static void ene_ub6250_info_destructor(void *extra)\r\n{\r\nif (!extra)\r\nreturn;\r\n}\r\nstatic int ene_send_scsi_cmd(struct us_data *us, u8 fDir, void *buf, int use_sg)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nstruct bulk_cs_wrap *bcs = (struct bulk_cs_wrap *) us->iobuf;\r\nint result;\r\nunsigned int residue;\r\nunsigned int cswlen = 0, partial = 0;\r\nunsigned int transfer_length = bcb->DataTransferLength;\r\nresult = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\nbcb, US_BULK_CB_WRAP_LEN, NULL);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "send cmd to out endpoint fail ---\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (buf) {\r\nunsigned int pipe = fDir;\r\nif (fDir == FDIR_READ)\r\npipe = us->recv_bulk_pipe;\r\nelse\r\npipe = us->send_bulk_pipe;\r\nif (use_sg) {\r\nresult = usb_stor_bulk_srb(us, pipe, us->srb);\r\n} else {\r\nresult = usb_stor_bulk_transfer_sg(us, pipe, buf,\r\ntransfer_length, 0, &partial);\r\n}\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "data transfer fail ---\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\n}\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe, bcs,\r\nUS_BULK_CS_WRAP_LEN, &cswlen);\r\nif (result == USB_STOR_XFER_SHORT && cswlen == 0) {\r\nusb_stor_dbg(us, "Received 0-length CSW; retrying...\n");\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\nbcs, US_BULK_CS_WRAP_LEN, &cswlen);\r\n}\r\nif (result == USB_STOR_XFER_STALLED) {\r\nusb_stor_dbg(us, "Attempting to get CSW (2nd try)...\n");\r\nresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\nbcs, US_BULK_CS_WRAP_LEN, NULL);\r\n}\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nresidue = le32_to_cpu(bcs->Residue);\r\nif (residue && !(us->fflags & US_FL_IGNORE_RESIDUE)) {\r\nresidue = min(residue, transfer_length);\r\nif (us->srb != NULL)\r\nscsi_set_resid(us->srb, max(scsi_get_resid(us->srb),\r\n(int)residue));\r\n}\r\nif (bcs->Status != US_BULK_STAT_OK)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif (info->SD_Status.Insert && info->SD_Status.Ready)\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nelse {\r\nene_sd_init(us);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int sd_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nunsigned char data_ptr[36] = {\r\n0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,\r\n0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,\r\n0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,\r\n0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30 };\r\nusb_stor_set_xfer_buf(data_ptr, 36, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int sd_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nunsigned char mediaNoWP[12] = {\r\n0x0b, 0x00, 0x00, 0x08, 0x00, 0x00,\r\n0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };\r\nunsigned char mediaWP[12] = {\r\n0x0b, 0x00, 0x80, 0x08, 0x00, 0x00,\r\n0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };\r\nif (info->SD_Status.WtP)\r\nusb_stor_set_xfer_buf(mediaWP, 12, srb);\r\nelse\r\nusb_stor_set_xfer_buf(mediaNoWP, 12, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int sd_scsi_read_capacity(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nu32 bl_num;\r\nu32 bl_len;\r\nunsigned int offset = 0;\r\nunsigned char buf[8];\r\nstruct scatterlist *sg = NULL;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nusb_stor_dbg(us, "sd_scsi_read_capacity\n");\r\nif (info->SD_Status.HiCapacity) {\r\nbl_len = 0x200;\r\nif (info->SD_Status.IsMMC)\r\nbl_num = info->HC_C_SIZE-1;\r\nelse\r\nbl_num = (info->HC_C_SIZE + 1) * 1024 - 1;\r\n} else {\r\nbl_len = 1 << (info->SD_READ_BL_LEN);\r\nbl_num = info->SD_Block_Mult * (info->SD_C_SIZE + 1)\r\n* (1 << (info->SD_C_SIZE_MULT + 2)) - 1;\r\n}\r\ninfo->bl_num = bl_num;\r\nusb_stor_dbg(us, "bl_len = %x\n", bl_len);\r\nusb_stor_dbg(us, "bl_num = %x\n", bl_num);\r\nbuf[0] = (bl_num >> 24) & 0xff;\r\nbuf[1] = (bl_num >> 16) & 0xff;\r\nbuf[2] = (bl_num >> 8) & 0xff;\r\nbuf[3] = (bl_num >> 0) & 0xff;\r\nbuf[4] = (bl_len >> 24) & 0xff;\r\nbuf[5] = (bl_len >> 16) & 0xff;\r\nbuf[6] = (bl_len >> 8) & 0xff;\r\nbuf[7] = (bl_len >> 0) & 0xff;\r\nusb_stor_access_xfer_buf(buf, 8, srb, &sg, &offset, TO_XFER_BUF);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int sd_scsi_read(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nint result;\r\nunsigned char *cdb = srb->cmnd;\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nu32 bn = ((cdb[2] << 24) & 0xff000000) | ((cdb[3] << 16) & 0x00ff0000) |\r\n((cdb[4] << 8) & 0x0000ff00) | ((cdb[5] << 0) & 0x000000ff);\r\nu16 blen = ((cdb[7] << 8) & 0xff00) | ((cdb[8] << 0) & 0x00ff);\r\nu32 bnByte = bn * 0x200;\r\nu32 blenByte = blen * 0x200;\r\nif (bn > info->bl_num)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nresult = ene_load_bincode(us, SD_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Load SD RW pattern Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (info->SD_Status.HiCapacity)\r\nbnByte = bn;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = blenByte;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[5] = (unsigned char)(bnByte);\r\nbcb->CDB[4] = (unsigned char)(bnByte>>8);\r\nbcb->CDB[3] = (unsigned char)(bnByte>>16);\r\nbcb->CDB[2] = (unsigned char)(bnByte>>24);\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, scsi_sglist(srb), 1);\r\nreturn result;\r\n}\r\nstatic int sd_scsi_write(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nint result;\r\nunsigned char *cdb = srb->cmnd;\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nu32 bn = ((cdb[2] << 24) & 0xff000000) | ((cdb[3] << 16) & 0x00ff0000) |\r\n((cdb[4] << 8) & 0x0000ff00) | ((cdb[5] << 0) & 0x000000ff);\r\nu16 blen = ((cdb[7] << 8) & 0xff00) | ((cdb[8] << 0) & 0x00ff);\r\nu32 bnByte = bn * 0x200;\r\nu32 blenByte = blen * 0x200;\r\nif (bn > info->bl_num)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nresult = ene_load_bincode(us, SD_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Load SD RW pattern Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (info->SD_Status.HiCapacity)\r\nbnByte = bn;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = blenByte;\r\nbcb->Flags = 0x00;\r\nbcb->CDB[0] = 0xF0;\r\nbcb->CDB[5] = (unsigned char)(bnByte);\r\nbcb->CDB[4] = (unsigned char)(bnByte>>8);\r\nbcb->CDB[3] = (unsigned char)(bnByte>>16);\r\nbcb->CDB[2] = (unsigned char)(bnByte>>24);\r\nresult = ene_send_scsi_cmd(us, FDIR_WRITE, scsi_sglist(srb), 1);\r\nreturn result;\r\n}\r\nstatic int ms_lib_set_logicalpair(struct us_data *us, u16 logblk, u16 phyblk)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif ((logblk >= info->MS_Lib.NumberOfLogBlock) || (phyblk >= info->MS_Lib.NumberOfPhyBlock))\r\nreturn (u32)-1;\r\ninfo->MS_Lib.Phy2LogMap[phyblk] = logblk;\r\ninfo->MS_Lib.Log2PhyMap[logblk] = phyblk;\r\nreturn 0;\r\n}\r\nstatic int ms_lib_set_logicalblockmark(struct us_data *us, u16 phyblk, u16 mark)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\r\nreturn (u32)-1;\r\ninfo->MS_Lib.Phy2LogMap[phyblk] = mark;\r\nreturn 0;\r\n}\r\nstatic int ms_lib_set_initialerrorblock(struct us_data *us, u16 phyblk)\r\n{\r\nreturn ms_lib_set_logicalblockmark(us, phyblk, MS_LB_INITIAL_ERROR);\r\n}\r\nstatic int ms_lib_set_bootblockmark(struct us_data *us, u16 phyblk)\r\n{\r\nreturn ms_lib_set_logicalblockmark(us, phyblk, MS_LB_BOOT_BLOCK);\r\n}\r\nstatic int ms_lib_free_logicalmap(struct us_data *us)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nkfree(info->MS_Lib.Phy2LogMap);\r\ninfo->MS_Lib.Phy2LogMap = NULL;\r\nkfree(info->MS_Lib.Log2PhyMap);\r\ninfo->MS_Lib.Log2PhyMap = NULL;\r\nreturn 0;\r\n}\r\nstatic int ms_lib_alloc_logicalmap(struct us_data *us)\r\n{\r\nu32 i;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\ninfo->MS_Lib.Phy2LogMap = kmalloc(info->MS_Lib.NumberOfPhyBlock * sizeof(u16), GFP_KERNEL);\r\ninfo->MS_Lib.Log2PhyMap = kmalloc(info->MS_Lib.NumberOfLogBlock * sizeof(u16), GFP_KERNEL);\r\nif ((info->MS_Lib.Phy2LogMap == NULL) || (info->MS_Lib.Log2PhyMap == NULL)) {\r\nms_lib_free_logicalmap(us);\r\nreturn (u32)-1;\r\n}\r\nfor (i = 0; i < info->MS_Lib.NumberOfPhyBlock; i++)\r\ninfo->MS_Lib.Phy2LogMap[i] = MS_LB_NOT_USED;\r\nfor (i = 0; i < info->MS_Lib.NumberOfLogBlock; i++)\r\ninfo->MS_Lib.Log2PhyMap[i] = MS_LB_NOT_USED;\r\nreturn 0;\r\n}\r\nstatic void ms_lib_clear_writebuf(struct us_data *us)\r\n{\r\nint i;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\ninfo->MS_Lib.wrtblk = (u16)-1;\r\nms_lib_clear_pagemap(info);\r\nif (info->MS_Lib.blkpag)\r\nmemset(info->MS_Lib.blkpag, 0xff, info->MS_Lib.PagesPerBlock * info->MS_Lib.BytesPerSector);\r\nif (info->MS_Lib.blkext) {\r\nfor (i = 0; i < info->MS_Lib.PagesPerBlock; i++) {\r\ninfo->MS_Lib.blkext[i].status1 = MS_REG_ST1_DEFAULT;\r\ninfo->MS_Lib.blkext[i].ovrflg = MS_REG_OVR_DEFAULT;\r\ninfo->MS_Lib.blkext[i].mngflg = MS_REG_MNG_DEFAULT;\r\ninfo->MS_Lib.blkext[i].logadr = MS_LB_NOT_USED;\r\n}\r\n}\r\n}\r\nstatic int ms_count_freeblock(struct us_data *us, u16 PhyBlock)\r\n{\r\nu32 Ende, Count;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nEnde = PhyBlock + MS_PHYSICAL_BLOCKS_PER_SEGMENT;\r\nfor (Count = 0; PhyBlock < Ende; PhyBlock++) {\r\nswitch (info->MS_Lib.Phy2LogMap[PhyBlock]) {\r\ncase MS_LB_NOT_USED:\r\ncase MS_LB_NOT_USED_ERASED:\r\nCount++;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn Count;\r\n}\r\nstatic int ms_read_readpage(struct us_data *us, u32 PhyBlockAddr,\r\nu8 PageNum, u32 *PageBuf, struct ms_lib_type_extdat *ExtraDat)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nu8 ExtBuf[4];\r\nu32 bn = PhyBlockAddr * 0x20 + PageNum;\r\nresult = ene_load_bincode(us, MS_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x02;\r\nbcb->CDB[5] = (unsigned char)(bn);\r\nbcb->CDB[4] = (unsigned char)(bn>>8);\r\nbcb->CDB[3] = (unsigned char)(bn>>16);\r\nbcb->CDB[2] = (unsigned char)(bn>>24);\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, PageBuf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x4;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x03;\r\nbcb->CDB[5] = (unsigned char)(PageNum);\r\nbcb->CDB[4] = (unsigned char)(PhyBlockAddr);\r\nbcb->CDB[3] = (unsigned char)(PhyBlockAddr>>8);\r\nbcb->CDB[2] = (unsigned char)(PhyBlockAddr>>16);\r\nbcb->CDB[6] = 0x01;\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, &ExtBuf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nExtraDat->reserved = 0;\r\nExtraDat->intr = 0x80;\r\nExtraDat->status0 = 0x10;\r\nExtraDat->status1 = 0x00;\r\nExtraDat->ovrflg = ExtBuf[0];\r\nExtraDat->mngflg = ExtBuf[1];\r\nExtraDat->logadr = memstick_logaddr(ExtBuf[2], ExtBuf[3]);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_lib_process_bootblock(struct us_data *us, u16 PhyBlock, u8 *PageData)\r\n{\r\nstruct ms_bootblock_sysent *SysEntry;\r\nstruct ms_bootblock_sysinf *SysInfo;\r\nu32 i, result;\r\nu8 PageNumber;\r\nu8 *PageBuffer;\r\nstruct ms_lib_type_extdat ExtraData;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nPageBuffer = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\r\nif (PageBuffer == NULL)\r\nreturn (u32)-1;\r\nresult = (u32)-1;\r\nSysInfo = &(((struct ms_bootblock_page0 *)PageData)->sysinf);\r\nif ((SysInfo->bMsClass != MS_SYSINF_MSCLASS_TYPE_1) ||\r\n(be16_to_cpu(SysInfo->wPageSize) != MS_SYSINF_PAGE_SIZE) ||\r\n((SysInfo->bSecuritySupport & MS_SYSINF_SECURITY) == MS_SYSINF_SECURITY_SUPPORT) ||\r\n(SysInfo->bReserved1 != MS_SYSINF_RESERVED1) ||\r\n(SysInfo->bReserved2 != MS_SYSINF_RESERVED2) ||\r\n(SysInfo->bFormatType != MS_SYSINF_FORMAT_FAT) ||\r\n(SysInfo->bUsage != MS_SYSINF_USAGE_GENERAL))\r\ngoto exit;\r\nswitch (info->MS_Lib.cardType = SysInfo->bCardType) {\r\ncase MS_SYSINF_CARDTYPE_RDONLY:\r\nms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);\r\nbreak;\r\ncase MS_SYSINF_CARDTYPE_RDWR:\r\nms_lib_ctrl_reset(info, MS_LIB_CTRL_RDONLY);\r\nbreak;\r\ncase MS_SYSINF_CARDTYPE_HYBRID:\r\ndefault:\r\ngoto exit;\r\n}\r\ninfo->MS_Lib.blockSize = be16_to_cpu(SysInfo->wBlockSize);\r\ninfo->MS_Lib.NumberOfPhyBlock = be16_to_cpu(SysInfo->wBlockNumber);\r\ninfo->MS_Lib.NumberOfLogBlock = be16_to_cpu(SysInfo->wTotalBlockNumber)-2;\r\ninfo->MS_Lib.PagesPerBlock = info->MS_Lib.blockSize * SIZE_OF_KIRO / MS_BYTES_PER_PAGE;\r\ninfo->MS_Lib.NumberOfSegment = info->MS_Lib.NumberOfPhyBlock / MS_PHYSICAL_BLOCKS_PER_SEGMENT;\r\ninfo->MS_Model = be16_to_cpu(SysInfo->wMemorySize);\r\nif (ms_lib_alloc_logicalmap(us))\r\ngoto exit;\r\nms_lib_set_bootblockmark(us, PhyBlock);\r\nSysEntry = &(((struct ms_bootblock_page0 *)PageData)->sysent);\r\nfor (i = 0; i < MS_NUMBER_OF_SYSTEM_ENTRY; i++) {\r\nu32 EntryOffset, EntrySize;\r\nEntryOffset = be32_to_cpu(SysEntry->entry[i].dwStart);\r\nif (EntryOffset == 0xffffff)\r\ncontinue;\r\nEntrySize = be32_to_cpu(SysEntry->entry[i].dwSize);\r\nif (EntrySize == 0)\r\ncontinue;\r\nif (EntryOffset + MS_BYTES_PER_PAGE + EntrySize > info->MS_Lib.blockSize * (u32)SIZE_OF_KIRO)\r\ncontinue;\r\nif (i == 0) {\r\nu8 PrevPageNumber = 0;\r\nu16 phyblk;\r\nif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_INVALID_BLOCK)\r\ngoto exit;\r\nwhile (EntrySize > 0) {\r\nPageNumber = (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1);\r\nif (PageNumber != PrevPageNumber) {\r\nswitch (ms_read_readpage(us, PhyBlock, PageNumber, (u32 *)PageBuffer, &ExtraData)) {\r\ncase MS_STATUS_SUCCESS:\r\nbreak;\r\ncase MS_STATUS_WRITE_PROTECT:\r\ncase MS_ERROR_FLASH_READ:\r\ncase MS_STATUS_ERROR:\r\ndefault:\r\ngoto exit;\r\n}\r\nPrevPageNumber = PageNumber;\r\n}\r\nphyblk = be16_to_cpu(*(u16 *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)));\r\nif (phyblk < 0x0fff)\r\nms_lib_set_initialerrorblock(us, phyblk);\r\nEntryOffset += 2;\r\nEntrySize -= 2;\r\n}\r\n} else if (i == 1) {\r\nstruct ms_bootblock_idi *idi;\r\nif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_CIS_IDI)\r\ngoto exit;\r\nswitch (ms_read_readpage(us, PhyBlock, (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1), (u32 *)PageBuffer, &ExtraData)) {\r\ncase MS_STATUS_SUCCESS:\r\nbreak;\r\ncase MS_STATUS_WRITE_PROTECT:\r\ncase MS_ERROR_FLASH_READ:\r\ncase MS_STATUS_ERROR:\r\ndefault:\r\ngoto exit;\r\n}\r\nidi = &((struct ms_bootblock_cis_idi *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)))->idi.idi;\r\nif (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)\r\ngoto exit;\r\ninfo->MS_Lib.BytesPerSector = le16_to_cpu(idi->wIDIbytesPerSector);\r\nif (info->MS_Lib.BytesPerSector != MS_BYTES_PER_PAGE)\r\ngoto exit;\r\n}\r\n}\r\nresult = 0;\r\nexit:\r\nif (result)\r\nms_lib_free_logicalmap(us);\r\nkfree(PageBuffer);\r\nresult = 0;\r\nreturn result;\r\n}\r\nstatic void ms_lib_free_writebuf(struct us_data *us)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\ninfo->MS_Lib.wrtblk = (u16)-1;\r\nms_lib_clear_pagemap(info);\r\nif (info->MS_Lib.blkpag) {\r\nkfree((u8 *)(info->MS_Lib.blkpag));\r\ninfo->MS_Lib.blkpag = NULL;\r\n}\r\nif (info->MS_Lib.blkext) {\r\nkfree((u8 *)(info->MS_Lib.blkext));\r\ninfo->MS_Lib.blkext = NULL;\r\n}\r\n}\r\nstatic void ms_lib_free_allocatedarea(struct us_data *us)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nms_lib_free_writebuf(us);\r\nms_lib_free_logicalmap(us);\r\ninfo->MS_Lib.flags = 0;\r\ninfo->MS_Lib.BytesPerSector = 0;\r\ninfo->MS_Lib.SectorsPerCylinder = 0;\r\ninfo->MS_Lib.cardType = 0;\r\ninfo->MS_Lib.blockSize = 0;\r\ninfo->MS_Lib.PagesPerBlock = 0;\r\ninfo->MS_Lib.NumberOfPhyBlock = 0;\r\ninfo->MS_Lib.NumberOfLogBlock = 0;\r\n}\r\nstatic int ms_lib_alloc_writebuf(struct us_data *us)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\ninfo->MS_Lib.wrtblk = (u16)-1;\r\ninfo->MS_Lib.blkpag = kmalloc(info->MS_Lib.PagesPerBlock * info->MS_Lib.BytesPerSector, GFP_KERNEL);\r\ninfo->MS_Lib.blkext = kmalloc(info->MS_Lib.PagesPerBlock * sizeof(struct ms_lib_type_extdat), GFP_KERNEL);\r\nif ((info->MS_Lib.blkpag == NULL) || (info->MS_Lib.blkext == NULL)) {\r\nms_lib_free_writebuf(us);\r\nreturn (u32)-1;\r\n}\r\nms_lib_clear_writebuf(us);\r\nreturn 0;\r\n}\r\nstatic int ms_lib_force_setlogical_pair(struct us_data *us, u16 logblk, u16 phyblk)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif (logblk == MS_LB_NOT_USED)\r\nreturn 0;\r\nif ((logblk >= info->MS_Lib.NumberOfLogBlock) ||\r\n(phyblk >= info->MS_Lib.NumberOfPhyBlock))\r\nreturn (u32)-1;\r\ninfo->MS_Lib.Phy2LogMap[phyblk] = logblk;\r\ninfo->MS_Lib.Log2PhyMap[logblk] = phyblk;\r\nreturn 0;\r\n}\r\nstatic int ms_read_copyblock(struct us_data *us, u16 oldphy, u16 newphy,\r\nu16 PhyBlockAddr, u8 PageNum, unsigned char *buf, u16 len)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nresult = ene_load_bincode(us, MS_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200*len;\r\nbcb->Flags = 0x00;\r\nbcb->CDB[0] = 0xF0;\r\nbcb->CDB[1] = 0x08;\r\nbcb->CDB[4] = (unsigned char)(oldphy);\r\nbcb->CDB[3] = (unsigned char)(oldphy>>8);\r\nbcb->CDB[2] = 0;\r\nbcb->CDB[7] = (unsigned char)(newphy);\r\nbcb->CDB[6] = (unsigned char)(newphy>>8);\r\nbcb->CDB[5] = 0;\r\nbcb->CDB[9] = (unsigned char)(PhyBlockAddr);\r\nbcb->CDB[8] = (unsigned char)(PhyBlockAddr>>8);\r\nbcb->CDB[10] = PageNum;\r\nresult = ene_send_scsi_cmd(us, FDIR_WRITE, buf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_read_eraseblock(struct us_data *us, u32 PhyBlockAddr)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nu32 bn = PhyBlockAddr;\r\nresult = ene_load_bincode(us, MS_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF2;\r\nbcb->CDB[1] = 0x06;\r\nbcb->CDB[4] = (unsigned char)(bn);\r\nbcb->CDB[3] = (unsigned char)(bn>>8);\r\nbcb->CDB[2] = (unsigned char)(bn>>16);\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, NULL, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_lib_check_disableblock(struct us_data *us, u16 PhyBlock)\r\n{\r\nunsigned char *PageBuf = NULL;\r\nu16 result = MS_STATUS_SUCCESS;\r\nu16 blk, index = 0;\r\nstruct ms_lib_type_extdat extdat;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nPageBuf = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\r\nif (PageBuf == NULL) {\r\nresult = MS_NO_MEMORY_ERROR;\r\ngoto exit;\r\n}\r\nms_read_readpage(us, PhyBlock, 1, (u32 *)PageBuf, &extdat);\r\ndo {\r\nblk = be16_to_cpu(PageBuf[index]);\r\nif (blk == MS_LB_NOT_USED)\r\nbreak;\r\nif (blk == info->MS_Lib.Log2PhyMap[0]) {\r\nresult = MS_ERROR_FLASH_READ;\r\nbreak;\r\n}\r\nindex++;\r\n} while (1);\r\nexit:\r\nkfree(PageBuf);\r\nreturn result;\r\n}\r\nstatic int ms_lib_setacquired_errorblock(struct us_data *us, u16 phyblk)\r\n{\r\nu16 log;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\r\nreturn (u32)-1;\r\nlog = info->MS_Lib.Phy2LogMap[phyblk];\r\nif (log < info->MS_Lib.NumberOfLogBlock)\r\ninfo->MS_Lib.Log2PhyMap[log] = MS_LB_NOT_USED;\r\nif (info->MS_Lib.Phy2LogMap[phyblk] != MS_LB_INITIAL_ERROR)\r\ninfo->MS_Lib.Phy2LogMap[phyblk] = MS_LB_ACQUIRED_ERROR;\r\nreturn 0;\r\n}\r\nstatic int ms_lib_overwrite_extra(struct us_data *us, u32 PhyBlockAddr,\r\nu8 PageNum, u8 OverwriteFlag)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nresult = ene_load_bincode(us, MS_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x4;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF2;\r\nbcb->CDB[1] = 0x05;\r\nbcb->CDB[5] = (unsigned char)(PageNum);\r\nbcb->CDB[4] = (unsigned char)(PhyBlockAddr);\r\nbcb->CDB[3] = (unsigned char)(PhyBlockAddr>>8);\r\nbcb->CDB[2] = (unsigned char)(PhyBlockAddr>>16);\r\nbcb->CDB[6] = OverwriteFlag;\r\nbcb->CDB[7] = 0xFF;\r\nbcb->CDB[8] = 0xFF;\r\nbcb->CDB[9] = 0xFF;\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, NULL, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_lib_error_phyblock(struct us_data *us, u16 phyblk)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\r\nreturn MS_STATUS_ERROR;\r\nms_lib_setacquired_errorblock(us, phyblk);\r\nif (ms_lib_iswritable(info))\r\nreturn ms_lib_overwrite_extra(us, phyblk, 0, (u8)(~MS_REG_OVR_BKST & BYTE_MASK));\r\nreturn MS_STATUS_SUCCESS;\r\n}\r\nstatic int ms_lib_erase_phyblock(struct us_data *us, u16 phyblk)\r\n{\r\nu16 log;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\r\nreturn MS_STATUS_ERROR;\r\nlog = info->MS_Lib.Phy2LogMap[phyblk];\r\nif (log < info->MS_Lib.NumberOfLogBlock)\r\ninfo->MS_Lib.Log2PhyMap[log] = MS_LB_NOT_USED;\r\ninfo->MS_Lib.Phy2LogMap[phyblk] = MS_LB_NOT_USED;\r\nif (ms_lib_iswritable(info)) {\r\nswitch (ms_read_eraseblock(us, phyblk)) {\r\ncase MS_STATUS_SUCCESS:\r\ninfo->MS_Lib.Phy2LogMap[phyblk] = MS_LB_NOT_USED_ERASED;\r\nreturn MS_STATUS_SUCCESS;\r\ncase MS_ERROR_FLASH_ERASE:\r\ncase MS_STATUS_INT_ERROR:\r\nms_lib_error_phyblock(us, phyblk);\r\nreturn MS_ERROR_FLASH_ERASE;\r\ncase MS_STATUS_ERROR:\r\ndefault:\r\nms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);\r\nms_lib_setacquired_errorblock(us, phyblk);\r\nreturn MS_STATUS_ERROR;\r\n}\r\n}\r\nms_lib_setacquired_errorblock(us, phyblk);\r\nreturn MS_STATUS_SUCCESS;\r\n}\r\nstatic int ms_lib_read_extra(struct us_data *us, u32 PhyBlock,\r\nu8 PageNum, struct ms_lib_type_extdat *ExtraDat)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nu8 ExtBuf[4];\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x4;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x03;\r\nbcb->CDB[5] = (unsigned char)(PageNum);\r\nbcb->CDB[4] = (unsigned char)(PhyBlock);\r\nbcb->CDB[3] = (unsigned char)(PhyBlock>>8);\r\nbcb->CDB[2] = (unsigned char)(PhyBlock>>16);\r\nbcb->CDB[6] = 0x01;\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, &ExtBuf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nExtraDat->reserved = 0;\r\nExtraDat->intr = 0x80;\r\nExtraDat->status0 = 0x10;\r\nExtraDat->status1 = 0x00;\r\nExtraDat->ovrflg = ExtBuf[0];\r\nExtraDat->mngflg = ExtBuf[1];\r\nExtraDat->logadr = memstick_logaddr(ExtBuf[2], ExtBuf[3]);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_libsearch_block_from_physical(struct us_data *us, u16 phyblk)\r\n{\r\nu16 Newblk;\r\nu16 blk;\r\nstruct ms_lib_type_extdat extdat;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\r\nreturn MS_LB_ERROR;\r\nfor (blk = phyblk + 1; blk != phyblk; blk++) {\r\nif ((blk & MS_PHYSICAL_BLOCKS_PER_SEGMENT_MASK) == 0)\r\nblk -= MS_PHYSICAL_BLOCKS_PER_SEGMENT;\r\nNewblk = info->MS_Lib.Phy2LogMap[blk];\r\nif (info->MS_Lib.Phy2LogMap[blk] == MS_LB_NOT_USED_ERASED) {\r\nreturn blk;\r\n} else if (info->MS_Lib.Phy2LogMap[blk] == MS_LB_NOT_USED) {\r\nswitch (ms_lib_read_extra(us, blk, 0, &extdat)) {\r\ncase MS_STATUS_SUCCESS:\r\ncase MS_STATUS_SUCCESS_WITH_ECC:\r\nbreak;\r\ncase MS_NOCARD_ERROR:\r\nreturn MS_NOCARD_ERROR;\r\ncase MS_STATUS_INT_ERROR:\r\nreturn MS_LB_ERROR;\r\ncase MS_ERROR_FLASH_READ:\r\ndefault:\r\nms_lib_setacquired_errorblock(us, blk);\r\ncontinue;\r\n}\r\nif ((extdat.ovrflg & MS_REG_OVR_BKST) != MS_REG_OVR_BKST_OK) {\r\nms_lib_setacquired_errorblock(us, blk);\r\ncontinue;\r\n}\r\nswitch (ms_lib_erase_phyblock(us, blk)) {\r\ncase MS_STATUS_SUCCESS:\r\nreturn blk;\r\ncase MS_STATUS_ERROR:\r\nreturn MS_LB_ERROR;\r\ncase MS_ERROR_FLASH_ERASE:\r\ndefault:\r\nms_lib_error_phyblock(us, blk);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn MS_LB_ERROR;\r\n}\r\nstatic int ms_libsearch_block_from_logical(struct us_data *us, u16 logblk)\r\n{\r\nu16 phyblk;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nphyblk = ms_libconv_to_physical(info, logblk);\r\nif (phyblk >= MS_LB_ERROR) {\r\nif (logblk >= info->MS_Lib.NumberOfLogBlock)\r\nreturn MS_LB_ERROR;\r\nphyblk = (logblk + MS_NUMBER_OF_BOOT_BLOCK) / MS_LOGICAL_BLOCKS_PER_SEGMENT;\r\nphyblk *= MS_PHYSICAL_BLOCKS_PER_SEGMENT;\r\nphyblk += MS_PHYSICAL_BLOCKS_PER_SEGMENT - 1;\r\n}\r\nreturn ms_libsearch_block_from_physical(us, phyblk);\r\n}\r\nstatic int ms_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\r\nif (info->MS_Status.Insert && info->MS_Status.Ready) {\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n} else {\r\nene_ms_init(us);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nunsigned char data_ptr[36] = {\r\n0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,\r\n0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,\r\n0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,\r\n0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30};\r\nusb_stor_set_xfer_buf(data_ptr, 36, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nunsigned char mediaNoWP[12] = {\r\n0x0b, 0x00, 0x00, 0x08, 0x00, 0x00,\r\n0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };\r\nunsigned char mediaWP[12] = {\r\n0x0b, 0x00, 0x80, 0x08, 0x00, 0x00,\r\n0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };\r\nif (info->MS_Status.WtP)\r\nusb_stor_set_xfer_buf(mediaWP, 12, srb);\r\nelse\r\nusb_stor_set_xfer_buf(mediaNoWP, 12, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_scsi_read_capacity(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nu32 bl_num;\r\nu16 bl_len;\r\nunsigned int offset = 0;\r\nunsigned char buf[8];\r\nstruct scatterlist *sg = NULL;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nusb_stor_dbg(us, "ms_scsi_read_capacity\n");\r\nbl_len = 0x200;\r\nif (info->MS_Status.IsMSPro)\r\nbl_num = info->MSP_TotalBlock - 1;\r\nelse\r\nbl_num = info->MS_Lib.NumberOfLogBlock * info->MS_Lib.blockSize * 2 - 1;\r\ninfo->bl_num = bl_num;\r\nusb_stor_dbg(us, "bl_len = %x\n", bl_len);\r\nusb_stor_dbg(us, "bl_num = %x\n", bl_num);\r\nbuf[0] = (bl_num >> 24) & 0xff;\r\nbuf[1] = (bl_num >> 16) & 0xff;\r\nbuf[2] = (bl_num >> 8) & 0xff;\r\nbuf[3] = (bl_num >> 0) & 0xff;\r\nbuf[4] = (bl_len >> 24) & 0xff;\r\nbuf[5] = (bl_len >> 16) & 0xff;\r\nbuf[6] = (bl_len >> 8) & 0xff;\r\nbuf[7] = (bl_len >> 0) & 0xff;\r\nusb_stor_access_xfer_buf(buf, 8, srb, &sg, &offset, TO_XFER_BUF);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic void ms_lib_phy_to_log_range(u16 PhyBlock, u16 *LogStart, u16 *LogEnde)\r\n{\r\nPhyBlock /= MS_PHYSICAL_BLOCKS_PER_SEGMENT;\r\nif (PhyBlock) {\r\n*LogStart = MS_LOGICAL_BLOCKS_IN_1ST_SEGMENT + (PhyBlock - 1) * MS_LOGICAL_BLOCKS_PER_SEGMENT;\r\n*LogEnde = *LogStart + MS_LOGICAL_BLOCKS_PER_SEGMENT;\r\n} else {\r\n*LogStart = 0;\r\n*LogEnde = MS_LOGICAL_BLOCKS_IN_1ST_SEGMENT;\r\n}\r\n}\r\nstatic int ms_lib_read_extrablock(struct us_data *us, u32 PhyBlock,\r\nu8 PageNum, u8 blen, void *buf)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x4 * blen;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x03;\r\nbcb->CDB[5] = (unsigned char)(PageNum);\r\nbcb->CDB[4] = (unsigned char)(PhyBlock);\r\nbcb->CDB[3] = (unsigned char)(PhyBlock>>8);\r\nbcb->CDB[2] = (unsigned char)(PhyBlock>>16);\r\nbcb->CDB[6] = blen;\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, buf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ms_lib_scan_logicalblocknumber(struct us_data *us, u16 btBlk1st)\r\n{\r\nu16 PhyBlock, newblk, i;\r\nu16 LogStart, LogEnde;\r\nstruct ms_lib_type_extdat extdat;\r\nu8 buf[0x200];\r\nu32 count = 0, index = 0;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nfor (PhyBlock = 0; PhyBlock < info->MS_Lib.NumberOfPhyBlock;) {\r\nms_lib_phy_to_log_range(PhyBlock, &LogStart, &LogEnde);\r\nfor (i = 0; i < MS_PHYSICAL_BLOCKS_PER_SEGMENT; i++, PhyBlock++) {\r\nswitch (ms_libconv_to_logical(info, PhyBlock)) {\r\ncase MS_STATUS_ERROR:\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\nif (count == PhyBlock) {\r\nms_lib_read_extrablock(us, PhyBlock, 0, 0x80, &buf);\r\ncount += 0x80;\r\n}\r\nindex = (PhyBlock % 0x80) * 4;\r\nextdat.ovrflg = buf[index];\r\nextdat.mngflg = buf[index+1];\r\nextdat.logadr = memstick_logaddr(buf[index+2], buf[index+3]);\r\nif ((extdat.ovrflg & MS_REG_OVR_BKST) != MS_REG_OVR_BKST_OK) {\r\nms_lib_setacquired_errorblock(us, PhyBlock);\r\ncontinue;\r\n}\r\nif ((extdat.mngflg & MS_REG_MNG_ATFLG) == MS_REG_MNG_ATFLG_ATTBL) {\r\nms_lib_erase_phyblock(us, PhyBlock);\r\ncontinue;\r\n}\r\nif (extdat.logadr != MS_LB_NOT_USED) {\r\nif ((extdat.logadr < LogStart) || (LogEnde <= extdat.logadr)) {\r\nms_lib_erase_phyblock(us, PhyBlock);\r\ncontinue;\r\n}\r\nnewblk = ms_libconv_to_physical(info, extdat.logadr);\r\nif (newblk != MS_LB_NOT_USED) {\r\nif (extdat.logadr == 0) {\r\nms_lib_set_logicalpair(us, extdat.logadr, PhyBlock);\r\nif (ms_lib_check_disableblock(us, btBlk1st)) {\r\nms_lib_set_logicalpair(us, extdat.logadr, newblk);\r\ncontinue;\r\n}\r\n}\r\nms_lib_read_extra(us, newblk, 0, &extdat);\r\nif ((extdat.ovrflg & MS_REG_OVR_UDST) == MS_REG_OVR_UDST_UPDATING) {\r\nms_lib_erase_phyblock(us, PhyBlock);\r\ncontinue;\r\n} else {\r\nms_lib_erase_phyblock(us, newblk);\r\n}\r\n}\r\nms_lib_set_logicalpair(us, extdat.logadr, PhyBlock);\r\n}\r\n}\r\n}\r\nreturn MS_STATUS_SUCCESS;\r\n}\r\nstatic int ms_scsi_read(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nint result;\r\nunsigned char *cdb = srb->cmnd;\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nu32 bn = ((cdb[2] << 24) & 0xff000000) | ((cdb[3] << 16) & 0x00ff0000) |\r\n((cdb[4] << 8) & 0x0000ff00) | ((cdb[5] << 0) & 0x000000ff);\r\nu16 blen = ((cdb[7] << 8) & 0xff00) | ((cdb[8] << 0) & 0x00ff);\r\nu32 blenByte = blen * 0x200;\r\nif (bn > info->bl_num)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (info->MS_Status.IsMSPro) {\r\nresult = ene_load_bincode(us, MSP_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Load MPS RW pattern Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = blenByte;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x02;\r\nbcb->CDB[5] = (unsigned char)(bn);\r\nbcb->CDB[4] = (unsigned char)(bn>>8);\r\nbcb->CDB[3] = (unsigned char)(bn>>16);\r\nbcb->CDB[2] = (unsigned char)(bn>>24);\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, scsi_sglist(srb), 1);\r\n} else {\r\nvoid *buf;\r\nint offset = 0;\r\nu16 phyblk, logblk;\r\nu8 PageNum;\r\nu16 len;\r\nu32 blkno;\r\nbuf = kmalloc(blenByte, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nresult = ene_load_bincode(us, MS_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\npr_info("Load MS RW pattern Fail !!\n");\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto exit;\r\n}\r\nlogblk = (u16)(bn / info->MS_Lib.PagesPerBlock);\r\nPageNum = (u8)(bn % info->MS_Lib.PagesPerBlock);\r\nwhile (1) {\r\nif (blen > (info->MS_Lib.PagesPerBlock-PageNum))\r\nlen = info->MS_Lib.PagesPerBlock-PageNum;\r\nelse\r\nlen = blen;\r\nphyblk = ms_libconv_to_physical(info, logblk);\r\nblkno = phyblk * 0x20 + PageNum;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200 * len;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x02;\r\nbcb->CDB[5] = (unsigned char)(blkno);\r\nbcb->CDB[4] = (unsigned char)(blkno>>8);\r\nbcb->CDB[3] = (unsigned char)(blkno>>16);\r\nbcb->CDB[2] = (unsigned char)(blkno>>24);\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, buf+offset, 0);\r\nif (result != USB_STOR_XFER_GOOD) {\r\npr_info("MS_SCSI_Read --- result = %x\n", result);\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto exit;\r\n}\r\nblen -= len;\r\nif (blen <= 0)\r\nbreak;\r\nlogblk++;\r\nPageNum = 0;\r\noffset += MS_BYTES_PER_PAGE*len;\r\n}\r\nusb_stor_set_xfer_buf(buf, blenByte, srb);\r\nexit:\r\nkfree(buf);\r\n}\r\nreturn result;\r\n}\r\nstatic int ms_scsi_write(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nint result;\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nunsigned char *cdb = srb->cmnd;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nu32 bn = ((cdb[2] << 24) & 0xff000000) |\r\n((cdb[3] << 16) & 0x00ff0000) |\r\n((cdb[4] << 8) & 0x0000ff00) |\r\n((cdb[5] << 0) & 0x000000ff);\r\nu16 blen = ((cdb[7] << 8) & 0xff00) | ((cdb[8] << 0) & 0x00ff);\r\nu32 blenByte = blen * 0x200;\r\nif (bn > info->bl_num)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (info->MS_Status.IsMSPro) {\r\nresult = ene_load_bincode(us, MSP_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\npr_info("Load MSP RW pattern Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = blenByte;\r\nbcb->Flags = 0x00;\r\nbcb->CDB[0] = 0xF0;\r\nbcb->CDB[1] = 0x04;\r\nbcb->CDB[5] = (unsigned char)(bn);\r\nbcb->CDB[4] = (unsigned char)(bn>>8);\r\nbcb->CDB[3] = (unsigned char)(bn>>16);\r\nbcb->CDB[2] = (unsigned char)(bn>>24);\r\nresult = ene_send_scsi_cmd(us, FDIR_WRITE, scsi_sglist(srb), 1);\r\n} else {\r\nvoid *buf;\r\nint offset = 0;\r\nu16 PhyBlockAddr;\r\nu8 PageNum;\r\nu16 len, oldphy, newphy;\r\nbuf = kmalloc(blenByte, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nusb_stor_set_xfer_buf(buf, blenByte, srb);\r\nresult = ene_load_bincode(us, MS_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\npr_info("Load MS RW pattern Fail !!\n");\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto exit;\r\n}\r\nPhyBlockAddr = (u16)(bn / info->MS_Lib.PagesPerBlock);\r\nPageNum = (u8)(bn % info->MS_Lib.PagesPerBlock);\r\nwhile (1) {\r\nif (blen > (info->MS_Lib.PagesPerBlock-PageNum))\r\nlen = info->MS_Lib.PagesPerBlock-PageNum;\r\nelse\r\nlen = blen;\r\noldphy = ms_libconv_to_physical(info, PhyBlockAddr);\r\nnewphy = ms_libsearch_block_from_logical(us, PhyBlockAddr);\r\nresult = ms_read_copyblock(us, oldphy, newphy, PhyBlockAddr, PageNum, buf+offset, len);\r\nif (result != USB_STOR_XFER_GOOD) {\r\npr_info("MS_SCSI_Write --- result = %x\n", result);\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto exit;\r\n}\r\ninfo->MS_Lib.Phy2LogMap[oldphy] = MS_LB_NOT_USED_ERASED;\r\nms_lib_force_setlogical_pair(us, PhyBlockAddr, newphy);\r\nblen -= len;\r\nif (blen <= 0)\r\nbreak;\r\nPhyBlockAddr++;\r\nPageNum = 0;\r\noffset += MS_BYTES_PER_PAGE*len;\r\n}\r\nexit:\r\nkfree(buf);\r\n}\r\nreturn result;\r\n}\r\nstatic int ene_get_card_type(struct us_data *us, u16 index, void *buf)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x01;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xED;\r\nbcb->CDB[2] = (unsigned char)(index>>8);\r\nbcb->CDB[3] = (unsigned char)index;\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, buf, 0);\r\nreturn result;\r\n}\r\nstatic int ene_get_card_status(struct us_data *us, u8 *buf)\r\n{\r\nu16 tmpreg;\r\nu32 reg4b;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nreg4b = *(u32 *)&buf[0x18];\r\ninfo->SD_READ_BL_LEN = (u8)((reg4b >> 8) & 0x0f);\r\ntmpreg = (u16) reg4b;\r\nreg4b = *(u32 *)(&buf[0x14]);\r\nif (info->SD_Status.HiCapacity && !info->SD_Status.IsMMC)\r\ninfo->HC_C_SIZE = (reg4b >> 8) & 0x3fffff;\r\ninfo->SD_C_SIZE = ((tmpreg & 0x03) << 10) | (u16)(reg4b >> 22);\r\ninfo->SD_C_SIZE_MULT = (u8)(reg4b >> 7) & 0x07;\r\nif (info->SD_Status.HiCapacity && info->SD_Status.IsMMC)\r\ninfo->HC_C_SIZE = *(u32 *)(&buf[0x100]);\r\nif (info->SD_READ_BL_LEN > SD_BLOCK_LEN) {\r\ninfo->SD_Block_Mult = 1 << (info->SD_READ_BL_LEN-SD_BLOCK_LEN);\r\ninfo->SD_READ_BL_LEN = SD_BLOCK_LEN;\r\n} else {\r\ninfo->SD_Block_Mult = 1;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ene_load_bincode(struct us_data *us, unsigned char flag)\r\n{\r\nint err;\r\nchar *fw_name = NULL;\r\nunsigned char *buf = NULL;\r\nconst struct firmware *sd_fw = NULL;\r\nint result = USB_STOR_TRANSPORT_ERROR;\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nif (info->BIN_FLAG == flag)\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nswitch (flag) {\r\ncase SD_INIT1_PATTERN:\r\nusb_stor_dbg(us, "SD_INIT1_PATTERN\n");\r\nfw_name = SD_INIT1_FIRMWARE;\r\nbreak;\r\ncase SD_INIT2_PATTERN:\r\nusb_stor_dbg(us, "SD_INIT2_PATTERN\n");\r\nfw_name = SD_INIT2_FIRMWARE;\r\nbreak;\r\ncase SD_RW_PATTERN:\r\nusb_stor_dbg(us, "SD_RW_PATTERN\n");\r\nfw_name = SD_RW_FIRMWARE;\r\nbreak;\r\ncase MS_INIT_PATTERN:\r\nusb_stor_dbg(us, "MS_INIT_PATTERN\n");\r\nfw_name = MS_INIT_FIRMWARE;\r\nbreak;\r\ncase MSP_RW_PATTERN:\r\nusb_stor_dbg(us, "MSP_RW_PATTERN\n");\r\nfw_name = MSP_RW_FIRMWARE;\r\nbreak;\r\ncase MS_RW_PATTERN:\r\nusb_stor_dbg(us, "MS_RW_PATTERN\n");\r\nfw_name = MS_RW_FIRMWARE;\r\nbreak;\r\ndefault:\r\nusb_stor_dbg(us, "----------- Unknown PATTERN ----------\n");\r\ngoto nofw;\r\n}\r\nerr = request_firmware(&sd_fw, fw_name, &us->pusb_dev->dev);\r\nif (err) {\r\nusb_stor_dbg(us, "load firmware %s failed\n", fw_name);\r\ngoto nofw;\r\n}\r\nbuf = kmemdup(sd_fw->data, sd_fw->size, GFP_KERNEL);\r\nif (buf == NULL)\r\ngoto nofw;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = sd_fw->size;\r\nbcb->Flags = 0x00;\r\nbcb->CDB[0] = 0xEF;\r\nresult = ene_send_scsi_cmd(us, FDIR_WRITE, buf, 0);\r\ninfo->BIN_FLAG = flag;\r\nkfree(buf);\r\nnofw:\r\nrelease_firmware(sd_fw);\r\nreturn result;\r\n}\r\nstatic int ms_card_init(struct us_data *us)\r\n{\r\nu32 result;\r\nu16 TmpBlock;\r\nunsigned char *PageBuffer0 = NULL, *PageBuffer1 = NULL;\r\nstruct ms_lib_type_extdat extdat;\r\nu16 btBlk1st, btBlk2nd;\r\nu32 btBlk1stErred;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nprintk(KERN_INFO "MS_CardInit start\n");\r\nms_lib_free_allocatedarea(us);\r\nPageBuffer0 = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\r\nPageBuffer1 = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\r\nif ((PageBuffer0 == NULL) || (PageBuffer1 == NULL)) {\r\nresult = MS_NO_MEMORY_ERROR;\r\ngoto exit;\r\n}\r\nbtBlk1st = btBlk2nd = MS_LB_NOT_USED;\r\nbtBlk1stErred = 0;\r\nfor (TmpBlock = 0; TmpBlock < MS_MAX_INITIAL_ERROR_BLOCKS+2; TmpBlock++) {\r\nswitch (ms_read_readpage(us, TmpBlock, 0, (u32 *)PageBuffer0, &extdat)) {\r\ncase MS_STATUS_SUCCESS:\r\nbreak;\r\ncase MS_STATUS_INT_ERROR:\r\nbreak;\r\ncase MS_STATUS_ERROR:\r\ndefault:\r\ncontinue;\r\n}\r\nif ((extdat.ovrflg & MS_REG_OVR_BKST) == MS_REG_OVR_BKST_NG)\r\ncontinue;\r\nif (((extdat.mngflg & MS_REG_MNG_SYSFLG) == MS_REG_MNG_SYSFLG_USER) ||\r\n(be16_to_cpu(((struct ms_bootblock_page0 *)PageBuffer0)->header.wBlockID) != MS_BOOT_BLOCK_ID) ||\r\n(be16_to_cpu(((struct ms_bootblock_page0 *)PageBuffer0)->header.wFormatVersion) != MS_BOOT_BLOCK_FORMAT_VERSION) ||\r\n(((struct ms_bootblock_page0 *)PageBuffer0)->header.bNumberOfDataEntry != MS_BOOT_BLOCK_DATA_ENTRIES))\r\ncontinue;\r\nif (btBlk1st != MS_LB_NOT_USED) {\r\nbtBlk2nd = TmpBlock;\r\nbreak;\r\n}\r\nbtBlk1st = TmpBlock;\r\nmemcpy(PageBuffer1, PageBuffer0, MS_BYTES_PER_PAGE);\r\nif (extdat.status1 & (MS_REG_ST1_DTER | MS_REG_ST1_EXER | MS_REG_ST1_FGER))\r\nbtBlk1stErred = 1;\r\n}\r\nif (btBlk1st == MS_LB_NOT_USED) {\r\nresult = MS_STATUS_ERROR;\r\ngoto exit;\r\n}\r\nif ((extdat.status0 & MS_REG_ST0_WP) == MS_REG_ST0_WP_ON)\r\nms_lib_ctrl_set(info, MS_LIB_CTRL_WRPROTECT);\r\nresult = MS_STATUS_ERROR;\r\nif (btBlk1stErred == 0)\r\nresult = ms_lib_process_bootblock(us, btBlk1st, PageBuffer1);\r\nif (result && (btBlk2nd != MS_LB_NOT_USED))\r\nresult = ms_lib_process_bootblock(us, btBlk2nd, PageBuffer0);\r\nif (result) {\r\nresult = MS_STATUS_ERROR;\r\ngoto exit;\r\n}\r\nfor (TmpBlock = 0; TmpBlock < btBlk1st; TmpBlock++)\r\ninfo->MS_Lib.Phy2LogMap[TmpBlock] = MS_LB_INITIAL_ERROR;\r\ninfo->MS_Lib.Phy2LogMap[btBlk1st] = MS_LB_BOOT_BLOCK;\r\nif (btBlk2nd != MS_LB_NOT_USED) {\r\nfor (TmpBlock = btBlk1st + 1; TmpBlock < btBlk2nd; TmpBlock++)\r\ninfo->MS_Lib.Phy2LogMap[TmpBlock] = MS_LB_INITIAL_ERROR;\r\ninfo->MS_Lib.Phy2LogMap[btBlk2nd] = MS_LB_BOOT_BLOCK;\r\n}\r\nresult = ms_lib_scan_logicalblocknumber(us, btBlk1st);\r\nif (result)\r\ngoto exit;\r\nfor (TmpBlock = MS_PHYSICAL_BLOCKS_PER_SEGMENT;\r\nTmpBlock < info->MS_Lib.NumberOfPhyBlock;\r\nTmpBlock += MS_PHYSICAL_BLOCKS_PER_SEGMENT) {\r\nif (ms_count_freeblock(us, TmpBlock) == 0) {\r\nms_lib_ctrl_set(info, MS_LIB_CTRL_WRPROTECT);\r\nbreak;\r\n}\r\n}\r\nif (ms_lib_alloc_writebuf(us)) {\r\nresult = MS_NO_MEMORY_ERROR;\r\ngoto exit;\r\n}\r\nresult = MS_STATUS_SUCCESS;\r\nexit:\r\nkfree(PageBuffer1);\r\nkfree(PageBuffer0);\r\nprintk(KERN_INFO "MS_CardInit end\n");\r\nreturn result;\r\n}\r\nstatic int ene_ms_init(struct us_data *us)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nu8 buf[0x200];\r\nu16 MSP_BlockSize, MSP_UserAreaBlocks;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nprintk(KERN_INFO "transport --- ENE_MSInit\n");\r\nresult = ene_load_bincode(us, MS_INIT_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nprintk(KERN_ERR "Load MS Init Code Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x01;\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, &buf, 0);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nprintk(KERN_ERR "Execution MS Init Code Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\ninfo->MS_Status = *(struct MS_STATUS *)&buf[0];\r\nif (info->MS_Status.Insert && info->MS_Status.Ready) {\r\nprintk(KERN_INFO "Insert = %x\n", info->MS_Status.Insert);\r\nprintk(KERN_INFO "Ready = %x\n", info->MS_Status.Ready);\r\nprintk(KERN_INFO "IsMSPro = %x\n", info->MS_Status.IsMSPro);\r\nprintk(KERN_INFO "IsMSPHG = %x\n", info->MS_Status.IsMSPHG);\r\nprintk(KERN_INFO "WtP= %x\n", info->MS_Status.WtP);\r\nif (info->MS_Status.IsMSPro) {\r\nMSP_BlockSize = (buf[6] << 8) | buf[7];\r\nMSP_UserAreaBlocks = (buf[10] << 8) | buf[11];\r\ninfo->MSP_TotalBlock = MSP_BlockSize * MSP_UserAreaBlocks;\r\n} else {\r\nms_card_init(us);\r\n}\r\nusb_stor_dbg(us, "MS Init Code OK !!\n");\r\n} else {\r\nusb_stor_dbg(us, "MS Card Not Ready --- %x\n", buf[0]);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ene_sd_init(struct us_data *us)\r\n{\r\nint result;\r\nu8 buf[0x200];\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\r\nusb_stor_dbg(us, "transport --- ENE_SDInit\n");\r\nresult = ene_load_bincode(us, SD_INIT1_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Load SD Init Code Part-1 Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF2;\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, NULL, 0);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Execution SD Init Code Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nresult = ene_load_bincode(us, SD_INIT2_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Load SD Init Code Part-2 Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200;\r\nbcb->Flags = US_BULK_FLAG_IN;\r\nbcb->CDB[0] = 0xF1;\r\nresult = ene_send_scsi_cmd(us, FDIR_READ, &buf, 0);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Execution SD Init Code Fail !!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\ninfo->SD_Status = *(struct SD_STATUS *)&buf[0];\r\nif (info->SD_Status.Insert && info->SD_Status.Ready) {\r\nstruct SD_STATUS *s = &info->SD_Status;\r\nene_get_card_status(us, (unsigned char *)&buf);\r\nusb_stor_dbg(us, "Insert = %x\n", s->Insert);\r\nusb_stor_dbg(us, "Ready = %x\n", s->Ready);\r\nusb_stor_dbg(us, "IsMMC = %x\n", s->IsMMC);\r\nusb_stor_dbg(us, "HiCapacity = %x\n", s->HiCapacity);\r\nusb_stor_dbg(us, "HiSpeed = %x\n", s->HiSpeed);\r\nusb_stor_dbg(us, "WtP = %x\n", s->WtP);\r\n} else {\r\nusb_stor_dbg(us, "SD Card Not Ready --- %x\n", buf[0]);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int ene_init(struct us_data *us)\r\n{\r\nint result;\r\nu8 misc_reg03 = 0;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\r\nresult = ene_get_card_type(us, REG_CARD_STATUS, &misc_reg03);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (misc_reg03 & 0x01) {\r\nif (!info->SD_Status.Ready) {\r\nresult = ene_sd_init(us);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\n}\r\nif (misc_reg03 & 0x02) {\r\nif (!info->MS_Status.Ready) {\r\nresult = ene_ms_init(us);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int sd_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nint result;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *)us->extra;\r\ninfo->SrbStatus = SS_SUCCESS;\r\nswitch (srb->cmnd[0]) {\r\ncase TEST_UNIT_READY:\r\nresult = sd_scsi_test_unit_ready(us, srb);\r\nbreak;\r\ncase INQUIRY:\r\nresult = sd_scsi_inquiry(us, srb);\r\nbreak;\r\ncase MODE_SENSE:\r\nresult = sd_scsi_mode_sense(us, srb);\r\nbreak;\r\ncase READ_CAPACITY:\r\nresult = sd_scsi_read_capacity(us, srb);\r\nbreak;\r\ncase READ_10:\r\nresult = sd_scsi_read(us, srb);\r\nbreak;\r\ncase WRITE_10:\r\nresult = sd_scsi_write(us, srb);\r\nbreak;\r\ndefault:\r\ninfo->SrbStatus = SS_ILLEGAL_REQUEST;\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)\r\n{\r\nint result;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *)us->extra;\r\ninfo->SrbStatus = SS_SUCCESS;\r\nswitch (srb->cmnd[0]) {\r\ncase TEST_UNIT_READY:\r\nresult = ms_scsi_test_unit_ready(us, srb);\r\nbreak;\r\ncase INQUIRY:\r\nresult = ms_scsi_inquiry(us, srb);\r\nbreak;\r\ncase MODE_SENSE:\r\nresult = ms_scsi_mode_sense(us, srb);\r\nbreak;\r\ncase READ_CAPACITY:\r\nresult = ms_scsi_read_capacity(us, srb);\r\nbreak;\r\ncase READ_10:\r\nresult = ms_scsi_read(us, srb);\r\nbreak;\r\ncase WRITE_10:\r\nresult = ms_scsi_write(us, srb);\r\nbreak;\r\ndefault:\r\ninfo->SrbStatus = SS_ILLEGAL_REQUEST;\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int ene_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nint result = 0;\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\r\nscsi_set_resid(srb, 0);\r\nif (unlikely(!(info->SD_Status.Ready || info->MS_Status.Ready))) {\r\nresult = ene_init(us);\r\n} else {\r\nif (info->SD_Status.Ready)\r\nresult = sd_scsi_irp(us, srb);\r\nif (info->MS_Status.Ready)\r\nresult = ms_scsi_irp(us, srb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ene_ub6250_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint result;\r\nu8 misc_reg03 = 0;\r\nstruct us_data *us;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - ene_ub6250_usb_ids) + ene_ub6250_unusual_dev_list,\r\n&ene_ub6250_host_template);\r\nif (result)\r\nreturn result;\r\nif (!us->extra) {\r\nus->extra = kzalloc(sizeof(struct ene_ub6250_info), GFP_KERNEL);\r\nif (!us->extra)\r\nreturn -ENOMEM;\r\nus->extra_destructor = ene_ub6250_info_destructor;\r\n}\r\nus->transport_name = "ene_ub6250";\r\nus->transport = ene_transport;\r\nus->max_lun = 0;\r\nresult = usb_stor_probe2(us);\r\nif (result)\r\nreturn result;\r\nresult = ene_get_card_type(us, REG_CARD_STATUS, &misc_reg03);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_disconnect(intf);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (!(misc_reg03 & 0x01)) {\r\npr_info("ums_eneub6250: This driver only supports SD/MS cards. "\r\n"It does not support SM cards.\n");\r\n}\r\nreturn result;\r\n}\r\nstatic int ene_ub6250_resume(struct usb_interface *iface)\r\n{\r\nu8 tmp = 0;\r\nstruct us_data *us = usb_get_intfdata(iface);\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\r\nmutex_lock(&us->dev_mutex);\r\nif (us->suspend_resume_hook)\r\n(us->suspend_resume_hook)(us, US_RESUME);\r\nmutex_unlock(&us->dev_mutex);\r\ninfo->Power_IsResum = true;\r\ninfo->SD_Status = *(struct SD_STATUS *)&tmp;\r\ninfo->MS_Status = *(struct MS_STATUS *)&tmp;\r\ninfo->SM_Status = *(struct SM_STATUS *)&tmp;\r\nreturn 0;\r\n}\r\nstatic int ene_ub6250_reset_resume(struct usb_interface *iface)\r\n{\r\nu8 tmp = 0;\r\nstruct us_data *us = usb_get_intfdata(iface);\r\nstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\r\nusb_stor_reset_resume(iface);\r\ninfo->Power_IsResum = true;\r\ninfo->SD_Status = *(struct SD_STATUS *)&tmp;\r\ninfo->MS_Status = *(struct MS_STATUS *)&tmp;\r\ninfo->SM_Status = *(struct SM_STATUS *)&tmp;\r\nreturn 0;\r\n}
