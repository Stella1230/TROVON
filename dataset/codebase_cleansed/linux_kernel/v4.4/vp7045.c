int vp7045_usb_op(struct dvb_usb_device *d, u8 cmd, u8 *out, int outlen, u8 *in, int inlen, int msec)\r\n{\r\nint ret = 0;\r\nu8 *buf = d->priv;\r\nbuf[0] = cmd;\r\nif (outlen > 19)\r\noutlen = 19;\r\nif (inlen > 11)\r\ninlen = 11;\r\nret = mutex_lock_interruptible(&d->usb_mutex);\r\nif (ret)\r\nreturn ret;\r\nif (out != NULL && outlen > 0)\r\nmemcpy(&buf[1], out, outlen);\r\ndeb_xfer("out buffer: ");\r\ndebug_dump(buf, outlen+1, deb_xfer);\r\nif (usb_control_msg(d->udev,\r\nusb_sndctrlpipe(d->udev,0),\r\nTH_COMMAND_OUT, USB_TYPE_VENDOR | USB_DIR_OUT, 0, 0,\r\nbuf, 20, 2000) != 20) {\r\nerr("USB control message 'out' went wrong.");\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nmsleep(msec);\r\nif (usb_control_msg(d->udev,\r\nusb_rcvctrlpipe(d->udev,0),\r\nTH_COMMAND_IN, USB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\r\nbuf, 12, 2000) != 12) {\r\nerr("USB control message 'in' went wrong.");\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\ndeb_xfer("in buffer: ");\r\ndebug_dump(buf, 12, deb_xfer);\r\nif (in != NULL && inlen > 0)\r\nmemcpy(in, &buf[1], inlen);\r\nunlock:\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nu8 vp7045_read_reg(struct dvb_usb_device *d, u8 reg)\r\n{\r\nu8 obuf[2] = { 0 },v;\r\nobuf[1] = reg;\r\nvp7045_usb_op(d,TUNER_REG_READ,obuf,2,&v,1,30);\r\nreturn v;\r\n}\r\nstatic int vp7045_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 v = onoff;\r\nreturn vp7045_usb_op(d,SET_TUNER_POWER,&v,1,NULL,0,150);\r\n}\r\nstatic int vp7045_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nu8 key;\r\nint i;\r\nvp7045_usb_op(d,RC_VAL_READ,NULL,0,&key,1,20);\r\ndeb_rc("remote query key: %x %d\n",key,key);\r\nif (key == 0x44) {\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(rc_map_vp7045_table); i++)\r\nif (rc5_data(&rc_map_vp7045_table[i]) == key) {\r\n*state = REMOTE_KEY_PRESSED;\r\n*event = rc_map_vp7045_table[i].keycode;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vp7045_read_eeprom(struct dvb_usb_device *d,u8 *buf, int len, int offset)\r\n{\r\nint i = 0;\r\nu8 v,br[2];\r\nfor (i=0; i < len; i++) {\r\nv = offset + i;\r\nvp7045_usb_op(d,GET_EE_VALUE,&v,1,br,2,5);\r\nbuf[i] = br[1];\r\n}\r\ndeb_info("VP7045 EEPROM read (offs: %d, len: %d) : ",offset, i);\r\ndebug_dump(buf,i,deb_info);\r\nreturn 0;\r\n}\r\nstatic int vp7045_read_mac_addr(struct dvb_usb_device *d,u8 mac[6])\r\n{\r\nreturn vp7045_read_eeprom(d,mac, 6, MAC_0_ADDR);\r\n}\r\nstatic int vp7045_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nu8 buf[255] = { 0 };\r\nvp7045_usb_op(adap->dev,VENDOR_STRING_READ,NULL,0,buf,20,0);\r\nbuf[10] = '\0';\r\ndeb_info("firmware says: %s ",buf);\r\nvp7045_usb_op(adap->dev,PRODUCT_STRING_READ,NULL,0,buf,20,0);\r\nbuf[10] = '\0';\r\ndeb_info("%s ",buf);\r\nvp7045_usb_op(adap->dev,FW_VERSION_READ,NULL,0,buf,20,0);\r\nbuf[10] = '\0';\r\ndeb_info("v%s\n",buf);\r\nadap->fe_adap[0].fe = vp7045_fe_attach(adap->dev);\r\nreturn 0;\r\n}\r\nstatic int vp7045_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn dvb_usb_device_init(intf, &vp7045_properties,\r\nTHIS_MODULE, NULL, adapter_nr);\r\n}
