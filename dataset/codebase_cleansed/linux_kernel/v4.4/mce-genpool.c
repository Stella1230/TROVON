void mce_gen_pool_process(void)\r\n{\r\nstruct llist_node *head;\r\nstruct mce_evt_llist *node;\r\nstruct mce *mce;\r\nhead = llist_del_all(&mce_event_llist);\r\nif (!head)\r\nreturn;\r\nhead = llist_reverse_order(head);\r\nllist_for_each_entry(node, head, llnode) {\r\nmce = &node->mce;\r\natomic_notifier_call_chain(&x86_mce_decoder_chain, 0, mce);\r\ngen_pool_free(mce_evt_pool, (unsigned long)node, sizeof(*node));\r\n}\r\n}\r\nbool mce_gen_pool_empty(void)\r\n{\r\nreturn llist_empty(&mce_event_llist);\r\n}\r\nint mce_gen_pool_add(struct mce *mce)\r\n{\r\nstruct mce_evt_llist *node;\r\nif (!mce_evt_pool)\r\nreturn -EINVAL;\r\nnode = (void *)gen_pool_alloc(mce_evt_pool, sizeof(*node));\r\nif (!node) {\r\npr_warn_ratelimited("MCE records pool full!\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&node->mce, mce, sizeof(*mce));\r\nllist_add(&node->llnode, &mce_event_llist);\r\nreturn 0;\r\n}\r\nstatic int mce_gen_pool_create(void)\r\n{\r\nstruct gen_pool *tmpp;\r\nint ret = -ENOMEM;\r\ntmpp = gen_pool_create(ilog2(sizeof(struct mce_evt_llist)), -1);\r\nif (!tmpp)\r\ngoto out;\r\nret = gen_pool_add(tmpp, (unsigned long)gen_pool_buf, MCE_POOLSZ, -1);\r\nif (ret) {\r\ngen_pool_destroy(tmpp);\r\ngoto out;\r\n}\r\nmce_evt_pool = tmpp;\r\nout:\r\nreturn ret;\r\n}\r\nint mce_gen_pool_init(void)\r\n{\r\nif (mce_evt_pool)\r\nreturn 0;\r\nreturn mce_gen_pool_create();\r\n}
