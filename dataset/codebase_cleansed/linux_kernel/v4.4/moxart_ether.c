static inline void moxart_emac_write(struct net_device *ndev,\r\nunsigned int reg, unsigned long value)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nwritel(value, priv->base + reg);\r\n}\r\nstatic void moxart_update_mac_address(struct net_device *ndev)\r\n{\r\nmoxart_emac_write(ndev, REG_MAC_MS_ADDRESS,\r\n((ndev->dev_addr[0] << 8) | (ndev->dev_addr[1])));\r\nmoxart_emac_write(ndev, REG_MAC_MS_ADDRESS + 4,\r\n((ndev->dev_addr[2] << 24) |\r\n(ndev->dev_addr[3] << 16) |\r\n(ndev->dev_addr[4] << 8) |\r\n(ndev->dev_addr[5])));\r\n}\r\nstatic int moxart_set_mac_address(struct net_device *ndev, void *addr)\r\n{\r\nstruct sockaddr *address = addr;\r\nif (!is_valid_ether_addr(address->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(ndev->dev_addr, address->sa_data, ndev->addr_len);\r\nmoxart_update_mac_address(ndev);\r\nreturn 0;\r\n}\r\nstatic void moxart_mac_free_memory(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nint i;\r\nfor (i = 0; i < RX_DESC_NUM; i++)\r\ndma_unmap_single(&ndev->dev, priv->rx_mapping[i],\r\npriv->rx_buf_size, DMA_FROM_DEVICE);\r\nif (priv->tx_desc_base)\r\ndma_free_coherent(NULL, TX_REG_DESC_SIZE * TX_DESC_NUM,\r\npriv->tx_desc_base, priv->tx_base);\r\nif (priv->rx_desc_base)\r\ndma_free_coherent(NULL, RX_REG_DESC_SIZE * RX_DESC_NUM,\r\npriv->rx_desc_base, priv->rx_base);\r\nkfree(priv->tx_buf_base);\r\nkfree(priv->rx_buf_base);\r\n}\r\nstatic void moxart_mac_reset(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nwritel(SW_RST, priv->base + REG_MAC_CTRL);\r\nwhile (readl(priv->base + REG_MAC_CTRL) & SW_RST)\r\nmdelay(10);\r\nwritel(0, priv->base + REG_INTERRUPT_MASK);\r\npriv->reg_maccr = RX_BROADPKT | FULLDUP | CRC_APD | RX_FTL;\r\n}\r\nstatic void moxart_mac_enable(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nwritel(0x00001010, priv->base + REG_INT_TIMER_CTRL);\r\nwritel(0x00000001, priv->base + REG_APOLL_TIMER_CTRL);\r\nwritel(0x00000390, priv->base + REG_DMA_BLEN_CTRL);\r\npriv->reg_imr |= (RPKT_FINISH_M | XPKT_FINISH_M);\r\nwritel(priv->reg_imr, priv->base + REG_INTERRUPT_MASK);\r\npriv->reg_maccr |= (RCV_EN | XMT_EN | RDMA_EN | XDMA_EN);\r\nwritel(priv->reg_maccr, priv->base + REG_MAC_CTRL);\r\n}\r\nstatic void moxart_mac_setup_desc_ring(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nvoid __iomem *desc;\r\nint i;\r\nfor (i = 0; i < TX_DESC_NUM; i++) {\r\ndesc = priv->tx_desc_base + i * TX_REG_DESC_SIZE;\r\nmemset(desc, 0, TX_REG_DESC_SIZE);\r\npriv->tx_buf[i] = priv->tx_buf_base + priv->tx_buf_size * i;\r\n}\r\nwritel(TX_DESC1_END, desc + TX_REG_OFFSET_DESC1);\r\npriv->tx_head = 0;\r\npriv->tx_tail = 0;\r\nfor (i = 0; i < RX_DESC_NUM; i++) {\r\ndesc = priv->rx_desc_base + i * RX_REG_DESC_SIZE;\r\nmemset(desc, 0, RX_REG_DESC_SIZE);\r\nwritel(RX_DESC0_DMA_OWN, desc + RX_REG_OFFSET_DESC0);\r\nwritel(RX_BUF_SIZE & RX_DESC1_BUF_SIZE_MASK,\r\ndesc + RX_REG_OFFSET_DESC1);\r\npriv->rx_buf[i] = priv->rx_buf_base + priv->rx_buf_size * i;\r\npriv->rx_mapping[i] = dma_map_single(&ndev->dev,\r\npriv->rx_buf[i],\r\npriv->rx_buf_size,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&ndev->dev, priv->rx_mapping[i]))\r\nnetdev_err(ndev, "DMA mapping error\n");\r\nwritel(priv->rx_mapping[i],\r\ndesc + RX_REG_OFFSET_DESC2 + RX_DESC2_ADDRESS_PHYS);\r\nwritel(priv->rx_buf[i],\r\ndesc + RX_REG_OFFSET_DESC2 + RX_DESC2_ADDRESS_VIRT);\r\n}\r\nwritel(RX_DESC1_END, desc + RX_REG_OFFSET_DESC1);\r\npriv->rx_head = 0;\r\nwritel(priv->tx_base, priv->base + REG_TXR_BASE_ADDRESS);\r\nwritel(priv->rx_base, priv->base + REG_RXR_BASE_ADDRESS);\r\n}\r\nstatic int moxart_mac_open(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nif (!is_valid_ether_addr(ndev->dev_addr))\r\nreturn -EADDRNOTAVAIL;\r\nnapi_enable(&priv->napi);\r\nmoxart_mac_reset(ndev);\r\nmoxart_update_mac_address(ndev);\r\nmoxart_mac_setup_desc_ring(ndev);\r\nmoxart_mac_enable(ndev);\r\nnetif_start_queue(ndev);\r\nnetdev_dbg(ndev, "%s: IMR=0x%x, MACCR=0x%x\n",\r\n__func__, readl(priv->base + REG_INTERRUPT_MASK),\r\nreadl(priv->base + REG_MAC_CTRL));\r\nreturn 0;\r\n}\r\nstatic int moxart_mac_stop(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nnapi_disable(&priv->napi);\r\nnetif_stop_queue(ndev);\r\nwritel(0, priv->base + REG_INTERRUPT_MASK);\r\nwritel(0, priv->base + REG_MAC_CTRL);\r\nreturn 0;\r\n}\r\nstatic int moxart_rx_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct moxart_mac_priv_t *priv = container_of(napi,\r\nstruct moxart_mac_priv_t,\r\nnapi);\r\nstruct net_device *ndev = priv->ndev;\r\nstruct sk_buff *skb;\r\nvoid __iomem *desc;\r\nunsigned int desc0, len;\r\nint rx_head = priv->rx_head;\r\nint rx = 0;\r\nwhile (rx < budget) {\r\ndesc = priv->rx_desc_base + (RX_REG_DESC_SIZE * rx_head);\r\ndesc0 = readl(desc + RX_REG_OFFSET_DESC0);\r\nif (desc0 & RX_DESC0_DMA_OWN)\r\nbreak;\r\nif (desc0 & (RX_DESC0_ERR | RX_DESC0_CRC_ERR | RX_DESC0_FTL |\r\nRX_DESC0_RUNT | RX_DESC0_ODD_NB)) {\r\nnet_dbg_ratelimited("packet error\n");\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_errors++;\r\ngoto rx_next;\r\n}\r\nlen = desc0 & RX_DESC0_FRAME_LEN_MASK;\r\nif (len > RX_BUF_SIZE)\r\nlen = RX_BUF_SIZE;\r\ndma_sync_single_for_cpu(&ndev->dev,\r\npriv->rx_mapping[rx_head],\r\npriv->rx_buf_size, DMA_FROM_DEVICE);\r\nskb = netdev_alloc_skb_ip_align(ndev, len);\r\nif (unlikely(!skb)) {\r\nnet_dbg_ratelimited("netdev_alloc_skb_ip_align failed\n");\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_errors++;\r\ngoto rx_next;\r\n}\r\nmemcpy(skb->data, priv->rx_buf[rx_head], len);\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nnapi_gro_receive(&priv->napi, skb);\r\nrx++;\r\npriv->stats.rx_packets++;\r\npriv->stats.rx_bytes += len;\r\nif (desc0 & RX_DESC0_MULTICAST)\r\npriv->stats.multicast++;\r\nrx_next:\r\nwritel(RX_DESC0_DMA_OWN, desc + RX_REG_OFFSET_DESC0);\r\nrx_head = RX_NEXT(rx_head);\r\npriv->rx_head = rx_head;\r\n}\r\nif (rx < budget) {\r\nnapi_complete(napi);\r\n}\r\npriv->reg_imr |= RPKT_FINISH_M;\r\nwritel(priv->reg_imr, priv->base + REG_INTERRUPT_MASK);\r\nreturn rx;\r\n}\r\nstatic void moxart_tx_finished(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nunsigned tx_head = priv->tx_head;\r\nunsigned tx_tail = priv->tx_tail;\r\nwhile (tx_tail != tx_head) {\r\ndma_unmap_single(&ndev->dev, priv->tx_mapping[tx_tail],\r\npriv->tx_len[tx_tail], DMA_TO_DEVICE);\r\npriv->stats.tx_packets++;\r\npriv->stats.tx_bytes += priv->tx_skb[tx_tail]->len;\r\ndev_kfree_skb_irq(priv->tx_skb[tx_tail]);\r\npriv->tx_skb[tx_tail] = NULL;\r\ntx_tail = TX_NEXT(tx_tail);\r\n}\r\npriv->tx_tail = tx_tail;\r\n}\r\nstatic irqreturn_t moxart_mac_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *ndev = (struct net_device *) dev_id;\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nunsigned int ists = readl(priv->base + REG_INTERRUPT_STATUS);\r\nif (ists & XPKT_OK_INT_STS)\r\nmoxart_tx_finished(ndev);\r\nif (ists & RPKT_FINISH) {\r\nif (napi_schedule_prep(&priv->napi)) {\r\npriv->reg_imr &= ~RPKT_FINISH_M;\r\nwritel(priv->reg_imr, priv->base + REG_INTERRUPT_MASK);\r\n__napi_schedule(&priv->napi);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int moxart_mac_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nvoid __iomem *desc;\r\nunsigned int len;\r\nunsigned int tx_head = priv->tx_head;\r\nu32 txdes1;\r\nint ret = NETDEV_TX_BUSY;\r\ndesc = priv->tx_desc_base + (TX_REG_DESC_SIZE * tx_head);\r\nspin_lock_irq(&priv->txlock);\r\nif (readl(desc + TX_REG_OFFSET_DESC0) & TX_DESC0_DMA_OWN) {\r\nnet_dbg_ratelimited("no TX space for packet\n");\r\npriv->stats.tx_dropped++;\r\ngoto out_unlock;\r\n}\r\nlen = skb->len > TX_BUF_SIZE ? TX_BUF_SIZE : skb->len;\r\npriv->tx_mapping[tx_head] = dma_map_single(&ndev->dev, skb->data,\r\nlen, DMA_TO_DEVICE);\r\nif (dma_mapping_error(&ndev->dev, priv->tx_mapping[tx_head])) {\r\nnetdev_err(ndev, "DMA mapping error\n");\r\ngoto out_unlock;\r\n}\r\npriv->tx_len[tx_head] = len;\r\npriv->tx_skb[tx_head] = skb;\r\nwritel(priv->tx_mapping[tx_head],\r\ndesc + TX_REG_OFFSET_DESC2 + TX_DESC2_ADDRESS_PHYS);\r\nwritel(skb->data,\r\ndesc + TX_REG_OFFSET_DESC2 + TX_DESC2_ADDRESS_VIRT);\r\nif (skb->len < ETH_ZLEN) {\r\nmemset(&skb->data[skb->len],\r\n0, ETH_ZLEN - skb->len);\r\nlen = ETH_ZLEN;\r\n}\r\ndma_sync_single_for_device(&ndev->dev, priv->tx_mapping[tx_head],\r\npriv->tx_buf_size, DMA_TO_DEVICE);\r\ntxdes1 = TX_DESC1_LTS | TX_DESC1_FTS | (len & TX_DESC1_BUF_SIZE_MASK);\r\nif (tx_head == TX_DESC_NUM_MASK)\r\ntxdes1 |= TX_DESC1_END;\r\nwritel(txdes1, desc + TX_REG_OFFSET_DESC1);\r\nwritel(TX_DESC0_DMA_OWN, desc + TX_REG_OFFSET_DESC0);\r\nwritel(0xffffffff, priv->base + REG_TX_POLL_DEMAND);\r\npriv->tx_head = TX_NEXT(tx_head);\r\nndev->trans_start = jiffies;\r\nret = NETDEV_TX_OK;\r\nout_unlock:\r\nspin_unlock_irq(&priv->txlock);\r\nreturn ret;\r\n}\r\nstatic struct net_device_stats *moxart_mac_get_stats(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nreturn &priv->stats;\r\n}\r\nstatic void moxart_mac_setmulticast(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nstruct netdev_hw_addr *ha;\r\nint crc_val;\r\nnetdev_for_each_mc_addr(ha, ndev) {\r\ncrc_val = crc32_le(~0, ha->addr, ETH_ALEN);\r\ncrc_val = (crc_val >> 26) & 0x3f;\r\nif (crc_val >= 32) {\r\nwritel(readl(priv->base + REG_MCAST_HASH_TABLE1) |\r\n(1UL << (crc_val - 32)),\r\npriv->base + REG_MCAST_HASH_TABLE1);\r\n} else {\r\nwritel(readl(priv->base + REG_MCAST_HASH_TABLE0) |\r\n(1UL << crc_val),\r\npriv->base + REG_MCAST_HASH_TABLE0);\r\n}\r\n}\r\n}\r\nstatic void moxart_mac_set_rx_mode(struct net_device *ndev)\r\n{\r\nstruct moxart_mac_priv_t *priv = netdev_priv(ndev);\r\nspin_lock_irq(&priv->txlock);\r\n(ndev->flags & IFF_PROMISC) ? (priv->reg_maccr |= RCV_ALL) :\r\n(priv->reg_maccr &= ~RCV_ALL);\r\n(ndev->flags & IFF_ALLMULTI) ? (priv->reg_maccr |= RX_MULTIPKT) :\r\n(priv->reg_maccr &= ~RX_MULTIPKT);\r\nif ((ndev->flags & IFF_MULTICAST) && netdev_mc_count(ndev)) {\r\npriv->reg_maccr |= HT_MULTI_EN;\r\nmoxart_mac_setmulticast(ndev);\r\n} else {\r\npriv->reg_maccr &= ~HT_MULTI_EN;\r\n}\r\nwritel(priv->reg_maccr, priv->base + REG_MAC_CTRL);\r\nspin_unlock_irq(&priv->txlock);\r\n}\r\nstatic int moxart_mac_probe(struct platform_device *pdev)\r\n{\r\nstruct device *p_dev = &pdev->dev;\r\nstruct device_node *node = p_dev->of_node;\r\nstruct net_device *ndev;\r\nstruct moxart_mac_priv_t *priv;\r\nstruct resource *res;\r\nunsigned int irq;\r\nint ret;\r\nndev = alloc_etherdev(sizeof(struct moxart_mac_priv_t));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (irq <= 0) {\r\nnetdev_err(ndev, "irq_of_parse_and_map failed\n");\r\nret = -EINVAL;\r\ngoto irq_map_fail;\r\n}\r\npriv = netdev_priv(ndev);\r\npriv->ndev = ndev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nndev->base_addr = res->start;\r\npriv->base = devm_ioremap_resource(p_dev, res);\r\nret = IS_ERR(priv->base);\r\nif (ret) {\r\ndev_err(p_dev, "devm_ioremap_resource failed\n");\r\ngoto init_fail;\r\n}\r\nspin_lock_init(&priv->txlock);\r\npriv->tx_buf_size = TX_BUF_SIZE;\r\npriv->rx_buf_size = RX_BUF_SIZE;\r\npriv->tx_desc_base = dma_alloc_coherent(NULL, TX_REG_DESC_SIZE *\r\nTX_DESC_NUM, &priv->tx_base,\r\nGFP_DMA | GFP_KERNEL);\r\nif (priv->tx_desc_base == NULL) {\r\nret = -ENOMEM;\r\ngoto init_fail;\r\n}\r\npriv->rx_desc_base = dma_alloc_coherent(NULL, RX_REG_DESC_SIZE *\r\nRX_DESC_NUM, &priv->rx_base,\r\nGFP_DMA | GFP_KERNEL);\r\nif (priv->rx_desc_base == NULL) {\r\nret = -ENOMEM;\r\ngoto init_fail;\r\n}\r\npriv->tx_buf_base = kmalloc(priv->tx_buf_size * TX_DESC_NUM,\r\nGFP_ATOMIC);\r\nif (!priv->tx_buf_base) {\r\nret = -ENOMEM;\r\ngoto init_fail;\r\n}\r\npriv->rx_buf_base = kmalloc(priv->rx_buf_size * RX_DESC_NUM,\r\nGFP_ATOMIC);\r\nif (!priv->rx_buf_base) {\r\nret = -ENOMEM;\r\ngoto init_fail;\r\n}\r\nplatform_set_drvdata(pdev, ndev);\r\nret = devm_request_irq(p_dev, irq, moxart_mac_interrupt, 0,\r\npdev->name, ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "devm_request_irq failed\n");\r\ngoto init_fail;\r\n}\r\nndev->netdev_ops = &moxart_netdev_ops;\r\nnetif_napi_add(ndev, &priv->napi, moxart_rx_poll, RX_DESC_NUM);\r\nndev->priv_flags |= IFF_UNICAST_FLT;\r\nndev->irq = irq;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nret = register_netdev(ndev);\r\nif (ret) {\r\nfree_netdev(ndev);\r\ngoto init_fail;\r\n}\r\nnetdev_dbg(ndev, "%s: IRQ=%d address=%pM\n",\r\n__func__, ndev->irq, ndev->dev_addr);\r\nreturn 0;\r\ninit_fail:\r\nnetdev_err(ndev, "init failed\n");\r\nmoxart_mac_free_memory(ndev);\r\nirq_map_fail:\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int moxart_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nunregister_netdev(ndev);\r\nfree_irq(ndev->irq, ndev);\r\nmoxart_mac_free_memory(ndev);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}
