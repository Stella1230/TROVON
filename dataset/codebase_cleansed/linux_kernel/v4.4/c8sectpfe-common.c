static int register_dvb(struct stdemux *demux, struct dvb_adapter *adap,\r\nvoid *start_feed, void *stop_feed,\r\nstruct c8sectpfei *fei)\r\n{\r\nint result;\r\ndemux->dvb_demux.dmx.capabilities = DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING;\r\ndemux->dvb_demux.priv = demux;\r\ndemux->dvb_demux.filternum = C8SECTPFE_MAXCHANNEL;\r\ndemux->dvb_demux.feednum = C8SECTPFE_MAXCHANNEL;\r\ndemux->dvb_demux.start_feed = start_feed;\r\ndemux->dvb_demux.stop_feed = stop_feed;\r\ndemux->dvb_demux.write_to_decoder = NULL;\r\nresult = dvb_dmx_init(&demux->dvb_demux);\r\nif (result < 0) {\r\ndev_err(fei->dev, "dvb_dmx_init failed (errno = %d)\n",\r\nresult);\r\ngoto err_dmx;\r\n}\r\ndemux->dmxdev.filternum = demux->dvb_demux.filternum;\r\ndemux->dmxdev.demux = &demux->dvb_demux.dmx;\r\ndemux->dmxdev.capabilities = 0;\r\nresult = dvb_dmxdev_init(&demux->dmxdev, adap);\r\nif (result < 0) {\r\ndev_err(fei->dev, "dvb_dmxdev_init failed (errno = %d)\n",\r\nresult);\r\ngoto err_dmxdev;\r\n}\r\ndemux->hw_frontend.source = DMX_FRONTEND_0 + demux->tsin_index;\r\nresult = demux->dvb_demux.dmx.add_frontend(&demux->dvb_demux.dmx,\r\n&demux->hw_frontend);\r\nif (result < 0) {\r\ndev_err(fei->dev, "add_frontend failed (errno = %d)\n", result);\r\ngoto err_fe_hw;\r\n}\r\ndemux->mem_frontend.source = DMX_MEMORY_FE;\r\nresult = demux->dvb_demux.dmx.add_frontend(&demux->dvb_demux.dmx,\r\n&demux->mem_frontend);\r\nif (result < 0) {\r\ndev_err(fei->dev, "add_frontend failed (%d)\n", result);\r\ngoto err_fe_mem;\r\n}\r\nresult = demux->dvb_demux.dmx.connect_frontend(&demux->dvb_demux.dmx,\r\n&demux->hw_frontend);\r\nif (result < 0) {\r\ndev_err(fei->dev, "connect_frontend (%d)\n", result);\r\ngoto err_fe_con;\r\n}\r\nreturn 0;\r\nerr_fe_con:\r\ndemux->dvb_demux.dmx.remove_frontend(&demux->dvb_demux.dmx,\r\n&demux->mem_frontend);\r\nerr_fe_mem:\r\ndemux->dvb_demux.dmx.remove_frontend(&demux->dvb_demux.dmx,\r\n&demux->hw_frontend);\r\nerr_fe_hw:\r\ndvb_dmxdev_release(&demux->dmxdev);\r\nerr_dmxdev:\r\ndvb_dmx_release(&demux->dvb_demux);\r\nerr_dmx:\r\nreturn result;\r\n}\r\nstatic void unregister_dvb(struct stdemux *demux)\r\n{\r\ndemux->dvb_demux.dmx.remove_frontend(&demux->dvb_demux.dmx,\r\n&demux->mem_frontend);\r\ndemux->dvb_demux.dmx.remove_frontend(&demux->dvb_demux.dmx,\r\n&demux->hw_frontend);\r\ndvb_dmxdev_release(&demux->dmxdev);\r\ndvb_dmx_release(&demux->dvb_demux);\r\n}\r\nstatic struct c8sectpfe *c8sectpfe_create(struct c8sectpfei *fei,\r\nvoid *start_feed,\r\nvoid *stop_feed)\r\n{\r\nstruct c8sectpfe *c8sectpfe;\r\nint result;\r\nint i, j;\r\nshort int ids[] = { -1 };\r\nc8sectpfe = kzalloc(sizeof(struct c8sectpfe), GFP_KERNEL);\r\nif (!c8sectpfe)\r\ngoto err1;\r\nmutex_init(&c8sectpfe->lock);\r\nc8sectpfe->device = fei->dev;\r\nresult = dvb_register_adapter(&c8sectpfe->adapter, "STi c8sectpfe",\r\nTHIS_MODULE, fei->dev, ids);\r\nif (result < 0) {\r\ndev_err(fei->dev, "dvb_register_adapter failed (errno = %d)\n",\r\nresult);\r\ngoto err2;\r\n}\r\nc8sectpfe->adapter.priv = fei;\r\nfor (i = 0; i < fei->tsin_count; i++) {\r\nc8sectpfe->demux[i].tsin_index = i;\r\nc8sectpfe->demux[i].c8sectpfei = fei;\r\nresult = register_dvb(&c8sectpfe->demux[i], &c8sectpfe->adapter,\r\nstart_feed, stop_feed, fei);\r\nif (result < 0) {\r\ndev_err(fei->dev,\r\n"register_dvb feed=%d failed (errno = %d)\n",\r\nresult, i);\r\nfor (j = 0; j < i; j++)\r\nunregister_dvb(&c8sectpfe->demux[j]);\r\ngoto err3;\r\n}\r\n}\r\nc8sectpfe->num_feeds = fei->tsin_count;\r\nreturn c8sectpfe;\r\nerr3:\r\ndvb_unregister_adapter(&c8sectpfe->adapter);\r\nerr2:\r\nkfree(c8sectpfe);\r\nerr1:\r\nreturn NULL;\r\n}\r\nstatic void c8sectpfe_delete(struct c8sectpfe *c8sectpfe)\r\n{\r\nint i;\r\nif (!c8sectpfe)\r\nreturn;\r\nfor (i = 0; i < c8sectpfe->num_feeds; i++)\r\nunregister_dvb(&c8sectpfe->demux[i]);\r\ndvb_unregister_adapter(&c8sectpfe->adapter);\r\nkfree(c8sectpfe);\r\n}\r\nvoid c8sectpfe_tuner_unregister_frontend(struct c8sectpfe *c8sectpfe,\r\nstruct c8sectpfei *fei)\r\n{\r\nint n;\r\nstruct channel_info *tsin;\r\nfor (n = 0; n < fei->tsin_count; n++) {\r\ntsin = fei->channel_data[n];\r\nif (tsin && tsin->frontend) {\r\ndvb_unregister_frontend(tsin->frontend);\r\ndvb_frontend_detach(tsin->frontend);\r\n}\r\nif (tsin && tsin->i2c_adapter)\r\ni2c_put_adapter(tsin->i2c_adapter);\r\nif (tsin && tsin->i2c_client) {\r\nif (tsin->i2c_client->dev.driver->owner)\r\nmodule_put(tsin->i2c_client->dev.driver->owner);\r\ni2c_unregister_device(tsin->i2c_client);\r\n}\r\n}\r\nc8sectpfe_delete(c8sectpfe);\r\n}\r\nint c8sectpfe_tuner_register_frontend(struct c8sectpfe **c8sectpfe,\r\nstruct c8sectpfei *fei,\r\nvoid *start_feed,\r\nvoid *stop_feed)\r\n{\r\nstruct channel_info *tsin;\r\nstruct dvb_frontend *frontend;\r\nint n, res;\r\n*c8sectpfe = c8sectpfe_create(fei, start_feed, stop_feed);\r\nif (!*c8sectpfe)\r\nreturn -ENOMEM;\r\nfor (n = 0; n < fei->tsin_count; n++) {\r\ntsin = fei->channel_data[n];\r\nres = c8sectpfe_frontend_attach(&frontend, *c8sectpfe, tsin, n);\r\nif (res)\r\ngoto err;\r\nres = dvb_register_frontend(&c8sectpfe[0]->adapter, frontend);\r\nif (res < 0) {\r\ndev_err(fei->dev, "dvb_register_frontend failed (%d)\n",\r\nres);\r\ngoto err;\r\n}\r\ntsin->frontend = frontend;\r\n}\r\nreturn 0;\r\nerr:\r\nc8sectpfe_tuner_unregister_frontend(*c8sectpfe, fei);\r\nreturn res;\r\n}
