static void timer64_config(unsigned long period)\r\n{\r\nu32 tcr = soc_readl(&timer->tcr) & ~TCR_ENAMODELO_MASK;\r\nsoc_writel(tcr, &timer->tcr);\r\nsoc_writel(period - 1, &timer->prdlo);\r\nsoc_writel(0, &timer->cntlo);\r\ntcr |= timer64_mode;\r\nsoc_writel(tcr, &timer->tcr);\r\n}\r\nstatic void timer64_enable(void)\r\n{\r\nu32 val;\r\nif (timer64_devstate_id >= 0)\r\ndscr_set_devstate(timer64_devstate_id, DSCR_DEVSTATE_ENABLED);\r\nsoc_writel(soc_readl(&timer->tcr) & ~TCR_ENAMODELO_MASK, &timer->tcr);\r\nsoc_writel(0, &timer->prdlo);\r\nval = soc_readl(&timer->tcr);\r\nsoc_writel(val & ~(TCR_CLKSRCLO | TCR_PWIDLO_MASK), &timer->tcr);\r\nval = soc_readl(&timer->tgcr) & ~TGCR_TIMMODE_MASK;\r\nsoc_writel(val, &timer->tgcr);\r\nsoc_writel(val | (TGCR_TIMLORS | TGCR_TIMMODE_UD32), &timer->tgcr);\r\n}\r\nstatic void timer64_disable(void)\r\n{\r\nsoc_writel(soc_readl(&timer->tcr) & ~TCR_ENAMODELO_MASK, &timer->tcr);\r\nsoc_writel(0, &timer->prdlo);\r\nif (timer64_devstate_id >= 0)\r\ndscr_set_devstate(timer64_devstate_id, DSCR_DEVSTATE_DISABLED);\r\n}\r\nstatic int next_event(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\ntimer64_config(delta);\r\nreturn 0;\r\n}\r\nstatic int set_periodic(struct clock_event_device *evt)\r\n{\r\ntimer64_enable();\r\ntimer64_mode = TIMER64_MODE_PERIODIC;\r\ntimer64_config(TIMER64_RATE / HZ);\r\nreturn 0;\r\n}\r\nstatic int set_oneshot(struct clock_event_device *evt)\r\n{\r\ntimer64_enable();\r\ntimer64_mode = TIMER64_MODE_ONE_SHOT;\r\nreturn 0;\r\n}\r\nstatic int shutdown(struct clock_event_device *evt)\r\n{\r\ntimer64_mode = TIMER64_MODE_DISABLED;\r\ntimer64_disable();\r\nreturn 0;\r\n}\r\nstatic irqreturn_t timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *cd = &t64_clockevent_device;\r\ncd->event_handler(cd);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init timer64_init(void)\r\n{\r\nstruct clock_event_device *cd = &t64_clockevent_device;\r\nstruct device_node *np, *first = NULL;\r\nu32 val;\r\nint err, found = 0;\r\nfor_each_compatible_node(np, NULL, "ti,c64x+timer64") {\r\nerr = of_property_read_u32(np, "ti,core-mask", &val);\r\nif (!err) {\r\nif (val & (1 << get_coreid())) {\r\nfound = 1;\r\nbreak;\r\n}\r\n} else if (!first)\r\nfirst = np;\r\n}\r\nif (!found) {\r\nif (first)\r\nnp = of_node_get(first);\r\nelse {\r\npr_debug("Cannot find ti,c64x+timer64 timer.\n");\r\nreturn;\r\n}\r\n}\r\ntimer = of_iomap(np, 0);\r\nif (!timer) {\r\npr_debug("%s: Cannot map timer registers.\n", np->full_name);\r\ngoto out;\r\n}\r\npr_debug("%s: Timer registers=%p.\n", np->full_name, timer);\r\ncd->irq = irq_of_parse_and_map(np, 0);\r\nif (cd->irq == NO_IRQ) {\r\npr_debug("%s: Cannot find interrupt.\n", np->full_name);\r\niounmap(timer);\r\ngoto out;\r\n}\r\nerr = of_property_read_u32(np, "ti,dscr-dev-enable", &val);\r\nif (!err) {\r\ntimer64_devstate_id = val;\r\ndscr_set_devstate(timer64_devstate_id, DSCR_DEVSTATE_ENABLED);\r\n}\r\npr_debug("%s: Timer irq=%d.\n", np->full_name, cd->irq);\r\nclockevents_calc_mult_shift(cd, c6x_core_freq / TIMER_DIVISOR, 5);\r\ncd->max_delta_ns = clockevent_delta2ns(0x7fffffff, cd);\r\ncd->min_delta_ns = clockevent_delta2ns(250, cd);\r\ncd->cpumask = cpumask_of(smp_processor_id());\r\nclockevents_register_device(cd);\r\nsetup_irq(cd->irq, &timer_iact);\r\nout:\r\nof_node_put(np);\r\nreturn;\r\n}
