static int wiimote_hid_send(struct hid_device *hdev, __u8 *buffer,\r\nsize_t count)\r\n{\r\n__u8 *buf;\r\nint ret;\r\nif (!hdev->ll_driver->output_report)\r\nreturn -ENODEV;\r\nbuf = kmemdup(buffer, count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = hid_hw_output_report(hdev, buf, count);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void wiimote_queue_worker(struct work_struct *work)\r\n{\r\nstruct wiimote_queue *queue = container_of(work, struct wiimote_queue,\r\nworker);\r\nstruct wiimote_data *wdata = container_of(queue, struct wiimote_data,\r\nqueue);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&wdata->queue.lock, flags);\r\nwhile (wdata->queue.head != wdata->queue.tail) {\r\nspin_unlock_irqrestore(&wdata->queue.lock, flags);\r\nret = wiimote_hid_send(wdata->hdev,\r\nwdata->queue.outq[wdata->queue.tail].data,\r\nwdata->queue.outq[wdata->queue.tail].size);\r\nif (ret < 0) {\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_abort(wdata);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nspin_lock_irqsave(&wdata->queue.lock, flags);\r\nwdata->queue.tail = (wdata->queue.tail + 1) % WIIMOTE_BUFSIZE;\r\n}\r\nspin_unlock_irqrestore(&wdata->queue.lock, flags);\r\n}\r\nstatic void wiimote_queue(struct wiimote_data *wdata, const __u8 *buffer,\r\nsize_t count)\r\n{\r\nunsigned long flags;\r\n__u8 newhead;\r\nif (count > HID_MAX_BUFFER_SIZE) {\r\nhid_warn(wdata->hdev, "Sending too large output report\n");\r\nspin_lock_irqsave(&wdata->queue.lock, flags);\r\ngoto out_error;\r\n}\r\nspin_lock_irqsave(&wdata->queue.lock, flags);\r\nmemcpy(wdata->queue.outq[wdata->queue.head].data, buffer, count);\r\nwdata->queue.outq[wdata->queue.head].size = count;\r\nnewhead = (wdata->queue.head + 1) % WIIMOTE_BUFSIZE;\r\nif (wdata->queue.head == wdata->queue.tail) {\r\nwdata->queue.head = newhead;\r\nschedule_work(&wdata->queue.worker);\r\n} else if (newhead != wdata->queue.tail) {\r\nwdata->queue.head = newhead;\r\n} else {\r\nhid_warn(wdata->hdev, "Output queue is full");\r\ngoto out_error;\r\n}\r\ngoto out_unlock;\r\nout_error:\r\nwiimote_cmd_abort(wdata);\r\nout_unlock:\r\nspin_unlock_irqrestore(&wdata->queue.lock, flags);\r\n}\r\nstatic inline void wiiproto_keep_rumble(struct wiimote_data *wdata, __u8 *cmd1)\r\n{\r\nif (wdata->state.flags & WIIPROTO_FLAG_RUMBLE)\r\n*cmd1 |= 0x01;\r\n}\r\nvoid wiiproto_req_rumble(struct wiimote_data *wdata, __u8 rumble)\r\n{\r\n__u8 cmd[2];\r\nrumble = !!rumble;\r\nif (rumble == !!(wdata->state.flags & WIIPROTO_FLAG_RUMBLE))\r\nreturn;\r\nif (rumble)\r\nwdata->state.flags |= WIIPROTO_FLAG_RUMBLE;\r\nelse\r\nwdata->state.flags &= ~WIIPROTO_FLAG_RUMBLE;\r\ncmd[0] = WIIPROTO_REQ_RUMBLE;\r\ncmd[1] = 0;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nvoid wiiproto_req_leds(struct wiimote_data *wdata, int leds)\r\n{\r\n__u8 cmd[2];\r\nleds &= WIIPROTO_FLAGS_LEDS;\r\nif ((wdata->state.flags & WIIPROTO_FLAGS_LEDS) == leds)\r\nreturn;\r\nwdata->state.flags = (wdata->state.flags & ~WIIPROTO_FLAGS_LEDS) | leds;\r\ncmd[0] = WIIPROTO_REQ_LED;\r\ncmd[1] = 0;\r\nif (leds & WIIPROTO_FLAG_LED1)\r\ncmd[1] |= 0x10;\r\nif (leds & WIIPROTO_FLAG_LED2)\r\ncmd[1] |= 0x20;\r\nif (leds & WIIPROTO_FLAG_LED3)\r\ncmd[1] |= 0x40;\r\nif (leds & WIIPROTO_FLAG_LED4)\r\ncmd[1] |= 0x80;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nstatic __u8 select_drm(struct wiimote_data *wdata)\r\n{\r\n__u8 ir = wdata->state.flags & WIIPROTO_FLAGS_IR;\r\nbool ext;\r\next = (wdata->state.flags & WIIPROTO_FLAG_EXT_USED) ||\r\n(wdata->state.flags & WIIPROTO_FLAG_MP_USED);\r\nif (wdata->state.devtype == WIIMOTE_DEV_BALANCE_BOARD) {\r\nif (ext)\r\nreturn WIIPROTO_REQ_DRM_KEE;\r\nelse\r\nreturn WIIPROTO_REQ_DRM_K;\r\n}\r\nif (ir == WIIPROTO_FLAG_IR_BASIC) {\r\nif (wdata->state.flags & WIIPROTO_FLAG_ACCEL) {\r\nreturn WIIPROTO_REQ_DRM_KAIE;\r\n} else {\r\nreturn WIIPROTO_REQ_DRM_KIE;\r\n}\r\n} else if (ir == WIIPROTO_FLAG_IR_EXT) {\r\nreturn WIIPROTO_REQ_DRM_KAI;\r\n} else if (ir == WIIPROTO_FLAG_IR_FULL) {\r\nreturn WIIPROTO_REQ_DRM_SKAI1;\r\n} else {\r\nif (wdata->state.flags & WIIPROTO_FLAG_ACCEL) {\r\nif (ext)\r\nreturn WIIPROTO_REQ_DRM_KAE;\r\nelse\r\nreturn WIIPROTO_REQ_DRM_KA;\r\n} else {\r\nif (ext)\r\nreturn WIIPROTO_REQ_DRM_KEE;\r\nelse\r\nreturn WIIPROTO_REQ_DRM_K;\r\n}\r\n}\r\n}\r\nvoid wiiproto_req_drm(struct wiimote_data *wdata, __u8 drm)\r\n{\r\n__u8 cmd[3];\r\nif (wdata->state.flags & WIIPROTO_FLAG_DRM_LOCKED)\r\ndrm = wdata->state.drm;\r\nelse if (drm == WIIPROTO_REQ_NULL)\r\ndrm = select_drm(wdata);\r\ncmd[0] = WIIPROTO_REQ_DRM;\r\ncmd[1] = 0;\r\ncmd[2] = drm;\r\nwdata->state.drm = drm;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nvoid wiiproto_req_status(struct wiimote_data *wdata)\r\n{\r\n__u8 cmd[2];\r\ncmd[0] = WIIPROTO_REQ_SREQ;\r\ncmd[1] = 0;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nvoid wiiproto_req_accel(struct wiimote_data *wdata, __u8 accel)\r\n{\r\naccel = !!accel;\r\nif (accel == !!(wdata->state.flags & WIIPROTO_FLAG_ACCEL))\r\nreturn;\r\nif (accel)\r\nwdata->state.flags |= WIIPROTO_FLAG_ACCEL;\r\nelse\r\nwdata->state.flags &= ~WIIPROTO_FLAG_ACCEL;\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\n}\r\nvoid wiiproto_req_ir1(struct wiimote_data *wdata, __u8 flags)\r\n{\r\n__u8 cmd[2];\r\ncmd[0] = WIIPROTO_REQ_IR1;\r\ncmd[1] = flags;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nvoid wiiproto_req_ir2(struct wiimote_data *wdata, __u8 flags)\r\n{\r\n__u8 cmd[2];\r\ncmd[0] = WIIPROTO_REQ_IR2;\r\ncmd[1] = flags;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nstatic void wiiproto_req_wmem(struct wiimote_data *wdata, bool eeprom,\r\n__u32 offset, const __u8 *buf, __u8 size)\r\n{\r\n__u8 cmd[22];\r\nif (size > 16 || size == 0) {\r\nhid_warn(wdata->hdev, "Invalid length %d wmem request\n", size);\r\nreturn;\r\n}\r\nmemset(cmd, 0, sizeof(cmd));\r\ncmd[0] = WIIPROTO_REQ_WMEM;\r\ncmd[2] = (offset >> 16) & 0xff;\r\ncmd[3] = (offset >> 8) & 0xff;\r\ncmd[4] = offset & 0xff;\r\ncmd[5] = size;\r\nmemcpy(&cmd[6], buf, size);\r\nif (!eeprom)\r\ncmd[1] |= 0x04;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nvoid wiiproto_req_rmem(struct wiimote_data *wdata, bool eeprom, __u32 offset,\r\n__u16 size)\r\n{\r\n__u8 cmd[7];\r\nif (size == 0) {\r\nhid_warn(wdata->hdev, "Invalid length %d rmem request\n", size);\r\nreturn;\r\n}\r\ncmd[0] = WIIPROTO_REQ_RMEM;\r\ncmd[1] = 0;\r\ncmd[2] = (offset >> 16) & 0xff;\r\ncmd[3] = (offset >> 8) & 0xff;\r\ncmd[4] = offset & 0xff;\r\ncmd[5] = (size >> 8) & 0xff;\r\ncmd[6] = size & 0xff;\r\nif (!eeprom)\r\ncmd[1] |= 0x04;\r\nwiiproto_keep_rumble(wdata, &cmd[1]);\r\nwiimote_queue(wdata, cmd, sizeof(cmd));\r\n}\r\nint wiimote_cmd_write(struct wiimote_data *wdata, __u32 offset,\r\nconst __u8 *wmem, __u8 size)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_WMEM, 0);\r\nwiiproto_req_wreg(wdata, offset, wmem, size);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nif (!ret && wdata->state.cmd_err)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nssize_t wiimote_cmd_read(struct wiimote_data *wdata, __u32 offset, __u8 *rmem,\r\n__u8 size)\r\n{\r\nunsigned long flags;\r\nssize_t ret;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.cmd_read_size = size;\r\nwdata->state.cmd_read_buf = rmem;\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_RMEM, offset & 0xffff);\r\nwiiproto_req_rreg(wdata, offset, size);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nret = wiimote_cmd_wait(wdata);\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.cmd_read_buf = NULL;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nif (!ret) {\r\nif (wdata->state.cmd_read_size == 0)\r\nret = -EIO;\r\nelse\r\nret = wdata->state.cmd_read_size;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wiimote_cmd_init_ext(struct wiimote_data *wdata)\r\n{\r\n__u8 wmem;\r\nint ret;\r\nwmem = 0x55;\r\nret = wiimote_cmd_write(wdata, 0xa400f0, &wmem, sizeof(wmem));\r\nif (ret)\r\nreturn ret;\r\nwmem = 0x0;\r\nret = wiimote_cmd_write(wdata, 0xa400fb, &wmem, sizeof(wmem));\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic __u8 wiimote_cmd_read_ext(struct wiimote_data *wdata, __u8 *rmem)\r\n{\r\nint ret;\r\nret = wiimote_cmd_read(wdata, 0xa400fa, rmem, 6);\r\nif (ret != 6)\r\nreturn WIIMOTE_EXT_NONE;\r\nhid_dbg(wdata->hdev, "extension ID: %6phC\n", rmem);\r\nif (rmem[0] == 0xff && rmem[1] == 0xff && rmem[2] == 0xff &&\r\nrmem[3] == 0xff && rmem[4] == 0xff && rmem[5] == 0xff)\r\nreturn WIIMOTE_EXT_NONE;\r\nif (rmem[4] == 0x00 && rmem[5] == 0x00)\r\nreturn WIIMOTE_EXT_NUNCHUK;\r\nif (rmem[4] == 0x01 && rmem[5] == 0x01)\r\nreturn WIIMOTE_EXT_CLASSIC_CONTROLLER;\r\nif (rmem[4] == 0x04 && rmem[5] == 0x02)\r\nreturn WIIMOTE_EXT_BALANCE_BOARD;\r\nif (rmem[4] == 0x01 && rmem[5] == 0x20)\r\nreturn WIIMOTE_EXT_PRO_CONTROLLER;\r\nreturn WIIMOTE_EXT_UNKNOWN;\r\n}\r\nstatic int wiimote_cmd_init_mp(struct wiimote_data *wdata)\r\n{\r\n__u8 wmem;\r\nint ret;\r\nwmem = 0x55;\r\nret = wiimote_cmd_write(wdata, 0xa600f0, &wmem, sizeof(wmem));\r\nif (ret)\r\nreturn ret;\r\nwmem = 0x0;\r\nret = wiimote_cmd_write(wdata, 0xa600fb, &wmem, sizeof(wmem));\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic bool wiimote_cmd_map_mp(struct wiimote_data *wdata, __u8 exttype)\r\n{\r\n__u8 wmem;\r\nswitch (exttype) {\r\ncase WIIMOTE_EXT_CLASSIC_CONTROLLER:\r\nwmem = 0x07;\r\nbreak;\r\ncase WIIMOTE_EXT_NUNCHUK:\r\nwmem = 0x05;\r\nbreak;\r\ndefault:\r\nwmem = 0x04;\r\nbreak;\r\n}\r\nreturn wiimote_cmd_write(wdata, 0xa600fe, &wmem, sizeof(wmem));\r\n}\r\nstatic bool wiimote_cmd_read_mp(struct wiimote_data *wdata, __u8 *rmem)\r\n{\r\nint ret;\r\nret = wiimote_cmd_read(wdata, 0xa600fa, rmem, 6);\r\nif (ret != 6)\r\nreturn false;\r\nhid_dbg(wdata->hdev, "motion plus ID: %6phC\n", rmem);\r\nif (rmem[5] == 0x05)\r\nreturn true;\r\nhid_info(wdata->hdev, "unknown motion plus ID: %6phC\n", rmem);\r\nreturn false;\r\n}\r\nstatic __u8 wiimote_cmd_read_mp_mapped(struct wiimote_data *wdata)\r\n{\r\nint ret;\r\n__u8 rmem[6];\r\nret = wiimote_cmd_read(wdata, 0xa400fa, rmem, 6);\r\nif (ret != 6)\r\nreturn WIIMOTE_MP_NONE;\r\nhid_dbg(wdata->hdev, "mapped motion plus ID: %6phC\n", rmem);\r\nif (rmem[0] == 0xff && rmem[1] == 0xff && rmem[2] == 0xff &&\r\nrmem[3] == 0xff && rmem[4] == 0xff && rmem[5] == 0xff)\r\nreturn WIIMOTE_MP_NONE;\r\nif (rmem[4] == 0x04 && rmem[5] == 0x05)\r\nreturn WIIMOTE_MP_SINGLE;\r\nelse if (rmem[4] == 0x05 && rmem[5] == 0x05)\r\nreturn WIIMOTE_MP_PASSTHROUGH_NUNCHUK;\r\nelse if (rmem[4] == 0x07 && rmem[5] == 0x05)\r\nreturn WIIMOTE_MP_PASSTHROUGH_CLASSIC;\r\nreturn WIIMOTE_MP_UNKNOWN;\r\n}\r\nstatic void wiimote_modules_load(struct wiimote_data *wdata,\r\nunsigned int devtype)\r\n{\r\nbool need_input = false;\r\nconst __u8 *mods, *iter;\r\nconst struct wiimod_ops *ops;\r\nint ret;\r\nmods = wiimote_devtype_mods[devtype];\r\nfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\r\nif (wiimod_table[*iter]->flags & WIIMOD_FLAG_INPUT) {\r\nneed_input = true;\r\nbreak;\r\n}\r\n}\r\nif (need_input) {\r\nwdata->input = input_allocate_device();\r\nif (!wdata->input)\r\nreturn;\r\ninput_set_drvdata(wdata->input, wdata);\r\nwdata->input->dev.parent = &wdata->hdev->dev;\r\nwdata->input->id.bustype = wdata->hdev->bus;\r\nwdata->input->id.vendor = wdata->hdev->vendor;\r\nwdata->input->id.product = wdata->hdev->product;\r\nwdata->input->id.version = wdata->hdev->version;\r\nwdata->input->name = WIIMOTE_NAME;\r\n}\r\nfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\r\nops = wiimod_table[*iter];\r\nif (!ops->probe)\r\ncontinue;\r\nret = ops->probe(ops, wdata);\r\nif (ret)\r\ngoto error;\r\n}\r\nif (wdata->input) {\r\nret = input_register_device(wdata->input);\r\nif (ret)\r\ngoto error;\r\n}\r\nspin_lock_irq(&wdata->state.lock);\r\nwdata->state.devtype = devtype;\r\nspin_unlock_irq(&wdata->state.lock);\r\nreturn;\r\nerror:\r\nfor ( ; iter-- != mods; ) {\r\nops = wiimod_table[*iter];\r\nif (ops->remove)\r\nops->remove(ops, wdata);\r\n}\r\nif (wdata->input) {\r\ninput_free_device(wdata->input);\r\nwdata->input = NULL;\r\n}\r\n}\r\nstatic void wiimote_modules_unload(struct wiimote_data *wdata)\r\n{\r\nconst __u8 *mods, *iter;\r\nconst struct wiimod_ops *ops;\r\nunsigned long flags;\r\nmods = wiimote_devtype_mods[wdata->state.devtype];\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.devtype = WIIMOTE_DEV_UNKNOWN;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nfor (iter = mods; *iter != WIIMOD_NULL; ++iter)\r\n;\r\nif (wdata->input) {\r\ninput_get_device(wdata->input);\r\ninput_unregister_device(wdata->input);\r\n}\r\nfor ( ; iter-- != mods; ) {\r\nops = wiimod_table[*iter];\r\nif (ops->remove)\r\nops->remove(ops, wdata);\r\n}\r\nif (wdata->input) {\r\ninput_put_device(wdata->input);\r\nwdata->input = NULL;\r\n}\r\n}\r\nstatic void wiimote_ext_load(struct wiimote_data *wdata, unsigned int ext)\r\n{\r\nunsigned long flags;\r\nconst struct wiimod_ops *ops;\r\nint ret;\r\nops = wiimod_ext_table[ext];\r\nif (ops->probe) {\r\nret = ops->probe(ops, wdata);\r\nif (ret)\r\next = WIIMOTE_EXT_UNKNOWN;\r\n}\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.exttype = ext;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic void wiimote_ext_unload(struct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nconst struct wiimod_ops *ops;\r\nops = wiimod_ext_table[wdata->state.exttype];\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.exttype = WIIMOTE_EXT_UNKNOWN;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_USED;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nif (ops->remove)\r\nops->remove(ops, wdata);\r\n}\r\nstatic void wiimote_mp_load(struct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nconst struct wiimod_ops *ops;\r\nint ret;\r\n__u8 mode = 2;\r\nops = &wiimod_mp;\r\nif (ops->probe) {\r\nret = ops->probe(ops, wdata);\r\nif (ret)\r\nmode = 1;\r\n}\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.mp = mode;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic void wiimote_mp_unload(struct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nconst struct wiimod_ops *ops;\r\nif (wdata->state.mp < 2)\r\nreturn;\r\nops = &wiimod_mp;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.mp = 0;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_MP_USED;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nif (ops->remove)\r\nops->remove(ops, wdata);\r\n}\r\nstatic void wiimote_init_set_type(struct wiimote_data *wdata,\r\n__u8 exttype)\r\n{\r\n__u8 devtype = WIIMOTE_DEV_GENERIC;\r\n__u16 vendor, product;\r\nconst char *name;\r\nvendor = wdata->hdev->vendor;\r\nproduct = wdata->hdev->product;\r\nname = wdata->hdev->name;\r\nif (exttype == WIIMOTE_EXT_BALANCE_BOARD) {\r\ndevtype = WIIMOTE_DEV_BALANCE_BOARD;\r\ngoto done;\r\n} else if (exttype == WIIMOTE_EXT_PRO_CONTROLLER) {\r\ndevtype = WIIMOTE_DEV_PRO_CONTROLLER;\r\ngoto done;\r\n}\r\nif (!strcmp(name, "Nintendo RVL-CNT-01")) {\r\ndevtype = WIIMOTE_DEV_GEN10;\r\ngoto done;\r\n} else if (!strcmp(name, "Nintendo RVL-CNT-01-TR")) {\r\ndevtype = WIIMOTE_DEV_GEN20;\r\ngoto done;\r\n} else if (!strcmp(name, "Nintendo RVL-WBC-01")) {\r\ndevtype = WIIMOTE_DEV_BALANCE_BOARD;\r\ngoto done;\r\n} else if (!strcmp(name, "Nintendo RVL-CNT-01-UC")) {\r\ndevtype = WIIMOTE_DEV_PRO_CONTROLLER;\r\ngoto done;\r\n}\r\nif (vendor == USB_VENDOR_ID_NINTENDO) {\r\nif (product == USB_DEVICE_ID_NINTENDO_WIIMOTE) {\r\ndevtype = WIIMOTE_DEV_GEN10;\r\ngoto done;\r\n} else if (product == USB_DEVICE_ID_NINTENDO_WIIMOTE2) {\r\ndevtype = WIIMOTE_DEV_GEN20;\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nif (devtype == WIIMOTE_DEV_GENERIC)\r\nhid_info(wdata->hdev, "cannot detect device; NAME: %s VID: %04x PID: %04x EXT: %04x\n",\r\nname, vendor, product, exttype);\r\nelse\r\nhid_info(wdata->hdev, "detected device: %s\n",\r\nwiimote_devtype_names[devtype]);\r\nwiimote_modules_load(wdata, devtype);\r\n}\r\nstatic void wiimote_init_detect(struct wiimote_data *wdata)\r\n{\r\n__u8 exttype = WIIMOTE_EXT_NONE, extdata[6];\r\nbool ext;\r\nint ret;\r\nwiimote_cmd_acquire_noint(wdata);\r\nspin_lock_irq(&wdata->state.lock);\r\nwdata->state.devtype = WIIMOTE_DEV_UNKNOWN;\r\nwiimote_cmd_set(wdata, WIIPROTO_REQ_SREQ, 0);\r\nwiiproto_req_status(wdata);\r\nspin_unlock_irq(&wdata->state.lock);\r\nret = wiimote_cmd_wait_noint(wdata);\r\nif (ret)\r\ngoto out_release;\r\nspin_lock_irq(&wdata->state.lock);\r\next = wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED;\r\nspin_unlock_irq(&wdata->state.lock);\r\nif (!ext)\r\ngoto out_release;\r\nwiimote_cmd_init_ext(wdata);\r\nexttype = wiimote_cmd_read_ext(wdata, extdata);\r\nout_release:\r\nwiimote_cmd_release(wdata);\r\nwiimote_init_set_type(wdata, exttype);\r\nspin_lock_irq(&wdata->state.lock);\r\nif (!(wdata->state.flags & WIIPROTO_FLAG_BUILTIN_MP) &&\r\n!(wdata->state.flags & WIIPROTO_FLAG_NO_MP))\r\nmod_timer(&wdata->timer, jiffies + HZ * 4);\r\nspin_unlock_irq(&wdata->state.lock);\r\n}\r\nstatic void wiimote_init_poll_mp(struct wiimote_data *wdata)\r\n{\r\nbool mp;\r\n__u8 mpdata[6];\r\nwiimote_cmd_acquire_noint(wdata);\r\nwiimote_cmd_init_mp(wdata);\r\nmp = wiimote_cmd_read_mp(wdata, mpdata);\r\nwiimote_cmd_release(wdata);\r\nif (mp) {\r\nif (!wdata->state.mp) {\r\nhid_info(wdata->hdev, "detected extension: Nintendo Wii Motion Plus\n");\r\nwiimote_mp_load(wdata);\r\n}\r\n} else if (wdata->state.mp) {\r\nwiimote_mp_unload(wdata);\r\n}\r\nmod_timer(&wdata->timer, jiffies + HZ * 4);\r\n}\r\nstatic bool wiimote_init_check(struct wiimote_data *wdata)\r\n{\r\n__u32 flags;\r\n__u8 type, data[6];\r\nbool ret, poll_mp;\r\nspin_lock_irq(&wdata->state.lock);\r\nflags = wdata->state.flags;\r\nspin_unlock_irq(&wdata->state.lock);\r\nwiimote_cmd_acquire_noint(wdata);\r\nif (wdata->state.exttype == WIIMOTE_EXT_NONE &&\r\nwdata->state.mp > 0 && (flags & WIIPROTO_FLAG_MP_USED)) {\r\ntype = wiimote_cmd_read_mp_mapped(wdata);\r\nret = type == WIIMOTE_MP_SINGLE;\r\nspin_lock_irq(&wdata->state.lock);\r\nret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);\r\nret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_PLUGGED);\r\nret = ret && (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);\r\nspin_unlock_irq(&wdata->state.lock);\r\nif (!ret)\r\nhid_dbg(wdata->hdev, "state left: !EXT && MP\n");\r\npoll_mp = false;\r\ngoto out_release;\r\n}\r\nif (!(flags & WIIPROTO_FLAG_MP_USED) &&\r\nwdata->state.exttype != WIIMOTE_EXT_NONE) {\r\ntype = wiimote_cmd_read_ext(wdata, data);\r\nret = type == wdata->state.exttype;\r\nspin_lock_irq(&wdata->state.lock);\r\nret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);\r\nret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);\r\nspin_unlock_irq(&wdata->state.lock);\r\nif (!ret)\r\nhid_dbg(wdata->hdev, "state left: EXT && !MP\n");\r\npoll_mp = true;\r\ngoto out_release;\r\n}\r\nif (!(flags & WIIPROTO_FLAG_MP_USED) &&\r\nwdata->state.exttype == WIIMOTE_EXT_NONE) {\r\ntype = wiimote_cmd_read_ext(wdata, data);\r\nret = type == wdata->state.exttype;\r\nspin_lock_irq(&wdata->state.lock);\r\nret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);\r\nret = ret && !(wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);\r\nret = ret && !(wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED);\r\nspin_unlock_irq(&wdata->state.lock);\r\nif (!ret)\r\nhid_dbg(wdata->hdev, "state left: !EXT && !MP\n");\r\npoll_mp = true;\r\ngoto out_release;\r\n}\r\nif (wdata->state.exttype != WIIMOTE_EXT_NONE &&\r\nwdata->state.mp > 0 && (flags & WIIPROTO_FLAG_MP_USED)) {\r\ntype = wiimote_cmd_read_mp_mapped(wdata);\r\nret = type != WIIMOTE_MP_NONE;\r\nret = ret && type != WIIMOTE_MP_UNKNOWN;\r\nret = ret && type != WIIMOTE_MP_SINGLE;\r\nspin_lock_irq(&wdata->state.lock);\r\nret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED);\r\nret = ret && (wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE);\r\nret = ret && (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE);\r\nspin_unlock_irq(&wdata->state.lock);\r\nif (!ret)\r\nhid_dbg(wdata->hdev, "state left: EXT && MP\n");\r\npoll_mp = false;\r\ngoto out_release;\r\n}\r\nret = false;\r\nout_release:\r\nwiimote_cmd_release(wdata);\r\nif (ret && poll_mp && !(flags & WIIPROTO_FLAG_BUILTIN_MP) &&\r\n!(flags & WIIPROTO_FLAG_NO_MP))\r\nwiimote_init_poll_mp(wdata);\r\nreturn ret;\r\n}\r\nstatic void wiimote_init_hotplug(struct wiimote_data *wdata)\r\n{\r\n__u8 exttype, extdata[6], mpdata[6];\r\n__u32 flags;\r\nbool mp;\r\nhid_dbg(wdata->hdev, "detect extensions..\n");\r\nwiimote_cmd_acquire_noint(wdata);\r\nspin_lock_irq(&wdata->state.lock);\r\nflags = wdata->state.flags;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_ACTIVE;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_MP_ACTIVE;\r\nspin_unlock_irq(&wdata->state.lock);\r\nwiimote_cmd_init_ext(wdata);\r\nif (flags & WIIPROTO_FLAG_NO_MP) {\r\nmp = false;\r\n} else {\r\nwiimote_cmd_init_mp(wdata);\r\nmp = wiimote_cmd_read_mp(wdata, mpdata);\r\n}\r\nexttype = wiimote_cmd_read_ext(wdata, extdata);\r\nwiimote_cmd_release(wdata);\r\nif (exttype != wdata->state.exttype) {\r\nwiimote_ext_unload(wdata);\r\nif (exttype == WIIMOTE_EXT_UNKNOWN) {\r\nhid_info(wdata->hdev, "cannot detect extension; %6phC\n",\r\nextdata);\r\n} else if (exttype == WIIMOTE_EXT_NONE) {\r\nspin_lock_irq(&wdata->state.lock);\r\nwdata->state.exttype = WIIMOTE_EXT_NONE;\r\nspin_unlock_irq(&wdata->state.lock);\r\n} else {\r\nhid_info(wdata->hdev, "detected extension: %s\n",\r\nwiimote_exttype_names[exttype]);\r\nwiimote_ext_load(wdata, exttype);\r\n}\r\n}\r\nif (mp) {\r\nif (!wdata->state.mp) {\r\nhid_info(wdata->hdev, "detected extension: Nintendo Wii Motion Plus\n");\r\nwiimote_mp_load(wdata);\r\n}\r\n} else if (wdata->state.mp) {\r\nwiimote_mp_unload(wdata);\r\n}\r\nif (!(flags & WIIPROTO_FLAG_MP_USED))\r\nmp = false;\r\nif (mp) {\r\nwiimote_cmd_acquire_noint(wdata);\r\nwiimote_cmd_map_mp(wdata, exttype);\r\nwiimote_cmd_release(wdata);\r\ndel_timer_sync(&wdata->timer);\r\n} else {\r\nif (!(flags & WIIPROTO_FLAG_BUILTIN_MP) &&\r\n!(flags & WIIPROTO_FLAG_NO_MP))\r\nmod_timer(&wdata->timer, jiffies + HZ * 4);\r\n}\r\nspin_lock_irq(&wdata->state.lock);\r\nif (mp) {\r\nwdata->state.flags |= WIIPROTO_FLAG_MP_ACTIVE;\r\nif (wdata->state.exttype == WIIMOTE_EXT_NONE) {\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_PLUGGED;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_MP_PLUGGED;\r\n} else {\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_PLUGGED;\r\nwdata->state.flags |= WIIPROTO_FLAG_MP_PLUGGED;\r\nwdata->state.flags |= WIIPROTO_FLAG_EXT_ACTIVE;\r\n}\r\n} else if (wdata->state.exttype != WIIMOTE_EXT_NONE) {\r\nwdata->state.flags |= WIIPROTO_FLAG_EXT_ACTIVE;\r\n}\r\nwiiproto_req_status(wdata);\r\nspin_unlock_irq(&wdata->state.lock);\r\nhid_dbg(wdata->hdev, "detected extensions: MP: %d EXT: %d\n",\r\nwdata->state.mp, wdata->state.exttype);\r\n}\r\nstatic void wiimote_init_worker(struct work_struct *work)\r\n{\r\nstruct wiimote_data *wdata = container_of(work, struct wiimote_data,\r\ninit_worker);\r\nbool changed = false;\r\nif (wdata->state.devtype == WIIMOTE_DEV_PENDING) {\r\nwiimote_init_detect(wdata);\r\nchanged = true;\r\n}\r\nif (changed || !wiimote_init_check(wdata))\r\nwiimote_init_hotplug(wdata);\r\nif (changed)\r\nkobject_uevent(&wdata->hdev->dev.kobj, KOBJ_CHANGE);\r\n}\r\nvoid __wiimote_schedule(struct wiimote_data *wdata)\r\n{\r\nif (!(wdata->state.flags & WIIPROTO_FLAG_EXITING))\r\nschedule_work(&wdata->init_worker);\r\n}\r\nstatic void wiimote_schedule(struct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\n__wiimote_schedule(wdata);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\n}\r\nstatic void wiimote_init_timeout(unsigned long arg)\r\n{\r\nstruct wiimote_data *wdata = (void*)arg;\r\nwiimote_schedule(wdata);\r\n}\r\nstatic void handler_keys(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nconst __u8 *iter, *mods;\r\nconst struct wiimod_ops *ops;\r\nops = wiimod_ext_table[wdata->state.exttype];\r\nif (ops->in_keys) {\r\nops->in_keys(wdata, payload);\r\nreturn;\r\n}\r\nmods = wiimote_devtype_mods[wdata->state.devtype];\r\nfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\r\nops = wiimod_table[*iter];\r\nif (ops->in_keys) {\r\nops->in_keys(wdata, payload);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void handler_accel(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nconst __u8 *iter, *mods;\r\nconst struct wiimod_ops *ops;\r\nops = wiimod_ext_table[wdata->state.exttype];\r\nif (ops->in_accel) {\r\nops->in_accel(wdata, payload);\r\nreturn;\r\n}\r\nmods = wiimote_devtype_mods[wdata->state.devtype];\r\nfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\r\nops = wiimod_table[*iter];\r\nif (ops->in_accel) {\r\nops->in_accel(wdata, payload);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic bool valid_ext_handler(const struct wiimod_ops *ops, size_t len)\r\n{\r\nif (!ops->in_ext)\r\nreturn false;\r\nif ((ops->flags & WIIMOD_FLAG_EXT8) && len < 8)\r\nreturn false;\r\nif ((ops->flags & WIIMOD_FLAG_EXT16) && len < 16)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void handler_ext(struct wiimote_data *wdata, const __u8 *payload,\r\nsize_t len)\r\n{\r\nstatic const __u8 invalid[21] = { 0xff, 0xff, 0xff, 0xff,\r\n0xff, 0xff, 0xff, 0xff,\r\n0xff, 0xff, 0xff, 0xff,\r\n0xff, 0xff, 0xff, 0xff,\r\n0xff, 0xff, 0xff, 0xff,\r\n0xff };\r\nconst __u8 *iter, *mods;\r\nconst struct wiimod_ops *ops;\r\nbool is_mp;\r\nif (len > 21)\r\nlen = 21;\r\nif (len < 6 || !memcmp(payload, invalid, len))\r\nreturn;\r\nif (wdata->state.flags & WIIPROTO_FLAG_MP_ACTIVE) {\r\nif (payload[5] & 0x01)\r\nreturn;\r\nif (payload[4] & 0x01) {\r\nif (!(wdata->state.flags & WIIPROTO_FLAG_MP_PLUGGED)) {\r\nhid_dbg(wdata->hdev, "MP hotplug: 1\n");\r\nwdata->state.flags |= WIIPROTO_FLAG_MP_PLUGGED;\r\n__wiimote_schedule(wdata);\r\n}\r\n} else {\r\nif (wdata->state.flags & WIIPROTO_FLAG_MP_PLUGGED) {\r\nhid_dbg(wdata->hdev, "MP hotplug: 0\n");\r\nwdata->state.flags &= ~WIIPROTO_FLAG_MP_PLUGGED;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_ACTIVE;\r\n__wiimote_schedule(wdata);\r\n}\r\n}\r\nis_mp = payload[5] & 0x02;\r\n} else {\r\nis_mp = false;\r\n}\r\nif (!(wdata->state.flags & WIIPROTO_FLAG_EXT_ACTIVE) && !is_mp)\r\nreturn;\r\nops = wiimod_ext_table[wdata->state.exttype];\r\nif (is_mp && ops->in_mp) {\r\nops->in_mp(wdata, payload);\r\nreturn;\r\n} else if (!is_mp && valid_ext_handler(ops, len)) {\r\nops->in_ext(wdata, payload);\r\nreturn;\r\n}\r\nops = &wiimod_mp;\r\nif (is_mp && ops->in_mp) {\r\nops->in_mp(wdata, payload);\r\nreturn;\r\n} else if (!is_mp && valid_ext_handler(ops, len)) {\r\nops->in_ext(wdata, payload);\r\nreturn;\r\n}\r\nmods = wiimote_devtype_mods[wdata->state.devtype];\r\nfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\r\nops = wiimod_table[*iter];\r\nif (is_mp && ops->in_mp) {\r\nops->in_mp(wdata, payload);\r\nreturn;\r\n} else if (!is_mp && valid_ext_handler(ops, len)) {\r\nops->in_ext(wdata, payload);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void handler_ir(struct wiimote_data *wdata, const __u8 *payload,\r\nbool packed, unsigned int id)\r\n{\r\nconst __u8 *iter, *mods;\r\nconst struct wiimod_ops *ops;\r\nops = wiimod_ext_table[wdata->state.exttype];\r\nif (ops->in_ir) {\r\nops->in_ir(wdata, payload, packed, id);\r\nreturn;\r\n}\r\nmods = wiimote_devtype_mods[wdata->state.devtype];\r\nfor (iter = mods; *iter != WIIMOD_NULL; ++iter) {\r\nops = wiimod_table[*iter];\r\nif (ops->in_ir) {\r\nops->in_ir(wdata, payload, packed, id);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void handler_status_K(struct wiimote_data *wdata,\r\nconst __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nwiiproto_req_drm(wdata, WIIPROTO_REQ_NULL);\r\n}\r\nstatic void handler_status(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_status_K(wdata, payload);\r\nif (payload[2] & 0x02) {\r\nif (!(wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED)) {\r\nhid_dbg(wdata->hdev, "EXT hotplug: 1\n");\r\nwdata->state.flags |= WIIPROTO_FLAG_EXT_PLUGGED;\r\n__wiimote_schedule(wdata);\r\n}\r\n} else {\r\nif (wdata->state.flags & WIIPROTO_FLAG_EXT_PLUGGED) {\r\nhid_dbg(wdata->hdev, "EXT hotplug: 0\n");\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_PLUGGED;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_MP_PLUGGED;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_EXT_ACTIVE;\r\nwdata->state.flags &= ~WIIPROTO_FLAG_MP_ACTIVE;\r\n__wiimote_schedule(wdata);\r\n}\r\n}\r\nwdata->state.cmd_battery = payload[5];\r\nif (wiimote_cmd_pending(wdata, WIIPROTO_REQ_SREQ, 0))\r\nwiimote_cmd_complete(wdata);\r\n}\r\nstatic void handler_generic_K(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\n}\r\nstatic void handler_data(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\n__u16 offset = payload[3] << 8 | payload[4];\r\n__u8 size = (payload[2] >> 4) + 1;\r\n__u8 err = payload[2] & 0x0f;\r\nhandler_keys(wdata, payload);\r\nif (wiimote_cmd_pending(wdata, WIIPROTO_REQ_RMEM, offset)) {\r\nif (err)\r\nsize = 0;\r\nelse if (size > wdata->state.cmd_read_size)\r\nsize = wdata->state.cmd_read_size;\r\nwdata->state.cmd_read_size = size;\r\nif (wdata->state.cmd_read_buf)\r\nmemcpy(wdata->state.cmd_read_buf, &payload[5], size);\r\nwiimote_cmd_complete(wdata);\r\n}\r\n}\r\nstatic void handler_return(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\n__u8 err = payload[3];\r\n__u8 cmd = payload[2];\r\nhandler_keys(wdata, payload);\r\nif (wiimote_cmd_pending(wdata, cmd, 0)) {\r\nwdata->state.cmd_err = err;\r\nwiimote_cmd_complete(wdata);\r\n} else if (err) {\r\nhid_warn(wdata->hdev, "Remote error %hhu on req %hhu\n", err,\r\ncmd);\r\n}\r\n}\r\nstatic void handler_drm_KA(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_accel(wdata, payload);\r\n}\r\nstatic void handler_drm_KE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_ext(wdata, &payload[2], 8);\r\n}\r\nstatic void handler_drm_KAI(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_accel(wdata, payload);\r\nir_to_input0(wdata, &payload[5], false);\r\nir_to_input1(wdata, &payload[8], false);\r\nir_to_input2(wdata, &payload[11], false);\r\nir_to_input3(wdata, &payload[14], false);\r\n}\r\nstatic void handler_drm_KEE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_ext(wdata, &payload[2], 19);\r\n}\r\nstatic void handler_drm_KIE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nir_to_input0(wdata, &payload[2], false);\r\nir_to_input1(wdata, &payload[4], true);\r\nir_to_input2(wdata, &payload[7], false);\r\nir_to_input3(wdata, &payload[9], true);\r\nhandler_ext(wdata, &payload[12], 9);\r\n}\r\nstatic void handler_drm_KAE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_accel(wdata, payload);\r\nhandler_ext(wdata, &payload[5], 16);\r\n}\r\nstatic void handler_drm_KAIE(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nhandler_accel(wdata, payload);\r\nir_to_input0(wdata, &payload[5], false);\r\nir_to_input1(wdata, &payload[7], true);\r\nir_to_input2(wdata, &payload[10], false);\r\nir_to_input3(wdata, &payload[12], true);\r\nhandler_ext(wdata, &payload[15], 6);\r\n}\r\nstatic void handler_drm_E(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_ext(wdata, payload, 21);\r\n}\r\nstatic void handler_drm_SKAI1(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\nhandler_keys(wdata, payload);\r\nwdata->state.accel_split[0] = payload[2];\r\nwdata->state.accel_split[1] = (payload[0] >> 1) & (0x10 | 0x20);\r\nwdata->state.accel_split[1] |= (payload[1] << 1) & (0x40 | 0x80);\r\nir_to_input0(wdata, &payload[3], false);\r\nir_to_input1(wdata, &payload[12], false);\r\n}\r\nstatic void handler_drm_SKAI2(struct wiimote_data *wdata, const __u8 *payload)\r\n{\r\n__u8 buf[5];\r\nhandler_keys(wdata, payload);\r\nwdata->state.accel_split[1] |= (payload[0] >> 5) & (0x01 | 0x02);\r\nwdata->state.accel_split[1] |= (payload[1] >> 3) & (0x04 | 0x08);\r\nbuf[0] = 0;\r\nbuf[1] = 0;\r\nbuf[2] = wdata->state.accel_split[0];\r\nbuf[3] = payload[2];\r\nbuf[4] = wdata->state.accel_split[1];\r\nhandler_accel(wdata, buf);\r\nir_to_input2(wdata, &payload[3], false);\r\nir_to_input3(wdata, &payload[12], false);\r\n}\r\nstatic int wiimote_hid_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *raw_data, int size)\r\n{\r\nstruct wiimote_data *wdata = hid_get_drvdata(hdev);\r\nstruct wiiproto_handler *h;\r\nint i;\r\nunsigned long flags;\r\nif (size < 1)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nfor (i = 0; handlers[i].id; ++i) {\r\nh = &handlers[i];\r\nif (h->id == raw_data[0] && h->size < size) {\r\nh->func(wdata, &raw_data[1]);\r\nbreak;\r\n}\r\n}\r\nif (!handlers[i].id)\r\nhid_warn(hdev, "Unhandled report %hhu size %d\n", raw_data[0],\r\nsize);\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t wiimote_ext_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct wiimote_data *wdata = dev_to_wii(dev);\r\n__u8 type;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\ntype = wdata->state.exttype;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nswitch (type) {\r\ncase WIIMOTE_EXT_NONE:\r\nreturn sprintf(buf, "none\n");\r\ncase WIIMOTE_EXT_NUNCHUK:\r\nreturn sprintf(buf, "nunchuk\n");\r\ncase WIIMOTE_EXT_CLASSIC_CONTROLLER:\r\nreturn sprintf(buf, "classic\n");\r\ncase WIIMOTE_EXT_BALANCE_BOARD:\r\nreturn sprintf(buf, "balanceboard\n");\r\ncase WIIMOTE_EXT_PRO_CONTROLLER:\r\nreturn sprintf(buf, "procontroller\n");\r\ncase WIIMOTE_EXT_UNKNOWN:\r\ndefault:\r\nreturn sprintf(buf, "unknown\n");\r\n}\r\n}\r\nstatic ssize_t wiimote_ext_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct wiimote_data *wdata = dev_to_wii(dev);\r\nif (!strcmp(buf, "scan")) {\r\nwiimote_schedule(wdata);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn strnlen(buf, PAGE_SIZE);\r\n}\r\nstatic ssize_t wiimote_dev_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct wiimote_data *wdata = dev_to_wii(dev);\r\n__u8 type;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\ntype = wdata->state.devtype;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\nswitch (type) {\r\ncase WIIMOTE_DEV_GENERIC:\r\nreturn sprintf(buf, "generic\n");\r\ncase WIIMOTE_DEV_GEN10:\r\nreturn sprintf(buf, "gen10\n");\r\ncase WIIMOTE_DEV_GEN20:\r\nreturn sprintf(buf, "gen20\n");\r\ncase WIIMOTE_DEV_BALANCE_BOARD:\r\nreturn sprintf(buf, "balanceboard\n");\r\ncase WIIMOTE_DEV_PRO_CONTROLLER:\r\nreturn sprintf(buf, "procontroller\n");\r\ncase WIIMOTE_DEV_PENDING:\r\nreturn sprintf(buf, "pending\n");\r\ncase WIIMOTE_DEV_UNKNOWN:\r\ndefault:\r\nreturn sprintf(buf, "unknown\n");\r\n}\r\n}\r\nstatic struct wiimote_data *wiimote_create(struct hid_device *hdev)\r\n{\r\nstruct wiimote_data *wdata;\r\nwdata = kzalloc(sizeof(*wdata), GFP_KERNEL);\r\nif (!wdata)\r\nreturn NULL;\r\nwdata->hdev = hdev;\r\nhid_set_drvdata(hdev, wdata);\r\nspin_lock_init(&wdata->queue.lock);\r\nINIT_WORK(&wdata->queue.worker, wiimote_queue_worker);\r\nspin_lock_init(&wdata->state.lock);\r\ninit_completion(&wdata->state.ready);\r\nmutex_init(&wdata->state.sync);\r\nwdata->state.drm = WIIPROTO_REQ_DRM_K;\r\nwdata->state.cmd_battery = 0xff;\r\nINIT_WORK(&wdata->init_worker, wiimote_init_worker);\r\nsetup_timer(&wdata->timer, wiimote_init_timeout, (long)wdata);\r\nreturn wdata;\r\n}\r\nstatic void wiimote_destroy(struct wiimote_data *wdata)\r\n{\r\nunsigned long flags;\r\nwiidebug_deinit(wdata);\r\nspin_lock_irqsave(&wdata->state.lock, flags);\r\nwdata->state.flags |= WIIPROTO_FLAG_EXITING;\r\nspin_unlock_irqrestore(&wdata->state.lock, flags);\r\ncancel_work_sync(&wdata->init_worker);\r\ndel_timer_sync(&wdata->timer);\r\ndevice_remove_file(&wdata->hdev->dev, &dev_attr_devtype);\r\ndevice_remove_file(&wdata->hdev->dev, &dev_attr_extension);\r\nwiimote_mp_unload(wdata);\r\nwiimote_ext_unload(wdata);\r\nwiimote_modules_unload(wdata);\r\ncancel_work_sync(&wdata->queue.worker);\r\nhid_hw_close(wdata->hdev);\r\nhid_hw_stop(wdata->hdev);\r\nkfree(wdata);\r\n}\r\nstatic int wiimote_hid_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nstruct wiimote_data *wdata;\r\nint ret;\r\nhdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\r\nwdata = wiimote_create(hdev);\r\nif (!wdata) {\r\nhid_err(hdev, "Can't alloc device\n");\r\nreturn -ENOMEM;\r\n}\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "HID parse failed\n");\r\ngoto err;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\r\nif (ret) {\r\nhid_err(hdev, "HW start failed\n");\r\ngoto err;\r\n}\r\nret = hid_hw_open(hdev);\r\nif (ret) {\r\nhid_err(hdev, "cannot start hardware I/O\n");\r\ngoto err_stop;\r\n}\r\nret = device_create_file(&hdev->dev, &dev_attr_extension);\r\nif (ret) {\r\nhid_err(hdev, "cannot create sysfs attribute\n");\r\ngoto err_close;\r\n}\r\nret = device_create_file(&hdev->dev, &dev_attr_devtype);\r\nif (ret) {\r\nhid_err(hdev, "cannot create sysfs attribute\n");\r\ngoto err_ext;\r\n}\r\nret = wiidebug_init(wdata);\r\nif (ret)\r\ngoto err_free;\r\nhid_info(hdev, "New device registered\n");\r\nwiimote_schedule(wdata);\r\nreturn 0;\r\nerr_free:\r\nwiimote_destroy(wdata);\r\nreturn ret;\r\nerr_ext:\r\ndevice_remove_file(&wdata->hdev->dev, &dev_attr_extension);\r\nerr_close:\r\nhid_hw_close(hdev);\r\nerr_stop:\r\nhid_hw_stop(hdev);\r\nerr:\r\ninput_free_device(wdata->ir);\r\ninput_free_device(wdata->accel);\r\nkfree(wdata);\r\nreturn ret;\r\n}\r\nstatic void wiimote_hid_remove(struct hid_device *hdev)\r\n{\r\nstruct wiimote_data *wdata = hid_get_drvdata(hdev);\r\nhid_info(hdev, "Device removed\n");\r\nwiimote_destroy(wdata);\r\n}
