static struct net_device * __init ipddp_init(void)\r\n{\r\nstatic unsigned version_printed;\r\nstruct net_device *dev;\r\nint err;\r\ndev = alloc_etherdev(0);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nnetif_keep_dst(dev);\r\nstrcpy(dev->name, "ipddp%d");\r\nif (version_printed++ == 0)\r\nprintk(version);\r\ndev->netdev_ops = &ipddp_netdev_ops;\r\ndev->type = ARPHRD_IPDDP;\r\ndev->mtu = 585;\r\ndev->flags |= IFF_NOARP;\r\ndev->hard_header_len = 14+8+sizeof(struct ddpehdr)+1;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nif(ipddp_mode == IPDDP_ENCAP)\r\nprintk("%s: Appletalk-IP Encap. mode by Bradford W. Johnson <johns393@maroon.tc.umn.edu>\n",\r\ndev->name);\r\nif(ipddp_mode == IPDDP_DECAP)\r\nprintk("%s: Appletalk-IP Decap. mode by Jay Schulist <jschlst@samba.org>\n",\r\ndev->name);\r\nreturn dev;\r\n}\r\nstatic netdev_tx_t ipddp_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\n__be32 paddr = skb_rtable(skb)->rt_gateway;\r\nstruct ddpehdr *ddp;\r\nstruct ipddp_route *rt;\r\nstruct atalk_addr *our_addr;\r\nspin_lock(&ipddp_route_lock);\r\nfor(rt = ipddp_route_list; rt != NULL; rt = rt->next)\r\n{\r\nif(rt->ip == paddr)\r\nbreak;\r\n}\r\nif(rt == NULL) {\r\nspin_unlock(&ipddp_route_lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nour_addr = atalk_find_dev_addr(rt->dev);\r\nif(ipddp_mode == IPDDP_DECAP)\r\nskb_pull(skb, 35-(sizeof(struct ddpehdr)+1));\r\nddp = (struct ddpehdr *)skb->data;\r\nddp->deh_len_hops = htons(skb->len + (1<<10));\r\nddp->deh_sum = 0;\r\nif(rt->dev->type == ARPHRD_LOCALTLK)\r\n{\r\nddp->deh_dnet = 0;\r\nddp->deh_snet = 0;\r\n}\r\nelse\r\n{\r\nddp->deh_dnet = rt->at.s_net;\r\nddp->deh_snet = our_addr->s_net;\r\n}\r\nddp->deh_dnode = rt->at.s_node;\r\nddp->deh_snode = our_addr->s_node;\r\nddp->deh_dport = 72;\r\nddp->deh_sport = 72;\r\n*((__u8 *)(ddp+1)) = 22;\r\nskb->protocol = htons(ETH_P_ATALK);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\naarp_send_ddp(rt->dev, skb, &rt->at, NULL);\r\nspin_unlock(&ipddp_route_lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ipddp_create(struct ipddp_route *new_rt)\r\n{\r\nstruct ipddp_route *rt = kmalloc(sizeof(*rt), GFP_KERNEL);\r\nif (rt == NULL)\r\nreturn -ENOMEM;\r\nrt->ip = new_rt->ip;\r\nrt->at = new_rt->at;\r\nrt->next = NULL;\r\nif ((rt->dev = atrtr_get_dev(&rt->at)) == NULL) {\r\nkfree(rt);\r\nreturn -ENETUNREACH;\r\n}\r\nspin_lock_bh(&ipddp_route_lock);\r\nif (__ipddp_find_route(rt)) {\r\nspin_unlock_bh(&ipddp_route_lock);\r\nkfree(rt);\r\nreturn -EEXIST;\r\n}\r\nrt->next = ipddp_route_list;\r\nipddp_route_list = rt;\r\nspin_unlock_bh(&ipddp_route_lock);\r\nreturn 0;\r\n}\r\nstatic int ipddp_delete(struct ipddp_route *rt)\r\n{\r\nstruct ipddp_route **r = &ipddp_route_list;\r\nstruct ipddp_route *tmp;\r\nspin_lock_bh(&ipddp_route_lock);\r\nwhile((tmp = *r) != NULL)\r\n{\r\nif(tmp->ip == rt->ip &&\r\ntmp->at.s_net == rt->at.s_net &&\r\ntmp->at.s_node == rt->at.s_node)\r\n{\r\n*r = tmp->next;\r\nspin_unlock_bh(&ipddp_route_lock);\r\nkfree(tmp);\r\nreturn 0;\r\n}\r\nr = &tmp->next;\r\n}\r\nspin_unlock_bh(&ipddp_route_lock);\r\nreturn -ENOENT;\r\n}\r\nstatic struct ipddp_route* __ipddp_find_route(struct ipddp_route *rt)\r\n{\r\nstruct ipddp_route *f;\r\nfor(f = ipddp_route_list; f != NULL; f = f->next)\r\n{\r\nif(f->ip == rt->ip &&\r\nf->at.s_net == rt->at.s_net &&\r\nf->at.s_node == rt->at.s_node)\r\nreturn f;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct ipddp_route __user *rt = ifr->ifr_data;\r\nstruct ipddp_route rcp, rcp2, *rp;\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif(copy_from_user(&rcp, rt, sizeof(rcp)))\r\nreturn -EFAULT;\r\nswitch(cmd)\r\n{\r\ncase SIOCADDIPDDPRT:\r\nreturn ipddp_create(&rcp);\r\ncase SIOCFINDIPDDPRT:\r\nspin_lock_bh(&ipddp_route_lock);\r\nrp = __ipddp_find_route(&rcp);\r\nif (rp)\r\nmemcpy(&rcp2, rp, sizeof(rcp2));\r\nspin_unlock_bh(&ipddp_route_lock);\r\nif (rp) {\r\nif (copy_to_user(rt, &rcp2,\r\nsizeof(struct ipddp_route)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n} else\r\nreturn -ENOENT;\r\ncase SIOCDELIPDDPRT:\r\nreturn ipddp_delete(&rcp);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int __init ipddp_init_module(void)\r\n{\r\ndev_ipddp = ipddp_init();\r\nif (IS_ERR(dev_ipddp))\r\nreturn PTR_ERR(dev_ipddp);\r\nreturn 0;\r\n}\r\nstatic void __exit ipddp_cleanup_module(void)\r\n{\r\nstruct ipddp_route *p;\r\nunregister_netdev(dev_ipddp);\r\nfree_netdev(dev_ipddp);\r\nwhile (ipddp_route_list) {\r\np = ipddp_route_list->next;\r\nkfree(ipddp_route_list);\r\nipddp_route_list = p;\r\n}\r\n}
