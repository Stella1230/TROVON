static void port_write_data(struct parport *p, unsigned char d)\r\n{\r\nparport_write_data(p, d);\r\n}\r\nstatic void port_write_control(struct parport *p, unsigned char d)\r\n{\r\nparport_write_control(p, d);\r\n}\r\nstatic unsigned char port_read_data(struct parport *p)\r\n{\r\nreturn parport_read_data(p);\r\n}\r\nstatic unsigned char port_read_status(struct parport *p)\r\n{\r\nreturn parport_read_status(p);\r\n}\r\nstatic unsigned char port_read_control(struct parport *p)\r\n{\r\nreturn parport_read_control(p);\r\n}\r\nstatic inline void line_set(struct parport *data, int state,\r\nconst struct lineop *op)\r\n{\r\nu8 oldval = port_read[op->port](data);\r\nif ((op->inverted && !state) || (!op->inverted && state))\r\nport_write[op->port](data, oldval | op->val);\r\nelse\r\nport_write[op->port](data, oldval & ~op->val);\r\n}\r\nstatic inline int line_get(struct parport *data,\r\nconst struct lineop *op)\r\n{\r\nu8 oldval = port_read[op->port](data);\r\nreturn ((op->inverted && (oldval & op->val) != op->val)\r\n|| (!op->inverted && (oldval & op->val) == op->val));\r\n}\r\nstatic void parport_setscl(void *data, int state)\r\n{\r\nline_set((struct parport *) data, state, &adapter_parm[type].setscl);\r\n}\r\nstatic void parport_setsda(void *data, int state)\r\n{\r\nline_set((struct parport *) data, state, &adapter_parm[type].setsda);\r\n}\r\nstatic int parport_getscl(void *data)\r\n{\r\nreturn line_get((struct parport *) data, &adapter_parm[type].getscl);\r\n}\r\nstatic int parport_getsda(void *data)\r\n{\r\nreturn line_get((struct parport *) data, &adapter_parm[type].getsda);\r\n}\r\nstatic void i2c_parport_irq(void *data)\r\n{\r\nstruct i2c_par *adapter = data;\r\nstruct i2c_client *ara = adapter->ara;\r\nif (ara) {\r\ndev_dbg(&ara->dev, "SMBus alert received\n");\r\ni2c_handle_smbus_alert(ara);\r\n} else\r\ndev_dbg(&adapter->adapter.dev,\r\n"SMBus alert received but no ARA client!\n");\r\n}\r\nstatic void i2c_parport_attach(struct parport *port)\r\n{\r\nstruct i2c_par *adapter;\r\nint i;\r\nstruct pardev_cb i2c_parport_cb;\r\nfor (i = 0; i < MAX_DEVICE; i++) {\r\nif (parport[i] == -1)\r\ncontinue;\r\nif (port->number == parport[i])\r\nbreak;\r\n}\r\nif (i == MAX_DEVICE) {\r\npr_debug("Not using parport%d.\n", port->number);\r\nreturn;\r\n}\r\nadapter = kzalloc(sizeof(struct i2c_par), GFP_KERNEL);\r\nif (!adapter)\r\nreturn;\r\nmemset(&i2c_parport_cb, 0, sizeof(i2c_parport_cb));\r\ni2c_parport_cb.flags = PARPORT_FLAG_EXCL;\r\ni2c_parport_cb.irq_func = i2c_parport_irq;\r\ni2c_parport_cb.private = adapter;\r\npr_debug("attaching to %s\n", port->name);\r\nparport_disable_irq(port);\r\nadapter->pdev = parport_register_dev_model(port, "i2c-parport",\r\n&i2c_parport_cb, i);\r\nif (!adapter->pdev) {\r\npr_err("Unable to register with parport\n");\r\ngoto err_free;\r\n}\r\nadapter->adapter.owner = THIS_MODULE;\r\nadapter->adapter.class = I2C_CLASS_HWMON;\r\nstrlcpy(adapter->adapter.name, "Parallel port adapter",\r\nsizeof(adapter->adapter.name));\r\nadapter->algo_data = parport_algo_data;\r\nif (!adapter_parm[type].getscl.val) {\r\nadapter->algo_data.getscl = NULL;\r\nadapter->algo_data.udelay = 50;\r\n}\r\nadapter->algo_data.data = port;\r\nadapter->adapter.algo_data = &adapter->algo_data;\r\nadapter->adapter.dev.parent = port->physport->dev;\r\nif (parport_claim_or_block(adapter->pdev) < 0) {\r\ndev_err(&adapter->pdev->dev,\r\n"Could not claim parallel port\n");\r\ngoto err_unregister;\r\n}\r\nparport_setsda(port, 1);\r\nparport_setscl(port, 1);\r\nif (adapter_parm[type].init.val) {\r\nline_set(port, 1, &adapter_parm[type].init);\r\nmsleep(100);\r\n}\r\nif (i2c_bit_add_bus(&adapter->adapter) < 0) {\r\ndev_err(&adapter->pdev->dev, "Unable to register with I2C\n");\r\ngoto err_unregister;\r\n}\r\nif (adapter_parm[type].smbus_alert) {\r\nadapter->alert_data.alert_edge_triggered = 1;\r\nadapter->ara = i2c_setup_smbus_alert(&adapter->adapter,\r\n&adapter->alert_data);\r\nif (adapter->ara)\r\nparport_enable_irq(port);\r\nelse\r\ndev_warn(&adapter->pdev->dev,\r\n"Failed to register ARA client\n");\r\n}\r\nmutex_lock(&adapter_list_lock);\r\nlist_add_tail(&adapter->node, &adapter_list);\r\nmutex_unlock(&adapter_list_lock);\r\nreturn;\r\nerr_unregister:\r\nparport_release(adapter->pdev);\r\nparport_unregister_device(adapter->pdev);\r\nerr_free:\r\nkfree(adapter);\r\n}\r\nstatic void i2c_parport_detach(struct parport *port)\r\n{\r\nstruct i2c_par *adapter, *_n;\r\nmutex_lock(&adapter_list_lock);\r\nlist_for_each_entry_safe(adapter, _n, &adapter_list, node) {\r\nif (adapter->pdev->port == port) {\r\nif (adapter->ara) {\r\nparport_disable_irq(port);\r\ni2c_unregister_device(adapter->ara);\r\n}\r\ni2c_del_adapter(&adapter->adapter);\r\nif (adapter_parm[type].init.val)\r\nline_set(port, 0, &adapter_parm[type].init);\r\nparport_release(adapter->pdev);\r\nparport_unregister_device(adapter->pdev);\r\nlist_del(&adapter->node);\r\nkfree(adapter);\r\n}\r\n}\r\nmutex_unlock(&adapter_list_lock);\r\n}\r\nstatic int __init i2c_parport_init(void)\r\n{\r\nif (type < 0) {\r\npr_warn("adapter type unspecified\n");\r\nreturn -ENODEV;\r\n}\r\nif (type >= ARRAY_SIZE(adapter_parm)) {\r\npr_warn("invalid type (%d)\n", type);\r\nreturn -ENODEV;\r\n}\r\nreturn parport_register_driver(&i2c_parport_driver);\r\n}\r\nstatic void __exit i2c_parport_exit(void)\r\n{\r\nparport_unregister_driver(&i2c_parport_driver);\r\n}
