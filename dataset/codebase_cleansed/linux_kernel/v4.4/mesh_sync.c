static bool mesh_peer_tbtt_adjusting(struct ieee802_11_elems *ie)\r\n{\r\nreturn (ie->mesh_config->meshconf_cap &\r\nIEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING) != 0;\r\n}\r\nvoid mesh_sync_adjust_tbtt(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu64 beacon_int_fraction = sdata->vif.bss_conf.beacon_int * 1024 / 2500;\r\nu64 tsf;\r\nu64 tsfdelta;\r\nspin_lock_bh(&ifmsh->sync_offset_lock);\r\nif (ifmsh->sync_offset_clockdrift_max < beacon_int_fraction) {\r\nmsync_dbg(sdata, "TBTT : max clockdrift=%lld; adjusting\n",\r\n(long long) ifmsh->sync_offset_clockdrift_max);\r\ntsfdelta = -ifmsh->sync_offset_clockdrift_max;\r\nifmsh->sync_offset_clockdrift_max = 0;\r\n} else {\r\nmsync_dbg(sdata, "TBTT : max clockdrift=%lld; adjusting by %llu\n",\r\n(long long) ifmsh->sync_offset_clockdrift_max,\r\n(unsigned long long) beacon_int_fraction);\r\ntsfdelta = -beacon_int_fraction;\r\nifmsh->sync_offset_clockdrift_max -= beacon_int_fraction;\r\n}\r\nspin_unlock_bh(&ifmsh->sync_offset_lock);\r\ntsf = drv_get_tsf(local, sdata);\r\nif (tsf != -1ULL)\r\ndrv_set_tsf(local, sdata, tsf + tsfdelta);\r\n}\r\nstatic void mesh_sync_offset_rx_bcn_presp(struct ieee80211_sub_if_data *sdata,\r\nu16 stype,\r\nstruct ieee80211_mgmt *mgmt,\r\nstruct ieee802_11_elems *elems,\r\nstruct ieee80211_rx_status *rx_status)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nu64 t_t, t_r;\r\nWARN_ON(ifmsh->mesh_sp_id != IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET);\r\nif (stype != IEEE80211_STYPE_BEACON)\r\nreturn;\r\nif (ieee80211_have_rx_timestamp(rx_status))\r\nt_r = ieee80211_calculate_rx_timestamp(local, rx_status,\r\n24 + 12 +\r\nelems->total_len +\r\nFCS_LEN,\r\n24);\r\nelse\r\nt_r = drv_get_tsf(local, sdata);\r\nrcu_read_lock();\r\nsta = sta_info_get(sdata, mgmt->sa);\r\nif (!sta)\r\ngoto no_sync;\r\nif (elems->mesh_config && mesh_peer_tbtt_adjusting(elems)) {\r\nclear_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN);\r\nmsync_dbg(sdata, "STA %pM : is adjusting TBTT\n",\r\nsta->sta.addr);\r\ngoto no_sync;\r\n}\r\nt_t = le64_to_cpu(mgmt->u.beacon.timestamp);\r\nsta->mesh->t_offset = t_t - t_r;\r\nif (test_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN)) {\r\ns64 t_clockdrift = sta->mesh->t_offset_setpoint - sta->mesh->t_offset;\r\nmsync_dbg(sdata,\r\n"STA %pM : t_offset=%lld, t_offset_setpoint=%lld, t_clockdrift=%lld\n",\r\nsta->sta.addr, (long long) sta->mesh->t_offset,\r\n(long long) sta->mesh->t_offset_setpoint,\r\n(long long) t_clockdrift);\r\nif (t_clockdrift > TOFFSET_MAXIMUM_ADJUSTMENT ||\r\nt_clockdrift < -TOFFSET_MAXIMUM_ADJUSTMENT) {\r\nmsync_dbg(sdata,\r\n"STA %pM : t_clockdrift=%lld too large, setpoint reset\n",\r\nsta->sta.addr,\r\n(long long) t_clockdrift);\r\nclear_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN);\r\ngoto no_sync;\r\n}\r\nspin_lock_bh(&ifmsh->sync_offset_lock);\r\nif (t_clockdrift > ifmsh->sync_offset_clockdrift_max)\r\nifmsh->sync_offset_clockdrift_max = t_clockdrift;\r\nspin_unlock_bh(&ifmsh->sync_offset_lock);\r\n} else {\r\nsta->mesh->t_offset_setpoint = sta->mesh->t_offset - TOFFSET_SET_MARGIN;\r\nset_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN);\r\nmsync_dbg(sdata,\r\n"STA %pM : offset was invalid, t_offset=%lld\n",\r\nsta->sta.addr,\r\n(long long) sta->mesh->t_offset);\r\n}\r\nno_sync:\r\nrcu_read_unlock();\r\n}\r\nstatic void mesh_sync_offset_adjust_tbtt(struct ieee80211_sub_if_data *sdata,\r\nstruct beacon_data *beacon)\r\n{\r\nstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\r\nu8 cap;\r\nWARN_ON(ifmsh->mesh_sp_id != IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET);\r\nWARN_ON(!rcu_read_lock_held());\r\ncap = beacon->meshconf->meshconf_cap;\r\nspin_lock_bh(&ifmsh->sync_offset_lock);\r\nif (ifmsh->sync_offset_clockdrift_max > TOFFSET_MINIMUM_ADJUSTMENT) {\r\nmsync_dbg(sdata,\r\n"TBTT : kicking off TBTT adjustment with clockdrift_max=%lld\n",\r\nifmsh->sync_offset_clockdrift_max);\r\nset_bit(MESH_WORK_DRIFT_ADJUST, &ifmsh->wrkq_flags);\r\nifmsh->adjusting_tbtt = true;\r\n} else {\r\nmsync_dbg(sdata,\r\n"TBTT : max clockdrift=%lld; too small to adjust\n",\r\n(long long)ifmsh->sync_offset_clockdrift_max);\r\nifmsh->sync_offset_clockdrift_max = 0;\r\nifmsh->adjusting_tbtt = false;\r\n}\r\nspin_unlock_bh(&ifmsh->sync_offset_lock);\r\nbeacon->meshconf->meshconf_cap = ifmsh->adjusting_tbtt ?\r\nIEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING | cap :\r\n~IEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING & cap;\r\n}\r\nconst struct ieee80211_mesh_sync_ops *ieee80211_mesh_sync_ops_get(u8 method)\r\n{\r\nint i;\r\nfor (i = 0 ; i < ARRAY_SIZE(sync_methods); ++i) {\r\nif (sync_methods[i].method == method)\r\nreturn &sync_methods[i].ops;\r\n}\r\nreturn NULL;\r\n}
