static void vx_write_codec_reg(struct vx_core *chip, int codec, unsigned int data)\r\n{\r\nif (snd_BUG_ON(!chip->ops->write_codec))\r\nreturn;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn;\r\nmutex_lock(&chip->lock);\r\nchip->ops->write_codec(chip, codec, data);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic void vx_set_codec_reg(struct vx_core *chip, int codec, int reg, int val)\r\n{\r\nunion vx_codec_data data;\r\nSET_CDC_DATA_INIT(data);\r\nSET_CDC_DATA_REG(data, reg);\r\nSET_CDC_DATA_VAL(data, val);\r\nvx_write_codec_reg(chip, codec, data.l);\r\n}\r\nstatic void vx_set_analog_output_level(struct vx_core *chip, int codec, int left, int right)\r\n{\r\nleft = chip->hw->output_level_max - left;\r\nright = chip->hw->output_level_max - right;\r\nif (chip->ops->akm_write) {\r\nchip->ops->akm_write(chip, XX_CODEC_LEVEL_LEFT_REGISTER, left);\r\nchip->ops->akm_write(chip, XX_CODEC_LEVEL_RIGHT_REGISTER, right);\r\n} else {\r\nvx_set_codec_reg(chip, codec, XX_CODEC_LEVEL_LEFT_REGISTER, left);\r\nvx_set_codec_reg(chip, codec, XX_CODEC_LEVEL_RIGHT_REGISTER, right);\r\n}\r\n}\r\nvoid vx_toggle_dac_mute(struct vx_core *chip, int mute)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < chip->hw->num_codecs; i++) {\r\nif (chip->ops->akm_write)\r\nchip->ops->akm_write(chip, XX_CODEC_DAC_CONTROL_REGISTER, mute);\r\nelse\r\nvx_set_codec_reg(chip, i, XX_CODEC_DAC_CONTROL_REGISTER,\r\nmute ? DAC_ATTEN_MAX : DAC_ATTEN_MIN);\r\n}\r\n}\r\nvoid vx_reset_codec(struct vx_core *chip, int cold_reset)\r\n{\r\nunsigned int i;\r\nint port = chip->type >= VX_TYPE_VXPOCKET ? 0x75 : 0x65;\r\nchip->ops->reset_codec(chip);\r\nif (! chip->ops->akm_write) {\r\nfor (i = 0; i < chip->hw->num_codecs; i++) {\r\nvx_set_codec_reg(chip, i, XX_CODEC_DAC_CONTROL_REGISTER, DAC_ATTEN_MAX);\r\nvx_set_codec_reg(chip, i, XX_CODEC_ADC_CONTROL_REGISTER, 0x00);\r\nvx_set_codec_reg(chip, i, XX_CODEC_PORT_MODE_REGISTER, port);\r\nvx_set_codec_reg(chip, i, XX_CODEC_CLOCK_CONTROL_REGISTER, 0x00);\r\n}\r\n}\r\nfor (i = 0; i < chip->hw->num_codecs; i++) {\r\nchip->output_level[i][0] = 0;\r\nchip->output_level[i][1] = 0;\r\nvx_set_analog_output_level(chip, i, 0, 0);\r\n}\r\n}\r\nstatic void vx_change_audio_source(struct vx_core *chip, int src)\r\n{\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn;\r\nmutex_lock(&chip->lock);\r\nchip->ops->change_audio_source(chip, src);\r\nmutex_unlock(&chip->lock);\r\n}\r\nint vx_sync_audio_source(struct vx_core *chip)\r\n{\r\nif (chip->audio_source_target == chip->audio_source ||\r\nchip->pcm_running)\r\nreturn 0;\r\nvx_change_audio_source(chip, chip->audio_source_target);\r\nchip->audio_source = chip->audio_source_target;\r\nreturn 1;\r\n}\r\nstatic int vx_adjust_audio_level(struct vx_core *chip, int audio, int capture,\r\nstruct vx_audio_level *info)\r\n{\r\nstruct vx_rmh rmh;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn -EBUSY;\r\nvx_init_rmh(&rmh, CMD_AUDIO_LEVEL_ADJUST);\r\nif (capture)\r\nrmh.Cmd[0] |= COMMAND_RECORD_MASK;\r\nrmh.Cmd[1] = 1 << audio;\r\nrmh.Cmd[2] = 0;\r\nif (info->has_level) {\r\nrmh.Cmd[0] |= VALID_AUDIO_IO_DIGITAL_LEVEL;\r\nrmh.Cmd[2] |= info->level;\r\n}\r\nif (info->has_monitor_level) {\r\nrmh.Cmd[0] |= VALID_AUDIO_IO_MONITORING_LEVEL;\r\nrmh.Cmd[2] |= ((unsigned int)info->monitor_level << 10);\r\n}\r\nif (info->has_mute) {\r\nrmh.Cmd[0] |= VALID_AUDIO_IO_MUTE_LEVEL;\r\nif (info->mute)\r\nrmh.Cmd[2] |= AUDIO_IO_HAS_MUTE_LEVEL;\r\n}\r\nif (info->has_monitor_mute) {\r\nrmh.Cmd[0] |= VALID_AUDIO_IO_MUTE_MONITORING_1 | VALID_AUDIO_IO_MUTE_MONITORING_2;\r\nif (info->monitor_mute)\r\nrmh.Cmd[2] |= AUDIO_IO_HAS_MUTE_MONITORING_1;\r\n}\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nint vx_set_monitor_level(struct vx_core *chip, int audio, int level, int active)\r\n{\r\nstruct vx_audio_level info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.has_monitor_level = 1;\r\ninfo.monitor_level = level;\r\ninfo.has_monitor_mute = 1;\r\ninfo.monitor_mute = !active;\r\nchip->audio_monitor[audio] = level;\r\nchip->audio_monitor_active[audio] = active;\r\nreturn vx_adjust_audio_level(chip, audio, 0, &info);\r\n}\r\nstatic int vx_set_audio_switch(struct vx_core *chip, int audio, int active)\r\n{\r\nstruct vx_audio_level info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.has_mute = 1;\r\ninfo.mute = !active;\r\nchip->audio_active[audio] = active;\r\nreturn vx_adjust_audio_level(chip, audio, 0, &info);\r\n}\r\nstatic int vx_set_audio_gain(struct vx_core *chip, int audio, int capture, int level)\r\n{\r\nstruct vx_audio_level info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.has_level = 1;\r\ninfo.level = level;\r\nchip->audio_gain[capture][audio] = level;\r\nreturn vx_adjust_audio_level(chip, audio, capture, &info);\r\n}\r\nstatic void vx_reset_audio_levels(struct vx_core *chip)\r\n{\r\nunsigned int i, c;\r\nstruct vx_audio_level info;\r\nmemset(chip->audio_gain, 0, sizeof(chip->audio_gain));\r\nmemset(chip->audio_active, 0, sizeof(chip->audio_active));\r\nmemset(chip->audio_monitor, 0, sizeof(chip->audio_monitor));\r\nmemset(chip->audio_monitor_active, 0, sizeof(chip->audio_monitor_active));\r\nfor (c = 0; c < 2; c++) {\r\nfor (i = 0; i < chip->hw->num_ins * 2; i++) {\r\nmemset(&info, 0, sizeof(info));\r\nif (c == 0) {\r\ninfo.has_monitor_level = 1;\r\ninfo.has_mute = 1;\r\ninfo.has_monitor_mute = 1;\r\n}\r\ninfo.has_level = 1;\r\ninfo.level = CVAL_0DB;\r\nvx_adjust_audio_level(chip, i, c, &info);\r\nchip->audio_gain[c][i] = CVAL_0DB;\r\nchip->audio_monitor[i] = CVAL_0DB;\r\n}\r\n}\r\n}\r\nstatic int vx_get_audio_vu_meter(struct vx_core *chip, int audio, int capture, struct vx_vu_meter *info)\r\n{\r\nstruct vx_rmh rmh;\r\nint i, err;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn -EBUSY;\r\nvx_init_rmh(&rmh, CMD_AUDIO_VU_PIC_METER);\r\nrmh.LgStat += 2 * VU_METER_CHANNELS;\r\nif (capture)\r\nrmh.Cmd[0] |= COMMAND_RECORD_MASK;\r\nrmh.Cmd[1] = 0;\r\nfor (i = 0; i < VU_METER_CHANNELS; i++)\r\nrmh.Cmd[1] |= 1 << (audio + i);\r\nerr = vx_send_msg(chip, &rmh);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < 2 * VU_METER_CHANNELS; i +=2) {\r\ninfo->saturated = (rmh.Stat[0] & (1 << (audio + i))) ? 1 : 0;\r\ninfo->vu_level = rmh.Stat[i + 1];\r\ninfo->peak_level = rmh.Stat[i + 2];\r\ninfo++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vx_output_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = chip->hw->output_level_max;\r\nreturn 0;\r\n}\r\nstatic int vx_output_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint codec = kcontrol->id.index;\r\nmutex_lock(&chip->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->output_level[codec][0];\r\nucontrol->value.integer.value[1] = chip->output_level[codec][1];\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_output_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint codec = kcontrol->id.index;\r\nunsigned int val[2], vmax;\r\nvmax = chip->hw->output_level_max;\r\nval[0] = ucontrol->value.integer.value[0];\r\nval[1] = ucontrol->value.integer.value[1];\r\nif (val[0] > vmax || val[1] > vmax)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mixer_mutex);\r\nif (val[0] != chip->output_level[codec][0] ||\r\nval[1] != chip->output_level[codec][1]) {\r\nvx_set_analog_output_level(chip, codec, val[0], val[1]);\r\nchip->output_level[codec][0] = val[0];\r\nchip->output_level[codec][1] = val[1];\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_audio_src_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts_mic[3] = {\r\n"Digital", "Line", "Mic"\r\n};\r\nstatic const char * const texts_vx2[2] = {\r\n"Digital", "Analog"\r\n};\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nif (chip->type >= VX_TYPE_VXPOCKET)\r\nreturn snd_ctl_enum_info(uinfo, 1, 3, texts_mic);\r\nelse\r\nreturn snd_ctl_enum_info(uinfo, 1, 2, texts_vx2);\r\n}\r\nstatic int vx_audio_src_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = chip->audio_source_target;\r\nreturn 0;\r\n}\r\nstatic int vx_audio_src_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nif (chip->type >= VX_TYPE_VXPOCKET) {\r\nif (ucontrol->value.enumerated.item[0] > 2)\r\nreturn -EINVAL;\r\n} else {\r\nif (ucontrol->value.enumerated.item[0] > 1)\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&chip->mixer_mutex);\r\nif (chip->audio_source_target != ucontrol->value.enumerated.item[0]) {\r\nchip->audio_source_target = ucontrol->value.enumerated.item[0];\r\nvx_sync_audio_source(chip);\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_clock_mode_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[3] = {\r\n"Auto", "Internal", "External"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, 3, texts);\r\n}\r\nstatic int vx_clock_mode_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = chip->clock_mode;\r\nreturn 0;\r\n}\r\nstatic int vx_clock_mode_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.enumerated.item[0] > 2)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mixer_mutex);\r\nif (chip->clock_mode != ucontrol->value.enumerated.item[0]) {\r\nchip->clock_mode = ucontrol->value.enumerated.item[0];\r\nvx_set_clock(chip, chip->freq);\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_audio_gain_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = CVAL_MAX;\r\nreturn 0;\r\n}\r\nstatic int vx_audio_gain_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint audio = kcontrol->private_value & 0xff;\r\nint capture = (kcontrol->private_value >> 8) & 1;\r\nmutex_lock(&chip->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->audio_gain[capture][audio];\r\nucontrol->value.integer.value[1] = chip->audio_gain[capture][audio+1];\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_audio_gain_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint audio = kcontrol->private_value & 0xff;\r\nint capture = (kcontrol->private_value >> 8) & 1;\r\nunsigned int val[2];\r\nval[0] = ucontrol->value.integer.value[0];\r\nval[1] = ucontrol->value.integer.value[1];\r\nif (val[0] > CVAL_MAX || val[1] > CVAL_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mixer_mutex);\r\nif (val[0] != chip->audio_gain[capture][audio] ||\r\nval[1] != chip->audio_gain[capture][audio+1]) {\r\nvx_set_audio_gain(chip, audio, capture, val[0]);\r\nvx_set_audio_gain(chip, audio+1, capture, val[1]);\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_audio_monitor_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint audio = kcontrol->private_value & 0xff;\r\nmutex_lock(&chip->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->audio_monitor[audio];\r\nucontrol->value.integer.value[1] = chip->audio_monitor[audio+1];\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_audio_monitor_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint audio = kcontrol->private_value & 0xff;\r\nunsigned int val[2];\r\nval[0] = ucontrol->value.integer.value[0];\r\nval[1] = ucontrol->value.integer.value[1];\r\nif (val[0] > CVAL_MAX || val[1] > CVAL_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mixer_mutex);\r\nif (val[0] != chip->audio_monitor[audio] ||\r\nval[1] != chip->audio_monitor[audio+1]) {\r\nvx_set_monitor_level(chip, audio, val[0],\r\nchip->audio_monitor_active[audio]);\r\nvx_set_monitor_level(chip, audio+1, val[1],\r\nchip->audio_monitor_active[audio+1]);\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_audio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint audio = kcontrol->private_value & 0xff;\r\nmutex_lock(&chip->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->audio_active[audio];\r\nucontrol->value.integer.value[1] = chip->audio_active[audio+1];\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_audio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint audio = kcontrol->private_value & 0xff;\r\nmutex_lock(&chip->mixer_mutex);\r\nif (ucontrol->value.integer.value[0] != chip->audio_active[audio] ||\r\nucontrol->value.integer.value[1] != chip->audio_active[audio+1]) {\r\nvx_set_audio_switch(chip, audio,\r\n!!ucontrol->value.integer.value[0]);\r\nvx_set_audio_switch(chip, audio+1,\r\n!!ucontrol->value.integer.value[1]);\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_monitor_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint audio = kcontrol->private_value & 0xff;\r\nmutex_lock(&chip->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->audio_monitor_active[audio];\r\nucontrol->value.integer.value[1] = chip->audio_monitor_active[audio+1];\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_monitor_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nint audio = kcontrol->private_value & 0xff;\r\nmutex_lock(&chip->mixer_mutex);\r\nif (ucontrol->value.integer.value[0] != chip->audio_monitor_active[audio] ||\r\nucontrol->value.integer.value[1] != chip->audio_monitor_active[audio+1]) {\r\nvx_set_monitor_level(chip, audio, chip->audio_monitor[audio],\r\n!!ucontrol->value.integer.value[0]);\r\nvx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],\r\n!!ucontrol->value.integer.value[1]);\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_iec958_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int vx_iec958_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mixer_mutex);\r\nucontrol->value.iec958.status[0] = (chip->uer_bits >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (chip->uer_bits >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (chip->uer_bits >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (chip->uer_bits >> 24) & 0xff;\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_iec958_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int vx_iec958_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nval = (ucontrol->value.iec958.status[0] << 0) |\r\n(ucontrol->value.iec958.status[1] << 8) |\r\n(ucontrol->value.iec958.status[2] << 16) |\r\n(ucontrol->value.iec958.status[3] << 24);\r\nmutex_lock(&chip->mixer_mutex);\r\nif (chip->uer_bits != val) {\r\nchip->uer_bits = val;\r\nvx_set_iec958_status(chip, val);\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_vu_meter_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = METER_MAX;\r\nreturn 0;\r\n}\r\nstatic int vx_vu_meter_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nstruct vx_vu_meter meter[2];\r\nint audio = kcontrol->private_value & 0xff;\r\nint capture = (kcontrol->private_value >> 8) & 1;\r\nvx_get_audio_vu_meter(chip, audio, capture, meter);\r\nucontrol->value.integer.value[0] = meter[0].vu_level >> METER_SHIFT;\r\nucontrol->value.integer.value[1] = meter[1].vu_level >> METER_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int vx_peak_meter_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nstruct vx_vu_meter meter[2];\r\nint audio = kcontrol->private_value & 0xff;\r\nint capture = (kcontrol->private_value >> 8) & 1;\r\nvx_get_audio_vu_meter(chip, audio, capture, meter);\r\nucontrol->value.integer.value[0] = meter[0].peak_level >> METER_SHIFT;\r\nucontrol->value.integer.value[1] = meter[1].peak_level >> METER_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int vx_saturation_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *chip = snd_kcontrol_chip(kcontrol);\r\nstruct vx_vu_meter meter[2];\r\nint audio = kcontrol->private_value & 0xff;\r\nvx_get_audio_vu_meter(chip, audio, 1, meter);\r\nucontrol->value.integer.value[0] = meter[0].saturated;\r\nucontrol->value.integer.value[1] = meter[1].saturated;\r\nreturn 0;\r\n}\r\nint snd_vx_mixer_new(struct vx_core *chip)\r\n{\r\nunsigned int i, c;\r\nint err;\r\nstruct snd_kcontrol_new temp;\r\nstruct snd_card *card = chip->card;\r\nchar name[32];\r\nstrcpy(card->mixername, card->driver);\r\nfor (i = 0; i < chip->hw->num_outs; i++) {\r\ntemp = vx_control_output_level;\r\ntemp.index = i;\r\ntemp.tlv.p = chip->hw->output_level_db_scale;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < chip->hw->num_outs; i++) {\r\nint val = i * 2;\r\ntemp = vx_control_audio_gain;\r\ntemp.index = i;\r\ntemp.name = "PCM Playback Volume";\r\ntemp.private_value = val;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\ntemp = vx_control_output_switch;\r\ntemp.index = i;\r\ntemp.private_value = val;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\ntemp = vx_control_monitor_gain;\r\ntemp.index = i;\r\ntemp.private_value = val;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\ntemp = vx_control_monitor_switch;\r\ntemp.index = i;\r\ntemp.private_value = val;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < chip->hw->num_outs; i++) {\r\ntemp = vx_control_audio_gain;\r\ntemp.index = i;\r\ntemp.name = "PCM Capture Volume";\r\ntemp.private_value = (i * 2) | (1 << 8);\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&vx_control_audio_src, chip))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&vx_control_clock_mode, chip))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&vx_control_iec958_mask, chip))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&vx_control_iec958, chip))) < 0)\r\nreturn err;\r\nfor (c = 0; c < 2; c++) {\r\nstatic char *dir[2] = { "Output", "Input" };\r\nfor (i = 0; i < chip->hw->num_ins; i++) {\r\nint val = (i * 2) | (c << 8);\r\nif (c == 1) {\r\ntemp = vx_control_saturation;\r\ntemp.index = i;\r\ntemp.private_value = val;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\n}\r\nsprintf(name, "%s VU Meter", dir[c]);\r\ntemp = vx_control_vu_meter;\r\ntemp.index = i;\r\ntemp.name = name;\r\ntemp.private_value = val;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\nsprintf(name, "%s Peak Meter", dir[c]);\r\ntemp = vx_control_peak_meter;\r\ntemp.index = i;\r\ntemp.name = name;\r\ntemp.private_value = val;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&temp, chip))) < 0)\r\nreturn err;\r\n}\r\n}\r\nvx_reset_audio_levels(chip);\r\nreturn 0;\r\n}
