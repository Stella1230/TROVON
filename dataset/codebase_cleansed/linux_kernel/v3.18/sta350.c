static int sta350_coefficient_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint numcoef = kcontrol->private_value >> 16;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = 3 * numcoef;\r\nreturn 0;\r\n}\r\nstatic int sta350_coefficient_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nint numcoef = kcontrol->private_value >> 16;\r\nint index = kcontrol->private_value & 0xffff;\r\nunsigned int cfud, val;\r\nint i, ret = 0;\r\nmutex_lock(&sta350->coeff_lock);\r\nregmap_read(sta350->regmap, STA350_CFUD, &cfud);\r\ncfud &= 0xf0;\r\nregmap_write(sta350->regmap, STA350_CFUD, cfud);\r\nregmap_write(sta350->regmap, STA350_CFADDR2, index);\r\nif (numcoef == 1) {\r\nregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x04);\r\n} else if (numcoef == 5) {\r\nregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x08);\r\n} else {\r\nret = -EINVAL;\r\ngoto exit_unlock;\r\n}\r\nfor (i = 0; i < 3 * numcoef; i++) {\r\nregmap_read(sta350->regmap, STA350_B1CF1 + i, &val);\r\nucontrol->value.bytes.data[i] = val;\r\n}\r\nexit_unlock:\r\nmutex_unlock(&sta350->coeff_lock);\r\nreturn ret;\r\n}\r\nstatic int sta350_coefficient_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nint numcoef = kcontrol->private_value >> 16;\r\nint index = kcontrol->private_value & 0xffff;\r\nunsigned int cfud;\r\nint i;\r\nregmap_read(sta350->regmap, STA350_CFUD, &cfud);\r\ncfud &= 0xf0;\r\nregmap_write(sta350->regmap, STA350_CFUD, cfud);\r\nregmap_write(sta350->regmap, STA350_CFADDR2, index);\r\nfor (i = 0; i < numcoef && (index + i < STA350_COEF_COUNT); i++)\r\nsta350->coef_shadow[index + i] =\r\n(ucontrol->value.bytes.data[3 * i] << 16)\r\n| (ucontrol->value.bytes.data[3 * i + 1] << 8)\r\n| (ucontrol->value.bytes.data[3 * i + 2]);\r\nfor (i = 0; i < 3 * numcoef; i++)\r\nregmap_write(sta350->regmap, STA350_B1CF1 + i,\r\nucontrol->value.bytes.data[i]);\r\nif (numcoef == 1)\r\nregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x01);\r\nelse if (numcoef == 5)\r\nregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x02);\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sta350_sync_coef_shadow(struct snd_soc_codec *codec)\r\n{\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int cfud;\r\nint i;\r\nregmap_read(sta350->regmap, STA350_CFUD, &cfud);\r\ncfud &= 0xf0;\r\nfor (i = 0; i < STA350_COEF_COUNT; i++) {\r\nregmap_write(sta350->regmap, STA350_CFADDR2, i);\r\nregmap_write(sta350->regmap, STA350_B1CF1,\r\n(sta350->coef_shadow[i] >> 16) & 0xff);\r\nregmap_write(sta350->regmap, STA350_B1CF2,\r\n(sta350->coef_shadow[i] >> 8) & 0xff);\r\nregmap_write(sta350->regmap, STA350_B1CF3,\r\n(sta350->coef_shadow[i]) & 0xff);\r\nregmap_write(sta350->regmap, STA350_CFUD, cfud);\r\nregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x01);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sta350_cache_sync(struct snd_soc_codec *codec)\r\n{\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int mute;\r\nint rc;\r\nregmap_read(sta350->regmap, STA350_CFUD, &mute);\r\nregmap_write(sta350->regmap, STA350_MMUTE, mute | STA350_MMUTE_MMUTE);\r\nsta350_sync_coef_shadow(codec);\r\nrc = regcache_sync(sta350->regmap);\r\nregmap_write(sta350->regmap, STA350_MMUTE, mute);\r\nreturn rc;\r\n}\r\nstatic int sta350_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "mclk=%u\n", freq);\r\nsta350->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int sta350_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int confb = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nsta350->format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nconfb |= STA350_CONFB_C2IM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nconfb |= STA350_CONFB_C1IM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(sta350->regmap, STA350_CONFB,\r\nSTA350_CONFB_C1IM | STA350_CONFB_C2IM, confb);\r\n}\r\nstatic int sta350_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nint i, mcs = -EINVAL, ir = -EINVAL;\r\nunsigned int confa, confb;\r\nunsigned int rate, ratio;\r\nint ret;\r\nif (!sta350->mclk) {\r\ndev_err(codec->dev,\r\n"sta350->mclk is unset. Unable to determine ratio\n");\r\nreturn -EIO;\r\n}\r\nrate = params_rate(params);\r\nratio = sta350->mclk / rate;\r\ndev_dbg(codec->dev, "rate: %u, ratio: %u\n", rate, ratio);\r\nfor (i = 0; i < ARRAY_SIZE(interpolation_ratios); i++) {\r\nif (interpolation_ratios[i].fs == rate) {\r\nir = interpolation_ratios[i].ir;\r\nbreak;\r\n}\r\n}\r\nif (ir < 0) {\r\ndev_err(codec->dev, "Unsupported samplerate: %u\n", rate);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nif (mcs_ratio_table[ir][i] == ratio) {\r\nmcs = i;\r\nbreak;\r\n}\r\n}\r\nif (mcs < 0) {\r\ndev_err(codec->dev, "Unresolvable ratio: %u\n", ratio);\r\nreturn -EINVAL;\r\n}\r\nconfa = (ir << STA350_CONFA_IR_SHIFT) |\r\n(mcs << STA350_CONFA_MCS_SHIFT);\r\nconfb = 0;\r\nswitch (params_width(params)) {\r\ncase 24:\r\ndev_dbg(codec->dev, "24bit\n");\r\ncase 32:\r\ndev_dbg(codec->dev, "24bit or 32bit\n");\r\nswitch (sta350->format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nconfb |= 0x0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nconfb |= 0x1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nconfb |= 0x2;\r\nbreak;\r\n}\r\nbreak;\r\ncase 20:\r\ndev_dbg(codec->dev, "20bit\n");\r\nswitch (sta350->format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nconfb |= 0x4;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nconfb |= 0x5;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nconfb |= 0x6;\r\nbreak;\r\n}\r\nbreak;\r\ncase 18:\r\ndev_dbg(codec->dev, "18bit\n");\r\nswitch (sta350->format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nconfb |= 0x8;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nconfb |= 0x9;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nconfb |= 0xa;\r\nbreak;\r\n}\r\nbreak;\r\ncase 16:\r\ndev_dbg(codec->dev, "16bit\n");\r\nswitch (sta350->format) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nconfb |= 0x0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nconfb |= 0xd;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nconfb |= 0xe;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(sta350->regmap, STA350_CONFA,\r\nSTA350_CONFA_MCS_MASK | STA350_CONFA_IR_MASK,\r\nconfa);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_update_bits(sta350->regmap, STA350_CONFB,\r\nSTA350_CONFB_SAI_MASK | STA350_CONFB_SAIFB,\r\nconfb);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int sta350_startup_sequence(struct sta350_priv *sta350)\r\n{\r\nif (sta350->gpiod_power_down)\r\ngpiod_set_value(sta350->gpiod_power_down, 1);\r\nif (sta350->gpiod_nreset) {\r\ngpiod_set_value(sta350->gpiod_nreset, 0);\r\nmdelay(1);\r\ngpiod_set_value(sta350->gpiod_nreset, 1);\r\nmdelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sta350_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ndev_dbg(codec->dev, "level = %d\n", level);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nregmap_update_bits(sta350->regmap, STA350_CONFF,\r\nSTA350_CONFF_PWDN | STA350_CONFF_EAPD,\r\nSTA350_CONFF_PWDN | STA350_CONFF_EAPD);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(\r\nARRAY_SIZE(sta350->supplies),\r\nsta350->supplies);\r\nif (ret < 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nsta350_startup_sequence(sta350);\r\nsta350_cache_sync(codec);\r\n}\r\nregmap_update_bits(sta350->regmap, STA350_CONFF,\r\nSTA350_CONFF_PWDN | STA350_CONFF_EAPD,\r\n0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_update_bits(sta350->regmap, STA350_CONFF,\r\nSTA350_CONFF_PWDN | STA350_CONFF_EAPD, 0);\r\nif (sta350->gpiod_power_down)\r\ngpiod_set_value(sta350->gpiod_power_down, 0);\r\nif (sta350->gpiod_nreset)\r\ngpiod_set_value(sta350->gpiod_nreset, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(sta350->supplies),\r\nsta350->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int sta350_suspend(struct snd_soc_codec *codec)\r\n{\r\nsta350_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int sta350_resume(struct snd_soc_codec *codec)\r\n{\r\nsta350_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int sta350_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nstruct sta350_platform_data *pdata = sta350->pdata;\r\nint i, ret = 0, thermal = 0;\r\nret = regulator_bulk_enable(ARRAY_SIZE(sta350->supplies),\r\nsta350->supplies);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sta350_startup_sequence(sta350);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to startup device\n");\r\nreturn ret;\r\n}\r\nif (!pdata->thermal_warning_recovery)\r\nthermal |= STA350_CONFA_TWAB;\r\nif (!pdata->thermal_warning_adjustment)\r\nthermal |= STA350_CONFA_TWRB;\r\nif (!pdata->fault_detect_recovery)\r\nthermal |= STA350_CONFA_FDRB;\r\nregmap_update_bits(sta350->regmap, STA350_CONFA,\r\nSTA350_CONFA_TWAB | STA350_CONFA_TWRB |\r\nSTA350_CONFA_FDRB,\r\nthermal);\r\nregmap_update_bits(sta350->regmap, STA350_CONFC,\r\nSTA350_CONFC_OM_MASK,\r\npdata->ffx_power_output_mode\r\n<< STA350_CONFC_OM_SHIFT);\r\nregmap_update_bits(sta350->regmap, STA350_CONFC,\r\nSTA350_CONFC_CSZ_MASK,\r\npdata->drop_compensation_ns\r\n<< STA350_CONFC_CSZ_SHIFT);\r\nregmap_update_bits(sta350->regmap,\r\nSTA350_CONFC,\r\nSTA350_CONFC_OCRB,\r\npdata->oc_warning_adjustment ?\r\nSTA350_CONFC_OCRB : 0);\r\nregmap_update_bits(sta350->regmap, STA350_CONFE,\r\nSTA350_CONFE_MPCV,\r\npdata->max_power_use_mpcc ?\r\nSTA350_CONFE_MPCV : 0);\r\nregmap_update_bits(sta350->regmap, STA350_CONFE,\r\nSTA350_CONFE_MPC,\r\npdata->max_power_correction ?\r\nSTA350_CONFE_MPC : 0);\r\nregmap_update_bits(sta350->regmap, STA350_CONFE,\r\nSTA350_CONFE_AME,\r\npdata->am_reduction_mode ?\r\nSTA350_CONFE_AME : 0);\r\nregmap_update_bits(sta350->regmap, STA350_CONFE,\r\nSTA350_CONFE_PWMS,\r\npdata->odd_pwm_speed_mode ?\r\nSTA350_CONFE_PWMS : 0);\r\nregmap_update_bits(sta350->regmap, STA350_CONFE,\r\nSTA350_CONFE_DCCV,\r\npdata->distortion_compensation ?\r\nSTA350_CONFE_DCCV : 0);\r\nregmap_update_bits(sta350->regmap, STA350_CONFF,\r\nSTA350_CONFF_IDE,\r\npdata->invalid_input_detect_mute ?\r\nSTA350_CONFF_IDE : 0);\r\nregmap_update_bits(sta350->regmap, STA350_CONFF,\r\nSTA350_CONFF_OCFG_MASK,\r\npdata->output_conf\r\n<< STA350_CONFF_OCFG_SHIFT);\r\nregmap_update_bits(sta350->regmap, STA350_C1CFG,\r\nSTA350_CxCFG_OM_MASK,\r\npdata->ch1_output_mapping\r\n<< STA350_CxCFG_OM_SHIFT);\r\nregmap_update_bits(sta350->regmap, STA350_C2CFG,\r\nSTA350_CxCFG_OM_MASK,\r\npdata->ch2_output_mapping\r\n<< STA350_CxCFG_OM_SHIFT);\r\nregmap_update_bits(sta350->regmap, STA350_C3CFG,\r\nSTA350_CxCFG_OM_MASK,\r\npdata->ch3_output_mapping\r\n<< STA350_CxCFG_OM_SHIFT);\r\nregmap_update_bits(sta350->regmap, STA350_MISC1,\r\nSTA350_MISC1_CPWMEN,\r\npdata->activate_mute_output ?\r\nSTA350_MISC1_CPWMEN : 0);\r\nregmap_update_bits(sta350->regmap, STA350_MISC1,\r\nSTA350_MISC1_BRIDGOFF,\r\npdata->bridge_immediate_off ?\r\nSTA350_MISC1_BRIDGOFF : 0);\r\nregmap_update_bits(sta350->regmap, STA350_MISC1,\r\nSTA350_MISC1_NSHHPEN,\r\npdata->noise_shape_dc_cut ?\r\nSTA350_MISC1_NSHHPEN : 0);\r\nregmap_update_bits(sta350->regmap, STA350_MISC1,\r\nSTA350_MISC1_RPDNEN,\r\npdata->powerdown_master_vol ?\r\nSTA350_MISC1_RPDNEN: 0);\r\nregmap_update_bits(sta350->regmap, STA350_MISC2,\r\nSTA350_MISC2_PNDLSL_MASK,\r\npdata->powerdown_delay_divider\r\n<< STA350_MISC2_PNDLSL_SHIFT);\r\nfor (i = 4; i <= 49; i += 5)\r\nsta350->coef_shadow[i] = 0x400000;\r\nfor (i = 50; i <= 54; i++)\r\nsta350->coef_shadow[i] = 0x7fffff;\r\nsta350->coef_shadow[55] = 0x5a9df7;\r\nsta350->coef_shadow[56] = 0x7fffff;\r\nsta350->coef_shadow[59] = 0x7fffff;\r\nsta350->coef_shadow[60] = 0x400000;\r\nsta350->coef_shadow[61] = 0x400000;\r\nsta350_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nregulator_bulk_disable(ARRAY_SIZE(sta350->supplies), sta350->supplies);\r\nreturn 0;\r\n}\r\nstatic int sta350_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct sta350_priv *sta350 = snd_soc_codec_get_drvdata(codec);\r\nsta350_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nregulator_bulk_disable(ARRAY_SIZE(sta350->supplies), sta350->supplies);\r\nreturn 0;\r\n}\r\nstatic int sta350_probe_dt(struct device *dev, struct sta350_priv *sta350)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct sta350_platform_data *pdata;\r\nconst char *ffx_power_mode;\r\nu16 tmp;\r\nu8 tmp8;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nof_property_read_u8(np, "st,output-conf",\r\n&pdata->output_conf);\r\nof_property_read_u8(np, "st,ch1-output-mapping",\r\n&pdata->ch1_output_mapping);\r\nof_property_read_u8(np, "st,ch2-output-mapping",\r\n&pdata->ch2_output_mapping);\r\nof_property_read_u8(np, "st,ch3-output-mapping",\r\n&pdata->ch3_output_mapping);\r\nif (of_get_property(np, "st,thermal-warning-recovery", NULL))\r\npdata->thermal_warning_recovery = 1;\r\nif (of_get_property(np, "st,thermal-warning-adjustment", NULL))\r\npdata->thermal_warning_adjustment = 1;\r\nif (of_get_property(np, "st,fault-detect-recovery", NULL))\r\npdata->fault_detect_recovery = 1;\r\npdata->ffx_power_output_mode = STA350_FFX_PM_VARIABLE_DROP_COMP;\r\nif (!of_property_read_string(np, "st,ffx-power-output-mode",\r\n&ffx_power_mode)) {\r\nint i, mode = -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(sta350_ffx_modes); i++)\r\nif (!strcasecmp(ffx_power_mode, sta350_ffx_modes[i]))\r\nmode = i;\r\nif (mode < 0)\r\ndev_warn(dev, "Unsupported ffx output mode: %s\n",\r\nffx_power_mode);\r\nelse\r\npdata->ffx_power_output_mode = mode;\r\n}\r\ntmp = 140;\r\nof_property_read_u16(np, "st,drop-compensation-ns", &tmp);\r\npdata->drop_compensation_ns = clamp_t(u16, tmp, 0, 300) / 20;\r\nif (of_get_property(np, "st,overcurrent-warning-adjustment", NULL))\r\npdata->oc_warning_adjustment = 1;\r\nif (of_get_property(np, "st,max-power-use-mpcc", NULL))\r\npdata->max_power_use_mpcc = 1;\r\nif (of_get_property(np, "st,max-power-correction", NULL))\r\npdata->max_power_correction = 1;\r\nif (of_get_property(np, "st,am-reduction-mode", NULL))\r\npdata->am_reduction_mode = 1;\r\nif (of_get_property(np, "st,odd-pwm-speed-mode", NULL))\r\npdata->odd_pwm_speed_mode = 1;\r\nif (of_get_property(np, "st,distortion-compensation", NULL))\r\npdata->distortion_compensation = 1;\r\nif (of_get_property(np, "st,invalid-input-detect-mute", NULL))\r\npdata->invalid_input_detect_mute = 1;\r\nif (of_get_property(np, "st,activate-mute-output", NULL))\r\npdata->activate_mute_output = 1;\r\nif (of_get_property(np, "st,bridge-immediate-off", NULL))\r\npdata->bridge_immediate_off = 1;\r\nif (of_get_property(np, "st,noise-shape-dc-cut", NULL))\r\npdata->noise_shape_dc_cut = 1;\r\nif (of_get_property(np, "st,powerdown-master-volume", NULL))\r\npdata->powerdown_master_vol = 1;\r\nif (!of_property_read_u8(np, "st,powerdown-delay-divider", &tmp8)) {\r\nif (is_power_of_2(tmp8) && tmp8 >= 1 && tmp8 <= 128)\r\npdata->powerdown_delay_divider = ilog2(tmp8);\r\nelse\r\ndev_warn(dev, "Unsupported powerdown delay divider %d\n",\r\ntmp8);\r\n}\r\nsta350->pdata = pdata;\r\nreturn 0;\r\n}\r\nstatic int sta350_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &i2c->dev;\r\nstruct sta350_priv *sta350;\r\nint ret, i;\r\nsta350 = devm_kzalloc(dev, sizeof(struct sta350_priv), GFP_KERNEL);\r\nif (!sta350)\r\nreturn -ENOMEM;\r\nmutex_init(&sta350->coeff_lock);\r\nsta350->pdata = dev_get_platdata(dev);\r\n#ifdef CONFIG_OF\r\nif (dev->of_node) {\r\nret = sta350_probe_dt(dev, sta350);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n#endif\r\nsta350->gpiod_nreset = devm_gpiod_get(dev, "reset");\r\nif (IS_ERR(sta350->gpiod_nreset)) {\r\nret = PTR_ERR(sta350->gpiod_nreset);\r\nif (ret != -ENOENT && ret != -ENOSYS)\r\nreturn ret;\r\nsta350->gpiod_nreset = NULL;\r\n} else {\r\ngpiod_direction_output(sta350->gpiod_nreset, 0);\r\n}\r\nsta350->gpiod_power_down = devm_gpiod_get(dev, "power-down");\r\nif (IS_ERR(sta350->gpiod_power_down)) {\r\nret = PTR_ERR(sta350->gpiod_power_down);\r\nif (ret != -ENOENT && ret != -ENOSYS)\r\nreturn ret;\r\nsta350->gpiod_power_down = NULL;\r\n} else {\r\ngpiod_direction_output(sta350->gpiod_power_down, 0);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sta350->supplies); i++)\r\nsta350->supplies[i].supply = sta350_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(sta350->supplies),\r\nsta350->supplies);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nsta350->regmap = devm_regmap_init_i2c(i2c, &sta350_regmap);\r\nif (IS_ERR(sta350->regmap)) {\r\nret = PTR_ERR(sta350->regmap);\r\ndev_err(dev, "Failed to init regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, sta350);\r\nret = snd_soc_register_codec(dev, &sta350_codec, &sta350_dai, 1);\r\nif (ret < 0)\r\ndev_err(dev, "Failed to register codec (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int sta350_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
