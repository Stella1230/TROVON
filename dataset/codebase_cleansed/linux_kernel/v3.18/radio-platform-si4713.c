static int radio_si4713_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *capability)\r\n{\r\nstrlcpy(capability->driver, "radio-si4713", sizeof(capability->driver));\r\nstrlcpy(capability->card, "Silicon Labs Si4713 Modulator",\r\nsizeof(capability->card));\r\nstrlcpy(capability->bus_info, "platform:radio-si4713",\r\nsizeof(capability->bus_info));\r\ncapability->device_caps = V4L2_CAP_MODULATOR | V4L2_CAP_RDS_OUTPUT;\r\ncapability->capabilities = capability->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic inline struct v4l2_device *get_v4l2_dev(struct file *file)\r\n{\r\nreturn &((struct radio_si4713_device *)video_drvdata(file))->v4l2_dev;\r\n}\r\nstatic int radio_si4713_g_modulator(struct file *file, void *p,\r\nstruct v4l2_modulator *vm)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\r\ng_modulator, vm);\r\n}\r\nstatic int radio_si4713_s_modulator(struct file *file, void *p,\r\nconst struct v4l2_modulator *vm)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\r\ns_modulator, vm);\r\n}\r\nstatic int radio_si4713_g_frequency(struct file *file, void *p,\r\nstruct v4l2_frequency *vf)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\r\ng_frequency, vf);\r\n}\r\nstatic int radio_si4713_s_frequency(struct file *file, void *p,\r\nconst struct v4l2_frequency *vf)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\r\ns_frequency, vf);\r\n}\r\nstatic long radio_si4713_default(struct file *file, void *p,\r\nbool valid_prio, unsigned int cmd, void *arg)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, core,\r\nioctl, cmd, arg);\r\n}\r\nstatic int radio_si4713_pdriver_probe(struct platform_device *pdev)\r\n{\r\nstruct radio_si4713_platform_data *pdata = pdev->dev.platform_data;\r\nstruct radio_si4713_device *rsdev;\r\nstruct i2c_adapter *adapter;\r\nstruct v4l2_subdev *sd;\r\nint rval = 0;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Cannot proceed without platform data.\n");\r\nrval = -EINVAL;\r\ngoto exit;\r\n}\r\nrsdev = devm_kzalloc(&pdev->dev, sizeof(*rsdev), GFP_KERNEL);\r\nif (!rsdev) {\r\ndev_err(&pdev->dev, "Failed to alloc video device.\n");\r\nrval = -ENOMEM;\r\ngoto exit;\r\n}\r\nmutex_init(&rsdev->lock);\r\nrval = v4l2_device_register(&pdev->dev, &rsdev->v4l2_dev);\r\nif (rval) {\r\ndev_err(&pdev->dev, "Failed to register v4l2 device.\n");\r\ngoto exit;\r\n}\r\nadapter = i2c_get_adapter(pdata->i2c_bus);\r\nif (!adapter) {\r\ndev_err(&pdev->dev, "Cannot get i2c adapter %d\n",\r\npdata->i2c_bus);\r\nrval = -ENODEV;\r\ngoto unregister_v4l2_dev;\r\n}\r\nsd = v4l2_i2c_new_subdev_board(&rsdev->v4l2_dev, adapter,\r\npdata->subdev_board_info, NULL);\r\nif (!sd) {\r\ndev_err(&pdev->dev, "Cannot get v4l2 subdevice\n");\r\nrval = -ENODEV;\r\ngoto put_adapter;\r\n}\r\nrsdev->radio_dev = radio_si4713_vdev_template;\r\nrsdev->radio_dev.v4l2_dev = &rsdev->v4l2_dev;\r\nrsdev->radio_dev.ctrl_handler = sd->ctrl_handler;\r\nrsdev->radio_dev.lock = &rsdev->lock;\r\nvideo_set_drvdata(&rsdev->radio_dev, rsdev);\r\nif (video_register_device(&rsdev->radio_dev, VFL_TYPE_RADIO, radio_nr)) {\r\ndev_err(&pdev->dev, "Could not register video device.\n");\r\nrval = -EIO;\r\ngoto put_adapter;\r\n}\r\ndev_info(&pdev->dev, "New device successfully probed\n");\r\ngoto exit;\r\nput_adapter:\r\ni2c_put_adapter(adapter);\r\nunregister_v4l2_dev:\r\nv4l2_device_unregister(&rsdev->v4l2_dev);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int radio_si4713_pdriver_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct v4l2_subdev *sd = list_entry(v4l2_dev->subdevs.next,\r\nstruct v4l2_subdev, list);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct radio_si4713_device *rsdev;\r\nrsdev = container_of(v4l2_dev, struct radio_si4713_device, v4l2_dev);\r\nvideo_unregister_device(&rsdev->radio_dev);\r\ni2c_put_adapter(client->adapter);\r\nv4l2_device_unregister(&rsdev->v4l2_dev);\r\nreturn 0;\r\n}
