static ssize_t channels_supported_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct wpan_phy *phy = container_of(dev, struct wpan_phy, dev);\r\nint ret;\r\nint i, len = 0;\r\nmutex_lock(&phy->pib_lock);\r\nfor (i = 0; i < 32; i++) {\r\nret = snprintf(buf + len, PAGE_SIZE - len,\r\n"%#09x\n", phy->channels_supported[i]);\r\nif (ret < 0)\r\nbreak;\r\nlen += ret;\r\n}\r\nmutex_unlock(&phy->pib_lock);\r\nreturn len;\r\n}\r\nstatic void wpan_phy_release(struct device *d)\r\n{\r\nstruct wpan_phy *phy = container_of(d, struct wpan_phy, dev);\r\nkfree(phy);\r\n}\r\nstatic int wpan_phy_match(struct device *dev, const void *data)\r\n{\r\nreturn !strcmp(dev_name(dev), (const char *)data);\r\n}\r\nstruct wpan_phy *wpan_phy_find(const char *str)\r\n{\r\nstruct device *dev;\r\nif (WARN_ON(!str))\r\nreturn NULL;\r\ndev = class_find_device(&wpan_phy_class, NULL, str, wpan_phy_match);\r\nif (!dev)\r\nreturn NULL;\r\nreturn container_of(dev, struct wpan_phy, dev);\r\n}\r\nstatic int wpan_phy_iter(struct device *dev, void *_data)\r\n{\r\nstruct wpan_phy_iter_data *wpid = _data;\r\nstruct wpan_phy *phy = container_of(dev, struct wpan_phy, dev);\r\nreturn wpid->fn(phy, wpid->data);\r\n}\r\nint wpan_phy_for_each(int (*fn)(struct wpan_phy *phy, void *data),\r\nvoid *data)\r\n{\r\nstruct wpan_phy_iter_data wpid = {\r\n.fn = fn,\r\n.data = data,\r\n};\r\nreturn class_for_each_device(&wpan_phy_class, NULL,\r\n&wpid, wpan_phy_iter);\r\n}\r\nstatic int wpan_phy_idx_valid(int idx)\r\n{\r\nreturn idx >= 0;\r\n}\r\nstruct wpan_phy *wpan_phy_alloc(size_t priv_size)\r\n{\r\nstruct wpan_phy *phy = kzalloc(sizeof(*phy) + priv_size,\r\nGFP_KERNEL);\r\nif (!phy)\r\ngoto out;\r\nmutex_lock(&wpan_phy_mutex);\r\nphy->idx = wpan_phy_idx++;\r\nif (unlikely(!wpan_phy_idx_valid(phy->idx))) {\r\nwpan_phy_idx--;\r\nmutex_unlock(&wpan_phy_mutex);\r\nkfree(phy);\r\ngoto out;\r\n}\r\nmutex_unlock(&wpan_phy_mutex);\r\nmutex_init(&phy->pib_lock);\r\ndevice_initialize(&phy->dev);\r\ndev_set_name(&phy->dev, "wpan-phy%d", phy->idx);\r\nphy->dev.class = &wpan_phy_class;\r\nphy->current_channel = -1;\r\nphy->current_page = 0;\r\nreturn phy;\r\nout:\r\nreturn NULL;\r\n}\r\nint wpan_phy_register(struct wpan_phy *phy)\r\n{\r\nreturn device_add(&phy->dev);\r\n}\r\nvoid wpan_phy_unregister(struct wpan_phy *phy)\r\n{\r\ndevice_del(&phy->dev);\r\n}\r\nvoid wpan_phy_free(struct wpan_phy *phy)\r\n{\r\nput_device(&phy->dev);\r\n}\r\nstatic int __init wpan_phy_class_init(void)\r\n{\r\nint rc;\r\nrc = class_register(&wpan_phy_class);\r\nif (rc)\r\ngoto err;\r\nrc = ieee802154_nl_init();\r\nif (rc)\r\ngoto err_nl;\r\nreturn 0;\r\nerr_nl:\r\nclass_unregister(&wpan_phy_class);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic void __exit wpan_phy_class_exit(void)\r\n{\r\nieee802154_nl_exit();\r\nclass_unregister(&wpan_phy_class);\r\n}
