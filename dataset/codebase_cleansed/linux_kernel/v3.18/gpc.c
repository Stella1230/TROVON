void imx_gpc_pre_suspend(bool arm_power_off)\r\n{\r\nvoid __iomem *reg_imr1 = gpc_base + GPC_IMR1;\r\nint i;\r\nif (arm_power_off)\r\nwritel_relaxed(0x1, gpc_base + GPC_PGC_CPU_PDN);\r\nfor (i = 0; i < IMR_NUM; i++) {\r\ngpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);\r\nwritel_relaxed(~gpc_wake_irqs[i], reg_imr1 + i * 4);\r\n}\r\n}\r\nvoid imx_gpc_post_resume(void)\r\n{\r\nvoid __iomem *reg_imr1 = gpc_base + GPC_IMR1;\r\nint i;\r\nwritel_relaxed(0x0, gpc_base + GPC_PGC_CPU_PDN);\r\nfor (i = 0; i < IMR_NUM; i++)\r\nwritel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);\r\n}\r\nstatic int imx_gpc_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nunsigned int idx = d->irq / 32 - 1;\r\nu32 mask;\r\nif (d->irq < 32)\r\nreturn -EINVAL;\r\nmask = 1 << d->irq % 32;\r\ngpc_wake_irqs[idx] = on ? gpc_wake_irqs[idx] | mask :\r\ngpc_wake_irqs[idx] & ~mask;\r\nreturn 0;\r\n}\r\nvoid imx_gpc_mask_all(void)\r\n{\r\nvoid __iomem *reg_imr1 = gpc_base + GPC_IMR1;\r\nint i;\r\nfor (i = 0; i < IMR_NUM; i++) {\r\ngpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);\r\nwritel_relaxed(~0, reg_imr1 + i * 4);\r\n}\r\n}\r\nvoid imx_gpc_restore_all(void)\r\n{\r\nvoid __iomem *reg_imr1 = gpc_base + GPC_IMR1;\r\nint i;\r\nfor (i = 0; i < IMR_NUM; i++)\r\nwritel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);\r\n}\r\nvoid imx_gpc_irq_unmask(struct irq_data *d)\r\n{\r\nvoid __iomem *reg;\r\nu32 val;\r\nif (d->irq < 32)\r\nreturn;\r\nreg = gpc_base + GPC_IMR1 + (d->irq / 32 - 1) * 4;\r\nval = readl_relaxed(reg);\r\nval &= ~(1 << d->irq % 32);\r\nwritel_relaxed(val, reg);\r\n}\r\nvoid imx_gpc_irq_mask(struct irq_data *d)\r\n{\r\nvoid __iomem *reg;\r\nu32 val;\r\nif (d->irq < 32)\r\nreturn;\r\nreg = gpc_base + GPC_IMR1 + (d->irq / 32 - 1) * 4;\r\nval = readl_relaxed(reg);\r\nval |= 1 << (d->irq % 32);\r\nwritel_relaxed(val, reg);\r\n}\r\nvoid __init imx_gpc_init(void)\r\n{\r\nstruct device_node *np;\r\nint i;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");\r\ngpc_base = of_iomap(np, 0);\r\nWARN_ON(!gpc_base);\r\nfor (i = 0; i < IMR_NUM; i++)\r\nwritel_relaxed(~0, gpc_base + GPC_IMR1 + i * 4);\r\ngic_arch_extn.irq_mask = imx_gpc_irq_mask;\r\ngic_arch_extn.irq_unmask = imx_gpc_irq_unmask;\r\ngic_arch_extn.irq_set_wake = imx_gpc_irq_set_wake;\r\n}
