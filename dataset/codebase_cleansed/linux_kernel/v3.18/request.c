static unsigned cache_mode(struct cached_dev *dc, struct bio *bio)\r\n{\r\nreturn BDEV_CACHE_MODE(&dc->sb);\r\n}\r\nstatic bool verify(struct cached_dev *dc, struct bio *bio)\r\n{\r\nreturn dc->verify;\r\n}\r\nstatic void bio_csum(struct bio *bio, struct bkey *k)\r\n{\r\nstruct bio_vec bv;\r\nstruct bvec_iter iter;\r\nuint64_t csum = 0;\r\nbio_for_each_segment(bv, bio, iter) {\r\nvoid *d = kmap(bv.bv_page) + bv.bv_offset;\r\ncsum = bch_crc64_update(csum, d, bv.bv_len);\r\nkunmap(bv.bv_page);\r\n}\r\nk->ptr[KEY_PTRS(k)] = csum & (~0ULL >> 1);\r\n}\r\nstatic void bch_data_insert_keys(struct closure *cl)\r\n{\r\nstruct data_insert_op *op = container_of(cl, struct data_insert_op, cl);\r\natomic_t *journal_ref = NULL;\r\nstruct bkey *replace_key = op->replace ? &op->replace_key : NULL;\r\nint ret;\r\n#if 0\r\nwhile (atomic_read(&s->cl.remaining) & CLOSURE_WAITING)\r\nclosure_sync(&s->cl);\r\n#endif\r\nif (!op->replace)\r\njournal_ref = bch_journal(op->c, &op->insert_keys,\r\nop->flush_journal ? cl : NULL);\r\nret = bch_btree_insert(op->c, &op->insert_keys,\r\njournal_ref, replace_key);\r\nif (ret == -ESRCH) {\r\nop->replace_collision = true;\r\n} else if (ret) {\r\nop->error = -ENOMEM;\r\nop->insert_data_done = true;\r\n}\r\nif (journal_ref)\r\natomic_dec_bug(journal_ref);\r\nif (!op->insert_data_done)\r\ncontinue_at(cl, bch_data_insert_start, op->wq);\r\nbch_keylist_free(&op->insert_keys);\r\nclosure_return(cl);\r\n}\r\nstatic int bch_keylist_realloc(struct keylist *l, unsigned u64s,\r\nstruct cache_set *c)\r\n{\r\nsize_t oldsize = bch_keylist_nkeys(l);\r\nsize_t newsize = oldsize + u64s;\r\nif (newsize * sizeof(uint64_t) > block_bytes(c) - sizeof(struct jset))\r\nreturn -ENOMEM;\r\nreturn __bch_keylist_realloc(l, u64s);\r\n}\r\nstatic void bch_data_invalidate(struct closure *cl)\r\n{\r\nstruct data_insert_op *op = container_of(cl, struct data_insert_op, cl);\r\nstruct bio *bio = op->bio;\r\npr_debug("invalidating %i sectors from %llu",\r\nbio_sectors(bio), (uint64_t) bio->bi_iter.bi_sector);\r\nwhile (bio_sectors(bio)) {\r\nunsigned sectors = min(bio_sectors(bio),\r\n1U << (KEY_SIZE_BITS - 1));\r\nif (bch_keylist_realloc(&op->insert_keys, 2, op->c))\r\ngoto out;\r\nbio->bi_iter.bi_sector += sectors;\r\nbio->bi_iter.bi_size -= sectors << 9;\r\nbch_keylist_add(&op->insert_keys,\r\n&KEY(op->inode, bio->bi_iter.bi_sector, sectors));\r\n}\r\nop->insert_data_done = true;\r\nbio_put(bio);\r\nout:\r\ncontinue_at(cl, bch_data_insert_keys, op->wq);\r\n}\r\nstatic void bch_data_insert_error(struct closure *cl)\r\n{\r\nstruct data_insert_op *op = container_of(cl, struct data_insert_op, cl);\r\nstruct bkey *src = op->insert_keys.keys, *dst = op->insert_keys.keys;\r\nwhile (src != op->insert_keys.top) {\r\nstruct bkey *n = bkey_next(src);\r\nSET_KEY_PTRS(src, 0);\r\nmemmove(dst, src, bkey_bytes(src));\r\ndst = bkey_next(dst);\r\nsrc = n;\r\n}\r\nop->insert_keys.top = dst;\r\nbch_data_insert_keys(cl);\r\n}\r\nstatic void bch_data_insert_endio(struct bio *bio, int error)\r\n{\r\nstruct closure *cl = bio->bi_private;\r\nstruct data_insert_op *op = container_of(cl, struct data_insert_op, cl);\r\nif (error) {\r\nif (op->writeback)\r\nop->error = error;\r\nelse if (!op->replace)\r\nset_closure_fn(cl, bch_data_insert_error, op->wq);\r\nelse\r\nset_closure_fn(cl, NULL, NULL);\r\n}\r\nbch_bbio_endio(op->c, bio, error, "writing data to cache");\r\n}\r\nstatic void bch_data_insert_start(struct closure *cl)\r\n{\r\nstruct data_insert_op *op = container_of(cl, struct data_insert_op, cl);\r\nstruct bio *bio = op->bio, *n;\r\nif (atomic_sub_return(bio_sectors(bio), &op->c->sectors_to_gc) < 0) {\r\nset_gc_sectors(op->c);\r\nwake_up_gc(op->c);\r\n}\r\nif (op->bypass)\r\nreturn bch_data_invalidate(cl);\r\nbio->bi_rw &= ~(REQ_FLUSH|REQ_FUA);\r\ndo {\r\nunsigned i;\r\nstruct bkey *k;\r\nstruct bio_set *split = op->c->bio_split;\r\nif (bch_keylist_realloc(&op->insert_keys,\r\n3 + (op->csum ? 1 : 0),\r\nop->c))\r\ncontinue_at(cl, bch_data_insert_keys, op->wq);\r\nk = op->insert_keys.top;\r\nbkey_init(k);\r\nSET_KEY_INODE(k, op->inode);\r\nSET_KEY_OFFSET(k, bio->bi_iter.bi_sector);\r\nif (!bch_alloc_sectors(op->c, k, bio_sectors(bio),\r\nop->write_point, op->write_prio,\r\nop->writeback))\r\ngoto err;\r\nn = bio_next_split(bio, KEY_SIZE(k), GFP_NOIO, split);\r\nn->bi_end_io = bch_data_insert_endio;\r\nn->bi_private = cl;\r\nif (op->writeback) {\r\nSET_KEY_DIRTY(k, true);\r\nfor (i = 0; i < KEY_PTRS(k); i++)\r\nSET_GC_MARK(PTR_BUCKET(op->c, k, i),\r\nGC_MARK_DIRTY);\r\n}\r\nSET_KEY_CSUM(k, op->csum);\r\nif (KEY_CSUM(k))\r\nbio_csum(n, k);\r\ntrace_bcache_cache_insert(k);\r\nbch_keylist_push(&op->insert_keys);\r\nn->bi_rw |= REQ_WRITE;\r\nbch_submit_bbio(n, op->c, k, 0);\r\n} while (n != bio);\r\nop->insert_data_done = true;\r\ncontinue_at(cl, bch_data_insert_keys, op->wq);\r\nerr:\r\nBUG_ON(op->writeback);\r\nif (!op->replace) {\r\nop->bypass = true;\r\nreturn bch_data_invalidate(cl);\r\n} else {\r\nop->insert_data_done = true;\r\nbio_put(bio);\r\nif (!bch_keylist_empty(&op->insert_keys))\r\ncontinue_at(cl, bch_data_insert_keys, op->wq);\r\nelse\r\nclosure_return(cl);\r\n}\r\n}\r\nvoid bch_data_insert(struct closure *cl)\r\n{\r\nstruct data_insert_op *op = container_of(cl, struct data_insert_op, cl);\r\ntrace_bcache_write(op->c, op->inode, op->bio,\r\nop->writeback, op->bypass);\r\nbch_keylist_init(&op->insert_keys);\r\nbio_get(op->bio);\r\nbch_data_insert_start(cl);\r\n}\r\nunsigned bch_get_congested(struct cache_set *c)\r\n{\r\nint i;\r\nlong rand;\r\nif (!c->congested_read_threshold_us &&\r\n!c->congested_write_threshold_us)\r\nreturn 0;\r\ni = (local_clock_us() - c->congested_last_us) / 1024;\r\nif (i < 0)\r\nreturn 0;\r\ni += atomic_read(&c->congested);\r\nif (i >= 0)\r\nreturn 0;\r\ni += CONGESTED_MAX;\r\nif (i > 0)\r\ni = fract_exp_two(i, 6);\r\nrand = get_random_int();\r\ni -= bitmap_weight(&rand, BITS_PER_LONG);\r\nreturn i > 0 ? i : 1;\r\n}\r\nstatic void add_sequential(struct task_struct *t)\r\n{\r\newma_add(t->sequential_io_avg,\r\nt->sequential_io, 8, 0);\r\nt->sequential_io = 0;\r\n}\r\nstatic struct hlist_head *iohash(struct cached_dev *dc, uint64_t k)\r\n{\r\nreturn &dc->io_hash[hash_64(k, RECENT_IO_BITS)];\r\n}\r\nstatic bool check_should_bypass(struct cached_dev *dc, struct bio *bio)\r\n{\r\nstruct cache_set *c = dc->disk.c;\r\nunsigned mode = cache_mode(dc, bio);\r\nunsigned sectors, congested = bch_get_congested(c);\r\nstruct task_struct *task = current;\r\nstruct io *i;\r\nif (test_bit(BCACHE_DEV_DETACHING, &dc->disk.flags) ||\r\nc->gc_stats.in_use > CUTOFF_CACHE_ADD ||\r\n(bio->bi_rw & REQ_DISCARD))\r\ngoto skip;\r\nif (mode == CACHE_MODE_NONE ||\r\n(mode == CACHE_MODE_WRITEAROUND &&\r\n(bio->bi_rw & REQ_WRITE)))\r\ngoto skip;\r\nif (bio->bi_iter.bi_sector & (c->sb.block_size - 1) ||\r\nbio_sectors(bio) & (c->sb.block_size - 1)) {\r\npr_debug("skipping unaligned io");\r\ngoto skip;\r\n}\r\nif (bypass_torture_test(dc)) {\r\nif ((get_random_int() & 3) == 3)\r\ngoto skip;\r\nelse\r\ngoto rescale;\r\n}\r\nif (!congested && !dc->sequential_cutoff)\r\ngoto rescale;\r\nif (!congested &&\r\nmode == CACHE_MODE_WRITEBACK &&\r\n(bio->bi_rw & REQ_WRITE) &&\r\n(bio->bi_rw & REQ_SYNC))\r\ngoto rescale;\r\nspin_lock(&dc->io_lock);\r\nhlist_for_each_entry(i, iohash(dc, bio->bi_iter.bi_sector), hash)\r\nif (i->last == bio->bi_iter.bi_sector &&\r\ntime_before(jiffies, i->jiffies))\r\ngoto found;\r\ni = list_first_entry(&dc->io_lru, struct io, lru);\r\nadd_sequential(task);\r\ni->sequential = 0;\r\nfound:\r\nif (i->sequential + bio->bi_iter.bi_size > i->sequential)\r\ni->sequential += bio->bi_iter.bi_size;\r\ni->last = bio_end_sector(bio);\r\ni->jiffies = jiffies + msecs_to_jiffies(5000);\r\ntask->sequential_io = i->sequential;\r\nhlist_del(&i->hash);\r\nhlist_add_head(&i->hash, iohash(dc, i->last));\r\nlist_move_tail(&i->lru, &dc->io_lru);\r\nspin_unlock(&dc->io_lock);\r\nsectors = max(task->sequential_io,\r\ntask->sequential_io_avg) >> 9;\r\nif (dc->sequential_cutoff &&\r\nsectors >= dc->sequential_cutoff >> 9) {\r\ntrace_bcache_bypass_sequential(bio);\r\ngoto skip;\r\n}\r\nif (congested && sectors >= congested) {\r\ntrace_bcache_bypass_congested(bio);\r\ngoto skip;\r\n}\r\nrescale:\r\nbch_rescale_priorities(c, bio_sectors(bio));\r\nreturn false;\r\nskip:\r\nbch_mark_sectors_bypassed(c, dc, bio_sectors(bio));\r\nreturn true;\r\n}\r\nstatic void bch_cache_read_endio(struct bio *bio, int error)\r\n{\r\nstruct bbio *b = container_of(bio, struct bbio, bio);\r\nstruct closure *cl = bio->bi_private;\r\nstruct search *s = container_of(cl, struct search, cl);\r\nif (error)\r\ns->iop.error = error;\r\nelse if (!KEY_DIRTY(&b->key) &&\r\nptr_stale(s->iop.c, &b->key, 0)) {\r\natomic_long_inc(&s->iop.c->cache_read_races);\r\ns->iop.error = -EINTR;\r\n}\r\nbch_bbio_endio(s->iop.c, bio, error, "reading from cache");\r\n}\r\nstatic int cache_lookup_fn(struct btree_op *op, struct btree *b, struct bkey *k)\r\n{\r\nstruct search *s = container_of(op, struct search, op);\r\nstruct bio *n, *bio = &s->bio.bio;\r\nstruct bkey *bio_key;\r\nunsigned ptr;\r\nif (bkey_cmp(k, &KEY(s->iop.inode, bio->bi_iter.bi_sector, 0)) <= 0)\r\nreturn MAP_CONTINUE;\r\nif (KEY_INODE(k) != s->iop.inode ||\r\nKEY_START(k) > bio->bi_iter.bi_sector) {\r\nunsigned bio_sectors = bio_sectors(bio);\r\nunsigned sectors = KEY_INODE(k) == s->iop.inode\r\n? min_t(uint64_t, INT_MAX,\r\nKEY_START(k) - bio->bi_iter.bi_sector)\r\n: INT_MAX;\r\nint ret = s->d->cache_miss(b, s, bio, sectors);\r\nif (ret != MAP_CONTINUE)\r\nreturn ret;\r\nBUG_ON(bio_sectors <= sectors);\r\n}\r\nif (!KEY_SIZE(k))\r\nreturn MAP_CONTINUE;\r\nptr = 0;\r\nPTR_BUCKET(b->c, k, ptr)->prio = INITIAL_PRIO;\r\nif (KEY_DIRTY(k))\r\ns->read_dirty_data = true;\r\nn = bio_next_split(bio, min_t(uint64_t, INT_MAX,\r\nKEY_OFFSET(k) - bio->bi_iter.bi_sector),\r\nGFP_NOIO, s->d->bio_split);\r\nbio_key = &container_of(n, struct bbio, bio)->key;\r\nbch_bkey_copy_single_ptr(bio_key, k, ptr);\r\nbch_cut_front(&KEY(s->iop.inode, n->bi_iter.bi_sector, 0), bio_key);\r\nbch_cut_back(&KEY(s->iop.inode, bio_end_sector(n), 0), bio_key);\r\nn->bi_end_io = bch_cache_read_endio;\r\nn->bi_private = &s->cl;\r\n__bch_submit_bbio(n, b->c);\r\nreturn n == bio ? MAP_DONE : MAP_CONTINUE;\r\n}\r\nstatic void cache_lookup(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, iop.cl);\r\nstruct bio *bio = &s->bio.bio;\r\nint ret;\r\nbch_btree_op_init(&s->op, -1);\r\nret = bch_btree_map_keys(&s->op, s->iop.c,\r\n&KEY(s->iop.inode, bio->bi_iter.bi_sector, 0),\r\ncache_lookup_fn, MAP_END_KEY);\r\nif (ret == -EAGAIN)\r\ncontinue_at(cl, cache_lookup, bcache_wq);\r\nclosure_return(cl);\r\n}\r\nstatic void request_endio(struct bio *bio, int error)\r\n{\r\nstruct closure *cl = bio->bi_private;\r\nif (error) {\r\nstruct search *s = container_of(cl, struct search, cl);\r\ns->iop.error = error;\r\ns->recoverable = false;\r\n}\r\nbio_put(bio);\r\nclosure_put(cl);\r\n}\r\nstatic void bio_complete(struct search *s)\r\n{\r\nif (s->orig_bio) {\r\nint cpu, rw = bio_data_dir(s->orig_bio);\r\nunsigned long duration = jiffies - s->start_time;\r\ncpu = part_stat_lock();\r\npart_round_stats(cpu, &s->d->disk->part0);\r\npart_stat_add(cpu, &s->d->disk->part0, ticks[rw], duration);\r\npart_stat_unlock();\r\ntrace_bcache_request_end(s->d, s->orig_bio);\r\nbio_endio(s->orig_bio, s->iop.error);\r\ns->orig_bio = NULL;\r\n}\r\n}\r\nstatic void do_bio_hook(struct search *s, struct bio *orig_bio)\r\n{\r\nstruct bio *bio = &s->bio.bio;\r\nbio_init(bio);\r\n__bio_clone_fast(bio, orig_bio);\r\nbio->bi_end_io = request_endio;\r\nbio->bi_private = &s->cl;\r\natomic_set(&bio->bi_cnt, 3);\r\n}\r\nstatic void search_free(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nbio_complete(s);\r\nif (s->iop.bio)\r\nbio_put(s->iop.bio);\r\nclosure_debug_destroy(cl);\r\nmempool_free(s, s->d->c->search);\r\n}\r\nstatic inline struct search *search_alloc(struct bio *bio,\r\nstruct bcache_device *d)\r\n{\r\nstruct search *s;\r\ns = mempool_alloc(d->c->search, GFP_NOIO);\r\nclosure_init(&s->cl, NULL);\r\ndo_bio_hook(s, bio);\r\ns->orig_bio = bio;\r\ns->cache_miss = NULL;\r\ns->d = d;\r\ns->recoverable = 1;\r\ns->write = (bio->bi_rw & REQ_WRITE) != 0;\r\ns->read_dirty_data = 0;\r\ns->start_time = jiffies;\r\ns->iop.c = d->c;\r\ns->iop.bio = NULL;\r\ns->iop.inode = d->id;\r\ns->iop.write_point = hash_long((unsigned long) current, 16);\r\ns->iop.write_prio = 0;\r\ns->iop.error = 0;\r\ns->iop.flags = 0;\r\ns->iop.flush_journal = (bio->bi_rw & (REQ_FLUSH|REQ_FUA)) != 0;\r\ns->iop.wq = bcache_wq;\r\nreturn s;\r\n}\r\nstatic void cached_dev_bio_complete(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nstruct cached_dev *dc = container_of(s->d, struct cached_dev, disk);\r\nsearch_free(cl);\r\ncached_dev_put(dc);\r\n}\r\nstatic void cached_dev_cache_miss_done(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nif (s->iop.replace_collision)\r\nbch_mark_cache_miss_collision(s->iop.c, s->d);\r\nif (s->iop.bio) {\r\nint i;\r\nstruct bio_vec *bv;\r\nbio_for_each_segment_all(bv, s->iop.bio, i)\r\n__free_page(bv->bv_page);\r\n}\r\ncached_dev_bio_complete(cl);\r\n}\r\nstatic void cached_dev_read_error(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nstruct bio *bio = &s->bio.bio;\r\nif (s->recoverable) {\r\ntrace_bcache_read_retry(s->orig_bio);\r\ns->iop.error = 0;\r\ndo_bio_hook(s, s->orig_bio);\r\nclosure_bio_submit(bio, cl, s->d);\r\n}\r\ncontinue_at(cl, cached_dev_cache_miss_done, NULL);\r\n}\r\nstatic void cached_dev_read_done(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nstruct cached_dev *dc = container_of(s->d, struct cached_dev, disk);\r\nif (s->iop.bio) {\r\nbio_reset(s->iop.bio);\r\ns->iop.bio->bi_iter.bi_sector = s->cache_miss->bi_iter.bi_sector;\r\ns->iop.bio->bi_bdev = s->cache_miss->bi_bdev;\r\ns->iop.bio->bi_iter.bi_size = s->insert_bio_sectors << 9;\r\nbch_bio_map(s->iop.bio, NULL);\r\nbio_copy_data(s->cache_miss, s->iop.bio);\r\nbio_put(s->cache_miss);\r\ns->cache_miss = NULL;\r\n}\r\nif (verify(dc, &s->bio.bio) && s->recoverable && !s->read_dirty_data)\r\nbch_data_verify(dc, s->orig_bio);\r\nbio_complete(s);\r\nif (s->iop.bio &&\r\n!test_bit(CACHE_SET_STOPPING, &s->iop.c->flags)) {\r\nBUG_ON(!s->iop.replace);\r\nclosure_call(&s->iop.cl, bch_data_insert, NULL, cl);\r\n}\r\ncontinue_at(cl, cached_dev_cache_miss_done, NULL);\r\n}\r\nstatic void cached_dev_read_done_bh(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nstruct cached_dev *dc = container_of(s->d, struct cached_dev, disk);\r\nbch_mark_cache_accounting(s->iop.c, s->d,\r\n!s->cache_miss, s->iop.bypass);\r\ntrace_bcache_read(s->orig_bio, !s->cache_miss, s->iop.bypass);\r\nif (s->iop.error)\r\ncontinue_at_nobarrier(cl, cached_dev_read_error, bcache_wq);\r\nelse if (s->iop.bio || verify(dc, &s->bio.bio))\r\ncontinue_at_nobarrier(cl, cached_dev_read_done, bcache_wq);\r\nelse\r\ncontinue_at_nobarrier(cl, cached_dev_bio_complete, NULL);\r\n}\r\nstatic int cached_dev_cache_miss(struct btree *b, struct search *s,\r\nstruct bio *bio, unsigned sectors)\r\n{\r\nint ret = MAP_CONTINUE;\r\nunsigned reada = 0;\r\nstruct cached_dev *dc = container_of(s->d, struct cached_dev, disk);\r\nstruct bio *miss, *cache_bio;\r\nif (s->cache_miss || s->iop.bypass) {\r\nmiss = bio_next_split(bio, sectors, GFP_NOIO, s->d->bio_split);\r\nret = miss == bio ? MAP_DONE : MAP_CONTINUE;\r\ngoto out_submit;\r\n}\r\nif (!(bio->bi_rw & REQ_RAHEAD) &&\r\n!(bio->bi_rw & REQ_META) &&\r\ns->iop.c->gc_stats.in_use < CUTOFF_CACHE_READA)\r\nreada = min_t(sector_t, dc->readahead >> 9,\r\nbdev_sectors(bio->bi_bdev) - bio_end_sector(bio));\r\ns->insert_bio_sectors = min(sectors, bio_sectors(bio) + reada);\r\ns->iop.replace_key = KEY(s->iop.inode,\r\nbio->bi_iter.bi_sector + s->insert_bio_sectors,\r\ns->insert_bio_sectors);\r\nret = bch_btree_insert_check_key(b, &s->op, &s->iop.replace_key);\r\nif (ret)\r\nreturn ret;\r\ns->iop.replace = true;\r\nmiss = bio_next_split(bio, sectors, GFP_NOIO, s->d->bio_split);\r\nret = miss == bio ? MAP_DONE : -EINTR;\r\ncache_bio = bio_alloc_bioset(GFP_NOWAIT,\r\nDIV_ROUND_UP(s->insert_bio_sectors, PAGE_SECTORS),\r\ndc->disk.bio_split);\r\nif (!cache_bio)\r\ngoto out_submit;\r\ncache_bio->bi_iter.bi_sector = miss->bi_iter.bi_sector;\r\ncache_bio->bi_bdev = miss->bi_bdev;\r\ncache_bio->bi_iter.bi_size = s->insert_bio_sectors << 9;\r\ncache_bio->bi_end_io = request_endio;\r\ncache_bio->bi_private = &s->cl;\r\nbch_bio_map(cache_bio, NULL);\r\nif (bio_alloc_pages(cache_bio, __GFP_NOWARN|GFP_NOIO))\r\ngoto out_put;\r\nif (reada)\r\nbch_mark_cache_readahead(s->iop.c, s->d);\r\ns->cache_miss = miss;\r\ns->iop.bio = cache_bio;\r\nbio_get(cache_bio);\r\nclosure_bio_submit(cache_bio, &s->cl, s->d);\r\nreturn ret;\r\nout_put:\r\nbio_put(cache_bio);\r\nout_submit:\r\nmiss->bi_end_io = request_endio;\r\nmiss->bi_private = &s->cl;\r\nclosure_bio_submit(miss, &s->cl, s->d);\r\nreturn ret;\r\n}\r\nstatic void cached_dev_read(struct cached_dev *dc, struct search *s)\r\n{\r\nstruct closure *cl = &s->cl;\r\nclosure_call(&s->iop.cl, cache_lookup, NULL, cl);\r\ncontinue_at(cl, cached_dev_read_done_bh, NULL);\r\n}\r\nstatic void cached_dev_write_complete(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nstruct cached_dev *dc = container_of(s->d, struct cached_dev, disk);\r\nup_read_non_owner(&dc->writeback_lock);\r\ncached_dev_bio_complete(cl);\r\n}\r\nstatic void cached_dev_write(struct cached_dev *dc, struct search *s)\r\n{\r\nstruct closure *cl = &s->cl;\r\nstruct bio *bio = &s->bio.bio;\r\nstruct bkey start = KEY(dc->disk.id, bio->bi_iter.bi_sector, 0);\r\nstruct bkey end = KEY(dc->disk.id, bio_end_sector(bio), 0);\r\nbch_keybuf_check_overlapping(&s->iop.c->moving_gc_keys, &start, &end);\r\ndown_read_non_owner(&dc->writeback_lock);\r\nif (bch_keybuf_check_overlapping(&dc->writeback_keys, &start, &end)) {\r\ns->iop.bypass = false;\r\ns->iop.writeback = true;\r\n}\r\nif (bio->bi_rw & REQ_DISCARD)\r\ns->iop.bypass = true;\r\nif (should_writeback(dc, s->orig_bio,\r\ncache_mode(dc, bio),\r\ns->iop.bypass)) {\r\ns->iop.bypass = false;\r\ns->iop.writeback = true;\r\n}\r\nif (s->iop.bypass) {\r\ns->iop.bio = s->orig_bio;\r\nbio_get(s->iop.bio);\r\nif (!(bio->bi_rw & REQ_DISCARD) ||\r\nblk_queue_discard(bdev_get_queue(dc->bdev)))\r\nclosure_bio_submit(bio, cl, s->d);\r\n} else if (s->iop.writeback) {\r\nbch_writeback_add(dc);\r\ns->iop.bio = bio;\r\nif (bio->bi_rw & REQ_FLUSH) {\r\nstruct bio *flush = bio_alloc_bioset(GFP_NOIO, 0,\r\ndc->disk.bio_split);\r\nflush->bi_rw = WRITE_FLUSH;\r\nflush->bi_bdev = bio->bi_bdev;\r\nflush->bi_end_io = request_endio;\r\nflush->bi_private = cl;\r\nclosure_bio_submit(flush, cl, s->d);\r\n}\r\n} else {\r\ns->iop.bio = bio_clone_fast(bio, GFP_NOIO, dc->disk.bio_split);\r\nclosure_bio_submit(bio, cl, s->d);\r\n}\r\nclosure_call(&s->iop.cl, bch_data_insert, NULL, cl);\r\ncontinue_at(cl, cached_dev_write_complete, NULL);\r\n}\r\nstatic void cached_dev_nodata(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nstruct bio *bio = &s->bio.bio;\r\nif (s->iop.flush_journal)\r\nbch_journal_meta(s->iop.c, cl);\r\nclosure_bio_submit(bio, cl, s->d);\r\ncontinue_at(cl, cached_dev_bio_complete, NULL);\r\n}\r\nstatic void cached_dev_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct search *s;\r\nstruct bcache_device *d = bio->bi_bdev->bd_disk->private_data;\r\nstruct cached_dev *dc = container_of(d, struct cached_dev, disk);\r\nint cpu, rw = bio_data_dir(bio);\r\ncpu = part_stat_lock();\r\npart_stat_inc(cpu, &d->disk->part0, ios[rw]);\r\npart_stat_add(cpu, &d->disk->part0, sectors[rw], bio_sectors(bio));\r\npart_stat_unlock();\r\nbio->bi_bdev = dc->bdev;\r\nbio->bi_iter.bi_sector += dc->sb.data_offset;\r\nif (cached_dev_get(dc)) {\r\ns = search_alloc(bio, d);\r\ntrace_bcache_request_start(s->d, bio);\r\nif (!bio->bi_iter.bi_size) {\r\ncontinue_at_nobarrier(&s->cl,\r\ncached_dev_nodata,\r\nbcache_wq);\r\n} else {\r\ns->iop.bypass = check_should_bypass(dc, bio);\r\nif (rw)\r\ncached_dev_write(dc, s);\r\nelse\r\ncached_dev_read(dc, s);\r\n}\r\n} else {\r\nif ((bio->bi_rw & REQ_DISCARD) &&\r\n!blk_queue_discard(bdev_get_queue(dc->bdev)))\r\nbio_endio(bio, 0);\r\nelse\r\nbch_generic_make_request(bio, &d->bio_split_hook);\r\n}\r\n}\r\nstatic int cached_dev_ioctl(struct bcache_device *d, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct cached_dev *dc = container_of(d, struct cached_dev, disk);\r\nreturn __blkdev_driver_ioctl(dc->bdev, mode, cmd, arg);\r\n}\r\nstatic int cached_dev_congested(void *data, int bits)\r\n{\r\nstruct bcache_device *d = data;\r\nstruct cached_dev *dc = container_of(d, struct cached_dev, disk);\r\nstruct request_queue *q = bdev_get_queue(dc->bdev);\r\nint ret = 0;\r\nif (bdi_congested(&q->backing_dev_info, bits))\r\nreturn 1;\r\nif (cached_dev_get(dc)) {\r\nunsigned i;\r\nstruct cache *ca;\r\nfor_each_cache(ca, d->c, i) {\r\nq = bdev_get_queue(ca->bdev);\r\nret |= bdi_congested(&q->backing_dev_info, bits);\r\n}\r\ncached_dev_put(dc);\r\n}\r\nreturn ret;\r\n}\r\nvoid bch_cached_dev_request_init(struct cached_dev *dc)\r\n{\r\nstruct gendisk *g = dc->disk.disk;\r\ng->queue->make_request_fn = cached_dev_make_request;\r\ng->queue->backing_dev_info.congested_fn = cached_dev_congested;\r\ndc->disk.cache_miss = cached_dev_cache_miss;\r\ndc->disk.ioctl = cached_dev_ioctl;\r\n}\r\nstatic int flash_dev_cache_miss(struct btree *b, struct search *s,\r\nstruct bio *bio, unsigned sectors)\r\n{\r\nunsigned bytes = min(sectors, bio_sectors(bio)) << 9;\r\nswap(bio->bi_iter.bi_size, bytes);\r\nzero_fill_bio(bio);\r\nswap(bio->bi_iter.bi_size, bytes);\r\nbio_advance(bio, bytes);\r\nif (!bio->bi_iter.bi_size)\r\nreturn MAP_DONE;\r\nreturn MAP_CONTINUE;\r\n}\r\nstatic void flash_dev_nodata(struct closure *cl)\r\n{\r\nstruct search *s = container_of(cl, struct search, cl);\r\nif (s->iop.flush_journal)\r\nbch_journal_meta(s->iop.c, cl);\r\ncontinue_at(cl, search_free, NULL);\r\n}\r\nstatic void flash_dev_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct search *s;\r\nstruct closure *cl;\r\nstruct bcache_device *d = bio->bi_bdev->bd_disk->private_data;\r\nint cpu, rw = bio_data_dir(bio);\r\ncpu = part_stat_lock();\r\npart_stat_inc(cpu, &d->disk->part0, ios[rw]);\r\npart_stat_add(cpu, &d->disk->part0, sectors[rw], bio_sectors(bio));\r\npart_stat_unlock();\r\ns = search_alloc(bio, d);\r\ncl = &s->cl;\r\nbio = &s->bio.bio;\r\ntrace_bcache_request_start(s->d, bio);\r\nif (!bio->bi_iter.bi_size) {\r\ncontinue_at_nobarrier(&s->cl,\r\nflash_dev_nodata,\r\nbcache_wq);\r\n} else if (rw) {\r\nbch_keybuf_check_overlapping(&s->iop.c->moving_gc_keys,\r\n&KEY(d->id, bio->bi_iter.bi_sector, 0),\r\n&KEY(d->id, bio_end_sector(bio), 0));\r\ns->iop.bypass = (bio->bi_rw & REQ_DISCARD) != 0;\r\ns->iop.writeback = true;\r\ns->iop.bio = bio;\r\nclosure_call(&s->iop.cl, bch_data_insert, NULL, cl);\r\n} else {\r\nclosure_call(&s->iop.cl, cache_lookup, NULL, cl);\r\n}\r\ncontinue_at(cl, search_free, NULL);\r\n}\r\nstatic int flash_dev_ioctl(struct bcache_device *d, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOTTY;\r\n}\r\nstatic int flash_dev_congested(void *data, int bits)\r\n{\r\nstruct bcache_device *d = data;\r\nstruct request_queue *q;\r\nstruct cache *ca;\r\nunsigned i;\r\nint ret = 0;\r\nfor_each_cache(ca, d->c, i) {\r\nq = bdev_get_queue(ca->bdev);\r\nret |= bdi_congested(&q->backing_dev_info, bits);\r\n}\r\nreturn ret;\r\n}\r\nvoid bch_flash_dev_request_init(struct bcache_device *d)\r\n{\r\nstruct gendisk *g = d->disk;\r\ng->queue->make_request_fn = flash_dev_make_request;\r\ng->queue->backing_dev_info.congested_fn = flash_dev_congested;\r\nd->cache_miss = flash_dev_cache_miss;\r\nd->ioctl = flash_dev_ioctl;\r\n}\r\nvoid bch_request_exit(void)\r\n{\r\nif (bch_search_cache)\r\nkmem_cache_destroy(bch_search_cache);\r\n}\r\nint __init bch_request_init(void)\r\n{\r\nbch_search_cache = KMEM_CACHE(search, 0);\r\nif (!bch_search_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
