static inline void canframecpy(struct can_frame *dst, struct can_frame *src)\r\n{\r\ndst->can_id = src->can_id;\r\ndst->can_dlc = src->can_dlc;\r\n*(u64 *)dst->data = *(u64 *)src->data;\r\n}\r\nstatic int cgw_chk_csum_parms(s8 fr, s8 to, s8 re)\r\n{\r\nif (fr > -9 && fr < 8 &&\r\nto > -9 && to < 8 &&\r\nre > -9 && re < 8)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic inline int calc_idx(int idx, int rx_dlc)\r\n{\r\nif (idx < 0)\r\nreturn rx_dlc + idx;\r\nelse\r\nreturn idx;\r\n}\r\nstatic void cgw_csum_xor_rel(struct can_frame *cf, struct cgw_csum_xor *xor)\r\n{\r\nint from = calc_idx(xor->from_idx, cf->can_dlc);\r\nint to = calc_idx(xor->to_idx, cf->can_dlc);\r\nint res = calc_idx(xor->result_idx, cf->can_dlc);\r\nu8 val = xor->init_xor_val;\r\nint i;\r\nif (from < 0 || to < 0 || res < 0)\r\nreturn;\r\nif (from <= to) {\r\nfor (i = from; i <= to; i++)\r\nval ^= cf->data[i];\r\n} else {\r\nfor (i = from; i >= to; i--)\r\nval ^= cf->data[i];\r\n}\r\ncf->data[res] = val;\r\n}\r\nstatic void cgw_csum_xor_pos(struct can_frame *cf, struct cgw_csum_xor *xor)\r\n{\r\nu8 val = xor->init_xor_val;\r\nint i;\r\nfor (i = xor->from_idx; i <= xor->to_idx; i++)\r\nval ^= cf->data[i];\r\ncf->data[xor->result_idx] = val;\r\n}\r\nstatic void cgw_csum_xor_neg(struct can_frame *cf, struct cgw_csum_xor *xor)\r\n{\r\nu8 val = xor->init_xor_val;\r\nint i;\r\nfor (i = xor->from_idx; i >= xor->to_idx; i--)\r\nval ^= cf->data[i];\r\ncf->data[xor->result_idx] = val;\r\n}\r\nstatic void cgw_csum_crc8_rel(struct can_frame *cf, struct cgw_csum_crc8 *crc8)\r\n{\r\nint from = calc_idx(crc8->from_idx, cf->can_dlc);\r\nint to = calc_idx(crc8->to_idx, cf->can_dlc);\r\nint res = calc_idx(crc8->result_idx, cf->can_dlc);\r\nu8 crc = crc8->init_crc_val;\r\nint i;\r\nif (from < 0 || to < 0 || res < 0)\r\nreturn;\r\nif (from <= to) {\r\nfor (i = crc8->from_idx; i <= crc8->to_idx; i++)\r\ncrc = crc8->crctab[crc^cf->data[i]];\r\n} else {\r\nfor (i = crc8->from_idx; i >= crc8->to_idx; i--)\r\ncrc = crc8->crctab[crc^cf->data[i]];\r\n}\r\nswitch (crc8->profile) {\r\ncase CGW_CRC8PRF_1U8:\r\ncrc = crc8->crctab[crc^crc8->profile_data[0]];\r\nbreak;\r\ncase CGW_CRC8PRF_16U8:\r\ncrc = crc8->crctab[crc^crc8->profile_data[cf->data[1] & 0xF]];\r\nbreak;\r\ncase CGW_CRC8PRF_SFFID_XOR:\r\ncrc = crc8->crctab[crc^(cf->can_id & 0xFF)^\r\n(cf->can_id >> 8 & 0xFF)];\r\nbreak;\r\n}\r\ncf->data[crc8->result_idx] = crc^crc8->final_xor_val;\r\n}\r\nstatic void cgw_csum_crc8_pos(struct can_frame *cf, struct cgw_csum_crc8 *crc8)\r\n{\r\nu8 crc = crc8->init_crc_val;\r\nint i;\r\nfor (i = crc8->from_idx; i <= crc8->to_idx; i++)\r\ncrc = crc8->crctab[crc^cf->data[i]];\r\nswitch (crc8->profile) {\r\ncase CGW_CRC8PRF_1U8:\r\ncrc = crc8->crctab[crc^crc8->profile_data[0]];\r\nbreak;\r\ncase CGW_CRC8PRF_16U8:\r\ncrc = crc8->crctab[crc^crc8->profile_data[cf->data[1] & 0xF]];\r\nbreak;\r\ncase CGW_CRC8PRF_SFFID_XOR:\r\ncrc = crc8->crctab[crc^(cf->can_id & 0xFF)^\r\n(cf->can_id >> 8 & 0xFF)];\r\nbreak;\r\n}\r\ncf->data[crc8->result_idx] = crc^crc8->final_xor_val;\r\n}\r\nstatic void cgw_csum_crc8_neg(struct can_frame *cf, struct cgw_csum_crc8 *crc8)\r\n{\r\nu8 crc = crc8->init_crc_val;\r\nint i;\r\nfor (i = crc8->from_idx; i >= crc8->to_idx; i--)\r\ncrc = crc8->crctab[crc^cf->data[i]];\r\nswitch (crc8->profile) {\r\ncase CGW_CRC8PRF_1U8:\r\ncrc = crc8->crctab[crc^crc8->profile_data[0]];\r\nbreak;\r\ncase CGW_CRC8PRF_16U8:\r\ncrc = crc8->crctab[crc^crc8->profile_data[cf->data[1] & 0xF]];\r\nbreak;\r\ncase CGW_CRC8PRF_SFFID_XOR:\r\ncrc = crc8->crctab[crc^(cf->can_id & 0xFF)^\r\n(cf->can_id >> 8 & 0xFF)];\r\nbreak;\r\n}\r\ncf->data[crc8->result_idx] = crc^crc8->final_xor_val;\r\n}\r\nstatic void can_can_gw_rcv(struct sk_buff *skb, void *data)\r\n{\r\nstruct cgw_job *gwj = (struct cgw_job *)data;\r\nstruct can_frame *cf;\r\nstruct sk_buff *nskb;\r\nint modidx = 0;\r\n#define cgw_hops(skb) ((skb)->csum_start)\r\nBUG_ON(skb->ip_summed != CHECKSUM_UNNECESSARY);\r\nif (cgw_hops(skb) >= max_hops) {\r\ngwj->deleted_frames++;\r\nreturn;\r\n}\r\nif (!(gwj->dst.dev->flags & IFF_UP)) {\r\ngwj->dropped_frames++;\r\nreturn;\r\n}\r\nif (!(gwj->flags & CGW_FLAGS_CAN_IIF_TX_OK) &&\r\ncan_skb_prv(skb)->ifindex == gwj->dst.dev->ifindex)\r\nreturn;\r\nif (gwj->mod.modfunc[0])\r\nnskb = skb_copy(skb, GFP_ATOMIC);\r\nelse\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!nskb) {\r\ngwj->dropped_frames++;\r\nreturn;\r\n}\r\ncgw_hops(nskb) = cgw_hops(skb) + 1;\r\nif (gwj->limit_hops && cgw_hops(nskb) == 1)\r\ncgw_hops(nskb) = max_hops - gwj->limit_hops + 1;\r\nnskb->dev = gwj->dst.dev;\r\ncf = (struct can_frame *)nskb->data;\r\nwhile (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])\r\n(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);\r\nif (modidx) {\r\nif (gwj->mod.csumfunc.crc8)\r\n(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);\r\nif (gwj->mod.csumfunc.xor)\r\n(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);\r\n}\r\nif (!(gwj->flags & CGW_FLAGS_CAN_SRC_TSTAMP))\r\nnskb->tstamp.tv64 = 0;\r\nif (can_send(nskb, gwj->flags & CGW_FLAGS_CAN_ECHO))\r\ngwj->dropped_frames++;\r\nelse\r\ngwj->handled_frames++;\r\n}\r\nstatic inline int cgw_register_filter(struct cgw_job *gwj)\r\n{\r\nreturn can_rx_register(gwj->src.dev, gwj->ccgw.filter.can_id,\r\ngwj->ccgw.filter.can_mask, can_can_gw_rcv,\r\ngwj, "gw");\r\n}\r\nstatic inline void cgw_unregister_filter(struct cgw_job *gwj)\r\n{\r\ncan_rx_unregister(gwj->src.dev, gwj->ccgw.filter.can_id,\r\ngwj->ccgw.filter.can_mask, can_can_gw_rcv, gwj);\r\n}\r\nstatic int cgw_notifier(struct notifier_block *nb,\r\nunsigned long msg, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (dev->type != ARPHRD_CAN)\r\nreturn NOTIFY_DONE;\r\nif (msg == NETDEV_UNREGISTER) {\r\nstruct cgw_job *gwj = NULL;\r\nstruct hlist_node *nx;\r\nASSERT_RTNL();\r\nhlist_for_each_entry_safe(gwj, nx, &cgw_list, list) {\r\nif (gwj->src.dev == dev || gwj->dst.dev == dev) {\r\nhlist_del(&gwj->list);\r\ncgw_unregister_filter(gwj);\r\nkmem_cache_free(cgw_cache, gwj);\r\n}\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int cgw_put_job(struct sk_buff *skb, struct cgw_job *gwj, int type,\r\nu32 pid, u32 seq, int flags)\r\n{\r\nstruct cgw_frame_mod mb;\r\nstruct rtcanmsg *rtcan;\r\nstruct nlmsghdr *nlh;\r\nnlh = nlmsg_put(skb, pid, seq, type, sizeof(*rtcan), flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nrtcan = nlmsg_data(nlh);\r\nrtcan->can_family = AF_CAN;\r\nrtcan->gwtype = gwj->gwtype;\r\nrtcan->flags = gwj->flags;\r\nif (gwj->handled_frames) {\r\nif (nla_put_u32(skb, CGW_HANDLED, gwj->handled_frames) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->dropped_frames) {\r\nif (nla_put_u32(skb, CGW_DROPPED, gwj->dropped_frames) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->deleted_frames) {\r\nif (nla_put_u32(skb, CGW_DELETED, gwj->deleted_frames) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->limit_hops) {\r\nif (nla_put_u8(skb, CGW_LIM_HOPS, gwj->limit_hops) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->mod.modtype.and) {\r\nmemcpy(&mb.cf, &gwj->mod.modframe.and, sizeof(mb.cf));\r\nmb.modtype = gwj->mod.modtype.and;\r\nif (nla_put(skb, CGW_MOD_AND, sizeof(mb), &mb) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->mod.modtype.or) {\r\nmemcpy(&mb.cf, &gwj->mod.modframe.or, sizeof(mb.cf));\r\nmb.modtype = gwj->mod.modtype.or;\r\nif (nla_put(skb, CGW_MOD_OR, sizeof(mb), &mb) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->mod.modtype.xor) {\r\nmemcpy(&mb.cf, &gwj->mod.modframe.xor, sizeof(mb.cf));\r\nmb.modtype = gwj->mod.modtype.xor;\r\nif (nla_put(skb, CGW_MOD_XOR, sizeof(mb), &mb) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->mod.modtype.set) {\r\nmemcpy(&mb.cf, &gwj->mod.modframe.set, sizeof(mb.cf));\r\nmb.modtype = gwj->mod.modtype.set;\r\nif (nla_put(skb, CGW_MOD_SET, sizeof(mb), &mb) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->mod.csumfunc.crc8) {\r\nif (nla_put(skb, CGW_CS_CRC8, CGW_CS_CRC8_LEN,\r\n&gwj->mod.csum.crc8) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->mod.csumfunc.xor) {\r\nif (nla_put(skb, CGW_CS_XOR, CGW_CS_XOR_LEN,\r\n&gwj->mod.csum.xor) < 0)\r\ngoto cancel;\r\n}\r\nif (gwj->gwtype == CGW_TYPE_CAN_CAN) {\r\nif (gwj->ccgw.filter.can_id || gwj->ccgw.filter.can_mask) {\r\nif (nla_put(skb, CGW_FILTER, sizeof(struct can_filter),\r\n&gwj->ccgw.filter) < 0)\r\ngoto cancel;\r\n}\r\nif (nla_put_u32(skb, CGW_SRC_IF, gwj->ccgw.src_idx) < 0)\r\ngoto cancel;\r\nif (nla_put_u32(skb, CGW_DST_IF, gwj->ccgw.dst_idx) < 0)\r\ngoto cancel;\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\ncancel:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int cgw_dump_jobs(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct cgw_job *gwj = NULL;\r\nint idx = 0;\r\nint s_idx = cb->args[0];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gwj, &cgw_list, list) {\r\nif (idx < s_idx)\r\ngoto cont;\r\nif (cgw_put_job(skb, gwj, RTM_NEWROUTE, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI) < 0)\r\nbreak;\r\ncont:\r\nidx++;\r\n}\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic int cgw_parse_attr(struct nlmsghdr *nlh, struct cf_mod *mod,\r\nu8 gwtype, void *gwtypeattr, u8 *limhops)\r\n{\r\nstruct nlattr *tb[CGW_MAX+1];\r\nstruct cgw_frame_mod mb;\r\nint modidx = 0;\r\nint err = 0;\r\nmemset(mod, 0, sizeof(*mod));\r\nerr = nlmsg_parse(nlh, sizeof(struct rtcanmsg), tb, CGW_MAX,\r\ncgw_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[CGW_LIM_HOPS]) {\r\n*limhops = nla_get_u8(tb[CGW_LIM_HOPS]);\r\nif (*limhops < 1 || *limhops > max_hops)\r\nreturn -EINVAL;\r\n}\r\nif (tb[CGW_MOD_AND]) {\r\nnla_memcpy(&mb, tb[CGW_MOD_AND], CGW_MODATTR_LEN);\r\ncanframecpy(&mod->modframe.and, &mb.cf);\r\nmod->modtype.and = mb.modtype;\r\nif (mb.modtype & CGW_MOD_ID)\r\nmod->modfunc[modidx++] = mod_and_id;\r\nif (mb.modtype & CGW_MOD_DLC)\r\nmod->modfunc[modidx++] = mod_and_dlc;\r\nif (mb.modtype & CGW_MOD_DATA)\r\nmod->modfunc[modidx++] = mod_and_data;\r\n}\r\nif (tb[CGW_MOD_OR]) {\r\nnla_memcpy(&mb, tb[CGW_MOD_OR], CGW_MODATTR_LEN);\r\ncanframecpy(&mod->modframe.or, &mb.cf);\r\nmod->modtype.or = mb.modtype;\r\nif (mb.modtype & CGW_MOD_ID)\r\nmod->modfunc[modidx++] = mod_or_id;\r\nif (mb.modtype & CGW_MOD_DLC)\r\nmod->modfunc[modidx++] = mod_or_dlc;\r\nif (mb.modtype & CGW_MOD_DATA)\r\nmod->modfunc[modidx++] = mod_or_data;\r\n}\r\nif (tb[CGW_MOD_XOR]) {\r\nnla_memcpy(&mb, tb[CGW_MOD_XOR], CGW_MODATTR_LEN);\r\ncanframecpy(&mod->modframe.xor, &mb.cf);\r\nmod->modtype.xor = mb.modtype;\r\nif (mb.modtype & CGW_MOD_ID)\r\nmod->modfunc[modidx++] = mod_xor_id;\r\nif (mb.modtype & CGW_MOD_DLC)\r\nmod->modfunc[modidx++] = mod_xor_dlc;\r\nif (mb.modtype & CGW_MOD_DATA)\r\nmod->modfunc[modidx++] = mod_xor_data;\r\n}\r\nif (tb[CGW_MOD_SET]) {\r\nnla_memcpy(&mb, tb[CGW_MOD_SET], CGW_MODATTR_LEN);\r\ncanframecpy(&mod->modframe.set, &mb.cf);\r\nmod->modtype.set = mb.modtype;\r\nif (mb.modtype & CGW_MOD_ID)\r\nmod->modfunc[modidx++] = mod_set_id;\r\nif (mb.modtype & CGW_MOD_DLC)\r\nmod->modfunc[modidx++] = mod_set_dlc;\r\nif (mb.modtype & CGW_MOD_DATA)\r\nmod->modfunc[modidx++] = mod_set_data;\r\n}\r\nif (modidx) {\r\nif (tb[CGW_CS_CRC8]) {\r\nstruct cgw_csum_crc8 *c = nla_data(tb[CGW_CS_CRC8]);\r\nerr = cgw_chk_csum_parms(c->from_idx, c->to_idx,\r\nc->result_idx);\r\nif (err)\r\nreturn err;\r\nnla_memcpy(&mod->csum.crc8, tb[CGW_CS_CRC8],\r\nCGW_CS_CRC8_LEN);\r\nif (c->from_idx < 0 || c->to_idx < 0 ||\r\nc->result_idx < 0)\r\nmod->csumfunc.crc8 = cgw_csum_crc8_rel;\r\nelse if (c->from_idx <= c->to_idx)\r\nmod->csumfunc.crc8 = cgw_csum_crc8_pos;\r\nelse\r\nmod->csumfunc.crc8 = cgw_csum_crc8_neg;\r\n}\r\nif (tb[CGW_CS_XOR]) {\r\nstruct cgw_csum_xor *c = nla_data(tb[CGW_CS_XOR]);\r\nerr = cgw_chk_csum_parms(c->from_idx, c->to_idx,\r\nc->result_idx);\r\nif (err)\r\nreturn err;\r\nnla_memcpy(&mod->csum.xor, tb[CGW_CS_XOR],\r\nCGW_CS_XOR_LEN);\r\nif (c->from_idx < 0 || c->to_idx < 0 ||\r\nc->result_idx < 0)\r\nmod->csumfunc.xor = cgw_csum_xor_rel;\r\nelse if (c->from_idx <= c->to_idx)\r\nmod->csumfunc.xor = cgw_csum_xor_pos;\r\nelse\r\nmod->csumfunc.xor = cgw_csum_xor_neg;\r\n}\r\n}\r\nif (gwtype == CGW_TYPE_CAN_CAN) {\r\nstruct can_can_gw *ccgw = (struct can_can_gw *)gwtypeattr;\r\nmemset(ccgw, 0, sizeof(*ccgw));\r\nif (tb[CGW_FILTER])\r\nnla_memcpy(&ccgw->filter, tb[CGW_FILTER],\r\nsizeof(struct can_filter));\r\nerr = -ENODEV;\r\nif (!tb[CGW_SRC_IF] || !tb[CGW_DST_IF])\r\nreturn err;\r\nccgw->src_idx = nla_get_u32(tb[CGW_SRC_IF]);\r\nccgw->dst_idx = nla_get_u32(tb[CGW_DST_IF]);\r\nif (!ccgw->src_idx && !ccgw->dst_idx)\r\nreturn 0;\r\nif (!ccgw->src_idx || !ccgw->dst_idx)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cgw_create_job(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct rtcanmsg *r;\r\nstruct cgw_job *gwj;\r\nu8 limhops = 0;\r\nint err = 0;\r\nif (!netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (nlmsg_len(nlh) < sizeof(*r))\r\nreturn -EINVAL;\r\nr = nlmsg_data(nlh);\r\nif (r->can_family != AF_CAN)\r\nreturn -EPFNOSUPPORT;\r\nif (r->gwtype != CGW_TYPE_CAN_CAN)\r\nreturn -EINVAL;\r\ngwj = kmem_cache_alloc(cgw_cache, GFP_KERNEL);\r\nif (!gwj)\r\nreturn -ENOMEM;\r\ngwj->handled_frames = 0;\r\ngwj->dropped_frames = 0;\r\ngwj->deleted_frames = 0;\r\ngwj->flags = r->flags;\r\ngwj->gwtype = r->gwtype;\r\nerr = cgw_parse_attr(nlh, &gwj->mod, CGW_TYPE_CAN_CAN, &gwj->ccgw,\r\n&limhops);\r\nif (err < 0)\r\ngoto out;\r\nerr = -ENODEV;\r\nif (!gwj->ccgw.src_idx || !gwj->ccgw.dst_idx)\r\ngoto out;\r\ngwj->src.dev = __dev_get_by_index(&init_net, gwj->ccgw.src_idx);\r\nif (!gwj->src.dev)\r\ngoto out;\r\nif (gwj->src.dev->type != ARPHRD_CAN)\r\ngoto out;\r\ngwj->dst.dev = __dev_get_by_index(&init_net, gwj->ccgw.dst_idx);\r\nif (!gwj->dst.dev)\r\ngoto out;\r\nif (gwj->dst.dev->type != ARPHRD_CAN)\r\ngoto out;\r\ngwj->limit_hops = limhops;\r\nASSERT_RTNL();\r\nerr = cgw_register_filter(gwj);\r\nif (!err)\r\nhlist_add_head_rcu(&gwj->list, &cgw_list);\r\nout:\r\nif (err)\r\nkmem_cache_free(cgw_cache, gwj);\r\nreturn err;\r\n}\r\nstatic void cgw_remove_all_jobs(void)\r\n{\r\nstruct cgw_job *gwj = NULL;\r\nstruct hlist_node *nx;\r\nASSERT_RTNL();\r\nhlist_for_each_entry_safe(gwj, nx, &cgw_list, list) {\r\nhlist_del(&gwj->list);\r\ncgw_unregister_filter(gwj);\r\nkmem_cache_free(cgw_cache, gwj);\r\n}\r\n}\r\nstatic int cgw_remove_job(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct cgw_job *gwj = NULL;\r\nstruct hlist_node *nx;\r\nstruct rtcanmsg *r;\r\nstruct cf_mod mod;\r\nstruct can_can_gw ccgw;\r\nu8 limhops = 0;\r\nint err = 0;\r\nif (!netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (nlmsg_len(nlh) < sizeof(*r))\r\nreturn -EINVAL;\r\nr = nlmsg_data(nlh);\r\nif (r->can_family != AF_CAN)\r\nreturn -EPFNOSUPPORT;\r\nif (r->gwtype != CGW_TYPE_CAN_CAN)\r\nreturn -EINVAL;\r\nerr = cgw_parse_attr(nlh, &mod, CGW_TYPE_CAN_CAN, &ccgw, &limhops);\r\nif (err < 0)\r\nreturn err;\r\nif (!ccgw.src_idx && !ccgw.dst_idx) {\r\ncgw_remove_all_jobs();\r\nreturn 0;\r\n}\r\nerr = -EINVAL;\r\nASSERT_RTNL();\r\nhlist_for_each_entry_safe(gwj, nx, &cgw_list, list) {\r\nif (gwj->flags != r->flags)\r\ncontinue;\r\nif (gwj->limit_hops != limhops)\r\ncontinue;\r\nif (memcmp(&gwj->mod, &mod, sizeof(mod)))\r\ncontinue;\r\nif (memcmp(&gwj->ccgw, &ccgw, sizeof(ccgw)))\r\ncontinue;\r\nhlist_del(&gwj->list);\r\ncgw_unregister_filter(gwj);\r\nkmem_cache_free(cgw_cache, gwj);\r\nerr = 0;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic __init int cgw_module_init(void)\r\n{\r\nmax_hops = clamp_t(unsigned int, max_hops, CGW_MIN_HOPS, CGW_MAX_HOPS);\r\npr_info("can: netlink gateway (rev " CAN_GW_VERSION ") max_hops=%d\n",\r\nmax_hops);\r\ncgw_cache = kmem_cache_create("can_gw", sizeof(struct cgw_job),\r\n0, 0, NULL);\r\nif (!cgw_cache)\r\nreturn -ENOMEM;\r\nnotifier.notifier_call = cgw_notifier;\r\nregister_netdevice_notifier(&notifier);\r\nif (__rtnl_register(PF_CAN, RTM_GETROUTE, NULL, cgw_dump_jobs, NULL)) {\r\nunregister_netdevice_notifier(&notifier);\r\nkmem_cache_destroy(cgw_cache);\r\nreturn -ENOBUFS;\r\n}\r\n__rtnl_register(PF_CAN, RTM_NEWROUTE, cgw_create_job, NULL, NULL);\r\n__rtnl_register(PF_CAN, RTM_DELROUTE, cgw_remove_job, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic __exit void cgw_module_exit(void)\r\n{\r\nrtnl_unregister_all(PF_CAN);\r\nunregister_netdevice_notifier(&notifier);\r\nrtnl_lock();\r\ncgw_remove_all_jobs();\r\nrtnl_unlock();\r\nrcu_barrier();\r\nkmem_cache_destroy(cgw_cache);\r\n}
