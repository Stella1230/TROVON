static void snd_interwave_i2c_setlines(struct snd_i2c_bus *bus, int ctrl, int data)\r\n{\r\nunsigned long port = bus->private_value;\r\n#if 0\r\nprintk(KERN_DEBUG "i2c_setlines - 0x%lx <- %i,%i\n", port, ctrl, data);\r\n#endif\r\noutb((data << 1) | ctrl, port);\r\nudelay(10);\r\n}\r\nstatic int snd_interwave_i2c_getclockline(struct snd_i2c_bus *bus)\r\n{\r\nunsigned long port = bus->private_value;\r\nunsigned char res;\r\nres = inb(port) & 1;\r\n#if 0\r\nprintk(KERN_DEBUG "i2c_getclockline - 0x%lx -> %i\n", port, res);\r\n#endif\r\nreturn res;\r\n}\r\nstatic int snd_interwave_i2c_getdataline(struct snd_i2c_bus *bus, int ack)\r\n{\r\nunsigned long port = bus->private_value;\r\nunsigned char res;\r\nif (ack)\r\nudelay(10);\r\nres = (inb(port) & 2) >> 1;\r\n#if 0\r\nprintk(KERN_DEBUG "i2c_getdataline - 0x%lx -> %i\n", port, res);\r\n#endif\r\nreturn res;\r\n}\r\nstatic int snd_interwave_detect_stb(struct snd_interwave *iwcard,\r\nstruct snd_gus_card *gus, int dev,\r\nstruct snd_i2c_bus **rbus)\r\n{\r\nunsigned long port;\r\nstruct snd_i2c_bus *bus;\r\nstruct snd_card *card = iwcard->card;\r\nchar name[32];\r\nint err;\r\n*rbus = NULL;\r\nport = port_tc[dev];\r\nif (port == SNDRV_AUTO_PORT) {\r\nport = 0x350;\r\nif (gus->gf1.port == 0x250) {\r\nport = 0x360;\r\n}\r\nwhile (port <= 0x380) {\r\nif ((iwcard->i2c_res = request_region(port, 1, "InterWave (I2C bus)")) != NULL)\r\nbreak;\r\nport += 0x10;\r\n}\r\n} else {\r\niwcard->i2c_res = request_region(port, 1, "InterWave (I2C bus)");\r\n}\r\nif (iwcard->i2c_res == NULL) {\r\nsnd_printk(KERN_ERR "interwave: can't grab i2c bus port\n");\r\nreturn -ENODEV;\r\n}\r\nsprintf(name, "InterWave-%i", card->number);\r\nif ((err = snd_i2c_bus_create(card, name, NULL, &bus)) < 0)\r\nreturn err;\r\nbus->private_value = port;\r\nbus->hw_ops.bit = &snd_interwave_i2c_bit_ops;\r\nif ((err = snd_tea6330t_detect(bus, 0)) < 0)\r\nreturn err;\r\n*rbus = bus;\r\nreturn 0;\r\n}\r\nstatic int snd_interwave_detect(struct snd_interwave *iwcard,\r\nstruct snd_gus_card *gus,\r\nint dev\r\n#ifdef SNDRV_STB\r\n, struct snd_i2c_bus **rbus\r\n#endif\r\n)\r\n{\r\nunsigned long flags;\r\nunsigned char rev1, rev2;\r\nint d;\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);\r\nif (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 0) {\r\nsnd_printdd("[0x%lx] check 1 failed - 0x%x\n", gus->gf1.port, d);\r\nreturn -ENODEV;\r\n}\r\nudelay(160);\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\r\nudelay(160);\r\nif (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 1) {\r\nsnd_printdd("[0x%lx] check 2 failed - 0x%x\n", gus->gf1.port, d);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\nrev1 = snd_gf1_look8(gus, SNDRV_GF1_GB_VERSION_NUMBER);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_VERSION_NUMBER, ~rev1);\r\nrev2 = snd_gf1_look8(gus, SNDRV_GF1_GB_VERSION_NUMBER);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_VERSION_NUMBER, rev1);\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\nsnd_printdd("[0x%lx] InterWave check - rev1=0x%x, rev2=0x%x\n", gus->gf1.port, rev1, rev2);\r\nif ((rev1 & 0xf0) == (rev2 & 0xf0) &&\r\n(rev1 & 0x0f) != (rev2 & 0x0f)) {\r\nsnd_printdd("[0x%lx] InterWave check - passed\n", gus->gf1.port);\r\ngus->interwave = 1;\r\nstrcpy(gus->card->shortname, "AMD InterWave");\r\ngus->revision = rev1 >> 4;\r\n#ifndef SNDRV_STB\r\nreturn 0;\r\n#else\r\nreturn snd_interwave_detect_stb(iwcard, gus, dev, rbus);\r\n#endif\r\n}\r\nsnd_printdd("[0x%lx] InterWave check - failed\n", gus->gf1.port);\r\nreturn -ENODEV;\r\n}\r\nstatic irqreturn_t snd_interwave_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_interwave *iwcard = dev_id;\r\nint loop, max = 5;\r\nint handled = 0;\r\ndo {\r\nloop = 0;\r\nif (inb(iwcard->gus_status_reg)) {\r\nhandled = 1;\r\nsnd_gus_interrupt(irq, iwcard->gus);\r\nloop++;\r\n}\r\nif (inb(iwcard->pcm_status_reg) & 0x01) {\r\nhandled = 1;\r\nsnd_wss_interrupt(irq, iwcard->wss);\r\nloop++;\r\n}\r\n} while (loop && --max > 0);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void snd_interwave_reset(struct snd_gus_card *gus)\r\n{\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_RESET, 0x00);\r\nudelay(160);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_RESET, 0x01);\r\nudelay(160);\r\n}\r\nstatic void snd_interwave_bank_sizes(struct snd_gus_card *gus, int *sizes)\r\n{\r\nunsigned int idx;\r\nunsigned int local;\r\nunsigned char d;\r\nfor (idx = 0; idx < 4; idx++) {\r\nsizes[idx] = 0;\r\nd = 0x55;\r\nfor (local = idx << 22;\r\nlocal < (idx << 22) + 0x400000;\r\nlocal += 0x40000, d++) {\r\nsnd_gf1_poke(gus, local, d);\r\nsnd_gf1_poke(gus, local + 1, d + 1);\r\n#if 0\r\nprintk(KERN_DEBUG "d = 0x%x, local = 0x%x, "\r\n"local + 1 = 0x%x, idx << 22 = 0x%x\n",\r\nd,\r\nsnd_gf1_peek(gus, local),\r\nsnd_gf1_peek(gus, local + 1),\r\nsnd_gf1_peek(gus, idx << 22));\r\n#endif\r\nif (snd_gf1_peek(gus, local) != d ||\r\nsnd_gf1_peek(gus, local + 1) != d + 1 ||\r\nsnd_gf1_peek(gus, idx << 22) != 0x55)\r\nbreak;\r\nsizes[idx]++;\r\n}\r\n}\r\n#if 0\r\nprintk(KERN_DEBUG "sizes: %i %i %i %i\n",\r\nsizes[0], sizes[1], sizes[2], sizes[3]);\r\n#endif\r\n}\r\nstatic void snd_interwave_detect_memory(struct snd_gus_card *gus)\r\n{\r\nstatic unsigned int lmc[13] =\r\n{\r\n0x00000001, 0x00000101, 0x01010101, 0x00000401,\r\n0x04040401, 0x00040101, 0x04040101, 0x00000004,\r\n0x00000404, 0x04040404, 0x00000010, 0x00001010,\r\n0x10101010\r\n};\r\nint bank_pos, pages;\r\nunsigned int i, lmct;\r\nint psizes[4];\r\nunsigned char iwave[8];\r\nunsigned char csum;\r\nsnd_interwave_reset(gus);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_GLOBAL_MODE, snd_gf1_read8(gus, SNDRV_GF1_GB_GLOBAL_MODE) | 0x01);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x01);\r\nsnd_gf1_write16(gus, SNDRV_GF1_GW_MEMORY_CONFIG, (snd_gf1_look16(gus, SNDRV_GF1_GW_MEMORY_CONFIG) & 0xff10) | 0x004c);\r\npages = 0;\r\nsnd_gf1_poke(gus, 0, 0x55);\r\nsnd_gf1_poke(gus, 1, 0xaa);\r\n#if 1\r\nif (snd_gf1_peek(gus, 0) == 0x55 && snd_gf1_peek(gus, 1) == 0xaa)\r\n#else\r\nif (0)\r\n#endif\r\n{\r\nsnd_interwave_bank_sizes(gus, psizes);\r\nlmct = (psizes[3] << 24) | (psizes[2] << 16) |\r\n(psizes[1] << 8) | psizes[0];\r\n#if 0\r\nprintk(KERN_DEBUG "lmct = 0x%08x\n", lmct);\r\n#endif\r\nfor (i = 0; i < ARRAY_SIZE(lmc); i++)\r\nif (lmct == lmc[i]) {\r\n#if 0\r\nprintk(KERN_DEBUG "found !!! %i\n", i);\r\n#endif\r\nsnd_gf1_write16(gus, SNDRV_GF1_GW_MEMORY_CONFIG, (snd_gf1_look16(gus, SNDRV_GF1_GW_MEMORY_CONFIG) & 0xfff0) | i);\r\nsnd_interwave_bank_sizes(gus, psizes);\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(lmc) && !gus->gf1.enh_mode)\r\nsnd_gf1_write16(gus, SNDRV_GF1_GW_MEMORY_CONFIG, (snd_gf1_look16(gus, SNDRV_GF1_GW_MEMORY_CONFIG) & 0xfff0) | 2);\r\nfor (i = 0; i < 4; i++) {\r\ngus->gf1.mem_alloc.banks_8[i].address =\r\ngus->gf1.mem_alloc.banks_16[i].address = i << 22;\r\ngus->gf1.mem_alloc.banks_8[i].size =\r\ngus->gf1.mem_alloc.banks_16[i].size = psizes[i] << 18;\r\npages += psizes[i];\r\n}\r\n}\r\npages <<= 18;\r\ngus->gf1.memory = pages;\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x03);\r\nsnd_gf1_write16(gus, SNDRV_GF1_GW_MEMORY_CONFIG, (snd_gf1_look16(gus, SNDRV_GF1_GW_MEMORY_CONFIG) & 0xff1f) | (4 << 5));\r\ngus->gf1.rom_banks = 0;\r\ngus->gf1.rom_memory = 0;\r\nfor (bank_pos = 0; bank_pos < 16L * 1024L * 1024L; bank_pos += 4L * 1024L * 1024L) {\r\nfor (i = 0; i < 8; ++i)\r\niwave[i] = snd_gf1_peek(gus, bank_pos + i);\r\nif (strncmp(iwave, "INTRWAVE", 8))\r\ncontinue;\r\ncsum = 0;\r\nfor (i = 0; i < sizeof(struct rom_hdr); i++)\r\ncsum += snd_gf1_peek(gus, bank_pos + i);\r\nif (csum != 0)\r\ncontinue;\r\ngus->gf1.rom_banks++;\r\ngus->gf1.rom_present |= 1 << (bank_pos >> 22);\r\ngus->gf1.rom_memory = snd_gf1_peek(gus, bank_pos + 40) |\r\n(snd_gf1_peek(gus, bank_pos + 41) << 8) |\r\n(snd_gf1_peek(gus, bank_pos + 42) << 16) |\r\n(snd_gf1_peek(gus, bank_pos + 43) << 24);\r\n}\r\n#if 0\r\nif (gus->gf1.rom_memory > 0) {\r\nif (gus->gf1.rom_banks == 1 && gus->gf1.rom_present == 8)\r\ngus->card->type = SNDRV_CARD_TYPE_IW_DYNASONIC;\r\n}\r\n#endif\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x00);\r\nif (!gus->gf1.enh_mode)\r\nsnd_interwave_reset(gus);\r\n}\r\nstatic void snd_interwave_init(int dev, struct snd_gus_card *gus)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_SOUND_BLASTER_CONTROL, 0x00);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_COMPATIBILITY, 0x1f);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_DECODE_CONTROL, 0x49);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_VERSION_NUMBER, 0x11);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_MPU401_CONTROL_A, 0x00);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_MPU401_CONTROL_B, 0x30);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_EMULATION_IRQ, 0x00);\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\ngus->equal_irq = 1;\r\ngus->codec_flag = 1;\r\ngus->interwave = 1;\r\ngus->max_flag = 1;\r\ngus->joystick_dac = joystick_dac[dev];\r\n}\r\nstatic int snd_interwave_mixer(struct snd_wss *chip)\r\n{\r\nstruct snd_card *card = chip->card;\r\nstruct snd_ctl_elem_id id1, id2;\r\nunsigned int idx;\r\nint err;\r\nmemset(&id1, 0, sizeof(id1));\r\nmemset(&id2, 0, sizeof(id2));\r\nid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\n#if 0\r\nstrcpy(id1.name, "Mic Playback Switch");\r\nif ((err = snd_ctl_remove_id(card, &id1)) < 0)\r\nreturn err;\r\nstrcpy(id1.name, "Mic Playback Volume");\r\nif ((err = snd_ctl_remove_id(card, &id1)) < 0)\r\nreturn err;\r\n#endif\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_interwave_controls); idx++)\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_interwave_controls[idx], chip))) < 0)\r\nreturn err;\r\nsnd_wss_out(chip, CS4231_LINE_LEFT_OUTPUT, 0x9f);\r\nsnd_wss_out(chip, CS4231_LINE_RIGHT_OUTPUT, 0x9f);\r\nsnd_wss_out(chip, CS4231_LEFT_MIC_INPUT, 0x9f);\r\nsnd_wss_out(chip, CS4231_RIGHT_MIC_INPUT, 0x9f);\r\nstrcpy(id1.name, "Aux Playback Switch");\r\nstrcpy(id2.name, "Synth Playback Switch");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nstrcpy(id2.name, "Synth Playback Volume");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nstrcpy(id1.name, "Aux Playback Switch"); id1.index = 1;\r\nstrcpy(id2.name, "CD Playback Switch");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nstrcpy(id2.name, "CD Playback Volume");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_interwave_pnp(int dev, struct snd_interwave *iwcard,\r\nstruct pnp_card_link *card,\r\nconst struct pnp_card_device_id *id)\r\n{\r\nstruct pnp_dev *pdev;\r\nint err;\r\niwcard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);\r\nif (iwcard->dev == NULL)\r\nreturn -EBUSY;\r\n#ifdef SNDRV_STB\r\niwcard->devtc = pnp_request_card_device(card, id->devs[1].id, NULL);\r\nif (iwcard->devtc == NULL)\r\nreturn -EBUSY;\r\n#endif\r\npdev = iwcard->dev;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "InterWave PnP configure failure (out of resources?)\n");\r\nreturn err;\r\n}\r\nif (pnp_port_start(pdev, 0) + 0x100 != pnp_port_start(pdev, 1) ||\r\npnp_port_start(pdev, 0) + 0x10c != pnp_port_start(pdev, 2)) {\r\nsnd_printk(KERN_ERR "PnP configure failure (wrong ports)\n");\r\nreturn -ENOENT;\r\n}\r\nport[dev] = pnp_port_start(pdev, 0);\r\ndma1[dev] = pnp_dma(pdev, 0);\r\nif (dma2[dev] >= 0)\r\ndma2[dev] = pnp_dma(pdev, 1);\r\nirq[dev] = pnp_irq(pdev, 0);\r\nsnd_printdd("isapnp IW: sb port=0x%llx, gf1 port=0x%llx, codec port=0x%llx\n",\r\n(unsigned long long)pnp_port_start(pdev, 0),\r\n(unsigned long long)pnp_port_start(pdev, 1),\r\n(unsigned long long)pnp_port_start(pdev, 2));\r\nsnd_printdd("isapnp IW: dma1=%i, dma2=%i, irq=%i\n", dma1[dev], dma2[dev], irq[dev]);\r\n#ifdef SNDRV_STB\r\npdev = iwcard->devtc;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "InterWave ToneControl PnP configure failure (out of resources?)\n");\r\nreturn err;\r\n}\r\nport_tc[dev] = pnp_port_start(pdev, 0);\r\nsnd_printdd("isapnp IW: tone control port=0x%lx\n", port_tc[dev]);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void snd_interwave_free(struct snd_card *card)\r\n{\r\nstruct snd_interwave *iwcard = card->private_data;\r\nif (iwcard == NULL)\r\nreturn;\r\n#ifdef SNDRV_STB\r\nrelease_and_free_resource(iwcard->i2c_res);\r\n#endif\r\nif (iwcard->irq >= 0)\r\nfree_irq(iwcard->irq, (void *)iwcard);\r\n}\r\nstatic int snd_interwave_card_new(struct device *pdev, int dev,\r\nstruct snd_card **cardp)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_interwave *iwcard;\r\nint err;\r\nerr = snd_card_new(pdev, index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_interwave), &card);\r\nif (err < 0)\r\nreturn err;\r\niwcard = card->private_data;\r\niwcard->card = card;\r\niwcard->irq = -1;\r\ncard->private_free = snd_interwave_free;\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int snd_interwave_probe(struct snd_card *card, int dev)\r\n{\r\nint xirq, xdma1, xdma2;\r\nstruct snd_interwave *iwcard = card->private_data;\r\nstruct snd_wss *wss;\r\nstruct snd_gus_card *gus;\r\n#ifdef SNDRV_STB\r\nstruct snd_i2c_bus *i2c_bus;\r\n#endif\r\nstruct snd_pcm *pcm;\r\nchar *str;\r\nint err;\r\nxirq = irq[dev];\r\nxdma1 = dma1[dev];\r\nxdma2 = dma2[dev];\r\nif ((err = snd_gus_create(card,\r\nport[dev],\r\n-xirq, xdma1, xdma2,\r\n0, 32,\r\npcm_channels[dev], effect[dev], &gus)) < 0)\r\nreturn err;\r\nif ((err = snd_interwave_detect(iwcard, gus, dev\r\n#ifdef SNDRV_STB\r\n, &i2c_bus\r\n#endif\r\n)) < 0)\r\nreturn err;\r\niwcard->gus_status_reg = gus->gf1.reg_irqstat;\r\niwcard->pcm_status_reg = gus->gf1.port + 0x10c + 2;\r\nsnd_interwave_init(dev, gus);\r\nsnd_interwave_detect_memory(gus);\r\nif ((err = snd_gus_initialize(gus)) < 0)\r\nreturn err;\r\nif (request_irq(xirq, snd_interwave_interrupt, 0,\r\n"InterWave", iwcard)) {\r\nsnd_printk(KERN_ERR PFX "unable to grab IRQ %d\n", xirq);\r\nreturn -EBUSY;\r\n}\r\niwcard->irq = xirq;\r\nerr = snd_wss_create(card,\r\ngus->gf1.port + 0x10c, -1, xirq,\r\nxdma2 < 0 ? xdma1 : xdma2, xdma1,\r\nWSS_HW_INTERWAVE,\r\nWSS_HWSHARE_IRQ |\r\nWSS_HWSHARE_DMA1 |\r\nWSS_HWSHARE_DMA2,\r\n&wss);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_wss_pcm(wss, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsprintf(pcm->name + strlen(pcm->name), " rev %c", gus->revision + 'A');\r\nstrcat(pcm->name, " (codec)");\r\nerr = snd_wss_timer(wss, 2, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_wss_mixer(wss);\r\nif (err < 0)\r\nreturn err;\r\nif (pcm_channels[dev] > 0) {\r\nerr = snd_gf1_pcm_new(gus, 1, 1, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_interwave_mixer(wss);\r\nif (err < 0)\r\nreturn err;\r\n#ifdef SNDRV_STB\r\n{\r\nstruct snd_ctl_elem_id id1, id2;\r\nmemset(&id1, 0, sizeof(id1));\r\nmemset(&id2, 0, sizeof(id2));\r\nid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(id1.name, "Master Playback Switch");\r\nstrcpy(id2.name, id1.name);\r\nid2.index = 1;\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nstrcpy(id1.name, "Master Playback Volume");\r\nstrcpy(id2.name, id1.name);\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nif ((err = snd_tea6330t_update_mixer(card, i2c_bus, 0, 1)) < 0)\r\nreturn err;\r\n}\r\n#endif\r\ngus->uart_enable = midi[dev];\r\nif ((err = snd_gf1_rawmidi_new(gus, 0, NULL)) < 0)\r\nreturn err;\r\n#ifndef SNDRV_STB\r\nstr = "AMD InterWave";\r\nif (gus->gf1.rom_banks == 1 && gus->gf1.rom_present == 8)\r\nstr = "Dynasonic 3-D";\r\n#else\r\nstr = "InterWave STB";\r\n#endif\r\nstrcpy(card->driver, str);\r\nstrcpy(card->shortname, str);\r\nsprintf(card->longname, "%s at 0x%lx, irq %i, dma %d",\r\nstr,\r\ngus->gf1.port,\r\nxirq,\r\nxdma1);\r\nif (xdma2 >= 0)\r\nsprintf(card->longname + strlen(card->longname), "&%d", xdma2);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\nreturn err;\r\niwcard->wss = wss;\r\niwcard->gus = gus;\r\nreturn 0;\r\n}\r\nstatic int snd_interwave_isa_probe1(int dev, struct device *devptr)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_interwave_card_new(devptr, dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_interwave_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ndev_set_drvdata(devptr, card);\r\nreturn 0;\r\n}\r\nstatic int snd_interwave_isa_match(struct device *pdev,\r\nunsigned int dev)\r\n{\r\nif (!enable[dev])\r\nreturn 0;\r\n#ifdef CONFIG_PNP\r\nif (isapnp[dev])\r\nreturn 0;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int snd_interwave_isa_probe(struct device *pdev,\r\nunsigned int dev)\r\n{\r\nint err;\r\nstatic int possible_irqs[] = {5, 11, 12, 9, 7, 15, 3, -1};\r\nstatic int possible_dmas[] = {0, 1, 3, 5, 6, 7, -1};\r\nif (irq[dev] == SNDRV_AUTO_IRQ) {\r\nif ((irq[dev] = snd_legacy_find_free_irq(possible_irqs)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma1[dev] == SNDRV_AUTO_DMA) {\r\nif ((dma1[dev] = snd_legacy_find_free_dma(possible_dmas)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free DMA1\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma2[dev] == SNDRV_AUTO_DMA) {\r\nif ((dma2[dev] = snd_legacy_find_free_dma(possible_dmas)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free DMA2\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (port[dev] != SNDRV_AUTO_PORT)\r\nreturn snd_interwave_isa_probe1(dev, pdev);\r\nelse {\r\nstatic long possible_ports[] = {0x210, 0x220, 0x230, 0x240, 0x250, 0x260};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\r\nport[dev] = possible_ports[i];\r\nerr = snd_interwave_isa_probe1(dev, pdev);\r\nif (! err)\r\nreturn 0;\r\n}\r\nreturn err;\r\n}\r\n}\r\nstatic int snd_interwave_isa_remove(struct device *devptr, unsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\nreturn 0;\r\n}\r\nstatic int snd_interwave_pnp_detect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nint res;\r\nfor ( ; dev < SNDRV_CARDS; dev++) {\r\nif (enable[dev] && isapnp[dev])\r\nbreak;\r\n}\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nres = snd_interwave_card_new(&pcard->card->dev, dev, &card);\r\nif (res < 0)\r\nreturn res;\r\nif ((res = snd_interwave_pnp(dev, card->private_data, pcard, pid)) < 0) {\r\nsnd_card_free(card);\r\nreturn res;\r\n}\r\nif ((res = snd_interwave_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn res;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_interwave_pnp_remove(struct pnp_card_link *pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int __init alsa_card_interwave_init(void)\r\n{\r\nint err;\r\nerr = isa_register_driver(&snd_interwave_driver, SNDRV_CARDS);\r\n#ifdef CONFIG_PNP\r\nif (!err)\r\nisa_registered = 1;\r\nerr = pnp_register_card_driver(&interwave_pnpc_driver);\r\nif (!err)\r\npnp_registered = 1;\r\nif (isa_registered)\r\nerr = 0;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit alsa_card_interwave_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\npnp_unregister_card_driver(&interwave_pnpc_driver);\r\nif (isa_registered)\r\n#endif\r\nisa_unregister_driver(&snd_interwave_driver);\r\n}
