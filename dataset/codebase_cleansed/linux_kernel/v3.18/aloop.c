static inline unsigned int byte_pos(struct loopback_pcm *dpcm, unsigned int x)\r\n{\r\nif (dpcm->pcm_rate_shift == NO_PITCH) {\r\nx /= HZ;\r\n} else {\r\nx = div_u64(NO_PITCH * (unsigned long long)x,\r\nHZ * (unsigned long long)dpcm->pcm_rate_shift);\r\n}\r\nreturn x - (x % dpcm->pcm_salign);\r\n}\r\nstatic inline unsigned int frac_pos(struct loopback_pcm *dpcm, unsigned int x)\r\n{\r\nif (dpcm->pcm_rate_shift == NO_PITCH) {\r\nreturn x * HZ;\r\n} else {\r\nx = div_u64(dpcm->pcm_rate_shift * (unsigned long long)x * HZ,\r\nNO_PITCH);\r\n}\r\nreturn x;\r\n}\r\nstatic inline struct loopback_setup *get_setup(struct loopback_pcm *dpcm)\r\n{\r\nint device = dpcm->substream->pstr->pcm->device;\r\nif (dpcm->substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndevice ^= 1;\r\nreturn &dpcm->loopback->setup[dpcm->substream->number][device];\r\n}\r\nstatic inline unsigned int get_notify(struct loopback_pcm *dpcm)\r\n{\r\nreturn get_setup(dpcm)->notify;\r\n}\r\nstatic inline unsigned int get_rate_shift(struct loopback_pcm *dpcm)\r\n{\r\nreturn get_setup(dpcm)->rate_shift;\r\n}\r\nstatic void loopback_timer_start(struct loopback_pcm *dpcm)\r\n{\r\nunsigned long tick;\r\nunsigned int rate_shift = get_rate_shift(dpcm);\r\nif (rate_shift != dpcm->pcm_rate_shift) {\r\ndpcm->pcm_rate_shift = rate_shift;\r\ndpcm->period_size_frac = frac_pos(dpcm, dpcm->pcm_period_size);\r\n}\r\nif (dpcm->period_size_frac <= dpcm->irq_pos) {\r\ndpcm->irq_pos %= dpcm->period_size_frac;\r\ndpcm->period_update_pending = 1;\r\n}\r\ntick = dpcm->period_size_frac - dpcm->irq_pos;\r\ntick = (tick + dpcm->pcm_bps - 1) / dpcm->pcm_bps;\r\ndpcm->timer.expires = jiffies + tick;\r\nadd_timer(&dpcm->timer);\r\n}\r\nstatic inline void loopback_timer_stop(struct loopback_pcm *dpcm)\r\n{\r\ndel_timer(&dpcm->timer);\r\ndpcm->timer.expires = 0;\r\n}\r\nstatic int loopback_check_format(struct loopback_cable *cable, int stream)\r\n{\r\nstruct snd_pcm_runtime *runtime, *cruntime;\r\nstruct loopback_setup *setup;\r\nstruct snd_card *card;\r\nint check;\r\nif (cable->valid != CABLE_VALID_BOTH) {\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ngoto __notify;\r\nreturn 0;\r\n}\r\nruntime = cable->streams[SNDRV_PCM_STREAM_PLAYBACK]->\r\nsubstream->runtime;\r\ncruntime = cable->streams[SNDRV_PCM_STREAM_CAPTURE]->\r\nsubstream->runtime;\r\ncheck = runtime->format != cruntime->format ||\r\nruntime->rate != cruntime->rate ||\r\nruntime->channels != cruntime->channels;\r\nif (!check)\r\nreturn 0;\r\nif (stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nreturn -EIO;\r\n} else {\r\nsnd_pcm_stop(cable->streams[SNDRV_PCM_STREAM_CAPTURE]->\r\nsubstream, SNDRV_PCM_STATE_DRAINING);\r\n__notify:\r\nruntime = cable->streams[SNDRV_PCM_STREAM_PLAYBACK]->\r\nsubstream->runtime;\r\nsetup = get_setup(cable->streams[SNDRV_PCM_STREAM_PLAYBACK]);\r\ncard = cable->streams[SNDRV_PCM_STREAM_PLAYBACK]->loopback->card;\r\nif (setup->format != runtime->format) {\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&setup->format_id);\r\nsetup->format = runtime->format;\r\n}\r\nif (setup->rate != runtime->rate) {\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&setup->rate_id);\r\nsetup->rate = runtime->rate;\r\n}\r\nif (setup->channels != runtime->channels) {\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&setup->channels_id);\r\nsetup->channels = runtime->channels;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void loopback_active_notify(struct loopback_pcm *dpcm)\r\n{\r\nsnd_ctl_notify(dpcm->loopback->card,\r\nSNDRV_CTL_EVENT_MASK_VALUE,\r\n&get_setup(dpcm)->active_id);\r\n}\r\nstatic int loopback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct loopback_pcm *dpcm = runtime->private_data;\r\nstruct loopback_cable *cable = dpcm->cable;\r\nint err, stream = 1 << substream->stream;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nerr = loopback_check_format(cable, substream->stream);\r\nif (err < 0)\r\nreturn err;\r\ndpcm->last_jiffies = jiffies;\r\ndpcm->pcm_rate_shift = 0;\r\ndpcm->last_drift = 0;\r\nspin_lock(&cable->lock);\r\ncable->running |= stream;\r\ncable->pause &= ~stream;\r\nloopback_timer_start(dpcm);\r\nspin_unlock(&cable->lock);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nloopback_active_notify(dpcm);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nspin_lock(&cable->lock);\r\ncable->running &= ~stream;\r\ncable->pause &= ~stream;\r\nloopback_timer_stop(dpcm);\r\nspin_unlock(&cable->lock);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nloopback_active_notify(dpcm);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nspin_lock(&cable->lock);\r\ncable->pause |= stream;\r\nloopback_timer_stop(dpcm);\r\nspin_unlock(&cable->lock);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nspin_lock(&cable->lock);\r\ndpcm->last_jiffies = jiffies;\r\ncable->pause &= ~stream;\r\nloopback_timer_start(dpcm);\r\nspin_unlock(&cable->lock);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void params_change_substream(struct loopback_pcm *dpcm,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nstruct snd_pcm_runtime *dst_runtime;\r\nif (dpcm == NULL || dpcm->substream == NULL)\r\nreturn;\r\ndst_runtime = dpcm->substream->runtime;\r\nif (dst_runtime == NULL)\r\nreturn;\r\ndst_runtime->hw = dpcm->cable->hw;\r\n}\r\nstatic void params_change(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct loopback_pcm *dpcm = runtime->private_data;\r\nstruct loopback_cable *cable = dpcm->cable;\r\ncable->hw.formats = pcm_format_to_bits(runtime->format);\r\ncable->hw.rate_min = runtime->rate;\r\ncable->hw.rate_max = runtime->rate;\r\ncable->hw.channels_min = runtime->channels;\r\ncable->hw.channels_max = runtime->channels;\r\nparams_change_substream(cable->streams[SNDRV_PCM_STREAM_PLAYBACK],\r\nruntime);\r\nparams_change_substream(cable->streams[SNDRV_PCM_STREAM_CAPTURE],\r\nruntime);\r\n}\r\nstatic int loopback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct loopback_pcm *dpcm = runtime->private_data;\r\nstruct loopback_cable *cable = dpcm->cable;\r\nint bps, salign;\r\nsalign = (snd_pcm_format_width(runtime->format) *\r\nruntime->channels) / 8;\r\nbps = salign * runtime->rate;\r\nif (bps <= 0 || salign <= 0)\r\nreturn -EINVAL;\r\ndpcm->buf_pos = 0;\r\ndpcm->pcm_buffer_size = frames_to_bytes(runtime, runtime->buffer_size);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\ndpcm->silent_size = dpcm->pcm_buffer_size;\r\nsnd_pcm_format_set_silence(runtime->format, runtime->dma_area,\r\nruntime->buffer_size * runtime->channels);\r\n}\r\ndpcm->irq_pos = 0;\r\ndpcm->period_update_pending = 0;\r\ndpcm->pcm_bps = bps;\r\ndpcm->pcm_salign = salign;\r\ndpcm->pcm_period_size = frames_to_bytes(runtime, runtime->period_size);\r\nmutex_lock(&dpcm->loopback->cable_lock);\r\nif (!(cable->valid & ~(1 << substream->stream)) ||\r\n(get_setup(dpcm)->notify &&\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK))\r\nparams_change(substream);\r\ncable->valid |= 1 << substream->stream;\r\nmutex_unlock(&dpcm->loopback->cable_lock);\r\nreturn 0;\r\n}\r\nstatic void clear_capture_buf(struct loopback_pcm *dpcm, unsigned int bytes)\r\n{\r\nstruct snd_pcm_runtime *runtime = dpcm->substream->runtime;\r\nchar *dst = runtime->dma_area;\r\nunsigned int dst_off = dpcm->buf_pos;\r\nif (dpcm->silent_size >= dpcm->pcm_buffer_size)\r\nreturn;\r\nif (dpcm->silent_size + bytes > dpcm->pcm_buffer_size)\r\nbytes = dpcm->pcm_buffer_size - dpcm->silent_size;\r\nfor (;;) {\r\nunsigned int size = bytes;\r\nif (dst_off + size > dpcm->pcm_buffer_size)\r\nsize = dpcm->pcm_buffer_size - dst_off;\r\nsnd_pcm_format_set_silence(runtime->format, dst + dst_off,\r\nbytes_to_frames(runtime, size) *\r\nruntime->channels);\r\ndpcm->silent_size += size;\r\nbytes -= size;\r\nif (!bytes)\r\nbreak;\r\ndst_off = 0;\r\n}\r\n}\r\nstatic void copy_play_buf(struct loopback_pcm *play,\r\nstruct loopback_pcm *capt,\r\nunsigned int bytes)\r\n{\r\nstruct snd_pcm_runtime *runtime = play->substream->runtime;\r\nchar *src = runtime->dma_area;\r\nchar *dst = capt->substream->runtime->dma_area;\r\nunsigned int src_off = play->buf_pos;\r\nunsigned int dst_off = capt->buf_pos;\r\nunsigned int clear_bytes = 0;\r\nif (runtime->status->state == SNDRV_PCM_STATE_DRAINING &&\r\nsnd_pcm_playback_hw_avail(runtime) < runtime->buffer_size) {\r\nsnd_pcm_uframes_t appl_ptr, appl_ptr1, diff;\r\nappl_ptr = appl_ptr1 = runtime->control->appl_ptr;\r\nappl_ptr1 -= appl_ptr1 % runtime->buffer_size;\r\nappl_ptr1 += play->buf_pos / play->pcm_salign;\r\nif (appl_ptr < appl_ptr1)\r\nappl_ptr1 -= runtime->buffer_size;\r\ndiff = (appl_ptr - appl_ptr1) * play->pcm_salign;\r\nif (diff < bytes) {\r\nclear_bytes = bytes - diff;\r\nbytes = diff;\r\n}\r\n}\r\nfor (;;) {\r\nunsigned int size = bytes;\r\nif (src_off + size > play->pcm_buffer_size)\r\nsize = play->pcm_buffer_size - src_off;\r\nif (dst_off + size > capt->pcm_buffer_size)\r\nsize = capt->pcm_buffer_size - dst_off;\r\nmemcpy(dst + dst_off, src + src_off, size);\r\ncapt->silent_size = 0;\r\nbytes -= size;\r\nif (!bytes)\r\nbreak;\r\nsrc_off = (src_off + size) % play->pcm_buffer_size;\r\ndst_off = (dst_off + size) % capt->pcm_buffer_size;\r\n}\r\nif (clear_bytes > 0) {\r\nclear_capture_buf(capt, clear_bytes);\r\ncapt->silent_size = 0;\r\n}\r\n}\r\nstatic inline unsigned int bytepos_delta(struct loopback_pcm *dpcm,\r\nunsigned int jiffies_delta)\r\n{\r\nunsigned long last_pos;\r\nunsigned int delta;\r\nlast_pos = byte_pos(dpcm, dpcm->irq_pos);\r\ndpcm->irq_pos += jiffies_delta * dpcm->pcm_bps;\r\ndelta = byte_pos(dpcm, dpcm->irq_pos) - last_pos;\r\nif (delta >= dpcm->last_drift)\r\ndelta -= dpcm->last_drift;\r\ndpcm->last_drift = 0;\r\nif (dpcm->irq_pos >= dpcm->period_size_frac) {\r\ndpcm->irq_pos %= dpcm->period_size_frac;\r\ndpcm->period_update_pending = 1;\r\n}\r\nreturn delta;\r\n}\r\nstatic inline void bytepos_finish(struct loopback_pcm *dpcm,\r\nunsigned int delta)\r\n{\r\ndpcm->buf_pos += delta;\r\ndpcm->buf_pos %= dpcm->pcm_buffer_size;\r\n}\r\nstatic unsigned int loopback_pos_update(struct loopback_cable *cable)\r\n{\r\nstruct loopback_pcm *dpcm_play =\r\ncable->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nstruct loopback_pcm *dpcm_capt =\r\ncable->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nunsigned long delta_play = 0, delta_capt = 0;\r\nunsigned int running, count1, count2;\r\nrunning = cable->running ^ cable->pause;\r\nif (running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) {\r\ndelta_play = jiffies - dpcm_play->last_jiffies;\r\ndpcm_play->last_jiffies += delta_play;\r\n}\r\nif (running & (1 << SNDRV_PCM_STREAM_CAPTURE)) {\r\ndelta_capt = jiffies - dpcm_capt->last_jiffies;\r\ndpcm_capt->last_jiffies += delta_capt;\r\n}\r\nif (delta_play == 0 && delta_capt == 0)\r\ngoto unlock;\r\nif (delta_play > delta_capt) {\r\ncount1 = bytepos_delta(dpcm_play, delta_play - delta_capt);\r\nbytepos_finish(dpcm_play, count1);\r\ndelta_play = delta_capt;\r\n} else if (delta_play < delta_capt) {\r\ncount1 = bytepos_delta(dpcm_capt, delta_capt - delta_play);\r\nclear_capture_buf(dpcm_capt, count1);\r\nbytepos_finish(dpcm_capt, count1);\r\ndelta_capt = delta_play;\r\n}\r\nif (delta_play == 0 && delta_capt == 0)\r\ngoto unlock;\r\ncount1 = bytepos_delta(dpcm_play, delta_play);\r\ncount2 = bytepos_delta(dpcm_capt, delta_capt);\r\nif (count1 < count2) {\r\ndpcm_capt->last_drift = count2 - count1;\r\ncount1 = count2;\r\n} else if (count1 > count2) {\r\ndpcm_play->last_drift = count1 - count2;\r\n}\r\ncopy_play_buf(dpcm_play, dpcm_capt, count1);\r\nbytepos_finish(dpcm_play, count1);\r\nbytepos_finish(dpcm_capt, count1);\r\nunlock:\r\nreturn running;\r\n}\r\nstatic void loopback_timer_function(unsigned long data)\r\n{\r\nstruct loopback_pcm *dpcm = (struct loopback_pcm *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dpcm->cable->lock, flags);\r\nif (loopback_pos_update(dpcm->cable) & (1 << dpcm->substream->stream)) {\r\nloopback_timer_start(dpcm);\r\nif (dpcm->period_update_pending) {\r\ndpcm->period_update_pending = 0;\r\nspin_unlock_irqrestore(&dpcm->cable->lock, flags);\r\nsnd_pcm_period_elapsed(dpcm->substream);\r\nreturn;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dpcm->cable->lock, flags);\r\n}\r\nstatic snd_pcm_uframes_t loopback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct loopback_pcm *dpcm = runtime->private_data;\r\nsnd_pcm_uframes_t pos;\r\nspin_lock(&dpcm->cable->lock);\r\nloopback_pos_update(dpcm->cable);\r\npos = dpcm->buf_pos;\r\nspin_unlock(&dpcm->cable->lock);\r\nreturn bytes_to_frames(runtime, pos);\r\n}\r\nstatic void loopback_runtime_free(struct snd_pcm_runtime *runtime)\r\n{\r\nstruct loopback_pcm *dpcm = runtime->private_data;\r\nkfree(dpcm);\r\n}\r\nstatic int loopback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(params));\r\n}\r\nstatic int loopback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct loopback_pcm *dpcm = runtime->private_data;\r\nstruct loopback_cable *cable = dpcm->cable;\r\nmutex_lock(&dpcm->loopback->cable_lock);\r\ncable->valid &= ~(1 << substream->stream);\r\nmutex_unlock(&dpcm->loopback->cable_lock);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic unsigned int get_cable_index(struct snd_pcm_substream *substream)\r\n{\r\nif (!substream->pcm->device)\r\nreturn substream->stream;\r\nelse\r\nreturn !substream->stream;\r\n}\r\nstatic int rule_format(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_hardware *hw = rule->private;\r\nstruct snd_mask *maskp = hw_param_mask(params, rule->var);\r\nmaskp->bits[0] &= (u_int32_t)hw->formats;\r\nmaskp->bits[1] &= (u_int32_t)(hw->formats >> 32);\r\nmemset(maskp->bits + 2, 0, (SNDRV_MASK_MAX-64) / 8);\r\nif (! maskp->bits[0] && ! maskp->bits[1])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rule_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_hardware *hw = rule->private;\r\nstruct snd_interval t;\r\nt.min = hw->rate_min;\r\nt.max = hw->rate_max;\r\nt.openmin = t.openmax = 0;\r\nt.integer = 0;\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nstatic int rule_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_hardware *hw = rule->private;\r\nstruct snd_interval t;\r\nt.min = hw->channels_min;\r\nt.max = hw->channels_max;\r\nt.openmin = t.openmax = 0;\r\nt.integer = 0;\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nstatic int loopback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct loopback *loopback = substream->private_data;\r\nstruct loopback_pcm *dpcm;\r\nstruct loopback_cable *cable;\r\nint err = 0;\r\nint dev = get_cable_index(substream);\r\nmutex_lock(&loopback->cable_lock);\r\ndpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\r\nif (!dpcm) {\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\ndpcm->loopback = loopback;\r\ndpcm->substream = substream;\r\nsetup_timer(&dpcm->timer, loopback_timer_function,\r\n(unsigned long)dpcm);\r\ncable = loopback->cables[substream->number][dev];\r\nif (!cable) {\r\ncable = kzalloc(sizeof(*cable), GFP_KERNEL);\r\nif (!cable) {\r\nkfree(dpcm);\r\nerr = -ENOMEM;\r\ngoto unlock;\r\n}\r\nspin_lock_init(&cable->lock);\r\ncable->hw = loopback_pcm_hardware;\r\nloopback->cables[substream->number][dev] = cable;\r\n}\r\ndpcm->cable = cable;\r\ncable->streams[substream->stream] = dpcm;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nerr = snd_pcm_hw_rule_add(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nrule_format, &runtime->hw,\r\nSNDRV_PCM_HW_PARAM_FORMAT, -1);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = snd_pcm_hw_rule_add(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nrule_rate, &runtime->hw,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\ngoto unlock;\r\nerr = snd_pcm_hw_rule_add(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nrule_channels, &runtime->hw,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\ngoto unlock;\r\nruntime->private_data = dpcm;\r\nruntime->private_free = loopback_runtime_free;\r\nif (get_notify(dpcm))\r\nruntime->hw = loopback_pcm_hardware;\r\nelse\r\nruntime->hw = cable->hw;\r\nunlock:\r\nmutex_unlock(&loopback->cable_lock);\r\nreturn err;\r\n}\r\nstatic int loopback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct loopback *loopback = substream->private_data;\r\nstruct loopback_pcm *dpcm = substream->runtime->private_data;\r\nstruct loopback_cable *cable;\r\nint dev = get_cable_index(substream);\r\nloopback_timer_stop(dpcm);\r\nmutex_lock(&loopback->cable_lock);\r\ncable = loopback->cables[substream->number][dev];\r\nif (cable->streams[!substream->stream]) {\r\ncable->streams[substream->stream] = NULL;\r\n} else {\r\nloopback->cables[substream->number][dev] = NULL;\r\nkfree(cable);\r\n}\r\nmutex_unlock(&loopback->cable_lock);\r\nreturn 0;\r\n}\r\nstatic int loopback_pcm_new(struct loopback *loopback,\r\nint device, int substreams)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(loopback->card, "Loopback PCM", device,\r\nsubstreams, substreams, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &loopback_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &loopback_capture_ops);\r\npcm->private_data = loopback;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "Loopback PCM");\r\nloopback->pcm[device] = pcm;\r\nreturn 0;\r\n}\r\nstatic int loopback_rate_shift_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 80000;\r\nuinfo->value.integer.max = 120000;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int loopback_rate_shift_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\nloopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].rate_shift;\r\nreturn 0;\r\n}\r\nstatic int loopback_rate_shift_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change = 0;\r\nval = ucontrol->value.integer.value[0];\r\nif (val < 80000)\r\nval = 80000;\r\nif (val > 120000)\r\nval = 120000;\r\nmutex_lock(&loopback->cable_lock);\r\nif (val != loopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].rate_shift) {\r\nloopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].rate_shift = val;\r\nchange = 1;\r\n}\r\nmutex_unlock(&loopback->cable_lock);\r\nreturn change;\r\n}\r\nstatic int loopback_notify_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\nloopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].notify;\r\nreturn 0;\r\n}\r\nstatic int loopback_notify_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change = 0;\r\nval = ucontrol->value.integer.value[0] ? 1 : 0;\r\nif (val != loopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].notify) {\r\nloopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].notify = val;\r\nchange = 1;\r\n}\r\nreturn change;\r\n}\r\nstatic int loopback_active_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\r\nstruct loopback_cable *cable = loopback->cables\r\n[kcontrol->id.subdevice][kcontrol->id.device ^ 1];\r\nunsigned int val = 0;\r\nif (cable != NULL)\r\nval = (cable->running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) ?\r\n1 : 0;\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int loopback_format_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = SNDRV_PCM_FORMAT_LAST;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int loopback_format_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\nloopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].format;\r\nreturn 0;\r\n}\r\nstatic int loopback_rate_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 192000;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int loopback_rate_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\nloopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].rate;\r\nreturn 0;\r\n}\r\nstatic int loopback_channels_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 1;\r\nuinfo->value.integer.max = 1024;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int loopback_channels_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct loopback *loopback = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\nloopback->setup[kcontrol->id.subdevice]\r\n[kcontrol->id.device].channels;\r\nreturn 0;\r\n}\r\nstatic int loopback_mixer_new(struct loopback *loopback, int notify)\r\n{\r\nstruct snd_card *card = loopback->card;\r\nstruct snd_pcm *pcm;\r\nstruct snd_kcontrol *kctl;\r\nstruct loopback_setup *setup;\r\nint err, dev, substr, substr_count, idx;\r\nstrcpy(card->mixername, "Loopback Mixer");\r\nfor (dev = 0; dev < 2; dev++) {\r\npcm = loopback->pcm[dev];\r\nsubstr_count =\r\npcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream_count;\r\nfor (substr = 0; substr < substr_count; substr++) {\r\nsetup = &loopback->setup[substr][dev];\r\nsetup->notify = notify;\r\nsetup->rate_shift = NO_PITCH;\r\nsetup->format = SNDRV_PCM_FORMAT_S16_LE;\r\nsetup->rate = 48000;\r\nsetup->channels = 2;\r\nfor (idx = 0; idx < ARRAY_SIZE(loopback_controls);\r\nidx++) {\r\nkctl = snd_ctl_new1(&loopback_controls[idx],\r\nloopback);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->id.device = dev;\r\nkctl->id.subdevice = substr;\r\nswitch (idx) {\r\ncase ACTIVE_IDX:\r\nsetup->active_id = kctl->id;\r\nbreak;\r\ncase FORMAT_IDX:\r\nsetup->format_id = kctl->id;\r\nbreak;\r\ncase RATE_IDX:\r\nsetup->rate_id = kctl->id;\r\nbreak;\r\ncase CHANNELS_IDX:\r\nsetup->channels_id = kctl->id;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr = snd_ctl_add(card, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void print_dpcm_info(struct snd_info_buffer *buffer,\r\nstruct loopback_pcm *dpcm,\r\nconst char *id)\r\n{\r\nsnd_iprintf(buffer, " %s\n", id);\r\nif (dpcm == NULL) {\r\nsnd_iprintf(buffer, " inactive\n");\r\nreturn;\r\n}\r\nsnd_iprintf(buffer, " buffer_size:\t%u\n", dpcm->pcm_buffer_size);\r\nsnd_iprintf(buffer, " buffer_pos:\t\t%u\n", dpcm->buf_pos);\r\nsnd_iprintf(buffer, " silent_size:\t%u\n", dpcm->silent_size);\r\nsnd_iprintf(buffer, " period_size:\t%u\n", dpcm->pcm_period_size);\r\nsnd_iprintf(buffer, " bytes_per_sec:\t%u\n", dpcm->pcm_bps);\r\nsnd_iprintf(buffer, " sample_align:\t%u\n", dpcm->pcm_salign);\r\nsnd_iprintf(buffer, " rate_shift:\t\t%u\n", dpcm->pcm_rate_shift);\r\nsnd_iprintf(buffer, " update_pending:\t%u\n",\r\ndpcm->period_update_pending);\r\nsnd_iprintf(buffer, " irq_pos:\t\t%u\n", dpcm->irq_pos);\r\nsnd_iprintf(buffer, " period_frac:\t%u\n", dpcm->period_size_frac);\r\nsnd_iprintf(buffer, " last_jiffies:\t%lu (%lu)\n",\r\ndpcm->last_jiffies, jiffies);\r\nsnd_iprintf(buffer, " timer_expires:\t%lu\n", dpcm->timer.expires);\r\n}\r\nstatic void print_substream_info(struct snd_info_buffer *buffer,\r\nstruct loopback *loopback,\r\nint sub,\r\nint num)\r\n{\r\nstruct loopback_cable *cable = loopback->cables[sub][num];\r\nsnd_iprintf(buffer, "Cable %i substream %i:\n", num, sub);\r\nif (cable == NULL) {\r\nsnd_iprintf(buffer, " inactive\n");\r\nreturn;\r\n}\r\nsnd_iprintf(buffer, " valid: %u\n", cable->valid);\r\nsnd_iprintf(buffer, " running: %u\n", cable->running);\r\nsnd_iprintf(buffer, " pause: %u\n", cable->pause);\r\nprint_dpcm_info(buffer, cable->streams[0], "Playback");\r\nprint_dpcm_info(buffer, cable->streams[1], "Capture");\r\n}\r\nstatic void print_cable_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct loopback *loopback = entry->private_data;\r\nint sub, num;\r\nmutex_lock(&loopback->cable_lock);\r\nnum = entry->name[strlen(entry->name)-1];\r\nnum = num == '0' ? 0 : 1;\r\nfor (sub = 0; sub < MAX_PCM_SUBSTREAMS; sub++)\r\nprint_substream_info(buffer, loopback, sub, num);\r\nmutex_unlock(&loopback->cable_lock);\r\n}\r\nstatic int loopback_proc_new(struct loopback *loopback, int cidx)\r\n{\r\nchar name[32];\r\nstruct snd_info_entry *entry;\r\nint err;\r\nsnprintf(name, sizeof(name), "cable#%d", cidx);\r\nerr = snd_card_proc_new(loopback->card, name, &entry);\r\nif (err < 0)\r\nreturn err;\r\nsnd_info_set_text_ops(entry, loopback, print_cable_info);\r\nreturn 0;\r\n}\r\nstatic int loopback_probe(struct platform_device *devptr)\r\n{\r\nstruct snd_card *card;\r\nstruct loopback *loopback;\r\nint dev = devptr->id;\r\nint err;\r\nerr = snd_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct loopback), &card);\r\nif (err < 0)\r\nreturn err;\r\nloopback = card->private_data;\r\nif (pcm_substreams[dev] < 1)\r\npcm_substreams[dev] = 1;\r\nif (pcm_substreams[dev] > MAX_PCM_SUBSTREAMS)\r\npcm_substreams[dev] = MAX_PCM_SUBSTREAMS;\r\nloopback->card = card;\r\nmutex_init(&loopback->cable_lock);\r\nerr = loopback_pcm_new(loopback, 0, pcm_substreams[dev]);\r\nif (err < 0)\r\ngoto __nodev;\r\nerr = loopback_pcm_new(loopback, 1, pcm_substreams[dev]);\r\nif (err < 0)\r\ngoto __nodev;\r\nerr = loopback_mixer_new(loopback, pcm_notify[dev] ? 1 : 0);\r\nif (err < 0)\r\ngoto __nodev;\r\nloopback_proc_new(loopback, 0);\r\nloopback_proc_new(loopback, 1);\r\nstrcpy(card->driver, "Loopback");\r\nstrcpy(card->shortname, "Loopback");\r\nsprintf(card->longname, "Loopback %i", dev + 1);\r\nerr = snd_card_register(card);\r\nif (!err) {\r\nplatform_set_drvdata(devptr, card);\r\nreturn 0;\r\n}\r\n__nodev:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int loopback_remove(struct platform_device *devptr)\r\n{\r\nsnd_card_free(platform_get_drvdata(devptr));\r\nreturn 0;\r\n}\r\nstatic int loopback_suspend(struct device *pdev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct loopback *loopback = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(loopback->pcm[0]);\r\nsnd_pcm_suspend_all(loopback->pcm[1]);\r\nreturn 0;\r\n}\r\nstatic int loopback_resume(struct device *pdev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic void loopback_unregister_all(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(devices); ++i)\r\nplatform_device_unregister(devices[i]);\r\nplatform_driver_unregister(&loopback_driver);\r\n}\r\nstatic int __init alsa_card_loopback_init(void)\r\n{\r\nint i, err, cards;\r\nerr = platform_driver_register(&loopback_driver);\r\nif (err < 0)\r\nreturn err;\r\ncards = 0;\r\nfor (i = 0; i < SNDRV_CARDS; i++) {\r\nstruct platform_device *device;\r\nif (!enable[i])\r\ncontinue;\r\ndevice = platform_device_register_simple(SND_LOOPBACK_DRIVER,\r\ni, NULL, 0);\r\nif (IS_ERR(device))\r\ncontinue;\r\nif (!platform_get_drvdata(device)) {\r\nplatform_device_unregister(device);\r\ncontinue;\r\n}\r\ndevices[i] = device;\r\ncards++;\r\n}\r\nif (!cards) {\r\n#ifdef MODULE\r\nprintk(KERN_ERR "aloop: No loopback enabled\n");\r\n#endif\r\nloopback_unregister_all();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_card_loopback_exit(void)\r\n{\r\nloopback_unregister_all();\r\n}
