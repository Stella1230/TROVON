static int send_control_msg(struct usb_device *udev, u8 request, u16 value,\r\nu16 index, unsigned char *cp, u16 size)\r\n{\r\nint status;\r\nunsigned char *transfer_buffer = kmalloc(size, GFP_KERNEL);\r\nif (!transfer_buffer) {\r\ndev_err(&udev->dev, "kmalloc(%d) failed\n", size);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(transfer_buffer, cp, size);\r\nstatus = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nrequest,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, value, index,\r\ntransfer_buffer, size, CTRL_TIMEOUT);\r\nkfree(transfer_buffer);\r\nreturn status;\r\n}\r\nstatic int buffer_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct zr364xx_camera *cam = vq->priv_data;\r\n*size = cam->width * cam->height * (cam->fmt->depth >> 3);\r\nif (*count == 0)\r\n*count = ZR364XX_DEF_BUFS;\r\nif (*size * *count > ZR364XX_DEF_BUFS * 1024 * 1024)\r\n*count = (ZR364XX_DEF_BUFS * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct zr364xx_buffer *buf)\r\n{\r\n_DBG("%s\n", __func__);\r\nif (in_interrupt())\r\nBUG();\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct zr364xx_camera *cam = vq->priv_data;\r\nstruct zr364xx_buffer *buf = container_of(vb, struct zr364xx_buffer,\r\nvb);\r\nint rc;\r\nDBG("%s, field=%d, fmt name = %s\n", __func__, field, cam->fmt != NULL ?\r\ncam->fmt->name : "");\r\nif (cam->fmt == NULL)\r\nreturn -EINVAL;\r\nbuf->vb.size = cam->width * cam->height * (cam->fmt->depth >> 3);\r\nif (buf->vb.baddr != 0 && buf->vb.bsize < buf->vb.size) {\r\nDBG("invalid buffer prepare\n");\r\nreturn -EINVAL;\r\n}\r\nbuf->fmt = cam->fmt;\r\nbuf->vb.width = cam->width;\r\nbuf->vb.height = cam->height;\r\nbuf->vb.field = field;\r\nif (buf->vb.state == VIDEOBUF_NEEDS_INIT) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct zr364xx_buffer *buf = container_of(vb, struct zr364xx_buffer,\r\nvb);\r\nstruct zr364xx_camera *cam = vq->priv_data;\r\n_DBG("%s\n", __func__);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &cam->vidq.active);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct zr364xx_buffer *buf = container_of(vb, struct zr364xx_buffer,\r\nvb);\r\n_DBG("%s\n", __func__);\r\nfree_buffer(vq, buf);\r\n}\r\nstatic ssize_t zr364xx_read(struct file *file, char __user *buf, size_t count,\r\nloff_t * ppos)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nint err = 0;\r\n_DBG("%s\n", __func__);\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (!count)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&cam->lock))\r\nreturn -ERESTARTSYS;\r\nerr = zr364xx_vidioc_streamon(file, file->private_data,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nif (err == 0) {\r\nDBG("%s: reading %d bytes at pos %d.\n", __func__,\r\n(int) count, (int) *ppos);\r\nerr = videobuf_read_one(&cam->vb_vidq, buf, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nmutex_unlock(&cam->lock);\r\nreturn err;\r\n}\r\nstatic void zr364xx_fillbuff(struct zr364xx_camera *cam,\r\nstruct zr364xx_buffer *buf,\r\nint jpgsize)\r\n{\r\nint pos = 0;\r\nconst char *tmpbuf;\r\nchar *vbuf = videobuf_to_vmalloc(&buf->vb);\r\nunsigned long last_frame;\r\nif (!vbuf)\r\nreturn;\r\nlast_frame = cam->last_frame;\r\nif (last_frame != -1) {\r\ntmpbuf = (const char *)cam->buffer.frame[last_frame].lpvbits;\r\nswitch (buf->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_JPEG:\r\nbuf->vb.size = jpgsize;\r\nmemcpy(vbuf, tmpbuf, buf->vb.size);\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG KBUILD_MODNAME ": unknown format?\n");\r\n}\r\ncam->last_frame = -1;\r\n} else {\r\nprintk(KERN_ERR KBUILD_MODNAME ": =======no frame\n");\r\nreturn;\r\n}\r\nDBG("%s: Buffer 0x%08lx size= %d\n", __func__,\r\n(unsigned long)vbuf, pos);\r\nbuf->vb.field_count = cam->frame_count * 2;\r\nv4l2_get_timestamp(&buf->vb.ts);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\n}\r\nstatic int zr364xx_got_frame(struct zr364xx_camera *cam, int jpgsize)\r\n{\r\nstruct zr364xx_dmaqueue *dma_q = &cam->vidq;\r\nstruct zr364xx_buffer *buf;\r\nunsigned long flags = 0;\r\nint rc = 0;\r\nDBG("wakeup: %p\n", &dma_q);\r\nspin_lock_irqsave(&cam->slock, flags);\r\nif (list_empty(&dma_q->active)) {\r\nDBG("No active queue to serve\n");\r\nrc = -1;\r\ngoto unlock;\r\n}\r\nbuf = list_entry(dma_q->active.next,\r\nstruct zr364xx_buffer, vb.queue);\r\nif (!waitqueue_active(&buf->vb.done)) {\r\nrc = -1;\r\ngoto unlock;\r\n}\r\nlist_del(&buf->vb.queue);\r\nv4l2_get_timestamp(&buf->vb.ts);\r\nDBG("[%p/%d] wakeup\n", buf, buf->vb.i);\r\nzr364xx_fillbuff(cam, buf, jpgsize);\r\nwake_up(&buf->vb.done);\r\nDBG("wakeup [buf/i] [%p/%d]\n", buf, buf->vb.i);\r\nunlock:\r\nspin_unlock_irqrestore(&cam->slock, flags);\r\nreturn rc;\r\n}\r\nstatic int zr364xx_read_video_callback(struct zr364xx_camera *cam,\r\nstruct zr364xx_pipeinfo *pipe_info,\r\nstruct urb *purb)\r\n{\r\nunsigned char *pdest;\r\nunsigned char *psrc;\r\ns32 idx = -1;\r\nstruct zr364xx_framei *frm;\r\nint i = 0;\r\nunsigned char *ptr = NULL;\r\n_DBG("buffer to user\n");\r\nidx = cam->cur_frame;\r\nfrm = &cam->buffer.frame[idx];\r\nif (cam->method == METHOD0) {\r\nu16 *buf = (u16 *)pipe_info->transfer_buffer;\r\nfor (i = 0; i < purb->actual_length/2; i++)\r\nswab16s(buf + i);\r\n}\r\nif (!cam->b_acquire) {\r\nfrm->ulState = ZR364XX_READ_IDLE;\r\nreturn -EINVAL;\r\n}\r\npsrc = (u8 *)pipe_info->transfer_buffer;\r\nptr = pdest = frm->lpvbits;\r\nif (frm->ulState == ZR364XX_READ_IDLE) {\r\nfrm->ulState = ZR364XX_READ_FRAME;\r\nfrm->cur_size = 0;\r\n_DBG("jpeg header, ");\r\nmemcpy(ptr, header1, sizeof(header1));\r\nptr += sizeof(header1);\r\nheader3 = 0;\r\nmemcpy(ptr, &header3, 1);\r\nptr++;\r\nmemcpy(ptr, psrc, 64);\r\nptr += 64;\r\nheader3 = 1;\r\nmemcpy(ptr, &header3, 1);\r\nptr++;\r\nmemcpy(ptr, psrc + 64, 64);\r\nptr += 64;\r\nmemcpy(ptr, header2, sizeof(header2));\r\nptr += sizeof(header2);\r\nmemcpy(ptr, psrc + 128,\r\npurb->actual_length - 128);\r\nptr += purb->actual_length - 128;\r\n_DBG("header : %d %d %d %d %d %d %d %d %d\n",\r\npsrc[0], psrc[1], psrc[2],\r\npsrc[3], psrc[4], psrc[5],\r\npsrc[6], psrc[7], psrc[8]);\r\nfrm->cur_size = ptr - pdest;\r\n} else {\r\nif (frm->cur_size + purb->actual_length > MAX_FRAME_SIZE) {\r\ndev_info(&cam->udev->dev,\r\n"%s: buffer (%d bytes) too small to hold "\r\n"frame data. Discarding frame data.\n",\r\n__func__, MAX_FRAME_SIZE);\r\n} else {\r\npdest += frm->cur_size;\r\nmemcpy(pdest, psrc, purb->actual_length);\r\nfrm->cur_size += purb->actual_length;\r\n}\r\n}\r\nif (purb->actual_length < pipe_info->transfer_size) {\r\n_DBG("****************Buffer[%d]full*************\n", idx);\r\ncam->last_frame = cam->cur_frame;\r\ncam->cur_frame++;\r\nif (cam->cur_frame == cam->buffer.dwFrames)\r\ncam->cur_frame = 0;\r\nptr = pdest = frm->lpvbits;\r\nptr += frm->cur_size - 2;\r\nwhile (ptr > pdest) {\r\nif (*ptr == 0xFF && *(ptr + 1) == 0xD9\r\n&& *(ptr + 2) == 0xFF)\r\nbreak;\r\nptr--;\r\n}\r\nif (ptr == pdest)\r\nDBG("No EOI marker\n");\r\nwhile (ptr > pdest) {\r\nif (*ptr == 0xFF && *(ptr + 1) == 0xFF\r\n&& *(ptr + 2) == 0xFF)\r\nbreak;\r\nptr--;\r\n}\r\nif (ptr != pdest) {\r\nDBG("Bogus frame ? %d\n", ++(cam->nb));\r\n} else if (cam->b_acquire) {\r\nif (cam->skip)\r\ncam->skip--;\r\nelse {\r\n_DBG("jpeg(%lu): %d %d %d %d %d %d %d %d\n",\r\nfrm->cur_size,\r\npdest[0], pdest[1], pdest[2], pdest[3],\r\npdest[4], pdest[5], pdest[6], pdest[7]);\r\nzr364xx_got_frame(cam, frm->cur_size);\r\n}\r\n}\r\ncam->frame_count++;\r\nfrm->ulState = ZR364XX_READ_IDLE;\r\nfrm->cur_size = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nstrlcpy(cap->driver, DRIVER_DESC, sizeof(cap->driver));\r\nstrlcpy(cap->card, cam->udev->product, sizeof(cap->card));\r\nstrlcpy(cap->bus_info, dev_name(&cam->udev->dev),\r\nsizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(i->name, DRIVER_DESC " Camera");\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_g_input(struct file *file, void *priv,\r\nunsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_s_input(struct file *file, void *priv,\r\nunsigned int i)\r\n{\r\nif (i != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct zr364xx_camera *cam =\r\ncontainer_of(ctrl->handler, struct zr364xx_camera, ctrl_handler);\r\nint temp;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsend_control_msg(cam->udev, 1, 0x2001, 0, NULL, 0);\r\ntemp = (0x60 << 8) + 127 - ctrl->val;\r\nsend_control_msg(cam->udev, 1, temp, 0, NULL, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_enum_fmt_vid_cap(struct file *file,\r\nvoid *priv, struct v4l2_fmtdesc *f)\r\n{\r\nif (f->index > 0)\r\nreturn -EINVAL;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nstrcpy(f->description, formats[0].name);\r\nf->pixelformat = formats[0].fourcc;\r\nreturn 0;\r\n}\r\nstatic char *decode_fourcc(__u32 pixelformat, char *buf)\r\n{\r\nbuf[0] = pixelformat & 0xff;\r\nbuf[1] = (pixelformat >> 8) & 0xff;\r\nbuf[2] = (pixelformat >> 16) & 0xff;\r\nbuf[3] = (pixelformat >> 24) & 0xff;\r\nbuf[4] = '\0';\r\nreturn buf;\r\n}\r\nstatic int zr364xx_vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nchar pixelformat_name[5];\r\nif (cam == NULL)\r\nreturn -ENODEV;\r\nif (f->fmt.pix.pixelformat != V4L2_PIX_FMT_JPEG) {\r\nDBG("%s: unsupported pixelformat V4L2_PIX_FMT_%s\n", __func__,\r\ndecode_fourcc(f->fmt.pix.pixelformat, pixelformat_name));\r\nreturn -EINVAL;\r\n}\r\nif (!(f->fmt.pix.width == 160 && f->fmt.pix.height == 120) &&\r\n!(f->fmt.pix.width == 640 && f->fmt.pix.height == 480)) {\r\nf->fmt.pix.width = 320;\r\nf->fmt.pix.height = 240;\r\n}\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\r\nDBG("%s: V4L2_PIX_FMT_%s (%d) ok!\n", __func__,\r\ndecode_fourcc(f->fmt.pix.pixelformat, pixelformat_name),\r\nf->fmt.pix.field);\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct zr364xx_camera *cam;\r\nif (file == NULL)\r\nreturn -ENODEV;\r\ncam = video_drvdata(file);\r\nf->fmt.pix.pixelformat = formats[0].fourcc;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.width = cam->width;\r\nf->fmt.pix.height = cam->height;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nstruct videobuf_queue *q = &cam->vb_vidq;\r\nchar pixelformat_name[5];\r\nint ret = zr364xx_vidioc_try_fmt_vid_cap(file, cam, f);\r\nint i;\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&q->vb_lock);\r\nif (videobuf_queue_is_busy(&cam->vb_vidq)) {\r\nDBG("%s queue busy\n", __func__);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (cam->owner) {\r\nDBG("%s can't change format after started\n", __func__);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncam->width = f->fmt.pix.width;\r\ncam->height = f->fmt.pix.height;\r\nDBG("%s: %dx%d mode selected\n", __func__,\r\ncam->width, cam->height);\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;\r\ncam->vb_vidq.field = f->fmt.pix.field;\r\nif (f->fmt.pix.width == 160 && f->fmt.pix.height == 120)\r\nmode = 1;\r\nelse if (f->fmt.pix.width == 640 && f->fmt.pix.height == 480)\r\nmode = 2;\r\nelse\r\nmode = 0;\r\nm0d1[0] = mode;\r\nm1[2].value = 0xf000 + mode;\r\nm2[1].value = 0xf000 + mode;\r\nif (cam->method == METHOD3) {\r\nswitch (mode) {\r\ncase 1:\r\nm2[1].value = 0xf000 + 4;\r\nbreak;\r\ncase 2:\r\nm2[1].value = 0xf000 + 0;\r\nbreak;\r\ndefault:\r\nm2[1].value = 0xf000 + 1;\r\nbreak;\r\n}\r\n}\r\nheader2[437] = cam->height / 256;\r\nheader2[438] = cam->height % 256;\r\nheader2[439] = cam->width / 256;\r\nheader2[440] = cam->width % 256;\r\nfor (i = 0; init[cam->method][i].size != -1; i++) {\r\nret =\r\nsend_control_msg(cam->udev, 1, init[cam->method][i].value,\r\n0, init[cam->method][i].bytes,\r\ninit[cam->method][i].size);\r\nif (ret < 0) {\r\ndev_err(&cam->udev->dev,\r\n"error during resolution change sequence: %d\n", i);\r\ngoto out;\r\n}\r\n}\r\nmdelay(100);\r\ncam->skip = 2;\r\nret = 0;\r\nout:\r\nmutex_unlock(&q->vb_lock);\r\nDBG("%s: V4L2_PIX_FMT_%s (%d) ok!\n", __func__,\r\ndecode_fourcc(f->fmt.pix.pixelformat, pixelformat_name),\r\nf->fmt.pix.field);\r\nreturn ret;\r\n}\r\nstatic int zr364xx_vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nif (cam->owner && cam->owner != priv)\r\nreturn -EBUSY;\r\nreturn videobuf_reqbufs(&cam->vb_vidq, p);\r\n}\r\nstatic int zr364xx_vidioc_querybuf(struct file *file,\r\nvoid *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nrc = videobuf_querybuf(&cam->vb_vidq, p);\r\nreturn rc;\r\n}\r\nstatic int zr364xx_vidioc_qbuf(struct file *file,\r\nvoid *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\n_DBG("%s\n", __func__);\r\nif (cam->owner && cam->owner != priv)\r\nreturn -EBUSY;\r\nrc = videobuf_qbuf(&cam->vb_vidq, p);\r\nreturn rc;\r\n}\r\nstatic int zr364xx_vidioc_dqbuf(struct file *file,\r\nvoid *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\n_DBG("%s\n", __func__);\r\nif (cam->owner && cam->owner != priv)\r\nreturn -EBUSY;\r\nrc = videobuf_dqbuf(&cam->vb_vidq, p, file->f_flags & O_NONBLOCK);\r\nreturn rc;\r\n}\r\nstatic void read_pipe_completion(struct urb *purb)\r\n{\r\nstruct zr364xx_pipeinfo *pipe_info;\r\nstruct zr364xx_camera *cam;\r\nint pipe;\r\npipe_info = purb->context;\r\n_DBG("%s %p, status %d\n", __func__, purb, purb->status);\r\nif (pipe_info == NULL) {\r\nprintk(KERN_ERR KBUILD_MODNAME ": no context!\n");\r\nreturn;\r\n}\r\ncam = pipe_info->cam;\r\nif (cam == NULL) {\r\nprintk(KERN_ERR KBUILD_MODNAME ": no context!\n");\r\nreturn;\r\n}\r\nif (purb->status == -ESHUTDOWN) {\r\nDBG("%s, err shutdown\n", __func__);\r\npipe_info->err_count++;\r\nreturn;\r\n}\r\nif (pipe_info->state == 0) {\r\nDBG("exiting USB pipe\n");\r\nreturn;\r\n}\r\nif (purb->actual_length > pipe_info->transfer_size) {\r\ndev_err(&cam->udev->dev, "wrong number of bytes\n");\r\nreturn;\r\n}\r\nif (purb->status == 0)\r\nzr364xx_read_video_callback(cam, pipe_info, purb);\r\nelse {\r\npipe_info->err_count++;\r\nDBG("%s: failed URB %d\n", __func__, purb->status);\r\n}\r\npipe = usb_rcvbulkpipe(cam->udev, cam->read_endpoint);\r\nusb_fill_bulk_urb(pipe_info->stream_urb, cam->udev,\r\npipe,\r\npipe_info->transfer_buffer,\r\npipe_info->transfer_size,\r\nread_pipe_completion, pipe_info);\r\nif (pipe_info->state != 0) {\r\npurb->status = usb_submit_urb(pipe_info->stream_urb,\r\nGFP_ATOMIC);\r\nif (purb->status)\r\ndev_err(&cam->udev->dev,\r\n"error submitting urb (error=%i)\n",\r\npurb->status);\r\n} else\r\nDBG("read pipe complete state 0\n");\r\n}\r\nstatic int zr364xx_start_readpipe(struct zr364xx_camera *cam)\r\n{\r\nint pipe;\r\nint retval;\r\nstruct zr364xx_pipeinfo *pipe_info = cam->pipe;\r\npipe = usb_rcvbulkpipe(cam->udev, cam->read_endpoint);\r\nDBG("%s: start pipe IN x%x\n", __func__, cam->read_endpoint);\r\npipe_info->state = 1;\r\npipe_info->err_count = 0;\r\npipe_info->stream_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pipe_info->stream_urb) {\r\ndev_err(&cam->udev->dev, "ReadStream: Unable to alloc URB\n");\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(pipe_info->stream_urb, cam->udev,\r\npipe,\r\npipe_info->transfer_buffer,\r\npipe_info->transfer_size,\r\nread_pipe_completion, pipe_info);\r\nDBG("submitting URB %p\n", pipe_info->stream_urb);\r\nretval = usb_submit_urb(pipe_info->stream_urb, GFP_KERNEL);\r\nif (retval) {\r\nprintk(KERN_ERR KBUILD_MODNAME ": start read pipe failed\n");\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void zr364xx_stop_readpipe(struct zr364xx_camera *cam)\r\n{\r\nstruct zr364xx_pipeinfo *pipe_info;\r\nif (cam == NULL) {\r\nprintk(KERN_ERR KBUILD_MODNAME ": invalid device\n");\r\nreturn;\r\n}\r\nDBG("stop read pipe\n");\r\npipe_info = cam->pipe;\r\nif (pipe_info) {\r\nif (pipe_info->state != 0)\r\npipe_info->state = 0;\r\nif (pipe_info->stream_urb) {\r\nusb_kill_urb(pipe_info->stream_urb);\r\nusb_free_urb(pipe_info->stream_urb);\r\npipe_info->stream_urb = NULL;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int zr364xx_start_acquire(struct zr364xx_camera *cam)\r\n{\r\nint j;\r\nDBG("start acquire\n");\r\ncam->last_frame = -1;\r\ncam->cur_frame = 0;\r\nfor (j = 0; j < FRAMES; j++) {\r\ncam->buffer.frame[j].ulState = ZR364XX_READ_IDLE;\r\ncam->buffer.frame[j].cur_size = 0;\r\n}\r\ncam->b_acquire = 1;\r\nreturn 0;\r\n}\r\nstatic inline int zr364xx_stop_acquire(struct zr364xx_camera *cam)\r\n{\r\ncam->b_acquire = 0;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_prepare(struct zr364xx_camera *cam)\r\n{\r\nint res;\r\nint i, j;\r\nfor (i = 0; init[cam->method][i].size != -1; i++) {\r\nres = send_control_msg(cam->udev, 1, init[cam->method][i].value,\r\n0, init[cam->method][i].bytes,\r\ninit[cam->method][i].size);\r\nif (res < 0) {\r\ndev_err(&cam->udev->dev,\r\n"error during open sequence: %d\n", i);\r\nreturn res;\r\n}\r\n}\r\ncam->skip = 2;\r\ncam->last_frame = -1;\r\ncam->cur_frame = 0;\r\ncam->frame_count = 0;\r\nfor (j = 0; j < FRAMES; j++) {\r\ncam->buffer.frame[j].ulState = ZR364XX_READ_IDLE;\r\ncam->buffer.frame[j].cur_size = 0;\r\n}\r\nv4l2_ctrl_handler_setup(&cam->ctrl_handler);\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nint res;\r\nDBG("%s\n", __func__);\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cam->owner && cam->owner != priv)\r\nreturn -EBUSY;\r\nres = zr364xx_prepare(cam);\r\nif (res)\r\nreturn res;\r\nres = videobuf_streamon(&cam->vb_vidq);\r\nif (res == 0) {\r\nzr364xx_start_acquire(cam);\r\ncam->owner = file->private_data;\r\n}\r\nreturn res;\r\n}\r\nstatic int zr364xx_vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nDBG("%s\n", __func__);\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cam->owner && cam->owner != priv)\r\nreturn -EBUSY;\r\nzr364xx_stop_acquire(cam);\r\nreturn videobuf_streamoff(&cam->vb_vidq);\r\n}\r\nstatic int zr364xx_open(struct file *file)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nint err;\r\nDBG("%s\n", __func__);\r\nif (mutex_lock_interruptible(&cam->lock))\r\nreturn -ERESTARTSYS;\r\nerr = v4l2_fh_open(file);\r\nif (err)\r\ngoto out;\r\nmdelay(100);\r\nerr = 0;\r\nout:\r\nmutex_unlock(&cam->lock);\r\nDBG("%s: %d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic void zr364xx_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct zr364xx_camera *cam =\r\ncontainer_of(v4l2_dev, struct zr364xx_camera, v4l2_dev);\r\nunsigned long i;\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nvideobuf_mmap_free(&cam->vb_vidq);\r\nfor (i = 0; i < FRAMES; i++) {\r\nif (cam->buffer.frame[i].lpvbits) {\r\nDBG("vfree %p\n", cam->buffer.frame[i].lpvbits);\r\nvfree(cam->buffer.frame[i].lpvbits);\r\n}\r\ncam->buffer.frame[i].lpvbits = NULL;\r\n}\r\nv4l2_ctrl_handler_free(&cam->ctrl_handler);\r\nkfree(cam->pipe->transfer_buffer);\r\nkfree(cam);\r\n}\r\nstatic int zr364xx_close(struct file *file)\r\n{\r\nstruct zr364xx_camera *cam;\r\nstruct usb_device *udev;\r\nint i;\r\nDBG("%s\n", __func__);\r\ncam = video_drvdata(file);\r\nmutex_lock(&cam->lock);\r\nudev = cam->udev;\r\nif (file->private_data == cam->owner) {\r\nif (cam->b_acquire)\r\nzr364xx_stop_acquire(cam);\r\nvideobuf_streamoff(&cam->vb_vidq);\r\nfor (i = 0; i < 2; i++) {\r\nsend_control_msg(udev, 1, init[cam->method][i].value,\r\n0, init[cam->method][i].bytes,\r\ninit[cam->method][i].size);\r\n}\r\ncam->owner = NULL;\r\n}\r\nmdelay(100);\r\nmutex_unlock(&cam->lock);\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic int zr364xx_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nint ret;\r\nif (cam == NULL) {\r\nDBG("%s: cam == NULL\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nDBG("mmap called, vma=0x%08lx\n", (unsigned long)vma);\r\nret = videobuf_mmap_mapper(&cam->vb_vidq, vma);\r\nDBG("vma start=0x%08lx, size=%ld, ret=%d\n",\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end - (unsigned long)vma->vm_start, ret);\r\nreturn ret;\r\n}\r\nstatic unsigned int zr364xx_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nstruct videobuf_queue *q = &cam->vb_vidq;\r\nunsigned res = v4l2_ctrl_poll(file, wait);\r\n_DBG("%s\n", __func__);\r\nreturn res | videobuf_poll_stream(file, q, wait);\r\n}\r\nstatic int zr364xx_board_init(struct zr364xx_camera *cam)\r\n{\r\nstruct zr364xx_pipeinfo *pipe = cam->pipe;\r\nunsigned long i;\r\nDBG("board init: %p\n", cam);\r\nmemset(pipe, 0, sizeof(*pipe));\r\npipe->cam = cam;\r\npipe->transfer_size = BUFFER_SIZE;\r\npipe->transfer_buffer = kzalloc(pipe->transfer_size,\r\nGFP_KERNEL);\r\nif (pipe->transfer_buffer == NULL) {\r\nDBG("out of memory!\n");\r\nreturn -ENOMEM;\r\n}\r\ncam->b_acquire = 0;\r\ncam->frame_count = 0;\r\nfor (i = 0; i < FRAMES; i++) {\r\ncam->buffer.frame[i].lpvbits = vmalloc(MAX_FRAME_SIZE);\r\nDBG("valloc %p, idx %lu, pdata %p\n",\r\n&cam->buffer.frame[i], i,\r\ncam->buffer.frame[i].lpvbits);\r\nif (cam->buffer.frame[i].lpvbits == NULL) {\r\nprintk(KERN_INFO KBUILD_MODNAME ": out of memory. "\r\n"Using less frames\n");\r\nbreak;\r\n}\r\n}\r\nif (i == 0) {\r\nprintk(KERN_INFO KBUILD_MODNAME ": out of memory. Aborting\n");\r\nkfree(cam->pipe->transfer_buffer);\r\ncam->pipe->transfer_buffer = NULL;\r\nreturn -ENOMEM;\r\n} else\r\ncam->buffer.dwFrames = i;\r\nfor (i = 0; i < FRAMES; i++) {\r\ncam->buffer.frame[i].ulState = ZR364XX_READ_IDLE;\r\ncam->buffer.frame[i].cur_size = 0;\r\n}\r\ncam->cur_frame = 0;\r\ncam->last_frame = -1;\r\nzr364xx_start_readpipe(cam);\r\nDBG(": board initialized\n");\r\nreturn 0;\r\n}\r\nstatic int zr364xx_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct zr364xx_camera *cam = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint err;\r\nint i;\r\nDBG("probing...\n");\r\ndev_info(&intf->dev, DRIVER_DESC " compatible webcam plugged\n");\r\ndev_info(&intf->dev, "model %04x:%04x detected\n",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\ncam = kzalloc(sizeof(struct zr364xx_camera), GFP_KERNEL);\r\nif (cam == NULL) {\r\ndev_err(&udev->dev, "cam: out of memory !\n");\r\nreturn -ENOMEM;\r\n}\r\ncam->v4l2_dev.release = zr364xx_release;\r\nerr = v4l2_device_register(&intf->dev, &cam->v4l2_dev);\r\nif (err < 0) {\r\ndev_err(&udev->dev, "couldn't register v4l2_device\n");\r\nkfree(cam);\r\nreturn err;\r\n}\r\nhdl = &cam->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 1);\r\nv4l2_ctrl_new_std(hdl, &zr364xx_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 127, 1, 64);\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ndev_err(&udev->dev, "couldn't register control\n");\r\ngoto fail;\r\n}\r\ncam->method = id->driver_info;\r\nmutex_init(&cam->lock);\r\ncam->vdev = zr364xx_template;\r\ncam->vdev.lock = &cam->lock;\r\ncam->vdev.v4l2_dev = &cam->v4l2_dev;\r\ncam->vdev.ctrl_handler = &cam->ctrl_handler;\r\nvideo_set_drvdata(&cam->vdev, cam);\r\nif (debug)\r\ncam->vdev.debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;\r\ncam->udev = udev;\r\nswitch (mode) {\r\ncase 1:\r\ndev_info(&udev->dev, "160x120 mode selected\n");\r\ncam->width = 160;\r\ncam->height = 120;\r\nbreak;\r\ncase 2:\r\ndev_info(&udev->dev, "640x480 mode selected\n");\r\ncam->width = 640;\r\ncam->height = 480;\r\nbreak;\r\ndefault:\r\ndev_info(&udev->dev, "320x240 mode selected\n");\r\ncam->width = 320;\r\ncam->height = 240;\r\nbreak;\r\n}\r\nm0d1[0] = mode;\r\nm1[2].value = 0xf000 + mode;\r\nm2[1].value = 0xf000 + mode;\r\nif (cam->method == METHOD3) {\r\nswitch (mode) {\r\ncase 1:\r\nm2[1].value = 0xf000 + 4;\r\nbreak;\r\ncase 2:\r\nm2[1].value = 0xf000 + 0;\r\nbreak;\r\ndefault:\r\nm2[1].value = 0xf000 + 1;\r\nbreak;\r\n}\r\n}\r\nheader2[437] = cam->height / 256;\r\nheader2[438] = cam->height % 256;\r\nheader2[439] = cam->width / 256;\r\nheader2[440] = cam->width % 256;\r\ncam->nb = 0;\r\nDBG("dev: %p, udev %p interface %p\n", cam, cam->udev, intf);\r\niface_desc = intf->cur_altsetting;\r\nDBG("num endpoints %d\n", iface_desc->desc.bNumEndpoints);\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!cam->read_endpoint && usb_endpoint_is_bulk_in(endpoint)) {\r\ncam->read_endpoint = endpoint->bEndpointAddress;\r\n}\r\n}\r\nif (!cam->read_endpoint) {\r\nerr = -ENOMEM;\r\ndev_err(&intf->dev, "Could not find bulk-in endpoint\n");\r\ngoto fail;\r\n}\r\nINIT_LIST_HEAD(&cam->vidq.active);\r\ncam->vidq.cam = cam;\r\nusb_set_intfdata(intf, cam);\r\nerr = zr364xx_board_init(cam);\r\nif (!err)\r\nerr = v4l2_ctrl_handler_setup(hdl);\r\nif (err)\r\ngoto fail;\r\nspin_lock_init(&cam->slock);\r\ncam->fmt = formats;\r\nvideobuf_queue_vmalloc_init(&cam->vb_vidq, &zr364xx_video_qops,\r\nNULL, &cam->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_NONE,\r\nsizeof(struct zr364xx_buffer), cam, &cam->lock);\r\nerr = video_register_device(&cam->vdev, VFL_TYPE_GRABBER, -1);\r\nif (err) {\r\ndev_err(&udev->dev, "video_register_device failed\n");\r\ngoto fail;\r\n}\r\ndev_info(&udev->dev, DRIVER_DESC " controlling device %s\n",\r\nvideo_device_node_name(&cam->vdev));\r\nreturn 0;\r\nfail:\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nkfree(cam);\r\nreturn err;\r\n}\r\nstatic void zr364xx_disconnect(struct usb_interface *intf)\r\n{\r\nstruct zr364xx_camera *cam = usb_get_intfdata(intf);\r\nmutex_lock(&cam->lock);\r\nusb_set_intfdata(intf, NULL);\r\ndev_info(&intf->dev, DRIVER_DESC " webcam unplugged\n");\r\nvideo_unregister_device(&cam->vdev);\r\nv4l2_device_disconnect(&cam->v4l2_dev);\r\nif (cam->b_acquire)\r\nzr364xx_stop_acquire(cam);\r\nzr364xx_stop_readpipe(cam);\r\nmutex_unlock(&cam->lock);\r\nv4l2_device_put(&cam->v4l2_dev);\r\n}\r\nstatic int zr364xx_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct zr364xx_camera *cam = usb_get_intfdata(intf);\r\ncam->was_streaming = cam->b_acquire;\r\nif (!cam->was_streaming)\r\nreturn 0;\r\nzr364xx_stop_acquire(cam);\r\nzr364xx_stop_readpipe(cam);\r\nreturn 0;\r\n}\r\nstatic int zr364xx_resume(struct usb_interface *intf)\r\n{\r\nstruct zr364xx_camera *cam = usb_get_intfdata(intf);\r\nint res;\r\nif (!cam->was_streaming)\r\nreturn 0;\r\nzr364xx_start_readpipe(cam);\r\nres = zr364xx_prepare(cam);\r\nif (!res)\r\nzr364xx_start_acquire(cam);\r\nreturn res;\r\n}
