static inline struct f_uas *to_f_uas(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_uas, function);\r\n}\r\nstatic inline void usbg_cleanup_cmd(struct usbg_cmd *cmd)\r\n{\r\nkref_put(&cmd->ref, usbg_cmd_release);\r\n}\r\nstatic int bot_enqueue_cmd_cbw(struct f_uas *fu)\r\n{\r\nint ret;\r\nif (fu->flags & USBG_BOT_CMD_PEND)\r\nreturn 0;\r\nret = usb_ep_queue(fu->ep_out, fu->cmd.req, GFP_ATOMIC);\r\nif (!ret)\r\nfu->flags |= USBG_BOT_CMD_PEND;\r\nreturn ret;\r\n}\r\nstatic void bot_status_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nstruct f_uas *fu = cmd->fu;\r\nusbg_cleanup_cmd(cmd);\r\nif (req->status < 0) {\r\npr_err("ERR %s(%d)\n", __func__, __LINE__);\r\nreturn;\r\n}\r\nbot_enqueue_cmd_cbw(fu);\r\n}\r\nstatic void bot_enqueue_sense_code(struct f_uas *fu, struct usbg_cmd *cmd)\r\n{\r\nstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\r\nint ret;\r\nu8 *sense;\r\nunsigned int csw_stat;\r\ncsw_stat = cmd->csw_code;\r\nsense = cmd->sense_iu.sense;\r\ncsw->Tag = cmd->bot_tag;\r\ncsw->Status = csw_stat;\r\nfu->bot_status.req->context = cmd;\r\nret = usb_ep_queue(fu->ep_in, fu->bot_status.req, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) ERR: %d\n", __func__, __LINE__, ret);\r\n}\r\nstatic void bot_err_compl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nstruct f_uas *fu = cmd->fu;\r\nif (req->status < 0)\r\npr_err("ERR %s(%d)\n", __func__, __LINE__);\r\nif (cmd->data_len) {\r\nif (cmd->data_len > ep->maxpacket) {\r\nreq->length = ep->maxpacket;\r\ncmd->data_len -= ep->maxpacket;\r\n} else {\r\nreq->length = cmd->data_len;\r\ncmd->data_len = 0;\r\n}\r\nusb_ep_queue(ep, req, GFP_ATOMIC);\r\nreturn ;\r\n}\r\nbot_enqueue_sense_code(fu, cmd);\r\n}\r\nstatic void bot_send_bad_status(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\r\nstruct usb_request *req;\r\nstruct usb_ep *ep;\r\ncsw->Residue = cpu_to_le32(cmd->data_len);\r\nif (cmd->data_len) {\r\nif (cmd->is_read) {\r\nep = fu->ep_in;\r\nreq = fu->bot_req_in;\r\n} else {\r\nep = fu->ep_out;\r\nreq = fu->bot_req_out;\r\n}\r\nif (cmd->data_len > fu->ep_in->maxpacket) {\r\nreq->length = ep->maxpacket;\r\ncmd->data_len -= ep->maxpacket;\r\n} else {\r\nreq->length = cmd->data_len;\r\ncmd->data_len = 0;\r\n}\r\nreq->complete = bot_err_compl;\r\nreq->context = cmd;\r\nreq->buf = fu->cmd.buf;\r\nusb_ep_queue(ep, req, GFP_KERNEL);\r\n} else {\r\nbot_enqueue_sense_code(fu, cmd);\r\n}\r\n}\r\nstatic int bot_send_status(struct usbg_cmd *cmd, bool moved_data)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\r\nint ret;\r\nif (cmd->se_cmd.scsi_status == SAM_STAT_GOOD) {\r\nif (!moved_data && cmd->data_len) {\r\ncmd->csw_code = US_BULK_STAT_OK;\r\nbot_send_bad_status(cmd);\r\nreturn 0;\r\n}\r\ncsw->Tag = cmd->bot_tag;\r\ncsw->Residue = cpu_to_le32(0);\r\ncsw->Status = US_BULK_STAT_OK;\r\nfu->bot_status.req->context = cmd;\r\nret = usb_ep_queue(fu->ep_in, fu->bot_status.req, GFP_KERNEL);\r\nif (ret)\r\npr_err("%s(%d) ERR: %d\n", __func__, __LINE__, ret);\r\n} else {\r\ncmd->csw_code = US_BULK_STAT_FAIL;\r\nbot_send_bad_status(cmd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bot_send_status_response(struct usbg_cmd *cmd)\r\n{\r\nbool moved_data = false;\r\nif (!cmd->is_read)\r\nmoved_data = true;\r\nreturn bot_send_status(cmd, moved_data);\r\n}\r\nstatic void bot_read_compl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nif (req->status < 0)\r\npr_err("ERR %s(%d)\n", __func__, __LINE__);\r\nbot_send_status(cmd, true);\r\n}\r\nstatic int bot_send_read_response(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct usb_gadget *gadget = fuas_to_gadget(fu);\r\nint ret;\r\nif (!cmd->data_len) {\r\ncmd->csw_code = US_BULK_STAT_PHASE;\r\nbot_send_bad_status(cmd);\r\nreturn 0;\r\n}\r\nif (!gadget->sg_supported) {\r\ncmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\r\nif (!cmd->data_buf)\r\nreturn -ENOMEM;\r\nsg_copy_to_buffer(se_cmd->t_data_sg,\r\nse_cmd->t_data_nents,\r\ncmd->data_buf,\r\nse_cmd->data_length);\r\nfu->bot_req_in->buf = cmd->data_buf;\r\n} else {\r\nfu->bot_req_in->buf = NULL;\r\nfu->bot_req_in->num_sgs = se_cmd->t_data_nents;\r\nfu->bot_req_in->sg = se_cmd->t_data_sg;\r\n}\r\nfu->bot_req_in->complete = bot_read_compl;\r\nfu->bot_req_in->length = se_cmd->data_length;\r\nfu->bot_req_in->context = cmd;\r\nret = usb_ep_queue(fu->ep_in, fu->bot_req_in, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d)\n", __func__, __LINE__);\r\nreturn 0;\r\n}\r\nstatic int bot_send_write_request(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct usb_gadget *gadget = fuas_to_gadget(fu);\r\nint ret;\r\ninit_completion(&cmd->write_complete);\r\ncmd->fu = fu;\r\nif (!cmd->data_len) {\r\ncmd->csw_code = US_BULK_STAT_PHASE;\r\nreturn -EINVAL;\r\n}\r\nif (!gadget->sg_supported) {\r\ncmd->data_buf = kmalloc(se_cmd->data_length, GFP_KERNEL);\r\nif (!cmd->data_buf)\r\nreturn -ENOMEM;\r\nfu->bot_req_out->buf = cmd->data_buf;\r\n} else {\r\nfu->bot_req_out->buf = NULL;\r\nfu->bot_req_out->num_sgs = se_cmd->t_data_nents;\r\nfu->bot_req_out->sg = se_cmd->t_data_sg;\r\n}\r\nfu->bot_req_out->complete = usbg_data_write_cmpl;\r\nfu->bot_req_out->length = se_cmd->data_length;\r\nfu->bot_req_out->context = cmd;\r\nret = usbg_prepare_w_request(cmd, fu->bot_req_out);\r\nif (ret)\r\ngoto cleanup;\r\nret = usb_ep_queue(fu->ep_out, fu->bot_req_out, GFP_KERNEL);\r\nif (ret)\r\npr_err("%s(%d)\n", __func__, __LINE__);\r\nwait_for_completion(&cmd->write_complete);\r\ntarget_execute_cmd(se_cmd);\r\ncleanup:\r\nreturn ret;\r\n}\r\nstatic void bot_cmd_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_uas *fu = req->context;\r\nint ret;\r\nfu->flags &= ~USBG_BOT_CMD_PEND;\r\nif (req->status < 0)\r\nreturn;\r\nret = bot_submit_command(fu, req->buf, req->actual);\r\nif (ret)\r\npr_err("%s(%d): %d\n", __func__, __LINE__, ret);\r\n}\r\nstatic int bot_prepare_reqs(struct f_uas *fu)\r\n{\r\nint ret;\r\nfu->bot_req_in = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\r\nif (!fu->bot_req_in)\r\ngoto err;\r\nfu->bot_req_out = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\r\nif (!fu->bot_req_out)\r\ngoto err_out;\r\nfu->cmd.req = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\r\nif (!fu->cmd.req)\r\ngoto err_cmd;\r\nfu->bot_status.req = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\r\nif (!fu->bot_status.req)\r\ngoto err_sts;\r\nfu->bot_status.req->buf = &fu->bot_status.csw;\r\nfu->bot_status.req->length = US_BULK_CS_WRAP_LEN;\r\nfu->bot_status.req->complete = bot_status_complete;\r\nfu->bot_status.csw.Signature = cpu_to_le32(US_BULK_CS_SIGN);\r\nfu->cmd.buf = kmalloc(fu->ep_out->maxpacket, GFP_KERNEL);\r\nif (!fu->cmd.buf)\r\ngoto err_buf;\r\nfu->cmd.req->complete = bot_cmd_complete;\r\nfu->cmd.req->buf = fu->cmd.buf;\r\nfu->cmd.req->length = fu->ep_out->maxpacket;\r\nfu->cmd.req->context = fu;\r\nret = bot_enqueue_cmd_cbw(fu);\r\nif (ret)\r\ngoto err_queue;\r\nreturn 0;\r\nerr_queue:\r\nkfree(fu->cmd.buf);\r\nfu->cmd.buf = NULL;\r\nerr_buf:\r\nusb_ep_free_request(fu->ep_in, fu->bot_status.req);\r\nerr_sts:\r\nusb_ep_free_request(fu->ep_out, fu->cmd.req);\r\nfu->cmd.req = NULL;\r\nerr_cmd:\r\nusb_ep_free_request(fu->ep_out, fu->bot_req_out);\r\nfu->bot_req_out = NULL;\r\nerr_out:\r\nusb_ep_free_request(fu->ep_in, fu->bot_req_in);\r\nfu->bot_req_in = NULL;\r\nerr:\r\npr_err("BOT: endpoint setup failed\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic void bot_cleanup_old_alt(struct f_uas *fu)\r\n{\r\nif (!(fu->flags & USBG_ENABLED))\r\nreturn;\r\nusb_ep_disable(fu->ep_in);\r\nusb_ep_disable(fu->ep_out);\r\nif (!fu->bot_req_in)\r\nreturn;\r\nusb_ep_free_request(fu->ep_in, fu->bot_req_in);\r\nusb_ep_free_request(fu->ep_out, fu->bot_req_out);\r\nusb_ep_free_request(fu->ep_out, fu->cmd.req);\r\nusb_ep_free_request(fu->ep_out, fu->bot_status.req);\r\nkfree(fu->cmd.buf);\r\nfu->bot_req_in = NULL;\r\nfu->bot_req_out = NULL;\r\nfu->cmd.req = NULL;\r\nfu->bot_status.req = NULL;\r\nfu->cmd.buf = NULL;\r\n}\r\nstatic void bot_set_alt(struct f_uas *fu)\r\n{\r\nstruct usb_function *f = &fu->function;\r\nstruct usb_gadget *gadget = f->config->cdev->gadget;\r\nint ret;\r\nfu->flags = USBG_IS_BOT;\r\nconfig_ep_by_speed(gadget, f, fu->ep_in);\r\nret = usb_ep_enable(fu->ep_in);\r\nif (ret)\r\ngoto err_b_in;\r\nconfig_ep_by_speed(gadget, f, fu->ep_out);\r\nret = usb_ep_enable(fu->ep_out);\r\nif (ret)\r\ngoto err_b_out;\r\nret = bot_prepare_reqs(fu);\r\nif (ret)\r\ngoto err_wq;\r\nfu->flags |= USBG_ENABLED;\r\npr_info("Using the BOT protocol\n");\r\nreturn;\r\nerr_wq:\r\nusb_ep_disable(fu->ep_out);\r\nerr_b_out:\r\nusb_ep_disable(fu->ep_in);\r\nerr_b_in:\r\nfu->flags = USBG_IS_BOT;\r\n}\r\nstatic int usbg_bot_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nint luns;\r\nu8 *ret_lun;\r\nswitch (ctrl->bRequest) {\r\ncase US_BULK_GET_MAX_LUN:\r\nif (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE))\r\nreturn -ENOTSUPP;\r\nif (w_length < 1)\r\nreturn -EINVAL;\r\nif (w_value != 0)\r\nreturn -EINVAL;\r\nluns = atomic_read(&fu->tpg->tpg_port_count);\r\nif (!luns) {\r\npr_err("No LUNs configured?\n");\r\nreturn -EINVAL;\r\n}\r\nluns--;\r\nif (luns > 0xf) {\r\npr_info_once("Limiting the number of luns to 16\n");\r\nluns = 0xf;\r\n}\r\nret_lun = cdev->req->buf;\r\n*ret_lun = luns;\r\ncdev->req->length = 1;\r\nreturn usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);\r\nbreak;\r\ncase US_BULK_RESET_REQUEST:\r\nbot_enqueue_cmd_cbw(fu);\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void uasp_cleanup_one_stream(struct f_uas *fu, struct uas_stream *stream)\r\n{\r\nif (!stream->req_in)\r\nreturn;\r\nusb_ep_free_request(fu->ep_in, stream->req_in);\r\nusb_ep_free_request(fu->ep_out, stream->req_out);\r\nusb_ep_free_request(fu->ep_status, stream->req_status);\r\nstream->req_in = NULL;\r\nstream->req_out = NULL;\r\nstream->req_status = NULL;\r\n}\r\nstatic void uasp_free_cmdreq(struct f_uas *fu)\r\n{\r\nusb_ep_free_request(fu->ep_cmd, fu->cmd.req);\r\nkfree(fu->cmd.buf);\r\nfu->cmd.req = NULL;\r\nfu->cmd.buf = NULL;\r\n}\r\nstatic void uasp_cleanup_old_alt(struct f_uas *fu)\r\n{\r\nint i;\r\nif (!(fu->flags & USBG_ENABLED))\r\nreturn;\r\nusb_ep_disable(fu->ep_in);\r\nusb_ep_disable(fu->ep_out);\r\nusb_ep_disable(fu->ep_status);\r\nusb_ep_disable(fu->ep_cmd);\r\nfor (i = 0; i < UASP_SS_EP_COMP_NUM_STREAMS; i++)\r\nuasp_cleanup_one_stream(fu, &fu->stream[i]);\r\nuasp_free_cmdreq(fu);\r\n}\r\nstatic int uasp_prepare_r_request(struct usbg_cmd *cmd)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct f_uas *fu = cmd->fu;\r\nstruct usb_gadget *gadget = fuas_to_gadget(fu);\r\nstruct uas_stream *stream = cmd->stream;\r\nif (!gadget->sg_supported) {\r\ncmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\r\nif (!cmd->data_buf)\r\nreturn -ENOMEM;\r\nsg_copy_to_buffer(se_cmd->t_data_sg,\r\nse_cmd->t_data_nents,\r\ncmd->data_buf,\r\nse_cmd->data_length);\r\nstream->req_in->buf = cmd->data_buf;\r\n} else {\r\nstream->req_in->buf = NULL;\r\nstream->req_in->num_sgs = se_cmd->t_data_nents;\r\nstream->req_in->sg = se_cmd->t_data_sg;\r\n}\r\nstream->req_in->complete = uasp_status_data_cmpl;\r\nstream->req_in->length = se_cmd->data_length;\r\nstream->req_in->context = cmd;\r\ncmd->state = UASP_SEND_STATUS;\r\nreturn 0;\r\n}\r\nstatic void uasp_prepare_status(struct usbg_cmd *cmd)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct sense_iu *iu = &cmd->sense_iu;\r\nstruct uas_stream *stream = cmd->stream;\r\ncmd->state = UASP_QUEUE_COMMAND;\r\niu->iu_id = IU_ID_STATUS;\r\niu->tag = cpu_to_be16(cmd->tag);\r\niu->len = cpu_to_be16(se_cmd->scsi_sense_length);\r\niu->status = se_cmd->scsi_status;\r\nstream->req_status->context = cmd;\r\nstream->req_status->length = se_cmd->scsi_sense_length + 16;\r\nstream->req_status->buf = iu;\r\nstream->req_status->complete = uasp_status_data_cmpl;\r\n}\r\nstatic void uasp_status_data_cmpl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nstruct uas_stream *stream = cmd->stream;\r\nstruct f_uas *fu = cmd->fu;\r\nint ret;\r\nif (req->status < 0)\r\ngoto cleanup;\r\nswitch (cmd->state) {\r\ncase UASP_SEND_DATA:\r\nret = uasp_prepare_r_request(cmd);\r\nif (ret)\r\ngoto cleanup;\r\nret = usb_ep_queue(fu->ep_in, stream->req_in, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\nbreak;\r\ncase UASP_RECEIVE_DATA:\r\nret = usbg_prepare_w_request(cmd, stream->req_out);\r\nif (ret)\r\ngoto cleanup;\r\nret = usb_ep_queue(fu->ep_out, stream->req_out, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\nbreak;\r\ncase UASP_SEND_STATUS:\r\nuasp_prepare_status(cmd);\r\nret = usb_ep_queue(fu->ep_status, stream->req_status,\r\nGFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\nbreak;\r\ncase UASP_QUEUE_COMMAND:\r\nusbg_cleanup_cmd(cmd);\r\nusb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn;\r\ncleanup:\r\nusbg_cleanup_cmd(cmd);\r\n}\r\nstatic int uasp_send_status_response(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct uas_stream *stream = cmd->stream;\r\nstruct sense_iu *iu = &cmd->sense_iu;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nstream->req_status->complete = uasp_status_data_cmpl;\r\nstream->req_status->context = cmd;\r\ncmd->fu = fu;\r\nuasp_prepare_status(cmd);\r\nreturn usb_ep_queue(fu->ep_status, stream->req_status, GFP_ATOMIC);\r\n}\r\nstatic int uasp_send_read_response(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct uas_stream *stream = cmd->stream;\r\nstruct sense_iu *iu = &cmd->sense_iu;\r\nint ret;\r\ncmd->fu = fu;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nif (fu->flags & USBG_USE_STREAMS) {\r\nret = uasp_prepare_r_request(cmd);\r\nif (ret)\r\ngoto out;\r\nret = usb_ep_queue(fu->ep_in, stream->req_in, GFP_ATOMIC);\r\nif (ret) {\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\nkfree(cmd->data_buf);\r\ncmd->data_buf = NULL;\r\n}\r\n} else {\r\niu->iu_id = IU_ID_READ_READY;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nstream->req_status->complete = uasp_status_data_cmpl;\r\nstream->req_status->context = cmd;\r\ncmd->state = UASP_SEND_DATA;\r\nstream->req_status->buf = iu;\r\nstream->req_status->length = sizeof(struct iu);\r\nret = usb_ep_queue(fu->ep_status, stream->req_status,\r\nGFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d) => %d\n", __func__, __LINE__, ret);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int uasp_send_write_request(struct usbg_cmd *cmd)\r\n{\r\nstruct f_uas *fu = cmd->fu;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct uas_stream *stream = cmd->stream;\r\nstruct sense_iu *iu = &cmd->sense_iu;\r\nint ret;\r\ninit_completion(&cmd->write_complete);\r\ncmd->fu = fu;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nif (fu->flags & USBG_USE_STREAMS) {\r\nret = usbg_prepare_w_request(cmd, stream->req_out);\r\nif (ret)\r\ngoto cleanup;\r\nret = usb_ep_queue(fu->ep_out, stream->req_out, GFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d)\n", __func__, __LINE__);\r\n} else {\r\niu->iu_id = IU_ID_WRITE_READY;\r\niu->tag = cpu_to_be16(cmd->tag);\r\nstream->req_status->complete = uasp_status_data_cmpl;\r\nstream->req_status->context = cmd;\r\ncmd->state = UASP_RECEIVE_DATA;\r\nstream->req_status->buf = iu;\r\nstream->req_status->length = sizeof(struct iu);\r\nret = usb_ep_queue(fu->ep_status, stream->req_status,\r\nGFP_ATOMIC);\r\nif (ret)\r\npr_err("%s(%d)\n", __func__, __LINE__);\r\n}\r\nwait_for_completion(&cmd->write_complete);\r\ntarget_execute_cmd(se_cmd);\r\ncleanup:\r\nreturn ret;\r\n}\r\nstatic void uasp_cmd_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_uas *fu = req->context;\r\nint ret;\r\nif (req->status < 0)\r\nreturn;\r\nret = usbg_submit_command(fu, req->buf, req->actual);\r\nif (!ret)\r\nreturn;\r\nusb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\r\n}\r\nstatic int uasp_alloc_stream_res(struct f_uas *fu, struct uas_stream *stream)\r\n{\r\nstream->req_in = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\r\nif (!stream->req_in)\r\ngoto out;\r\nstream->req_out = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\r\nif (!stream->req_out)\r\ngoto err_out;\r\nstream->req_status = usb_ep_alloc_request(fu->ep_status, GFP_KERNEL);\r\nif (!stream->req_status)\r\ngoto err_sts;\r\nreturn 0;\r\nerr_sts:\r\nusb_ep_free_request(fu->ep_status, stream->req_status);\r\nstream->req_status = NULL;\r\nerr_out:\r\nusb_ep_free_request(fu->ep_out, stream->req_out);\r\nstream->req_out = NULL;\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nstatic int uasp_alloc_cmd(struct f_uas *fu)\r\n{\r\nfu->cmd.req = usb_ep_alloc_request(fu->ep_cmd, GFP_KERNEL);\r\nif (!fu->cmd.req)\r\ngoto err;\r\nfu->cmd.buf = kmalloc(fu->ep_cmd->maxpacket, GFP_KERNEL);\r\nif (!fu->cmd.buf)\r\ngoto err_buf;\r\nfu->cmd.req->complete = uasp_cmd_complete;\r\nfu->cmd.req->buf = fu->cmd.buf;\r\nfu->cmd.req->length = fu->ep_cmd->maxpacket;\r\nfu->cmd.req->context = fu;\r\nreturn 0;\r\nerr_buf:\r\nusb_ep_free_request(fu->ep_cmd, fu->cmd.req);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void uasp_setup_stream_res(struct f_uas *fu, int max_streams)\r\n{\r\nint i;\r\nfor (i = 0; i < max_streams; i++) {\r\nstruct uas_stream *s = &fu->stream[i];\r\ns->req_in->stream_id = i + 1;\r\ns->req_out->stream_id = i + 1;\r\ns->req_status->stream_id = i + 1;\r\n}\r\n}\r\nstatic int uasp_prepare_reqs(struct f_uas *fu)\r\n{\r\nint ret;\r\nint i;\r\nint max_streams;\r\nif (fu->flags & USBG_USE_STREAMS)\r\nmax_streams = UASP_SS_EP_COMP_NUM_STREAMS;\r\nelse\r\nmax_streams = 1;\r\nfor (i = 0; i < max_streams; i++) {\r\nret = uasp_alloc_stream_res(fu, &fu->stream[i]);\r\nif (ret)\r\ngoto err_cleanup;\r\n}\r\nret = uasp_alloc_cmd(fu);\r\nif (ret)\r\ngoto err_free_stream;\r\nuasp_setup_stream_res(fu, max_streams);\r\nret = usb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\r\nif (ret)\r\ngoto err_free_stream;\r\nreturn 0;\r\nerr_free_stream:\r\nuasp_free_cmdreq(fu);\r\nerr_cleanup:\r\nif (i) {\r\ndo {\r\nuasp_cleanup_one_stream(fu, &fu->stream[i - 1]);\r\ni--;\r\n} while (i);\r\n}\r\npr_err("UASP: endpoint setup failed\n");\r\nreturn ret;\r\n}\r\nstatic void uasp_set_alt(struct f_uas *fu)\r\n{\r\nstruct usb_function *f = &fu->function;\r\nstruct usb_gadget *gadget = f->config->cdev->gadget;\r\nint ret;\r\nfu->flags = USBG_IS_UAS;\r\nif (gadget->speed == USB_SPEED_SUPER)\r\nfu->flags |= USBG_USE_STREAMS;\r\nconfig_ep_by_speed(gadget, f, fu->ep_in);\r\nret = usb_ep_enable(fu->ep_in);\r\nif (ret)\r\ngoto err_b_in;\r\nconfig_ep_by_speed(gadget, f, fu->ep_out);\r\nret = usb_ep_enable(fu->ep_out);\r\nif (ret)\r\ngoto err_b_out;\r\nconfig_ep_by_speed(gadget, f, fu->ep_cmd);\r\nret = usb_ep_enable(fu->ep_cmd);\r\nif (ret)\r\ngoto err_cmd;\r\nconfig_ep_by_speed(gadget, f, fu->ep_status);\r\nret = usb_ep_enable(fu->ep_status);\r\nif (ret)\r\ngoto err_status;\r\nret = uasp_prepare_reqs(fu);\r\nif (ret)\r\ngoto err_wq;\r\nfu->flags |= USBG_ENABLED;\r\npr_info("Using the UAS protocol\n");\r\nreturn;\r\nerr_wq:\r\nusb_ep_disable(fu->ep_status);\r\nerr_status:\r\nusb_ep_disable(fu->ep_cmd);\r\nerr_cmd:\r\nusb_ep_disable(fu->ep_out);\r\nerr_b_out:\r\nusb_ep_disable(fu->ep_in);\r\nerr_b_in:\r\nfu->flags = 0;\r\n}\r\nstatic int get_cmd_dir(const unsigned char *cdb)\r\n{\r\nint ret;\r\nswitch (cdb[0]) {\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_12:\r\ncase READ_16:\r\ncase INQUIRY:\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\ncase SERVICE_ACTION_IN:\r\ncase MAINTENANCE_IN:\r\ncase PERSISTENT_RESERVE_IN:\r\ncase SECURITY_PROTOCOL_IN:\r\ncase ACCESS_CONTROL_IN:\r\ncase REPORT_LUNS:\r\ncase READ_BLOCK_LIMITS:\r\ncase READ_POSITION:\r\ncase READ_CAPACITY:\r\ncase READ_TOC:\r\ncase READ_FORMAT_CAPACITIES:\r\ncase REQUEST_SENSE:\r\nret = DMA_FROM_DEVICE;\r\nbreak;\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_12:\r\ncase WRITE_16:\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\ncase WRITE_VERIFY:\r\ncase WRITE_VERIFY_12:\r\ncase PERSISTENT_RESERVE_OUT:\r\ncase MAINTENANCE_OUT:\r\ncase SECURITY_PROTOCOL_OUT:\r\ncase ACCESS_CONTROL_OUT:\r\nret = DMA_TO_DEVICE;\r\nbreak;\r\ncase ALLOW_MEDIUM_REMOVAL:\r\ncase TEST_UNIT_READY:\r\ncase SYNCHRONIZE_CACHE:\r\ncase START_STOP:\r\ncase ERASE:\r\ncase REZERO_UNIT:\r\ncase SEEK_10:\r\ncase SPACE:\r\ncase VERIFY:\r\ncase WRITE_FILEMARKS:\r\nret = DMA_NONE;\r\nbreak;\r\ndefault:\r\npr_warn("target: Unknown data direction for SCSI Opcode "\r\n"0x%02x\n", cdb[0]);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void usbg_data_write_cmpl(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usbg_cmd *cmd = req->context;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nif (req->status < 0) {\r\npr_err("%s() state %d transfer failed\n", __func__, cmd->state);\r\ngoto cleanup;\r\n}\r\nif (req->num_sgs == 0) {\r\nsg_copy_from_buffer(se_cmd->t_data_sg,\r\nse_cmd->t_data_nents,\r\ncmd->data_buf,\r\nse_cmd->data_length);\r\n}\r\ncomplete(&cmd->write_complete);\r\nreturn;\r\ncleanup:\r\nusbg_cleanup_cmd(cmd);\r\n}\r\nstatic int usbg_prepare_w_request(struct usbg_cmd *cmd, struct usb_request *req)\r\n{\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct f_uas *fu = cmd->fu;\r\nstruct usb_gadget *gadget = fuas_to_gadget(fu);\r\nif (!gadget->sg_supported) {\r\ncmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\r\nif (!cmd->data_buf)\r\nreturn -ENOMEM;\r\nreq->buf = cmd->data_buf;\r\n} else {\r\nreq->buf = NULL;\r\nreq->num_sgs = se_cmd->t_data_nents;\r\nreq->sg = se_cmd->t_data_sg;\r\n}\r\nreq->complete = usbg_data_write_cmpl;\r\nreq->length = se_cmd->data_length;\r\nreq->context = cmd;\r\nreturn 0;\r\n}\r\nstatic int usbg_send_status_response(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nstruct f_uas *fu = cmd->fu;\r\nif (fu->flags & USBG_IS_BOT)\r\nreturn bot_send_status_response(cmd);\r\nelse\r\nreturn uasp_send_status_response(cmd);\r\n}\r\nstatic int usbg_send_write_request(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nstruct f_uas *fu = cmd->fu;\r\nif (fu->flags & USBG_IS_BOT)\r\nreturn bot_send_write_request(cmd);\r\nelse\r\nreturn uasp_send_write_request(cmd);\r\n}\r\nstatic int usbg_send_read_response(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nstruct f_uas *fu = cmd->fu;\r\nif (fu->flags & USBG_IS_BOT)\r\nreturn bot_send_read_response(cmd);\r\nelse\r\nreturn uasp_send_read_response(cmd);\r\n}\r\nstatic void usbg_cmd_work(struct work_struct *work)\r\n{\r\nstruct usbg_cmd *cmd = container_of(work, struct usbg_cmd, work);\r\nstruct se_cmd *se_cmd;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nstruct usbg_tpg *tpg;\r\nint dir;\r\nse_cmd = &cmd->se_cmd;\r\ntpg = cmd->fu->tpg;\r\ntv_nexus = tpg->tpg_nexus;\r\ndir = get_cmd_dir(cmd->cmd_buf);\r\nif (dir < 0) {\r\ntransport_init_se_cmd(se_cmd,\r\ntv_nexus->tvn_se_sess->se_tpg->se_tpg_tfo,\r\ntv_nexus->tvn_se_sess, cmd->data_len, DMA_NONE,\r\ncmd->prio_attr, cmd->sense_iu.sense);\r\ngoto out;\r\n}\r\nif (target_submit_cmd(se_cmd, tv_nexus->tvn_se_sess,\r\ncmd->cmd_buf, cmd->sense_iu.sense, cmd->unpacked_lun,\r\n0, cmd->prio_attr, dir, TARGET_SCF_UNKNOWN_SIZE) < 0)\r\ngoto out;\r\nreturn;\r\nout:\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_UNSUPPORTED_SCSI_OPCODE, 1);\r\nusbg_cleanup_cmd(cmd);\r\n}\r\nstatic int usbg_submit_command(struct f_uas *fu,\r\nvoid *cmdbuf, unsigned int len)\r\n{\r\nstruct command_iu *cmd_iu = cmdbuf;\r\nstruct usbg_cmd *cmd;\r\nstruct usbg_tpg *tpg;\r\nstruct se_cmd *se_cmd;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nu32 cmd_len;\r\nint ret;\r\nif (cmd_iu->iu_id != IU_ID_COMMAND) {\r\npr_err("Unsupported type %d\n", cmd_iu->iu_id);\r\nreturn -EINVAL;\r\n}\r\ncmd = kzalloc(sizeof *cmd, GFP_ATOMIC);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->fu = fu;\r\nkref_init(&cmd->ref);\r\nkref_get(&cmd->ref);\r\ntpg = fu->tpg;\r\ncmd_len = (cmd_iu->len & ~0x3) + 16;\r\nif (cmd_len > USBG_MAX_CMD)\r\ngoto err;\r\nmemcpy(cmd->cmd_buf, cmd_iu->cdb, cmd_len);\r\ncmd->tag = be16_to_cpup(&cmd_iu->tag);\r\nif (fu->flags & USBG_USE_STREAMS) {\r\nif (cmd->tag > UASP_SS_EP_COMP_NUM_STREAMS)\r\ngoto err;\r\nif (!cmd->tag)\r\ncmd->stream = &fu->stream[0];\r\nelse\r\ncmd->stream = &fu->stream[cmd->tag - 1];\r\n} else {\r\ncmd->stream = &fu->stream[0];\r\n}\r\ntv_nexus = tpg->tpg_nexus;\r\nif (!tv_nexus) {\r\npr_err("Missing nexus, ignoring command\n");\r\ngoto err;\r\n}\r\nswitch (cmd_iu->prio_attr & 0x7) {\r\ncase UAS_HEAD_TAG:\r\ncmd->prio_attr = MSG_HEAD_TAG;\r\nbreak;\r\ncase UAS_ORDERED_TAG:\r\ncmd->prio_attr = MSG_ORDERED_TAG;\r\nbreak;\r\ncase UAS_ACA:\r\ncmd->prio_attr = MSG_ACA_TAG;\r\nbreak;\r\ndefault:\r\npr_debug_once("Unsupported prio_attr: %02x.\n",\r\ncmd_iu->prio_attr);\r\ncase UAS_SIMPLE_TAG:\r\ncmd->prio_attr = MSG_SIMPLE_TAG;\r\nbreak;\r\n}\r\nse_cmd = &cmd->se_cmd;\r\ncmd->unpacked_lun = scsilun_to_int(&cmd_iu->lun);\r\nINIT_WORK(&cmd->work, usbg_cmd_work);\r\nret = queue_work(tpg->workqueue, &cmd->work);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(cmd);\r\nreturn -EINVAL;\r\n}\r\nstatic void bot_cmd_work(struct work_struct *work)\r\n{\r\nstruct usbg_cmd *cmd = container_of(work, struct usbg_cmd, work);\r\nstruct se_cmd *se_cmd;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nstruct usbg_tpg *tpg;\r\nint dir;\r\nse_cmd = &cmd->se_cmd;\r\ntpg = cmd->fu->tpg;\r\ntv_nexus = tpg->tpg_nexus;\r\ndir = get_cmd_dir(cmd->cmd_buf);\r\nif (dir < 0) {\r\ntransport_init_se_cmd(se_cmd,\r\ntv_nexus->tvn_se_sess->se_tpg->se_tpg_tfo,\r\ntv_nexus->tvn_se_sess, cmd->data_len, DMA_NONE,\r\ncmd->prio_attr, cmd->sense_iu.sense);\r\ngoto out;\r\n}\r\nif (target_submit_cmd(se_cmd, tv_nexus->tvn_se_sess,\r\ncmd->cmd_buf, cmd->sense_iu.sense, cmd->unpacked_lun,\r\ncmd->data_len, cmd->prio_attr, dir, 0) < 0)\r\ngoto out;\r\nreturn;\r\nout:\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_UNSUPPORTED_SCSI_OPCODE, 1);\r\nusbg_cleanup_cmd(cmd);\r\n}\r\nstatic int bot_submit_command(struct f_uas *fu,\r\nvoid *cmdbuf, unsigned int len)\r\n{\r\nstruct bulk_cb_wrap *cbw = cmdbuf;\r\nstruct usbg_cmd *cmd;\r\nstruct usbg_tpg *tpg;\r\nstruct se_cmd *se_cmd;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nu32 cmd_len;\r\nint ret;\r\nif (cbw->Signature != cpu_to_le32(US_BULK_CB_SIGN)) {\r\npr_err("Wrong signature on CBW\n");\r\nreturn -EINVAL;\r\n}\r\nif (len != 31) {\r\npr_err("Wrong length for CBW\n");\r\nreturn -EINVAL;\r\n}\r\ncmd_len = cbw->Length;\r\nif (cmd_len < 1 || cmd_len > 16)\r\nreturn -EINVAL;\r\ncmd = kzalloc(sizeof *cmd, GFP_ATOMIC);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->fu = fu;\r\nkref_init(&cmd->ref);\r\nkref_get(&cmd->ref);\r\ntpg = fu->tpg;\r\nmemcpy(cmd->cmd_buf, cbw->CDB, cmd_len);\r\ncmd->bot_tag = cbw->Tag;\r\ntv_nexus = tpg->tpg_nexus;\r\nif (!tv_nexus) {\r\npr_err("Missing nexus, ignoring command\n");\r\ngoto err;\r\n}\r\ncmd->prio_attr = MSG_SIMPLE_TAG;\r\nse_cmd = &cmd->se_cmd;\r\ncmd->unpacked_lun = cbw->Lun;\r\ncmd->is_read = cbw->Flags & US_BULK_FLAG_IN ? 1 : 0;\r\ncmd->data_len = le32_to_cpu(cbw->DataTransferLength);\r\nINIT_WORK(&cmd->work, bot_cmd_work);\r\nret = queue_work(tpg->workqueue, &cmd->work);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(cmd);\r\nreturn -EINVAL;\r\n}\r\nstatic int usbg_check_true(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int usbg_check_false(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic char *usbg_get_fabric_name(void)\r\n{\r\nreturn "usb_gadget";\r\n}\r\nstatic u8 usbg_get_fabric_proto_ident(struct se_portal_group *se_tpg)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nstruct usbg_tport *tport = tpg->tport;\r\nu8 proto_id;\r\nswitch (tport->tport_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\ndefault:\r\nproto_id = sas_get_fabric_proto_ident(se_tpg);\r\nbreak;\r\n}\r\nreturn proto_id;\r\n}\r\nstatic char *usbg_get_fabric_wwn(struct se_portal_group *se_tpg)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nstruct usbg_tport *tport = tpg->tport;\r\nreturn &tport->tport_name[0];\r\n}\r\nstatic u16 usbg_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nreturn tpg->tport_tpgt;\r\n}\r\nstatic u32 usbg_get_default_depth(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic u32 usbg_get_pr_transport_id(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl,\r\nstruct t10_pr_registration *pr_reg,\r\nint *format_code,\r\nunsigned char *buf)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nstruct usbg_tport *tport = tpg->tport;\r\nint ret = 0;\r\nswitch (tport->tport_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\ndefault:\r\nret = sas_get_pr_transport_id(se_tpg, se_nacl, pr_reg,\r\nformat_code, buf);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 usbg_get_pr_transport_id_len(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl,\r\nstruct t10_pr_registration *pr_reg,\r\nint *format_code)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nstruct usbg_tport *tport = tpg->tport;\r\nint ret = 0;\r\nswitch (tport->tport_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\ndefault:\r\nret = sas_get_pr_transport_id_len(se_tpg, se_nacl, pr_reg,\r\nformat_code);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic char *usbg_parse_pr_out_transport_id(\r\nstruct se_portal_group *se_tpg,\r\nconst char *buf,\r\nu32 *out_tid_len,\r\nchar **port_nexus_ptr)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\nstruct usbg_tport *tport = tpg->tport;\r\nchar *tid = NULL;\r\nswitch (tport->tport_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\ndefault:\r\ntid = sas_parse_pr_out_transport_id(se_tpg, buf, out_tid_len,\r\nport_nexus_ptr);\r\n}\r\nreturn tid;\r\n}\r\nstatic struct se_node_acl *usbg_alloc_fabric_acl(struct se_portal_group *se_tpg)\r\n{\r\nstruct usbg_nacl *nacl;\r\nnacl = kzalloc(sizeof(struct usbg_nacl), GFP_KERNEL);\r\nif (!nacl)\r\nreturn NULL;\r\nreturn &nacl->se_node_acl;\r\n}\r\nstatic void usbg_release_fabric_acl(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl)\r\n{\r\nstruct usbg_nacl *nacl = container_of(se_nacl,\r\nstruct usbg_nacl, se_node_acl);\r\nkfree(nacl);\r\n}\r\nstatic u32 usbg_tpg_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic void usbg_cmd_release(struct kref *ref)\r\n{\r\nstruct usbg_cmd *cmd = container_of(ref, struct usbg_cmd,\r\nref);\r\ntransport_generic_free_cmd(&cmd->se_cmd, 0);\r\n}\r\nstatic void usbg_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nkfree(cmd->data_buf);\r\nkfree(cmd);\r\nreturn;\r\n}\r\nstatic int usbg_shutdown_session(struct se_session *se_sess)\r\n{\r\nreturn 0;\r\n}\r\nstatic void usbg_close_session(struct se_session *se_sess)\r\n{\r\nreturn;\r\n}\r\nstatic u32 usbg_sess_get_index(struct se_session *se_sess)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usbg_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void usbg_set_default_node_attrs(struct se_node_acl *nacl)\r\n{\r\nreturn;\r\n}\r\nstatic u32 usbg_get_task_tag(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nstruct f_uas *fu = cmd->fu;\r\nif (fu->flags & USBG_IS_BOT)\r\nreturn le32_to_cpu(cmd->bot_tag);\r\nelse\r\nreturn cmd->tag;\r\n}\r\nstatic int usbg_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void usbg_queue_tm_rsp(struct se_cmd *se_cmd)\r\n{\r\n}\r\nstatic void usbg_aborted_task(struct se_cmd *se_cmd)\r\n{\r\nreturn;\r\n}\r\nstatic const char *usbg_check_wwn(const char *name)\r\n{\r\nconst char *n;\r\nunsigned int len;\r\nn = strstr(name, "naa.");\r\nif (!n)\r\nreturn NULL;\r\nn += 4;\r\nlen = strlen(n);\r\nif (len == 0 || len > USBG_NAMELEN - 1)\r\nreturn NULL;\r\nreturn n;\r\n}\r\nstatic struct se_node_acl *usbg_make_nodeacl(\r\nstruct se_portal_group *se_tpg,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct se_node_acl *se_nacl, *se_nacl_new;\r\nstruct usbg_nacl *nacl;\r\nu64 wwpn = 0;\r\nu32 nexus_depth;\r\nconst char *wnn_name;\r\nwnn_name = usbg_check_wwn(name);\r\nif (!wnn_name)\r\nreturn ERR_PTR(-EINVAL);\r\nse_nacl_new = usbg_alloc_fabric_acl(se_tpg);\r\nif (!(se_nacl_new))\r\nreturn ERR_PTR(-ENOMEM);\r\nnexus_depth = 1;\r\nse_nacl = core_tpg_add_initiator_node_acl(se_tpg, se_nacl_new,\r\nname, nexus_depth);\r\nif (IS_ERR(se_nacl)) {\r\nusbg_release_fabric_acl(se_tpg, se_nacl_new);\r\nreturn se_nacl;\r\n}\r\nnacl = container_of(se_nacl, struct usbg_nacl, se_node_acl);\r\nnacl->iport_wwpn = wwpn;\r\nsnprintf(nacl->iport_name, sizeof(nacl->iport_name), "%s", name);\r\nreturn se_nacl;\r\n}\r\nstatic void usbg_drop_nodeacl(struct se_node_acl *se_acl)\r\n{\r\nstruct usbg_nacl *nacl = container_of(se_acl,\r\nstruct usbg_nacl, se_node_acl);\r\ncore_tpg_del_initiator_node_acl(se_acl->se_tpg, se_acl, 1);\r\nkfree(nacl);\r\n}\r\nstatic struct se_portal_group *usbg_make_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct usbg_tport *tport = container_of(wwn, struct usbg_tport,\r\ntport_wwn);\r\nstruct usbg_tpg *tpg;\r\nunsigned long tpgt;\r\nint ret;\r\nif (strstr(name, "tpgt_") != name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (kstrtoul(name + 5, 0, &tpgt) || tpgt > UINT_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nif (the_only_tpg_I_currently_have) {\r\npr_err("Until the gadget framework can't handle multiple\n");\r\npr_err("gadgets, you can't do this here.\n");\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\ntpg = kzalloc(sizeof(struct usbg_tpg), GFP_KERNEL);\r\nif (!tpg)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&tpg->tpg_mutex);\r\natomic_set(&tpg->tpg_port_count, 0);\r\ntpg->workqueue = alloc_workqueue("tcm_usb_gadget", 0, 1);\r\nif (!tpg->workqueue) {\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\ntpg->tport = tport;\r\ntpg->tport_tpgt = tpgt;\r\nret = core_tpg_register(&usbg_fabric_configfs->tf_ops, wwn,\r\n&tpg->se_tpg, tpg,\r\nTRANSPORT_TPG_TYPE_NORMAL);\r\nif (ret < 0) {\r\ndestroy_workqueue(tpg->workqueue);\r\nkfree(tpg);\r\nreturn NULL;\r\n}\r\nthe_only_tpg_I_currently_have = tpg;\r\nreturn &tpg->se_tpg;\r\n}\r\nstatic void usbg_drop_tpg(struct se_portal_group *se_tpg)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg,\r\nstruct usbg_tpg, se_tpg);\r\ncore_tpg_deregister(se_tpg);\r\ndestroy_workqueue(tpg->workqueue);\r\nkfree(tpg);\r\nthe_only_tpg_I_currently_have = NULL;\r\n}\r\nstatic struct se_wwn *usbg_make_tport(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct usbg_tport *tport;\r\nconst char *wnn_name;\r\nu64 wwpn = 0;\r\nwnn_name = usbg_check_wwn(name);\r\nif (!wnn_name)\r\nreturn ERR_PTR(-EINVAL);\r\ntport = kzalloc(sizeof(struct usbg_tport), GFP_KERNEL);\r\nif (!(tport))\r\nreturn ERR_PTR(-ENOMEM);\r\ntport->tport_wwpn = wwpn;\r\nsnprintf(tport->tport_name, sizeof(tport->tport_name), "%s", wnn_name);\r\nreturn &tport->tport_wwn;\r\n}\r\nstatic void usbg_drop_tport(struct se_wwn *wwn)\r\n{\r\nstruct usbg_tport *tport = container_of(wwn,\r\nstruct usbg_tport, tport_wwn);\r\nkfree(tport);\r\n}\r\nstatic ssize_t usbg_wwn_show_attr_version(\r\nstruct target_fabric_configfs *tf,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "usb-gadget fabric module\n");\r\n}\r\nstatic ssize_t tcm_usbg_tpg_show_enable(\r\nstruct se_portal_group *se_tpg,\r\nchar *page)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\nreturn snprintf(page, PAGE_SIZE, "%u\n", tpg->gadget_connect);\r\n}\r\nstatic ssize_t tcm_usbg_tpg_store_enable(\r\nstruct se_portal_group *se_tpg,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\nunsigned long op;\r\nssize_t ret;\r\nret = kstrtoul(page, 0, &op);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nif (op > 1)\r\nreturn -EINVAL;\r\nif (op && tpg->gadget_connect)\r\ngoto out;\r\nif (!op && !tpg->gadget_connect)\r\ngoto out;\r\nif (op) {\r\nret = usbg_attach(tpg);\r\nif (ret)\r\ngoto out;\r\n} else {\r\nusbg_detach(tpg);\r\n}\r\ntpg->gadget_connect = op;\r\nout:\r\nreturn count;\r\n}\r\nstatic ssize_t tcm_usbg_tpg_show_nexus(\r\nstruct se_portal_group *se_tpg,\r\nchar *page)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nssize_t ret;\r\nmutex_lock(&tpg->tpg_mutex);\r\ntv_nexus = tpg->tpg_nexus;\r\nif (!tv_nexus) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = snprintf(page, PAGE_SIZE, "%s\n",\r\ntv_nexus->tvn_se_sess->se_node_acl->initiatorname);\r\nout:\r\nmutex_unlock(&tpg->tpg_mutex);\r\nreturn ret;\r\n}\r\nstatic int tcm_usbg_make_nexus(struct usbg_tpg *tpg, char *name)\r\n{\r\nstruct se_portal_group *se_tpg;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nint ret;\r\nmutex_lock(&tpg->tpg_mutex);\r\nif (tpg->tpg_nexus) {\r\nret = -EEXIST;\r\npr_debug("tpg->tpg_nexus already exists\n");\r\ngoto err_unlock;\r\n}\r\nse_tpg = &tpg->se_tpg;\r\nret = -ENOMEM;\r\ntv_nexus = kzalloc(sizeof(*tv_nexus), GFP_KERNEL);\r\nif (!tv_nexus)\r\ngoto err_unlock;\r\ntv_nexus->tvn_se_sess = transport_init_session(TARGET_PROT_NORMAL);\r\nif (IS_ERR(tv_nexus->tvn_se_sess))\r\ngoto err_free;\r\ntv_nexus->tvn_se_sess->se_node_acl = core_tpg_check_initiator_node_acl(\r\nse_tpg, name);\r\nif (!tv_nexus->tvn_se_sess->se_node_acl) {\r\npr_debug("core_tpg_check_initiator_node_acl() failed"\r\n" for %s\n", name);\r\ngoto err_session;\r\n}\r\n__transport_register_session(se_tpg, tv_nexus->tvn_se_sess->se_node_acl,\r\ntv_nexus->tvn_se_sess, tv_nexus);\r\ntpg->tpg_nexus = tv_nexus;\r\nmutex_unlock(&tpg->tpg_mutex);\r\nreturn 0;\r\nerr_session:\r\ntransport_free_session(tv_nexus->tvn_se_sess);\r\nerr_free:\r\nkfree(tv_nexus);\r\nerr_unlock:\r\nmutex_unlock(&tpg->tpg_mutex);\r\nreturn ret;\r\n}\r\nstatic int tcm_usbg_drop_nexus(struct usbg_tpg *tpg)\r\n{\r\nstruct se_session *se_sess;\r\nstruct tcm_usbg_nexus *tv_nexus;\r\nint ret = -ENODEV;\r\nmutex_lock(&tpg->tpg_mutex);\r\ntv_nexus = tpg->tpg_nexus;\r\nif (!tv_nexus)\r\ngoto out;\r\nse_sess = tv_nexus->tvn_se_sess;\r\nif (!se_sess)\r\ngoto out;\r\nif (atomic_read(&tpg->tpg_port_count)) {\r\nret = -EPERM;\r\npr_err("Unable to remove Host I_T Nexus with"\r\n" active TPG port count: %d\n",\r\natomic_read(&tpg->tpg_port_count));\r\ngoto out;\r\n}\r\npr_debug("Removing I_T Nexus to Initiator Port: %s\n",\r\ntv_nexus->tvn_se_sess->se_node_acl->initiatorname);\r\ntransport_deregister_session(tv_nexus->tvn_se_sess);\r\ntpg->tpg_nexus = NULL;\r\nkfree(tv_nexus);\r\nret = 0;\r\nout:\r\nmutex_unlock(&tpg->tpg_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t tcm_usbg_tpg_store_nexus(\r\nstruct se_portal_group *se_tpg,\r\nconst char *page,\r\nsize_t count)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\nunsigned char i_port[USBG_NAMELEN], *ptr;\r\nint ret;\r\nif (!strncmp(page, "NULL", 4)) {\r\nret = tcm_usbg_drop_nexus(tpg);\r\nreturn (!ret) ? count : ret;\r\n}\r\nif (strlen(page) >= USBG_NAMELEN) {\r\npr_err("Emulated NAA Sas Address: %s, exceeds"\r\n" max: %d\n", page, USBG_NAMELEN);\r\nreturn -EINVAL;\r\n}\r\nsnprintf(i_port, USBG_NAMELEN, "%s", page);\r\nptr = strstr(i_port, "naa.");\r\nif (!ptr) {\r\npr_err("Missing 'naa.' prefix\n");\r\nreturn -EINVAL;\r\n}\r\nif (i_port[strlen(i_port) - 1] == '\n')\r\ni_port[strlen(i_port) - 1] = '\0';\r\nret = tcm_usbg_make_nexus(tpg, &i_port[4]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int usbg_port_link(struct se_portal_group *se_tpg, struct se_lun *lun)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\natomic_inc(&tpg->tpg_port_count);\r\nsmp_mb__after_atomic();\r\nreturn 0;\r\n}\r\nstatic void usbg_port_unlink(struct se_portal_group *se_tpg,\r\nstruct se_lun *se_lun)\r\n{\r\nstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\r\natomic_dec(&tpg->tpg_port_count);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic int usbg_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\r\nse_cmd);\r\nkref_put(&cmd->ref, usbg_cmd_release);\r\nreturn 1;\r\n}\r\nstatic int usbg_register_configfs(void)\r\n{\r\nstruct target_fabric_configfs *fabric;\r\nint ret;\r\nfabric = target_fabric_configfs_init(THIS_MODULE, "usb_gadget");\r\nif (IS_ERR(fabric)) {\r\nprintk(KERN_ERR "target_fabric_configfs_init() failed\n");\r\nreturn PTR_ERR(fabric);\r\n}\r\nfabric->tf_ops = usbg_ops;\r\nfabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = usbg_wwn_attrs;\r\nfabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = usbg_base_attrs;\r\nfabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = NULL;\r\nfabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;\r\nfabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;\r\nfabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = NULL;\r\nfabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;\r\nfabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = NULL;\r\nfabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = NULL;\r\nret = target_fabric_configfs_register(fabric);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "target_fabric_configfs_register() failed"\r\n" for usb-gadget\n");\r\nreturn ret;\r\n}\r\nusbg_fabric_configfs = fabric;\r\nreturn 0;\r\n}\r\nstatic void usbg_deregister_configfs(void)\r\n{\r\nif (!(usbg_fabric_configfs))\r\nreturn;\r\ntarget_fabric_configfs_deregister(usbg_fabric_configfs);\r\nusbg_fabric_configfs = NULL;\r\n}\r\nstatic int guas_unbind(struct usb_composite_dev *cdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void give_back_ep(struct usb_ep **pep)\r\n{\r\nstruct usb_ep *ep = *pep;\r\nif (!ep)\r\nreturn;\r\nep->driver_data = NULL;\r\n}\r\nstatic int usbg_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nstruct usb_gadget *gadget = c->cdev->gadget;\r\nstruct usb_ep *ep;\r\nint iface;\r\nint ret;\r\niface = usb_interface_id(c, f);\r\nif (iface < 0)\r\nreturn iface;\r\nbot_intf_desc.bInterfaceNumber = iface;\r\nuasp_intf_desc.bInterfaceNumber = iface;\r\nfu->iface = iface;\r\nep = usb_ep_autoconfig_ss(gadget, &uasp_ss_bi_desc,\r\n&uasp_bi_ep_comp_desc);\r\nif (!ep)\r\ngoto ep_fail;\r\nep->driver_data = fu;\r\nfu->ep_in = ep;\r\nep = usb_ep_autoconfig_ss(gadget, &uasp_ss_bo_desc,\r\n&uasp_bo_ep_comp_desc);\r\nif (!ep)\r\ngoto ep_fail;\r\nep->driver_data = fu;\r\nfu->ep_out = ep;\r\nep = usb_ep_autoconfig_ss(gadget, &uasp_ss_status_desc,\r\n&uasp_status_in_ep_comp_desc);\r\nif (!ep)\r\ngoto ep_fail;\r\nep->driver_data = fu;\r\nfu->ep_status = ep;\r\nep = usb_ep_autoconfig_ss(gadget, &uasp_ss_cmd_desc,\r\n&uasp_cmd_comp_desc);\r\nif (!ep)\r\ngoto ep_fail;\r\nep->driver_data = fu;\r\nfu->ep_cmd = ep;\r\nuasp_bi_desc.bEndpointAddress = uasp_ss_bi_desc.bEndpointAddress;\r\nuasp_bo_desc.bEndpointAddress = uasp_ss_bo_desc.bEndpointAddress;\r\nuasp_status_desc.bEndpointAddress =\r\nuasp_ss_status_desc.bEndpointAddress;\r\nuasp_cmd_desc.bEndpointAddress = uasp_ss_cmd_desc.bEndpointAddress;\r\nuasp_fs_bi_desc.bEndpointAddress = uasp_ss_bi_desc.bEndpointAddress;\r\nuasp_fs_bo_desc.bEndpointAddress = uasp_ss_bo_desc.bEndpointAddress;\r\nuasp_fs_status_desc.bEndpointAddress =\r\nuasp_ss_status_desc.bEndpointAddress;\r\nuasp_fs_cmd_desc.bEndpointAddress = uasp_ss_cmd_desc.bEndpointAddress;\r\nret = usb_assign_descriptors(f, uasp_fs_function_desc,\r\nuasp_hs_function_desc, uasp_ss_function_desc);\r\nif (ret)\r\ngoto ep_fail;\r\nreturn 0;\r\nep_fail:\r\npr_err("Can't claim all required eps\n");\r\ngive_back_ep(&fu->ep_in);\r\ngive_back_ep(&fu->ep_out);\r\ngive_back_ep(&fu->ep_status);\r\ngive_back_ep(&fu->ep_cmd);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void usbg_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nusb_free_all_descriptors(f);\r\nkfree(fu);\r\n}\r\nstatic void usbg_delayed_set_alt(struct work_struct *wq)\r\n{\r\nstruct guas_setup_wq *work = container_of(wq, struct guas_setup_wq,\r\nwork);\r\nstruct f_uas *fu = work->fu;\r\nint alt = work->alt;\r\nkfree(work);\r\nif (fu->flags & USBG_IS_BOT)\r\nbot_cleanup_old_alt(fu);\r\nif (fu->flags & USBG_IS_UAS)\r\nuasp_cleanup_old_alt(fu);\r\nif (alt == USB_G_ALT_INT_BBB)\r\nbot_set_alt(fu);\r\nelse if (alt == USB_G_ALT_INT_UAS)\r\nuasp_set_alt(fu);\r\nusb_composite_setup_continue(fu->function.config->cdev);\r\n}\r\nstatic int usbg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nif ((alt == USB_G_ALT_INT_BBB) || (alt == USB_G_ALT_INT_UAS)) {\r\nstruct guas_setup_wq *work;\r\nwork = kmalloc(sizeof(*work), GFP_ATOMIC);\r\nif (!work)\r\nreturn -ENOMEM;\r\nINIT_WORK(&work->work, usbg_delayed_set_alt);\r\nwork->fu = fu;\r\nwork->alt = alt;\r\nschedule_work(&work->work);\r\nreturn USB_GADGET_DELAYED_STATUS;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void usbg_disable(struct usb_function *f)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nif (fu->flags & USBG_IS_UAS)\r\nuasp_cleanup_old_alt(fu);\r\nelse if (fu->flags & USBG_IS_BOT)\r\nbot_cleanup_old_alt(fu);\r\nfu->flags = 0;\r\n}\r\nstatic int usbg_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_uas *fu = to_f_uas(f);\r\nif (!(fu->flags & USBG_IS_BOT))\r\nreturn -EOPNOTSUPP;\r\nreturn usbg_bot_setup(f, ctrl);\r\n}\r\nstatic int usbg_cfg_bind(struct usb_configuration *c)\r\n{\r\nstruct f_uas *fu;\r\nint ret;\r\nfu = kzalloc(sizeof(*fu), GFP_KERNEL);\r\nif (!fu)\r\nreturn -ENOMEM;\r\nfu->function.name = "Target Function";\r\nfu->function.bind = usbg_bind;\r\nfu->function.unbind = usbg_unbind;\r\nfu->function.set_alt = usbg_set_alt;\r\nfu->function.setup = usbg_setup;\r\nfu->function.disable = usbg_disable;\r\nfu->tpg = the_only_tpg_I_currently_have;\r\nbot_intf_desc.iInterface = usbg_us_strings[USB_G_STR_INT_BBB].id;\r\nuasp_intf_desc.iInterface = usbg_us_strings[USB_G_STR_INT_UAS].id;\r\nret = usb_add_function(c, &fu->function);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(fu);\r\nreturn ret;\r\n}\r\nstatic int usb_target_bind(struct usb_composite_dev *cdev)\r\n{\r\nint ret;\r\nret = usb_string_ids_tab(cdev, usbg_us_strings);\r\nif (ret)\r\nreturn ret;\r\nusbg_device_desc.iManufacturer =\r\nusbg_us_strings[USB_GADGET_MANUFACTURER_IDX].id;\r\nusbg_device_desc.iProduct = usbg_us_strings[USB_GADGET_PRODUCT_IDX].id;\r\nusbg_device_desc.iSerialNumber =\r\nusbg_us_strings[USB_GADGET_SERIAL_IDX].id;\r\nusbg_config_driver.iConfiguration =\r\nusbg_us_strings[USB_G_STR_CONFIG].id;\r\nret = usb_add_config(cdev, &usbg_config_driver,\r\nusbg_cfg_bind);\r\nif (ret)\r\nreturn ret;\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\nreturn 0;\r\n}\r\nstatic int usbg_attach(struct usbg_tpg *tpg)\r\n{\r\nreturn usb_composite_probe(&usbg_driver);\r\n}\r\nstatic void usbg_detach(struct usbg_tpg *tpg)\r\n{\r\nusb_composite_unregister(&usbg_driver);\r\n}\r\nstatic int __init usb_target_gadget_init(void)\r\n{\r\nint ret;\r\nret = usbg_register_configfs();\r\nreturn ret;\r\n}\r\nstatic void __exit usb_target_gadget_exit(void)\r\n{\r\nusbg_deregister_configfs();\r\n}
