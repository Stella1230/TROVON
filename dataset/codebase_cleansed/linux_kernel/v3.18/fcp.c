int avc_general_set_sig_fmt(struct fw_unit *unit, unsigned int rate,\r\nenum avc_general_plug_dir dir,\r\nunsigned short pid)\r\n{\r\nunsigned int sfc;\r\nu8 *buf;\r\nbool flag;\r\nint err;\r\nflag = false;\r\nfor (sfc = 0; sfc < CIP_SFC_COUNT; sfc++) {\r\nif (amdtp_rate_table[sfc] == rate) {\r\nflag = true;\r\nbreak;\r\n}\r\n}\r\nif (!flag)\r\nreturn -EINVAL;\r\nbuf = kzalloc(8, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nbuf[0] = 0x00;\r\nbuf[1] = 0xff;\r\nif (dir == AVC_GENERAL_PLUG_DIR_IN)\r\nbuf[2] = 0x19;\r\nelse\r\nbuf[2] = 0x18;\r\nbuf[3] = 0xff & pid;\r\nbuf[4] = 0x90;\r\nbuf[5] = 0x07 & sfc;\r\nbuf[6] = 0xff;\r\nbuf[7] = 0xff;\r\nerr = fcp_avc_transaction(unit, buf, 8, buf, 8,\r\nBIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5));\r\nif (err >= 0 && err < 8)\r\nerr = -EIO;\r\nelse if (buf[0] == 0x08)\r\nerr = -ENOSYS;\r\nelse if (buf[0] == 0x0a)\r\nerr = -EINVAL;\r\nif (err < 0)\r\ngoto end;\r\nerr = 0;\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nint avc_general_get_sig_fmt(struct fw_unit *unit, unsigned int *rate,\r\nenum avc_general_plug_dir dir,\r\nunsigned short pid)\r\n{\r\nunsigned int sfc;\r\nu8 *buf;\r\nint err;\r\nbuf = kzalloc(8, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nbuf[0] = 0x01;\r\nbuf[1] = 0xff;\r\nif (dir == AVC_GENERAL_PLUG_DIR_IN)\r\nbuf[2] = 0x19;\r\nelse\r\nbuf[2] = 0x18;\r\nbuf[3] = 0xff & pid;\r\nbuf[4] = 0x90;\r\nbuf[5] = 0xff;\r\nbuf[6] = 0xff;\r\nbuf[7] = 0xff;\r\nerr = fcp_avc_transaction(unit, buf, 8, buf, 8,\r\nBIT(1) | BIT(2) | BIT(3) | BIT(4));\r\nif (err >= 0 && err < 8)\r\nerr = -EIO;\r\nelse if (buf[0] == 0x08)\r\nerr = -ENOSYS;\r\nelse if (buf[0] == 0x0a)\r\nerr = -EINVAL;\r\nelse if (buf[0] == 0x0b)\r\nerr = -EAGAIN;\r\nif (err < 0)\r\ngoto end;\r\nsfc = 0x07 & buf[5];\r\nif (sfc >= CIP_SFC_COUNT) {\r\nerr = -EAGAIN;\r\ngoto end;\r\n}\r\n*rate = amdtp_rate_table[sfc];\r\nerr = 0;\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nint avc_general_get_plug_info(struct fw_unit *unit, unsigned int subunit_type,\r\nunsigned int subunit_id, unsigned int subfunction,\r\nu8 info[AVC_PLUG_INFO_BUF_BYTES])\r\n{\r\nu8 *buf;\r\nint err;\r\nif ((subunit_type == 0x1E) || (subunit_id == 5))\r\nreturn -EINVAL;\r\nbuf = kzalloc(8, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nbuf[0] = 0x01;\r\nbuf[1] = ((subunit_type & 0x1f) << 3) | (subunit_id & 0x7);\r\nbuf[2] = 0x02;\r\nbuf[3] = 0xff & subfunction;\r\nerr = fcp_avc_transaction(unit, buf, 8, buf, 8, BIT(1) | BIT(2));\r\nif (err >= 0 && err < 8)\r\nerr = -EIO;\r\nelse if (buf[0] == 0x08)\r\nerr = -ENOSYS;\r\nelse if (buf[0] == 0x0a)\r\nerr = -EINVAL;\r\nelse if (buf[0] == 0x0b)\r\nerr = -EAGAIN;\r\nif (err < 0)\r\ngoto end;\r\ninfo[0] = buf[4];\r\ninfo[1] = buf[5];\r\ninfo[2] = buf[6];\r\ninfo[3] = buf[7];\r\nerr = 0;\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nint fcp_avc_transaction(struct fw_unit *unit,\r\nconst void *command, unsigned int command_size,\r\nvoid *response, unsigned int response_size,\r\nunsigned int response_match_bytes)\r\n{\r\nstruct fcp_transaction t;\r\nint tcode, ret, tries = 0;\r\nt.unit = unit;\r\nt.response_buffer = response;\r\nt.response_size = response_size;\r\nt.response_match_bytes = response_match_bytes;\r\nt.state = STATE_PENDING;\r\ninit_waitqueue_head(&t.wait);\r\nif (*(const u8 *)command == 0x00 || *(const u8 *)command == 0x03)\r\nt.deferrable = true;\r\nspin_lock_irq(&transactions_lock);\r\nlist_add_tail(&t.list, &transactions);\r\nspin_unlock_irq(&transactions_lock);\r\nfor (;;) {\r\ntcode = command_size == 4 ? TCODE_WRITE_QUADLET_REQUEST\r\n: TCODE_WRITE_BLOCK_REQUEST;\r\nret = snd_fw_transaction(t.unit, tcode,\r\nCSR_REGISTER_BASE + CSR_FCP_COMMAND,\r\n(void *)command, command_size, 0);\r\nif (ret < 0)\r\nbreak;\r\ndeferred:\r\nwait_event_timeout(t.wait, t.state != STATE_PENDING,\r\nmsecs_to_jiffies(FCP_TIMEOUT_MS));\r\nif (t.state == STATE_DEFERRED) {\r\nt.state = STATE_PENDING;\r\ngoto deferred;\r\n} else if (t.state == STATE_COMPLETE) {\r\nret = t.response_size;\r\nbreak;\r\n} else if (t.state == STATE_BUS_RESET) {\r\nmsleep(ERROR_DELAY_MS);\r\n} else if (++tries >= ERROR_RETRIES) {\r\ndev_err(&t.unit->device, "FCP command timed out\n");\r\nret = -EIO;\r\nbreak;\r\n}\r\n}\r\nspin_lock_irq(&transactions_lock);\r\nlist_del(&t.list);\r\nspin_unlock_irq(&transactions_lock);\r\nreturn ret;\r\n}\r\nvoid fcp_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct fcp_transaction *t;\r\nspin_lock_irq(&transactions_lock);\r\nlist_for_each_entry(t, &transactions, list) {\r\nif (t->unit == unit &&\r\n(t->state == STATE_PENDING ||\r\nt->state == STATE_DEFERRED)) {\r\nt->state = STATE_BUS_RESET;\r\nwake_up(&t->wait);\r\n}\r\n}\r\nspin_unlock_irq(&transactions_lock);\r\n}\r\nstatic bool is_matching_response(struct fcp_transaction *transaction,\r\nconst void *response, size_t length)\r\n{\r\nconst u8 *p1, *p2;\r\nunsigned int mask, i;\r\np1 = response;\r\np2 = transaction->response_buffer;\r\nmask = transaction->response_match_bytes;\r\nfor (i = 0; ; ++i) {\r\nif ((mask & 1) && p1[i] != p2[i])\r\nreturn false;\r\nmask >>= 1;\r\nif (!mask)\r\nreturn true;\r\nif (--length == 0)\r\nreturn false;\r\n}\r\n}\r\nstatic void fcp_response(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct fcp_transaction *t;\r\nunsigned long flags;\r\nif (length < 1 || (*(const u8 *)data & 0xf0) != CTS_AVC)\r\nreturn;\r\nspin_lock_irqsave(&transactions_lock, flags);\r\nlist_for_each_entry(t, &transactions, list) {\r\nstruct fw_device *device = fw_parent_device(t->unit);\r\nif (device->card != card ||\r\ndevice->generation != generation)\r\ncontinue;\r\nsmp_rmb();\r\nif (device->node_id != source)\r\ncontinue;\r\nif (t->state == STATE_PENDING &&\r\nis_matching_response(t, data, length)) {\r\nif (t->deferrable && *(const u8 *)data == 0x0f) {\r\nt->state = STATE_DEFERRED;\r\n} else {\r\nt->state = STATE_COMPLETE;\r\nt->response_size = min_t(unsigned int, length,\r\nt->response_size);\r\nmemcpy(t->response_buffer, data,\r\nt->response_size);\r\n}\r\nwake_up(&t->wait);\r\n}\r\n}\r\nspin_unlock_irqrestore(&transactions_lock, flags);\r\n}\r\nstatic int __init fcp_module_init(void)\r\n{\r\nstatic const struct fw_address_region response_register_region = {\r\n.start = CSR_REGISTER_BASE + CSR_FCP_RESPONSE,\r\n.end = CSR_REGISTER_BASE + CSR_FCP_END,\r\n};\r\nfw_core_add_address_handler(&response_register_handler,\r\n&response_register_region);\r\nreturn 0;\r\n}\r\nstatic void __exit fcp_module_exit(void)\r\n{\r\nWARN_ON(!list_empty(&transactions));\r\nfw_core_remove_address_handler(&response_register_handler);\r\n}
