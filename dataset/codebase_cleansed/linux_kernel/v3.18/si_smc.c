static int si_set_smc_sram_address(struct radeon_device *rdev,\r\nu32 smc_address, u32 limit)\r\n{\r\nif (smc_address & 3)\r\nreturn -EINVAL;\r\nif ((smc_address + 3) > limit)\r\nreturn -EINVAL;\r\nWREG32(SMC_IND_INDEX_0, smc_address);\r\nWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\r\nreturn 0;\r\n}\r\nint si_copy_bytes_to_smc(struct radeon_device *rdev,\r\nu32 smc_start_address,\r\nconst u8 *src, u32 byte_count, u32 limit)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nu32 data, original_data, addr, extra_shift;\r\nif (smc_start_address & 3)\r\nreturn -EINVAL;\r\nif ((smc_start_address + byte_count) > limit)\r\nreturn -EINVAL;\r\naddr = smc_start_address;\r\nspin_lock_irqsave(&rdev->smc_idx_lock, flags);\r\nwhile (byte_count >= 4) {\r\ndata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\r\nret = si_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\ngoto done;\r\nWREG32(SMC_IND_DATA_0, data);\r\nsrc += 4;\r\nbyte_count -= 4;\r\naddr += 4;\r\n}\r\nif (byte_count > 0) {\r\ndata = 0;\r\nret = si_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\ngoto done;\r\noriginal_data = RREG32(SMC_IND_DATA_0);\r\nextra_shift = 8 * (4 - byte_count);\r\nwhile (byte_count > 0) {\r\ndata = (data << 8) + *src++;\r\nbyte_count--;\r\n}\r\ndata <<= extra_shift;\r\ndata |= (original_data & ~((~0UL) << extra_shift));\r\nret = si_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\ngoto done;\r\nWREG32(SMC_IND_DATA_0, data);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\r\nreturn ret;\r\n}\r\nvoid si_start_smc(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\r\ntmp &= ~RST_REG;\r\nWREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);\r\n}\r\nvoid si_reset_smc(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\nRREG32(CB_CGTT_SCLK_CTRL);\r\nRREG32(CB_CGTT_SCLK_CTRL);\r\nRREG32(CB_CGTT_SCLK_CTRL);\r\nRREG32(CB_CGTT_SCLK_CTRL);\r\ntmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\r\ntmp |= RST_REG;\r\nWREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);\r\n}\r\nint si_program_jump_on_start(struct radeon_device *rdev)\r\n{\r\nstatic u8 data[] = { 0x0E, 0x00, 0x40, 0x40 };\r\nreturn si_copy_bytes_to_smc(rdev, 0x0, data, 4, sizeof(data)+1);\r\n}\r\nvoid si_stop_smc_clock(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\r\ntmp |= CK_DISABLE;\r\nWREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);\r\n}\r\nvoid si_start_smc_clock(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\r\ntmp &= ~CK_DISABLE;\r\nWREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);\r\n}\r\nbool si_is_smc_running(struct radeon_device *rdev)\r\n{\r\nu32 rst = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\r\nu32 clk = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\r\nif (!(rst & RST_REG) && !(clk & CK_DISABLE))\r\nreturn true;\r\nreturn false;\r\n}\r\nPPSMC_Result si_send_msg_to_smc(struct radeon_device *rdev, PPSMC_Msg msg)\r\n{\r\nu32 tmp;\r\nint i;\r\nif (!si_is_smc_running(rdev))\r\nreturn PPSMC_Result_Failed;\r\nWREG32(SMC_MESSAGE_0, msg);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = RREG32(SMC_RESP_0);\r\nif (tmp != 0)\r\nbreak;\r\nudelay(1);\r\n}\r\ntmp = RREG32(SMC_RESP_0);\r\nreturn (PPSMC_Result)tmp;\r\n}\r\nPPSMC_Result si_wait_for_smc_inactive(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\nint i;\r\nif (!si_is_smc_running(rdev))\r\nreturn PPSMC_Result_OK;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\r\nif ((tmp & CKEN) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn PPSMC_Result_OK;\r\n}\r\nint si_load_smc_ucode(struct radeon_device *rdev, u32 limit)\r\n{\r\nunsigned long flags;\r\nu32 ucode_start_address;\r\nu32 ucode_size;\r\nconst u8 *src;\r\nu32 data;\r\nif (!rdev->smc_fw)\r\nreturn -EINVAL;\r\nif (rdev->new_fw) {\r\nconst struct smc_firmware_header_v1_0 *hdr =\r\n(const struct smc_firmware_header_v1_0 *)rdev->smc_fw->data;\r\nradeon_ucode_print_smc_hdr(&hdr->header);\r\nucode_start_address = le32_to_cpu(hdr->ucode_start_addr);\r\nucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);\r\nsrc = (const u8 *)\r\n(rdev->smc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\r\n} else {\r\nswitch (rdev->family) {\r\ncase CHIP_TAHITI:\r\nucode_start_address = TAHITI_SMC_UCODE_START;\r\nucode_size = TAHITI_SMC_UCODE_SIZE;\r\nbreak;\r\ncase CHIP_PITCAIRN:\r\nucode_start_address = PITCAIRN_SMC_UCODE_START;\r\nucode_size = PITCAIRN_SMC_UCODE_SIZE;\r\nbreak;\r\ncase CHIP_VERDE:\r\nucode_start_address = VERDE_SMC_UCODE_START;\r\nucode_size = VERDE_SMC_UCODE_SIZE;\r\nbreak;\r\ncase CHIP_OLAND:\r\nucode_start_address = OLAND_SMC_UCODE_START;\r\nucode_size = OLAND_SMC_UCODE_SIZE;\r\nbreak;\r\ncase CHIP_HAINAN:\r\nucode_start_address = HAINAN_SMC_UCODE_START;\r\nucode_size = HAINAN_SMC_UCODE_SIZE;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown asic in smc ucode loader\n");\r\nBUG();\r\n}\r\nsrc = (const u8 *)rdev->smc_fw->data;\r\n}\r\nif (ucode_size & 3)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&rdev->smc_idx_lock, flags);\r\nWREG32(SMC_IND_INDEX_0, ucode_start_address);\r\nWREG32_P(SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, ~AUTO_INCREMENT_IND_0);\r\nwhile (ucode_size >= 4) {\r\ndata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\r\nWREG32(SMC_IND_DATA_0, data);\r\nsrc += 4;\r\nucode_size -= 4;\r\n}\r\nWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\r\nspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\r\nreturn 0;\r\n}\r\nint si_read_smc_sram_dword(struct radeon_device *rdev, u32 smc_address,\r\nu32 *value, u32 limit)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&rdev->smc_idx_lock, flags);\r\nret = si_set_smc_sram_address(rdev, smc_address, limit);\r\nif (ret == 0)\r\n*value = RREG32(SMC_IND_DATA_0);\r\nspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\r\nreturn ret;\r\n}\r\nint si_write_smc_sram_dword(struct radeon_device *rdev, u32 smc_address,\r\nu32 value, u32 limit)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&rdev->smc_idx_lock, flags);\r\nret = si_set_smc_sram_address(rdev, smc_address, limit);\r\nif (ret == 0)\r\nWREG32(SMC_IND_DATA_0, value);\r\nspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\r\nreturn ret;\r\n}
