static void f81232_update_line_status(struct usb_serial_port *port,\r\nunsigned char *data,\r\nunsigned int actual_length)\r\n{\r\n}\r\nstatic void f81232_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned int actual_length = urb->actual_length;\r\nint status = urb->status;\r\nint retval;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(&port->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\nf81232_update_line_status(port, data, actual_length);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&urb->dev->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic void f81232_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nunsigned char *data = urb->transfer_buffer;\r\nchar tty_flag = TTY_NORMAL;\r\nunsigned long flags;\r\nu8 line_status;\r\nint i;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nline_status = priv->line_status;\r\npriv->line_status &= ~UART_STATE_TRANSIENT_MASK;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (!urb->actual_length)\r\nreturn;\r\nif (line_status & UART_BREAK_ERROR)\r\ntty_flag = TTY_BREAK;\r\nelse if (line_status & UART_PARITY_ERROR)\r\ntty_flag = TTY_PARITY;\r\nelse if (line_status & UART_FRAME_ERROR)\r\ntty_flag = TTY_FRAME;\r\ndev_dbg(&port->dev, "%s - tty_flag = %d\n", __func__, tty_flag);\r\nif (line_status & UART_OVERRUN_ERROR)\r\ntty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\r\nif (port->port.console && port->sysrq) {\r\nfor (i = 0; i < urb->actual_length; ++i)\r\nif (!usb_serial_handle_sysrq_char(port, data[i]))\r\ntty_insert_flip_char(&port->port, data[i],\r\ntty_flag);\r\n} else {\r\ntty_insert_flip_string_fixed_flag(&port->port, data, tty_flag,\r\nurb->actual_length);\r\n}\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic int set_control_lines(struct usb_device *dev, u8 value)\r\n{\r\nreturn 0;\r\n}\r\nstatic void f81232_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\n}\r\nstatic void f81232_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nif (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))\r\nreturn;\r\nif (old_termios)\r\ntty_termios_copy_hw(&tty->termios, old_termios);\r\n}\r\nstatic int f81232_tiocmget(struct tty_struct *tty)\r\n{\r\nreturn 0;\r\n}\r\nstatic int f81232_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nreturn 0;\r\n}\r\nstatic int f81232_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint result;\r\nif (tty)\r\nf81232_set_termios(tty, port, NULL);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev, "%s - failed submitting interrupt urb,"\r\n" error %d\n", __func__, result);\r\nreturn result;\r\n}\r\nresult = usb_serial_generic_open(tty, port);\r\nif (result) {\r\nusb_kill_urb(port->interrupt_in_urb);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic void f81232_close(struct usb_serial_port *port)\r\n{\r\nusb_serial_generic_close(port);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic void f81232_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (on)\r\npriv->line_control |= (CONTROL_DTR | CONTROL_RTS);\r\nelse\r\npriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nset_control_lines(port->serial->dev, control);\r\n}\r\nstatic int f81232_carrier_raised(struct usb_serial_port *port)\r\n{\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nif (priv->line_status & UART_DCD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int f81232_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct serial_struct ser;\r\nstruct usb_serial_port *port = tty->driver_data;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmemset(&ser, 0, sizeof ser);\r\nser.type = PORT_16654;\r\nser.line = port->minor;\r\nser.port = port->port_number;\r\nser.baud_base = 460800;\r\nif (copy_to_user((void __user *)arg, &ser, sizeof ser))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int f81232_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct f81232_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\nusb_set_serial_port_data(port, priv);\r\nport->port.drain_delay = 256;\r\nreturn 0;\r\n}\r\nstatic int f81232_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct f81232_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}
