struct snd_seq_prioq *snd_seq_prioq_new(void)\r\n{\r\nstruct snd_seq_prioq *f;\r\nf = kzalloc(sizeof(*f), GFP_KERNEL);\r\nif (f == NULL) {\r\npr_debug("ALSA: seq: malloc failed for snd_seq_prioq_new()\n");\r\nreturn NULL;\r\n}\r\nspin_lock_init(&f->lock);\r\nf->head = NULL;\r\nf->tail = NULL;\r\nf->cells = 0;\r\nreturn f;\r\n}\r\nvoid snd_seq_prioq_delete(struct snd_seq_prioq **fifo)\r\n{\r\nstruct snd_seq_prioq *f = *fifo;\r\n*fifo = NULL;\r\nif (f == NULL) {\r\npr_debug("ALSA: seq: snd_seq_prioq_delete() called with NULL prioq\n");\r\nreturn;\r\n}\r\nif (f->cells > 0) {\r\nwhile (f->cells > 0)\r\nsnd_seq_cell_free(snd_seq_prioq_cell_out(f));\r\n}\r\nkfree(f);\r\n}\r\nstatic inline int compare_timestamp(struct snd_seq_event *a,\r\nstruct snd_seq_event *b)\r\n{\r\nif ((a->flags & SNDRV_SEQ_TIME_STAMP_MASK) == SNDRV_SEQ_TIME_STAMP_TICK) {\r\nreturn (snd_seq_compare_tick_time(&a->time.tick, &b->time.tick));\r\n} else {\r\nreturn (snd_seq_compare_real_time(&a->time.time, &b->time.time));\r\n}\r\n}\r\nstatic inline int compare_timestamp_rel(struct snd_seq_event *a,\r\nstruct snd_seq_event *b)\r\n{\r\nif ((a->flags & SNDRV_SEQ_TIME_STAMP_MASK) == SNDRV_SEQ_TIME_STAMP_TICK) {\r\nif (a->time.tick > b->time.tick)\r\nreturn 1;\r\nelse if (a->time.tick == b->time.tick)\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n} else {\r\nif (a->time.time.tv_sec > b->time.time.tv_sec)\r\nreturn 1;\r\nelse if (a->time.time.tv_sec == b->time.time.tv_sec) {\r\nif (a->time.time.tv_nsec > b->time.time.tv_nsec)\r\nreturn 1;\r\nelse if (a->time.time.tv_nsec == b->time.time.tv_nsec)\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n} else\r\nreturn -1;\r\n}\r\n}\r\nint snd_seq_prioq_cell_in(struct snd_seq_prioq * f,\r\nstruct snd_seq_event_cell * cell)\r\n{\r\nstruct snd_seq_event_cell *cur, *prev;\r\nunsigned long flags;\r\nint count;\r\nint prior;\r\nif (snd_BUG_ON(!f || !cell))\r\nreturn -EINVAL;\r\nprior = (cell->event.flags & SNDRV_SEQ_PRIORITY_MASK);\r\nspin_lock_irqsave(&f->lock, flags);\r\nif (f->tail && !prior) {\r\nif (compare_timestamp(&cell->event, &f->tail->event)) {\r\nf->tail->next = cell;\r\nf->tail = cell;\r\ncell->next = NULL;\r\nf->cells++;\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nreturn 0;\r\n}\r\n}\r\nprev = NULL;\r\ncur = f->head;\r\ncount = 10000;\r\nwhile (cur != NULL) {\r\nint rel = compare_timestamp_rel(&cell->event, &cur->event);\r\nif (rel < 0)\r\nbreak;\r\nelse if (rel == 0 && prior)\r\nbreak;\r\nprev = cur;\r\ncur = cur->next;\r\nif (! --count) {\r\nspin_unlock_irqrestore(&f->lock, flags);\r\npr_err("ALSA: seq: cannot find a pointer.. infinite loop?\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (prev != NULL)\r\nprev->next = cell;\r\ncell->next = cur;\r\nif (f->head == cur)\r\nf->head = cell;\r\nif (cur == NULL)\r\nf->tail = cell;\r\nf->cells++;\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nreturn 0;\r\n}\r\nstruct snd_seq_event_cell *snd_seq_prioq_cell_out(struct snd_seq_prioq *f)\r\n{\r\nstruct snd_seq_event_cell *cell;\r\nunsigned long flags;\r\nif (f == NULL) {\r\npr_debug("ALSA: seq: snd_seq_prioq_cell_in() called with NULL prioq\n");\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&f->lock, flags);\r\ncell = f->head;\r\nif (cell) {\r\nf->head = cell->next;\r\nif (f->tail == cell)\r\nf->tail = NULL;\r\ncell->next = NULL;\r\nf->cells--;\r\n}\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nreturn cell;\r\n}\r\nint snd_seq_prioq_avail(struct snd_seq_prioq * f)\r\n{\r\nif (f == NULL) {\r\npr_debug("ALSA: seq: snd_seq_prioq_cell_in() called with NULL prioq\n");\r\nreturn 0;\r\n}\r\nreturn f->cells;\r\n}\r\nstruct snd_seq_event_cell *snd_seq_prioq_cell_peek(struct snd_seq_prioq * f)\r\n{\r\nif (f == NULL) {\r\npr_debug("ALSA: seq: snd_seq_prioq_cell_in() called with NULL prioq\n");\r\nreturn NULL;\r\n}\r\nreturn f->head;\r\n}\r\nstatic inline int prioq_match(struct snd_seq_event_cell *cell,\r\nint client, int timestamp)\r\n{\r\nif (cell->event.source.client == client ||\r\ncell->event.dest.client == client)\r\nreturn 1;\r\nif (!timestamp)\r\nreturn 0;\r\nswitch (cell->event.flags & SNDRV_SEQ_TIME_STAMP_MASK) {\r\ncase SNDRV_SEQ_TIME_STAMP_TICK:\r\nif (cell->event.time.tick)\r\nreturn 1;\r\nbreak;\r\ncase SNDRV_SEQ_TIME_STAMP_REAL:\r\nif (cell->event.time.time.tv_sec ||\r\ncell->event.time.time.tv_nsec)\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_seq_prioq_leave(struct snd_seq_prioq * f, int client, int timestamp)\r\n{\r\nregister struct snd_seq_event_cell *cell, *next;\r\nunsigned long flags;\r\nstruct snd_seq_event_cell *prev = NULL;\r\nstruct snd_seq_event_cell *freefirst = NULL, *freeprev = NULL, *freenext;\r\nspin_lock_irqsave(&f->lock, flags);\r\ncell = f->head;\r\nwhile (cell) {\r\nnext = cell->next;\r\nif (prioq_match(cell, client, timestamp)) {\r\nif (cell == f->head) {\r\nf->head = cell->next;\r\n} else {\r\nprev->next = cell->next;\r\n}\r\nif (cell == f->tail)\r\nf->tail = cell->next;\r\nf->cells--;\r\ncell->next = NULL;\r\nif (freefirst == NULL) {\r\nfreefirst = cell;\r\n} else {\r\nfreeprev->next = cell;\r\n}\r\nfreeprev = cell;\r\n} else {\r\n#if 0\r\npr_debug("ALSA: seq: type = %i, source = %i, dest = %i, "\r\n"client = %i\n",\r\ncell->event.type,\r\ncell->event.source.client,\r\ncell->event.dest.client,\r\nclient);\r\n#endif\r\nprev = cell;\r\n}\r\ncell = next;\r\n}\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nwhile (freefirst) {\r\nfreenext = freefirst->next;\r\nsnd_seq_cell_free(freefirst);\r\nfreefirst = freenext;\r\n}\r\n}\r\nstatic int prioq_remove_match(struct snd_seq_remove_events *info,\r\nstruct snd_seq_event *ev)\r\n{\r\nint res;\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_DEST) {\r\nif (ev->dest.client != info->dest.client ||\r\nev->dest.port != info->dest.port)\r\nreturn 0;\r\n}\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_DEST_CHANNEL) {\r\nif (! snd_seq_ev_is_channel_type(ev))\r\nreturn 0;\r\nif (ev->data.note.channel != info->channel)\r\nreturn 0;\r\n}\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_TIME_AFTER) {\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_TIME_TICK)\r\nres = snd_seq_compare_tick_time(&ev->time.tick, &info->time.tick);\r\nelse\r\nres = snd_seq_compare_real_time(&ev->time.time, &info->time.time);\r\nif (!res)\r\nreturn 0;\r\n}\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_TIME_BEFORE) {\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_TIME_TICK)\r\nres = snd_seq_compare_tick_time(&ev->time.tick, &info->time.tick);\r\nelse\r\nres = snd_seq_compare_real_time(&ev->time.time, &info->time.time);\r\nif (res)\r\nreturn 0;\r\n}\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_EVENT_TYPE) {\r\nif (ev->type != info->type)\r\nreturn 0;\r\n}\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_IGNORE_OFF) {\r\nswitch (ev->type) {\r\ncase SNDRV_SEQ_EVENT_NOTEOFF:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (info->remove_mode & SNDRV_SEQ_REMOVE_TAG_MATCH) {\r\nif (info->tag != ev->tag)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid snd_seq_prioq_remove_events(struct snd_seq_prioq * f, int client,\r\nstruct snd_seq_remove_events *info)\r\n{\r\nstruct snd_seq_event_cell *cell, *next;\r\nunsigned long flags;\r\nstruct snd_seq_event_cell *prev = NULL;\r\nstruct snd_seq_event_cell *freefirst = NULL, *freeprev = NULL, *freenext;\r\nspin_lock_irqsave(&f->lock, flags);\r\ncell = f->head;\r\nwhile (cell) {\r\nnext = cell->next;\r\nif (cell->event.source.client == client &&\r\nprioq_remove_match(info, &cell->event)) {\r\nif (cell == f->head) {\r\nf->head = cell->next;\r\n} else {\r\nprev->next = cell->next;\r\n}\r\nif (cell == f->tail)\r\nf->tail = cell->next;\r\nf->cells--;\r\ncell->next = NULL;\r\nif (freefirst == NULL) {\r\nfreefirst = cell;\r\n} else {\r\nfreeprev->next = cell;\r\n}\r\nfreeprev = cell;\r\n} else {\r\nprev = cell;\r\n}\r\ncell = next;\r\n}\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nwhile (freefirst) {\r\nfreenext = freefirst->next;\r\nsnd_seq_cell_free(freefirst);\r\nfreefirst = freenext;\r\n}\r\n}
