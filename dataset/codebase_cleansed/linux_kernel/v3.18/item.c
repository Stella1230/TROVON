static inline struct config_item *to_item(struct list_head *entry)\r\n{\r\nreturn container_of(entry, struct config_item, ci_entry);\r\n}\r\nvoid config_item_init(struct config_item *item)\r\n{\r\nkref_init(&item->ci_kref);\r\nINIT_LIST_HEAD(&item->ci_entry);\r\n}\r\nint config_item_set_name(struct config_item *item, const char *fmt, ...)\r\n{\r\nint error = 0;\r\nint limit = CONFIGFS_ITEM_NAME_LEN;\r\nint need;\r\nva_list args;\r\nchar *name;\r\nva_start(args, fmt);\r\nneed = vsnprintf(item->ci_namebuf, limit, fmt, args);\r\nva_end(args);\r\nif (need < limit)\r\nname = item->ci_namebuf;\r\nelse {\r\nlimit = need + 1;\r\nname = kmalloc(limit, GFP_KERNEL);\r\nif (!name) {\r\nerror = -ENOMEM;\r\ngoto Done;\r\n}\r\nva_start(args, fmt);\r\nneed = vsnprintf(name, limit, fmt, args);\r\nva_end(args);\r\nif (need >= limit) {\r\nkfree(name);\r\nerror = -EFAULT;\r\ngoto Done;\r\n}\r\n}\r\nif (item->ci_name && item->ci_name != item->ci_namebuf)\r\nkfree(item->ci_name);\r\nitem->ci_name = name;\r\nDone:\r\nreturn error;\r\n}\r\nvoid config_item_init_type_name(struct config_item *item,\r\nconst char *name,\r\nstruct config_item_type *type)\r\n{\r\nconfig_item_set_name(item, name);\r\nitem->ci_type = type;\r\nconfig_item_init(item);\r\n}\r\nvoid config_group_init_type_name(struct config_group *group, const char *name,\r\nstruct config_item_type *type)\r\n{\r\nconfig_item_set_name(&group->cg_item, name);\r\ngroup->cg_item.ci_type = type;\r\nconfig_group_init(group);\r\n}\r\nstruct config_item *config_item_get(struct config_item *item)\r\n{\r\nif (item)\r\nkref_get(&item->ci_kref);\r\nreturn item;\r\n}\r\nstatic void config_item_cleanup(struct config_item *item)\r\n{\r\nstruct config_item_type *t = item->ci_type;\r\nstruct config_group *s = item->ci_group;\r\nstruct config_item *parent = item->ci_parent;\r\npr_debug("config_item %s: cleaning up\n", config_item_name(item));\r\nif (item->ci_name != item->ci_namebuf)\r\nkfree(item->ci_name);\r\nitem->ci_name = NULL;\r\nif (t && t->ct_item_ops && t->ct_item_ops->release)\r\nt->ct_item_ops->release(item);\r\nif (s)\r\nconfig_group_put(s);\r\nif (parent)\r\nconfig_item_put(parent);\r\n}\r\nstatic void config_item_release(struct kref *kref)\r\n{\r\nconfig_item_cleanup(container_of(kref, struct config_item, ci_kref));\r\n}\r\nvoid config_item_put(struct config_item *item)\r\n{\r\nif (item)\r\nkref_put(&item->ci_kref, config_item_release);\r\n}\r\nvoid config_group_init(struct config_group *group)\r\n{\r\nconfig_item_init(&group->cg_item);\r\nINIT_LIST_HEAD(&group->cg_children);\r\n}\r\nstruct config_item *config_group_find_item(struct config_group *group,\r\nconst char *name)\r\n{\r\nstruct list_head *entry;\r\nstruct config_item *ret = NULL;\r\nlist_for_each(entry, &group->cg_children) {\r\nstruct config_item *item = to_item(entry);\r\nif (config_item_name(item) &&\r\n!strcmp(config_item_name(item), name)) {\r\nret = config_item_get(item);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}
