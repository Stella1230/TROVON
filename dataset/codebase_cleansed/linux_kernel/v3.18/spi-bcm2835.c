static inline u32 bcm2835_rd(struct bcm2835_spi *bs, unsigned reg)\r\n{\r\nreturn readl(bs->regs + reg);\r\n}\r\nstatic inline void bcm2835_wr(struct bcm2835_spi *bs, unsigned reg, u32 val)\r\n{\r\nwritel(val, bs->regs + reg);\r\n}\r\nstatic inline void bcm2835_rd_fifo(struct bcm2835_spi *bs, int len)\r\n{\r\nu8 byte;\r\nwhile (len--) {\r\nbyte = bcm2835_rd(bs, BCM2835_SPI_FIFO);\r\nif (bs->rx_buf)\r\n*bs->rx_buf++ = byte;\r\n}\r\n}\r\nstatic inline void bcm2835_wr_fifo(struct bcm2835_spi *bs, int len)\r\n{\r\nu8 byte;\r\nif (len > bs->len)\r\nlen = bs->len;\r\nwhile (len--) {\r\nbyte = bs->tx_buf ? *bs->tx_buf++ : 0;\r\nbcm2835_wr(bs, BCM2835_SPI_FIFO, byte);\r\nbs->len--;\r\n}\r\n}\r\nstatic irqreturn_t bcm2835_spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nu32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);\r\nif (bs->len && (cs & BCM2835_SPI_CS_RXR)) {\r\nbcm2835_rd_fifo(bs, 12);\r\nbcm2835_wr_fifo(bs, 12);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (cs & BCM2835_SPI_CS_DONE) {\r\nif (bs->len) {\r\nbcm2835_wr_fifo(bs, 16);\r\n} else {\r\ncs &= ~(BCM2835_SPI_CS_INTR | BCM2835_SPI_CS_INTD);\r\nbcm2835_wr(bs, BCM2835_SPI_CS, cs);\r\ncomplete(&bs->done);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int bcm2835_spi_start_transfer(struct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(spi->master);\r\nunsigned long spi_hz, clk_hz, cdiv;\r\nu32 cs = BCM2835_SPI_CS_INTR | BCM2835_SPI_CS_INTD | BCM2835_SPI_CS_TA;\r\nspi_hz = tfr->speed_hz;\r\nclk_hz = clk_get_rate(bs->clk);\r\nif (spi_hz >= clk_hz / 2) {\r\ncdiv = 2;\r\n} else if (spi_hz) {\r\ncdiv = roundup_pow_of_two(DIV_ROUND_UP(clk_hz, spi_hz));\r\nif (cdiv >= 65536)\r\ncdiv = 0;\r\n} else\r\ncdiv = 0;\r\nif (spi->mode & SPI_CPOL)\r\ncs |= BCM2835_SPI_CS_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\ncs |= BCM2835_SPI_CS_CPHA;\r\nif (!(spi->mode & SPI_NO_CS)) {\r\nif (spi->mode & SPI_CS_HIGH) {\r\ncs |= BCM2835_SPI_CS_CSPOL;\r\ncs |= BCM2835_SPI_CS_CSPOL0 << spi->chip_select;\r\n}\r\ncs |= spi->chip_select;\r\n}\r\nreinit_completion(&bs->done);\r\nbs->tx_buf = tfr->tx_buf;\r\nbs->rx_buf = tfr->rx_buf;\r\nbs->len = tfr->len;\r\nbcm2835_wr(bs, BCM2835_SPI_CLK, cdiv);\r\nbcm2835_wr(bs, BCM2835_SPI_CS, cs);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_spi_finish_transfer(struct spi_device *spi,\r\nstruct spi_transfer *tfr, bool cs_change)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(spi->master);\r\nu32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);\r\nwhile (cs & BCM2835_SPI_CS_RXD) {\r\nbcm2835_rd_fifo(bs, 1);\r\ncs = bcm2835_rd(bs, BCM2835_SPI_CS);\r\n}\r\nif (tfr->delay_usecs)\r\nudelay(tfr->delay_usecs);\r\nif (cs_change)\r\nbcm2835_wr(bs, BCM2835_SPI_CS, cs & ~BCM2835_SPI_CS_TA);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_spi_transfer_one(struct spi_master *master,\r\nstruct spi_message *mesg)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nstruct spi_transfer *tfr;\r\nstruct spi_device *spi = mesg->spi;\r\nint err = 0;\r\nunsigned int timeout;\r\nbool cs_change;\r\nlist_for_each_entry(tfr, &mesg->transfers, transfer_list) {\r\nerr = bcm2835_spi_start_transfer(spi, tfr);\r\nif (err)\r\ngoto out;\r\ntimeout = wait_for_completion_timeout(&bs->done,\r\nmsecs_to_jiffies(BCM2835_SPI_TIMEOUT_MS));\r\nif (!timeout) {\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\ncs_change = tfr->cs_change ||\r\nlist_is_last(&tfr->transfer_list, &mesg->transfers);\r\nerr = bcm2835_spi_finish_transfer(spi, tfr, cs_change);\r\nif (err)\r\ngoto out;\r\nmesg->actual_length += (tfr->len - bs->len);\r\n}\r\nout:\r\nbcm2835_wr(bs, BCM2835_SPI_CS,\r\nBCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);\r\nmesg->status = err;\r\nspi_finalize_current_message(master);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct bcm2835_spi *bs;\r\nstruct resource *res;\r\nint err;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*bs));\r\nif (!master) {\r\ndev_err(&pdev->dev, "spi_alloc_master() failed\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nmaster->mode_bits = BCM2835_SPI_MODE_BITS;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->num_chipselect = 3;\r\nmaster->transfer_one_message = bcm2835_spi_transfer_one;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nbs = spi_master_get_devdata(master);\r\ninit_completion(&bs->done);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbs->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(bs->regs)) {\r\nerr = PTR_ERR(bs->regs);\r\ngoto out_master_put;\r\n}\r\nbs->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(bs->clk)) {\r\nerr = PTR_ERR(bs->clk);\r\ndev_err(&pdev->dev, "could not get clk: %d\n", err);\r\ngoto out_master_put;\r\n}\r\nbs->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (bs->irq <= 0) {\r\ndev_err(&pdev->dev, "could not get IRQ: %d\n", bs->irq);\r\nerr = bs->irq ? bs->irq : -ENODEV;\r\ngoto out_master_put;\r\n}\r\nclk_prepare_enable(bs->clk);\r\nerr = devm_request_irq(&pdev->dev, bs->irq, bcm2835_spi_interrupt, 0,\r\ndev_name(&pdev->dev), master);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not request IRQ: %d\n", err);\r\ngoto out_clk_disable;\r\n}\r\nbcm2835_wr(bs, BCM2835_SPI_CS,\r\nBCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);\r\nerr = devm_spi_register_master(&pdev->dev, master);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not register SPI master: %d\n", err);\r\ngoto out_clk_disable;\r\n}\r\nreturn 0;\r\nout_clk_disable:\r\nclk_disable_unprepare(bs->clk);\r\nout_master_put:\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nstatic int bcm2835_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nbcm2835_wr(bs, BCM2835_SPI_CS,\r\nBCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);\r\nclk_disable_unprepare(bs->clk);\r\nreturn 0;\r\n}
