static bool check_need_swap(int file_endian)\r\n{\r\nconst int data = 1;\r\nu8 *check = (u8 *)&data;\r\nint host_endian;\r\nif (check[0] == 1)\r\nhost_endian = ELFDATA2LSB;\r\nelse\r\nhost_endian = ELFDATA2MSB;\r\nreturn host_endian != file_endian;\r\n}\r\nstatic int read_build_id(void *note_data, size_t note_len, void *bf,\r\nsize_t size, bool need_swap)\r\n{\r\nstruct {\r\nu32 n_namesz;\r\nu32 n_descsz;\r\nu32 n_type;\r\n} *nhdr;\r\nvoid *ptr;\r\nptr = note_data;\r\nwhile (ptr < (note_data + note_len)) {\r\nconst char *name;\r\nsize_t namesz, descsz;\r\nnhdr = ptr;\r\nif (need_swap) {\r\nnhdr->n_namesz = bswap_32(nhdr->n_namesz);\r\nnhdr->n_descsz = bswap_32(nhdr->n_descsz);\r\nnhdr->n_type = bswap_32(nhdr->n_type);\r\n}\r\nnamesz = NOTE_ALIGN(nhdr->n_namesz);\r\ndescsz = NOTE_ALIGN(nhdr->n_descsz);\r\nptr += sizeof(*nhdr);\r\nname = ptr;\r\nptr += namesz;\r\nif (nhdr->n_type == NT_GNU_BUILD_ID &&\r\nnhdr->n_namesz == sizeof("GNU")) {\r\nif (memcmp(name, "GNU", sizeof("GNU")) == 0) {\r\nsize_t sz = min(size, descsz);\r\nmemcpy(bf, ptr, sz);\r\nmemset(bf + sz, 0, size - sz);\r\nreturn 0;\r\n}\r\n}\r\nptr += descsz;\r\n}\r\nreturn -1;\r\n}\r\nint filename__read_debuglink(const char *filename __maybe_unused,\r\nchar *debuglink __maybe_unused,\r\nsize_t size __maybe_unused)\r\n{\r\nreturn -1;\r\n}\r\nint filename__read_build_id(const char *filename, void *bf, size_t size)\r\n{\r\nFILE *fp;\r\nint ret = -1;\r\nbool need_swap = false;\r\nu8 e_ident[EI_NIDENT];\r\nsize_t buf_size;\r\nvoid *buf;\r\nint i;\r\nfp = fopen(filename, "r");\r\nif (fp == NULL)\r\nreturn -1;\r\nif (fread(e_ident, sizeof(e_ident), 1, fp) != 1)\r\ngoto out;\r\nif (memcmp(e_ident, ELFMAG, SELFMAG) ||\r\ne_ident[EI_VERSION] != EV_CURRENT)\r\ngoto out;\r\nneed_swap = check_need_swap(e_ident[EI_DATA]);\r\nfseek(fp, 0, SEEK_SET);\r\nif (e_ident[EI_CLASS] == ELFCLASS32) {\r\nElf32_Ehdr ehdr;\r\nElf32_Phdr *phdr;\r\nif (fread(&ehdr, sizeof(ehdr), 1, fp) != 1)\r\ngoto out;\r\nif (need_swap) {\r\nehdr.e_phoff = bswap_32(ehdr.e_phoff);\r\nehdr.e_phentsize = bswap_16(ehdr.e_phentsize);\r\nehdr.e_phnum = bswap_16(ehdr.e_phnum);\r\n}\r\nbuf_size = ehdr.e_phentsize * ehdr.e_phnum;\r\nbuf = malloc(buf_size);\r\nif (buf == NULL)\r\ngoto out;\r\nfseek(fp, ehdr.e_phoff, SEEK_SET);\r\nif (fread(buf, buf_size, 1, fp) != 1)\r\ngoto out_free;\r\nfor (i = 0, phdr = buf; i < ehdr.e_phnum; i++, phdr++) {\r\nvoid *tmp;\r\nif (need_swap) {\r\nphdr->p_type = bswap_32(phdr->p_type);\r\nphdr->p_offset = bswap_32(phdr->p_offset);\r\nphdr->p_filesz = bswap_32(phdr->p_filesz);\r\n}\r\nif (phdr->p_type != PT_NOTE)\r\ncontinue;\r\nbuf_size = phdr->p_filesz;\r\ntmp = realloc(buf, buf_size);\r\nif (tmp == NULL)\r\ngoto out_free;\r\nbuf = tmp;\r\nfseek(fp, phdr->p_offset, SEEK_SET);\r\nif (fread(buf, buf_size, 1, fp) != 1)\r\ngoto out_free;\r\nret = read_build_id(buf, buf_size, bf, size, need_swap);\r\nif (ret == 0)\r\nret = size;\r\nbreak;\r\n}\r\n} else {\r\nElf64_Ehdr ehdr;\r\nElf64_Phdr *phdr;\r\nif (fread(&ehdr, sizeof(ehdr), 1, fp) != 1)\r\ngoto out;\r\nif (need_swap) {\r\nehdr.e_phoff = bswap_64(ehdr.e_phoff);\r\nehdr.e_phentsize = bswap_16(ehdr.e_phentsize);\r\nehdr.e_phnum = bswap_16(ehdr.e_phnum);\r\n}\r\nbuf_size = ehdr.e_phentsize * ehdr.e_phnum;\r\nbuf = malloc(buf_size);\r\nif (buf == NULL)\r\ngoto out;\r\nfseek(fp, ehdr.e_phoff, SEEK_SET);\r\nif (fread(buf, buf_size, 1, fp) != 1)\r\ngoto out_free;\r\nfor (i = 0, phdr = buf; i < ehdr.e_phnum; i++, phdr++) {\r\nvoid *tmp;\r\nif (need_swap) {\r\nphdr->p_type = bswap_32(phdr->p_type);\r\nphdr->p_offset = bswap_64(phdr->p_offset);\r\nphdr->p_filesz = bswap_64(phdr->p_filesz);\r\n}\r\nif (phdr->p_type != PT_NOTE)\r\ncontinue;\r\nbuf_size = phdr->p_filesz;\r\ntmp = realloc(buf, buf_size);\r\nif (tmp == NULL)\r\ngoto out_free;\r\nbuf = tmp;\r\nfseek(fp, phdr->p_offset, SEEK_SET);\r\nif (fread(buf, buf_size, 1, fp) != 1)\r\ngoto out_free;\r\nret = read_build_id(buf, buf_size, bf, size, need_swap);\r\nif (ret == 0)\r\nret = size;\r\nbreak;\r\n}\r\n}\r\nout_free:\r\nfree(buf);\r\nout:\r\nfclose(fp);\r\nreturn ret;\r\n}\r\nint sysfs__read_build_id(const char *filename, void *build_id, size_t size)\r\n{\r\nint fd;\r\nint ret = -1;\r\nstruct stat stbuf;\r\nsize_t buf_size;\r\nvoid *buf;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\nreturn -1;\r\nif (fstat(fd, &stbuf) < 0)\r\ngoto out;\r\nbuf_size = stbuf.st_size;\r\nbuf = malloc(buf_size);\r\nif (buf == NULL)\r\ngoto out;\r\nif (read(fd, buf, buf_size) != (ssize_t) buf_size)\r\ngoto out_free;\r\nret = read_build_id(buf, buf_size, build_id, size, false);\r\nout_free:\r\nfree(buf);\r\nout:\r\nclose(fd);\r\nreturn ret;\r\n}\r\nint symsrc__init(struct symsrc *ss, struct dso *dso __maybe_unused,\r\nconst char *name,\r\nenum dso_binary_type type)\r\n{\r\nint fd = open(name, O_RDONLY);\r\nif (fd < 0)\r\nreturn -1;\r\nss->name = strdup(name);\r\nif (!ss->name)\r\ngoto out_close;\r\nss->fd = fd;\r\nss->type = type;\r\nreturn 0;\r\nout_close:\r\nclose(fd);\r\nreturn -1;\r\n}\r\nbool symsrc__possibly_runtime(struct symsrc *ss __maybe_unused)\r\n{\r\nreturn true;\r\n}\r\nbool symsrc__has_symtab(struct symsrc *ss __maybe_unused)\r\n{\r\nreturn false;\r\n}\r\nvoid symsrc__destroy(struct symsrc *ss)\r\n{\r\nzfree(&ss->name);\r\nclose(ss->fd);\r\n}\r\nint dso__synthesize_plt_symbols(struct dso *dso __maybe_unused,\r\nstruct symsrc *ss __maybe_unused,\r\nstruct map *map __maybe_unused,\r\nsymbol_filter_t filter __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int fd__is_64_bit(int fd)\r\n{\r\nu8 e_ident[EI_NIDENT];\r\nif (lseek(fd, 0, SEEK_SET))\r\nreturn -1;\r\nif (readn(fd, e_ident, sizeof(e_ident)) != sizeof(e_ident))\r\nreturn -1;\r\nif (memcmp(e_ident, ELFMAG, SELFMAG) ||\r\ne_ident[EI_VERSION] != EV_CURRENT)\r\nreturn -1;\r\nreturn e_ident[EI_CLASS] == ELFCLASS64;\r\n}\r\nenum dso_type dso__type_fd(int fd)\r\n{\r\nElf64_Ehdr ehdr;\r\nint ret;\r\nret = fd__is_64_bit(fd);\r\nif (ret < 0)\r\nreturn DSO__TYPE_UNKNOWN;\r\nif (ret)\r\nreturn DSO__TYPE_64BIT;\r\nif (readn(fd, &ehdr, sizeof(ehdr)) != sizeof(ehdr))\r\nreturn DSO__TYPE_UNKNOWN;\r\nif (ehdr.e_machine == EM_X86_64)\r\nreturn DSO__TYPE_X32BIT;\r\nreturn DSO__TYPE_32BIT;\r\n}\r\nint dso__load_sym(struct dso *dso, struct map *map __maybe_unused,\r\nstruct symsrc *ss,\r\nstruct symsrc *runtime_ss __maybe_unused,\r\nsymbol_filter_t filter __maybe_unused,\r\nint kmodule __maybe_unused)\r\n{\r\nunsigned char *build_id[BUILD_ID_SIZE];\r\nint ret;\r\nret = fd__is_64_bit(ss->fd);\r\nif (ret >= 0)\r\ndso->is_64_bit = ret;\r\nif (filename__read_build_id(ss->name, build_id, BUILD_ID_SIZE) > 0) {\r\ndso__set_build_id(dso, build_id);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint file__read_maps(int fd __maybe_unused, bool exe __maybe_unused,\r\nmapfn_t mapfn __maybe_unused, void *data __maybe_unused,\r\nbool *is_64_bit __maybe_unused)\r\n{\r\nreturn -1;\r\n}\r\nint kcore_extract__create(struct kcore_extract *kce __maybe_unused)\r\n{\r\nreturn -1;\r\n}\r\nvoid kcore_extract__delete(struct kcore_extract *kce __maybe_unused)\r\n{\r\n}\r\nint kcore_copy(const char *from_dir __maybe_unused,\r\nconst char *to_dir __maybe_unused)\r\n{\r\nreturn -1;\r\n}\r\nvoid symbol__elf_init(void)\r\n{\r\n}
