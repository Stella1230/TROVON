static enum dlm_status dlmunlock_common(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock,\r\nstruct dlm_lockstatus *lksb,\r\nint flags, int *call_ast,\r\nint master_node)\r\n{\r\nenum dlm_status status;\r\nint actions = 0;\r\nint in_use;\r\nu8 owner;\r\nmlog(0, "master_node = %d, valblk = %d\n", master_node,\r\nflags & LKM_VALBLK);\r\nif (master_node)\r\nBUG_ON(res->owner != dlm->node_num);\r\nelse\r\nBUG_ON(res->owner == dlm->node_num);\r\nspin_lock(&dlm->ast_lock);\r\nin_use = !list_empty(&lock->ast_list);\r\nspin_unlock(&dlm->ast_lock);\r\nif (in_use && !(flags & LKM_CANCEL)) {\r\nmlog(ML_ERROR, "lockres %.*s: Someone is calling dlmunlock "\r\n"while waiting for an ast!", res->lockname.len,\r\nres->lockname.name);\r\nreturn DLM_BADPARAM;\r\n}\r\nspin_lock(&res->spinlock);\r\nif (res->state & DLM_LOCK_RES_IN_PROGRESS) {\r\nif (master_node && !(flags & LKM_CANCEL)) {\r\nmlog(ML_ERROR, "lockres in progress!\n");\r\nspin_unlock(&res->spinlock);\r\nreturn DLM_FORWARD;\r\n}\r\n__dlm_wait_on_lockres(res);\r\nres->state |= DLM_LOCK_RES_IN_PROGRESS;\r\n}\r\nspin_lock(&lock->spinlock);\r\nif (res->state & DLM_LOCK_RES_RECOVERING) {\r\nstatus = DLM_RECOVERING;\r\ngoto leave;\r\n}\r\nif (res->state & DLM_LOCK_RES_MIGRATING) {\r\nstatus = DLM_MIGRATING;\r\ngoto leave;\r\n}\r\nif (flags & LKM_CANCEL)\r\nstatus = dlm_get_cancel_actions(dlm, res, lock, lksb, &actions);\r\nelse\r\nstatus = dlm_get_unlock_actions(dlm, res, lock, lksb, &actions);\r\nif (status != DLM_NORMAL && (status != DLM_CANCELGRANT || !master_node))\r\ngoto leave;\r\nif (flags & LKM_VALBLK) {\r\nif (master_node)\r\nmemcpy(res->lvb, lksb->lvb, DLM_LVB_LEN);\r\nelse\r\nflags |= LKM_PUT_LVB;\r\n}\r\nif (!master_node) {\r\nowner = res->owner;\r\nif (flags & LKM_CANCEL)\r\nlock->cancel_pending = 1;\r\nelse\r\nlock->unlock_pending = 1;\r\nspin_unlock(&lock->spinlock);\r\nspin_unlock(&res->spinlock);\r\nstatus = dlm_send_remote_unlock_request(dlm, res, lock, lksb,\r\nflags, owner);\r\nspin_lock(&res->spinlock);\r\nspin_lock(&lock->spinlock);\r\nif (status == DLM_CANCELGRANT) {\r\nactions &= ~(DLM_UNLOCK_REMOVE_LOCK|\r\nDLM_UNLOCK_REGRANT_LOCK|\r\nDLM_UNLOCK_CLEAR_CONVERT_TYPE);\r\n} else if (status == DLM_RECOVERING ||\r\nstatus == DLM_MIGRATING ||\r\nstatus == DLM_FORWARD ||\r\nstatus == DLM_NOLOCKMGR\r\n) {\r\nmlog(0, "%s:%.*s: clearing actions, %s\n",\r\ndlm->name, res->lockname.len,\r\nres->lockname.name,\r\nstatus==DLM_RECOVERING?"recovering":\r\n(status==DLM_MIGRATING?"migrating":\r\n(status == DLM_FORWARD ? "forward" :\r\n"nolockmanager")));\r\nactions = 0;\r\n}\r\nif (flags & LKM_CANCEL)\r\nlock->cancel_pending = 0;\r\nelse\r\nlock->unlock_pending = 0;\r\n}\r\ndlm_lock_get(lock);\r\nif (actions & DLM_UNLOCK_REMOVE_LOCK) {\r\nlist_del_init(&lock->list);\r\ndlm_lock_put(lock);\r\n}\r\nif (actions & DLM_UNLOCK_REGRANT_LOCK) {\r\ndlm_lock_get(lock);\r\nlist_add_tail(&lock->list, &res->granted);\r\n}\r\nif (actions & DLM_UNLOCK_CLEAR_CONVERT_TYPE) {\r\nmlog(0, "clearing convert_type at %smaster node\n",\r\nmaster_node ? "" : "non-");\r\nlock->ml.convert_type = LKM_IVMODE;\r\n}\r\ndlm_lock_put(lock);\r\nleave:\r\nres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\r\nif (!dlm_lock_on_list(&res->converting, lock))\r\nBUG_ON(lock->ml.convert_type != LKM_IVMODE);\r\nelse\r\nBUG_ON(lock->ml.convert_type == LKM_IVMODE);\r\nspin_unlock(&lock->spinlock);\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\nif (actions & DLM_UNLOCK_FREE_LOCK) {\r\nBUG_ON(!(actions & DLM_UNLOCK_REMOVE_LOCK));\r\nmlog(0, "lock %u:%llu should be gone now! refs=%d\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\r\natomic_read(&lock->lock_refs.refcount)-1);\r\ndlm_lock_put(lock);\r\n}\r\nif (actions & DLM_UNLOCK_CALL_AST)\r\n*call_ast = 1;\r\nif (status == DLM_NORMAL)\r\nlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\r\nreturn status;\r\n}\r\nvoid dlm_commit_pending_unlock(struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock)\r\n{\r\nlist_del_init(&lock->list);\r\n}\r\nvoid dlm_commit_pending_cancel(struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock)\r\n{\r\nlist_move_tail(&lock->list, &res->granted);\r\nlock->ml.convert_type = LKM_IVMODE;\r\n}\r\nstatic inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock,\r\nstruct dlm_lockstatus *lksb,\r\nint flags,\r\nint *call_ast)\r\n{\r\nreturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);\r\n}\r\nstatic inline enum dlm_status dlmunlock_remote(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock,\r\nstruct dlm_lockstatus *lksb,\r\nint flags, int *call_ast)\r\n{\r\nreturn dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 0);\r\n}\r\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock,\r\nstruct dlm_lockstatus *lksb,\r\nint flags,\r\nu8 owner)\r\n{\r\nstruct dlm_unlock_lock unlock;\r\nint tmpret;\r\nenum dlm_status ret;\r\nint status = 0;\r\nstruct kvec vec[2];\r\nsize_t veclen = 1;\r\nmlog(0, "%.*s\n", res->lockname.len, res->lockname.name);\r\nif (owner == dlm->node_num) {\r\nmlog(0, "%s:%.*s: this node became the master due to a "\r\n"migration, re-evaluate now\n", dlm->name,\r\nres->lockname.len, res->lockname.name);\r\nreturn DLM_FORWARD;\r\n}\r\nmemset(&unlock, 0, sizeof(unlock));\r\nunlock.node_idx = dlm->node_num;\r\nunlock.flags = cpu_to_be32(flags);\r\nunlock.cookie = lock->ml.cookie;\r\nunlock.namelen = res->lockname.len;\r\nmemcpy(unlock.name, res->lockname.name, unlock.namelen);\r\nvec[0].iov_len = sizeof(struct dlm_unlock_lock);\r\nvec[0].iov_base = &unlock;\r\nif (flags & LKM_PUT_LVB) {\r\nvec[1].iov_len = DLM_LVB_LEN;\r\nvec[1].iov_base = lock->lksb->lvb;\r\nveclen++;\r\n}\r\ntmpret = o2net_send_message_vec(DLM_UNLOCK_LOCK_MSG, dlm->key,\r\nvec, veclen, owner, &status);\r\nif (tmpret >= 0) {\r\nif (status == DLM_FORWARD)\r\nmlog(0, "master was in-progress. retry\n");\r\nret = status;\r\n} else {\r\nmlog(ML_ERROR, "Error %d when sending message %u (key 0x%x) to "\r\n"node %u\n", tmpret, DLM_UNLOCK_LOCK_MSG, dlm->key, owner);\r\nif (dlm_is_host_down(tmpret)) {\r\nif (dlm_is_node_dead(dlm, owner))\r\nret = DLM_NORMAL;\r\nelse\r\nret = DLM_NOLOCKMGR;\r\n} else {\r\nret = dlm_err_to_dlm_status(tmpret);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint dlm_unlock_lock_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_unlock_lock *unlock = (struct dlm_unlock_lock *)msg->buf;\r\nstruct dlm_lock_resource *res = NULL;\r\nstruct dlm_lock *lock = NULL;\r\nenum dlm_status status = DLM_NORMAL;\r\nint found = 0, i;\r\nstruct dlm_lockstatus *lksb = NULL;\r\nint ignore;\r\nu32 flags;\r\nstruct list_head *queue;\r\nflags = be32_to_cpu(unlock->flags);\r\nif (flags & LKM_GET_LVB) {\r\nmlog(ML_ERROR, "bad args! GET_LVB specified on unlock!\n");\r\nreturn DLM_BADARGS;\r\n}\r\nif ((flags & (LKM_PUT_LVB|LKM_CANCEL)) == (LKM_PUT_LVB|LKM_CANCEL)) {\r\nmlog(ML_ERROR, "bad args! cannot modify lvb on a CANCEL "\r\n"request!\n");\r\nreturn DLM_BADARGS;\r\n}\r\nif (unlock->namelen > DLM_LOCKID_NAME_MAX) {\r\nmlog(ML_ERROR, "Invalid name length in unlock handler!\n");\r\nreturn DLM_IVBUFLEN;\r\n}\r\nif (!dlm_grab(dlm))\r\nreturn DLM_REJECTED;\r\nmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\r\n"Domain %s not fully joined!\n", dlm->name);\r\nmlog(0, "lvb: %s\n", flags & LKM_PUT_LVB ? "put lvb" : "none");\r\nres = dlm_lookup_lockres(dlm, unlock->name, unlock->namelen);\r\nif (!res) {\r\nmlog(0, "returning DLM_FORWARD -- res no longer exists\n");\r\nstatus = DLM_FORWARD;\r\ngoto not_found;\r\n}\r\nqueue=&res->granted;\r\nfound = 0;\r\nspin_lock(&res->spinlock);\r\nif (res->state & DLM_LOCK_RES_RECOVERING) {\r\nspin_unlock(&res->spinlock);\r\nmlog(0, "returning DLM_RECOVERING\n");\r\nstatus = DLM_RECOVERING;\r\ngoto leave;\r\n}\r\nif (res->state & DLM_LOCK_RES_MIGRATING) {\r\nspin_unlock(&res->spinlock);\r\nmlog(0, "returning DLM_MIGRATING\n");\r\nstatus = DLM_MIGRATING;\r\ngoto leave;\r\n}\r\nif (res->owner != dlm->node_num) {\r\nspin_unlock(&res->spinlock);\r\nmlog(0, "returning DLM_FORWARD -- not master\n");\r\nstatus = DLM_FORWARD;\r\ngoto leave;\r\n}\r\nfor (i=0; i<3; i++) {\r\nlist_for_each_entry(lock, queue, list) {\r\nif (lock->ml.cookie == unlock->cookie &&\r\nlock->ml.node == unlock->node_idx) {\r\ndlm_lock_get(lock);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found)\r\nbreak;\r\nqueue++;\r\n}\r\nspin_unlock(&res->spinlock);\r\nif (!found) {\r\nstatus = DLM_IVLOCKID;\r\ngoto not_found;\r\n}\r\nlksb = lock->lksb;\r\nif (flags & (LKM_VALBLK|LKM_PUT_LVB) &&\r\nlock->ml.type != LKM_EXMODE)\r\nflags &= ~(LKM_VALBLK|LKM_PUT_LVB);\r\nif (flags & LKM_PUT_LVB) {\r\nlksb->flags |= DLM_LKSB_PUT_LVB;\r\nmemcpy(&lksb->lvb[0], &unlock->lvb[0], DLM_LVB_LEN);\r\n}\r\nstatus = dlmunlock_master(dlm, res, lock, lksb, flags, &ignore);\r\nif (status == DLM_FORWARD)\r\nmlog(0, "lockres is in progress\n");\r\nif (flags & LKM_PUT_LVB)\r\nlksb->flags &= ~DLM_LKSB_PUT_LVB;\r\ndlm_lockres_calc_usage(dlm, res);\r\ndlm_kick_thread(dlm, res);\r\nnot_found:\r\nif (!found)\r\nmlog(ML_ERROR, "failed to find lock to unlock! "\r\n"cookie=%u:%llu\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(unlock->cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(unlock->cookie)));\r\nelse\r\ndlm_lock_put(lock);\r\nleave:\r\nif (res)\r\ndlm_lockres_put(res);\r\ndlm_put(dlm);\r\nreturn status;\r\n}\r\nstatic enum dlm_status dlm_get_cancel_actions(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock,\r\nstruct dlm_lockstatus *lksb,\r\nint *actions)\r\n{\r\nenum dlm_status status;\r\nif (dlm_lock_on_list(&res->blocked, lock)) {\r\nstatus = DLM_NORMAL;\r\n*actions = (DLM_UNLOCK_CALL_AST |\r\nDLM_UNLOCK_REMOVE_LOCK);\r\n} else if (dlm_lock_on_list(&res->converting, lock)) {\r\nstatus = DLM_NORMAL;\r\n*actions = (DLM_UNLOCK_CALL_AST |\r\nDLM_UNLOCK_REMOVE_LOCK |\r\nDLM_UNLOCK_REGRANT_LOCK |\r\nDLM_UNLOCK_CLEAR_CONVERT_TYPE);\r\n} else if (dlm_lock_on_list(&res->granted, lock)) {\r\nstatus = DLM_CANCELGRANT;\r\n*actions = DLM_UNLOCK_CALL_AST;\r\n} else {\r\nmlog(ML_ERROR, "lock to cancel is not on any list!\n");\r\nstatus = DLM_IVLOCKID;\r\n*actions = 0;\r\n}\r\nreturn status;\r\n}\r\nstatic enum dlm_status dlm_get_unlock_actions(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_lock *lock,\r\nstruct dlm_lockstatus *lksb,\r\nint *actions)\r\n{\r\nenum dlm_status status;\r\nif (!dlm_lock_on_list(&res->granted, lock)) {\r\nstatus = DLM_DENIED;\r\ndlm_error(status);\r\n*actions = 0;\r\n} else {\r\nstatus = DLM_NORMAL;\r\n*actions = (DLM_UNLOCK_FREE_LOCK |\r\nDLM_UNLOCK_CALL_AST |\r\nDLM_UNLOCK_REMOVE_LOCK);\r\n}\r\nreturn status;\r\n}\r\nenum dlm_status dlmunlock(struct dlm_ctxt *dlm, struct dlm_lockstatus *lksb,\r\nint flags, dlm_astunlockfunc_t *unlockast, void *data)\r\n{\r\nenum dlm_status status;\r\nstruct dlm_lock_resource *res;\r\nstruct dlm_lock *lock = NULL;\r\nint call_ast, is_master;\r\nif (!lksb) {\r\ndlm_error(DLM_BADARGS);\r\nreturn DLM_BADARGS;\r\n}\r\nif (flags & ~(LKM_CANCEL | LKM_VALBLK | LKM_INVVALBLK)) {\r\ndlm_error(DLM_BADPARAM);\r\nreturn DLM_BADPARAM;\r\n}\r\nif ((flags & (LKM_VALBLK | LKM_CANCEL)) == (LKM_VALBLK | LKM_CANCEL)) {\r\nmlog(0, "VALBLK given with CANCEL: ignoring VALBLK\n");\r\nflags &= ~LKM_VALBLK;\r\n}\r\nif (!lksb->lockid || !lksb->lockid->lockres) {\r\ndlm_error(DLM_BADPARAM);\r\nreturn DLM_BADPARAM;\r\n}\r\nlock = lksb->lockid;\r\nBUG_ON(!lock);\r\ndlm_lock_get(lock);\r\nres = lock->lockres;\r\nBUG_ON(!res);\r\ndlm_lockres_get(res);\r\nretry:\r\ncall_ast = 0;\r\nmlog(0, "lock=%p res=%p\n", lock, res);\r\nspin_lock(&res->spinlock);\r\nis_master = (res->owner == dlm->node_num);\r\nif (flags & LKM_VALBLK && lock->ml.type != LKM_EXMODE)\r\nflags &= ~LKM_VALBLK;\r\nspin_unlock(&res->spinlock);\r\nif (is_master) {\r\nstatus = dlmunlock_master(dlm, res, lock, lksb, flags,\r\n&call_ast);\r\nmlog(0, "done calling dlmunlock_master: returned %d, "\r\n"call_ast is %d\n", status, call_ast);\r\n} else {\r\nstatus = dlmunlock_remote(dlm, res, lock, lksb, flags,\r\n&call_ast);\r\nmlog(0, "done calling dlmunlock_remote: returned %d, "\r\n"call_ast is %d\n", status, call_ast);\r\n}\r\nif (status == DLM_RECOVERING ||\r\nstatus == DLM_MIGRATING ||\r\nstatus == DLM_FORWARD ||\r\nstatus == DLM_NOLOCKMGR) {\r\nmsleep(50);\r\nmlog(0, "retrying unlock due to pending recovery/"\r\n"migration/in-progress/reconnect\n");\r\ngoto retry;\r\n}\r\nif (call_ast) {\r\nmlog(0, "calling unlockast(%p, %d)\n", data, status);\r\nif (is_master) {\r\ndlm_kick_thread(dlm, NULL);\r\nwait_event(dlm->ast_wq,\r\ndlm_lock_basts_flushed(dlm, lock));\r\n}\r\n(*unlockast)(data, status);\r\n}\r\nif (status == DLM_CANCELGRANT)\r\nstatus = DLM_NORMAL;\r\nif (status == DLM_NORMAL) {\r\nmlog(0, "kicking the thread\n");\r\ndlm_kick_thread(dlm, res);\r\n} else\r\ndlm_error(status);\r\ndlm_lockres_calc_usage(dlm, res);\r\ndlm_lockres_put(res);\r\ndlm_lock_put(lock);\r\nmlog(0, "returning status=%d!\n", status);\r\nreturn status;\r\n}
