static int exynos_drm_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct exynos_drm_display *display = exynos_connector->display;\r\nstruct edid *edid = NULL;\r\nunsigned int count = 0;\r\nint ret;\r\nif (display->ops->get_edid) {\r\nedid = display->ops->get_edid(display, connector);\r\nif (IS_ERR_OR_NULL(edid)) {\r\nret = PTR_ERR(edid);\r\nedid = NULL;\r\nDRM_ERROR("Panel operation get_edid failed %d\n", ret);\r\ngoto out;\r\n}\r\ncount = drm_add_edid_modes(connector, edid);\r\nif (!count) {\r\nDRM_ERROR("Add edid modes failed %d\n", count);\r\ngoto out;\r\n}\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\n} else {\r\nstruct exynos_drm_panel_info *panel;\r\nstruct drm_display_mode *mode = drm_mode_create(connector->dev);\r\nif (!mode) {\r\nDRM_ERROR("failed to create a new display mode.\n");\r\nreturn 0;\r\n}\r\nif (display->ops->get_panel)\r\npanel = display->ops->get_panel(display);\r\nelse {\r\ndrm_mode_destroy(connector->dev, mode);\r\nreturn 0;\r\n}\r\ndrm_display_mode_from_videomode(&panel->vm, mode);\r\nmode->width_mm = panel->width_mm;\r\nmode->height_mm = panel->height_mm;\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\ncount = 1;\r\n}\r\nout:\r\nkfree(edid);\r\nreturn count;\r\n}\r\nstatic int exynos_drm_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct exynos_drm_display *display = exynos_connector->display;\r\nint ret = MODE_BAD;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (display->ops->check_mode)\r\nif (!display->ops->check_mode(display, mode))\r\nret = MODE_OK;\r\nreturn ret;\r\n}\r\nstatic struct drm_encoder *exynos_drm_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nreturn drm_encoder_find(dev, exynos_connector->encoder_id);\r\n}\r\nstatic int exynos_drm_connector_fill_modes(struct drm_connector *connector,\r\nunsigned int max_width, unsigned int max_height)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct exynos_drm_display *display = exynos_connector->display;\r\nunsigned int width, height;\r\nwidth = max_width;\r\nheight = max_height;\r\nif (display->ops->get_max_resol)\r\ndisplay->ops->get_max_resol(display, &width, &height);\r\nreturn drm_helper_probe_single_connector_modes(connector, width,\r\nheight);\r\n}\r\nstatic enum drm_connector_status\r\nexynos_drm_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct exynos_drm_display *display = exynos_connector->display;\r\nenum drm_connector_status status = connector_status_disconnected;\r\nif (display->ops->is_connected) {\r\nif (display->ops->is_connected(display))\r\nstatus = connector_status_connected;\r\nelse\r\nstatus = connector_status_disconnected;\r\n}\r\nreturn status;\r\n}\r\nstatic void exynos_drm_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(exynos_connector);\r\n}\r\nstruct drm_connector *exynos_drm_connector_create(struct drm_device *dev,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct exynos_drm_connector *exynos_connector;\r\nstruct exynos_drm_display *display = exynos_drm_get_display(encoder);\r\nstruct drm_connector *connector;\r\nint type;\r\nint err;\r\nexynos_connector = kzalloc(sizeof(*exynos_connector), GFP_KERNEL);\r\nif (!exynos_connector)\r\nreturn NULL;\r\nconnector = &exynos_connector->drm_connector;\r\nswitch (display->type) {\r\ncase EXYNOS_DISPLAY_TYPE_HDMI:\r\ntype = DRM_MODE_CONNECTOR_HDMIA;\r\nconnector->interlace_allowed = true;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nbreak;\r\ncase EXYNOS_DISPLAY_TYPE_VIDI:\r\ntype = DRM_MODE_CONNECTOR_VIRTUAL;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nbreak;\r\ndefault:\r\ntype = DRM_MODE_CONNECTOR_Unknown;\r\nbreak;\r\n}\r\ndrm_connector_init(dev, connector, &exynos_connector_funcs, type);\r\ndrm_connector_helper_add(connector, &exynos_connector_helper_funcs);\r\nerr = drm_connector_register(connector);\r\nif (err)\r\ngoto err_connector;\r\nexynos_connector->encoder_id = encoder->base.id;\r\nexynos_connector->display = display;\r\nconnector->dpms = DRM_MODE_DPMS_OFF;\r\nconnector->encoder = encoder;\r\nerr = drm_mode_connector_attach_encoder(connector, encoder);\r\nif (err) {\r\nDRM_ERROR("failed to attach a connector to a encoder\n");\r\ngoto err_sysfs;\r\n}\r\nDRM_DEBUG_KMS("connector has been created\n");\r\nreturn connector;\r\nerr_sysfs:\r\ndrm_connector_unregister(connector);\r\nerr_connector:\r\ndrm_connector_cleanup(connector);\r\nkfree(exynos_connector);\r\nreturn NULL;\r\n}
