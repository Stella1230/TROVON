static void __iomem *vexpress_sysreg_base(void)\r\n{\r\nif (!__vexpress_sysreg_base) {\r\nstruct device_node *node = of_find_compatible_node(NULL, NULL,\r\n"arm,vexpress-sysreg");\r\n__vexpress_sysreg_base = of_iomap(node, 0);\r\n}\r\nWARN_ON(!__vexpress_sysreg_base);\r\nreturn __vexpress_sysreg_base;\r\n}\r\nstatic int vexpress_sysreg_get_master(void)\r\n{\r\nif (readl(vexpress_sysreg_base() + SYS_MISC) & SYS_MISC_MASTERSITE)\r\nreturn VEXPRESS_SITE_DB2;\r\nreturn VEXPRESS_SITE_DB1;\r\n}\r\nvoid vexpress_flags_set(u32 data)\r\n{\r\nwritel(~0, vexpress_sysreg_base() + SYS_FLAGSCLR);\r\nwritel(data, vexpress_sysreg_base() + SYS_FLAGSSET);\r\n}\r\nunsigned int vexpress_get_mci_cardin(struct device *dev)\r\n{\r\nreturn readl(vexpress_sysreg_base() + SYS_MCI) & SYS_MCI_CARDIN;\r\n}\r\nu32 vexpress_get_procid(int site)\r\n{\r\nif (site == VEXPRESS_SITE_MASTER)\r\nsite = vexpress_sysreg_get_master();\r\nreturn readl(vexpress_sysreg_base() + (site == VEXPRESS_SITE_DB1 ?\r\nSYS_PROCID0 : SYS_PROCID1));\r\n}\r\nvoid __iomem *vexpress_get_24mhz_clock_base(void)\r\n{\r\nreturn vexpress_sysreg_base() + SYS_24MHZ;\r\n}\r\nvoid __init vexpress_sysreg_early_init(void __iomem *base)\r\n{\r\n__vexpress_sysreg_base = base;\r\nvexpress_config_set_master(vexpress_sysreg_get_master());\r\n}\r\nstatic int vexpress_sysreg_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nvoid __iomem *base;\r\nstruct bgpio_chip *mmc_gpio_chip;\r\nu32 dt_hbi;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -EINVAL;\r\nbase = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (!base)\r\nreturn -ENOMEM;\r\nvexpress_config_set_master(vexpress_sysreg_get_master());\r\nif (of_property_read_u32(of_allnodes, "arm,hbi", &dt_hbi) == 0) {\r\nu32 id = vexpress_get_procid(VEXPRESS_SITE_MASTER);\r\nu32 hbi = (id >> SYS_PROCIDx_HBI_SHIFT) & SYS_HBI_MASK;\r\nif (WARN_ON(dt_hbi != hbi))\r\ndev_warn(&pdev->dev, "DT HBI (%x) is not matching hardware (%x)!\n",\r\ndt_hbi, hbi);\r\n}\r\nmmc_gpio_chip = devm_kzalloc(&pdev->dev, sizeof(*mmc_gpio_chip),\r\nGFP_KERNEL);\r\nif (!mmc_gpio_chip)\r\nreturn -ENOMEM;\r\nbgpio_init(mmc_gpio_chip, &pdev->dev, 0x4, base + SYS_MCI,\r\nNULL, NULL, NULL, NULL, 0);\r\nmmc_gpio_chip->gc.ngpio = 2;\r\ngpiochip_add(&mmc_gpio_chip->gc);\r\nreturn mfd_add_devices(&pdev->dev, PLATFORM_DEVID_AUTO,\r\nvexpress_sysreg_cells,\r\nARRAY_SIZE(vexpress_sysreg_cells), mem, 0, NULL);\r\n}\r\nstatic int __init vexpress_sysreg_init(void)\r\n{\r\nstruct device_node *node;\r\nfor_each_matching_node(node, vexpress_sysreg_match)\r\nof_platform_device_create(node, NULL, NULL);\r\nreturn platform_driver_register(&vexpress_sysreg_driver);\r\n}
