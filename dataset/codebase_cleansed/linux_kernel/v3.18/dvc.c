static void rsnd_dvc_volume_update(struct rsnd_mod *mod)\r\n{\r\nstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(mod);\r\nu32 max = (0x00800000 - 1);\r\nu32 vol[RSND_DVC_VOLUME_NUM];\r\nu32 mute = 0;\r\nint i;\r\nfor (i = 0; i < RSND_DVC_VOLUME_NUM; i++) {\r\nvol[i] = max / RSND_DVC_VOLUME_MAX * dvc->volume[i];\r\nmute |= (!!dvc->mute[i]) << i;\r\n}\r\nrsnd_mod_write(mod, DVC_VOL0R, vol[0]);\r\nrsnd_mod_write(mod, DVC_VOL1R, vol[1]);\r\nrsnd_mod_write(mod, DVC_ZCMCR, mute);\r\n}\r\nstatic int rsnd_dvc_probe_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\ndev_dbg(dev, "%s (Gen2) is probed\n", rsnd_mod_name(mod));\r\nreturn 0;\r\n}\r\nstatic int rsnd_dvc_init(struct rsnd_mod *dvc_mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(dvc_mod);\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(dvc_mod);\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(dvc_mod);\r\nstruct rsnd_mod *src_mod = rsnd_io_to_mod_src(io);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nint dvc_id = rsnd_mod_id(dvc_mod);\r\nint src_id = rsnd_mod_id(src_mod);\r\nu32 route[] = {\r\n[0] = 0x30000,\r\n[1] = 0x30001,\r\n[2] = 0x40000,\r\n[3] = 0x10000,\r\n[4] = 0x20000,\r\n[5] = 0x40100\r\n};\r\nif (src_id >= ARRAY_SIZE(route)) {\r\ndev_err(dev, "DVC%d isn't connected to SRC%d\n", dvc_id, src_id);\r\nreturn -EINVAL;\r\n}\r\nclk_prepare_enable(dvc->clk);\r\nrsnd_mod_write(dvc_mod, CMD_ROUTE_SLCT, route[src_id]);\r\nrsnd_mod_write(dvc_mod, DVC_SWRSR, 0);\r\nrsnd_mod_write(dvc_mod, DVC_SWRSR, 1);\r\nrsnd_mod_write(dvc_mod, DVC_DVUIR, 1);\r\nrsnd_mod_write(dvc_mod, DVC_ADINR, rsnd_get_adinr(dvc_mod));\r\nrsnd_mod_write(dvc_mod, DVC_DVUCR, 0x101);\r\nrsnd_dvc_volume_update(dvc_mod);\r\nrsnd_mod_write(dvc_mod, DVC_DVUIR, 0);\r\nrsnd_mod_write(dvc_mod, DVC_DVUER, 1);\r\nrsnd_adg_set_cmd_timsel_gen2(rdai, dvc_mod, io);\r\nreturn 0;\r\n}\r\nstatic int rsnd_dvc_quit(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(mod);\r\nclk_disable_unprepare(dvc->clk);\r\nreturn 0;\r\n}\r\nstatic int rsnd_dvc_start(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nrsnd_mod_write(mod, CMD_CTRL, 0x10);\r\nreturn 0;\r\n}\r\nstatic int rsnd_dvc_stop(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nrsnd_mod_write(mod, CMD_CTRL, 0);\r\nreturn 0;\r\n}\r\nstatic int rsnd_dvc_volume_info(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct rsnd_mod *mod = snd_kcontrol_chip(kctrl);\r\nstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(mod);\r\nu8 *val = (u8 *)kctrl->private_value;\r\nuinfo->count = RSND_DVC_VOLUME_NUM;\r\nuinfo->value.integer.min = 0;\r\nif (val == dvc->volume) {\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->value.integer.max = RSND_DVC_VOLUME_MAX;\r\n} else {\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->value.integer.max = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rsnd_dvc_volume_get(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu8 *val = (u8 *)kctrl->private_value;\r\nint i;\r\nfor (i = 0; i < RSND_DVC_VOLUME_NUM; i++)\r\nucontrol->value.integer.value[i] = val[i];\r\nreturn 0;\r\n}\r\nstatic int rsnd_dvc_volume_put(struct snd_kcontrol *kctrl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rsnd_mod *mod = snd_kcontrol_chip(kctrl);\r\nu8 *val = (u8 *)kctrl->private_value;\r\nint i, change = 0;\r\nfor (i = 0; i < RSND_DVC_VOLUME_NUM; i++) {\r\nchange |= (ucontrol->value.integer.value[i] != val[i]);\r\nval[i] = ucontrol->value.integer.value[i];\r\n}\r\nif (change)\r\nrsnd_dvc_volume_update(mod);\r\nreturn change;\r\n}\r\nstatic int __rsnd_dvc_pcm_new(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai,\r\nstruct snd_soc_pcm_runtime *rtd,\r\nconst unsigned char *name,\r\nu8 *private)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_kcontrol *kctrl;\r\nstruct snd_kcontrol_new knew = {\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = name,\r\n.info = rsnd_dvc_volume_info,\r\n.get = rsnd_dvc_volume_get,\r\n.put = rsnd_dvc_volume_put,\r\n.private_value = (unsigned long)private,\r\n};\r\nint ret;\r\nkctrl = snd_ctl_new1(&knew, mod);\r\nif (!kctrl)\r\nreturn -ENOMEM;\r\nret = snd_ctl_add(card, kctrl);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rsnd_dvc_pcm_new(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai,\r\nstruct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nstruct rsnd_dvc *dvc = rsnd_mod_to_dvc(mod);\r\nint ret;\r\nret = __rsnd_dvc_pcm_new(mod, rdai, rtd,\r\nrsnd_dai_is_play(rdai, io) ?\r\n"DVC Out Playback Volume" : "DVC In Capture Volume",\r\ndvc->volume);\r\nif (ret < 0)\r\nreturn ret;\r\nret = __rsnd_dvc_pcm_new(mod, rdai, rtd,\r\nrsnd_dai_is_play(rdai, io) ?\r\n"DVC Out Mute Switch" : "DVC In Mute Switch",\r\ndvc->mute);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstruct rsnd_mod *rsnd_dvc_mod_get(struct rsnd_priv *priv, int id)\r\n{\r\nif (WARN_ON(id < 0 || id >= rsnd_dvc_nr(priv)))\r\nid = 0;\r\nreturn &((struct rsnd_dvc *)(priv->dvc) + id)->mod;\r\n}\r\nstatic void rsnd_of_parse_dvc(struct platform_device *pdev,\r\nconst struct rsnd_of_data *of_data,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct device_node *node;\r\nstruct rsnd_dvc_platform_info *dvc_info;\r\nstruct rcar_snd_info *info = rsnd_priv_to_info(priv);\r\nstruct device *dev = &pdev->dev;\r\nint nr;\r\nif (!of_data)\r\nreturn;\r\nnode = of_get_child_by_name(dev->of_node, "rcar_sound,dvc");\r\nif (!node)\r\nreturn;\r\nnr = of_get_child_count(node);\r\nif (!nr)\r\ngoto rsnd_of_parse_dvc_end;\r\ndvc_info = devm_kzalloc(dev,\r\nsizeof(struct rsnd_dvc_platform_info) * nr,\r\nGFP_KERNEL);\r\nif (!dvc_info) {\r\ndev_err(dev, "dvc info allocation error\n");\r\ngoto rsnd_of_parse_dvc_end;\r\n}\r\ninfo->dvc_info = dvc_info;\r\ninfo->dvc_info_nr = nr;\r\nrsnd_of_parse_dvc_end:\r\nof_node_put(node);\r\n}\r\nint rsnd_dvc_probe(struct platform_device *pdev,\r\nconst struct rsnd_of_data *of_data,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rcar_snd_info *info = rsnd_priv_to_info(priv);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_dvc *dvc;\r\nstruct clk *clk;\r\nchar name[RSND_DVC_NAME_SIZE];\r\nint i, nr;\r\nrsnd_of_parse_dvc(pdev, of_data, priv);\r\nnr = info->dvc_info_nr;\r\nif (!nr)\r\nreturn 0;\r\nif (rsnd_is_gen1(priv)) {\r\ndev_warn(dev, "CMD is not supported on Gen1\n");\r\nreturn -EINVAL;\r\n}\r\ndvc = devm_kzalloc(dev, sizeof(*dvc) * nr, GFP_KERNEL);\r\nif (!dvc) {\r\ndev_err(dev, "CMD allocate failed\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->dvc_nr = nr;\r\npriv->dvc = dvc;\r\nfor_each_rsnd_dvc(dvc, priv, i) {\r\nsnprintf(name, RSND_DVC_NAME_SIZE, "%s.%d",\r\nDVC_NAME, i);\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\ndvc->info = &info->dvc_info[i];\r\ndvc->clk = clk;\r\nrsnd_mod_init(priv, &dvc->mod, &rsnd_dvc_ops, RSND_MOD_DVC, i);\r\ndev_dbg(dev, "CMD%d probed\n", i);\r\n}\r\nreturn 0;\r\n}
