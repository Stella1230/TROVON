static inline void notify_other_smsm(void)\r\n{\r\nmsm_a2m_int(5);\r\n#ifdef CONFIG_QDSP6\r\nmsm_a2m_int(8);\r\n#endif\r\n}\r\nstatic inline void notify_modem_smd(void)\r\n{\r\nmsm_a2m_int(0);\r\n}\r\nstatic inline void notify_dsp_smd(void)\r\n{\r\nmsm_a2m_int(8);\r\n}\r\nstatic void smd_diag(void)\r\n{\r\nchar *x;\r\nx = smem_find(ID_DIAG_ERR_MSG, SZ_DIAG_ERR_MSG);\r\nif (x != 0) {\r\nx[SZ_DIAG_ERR_MSG - 1] = 0;\r\npr_debug("DIAG '%s'\n", x);\r\n}\r\n}\r\nstatic void handle_modem_crash(void)\r\n{\r\npr_err("ARM9 has CRASHED\n");\r\nsmd_diag();\r\nfor (;;)\r\n;\r\n}\r\nuint32_t raw_smsm_get_state(enum smsm_state_item item)\r\n{\r\nreturn readl(smd_info.state + item * 4);\r\n}\r\nstatic int check_for_modem_crash(void)\r\n{\r\nif (raw_smsm_get_state(SMSM_STATE_MODEM) & SMSM_RESET) {\r\nhandle_modem_crash();\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smd_stream_read_avail(struct smd_channel *ch)\r\n{\r\nreturn (ch->recv->head - ch->recv->tail) & ch->fifo_mask;\r\n}\r\nstatic int smd_stream_write_avail(struct smd_channel *ch)\r\n{\r\nreturn ch->fifo_mask -\r\n((ch->send->head - ch->send->tail) & ch->fifo_mask);\r\n}\r\nstatic int smd_packet_read_avail(struct smd_channel *ch)\r\n{\r\nif (ch->current_packet) {\r\nint n = smd_stream_read_avail(ch);\r\nif (n > ch->current_packet)\r\nn = ch->current_packet;\r\nreturn n;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int smd_packet_write_avail(struct smd_channel *ch)\r\n{\r\nint n = smd_stream_write_avail(ch);\r\nreturn n > SMD_HEADER_SIZE ? n - SMD_HEADER_SIZE : 0;\r\n}\r\nstatic int ch_is_open(struct smd_channel *ch)\r\n{\r\nreturn (ch->recv->state == SMD_SS_OPENED) &&\r\n(ch->send->state == SMD_SS_OPENED);\r\n}\r\nstatic unsigned ch_read_buffer(struct smd_channel *ch, void **ptr)\r\n{\r\nunsigned head = ch->recv->head;\r\nunsigned tail = ch->recv->tail;\r\n*ptr = (void *) (ch->recv_data + tail);\r\nif (tail <= head)\r\nreturn head - tail;\r\nelse\r\nreturn ch->fifo_size - tail;\r\n}\r\nstatic void ch_read_done(struct smd_channel *ch, unsigned count)\r\n{\r\nBUG_ON(count > smd_stream_read_avail(ch));\r\nch->recv->tail = (ch->recv->tail + count) & ch->fifo_mask;\r\nch->send->fTAIL = 1;\r\n}\r\nstatic int ch_read(struct smd_channel *ch, void *_data, int len)\r\n{\r\nvoid *ptr;\r\nunsigned n;\r\nunsigned char *data = _data;\r\nint orig_len = len;\r\nwhile (len > 0) {\r\nn = ch_read_buffer(ch, &ptr);\r\nif (n == 0)\r\nbreak;\r\nif (n > len)\r\nn = len;\r\nif (_data)\r\nmemcpy(data, ptr, n);\r\ndata += n;\r\nlen -= n;\r\nch_read_done(ch, n);\r\n}\r\nreturn orig_len - len;\r\n}\r\nstatic void update_stream_state(struct smd_channel *ch)\r\n{\r\n}\r\nstatic void update_packet_state(struct smd_channel *ch)\r\n{\r\nunsigned hdr[5];\r\nint r;\r\nif (ch->current_packet != 0)\r\nreturn;\r\nif (smd_stream_read_avail(ch) < SMD_HEADER_SIZE)\r\nreturn;\r\nr = ch_read(ch, hdr, SMD_HEADER_SIZE);\r\nBUG_ON(r != SMD_HEADER_SIZE);\r\nch->current_packet = hdr[0];\r\n}\r\nstatic unsigned ch_write_buffer(struct smd_channel *ch, void **ptr)\r\n{\r\nunsigned head = ch->send->head;\r\nunsigned tail = ch->send->tail;\r\n*ptr = (void *) (ch->send_data + head);\r\nif (head < tail) {\r\nreturn tail - head - 1;\r\n} else {\r\nif (tail == 0)\r\nreturn ch->fifo_size - head - 1;\r\nelse\r\nreturn ch->fifo_size - head;\r\n}\r\n}\r\nstatic void ch_write_done(struct smd_channel *ch, unsigned count)\r\n{\r\nBUG_ON(count > smd_stream_write_avail(ch));\r\nch->send->head = (ch->send->head + count) & ch->fifo_mask;\r\nch->send->fHEAD = 1;\r\n}\r\nstatic void ch_set_state(struct smd_channel *ch, unsigned n)\r\n{\r\nif (n == SMD_SS_OPENED) {\r\nch->send->fDSR = 1;\r\nch->send->fCTS = 1;\r\nch->send->fCD = 1;\r\n} else {\r\nch->send->fDSR = 0;\r\nch->send->fCTS = 0;\r\nch->send->fCD = 0;\r\n}\r\nch->send->state = n;\r\nch->send->fSTATE = 1;\r\nch->notify_other_cpu();\r\n}\r\nstatic void do_smd_probe(void)\r\n{\r\nstruct smem_shared *shared = (void *) MSM_SHARED_RAM_BASE;\r\nif (shared->heap_info.free_offset != last_heap_free) {\r\nlast_heap_free = shared->heap_info.free_offset;\r\nschedule_work(&probe_work);\r\n}\r\n}\r\nstatic void smd_state_change(struct smd_channel *ch,\r\nunsigned last, unsigned next)\r\n{\r\nch->last_state = next;\r\npr_debug("ch %d %d -> %d\n", ch->n, last, next);\r\nswitch (next) {\r\ncase SMD_SS_OPENING:\r\nch->recv->tail = 0;\r\ncase SMD_SS_OPENED:\r\nif (ch->send->state != SMD_SS_OPENED)\r\nch_set_state(ch, SMD_SS_OPENED);\r\nch->notify(ch->priv, SMD_EVENT_OPEN);\r\nbreak;\r\ncase SMD_SS_FLUSHING:\r\ncase SMD_SS_RESET:\r\ndefault:\r\nch->notify(ch->priv, SMD_EVENT_CLOSE);\r\n}\r\n}\r\nstatic void handle_smd_irq(struct list_head *list, void (*notify)(void))\r\n{\r\nunsigned long flags;\r\nstruct smd_channel *ch;\r\nint do_notify = 0;\r\nunsigned ch_flags;\r\nunsigned tmp;\r\nspin_lock_irqsave(&smd_lock, flags);\r\nlist_for_each_entry(ch, list, ch_list) {\r\nch_flags = 0;\r\nif (ch_is_open(ch)) {\r\nif (ch->recv->fHEAD) {\r\nch->recv->fHEAD = 0;\r\nch_flags |= 1;\r\ndo_notify |= 1;\r\n}\r\nif (ch->recv->fTAIL) {\r\nch->recv->fTAIL = 0;\r\nch_flags |= 2;\r\ndo_notify |= 1;\r\n}\r\nif (ch->recv->fSTATE) {\r\nch->recv->fSTATE = 0;\r\nch_flags |= 4;\r\ndo_notify |= 1;\r\n}\r\n}\r\ntmp = ch->recv->state;\r\nif (tmp != ch->last_state)\r\nsmd_state_change(ch, ch->last_state, tmp);\r\nif (ch_flags) {\r\nch->update_state(ch);\r\nch->notify(ch->priv, SMD_EVENT_DATA);\r\n}\r\n}\r\nif (do_notify)\r\nnotify();\r\nspin_unlock_irqrestore(&smd_lock, flags);\r\ndo_smd_probe();\r\n}\r\nstatic irqreturn_t smd_modem_irq_handler(int irq, void *data)\r\n{\r\nhandle_smd_irq(&smd_ch_list_modem, notify_modem_smd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smd_dsp_irq_handler(int irq, void *data)\r\n{\r\nhandle_smd_irq(&smd_ch_list_dsp, notify_dsp_smd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void smd_fake_irq_handler(unsigned long arg)\r\n{\r\nhandle_smd_irq(&smd_ch_list_modem, notify_modem_smd);\r\nhandle_smd_irq(&smd_ch_list_dsp, notify_dsp_smd);\r\n}\r\nstatic inline int smd_need_int(struct smd_channel *ch)\r\n{\r\nif (ch_is_open(ch)) {\r\nif (ch->recv->fHEAD || ch->recv->fTAIL || ch->recv->fSTATE)\r\nreturn 1;\r\nif (ch->recv->state != ch->last_state)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid smd_sleep_exit(void)\r\n{\r\nunsigned long flags;\r\nstruct smd_channel *ch;\r\nint need_int = 0;\r\nspin_lock_irqsave(&smd_lock, flags);\r\nlist_for_each_entry(ch, &smd_ch_list_modem, ch_list) {\r\nif (smd_need_int(ch)) {\r\nneed_int = 1;\r\nbreak;\r\n}\r\n}\r\nlist_for_each_entry(ch, &smd_ch_list_dsp, ch_list) {\r\nif (smd_need_int(ch)) {\r\nneed_int = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&smd_lock, flags);\r\ndo_smd_probe();\r\nif (need_int) {\r\nif (msm_smd_debug_mask & MSM_SMD_DEBUG)\r\npr_info("smd_sleep_exit need interrupt\n");\r\ntasklet_schedule(&smd_fake_irq_tasklet);\r\n}\r\n}\r\nvoid smd_kick(smd_channel_t *ch)\r\n{\r\nunsigned long flags;\r\nunsigned tmp;\r\nspin_lock_irqsave(&smd_lock, flags);\r\nch->update_state(ch);\r\ntmp = ch->recv->state;\r\nif (tmp != ch->last_state) {\r\nch->last_state = tmp;\r\nif (tmp == SMD_SS_OPENED)\r\nch->notify(ch->priv, SMD_EVENT_OPEN);\r\nelse\r\nch->notify(ch->priv, SMD_EVENT_CLOSE);\r\n}\r\nch->notify(ch->priv, SMD_EVENT_DATA);\r\nch->notify_other_cpu();\r\nspin_unlock_irqrestore(&smd_lock, flags);\r\n}\r\nstatic int smd_is_packet(int chn, unsigned type)\r\n{\r\ntype &= SMD_KIND_MASK;\r\nif (type == SMD_KIND_PACKET)\r\nreturn 1;\r\nif (type == SMD_KIND_STREAM)\r\nreturn 0;\r\nif ((chn > 4) || (chn == 1))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int smd_stream_write(smd_channel_t *ch, const void *_data, int len)\r\n{\r\nvoid *ptr;\r\nconst unsigned char *buf = _data;\r\nunsigned xfer;\r\nint orig_len = len;\r\nif (len < 0)\r\nreturn -EINVAL;\r\nwhile ((xfer = ch_write_buffer(ch, &ptr)) != 0) {\r\nif (!ch_is_open(ch))\r\nbreak;\r\nif (xfer > len)\r\nxfer = len;\r\nmemcpy(ptr, buf, xfer);\r\nch_write_done(ch, xfer);\r\nlen -= xfer;\r\nbuf += xfer;\r\nif (len == 0)\r\nbreak;\r\n}\r\nch->notify_other_cpu();\r\nreturn orig_len - len;\r\n}\r\nstatic int smd_packet_write(smd_channel_t *ch, const void *_data, int len)\r\n{\r\nunsigned hdr[5];\r\nif (len < 0)\r\nreturn -EINVAL;\r\nif (smd_stream_write_avail(ch) < (len + SMD_HEADER_SIZE))\r\nreturn -ENOMEM;\r\nhdr[0] = len;\r\nhdr[1] = hdr[2] = hdr[3] = hdr[4] = 0;\r\nsmd_stream_write(ch, hdr, sizeof(hdr));\r\nsmd_stream_write(ch, _data, len);\r\nreturn len;\r\n}\r\nstatic int smd_stream_read(smd_channel_t *ch, void *data, int len)\r\n{\r\nint r;\r\nif (len < 0)\r\nreturn -EINVAL;\r\nr = ch_read(ch, data, len);\r\nif (r > 0)\r\nch->notify_other_cpu();\r\nreturn r;\r\n}\r\nstatic int smd_packet_read(smd_channel_t *ch, void *data, int len)\r\n{\r\nunsigned long flags;\r\nint r;\r\nif (len < 0)\r\nreturn -EINVAL;\r\nif (len > ch->current_packet)\r\nlen = ch->current_packet;\r\nr = ch_read(ch, data, len);\r\nif (r > 0)\r\nch->notify_other_cpu();\r\nspin_lock_irqsave(&smd_lock, flags);\r\nch->current_packet -= r;\r\nupdate_packet_state(ch);\r\nspin_unlock_irqrestore(&smd_lock, flags);\r\nreturn r;\r\n}\r\nstatic int smd_alloc_channel(const char *name, uint32_t cid, uint32_t type)\r\n{\r\nstruct smd_channel *ch;\r\nch = kzalloc(sizeof(struct smd_channel), GFP_KERNEL);\r\nif (ch == 0) {\r\npr_err("smd_alloc_channel() out of memory\n");\r\nreturn -1;\r\n}\r\nch->n = cid;\r\nif (_smd_alloc_channel(ch)) {\r\nkfree(ch);\r\nreturn -1;\r\n}\r\nch->fifo_mask = ch->fifo_size - 1;\r\nch->type = type;\r\nif ((type & SMD_TYPE_MASK) == SMD_TYPE_APPS_MODEM)\r\nch->notify_other_cpu = notify_modem_smd;\r\nelse\r\nch->notify_other_cpu = notify_dsp_smd;\r\nif (smd_is_packet(cid, type)) {\r\nch->read = smd_packet_read;\r\nch->write = smd_packet_write;\r\nch->read_avail = smd_packet_read_avail;\r\nch->write_avail = smd_packet_write_avail;\r\nch->update_state = update_packet_state;\r\n} else {\r\nch->read = smd_stream_read;\r\nch->write = smd_stream_write;\r\nch->read_avail = smd_stream_read_avail;\r\nch->write_avail = smd_stream_write_avail;\r\nch->update_state = update_stream_state;\r\n}\r\nif ((type & 0xff) == 0)\r\nmemcpy(ch->name, "SMD_", 4);\r\nelse\r\nmemcpy(ch->name, "DSP_", 4);\r\nmemcpy(ch->name + 4, name, 20);\r\nch->name[23] = 0;\r\nch->pdev.name = ch->name;\r\nch->pdev.id = -1;\r\npr_debug("smd_alloc_channel() cid=%02d size=%05d '%s'\n",\r\nch->n, ch->fifo_size, ch->name);\r\nmutex_lock(&smd_creation_mutex);\r\nlist_add(&ch->ch_list, &smd_ch_closed_list);\r\nmutex_unlock(&smd_creation_mutex);\r\nplatform_device_register(&ch->pdev);\r\nreturn 0;\r\n}\r\nstatic void smd_channel_probe_worker(struct work_struct *work)\r\n{\r\nstruct smd_alloc_elm *shared;\r\nunsigned ctype;\r\nunsigned type;\r\nunsigned n;\r\nshared = smem_find(ID_CH_ALLOC_TBL, sizeof(*shared) * 64);\r\nif (!shared) {\r\npr_err("cannot find allocation table\n");\r\nreturn;\r\n}\r\nfor (n = 0; n < 64; n++) {\r\nif (smd_ch_allocated[n])\r\ncontinue;\r\nif (!shared[n].ref_count)\r\ncontinue;\r\nif (!shared[n].name[0])\r\ncontinue;\r\nctype = shared[n].ctype;\r\ntype = ctype & SMD_TYPE_MASK;\r\nif (!memcmp(shared[n].name, "DAL", 3))\r\nctype = (ctype & (~SMD_KIND_MASK)) | SMD_KIND_STREAM;\r\ntype = shared[n].ctype & SMD_TYPE_MASK;\r\nif ((type == SMD_TYPE_APPS_MODEM) ||\r\n(type == SMD_TYPE_APPS_DSP))\r\nif (!smd_alloc_channel(shared[n].name, shared[n].cid, ctype))\r\nsmd_ch_allocated[n] = 1;\r\n}\r\n}\r\nstatic void do_nothing_notify(void *priv, unsigned flags)\r\n{\r\n}\r\nstruct smd_channel *smd_get_channel(const char *name)\r\n{\r\nstruct smd_channel *ch;\r\nmutex_lock(&smd_creation_mutex);\r\nlist_for_each_entry(ch, &smd_ch_closed_list, ch_list) {\r\nif (!strcmp(name, ch->name)) {\r\nlist_del(&ch->ch_list);\r\nmutex_unlock(&smd_creation_mutex);\r\nreturn ch;\r\n}\r\n}\r\nmutex_unlock(&smd_creation_mutex);\r\nreturn NULL;\r\n}\r\nint smd_open(const char *name, smd_channel_t **_ch,\r\nvoid *priv, void (*notify)(void *, unsigned))\r\n{\r\nstruct smd_channel *ch;\r\nunsigned long flags;\r\nif (smd_initialized == 0) {\r\npr_info("smd_open() before smd_init()\n");\r\nreturn -ENODEV;\r\n}\r\nch = smd_get_channel(name);\r\nif (!ch)\r\nreturn -ENODEV;\r\nif (notify == 0)\r\nnotify = do_nothing_notify;\r\nch->notify = notify;\r\nch->current_packet = 0;\r\nch->last_state = SMD_SS_CLOSED;\r\nch->priv = priv;\r\n*_ch = ch;\r\nspin_lock_irqsave(&smd_lock, flags);\r\nif ((ch->type & SMD_TYPE_MASK) == SMD_TYPE_APPS_MODEM)\r\nlist_add(&ch->ch_list, &smd_ch_list_modem);\r\nelse\r\nlist_add(&ch->ch_list, &smd_ch_list_dsp);\r\nif (ch->recv->state == SMD_SS_CLOSING) {\r\nch->send->head = 0;\r\nch_set_state(ch, SMD_SS_OPENING);\r\n} else {\r\nch_set_state(ch, SMD_SS_OPENED);\r\n}\r\nspin_unlock_irqrestore(&smd_lock, flags);\r\nsmd_kick(ch);\r\nreturn 0;\r\n}\r\nint smd_close(smd_channel_t *ch)\r\n{\r\nunsigned long flags;\r\nif (ch == 0)\r\nreturn -1;\r\nspin_lock_irqsave(&smd_lock, flags);\r\nch->notify = do_nothing_notify;\r\nlist_del(&ch->ch_list);\r\nch_set_state(ch, SMD_SS_CLOSED);\r\nspin_unlock_irqrestore(&smd_lock, flags);\r\nmutex_lock(&smd_creation_mutex);\r\nlist_add(&ch->ch_list, &smd_ch_closed_list);\r\nmutex_unlock(&smd_creation_mutex);\r\nreturn 0;\r\n}\r\nint smd_read(smd_channel_t *ch, void *data, int len)\r\n{\r\nreturn ch->read(ch, data, len);\r\n}\r\nint smd_write(smd_channel_t *ch, const void *data, int len)\r\n{\r\nreturn ch->write(ch, data, len);\r\n}\r\nint smd_write_atomic(smd_channel_t *ch, const void *data, int len)\r\n{\r\nunsigned long flags;\r\nint res;\r\nspin_lock_irqsave(&smd_lock, flags);\r\nres = ch->write(ch, data, len);\r\nspin_unlock_irqrestore(&smd_lock, flags);\r\nreturn res;\r\n}\r\nint smd_read_avail(smd_channel_t *ch)\r\n{\r\nreturn ch->read_avail(ch);\r\n}\r\nint smd_write_avail(smd_channel_t *ch)\r\n{\r\nreturn ch->write_avail(ch);\r\n}\r\nint smd_wait_until_readable(smd_channel_t *ch, int bytes)\r\n{\r\nreturn -1;\r\n}\r\nint smd_wait_until_writable(smd_channel_t *ch, int bytes)\r\n{\r\nreturn -1;\r\n}\r\nint smd_cur_packet_size(smd_channel_t *ch)\r\n{\r\nreturn ch->current_packet;\r\n}\r\nvoid *smem_alloc(unsigned id, unsigned size)\r\n{\r\nreturn smem_find(id, size);\r\n}\r\nvoid __iomem *smem_item(unsigned id, unsigned *size)\r\n{\r\nstruct smem_shared *shared = (void *) MSM_SHARED_RAM_BASE;\r\nstruct smem_heap_entry *toc = shared->heap_toc;\r\nif (id >= SMEM_NUM_ITEMS)\r\nreturn NULL;\r\nif (toc[id].allocated) {\r\n*size = toc[id].size;\r\nreturn (MSM_SHARED_RAM_BASE + toc[id].offset);\r\n} else {\r\n*size = 0;\r\n}\r\nreturn NULL;\r\n}\r\nvoid *smem_find(unsigned id, unsigned size_in)\r\n{\r\nunsigned size;\r\nvoid *ptr;\r\nptr = smem_item(id, &size);\r\nif (!ptr)\r\nreturn 0;\r\nsize_in = ALIGN(size_in, 8);\r\nif (size_in != size) {\r\npr_err("smem_find(%d, %d): wrong size %d\n",\r\nid, size_in, size);\r\nreturn 0;\r\n}\r\nreturn ptr;\r\n}\r\nstatic irqreturn_t smsm_irq_handler(int irq, void *data)\r\n{\r\nunsigned long flags;\r\nunsigned apps, modm;\r\nspin_lock_irqsave(&smem_lock, flags);\r\napps = raw_smsm_get_state(SMSM_STATE_APPS);\r\nmodm = raw_smsm_get_state(SMSM_STATE_MODEM);\r\nif (msm_smd_debug_mask & MSM_SMSM_DEBUG)\r\npr_info("<SM %08x %08x>\n", apps, modm);\r\nif (modm & SMSM_RESET)\r\nhandle_modem_crash();\r\ndo_smd_probe();\r\nspin_unlock_irqrestore(&smem_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nint smsm_change_state(enum smsm_state_item item,\r\nuint32_t clear_mask, uint32_t set_mask)\r\n{\r\nvoid __iomem *addr = smd_info.state + item * 4;\r\nunsigned long flags;\r\nunsigned state;\r\nif (!smd_info.ready)\r\nreturn -EIO;\r\nspin_lock_irqsave(&smem_lock, flags);\r\nif (raw_smsm_get_state(SMSM_STATE_MODEM) & SMSM_RESET)\r\nhandle_modem_crash();\r\nstate = (readl(addr) & ~clear_mask) | set_mask;\r\nwritel(state, addr);\r\nif (msm_smd_debug_mask & MSM_SMSM_DEBUG)\r\npr_info("smsm_change_state %d %x\n", item, state);\r\nnotify_other_smsm();\r\nspin_unlock_irqrestore(&smem_lock, flags);\r\nreturn 0;\r\n}\r\nuint32_t smsm_get_state(enum smsm_state_item item)\r\n{\r\nunsigned long flags;\r\nuint32_t rv;\r\nspin_lock_irqsave(&smem_lock, flags);\r\nrv = readl(smd_info.state + item * 4);\r\nif (item == SMSM_STATE_MODEM && (rv & SMSM_RESET))\r\nhandle_modem_crash();\r\nspin_unlock_irqrestore(&smem_lock, flags);\r\nreturn rv;\r\n}\r\nint smsm_set_sleep_duration(uint32_t delay)\r\n{\r\nstruct msm_dem_slave_data *ptr;\r\nptr = smem_find(SMEM_APPS_DEM_SLAVE_DATA, sizeof(*ptr));\r\nif (ptr == NULL) {\r\npr_err("smsm_set_sleep_duration <SM NO APPS_DEM_SLAVE_DATA>\n");\r\nreturn -EIO;\r\n}\r\nif (msm_smd_debug_mask & MSM_SMSM_DEBUG)\r\npr_info("smsm_set_sleep_duration %d -> %d\n",\r\nptr->sleep_time, delay);\r\nptr->sleep_time = delay;\r\nreturn 0;\r\n}\r\nint smsm_set_sleep_duration(uint32_t delay)\r\n{\r\nuint32_t *ptr;\r\nptr = smem_find(SMEM_SMSM_SLEEP_DELAY, sizeof(*ptr));\r\nif (ptr == NULL) {\r\npr_err("smsm_set_sleep_duration <SM NO SLEEP_DELAY>\n");\r\nreturn -EIO;\r\n}\r\nif (msm_smd_debug_mask & MSM_SMSM_DEBUG)\r\npr_info("smsm_set_sleep_duration %d -> %d\n",\r\n*ptr, delay);\r\n*ptr = delay;\r\nreturn 0;\r\n}\r\nint smd_core_init(void)\r\n{\r\nint r;\r\nfor (;;) {\r\nunsigned size;\r\nvoid __iomem *state;\r\nstate = smem_item(SMEM_SMSM_SHARED_STATE, &size);\r\nif (size == SMSM_V1_SIZE || size == SMSM_V2_SIZE) {\r\nsmd_info.state = state;\r\nbreak;\r\n}\r\n}\r\nsmd_info.ready = 1;\r\nr = request_irq(INT_A9_M2A_0, smd_modem_irq_handler,\r\nIRQF_TRIGGER_RISING, "smd_dev", 0);\r\nif (r < 0)\r\nreturn r;\r\nr = enable_irq_wake(INT_A9_M2A_0);\r\nif (r < 0)\r\npr_err("smd_core_init: enable_irq_wake failed for A9_M2A_0\n");\r\nr = request_irq(INT_A9_M2A_5, smsm_irq_handler,\r\nIRQF_TRIGGER_RISING, "smsm_dev", 0);\r\nif (r < 0) {\r\nfree_irq(INT_A9_M2A_0, 0);\r\nreturn r;\r\n}\r\nr = enable_irq_wake(INT_A9_M2A_5);\r\nif (r < 0)\r\npr_err("smd_core_init: enable_irq_wake failed for A9_M2A_5\n");\r\n#if defined(CONFIG_QDSP6)\r\nr = request_irq(INT_ADSP_A11, smd_dsp_irq_handler,\r\nIRQF_TRIGGER_RISING, "smd_dsp", 0);\r\nif (r < 0) {\r\nfree_irq(INT_A9_M2A_0, 0);\r\nfree_irq(INT_A9_M2A_5, 0);\r\nreturn r;\r\n}\r\n#endif\r\ndo_smd_probe();\r\nsmsm_change_state(SMSM_STATE_APPS,\r\n~0, SMSM_INIT | SMSM_SMDINIT | SMSM_RPCINIT | SMSM_RUN);\r\n#ifdef CONFIG_ARCH_MSM_SCORPION\r\nsmsm_change_state(SMSM_STATE_APPS_DEM, ~0, 0);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int msm_smd_probe(struct platform_device *pdev)\r\n{\r\nproc_comm_boot_wait();\r\nINIT_WORK(&probe_work, smd_channel_probe_worker);\r\nif (smd_core_init()) {\r\npr_err("smd_core_init() failed\n");\r\nreturn -1;\r\n}\r\ndo_smd_probe();\r\nmsm_check_for_modem_crash = check_for_modem_crash;\r\nmsm_init_last_radio_log(THIS_MODULE);\r\nsmd_initialized = 1;\r\nreturn 0;\r\n}\r\nstatic int __init msm_smd_init(void)\r\n{\r\nreturn platform_driver_register(&msm_smd_driver);\r\n}
