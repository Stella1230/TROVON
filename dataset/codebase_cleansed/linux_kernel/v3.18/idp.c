static void idp_backlight_power(int on)\r\n{\r\nif (on) {\r\nIDP_CPLD_LCD |= (1<<1);\r\n} else {\r\nIDP_CPLD_LCD &= ~(1<<1);\r\n}\r\n}\r\nstatic void idp_vlcd(int on)\r\n{\r\nif (on) {\r\nIDP_CPLD_LCD |= (1<<2);\r\n} else {\r\nIDP_CPLD_LCD &= ~(1<<2);\r\n}\r\n}\r\nstatic void idp_lcd_power(int on, struct fb_var_screeninfo *var)\r\n{\r\nif (on) {\r\nIDP_CPLD_LCD |= (1<<0);\r\n} else {\r\nIDP_CPLD_LCD &= ~(1<<0);\r\n}\r\nidp_vlcd(on);\r\n}\r\nstatic void __init idp_init(void)\r\n{\r\nprintk("idp_init()\n");\r\npxa2xx_mfp_config(ARRAY_AND_SIZE(idp_pin_config));\r\npxa_set_ffuart_info(NULL);\r\npxa_set_btuart_info(NULL);\r\npxa_set_stuart_info(NULL);\r\nplatform_device_register(&smc91x_device);\r\npxa_set_fb_info(NULL, &sharp_lm8v31);\r\npxa_set_mci_info(&idp_mci_platform_data);\r\n}\r\nstatic void __init idp_map_io(void)\r\n{\r\npxa25x_map_io();\r\niotable_init(idp_io_desc, ARRAY_SIZE(idp_io_desc));\r\n}\r\nstatic void idp_led_set(struct led_classdev *cdev,\r\nenum led_brightness b)\r\n{\r\nstruct idp_led *led = container_of(cdev,\r\nstruct idp_led, cdev);\r\nu32 reg = IDP_CPLD_LED_CONTROL;\r\nif (b != LED_OFF)\r\nreg &= ~led->mask;\r\nelse\r\nreg |= led->mask;\r\nIDP_CPLD_LED_CONTROL = reg;\r\n}\r\nstatic enum led_brightness idp_led_get(struct led_classdev *cdev)\r\n{\r\nstruct idp_led *led = container_of(cdev,\r\nstruct idp_led, cdev);\r\nreturn (IDP_CPLD_LED_CONTROL & led->mask) ? LED_OFF : LED_FULL;\r\n}\r\nstatic int __init idp_leds_init(void)\r\n{\r\nint i;\r\nif (!machine_is_pxa_idp())\r\nreturn -ENODEV;\r\nfor (i = 0; i < ARRAY_SIZE(idp_leds); i++) {\r\nstruct idp_led *led;\r\nled = kzalloc(sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nbreak;\r\nled->cdev.name = idp_leds[i].name;\r\nled->cdev.brightness_set = idp_led_set;\r\nled->cdev.brightness_get = idp_led_get;\r\nled->cdev.default_trigger = idp_leds[i].trigger;\r\nif (i == 0)\r\nled->mask = IDP_HB_LED;\r\nelse\r\nled->mask = IDP_BUSY_LED;\r\nif (led_classdev_register(NULL, &led->cdev) < 0) {\r\nkfree(led);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
