static u_long mac_get_tneg(struct s_smc *smc)\r\n{\r\nu_long tneg ;\r\ntneg = (u_long)((long)inpw(FM_A(FM_TNEG))<<5) ;\r\nreturn (u_long)((tneg + ((inpw(FM_A(FM_TMRS))>>10)&0x1f)) |\r\n0xffe00000L) ;\r\n}\r\nvoid mac_update_counter(struct s_smc *smc)\r\n{\r\nsmc->mib.m[MAC0].fddiMACFrame_Ct =\r\n(smc->mib.m[MAC0].fddiMACFrame_Ct & 0xffff0000L)\r\n+ (u_short) inpw(FM_A(FM_FCNTR)) ;\r\nsmc->mib.m[MAC0].fddiMACLost_Ct =\r\n(smc->mib.m[MAC0].fddiMACLost_Ct & 0xffff0000L)\r\n+ (u_short) inpw(FM_A(FM_LCNTR)) ;\r\nsmc->mib.m[MAC0].fddiMACError_Ct =\r\n(smc->mib.m[MAC0].fddiMACError_Ct & 0xffff0000L)\r\n+ (u_short) inpw(FM_A(FM_ECNTR)) ;\r\nsmc->mib.m[MAC0].fddiMACT_Neg = mac_get_tneg(smc) ;\r\n#ifdef SMT_REAL_TOKEN_CT\r\nTBD\r\n#else\r\nsmt_emulate_token_ct( smc, MAC0 );\r\n#endif\r\n}\r\nstatic void write_mdr(struct s_smc *smc, u_long val)\r\n{\r\nCHECK_NPP() ;\r\nMDRW(val) ;\r\n}\r\nstatic void init_ram(struct s_smc *smc)\r\n{\r\nu_short i ;\r\nsmc->hw.fp.fifo.rbc_ram_start = 0 ;\r\nsmc->hw.fp.fifo.rbc_ram_end =\r\nsmc->hw.fp.fifo.rbc_ram_start + RBC_MEM_SIZE ;\r\nCHECK_NPP() ;\r\nMARW(smc->hw.fp.fifo.rbc_ram_start) ;\r\nfor (i = smc->hw.fp.fifo.rbc_ram_start;\r\ni < (u_short) (smc->hw.fp.fifo.rbc_ram_end-1); i++)\r\nwrite_mdr(smc,0L) ;\r\nwrite_mdr(smc,0L) ;\r\n}\r\nstatic void set_recvptr(struct s_smc *smc)\r\n{\r\noutpw(FM_A(FM_RPR1),smc->hw.fp.fifo.rx1_fifo_start) ;\r\noutpw(FM_A(FM_SWPR1),smc->hw.fp.fifo.rx1_fifo_start) ;\r\noutpw(FM_A(FM_WPR1),smc->hw.fp.fifo.rx1_fifo_start) ;\r\noutpw(FM_A(FM_EARV1),smc->hw.fp.fifo.tx_s_start-1) ;\r\nif (smc->hw.fp.fifo.rx2_fifo_size) {\r\noutpw(FM_A(FM_RPR2),smc->hw.fp.fifo.rx2_fifo_start) ;\r\noutpw(FM_A(FM_SWPR2),smc->hw.fp.fifo.rx2_fifo_start) ;\r\noutpw(FM_A(FM_WPR2),smc->hw.fp.fifo.rx2_fifo_start) ;\r\noutpw(FM_A(FM_EARV2),smc->hw.fp.fifo.rbc_ram_end-1) ;\r\n}\r\nelse {\r\noutpw(FM_A(FM_RPR2),smc->hw.fp.fifo.rbc_ram_end-1) ;\r\noutpw(FM_A(FM_SWPR2),smc->hw.fp.fifo.rbc_ram_end-1) ;\r\noutpw(FM_A(FM_WPR2),smc->hw.fp.fifo.rbc_ram_end-1) ;\r\noutpw(FM_A(FM_EARV2),smc->hw.fp.fifo.rbc_ram_end-1) ;\r\n}\r\n}\r\nstatic void set_txptr(struct s_smc *smc)\r\n{\r\noutpw(FM_A(FM_CMDREG2),FM_IRSTQ) ;\r\noutpw(FM_A(FM_RPXA0),smc->hw.fp.fifo.tx_a0_start) ;\r\noutpw(FM_A(FM_SWPXA0),smc->hw.fp.fifo.tx_a0_start) ;\r\noutpw(FM_A(FM_WPXA0),smc->hw.fp.fifo.tx_a0_start) ;\r\noutpw(FM_A(FM_EAA0),smc->hw.fp.fifo.rx2_fifo_start-1) ;\r\nif (smc->hw.fp.fifo.tx_s_size) {\r\noutpw(FM_A(FM_RPXS),smc->hw.fp.fifo.tx_s_start) ;\r\noutpw(FM_A(FM_SWPXS),smc->hw.fp.fifo.tx_s_start) ;\r\noutpw(FM_A(FM_WPXS),smc->hw.fp.fifo.tx_s_start) ;\r\noutpw(FM_A(FM_EAS),smc->hw.fp.fifo.tx_a0_start-1) ;\r\n}\r\nelse {\r\noutpw(FM_A(FM_RPXS),smc->hw.fp.fifo.tx_a0_start-1) ;\r\noutpw(FM_A(FM_SWPXS),smc->hw.fp.fifo.tx_a0_start-1) ;\r\noutpw(FM_A(FM_WPXS),smc->hw.fp.fifo.tx_a0_start-1) ;\r\noutpw(FM_A(FM_EAS),smc->hw.fp.fifo.tx_a0_start-1) ;\r\n}\r\n}\r\nstatic void init_rbc(struct s_smc *smc)\r\n{\r\nu_short rbc_ram_addr ;\r\nrbc_ram_addr = smc->hw.fp.fifo.rx2_fifo_start - 1 ;\r\noutpw(FM_A(FM_RPXA1),rbc_ram_addr) ;\r\noutpw(FM_A(FM_WPXA1),rbc_ram_addr) ;\r\noutpw(FM_A(FM_SWPXA1),rbc_ram_addr) ;\r\noutpw(FM_A(FM_EAA1),rbc_ram_addr) ;\r\nset_recvptr(smc) ;\r\nset_txptr(smc) ;\r\n}\r\nstatic void init_rx(struct s_smc *smc)\r\n{\r\nstruct s_smt_rx_queue *queue ;\r\nsmc->hw.fp.rx[QUEUE_R1] = queue = &smc->hw.fp.rx_q[QUEUE_R1] ;\r\nqueue->rx_bmu_ctl = (HW_PTR) ADDR(B0_R1_CSR) ;\r\nqueue->rx_bmu_dsc = (HW_PTR) ADDR(B4_R1_DA) ;\r\nsmc->hw.fp.rx[QUEUE_R2] = queue = &smc->hw.fp.rx_q[QUEUE_R2] ;\r\nqueue->rx_bmu_ctl = (HW_PTR) ADDR(B0_R2_CSR) ;\r\nqueue->rx_bmu_dsc = (HW_PTR) ADDR(B4_R2_DA) ;\r\n}\r\nvoid set_formac_tsync(struct s_smc *smc, long sync_bw)\r\n{\r\noutpw(FM_A(FM_TSYNC),(unsigned int) (((-sync_bw) >> 5) & 0xffff) ) ;\r\n}\r\nstatic void init_tx(struct s_smc *smc)\r\n{\r\nstruct s_smt_tx_queue *queue ;\r\nsmc->hw.fp.tx[QUEUE_S] = queue = &smc->hw.fp.tx_q[QUEUE_S] ;\r\nqueue->tx_bmu_ctl = (HW_PTR) ADDR(B0_XS_CSR) ;\r\nqueue->tx_bmu_dsc = (HW_PTR) ADDR(B5_XS_DA) ;\r\n#ifdef ESS\r\nset_formac_tsync(smc,smc->ess.sync_bw) ;\r\n#endif\r\nsmc->hw.fp.tx[QUEUE_A0] = queue = &smc->hw.fp.tx_q[QUEUE_A0] ;\r\nqueue->tx_bmu_ctl = (HW_PTR) ADDR(B0_XA_CSR) ;\r\nqueue->tx_bmu_dsc = (HW_PTR) ADDR(B5_XA_DA) ;\r\nllc_recover_tx(smc) ;\r\n}\r\nstatic void mac_counter_init(struct s_smc *smc)\r\n{\r\nint i ;\r\nu_long *ec ;\r\noutpw(FM_A(FM_FCNTR),0) ;\r\noutpw(FM_A(FM_LCNTR),0) ;\r\noutpw(FM_A(FM_ECNTR),0) ;\r\nec = (u_long *)&smc->hw.fp.err_stats ;\r\nfor (i = (sizeof(struct err_st)/sizeof(long)) ; i ; i--)\r\n*ec++ = 0L ;\r\nsmc->mib.m[MAC0].fddiMACRingOp_Ct = 0 ;\r\n}\r\nstatic void set_formac_addr(struct s_smc *smc)\r\n{\r\nlong t_requ = smc->mib.m[MAC0].fddiMACT_Req ;\r\noutpw(FM_A(FM_SAID),my_said) ;\r\noutpw(FM_A(FM_LAIL),(unsigned short)((smc->hw.fddi_home_addr.a[4]<<8) +\r\nsmc->hw.fddi_home_addr.a[5])) ;\r\noutpw(FM_A(FM_LAIC),(unsigned short)((smc->hw.fddi_home_addr.a[2]<<8) +\r\nsmc->hw.fddi_home_addr.a[3])) ;\r\noutpw(FM_A(FM_LAIM),(unsigned short)((smc->hw.fddi_home_addr.a[0]<<8) +\r\nsmc->hw.fddi_home_addr.a[1])) ;\r\noutpw(FM_A(FM_SAGP),my_sagp) ;\r\noutpw(FM_A(FM_LAGL),(unsigned short)((smc->hw.fp.group_addr.a[4]<<8) +\r\nsmc->hw.fp.group_addr.a[5])) ;\r\noutpw(FM_A(FM_LAGC),(unsigned short)((smc->hw.fp.group_addr.a[2]<<8) +\r\nsmc->hw.fp.group_addr.a[3])) ;\r\noutpw(FM_A(FM_LAGM),(unsigned short)((smc->hw.fp.group_addr.a[0]<<8) +\r\nsmc->hw.fp.group_addr.a[1])) ;\r\noutpw(FM_A(FM_TREQ1),(unsigned short)(t_requ>>16)) ;\r\noutpw(FM_A(FM_TREQ0),(unsigned short)t_requ) ;\r\n}\r\nstatic void set_int(char *p, int l)\r\n{\r\np[0] = (char)(l >> 24) ;\r\np[1] = (char)(l >> 16) ;\r\np[2] = (char)(l >> 8) ;\r\np[3] = (char)(l >> 0) ;\r\n}\r\nstatic void copy_tx_mac(struct s_smc *smc, u_long td, struct fddi_mac *mac,\r\nunsigned int off, int len)\r\n{\r\nint i ;\r\n__le32 *p ;\r\nCHECK_NPP() ;\r\nMARW(off) ;\r\np = (__le32 *) mac ;\r\nfor (i = (len + 3)/4 ; i ; i--) {\r\nif (i == 1) {\r\noutpw(FM_A(FM_CMDREG2),FM_ISTTB) ;\r\n}\r\nwrite_mdr(smc,le32_to_cpu(*p)) ;\r\np++ ;\r\n}\r\noutpw(FM_A(FM_CMDREG2),FM_ISTTB) ;\r\nwrite_mdr(smc,td) ;\r\n}\r\nstatic void directed_beacon(struct s_smc *smc)\r\n{\r\nSK_LOC_DECL(__le32,a[2]) ;\r\n* (char *) a = (char) ((long)DBEACON_INFO<<24L) ;\r\na[1] = 0 ;\r\nmemcpy((char *)a+1, (char *) &smc->mib.m[MAC0].fddiMACUpstreamNbr, ETH_ALEN);\r\nCHECK_NPP() ;\r\nMARW(smc->hw.fp.fifo.rbc_ram_start+DBEACON_FRAME_OFF+4) ;\r\nwrite_mdr(smc,le32_to_cpu(a[0])) ;\r\noutpw(FM_A(FM_CMDREG2),FM_ISTTB) ;\r\nwrite_mdr(smc,le32_to_cpu(a[1])) ;\r\noutpw(FM_A(FM_SABC),smc->hw.fp.fifo.rbc_ram_start + DBEACON_FRAME_OFF) ;\r\n}\r\nstatic void build_claim_beacon(struct s_smc *smc, u_long t_request)\r\n{\r\nu_int td ;\r\nint len ;\r\nstruct fddi_mac_sf *mac ;\r\nlen = 17 ;\r\ntd = TX_DESCRIPTOR | ((((u_int)len-1)&3)<<27) ;\r\nmac = &smc->hw.fp.mac_sfb ;\r\nmac->mac_fc = FC_CLAIM ;\r\nmac->mac_source = mac->mac_dest = MA ;\r\nset_int((char *)mac->mac_info,(int)t_request) ;\r\ncopy_tx_mac(smc,td,(struct fddi_mac *)mac,\r\nsmc->hw.fp.fifo.rbc_ram_start + CLAIM_FRAME_OFF,len) ;\r\noutpw(FM_A(FM_SACL),smc->hw.fp.fifo.rbc_ram_start + CLAIM_FRAME_OFF) ;\r\nlen = 17 ;\r\ntd = TX_DESCRIPTOR | ((((u_int)len-1)&3)<<27) ;\r\nmac->mac_fc = FC_BEACON ;\r\nmac->mac_source = MA ;\r\nmac->mac_dest = null_addr ;\r\nset_int((char *) mac->mac_info,((int)BEACON_INFO<<24) + 0 ) ;\r\ncopy_tx_mac(smc,td,(struct fddi_mac *)mac,\r\nsmc->hw.fp.fifo.rbc_ram_start + BEACON_FRAME_OFF,len) ;\r\noutpw(FM_A(FM_SABC),smc->hw.fp.fifo.rbc_ram_start + BEACON_FRAME_OFF) ;\r\nlen = 23 ;\r\ntd = TX_DESCRIPTOR | ((((u_int)len-1)&3)<<27) ;\r\nmac->mac_fc = FC_BEACON ;\r\nmac->mac_source = MA ;\r\nmac->mac_dest = dbeacon_multi ;\r\nset_int((char *) mac->mac_info,((int)DBEACON_INFO<<24) + 0 ) ;\r\nset_int((char *) mac->mac_info+4,0) ;\r\nset_int((char *) mac->mac_info+8,0) ;\r\ncopy_tx_mac(smc,td,(struct fddi_mac *)mac,\r\nsmc->hw.fp.fifo.rbc_ram_start + DBEACON_FRAME_OFF,len) ;\r\noutpw(FM_A(FM_EACB),smc->hw.fp.fifo.rx1_fifo_start-1) ;\r\noutpw(FM_A(FM_WPXSF),0) ;\r\noutpw(FM_A(FM_RPXSF),0) ;\r\n}\r\nstatic void formac_rcv_restart(struct s_smc *smc)\r\n{\r\nSETMASK(FM_A(FM_MDREG1),smc->hw.fp.rx_mode,FM_ADDRX) ;\r\noutpw(FM_A(FM_CMDREG1),FM_ICLLR) ;\r\n}\r\nvoid formac_tx_restart(struct s_smc *smc)\r\n{\r\noutpw(FM_A(FM_CMDREG1),FM_ICLLS) ;\r\noutpw(FM_A(FM_CMDREG1),FM_ICLLA0) ;\r\n}\r\nstatic void enable_formac(struct s_smc *smc)\r\n{\r\noutpw(FM_A(FM_IMSK1U),(unsigned short)~mac_imsk1u);\r\noutpw(FM_A(FM_IMSK1L),(unsigned short)~mac_imsk1l);\r\noutpw(FM_A(FM_IMSK2U),(unsigned short)~mac_imsk2u);\r\noutpw(FM_A(FM_IMSK2L),(unsigned short)~mac_imsk2l);\r\noutpw(FM_A(FM_IMSK3U),(unsigned short)~mac_imsk3u);\r\noutpw(FM_A(FM_IMSK3L),(unsigned short)~mac_imsk3l);\r\n}\r\nstatic void disable_formac(struct s_smc *smc)\r\n{\r\noutpw(FM_A(FM_IMSK1U),MW) ;\r\noutpw(FM_A(FM_IMSK1L),MW) ;\r\noutpw(FM_A(FM_IMSK2U),MW) ;\r\noutpw(FM_A(FM_IMSK2L),MW) ;\r\noutpw(FM_A(FM_IMSK3U),MW) ;\r\noutpw(FM_A(FM_IMSK3L),MW) ;\r\n}\r\nstatic void mac_ring_up(struct s_smc *smc, int up)\r\n{\r\nif (up) {\r\nformac_rcv_restart(smc) ;\r\nsmc->hw.mac_ring_is_up = TRUE ;\r\nllc_restart_tx(smc) ;\r\n}\r\nelse {\r\nSETMASK(FM_A(FM_MDREG1),FM_MDISRCV,FM_ADDET) ;\r\noutpw(FM_A(FM_CMDREG2),FM_IACTR) ;\r\nsmc->hw.mac_ring_is_up = FALSE ;\r\n}\r\n}\r\nvoid mac2_irq(struct s_smc *smc, u_short code_s2u, u_short code_s2l)\r\n{\r\nu_short change_s2l ;\r\nu_short change_s2u ;\r\nif (code_s2u & (FM_SCLM|FM_SHICLM|FM_SBEC|FM_SOTRBEC)) {\r\nqueue_event(smc,EVENT_RMT,RM_TX_STATE_CHANGE) ;\r\n}\r\nelse if (code_s2l & (FM_STKISS)) {\r\nqueue_event(smc,EVENT_RMT,RM_TX_STATE_CHANGE) ;\r\n}\r\nchange_s2l = smc->hw.fp.s2l ^ code_s2l ;\r\nchange_s2u = smc->hw.fp.s2u ^ code_s2u ;\r\nif ((change_s2l & FM_SRNGOP) ||\r\n(!smc->hw.mac_ring_is_up && ((code_s2l & FM_SRNGOP)))) {\r\nif (code_s2l & FM_SRNGOP) {\r\nmac_ring_up(smc,1) ;\r\nqueue_event(smc,EVENT_RMT,RM_RING_OP) ;\r\nsmc->mib.m[MAC0].fddiMACRingOp_Ct++ ;\r\n}\r\nelse {\r\nmac_ring_up(smc,0) ;\r\nqueue_event(smc,EVENT_RMT,RM_RING_NON_OP) ;\r\n}\r\ngoto mac2_end ;\r\n}\r\nif (code_s2l & FM_SMISFRM) {\r\nsmc->mib.m[MAC0].fddiMACNotCopied_Ct++ ;\r\n}\r\nif (code_s2u & (FM_SRCVOVR |\r\nFM_SRBFL)) {\r\nsmc->hw.mac_ct.mac_r_restart_counter++ ;\r\nsmt_stat_counter(smc,1) ;\r\n}\r\nif (code_s2u & FM_SOTRBEC)\r\nqueue_event(smc,EVENT_RMT,RM_OTHER_BEACON) ;\r\nif (code_s2u & FM_SMYBEC)\r\nqueue_event(smc,EVENT_RMT,RM_MY_BEACON) ;\r\nif (change_s2u & code_s2u & FM_SLOCLM) {\r\nDB_RMTN(2,"RMT : lower claim received\n",0,0) ;\r\n}\r\nif ((code_s2u & FM_SMYCLM) && !(code_s2l & FM_SDUPCLM)) {\r\nqueue_event(smc,EVENT_RMT,RM_MY_CLAIM) ;\r\n}\r\nif (code_s2l & FM_SDUPCLM) {\r\nqueue_event(smc,EVENT_RMT,RM_VALID_CLAIM) ;\r\n}\r\nif (change_s2u & code_s2u & FM_SHICLM) {\r\nDB_RMTN(2,"RMT : higher claim received\n",0,0) ;\r\n}\r\nif ( (code_s2l & FM_STRTEXP) ||\r\n(code_s2l & FM_STRTEXR) )\r\nqueue_event(smc,EVENT_RMT,RM_TRT_EXP) ;\r\nif (code_s2l & FM_SMULTDA) {\r\nsmc->r.dup_addr_test = DA_FAILED ;\r\nqueue_event(smc,EVENT_RMT,RM_DUP_ADDR) ;\r\n}\r\nif (code_s2u & FM_SBEC)\r\nsmc->hw.fp.err_stats.err_bec_stat++ ;\r\nif (code_s2u & FM_SCLM)\r\nsmc->hw.fp.err_stats.err_clm_stat++ ;\r\nif (code_s2l & FM_STVXEXP)\r\nsmc->mib.m[MAC0].fddiMACTvxExpired_Ct++ ;\r\nif ((code_s2u & (FM_SBEC|FM_SCLM))) {\r\nif (!(change_s2l & FM_SRNGOP) && (smc->hw.fp.s2l & FM_SRNGOP)) {\r\nmac_ring_up(smc,0) ;\r\nqueue_event(smc,EVENT_RMT,RM_RING_NON_OP) ;\r\nmac_ring_up(smc,1) ;\r\nqueue_event(smc,EVENT_RMT,RM_RING_OP) ;\r\nsmc->mib.m[MAC0].fddiMACRingOp_Ct++ ;\r\n}\r\n}\r\nif (code_s2l & FM_SPHINV)\r\nsmc->hw.fp.err_stats.err_phinv++ ;\r\nif (code_s2l & FM_SSIFG)\r\nsmc->hw.fp.err_stats.err_sifg_det++ ;\r\nif (code_s2l & FM_STKISS)\r\nsmc->hw.fp.err_stats.err_tkiss++ ;\r\nif (code_s2l & FM_STKERR)\r\nsmc->hw.fp.err_stats.err_tkerr++ ;\r\nif (code_s2l & FM_SFRMCTR)\r\nsmc->mib.m[MAC0].fddiMACFrame_Ct += 0x10000L ;\r\nif (code_s2l & FM_SERRCTR)\r\nsmc->mib.m[MAC0].fddiMACError_Ct += 0x10000L ;\r\nif (code_s2l & FM_SLSTCTR)\r\nsmc->mib.m[MAC0].fddiMACLost_Ct += 0x10000L ;\r\nif (code_s2u & FM_SERRSF) {\r\nSMT_PANIC(smc,SMT_E0114, SMT_E0114_MSG) ;\r\n}\r\nmac2_end:\r\nsmc->hw.fp.s2l = code_s2l ;\r\nsmc->hw.fp.s2u = code_s2u ;\r\noutpw(FM_A(FM_IMSK2U),~mac_imsk2u) ;\r\n}\r\nvoid mac3_irq(struct s_smc *smc, u_short code_s3u, u_short code_s3l)\r\n{\r\nUNUSED(code_s3l) ;\r\nif (code_s3u & (FM_SRCVOVR2 |\r\nFM_SRBFL2)) {\r\nsmc->hw.mac_ct.mac_r_restart_counter++ ;\r\nsmt_stat_counter(smc,1);\r\n}\r\nif (code_s3u & FM_SRPERRQ2) {\r\nSMT_PANIC(smc,SMT_E0115, SMT_E0115_MSG) ;\r\n}\r\nif (code_s3u & FM_SRPERRQ1) {\r\nSMT_PANIC(smc,SMT_E0116, SMT_E0116_MSG) ;\r\n}\r\n}\r\nstatic void formac_offline(struct s_smc *smc)\r\n{\r\noutpw(FM_A(FM_CMDREG2),FM_IACTR) ;\r\nSETMASK(FM_A(FM_MDREG1),FM_MDISRCV,FM_ADDET) ;\r\nSETMASK(FM_A(FM_MDREG1),FM_MINIT,FM_MMODE) ;\r\ndisable_formac(smc) ;\r\nsmc->hw.mac_ring_is_up = FALSE ;\r\nsmc->hw.hw_state = STOPPED ;\r\n}\r\nstatic void formac_online(struct s_smc *smc)\r\n{\r\nenable_formac(smc) ;\r\nSETMASK(FM_A(FM_MDREG1),FM_MONLINE | FM_SELRA | MDR1INIT |\r\nsmc->hw.fp.rx_mode, FM_MMODE | FM_SELRA | FM_ADDRX) ;\r\n}\r\nint init_fplus(struct s_smc *smc)\r\n{\r\nsmc->hw.fp.nsa_mode = FM_MRNNSAFNMA ;\r\nsmc->hw.fp.rx_mode = FM_MDAMA ;\r\nsmc->hw.fp.group_addr = fddi_broadcast ;\r\nsmc->hw.fp.func_addr = 0 ;\r\nsmc->hw.fp.frselreg_init = 0 ;\r\ninit_driver_fplus(smc) ;\r\nif (smc->s.sas == SMT_DAS)\r\nsmc->hw.fp.mdr3init |= FM_MENDAS ;\r\nsmc->hw.mac_ct.mac_nobuf_counter = 0 ;\r\nsmc->hw.mac_ct.mac_r_restart_counter = 0 ;\r\nsmc->hw.fp.fm_st1u = (HW_PTR) ADDR(B0_ST1U) ;\r\nsmc->hw.fp.fm_st1l = (HW_PTR) ADDR(B0_ST1L) ;\r\nsmc->hw.fp.fm_st2u = (HW_PTR) ADDR(B0_ST2U) ;\r\nsmc->hw.fp.fm_st2l = (HW_PTR) ADDR(B0_ST2L) ;\r\nsmc->hw.fp.fm_st3u = (HW_PTR) ADDR(B0_ST3U) ;\r\nsmc->hw.fp.fm_st3l = (HW_PTR) ADDR(B0_ST3L) ;\r\nsmc->hw.fp.s2l = smc->hw.fp.s2u = 0 ;\r\nsmc->hw.mac_ring_is_up = 0 ;\r\nmac_counter_init(smc) ;\r\nsmc->hw.mac_pa.t_neg = (u_long)0 ;\r\nsmc->hw.mac_pa.t_pri = (u_long)0 ;\r\nmac_do_pci_fix(smc) ;\r\nreturn init_mac(smc, 1);\r\n}\r\nstatic int init_mac(struct s_smc *smc, int all)\r\n{\r\nu_short t_max,x ;\r\nu_long time=0 ;\r\noutpw(FM_A(FM_MDREG1),FM_MINIT) ;\r\nset_formac_addr(smc) ;\r\noutpw(FM_A(FM_MDREG1),FM_MMEMACT) ;\r\noutpw(FM_A(FM_MDREG2),smc->hw.fp.mdr2init) ;\r\nif (all) {\r\ninit_ram(smc) ;\r\n}\r\nelse {\r\noutp(ADDR(B0_CTRL), CTRL_HPI_SET) ;\r\ntime = hwt_quick_read(smc) ;\r\n}\r\nsmt_split_up_fifo(smc) ;\r\ninit_tx(smc) ;\r\ninit_rx(smc) ;\r\ninit_rbc(smc) ;\r\nbuild_claim_beacon(smc,smc->mib.m[MAC0].fddiMACT_Req) ;\r\noutpw(FM_A(FM_FRMTHR),14<<12) ;\r\noutpw(FM_A(FM_MDREG1),MDR1INIT | FM_SELRA | smc->hw.fp.rx_mode) ;\r\noutpw(FM_A(FM_MDREG2),smc->hw.fp.mdr2init) ;\r\noutpw(FM_A(FM_MDREG3),smc->hw.fp.mdr3init) ;\r\noutpw(FM_A(FM_FRSELREG),smc->hw.fp.frselreg_init) ;\r\nt_max = (u_short)(smc->mib.m[MAC0].fddiMACT_Max/32) ;\r\nx = t_max/0x27 ;\r\nx *= 0x27 ;\r\nif ((t_max == 0xfffe) || (t_max - x == 0x16))\r\nt_max-- ;\r\noutpw(FM_A(FM_TMAX),(u_short)t_max) ;\r\nif (smc->mib.m[MAC0].fddiMACTvxValue < (u_long) (- US2BCLK(52))) {\r\noutpw(FM_A(FM_TVX), (u_short) (- US2BCLK(52))/255 & MB) ;\r\n} else {\r\noutpw(FM_A(FM_TVX),\r\n(u_short)((smc->mib.m[MAC0].fddiMACTvxValue/255) & MB)) ;\r\n}\r\noutpw(FM_A(FM_CMDREG1),FM_ICLLS) ;\r\noutpw(FM_A(FM_CMDREG1),FM_ICLLA0) ;\r\noutpw(FM_A(FM_CMDREG1),FM_ICLLR);\r\noutpw(FM_A(FM_UNLCKDLY),(0xff|(0xff<<8))) ;\r\nrtm_init(smc) ;\r\nif (!all) {\r\nhwt_wait_time(smc,time,MS2BCLK(10)) ;\r\noutpd(ADDR(B0_R1_CSR),CSR_SET_RESET) ;\r\noutpd(ADDR(B0_XA_CSR),CSR_SET_RESET) ;\r\noutpd(ADDR(B0_XS_CSR),CSR_SET_RESET) ;\r\noutp(ADDR(B0_CTRL), CTRL_HPI_CLR) ;\r\noutpd(ADDR(B0_R1_CSR),CSR_CLR_RESET) ;\r\noutpd(ADDR(B0_XA_CSR),CSR_CLR_RESET) ;\r\noutpd(ADDR(B0_XS_CSR),CSR_CLR_RESET) ;\r\nif (!smc->hw.hw_is_64bit) {\r\noutpd(ADDR(B4_R1_F), RX_WATERMARK) ;\r\noutpd(ADDR(B5_XA_F), TX_WATERMARK) ;\r\noutpd(ADDR(B5_XS_F), TX_WATERMARK) ;\r\n}\r\nsmc->hw.hw_state = STOPPED ;\r\nmac_drv_repair_descr(smc) ;\r\n}\r\nsmc->hw.hw_state = STARTED ;\r\nreturn 0;\r\n}\r\nvoid config_mux(struct s_smc *smc, int mux)\r\n{\r\nplc_config_mux(smc,mux) ;\r\nSETMASK(FM_A(FM_MDREG1),FM_SELRA,FM_SELRA) ;\r\n}\r\nvoid sm_mac_check_beacon_claim(struct s_smc *smc)\r\n{\r\noutpw(FM_A(FM_IMSK2U),~(mac_imsk2u | mac_beacon_imsk2u)) ;\r\nformac_rcv_restart(smc) ;\r\nprocess_receive(smc) ;\r\n}\r\nvoid sm_ma_control(struct s_smc *smc, int mode)\r\n{\r\nswitch(mode) {\r\ncase MA_OFFLINE :\r\nformac_offline(smc) ;\r\nbreak ;\r\ncase MA_RESET :\r\n(void)init_mac(smc,0) ;\r\nbreak ;\r\ncase MA_BEACON :\r\nformac_online(smc) ;\r\nbreak ;\r\ncase MA_DIRECTED :\r\ndirected_beacon(smc) ;\r\nbreak ;\r\ncase MA_TREQ :\r\nbreak ;\r\n}\r\n}\r\nint sm_mac_get_tx_state(struct s_smc *smc)\r\n{\r\nreturn (inpw(FM_A(FM_STMCHN))>>4) & 7;\r\n}\r\nstatic struct s_fpmc* mac_get_mc_table(struct s_smc *smc,\r\nstruct fddi_addr *user,\r\nstruct fddi_addr *own,\r\nint del, int can)\r\n{\r\nstruct s_fpmc *tb ;\r\nstruct s_fpmc *slot ;\r\nu_char *p ;\r\nint i ;\r\n*own = *user ;\r\nif (can) {\r\np = own->a ;\r\nfor (i = 0 ; i < 6 ; i++, p++)\r\n*p = bitrev8(*p);\r\n}\r\nslot = NULL;\r\nfor (i = 0, tb = smc->hw.fp.mc.table ; i < FPMAX_MULTICAST ; i++, tb++){\r\nif (!tb->n) {\r\nif (!del && !slot)\r\nslot = tb ;\r\ncontinue ;\r\n}\r\nif (!ether_addr_equal((char *)&tb->a, (char *)own))\r\ncontinue ;\r\nreturn tb;\r\n}\r\nreturn slot;\r\n}\r\nvoid mac_clear_multicast(struct s_smc *smc)\r\n{\r\nstruct s_fpmc *tb ;\r\nint i ;\r\nsmc->hw.fp.os_slots_used = 0 ;\r\nfor (i = 0, tb = smc->hw.fp.mc.table ; i < FPMAX_MULTICAST ; i++, tb++){\r\nif (!tb->perm) {\r\ntb->n = 0 ;\r\n}\r\n}\r\n}\r\nint mac_add_multicast(struct s_smc *smc, struct fddi_addr *addr, int can)\r\n{\r\nSK_LOC_DECL(struct fddi_addr,own) ;\r\nstruct s_fpmc *tb ;\r\nif (can & 0x80) {\r\nif (smc->hw.fp.smt_slots_used >= SMT_MAX_MULTI) {\r\nreturn 1;\r\n}\r\n}\r\nelse {\r\nif (smc->hw.fp.os_slots_used >= FPMAX_MULTICAST-SMT_MAX_MULTI) {\r\nreturn 1;\r\n}\r\n}\r\nif (!(tb = mac_get_mc_table(smc,addr,&own,0,can & ~0x80)))\r\nreturn 1;\r\ntb->n++ ;\r\ntb->a = own ;\r\ntb->perm = (can & 0x80) ? 1 : 0 ;\r\nif (can & 0x80)\r\nsmc->hw.fp.smt_slots_used++ ;\r\nelse\r\nsmc->hw.fp.os_slots_used++ ;\r\nreturn 0;\r\n}\r\nvoid mac_update_multicast(struct s_smc *smc)\r\n{\r\nstruct s_fpmc *tb ;\r\nu_char *fu ;\r\nint i ;\r\noutpw(FM_A(FM_AFCMD),FM_IINV_CAM) ;\r\nif (smc->hw.fp.func_addr) {\r\nfu = (u_char *) &smc->hw.fp.func_addr ;\r\noutpw(FM_A(FM_AFMASK2),0xffff) ;\r\noutpw(FM_A(FM_AFMASK1),(u_short) ~((fu[0] << 8) + fu[1])) ;\r\noutpw(FM_A(FM_AFMASK0),(u_short) ~((fu[2] << 8) + fu[3])) ;\r\noutpw(FM_A(FM_AFPERS),FM_VALID|FM_DA) ;\r\noutpw(FM_A(FM_AFCOMP2), 0xc000) ;\r\noutpw(FM_A(FM_AFCOMP1), 0x0000) ;\r\noutpw(FM_A(FM_AFCOMP0), 0x0000) ;\r\noutpw(FM_A(FM_AFCMD),FM_IWRITE_CAM) ;\r\n}\r\noutpw(FM_A(FM_AFMASK0),0xffff) ;\r\noutpw(FM_A(FM_AFMASK1),0xffff) ;\r\noutpw(FM_A(FM_AFMASK2),0xffff) ;\r\noutpw(FM_A(FM_AFPERS),FM_VALID|FM_DA) ;\r\nfor (i = 0, tb = smc->hw.fp.mc.table; i < FPMAX_MULTICAST; i++, tb++) {\r\nif (tb->n) {\r\nCHECK_CAM() ;\r\noutpw(FM_A(FM_AFCOMP2),\r\n(u_short)((tb->a.a[0]<<8)+tb->a.a[1])) ;\r\noutpw(FM_A(FM_AFCOMP1),\r\n(u_short)((tb->a.a[2]<<8)+tb->a.a[3])) ;\r\noutpw(FM_A(FM_AFCOMP0),\r\n(u_short)((tb->a.a[4]<<8)+tb->a.a[5])) ;\r\noutpw(FM_A(FM_AFCMD),FM_IWRITE_CAM) ;\r\n}\r\n}\r\n}\r\nvoid mac_set_rx_mode(struct s_smc *smc, int mode)\r\n{\r\nswitch (mode) {\r\ncase RX_ENABLE_ALLMULTI :\r\nsmc->hw.fp.rx_prom |= RX_MODE_ALL_MULTI ;\r\nbreak ;\r\ncase RX_DISABLE_ALLMULTI :\r\nsmc->hw.fp.rx_prom &= ~RX_MODE_ALL_MULTI ;\r\nbreak ;\r\ncase RX_ENABLE_PROMISC :\r\nsmc->hw.fp.rx_prom |= RX_MODE_PROM ;\r\nbreak ;\r\ncase RX_DISABLE_PROMISC :\r\nsmc->hw.fp.rx_prom &= ~RX_MODE_PROM ;\r\nbreak ;\r\ncase RX_ENABLE_NSA :\r\nsmc->hw.fp.nsa_mode = FM_MDAMA ;\r\nsmc->hw.fp.rx_mode = (smc->hw.fp.rx_mode & ~FM_ADDET) |\r\nsmc->hw.fp.nsa_mode ;\r\nbreak ;\r\ncase RX_DISABLE_NSA :\r\nsmc->hw.fp.nsa_mode = FM_MRNNSAFNMA ;\r\nsmc->hw.fp.rx_mode = (smc->hw.fp.rx_mode & ~FM_ADDET) |\r\nsmc->hw.fp.nsa_mode ;\r\nbreak ;\r\n}\r\nif (smc->hw.fp.rx_prom & RX_MODE_PROM) {\r\nsmc->hw.fp.rx_mode = FM_MLIMPROM ;\r\n}\r\nelse if (smc->hw.fp.rx_prom & RX_MODE_ALL_MULTI) {\r\nsmc->hw.fp.rx_mode = smc->hw.fp.nsa_mode | FM_EXGPA0 ;\r\n}\r\nelse\r\nsmc->hw.fp.rx_mode = smc->hw.fp.nsa_mode ;\r\nSETMASK(FM_A(FM_MDREG1),smc->hw.fp.rx_mode,FM_ADDRX) ;\r\nmac_update_multicast(smc) ;\r\n}\r\nvoid rtm_irq(struct s_smc *smc)\r\n{\r\noutpw(ADDR(B2_RTM_CRTL),TIM_CL_IRQ) ;\r\nif (inpw(ADDR(B2_RTM_CRTL)) & TIM_RES_TOK) {\r\noutpw(FM_A(FM_CMDREG1),FM_ICL) ;\r\nDB_RMT("RMT: fddiPATHT_Rmode expired\n",0,0) ;\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS,\r\n(u_long) FDDI_SMT_EVENT,\r\n(u_long) FDDI_RTT, smt_get_event_word(smc));\r\n}\r\noutpw(ADDR(B2_RTM_CRTL),TIM_START) ;\r\n}\r\nstatic void rtm_init(struct s_smc *smc)\r\n{\r\noutpd(ADDR(B2_RTM_INI),0) ;\r\noutpw(ADDR(B2_RTM_CRTL),TIM_START) ;\r\n}\r\nvoid rtm_set_timer(struct s_smc *smc)\r\n{\r\nDB_RMT("RMT: setting new fddiPATHT_Rmode, t = %d ns\n",\r\n(int) smc->mib.a[PATH0].fddiPATHT_Rmode,0) ;\r\noutpd(ADDR(B2_RTM_INI),smc->mib.a[PATH0].fddiPATHT_Rmode) ;\r\n}\r\nstatic void smt_split_up_fifo(struct s_smc *smc)\r\n{\r\nif (SMT_R1_RXD_COUNT == 0) {\r\nSMT_PANIC(smc,SMT_E0117, SMT_E0117_MSG) ;\r\n}\r\nswitch(SMT_R2_RXD_COUNT) {\r\ncase 0:\r\nsmc->hw.fp.fifo.rx1_fifo_size = RX_FIFO_SPACE ;\r\nsmc->hw.fp.fifo.rx2_fifo_size = 0 ;\r\nbreak ;\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nsmc->hw.fp.fifo.rx1_fifo_size = RX_LARGE_FIFO ;\r\nsmc->hw.fp.fifo.rx2_fifo_size = RX_SMALL_FIFO ;\r\nbreak ;\r\ndefault:\r\nsmc->hw.fp.fifo.rx1_fifo_size = RX_FIFO_SPACE *\r\nSMT_R1_RXD_COUNT/(SMT_R1_RXD_COUNT+SMT_R2_RXD_COUNT) ;\r\nsmc->hw.fp.fifo.rx2_fifo_size = RX_FIFO_SPACE *\r\nSMT_R2_RXD_COUNT/(SMT_R1_RXD_COUNT+SMT_R2_RXD_COUNT) ;\r\nbreak ;\r\n}\r\nif (smc->mib.a[PATH0].fddiPATHSbaPayload) {\r\n#ifdef ESS\r\nsmc->hw.fp.fifo.fifo_config_mode |=\r\nsmc->mib.fddiESSSynchTxMode | SYNC_TRAFFIC_ON ;\r\n#endif\r\n}\r\nelse {\r\nsmc->hw.fp.fifo.fifo_config_mode &=\r\n~(SEND_ASYNC_AS_SYNC|SYNC_TRAFFIC_ON) ;\r\n}\r\nif (smc->hw.fp.fifo.fifo_config_mode & SYNC_TRAFFIC_ON) {\r\nif (smc->hw.fp.fifo.fifo_config_mode & SEND_ASYNC_AS_SYNC) {\r\nsmc->hw.fp.fifo.tx_s_size = TX_LARGE_FIFO ;\r\nsmc->hw.fp.fifo.tx_a0_size = TX_SMALL_FIFO ;\r\n}\r\nelse {\r\nsmc->hw.fp.fifo.tx_s_size = TX_MEDIUM_FIFO ;\r\nsmc->hw.fp.fifo.tx_a0_size = TX_MEDIUM_FIFO ;\r\n}\r\n}\r\nelse {\r\nsmc->hw.fp.fifo.tx_s_size = 0 ;\r\nsmc->hw.fp.fifo.tx_a0_size = TX_FIFO_SPACE ;\r\n}\r\nsmc->hw.fp.fifo.rx1_fifo_start = smc->hw.fp.fifo.rbc_ram_start +\r\nRX_FIFO_OFF ;\r\nsmc->hw.fp.fifo.tx_s_start = smc->hw.fp.fifo.rx1_fifo_start +\r\nsmc->hw.fp.fifo.rx1_fifo_size ;\r\nsmc->hw.fp.fifo.tx_a0_start = smc->hw.fp.fifo.tx_s_start +\r\nsmc->hw.fp.fifo.tx_s_size ;\r\nsmc->hw.fp.fifo.rx2_fifo_start = smc->hw.fp.fifo.tx_a0_start +\r\nsmc->hw.fp.fifo.tx_a0_size ;\r\nDB_SMT("FIFO split: mode = %x\n",smc->hw.fp.fifo.fifo_config_mode,0) ;\r\nDB_SMT("rbc_ram_start = %x rbc_ram_end = %x\n",\r\nsmc->hw.fp.fifo.rbc_ram_start, smc->hw.fp.fifo.rbc_ram_end) ;\r\nDB_SMT("rx1_fifo_start = %x tx_s_start = %x\n",\r\nsmc->hw.fp.fifo.rx1_fifo_start, smc->hw.fp.fifo.tx_s_start) ;\r\nDB_SMT("tx_a0_start = %x rx2_fifo_start = %x\n",\r\nsmc->hw.fp.fifo.tx_a0_start, smc->hw.fp.fifo.rx2_fifo_start) ;\r\n}\r\nvoid formac_reinit_tx(struct s_smc *smc)\r\n{\r\nif (!smc->hw.fp.fifo.tx_s_size && smc->mib.a[PATH0].fddiPATHSbaPayload){\r\n(void)init_mac(smc,0) ;\r\n}\r\n}
