static int\r\nqla4xxx_space_in_req_ring(struct scsi_qla_host *ha, uint16_t req_cnt)\r\n{\r\nuint16_t cnt;\r\nif ((req_cnt + 2) >= ha->req_q_count) {\r\ncnt = (uint16_t) ha->isp_ops->rd_shdw_req_q_out(ha);\r\nif (ha->request_in < cnt)\r\nha->req_q_count = cnt - ha->request_in;\r\nelse\r\nha->req_q_count = REQUEST_QUEUE_DEPTH -\r\n(ha->request_in - cnt);\r\n}\r\nif ((req_cnt + 2) < ha->req_q_count)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void qla4xxx_advance_req_ring_ptr(struct scsi_qla_host *ha)\r\n{\r\nif (ha->request_in == (REQUEST_QUEUE_DEPTH - 1)) {\r\nha->request_in = 0;\r\nha->request_ptr = ha->request_ring;\r\n} else {\r\nha->request_in++;\r\nha->request_ptr++;\r\n}\r\n}\r\nstatic int qla4xxx_get_req_pkt(struct scsi_qla_host *ha,\r\nstruct queue_entry **queue_entry)\r\n{\r\nuint16_t req_cnt = 1;\r\nif (qla4xxx_space_in_req_ring(ha, req_cnt)) {\r\n*queue_entry = ha->request_ptr;\r\nmemset(*queue_entry, 0, sizeof(**queue_entry));\r\nqla4xxx_advance_req_ring_ptr(ha);\r\nha->req_q_count -= req_cnt;\r\nreturn QLA_SUCCESS;\r\n}\r\nreturn QLA_ERROR;\r\n}\r\nint qla4xxx_send_marker_iocb(struct scsi_qla_host *ha,\r\nstruct ddb_entry *ddb_entry, uint64_t lun, uint16_t mrkr_mod)\r\n{\r\nstruct qla4_marker_entry *marker_entry;\r\nunsigned long flags = 0;\r\nuint8_t status = QLA_SUCCESS;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (qla4xxx_get_req_pkt(ha, (struct queue_entry **) &marker_entry) !=\r\nQLA_SUCCESS) {\r\nstatus = QLA_ERROR;\r\ngoto exit_send_marker;\r\n}\r\nmarker_entry->hdr.entryType = ET_MARKER;\r\nmarker_entry->hdr.entryCount = 1;\r\nmarker_entry->target = cpu_to_le16(ddb_entry->fw_ddb_index);\r\nmarker_entry->modifier = cpu_to_le16(mrkr_mod);\r\nint_to_scsilun(lun, &marker_entry->lun);\r\nwmb();\r\nha->isp_ops->queue_iocb(ha);\r\nexit_send_marker:\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn status;\r\n}\r\nstatic struct continuation_t1_entry *\r\nqla4xxx_alloc_cont_entry(struct scsi_qla_host *ha)\r\n{\r\nstruct continuation_t1_entry *cont_entry;\r\ncont_entry = (struct continuation_t1_entry *)ha->request_ptr;\r\nqla4xxx_advance_req_ring_ptr(ha);\r\ncont_entry->hdr.entryType = ET_CONTINUE;\r\ncont_entry->hdr.entryCount = 1;\r\ncont_entry->hdr.systemDefined = (uint8_t) cpu_to_le16(ha->request_in);\r\nreturn cont_entry;\r\n}\r\nstatic uint16_t qla4xxx_calc_request_entries(uint16_t dsds)\r\n{\r\nuint16_t iocbs;\r\niocbs = 1;\r\nif (dsds > COMMAND_SEG) {\r\niocbs += (dsds - COMMAND_SEG) / CONTINUE_SEG;\r\nif ((dsds - COMMAND_SEG) % CONTINUE_SEG)\r\niocbs++;\r\n}\r\nreturn iocbs;\r\n}\r\nstatic void qla4xxx_build_scsi_iocbs(struct srb *srb,\r\nstruct command_t3_entry *cmd_entry,\r\nuint16_t tot_dsds)\r\n{\r\nstruct scsi_qla_host *ha;\r\nuint16_t avail_dsds;\r\nstruct data_seg_a64 *cur_dsd;\r\nstruct scsi_cmnd *cmd;\r\nstruct scatterlist *sg;\r\nint i;\r\ncmd = srb->cmd;\r\nha = srb->ha;\r\nif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\r\ncmd_entry->ttlByteCnt = __constant_cpu_to_le32(0);\r\nreturn;\r\n}\r\navail_dsds = COMMAND_SEG;\r\ncur_dsd = (struct data_seg_a64 *) & (cmd_entry->dataseg[0]);\r\nscsi_for_each_sg(cmd, sg, tot_dsds, i) {\r\ndma_addr_t sle_dma;\r\nif (avail_dsds == 0) {\r\nstruct continuation_t1_entry *cont_entry;\r\ncont_entry = qla4xxx_alloc_cont_entry(ha);\r\ncur_dsd =\r\n(struct data_seg_a64 *)\r\n&cont_entry->dataseg[0];\r\navail_dsds = CONTINUE_SEG;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\ncur_dsd->base.addrLow = cpu_to_le32(LSDW(sle_dma));\r\ncur_dsd->base.addrHigh = cpu_to_le32(MSDW(sle_dma));\r\ncur_dsd->count = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\ncur_dsd++;\r\n}\r\n}\r\nvoid qla4_83xx_queue_iocb(struct scsi_qla_host *ha)\r\n{\r\nwritel(ha->request_in, &ha->qla4_83xx_reg->req_q_in);\r\nreadl(&ha->qla4_83xx_reg->req_q_in);\r\n}\r\nvoid qla4_83xx_complete_iocb(struct scsi_qla_host *ha)\r\n{\r\nwritel(ha->response_out, &ha->qla4_83xx_reg->rsp_q_out);\r\nreadl(&ha->qla4_83xx_reg->rsp_q_out);\r\n}\r\nvoid qla4_82xx_queue_iocb(struct scsi_qla_host *ha)\r\n{\r\nuint32_t dbval = 0;\r\ndbval = 0x14 | (ha->func_num << 5);\r\ndbval = dbval | (0 << 8) | (ha->request_in << 16);\r\nqla4_82xx_wr_32(ha, ha->nx_db_wr_ptr, ha->request_in);\r\n}\r\nvoid qla4_82xx_complete_iocb(struct scsi_qla_host *ha)\r\n{\r\nwritel(ha->response_out, &ha->qla4_82xx_reg->rsp_q_out);\r\nreadl(&ha->qla4_82xx_reg->rsp_q_out);\r\n}\r\nvoid qla4xxx_queue_iocb(struct scsi_qla_host *ha)\r\n{\r\nwritel(ha->request_in, &ha->reg->req_q_in);\r\nreadl(&ha->reg->req_q_in);\r\n}\r\nvoid qla4xxx_complete_iocb(struct scsi_qla_host *ha)\r\n{\r\nwritel(ha->response_out, &ha->reg->rsp_q_out);\r\nreadl(&ha->reg->rsp_q_out);\r\n}\r\nint qla4xxx_send_command_to_isp(struct scsi_qla_host *ha, struct srb * srb)\r\n{\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nstruct ddb_entry *ddb_entry;\r\nstruct command_t3_entry *cmd_entry;\r\nint nseg;\r\nuint16_t tot_dsds;\r\nuint16_t req_cnt;\r\nunsigned long flags;\r\nuint32_t index;\r\nchar tag[2];\r\nddb_entry = srb->ddb;\r\ntot_dsds = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nindex = (uint32_t)cmd->request->tag;\r\nif (!test_bit(AF_ONLINE, &ha->flags)) {\r\nDEBUG2(printk("scsi%ld: %s: Adapter OFFLINE! "\r\n"Do not issue command.\n",\r\nha->host_no, __func__));\r\ngoto queuing_error;\r\n}\r\nnseg = scsi_dma_map(cmd);\r\nif (nseg < 0)\r\ngoto queuing_error;\r\ntot_dsds = nseg;\r\nreq_cnt = qla4xxx_calc_request_entries(tot_dsds);\r\nif (!qla4xxx_space_in_req_ring(ha, req_cnt))\r\ngoto queuing_error;\r\nif ((ha->iocb_cnt + req_cnt) >= ha->iocb_hiwat)\r\ngoto queuing_error;\r\ncmd_entry = (struct command_t3_entry *) ha->request_ptr;\r\nmemset(cmd_entry, 0, sizeof(struct command_t3_entry));\r\ncmd_entry->hdr.entryType = ET_COMMAND;\r\ncmd_entry->handle = cpu_to_le32(index);\r\ncmd_entry->target = cpu_to_le16(ddb_entry->fw_ddb_index);\r\nint_to_scsilun(cmd->device->lun, &cmd_entry->lun);\r\ncmd_entry->ttlByteCnt = cpu_to_le32(scsi_bufflen(cmd));\r\nmemcpy(cmd_entry->cdb, cmd->cmnd, cmd->cmd_len);\r\ncmd_entry->dataSegCnt = cpu_to_le16(tot_dsds);\r\ncmd_entry->hdr.entryCount = req_cnt;\r\ncmd_entry->control_flags = CF_NO_DATA;\r\nif (scsi_bufflen(cmd)) {\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE)\r\ncmd_entry->control_flags = CF_WRITE;\r\nelse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\r\ncmd_entry->control_flags = CF_READ;\r\nha->bytes_xfered += scsi_bufflen(cmd);\r\nif (ha->bytes_xfered & ~0xFFFFF){\r\nha->total_mbytes_xferred += ha->bytes_xfered >> 20;\r\nha->bytes_xfered &= 0xFFFFF;\r\n}\r\n}\r\ncmd_entry->control_flags |= CF_SIMPLE_TAG;\r\nif (scsi_populate_tag_msg(cmd, tag))\r\nswitch (tag[0]) {\r\ncase MSG_HEAD_TAG:\r\ncmd_entry->control_flags |= CF_HEAD_TAG;\r\nbreak;\r\ncase MSG_ORDERED_TAG:\r\ncmd_entry->control_flags |= CF_ORDERED_TAG;\r\nbreak;\r\n}\r\nqla4xxx_advance_req_ring_ptr(ha);\r\nqla4xxx_build_scsi_iocbs(srb, cmd_entry, tot_dsds);\r\nwmb();\r\nsrb->cmd->host_scribble = (unsigned char *)(unsigned long)index;\r\nsrb->state = SRB_ACTIVE_STATE;\r\nsrb->flags |= SRB_DMA_VALID;\r\nha->iocb_cnt += req_cnt;\r\nsrb->iocb_cnt = req_cnt;\r\nha->req_q_count -= req_cnt;\r\nha->isp_ops->queue_iocb(ha);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\nqueuing_error:\r\nif (tot_dsds)\r\nscsi_dma_unmap(cmd);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_ERROR;\r\n}\r\nint qla4xxx_send_passthru0(struct iscsi_task *task)\r\n{\r\nstruct passthru0 *passthru_iocb;\r\nstruct iscsi_session *sess = task->conn->session;\r\nstruct ddb_entry *ddb_entry = sess->dd_data;\r\nstruct scsi_qla_host *ha = ddb_entry->ha;\r\nstruct ql4_task_data *task_data = task->dd_data;\r\nuint16_t ctrl_flags = 0;\r\nunsigned long flags;\r\nint ret = QLA_ERROR;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\ntask_data->iocb_req_cnt = 1;\r\nif (!qla4xxx_space_in_req_ring(ha, task_data->iocb_req_cnt))\r\ngoto queuing_error;\r\npassthru_iocb = (struct passthru0 *) ha->request_ptr;\r\nmemset(passthru_iocb, 0, sizeof(struct passthru0));\r\npassthru_iocb->hdr.entryType = ET_PASSTHRU0;\r\npassthru_iocb->hdr.systemDefined = SD_ISCSI_PDU;\r\npassthru_iocb->hdr.entryCount = task_data->iocb_req_cnt;\r\npassthru_iocb->handle = task->itt;\r\npassthru_iocb->target = cpu_to_le16(ddb_entry->fw_ddb_index);\r\npassthru_iocb->timeout = cpu_to_le16(PT_DEFAULT_TIMEOUT);\r\nif (task_data->req_len) {\r\nmemcpy((uint8_t *)task_data->req_buffer +\r\nsizeof(struct iscsi_hdr), task->data, task->data_count);\r\nctrl_flags |= PT_FLAG_SEND_BUFFER;\r\npassthru_iocb->out_dsd.base.addrLow =\r\ncpu_to_le32(LSDW(task_data->req_dma));\r\npassthru_iocb->out_dsd.base.addrHigh =\r\ncpu_to_le32(MSDW(task_data->req_dma));\r\npassthru_iocb->out_dsd.count =\r\ncpu_to_le32(task->data_count +\r\nsizeof(struct iscsi_hdr));\r\n}\r\nif (task_data->resp_len) {\r\npassthru_iocb->in_dsd.base.addrLow =\r\ncpu_to_le32(LSDW(task_data->resp_dma));\r\npassthru_iocb->in_dsd.base.addrHigh =\r\ncpu_to_le32(MSDW(task_data->resp_dma));\r\npassthru_iocb->in_dsd.count =\r\ncpu_to_le32(task_data->resp_len);\r\n}\r\nctrl_flags |= (PT_FLAG_ISCSI_PDU | PT_FLAG_WAIT_4_RESPONSE);\r\npassthru_iocb->control_flags = cpu_to_le16(ctrl_flags);\r\nqla4xxx_advance_req_ring_ptr(ha);\r\nwmb();\r\nha->iocb_cnt += task_data->iocb_req_cnt;\r\nha->req_q_count -= task_data->iocb_req_cnt;\r\nha->isp_ops->queue_iocb(ha);\r\nret = QLA_SUCCESS;\r\nqueuing_error:\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct mrb *qla4xxx_get_new_mrb(struct scsi_qla_host *ha)\r\n{\r\nstruct mrb *mrb;\r\nmrb = kzalloc(sizeof(*mrb), GFP_KERNEL);\r\nif (!mrb)\r\nreturn mrb;\r\nmrb->ha = ha;\r\nreturn mrb;\r\n}\r\nstatic int qla4xxx_send_mbox_iocb(struct scsi_qla_host *ha, struct mrb *mrb,\r\nuint32_t *in_mbox)\r\n{\r\nint rval = QLA_SUCCESS;\r\nuint32_t i;\r\nunsigned long flags;\r\nuint32_t index = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nrval = qla4xxx_get_req_pkt(ha, (struct queue_entry **) &(mrb->mbox));\r\nif (rval != QLA_SUCCESS)\r\ngoto exit_mbox_iocb;\r\nindex = ha->mrb_index;\r\nfor (i = 0; i < MAX_MRB; i++) {\r\nindex++;\r\nif (index == MAX_MRB)\r\nindex = 1;\r\nif (ha->active_mrb_array[index] == NULL) {\r\nha->mrb_index = index;\r\nbreak;\r\n}\r\n}\r\nmrb->iocb_cnt = 1;\r\nha->active_mrb_array[index] = mrb;\r\nmrb->mbox->handle = index;\r\nmrb->mbox->hdr.entryType = ET_MBOX_CMD;\r\nmrb->mbox->hdr.entryCount = mrb->iocb_cnt;\r\nmemcpy(mrb->mbox->in_mbox, in_mbox, 32);\r\nmrb->mbox_cmd = in_mbox[0];\r\nwmb();\r\nha->iocb_cnt += mrb->iocb_cnt;\r\nha->isp_ops->queue_iocb(ha);\r\nexit_mbox_iocb:\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn rval;\r\n}\r\nint qla4xxx_ping_iocb(struct scsi_qla_host *ha, uint32_t options,\r\nuint32_t payload_size, uint32_t pid, uint8_t *ipaddr)\r\n{\r\nuint32_t in_mbox[8];\r\nstruct mrb *mrb = NULL;\r\nint rval = QLA_SUCCESS;\r\nmemset(in_mbox, 0, sizeof(in_mbox));\r\nmrb = qla4xxx_get_new_mrb(ha);\r\nif (!mrb) {\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: fail to get new mrb\n",\r\n__func__));\r\nrval = QLA_ERROR;\r\ngoto exit_ping;\r\n}\r\nin_mbox[0] = MBOX_CMD_PING;\r\nin_mbox[1] = options;\r\nmemcpy(&in_mbox[2], &ipaddr[0], 4);\r\nmemcpy(&in_mbox[3], &ipaddr[4], 4);\r\nmemcpy(&in_mbox[4], &ipaddr[8], 4);\r\nmemcpy(&in_mbox[5], &ipaddr[12], 4);\r\nin_mbox[6] = payload_size;\r\nmrb->pid = pid;\r\nrval = qla4xxx_send_mbox_iocb(ha, mrb, in_mbox);\r\nif (rval != QLA_SUCCESS)\r\ngoto exit_ping;\r\nreturn rval;\r\nexit_ping:\r\nkfree(mrb);\r\nreturn rval;\r\n}
