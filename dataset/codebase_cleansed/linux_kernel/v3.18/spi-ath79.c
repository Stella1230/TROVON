static inline u32 ath79_spi_rr(struct ath79_spi *sp, unsigned reg)\r\n{\r\nreturn ioread32(sp->base + reg);\r\n}\r\nstatic inline void ath79_spi_wr(struct ath79_spi *sp, unsigned reg, u32 val)\r\n{\r\niowrite32(val, sp->base + reg);\r\n}\r\nstatic inline struct ath79_spi *ath79_spidev_to_sp(struct spi_device *spi)\r\n{\r\nreturn spi_master_get_devdata(spi->master);\r\n}\r\nstatic inline void ath79_spi_delay(struct ath79_spi *sp, unsigned nsecs)\r\n{\r\nif (nsecs > sp->rrw_delay)\r\nndelay(nsecs - sp->rrw_delay);\r\n}\r\nstatic void ath79_spi_chipselect(struct spi_device *spi, int is_active)\r\n{\r\nstruct ath79_spi *sp = ath79_spidev_to_sp(spi);\r\nint cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;\r\nif (is_active) {\r\nif (spi->mode & SPI_CPOL)\r\nsp->ioc_base |= AR71XX_SPI_IOC_CLK;\r\nelse\r\nsp->ioc_base &= ~AR71XX_SPI_IOC_CLK;\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);\r\n}\r\nif (spi->chip_select) {\r\nstruct ath79_spi_controller_data *cdata = spi->controller_data;\r\ngpio_set_value(cdata->gpio, cs_high);\r\n} else {\r\nif (cs_high)\r\nsp->ioc_base |= AR71XX_SPI_IOC_CS0;\r\nelse\r\nsp->ioc_base &= ~AR71XX_SPI_IOC_CS0;\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, sp->ioc_base);\r\n}\r\n}\r\nstatic void ath79_spi_enable(struct ath79_spi *sp)\r\n{\r\nath79_spi_wr(sp, AR71XX_SPI_REG_FS, AR71XX_SPI_FS_GPIO);\r\nsp->reg_ctrl = ath79_spi_rr(sp, AR71XX_SPI_REG_CTRL);\r\nsp->ioc_base = ath79_spi_rr(sp, AR71XX_SPI_REG_IOC);\r\nath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, 0x43);\r\n}\r\nstatic void ath79_spi_disable(struct ath79_spi *sp)\r\n{\r\nath79_spi_wr(sp, AR71XX_SPI_REG_CTRL, sp->reg_ctrl);\r\nath79_spi_wr(sp, AR71XX_SPI_REG_FS, 0);\r\n}\r\nstatic int ath79_spi_setup_cs(struct spi_device *spi)\r\n{\r\nstruct ath79_spi_controller_data *cdata;\r\nint status;\r\ncdata = spi->controller_data;\r\nif (spi->chip_select && !cdata)\r\nreturn -EINVAL;\r\nstatus = 0;\r\nif (spi->chip_select) {\r\nunsigned long flags;\r\nflags = GPIOF_DIR_OUT;\r\nif (spi->mode & SPI_CS_HIGH)\r\nflags |= GPIOF_INIT_LOW;\r\nelse\r\nflags |= GPIOF_INIT_HIGH;\r\nstatus = gpio_request_one(cdata->gpio, flags,\r\ndev_name(&spi->dev));\r\n}\r\nreturn status;\r\n}\r\nstatic void ath79_spi_cleanup_cs(struct spi_device *spi)\r\n{\r\nif (spi->chip_select) {\r\nstruct ath79_spi_controller_data *cdata = spi->controller_data;\r\ngpio_free(cdata->gpio);\r\n}\r\n}\r\nstatic int ath79_spi_setup(struct spi_device *spi)\r\n{\r\nint status = 0;\r\nif (!spi->controller_state) {\r\nstatus = ath79_spi_setup_cs(spi);\r\nif (status)\r\nreturn status;\r\n}\r\nstatus = spi_bitbang_setup(spi);\r\nif (status && !spi->controller_state)\r\nath79_spi_cleanup_cs(spi);\r\nreturn status;\r\n}\r\nstatic void ath79_spi_cleanup(struct spi_device *spi)\r\n{\r\nath79_spi_cleanup_cs(spi);\r\nspi_bitbang_cleanup(spi);\r\n}\r\nstatic u32 ath79_spi_txrx_mode0(struct spi_device *spi, unsigned nsecs,\r\nu32 word, u8 bits)\r\n{\r\nstruct ath79_spi *sp = ath79_spidev_to_sp(spi);\r\nu32 ioc = sp->ioc_base;\r\nfor (word <<= (32 - bits); likely(bits); bits--) {\r\nu32 out;\r\nif (word & (1 << 31))\r\nout = ioc | AR71XX_SPI_IOC_DO;\r\nelse\r\nout = ioc & ~AR71XX_SPI_IOC_DO;\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, out);\r\nath79_spi_delay(sp, nsecs);\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, out | AR71XX_SPI_IOC_CLK);\r\nath79_spi_delay(sp, nsecs);\r\nif (bits == 1)\r\nath79_spi_wr(sp, AR71XX_SPI_REG_IOC, out);\r\nword <<= 1;\r\n}\r\nreturn ath79_spi_rr(sp, AR71XX_SPI_REG_RDS);\r\n}\r\nstatic int ath79_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct ath79_spi *sp;\r\nstruct ath79_spi_platform_data *pdata;\r\nstruct resource *r;\r\nunsigned long rate;\r\nint ret;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*sp));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate spi master\n");\r\nreturn -ENOMEM;\r\n}\r\nsp = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, sp);\r\npdata = dev_get_platdata(&pdev->dev);\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\r\nmaster->setup = ath79_spi_setup;\r\nmaster->cleanup = ath79_spi_cleanup;\r\nif (pdata) {\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->num_chipselect = pdata->num_chipselect;\r\n}\r\nsp->bitbang.master = master;\r\nsp->bitbang.chipselect = ath79_spi_chipselect;\r\nsp->bitbang.txrx_word[SPI_MODE_0] = ath79_spi_txrx_mode0;\r\nsp->bitbang.setup_transfer = spi_bitbang_setup_transfer;\r\nsp->bitbang.flags = SPI_CS_HIGH;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nret = -ENOENT;\r\ngoto err_put_master;\r\n}\r\nsp->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!sp->base) {\r\nret = -ENXIO;\r\ngoto err_put_master;\r\n}\r\nsp->clk = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(sp->clk)) {\r\nret = PTR_ERR(sp->clk);\r\ngoto err_put_master;\r\n}\r\nret = clk_enable(sp->clk);\r\nif (ret)\r\ngoto err_put_master;\r\nrate = DIV_ROUND_UP(clk_get_rate(sp->clk), MHZ);\r\nif (!rate) {\r\nret = -EINVAL;\r\ngoto err_clk_disable;\r\n}\r\nsp->rrw_delay = ATH79_SPI_RRW_DELAY_FACTOR / rate;\r\ndev_dbg(&pdev->dev, "register read/write delay is %u nsecs\n",\r\nsp->rrw_delay);\r\nath79_spi_enable(sp);\r\nret = spi_bitbang_start(&sp->bitbang);\r\nif (ret)\r\ngoto err_disable;\r\nreturn 0;\r\nerr_disable:\r\nath79_spi_disable(sp);\r\nerr_clk_disable:\r\nclk_disable(sp->clk);\r\nerr_put_master:\r\nspi_master_put(sp->bitbang.master);\r\nreturn ret;\r\n}\r\nstatic int ath79_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct ath79_spi *sp = platform_get_drvdata(pdev);\r\nspi_bitbang_stop(&sp->bitbang);\r\nath79_spi_disable(sp);\r\nclk_disable(sp->clk);\r\nspi_master_put(sp->bitbang.master);\r\nreturn 0;\r\n}\r\nstatic void ath79_spi_shutdown(struct platform_device *pdev)\r\n{\r\nath79_spi_remove(pdev);\r\n}
