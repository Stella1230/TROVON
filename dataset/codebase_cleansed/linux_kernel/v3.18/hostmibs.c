INT ProcessGetHostMibs(struct bcm_mini_adapter *Adapter,\r\nstruct bcm_host_stats_mibs *pstHostMibs)\r\n{\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_rule *pstPhsRule = NULL;\r\nstruct bcm_phs_classifier_table *pstClassifierTable = NULL;\r\nstruct bcm_phs_classifier_entry *pstClassifierRule = NULL;\r\nstruct bcm_phs_extension *pDeviceExtension = &Adapter->stBCMPhsContext;\r\nstruct bcm_mibs_host_info *host_info;\r\nUINT nClassifierIndex = 0;\r\nUINT nPhsTableIndex = 0;\r\nUINT nSfIndex = 0;\r\nUINT uiIndex = 0;\r\nif (pDeviceExtension == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, HOST_MIBS,\r\nDBG_LVL_ALL, "Invalid Device Extension\n");\r\nreturn STATUS_FAILURE;\r\n}\r\nfor (nClassifierIndex = 0; nClassifierIndex < MAX_CLASSIFIERS;\r\nnClassifierIndex++) {\r\nif (Adapter->astClassifierTable[nClassifierIndex].bUsed == TRUE)\r\nmemcpy(&pstHostMibs->astClassifierTable[nClassifierIndex],\r\n&Adapter->astClassifierTable[nClassifierIndex],\r\nsizeof(struct bcm_mibs_classifier_rule));\r\n}\r\nfor (nSfIndex = 0; nSfIndex < NO_OF_QUEUES; nSfIndex++) {\r\nif (Adapter->PackInfo[nSfIndex].bValid) {\r\nmemcpy(&pstHostMibs->astSFtable[nSfIndex],\r\n&Adapter->PackInfo[nSfIndex],\r\nsizeof(struct bcm_mibs_table));\r\n} else {\r\ncontinue;\r\n}\r\nif (PHS_INVALID_TABLE_INDEX ==\r\nGetServiceFlowEntry(pDeviceExtension->\r\npstServiceFlowPhsRulesTable,\r\nAdapter->PackInfo[nSfIndex].\r\nusVCID_Value, &pstServiceFlowEntry))\r\ncontinue;\r\npstClassifierTable = pstServiceFlowEntry->pstClassifierTable;\r\nfor (uiIndex = 0; uiIndex < MAX_PHSRULE_PER_SF; uiIndex++) {\r\npstClassifierRule = &pstClassifierTable->stActivePhsRulesList[uiIndex];\r\nif (pstClassifierRule->bUsed) {\r\npstPhsRule = pstClassifierRule->pstPhsRule;\r\npstHostMibs->astPhsRulesTable[nPhsTableIndex].\r\nulSFID = Adapter->PackInfo[nSfIndex].ulSFID;\r\nmemcpy(&pstHostMibs->astPhsRulesTable[nPhsTableIndex].u8PHSI,\r\n&pstPhsRule->u8PHSI,\r\nsizeof(struct bcm_phs_rule));\r\nnPhsTableIndex++;\r\n}\r\n}\r\n}\r\nhost_info = &pstHostMibs->stHostInfo;\r\nhost_info->GoodTransmits = Adapter->dev->stats.tx_packets;\r\nhost_info->GoodReceives = Adapter->dev->stats.rx_packets;\r\nhost_info->CurrNumFreeDesc = atomic_read(&Adapter->CurrNumFreeTxDesc);\r\nhost_info->BEBucketSize = Adapter->BEBucketSize;\r\nhost_info->rtPSBucketSize = Adapter->rtPSBucketSize;\r\nhost_info->TimerActive = Adapter->TimerActive;\r\nhost_info->u32TotalDSD = Adapter->u32TotalDSD;\r\nmemcpy(host_info->aTxPktSizeHist, Adapter->aTxPktSizeHist,\r\nsizeof(UINT32) * MIBS_MAX_HIST_ENTRIES);\r\nmemcpy(host_info->aRxPktSizeHist, Adapter->aRxPktSizeHist,\r\nsizeof(UINT32) * MIBS_MAX_HIST_ENTRIES);\r\nreturn STATUS_SUCCESS;\r\n}\r\nVOID GetDroppedAppCntrlPktMibs(struct bcm_host_stats_mibs *pstHostMibs,\r\nstruct bcm_tarang_data *pTarang)\r\n{\r\nmemcpy(&(pstHostMibs->stDroppedAppCntrlMsgs),\r\n&(pTarang->stDroppedAppCntrlMsgs),\r\nsizeof(struct bcm_mibs_dropped_cntrl_msg));\r\n}\r\nVOID CopyMIBSExtendedSFParameters(struct bcm_mini_adapter *Adapter,\r\nstruct bcm_connect_mgr_params *psfLocalSet,\r\nUINT uiSearchRuleIndex)\r\n{\r\nstruct bcm_mibs_parameters *t =\r\n&Adapter->PackInfo[uiSearchRuleIndex].stMibsExtServiceFlowTable;\r\nt->wmanIfSfid = psfLocalSet->u32SFID;\r\nt->wmanIfCmnCpsMaxSustainedRate =\r\npsfLocalSet->u32MaxSustainedTrafficRate;\r\nt->wmanIfCmnCpsMaxTrafficBurst = psfLocalSet->u32MaxTrafficBurst;\r\nt->wmanIfCmnCpsMinReservedRate = psfLocalSet->u32MinReservedTrafficRate;\r\nt->wmanIfCmnCpsToleratedJitter = psfLocalSet->u32ToleratedJitter;\r\nt->wmanIfCmnCpsMaxLatency = psfLocalSet->u32MaximumLatency;\r\nt->wmanIfCmnCpsFixedVsVariableSduInd =\r\npsfLocalSet->u8FixedLengthVSVariableLengthSDUIndicator;\r\nt->wmanIfCmnCpsFixedVsVariableSduInd =\r\nntohl(t->wmanIfCmnCpsFixedVsVariableSduInd);\r\nt->wmanIfCmnCpsSduSize = psfLocalSet->u8SDUSize;\r\nt->wmanIfCmnCpsSduSize = ntohl(t->wmanIfCmnCpsSduSize);\r\nt->wmanIfCmnCpsSfSchedulingType =\r\npsfLocalSet->u8ServiceFlowSchedulingType;\r\nt->wmanIfCmnCpsSfSchedulingType =\r\nntohl(t->wmanIfCmnCpsSfSchedulingType);\r\nt->wmanIfCmnCpsArqEnable = psfLocalSet->u8ARQEnable;\r\nt->wmanIfCmnCpsArqEnable = ntohl(t->wmanIfCmnCpsArqEnable);\r\nt->wmanIfCmnCpsArqWindowSize = ntohs(psfLocalSet->u16ARQWindowSize);\r\nt->wmanIfCmnCpsArqWindowSize = ntohl(t->wmanIfCmnCpsArqWindowSize);\r\nt->wmanIfCmnCpsArqBlockLifetime =\r\nntohs(psfLocalSet->u16ARQBlockLifeTime);\r\nt->wmanIfCmnCpsArqBlockLifetime =\r\nntohl(t->wmanIfCmnCpsArqBlockLifetime);\r\nt->wmanIfCmnCpsArqSyncLossTimeout =\r\nntohs(psfLocalSet->u16ARQSyncLossTimeOut);\r\nt->wmanIfCmnCpsArqSyncLossTimeout =\r\nntohl(t->wmanIfCmnCpsArqSyncLossTimeout);\r\nt->wmanIfCmnCpsArqDeliverInOrder = psfLocalSet->u8ARQDeliverInOrder;\r\nt->wmanIfCmnCpsArqDeliverInOrder =\r\nntohl(t->wmanIfCmnCpsArqDeliverInOrder);\r\nt->wmanIfCmnCpsArqRxPurgeTimeout =\r\nntohs(psfLocalSet->u16ARQRxPurgeTimeOut);\r\nt->wmanIfCmnCpsArqRxPurgeTimeout =\r\nntohl(t->wmanIfCmnCpsArqRxPurgeTimeout);\r\nt->wmanIfCmnCpsArqBlockSize = ntohs(psfLocalSet->u16ARQBlockSize);\r\nt->wmanIfCmnCpsArqBlockSize = ntohl(t->wmanIfCmnCpsArqBlockSize);\r\nt->wmanIfCmnCpsReqTxPolicy = psfLocalSet->u8RequesttransmissionPolicy;\r\nt->wmanIfCmnCpsReqTxPolicy = ntohl(t->wmanIfCmnCpsReqTxPolicy);\r\nt->wmanIfCmnSfCsSpecification = psfLocalSet->u8CSSpecification;\r\nt->wmanIfCmnSfCsSpecification = ntohl(t->wmanIfCmnSfCsSpecification);\r\nt->wmanIfCmnCpsTargetSaid = ntohs(psfLocalSet->u16TargetSAID);\r\nt->wmanIfCmnCpsTargetSaid = ntohl(t->wmanIfCmnCpsTargetSaid);\r\n}
