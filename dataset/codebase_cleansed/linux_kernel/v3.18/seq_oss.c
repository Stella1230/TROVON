static inline int register_proc(void) { return 0; }\r\nstatic inline void unregister_proc(void) {}\r\nstatic int __init alsa_seq_oss_init(void)\r\n{\r\nint rc;\r\nstatic struct snd_seq_dev_ops ops = {\r\nsnd_seq_oss_synth_register,\r\nsnd_seq_oss_synth_unregister,\r\n};\r\nsnd_seq_autoload_lock();\r\nif ((rc = register_device()) < 0)\r\ngoto error;\r\nif ((rc = register_proc()) < 0) {\r\nunregister_device();\r\ngoto error;\r\n}\r\nif ((rc = snd_seq_oss_create_client()) < 0) {\r\nunregister_proc();\r\nunregister_device();\r\ngoto error;\r\n}\r\nif ((rc = snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OSS, &ops,\r\nsizeof(struct snd_seq_oss_reg))) < 0) {\r\nsnd_seq_oss_delete_client();\r\nunregister_proc();\r\nunregister_device();\r\ngoto error;\r\n}\r\nsnd_seq_oss_synth_init();\r\nerror:\r\nsnd_seq_autoload_unlock();\r\nreturn rc;\r\n}\r\nstatic void __exit alsa_seq_oss_exit(void)\r\n{\r\nsnd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_OSS);\r\nsnd_seq_oss_delete_client();\r\nunregister_proc();\r\nunregister_device();\r\n}\r\nstatic int\r\nodev_open(struct inode *inode, struct file *file)\r\n{\r\nint level, rc;\r\nif (iminor(inode) == SNDRV_MINOR_OSS_MUSIC)\r\nlevel = SNDRV_SEQ_OSS_MODE_MUSIC;\r\nelse\r\nlevel = SNDRV_SEQ_OSS_MODE_SYNTH;\r\nmutex_lock(&register_mutex);\r\nrc = snd_seq_oss_open(file, level);\r\nmutex_unlock(&register_mutex);\r\nreturn rc;\r\n}\r\nstatic int\r\nodev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_oss_devinfo *dp;\r\nif ((dp = file->private_data) == NULL)\r\nreturn 0;\r\nsnd_seq_oss_drain_write(dp);\r\nmutex_lock(&register_mutex);\r\nsnd_seq_oss_release(dp);\r\nmutex_unlock(&register_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nodev_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct seq_oss_devinfo *dp;\r\ndp = file->private_data;\r\nif (snd_BUG_ON(!dp))\r\nreturn -ENXIO;\r\nreturn snd_seq_oss_read(dp, buf, count);\r\n}\r\nstatic ssize_t\r\nodev_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\r\n{\r\nstruct seq_oss_devinfo *dp;\r\ndp = file->private_data;\r\nif (snd_BUG_ON(!dp))\r\nreturn -ENXIO;\r\nreturn snd_seq_oss_write(dp, buf, count, file);\r\n}\r\nstatic long\r\nodev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct seq_oss_devinfo *dp;\r\ndp = file->private_data;\r\nif (snd_BUG_ON(!dp))\r\nreturn -ENXIO;\r\nreturn snd_seq_oss_ioctl(dp, cmd, arg);\r\n}\r\nstatic unsigned int\r\nodev_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct seq_oss_devinfo *dp;\r\ndp = file->private_data;\r\nif (snd_BUG_ON(!dp))\r\nreturn -ENXIO;\r\nreturn snd_seq_oss_poll(dp, file, wait);\r\n}\r\nstatic int __init\r\nregister_device(void)\r\n{\r\nint rc;\r\nmutex_lock(&register_mutex);\r\nif ((rc = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_SEQUENCER,\r\nNULL, 0,\r\n&seq_oss_f_ops, NULL)) < 0) {\r\npr_err("ALSA: seq_oss: can't register device seq\n");\r\nmutex_unlock(&register_mutex);\r\nreturn rc;\r\n}\r\nif ((rc = snd_register_oss_device(SNDRV_OSS_DEVICE_TYPE_MUSIC,\r\nNULL, 0,\r\n&seq_oss_f_ops, NULL)) < 0) {\r\npr_err("ALSA: seq_oss: can't register device music\n");\r\nsnd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_SEQUENCER, NULL, 0);\r\nmutex_unlock(&register_mutex);\r\nreturn rc;\r\n}\r\nmutex_unlock(&register_mutex);\r\nreturn 0;\r\n}\r\nstatic void\r\nunregister_device(void)\r\n{\r\nmutex_lock(&register_mutex);\r\nif (snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_MUSIC, NULL, 0) < 0)\r\npr_err("ALSA: seq_oss: error unregister device music\n");\r\nif (snd_unregister_oss_device(SNDRV_OSS_DEVICE_TYPE_SEQUENCER, NULL, 0) < 0)\r\npr_err("ALSA: seq_oss: error unregister device seq\n");\r\nmutex_unlock(&register_mutex);\r\n}\r\nstatic void\r\ninfo_read(struct snd_info_entry *entry, struct snd_info_buffer *buf)\r\n{\r\nmutex_lock(&register_mutex);\r\nsnd_iprintf(buf, "OSS sequencer emulation version %s\n", SNDRV_SEQ_OSS_VERSION_STR);\r\nsnd_seq_oss_system_info_read(buf);\r\nsnd_seq_oss_synth_info_read(buf);\r\nsnd_seq_oss_midi_info_read(buf);\r\nmutex_unlock(&register_mutex);\r\n}\r\nstatic int __init\r\nregister_proc(void)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = snd_info_create_module_entry(THIS_MODULE, SNDRV_SEQ_OSS_PROCNAME, snd_seq_root);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = NULL;\r\nentry->c.text.read = info_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nreturn -ENOMEM;\r\n}\r\ninfo_entry = entry;\r\nreturn 0;\r\n}\r\nstatic void\r\nunregister_proc(void)\r\n{\r\nsnd_info_free_entry(info_entry);\r\ninfo_entry = NULL;\r\n}
