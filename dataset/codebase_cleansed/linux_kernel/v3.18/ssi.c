static int rsnd_ssi_use_busif(struct rsnd_mod *mod)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nint use_busif = 0;\r\nif (!(rsnd_ssi_mode_flags(ssi) & RSND_SSI_NO_BUSIF))\r\nuse_busif = 1;\r\nif (rsnd_io_to_mod_src(io))\r\nuse_busif = 1;\r\nreturn use_busif;\r\n}\r\nstatic void rsnd_ssi_status_check(struct rsnd_mod *mod,\r\nu32 bit)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nu32 status;\r\nint i;\r\nfor (i = 0; i < 1024; i++) {\r\nstatus = rsnd_mod_read(mod, SSISR);\r\nif (status & bit)\r\nreturn;\r\nudelay(50);\r\n}\r\ndev_warn(dev, "status check failed\n");\r\n}\r\nstatic int rsnd_ssi_master_clk_start(struct rsnd_ssi *ssi,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(&ssi->mod);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nint i, j, ret;\r\nint adg_clk_div_table[] = {\r\n1, 6,\r\n};\r\nint ssi_clk_mul_table[] = {\r\n1, 2, 4, 8, 16, 6, 12,\r\n};\r\nunsigned int main_rate;\r\nunsigned int rate = rsnd_src_get_ssi_rate(priv, io, runtime);\r\nfor (i = 0; i < ARRAY_SIZE(adg_clk_div_table); i++) {\r\nfor (j = 0; j < ARRAY_SIZE(ssi_clk_mul_table); j++) {\r\nmain_rate = rate / adg_clk_div_table[i]\r\n* 32 * 2 * ssi_clk_mul_table[j];\r\nret = rsnd_adg_ssi_clk_try_start(&ssi->mod, main_rate);\r\nif (0 == ret) {\r\nssi->rate = rate;\r\nssi->cr_clk = FORCE | SWL_32 |\r\nSCKD | SWSD | CKDV(j);\r\ndev_dbg(dev, "ssi%d outputs %u Hz\n",\r\nrsnd_mod_id(&ssi->mod), rate);\r\nreturn 0;\r\n}\r\n}\r\n}\r\ndev_err(dev, "unsupported clock rate\n");\r\nreturn -EIO;\r\n}\r\nstatic void rsnd_ssi_master_clk_stop(struct rsnd_ssi *ssi)\r\n{\r\nssi->rate = 0;\r\nssi->cr_clk = 0;\r\nrsnd_adg_ssi_clk_stop(&ssi->mod);\r\n}\r\nstatic void rsnd_ssi_hw_start(struct rsnd_ssi *ssi,\r\nstruct rsnd_dai *rdai,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(&ssi->mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nu32 cr;\r\nif (0 == ssi->usrcnt) {\r\nclk_prepare_enable(ssi->clk);\r\nif (rsnd_dai_is_clk_master(rdai)) {\r\nif (rsnd_ssi_clk_from_parent(ssi))\r\nrsnd_ssi_hw_start(ssi->parent, rdai, io);\r\nelse\r\nrsnd_ssi_master_clk_start(ssi, io);\r\n}\r\n}\r\ncr = ssi->cr_own |\r\nssi->cr_clk |\r\nssi->cr_etc |\r\nEN;\r\nrsnd_mod_write(&ssi->mod, SSICR, cr);\r\nssi->usrcnt++;\r\ndev_dbg(dev, "ssi%d hw started\n", rsnd_mod_id(&ssi->mod));\r\n}\r\nstatic void rsnd_ssi_hw_stop(struct rsnd_ssi *ssi,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(&ssi->mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nu32 cr;\r\nif (0 == ssi->usrcnt)\r\nreturn;\r\nssi->usrcnt--;\r\nif (0 == ssi->usrcnt) {\r\ncr = ssi->cr_own |\r\nssi->cr_clk;\r\nrsnd_mod_write(&ssi->mod, SSICR, cr | EN);\r\nrsnd_ssi_status_check(&ssi->mod, DIRQ);\r\nrsnd_mod_write(&ssi->mod, SSICR, cr);\r\nrsnd_ssi_status_check(&ssi->mod, IIRQ);\r\nif (rsnd_dai_is_clk_master(rdai)) {\r\nif (rsnd_ssi_clk_from_parent(ssi))\r\nrsnd_ssi_hw_stop(ssi->parent, rdai);\r\nelse\r\nrsnd_ssi_master_clk_stop(ssi);\r\n}\r\nclk_disable_unprepare(ssi->clk);\r\n}\r\ndev_dbg(dev, "ssi%d hw stopped\n", rsnd_mod_id(&ssi->mod));\r\n}\r\nstatic int rsnd_ssi_init(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nu32 cr;\r\ncr = FORCE;\r\ncr |= SWL_32;\r\nswitch (runtime->sample_bits) {\r\ncase 16:\r\ncr |= DWL_16;\r\nbreak;\r\ncase 32:\r\ncr |= DWL_24;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nif (rdai->bit_clk_inv)\r\ncr |= SCKP;\r\nif (rdai->frm_clk_inv)\r\ncr |= SWSP;\r\nif (rdai->data_alignment)\r\ncr |= SDTA;\r\nif (rdai->sys_delay)\r\ncr |= DEL;\r\nif (rsnd_dai_is_play(rdai, io))\r\ncr |= TRMD;\r\nssi->rdai = rdai;\r\nssi->cr_own = cr;\r\nssi->err = -1;\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_quit(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nif (ssi->err > 0)\r\ndev_warn(dev, "ssi under/over flow err = %d\n", ssi->err);\r\nssi->rdai = NULL;\r\nssi->cr_own = 0;\r\nssi->err = 0;\r\nreturn 0;\r\n}\r\nstatic void rsnd_ssi_record_error(struct rsnd_ssi *ssi, u32 status)\r\n{\r\nif (status & (UIRQ | OIRQ)) {\r\nssi->err++;\r\nrsnd_mod_write(&ssi->mod, SSISR, 0);\r\n}\r\n}\r\nstatic irqreturn_t rsnd_ssi_pio_interrupt(int irq, void *data)\r\n{\r\nstruct rsnd_ssi *ssi = data;\r\nstruct rsnd_mod *mod = &ssi->mod;\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nu32 status = rsnd_mod_read(mod, SSISR);\r\nirqreturn_t ret = IRQ_NONE;\r\nif (io && (status & DIRQ)) {\r\nstruct rsnd_dai *rdai = ssi->rdai;\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nu32 *buf = (u32 *)(runtime->dma_area +\r\nrsnd_dai_pointer_offset(io, 0));\r\nrsnd_ssi_record_error(ssi, status);\r\nif (rsnd_dai_is_play(rdai, io))\r\nrsnd_mod_write(mod, SSITDR, *buf);\r\nelse\r\n*buf = rsnd_mod_read(mod, SSIRDR);\r\nrsnd_dai_pointer_update(io, sizeof(*buf));\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rsnd_ssi_pio_probe(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nint irq = ssi->info->pio_irq;\r\nint ret;\r\nret = devm_request_irq(dev, irq,\r\nrsnd_ssi_pio_interrupt,\r\nIRQF_SHARED,\r\ndev_name(dev), ssi);\r\nif (ret)\r\ndev_err(dev, "SSI request interrupt failed\n");\r\ndev_dbg(dev, "%s (PIO) is probed\n", rsnd_mod_name(mod));\r\nreturn ret;\r\n}\r\nstatic int rsnd_ssi_pio_start(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nssi->cr_etc = UIEN | OIEN | DIEN;\r\nrsnd_src_ssiu_start(mod, rdai, 0);\r\nrsnd_src_enable_ssi_irq(mod, rdai);\r\nrsnd_ssi_hw_start(ssi, rdai, io);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_pio_stop(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nssi->cr_etc = 0;\r\nrsnd_ssi_hw_stop(ssi, rdai);\r\nrsnd_src_ssiu_stop(mod, rdai, 0);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_dma_probe(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nint dma_id = ssi->info->dma_id;\r\nint ret;\r\nret = rsnd_dma_init(\r\npriv, rsnd_mod_to_dma(mod),\r\nrsnd_info_is_playback(priv, ssi),\r\ndma_id);\r\nif (ret < 0)\r\ndev_err(dev, "SSI DMA failed\n");\r\ndev_dbg(dev, "%s (DMA) is probed\n", rsnd_mod_name(mod));\r\nreturn ret;\r\n}\r\nstatic int rsnd_ssi_dma_remove(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nrsnd_dma_quit(rsnd_mod_to_priv(mod), rsnd_mod_to_dma(mod));\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_dma_start(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct rsnd_dma *dma = rsnd_mod_to_dma(&ssi->mod);\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nssi->cr_etc = DMEN;\r\nrsnd_src_ssiu_start(mod, rdai, rsnd_ssi_use_busif(mod));\r\nrsnd_dma_start(dma);\r\nrsnd_ssi_hw_start(ssi, ssi->rdai, io);\r\nif (rsnd_dai_is_clk_master(rdai))\r\nrsnd_mod_write(&ssi->mod, SSIWSR, CONT);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_dma_stop(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct rsnd_dma *dma = rsnd_mod_to_dma(&ssi->mod);\r\nssi->cr_etc = 0;\r\nrsnd_ssi_record_error(ssi, rsnd_mod_read(mod, SSISR));\r\nrsnd_ssi_hw_stop(ssi, rdai);\r\nrsnd_dma_stop(dma);\r\nrsnd_src_ssiu_stop(mod, rdai, 1);\r\nreturn 0;\r\n}\r\nstatic char *rsnd_ssi_dma_name(struct rsnd_mod *mod)\r\n{\r\nreturn rsnd_ssi_use_busif(mod) ? "ssiu" : SSI_NAME;\r\n}\r\nstruct rsnd_mod *rsnd_ssi_mod_get(struct rsnd_priv *priv, int id)\r\n{\r\nif (WARN_ON(id < 0 || id >= rsnd_ssi_nr(priv)))\r\nid = 0;\r\nreturn &((struct rsnd_ssi *)(priv->ssi) + id)->mod;\r\n}\r\nint rsnd_ssi_is_pin_sharing(struct rsnd_mod *mod)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nreturn !!(rsnd_ssi_mode_flags(ssi) & RSND_SSI_CLK_PIN_SHARE);\r\n}\r\nstatic void rsnd_ssi_parent_clk_setup(struct rsnd_priv *priv, struct rsnd_ssi *ssi)\r\n{\r\nif (!rsnd_ssi_is_pin_sharing(&ssi->mod))\r\nreturn;\r\nswitch (rsnd_mod_id(&ssi->mod)) {\r\ncase 1:\r\ncase 2:\r\nssi->parent = rsnd_mod_to_ssi(rsnd_ssi_mod_get(priv, 0));\r\nbreak;\r\ncase 4:\r\nssi->parent = rsnd_mod_to_ssi(rsnd_ssi_mod_get(priv, 3));\r\nbreak;\r\ncase 8:\r\nssi->parent = rsnd_mod_to_ssi(rsnd_ssi_mod_get(priv, 7));\r\nbreak;\r\n}\r\n}\r\nstatic void rsnd_of_parse_ssi(struct platform_device *pdev,\r\nconst struct rsnd_of_data *of_data,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct device_node *node;\r\nstruct device_node *np;\r\nstruct rsnd_ssi_platform_info *ssi_info;\r\nstruct rcar_snd_info *info = rsnd_priv_to_info(priv);\r\nstruct device *dev = &pdev->dev;\r\nint nr, i;\r\nif (!of_data)\r\nreturn;\r\nnode = of_get_child_by_name(dev->of_node, "rcar_sound,ssi");\r\nif (!node)\r\nreturn;\r\nnr = of_get_child_count(node);\r\nif (!nr)\r\ngoto rsnd_of_parse_ssi_end;\r\nssi_info = devm_kzalloc(dev,\r\nsizeof(struct rsnd_ssi_platform_info) * nr,\r\nGFP_KERNEL);\r\nif (!ssi_info) {\r\ndev_err(dev, "ssi info allocation error\n");\r\ngoto rsnd_of_parse_ssi_end;\r\n}\r\ninfo->ssi_info = ssi_info;\r\ninfo->ssi_info_nr = nr;\r\ni = -1;\r\nfor_each_child_of_node(node, np) {\r\ni++;\r\nssi_info = info->ssi_info + i;\r\nif (of_get_property(np, "shared-pin", NULL))\r\nssi_info->flags |= RSND_SSI_CLK_PIN_SHARE;\r\nssi_info->pio_irq = irq_of_parse_and_map(np, 0);\r\nssi_info->dma_id = of_get_property(np, "pio-transfer", NULL) ?\r\n0 : 1;\r\nif (of_get_property(np, "no-busif", NULL))\r\nssi_info->flags |= RSND_SSI_NO_BUSIF;\r\n}\r\nrsnd_of_parse_ssi_end:\r\nof_node_put(node);\r\n}\r\nint rsnd_ssi_probe(struct platform_device *pdev,\r\nconst struct rsnd_of_data *of_data,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rcar_snd_info *info = rsnd_priv_to_info(priv);\r\nstruct rsnd_ssi_platform_info *pinfo;\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_mod_ops *ops;\r\nstruct clk *clk;\r\nstruct rsnd_ssi *ssi;\r\nchar name[RSND_SSI_NAME_SIZE];\r\nint i, nr;\r\nrsnd_of_parse_ssi(pdev, of_data, priv);\r\nnr = info->ssi_info_nr;\r\nssi = devm_kzalloc(dev, sizeof(*ssi) * nr, GFP_KERNEL);\r\nif (!ssi) {\r\ndev_err(dev, "SSI allocate failed\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->ssi = ssi;\r\npriv->ssi_nr = nr;\r\nfor_each_rsnd_ssi(ssi, priv, i) {\r\npinfo = &info->ssi_info[i];\r\nsnprintf(name, RSND_SSI_NAME_SIZE, "%s.%d",\r\nSSI_NAME, i);\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nssi->info = pinfo;\r\nssi->clk = clk;\r\nops = &rsnd_ssi_non_ops;\r\nif (pinfo->dma_id > 0)\r\nops = &rsnd_ssi_dma_ops;\r\nelse if (rsnd_ssi_pio_available(ssi))\r\nops = &rsnd_ssi_pio_ops;\r\nrsnd_mod_init(priv, &ssi->mod, ops, RSND_MOD_SSI, i);\r\nrsnd_ssi_parent_clk_setup(priv, ssi);\r\n}\r\nreturn 0;\r\n}
