static int lenovo_input_mapping_tpkbd(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nif (usage->hid == (HID_UP_BUTTON | 0x0010)) {\r\nhid_set_drvdata(hdev, (void *)1);\r\nmap_key_clear(KEY_MICMUTE);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lenovo_input_mapping_cptkbd(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nif ((usage->hid & HID_USAGE_PAGE) == HID_UP_MSVENDOR ||\r\n(usage->hid & HID_USAGE_PAGE) == HID_UP_LNVENDOR) {\r\nset_bit(EV_REP, hi->input->evbit);\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x00f1:\r\nmap_key_clear(KEY_MICMUTE);\r\nreturn 1;\r\ncase 0x00f2:\r\nmap_key_clear(KEY_BRIGHTNESSDOWN);\r\nreturn 1;\r\ncase 0x00f3:\r\nmap_key_clear(KEY_BRIGHTNESSUP);\r\nreturn 1;\r\ncase 0x00f4:\r\nmap_key_clear(KEY_SWITCHVIDEOMODE);\r\nreturn 1;\r\ncase 0x00f5:\r\nmap_key_clear(KEY_WLAN);\r\nreturn 1;\r\ncase 0x00f6:\r\nmap_key_clear(KEY_CONFIG);\r\nreturn 1;\r\ncase 0x00f8:\r\nmap_key_clear(KEY_SCALE);\r\nreturn 1;\r\ncase 0x00fa:\r\nmap_key_clear(KEY_FN_ESC);\r\nreturn 1;\r\ncase 0x00fb:\r\nmap_key_clear(KEY_FILE);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lenovo_input_mapping(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_LENOVO_TPKBD:\r\nreturn lenovo_input_mapping_tpkbd(hdev, hi, field,\r\nusage, bit, max);\r\ncase USB_DEVICE_ID_LENOVO_CUSBKBD:\r\ncase USB_DEVICE_ID_LENOVO_CBTKBD:\r\nreturn lenovo_input_mapping_cptkbd(hdev, hi, field,\r\nusage, bit, max);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int lenovo_send_cmd_cptkbd(struct hid_device *hdev,\r\nunsigned char byte2, unsigned char byte3)\r\n{\r\nint ret;\r\nunsigned char buf[] = {0x18, byte2, byte3};\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_LENOVO_CUSBKBD:\r\nret = hid_hw_raw_request(hdev, 0x13, buf, sizeof(buf),\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nbreak;\r\ncase USB_DEVICE_ID_LENOVO_CBTKBD:\r\nret = hid_hw_output_report(hdev, buf, sizeof(buf));\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic void lenovo_features_set_cptkbd(struct hid_device *hdev)\r\n{\r\nint ret;\r\nstruct lenovo_drvdata_cptkbd *cptkbd_data = hid_get_drvdata(hdev);\r\nret = lenovo_send_cmd_cptkbd(hdev, 0x05, cptkbd_data->fn_lock);\r\nif (ret)\r\nhid_err(hdev, "Fn-lock setting failed: %d\n", ret);\r\n}\r\nstatic ssize_t attr_fn_lock_show_cptkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_cptkbd *cptkbd_data = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", cptkbd_data->fn_lock);\r\n}\r\nstatic ssize_t attr_fn_lock_store_cptkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_cptkbd *cptkbd_data = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ncptkbd_data->fn_lock = !!value;\r\nlenovo_features_set_cptkbd(hdev);\r\nreturn count;\r\n}\r\nstatic int lenovo_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data, int size)\r\n{\r\nif (unlikely(hdev->product == USB_DEVICE_ID_LENOVO_CUSBKBD\r\n&& size == 3\r\n&& data[0] == 0x15\r\n&& data[1] == 0x94\r\n&& data[2] == 0x01)) {\r\ndata[1] = 0x0;\r\ndata[2] = 0x4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lenovo_features_set_tpkbd(struct hid_device *hdev)\r\n{\r\nstruct hid_report *report;\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nreport = hdev->report_enum[HID_FEATURE_REPORT].report_id_hash[4];\r\nreport->field[0]->value[0] = data_pointer->press_to_select ? 0x01 : 0x02;\r\nreport->field[0]->value[0] |= data_pointer->dragging ? 0x04 : 0x08;\r\nreport->field[0]->value[0] |= data_pointer->release_to_select ? 0x10 : 0x20;\r\nreport->field[0]->value[0] |= data_pointer->select_right ? 0x80 : 0x40;\r\nreport->field[1]->value[0] = 0x03;\r\nreport->field[2]->value[0] = data_pointer->sensitivity;\r\nreport->field[3]->value[0] = data_pointer->press_speed;\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\nreturn 0;\r\n}\r\nstatic ssize_t attr_press_to_select_show_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", data_pointer->press_to_select);\r\n}\r\nstatic ssize_t attr_press_to_select_store_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ndata_pointer->press_to_select = value;\r\nlenovo_features_set_tpkbd(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t attr_dragging_show_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", data_pointer->dragging);\r\n}\r\nstatic ssize_t attr_dragging_store_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ndata_pointer->dragging = value;\r\nlenovo_features_set_tpkbd(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t attr_release_to_select_show_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", data_pointer->release_to_select);\r\n}\r\nstatic ssize_t attr_release_to_select_store_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ndata_pointer->release_to_select = value;\r\nlenovo_features_set_tpkbd(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t attr_select_right_show_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", data_pointer->select_right);\r\n}\r\nstatic ssize_t attr_select_right_store_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value))\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\ndata_pointer->select_right = value;\r\nlenovo_features_set_tpkbd(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t attr_sensitivity_show_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\ndata_pointer->sensitivity);\r\n}\r\nstatic ssize_t attr_sensitivity_store_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value) || value < 1 || value > 255)\r\nreturn -EINVAL;\r\ndata_pointer->sensitivity = value;\r\nlenovo_features_set_tpkbd(hdev);\r\nreturn count;\r\n}\r\nstatic ssize_t attr_press_speed_show_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\ndata_pointer->press_speed);\r\n}\r\nstatic ssize_t attr_press_speed_store_tpkbd(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nint value;\r\nif (kstrtoint(buf, 10, &value) || value < 1 || value > 255)\r\nreturn -EINVAL;\r\ndata_pointer->press_speed = value;\r\nlenovo_features_set_tpkbd(hdev);\r\nreturn count;\r\n}\r\nstatic enum led_brightness lenovo_led_brightness_get_tpkbd(\r\nstruct led_classdev *led_cdev)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nint led_nr = 0;\r\nif (led_cdev == &data_pointer->led_micmute)\r\nled_nr = 1;\r\nreturn data_pointer->led_state & (1 << led_nr)\r\n? LED_FULL\r\n: LED_OFF;\r\n}\r\nstatic void lenovo_led_brightness_set_tpkbd(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nstruct hid_report *report;\r\nint led_nr = 0;\r\nif (led_cdev == &data_pointer->led_micmute)\r\nled_nr = 1;\r\nif (value == LED_OFF)\r\ndata_pointer->led_state &= ~(1 << led_nr);\r\nelse\r\ndata_pointer->led_state |= 1 << led_nr;\r\nreport = hdev->report_enum[HID_OUTPUT_REPORT].report_id_hash[3];\r\nreport->field[0]->value[0] = (data_pointer->led_state >> 0) & 1;\r\nreport->field[0]->value[1] = (data_pointer->led_state >> 1) & 1;\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic int lenovo_probe_tpkbd(struct hid_device *hdev)\r\n{\r\nstruct device *dev = &hdev->dev;\r\nstruct lenovo_drvdata_tpkbd *data_pointer;\r\nsize_t name_sz = strlen(dev_name(dev)) + 16;\r\nchar *name_mute, *name_micmute;\r\nint i;\r\nint ret;\r\nif (!hid_get_drvdata(hdev))\r\nreturn 0;\r\nhid_set_drvdata(hdev, NULL);\r\nfor (i = 0; i < 4; i++) {\r\nif (!hid_validate_values(hdev, HID_FEATURE_REPORT, 4, i, 1))\r\nreturn -ENODEV;\r\n}\r\nif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 3, 0, 2))\r\nreturn -ENODEV;\r\nret = sysfs_create_group(&hdev->dev.kobj, &lenovo_attr_group_tpkbd);\r\nif (ret)\r\nhid_warn(hdev, "Could not create sysfs group: %d\n", ret);\r\ndata_pointer = devm_kzalloc(&hdev->dev,\r\nsizeof(struct lenovo_drvdata_tpkbd),\r\nGFP_KERNEL);\r\nif (data_pointer == NULL) {\r\nhid_err(hdev, "Could not allocate memory for driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ndata_pointer->sensitivity = 0xa0;\r\ndata_pointer->press_speed = 0x38;\r\nname_mute = devm_kzalloc(&hdev->dev, name_sz, GFP_KERNEL);\r\nname_micmute = devm_kzalloc(&hdev->dev, name_sz, GFP_KERNEL);\r\nif (name_mute == NULL || name_micmute == NULL) {\r\nhid_err(hdev, "Could not allocate memory for led data\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(name_mute, name_sz, "%s:amber:mute", dev_name(dev));\r\nsnprintf(name_micmute, name_sz, "%s:amber:micmute", dev_name(dev));\r\nhid_set_drvdata(hdev, data_pointer);\r\ndata_pointer->led_mute.name = name_mute;\r\ndata_pointer->led_mute.brightness_get = lenovo_led_brightness_get_tpkbd;\r\ndata_pointer->led_mute.brightness_set = lenovo_led_brightness_set_tpkbd;\r\ndata_pointer->led_mute.dev = dev;\r\nled_classdev_register(dev, &data_pointer->led_mute);\r\ndata_pointer->led_micmute.name = name_micmute;\r\ndata_pointer->led_micmute.brightness_get =\r\nlenovo_led_brightness_get_tpkbd;\r\ndata_pointer->led_micmute.brightness_set =\r\nlenovo_led_brightness_set_tpkbd;\r\ndata_pointer->led_micmute.dev = dev;\r\nled_classdev_register(dev, &data_pointer->led_micmute);\r\nlenovo_features_set_tpkbd(hdev);\r\nreturn 0;\r\n}\r\nstatic int lenovo_probe_cptkbd(struct hid_device *hdev)\r\n{\r\nint ret;\r\nstruct lenovo_drvdata_cptkbd *cptkbd_data;\r\nif (hdev->product == USB_DEVICE_ID_LENOVO_CUSBKBD\r\n&& hdev->type != HID_TYPE_USBMOUSE) {\r\nhid_dbg(hdev, "Ignoring keyboard half of device\n");\r\nreturn 0;\r\n}\r\ncptkbd_data = devm_kzalloc(&hdev->dev,\r\nsizeof(*cptkbd_data),\r\nGFP_KERNEL);\r\nif (cptkbd_data == NULL) {\r\nhid_err(hdev, "can't alloc keyboard descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, cptkbd_data);\r\nret = lenovo_send_cmd_cptkbd(hdev, 0x01, 0x03);\r\nif (ret)\r\nhid_warn(hdev, "Failed to switch F7/9/11 mode: %d\n", ret);\r\ncptkbd_data->fn_lock = true;\r\nlenovo_features_set_cptkbd(hdev);\r\nret = sysfs_create_group(&hdev->dev.kobj, &lenovo_attr_group_cptkbd);\r\nif (ret)\r\nhid_warn(hdev, "Could not create sysfs group: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int lenovo_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint ret;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "hid_parse failed\n");\r\ngoto err;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hid_hw_start failed\n");\r\ngoto err;\r\n}\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_LENOVO_TPKBD:\r\nret = lenovo_probe_tpkbd(hdev);\r\nbreak;\r\ncase USB_DEVICE_ID_LENOVO_CUSBKBD:\r\ncase USB_DEVICE_ID_LENOVO_CBTKBD:\r\nret = lenovo_probe_cptkbd(hdev);\r\nbreak;\r\ndefault:\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret)\r\ngoto err_hid;\r\nreturn 0;\r\nerr_hid:\r\nhid_hw_stop(hdev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void lenovo_remove_tpkbd(struct hid_device *hdev)\r\n{\r\nstruct lenovo_drvdata_tpkbd *data_pointer = hid_get_drvdata(hdev);\r\nif (data_pointer == NULL)\r\nreturn;\r\nsysfs_remove_group(&hdev->dev.kobj,\r\n&lenovo_attr_group_tpkbd);\r\nled_classdev_unregister(&data_pointer->led_micmute);\r\nled_classdev_unregister(&data_pointer->led_mute);\r\nhid_set_drvdata(hdev, NULL);\r\n}\r\nstatic void lenovo_remove_cptkbd(struct hid_device *hdev)\r\n{\r\nsysfs_remove_group(&hdev->dev.kobj,\r\n&lenovo_attr_group_cptkbd);\r\n}\r\nstatic void lenovo_remove(struct hid_device *hdev)\r\n{\r\nswitch (hdev->product) {\r\ncase USB_DEVICE_ID_LENOVO_TPKBD:\r\nlenovo_remove_tpkbd(hdev);\r\nbreak;\r\ncase USB_DEVICE_ID_LENOVO_CUSBKBD:\r\ncase USB_DEVICE_ID_LENOVO_CBTKBD:\r\nlenovo_remove_cptkbd(hdev);\r\nbreak;\r\n}\r\nhid_hw_stop(hdev);\r\n}
