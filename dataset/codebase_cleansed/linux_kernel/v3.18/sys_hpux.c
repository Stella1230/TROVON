unsigned long hpux_brk(unsigned long addr)\r\n{\r\nreturn sys_brk(addr + PAGE_SIZE);\r\n}\r\nint hpux_sbrk(void)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint hpux_nice(int priority_change)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint hpux_ptrace(void)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint hpux_wait(int __user *stat_loc)\r\n{\r\nreturn sys_waitpid(-1, stat_loc, 0);\r\n}\r\nint hpux_setpgrp(void)\r\n{\r\nreturn sys_setpgid(0,0);\r\n}\r\nint hpux_setpgrp3(void)\r\n{\r\nreturn hpux_setpgrp();\r\n}\r\nint hpux_sysconf(int which)\r\n{\r\nswitch (which) {\r\ncase _SC_CPU_VERSION:\r\nreturn CPU_PA_RISC1_1;\r\ncase _SC_OPEN_MAX:\r\nreturn INT_MAX;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int hpux_ustat(dev_t dev, struct hpux_ustat __user *ubuf)\r\n{\r\nstruct hpux_ustat tmp;\r\nstruct kstatfs sbuf;\r\nint err = vfs_ustat(dev, &sbuf);\r\nif (err)\r\ngoto out;\r\nmemset(&tmp,0,sizeof(tmp));\r\ntmp.f_tfree = (int32_t)sbuf.f_bfree;\r\ntmp.f_tinode = (u_int32_t)sbuf.f_ffree;\r\ntmp.f_blksize = (u_int32_t)sbuf.f_bsize;\r\nerr = copy_to_user(ubuf, &tmp, sizeof(tmp)) ? -EFAULT : 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int do_statfs_hpux(struct kstatfs *st, struct hpux_statfs __user *p)\r\n{\r\nstruct hpux_statfs buf;\r\nmemset(&buf, 0, sizeof(buf));\r\nbuf.f_type = st->f_type;\r\nbuf.f_bsize = st->f_bsize;\r\nbuf.f_blocks = st->f_blocks;\r\nbuf.f_bfree = st->f_bfree;\r\nbuf.f_bavail = st->f_bavail;\r\nbuf.f_files = st->f_files;\r\nbuf.f_ffree = st->f_ffree;\r\nbuf.f_fsid[0] = st->f_fsid.val[0];\r\nbuf.f_fsid[1] = st->f_fsid.val[1];\r\nif (copy_to_user(p, &buf, sizeof(buf)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nasmlinkage long hpux_statfs(const char __user *pathname,\r\nstruct hpux_statfs __user *buf)\r\n{\r\nstruct kstatfs st;\r\nint error = user_statfs(pathname, &st);\r\nif (!error)\r\nerror = do_statfs_hpux(&st, buf);\r\nreturn error;\r\n}\r\nasmlinkage long hpux_fstatfs(unsigned int fd, struct hpux_statfs __user * buf)\r\n{\r\nstruct kstatfs st;\r\nint error = fd_statfs(fd, &st);\r\nif (!error)\r\nerror = do_statfs_hpux(&st, buf);\r\nreturn error;\r\n}\r\nstatic int hpux_uname(struct hpux_utsname __user *name)\r\n{\r\nint error;\r\nif (!name)\r\nreturn -EFAULT;\r\nif (!access_ok(VERIFY_WRITE,name,sizeof(struct hpux_utsname)))\r\nreturn -EFAULT;\r\ndown_read(&uts_sem);\r\nerror = __copy_to_user(&name->sysname, &utsname()->sysname,\r\nHPUX_UTSLEN - 1);\r\nerror |= __put_user(0, name->sysname + HPUX_UTSLEN - 1);\r\nerror |= __copy_to_user(&name->nodename, &utsname()->nodename,\r\nHPUX_UTSLEN - 1);\r\nerror |= __put_user(0, name->nodename + HPUX_UTSLEN - 1);\r\nerror |= __copy_to_user(&name->release, &utsname()->release,\r\nHPUX_UTSLEN - 1);\r\nerror |= __put_user(0, name->release + HPUX_UTSLEN - 1);\r\nerror |= __copy_to_user(&name->version, &utsname()->version,\r\nHPUX_UTSLEN - 1);\r\nerror |= __put_user(0, name->version + HPUX_UTSLEN - 1);\r\nerror |= __copy_to_user(&name->machine, &utsname()->machine,\r\nHPUX_UTSLEN - 1);\r\nerror |= __put_user(0, name->machine + HPUX_UTSLEN - 1);\r\nup_read(&uts_sem);\r\n#if 0\r\nerror |= __put_user(0,name->idnumber);\r\nerror |= __put_user(0,name->idnumber+HPUX_SNLEN-1);\r\n#endif\r\nerror = error ? -EFAULT : 0;\r\nreturn error;\r\n}\r\nint hpux_utssys(char __user *ubuf, int n, int type)\r\n{\r\nint len;\r\nint error;\r\nswitch( type ) {\r\ncase 0:\r\nreturn hpux_uname((struct hpux_utsname __user *)ubuf);\r\nbreak ;\r\ncase 1:\r\nreturn -EFAULT ;\r\nbreak ;\r\ncase 2:\r\nreturn hpux_ustat(new_decode_dev(n),\r\n(struct hpux_ustat __user *)ubuf);\r\nbreak;\r\ncase 3:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif ( n <= 0 )\r\nreturn -EINVAL ;\r\nlen = (n <= __NEW_UTS_LEN) ? n : __NEW_UTS_LEN ;\r\nreturn sys_sethostname(ubuf, len);\r\nbreak ;\r\ncase 4:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif ( n <= 0 )\r\nreturn -EINVAL ;\r\nlen = (n <= __NEW_UTS_LEN) ? n : __NEW_UTS_LEN ;\r\nreturn sys_sethostname(ubuf, len);\r\nbreak ;\r\ncase 5:\r\nif ( n <= 0 )\r\nreturn -EINVAL ;\r\nreturn sys_gethostname(ubuf, n);\r\nbreak ;\r\ncase 6:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif ( n <= 0 )\r\nreturn -EINVAL ;\r\nlen = (n <= __NEW_UTS_LEN) ? n : __NEW_UTS_LEN ;\r\ndown_write(&uts_sem);\r\nerror = -EFAULT;\r\nif (!copy_from_user(utsname()->sysname, ubuf, len)) {\r\nutsname()->sysname[len] = 0;\r\nerror = 0;\r\n}\r\nup_write(&uts_sem);\r\nreturn error;\r\nbreak ;\r\ncase 7:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif ( n <= 0 )\r\nreturn -EINVAL ;\r\nlen = (n <= __NEW_UTS_LEN) ? n : __NEW_UTS_LEN ;\r\ndown_write(&uts_sem);\r\nerror = -EFAULT;\r\nif (!copy_from_user(utsname()->release, ubuf, len)) {\r\nutsname()->release[len] = 0;\r\nerror = 0;\r\n}\r\nup_write(&uts_sem);\r\nreturn error;\r\nbreak ;\r\ndefault:\r\nreturn -EFAULT ;\r\n}\r\n}\r\nint hpux_getdomainname(char __user *name, int len)\r\n{\r\nint nlen;\r\nint err = -EFAULT;\r\ndown_read(&uts_sem);\r\nnlen = strlen(utsname()->domainname) + 1;\r\nif (nlen < len)\r\nlen = nlen;\r\nif(len > __NEW_UTS_LEN)\r\ngoto done;\r\nif(copy_to_user(name, utsname()->domainname, len))\r\ngoto done;\r\nerr = 0;\r\ndone:\r\nup_read(&uts_sem);\r\nreturn err;\r\n}\r\nint hpux_pipe(int *kstack_fildes)\r\n{\r\nreturn do_pipe_flags(kstack_fildes, 0);\r\n}\r\nint hpux_lockf(int fildes, int function, off_t size)\r\n{\r\nreturn 0;\r\n}\r\nint hpux_sysfs(int opcode, unsigned long arg1, unsigned long arg2)\r\n{\r\nchar *fsname = NULL;\r\nint len = 0;\r\nint fstype;\r\nprintk(KERN_DEBUG "in hpux_sysfs\n");\r\nprintk(KERN_DEBUG "hpux_sysfs called with opcode = %d\n", opcode);\r\nprintk(KERN_DEBUG "hpux_sysfs called with arg1='%lx'\n", arg1);\r\nif ( opcode == 1 ) {\r\nchar __user *user_fsname = (char __user *)arg1;\r\nlen = strlen_user(user_fsname);\r\nprintk(KERN_DEBUG "len of arg1 = %d\n", len);\r\nif (len == 0)\r\nreturn 0;\r\nfsname = kmalloc(len, GFP_KERNEL);\r\nif (!fsname) {\r\nprintk(KERN_DEBUG "failed to kmalloc fsname\n");\r\nreturn 0;\r\n}\r\nif (copy_from_user(fsname, user_fsname, len)) {\r\nprintk(KERN_DEBUG "failed to copy_from_user fsname\n");\r\nkfree(fsname);\r\nreturn 0;\r\n}\r\nfsname[len - 1] = '\0';\r\nprintk(KERN_DEBUG "that is '%s' as (char *)\n", fsname);\r\nif ( !strcmp(fsname, "hfs") ) {\r\nfstype = 0;\r\n} else {\r\nfstype = 0;\r\n}\r\nkfree(fsname);\r\nprintk(KERN_DEBUG "returning fstype=%d\n", fstype);\r\nreturn fstype;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nhpux_unimplemented(unsigned long arg1,unsigned long arg2,unsigned long arg3,\r\nunsigned long arg4,unsigned long arg5,unsigned long arg6,\r\nunsigned long arg7,unsigned long sc_num)\r\n{\r\nconst char *name = NULL;\r\nif ( sc_num <= syscall_names_max && sc_num >= 0 ) {\r\nname = syscall_names[sc_num];\r\n}\r\nif ( name ) {\r\nprintk(KERN_DEBUG "Unimplemented HP-UX syscall emulation. Syscall #%lu (%s)\n",\r\nsc_num, name);\r\n} else {\r\nprintk(KERN_DEBUG "Unimplemented unknown HP-UX syscall emulation. Syscall #%lu\n",\r\nsc_num);\r\n}\r\nprintk(KERN_DEBUG " Args: %lx %lx %lx %lx %lx %lx %lx\n",\r\narg1, arg2, arg3, arg4, arg5, arg6, arg7);\r\nreturn -ENOSYS;\r\n}
