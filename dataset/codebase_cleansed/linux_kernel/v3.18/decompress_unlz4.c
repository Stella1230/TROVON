STATIC inline int INIT unlz4(u8 *input, long in_len,\r\nlong (*fill)(void *, unsigned long),\r\nlong (*flush)(void *, unsigned long),\r\nu8 *output, long *posp,\r\nvoid (*error) (char *x))\r\n{\r\nint ret = -1;\r\nsize_t chunksize = 0;\r\nsize_t uncomp_chunksize = LZ4_DEFAULT_UNCOMPRESSED_CHUNK_SIZE;\r\nu8 *inp;\r\nu8 *inp_start;\r\nu8 *outp;\r\nlong size = in_len;\r\n#ifdef PREBOOT\r\nsize_t out_len = get_unaligned_le32(input + in_len);\r\n#endif\r\nsize_t dest_len;\r\nif (output) {\r\noutp = output;\r\n} else if (!flush) {\r\nerror("NULL output pointer and no flush function provided");\r\ngoto exit_0;\r\n} else {\r\noutp = large_malloc(uncomp_chunksize);\r\nif (!outp) {\r\nerror("Could not allocate output buffer");\r\ngoto exit_0;\r\n}\r\n}\r\nif (input && fill) {\r\nerror("Both input pointer and fill function provided,");\r\ngoto exit_1;\r\n} else if (input) {\r\ninp = input;\r\n} else if (!fill) {\r\nerror("NULL input pointer and missing fill function");\r\ngoto exit_1;\r\n} else {\r\ninp = large_malloc(lz4_compressbound(uncomp_chunksize));\r\nif (!inp) {\r\nerror("Could not allocate input buffer");\r\ngoto exit_1;\r\n}\r\n}\r\ninp_start = inp;\r\nif (posp)\r\n*posp = 0;\r\nif (fill) {\r\nsize = fill(inp, 4);\r\nif (size < 4) {\r\nerror("data corrupted");\r\ngoto exit_2;\r\n}\r\n}\r\nchunksize = get_unaligned_le32(inp);\r\nif (chunksize == ARCHIVE_MAGICNUMBER) {\r\nif (!fill) {\r\ninp += 4;\r\nsize -= 4;\r\n}\r\n} else {\r\nerror("invalid header");\r\ngoto exit_2;\r\n}\r\nif (posp)\r\n*posp += 4;\r\nfor (;;) {\r\nif (fill) {\r\nsize = fill(inp, 4);\r\nif (size == 0)\r\nbreak;\r\nif (size < 4) {\r\nerror("data corrupted");\r\ngoto exit_2;\r\n}\r\n}\r\nchunksize = get_unaligned_le32(inp);\r\nif (chunksize == ARCHIVE_MAGICNUMBER) {\r\nif (!fill) {\r\ninp += 4;\r\nsize -= 4;\r\n}\r\nif (posp)\r\n*posp += 4;\r\ncontinue;\r\n}\r\nif (posp)\r\n*posp += 4;\r\nif (!fill) {\r\ninp += 4;\r\nsize -= 4;\r\n} else {\r\nif (chunksize > lz4_compressbound(uncomp_chunksize)) {\r\nerror("chunk length is longer than allocated");\r\ngoto exit_2;\r\n}\r\nsize = fill(inp, chunksize);\r\nif (size < chunksize) {\r\nerror("data corrupted");\r\ngoto exit_2;\r\n}\r\n}\r\n#ifdef PREBOOT\r\nif (out_len >= uncomp_chunksize) {\r\ndest_len = uncomp_chunksize;\r\nout_len -= dest_len;\r\n} else\r\ndest_len = out_len;\r\nret = lz4_decompress(inp, &chunksize, outp, dest_len);\r\n#else\r\ndest_len = uncomp_chunksize;\r\nret = lz4_decompress_unknownoutputsize(inp, chunksize, outp,\r\n&dest_len);\r\n#endif\r\nif (ret < 0) {\r\nerror("Decoding failed");\r\ngoto exit_2;\r\n}\r\nret = -1;\r\nif (flush && flush(outp, dest_len) != dest_len)\r\ngoto exit_2;\r\nif (output)\r\noutp += dest_len;\r\nif (posp)\r\n*posp += chunksize;\r\nif (!fill) {\r\nsize -= chunksize;\r\nif (size == 0)\r\nbreak;\r\nelse if (size < 0) {\r\nerror("data corrupted");\r\ngoto exit_2;\r\n}\r\ninp += chunksize;\r\n}\r\n}\r\nret = 0;\r\nexit_2:\r\nif (!input)\r\nlarge_free(inp_start);\r\nexit_1:\r\nif (!output)\r\nlarge_free(outp);\r\nexit_0:\r\nreturn ret;\r\n}\r\nSTATIC int INIT decompress(unsigned char *buf, long in_len,\r\nlong (*fill)(void*, unsigned long),\r\nlong (*flush)(void*, unsigned long),\r\nunsigned char *output,\r\nlong *posp,\r\nvoid(*error)(char *x)\r\n)\r\n{\r\nreturn unlz4(buf, in_len - 4, fill, flush, output, posp, error);\r\n}
