static bool max9850_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX9850_STATUSA:\r\ncase MAX9850_STATUSB:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int max9850_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max9850_priv *max9850 = snd_soc_codec_get_drvdata(codec);\r\nu64 lrclk_div;\r\nu8 sf, da;\r\nif (!max9850->sysclk)\r\nreturn -EINVAL;\r\nsf = (snd_soc_read(codec, MAX9850_CLOCK) >> 2) + 1;\r\nlrclk_div = (1 << 22);\r\nlrclk_div *= params_rate(params);\r\nlrclk_div *= sf;\r\ndo_div(lrclk_div, max9850->sysclk);\r\nsnd_soc_write(codec, MAX9850_LRCLK_MSB, (lrclk_div >> 8) & 0x7f);\r\nsnd_soc_write(codec, MAX9850_LRCLK_LSB, lrclk_div & 0xff);\r\nswitch (params_width(params)) {\r\ncase 16:\r\nda = 0;\r\nbreak;\r\ncase 20:\r\nda = 0x2;\r\nbreak;\r\ncase 24:\r\nda = 0x3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, MAX9850_DIGITAL_AUDIO, 0x3, da);\r\nreturn 0;\r\n}\r\nstatic int max9850_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max9850_priv *max9850 = snd_soc_codec_get_drvdata(codec);\r\nif (freq <= 13000000)\r\nsnd_soc_write(codec, MAX9850_CLOCK, 0x0);\r\nelse if (freq <= 26000000)\r\nsnd_soc_write(codec, MAX9850_CLOCK, 0x4);\r\nelse if (freq <= 40000000)\r\nsnd_soc_write(codec, MAX9850_CLOCK, 0x8);\r\nelse\r\nreturn -EINVAL;\r\nmax9850->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int max9850_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 da = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nda |= MAX9850_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nda |= MAX9850_DLY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nda |= MAX9850_RTJ;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nda |= MAX9850_BCINV | MAX9850_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nda |= MAX9850_BCINV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nda |= MAX9850_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, MAX9850_DIGITAL_AUDIO, da);\r\nreturn 0;\r\n}\r\nstatic int max9850_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct max9850_priv *max9850 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regcache_sync(max9850->regmap);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int max9850_suspend(struct snd_soc_codec *codec)\r\n{\r\nmax9850_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int max9850_resume(struct snd_soc_codec *codec)\r\n{\r\nmax9850_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int max9850_probe(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_update_bits(codec, MAX9850_GENERAL_PURPOSE, 1, 1);\r\nsnd_soc_update_bits(codec, MAX9850_VOLUME, 0x40, 0x40);\r\nsnd_soc_update_bits(codec, MAX9850_CHARGE_PUMP, 0xff, 0xc0);\r\nreturn 0;\r\n}\r\nstatic int max9850_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max9850_priv *max9850;\r\nint ret;\r\nmax9850 = devm_kzalloc(&i2c->dev, sizeof(struct max9850_priv),\r\nGFP_KERNEL);\r\nif (max9850 == NULL)\r\nreturn -ENOMEM;\r\nmax9850->regmap = devm_regmap_init_i2c(i2c, &max9850_regmap);\r\nif (IS_ERR(max9850->regmap))\r\nreturn PTR_ERR(max9850->regmap);\r\ni2c_set_clientdata(i2c, max9850);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_max9850, &max9850_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int max9850_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
