static inline void sbic_arm_write(AS_Host *host, unsigned int reg, unsigned int value)\r\n{\r\nwriteb(reg, host->base + SBIC_REGIDX);\r\nwriteb(value, host->base + SBIC_REGVAL);\r\n}\r\nstatic inline int sbic_arm_read(AS_Host *host, unsigned int reg)\r\n{\r\nif(reg == SBIC_ASR)\r\nreturn readl(host->base + SBIC_REGIDX) & 255;\r\nwriteb(reg, host->base + SBIC_REGIDX);\r\nreturn readl(host->base + SBIC_REGVAL) & 255;\r\n}\r\nstatic inline unsigned int dmac_address(AS_Host *host)\r\n{\r\nreturn dmac_read(host, DMAC_TXADRHI) << 16 |\r\ndmac_read(host, DMAC_TXADRMD) << 8 |\r\ndmac_read(host, DMAC_TXADRLO);\r\n}\r\nstatic\r\nvoid acornscsi_dumpdma(AS_Host *host, char *where)\r\n{\r\nunsigned int mode, addr, len;\r\nmode = dmac_read(host, DMAC_MODECON);\r\naddr = dmac_address(host);\r\nlen = dmac_read(host, DMAC_TXCNTHI) << 8 |\r\ndmac_read(host, DMAC_TXCNTLO);\r\nprintk("scsi%d: %s: DMAC %02x @%06x+%04x msk %02x, ",\r\nhost->host->host_no, where,\r\nmode, addr, (len + 1) & 0xffff,\r\ndmac_read(host, DMAC_MASKREG));\r\nprintk("DMA @%06x, ", host->dma.start_addr);\r\nprintk("BH @%p +%04x, ", host->scsi.SCp.ptr,\r\nhost->scsi.SCp.this_residual);\r\nprintk("DT @+%04x ST @+%04x", host->dma.transferred,\r\nhost->scsi.SCp.scsi_xferred);\r\nprintk("\n");\r\n}\r\nstatic\r\nunsigned long acornscsi_sbic_xfcount(AS_Host *host)\r\n{\r\nunsigned long length;\r\nlength = sbic_arm_read(host, SBIC_TRANSCNTH) << 16;\r\nlength |= sbic_arm_readnext(host) << 8;\r\nlength |= sbic_arm_readnext(host);\r\nreturn length;\r\n}\r\nstatic int\r\nacornscsi_sbic_wait(AS_Host *host, int stat_mask, int stat, int timeout, char *msg)\r\n{\r\nint asr;\r\ndo {\r\nasr = sbic_arm_read(host, SBIC_ASR);\r\nif ((asr & stat_mask) == stat)\r\nreturn 0;\r\nudelay(1);\r\n} while (--timeout);\r\nprintk("scsi%d: timeout while %s\n", host->host->host_no, msg);\r\nreturn -1;\r\n}\r\nstatic\r\nint acornscsi_sbic_issuecmd(AS_Host *host, int command)\r\n{\r\nif (acornscsi_sbic_wait(host, ASR_CIP, 0, 1000, "issuing command"))\r\nreturn -1;\r\nsbic_arm_write(host, SBIC_CMND, command);\r\nreturn 0;\r\n}\r\nstatic void\r\nacornscsi_csdelay(unsigned int cs)\r\n{\r\nunsigned long target_jiffies, flags;\r\ntarget_jiffies = jiffies + 1 + cs * HZ / 100;\r\nlocal_save_flags(flags);\r\nlocal_irq_enable();\r\nwhile (time_before(jiffies, target_jiffies)) barrier();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic\r\nvoid acornscsi_resetcard(AS_Host *host)\r\n{\r\nunsigned int i, timeout;\r\nhost->card.page_reg = 0x80;\r\nwriteb(host->card.page_reg, host->fast + PAGE_REG);\r\nacornscsi_csdelay(3);\r\nhost->card.page_reg = 0;\r\nwriteb(host->card.page_reg, host->fast + PAGE_REG);\r\ntimeout = 1000;\r\ndo {\r\nif (readb(host->fast + INT_REG) & 8)\r\nbreak;\r\nudelay(1);\r\n} while (--timeout);\r\nif (timeout == 0)\r\nprintk("scsi%d: timeout while resetting card\n",\r\nhost->host->host_no);\r\nsbic_arm_read(host, SBIC_ASR);\r\nsbic_arm_read(host, SBIC_SSR);\r\nsbic_arm_write(host, SBIC_OWNID, OWNID_EAF | host->host->this_id);\r\nsbic_arm_write(host, SBIC_CMND, CMND_RESET);\r\ntimeout = 1000;\r\ndo {\r\nif (readb(host->fast + INT_REG) & 8)\r\nbreak;\r\nudelay(1);\r\n} while (--timeout);\r\nif (timeout == 0)\r\nprintk("scsi%d: timeout while resetting card\n",\r\nhost->host->host_no);\r\nsbic_arm_read(host, SBIC_ASR);\r\nif (sbic_arm_read(host, SBIC_SSR) != 0x01)\r\nprintk(KERN_CRIT "scsi%d: WD33C93A didn't give enhanced reset interrupt\n",\r\nhost->host->host_no);\r\nsbic_arm_write(host, SBIC_CTRL, INIT_SBICDMA | CTRL_IDI);\r\nsbic_arm_write(host, SBIC_TIMEOUT, TIMEOUT_TIME);\r\nsbic_arm_write(host, SBIC_SYNCHTRANSFER, SYNCHTRANSFER_2DBA);\r\nsbic_arm_write(host, SBIC_SOURCEID, SOURCEID_ER | SOURCEID_DSP);\r\nhost->card.page_reg = 0x40;\r\nwriteb(host->card.page_reg, host->fast + PAGE_REG);\r\ndmac_write(host, DMAC_INIT, 0);\r\n#ifdef USE_DMAC\r\ndmac_write(host, DMAC_INIT, INIT_8BIT);\r\ndmac_write(host, DMAC_CHANNEL, CHANNEL_0);\r\ndmac_write(host, DMAC_DEVCON0, INIT_DEVCON0);\r\ndmac_write(host, DMAC_DEVCON1, INIT_DEVCON1);\r\n#endif\r\nhost->SCpnt = NULL;\r\nhost->scsi.phase = PHASE_IDLE;\r\nhost->scsi.disconnectable = 0;\r\nmemset(host->busyluns, 0, sizeof(host->busyluns));\r\nfor (i = 0; i < 8; i++) {\r\nhost->device[i].sync_state = SYNC_NEGOCIATE;\r\nhost->device[i].disconnect_ok = 1;\r\n}\r\nacornscsi_csdelay(25);\r\n}\r\nstatic\r\nvoid print_scsi_status(unsigned int ssr)\r\n{\r\nif (acornscsi_map[ssr] != -1)\r\nprintk("%s:%s",\r\nacornscsi_interrupttype[(ssr >> 4)],\r\nacornscsi_interruptcode[acornscsi_map[ssr]]);\r\nelse\r\nprintk("%X:%X", ssr >> 4, ssr & 0x0f);\r\n}\r\nstatic\r\nvoid print_sbic_status(int asr, int ssr, int cmdphase)\r\n{\r\n#ifdef CONFIG_ACORNSCSI_CONSTANTS\r\nprintk("sbic: %c%c%c%c%c%c ",\r\nasr & ASR_INT ? 'I' : 'i',\r\nasr & ASR_LCI ? 'L' : 'l',\r\nasr & ASR_BSY ? 'B' : 'b',\r\nasr & ASR_CIP ? 'C' : 'c',\r\nasr & ASR_PE ? 'P' : 'p',\r\nasr & ASR_DBR ? 'D' : 'd');\r\nprintk("scsi: ");\r\nprint_scsi_status(ssr);\r\nprintk(" ph %02X\n", cmdphase);\r\n#else\r\nprintk("sbic: %02X scsi: %X:%X ph: %02X\n",\r\nasr, (ssr & 0xf0)>>4, ssr & 0x0f, cmdphase);\r\n#endif\r\n}\r\nstatic void\r\nacornscsi_dumplogline(AS_Host *host, int target, int line)\r\n{\r\nunsigned long prev;\r\nsigned int ptr;\r\nptr = host->status_ptr[target] - STATUS_BUFFER_TO_PRINT;\r\nif (ptr < 0)\r\nptr += STATUS_BUFFER_SIZE;\r\nprintk("%c: %3s:", target == 8 ? 'H' : '0' + target,\r\nline == 0 ? "ph" : line == 1 ? "ssr" : "int");\r\nprev = host->status[target][ptr].when;\r\nfor (; ptr != host->status_ptr[target]; ptr = (ptr + 1) & (STATUS_BUFFER_SIZE - 1)) {\r\nunsigned long time_diff;\r\nif (!host->status[target][ptr].when)\r\ncontinue;\r\nswitch (line) {\r\ncase 0:\r\nprintk("%c%02X", host->status[target][ptr].irq ? '-' : ' ',\r\nhost->status[target][ptr].ph);\r\nbreak;\r\ncase 1:\r\nprintk(" %02X", host->status[target][ptr].ssr);\r\nbreak;\r\ncase 2:\r\ntime_diff = host->status[target][ptr].when - prev;\r\nprev = host->status[target][ptr].when;\r\nif (time_diff == 0)\r\nprintk("==^");\r\nelse if (time_diff >= 100)\r\nprintk(" ");\r\nelse\r\nprintk(" %02ld", time_diff);\r\nbreak;\r\n}\r\n}\r\nprintk("\n");\r\n}\r\nstatic\r\nvoid acornscsi_dumplog(AS_Host *host, int target)\r\n{\r\ndo {\r\nacornscsi_dumplogline(host, target, 0);\r\nacornscsi_dumplogline(host, target, 1);\r\nacornscsi_dumplogline(host, target, 2);\r\nif (target == 8)\r\nbreak;\r\ntarget = 8;\r\n} while (1);\r\n}\r\nstatic\r\nchar acornscsi_target(AS_Host *host)\r\n{\r\nif (host->SCpnt)\r\nreturn '0' + host->SCpnt->device->id;\r\nreturn 'H';\r\n}\r\nstatic inline\r\ncmdtype_t acornscsi_cmdtype(int command)\r\n{\r\nswitch (command) {\r\ncase WRITE_6: case WRITE_10: case WRITE_12:\r\nreturn CMD_WRITE;\r\ncase READ_6: case READ_10: case READ_12:\r\nreturn CMD_READ;\r\ndefault:\r\nreturn CMD_MISC;\r\n}\r\n}\r\nstatic\r\ndatadir_t acornscsi_datadirection(int command)\r\n{\r\nswitch (command) {\r\ncase CHANGE_DEFINITION: case COMPARE: case COPY:\r\ncase COPY_VERIFY: case LOG_SELECT: case MODE_SELECT:\r\ncase MODE_SELECT_10: case SEND_DIAGNOSTIC: case WRITE_BUFFER:\r\ncase FORMAT_UNIT: case REASSIGN_BLOCKS: case RESERVE:\r\ncase SEARCH_EQUAL: case SEARCH_HIGH: case SEARCH_LOW:\r\ncase WRITE_6: case WRITE_10: case WRITE_VERIFY:\r\ncase UPDATE_BLOCK: case WRITE_LONG: case WRITE_SAME:\r\ncase SEARCH_HIGH_12: case SEARCH_EQUAL_12: case SEARCH_LOW_12:\r\ncase WRITE_12: case WRITE_VERIFY_12: case SET_WINDOW:\r\ncase MEDIUM_SCAN: case SEND_VOLUME_TAG: case 0xea:\r\nreturn DATADIR_OUT;\r\ndefault:\r\nreturn DATADIR_IN;\r\n}\r\n}\r\nstatic\r\nint acornscsi_getperiod(unsigned char syncxfer)\r\n{\r\nint i;\r\nsyncxfer &= 0xf0;\r\nif (syncxfer == 0x10)\r\nsyncxfer = 0;\r\nfor (i = 1; sync_xfer_table[i].period_ns; i++)\r\nif (syncxfer == sync_xfer_table[i].reg_value)\r\nreturn sync_xfer_table[i].period_ns;\r\nreturn 0;\r\n}\r\nstatic inline\r\nint round_period(unsigned int period)\r\n{\r\nint i;\r\nfor (i = 1; sync_xfer_table[i].period_ns; i++) {\r\nif ((period <= sync_xfer_table[i].period_ns) &&\r\n(period > sync_xfer_table[i - 1].period_ns))\r\nreturn i;\r\n}\r\nreturn 7;\r\n}\r\nstatic\r\nunsigned char calc_sync_xfer(unsigned int period, unsigned int offset)\r\n{\r\nreturn sync_xfer_table[round_period(period)].reg_value |\r\n((offset < SDTR_SIZE) ? offset : SDTR_SIZE);\r\n}\r\nstatic\r\nintr_ret_t acornscsi_kick(AS_Host *host)\r\n{\r\nint from_queue = 0;\r\nstruct scsi_cmnd *SCpnt;\r\nSCpnt = host->origSCpnt;\r\nhost->origSCpnt = NULL;\r\nif (!SCpnt) {\r\nSCpnt = queue_remove_exclude(&host->queues.issue, host->busyluns);\r\nif (!SCpnt)\r\nreturn INTR_IDLE;\r\nfrom_queue = 1;\r\n}\r\nif (host->scsi.disconnectable && host->SCpnt) {\r\nqueue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);\r\nhost->scsi.disconnectable = 0;\r\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\r\nDBG(host->SCpnt, printk("scsi%d.%c: moved command to disconnected queue\n",\r\nhost->host->host_no, acornscsi_target(host)));\r\n#endif\r\nhost->SCpnt = NULL;\r\n}\r\nif (!(sbic_arm_read(host, SBIC_ASR) & (ASR_INT|ASR_BSY|ASR_CIP))) {\r\nsbic_arm_write(host, SBIC_DESTID, SCpnt->device->id);\r\nsbic_arm_write(host, SBIC_CMND, CMND_SELWITHATN);\r\n}\r\nhost->scsi.phase = PHASE_CONNECTING;\r\nhost->SCpnt = SCpnt;\r\nhost->scsi.SCp = SCpnt->SCp;\r\nhost->dma.xfer_setup = 0;\r\nhost->dma.xfer_required = 0;\r\nhost->dma.xfer_done = 0;\r\n#if (DEBUG & (DEBUG_ABORT|DEBUG_CONNECT))\r\nDBG(SCpnt,printk("scsi%d.%c: starting cmd %02X\n",\r\nhost->host->host_no, '0' + SCpnt->device->id,\r\nSCpnt->cmnd[0]));\r\n#endif\r\nif (from_queue) {\r\n#ifdef CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE\r\nif (SCpnt->device->simple_tags) {\r\nSCpnt->device->current_tag += 1;\r\nif (SCpnt->device->current_tag == 0)\r\nSCpnt->device->current_tag = 1;\r\nSCpnt->tag = SCpnt->device->current_tag;\r\n} else\r\n#endif\r\nset_bit(SCpnt->device->id * 8 +\r\n(u8)(SCpnt->device->lun & 0x07), host->busyluns);\r\nhost->stats.removes += 1;\r\nswitch (acornscsi_cmdtype(SCpnt->cmnd[0])) {\r\ncase CMD_WRITE:\r\nhost->stats.writes += 1;\r\nbreak;\r\ncase CMD_READ:\r\nhost->stats.reads += 1;\r\nbreak;\r\ncase CMD_MISC:\r\nhost->stats.miscs += 1;\r\nbreak;\r\n}\r\n}\r\nreturn INTR_PROCESSING;\r\n}\r\nstatic void acornscsi_done(AS_Host *host, struct scsi_cmnd **SCpntp,\r\nunsigned int result)\r\n{\r\nstruct scsi_cmnd *SCpnt = *SCpntp;\r\nsbic_arm_write(host, SBIC_SOURCEID, SOURCEID_ER | SOURCEID_DSP);\r\nhost->stats.fins += 1;\r\nif (SCpnt) {\r\n*SCpntp = NULL;\r\nacornscsi_dma_cleanup(host);\r\nSCpnt->result = result << 16 | host->scsi.SCp.Message << 8 | host->scsi.SCp.Status;\r\nif (result == DID_OK) {\r\nint xfer_warn = 0;\r\nif (SCpnt->underflow == 0) {\r\nif (host->scsi.SCp.ptr &&\r\nacornscsi_cmdtype(SCpnt->cmnd[0]) != CMD_MISC)\r\nxfer_warn = 1;\r\n} else {\r\nif (host->scsi.SCp.scsi_xferred < SCpnt->underflow ||\r\nhost->scsi.SCp.scsi_xferred != host->dma.transferred)\r\nxfer_warn = 1;\r\n}\r\nif (host->dma.xfer_done)\r\nxfer_warn = 0;\r\nif (xfer_warn) {\r\nswitch (status_byte(SCpnt->result)) {\r\ncase CHECK_CONDITION:\r\ncase COMMAND_TERMINATED:\r\ncase BUSY:\r\ncase QUEUE_FULL:\r\ncase RESERVATION_CONFLICT:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.H: incomplete data transfer detected: result=%08X command=",\r\nhost->host->host_no, SCpnt->result);\r\n__scsi_print_command(SCpnt->cmnd);\r\nacornscsi_dumpdma(host, "done");\r\nacornscsi_dumplog(host, SCpnt->device->id);\r\nSCpnt->result &= 0xffff;\r\nSCpnt->result |= DID_ERROR << 16;\r\n}\r\n}\r\n}\r\nif (!SCpnt->scsi_done)\r\npanic("scsi%d.H: null scsi_done function in acornscsi_done", host->host->host_no);\r\nclear_bit(SCpnt->device->id * 8 +\r\n(u8)(SCpnt->device->lun & 0x7), host->busyluns);\r\nSCpnt->scsi_done(SCpnt);\r\n} else\r\nprintk("scsi%d: null command in acornscsi_done", host->host->host_no);\r\nhost->scsi.phase = PHASE_IDLE;\r\n}\r\nstatic\r\nvoid acornscsi_data_updateptr(AS_Host *host, struct scsi_pointer *SCp, unsigned int length)\r\n{\r\nSCp->ptr += length;\r\nSCp->this_residual -= length;\r\nif (SCp->this_residual == 0 && next_SCp(SCp) == 0)\r\nhost->dma.xfer_done = 1;\r\n}\r\nstatic\r\nvoid acornscsi_data_read(AS_Host *host, char *ptr,\r\nunsigned int start_addr, unsigned int length)\r\n{\r\nextern void __acornscsi_in(void __iomem *, char *buf, int len);\r\nunsigned int page, offset, len = length;\r\npage = (start_addr >> 12);\r\noffset = start_addr & ((1 << 12) - 1);\r\nwriteb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);\r\nwhile (len > 0) {\r\nunsigned int this_len;\r\nif (len + offset > (1 << 12))\r\nthis_len = (1 << 12) - offset;\r\nelse\r\nthis_len = len;\r\n__acornscsi_in(host->base + (offset << 1), ptr, this_len);\r\noffset += this_len;\r\nptr += this_len;\r\nlen -= this_len;\r\nif (offset == (1 << 12)) {\r\noffset = 0;\r\npage ++;\r\nwriteb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);\r\n}\r\n}\r\nwriteb(host->card.page_reg, host->fast + PAGE_REG);\r\n}\r\nstatic\r\nvoid acornscsi_data_write(AS_Host *host, char *ptr,\r\nunsigned int start_addr, unsigned int length)\r\n{\r\nextern void __acornscsi_out(void __iomem *, char *buf, int len);\r\nunsigned int page, offset, len = length;\r\npage = (start_addr >> 12);\r\noffset = start_addr & ((1 << 12) - 1);\r\nwriteb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);\r\nwhile (len > 0) {\r\nunsigned int this_len;\r\nif (len + offset > (1 << 12))\r\nthis_len = (1 << 12) - offset;\r\nelse\r\nthis_len = len;\r\n__acornscsi_out(host->base + (offset << 1), ptr, this_len);\r\noffset += this_len;\r\nptr += this_len;\r\nlen -= this_len;\r\nif (offset == (1 << 12)) {\r\noffset = 0;\r\npage ++;\r\nwriteb((page & 0x3f) | host->card.page_reg, host->fast + PAGE_REG);\r\n}\r\n}\r\nwriteb(host->card.page_reg, host->fast + PAGE_REG);\r\n}\r\nstatic inline\r\nvoid acornscsi_dma_stop(AS_Host *host)\r\n{\r\ndmac_write(host, DMAC_MASKREG, MASK_ON);\r\ndmac_clearintr(host);\r\n#if (DEBUG & DEBUG_DMA)\r\nDBG(host->SCpnt, acornscsi_dumpdma(host, "stop"));\r\n#endif\r\n}\r\nstatic\r\nvoid acornscsi_dma_setup(AS_Host *host, dmadir_t direction)\r\n{\r\nunsigned int address, length, mode;\r\nhost->dma.direction = direction;\r\ndmac_write(host, DMAC_MASKREG, MASK_ON);\r\nif (direction == DMA_OUT) {\r\n#if (DEBUG & DEBUG_NO_WRITE)\r\nif (NO_WRITE & (1 << host->SCpnt->device->id)) {\r\nprintk(KERN_CRIT "scsi%d.%c: I can't handle DMA_OUT!\n",\r\nhost->host->host_no, acornscsi_target(host));\r\nreturn;\r\n}\r\n#endif\r\nmode = DMAC_WRITE;\r\n} else\r\nmode = DMAC_READ;\r\nlength = min_t(unsigned int, host->scsi.SCp.this_residual, DMAC_BUFFER_SIZE / 2);\r\nif (length) {\r\nhost->dma.start_addr = address = host->dma.free_addr;\r\nhost->dma.free_addr = (host->dma.free_addr + length) &\r\n(DMAC_BUFFER_SIZE - 1);\r\nif (direction == DMA_OUT)\r\nacornscsi_data_write(host, host->scsi.SCp.ptr, host->dma.start_addr,\r\nlength);\r\nlength -= 1;\r\ndmac_write(host, DMAC_TXCNTLO, length);\r\ndmac_write(host, DMAC_TXCNTHI, length >> 8);\r\ndmac_write(host, DMAC_TXADRLO, address);\r\ndmac_write(host, DMAC_TXADRMD, address >> 8);\r\ndmac_write(host, DMAC_TXADRHI, 0);\r\ndmac_write(host, DMAC_MODECON, mode);\r\ndmac_write(host, DMAC_MASKREG, MASK_OFF);\r\n#if (DEBUG & DEBUG_DMA)\r\nDBG(host->SCpnt, acornscsi_dumpdma(host, "strt"));\r\n#endif\r\nhost->dma.xfer_setup = 1;\r\n}\r\n}\r\nstatic\r\nvoid acornscsi_dma_cleanup(AS_Host *host)\r\n{\r\ndmac_write(host, DMAC_MASKREG, MASK_ON);\r\ndmac_clearintr(host);\r\nif (host->dma.xfer_required) {\r\nhost->dma.xfer_required = 0;\r\nif (host->dma.direction == DMA_IN)\r\nacornscsi_data_read(host, host->dma.xfer_ptr,\r\nhost->dma.xfer_start, host->dma.xfer_length);\r\n}\r\nif (host->dma.xfer_setup) {\r\nunsigned int transferred;\r\nhost->dma.xfer_setup = 0;\r\n#if (DEBUG & DEBUG_DMA)\r\nDBG(host->SCpnt, acornscsi_dumpdma(host, "cupi"));\r\n#endif\r\ntransferred = dmac_address(host) - host->dma.start_addr;\r\nhost->dma.transferred += transferred;\r\nif (host->dma.direction == DMA_IN)\r\nacornscsi_data_read(host, host->scsi.SCp.ptr,\r\nhost->dma.start_addr, transferred);\r\nacornscsi_data_updateptr(host, &host->scsi.SCp, transferred);\r\n#if (DEBUG & DEBUG_DMA)\r\nDBG(host->SCpnt, acornscsi_dumpdma(host, "cupo"));\r\n#endif\r\n}\r\n}\r\nstatic\r\nvoid acornscsi_dma_intr(AS_Host *host)\r\n{\r\nunsigned int address, length, transferred;\r\n#if (DEBUG & DEBUG_DMA)\r\nDBG(host->SCpnt, acornscsi_dumpdma(host, "inti"));\r\n#endif\r\ndmac_write(host, DMAC_MASKREG, MASK_ON);\r\ndmac_clearintr(host);\r\ntransferred = dmac_address(host) - host->dma.start_addr;\r\nhost->dma.transferred += transferred;\r\nif (host->dma.direction == DMA_IN) {\r\nhost->dma.xfer_start = host->dma.start_addr;\r\nhost->dma.xfer_length = transferred;\r\nhost->dma.xfer_ptr = host->scsi.SCp.ptr;\r\nhost->dma.xfer_required = 1;\r\n}\r\nacornscsi_data_updateptr(host, &host->scsi.SCp, transferred);\r\nlength = min_t(unsigned int, host->scsi.SCp.this_residual, DMAC_BUFFER_SIZE / 2);\r\nif (length) {\r\nhost->dma.start_addr = address = host->dma.free_addr;\r\nhost->dma.free_addr = (host->dma.free_addr + length) &\r\n(DMAC_BUFFER_SIZE - 1);\r\nif (host->dma.direction == DMA_OUT)\r\nacornscsi_data_write(host, host->scsi.SCp.ptr, host->dma.start_addr,\r\nlength);\r\nlength -= 1;\r\ndmac_write(host, DMAC_TXCNTLO, length);\r\ndmac_write(host, DMAC_TXCNTHI, length >> 8);\r\ndmac_write(host, DMAC_TXADRLO, address);\r\ndmac_write(host, DMAC_TXADRMD, address >> 8);\r\ndmac_write(host, DMAC_TXADRHI, 0);\r\ndmac_write(host, DMAC_MASKREG, MASK_OFF);\r\n#if (DEBUG & DEBUG_DMA)\r\nDBG(host->SCpnt, acornscsi_dumpdma(host, "into"));\r\n#endif\r\n} else {\r\nhost->dma.xfer_setup = 0;\r\n#if 0\r\nif (dmac_read(host, DMAC_STATUS) & STATUS_RQ0) {\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\ndmac_write(host, DMAC_TXCNTLO, 0);\r\ndmac_write(host, DMAC_TXCNTHI, 0);\r\ndmac_write(host, DMAC_TXADRLO, 0);\r\ndmac_write(host, DMAC_TXADRMD, 0);\r\ndmac_write(host, DMAC_TXADRHI, 0);\r\ndmac_write(host, DMAC_MASKREG, MASK_OFF);\r\n}\r\n#endif\r\n}\r\n}\r\nstatic\r\nvoid acornscsi_dma_xfer(AS_Host *host)\r\n{\r\nhost->dma.xfer_required = 0;\r\nif (host->dma.direction == DMA_IN)\r\nacornscsi_data_read(host, host->dma.xfer_ptr,\r\nhost->dma.xfer_start, host->dma.xfer_length);\r\n}\r\nstatic\r\nvoid acornscsi_dma_adjust(AS_Host *host)\r\n{\r\nif (host->dma.xfer_setup) {\r\nsigned long transferred;\r\n#if (DEBUG & (DEBUG_DMA|DEBUG_WRITE))\r\nDBG(host->SCpnt, acornscsi_dumpdma(host, "adji"));\r\n#endif\r\ntransferred = host->scsi.SCp.scsi_xferred - host->dma.transferred;\r\nif (transferred < 0)\r\nprintk("scsi%d.%c: Ack! DMA write correction %ld < 0!\n",\r\nhost->host->host_no, acornscsi_target(host), transferred);\r\nelse if (transferred == 0)\r\nhost->dma.xfer_setup = 0;\r\nelse {\r\ntransferred += host->dma.start_addr;\r\ndmac_write(host, DMAC_TXADRLO, transferred);\r\ndmac_write(host, DMAC_TXADRMD, transferred >> 8);\r\ndmac_write(host, DMAC_TXADRHI, transferred >> 16);\r\n#if (DEBUG & (DEBUG_DMA|DEBUG_WRITE))\r\nDBG(host->SCpnt, acornscsi_dumpdma(host, "adjo"));\r\n#endif\r\n}\r\n}\r\n}\r\nstatic int\r\nacornscsi_write_pio(AS_Host *host, char *bytes, int *ptr, int len, unsigned int max_timeout)\r\n{\r\nunsigned int asr, timeout = max_timeout;\r\nint my_ptr = *ptr;\r\nwhile (my_ptr < len) {\r\nasr = sbic_arm_read(host, SBIC_ASR);\r\nif (asr & ASR_DBR) {\r\ntimeout = max_timeout;\r\nsbic_arm_write(host, SBIC_DATA, bytes[my_ptr++]);\r\n} else if (asr & ASR_INT)\r\nbreak;\r\nelse if (--timeout == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\n*ptr = my_ptr;\r\nreturn (timeout == 0) ? -1 : 0;\r\n}\r\nstatic void\r\nacornscsi_sendcommand(AS_Host *host)\r\n{\r\nstruct scsi_cmnd *SCpnt = host->SCpnt;\r\nsbic_arm_write(host, SBIC_TRANSCNTH, 0);\r\nsbic_arm_writenext(host, 0);\r\nsbic_arm_writenext(host, SCpnt->cmd_len - host->scsi.SCp.sent_command);\r\nacornscsi_sbic_issuecmd(host, CMND_XFERINFO);\r\nif (acornscsi_write_pio(host, SCpnt->cmnd,\r\n(int *)&host->scsi.SCp.sent_command, SCpnt->cmd_len, 1000000))\r\nprintk("scsi%d: timeout while sending command\n", host->host->host_no);\r\nhost->scsi.phase = PHASE_COMMAND;\r\n}\r\nstatic\r\nvoid acornscsi_sendmessage(AS_Host *host)\r\n{\r\nunsigned int message_length = msgqueue_msglength(&host->scsi.msgs);\r\nunsigned int msgnr;\r\nstruct message *msg;\r\n#if (DEBUG & DEBUG_MESSAGES)\r\nprintk("scsi%d.%c: sending message ",\r\nhost->host->host_no, acornscsi_target(host));\r\n#endif\r\nswitch (message_length) {\r\ncase 0:\r\nacornscsi_sbic_issuecmd(host, CMND_XFERINFO | CMND_SBT);\r\nacornscsi_sbic_wait(host, ASR_DBR, ASR_DBR, 1000, "sending message 1");\r\nsbic_arm_write(host, SBIC_DATA, NOP);\r\nhost->scsi.last_message = NOP;\r\n#if (DEBUG & DEBUG_MESSAGES)\r\nprintk("NOP");\r\n#endif\r\nbreak;\r\ncase 1:\r\nacornscsi_sbic_issuecmd(host, CMND_XFERINFO | CMND_SBT);\r\nmsg = msgqueue_getmsg(&host->scsi.msgs, 0);\r\nacornscsi_sbic_wait(host, ASR_DBR, ASR_DBR, 1000, "sending message 2");\r\nsbic_arm_write(host, SBIC_DATA, msg->msg[0]);\r\nhost->scsi.last_message = msg->msg[0];\r\n#if (DEBUG & DEBUG_MESSAGES)\r\nspi_print_msg(msg->msg);\r\n#endif\r\nbreak;\r\ndefault:\r\nsbic_arm_write(host, SBIC_TRANSCNTH, 0);\r\nsbic_arm_writenext(host, 0);\r\nsbic_arm_writenext(host, message_length);\r\nacornscsi_sbic_issuecmd(host, CMND_XFERINFO);\r\nmsgnr = 0;\r\nwhile ((msg = msgqueue_getmsg(&host->scsi.msgs, msgnr++)) != NULL) {\r\nunsigned int i;\r\n#if (DEBUG & DEBUG_MESSAGES)\r\nspi_print_msg(msg);\r\n#endif\r\ni = 0;\r\nif (acornscsi_write_pio(host, msg->msg, &i, msg->length, 1000000))\r\nprintk("scsi%d: timeout while sending message\n", host->host->host_no);\r\nhost->scsi.last_message = msg->msg[0];\r\nif (msg->msg[0] == EXTENDED_MESSAGE)\r\nhost->scsi.last_message |= msg->msg[2] << 8;\r\nif (i != msg->length)\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n#if (DEBUG & DEBUG_MESSAGES)\r\nprintk("\n");\r\n#endif\r\n}\r\nstatic\r\nvoid acornscsi_readstatusbyte(AS_Host *host)\r\n{\r\nacornscsi_sbic_issuecmd(host, CMND_XFERINFO|CMND_SBT);\r\nacornscsi_sbic_wait(host, ASR_DBR, ASR_DBR, 1000, "reading status byte");\r\nhost->scsi.SCp.Status = sbic_arm_read(host, SBIC_DATA);\r\n}\r\nstatic\r\nunsigned char acornscsi_readmessagebyte(AS_Host *host)\r\n{\r\nunsigned char message;\r\nacornscsi_sbic_issuecmd(host, CMND_XFERINFO | CMND_SBT);\r\nacornscsi_sbic_wait(host, ASR_DBR, ASR_DBR, 1000, "for message byte");\r\nmessage = sbic_arm_read(host, SBIC_DATA);\r\nacornscsi_sbic_wait(host, ASR_INT, ASR_INT, 1000, "for interrupt after message byte");\r\nsbic_arm_read(host, SBIC_SSR);\r\nreturn message;\r\n}\r\nstatic\r\nvoid acornscsi_message(AS_Host *host)\r\n{\r\nunsigned char message[16];\r\nunsigned int msgidx = 0, msglen = 1;\r\ndo {\r\nmessage[msgidx] = acornscsi_readmessagebyte(host);\r\nswitch (msgidx) {\r\ncase 0:\r\nif (message[0] == EXTENDED_MESSAGE ||\r\n(message[0] >= 0x20 && message[0] <= 0x2f))\r\nmsglen = 2;\r\nbreak;\r\ncase 1:\r\nif (message[0] == EXTENDED_MESSAGE)\r\nmsglen += message[msgidx];\r\nbreak;\r\n}\r\nmsgidx += 1;\r\nif (msgidx < msglen) {\r\nacornscsi_sbic_issuecmd(host, CMND_NEGATEACK);\r\nacornscsi_sbic_wait(host, ASR_INT, ASR_INT, 1000, "for interrupt after negate ack");\r\nsbic_arm_read(host, SBIC_SSR);\r\n}\r\n} while (msgidx < msglen);\r\n#if (DEBUG & DEBUG_MESSAGES)\r\nprintk("scsi%d.%c: message in: ",\r\nhost->host->host_no, acornscsi_target(host));\r\nspi_print_msg(message);\r\nprintk("\n");\r\n#endif\r\nif (host->scsi.phase == PHASE_RECONNECTED) {\r\nif (message[0] == SIMPLE_QUEUE_TAG)\r\nhost->scsi.reconnected.tag = message[1];\r\nif (acornscsi_reconnect_finish(host))\r\nhost->scsi.phase = PHASE_MSGIN;\r\n}\r\nswitch (message[0]) {\r\ncase ABORT:\r\ncase ABORT_TAG:\r\ncase COMMAND_COMPLETE:\r\nif (host->scsi.phase != PHASE_STATUSIN) {\r\nprintk(KERN_ERR "scsi%d.%c: command complete following non-status in phase?\n",\r\nhost->host->host_no, acornscsi_target(host));\r\nacornscsi_dumplog(host, host->SCpnt->device->id);\r\n}\r\nhost->scsi.phase = PHASE_DONE;\r\nhost->scsi.SCp.Message = message[0];\r\nbreak;\r\ncase SAVE_POINTERS:\r\nacornscsi_dma_cleanup(host);\r\nhost->SCpnt->SCp = host->scsi.SCp;\r\nhost->SCpnt->SCp.sent_command = 0;\r\nhost->scsi.phase = PHASE_MSGIN;\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nacornscsi_dma_cleanup(host);\r\nhost->scsi.SCp = host->SCpnt->SCp;\r\nhost->scsi.phase = PHASE_MSGIN;\r\nbreak;\r\ncase DISCONNECT:\r\nacornscsi_dma_cleanup(host);\r\nhost->scsi.phase = PHASE_DISCONNECT;\r\nbreak;\r\ncase MESSAGE_REJECT:\r\n#if 0\r\nif (host->device[host->SCpnt->device->id].sync_state == SYNC_SENT_REQUEST)\r\nhost->device[host->SCpnt->device->id].sync_state = SYNC_NEGOCIATE;\r\n#endif\r\nif (msgqueue_msglength(&host->scsi.msgs))\r\nacornscsi_sbic_issuecmd(host, CMND_ASSERTATN);\r\nswitch (host->scsi.last_message) {\r\n#ifdef CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE\r\ncase HEAD_OF_QUEUE_TAG:\r\ncase ORDERED_QUEUE_TAG:\r\ncase SIMPLE_QUEUE_TAG:\r\nprintk(KERN_NOTICE "scsi%d.%c: disabling tagged queueing\n",\r\nhost->host->host_no, acornscsi_target(host));\r\nhost->SCpnt->device->simple_tags = 0;\r\nset_bit(host->SCpnt->device->id * 8 +\r\n(u8)(host->SCpnt->device->lun & 0x7), host->busyluns);\r\nbreak;\r\n#endif\r\ncase EXTENDED_MESSAGE | (EXTENDED_SDTR << 8):\r\nprintk(KERN_NOTICE "scsi%d.%c: Using asynchronous transfer\n",\r\nhost->host->host_no, acornscsi_target(host));\r\nhost->device[host->SCpnt->device->id].sync_xfer = SYNCHTRANSFER_2DBA;\r\nhost->device[host->SCpnt->device->id].sync_state = SYNC_ASYNCHRONOUS;\r\nsbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase QUEUE_FULL:\r\nbreak;\r\ncase SIMPLE_QUEUE_TAG:\r\nprintk("scsi%d.%c: reconnect queue tag %02X\n",\r\nhost->host->host_no, acornscsi_target(host),\r\nmessage[1]);\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nswitch (message[2]) {\r\n#ifdef CONFIG_SCSI_ACORNSCSI_SYNC\r\ncase EXTENDED_SDTR:\r\nif (host->device[host->SCpnt->device->id].sync_state == SYNC_SENT_REQUEST) {\r\nhost->device[host->SCpnt->device->id].sync_state = SYNC_COMPLETED;\r\nprintk(KERN_NOTICE "scsi%d.%c: Using synchronous transfer, offset %d, %d ns\n",\r\nhost->host->host_no, acornscsi_target(host),\r\nmessage[4], message[3] * 4);\r\nhost->device[host->SCpnt->device->id].sync_xfer =\r\ncalc_sync_xfer(message[3] * 4, message[4]);\r\n} else {\r\nunsigned char period, length;\r\nacornscsi_sbic_issuecmd(host, CMND_ASSERTATN);\r\nperiod = max_t(unsigned int, message[3], sdtr_period / 4);\r\nlength = min_t(unsigned int, message[4], sdtr_size);\r\nmsgqueue_addmsg(&host->scsi.msgs, 5, EXTENDED_MESSAGE, 3,\r\nEXTENDED_SDTR, period, length);\r\nhost->device[host->SCpnt->device->id].sync_xfer =\r\ncalc_sync_xfer(period * 4, length);\r\n}\r\nsbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);\r\nbreak;\r\n#else\r\n#endif\r\ncase EXTENDED_WDTR:\r\ndefault:\r\nacornscsi_sbic_issuecmd(host, CMND_ASSERTATN);\r\nmsgqueue_flush(&host->scsi.msgs);\r\nmsgqueue_addmsg(&host->scsi.msgs, 1, MESSAGE_REJECT);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: unrecognised message %02X, rejecting\n",\r\nhost->host->host_no, acornscsi_target(host),\r\nmessage[0]);\r\nacornscsi_sbic_issuecmd(host, CMND_ASSERTATN);\r\nmsgqueue_flush(&host->scsi.msgs);\r\nmsgqueue_addmsg(&host->scsi.msgs, 1, MESSAGE_REJECT);\r\nhost->scsi.phase = PHASE_MSGIN;\r\nbreak;\r\n}\r\nacornscsi_sbic_issuecmd(host, CMND_NEGATEACK);\r\n}\r\nstatic\r\nvoid acornscsi_buildmessages(AS_Host *host)\r\n{\r\n#if 0\r\nif (cmd_reset) {\r\nmsgqueue_addmsg(&host->scsi.msgs, 1, BUS_DEVICE_RESET);\r\nreturn;\r\n}\r\n#endif\r\nmsgqueue_addmsg(&host->scsi.msgs, 1,\r\nIDENTIFY(host->device[host->SCpnt->device->id].disconnect_ok,\r\nhost->SCpnt->device->lun));\r\n#if 0\r\nif (cmd_aborted) {\r\nacornscsi_abortcmd(host->SCpnt->tag);\r\nreturn;\r\n}\r\n#endif\r\n#ifdef CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE\r\nif (host->SCpnt->tag) {\r\nunsigned int tag_type;\r\nif (host->SCpnt->cmnd[0] == REQUEST_SENSE ||\r\nhost->SCpnt->cmnd[0] == TEST_UNIT_READY ||\r\nhost->SCpnt->cmnd[0] == INQUIRY)\r\ntag_type = HEAD_OF_QUEUE_TAG;\r\nelse\r\ntag_type = SIMPLE_QUEUE_TAG;\r\nmsgqueue_addmsg(&host->scsi.msgs, 2, tag_type, host->SCpnt->tag);\r\n}\r\n#endif\r\n#ifdef CONFIG_SCSI_ACORNSCSI_SYNC\r\nif (host->device[host->SCpnt->device->id].sync_state == SYNC_NEGOCIATE) {\r\nhost->device[host->SCpnt->device->id].sync_state = SYNC_SENT_REQUEST;\r\nmsgqueue_addmsg(&host->scsi.msgs, 5,\r\nEXTENDED_MESSAGE, 3, EXTENDED_SDTR,\r\nsdtr_period / 4, sdtr_size);\r\n}\r\n#endif\r\n}\r\nstatic\r\nint acornscsi_starttransfer(AS_Host *host)\r\n{\r\nint residual;\r\nif (!host->scsi.SCp.ptr ) {\r\nprintk(KERN_ERR "scsi%d.%c: null buffer passed to acornscsi_starttransfer\n",\r\nhost->host->host_no, acornscsi_target(host));\r\nreturn 0;\r\n}\r\nresidual = scsi_bufflen(host->SCpnt) - host->scsi.SCp.scsi_xferred;\r\nsbic_arm_write(host, SBIC_SYNCHTRANSFER, host->device[host->SCpnt->device->id].sync_xfer);\r\nsbic_arm_writenext(host, residual >> 16);\r\nsbic_arm_writenext(host, residual >> 8);\r\nsbic_arm_writenext(host, residual);\r\nacornscsi_sbic_issuecmd(host, CMND_XFERINFO);\r\nreturn 1;\r\n}\r\nstatic\r\nint acornscsi_reconnect(AS_Host *host)\r\n{\r\nunsigned int target, lun, ok = 0;\r\ntarget = sbic_arm_read(host, SBIC_SOURCEID);\r\nif (!(target & 8))\r\nprintk(KERN_ERR "scsi%d: invalid source id after reselection "\r\n"- device fault?\n",\r\nhost->host->host_no);\r\ntarget &= 7;\r\nif (host->SCpnt && !host->scsi.disconnectable) {\r\nprintk(KERN_ERR "scsi%d.%d: reconnected while command in "\r\n"progress to target %d?\n",\r\nhost->host->host_no, target, host->SCpnt->device->id);\r\nhost->SCpnt = NULL;\r\n}\r\nlun = sbic_arm_read(host, SBIC_DATA) & 7;\r\nhost->scsi.reconnected.target = target;\r\nhost->scsi.reconnected.lun = lun;\r\nhost->scsi.reconnected.tag = 0;\r\nif (host->scsi.disconnectable && host->SCpnt &&\r\nhost->SCpnt->device->id == target && host->SCpnt->device->lun == lun)\r\nok = 1;\r\nif (!ok && queue_probetgtlun(&host->queues.disconnected, target, lun))\r\nok = 1;\r\nADD_STATUS(target, 0x81, host->scsi.phase, 0);\r\nif (ok) {\r\nhost->scsi.phase = PHASE_RECONNECTED;\r\n} else {\r\nprintk(KERN_ERR "scsi%d.%c: reselected with no command "\r\n"to reconnect with\n",\r\nhost->host->host_no, '0' + target);\r\nacornscsi_dumplog(host, target);\r\nacornscsi_abortcmd(host, 0);\r\nif (host->SCpnt) {\r\nqueue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);\r\nhost->SCpnt = NULL;\r\n}\r\n}\r\nacornscsi_sbic_issuecmd(host, CMND_NEGATEACK);\r\nreturn !ok;\r\n}\r\nstatic\r\nint acornscsi_reconnect_finish(AS_Host *host)\r\n{\r\nif (host->scsi.disconnectable && host->SCpnt) {\r\nhost->scsi.disconnectable = 0;\r\nif (host->SCpnt->device->id == host->scsi.reconnected.target &&\r\nhost->SCpnt->device->lun == host->scsi.reconnected.lun &&\r\nhost->SCpnt->tag == host->scsi.reconnected.tag) {\r\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\r\nDBG(host->SCpnt, printk("scsi%d.%c: reconnected",\r\nhost->host->host_no, acornscsi_target(host)));\r\n#endif\r\n} else {\r\nqueue_add_cmd_tail(&host->queues.disconnected, host->SCpnt);\r\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\r\nDBG(host->SCpnt, printk("scsi%d.%c: had to move command "\r\n"to disconnected queue\n",\r\nhost->host->host_no, acornscsi_target(host)));\r\n#endif\r\nhost->SCpnt = NULL;\r\n}\r\n}\r\nif (!host->SCpnt) {\r\nhost->SCpnt = queue_remove_tgtluntag(&host->queues.disconnected,\r\nhost->scsi.reconnected.target,\r\nhost->scsi.reconnected.lun,\r\nhost->scsi.reconnected.tag);\r\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\r\nDBG(host->SCpnt, printk("scsi%d.%c: had to get command",\r\nhost->host->host_no, acornscsi_target(host)));\r\n#endif\r\n}\r\nif (!host->SCpnt)\r\nacornscsi_abortcmd(host, host->scsi.reconnected.tag);\r\nelse {\r\nhost->scsi.SCp = host->SCpnt->SCp;\r\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\r\nprintk(", data pointers: [%p, %X]",\r\nhost->scsi.SCp.ptr, host->scsi.SCp.this_residual);\r\n#endif\r\n}\r\n#if (DEBUG & (DEBUG_QUEUES|DEBUG_DISCON))\r\nprintk("\n");\r\n#endif\r\nhost->dma.transferred = host->scsi.SCp.scsi_xferred;\r\nreturn host->SCpnt != NULL;\r\n}\r\nstatic\r\nvoid acornscsi_disconnect_unexpected(AS_Host *host)\r\n{\r\nprintk(KERN_ERR "scsi%d.%c: unexpected disconnect\n",\r\nhost->host->host_no, acornscsi_target(host));\r\n#if (DEBUG & DEBUG_ABORT)\r\nacornscsi_dumplog(host, 8);\r\n#endif\r\nacornscsi_done(host, &host->SCpnt, DID_ERROR);\r\n}\r\nstatic\r\nvoid acornscsi_abortcmd(AS_Host *host, unsigned char tag)\r\n{\r\nhost->scsi.phase = PHASE_ABORTED;\r\nsbic_arm_write(host, SBIC_CMND, CMND_ASSERTATN);\r\nmsgqueue_flush(&host->scsi.msgs);\r\n#ifdef CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE\r\nif (tag)\r\nmsgqueue_addmsg(&host->scsi.msgs, 2, ABORT_TAG, tag);\r\nelse\r\n#endif\r\nmsgqueue_addmsg(&host->scsi.msgs, 1, ABORT);\r\n}\r\nstatic\r\nintr_ret_t acornscsi_sbicintr(AS_Host *host, int in_irq)\r\n{\r\nunsigned int asr, ssr;\r\nasr = sbic_arm_read(host, SBIC_ASR);\r\nif (!(asr & ASR_INT))\r\nreturn INTR_IDLE;\r\nssr = sbic_arm_read(host, SBIC_SSR);\r\n#if (DEBUG & DEBUG_PHASES)\r\nprint_sbic_status(asr, ssr, host->scsi.phase);\r\n#endif\r\nADD_STATUS(8, ssr, host->scsi.phase, in_irq);\r\nif (host->SCpnt && !host->scsi.disconnectable)\r\nADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, in_irq);\r\nswitch (ssr) {\r\ncase 0x00:\r\nprintk(KERN_ERR "scsi%d: reset in standard mode but wanted advanced mode.\n",\r\nhost->host->host_no);\r\nsbic_arm_write(host, SBIC_OWNID, OWNID_EAF | host->host->this_id);\r\nsbic_arm_write(host, SBIC_CMND, CMND_RESET);\r\nreturn INTR_IDLE;\r\ncase 0x01:\r\nsbic_arm_write(host, SBIC_CTRL, INIT_SBICDMA | CTRL_IDI);\r\nsbic_arm_write(host, SBIC_TIMEOUT, TIMEOUT_TIME);\r\nsbic_arm_write(host, SBIC_SYNCHTRANSFER, SYNCHTRANSFER_2DBA);\r\nsbic_arm_write(host, SBIC_SOURCEID, SOURCEID_ER | SOURCEID_DSP);\r\nmsgqueue_flush(&host->scsi.msgs);\r\nreturn INTR_IDLE;\r\ncase 0x41:\r\nacornscsi_disconnect_unexpected(host);\r\nreturn INTR_NEXT_COMMAND;\r\n}\r\nswitch (host->scsi.phase) {\r\ncase PHASE_CONNECTING:\r\nswitch (ssr) {\r\ncase 0x11:\r\nhost->scsi.phase = PHASE_CONNECTED;\r\nmsgqueue_flush(&host->scsi.msgs);\r\nhost->dma.transferred = host->scsi.SCp.scsi_xferred;\r\nasr = sbic_arm_read(host, SBIC_ASR);\r\nif (!(asr & ASR_INT))\r\nbreak;\r\nssr = sbic_arm_read(host, SBIC_SSR);\r\nADD_STATUS(8, ssr, host->scsi.phase, 1);\r\nADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, 1);\r\ngoto connected;\r\ncase 0x42:\r\nacornscsi_done(host, &host->SCpnt, DID_NO_CONNECT);\r\nreturn INTR_NEXT_COMMAND;\r\ncase 0x81:\r\nhost->origSCpnt = host->SCpnt;\r\nhost->SCpnt = NULL;\r\nmsgqueue_flush(&host->scsi.msgs);\r\nacornscsi_reconnect(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_CONNECTING, SSR %02X?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\n}\r\nreturn INTR_PROCESSING;\r\nconnected:\r\ncase PHASE_CONNECTED:\r\nswitch (ssr) {\r\n#ifdef NONSTANDARD\r\ncase 0x8a:\r\nacornscsi_sendcommand(host);\r\nbreak;\r\ncase 0x8b:\r\nacornscsi_readstatusbyte(host);\r\nhost->scsi.phase = PHASE_STATUSIN;\r\nbreak;\r\n#endif\r\ncase 0x8e:\r\nhost->scsi.phase = PHASE_MSGOUT;\r\nacornscsi_buildmessages(host);\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ncase 0x85:\r\nacornscsi_done(host, &host->SCpnt, DID_ERROR);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_CONNECTED, SSR %02X?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_MSGOUT:\r\nswitch (ssr) {\r\ncase 0x8a:\r\ncase 0x1a:\r\nacornscsi_sendcommand(host);\r\nbreak;\r\ncase 0x8b:\r\ncase 0x1b:\r\nacornscsi_readstatusbyte(host);\r\nhost->scsi.phase = PHASE_STATUSIN;\r\nbreak;\r\ncase 0x8e:\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ncase 0x4f:\r\ncase 0x1f:\r\nacornscsi_message(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_MSGOUT, SSR %02X?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_COMMAND:\r\nswitch (ssr) {\r\ncase 0x18:\r\nif (host->scsi.SCp.sent_command != host->SCpnt->cmd_len)\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nacornscsi_dma_setup(host, DMA_OUT);\r\nif (!acornscsi_starttransfer(host))\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nhost->scsi.phase = PHASE_DATAOUT;\r\nreturn INTR_IDLE;\r\ncase 0x19:\r\nif (host->scsi.SCp.sent_command != host->SCpnt->cmd_len)\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nacornscsi_dma_setup(host, DMA_IN);\r\nif (!acornscsi_starttransfer(host))\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nhost->scsi.phase = PHASE_DATAIN;\r\nreturn INTR_IDLE;\r\ncase 0x1b:\r\nacornscsi_readstatusbyte(host);\r\nhost->scsi.phase = PHASE_STATUSIN;\r\nbreak;\r\ncase 0x1e:\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ncase 0x1f:\r\nacornscsi_message(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_COMMAND, SSR %02X?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_DISCONNECT:\r\nif (ssr == 0x85) {\r\nhost->scsi.disconnectable = 1;\r\nhost->scsi.reconnected.tag = 0;\r\nhost->scsi.phase = PHASE_IDLE;\r\nhost->stats.disconnects += 1;\r\n} else {\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_DISCONNECT, SSR %02X instead of disconnect?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_NEXT_COMMAND;\r\ncase PHASE_IDLE:\r\nif (ssr == 0x81)\r\nacornscsi_reconnect(host);\r\nelse {\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_IDLE, SSR %02X while idle?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_RECONNECTED:\r\nif (ssr != 0x8f && !acornscsi_reconnect_finish(host))\r\nreturn INTR_IDLE;\r\nADD_STATUS(host->SCpnt->device->id, ssr, host->scsi.phase, in_irq);\r\nswitch (ssr) {\r\ncase 0x88:\r\nacornscsi_dma_setup(host, DMA_OUT);\r\nif (!acornscsi_starttransfer(host))\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nhost->scsi.phase = PHASE_DATAOUT;\r\nreturn INTR_IDLE;\r\ncase 0x89:\r\nacornscsi_dma_setup(host, DMA_IN);\r\nif (!acornscsi_starttransfer(host))\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nhost->scsi.phase = PHASE_DATAIN;\r\nreturn INTR_IDLE;\r\ncase 0x8a:\r\nacornscsi_sendcommand(host);\r\nbreak;\r\ncase 0x8b:\r\nacornscsi_readstatusbyte(host);\r\nhost->scsi.phase = PHASE_STATUSIN;\r\nbreak;\r\ncase 0x8e:\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ncase 0x8f:\r\nacornscsi_message(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_RECONNECTED, SSR %02X after reconnect?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_DATAIN:\r\nswitch (ssr) {\r\ncase 0x19:\r\ncase 0x89:\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nreturn INTR_IDLE;\r\ncase 0x1b:\r\ncase 0x4b:\r\ncase 0x8b:\r\nhost->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\r\nacornscsi_sbic_xfcount(host);\r\nacornscsi_dma_stop(host);\r\nacornscsi_readstatusbyte(host);\r\nhost->scsi.phase = PHASE_STATUSIN;\r\nbreak;\r\ncase 0x1e:\r\ncase 0x4e:\r\ncase 0x8e:\r\nhost->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\r\nacornscsi_sbic_xfcount(host);\r\nacornscsi_dma_stop(host);\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ncase 0x1f:\r\ncase 0x4f:\r\ncase 0x8f:\r\nhost->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\r\nacornscsi_sbic_xfcount(host);\r\nacornscsi_dma_stop(host);\r\nacornscsi_message(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_DATAIN, SSR %02X?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_DATAOUT:\r\nswitch (ssr) {\r\ncase 0x18:\r\ncase 0x88:\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nreturn INTR_IDLE;\r\ncase 0x1b:\r\ncase 0x4b:\r\ncase 0x8b:\r\nhost->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\r\nacornscsi_sbic_xfcount(host);\r\nacornscsi_dma_stop(host);\r\nacornscsi_dma_adjust(host);\r\nacornscsi_readstatusbyte(host);\r\nhost->scsi.phase = PHASE_STATUSIN;\r\nbreak;\r\ncase 0x1e:\r\ncase 0x4e:\r\ncase 0x8e:\r\nhost->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\r\nacornscsi_sbic_xfcount(host);\r\nacornscsi_dma_stop(host);\r\nacornscsi_dma_adjust(host);\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ncase 0x1f:\r\ncase 0x4f:\r\ncase 0x8f:\r\nhost->scsi.SCp.scsi_xferred = scsi_bufflen(host->SCpnt) -\r\nacornscsi_sbic_xfcount(host);\r\nacornscsi_dma_stop(host);\r\nacornscsi_dma_adjust(host);\r\nacornscsi_message(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_DATAOUT, SSR %02X?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_STATUSIN:\r\nswitch (ssr) {\r\ncase 0x1f:\r\ncase 0x8f:\r\nacornscsi_message(host);\r\nbreak;\r\ncase 0x1e:\r\ncase 0x8e:\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_STATUSIN, SSR %02X instead of MESSAGE_IN?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_MSGIN:\r\nswitch (ssr) {\r\ncase 0x1e:\r\ncase 0x4e:\r\ncase 0x8e:\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ncase 0x1f:\r\ncase 0x2f:\r\ncase 0x4f:\r\ncase 0x8f:\r\nacornscsi_message(host);\r\nbreak;\r\ncase 0x85:\r\nprintk("scsi%d.%c: strange message in disconnection\n",\r\nhost->host->host_no, acornscsi_target(host));\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\nacornscsi_done(host, &host->SCpnt, DID_ERROR);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_MSGIN, SSR %02X after message in?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_DONE:\r\nswitch (ssr) {\r\ncase 0x85:\r\nacornscsi_done(host, &host->SCpnt, DID_OK);\r\nreturn INTR_NEXT_COMMAND;\r\ncase 0x1e:\r\ncase 0x8e:\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_DONE, SSR %02X instead of disconnect?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ncase PHASE_ABORTED:\r\nswitch (ssr) {\r\ncase 0x85:\r\nif (host->SCpnt)\r\nacornscsi_done(host, &host->SCpnt, DID_ABORT);\r\nelse {\r\nclear_bit(host->scsi.reconnected.target * 8 + host->scsi.reconnected.lun,\r\nhost->busyluns);\r\nhost->scsi.phase = PHASE_IDLE;\r\n}\r\nreturn INTR_NEXT_COMMAND;\r\ncase 0x1e:\r\ncase 0x2e:\r\ncase 0x4e:\r\ncase 0x8e:\r\nacornscsi_sendmessage(host);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: PHASE_ABORTED, SSR %02X?\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: unknown driver phase %d\n",\r\nhost->host->host_no, acornscsi_target(host), ssr);\r\nacornscsi_dumplog(host, host->SCpnt ? host->SCpnt->device->id : 8);\r\n}\r\nreturn INTR_PROCESSING;\r\n}\r\nstatic irqreturn_t\r\nacornscsi_intr(int irq, void *dev_id)\r\n{\r\nAS_Host *host = (AS_Host *)dev_id;\r\nintr_ret_t ret;\r\nint iostatus;\r\nint in_irq = 0;\r\ndo {\r\nret = INTR_IDLE;\r\niostatus = readb(host->fast + INT_REG);\r\nif (iostatus & 2) {\r\nacornscsi_dma_intr(host);\r\niostatus = readb(host->fast + INT_REG);\r\n}\r\nif (iostatus & 8)\r\nret = acornscsi_sbicintr(host, in_irq);\r\nif (host->dma.xfer_required)\r\nacornscsi_dma_xfer(host);\r\nif (ret == INTR_NEXT_COMMAND)\r\nret = acornscsi_kick(host);\r\nin_irq = 1;\r\n} while (ret != INTR_IDLE);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int acornscsi_queuecmd_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nAS_Host *host = (AS_Host *)SCpnt->device->host->hostdata;\r\nif (!done) {\r\npanic("scsi%d: queuecommand called with NULL done function [cmd=%p]",\r\nhost->host->host_no, SCpnt);\r\nreturn -EINVAL;\r\n}\r\n#if (DEBUG & DEBUG_NO_WRITE)\r\nif (acornscsi_cmdtype(SCpnt->cmnd[0]) == CMD_WRITE && (NO_WRITE & (1 << SCpnt->device->id))) {\r\nprintk(KERN_CRIT "scsi%d.%c: WRITE attempted with NO_WRITE flag set\n",\r\nhost->host->host_no, '0' + SCpnt->device->id);\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\n#endif\r\nSCpnt->scsi_done = done;\r\nSCpnt->host_scribble = NULL;\r\nSCpnt->result = 0;\r\nSCpnt->tag = 0;\r\nSCpnt->SCp.phase = (int)acornscsi_datadirection(SCpnt->cmnd[0]);\r\nSCpnt->SCp.sent_command = 0;\r\nSCpnt->SCp.scsi_xferred = 0;\r\ninit_SCp(SCpnt);\r\nhost->stats.queues += 1;\r\n{\r\nunsigned long flags;\r\nif (!queue_add_cmd_ordered(&host->queues.issue, SCpnt)) {\r\nSCpnt->result = DID_ERROR << 16;\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\nlocal_irq_save(flags);\r\nif (host->scsi.phase == PHASE_IDLE)\r\nacornscsi_kick(host);\r\nlocal_irq_restore(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void acornscsi_reportstatus(struct scsi_cmnd **SCpntp1,\r\nstruct scsi_cmnd **SCpntp2,\r\nint result)\r\n{\r\nstruct scsi_cmnd *SCpnt = *SCpntp1;\r\nif (SCpnt) {\r\n*SCpntp1 = NULL;\r\nSCpnt->result = result;\r\nSCpnt->scsi_done(SCpnt);\r\n}\r\nif (SCpnt == *SCpntp2)\r\n*SCpntp2 = NULL;\r\n}\r\nstatic enum res_abort acornscsi_do_abort(AS_Host *host, struct scsi_cmnd *SCpnt)\r\n{\r\nenum res_abort res = res_not_running;\r\nif (queue_remove_cmd(&host->queues.issue, SCpnt)) {\r\nprintk("on issue queue ");\r\nres = res_success;\r\n} else if (queue_remove_cmd(&host->queues.disconnected, SCpnt)) {\r\nprintk("on disconnected queue ");\r\nres = res_success;\r\n} else if (host->SCpnt == SCpnt) {\r\nunsigned long flags;\r\nprintk("executing ");\r\nlocal_irq_save(flags);\r\nswitch (host->scsi.phase) {\r\ncase PHASE_IDLE:\r\nif (host->scsi.disconnectable) {\r\nhost->scsi.disconnectable = 0;\r\nhost->SCpnt = NULL;\r\nres = res_success;\r\n}\r\nbreak;\r\ncase PHASE_CONNECTED:\r\nsbic_arm_write(host, SBIC_CMND, CMND_DISCONNECT);\r\nhost->SCpnt = NULL;\r\nres = res_success_clear;\r\nbreak;\r\ndefault:\r\nacornscsi_abortcmd(host, host->SCpnt->tag);\r\nres = res_snooze;\r\n}\r\nlocal_irq_restore(flags);\r\n} else if (host->origSCpnt == SCpnt) {\r\nhost->origSCpnt = NULL;\r\nprintk("waiting for execution ");\r\nres = res_success_clear;\r\n} else\r\nprintk("unknown ");\r\nreturn res;\r\n}\r\nint acornscsi_abort(struct scsi_cmnd *SCpnt)\r\n{\r\nAS_Host *host = (AS_Host *) SCpnt->device->host->hostdata;\r\nint result;\r\nhost->stats.aborts += 1;\r\n#if (DEBUG & DEBUG_ABORT)\r\n{\r\nint asr, ssr;\r\nasr = sbic_arm_read(host, SBIC_ASR);\r\nssr = sbic_arm_read(host, SBIC_SSR);\r\nprintk(KERN_WARNING "acornscsi_abort: ");\r\nprint_sbic_status(asr, ssr, host->scsi.phase);\r\nacornscsi_dumplog(host, SCpnt->device->id);\r\n}\r\n#endif\r\nprintk("scsi%d: ", host->host->host_no);\r\nswitch (acornscsi_do_abort(host, SCpnt)) {\r\ncase res_success_clear:\r\nprintk("clear ");\r\nclear_bit(SCpnt->device->id * 8 +\r\n(u8)(SCpnt->device->lun & 0x7), host->busyluns);\r\ncase res_success:\r\nprintk("success\n");\r\nresult = SUCCESS;\r\nbreak;\r\ncase res_snooze:\r\nprintk("snooze\n");\r\nresult = FAILED;\r\nbreak;\r\ndefault:\r\ncase res_not_running:\r\nacornscsi_dumplog(host, SCpnt->device->id);\r\nresult = FAILED;\r\nprintk("not running\n");\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nint acornscsi_bus_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nAS_Host *host = (AS_Host *)SCpnt->device->host->hostdata;\r\nstruct scsi_cmnd *SCptr;\r\nhost->stats.resets += 1;\r\n#if (DEBUG & DEBUG_RESET)\r\n{\r\nint asr, ssr;\r\nasr = sbic_arm_read(host, SBIC_ASR);\r\nssr = sbic_arm_read(host, SBIC_SSR);\r\nprintk(KERN_WARNING "acornscsi_reset: ");\r\nprint_sbic_status(asr, ssr, host->scsi.phase);\r\nacornscsi_dumplog(host, SCpnt->device->id);\r\n}\r\n#endif\r\nacornscsi_dma_stop(host);\r\nacornscsi_resetcard(host);\r\nwhile ((SCptr = queue_remove(&host->queues.disconnected)) != NULL)\r\n;\r\nreturn SUCCESS;\r\n}\r\nconst\r\nchar *acornscsi_info(struct Scsi_Host *host)\r\n{\r\nstatic char string[100], *p;\r\np = string;\r\np += sprintf(string, "%s at port %08lX irq %d v%d.%d.%d"\r\n#ifdef CONFIG_SCSI_ACORNSCSI_SYNC\r\n" SYNC"\r\n#endif\r\n#ifdef CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE\r\n" TAG"\r\n#endif\r\n#if (DEBUG & DEBUG_NO_WRITE)\r\n" NOWRITE (" __stringify(NO_WRITE) ")"\r\n#endif\r\n, host->hostt->name, host->io_port, host->irq,\r\nVER_MAJOR, VER_MINOR, VER_PATCH);\r\nreturn string;\r\n}\r\nstatic int acornscsi_show_info(struct seq_file *m, struct Scsi_Host *instance)\r\n{\r\nint devidx;\r\nstruct scsi_device *scd;\r\nAS_Host *host;\r\nhost = (AS_Host *)instance->hostdata;\r\nseq_printf(m, "AcornSCSI driver v%d.%d.%d"\r\n#ifdef CONFIG_SCSI_ACORNSCSI_SYNC\r\n" SYNC"\r\n#endif\r\n#ifdef CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE\r\n" TAG"\r\n#endif\r\n#if (DEBUG & DEBUG_NO_WRITE)\r\n" NOWRITE (" __stringify(NO_WRITE) ")"\r\n#endif\r\n"\n\n", VER_MAJOR, VER_MINOR, VER_PATCH);\r\nseq_printf(m, "SBIC: WD33C93A Address: %p IRQ : %d\n",\r\nhost->base + SBIC_REGIDX, host->scsi.irq);\r\n#ifdef USE_DMAC\r\nseq_printf(m, "DMAC: uPC71071 Address: %p IRQ : %d\n\n",\r\nhost->base + DMAC_OFFSET, host->scsi.irq);\r\n#endif\r\nseq_printf(m, "Statistics:\n"\r\n"Queued commands: %-10u Issued commands: %-10u\n"\r\n"Done commands : %-10u Reads : %-10u\n"\r\n"Writes : %-10u Others : %-10u\n"\r\n"Disconnects : %-10u Aborts : %-10u\n"\r\n"Resets : %-10u\n\nLast phases:",\r\nhost->stats.queues, host->stats.removes,\r\nhost->stats.fins, host->stats.reads,\r\nhost->stats.writes, host->stats.miscs,\r\nhost->stats.disconnects, host->stats.aborts,\r\nhost->stats.resets);\r\nfor (devidx = 0; devidx < 9; devidx ++) {\r\nunsigned int statptr, prev;\r\nseq_printf(m, "\n%c:", devidx == 8 ? 'H' : ('0' + devidx));\r\nstatptr = host->status_ptr[devidx] - 10;\r\nif ((signed int)statptr < 0)\r\nstatptr += STATUS_BUFFER_SIZE;\r\nprev = host->status[devidx][statptr].when;\r\nfor (; statptr != host->status_ptr[devidx]; statptr = (statptr + 1) & (STATUS_BUFFER_SIZE - 1)) {\r\nif (host->status[devidx][statptr].when) {\r\nseq_printf(m, "%c%02X:%02X+%2ld",\r\nhost->status[devidx][statptr].irq ? '-' : ' ',\r\nhost->status[devidx][statptr].ph,\r\nhost->status[devidx][statptr].ssr,\r\n(host->status[devidx][statptr].when - prev) < 100 ?\r\n(host->status[devidx][statptr].when - prev) : 99);\r\nprev = host->status[devidx][statptr].when;\r\n}\r\n}\r\n}\r\nseq_printf(m, "\nAttached devices:\n");\r\nshost_for_each_device(scd, instance) {\r\nseq_printf(m, "Device/Lun TaggedQ Sync\n");\r\nseq_printf(m, " %d/%llu ", scd->id, scd->lun);\r\nif (scd->tagged_supported)\r\nseq_printf(m, "%3sabled(%3d) ",\r\nscd->simple_tags ? "en" : "dis",\r\nscd->current_tag);\r\nelse\r\nseq_printf(m, "unsupported ");\r\nif (host->device[scd->id].sync_xfer & 15)\r\nseq_printf(m, "offset %d, %d ns\n",\r\nhost->device[scd->id].sync_xfer & 15,\r\nacornscsi_getperiod(host->device[scd->id].sync_xfer));\r\nelse\r\nseq_printf(m, "async\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int acornscsi_probe(struct expansion_card *ec, const struct ecard_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nAS_Host *ashost;\r\nint ret;\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\nhost = scsi_host_alloc(&acornscsi_template, sizeof(AS_Host));\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto out_release;\r\n}\r\nashost = (AS_Host *)host->hostdata;\r\nashost->base = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);\r\nashost->fast = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\r\nif (!ashost->base || !ashost->fast)\r\ngoto out_put;\r\nhost->irq = ec->irq;\r\nashost->host = host;\r\nashost->scsi.irq = host->irq;\r\nec->irqaddr = ashost->fast + INT_REG;\r\nec->irqmask = 0x0a;\r\nret = request_irq(host->irq, acornscsi_intr, 0, "acornscsi", ashost);\r\nif (ret) {\r\nprintk(KERN_CRIT "scsi%d: IRQ%d not free: %d\n",\r\nhost->host_no, ashost->scsi.irq, ret);\r\ngoto out_put;\r\n}\r\nmemset(&ashost->stats, 0, sizeof (ashost->stats));\r\nqueue_initialise(&ashost->queues.issue);\r\nqueue_initialise(&ashost->queues.disconnected);\r\nmsgqueue_initialise(&ashost->scsi.msgs);\r\nacornscsi_resetcard(ashost);\r\nret = scsi_add_host(host, &ec->dev);\r\nif (ret)\r\ngoto out_irq;\r\nscsi_scan_host(host);\r\ngoto out;\r\nout_irq:\r\nfree_irq(host->irq, ashost);\r\nmsgqueue_free(&ashost->scsi.msgs);\r\nqueue_free(&ashost->queues.disconnected);\r\nqueue_free(&ashost->queues.issue);\r\nout_put:\r\necardm_iounmap(ec, ashost->fast);\r\necardm_iounmap(ec, ashost->base);\r\nscsi_host_put(host);\r\nout_release:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void acornscsi_remove(struct expansion_card *ec)\r\n{\r\nstruct Scsi_Host *host = ecard_get_drvdata(ec);\r\nAS_Host *ashost = (AS_Host *)host->hostdata;\r\necard_set_drvdata(ec, NULL);\r\nscsi_remove_host(host);\r\nwriteb(0x80, ashost->fast + PAGE_REG);\r\nfree_irq(host->irq, ashost);\r\nmsgqueue_free(&ashost->scsi.msgs);\r\nqueue_free(&ashost->queues.disconnected);\r\nqueue_free(&ashost->queues.issue);\r\necardm_iounmap(ec, ashost->fast);\r\necardm_iounmap(ec, ashost->base);\r\nscsi_host_put(host);\r\necard_release_resources(ec);\r\n}\r\nstatic int __init acornscsi_init(void)\r\n{\r\nreturn ecard_register_driver(&acornscsi_driver);\r\n}\r\nstatic void __exit acornscsi_exit(void)\r\n{\r\necard_remove_driver(&acornscsi_driver);\r\n}
