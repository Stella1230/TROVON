static ssize_t show_label(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nstruct temp_data *tdata = pdata->core_data[attr->index];\r\nif (tdata->is_pkg_data)\r\nreturn sprintf(buf, "Physical id %u\n", pdata->phys_proc_id);\r\nreturn sprintf(buf, "Core %u\n", tdata->cpu_core_id);\r\n}\r\nstatic ssize_t show_crit_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nu32 eax, edx;\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nstruct temp_data *tdata = pdata->core_data[attr->index];\r\nrdmsr_on_cpu(tdata->cpu, tdata->status_reg, &eax, &edx);\r\nreturn sprintf(buf, "%d\n", (eax >> 5) & 1);\r\n}\r\nstatic ssize_t show_tjmax(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", pdata->core_data[attr->index]->tjmax);\r\n}\r\nstatic ssize_t show_ttarget(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", pdata->core_data[attr->index]->ttarget);\r\n}\r\nstatic ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nu32 eax, edx;\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nstruct temp_data *tdata = pdata->core_data[attr->index];\r\nmutex_lock(&tdata->update_lock);\r\nif (!tdata->valid || time_after(jiffies, tdata->last_updated + HZ)) {\r\nrdmsr_on_cpu(tdata->cpu, tdata->status_reg, &eax, &edx);\r\ntdata->temp = tdata->tjmax - ((eax >> 16) & 0x7f) * 1000;\r\ntdata->valid = 1;\r\ntdata->last_updated = jiffies;\r\n}\r\nmutex_unlock(&tdata->update_lock);\r\nreturn sprintf(buf, "%d\n", tdata->temp);\r\n}\r\nstatic int adjust_tjmax(struct cpuinfo_x86 *c, u32 id, struct device *dev)\r\n{\r\nint tjmax = 100000;\r\nint tjmax_ee = 85000;\r\nint usemsr_ee = 1;\r\nint err;\r\nu32 eax, edx;\r\nint i;\r\nstruct pci_dev *host_bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));\r\nif (host_bridge && host_bridge->vendor == PCI_VENDOR_ID_INTEL) {\r\nfor (i = 0; i < ARRAY_SIZE(tjmax_pci_table); i++) {\r\nif (host_bridge->device == tjmax_pci_table[i].device)\r\nreturn tjmax_pci_table[i].tjmax;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tjmax_table); i++) {\r\nif (strstr(c->x86_model_id, tjmax_table[i].id))\r\nreturn tjmax_table[i].tjmax;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tjmax_model_table); i++) {\r\nconst struct tjmax_model *tm = &tjmax_model_table[i];\r\nif (c->x86_model == tm->model &&\r\n(tm->mask == ANY || c->x86_mask == tm->mask))\r\nreturn tm->tjmax;\r\n}\r\nif (c->x86_model == 0xf && c->x86_mask < 4)\r\nusemsr_ee = 0;\r\nif (c->x86_model > 0xe && usemsr_ee) {\r\nu8 platform_id;\r\nerr = rdmsr_safe_on_cpu(id, 0x17, &eax, &edx);\r\nif (err) {\r\ndev_warn(dev,\r\n"Unable to access MSR 0x17, assuming desktop"\r\n" CPU\n");\r\nusemsr_ee = 0;\r\n} else if (c->x86_model < 0x17 && !(eax & 0x10000000)) {\r\nusemsr_ee = 0;\r\n} else {\r\nplatform_id = (edx >> 18) & 0x7;\r\nif (c->x86_model == 0x17 &&\r\n(platform_id == 5 || platform_id == 7)) {\r\ntjmax_ee = 90000;\r\ntjmax = 105000;\r\n}\r\n}\r\n}\r\nif (usemsr_ee) {\r\nerr = rdmsr_safe_on_cpu(id, 0xee, &eax, &edx);\r\nif (err) {\r\ndev_warn(dev,\r\n"Unable to access MSR 0xEE, for Tjmax, left"\r\n" at default\n");\r\n} else if (eax & 0x40000000) {\r\ntjmax = tjmax_ee;\r\n}\r\n} else if (tjmax == 100000) {\r\ndev_warn(dev, "Using relative temperature scale!\n");\r\n}\r\nreturn tjmax;\r\n}\r\nstatic bool cpu_has_tjmax(struct cpuinfo_x86 *c)\r\n{\r\nu8 model = c->x86_model;\r\nreturn model > 0xe &&\r\nmodel != 0x1c &&\r\nmodel != 0x26 &&\r\nmodel != 0x27 &&\r\nmodel != 0x35 &&\r\nmodel != 0x36;\r\n}\r\nstatic int get_tjmax(struct cpuinfo_x86 *c, u32 id, struct device *dev)\r\n{\r\nint err;\r\nu32 eax, edx;\r\nu32 val;\r\nerr = rdmsr_safe_on_cpu(id, MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\r\nif (err) {\r\nif (cpu_has_tjmax(c))\r\ndev_warn(dev, "Unable to read TjMax from CPU %u\n", id);\r\n} else {\r\nval = (eax >> 16) & 0xff;\r\nif (val) {\r\ndev_dbg(dev, "TjMax is %d degrees C\n", val);\r\nreturn val * 1000;\r\n}\r\n}\r\nif (force_tjmax) {\r\ndev_notice(dev, "TjMax forced to %d degrees C by user\n",\r\nforce_tjmax);\r\nreturn force_tjmax * 1000;\r\n}\r\nreturn adjust_tjmax(c, id, dev);\r\n}\r\nstatic int create_core_attrs(struct temp_data *tdata, struct device *dev,\r\nint attr_no)\r\n{\r\nint i;\r\nstatic ssize_t (*const rd_ptr[TOTAL_ATTRS]) (struct device *dev,\r\nstruct device_attribute *devattr, char *buf) = {\r\nshow_label, show_crit_alarm, show_temp, show_tjmax,\r\nshow_ttarget };\r\nstatic const char *const names[TOTAL_ATTRS] = {\r\n"temp%d_label", "temp%d_crit_alarm",\r\n"temp%d_input", "temp%d_crit",\r\n"temp%d_max" };\r\nfor (i = 0; i < tdata->attr_size; i++) {\r\nsnprintf(tdata->attr_name[i], CORETEMP_NAME_LENGTH, names[i],\r\nattr_no);\r\nsysfs_attr_init(&tdata->sd_attrs[i].dev_attr.attr);\r\ntdata->sd_attrs[i].dev_attr.attr.name = tdata->attr_name[i];\r\ntdata->sd_attrs[i].dev_attr.attr.mode = S_IRUGO;\r\ntdata->sd_attrs[i].dev_attr.show = rd_ptr[i];\r\ntdata->sd_attrs[i].index = attr_no;\r\ntdata->attrs[i] = &tdata->sd_attrs[i].dev_attr.attr;\r\n}\r\ntdata->attr_group.attrs = tdata->attrs;\r\nreturn sysfs_create_group(&dev->kobj, &tdata->attr_group);\r\n}\r\nstatic int chk_ucode_version(unsigned int cpu)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nif (c->x86_model == 0xe && c->x86_mask < 0xc && c->microcode < 0x39) {\r\npr_err("Errata AE18 not fixed, update BIOS or microcode of the CPU!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct platform_device *coretemp_get_pdev(unsigned int cpu)\r\n{\r\nu16 phys_proc_id = TO_PHYS_ID(cpu);\r\nstruct pdev_entry *p;\r\nmutex_lock(&pdev_list_mutex);\r\nlist_for_each_entry(p, &pdev_list, list)\r\nif (p->phys_proc_id == phys_proc_id) {\r\nmutex_unlock(&pdev_list_mutex);\r\nreturn p->pdev;\r\n}\r\nmutex_unlock(&pdev_list_mutex);\r\nreturn NULL;\r\n}\r\nstatic struct temp_data *init_temp_data(unsigned int cpu, int pkg_flag)\r\n{\r\nstruct temp_data *tdata;\r\ntdata = kzalloc(sizeof(struct temp_data), GFP_KERNEL);\r\nif (!tdata)\r\nreturn NULL;\r\ntdata->status_reg = pkg_flag ? MSR_IA32_PACKAGE_THERM_STATUS :\r\nMSR_IA32_THERM_STATUS;\r\ntdata->is_pkg_data = pkg_flag;\r\ntdata->cpu = cpu;\r\ntdata->cpu_core_id = TO_CORE_ID(cpu);\r\ntdata->attr_size = MAX_CORE_ATTRS;\r\nmutex_init(&tdata->update_lock);\r\nreturn tdata;\r\n}\r\nstatic int create_core_data(struct platform_device *pdev, unsigned int cpu,\r\nint pkg_flag)\r\n{\r\nstruct temp_data *tdata;\r\nstruct platform_data *pdata = platform_get_drvdata(pdev);\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nu32 eax, edx;\r\nint err, attr_no;\r\nattr_no = pkg_flag ? 1 : TO_ATTR_NO(cpu);\r\nif (attr_no > MAX_CORE_DATA - 1)\r\nreturn -ERANGE;\r\nif (pdata->core_data[attr_no] != NULL)\r\nreturn 0;\r\ntdata = init_temp_data(cpu, pkg_flag);\r\nif (!tdata)\r\nreturn -ENOMEM;\r\nerr = rdmsr_safe_on_cpu(cpu, tdata->status_reg, &eax, &edx);\r\nif (err)\r\ngoto exit_free;\r\ntdata->tjmax = get_tjmax(c, cpu, &pdev->dev);\r\nif (c->x86_model > 0xe && c->x86_model != 0x1c) {\r\nerr = rdmsr_safe_on_cpu(cpu, MSR_IA32_TEMPERATURE_TARGET,\r\n&eax, &edx);\r\nif (!err) {\r\ntdata->ttarget\r\n= tdata->tjmax - ((eax >> 8) & 0xff) * 1000;\r\ntdata->attr_size++;\r\n}\r\n}\r\npdata->core_data[attr_no] = tdata;\r\nerr = create_core_attrs(tdata, pdata->hwmon_dev, attr_no);\r\nif (err)\r\ngoto exit_free;\r\nreturn 0;\r\nexit_free:\r\npdata->core_data[attr_no] = NULL;\r\nkfree(tdata);\r\nreturn err;\r\n}\r\nstatic void coretemp_add_core(unsigned int cpu, int pkg_flag)\r\n{\r\nstruct platform_device *pdev = coretemp_get_pdev(cpu);\r\nint err;\r\nif (!pdev)\r\nreturn;\r\nerr = create_core_data(pdev, cpu, pkg_flag);\r\nif (err)\r\ndev_err(&pdev->dev, "Adding Core %u failed\n", cpu);\r\n}\r\nstatic void coretemp_remove_core(struct platform_data *pdata,\r\nint indx)\r\n{\r\nstruct temp_data *tdata = pdata->core_data[indx];\r\nsysfs_remove_group(&pdata->hwmon_dev->kobj, &tdata->attr_group);\r\nkfree(pdata->core_data[indx]);\r\npdata->core_data[indx] = NULL;\r\n}\r\nstatic int coretemp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct platform_data *pdata;\r\npdata = devm_kzalloc(dev, sizeof(struct platform_data), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->phys_proc_id = pdev->id;\r\nplatform_set_drvdata(pdev, pdata);\r\npdata->hwmon_dev = devm_hwmon_device_register_with_groups(dev, DRVNAME,\r\npdata, NULL);\r\nreturn PTR_ERR_OR_ZERO(pdata->hwmon_dev);\r\n}\r\nstatic int coretemp_remove(struct platform_device *pdev)\r\n{\r\nstruct platform_data *pdata = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = MAX_CORE_DATA - 1; i >= 0; --i)\r\nif (pdata->core_data[i])\r\ncoretemp_remove_core(pdata, i);\r\nreturn 0;\r\n}\r\nstatic int coretemp_device_add(unsigned int cpu)\r\n{\r\nint err;\r\nstruct platform_device *pdev;\r\nstruct pdev_entry *pdev_entry;\r\nmutex_lock(&pdev_list_mutex);\r\npdev = platform_device_alloc(DRVNAME, TO_PHYS_ID(cpu));\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit;\r\n}\r\npdev_entry = kzalloc(sizeof(struct pdev_entry), GFP_KERNEL);\r\nif (!pdev_entry) {\r\nerr = -ENOMEM;\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_free;\r\n}\r\npdev_entry->pdev = pdev;\r\npdev_entry->phys_proc_id = pdev->id;\r\nlist_add_tail(&pdev_entry->list, &pdev_list);\r\nmutex_unlock(&pdev_list_mutex);\r\nreturn 0;\r\nexit_device_free:\r\nkfree(pdev_entry);\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\nmutex_unlock(&pdev_list_mutex);\r\nreturn err;\r\n}\r\nstatic void coretemp_device_remove(unsigned int cpu)\r\n{\r\nstruct pdev_entry *p, *n;\r\nu16 phys_proc_id = TO_PHYS_ID(cpu);\r\nmutex_lock(&pdev_list_mutex);\r\nlist_for_each_entry_safe(p, n, &pdev_list, list) {\r\nif (p->phys_proc_id != phys_proc_id)\r\ncontinue;\r\nplatform_device_unregister(p->pdev);\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\nmutex_unlock(&pdev_list_mutex);\r\n}\r\nstatic bool is_any_core_online(struct platform_data *pdata)\r\n{\r\nint i;\r\nfor (i = MAX_CORE_DATA - 1; i >= 0; --i) {\r\nif (pdata->core_data[i] &&\r\n!pdata->core_data[i]->is_pkg_data) {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void get_core_online(unsigned int cpu)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nstruct platform_device *pdev = coretemp_get_pdev(cpu);\r\nint err;\r\nif (!cpu_has(c, X86_FEATURE_DTHERM))\r\nreturn;\r\nif (!pdev) {\r\nif (chk_ucode_version(cpu))\r\nreturn;\r\nerr = coretemp_device_add(cpu);\r\nif (err)\r\nreturn;\r\nif (cpu_has(c, X86_FEATURE_PTS))\r\ncoretemp_add_core(cpu, 1);\r\n}\r\ncoretemp_add_core(cpu, 0);\r\n}\r\nstatic void put_core_offline(unsigned int cpu)\r\n{\r\nint i, indx;\r\nstruct platform_data *pdata;\r\nstruct platform_device *pdev = coretemp_get_pdev(cpu);\r\nif (!pdev)\r\nreturn;\r\npdata = platform_get_drvdata(pdev);\r\nindx = TO_ATTR_NO(cpu);\r\nif (indx > MAX_CORE_DATA - 1)\r\nreturn;\r\nif (pdata->core_data[indx] && pdata->core_data[indx]->cpu == cpu)\r\ncoretemp_remove_core(pdata, indx);\r\nfor_each_sibling(i, cpu) {\r\nif (i != cpu) {\r\nget_core_online(i);\r\nbreak;\r\n}\r\n}\r\nif (!is_any_core_online(pdata))\r\ncoretemp_device_remove(cpu);\r\n}\r\nstatic int coretemp_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long) hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_DOWN_FAILED:\r\nget_core_online(cpu);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\nput_core_offline(cpu);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init coretemp_init(void)\r\n{\r\nint i, err;\r\nif (!x86_match_cpu(coretemp_ids))\r\nreturn -ENODEV;\r\nerr = platform_driver_register(&coretemp_driver);\r\nif (err)\r\ngoto exit;\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(i)\r\nget_core_online(i);\r\n#ifndef CONFIG_HOTPLUG_CPU\r\nif (list_empty(&pdev_list)) {\r\ncpu_notifier_register_done();\r\nerr = -ENODEV;\r\ngoto exit_driver_unreg;\r\n}\r\n#endif\r\n__register_hotcpu_notifier(&coretemp_cpu_notifier);\r\ncpu_notifier_register_done();\r\nreturn 0;\r\n#ifndef CONFIG_HOTPLUG_CPU\r\nexit_driver_unreg:\r\nplatform_driver_unregister(&coretemp_driver);\r\n#endif\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __exit coretemp_exit(void)\r\n{\r\nstruct pdev_entry *p, *n;\r\ncpu_notifier_register_begin();\r\n__unregister_hotcpu_notifier(&coretemp_cpu_notifier);\r\nmutex_lock(&pdev_list_mutex);\r\nlist_for_each_entry_safe(p, n, &pdev_list, list) {\r\nplatform_device_unregister(p->pdev);\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\nmutex_unlock(&pdev_list_mutex);\r\ncpu_notifier_register_done();\r\nplatform_driver_unregister(&coretemp_driver);\r\n}
