static int ap_is_existing_file(char *pathname)\r\n{\r\n#ifndef _GNU_EFI\r\nstruct stat stat_info;\r\nif (!stat(pathname, &stat_info)) {\r\nacpi_log_error("Target path already exists, overwrite? [y|n] ");\r\nif (getchar() != 'y') {\r\nreturn (-1);\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint ap_open_output_file(char *pathname)\r\n{\r\nACPI_FILE file;\r\nif (ap_is_existing_file(pathname) != 0) {\r\nreturn (-1);\r\n}\r\nfile = acpi_os_open_file(pathname, ACPI_FILE_WRITING);\r\nif (!file) {\r\nacpi_log_error("Could not open output file: %s\n", pathname);\r\nreturn (-1);\r\n}\r\ngbl_output_file = file;\r\ngbl_output_filename = pathname;\r\nreturn (0);\r\n}\r\nint ap_write_to_binary_file(struct acpi_table_header *table, u32 instance)\r\n{\r\nchar filename[ACPI_NAME_SIZE + 16];\r\nchar instance_str[16];\r\nACPI_FILE file;\r\nsize_t actual;\r\nu32 table_length;\r\ntable_length = ap_get_table_length(table);\r\nif (ACPI_VALIDATE_RSDP_SIG(table->signature)) {\r\nACPI_MOVE_NAME(filename, ACPI_RSDP_NAME);\r\n} else {\r\nACPI_MOVE_NAME(filename, table->signature);\r\n}\r\nfilename[0] = (char)ACPI_TOLOWER(filename[0]);\r\nfilename[1] = (char)ACPI_TOLOWER(filename[1]);\r\nfilename[2] = (char)ACPI_TOLOWER(filename[2]);\r\nfilename[3] = (char)ACPI_TOLOWER(filename[3]);\r\nfilename[ACPI_NAME_SIZE] = 0;\r\nif (instance > 0) {\r\nacpi_ut_snprintf(instance_str, sizeof(instance_str), "%u",\r\ninstance);\r\nACPI_STRCAT(filename, instance_str);\r\n}\r\nACPI_STRCAT(filename, ACPI_TABLE_FILE_SUFFIX);\r\nif (gbl_verbose_mode) {\r\nacpi_log_error\r\n("Writing [%4.4s] to binary file: %s 0x%X (%u) bytes\n",\r\ntable->signature, filename, table->length, table->length);\r\n}\r\nfile = acpi_os_open_file(filename,\r\nACPI_FILE_WRITING | ACPI_FILE_BINARY);\r\nif (!file) {\r\nacpi_log_error("Could not open output file: %s\n", filename);\r\nreturn (-1);\r\n}\r\nactual = acpi_os_write_file(file, table, 1, table_length);\r\nif (actual != table_length) {\r\nacpi_log_error("Error writing binary output file: %s\n",\r\nfilename);\r\nacpi_os_close_file(file);\r\nreturn (-1);\r\n}\r\nacpi_os_close_file(file);\r\nreturn (0);\r\n}\r\nstruct acpi_table_header *ap_get_table_from_file(char *pathname,\r\nu32 *out_file_size)\r\n{\r\nstruct acpi_table_header *buffer = NULL;\r\nACPI_FILE file;\r\nu32 file_size;\r\nsize_t actual;\r\nfile =\r\nacpi_os_open_file(pathname, ACPI_FILE_READING | ACPI_FILE_BINARY);\r\nif (!file) {\r\nacpi_log_error("Could not open input file: %s\n", pathname);\r\nreturn (NULL);\r\n}\r\nfile_size = cm_get_file_size(file);\r\nif (file_size == ACPI_UINT32_MAX) {\r\nacpi_log_error("Could not get input file size: %s\n", pathname);\r\ngoto cleanup;\r\n}\r\nbuffer = ACPI_ALLOCATE_ZEROED(file_size);\r\nif (!buffer) {\r\nacpi_log_error("Could not allocate file buffer of size: %u\n",\r\nfile_size);\r\ngoto cleanup;\r\n}\r\nactual = acpi_os_read_file(file, buffer, 1, file_size);\r\nif (actual != file_size) {\r\nacpi_log_error("Could not read input file: %s\n", pathname);\r\nACPI_FREE(buffer);\r\nbuffer = NULL;\r\ngoto cleanup;\r\n}\r\n*out_file_size = file_size;\r\ncleanup:\r\nacpi_os_close_file(file);\r\nreturn (buffer);\r\n}
