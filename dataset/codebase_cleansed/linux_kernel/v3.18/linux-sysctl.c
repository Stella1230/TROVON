static int proc_set_timeout(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint rc;\r\nrc = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif (ldlm_timeout >= obd_timeout)\r\nldlm_timeout = max(obd_timeout / 3, 1U);\r\nreturn rc;\r\n}\r\nstatic int proc_memory_alloc(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nchar buf[22];\r\nint len;\r\nif (!*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (write)\r\nreturn -EINVAL;\r\nlen = snprintf(buf, sizeof(buf), "%llu\n", obd_memory_sum());\r\nif (len > *lenp)\r\nlen = *lenp;\r\nbuf[len] = '\0';\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\n*lenp = len;\r\n*ppos += *lenp;\r\nreturn 0;\r\n}\r\nstatic int proc_pages_alloc(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nchar buf[22];\r\nint len;\r\nif (!*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (write)\r\nreturn -EINVAL;\r\nlen = snprintf(buf, sizeof(buf), "%llu\n", obd_pages_sum());\r\nif (len > *lenp)\r\nlen = *lenp;\r\nbuf[len] = '\0';\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\n*lenp = len;\r\n*ppos += *lenp;\r\nreturn 0;\r\n}\r\nstatic int proc_mem_max(struct ctl_table *table, int write, void __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\nchar buf[22];\r\nint len;\r\nif (!*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (write)\r\nreturn -EINVAL;\r\nlen = snprintf(buf, sizeof(buf), "%llu\n", obd_memory_max());\r\nif (len > *lenp)\r\nlen = *lenp;\r\nbuf[len] = '\0';\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\n*lenp = len;\r\n*ppos += *lenp;\r\nreturn 0;\r\n}\r\nstatic int proc_pages_max(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nchar buf[22];\r\nint len;\r\nif (!*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (write)\r\nreturn -EINVAL;\r\nlen = snprintf(buf, sizeof(buf), "%llu\n", obd_pages_max());\r\nif (len > *lenp)\r\nlen = *lenp;\r\nbuf[len] = '\0';\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\n*lenp = len;\r\n*ppos += *lenp;\r\nreturn 0;\r\n}\r\nstatic int proc_max_dirty_pages_in_mb(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint rc = 0;\r\nif (!table->data || !table->maxlen || !*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (write) {\r\nrc = lprocfs_write_frac_helper(buffer, *lenp,\r\n(unsigned int *)table->data,\r\n1 << (20 - PAGE_CACHE_SHIFT));\r\nif (obd_max_dirty_pages > ((totalram_pages / 10) * 9)) {\r\nCERROR("Refusing to set max dirty pages to %u, which "\r\n"is more than 90%% of available RAM; setting "\r\n"to %lu\n", obd_max_dirty_pages,\r\n((totalram_pages / 10) * 9));\r\nobd_max_dirty_pages = ((totalram_pages / 10) * 9);\r\n} else if (obd_max_dirty_pages < 4 << (20 - PAGE_CACHE_SHIFT)) {\r\nobd_max_dirty_pages = 4 << (20 - PAGE_CACHE_SHIFT);\r\n}\r\n} else {\r\nchar buf[21];\r\nint len;\r\nlen = lprocfs_read_frac_helper(buf, sizeof(buf),\r\n*(unsigned int *)table->data,\r\n1 << (20 - PAGE_CACHE_SHIFT));\r\nif (len > *lenp)\r\nlen = *lenp;\r\nbuf[len] = '\0';\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\n*lenp = len;\r\n}\r\n*ppos += *lenp;\r\nreturn rc;\r\n}\r\nstatic int proc_alloc_fail_rate(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint rc = 0;\r\nif (!table->data || !table->maxlen || !*lenp || (*ppos && !write)) {\r\n*lenp = 0;\r\nreturn 0;\r\n}\r\nif (write) {\r\nrc = lprocfs_write_frac_helper(buffer, *lenp,\r\n(unsigned int *)table->data,\r\nOBD_ALLOC_FAIL_MULT);\r\n} else {\r\nchar buf[21];\r\nint len;\r\nlen = lprocfs_read_frac_helper(buf, 21,\r\n*(unsigned int *)table->data,\r\nOBD_ALLOC_FAIL_MULT);\r\nif (len > *lenp)\r\nlen = *lenp;\r\nbuf[len] = '\0';\r\nif (copy_to_user(buffer, buf, len))\r\nreturn -EFAULT;\r\n*lenp = len;\r\n}\r\n*ppos += *lenp;\r\nreturn rc;\r\n}\r\nvoid obd_sysctl_init(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (!obd_table_header)\r\nobd_table_header = register_sysctl_table(parent_table);\r\n#endif\r\n}\r\nvoid obd_sysctl_clean(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (obd_table_header)\r\nunregister_sysctl_table(obd_table_header);\r\nobd_table_header = NULL;\r\n#endif\r\n}
