static void pcan_start_led_timer(struct pcan_pccard *card)\r\n{\r\nif (!timer_pending(&card->led_timer))\r\nmod_timer(&card->led_timer, jiffies + HZ);\r\n}\r\nstatic void pcan_stop_led_timer(struct pcan_pccard *card)\r\n{\r\ndel_timer_sync(&card->led_timer);\r\n}\r\nstatic u8 pcan_read_canreg(const struct sja1000_priv *priv, int port)\r\n{\r\nreturn ioread8(priv->reg_base + port);\r\n}\r\nstatic void pcan_write_canreg(const struct sja1000_priv *priv, int port, u8 v)\r\n{\r\nstruct pcan_pccard *card = priv->priv;\r\nint c = (priv->reg_base - card->ioport_addr) / PCC_CHAN_SIZE;\r\nif (port == SJA1000_MOD)\r\nswitch (v) {\r\ncase MOD_RM:\r\npcan_set_leds(card, PCC_LED(c), PCC_LED_ON);\r\nbreak;\r\ncase 0x00:\r\npcan_set_leds(card, PCC_LED(c), PCC_LED_SLOW);\r\npcan_start_led_timer(card);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\niowrite8(v, priv->reg_base + port);\r\n}\r\nstatic u8 pcan_read_reg(struct pcan_pccard *card, int port)\r\n{\r\nreturn ioread8(card->ioport_addr + PCC_COMN_OFF + port);\r\n}\r\nstatic void pcan_write_reg(struct pcan_pccard *card, int port, u8 v)\r\n{\r\nif (port == PCC_CCR) {\r\nif (card->ccr == v)\r\nreturn;\r\ncard->ccr = v;\r\n}\r\niowrite8(v, card->ioport_addr + PCC_COMN_OFF + port);\r\n}\r\nstatic inline int pcan_pccard_present(struct pcan_pccard *card)\r\n{\r\nreturn ((pcan_read_reg(card, PCC_FW_MAJOR) == card->fw_major) &&\r\n(pcan_read_reg(card, PCC_FW_MINOR) == card->fw_minor));\r\n}\r\nstatic int pcan_wait_spi_busy(struct pcan_pccard *card)\r\n{\r\nunsigned long timeout = jiffies +\r\nmsecs_to_jiffies(PCC_SPI_MAX_BUSY_WAIT_MS) + 1;\r\nwhile (pcan_read_reg(card, PCC_CSR) & PCC_CSR_SPI_BUSY) {\r\nif (time_after(jiffies, timeout))\r\nreturn -EBUSY;\r\nschedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcan_write_eeprom(struct pcan_pccard *card, u16 addr, u8 v)\r\n{\r\nu8 status;\r\nint err, i;\r\npcan_write_reg(card, PCC_SPI_IR, PCC_EEP_WREN);\r\nerr = pcan_wait_spi_busy(card);\r\nif (err)\r\ngoto we_spi_err;\r\nfor (i = 0; i < PCC_WRITE_MAX_LOOP; i++) {\r\npcan_write_reg(card, PCC_SPI_IR, PCC_EEP_RDSR);\r\nerr = pcan_wait_spi_busy(card);\r\nif (err)\r\ngoto we_spi_err;\r\nstatus = pcan_read_reg(card, PCC_SPI_DIR);\r\nif (status & PCC_EEP_SR_WEN)\r\nbreak;\r\n}\r\nif (i >= PCC_WRITE_MAX_LOOP) {\r\ndev_err(&card->pdev->dev,\r\n"stop waiting to be allowed to write in eeprom\n");\r\nreturn -EIO;\r\n}\r\npcan_write_reg(card, PCC_SPI_ADR, addr & 0xff);\r\npcan_write_reg(card, PCC_SPI_DOR, v);\r\npcan_write_reg(card, PCC_SPI_IR, PCC_EEP_WRITE(addr));\r\nerr = pcan_wait_spi_busy(card);\r\nif (err)\r\ngoto we_spi_err;\r\nfor (i = 0; i < PCC_WRITE_MAX_LOOP; i++) {\r\npcan_write_reg(card, PCC_SPI_IR, PCC_EEP_RDSR);\r\nerr = pcan_wait_spi_busy(card);\r\nif (err)\r\ngoto we_spi_err;\r\nstatus = pcan_read_reg(card, PCC_SPI_DIR);\r\nif (!(status & PCC_EEP_SR_WIP))\r\nbreak;\r\n}\r\nif (i >= PCC_WRITE_MAX_LOOP) {\r\ndev_err(&card->pdev->dev,\r\n"stop waiting for write in eeprom to complete\n");\r\nreturn -EIO;\r\n}\r\npcan_write_reg(card, PCC_SPI_IR, PCC_EEP_WRDI);\r\nerr = pcan_wait_spi_busy(card);\r\nif (err)\r\ngoto we_spi_err;\r\nreturn 0;\r\nwe_spi_err:\r\ndev_err(&card->pdev->dev,\r\n"stop waiting (spi engine always busy) err %d\n", err);\r\nreturn err;\r\n}\r\nstatic void pcan_set_leds(struct pcan_pccard *card, u8 led_mask, u8 state)\r\n{\r\nu8 ccr = card->ccr;\r\nint i;\r\nfor (i = 0; i < card->chan_count; i++)\r\nif (led_mask & PCC_LED(i)) {\r\nccr &= ~PCC_CCR_LED_MASK_CHAN(i);\r\nccr |= PCC_CCR_LED_CHAN(state, i);\r\n}\r\npcan_write_reg(card, PCC_CCR, ccr);\r\n}\r\nstatic inline void pcan_set_can_power(struct pcan_pccard *card, int onoff)\r\n{\r\nint err;\r\nerr = pcan_write_eeprom(card, 0, !!onoff);\r\nif (err)\r\ndev_err(&card->pdev->dev,\r\n"failed setting power %s to can connectors (err %d)\n",\r\n(onoff) ? "on" : "off", err);\r\n}\r\nstatic void pcan_led_timer(unsigned long arg)\r\n{\r\nstruct pcan_pccard *card = (struct pcan_pccard *)arg;\r\nstruct net_device *netdev;\r\nint i, up_count = 0;\r\nu8 ccr;\r\nccr = card->ccr;\r\nfor (i = 0; i < card->chan_count; i++) {\r\nccr &= ~PCC_CCR_LED_MASK_CHAN(i);\r\nccr |= PCC_CCR_LED_ON_CHAN(i);\r\nnetdev = card->channel[i].netdev;\r\nif (!netdev || !(netdev->flags & IFF_UP))\r\ncontinue;\r\nup_count++;\r\nccr &= ~PCC_CCR_LED_MASK_CHAN(i);\r\nccr |= PCC_CCR_LED_SLOW_CHAN(i);\r\nif (netdev->stats.rx_bytes != card->channel[i].prev_rx_bytes) {\r\ncard->channel[i].prev_rx_bytes = netdev->stats.rx_bytes;\r\nccr &= ~PCC_CCR_LED_MASK_CHAN(i);\r\nccr |= PCC_CCR_LED_FAST_CHAN(i);\r\n}\r\nif (netdev->stats.tx_bytes != card->channel[i].prev_tx_bytes) {\r\ncard->channel[i].prev_tx_bytes = netdev->stats.tx_bytes;\r\nccr &= ~PCC_CCR_LED_MASK_CHAN(i);\r\nccr |= PCC_CCR_LED_FAST_CHAN(i);\r\n}\r\n}\r\npcan_write_reg(card, PCC_CCR, ccr);\r\nif (up_count)\r\nmod_timer(&card->led_timer, jiffies + HZ);\r\n}\r\nstatic irqreturn_t pcan_isr(int irq, void *dev_id)\r\n{\r\nstruct pcan_pccard *card = dev_id;\r\nint irq_handled;\r\nfor (irq_handled = 0; irq_handled < PCC_ISR_MAX_LOOP; irq_handled++) {\r\nint nothing_to_handle = 1;\r\nint i;\r\nfor (i = 0; i < card->chan_count; i++) {\r\nstruct net_device *netdev;\r\nif (!pcan_pccard_present(card)) {\r\nreturn IRQ_NONE;\r\n}\r\nnetdev = card->channel[i].netdev;\r\nif (netdev &&\r\nsja1000_interrupt(irq, netdev) == IRQ_HANDLED)\r\nnothing_to_handle = 0;\r\n}\r\nif (nothing_to_handle)\r\nbreak;\r\n}\r\nreturn (irq_handled) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void pcan_free_channels(struct pcan_pccard *card)\r\n{\r\nint i;\r\nu8 led_mask = 0;\r\nfor (i = 0; i < card->chan_count; i++) {\r\nstruct net_device *netdev;\r\nchar name[IFNAMSIZ];\r\nled_mask |= PCC_LED(i);\r\nnetdev = card->channel[i].netdev;\r\nif (!netdev)\r\ncontinue;\r\nstrncpy(name, netdev->name, IFNAMSIZ);\r\nunregister_sja1000dev(netdev);\r\nfree_sja1000dev(netdev);\r\ndev_info(&card->pdev->dev, "%s removed\n", name);\r\n}\r\nif (pcan_pccard_present(card)) {\r\npcan_set_leds(card, led_mask, PCC_LED_OFF);\r\npcan_set_can_power(card, 0);\r\n}\r\n}\r\nstatic inline int pcan_channel_present(struct sja1000_priv *priv)\r\n{\r\npcan_write_canreg(priv, SJA1000_MOD, 1);\r\npcan_write_canreg(priv, SJA1000_CDR, CDR_PELICAN);\r\nif (pcan_read_canreg(priv, SJA1000_CDR) == CDR_PELICAN)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int pcan_add_channels(struct pcan_pccard *card)\r\n{\r\nstruct pcmcia_device *pdev = card->pdev;\r\nint i, err = 0;\r\nu8 ccr = PCC_CCR_INIT;\r\ncard->ccr = ~ccr;\r\npcan_write_reg(card, PCC_CCR, ccr);\r\nmdelay(2);\r\nccr &= ~PCC_CCR_RST_ALL;\r\npcan_write_reg(card, PCC_CCR, ccr);\r\nfor (i = 0; i < ARRAY_SIZE(card->channel); i++) {\r\nstruct net_device *netdev;\r\nstruct sja1000_priv *priv;\r\nnetdev = alloc_sja1000dev(0);\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\npriv = netdev_priv(netdev);\r\npriv->priv = card;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nnetdev->dev_id = i;\r\npriv->irq_flags = IRQF_SHARED;\r\nnetdev->irq = pdev->irq;\r\npriv->reg_base = card->ioport_addr + PCC_CHAN_OFF(i);\r\nif (!pcan_channel_present(priv)) {\r\ndev_err(&pdev->dev, "channel %d not present\n", i);\r\nfree_sja1000dev(netdev);\r\ncontinue;\r\n}\r\npriv->read_reg = pcan_read_canreg;\r\npriv->write_reg = pcan_write_canreg;\r\npriv->can.clock.freq = PCC_CAN_CLOCK;\r\npriv->ocr = PCC_OCR;\r\npriv->cdr = PCC_CDR;\r\nif (i > 0)\r\npriv->cdr |= CDR_CLK_OFF;\r\npriv->flags |= SJA1000_CUSTOM_IRQ_HANDLER;\r\nerr = register_sja1000dev(netdev);\r\nif (err) {\r\nfree_sja1000dev(netdev);\r\ncontinue;\r\n}\r\ncard->channel[i].netdev = netdev;\r\ncard->chan_count++;\r\nccr &= ~PCC_CCR_LED_OFF_CHAN(i);\r\ndev_info(&pdev->dev,\r\n"%s on channel %d at 0x%p irq %d\n",\r\nnetdev->name, i, priv->reg_base, pdev->irq);\r\n}\r\npcan_write_reg(card, PCC_CCR, ccr);\r\nreturn err;\r\n}\r\nstatic int pcan_conf_check(struct pcmcia_device *pdev, void *priv_data)\r\n{\r\npdev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\npdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\npdev->io_lines = 10;\r\nreturn pcmcia_request_io(pdev);\r\n}\r\nstatic void pcan_free(struct pcmcia_device *pdev)\r\n{\r\nstruct pcan_pccard *card = pdev->priv;\r\nif (!card)\r\nreturn;\r\nfree_irq(pdev->irq, card);\r\npcan_stop_led_timer(card);\r\npcan_free_channels(card);\r\nioport_unmap(card->ioport_addr);\r\nkfree(card);\r\npdev->priv = NULL;\r\n}\r\nstatic int pcan_probe(struct pcmcia_device *pdev)\r\n{\r\nstruct pcan_pccard *card;\r\nint err;\r\npdev->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nerr = pcmcia_loop_config(pdev, pcan_conf_check, NULL);\r\nif (err) {\r\ndev_err(&pdev->dev, "pcmcia_loop_config() error %d\n", err);\r\ngoto probe_err_1;\r\n}\r\nif (!pdev->irq) {\r\ndev_err(&pdev->dev, "no irq assigned\n");\r\nerr = -ENODEV;\r\ngoto probe_err_1;\r\n}\r\nerr = pcmcia_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "pcmcia_enable_device failed err=%d\n",\r\nerr);\r\ngoto probe_err_1;\r\n}\r\ncard = kzalloc(sizeof(struct pcan_pccard), GFP_KERNEL);\r\nif (!card) {\r\nerr = -ENOMEM;\r\ngoto probe_err_2;\r\n}\r\ncard->pdev = pdev;\r\npdev->priv = card;\r\ncard->ioport_addr = ioport_map(pdev->resource[0]->start,\r\nresource_size(pdev->resource[0]));\r\nif (!card->ioport_addr) {\r\ndev_err(&pdev->dev, "couldn't map io port into io memory\n");\r\nerr = -ENOMEM;\r\ngoto probe_err_3;\r\n}\r\ncard->fw_major = pcan_read_reg(card, PCC_FW_MAJOR);\r\ncard->fw_minor = pcan_read_reg(card, PCC_FW_MINOR);\r\ndev_info(&pdev->dev, "PEAK-System pcmcia card %s fw %d.%d\n",\r\npdev->prod_id[1] ? pdev->prod_id[1] : "PCAN-PC Card",\r\ncard->fw_major, card->fw_minor);\r\npcan_add_channels(card);\r\nif (!card->chan_count) {\r\nerr = -ENOMEM;\r\ngoto probe_err_4;\r\n}\r\ninit_timer(&card->led_timer);\r\ncard->led_timer.function = pcan_led_timer;\r\ncard->led_timer.data = (unsigned long)card;\r\nerr = request_irq(pdev->irq, &pcan_isr, IRQF_SHARED, PCC_NAME, card);\r\nif (err) {\r\ndev_err(&pdev->dev, "couldn't request irq%d\n", pdev->irq);\r\ngoto probe_err_5;\r\n}\r\npcan_set_can_power(card, 1);\r\nreturn 0;\r\nprobe_err_5:\r\npcan_free_channels(card);\r\nprobe_err_4:\r\nioport_unmap(card->ioport_addr);\r\nprobe_err_3:\r\nkfree(card);\r\npdev->priv = NULL;\r\nprobe_err_2:\r\npcmcia_disable_device(pdev);\r\nprobe_err_1:\r\nreturn err;\r\n}\r\nstatic void pcan_remove(struct pcmcia_device *pdev)\r\n{\r\npcan_free(pdev);\r\npcmcia_disable_device(pdev);\r\n}
