static int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_port *p;\r\nstruct nlattr *nest;\r\nif (!br->multicast_router || hlist_empty(&br->router_list))\r\nreturn 0;\r\nnest = nla_nest_start(skb, MDBA_ROUTER);\r\nif (nest == NULL)\r\nreturn -EMSGSIZE;\r\nhlist_for_each_entry_rcu(p, &br->router_list, rlist) {\r\nif (p && nla_put_u32(skb, MDBA_ROUTER_PORT, p->dev->ifindex))\r\ngoto fail;\r\n}\r\nnla_nest_end(skb, nest);\r\nreturn 0;\r\nfail:\r\nnla_nest_cancel(skb, nest);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct nlattr *nest, *nest2;\r\nint i, err = 0;\r\nint idx = 0, s_idx = cb->args[1];\r\nif (br->multicast_disabled)\r\nreturn 0;\r\nmdb = rcu_dereference(br->mdb);\r\nif (!mdb)\r\nreturn 0;\r\nnest = nla_nest_start(skb, MDBA_MDB);\r\nif (nest == NULL)\r\nreturn -EMSGSIZE;\r\nfor (i = 0; i < mdb->max; i++) {\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct net_bridge_port *port;\r\nhlist_for_each_entry_rcu(mp, &mdb->mhash[i], hlist[mdb->ver]) {\r\nif (idx < s_idx)\r\ngoto skip;\r\nnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\r\nif (nest2 == NULL) {\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\nfor (pp = &mp->ports;\r\n(p = rcu_dereference(*pp)) != NULL;\r\npp = &p->next) {\r\nport = p->port;\r\nif (port) {\r\nstruct br_mdb_entry e;\r\nmemset(&e, 0, sizeof(e));\r\ne.ifindex = port->dev->ifindex;\r\ne.state = p->state;\r\nif (p->addr.proto == htons(ETH_P_IP))\r\ne.addr.u.ip4 = p->addr.u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (p->addr.proto == htons(ETH_P_IPV6))\r\ne.addr.u.ip6 = p->addr.u.ip6;\r\n#endif\r\ne.addr.proto = p->addr.proto;\r\nif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(e), &e)) {\r\nnla_nest_cancel(skb, nest2);\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\n}\r\n}\r\nnla_nest_end(skb, nest2);\r\nskip:\r\nidx++;\r\n}\r\n}\r\nout:\r\ncb->args[1] = idx;\r\nnla_nest_end(skb, nest);\r\nreturn err;\r\n}\r\nstatic int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net_device *dev;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlmsghdr *nlh = NULL;\r\nint idx = 0, s_idx;\r\ns_idx = cb->args[0];\r\nrcu_read_lock();\r\ncb->seq = net->dev_base_seq + br_mdb_rehash_seq;\r\nfor_each_netdev_rcu(net, dev) {\r\nif (dev->priv_flags & IFF_EBRIDGE) {\r\nstruct br_port_msg *bpm;\r\nif (idx < s_idx)\r\ngoto skip;\r\nnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, RTM_GETMDB,\r\nsizeof(*bpm), NLM_F_MULTI);\r\nif (nlh == NULL)\r\nbreak;\r\nbpm = nlmsg_data(nlh);\r\nmemset(bpm, 0, sizeof(*bpm));\r\nbpm->ifindex = dev->ifindex;\r\nif (br_mdb_fill_info(skb, cb, dev) < 0)\r\ngoto out;\r\nif (br_rports_fill_info(skb, cb, dev) < 0)\r\ngoto out;\r\ncb->args[1] = 0;\r\nnlmsg_end(skb, nlh);\r\nskip:\r\nidx++;\r\n}\r\n}\r\nout:\r\nif (nlh)\r\nnlmsg_end(skb, nlh);\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic int nlmsg_populate_mdb_fill(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nstruct br_mdb_entry *entry, u32 pid,\r\nu32 seq, int type, unsigned int flags)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct br_port_msg *bpm;\r\nstruct nlattr *nest, *nest2;\r\nnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nbpm = nlmsg_data(nlh);\r\nmemset(bpm, 0, sizeof(*bpm));\r\nbpm->family = AF_BRIDGE;\r\nbpm->ifindex = dev->ifindex;\r\nnest = nla_nest_start(skb, MDBA_MDB);\r\nif (nest == NULL)\r\ngoto cancel;\r\nnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\r\nif (nest2 == NULL)\r\ngoto end;\r\nif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\r\ngoto end;\r\nnla_nest_end(skb, nest2);\r\nnla_nest_end(skb, nest);\r\nreturn nlmsg_end(skb, nlh);\r\nend:\r\nnla_nest_end(skb, nest);\r\ncancel:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic inline size_t rtnl_mdb_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct br_port_msg))\r\n+ nla_total_size(sizeof(struct br_mdb_entry));\r\n}\r\nstatic void __br_mdb_notify(struct net_device *dev, struct br_mdb_entry *entry,\r\nint type)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(rtnl_mdb_nlmsg_size(), GFP_ATOMIC);\r\nif (!skb)\r\ngoto errout;\r\nerr = nlmsg_populate_mdb_fill(skb, dev, entry, 0, 0, type, NTF_SELF);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nrtnl_set_sk_err(net, RTNLGRP_MDB, err);\r\n}\r\nvoid br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\r\nstruct br_ip *group, int type)\r\n{\r\nstruct br_mdb_entry entry;\r\nmemset(&entry, 0, sizeof(entry));\r\nentry.ifindex = port->dev->ifindex;\r\nentry.addr.proto = group->proto;\r\nentry.addr.u.ip4 = group->u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nentry.addr.u.ip6 = group->u.ip6;\r\n#endif\r\n__br_mdb_notify(dev, &entry, type);\r\n}\r\nstatic bool is_valid_mdb_entry(struct br_mdb_entry *entry)\r\n{\r\nif (entry->ifindex == 0)\r\nreturn false;\r\nif (entry->addr.proto == htons(ETH_P_IP)) {\r\nif (!ipv4_is_multicast(entry->addr.u.ip4))\r\nreturn false;\r\nif (ipv4_is_local_multicast(entry->addr.u.ip4))\r\nreturn false;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (entry->addr.proto == htons(ETH_P_IPV6)) {\r\nif (ipv6_addr_is_ll_all_nodes(&entry->addr.u.ip6))\r\nreturn false;\r\n#endif\r\n} else\r\nreturn false;\r\nif (entry->state != MDB_PERMANENT && entry->state != MDB_TEMPORARY)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int br_mdb_parse(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct net_device **pdev, struct br_mdb_entry **pentry)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct br_mdb_entry *entry;\r\nstruct br_port_msg *bpm;\r\nstruct nlattr *tb[MDBA_SET_ENTRY_MAX+1];\r\nstruct net_device *dev;\r\nint err;\r\nerr = nlmsg_parse(nlh, sizeof(*bpm), tb, MDBA_SET_ENTRY, NULL);\r\nif (err < 0)\r\nreturn err;\r\nbpm = nlmsg_data(nlh);\r\nif (bpm->ifindex == 0) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with invalid ifindex\n");\r\nreturn -EINVAL;\r\n}\r\ndev = __dev_get_by_index(net, bpm->ifindex);\r\nif (dev == NULL) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with unknown ifindex\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(dev->priv_flags & IFF_EBRIDGE)) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with non-bridge\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n*pdev = dev;\r\nif (!tb[MDBA_SET_ENTRY] ||\r\nnla_len(tb[MDBA_SET_ENTRY]) != sizeof(struct br_mdb_entry)) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with invalid attr\n");\r\nreturn -EINVAL;\r\n}\r\nentry = nla_data(tb[MDBA_SET_ENTRY]);\r\nif (!is_valid_mdb_entry(entry)) {\r\npr_info("PF_BRIDGE: br_mdb_parse() with invalid entry\n");\r\nreturn -EINVAL;\r\n}\r\n*pentry = entry;\r\nreturn 0;\r\n}\r\nstatic int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,\r\nstruct br_ip *group, unsigned char state)\r\n{\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct net_bridge_mdb_htable *mdb;\r\nint err;\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, group);\r\nif (!mp) {\r\nmp = br_multicast_new_group(br, port, group);\r\nerr = PTR_ERR(mp);\r\nif (IS_ERR(mp))\r\nreturn err;\r\n}\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (p->port == port)\r\nreturn -EEXIST;\r\nif ((unsigned long)p->port < (unsigned long)port)\r\nbreak;\r\n}\r\np = br_multicast_new_port_group(port, group, *pp, state);\r\nif (unlikely(!p))\r\nreturn -ENOMEM;\r\nrcu_assign_pointer(*pp, p);\r\nbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\r\nreturn 0;\r\n}\r\nstatic int __br_mdb_add(struct net *net, struct net_bridge *br,\r\nstruct br_mdb_entry *entry)\r\n{\r\nstruct br_ip ip;\r\nstruct net_device *dev;\r\nstruct net_bridge_port *p;\r\nint ret;\r\nif (!netif_running(br->dev) || br->multicast_disabled)\r\nreturn -EINVAL;\r\ndev = __dev_get_by_index(net, entry->ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\np = br_port_get_rtnl(dev);\r\nif (!p || p->br != br || p->state == BR_STATE_DISABLED)\r\nreturn -EINVAL;\r\nip.proto = entry->addr.proto;\r\nif (ip.proto == htons(ETH_P_IP))\r\nip.u.ip4 = entry->addr.u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nip.u.ip6 = entry->addr.u.ip6;\r\n#endif\r\nspin_lock_bh(&br->multicast_lock);\r\nret = br_mdb_add_group(br, p, &ip, entry->state);\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn ret;\r\n}\r\nstatic int br_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct br_mdb_entry *entry;\r\nstruct net_device *dev;\r\nstruct net_bridge *br;\r\nint err;\r\nerr = br_mdb_parse(skb, nlh, &dev, &entry);\r\nif (err < 0)\r\nreturn err;\r\nbr = netdev_priv(dev);\r\nerr = __br_mdb_add(net, br, entry);\r\nif (!err)\r\n__br_mdb_notify(dev, entry, RTM_NEWMDB);\r\nreturn err;\r\n}\r\nstatic int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct br_ip ip;\r\nint err = -EINVAL;\r\nif (!netif_running(br->dev) || br->multicast_disabled)\r\nreturn -EINVAL;\r\nip.proto = entry->addr.proto;\r\nif (ip.proto == htons(ETH_P_IP)) {\r\nif (timer_pending(&br->ip4_other_query.timer))\r\nreturn -EBUSY;\r\nip.u.ip4 = entry->addr.u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else {\r\nif (timer_pending(&br->ip6_other_query.timer))\r\nreturn -EBUSY;\r\nip.u.ip6 = entry->addr.u.ip6;\r\n#endif\r\n}\r\nspin_lock_bh(&br->multicast_lock);\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, &ip);\r\nif (!mp)\r\ngoto unlock;\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (!p->port || p->port->dev->ifindex != entry->ifindex)\r\ncontinue;\r\nif (p->port->state == BR_STATE_DISABLED)\r\ngoto unlock;\r\nrcu_assign_pointer(*pp, p->next);\r\nhlist_del_init(&p->mglist);\r\ndel_timer(&p->timer);\r\ncall_rcu_bh(&p->rcu, br_multicast_free_pg);\r\nerr = 0;\r\nif (!mp->ports && !mp->mglist &&\r\nnetif_running(br->dev))\r\nmod_timer(&mp->timer, jiffies);\r\nbreak;\r\n}\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic int br_mdb_del(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net_device *dev;\r\nstruct br_mdb_entry *entry;\r\nstruct net_bridge *br;\r\nint err;\r\nerr = br_mdb_parse(skb, nlh, &dev, &entry);\r\nif (err < 0)\r\nreturn err;\r\nbr = netdev_priv(dev);\r\nerr = __br_mdb_del(br, entry);\r\nif (!err)\r\n__br_mdb_notify(dev, entry, RTM_DELMDB);\r\nreturn err;\r\n}\r\nvoid br_mdb_init(void)\r\n{\r\nrtnl_register(PF_BRIDGE, RTM_GETMDB, NULL, br_mdb_dump, NULL);\r\nrtnl_register(PF_BRIDGE, RTM_NEWMDB, br_mdb_add, NULL, NULL);\r\nrtnl_register(PF_BRIDGE, RTM_DELMDB, br_mdb_del, NULL, NULL);\r\n}\r\nvoid br_mdb_uninit(void)\r\n{\r\nrtnl_unregister(PF_BRIDGE, RTM_GETMDB);\r\nrtnl_unregister(PF_BRIDGE, RTM_NEWMDB);\r\nrtnl_unregister(PF_BRIDGE, RTM_DELMDB);\r\n}
