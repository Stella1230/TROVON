static void reg_write(struct ak4114 *ak4114, unsigned char reg, unsigned char val)\r\n{\r\nak4114->write(ak4114->private_data, reg, val);\r\nif (reg <= AK4114_REG_INT1_MASK)\r\nak4114->regmap[reg] = val;\r\nelse if (reg >= AK4114_REG_TXCSB0 && reg <= AK4114_REG_TXCSB4)\r\nak4114->txcsb[reg-AK4114_REG_TXCSB0] = val;\r\n}\r\nstatic inline unsigned char reg_read(struct ak4114 *ak4114, unsigned char reg)\r\n{\r\nreturn ak4114->read(ak4114->private_data, reg);\r\n}\r\nstatic void snd_ak4114_free(struct ak4114 *chip)\r\n{\r\nchip->init = 1;\r\nmb();\r\ncancel_delayed_work_sync(&chip->work);\r\nkfree(chip);\r\n}\r\nstatic int snd_ak4114_dev_free(struct snd_device *device)\r\n{\r\nstruct ak4114 *chip = device->device_data;\r\nsnd_ak4114_free(chip);\r\nreturn 0;\r\n}\r\nint snd_ak4114_create(struct snd_card *card,\r\nak4114_read_t *read, ak4114_write_t *write,\r\nconst unsigned char pgm[6], const unsigned char txcsb[5],\r\nvoid *private_data, struct ak4114 **r_ak4114)\r\n{\r\nstruct ak4114 *chip;\r\nint err = 0;\r\nunsigned char reg;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ak4114_dev_free,\r\n};\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&chip->lock);\r\nchip->card = card;\r\nchip->read = read;\r\nchip->write = write;\r\nchip->private_data = private_data;\r\nINIT_DELAYED_WORK(&chip->work, ak4114_stats);\r\nfor (reg = 0; reg < 6; reg++)\r\nchip->regmap[reg] = pgm[reg];\r\nfor (reg = 0; reg < 5; reg++)\r\nchip->txcsb[reg] = txcsb[reg];\r\nak4114_init_regs(chip);\r\nchip->rcs0 = reg_read(chip, AK4114_REG_RCS0) & ~(AK4114_QINT | AK4114_CINT);\r\nchip->rcs1 = reg_read(chip, AK4114_REG_RCS1);\r\nif ((err = snd_device_new(card, SNDRV_DEV_CODEC, chip, &ops)) < 0)\r\ngoto __fail;\r\nif (r_ak4114)\r\n*r_ak4114 = chip;\r\nreturn 0;\r\n__fail:\r\nsnd_ak4114_free(chip);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nvoid snd_ak4114_reg_write(struct ak4114 *chip, unsigned char reg, unsigned char mask, unsigned char val)\r\n{\r\nif (reg <= AK4114_REG_INT1_MASK)\r\nreg_write(chip, reg, (chip->regmap[reg] & ~mask) | val);\r\nelse if (reg >= AK4114_REG_TXCSB0 && reg <= AK4114_REG_TXCSB4)\r\nreg_write(chip, reg,\r\n(chip->txcsb[reg-AK4114_REG_TXCSB0] & ~mask) | val);\r\n}\r\nstatic void ak4114_init_regs(struct ak4114 *chip)\r\n{\r\nunsigned char old = chip->regmap[AK4114_REG_PWRDN], reg;\r\nreg_write(chip, AK4114_REG_PWRDN, old & ~(AK4114_RST|AK4114_PWN));\r\nudelay(200);\r\nreg_write(chip, AK4114_REG_PWRDN, (old | AK4114_RST) & ~AK4114_PWN);\r\nudelay(200);\r\nfor (reg = 1; reg < 6; reg++)\r\nreg_write(chip, reg, chip->regmap[reg]);\r\nfor (reg = 0; reg < 5; reg++)\r\nreg_write(chip, reg + AK4114_REG_TXCSB0, chip->txcsb[reg]);\r\nreg_write(chip, AK4114_REG_PWRDN, old | AK4114_RST | AK4114_PWN);\r\n}\r\nvoid snd_ak4114_reinit(struct ak4114 *chip)\r\n{\r\nchip->init = 1;\r\nmb();\r\nflush_delayed_work(&chip->work);\r\nak4114_init_regs(chip);\r\nchip->init = 0;\r\nif (chip->kctls[0])\r\nschedule_delayed_work(&chip->work, HZ / 10);\r\n}\r\nstatic unsigned int external_rate(unsigned char rcs1)\r\n{\r\nswitch (rcs1 & (AK4114_FS0|AK4114_FS1|AK4114_FS2|AK4114_FS3)) {\r\ncase AK4114_FS_32000HZ: return 32000;\r\ncase AK4114_FS_44100HZ: return 44100;\r\ncase AK4114_FS_48000HZ: return 48000;\r\ncase AK4114_FS_88200HZ: return 88200;\r\ncase AK4114_FS_96000HZ: return 96000;\r\ncase AK4114_FS_176400HZ: return 176400;\r\ncase AK4114_FS_192000HZ: return 192000;\r\ndefault: return 0;\r\n}\r\n}\r\nstatic int snd_ak4114_in_error_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = LONG_MAX;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_in_error_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\r\nlong *ptr;\r\nspin_lock_irq(&chip->lock);\r\nptr = (long *)(((char *)chip) + kcontrol->private_value);\r\nucontrol->value.integer.value[0] = *ptr;\r\n*ptr = 0;\r\nspin_unlock_irq(&chip->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_in_bit_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char reg = kcontrol->private_value & 0xff;\r\nunsigned char bit = (kcontrol->private_value >> 8) & 0xff;\r\nunsigned char inv = (kcontrol->private_value >> 31) & 1;\r\nucontrol->value.integer.value[0] = ((reg_read(chip, reg) & (1 << bit)) ? 1 : 0) ^ inv;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_rate_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 192000;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_rate_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = external_rate(reg_read(chip, AK4114_REG_RCS1));\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned i;\r\nfor (i = 0; i < AK4114_REG_RXCSB_SIZE; i++)\r\nucontrol->value.iec958.status[i] = reg_read(chip, AK4114_REG_RXCSB0 + i);\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_playback_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned i;\r\nfor (i = 0; i < AK4114_REG_TXCSB_SIZE; i++)\r\nucontrol->value.iec958.status[i] = chip->txcsb[i];\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_playback_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned i;\r\nfor (i = 0; i < AK4114_REG_TXCSB_SIZE; i++)\r\nreg_write(chip, AK4114_REG_TXCSB0 + i, ucontrol->value.iec958.status[i]);\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nmemset(ucontrol->value.iec958.status, 0xff, AK4114_REG_RXCSB_SIZE);\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_pinfo(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xffff;\r\nuinfo->count = 4;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_pget(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned short tmp;\r\nucontrol->value.integer.value[0] = 0xf8f2;\r\nucontrol->value.integer.value[1] = 0x4e1f;\r\ntmp = reg_read(chip, AK4114_REG_Pc0) | (reg_read(chip, AK4114_REG_Pc1) << 8);\r\nucontrol->value.integer.value[2] = tmp;\r\ntmp = reg_read(chip, AK4114_REG_Pd0) | (reg_read(chip, AK4114_REG_Pd1) << 8);\r\nucontrol->value.integer.value[3] = tmp;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_qinfo(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = AK4114_REG_QSUB_SIZE;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4114_spdif_qget(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ak4114 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned i;\r\nfor (i = 0; i < AK4114_REG_QSUB_SIZE; i++)\r\nucontrol->value.bytes.data[i] = reg_read(chip, AK4114_REG_QSUB_ADDR + i);\r\nreturn 0;\r\n}\r\nstatic void snd_ak4114_proc_regs_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct ak4114 *ak4114 = entry->private_data;\r\nint reg, val;\r\nfor (reg = 0; reg < 0x20; reg++) {\r\nval = reg_read(ak4114, reg);\r\nsnd_iprintf(buffer, "0x%02x = 0x%02x\n", reg, val);\r\n}\r\n}\r\nstatic void snd_ak4114_proc_init(struct ak4114 *ak4114)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(ak4114->card, "ak4114", &entry))\r\nsnd_info_set_text_ops(entry, ak4114, snd_ak4114_proc_regs_read);\r\n}\r\nint snd_ak4114_build(struct ak4114 *ak4114,\r\nstruct snd_pcm_substream *ply_substream,\r\nstruct snd_pcm_substream *cap_substream)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!cap_substream))\r\nreturn -EINVAL;\r\nak4114->playback_substream = ply_substream;\r\nak4114->capture_substream = cap_substream;\r\nfor (idx = 0; idx < AK4114_CONTROLS; idx++) {\r\nkctl = snd_ctl_new1(&snd_ak4114_iec958_controls[idx], ak4114);\r\nif (kctl == NULL)\r\nreturn -ENOMEM;\r\nif (strstr(kctl->id.name, "Playback")) {\r\nif (ply_substream == NULL) {\r\nsnd_ctl_free_one(kctl);\r\nak4114->kctls[idx] = NULL;\r\ncontinue;\r\n}\r\nkctl->id.device = ply_substream->pcm->device;\r\nkctl->id.subdevice = ply_substream->number;\r\n} else {\r\nkctl->id.device = cap_substream->pcm->device;\r\nkctl->id.subdevice = cap_substream->number;\r\n}\r\nerr = snd_ctl_add(ak4114->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nak4114->kctls[idx] = kctl;\r\n}\r\nsnd_ak4114_proc_init(ak4114);\r\nschedule_delayed_work(&ak4114->work, HZ / 10);\r\nreturn 0;\r\n}\r\nstatic void ak4114_notify(struct ak4114 *ak4114,\r\nunsigned char rcs0, unsigned char rcs1,\r\nunsigned char c0, unsigned char c1)\r\n{\r\nif (!ak4114->kctls[0])\r\nreturn;\r\nif (rcs0 & AK4114_PAR)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[0]->id);\r\nif (rcs0 & AK4114_V)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[1]->id);\r\nif (rcs1 & AK4114_CCRC)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[2]->id);\r\nif (rcs1 & AK4114_QCRC)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[3]->id);\r\nif (c1 & 0xf0)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[4]->id);\r\nif ((c0 & AK4114_PEM) | (c0 & AK4114_CINT))\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[9]->id);\r\nif (c0 & AK4114_QINT)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[10]->id);\r\nif (c0 & AK4114_AUDION)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[11]->id);\r\nif (c0 & AK4114_AUTO)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[12]->id);\r\nif (c0 & AK4114_DTSCD)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[13]->id);\r\nif (c0 & AK4114_UNLCK)\r\nsnd_ctl_notify(ak4114->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&ak4114->kctls[14]->id);\r\n}\r\nint snd_ak4114_external_rate(struct ak4114 *ak4114)\r\n{\r\nunsigned char rcs1;\r\nrcs1 = reg_read(ak4114, AK4114_REG_RCS1);\r\nreturn external_rate(rcs1);\r\n}\r\nint snd_ak4114_check_rate_and_errors(struct ak4114 *ak4114, unsigned int flags)\r\n{\r\nstruct snd_pcm_runtime *runtime = ak4114->capture_substream ? ak4114->capture_substream->runtime : NULL;\r\nunsigned long _flags;\r\nint res = 0;\r\nunsigned char rcs0, rcs1;\r\nunsigned char c0, c1;\r\nrcs1 = reg_read(ak4114, AK4114_REG_RCS1);\r\nif (flags & AK4114_CHECK_NO_STAT)\r\ngoto __rate;\r\nrcs0 = reg_read(ak4114, AK4114_REG_RCS0);\r\nspin_lock_irqsave(&ak4114->lock, _flags);\r\nif (rcs0 & AK4114_PAR)\r\nak4114->parity_errors++;\r\nif (rcs1 & AK4114_V)\r\nak4114->v_bit_errors++;\r\nif (rcs1 & AK4114_CCRC)\r\nak4114->ccrc_errors++;\r\nif (rcs1 & AK4114_QCRC)\r\nak4114->qcrc_errors++;\r\nc0 = (ak4114->rcs0 & (AK4114_QINT | AK4114_CINT | AK4114_PEM | AK4114_AUDION | AK4114_AUTO | AK4114_UNLCK)) ^\r\n(rcs0 & (AK4114_QINT | AK4114_CINT | AK4114_PEM | AK4114_AUDION | AK4114_AUTO | AK4114_UNLCK));\r\nc1 = (ak4114->rcs1 & 0xf0) ^ (rcs1 & 0xf0);\r\nak4114->rcs0 = rcs0 & ~(AK4114_QINT | AK4114_CINT);\r\nak4114->rcs1 = rcs1;\r\nspin_unlock_irqrestore(&ak4114->lock, _flags);\r\nak4114_notify(ak4114, rcs0, rcs1, c0, c1);\r\nif (ak4114->change_callback && (c0 | c1) != 0)\r\nak4114->change_callback(ak4114, c0, c1);\r\n__rate:\r\nres = external_rate(rcs1);\r\nif (!(flags & AK4114_CHECK_NO_RATE) && runtime && runtime->rate != res) {\r\nsnd_pcm_stream_lock_irqsave(ak4114->capture_substream, _flags);\r\nif (snd_pcm_running(ak4114->capture_substream)) {\r\nsnd_pcm_stop(ak4114->capture_substream, SNDRV_PCM_STATE_DRAINING);\r\nres = 1;\r\n}\r\nsnd_pcm_stream_unlock_irqrestore(ak4114->capture_substream, _flags);\r\n}\r\nreturn res;\r\n}\r\nstatic void ak4114_stats(struct work_struct *work)\r\n{\r\nstruct ak4114 *chip = container_of(work, struct ak4114, work.work);\r\nif (!chip->init)\r\nsnd_ak4114_check_rate_and_errors(chip, chip->check_flags);\r\nschedule_delayed_work(&chip->work, HZ / 10);\r\n}
