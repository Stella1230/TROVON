static struct ib_ah *c4iw_ah_create(struct ib_pd *pd,\r\nstruct ib_ah_attr *ah_attr)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic int c4iw_ah_destroy(struct ib_ah *ah)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int c4iw_multicast_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int c4iw_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int c4iw_process_mad(struct ib_device *ibdev, int mad_flags,\r\nu8 port_num, struct ib_wc *in_wc,\r\nstruct ib_grh *in_grh, struct ib_mad *in_mad,\r\nstruct ib_mad *out_mad)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int c4iw_dealloc_ucontext(struct ib_ucontext *context)\r\n{\r\nstruct c4iw_dev *rhp = to_c4iw_dev(context->device);\r\nstruct c4iw_ucontext *ucontext = to_c4iw_ucontext(context);\r\nstruct c4iw_mm_entry *mm, *tmp;\r\nPDBG("%s context %p\n", __func__, context);\r\nlist_for_each_entry_safe(mm, tmp, &ucontext->mmaps, entry)\r\nkfree(mm);\r\nc4iw_release_dev_ucontext(&rhp->rdev, &ucontext->uctx);\r\nkfree(ucontext);\r\nreturn 0;\r\n}\r\nstatic struct ib_ucontext *c4iw_alloc_ucontext(struct ib_device *ibdev,\r\nstruct ib_udata *udata)\r\n{\r\nstruct c4iw_ucontext *context;\r\nstruct c4iw_dev *rhp = to_c4iw_dev(ibdev);\r\nstatic int warned;\r\nstruct c4iw_alloc_ucontext_resp uresp;\r\nint ret = 0;\r\nstruct c4iw_mm_entry *mm = NULL;\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\ncontext = kzalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nc4iw_init_dev_ucontext(&rhp->rdev, &context->uctx);\r\nINIT_LIST_HEAD(&context->mmaps);\r\nspin_lock_init(&context->mmap_lock);\r\nif (udata->outlen < sizeof(uresp) - sizeof(uresp.reserved)) {\r\nif (!warned++)\r\npr_err(MOD "Warning - downlevel libcxgb4 (non-fatal), device status page disabled.");\r\nrhp->rdev.flags |= T4_STATUS_PAGE_DISABLED;\r\n} else {\r\nmm = kmalloc(sizeof(*mm), GFP_KERNEL);\r\nif (!mm) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nuresp.status_page_size = PAGE_SIZE;\r\nspin_lock(&context->mmap_lock);\r\nuresp.status_page_key = context->key;\r\ncontext->key += PAGE_SIZE;\r\nspin_unlock(&context->mmap_lock);\r\nret = ib_copy_to_udata(udata, &uresp,\r\nsizeof(uresp) - sizeof(uresp.reserved));\r\nif (ret)\r\ngoto err_mm;\r\nmm->key = uresp.status_page_key;\r\nmm->addr = virt_to_phys(rhp->rdev.status_page);\r\nmm->len = PAGE_SIZE;\r\ninsert_mmap(context, mm);\r\n}\r\nreturn &context->ibucontext;\r\nerr_mm:\r\nkfree(mm);\r\nerr_free:\r\nkfree(context);\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int c4iw_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)\r\n{\r\nint len = vma->vm_end - vma->vm_start;\r\nu32 key = vma->vm_pgoff << PAGE_SHIFT;\r\nstruct c4iw_rdev *rdev;\r\nint ret = 0;\r\nstruct c4iw_mm_entry *mm;\r\nstruct c4iw_ucontext *ucontext;\r\nu64 addr;\r\nPDBG("%s pgoff 0x%lx key 0x%x len %d\n", __func__, vma->vm_pgoff,\r\nkey, len);\r\nif (vma->vm_start & (PAGE_SIZE-1))\r\nreturn -EINVAL;\r\nrdev = &(to_c4iw_dev(context->device)->rdev);\r\nucontext = to_c4iw_ucontext(context);\r\nmm = remove_mmap(ucontext, key, len);\r\nif (!mm)\r\nreturn -EINVAL;\r\naddr = mm->addr;\r\nkfree(mm);\r\nif ((addr >= pci_resource_start(rdev->lldi.pdev, 0)) &&\r\n(addr < (pci_resource_start(rdev->lldi.pdev, 0) +\r\npci_resource_len(rdev->lldi.pdev, 0)))) {\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nret = io_remap_pfn_range(vma, vma->vm_start,\r\naddr >> PAGE_SHIFT,\r\nlen, vma->vm_page_prot);\r\n} else if ((addr >= pci_resource_start(rdev->lldi.pdev, 2)) &&\r\n(addr < (pci_resource_start(rdev->lldi.pdev, 2) +\r\npci_resource_len(rdev->lldi.pdev, 2)))) {\r\nif (addr >= rdev->oc_mw_pa)\r\nvma->vm_page_prot = t4_pgprot_wc(vma->vm_page_prot);\r\nelse {\r\nif (is_t5(rdev->lldi.adapter_type))\r\nvma->vm_page_prot =\r\nt4_pgprot_wc(vma->vm_page_prot);\r\nelse\r\nvma->vm_page_prot =\r\npgprot_noncached(vma->vm_page_prot);\r\n}\r\nret = io_remap_pfn_range(vma, vma->vm_start,\r\naddr >> PAGE_SHIFT,\r\nlen, vma->vm_page_prot);\r\n} else {\r\nret = remap_pfn_range(vma, vma->vm_start,\r\naddr >> PAGE_SHIFT,\r\nlen, vma->vm_page_prot);\r\n}\r\nreturn ret;\r\n}\r\nstatic int c4iw_deallocate_pd(struct ib_pd *pd)\r\n{\r\nstruct c4iw_dev *rhp;\r\nstruct c4iw_pd *php;\r\nphp = to_c4iw_pd(pd);\r\nrhp = php->rhp;\r\nPDBG("%s ibpd %p pdid 0x%x\n", __func__, pd, php->pdid);\r\nc4iw_put_resource(&rhp->rdev.resource.pdid_table, php->pdid);\r\nmutex_lock(&rhp->rdev.stats.lock);\r\nrhp->rdev.stats.pd.cur--;\r\nmutex_unlock(&rhp->rdev.stats.lock);\r\nkfree(php);\r\nreturn 0;\r\n}\r\nstatic struct ib_pd *c4iw_allocate_pd(struct ib_device *ibdev,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct c4iw_pd *php;\r\nu32 pdid;\r\nstruct c4iw_dev *rhp;\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\nrhp = (struct c4iw_dev *) ibdev;\r\npdid = c4iw_get_resource(&rhp->rdev.resource.pdid_table);\r\nif (!pdid)\r\nreturn ERR_PTR(-EINVAL);\r\nphp = kzalloc(sizeof(*php), GFP_KERNEL);\r\nif (!php) {\r\nc4iw_put_resource(&rhp->rdev.resource.pdid_table, pdid);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nphp->pdid = pdid;\r\nphp->rhp = rhp;\r\nif (context) {\r\nif (ib_copy_to_udata(udata, &php->pdid, sizeof(u32))) {\r\nc4iw_deallocate_pd(&php->ibpd);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\n}\r\nmutex_lock(&rhp->rdev.stats.lock);\r\nrhp->rdev.stats.pd.cur++;\r\nif (rhp->rdev.stats.pd.cur > rhp->rdev.stats.pd.max)\r\nrhp->rdev.stats.pd.max = rhp->rdev.stats.pd.cur;\r\nmutex_unlock(&rhp->rdev.stats.lock);\r\nPDBG("%s pdid 0x%0x ptr 0x%p\n", __func__, pdid, php);\r\nreturn &php->ibpd;\r\n}\r\nstatic int c4iw_query_pkey(struct ib_device *ibdev, u8 port, u16 index,\r\nu16 *pkey)\r\n{\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\n*pkey = 0;\r\nreturn 0;\r\n}\r\nstatic int c4iw_query_gid(struct ib_device *ibdev, u8 port, int index,\r\nunion ib_gid *gid)\r\n{\r\nstruct c4iw_dev *dev;\r\nPDBG("%s ibdev %p, port %d, index %d, gid %p\n",\r\n__func__, ibdev, port, index, gid);\r\ndev = to_c4iw_dev(ibdev);\r\nBUG_ON(port == 0);\r\nmemset(&(gid->raw[0]), 0, sizeof(gid->raw));\r\nmemcpy(&(gid->raw[0]), dev->rdev.lldi.ports[port-1]->dev_addr, 6);\r\nreturn 0;\r\n}\r\nstatic int c4iw_query_device(struct ib_device *ibdev,\r\nstruct ib_device_attr *props)\r\n{\r\nstruct c4iw_dev *dev;\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\ndev = to_c4iw_dev(ibdev);\r\nmemset(props, 0, sizeof *props);\r\nmemcpy(&props->sys_image_guid, dev->rdev.lldi.ports[0]->dev_addr, 6);\r\nprops->hw_ver = CHELSIO_CHIP_RELEASE(dev->rdev.lldi.adapter_type);\r\nprops->fw_ver = dev->rdev.lldi.fw_vers;\r\nprops->device_cap_flags = dev->device_cap_flags;\r\nprops->page_size_cap = T4_PAGESIZE_MASK;\r\nprops->vendor_id = (u32)dev->rdev.lldi.pdev->vendor;\r\nprops->vendor_part_id = (u32)dev->rdev.lldi.pdev->device;\r\nprops->max_mr_size = T4_MAX_MR_SIZE;\r\nprops->max_qp = dev->rdev.lldi.vr->qp.size / 2;\r\nprops->max_qp_wr = dev->rdev.hw_queue.t4_max_qp_depth;\r\nprops->max_sge = T4_MAX_RECV_SGE;\r\nprops->max_sge_rd = 1;\r\nprops->max_res_rd_atom = dev->rdev.lldi.max_ird_adapter;\r\nprops->max_qp_rd_atom = min(dev->rdev.lldi.max_ordird_qp,\r\nc4iw_max_read_depth);\r\nprops->max_qp_init_rd_atom = props->max_qp_rd_atom;\r\nprops->max_cq = dev->rdev.lldi.vr->qp.size;\r\nprops->max_cqe = dev->rdev.hw_queue.t4_max_cq_depth;\r\nprops->max_mr = c4iw_num_stags(&dev->rdev);\r\nprops->max_pd = T4_MAX_NUM_PD;\r\nprops->local_ca_ack_delay = 0;\r\nprops->max_fast_reg_page_list_len = t4_max_fr_depth(use_dsgl);\r\nreturn 0;\r\n}\r\nstatic int c4iw_query_port(struct ib_device *ibdev, u8 port,\r\nstruct ib_port_attr *props)\r\n{\r\nstruct c4iw_dev *dev;\r\nstruct net_device *netdev;\r\nstruct in_device *inetdev;\r\nPDBG("%s ibdev %p\n", __func__, ibdev);\r\ndev = to_c4iw_dev(ibdev);\r\nnetdev = dev->rdev.lldi.ports[port-1];\r\nmemset(props, 0, sizeof(struct ib_port_attr));\r\nprops->max_mtu = IB_MTU_4096;\r\nif (netdev->mtu >= 4096)\r\nprops->active_mtu = IB_MTU_4096;\r\nelse if (netdev->mtu >= 2048)\r\nprops->active_mtu = IB_MTU_2048;\r\nelse if (netdev->mtu >= 1024)\r\nprops->active_mtu = IB_MTU_1024;\r\nelse if (netdev->mtu >= 512)\r\nprops->active_mtu = IB_MTU_512;\r\nelse\r\nprops->active_mtu = IB_MTU_256;\r\nif (!netif_carrier_ok(netdev))\r\nprops->state = IB_PORT_DOWN;\r\nelse {\r\ninetdev = in_dev_get(netdev);\r\nif (inetdev) {\r\nif (inetdev->ifa_list)\r\nprops->state = IB_PORT_ACTIVE;\r\nelse\r\nprops->state = IB_PORT_INIT;\r\nin_dev_put(inetdev);\r\n} else\r\nprops->state = IB_PORT_INIT;\r\n}\r\nprops->port_cap_flags =\r\nIB_PORT_CM_SUP |\r\nIB_PORT_SNMP_TUNNEL_SUP |\r\nIB_PORT_REINIT_SUP |\r\nIB_PORT_DEVICE_MGMT_SUP |\r\nIB_PORT_VENDOR_CLASS_SUP | IB_PORT_BOOT_MGMT_SUP;\r\nprops->gid_tbl_len = 1;\r\nprops->pkey_tbl_len = 1;\r\nprops->active_width = 2;\r\nprops->active_speed = IB_SPEED_DDR;\r\nprops->max_msg_sz = -1;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_rev(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct c4iw_dev *c4iw_dev = container_of(dev, struct c4iw_dev,\r\nibdev.dev);\r\nPDBG("%s dev 0x%p\n", __func__, dev);\r\nreturn sprintf(buf, "%d\n",\r\nCHELSIO_CHIP_RELEASE(c4iw_dev->rdev.lldi.adapter_type));\r\n}\r\nstatic ssize_t show_fw_ver(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct c4iw_dev *c4iw_dev = container_of(dev, struct c4iw_dev,\r\nibdev.dev);\r\nPDBG("%s dev 0x%p\n", __func__, dev);\r\nreturn sprintf(buf, "%u.%u.%u.%u\n",\r\nFW_HDR_FW_VER_MAJOR_GET(c4iw_dev->rdev.lldi.fw_vers),\r\nFW_HDR_FW_VER_MINOR_GET(c4iw_dev->rdev.lldi.fw_vers),\r\nFW_HDR_FW_VER_MICRO_GET(c4iw_dev->rdev.lldi.fw_vers),\r\nFW_HDR_FW_VER_BUILD_GET(c4iw_dev->rdev.lldi.fw_vers));\r\n}\r\nstatic ssize_t show_hca(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct c4iw_dev *c4iw_dev = container_of(dev, struct c4iw_dev,\r\nibdev.dev);\r\nstruct ethtool_drvinfo info;\r\nstruct net_device *lldev = c4iw_dev->rdev.lldi.ports[0];\r\nPDBG("%s dev 0x%p\n", __func__, dev);\r\nlldev->ethtool_ops->get_drvinfo(lldev, &info);\r\nreturn sprintf(buf, "%s\n", info.driver);\r\n}\r\nstatic ssize_t show_board(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct c4iw_dev *c4iw_dev = container_of(dev, struct c4iw_dev,\r\nibdev.dev);\r\nPDBG("%s dev 0x%p\n", __func__, dev);\r\nreturn sprintf(buf, "%x.%x\n", c4iw_dev->rdev.lldi.pdev->vendor,\r\nc4iw_dev->rdev.lldi.pdev->device);\r\n}\r\nstatic int c4iw_get_mib(struct ib_device *ibdev,\r\nunion rdma_protocol_stats *stats)\r\n{\r\nstruct tp_tcp_stats v4, v6;\r\nstruct c4iw_dev *c4iw_dev = to_c4iw_dev(ibdev);\r\ncxgb4_get_tcp_stats(c4iw_dev->rdev.lldi.pdev, &v4, &v6);\r\nmemset(stats, 0, sizeof *stats);\r\nstats->iw.tcpInSegs = v4.tcpInSegs + v6.tcpInSegs;\r\nstats->iw.tcpOutSegs = v4.tcpOutSegs + v6.tcpOutSegs;\r\nstats->iw.tcpRetransSegs = v4.tcpRetransSegs + v6.tcpRetransSegs;\r\nstats->iw.tcpOutRsts = v4.tcpOutRsts + v6.tcpOutSegs;\r\nreturn 0;\r\n}\r\nint c4iw_register_device(struct c4iw_dev *dev)\r\n{\r\nint ret;\r\nint i;\r\nPDBG("%s c4iw_dev %p\n", __func__, dev);\r\nBUG_ON(!dev->rdev.lldi.ports[0]);\r\nstrlcpy(dev->ibdev.name, "cxgb4_%d", IB_DEVICE_NAME_MAX);\r\nmemset(&dev->ibdev.node_guid, 0, sizeof(dev->ibdev.node_guid));\r\nmemcpy(&dev->ibdev.node_guid, dev->rdev.lldi.ports[0]->dev_addr, 6);\r\ndev->ibdev.owner = THIS_MODULE;\r\ndev->device_cap_flags = IB_DEVICE_LOCAL_DMA_LKEY | IB_DEVICE_MEM_WINDOW;\r\nif (fastreg_support)\r\ndev->device_cap_flags |= IB_DEVICE_MEM_MGT_EXTENSIONS;\r\ndev->ibdev.local_dma_lkey = 0;\r\ndev->ibdev.uverbs_cmd_mask =\r\n(1ull << IB_USER_VERBS_CMD_GET_CONTEXT) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_DEVICE) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_PORT) |\r\n(1ull << IB_USER_VERBS_CMD_ALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_DEALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_REG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_DEREG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_REQ_NOTIFY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_QP) |\r\n(1ull << IB_USER_VERBS_CMD_MODIFY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POLL_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POST_SEND) |\r\n(1ull << IB_USER_VERBS_CMD_POST_RECV);\r\ndev->ibdev.node_type = RDMA_NODE_RNIC;\r\nmemcpy(dev->ibdev.node_desc, C4IW_NODE_DESC, sizeof(C4IW_NODE_DESC));\r\ndev->ibdev.phys_port_cnt = dev->rdev.lldi.nports;\r\ndev->ibdev.num_comp_vectors = dev->rdev.lldi.nciq;\r\ndev->ibdev.dma_device = &(dev->rdev.lldi.pdev->dev);\r\ndev->ibdev.query_device = c4iw_query_device;\r\ndev->ibdev.query_port = c4iw_query_port;\r\ndev->ibdev.query_pkey = c4iw_query_pkey;\r\ndev->ibdev.query_gid = c4iw_query_gid;\r\ndev->ibdev.alloc_ucontext = c4iw_alloc_ucontext;\r\ndev->ibdev.dealloc_ucontext = c4iw_dealloc_ucontext;\r\ndev->ibdev.mmap = c4iw_mmap;\r\ndev->ibdev.alloc_pd = c4iw_allocate_pd;\r\ndev->ibdev.dealloc_pd = c4iw_deallocate_pd;\r\ndev->ibdev.create_ah = c4iw_ah_create;\r\ndev->ibdev.destroy_ah = c4iw_ah_destroy;\r\ndev->ibdev.create_qp = c4iw_create_qp;\r\ndev->ibdev.modify_qp = c4iw_ib_modify_qp;\r\ndev->ibdev.query_qp = c4iw_ib_query_qp;\r\ndev->ibdev.destroy_qp = c4iw_destroy_qp;\r\ndev->ibdev.create_cq = c4iw_create_cq;\r\ndev->ibdev.destroy_cq = c4iw_destroy_cq;\r\ndev->ibdev.resize_cq = c4iw_resize_cq;\r\ndev->ibdev.poll_cq = c4iw_poll_cq;\r\ndev->ibdev.get_dma_mr = c4iw_get_dma_mr;\r\ndev->ibdev.reg_phys_mr = c4iw_register_phys_mem;\r\ndev->ibdev.rereg_phys_mr = c4iw_reregister_phys_mem;\r\ndev->ibdev.reg_user_mr = c4iw_reg_user_mr;\r\ndev->ibdev.dereg_mr = c4iw_dereg_mr;\r\ndev->ibdev.alloc_mw = c4iw_alloc_mw;\r\ndev->ibdev.bind_mw = c4iw_bind_mw;\r\ndev->ibdev.dealloc_mw = c4iw_dealloc_mw;\r\ndev->ibdev.alloc_fast_reg_mr = c4iw_alloc_fast_reg_mr;\r\ndev->ibdev.alloc_fast_reg_page_list = c4iw_alloc_fastreg_pbl;\r\ndev->ibdev.free_fast_reg_page_list = c4iw_free_fastreg_pbl;\r\ndev->ibdev.attach_mcast = c4iw_multicast_attach;\r\ndev->ibdev.detach_mcast = c4iw_multicast_detach;\r\ndev->ibdev.process_mad = c4iw_process_mad;\r\ndev->ibdev.req_notify_cq = c4iw_arm_cq;\r\ndev->ibdev.post_send = c4iw_post_send;\r\ndev->ibdev.post_recv = c4iw_post_receive;\r\ndev->ibdev.get_protocol_stats = c4iw_get_mib;\r\ndev->ibdev.uverbs_abi_ver = C4IW_UVERBS_ABI_VERSION;\r\ndev->ibdev.iwcm = kmalloc(sizeof(struct iw_cm_verbs), GFP_KERNEL);\r\nif (!dev->ibdev.iwcm)\r\nreturn -ENOMEM;\r\ndev->ibdev.iwcm->connect = c4iw_connect;\r\ndev->ibdev.iwcm->accept = c4iw_accept_cr;\r\ndev->ibdev.iwcm->reject = c4iw_reject_cr;\r\ndev->ibdev.iwcm->create_listen = c4iw_create_listen;\r\ndev->ibdev.iwcm->destroy_listen = c4iw_destroy_listen;\r\ndev->ibdev.iwcm->add_ref = c4iw_qp_add_ref;\r\ndev->ibdev.iwcm->rem_ref = c4iw_qp_rem_ref;\r\ndev->ibdev.iwcm->get_qp = c4iw_get_qp;\r\nret = ib_register_device(&dev->ibdev, NULL);\r\nif (ret)\r\ngoto bail1;\r\nfor (i = 0; i < ARRAY_SIZE(c4iw_class_attributes); ++i) {\r\nret = device_create_file(&dev->ibdev.dev,\r\nc4iw_class_attributes[i]);\r\nif (ret)\r\ngoto bail2;\r\n}\r\nreturn 0;\r\nbail2:\r\nib_unregister_device(&dev->ibdev);\r\nbail1:\r\nkfree(dev->ibdev.iwcm);\r\nreturn ret;\r\n}\r\nvoid c4iw_unregister_device(struct c4iw_dev *dev)\r\n{\r\nint i;\r\nPDBG("%s c4iw_dev %p\n", __func__, dev);\r\nfor (i = 0; i < ARRAY_SIZE(c4iw_class_attributes); ++i)\r\ndevice_remove_file(&dev->ibdev.dev,\r\nc4iw_class_attributes[i]);\r\nib_unregister_device(&dev->ibdev);\r\nkfree(dev->ibdev.iwcm);\r\nreturn;\r\n}
