static inline u64 sst_byt_header(int msg_id, int data, bool large, int str_id)\r\n{\r\nu64 header;\r\nheader = IPC_HEADER_MSG_ID(msg_id) |\r\nIPC_HEADER_STR_ID(str_id) |\r\nIPC_HEADER_LARGE(large) |\r\nIPC_HEADER_DATA(data) |\r\nSST_BYT_IPCX_BUSY;\r\nreturn header;\r\n}\r\nstatic inline u16 sst_byt_header_msg_id(u64 header)\r\n{\r\nreturn header & IPC_HEADER_MSG_ID_MASK;\r\n}\r\nstatic inline u8 sst_byt_header_str_id(u64 header)\r\n{\r\nreturn (header >> IPC_HEADER_STR_ID_SHIFT) & IPC_HEADER_STR_ID_MASK;\r\n}\r\nstatic inline u16 sst_byt_header_data(u64 header)\r\n{\r\nreturn (header >> IPC_HEADER_DATA_SHIFT) & IPC_HEADER_DATA_MASK;\r\n}\r\nstatic struct sst_byt_stream *sst_byt_get_stream(struct sst_byt *byt,\r\nint stream_id)\r\n{\r\nstruct sst_byt_stream *stream;\r\nlist_for_each_entry(stream, &byt->stream_list, node) {\r\nif (stream->str_id == stream_id)\r\nreturn stream;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sst_byt_ipc_shim_dbg(struct sst_byt *byt, const char *text)\r\n{\r\nstruct sst_dsp *sst = byt->dsp;\r\nu64 isr, ipcd, imrx, ipcx;\r\nipcx = sst_dsp_shim_read64_unlocked(sst, SST_IPCX);\r\nisr = sst_dsp_shim_read64_unlocked(sst, SST_ISRX);\r\nipcd = sst_dsp_shim_read64_unlocked(sst, SST_IPCD);\r\nimrx = sst_dsp_shim_read64_unlocked(sst, SST_IMRX);\r\ndev_err(byt->dev,\r\n"ipc: --%s-- ipcx 0x%llx isr 0x%llx ipcd 0x%llx imrx 0x%llx\n",\r\ntext, ipcx, isr, ipcd, imrx);\r\n}\r\nstatic struct ipc_message *sst_byt_msg_get_empty(struct sst_byt *byt)\r\n{\r\nstruct ipc_message *msg = NULL;\r\nif (!list_empty(&byt->empty_list)) {\r\nmsg = list_first_entry(&byt->empty_list,\r\nstruct ipc_message, list);\r\nlist_del(&msg->list);\r\n}\r\nreturn msg;\r\n}\r\nstatic void sst_byt_ipc_tx_msgs(struct kthread_work *work)\r\n{\r\nstruct sst_byt *byt =\r\ncontainer_of(work, struct sst_byt, kwork);\r\nstruct ipc_message *msg;\r\nu64 ipcx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&byt->dsp->spinlock, flags);\r\nif (list_empty(&byt->tx_list)) {\r\nspin_unlock_irqrestore(&byt->dsp->spinlock, flags);\r\nreturn;\r\n}\r\nipcx = sst_dsp_shim_read64_unlocked(byt->dsp, SST_IPCX);\r\nif (ipcx & SST_BYT_IPCX_BUSY) {\r\nspin_unlock_irqrestore(&byt->dsp->spinlock, flags);\r\nreturn;\r\n}\r\nmsg = list_first_entry(&byt->tx_list, struct ipc_message, list);\r\nlist_move(&msg->list, &byt->rx_list);\r\nif (msg->header & IPC_HEADER_LARGE(true))\r\nsst_dsp_outbox_write(byt->dsp, msg->tx_data, msg->tx_size);\r\nsst_dsp_shim_write64_unlocked(byt->dsp, SST_IPCX, msg->header);\r\nspin_unlock_irqrestore(&byt->dsp->spinlock, flags);\r\n}\r\nstatic inline void sst_byt_tx_msg_reply_complete(struct sst_byt *byt,\r\nstruct ipc_message *msg)\r\n{\r\nmsg->complete = true;\r\nif (!msg->wait)\r\nlist_add_tail(&msg->list, &byt->empty_list);\r\nelse\r\nwake_up(&msg->waitq);\r\n}\r\nstatic void sst_byt_drop_all(struct sst_byt *byt)\r\n{\r\nstruct ipc_message *msg, *tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&byt->dsp->spinlock, flags);\r\nlist_for_each_entry_safe(msg, tmp, &byt->tx_list, list) {\r\nlist_move(&msg->list, &byt->empty_list);\r\n}\r\nlist_for_each_entry_safe(msg, tmp, &byt->rx_list, list) {\r\nlist_move(&msg->list, &byt->empty_list);\r\n}\r\nspin_unlock_irqrestore(&byt->dsp->spinlock, flags);\r\n}\r\nstatic int sst_byt_tx_wait_done(struct sst_byt *byt, struct ipc_message *msg,\r\nvoid *rx_data)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nret = wait_event_timeout(msg->waitq, msg->complete,\r\nmsecs_to_jiffies(IPC_TIMEOUT_MSECS));\r\nspin_lock_irqsave(&byt->dsp->spinlock, flags);\r\nif (ret == 0) {\r\nlist_del(&msg->list);\r\nsst_byt_ipc_shim_dbg(byt, "message timeout");\r\nret = -ETIMEDOUT;\r\n} else {\r\nif (msg->rx_size)\r\nmemcpy(rx_data, msg->rx_data, msg->rx_size);\r\nret = msg->errno;\r\n}\r\nlist_add_tail(&msg->list, &byt->empty_list);\r\nspin_unlock_irqrestore(&byt->dsp->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic int sst_byt_ipc_tx_message(struct sst_byt *byt, u64 header,\r\nvoid *tx_data, size_t tx_bytes,\r\nvoid *rx_data, size_t rx_bytes, int wait)\r\n{\r\nunsigned long flags;\r\nstruct ipc_message *msg;\r\nspin_lock_irqsave(&byt->dsp->spinlock, flags);\r\nmsg = sst_byt_msg_get_empty(byt);\r\nif (msg == NULL) {\r\nspin_unlock_irqrestore(&byt->dsp->spinlock, flags);\r\nreturn -EBUSY;\r\n}\r\nmsg->header = header;\r\nmsg->tx_size = tx_bytes;\r\nmsg->rx_size = rx_bytes;\r\nmsg->wait = wait;\r\nmsg->errno = 0;\r\nmsg->complete = false;\r\nif (tx_bytes) {\r\n*(u32 *)msg->tx_data = (u32)(header & (u32)-1);\r\nmemcpy(msg->tx_data + sizeof(u32), tx_data, tx_bytes);\r\nmsg->tx_size += sizeof(u32);\r\n}\r\nlist_add_tail(&msg->list, &byt->tx_list);\r\nspin_unlock_irqrestore(&byt->dsp->spinlock, flags);\r\nqueue_kthread_work(&byt->kworker, &byt->kwork);\r\nif (wait)\r\nreturn sst_byt_tx_wait_done(byt, msg, rx_data);\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int sst_byt_ipc_tx_msg_wait(struct sst_byt *byt, u64 header,\r\nvoid *tx_data, size_t tx_bytes,\r\nvoid *rx_data, size_t rx_bytes)\r\n{\r\nreturn sst_byt_ipc_tx_message(byt, header, tx_data, tx_bytes,\r\nrx_data, rx_bytes, 1);\r\n}\r\nstatic inline int sst_byt_ipc_tx_msg_nowait(struct sst_byt *byt, u64 header,\r\nvoid *tx_data, size_t tx_bytes)\r\n{\r\nreturn sst_byt_ipc_tx_message(byt, header, tx_data, tx_bytes,\r\nNULL, 0, 0);\r\n}\r\nstatic struct ipc_message *sst_byt_reply_find_msg(struct sst_byt *byt,\r\nu64 header)\r\n{\r\nstruct ipc_message *msg = NULL, *_msg;\r\nu64 mask;\r\nmask = IPC_HEADER_MSG_ID_MASK |\r\nIPC_HEADER_STR_ID_MASK << IPC_HEADER_STR_ID_SHIFT;\r\nheader &= mask;\r\nif (list_empty(&byt->rx_list)) {\r\ndev_err(byt->dev,\r\n"ipc: rx list is empty but received 0x%llx\n", header);\r\ngoto out;\r\n}\r\nlist_for_each_entry(_msg, &byt->rx_list, list) {\r\nif ((_msg->header & mask) == header) {\r\nmsg = _msg;\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn msg;\r\n}\r\nstatic void sst_byt_stream_update(struct sst_byt *byt, struct ipc_message *msg)\r\n{\r\nstruct sst_byt_stream *stream;\r\nu64 header = msg->header;\r\nu8 stream_id = sst_byt_header_str_id(header);\r\nu8 stream_msg = sst_byt_header_msg_id(header);\r\nstream = sst_byt_get_stream(byt, stream_id);\r\nif (stream == NULL)\r\nreturn;\r\nswitch (stream_msg) {\r\ncase IPC_IA_DROP_STREAM:\r\ncase IPC_IA_PAUSE_STREAM:\r\ncase IPC_IA_FREE_STREAM:\r\nstream->running = false;\r\nbreak;\r\ncase IPC_IA_START_STREAM:\r\ncase IPC_IA_RESUME_STREAM:\r\nstream->running = true;\r\nbreak;\r\n}\r\n}\r\nstatic int sst_byt_process_reply(struct sst_byt *byt, u64 header)\r\n{\r\nstruct ipc_message *msg;\r\nmsg = sst_byt_reply_find_msg(byt, header);\r\nif (msg == NULL)\r\nreturn 1;\r\nif (header & IPC_HEADER_LARGE(true)) {\r\nmsg->rx_size = sst_byt_header_data(header);\r\nsst_dsp_inbox_read(byt->dsp, msg->rx_data, msg->rx_size);\r\n}\r\nsst_byt_stream_update(byt, msg);\r\nlist_del(&msg->list);\r\nsst_byt_tx_msg_reply_complete(byt, msg);\r\nreturn 1;\r\n}\r\nstatic void sst_byt_fw_ready(struct sst_byt *byt, u64 header)\r\n{\r\ndev_dbg(byt->dev, "ipc: DSP is ready 0x%llX\n", header);\r\nbyt->boot_complete = true;\r\nwake_up(&byt->boot_wait);\r\n}\r\nstatic int sst_byt_process_notification(struct sst_byt *byt,\r\nunsigned long *flags)\r\n{\r\nstruct sst_dsp *sst = byt->dsp;\r\nstruct sst_byt_stream *stream;\r\nu64 header;\r\nu8 msg_id, stream_id;\r\nint handled = 1;\r\nheader = sst_dsp_shim_read64_unlocked(sst, SST_IPCD);\r\nmsg_id = sst_byt_header_msg_id(header);\r\nswitch (msg_id) {\r\ncase IPC_SST_PERIOD_ELAPSED:\r\nstream_id = sst_byt_header_str_id(header);\r\nstream = sst_byt_get_stream(byt, stream_id);\r\nif (stream && stream->running && stream->notify_position) {\r\nspin_unlock_irqrestore(&sst->spinlock, *flags);\r\nstream->notify_position(stream, stream->pdata);\r\nspin_lock_irqsave(&sst->spinlock, *flags);\r\n}\r\nbreak;\r\ncase IPC_IA_FW_INIT_CMPLT:\r\nsst_byt_fw_ready(byt, header);\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t sst_byt_irq_thread(int irq, void *context)\r\n{\r\nstruct sst_dsp *sst = (struct sst_dsp *) context;\r\nstruct sst_byt *byt = sst_dsp_get_thread_context(sst);\r\nu64 header;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nheader = sst_dsp_shim_read64_unlocked(sst, SST_IPCD);\r\nif (header & SST_BYT_IPCD_BUSY) {\r\nif (header & IPC_NOTIFICATION) {\r\nsst_byt_process_notification(byt, &flags);\r\n} else {\r\nsst_byt_process_reply(byt, header);\r\n}\r\nsst_dsp_shim_update_bits64_unlocked(sst, SST_IPCD,\r\nSST_BYT_IPCD_DONE | SST_BYT_IPCD_BUSY |\r\nIPC_HEADER_DATA(IPC_HEADER_DATA_MASK),\r\nSST_BYT_IPCD_DONE);\r\nsst_dsp_shim_update_bits64_unlocked(sst, SST_IMRX,\r\nSST_BYT_IMRX_REQUEST, 0);\r\n}\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nqueue_kthread_work(&byt->kworker, &byt->kwork);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct sst_byt_stream *sst_byt_stream_new(struct sst_byt *byt, int id,\r\nu32 (*notify_position)(struct sst_byt_stream *stream, void *data),\r\nvoid *data)\r\n{\r\nstruct sst_byt_stream *stream;\r\nstruct sst_dsp *sst = byt->dsp;\r\nunsigned long flags;\r\nstream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (stream == NULL)\r\nreturn NULL;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nlist_add(&stream->node, &byt->stream_list);\r\nstream->notify_position = notify_position;\r\nstream->pdata = data;\r\nstream->byt = byt;\r\nstream->str_id = id;\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn stream;\r\n}\r\nint sst_byt_stream_set_bits(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nint bits)\r\n{\r\nstream->request.pcm_params.pcm_wd_sz = bits;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_set_channels(struct sst_byt *byt,\r\nstruct sst_byt_stream *stream, u8 channels)\r\n{\r\nstream->request.pcm_params.num_chan = channels;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_set_rate(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nunsigned int rate)\r\n{\r\nstream->request.pcm_params.sfreq = rate;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_type(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nint codec_type, int stream_type, int operation)\r\n{\r\nstream->request.str_type.codec_type = codec_type;\r\nstream->request.str_type.str_type = stream_type;\r\nstream->request.str_type.operation = operation;\r\nstream->request.str_type.time_slots = 0xc;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_buffer(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nuint32_t buffer_addr, uint32_t buffer_size)\r\n{\r\nstream->request.frame_info.num_entries = 1;\r\nstream->request.frame_info.ring_buf_info[0].addr = buffer_addr;\r\nstream->request.frame_info.ring_buf_info[0].size = buffer_size;\r\nstream->request.frame_info.frag_size =\r\nstream->request.pcm_params.sfreq *\r\nstream->request.pcm_params.num_chan *\r\nstream->request.pcm_params.pcm_wd_sz / 8 *\r\n4 / 1000;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_commit(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nstruct sst_byt_alloc_params *str_req = &stream->request;\r\nstruct sst_byt_alloc_response *reply = &stream->reply;\r\nu64 header;\r\nint ret;\r\nheader = sst_byt_header(IPC_IA_ALLOC_STREAM,\r\nsizeof(*str_req) + sizeof(u32),\r\ntrue, stream->str_id);\r\nret = sst_byt_ipc_tx_msg_wait(byt, header, str_req, sizeof(*str_req),\r\nreply, sizeof(*reply));\r\nif (ret < 0) {\r\ndev_err(byt->dev, "ipc: error stream commit failed\n");\r\nreturn ret;\r\n}\r\nstream->commited = true;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_free(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nu64 header;\r\nint ret = 0;\r\nstruct sst_dsp *sst = byt->dsp;\r\nunsigned long flags;\r\nif (!stream->commited)\r\ngoto out;\r\nheader = sst_byt_header(IPC_IA_FREE_STREAM, 0, false, stream->str_id);\r\nret = sst_byt_ipc_tx_msg_wait(byt, header, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(byt->dev, "ipc: free stream %d failed\n",\r\nstream->str_id);\r\nreturn -EAGAIN;\r\n}\r\nstream->commited = false;\r\nout:\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nlist_del(&stream->node);\r\nkfree(stream);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic int sst_byt_stream_operations(struct sst_byt *byt, int type,\r\nint stream_id, int wait)\r\n{\r\nu64 header;\r\nheader = sst_byt_header(type, 0, false, stream_id);\r\nif (wait)\r\nreturn sst_byt_ipc_tx_msg_wait(byt, header, NULL, 0, NULL, 0);\r\nelse\r\nreturn sst_byt_ipc_tx_msg_nowait(byt, header, NULL, 0);\r\n}\r\nint sst_byt_stream_start(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nu32 start_offset)\r\n{\r\nstruct sst_byt_start_stream_params start_stream;\r\nvoid *tx_msg;\r\nsize_t size;\r\nu64 header;\r\nint ret;\r\nstart_stream.byte_offset = start_offset;\r\nheader = sst_byt_header(IPC_IA_START_STREAM,\r\nsizeof(start_stream) + sizeof(u32),\r\ntrue, stream->str_id);\r\ntx_msg = &start_stream;\r\nsize = sizeof(start_stream);\r\nret = sst_byt_ipc_tx_msg_nowait(byt, header, tx_msg, size);\r\nif (ret < 0)\r\ndev_err(byt->dev, "ipc: error failed to start stream %d\n",\r\nstream->str_id);\r\nreturn ret;\r\n}\r\nint sst_byt_stream_stop(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nint ret;\r\nif (!stream->commited)\r\nreturn 0;\r\nret = sst_byt_stream_operations(byt, IPC_IA_DROP_STREAM,\r\nstream->str_id, 0);\r\nif (ret < 0)\r\ndev_err(byt->dev, "ipc: error failed to stop stream %d\n",\r\nstream->str_id);\r\nreturn ret;\r\n}\r\nint sst_byt_stream_pause(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nint ret;\r\nret = sst_byt_stream_operations(byt, IPC_IA_PAUSE_STREAM,\r\nstream->str_id, 0);\r\nif (ret < 0)\r\ndev_err(byt->dev, "ipc: error failed to pause stream %d\n",\r\nstream->str_id);\r\nreturn ret;\r\n}\r\nint sst_byt_stream_resume(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nint ret;\r\nret = sst_byt_stream_operations(byt, IPC_IA_RESUME_STREAM,\r\nstream->str_id, 0);\r\nif (ret < 0)\r\ndev_err(byt->dev, "ipc: error failed to resume stream %d\n",\r\nstream->str_id);\r\nreturn ret;\r\n}\r\nint sst_byt_get_dsp_position(struct sst_byt *byt,\r\nstruct sst_byt_stream *stream, int buffer_size)\r\n{\r\nstruct sst_dsp *sst = byt->dsp;\r\nstruct sst_byt_tstamp fw_tstamp;\r\nu8 str_id = stream->str_id;\r\nu32 tstamp_offset;\r\ntstamp_offset = SST_BYT_TIMESTAMP_OFFSET + str_id * sizeof(fw_tstamp);\r\nmemcpy_fromio(&fw_tstamp,\r\nsst->addr.lpe + tstamp_offset, sizeof(fw_tstamp));\r\nreturn do_div(fw_tstamp.ring_buffer_counter, buffer_size);\r\n}\r\nstatic int msg_empty_list_init(struct sst_byt *byt)\r\n{\r\nstruct ipc_message *msg;\r\nint i;\r\nbyt->msg = kzalloc(sizeof(*msg) * IPC_EMPTY_LIST_SIZE, GFP_KERNEL);\r\nif (byt->msg == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < IPC_EMPTY_LIST_SIZE; i++) {\r\ninit_waitqueue_head(&byt->msg[i].waitq);\r\nlist_add(&byt->msg[i].list, &byt->empty_list);\r\n}\r\nreturn 0;\r\n}\r\nstruct sst_dsp *sst_byt_get_dsp(struct sst_byt *byt)\r\n{\r\nreturn byt->dsp;\r\n}\r\nint sst_byt_dsp_suspend_late(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt = pdata->dsp;\r\ndev_dbg(byt->dev, "dsp reset\n");\r\nsst_dsp_reset(byt->dsp);\r\nsst_byt_drop_all(byt);\r\ndev_dbg(byt->dev, "dsp in reset\n");\r\ndev_dbg(byt->dev, "free all blocks and unload fw\n");\r\nsst_fw_unload(byt->fw);\r\nreturn 0;\r\n}\r\nint sst_byt_dsp_boot(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt = pdata->dsp;\r\nint ret;\r\ndev_dbg(byt->dev, "reload dsp fw\n");\r\nsst_dsp_reset(byt->dsp);\r\nret = sst_fw_reload(byt->fw);\r\nif (ret < 0) {\r\ndev_err(dev, "error: failed to reload firmware\n");\r\nreturn ret;\r\n}\r\nbyt->boot_complete = false;\r\nsst_dsp_boot(byt->dsp);\r\ndev_dbg(byt->dev, "dsp booting...\n");\r\nreturn 0;\r\n}\r\nint sst_byt_dsp_wait_for_ready(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt = pdata->dsp;\r\nint err;\r\ndev_dbg(byt->dev, "wait for dsp reboot\n");\r\nerr = wait_event_timeout(byt->boot_wait, byt->boot_complete,\r\nmsecs_to_jiffies(IPC_BOOT_MSECS));\r\nif (err == 0) {\r\ndev_err(byt->dev, "ipc: error DSP boot timeout\n");\r\nreturn -EIO;\r\n}\r\ndev_dbg(byt->dev, "dsp rebooted\n");\r\nreturn 0;\r\n}\r\nint sst_byt_dsp_init(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt;\r\nstruct sst_fw *byt_sst_fw;\r\nstruct sst_byt_fw_init init;\r\nint err;\r\ndev_dbg(dev, "initialising Byt DSP IPC\n");\r\nbyt = devm_kzalloc(dev, sizeof(*byt), GFP_KERNEL);\r\nif (byt == NULL)\r\nreturn -ENOMEM;\r\nbyt->dev = dev;\r\nINIT_LIST_HEAD(&byt->stream_list);\r\nINIT_LIST_HEAD(&byt->tx_list);\r\nINIT_LIST_HEAD(&byt->rx_list);\r\nINIT_LIST_HEAD(&byt->empty_list);\r\ninit_waitqueue_head(&byt->boot_wait);\r\ninit_waitqueue_head(&byt->wait_txq);\r\nerr = msg_empty_list_init(byt);\r\nif (err < 0)\r\nreturn -ENOMEM;\r\ninit_kthread_worker(&byt->kworker);\r\nbyt->tx_thread = kthread_run(kthread_worker_fn,\r\n&byt->kworker, "%s",\r\ndev_name(byt->dev));\r\nif (IS_ERR(byt->tx_thread)) {\r\nerr = PTR_ERR(byt->tx_thread);\r\ndev_err(byt->dev, "error failed to create message TX task\n");\r\ngoto err_free_msg;\r\n}\r\ninit_kthread_work(&byt->kwork, sst_byt_ipc_tx_msgs);\r\nbyt_dev.thread_context = byt;\r\nbyt->dsp = sst_dsp_new(dev, &byt_dev, pdata);\r\nif (byt->dsp == NULL) {\r\nerr = -ENODEV;\r\ngoto dsp_err;\r\n}\r\nsst_dsp_reset(byt->dsp);\r\nbyt_sst_fw = sst_fw_new(byt->dsp, pdata->fw, byt);\r\nif (byt_sst_fw == NULL) {\r\nerr = -ENODEV;\r\ndev_err(dev, "error: failed to load firmware\n");\r\ngoto fw_err;\r\n}\r\nsst_dsp_boot(byt->dsp);\r\nerr = wait_event_timeout(byt->boot_wait, byt->boot_complete,\r\nmsecs_to_jiffies(IPC_BOOT_MSECS));\r\nif (err == 0) {\r\nerr = -EIO;\r\ndev_err(byt->dev, "ipc: error DSP boot timeout\n");\r\ngoto boot_err;\r\n}\r\nsst_dsp_inbox_read(byt->dsp, &init, sizeof(init));\r\ndev_info(byt->dev, "FW version: %02x.%02x.%02x.%02x\n",\r\ninit.fw_version.major, init.fw_version.minor,\r\ninit.fw_version.build, init.fw_version.type);\r\ndev_info(byt->dev, "Build type: %x\n", init.fw_version.type);\r\ndev_info(byt->dev, "Build date: %s %s\n",\r\ninit.build_info.date, init.build_info.time);\r\npdata->dsp = byt;\r\nbyt->fw = byt_sst_fw;\r\nreturn 0;\r\nboot_err:\r\nsst_dsp_reset(byt->dsp);\r\nsst_fw_free(byt_sst_fw);\r\nfw_err:\r\nsst_dsp_free(byt->dsp);\r\ndsp_err:\r\nkthread_stop(byt->tx_thread);\r\nerr_free_msg:\r\nkfree(byt->msg);\r\nreturn err;\r\n}\r\nvoid sst_byt_dsp_free(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt = pdata->dsp;\r\nsst_dsp_reset(byt->dsp);\r\nsst_fw_free_all(byt->dsp);\r\nsst_dsp_free(byt->dsp);\r\nkthread_stop(byt->tx_thread);\r\nkfree(byt->msg);\r\n}
