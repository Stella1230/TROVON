static struct rxrpc_conn_bundle *rxrpc_alloc_bundle(gfp_t gfp)\r\n{\r\nstruct rxrpc_conn_bundle *bundle;\r\n_enter("");\r\nbundle = kzalloc(sizeof(struct rxrpc_conn_bundle), gfp);\r\nif (bundle) {\r\nINIT_LIST_HEAD(&bundle->unused_conns);\r\nINIT_LIST_HEAD(&bundle->avail_conns);\r\nINIT_LIST_HEAD(&bundle->busy_conns);\r\ninit_waitqueue_head(&bundle->chanwait);\r\natomic_set(&bundle->usage, 1);\r\n}\r\n_leave(" = %p", bundle);\r\nreturn bundle;\r\n}\r\nstatic inline\r\nint rxrpc_cmp_bundle(const struct rxrpc_conn_bundle *bundle,\r\nstruct key *key, __be16 service_id)\r\n{\r\nreturn (bundle->service_id - service_id) ?:\r\n((unsigned long) bundle->key - (unsigned long) key);\r\n}\r\nstruct rxrpc_conn_bundle *rxrpc_get_bundle(struct rxrpc_sock *rx,\r\nstruct rxrpc_transport *trans,\r\nstruct key *key,\r\n__be16 service_id,\r\ngfp_t gfp)\r\n{\r\nstruct rxrpc_conn_bundle *bundle, *candidate;\r\nstruct rb_node *p, *parent, **pp;\r\n_enter("%p{%x},%x,%hx,",\r\nrx, key_serial(key), trans->debug_id, ntohs(service_id));\r\nif (rx->trans == trans && rx->bundle) {\r\natomic_inc(&rx->bundle->usage);\r\nreturn rx->bundle;\r\n}\r\nspin_lock(&trans->client_lock);\r\np = trans->bundles.rb_node;\r\nwhile (p) {\r\nbundle = rb_entry(p, struct rxrpc_conn_bundle, node);\r\nif (rxrpc_cmp_bundle(bundle, key, service_id) < 0)\r\np = p->rb_left;\r\nelse if (rxrpc_cmp_bundle(bundle, key, service_id) > 0)\r\np = p->rb_right;\r\nelse\r\ngoto found_extant_bundle;\r\n}\r\nspin_unlock(&trans->client_lock);\r\ncandidate = rxrpc_alloc_bundle(gfp);\r\nif (!candidate) {\r\n_leave(" = -ENOMEM");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncandidate->key = key_get(key);\r\ncandidate->service_id = service_id;\r\nspin_lock(&trans->client_lock);\r\npp = &trans->bundles.rb_node;\r\nparent = NULL;\r\nwhile (*pp) {\r\nparent = *pp;\r\nbundle = rb_entry(parent, struct rxrpc_conn_bundle, node);\r\nif (rxrpc_cmp_bundle(bundle, key, service_id) < 0)\r\npp = &(*pp)->rb_left;\r\nelse if (rxrpc_cmp_bundle(bundle, key, service_id) > 0)\r\npp = &(*pp)->rb_right;\r\nelse\r\ngoto found_extant_second;\r\n}\r\nbundle = candidate;\r\ncandidate = NULL;\r\nrb_link_node(&bundle->node, parent, pp);\r\nrb_insert_color(&bundle->node, &trans->bundles);\r\nspin_unlock(&trans->client_lock);\r\n_net("BUNDLE new on trans %d", trans->debug_id);\r\nif (!rx->bundle && rx->sk.sk_state == RXRPC_CLIENT_CONNECTED) {\r\natomic_inc(&bundle->usage);\r\nrx->bundle = bundle;\r\n}\r\n_leave(" = %p [new]", bundle);\r\nreturn bundle;\r\nfound_extant_bundle:\r\natomic_inc(&bundle->usage);\r\nspin_unlock(&trans->client_lock);\r\n_net("BUNDLE old on trans %d", trans->debug_id);\r\nif (!rx->bundle && rx->sk.sk_state == RXRPC_CLIENT_CONNECTED) {\r\natomic_inc(&bundle->usage);\r\nrx->bundle = bundle;\r\n}\r\n_leave(" = %p [extant %d]", bundle, atomic_read(&bundle->usage));\r\nreturn bundle;\r\nfound_extant_second:\r\natomic_inc(&bundle->usage);\r\nspin_unlock(&trans->client_lock);\r\nkfree(candidate);\r\n_net("BUNDLE old2 on trans %d", trans->debug_id);\r\nif (!rx->bundle && rx->sk.sk_state == RXRPC_CLIENT_CONNECTED) {\r\natomic_inc(&bundle->usage);\r\nrx->bundle = bundle;\r\n}\r\n_leave(" = %p [second %d]", bundle, atomic_read(&bundle->usage));\r\nreturn bundle;\r\n}\r\nvoid rxrpc_put_bundle(struct rxrpc_transport *trans,\r\nstruct rxrpc_conn_bundle *bundle)\r\n{\r\n_enter("%p,%p{%d}",trans, bundle, atomic_read(&bundle->usage));\r\nif (atomic_dec_and_lock(&bundle->usage, &trans->client_lock)) {\r\n_debug("Destroy bundle");\r\nrb_erase(&bundle->node, &trans->bundles);\r\nspin_unlock(&trans->client_lock);\r\nASSERT(list_empty(&bundle->unused_conns));\r\nASSERT(list_empty(&bundle->avail_conns));\r\nASSERT(list_empty(&bundle->busy_conns));\r\nASSERTCMP(bundle->num_conns, ==, 0);\r\nkey_put(bundle->key);\r\nkfree(bundle);\r\n}\r\n_leave("");\r\n}\r\nstatic struct rxrpc_connection *rxrpc_alloc_connection(gfp_t gfp)\r\n{\r\nstruct rxrpc_connection *conn;\r\n_enter("");\r\nconn = kzalloc(sizeof(struct rxrpc_connection), gfp);\r\nif (conn) {\r\nINIT_WORK(&conn->processor, &rxrpc_process_connection);\r\nINIT_LIST_HEAD(&conn->bundle_link);\r\nconn->calls = RB_ROOT;\r\nskb_queue_head_init(&conn->rx_queue);\r\nrwlock_init(&conn->lock);\r\nspin_lock_init(&conn->state_lock);\r\natomic_set(&conn->usage, 1);\r\nconn->debug_id = atomic_inc_return(&rxrpc_debug_id);\r\nconn->avail_calls = RXRPC_MAXCALLS;\r\nconn->size_align = 4;\r\nconn->header_size = sizeof(struct rxrpc_header);\r\n}\r\n_leave(" = %p{%d}", conn, conn ? conn->debug_id : 0);\r\nreturn conn;\r\n}\r\nstatic void rxrpc_assign_connection_id(struct rxrpc_connection *conn)\r\n{\r\nstruct rxrpc_connection *xconn;\r\nstruct rb_node *parent, **p;\r\n__be32 epoch;\r\nu32 real_conn_id;\r\n_enter("");\r\nepoch = conn->epoch;\r\nwrite_lock_bh(&conn->trans->conn_lock);\r\nconn->trans->conn_idcounter += RXRPC_CID_INC;\r\nif (conn->trans->conn_idcounter < RXRPC_CID_INC)\r\nconn->trans->conn_idcounter = RXRPC_CID_INC;\r\nreal_conn_id = conn->trans->conn_idcounter;\r\nattempt_insertion:\r\nparent = NULL;\r\np = &conn->trans->client_conns.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nxconn = rb_entry(parent, struct rxrpc_connection, node);\r\nif (epoch < xconn->epoch)\r\np = &(*p)->rb_left;\r\nelse if (epoch > xconn->epoch)\r\np = &(*p)->rb_right;\r\nelse if (real_conn_id < xconn->real_conn_id)\r\np = &(*p)->rb_left;\r\nelse if (real_conn_id > xconn->real_conn_id)\r\np = &(*p)->rb_right;\r\nelse\r\ngoto id_exists;\r\n}\r\nrb_link_node(&conn->node, parent, p);\r\nrb_insert_color(&conn->node, &conn->trans->client_conns);\r\nconn->real_conn_id = real_conn_id;\r\nconn->cid = htonl(real_conn_id);\r\nwrite_unlock_bh(&conn->trans->conn_lock);\r\n_leave(" [CONNID %x CID %x]", real_conn_id, ntohl(conn->cid));\r\nreturn;\r\nid_exists:\r\nfor (;;) {\r\nreal_conn_id += RXRPC_CID_INC;\r\nif (real_conn_id < RXRPC_CID_INC) {\r\nreal_conn_id = RXRPC_CID_INC;\r\nconn->trans->conn_idcounter = real_conn_id;\r\ngoto attempt_insertion;\r\n}\r\nparent = rb_next(parent);\r\nif (!parent)\r\ngoto attempt_insertion;\r\nxconn = rb_entry(parent, struct rxrpc_connection, node);\r\nif (epoch < xconn->epoch ||\r\nreal_conn_id < xconn->real_conn_id)\r\ngoto attempt_insertion;\r\n}\r\n}\r\nstatic void rxrpc_add_call_ID_to_conn(struct rxrpc_connection *conn,\r\nstruct rxrpc_call *call)\r\n{\r\nstruct rxrpc_call *xcall;\r\nstruct rb_node *parent, **p;\r\n__be32 call_id;\r\nwrite_lock_bh(&conn->lock);\r\ncall_id = call->call_id;\r\np = &conn->calls.rb_node;\r\nparent = NULL;\r\nwhile (*p) {\r\nparent = *p;\r\nxcall = rb_entry(parent, struct rxrpc_call, conn_node);\r\nif (call_id < xcall->call_id)\r\np = &(*p)->rb_left;\r\nelse if (call_id > xcall->call_id)\r\np = &(*p)->rb_right;\r\nelse\r\nBUG();\r\n}\r\nrb_link_node(&call->conn_node, parent, p);\r\nrb_insert_color(&call->conn_node, &conn->calls);\r\nwrite_unlock_bh(&conn->lock);\r\n}\r\nstatic int rxrpc_connect_exclusive(struct rxrpc_sock *rx,\r\nstruct rxrpc_transport *trans,\r\n__be16 service_id,\r\nstruct rxrpc_call *call,\r\ngfp_t gfp)\r\n{\r\nstruct rxrpc_connection *conn;\r\nint chan, ret;\r\n_enter("");\r\nconn = rx->conn;\r\nif (!conn) {\r\nconn = rxrpc_alloc_connection(gfp);\r\nif (!conn) {\r\n_leave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\nconn->trans = trans;\r\nconn->bundle = NULL;\r\nconn->service_id = service_id;\r\nconn->epoch = rxrpc_epoch;\r\nconn->in_clientflag = 0;\r\nconn->out_clientflag = RXRPC_CLIENT_INITIATED;\r\nconn->cid = 0;\r\nconn->state = RXRPC_CONN_CLIENT;\r\nconn->avail_calls = RXRPC_MAXCALLS - 1;\r\nconn->security_level = rx->min_sec_level;\r\nconn->key = key_get(rx->key);\r\nret = rxrpc_init_client_conn_security(conn);\r\nif (ret < 0) {\r\nkey_put(conn->key);\r\nkfree(conn);\r\n_leave(" = %d [key]", ret);\r\nreturn ret;\r\n}\r\nwrite_lock_bh(&rxrpc_connection_lock);\r\nlist_add_tail(&conn->link, &rxrpc_connections);\r\nwrite_unlock_bh(&rxrpc_connection_lock);\r\nspin_lock(&trans->client_lock);\r\natomic_inc(&trans->usage);\r\n_net("CONNECT EXCL new %d on TRANS %d",\r\nconn->debug_id, conn->trans->debug_id);\r\nrxrpc_assign_connection_id(conn);\r\nrx->conn = conn;\r\n} else {\r\nspin_lock(&trans->client_lock);\r\n}\r\nfor (chan = 0; chan < RXRPC_MAXCALLS; chan++)\r\nif (!conn->channels[chan])\r\ngoto found_channel;\r\ngoto no_free_channels;\r\nfound_channel:\r\natomic_inc(&conn->usage);\r\nconn->channels[chan] = call;\r\ncall->conn = conn;\r\ncall->channel = chan;\r\ncall->cid = conn->cid | htonl(chan);\r\ncall->call_id = htonl(++conn->call_counter);\r\n_net("CONNECT client on conn %d chan %d as call %x",\r\nconn->debug_id, chan, ntohl(call->call_id));\r\nspin_unlock(&trans->client_lock);\r\nrxrpc_add_call_ID_to_conn(conn, call);\r\n_leave(" = 0");\r\nreturn 0;\r\nno_free_channels:\r\nspin_unlock(&trans->client_lock);\r\n_leave(" = -ENOSR");\r\nreturn -ENOSR;\r\n}\r\nint rxrpc_connect_call(struct rxrpc_sock *rx,\r\nstruct rxrpc_transport *trans,\r\nstruct rxrpc_conn_bundle *bundle,\r\nstruct rxrpc_call *call,\r\ngfp_t gfp)\r\n{\r\nstruct rxrpc_connection *conn, *candidate;\r\nint chan, ret;\r\nDECLARE_WAITQUEUE(myself, current);\r\n_enter("%p,%lx,", rx, call->user_call_ID);\r\nif (test_bit(RXRPC_SOCK_EXCLUSIVE_CONN, &rx->flags))\r\nreturn rxrpc_connect_exclusive(rx, trans, bundle->service_id,\r\ncall, gfp);\r\nspin_lock(&trans->client_lock);\r\nfor (;;) {\r\nif (!list_empty(&bundle->avail_conns)) {\r\n_debug("avail");\r\nconn = list_entry(bundle->avail_conns.next,\r\nstruct rxrpc_connection,\r\nbundle_link);\r\nif (conn->state >= RXRPC_CONN_REMOTELY_ABORTED) {\r\nlist_del_init(&conn->bundle_link);\r\nbundle->num_conns--;\r\ncontinue;\r\n}\r\nif (--conn->avail_calls == 0)\r\nlist_move(&conn->bundle_link,\r\n&bundle->busy_conns);\r\nASSERTCMP(conn->avail_calls, <, RXRPC_MAXCALLS);\r\nASSERT(conn->channels[0] == NULL ||\r\nconn->channels[1] == NULL ||\r\nconn->channels[2] == NULL ||\r\nconn->channels[3] == NULL);\r\natomic_inc(&conn->usage);\r\nbreak;\r\n}\r\nif (!list_empty(&bundle->unused_conns)) {\r\n_debug("unused");\r\nconn = list_entry(bundle->unused_conns.next,\r\nstruct rxrpc_connection,\r\nbundle_link);\r\nif (conn->state >= RXRPC_CONN_REMOTELY_ABORTED) {\r\nlist_del_init(&conn->bundle_link);\r\nbundle->num_conns--;\r\ncontinue;\r\n}\r\nASSERTCMP(conn->avail_calls, ==, RXRPC_MAXCALLS);\r\nconn->avail_calls = RXRPC_MAXCALLS - 1;\r\nASSERT(conn->channels[0] == NULL &&\r\nconn->channels[1] == NULL &&\r\nconn->channels[2] == NULL &&\r\nconn->channels[3] == NULL);\r\natomic_inc(&conn->usage);\r\nlist_move(&conn->bundle_link, &bundle->avail_conns);\r\nbreak;\r\n}\r\n_debug("get new conn [%d]", bundle->num_conns);\r\nspin_unlock(&trans->client_lock);\r\nif (signal_pending(current))\r\ngoto interrupted;\r\nif (bundle->num_conns >= 20) {\r\n_debug("too many conns");\r\nif (!(gfp & __GFP_WAIT)) {\r\n_leave(" = -EAGAIN");\r\nreturn -EAGAIN;\r\n}\r\nadd_wait_queue(&bundle->chanwait, &myself);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (bundle->num_conns < 20 ||\r\n!list_empty(&bundle->unused_conns) ||\r\n!list_empty(&bundle->avail_conns))\r\nbreak;\r\nif (signal_pending(current))\r\ngoto interrupted_dequeue;\r\nschedule();\r\n}\r\nremove_wait_queue(&bundle->chanwait, &myself);\r\n__set_current_state(TASK_RUNNING);\r\nspin_lock(&trans->client_lock);\r\ncontinue;\r\n}\r\ncandidate = rxrpc_alloc_connection(gfp);\r\nif (!candidate) {\r\n_leave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\ncandidate->trans = trans;\r\ncandidate->bundle = bundle;\r\ncandidate->service_id = bundle->service_id;\r\ncandidate->epoch = rxrpc_epoch;\r\ncandidate->in_clientflag = 0;\r\ncandidate->out_clientflag = RXRPC_CLIENT_INITIATED;\r\ncandidate->cid = 0;\r\ncandidate->state = RXRPC_CONN_CLIENT;\r\ncandidate->avail_calls = RXRPC_MAXCALLS;\r\ncandidate->security_level = rx->min_sec_level;\r\ncandidate->key = key_get(bundle->key);\r\nret = rxrpc_init_client_conn_security(candidate);\r\nif (ret < 0) {\r\nkey_put(candidate->key);\r\nkfree(candidate);\r\n_leave(" = %d [key]", ret);\r\nreturn ret;\r\n}\r\nwrite_lock_bh(&rxrpc_connection_lock);\r\nlist_add_tail(&candidate->link, &rxrpc_connections);\r\nwrite_unlock_bh(&rxrpc_connection_lock);\r\nspin_lock(&trans->client_lock);\r\nlist_add(&candidate->bundle_link, &bundle->unused_conns);\r\nbundle->num_conns++;\r\natomic_inc(&bundle->usage);\r\natomic_inc(&trans->usage);\r\n_net("CONNECT new %d on TRANS %d",\r\ncandidate->debug_id, candidate->trans->debug_id);\r\nrxrpc_assign_connection_id(candidate);\r\nif (candidate->security)\r\ncandidate->security->prime_packet_security(candidate);\r\nrxrpc_put_connection(candidate);\r\ncandidate = NULL;\r\n}\r\nfor (chan = 0; chan < RXRPC_MAXCALLS; chan++)\r\nif (!conn->channels[chan])\r\ngoto found_channel;\r\nASSERT(conn->channels[0] == NULL ||\r\nconn->channels[1] == NULL ||\r\nconn->channels[2] == NULL ||\r\nconn->channels[3] == NULL);\r\nBUG();\r\nfound_channel:\r\nconn->channels[chan] = call;\r\ncall->conn = conn;\r\ncall->channel = chan;\r\ncall->cid = conn->cid | htonl(chan);\r\ncall->call_id = htonl(++conn->call_counter);\r\n_net("CONNECT client on conn %d chan %d as call %x",\r\nconn->debug_id, chan, ntohl(call->call_id));\r\nASSERTCMP(conn->avail_calls, <, RXRPC_MAXCALLS);\r\nspin_unlock(&trans->client_lock);\r\nrxrpc_add_call_ID_to_conn(conn, call);\r\n_leave(" = 0");\r\nreturn 0;\r\ninterrupted_dequeue:\r\nremove_wait_queue(&bundle->chanwait, &myself);\r\n__set_current_state(TASK_RUNNING);\r\ninterrupted:\r\n_leave(" = -ERESTARTSYS");\r\nreturn -ERESTARTSYS;\r\n}\r\nstruct rxrpc_connection *\r\nrxrpc_incoming_connection(struct rxrpc_transport *trans,\r\nstruct rxrpc_header *hdr,\r\ngfp_t gfp)\r\n{\r\nstruct rxrpc_connection *conn, *candidate = NULL;\r\nstruct rb_node *p, **pp;\r\nconst char *new = "old";\r\n__be32 epoch;\r\nu32 conn_id;\r\n_enter("");\r\nASSERT(hdr->flags & RXRPC_CLIENT_INITIATED);\r\nepoch = hdr->epoch;\r\nconn_id = ntohl(hdr->cid) & RXRPC_CIDMASK;\r\nread_lock_bh(&trans->conn_lock);\r\np = trans->server_conns.rb_node;\r\nwhile (p) {\r\nconn = rb_entry(p, struct rxrpc_connection, node);\r\n_debug("maybe %x", conn->real_conn_id);\r\nif (epoch < conn->epoch)\r\np = p->rb_left;\r\nelse if (epoch > conn->epoch)\r\np = p->rb_right;\r\nelse if (conn_id < conn->real_conn_id)\r\np = p->rb_left;\r\nelse if (conn_id > conn->real_conn_id)\r\np = p->rb_right;\r\nelse\r\ngoto found_extant_connection;\r\n}\r\nread_unlock_bh(&trans->conn_lock);\r\ncandidate = rxrpc_alloc_connection(gfp);\r\nif (!candidate) {\r\n_leave(" = -ENOMEM");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncandidate->trans = trans;\r\ncandidate->epoch = hdr->epoch;\r\ncandidate->cid = hdr->cid & cpu_to_be32(RXRPC_CIDMASK);\r\ncandidate->service_id = hdr->serviceId;\r\ncandidate->security_ix = hdr->securityIndex;\r\ncandidate->in_clientflag = RXRPC_CLIENT_INITIATED;\r\ncandidate->out_clientflag = 0;\r\ncandidate->real_conn_id = conn_id;\r\ncandidate->state = RXRPC_CONN_SERVER;\r\nif (candidate->service_id)\r\ncandidate->state = RXRPC_CONN_SERVER_UNSECURED;\r\nwrite_lock_bh(&trans->conn_lock);\r\npp = &trans->server_conns.rb_node;\r\np = NULL;\r\nwhile (*pp) {\r\np = *pp;\r\nconn = rb_entry(p, struct rxrpc_connection, node);\r\nif (epoch < conn->epoch)\r\npp = &(*pp)->rb_left;\r\nelse if (epoch > conn->epoch)\r\npp = &(*pp)->rb_right;\r\nelse if (conn_id < conn->real_conn_id)\r\npp = &(*pp)->rb_left;\r\nelse if (conn_id > conn->real_conn_id)\r\npp = &(*pp)->rb_right;\r\nelse\r\ngoto found_extant_second;\r\n}\r\nconn = candidate;\r\ncandidate = NULL;\r\nrb_link_node(&conn->node, p, pp);\r\nrb_insert_color(&conn->node, &trans->server_conns);\r\natomic_inc(&conn->trans->usage);\r\nwrite_unlock_bh(&trans->conn_lock);\r\nwrite_lock_bh(&rxrpc_connection_lock);\r\nlist_add_tail(&conn->link, &rxrpc_connections);\r\nwrite_unlock_bh(&rxrpc_connection_lock);\r\nnew = "new";\r\nsuccess:\r\n_net("CONNECTION %s %d {%x}", new, conn->debug_id, conn->real_conn_id);\r\n_leave(" = %p {u=%d}", conn, atomic_read(&conn->usage));\r\nreturn conn;\r\nfound_extant_connection:\r\nif (hdr->securityIndex != conn->security_ix) {\r\nread_unlock_bh(&trans->conn_lock);\r\ngoto security_mismatch;\r\n}\r\natomic_inc(&conn->usage);\r\nread_unlock_bh(&trans->conn_lock);\r\ngoto success;\r\nfound_extant_second:\r\nif (hdr->securityIndex != conn->security_ix) {\r\nwrite_unlock_bh(&trans->conn_lock);\r\ngoto security_mismatch;\r\n}\r\natomic_inc(&conn->usage);\r\nwrite_unlock_bh(&trans->conn_lock);\r\nkfree(candidate);\r\ngoto success;\r\nsecurity_mismatch:\r\nkfree(candidate);\r\n_leave(" = -EKEYREJECTED");\r\nreturn ERR_PTR(-EKEYREJECTED);\r\n}\r\nstruct rxrpc_connection *rxrpc_find_connection(struct rxrpc_transport *trans,\r\nstruct rxrpc_header *hdr)\r\n{\r\nstruct rxrpc_connection *conn;\r\nstruct rb_node *p;\r\n__be32 epoch;\r\nu32 conn_id;\r\n_enter(",{%x,%x}", ntohl(hdr->cid), hdr->flags);\r\nread_lock_bh(&trans->conn_lock);\r\nconn_id = ntohl(hdr->cid) & RXRPC_CIDMASK;\r\nepoch = hdr->epoch;\r\nif (hdr->flags & RXRPC_CLIENT_INITIATED)\r\np = trans->server_conns.rb_node;\r\nelse\r\np = trans->client_conns.rb_node;\r\nwhile (p) {\r\nconn = rb_entry(p, struct rxrpc_connection, node);\r\n_debug("maybe %x", conn->real_conn_id);\r\nif (epoch < conn->epoch)\r\np = p->rb_left;\r\nelse if (epoch > conn->epoch)\r\np = p->rb_right;\r\nelse if (conn_id < conn->real_conn_id)\r\np = p->rb_left;\r\nelse if (conn_id > conn->real_conn_id)\r\np = p->rb_right;\r\nelse\r\ngoto found;\r\n}\r\nread_unlock_bh(&trans->conn_lock);\r\n_leave(" = NULL");\r\nreturn NULL;\r\nfound:\r\natomic_inc(&conn->usage);\r\nread_unlock_bh(&trans->conn_lock);\r\n_leave(" = %p", conn);\r\nreturn conn;\r\n}\r\nvoid rxrpc_put_connection(struct rxrpc_connection *conn)\r\n{\r\n_enter("%p{u=%d,d=%d}",\r\nconn, atomic_read(&conn->usage), conn->debug_id);\r\nASSERTCMP(atomic_read(&conn->usage), >, 0);\r\nconn->put_time = get_seconds();\r\nif (atomic_dec_and_test(&conn->usage)) {\r\n_debug("zombie");\r\nrxrpc_queue_delayed_work(&rxrpc_connection_reap, 0);\r\n}\r\n_leave("");\r\n}\r\nstatic void rxrpc_destroy_connection(struct rxrpc_connection *conn)\r\n{\r\n_enter("%p{%d}", conn, atomic_read(&conn->usage));\r\nASSERTCMP(atomic_read(&conn->usage), ==, 0);\r\n_net("DESTROY CONN %d", conn->debug_id);\r\nif (conn->bundle)\r\nrxrpc_put_bundle(conn->trans, conn->bundle);\r\nASSERT(RB_EMPTY_ROOT(&conn->calls));\r\nrxrpc_purge_queue(&conn->rx_queue);\r\nrxrpc_clear_conn_security(conn);\r\nrxrpc_put_transport(conn->trans);\r\nkfree(conn);\r\n_leave("");\r\n}\r\nstatic void rxrpc_connection_reaper(struct work_struct *work)\r\n{\r\nstruct rxrpc_connection *conn, *_p;\r\nunsigned long now, earliest, reap_time;\r\nLIST_HEAD(graveyard);\r\n_enter("");\r\nnow = get_seconds();\r\nearliest = ULONG_MAX;\r\nwrite_lock_bh(&rxrpc_connection_lock);\r\nlist_for_each_entry_safe(conn, _p, &rxrpc_connections, link) {\r\n_debug("reap CONN %d { u=%d,t=%ld }",\r\nconn->debug_id, atomic_read(&conn->usage),\r\n(long) now - (long) conn->put_time);\r\nif (likely(atomic_read(&conn->usage) > 0))\r\ncontinue;\r\nspin_lock(&conn->trans->client_lock);\r\nwrite_lock(&conn->trans->conn_lock);\r\nreap_time = conn->put_time + rxrpc_connection_expiry;\r\nif (atomic_read(&conn->usage) > 0) {\r\n;\r\n} else if (reap_time <= now) {\r\nlist_move_tail(&conn->link, &graveyard);\r\nif (conn->out_clientflag)\r\nrb_erase(&conn->node,\r\n&conn->trans->client_conns);\r\nelse\r\nrb_erase(&conn->node,\r\n&conn->trans->server_conns);\r\nif (conn->bundle) {\r\nlist_del_init(&conn->bundle_link);\r\nconn->bundle->num_conns--;\r\n}\r\n} else if (reap_time < earliest) {\r\nearliest = reap_time;\r\n}\r\nwrite_unlock(&conn->trans->conn_lock);\r\nspin_unlock(&conn->trans->client_lock);\r\n}\r\nwrite_unlock_bh(&rxrpc_connection_lock);\r\nif (earliest != ULONG_MAX) {\r\n_debug("reschedule reaper %ld", (long) earliest - now);\r\nASSERTCMP(earliest, >, now);\r\nrxrpc_queue_delayed_work(&rxrpc_connection_reap,\r\n(earliest - now) * HZ);\r\n}\r\nwhile (!list_empty(&graveyard)) {\r\nconn = list_entry(graveyard.next, struct rxrpc_connection,\r\nlink);\r\nlist_del_init(&conn->link);\r\nASSERTCMP(atomic_read(&conn->usage), ==, 0);\r\nrxrpc_destroy_connection(conn);\r\n}\r\n_leave("");\r\n}\r\nvoid __exit rxrpc_destroy_all_connections(void)\r\n{\r\n_enter("");\r\nrxrpc_connection_expiry = 0;\r\ncancel_delayed_work(&rxrpc_connection_reap);\r\nrxrpc_queue_delayed_work(&rxrpc_connection_reap, 0);\r\n_leave("");\r\n}
