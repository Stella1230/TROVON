static unsigned int cx20442_read_reg_cache(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nu8 *reg_cache = codec->reg_cache;\r\nif (reg >= codec->driver->reg_cache_size)\r\nreturn -EINVAL;\r\nreturn reg_cache[reg];\r\n}\r\nstatic int cx20442_pm_to_v253_vls(u8 value)\r\n{\r\nswitch (value & ~(1 << CX20442_AGC)) {\r\ncase 0:\r\nreturn V253_VLS_T;\r\ncase (1 << CX20442_SPKOUT):\r\ncase (1 << CX20442_MIC):\r\ncase (1 << CX20442_SPKOUT) | (1 << CX20442_MIC):\r\nreturn V253_VLS_M1S1;\r\ncase (1 << CX20442_TELOUT):\r\ncase (1 << CX20442_TELIN):\r\ncase (1 << CX20442_TELOUT) | (1 << CX20442_TELIN):\r\nreturn V253_VLS_L;\r\ncase (1 << CX20442_TELOUT) | (1 << CX20442_MIC):\r\nreturn V253_VLS_NONE;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cx20442_pm_to_v253_vsp(u8 value)\r\n{\r\nswitch (value & ~(1 << CX20442_AGC)) {\r\ncase (1 << CX20442_SPKOUT):\r\ncase (1 << CX20442_MIC):\r\ncase (1 << CX20442_SPKOUT) | (1 << CX20442_MIC):\r\nreturn (bool)(value & (1 << CX20442_AGC));\r\n}\r\nreturn (value & (1 << CX20442_AGC)) ? -EINVAL : 0;\r\n}\r\nstatic int cx20442_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct cx20442_priv *cx20442 = snd_soc_codec_get_drvdata(codec);\r\nu8 *reg_cache = codec->reg_cache;\r\nint vls, vsp, old, len;\r\nchar buf[18];\r\nif (reg >= codec->driver->reg_cache_size)\r\nreturn -EINVAL;\r\nif (!codec->hw_write || !cx20442->control_data)\r\nreturn -EIO;\r\nold = reg_cache[reg];\r\nreg_cache[reg] = value;\r\nvls = cx20442_pm_to_v253_vls(value);\r\nif (vls < 0)\r\nreturn vls;\r\nvsp = cx20442_pm_to_v253_vsp(value);\r\nif (vsp < 0)\r\nreturn vsp;\r\nif ((vls == V253_VLS_T) ||\r\n(vls == cx20442_pm_to_v253_vls(old))) {\r\nif (vsp == cx20442_pm_to_v253_vsp(old))\r\nreturn 0;\r\nlen = snprintf(buf, ARRAY_SIZE(buf), "at+vsp=%d\r", vsp);\r\n} else if (vsp == cx20442_pm_to_v253_vsp(old))\r\nlen = snprintf(buf, ARRAY_SIZE(buf), "at+vls=%d\r", vls);\r\nelse\r\nlen = snprintf(buf, ARRAY_SIZE(buf),\r\n"at+vls=%d;+vsp=%d\r", vls, vsp);\r\nif (unlikely(len > (ARRAY_SIZE(buf) - 1)))\r\nreturn -ENOMEM;\r\ndev_dbg(codec->dev, "%s: %s\n", __func__, buf);\r\nif (codec->hw_write(cx20442->control_data, buf, len) != len)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int v253_open(struct tty_struct *tty)\r\n{\r\nint ret, len = strlen(v253_init);\r\nif (!tty->ops->write)\r\nreturn -EINVAL;\r\nif (!tty->disc_data)\r\nreturn -ENODEV;\r\nif (tty->ops->write(tty, v253_init, len) != len) {\r\nret = -EIO;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ntty->disc_data = NULL;\r\nreturn ret;\r\n}\r\nstatic void v253_close(struct tty_struct *tty)\r\n{\r\nstruct snd_soc_codec *codec = tty->disc_data;\r\nstruct cx20442_priv *cx20442;\r\ntty->disc_data = NULL;\r\nif (!codec)\r\nreturn;\r\ncx20442 = snd_soc_codec_get_drvdata(codec);\r\ncodec->hw_write = NULL;\r\ncx20442->control_data = NULL;\r\ncodec->component.card->pop_time = 0;\r\n}\r\nstatic int v253_hangup(struct tty_struct *tty)\r\n{\r\nv253_close(tty);\r\nreturn 0;\r\n}\r\nstatic void v253_receive(struct tty_struct *tty,\r\nconst unsigned char *cp, char *fp, int count)\r\n{\r\nstruct snd_soc_codec *codec = tty->disc_data;\r\nstruct cx20442_priv *cx20442;\r\nif (!codec)\r\nreturn;\r\ncx20442 = snd_soc_codec_get_drvdata(codec);\r\nif (!cx20442->control_data) {\r\ncx20442->control_data = tty;\r\ncodec->hw_write = (hw_write_t)tty->ops->write;\r\ncodec->component.card->pop_time = 1;\r\n}\r\n}\r\nstatic void v253_wakeup(struct tty_struct *tty)\r\n{\r\n}\r\nstatic int cx20442_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct cx20442_priv *cx20442 = snd_soc_codec_get_drvdata(codec);\r\nint err = 0;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (codec->dapm.bias_level != SND_SOC_BIAS_STANDBY)\r\nbreak;\r\nif (IS_ERR(cx20442->por))\r\nerr = PTR_ERR(cx20442->por);\r\nelse\r\nerr = regulator_enable(cx20442->por);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level != SND_SOC_BIAS_PREPARE)\r\nbreak;\r\nif (IS_ERR(cx20442->por))\r\nerr = PTR_ERR(cx20442->por);\r\nelse\r\nerr = regulator_disable(cx20442->por);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!err)\r\ncodec->dapm.bias_level = level;\r\nreturn err;\r\n}\r\nstatic int cx20442_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cx20442_priv *cx20442;\r\ncx20442 = kzalloc(sizeof(struct cx20442_priv), GFP_KERNEL);\r\nif (cx20442 == NULL)\r\nreturn -ENOMEM;\r\ncx20442->por = regulator_get(codec->dev, "POR");\r\nif (IS_ERR(cx20442->por))\r\ndev_warn(codec->dev, "failed to get the regulator");\r\ncx20442->control_data = NULL;\r\nsnd_soc_codec_set_drvdata(codec, cx20442);\r\ncodec->hw_write = NULL;\r\ncodec->component.card->pop_time = 0;\r\nreturn 0;\r\n}\r\nstatic int cx20442_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct cx20442_priv *cx20442 = snd_soc_codec_get_drvdata(codec);\r\nif (cx20442->control_data) {\r\nstruct tty_struct *tty = cx20442->control_data;\r\ntty_hangup(tty);\r\n}\r\nif (!IS_ERR(cx20442->por)) {\r\nregulator_put(cx20442->por);\r\n}\r\nsnd_soc_codec_set_drvdata(codec, NULL);\r\nkfree(cx20442);\r\nreturn 0;\r\n}\r\nstatic int cx20442_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev,\r\n&cx20442_codec_dev, &cx20442_dai, 1);\r\n}\r\nstatic int __exit cx20442_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
