static void __iomem *rcar_pci_cfg_base(struct pci_bus *bus, unsigned int devfn,\r\nint where)\r\n{\r\nstruct pci_sys_data *sys = bus->sysdata;\r\nstruct rcar_pci_priv *priv = sys->private_data;\r\nint slot, val;\r\nif (sys->busnr != bus->number || PCI_FUNC(devfn))\r\nreturn NULL;\r\nslot = PCI_SLOT(devfn);\r\nif (slot > 2)\r\nreturn NULL;\r\nif (slot == 0x0 && where >= 0x40)\r\nreturn NULL;\r\nval = slot ? RCAR_AHBPCI_WIN1_DEVICE | RCAR_AHBPCI_WIN_CTR_CFG :\r\nRCAR_AHBPCI_WIN1_HOST | RCAR_AHBPCI_WIN_CTR_CFG;\r\niowrite32(val, priv->reg + RCAR_AHBPCI_WIN1_CTR_REG);\r\nreturn priv->reg + (slot >> 1) * 0x100 + where;\r\n}\r\nstatic int rcar_pci_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nvoid __iomem *reg = rcar_pci_cfg_base(bus, devfn, where);\r\nif (!reg)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\n*val = ioread8(reg);\r\nbreak;\r\ncase 2:\r\n*val = ioread16(reg);\r\nbreak;\r\ndefault:\r\n*val = ioread32(reg);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int rcar_pci_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nvoid __iomem *reg = rcar_pci_cfg_base(bus, devfn, where);\r\nif (!reg)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\niowrite8(val, reg);\r\nbreak;\r\ncase 2:\r\niowrite16(val, reg);\r\nbreak;\r\ndefault:\r\niowrite32(val, reg);\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int rcar_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstruct pci_sys_data *sys = dev->bus->sysdata;\r\nstruct rcar_pci_priv *priv = sys->private_data;\r\nint irq;\r\nirq = of_irq_parse_and_map_pci(dev, slot, pin);\r\nif (!irq)\r\nirq = priv->irq;\r\nreturn irq;\r\n}\r\nstatic irqreturn_t rcar_pci_err_irq(int irq, void *pw)\r\n{\r\nstruct rcar_pci_priv *priv = pw;\r\nu32 status = ioread32(priv->reg + RCAR_PCI_INT_STATUS_REG);\r\nif (status & RCAR_PCI_INT_ALLERRORS) {\r\ndev_err(priv->dev, "error irq: status %08x\n", status);\r\niowrite32(status & RCAR_PCI_INT_ALLERRORS,\r\npriv->reg + RCAR_PCI_INT_STATUS_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void rcar_pci_setup_errirq(struct rcar_pci_priv *priv)\r\n{\r\nint ret;\r\nu32 val;\r\nret = devm_request_irq(priv->dev, priv->irq, rcar_pci_err_irq,\r\nIRQF_SHARED, "error irq", priv);\r\nif (ret) {\r\ndev_err(priv->dev, "cannot claim IRQ for error handling\n");\r\nreturn;\r\n}\r\nval = ioread32(priv->reg + RCAR_PCI_INT_ENABLE_REG);\r\nval |= RCAR_PCI_INT_ALLERRORS;\r\niowrite32(val, priv->reg + RCAR_PCI_INT_ENABLE_REG);\r\n}\r\nstatic inline void rcar_pci_setup_errirq(struct rcar_pci_priv *priv) { }\r\nstatic int rcar_pci_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct rcar_pci_priv *priv = sys->private_data;\r\nvoid __iomem *reg = priv->reg;\r\nu32 val;\r\npm_runtime_enable(priv->dev);\r\npm_runtime_get_sync(priv->dev);\r\nval = ioread32(reg + RCAR_PCI_UNIT_REV_REG);\r\ndev_info(priv->dev, "PCI: bus%u revision %x\n", sys->busnr, val);\r\nval = ioread32(reg + RCAR_USBCTR_REG) & ~RCAR_USBCTR_DIRPD;\r\nval |= RCAR_USBCTR_USBH_RST | RCAR_USBCTR_PLL_RST;\r\niowrite32(val, reg + RCAR_USBCTR_REG);\r\nudelay(4);\r\nval &= ~(RCAR_USBCTR_PCIAHB_WIN1_MASK | RCAR_USBCTR_PCICLK_MASK |\r\nRCAR_USBCTR_USBH_RST | RCAR_USBCTR_PLL_RST);\r\nswitch (priv->window_size) {\r\ncase SZ_2G:\r\nval |= RCAR_USBCTR_PCIAHB_WIN1_2G;\r\nbreak;\r\ncase SZ_1G:\r\nval |= RCAR_USBCTR_PCIAHB_WIN1_1G;\r\nbreak;\r\ncase SZ_512M:\r\nval |= RCAR_USBCTR_PCIAHB_WIN1_512M;\r\nbreak;\r\ndefault:\r\npr_warn("unknown window size %ld - defaulting to 256M\n",\r\npriv->window_size);\r\npriv->window_size = SZ_256M;\r\ncase SZ_256M:\r\nval |= RCAR_USBCTR_PCIAHB_WIN1_256M;\r\nbreak;\r\n}\r\niowrite32(val, reg + RCAR_USBCTR_REG);\r\niowrite32(RCAR_AHB_BUS_MODE, reg + RCAR_AHB_BUS_CTR_REG);\r\nval = ioread32(reg + RCAR_PCI_ARBITER_CTR_REG);\r\nval |= RCAR_PCI_ARBITER_PCIREQ0 | RCAR_PCI_ARBITER_PCIREQ1 |\r\nRCAR_PCI_ARBITER_PCIBP_MODE;\r\niowrite32(val, reg + RCAR_PCI_ARBITER_CTR_REG);\r\niowrite32(0x40000000 | RCAR_PCIAHB_PREFETCH16,\r\nreg + RCAR_PCIAHB_WIN1_CTR_REG);\r\nval = priv->mem_res.start | RCAR_AHBPCI_WIN_CTR_MEM;\r\niowrite32(val, reg + RCAR_AHBPCI_WIN2_CTR_REG);\r\niowrite32(RCAR_AHBPCI_WIN1_HOST | RCAR_AHBPCI_WIN_CTR_CFG,\r\nreg + RCAR_AHBPCI_WIN1_CTR_REG);\r\niowrite32(0x40000000 | PCI_BASE_ADDRESS_MEM_PREFETCH,\r\nreg + PCI_BASE_ADDRESS_1);\r\nval = priv->cfg_res->start + RCAR_AHBPCI_PCICOM_OFFSET;\r\niowrite32(val, reg + PCI_BASE_ADDRESS_0);\r\nval = ioread32(reg + PCI_COMMAND);\r\nval |= PCI_COMMAND_SERR | PCI_COMMAND_PARITY |\r\nPCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\r\niowrite32(val, reg + PCI_COMMAND);\r\niowrite32(RCAR_PCI_INT_A | RCAR_PCI_INT_B | RCAR_PCI_INT_PME,\r\nreg + RCAR_PCI_INT_ENABLE_REG);\r\nif (priv->irq > 0)\r\nrcar_pci_setup_errirq(priv);\r\npci_add_resource(&sys->resources, &priv->io_res);\r\npci_add_resource(&sys->resources, &priv->mem_res);\r\nsys->busnr = priv->busnr;\r\nreturn 1;\r\n}\r\nstatic int rcar_pci_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *cfg_res, *mem_res;\r\nstruct rcar_pci_priv *priv;\r\nvoid __iomem *reg;\r\nstruct hw_pci hw;\r\nvoid *hw_private[1];\r\ncfg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg = devm_ioremap_resource(&pdev->dev, cfg_res);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!mem_res || !mem_res->start)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof(struct rcar_pci_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->mem_res = *mem_res;\r\npriv->io_res.start = priv->mem_res.start;\r\npriv->io_res.end = priv->mem_res.end;\r\npriv->io_res.flags = IORESOURCE_IO;\r\npriv->cfg_res = cfg_res;\r\npriv->irq = platform_get_irq(pdev, 0);\r\npriv->reg = reg;\r\npriv->dev = &pdev->dev;\r\nif (priv->irq < 0) {\r\ndev_err(&pdev->dev, "no valid irq found\n");\r\nreturn priv->irq;\r\n}\r\npriv->window_size = SZ_1G;\r\nif (pdev->dev.of_node) {\r\nstruct resource busnr;\r\nint ret;\r\nret = of_pci_parse_bus_range(pdev->dev.of_node, &busnr);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to parse bus-range\n");\r\nreturn ret;\r\n}\r\npriv->busnr = busnr.start;\r\nif (busnr.end != busnr.start)\r\ndev_warn(&pdev->dev, "only one bus number supported\n");\r\n} else {\r\npriv->busnr = pdev->id;\r\n}\r\nhw_private[0] = priv;\r\nmemset(&hw, 0, sizeof(hw));\r\nhw.nr_controllers = ARRAY_SIZE(hw_private);\r\nhw.private_data = hw_private;\r\nhw.map_irq = rcar_pci_map_irq;\r\nhw.ops = &rcar_pci_ops;\r\nhw.setup = rcar_pci_setup;\r\npci_common_init_dev(&pdev->dev, &hw);\r\nreturn 0;\r\n}
