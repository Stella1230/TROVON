static int uvc_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\r\nstruct uvc_streaming *stream =\r\ncontainer_of(queue, struct uvc_streaming, queue);\r\nif (fmt && fmt->fmt.pix.sizeimage < stream->ctrl.dwMaxVideoFrameSize)\r\nreturn -EINVAL;\r\n*nplanes = 1;\r\nsizes[0] = fmt ? fmt->fmt.pix.sizeimage\r\n: stream->ctrl.dwMaxVideoFrameSize;\r\nreturn 0;\r\n}\r\nstatic int uvc_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct uvc_buffer *buf = container_of(vb, struct uvc_buffer, buf);\r\nif (vb->v4l2_buf.type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\nvb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0)) {\r\nuvc_trace(UVC_TRACE_CAPTURE, "[E] Bytes used out of bounds.\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(queue->flags & UVC_QUEUE_DISCONNECTED))\r\nreturn -ENODEV;\r\nbuf->state = UVC_BUF_STATE_QUEUED;\r\nbuf->error = 0;\r\nbuf->mem = vb2_plane_vaddr(vb, 0);\r\nbuf->length = vb2_plane_size(vb, 0);\r\nif (vb->v4l2_buf.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nbuf->bytesused = 0;\r\nelse\r\nbuf->bytesused = vb2_get_plane_payload(vb, 0);\r\nreturn 0;\r\n}\r\nstatic void uvc_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct uvc_buffer *buf = container_of(vb, struct uvc_buffer, buf);\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nif (likely(!(queue->flags & UVC_QUEUE_DISCONNECTED))) {\r\nlist_add_tail(&buf->queue, &queue->irqqueue);\r\n} else {\r\nbuf->state = UVC_BUF_STATE_ERROR;\r\nvb2_buffer_done(&buf->buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nstatic void uvc_buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct uvc_streaming *stream =\r\ncontainer_of(queue, struct uvc_streaming, queue);\r\nstruct uvc_buffer *buf = container_of(vb, struct uvc_buffer, buf);\r\nif (vb->state == VB2_BUF_STATE_DONE)\r\nuvc_video_clock_update(stream, &vb->v4l2_buf, buf);\r\n}\r\nstatic void uvc_wait_prepare(struct vb2_queue *vq)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\r\nmutex_unlock(&queue->mutex);\r\n}\r\nstatic void uvc_wait_finish(struct vb2_queue *vq)\r\n{\r\nstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\r\nmutex_lock(&queue->mutex);\r\n}\r\nint uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,\r\nint drop_corrupted)\r\n{\r\nint ret;\r\nqueue->queue.type = type;\r\nqueue->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nqueue->queue.drv_priv = queue;\r\nqueue->queue.buf_struct_size = sizeof(struct uvc_buffer);\r\nqueue->queue.ops = &uvc_queue_qops;\r\nqueue->queue.mem_ops = &vb2_vmalloc_memops;\r\nqueue->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC\r\n| V4L2_BUF_FLAG_TSTAMP_SRC_SOE;\r\nret = vb2_queue_init(&queue->queue);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&queue->mutex);\r\nspin_lock_init(&queue->irqlock);\r\nINIT_LIST_HEAD(&queue->irqqueue);\r\nqueue->flags = drop_corrupted ? UVC_QUEUE_DROP_CORRUPTED : 0;\r\nreturn 0;\r\n}\r\nint uvc_alloc_buffers(struct uvc_video_queue *queue,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_reqbufs(&queue->queue, rb);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret ? ret : rb->count;\r\n}\r\nvoid uvc_free_buffers(struct uvc_video_queue *queue)\r\n{\r\nmutex_lock(&queue->mutex);\r\nvb2_queue_release(&queue->queue);\r\nmutex_unlock(&queue->mutex);\r\n}\r\nint uvc_query_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_querybuf(&queue->queue, buf);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_create_buffers(struct uvc_video_queue *queue,\r\nstruct v4l2_create_buffers *cb)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_create_bufs(&queue->queue, cb);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_qbuf(&queue->queue, buf);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_dequeue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf,\r\nint nonblocking)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_dqbuf(&queue->queue, buf, nonblocking);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_mmap(struct uvc_video_queue *queue, struct vm_area_struct *vma)\r\n{\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_mmap(&queue->queue, vma);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nunsigned long uvc_queue_get_unmapped_area(struct uvc_video_queue *queue,\r\nunsigned long pgoff)\r\n{\r\nunsigned long ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_get_unmapped_area(&queue->queue, 0, 0, pgoff, 0);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nunsigned int uvc_queue_poll(struct uvc_video_queue *queue, struct file *file,\r\npoll_table *wait)\r\n{\r\nunsigned int ret;\r\nmutex_lock(&queue->mutex);\r\nret = vb2_poll(&queue->queue, file, wait);\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nint uvc_queue_allocated(struct uvc_video_queue *queue)\r\n{\r\nint allocated;\r\nmutex_lock(&queue->mutex);\r\nallocated = vb2_is_busy(&queue->queue);\r\nmutex_unlock(&queue->mutex);\r\nreturn allocated;\r\n}\r\nint uvc_queue_enable(struct uvc_video_queue *queue, int enable)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nmutex_lock(&queue->mutex);\r\nif (enable) {\r\nret = vb2_streamon(&queue->queue, queue->queue.type);\r\nif (ret < 0)\r\ngoto done;\r\nqueue->buf_used = 0;\r\n} else {\r\nret = vb2_streamoff(&queue->queue, queue->queue.type);\r\nif (ret < 0)\r\ngoto done;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nINIT_LIST_HEAD(&queue->irqqueue);\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\ndone:\r\nmutex_unlock(&queue->mutex);\r\nreturn ret;\r\n}\r\nvoid uvc_queue_cancel(struct uvc_video_queue *queue, int disconnect)\r\n{\r\nstruct uvc_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nwhile (!list_empty(&queue->irqqueue)) {\r\nbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\r\nqueue);\r\nlist_del(&buf->queue);\r\nbuf->state = UVC_BUF_STATE_ERROR;\r\nvb2_buffer_done(&buf->buf, VB2_BUF_STATE_ERROR);\r\n}\r\nif (disconnect)\r\nqueue->flags |= UVC_QUEUE_DISCONNECTED;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nstruct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,\r\nstruct uvc_buffer *buf)\r\n{\r\nstruct uvc_buffer *nextbuf;\r\nunsigned long flags;\r\nif ((queue->flags & UVC_QUEUE_DROP_CORRUPTED) && buf->error) {\r\nbuf->error = 0;\r\nbuf->state = UVC_BUF_STATE_QUEUED;\r\nbuf->bytesused = 0;\r\nvb2_set_plane_payload(&buf->buf, 0, 0);\r\nreturn buf;\r\n}\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nlist_del(&buf->queue);\r\nif (!list_empty(&queue->irqqueue))\r\nnextbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\r\nqueue);\r\nelse\r\nnextbuf = NULL;\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\nbuf->state = buf->error ? VB2_BUF_STATE_ERROR : UVC_BUF_STATE_DONE;\r\nvb2_set_plane_payload(&buf->buf, 0, buf->bytesused);\r\nvb2_buffer_done(&buf->buf, VB2_BUF_STATE_DONE);\r\nreturn nextbuf;\r\n}
