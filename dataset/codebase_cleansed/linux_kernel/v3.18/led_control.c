static B_UINT16 CFG_CalculateChecksum(B_UINT8 *pu8Buffer, B_UINT32 u32Size)\r\n{\r\nB_UINT16 u16CheckSum = 0;\r\nwhile (u32Size--) {\r\nu16CheckSum += (B_UINT8)~(*pu8Buffer);\r\npu8Buffer++;\r\n}\r\nreturn u16CheckSum;\r\n}\r\nbool IsReqGpioIsLedInNVM(struct bcm_mini_adapter *Adapter, UINT gpios)\r\n{\r\nINT Status;\r\nStatus = (Adapter->gpioBitMap & gpios) ^ gpios;\r\nif (Status)\r\nreturn false;\r\nelse\r\nreturn TRUE;\r\n}\r\nstatic INT LED_Blink(struct bcm_mini_adapter *Adapter,\r\nUINT GPIO_Num,\r\nUCHAR uiLedIndex,\r\nULONG timeout,\r\nINT num_of_time,\r\nenum bcm_led_events currdriverstate)\r\n{\r\nint Status = STATUS_SUCCESS;\r\nbool bInfinite = false;\r\nif (num_of_time < 0) {\r\nbInfinite = TRUE;\r\nnum_of_time = 1;\r\n}\r\nwhile (num_of_time) {\r\nif (currdriverstate == Adapter->DriverState)\r\nTURN_ON_LED(Adapter, GPIO_Num, uiLedIndex);\r\nStatus = wait_event_interruptible_timeout(\r\nAdapter->LEDInfo.notify_led_event,\r\ncurrdriverstate != Adapter->DriverState ||\r\nkthread_should_stop(),\r\nmsecs_to_jiffies(timeout));\r\nif (kthread_should_stop()) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL,\r\n"Led thread got signal to exit..hence exiting");\r\nAdapter->LEDInfo.led_thread_running =\r\nBCM_LED_THREAD_DISABLED;\r\nTURN_OFF_LED(Adapter, GPIO_Num, uiLedIndex);\r\nStatus = EVENT_SIGNALED;\r\nbreak;\r\n}\r\nif (Status) {\r\nTURN_OFF_LED(Adapter, GPIO_Num, uiLedIndex);\r\nStatus = EVENT_SIGNALED;\r\nbreak;\r\n}\r\nTURN_OFF_LED(Adapter, GPIO_Num, uiLedIndex);\r\nStatus = wait_event_interruptible_timeout(\r\nAdapter->LEDInfo.notify_led_event,\r\ncurrdriverstate != Adapter->DriverState ||\r\nkthread_should_stop(),\r\nmsecs_to_jiffies(timeout));\r\nif (bInfinite == false)\r\nnum_of_time--;\r\n}\r\nreturn Status;\r\n}\r\nstatic INT ScaleRateofTransfer(ULONG rate)\r\n{\r\nif (rate <= 3)\r\nreturn rate;\r\nelse if ((rate > 3) && (rate <= 100))\r\nreturn 5;\r\nelse if ((rate > 100) && (rate <= 200))\r\nreturn 6;\r\nelse if ((rate > 200) && (rate <= 300))\r\nreturn 7;\r\nelse if ((rate > 300) && (rate <= 400))\r\nreturn 8;\r\nelse if ((rate > 400) && (rate <= 500))\r\nreturn 9;\r\nelse if ((rate > 500) && (rate <= 600))\r\nreturn 10;\r\nelse\r\nreturn MAX_NUM_OF_BLINKS;\r\n}\r\nstatic INT blink_in_normal_bandwidth(struct bcm_mini_adapter *ad,\r\nINT *time,\r\nINT *time_tx,\r\nINT *time_rx,\r\nUCHAR GPIO_Num_tx,\r\nUCHAR uiTxLedIndex,\r\nUCHAR GPIO_Num_rx,\r\nUCHAR uiRxLedIndex,\r\nenum bcm_led_events currdriverstate,\r\nulong *timeout)\r\n{\r\n*time = (*time_tx > *time_rx ? *time_rx : *time_tx);\r\nif (*time > 0) {\r\nif ((LED_Blink(ad, 1 << GPIO_Num_tx, uiTxLedIndex, *timeout,\r\n*time, currdriverstate) == EVENT_SIGNALED) ||\r\n(LED_Blink(ad, 1 << GPIO_Num_rx, uiRxLedIndex, *timeout,\r\n*time, currdriverstate) == EVENT_SIGNALED))\r\nreturn EVENT_SIGNALED;\r\n}\r\nif (*time == *time_tx) {\r\nif (LED_Blink(ad, (1 << GPIO_Num_rx), uiRxLedIndex, *timeout,\r\n*time_rx - *time,\r\ncurrdriverstate) == EVENT_SIGNALED)\r\nreturn EVENT_SIGNALED;\r\n*time = *time_rx;\r\n} else {\r\nif (LED_Blink(ad, 1 << GPIO_Num_tx, uiTxLedIndex, *timeout,\r\n*time_tx - *time,\r\ncurrdriverstate) == EVENT_SIGNALED)\r\nreturn EVENT_SIGNALED;\r\n*time = *time_tx;\r\n}\r\nreturn 0;\r\n}\r\nstatic INT LED_Proportional_Blink(struct bcm_mini_adapter *Adapter,\r\nUCHAR GPIO_Num_tx,\r\nUCHAR uiTxLedIndex,\r\nUCHAR GPIO_Num_rx,\r\nUCHAR uiRxLedIndex,\r\nenum bcm_led_events currdriverstate)\r\n{\r\nULONG64 Initial_num_of_packts_tx = 0, Initial_num_of_packts_rx = 0;\r\nULONG64 Final_num_of_packts_tx = 0, Final_num_of_packts_rx = 0;\r\nULONG64 rate_of_transfer_tx = 0, rate_of_transfer_rx = 0;\r\nint Status = STATUS_SUCCESS;\r\nINT num_of_time = 0, num_of_time_tx = 0, num_of_time_rx = 0;\r\nUINT remDelay = 0;\r\nulong timeout = 0;\r\nInitial_num_of_packts_tx = Adapter->dev->stats.tx_packets;\r\nInitial_num_of_packts_rx = Adapter->dev->stats.rx_packets;\r\nnum_of_time_tx = ScaleRateofTransfer((ULONG)rate_of_transfer_tx);\r\nnum_of_time_rx = ScaleRateofTransfer((ULONG)rate_of_transfer_rx);\r\nwhile ((Adapter->device_removed == false)) {\r\ntimeout = 50;\r\nif (EVENT_SIGNALED == blink_in_normal_bandwidth(Adapter,\r\n&num_of_time,\r\n&num_of_time_tx,\r\n&num_of_time_rx,\r\nGPIO_Num_tx,\r\nuiTxLedIndex,\r\nGPIO_Num_rx,\r\nuiRxLedIndex,\r\ncurrdriverstate,\r\n&timeout))\r\nreturn EVENT_SIGNALED;\r\nremDelay = MAX_NUM_OF_BLINKS - num_of_time;\r\nif (remDelay > 0) {\r\ntimeout = 100 * remDelay;\r\nStatus = wait_event_interruptible_timeout(\r\nAdapter->LEDInfo.notify_led_event,\r\ncurrdriverstate != Adapter->DriverState\r\n|| kthread_should_stop(),\r\nmsecs_to_jiffies(timeout));\r\nif (kthread_should_stop()) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nLED_DUMP_INFO, DBG_LVL_ALL,\r\n"Led thread got signal to exit..hence exiting");\r\nAdapter->LEDInfo.led_thread_running =\r\nBCM_LED_THREAD_DISABLED;\r\nreturn EVENT_SIGNALED;\r\n}\r\nif (Status)\r\nreturn EVENT_SIGNALED;\r\n}\r\nTURN_OFF_LED(Adapter, 1 << GPIO_Num_tx, uiTxLedIndex);\r\nTURN_OFF_LED(Adapter, 1 << GPIO_Num_rx, uiTxLedIndex);\r\nFinal_num_of_packts_tx = Adapter->dev->stats.tx_packets;\r\nFinal_num_of_packts_rx = Adapter->dev->stats.rx_packets;\r\nrate_of_transfer_tx = Final_num_of_packts_tx -\r\nInitial_num_of_packts_tx;\r\nrate_of_transfer_rx = Final_num_of_packts_rx -\r\nInitial_num_of_packts_rx;\r\nInitial_num_of_packts_tx = Final_num_of_packts_tx;\r\nInitial_num_of_packts_rx = Final_num_of_packts_rx;\r\nnum_of_time_tx =\r\nScaleRateofTransfer((ULONG)rate_of_transfer_tx);\r\nnum_of_time_rx =\r\nScaleRateofTransfer((ULONG)rate_of_transfer_rx);\r\n}\r\nreturn Status;\r\n}\r\nstatic INT ValidateDSDParamsChecksum(struct bcm_mini_adapter *Adapter,\r\nULONG ulParamOffset,\r\nUSHORT usParamLen)\r\n{\r\nINT Status = STATUS_SUCCESS;\r\nPUCHAR puBuffer = NULL;\r\nUSHORT usChksmOrg = 0;\r\nUSHORT usChecksumCalculated = 0;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,\r\n"LED Thread:ValidateDSDParamsChecksum: 0x%lx 0x%X",\r\nulParamOffset, usParamLen);\r\npuBuffer = kmalloc(usParamLen, GFP_KERNEL);\r\nif (!puBuffer) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL,\r\n"LED Thread: ValidateDSDParamsChecksum Allocation failed");\r\nreturn -ENOMEM;\r\n}\r\nif (STATUS_SUCCESS != BeceemNVMRead(Adapter, (PUINT)puBuffer,\r\nulParamOffset, usParamLen)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL,\r\n"LED Thread: ValidateDSDParamsChecksum BeceemNVMRead failed");\r\nStatus = STATUS_IMAGE_CHECKSUM_MISMATCH;\r\ngoto exit;\r\n}\r\nusChecksumCalculated = CFG_CalculateChecksum(puBuffer, usParamLen);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,\r\n"LED Thread: usCheckSumCalculated = 0x%x\n",\r\nusChecksumCalculated);\r\nif (STATUS_SUCCESS != BeceemNVMRead(Adapter, (PUINT)&usChksmOrg,\r\nulParamOffset+usParamLen, 2)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL,\r\n"LED Thread: ValidateDSDParamsChecksum BeceemNVMRead failed");\r\nStatus = STATUS_IMAGE_CHECKSUM_MISMATCH;\r\ngoto exit;\r\n}\r\nusChksmOrg = ntohs(usChksmOrg);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,\r\n"LED Thread: usChksmOrg = 0x%x", usChksmOrg);\r\nif (usChecksumCalculated ^ usChksmOrg) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL,\r\n"LED Thread: ValidateDSDParamsChecksum: Checksums don't match");\r\nStatus = STATUS_IMAGE_CHECKSUM_MISMATCH;\r\ngoto exit;\r\n}\r\nexit:\r\nkfree(puBuffer);\r\nreturn Status;\r\n}\r\nstatic INT ValidateHWParmStructure(struct bcm_mini_adapter *Adapter,\r\nULONG ulHwParamOffset)\r\n{\r\nINT Status = STATUS_SUCCESS;\r\nUSHORT HwParamLen = 0;\r\nulHwParamOffset += DSD_START_OFFSET;\r\nBeceemNVMRead(Adapter, (PUINT)&HwParamLen, ulHwParamOffset, 2);\r\nHwParamLen = ntohs(HwParamLen);\r\nif (0 == HwParamLen || HwParamLen > Adapter->uiNVMDSDSize)\r\nreturn STATUS_IMAGE_CHECKSUM_MISMATCH;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,\r\n"LED Thread:HwParamLen = 0x%x", HwParamLen);\r\nStatus = ValidateDSDParamsChecksum(Adapter, ulHwParamOffset,\r\nHwParamLen);\r\nreturn Status;\r\n}\r\nstatic int ReadLEDInformationFromEEPROM(struct bcm_mini_adapter *Adapter,\r\nUCHAR GPIO_Array[])\r\n{\r\nint Status = STATUS_SUCCESS;\r\nULONG dwReadValue = 0;\r\nUSHORT usHwParamData = 0;\r\nUSHORT usEEPROMVersion = 0;\r\nUCHAR ucIndex = 0;\r\nUCHAR ucGPIOInfo[32] = {0};\r\nBeceemNVMRead(Adapter, (PUINT)&usEEPROMVersion,\r\nEEPROM_VERSION_OFFSET, 2);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,\r\n"usEEPROMVersion: Minor:0x%X Major:0x%x",\r\nusEEPROMVersion & 0xFF,\r\n((usEEPROMVersion >> 8) & 0xFF));\r\nif (((usEEPROMVersion>>8)&0xFF) < EEPROM_MAP5_MAJORVERSION) {\r\nBeceemNVMRead(Adapter, (PUINT)&usHwParamData,\r\nEEPROM_HW_PARAM_POINTER_ADDRESS, 2);\r\nusHwParamData = ntohs(usHwParamData);\r\ndwReadValue = usHwParamData;\r\n} else {\r\nStatus = ValidateDSDParamsChecksum(Adapter,\r\nDSD_START_OFFSET,\r\nCOMPATIBILITY_SECTION_LENGTH_MAP5);\r\nif (Status != STATUS_SUCCESS)\r\nreturn Status;\r\nBeceemNVMRead(Adapter, (PUINT)&dwReadValue,\r\nEEPROM_HW_PARAM_POINTER_ADDRRES_MAP5, 4);\r\ndwReadValue = ntohl(dwReadValue);\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,\r\n"LED Thread: Start address of HW_PARAM structure = 0x%lx",\r\ndwReadValue);\r\nif (dwReadValue < DSD_START_OFFSET ||\r\ndwReadValue > (Adapter->uiNVMDSDSize-DSD_START_OFFSET))\r\nreturn STATUS_IMAGE_CHECKSUM_MISMATCH;\r\nStatus = ValidateHWParmStructure(Adapter, dwReadValue);\r\nif (Status)\r\nreturn Status;\r\ndwReadValue += DSD_START_OFFSET;\r\ndwReadValue += GPIO_SECTION_START_OFFSET;\r\nBeceemNVMRead(Adapter, (UINT *)ucGPIOInfo, dwReadValue, 32);\r\nfor (ucIndex = 0; ucIndex < 32; ucIndex++) {\r\nswitch (ucGPIOInfo[ucIndex]) {\r\ncase RED_LED:\r\nGPIO_Array[RED_LED] = ucIndex;\r\nAdapter->gpioBitMap |= (1 << ucIndex);\r\nbreak;\r\ncase BLUE_LED:\r\nGPIO_Array[BLUE_LED] = ucIndex;\r\nAdapter->gpioBitMap |= (1 << ucIndex);\r\nbreak;\r\ncase YELLOW_LED:\r\nGPIO_Array[YELLOW_LED] = ucIndex;\r\nAdapter->gpioBitMap |= (1 << ucIndex);\r\nbreak;\r\ncase GREEN_LED:\r\nGPIO_Array[GREEN_LED] = ucIndex;\r\nAdapter->gpioBitMap |= (1 << ucIndex);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,\r\n"GPIO's bit map correspond to LED :0x%X",\r\nAdapter->gpioBitMap);\r\nreturn Status;\r\n}\r\nstatic int ReadConfigFileStructure(struct bcm_mini_adapter *Adapter,\r\nbool *bEnableThread)\r\n{\r\nint Status = STATUS_SUCCESS;\r\nUCHAR GPIO_Array[NUM_OF_LEDS+1];\r\nUINT uiIndex = 0;\r\nUINT uiNum_of_LED_Type = 0;\r\nPUCHAR puCFGData = NULL;\r\nUCHAR bData = 0;\r\nstruct bcm_led_state_info *curr_led_state;\r\nmemset(GPIO_Array, DISABLE_GPIO_NUM, NUM_OF_LEDS+1);\r\nif (!Adapter->pstargetparams || IS_ERR(Adapter->pstargetparams)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL, "Target Params not Avail.\n");\r\nreturn -ENOENT;\r\n}\r\nStatus = ReadLEDInformationFromEEPROM(Adapter, GPIO_Array);\r\nif (Status == STATUS_IMAGE_CHECKSUM_MISMATCH) {\r\n*bEnableThread = false;\r\nreturn STATUS_SUCCESS;\r\n} else if (Status) {\r\n*bEnableThread = false;\r\nreturn Status;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO, DBG_LVL_ALL,\r\n"LED Thread: Config file read successfully\n");\r\npuCFGData = (PUCHAR) &Adapter->pstargetparams->HostDrvrConfig1;\r\nfor (uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++) {\r\nbData = *puCFGData;\r\ncurr_led_state = &Adapter->LEDInfo.LEDState[uiIndex];\r\nif (bData & 0x80) {\r\ncurr_led_state->BitPolarity = 0;\r\nbData = bData & 0x7f;\r\n}\r\ncurr_led_state->LED_Type = bData;\r\nif (bData <= NUM_OF_LEDS)\r\ncurr_led_state->GPIO_Num = GPIO_Array[bData];\r\nelse\r\ncurr_led_state->GPIO_Num = DISABLE_GPIO_NUM;\r\npuCFGData++;\r\nbData = *puCFGData;\r\ncurr_led_state->LED_On_State = bData;\r\npuCFGData++;\r\nbData = *puCFGData;\r\ncurr_led_state->LED_Blink_State = bData;\r\npuCFGData++;\r\n}\r\nfor (uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++) {\r\ncurr_led_state = &Adapter->LEDInfo.LEDState[uiIndex];\r\nif ((curr_led_state->LED_Type == DISABLE_GPIO_NUM) ||\r\n(curr_led_state->LED_Type == 0x7f) ||\r\n(curr_led_state->LED_Type == 0))\r\nuiNum_of_LED_Type++;\r\n}\r\nif (uiNum_of_LED_Type >= NUM_OF_LEDS)\r\n*bEnableThread = false;\r\nreturn Status;\r\n}\r\nstatic VOID LedGpioInit(struct bcm_mini_adapter *Adapter)\r\n{\r\nUINT uiResetValue = 0;\r\nUINT uiIndex = 0;\r\nstruct bcm_led_state_info *curr_led_state;\r\nif (rdmalt(Adapter, GPIO_MODE_REGISTER, &uiResetValue,\r\nsizeof(uiResetValue)) < 0)\r\nBCM_DEBUG_PRINT (Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL, "LED Thread: RDM Failed\n");\r\nfor (uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++) {\r\ncurr_led_state = &Adapter->LEDInfo.LEDState[uiIndex];\r\nif (curr_led_state->GPIO_Num != DISABLE_GPIO_NUM)\r\nuiResetValue |= (1 << curr_led_state->GPIO_Num);\r\nTURN_OFF_LED(Adapter, 1 << curr_led_state->GPIO_Num, uiIndex);\r\n}\r\nif (wrmalt(Adapter, GPIO_MODE_REGISTER, &uiResetValue,\r\nsizeof(uiResetValue)) < 0)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL, "LED Thread: WRM Failed\n");\r\nAdapter->LEDInfo.bIdle_led_off = false;\r\n}\r\nstatic INT BcmGetGPIOPinInfo(struct bcm_mini_adapter *Adapter,\r\nUCHAR *GPIO_num_tx,\r\nUCHAR *GPIO_num_rx,\r\nUCHAR *uiLedTxIndex,\r\nUCHAR *uiLedRxIndex,\r\nenum bcm_led_events currdriverstate)\r\n{\r\nUINT uiIndex = 0;\r\nstruct bcm_led_state_info *led_state_info;\r\n*GPIO_num_tx = DISABLE_GPIO_NUM;\r\n*GPIO_num_rx = DISABLE_GPIO_NUM;\r\nfor (uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++) {\r\nled_state_info = &Adapter->LEDInfo.LEDState[uiIndex];\r\nif (((currdriverstate == NORMAL_OPERATION) ||\r\n(currdriverstate == IDLEMODE_EXIT) ||\r\n(currdriverstate == FW_DOWNLOAD)) &&\r\n(led_state_info->LED_Blink_State & currdriverstate) &&\r\n(led_state_info->GPIO_Num != DISABLE_GPIO_NUM)) {\r\nif (*GPIO_num_tx == DISABLE_GPIO_NUM) {\r\n*GPIO_num_tx = led_state_info->GPIO_Num;\r\n*uiLedTxIndex = uiIndex;\r\n} else {\r\n*GPIO_num_rx = led_state_info->GPIO_Num;\r\n*uiLedRxIndex = uiIndex;\r\n}\r\n} else {\r\nif ((led_state_info->LED_On_State & currdriverstate) &&\r\n(led_state_info->GPIO_Num != DISABLE_GPIO_NUM)) {\r\n*GPIO_num_tx = led_state_info->GPIO_Num;\r\n*uiLedTxIndex = uiIndex;\r\n}\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic void handle_adapter_driver_state(struct bcm_mini_adapter *ad,\r\nenum bcm_led_events currdriverstate,\r\nUCHAR GPIO_num,\r\nUCHAR dummyGPIONum,\r\nUCHAR uiLedIndex,\r\nUCHAR dummyIndex,\r\nulong timeout,\r\nUINT uiResetValue,\r\nUINT uiIndex)\r\n{\r\nswitch (ad->DriverState) {\r\ncase DRIVER_INIT:\r\ncurrdriverstate = DRIVER_INIT;\r\nBcmGetGPIOPinInfo(ad, &GPIO_num, &dummyGPIONum,\r\n&uiLedIndex, &dummyIndex,\r\ncurrdriverstate);\r\nif (GPIO_num != DISABLE_GPIO_NUM)\r\nTURN_ON_LED(ad, 1 << GPIO_num, uiLedIndex);\r\nbreak;\r\ncase FW_DOWNLOAD:\r\ncurrdriverstate = FW_DOWNLOAD;\r\nBcmGetGPIOPinInfo(ad, &GPIO_num, &dummyGPIONum,\r\n&uiLedIndex, &dummyIndex,\r\ncurrdriverstate);\r\nif (GPIO_num != DISABLE_GPIO_NUM) {\r\ntimeout = 50;\r\nLED_Blink(ad, 1 << GPIO_num, uiLedIndex, timeout,\r\n-1, currdriverstate);\r\n}\r\nbreak;\r\ncase FW_DOWNLOAD_DONE:\r\ncurrdriverstate = FW_DOWNLOAD_DONE;\r\nBcmGetGPIOPinInfo(ad, &GPIO_num, &dummyGPIONum,\r\n&uiLedIndex, &dummyIndex, currdriverstate);\r\nif (GPIO_num != DISABLE_GPIO_NUM)\r\nTURN_ON_LED(ad, 1 << GPIO_num, uiLedIndex);\r\nbreak;\r\ncase SHUTDOWN_EXIT:\r\ncase NO_NETWORK_ENTRY:\r\ncurrdriverstate = NO_NETWORK_ENTRY;\r\nBcmGetGPIOPinInfo(ad, &GPIO_num, &dummyGPIONum,\r\n&uiLedIndex, &dummyGPIONum, currdriverstate);\r\nif (GPIO_num != DISABLE_GPIO_NUM)\r\nTURN_ON_LED(ad, 1 << GPIO_num, uiLedIndex);\r\nbreak;\r\ncase NORMAL_OPERATION:\r\n{\r\nUCHAR GPIO_num_tx = DISABLE_GPIO_NUM;\r\nUCHAR GPIO_num_rx = DISABLE_GPIO_NUM;\r\nUCHAR uiLEDTx = 0;\r\nUCHAR uiLEDRx = 0;\r\ncurrdriverstate = NORMAL_OPERATION;\r\nad->LEDInfo.bIdle_led_off = false;\r\nBcmGetGPIOPinInfo(ad, &GPIO_num_tx, &GPIO_num_rx,\r\n&uiLEDTx, &uiLEDRx, currdriverstate);\r\nif ((GPIO_num_tx == DISABLE_GPIO_NUM) &&\r\n(GPIO_num_rx == DISABLE_GPIO_NUM)) {\r\nGPIO_num = DISABLE_GPIO_NUM;\r\n} else {\r\nif (GPIO_num_tx == DISABLE_GPIO_NUM) {\r\nGPIO_num_tx = GPIO_num_rx;\r\nuiLEDTx = uiLEDRx;\r\n} else if (GPIO_num_rx == DISABLE_GPIO_NUM) {\r\nGPIO_num_rx = GPIO_num_tx;\r\nuiLEDRx = uiLEDTx;\r\n}\r\nLED_Proportional_Blink(ad,\r\nGPIO_num_tx, uiLEDTx,\r\nGPIO_num_rx, uiLEDRx,\r\ncurrdriverstate);\r\n}\r\n}\r\nbreak;\r\ncase LOWPOWER_MODE_ENTER:\r\ncurrdriverstate = LOWPOWER_MODE_ENTER;\r\nif (DEVICE_POWERSAVE_MODE_AS_MANUAL_CLOCK_GATING ==\r\nad->ulPowerSaveMode) {\r\nuiResetValue = 0;\r\nfor (uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++) {\r\nif (ad->LEDInfo.LEDState[uiIndex].GPIO_Num != DISABLE_GPIO_NUM)\r\nTURN_OFF_LED(ad,\r\n(1 << ad->LEDInfo.LEDState[uiIndex].GPIO_Num),\r\nuiIndex);\r\n}\r\n}\r\nad->LEDInfo.bLedInitDone = false;\r\nad->LEDInfo.bIdle_led_off = TRUE;\r\nwake_up(&ad->LEDInfo.idleModeSyncEvent);\r\nGPIO_num = DISABLE_GPIO_NUM;\r\nbreak;\r\ncase IDLEMODE_CONTINUE:\r\ncurrdriverstate = IDLEMODE_CONTINUE;\r\nGPIO_num = DISABLE_GPIO_NUM;\r\nbreak;\r\ncase IDLEMODE_EXIT:\r\nbreak;\r\ncase DRIVER_HALT:\r\ncurrdriverstate = DRIVER_HALT;\r\nGPIO_num = DISABLE_GPIO_NUM;\r\nfor (uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++) {\r\nif (ad->LEDInfo.LEDState[uiIndex].GPIO_Num !=\r\nDISABLE_GPIO_NUM)\r\nTURN_OFF_LED(ad,\r\n(1 << ad->LEDInfo.LEDState[uiIndex].GPIO_Num),\r\nuiIndex);\r\n}\r\nbreak;\r\ncase LED_THREAD_INACTIVE:\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL, "InActivating LED thread...");\r\ncurrdriverstate = LED_THREAD_INACTIVE;\r\nad->LEDInfo.led_thread_running =\r\nBCM_LED_THREAD_RUNNING_INACTIVELY;\r\nad->LEDInfo.bLedInitDone = false;\r\nfor (uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++) {\r\nif (ad->LEDInfo.LEDState[uiIndex].GPIO_Num !=\r\nDISABLE_GPIO_NUM)\r\nTURN_OFF_LED(ad,\r\n(1 << ad->LEDInfo.LEDState[uiIndex].GPIO_Num),\r\nuiIndex);\r\n}\r\nbreak;\r\ncase LED_THREAD_ACTIVE:\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL, "Activating LED thread again...");\r\nif (ad->LinkUpStatus == false)\r\nad->DriverState = NO_NETWORK_ENTRY;\r\nelse\r\nad->DriverState = NORMAL_OPERATION;\r\nad->LEDInfo.led_thread_running =\r\nBCM_LED_THREAD_RUNNING_ACTIVELY;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic VOID LEDControlThread(struct bcm_mini_adapter *Adapter)\r\n{\r\nUINT uiIndex = 0;\r\nUCHAR GPIO_num = 0;\r\nUCHAR uiLedIndex = 0;\r\nUINT uiResetValue = 0;\r\nenum bcm_led_events currdriverstate = 0;\r\nulong timeout = 0;\r\nINT Status = 0;\r\nUCHAR dummyGPIONum = 0;\r\nUCHAR dummyIndex = 0;\r\nAdapter->LEDInfo.bIdleMode_tx_from_host = false;\r\nGPIO_num = DISABLE_GPIO_NUM;\r\nwhile (TRUE) {\r\nif ((GPIO_num == DISABLE_GPIO_NUM)\r\n||\r\n((currdriverstate != FW_DOWNLOAD) &&\r\n(currdriverstate != NORMAL_OPERATION) &&\r\n(currdriverstate != LOWPOWER_MODE_ENTER))\r\n||\r\n(currdriverstate == LED_THREAD_INACTIVE))\r\nStatus = wait_event_interruptible(\r\nAdapter->LEDInfo.notify_led_event,\r\ncurrdriverstate != Adapter->DriverState\r\n|| kthread_should_stop());\r\nif (kthread_should_stop() || Adapter->device_removed) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL,\r\n"Led thread got signal to exit..hence exiting");\r\nAdapter->LEDInfo.led_thread_running =\r\nBCM_LED_THREAD_DISABLED;\r\nTURN_OFF_LED(Adapter, 1 << GPIO_num, uiLedIndex);\r\nreturn;\r\n}\r\nif (GPIO_num != DISABLE_GPIO_NUM)\r\nTURN_OFF_LED(Adapter, 1 << GPIO_num, uiLedIndex);\r\nif (Adapter->LEDInfo.bLedInitDone == false) {\r\nLedGpioInit(Adapter);\r\nAdapter->LEDInfo.bLedInitDone = TRUE;\r\n}\r\nhandle_adapter_driver_state(Adapter,\r\ncurrdriverstate,\r\nGPIO_num,\r\ndummyGPIONum,\r\nuiLedIndex,\r\ndummyIndex,\r\ntimeout,\r\nuiResetValue,\r\nuiIndex\r\n);\r\n}\r\nAdapter->LEDInfo.led_thread_running = BCM_LED_THREAD_DISABLED;\r\n}\r\nint InitLedSettings(struct bcm_mini_adapter *Adapter)\r\n{\r\nint Status = STATUS_SUCCESS;\r\nbool bEnableThread = TRUE;\r\nUCHAR uiIndex = 0;\r\nfor (uiIndex = 0; uiIndex < NUM_OF_LEDS; uiIndex++)\r\nAdapter->LEDInfo.LEDState[uiIndex].BitPolarity = 1;\r\nStatus = ReadConfigFileStructure(Adapter, &bEnableThread);\r\nif (STATUS_SUCCESS != Status) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL,\r\n"LED Thread: FAILED in ReadConfigFileStructure\n");\r\nreturn Status;\r\n}\r\nif (Adapter->LEDInfo.led_thread_running) {\r\nif (bEnableThread) {\r\n;\r\n} else {\r\nAdapter->DriverState = DRIVER_HALT;\r\nwake_up(&Adapter->LEDInfo.notify_led_event);\r\nAdapter->LEDInfo.led_thread_running =\r\nBCM_LED_THREAD_DISABLED;\r\n}\r\n} else if (bEnableThread) {\r\ninit_waitqueue_head(&Adapter->LEDInfo.notify_led_event);\r\ninit_waitqueue_head(&Adapter->LEDInfo.idleModeSyncEvent);\r\nAdapter->LEDInfo.led_thread_running =\r\nBCM_LED_THREAD_RUNNING_ACTIVELY;\r\nAdapter->LEDInfo.bIdle_led_off = false;\r\nAdapter->LEDInfo.led_cntrl_threadid =\r\nkthread_run((int (*)(void *)) LEDControlThread,\r\nAdapter, "led_control_thread");\r\nif (IS_ERR(Adapter->LEDInfo.led_cntrl_threadid)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, LED_DUMP_INFO,\r\nDBG_LVL_ALL,\r\n"Not able to spawn Kernel Thread\n");\r\nAdapter->LEDInfo.led_thread_running =\r\nBCM_LED_THREAD_DISABLED;\r\nreturn PTR_ERR(Adapter->LEDInfo.led_cntrl_threadid);\r\n}\r\n}\r\nreturn Status;\r\n}
