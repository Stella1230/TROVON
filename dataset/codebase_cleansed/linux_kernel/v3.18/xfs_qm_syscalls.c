int\r\nxfs_qm_scall_quotaoff(\r\nxfs_mount_t *mp,\r\nuint flags)\r\n{\r\nstruct xfs_quotainfo *q = mp->m_quotainfo;\r\nuint dqtype;\r\nint error;\r\nuint inactivate_flags;\r\nxfs_qoff_logitem_t *qoffstart;\r\nif ((mp->m_qflags & flags) == 0)\r\nreturn -EEXIST;\r\nerror = 0;\r\nflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\r\nASSERT(q);\r\nmutex_lock(&q->qi_quotaofflock);\r\nif ((flags & XFS_ALL_QUOTA_ACCT) == 0) {\r\nmp->m_qflags &= ~(flags);\r\nspin_lock(&mp->m_sb_lock);\r\nmp->m_sb.sb_qflags = mp->m_qflags;\r\nspin_unlock(&mp->m_sb_lock);\r\nmutex_unlock(&q->qi_quotaofflock);\r\nerror = xfs_qm_write_sb_changes(mp, XFS_SB_QFLAGS);\r\nreturn error;\r\n}\r\ndqtype = 0;\r\ninactivate_flags = 0;\r\nif (flags & XFS_UQUOTA_ACCT) {\r\ndqtype |= XFS_QMOPT_UQUOTA;\r\nflags |= (XFS_UQUOTA_CHKD | XFS_UQUOTA_ENFD);\r\ninactivate_flags |= XFS_UQUOTA_ACTIVE;\r\n}\r\nif (flags & XFS_GQUOTA_ACCT) {\r\ndqtype |= XFS_QMOPT_GQUOTA;\r\nflags |= (XFS_GQUOTA_CHKD | XFS_GQUOTA_ENFD);\r\ninactivate_flags |= XFS_GQUOTA_ACTIVE;\r\n}\r\nif (flags & XFS_PQUOTA_ACCT) {\r\ndqtype |= XFS_QMOPT_PQUOTA;\r\nflags |= (XFS_PQUOTA_CHKD | XFS_PQUOTA_ENFD);\r\ninactivate_flags |= XFS_PQUOTA_ACTIVE;\r\n}\r\nif ((mp->m_qflags & flags) == 0)\r\ngoto out_unlock;\r\nerror = xfs_qm_log_quotaoff(mp, &qoffstart, flags);\r\nif (error)\r\ngoto out_unlock;\r\nmp->m_qflags &= ~inactivate_flags;\r\nxfs_qm_dqrele_all_inodes(mp, flags);\r\nmp->m_qflags &= ~flags;\r\nxfs_qm_dqpurge_all(mp, dqtype);\r\nerror = xfs_qm_log_quotaoff_end(mp, qoffstart, flags);\r\nif (error) {\r\nxfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\r\ngoto out_unlock;\r\n}\r\nif (mp->m_qflags == 0) {\r\nmutex_unlock(&q->qi_quotaofflock);\r\nxfs_qm_destroy_quotainfo(mp);\r\nreturn 0;\r\n}\r\nif ((dqtype & XFS_QMOPT_UQUOTA) && q->qi_uquotaip) {\r\nIRELE(q->qi_uquotaip);\r\nq->qi_uquotaip = NULL;\r\n}\r\nif ((dqtype & XFS_QMOPT_GQUOTA) && q->qi_gquotaip) {\r\nIRELE(q->qi_gquotaip);\r\nq->qi_gquotaip = NULL;\r\n}\r\nif ((dqtype & XFS_QMOPT_PQUOTA) && q->qi_pquotaip) {\r\nIRELE(q->qi_pquotaip);\r\nq->qi_pquotaip = NULL;\r\n}\r\nout_unlock:\r\nmutex_unlock(&q->qi_quotaofflock);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_scall_trunc_qfile(\r\nstruct xfs_mount *mp,\r\nxfs_ino_t ino)\r\n{\r\nstruct xfs_inode *ip;\r\nstruct xfs_trans *tp;\r\nint error;\r\nif (ino == NULLFSINO)\r\nreturn 0;\r\nerror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\r\nif (error)\r\nreturn error;\r\nxfs_ilock(ip, XFS_IOLOCK_EXCL);\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_TRUNCATE_FILE);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\ngoto out_put;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nip->i_d.di_size = 0;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nerror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES |\r\nXFS_TRANS_ABORT);\r\ngoto out_unlock;\r\n}\r\nASSERT(ip->i_d.di_nextents == 0);\r\nxfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nout_unlock:\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL | XFS_IOLOCK_EXCL);\r\nout_put:\r\nIRELE(ip);\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_scall_trunc_qfiles(\r\nxfs_mount_t *mp,\r\nuint flags)\r\n{\r\nint error = -EINVAL;\r\nif (!xfs_sb_version_hasquota(&mp->m_sb) || flags == 0 ||\r\n(flags & ~XFS_DQ_ALLTYPES)) {\r\nxfs_debug(mp, "%s: flags=%x m_qflags=%x",\r\n__func__, flags, mp->m_qflags);\r\nreturn -EINVAL;\r\n}\r\nif (flags & XFS_DQ_USER) {\r\nerror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_uquotino);\r\nif (error)\r\nreturn error;\r\n}\r\nif (flags & XFS_DQ_GROUP) {\r\nerror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_gquotino);\r\nif (error)\r\nreturn error;\r\n}\r\nif (flags & XFS_DQ_PROJ)\r\nerror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_pquotino);\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_scall_quotaon(\r\nxfs_mount_t *mp,\r\nuint flags)\r\n{\r\nint error;\r\nuint qf;\r\n__int64_t sbflags;\r\nflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\r\nflags &= ~(XFS_ALL_QUOTA_ACCT);\r\nsbflags = 0;\r\nif (flags == 0) {\r\nxfs_debug(mp, "%s: zero flags, m_qflags=%x",\r\n__func__, mp->m_qflags);\r\nreturn -EINVAL;\r\n}\r\nASSERT((flags & XFS_ALL_QUOTA_ACCT) == 0);\r\nif (((flags & XFS_UQUOTA_ACCT) == 0 &&\r\n(mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) == 0 &&\r\n(flags & XFS_UQUOTA_ENFD)) ||\r\n((flags & XFS_GQUOTA_ACCT) == 0 &&\r\n(mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) == 0 &&\r\n(flags & XFS_GQUOTA_ENFD)) ||\r\n((flags & XFS_PQUOTA_ACCT) == 0 &&\r\n(mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) == 0 &&\r\n(flags & XFS_PQUOTA_ENFD))) {\r\nxfs_debug(mp,\r\n"%s: Can't enforce without acct, flags=%x sbflags=%x",\r\n__func__, flags, mp->m_sb.sb_qflags);\r\nreturn -EINVAL;\r\n}\r\nif ((mp->m_qflags & flags) == flags)\r\nreturn -EEXIST;\r\nspin_lock(&mp->m_sb_lock);\r\nqf = mp->m_sb.sb_qflags;\r\nmp->m_sb.sb_qflags = qf | flags;\r\nspin_unlock(&mp->m_sb_lock);\r\nif ((qf & flags) == flags && sbflags == 0)\r\nreturn -EEXIST;\r\nsbflags |= XFS_SB_QFLAGS;\r\nif ((error = xfs_qm_write_sb_changes(mp, sbflags)))\r\nreturn error;\r\nif (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) !=\r\n(mp->m_qflags & XFS_UQUOTA_ACCT)) ||\r\n((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) !=\r\n(mp->m_qflags & XFS_PQUOTA_ACCT)) ||\r\n((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) !=\r\n(mp->m_qflags & XFS_GQUOTA_ACCT)) ||\r\n(flags & XFS_ALL_QUOTA_ENFD) == 0)\r\nreturn 0;\r\nif (! XFS_IS_QUOTA_RUNNING(mp))\r\nreturn -ESRCH;\r\nmutex_lock(&mp->m_quotainfo->qi_quotaofflock);\r\nmp->m_qflags |= (flags & XFS_ALL_QUOTA_ENFD);\r\nmutex_unlock(&mp->m_quotainfo->qi_quotaofflock);\r\nreturn 0;\r\n}\r\nint\r\nxfs_qm_scall_getqstat(\r\nstruct xfs_mount *mp,\r\nstruct fs_quota_stat *out)\r\n{\r\nstruct xfs_quotainfo *q = mp->m_quotainfo;\r\nstruct xfs_inode *uip = NULL;\r\nstruct xfs_inode *gip = NULL;\r\nstruct xfs_inode *pip = NULL;\r\nbool tempuqip = false;\r\nbool tempgqip = false;\r\nbool temppqip = false;\r\nmemset(out, 0, sizeof(fs_quota_stat_t));\r\nout->qs_version = FS_QSTAT_VERSION;\r\nif (!xfs_sb_version_hasquota(&mp->m_sb)) {\r\nout->qs_uquota.qfs_ino = NULLFSINO;\r\nout->qs_gquota.qfs_ino = NULLFSINO;\r\nreturn 0;\r\n}\r\nout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\r\n(XFS_ALL_QUOTA_ACCT|\r\nXFS_ALL_QUOTA_ENFD));\r\nif (q) {\r\nuip = q->qi_uquotaip;\r\ngip = q->qi_gquotaip;\r\npip = q->qi_pquotaip;\r\n}\r\nif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\r\nif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\r\n0, 0, &uip) == 0)\r\ntempuqip = true;\r\n}\r\nif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\r\nif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\r\n0, 0, &gip) == 0)\r\ntempgqip = true;\r\n}\r\nif (!gip) {\r\nif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\r\nif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\r\n0, 0, &pip) == 0)\r\ntemppqip = true;\r\n}\r\n} else\r\npip = NULL;\r\nif (uip) {\r\nout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\r\nout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\r\nout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\r\nif (tempuqip)\r\nIRELE(uip);\r\n}\r\nif (gip) {\r\nout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\r\nout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\r\nout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\r\nif (tempgqip)\r\nIRELE(gip);\r\n}\r\nif (pip) {\r\nout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\r\nout->qs_gquota.qfs_nblks = pip->i_d.di_nblocks;\r\nout->qs_gquota.qfs_nextents = pip->i_d.di_nextents;\r\nif (temppqip)\r\nIRELE(pip);\r\n}\r\nif (q) {\r\nout->qs_incoredqs = q->qi_dquots;\r\nout->qs_btimelimit = q->qi_btimelimit;\r\nout->qs_itimelimit = q->qi_itimelimit;\r\nout->qs_rtbtimelimit = q->qi_rtbtimelimit;\r\nout->qs_bwarnlimit = q->qi_bwarnlimit;\r\nout->qs_iwarnlimit = q->qi_iwarnlimit;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_qm_scall_getqstatv(\r\nstruct xfs_mount *mp,\r\nstruct fs_quota_statv *out)\r\n{\r\nstruct xfs_quotainfo *q = mp->m_quotainfo;\r\nstruct xfs_inode *uip = NULL;\r\nstruct xfs_inode *gip = NULL;\r\nstruct xfs_inode *pip = NULL;\r\nbool tempuqip = false;\r\nbool tempgqip = false;\r\nbool temppqip = false;\r\nif (!xfs_sb_version_hasquota(&mp->m_sb)) {\r\nout->qs_uquota.qfs_ino = NULLFSINO;\r\nout->qs_gquota.qfs_ino = NULLFSINO;\r\nout->qs_pquota.qfs_ino = NULLFSINO;\r\nreturn 0;\r\n}\r\nout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\r\n(XFS_ALL_QUOTA_ACCT|\r\nXFS_ALL_QUOTA_ENFD));\r\nout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\r\nout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\r\nout->qs_pquota.qfs_ino = mp->m_sb.sb_pquotino;\r\nif (q) {\r\nuip = q->qi_uquotaip;\r\ngip = q->qi_gquotaip;\r\npip = q->qi_pquotaip;\r\n}\r\nif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\r\nif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\r\n0, 0, &uip) == 0)\r\ntempuqip = true;\r\n}\r\nif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\r\nif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\r\n0, 0, &gip) == 0)\r\ntempgqip = true;\r\n}\r\nif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\r\nif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\r\n0, 0, &pip) == 0)\r\ntemppqip = true;\r\n}\r\nif (uip) {\r\nout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\r\nout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\r\nif (tempuqip)\r\nIRELE(uip);\r\n}\r\nif (gip) {\r\nout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\r\nout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\r\nif (tempgqip)\r\nIRELE(gip);\r\n}\r\nif (pip) {\r\nout->qs_pquota.qfs_nblks = pip->i_d.di_nblocks;\r\nout->qs_pquota.qfs_nextents = pip->i_d.di_nextents;\r\nif (temppqip)\r\nIRELE(pip);\r\n}\r\nif (q) {\r\nout->qs_incoredqs = q->qi_dquots;\r\nout->qs_btimelimit = q->qi_btimelimit;\r\nout->qs_itimelimit = q->qi_itimelimit;\r\nout->qs_rtbtimelimit = q->qi_rtbtimelimit;\r\nout->qs_bwarnlimit = q->qi_bwarnlimit;\r\nout->qs_iwarnlimit = q->qi_iwarnlimit;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_qm_scall_setqlim(\r\nstruct xfs_mount *mp,\r\nxfs_dqid_t id,\r\nuint type,\r\nfs_disk_quota_t *newlim)\r\n{\r\nstruct xfs_quotainfo *q = mp->m_quotainfo;\r\nstruct xfs_disk_dquot *ddq;\r\nstruct xfs_dquot *dqp;\r\nstruct xfs_trans *tp;\r\nint error;\r\nxfs_qcnt_t hard, soft;\r\nif (newlim->d_fieldmask & ~XFS_DQ_MASK)\r\nreturn -EINVAL;\r\nif ((newlim->d_fieldmask & XFS_DQ_MASK) == 0)\r\nreturn 0;\r\nmutex_lock(&q->qi_quotaofflock);\r\nerror = xfs_qm_dqget(mp, NULL, id, type, XFS_QMOPT_DQALLOC, &dqp);\r\nif (error) {\r\nASSERT(error != -ENOENT);\r\ngoto out_unlock;\r\n}\r\nxfs_dqunlock(dqp);\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_QM_SETQLIM);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_setqlim, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\ngoto out_rele;\r\n}\r\nxfs_dqlock(dqp);\r\nxfs_trans_dqjoin(tp, dqp);\r\nddq = &dqp->q_core;\r\nhard = (newlim->d_fieldmask & FS_DQ_BHARD) ?\r\n(xfs_qcnt_t) XFS_BB_TO_FSB(mp, newlim->d_blk_hardlimit) :\r\nbe64_to_cpu(ddq->d_blk_hardlimit);\r\nsoft = (newlim->d_fieldmask & FS_DQ_BSOFT) ?\r\n(xfs_qcnt_t) XFS_BB_TO_FSB(mp, newlim->d_blk_softlimit) :\r\nbe64_to_cpu(ddq->d_blk_softlimit);\r\nif (hard == 0 || hard >= soft) {\r\nddq->d_blk_hardlimit = cpu_to_be64(hard);\r\nddq->d_blk_softlimit = cpu_to_be64(soft);\r\nxfs_dquot_set_prealloc_limits(dqp);\r\nif (id == 0) {\r\nq->qi_bhardlimit = hard;\r\nq->qi_bsoftlimit = soft;\r\n}\r\n} else {\r\nxfs_debug(mp, "blkhard %Ld < blksoft %Ld", hard, soft);\r\n}\r\nhard = (newlim->d_fieldmask & FS_DQ_RTBHARD) ?\r\n(xfs_qcnt_t) XFS_BB_TO_FSB(mp, newlim->d_rtb_hardlimit) :\r\nbe64_to_cpu(ddq->d_rtb_hardlimit);\r\nsoft = (newlim->d_fieldmask & FS_DQ_RTBSOFT) ?\r\n(xfs_qcnt_t) XFS_BB_TO_FSB(mp, newlim->d_rtb_softlimit) :\r\nbe64_to_cpu(ddq->d_rtb_softlimit);\r\nif (hard == 0 || hard >= soft) {\r\nddq->d_rtb_hardlimit = cpu_to_be64(hard);\r\nddq->d_rtb_softlimit = cpu_to_be64(soft);\r\nif (id == 0) {\r\nq->qi_rtbhardlimit = hard;\r\nq->qi_rtbsoftlimit = soft;\r\n}\r\n} else {\r\nxfs_debug(mp, "rtbhard %Ld < rtbsoft %Ld", hard, soft);\r\n}\r\nhard = (newlim->d_fieldmask & FS_DQ_IHARD) ?\r\n(xfs_qcnt_t) newlim->d_ino_hardlimit :\r\nbe64_to_cpu(ddq->d_ino_hardlimit);\r\nsoft = (newlim->d_fieldmask & FS_DQ_ISOFT) ?\r\n(xfs_qcnt_t) newlim->d_ino_softlimit :\r\nbe64_to_cpu(ddq->d_ino_softlimit);\r\nif (hard == 0 || hard >= soft) {\r\nddq->d_ino_hardlimit = cpu_to_be64(hard);\r\nddq->d_ino_softlimit = cpu_to_be64(soft);\r\nif (id == 0) {\r\nq->qi_ihardlimit = hard;\r\nq->qi_isoftlimit = soft;\r\n}\r\n} else {\r\nxfs_debug(mp, "ihard %Ld < isoft %Ld", hard, soft);\r\n}\r\nif (newlim->d_fieldmask & FS_DQ_BWARNS)\r\nddq->d_bwarns = cpu_to_be16(newlim->d_bwarns);\r\nif (newlim->d_fieldmask & FS_DQ_IWARNS)\r\nddq->d_iwarns = cpu_to_be16(newlim->d_iwarns);\r\nif (newlim->d_fieldmask & FS_DQ_RTBWARNS)\r\nddq->d_rtbwarns = cpu_to_be16(newlim->d_rtbwarns);\r\nif (id == 0) {\r\nif (newlim->d_fieldmask & FS_DQ_BTIMER) {\r\nq->qi_btimelimit = newlim->d_btimer;\r\nddq->d_btimer = cpu_to_be32(newlim->d_btimer);\r\n}\r\nif (newlim->d_fieldmask & FS_DQ_ITIMER) {\r\nq->qi_itimelimit = newlim->d_itimer;\r\nddq->d_itimer = cpu_to_be32(newlim->d_itimer);\r\n}\r\nif (newlim->d_fieldmask & FS_DQ_RTBTIMER) {\r\nq->qi_rtbtimelimit = newlim->d_rtbtimer;\r\nddq->d_rtbtimer = cpu_to_be32(newlim->d_rtbtimer);\r\n}\r\nif (newlim->d_fieldmask & FS_DQ_BWARNS)\r\nq->qi_bwarnlimit = newlim->d_bwarns;\r\nif (newlim->d_fieldmask & FS_DQ_IWARNS)\r\nq->qi_iwarnlimit = newlim->d_iwarns;\r\nif (newlim->d_fieldmask & FS_DQ_RTBWARNS)\r\nq->qi_rtbwarnlimit = newlim->d_rtbwarns;\r\n} else {\r\nxfs_qm_adjust_dqtimers(mp, ddq);\r\n}\r\ndqp->dq_flags |= XFS_DQ_DIRTY;\r\nxfs_trans_log_dquot(tp, dqp);\r\nerror = xfs_trans_commit(tp, 0);\r\nout_rele:\r\nxfs_qm_dqrele(dqp);\r\nout_unlock:\r\nmutex_unlock(&q->qi_quotaofflock);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_log_quotaoff_end(\r\nxfs_mount_t *mp,\r\nxfs_qoff_logitem_t *startqoff,\r\nuint flags)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nxfs_qoff_logitem_t *qoffi;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF_END);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_equotaoff, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nqoffi = xfs_trans_get_qoff_item(tp, startqoff,\r\nflags & XFS_ALL_QUOTA_ACCT);\r\nxfs_trans_log_quotaoff_item(tp, qoffi);\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp, 0);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_log_quotaoff(\r\nxfs_mount_t *mp,\r\nxfs_qoff_logitem_t **qoffstartp,\r\nuint flags)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nxfs_qoff_logitem_t *qoffi=NULL;\r\nuint oldsbqflag=0;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_QM_QUOTAOFF);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_quotaoff, 0, 0);\r\nif (error)\r\ngoto error0;\r\nqoffi = xfs_trans_get_qoff_item(tp, NULL, flags & XFS_ALL_QUOTA_ACCT);\r\nxfs_trans_log_quotaoff_item(tp, qoffi);\r\nspin_lock(&mp->m_sb_lock);\r\noldsbqflag = mp->m_sb.sb_qflags;\r\nmp->m_sb.sb_qflags = (mp->m_qflags & ~(flags)) & XFS_MOUNT_QUOTA_ALL;\r\nspin_unlock(&mp->m_sb_lock);\r\nxfs_mod_sb(tp, XFS_SB_QFLAGS);\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp, 0);\r\nerror0:\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nspin_lock(&mp->m_sb_lock);\r\nmp->m_sb.sb_qflags = oldsbqflag;\r\nspin_unlock(&mp->m_sb_lock);\r\n}\r\n*qoffstartp = qoffi;\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_scall_getquota(\r\nstruct xfs_mount *mp,\r\nxfs_dqid_t id,\r\nuint type,\r\nstruct fs_disk_quota *dst)\r\n{\r\nstruct xfs_dquot *dqp;\r\nint error;\r\nerror = xfs_qm_dqget(mp, NULL, id, type, 0, &dqp);\r\nif (error)\r\nreturn error;\r\nif (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {\r\nerror = -ENOENT;\r\ngoto out_put;\r\n}\r\nmemset(dst, 0, sizeof(*dst));\r\ndst->d_version = FS_DQUOT_VERSION;\r\ndst->d_flags = xfs_qm_export_qtype_flags(dqp->q_core.d_flags);\r\ndst->d_id = be32_to_cpu(dqp->q_core.d_id);\r\ndst->d_blk_hardlimit =\r\nXFS_FSB_TO_BB(mp, be64_to_cpu(dqp->q_core.d_blk_hardlimit));\r\ndst->d_blk_softlimit =\r\nXFS_FSB_TO_BB(mp, be64_to_cpu(dqp->q_core.d_blk_softlimit));\r\ndst->d_ino_hardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\r\ndst->d_ino_softlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\r\ndst->d_bcount = XFS_FSB_TO_BB(mp, dqp->q_res_bcount);\r\ndst->d_icount = dqp->q_res_icount;\r\ndst->d_btimer = be32_to_cpu(dqp->q_core.d_btimer);\r\ndst->d_itimer = be32_to_cpu(dqp->q_core.d_itimer);\r\ndst->d_iwarns = be16_to_cpu(dqp->q_core.d_iwarns);\r\ndst->d_bwarns = be16_to_cpu(dqp->q_core.d_bwarns);\r\ndst->d_rtb_hardlimit =\r\nXFS_FSB_TO_BB(mp, be64_to_cpu(dqp->q_core.d_rtb_hardlimit));\r\ndst->d_rtb_softlimit =\r\nXFS_FSB_TO_BB(mp, be64_to_cpu(dqp->q_core.d_rtb_softlimit));\r\ndst->d_rtbcount = XFS_FSB_TO_BB(mp, dqp->q_res_rtbcount);\r\ndst->d_rtbtimer = be32_to_cpu(dqp->q_core.d_rtbtimer);\r\ndst->d_rtbwarns = be16_to_cpu(dqp->q_core.d_rtbwarns);\r\nif ((!XFS_IS_UQUOTA_ENFORCED(mp) &&\r\ndqp->q_core.d_flags == XFS_DQ_USER) ||\r\n(!XFS_IS_GQUOTA_ENFORCED(mp) &&\r\ndqp->q_core.d_flags == XFS_DQ_GROUP) ||\r\n(!XFS_IS_PQUOTA_ENFORCED(mp) &&\r\ndqp->q_core.d_flags == XFS_DQ_PROJ)) {\r\ndst->d_btimer = 0;\r\ndst->d_itimer = 0;\r\ndst->d_rtbtimer = 0;\r\n}\r\n#ifdef DEBUG\r\nif (((XFS_IS_UQUOTA_ENFORCED(mp) && dst->d_flags == FS_USER_QUOTA) ||\r\n(XFS_IS_GQUOTA_ENFORCED(mp) && dst->d_flags == FS_GROUP_QUOTA) ||\r\n(XFS_IS_PQUOTA_ENFORCED(mp) && dst->d_flags == FS_PROJ_QUOTA)) &&\r\ndst->d_id != 0) {\r\nif ((dst->d_bcount > dst->d_blk_softlimit) &&\r\n(dst->d_blk_softlimit > 0)) {\r\nASSERT(dst->d_btimer != 0);\r\n}\r\nif ((dst->d_icount > dst->d_ino_softlimit) &&\r\n(dst->d_ino_softlimit > 0)) {\r\nASSERT(dst->d_itimer != 0);\r\n}\r\n}\r\n#endif\r\nout_put:\r\nxfs_qm_dqput(dqp);\r\nreturn error;\r\n}\r\nSTATIC uint\r\nxfs_qm_export_qtype_flags(\r\nuint flags)\r\n{\r\nASSERT((flags & (FS_PROJ_QUOTA | FS_USER_QUOTA)) !=\r\n(FS_PROJ_QUOTA | FS_USER_QUOTA));\r\nASSERT((flags & (FS_PROJ_QUOTA | FS_GROUP_QUOTA)) !=\r\n(FS_PROJ_QUOTA | FS_GROUP_QUOTA));\r\nASSERT((flags & (FS_USER_QUOTA | FS_GROUP_QUOTA)) !=\r\n(FS_USER_QUOTA | FS_GROUP_QUOTA));\r\nASSERT((flags & (FS_PROJ_QUOTA|FS_USER_QUOTA|FS_GROUP_QUOTA)) != 0);\r\nreturn (flags & XFS_DQ_USER) ?\r\nFS_USER_QUOTA : (flags & XFS_DQ_PROJ) ?\r\nFS_PROJ_QUOTA : FS_GROUP_QUOTA;\r\n}\r\nSTATIC uint\r\nxfs_qm_export_flags(\r\nuint flags)\r\n{\r\nuint uflags;\r\nuflags = 0;\r\nif (flags & XFS_UQUOTA_ACCT)\r\nuflags |= FS_QUOTA_UDQ_ACCT;\r\nif (flags & XFS_GQUOTA_ACCT)\r\nuflags |= FS_QUOTA_GDQ_ACCT;\r\nif (flags & XFS_PQUOTA_ACCT)\r\nuflags |= FS_QUOTA_PDQ_ACCT;\r\nif (flags & XFS_UQUOTA_ENFD)\r\nuflags |= FS_QUOTA_UDQ_ENFD;\r\nif (flags & XFS_GQUOTA_ENFD)\r\nuflags |= FS_QUOTA_GDQ_ENFD;\r\nif (flags & XFS_PQUOTA_ENFD)\r\nuflags |= FS_QUOTA_PDQ_ENFD;\r\nreturn uflags;\r\n}\r\nSTATIC int\r\nxfs_dqrele_inode(\r\nstruct xfs_inode *ip,\r\nint flags,\r\nvoid *args)\r\n{\r\nif (ip == ip->i_mount->m_quotainfo->qi_uquotaip ||\r\nip == ip->i_mount->m_quotainfo->qi_gquotaip ||\r\nip == ip->i_mount->m_quotainfo->qi_pquotaip) {\r\nASSERT(ip->i_udquot == NULL);\r\nASSERT(ip->i_gdquot == NULL);\r\nASSERT(ip->i_pdquot == NULL);\r\nreturn 0;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nif ((flags & XFS_UQUOTA_ACCT) && ip->i_udquot) {\r\nxfs_qm_dqrele(ip->i_udquot);\r\nip->i_udquot = NULL;\r\n}\r\nif ((flags & XFS_GQUOTA_ACCT) && ip->i_gdquot) {\r\nxfs_qm_dqrele(ip->i_gdquot);\r\nip->i_gdquot = NULL;\r\n}\r\nif ((flags & XFS_PQUOTA_ACCT) && ip->i_pdquot) {\r\nxfs_qm_dqrele(ip->i_pdquot);\r\nip->i_pdquot = NULL;\r\n}\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_qm_dqrele_all_inodes(\r\nstruct xfs_mount *mp,\r\nuint flags)\r\n{\r\nASSERT(mp->m_quotainfo);\r\nxfs_inode_ag_iterator(mp, xfs_dqrele_inode, flags, NULL);\r\n}
