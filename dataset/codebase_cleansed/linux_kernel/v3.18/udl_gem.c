struct udl_gem_object *udl_gem_alloc_object(struct drm_device *dev,\r\nsize_t size)\r\n{\r\nstruct udl_gem_object *obj;\r\nobj = kzalloc(sizeof(*obj), GFP_KERNEL);\r\nif (obj == NULL)\r\nreturn NULL;\r\nif (drm_gem_object_init(dev, &obj->base, size) != 0) {\r\nkfree(obj);\r\nreturn NULL;\r\n}\r\nreturn obj;\r\n}\r\nstatic int\r\nudl_gem_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint64_t size,\r\nuint32_t *handle_p)\r\n{\r\nstruct udl_gem_object *obj;\r\nint ret;\r\nu32 handle;\r\nsize = roundup(size, PAGE_SIZE);\r\nobj = udl_gem_alloc_object(dev, size);\r\nif (obj == NULL)\r\nreturn -ENOMEM;\r\nret = drm_gem_handle_create(file, &obj->base, &handle);\r\nif (ret) {\r\ndrm_gem_object_release(&obj->base);\r\nkfree(obj);\r\nreturn ret;\r\n}\r\ndrm_gem_object_unreference(&obj->base);\r\n*handle_p = handle;\r\nreturn 0;\r\n}\r\nint udl_dumb_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nargs->pitch = args->width * DIV_ROUND_UP(args->bpp, 8);\r\nargs->size = args->pitch * args->height;\r\nreturn udl_gem_create(file, dev,\r\nargs->size, &args->handle);\r\n}\r\nint udl_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret)\r\nreturn ret;\r\nvma->vm_flags &= ~VM_PFNMAP;\r\nvma->vm_flags |= VM_MIXEDMAP;\r\nreturn ret;\r\n}\r\nint udl_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct udl_gem_object *obj = to_udl_bo(vma->vm_private_data);\r\nstruct page *page;\r\nunsigned int page_offset;\r\nint ret = 0;\r\npage_offset = ((unsigned long)vmf->virtual_address - vma->vm_start) >>\r\nPAGE_SHIFT;\r\nif (!obj->pages)\r\nreturn VM_FAULT_SIGBUS;\r\npage = obj->pages[page_offset];\r\nret = vm_insert_page(vma, (unsigned long)vmf->virtual_address, page);\r\nswitch (ret) {\r\ncase -EAGAIN:\r\ncase 0:\r\ncase -ERESTARTSYS:\r\nreturn VM_FAULT_NOPAGE;\r\ncase -ENOMEM:\r\nreturn VM_FAULT_OOM;\r\ndefault:\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\n}\r\nstatic int udl_gem_get_pages(struct udl_gem_object *obj)\r\n{\r\nstruct page **pages;\r\nif (obj->pages)\r\nreturn 0;\r\npages = drm_gem_get_pages(&obj->base);\r\nif (IS_ERR(pages))\r\nreturn PTR_ERR(pages);\r\nobj->pages = pages;\r\nreturn 0;\r\n}\r\nstatic void udl_gem_put_pages(struct udl_gem_object *obj)\r\n{\r\nif (obj->base.import_attach) {\r\ndrm_free_large(obj->pages);\r\nobj->pages = NULL;\r\nreturn;\r\n}\r\ndrm_gem_put_pages(&obj->base, obj->pages, false, false);\r\nobj->pages = NULL;\r\n}\r\nint udl_gem_vmap(struct udl_gem_object *obj)\r\n{\r\nint page_count = obj->base.size / PAGE_SIZE;\r\nint ret;\r\nif (obj->base.import_attach) {\r\nobj->vmapping = dma_buf_vmap(obj->base.import_attach->dmabuf);\r\nif (!obj->vmapping)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nret = udl_gem_get_pages(obj);\r\nif (ret)\r\nreturn ret;\r\nobj->vmapping = vmap(obj->pages, page_count, 0, PAGE_KERNEL);\r\nif (!obj->vmapping)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid udl_gem_vunmap(struct udl_gem_object *obj)\r\n{\r\nif (obj->base.import_attach) {\r\ndma_buf_vunmap(obj->base.import_attach->dmabuf, obj->vmapping);\r\nreturn;\r\n}\r\nif (obj->vmapping)\r\nvunmap(obj->vmapping);\r\nudl_gem_put_pages(obj);\r\n}\r\nvoid udl_gem_free_object(struct drm_gem_object *gem_obj)\r\n{\r\nstruct udl_gem_object *obj = to_udl_bo(gem_obj);\r\nif (obj->vmapping)\r\nudl_gem_vunmap(obj);\r\nif (gem_obj->import_attach) {\r\ndrm_prime_gem_destroy(gem_obj, obj->sg);\r\nput_device(gem_obj->dev->dev);\r\n}\r\nif (obj->pages)\r\nudl_gem_put_pages(obj);\r\ndrm_gem_free_mmap_offset(gem_obj);\r\n}\r\nint udl_gem_mmap(struct drm_file *file, struct drm_device *dev,\r\nuint32_t handle, uint64_t *offset)\r\n{\r\nstruct udl_gem_object *gobj;\r\nstruct drm_gem_object *obj;\r\nint ret = 0;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (obj == NULL) {\r\nret = -ENOENT;\r\ngoto unlock;\r\n}\r\ngobj = to_udl_bo(obj);\r\nret = udl_gem_get_pages(gobj);\r\nif (ret)\r\ngoto out;\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret)\r\ngoto out;\r\n*offset = drm_vma_node_offset_addr(&gobj->base.vma_node);\r\nout:\r\ndrm_gem_object_unreference(&gobj->base);\r\nunlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nstatic int udl_prime_create(struct drm_device *dev,\r\nsize_t size,\r\nstruct sg_table *sg,\r\nstruct udl_gem_object **obj_p)\r\n{\r\nstruct udl_gem_object *obj;\r\nint npages;\r\nnpages = size / PAGE_SIZE;\r\n*obj_p = NULL;\r\nobj = udl_gem_alloc_object(dev, npages * PAGE_SIZE);\r\nif (!obj)\r\nreturn -ENOMEM;\r\nobj->sg = sg;\r\nobj->pages = drm_malloc_ab(npages, sizeof(struct page *));\r\nif (obj->pages == NULL) {\r\nDRM_ERROR("obj pages is NULL %d\n", npages);\r\nreturn -ENOMEM;\r\n}\r\ndrm_prime_sg_to_page_addr_arrays(sg, obj->pages, NULL, npages);\r\n*obj_p = obj;\r\nreturn 0;\r\n}\r\nstruct drm_gem_object *udl_gem_prime_import(struct drm_device *dev,\r\nstruct dma_buf *dma_buf)\r\n{\r\nstruct dma_buf_attachment *attach;\r\nstruct sg_table *sg;\r\nstruct udl_gem_object *uobj;\r\nint ret;\r\nget_device(dev->dev);\r\nattach = dma_buf_attach(dma_buf, dev->dev);\r\nif (IS_ERR(attach)) {\r\nput_device(dev->dev);\r\nreturn ERR_CAST(attach);\r\n}\r\nget_dma_buf(dma_buf);\r\nsg = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);\r\nif (IS_ERR(sg)) {\r\nret = PTR_ERR(sg);\r\ngoto fail_detach;\r\n}\r\nret = udl_prime_create(dev, dma_buf->size, sg, &uobj);\r\nif (ret) {\r\ngoto fail_unmap;\r\n}\r\nuobj->base.import_attach = attach;\r\nreturn &uobj->base;\r\nfail_unmap:\r\ndma_buf_unmap_attachment(attach, sg, DMA_BIDIRECTIONAL);\r\nfail_detach:\r\ndma_buf_detach(dma_buf, attach);\r\ndma_buf_put(dma_buf);\r\nput_device(dev->dev);\r\nreturn ERR_PTR(ret);\r\n}
