static inline struct plain_sec *sec2plsec(struct ptlrpc_sec *sec)\r\n{\r\nreturn container_of(sec, struct plain_sec, pls_base);\r\n}\r\nstatic int plain_unpack_bsd(struct lustre_msg *msg, int swabbed)\r\n{\r\nstruct ptlrpc_bulk_sec_desc *bsd;\r\nif (bulk_sec_desc_unpack(msg, PLAIN_PACK_BULK_OFF, swabbed))\r\nreturn -EPROTO;\r\nbsd = lustre_msg_buf(msg, PLAIN_PACK_BULK_OFF, PLAIN_BSD_SIZE);\r\nif (bsd == NULL) {\r\nCERROR("bulk sec desc has short size %d\n",\r\nlustre_msg_buflen(msg, PLAIN_PACK_BULK_OFF));\r\nreturn -EPROTO;\r\n}\r\nif (bsd->bsd_svc != SPTLRPC_BULK_SVC_NULL &&\r\nbsd->bsd_svc != SPTLRPC_BULK_SVC_INTG) {\r\nCERROR("invalid bulk svc %u\n", bsd->bsd_svc);\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int plain_generate_bulk_csum(struct ptlrpc_bulk_desc *desc,\r\n__u8 hash_alg,\r\nstruct plain_bulk_token *token)\r\n{\r\nif (hash_alg == BULK_HASH_ALG_NULL)\r\nreturn 0;\r\nmemset(token->pbt_hash, 0, sizeof(token->pbt_hash));\r\nreturn sptlrpc_get_bulk_checksum(desc, hash_alg, token->pbt_hash,\r\nsizeof(token->pbt_hash));\r\n}\r\nstatic int plain_verify_bulk_csum(struct ptlrpc_bulk_desc *desc,\r\n__u8 hash_alg,\r\nstruct plain_bulk_token *tokenr)\r\n{\r\nstruct plain_bulk_token tokenv;\r\nint rc;\r\nif (hash_alg == BULK_HASH_ALG_NULL)\r\nreturn 0;\r\nmemset(&tokenv.pbt_hash, 0, sizeof(tokenv.pbt_hash));\r\nrc = sptlrpc_get_bulk_checksum(desc, hash_alg, tokenv.pbt_hash,\r\nsizeof(tokenv.pbt_hash));\r\nif (rc)\r\nreturn rc;\r\nif (memcmp(tokenr->pbt_hash, tokenv.pbt_hash, sizeof(tokenr->pbt_hash)))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic void corrupt_bulk_data(struct ptlrpc_bulk_desc *desc)\r\n{\r\nchar *ptr;\r\nunsigned int off, i;\r\nfor (i = 0; i < desc->bd_iov_count; i++) {\r\nif (desc->bd_iov[i].kiov_len == 0)\r\ncontinue;\r\nptr = kmap(desc->bd_iov[i].kiov_page);\r\noff = desc->bd_iov[i].kiov_offset & ~CFS_PAGE_MASK;\r\nptr[off] ^= 0x1;\r\nkunmap(desc->bd_iov[i].kiov_page);\r\nreturn;\r\n}\r\n}\r\nstatic\r\nint plain_ctx_refresh(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nstatic\r\nint plain_ctx_validate(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nreturn 0;\r\n}\r\nstatic\r\nint plain_ctx_sign(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)\r\n{\r\nstruct lustre_msg *msg = req->rq_reqbuf;\r\nstruct plain_header *phdr;\r\nmsg->lm_secflvr = req->rq_flvr.sf_rpc;\r\nphdr = lustre_msg_buf(msg, PLAIN_PACK_HDR_OFF, 0);\r\nphdr->ph_ver = 0;\r\nphdr->ph_flags = 0;\r\nphdr->ph_sp = ctx->cc_sec->ps_part;\r\nphdr->ph_bulk_hash_alg = req->rq_flvr.u_bulk.hash.hash_alg;\r\nif (req->rq_pack_udesc)\r\nphdr->ph_flags |= PLAIN_FL_USER;\r\nif (req->rq_pack_bulk)\r\nphdr->ph_flags |= PLAIN_FL_BULK;\r\nreq->rq_reqdata_len = lustre_msg_size_v2(msg->lm_bufcount,\r\nmsg->lm_buflens);\r\nreturn 0;\r\n}\r\nstatic\r\nint plain_ctx_verify(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)\r\n{\r\nstruct lustre_msg *msg = req->rq_repdata;\r\nstruct plain_header *phdr;\r\n__u32 cksum;\r\nint swabbed;\r\nif (msg->lm_bufcount != PLAIN_PACK_SEGMENTS) {\r\nCERROR("unexpected reply buf count %u\n", msg->lm_bufcount);\r\nreturn -EPROTO;\r\n}\r\nswabbed = ptlrpc_rep_need_swab(req);\r\nphdr = lustre_msg_buf(msg, PLAIN_PACK_HDR_OFF, sizeof(*phdr));\r\nif (phdr == NULL) {\r\nCERROR("missing plain header\n");\r\nreturn -EPROTO;\r\n}\r\nif (phdr->ph_ver != 0) {\r\nCERROR("Invalid header version\n");\r\nreturn -EPROTO;\r\n}\r\nif (phdr->ph_flags & PLAIN_FL_USER) {\r\nCERROR("Unexpected udesc flag in reply\n");\r\nreturn -EPROTO;\r\n}\r\nif (phdr->ph_bulk_hash_alg != req->rq_flvr.u_bulk.hash.hash_alg) {\r\nCERROR("reply bulk flavor %u != %u\n", phdr->ph_bulk_hash_alg,\r\nreq->rq_flvr.u_bulk.hash.hash_alg);\r\nreturn -EPROTO;\r\n}\r\nif (unlikely(req->rq_early)) {\r\nunsigned int hsize = 4;\r\ncfs_crypto_hash_digest(CFS_HASH_ALG_CRC32,\r\nlustre_msg_buf(msg, PLAIN_PACK_MSG_OFF, 0),\r\nlustre_msg_buflen(msg, PLAIN_PACK_MSG_OFF),\r\nNULL, 0, (unsigned char *)&cksum, &hsize);\r\nif (cksum != msg->lm_cksum) {\r\nCDEBUG(D_SEC,\r\n"early reply checksum mismatch: %08x != %08x\n",\r\ncpu_to_le32(cksum), msg->lm_cksum);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (!req->rq_early &&\r\n!equi(req->rq_pack_bulk == 1,\r\nphdr->ph_flags & PLAIN_FL_BULK)) {\r\nCERROR("%s bulk checksum in reply\n",\r\nreq->rq_pack_bulk ? "Missing" : "Unexpected");\r\nreturn -EPROTO;\r\n}\r\nif (phdr->ph_flags & PLAIN_FL_BULK) {\r\nif (plain_unpack_bsd(msg, swabbed))\r\nreturn -EPROTO;\r\n}\r\n}\r\nreq->rq_repmsg = lustre_msg_buf(msg, PLAIN_PACK_MSG_OFF, 0);\r\nreq->rq_replen = lustre_msg_buflen(msg, PLAIN_PACK_MSG_OFF);\r\nreturn 0;\r\n}\r\nstatic\r\nint plain_cli_wrap_bulk(struct ptlrpc_cli_ctx *ctx,\r\nstruct ptlrpc_request *req,\r\nstruct ptlrpc_bulk_desc *desc)\r\n{\r\nstruct ptlrpc_bulk_sec_desc *bsd;\r\nstruct plain_bulk_token *token;\r\nint rc;\r\nLASSERT(req->rq_pack_bulk);\r\nLASSERT(req->rq_reqbuf->lm_bufcount == PLAIN_PACK_SEGMENTS);\r\nbsd = lustre_msg_buf(req->rq_reqbuf, PLAIN_PACK_BULK_OFF, 0);\r\ntoken = (struct plain_bulk_token *) bsd->bsd_data;\r\nbsd->bsd_version = 0;\r\nbsd->bsd_flags = 0;\r\nbsd->bsd_type = SPTLRPC_BULK_DEFAULT;\r\nbsd->bsd_svc = SPTLRPC_FLVR_BULK_SVC(req->rq_flvr.sf_rpc);\r\nif (bsd->bsd_svc == SPTLRPC_BULK_SVC_NULL)\r\nreturn 0;\r\nif (req->rq_bulk_read)\r\nreturn 0;\r\nrc = plain_generate_bulk_csum(desc, req->rq_flvr.u_bulk.hash.hash_alg,\r\ntoken);\r\nif (rc) {\r\nCERROR("bulk write: failed to compute checksum: %d\n", rc);\r\n} else {\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OSC_CHECKSUM_SEND) &&\r\nreq->rq_flvr.u_bulk.hash.hash_alg != BULK_HASH_ALG_NULL)\r\ntoken->pbt_hash[0] ^= 0x1;\r\n}\r\nreturn rc;\r\n}\r\nstatic\r\nint plain_cli_unwrap_bulk(struct ptlrpc_cli_ctx *ctx,\r\nstruct ptlrpc_request *req,\r\nstruct ptlrpc_bulk_desc *desc)\r\n{\r\nstruct ptlrpc_bulk_sec_desc *bsdv;\r\nstruct plain_bulk_token *tokenv;\r\nint rc;\r\nint i, nob;\r\nLASSERT(req->rq_pack_bulk);\r\nLASSERT(req->rq_reqbuf->lm_bufcount == PLAIN_PACK_SEGMENTS);\r\nLASSERT(req->rq_repdata->lm_bufcount == PLAIN_PACK_SEGMENTS);\r\nbsdv = lustre_msg_buf(req->rq_repdata, PLAIN_PACK_BULK_OFF, 0);\r\ntokenv = (struct plain_bulk_token *) bsdv->bsd_data;\r\nif (req->rq_bulk_write) {\r\nif (bsdv->bsd_flags & BSD_FL_ERR)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nfor (i = 0, nob = 0; i < desc->bd_iov_count; i++) {\r\nif (desc->bd_iov[i].kiov_len + nob > desc->bd_nob_transferred) {\r\ndesc->bd_iov[i].kiov_len =\r\ndesc->bd_nob_transferred - nob;\r\n}\r\nnob += desc->bd_iov[i].kiov_len;\r\n}\r\nrc = plain_verify_bulk_csum(desc, req->rq_flvr.u_bulk.hash.hash_alg,\r\ntokenv);\r\nif (rc)\r\nCERROR("bulk read: client verify failed: %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic\r\nstruct ptlrpc_cli_ctx *plain_sec_install_ctx(struct plain_sec *plsec)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx, *ctx_new;\r\nOBD_ALLOC_PTR(ctx_new);\r\nwrite_lock(&plsec->pls_lock);\r\nctx = plsec->pls_ctx;\r\nif (ctx) {\r\natomic_inc(&ctx->cc_refcount);\r\nif (ctx_new)\r\nOBD_FREE_PTR(ctx_new);\r\n} else if (ctx_new) {\r\nctx = ctx_new;\r\natomic_set(&ctx->cc_refcount, 1);\r\nctx->cc_sec = &plsec->pls_base;\r\nctx->cc_ops = &plain_ctx_ops;\r\nctx->cc_expire = 0;\r\nctx->cc_flags = PTLRPC_CTX_CACHED | PTLRPC_CTX_UPTODATE;\r\nctx->cc_vcred.vc_uid = 0;\r\nspin_lock_init(&ctx->cc_lock);\r\nINIT_LIST_HEAD(&ctx->cc_req_list);\r\nINIT_LIST_HEAD(&ctx->cc_gc_chain);\r\nplsec->pls_ctx = ctx;\r\natomic_inc(&plsec->pls_base.ps_nctx);\r\natomic_inc(&plsec->pls_base.ps_refcount);\r\natomic_inc(&ctx->cc_refcount);\r\n}\r\nwrite_unlock(&plsec->pls_lock);\r\nreturn ctx;\r\n}\r\nstatic\r\nvoid plain_destroy_sec(struct ptlrpc_sec *sec)\r\n{\r\nstruct plain_sec *plsec = sec2plsec(sec);\r\nLASSERT(sec->ps_policy == &plain_policy);\r\nLASSERT(sec->ps_import);\r\nLASSERT(atomic_read(&sec->ps_refcount) == 0);\r\nLASSERT(atomic_read(&sec->ps_nctx) == 0);\r\nLASSERT(plsec->pls_ctx == NULL);\r\nclass_import_put(sec->ps_import);\r\nOBD_FREE_PTR(plsec);\r\n}\r\nstatic\r\nvoid plain_kill_sec(struct ptlrpc_sec *sec)\r\n{\r\nsec->ps_dying = 1;\r\n}\r\nstatic\r\nstruct ptlrpc_sec *plain_create_sec(struct obd_import *imp,\r\nstruct ptlrpc_svc_ctx *svc_ctx,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nstruct plain_sec *plsec;\r\nstruct ptlrpc_sec *sec;\r\nstruct ptlrpc_cli_ctx *ctx;\r\nLASSERT(SPTLRPC_FLVR_POLICY(sf->sf_rpc) == SPTLRPC_POLICY_PLAIN);\r\nOBD_ALLOC_PTR(plsec);\r\nif (plsec == NULL)\r\nreturn NULL;\r\nrwlock_init(&plsec->pls_lock);\r\nplsec->pls_ctx = NULL;\r\nsec = &plsec->pls_base;\r\nsec->ps_policy = &plain_policy;\r\natomic_set(&sec->ps_refcount, 0);\r\natomic_set(&sec->ps_nctx, 0);\r\nsec->ps_id = sptlrpc_get_next_secid();\r\nsec->ps_import = class_import_get(imp);\r\nsec->ps_flvr = *sf;\r\nspin_lock_init(&sec->ps_lock);\r\nINIT_LIST_HEAD(&sec->ps_gc_list);\r\nsec->ps_gc_interval = 0;\r\nsec->ps_gc_next = 0;\r\nif (svc_ctx) {\r\nctx = plain_sec_install_ctx(plsec);\r\nif (ctx == NULL) {\r\nplain_destroy_sec(sec);\r\nreturn NULL;\r\n}\r\nsptlrpc_cli_ctx_put(ctx, 1);\r\n}\r\nreturn sec;\r\n}\r\nstatic\r\nstruct ptlrpc_cli_ctx *plain_lookup_ctx(struct ptlrpc_sec *sec,\r\nstruct vfs_cred *vcred,\r\nint create, int remove_dead)\r\n{\r\nstruct plain_sec *plsec = sec2plsec(sec);\r\nstruct ptlrpc_cli_ctx *ctx;\r\nread_lock(&plsec->pls_lock);\r\nctx = plsec->pls_ctx;\r\nif (ctx)\r\natomic_inc(&ctx->cc_refcount);\r\nread_unlock(&plsec->pls_lock);\r\nif (unlikely(ctx == NULL))\r\nctx = plain_sec_install_ctx(plsec);\r\nreturn ctx;\r\n}\r\nstatic\r\nvoid plain_release_ctx(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_cli_ctx *ctx, int sync)\r\n{\r\nLASSERT(atomic_read(&sec->ps_refcount) > 0);\r\nLASSERT(atomic_read(&sec->ps_nctx) > 0);\r\nLASSERT(atomic_read(&ctx->cc_refcount) == 0);\r\nLASSERT(ctx->cc_sec == sec);\r\nOBD_FREE_PTR(ctx);\r\natomic_dec(&sec->ps_nctx);\r\nsptlrpc_sec_put(sec);\r\n}\r\nstatic\r\nint plain_flush_ctx_cache(struct ptlrpc_sec *sec,\r\nuid_t uid, int grace, int force)\r\n{\r\nstruct plain_sec *plsec = sec2plsec(sec);\r\nstruct ptlrpc_cli_ctx *ctx;\r\nif (uid != -1)\r\nreturn 0;\r\nwrite_lock(&plsec->pls_lock);\r\nctx = plsec->pls_ctx;\r\nplsec->pls_ctx = NULL;\r\nwrite_unlock(&plsec->pls_lock);\r\nif (ctx)\r\nsptlrpc_cli_ctx_put(ctx, 1);\r\nreturn 0;\r\n}\r\nstatic\r\nint plain_alloc_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint msgsize)\r\n{\r\n__u32 buflens[PLAIN_PACK_SEGMENTS] = { 0, };\r\nint alloc_len;\r\nbuflens[PLAIN_PACK_HDR_OFF] = sizeof(struct plain_header);\r\nbuflens[PLAIN_PACK_MSG_OFF] = msgsize;\r\nif (req->rq_pack_udesc)\r\nbuflens[PLAIN_PACK_USER_OFF] = sptlrpc_current_user_desc_size();\r\nif (req->rq_pack_bulk) {\r\nLASSERT(req->rq_bulk_read || req->rq_bulk_write);\r\nbuflens[PLAIN_PACK_BULK_OFF] = PLAIN_BSD_SIZE;\r\n}\r\nalloc_len = lustre_msg_size_v2(PLAIN_PACK_SEGMENTS, buflens);\r\nif (!req->rq_reqbuf) {\r\nLASSERT(!req->rq_pool);\r\nalloc_len = size_roundup_power2(alloc_len);\r\nOBD_ALLOC_LARGE(req->rq_reqbuf, alloc_len);\r\nif (!req->rq_reqbuf)\r\nreturn -ENOMEM;\r\nreq->rq_reqbuf_len = alloc_len;\r\n} else {\r\nLASSERT(req->rq_pool);\r\nLASSERT(req->rq_reqbuf_len >= alloc_len);\r\nmemset(req->rq_reqbuf, 0, alloc_len);\r\n}\r\nlustre_init_msg_v2(req->rq_reqbuf, PLAIN_PACK_SEGMENTS, buflens, NULL);\r\nreq->rq_reqmsg = lustre_msg_buf(req->rq_reqbuf, PLAIN_PACK_MSG_OFF, 0);\r\nif (req->rq_pack_udesc)\r\nsptlrpc_pack_user_desc(req->rq_reqbuf, PLAIN_PACK_USER_OFF);\r\nreturn 0;\r\n}\r\nstatic\r\nvoid plain_free_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req)\r\n{\r\nif (!req->rq_pool) {\r\nOBD_FREE_LARGE(req->rq_reqbuf, req->rq_reqbuf_len);\r\nreq->rq_reqbuf = NULL;\r\nreq->rq_reqbuf_len = 0;\r\n}\r\n}\r\nstatic\r\nint plain_alloc_repbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint msgsize)\r\n{\r\n__u32 buflens[PLAIN_PACK_SEGMENTS] = { 0, };\r\nint alloc_len;\r\nbuflens[PLAIN_PACK_HDR_OFF] = sizeof(struct plain_header);\r\nbuflens[PLAIN_PACK_MSG_OFF] = msgsize;\r\nif (req->rq_pack_bulk) {\r\nLASSERT(req->rq_bulk_read || req->rq_bulk_write);\r\nbuflens[PLAIN_PACK_BULK_OFF] = PLAIN_BSD_SIZE;\r\n}\r\nalloc_len = lustre_msg_size_v2(PLAIN_PACK_SEGMENTS, buflens);\r\nalloc_len += plain_at_offset;\r\nalloc_len = size_roundup_power2(alloc_len);\r\nOBD_ALLOC_LARGE(req->rq_repbuf, alloc_len);\r\nif (!req->rq_repbuf)\r\nreturn -ENOMEM;\r\nreq->rq_repbuf_len = alloc_len;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid plain_free_repbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req)\r\n{\r\nOBD_FREE_LARGE(req->rq_repbuf, req->rq_repbuf_len);\r\nreq->rq_repbuf = NULL;\r\nreq->rq_repbuf_len = 0;\r\n}\r\nstatic\r\nint plain_enlarge_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint segment, int newsize)\r\n{\r\nstruct lustre_msg *newbuf;\r\nint oldsize;\r\nint newmsg_size, newbuf_size;\r\nLASSERT(req->rq_reqbuf);\r\nLASSERT(req->rq_reqbuf_len >= req->rq_reqlen);\r\nLASSERT(lustre_msg_buf(req->rq_reqbuf, PLAIN_PACK_MSG_OFF, 0) ==\r\nreq->rq_reqmsg);\r\noldsize = req->rq_reqmsg->lm_buflens[segment];\r\nreq->rq_reqmsg->lm_buflens[segment] = newsize;\r\nnewmsg_size = lustre_msg_size_v2(req->rq_reqmsg->lm_bufcount,\r\nreq->rq_reqmsg->lm_buflens);\r\nreq->rq_reqmsg->lm_buflens[segment] = oldsize;\r\noldsize = req->rq_reqbuf->lm_buflens[PLAIN_PACK_MSG_OFF];\r\nreq->rq_reqbuf->lm_buflens[PLAIN_PACK_MSG_OFF] = newmsg_size;\r\nnewbuf_size = lustre_msg_size_v2(req->rq_reqbuf->lm_bufcount,\r\nreq->rq_reqbuf->lm_buflens);\r\nreq->rq_reqbuf->lm_buflens[PLAIN_PACK_MSG_OFF] = oldsize;\r\nLASSERT(!req->rq_pool || req->rq_reqbuf_len >= newbuf_size);\r\nif (req->rq_reqbuf_len < newbuf_size) {\r\nnewbuf_size = size_roundup_power2(newbuf_size);\r\nOBD_ALLOC_LARGE(newbuf, newbuf_size);\r\nif (newbuf == NULL)\r\nreturn -ENOMEM;\r\nif (req->rq_import)\r\nspin_lock(&req->rq_import->imp_lock);\r\nmemcpy(newbuf, req->rq_reqbuf, req->rq_reqbuf_len);\r\nOBD_FREE_LARGE(req->rq_reqbuf, req->rq_reqbuf_len);\r\nreq->rq_reqbuf = newbuf;\r\nreq->rq_reqbuf_len = newbuf_size;\r\nreq->rq_reqmsg = lustre_msg_buf(req->rq_reqbuf,\r\nPLAIN_PACK_MSG_OFF, 0);\r\nif (req->rq_import)\r\nspin_unlock(&req->rq_import->imp_lock);\r\n}\r\n_sptlrpc_enlarge_msg_inplace(req->rq_reqbuf, PLAIN_PACK_MSG_OFF,\r\nnewmsg_size);\r\n_sptlrpc_enlarge_msg_inplace(req->rq_reqmsg, segment, newsize);\r\nreq->rq_reqlen = newmsg_size;\r\nreturn 0;\r\n}\r\nstatic\r\nint plain_accept(struct ptlrpc_request *req)\r\n{\r\nstruct lustre_msg *msg = req->rq_reqbuf;\r\nstruct plain_header *phdr;\r\nint swabbed;\r\nLASSERT(SPTLRPC_FLVR_POLICY(req->rq_flvr.sf_rpc) ==\r\nSPTLRPC_POLICY_PLAIN);\r\nif (SPTLRPC_FLVR_BASE(req->rq_flvr.sf_rpc) !=\r\nSPTLRPC_FLVR_BASE(SPTLRPC_FLVR_PLAIN) ||\r\nSPTLRPC_FLVR_BULK_TYPE(req->rq_flvr.sf_rpc) !=\r\nSPTLRPC_FLVR_BULK_TYPE(SPTLRPC_FLVR_PLAIN)) {\r\nCERROR("Invalid rpc flavor %x\n", req->rq_flvr.sf_rpc);\r\nreturn SECSVC_DROP;\r\n}\r\nif (msg->lm_bufcount < PLAIN_PACK_SEGMENTS) {\r\nCERROR("unexpected request buf count %u\n", msg->lm_bufcount);\r\nreturn SECSVC_DROP;\r\n}\r\nswabbed = ptlrpc_req_need_swab(req);\r\nphdr = lustre_msg_buf(msg, PLAIN_PACK_HDR_OFF, sizeof(*phdr));\r\nif (phdr == NULL) {\r\nCERROR("missing plain header\n");\r\nreturn -EPROTO;\r\n}\r\nif (phdr->ph_ver != 0) {\r\nCERROR("Invalid header version\n");\r\nreturn -EPROTO;\r\n}\r\nif (phdr->ph_bulk_hash_alg >= BULK_HASH_ALG_MAX) {\r\nCERROR("invalid hash algorithm: %u\n", phdr->ph_bulk_hash_alg);\r\nreturn -EPROTO;\r\n}\r\nreq->rq_sp_from = phdr->ph_sp;\r\nreq->rq_flvr.u_bulk.hash.hash_alg = phdr->ph_bulk_hash_alg;\r\nif (phdr->ph_flags & PLAIN_FL_USER) {\r\nif (sptlrpc_unpack_user_desc(msg, PLAIN_PACK_USER_OFF,\r\nswabbed)) {\r\nCERROR("Mal-formed user descriptor\n");\r\nreturn SECSVC_DROP;\r\n}\r\nreq->rq_pack_udesc = 1;\r\nreq->rq_user_desc = lustre_msg_buf(msg, PLAIN_PACK_USER_OFF, 0);\r\n}\r\nif (phdr->ph_flags & PLAIN_FL_BULK) {\r\nif (plain_unpack_bsd(msg, swabbed))\r\nreturn SECSVC_DROP;\r\nreq->rq_pack_bulk = 1;\r\n}\r\nreq->rq_reqmsg = lustre_msg_buf(msg, PLAIN_PACK_MSG_OFF, 0);\r\nreq->rq_reqlen = msg->lm_buflens[PLAIN_PACK_MSG_OFF];\r\nreq->rq_svc_ctx = &plain_svc_ctx;\r\natomic_inc(&req->rq_svc_ctx->sc_refcount);\r\nreturn SECSVC_OK;\r\n}\r\nstatic\r\nint plain_alloc_rs(struct ptlrpc_request *req, int msgsize)\r\n{\r\nstruct ptlrpc_reply_state *rs;\r\n__u32 buflens[PLAIN_PACK_SEGMENTS] = { 0, };\r\nint rs_size = sizeof(*rs);\r\nLASSERT(msgsize % 8 == 0);\r\nbuflens[PLAIN_PACK_HDR_OFF] = sizeof(struct plain_header);\r\nbuflens[PLAIN_PACK_MSG_OFF] = msgsize;\r\nif (req->rq_pack_bulk && (req->rq_bulk_read || req->rq_bulk_write))\r\nbuflens[PLAIN_PACK_BULK_OFF] = PLAIN_BSD_SIZE;\r\nrs_size += lustre_msg_size_v2(PLAIN_PACK_SEGMENTS, buflens);\r\nrs = req->rq_reply_state;\r\nif (rs) {\r\nLASSERT(rs->rs_size >= rs_size);\r\n} else {\r\nOBD_ALLOC_LARGE(rs, rs_size);\r\nif (rs == NULL)\r\nreturn -ENOMEM;\r\nrs->rs_size = rs_size;\r\n}\r\nrs->rs_svc_ctx = req->rq_svc_ctx;\r\natomic_inc(&req->rq_svc_ctx->sc_refcount);\r\nrs->rs_repbuf = (struct lustre_msg *) (rs + 1);\r\nrs->rs_repbuf_len = rs_size - sizeof(*rs);\r\nlustre_init_msg_v2(rs->rs_repbuf, PLAIN_PACK_SEGMENTS, buflens, NULL);\r\nrs->rs_msg = lustre_msg_buf_v2(rs->rs_repbuf, PLAIN_PACK_MSG_OFF, 0);\r\nreq->rq_reply_state = rs;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid plain_free_rs(struct ptlrpc_reply_state *rs)\r\n{\r\nLASSERT(atomic_read(&rs->rs_svc_ctx->sc_refcount) > 1);\r\natomic_dec(&rs->rs_svc_ctx->sc_refcount);\r\nif (!rs->rs_prealloc)\r\nOBD_FREE_LARGE(rs, rs->rs_size);\r\n}\r\nstatic\r\nint plain_authorize(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_reply_state *rs = req->rq_reply_state;\r\nstruct lustre_msg_v2 *msg = rs->rs_repbuf;\r\nstruct plain_header *phdr;\r\nint len;\r\nLASSERT(rs);\r\nLASSERT(msg);\r\nif (req->rq_replen != msg->lm_buflens[PLAIN_PACK_MSG_OFF])\r\nlen = lustre_shrink_msg(msg, PLAIN_PACK_MSG_OFF,\r\nreq->rq_replen, 1);\r\nelse\r\nlen = lustre_msg_size_v2(msg->lm_bufcount, msg->lm_buflens);\r\nmsg->lm_secflvr = req->rq_flvr.sf_rpc;\r\nphdr = lustre_msg_buf(msg, PLAIN_PACK_HDR_OFF, 0);\r\nphdr->ph_ver = 0;\r\nphdr->ph_flags = 0;\r\nphdr->ph_bulk_hash_alg = req->rq_flvr.u_bulk.hash.hash_alg;\r\nif (req->rq_pack_bulk)\r\nphdr->ph_flags |= PLAIN_FL_BULK;\r\nrs->rs_repdata_len = len;\r\nif (likely(req->rq_packed_final)) {\r\nif (lustre_msghdr_get_flags(req->rq_reqmsg) & MSGHDR_AT_SUPPORT)\r\nreq->rq_reply_off = plain_at_offset;\r\nelse\r\nreq->rq_reply_off = 0;\r\n} else {\r\nunsigned int hsize = 4;\r\ncfs_crypto_hash_digest(CFS_HASH_ALG_CRC32,\r\nlustre_msg_buf(msg, PLAIN_PACK_MSG_OFF, 0),\r\nlustre_msg_buflen(msg, PLAIN_PACK_MSG_OFF),\r\nNULL, 0, (unsigned char *)&msg->lm_cksum, &hsize);\r\nreq->rq_reply_off = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nint plain_svc_unwrap_bulk(struct ptlrpc_request *req,\r\nstruct ptlrpc_bulk_desc *desc)\r\n{\r\nstruct ptlrpc_reply_state *rs = req->rq_reply_state;\r\nstruct ptlrpc_bulk_sec_desc *bsdr, *bsdv;\r\nstruct plain_bulk_token *tokenr;\r\nint rc;\r\nLASSERT(req->rq_bulk_write);\r\nLASSERT(req->rq_pack_bulk);\r\nbsdr = lustre_msg_buf(req->rq_reqbuf, PLAIN_PACK_BULK_OFF, 0);\r\ntokenr = (struct plain_bulk_token *) bsdr->bsd_data;\r\nbsdv = lustre_msg_buf(rs->rs_repbuf, PLAIN_PACK_BULK_OFF, 0);\r\nbsdv->bsd_version = 0;\r\nbsdv->bsd_type = SPTLRPC_BULK_DEFAULT;\r\nbsdv->bsd_svc = bsdr->bsd_svc;\r\nbsdv->bsd_flags = 0;\r\nif (bsdr->bsd_svc == SPTLRPC_BULK_SVC_NULL)\r\nreturn 0;\r\nrc = plain_verify_bulk_csum(desc, req->rq_flvr.u_bulk.hash.hash_alg,\r\ntokenr);\r\nif (rc) {\r\nbsdv->bsd_flags |= BSD_FL_ERR;\r\nCERROR("bulk write: server verify failed: %d\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic\r\nint plain_svc_wrap_bulk(struct ptlrpc_request *req,\r\nstruct ptlrpc_bulk_desc *desc)\r\n{\r\nstruct ptlrpc_reply_state *rs = req->rq_reply_state;\r\nstruct ptlrpc_bulk_sec_desc *bsdr, *bsdv;\r\nstruct plain_bulk_token *tokenv;\r\nint rc;\r\nLASSERT(req->rq_bulk_read);\r\nLASSERT(req->rq_pack_bulk);\r\nbsdr = lustre_msg_buf(req->rq_reqbuf, PLAIN_PACK_BULK_OFF, 0);\r\nbsdv = lustre_msg_buf(rs->rs_repbuf, PLAIN_PACK_BULK_OFF, 0);\r\ntokenv = (struct plain_bulk_token *) bsdv->bsd_data;\r\nbsdv->bsd_version = 0;\r\nbsdv->bsd_type = SPTLRPC_BULK_DEFAULT;\r\nbsdv->bsd_svc = bsdr->bsd_svc;\r\nbsdv->bsd_flags = 0;\r\nif (bsdr->bsd_svc == SPTLRPC_BULK_SVC_NULL)\r\nreturn 0;\r\nrc = plain_generate_bulk_csum(desc, req->rq_flvr.u_bulk.hash.hash_alg,\r\ntokenv);\r\nif (rc) {\r\nCERROR("bulk read: server failed to compute "\r\n"checksum: %d\n", rc);\r\n} else {\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OSC_CHECKSUM_RECEIVE))\r\ncorrupt_bulk_data(desc);\r\n}\r\nreturn rc;\r\n}\r\nint sptlrpc_plain_init(void)\r\n{\r\n__u32 buflens[PLAIN_PACK_SEGMENTS] = { 0, };\r\nint rc;\r\nbuflens[PLAIN_PACK_MSG_OFF] = lustre_msg_early_size();\r\nplain_at_offset = lustre_msg_size_v2(PLAIN_PACK_SEGMENTS, buflens);\r\nrc = sptlrpc_register_policy(&plain_policy);\r\nif (rc)\r\nCERROR("failed to register: %d\n", rc);\r\nreturn rc;\r\n}\r\nvoid sptlrpc_plain_fini(void)\r\n{\r\nint rc;\r\nrc = sptlrpc_unregister_policy(&plain_policy);\r\nif (rc)\r\nCERROR("cannot unregister: %d\n", rc);\r\n}
