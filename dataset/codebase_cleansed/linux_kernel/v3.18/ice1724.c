static inline int stdclock_is_spdif_master(struct snd_ice1712 *ice)\r\n{\r\nreturn (inb(ICEMT1724(ice, RATE)) & VT1724_SPDIF_MASTER) ? 1 : 0;\r\n}\r\nstatic inline int is_pro_rate_locked(struct snd_ice1712 *ice)\r\n{\r\nreturn (!ice->is_spdif_master(ice)) && PRO_RATE_LOCKED;\r\n}\r\nstatic unsigned char snd_vt1724_ac97_ready(struct snd_ice1712 *ice)\r\n{\r\nunsigned char old_cmd;\r\nint tm;\r\nfor (tm = 0; tm < 0x10000; tm++) {\r\nold_cmd = inb(ICEMT1724(ice, AC97_CMD));\r\nif (old_cmd & (VT1724_AC97_WRITE | VT1724_AC97_READ))\r\ncontinue;\r\nif (!(old_cmd & VT1724_AC97_READY))\r\ncontinue;\r\nreturn old_cmd;\r\n}\r\ndev_dbg(ice->card->dev, "snd_vt1724_ac97_ready: timeout\n");\r\nreturn old_cmd;\r\n}\r\nstatic int snd_vt1724_ac97_wait_bit(struct snd_ice1712 *ice, unsigned char bit)\r\n{\r\nint tm;\r\nfor (tm = 0; tm < 0x10000; tm++)\r\nif ((inb(ICEMT1724(ice, AC97_CMD)) & bit) == 0)\r\nreturn 0;\r\ndev_dbg(ice->card->dev, "snd_vt1724_ac97_wait_bit: timeout\n");\r\nreturn -EIO;\r\n}\r\nstatic void snd_vt1724_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct snd_ice1712 *ice = ac97->private_data;\r\nunsigned char old_cmd;\r\nold_cmd = snd_vt1724_ac97_ready(ice);\r\nold_cmd &= ~VT1724_AC97_ID_MASK;\r\nold_cmd |= ac97->num;\r\noutb(reg, ICEMT1724(ice, AC97_INDEX));\r\noutw(val, ICEMT1724(ice, AC97_DATA));\r\noutb(old_cmd | VT1724_AC97_WRITE, ICEMT1724(ice, AC97_CMD));\r\nsnd_vt1724_ac97_wait_bit(ice, VT1724_AC97_WRITE);\r\n}\r\nstatic unsigned short snd_vt1724_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct snd_ice1712 *ice = ac97->private_data;\r\nunsigned char old_cmd;\r\nold_cmd = snd_vt1724_ac97_ready(ice);\r\nold_cmd &= ~VT1724_AC97_ID_MASK;\r\nold_cmd |= ac97->num;\r\noutb(reg, ICEMT1724(ice, AC97_INDEX));\r\noutb(old_cmd | VT1724_AC97_READ, ICEMT1724(ice, AC97_CMD));\r\nif (snd_vt1724_ac97_wait_bit(ice, VT1724_AC97_READ) < 0)\r\nreturn ~0;\r\nreturn inw(ICEMT1724(ice, AC97_DATA));\r\n}\r\nstatic void snd_vt1724_set_gpio_dir(struct snd_ice1712 *ice, unsigned int data)\r\n{\r\noutl(data, ICEREG1724(ice, GPIO_DIRECTION));\r\ninw(ICEREG1724(ice, GPIO_DIRECTION));\r\n}\r\nstatic unsigned int snd_vt1724_get_gpio_dir(struct snd_ice1712 *ice)\r\n{\r\nreturn inl(ICEREG1724(ice, GPIO_DIRECTION));\r\n}\r\nstatic void snd_vt1724_set_gpio_mask(struct snd_ice1712 *ice, unsigned int data)\r\n{\r\noutw(data, ICEREG1724(ice, GPIO_WRITE_MASK));\r\nif (!ice->vt1720)\r\noutb((data >> 16) & 0xff, ICEREG1724(ice, GPIO_WRITE_MASK_22));\r\ninw(ICEREG1724(ice, GPIO_WRITE_MASK));\r\n}\r\nstatic unsigned int snd_vt1724_get_gpio_mask(struct snd_ice1712 *ice)\r\n{\r\nunsigned int mask;\r\nif (!ice->vt1720)\r\nmask = (unsigned int)inb(ICEREG1724(ice, GPIO_WRITE_MASK_22));\r\nelse\r\nmask = 0;\r\nmask = (mask << 16) | inw(ICEREG1724(ice, GPIO_WRITE_MASK));\r\nreturn mask;\r\n}\r\nstatic void snd_vt1724_set_gpio_data(struct snd_ice1712 *ice, unsigned int data)\r\n{\r\noutw(data, ICEREG1724(ice, GPIO_DATA));\r\nif (!ice->vt1720)\r\noutb(data >> 16, ICEREG1724(ice, GPIO_DATA_22));\r\ninw(ICEREG1724(ice, GPIO_DATA));\r\n}\r\nstatic unsigned int snd_vt1724_get_gpio_data(struct snd_ice1712 *ice)\r\n{\r\nunsigned int data;\r\nif (!ice->vt1720)\r\ndata = (unsigned int)inb(ICEREG1724(ice, GPIO_DATA_22));\r\nelse\r\ndata = 0;\r\ndata = (data << 16) | inw(ICEREG1724(ice, GPIO_DATA));\r\nreturn data;\r\n}\r\nstatic void vt1724_midi_clear_rx(struct snd_ice1712 *ice)\r\n{\r\nunsigned int count;\r\nfor (count = inb(ICEREG1724(ice, MPU_RXFIFO)); count > 0; --count)\r\ninb(ICEREG1724(ice, MPU_DATA));\r\n}\r\nstatic inline struct snd_rawmidi_substream *\r\nget_rawmidi_substream(struct snd_ice1712 *ice, unsigned int stream)\r\n{\r\nreturn list_first_entry(&ice->rmidi[0]->streams[stream].substreams,\r\nstruct snd_rawmidi_substream, list);\r\n}\r\nstatic void vt1724_midi_write(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_rawmidi_substream *s;\r\nint count, i;\r\nu8 buffer[32];\r\ns = get_rawmidi_substream(ice, SNDRV_RAWMIDI_STREAM_OUTPUT);\r\ncount = 31 - inb(ICEREG1724(ice, MPU_TXFIFO));\r\nif (count > 0) {\r\ncount = snd_rawmidi_transmit(s, buffer, count);\r\nfor (i = 0; i < count; ++i)\r\noutb(buffer[i], ICEREG1724(ice, MPU_DATA));\r\n}\r\nenable_midi_irq(ice, VT1724_IRQ_MPU_TX,\r\n!snd_rawmidi_transmit_empty(s));\r\n}\r\nstatic void vt1724_midi_read(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_rawmidi_substream *s;\r\nint count, i;\r\nu8 buffer[32];\r\ns = get_rawmidi_substream(ice, SNDRV_RAWMIDI_STREAM_INPUT);\r\ncount = inb(ICEREG1724(ice, MPU_RXFIFO));\r\nif (count > 0) {\r\ncount = min(count, 32);\r\nfor (i = 0; i < count; ++i)\r\nbuffer[i] = inb(ICEREG1724(ice, MPU_DATA));\r\nsnd_rawmidi_receive(s, buffer, count);\r\n}\r\n}\r\nstatic void enable_midi_irq(struct snd_ice1712 *ice, u8 flag, int enable)\r\n{\r\nu8 mask = inb(ICEREG1724(ice, IRQMASK));\r\nif (enable)\r\nmask &= ~flag;\r\nelse\r\nmask |= flag;\r\noutb(mask, ICEREG1724(ice, IRQMASK));\r\n}\r\nstatic void vt1724_enable_midi_irq(struct snd_rawmidi_substream *substream,\r\nu8 flag, int enable)\r\n{\r\nstruct snd_ice1712 *ice = substream->rmidi->private_data;\r\nspin_lock_irq(&ice->reg_lock);\r\nenable_midi_irq(ice, flag, enable);\r\nspin_unlock_irq(&ice->reg_lock);\r\n}\r\nstatic int vt1724_midi_output_open(struct snd_rawmidi_substream *s)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vt1724_midi_output_close(struct snd_rawmidi_substream *s)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vt1724_midi_output_trigger(struct snd_rawmidi_substream *s, int up)\r\n{\r\nstruct snd_ice1712 *ice = s->rmidi->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ice->reg_lock, flags);\r\nif (up) {\r\nice->midi_output = 1;\r\nvt1724_midi_write(ice);\r\n} else {\r\nice->midi_output = 0;\r\nenable_midi_irq(ice, VT1724_IRQ_MPU_TX, 0);\r\n}\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\n}\r\nstatic void vt1724_midi_output_drain(struct snd_rawmidi_substream *s)\r\n{\r\nstruct snd_ice1712 *ice = s->rmidi->private_data;\r\nunsigned long timeout;\r\nvt1724_enable_midi_irq(s, VT1724_IRQ_MPU_TX, 0);\r\ntimeout = jiffies + msecs_to_jiffies(15);\r\ndo {\r\nif (inb(ICEREG1724(ice, MPU_CTRL)) & VT1724_MPU_TX_EMPTY)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after(timeout, jiffies));\r\n}\r\nstatic int vt1724_midi_input_open(struct snd_rawmidi_substream *s)\r\n{\r\nvt1724_midi_clear_rx(s->rmidi->private_data);\r\nvt1724_enable_midi_irq(s, VT1724_IRQ_MPU_RX, 1);\r\nreturn 0;\r\n}\r\nstatic int vt1724_midi_input_close(struct snd_rawmidi_substream *s)\r\n{\r\nvt1724_enable_midi_irq(s, VT1724_IRQ_MPU_RX, 0);\r\nreturn 0;\r\n}\r\nstatic void vt1724_midi_input_trigger(struct snd_rawmidi_substream *s, int up)\r\n{\r\nstruct snd_ice1712 *ice = s->rmidi->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ice->reg_lock, flags);\r\nif (up) {\r\nice->midi_input = 1;\r\nvt1724_midi_read(ice);\r\n} else {\r\nice->midi_input = 0;\r\n}\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\n}\r\nstatic irqreturn_t snd_vt1724_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_ice1712 *ice = dev_id;\r\nunsigned char status;\r\nunsigned char status_mask =\r\nVT1724_IRQ_MPU_RX | VT1724_IRQ_MPU_TX | VT1724_IRQ_MTPCM;\r\nint handled = 0;\r\nint timeout = 0;\r\nwhile (1) {\r\nstatus = inb(ICEREG1724(ice, IRQSTAT));\r\nstatus &= status_mask;\r\nif (status == 0)\r\nbreak;\r\nspin_lock(&ice->reg_lock);\r\nif (++timeout > 10) {\r\nstatus = inb(ICEREG1724(ice, IRQSTAT));\r\ndev_err(ice->card->dev,\r\n"Too long irq loop, status = 0x%x\n", status);\r\nif (status & VT1724_IRQ_MPU_TX) {\r\ndev_err(ice->card->dev, "Disabling MPU_TX\n");\r\nenable_midi_irq(ice, VT1724_IRQ_MPU_TX, 0);\r\n}\r\nspin_unlock(&ice->reg_lock);\r\nbreak;\r\n}\r\nhandled = 1;\r\nif (status & VT1724_IRQ_MPU_TX) {\r\nif (ice->midi_output)\r\nvt1724_midi_write(ice);\r\nelse\r\nenable_midi_irq(ice, VT1724_IRQ_MPU_TX, 0);\r\nstatus_mask &= ~VT1724_IRQ_MPU_TX;\r\n}\r\nif (status & VT1724_IRQ_MPU_RX) {\r\nif (ice->midi_input)\r\nvt1724_midi_read(ice);\r\nelse\r\nvt1724_midi_clear_rx(ice);\r\n}\r\noutb(status, ICEREG1724(ice, IRQSTAT));\r\nspin_unlock(&ice->reg_lock);\r\nif (status & VT1724_IRQ_MTPCM) {\r\nunsigned char mtstat = inb(ICEMT1724(ice, IRQ));\r\nif (mtstat & VT1724_MULTI_PDMA0) {\r\nif (ice->playback_pro_substream)\r\nsnd_pcm_period_elapsed(ice->playback_pro_substream);\r\n}\r\nif (mtstat & VT1724_MULTI_RDMA0) {\r\nif (ice->capture_pro_substream)\r\nsnd_pcm_period_elapsed(ice->capture_pro_substream);\r\n}\r\nif (mtstat & VT1724_MULTI_PDMA1) {\r\nif (ice->playback_con_substream_ds[0])\r\nsnd_pcm_period_elapsed(ice->playback_con_substream_ds[0]);\r\n}\r\nif (mtstat & VT1724_MULTI_PDMA2) {\r\nif (ice->playback_con_substream_ds[1])\r\nsnd_pcm_period_elapsed(ice->playback_con_substream_ds[1]);\r\n}\r\nif (mtstat & VT1724_MULTI_PDMA3) {\r\nif (ice->playback_con_substream_ds[2])\r\nsnd_pcm_period_elapsed(ice->playback_con_substream_ds[2]);\r\n}\r\nif (mtstat & VT1724_MULTI_PDMA4) {\r\nif (ice->playback_con_substream)\r\nsnd_pcm_period_elapsed(ice->playback_con_substream);\r\n}\r\nif (mtstat & VT1724_MULTI_RDMA1) {\r\nif (ice->capture_con_substream)\r\nsnd_pcm_period_elapsed(ice->capture_con_substream);\r\n}\r\noutb(mtstat, ICEMT1724(ice, IRQ));\r\nif (mtstat & VT1724_MULTI_FIFO_ERR) {\r\nunsigned char fstat = inb(ICEMT1724(ice, DMA_FIFO_ERR));\r\noutb(fstat, ICEMT1724(ice, DMA_FIFO_ERR));\r\noutb(VT1724_MULTI_FIFO_ERR | inb(ICEMT1724(ice, DMA_INT_MASK)), ICEMT1724(ice, DMA_INT_MASK));\r\n}\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int snd_vt1724_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nunsigned char what;\r\nunsigned char old;\r\nstruct snd_pcm_substream *s;\r\nwhat = 0;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (snd_pcm_substream_chip(s) == ice) {\r\nconst struct vt1724_pcm_reg *reg;\r\nreg = s->runtime->private_data;\r\nwhat |= reg->start;\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nspin_lock(&ice->reg_lock);\r\nold = inb(ICEMT1724(ice, DMA_PAUSE));\r\nif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\r\nold |= what;\r\nelse\r\nold &= ~what;\r\noutb(old, ICEMT1724(ice, DMA_PAUSE));\r\nspin_unlock(&ice->reg_lock);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nspin_lock(&ice->reg_lock);\r\nold = inb(ICEMT1724(ice, DMA_CONTROL));\r\nif (cmd == SNDRV_PCM_TRIGGER_START)\r\nold |= what;\r\nelse\r\nold &= ~what;\r\noutb(old, ICEMT1724(ice, DMA_CONTROL));\r\nspin_unlock(&ice->reg_lock);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int stdclock_get_rate(struct snd_ice1712 *ice)\r\n{\r\nunsigned int rate;\r\nrate = stdclock_rate_list[inb(ICEMT1724(ice, RATE)) & 15];\r\nreturn rate;\r\n}\r\nstatic void stdclock_set_rate(struct snd_ice1712 *ice, unsigned int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(stdclock_rate_list); i++) {\r\nif (stdclock_rate_list[i] == rate) {\r\noutb(i, ICEMT1724(ice, RATE));\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic unsigned char stdclock_set_mclk(struct snd_ice1712 *ice,\r\nunsigned int rate)\r\n{\r\nunsigned char val, old;\r\nif (ice->eeprom.data[ICE_EEP2_ACLINK] & VT1724_CFG_PRO_I2S) {\r\nval = old = inb(ICEMT1724(ice, I2S_FORMAT));\r\nif (rate > 96000)\r\nval |= VT1724_MT_I2S_MCLK_128X;\r\nelse\r\nval &= ~VT1724_MT_I2S_MCLK_128X;\r\nif (val != old) {\r\noutb(val, ICEMT1724(ice, I2S_FORMAT));\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_set_pro_rate(struct snd_ice1712 *ice, unsigned int rate,\r\nint force)\r\n{\r\nunsigned long flags;\r\nunsigned char mclk_change;\r\nunsigned int i, old_rate;\r\nif (rate > ice->hw_rates->list[ice->hw_rates->count - 1])\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ice->reg_lock, flags);\r\nif ((inb(ICEMT1724(ice, DMA_CONTROL)) & DMA_STARTS) ||\r\n(inb(ICEMT1724(ice, DMA_PAUSE)) & DMA_PAUSES)) {\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\nreturn ((rate == ice->cur_rate) && !force) ? 0 : -EBUSY;\r\n}\r\nif (!force && is_pro_rate_locked(ice)) {\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\nreturn (rate == ice->cur_rate) ? 0 : -EBUSY;\r\n}\r\nif (force || !ice->is_spdif_master(ice)) {\r\nold_rate = ice->get_rate(ice);\r\nif (force || (old_rate != rate))\r\nice->set_rate(ice, rate);\r\nelse if (rate == ice->cur_rate) {\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\nreturn 0;\r\n}\r\n}\r\nice->cur_rate = rate;\r\nmclk_change = ice->set_mclk(ice, rate);\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\nif (mclk_change && ice->gpio.i2s_mclk_changed)\r\nice->gpio.i2s_mclk_changed(ice);\r\nif (ice->gpio.set_pro_rate)\r\nice->gpio.set_pro_rate(ice, rate);\r\nfor (i = 0; i < ice->akm_codecs; i++) {\r\nif (ice->akm[i].ops.set_rate_val)\r\nice->akm[i].ops.set_rate_val(&ice->akm[i], rate);\r\n}\r\nif (ice->spdif.ops.setup_rate)\r\nice->spdif.ops.setup_rate(ice, rate);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nint i, chs, err;\r\nchs = params_channels(hw_params);\r\nmutex_lock(&ice->open_mutex);\r\nif (substream == ice->playback_pro_substream) {\r\nchs = chs / 2 - 1;\r\nfor (i = 0; i < chs; i++) {\r\nif (ice->pcm_reserved[i] &&\r\nice->pcm_reserved[i] != substream) {\r\nmutex_unlock(&ice->open_mutex);\r\nreturn -EBUSY;\r\n}\r\nice->pcm_reserved[i] = substream;\r\n}\r\nfor (; i < 3; i++) {\r\nif (ice->pcm_reserved[i] == substream)\r\nice->pcm_reserved[i] = NULL;\r\n}\r\n} else {\r\nfor (i = 0; i < 3; i++) {\r\nif (ice->playback_con_substream_ds[i] == substream) {\r\nif (ice->pcm_reserved[i] &&\r\nice->pcm_reserved[i] != substream) {\r\nmutex_unlock(&ice->open_mutex);\r\nreturn -EBUSY;\r\n}\r\nice->pcm_reserved[i] = substream;\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&ice->open_mutex);\r\nerr = snd_vt1724_set_pro_rate(ice, params_rate(hw_params), 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_vt1724_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nint i;\r\nmutex_lock(&ice->open_mutex);\r\nfor (i = 0; i < 3; i++)\r\nif (ice->pcm_reserved[i] == substream)\r\nice->pcm_reserved[i] = NULL;\r\nmutex_unlock(&ice->open_mutex);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_vt1724_playback_pro_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nunsigned char val;\r\nunsigned int size;\r\nspin_lock_irq(&ice->reg_lock);\r\nval = (8 - substream->runtime->channels) >> 1;\r\noutb(val, ICEMT1724(ice, BURST));\r\noutl(substream->runtime->dma_addr, ICEMT1724(ice, PLAYBACK_ADDR));\r\nsize = (snd_pcm_lib_buffer_bytes(substream) >> 2) - 1;\r\noutw(size, ICEMT1724(ice, PLAYBACK_SIZE));\r\noutb(size >> 16, ICEMT1724(ice, PLAYBACK_SIZE) + 2);\r\nsize = (snd_pcm_lib_period_bytes(substream) >> 2) - 1;\r\noutw(size, ICEMT1724(ice, PLAYBACK_COUNT));\r\noutb(size >> 16, ICEMT1724(ice, PLAYBACK_COUNT) + 2);\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_vt1724_playback_pro_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(inl(ICEMT1724(ice, DMA_CONTROL)) & VT1724_PDMA0_START))\r\nreturn 0;\r\n#if 0\r\nptr = inl(ICEMT1724(ice, PLAYBACK_ADDR));\r\nif (ptr < substream->runtime->dma_addr) {\r\ndev_dbg(ice->card->dev, "invalid negative ptr\n");\r\nreturn 0;\r\n}\r\nptr -= substream->runtime->dma_addr;\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\nif (ptr >= substream->runtime->buffer_size) {\r\ndev_dbg(ice->card->dev, "invalid ptr %d (size=%d)\n",\r\n(int)ptr, (int)substream->runtime->period_size);\r\nreturn 0;\r\n}\r\n#else\r\nptr = inl(ICEMT1724(ice, PLAYBACK_SIZE)) & 0xffffff;\r\nptr = (ptr + 1) << 2;\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\nif (!ptr)\r\n;\r\nelse if (ptr <= substream->runtime->buffer_size)\r\nptr = substream->runtime->buffer_size - ptr;\r\nelse {\r\ndev_dbg(ice->card->dev, "invalid ptr %d (size=%d)\n",\r\n(int)ptr, (int)substream->runtime->buffer_size);\r\nptr = 0;\r\n}\r\n#endif\r\nreturn ptr;\r\n}\r\nstatic int snd_vt1724_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nconst struct vt1724_pcm_reg *reg = substream->runtime->private_data;\r\nspin_lock_irq(&ice->reg_lock);\r\noutl(substream->runtime->dma_addr, ice->profi_port + reg->addr);\r\noutw((snd_pcm_lib_buffer_bytes(substream) >> 2) - 1,\r\nice->profi_port + reg->size);\r\noutw((snd_pcm_lib_period_bytes(substream) >> 2) - 1,\r\nice->profi_port + reg->count);\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_vt1724_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nconst struct vt1724_pcm_reg *reg = substream->runtime->private_data;\r\nsize_t ptr;\r\nif (!(inl(ICEMT1724(ice, DMA_CONTROL)) & reg->start))\r\nreturn 0;\r\n#if 0\r\nptr = inl(ice->profi_port + reg->addr);\r\nptr -= substream->runtime->dma_addr;\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n#else\r\nptr = inw(ice->profi_port + reg->size);\r\nptr = (ptr + 1) << 2;\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\nif (!ptr)\r\n;\r\nelse if (ptr <= substream->runtime->buffer_size)\r\nptr = substream->runtime->buffer_size - ptr;\r\nelse {\r\ndev_dbg(ice->card->dev, "invalid ptr %d (size=%d)\n",\r\n(int)ptr, (int)substream->runtime->buffer_size);\r\nptr = 0;\r\n}\r\nreturn ptr;\r\n#endif\r\n}\r\nstatic void set_std_hw_rates(struct snd_ice1712 *ice)\r\n{\r\nif (ice->eeprom.data[ICE_EEP2_ACLINK] & VT1724_CFG_PRO_I2S) {\r\nif ((ice->eeprom.data[ICE_EEP2_I2S] & 0x08) && !ice->vt1720)\r\nice->hw_rates = &hw_constraints_rates_192;\r\nelse\r\nice->hw_rates = &hw_constraints_rates_96;\r\n} else {\r\nice->hw_rates = &hw_constraints_rates_48;\r\n}\r\n}\r\nstatic int set_rate_constraints(struct snd_ice1712 *ice,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw.rate_min = ice->hw_rates->list[0];\r\nruntime->hw.rate_max = ice->hw_rates->list[ice->hw_rates->count - 1];\r\nruntime->hw.rates = SNDRV_PCM_RATE_KNOT;\r\nreturn snd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nice->hw_rates);\r\n}\r\nstatic void constrain_rate_if_locked(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int rate;\r\nif (is_pro_rate_locked(ice)) {\r\nrate = ice->get_rate(ice);\r\nif (rate >= runtime->hw.rate_min\r\n&& rate <= runtime->hw.rate_max) {\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\n}\r\n}\r\nstatic int snd_vt1724_playback_pro_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nint chs, num_indeps;\r\nruntime->private_data = (void *)&vt1724_playback_pro_reg;\r\nice->playback_pro_substream = substream;\r\nruntime->hw = snd_vt1724_playback_pro;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nset_rate_constraints(ice, substream);\r\nmutex_lock(&ice->open_mutex);\r\nnum_indeps = ice->num_total_dacs / 2 - 1;\r\nfor (chs = 0; chs < num_indeps; chs++) {\r\nif (ice->pcm_reserved[chs])\r\nbreak;\r\n}\r\nchs = (chs + 1) * 2;\r\nruntime->hw.channels_max = chs;\r\nif (chs > 2)\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, 2);\r\nmutex_unlock(&ice->open_mutex);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nVT1724_BUFFER_ALIGN);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nVT1724_BUFFER_ALIGN);\r\nconstrain_rate_if_locked(substream);\r\nif (ice->pro_open)\r\nice->pro_open(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_capture_pro_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->private_data = (void *)&vt1724_capture_pro_reg;\r\nice->capture_pro_substream = substream;\r\nruntime->hw = snd_vt1724_2ch_stereo;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nset_rate_constraints(ice, substream);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nVT1724_BUFFER_ALIGN);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nVT1724_BUFFER_ALIGN);\r\nconstrain_rate_if_locked(substream);\r\nif (ice->pro_open)\r\nice->pro_open(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_playback_pro_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nif (PRO_RATE_RESET)\r\nsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\r\nice->playback_pro_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_capture_pro_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nif (PRO_RATE_RESET)\r\nsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\r\nice->capture_pro_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pcm_profi(struct snd_ice1712 *ice, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint capt, err;\r\nif ((ice->eeprom.data[ICE_EEP2_SYSCONF] & VT1724_CFG_ADC_MASK) ==\r\nVT1724_CFG_ADC_NONE)\r\ncapt = 0;\r\nelse\r\ncapt = 1;\r\nerr = snd_pcm_new(ice->card, "ICE1724", device, 1, capt, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_vt1724_playback_pro_ops);\r\nif (capt)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_vt1724_capture_pro_ops);\r\npcm->private_data = ice;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "ICE1724");\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(ice->pci),\r\n256*1024, 256*1024);\r\nice->pcm_pro = pcm;\r\nreturn 0;\r\n}\r\nstatic void update_spdif_bits(struct snd_ice1712 *ice, unsigned int val)\r\n{\r\nunsigned char cbit, disabled;\r\ncbit = inb(ICEREG1724(ice, SPDIF_CFG));\r\ndisabled = cbit & ~VT1724_CFG_SPDIF_OUT_EN;\r\nif (cbit != disabled)\r\noutb(disabled, ICEREG1724(ice, SPDIF_CFG));\r\noutw(val, ICEMT1724(ice, SPDIF_CTRL));\r\nif (cbit != disabled)\r\noutb(cbit, ICEREG1724(ice, SPDIF_CFG));\r\noutw(val, ICEMT1724(ice, SPDIF_CTRL));\r\n}\r\nstatic void update_spdif_rate(struct snd_ice1712 *ice, unsigned int rate)\r\n{\r\nunsigned int val, nval;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ice->reg_lock, flags);\r\nnval = val = inw(ICEMT1724(ice, SPDIF_CTRL));\r\nnval &= ~(7 << 12);\r\nswitch (rate) {\r\ncase 44100: break;\r\ncase 48000: nval |= 2 << 12; break;\r\ncase 32000: nval |= 3 << 12; break;\r\ncase 88200: nval |= 4 << 12; break;\r\ncase 96000: nval |= 5 << 12; break;\r\ncase 192000: nval |= 6 << 12; break;\r\ncase 176400: nval |= 7 << 12; break;\r\n}\r\nif (val != nval)\r\nupdate_spdif_bits(ice, nval);\r\nspin_unlock_irqrestore(&ice->reg_lock, flags);\r\n}\r\nstatic int snd_vt1724_playback_spdif_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nif (!ice->force_pdma4)\r\nupdate_spdif_rate(ice, substream->runtime->rate);\r\nreturn snd_vt1724_pcm_prepare(substream);\r\n}\r\nstatic int snd_vt1724_playback_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->private_data = (void *)&vt1724_playback_spdif_reg;\r\nice->playback_con_substream = substream;\r\nif (ice->force_pdma4) {\r\nruntime->hw = snd_vt1724_2ch_stereo;\r\nset_rate_constraints(ice, substream);\r\n} else\r\nruntime->hw = snd_vt1724_spdif;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nVT1724_BUFFER_ALIGN);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nVT1724_BUFFER_ALIGN);\r\nconstrain_rate_if_locked(substream);\r\nif (ice->spdif.ops.open)\r\nice->spdif.ops.open(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_playback_spdif_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nif (PRO_RATE_RESET)\r\nsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\r\nice->playback_con_substream = NULL;\r\nif (ice->spdif.ops.close)\r\nice->spdif.ops.close(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_capture_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->private_data = (void *)&vt1724_capture_spdif_reg;\r\nice->capture_con_substream = substream;\r\nif (ice->force_rdma1) {\r\nruntime->hw = snd_vt1724_2ch_stereo;\r\nset_rate_constraints(ice, substream);\r\n} else\r\nruntime->hw = snd_vt1724_spdif;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nVT1724_BUFFER_ALIGN);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nVT1724_BUFFER_ALIGN);\r\nconstrain_rate_if_locked(substream);\r\nif (ice->spdif.ops.open)\r\nice->spdif.ops.open(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_capture_spdif_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nif (PRO_RATE_RESET)\r\nsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\r\nice->capture_con_substream = NULL;\r\nif (ice->spdif.ops.close)\r\nice->spdif.ops.close(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pcm_spdif(struct snd_ice1712 *ice, int device)\r\n{\r\nchar *name;\r\nstruct snd_pcm *pcm;\r\nint play, capt;\r\nint err;\r\nif (ice->force_pdma4 ||\r\n(ice->eeprom.data[ICE_EEP2_SPDIF] & VT1724_CFG_SPDIF_OUT_INT)) {\r\nplay = 1;\r\nice->has_spdif = 1;\r\n} else\r\nplay = 0;\r\nif (ice->force_rdma1 ||\r\n(ice->eeprom.data[ICE_EEP2_SPDIF] & VT1724_CFG_SPDIF_IN)) {\r\ncapt = 1;\r\nice->has_spdif = 1;\r\n} else\r\ncapt = 0;\r\nif (!play && !capt)\r\nreturn 0;\r\nif (ice->force_pdma4 || ice->force_rdma1)\r\nname = "ICE1724 Secondary";\r\nelse\r\nname = "ICE1724 IEC958";\r\nerr = snd_pcm_new(ice->card, name, device, play, capt, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nif (play)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_vt1724_playback_spdif_ops);\r\nif (capt)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_vt1724_capture_spdif_ops);\r\npcm->private_data = ice;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, name);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(ice->pci),\r\n256*1024, 256*1024);\r\nice->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_playback_indep_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nunsigned char val;\r\nspin_lock_irq(&ice->reg_lock);\r\nval = 3 - substream->number;\r\nif (inb(ICEMT1724(ice, BURST)) < val)\r\noutb(val, ICEMT1724(ice, BURST));\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn snd_vt1724_pcm_prepare(substream);\r\n}\r\nstatic int snd_vt1724_playback_indep_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nmutex_lock(&ice->open_mutex);\r\nif (ice->pcm_reserved[substream->number]) {\r\nmutex_unlock(&ice->open_mutex);\r\nreturn -EBUSY;\r\n}\r\nmutex_unlock(&ice->open_mutex);\r\nruntime->private_data = (void *)&vt1724_playback_dma_regs[substream->number];\r\nice->playback_con_substream_ds[substream->number] = substream;\r\nruntime->hw = snd_vt1724_2ch_stereo;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nset_rate_constraints(ice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_playback_indep_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ice1712 *ice = snd_pcm_substream_chip(substream);\r\nif (PRO_RATE_RESET)\r\nsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 0);\r\nice->playback_con_substream_ds[substream->number] = NULL;\r\nice->pcm_reserved[substream->number] = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pcm_indep(struct snd_ice1712 *ice, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint play;\r\nint err;\r\nplay = ice->num_total_dacs / 2 - 1;\r\nif (play <= 0)\r\nreturn 0;\r\nerr = snd_pcm_new(ice->card, "ICE1724 Surrounds", device, play, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_vt1724_playback_indep_ops);\r\npcm->private_data = ice;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "ICE1724 Surround PCM");\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(ice->pci),\r\n256*1024, 256*1024);\r\nice->pcm_ds = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_ac97_mixer(struct snd_ice1712 *ice)\r\n{\r\nint err;\r\nif (!(ice->eeprom.data[ICE_EEP2_ACLINK] & VT1724_CFG_PRO_I2S)) {\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_vt1724_ac97_write,\r\n.read = snd_vt1724_ac97_read,\r\n};\r\noutb(inb(ICEMT1724(ice, AC97_CMD)) | 0x80, ICEMT1724(ice, AC97_CMD));\r\nmdelay(5);\r\noutb(inb(ICEMT1724(ice, AC97_CMD)) & ~0x80, ICEMT1724(ice, AC97_CMD));\r\nerr = snd_ac97_bus(ice->card, 0, &ops, NULL, &pbus);\r\nif (err < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = ice;\r\nerr = snd_ac97_mixer(pbus, &ac97, &ice->ac97);\r\nif (err < 0)\r\ndev_warn(ice->card->dev,\r\n"cannot initialize pro ac97, skipped\n");\r\nelse\r\nreturn 0;\r\n}\r\nstrcat(ice->card->mixername, "ICE1724 - multitrack");\r\nreturn 0;\r\n}\r\nstatic inline unsigned int eeprom_triple(struct snd_ice1712 *ice, int idx)\r\n{\r\nreturn (unsigned int)ice->eeprom.data[idx] | \\r\n((unsigned int)ice->eeprom.data[idx + 1] << 8) | \\r\n((unsigned int)ice->eeprom.data[idx + 2] << 16);\r\n}\r\nstatic void snd_vt1724_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_ice1712 *ice = entry->private_data;\r\nunsigned int idx;\r\nsnd_iprintf(buffer, "%s\n\n", ice->card->longname);\r\nsnd_iprintf(buffer, "EEPROM:\n");\r\nsnd_iprintf(buffer, " Subvendor : 0x%x\n", ice->eeprom.subvendor);\r\nsnd_iprintf(buffer, " Size : %i bytes\n", ice->eeprom.size);\r\nsnd_iprintf(buffer, " Version : %i\n", ice->eeprom.version);\r\nsnd_iprintf(buffer, " System Config : 0x%x\n",\r\nice->eeprom.data[ICE_EEP2_SYSCONF]);\r\nsnd_iprintf(buffer, " ACLink : 0x%x\n",\r\nice->eeprom.data[ICE_EEP2_ACLINK]);\r\nsnd_iprintf(buffer, " I2S : 0x%x\n",\r\nice->eeprom.data[ICE_EEP2_I2S]);\r\nsnd_iprintf(buffer, " S/PDIF : 0x%x\n",\r\nice->eeprom.data[ICE_EEP2_SPDIF]);\r\nsnd_iprintf(buffer, " GPIO direction : 0x%x\n",\r\nice->eeprom.gpiodir);\r\nsnd_iprintf(buffer, " GPIO mask : 0x%x\n",\r\nice->eeprom.gpiomask);\r\nsnd_iprintf(buffer, " GPIO state : 0x%x\n",\r\nice->eeprom.gpiostate);\r\nfor (idx = 0x12; idx < ice->eeprom.size; idx++)\r\nsnd_iprintf(buffer, " Extra #%02i : 0x%x\n",\r\nidx, ice->eeprom.data[idx]);\r\nsnd_iprintf(buffer, "\nRegisters:\n");\r\nsnd_iprintf(buffer, " PSDOUT03 : 0x%08x\n",\r\n(unsigned)inl(ICEMT1724(ice, ROUTE_PLAYBACK)));\r\nfor (idx = 0x0; idx < 0x20 ; idx++)\r\nsnd_iprintf(buffer, " CCS%02x : 0x%02x\n",\r\nidx, inb(ice->port+idx));\r\nfor (idx = 0x0; idx < 0x30 ; idx++)\r\nsnd_iprintf(buffer, " MT%02x : 0x%02x\n",\r\nidx, inb(ice->profi_port+idx));\r\n}\r\nstatic void snd_vt1724_proc_init(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(ice->card, "ice1724", &entry))\r\nsnd_info_set_text_ops(entry, ice, snd_vt1724_proc_read);\r\n}\r\nstatic int snd_vt1724_eeprom_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = sizeof(struct snd_ice1712_eeprom);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_eeprom_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmemcpy(ucontrol->value.bytes.data, &ice->eeprom, sizeof(ice->eeprom));\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic unsigned int encode_spdif_bits(struct snd_aes_iec958 *diga)\r\n{\r\nunsigned int val, rbits;\r\nval = diga->status[0] & 0x03;\r\nif (val & 0x01) {\r\nif ((diga->status[0] & IEC958_AES0_PRO_EMPHASIS) ==\r\nIEC958_AES0_PRO_EMPHASIS_5015)\r\nval |= 1U << 3;\r\nrbits = (diga->status[4] >> 3) & 0x0f;\r\nif (rbits) {\r\nswitch (rbits) {\r\ncase 2: val |= 5 << 12; break;\r\ncase 3: val |= 6 << 12; break;\r\ncase 10: val |= 4 << 12; break;\r\ncase 11: val |= 7 << 12; break;\r\n}\r\n} else {\r\nswitch (diga->status[0] & IEC958_AES0_PRO_FS) {\r\ncase IEC958_AES0_PRO_FS_44100:\r\nbreak;\r\ncase IEC958_AES0_PRO_FS_32000:\r\nval |= 3U << 12;\r\nbreak;\r\ndefault:\r\nval |= 2U << 12;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nval |= diga->status[1] & 0x04;\r\nif ((diga->status[0] & IEC958_AES0_CON_EMPHASIS) ==\r\nIEC958_AES0_CON_EMPHASIS_5015)\r\nval |= 1U << 3;\r\nval |= (unsigned int)(diga->status[1] & 0x3f) << 4;\r\nval |= (unsigned int)(diga->status[3] & IEC958_AES3_CON_FS) << 12;\r\n}\r\nreturn val;\r\n}\r\nstatic void decode_spdif_bits(struct snd_aes_iec958 *diga, unsigned int val)\r\n{\r\nmemset(diga->status, 0, sizeof(diga->status));\r\ndiga->status[0] = val & 0x03;\r\nif (val & 0x01) {\r\nif (val & (1U << 3))\r\ndiga->status[0] |= IEC958_AES0_PRO_EMPHASIS_5015;\r\nswitch ((val >> 12) & 0x7) {\r\ncase 0:\r\nbreak;\r\ncase 2:\r\ndiga->status[0] |= IEC958_AES0_PRO_FS_32000;\r\nbreak;\r\ndefault:\r\ndiga->status[0] |= IEC958_AES0_PRO_FS_48000;\r\nbreak;\r\n}\r\n} else {\r\ndiga->status[0] |= val & (1U << 2);\r\nif (val & (1U << 3))\r\ndiga->status[0] |= IEC958_AES0_CON_EMPHASIS_5015;\r\ndiga->status[1] |= (val >> 4) & 0x3f;\r\ndiga->status[3] |= (val >> 12) & 0x07;\r\n}\r\n}\r\nstatic int snd_vt1724_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nval = inw(ICEMT1724(ice, SPDIF_CTRL));\r\ndecode_spdif_bits(&ucontrol->value.iec958, val);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int val, old;\r\nval = encode_spdif_bits(&ucontrol->value.iec958);\r\nspin_lock_irq(&ice->reg_lock);\r\nold = inw(ICEMT1724(ice, SPDIF_CTRL));\r\nif (val != old)\r\nupdate_spdif_bits(ice, val);\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn val != old;\r\n}\r\nstatic int snd_vt1724_spdif_maskc_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\r\nIEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_CON_NOT_COPYRIGHT |\r\nIEC958_AES0_CON_EMPHASIS;\r\nucontrol->value.iec958.status[1] = IEC958_AES1_CON_ORIGINAL |\r\nIEC958_AES1_CON_CATEGORY;\r\nucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_spdif_maskp_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_NONAUDIO |\r\nIEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_PRO_FS |\r\nIEC958_AES0_PRO_EMPHASIS;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_spdif_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = inb(ICEREG1724(ice, SPDIF_CFG)) &\r\nVT1724_CFG_SPDIF_OUT_EN ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_spdif_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned char old, val;\r\nspin_lock_irq(&ice->reg_lock);\r\nold = val = inb(ICEREG1724(ice, SPDIF_CFG));\r\nval &= ~VT1724_CFG_SPDIF_OUT_EN;\r\nif (ucontrol->value.integer.value[0])\r\nval |= VT1724_CFG_SPDIF_OUT_EN;\r\nif (old != val)\r\noutb(val, ICEREG1724(ice, SPDIF_CFG));\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn old != val;\r\n}\r\nstatic int snd_vt1724_pro_internal_clock_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint hw_rates_count = ice->hw_rates->count;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = hw_rates_count;\r\nif (ice->force_rdma1 ||\r\n(ice->eeprom.data[ICE_EEP2_SPDIF] & VT1724_CFG_SPDIF_IN))\r\nuinfo->value.enumerated.items += ice->ext_clock_count;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nif (uinfo->value.enumerated.item >= hw_rates_count)\r\nstrcpy(uinfo->value.enumerated.name,\r\nice->ext_clock_names[\r\nuinfo->value.enumerated.item - hw_rates_count]);\r\nelse\r\nsprintf(uinfo->value.enumerated.name, "%d",\r\nice->hw_rates->list[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pro_internal_clock_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int i, rate;\r\nspin_lock_irq(&ice->reg_lock);\r\nif (ice->is_spdif_master(ice)) {\r\nucontrol->value.enumerated.item[0] = ice->hw_rates->count +\r\nice->get_spdif_master_type(ice);\r\n} else {\r\nrate = ice->get_rate(ice);\r\nucontrol->value.enumerated.item[0] = 0;\r\nfor (i = 0; i < ice->hw_rates->count; i++) {\r\nif (ice->hw_rates->list[i] == rate) {\r\nucontrol->value.enumerated.item[0] = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int stdclock_get_spdif_master_type(struct snd_ice1712 *ice)\r\n{\r\nreturn 0;\r\n}\r\nstatic int stdclock_set_spdif_clock(struct snd_ice1712 *ice, int type)\r\n{\r\nunsigned char oval;\r\nunsigned char i2s_oval;\r\noval = inb(ICEMT1724(ice, RATE));\r\noutb(oval | VT1724_SPDIF_MASTER, ICEMT1724(ice, RATE));\r\ni2s_oval = inb(ICEMT1724(ice, I2S_FORMAT));\r\noutb(i2s_oval & ~VT1724_MT_I2S_MCLK_128X, ICEMT1724(ice, I2S_FORMAT));\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pro_internal_clock_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned int old_rate, new_rate;\r\nunsigned int item = ucontrol->value.enumerated.item[0];\r\nunsigned int first_ext_clock = ice->hw_rates->count;\r\nif (item > first_ext_clock + ice->ext_clock_count - 1)\r\nreturn -EINVAL;\r\nspin_lock_irq(&ice->reg_lock);\r\nif (ice->is_spdif_master(ice))\r\nold_rate = 0;\r\nelse\r\nold_rate = ice->get_rate(ice);\r\nif (item >= first_ext_clock) {\r\nice->set_spdif_clock(ice, item - first_ext_clock);\r\nnew_rate = 0;\r\n} else {\r\nnew_rate = ice->hw_rates->list[item];\r\nice->pro_rate_default = new_rate;\r\nspin_unlock_irq(&ice->reg_lock);\r\nsnd_vt1724_set_pro_rate(ice, ice->pro_rate_default, 1);\r\nspin_lock_irq(&ice->reg_lock);\r\n}\r\nspin_unlock_irq(&ice->reg_lock);\r\nif (old_rate != new_rate && !new_rate) {\r\nunsigned int i;\r\nif (ice->gpio.set_pro_rate)\r\nice->gpio.set_pro_rate(ice, 0);\r\nfor (i = 0; i < ice->akm_codecs; i++) {\r\nif (ice->akm[i].ops.set_rate_val)\r\nice->akm[i].ops.set_rate_val(&ice->akm[i], 0);\r\n}\r\n}\r\nreturn old_rate != new_rate;\r\n}\r\nstatic int snd_vt1724_pro_rate_locking_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = PRO_RATE_LOCKED;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pro_rate_locking_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint change = 0, nval;\r\nnval = ucontrol->value.integer.value[0] ? 1 : 0;\r\nspin_lock_irq(&ice->reg_lock);\r\nchange = PRO_RATE_LOCKED != nval;\r\nPRO_RATE_LOCKED = nval;\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_vt1724_pro_rate_reset_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = PRO_RATE_RESET ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pro_rate_reset_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint change = 0, nval;\r\nnval = ucontrol->value.integer.value[0] ? 1 : 0;\r\nspin_lock_irq(&ice->reg_lock);\r\nchange = PRO_RATE_RESET != nval;\r\nPRO_RATE_RESET = nval;\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_vt1724_pro_route_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[] = {\r\n"PCM Out",\r\n"H/W In 0", "H/W In 1",\r\n"IEC958 In L", "IEC958 In R",\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 5;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic inline int analog_route_shift(int idx)\r\n{\r\nreturn (idx % 2) * 12 + ((idx / 2) * 3) + 8;\r\n}\r\nstatic inline int digital_route_shift(int idx)\r\n{\r\nreturn idx * 3;\r\n}\r\nint snd_ice1724_get_route_val(struct snd_ice1712 *ice, int shift)\r\n{\r\nunsigned long val;\r\nunsigned char eitem;\r\nstatic const unsigned char xlate[8] = {\r\n0, 255, 1, 2, 255, 255, 3, 4,\r\n};\r\nval = inl(ICEMT1724(ice, ROUTE_PLAYBACK));\r\nval >>= shift;\r\nval &= 7;\r\neitem = xlate[val];\r\nif (eitem == 255) {\r\nsnd_BUG();\r\nreturn 0;\r\n}\r\nreturn eitem;\r\n}\r\nint snd_ice1724_put_route_val(struct snd_ice1712 *ice, unsigned int val,\r\nint shift)\r\n{\r\nunsigned int old_val, nval;\r\nint change;\r\nstatic const unsigned char xroute[8] = {\r\n0,\r\n2,\r\n3,\r\n6,\r\n7,\r\n};\r\nnval = xroute[val % 5];\r\nval = old_val = inl(ICEMT1724(ice, ROUTE_PLAYBACK));\r\nval &= ~(0x07 << shift);\r\nval |= nval << shift;\r\nchange = val != old_val;\r\nif (change)\r\noutl(val, ICEMT1724(ice, ROUTE_PLAYBACK));\r\nreturn change;\r\n}\r\nstatic int snd_vt1724_pro_route_analog_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nucontrol->value.enumerated.item[0] =\r\nsnd_ice1724_get_route_val(ice, analog_route_shift(idx));\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pro_route_analog_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nreturn snd_ice1724_put_route_val(ice,\r\nucontrol->value.enumerated.item[0],\r\nanalog_route_shift(idx));\r\n}\r\nstatic int snd_vt1724_pro_route_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nucontrol->value.enumerated.item[0] =\r\nsnd_ice1724_get_route_val(ice, digital_route_shift(idx));\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pro_route_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nreturn snd_ice1724_put_route_val(ice,\r\nucontrol->value.enumerated.item[0],\r\ndigital_route_shift(idx));\r\n}\r\nstatic int snd_vt1724_pro_peak_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 22;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_pro_peak_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint idx;\r\nspin_lock_irq(&ice->reg_lock);\r\nfor (idx = 0; idx < 22; idx++) {\r\noutb(idx, ICEMT1724(ice, MONITOR_PEAKINDEX));\r\nucontrol->value.integer.value[idx] =\r\ninb(ICEMT1724(ice, MONITOR_PEAKDATA));\r\n}\r\nspin_unlock_irq(&ice->reg_lock);\r\nreturn 0;\r\n}\r\nstatic void wait_i2c_busy(struct snd_ice1712 *ice)\r\n{\r\nint t = 0x10000;\r\nwhile ((inb(ICEREG1724(ice, I2C_CTRL)) & VT1724_I2C_BUSY) && t--)\r\n;\r\nif (t == -1)\r\ndev_err(ice->card->dev, "i2c busy timeout\n");\r\n}\r\nunsigned char snd_vt1724_read_i2c(struct snd_ice1712 *ice,\r\nunsigned char dev, unsigned char addr)\r\n{\r\nunsigned char val;\r\nmutex_lock(&ice->i2c_mutex);\r\nwait_i2c_busy(ice);\r\noutb(addr, ICEREG1724(ice, I2C_BYTE_ADDR));\r\noutb(dev & ~VT1724_I2C_WRITE, ICEREG1724(ice, I2C_DEV_ADDR));\r\nwait_i2c_busy(ice);\r\nval = inb(ICEREG1724(ice, I2C_DATA));\r\nmutex_unlock(&ice->i2c_mutex);\r\nreturn val;\r\n}\r\nvoid snd_vt1724_write_i2c(struct snd_ice1712 *ice,\r\nunsigned char dev, unsigned char addr, unsigned char data)\r\n{\r\nmutex_lock(&ice->i2c_mutex);\r\nwait_i2c_busy(ice);\r\noutb(addr, ICEREG1724(ice, I2C_BYTE_ADDR));\r\noutb(data, ICEREG1724(ice, I2C_DATA));\r\noutb(dev | VT1724_I2C_WRITE, ICEREG1724(ice, I2C_DEV_ADDR));\r\nwait_i2c_busy(ice);\r\nmutex_unlock(&ice->i2c_mutex);\r\n}\r\nstatic int snd_vt1724_read_eeprom(struct snd_ice1712 *ice,\r\nconst char *modelname)\r\n{\r\nconst int dev = 0xa0;\r\nunsigned int i, size;\r\nstruct snd_ice1712_card_info * const *tbl, *c;\r\nif (!modelname || !*modelname) {\r\nice->eeprom.subvendor = 0;\r\nif ((inb(ICEREG1724(ice, I2C_CTRL)) & VT1724_I2C_EEPROM) != 0)\r\nice->eeprom.subvendor =\r\n(snd_vt1724_read_i2c(ice, dev, 0x00) << 0) |\r\n(snd_vt1724_read_i2c(ice, dev, 0x01) << 8) |\r\n(snd_vt1724_read_i2c(ice, dev, 0x02) << 16) |\r\n(snd_vt1724_read_i2c(ice, dev, 0x03) << 24);\r\nif (ice->eeprom.subvendor == 0 ||\r\nice->eeprom.subvendor == (unsigned int)-1) {\r\nu16 vendor, device;\r\npci_read_config_word(ice->pci, PCI_SUBSYSTEM_VENDOR_ID,\r\n&vendor);\r\npci_read_config_word(ice->pci, PCI_SUBSYSTEM_ID, &device);\r\nice->eeprom.subvendor =\r\n((unsigned int)swab16(vendor) << 16) | swab16(device);\r\nif (ice->eeprom.subvendor == 0 ||\r\nice->eeprom.subvendor == (unsigned int)-1) {\r\ndev_err(ice->card->dev,\r\n"No valid ID is found\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\n}\r\nfor (tbl = card_tables; *tbl; tbl++) {\r\nfor (c = *tbl; c->name; c++) {\r\nif (modelname && c->model &&\r\n!strcmp(modelname, c->model)) {\r\ndev_info(ice->card->dev,\r\n"Using board model %s\n",\r\nc->name);\r\nice->eeprom.subvendor = c->subvendor;\r\n} else if (c->subvendor != ice->eeprom.subvendor)\r\ncontinue;\r\nice->card_info = c;\r\nif (!c->eeprom_size || !c->eeprom_data)\r\ngoto found;\r\ndev_dbg(ice->card->dev, "using the defined eeprom..\n");\r\nice->eeprom.version = 2;\r\nice->eeprom.size = c->eeprom_size + 6;\r\nmemcpy(ice->eeprom.data, c->eeprom_data, c->eeprom_size);\r\ngoto read_skipped;\r\n}\r\n}\r\ndev_warn(ice->card->dev, "No matching model found for ID 0x%x\n",\r\nice->eeprom.subvendor);\r\n#ifdef CONFIG_PM_SLEEP\r\nice->pm_suspend_enabled = 1;\r\n#endif\r\nfound:\r\nice->eeprom.size = snd_vt1724_read_i2c(ice, dev, 0x04);\r\nif (ice->eeprom.size < 6)\r\nice->eeprom.size = 32;\r\nelse if (ice->eeprom.size > 32) {\r\ndev_err(ice->card->dev, "Invalid EEPROM (size = %i)\n",\r\nice->eeprom.size);\r\nreturn -EIO;\r\n}\r\nice->eeprom.version = snd_vt1724_read_i2c(ice, dev, 0x05);\r\nif (ice->eeprom.version != 1 && ice->eeprom.version != 2)\r\ndev_warn(ice->card->dev, "Invalid EEPROM version %i\n",\r\nice->eeprom.version);\r\nsize = ice->eeprom.size - 6;\r\nfor (i = 0; i < size; i++)\r\nice->eeprom.data[i] = snd_vt1724_read_i2c(ice, dev, i + 6);\r\nread_skipped:\r\nice->eeprom.gpiomask = eeprom_triple(ice, ICE_EEP2_GPIO_MASK);\r\nice->eeprom.gpiostate = eeprom_triple(ice, ICE_EEP2_GPIO_STATE);\r\nice->eeprom.gpiodir = eeprom_triple(ice, ICE_EEP2_GPIO_DIR);\r\nreturn 0;\r\n}\r\nstatic void snd_vt1724_chip_reset(struct snd_ice1712 *ice)\r\n{\r\noutb(VT1724_RESET , ICEREG1724(ice, CONTROL));\r\ninb(ICEREG1724(ice, CONTROL));\r\nmsleep(10);\r\noutb(0, ICEREG1724(ice, CONTROL));\r\ninb(ICEREG1724(ice, CONTROL));\r\nmsleep(10);\r\n}\r\nstatic int snd_vt1724_chip_init(struct snd_ice1712 *ice)\r\n{\r\noutb(ice->eeprom.data[ICE_EEP2_SYSCONF], ICEREG1724(ice, SYS_CFG));\r\noutb(ice->eeprom.data[ICE_EEP2_ACLINK], ICEREG1724(ice, AC97_CFG));\r\noutb(ice->eeprom.data[ICE_EEP2_I2S], ICEREG1724(ice, I2S_FEATURES));\r\noutb(ice->eeprom.data[ICE_EEP2_SPDIF], ICEREG1724(ice, SPDIF_CFG));\r\nice->gpio.write_mask = ice->eeprom.gpiomask;\r\nice->gpio.direction = ice->eeprom.gpiodir;\r\nsnd_vt1724_set_gpio_mask(ice, ice->eeprom.gpiomask);\r\nsnd_vt1724_set_gpio_dir(ice, ice->eeprom.gpiodir);\r\nsnd_vt1724_set_gpio_data(ice, ice->eeprom.gpiostate);\r\noutb(0, ICEREG1724(ice, POWERDOWN));\r\noutb(VT1724_IRQ_MPU_RX | VT1724_IRQ_MPU_TX , ICEREG1724(ice, IRQMASK));\r\noutb(VT1724_MULTI_FIFO_ERR, ICEMT1724(ice, DMA_INT_MASK));\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_spdif_build_controls(struct snd_ice1712 *ice)\r\n{\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nif (snd_BUG_ON(!ice->pcm))\r\nreturn -EIO;\r\nif (!ice->own_routing) {\r\nerr = snd_ctl_add(ice->card,\r\nsnd_ctl_new1(&snd_vt1724_mixer_pro_spdif_route, ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_spdif_switch, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, kctl = snd_ctl_new1(&snd_vt1724_spdif_default, ice));\r\nif (err < 0)\r\nreturn err;\r\nkctl->id.device = ice->pcm->device;\r\nerr = snd_ctl_add(ice->card, kctl = snd_ctl_new1(&snd_vt1724_spdif_maskc, ice));\r\nif (err < 0)\r\nreturn err;\r\nkctl->id.device = ice->pcm->device;\r\nerr = snd_ctl_add(ice->card, kctl = snd_ctl_new1(&snd_vt1724_spdif_maskp, ice));\r\nif (err < 0)\r\nreturn err;\r\nkctl->id.device = ice->pcm->device;\r\n#if 0\r\nerr = snd_ctl_add(ice->card, kctl = snd_ctl_new1(&snd_vt1724_spdif_stream, ice));\r\nif (err < 0)\r\nreturn err;\r\nkctl->id.device = ice->pcm->device;\r\nice->spdif.stream_ctl = kctl;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_build_controls(struct snd_ice1712 *ice)\r\n{\r\nint err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_eeprom, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_pro_internal_clock, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_pro_rate_locking, ice));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_pro_rate_reset, ice));\r\nif (err < 0)\r\nreturn err;\r\nif (!ice->own_routing && ice->num_total_dacs > 0) {\r\nstruct snd_kcontrol_new tmp = snd_vt1724_mixer_pro_analog_route;\r\ntmp.count = ice->num_total_dacs;\r\nif (ice->vt1720 && tmp.count > 2)\r\ntmp.count = 2;\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&tmp, ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = snd_ctl_add(ice->card, snd_ctl_new1(&snd_vt1724_mixer_pro_peak, ice));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_free(struct snd_ice1712 *ice)\r\n{\r\nif (!ice->port)\r\ngoto __hw_end;\r\noutb(0xff, ICEMT1724(ice, DMA_INT_MASK));\r\noutb(0xff, ICEREG1724(ice, IRQMASK));\r\n__hw_end:\r\nif (ice->irq >= 0)\r\nfree_irq(ice->irq, ice);\r\npci_release_regions(ice->pci);\r\nsnd_ice1712_akm4xxx_free(ice);\r\npci_disable_device(ice->pci);\r\nkfree(ice->spec);\r\nkfree(ice);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ice1712 *ice = device->device_data;\r\nreturn snd_vt1724_free(ice);\r\n}\r\nstatic int snd_vt1724_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nconst char *modelname,\r\nstruct snd_ice1712 **r_ice1712)\r\n{\r\nstruct snd_ice1712 *ice;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_vt1724_dev_free,\r\n};\r\n*r_ice1712 = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nice = kzalloc(sizeof(*ice), GFP_KERNEL);\r\nif (ice == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nice->vt1724 = 1;\r\nspin_lock_init(&ice->reg_lock);\r\nmutex_init(&ice->gpio_mutex);\r\nmutex_init(&ice->open_mutex);\r\nmutex_init(&ice->i2c_mutex);\r\nice->gpio.set_mask = snd_vt1724_set_gpio_mask;\r\nice->gpio.get_mask = snd_vt1724_get_gpio_mask;\r\nice->gpio.set_dir = snd_vt1724_set_gpio_dir;\r\nice->gpio.get_dir = snd_vt1724_get_gpio_dir;\r\nice->gpio.set_data = snd_vt1724_set_gpio_data;\r\nice->gpio.get_data = snd_vt1724_get_gpio_data;\r\nice->card = card;\r\nice->pci = pci;\r\nice->irq = -1;\r\npci_set_master(pci);\r\nsnd_vt1724_proc_init(ice);\r\nsynchronize_irq(pci->irq);\r\ncard->private_data = ice;\r\nerr = pci_request_regions(pci, "ICE1724");\r\nif (err < 0) {\r\nkfree(ice);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nice->port = pci_resource_start(pci, 0);\r\nice->profi_port = pci_resource_start(pci, 1);\r\nif (request_irq(pci->irq, snd_vt1724_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, ice)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_vt1724_free(ice);\r\nreturn -EIO;\r\n}\r\nice->irq = pci->irq;\r\nsnd_vt1724_chip_reset(ice);\r\nif (snd_vt1724_read_eeprom(ice, modelname) < 0) {\r\nsnd_vt1724_free(ice);\r\nreturn -EIO;\r\n}\r\nif (snd_vt1724_chip_init(ice) < 0) {\r\nsnd_vt1724_free(ice);\r\nreturn -EIO;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ice, &ops);\r\nif (err < 0) {\r\nsnd_vt1724_free(ice);\r\nreturn err;\r\n}\r\n*r_ice1712 = ice;\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_ice1712 *ice;\r\nint pcm_dev = 0, err;\r\nstruct snd_ice1712_card_info * const *tbl, *c;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(card->driver, "ICE1724");\r\nstrcpy(card->shortname, "ICEnsemble ICE1724");\r\nerr = snd_vt1724_create(card, pci, model[dev], &ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nice->ext_clock_count = 0;\r\nfor (tbl = card_tables; *tbl; tbl++) {\r\nfor (c = *tbl; c->name; c++) {\r\nif ((model[dev] && c->model &&\r\n!strcmp(model[dev], c->model)) ||\r\n(c->subvendor == ice->eeprom.subvendor)) {\r\nstrcpy(card->shortname, c->name);\r\nif (c->driver)\r\nstrcpy(card->driver, c->driver);\r\nif (c->chip_init) {\r\nerr = c->chip_init(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\ngoto __found;\r\n}\r\n}\r\n}\r\nc = &no_matched;\r\n__found:\r\nice->pro_rate_default = PRO_RATE_DEFAULT;\r\nif (!ice->is_spdif_master)\r\nice->is_spdif_master = stdclock_is_spdif_master;\r\nif (!ice->get_rate)\r\nice->get_rate = stdclock_get_rate;\r\nif (!ice->set_rate)\r\nice->set_rate = stdclock_set_rate;\r\nif (!ice->set_mclk)\r\nice->set_mclk = stdclock_set_mclk;\r\nif (!ice->set_spdif_clock)\r\nice->set_spdif_clock = stdclock_set_spdif_clock;\r\nif (!ice->get_spdif_master_type)\r\nice->get_spdif_master_type = stdclock_get_spdif_master_type;\r\nif (!ice->ext_clock_names)\r\nice->ext_clock_names = ext_clock_names;\r\nif (!ice->ext_clock_count)\r\nice->ext_clock_count = ARRAY_SIZE(ext_clock_names);\r\nif (!ice->hw_rates)\r\nset_std_hw_rates(ice);\r\nerr = snd_vt1724_pcm_profi(ice, pcm_dev++);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_vt1724_pcm_spdif(ice, pcm_dev++);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_vt1724_pcm_indep(ice, pcm_dev++);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_vt1724_ac97_mixer(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_vt1724_build_controls(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (ice->pcm && ice->has_spdif) {\r\nerr = snd_vt1724_spdif_build_controls(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\nif (c->build_controls) {\r\nerr = c->build_controls(ice);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\nif (!c->no_mpu401) {\r\nif (ice->eeprom.data[ICE_EEP2_SYSCONF] & VT1724_CFG_MPU401) {\r\nstruct snd_rawmidi *rmidi;\r\nerr = snd_rawmidi_new(card, "MIDI", 0, 1, 1, &rmidi);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nice->rmidi[0] = rmidi;\r\nrmidi->private_data = ice;\r\nstrcpy(rmidi->name, "ICE1724 MIDI");\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\r\n&vt1724_midi_output_ops);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\r\n&vt1724_midi_input_ops);\r\noutb(VT1724_MPU_RX_FIFO | 0x1,\r\nICEREG1724(ice, MPU_FIFO_WM));\r\noutb(0x1, ICEREG1724(ice, MPU_FIFO_WM));\r\noutb(VT1724_MPU_UART, ICEREG1724(ice, MPU_CTRL));\r\n}\r\n}\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, ice->port, ice->irq);\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_vt1724_remove(struct pci_dev *pci)\r\n{\r\nstruct snd_card *card = pci_get_drvdata(pci);\r\nstruct snd_ice1712 *ice = card->private_data;\r\nif (ice->card_info && ice->card_info->chip_exit)\r\nice->card_info->chip_exit(ice);\r\nsnd_card_free(card);\r\n}\r\nstatic int snd_vt1724_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_ice1712 *ice = card->private_data;\r\nif (!ice->pm_suspend_enabled)\r\nreturn 0;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(ice->pcm);\r\nsnd_pcm_suspend_all(ice->pcm_pro);\r\nsnd_pcm_suspend_all(ice->pcm_ds);\r\nsnd_ac97_suspend(ice->ac97);\r\nspin_lock_irq(&ice->reg_lock);\r\nice->pm_saved_is_spdif_master = ice->is_spdif_master(ice);\r\nice->pm_saved_spdif_ctrl = inw(ICEMT1724(ice, SPDIF_CTRL));\r\nice->pm_saved_spdif_cfg = inb(ICEREG1724(ice, SPDIF_CFG));\r\nice->pm_saved_route = inl(ICEMT1724(ice, ROUTE_PLAYBACK));\r\nspin_unlock_irq(&ice->reg_lock);\r\nif (ice->pm_suspend)\r\nice->pm_suspend(ice);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_vt1724_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_ice1712 *ice = card->private_data;\r\nif (!ice->pm_suspend_enabled)\r\nreturn 0;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_vt1724_chip_reset(ice);\r\nif (snd_vt1724_chip_init(ice) < 0) {\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\nif (ice->pm_resume)\r\nice->pm_resume(ice);\r\nif (ice->pm_saved_is_spdif_master) {\r\nice->set_spdif_clock(ice, 0);\r\n} else {\r\nint rate;\r\nif (ice->cur_rate)\r\nrate = ice->cur_rate;\r\nelse\r\nrate = ice->pro_rate_default;\r\nsnd_vt1724_set_pro_rate(ice, rate, 1);\r\n}\r\nupdate_spdif_bits(ice, ice->pm_saved_spdif_ctrl);\r\noutb(ice->pm_saved_spdif_cfg, ICEREG1724(ice, SPDIF_CFG));\r\noutl(ice->pm_saved_route, ICEMT1724(ice, ROUTE_PLAYBACK));\r\nif (ice->ac97)\r\nsnd_ac97_resume(ice->ac97);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
