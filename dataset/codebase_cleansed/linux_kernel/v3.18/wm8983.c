static int eqmode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int reg;\r\nreg = snd_soc_read(codec, WM8983_EQ1_LOW_SHELF);\r\nif (reg & WM8983_EQ3DMODE)\r\nucontrol->value.integer.value[0] = 1;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int eqmode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int regpwr2, regpwr3;\r\nunsigned int reg_eq;\r\nif (ucontrol->value.integer.value[0] != 0\r\n&& ucontrol->value.integer.value[0] != 1)\r\nreturn -EINVAL;\r\nreg_eq = snd_soc_read(codec, WM8983_EQ1_LOW_SHELF);\r\nswitch ((reg_eq & WM8983_EQ3DMODE) >> WM8983_EQ3DMODE_SHIFT) {\r\ncase 0:\r\nif (!ucontrol->value.integer.value[0])\r\nreturn 0;\r\nbreak;\r\ncase 1:\r\nif (ucontrol->value.integer.value[0])\r\nreturn 0;\r\nbreak;\r\n}\r\nregpwr2 = snd_soc_read(codec, WM8983_POWER_MANAGEMENT_2);\r\nregpwr3 = snd_soc_read(codec, WM8983_POWER_MANAGEMENT_3);\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_2,\r\nWM8983_ADCENR_MASK | WM8983_ADCENL_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_3,\r\nWM8983_DACENR_MASK | WM8983_DACENL_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8983_EQ1_LOW_SHELF,\r\nWM8983_EQ3DMODE_MASK,\r\nucontrol->value.integer.value[0]\r\n<< WM8983_EQ3DMODE_SHIFT);\r\nsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_2, regpwr2);\r\nsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_3, regpwr3);\r\nreturn 0;\r\n}\r\nstatic bool wm8983_readable(struct device *dev, unsigned int reg)\r\n{\r\nif (reg > WM8983_MAX_REGISTER)\r\nreturn 0;\r\nreturn wm8983_access_masks[reg].read != 0;\r\n}\r\nstatic int wm8983_dac_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nreturn snd_soc_update_bits(codec, WM8983_DAC_CONTROL,\r\nWM8983_SOFTMUTE_MASK,\r\n!!mute << WM8983_SOFTMUTE_SHIFT);\r\n}\r\nstatic int wm8983_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 format, master, bcp, lrp;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nformat = 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nformat = 0x0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nformat = 0x1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nformat = 0x3;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown dai format\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8983_AUDIO_INTERFACE,\r\nWM8983_FMT_MASK, format << WM8983_FMT_SHIFT);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmaster = 0;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8983_CLOCK_GEN_CONTROL,\r\nWM8983_MS_MASK, master << WM8983_MS_SHIFT);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ndev_err(dai->dev, "DSP A/B modes are not supported\n");\r\nreturn -EINVAL;\r\ndefault:\r\nbreak;\r\n}\r\nbcp = lrp = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbcp = lrp = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbcp = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrp = 1;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown polarity configuration\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8983_AUDIO_INTERFACE,\r\nWM8983_LRCP_MASK, lrp << WM8983_LRCP_SHIFT);\r\nsnd_soc_update_bits(codec, WM8983_AUDIO_INTERFACE,\r\nWM8983_BCP_MASK, bcp << WM8983_BCP_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int wm8983_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint i;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8983_priv *wm8983 = snd_soc_codec_get_drvdata(codec);\r\nu16 blen, srate_idx;\r\nu32 tmp;\r\nint srate_best;\r\nint ret;\r\nret = snd_soc_params_to_bclk(params);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to convert params to bclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nwm8983->bclk = ret;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nblen = 0x0;\r\nbreak;\r\ncase 20:\r\nblen = 0x1;\r\nbreak;\r\ncase 24:\r\nblen = 0x2;\r\nbreak;\r\ncase 32:\r\nblen = 0x3;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unsupported word length %u\n",\r\nparams_width(params));\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8983_AUDIO_INTERFACE,\r\nWM8983_WL_MASK, blen << WM8983_WL_SHIFT);\r\nsrate_idx = 0;\r\nsrate_best = abs(srates[0] - params_rate(params));\r\nfor (i = 1; i < ARRAY_SIZE(srates); ++i) {\r\nif (abs(srates[i] - params_rate(params)) >= srate_best)\r\ncontinue;\r\nsrate_idx = i;\r\nsrate_best = abs(srates[i] - params_rate(params));\r\n}\r\ndev_dbg(dai->dev, "Selected SRATE = %d\n", srates[srate_idx]);\r\nsnd_soc_update_bits(codec, WM8983_ADDITIONAL_CONTROL,\r\nWM8983_SR_MASK, srate_idx << WM8983_SR_SHIFT);\r\ndev_dbg(dai->dev, "Target BCLK = %uHz\n", wm8983->bclk);\r\ndev_dbg(dai->dev, "SYSCLK = %uHz\n", wm8983->sysclk);\r\nfor (i = 0; i < ARRAY_SIZE(fs_ratios); ++i) {\r\nif (wm8983->sysclk / params_rate(params)\r\n== fs_ratios[i].ratio)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fs_ratios)) {\r\ndev_err(dai->dev, "Unable to configure MCLK ratio %u/%u\n",\r\nwm8983->sysclk, params_rate(params));\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "MCLK ratio = %dfs\n", fs_ratios[i].ratio);\r\nsnd_soc_update_bits(codec, WM8983_CLOCK_GEN_CONTROL,\r\nWM8983_MCLKDIV_MASK, i << WM8983_MCLKDIV_SHIFT);\r\ntmp = (wm8983->sysclk / fs_ratios[i].div) * 10;\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); ++i) {\r\nif (wm8983->bclk == tmp / bclk_divs[i])\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(bclk_divs)) {\r\ndev_err(dai->dev, "No matching BCLK divider found\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "BCLK div = %d\n", i);\r\nsnd_soc_update_bits(codec, WM8983_CLOCK_GEN_CONTROL,\r\nWM8983_BCLKDIV_MASK, i << WM8983_BCLKDIV_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int pll_factors(struct pll_div *pll_div, unsigned int target,\r\nunsigned int source)\r\n{\r\nu64 Kpart;\r\nunsigned long int K, Ndiv, Nmod;\r\npll_div->div2 = 0;\r\nNdiv = target / source;\r\nif (Ndiv < 6) {\r\nsource >>= 1;\r\npll_div->div2 = 1;\r\nNdiv = target / source;\r\n}\r\nif (Ndiv < 6 || Ndiv > 12) {\r\nprintk(KERN_ERR "%s: WM8983 N value is not within"\r\n" the recommended range: %lu\n", __func__, Ndiv);\r\nreturn -EINVAL;\r\n}\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (u64)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xffffffff;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div->k = K;\r\nreturn 0;\r\n}\r\nstatic int wm8983_set_pll(struct snd_soc_dai *dai, int pll_id,\r\nint source, unsigned int freq_in,\r\nunsigned int freq_out)\r\n{\r\nint ret;\r\nstruct snd_soc_codec *codec;\r\nstruct pll_div pll_div;\r\ncodec = dai->codec;\r\nif (!freq_in || !freq_out) {\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\r\nWM8983_PLLEN_MASK, 0);\r\nreturn 0;\r\n} else {\r\nret = pll_factors(&pll_div, freq_out * 4 * 2, freq_in);\r\nif (ret)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\r\nWM8983_PLLEN_MASK, 0);\r\nsnd_soc_write(codec, WM8983_PLL_N,\r\n(pll_div.div2 << WM8983_PLL_PRESCALE_SHIFT)\r\n| pll_div.n);\r\nsnd_soc_write(codec, WM8983_PLL_K_3, pll_div.k & 0x1ff);\r\nsnd_soc_write(codec, WM8983_PLL_K_2, (pll_div.k >> 9) & 0x1ff);\r\nsnd_soc_write(codec, WM8983_PLL_K_1, (pll_div.k >> 18));\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\r\nWM8983_PLLEN_MASK, WM8983_PLLEN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8983_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8983_priv *wm8983 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase WM8983_CLKSRC_MCLK:\r\nsnd_soc_update_bits(codec, WM8983_CLOCK_GEN_CONTROL,\r\nWM8983_CLKSEL_MASK, 0);\r\nbreak;\r\ncase WM8983_CLKSRC_PLL:\r\nsnd_soc_update_bits(codec, WM8983_CLOCK_GEN_CONTROL,\r\nWM8983_CLKSEL_MASK, WM8983_CLKSEL);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown clock source: %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nwm8983->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int wm8983_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8983_priv *wm8983 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\r\nWM8983_VMIDSEL_MASK,\r\n1 << WM8983_VMIDSEL_SHIFT);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regcache_sync(wm8983->regmap);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,\r\nWM8983_POBCTRL_MASK | WM8983_DELEN_MASK,\r\nWM8983_POBCTRL | WM8983_DELEN);\r\nsnd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,\r\nWM8983_TSDEN_MASK, WM8983_TSDEN);\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\r\nWM8983_BIASEN_MASK, WM8983_BIASEN);\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\r\nWM8983_VMIDSEL_MASK,\r\n1 << WM8983_VMIDSEL_SHIFT);\r\nmsleep(250);\r\nsnd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,\r\nWM8983_POBCTRL_MASK |\r\nWM8983_DELEN_MASK, 0);\r\n}\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\r\nWM8983_VMIDSEL_MASK,\r\n2 << WM8983_VMIDSEL_SHIFT);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,\r\nWM8983_TSDEN_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,\r\nWM8983_VMIDSEL_MASK | WM8983_BIASEN_MASK,\r\n0);\r\nmsleep(100);\r\nsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_1, 0);\r\nsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_2, 0);\r\nsnd_soc_write(codec, WM8983_POWER_MANAGEMENT_3, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8983_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8983_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8983_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8983_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8983_remove(struct snd_soc_codec *codec)\r\n{\r\nwm8983_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8983_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nint i;\r\nret = snd_soc_write(codec, WM8983_SOFTWARE_RESET, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vol_update_regs); ++i)\r\nsnd_soc_update_bits(codec, vol_update_regs[i],\r\n0x100, 0x100);\r\nfor (i = WM8983_LOUT1_HP_VOLUME_CTRL;\r\ni <= WM8983_OUT4_MONO_MIX_CTRL; ++i)\r\nsnd_soc_update_bits(codec, i, 0x40, 0x40);\r\nsnd_soc_update_bits(codec, WM8983_DAC_CONTROL,\r\nWM8983_SOFTMUTE_MASK,\r\nWM8983_SOFTMUTE);\r\nsnd_soc_update_bits(codec, WM8983_BIAS_CTRL,\r\nWM8983_BIASCUT, WM8983_BIASCUT);\r\nreturn 0;\r\n}\r\nstatic int wm8983_spi_probe(struct spi_device *spi)\r\n{\r\nstruct wm8983_priv *wm8983;\r\nint ret;\r\nwm8983 = devm_kzalloc(&spi->dev, sizeof *wm8983, GFP_KERNEL);\r\nif (!wm8983)\r\nreturn -ENOMEM;\r\nwm8983->regmap = devm_regmap_init_spi(spi, &wm8983_regmap);\r\nif (IS_ERR(wm8983->regmap)) {\r\nret = PTR_ERR(wm8983->regmap);\r\ndev_err(&spi->dev, "Failed to init regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nspi_set_drvdata(spi, wm8983);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_wm8983, &wm8983_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8983_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}\r\nstatic int wm8983_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8983_priv *wm8983;\r\nint ret;\r\nwm8983 = devm_kzalloc(&i2c->dev, sizeof *wm8983, GFP_KERNEL);\r\nif (!wm8983)\r\nreturn -ENOMEM;\r\nwm8983->regmap = devm_regmap_init_i2c(i2c, &wm8983_regmap);\r\nif (IS_ERR(wm8983->regmap)) {\r\nret = PTR_ERR(wm8983->regmap);\r\ndev_err(&i2c->dev, "Failed to init regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, wm8983);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8983, &wm8983_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8983_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init wm8983_modinit(void)\r\n{\r\nint ret = 0;\r\n#if IS_ENABLED(CONFIG_I2C)\r\nret = i2c_add_driver(&wm8983_i2c_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed to register wm8983 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&wm8983_spi_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8983 SPI driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8983_exit(void)\r\n{\r\n#if IS_ENABLED(CONFIG_I2C)\r\ni2c_del_driver(&wm8983_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&wm8983_spi_driver);\r\n#endif\r\n}
