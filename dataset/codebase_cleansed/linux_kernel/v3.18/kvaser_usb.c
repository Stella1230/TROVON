static inline int kvaser_usb_send_msg(const struct kvaser_usb *dev,\r\nstruct kvaser_msg *msg)\r\n{\r\nint actual_len;\r\nreturn usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->bulk_out->bEndpointAddress),\r\nmsg, msg->len, &actual_len,\r\nUSB_SEND_TIMEOUT);\r\n}\r\nstatic int kvaser_usb_wait_msg(const struct kvaser_usb *dev, u8 id,\r\nstruct kvaser_msg *msg)\r\n{\r\nstruct kvaser_msg *tmp;\r\nvoid *buf;\r\nint actual_len;\r\nint err;\r\nint pos;\r\nunsigned long to = jiffies + msecs_to_jiffies(USB_RECV_TIMEOUT);\r\nbuf = kzalloc(RX_BUFFER_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ndo {\r\nerr = usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in->bEndpointAddress),\r\nbuf, RX_BUFFER_SIZE, &actual_len,\r\nUSB_RECV_TIMEOUT);\r\nif (err < 0)\r\ngoto end;\r\npos = 0;\r\nwhile (pos <= actual_len - MSG_HEADER_LEN) {\r\ntmp = buf + pos;\r\nif (!tmp->len)\r\nbreak;\r\nif (pos + tmp->len > actual_len) {\r\ndev_err(dev->udev->dev.parent,\r\n"Format error\n");\r\nbreak;\r\n}\r\nif (tmp->id == id) {\r\nmemcpy(msg, tmp, tmp->len);\r\ngoto end;\r\n}\r\npos += tmp->len;\r\n}\r\n} while (time_before(jiffies, to));\r\nerr = -EINVAL;\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int kvaser_usb_send_simple_msg(const struct kvaser_usb *dev,\r\nu8 msg_id, int channel)\r\n{\r\nstruct kvaser_msg *msg;\r\nint rc;\r\nmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = msg_id;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_simple);\r\nmsg->u.simple.channel = channel;\r\nmsg->u.simple.tid = 0xff;\r\nrc = kvaser_usb_send_msg(dev, msg);\r\nkfree(msg);\r\nreturn rc;\r\n}\r\nstatic int kvaser_usb_get_software_info(struct kvaser_usb *dev)\r\n{\r\nstruct kvaser_msg msg;\r\nint err;\r\nerr = kvaser_usb_send_simple_msg(dev, CMD_GET_SOFTWARE_INFO, 0);\r\nif (err)\r\nreturn err;\r\nerr = kvaser_usb_wait_msg(dev, CMD_GET_SOFTWARE_INFO_REPLY, &msg);\r\nif (err)\r\nreturn err;\r\ndev->fw_version = le32_to_cpu(msg.u.softinfo.fw_version);\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_get_card_info(struct kvaser_usb *dev)\r\n{\r\nstruct kvaser_msg msg;\r\nint err;\r\nerr = kvaser_usb_send_simple_msg(dev, CMD_GET_CARD_INFO, 0);\r\nif (err)\r\nreturn err;\r\nerr = kvaser_usb_wait_msg(dev, CMD_GET_CARD_INFO_REPLY, &msg);\r\nif (err)\r\nreturn err;\r\ndev->nchannels = msg.u.cardinfo.nchannels;\r\nif (dev->nchannels > MAX_NET_DEVICES)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_tx_acknowledge(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct net_device_stats *stats;\r\nstruct kvaser_usb_tx_urb_context *context;\r\nstruct kvaser_usb_net_priv *priv;\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nu8 channel = msg->u.tx_acknowledge.channel;\r\nu8 tid = msg->u.tx_acknowledge.tid;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\nif (!netif_device_present(priv->netdev))\r\nreturn;\r\nstats = &priv->netdev->stats;\r\ncontext = &priv->tx_contexts[tid % MAX_TX_URBS];\r\nif (priv->can.restart_ms &&\r\n(priv->can.state >= CAN_STATE_BUS_OFF)) {\r\nskb = alloc_can_err_skb(priv->netdev, &cf);\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_RESTARTED;\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n} else {\r\nnetdev_err(priv->netdev,\r\n"No memory left for err_skb\n");\r\n}\r\npriv->can.can_stats.restarts++;\r\nnetif_carrier_on(priv->netdev);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nstats->tx_packets++;\r\nstats->tx_bytes += context->dlc;\r\ncan_get_echo_skb(priv->netdev, context->echo_index);\r\ncontext->echo_index = MAX_TX_URBS;\r\natomic_dec(&priv->active_tx_urbs);\r\nnetif_wake_queue(priv->netdev);\r\n}\r\nstatic void kvaser_usb_simple_msg_callback(struct urb *urb)\r\n{\r\nstruct net_device *netdev = urb->context;\r\nkfree(urb->transfer_buffer);\r\nif (urb->status)\r\nnetdev_warn(netdev, "urb status received: %d\n",\r\nurb->status);\r\n}\r\nstatic int kvaser_usb_simple_msg_async(struct kvaser_usb_net_priv *priv,\r\nu8 msg_id)\r\n{\r\nstruct kvaser_usb *dev = priv->dev;\r\nstruct net_device *netdev = priv->netdev;\r\nstruct kvaser_msg *msg;\r\nstruct urb *urb;\r\nvoid *buf;\r\nint err;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_err(netdev, "No memory left for URBs\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = kmalloc(sizeof(struct kvaser_msg), GFP_ATOMIC);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nmsg = (struct kvaser_msg *)buf;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_simple);\r\nmsg->id = msg_id;\r\nmsg->u.simple.channel = priv->channel;\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->bulk_out->bEndpointAddress),\r\nbuf, msg->len,\r\nkvaser_usb_simple_msg_callback, priv);\r\nusb_anchor_urb(urb, &priv->tx_submitted);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\nnetdev_err(netdev, "Error transmitting URB\n");\r\nusb_unanchor_urb(urb);\r\nusb_free_urb(urb);\r\nkfree(buf);\r\nreturn err;\r\n}\r\nusb_free_urb(urb);\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_unlink_tx_urbs(struct kvaser_usb_net_priv *priv)\r\n{\r\nint i;\r\nusb_kill_anchored_urbs(&priv->tx_submitted);\r\natomic_set(&priv->active_tx_urbs, 0);\r\nfor (i = 0; i < MAX_TX_URBS; i++)\r\npriv->tx_contexts[i].echo_index = MAX_TX_URBS;\r\n}\r\nstatic void kvaser_usb_rx_error(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats;\r\nstruct kvaser_usb_net_priv *priv;\r\nunsigned int new_state;\r\nu8 channel, status, txerr, rxerr, error_factor;\r\nswitch (msg->id) {\r\ncase CMD_CAN_ERROR_EVENT:\r\nchannel = msg->u.error_event.channel;\r\nstatus = msg->u.error_event.status;\r\ntxerr = msg->u.error_event.tx_errors_count;\r\nrxerr = msg->u.error_event.rx_errors_count;\r\nerror_factor = msg->u.error_event.error_factor;\r\nbreak;\r\ncase CMD_LOG_MESSAGE:\r\nchannel = msg->u.log_message.channel;\r\nstatus = msg->u.log_message.data[0];\r\ntxerr = msg->u.log_message.data[2];\r\nrxerr = msg->u.log_message.data[3];\r\nerror_factor = msg->u.log_message.data[1];\r\nbreak;\r\ncase CMD_CHIP_STATE_EVENT:\r\nchannel = msg->u.chip_state_event.channel;\r\nstatus = msg->u.chip_state_event.status;\r\ntxerr = msg->u.chip_state_event.tx_errors_count;\r\nrxerr = msg->u.chip_state_event.rx_errors_count;\r\nerror_factor = 0;\r\nbreak;\r\ndefault:\r\ndev_err(dev->udev->dev.parent, "Invalid msg id (%d)\n",\r\nmsg->id);\r\nreturn;\r\n}\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\nstats = &priv->netdev->stats;\r\nif (status & M16C_STATE_BUS_RESET) {\r\nkvaser_usb_unlink_tx_urbs(priv);\r\nreturn;\r\n}\r\nskb = alloc_can_err_skb(priv->netdev, &cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nnew_state = priv->can.state;\r\nnetdev_dbg(priv->netdev, "Error status: 0x%02x\n", status);\r\nif (status & M16C_STATE_BUS_OFF) {\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\npriv->can.can_stats.bus_off++;\r\nif (!priv->can.restart_ms)\r\nkvaser_usb_simple_msg_async(priv, CMD_STOP_CHIP);\r\nnetif_carrier_off(priv->netdev);\r\nnew_state = CAN_STATE_BUS_OFF;\r\n} else if (status & M16C_STATE_BUS_PASSIVE) {\r\nif (priv->can.state != CAN_STATE_ERROR_PASSIVE) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (txerr || rxerr)\r\ncf->data[1] = (txerr > rxerr)\r\n? CAN_ERR_CRTL_TX_PASSIVE\r\n: CAN_ERR_CRTL_RX_PASSIVE;\r\nelse\r\ncf->data[1] = CAN_ERR_CRTL_TX_PASSIVE |\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\npriv->can.can_stats.error_passive++;\r\n}\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\n}\r\nif (status == M16C_STATE_BUS_ERROR) {\r\nif ((priv->can.state < CAN_STATE_ERROR_WARNING) &&\r\n((txerr >= 96) || (rxerr >= 96))) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (txerr > rxerr)\r\n? CAN_ERR_CRTL_TX_WARNING\r\n: CAN_ERR_CRTL_RX_WARNING;\r\npriv->can.can_stats.error_warning++;\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\n} else if (priv->can.state > CAN_STATE_ERROR_ACTIVE) {\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_ACTIVE;\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\n}\r\nif (!status) {\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_ACTIVE;\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nif (priv->can.restart_ms &&\r\n(priv->can.state >= CAN_STATE_BUS_OFF) &&\r\n(new_state < CAN_STATE_BUS_OFF)) {\r\ncf->can_id |= CAN_ERR_RESTARTED;\r\nnetif_carrier_on(priv->netdev);\r\npriv->can.can_stats.restarts++;\r\n}\r\nif (error_factor) {\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\ncf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\r\nif (error_factor & M16C_EF_ACKE)\r\ncf->data[3] |= (CAN_ERR_PROT_LOC_ACK);\r\nif (error_factor & M16C_EF_CRCE)\r\ncf->data[3] |= (CAN_ERR_PROT_LOC_CRC_SEQ |\r\nCAN_ERR_PROT_LOC_CRC_DEL);\r\nif (error_factor & M16C_EF_FORME)\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nif (error_factor & M16C_EF_STFE)\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nif (error_factor & M16C_EF_BITE0)\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\nif (error_factor & M16C_EF_BITE1)\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\nif (error_factor & M16C_EF_TRE)\r\ncf->data[2] |= CAN_ERR_PROT_TX;\r\n}\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\npriv->bec.txerr = txerr;\r\npriv->bec.rxerr = rxerr;\r\npriv->can.state = new_state;\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\nstatic void kvaser_usb_rx_can_err(const struct kvaser_usb_net_priv *priv,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nif (msg->u.rx_can.flag & (MSG_FLAG_ERROR_FRAME |\r\nMSG_FLAG_NERR)) {\r\nnetdev_err(priv->netdev, "Unknow error (flags: 0x%02x)\n",\r\nmsg->u.rx_can.flag);\r\nstats->rx_errors++;\r\nreturn;\r\n}\r\nif (msg->u.rx_can.flag & MSG_FLAG_OVERRUN) {\r\nskb = alloc_can_err_skb(priv->netdev, &cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\n}\r\nstatic void kvaser_usb_rx_can_msg(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct kvaser_usb_net_priv *priv;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats;\r\nu8 channel = msg->u.rx_can.channel;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\nstats = &priv->netdev->stats;\r\nif ((msg->u.rx_can.flag & MSG_FLAG_ERROR_FRAME) &&\r\n(msg->id == CMD_LOG_MESSAGE)) {\r\nkvaser_usb_rx_error(dev, msg);\r\nreturn;\r\n} else if (msg->u.rx_can.flag & (MSG_FLAG_ERROR_FRAME |\r\nMSG_FLAG_NERR |\r\nMSG_FLAG_OVERRUN)) {\r\nkvaser_usb_rx_can_err(priv, msg);\r\nreturn;\r\n} else if (msg->u.rx_can.flag & ~MSG_FLAG_REMOTE_FRAME) {\r\nnetdev_warn(priv->netdev,\r\n"Unhandled frame (flags: 0x%02x)",\r\nmsg->u.rx_can.flag);\r\nreturn;\r\n}\r\nskb = alloc_can_skb(priv->netdev, &cf);\r\nif (!skb) {\r\nstats->tx_dropped++;\r\nreturn;\r\n}\r\nif (msg->id == CMD_LOG_MESSAGE) {\r\ncf->can_id = le32_to_cpu(msg->u.log_message.id);\r\nif (cf->can_id & KVASER_EXTENDED_FRAME)\r\ncf->can_id &= CAN_EFF_MASK | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id &= CAN_SFF_MASK;\r\ncf->can_dlc = get_can_dlc(msg->u.log_message.dlc);\r\nif (msg->u.log_message.flags & MSG_FLAG_REMOTE_FRAME)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(cf->data, &msg->u.log_message.data,\r\ncf->can_dlc);\r\n} else {\r\ncf->can_id = ((msg->u.rx_can.msg[0] & 0x1f) << 6) |\r\n(msg->u.rx_can.msg[1] & 0x3f);\r\nif (msg->id == CMD_RX_EXT_MESSAGE) {\r\ncf->can_id <<= 18;\r\ncf->can_id |= ((msg->u.rx_can.msg[2] & 0x0f) << 14) |\r\n((msg->u.rx_can.msg[3] & 0xff) << 6) |\r\n(msg->u.rx_can.msg[4] & 0x3f);\r\ncf->can_id |= CAN_EFF_FLAG;\r\n}\r\ncf->can_dlc = get_can_dlc(msg->u.rx_can.msg[5]);\r\nif (msg->u.rx_can.flag & MSG_FLAG_REMOTE_FRAME)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(cf->data, &msg->u.rx_can.msg[6],\r\ncf->can_dlc);\r\n}\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\nstatic void kvaser_usb_start_chip_reply(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct kvaser_usb_net_priv *priv;\r\nu8 channel = msg->u.simple.channel;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\nif (completion_done(&priv->start_comp) &&\r\nnetif_queue_stopped(priv->netdev)) {\r\nnetif_wake_queue(priv->netdev);\r\n} else {\r\nnetif_start_queue(priv->netdev);\r\ncomplete(&priv->start_comp);\r\n}\r\n}\r\nstatic void kvaser_usb_stop_chip_reply(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct kvaser_usb_net_priv *priv;\r\nu8 channel = msg->u.simple.channel;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\ncomplete(&priv->stop_comp);\r\n}\r\nstatic void kvaser_usb_handle_message(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nswitch (msg->id) {\r\ncase CMD_START_CHIP_REPLY:\r\nkvaser_usb_start_chip_reply(dev, msg);\r\nbreak;\r\ncase CMD_STOP_CHIP_REPLY:\r\nkvaser_usb_stop_chip_reply(dev, msg);\r\nbreak;\r\ncase CMD_RX_STD_MESSAGE:\r\ncase CMD_RX_EXT_MESSAGE:\r\ncase CMD_LOG_MESSAGE:\r\nkvaser_usb_rx_can_msg(dev, msg);\r\nbreak;\r\ncase CMD_CHIP_STATE_EVENT:\r\ncase CMD_CAN_ERROR_EVENT:\r\nkvaser_usb_rx_error(dev, msg);\r\nbreak;\r\ncase CMD_TX_ACKNOWLEDGE:\r\nkvaser_usb_tx_acknowledge(dev, msg);\r\nbreak;\r\ndefault:\r\ndev_warn(dev->udev->dev.parent,\r\n"Unhandled message (%d)\n", msg->id);\r\nbreak;\r\n}\r\n}\r\nstatic void kvaser_usb_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct kvaser_usb *dev = urb->context;\r\nstruct kvaser_msg *msg;\r\nint pos = 0;\r\nint err, i;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_info(dev->udev->dev.parent, "Rx URB aborted (%d)\n",\r\nurb->status);\r\ngoto resubmit_urb;\r\n}\r\nwhile (pos <= urb->actual_length - MSG_HEADER_LEN) {\r\nmsg = urb->transfer_buffer + pos;\r\nif (!msg->len)\r\nbreak;\r\nif (pos + msg->len > urb->actual_length) {\r\ndev_err(dev->udev->dev.parent, "Format error\n");\r\nbreak;\r\n}\r\nkvaser_usb_handle_message(dev, msg);\r\npos += msg->len;\r\n}\r\nresubmit_urb:\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in->bEndpointAddress),\r\nurb->transfer_buffer, RX_BUFFER_SIZE,\r\nkvaser_usb_read_bulk_callback, dev);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err == -ENODEV) {\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nif (!dev->nets[i])\r\ncontinue;\r\nnetif_device_detach(dev->nets[i]->netdev);\r\n}\r\n} else if (err) {\r\ndev_err(dev->udev->dev.parent,\r\n"Failed resubmitting read bulk urb: %d\n", err);\r\n}\r\nreturn;\r\n}\r\nstatic int kvaser_usb_setup_rx_urbs(struct kvaser_usb *dev)\r\n{\r\nint i, err = 0;\r\nif (dev->rxinitdone)\r\nreturn 0;\r\nfor (i = 0; i < MAX_RX_URBS; i++) {\r\nstruct urb *urb = NULL;\r\nu8 *buf = NULL;\r\ndma_addr_t buf_dma;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_warn(dev->udev->dev.parent,\r\n"No memory left for URBs\n");\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev, RX_BUFFER_SIZE,\r\nGFP_KERNEL, &buf_dma);\r\nif (!buf) {\r\ndev_warn(dev->udev->dev.parent,\r\n"No memory left for USB buffer\n");\r\nusb_free_urb(urb);\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in->bEndpointAddress),\r\nbuf, RX_BUFFER_SIZE,\r\nkvaser_usb_read_bulk_callback,\r\ndev);\r\nurb->transfer_dma = buf_dma;\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &dev->rx_submitted);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(dev->udev, RX_BUFFER_SIZE, buf,\r\nbuf_dma);\r\nusb_free_urb(urb);\r\nbreak;\r\n}\r\ndev->rxbuf[i] = buf;\r\ndev->rxbuf_dma[i] = buf_dma;\r\nusb_free_urb(urb);\r\n}\r\nif (i == 0) {\r\ndev_warn(dev->udev->dev.parent,\r\n"Cannot setup read URBs, error %d\n", err);\r\nreturn err;\r\n} else if (i < MAX_RX_URBS) {\r\ndev_warn(dev->udev->dev.parent,\r\n"RX performances may be slow\n");\r\n}\r\ndev->rxinitdone = true;\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_set_opt_mode(const struct kvaser_usb_net_priv *priv)\r\n{\r\nstruct kvaser_msg *msg;\r\nint rc;\r\nmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = CMD_SET_CTRL_MODE;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_ctrl_mode);\r\nmsg->u.ctrl_mode.tid = 0xff;\r\nmsg->u.ctrl_mode.channel = priv->channel;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nmsg->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\r\nelse\r\nmsg->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\r\nrc = kvaser_usb_send_msg(priv->dev, msg);\r\nkfree(msg);\r\nreturn rc;\r\n}\r\nstatic int kvaser_usb_start_chip(struct kvaser_usb_net_priv *priv)\r\n{\r\nint err;\r\ninit_completion(&priv->start_comp);\r\nerr = kvaser_usb_send_simple_msg(priv->dev, CMD_START_CHIP,\r\npriv->channel);\r\nif (err)\r\nreturn err;\r\nif (!wait_for_completion_timeout(&priv->start_comp,\r\nmsecs_to_jiffies(START_TIMEOUT)))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_open(struct net_device *netdev)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nstruct kvaser_usb *dev = priv->dev;\r\nint err;\r\nerr = open_candev(netdev);\r\nif (err)\r\nreturn err;\r\nerr = kvaser_usb_setup_rx_urbs(dev);\r\nif (err)\r\ngoto error;\r\nerr = kvaser_usb_set_opt_mode(priv);\r\nif (err)\r\ngoto error;\r\nerr = kvaser_usb_start_chip(priv);\r\nif (err) {\r\nnetdev_warn(netdev, "Cannot start device, error %d\n", err);\r\ngoto error;\r\n}\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\nerror:\r\nclose_candev(netdev);\r\nreturn err;\r\n}\r\nstatic void kvaser_usb_unlink_all_urbs(struct kvaser_usb *dev)\r\n{\r\nint i;\r\nusb_kill_anchored_urbs(&dev->rx_submitted);\r\nfor (i = 0; i < MAX_RX_URBS; i++)\r\nusb_free_coherent(dev->udev, RX_BUFFER_SIZE,\r\ndev->rxbuf[i],\r\ndev->rxbuf_dma[i]);\r\nfor (i = 0; i < MAX_NET_DEVICES; i++) {\r\nstruct kvaser_usb_net_priv *priv = dev->nets[i];\r\nif (priv)\r\nkvaser_usb_unlink_tx_urbs(priv);\r\n}\r\n}\r\nstatic int kvaser_usb_stop_chip(struct kvaser_usb_net_priv *priv)\r\n{\r\nint err;\r\ninit_completion(&priv->stop_comp);\r\nerr = kvaser_usb_send_simple_msg(priv->dev, CMD_STOP_CHIP,\r\npriv->channel);\r\nif (err)\r\nreturn err;\r\nif (!wait_for_completion_timeout(&priv->stop_comp,\r\nmsecs_to_jiffies(STOP_TIMEOUT)))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_flush_queue(struct kvaser_usb_net_priv *priv)\r\n{\r\nstruct kvaser_msg *msg;\r\nint rc;\r\nmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = CMD_FLUSH_QUEUE;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_flush_queue);\r\nmsg->u.flush_queue.channel = priv->channel;\r\nmsg->u.flush_queue.flags = 0x00;\r\nrc = kvaser_usb_send_msg(priv->dev, msg);\r\nkfree(msg);\r\nreturn rc;\r\n}\r\nstatic int kvaser_usb_close(struct net_device *netdev)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nstruct kvaser_usb *dev = priv->dev;\r\nint err;\r\nnetif_stop_queue(netdev);\r\nerr = kvaser_usb_flush_queue(priv);\r\nif (err)\r\nnetdev_warn(netdev, "Cannot flush queue, error %d\n", err);\r\nif (kvaser_usb_send_simple_msg(dev, CMD_RESET_CHIP, priv->channel))\r\nnetdev_warn(netdev, "Cannot reset card, error %d\n", err);\r\nerr = kvaser_usb_stop_chip(priv);\r\nif (err)\r\nnetdev_warn(netdev, "Cannot stop device, error %d\n", err);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nclose_candev(priv->netdev);\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct kvaser_usb_tx_urb_context *context = urb->context;\r\nstruct kvaser_usb_net_priv *priv;\r\nstruct net_device *netdev;\r\nif (WARN_ON(!context))\r\nreturn;\r\npriv = context->priv;\r\nnetdev = priv->netdev;\r\nkfree(urb->transfer_buffer);\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nif (urb->status)\r\nnetdev_info(netdev, "Tx URB aborted (%d)\n", urb->status);\r\n}\r\nstatic netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nstruct kvaser_usb *dev = priv->dev;\r\nstruct net_device_stats *stats = &netdev->stats;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nstruct kvaser_usb_tx_urb_context *context = NULL;\r\nstruct urb *urb;\r\nvoid *buf;\r\nstruct kvaser_msg *msg;\r\nint i, err;\r\nint ret = NETDEV_TX_OK;\r\nif (can_dropped_invalid_skb(netdev, skb))\r\nreturn NETDEV_TX_OK;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_err(netdev, "No memory left for URBs\n");\r\nstats->tx_dropped++;\r\ngoto nourbmem;\r\n}\r\nbuf = kmalloc(sizeof(struct kvaser_msg), GFP_ATOMIC);\r\nif (!buf) {\r\nstats->tx_dropped++;\r\ngoto nobufmem;\r\n}\r\nmsg = buf;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_tx_can);\r\nmsg->u.tx_can.flags = 0;\r\nmsg->u.tx_can.channel = priv->channel;\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nmsg->id = CMD_TX_EXT_MESSAGE;\r\nmsg->u.tx_can.msg[0] = (cf->can_id >> 24) & 0x1f;\r\nmsg->u.tx_can.msg[1] = (cf->can_id >> 18) & 0x3f;\r\nmsg->u.tx_can.msg[2] = (cf->can_id >> 14) & 0x0f;\r\nmsg->u.tx_can.msg[3] = (cf->can_id >> 6) & 0xff;\r\nmsg->u.tx_can.msg[4] = cf->can_id & 0x3f;\r\n} else {\r\nmsg->id = CMD_TX_STD_MESSAGE;\r\nmsg->u.tx_can.msg[0] = (cf->can_id >> 6) & 0x1f;\r\nmsg->u.tx_can.msg[1] = cf->can_id & 0x3f;\r\n}\r\nmsg->u.tx_can.msg[5] = cf->can_dlc;\r\nmemcpy(&msg->u.tx_can.msg[6], cf->data, cf->can_dlc);\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nmsg->u.tx_can.flags |= MSG_FLAG_REMOTE_FRAME;\r\nfor (i = 0; i < ARRAY_SIZE(priv->tx_contexts); i++) {\r\nif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\r\ncontext = &priv->tx_contexts[i];\r\nbreak;\r\n}\r\n}\r\nif (!context) {\r\nnetdev_warn(netdev, "cannot find free context\n");\r\nret = NETDEV_TX_BUSY;\r\ngoto releasebuf;\r\n}\r\ncontext->priv = priv;\r\ncontext->echo_index = i;\r\ncontext->dlc = cf->can_dlc;\r\nmsg->u.tx_can.tid = context->echo_index;\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->bulk_out->bEndpointAddress),\r\nbuf, msg->len,\r\nkvaser_usb_write_bulk_callback, context);\r\nusb_anchor_urb(urb, &priv->tx_submitted);\r\ncan_put_echo_skb(skb, netdev, context->echo_index);\r\natomic_inc(&priv->active_tx_urbs);\r\nif (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\r\nnetif_stop_queue(netdev);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(err)) {\r\ncan_free_echo_skb(netdev, context->echo_index);\r\nskb = NULL;\r\natomic_dec(&priv->active_tx_urbs);\r\nusb_unanchor_urb(urb);\r\nstats->tx_dropped++;\r\nif (err == -ENODEV)\r\nnetif_device_detach(netdev);\r\nelse\r\nnetdev_warn(netdev, "Failed tx_urb %d\n", err);\r\ngoto releasebuf;\r\n}\r\nusb_free_urb(urb);\r\nreturn NETDEV_TX_OK;\r\nreleasebuf:\r\nkfree(buf);\r\nnobufmem:\r\nusb_free_urb(urb);\r\nnourbmem:\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int kvaser_usb_set_bittiming(struct net_device *netdev)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nstruct kvaser_usb *dev = priv->dev;\r\nstruct kvaser_msg *msg;\r\nint rc;\r\nmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = CMD_SET_BUS_PARAMS;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_busparams);\r\nmsg->u.busparams.channel = priv->channel;\r\nmsg->u.busparams.tid = 0xff;\r\nmsg->u.busparams.bitrate = cpu_to_le32(bt->bitrate);\r\nmsg->u.busparams.sjw = bt->sjw;\r\nmsg->u.busparams.tseg1 = bt->prop_seg + bt->phase_seg1;\r\nmsg->u.busparams.tseg2 = bt->phase_seg2;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nmsg->u.busparams.no_samp = 3;\r\nelse\r\nmsg->u.busparams.no_samp = 1;\r\nrc = kvaser_usb_send_msg(dev, msg);\r\nkfree(msg);\r\nreturn rc;\r\n}\r\nstatic int kvaser_usb_set_mode(struct net_device *netdev,\r\nenum can_mode mode)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nint err;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nerr = kvaser_usb_simple_msg_async(priv, CMD_START_CHIP);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_get_berr_counter(const struct net_device *netdev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\n*bec = priv->bec;\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_remove_interfaces(struct kvaser_usb *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nif (!dev->nets[i])\r\ncontinue;\r\nunregister_netdev(dev->nets[i]->netdev);\r\n}\r\nkvaser_usb_unlink_all_urbs(dev);\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nif (!dev->nets[i])\r\ncontinue;\r\nfree_candev(dev->nets[i]->netdev);\r\n}\r\n}\r\nstatic int kvaser_usb_init_one(struct usb_interface *intf,\r\nconst struct usb_device_id *id, int channel)\r\n{\r\nstruct kvaser_usb *dev = usb_get_intfdata(intf);\r\nstruct net_device *netdev;\r\nstruct kvaser_usb_net_priv *priv;\r\nint i, err;\r\nnetdev = alloc_candev(sizeof(*priv), MAX_TX_URBS);\r\nif (!netdev) {\r\ndev_err(&intf->dev, "Cannot alloc candev\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = netdev_priv(netdev);\r\ninit_completion(&priv->start_comp);\r\ninit_completion(&priv->stop_comp);\r\ninit_usb_anchor(&priv->tx_submitted);\r\natomic_set(&priv->active_tx_urbs, 0);\r\nfor (i = 0; i < ARRAY_SIZE(priv->tx_contexts); i++)\r\npriv->tx_contexts[i].echo_index = MAX_TX_URBS;\r\npriv->dev = dev;\r\npriv->netdev = netdev;\r\npriv->channel = channel;\r\npriv->can.state = CAN_STATE_STOPPED;\r\npriv->can.clock.freq = CAN_USB_CLOCK;\r\npriv->can.bittiming_const = &kvaser_usb_bittiming_const;\r\npriv->can.do_set_bittiming = kvaser_usb_set_bittiming;\r\npriv->can.do_set_mode = kvaser_usb_set_mode;\r\nif (id->driver_info & KVASER_HAS_TXRX_ERRORS)\r\npriv->can.do_get_berr_counter = kvaser_usb_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\nif (id->driver_info & KVASER_HAS_SILENT_MODE)\r\npriv->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\r\nnetdev->flags |= IFF_ECHO;\r\nnetdev->netdev_ops = &kvaser_usb_netdev_ops;\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nnetdev->dev_id = channel;\r\ndev->nets[channel] = priv;\r\nerr = register_candev(netdev);\r\nif (err) {\r\ndev_err(&intf->dev, "Failed to register can device\n");\r\nfree_candev(netdev);\r\ndev->nets[channel] = NULL;\r\nreturn err;\r\n}\r\nnetdev_dbg(netdev, "device registered\n");\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_get_endpoints(const struct usb_interface *intf,\r\nstruct usb_endpoint_descriptor **in,\r\nstruct usb_endpoint_descriptor **out)\r\n{\r\nconst struct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\niface_desc = &intf->altsetting[0];\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!*in && usb_endpoint_is_bulk_in(endpoint))\r\n*in = endpoint;\r\nif (!*out && usb_endpoint_is_bulk_out(endpoint))\r\n*out = endpoint;\r\nif (*in && *out)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int kvaser_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct kvaser_usb *dev;\r\nint err = -ENOMEM;\r\nint i;\r\ndev = devm_kzalloc(&intf->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nerr = kvaser_usb_get_endpoints(intf, &dev->bulk_in, &dev->bulk_out);\r\nif (err) {\r\ndev_err(&intf->dev, "Cannot get usb endpoint(s)");\r\nreturn err;\r\n}\r\ndev->udev = interface_to_usbdev(intf);\r\ninit_usb_anchor(&dev->rx_submitted);\r\nusb_set_intfdata(intf, dev);\r\nfor (i = 0; i < MAX_NET_DEVICES; i++)\r\nkvaser_usb_send_simple_msg(dev, CMD_RESET_CHIP, i);\r\nerr = kvaser_usb_get_software_info(dev);\r\nif (err) {\r\ndev_err(&intf->dev,\r\n"Cannot get software infos, error %d\n", err);\r\nreturn err;\r\n}\r\nerr = kvaser_usb_get_card_info(dev);\r\nif (err) {\r\ndev_err(&intf->dev,\r\n"Cannot get card infos, error %d\n", err);\r\nreturn err;\r\n}\r\ndev_dbg(&intf->dev, "Firmware version: %d.%d.%d\n",\r\n((dev->fw_version >> 24) & 0xff),\r\n((dev->fw_version >> 16) & 0xff),\r\n(dev->fw_version & 0xffff));\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nerr = kvaser_usb_init_one(intf, id, i);\r\nif (err) {\r\nkvaser_usb_remove_interfaces(dev);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct kvaser_usb *dev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (!dev)\r\nreturn;\r\nkvaser_usb_remove_interfaces(dev);\r\n}
