static void _omap3_dpll_write_clken(struct clk_hw_omap *clk, u8 clken_bits)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\ndd = clk->dpll_data;\r\nv = omap2_clk_readl(clk, dd->control_reg);\r\nv &= ~dd->enable_mask;\r\nv |= clken_bits << __ffs(dd->enable_mask);\r\nomap2_clk_writel(v, clk, dd->control_reg);\r\n}\r\nstatic int _omap3_wait_dpll_status(struct clk_hw_omap *clk, u8 state)\r\n{\r\nconst struct dpll_data *dd;\r\nint i = 0;\r\nint ret = -EINVAL;\r\nconst char *clk_name;\r\ndd = clk->dpll_data;\r\nclk_name = __clk_get_name(clk->hw.clk);\r\nstate <<= __ffs(dd->idlest_mask);\r\nwhile (((omap2_clk_readl(clk, dd->idlest_reg) & dd->idlest_mask)\r\n!= state) && i < MAX_DPLL_WAIT_TRIES) {\r\ni++;\r\nudelay(1);\r\n}\r\nif (i == MAX_DPLL_WAIT_TRIES) {\r\nprintk(KERN_ERR "clock: %s failed transition to '%s'\n",\r\nclk_name, (state) ? "locked" : "bypassed");\r\n} else {\r\npr_debug("clock: %s transition to '%s' in %d loops\n",\r\nclk_name, (state) ? "locked" : "bypassed", i);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic u16 _omap3_dpll_compute_freqsel(struct clk_hw_omap *clk, u8 n)\r\n{\r\nunsigned long fint;\r\nu16 f = 0;\r\nfint = __clk_get_rate(clk->dpll_data->clk_ref) / n;\r\npr_debug("clock: fint is %lu\n", fint);\r\nif (fint >= 750000 && fint <= 1000000)\r\nf = 0x3;\r\nelse if (fint > 1000000 && fint <= 1250000)\r\nf = 0x4;\r\nelse if (fint > 1250000 && fint <= 1500000)\r\nf = 0x5;\r\nelse if (fint > 1500000 && fint <= 1750000)\r\nf = 0x6;\r\nelse if (fint > 1750000 && fint <= 2100000)\r\nf = 0x7;\r\nelse if (fint > 7500000 && fint <= 10000000)\r\nf = 0xB;\r\nelse if (fint > 10000000 && fint <= 12500000)\r\nf = 0xC;\r\nelse if (fint > 12500000 && fint <= 15000000)\r\nf = 0xD;\r\nelse if (fint > 15000000 && fint <= 17500000)\r\nf = 0xE;\r\nelse if (fint > 17500000 && fint <= 21000000)\r\nf = 0xF;\r\nelse\r\npr_debug("clock: unknown freqsel setting for %d\n", n);\r\nreturn f;\r\n}\r\nstatic int _omap3_noncore_dpll_lock(struct clk_hw_omap *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu8 ai;\r\nu8 state = 1;\r\nint r = 0;\r\npr_debug("clock: locking DPLL %s\n", __clk_get_name(clk->hw.clk));\r\ndd = clk->dpll_data;\r\nstate <<= __ffs(dd->idlest_mask);\r\nif ((omap2_clk_readl(clk, dd->idlest_reg) & dd->idlest_mask) == state)\r\ngoto done;\r\nai = omap3_dpll_autoidle_read(clk);\r\nif (ai)\r\nomap3_dpll_deny_idle(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOCKED);\r\nr = _omap3_wait_dpll_status(clk, 1);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\ndone:\r\nreturn r;\r\n}\r\nstatic int _omap3_noncore_dpll_bypass(struct clk_hw_omap *clk)\r\n{\r\nint r;\r\nu8 ai;\r\nif (!(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_BYPASS)))\r\nreturn -EINVAL;\r\npr_debug("clock: configuring DPLL %s for low-power bypass\n",\r\n__clk_get_name(clk->hw.clk));\r\nai = omap3_dpll_autoidle_read(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOW_POWER_BYPASS);\r\nr = _omap3_wait_dpll_status(clk, 0);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\nreturn r;\r\n}\r\nstatic int _omap3_noncore_dpll_stop(struct clk_hw_omap *clk)\r\n{\r\nu8 ai;\r\nif (!(clk->dpll_data->modes & (1 << DPLL_LOW_POWER_STOP)))\r\nreturn -EINVAL;\r\npr_debug("clock: stopping DPLL %s\n", __clk_get_name(clk->hw.clk));\r\nai = omap3_dpll_autoidle_read(clk);\r\n_omap3_dpll_write_clken(clk, DPLL_LOW_POWER_STOP);\r\nif (ai)\r\nomap3_dpll_allow_idle(clk);\r\nreturn 0;\r\n}\r\nstatic void _lookup_dco(struct clk_hw_omap *clk, u8 *dco, u16 m, u8 n)\r\n{\r\nunsigned long fint, clkinp;\r\nclkinp = __clk_get_rate(__clk_get_parent(clk->hw.clk));\r\nfint = (clkinp / n) * m;\r\nif (fint < 1000000000)\r\n*dco = 2;\r\nelse\r\n*dco = 4;\r\n}\r\nstatic void _lookup_sddiv(struct clk_hw_omap *clk, u8 *sd_div, u16 m, u8 n)\r\n{\r\nunsigned long clkinp, sd;\r\nint mod1, mod2;\r\nclkinp = __clk_get_rate(__clk_get_parent(clk->hw.clk));\r\nclkinp /= 100000;\r\nmod1 = (clkinp * m) % (250 * n);\r\nsd = (clkinp * m) / (250 * n);\r\nmod2 = sd % 10;\r\nsd /= 10;\r\nif (mod1 || mod2)\r\nsd++;\r\n*sd_div = sd;\r\n}\r\nstatic int omap3_noncore_dpll_program(struct clk_hw_omap *clk, u16 freqsel)\r\n{\r\nstruct dpll_data *dd = clk->dpll_data;\r\nu8 dco, sd_div;\r\nu32 v;\r\n_omap3_noncore_dpll_bypass(clk);\r\nif (ti_clk_features.flags & TI_CLK_DPLL_HAS_FREQSEL) {\r\nv = omap2_clk_readl(clk, dd->control_reg);\r\nv &= ~dd->freqsel_mask;\r\nv |= freqsel << __ffs(dd->freqsel_mask);\r\nomap2_clk_writel(v, clk, dd->control_reg);\r\n}\r\nv = omap2_clk_readl(clk, dd->mult_div1_reg);\r\nif (dd->dcc_mask) {\r\nif (dd->last_rounded_rate >= dd->dcc_rate)\r\nv |= dd->dcc_mask;\r\nelse\r\nv &= ~dd->dcc_mask;\r\n}\r\nv &= ~(dd->mult_mask | dd->div1_mask);\r\nv |= dd->last_rounded_m << __ffs(dd->mult_mask);\r\nv |= (dd->last_rounded_n - 1) << __ffs(dd->div1_mask);\r\nif (dd->dco_mask) {\r\n_lookup_dco(clk, &dco, dd->last_rounded_m, dd->last_rounded_n);\r\nv &= ~(dd->dco_mask);\r\nv |= dco << __ffs(dd->dco_mask);\r\n}\r\nif (dd->sddiv_mask) {\r\n_lookup_sddiv(clk, &sd_div, dd->last_rounded_m,\r\ndd->last_rounded_n);\r\nv &= ~(dd->sddiv_mask);\r\nv |= sd_div << __ffs(dd->sddiv_mask);\r\n}\r\nomap2_clk_writel(v, clk, dd->mult_div1_reg);\r\nif (dd->m4xen_mask || dd->lpmode_mask) {\r\nv = omap2_clk_readl(clk, dd->control_reg);\r\nif (dd->m4xen_mask) {\r\nif (dd->last_rounded_m4xen)\r\nv |= dd->m4xen_mask;\r\nelse\r\nv &= ~dd->m4xen_mask;\r\n}\r\nif (dd->lpmode_mask) {\r\nif (dd->last_rounded_lpmode)\r\nv |= dd->lpmode_mask;\r\nelse\r\nv &= ~dd->lpmode_mask;\r\n}\r\nomap2_clk_writel(v, clk, dd->control_reg);\r\n}\r\n_omap3_noncore_dpll_lock(clk);\r\nreturn 0;\r\n}\r\nunsigned long omap3_dpll_recalc(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nreturn omap2_get_dpll_rate(clk);\r\n}\r\nint omap3_noncore_dpll_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nint r;\r\nstruct dpll_data *dd;\r\nstruct clk *parent;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\nif (clk->clkdm) {\r\nr = clkdm_clk_enable(clk->clkdm, hw->clk);\r\nif (r) {\r\nWARN(1,\r\n"%s: could not enable %s's clockdomain %s: %d\n",\r\n__func__, __clk_get_name(hw->clk),\r\nclk->clkdm->name, r);\r\nreturn r;\r\n}\r\n}\r\nparent = __clk_get_parent(hw->clk);\r\nif (__clk_get_rate(hw->clk) == __clk_get_rate(dd->clk_bypass)) {\r\nWARN_ON(parent != dd->clk_bypass);\r\nr = _omap3_noncore_dpll_bypass(clk);\r\n} else {\r\nWARN_ON(parent != dd->clk_ref);\r\nr = _omap3_noncore_dpll_lock(clk);\r\n}\r\nreturn r;\r\n}\r\nvoid omap3_noncore_dpll_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\n_omap3_noncore_dpll_stop(clk);\r\nif (clk->clkdm)\r\nclkdm_clk_disable(clk->clkdm, hw->clk);\r\n}\r\nint omap3_noncore_dpll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nstruct clk *new_parent = NULL;\r\nunsigned long rrate;\r\nu16 freqsel = 0;\r\nstruct dpll_data *dd;\r\nint ret;\r\nif (!hw || !rate)\r\nreturn -EINVAL;\r\ndd = clk->dpll_data;\r\nif (!dd)\r\nreturn -EINVAL;\r\nif (__clk_get_rate(dd->clk_bypass) == rate &&\r\n(dd->modes & (1 << DPLL_LOW_POWER_BYPASS))) {\r\npr_debug("%s: %s: set rate: entering bypass.\n",\r\n__func__, __clk_get_name(hw->clk));\r\n__clk_prepare(dd->clk_bypass);\r\nclk_enable(dd->clk_bypass);\r\nret = _omap3_noncore_dpll_bypass(clk);\r\nif (!ret)\r\nnew_parent = dd->clk_bypass;\r\nclk_disable(dd->clk_bypass);\r\n__clk_unprepare(dd->clk_bypass);\r\n} else {\r\n__clk_prepare(dd->clk_ref);\r\nclk_enable(dd->clk_ref);\r\nif (dd->last_rounded_rate != rate) {\r\nrrate = __clk_round_rate(hw->clk, rate);\r\nif (rrate != rate) {\r\npr_warn("%s: %s: final rate %lu does not match desired rate %lu\n",\r\n__func__, __clk_get_name(hw->clk),\r\nrrate, rate);\r\nrate = rrate;\r\n}\r\n}\r\nif (dd->last_rounded_rate == 0)\r\nreturn -EINVAL;\r\nif (ti_clk_features.flags & TI_CLK_DPLL_HAS_FREQSEL) {\r\nfreqsel = _omap3_dpll_compute_freqsel(clk,\r\ndd->last_rounded_n);\r\nWARN_ON(!freqsel);\r\n}\r\npr_debug("%s: %s: set rate: locking rate to %lu.\n",\r\n__func__, __clk_get_name(hw->clk), rate);\r\nret = omap3_noncore_dpll_program(clk, freqsel);\r\nif (!ret)\r\nnew_parent = dd->clk_ref;\r\nclk_disable(dd->clk_ref);\r\n__clk_unprepare(dd->clk_ref);\r\n}\r\nif (!ret && clk_get_parent(hw->clk) != new_parent)\r\n__clk_reparent(hw->clk, new_parent);\r\nreturn 0;\r\n}\r\nu32 omap3_dpll_autoidle_read(struct clk_hw_omap *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn -EINVAL;\r\ndd = clk->dpll_data;\r\nif (!dd->autoidle_reg)\r\nreturn -EINVAL;\r\nv = omap2_clk_readl(clk, dd->autoidle_reg);\r\nv &= dd->autoidle_mask;\r\nv >>= __ffs(dd->autoidle_mask);\r\nreturn v;\r\n}\r\nvoid omap3_dpll_allow_idle(struct clk_hw_omap *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn;\r\ndd = clk->dpll_data;\r\nif (!dd->autoidle_reg)\r\nreturn;\r\nv = omap2_clk_readl(clk, dd->autoidle_reg);\r\nv &= ~dd->autoidle_mask;\r\nv |= DPLL_AUTOIDLE_LOW_POWER_STOP << __ffs(dd->autoidle_mask);\r\nomap2_clk_writel(v, clk, dd->autoidle_reg);\r\n}\r\nvoid omap3_dpll_deny_idle(struct clk_hw_omap *clk)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nif (!clk || !clk->dpll_data)\r\nreturn;\r\ndd = clk->dpll_data;\r\nif (!dd->autoidle_reg)\r\nreturn;\r\nv = omap2_clk_readl(clk, dd->autoidle_reg);\r\nv &= ~dd->autoidle_mask;\r\nv |= DPLL_AUTOIDLE_DISABLE << __ffs(dd->autoidle_mask);\r\nomap2_clk_writel(v, clk, dd->autoidle_reg);\r\n}\r\nstatic struct clk_hw_omap *omap3_find_clkoutx2_dpll(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *pclk = NULL;\r\nstruct clk *parent;\r\ndo {\r\ndo {\r\nparent = __clk_get_parent(hw->clk);\r\nhw = __clk_get_hw(parent);\r\n} while (hw && (__clk_get_flags(hw->clk) & CLK_IS_BASIC));\r\nif (!hw)\r\nbreak;\r\npclk = to_clk_hw_omap(hw);\r\n} while (pclk && !pclk->dpll_data);\r\nif (!pclk) {\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\nreturn pclk;\r\n}\r\nunsigned long omap3_clkoutx2_recalc(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nconst struct dpll_data *dd;\r\nunsigned long rate;\r\nu32 v;\r\nstruct clk_hw_omap *pclk = NULL;\r\nif (!parent_rate)\r\nreturn 0;\r\npclk = omap3_find_clkoutx2_dpll(hw);\r\nif (!pclk)\r\nreturn 0;\r\ndd = pclk->dpll_data;\r\nWARN_ON(!dd->enable_mask);\r\nv = omap2_clk_readl(pclk, dd->control_reg) & dd->enable_mask;\r\nv >>= __ffs(dd->enable_mask);\r\nif ((v != OMAP3XXX_EN_DPLL_LOCKED) || (dd->flags & DPLL_J_TYPE))\r\nrate = parent_rate;\r\nelse\r\nrate = parent_rate * 2;\r\nreturn rate;\r\n}\r\nint omap3_clkoutx2_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn 0;\r\n}\r\nlong omap3_clkoutx2_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nconst struct dpll_data *dd;\r\nu32 v;\r\nstruct clk_hw_omap *pclk = NULL;\r\nif (!*prate)\r\nreturn 0;\r\npclk = omap3_find_clkoutx2_dpll(hw);\r\nif (!pclk)\r\nreturn 0;\r\ndd = pclk->dpll_data;\r\nif (dd->flags & DPLL_J_TYPE) {\r\n*prate = __clk_round_rate(__clk_get_parent(pclk->hw.clk), rate);\r\nreturn *prate;\r\n}\r\nWARN_ON(!dd->enable_mask);\r\nv = omap2_clk_readl(pclk, dd->control_reg) & dd->enable_mask;\r\nv >>= __ffs(dd->enable_mask);\r\nif (v != OMAP3XXX_EN_DPLL_LOCKED)\r\nreturn *prate;\r\nif (__clk_get_flags(hw->clk) & CLK_SET_RATE_PARENT) {\r\nunsigned long best_parent;\r\nbest_parent = (rate / 2);\r\n*prate = __clk_round_rate(__clk_get_parent(hw->clk),\r\nbest_parent);\r\n}\r\nreturn *prate * 2;\r\n}
