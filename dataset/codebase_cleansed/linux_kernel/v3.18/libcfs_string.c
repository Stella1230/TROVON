int cfs_str2mask(const char *str, const char *(*bit2str)(int bit),\r\nint *oldmask, int minmask, int allmask)\r\n{\r\nconst char *debugstr;\r\nchar op = 0;\r\nint newmask = minmask, i, len, found = 0;\r\nwhile (*str != 0) {\r\nwhile (isspace(*str))\r\nstr++;\r\nif (*str == 0)\r\nbreak;\r\nif (*str == '+' || *str == '-') {\r\nop = *str++;\r\nif (!found)\r\nnewmask = *oldmask;\r\nwhile (isspace(*str))\r\nstr++;\r\nif (*str == 0)\r\nreturn -EINVAL;\r\n}\r\nfor (len = 0; str[len] != 0 && !isspace(str[len]) &&\r\nstr[len] != '+' && str[len] != '-'; len++);\r\nfound = 0;\r\nfor (i = 0; i < 32; i++) {\r\ndebugstr = bit2str(i);\r\nif (debugstr != NULL &&\r\nstrlen(debugstr) == len &&\r\nstrncasecmp(str, debugstr, len) == 0) {\r\nif (op == '-')\r\nnewmask &= ~(1 << i);\r\nelse\r\nnewmask |= (1 << i);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found && len == 3 &&\r\n(strncasecmp(str, "ALL", len) == 0)) {\r\nif (op == '-')\r\nnewmask = minmask;\r\nelse\r\nnewmask = allmask;\r\nfound = 1;\r\n}\r\nif (!found) {\r\nCWARN("unknown mask '%.*s'.\n"\r\n"mask usage: [+|-]<all|type> ...\n", len, str);\r\nreturn -EINVAL;\r\n}\r\nstr += len;\r\n}\r\n*oldmask = newmask;\r\nreturn 0;\r\n}\r\nchar *cfs_firststr(char *str, size_t size)\r\n{\r\nsize_t i = 0;\r\nchar *end;\r\nwhile (i < size && *str && isspace(*str)) {\r\n++i;\r\n++str;\r\n}\r\nif (*str == '\0')\r\ngoto out;\r\nend = str;\r\nwhile (i < size && *end != '\0' && !isspace(*end)) {\r\n++i;\r\n++end;\r\n}\r\n*end= '\0';\r\nout:\r\nreturn str;\r\n}\r\nchar *\r\ncfs_trimwhite(char *str)\r\n{\r\nchar *end;\r\nwhile (isspace(*str))\r\nstr++;\r\nend = str + strlen(str);\r\nwhile (end > str) {\r\nif (!isspace(end[-1]))\r\nbreak;\r\nend--;\r\n}\r\n*end = 0;\r\nreturn str;\r\n}\r\nint\r\ncfs_gettok(struct cfs_lstr *next, char delim, struct cfs_lstr *res)\r\n{\r\nchar *end;\r\nif (next->ls_str == NULL)\r\nreturn 0;\r\nwhile (next->ls_len) {\r\nif (!isspace(*next->ls_str))\r\nbreak;\r\nnext->ls_str++;\r\nnext->ls_len--;\r\n}\r\nif (next->ls_len == 0)\r\nreturn 0;\r\nif (*next->ls_str == delim) {\r\nreturn 0;\r\n}\r\nres->ls_str = next->ls_str;\r\nend = memchr(next->ls_str, delim, next->ls_len);\r\nif (end == NULL) {\r\nend = next->ls_str + next->ls_len;\r\nnext->ls_str = NULL;\r\n} else {\r\nnext->ls_str = end + 1;\r\nnext->ls_len -= (end - res->ls_str + 1);\r\n}\r\nwhile (--end != res->ls_str) {\r\nif (!isspace(*end))\r\nbreak;\r\n}\r\nres->ls_len = end - res->ls_str + 1;\r\nreturn 1;\r\n}\r\nint\r\ncfs_str2num_check(char *str, int nob, unsigned *num,\r\nunsigned min, unsigned max)\r\n{\r\nchar *endp;\r\nstr = cfs_trimwhite(str);\r\n*num = strtoul(str, &endp, 0);\r\nif (endp == str)\r\nreturn 0;\r\nfor (; endp < str + nob; endp++) {\r\nif (!isspace(*endp))\r\nreturn 0;\r\n}\r\nreturn (*num >= min && *num <= max);\r\n}\r\nstatic int\r\ncfs_range_expr_parse(struct cfs_lstr *src, unsigned min, unsigned max,\r\nint bracketed, struct cfs_range_expr **expr)\r\n{\r\nstruct cfs_range_expr *re;\r\nstruct cfs_lstr tok;\r\nLIBCFS_ALLOC(re, sizeof(*re));\r\nif (re == NULL)\r\nreturn -ENOMEM;\r\nif (src->ls_len == 1 && src->ls_str[0] == '*') {\r\nre->re_lo = min;\r\nre->re_hi = max;\r\nre->re_stride = 1;\r\ngoto out;\r\n}\r\nif (cfs_str2num_check(src->ls_str, src->ls_len,\r\n&re->re_lo, min, max)) {\r\nre->re_hi = re->re_lo;\r\nre->re_stride = 1;\r\ngoto out;\r\n}\r\nif (!bracketed || !cfs_gettok(src, '-', &tok))\r\ngoto failed;\r\nif (!cfs_str2num_check(tok.ls_str, tok.ls_len,\r\n&re->re_lo, min, max))\r\ngoto failed;\r\nif (cfs_str2num_check(src->ls_str, src->ls_len,\r\n&re->re_hi, min, max)) {\r\nre->re_stride = 1;\r\ngoto out;\r\n}\r\nif (cfs_gettok(src, '/', &tok)) {\r\nif (!cfs_str2num_check(tok.ls_str, tok.ls_len,\r\n&re->re_hi, min, max))\r\ngoto failed;\r\nif (cfs_str2num_check(src->ls_str, src->ls_len,\r\n&re->re_stride, min, max)) {\r\ngoto out;\r\n}\r\n}\r\nout:\r\n*expr = re;\r\nreturn 0;\r\nfailed:\r\nLIBCFS_FREE(re, sizeof(*re));\r\nreturn -EINVAL;\r\n}\r\nint\r\ncfs_expr_list_match(__u32 value, struct cfs_expr_list *expr_list)\r\n{\r\nstruct cfs_range_expr *expr;\r\nlist_for_each_entry(expr, &expr_list->el_exprs, re_link) {\r\nif (value >= expr->re_lo && value <= expr->re_hi &&\r\n((value - expr->re_lo) % expr->re_stride) == 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\ncfs_expr_list_values(struct cfs_expr_list *expr_list, int max, __u32 **valpp)\r\n{\r\nstruct cfs_range_expr *expr;\r\n__u32 *val;\r\nint count = 0;\r\nint i;\r\nlist_for_each_entry(expr, &expr_list->el_exprs, re_link) {\r\nfor (i = expr->re_lo; i <= expr->re_hi; i++) {\r\nif (((i - expr->re_lo) % expr->re_stride) == 0)\r\ncount++;\r\n}\r\n}\r\nif (count == 0)\r\nreturn 0;\r\nif (count > max) {\r\nCERROR("Number of values %d exceeds max allowed %d\n",\r\nmax, count);\r\nreturn -EINVAL;\r\n}\r\nLIBCFS_ALLOC(val, sizeof(val[0]) * count);\r\nif (val == NULL)\r\nreturn -ENOMEM;\r\ncount = 0;\r\nlist_for_each_entry(expr, &expr_list->el_exprs, re_link) {\r\nfor (i = expr->re_lo; i <= expr->re_hi; i++) {\r\nif (((i - expr->re_lo) % expr->re_stride) == 0)\r\nval[count++] = i;\r\n}\r\n}\r\n*valpp = val;\r\nreturn count;\r\n}\r\nvoid\r\ncfs_expr_list_free(struct cfs_expr_list *expr_list)\r\n{\r\nwhile (!list_empty(&expr_list->el_exprs)) {\r\nstruct cfs_range_expr *expr;\r\nexpr = list_entry(expr_list->el_exprs.next,\r\nstruct cfs_range_expr, re_link),\r\nlist_del(&expr->re_link);\r\nLIBCFS_FREE(expr, sizeof(*expr));\r\n}\r\nLIBCFS_FREE(expr_list, sizeof(*expr_list));\r\n}\r\nint\r\ncfs_expr_list_parse(char *str, int len, unsigned min, unsigned max,\r\nstruct cfs_expr_list **elpp)\r\n{\r\nstruct cfs_expr_list *expr_list;\r\nstruct cfs_range_expr *expr;\r\nstruct cfs_lstr src;\r\nint rc;\r\nLIBCFS_ALLOC(expr_list, sizeof(*expr_list));\r\nif (expr_list == NULL)\r\nreturn -ENOMEM;\r\nsrc.ls_str = str;\r\nsrc.ls_len = len;\r\nINIT_LIST_HEAD(&expr_list->el_exprs);\r\nif (src.ls_str[0] == '[' &&\r\nsrc.ls_str[src.ls_len - 1] == ']') {\r\nsrc.ls_str++;\r\nsrc.ls_len -= 2;\r\nrc = -EINVAL;\r\nwhile (src.ls_str != NULL) {\r\nstruct cfs_lstr tok;\r\nif (!cfs_gettok(&src, ',', &tok)) {\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nrc = cfs_range_expr_parse(&tok, min, max, 1, &expr);\r\nif (rc != 0)\r\nbreak;\r\nlist_add_tail(&expr->re_link,\r\n&expr_list->el_exprs);\r\n}\r\n} else {\r\nrc = cfs_range_expr_parse(&src, min, max, 0, &expr);\r\nif (rc == 0) {\r\nlist_add_tail(&expr->re_link,\r\n&expr_list->el_exprs);\r\n}\r\n}\r\nif (rc != 0)\r\ncfs_expr_list_free(expr_list);\r\nelse\r\n*elpp = expr_list;\r\nreturn rc;\r\n}\r\nvoid\r\ncfs_expr_list_free_list(struct list_head *list)\r\n{\r\nstruct cfs_expr_list *el;\r\nwhile (!list_empty(list)) {\r\nel = list_entry(list->next,\r\nstruct cfs_expr_list, el_link);\r\nlist_del(&el->el_link);\r\ncfs_expr_list_free(el);\r\n}\r\n}\r\nint\r\ncfs_ip_addr_parse(char *str, int len, struct list_head *list)\r\n{\r\nstruct cfs_expr_list *el;\r\nstruct cfs_lstr src;\r\nint rc;\r\nint i;\r\nsrc.ls_str = str;\r\nsrc.ls_len = len;\r\ni = 0;\r\nwhile (src.ls_str != NULL) {\r\nstruct cfs_lstr res;\r\nif (!cfs_gettok(&src, '.', &res)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = cfs_expr_list_parse(res.ls_str, res.ls_len, 0, 255, &el);\r\nif (rc != 0)\r\ngoto out;\r\nlist_add_tail(&el->el_link, list);\r\ni++;\r\n}\r\nif (i == 4)\r\nreturn 0;\r\nrc = -EINVAL;\r\nout:\r\ncfs_expr_list_free_list(list);\r\nreturn rc;\r\n}\r\nint\r\ncfs_ip_addr_match(__u32 addr, struct list_head *list)\r\n{\r\nstruct cfs_expr_list *el;\r\nint i = 0;\r\nlist_for_each_entry_reverse(el, list, el_link) {\r\nif (!cfs_expr_list_match(addr & 0xff, el))\r\nreturn 0;\r\naddr >>= 8;\r\ni++;\r\n}\r\nreturn i == 4;\r\n}\r\nvoid\r\ncfs_ip_addr_free(struct list_head *list)\r\n{\r\ncfs_expr_list_free_list(list);\r\n}
