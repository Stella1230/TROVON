static bool swim3_end_request(struct floppy_state *fs, int err, unsigned int nr_bytes)\r\n{\r\nstruct request *req = fs->cur_req;\r\nint rc;\r\nswim3_dbg(" end request, err=%d nr_bytes=%d, cur_req=%p\n",\r\nerr, nr_bytes, req);\r\nif (err)\r\nnr_bytes = blk_rq_cur_bytes(req);\r\nrc = __blk_end_request(req, err, nr_bytes);\r\nif (rc)\r\nreturn true;\r\nfs->cur_req = NULL;\r\nreturn false;\r\n}\r\nstatic void swim3_select(struct floppy_state *fs, int sel)\r\n{\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nout_8(&sw->select, RELAX);\r\nif (sel & 8)\r\nout_8(&sw->control_bis, SELECT);\r\nelse\r\nout_8(&sw->control_bic, SELECT);\r\nout_8(&sw->select, sel & CA_MASK);\r\n}\r\nstatic void swim3_action(struct floppy_state *fs, int action)\r\n{\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nswim3_select(fs, action);\r\nudelay(1);\r\nout_8(&sw->select, sw->select | LSTRB);\r\nudelay(2);\r\nout_8(&sw->select, sw->select & ~LSTRB);\r\nudelay(1);\r\n}\r\nstatic int swim3_readbit(struct floppy_state *fs, int bit)\r\n{\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nint stat;\r\nswim3_select(fs, bit);\r\nudelay(1);\r\nstat = in_8(&sw->status);\r\nreturn (stat & DATA) == 0;\r\n}\r\nstatic void start_request(struct floppy_state *fs)\r\n{\r\nstruct request *req;\r\nunsigned long x;\r\nswim3_dbg("start request, initial state=%d\n", fs->state);\r\nif (fs->state == idle && fs->wanted) {\r\nfs->state = available;\r\nwake_up(&fs->wait);\r\nreturn;\r\n}\r\nwhile (fs->state == idle) {\r\nswim3_dbg("start request, idle loop, cur_req=%p\n", fs->cur_req);\r\nif (!fs->cur_req) {\r\nfs->cur_req = blk_fetch_request(disks[fs->index]->queue);\r\nswim3_dbg(" fetched request %p\n", fs->cur_req);\r\nif (!fs->cur_req)\r\nbreak;\r\n}\r\nreq = fs->cur_req;\r\nif (fs->mdev->media_bay &&\r\ncheck_media_bay(fs->mdev->media_bay) != MB_FD) {\r\nswim3_dbg("%s", " media bay absent, dropping req\n");\r\nswim3_end_request(fs, -ENODEV, 0);\r\ncontinue;\r\n}\r\n#if 0\r\nswim3_dbg("do_fd_req: dev=%s cmd=%d sec=%ld nr_sec=%u buf=%p\n",\r\nreq->rq_disk->disk_name, req->cmd,\r\n(long)blk_rq_pos(req), blk_rq_sectors(req),\r\nbio_data(req->bio));\r\nswim3_dbg(" errors=%d current_nr_sectors=%u\n",\r\nreq->errors, blk_rq_cur_sectors(req));\r\n#endif\r\nif (blk_rq_pos(req) >= fs->total_secs) {\r\nswim3_dbg(" pos out of bounds (%ld, max is %ld)\n",\r\n(long)blk_rq_pos(req), (long)fs->total_secs);\r\nswim3_end_request(fs, -EIO, 0);\r\ncontinue;\r\n}\r\nif (fs->ejected) {\r\nswim3_dbg("%s", " disk ejected\n");\r\nswim3_end_request(fs, -EIO, 0);\r\ncontinue;\r\n}\r\nif (rq_data_dir(req) == WRITE) {\r\nif (fs->write_prot < 0)\r\nfs->write_prot = swim3_readbit(fs, WRITE_PROT);\r\nif (fs->write_prot) {\r\nswim3_dbg("%s", " try to write, disk write protected\n");\r\nswim3_end_request(fs, -EIO, 0);\r\ncontinue;\r\n}\r\n}\r\nfs->req_cyl = ((long)blk_rq_pos(req)) / fs->secpercyl;\r\nx = ((long)blk_rq_pos(req)) % fs->secpercyl;\r\nfs->head = x / fs->secpertrack;\r\nfs->req_sector = x % fs->secpertrack + 1;\r\nfs->state = do_transfer;\r\nfs->retries = 0;\r\nact(fs);\r\n}\r\n}\r\nstatic void do_fd_request(struct request_queue * q)\r\n{\r\nstart_request(q->queuedata);\r\n}\r\nstatic void set_timeout(struct floppy_state *fs, int nticks,\r\nvoid (*proc)(unsigned long))\r\n{\r\nif (fs->timeout_pending)\r\ndel_timer(&fs->timeout);\r\nfs->timeout.expires = jiffies + nticks;\r\nfs->timeout.function = proc;\r\nfs->timeout.data = (unsigned long) fs;\r\nadd_timer(&fs->timeout);\r\nfs->timeout_pending = 1;\r\n}\r\nstatic inline void scan_track(struct floppy_state *fs)\r\n{\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nswim3_select(fs, READ_DATA_0);\r\nin_8(&sw->intr);\r\nin_8(&sw->error);\r\nout_8(&sw->intr_enable, SEEN_SECTOR);\r\nout_8(&sw->control_bis, DO_ACTION);\r\nset_timeout(fs, HZ, scan_timeout);\r\n}\r\nstatic inline void seek_track(struct floppy_state *fs, int n)\r\n{\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nif (n >= 0) {\r\nswim3_action(fs, SEEK_POSITIVE);\r\nsw->nseek = n;\r\n} else {\r\nswim3_action(fs, SEEK_NEGATIVE);\r\nsw->nseek = -n;\r\n}\r\nfs->expect_cyl = (fs->cur_cyl >= 0)? fs->cur_cyl + n: -1;\r\nswim3_select(fs, STEP);\r\nin_8(&sw->error);\r\nout_8(&sw->intr_enable, SEEK_DONE);\r\nout_8(&sw->control_bis, DO_SEEK);\r\nset_timeout(fs, 3*HZ, seek_timeout);\r\nfs->settle_time = 0;\r\n}\r\nstatic inline void init_dma(struct dbdma_cmd *cp, int cmd,\r\nvoid *buf, int count)\r\n{\r\nst_le16(&cp->req_count, count);\r\nst_le16(&cp->command, cmd);\r\nst_le32(&cp->phy_addr, virt_to_bus(buf));\r\ncp->xfer_status = 0;\r\n}\r\nstatic inline void setup_transfer(struct floppy_state *fs)\r\n{\r\nint n;\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nstruct dbdma_cmd *cp = fs->dma_cmd;\r\nstruct dbdma_regs __iomem *dr = fs->dma;\r\nstruct request *req = fs->cur_req;\r\nif (blk_rq_cur_sectors(req) <= 0) {\r\nswim3_warn("%s", "Transfer 0 sectors ?\n");\r\nreturn;\r\n}\r\nif (rq_data_dir(req) == WRITE)\r\nn = 1;\r\nelse {\r\nn = fs->secpertrack - fs->req_sector + 1;\r\nif (n > blk_rq_cur_sectors(req))\r\nn = blk_rq_cur_sectors(req);\r\n}\r\nswim3_dbg(" setup xfer at sect %d (of %d) head %d for %d\n",\r\nfs->req_sector, fs->secpertrack, fs->head, n);\r\nfs->scount = n;\r\nswim3_select(fs, fs->head? READ_DATA_1: READ_DATA_0);\r\nout_8(&sw->sector, fs->req_sector);\r\nout_8(&sw->nsect, n);\r\nout_8(&sw->gap3, 0);\r\nout_le32(&dr->cmdptr, virt_to_bus(cp));\r\nif (rq_data_dir(req) == WRITE) {\r\ninit_dma(cp, OUTPUT_MORE, write_preamble, sizeof(write_preamble));\r\n++cp;\r\ninit_dma(cp, OUTPUT_MORE, bio_data(req->bio), 512);\r\n++cp;\r\ninit_dma(cp, OUTPUT_LAST, write_postamble, sizeof(write_postamble));\r\n} else {\r\ninit_dma(cp, INPUT_LAST, bio_data(req->bio), n * 512);\r\n}\r\n++cp;\r\nout_le16(&cp->command, DBDMA_STOP);\r\nout_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);\r\nin_8(&sw->error);\r\nout_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);\r\nif (rq_data_dir(req) == WRITE)\r\nout_8(&sw->control_bis, WRITE_SECTORS);\r\nin_8(&sw->intr);\r\nout_le32(&dr->control, (RUN << 16) | RUN);\r\nout_8(&sw->intr_enable, TRANSFER_DONE);\r\nout_8(&sw->control_bis, DO_ACTION);\r\nset_timeout(fs, 2*HZ, xfer_timeout);\r\n}\r\nstatic void act(struct floppy_state *fs)\r\n{\r\nfor (;;) {\r\nswim3_dbg(" act loop, state=%d, req_cyl=%d, cur_cyl=%d\n",\r\nfs->state, fs->req_cyl, fs->cur_cyl);\r\nswitch (fs->state) {\r\ncase idle:\r\nreturn;\r\ncase locating:\r\nif (swim3_readbit(fs, TRACK_ZERO)) {\r\nswim3_dbg("%s", " locate track 0\n");\r\nfs->cur_cyl = 0;\r\nif (fs->req_cyl == 0)\r\nfs->state = do_transfer;\r\nelse\r\nfs->state = seeking;\r\nbreak;\r\n}\r\nscan_track(fs);\r\nreturn;\r\ncase seeking:\r\nif (fs->cur_cyl < 0) {\r\nfs->expect_cyl = -1;\r\nfs->state = locating;\r\nbreak;\r\n}\r\nif (fs->req_cyl == fs->cur_cyl) {\r\nswim3_warn("%s", "Whoops, seeking 0\n");\r\nfs->state = do_transfer;\r\nbreak;\r\n}\r\nseek_track(fs, fs->req_cyl - fs->cur_cyl);\r\nreturn;\r\ncase settling:\r\nfs->settle_time = (HZ + 32) / 33;\r\nset_timeout(fs, fs->settle_time, settle_timeout);\r\nreturn;\r\ncase do_transfer:\r\nif (fs->cur_cyl != fs->req_cyl) {\r\nif (fs->retries > 5) {\r\nswim3_err("Wrong cylinder in transfer, want: %d got %d\n",\r\nfs->req_cyl, fs->cur_cyl);\r\nswim3_end_request(fs, -EIO, 0);\r\nfs->state = idle;\r\nreturn;\r\n}\r\nfs->state = seeking;\r\nbreak;\r\n}\r\nsetup_transfer(fs);\r\nreturn;\r\ncase jogging:\r\nseek_track(fs, -5);\r\nreturn;\r\ndefault:\r\nswim3_err("Unknown state %d\n", fs->state);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void scan_timeout(unsigned long data)\r\n{\r\nstruct floppy_state *fs = (struct floppy_state *) data;\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nunsigned long flags;\r\nswim3_dbg("* scan timeout, state=%d\n", fs->state);\r\nspin_lock_irqsave(&swim3_lock, flags);\r\nfs->timeout_pending = 0;\r\nout_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);\r\nout_8(&sw->select, RELAX);\r\nout_8(&sw->intr_enable, 0);\r\nfs->cur_cyl = -1;\r\nif (fs->retries > 5) {\r\nswim3_end_request(fs, -EIO, 0);\r\nfs->state = idle;\r\nstart_request(fs);\r\n} else {\r\nfs->state = jogging;\r\nact(fs);\r\n}\r\nspin_unlock_irqrestore(&swim3_lock, flags);\r\n}\r\nstatic void seek_timeout(unsigned long data)\r\n{\r\nstruct floppy_state *fs = (struct floppy_state *) data;\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nunsigned long flags;\r\nswim3_dbg("* seek timeout, state=%d\n", fs->state);\r\nspin_lock_irqsave(&swim3_lock, flags);\r\nfs->timeout_pending = 0;\r\nout_8(&sw->control_bic, DO_SEEK);\r\nout_8(&sw->select, RELAX);\r\nout_8(&sw->intr_enable, 0);\r\nswim3_err("%s", "Seek timeout\n");\r\nswim3_end_request(fs, -EIO, 0);\r\nfs->state = idle;\r\nstart_request(fs);\r\nspin_unlock_irqrestore(&swim3_lock, flags);\r\n}\r\nstatic void settle_timeout(unsigned long data)\r\n{\r\nstruct floppy_state *fs = (struct floppy_state *) data;\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nunsigned long flags;\r\nswim3_dbg("* settle timeout, state=%d\n", fs->state);\r\nspin_lock_irqsave(&swim3_lock, flags);\r\nfs->timeout_pending = 0;\r\nif (swim3_readbit(fs, SEEK_COMPLETE)) {\r\nout_8(&sw->select, RELAX);\r\nfs->state = locating;\r\nact(fs);\r\ngoto unlock;\r\n}\r\nout_8(&sw->select, RELAX);\r\nif (fs->settle_time < 2*HZ) {\r\n++fs->settle_time;\r\nset_timeout(fs, 1, settle_timeout);\r\ngoto unlock;\r\n}\r\nswim3_err("%s", "Seek settle timeout\n");\r\nswim3_end_request(fs, -EIO, 0);\r\nfs->state = idle;\r\nstart_request(fs);\r\nunlock:\r\nspin_unlock_irqrestore(&swim3_lock, flags);\r\n}\r\nstatic void xfer_timeout(unsigned long data)\r\n{\r\nstruct floppy_state *fs = (struct floppy_state *) data;\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nstruct dbdma_regs __iomem *dr = fs->dma;\r\nunsigned long flags;\r\nint n;\r\nswim3_dbg("* xfer timeout, state=%d\n", fs->state);\r\nspin_lock_irqsave(&swim3_lock, flags);\r\nfs->timeout_pending = 0;\r\nout_le32(&dr->control, RUN << 16);\r\nfor (n = 0; (in_le32(&dr->status) & ACTIVE) && n < 1000; n++)\r\nudelay(1);\r\nout_8(&sw->intr_enable, 0);\r\nout_8(&sw->control_bic, WRITE_SECTORS | DO_ACTION);\r\nout_8(&sw->select, RELAX);\r\nswim3_err("Timeout %sing sector %ld\n",\r\n(rq_data_dir(fs->cur_req)==WRITE? "writ": "read"),\r\n(long)blk_rq_pos(fs->cur_req));\r\nswim3_end_request(fs, -EIO, 0);\r\nfs->state = idle;\r\nstart_request(fs);\r\nspin_unlock_irqrestore(&swim3_lock, flags);\r\n}\r\nstatic irqreturn_t swim3_interrupt(int irq, void *dev_id)\r\n{\r\nstruct floppy_state *fs = (struct floppy_state *) dev_id;\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nint intr, err, n;\r\nint stat, resid;\r\nstruct dbdma_regs __iomem *dr;\r\nstruct dbdma_cmd *cp;\r\nunsigned long flags;\r\nstruct request *req = fs->cur_req;\r\nswim3_dbg("* interrupt, state=%d\n", fs->state);\r\nspin_lock_irqsave(&swim3_lock, flags);\r\nintr = in_8(&sw->intr);\r\nerr = (intr & ERROR_INTR)? in_8(&sw->error): 0;\r\nif ((intr & ERROR_INTR) && fs->state != do_transfer)\r\nswim3_err("Non-transfer error interrupt: state=%d, dir=%x, intr=%x, err=%x\n",\r\nfs->state, rq_data_dir(req), intr, err);\r\nswitch (fs->state) {\r\ncase locating:\r\nif (intr & SEEN_SECTOR) {\r\nout_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);\r\nout_8(&sw->select, RELAX);\r\nout_8(&sw->intr_enable, 0);\r\ndel_timer(&fs->timeout);\r\nfs->timeout_pending = 0;\r\nif (sw->ctrack == 0xff) {\r\nswim3_err("%s", "Seen sector but cyl=ff?\n");\r\nfs->cur_cyl = -1;\r\nif (fs->retries > 5) {\r\nswim3_end_request(fs, -EIO, 0);\r\nfs->state = idle;\r\nstart_request(fs);\r\n} else {\r\nfs->state = jogging;\r\nact(fs);\r\n}\r\nbreak;\r\n}\r\nfs->cur_cyl = sw->ctrack;\r\nfs->cur_sector = sw->csect;\r\nif (fs->expect_cyl != -1 && fs->expect_cyl != fs->cur_cyl)\r\nswim3_err("Expected cyl %d, got %d\n",\r\nfs->expect_cyl, fs->cur_cyl);\r\nfs->state = do_transfer;\r\nact(fs);\r\n}\r\nbreak;\r\ncase seeking:\r\ncase jogging:\r\nif (sw->nseek == 0) {\r\nout_8(&sw->control_bic, DO_SEEK);\r\nout_8(&sw->select, RELAX);\r\nout_8(&sw->intr_enable, 0);\r\ndel_timer(&fs->timeout);\r\nfs->timeout_pending = 0;\r\nif (fs->state == seeking)\r\n++fs->retries;\r\nfs->state = settling;\r\nact(fs);\r\n}\r\nbreak;\r\ncase settling:\r\nout_8(&sw->intr_enable, 0);\r\ndel_timer(&fs->timeout);\r\nfs->timeout_pending = 0;\r\nact(fs);\r\nbreak;\r\ncase do_transfer:\r\nif ((intr & (ERROR_INTR | TRANSFER_DONE)) == 0)\r\nbreak;\r\nout_8(&sw->intr_enable, 0);\r\nout_8(&sw->control_bic, WRITE_SECTORS | DO_ACTION);\r\nout_8(&sw->select, RELAX);\r\ndel_timer(&fs->timeout);\r\nfs->timeout_pending = 0;\r\ndr = fs->dma;\r\ncp = fs->dma_cmd;\r\nif (rq_data_dir(req) == WRITE)\r\n++cp;\r\nif ((intr & ERROR_INTR) == 0 && cp->xfer_status == 0) {\r\nfor (n = 0; n < 100; ++n) {\r\nif (cp->xfer_status != 0)\r\nbreak;\r\nudelay(1);\r\nbarrier();\r\n}\r\n}\r\nout_le32(&dr->control, (RUN | PAUSE) << 16);\r\nstat = ld_le16(&cp->xfer_status);\r\nresid = ld_le16(&cp->res_count);\r\nif (intr & ERROR_INTR) {\r\nn = fs->scount - 1 - resid / 512;\r\nif (n > 0) {\r\nblk_update_request(req, 0, n << 9);\r\nfs->req_sector += n;\r\n}\r\nif (fs->retries < 5) {\r\n++fs->retries;\r\nact(fs);\r\n} else {\r\nswim3_err("Error %sing block %ld (err=%x)\n",\r\nrq_data_dir(req) == WRITE? "writ": "read",\r\n(long)blk_rq_pos(req), err);\r\nswim3_end_request(fs, -EIO, 0);\r\nfs->state = idle;\r\n}\r\n} else {\r\nif ((stat & ACTIVE) == 0 || resid != 0) {\r\nswim3_err("fd dma error: stat=%x resid=%d\n", stat, resid);\r\nswim3_err(" state=%d, dir=%x, intr=%x, err=%x\n",\r\nfs->state, rq_data_dir(req), intr, err);\r\nswim3_end_request(fs, -EIO, 0);\r\nfs->state = idle;\r\nstart_request(fs);\r\nbreak;\r\n}\r\nfs->retries = 0;\r\nif (swim3_end_request(fs, 0, fs->scount << 9)) {\r\nfs->req_sector += fs->scount;\r\nif (fs->req_sector > fs->secpertrack) {\r\nfs->req_sector -= fs->secpertrack;\r\nif (++fs->head > 1) {\r\nfs->head = 0;\r\n++fs->req_cyl;\r\n}\r\n}\r\nact(fs);\r\n} else\r\nfs->state = idle;\r\n}\r\nif (fs->state == idle)\r\nstart_request(fs);\r\nbreak;\r\ndefault:\r\nswim3_err("Don't know what to do in state %d\n", fs->state);\r\n}\r\nspin_unlock_irqrestore(&swim3_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int grab_drive(struct floppy_state *fs, enum swim_state state,\r\nint interruptible)\r\n{\r\nunsigned long flags;\r\nswim3_dbg("%s", "-> grab drive\n");\r\nspin_lock_irqsave(&swim3_lock, flags);\r\nif (fs->state != idle && fs->state != available) {\r\n++fs->wanted;\r\nif (!interruptible)\r\nwait_event_lock_irq(fs->wait,\r\nfs->state == available,\r\nswim3_lock);\r\nelse if (wait_event_interruptible_lock_irq(fs->wait,\r\nfs->state == available,\r\nswim3_lock)) {\r\n--fs->wanted;\r\nspin_unlock_irqrestore(&swim3_lock, flags);\r\nreturn -EINTR;\r\n}\r\n--fs->wanted;\r\n}\r\nfs->state = state;\r\nspin_unlock_irqrestore(&swim3_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void release_drive(struct floppy_state *fs)\r\n{\r\nunsigned long flags;\r\nswim3_dbg("%s", "-> release drive\n");\r\nspin_lock_irqsave(&swim3_lock, flags);\r\nfs->state = idle;\r\nstart_request(fs);\r\nspin_unlock_irqrestore(&swim3_lock, flags);\r\n}\r\nstatic int fd_eject(struct floppy_state *fs)\r\n{\r\nint err, n;\r\nerr = grab_drive(fs, ejecting, 1);\r\nif (err)\r\nreturn err;\r\nswim3_action(fs, EJECT);\r\nfor (n = 20; n > 0; --n) {\r\nif (signal_pending(current)) {\r\nerr = -EINTR;\r\nbreak;\r\n}\r\nswim3_select(fs, RELAX);\r\nschedule_timeout_interruptible(1);\r\nif (swim3_readbit(fs, DISK_IN) == 0)\r\nbreak;\r\n}\r\nswim3_select(fs, RELAX);\r\nudelay(150);\r\nfs->ejected = 1;\r\nrelease_drive(fs);\r\nreturn err;\r\n}\r\nstatic int floppy_locked_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nstruct floppy_state *fs = bdev->bd_disk->private_data;\r\nint err;\r\nif ((cmd & 0x80) && !capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (fs->mdev->media_bay &&\r\ncheck_media_bay(fs->mdev->media_bay) != MB_FD)\r\nreturn -ENXIO;\r\nswitch (cmd) {\r\ncase FDEJECT:\r\nif (fs->ref_count != 1)\r\nreturn -EBUSY;\r\nerr = fd_eject(fs);\r\nreturn err;\r\ncase FDGETPRM:\r\nif (copy_to_user((void __user *) param, &floppy_type,\r\nsizeof(struct floppy_struct)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int floppy_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nint ret;\r\nmutex_lock(&swim3_mutex);\r\nret = floppy_locked_ioctl(bdev, mode, cmd, param);\r\nmutex_unlock(&swim3_mutex);\r\nreturn ret;\r\n}\r\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct floppy_state *fs = bdev->bd_disk->private_data;\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nint n, err = 0;\r\nif (fs->ref_count == 0) {\r\nif (fs->mdev->media_bay &&\r\ncheck_media_bay(fs->mdev->media_bay) != MB_FD)\r\nreturn -ENXIO;\r\nout_8(&sw->setup, S_IBM_DRIVE | S_FCLK_DIV2);\r\nout_8(&sw->control_bic, 0xff);\r\nout_8(&sw->mode, 0x95);\r\nudelay(10);\r\nout_8(&sw->intr_enable, 0);\r\nout_8(&sw->control_bis, DRIVE_ENABLE | INTR_ENABLE);\r\nswim3_action(fs, MOTOR_ON);\r\nfs->write_prot = -1;\r\nfs->cur_cyl = -1;\r\nfor (n = 0; n < 2 * HZ; ++n) {\r\nif (n >= HZ/30 && swim3_readbit(fs, SEEK_COMPLETE))\r\nbreak;\r\nif (signal_pending(current)) {\r\nerr = -EINTR;\r\nbreak;\r\n}\r\nswim3_select(fs, RELAX);\r\nschedule_timeout_interruptible(1);\r\n}\r\nif (err == 0 && (swim3_readbit(fs, SEEK_COMPLETE) == 0\r\n|| swim3_readbit(fs, DISK_IN) == 0))\r\nerr = -ENXIO;\r\nswim3_action(fs, SETMFM);\r\nswim3_select(fs, RELAX);\r\n} else if (fs->ref_count == -1 || mode & FMODE_EXCL)\r\nreturn -EBUSY;\r\nif (err == 0 && (mode & FMODE_NDELAY) == 0\r\n&& (mode & (FMODE_READ|FMODE_WRITE))) {\r\ncheck_disk_change(bdev);\r\nif (fs->ejected)\r\nerr = -ENXIO;\r\n}\r\nif (err == 0 && (mode & FMODE_WRITE)) {\r\nif (fs->write_prot < 0)\r\nfs->write_prot = swim3_readbit(fs, WRITE_PROT);\r\nif (fs->write_prot)\r\nerr = -EROFS;\r\n}\r\nif (err) {\r\nif (fs->ref_count == 0) {\r\nswim3_action(fs, MOTOR_OFF);\r\nout_8(&sw->control_bic, DRIVE_ENABLE | INTR_ENABLE);\r\nswim3_select(fs, RELAX);\r\n}\r\nreturn err;\r\n}\r\nif (mode & FMODE_EXCL)\r\nfs->ref_count = -1;\r\nelse\r\n++fs->ref_count;\r\nreturn 0;\r\n}\r\nstatic int floppy_unlocked_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&swim3_mutex);\r\nret = floppy_open(bdev, mode);\r\nmutex_unlock(&swim3_mutex);\r\nreturn ret;\r\n}\r\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct floppy_state *fs = disk->private_data;\r\nstruct swim3 __iomem *sw = fs->swim3;\r\nmutex_lock(&swim3_mutex);\r\nif (fs->ref_count > 0 && --fs->ref_count == 0) {\r\nswim3_action(fs, MOTOR_OFF);\r\nout_8(&sw->control_bic, 0xff);\r\nswim3_select(fs, RELAX);\r\n}\r\nmutex_unlock(&swim3_mutex);\r\n}\r\nstatic unsigned int floppy_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct floppy_state *fs = disk->private_data;\r\nreturn fs->ejected ? DISK_EVENT_MEDIA_CHANGE : 0;\r\n}\r\nstatic int floppy_revalidate(struct gendisk *disk)\r\n{\r\nstruct floppy_state *fs = disk->private_data;\r\nstruct swim3 __iomem *sw;\r\nint ret, n;\r\nif (fs->mdev->media_bay &&\r\ncheck_media_bay(fs->mdev->media_bay) != MB_FD)\r\nreturn -ENXIO;\r\nsw = fs->swim3;\r\ngrab_drive(fs, revalidating, 0);\r\nout_8(&sw->intr_enable, 0);\r\nout_8(&sw->control_bis, DRIVE_ENABLE);\r\nswim3_action(fs, MOTOR_ON);\r\nfs->write_prot = -1;\r\nfs->cur_cyl = -1;\r\nmdelay(1);\r\nfor (n = HZ; n > 0; --n) {\r\nif (swim3_readbit(fs, SEEK_COMPLETE))\r\nbreak;\r\nif (signal_pending(current))\r\nbreak;\r\nswim3_select(fs, RELAX);\r\nschedule_timeout_interruptible(1);\r\n}\r\nret = swim3_readbit(fs, SEEK_COMPLETE) == 0\r\n|| swim3_readbit(fs, DISK_IN) == 0;\r\nif (ret)\r\nswim3_action(fs, MOTOR_OFF);\r\nelse {\r\nfs->ejected = 0;\r\nswim3_action(fs, SETMFM);\r\n}\r\nswim3_select(fs, RELAX);\r\nrelease_drive(fs);\r\nreturn ret;\r\n}\r\nstatic void swim3_mb_event(struct macio_dev* mdev, int mb_state)\r\n{\r\nstruct floppy_state *fs = macio_get_drvdata(mdev);\r\nstruct swim3 __iomem *sw;\r\nif (!fs)\r\nreturn;\r\nsw = fs->swim3;\r\nif (mb_state != MB_FD)\r\nreturn;\r\nout_8(&sw->intr_enable, 0);\r\nin_8(&sw->intr);\r\nin_8(&sw->error);\r\n}\r\nstatic int swim3_add_device(struct macio_dev *mdev, int index)\r\n{\r\nstruct device_node *swim = mdev->ofdev.dev.of_node;\r\nstruct floppy_state *fs = &floppy_states[index];\r\nint rc = -EBUSY;\r\nmemset(fs, 0, sizeof(*fs));\r\nfs->mdev = mdev;\r\nfs->index = index;\r\nif (macio_resource_count(mdev) < 2) {\r\nswim3_err("%s", "No address in device-tree\n");\r\nreturn -ENXIO;\r\n}\r\nif (macio_irq_count(mdev) < 1) {\r\nswim3_err("%s", "No interrupt in device-tree\n");\r\nreturn -ENXIO;\r\n}\r\nif (macio_request_resource(mdev, 0, "swim3 (mmio)")) {\r\nswim3_err("%s", "Can't request mmio resource\n");\r\nreturn -EBUSY;\r\n}\r\nif (macio_request_resource(mdev, 1, "swim3 (dma)")) {\r\nswim3_err("%s", "Can't request dma resource\n");\r\nmacio_release_resource(mdev, 0);\r\nreturn -EBUSY;\r\n}\r\ndev_set_drvdata(&mdev->ofdev.dev, fs);\r\nif (mdev->media_bay == NULL)\r\npmac_call_feature(PMAC_FTR_SWIM3_ENABLE, swim, 0, 1);\r\nfs->state = idle;\r\nfs->swim3 = (struct swim3 __iomem *)\r\nioremap(macio_resource_start(mdev, 0), 0x200);\r\nif (fs->swim3 == NULL) {\r\nswim3_err("%s", "Couldn't map mmio registers\n");\r\nrc = -ENOMEM;\r\ngoto out_release;\r\n}\r\nfs->dma = (struct dbdma_regs __iomem *)\r\nioremap(macio_resource_start(mdev, 1), 0x200);\r\nif (fs->dma == NULL) {\r\nswim3_err("%s", "Couldn't map dma registers\n");\r\niounmap(fs->swim3);\r\nrc = -ENOMEM;\r\ngoto out_release;\r\n}\r\nfs->swim3_intr = macio_irq(mdev, 0);\r\nfs->dma_intr = macio_irq(mdev, 1);\r\nfs->cur_cyl = -1;\r\nfs->cur_sector = -1;\r\nfs->secpercyl = 36;\r\nfs->secpertrack = 18;\r\nfs->total_secs = 2880;\r\ninit_waitqueue_head(&fs->wait);\r\nfs->dma_cmd = (struct dbdma_cmd *) DBDMA_ALIGN(fs->dbdma_cmd_space);\r\nmemset(fs->dma_cmd, 0, 2 * sizeof(struct dbdma_cmd));\r\nst_le16(&fs->dma_cmd[1].command, DBDMA_STOP);\r\nif (mdev->media_bay == NULL || check_media_bay(mdev->media_bay) == MB_FD)\r\nswim3_mb_event(mdev, MB_FD);\r\nif (request_irq(fs->swim3_intr, swim3_interrupt, 0, "SWIM3", fs)) {\r\nswim3_err("%s", "Couldn't request interrupt\n");\r\npmac_call_feature(PMAC_FTR_SWIM3_ENABLE, swim, 0, 0);\r\ngoto out_unmap;\r\nreturn -EBUSY;\r\n}\r\ninit_timer(&fs->timeout);\r\nswim3_info("SWIM3 floppy controller %s\n",\r\nmdev->media_bay ? "in media bay" : "");\r\nreturn 0;\r\nout_unmap:\r\niounmap(fs->dma);\r\niounmap(fs->swim3);\r\nout_release:\r\nmacio_release_resource(mdev, 0);\r\nmacio_release_resource(mdev, 1);\r\nreturn rc;\r\n}\r\nstatic int swim3_attach(struct macio_dev *mdev,\r\nconst struct of_device_id *match)\r\n{\r\nstruct gendisk *disk;\r\nint index, rc;\r\nindex = floppy_count++;\r\nif (index >= MAX_FLOPPIES)\r\nreturn -ENXIO;\r\nrc = swim3_add_device(mdev, index);\r\nif (rc)\r\nreturn rc;\r\ndisk = disks[index] = alloc_disk(1);\r\nif (disk == NULL)\r\nreturn -ENOMEM;\r\ndisk->queue = blk_init_queue(do_fd_request, &swim3_lock);\r\nif (disk->queue == NULL) {\r\nput_disk(disk);\r\nreturn -ENOMEM;\r\n}\r\ndisk->queue->queuedata = &floppy_states[index];\r\nif (index == 0) {\r\nif (register_blkdev(FLOPPY_MAJOR, "fd"))\r\nreturn 0;\r\n}\r\ndisk->major = FLOPPY_MAJOR;\r\ndisk->first_minor = index;\r\ndisk->fops = &floppy_fops;\r\ndisk->private_data = &floppy_states[index];\r\ndisk->flags |= GENHD_FL_REMOVABLE;\r\nsprintf(disk->disk_name, "fd%d", index);\r\nset_capacity(disk, 2880);\r\nadd_disk(disk);\r\nreturn 0;\r\n}\r\nint swim3_init(void)\r\n{\r\nmacio_register_driver(&swim3_driver);\r\nreturn 0;\r\n}
