static void dvc_writel(struct tegra_i2c_dev *i2c_dev, u32 val, unsigned long reg)\r\n{\r\nwritel(val, i2c_dev->base + reg);\r\n}\r\nstatic u32 dvc_readl(struct tegra_i2c_dev *i2c_dev, unsigned long reg)\r\n{\r\nreturn readl(i2c_dev->base + reg);\r\n}\r\nstatic unsigned long tegra_i2c_reg_addr(struct tegra_i2c_dev *i2c_dev,\r\nunsigned long reg)\r\n{\r\nif (i2c_dev->is_dvc)\r\nreg += (reg >= I2C_TX_FIFO) ? 0x10 : 0x40;\r\nreturn reg;\r\n}\r\nstatic void i2c_writel(struct tegra_i2c_dev *i2c_dev, u32 val,\r\nunsigned long reg)\r\n{\r\nwritel(val, i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg));\r\nif (reg != I2C_TX_FIFO)\r\nreadl(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg));\r\n}\r\nstatic u32 i2c_readl(struct tegra_i2c_dev *i2c_dev, unsigned long reg)\r\n{\r\nreturn readl(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg));\r\n}\r\nstatic void i2c_writesl(struct tegra_i2c_dev *i2c_dev, void *data,\r\nunsigned long reg, int len)\r\n{\r\nwritesl(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg), data, len);\r\n}\r\nstatic void i2c_readsl(struct tegra_i2c_dev *i2c_dev, void *data,\r\nunsigned long reg, int len)\r\n{\r\nreadsl(i2c_dev->base + tegra_i2c_reg_addr(i2c_dev, reg), data, len);\r\n}\r\nstatic void tegra_i2c_mask_irq(struct tegra_i2c_dev *i2c_dev, u32 mask)\r\n{\r\nu32 int_mask = i2c_readl(i2c_dev, I2C_INT_MASK);\r\nint_mask &= ~mask;\r\ni2c_writel(i2c_dev, int_mask, I2C_INT_MASK);\r\n}\r\nstatic void tegra_i2c_unmask_irq(struct tegra_i2c_dev *i2c_dev, u32 mask)\r\n{\r\nu32 int_mask = i2c_readl(i2c_dev, I2C_INT_MASK);\r\nint_mask |= mask;\r\ni2c_writel(i2c_dev, int_mask, I2C_INT_MASK);\r\n}\r\nstatic int tegra_i2c_flush_fifos(struct tegra_i2c_dev *i2c_dev)\r\n{\r\nunsigned long timeout = jiffies + HZ;\r\nu32 val = i2c_readl(i2c_dev, I2C_FIFO_CONTROL);\r\nval |= I2C_FIFO_CONTROL_TX_FLUSH | I2C_FIFO_CONTROL_RX_FLUSH;\r\ni2c_writel(i2c_dev, val, I2C_FIFO_CONTROL);\r\nwhile (i2c_readl(i2c_dev, I2C_FIFO_CONTROL) &\r\n(I2C_FIFO_CONTROL_TX_FLUSH | I2C_FIFO_CONTROL_RX_FLUSH)) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(i2c_dev->dev, "timeout waiting for fifo flush\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_i2c_empty_rx_fifo(struct tegra_i2c_dev *i2c_dev)\r\n{\r\nu32 val;\r\nint rx_fifo_avail;\r\nu8 *buf = i2c_dev->msg_buf;\r\nsize_t buf_remaining = i2c_dev->msg_buf_remaining;\r\nint words_to_transfer;\r\nval = i2c_readl(i2c_dev, I2C_FIFO_STATUS);\r\nrx_fifo_avail = (val & I2C_FIFO_STATUS_RX_MASK) >>\r\nI2C_FIFO_STATUS_RX_SHIFT;\r\nwords_to_transfer = buf_remaining / BYTES_PER_FIFO_WORD;\r\nif (words_to_transfer > rx_fifo_avail)\r\nwords_to_transfer = rx_fifo_avail;\r\ni2c_readsl(i2c_dev, buf, I2C_RX_FIFO, words_to_transfer);\r\nbuf += words_to_transfer * BYTES_PER_FIFO_WORD;\r\nbuf_remaining -= words_to_transfer * BYTES_PER_FIFO_WORD;\r\nrx_fifo_avail -= words_to_transfer;\r\nif (rx_fifo_avail > 0 && buf_remaining > 0) {\r\nBUG_ON(buf_remaining > 3);\r\nval = i2c_readl(i2c_dev, I2C_RX_FIFO);\r\nmemcpy(buf, &val, buf_remaining);\r\nbuf_remaining = 0;\r\nrx_fifo_avail--;\r\n}\r\nBUG_ON(rx_fifo_avail > 0 && buf_remaining > 0);\r\ni2c_dev->msg_buf_remaining = buf_remaining;\r\ni2c_dev->msg_buf = buf;\r\nreturn 0;\r\n}\r\nstatic int tegra_i2c_fill_tx_fifo(struct tegra_i2c_dev *i2c_dev)\r\n{\r\nu32 val;\r\nint tx_fifo_avail;\r\nu8 *buf = i2c_dev->msg_buf;\r\nsize_t buf_remaining = i2c_dev->msg_buf_remaining;\r\nint words_to_transfer;\r\nval = i2c_readl(i2c_dev, I2C_FIFO_STATUS);\r\ntx_fifo_avail = (val & I2C_FIFO_STATUS_TX_MASK) >>\r\nI2C_FIFO_STATUS_TX_SHIFT;\r\nwords_to_transfer = buf_remaining / BYTES_PER_FIFO_WORD;\r\nif (words_to_transfer) {\r\nif (words_to_transfer > tx_fifo_avail)\r\nwords_to_transfer = tx_fifo_avail;\r\nbuf_remaining -= words_to_transfer * BYTES_PER_FIFO_WORD;\r\ntx_fifo_avail -= words_to_transfer;\r\ni2c_dev->msg_buf_remaining = buf_remaining;\r\ni2c_dev->msg_buf = buf +\r\nwords_to_transfer * BYTES_PER_FIFO_WORD;\r\nbarrier();\r\ni2c_writesl(i2c_dev, buf, I2C_TX_FIFO, words_to_transfer);\r\nbuf += words_to_transfer * BYTES_PER_FIFO_WORD;\r\n}\r\nif (tx_fifo_avail > 0 && buf_remaining > 0) {\r\nBUG_ON(buf_remaining > 3);\r\nmemcpy(&val, buf, buf_remaining);\r\ni2c_dev->msg_buf_remaining = 0;\r\ni2c_dev->msg_buf = NULL;\r\nbarrier();\r\ni2c_writel(i2c_dev, val, I2C_TX_FIFO);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tegra_dvc_init(struct tegra_i2c_dev *i2c_dev)\r\n{\r\nu32 val = 0;\r\nval = dvc_readl(i2c_dev, DVC_CTRL_REG3);\r\nval |= DVC_CTRL_REG3_SW_PROG;\r\nval |= DVC_CTRL_REG3_I2C_DONE_INTR_EN;\r\ndvc_writel(i2c_dev, val, DVC_CTRL_REG3);\r\nval = dvc_readl(i2c_dev, DVC_CTRL_REG1);\r\nval |= DVC_CTRL_REG1_INTR_EN;\r\ndvc_writel(i2c_dev, val, DVC_CTRL_REG1);\r\n}\r\nstatic inline int tegra_i2c_clock_enable(struct tegra_i2c_dev *i2c_dev)\r\n{\r\nint ret;\r\nif (!i2c_dev->hw->has_single_clk_source) {\r\nret = clk_enable(i2c_dev->fast_clk);\r\nif (ret < 0) {\r\ndev_err(i2c_dev->dev,\r\n"Enabling fast clk failed, err %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = clk_enable(i2c_dev->div_clk);\r\nif (ret < 0) {\r\ndev_err(i2c_dev->dev,\r\n"Enabling div clk failed, err %d\n", ret);\r\nclk_disable(i2c_dev->fast_clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void tegra_i2c_clock_disable(struct tegra_i2c_dev *i2c_dev)\r\n{\r\nclk_disable(i2c_dev->div_clk);\r\nif (!i2c_dev->hw->has_single_clk_source)\r\nclk_disable(i2c_dev->fast_clk);\r\n}\r\nstatic int tegra_i2c_init(struct tegra_i2c_dev *i2c_dev)\r\n{\r\nu32 val;\r\nint err = 0;\r\nu32 clk_divisor;\r\nerr = tegra_i2c_clock_enable(i2c_dev);\r\nif (err < 0) {\r\ndev_err(i2c_dev->dev, "Clock enable failed %d\n", err);\r\nreturn err;\r\n}\r\nreset_control_assert(i2c_dev->rst);\r\nudelay(2);\r\nreset_control_deassert(i2c_dev->rst);\r\nif (i2c_dev->is_dvc)\r\ntegra_dvc_init(i2c_dev);\r\nval = I2C_CNFG_NEW_MASTER_FSM | I2C_CNFG_PACKET_MODE_EN |\r\n(0x2 << I2C_CNFG_DEBOUNCE_CNT_SHIFT);\r\ni2c_writel(i2c_dev, val, I2C_CNFG);\r\ni2c_writel(i2c_dev, 0, I2C_INT_MASK);\r\nclk_divisor = i2c_dev->hw->clk_divisor_hs_mode;\r\nclk_divisor |= i2c_dev->hw->clk_divisor_std_fast_mode <<\r\nI2C_CLK_DIVISOR_STD_FAST_MODE_SHIFT;\r\ni2c_writel(i2c_dev, clk_divisor, I2C_CLK_DIVISOR);\r\nif (!i2c_dev->is_dvc) {\r\nu32 sl_cfg = i2c_readl(i2c_dev, I2C_SL_CNFG);\r\nsl_cfg |= I2C_SL_CNFG_NACK | I2C_SL_CNFG_NEWSL;\r\ni2c_writel(i2c_dev, sl_cfg, I2C_SL_CNFG);\r\ni2c_writel(i2c_dev, 0xfc, I2C_SL_ADDR1);\r\ni2c_writel(i2c_dev, 0x00, I2C_SL_ADDR2);\r\n}\r\nval = 7 << I2C_FIFO_CONTROL_TX_TRIG_SHIFT |\r\n0 << I2C_FIFO_CONTROL_RX_TRIG_SHIFT;\r\ni2c_writel(i2c_dev, val, I2C_FIFO_CONTROL);\r\nif (tegra_i2c_flush_fifos(i2c_dev))\r\nerr = -ETIMEDOUT;\r\ntegra_i2c_clock_disable(i2c_dev);\r\nif (i2c_dev->irq_disabled) {\r\ni2c_dev->irq_disabled = 0;\r\nenable_irq(i2c_dev->irq);\r\n}\r\nreturn err;\r\n}\r\nstatic irqreturn_t tegra_i2c_isr(int irq, void *dev_id)\r\n{\r\nu32 status;\r\nconst u32 status_err = I2C_INT_NO_ACK | I2C_INT_ARBITRATION_LOST;\r\nstruct tegra_i2c_dev *i2c_dev = dev_id;\r\nstatus = i2c_readl(i2c_dev, I2C_INT_STATUS);\r\nif (status == 0) {\r\ndev_warn(i2c_dev->dev, "irq status 0 %08x %08x %08x\n",\r\ni2c_readl(i2c_dev, I2C_PACKET_TRANSFER_STATUS),\r\ni2c_readl(i2c_dev, I2C_STATUS),\r\ni2c_readl(i2c_dev, I2C_CNFG));\r\ni2c_dev->msg_err |= I2C_ERR_UNKNOWN_INTERRUPT;\r\nif (!i2c_dev->irq_disabled) {\r\ndisable_irq_nosync(i2c_dev->irq);\r\ni2c_dev->irq_disabled = 1;\r\n}\r\ngoto err;\r\n}\r\nif (unlikely(status & status_err)) {\r\nif (status & I2C_INT_NO_ACK)\r\ni2c_dev->msg_err |= I2C_ERR_NO_ACK;\r\nif (status & I2C_INT_ARBITRATION_LOST)\r\ni2c_dev->msg_err |= I2C_ERR_ARBITRATION_LOST;\r\ngoto err;\r\n}\r\nif (i2c_dev->msg_read && (status & I2C_INT_RX_FIFO_DATA_REQ)) {\r\nif (i2c_dev->msg_buf_remaining)\r\ntegra_i2c_empty_rx_fifo(i2c_dev);\r\nelse\r\nBUG();\r\n}\r\nif (!i2c_dev->msg_read && (status & I2C_INT_TX_FIFO_DATA_REQ)) {\r\nif (i2c_dev->msg_buf_remaining)\r\ntegra_i2c_fill_tx_fifo(i2c_dev);\r\nelse\r\ntegra_i2c_mask_irq(i2c_dev, I2C_INT_TX_FIFO_DATA_REQ);\r\n}\r\ni2c_writel(i2c_dev, status, I2C_INT_STATUS);\r\nif (i2c_dev->is_dvc)\r\ndvc_writel(i2c_dev, DVC_STATUS_I2C_DONE_INTR, DVC_STATUS);\r\nif (status & I2C_INT_PACKET_XFER_COMPLETE) {\r\nBUG_ON(i2c_dev->msg_buf_remaining);\r\ncomplete(&i2c_dev->msg_complete);\r\n}\r\nreturn IRQ_HANDLED;\r\nerr:\r\ntegra_i2c_mask_irq(i2c_dev, I2C_INT_NO_ACK | I2C_INT_ARBITRATION_LOST |\r\nI2C_INT_PACKET_XFER_COMPLETE | I2C_INT_TX_FIFO_DATA_REQ |\r\nI2C_INT_RX_FIFO_DATA_REQ);\r\ni2c_writel(i2c_dev, status, I2C_INT_STATUS);\r\nif (i2c_dev->is_dvc)\r\ndvc_writel(i2c_dev, DVC_STATUS_I2C_DONE_INTR, DVC_STATUS);\r\ncomplete(&i2c_dev->msg_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tegra_i2c_xfer_msg(struct tegra_i2c_dev *i2c_dev,\r\nstruct i2c_msg *msg, enum msg_end_type end_state)\r\n{\r\nu32 packet_header;\r\nu32 int_mask;\r\nint ret;\r\ntegra_i2c_flush_fifos(i2c_dev);\r\nif (msg->len == 0)\r\nreturn -EINVAL;\r\ni2c_dev->msg_buf = msg->buf;\r\ni2c_dev->msg_buf_remaining = msg->len;\r\ni2c_dev->msg_err = I2C_ERR_NONE;\r\ni2c_dev->msg_read = (msg->flags & I2C_M_RD);\r\nreinit_completion(&i2c_dev->msg_complete);\r\npacket_header = (0 << PACKET_HEADER0_HEADER_SIZE_SHIFT) |\r\nPACKET_HEADER0_PROTOCOL_I2C |\r\n(i2c_dev->cont_id << PACKET_HEADER0_CONT_ID_SHIFT) |\r\n(1 << PACKET_HEADER0_PACKET_ID_SHIFT);\r\ni2c_writel(i2c_dev, packet_header, I2C_TX_FIFO);\r\npacket_header = msg->len - 1;\r\ni2c_writel(i2c_dev, packet_header, I2C_TX_FIFO);\r\npacket_header = I2C_HEADER_IE_ENABLE;\r\nif (end_state == MSG_END_CONTINUE)\r\npacket_header |= I2C_HEADER_CONTINUE_XFER;\r\nelse if (end_state == MSG_END_REPEAT_START)\r\npacket_header |= I2C_HEADER_REPEAT_START;\r\nif (msg->flags & I2C_M_TEN) {\r\npacket_header |= msg->addr;\r\npacket_header |= I2C_HEADER_10BIT_ADDR;\r\n} else {\r\npacket_header |= msg->addr << I2C_HEADER_SLAVE_ADDR_SHIFT;\r\n}\r\nif (msg->flags & I2C_M_IGNORE_NAK)\r\npacket_header |= I2C_HEADER_CONT_ON_NAK;\r\nif (msg->flags & I2C_M_RD)\r\npacket_header |= I2C_HEADER_READ;\r\ni2c_writel(i2c_dev, packet_header, I2C_TX_FIFO);\r\nif (!(msg->flags & I2C_M_RD))\r\ntegra_i2c_fill_tx_fifo(i2c_dev);\r\nint_mask = I2C_INT_NO_ACK | I2C_INT_ARBITRATION_LOST;\r\nif (i2c_dev->hw->has_per_pkt_xfer_complete_irq)\r\nint_mask |= I2C_INT_PACKET_XFER_COMPLETE;\r\nif (msg->flags & I2C_M_RD)\r\nint_mask |= I2C_INT_RX_FIFO_DATA_REQ;\r\nelse if (i2c_dev->msg_buf_remaining)\r\nint_mask |= I2C_INT_TX_FIFO_DATA_REQ;\r\ntegra_i2c_unmask_irq(i2c_dev, int_mask);\r\ndev_dbg(i2c_dev->dev, "unmasked irq: %02x\n",\r\ni2c_readl(i2c_dev, I2C_INT_MASK));\r\nret = wait_for_completion_timeout(&i2c_dev->msg_complete, TEGRA_I2C_TIMEOUT);\r\ntegra_i2c_mask_irq(i2c_dev, int_mask);\r\nif (ret == 0) {\r\ndev_err(i2c_dev->dev, "i2c transfer timed out\n");\r\ntegra_i2c_init(i2c_dev);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(i2c_dev->dev, "transfer complete: %d %d %d\n",\r\nret, completion_done(&i2c_dev->msg_complete), i2c_dev->msg_err);\r\nif (likely(i2c_dev->msg_err == I2C_ERR_NONE))\r\nreturn 0;\r\nif (i2c_dev->msg_err == I2C_ERR_NO_ACK)\r\nudelay(DIV_ROUND_UP(2 * 1000000, i2c_dev->bus_clk_rate));\r\ntegra_i2c_init(i2c_dev);\r\nif (i2c_dev->msg_err == I2C_ERR_NO_ACK) {\r\nif (msg->flags & I2C_M_IGNORE_NAK)\r\nreturn 0;\r\nreturn -EREMOTEIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int tegra_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\r\nint num)\r\n{\r\nstruct tegra_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\r\nint i;\r\nint ret = 0;\r\nif (i2c_dev->is_suspended)\r\nreturn -EBUSY;\r\nret = tegra_i2c_clock_enable(i2c_dev);\r\nif (ret < 0) {\r\ndev_err(i2c_dev->dev, "Clock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < num; i++) {\r\nenum msg_end_type end_type = MSG_END_STOP;\r\nif (i < (num - 1)) {\r\nif (msgs[i + 1].flags & I2C_M_NOSTART)\r\nend_type = MSG_END_CONTINUE;\r\nelse\r\nend_type = MSG_END_REPEAT_START;\r\n}\r\nret = tegra_i2c_xfer_msg(i2c_dev, &msgs[i], end_type);\r\nif (ret)\r\nbreak;\r\n}\r\ntegra_i2c_clock_disable(i2c_dev);\r\nreturn ret ?: i;\r\n}\r\nstatic u32 tegra_i2c_func(struct i2c_adapter *adap)\r\n{\r\nstruct tegra_i2c_dev *i2c_dev = i2c_get_adapdata(adap);\r\nu32 ret = I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |\r\nI2C_FUNC_PROTOCOL_MANGLING;\r\nif (i2c_dev->hw->has_continue_xfer_support)\r\nret |= I2C_FUNC_NOSTART;\r\nreturn ret;\r\n}\r\nstatic int tegra_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_i2c_dev *i2c_dev;\r\nstruct resource *res;\r\nstruct clk *div_clk;\r\nstruct clk *fast_clk;\r\nvoid __iomem *base;\r\nint irq;\r\nint ret = 0;\r\nint clk_multiplier = I2C_CLK_MULTIPLIER_STD_FAST_MODE;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no irq resource\n");\r\nreturn -EINVAL;\r\n}\r\nirq = res->start;\r\ndiv_clk = devm_clk_get(&pdev->dev, "div-clk");\r\nif (IS_ERR(div_clk)) {\r\ndev_err(&pdev->dev, "missing controller clock");\r\nreturn PTR_ERR(div_clk);\r\n}\r\ni2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\r\nif (!i2c_dev)\r\nreturn -ENOMEM;\r\ni2c_dev->base = base;\r\ni2c_dev->div_clk = div_clk;\r\ni2c_dev->adapter.algo = &tegra_i2c_algo;\r\ni2c_dev->irq = irq;\r\ni2c_dev->cont_id = pdev->id;\r\ni2c_dev->dev = &pdev->dev;\r\ni2c_dev->rst = devm_reset_control_get(&pdev->dev, "i2c");\r\nif (IS_ERR(i2c_dev->rst)) {\r\ndev_err(&pdev->dev, "missing controller reset");\r\nreturn PTR_ERR(i2c_dev->rst);\r\n}\r\nret = of_property_read_u32(i2c_dev->dev->of_node, "clock-frequency",\r\n&i2c_dev->bus_clk_rate);\r\nif (ret)\r\ni2c_dev->bus_clk_rate = 100000;\r\ni2c_dev->hw = &tegra20_i2c_hw;\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(tegra_i2c_of_match, &pdev->dev);\r\ni2c_dev->hw = match->data;\r\ni2c_dev->is_dvc = of_device_is_compatible(pdev->dev.of_node,\r\n"nvidia,tegra20-i2c-dvc");\r\n} else if (pdev->id == 3) {\r\ni2c_dev->is_dvc = 1;\r\n}\r\ninit_completion(&i2c_dev->msg_complete);\r\nif (!i2c_dev->hw->has_single_clk_source) {\r\nfast_clk = devm_clk_get(&pdev->dev, "fast-clk");\r\nif (IS_ERR(fast_clk)) {\r\ndev_err(&pdev->dev, "missing fast clock");\r\nreturn PTR_ERR(fast_clk);\r\n}\r\ni2c_dev->fast_clk = fast_clk;\r\n}\r\nplatform_set_drvdata(pdev, i2c_dev);\r\nif (!i2c_dev->hw->has_single_clk_source) {\r\nret = clk_prepare(i2c_dev->fast_clk);\r\nif (ret < 0) {\r\ndev_err(i2c_dev->dev, "Clock prepare failed %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nclk_multiplier *= (i2c_dev->hw->clk_divisor_std_fast_mode + 1);\r\nret = clk_set_rate(i2c_dev->div_clk,\r\ni2c_dev->bus_clk_rate * clk_multiplier);\r\nif (ret) {\r\ndev_err(i2c_dev->dev, "Clock rate change failed %d\n", ret);\r\ngoto unprepare_fast_clk;\r\n}\r\nret = clk_prepare(i2c_dev->div_clk);\r\nif (ret < 0) {\r\ndev_err(i2c_dev->dev, "Clock prepare failed %d\n", ret);\r\ngoto unprepare_fast_clk;\r\n}\r\nret = tegra_i2c_init(i2c_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to initialize i2c controller");\r\ngoto unprepare_div_clk;\r\n}\r\nret = devm_request_irq(&pdev->dev, i2c_dev->irq,\r\ntegra_i2c_isr, 0, dev_name(&pdev->dev), i2c_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq %i\n", i2c_dev->irq);\r\ngoto unprepare_div_clk;\r\n}\r\ni2c_set_adapdata(&i2c_dev->adapter, i2c_dev);\r\ni2c_dev->adapter.owner = THIS_MODULE;\r\ni2c_dev->adapter.class = I2C_CLASS_DEPRECATED;\r\nstrlcpy(i2c_dev->adapter.name, "Tegra I2C adapter",\r\nsizeof(i2c_dev->adapter.name));\r\ni2c_dev->adapter.algo = &tegra_i2c_algo;\r\ni2c_dev->adapter.dev.parent = &pdev->dev;\r\ni2c_dev->adapter.nr = pdev->id;\r\ni2c_dev->adapter.dev.of_node = pdev->dev.of_node;\r\nret = i2c_add_numbered_adapter(&i2c_dev->adapter);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to add I2C adapter\n");\r\ngoto unprepare_div_clk;\r\n}\r\nreturn 0;\r\nunprepare_div_clk:\r\nclk_unprepare(i2c_dev->div_clk);\r\nunprepare_fast_clk:\r\nif (!i2c_dev->hw->has_single_clk_source)\r\nclk_unprepare(i2c_dev->fast_clk);\r\nreturn ret;\r\n}\r\nstatic int tegra_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c_dev->adapter);\r\nclk_unprepare(i2c_dev->div_clk);\r\nif (!i2c_dev->hw->has_single_clk_source)\r\nclk_unprepare(i2c_dev->fast_clk);\r\nreturn 0;\r\n}\r\nstatic int tegra_i2c_suspend(struct device *dev)\r\n{\r\nstruct tegra_i2c_dev *i2c_dev = dev_get_drvdata(dev);\r\ni2c_lock_adapter(&i2c_dev->adapter);\r\ni2c_dev->is_suspended = true;\r\ni2c_unlock_adapter(&i2c_dev->adapter);\r\nreturn 0;\r\n}\r\nstatic int tegra_i2c_resume(struct device *dev)\r\n{\r\nstruct tegra_i2c_dev *i2c_dev = dev_get_drvdata(dev);\r\nint ret;\r\ni2c_lock_adapter(&i2c_dev->adapter);\r\nret = tegra_i2c_init(i2c_dev);\r\nif (ret) {\r\ni2c_unlock_adapter(&i2c_dev->adapter);\r\nreturn ret;\r\n}\r\ni2c_dev->is_suspended = false;\r\ni2c_unlock_adapter(&i2c_dev->adapter);\r\nreturn 0;\r\n}\r\nstatic int __init tegra_i2c_init_driver(void)\r\n{\r\nreturn platform_driver_register(&tegra_i2c_driver);\r\n}\r\nstatic void __exit tegra_i2c_exit_driver(void)\r\n{\r\nplatform_driver_unregister(&tegra_i2c_driver);\r\n}
