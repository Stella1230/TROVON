static void sti_drm_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\n}\r\nstatic void sti_drm_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\ncompo->enable = true;\r\nif (mixer->id == STI_MIXER_MAIN) {\r\nif (clk_prepare_enable(compo->clk_compo_main))\r\nDRM_INFO("Failed to prepare/enable compo_main clk\n");\r\n} else {\r\nif (clk_prepare_enable(compo->clk_compo_aux))\r\nDRM_INFO("Failed to prepare/enable compo_aux clk\n");\r\n}\r\n}\r\nstatic void sti_drm_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nstruct sti_layer *layer;\r\nif ((!mixer || !compo)) {\r\nDRM_ERROR("Can not find mixer or compositor)\n");\r\nreturn;\r\n}\r\nlayer = to_sti_layer(crtc->primary);\r\nif (layer)\r\nsti_layer_commit(layer);\r\nelse\r\nDRM_ERROR("Can not find CRTC dedicated plane (GDP0)\n");\r\nif (sti_mixer_set_layer_status(mixer, layer, true))\r\nDRM_ERROR("Can not enable layer at mixer\n");\r\n}\r\nstatic bool sti_drm_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int\r\nsti_drm_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nstruct sti_layer *layer;\r\nstruct clk *clk;\r\nint rate = mode->clock * 1000;\r\nint res;\r\nunsigned int w, h;\r\nDRM_DEBUG_KMS("CRTC:%d (%s) fb:%d mode:%d (%s)\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer),\r\ncrtc->primary->fb->base.id, mode->base.id, mode->name);\r\nDRM_DEBUG_KMS("%d %d %d %d %d %d %d %d %d %d 0x%x 0x%x\n",\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay,\r\nmode->hsync_start, mode->hsync_end,\r\nmode->htotal,\r\nmode->vdisplay,\r\nmode->vsync_start, mode->vsync_end,\r\nmode->vtotal, mode->type, mode->flags);\r\nif (mixer->id == STI_MIXER_MAIN)\r\nclk = compo->clk_pix_main;\r\nelse\r\nclk = compo->clk_pix_aux;\r\nres = clk_set_rate(clk, rate);\r\nif (res < 0) {\r\nDRM_ERROR("Cannot set rate (%dHz) for pix clk\n", rate);\r\nreturn -EINVAL;\r\n}\r\nif (clk_prepare_enable(clk)) {\r\nDRM_ERROR("Failed to prepare/enable pix clk\n");\r\nreturn -EINVAL;\r\n}\r\nsti_vtg_set_config(mixer->id == STI_MIXER_MAIN ?\r\ncompo->vtg_main : compo->vtg_aux, &crtc->mode);\r\nlayer = to_sti_layer(crtc->primary);\r\nif (!layer) {\r\nDRM_ERROR("Can not find GDP0)\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&crtc->mode, adjusted_mode, sizeof(*adjusted_mode));\r\nres = sti_mixer_set_layer_depth(mixer, layer);\r\nif (res) {\r\nDRM_ERROR("Can not set layer depth\n");\r\nreturn -EINVAL;\r\n}\r\nres = sti_mixer_active_video_area(mixer, &crtc->mode);\r\nif (res) {\r\nDRM_ERROR("Can not set active video area\n");\r\nreturn -EINVAL;\r\n}\r\nw = crtc->primary->fb->width - x;\r\nh = crtc->primary->fb->height - y;\r\nreturn sti_layer_prepare(layer, crtc->primary->fb, &crtc->mode,\r\nmixer->id, 0, 0, w, h, x, y, w, h);\r\n}\r\nstatic int sti_drm_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct sti_layer *layer;\r\nunsigned int w, h;\r\nint ret;\r\nDRM_DEBUG_KMS("CRTC:%d (%s) fb:%d (%d,%d)\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer),\r\ncrtc->primary->fb->base.id, x, y);\r\nlayer = to_sti_layer(crtc->primary);\r\nif (!layer) {\r\nDRM_ERROR("Can not find GDP0)\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nw = crtc->primary->fb->width - crtc->x;\r\nh = crtc->primary->fb->height - crtc->y;\r\nret = sti_layer_prepare(layer, crtc->primary->fb, &crtc->mode,\r\nmixer->id, 0, 0, w, h,\r\ncrtc->x, crtc->y, w, h);\r\nif (ret) {\r\nDRM_ERROR("Can not prepare layer\n");\r\ngoto out;\r\n}\r\nsti_drm_crtc_commit(crtc);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void sti_drm_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void sti_drm_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nstruct sti_layer *layer;\r\nif (!compo->enable)\r\nreturn;\r\nDRM_DEBUG_KMS("CRTC:%d (%s)\n", crtc->base.id, sti_mixer_to_str(mixer));\r\nsti_mixer_set_background_status(mixer, false);\r\nlayer = to_sti_layer(crtc->primary);\r\nif (!layer) {\r\nDRM_ERROR("Cannot find GDP0\n");\r\nreturn;\r\n}\r\nif (sti_mixer_set_layer_status(mixer, layer, false))\r\nDRM_ERROR("Can not disable %s layer at mixer\n",\r\nsti_layer_to_str(layer));\r\nmsleep(WAIT_NEXT_VSYNC_MS);\r\nsti_layer_disable(layer);\r\ndrm_vblank_off(crtc->dev, mixer->id);\r\nif (mixer->id == STI_MIXER_MAIN) {\r\nclk_disable_unprepare(compo->clk_pix_main);\r\nclk_disable_unprepare(compo->clk_compo_main);\r\n} else {\r\nclk_disable_unprepare(compo->clk_pix_aux);\r\nclk_disable_unprepare(compo->clk_compo_aux);\r\n}\r\ncompo->enable = false;\r\n}\r\nstatic int sti_drm_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct drm_device *drm_dev = crtc->dev;\r\nstruct drm_framebuffer *old_fb;\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nunsigned long flags;\r\nint ret;\r\nDRM_DEBUG_KMS("fb %d --> fb %d\n",\r\ncrtc->primary->fb->base.id, fb->base.id);\r\nmutex_lock(&drm_dev->struct_mutex);\r\nold_fb = crtc->primary->fb;\r\ncrtc->primary->fb = fb;\r\nret = sti_drm_crtc_mode_set_base(crtc, crtc->x, crtc->y, old_fb);\r\nif (ret) {\r\nDRM_ERROR("failed\n");\r\ncrtc->primary->fb = old_fb;\r\ngoto out;\r\n}\r\nif (event) {\r\nevent->pipe = mixer->id;\r\nret = drm_vblank_get(drm_dev, event->pipe);\r\nif (ret) {\r\nDRM_ERROR("Cannot get vblank\n");\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nif (mixer->pending_event) {\r\ndrm_vblank_put(drm_dev, event->pipe);\r\nret = -EBUSY;\r\n} else {\r\nmixer->pending_event = event;\r\n}\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\n}\r\nout:\r\nmutex_unlock(&drm_dev->struct_mutex);\r\nreturn ret;\r\n}\r\nstatic void sti_drm_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\ndrm_crtc_cleanup(crtc);\r\n}\r\nstatic int sti_drm_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\nreturn 0;\r\n}\r\nint sti_drm_crtc_vblank_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct drm_device *drm_dev;\r\nstruct sti_compositor *compo =\r\ncontainer_of(nb, struct sti_compositor, vtg_vblank_nb);\r\nint *crtc = data;\r\nunsigned long flags;\r\nstruct sti_drm_private *priv;\r\ndrm_dev = compo->mixer[*crtc]->drm_crtc.dev;\r\npriv = drm_dev->dev_private;\r\nif ((event != VTG_TOP_FIELD_EVENT) &&\r\n(event != VTG_BOTTOM_FIELD_EVENT)) {\r\nDRM_ERROR("unknown event: %lu\n", event);\r\nreturn -EINVAL;\r\n}\r\ndrm_handle_vblank(drm_dev, *crtc);\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nif (compo->mixer[*crtc]->pending_event) {\r\ndrm_send_vblank_event(drm_dev, -1,\r\ncompo->mixer[*crtc]->pending_event);\r\ndrm_vblank_put(drm_dev, *crtc);\r\ncompo->mixer[*crtc]->pending_event = NULL;\r\n}\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\nreturn 0;\r\n}\r\nint sti_drm_crtc_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct sti_drm_private *dev_priv = dev->dev_private;\r\nstruct sti_compositor *compo = dev_priv->compo;\r\nstruct notifier_block *vtg_vblank_nb = &compo->vtg_vblank_nb;\r\nif (sti_vtg_register_client(crtc == STI_MIXER_MAIN ?\r\ncompo->vtg_main : compo->vtg_aux,\r\nvtg_vblank_nb, crtc)) {\r\nDRM_ERROR("Cannot register VTG notifier\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid sti_drm_crtc_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct sti_drm_private *priv = dev->dev_private;\r\nstruct sti_compositor *compo = priv->compo;\r\nstruct notifier_block *vtg_vblank_nb = &compo->vtg_vblank_nb;\r\nunsigned long flags;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (sti_vtg_unregister_client(crtc == STI_MIXER_MAIN ?\r\ncompo->vtg_main : compo->vtg_aux, vtg_vblank_nb))\r\nDRM_DEBUG_DRIVER("Warning: cannot unregister VTG notifier\n");\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (compo->mixer[crtc]->pending_event) {\r\ndrm_vblank_put(dev, crtc);\r\ncompo->mixer[crtc]->pending_event = NULL;\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nbool sti_drm_crtc_is_main(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nif (mixer->id == STI_MIXER_MAIN)\r\nreturn true;\r\nreturn false;\r\n}\r\nint sti_drm_crtc_init(struct drm_device *drm_dev, struct sti_mixer *mixer,\r\nstruct drm_plane *primary, struct drm_plane *cursor)\r\n{\r\nstruct drm_crtc *crtc = &mixer->drm_crtc;\r\nint res;\r\nres = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,\r\n&sti_crtc_funcs);\r\nif (res) {\r\nDRM_ERROR("Can not initialze CRTC\n");\r\nreturn -EINVAL;\r\n}\r\ndrm_crtc_helper_add(crtc, &sti_crtc_helper_funcs);\r\nDRM_DEBUG_DRIVER("drm CRTC:%d mapped to %s\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer));\r\nreturn 0;\r\n}
