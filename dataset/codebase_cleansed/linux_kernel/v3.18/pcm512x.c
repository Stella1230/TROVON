static bool pcm512x_readable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase PCM512x_RESET:\r\ncase PCM512x_POWER:\r\ncase PCM512x_MUTE:\r\ncase PCM512x_PLL_EN:\r\ncase PCM512x_SPI_MISO_FUNCTION:\r\ncase PCM512x_DSP:\r\ncase PCM512x_GPIO_EN:\r\ncase PCM512x_BCLK_LRCLK_CFG:\r\ncase PCM512x_DSP_GPIO_INPUT:\r\ncase PCM512x_MASTER_MODE:\r\ncase PCM512x_PLL_REF:\r\ncase PCM512x_PLL_COEFF_0:\r\ncase PCM512x_PLL_COEFF_1:\r\ncase PCM512x_PLL_COEFF_2:\r\ncase PCM512x_PLL_COEFF_3:\r\ncase PCM512x_PLL_COEFF_4:\r\ncase PCM512x_DSP_CLKDIV:\r\ncase PCM512x_DAC_CLKDIV:\r\ncase PCM512x_NCP_CLKDIV:\r\ncase PCM512x_OSR_CLKDIV:\r\ncase PCM512x_MASTER_CLKDIV_1:\r\ncase PCM512x_MASTER_CLKDIV_2:\r\ncase PCM512x_FS_SPEED_MODE:\r\ncase PCM512x_IDAC_1:\r\ncase PCM512x_IDAC_2:\r\ncase PCM512x_ERROR_DETECT:\r\ncase PCM512x_I2S_1:\r\ncase PCM512x_I2S_2:\r\ncase PCM512x_DAC_ROUTING:\r\ncase PCM512x_DSP_PROGRAM:\r\ncase PCM512x_CLKDET:\r\ncase PCM512x_AUTO_MUTE:\r\ncase PCM512x_DIGITAL_VOLUME_1:\r\ncase PCM512x_DIGITAL_VOLUME_2:\r\ncase PCM512x_DIGITAL_VOLUME_3:\r\ncase PCM512x_DIGITAL_MUTE_1:\r\ncase PCM512x_DIGITAL_MUTE_2:\r\ncase PCM512x_DIGITAL_MUTE_3:\r\ncase PCM512x_GPIO_OUTPUT_1:\r\ncase PCM512x_GPIO_OUTPUT_2:\r\ncase PCM512x_GPIO_OUTPUT_3:\r\ncase PCM512x_GPIO_OUTPUT_4:\r\ncase PCM512x_GPIO_OUTPUT_5:\r\ncase PCM512x_GPIO_OUTPUT_6:\r\ncase PCM512x_GPIO_CONTROL_1:\r\ncase PCM512x_GPIO_CONTROL_2:\r\ncase PCM512x_OVERFLOW:\r\ncase PCM512x_RATE_DET_1:\r\ncase PCM512x_RATE_DET_2:\r\ncase PCM512x_RATE_DET_3:\r\ncase PCM512x_RATE_DET_4:\r\ncase PCM512x_ANALOG_MUTE_DET:\r\ncase PCM512x_GPIN:\r\ncase PCM512x_DIGITAL_MUTE_DET:\r\ncase PCM512x_OUTPUT_AMPLITUDE:\r\ncase PCM512x_ANALOG_GAIN_CTRL:\r\ncase PCM512x_UNDERVOLTAGE_PROT:\r\ncase PCM512x_ANALOG_MUTE_CTRL:\r\ncase PCM512x_ANALOG_GAIN_BOOST:\r\ncase PCM512x_VCOM_CTRL_1:\r\ncase PCM512x_VCOM_CTRL_2:\r\ncase PCM512x_CRAM_CTRL:\r\nreturn true;\r\ndefault:\r\nreturn reg < 0xff;\r\n}\r\n}\r\nstatic bool pcm512x_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase PCM512x_PLL_EN:\r\ncase PCM512x_OVERFLOW:\r\ncase PCM512x_RATE_DET_1:\r\ncase PCM512x_RATE_DET_2:\r\ncase PCM512x_RATE_DET_3:\r\ncase PCM512x_RATE_DET_4:\r\ncase PCM512x_ANALOG_MUTE_DET:\r\ncase PCM512x_GPIN:\r\ncase PCM512x_DIGITAL_MUTE_DET:\r\ncase PCM512x_CRAM_CTRL:\r\nreturn true;\r\ndefault:\r\nreturn reg < 0xff;\r\n}\r\n}\r\nstatic int pcm512x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct pcm512x_priv *pcm512x = dev_get_drvdata(codec->dev);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQST, 0);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to remove standby: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQST, PCM512x_RQST);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request standby: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nint pcm512x_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct pcm512x_priv *pcm512x;\r\nint i, ret;\r\npcm512x = devm_kzalloc(dev, sizeof(struct pcm512x_priv), GFP_KERNEL);\r\nif (!pcm512x)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, pcm512x);\r\npcm512x->regmap = regmap;\r\nfor (i = 0; i < ARRAY_SIZE(pcm512x->supplies); i++)\r\npcm512x->supplies[i].supply = pcm512x_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to get supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\npcm512x->supply_nb[0].notifier_call = pcm512x_regulator_event_0;\r\npcm512x->supply_nb[1].notifier_call = pcm512x_regulator_event_1;\r\npcm512x->supply_nb[2].notifier_call = pcm512x_regulator_event_2;\r\nfor (i = 0; i < ARRAY_SIZE(pcm512x->supplies); i++) {\r\nret = regulator_register_notifier(pcm512x->supplies[i].consumer,\r\n&pcm512x->supply_nb[i]);\r\nif (ret != 0) {\r\ndev_err(dev,\r\n"Failed to register regulator notifier: %d\n",\r\nret);\r\n}\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(regmap, PCM512x_RESET,\r\nPCM512x_RSTM | PCM512x_RSTR);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to reset device: %d\n", ret);\r\ngoto err;\r\n}\r\nret = regmap_write(regmap, PCM512x_RESET, 0);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to reset device: %d\n", ret);\r\ngoto err;\r\n}\r\npcm512x->sclk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(pcm512x->sclk)) {\r\nif (PTR_ERR(pcm512x->sclk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_info(dev, "No SCLK, using BCLK: %ld\n",\r\nPTR_ERR(pcm512x->sclk));\r\nregmap_update_bits(regmap, PCM512x_ERROR_DETECT,\r\nPCM512x_IDCH, PCM512x_IDCH);\r\nregmap_update_bits(regmap, PCM512x_PLL_REF,\r\nPCM512x_SREF, PCM512x_SREF);\r\n} else {\r\nret = clk_prepare_enable(pcm512x->sclk);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable SCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQST, PCM512x_RQST);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request standby: %d\n",\r\nret);\r\ngoto err_clk;\r\n}\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_idle(dev);\r\nret = snd_soc_register_codec(dev, &pcm512x_codec_driver,\r\n&pcm512x_dai, 1);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to register CODEC: %d\n", ret);\r\ngoto err_pm;\r\n}\r\nreturn 0;\r\nerr_pm:\r\npm_runtime_disable(dev);\r\nerr_clk:\r\nif (!IS_ERR(pcm512x->sclk))\r\nclk_disable_unprepare(pcm512x->sclk);\r\nerr:\r\nregulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nreturn ret;\r\n}\r\nvoid pcm512x_remove(struct device *dev)\r\n{\r\nstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\r\nsnd_soc_unregister_codec(dev);\r\npm_runtime_disable(dev);\r\nif (!IS_ERR(pcm512x->sclk))\r\nclk_disable_unprepare(pcm512x->sclk);\r\nregulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\n}\r\nstatic int pcm512x_suspend(struct device *dev)\r\n{\r\nstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\r\nint ret;\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQPD, PCM512x_RQPD);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request power down: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to disable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!IS_ERR(pcm512x->sclk))\r\nclk_disable_unprepare(pcm512x->sclk);\r\nreturn 0;\r\n}\r\nstatic int pcm512x_resume(struct device *dev)\r\n{\r\nstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\r\nint ret;\r\nif (!IS_ERR(pcm512x->sclk)) {\r\nret = clk_prepare_enable(pcm512x->sclk);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable SCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(pcm512x->supplies),\r\npcm512x->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(pcm512x->regmap, false);\r\nret = regcache_sync(pcm512x->regmap);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\r\nPCM512x_RQPD, 0);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to remove power down: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
