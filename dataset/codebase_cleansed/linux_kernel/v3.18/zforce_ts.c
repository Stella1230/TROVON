static int zforce_command(struct zforce_ts *ts, u8 cmd)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nchar buf[3];\r\nint ret;\r\ndev_dbg(&client->dev, "%s: 0x%x\n", __func__, cmd);\r\nbuf[0] = FRAME_START;\r\nbuf[1] = 1;\r\nbuf[2] = cmd;\r\nmutex_lock(&ts->access_mutex);\r\nret = i2c_master_send(client, &buf[0], ARRAY_SIZE(buf));\r\nmutex_unlock(&ts->access_mutex);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "i2c send data request error: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zforce_send_wait(struct zforce_ts *ts, const char *buf, int len)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint ret;\r\nret = mutex_trylock(&ts->command_mutex);\r\nif (!ret) {\r\ndev_err(&client->dev, "already waiting for a command\n");\r\nreturn -EBUSY;\r\n}\r\ndev_dbg(&client->dev, "sending %d bytes for command 0x%x\n",\r\nbuf[1], buf[2]);\r\nts->command_waiting = buf[2];\r\nmutex_lock(&ts->access_mutex);\r\nret = i2c_master_send(client, buf, len);\r\nmutex_unlock(&ts->access_mutex);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "i2c send data request error: %d\n", ret);\r\ngoto unlock;\r\n}\r\ndev_dbg(&client->dev, "waiting for result for command 0x%x\n", buf[2]);\r\nif (wait_for_completion_timeout(&ts->command_done, WAIT_TIMEOUT) == 0) {\r\nret = -ETIME;\r\ngoto unlock;\r\n}\r\nret = ts->command_result;\r\nunlock:\r\nmutex_unlock(&ts->command_mutex);\r\nreturn ret;\r\n}\r\nstatic int zforce_command_wait(struct zforce_ts *ts, u8 cmd)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nchar buf[3];\r\nint ret;\r\ndev_dbg(&client->dev, "%s: 0x%x\n", __func__, cmd);\r\nbuf[0] = FRAME_START;\r\nbuf[1] = 1;\r\nbuf[2] = cmd;\r\nret = zforce_send_wait(ts, &buf[0], ARRAY_SIZE(buf));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "i2c send data request error: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zforce_resolution(struct zforce_ts *ts, u16 x, u16 y)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nchar buf[7] = { FRAME_START, 5, COMMAND_RESOLUTION,\r\n(x & 0xff), ((x >> 8) & 0xff),\r\n(y & 0xff), ((y >> 8) & 0xff) };\r\ndev_dbg(&client->dev, "set resolution to (%d,%d)\n", x, y);\r\nreturn zforce_send_wait(ts, &buf[0], ARRAY_SIZE(buf));\r\n}\r\nstatic int zforce_scan_frequency(struct zforce_ts *ts, u16 idle, u16 finger,\r\nu16 stylus)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nchar buf[9] = { FRAME_START, 7, COMMAND_SCANFREQ,\r\n(idle & 0xff), ((idle >> 8) & 0xff),\r\n(finger & 0xff), ((finger >> 8) & 0xff),\r\n(stylus & 0xff), ((stylus >> 8) & 0xff) };\r\ndev_dbg(&client->dev,\r\n"set scan frequency to (idle: %d, finger: %d, stylus: %d)\n",\r\nidle, finger, stylus);\r\nreturn zforce_send_wait(ts, &buf[0], ARRAY_SIZE(buf));\r\n}\r\nstatic int zforce_setconfig(struct zforce_ts *ts, char b1)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nchar buf[7] = { FRAME_START, 5, COMMAND_SETCONFIG,\r\nb1, 0, 0, 0 };\r\ndev_dbg(&client->dev, "set config to (%d)\n", b1);\r\nreturn zforce_send_wait(ts, &buf[0], ARRAY_SIZE(buf));\r\n}\r\nstatic int zforce_start(struct zforce_ts *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nconst struct zforce_ts_platdata *pdata = ts->pdata;\r\nint ret;\r\ndev_dbg(&client->dev, "starting device\n");\r\nret = zforce_command_wait(ts, COMMAND_INITIALIZE);\r\nif (ret) {\r\ndev_err(&client->dev, "Unable to initialize, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = zforce_resolution(ts, pdata->x_max, pdata->y_max);\r\nif (ret) {\r\ndev_err(&client->dev, "Unable to set resolution, %d\n", ret);\r\ngoto error;\r\n}\r\nret = zforce_scan_frequency(ts, 10, 50, 50);\r\nif (ret) {\r\ndev_err(&client->dev, "Unable to set scan frequency, %d\n",\r\nret);\r\ngoto error;\r\n}\r\nret = zforce_setconfig(ts, SETCONFIG_DUALTOUCH);\r\nif (ret) {\r\ndev_err(&client->dev, "Unable to set config\n");\r\ngoto error;\r\n}\r\nret = zforce_command(ts, COMMAND_DATAREQUEST);\r\nif (ret) {\r\ndev_err(&client->dev, "Unable to request data\n");\r\ngoto error;\r\n}\r\nmsleep(200);\r\nreturn 0;\r\nerror:\r\nzforce_command_wait(ts, COMMAND_DEACTIVATE);\r\nreturn ret;\r\n}\r\nstatic int zforce_stop(struct zforce_ts *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint ret;\r\ndev_dbg(&client->dev, "stopping device\n");\r\nret = zforce_command_wait(ts, COMMAND_DEACTIVATE);\r\nif (ret != 0) {\r\ndev_err(&client->dev, "could not deactivate device, %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zforce_touch_event(struct zforce_ts *ts, u8 *payload)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nconst struct zforce_ts_platdata *pdata = ts->pdata;\r\nstruct zforce_point point;\r\nint count, i, num = 0;\r\ncount = payload[0];\r\nif (count > ZFORCE_REPORT_POINTS) {\r\ndev_warn(&client->dev,\r\n"too many coordinates %d, expected max %d\n",\r\ncount, ZFORCE_REPORT_POINTS);\r\ncount = ZFORCE_REPORT_POINTS;\r\n}\r\nfor (i = 0; i < count; i++) {\r\npoint.coord_x =\r\npayload[9 * i + 2] << 8 | payload[9 * i + 1];\r\npoint.coord_y =\r\npayload[9 * i + 4] << 8 | payload[9 * i + 3];\r\nif (point.coord_x > pdata->x_max ||\r\npoint.coord_y > pdata->y_max) {\r\ndev_warn(&client->dev, "coordinates (%d,%d) invalid\n",\r\npoint.coord_x, point.coord_y);\r\npoint.coord_x = point.coord_y = 0;\r\n}\r\npoint.state = payload[9 * i + 5] & 0x03;\r\npoint.id = (payload[9 * i + 5] & 0xfc) >> 2;\r\npoint.area_major = max(payload[9 * i + 6],\r\npayload[9 * i + 7]);\r\npoint.area_minor = min(payload[9 * i + 6],\r\npayload[9 * i + 7]);\r\npoint.orientation = payload[9 * i + 6] > payload[9 * i + 7];\r\npoint.pressure = payload[9 * i + 8];\r\npoint.prblty = payload[9 * i + 9];\r\ndev_dbg(&client->dev,\r\n"point %d/%d: state %d, id %d, pressure %d, prblty %d, x %d, y %d, amajor %d, aminor %d, ori %d\n",\r\ni, count, point.state, point.id,\r\npoint.pressure, point.prblty,\r\npoint.coord_x, point.coord_y,\r\npoint.area_major, point.area_minor,\r\npoint.orientation);\r\ninput_mt_slot(ts->input, point.id - 1);\r\ninput_mt_report_slot_state(ts->input, MT_TOOL_FINGER,\r\npoint.state != STATE_UP);\r\nif (point.state != STATE_UP) {\r\ninput_report_abs(ts->input, ABS_MT_POSITION_X,\r\npoint.coord_x);\r\ninput_report_abs(ts->input, ABS_MT_POSITION_Y,\r\npoint.coord_y);\r\ninput_report_abs(ts->input, ABS_MT_TOUCH_MAJOR,\r\npoint.area_major);\r\ninput_report_abs(ts->input, ABS_MT_TOUCH_MINOR,\r\npoint.area_minor);\r\ninput_report_abs(ts->input, ABS_MT_ORIENTATION,\r\npoint.orientation);\r\nnum++;\r\n}\r\n}\r\ninput_mt_sync_frame(ts->input);\r\ninput_mt_report_finger_count(ts->input, num);\r\ninput_sync(ts->input);\r\nreturn 0;\r\n}\r\nstatic int zforce_read_packet(struct zforce_ts *ts, u8 *buf)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nint ret;\r\nmutex_lock(&ts->access_mutex);\r\nret = i2c_master_recv(client, buf, 2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "error reading header: %d\n", ret);\r\ngoto unlock;\r\n}\r\nif (buf[PAYLOAD_HEADER] != FRAME_START) {\r\ndev_err(&client->dev, "invalid frame start: %d\n", buf[0]);\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nif (buf[PAYLOAD_LENGTH] == 0) {\r\ndev_err(&client->dev, "invalid payload length: %d\n",\r\nbuf[PAYLOAD_LENGTH]);\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nret = i2c_master_recv(client, &buf[PAYLOAD_BODY], buf[PAYLOAD_LENGTH]);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "error reading payload: %d\n", ret);\r\ngoto unlock;\r\n}\r\ndev_dbg(&client->dev, "read %d bytes for response command 0x%x\n",\r\nbuf[PAYLOAD_LENGTH], buf[PAYLOAD_BODY]);\r\nunlock:\r\nmutex_unlock(&ts->access_mutex);\r\nreturn ret;\r\n}\r\nstatic void zforce_complete(struct zforce_ts *ts, int cmd, int result)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nif (ts->command_waiting == cmd) {\r\ndev_dbg(&client->dev, "completing command 0x%x\n", cmd);\r\nts->command_result = result;\r\ncomplete(&ts->command_done);\r\n} else {\r\ndev_dbg(&client->dev, "command %d not for us\n", cmd);\r\n}\r\n}\r\nstatic irqreturn_t zforce_irq(int irq, void *dev_id)\r\n{\r\nstruct zforce_ts *ts = dev_id;\r\nstruct i2c_client *client = ts->client;\r\nif (ts->suspended && device_may_wakeup(&client->dev))\r\npm_wakeup_event(&client->dev, 500);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t zforce_irq_thread(int irq, void *dev_id)\r\n{\r\nstruct zforce_ts *ts = dev_id;\r\nstruct i2c_client *client = ts->client;\r\nconst struct zforce_ts_platdata *pdata = ts->pdata;\r\nint ret;\r\nu8 payload_buffer[FRAME_MAXSIZE];\r\nu8 *payload;\r\nif (ts->suspended) {\r\nmsleep(20);\r\nreturn IRQ_HANDLED;\r\n}\r\ndev_dbg(&client->dev, "handling interrupt\n");\r\nif (!ts->suspending && device_may_wakeup(&client->dev))\r\npm_stay_awake(&client->dev);\r\nwhile (!gpio_get_value(pdata->gpio_int)) {\r\nret = zforce_read_packet(ts, payload_buffer);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"could not read packet, ret: %d\n", ret);\r\nbreak;\r\n}\r\npayload = &payload_buffer[PAYLOAD_BODY];\r\nswitch (payload[RESPONSE_ID]) {\r\ncase NOTIFICATION_TOUCH:\r\nif (ts->suspending && device_may_wakeup(&client->dev))\r\npm_wakeup_event(&client->dev, 500);\r\nzforce_touch_event(ts, &payload[RESPONSE_DATA]);\r\nbreak;\r\ncase NOTIFICATION_BOOTCOMPLETE:\r\nts->boot_complete = payload[RESPONSE_DATA];\r\nzforce_complete(ts, payload[RESPONSE_ID], 0);\r\nbreak;\r\ncase RESPONSE_INITIALIZE:\r\ncase RESPONSE_DEACTIVATE:\r\ncase RESPONSE_SETCONFIG:\r\ncase RESPONSE_RESOLUTION:\r\ncase RESPONSE_SCANFREQ:\r\nzforce_complete(ts, payload[RESPONSE_ID],\r\npayload[RESPONSE_DATA]);\r\nbreak;\r\ncase RESPONSE_STATUS:\r\nts->version_major = (payload[RESPONSE_DATA + 1] << 8) |\r\npayload[RESPONSE_DATA];\r\nts->version_minor = (payload[RESPONSE_DATA + 3] << 8) |\r\npayload[RESPONSE_DATA + 2];\r\nts->version_build = (payload[RESPONSE_DATA + 5] << 8) |\r\npayload[RESPONSE_DATA + 4];\r\nts->version_rev = (payload[RESPONSE_DATA + 7] << 8) |\r\npayload[RESPONSE_DATA + 6];\r\ndev_dbg(&ts->client->dev,\r\n"Firmware Version %04x:%04x %04x:%04x\n",\r\nts->version_major, ts->version_minor,\r\nts->version_build, ts->version_rev);\r\nzforce_complete(ts, payload[RESPONSE_ID], 0);\r\nbreak;\r\ncase NOTIFICATION_INVALID_COMMAND:\r\ndev_err(&ts->client->dev, "invalid command: 0x%x\n",\r\npayload[RESPONSE_DATA]);\r\nbreak;\r\ndefault:\r\ndev_err(&ts->client->dev,\r\n"unrecognized response id: 0x%x\n",\r\npayload[RESPONSE_ID]);\r\nbreak;\r\n}\r\n}\r\nif (!ts->suspending && device_may_wakeup(&client->dev))\r\npm_relax(&client->dev);\r\ndev_dbg(&client->dev, "finished interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int zforce_input_open(struct input_dev *dev)\r\n{\r\nstruct zforce_ts *ts = input_get_drvdata(dev);\r\nint ret;\r\nret = zforce_start(ts);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void zforce_input_close(struct input_dev *dev)\r\n{\r\nstruct zforce_ts *ts = input_get_drvdata(dev);\r\nstruct i2c_client *client = ts->client;\r\nint ret;\r\nret = zforce_stop(ts);\r\nif (ret)\r\ndev_warn(&client->dev, "stopping zforce failed\n");\r\nreturn;\r\n}\r\nstatic int zforce_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct zforce_ts *ts = i2c_get_clientdata(client);\r\nstruct input_dev *input = ts->input;\r\nint ret = 0;\r\nmutex_lock(&input->mutex);\r\nts->suspending = true;\r\nif (device_may_wakeup(&client->dev)) {\r\ndev_dbg(&client->dev, "suspend while being a wakeup source\n");\r\nif (!input->users) {\r\nret = zforce_start(ts);\r\nif (ret)\r\ngoto unlock;\r\n}\r\nenable_irq_wake(client->irq);\r\n} else if (input->users) {\r\ndev_dbg(&client->dev,\r\n"suspend without being a wakeup source\n");\r\nret = zforce_stop(ts);\r\nif (ret)\r\ngoto unlock;\r\ndisable_irq(client->irq);\r\n}\r\nts->suspended = true;\r\nunlock:\r\nts->suspending = false;\r\nmutex_unlock(&input->mutex);\r\nreturn ret;\r\n}\r\nstatic int zforce_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct zforce_ts *ts = i2c_get_clientdata(client);\r\nstruct input_dev *input = ts->input;\r\nint ret = 0;\r\nmutex_lock(&input->mutex);\r\nts->suspended = false;\r\nif (device_may_wakeup(&client->dev)) {\r\ndev_dbg(&client->dev, "resume from being a wakeup source\n");\r\ndisable_irq_wake(client->irq);\r\nif (!input->users) {\r\nret = zforce_stop(ts);\r\nif (ret)\r\ngoto unlock;\r\n}\r\n} else if (input->users) {\r\ndev_dbg(&client->dev, "resume without being a wakeup source\n");\r\nenable_irq(client->irq);\r\nret = zforce_start(ts);\r\nif (ret < 0)\r\ngoto unlock;\r\n}\r\nunlock:\r\nmutex_unlock(&input->mutex);\r\nreturn ret;\r\n}\r\nstatic void zforce_reset(void *data)\r\n{\r\nstruct zforce_ts *ts = data;\r\ngpio_set_value(ts->pdata->gpio_rst, 0);\r\nudelay(10);\r\nif (!IS_ERR(ts->reg_vdd))\r\nregulator_disable(ts->reg_vdd);\r\n}\r\nstatic struct zforce_ts_platdata *zforce_parse_dt(struct device *dev)\r\n{\r\nstruct zforce_ts_platdata *pdata;\r\nstruct device_node *np = dev->of_node;\r\nif (!np)\r\nreturn ERR_PTR(-ENOENT);\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(dev, "failed to allocate platform data\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npdata->gpio_int = of_get_gpio(np, 0);\r\nif (!gpio_is_valid(pdata->gpio_int)) {\r\ndev_err(dev, "failed to get interrupt gpio\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata->gpio_rst = of_get_gpio(np, 1);\r\nif (!gpio_is_valid(pdata->gpio_rst)) {\r\ndev_err(dev, "failed to get reset gpio\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(np, "x-size", &pdata->x_max)) {\r\ndev_err(dev, "failed to get x-size property\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(np, "y-size", &pdata->y_max)) {\r\ndev_err(dev, "failed to get y-size property\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn pdata;\r\n}\r\nstatic int zforce_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct zforce_ts_platdata *pdata = dev_get_platdata(&client->dev);\r\nstruct zforce_ts *ts;\r\nstruct input_dev *input_dev;\r\nint ret;\r\nif (!pdata) {\r\npdata = zforce_parse_dt(&client->dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nts = devm_kzalloc(&client->dev, sizeof(struct zforce_ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nret = devm_gpio_request_one(&client->dev, pdata->gpio_int, GPIOF_IN,\r\n"zforce_ts_int");\r\nif (ret) {\r\ndev_err(&client->dev, "request of gpio %d failed, %d\n",\r\npdata->gpio_int, ret);\r\nreturn ret;\r\n}\r\nret = devm_gpio_request_one(&client->dev, pdata->gpio_rst,\r\nGPIOF_OUT_INIT_LOW, "zforce_ts_rst");\r\nif (ret) {\r\ndev_err(&client->dev, "request of gpio %d failed, %d\n",\r\npdata->gpio_rst, ret);\r\nreturn ret;\r\n}\r\nts->reg_vdd = devm_regulator_get_optional(&client->dev, "vdd");\r\nif (IS_ERR(ts->reg_vdd)) {\r\nret = PTR_ERR(ts->reg_vdd);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\n} else {\r\nret = regulator_enable(ts->reg_vdd);\r\nif (ret)\r\nreturn ret;\r\nudelay(100);\r\n}\r\nret = devm_add_action(&client->dev, zforce_reset, ts);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to register reset action, %d\n",\r\nret);\r\nif (!IS_ERR(ts->reg_vdd))\r\nregulator_disable(ts->reg_vdd);\r\nreturn ret;\r\n}\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input0", dev_name(&client->dev));\r\ninput_dev = devm_input_allocate_device(&client->dev);\r\nif (!input_dev) {\r\ndev_err(&client->dev, "could not allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&ts->access_mutex);\r\nmutex_init(&ts->command_mutex);\r\nts->pdata = pdata;\r\nts->client = client;\r\nts->input = input_dev;\r\ninput_dev->name = "Neonode zForce touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->open = zforce_input_open;\r\ninput_dev->close = zforce_input_close;\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(EV_SYN, input_dev->evbit);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,\r\npdata->x_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,\r\npdata->y_max, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0,\r\nZFORCE_MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0,\r\nZFORCE_MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);\r\ninput_mt_init_slots(input_dev, ZFORCE_REPORT_POINTS, INPUT_MT_DIRECT);\r\ninput_set_drvdata(ts->input, ts);\r\ninit_completion(&ts->command_done);\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nzforce_irq, zforce_irq_thread,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\ninput_dev->name, ts);\r\nif (ret) {\r\ndev_err(&client->dev, "irq %d request failed\n", client->irq);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, ts);\r\ngpio_set_value(pdata->gpio_rst, 1);\r\nts->command_waiting = NOTIFICATION_BOOTCOMPLETE;\r\nif (wait_for_completion_timeout(&ts->command_done, WAIT_TIMEOUT) == 0)\r\ndev_warn(&client->dev, "bootcomplete timed out\n");\r\nret = zforce_command_wait(ts, COMMAND_INITIALIZE);\r\nif (ret) {\r\ndev_err(&client->dev, "unable to initialize, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = zforce_command_wait(ts, COMMAND_STATUS);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "couldn't get status, %d\n", ret);\r\nzforce_stop(ts);\r\nreturn ret;\r\n}\r\nret = zforce_stop(ts);\r\nif (ret < 0)\r\nreturn ret;\r\ndevice_set_wakeup_capable(&client->dev, true);\r\nret = input_register_device(input_dev);\r\nif (ret) {\r\ndev_err(&client->dev, "could not register input device, %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
