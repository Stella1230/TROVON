static int pch_gbe_validate_option(int *value,\r\nconst struct pch_gbe_option *opt,\r\nstruct pch_gbe_adapter *adapter)\r\n{\r\nif (*value == OPTION_UNSET) {\r\n*value = opt->def;\r\nreturn 0;\r\n}\r\nswitch (opt->type) {\r\ncase enable_option:\r\nswitch (*value) {\r\ncase OPTION_ENABLED:\r\nnetdev_dbg(adapter->netdev, "%s Enabled\n", opt->name);\r\nreturn 0;\r\ncase OPTION_DISABLED:\r\nnetdev_dbg(adapter->netdev, "%s Disabled\n", opt->name);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase range_option:\r\nif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\r\nnetdev_dbg(adapter->netdev, "%s set to %i\n",\r\nopt->name, *value);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase list_option: {\r\nint i;\r\nconst struct pch_gbe_opt_list *ent;\r\nfor (i = 0; i < opt->arg.l.nr; i++) {\r\nent = &opt->arg.l.p[i];\r\nif (*value == ent->i) {\r\nif (ent->str[0] != '\0')\r\nnetdev_dbg(adapter->netdev, "%s\n",\r\nent->str);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nnetdev_dbg(adapter->netdev, "Invalid %s value specified (%i) %s\n",\r\nopt->name, *value, opt->err);\r\n*value = opt->def;\r\nreturn -1;\r\n}\r\nstatic void pch_gbe_check_copper_options(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nint speed, dplx;\r\n{\r\nstatic const struct pch_gbe_option opt = {\r\n.type = list_option,\r\n.name = "Speed",\r\n.err = "parameter ignored",\r\n.def = 0,\r\n.arg = { .l = { .nr = (int)ARRAY_SIZE(speed_list),\r\n.p = speed_list } }\r\n};\r\nspeed = Speed;\r\npch_gbe_validate_option(&speed, &opt, adapter);\r\n}\r\n{\r\nstatic const struct pch_gbe_option opt = {\r\n.type = list_option,\r\n.name = "Duplex",\r\n.err = "parameter ignored",\r\n.def = 0,\r\n.arg = { .l = { .nr = (int)ARRAY_SIZE(dplx_list),\r\n.p = dplx_list } }\r\n};\r\ndplx = Duplex;\r\npch_gbe_validate_option(&dplx, &opt, adapter);\r\n}\r\n{\r\nstatic const struct pch_gbe_option opt = {\r\n.type = list_option,\r\n.name = "AutoNeg",\r\n.err = "parameter ignored",\r\n.def = PCH_AUTONEG_ADVERTISE_DEFAULT,\r\n.arg = { .l = { .nr = (int)ARRAY_SIZE(an_list),\r\n.p = an_list} }\r\n};\r\nif (speed || dplx) {\r\nnetdev_dbg(adapter->netdev,\r\n"AutoNeg specified along with Speed or Duplex, AutoNeg parameter ignored\n");\r\nhw->phy.autoneg_advertised = opt.def;\r\n} else {\r\nint tmp = AutoNeg;\r\npch_gbe_validate_option(&tmp, &opt, adapter);\r\nhw->phy.autoneg_advertised = tmp;\r\n}\r\n}\r\nswitch (speed + dplx) {\r\ncase 0:\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 1;\r\nif ((speed || dplx))\r\nnetdev_dbg(adapter->netdev,\r\n"Speed and duplex autonegotiation enabled\n");\r\nhw->mac.link_speed = SPEED_10;\r\nhw->mac.link_duplex = DUPLEX_HALF;\r\nbreak;\r\ncase HALF_DUPLEX:\r\nnetdev_dbg(adapter->netdev,\r\n"Half Duplex specified without Speed\n");\r\nnetdev_dbg(adapter->netdev,\r\n"Using Autonegotiation at Half Duplex only\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 1;\r\nhw->phy.autoneg_advertised = PHY_ADVERTISE_10_HALF |\r\nPHY_ADVERTISE_100_HALF;\r\nhw->mac.link_speed = SPEED_10;\r\nhw->mac.link_duplex = DUPLEX_HALF;\r\nbreak;\r\ncase FULL_DUPLEX:\r\nnetdev_dbg(adapter->netdev,\r\n"Full Duplex specified without Speed\n");\r\nnetdev_dbg(adapter->netdev,\r\n"Using Autonegotiation at Full Duplex only\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 1;\r\nhw->phy.autoneg_advertised = PHY_ADVERTISE_10_FULL |\r\nPHY_ADVERTISE_100_FULL |\r\nPHY_ADVERTISE_1000_FULL;\r\nhw->mac.link_speed = SPEED_10;\r\nhw->mac.link_duplex = DUPLEX_FULL;\r\nbreak;\r\ncase SPEED_10:\r\nnetdev_dbg(adapter->netdev,\r\n"10 Mbps Speed specified without Duplex\n");\r\nnetdev_dbg(adapter->netdev,\r\n"Using Autonegotiation at 10 Mbps only\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 1;\r\nhw->phy.autoneg_advertised = PHY_ADVERTISE_10_HALF |\r\nPHY_ADVERTISE_10_FULL;\r\nhw->mac.link_speed = SPEED_10;\r\nhw->mac.link_duplex = DUPLEX_HALF;\r\nbreak;\r\ncase SPEED_10 + HALF_DUPLEX:\r\nnetdev_dbg(adapter->netdev, "Forcing to 10 Mbps Half Duplex\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 0;\r\nhw->phy.autoneg_advertised = 0;\r\nhw->mac.link_speed = SPEED_10;\r\nhw->mac.link_duplex = DUPLEX_HALF;\r\nbreak;\r\ncase SPEED_10 + FULL_DUPLEX:\r\nnetdev_dbg(adapter->netdev, "Forcing to 10 Mbps Full Duplex\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 0;\r\nhw->phy.autoneg_advertised = 0;\r\nhw->mac.link_speed = SPEED_10;\r\nhw->mac.link_duplex = DUPLEX_FULL;\r\nbreak;\r\ncase SPEED_100:\r\nnetdev_dbg(adapter->netdev,\r\n"100 Mbps Speed specified without Duplex\n");\r\nnetdev_dbg(adapter->netdev,\r\n"Using Autonegotiation at 100 Mbps only\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 1;\r\nhw->phy.autoneg_advertised = PHY_ADVERTISE_100_HALF |\r\nPHY_ADVERTISE_100_FULL;\r\nhw->mac.link_speed = SPEED_100;\r\nhw->mac.link_duplex = DUPLEX_HALF;\r\nbreak;\r\ncase SPEED_100 + HALF_DUPLEX:\r\nnetdev_dbg(adapter->netdev,\r\n"Forcing to 100 Mbps Half Duplex\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 0;\r\nhw->phy.autoneg_advertised = 0;\r\nhw->mac.link_speed = SPEED_100;\r\nhw->mac.link_duplex = DUPLEX_HALF;\r\nbreak;\r\ncase SPEED_100 + FULL_DUPLEX:\r\nnetdev_dbg(adapter->netdev,\r\n"Forcing to 100 Mbps Full Duplex\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 0;\r\nhw->phy.autoneg_advertised = 0;\r\nhw->mac.link_speed = SPEED_100;\r\nhw->mac.link_duplex = DUPLEX_FULL;\r\nbreak;\r\ncase SPEED_1000:\r\nnetdev_dbg(adapter->netdev,\r\n"1000 Mbps Speed specified without Duplex\n");\r\ngoto full_duplex_only;\r\ncase SPEED_1000 + HALF_DUPLEX:\r\nnetdev_dbg(adapter->netdev,\r\n"Half Duplex is not supported at 1000 Mbps\n");\r\ncase SPEED_1000 + FULL_DUPLEX:\r\nfull_duplex_only:\r\nnetdev_dbg(adapter->netdev,\r\n"Using Autonegotiation at 1000 Mbps Full Duplex only\n");\r\nhw->mac.autoneg = hw->mac.fc_autoneg = 1;\r\nhw->phy.autoneg_advertised = PHY_ADVERTISE_1000_FULL;\r\nhw->mac.link_speed = SPEED_1000;\r\nhw->mac.link_duplex = DUPLEX_FULL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nvoid pch_gbe_check_options(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nstruct net_device *dev = adapter->netdev;\r\nint val;\r\n{\r\nstatic const struct pch_gbe_option opt = {\r\n.type = range_option,\r\n.name = "Transmit Descriptors",\r\n.err = "using default of "\r\n__MODULE_STRING(PCH_GBE_DEFAULT_TXD),\r\n.def = PCH_GBE_DEFAULT_TXD,\r\n.arg = { .r = { .min = PCH_GBE_MIN_TXD,\r\n.max = PCH_GBE_MAX_TXD } }\r\n};\r\nstruct pch_gbe_tx_ring *tx_ring = adapter->tx_ring;\r\ntx_ring->count = TxDescriptors;\r\npch_gbe_validate_option(&tx_ring->count, &opt, adapter);\r\ntx_ring->count = roundup(tx_ring->count,\r\nPCH_GBE_TX_DESC_MULTIPLE);\r\n}\r\n{\r\nstatic const struct pch_gbe_option opt = {\r\n.type = range_option,\r\n.name = "Receive Descriptors",\r\n.err = "using default of "\r\n__MODULE_STRING(PCH_GBE_DEFAULT_RXD),\r\n.def = PCH_GBE_DEFAULT_RXD,\r\n.arg = { .r = { .min = PCH_GBE_MIN_RXD,\r\n.max = PCH_GBE_MAX_RXD } }\r\n};\r\nstruct pch_gbe_rx_ring *rx_ring = adapter->rx_ring;\r\nrx_ring->count = RxDescriptors;\r\npch_gbe_validate_option(&rx_ring->count, &opt, adapter);\r\nrx_ring->count = roundup(rx_ring->count,\r\nPCH_GBE_RX_DESC_MULTIPLE);\r\n}\r\n{\r\nstatic const struct pch_gbe_option opt = {\r\n.type = enable_option,\r\n.name = "Checksum Offload",\r\n.err = "defaulting to Enabled",\r\n.def = PCH_GBE_DEFAULT_RX_CSUM\r\n};\r\nval = XsumRX;\r\npch_gbe_validate_option(&val, &opt, adapter);\r\nif (!val)\r\ndev->features &= ~NETIF_F_RXCSUM;\r\n}\r\n{\r\nstatic const struct pch_gbe_option opt = {\r\n.type = enable_option,\r\n.name = "Checksum Offload",\r\n.err = "defaulting to Enabled",\r\n.def = PCH_GBE_DEFAULT_TX_CSUM\r\n};\r\nval = XsumTX;\r\npch_gbe_validate_option(&val, &opt, adapter);\r\nif (!val)\r\ndev->features &= ~NETIF_F_ALL_CSUM;\r\n}\r\n{\r\nstatic const struct pch_gbe_option opt = {\r\n.type = list_option,\r\n.name = "Flow Control",\r\n.err = "reading default settings from EEPROM",\r\n.def = PCH_GBE_FC_DEFAULT,\r\n.arg = { .l = { .nr = (int)ARRAY_SIZE(fc_list),\r\n.p = fc_list } }\r\n};\r\nint tmp = FlowControl;\r\npch_gbe_validate_option(&tmp, &opt, adapter);\r\nhw->mac.fc = tmp;\r\n}\r\npch_gbe_check_copper_options(adapter);\r\n}
