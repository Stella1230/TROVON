static irqreturn_t brcmf_sdiod_oob_irqhandler(int irq, void *dev_id)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev_id);\r\nstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\r\nbrcmf_dbg(INTR, "OOB intr triggered\n");\r\nif (sdiodev->irq_en) {\r\ndisable_irq_nosync(irq);\r\nsdiodev->irq_en = false;\r\n}\r\nbrcmf_sdio_isr(sdiodev->bus);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void brcmf_sdiod_ib_irqhandler(struct sdio_func *func)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(&func->dev);\r\nstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\r\nbrcmf_dbg(INTR, "IB intr triggered\n");\r\nbrcmf_sdio_isr(sdiodev->bus);\r\n}\r\nstatic void brcmf_sdiod_dummy_irqhandler(struct sdio_func *func)\r\n{\r\n}\r\nstatic bool brcmf_sdiod_pm_resume_error(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nbool is_err = false;\r\n#ifdef CONFIG_PM_SLEEP\r\nis_err = atomic_read(&sdiodev->suspend);\r\n#endif\r\nreturn is_err;\r\n}\r\nstatic void brcmf_sdiod_pm_resume_wait(struct brcmf_sdio_dev *sdiodev,\r\nwait_queue_head_t *wq)\r\n{\r\n#ifdef CONFIG_PM_SLEEP\r\nint retry = 0;\r\nwhile (atomic_read(&sdiodev->suspend) && retry++ != 30)\r\nwait_event_timeout(*wq, false, HZ/100);\r\n#endif\r\n}\r\nint brcmf_sdiod_intr_register(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nint ret = 0;\r\nu8 data;\r\nu32 addr, gpiocontrol;\r\nunsigned long flags;\r\nif ((sdiodev->pdata) && (sdiodev->pdata->oob_irq_supported)) {\r\nbrcmf_dbg(SDIO, "Enter, register OOB IRQ %d\n",\r\nsdiodev->pdata->oob_irq_nr);\r\nret = request_irq(sdiodev->pdata->oob_irq_nr,\r\nbrcmf_sdiod_oob_irqhandler,\r\nsdiodev->pdata->oob_irq_flags,\r\n"brcmf_oob_intr",\r\n&sdiodev->func[1]->dev);\r\nif (ret != 0) {\r\nbrcmf_err("request_irq failed %d\n", ret);\r\nreturn ret;\r\n}\r\nsdiodev->oob_irq_requested = true;\r\nspin_lock_init(&sdiodev->irq_en_lock);\r\nspin_lock_irqsave(&sdiodev->irq_en_lock, flags);\r\nsdiodev->irq_en = true;\r\nspin_unlock_irqrestore(&sdiodev->irq_en_lock, flags);\r\nret = enable_irq_wake(sdiodev->pdata->oob_irq_nr);\r\nif (ret != 0) {\r\nbrcmf_err("enable_irq_wake failed %d\n", ret);\r\nreturn ret;\r\n}\r\nsdiodev->irq_wake = true;\r\nsdio_claim_host(sdiodev->func[1]);\r\nif (sdiodev->bus_if->chip == BRCM_CC_43362_CHIP_ID) {\r\naddr = CORE_CC_REG(SI_ENUM_BASE, gpiocontrol);\r\ngpiocontrol = brcmf_sdiod_regrl(sdiodev, addr, &ret);\r\ngpiocontrol |= 0x2;\r\nbrcmf_sdiod_regwl(sdiodev, addr, gpiocontrol, &ret);\r\nbrcmf_sdiod_regwb(sdiodev, SBSDIO_GPIO_SELECT, 0xf,\r\n&ret);\r\nbrcmf_sdiod_regwb(sdiodev, SBSDIO_GPIO_OUT, 0, &ret);\r\nbrcmf_sdiod_regwb(sdiodev, SBSDIO_GPIO_EN, 0x2, &ret);\r\n}\r\ndata = brcmf_sdiod_regrb(sdiodev, SDIO_CCCR_IENx, &ret);\r\ndata |= 1 << SDIO_FUNC_1 | 1 << SDIO_FUNC_2 | 1;\r\nbrcmf_sdiod_regwb(sdiodev, SDIO_CCCR_IENx, data, &ret);\r\ndata = SDIO_SEPINT_MASK | SDIO_SEPINT_OE;\r\nif (sdiodev->pdata->oob_irq_flags & IRQF_TRIGGER_HIGH)\r\ndata |= SDIO_SEPINT_ACT_HI;\r\nbrcmf_sdiod_regwb(sdiodev, SDIO_CCCR_BRCM_SEPINT, data, &ret);\r\nsdio_release_host(sdiodev->func[1]);\r\n} else {\r\nbrcmf_dbg(SDIO, "Entering\n");\r\nsdio_claim_host(sdiodev->func[1]);\r\nsdio_claim_irq(sdiodev->func[1], brcmf_sdiod_ib_irqhandler);\r\nsdio_claim_irq(sdiodev->func[2], brcmf_sdiod_dummy_irqhandler);\r\nsdio_release_host(sdiodev->func[1]);\r\n}\r\nreturn 0;\r\n}\r\nint brcmf_sdiod_intr_unregister(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nbrcmf_dbg(SDIO, "Entering\n");\r\nif ((sdiodev->pdata) && (sdiodev->pdata->oob_irq_supported)) {\r\nsdio_claim_host(sdiodev->func[1]);\r\nbrcmf_sdiod_regwb(sdiodev, SDIO_CCCR_BRCM_SEPINT, 0, NULL);\r\nbrcmf_sdiod_regwb(sdiodev, SDIO_CCCR_IENx, 0, NULL);\r\nsdio_release_host(sdiodev->func[1]);\r\nif (sdiodev->oob_irq_requested) {\r\nsdiodev->oob_irq_requested = false;\r\nif (sdiodev->irq_wake) {\r\ndisable_irq_wake(sdiodev->pdata->oob_irq_nr);\r\nsdiodev->irq_wake = false;\r\n}\r\nfree_irq(sdiodev->pdata->oob_irq_nr,\r\n&sdiodev->func[1]->dev);\r\nsdiodev->irq_en = false;\r\n}\r\n} else {\r\nsdio_claim_host(sdiodev->func[1]);\r\nsdio_release_irq(sdiodev->func[2]);\r\nsdio_release_irq(sdiodev->func[1]);\r\nsdio_release_host(sdiodev->func[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int brcmf_sdiod_f0_writeb(struct sdio_func *func,\r\nuint regaddr, u8 byte)\r\n{\r\nint err_ret;\r\nif ((regaddr == SDIO_CCCR_ABORT) ||\r\n(regaddr == SDIO_CCCR_IENx))\r\nsdio_writeb(func, byte, regaddr, &err_ret);\r\nelse\r\nsdio_f0_writeb(func, byte, regaddr, &err_ret);\r\nreturn err_ret;\r\n}\r\nstatic int brcmf_sdiod_request_data(struct brcmf_sdio_dev *sdiodev, u8 fn,\r\nu32 addr, u8 regsz, void *data, bool write)\r\n{\r\nstruct sdio_func *func;\r\nint ret;\r\nbrcmf_dbg(SDIO, "rw=%d, func=%d, addr=0x%05x, nbytes=%d\n",\r\nwrite, fn, addr, regsz);\r\nbrcmf_sdiod_pm_resume_wait(sdiodev, &sdiodev->request_word_wait);\r\nif (brcmf_sdiod_pm_resume_error(sdiodev))\r\nreturn -EIO;\r\nif (WARN_ON(regsz > 1 && !fn))\r\nreturn -EINVAL;\r\nfunc = sdiodev->func[fn];\r\nswitch (regsz) {\r\ncase sizeof(u8):\r\nif (write) {\r\nif (fn)\r\nsdio_writeb(func, *(u8 *)data, addr, &ret);\r\nelse\r\nret = brcmf_sdiod_f0_writeb(func, addr,\r\n*(u8 *)data);\r\n} else {\r\nif (fn)\r\n*(u8 *)data = sdio_readb(func, addr, &ret);\r\nelse\r\n*(u8 *)data = sdio_f0_readb(func, addr, &ret);\r\n}\r\nbreak;\r\ncase sizeof(u16):\r\nif (write)\r\nsdio_writew(func, *(u16 *)data, addr, &ret);\r\nelse\r\n*(u16 *)data = sdio_readw(func, addr, &ret);\r\nbreak;\r\ncase sizeof(u32):\r\nif (write)\r\nsdio_writel(func, *(u32 *)data, addr, &ret);\r\nelse\r\n*(u32 *)data = sdio_readl(func, addr, &ret);\r\nbreak;\r\ndefault:\r\nbrcmf_err("invalid size: %d\n", regsz);\r\nbreak;\r\n}\r\nif (ret)\r\nbrcmf_dbg(SDIO, "failed to %s data F%d@0x%05x, err: %d\n",\r\nwrite ? "write" : "read", fn, addr, ret);\r\nreturn ret;\r\n}\r\nstatic int brcmf_sdiod_regrw_helper(struct brcmf_sdio_dev *sdiodev, u32 addr,\r\nu8 regsz, void *data, bool write)\r\n{\r\nu8 func;\r\ns32 retry = 0;\r\nint ret;\r\nif (sdiodev->bus_if->state == BRCMF_BUS_NOMEDIUM)\r\nreturn -ENOMEDIUM;\r\nif ((addr & ~REG_F0_REG_MASK) == 0)\r\nfunc = SDIO_FUNC_0;\r\nelse\r\nfunc = SDIO_FUNC_1;\r\ndo {\r\nif (!write)\r\nmemset(data, 0, regsz);\r\nif (retry)\r\nusleep_range(1000, 2000);\r\nret = brcmf_sdiod_request_data(sdiodev, func, addr, regsz,\r\ndata, write);\r\n} while (ret != 0 && ret != -ENOMEDIUM &&\r\nretry++ < SDIOH_API_ACCESS_RETRY_LIMIT);\r\nif (ret == -ENOMEDIUM)\r\nbrcmf_bus_change_state(sdiodev->bus_if, BRCMF_BUS_NOMEDIUM);\r\nelse if (ret != 0) {\r\nif (addr != SBSDIO_FUNC1_SLEEPCSR)\r\nbrcmf_err("failed to %s data F%d@0x%05x, err: %d\n",\r\nwrite ? "write" : "read", func, addr, ret);\r\nelse\r\nbrcmf_dbg(SDIO, "failed to %s data F%d@0x%05x, err: %d\n",\r\nwrite ? "write" : "read", func, addr, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nbrcmf_sdiod_set_sbaddr_window(struct brcmf_sdio_dev *sdiodev, u32 address)\r\n{\r\nint err = 0, i;\r\nu8 addr[3];\r\nif (sdiodev->bus_if->state == BRCMF_BUS_NOMEDIUM)\r\nreturn -ENOMEDIUM;\r\naddr[0] = (address >> 8) & SBSDIO_SBADDRLOW_MASK;\r\naddr[1] = (address >> 16) & SBSDIO_SBADDRMID_MASK;\r\naddr[2] = (address >> 24) & SBSDIO_SBADDRHIGH_MASK;\r\nfor (i = 0; i < 3; i++) {\r\nerr = brcmf_sdiod_regrw_helper(sdiodev,\r\nSBSDIO_FUNC1_SBADDRLOW + i,\r\nsizeof(u8), &addr[i], true);\r\nif (err) {\r\nbrcmf_err("failed at addr: 0x%0x\n",\r\nSBSDIO_FUNC1_SBADDRLOW + i);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nbrcmf_sdiod_addrprep(struct brcmf_sdio_dev *sdiodev, uint width, u32 *addr)\r\n{\r\nuint bar0 = *addr & ~SBSDIO_SB_OFT_ADDR_MASK;\r\nint err = 0;\r\nif (bar0 != sdiodev->sbwad) {\r\nerr = brcmf_sdiod_set_sbaddr_window(sdiodev, bar0);\r\nif (err)\r\nreturn err;\r\nsdiodev->sbwad = bar0;\r\n}\r\n*addr &= SBSDIO_SB_OFT_ADDR_MASK;\r\nif (width == 4)\r\n*addr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\r\nreturn 0;\r\n}\r\nu8 brcmf_sdiod_regrb(struct brcmf_sdio_dev *sdiodev, u32 addr, int *ret)\r\n{\r\nu8 data;\r\nint retval;\r\nbrcmf_dbg(SDIO, "addr:0x%08x\n", addr);\r\nretval = brcmf_sdiod_regrw_helper(sdiodev, addr, sizeof(data), &data,\r\nfalse);\r\nbrcmf_dbg(SDIO, "data:0x%02x\n", data);\r\nif (ret)\r\n*ret = retval;\r\nreturn data;\r\n}\r\nu32 brcmf_sdiod_regrl(struct brcmf_sdio_dev *sdiodev, u32 addr, int *ret)\r\n{\r\nu32 data;\r\nint retval;\r\nbrcmf_dbg(SDIO, "addr:0x%08x\n", addr);\r\nretval = brcmf_sdiod_addrprep(sdiodev, sizeof(data), &addr);\r\nif (retval)\r\ngoto done;\r\nretval = brcmf_sdiod_regrw_helper(sdiodev, addr, sizeof(data), &data,\r\nfalse);\r\nbrcmf_dbg(SDIO, "data:0x%08x\n", data);\r\ndone:\r\nif (ret)\r\n*ret = retval;\r\nreturn data;\r\n}\r\nvoid brcmf_sdiod_regwb(struct brcmf_sdio_dev *sdiodev, u32 addr,\r\nu8 data, int *ret)\r\n{\r\nint retval;\r\nbrcmf_dbg(SDIO, "addr:0x%08x, data:0x%02x\n", addr, data);\r\nretval = brcmf_sdiod_regrw_helper(sdiodev, addr, sizeof(data), &data,\r\ntrue);\r\nif (ret)\r\n*ret = retval;\r\n}\r\nvoid brcmf_sdiod_regwl(struct brcmf_sdio_dev *sdiodev, u32 addr,\r\nu32 data, int *ret)\r\n{\r\nint retval;\r\nbrcmf_dbg(SDIO, "addr:0x%08x, data:0x%08x\n", addr, data);\r\nretval = brcmf_sdiod_addrprep(sdiodev, sizeof(data), &addr);\r\nif (retval)\r\ngoto done;\r\nretval = brcmf_sdiod_regrw_helper(sdiodev, addr, sizeof(data), &data,\r\ntrue);\r\ndone:\r\nif (ret)\r\n*ret = retval;\r\n}\r\nstatic int brcmf_sdiod_buffrw(struct brcmf_sdio_dev *sdiodev, uint fn,\r\nbool write, u32 addr, struct sk_buff *pkt)\r\n{\r\nunsigned int req_sz;\r\nint err;\r\nbrcmf_sdiod_pm_resume_wait(sdiodev, &sdiodev->request_buffer_wait);\r\nif (brcmf_sdiod_pm_resume_error(sdiodev))\r\nreturn -EIO;\r\nreq_sz = pkt->len + 3;\r\nreq_sz &= (uint)~3;\r\nif (write)\r\nerr = sdio_memcpy_toio(sdiodev->func[fn], addr,\r\n((u8 *)(pkt->data)), req_sz);\r\nelse if (fn == 1)\r\nerr = sdio_memcpy_fromio(sdiodev->func[fn], ((u8 *)(pkt->data)),\r\naddr, req_sz);\r\nelse\r\nerr = sdio_readsb(sdiodev->func[fn], ((u8 *)(pkt->data)), addr,\r\nreq_sz);\r\nif (err == -ENOMEDIUM)\r\nbrcmf_bus_change_state(sdiodev->bus_if, BRCMF_BUS_NOMEDIUM);\r\nreturn err;\r\n}\r\nstatic int brcmf_sdiod_sglist_rw(struct brcmf_sdio_dev *sdiodev, uint fn,\r\nbool write, u32 addr,\r\nstruct sk_buff_head *pktlist)\r\n{\r\nunsigned int req_sz, func_blk_sz, sg_cnt, sg_data_sz, pkt_offset;\r\nunsigned int max_req_sz, orig_offset, dst_offset;\r\nunsigned short max_seg_cnt, seg_sz;\r\nunsigned char *pkt_data, *orig_data, *dst_data;\r\nstruct sk_buff *pkt_next = NULL, *local_pkt_next;\r\nstruct sk_buff_head local_list, *target_list;\r\nstruct mmc_request mmc_req;\r\nstruct mmc_command mmc_cmd;\r\nstruct mmc_data mmc_dat;\r\nstruct scatterlist *sgl;\r\nint ret = 0;\r\nif (!pktlist->qlen)\r\nreturn -EINVAL;\r\nbrcmf_sdiod_pm_resume_wait(sdiodev, &sdiodev->request_buffer_wait);\r\nif (brcmf_sdiod_pm_resume_error(sdiodev))\r\nreturn -EIO;\r\ntarget_list = pktlist;\r\n__skb_queue_head_init(&local_list);\r\nif (sdiodev->pdata && sdiodev->pdata->broken_sg_support && !write) {\r\nreq_sz = 0;\r\nskb_queue_walk(pktlist, pkt_next)\r\nreq_sz += pkt_next->len;\r\nreq_sz = ALIGN(req_sz, sdiodev->func[fn]->cur_blksize);\r\nwhile (req_sz > PAGE_SIZE) {\r\npkt_next = brcmu_pkt_buf_get_skb(PAGE_SIZE);\r\nif (pkt_next == NULL) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\n__skb_queue_tail(&local_list, pkt_next);\r\nreq_sz -= PAGE_SIZE;\r\n}\r\npkt_next = brcmu_pkt_buf_get_skb(req_sz);\r\nif (pkt_next == NULL) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\n__skb_queue_tail(&local_list, pkt_next);\r\ntarget_list = &local_list;\r\n}\r\nfunc_blk_sz = sdiodev->func[fn]->cur_blksize;\r\nmax_req_sz = sdiodev->max_request_size;\r\nmax_seg_cnt = min_t(unsigned short, sdiodev->max_segment_count,\r\ntarget_list->qlen);\r\nseg_sz = target_list->qlen;\r\npkt_offset = 0;\r\npkt_next = target_list->next;\r\nmemset(&mmc_req, 0, sizeof(struct mmc_request));\r\nmemset(&mmc_cmd, 0, sizeof(struct mmc_command));\r\nmemset(&mmc_dat, 0, sizeof(struct mmc_data));\r\nmmc_dat.sg = sdiodev->sgtable.sgl;\r\nmmc_dat.blksz = func_blk_sz;\r\nmmc_dat.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;\r\nmmc_cmd.opcode = SD_IO_RW_EXTENDED;\r\nmmc_cmd.arg = write ? 1<<31 : 0;\r\nmmc_cmd.arg |= (fn & 0x7) << 28;\r\nmmc_cmd.arg |= 1<<27;\r\nmmc_cmd.arg |= (fn == 1) ? 1<<26 : 0;\r\nmmc_cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;\r\nmmc_req.cmd = &mmc_cmd;\r\nmmc_req.data = &mmc_dat;\r\nwhile (seg_sz) {\r\nreq_sz = 0;\r\nsg_cnt = 0;\r\nsgl = sdiodev->sgtable.sgl;\r\nwhile (pkt_next != (struct sk_buff *)target_list) {\r\npkt_data = pkt_next->data + pkt_offset;\r\nsg_data_sz = pkt_next->len - pkt_offset;\r\nif (sg_data_sz > sdiodev->max_segment_size)\r\nsg_data_sz = sdiodev->max_segment_size;\r\nif (sg_data_sz > max_req_sz - req_sz)\r\nsg_data_sz = max_req_sz - req_sz;\r\nsg_set_buf(sgl, pkt_data, sg_data_sz);\r\nsg_cnt++;\r\nsgl = sg_next(sgl);\r\nreq_sz += sg_data_sz;\r\npkt_offset += sg_data_sz;\r\nif (pkt_offset == pkt_next->len) {\r\npkt_offset = 0;\r\npkt_next = pkt_next->next;\r\n}\r\nif (req_sz >= max_req_sz || sg_cnt >= max_seg_cnt)\r\nbreak;\r\n}\r\nseg_sz -= sg_cnt;\r\nif (req_sz % func_blk_sz != 0) {\r\nbrcmf_err("sg request length %u is not %u aligned\n",\r\nreq_sz, func_blk_sz);\r\nret = -ENOTBLK;\r\ngoto exit;\r\n}\r\nmmc_dat.sg_len = sg_cnt;\r\nmmc_dat.blocks = req_sz / func_blk_sz;\r\nmmc_cmd.arg |= (addr & 0x1FFFF) << 9;\r\nmmc_cmd.arg |= mmc_dat.blocks & 0x1FF;\r\nif (fn == 1)\r\naddr += req_sz;\r\nmmc_set_data_timeout(&mmc_dat, sdiodev->func[fn]->card);\r\nmmc_wait_for_req(sdiodev->func[fn]->card->host, &mmc_req);\r\nret = mmc_cmd.error ? mmc_cmd.error : mmc_dat.error;\r\nif (ret == -ENOMEDIUM) {\r\nbrcmf_bus_change_state(sdiodev->bus_if,\r\nBRCMF_BUS_NOMEDIUM);\r\nbreak;\r\n} else if (ret != 0) {\r\nbrcmf_err("CMD53 sg block %s failed %d\n",\r\nwrite ? "write" : "read", ret);\r\nret = -EIO;\r\nbreak;\r\n}\r\n}\r\nif (sdiodev->pdata && sdiodev->pdata->broken_sg_support && !write) {\r\nlocal_pkt_next = local_list.next;\r\norig_offset = 0;\r\nskb_queue_walk(pktlist, pkt_next) {\r\ndst_offset = 0;\r\ndo {\r\nreq_sz = local_pkt_next->len - orig_offset;\r\nreq_sz = min_t(uint, pkt_next->len - dst_offset,\r\nreq_sz);\r\norig_data = local_pkt_next->data + orig_offset;\r\ndst_data = pkt_next->data + dst_offset;\r\nmemcpy(dst_data, orig_data, req_sz);\r\norig_offset += req_sz;\r\ndst_offset += req_sz;\r\nif (orig_offset == local_pkt_next->len) {\r\norig_offset = 0;\r\nlocal_pkt_next = local_pkt_next->next;\r\n}\r\nif (dst_offset == pkt_next->len)\r\nbreak;\r\n} while (!skb_queue_empty(&local_list));\r\n}\r\n}\r\nexit:\r\nsg_init_table(sdiodev->sgtable.sgl, sdiodev->sgtable.orig_nents);\r\nwhile ((pkt_next = __skb_dequeue(&local_list)) != NULL)\r\nbrcmu_pkt_buf_free_skb(pkt_next);\r\nreturn ret;\r\n}\r\nint brcmf_sdiod_recv_buf(struct brcmf_sdio_dev *sdiodev, u8 *buf, uint nbytes)\r\n{\r\nstruct sk_buff *mypkt;\r\nint err;\r\nmypkt = brcmu_pkt_buf_get_skb(nbytes);\r\nif (!mypkt) {\r\nbrcmf_err("brcmu_pkt_buf_get_skb failed: len %d\n",\r\nnbytes);\r\nreturn -EIO;\r\n}\r\nerr = brcmf_sdiod_recv_pkt(sdiodev, mypkt);\r\nif (!err)\r\nmemcpy(buf, mypkt->data, nbytes);\r\nbrcmu_pkt_buf_free_skb(mypkt);\r\nreturn err;\r\n}\r\nint brcmf_sdiod_recv_pkt(struct brcmf_sdio_dev *sdiodev, struct sk_buff *pkt)\r\n{\r\nu32 addr = sdiodev->sbwad;\r\nint err = 0;\r\nbrcmf_dbg(SDIO, "addr = 0x%x, size = %d\n", addr, pkt->len);\r\nerr = brcmf_sdiod_addrprep(sdiodev, 4, &addr);\r\nif (err)\r\ngoto done;\r\nerr = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_2, false, addr, pkt);\r\ndone:\r\nreturn err;\r\n}\r\nint brcmf_sdiod_recv_chain(struct brcmf_sdio_dev *sdiodev,\r\nstruct sk_buff_head *pktq, uint totlen)\r\n{\r\nstruct sk_buff *glom_skb;\r\nstruct sk_buff *skb;\r\nu32 addr = sdiodev->sbwad;\r\nint err = 0;\r\nbrcmf_dbg(SDIO, "addr = 0x%x, size = %d\n",\r\naddr, pktq->qlen);\r\nerr = brcmf_sdiod_addrprep(sdiodev, 4, &addr);\r\nif (err)\r\ngoto done;\r\nif (pktq->qlen == 1)\r\nerr = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_2, false, addr,\r\npktq->next);\r\nelse if (!sdiodev->sg_support) {\r\nglom_skb = brcmu_pkt_buf_get_skb(totlen);\r\nif (!glom_skb)\r\nreturn -ENOMEM;\r\nerr = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_2, false, addr,\r\nglom_skb);\r\nif (err)\r\ngoto done;\r\nskb_queue_walk(pktq, skb) {\r\nmemcpy(skb->data, glom_skb->data, skb->len);\r\nskb_pull(glom_skb, skb->len);\r\n}\r\n} else\r\nerr = brcmf_sdiod_sglist_rw(sdiodev, SDIO_FUNC_2, false, addr,\r\npktq);\r\ndone:\r\nreturn err;\r\n}\r\nint brcmf_sdiod_send_buf(struct brcmf_sdio_dev *sdiodev, u8 *buf, uint nbytes)\r\n{\r\nstruct sk_buff *mypkt;\r\nu32 addr = sdiodev->sbwad;\r\nint err;\r\nmypkt = brcmu_pkt_buf_get_skb(nbytes);\r\nif (!mypkt) {\r\nbrcmf_err("brcmu_pkt_buf_get_skb failed: len %d\n",\r\nnbytes);\r\nreturn -EIO;\r\n}\r\nmemcpy(mypkt->data, buf, nbytes);\r\nerr = brcmf_sdiod_addrprep(sdiodev, 4, &addr);\r\nif (!err)\r\nerr = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_2, true, addr,\r\nmypkt);\r\nbrcmu_pkt_buf_free_skb(mypkt);\r\nreturn err;\r\n}\r\nint brcmf_sdiod_send_pkt(struct brcmf_sdio_dev *sdiodev,\r\nstruct sk_buff_head *pktq)\r\n{\r\nstruct sk_buff *skb;\r\nu32 addr = sdiodev->sbwad;\r\nint err;\r\nbrcmf_dbg(SDIO, "addr = 0x%x, size = %d\n", addr, pktq->qlen);\r\nerr = brcmf_sdiod_addrprep(sdiodev, 4, &addr);\r\nif (err)\r\nreturn err;\r\nif (pktq->qlen == 1 || !sdiodev->sg_support)\r\nskb_queue_walk(pktq, skb) {\r\nerr = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_2, true,\r\naddr, skb);\r\nif (err)\r\nbreak;\r\n}\r\nelse\r\nerr = brcmf_sdiod_sglist_rw(sdiodev, SDIO_FUNC_2, true, addr,\r\npktq);\r\nreturn err;\r\n}\r\nint\r\nbrcmf_sdiod_ramrw(struct brcmf_sdio_dev *sdiodev, bool write, u32 address,\r\nu8 *data, uint size)\r\n{\r\nint bcmerror = 0;\r\nstruct sk_buff *pkt;\r\nu32 sdaddr;\r\nuint dsize;\r\ndsize = min_t(uint, SBSDIO_SB_OFT_ADDR_LIMIT, size);\r\npkt = dev_alloc_skb(dsize);\r\nif (!pkt) {\r\nbrcmf_err("dev_alloc_skb failed: len %d\n", dsize);\r\nreturn -EIO;\r\n}\r\npkt->priority = 0;\r\nsdaddr = address & SBSDIO_SB_OFT_ADDR_MASK;\r\nif ((sdaddr + size) & SBSDIO_SBWINDOW_MASK)\r\ndsize = (SBSDIO_SB_OFT_ADDR_LIMIT - sdaddr);\r\nelse\r\ndsize = size;\r\nsdio_claim_host(sdiodev->func[1]);\r\nwhile (size) {\r\nbcmerror = brcmf_sdiod_set_sbaddr_window(sdiodev, address);\r\nif (bcmerror)\r\nbreak;\r\nbrcmf_dbg(SDIO, "%s %d bytes at offset 0x%08x in window 0x%08x\n",\r\nwrite ? "write" : "read", dsize,\r\nsdaddr, address & SBSDIO_SBWINDOW_MASK);\r\nsdaddr &= SBSDIO_SB_OFT_ADDR_MASK;\r\nsdaddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\r\nskb_put(pkt, dsize);\r\nif (write)\r\nmemcpy(pkt->data, data, dsize);\r\nbcmerror = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_1, write,\r\nsdaddr, pkt);\r\nif (bcmerror) {\r\nbrcmf_err("membytes transfer failed\n");\r\nbreak;\r\n}\r\nif (!write)\r\nmemcpy(data, pkt->data, dsize);\r\nskb_trim(pkt, 0);\r\nsize -= dsize;\r\nif (size) {\r\ndata += dsize;\r\naddress += dsize;\r\nsdaddr = 0;\r\ndsize = min_t(uint, SBSDIO_SB_OFT_ADDR_LIMIT, size);\r\n}\r\n}\r\ndev_kfree_skb(pkt);\r\nif (brcmf_sdiod_set_sbaddr_window(sdiodev, sdiodev->sbwad))\r\nbrcmf_err("FAILED to set window back to 0x%x\n",\r\nsdiodev->sbwad);\r\nsdio_release_host(sdiodev->func[1]);\r\nreturn bcmerror;\r\n}\r\nint brcmf_sdiod_abort(struct brcmf_sdio_dev *sdiodev, uint fn)\r\n{\r\nchar t_func = (char)fn;\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nbrcmf_sdiod_request_data(sdiodev, SDIO_FUNC_0, SDIO_CCCR_ABORT,\r\nsizeof(t_func), &t_func, true);\r\nbrcmf_dbg(SDIO, "Exit\n");\r\nreturn 0;\r\n}\r\nstatic void brcmf_sdiod_sgtable_alloc(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nuint nents;\r\nint err;\r\nif (!sdiodev->sg_support)\r\nreturn;\r\nnents = max_t(uint, BRCMF_DEFAULT_RXGLOM_SIZE, brcmf_sdiod_txglomsz);\r\nnents += (nents >> 4) + 1;\r\nWARN_ON(nents > sdiodev->max_segment_count);\r\nbrcmf_dbg(TRACE, "nents=%d\n", nents);\r\nerr = sg_alloc_table(&sdiodev->sgtable, nents, GFP_KERNEL);\r\nif (err < 0) {\r\nbrcmf_err("allocation failed: disable scatter-gather");\r\nsdiodev->sg_support = false;\r\n}\r\nsdiodev->txglomsz = brcmf_sdiod_txglomsz;\r\n}\r\nstatic int brcmf_sdiod_remove(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nif (sdiodev->bus) {\r\nbrcmf_sdio_remove(sdiodev->bus);\r\nsdiodev->bus = NULL;\r\n}\r\nsdio_claim_host(sdiodev->func[2]);\r\nsdio_disable_func(sdiodev->func[2]);\r\nsdio_release_host(sdiodev->func[2]);\r\nsdio_claim_host(sdiodev->func[1]);\r\nsdio_disable_func(sdiodev->func[1]);\r\nsdio_release_host(sdiodev->func[1]);\r\nsg_free_table(&sdiodev->sgtable);\r\nsdiodev->sbwad = 0;\r\nreturn 0;\r\n}\r\nstatic int brcmf_sdiod_probe(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nstruct sdio_func *func;\r\nstruct mmc_host *host;\r\nuint max_blocks;\r\nint ret = 0;\r\nsdiodev->num_funcs = 2;\r\nsdio_claim_host(sdiodev->func[1]);\r\nret = sdio_set_block_size(sdiodev->func[1], SDIO_FUNC1_BLOCKSIZE);\r\nif (ret) {\r\nbrcmf_err("Failed to set F1 blocksize\n");\r\nsdio_release_host(sdiodev->func[1]);\r\ngoto out;\r\n}\r\nret = sdio_set_block_size(sdiodev->func[2], SDIO_FUNC2_BLOCKSIZE);\r\nif (ret) {\r\nbrcmf_err("Failed to set F2 blocksize\n");\r\nsdio_release_host(sdiodev->func[1]);\r\ngoto out;\r\n}\r\nsdiodev->func[2]->enable_timeout = SDIO_WAIT_F2RDY;\r\nret = sdio_enable_func(sdiodev->func[1]);\r\nsdio_release_host(sdiodev->func[1]);\r\nif (ret) {\r\nbrcmf_err("Failed to enable F1: err=%d\n", ret);\r\ngoto out;\r\n}\r\nfunc = sdiodev->func[2];\r\nhost = func->card->host;\r\nsdiodev->sg_support = host->max_segs > 1;\r\nmax_blocks = min_t(uint, host->max_blk_count, 511u);\r\nsdiodev->max_request_size = min_t(uint, host->max_req_size,\r\nmax_blocks * func->cur_blksize);\r\nsdiodev->max_segment_count = min_t(uint, host->max_segs,\r\nSG_MAX_SINGLE_ALLOC);\r\nsdiodev->max_segment_size = host->max_seg_size;\r\nbrcmf_sdiod_sgtable_alloc(sdiodev);\r\nsdiodev->bus = brcmf_sdio_probe(sdiodev);\r\nif (!sdiodev->bus) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nout:\r\nif (ret)\r\nbrcmf_sdiod_remove(sdiodev);\r\nreturn ret;\r\n}\r\nstatic int brcmf_ops_sdio_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nint err;\r\nstruct brcmf_sdio_dev *sdiodev;\r\nstruct brcmf_bus *bus_if;\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nbrcmf_dbg(SDIO, "Class=%x\n", func->class);\r\nbrcmf_dbg(SDIO, "sdio vendor ID: 0x%04x\n", func->vendor);\r\nbrcmf_dbg(SDIO, "sdio device ID: 0x%04x\n", func->device);\r\nbrcmf_dbg(SDIO, "Function#: %d\n", func->num);\r\nif (func->num == 1)\r\nreturn 0;\r\nif (func->num != 2)\r\nreturn -ENODEV;\r\nbus_if = kzalloc(sizeof(struct brcmf_bus), GFP_KERNEL);\r\nif (!bus_if)\r\nreturn -ENOMEM;\r\nsdiodev = kzalloc(sizeof(struct brcmf_sdio_dev), GFP_KERNEL);\r\nif (!sdiodev) {\r\nkfree(bus_if);\r\nreturn -ENOMEM;\r\n}\r\nsdiodev->func[0] = kmemdup(func, sizeof(*func), GFP_KERNEL);\r\nsdiodev->func[0]->num = 0;\r\nsdiodev->func[1] = func->card->sdio_func[0];\r\nsdiodev->func[2] = func;\r\nsdiodev->bus_if = bus_if;\r\nbus_if->bus_priv.sdio = sdiodev;\r\nbus_if->proto_type = BRCMF_PROTO_BCDC;\r\ndev_set_drvdata(&func->dev, bus_if);\r\ndev_set_drvdata(&sdiodev->func[1]->dev, bus_if);\r\nsdiodev->dev = &sdiodev->func[1]->dev;\r\nsdiodev->pdata = brcmfmac_sdio_pdata;\r\nif (!sdiodev->pdata)\r\nbrcmf_of_probe(sdiodev);\r\natomic_set(&sdiodev->suspend, false);\r\ninit_waitqueue_head(&sdiodev->request_word_wait);\r\ninit_waitqueue_head(&sdiodev->request_buffer_wait);\r\nbrcmf_dbg(SDIO, "F2 found, calling brcmf_sdiod_probe...\n");\r\nerr = brcmf_sdiod_probe(sdiodev);\r\nif (err) {\r\nbrcmf_err("F2 error, probe failed %d...\n", err);\r\ngoto fail;\r\n}\r\nbrcmf_dbg(SDIO, "F2 init completed...\n");\r\nreturn 0;\r\nfail:\r\ndev_set_drvdata(&func->dev, NULL);\r\ndev_set_drvdata(&sdiodev->func[1]->dev, NULL);\r\nkfree(sdiodev->func[0]);\r\nkfree(sdiodev);\r\nkfree(bus_if);\r\nreturn err;\r\n}\r\nstatic void brcmf_ops_sdio_remove(struct sdio_func *func)\r\n{\r\nstruct brcmf_bus *bus_if;\r\nstruct brcmf_sdio_dev *sdiodev;\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nbrcmf_dbg(SDIO, "sdio vendor ID: 0x%04x\n", func->vendor);\r\nbrcmf_dbg(SDIO, "sdio device ID: 0x%04x\n", func->device);\r\nbrcmf_dbg(SDIO, "Function: %d\n", func->num);\r\nif (func->num != 1 && func->num != 2)\r\nreturn;\r\nbus_if = dev_get_drvdata(&func->dev);\r\nif (bus_if) {\r\nsdiodev = bus_if->bus_priv.sdio;\r\nbrcmf_sdiod_remove(sdiodev);\r\ndev_set_drvdata(&sdiodev->func[1]->dev, NULL);\r\ndev_set_drvdata(&sdiodev->func[2]->dev, NULL);\r\nkfree(bus_if);\r\nkfree(sdiodev->func[0]);\r\nkfree(sdiodev);\r\n}\r\nbrcmf_dbg(SDIO, "Exit\n");\r\n}\r\nstatic int brcmf_ops_sdio_suspend(struct device *dev)\r\n{\r\nmmc_pm_flag_t sdio_flags;\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\r\nint ret = 0;\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nsdio_flags = sdio_get_host_pm_caps(sdiodev->func[1]);\r\nif (!(sdio_flags & MMC_PM_KEEP_POWER)) {\r\nbrcmf_err("Host can't keep power while suspended\n");\r\nreturn -EINVAL;\r\n}\r\natomic_set(&sdiodev->suspend, true);\r\nret = sdio_set_host_pm_flags(sdiodev->func[1], MMC_PM_KEEP_POWER);\r\nif (ret) {\r\nbrcmf_err("Failed to set pm_flags\n");\r\natomic_set(&sdiodev->suspend, false);\r\nreturn ret;\r\n}\r\nbrcmf_sdio_wd_timer(sdiodev->bus, 0);\r\nreturn ret;\r\n}\r\nstatic int brcmf_ops_sdio_resume(struct device *dev)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nbrcmf_sdio_wd_timer(sdiodev->bus, BRCMF_WD_POLL_MS);\r\natomic_set(&sdiodev->suspend, false);\r\nreturn 0;\r\n}\r\nstatic int __init brcmf_sdio_pd_probe(struct platform_device *pdev)\r\n{\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nbrcmfmac_sdio_pdata = dev_get_platdata(&pdev->dev);\r\nif (brcmfmac_sdio_pdata->power_on)\r\nbrcmfmac_sdio_pdata->power_on();\r\nreturn 0;\r\n}\r\nstatic int brcmf_sdio_pd_remove(struct platform_device *pdev)\r\n{\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nif (brcmfmac_sdio_pdata->power_off)\r\nbrcmfmac_sdio_pdata->power_off();\r\nsdio_unregister_driver(&brcmf_sdmmc_driver);\r\nreturn 0;\r\n}\r\nvoid brcmf_sdio_register(void)\r\n{\r\nint ret;\r\nret = sdio_register_driver(&brcmf_sdmmc_driver);\r\nif (ret)\r\nbrcmf_err("sdio_register_driver failed: %d\n", ret);\r\n}\r\nvoid brcmf_sdio_exit(void)\r\n{\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nif (brcmfmac_sdio_pdata)\r\nplatform_driver_unregister(&brcmf_sdio_pd);\r\nelse\r\nsdio_unregister_driver(&brcmf_sdmmc_driver);\r\n}\r\nvoid __init brcmf_sdio_init(void)\r\n{\r\nint ret;\r\nbrcmf_dbg(SDIO, "Enter\n");\r\nret = platform_driver_probe(&brcmf_sdio_pd, brcmf_sdio_pd_probe);\r\nif (ret == -ENODEV)\r\nbrcmf_dbg(SDIO, "No platform data available.\n");\r\n}
