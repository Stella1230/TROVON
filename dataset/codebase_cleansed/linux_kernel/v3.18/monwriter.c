static int monwrite_diag(struct monwrite_hdr *myhdr, char *buffer, int fcn)\r\n{\r\nstruct appldata_product_id id;\r\nint rc;\r\nstrncpy(id.prod_nr, "LNXAPPL", 7);\r\nid.prod_fn = myhdr->applid;\r\nid.record_nr = myhdr->record_num;\r\nid.version_nr = myhdr->version;\r\nid.release_nr = myhdr->release;\r\nid.mod_lvl = myhdr->mod_level;\r\nrc = appldata_asm(&id, fcn, (void *) buffer, myhdr->datalen);\r\nif (rc <= 0)\r\nreturn rc;\r\npr_err("Writing monitor data failed with rc=%i\n", rc);\r\nif (rc == 5)\r\nreturn -EPERM;\r\nreturn -EINVAL;\r\n}\r\nstatic struct mon_buf *monwrite_find_hdr(struct mon_private *monpriv,\r\nstruct monwrite_hdr *monhdr)\r\n{\r\nstruct mon_buf *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &monpriv->list, list)\r\nif ((entry->hdr.mon_function == monhdr->mon_function ||\r\nmonhdr->mon_function == MONWRITE_STOP_INTERVAL) &&\r\nentry->hdr.applid == monhdr->applid &&\r\nentry->hdr.record_num == monhdr->record_num &&\r\nentry->hdr.version == monhdr->version &&\r\nentry->hdr.release == monhdr->release &&\r\nentry->hdr.mod_level == monhdr->mod_level)\r\nreturn entry;\r\nreturn NULL;\r\n}\r\nstatic int monwrite_new_hdr(struct mon_private *monpriv)\r\n{\r\nstruct monwrite_hdr *monhdr = &monpriv->hdr;\r\nstruct mon_buf *monbuf;\r\nint rc = 0;\r\nif (monhdr->datalen > MONWRITE_MAX_DATALEN ||\r\nmonhdr->mon_function > MONWRITE_START_CONFIG ||\r\nmonhdr->hdrlen != sizeof(struct monwrite_hdr))\r\nreturn -EINVAL;\r\nmonbuf = NULL;\r\nif (monhdr->mon_function != MONWRITE_GEN_EVENT)\r\nmonbuf = monwrite_find_hdr(monpriv, monhdr);\r\nif (monbuf) {\r\nif (monhdr->mon_function == MONWRITE_STOP_INTERVAL) {\r\nmonhdr->datalen = monbuf->hdr.datalen;\r\nrc = monwrite_diag(monhdr, monbuf->data,\r\nAPPLDATA_STOP_REC);\r\nlist_del(&monbuf->list);\r\nmon_buf_count--;\r\nkfree(monbuf->data);\r\nkfree(monbuf);\r\nmonbuf = NULL;\r\n}\r\n} else if (monhdr->mon_function != MONWRITE_STOP_INTERVAL) {\r\nif (mon_buf_count >= mon_max_bufs)\r\nreturn -ENOSPC;\r\nmonbuf = kzalloc(sizeof(struct mon_buf), GFP_KERNEL);\r\nif (!monbuf)\r\nreturn -ENOMEM;\r\nmonbuf->data = kzalloc(monhdr->datalen,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!monbuf->data) {\r\nkfree(monbuf);\r\nreturn -ENOMEM;\r\n}\r\nmonbuf->hdr = *monhdr;\r\nlist_add_tail(&monbuf->list, &monpriv->list);\r\nif (monhdr->mon_function != MONWRITE_GEN_EVENT)\r\nmon_buf_count++;\r\n}\r\nmonpriv->current_buf = monbuf;\r\nreturn rc;\r\n}\r\nstatic int monwrite_new_data(struct mon_private *monpriv)\r\n{\r\nstruct monwrite_hdr *monhdr = &monpriv->hdr;\r\nstruct mon_buf *monbuf = monpriv->current_buf;\r\nint rc = 0;\r\nswitch (monhdr->mon_function) {\r\ncase MONWRITE_START_INTERVAL:\r\nif (!monbuf->diag_done) {\r\nrc = monwrite_diag(monhdr, monbuf->data,\r\nAPPLDATA_START_INTERVAL_REC);\r\nmonbuf->diag_done = 1;\r\n}\r\nbreak;\r\ncase MONWRITE_START_CONFIG:\r\nif (!monbuf->diag_done) {\r\nrc = monwrite_diag(monhdr, monbuf->data,\r\nAPPLDATA_START_CONFIG_REC);\r\nmonbuf->diag_done = 1;\r\n}\r\nbreak;\r\ncase MONWRITE_GEN_EVENT:\r\nrc = monwrite_diag(monhdr, monbuf->data,\r\nAPPLDATA_GEN_EVENT_REC);\r\nlist_del(&monpriv->current_buf->list);\r\nkfree(monpriv->current_buf->data);\r\nkfree(monpriv->current_buf);\r\nmonpriv->current_buf = NULL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn rc;\r\n}\r\nstatic int monwrite_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct mon_private *monpriv;\r\nmonpriv = kzalloc(sizeof(struct mon_private), GFP_KERNEL);\r\nif (!monpriv)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&monpriv->list);\r\nmonpriv->hdr_to_read = sizeof(monpriv->hdr);\r\nmutex_init(&monpriv->thread_mutex);\r\nfilp->private_data = monpriv;\r\nlist_add_tail(&monpriv->priv_list, &mon_priv_list);\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int monwrite_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct mon_private *monpriv = filp->private_data;\r\nstruct mon_buf *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &monpriv->list, list) {\r\nif (entry->hdr.mon_function != MONWRITE_GEN_EVENT)\r\nmonwrite_diag(&entry->hdr, entry->data,\r\nAPPLDATA_STOP_REC);\r\nmon_buf_count--;\r\nlist_del(&entry->list);\r\nkfree(entry->data);\r\nkfree(entry);\r\n}\r\nlist_del(&monpriv->priv_list);\r\nkfree(monpriv);\r\nreturn 0;\r\n}\r\nstatic ssize_t monwrite_write(struct file *filp, const char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct mon_private *monpriv = filp->private_data;\r\nsize_t len, written;\r\nvoid *to;\r\nint rc;\r\nmutex_lock(&monpriv->thread_mutex);\r\nfor (written = 0; written < count; ) {\r\nif (monpriv->hdr_to_read) {\r\nlen = min(count - written, monpriv->hdr_to_read);\r\nto = (char *) &monpriv->hdr +\r\nsizeof(monpriv->hdr) - monpriv->hdr_to_read;\r\nif (copy_from_user(to, data + written, len)) {\r\nrc = -EFAULT;\r\ngoto out_error;\r\n}\r\nmonpriv->hdr_to_read -= len;\r\nwritten += len;\r\nif (monpriv->hdr_to_read > 0)\r\ncontinue;\r\nrc = monwrite_new_hdr(monpriv);\r\nif (rc)\r\ngoto out_error;\r\nmonpriv->data_to_read = monpriv->current_buf ?\r\nmonpriv->current_buf->hdr.datalen : 0;\r\n}\r\nif (monpriv->data_to_read) {\r\nlen = min(count - written, monpriv->data_to_read);\r\nto = monpriv->current_buf->data +\r\nmonpriv->hdr.datalen - monpriv->data_to_read;\r\nif (copy_from_user(to, data + written, len)) {\r\nrc = -EFAULT;\r\ngoto out_error;\r\n}\r\nmonpriv->data_to_read -= len;\r\nwritten += len;\r\nif (monpriv->data_to_read > 0)\r\ncontinue;\r\nrc = monwrite_new_data(monpriv);\r\nif (rc)\r\ngoto out_error;\r\n}\r\nmonpriv->hdr_to_read = sizeof(monpriv->hdr);\r\n}\r\nmutex_unlock(&monpriv->thread_mutex);\r\nreturn written;\r\nout_error:\r\nmonpriv->data_to_read = 0;\r\nmonpriv->hdr_to_read = sizeof(struct monwrite_hdr);\r\nmutex_unlock(&monpriv->thread_mutex);\r\nreturn rc;\r\n}\r\nstatic int monwriter_freeze(struct device *dev)\r\n{\r\nstruct mon_private *monpriv;\r\nstruct mon_buf *monbuf;\r\nlist_for_each_entry(monpriv, &mon_priv_list, priv_list) {\r\nlist_for_each_entry(monbuf, &monpriv->list, list) {\r\nif (monbuf->hdr.mon_function != MONWRITE_GEN_EVENT)\r\nmonwrite_diag(&monbuf->hdr, monbuf->data,\r\nAPPLDATA_STOP_REC);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int monwriter_restore(struct device *dev)\r\n{\r\nstruct mon_private *monpriv;\r\nstruct mon_buf *monbuf;\r\nlist_for_each_entry(monpriv, &mon_priv_list, priv_list) {\r\nlist_for_each_entry(monbuf, &monpriv->list, list) {\r\nif (monbuf->hdr.mon_function == MONWRITE_START_INTERVAL)\r\nmonwrite_diag(&monbuf->hdr, monbuf->data,\r\nAPPLDATA_START_INTERVAL_REC);\r\nif (monbuf->hdr.mon_function == MONWRITE_START_CONFIG)\r\nmonwrite_diag(&monbuf->hdr, monbuf->data,\r\nAPPLDATA_START_CONFIG_REC);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int monwriter_thaw(struct device *dev)\r\n{\r\nreturn monwriter_restore(dev);\r\n}\r\nstatic int __init mon_init(void)\r\n{\r\nint rc;\r\nif (!MACHINE_IS_VM)\r\nreturn -ENODEV;\r\nrc = platform_driver_register(&monwriter_pdrv);\r\nif (rc)\r\nreturn rc;\r\nmonwriter_pdev = platform_device_register_simple("monwriter", -1, NULL,\r\n0);\r\nif (IS_ERR(monwriter_pdev)) {\r\nrc = PTR_ERR(monwriter_pdev);\r\ngoto out_driver;\r\n}\r\nrc = misc_register(&mon_dev);\r\nif (rc)\r\ngoto out_device;\r\nreturn 0;\r\nout_device:\r\nplatform_device_unregister(monwriter_pdev);\r\nout_driver:\r\nplatform_driver_unregister(&monwriter_pdrv);\r\nreturn rc;\r\n}\r\nstatic void __exit mon_exit(void)\r\n{\r\nmisc_deregister(&mon_dev);\r\nplatform_device_unregister(monwriter_pdev);\r\nplatform_driver_unregister(&monwriter_pdrv);\r\n}
