static bool pcm1681_accessible_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn !((reg == 0x00) || (reg == 0x0f));\r\n}\r\nstatic bool pcm1681_writeable_reg(struct device *dev, unsigned register reg)\r\n{\r\nreturn pcm1681_accessible_reg(dev, reg) &&\r\n(reg != PCM1681_ZERO_DETECT_STATUS);\r\n}\r\nstatic int pcm1681_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct pcm1681_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint i = 0, val = -1, enable = 0;\r\nif (priv->deemph)\r\nfor (i = 0; i < ARRAY_SIZE(pcm1681_deemph); i++)\r\nif (pcm1681_deemph[i] == priv->rate)\r\nval = i;\r\nif (val != -1) {\r\nregmap_update_bits(priv->regmap, PCM1681_DEEMPH_CONTROL,\r\nPCM1681_DEEMPH_RATE_MASK, val);\r\nenable = 1;\r\n} else\r\nenable = 0;\r\nreturn regmap_update_bits(priv->regmap, PCM1681_DEEMPH_CONTROL,\r\nPCM1681_DEEMPH_MASK, enable);\r\n}\r\nstatic int pcm1681_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct pcm1681_private *priv = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = priv->deemph;\r\nreturn 0;\r\n}\r\nstatic int pcm1681_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct pcm1681_private *priv = snd_soc_codec_get_drvdata(codec);\r\npriv->deemph = ucontrol->value.enumerated.item[0];\r\nreturn pcm1681_set_deemph(codec);\r\n}\r\nstatic int pcm1681_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct pcm1681_private *priv = snd_soc_codec_get_drvdata(codec);\r\nif ((format & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS) {\r\ndev_err(codec->dev, "Invalid clocking mode\n");\r\nreturn -EINVAL;\r\n}\r\npriv->format = format;\r\nreturn 0;\r\n}\r\nstatic int pcm1681_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm1681_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint val;\r\nif (mute)\r\nval = PCM1681_SOFT_MUTE_ALL;\r\nelse\r\nval = 0;\r\nreturn regmap_write(priv->regmap, PCM1681_SOFT_MUTE, val);\r\n}\r\nstatic int pcm1681_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct pcm1681_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint val = 0, ret;\r\npriv->rate = params_rate(params);\r\nswitch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nswitch (params_width(params)) {\r\ncase 24:\r\nval = 0;\r\nbreak;\r\ncase 16:\r\nval = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = 0x04;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = 0x05;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid DAI format\n");\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(priv->regmap, PCM1681_FMT_CONTROL, 0x0f, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn pcm1681_set_deemph(codec);\r\n}\r\nstatic int pcm1681_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct pcm1681_private *priv;\r\npriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->regmap = devm_regmap_init_i2c(client, &pcm1681_regmap);\r\nif (IS_ERR(priv->regmap)) {\r\nret = PTR_ERR(priv->regmap);\r\ndev_err(&client->dev, "Failed to create regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, priv);\r\nreturn snd_soc_register_codec(&client->dev, &soc_codec_dev_pcm1681,\r\n&pcm1681_dai, 1);\r\n}\r\nstatic int pcm1681_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
