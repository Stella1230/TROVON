static void set_pts(struct tegra_usb_phy *phy, u8 pts_val)\r\n{\r\nvoid __iomem *base = phy->regs;\r\nunsigned long val;\r\nif (phy->soc_config->has_hostpc) {\r\nval = readl(base + TEGRA_USB_HOSTPC1_DEVLC);\r\nval &= ~TEGRA_USB_HOSTPC1_DEVLC_PTS(~0);\r\nval |= TEGRA_USB_HOSTPC1_DEVLC_PTS(pts_val);\r\nwritel(val, base + TEGRA_USB_HOSTPC1_DEVLC);\r\n} else {\r\nval = readl(base + TEGRA_USB_PORTSC1) & ~TEGRA_PORTSC1_RWC_BITS;\r\nval &= ~TEGRA_USB_PORTSC1_PTS(~0);\r\nval |= TEGRA_USB_PORTSC1_PTS(pts_val);\r\nwritel(val, base + TEGRA_USB_PORTSC1);\r\n}\r\n}\r\nstatic void set_phcd(struct tegra_usb_phy *phy, bool enable)\r\n{\r\nvoid __iomem *base = phy->regs;\r\nunsigned long val;\r\nif (phy->soc_config->has_hostpc) {\r\nval = readl(base + TEGRA_USB_HOSTPC1_DEVLC);\r\nif (enable)\r\nval |= TEGRA_USB_HOSTPC1_DEVLC_PHCD;\r\nelse\r\nval &= ~TEGRA_USB_HOSTPC1_DEVLC_PHCD;\r\nwritel(val, base + TEGRA_USB_HOSTPC1_DEVLC);\r\n} else {\r\nval = readl(base + TEGRA_USB_PORTSC1) & ~PORT_RWC_BITS;\r\nif (enable)\r\nval |= TEGRA_USB_PORTSC1_PHCD;\r\nelse\r\nval &= ~TEGRA_USB_PORTSC1_PHCD;\r\nwritel(val, base + TEGRA_USB_PORTSC1);\r\n}\r\n}\r\nstatic int utmip_pad_open(struct tegra_usb_phy *phy)\r\n{\r\nphy->pad_clk = devm_clk_get(phy->u_phy.dev, "utmi-pads");\r\nif (IS_ERR(phy->pad_clk)) {\r\npr_err("%s: can't get utmip pad clock\n", __func__);\r\nreturn PTR_ERR(phy->pad_clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic void utmip_pad_power_on(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val, flags;\r\nvoid __iomem *base = phy->pad_regs;\r\nstruct tegra_utmip_config *config = phy->config;\r\nclk_prepare_enable(phy->pad_clk);\r\nspin_lock_irqsave(&utmip_pad_lock, flags);\r\nif (utmip_pad_count++ == 0) {\r\nval = readl(base + UTMIP_BIAS_CFG0);\r\nval &= ~(UTMIP_OTGPD | UTMIP_BIASPD);\r\nif (phy->soc_config->requires_extra_tuning_parameters) {\r\nval &= ~(UTMIP_HSSQUELCH_LEVEL(~0) |\r\nUTMIP_HSDISCON_LEVEL(~0) |\r\nUTMIP_HSDISCON_LEVEL_MSB(~0));\r\nval |= UTMIP_HSSQUELCH_LEVEL(config->hssquelch_level);\r\nval |= UTMIP_HSDISCON_LEVEL(config->hsdiscon_level);\r\nval |= UTMIP_HSDISCON_LEVEL_MSB(config->hsdiscon_level);\r\n}\r\nwritel(val, base + UTMIP_BIAS_CFG0);\r\n}\r\nspin_unlock_irqrestore(&utmip_pad_lock, flags);\r\nclk_disable_unprepare(phy->pad_clk);\r\n}\r\nstatic int utmip_pad_power_off(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val, flags;\r\nvoid __iomem *base = phy->pad_regs;\r\nif (!utmip_pad_count) {\r\npr_err("%s: utmip pad already powered off\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nclk_prepare_enable(phy->pad_clk);\r\nspin_lock_irqsave(&utmip_pad_lock, flags);\r\nif (--utmip_pad_count == 0) {\r\nval = readl(base + UTMIP_BIAS_CFG0);\r\nval |= UTMIP_OTGPD | UTMIP_BIASPD;\r\nwritel(val, base + UTMIP_BIAS_CFG0);\r\n}\r\nspin_unlock_irqrestore(&utmip_pad_lock, flags);\r\nclk_disable_unprepare(phy->pad_clk);\r\nreturn 0;\r\n}\r\nstatic int utmi_wait_register(void __iomem *reg, u32 mask, u32 result)\r\n{\r\nunsigned long timeout = 2000;\r\ndo {\r\nif ((readl(reg) & mask) == result)\r\nreturn 0;\r\nudelay(1);\r\ntimeout--;\r\n} while (timeout);\r\nreturn -1;\r\n}\r\nstatic void utmi_phy_clk_disable(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nif (phy->is_legacy_phy) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= USB_SUSP_SET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nudelay(10);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_SUSP_SET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\n} else\r\nset_phcd(phy, true);\r\nif (utmi_wait_register(base + USB_SUSP_CTRL, USB_PHY_CLK_VALID, 0) < 0)\r\npr_err("%s: timeout waiting for phy to stabilize\n", __func__);\r\n}\r\nstatic void utmi_phy_clk_enable(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nif (phy->is_legacy_phy) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= USB_SUSP_CLR;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nudelay(10);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_SUSP_CLR;\r\nwritel(val, base + USB_SUSP_CTRL);\r\n} else\r\nset_phcd(phy, false);\r\nif (utmi_wait_register(base + USB_SUSP_CTRL, USB_PHY_CLK_VALID,\r\nUSB_PHY_CLK_VALID))\r\npr_err("%s: timeout waiting for phy to stabilize\n", __func__);\r\n}\r\nstatic int utmi_phy_power_on(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nstruct tegra_utmip_config *config = phy->config;\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= UTMIP_RESET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nif (phy->is_legacy_phy) {\r\nval = readl(base + USB1_LEGACY_CTRL);\r\nval |= USB1_NO_LEGACY_MODE;\r\nwritel(val, base + USB1_LEGACY_CTRL);\r\n}\r\nval = readl(base + UTMIP_TX_CFG0);\r\nval |= UTMIP_FS_PREABMLE_J;\r\nwritel(val, base + UTMIP_TX_CFG0);\r\nval = readl(base + UTMIP_HSRX_CFG0);\r\nval &= ~(UTMIP_IDLE_WAIT(~0) | UTMIP_ELASTIC_LIMIT(~0));\r\nval |= UTMIP_IDLE_WAIT(config->idle_wait_delay);\r\nval |= UTMIP_ELASTIC_LIMIT(config->elastic_limit);\r\nwritel(val, base + UTMIP_HSRX_CFG0);\r\nval = readl(base + UTMIP_HSRX_CFG1);\r\nval &= ~UTMIP_HS_SYNC_START_DLY(~0);\r\nval |= UTMIP_HS_SYNC_START_DLY(config->hssync_start_delay);\r\nwritel(val, base + UTMIP_HSRX_CFG1);\r\nval = readl(base + UTMIP_DEBOUNCE_CFG0);\r\nval &= ~UTMIP_BIAS_DEBOUNCE_A(~0);\r\nval |= UTMIP_BIAS_DEBOUNCE_A(phy->freq->debounce);\r\nwritel(val, base + UTMIP_DEBOUNCE_CFG0);\r\nval = readl(base + UTMIP_MISC_CFG0);\r\nval &= ~UTMIP_SUSPEND_EXIT_ON_EDGE;\r\nwritel(val, base + UTMIP_MISC_CFG0);\r\nif (!phy->soc_config->utmi_pll_config_in_car_module) {\r\nval = readl(base + UTMIP_MISC_CFG1);\r\nval &= ~(UTMIP_PLL_ACTIVE_DLY_COUNT(~0) |\r\nUTMIP_PLLU_STABLE_COUNT(~0));\r\nval |= UTMIP_PLL_ACTIVE_DLY_COUNT(phy->freq->active_delay) |\r\nUTMIP_PLLU_STABLE_COUNT(phy->freq->stable_count);\r\nwritel(val, base + UTMIP_MISC_CFG1);\r\nval = readl(base + UTMIP_PLL_CFG1);\r\nval &= ~(UTMIP_XTAL_FREQ_COUNT(~0) |\r\nUTMIP_PLLU_ENABLE_DLY_COUNT(~0));\r\nval |= UTMIP_XTAL_FREQ_COUNT(phy->freq->xtal_freq_count) |\r\nUTMIP_PLLU_ENABLE_DLY_COUNT(phy->freq->enable_delay);\r\nwritel(val, base + UTMIP_PLL_CFG1);\r\n}\r\nif (phy->mode == USB_DR_MODE_PERIPHERAL) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~(USB_WAKE_ON_CNNT_EN_DEV | USB_WAKE_ON_DISCON_EN_DEV);\r\nwritel(val, base + USB_SUSP_CTRL);\r\nval = readl(base + UTMIP_BAT_CHRG_CFG0);\r\nval &= ~UTMIP_PD_CHRG;\r\nwritel(val, base + UTMIP_BAT_CHRG_CFG0);\r\n} else {\r\nval = readl(base + UTMIP_BAT_CHRG_CFG0);\r\nval |= UTMIP_PD_CHRG;\r\nwritel(val, base + UTMIP_BAT_CHRG_CFG0);\r\n}\r\nutmip_pad_power_on(phy);\r\nval = readl(base + UTMIP_XCVR_CFG0);\r\nval &= ~(UTMIP_FORCE_PD_POWERDOWN | UTMIP_FORCE_PD2_POWERDOWN |\r\nUTMIP_FORCE_PDZI_POWERDOWN | UTMIP_XCVR_LSBIAS_SEL |\r\nUTMIP_XCVR_SETUP(~0) | UTMIP_XCVR_SETUP_MSB(~0) |\r\nUTMIP_XCVR_LSFSLEW(~0) | UTMIP_XCVR_LSRSLEW(~0));\r\nif (!config->xcvr_setup_use_fuses) {\r\nval |= UTMIP_XCVR_SETUP(config->xcvr_setup);\r\nval |= UTMIP_XCVR_SETUP_MSB(config->xcvr_setup);\r\n}\r\nval |= UTMIP_XCVR_LSFSLEW(config->xcvr_lsfslew);\r\nval |= UTMIP_XCVR_LSRSLEW(config->xcvr_lsrslew);\r\nif (phy->soc_config->requires_extra_tuning_parameters) {\r\nval &= ~(UTMIP_XCVR_HSSLEW(~0) | UTMIP_XCVR_HSSLEW_MSB(~0));\r\nval |= UTMIP_XCVR_HSSLEW(config->xcvr_hsslew);\r\nval |= UTMIP_XCVR_HSSLEW_MSB(config->xcvr_hsslew);\r\n}\r\nwritel(val, base + UTMIP_XCVR_CFG0);\r\nval = readl(base + UTMIP_XCVR_CFG1);\r\nval &= ~(UTMIP_FORCE_PDDISC_POWERDOWN | UTMIP_FORCE_PDCHRP_POWERDOWN |\r\nUTMIP_FORCE_PDDR_POWERDOWN | UTMIP_XCVR_TERM_RANGE_ADJ(~0));\r\nval |= UTMIP_XCVR_TERM_RANGE_ADJ(config->term_range_adj);\r\nwritel(val, base + UTMIP_XCVR_CFG1);\r\nval = readl(base + UTMIP_BIAS_CFG1);\r\nval &= ~UTMIP_BIAS_PDTRK_COUNT(~0);\r\nval |= UTMIP_BIAS_PDTRK_COUNT(0x5);\r\nwritel(val, base + UTMIP_BIAS_CFG1);\r\nval = readl(base + UTMIP_SPARE_CFG0);\r\nif (config->xcvr_setup_use_fuses)\r\nval |= FUSE_SETUP_SEL;\r\nelse\r\nval &= ~FUSE_SETUP_SEL;\r\nwritel(val, base + UTMIP_SPARE_CFG0);\r\nif (!phy->is_legacy_phy) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= UTMIP_PHY_ENABLE;\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~UTMIP_RESET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nif (phy->is_legacy_phy) {\r\nval = readl(base + USB1_LEGACY_CTRL);\r\nval &= ~USB1_VBUS_SENSE_CTL_MASK;\r\nval |= USB1_VBUS_SENSE_CTL_A_SESS_VLD;\r\nwritel(val, base + USB1_LEGACY_CTRL);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_SUSP_SET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nutmi_phy_clk_enable(phy);\r\nif (phy->soc_config->requires_usbmode_setup) {\r\nval = readl(base + USB_USBMODE);\r\nval &= ~USB_USBMODE_MASK;\r\nif (phy->mode == USB_DR_MODE_HOST)\r\nval |= USB_USBMODE_HOST;\r\nelse\r\nval |= USB_USBMODE_DEVICE;\r\nwritel(val, base + USB_USBMODE);\r\n}\r\nif (!phy->is_legacy_phy)\r\nset_pts(phy, 0);\r\nreturn 0;\r\n}\r\nstatic int utmi_phy_power_off(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nutmi_phy_clk_disable(phy);\r\nif (phy->mode == USB_DR_MODE_PERIPHERAL) {\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_WAKEUP_DEBOUNCE_COUNT(~0);\r\nval |= USB_WAKE_ON_CNNT_EN_DEV | USB_WAKEUP_DEBOUNCE_COUNT(5);\r\nwritel(val, base + USB_SUSP_CTRL);\r\n}\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= UTMIP_RESET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nval = readl(base + UTMIP_BAT_CHRG_CFG0);\r\nval |= UTMIP_PD_CHRG;\r\nwritel(val, base + UTMIP_BAT_CHRG_CFG0);\r\nval = readl(base + UTMIP_XCVR_CFG0);\r\nval |= UTMIP_FORCE_PD_POWERDOWN | UTMIP_FORCE_PD2_POWERDOWN |\r\nUTMIP_FORCE_PDZI_POWERDOWN;\r\nwritel(val, base + UTMIP_XCVR_CFG0);\r\nval = readl(base + UTMIP_XCVR_CFG1);\r\nval |= UTMIP_FORCE_PDDISC_POWERDOWN | UTMIP_FORCE_PDCHRP_POWERDOWN |\r\nUTMIP_FORCE_PDDR_POWERDOWN;\r\nwritel(val, base + UTMIP_XCVR_CFG1);\r\nreturn utmip_pad_power_off(phy);\r\n}\r\nstatic void utmi_phy_preresume(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nval = readl(base + UTMIP_TX_CFG0);\r\nval |= UTMIP_HS_DISCON_DISABLE;\r\nwritel(val, base + UTMIP_TX_CFG0);\r\n}\r\nstatic void utmi_phy_postresume(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nval = readl(base + UTMIP_TX_CFG0);\r\nval &= ~UTMIP_HS_DISCON_DISABLE;\r\nwritel(val, base + UTMIP_TX_CFG0);\r\n}\r\nstatic void utmi_phy_restore_start(struct tegra_usb_phy *phy,\r\nenum tegra_usb_phy_port_speed port_speed)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nval = readl(base + UTMIP_MISC_CFG0);\r\nval &= ~UTMIP_DPDM_OBSERVE_SEL(~0);\r\nif (port_speed == TEGRA_USB_PHY_PORT_SPEED_LOW)\r\nval |= UTMIP_DPDM_OBSERVE_SEL_FS_K;\r\nelse\r\nval |= UTMIP_DPDM_OBSERVE_SEL_FS_J;\r\nwritel(val, base + UTMIP_MISC_CFG0);\r\nudelay(1);\r\nval = readl(base + UTMIP_MISC_CFG0);\r\nval |= UTMIP_DPDM_OBSERVE;\r\nwritel(val, base + UTMIP_MISC_CFG0);\r\nudelay(10);\r\n}\r\nstatic void utmi_phy_restore_end(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nval = readl(base + UTMIP_MISC_CFG0);\r\nval &= ~UTMIP_DPDM_OBSERVE;\r\nwritel(val, base + UTMIP_MISC_CFG0);\r\nudelay(10);\r\n}\r\nstatic int ulpi_phy_power_on(struct tegra_usb_phy *phy)\r\n{\r\nint ret;\r\nunsigned long val;\r\nvoid __iomem *base = phy->regs;\r\nret = gpio_direction_output(phy->reset_gpio, 0);\r\nif (ret < 0) {\r\ndev_err(phy->u_phy.dev, "gpio %d not set to 0\n",\r\nphy->reset_gpio);\r\nreturn ret;\r\n}\r\nmsleep(5);\r\nret = gpio_direction_output(phy->reset_gpio, 1);\r\nif (ret < 0) {\r\ndev_err(phy->u_phy.dev, "gpio %d not set to 1\n",\r\nphy->reset_gpio);\r\nreturn ret;\r\n}\r\nclk_prepare_enable(phy->clk);\r\nmsleep(1);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= UHSIC_RESET;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nval = readl(base + ULPI_TIMING_CTRL_0);\r\nval |= ULPI_OUTPUT_PINMUX_BYP | ULPI_CLKOUT_PINMUX_BYP;\r\nwritel(val, base + ULPI_TIMING_CTRL_0);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= ULPI_PHY_ENABLE;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nval = 0;\r\nwritel(val, base + ULPI_TIMING_CTRL_1);\r\nval |= ULPI_DATA_TRIMMER_SEL(4);\r\nval |= ULPI_STPDIRNXT_TRIMMER_SEL(4);\r\nval |= ULPI_DIR_TRIMMER_SEL(4);\r\nwritel(val, base + ULPI_TIMING_CTRL_1);\r\nudelay(10);\r\nval |= ULPI_DATA_TRIMMER_LOAD;\r\nval |= ULPI_STPDIRNXT_TRIMMER_LOAD;\r\nval |= ULPI_DIR_TRIMMER_LOAD;\r\nwritel(val, base + ULPI_TIMING_CTRL_1);\r\nret = usb_phy_io_write(phy->ulpi, 0x40, 0x08);\r\nif (ret) {\r\npr_err("%s: ulpi write failed\n", __func__);\r\nreturn ret;\r\n}\r\nret = usb_phy_io_write(phy->ulpi, 0x80, 0x0B);\r\nif (ret) {\r\npr_err("%s: ulpi write failed\n", __func__);\r\nreturn ret;\r\n}\r\nval = readl(base + USB_SUSP_CTRL);\r\nval |= USB_SUSP_CLR;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nudelay(100);\r\nval = readl(base + USB_SUSP_CTRL);\r\nval &= ~USB_SUSP_CLR;\r\nwritel(val, base + USB_SUSP_CTRL);\r\nreturn 0;\r\n}\r\nstatic int ulpi_phy_power_off(struct tegra_usb_phy *phy)\r\n{\r\nclk_disable(phy->clk);\r\nreturn gpio_direction_output(phy->reset_gpio, 0);\r\n}\r\nstatic void tegra_usb_phy_close(struct tegra_usb_phy *phy)\r\n{\r\nif (!IS_ERR(phy->vbus))\r\nregulator_disable(phy->vbus);\r\nclk_disable_unprepare(phy->pll_u);\r\n}\r\nstatic int tegra_usb_phy_power_on(struct tegra_usb_phy *phy)\r\n{\r\nif (phy->is_ulpi_phy)\r\nreturn ulpi_phy_power_on(phy);\r\nelse\r\nreturn utmi_phy_power_on(phy);\r\n}\r\nstatic int tegra_usb_phy_power_off(struct tegra_usb_phy *phy)\r\n{\r\nif (phy->is_ulpi_phy)\r\nreturn ulpi_phy_power_off(phy);\r\nelse\r\nreturn utmi_phy_power_off(phy);\r\n}\r\nstatic int tegra_usb_phy_suspend(struct usb_phy *x, int suspend)\r\n{\r\nstruct tegra_usb_phy *phy = container_of(x, struct tegra_usb_phy, u_phy);\r\nif (suspend)\r\nreturn tegra_usb_phy_power_off(phy);\r\nelse\r\nreturn tegra_usb_phy_power_on(phy);\r\n}\r\nstatic int ulpi_open(struct tegra_usb_phy *phy)\r\n{\r\nint err;\r\nphy->clk = devm_clk_get(phy->u_phy.dev, "ulpi-link");\r\nif (IS_ERR(phy->clk)) {\r\npr_err("%s: can't get ulpi clock\n", __func__);\r\nreturn PTR_ERR(phy->clk);\r\n}\r\nerr = devm_gpio_request(phy->u_phy.dev, phy->reset_gpio,\r\n"ulpi_phy_reset_b");\r\nif (err < 0) {\r\ndev_err(phy->u_phy.dev, "request failed for gpio: %d\n",\r\nphy->reset_gpio);\r\nreturn err;\r\n}\r\nerr = gpio_direction_output(phy->reset_gpio, 0);\r\nif (err < 0) {\r\ndev_err(phy->u_phy.dev, "gpio %d direction not set to output\n",\r\nphy->reset_gpio);\r\nreturn err;\r\n}\r\nphy->ulpi = otg_ulpi_create(&ulpi_viewport_access_ops, 0);\r\nif (!phy->ulpi) {\r\ndev_err(phy->u_phy.dev, "otg_ulpi_create returned NULL\n");\r\nerr = -ENOMEM;\r\nreturn err;\r\n}\r\nphy->ulpi->io_priv = phy->regs + ULPI_VIEWPORT;\r\nreturn 0;\r\n}\r\nstatic int tegra_usb_phy_init(struct tegra_usb_phy *phy)\r\n{\r\nunsigned long parent_rate;\r\nint i;\r\nint err;\r\nphy->pll_u = devm_clk_get(phy->u_phy.dev, "pll_u");\r\nif (IS_ERR(phy->pll_u)) {\r\npr_err("Can't get pll_u clock\n");\r\nreturn PTR_ERR(phy->pll_u);\r\n}\r\nerr = clk_prepare_enable(phy->pll_u);\r\nif (err)\r\nreturn err;\r\nparent_rate = clk_get_rate(clk_get_parent(phy->pll_u));\r\nfor (i = 0; i < ARRAY_SIZE(tegra_freq_table); i++) {\r\nif (tegra_freq_table[i].freq == parent_rate) {\r\nphy->freq = &tegra_freq_table[i];\r\nbreak;\r\n}\r\n}\r\nif (!phy->freq) {\r\npr_err("invalid pll_u parent rate %ld\n", parent_rate);\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nif (!IS_ERR(phy->vbus)) {\r\nerr = regulator_enable(phy->vbus);\r\nif (err) {\r\ndev_err(phy->u_phy.dev,\r\n"failed to enable usb vbus regulator: %d\n",\r\nerr);\r\ngoto fail;\r\n}\r\n}\r\nif (phy->is_ulpi_phy)\r\nerr = ulpi_open(phy);\r\nelse\r\nerr = utmip_pad_open(phy);\r\nif (err < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nclk_disable_unprepare(phy->pll_u);\r\nreturn err;\r\n}\r\nvoid tegra_usb_phy_preresume(struct usb_phy *x)\r\n{\r\nstruct tegra_usb_phy *phy = container_of(x, struct tegra_usb_phy, u_phy);\r\nif (!phy->is_ulpi_phy)\r\nutmi_phy_preresume(phy);\r\n}\r\nvoid tegra_usb_phy_postresume(struct usb_phy *x)\r\n{\r\nstruct tegra_usb_phy *phy = container_of(x, struct tegra_usb_phy, u_phy);\r\nif (!phy->is_ulpi_phy)\r\nutmi_phy_postresume(phy);\r\n}\r\nvoid tegra_ehci_phy_restore_start(struct usb_phy *x,\r\nenum tegra_usb_phy_port_speed port_speed)\r\n{\r\nstruct tegra_usb_phy *phy = container_of(x, struct tegra_usb_phy, u_phy);\r\nif (!phy->is_ulpi_phy)\r\nutmi_phy_restore_start(phy, port_speed);\r\n}\r\nvoid tegra_ehci_phy_restore_end(struct usb_phy *x)\r\n{\r\nstruct tegra_usb_phy *phy = container_of(x, struct tegra_usb_phy, u_phy);\r\nif (!phy->is_ulpi_phy)\r\nutmi_phy_restore_end(phy);\r\n}\r\nstatic int read_utmi_param(struct platform_device *pdev, const char *param,\r\nu8 *dest)\r\n{\r\nu32 value;\r\nint err = of_property_read_u32(pdev->dev.of_node, param, &value);\r\n*dest = (u8)value;\r\nif (err < 0)\r\ndev_err(&pdev->dev, "Failed to read USB UTMI parameter %s: %d\n",\r\nparam, err);\r\nreturn err;\r\n}\r\nstatic int utmi_phy_probe(struct tegra_usb_phy *tegra_phy,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint err;\r\nstruct tegra_utmip_config *config;\r\ntegra_phy->is_ulpi_phy = false;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Failed to get UTMI Pad regs\n");\r\nreturn -ENXIO;\r\n}\r\ntegra_phy->pad_regs = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!tegra_phy->pad_regs) {\r\ndev_err(&pdev->dev, "Failed to remap UTMI Pad regs\n");\r\nreturn -ENOMEM;\r\n}\r\ntegra_phy->config = devm_kzalloc(&pdev->dev, sizeof(*config),\r\nGFP_KERNEL);\r\nif (!tegra_phy->config) {\r\ndev_err(&pdev->dev,\r\n"unable to allocate memory for USB UTMIP config\n");\r\nreturn -ENOMEM;\r\n}\r\nconfig = tegra_phy->config;\r\nerr = read_utmi_param(pdev, "nvidia,hssync-start-delay",\r\n&config->hssync_start_delay);\r\nif (err < 0)\r\nreturn err;\r\nerr = read_utmi_param(pdev, "nvidia,elastic-limit",\r\n&config->elastic_limit);\r\nif (err < 0)\r\nreturn err;\r\nerr = read_utmi_param(pdev, "nvidia,idle-wait-delay",\r\n&config->idle_wait_delay);\r\nif (err < 0)\r\nreturn err;\r\nerr = read_utmi_param(pdev, "nvidia,term-range-adj",\r\n&config->term_range_adj);\r\nif (err < 0)\r\nreturn err;\r\nerr = read_utmi_param(pdev, "nvidia,xcvr-lsfslew",\r\n&config->xcvr_lsfslew);\r\nif (err < 0)\r\nreturn err;\r\nerr = read_utmi_param(pdev, "nvidia,xcvr-lsrslew",\r\n&config->xcvr_lsrslew);\r\nif (err < 0)\r\nreturn err;\r\nif (tegra_phy->soc_config->requires_extra_tuning_parameters) {\r\nerr = read_utmi_param(pdev, "nvidia,xcvr-hsslew",\r\n&config->xcvr_hsslew);\r\nif (err < 0)\r\nreturn err;\r\nerr = read_utmi_param(pdev, "nvidia,hssquelch-level",\r\n&config->hssquelch_level);\r\nif (err < 0)\r\nreturn err;\r\nerr = read_utmi_param(pdev, "nvidia,hsdiscon-level",\r\n&config->hsdiscon_level);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nconfig->xcvr_setup_use_fuses = of_property_read_bool(\r\npdev->dev.of_node, "nvidia,xcvr-setup-use-fuses");\r\nif (!config->xcvr_setup_use_fuses) {\r\nerr = read_utmi_param(pdev, "nvidia,xcvr-setup",\r\n&config->xcvr_setup);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nstruct tegra_usb_phy *tegra_phy = NULL;\r\nstruct device_node *np = pdev->dev.of_node;\r\nenum usb_phy_interface phy_type;\r\nint err;\r\ntegra_phy = devm_kzalloc(&pdev->dev, sizeof(*tegra_phy), GFP_KERNEL);\r\nif (!tegra_phy) {\r\ndev_err(&pdev->dev, "unable to allocate memory for USB2 PHY\n");\r\nreturn -ENOMEM;\r\n}\r\nmatch = of_match_device(tegra_usb_phy_id_table, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\ntegra_phy->soc_config = match->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Failed to get I/O memory\n");\r\nreturn -ENXIO;\r\n}\r\ntegra_phy->regs = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!tegra_phy->regs) {\r\ndev_err(&pdev->dev, "Failed to remap I/O memory\n");\r\nreturn -ENOMEM;\r\n}\r\ntegra_phy->is_legacy_phy =\r\nof_property_read_bool(np, "nvidia,has-legacy-mode");\r\nphy_type = of_usb_get_phy_mode(np);\r\nswitch (phy_type) {\r\ncase USBPHY_INTERFACE_MODE_UTMI:\r\nerr = utmi_phy_probe(tegra_phy, pdev);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase USBPHY_INTERFACE_MODE_ULPI:\r\ntegra_phy->is_ulpi_phy = true;\r\ntegra_phy->reset_gpio =\r\nof_get_named_gpio(np, "nvidia,phy-reset-gpio", 0);\r\nif (!gpio_is_valid(tegra_phy->reset_gpio)) {\r\ndev_err(&pdev->dev, "invalid gpio: %d\n",\r\ntegra_phy->reset_gpio);\r\nreturn tegra_phy->reset_gpio;\r\n}\r\ntegra_phy->config = NULL;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "phy_type is invalid or unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_find_property(np, "dr_mode", NULL))\r\ntegra_phy->mode = of_usb_get_dr_mode(np);\r\nelse\r\ntegra_phy->mode = USB_DR_MODE_HOST;\r\nif (tegra_phy->mode == USB_DR_MODE_UNKNOWN) {\r\ndev_err(&pdev->dev, "dr_mode is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif (of_find_property(np, "vbus-supply", NULL)) {\r\ntegra_phy->vbus = devm_regulator_get(&pdev->dev, "vbus");\r\nif (IS_ERR(tegra_phy->vbus))\r\nreturn PTR_ERR(tegra_phy->vbus);\r\n} else {\r\ndev_notice(&pdev->dev, "no vbus regulator");\r\ntegra_phy->vbus = ERR_PTR(-ENODEV);\r\n}\r\ntegra_phy->u_phy.dev = &pdev->dev;\r\nerr = tegra_usb_phy_init(tegra_phy);\r\nif (err < 0)\r\nreturn err;\r\ntegra_phy->u_phy.set_suspend = tegra_usb_phy_suspend;\r\nplatform_set_drvdata(pdev, tegra_phy);\r\nerr = usb_add_phy_dev(&tegra_phy->u_phy);\r\nif (err < 0) {\r\ntegra_usb_phy_close(tegra_phy);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_usb_phy_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_usb_phy *tegra_phy = platform_get_drvdata(pdev);\r\nusb_remove_phy(&tegra_phy->u_phy);\r\ntegra_usb_phy_close(tegra_phy);\r\nreturn 0;\r\n}
