static inline struct sirfsoc_uart_port *to_sirfport(struct uart_port *port)\r\n{\r\nreturn container_of(port, struct sirfsoc_uart_port, port);\r\n}\r\nstatic inline unsigned int sirfsoc_uart_tx_empty(struct uart_port *port)\r\n{\r\nunsigned long reg;\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_fifo_status *ufifo_st = &sirfport->uart_reg->fifo_status;\r\nreg = rd_regl(port, ureg->sirfsoc_tx_fifo_status);\r\nreturn (reg & ufifo_st->ff_empty(port->line)) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int sirfsoc_uart_get_mctrl(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nif (!sirfport->hw_flow_ctrl || !sirfport->ms_enabled)\r\ngoto cts_asserted;\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\nif (!(rd_regl(port, ureg->sirfsoc_afc_ctrl) &\r\nSIRFUART_AFC_CTS_STATUS))\r\ngoto cts_asserted;\r\nelse\r\ngoto cts_deasserted;\r\n} else {\r\nif (!gpio_get_value(sirfport->cts_gpio))\r\ngoto cts_asserted;\r\nelse\r\ngoto cts_deasserted;\r\n}\r\ncts_deasserted:\r\nreturn TIOCM_CAR | TIOCM_DSR;\r\ncts_asserted:\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void sirfsoc_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nunsigned int assert = mctrl & TIOCM_RTS;\r\nunsigned int val = assert ? SIRFUART_AFC_CTRL_RX_THD : 0x0;\r\nunsigned int current_val;\r\nif (!sirfport->hw_flow_ctrl || !sirfport->ms_enabled)\r\nreturn;\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\ncurrent_val = rd_regl(port, ureg->sirfsoc_afc_ctrl) & ~0xFF;\r\nval |= current_val;\r\nwr_regl(port, ureg->sirfsoc_afc_ctrl, val);\r\n} else {\r\nif (!val)\r\ngpio_set_value(sirfport->rts_gpio, 1);\r\nelse\r\ngpio_set_value(sirfport->rts_gpio, 0);\r\n}\r\n}\r\nstatic void sirfsoc_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nif (sirfport->tx_dma_chan) {\r\nif (sirfport->tx_dma_state == TX_DMA_RUNNING) {\r\ndmaengine_pause(sirfport->tx_dma_chan);\r\nsirfport->tx_dma_state = TX_DMA_PAUSE;\r\n} else {\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) &\r\n~uint_en->sirfsoc_txfifo_empty_en);\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nuint_en->sirfsoc_txfifo_empty_en);\r\n}\r\n} else {\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) &\r\n~uint_en->sirfsoc_txfifo_empty_en);\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nuint_en->sirfsoc_txfifo_empty_en);\r\n}\r\n}\r\nstatic void sirfsoc_uart_tx_with_dma(struct sirfsoc_uart_port *sirfport)\r\n{\r\nstruct uart_port *port = &sirfport->port;\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned long tran_size;\r\nunsigned long tran_start;\r\nunsigned long pio_tx_size;\r\ntran_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\ntran_start = (unsigned long)(xmit->buf + xmit->tail);\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port) ||\r\n!tran_size)\r\nreturn;\r\nif (sirfport->tx_dma_state == TX_DMA_PAUSE) {\r\ndmaengine_resume(sirfport->tx_dma_chan);\r\nreturn;\r\n}\r\nif (sirfport->tx_dma_state == TX_DMA_RUNNING)\r\nreturn;\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg)&\r\n~(uint_en->sirfsoc_txfifo_empty_en));\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nuint_en->sirfsoc_txfifo_empty_en);\r\nif (tran_size < 4 || BYTES_TO_ALIGN(tran_start)) {\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op, SIRFUART_FIFO_STOP);\r\nwr_regl(port, ureg->sirfsoc_tx_dma_io_ctrl,\r\nrd_regl(port, ureg->sirfsoc_tx_dma_io_ctrl)|\r\nSIRFUART_IO_MODE);\r\nif (BYTES_TO_ALIGN(tran_start)) {\r\npio_tx_size = sirfsoc_uart_pio_tx_chars(sirfport,\r\nBYTES_TO_ALIGN(tran_start));\r\ntran_size -= pio_tx_size;\r\n}\r\nif (tran_size < 4)\r\nsirfsoc_uart_pio_tx_chars(sirfport, tran_size);\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg)|\r\nuint_en->sirfsoc_txfifo_empty_en);\r\nelse\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nuint_en->sirfsoc_txfifo_empty_en);\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op, SIRFUART_FIFO_START);\r\n} else {\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op, SIRFUART_FIFO_STOP);\r\nwr_regl(port, ureg->sirfsoc_tx_dma_io_ctrl,\r\nrd_regl(port, ureg->sirfsoc_tx_dma_io_ctrl)&\r\n~SIRFUART_IO_MODE);\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op, SIRFUART_FIFO_START);\r\ntran_size &= ~(0x3);\r\nsirfport->tx_dma_addr = dma_map_single(port->dev,\r\nxmit->buf + xmit->tail,\r\ntran_size, DMA_TO_DEVICE);\r\nsirfport->tx_dma_desc = dmaengine_prep_slave_single(\r\nsirfport->tx_dma_chan, sirfport->tx_dma_addr,\r\ntran_size, DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\r\nif (!sirfport->tx_dma_desc) {\r\ndev_err(port->dev, "DMA prep slave single fail\n");\r\nreturn;\r\n}\r\nsirfport->tx_dma_desc->callback =\r\nsirfsoc_uart_tx_dma_complete_callback;\r\nsirfport->tx_dma_desc->callback_param = (void *)sirfport;\r\nsirfport->transfer_size = tran_size;\r\ndmaengine_submit(sirfport->tx_dma_desc);\r\ndma_async_issue_pending(sirfport->tx_dma_chan);\r\nsirfport->tx_dma_state = TX_DMA_RUNNING;\r\n}\r\n}\r\nstatic void sirfsoc_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nif (sirfport->tx_dma_chan)\r\nsirfsoc_uart_tx_with_dma(sirfport);\r\nelse {\r\nsirfsoc_uart_pio_tx_chars(sirfport,\r\nSIRFSOC_UART_IO_TX_REASONABLE_CNT);\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op, SIRFUART_FIFO_START);\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg)|\r\nuint_en->sirfsoc_txfifo_empty_en);\r\nelse\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nuint_en->sirfsoc_txfifo_empty_en);\r\n}\r\n}\r\nstatic void sirfsoc_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, 0);\r\nif (sirfport->rx_dma_chan) {\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) &\r\n~(SIRFUART_RX_DMA_INT_EN(port, uint_en) |\r\nuint_en->sirfsoc_rx_done_en));\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nSIRFUART_RX_DMA_INT_EN(port, uint_en)|\r\nuint_en->sirfsoc_rx_done_en);\r\ndmaengine_terminate_all(sirfport->rx_dma_chan);\r\n} else {\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg)&\r\n~(SIRFUART_RX_IO_INT_EN(port, uint_en)));\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nSIRFUART_RX_IO_INT_EN(port, uint_en));\r\n}\r\n}\r\nstatic void sirfsoc_uart_disable_ms(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nif (!sirfport->hw_flow_ctrl)\r\nreturn;\r\nsirfport->ms_enabled = false;\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\nwr_regl(port, ureg->sirfsoc_afc_ctrl,\r\nrd_regl(port, ureg->sirfsoc_afc_ctrl) & ~0x3FF);\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg)&\r\n~uint_en->sirfsoc_cts_en);\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nuint_en->sirfsoc_cts_en);\r\n} else\r\ndisable_irq(gpio_to_irq(sirfport->cts_gpio));\r\n}\r\nstatic irqreturn_t sirfsoc_uart_usp_cts_handler(int irq, void *dev_id)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = (struct sirfsoc_uart_port *)dev_id;\r\nstruct uart_port *port = &sirfport->port;\r\nspin_lock(&port->lock);\r\nif (gpio_is_valid(sirfport->cts_gpio) && sirfport->ms_enabled)\r\nuart_handle_cts_change(port,\r\n!gpio_get_value(sirfport->cts_gpio));\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sirfsoc_uart_enable_ms(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nif (!sirfport->hw_flow_ctrl)\r\nreturn;\r\nsirfport->ms_enabled = true;\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\nwr_regl(port, ureg->sirfsoc_afc_ctrl,\r\nrd_regl(port, ureg->sirfsoc_afc_ctrl) |\r\nSIRFUART_AFC_TX_EN | SIRFUART_AFC_RX_EN);\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg)\r\n| uint_en->sirfsoc_cts_en);\r\nelse\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nuint_en->sirfsoc_cts_en);\r\n} else\r\nenable_irq(gpio_to_irq(sirfport->cts_gpio));\r\n}\r\nstatic void sirfsoc_uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\nunsigned long ulcon = rd_regl(port, ureg->sirfsoc_line_ctrl);\r\nif (break_state)\r\nulcon |= SIRFUART_SET_BREAK;\r\nelse\r\nulcon &= ~SIRFUART_SET_BREAK;\r\nwr_regl(port, ureg->sirfsoc_line_ctrl, ulcon);\r\n}\r\n}\r\nstatic unsigned int\r\nsirfsoc_uart_pio_rx_chars(struct uart_port *port, unsigned int max_rx_count)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_fifo_status *ufifo_st = &sirfport->uart_reg->fifo_status;\r\nunsigned int ch, rx_count = 0;\r\nstruct tty_struct *tty;\r\ntty = tty_port_tty_get(&port->state->port);\r\nif (!tty)\r\nreturn -ENODEV;\r\nwhile (!(rd_regl(port, ureg->sirfsoc_rx_fifo_status) &\r\nufifo_st->ff_empty(port->line))) {\r\nch = rd_regl(port, ureg->sirfsoc_rx_fifo_data) |\r\nSIRFUART_DUMMY_READ;\r\nif (unlikely(uart_handle_sysrq_char(port, ch)))\r\ncontinue;\r\nuart_insert_char(port, 0, 0, ch, TTY_NORMAL);\r\nrx_count++;\r\nif (rx_count >= max_rx_count)\r\nbreak;\r\n}\r\nsirfport->rx_io_count += rx_count;\r\nport->icount.rx += rx_count;\r\nreturn rx_count;\r\n}\r\nstatic unsigned int\r\nsirfsoc_uart_pio_tx_chars(struct sirfsoc_uart_port *sirfport, int count)\r\n{\r\nstruct uart_port *port = &sirfport->port;\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_fifo_status *ufifo_st = &sirfport->uart_reg->fifo_status;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int num_tx = 0;\r\nwhile (!uart_circ_empty(xmit) &&\r\n!(rd_regl(port, ureg->sirfsoc_tx_fifo_status) &\r\nufifo_st->ff_full(port->line)) &&\r\ncount--) {\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_data,\r\nxmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nnum_tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nreturn num_tx;\r\n}\r\nstatic void sirfsoc_uart_tx_dma_complete_callback(void *param)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = (struct sirfsoc_uart_port *)param;\r\nstruct uart_port *port = &sirfport->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nxmit->tail = (xmit->tail + sirfport->transfer_size) &\r\n(UART_XMIT_SIZE - 1);\r\nport->icount.tx += sirfport->transfer_size;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (sirfport->tx_dma_addr)\r\ndma_unmap_single(port->dev, sirfport->tx_dma_addr,\r\nsirfport->transfer_size, DMA_TO_DEVICE);\r\nsirfport->tx_dma_state = TX_DMA_IDLE;\r\nsirfsoc_uart_tx_with_dma(sirfport);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void sirfsoc_uart_insert_rx_buf_to_tty(\r\nstruct sirfsoc_uart_port *sirfport, int count)\r\n{\r\nstruct uart_port *port = &sirfport->port;\r\nstruct tty_port *tport = &port->state->port;\r\nint inserted;\r\ninserted = tty_insert_flip_string(tport,\r\nsirfport->rx_dma_items[sirfport->rx_completed].xmit.buf, count);\r\nport->icount.rx += inserted;\r\n}\r\nstatic void sirfsoc_rx_submit_one_dma_desc(struct uart_port *port, int index)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nsirfport->rx_dma_items[index].xmit.tail =\r\nsirfport->rx_dma_items[index].xmit.head = 0;\r\nsirfport->rx_dma_items[index].desc =\r\ndmaengine_prep_slave_single(sirfport->rx_dma_chan,\r\nsirfport->rx_dma_items[index].dma_addr, SIRFSOC_RX_DMA_BUF_SIZE,\r\nDMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\r\nif (!sirfport->rx_dma_items[index].desc) {\r\ndev_err(port->dev, "DMA slave single fail\n");\r\nreturn;\r\n}\r\nsirfport->rx_dma_items[index].desc->callback =\r\nsirfsoc_uart_rx_dma_complete_callback;\r\nsirfport->rx_dma_items[index].desc->callback_param = sirfport;\r\nsirfport->rx_dma_items[index].cookie =\r\ndmaengine_submit(sirfport->rx_dma_items[index].desc);\r\ndma_async_issue_pending(sirfport->rx_dma_chan);\r\n}\r\nstatic void sirfsoc_rx_tmo_process_tl(unsigned long param)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = (struct sirfsoc_uart_port *)param;\r\nstruct uart_port *port = &sirfport->port;\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nstruct sirfsoc_int_status *uint_st = &sirfport->uart_reg->uart_int_st;\r\nunsigned int count;\r\nunsigned long flags;\r\nstruct dma_tx_state tx_state;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (DMA_COMPLETE == dmaengine_tx_status(sirfport->rx_dma_chan,\r\nsirfport->rx_dma_items[sirfport->rx_completed].cookie, &tx_state)) {\r\nsirfsoc_uart_insert_rx_buf_to_tty(sirfport,\r\nSIRFSOC_RX_DMA_BUF_SIZE);\r\nsirfport->rx_completed++;\r\nsirfport->rx_completed %= SIRFSOC_RX_LOOP_BUF_CNT;\r\n}\r\ncount = CIRC_CNT(sirfport->rx_dma_items[sirfport->rx_issued].xmit.head,\r\nsirfport->rx_dma_items[sirfport->rx_issued].xmit.tail,\r\nSIRFSOC_RX_DMA_BUF_SIZE);\r\nif (count > 0)\r\nsirfsoc_uart_insert_rx_buf_to_tty(sirfport, count);\r\nwr_regl(port, ureg->sirfsoc_rx_dma_io_ctrl,\r\nrd_regl(port, ureg->sirfsoc_rx_dma_io_ctrl) |\r\nSIRFUART_IO_MODE);\r\nsirfsoc_uart_pio_rx_chars(port, 4 - sirfport->rx_io_count);\r\nif (sirfport->rx_io_count == 4) {\r\nsirfport->rx_io_count = 0;\r\nwr_regl(port, ureg->sirfsoc_int_st_reg,\r\nuint_st->sirfsoc_rx_done);\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) &\r\n~(uint_en->sirfsoc_rx_done_en));\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nuint_en->sirfsoc_rx_done_en);\r\nsirfsoc_uart_start_next_rx_dma(port);\r\n} else {\r\nwr_regl(port, ureg->sirfsoc_int_st_reg,\r\nuint_st->sirfsoc_rx_done);\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) |\r\n(uint_en->sirfsoc_rx_done_en));\r\nelse\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nuint_en->sirfsoc_rx_done_en);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ntty_flip_buffer_push(&port->state->port);\r\n}\r\nstatic void sirfsoc_uart_handle_rx_tmo(struct sirfsoc_uart_port *sirfport)\r\n{\r\nstruct uart_port *port = &sirfport->port;\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nstruct dma_tx_state tx_state;\r\ndmaengine_tx_status(sirfport->rx_dma_chan,\r\nsirfport->rx_dma_items[sirfport->rx_issued].cookie, &tx_state);\r\ndmaengine_terminate_all(sirfport->rx_dma_chan);\r\nsirfport->rx_dma_items[sirfport->rx_issued].xmit.head =\r\nSIRFSOC_RX_DMA_BUF_SIZE - tx_state.residue;\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) &\r\n~(uint_en->sirfsoc_rx_timeout_en));\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nuint_en->sirfsoc_rx_timeout_en);\r\ntasklet_schedule(&sirfport->rx_tmo_process_tasklet);\r\n}\r\nstatic void sirfsoc_uart_handle_rx_done(struct sirfsoc_uart_port *sirfport)\r\n{\r\nstruct uart_port *port = &sirfport->port;\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nstruct sirfsoc_int_status *uint_st = &sirfport->uart_reg->uart_int_st;\r\nsirfsoc_uart_pio_rx_chars(port, 4 - sirfport->rx_io_count);\r\nif (sirfport->rx_io_count == 4) {\r\nsirfport->rx_io_count = 0;\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) &\r\n~(uint_en->sirfsoc_rx_done_en));\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR,\r\nuint_en->sirfsoc_rx_done_en);\r\nwr_regl(port, ureg->sirfsoc_int_st_reg,\r\nuint_st->sirfsoc_rx_timeout);\r\nsirfsoc_uart_start_next_rx_dma(port);\r\n}\r\n}\r\nstatic irqreturn_t sirfsoc_uart_isr(int irq, void *dev_id)\r\n{\r\nunsigned long intr_status;\r\nunsigned long cts_status;\r\nunsigned long flag = TTY_NORMAL;\r\nstruct sirfsoc_uart_port *sirfport = (struct sirfsoc_uart_port *)dev_id;\r\nstruct uart_port *port = &sirfport->port;\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_fifo_status *ufifo_st = &sirfport->uart_reg->fifo_status;\r\nstruct sirfsoc_int_status *uint_st = &sirfport->uart_reg->uart_int_st;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nstruct uart_state *state = port->state;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nspin_lock(&port->lock);\r\nintr_status = rd_regl(port, ureg->sirfsoc_int_st_reg);\r\nwr_regl(port, ureg->sirfsoc_int_st_reg, intr_status);\r\nintr_status &= rd_regl(port, ureg->sirfsoc_int_en_reg);\r\nif (unlikely(intr_status & (SIRFUART_ERR_INT_STAT(port, uint_st)))) {\r\nif (intr_status & uint_st->sirfsoc_rxd_brk) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ngoto recv_char;\r\n}\r\nif (intr_status & uint_st->sirfsoc_rx_oflow)\r\nport->icount.overrun++;\r\nif (intr_status & uint_st->sirfsoc_frm_err) {\r\nport->icount.frame++;\r\nflag = TTY_FRAME;\r\n}\r\nif (intr_status & uint_st->sirfsoc_parity_err)\r\nflag = TTY_PARITY;\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, SIRFUART_FIFO_RESET);\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, 0);\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, SIRFUART_FIFO_START);\r\nintr_status &= port->read_status_mask;\r\nuart_insert_char(port, intr_status,\r\nuint_en->sirfsoc_rx_oflow_en, 0, flag);\r\n}\r\nrecv_char:\r\nif ((sirfport->uart_reg->uart_type == SIRF_REAL_UART) &&\r\n(intr_status & SIRFUART_CTS_INT_ST(uint_st)) &&\r\n!sirfport->tx_dma_state) {\r\ncts_status = rd_regl(port, ureg->sirfsoc_afc_ctrl) &\r\nSIRFUART_AFC_CTS_STATUS;\r\nif (cts_status != 0)\r\ncts_status = 0;\r\nelse\r\ncts_status = 1;\r\nuart_handle_cts_change(port, cts_status);\r\nwake_up_interruptible(&state->port.delta_msr_wait);\r\n}\r\nif (sirfport->rx_dma_chan) {\r\nif (intr_status & uint_st->sirfsoc_rx_timeout)\r\nsirfsoc_uart_handle_rx_tmo(sirfport);\r\nif (intr_status & uint_st->sirfsoc_rx_done)\r\nsirfsoc_uart_handle_rx_done(sirfport);\r\n} else {\r\nif (intr_status & SIRFUART_RX_IO_INT_ST(uint_st))\r\nsirfsoc_uart_pio_rx_chars(port,\r\nSIRFSOC_UART_IO_RX_MAX_CNT);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(&state->port);\r\nspin_lock(&port->lock);\r\nif (intr_status & uint_st->sirfsoc_txfifo_empty) {\r\nif (sirfport->tx_dma_chan)\r\nsirfsoc_uart_tx_with_dma(sirfport);\r\nelse {\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n} else {\r\nsirfsoc_uart_pio_tx_chars(sirfport,\r\nSIRFSOC_UART_IO_TX_REASONABLE_CNT);\r\nif ((uart_circ_empty(xmit)) &&\r\n(rd_regl(port, ureg->sirfsoc_tx_fifo_status) &\r\nufifo_st->ff_empty(port->line)))\r\nsirfsoc_uart_stop_tx(port);\r\n}\r\n}\r\n}\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sirfsoc_uart_rx_dma_complete_tl(unsigned long param)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = (struct sirfsoc_uart_port *)param;\r\nstruct uart_port *port = &sirfport->port;\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nunsigned long flags;\r\nstruct dma_tx_state tx_state;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (DMA_COMPLETE == dmaengine_tx_status(sirfport->rx_dma_chan,\r\nsirfport->rx_dma_items[sirfport->rx_completed].cookie, &tx_state)) {\r\nsirfsoc_uart_insert_rx_buf_to_tty(sirfport,\r\nSIRFSOC_RX_DMA_BUF_SIZE);\r\nif (rd_regl(port, ureg->sirfsoc_int_en_reg) &\r\nuint_en->sirfsoc_rx_timeout_en)\r\nsirfsoc_rx_submit_one_dma_desc(port,\r\nsirfport->rx_completed++);\r\nelse\r\nsirfport->rx_completed++;\r\nsirfport->rx_completed %= SIRFSOC_RX_LOOP_BUF_CNT;\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ntty_flip_buffer_push(&port->state->port);\r\n}\r\nstatic void sirfsoc_uart_rx_dma_complete_callback(void *param)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = (struct sirfsoc_uart_port *)param;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sirfport->port.lock, flags);\r\nsirfport->rx_issued++;\r\nsirfport->rx_issued %= SIRFSOC_RX_LOOP_BUF_CNT;\r\ntasklet_schedule(&sirfport->rx_dma_complete_tasklet);\r\nspin_unlock_irqrestore(&sirfport->port.lock, flags);\r\n}\r\nstatic void sirfsoc_uart_start_next_rx_dma(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nint i;\r\nsirfport->rx_io_count = 0;\r\nwr_regl(port, ureg->sirfsoc_rx_dma_io_ctrl,\r\nrd_regl(port, ureg->sirfsoc_rx_dma_io_ctrl) &\r\n~SIRFUART_IO_MODE);\r\nfor (i = 0; i < SIRFSOC_RX_LOOP_BUF_CNT; i++)\r\nsirfsoc_rx_submit_one_dma_desc(port, i);\r\nsirfport->rx_completed = sirfport->rx_issued = 0;\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) |\r\nSIRFUART_RX_DMA_INT_EN(port, uint_en));\r\nelse\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nSIRFUART_RX_DMA_INT_EN(port, uint_en));\r\n}\r\nstatic void sirfsoc_uart_start_rx(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nsirfport->rx_io_count = 0;\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, SIRFUART_FIFO_RESET);\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, 0);\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, SIRFUART_FIFO_START);\r\nif (sirfport->rx_dma_chan)\r\nsirfsoc_uart_start_next_rx_dma(port);\r\nelse {\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nrd_regl(port, ureg->sirfsoc_int_en_reg) |\r\nSIRFUART_RX_IO_INT_EN(port, uint_en));\r\nelse\r\nwr_regl(port, ureg->sirfsoc_int_en_reg,\r\nSIRFUART_RX_IO_INT_EN(port, uint_en));\r\n}\r\n}\r\nstatic unsigned int\r\nsirfsoc_usp_calc_sample_div(unsigned long set_rate,\r\nunsigned long ioclk_rate, unsigned long *sample_reg)\r\n{\r\nunsigned long min_delta = ~0UL;\r\nunsigned short sample_div;\r\nunsigned long ioclk_div = 0;\r\nunsigned long temp_delta;\r\nfor (sample_div = SIRF_MIN_SAMPLE_DIV;\r\nsample_div <= SIRF_MAX_SAMPLE_DIV; sample_div++) {\r\ntemp_delta = ioclk_rate -\r\n(ioclk_rate + (set_rate * sample_div) / 2)\r\n/ (set_rate * sample_div) * set_rate * sample_div;\r\ntemp_delta = (temp_delta > 0) ? temp_delta : -temp_delta;\r\nif (temp_delta < min_delta) {\r\nioclk_div = (2 * ioclk_rate /\r\n(set_rate * sample_div) + 1) / 2 - 1;\r\nif (ioclk_div > SIRF_IOCLK_DIV_MAX)\r\ncontinue;\r\nmin_delta = temp_delta;\r\n*sample_reg = sample_div;\r\nif (!temp_delta)\r\nbreak;\r\n}\r\n}\r\nreturn ioclk_div;\r\n}\r\nstatic unsigned int\r\nsirfsoc_uart_calc_sample_div(unsigned long baud_rate,\r\nunsigned long ioclk_rate, unsigned long *set_baud)\r\n{\r\nunsigned long min_delta = ~0UL;\r\nunsigned short sample_div;\r\nunsigned int regv = 0;\r\nunsigned long ioclk_div;\r\nunsigned long baud_tmp;\r\nint temp_delta;\r\nfor (sample_div = SIRF_MIN_SAMPLE_DIV;\r\nsample_div <= SIRF_MAX_SAMPLE_DIV; sample_div++) {\r\nioclk_div = (ioclk_rate / (baud_rate * (sample_div + 1))) - 1;\r\nif (ioclk_div > SIRF_IOCLK_DIV_MAX)\r\ncontinue;\r\nbaud_tmp = ioclk_rate / ((ioclk_div + 1) * (sample_div + 1));\r\ntemp_delta = baud_tmp - baud_rate;\r\ntemp_delta = (temp_delta > 0) ? temp_delta : -temp_delta;\r\nif (temp_delta < min_delta) {\r\nregv = regv & (~SIRF_IOCLK_DIV_MASK);\r\nregv = regv | ioclk_div;\r\nregv = regv & (~SIRF_SAMPLE_DIV_MASK);\r\nregv = regv | (sample_div << SIRF_SAMPLE_DIV_SHIFT);\r\nmin_delta = temp_delta;\r\n*set_baud = baud_tmp;\r\n}\r\n}\r\nreturn regv;\r\n}\r\nstatic void sirfsoc_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_int_en *uint_en = &sirfport->uart_reg->uart_int_en;\r\nunsigned long config_reg = 0;\r\nunsigned long baud_rate;\r\nunsigned long set_baud;\r\nunsigned long flags;\r\nunsigned long ic;\r\nunsigned int clk_div_reg = 0;\r\nunsigned long txfifo_op_reg, ioclk_rate;\r\nunsigned long rx_time_out;\r\nint threshold_div;\r\nu32 data_bit_len, stop_bit_len, len_val;\r\nunsigned long sample_div_reg = 0xf;\r\nioclk_rate = port->uartclk;\r\nswitch (termios->c_cflag & CSIZE) {\r\ndefault:\r\ncase CS8:\r\ndata_bit_len = 8;\r\nconfig_reg |= SIRFUART_DATA_BIT_LEN_8;\r\nbreak;\r\ncase CS7:\r\ndata_bit_len = 7;\r\nconfig_reg |= SIRFUART_DATA_BIT_LEN_7;\r\nbreak;\r\ncase CS6:\r\ndata_bit_len = 6;\r\nconfig_reg |= SIRFUART_DATA_BIT_LEN_6;\r\nbreak;\r\ncase CS5:\r\ndata_bit_len = 5;\r\nconfig_reg |= SIRFUART_DATA_BIT_LEN_5;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB) {\r\nconfig_reg |= SIRFUART_STOP_BIT_LEN_2;\r\nstop_bit_len = 2;\r\n} else\r\nstop_bit_len = 1;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->read_status_mask = uint_en->sirfsoc_rx_oflow_en;\r\nport->ignore_status_mask = 0;\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= uint_en->sirfsoc_frm_err_en |\r\nuint_en->sirfsoc_parity_err_en;\r\n} else {\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= uint_en->sirfsoc_frm_err_en;\r\n}\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= uint_en->sirfsoc_rxd_brk_en;\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |=\r\nuint_en->sirfsoc_frm_err_en |\r\nuint_en->sirfsoc_parity_err_en;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\nconfig_reg |= SIRFUART_STICK_BIT_MARK;\r\nelse\r\nconfig_reg |= SIRFUART_STICK_BIT_SPACE;\r\n} else if (termios->c_cflag & PARODD) {\r\nconfig_reg |= SIRFUART_STICK_BIT_ODD;\r\n} else {\r\nconfig_reg |= SIRFUART_STICK_BIT_EVEN;\r\n}\r\n}\r\n} else {\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |=\r\nuint_en->sirfsoc_frm_err_en;\r\nif (termios->c_cflag & PARENB)\r\ndev_warn(port->dev,\r\n"USP-UART not support parity err\n");\r\n}\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |=\r\nuint_en->sirfsoc_rxd_brk_en;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |=\r\nuint_en->sirfsoc_rx_oflow_en;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= SIRFUART_DUMMY_READ;\r\nif (UART_ENABLE_MS(port, termios->c_cflag)) {\r\nif (!sirfport->ms_enabled)\r\nsirfsoc_uart_enable_ms(port);\r\n} else {\r\nif (sirfport->ms_enabled)\r\nsirfsoc_uart_disable_ms(port);\r\n}\r\nbaud_rate = uart_get_baud_rate(port, termios, old, 0, 4000000);\r\nif (ioclk_rate == 150000000) {\r\nfor (ic = 0; ic < SIRF_BAUD_RATE_SUPPORT_NR; ic++)\r\nif (baud_rate == baudrate_to_regv[ic].baud_rate)\r\nclk_div_reg = baudrate_to_regv[ic].reg_val;\r\n}\r\nset_baud = baud_rate;\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\nif (unlikely(clk_div_reg == 0))\r\nclk_div_reg = sirfsoc_uart_calc_sample_div(baud_rate,\r\nioclk_rate, &set_baud);\r\nwr_regl(port, ureg->sirfsoc_divisor, clk_div_reg);\r\n} else {\r\nclk_div_reg = sirfsoc_usp_calc_sample_div(baud_rate,\r\nioclk_rate, &sample_div_reg);\r\nsample_div_reg--;\r\nset_baud = ((ioclk_rate / (clk_div_reg+1) - 1) /\r\n(sample_div_reg + 1));\r\nlen_val = ((1 << SIRFSOC_USP_MODE2_RXD_DELAY_OFFSET) |\r\n(1 << SIRFSOC_USP_MODE2_TXD_DELAY_OFFSET));\r\nlen_val |= ((clk_div_reg & SIRFSOC_USP_MODE2_CLK_DIVISOR_MASK)\r\n<< SIRFSOC_USP_MODE2_CLK_DIVISOR_OFFSET);\r\nwr_regl(port, ureg->sirfsoc_mode2, len_val);\r\n}\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, set_baud, set_baud);\r\nrx_time_out = SIRFSOC_UART_RX_TIMEOUT(set_baud, 20000);\r\nrx_time_out = SIRFUART_RECV_TIMEOUT_VALUE(rx_time_out);\r\ntxfifo_op_reg = rd_regl(port, ureg->sirfsoc_tx_fifo_op);\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, SIRFUART_FIFO_STOP);\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op,\r\n(txfifo_op_reg & ~SIRFUART_FIFO_START));\r\nif (sirfport->uart_reg->uart_type == SIRF_REAL_UART) {\r\nconfig_reg |= SIRFUART_RECV_TIMEOUT(port, rx_time_out);\r\nwr_regl(port, ureg->sirfsoc_line_ctrl, config_reg);\r\n} else {\r\nlen_val = (data_bit_len - 1) << SIRFSOC_USP_TX_DATA_LEN_OFFSET;\r\nlen_val |= (data_bit_len + 1 + stop_bit_len - 1) <<\r\nSIRFSOC_USP_TX_FRAME_LEN_OFFSET;\r\nlen_val |= ((data_bit_len - 1) <<\r\nSIRFSOC_USP_TX_SHIFTER_LEN_OFFSET);\r\nlen_val |= (((clk_div_reg & 0xc00) >> 10) <<\r\nSIRFSOC_USP_TX_CLK_DIVISOR_OFFSET);\r\nwr_regl(port, ureg->sirfsoc_tx_frame_ctrl, len_val);\r\nlen_val = (data_bit_len - 1) << SIRFSOC_USP_RX_DATA_LEN_OFFSET;\r\nlen_val |= (data_bit_len + 1 + stop_bit_len - 1) <<\r\nSIRFSOC_USP_RX_FRAME_LEN_OFFSET;\r\nlen_val |= (data_bit_len - 1) <<\r\nSIRFSOC_USP_RX_SHIFTER_LEN_OFFSET;\r\nlen_val |= (((clk_div_reg & 0xf000) >> 12) <<\r\nSIRFSOC_USP_RX_CLK_DIVISOR_OFFSET);\r\nwr_regl(port, ureg->sirfsoc_rx_frame_ctrl, len_val);\r\nwr_regl(port, ureg->sirfsoc_async_param_reg,\r\n(SIRFUART_RECV_TIMEOUT(port, rx_time_out)) |\r\n(sample_div_reg & SIRFSOC_USP_ASYNC_DIV2_MASK) <<\r\nSIRFSOC_USP_ASYNC_DIV2_OFFSET);\r\n}\r\nif (sirfport->tx_dma_chan)\r\nwr_regl(port, ureg->sirfsoc_tx_dma_io_ctrl, SIRFUART_DMA_MODE);\r\nelse\r\nwr_regl(port, ureg->sirfsoc_tx_dma_io_ctrl, SIRFUART_IO_MODE);\r\nif (sirfport->rx_dma_chan)\r\nwr_regl(port, ureg->sirfsoc_rx_dma_io_ctrl, SIRFUART_DMA_MODE);\r\nelse\r\nwr_regl(port, ureg->sirfsoc_rx_dma_io_ctrl, SIRFUART_IO_MODE);\r\nif (set_baud < 1000000)\r\nthreshold_div = 1;\r\nelse\r\nthreshold_div = 2;\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_ctrl,\r\nSIRFUART_FIFO_THD(port) / threshold_div);\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_ctrl,\r\nSIRFUART_FIFO_THD(port) / threshold_div);\r\ntxfifo_op_reg |= SIRFUART_FIFO_START;\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op, txfifo_op_reg);\r\nuart_update_timeout(port, termios->c_cflag, set_baud);\r\nsirfsoc_uart_start_rx(port);\r\nwr_regl(port, ureg->sirfsoc_tx_rx_en, SIRFUART_TX_EN | SIRFUART_RX_EN);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void sirfsoc_uart_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nif (!state)\r\nclk_prepare_enable(sirfport->clk);\r\nelse\r\nclk_disable_unprepare(sirfport->clk);\r\n}\r\nstatic int sirfsoc_uart_startup(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nunsigned int index = port->line;\r\nint ret;\r\nset_irq_flags(port->irq, IRQF_VALID | IRQF_NOAUTOEN);\r\nret = request_irq(port->irq,\r\nsirfsoc_uart_isr,\r\n0,\r\nSIRFUART_PORT_NAME,\r\nsirfport);\r\nif (ret != 0) {\r\ndev_err(port->dev, "UART%d request IRQ line (%d) failed.\n",\r\nindex, port->irq);\r\ngoto irq_err;\r\n}\r\nwr_regl(port, ureg->sirfsoc_tx_dma_io_ctrl,\r\nrd_regl(port, ureg->sirfsoc_tx_dma_io_ctrl) |\r\nSIRFUART_IO_MODE);\r\nwr_regl(port, ureg->sirfsoc_rx_dma_io_ctrl,\r\nrd_regl(port, ureg->sirfsoc_rx_dma_io_ctrl) |\r\nSIRFUART_IO_MODE);\r\nwr_regl(port, ureg->sirfsoc_tx_dma_io_len, 0);\r\nwr_regl(port, ureg->sirfsoc_rx_dma_io_len, 0);\r\nwr_regl(port, ureg->sirfsoc_tx_rx_en, SIRFUART_RX_EN | SIRFUART_TX_EN);\r\nif (sirfport->uart_reg->uart_type == SIRF_USP_UART)\r\nwr_regl(port, ureg->sirfsoc_mode1,\r\nSIRFSOC_USP_ENDIAN_CTRL_LSBF |\r\nSIRFSOC_USP_EN);\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op, SIRFUART_FIFO_RESET);\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_op, 0);\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, SIRFUART_FIFO_RESET);\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_op, 0);\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_ctrl, SIRFUART_FIFO_THD(port));\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_ctrl, SIRFUART_FIFO_THD(port));\r\nif (sirfport->rx_dma_chan)\r\nwr_regl(port, ureg->sirfsoc_rx_fifo_level_chk,\r\nSIRFUART_RX_FIFO_CHK_SC(port->line, 0x4) |\r\nSIRFUART_RX_FIFO_CHK_LC(port->line, 0xe) |\r\nSIRFUART_RX_FIFO_CHK_HC(port->line, 0x1b));\r\nif (sirfport->tx_dma_chan) {\r\nsirfport->tx_dma_state = TX_DMA_IDLE;\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_level_chk,\r\nSIRFUART_TX_FIFO_CHK_SC(port->line, 0x1b) |\r\nSIRFUART_TX_FIFO_CHK_LC(port->line, 0xe) |\r\nSIRFUART_TX_FIFO_CHK_HC(port->line, 0x4));\r\n}\r\nsirfport->ms_enabled = false;\r\nif (sirfport->uart_reg->uart_type == SIRF_USP_UART &&\r\nsirfport->hw_flow_ctrl) {\r\nset_irq_flags(gpio_to_irq(sirfport->cts_gpio),\r\nIRQF_VALID | IRQF_NOAUTOEN);\r\nret = request_irq(gpio_to_irq(sirfport->cts_gpio),\r\nsirfsoc_uart_usp_cts_handler, IRQF_TRIGGER_FALLING |\r\nIRQF_TRIGGER_RISING, "usp_cts_irq", sirfport);\r\nif (ret != 0) {\r\ndev_err(port->dev, "UART-USP:request gpio irq fail\n");\r\ngoto init_rx_err;\r\n}\r\n}\r\nenable_irq(port->irq);\r\nreturn 0;\r\ninit_rx_err:\r\nfree_irq(port->irq, sirfport);\r\nirq_err:\r\nreturn ret;\r\n}\r\nstatic void sirfsoc_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nif (!sirfport->is_marco)\r\nwr_regl(port, ureg->sirfsoc_int_en_reg, 0);\r\nelse\r\nwr_regl(port, SIRFUART_INT_EN_CLR, ~0UL);\r\nfree_irq(port->irq, sirfport);\r\nif (sirfport->ms_enabled)\r\nsirfsoc_uart_disable_ms(port);\r\nif (sirfport->uart_reg->uart_type == SIRF_USP_UART &&\r\nsirfport->hw_flow_ctrl) {\r\ngpio_set_value(sirfport->rts_gpio, 1);\r\nfree_irq(gpio_to_irq(sirfport->cts_gpio), sirfport);\r\n}\r\nif (sirfport->tx_dma_chan)\r\nsirfport->tx_dma_state = TX_DMA_IDLE;\r\n}\r\nstatic const char *sirfsoc_uart_type(struct uart_port *port)\r\n{\r\nreturn port->type == SIRFSOC_PORT_TYPE ? SIRFUART_PORT_NAME : NULL;\r\n}\r\nstatic int sirfsoc_uart_request_port(struct uart_port *port)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_uart_param *uart_param = &sirfport->uart_reg->uart_param;\r\nvoid *ret;\r\nret = request_mem_region(port->mapbase,\r\nSIRFUART_MAP_SIZE, uart_param->port_name);\r\nreturn ret ? 0 : -EBUSY;\r\n}\r\nstatic void sirfsoc_uart_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, SIRFUART_MAP_SIZE);\r\n}\r\nstatic void sirfsoc_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = SIRFSOC_PORT_TYPE;\r\nsirfsoc_uart_request_port(port);\r\n}\r\n}\r\nstatic int __init\r\nsirfsoc_uart_console_setup(struct console *co, char *options)\r\n{\r\nunsigned int baud = 115200;\r\nunsigned int bits = 8;\r\nunsigned int parity = 'n';\r\nunsigned int flow = 'n';\r\nstruct uart_port *port = &sirfsoc_uart_ports[co->index].port;\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nif (co->index < 0 || co->index >= SIRFSOC_UART_NR)\r\nreturn -EINVAL;\r\nif (!port->mapbase)\r\nreturn -ENODEV;\r\nif (sirfport->uart_reg->uart_type == SIRF_USP_UART)\r\nwr_regl(port, ureg->sirfsoc_mode1, SIRFSOC_USP_EN |\r\nSIRFSOC_USP_ENDIAN_CTRL_LSBF);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nport->cons = co;\r\nsirfport->rx_dma_chan = NULL;\r\nsirfport->tx_dma_chan = NULL;\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic void sirfsoc_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = to_sirfport(port);\r\nstruct sirfsoc_register *ureg = &sirfport->uart_reg->uart_reg;\r\nstruct sirfsoc_fifo_status *ufifo_st = &sirfport->uart_reg->fifo_status;\r\nwhile (rd_regl(port,\r\nureg->sirfsoc_tx_fifo_status) & ufifo_st->ff_full(port->line))\r\ncpu_relax();\r\nwr_regl(port, ureg->sirfsoc_tx_fifo_data, ch);\r\n}\r\nstatic void sirfsoc_uart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &sirfsoc_uart_ports[co->index].port;\r\nuart_console_write(port, s, count, sirfsoc_uart_console_putchar);\r\n}\r\nstatic int __init sirfsoc_uart_console_init(void)\r\n{\r\nregister_console(&sirfsoc_uart_console);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct sirfsoc_uart_port *sirfport;\r\nstruct uart_port *port;\r\nstruct resource *res;\r\nint ret;\r\nint i, j;\r\nstruct dma_slave_config slv_cfg = {\r\n.src_maxburst = 2,\r\n};\r\nstruct dma_slave_config tx_slv_cfg = {\r\n.dst_maxburst = 2,\r\n};\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(sirfsoc_uart_ids, pdev->dev.of_node);\r\nif (of_property_read_u32(pdev->dev.of_node, "cell-index", &pdev->id)) {\r\ndev_err(&pdev->dev,\r\n"Unable to find cell-index in uart node.\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nif (of_device_is_compatible(pdev->dev.of_node, "sirf,prima2-usp-uart"))\r\npdev->id += ((struct sirfsoc_uart_register *)\r\nmatch->data)->uart_param.register_uart_nr;\r\nsirfport = &sirfsoc_uart_ports[pdev->id];\r\nport = &sirfport->port;\r\nport->dev = &pdev->dev;\r\nport->private_data = sirfport;\r\nsirfport->uart_reg = (struct sirfsoc_uart_register *)match->data;\r\nsirfport->hw_flow_ctrl = of_property_read_bool(pdev->dev.of_node,\r\n"sirf,uart-has-rtscts");\r\nif (of_device_is_compatible(pdev->dev.of_node, "sirf,prima2-uart"))\r\nsirfport->uart_reg->uart_type = SIRF_REAL_UART;\r\nif (of_device_is_compatible(pdev->dev.of_node, "sirf,prima2-usp-uart")) {\r\nsirfport->uart_reg->uart_type = SIRF_USP_UART;\r\nif (!sirfport->hw_flow_ctrl)\r\ngoto usp_no_flow_control;\r\nif (of_find_property(pdev->dev.of_node, "cts-gpios", NULL))\r\nsirfport->cts_gpio = of_get_named_gpio(\r\npdev->dev.of_node, "cts-gpios", 0);\r\nelse\r\nsirfport->cts_gpio = -1;\r\nif (of_find_property(pdev->dev.of_node, "rts-gpios", NULL))\r\nsirfport->rts_gpio = of_get_named_gpio(\r\npdev->dev.of_node, "rts-gpios", 0);\r\nelse\r\nsirfport->rts_gpio = -1;\r\nif ((!gpio_is_valid(sirfport->cts_gpio) ||\r\n!gpio_is_valid(sirfport->rts_gpio))) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev,\r\n"Usp flow control must have cts and rts gpio");\r\ngoto err;\r\n}\r\nret = devm_gpio_request(&pdev->dev, sirfport->cts_gpio,\r\n"usp-cts-gpio");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable request cts gpio");\r\ngoto err;\r\n}\r\ngpio_direction_input(sirfport->cts_gpio);\r\nret = devm_gpio_request(&pdev->dev, sirfport->rts_gpio,\r\n"usp-rts-gpio");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable request rts gpio");\r\ngoto err;\r\n}\r\ngpio_direction_output(sirfport->rts_gpio, 1);\r\n}\r\nusp_no_flow_control:\r\nif (of_device_is_compatible(pdev->dev.of_node, "sirf,marco-uart"))\r\nsirfport->is_marco = true;\r\nif (of_property_read_u32(pdev->dev.of_node,\r\n"fifosize",\r\n&port->fifosize)) {\r\ndev_err(&pdev->dev,\r\n"Unable to find fifosize in uart node.\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "Insufficient resources.\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\ntasklet_init(&sirfport->rx_dma_complete_tasklet,\r\nsirfsoc_uart_rx_dma_complete_tl, (unsigned long)sirfport);\r\ntasklet_init(&sirfport->rx_tmo_process_tasklet,\r\nsirfsoc_rx_tmo_process_tl, (unsigned long)sirfport);\r\nport->mapbase = res->start;\r\nport->membase = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!port->membase) {\r\ndev_err(&pdev->dev, "Cannot remap resource.\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "Insufficient resources.\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nport->irq = res->start;\r\nsirfport->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(sirfport->clk)) {\r\nret = PTR_ERR(sirfport->clk);\r\ngoto err;\r\n}\r\nport->uartclk = clk_get_rate(sirfport->clk);\r\nport->ops = &sirfsoc_uart_ops;\r\nspin_lock_init(&port->lock);\r\nplatform_set_drvdata(pdev, sirfport);\r\nret = uart_add_one_port(&sirfsoc_uart_drv, port);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Cannot add UART port(%d).\n", pdev->id);\r\ngoto port_err;\r\n}\r\nsirfport->rx_dma_chan = dma_request_slave_channel(port->dev, "rx");\r\nfor (i = 0; sirfport->rx_dma_chan && i < SIRFSOC_RX_LOOP_BUF_CNT; i++) {\r\nsirfport->rx_dma_items[i].xmit.buf =\r\ndma_alloc_coherent(port->dev, SIRFSOC_RX_DMA_BUF_SIZE,\r\n&sirfport->rx_dma_items[i].dma_addr, GFP_KERNEL);\r\nif (!sirfport->rx_dma_items[i].xmit.buf) {\r\ndev_err(port->dev, "Uart alloc bufa failed\n");\r\nret = -ENOMEM;\r\ngoto alloc_coherent_err;\r\n}\r\nsirfport->rx_dma_items[i].xmit.head =\r\nsirfport->rx_dma_items[i].xmit.tail = 0;\r\n}\r\nif (sirfport->rx_dma_chan)\r\ndmaengine_slave_config(sirfport->rx_dma_chan, &slv_cfg);\r\nsirfport->tx_dma_chan = dma_request_slave_channel(port->dev, "tx");\r\nif (sirfport->tx_dma_chan)\r\ndmaengine_slave_config(sirfport->tx_dma_chan, &tx_slv_cfg);\r\nreturn 0;\r\nalloc_coherent_err:\r\nfor (j = 0; j < i; j++)\r\ndma_free_coherent(port->dev, SIRFSOC_RX_DMA_BUF_SIZE,\r\nsirfport->rx_dma_items[j].xmit.buf,\r\nsirfport->rx_dma_items[j].dma_addr);\r\ndma_release_channel(sirfport->rx_dma_chan);\r\nport_err:\r\nclk_put(sirfport->clk);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int sirfsoc_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = platform_get_drvdata(pdev);\r\nstruct uart_port *port = &sirfport->port;\r\nclk_put(sirfport->clk);\r\nuart_remove_one_port(&sirfsoc_uart_drv, port);\r\nif (sirfport->rx_dma_chan) {\r\nint i;\r\ndmaengine_terminate_all(sirfport->rx_dma_chan);\r\ndma_release_channel(sirfport->rx_dma_chan);\r\nfor (i = 0; i < SIRFSOC_RX_LOOP_BUF_CNT; i++)\r\ndma_free_coherent(port->dev, SIRFSOC_RX_DMA_BUF_SIZE,\r\nsirfport->rx_dma_items[i].xmit.buf,\r\nsirfport->rx_dma_items[i].dma_addr);\r\n}\r\nif (sirfport->tx_dma_chan) {\r\ndmaengine_terminate_all(sirfport->tx_dma_chan);\r\ndma_release_channel(sirfport->tx_dma_chan);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsirfsoc_uart_suspend(struct device *pdev)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = dev_get_drvdata(pdev);\r\nstruct uart_port *port = &sirfport->port;\r\nuart_suspend_port(&sirfsoc_uart_drv, port);\r\nreturn 0;\r\n}\r\nstatic int sirfsoc_uart_resume(struct device *pdev)\r\n{\r\nstruct sirfsoc_uart_port *sirfport = dev_get_drvdata(pdev);\r\nstruct uart_port *port = &sirfport->port;\r\nuart_resume_port(&sirfsoc_uart_drv, port);\r\nreturn 0;\r\n}\r\nstatic int __init sirfsoc_uart_init(void)\r\n{\r\nint ret = 0;\r\nret = uart_register_driver(&sirfsoc_uart_drv);\r\nif (ret)\r\ngoto out;\r\nret = platform_driver_register(&sirfsoc_uart_driver);\r\nif (ret)\r\nuart_unregister_driver(&sirfsoc_uart_drv);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit sirfsoc_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&sirfsoc_uart_driver);\r\nuart_unregister_driver(&sirfsoc_uart_drv);\r\n}
