static int check_mutually_exclusive(struct extcon_dev *edev, u32 new_state)\r\n{\r\nint i = 0;\r\nif (!edev->mutually_exclusive)\r\nreturn 0;\r\nfor (i = 0; edev->mutually_exclusive[i]; i++) {\r\nint weight;\r\nu32 correspondants = new_state & edev->mutually_exclusive[i];\r\nweight = hweight32(correspondants);\r\nif (weight > 1)\r\nreturn i + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint i, count = 0;\r\nstruct extcon_dev *edev = dev_get_drvdata(dev);\r\nif (edev->print_state) {\r\nint ret = edev->print_state(edev, buf);\r\nif (ret >= 0)\r\nreturn ret;\r\n}\r\nif (edev->max_supported == 0)\r\nreturn sprintf(buf, "%u\n", edev->state);\r\nfor (i = 0; i < SUPPORTED_CABLE_MAX; i++) {\r\nif (!edev->supported_cable[i])\r\nbreak;\r\ncount += sprintf(buf + count, "%s=%d\n",\r\nedev->supported_cable[i],\r\n!!(edev->state & (1 << i)));\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t state_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu32 state;\r\nssize_t ret = 0;\r\nstruct extcon_dev *edev = dev_get_drvdata(dev);\r\nret = sscanf(buf, "0x%x", &state);\r\nif (ret == 0)\r\nret = -EINVAL;\r\nelse\r\nret = extcon_set_state(edev, state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct extcon_dev *edev = dev_get_drvdata(dev);\r\nif (edev->print_name) {\r\nint ret = edev->print_name(edev, buf);\r\nif (ret >= 0)\r\nreturn ret;\r\n}\r\nreturn sprintf(buf, "%s\n", dev_name(&edev->dev));\r\n}\r\nstatic ssize_t cable_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct extcon_cable *cable = container_of(attr, struct extcon_cable,\r\nattr_name);\r\nreturn sprintf(buf, "%s\n",\r\ncable->edev->supported_cable[cable->cable_index]);\r\n}\r\nstatic ssize_t cable_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct extcon_cable *cable = container_of(attr, struct extcon_cable,\r\nattr_state);\r\nreturn sprintf(buf, "%d\n",\r\nextcon_get_cable_state_(cable->edev,\r\ncable->cable_index));\r\n}\r\nint extcon_update_state(struct extcon_dev *edev, u32 mask, u32 state)\r\n{\r\nchar name_buf[120];\r\nchar state_buf[120];\r\nchar *prop_buf;\r\nchar *envp[3];\r\nint env_offset = 0;\r\nint length;\r\nunsigned long flags;\r\nspin_lock_irqsave(&edev->lock, flags);\r\nif (edev->state != ((edev->state & ~mask) | (state & mask))) {\r\nu32 old_state = edev->state;\r\nif (check_mutually_exclusive(edev, (edev->state & ~mask) |\r\n(state & mask))) {\r\nspin_unlock_irqrestore(&edev->lock, flags);\r\nreturn -EPERM;\r\n}\r\nedev->state &= ~mask;\r\nedev->state |= state & mask;\r\nraw_notifier_call_chain(&edev->nh, old_state, edev);\r\nprop_buf = (char *)get_zeroed_page(GFP_ATOMIC);\r\nif (prop_buf) {\r\nlength = name_show(&edev->dev, NULL, prop_buf);\r\nif (length > 0) {\r\nif (prop_buf[length - 1] == '\n')\r\nprop_buf[length - 1] = 0;\r\nsnprintf(name_buf, sizeof(name_buf),\r\n"NAME=%s", prop_buf);\r\nenvp[env_offset++] = name_buf;\r\n}\r\nlength = state_show(&edev->dev, NULL, prop_buf);\r\nif (length > 0) {\r\nif (prop_buf[length - 1] == '\n')\r\nprop_buf[length - 1] = 0;\r\nsnprintf(state_buf, sizeof(state_buf),\r\n"STATE=%s", prop_buf);\r\nenvp[env_offset++] = state_buf;\r\n}\r\nenvp[env_offset] = NULL;\r\nspin_unlock_irqrestore(&edev->lock, flags);\r\nkobject_uevent_env(&edev->dev.kobj, KOBJ_CHANGE, envp);\r\nfree_page((unsigned long)prop_buf);\r\n} else {\r\nspin_unlock_irqrestore(&edev->lock, flags);\r\ndev_err(&edev->dev, "out of memory in extcon_set_state\n");\r\nkobject_uevent(&edev->dev.kobj, KOBJ_CHANGE);\r\n}\r\n} else {\r\nspin_unlock_irqrestore(&edev->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nint extcon_set_state(struct extcon_dev *edev, u32 state)\r\n{\r\nreturn extcon_update_state(edev, 0xffffffff, state);\r\n}\r\nint extcon_find_cable_index(struct extcon_dev *edev, const char *cable_name)\r\n{\r\nint i;\r\nif (edev->supported_cable) {\r\nfor (i = 0; edev->supported_cable[i]; i++) {\r\nif (!strncmp(edev->supported_cable[i],\r\ncable_name, CABLE_NAME_MAX))\r\nreturn i;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint extcon_get_cable_state_(struct extcon_dev *edev, int index)\r\n{\r\nif (index < 0 || (edev->max_supported && edev->max_supported <= index))\r\nreturn -EINVAL;\r\nreturn !!(edev->state & (1 << index));\r\n}\r\nint extcon_get_cable_state(struct extcon_dev *edev, const char *cable_name)\r\n{\r\nreturn extcon_get_cable_state_(edev, extcon_find_cable_index\r\n(edev, cable_name));\r\n}\r\nint extcon_set_cable_state_(struct extcon_dev *edev,\r\nint index, bool cable_state)\r\n{\r\nu32 state;\r\nif (index < 0 || (edev->max_supported && edev->max_supported <= index))\r\nreturn -EINVAL;\r\nstate = cable_state ? (1 << index) : 0;\r\nreturn extcon_update_state(edev, 1 << index, state);\r\n}\r\nint extcon_set_cable_state(struct extcon_dev *edev,\r\nconst char *cable_name, bool cable_state)\r\n{\r\nreturn extcon_set_cable_state_(edev, extcon_find_cable_index\r\n(edev, cable_name), cable_state);\r\n}\r\nstruct extcon_dev *extcon_get_extcon_dev(const char *extcon_name)\r\n{\r\nstruct extcon_dev *sd;\r\nmutex_lock(&extcon_dev_list_lock);\r\nlist_for_each_entry(sd, &extcon_dev_list, entry) {\r\nif (!strcmp(sd->name, extcon_name))\r\ngoto out;\r\n}\r\nsd = NULL;\r\nout:\r\nmutex_unlock(&extcon_dev_list_lock);\r\nreturn sd;\r\n}\r\nstatic int _call_per_cable(struct notifier_block *nb, unsigned long val,\r\nvoid *ptr)\r\n{\r\nstruct extcon_specific_cable_nb *obj = container_of(nb,\r\nstruct extcon_specific_cable_nb, internal_nb);\r\nstruct extcon_dev *edev = ptr;\r\nif ((val & (1 << obj->cable_index)) !=\r\n(edev->state & (1 << obj->cable_index))) {\r\nbool cable_state = true;\r\nobj->previous_value = val;\r\nif (val & (1 << obj->cable_index))\r\ncable_state = false;\r\nreturn obj->user_nb->notifier_call(obj->user_nb,\r\ncable_state, ptr);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nint extcon_register_interest(struct extcon_specific_cable_nb *obj,\r\nconst char *extcon_name, const char *cable_name,\r\nstruct notifier_block *nb)\r\n{\r\nif (!obj || !cable_name || !nb)\r\nreturn -EINVAL;\r\nif (extcon_name) {\r\nobj->edev = extcon_get_extcon_dev(extcon_name);\r\nif (!obj->edev)\r\nreturn -ENODEV;\r\nobj->cable_index = extcon_find_cable_index(obj->edev,\r\ncable_name);\r\nif (obj->cable_index < 0)\r\nreturn obj->cable_index;\r\nobj->user_nb = nb;\r\nobj->internal_nb.notifier_call = _call_per_cable;\r\nreturn raw_notifier_chain_register(&obj->edev->nh,\r\n&obj->internal_nb);\r\n} else {\r\nstruct class_dev_iter iter;\r\nstruct extcon_dev *extd;\r\nstruct device *dev;\r\nif (!extcon_class)\r\nreturn -ENODEV;\r\nclass_dev_iter_init(&iter, extcon_class, NULL, NULL);\r\nwhile ((dev = class_dev_iter_next(&iter))) {\r\nextd = dev_get_drvdata(dev);\r\nif (extcon_find_cable_index(extd, cable_name) < 0)\r\ncontinue;\r\nclass_dev_iter_exit(&iter);\r\nreturn extcon_register_interest(obj, extd->name,\r\ncable_name, nb);\r\n}\r\nreturn -ENODEV;\r\n}\r\n}\r\nint extcon_unregister_interest(struct extcon_specific_cable_nb *obj)\r\n{\r\nif (!obj)\r\nreturn -EINVAL;\r\nreturn raw_notifier_chain_unregister(&obj->edev->nh, &obj->internal_nb);\r\n}\r\nint extcon_register_notifier(struct extcon_dev *edev,\r\nstruct notifier_block *nb)\r\n{\r\nreturn raw_notifier_chain_register(&edev->nh, nb);\r\n}\r\nint extcon_unregister_notifier(struct extcon_dev *edev,\r\nstruct notifier_block *nb)\r\n{\r\nreturn raw_notifier_chain_unregister(&edev->nh, nb);\r\n}\r\nstatic int create_extcon_class(void)\r\n{\r\nif (!extcon_class) {\r\nextcon_class = class_create(THIS_MODULE, "extcon");\r\nif (IS_ERR(extcon_class))\r\nreturn PTR_ERR(extcon_class);\r\nextcon_class->dev_groups = extcon_groups;\r\n#if defined(CONFIG_ANDROID)\r\nswitch_class = class_compat_register("switch");\r\nif (WARN(!switch_class, "cannot allocate"))\r\nreturn -ENOMEM;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic void extcon_dev_release(struct device *dev)\r\n{\r\n}\r\nstatic void dummy_sysfs_dev_release(struct device *dev)\r\n{\r\n}\r\nstruct extcon_dev *extcon_dev_allocate(const char **supported_cable)\r\n{\r\nstruct extcon_dev *edev;\r\nedev = kzalloc(sizeof(*edev), GFP_KERNEL);\r\nif (!edev)\r\nreturn ERR_PTR(-ENOMEM);\r\nedev->max_supported = 0;\r\nedev->supported_cable = supported_cable;\r\nreturn edev;\r\n}\r\nvoid extcon_dev_free(struct extcon_dev *edev)\r\n{\r\nkfree(edev);\r\n}\r\nstatic int devm_extcon_dev_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct extcon_dev **r = res;\r\nif (WARN_ON(!r || !*r))\r\nreturn 0;\r\nreturn *r == data;\r\n}\r\nstatic void devm_extcon_dev_release(struct device *dev, void *res)\r\n{\r\nextcon_dev_free(*(struct extcon_dev **)res);\r\n}\r\nstruct extcon_dev *devm_extcon_dev_allocate(struct device *dev,\r\nconst char **supported_cable)\r\n{\r\nstruct extcon_dev **ptr, *edev;\r\nptr = devres_alloc(devm_extcon_dev_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\nedev = extcon_dev_allocate(supported_cable);\r\nif (IS_ERR(edev)) {\r\ndevres_free(ptr);\r\nreturn edev;\r\n}\r\nedev->dev.parent = dev;\r\n*ptr = edev;\r\ndevres_add(dev, ptr);\r\nreturn edev;\r\n}\r\nvoid devm_extcon_dev_free(struct device *dev, struct extcon_dev *edev)\r\n{\r\nWARN_ON(devres_release(dev, devm_extcon_dev_release,\r\ndevm_extcon_dev_match, edev));\r\n}\r\nint extcon_dev_register(struct extcon_dev *edev)\r\n{\r\nint ret, index = 0;\r\nif (!extcon_class) {\r\nret = create_extcon_class();\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (edev->supported_cable) {\r\nfor (index = 0; edev->supported_cable[index]; index++)\r\n;\r\nedev->max_supported = index;\r\n} else {\r\nedev->max_supported = 0;\r\n}\r\nif (index > SUPPORTED_CABLE_MAX) {\r\ndev_err(&edev->dev, "extcon: maximum number of supported cables exceeded.\n");\r\nreturn -EINVAL;\r\n}\r\nedev->dev.class = extcon_class;\r\nedev->dev.release = extcon_dev_release;\r\nedev->name = edev->name ? edev->name : dev_name(edev->dev.parent);\r\nif (IS_ERR_OR_NULL(edev->name)) {\r\ndev_err(&edev->dev,\r\n"extcon device name is null\n");\r\nreturn -EINVAL;\r\n}\r\ndev_set_name(&edev->dev, "%s", edev->name);\r\nif (edev->max_supported) {\r\nchar buf[10];\r\nchar *str;\r\nstruct extcon_cable *cable;\r\nedev->cables = kzalloc(sizeof(struct extcon_cable) *\r\nedev->max_supported, GFP_KERNEL);\r\nif (!edev->cables) {\r\nret = -ENOMEM;\r\ngoto err_sysfs_alloc;\r\n}\r\nfor (index = 0; index < edev->max_supported; index++) {\r\ncable = &edev->cables[index];\r\nsnprintf(buf, 10, "cable.%d", index);\r\nstr = kzalloc(sizeof(char) * (strlen(buf) + 1),\r\nGFP_KERNEL);\r\nif (!str) {\r\nfor (index--; index >= 0; index--) {\r\ncable = &edev->cables[index];\r\nkfree(cable->attr_g.name);\r\n}\r\nret = -ENOMEM;\r\ngoto err_alloc_cables;\r\n}\r\nstrcpy(str, buf);\r\ncable->edev = edev;\r\ncable->cable_index = index;\r\ncable->attrs[0] = &cable->attr_name.attr;\r\ncable->attrs[1] = &cable->attr_state.attr;\r\ncable->attrs[2] = NULL;\r\ncable->attr_g.name = str;\r\ncable->attr_g.attrs = cable->attrs;\r\nsysfs_attr_init(&cable->attr_name.attr);\r\ncable->attr_name.attr.name = "name";\r\ncable->attr_name.attr.mode = 0444;\r\ncable->attr_name.show = cable_name_show;\r\nsysfs_attr_init(&cable->attr_state.attr);\r\ncable->attr_state.attr.name = "state";\r\ncable->attr_state.attr.mode = 0444;\r\ncable->attr_state.show = cable_state_show;\r\n}\r\n}\r\nif (edev->max_supported && edev->mutually_exclusive) {\r\nchar buf[80];\r\nchar *name;\r\nfor (index = 0; edev->mutually_exclusive[index]; index++)\r\n;\r\nedev->attrs_muex = kzalloc(sizeof(struct attribute *) *\r\n(index + 1), GFP_KERNEL);\r\nif (!edev->attrs_muex) {\r\nret = -ENOMEM;\r\ngoto err_muex;\r\n}\r\nedev->d_attrs_muex = kzalloc(sizeof(struct device_attribute) *\r\nindex, GFP_KERNEL);\r\nif (!edev->d_attrs_muex) {\r\nret = -ENOMEM;\r\nkfree(edev->attrs_muex);\r\ngoto err_muex;\r\n}\r\nfor (index = 0; edev->mutually_exclusive[index]; index++) {\r\nsprintf(buf, "0x%x", edev->mutually_exclusive[index]);\r\nname = kzalloc(sizeof(char) * (strlen(buf) + 1),\r\nGFP_KERNEL);\r\nif (!name) {\r\nfor (index--; index >= 0; index--) {\r\nkfree(edev->d_attrs_muex[index].attr.\r\nname);\r\n}\r\nkfree(edev->d_attrs_muex);\r\nkfree(edev->attrs_muex);\r\nret = -ENOMEM;\r\ngoto err_muex;\r\n}\r\nstrcpy(name, buf);\r\nsysfs_attr_init(&edev->d_attrs_muex[index].attr);\r\nedev->d_attrs_muex[index].attr.name = name;\r\nedev->d_attrs_muex[index].attr.mode = 0000;\r\nedev->attrs_muex[index] = &edev->d_attrs_muex[index]\r\n.attr;\r\n}\r\nedev->attr_g_muex.name = muex_name;\r\nedev->attr_g_muex.attrs = edev->attrs_muex;\r\n}\r\nif (edev->max_supported) {\r\nedev->extcon_dev_type.groups =\r\nkzalloc(sizeof(struct attribute_group *) *\r\n(edev->max_supported + 2), GFP_KERNEL);\r\nif (!edev->extcon_dev_type.groups) {\r\nret = -ENOMEM;\r\ngoto err_alloc_groups;\r\n}\r\nedev->extcon_dev_type.name = dev_name(&edev->dev);\r\nedev->extcon_dev_type.release = dummy_sysfs_dev_release;\r\nfor (index = 0; index < edev->max_supported; index++)\r\nedev->extcon_dev_type.groups[index] =\r\n&edev->cables[index].attr_g;\r\nif (edev->mutually_exclusive)\r\nedev->extcon_dev_type.groups[index] =\r\n&edev->attr_g_muex;\r\nedev->dev.type = &edev->extcon_dev_type;\r\n}\r\nret = device_register(&edev->dev);\r\nif (ret) {\r\nput_device(&edev->dev);\r\ngoto err_dev;\r\n}\r\n#if defined(CONFIG_ANDROID)\r\nif (switch_class)\r\nret = class_compat_create_link(switch_class, &edev->dev, NULL);\r\n#endif\r\nspin_lock_init(&edev->lock);\r\nRAW_INIT_NOTIFIER_HEAD(&edev->nh);\r\ndev_set_drvdata(&edev->dev, edev);\r\nedev->state = 0;\r\nmutex_lock(&extcon_dev_list_lock);\r\nlist_add(&edev->entry, &extcon_dev_list);\r\nmutex_unlock(&extcon_dev_list_lock);\r\nreturn 0;\r\nerr_dev:\r\nif (edev->max_supported)\r\nkfree(edev->extcon_dev_type.groups);\r\nerr_alloc_groups:\r\nif (edev->max_supported && edev->mutually_exclusive) {\r\nfor (index = 0; edev->mutually_exclusive[index]; index++)\r\nkfree(edev->d_attrs_muex[index].attr.name);\r\nkfree(edev->d_attrs_muex);\r\nkfree(edev->attrs_muex);\r\n}\r\nerr_muex:\r\nfor (index = 0; index < edev->max_supported; index++)\r\nkfree(edev->cables[index].attr_g.name);\r\nerr_alloc_cables:\r\nif (edev->max_supported)\r\nkfree(edev->cables);\r\nerr_sysfs_alloc:\r\nreturn ret;\r\n}\r\nvoid extcon_dev_unregister(struct extcon_dev *edev)\r\n{\r\nint index;\r\nmutex_lock(&extcon_dev_list_lock);\r\nlist_del(&edev->entry);\r\nmutex_unlock(&extcon_dev_list_lock);\r\nif (IS_ERR_OR_NULL(get_device(&edev->dev))) {\r\ndev_err(&edev->dev, "Failed to unregister extcon_dev (%s)\n",\r\ndev_name(&edev->dev));\r\nreturn;\r\n}\r\ndevice_unregister(&edev->dev);\r\nif (edev->mutually_exclusive && edev->max_supported) {\r\nfor (index = 0; edev->mutually_exclusive[index];\r\nindex++)\r\nkfree(edev->d_attrs_muex[index].attr.name);\r\nkfree(edev->d_attrs_muex);\r\nkfree(edev->attrs_muex);\r\n}\r\nfor (index = 0; index < edev->max_supported; index++)\r\nkfree(edev->cables[index].attr_g.name);\r\nif (edev->max_supported) {\r\nkfree(edev->extcon_dev_type.groups);\r\nkfree(edev->cables);\r\n}\r\n#if defined(CONFIG_ANDROID)\r\nif (switch_class)\r\nclass_compat_remove_link(switch_class, &edev->dev, NULL);\r\n#endif\r\nput_device(&edev->dev);\r\n}\r\nstatic void devm_extcon_dev_unreg(struct device *dev, void *res)\r\n{\r\nextcon_dev_unregister(*(struct extcon_dev **)res);\r\n}\r\nint devm_extcon_dev_register(struct device *dev, struct extcon_dev *edev)\r\n{\r\nstruct extcon_dev **ptr;\r\nint ret;\r\nptr = devres_alloc(devm_extcon_dev_unreg, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn -ENOMEM;\r\nret = extcon_dev_register(edev);\r\nif (ret) {\r\ndevres_free(ptr);\r\nreturn ret;\r\n}\r\n*ptr = edev;\r\ndevres_add(dev, ptr);\r\nreturn 0;\r\n}\r\nvoid devm_extcon_dev_unregister(struct device *dev, struct extcon_dev *edev)\r\n{\r\nWARN_ON(devres_release(dev, devm_extcon_dev_unreg,\r\ndevm_extcon_dev_match, edev));\r\n}\r\nstruct extcon_dev *extcon_get_edev_by_phandle(struct device *dev, int index)\r\n{\r\nstruct device_node *node;\r\nstruct extcon_dev *edev;\r\nif (!dev->of_node) {\r\ndev_err(dev, "device does not have a device node entry\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nnode = of_parse_phandle(dev->of_node, "extcon", index);\r\nif (!node) {\r\ndev_err(dev, "failed to get phandle in %s node\n",\r\ndev->of_node->full_name);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nedev = extcon_get_extcon_dev(node->name);\r\nif (!edev) {\r\ndev_err(dev, "unable to get extcon device : %s\n", node->name);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nreturn edev;\r\n}\r\nstruct extcon_dev *extcon_get_edev_by_phandle(struct device *dev, int index)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic int __init extcon_class_init(void)\r\n{\r\nreturn create_extcon_class();\r\n}\r\nstatic void __exit extcon_class_exit(void)\r\n{\r\n#if defined(CONFIG_ANDROID)\r\nclass_compat_unregister(switch_class);\r\n#endif\r\nclass_destroy(extcon_class);\r\n}
