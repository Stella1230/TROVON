static int\r\nsnd_wavefront_pnp (int dev, snd_wavefront_card_t *acard, struct pnp_card_link *card,\r\nconst struct pnp_card_device_id *id)\r\n{\r\nstruct pnp_dev *pdev;\r\nint err;\r\nacard->wss = pnp_request_card_device(card, id->devs[0].id, NULL);\r\nif (acard->wss == NULL)\r\nreturn -EBUSY;\r\nif (use_cs4232_midi[dev]) {\r\nacard->mpu = pnp_request_card_device(card, id->devs[2].id, NULL);\r\nif (acard->mpu == NULL)\r\nreturn -EBUSY;\r\n}\r\nacard->synth = pnp_request_card_device(card, id->devs[3].id, NULL);\r\nif (acard->synth == NULL)\r\nreturn -EBUSY;\r\npdev = acard->wss;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "PnP WSS pnp configure failure\n");\r\nreturn err;\r\n}\r\ncs4232_pcm_port[dev] = pnp_port_start(pdev, 0);\r\nfm_port[dev] = pnp_port_start(pdev, 1);\r\ndma1[dev] = pnp_dma(pdev, 0);\r\ndma2[dev] = pnp_dma(pdev, 1);\r\ncs4232_pcm_irq[dev] = pnp_irq(pdev, 0);\r\npdev = acard->synth;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "PnP ICS2115 pnp configure failure\n");\r\nreturn err;\r\n}\r\nics2115_port[dev] = pnp_port_start(pdev, 0);\r\nics2115_irq[dev] = pnp_irq(pdev, 0);\r\nif (use_cs4232_midi[dev]) {\r\npdev = acard->mpu;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "PnP MPU401 pnp configure failure\n");\r\ncs4232_mpu_port[dev] = SNDRV_AUTO_PORT;\r\n} else {\r\ncs4232_mpu_port[dev] = pnp_port_start(pdev, 0);\r\ncs4232_mpu_irq[dev] = pnp_irq(pdev, 0);\r\n}\r\nsnd_printk (KERN_INFO "CS4232 MPU: port=0x%lx, irq=%i\n",\r\ncs4232_mpu_port[dev],\r\ncs4232_mpu_irq[dev]);\r\n}\r\nsnd_printdd ("CS4232: pcm port=0x%lx, fm port=0x%lx, dma1=%i, dma2=%i, irq=%i\nICS2115: port=0x%lx, irq=%i\n",\r\ncs4232_pcm_port[dev],\r\nfm_port[dev],\r\ndma1[dev],\r\ndma2[dev],\r\ncs4232_pcm_irq[dev],\r\nics2115_port[dev],\r\nics2115_irq[dev]);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_wavefront_ics2115_interrupt(int irq, void *dev_id)\r\n{\r\nsnd_wavefront_card_t *acard;\r\nacard = (snd_wavefront_card_t *) dev_id;\r\nif (acard == NULL)\r\nreturn IRQ_NONE;\r\nif (acard->wavefront.interrupts_are_midi) {\r\nsnd_wavefront_midi_interrupt (acard);\r\n} else {\r\nsnd_wavefront_internal_interrupt (acard);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct snd_hwdep *snd_wavefront_new_synth(struct snd_card *card,\r\nint hw_dev,\r\nsnd_wavefront_card_t *acard)\r\n{\r\nstruct snd_hwdep *wavefront_synth;\r\nif (snd_wavefront_detect (acard) < 0) {\r\nreturn NULL;\r\n}\r\nif (snd_wavefront_start (&acard->wavefront) < 0) {\r\nreturn NULL;\r\n}\r\nif (snd_hwdep_new(card, "WaveFront", hw_dev, &wavefront_synth) < 0)\r\nreturn NULL;\r\nstrcpy (wavefront_synth->name,\r\n"WaveFront (ICS2115) wavetable synthesizer");\r\nwavefront_synth->ops.open = snd_wavefront_synth_open;\r\nwavefront_synth->ops.release = snd_wavefront_synth_release;\r\nwavefront_synth->ops.ioctl = snd_wavefront_synth_ioctl;\r\nreturn wavefront_synth;\r\n}\r\nstatic struct snd_hwdep *snd_wavefront_new_fx(struct snd_card *card,\r\nint hw_dev,\r\nsnd_wavefront_card_t *acard,\r\nunsigned long port)\r\n{\r\nstruct snd_hwdep *fx_processor;\r\nif (snd_wavefront_fx_start (&acard->wavefront)) {\r\nsnd_printk (KERN_ERR "cannot initialize YSS225 FX processor");\r\nreturn NULL;\r\n}\r\nif (snd_hwdep_new (card, "YSS225", hw_dev, &fx_processor) < 0)\r\nreturn NULL;\r\nsprintf (fx_processor->name, "YSS225 FX Processor at 0x%lx", port);\r\nfx_processor->ops.open = snd_wavefront_fx_open;\r\nfx_processor->ops.release = snd_wavefront_fx_release;\r\nfx_processor->ops.ioctl = snd_wavefront_fx_ioctl;\r\nreturn fx_processor;\r\n}\r\nstatic struct snd_rawmidi *snd_wavefront_new_midi(struct snd_card *card,\r\nint midi_dev,\r\nsnd_wavefront_card_t *acard,\r\nunsigned long port,\r\nsnd_wavefront_mpu_id mpu)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nstatic int first = 1;\r\nif (first) {\r\nfirst = 0;\r\nacard->wavefront.midi.base = port;\r\nif (snd_wavefront_midi_start (acard)) {\r\nsnd_printk (KERN_ERR "cannot initialize MIDI interface\n");\r\nreturn NULL;\r\n}\r\n}\r\nif (snd_rawmidi_new (card, "WaveFront MIDI", midi_dev, 1, 1, &rmidi) < 0)\r\nreturn NULL;\r\nif (mpu == internal_mpu) {\r\nstrcpy(rmidi->name, "WaveFront MIDI (Internal)");\r\nrmidi->private_data = &internal_id;\r\n} else {\r\nstrcpy(rmidi->name, "WaveFront MIDI (External)");\r\nrmidi->private_data = &external_id;\r\n}\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_wavefront_midi_output);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_wavefront_midi_input);\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nreturn rmidi;\r\n}\r\nstatic void\r\nsnd_wavefront_free(struct snd_card *card)\r\n{\r\nsnd_wavefront_card_t *acard = (snd_wavefront_card_t *)card->private_data;\r\nif (acard) {\r\nrelease_and_free_resource(acard->wavefront.res_base);\r\nif (acard->wavefront.irq > 0)\r\nfree_irq(acard->wavefront.irq, (void *)acard);\r\n}\r\n}\r\nstatic int snd_wavefront_card_new(struct device *pdev, int dev,\r\nstruct snd_card **cardp)\r\n{\r\nstruct snd_card *card;\r\nsnd_wavefront_card_t *acard;\r\nint err;\r\nerr = snd_card_new(pdev, index[dev], id[dev], THIS_MODULE,\r\nsizeof(snd_wavefront_card_t), &card);\r\nif (err < 0)\r\nreturn err;\r\nacard = card->private_data;\r\nacard->wavefront.irq = -1;\r\nspin_lock_init(&acard->wavefront.irq_lock);\r\ninit_waitqueue_head(&acard->wavefront.interrupt_sleeper);\r\nspin_lock_init(&acard->wavefront.midi.open);\r\nspin_lock_init(&acard->wavefront.midi.virtual);\r\nacard->wavefront.card = card;\r\ncard->private_free = snd_wavefront_free;\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_wavefront_probe (struct snd_card *card, int dev)\r\n{\r\nsnd_wavefront_card_t *acard = card->private_data;\r\nstruct snd_wss *chip;\r\nstruct snd_hwdep *wavefront_synth;\r\nstruct snd_rawmidi *ics2115_internal_rmidi = NULL;\r\nstruct snd_rawmidi *ics2115_external_rmidi = NULL;\r\nstruct snd_hwdep *fx_processor;\r\nint hw_dev = 0, midi_dev = 0, err;\r\nerr = snd_wss_create(card, cs4232_pcm_port[dev], -1,\r\ncs4232_pcm_irq[dev], dma1[dev], dma2[dev],\r\nWSS_HW_DETECT, 0, &chip);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "can't allocate WSS device\n");\r\nreturn err;\r\n}\r\nerr = snd_wss_pcm(chip, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_wss_timer(chip, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (fm_port[dev] > 0 && fm_port[dev] != SNDRV_AUTO_PORT) {\r\nstruct snd_opl3 *opl3;\r\nerr = snd_opl3_create(card, fm_port[dev], fm_port[dev] + 2,\r\nOPL3_HW_OPL3_CS, 0, &opl3);\r\nif (err < 0) {\r\nsnd_printk (KERN_ERR "can't allocate or detect OPL3 synth\n");\r\nreturn err;\r\n}\r\nerr = snd_opl3_hwdep_new(opl3, hw_dev, 1, NULL);\r\nif (err < 0)\r\nreturn err;\r\nhw_dev++;\r\n}\r\nacard->wavefront.res_base = request_region(ics2115_port[dev], 16,\r\n"ICS2115");\r\nif (acard->wavefront.res_base == NULL) {\r\nsnd_printk(KERN_ERR "unable to grab ICS2115 i/o region 0x%lx-0x%lx\n",\r\nics2115_port[dev], ics2115_port[dev] + 16 - 1);\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(ics2115_irq[dev], snd_wavefront_ics2115_interrupt,\r\n0, "ICS2115", acard)) {\r\nsnd_printk(KERN_ERR "unable to use ICS2115 IRQ %d\n", ics2115_irq[dev]);\r\nreturn -EBUSY;\r\n}\r\nacard->wavefront.irq = ics2115_irq[dev];\r\nacard->wavefront.base = ics2115_port[dev];\r\nwavefront_synth = snd_wavefront_new_synth(card, hw_dev, acard);\r\nif (wavefront_synth == NULL) {\r\nsnd_printk (KERN_ERR "can't create WaveFront synth device\n");\r\nreturn -ENOMEM;\r\n}\r\nstrcpy (wavefront_synth->name, "ICS2115 Wavetable MIDI Synthesizer");\r\nwavefront_synth->iface = SNDRV_HWDEP_IFACE_ICS2115;\r\nhw_dev++;\r\nerr = snd_wss_mixer(chip);\r\nif (err < 0) {\r\nsnd_printk (KERN_ERR "can't allocate mixer device\n");\r\nreturn err;\r\n}\r\nif (cs4232_mpu_port[dev] > 0 && cs4232_mpu_port[dev] != SNDRV_AUTO_PORT) {\r\nerr = snd_mpu401_uart_new(card, midi_dev, MPU401_HW_CS4232,\r\ncs4232_mpu_port[dev], 0,\r\ncs4232_mpu_irq[dev], NULL);\r\nif (err < 0) {\r\nsnd_printk (KERN_ERR "can't allocate CS4232 MPU-401 device\n");\r\nreturn err;\r\n}\r\nmidi_dev++;\r\n}\r\nif (ics2115_port[dev] > 0 && ics2115_port[dev] != SNDRV_AUTO_PORT) {\r\nics2115_internal_rmidi =\r\nsnd_wavefront_new_midi (card,\r\nmidi_dev,\r\nacard,\r\nics2115_port[dev],\r\ninternal_mpu);\r\nif (ics2115_internal_rmidi == NULL) {\r\nsnd_printk (KERN_ERR "can't setup ICS2115 internal MIDI device\n");\r\nreturn -ENOMEM;\r\n}\r\nmidi_dev++;\r\n}\r\nif (ics2115_port[dev] > 0 && ics2115_port[dev] != SNDRV_AUTO_PORT) {\r\nics2115_external_rmidi =\r\nsnd_wavefront_new_midi (card,\r\nmidi_dev,\r\nacard,\r\nics2115_port[dev],\r\nexternal_mpu);\r\nif (ics2115_external_rmidi == NULL) {\r\nsnd_printk (KERN_ERR "can't setup ICS2115 external MIDI device\n");\r\nreturn -ENOMEM;\r\n}\r\nmidi_dev++;\r\n}\r\nif (acard->wavefront.has_fx) {\r\nfx_processor = snd_wavefront_new_fx (card,\r\nhw_dev,\r\nacard,\r\nics2115_port[dev]);\r\nif (fx_processor == NULL) {\r\nsnd_printk (KERN_ERR "can't setup FX device\n");\r\nreturn -ENOMEM;\r\n}\r\nhw_dev++;\r\nstrcpy(card->driver, "Tropez+");\r\nstrcpy(card->shortname, "Turtle Beach Tropez+");\r\n} else {\r\nstrcpy(card->driver, "WaveFront");\r\nstrcpy(card->shortname, "Turtle Beach WaveFront");\r\n}\r\nsprintf(card->longname, "%s PCM 0x%lx irq %d dma %d",\r\ncard->driver,\r\nchip->port,\r\ncs4232_pcm_irq[dev],\r\ndma1[dev]);\r\nif (dma2[dev] >= 0 && dma2[dev] < 8)\r\nsprintf(card->longname + strlen(card->longname), "&%d", dma2[dev]);\r\nif (cs4232_mpu_port[dev] > 0 && cs4232_mpu_port[dev] != SNDRV_AUTO_PORT) {\r\nsprintf (card->longname + strlen (card->longname),\r\n" MPU-401 0x%lx irq %d",\r\ncs4232_mpu_port[dev],\r\ncs4232_mpu_irq[dev]);\r\n}\r\nsprintf (card->longname + strlen (card->longname),\r\n" SYNTH 0x%lx irq %d",\r\nics2115_port[dev],\r\nics2115_irq[dev]);\r\nreturn snd_card_register(card);\r\n}\r\nstatic int snd_wavefront_isa_match(struct device *pdev,\r\nunsigned int dev)\r\n{\r\nif (!enable[dev])\r\nreturn 0;\r\n#ifdef CONFIG_PNP\r\nif (isapnp[dev])\r\nreturn 0;\r\n#endif\r\nif (cs4232_pcm_port[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR "specify CS4232 port\n");\r\nreturn 0;\r\n}\r\nif (ics2115_port[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR "specify ICS2115 port\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_wavefront_isa_probe(struct device *pdev,\r\nunsigned int dev)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_wavefront_card_new(pdev, dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_wavefront_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ndev_set_drvdata(pdev, card);\r\nreturn 0;\r\n}\r\nstatic int snd_wavefront_isa_remove(struct device *devptr,\r\nunsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\nreturn 0;\r\n}\r\nstatic int snd_wavefront_pnp_detect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nint res;\r\nfor ( ; dev < SNDRV_CARDS; dev++) {\r\nif (enable[dev] && isapnp[dev])\r\nbreak;\r\n}\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nres = snd_wavefront_card_new(&pcard->card->dev, dev, &card);\r\nif (res < 0)\r\nreturn res;\r\nif (snd_wavefront_pnp (dev, card->private_data, pcard, pid) < 0) {\r\nif (cs4232_pcm_port[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk (KERN_ERR "isapnp detection failed\n");\r\nsnd_card_free (card);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ((res = snd_wavefront_probe(card, dev)) < 0)\r\nreturn res;\r\npnp_set_card_drvdata(pcard, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_wavefront_pnp_remove(struct pnp_card_link *pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int __init alsa_card_wavefront_init(void)\r\n{\r\nint err;\r\nerr = isa_register_driver(&snd_wavefront_driver, SNDRV_CARDS);\r\n#ifdef CONFIG_PNP\r\nif (!err)\r\nisa_registered = 1;\r\nerr = pnp_register_card_driver(&wavefront_pnpc_driver);\r\nif (!err)\r\npnp_registered = 1;\r\nif (isa_registered)\r\nerr = 0;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit alsa_card_wavefront_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\npnp_unregister_card_driver(&wavefront_pnpc_driver);\r\nif (isa_registered)\r\n#endif\r\nisa_unregister_driver(&snd_wavefront_driver);\r\n}
