void\r\nahd_print_path(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nprintk("(scsi%d:%c:%d:%d): ",\r\nahd->platform_data->host->host_no,\r\nscb != NULL ? SCB_GET_CHANNEL(ahd, scb) : 'X',\r\nscb != NULL ? SCB_GET_TARGET(ahd, scb) : -1,\r\nscb != NULL ? SCB_GET_LUN(scb) : -1);\r\n}\r\nvoid\r\nahd_delay(long usec)\r\n{\r\nwhile (usec > 0) {\r\nudelay(usec % 1024);\r\nusec -= 1024;\r\n}\r\n}\r\nuint8_t\r\nahd_inb(struct ahd_softc * ahd, long port)\r\n{\r\nuint8_t x;\r\nif (ahd->tags[0] == BUS_SPACE_MEMIO) {\r\nx = readb(ahd->bshs[0].maddr + port);\r\n} else {\r\nx = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));\r\n}\r\nmb();\r\nreturn (x);\r\n}\r\nvoid\r\nahd_outb(struct ahd_softc * ahd, long port, uint8_t val)\r\n{\r\nif (ahd->tags[0] == BUS_SPACE_MEMIO) {\r\nwriteb(val, ahd->bshs[0].maddr + port);\r\n} else {\r\noutb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));\r\n}\r\nmb();\r\n}\r\nvoid\r\nahd_outw_atomic(struct ahd_softc * ahd, long port, uint16_t val)\r\n{\r\nif (ahd->tags[0] == BUS_SPACE_MEMIO) {\r\nwritew(val, ahd->bshs[0].maddr + port);\r\n} else {\r\noutw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));\r\n}\r\nmb();\r\n}\r\nvoid\r\nahd_outsb(struct ahd_softc * ahd, long port, uint8_t *array, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nahd_outb(ahd, port, *array++);\r\n}\r\nvoid\r\nahd_insb(struct ahd_softc * ahd, long port, uint8_t *array, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\n*array++ = ahd_inb(ahd, port);\r\n}\r\nuint32_t\r\nahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)\r\n{\r\nswitch (width) {\r\ncase 1:\r\n{\r\nuint8_t retval;\r\npci_read_config_byte(pci, reg, &retval);\r\nreturn (retval);\r\n}\r\ncase 2:\r\n{\r\nuint16_t retval;\r\npci_read_config_word(pci, reg, &retval);\r\nreturn (retval);\r\n}\r\ncase 4:\r\n{\r\nuint32_t retval;\r\npci_read_config_dword(pci, reg, &retval);\r\nreturn (retval);\r\n}\r\ndefault:\r\npanic("ahd_pci_read_config: Read size too big");\r\nreturn (0);\r\n}\r\n}\r\nvoid\r\nahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)\r\n{\r\nswitch (width) {\r\ncase 1:\r\npci_write_config_byte(pci, reg, value);\r\nbreak;\r\ncase 2:\r\npci_write_config_word(pci, reg, value);\r\nbreak;\r\ncase 4:\r\npci_write_config_dword(pci, reg, value);\r\nbreak;\r\ndefault:\r\npanic("ahd_pci_write_config: Write size too big");\r\n}\r\n}\r\nstatic void\r\nahd_linux_unmap_scb(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nstruct scsi_cmnd *cmd;\r\ncmd = scb->io_ctx;\r\nahd_sync_sglist(ahd, scb, BUS_DMASYNC_POSTWRITE);\r\nscsi_dma_unmap(cmd);\r\n}\r\nstatic const char *\r\nahd_linux_info(struct Scsi_Host *host)\r\n{\r\nstatic char buffer[512];\r\nchar ahd_info[256];\r\nchar *bp;\r\nstruct ahd_softc *ahd;\r\nbp = &buffer[0];\r\nahd = *(struct ahd_softc **)host->hostdata;\r\nmemset(bp, 0, sizeof(buffer));\r\nstrcpy(bp, "Adaptec AIC79XX PCI-X SCSI HBA DRIVER, Rev " AIC79XX_DRIVER_VERSION "\n"\r\n" <");\r\nstrcat(bp, ahd->description);\r\nstrcat(bp, ">\n"\r\n" ");\r\nahd_controller_info(ahd, ahd_info);\r\nstrcat(bp, ahd_info);\r\nreturn (bp);\r\n}\r\nstatic int\r\nahd_linux_queue_lck(struct scsi_cmnd * cmd, void (*scsi_done) (struct scsi_cmnd *))\r\n{\r\nstruct ahd_softc *ahd;\r\nstruct ahd_linux_device *dev = scsi_transport_device_data(cmd->device);\r\nint rtn = SCSI_MLQUEUE_HOST_BUSY;\r\nahd = *(struct ahd_softc **)cmd->device->host->hostdata;\r\ncmd->scsi_done = scsi_done;\r\ncmd->result = CAM_REQ_INPROG << 16;\r\nrtn = ahd_linux_run_command(ahd, dev, cmd);\r\nreturn rtn;\r\n}\r\nint\r\nahd_linux_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct ahd_softc *ahd =\r\n*((struct ahd_softc **)dev_to_shost(&starget->dev)->hostdata);\r\nstruct seeprom_config *sc = ahd->seep_config;\r\nunsigned long flags;\r\nstruct scsi_target **ahd_targp = ahd_linux_target_in_softc(starget);\r\nstruct ahd_devinfo devinfo;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nchar channel = starget->channel + 'A';\r\nahd_lock(ahd, &flags);\r\nBUG_ON(*ahd_targp != NULL);\r\n*ahd_targp = starget;\r\nif (sc) {\r\nint flags = sc->device_flags[starget->id];\r\ntinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\r\nstarget->id, &tstate);\r\nif ((flags & CFPACKETIZED) == 0) {\r\nspi_max_iu(starget) = 0;\r\n} else {\r\nif ((ahd->features & AHD_RTI) == 0)\r\nspi_rti(starget) = 0;\r\n}\r\nif ((flags & CFQAS) == 0)\r\nspi_max_qas(starget) = 0;\r\nspi_max_width(starget) = (flags & CFWIDEB) ? 1 : 0;\r\nspi_min_period(starget) = tinfo->user.period;\r\nspi_max_offset(starget) = tinfo->user.offset;\r\n}\r\ntinfo = ahd_fetch_transinfo(ahd, channel, ahd->our_id,\r\nstarget->id, &tstate);\r\nahd_compile_devinfo(&devinfo, ahd->our_id, starget->id,\r\nCAM_LUN_WILDCARD, channel,\r\nROLE_INITIATOR);\r\nahd_set_syncrate(ahd, &devinfo, 0, 0, 0,\r\nAHD_TRANS_GOAL, FALSE);\r\nahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,\r\nAHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nahd_linux_target_destroy(struct scsi_target *starget)\r\n{\r\nstruct scsi_target **ahd_targp = ahd_linux_target_in_softc(starget);\r\n*ahd_targp = NULL;\r\n}\r\nstatic int\r\nahd_linux_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct ahd_softc *ahd =\r\n*((struct ahd_softc **)sdev->host->hostdata);\r\nstruct ahd_linux_device *dev;\r\nif (bootverbose)\r\nprintk("%s: Slave Alloc %d\n", ahd_name(ahd), sdev->id);\r\ndev = scsi_transport_device_data(sdev);\r\nmemset(dev, 0, sizeof(*dev));\r\ndev->openings = 1;\r\ndev->maxtags = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nahd_linux_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct ahd_softc *ahd;\r\nahd = *((struct ahd_softc **)sdev->host->hostdata);\r\nif (bootverbose)\r\nsdev_printk(KERN_INFO, sdev, "Slave Configure\n");\r\nahd_linux_device_queue_depth(sdev);\r\nif (!spi_initial_dv(sdev->sdev_target))\r\nspi_dv_device(sdev);\r\nreturn 0;\r\n}\r\nstatic int\r\nahd_linux_biosparam(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nuint8_t *bh;\r\nint heads;\r\nint sectors;\r\nint cylinders;\r\nint ret;\r\nint extended;\r\nstruct ahd_softc *ahd;\r\nahd = *((struct ahd_softc **)sdev->host->hostdata);\r\nbh = scsi_bios_ptable(bdev);\r\nif (bh) {\r\nret = scsi_partsize(bh, capacity,\r\n&geom[2], &geom[0], &geom[1]);\r\nkfree(bh);\r\nif (ret != -1)\r\nreturn (ret);\r\n}\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = aic_sector_div(capacity, heads, sectors);\r\nif (aic79xx_extended != 0)\r\nextended = 1;\r\nelse\r\nextended = (ahd->flags & AHD_EXTENDED_TRANS_A) != 0;\r\nif (extended && cylinders >= 1024) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = aic_sector_div(capacity, heads, sectors);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn (0);\r\n}\r\nstatic int\r\nahd_linux_abort(struct scsi_cmnd *cmd)\r\n{\r\nint error;\r\nerror = ahd_linux_queue_abort_cmd(cmd);\r\nreturn error;\r\n}\r\nstatic int\r\nahd_linux_dev_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct ahd_softc *ahd;\r\nstruct ahd_linux_device *dev;\r\nstruct scb *reset_scb;\r\nu_int cdb_byte;\r\nint retval = SUCCESS;\r\nint paused;\r\nint wait;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nunsigned long flags;\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nreset_scb = NULL;\r\npaused = FALSE;\r\nwait = FALSE;\r\nahd = *(struct ahd_softc **)cmd->device->host->hostdata;\r\nscmd_printk(KERN_INFO, cmd,\r\n"Attempting to queue a TARGET RESET message:");\r\nprintk("CDB:");\r\nfor (cdb_byte = 0; cdb_byte < cmd->cmd_len; cdb_byte++)\r\nprintk(" 0x%x", cmd->cmnd[cdb_byte]);\r\nprintk("\n");\r\ndev = scsi_transport_device_data(cmd->device);\r\nif (dev == NULL) {\r\nscmd_printk(KERN_INFO, cmd, "Is not an active device\n");\r\nreturn SUCCESS;\r\n}\r\nreset_scb = ahd_get_scb(ahd, AHD_NEVER_COL_IDX);\r\nif (!reset_scb) {\r\nscmd_printk(KERN_INFO, cmd, "No SCB available\n");\r\nreturn FAILED;\r\n}\r\ntinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\r\ncmd->device->id, &tstate);\r\nreset_scb->io_ctx = cmd;\r\nreset_scb->platform_data->dev = dev;\r\nreset_scb->sg_count = 0;\r\nahd_set_residual(reset_scb, 0);\r\nahd_set_sense_residual(reset_scb, 0);\r\nreset_scb->platform_data->xfer_len = 0;\r\nreset_scb->hscb->control = 0;\r\nreset_scb->hscb->scsiid = BUILD_SCSIID(ahd,cmd);\r\nreset_scb->hscb->lun = cmd->device->lun;\r\nreset_scb->hscb->cdb_len = 0;\r\nreset_scb->hscb->task_management = SIU_TASKMGMT_LUN_RESET;\r\nreset_scb->flags |= SCB_DEVICE_RESET|SCB_RECOVERY_SCB|SCB_ACTIVE;\r\nif ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {\r\nreset_scb->flags |= SCB_PACKETIZED;\r\n} else {\r\nreset_scb->hscb->control |= MK_MESSAGE;\r\n}\r\ndev->openings--;\r\ndev->active++;\r\ndev->commands_issued++;\r\nahd_lock(ahd, &flags);\r\nLIST_INSERT_HEAD(&ahd->pending_scbs, reset_scb, pending_links);\r\nahd_queue_scb(ahd, reset_scb);\r\nahd->platform_data->eh_done = &done;\r\nahd_unlock(ahd, &flags);\r\nprintk("%s: Device reset code sleeping\n", ahd_name(ahd));\r\nif (!wait_for_completion_timeout(&done, 5 * HZ)) {\r\nahd_lock(ahd, &flags);\r\nahd->platform_data->eh_done = NULL;\r\nahd_unlock(ahd, &flags);\r\nprintk("%s: Device reset timer expired (active %d)\n",\r\nahd_name(ahd), dev->active);\r\nretval = FAILED;\r\n}\r\nprintk("%s: Device reset returning 0x%x\n", ahd_name(ahd), retval);\r\nreturn (retval);\r\n}\r\nstatic int\r\nahd_linux_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct ahd_softc *ahd;\r\nint found;\r\nunsigned long flags;\r\nahd = *(struct ahd_softc **)cmd->device->host->hostdata;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_RECOVERY) != 0)\r\nprintk("%s: Bus reset called for cmd %p\n",\r\nahd_name(ahd), cmd);\r\n#endif\r\nahd_lock(ahd, &flags);\r\nfound = ahd_reset_channel(ahd, scmd_channel(cmd) + 'A',\r\nTRUE);\r\nahd_unlock(ahd, &flags);\r\nif (bootverbose)\r\nprintk("%s: SCSI bus reset delivered. "\r\n"%d SCBs aborted.\n", ahd_name(ahd), found);\r\nreturn (SUCCESS);\r\n}\r\nint\r\nahd_dma_tag_create(struct ahd_softc *ahd, bus_dma_tag_t parent,\r\nbus_size_t alignment, bus_size_t boundary,\r\ndma_addr_t lowaddr, dma_addr_t highaddr,\r\nbus_dma_filter_t *filter, void *filterarg,\r\nbus_size_t maxsize, int nsegments,\r\nbus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)\r\n{\r\nbus_dma_tag_t dmat;\r\ndmat = kmalloc(sizeof(*dmat), GFP_ATOMIC);\r\nif (dmat == NULL)\r\nreturn (ENOMEM);\r\ndmat->alignment = alignment;\r\ndmat->boundary = boundary;\r\ndmat->maxsize = maxsize;\r\n*ret_tag = dmat;\r\nreturn (0);\r\n}\r\nvoid\r\nahd_dma_tag_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat)\r\n{\r\nkfree(dmat);\r\n}\r\nint\r\nahd_dmamem_alloc(struct ahd_softc *ahd, bus_dma_tag_t dmat, void** vaddr,\r\nint flags, bus_dmamap_t *mapp)\r\n{\r\n*vaddr = pci_alloc_consistent(ahd->dev_softc,\r\ndmat->maxsize, mapp);\r\nif (*vaddr == NULL)\r\nreturn (ENOMEM);\r\nreturn(0);\r\n}\r\nvoid\r\nahd_dmamem_free(struct ahd_softc *ahd, bus_dma_tag_t dmat,\r\nvoid* vaddr, bus_dmamap_t map)\r\n{\r\npci_free_consistent(ahd->dev_softc, dmat->maxsize,\r\nvaddr, map);\r\n}\r\nint\r\nahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map,\r\nvoid *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,\r\nvoid *cb_arg, int flags)\r\n{\r\nbus_dma_segment_t stack_sg;\r\nstack_sg.ds_addr = map;\r\nstack_sg.ds_len = dmat->maxsize;\r\ncb(cb_arg, &stack_sg, 1, 0);\r\nreturn (0);\r\n}\r\nvoid\r\nahd_dmamap_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)\r\n{\r\n}\r\nint\r\nahd_dmamap_unload(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)\r\n{\r\nreturn (0);\r\n}\r\nstatic void\r\nahd_linux_setup_iocell_info(u_long index, int instance, int targ, int32_t value)\r\n{\r\nif ((instance >= 0)\r\n&& (instance < ARRAY_SIZE(aic79xx_iocell_info))) {\r\nuint8_t *iocell_info;\r\niocell_info = (uint8_t*)&aic79xx_iocell_info[instance];\r\niocell_info[index] = value & 0xFFFF;\r\nif (bootverbose)\r\nprintk("iocell[%d:%ld] = %d\n", instance, index, value);\r\n}\r\n}\r\nstatic void\r\nahd_linux_setup_tag_info_global(char *p)\r\n{\r\nint tags, i, j;\r\ntags = simple_strtoul(p + 1, NULL, 0) & 0xff;\r\nprintk("Setting Global Tags= %d\n", tags);\r\nfor (i = 0; i < ARRAY_SIZE(aic79xx_tag_info); i++) {\r\nfor (j = 0; j < AHD_NUM_TARGETS; j++) {\r\naic79xx_tag_info[i].tag_commands[j] = tags;\r\n}\r\n}\r\n}\r\nstatic void\r\nahd_linux_setup_tag_info(u_long arg, int instance, int targ, int32_t value)\r\n{\r\nif ((instance >= 0) && (targ >= 0)\r\n&& (instance < ARRAY_SIZE(aic79xx_tag_info))\r\n&& (targ < AHD_NUM_TARGETS)) {\r\naic79xx_tag_info[instance].tag_commands[targ] = value & 0x1FF;\r\nif (bootverbose)\r\nprintk("tag_info[%d:%d] = %d\n", instance, targ, value);\r\n}\r\n}\r\nstatic char *\r\nahd_parse_brace_option(char *opt_name, char *opt_arg, char *end, int depth,\r\nvoid (*callback)(u_long, int, int, int32_t),\r\nu_long callback_arg)\r\n{\r\nchar *tok_end;\r\nchar *tok_end2;\r\nint i;\r\nint instance;\r\nint targ;\r\nint done;\r\nchar tok_list[] = {'.', ',', '{', '}', '\0'};\r\nif (*opt_arg != ':')\r\nreturn (opt_arg);\r\nopt_arg++;\r\ninstance = -1;\r\ntarg = -1;\r\ndone = FALSE;\r\ntok_end = strchr(opt_arg, '\0');\r\nif (tok_end < end)\r\n*tok_end = ',';\r\nwhile (!done) {\r\nswitch (*opt_arg) {\r\ncase '{':\r\nif (instance == -1) {\r\ninstance = 0;\r\n} else {\r\nif (depth > 1) {\r\nif (targ == -1)\r\ntarg = 0;\r\n} else {\r\nprintk("Malformed Option %s\n",\r\nopt_name);\r\ndone = TRUE;\r\n}\r\n}\r\nopt_arg++;\r\nbreak;\r\ncase '}':\r\nif (targ != -1)\r\ntarg = -1;\r\nelse if (instance != -1)\r\ninstance = -1;\r\nopt_arg++;\r\nbreak;\r\ncase ',':\r\ncase '.':\r\nif (instance == -1)\r\ndone = TRUE;\r\nelse if (targ >= 0)\r\ntarg++;\r\nelse if (instance >= 0)\r\ninstance++;\r\nopt_arg++;\r\nbreak;\r\ncase '\0':\r\ndone = TRUE;\r\nbreak;\r\ndefault:\r\ntok_end = end;\r\nfor (i = 0; tok_list[i]; i++) {\r\ntok_end2 = strchr(opt_arg, tok_list[i]);\r\nif ((tok_end2) && (tok_end2 < tok_end))\r\ntok_end = tok_end2;\r\n}\r\ncallback(callback_arg, instance, targ,\r\nsimple_strtol(opt_arg, NULL, 0));\r\nopt_arg = tok_end;\r\nbreak;\r\n}\r\n}\r\nreturn (opt_arg);\r\n}\r\nstatic int\r\naic79xx_setup(char *s)\r\n{\r\nint i, n;\r\nchar *p;\r\nchar *end;\r\nstatic const struct {\r\nconst char *name;\r\nuint32_t *flag;\r\n} options[] = {\r\n{ "extended", &aic79xx_extended },\r\n{ "no_reset", &aic79xx_no_reset },\r\n{ "verbose", &aic79xx_verbose },\r\n{ "allow_memio", &aic79xx_allow_memio},\r\n#ifdef AHD_DEBUG\r\n{ "debug", &ahd_debug },\r\n#endif\r\n{ "periodic_otag", &aic79xx_periodic_otag },\r\n{ "pci_parity", &aic79xx_pci_parity },\r\n{ "seltime", &aic79xx_seltime },\r\n{ "tag_info", NULL },\r\n{ "global_tag_depth", NULL},\r\n{ "slewrate", NULL },\r\n{ "precomp", NULL },\r\n{ "amplitude", NULL },\r\n{ "slowcrc", &aic79xx_slowcrc },\r\n};\r\nend = strchr(s, '\0');\r\nn = 0;\r\nwhile ((p = strsep(&s, ",.")) != NULL) {\r\nif (*p == '\0')\r\ncontinue;\r\nfor (i = 0; i < ARRAY_SIZE(options); i++) {\r\nn = strlen(options[i].name);\r\nif (strncmp(options[i].name, p, n) == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(options))\r\ncontinue;\r\nif (strncmp(p, "global_tag_depth", n) == 0) {\r\nahd_linux_setup_tag_info_global(p + n);\r\n} else if (strncmp(p, "tag_info", n) == 0) {\r\ns = ahd_parse_brace_option("tag_info", p + n, end,\r\n2, ahd_linux_setup_tag_info, 0);\r\n} else if (strncmp(p, "slewrate", n) == 0) {\r\ns = ahd_parse_brace_option("slewrate",\r\np + n, end, 1, ahd_linux_setup_iocell_info,\r\nAIC79XX_SLEWRATE_INDEX);\r\n} else if (strncmp(p, "precomp", n) == 0) {\r\ns = ahd_parse_brace_option("precomp",\r\np + n, end, 1, ahd_linux_setup_iocell_info,\r\nAIC79XX_PRECOMP_INDEX);\r\n} else if (strncmp(p, "amplitude", n) == 0) {\r\ns = ahd_parse_brace_option("amplitude",\r\np + n, end, 1, ahd_linux_setup_iocell_info,\r\nAIC79XX_AMPLITUDE_INDEX);\r\n} else if (p[n] == ':') {\r\n*(options[i].flag) = simple_strtoul(p + n + 1, NULL, 0);\r\n} else if (!strncmp(p, "verbose", n)) {\r\n*(options[i].flag) = 1;\r\n} else {\r\n*(options[i].flag) ^= 0xFFFFFFFF;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint\r\nahd_linux_register_host(struct ahd_softc *ahd, struct scsi_host_template *template)\r\n{\r\nchar buf[80];\r\nstruct Scsi_Host *host;\r\nchar *new_name;\r\nu_long s;\r\nint retval;\r\ntemplate->name = ahd->description;\r\nhost = scsi_host_alloc(template, sizeof(struct ahd_softc *));\r\nif (host == NULL)\r\nreturn (ENOMEM);\r\n*((struct ahd_softc **)host->hostdata) = ahd;\r\nahd->platform_data->host = host;\r\nhost->can_queue = AHD_MAX_QUEUE;\r\nhost->cmd_per_lun = 2;\r\nhost->sg_tablesize = AHD_NSEG;\r\nhost->this_id = ahd->our_id;\r\nhost->irq = ahd->platform_data->irq;\r\nhost->max_id = (ahd->features & AHD_WIDE) ? 16 : 8;\r\nhost->max_lun = AHD_NUM_LUNS;\r\nhost->max_channel = 0;\r\nhost->sg_tablesize = AHD_NSEG;\r\nahd_lock(ahd, &s);\r\nahd_set_unit(ahd, ahd_linux_unit++);\r\nahd_unlock(ahd, &s);\r\nsprintf(buf, "scsi%d", host->host_no);\r\nnew_name = kmalloc(strlen(buf) + 1, GFP_ATOMIC);\r\nif (new_name != NULL) {\r\nstrcpy(new_name, buf);\r\nahd_set_name(ahd, new_name);\r\n}\r\nhost->unique_id = ahd->unit;\r\nahd_linux_initialize_scsi_bus(ahd);\r\nahd_intr_enable(ahd, TRUE);\r\nhost->transportt = ahd_linux_transport_template;\r\nretval = scsi_add_host(host, &ahd->dev_softc->dev);\r\nif (retval) {\r\nprintk(KERN_WARNING "aic79xx: scsi_add_host failed\n");\r\nscsi_host_put(host);\r\nreturn retval;\r\n}\r\nscsi_scan_host(host);\r\nreturn 0;\r\n}\r\nstatic void\r\nahd_linux_initialize_scsi_bus(struct ahd_softc *ahd)\r\n{\r\nu_int target_id;\r\nu_int numtarg;\r\nunsigned long s;\r\ntarget_id = 0;\r\nnumtarg = 0;\r\nif (aic79xx_no_reset != 0)\r\nahd->flags &= ~AHD_RESET_BUS_A;\r\nif ((ahd->flags & AHD_RESET_BUS_A) != 0)\r\nahd_reset_channel(ahd, 'A', TRUE);\r\nelse\r\nnumtarg = (ahd->features & AHD_WIDE) ? 16 : 8;\r\nahd_lock(ahd, &s);\r\nfor (; target_id < numtarg; target_id++) {\r\nstruct ahd_devinfo devinfo;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\ntinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\r\ntarget_id, &tstate);\r\nahd_compile_devinfo(&devinfo, ahd->our_id, target_id,\r\nCAM_LUN_WILDCARD, 'A', ROLE_INITIATOR);\r\nahd_update_neg_request(ahd, &devinfo, tstate,\r\ntinfo, AHD_NEG_ALWAYS);\r\n}\r\nahd_unlock(ahd, &s);\r\nif ((ahd->flags & AHD_RESET_BUS_A) != 0) {\r\nahd_freeze_simq(ahd);\r\nmsleep(AIC79XX_RESET_DELAY);\r\nahd_release_simq(ahd);\r\n}\r\n}\r\nint\r\nahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg)\r\n{\r\nahd->platform_data =\r\nkmalloc(sizeof(struct ahd_platform_data), GFP_ATOMIC);\r\nif (ahd->platform_data == NULL)\r\nreturn (ENOMEM);\r\nmemset(ahd->platform_data, 0, sizeof(struct ahd_platform_data));\r\nahd->platform_data->irq = AHD_LINUX_NOIRQ;\r\nahd_lockinit(ahd);\r\nahd->seltime = (aic79xx_seltime & 0x3) << 4;\r\nreturn (0);\r\n}\r\nvoid\r\nahd_platform_free(struct ahd_softc *ahd)\r\n{\r\nstruct scsi_target *starget;\r\nint i;\r\nif (ahd->platform_data != NULL) {\r\nfor (i = 0; i < AHD_NUM_TARGETS; i++) {\r\nstarget = ahd->platform_data->starget[i];\r\nif (starget != NULL) {\r\nahd->platform_data->starget[i] = NULL;\r\n}\r\n}\r\nif (ahd->platform_data->irq != AHD_LINUX_NOIRQ)\r\nfree_irq(ahd->platform_data->irq, ahd);\r\nif (ahd->tags[0] == BUS_SPACE_PIO\r\n&& ahd->bshs[0].ioport != 0)\r\nrelease_region(ahd->bshs[0].ioport, 256);\r\nif (ahd->tags[1] == BUS_SPACE_PIO\r\n&& ahd->bshs[1].ioport != 0)\r\nrelease_region(ahd->bshs[1].ioport, 256);\r\nif (ahd->tags[0] == BUS_SPACE_MEMIO\r\n&& ahd->bshs[0].maddr != NULL) {\r\niounmap(ahd->bshs[0].maddr);\r\nrelease_mem_region(ahd->platform_data->mem_busaddr,\r\n0x1000);\r\n}\r\nif (ahd->platform_data->host)\r\nscsi_host_put(ahd->platform_data->host);\r\nkfree(ahd->platform_data);\r\n}\r\n}\r\nvoid\r\nahd_platform_init(struct ahd_softc *ahd)\r\n{\r\nif (ahd->unit < ARRAY_SIZE(aic79xx_iocell_info)) {\r\nconst struct ahd_linux_iocell_opts *iocell_opts;\r\niocell_opts = &aic79xx_iocell_info[ahd->unit];\r\nif (iocell_opts->precomp != AIC79XX_DEFAULT_PRECOMP)\r\nAHD_SET_PRECOMP(ahd, iocell_opts->precomp);\r\nif (iocell_opts->slewrate != AIC79XX_DEFAULT_SLEWRATE)\r\nAHD_SET_SLEWRATE(ahd, iocell_opts->slewrate);\r\nif (iocell_opts->amplitude != AIC79XX_DEFAULT_AMPLITUDE)\r\nAHD_SET_AMPLITUDE(ahd, iocell_opts->amplitude);\r\n}\r\n}\r\nvoid\r\nahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nahd_platform_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),\r\nSCB_GET_CHANNEL(ahd, scb),\r\nSCB_GET_LUN(scb), SCB_LIST_NULL,\r\nROLE_UNKNOWN, CAM_REQUEUE_REQ);\r\n}\r\nvoid\r\nahd_platform_set_tags(struct ahd_softc *ahd, struct scsi_device *sdev,\r\nstruct ahd_devinfo *devinfo, ahd_queue_alg alg)\r\n{\r\nstruct ahd_linux_device *dev;\r\nint was_queuing;\r\nint now_queuing;\r\nif (sdev == NULL)\r\nreturn;\r\ndev = scsi_transport_device_data(sdev);\r\nif (dev == NULL)\r\nreturn;\r\nwas_queuing = dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED);\r\nswitch (alg) {\r\ndefault:\r\ncase AHD_QUEUE_NONE:\r\nnow_queuing = 0;\r\nbreak;\r\ncase AHD_QUEUE_BASIC:\r\nnow_queuing = AHD_DEV_Q_BASIC;\r\nbreak;\r\ncase AHD_QUEUE_TAGGED:\r\nnow_queuing = AHD_DEV_Q_TAGGED;\r\nbreak;\r\n}\r\nif ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) == 0\r\n&& (was_queuing != now_queuing)\r\n&& (dev->active != 0)) {\r\ndev->flags |= AHD_DEV_FREEZE_TIL_EMPTY;\r\ndev->qfrozen++;\r\n}\r\ndev->flags &= ~(AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED|AHD_DEV_PERIODIC_OTAG);\r\nif (now_queuing) {\r\nu_int usertags;\r\nusertags = ahd_linux_user_tagdepth(ahd, devinfo);\r\nif (!was_queuing) {\r\ndev->maxtags = usertags;\r\ndev->openings = dev->maxtags - dev->active;\r\n}\r\nif (dev->maxtags == 0) {\r\ndev->openings = 1;\r\n} else if (alg == AHD_QUEUE_TAGGED) {\r\ndev->flags |= AHD_DEV_Q_TAGGED;\r\nif (aic79xx_periodic_otag != 0)\r\ndev->flags |= AHD_DEV_PERIODIC_OTAG;\r\n} else\r\ndev->flags |= AHD_DEV_Q_BASIC;\r\n} else {\r\ndev->maxtags = 0;\r\ndev->openings = 1 - dev->active;\r\n}\r\nswitch ((dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED))) {\r\ncase AHD_DEV_Q_BASIC:\r\nscsi_set_tag_type(sdev, MSG_SIMPLE_TASK);\r\nscsi_activate_tcq(sdev, dev->openings + dev->active);\r\nbreak;\r\ncase AHD_DEV_Q_TAGGED:\r\nscsi_set_tag_type(sdev, MSG_ORDERED_TASK);\r\nscsi_activate_tcq(sdev, dev->openings + dev->active);\r\nbreak;\r\ndefault:\r\nscsi_deactivate_tcq(sdev, 1);\r\nbreak;\r\n}\r\n}\r\nint\r\nahd_platform_abort_scbs(struct ahd_softc *ahd, int target, char channel,\r\nint lun, u_int tag, role_t role, uint32_t status)\r\n{\r\nreturn 0;\r\n}\r\nstatic u_int\r\nahd_linux_user_tagdepth(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)\r\n{\r\nstatic int warned_user;\r\nu_int tags;\r\ntags = 0;\r\nif ((ahd->user_discenable & devinfo->target_mask) != 0) {\r\nif (ahd->unit >= ARRAY_SIZE(aic79xx_tag_info)) {\r\nif (warned_user == 0) {\r\nprintk(KERN_WARNING\r\n"aic79xx: WARNING: Insufficient tag_info instances\n"\r\n"aic79xx: for installed controllers. Using defaults\n"\r\n"aic79xx: Please update the aic79xx_tag_info array in\n"\r\n"aic79xx: the aic79xx_osm.c source file.\n");\r\nwarned_user++;\r\n}\r\ntags = AHD_MAX_QUEUE;\r\n} else {\r\nadapter_tag_info_t *tag_info;\r\ntag_info = &aic79xx_tag_info[ahd->unit];\r\ntags = tag_info->tag_commands[devinfo->target_offset];\r\nif (tags > AHD_MAX_QUEUE)\r\ntags = AHD_MAX_QUEUE;\r\n}\r\n}\r\nreturn (tags);\r\n}\r\nstatic void\r\nahd_linux_device_queue_depth(struct scsi_device *sdev)\r\n{\r\nstruct ahd_devinfo devinfo;\r\nu_int tags;\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)sdev->host->hostdata);\r\nahd_compile_devinfo(&devinfo,\r\nahd->our_id,\r\nsdev->sdev_target->id, sdev->lun,\r\nsdev->sdev_target->channel == 0 ? 'A' : 'B',\r\nROLE_INITIATOR);\r\ntags = ahd_linux_user_tagdepth(ahd, &devinfo);\r\nif (tags != 0 && sdev->tagged_supported != 0) {\r\nahd_platform_set_tags(ahd, sdev, &devinfo, AHD_QUEUE_TAGGED);\r\nahd_send_async(ahd, devinfo.channel, devinfo.target,\r\ndevinfo.lun, AC_TRANSFER_NEG);\r\nahd_print_devinfo(ahd, &devinfo);\r\nprintk("Tagged Queuing enabled. Depth %d\n", tags);\r\n} else {\r\nahd_platform_set_tags(ahd, sdev, &devinfo, AHD_QUEUE_NONE);\r\nahd_send_async(ahd, devinfo.channel, devinfo.target,\r\ndevinfo.lun, AC_TRANSFER_NEG);\r\n}\r\n}\r\nstatic int\r\nahd_linux_run_command(struct ahd_softc *ahd, struct ahd_linux_device *dev,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct scb *scb;\r\nstruct hardware_scb *hscb;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nu_int col_idx;\r\nuint16_t mask;\r\nunsigned long flags;\r\nint nseg;\r\nnseg = scsi_dma_map(cmd);\r\nif (nseg < 0)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nahd_lock(ahd, &flags);\r\ntinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,\r\ncmd->device->id, &tstate);\r\nif ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) == 0\r\n|| (tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {\r\ncol_idx = AHD_NEVER_COL_IDX;\r\n} else {\r\ncol_idx = AHD_BUILD_COL_IDX(cmd->device->id,\r\ncmd->device->lun);\r\n}\r\nif ((scb = ahd_get_scb(ahd, col_idx)) == NULL) {\r\nahd->flags |= AHD_RESOURCE_SHORTAGE;\r\nahd_unlock(ahd, &flags);\r\nscsi_dma_unmap(cmd);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nscb->io_ctx = cmd;\r\nscb->platform_data->dev = dev;\r\nhscb = scb->hscb;\r\ncmd->host_scribble = (char *)scb;\r\nhscb->control = 0;\r\nhscb->scsiid = BUILD_SCSIID(ahd, cmd);\r\nhscb->lun = cmd->device->lun;\r\nscb->hscb->task_management = 0;\r\nmask = SCB_GET_TARGET_MASK(ahd, scb);\r\nif ((ahd->user_discenable & mask) != 0)\r\nhscb->control |= DISCENB;\r\nif ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0)\r\nscb->flags |= SCB_PACKETIZED;\r\nif ((tstate->auto_negotiate & mask) != 0) {\r\nscb->flags |= SCB_AUTO_NEGOTIATE;\r\nscb->hscb->control |= MK_MESSAGE;\r\n}\r\nif ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) != 0) {\r\nint msg_bytes;\r\nuint8_t tag_msgs[2];\r\nmsg_bytes = scsi_populate_tag_msg(cmd, tag_msgs);\r\nif (msg_bytes && tag_msgs[0] != MSG_SIMPLE_TASK) {\r\nhscb->control |= tag_msgs[0];\r\nif (tag_msgs[0] == MSG_ORDERED_TASK)\r\ndev->commands_since_idle_or_otag = 0;\r\n} else\r\nif (dev->commands_since_idle_or_otag == AHD_OTAG_THRESH\r\n&& (dev->flags & AHD_DEV_Q_TAGGED) != 0) {\r\nhscb->control |= MSG_ORDERED_TASK;\r\ndev->commands_since_idle_or_otag = 0;\r\n} else {\r\nhscb->control |= MSG_SIMPLE_TASK;\r\n}\r\n}\r\nhscb->cdb_len = cmd->cmd_len;\r\nmemcpy(hscb->shared_data.idata.cdb, cmd->cmnd, hscb->cdb_len);\r\nscb->platform_data->xfer_len = 0;\r\nahd_set_residual(scb, 0);\r\nahd_set_sense_residual(scb, 0);\r\nscb->sg_count = 0;\r\nif (nseg > 0) {\r\nvoid *sg = scb->sg_list;\r\nstruct scatterlist *cur_seg;\r\nint i;\r\nscb->platform_data->xfer_len = 0;\r\nscsi_for_each_sg(cmd, cur_seg, nseg, i) {\r\ndma_addr_t addr;\r\nbus_size_t len;\r\naddr = sg_dma_address(cur_seg);\r\nlen = sg_dma_len(cur_seg);\r\nscb->platform_data->xfer_len += len;\r\nsg = ahd_sg_setup(ahd, scb, sg, addr, len,\r\ni == (nseg - 1));\r\n}\r\n}\r\nLIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);\r\ndev->openings--;\r\ndev->active++;\r\ndev->commands_issued++;\r\nif ((dev->flags & AHD_DEV_PERIODIC_OTAG) != 0)\r\ndev->commands_since_idle_or_otag++;\r\nscb->flags |= SCB_ACTIVE;\r\nahd_queue_scb(ahd, scb);\r\nahd_unlock(ahd, &flags);\r\nreturn 0;\r\n}\r\nirqreturn_t\r\nahd_linux_isr(int irq, void *dev_id)\r\n{\r\nstruct ahd_softc *ahd;\r\nu_long flags;\r\nint ours;\r\nahd = (struct ahd_softc *) dev_id;\r\nahd_lock(ahd, &flags);\r\nours = ahd_intr(ahd);\r\nahd_unlock(ahd, &flags);\r\nreturn IRQ_RETVAL(ours);\r\n}\r\nvoid\r\nahd_send_async(struct ahd_softc *ahd, char channel,\r\nu_int target, u_int lun, ac_code code)\r\n{\r\nswitch (code) {\r\ncase AC_TRANSFER_NEG:\r\n{\r\nstruct scsi_target *starget;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nunsigned int target_ppr_options;\r\nBUG_ON(target == CAM_TARGET_WILDCARD);\r\ntinfo = ahd_fetch_transinfo(ahd, channel, ahd->our_id,\r\ntarget, &tstate);\r\nif (tinfo->curr.period != tinfo->goal.period\r\n|| tinfo->curr.width != tinfo->goal.width\r\n|| tinfo->curr.offset != tinfo->goal.offset\r\n|| tinfo->curr.ppr_options != tinfo->goal.ppr_options)\r\nif (bootverbose == 0)\r\nbreak;\r\nstarget = ahd->platform_data->starget[target];\r\nif (starget == NULL)\r\nbreak;\r\ntarget_ppr_options =\r\n(spi_dt(starget) ? MSG_EXT_PPR_DT_REQ : 0)\r\n+ (spi_qas(starget) ? MSG_EXT_PPR_QAS_REQ : 0)\r\n+ (spi_iu(starget) ? MSG_EXT_PPR_IU_REQ : 0)\r\n+ (spi_rd_strm(starget) ? MSG_EXT_PPR_RD_STRM : 0)\r\n+ (spi_pcomp_en(starget) ? MSG_EXT_PPR_PCOMP_EN : 0)\r\n+ (spi_rti(starget) ? MSG_EXT_PPR_RTI : 0)\r\n+ (spi_wr_flow(starget) ? MSG_EXT_PPR_WR_FLOW : 0)\r\n+ (spi_hold_mcs(starget) ? MSG_EXT_PPR_HOLD_MCS : 0);\r\nif (tinfo->curr.period == spi_period(starget)\r\n&& tinfo->curr.width == spi_width(starget)\r\n&& tinfo->curr.offset == spi_offset(starget)\r\n&& tinfo->curr.ppr_options == target_ppr_options)\r\nif (bootverbose == 0)\r\nbreak;\r\nspi_period(starget) = tinfo->curr.period;\r\nspi_width(starget) = tinfo->curr.width;\r\nspi_offset(starget) = tinfo->curr.offset;\r\nspi_dt(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_DT_REQ ? 1 : 0;\r\nspi_qas(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_QAS_REQ ? 1 : 0;\r\nspi_iu(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ ? 1 : 0;\r\nspi_rd_strm(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_RD_STRM ? 1 : 0;\r\nspi_pcomp_en(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_PCOMP_EN ? 1 : 0;\r\nspi_rti(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_RTI ? 1 : 0;\r\nspi_wr_flow(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_WR_FLOW ? 1 : 0;\r\nspi_hold_mcs(starget) = tinfo->curr.ppr_options & MSG_EXT_PPR_HOLD_MCS ? 1 : 0;\r\nspi_display_xfer_agreement(starget);\r\nbreak;\r\n}\r\ncase AC_SENT_BDR:\r\n{\r\nWARN_ON(lun != CAM_LUN_WILDCARD);\r\nscsi_report_device_reset(ahd->platform_data->host,\r\nchannel - 'A', target);\r\nbreak;\r\n}\r\ncase AC_BUS_RESET:\r\nif (ahd->platform_data->host != NULL) {\r\nscsi_report_bus_reset(ahd->platform_data->host,\r\nchannel - 'A');\r\n}\r\nbreak;\r\ndefault:\r\npanic("ahd_send_async: Unexpected async event");\r\n}\r\n}\r\nvoid\r\nahd_done(struct ahd_softc *ahd, struct scb *scb)\r\n{\r\nstruct scsi_cmnd *cmd;\r\nstruct ahd_linux_device *dev;\r\nif ((scb->flags & SCB_ACTIVE) == 0) {\r\nprintk("SCB %d done'd twice\n", SCB_GET_TAG(scb));\r\nahd_dump_card_state(ahd);\r\npanic("Stopping for safety");\r\n}\r\nLIST_REMOVE(scb, pending_links);\r\ncmd = scb->io_ctx;\r\ndev = scb->platform_data->dev;\r\ndev->active--;\r\ndev->openings++;\r\nif ((cmd->result & (CAM_DEV_QFRZN << 16)) != 0) {\r\ncmd->result &= ~(CAM_DEV_QFRZN << 16);\r\ndev->qfrozen--;\r\n}\r\nahd_linux_unmap_scb(ahd, scb);\r\ncmd->sense_buffer[0] = 0;\r\nif (ahd_get_transaction_status(scb) == CAM_REQ_INPROG) {\r\nuint32_t amount_xferred;\r\namount_xferred =\r\nahd_get_transfer_length(scb) - ahd_get_residual(scb);\r\nif ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_MISC) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("Set CAM_UNCOR_PARITY\n");\r\n}\r\n#endif\r\nahd_set_transaction_status(scb, CAM_UNCOR_PARITY);\r\n#ifdef AHD_REPORT_UNDERFLOWS\r\n} else if (amount_xferred < scb->io_ctx->underflow) {\r\nu_int i;\r\nahd_print_path(ahd, scb);\r\nprintk("CDB:");\r\nfor (i = 0; i < scb->io_ctx->cmd_len; i++)\r\nprintk(" 0x%x", scb->io_ctx->cmnd[i]);\r\nprintk("\n");\r\nahd_print_path(ahd, scb);\r\nprintk("Saw underflow (%ld of %ld bytes). "\r\n"Treated as error\n",\r\nahd_get_residual(scb),\r\nahd_get_transfer_length(scb));\r\nahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);\r\n#endif\r\n} else {\r\nahd_set_transaction_status(scb, CAM_REQ_CMP);\r\n}\r\n} else if (ahd_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {\r\nahd_linux_handle_scsi_status(ahd, cmd->device, scb);\r\n}\r\nif (dev->openings == 1\r\n&& ahd_get_transaction_status(scb) == CAM_REQ_CMP\r\n&& ahd_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)\r\ndev->tag_success_count++;\r\nif ((dev->openings + dev->active) < dev->maxtags\r\n&& dev->tag_success_count > AHD_TAG_SUCCESS_INTERVAL) {\r\ndev->tag_success_count = 0;\r\ndev->openings++;\r\n}\r\nif (dev->active == 0)\r\ndev->commands_since_idle_or_otag = 0;\r\nif ((scb->flags & SCB_RECOVERY_SCB) != 0) {\r\nprintk("Recovery SCB completes\n");\r\nif (ahd_get_transaction_status(scb) == CAM_BDR_SENT\r\n|| ahd_get_transaction_status(scb) == CAM_REQ_ABORTED)\r\nahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);\r\nif (ahd->platform_data->eh_done)\r\ncomplete(ahd->platform_data->eh_done);\r\n}\r\nahd_free_scb(ahd, scb);\r\nahd_linux_queue_cmd_complete(ahd, cmd);\r\n}\r\nstatic void\r\nahd_linux_handle_scsi_status(struct ahd_softc *ahd,\r\nstruct scsi_device *sdev, struct scb *scb)\r\n{\r\nstruct ahd_devinfo devinfo;\r\nstruct ahd_linux_device *dev = scsi_transport_device_data(sdev);\r\nahd_compile_devinfo(&devinfo,\r\nahd->our_id,\r\nsdev->sdev_target->id, sdev->lun,\r\nsdev->sdev_target->channel == 0 ? 'A' : 'B',\r\nROLE_INITIATOR);\r\nswitch (ahd_get_scsi_status(scb)) {\r\ndefault:\r\nbreak;\r\ncase SCSI_STATUS_CHECK_COND:\r\ncase SCSI_STATUS_CMD_TERMINATED:\r\n{\r\nstruct scsi_cmnd *cmd;\r\ncmd = scb->io_ctx;\r\nif ((scb->flags & (SCB_SENSE|SCB_PKT_SENSE)) != 0) {\r\nstruct scsi_status_iu_header *siu;\r\nu_int sense_size;\r\nu_int sense_offset;\r\nif (scb->flags & SCB_SENSE) {\r\nsense_size = min(sizeof(struct scsi_sense_data)\r\n- ahd_get_sense_residual(scb),\r\n(u_long)SCSI_SENSE_BUFFERSIZE);\r\nsense_offset = 0;\r\n} else {\r\nsiu = (struct scsi_status_iu_header *)\r\nscb->sense_data;\r\nsense_size = min_t(size_t,\r\nscsi_4btoul(siu->sense_length),\r\nSCSI_SENSE_BUFFERSIZE);\r\nsense_offset = SIU_SENSE_OFFSET(siu);\r\n}\r\nmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nmemcpy(cmd->sense_buffer,\r\nahd_get_sense_buf(ahd, scb)\r\n+ sense_offset, sense_size);\r\ncmd->result |= (DRIVER_SENSE << 24);\r\n#ifdef AHD_DEBUG\r\nif (ahd_debug & AHD_SHOW_SENSE) {\r\nint i;\r\nprintk("Copied %d bytes of sense data at %d:",\r\nsense_size, sense_offset);\r\nfor (i = 0; i < sense_size; i++) {\r\nif ((i & 0xF) == 0)\r\nprintk("\n");\r\nprintk("0x%x ", cmd->sense_buffer[i]);\r\n}\r\nprintk("\n");\r\n}\r\n#endif\r\n}\r\nbreak;\r\n}\r\ncase SCSI_STATUS_QUEUE_FULL:\r\ndev->tag_success_count = 0;\r\nif (dev->active != 0) {\r\ndev->openings = 0;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_QFULL) != 0) {\r\nahd_print_path(ahd, scb);\r\nprintk("Dropping tag count to %d\n",\r\ndev->active);\r\n}\r\n#endif\r\nif (dev->active == dev->tags_on_last_queuefull) {\r\ndev->last_queuefull_same_count++;\r\nif (dev->last_queuefull_same_count\r\n== AHD_LOCK_TAGS_COUNT) {\r\ndev->maxtags = dev->active;\r\nahd_print_path(ahd, scb);\r\nprintk("Locking max tag count at %d\n",\r\ndev->active);\r\n}\r\n} else {\r\ndev->tags_on_last_queuefull = dev->active;\r\ndev->last_queuefull_same_count = 0;\r\n}\r\nahd_set_transaction_status(scb, CAM_REQUEUE_REQ);\r\nahd_set_scsi_status(scb, SCSI_STATUS_OK);\r\nahd_platform_set_tags(ahd, sdev, &devinfo,\r\n(dev->flags & AHD_DEV_Q_BASIC)\r\n? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);\r\nbreak;\r\n}\r\ndev->openings = 1;\r\nahd_platform_set_tags(ahd, sdev, &devinfo,\r\n(dev->flags & AHD_DEV_Q_BASIC)\r\n? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);\r\nahd_set_scsi_status(scb, SCSI_STATUS_BUSY);\r\n}\r\n}\r\nstatic void\r\nahd_linux_queue_cmd_complete(struct ahd_softc *ahd, struct scsi_cmnd *cmd)\r\n{\r\nint status;\r\nint new_status = DID_OK;\r\nint do_fallback = 0;\r\nint scsi_status;\r\nstatus = ahd_cmd_get_transaction_status(cmd);\r\nswitch (status) {\r\ncase CAM_REQ_INPROG:\r\ncase CAM_REQ_CMP:\r\nnew_status = DID_OK;\r\nbreak;\r\ncase CAM_AUTOSENSE_FAIL:\r\nnew_status = DID_ERROR;\r\ncase CAM_SCSI_STATUS_ERROR:\r\nscsi_status = ahd_cmd_get_scsi_status(cmd);\r\nswitch(scsi_status) {\r\ncase SCSI_STATUS_CMD_TERMINATED:\r\ncase SCSI_STATUS_CHECK_COND:\r\nif ((cmd->result >> 24) != DRIVER_SENSE) {\r\ndo_fallback = 1;\r\n} else {\r\nstruct scsi_sense_data *sense;\r\nsense = (struct scsi_sense_data *)\r\ncmd->sense_buffer;\r\nif (sense->extra_len >= 5 &&\r\n(sense->add_sense_code == 0x47\r\n|| sense->add_sense_code == 0x48))\r\ndo_fallback = 1;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase CAM_REQ_ABORTED:\r\nnew_status = DID_ABORT;\r\nbreak;\r\ncase CAM_BUSY:\r\nnew_status = DID_BUS_BUSY;\r\nbreak;\r\ncase CAM_REQ_INVALID:\r\ncase CAM_PATH_INVALID:\r\nnew_status = DID_BAD_TARGET;\r\nbreak;\r\ncase CAM_SEL_TIMEOUT:\r\nnew_status = DID_NO_CONNECT;\r\nbreak;\r\ncase CAM_SCSI_BUS_RESET:\r\ncase CAM_BDR_SENT:\r\nnew_status = DID_RESET;\r\nbreak;\r\ncase CAM_UNCOR_PARITY:\r\nnew_status = DID_PARITY;\r\ndo_fallback = 1;\r\nbreak;\r\ncase CAM_CMD_TIMEOUT:\r\nnew_status = DID_TIME_OUT;\r\ndo_fallback = 1;\r\nbreak;\r\ncase CAM_REQ_CMP_ERR:\r\ncase CAM_UNEXP_BUSFREE:\r\ncase CAM_DATA_RUN_ERR:\r\nnew_status = DID_ERROR;\r\ndo_fallback = 1;\r\nbreak;\r\ncase CAM_UA_ABORT:\r\ncase CAM_NO_HBA:\r\ncase CAM_SEQUENCE_FAIL:\r\ncase CAM_CCB_LEN_ERR:\r\ncase CAM_PROVIDE_FAIL:\r\ncase CAM_REQ_TERMIO:\r\ncase CAM_UNREC_HBA_ERROR:\r\ncase CAM_REQ_TOO_BIG:\r\nnew_status = DID_ERROR;\r\nbreak;\r\ncase CAM_REQUEUE_REQ:\r\nnew_status = DID_REQUEUE;\r\nbreak;\r\ndefault:\r\nnew_status = DID_ERROR;\r\nbreak;\r\n}\r\nif (do_fallback) {\r\nprintk("%s: device overrun (status %x) on %d:%d:%d\n",\r\nahd_name(ahd), status, cmd->device->channel,\r\ncmd->device->id, (u8)cmd->device->lun);\r\n}\r\nahd_cmd_set_transaction_status(cmd, new_status);\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic void\r\nahd_freeze_simq(struct ahd_softc *ahd)\r\n{\r\nscsi_block_requests(ahd->platform_data->host);\r\n}\r\nstatic void\r\nahd_release_simq(struct ahd_softc *ahd)\r\n{\r\nscsi_unblock_requests(ahd->platform_data->host);\r\n}\r\nstatic int\r\nahd_linux_queue_abort_cmd(struct scsi_cmnd *cmd)\r\n{\r\nstruct ahd_softc *ahd;\r\nstruct ahd_linux_device *dev;\r\nstruct scb *pending_scb;\r\nu_int saved_scbptr;\r\nu_int active_scbptr;\r\nu_int last_phase;\r\nu_int saved_scsiid;\r\nu_int cdb_byte;\r\nint retval;\r\nint was_paused;\r\nint paused;\r\nint wait;\r\nint disconnected;\r\nahd_mode_state saved_modes;\r\nunsigned long flags;\r\npending_scb = NULL;\r\npaused = FALSE;\r\nwait = FALSE;\r\nahd = *(struct ahd_softc **)cmd->device->host->hostdata;\r\nscmd_printk(KERN_INFO, cmd,\r\n"Attempting to queue an ABORT message:");\r\nprintk("CDB:");\r\nfor (cdb_byte = 0; cdb_byte < cmd->cmd_len; cdb_byte++)\r\nprintk(" 0x%x", cmd->cmnd[cdb_byte]);\r\nprintk("\n");\r\nahd_lock(ahd, &flags);\r\ndev = scsi_transport_device_data(cmd->device);\r\nif (dev == NULL) {\r\nscmd_printk(KERN_INFO, cmd, "Is not an active device\n");\r\nretval = SUCCESS;\r\ngoto no_cmd;\r\n}\r\nLIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {\r\nif (pending_scb->io_ctx == cmd)\r\nbreak;\r\n}\r\nif (pending_scb == NULL) {\r\nscmd_printk(KERN_INFO, cmd, "Command not found\n");\r\ngoto no_cmd;\r\n}\r\nif ((pending_scb->flags & SCB_RECOVERY_SCB) != 0) {\r\nretval = FAILED;\r\ngoto done;\r\n}\r\nwas_paused = ahd_is_paused(ahd);\r\nahd_pause_and_flushwork(ahd);\r\npaused = TRUE;\r\nif ((pending_scb->flags & SCB_ACTIVE) == 0) {\r\nscmd_printk(KERN_INFO, cmd, "Command already completed\n");\r\ngoto no_cmd;\r\n}\r\nprintk("%s: At time of recovery, card was %spaused\n",\r\nahd_name(ahd), was_paused ? "" : "not ");\r\nahd_dump_card_state(ahd);\r\ndisconnected = TRUE;\r\nif (ahd_search_qinfifo(ahd, cmd->device->id,\r\ncmd->device->channel + 'A',\r\ncmd->device->lun,\r\npending_scb->hscb->tag,\r\nROLE_INITIATOR, CAM_REQ_ABORTED,\r\nSEARCH_COMPLETE) > 0) {\r\nprintk("%s:%d:%d:%d: Cmd aborted from QINFIFO\n",\r\nahd_name(ahd), cmd->device->channel,\r\ncmd->device->id, (u8)cmd->device->lun);\r\nretval = SUCCESS;\r\ngoto done;\r\n}\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nlast_phase = ahd_inb(ahd, LASTPHASE);\r\nsaved_scbptr = ahd_get_scbptr(ahd);\r\nactive_scbptr = saved_scbptr;\r\nif (disconnected && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) == 0) {\r\nstruct scb *bus_scb;\r\nbus_scb = ahd_lookup_scb(ahd, active_scbptr);\r\nif (bus_scb == pending_scb)\r\ndisconnected = FALSE;\r\n}\r\nsaved_scsiid = ahd_inb(ahd, SAVED_SCSIID);\r\nif (last_phase != P_BUSFREE\r\n&& SCB_GET_TAG(pending_scb) == active_scbptr) {\r\npending_scb = ahd_lookup_scb(ahd, active_scbptr);\r\npending_scb->flags |= SCB_RECOVERY_SCB|SCB_ABORT;\r\nahd_outb(ahd, MSG_OUT, HOST_MSG);\r\nahd_outb(ahd, SCSISIGO, last_phase|ATNO);\r\nscmd_printk(KERN_INFO, cmd, "Device is active, asserting ATN\n");\r\nwait = TRUE;\r\n} else if (disconnected) {\r\npending_scb->flags |= SCB_RECOVERY_SCB|SCB_ABORT;\r\nahd_set_scbptr(ahd, SCB_GET_TAG(pending_scb));\r\npending_scb->hscb->cdb_len = 0;\r\npending_scb->hscb->task_attribute = 0;\r\npending_scb->hscb->task_management = SIU_TASKMGMT_ABORT_TASK;\r\nif ((pending_scb->flags & SCB_PACKETIZED) != 0) {\r\nahd_outb(ahd, SCB_TASK_MANAGEMENT,\r\npending_scb->hscb->task_management);\r\n} else {\r\npending_scb->hscb->control |= MK_MESSAGE|DISCONNECTED;\r\nahd_outb(ahd, SCB_CONTROL,\r\nahd_inb(ahd, SCB_CONTROL)|MK_MESSAGE);\r\n}\r\nahd_search_qinfifo(ahd, cmd->device->id,\r\ncmd->device->channel + 'A', cmd->device->lun,\r\nSCB_LIST_NULL, ROLE_INITIATOR,\r\nCAM_REQUEUE_REQ, SEARCH_COMPLETE);\r\nahd_qinfifo_requeue_tail(ahd, pending_scb);\r\nahd_set_scbptr(ahd, saved_scbptr);\r\nahd_print_path(ahd, pending_scb);\r\nprintk("Device is disconnected, re-queuing SCB\n");\r\nwait = TRUE;\r\n} else {\r\nscmd_printk(KERN_INFO, cmd, "Unable to deliver message\n");\r\nretval = FAILED;\r\ngoto done;\r\n}\r\nno_cmd:\r\nretval = SUCCESS;\r\ndone:\r\nif (paused)\r\nahd_unpause(ahd);\r\nif (wait) {\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nahd->platform_data->eh_done = &done;\r\nahd_unlock(ahd, &flags);\r\nprintk("%s: Recovery code sleeping\n", ahd_name(ahd));\r\nif (!wait_for_completion_timeout(&done, 5 * HZ)) {\r\nahd_lock(ahd, &flags);\r\nahd->platform_data->eh_done = NULL;\r\nahd_unlock(ahd, &flags);\r\nprintk("%s: Timer Expired (active %d)\n",\r\nahd_name(ahd), dev->active);\r\nretval = FAILED;\r\n}\r\nprintk("Recovery code awake\n");\r\n} else\r\nahd_unlock(ahd, &flags);\r\nif (retval != SUCCESS)\r\nprintk("%s: Command abort returning 0x%x\n",\r\nahd_name(ahd), retval);\r\nreturn retval;\r\n}\r\nstatic void ahd_linux_set_width(struct scsi_target *starget, int width)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_devinfo devinfo;\r\nunsigned long flags;\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_lock(ahd, &flags);\r\nahd_set_width(ahd, &devinfo, width, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_period(struct scsi_target *starget, int period)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options;\r\nunsigned int dt;\r\nunsigned long flags;\r\nunsigned long offset = tinfo->goal.offset;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: set period to %d\n", ahd_name(ahd), period);\r\n#endif\r\nif (offset == 0)\r\noffset = MAX_OFFSET;\r\nif (period < 8)\r\nperiod = 8;\r\nif (period < 10) {\r\nif (spi_max_width(starget)) {\r\nppr_options |= MSG_EXT_PPR_DT_REQ;\r\nif (period == 8)\r\nppr_options |= MSG_EXT_PPR_IU_REQ;\r\n} else\r\nperiod = 10;\r\n}\r\ndt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nif (ppr_options & ~MSG_EXT_PPR_QAS_REQ) {\r\nif (spi_width(starget) == 0)\r\nppr_options &= MSG_EXT_PPR_QAS_REQ;\r\n}\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_offset(struct scsi_target *starget, int offset)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = 0;\r\nunsigned int period = 0;\r\nunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nunsigned long flags;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: set offset to %d\n", ahd_name(ahd), offset);\r\n#endif\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nif (offset != 0) {\r\nperiod = tinfo->goal.period;\r\nppr_options = tinfo->goal.ppr_options;\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\n}\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, offset, ppr_options,\r\nAHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_dt(struct scsi_target *starget, int dt)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_DT_REQ;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int width = tinfo->goal.width;\r\nunsigned long flags;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: %s DT\n", ahd_name(ahd),\r\ndt ? "enabling" : "disabling");\r\n#endif\r\nif (dt && spi_max_width(starget)) {\r\nppr_options |= MSG_EXT_PPR_DT_REQ;\r\nif (!width)\r\nahd_linux_set_width(starget, 1);\r\n} else {\r\nif (period <= 9)\r\nperiod = 10;\r\nppr_options &= ~MSG_EXT_PPR_IU_REQ;\r\n}\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_qas(struct scsi_target *starget, int qas)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_QAS_REQ;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int dt;\r\nunsigned long flags;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: %s QAS\n", ahd_name(ahd),\r\nqas ? "enabling" : "disabling");\r\n#endif\r\nif (qas) {\r\nppr_options |= MSG_EXT_PPR_QAS_REQ;\r\n}\r\ndt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_iu(struct scsi_target *starget, int iu)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_IU_REQ;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int dt;\r\nunsigned long flags;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: %s IU\n", ahd_name(ahd),\r\niu ? "enabling" : "disabling");\r\n#endif\r\nif (iu && spi_max_width(starget)) {\r\nppr_options |= MSG_EXT_PPR_IU_REQ;\r\nppr_options |= MSG_EXT_PPR_DT_REQ;\r\n}\r\ndt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_rd_strm(struct scsi_target *starget, int rdstrm)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_RD_STRM;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nunsigned long flags;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: %s Read Streaming\n", ahd_name(ahd),\r\nrdstrm ? "enabling" : "disabling");\r\n#endif\r\nif (rdstrm && spi_max_width(starget))\r\nppr_options |= MSG_EXT_PPR_RD_STRM;\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_wr_flow(struct scsi_target *starget, int wrflow)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_WR_FLOW;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nunsigned long flags;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: %s Write Flow Control\n", ahd_name(ahd),\r\nwrflow ? "enabling" : "disabling");\r\n#endif\r\nif (wrflow && spi_max_width(starget))\r\nppr_options |= MSG_EXT_PPR_WR_FLOW;\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_rti(struct scsi_target *starget, int rti)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_RTI;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nunsigned long flags;\r\nif ((ahd->features & AHD_RTI) == 0) {\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: RTI not available\n", ahd_name(ahd));\r\n#endif\r\nreturn;\r\n}\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: %s RTI\n", ahd_name(ahd),\r\nrti ? "enabling" : "disabling");\r\n#endif\r\nif (rti && spi_max_width(starget))\r\nppr_options |= MSG_EXT_PPR_RTI;\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_pcomp_en(struct scsi_target *starget, int pcomp)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_PCOMP_EN;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nunsigned long flags;\r\n#ifdef AHD_DEBUG\r\nif ((ahd_debug & AHD_SHOW_DV) != 0)\r\nprintk("%s: %s Precompensation\n", ahd_name(ahd),\r\npcomp ? "Enable" : "Disable");\r\n#endif\r\nif (pcomp && spi_max_width(starget)) {\r\nuint8_t precomp;\r\nif (ahd->unit < ARRAY_SIZE(aic79xx_iocell_info)) {\r\nconst struct ahd_linux_iocell_opts *iocell_opts;\r\niocell_opts = &aic79xx_iocell_info[ahd->unit];\r\nprecomp = iocell_opts->precomp;\r\n} else {\r\nprecomp = AIC79XX_DEFAULT_PRECOMP;\r\n}\r\nppr_options |= MSG_EXT_PPR_PCOMP_EN;\r\nAHD_SET_PRECOMP(ahd, precomp);\r\n} else {\r\nAHD_SET_PRECOMP(ahd, 0);\r\n}\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_set_hold_mcs(struct scsi_target *starget, int hold)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nstruct ahd_softc *ahd = *((struct ahd_softc **)shost->hostdata);\r\nstruct ahd_tmode_tstate *tstate;\r\nstruct ahd_initiator_tinfo *tinfo\r\n= ahd_fetch_transinfo(ahd,\r\nstarget->channel + 'A',\r\nshost->this_id, starget->id, &tstate);\r\nstruct ahd_devinfo devinfo;\r\nunsigned int ppr_options = tinfo->goal.ppr_options\r\n& ~MSG_EXT_PPR_HOLD_MCS;\r\nunsigned int period = tinfo->goal.period;\r\nunsigned int dt = ppr_options & MSG_EXT_PPR_DT_REQ;\r\nunsigned long flags;\r\nif (hold && spi_max_width(starget))\r\nppr_options |= MSG_EXT_PPR_HOLD_MCS;\r\nahd_compile_devinfo(&devinfo, shost->this_id, starget->id, 0,\r\nstarget->channel + 'A', ROLE_INITIATOR);\r\nahd_find_syncrate(ahd, &period, &ppr_options,\r\ndt ? AHD_SYNCRATE_MAX : AHD_SYNCRATE_ULTRA2);\r\nahd_lock(ahd, &flags);\r\nahd_set_syncrate(ahd, &devinfo, period, tinfo->goal.offset,\r\nppr_options, AHD_TRANS_GOAL, FALSE);\r\nahd_unlock(ahd, &flags);\r\n}\r\nstatic void ahd_linux_get_signalling(struct Scsi_Host *shost)\r\n{\r\nstruct ahd_softc *ahd = *(struct ahd_softc **)shost->hostdata;\r\nunsigned long flags;\r\nu8 mode;\r\nahd_lock(ahd, &flags);\r\nahd_pause(ahd);\r\nmode = ahd_inb(ahd, SBLKCTL);\r\nahd_unpause(ahd);\r\nahd_unlock(ahd, &flags);\r\nif (mode & ENAB40)\r\nspi_signalling(shost) = SPI_SIGNAL_LVD;\r\nelse if (mode & ENAB20)\r\nspi_signalling(shost) = SPI_SIGNAL_SE;\r\nelse\r\nspi_signalling(shost) = SPI_SIGNAL_UNKNOWN;\r\n}\r\nstatic int __init\r\nahd_linux_init(void)\r\n{\r\nint error = 0;\r\nif (aic79xx)\r\naic79xx_setup(aic79xx);\r\nahd_linux_transport_template =\r\nspi_attach_transport(&ahd_linux_transport_functions);\r\nif (!ahd_linux_transport_template)\r\nreturn -ENODEV;\r\nscsi_transport_reserve_device(ahd_linux_transport_template,\r\nsizeof(struct ahd_linux_device));\r\nerror = ahd_linux_pci_init();\r\nif (error)\r\nspi_release_transport(ahd_linux_transport_template);\r\nreturn error;\r\n}\r\nstatic void __exit\r\nahd_linux_exit(void)\r\n{\r\nahd_linux_pci_exit();\r\nspi_release_transport(ahd_linux_transport_template);\r\n}
