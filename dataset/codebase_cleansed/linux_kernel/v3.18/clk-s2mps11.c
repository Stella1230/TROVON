static struct s2mps11_clk *to_s2mps11_clk(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct s2mps11_clk, hw);\r\n}\r\nstatic int s2mps11_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct s2mps11_clk *s2mps11 = to_s2mps11_clk(hw);\r\nint ret;\r\nret = regmap_update_bits(s2mps11->iodev->regmap_pmic,\r\ns2mps11->reg,\r\ns2mps11->mask, s2mps11->mask);\r\nreturn ret;\r\n}\r\nstatic void s2mps11_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct s2mps11_clk *s2mps11 = to_s2mps11_clk(hw);\r\nint ret;\r\nret = regmap_update_bits(s2mps11->iodev->regmap_pmic, s2mps11->reg,\r\ns2mps11->mask, ~s2mps11->mask);\r\n}\r\nstatic int s2mps11_clk_is_prepared(struct clk_hw *hw)\r\n{\r\nint ret;\r\nu32 val;\r\nstruct s2mps11_clk *s2mps11 = to_s2mps11_clk(hw);\r\nret = regmap_read(s2mps11->iodev->regmap_pmic,\r\ns2mps11->reg, &val);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nreturn val & s2mps11->mask;\r\n}\r\nstatic unsigned long s2mps11_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 32768;\r\n}\r\nstatic struct device_node *s2mps11_clk_parse_dt(struct platform_device *pdev,\r\nstruct clk_init_data *clks_init)\r\n{\r\nstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *clk_np;\r\nint i;\r\nif (!iodev->dev->of_node)\r\nreturn ERR_PTR(-EINVAL);\r\nclk_np = of_get_child_by_name(iodev->dev->of_node, "clocks");\r\nif (!clk_np) {\r\ndev_err(&pdev->dev, "could not find clock sub-node\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfor (i = 0; i < S2MPS11_CLKS_NUM; i++) {\r\nif (!clks_init[i].name)\r\ncontinue;\r\nof_property_read_string_index(clk_np, "clock-output-names", i,\r\n&clks_init[i].name);\r\n}\r\nreturn clk_np;\r\n}\r\nstatic int s2mps11_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct s2mps11_clk *s2mps11_clks, *s2mps11_clk;\r\nunsigned int s2mps11_reg;\r\nstruct clk_init_data *clks_init;\r\nint i, ret = 0;\r\ns2mps11_clks = devm_kzalloc(&pdev->dev, sizeof(*s2mps11_clk) *\r\nS2MPS11_CLKS_NUM, GFP_KERNEL);\r\nif (!s2mps11_clks)\r\nreturn -ENOMEM;\r\ns2mps11_clk = s2mps11_clks;\r\nclk_table = devm_kzalloc(&pdev->dev, sizeof(struct clk *) *\r\nS2MPS11_CLKS_NUM, GFP_KERNEL);\r\nif (!clk_table)\r\nreturn -ENOMEM;\r\nswitch(platform_get_device_id(pdev)->driver_data) {\r\ncase S2MPS11X:\r\ns2mps11_reg = S2MPS11_REG_RTC_CTRL;\r\nclks_init = s2mps11_clks_init;\r\nbreak;\r\ncase S2MPS14X:\r\ns2mps11_reg = S2MPS14_REG_RTCCTRL;\r\nclks_init = s2mps14_clks_init;\r\nbreak;\r\ncase S5M8767X:\r\ns2mps11_reg = S5M8767_REG_CTRL1;\r\nclks_init = s2mps11_clks_init;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Invalid device type\n");\r\nreturn -EINVAL;\r\n};\r\ns2mps11_clks->clk_np = s2mps11_clk_parse_dt(pdev, clks_init);\r\nif (IS_ERR(s2mps11_clks->clk_np))\r\nreturn PTR_ERR(s2mps11_clks->clk_np);\r\nfor (i = 0; i < S2MPS11_CLKS_NUM; i++, s2mps11_clk++) {\r\nif (!clks_init[i].name)\r\ncontinue;\r\ns2mps11_clk->iodev = iodev;\r\ns2mps11_clk->hw.init = &clks_init[i];\r\ns2mps11_clk->mask = 1 << i;\r\ns2mps11_clk->reg = s2mps11_reg;\r\ns2mps11_clk->clk = devm_clk_register(&pdev->dev,\r\n&s2mps11_clk->hw);\r\nif (IS_ERR(s2mps11_clk->clk)) {\r\ndev_err(&pdev->dev, "Fail to register : %s\n",\r\ns2mps11_name(s2mps11_clk));\r\nret = PTR_ERR(s2mps11_clk->clk);\r\ngoto err_reg;\r\n}\r\ns2mps11_clk->lookup = clkdev_alloc(s2mps11_clk->clk,\r\ns2mps11_name(s2mps11_clk), NULL);\r\nif (!s2mps11_clk->lookup) {\r\nret = -ENOMEM;\r\ngoto err_lup;\r\n}\r\nclkdev_add(s2mps11_clk->lookup);\r\n}\r\nfor (i = 0; i < S2MPS11_CLKS_NUM; i++) {\r\nif (!clks_init[i].name)\r\ncontinue;\r\nclk_table[i] = s2mps11_clks[i].clk;\r\n}\r\nclk_data.clks = clk_table;\r\nclk_data.clk_num = S2MPS11_CLKS_NUM;\r\nof_clk_add_provider(s2mps11_clks->clk_np, of_clk_src_onecell_get,\r\n&clk_data);\r\nplatform_set_drvdata(pdev, s2mps11_clks);\r\nreturn ret;\r\nerr_lup:\r\ndevm_clk_unregister(&pdev->dev, s2mps11_clk->clk);\r\nerr_reg:\r\nwhile (s2mps11_clk > s2mps11_clks) {\r\nif (s2mps11_clk->lookup) {\r\nclkdev_drop(s2mps11_clk->lookup);\r\ndevm_clk_unregister(&pdev->dev, s2mps11_clk->clk);\r\n}\r\ns2mps11_clk--;\r\n}\r\nreturn ret;\r\n}\r\nstatic int s2mps11_clk_remove(struct platform_device *pdev)\r\n{\r\nstruct s2mps11_clk *s2mps11_clks = platform_get_drvdata(pdev);\r\nint i;\r\nof_clk_del_provider(s2mps11_clks[0].clk_np);\r\nof_node_put(s2mps11_clks[0].clk_np);\r\nfor (i = 0; i < S2MPS11_CLKS_NUM; i++) {\r\nif (!s2mps11_clks[i].lookup)\r\ncontinue;\r\nclkdev_drop(s2mps11_clks[i].lookup);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init s2mps11_clk_init(void)\r\n{\r\nreturn platform_driver_register(&s2mps11_clk_driver);\r\n}\r\nstatic void __init s2mps11_clk_cleanup(void)\r\n{\r\nplatform_driver_unregister(&s2mps11_clk_driver);\r\n}
