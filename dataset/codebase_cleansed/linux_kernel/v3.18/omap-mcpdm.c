static inline void omap_mcpdm_write(struct omap_mcpdm *mcpdm, u16 reg, u32 val)\r\n{\r\nwritel_relaxed(val, mcpdm->io_base + reg);\r\n}\r\nstatic inline int omap_mcpdm_read(struct omap_mcpdm *mcpdm, u16 reg)\r\n{\r\nreturn readl_relaxed(mcpdm->io_base + reg);\r\n}\r\nstatic void omap_mcpdm_reg_dump(struct omap_mcpdm *mcpdm)\r\n{\r\ndev_dbg(mcpdm->dev, "***********************\n");\r\ndev_dbg(mcpdm->dev, "IRQSTATUS_RAW: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_IRQSTATUS_RAW));\r\ndev_dbg(mcpdm->dev, "IRQSTATUS: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_IRQSTATUS));\r\ndev_dbg(mcpdm->dev, "IRQENABLE_SET: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_IRQENABLE_SET));\r\ndev_dbg(mcpdm->dev, "IRQENABLE_CLR: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_IRQENABLE_CLR));\r\ndev_dbg(mcpdm->dev, "IRQWAKE_EN: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_IRQWAKE_EN));\r\ndev_dbg(mcpdm->dev, "DMAENABLE_SET: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_DMAENABLE_SET));\r\ndev_dbg(mcpdm->dev, "DMAENABLE_CLR: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_DMAENABLE_CLR));\r\ndev_dbg(mcpdm->dev, "DMAWAKEEN: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_DMAWAKEEN));\r\ndev_dbg(mcpdm->dev, "CTRL: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_CTRL));\r\ndev_dbg(mcpdm->dev, "DN_DATA: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_DN_DATA));\r\ndev_dbg(mcpdm->dev, "UP_DATA: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_UP_DATA));\r\ndev_dbg(mcpdm->dev, "FIFO_CTRL_DN: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_FIFO_CTRL_DN));\r\ndev_dbg(mcpdm->dev, "FIFO_CTRL_UP: 0x%04x\n",\r\nomap_mcpdm_read(mcpdm, MCPDM_REG_FIFO_CTRL_UP));\r\ndev_dbg(mcpdm->dev, "***********************\n");\r\n}\r\nstatic void omap_mcpdm_reg_dump(struct omap_mcpdm *mcpdm) {}\r\nstatic void omap_mcpdm_start(struct omap_mcpdm *mcpdm)\r\n{\r\nu32 ctrl = omap_mcpdm_read(mcpdm, MCPDM_REG_CTRL);\r\nu32 link_mask = mcpdm->config[0].link_mask | mcpdm->config[1].link_mask;\r\nctrl |= (MCPDM_SW_DN_RST | MCPDM_SW_UP_RST);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\r\nctrl |= link_mask;\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\r\nctrl &= ~(MCPDM_SW_DN_RST | MCPDM_SW_UP_RST);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\r\n}\r\nstatic void omap_mcpdm_stop(struct omap_mcpdm *mcpdm)\r\n{\r\nu32 ctrl = omap_mcpdm_read(mcpdm, MCPDM_REG_CTRL);\r\nu32 link_mask = MCPDM_PDM_DN_MASK | MCPDM_PDM_UP_MASK;\r\nctrl |= (MCPDM_SW_DN_RST | MCPDM_SW_UP_RST);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\r\nctrl &= ~(link_mask);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\r\nctrl &= ~(MCPDM_SW_DN_RST | MCPDM_SW_UP_RST);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\r\n}\r\nstatic inline int omap_mcpdm_active(struct omap_mcpdm *mcpdm)\r\n{\r\nreturn omap_mcpdm_read(mcpdm, MCPDM_REG_CTRL) &\r\n(MCPDM_PDM_DN_MASK | MCPDM_PDM_UP_MASK);\r\n}\r\nstatic void omap_mcpdm_open_streams(struct omap_mcpdm *mcpdm)\r\n{\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_IRQENABLE_SET,\r\nMCPDM_DN_IRQ_EMPTY | MCPDM_DN_IRQ_FULL |\r\nMCPDM_UP_IRQ_EMPTY | MCPDM_UP_IRQ_FULL);\r\nif (mcpdm->dn_rx_offset) {\r\nu32 dn_offset = mcpdm->dn_rx_offset;\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_DN_OFFSET, dn_offset);\r\ndn_offset |= (MCPDM_DN_OFST_RX1_EN | MCPDM_DN_OFST_RX2_EN);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_DN_OFFSET, dn_offset);\r\n}\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_FIFO_CTRL_DN,\r\nmcpdm->config[SNDRV_PCM_STREAM_PLAYBACK].threshold);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_FIFO_CTRL_UP,\r\nmcpdm->config[SNDRV_PCM_STREAM_CAPTURE].threshold);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_DMAENABLE_SET,\r\nMCPDM_DMA_DN_ENABLE | MCPDM_DMA_UP_ENABLE);\r\n}\r\nstatic void omap_mcpdm_close_streams(struct omap_mcpdm *mcpdm)\r\n{\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_IRQENABLE_CLR,\r\nMCPDM_DN_IRQ_EMPTY | MCPDM_DN_IRQ_FULL);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_DMAENABLE_CLR, MCPDM_DMA_DN_ENABLE);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_IRQENABLE_CLR,\r\nMCPDM_UP_IRQ_EMPTY | MCPDM_UP_IRQ_FULL);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_DMAENABLE_CLR, MCPDM_DMA_UP_ENABLE);\r\nif (mcpdm->dn_rx_offset)\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_DN_OFFSET, 0);\r\n}\r\nstatic irqreturn_t omap_mcpdm_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct omap_mcpdm *mcpdm = dev_id;\r\nint irq_status;\r\nirq_status = omap_mcpdm_read(mcpdm, MCPDM_REG_IRQSTATUS);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_IRQSTATUS, irq_status);\r\nif (irq_status & MCPDM_DN_IRQ_FULL)\r\ndev_dbg(mcpdm->dev, "DN (playback) FIFO Full\n");\r\nif (irq_status & MCPDM_DN_IRQ_EMPTY)\r\ndev_dbg(mcpdm->dev, "DN (playback) FIFO Empty\n");\r\nif (irq_status & MCPDM_DN_IRQ)\r\ndev_dbg(mcpdm->dev, "DN (playback) write request\n");\r\nif (irq_status & MCPDM_UP_IRQ_FULL)\r\ndev_dbg(mcpdm->dev, "UP (capture) FIFO Full\n");\r\nif (irq_status & MCPDM_UP_IRQ_EMPTY)\r\ndev_dbg(mcpdm->dev, "UP (capture) FIFO Empty\n");\r\nif (irq_status & MCPDM_UP_IRQ)\r\ndev_dbg(mcpdm->dev, "UP (capture) write request\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap_mcpdm_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\r\nmutex_lock(&mcpdm->mutex);\r\nif (!dai->active) {\r\nu32 ctrl = omap_mcpdm_read(mcpdm, MCPDM_REG_CTRL);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl | MCPDM_WD_EN);\r\nomap_mcpdm_open_streams(mcpdm);\r\n}\r\nmutex_unlock(&mcpdm->mutex);\r\nreturn 0;\r\n}\r\nstatic void omap_mcpdm_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\r\nmutex_lock(&mcpdm->mutex);\r\nif (!dai->active) {\r\nif (omap_mcpdm_active(mcpdm)) {\r\nomap_mcpdm_stop(mcpdm);\r\nomap_mcpdm_close_streams(mcpdm);\r\nmcpdm->config[0].link_mask = 0;\r\nmcpdm->config[1].link_mask = 0;\r\n}\r\n}\r\nmutex_unlock(&mcpdm->mutex);\r\n}\r\nstatic int omap_mcpdm_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\r\nint stream = substream->stream;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nu32 threshold;\r\nint channels;\r\nint link_mask = 0;\r\nchannels = params_channels(params);\r\nswitch (channels) {\r\ncase 5:\r\nif (stream == SNDRV_PCM_STREAM_CAPTURE)\r\nreturn -EINVAL;\r\nlink_mask |= 1 << 4;\r\ncase 4:\r\nif (stream == SNDRV_PCM_STREAM_CAPTURE)\r\nreturn -EINVAL;\r\nlink_mask |= 1 << 3;\r\ncase 3:\r\nlink_mask |= 1 << 2;\r\ncase 2:\r\nlink_mask |= 1 << 1;\r\ncase 1:\r\nlink_mask |= 1 << 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndma_data = snd_soc_dai_get_dma_data(dai, substream);\r\nthreshold = mcpdm->config[stream].threshold;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nlink_mask <<= 3;\r\nif (!mcpdm->config[!stream].link_mask)\r\nmcpdm->config[!stream].link_mask = 0x3;\r\ndma_data->maxburst =\r\n(MCPDM_DN_THRES_MAX - threshold) * channels;\r\n} else {\r\nif (!mcpdm->config[!stream].link_mask)\r\nmcpdm->config[!stream].link_mask = (0x3 << 3);\r\ndma_data->maxburst = threshold * channels;\r\n}\r\nif (mcpdm->config[stream].link_mask &&\r\nmcpdm->config[stream].link_mask != link_mask)\r\nmcpdm->restart = true;\r\nmcpdm->config[stream].link_mask = link_mask;\r\nreturn 0;\r\n}\r\nstatic int omap_mcpdm_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\r\nif (!omap_mcpdm_active(mcpdm)) {\r\nomap_mcpdm_start(mcpdm);\r\nomap_mcpdm_reg_dump(mcpdm);\r\n} else if (mcpdm->restart) {\r\nomap_mcpdm_stop(mcpdm);\r\nomap_mcpdm_start(mcpdm);\r\nmcpdm->restart = false;\r\nomap_mcpdm_reg_dump(mcpdm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_mcpdm_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\npm_runtime_enable(mcpdm->dev);\r\npm_runtime_get_sync(mcpdm->dev);\r\nomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, 0x00);\r\nret = devm_request_irq(mcpdm->dev, mcpdm->irq, omap_mcpdm_irq_handler,\r\n0, "McPDM", (void *)mcpdm);\r\npm_runtime_put_sync(mcpdm->dev);\r\nif (ret) {\r\ndev_err(mcpdm->dev, "Request for IRQ failed\n");\r\npm_runtime_disable(mcpdm->dev);\r\n}\r\nmcpdm->config[SNDRV_PCM_STREAM_PLAYBACK].threshold = 2;\r\nmcpdm->config[SNDRV_PCM_STREAM_CAPTURE].threshold =\r\nMCPDM_UP_THRES_MAX - 3;\r\nsnd_soc_dai_init_dma_data(dai,\r\n&mcpdm->dma_data[SNDRV_PCM_STREAM_PLAYBACK],\r\n&mcpdm->dma_data[SNDRV_PCM_STREAM_CAPTURE]);\r\nreturn ret;\r\n}\r\nstatic int omap_mcpdm_remove(struct snd_soc_dai *dai)\r\n{\r\nstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\r\npm_runtime_disable(mcpdm->dev);\r\nreturn 0;\r\n}\r\nvoid omap_mcpdm_configure_dn_offsets(struct snd_soc_pcm_runtime *rtd,\r\nu8 rx1, u8 rx2)\r\n{\r\nstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nmcpdm->dn_rx_offset = MCPDM_DNOFST_RX1(rx1) | MCPDM_DNOFST_RX2(rx2);\r\n}\r\nstatic int asoc_mcpdm_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_mcpdm *mcpdm;\r\nstruct resource *res;\r\nint ret;\r\nmcpdm = devm_kzalloc(&pdev->dev, sizeof(struct omap_mcpdm), GFP_KERNEL);\r\nif (!mcpdm)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mcpdm);\r\nmutex_init(&mcpdm->mutex);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dma");\r\nif (res == NULL)\r\nreturn -ENOMEM;\r\nmcpdm->dma_data[0].addr = res->start + MCPDM_REG_DN_DATA;\r\nmcpdm->dma_data[1].addr = res->start + MCPDM_REG_UP_DATA;\r\nmcpdm->dma_data[0].filter_data = "dn_link";\r\nmcpdm->dma_data[1].filter_data = "up_link";\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mpu");\r\nmcpdm->io_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mcpdm->io_base))\r\nreturn PTR_ERR(mcpdm->io_base);\r\nmcpdm->irq = platform_get_irq(pdev, 0);\r\nif (mcpdm->irq < 0)\r\nreturn mcpdm->irq;\r\nmcpdm->dev = &pdev->dev;\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&omap_mcpdm_component,\r\n&omap_mcpdm_dai, 1);\r\nif (ret)\r\nreturn ret;\r\nreturn omap_pcm_platform_register(&pdev->dev);\r\n}
