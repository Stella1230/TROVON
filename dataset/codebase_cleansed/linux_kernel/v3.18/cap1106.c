static bool cap1106_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CAP1106_REG_MAIN_CONTROL:\r\ncase CAP1106_REG_SENSOR_INPUT:\r\ncase CAP1106_REG_SENOR_DELTA(0):\r\ncase CAP1106_REG_SENOR_DELTA(1):\r\ncase CAP1106_REG_SENOR_DELTA(2):\r\ncase CAP1106_REG_SENOR_DELTA(3):\r\ncase CAP1106_REG_SENOR_DELTA(4):\r\ncase CAP1106_REG_SENOR_DELTA(5):\r\ncase CAP1106_REG_PRODUCT_ID:\r\ncase CAP1106_REG_MANUFACTURER_ID:\r\ncase CAP1106_REG_REVISION:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic irqreturn_t cap1106_thread_func(int irq_num, void *data)\r\n{\r\nstruct cap1106_priv *priv = data;\r\nunsigned int status;\r\nint ret, i;\r\nret = regmap_update_bits(priv->regmap, CAP1106_REG_MAIN_CONTROL, 1, 0);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_read(priv->regmap, CAP1106_REG_SENSOR_INPUT, &status);\r\nif (ret < 0)\r\ngoto out;\r\nfor (i = 0; i < CAP1106_NUM_CHN; i++)\r\ninput_report_key(priv->idev, priv->keycodes[i],\r\nstatus & (1 << i));\r\ninput_sync(priv->idev);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cap1106_set_sleep(struct cap1106_priv *priv, bool sleep)\r\n{\r\nreturn regmap_update_bits(priv->regmap, CAP1106_REG_MAIN_CONTROL,\r\nCAP1106_REG_MAIN_CONTROL_DLSEEP,\r\nsleep ? CAP1106_REG_MAIN_CONTROL_DLSEEP : 0);\r\n}\r\nstatic int cap1106_input_open(struct input_dev *idev)\r\n{\r\nstruct cap1106_priv *priv = input_get_drvdata(idev);\r\nreturn cap1106_set_sleep(priv, false);\r\n}\r\nstatic void cap1106_input_close(struct input_dev *idev)\r\n{\r\nstruct cap1106_priv *priv = input_get_drvdata(idev);\r\ncap1106_set_sleep(priv, true);\r\n}\r\nstatic int cap1106_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &i2c_client->dev;\r\nstruct cap1106_priv *priv;\r\nstruct device_node *node;\r\nint i, error, irq, gain = 0;\r\nunsigned int val, rev;\r\nu32 gain32, keycodes[CAP1106_NUM_CHN];\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->regmap = devm_regmap_init_i2c(i2c_client, &cap1106_regmap_config);\r\nif (IS_ERR(priv->regmap))\r\nreturn PTR_ERR(priv->regmap);\r\nerror = regmap_read(priv->regmap, CAP1106_REG_PRODUCT_ID, &val);\r\nif (error)\r\nreturn error;\r\nif (val != CAP1106_PRODUCT_ID) {\r\ndev_err(dev, "Product ID: Got 0x%02x, expected 0x%02x\n",\r\nval, CAP1106_PRODUCT_ID);\r\nreturn -ENODEV;\r\n}\r\nerror = regmap_read(priv->regmap, CAP1106_REG_MANUFACTURER_ID, &val);\r\nif (error)\r\nreturn error;\r\nif (val != CAP1106_MANUFACTURER_ID) {\r\ndev_err(dev, "Manufacturer ID: Got 0x%02x, expected 0x%02x\n",\r\nval, CAP1106_MANUFACTURER_ID);\r\nreturn -ENODEV;\r\n}\r\nerror = regmap_read(priv->regmap, CAP1106_REG_REVISION, &rev);\r\nif (error < 0)\r\nreturn error;\r\ndev_info(dev, "CAP1106 detected, revision 0x%02x\n", rev);\r\ni2c_set_clientdata(i2c_client, priv);\r\nnode = dev->of_node;\r\nif (!of_property_read_u32(node, "microchip,sensor-gain", &gain32)) {\r\nif (is_power_of_2(gain32) && gain32 <= 8)\r\ngain = ilog2(gain32);\r\nelse\r\ndev_err(dev, "Invalid sensor-gain value %d\n", gain32);\r\n}\r\nBUILD_BUG_ON(ARRAY_SIZE(keycodes) != ARRAY_SIZE(priv->keycodes));\r\nfor (i = 0; i < ARRAY_SIZE(keycodes); i++)\r\nkeycodes[i] = KEY_A + i;\r\nof_property_read_u32_array(node, "linux,keycodes",\r\nkeycodes, ARRAY_SIZE(keycodes));\r\nfor (i = 0; i < ARRAY_SIZE(keycodes); i++)\r\npriv->keycodes[i] = keycodes[i];\r\nerror = regmap_update_bits(priv->regmap, CAP1106_REG_MAIN_CONTROL,\r\nCAP1106_REG_MAIN_CONTROL_GAIN_MASK,\r\ngain << CAP1106_REG_MAIN_CONTROL_GAIN_SHIFT);\r\nif (error)\r\nreturn error;\r\nerror = regmap_write(priv->regmap, CAP1106_REG_REPEAT_RATE, 0);\r\nif (error)\r\nreturn error;\r\npriv->idev = devm_input_allocate_device(dev);\r\nif (!priv->idev)\r\nreturn -ENOMEM;\r\npriv->idev->name = "CAP1106 capacitive touch sensor";\r\npriv->idev->id.bustype = BUS_I2C;\r\npriv->idev->evbit[0] = BIT_MASK(EV_KEY);\r\nif (of_property_read_bool(node, "autorepeat"))\r\n__set_bit(EV_REP, priv->idev->evbit);\r\nfor (i = 0; i < CAP1106_NUM_CHN; i++)\r\n__set_bit(priv->keycodes[i], priv->idev->keybit);\r\n__clear_bit(KEY_RESERVED, priv->idev->keybit);\r\npriv->idev->keycode = priv->keycodes;\r\npriv->idev->keycodesize = sizeof(priv->keycodes[0]);\r\npriv->idev->keycodemax = ARRAY_SIZE(priv->keycodes);\r\npriv->idev->id.vendor = CAP1106_MANUFACTURER_ID;\r\npriv->idev->id.product = CAP1106_PRODUCT_ID;\r\npriv->idev->id.version = rev;\r\npriv->idev->open = cap1106_input_open;\r\npriv->idev->close = cap1106_input_close;\r\ninput_set_drvdata(priv->idev, priv);\r\ncap1106_set_sleep(priv, true);\r\nerror = input_register_device(priv->idev);\r\nif (error)\r\nreturn error;\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (!irq) {\r\ndev_err(dev, "Unable to parse or map IRQ\n");\r\nreturn -ENXIO;\r\n}\r\nerror = devm_request_threaded_irq(dev, irq, NULL, cap1106_thread_func,\r\nIRQF_ONESHOT, dev_name(dev), priv);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}
