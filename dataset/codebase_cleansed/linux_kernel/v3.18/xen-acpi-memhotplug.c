static int xen_hotadd_memory(int pxm, struct acpi_memory_info *info)\r\n{\r\nint rc;\r\nstruct xen_platform_op op;\r\nop.cmd = XENPF_mem_hotadd;\r\nop.u.mem_add.spfn = info->start_addr >> PAGE_SHIFT;\r\nop.u.mem_add.epfn = (info->start_addr + info->length) >> PAGE_SHIFT;\r\nop.u.mem_add.pxm = pxm;\r\nrc = HYPERVISOR_dom0_op(&op);\r\nif (rc)\r\npr_err(PREFIX "Xen Hotplug Memory Add failed on "\r\n"0x%lx -> 0x%lx, _PXM: %d, error: %d\n",\r\n(unsigned long)info->start_addr,\r\n(unsigned long)(info->start_addr + info->length),\r\npxm, rc);\r\nreturn rc;\r\n}\r\nstatic int xen_acpi_memory_enable_device(struct acpi_memory_device *mem_device)\r\n{\r\nint pxm, result;\r\nint num_enabled = 0;\r\nstruct acpi_memory_info *info;\r\nif (!mem_device)\r\nreturn -EINVAL;\r\npxm = xen_acpi_get_pxm(mem_device->device->handle);\r\nif (pxm < 0)\r\nreturn pxm;\r\nlist_for_each_entry(info, &mem_device->res_list, list) {\r\nif (info->enabled) {\r\nnum_enabled++;\r\ncontinue;\r\n}\r\nif (!info->length)\r\ncontinue;\r\nresult = xen_hotadd_memory(pxm, info);\r\nif (result)\r\ncontinue;\r\ninfo->enabled = 1;\r\nnum_enabled++;\r\n}\r\nif (!num_enabled)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic acpi_status\r\nacpi_memory_get_resource(struct acpi_resource *resource, void *context)\r\n{\r\nstruct acpi_memory_device *mem_device = context;\r\nstruct acpi_resource_address64 address64;\r\nstruct acpi_memory_info *info, *new;\r\nacpi_status status;\r\nstatus = acpi_resource_to_address64(resource, &address64);\r\nif (ACPI_FAILURE(status) ||\r\n(address64.resource_type != ACPI_MEMORY_RANGE))\r\nreturn AE_OK;\r\nlist_for_each_entry(info, &mem_device->res_list, list) {\r\nif ((info->caching == address64.info.mem.caching) &&\r\n(info->write_protect == address64.info.mem.write_protect) &&\r\n(info->start_addr + info->length == address64.minimum)) {\r\ninfo->length += address64.address_length;\r\nreturn AE_OK;\r\n}\r\n}\r\nnew = kzalloc(sizeof(struct acpi_memory_info), GFP_KERNEL);\r\nif (!new)\r\nreturn AE_ERROR;\r\nINIT_LIST_HEAD(&new->list);\r\nnew->caching = address64.info.mem.caching;\r\nnew->write_protect = address64.info.mem.write_protect;\r\nnew->start_addr = address64.minimum;\r\nnew->length = address64.address_length;\r\nlist_add_tail(&new->list, &mem_device->res_list);\r\nreturn AE_OK;\r\n}\r\nstatic int\r\nacpi_memory_get_device_resources(struct acpi_memory_device *mem_device)\r\n{\r\nacpi_status status;\r\nstruct acpi_memory_info *info, *n;\r\nif (!list_empty(&mem_device->res_list))\r\nreturn 0;\r\nstatus = acpi_walk_resources(mem_device->device->handle,\r\nMETHOD_NAME__CRS, acpi_memory_get_resource, mem_device);\r\nif (ACPI_FAILURE(status)) {\r\nlist_for_each_entry_safe(info, n, &mem_device->res_list, list)\r\nkfree(info);\r\nINIT_LIST_HEAD(&mem_device->res_list);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_memory_get_device(acpi_handle handle,\r\nstruct acpi_memory_device **mem_device)\r\n{\r\nstruct acpi_device *device = NULL;\r\nint result = 0;\r\nacpi_scan_lock_acquire();\r\nacpi_bus_get_device(handle, &device);\r\nif (acpi_device_enumerated(device))\r\ngoto end;\r\nresult = acpi_bus_scan(handle);\r\nif (result) {\r\npr_warn(PREFIX "ACPI namespace scan failed\n");\r\nresult = -EINVAL;\r\ngoto out;\r\n}\r\ndevice = NULL;\r\nacpi_bus_get_device(handle, &device);\r\nif (!acpi_device_enumerated(device)) {\r\npr_warn(PREFIX "Missing device object\n");\r\nresult = -EINVAL;\r\ngoto out;\r\n}\r\nend:\r\n*mem_device = acpi_driver_data(device);\r\nif (!(*mem_device)) {\r\npr_err(PREFIX "driver data not found\n");\r\nresult = -ENODEV;\r\ngoto out;\r\n}\r\nout:\r\nacpi_scan_lock_release();\r\nreturn result;\r\n}\r\nstatic int acpi_memory_check_device(struct acpi_memory_device *mem_device)\r\n{\r\nunsigned long long current_status;\r\nif (ACPI_FAILURE(acpi_evaluate_integer(mem_device->device->handle,\r\n"_STA", NULL, &current_status)))\r\nreturn -ENODEV;\r\nif (!((current_status & ACPI_STA_DEVICE_PRESENT)\r\n&& (current_status & ACPI_STA_DEVICE_ENABLED)\r\n&& (current_status & ACPI_STA_DEVICE_FUNCTIONING)))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int acpi_memory_disable_device(struct acpi_memory_device *mem_device)\r\n{\r\npr_debug(PREFIX "Xen does not support memory hotremove\n");\r\nreturn -ENOSYS;\r\n}\r\nstatic void acpi_memory_device_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct acpi_memory_device *mem_device;\r\nstruct acpi_device *device;\r\nu32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;\r\nswitch (event) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"\nReceived BUS CHECK notification for device\n"));\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nif (event == ACPI_NOTIFY_DEVICE_CHECK)\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"\nReceived DEVICE CHECK notification for device\n"));\r\nif (acpi_memory_get_device(handle, &mem_device)) {\r\npr_err(PREFIX "Cannot find driver data\n");\r\nbreak;\r\n}\r\nost_code = ACPI_OST_SC_SUCCESS;\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"\nReceived EJECT REQUEST notification for device\n"));\r\nacpi_scan_lock_acquire();\r\nif (acpi_bus_get_device(handle, &device)) {\r\nacpi_scan_lock_release();\r\npr_err(PREFIX "Device doesn't exist\n");\r\nbreak;\r\n}\r\nmem_device = acpi_driver_data(device);\r\nif (!mem_device) {\r\nacpi_scan_lock_release();\r\npr_err(PREFIX "Driver Data is NULL\n");\r\nbreak;\r\n}\r\nacpi_memory_disable_device(mem_device);\r\nacpi_scan_lock_release();\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nreturn;\r\n}\r\n(void) acpi_evaluate_ost(handle, event, ost_code, NULL);\r\nreturn;\r\n}\r\nstatic int xen_acpi_memory_device_add(struct acpi_device *device)\r\n{\r\nint result;\r\nstruct acpi_memory_device *mem_device = NULL;\r\nif (!device)\r\nreturn -EINVAL;\r\nmem_device = kzalloc(sizeof(struct acpi_memory_device), GFP_KERNEL);\r\nif (!mem_device)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&mem_device->res_list);\r\nmem_device->device = device;\r\nsprintf(acpi_device_name(device), "%s", ACPI_MEMORY_DEVICE_NAME);\r\nsprintf(acpi_device_class(device), "%s", ACPI_MEMORY_DEVICE_CLASS);\r\ndevice->driver_data = mem_device;\r\nresult = acpi_memory_get_device_resources(mem_device);\r\nif (result) {\r\nkfree(mem_device);\r\nreturn result;\r\n}\r\nif (!acpi_hotmem_initialized)\r\nreturn 0;\r\nif (!acpi_memory_check_device(mem_device))\r\nresult = xen_acpi_memory_enable_device(mem_device);\r\nreturn result;\r\n}\r\nstatic int xen_acpi_memory_device_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_memory_device *mem_device = NULL;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nmem_device = acpi_driver_data(device);\r\nkfree(mem_device);\r\nreturn 0;\r\n}\r\nstatic acpi_status is_memory_device(acpi_handle handle)\r\n{\r\nchar *hardware_id;\r\nacpi_status status;\r\nstruct acpi_device_info *info;\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nif (!(info->valid & ACPI_VALID_HID)) {\r\nkfree(info);\r\nreturn AE_ERROR;\r\n}\r\nhardware_id = info->hardware_id.string;\r\nif ((hardware_id == NULL) ||\r\n(strcmp(hardware_id, ACPI_MEMORY_DEVICE_HID)))\r\nstatus = AE_ERROR;\r\nkfree(info);\r\nreturn status;\r\n}\r\nstatic acpi_status\r\nacpi_memory_register_notify_handler(acpi_handle handle,\r\nu32 level, void *ctxt, void **retv)\r\n{\r\nacpi_status status;\r\nstatus = is_memory_device(handle);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nstatus = acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,\r\nacpi_memory_device_notify, NULL);\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\nacpi_memory_deregister_notify_handler(acpi_handle handle,\r\nu32 level, void *ctxt, void **retv)\r\n{\r\nacpi_status status;\r\nstatus = is_memory_device(handle);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nstatus = acpi_remove_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nacpi_memory_device_notify);\r\nreturn AE_OK;\r\n}\r\nstatic int __init xen_acpi_memory_device_init(void)\r\n{\r\nint result;\r\nacpi_status status;\r\nif (!xen_initial_domain())\r\nreturn -ENODEV;\r\nxen_stub_memory_device_exit();\r\nresult = acpi_bus_register_driver(&xen_acpi_memory_device_driver);\r\nif (result < 0) {\r\nxen_stub_memory_device_init();\r\nreturn -ENODEV;\r\n}\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nacpi_memory_register_notify_handler,\r\nNULL, NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_warn(PREFIX "walk_namespace failed\n");\r\nacpi_bus_unregister_driver(&xen_acpi_memory_device_driver);\r\nxen_stub_memory_device_init();\r\nreturn -ENODEV;\r\n}\r\nacpi_hotmem_initialized = true;\r\nreturn 0;\r\n}\r\nstatic void __exit xen_acpi_memory_device_exit(void)\r\n{\r\nacpi_status status;\r\nif (!xen_initial_domain())\r\nreturn;\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nacpi_memory_deregister_notify_handler,\r\nNULL, NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\npr_warn(PREFIX "walk_namespace failed\n");\r\nacpi_bus_unregister_driver(&xen_acpi_memory_device_driver);\r\nxen_stub_memory_device_init();\r\nreturn;\r\n}
