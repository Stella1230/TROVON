static u8 _is_fw_read_cmd_down(struct adapter *adapt, u8 msgbox_num)\r\n{\r\nu8 read_down = false;\r\nint retry_cnts = 100;\r\nu8 valid;\r\ndo {\r\nvalid = usb_read8(adapt, REG_HMETFR) & BIT(msgbox_num);\r\nif (0 == valid)\r\nread_down = true;\r\n} while ((!read_down) && (retry_cnts--));\r\nreturn read_down;\r\n}\r\nstatic s32 FillH2CCmd_88E(struct adapter *adapt, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)\r\n{\r\nu8 bcmd_down = false;\r\ns32 retry_cnts = 100;\r\nu8 h2c_box_num;\r\nu32 msgbox_addr;\r\nu32 msgbox_ex_addr;\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nu8 cmd_idx, ext_cmd_len;\r\nu32 h2c_cmd = 0;\r\nu32 h2c_cmd_ex = 0;\r\ns32 ret = _FAIL;\r\nif (!adapt->bFWReady) {\r\nDBG_88E("FillH2CCmd_88E(): return H2C cmd because fw is not ready\n");\r\nreturn ret;\r\n}\r\nif (!pCmdBuffer)\r\ngoto exit;\r\nif (CmdLen > RTL88E_MAX_CMD_LEN)\r\ngoto exit;\r\nif (adapt->bSurpriseRemoved)\r\ngoto exit;\r\ndo {\r\nh2c_box_num = haldata->LastHMEBoxNum;\r\nif (!_is_fw_read_cmd_down(adapt, h2c_box_num)) {\r\nDBG_88E(" fw read cmd failed...\n");\r\ngoto exit;\r\n}\r\n*(u8 *)(&h2c_cmd) = ElementID;\r\nif (CmdLen <= 3) {\r\nmemcpy((u8 *)(&h2c_cmd)+1, pCmdBuffer, CmdLen);\r\n} else {\r\nmemcpy((u8 *)(&h2c_cmd)+1, pCmdBuffer, 3);\r\next_cmd_len = CmdLen-3;\r\nmemcpy((u8 *)(&h2c_cmd_ex), pCmdBuffer+3, ext_cmd_len);\r\nmsgbox_ex_addr = REG_HMEBOX_EXT_0 + (h2c_box_num * RTL88E_EX_MESSAGE_BOX_SIZE);\r\nfor (cmd_idx = 0; cmd_idx < ext_cmd_len; cmd_idx++) {\r\nusb_write8(adapt, msgbox_ex_addr+cmd_idx, *((u8 *)(&h2c_cmd_ex)+cmd_idx));\r\n}\r\n}\r\nmsgbox_addr = REG_HMEBOX_0 + (h2c_box_num * RTL88E_MESSAGE_BOX_SIZE);\r\nfor (cmd_idx = 0; cmd_idx < RTL88E_MESSAGE_BOX_SIZE; cmd_idx++) {\r\nusb_write8(adapt, msgbox_addr+cmd_idx, *((u8 *)(&h2c_cmd)+cmd_idx));\r\n}\r\nbcmd_down = true;\r\nhaldata->LastHMEBoxNum = (h2c_box_num+1) % RTL88E_MAX_H2C_BOX_NUMS;\r\n} while ((!bcmd_down) && (retry_cnts--));\r\nret = _SUCCESS;\r\nexit:\r\nreturn ret;\r\n}\r\nu8 rtl8188e_set_rssi_cmd(struct adapter *adapt, u8 *param)\r\n{\r\nu8 res = _SUCCESS;\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nif (haldata->fw_ractrl) {\r\n;\r\n} else {\r\nDBG_88E("==>%s fw dont support RA\n", __func__);\r\nres = _FAIL;\r\n}\r\nreturn res;\r\n}\r\nu8 rtl8188e_set_raid_cmd(struct adapter *adapt, u32 mask)\r\n{\r\nu8 buf[3];\r\nu8 res = _SUCCESS;\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nif (haldata->fw_ractrl) {\r\n__le32 lmask;\r\nmemset(buf, 0, 3);\r\nlmask = cpu_to_le32(mask);\r\nmemcpy(buf, &lmask, 3);\r\nFillH2CCmd_88E(adapt, H2C_DM_MACID_CFG, 3, buf);\r\n} else {\r\nDBG_88E("==>%s fw dont support RA\n", __func__);\r\nres = _FAIL;\r\n}\r\nreturn res;\r\n}\r\nvoid rtl8188e_Add_RateATid(struct adapter *pAdapter, u32 bitmap, u8 arg, u8 rssi_level)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(pAdapter);\r\nu8 macid, init_rate, raid, shortGIrate = false;\r\nmacid = arg&0x1f;\r\nraid = (bitmap>>28) & 0x0f;\r\nbitmap &= 0x0fffffff;\r\nif (rssi_level != DM_RATR_STA_INIT)\r\nbitmap = ODM_Get_Rate_Bitmap(&haldata->odmpriv, macid, bitmap, rssi_level);\r\nbitmap |= ((raid<<28)&0xf0000000);\r\ninit_rate = get_highest_rate_idx(bitmap&0x0fffffff)&0x3f;\r\nshortGIrate = (arg&BIT(5)) ? true : false;\r\nif (shortGIrate)\r\ninit_rate |= BIT(6);\r\nraid = (bitmap>>28) & 0x0f;\r\nbitmap &= 0x0fffffff;\r\nDBG_88E("%s=> mac_id:%d, raid:%d, ra_bitmap=0x%x, shortGIrate=0x%02x\n",\r\n__func__, macid, raid, bitmap, shortGIrate);\r\nODM_RA_UpdateRateInfo_8188E(&(haldata->odmpriv), macid, raid, bitmap, shortGIrate);\r\n}\r\nvoid rtl8188e_set_FwPwrMode_cmd(struct adapter *adapt, u8 Mode)\r\n{\r\nstruct setpwrmode_parm H2CSetPwrMode;\r\nstruct pwrctrl_priv *pwrpriv = &adapt->pwrctrlpriv;\r\nu8 RLBM = 0;\r\nDBG_88E("%s: Mode=%d SmartPS=%d UAPSD=%d\n", __func__,\r\nMode, pwrpriv->smart_ps, adapt->registrypriv.uapsd_enable);\r\nswitch (Mode) {\r\ncase PS_MODE_ACTIVE:\r\nH2CSetPwrMode.Mode = 0;\r\nbreak;\r\ncase PS_MODE_MIN:\r\nH2CSetPwrMode.Mode = 1;\r\nbreak;\r\ncase PS_MODE_MAX:\r\nRLBM = 1;\r\nH2CSetPwrMode.Mode = 1;\r\nbreak;\r\ncase PS_MODE_DTIM:\r\nRLBM = 2;\r\nH2CSetPwrMode.Mode = 1;\r\nbreak;\r\ncase PS_MODE_UAPSD_WMM:\r\nH2CSetPwrMode.Mode = 2;\r\nbreak;\r\ndefault:\r\nH2CSetPwrMode.Mode = 0;\r\nbreak;\r\n}\r\nH2CSetPwrMode.SmartPS_RLBM = (((pwrpriv->smart_ps<<4)&0xf0) | (RLBM & 0x0f));\r\nH2CSetPwrMode.AwakeInterval = 1;\r\nH2CSetPwrMode.bAllQueueUAPSD = adapt->registrypriv.uapsd_enable;\r\nif (Mode > 0)\r\nH2CSetPwrMode.PwrState = 0x00;\r\nelse\r\nH2CSetPwrMode.PwrState = 0x0C;\r\nFillH2CCmd_88E(adapt, H2C_PS_PWR_MODE, sizeof(H2CSetPwrMode), (u8 *)&H2CSetPwrMode);\r\n}\r\nvoid rtl8188e_set_FwMediaStatus_cmd(struct adapter *adapt, __le16 mstatus_rpt)\r\n{\r\nu8 opmode, macid;\r\nu16 mst_rpt = le16_to_cpu(mstatus_rpt);\r\nopmode = (u8) mst_rpt;\r\nmacid = (u8)(mst_rpt >> 8);\r\nDBG_88E("### %s: MStatus=%x MACID=%d\n", __func__, opmode, macid);\r\nFillH2CCmd_88E(adapt, H2C_COM_MEDIA_STATUS_RPT, sizeof(mst_rpt), (u8 *)&mst_rpt);\r\n}\r\nstatic void ConstructBeacon(struct adapter *adapt, u8 *pframe, u32 *pLength)\r\n{\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nu32 rate_len, pktlen;\r\nstruct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nu8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);\r\nSetSeqNum(pwlanhdr, 0);\r\nSetFrameSubType(pframe, WIFI_BEACON);\r\npframe += sizeof(struct rtw_ieee80211_hdr_3addr);\r\npktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\npframe += 8;\r\npktlen += 8;\r\nmemcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);\r\npframe += 2;\r\npktlen += 2;\r\nmemcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);\r\npframe += 2;\r\npktlen += 2;\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\r\npktlen += cur_network->IELength - sizeof(struct ndis_802_11_fixed_ie);\r\nmemcpy(pframe, cur_network->IEs+sizeof(struct ndis_802_11_fixed_ie), pktlen);\r\ngoto _ConstructBeacon;\r\n}\r\npframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pktlen);\r\nrate_len = rtw_get_rateset_len(cur_network->SupportedRates);\r\npframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8) ? 8 : rate_len), cur_network->SupportedRates, &pktlen);\r\npframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {\r\nu32 ATIMWindow;\r\nATIMWindow = 0;\r\npframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);\r\n}\r\nif (rate_len > 8)\r\npframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);\r\n_ConstructBeacon:\r\nif ((pktlen + TXDESC_SIZE) > 512) {\r\nDBG_88E("beacon frame too large\n");\r\nreturn;\r\n}\r\n*pLength = pktlen;\r\n}\r\nstatic void ConstructPSPoll(struct adapter *adapt, u8 *pframe, u32 *pLength)\r\n{\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\nstruct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\n__le16 *fctrl;\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nSetPwrMgt(fctrl);\r\nSetFrameSubType(pframe, WIFI_PSPOLL);\r\nSetDuration(pframe, (pmlmeinfo->aid | 0xc000));\r\nmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);\r\n*pLength = 16;\r\n}\r\nstatic void ConstructNullFunctionData(struct adapter *adapt, u8 *pframe,\r\nu32 *pLength,\r\nu8 *StaAddr,\r\nu8 bQoS,\r\nu8 AC,\r\nu8 bEosp,\r\nu8 bForcePowerSave)\r\n{\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nu32 pktlen;\r\nstruct mlme_priv *pmlmepriv = &adapt->mlmepriv;\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nstruct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nfctrl = &pwlanhdr->frame_ctl;\r\n*(fctrl) = 0;\r\nif (bForcePowerSave)\r\nSetPwrMgt(fctrl);\r\nswitch (cur_network->network.InfrastructureMode) {\r\ncase Ndis802_11Infrastructure:\r\nSetToDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, StaAddr, ETH_ALEN);\r\nbreak;\r\ncase Ndis802_11APMode:\r\nSetFrDs(fctrl);\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, myid(&(adapt->eeprompriv)), ETH_ALEN);\r\nbreak;\r\ncase Ndis802_11IBSS:\r\ndefault:\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);\r\nbreak;\r\n}\r\nSetSeqNum(pwlanhdr, 0);\r\nif (bQoS) {\r\nstruct rtw_ieee80211_hdr_3addr_qos *pwlanqoshdr;\r\nSetFrameSubType(pframe, WIFI_QOS_DATA_NULL);\r\npwlanqoshdr = (struct rtw_ieee80211_hdr_3addr_qos *)pframe;\r\nSetPriority(&pwlanqoshdr->qc, AC);\r\nSetEOSP(&pwlanqoshdr->qc, bEosp);\r\npktlen = sizeof(struct rtw_ieee80211_hdr_3addr_qos);\r\n} else {\r\nSetFrameSubType(pframe, WIFI_DATA_NULL);\r\npktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\n}\r\n*pLength = pktlen;\r\n}\r\nstatic void ConstructProbeRsp(struct adapter *adapt, u8 *pframe, u32 *pLength, u8 *StaAddr, bool bHideSSID)\r\n{\r\nstruct rtw_ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nu8 *mac, *bssid;\r\nu32 pktlen;\r\nstruct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\npwlanhdr = (struct rtw_ieee80211_hdr *)pframe;\r\nmac = myid(&(adapt->eeprompriv));\r\nbssid = cur_network->MacAddress;\r\nfctrl = &(pwlanhdr->frame_ctl);\r\n*(fctrl) = 0;\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, mac, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, bssid, ETH_ALEN);\r\nSetSeqNum(pwlanhdr, 0);\r\nSetFrameSubType(fctrl, WIFI_PROBERSP);\r\npktlen = sizeof(struct rtw_ieee80211_hdr_3addr);\r\npframe += pktlen;\r\nif (cur_network->IELength > MAX_IE_SZ)\r\nreturn;\r\nmemcpy(pframe, cur_network->IEs, cur_network->IELength);\r\npframe += cur_network->IELength;\r\npktlen += cur_network->IELength;\r\n*pLength = pktlen;\r\n}\r\nstatic void SetFwRsvdPagePkt(struct adapter *adapt, bool bDLFinished)\r\n{\r\nstruct hal_data_8188e *haldata;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nstruct xmit_priv *pxmitpriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nu32 BeaconLength = 0, ProbeRspLength = 0, PSPollLength;\r\nu32 NullDataLength, QosNullLength;\r\nu8 *ReservedPagePacket;\r\nu8 PageNum, PageNeed, TxDescLen;\r\nu16 BufIndex;\r\nu32 TotalPacketLen;\r\nstruct rsvdpage_loc RsvdPageLoc;\r\nDBG_88E("%s\n", __func__);\r\nReservedPagePacket = kzalloc(1000, GFP_KERNEL);\r\nif (ReservedPagePacket == NULL) {\r\nDBG_88E("%s: alloc ReservedPagePacket fail!\n", __func__);\r\nreturn;\r\n}\r\nhaldata = GET_HAL_DATA(adapt);\r\npxmitpriv = &adapt->xmitpriv;\r\npmlmeext = &adapt->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\nTxDescLen = TXDESC_SIZE;\r\nPageNum = 0;\r\nBufIndex = TXDESC_OFFSET;\r\nConstructBeacon(adapt, &ReservedPagePacket[BufIndex], &BeaconLength);\r\nPageNeed = (u8)PageNum_128(TxDescLen + BeaconLength);\r\nif (PageNeed == 1)\r\nPageNeed += 1;\r\nPageNum += PageNeed;\r\nhaldata->FwRsvdPageStartOffset = PageNum;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocPsPoll = PageNum;\r\nConstructPSPoll(adapt, &ReservedPagePacket[BufIndex], &PSPollLength);\r\nrtl8188e_fill_fake_txdesc(adapt, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, true, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + PSPollLength);\r\nPageNum += PageNeed;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocNullData = PageNum;\r\nConstructNullFunctionData(adapt, &ReservedPagePacket[BufIndex], &NullDataLength, get_my_bssid(&pmlmeinfo->network), false, 0, 0, false);\r\nrtl8188e_fill_fake_txdesc(adapt, &ReservedPagePacket[BufIndex-TxDescLen], NullDataLength, false, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + NullDataLength);\r\nPageNum += PageNeed;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocProbeRsp = PageNum;\r\nConstructProbeRsp(adapt, &ReservedPagePacket[BufIndex], &ProbeRspLength, get_my_bssid(&pmlmeinfo->network), false);\r\nrtl8188e_fill_fake_txdesc(adapt, &ReservedPagePacket[BufIndex-TxDescLen], ProbeRspLength, false, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + ProbeRspLength);\r\nPageNum += PageNeed;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocQosNull = PageNum;\r\nConstructNullFunctionData(adapt, &ReservedPagePacket[BufIndex],\r\n&QosNullLength, get_my_bssid(&pmlmeinfo->network), true, 0, 0, false);\r\nrtl8188e_fill_fake_txdesc(adapt, &ReservedPagePacket[BufIndex-TxDescLen], QosNullLength, false, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + QosNullLength);\r\nPageNum += PageNeed;\r\nTotalPacketLen = BufIndex + QosNullLength;\r\npmgntframe = alloc_mgtxmitframe(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto exit;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(adapt, pattrib);\r\npattrib->qsel = 0x10;\r\npattrib->last_txcmdsz = TotalPacketLen - TXDESC_OFFSET;\r\npattrib->pktlen = pattrib->last_txcmdsz;\r\nmemcpy(pmgntframe->buf_addr, ReservedPagePacket, TotalPacketLen);\r\nrtw_hal_mgnt_xmit(adapt, pmgntframe);\r\nDBG_88E("%s: Set RSVD page location to Fw\n", __func__);\r\nFillH2CCmd_88E(adapt, H2C_COM_RSVD_PAGE, sizeof(RsvdPageLoc), (u8 *)&RsvdPageLoc);\r\nexit:\r\nkfree(ReservedPagePacket);\r\n}\r\nvoid rtl8188e_set_FwJoinBssReport_cmd(struct adapter *adapt, u8 mstatus)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nstruct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nbool bSendBeacon = false;\r\nbool bcn_valid = false;\r\nu8 DLBcnCount = 0;\r\nu32 poll = 0;\r\nDBG_88E("%s mstatus(%x)\n", __func__, mstatus);\r\nif (mstatus == 1) {\r\nusb_write16(adapt, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));\r\nhaldata->RegCR_1 |= BIT0;\r\nusb_write8(adapt, REG_CR+1, haldata->RegCR_1);\r\nusb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL)&(~BIT(3)));\r\nusb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL)|BIT(4));\r\nif (haldata->RegFwHwTxQCtrl&BIT6) {\r\nDBG_88E("HalDownloadRSVDPage(): There is an Adapter is sending beacon.\n");\r\nbSendBeacon = true;\r\n}\r\nusb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata->RegFwHwTxQCtrl&(~BIT6)));\r\nhaldata->RegFwHwTxQCtrl &= (~BIT6);\r\nrtw_hal_set_hwreg(adapt, HW_VAR_BCN_VALID, NULL);\r\nDLBcnCount = 0;\r\npoll = 0;\r\ndo {\r\nSetFwRsvdPagePkt(adapt, false);\r\nDLBcnCount++;\r\ndo {\r\nyield();\r\nrtw_hal_get_hwreg(adapt, HW_VAR_BCN_VALID, (u8 *)(&bcn_valid));\r\npoll++;\r\n} while (!bcn_valid && (poll%10) != 0 && !adapt->bSurpriseRemoved && !adapt->bDriverStopped);\r\n} while (!bcn_valid && DLBcnCount <= 100 && !adapt->bSurpriseRemoved && !adapt->bDriverStopped);\r\nif (adapt->bSurpriseRemoved || adapt->bDriverStopped)\r\n;\r\nelse if (!bcn_valid)\r\nDBG_88E("%s: 1 Download RSVD page failed! DLBcnCount:%u, poll:%u\n", __func__, DLBcnCount, poll);\r\nelse\r\nDBG_88E("%s: 1 Download RSVD success! DLBcnCount:%u, poll:%u\n", __func__, DLBcnCount, poll);\r\nusb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL)|BIT(3));\r\nusb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL)&(~BIT(4)));\r\nif (bSendBeacon) {\r\nusb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata->RegFwHwTxQCtrl|BIT6));\r\nhaldata->RegFwHwTxQCtrl |= BIT6;\r\n}\r\nif (bcn_valid) {\r\nrtw_hal_set_hwreg(adapt, HW_VAR_BCN_VALID, NULL);\r\nDBG_88E("Set RSVD page location to Fw.\n");\r\n}\r\nhaldata->RegCR_1 &= (~BIT0);\r\nusb_write8(adapt, REG_CR+1, haldata->RegCR_1);\r\n}\r\n}
