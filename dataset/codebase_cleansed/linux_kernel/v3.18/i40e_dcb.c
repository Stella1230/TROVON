i40e_status i40e_get_dcbx_status(struct i40e_hw *hw, u16 *status)\r\n{\r\nu32 reg;\r\nif (!status)\r\nreturn I40E_ERR_PARAM;\r\nreg = rd32(hw, I40E_PRTDCB_GENS);\r\n*status = (u16)((reg & I40E_PRTDCB_GENS_DCBX_STATUS_MASK) >>\r\nI40E_PRTDCB_GENS_DCBX_STATUS_SHIFT);\r\nreturn 0;\r\n}\r\nstatic void i40e_parse_ieee_etscfg_tlv(struct i40e_lldp_org_tlv *tlv,\r\nstruct i40e_dcbx_config *dcbcfg)\r\n{\r\nstruct i40e_ieee_ets_config *etscfg;\r\nu8 *buf = tlv->tlvinfo;\r\nu16 offset = 0;\r\nu8 priority;\r\nint i;\r\netscfg = &dcbcfg->etscfg;\r\netscfg->willing = (u8)((buf[offset] & I40E_IEEE_ETS_WILLING_MASK) >>\r\nI40E_IEEE_ETS_WILLING_SHIFT);\r\netscfg->cbs = (u8)((buf[offset] & I40E_IEEE_ETS_CBS_MASK) >>\r\nI40E_IEEE_ETS_CBS_SHIFT);\r\netscfg->maxtcs = (u8)((buf[offset] & I40E_IEEE_ETS_MAXTC_MASK) >>\r\nI40E_IEEE_ETS_MAXTC_SHIFT);\r\noffset++;\r\nfor (i = 0; i < 4; i++) {\r\npriority = (u8)((buf[offset] & I40E_IEEE_ETS_PRIO_1_MASK) >>\r\nI40E_IEEE_ETS_PRIO_1_SHIFT);\r\netscfg->prioritytable[i * 2] = priority;\r\npriority = (u8)((buf[offset] & I40E_IEEE_ETS_PRIO_0_MASK) >>\r\nI40E_IEEE_ETS_PRIO_0_SHIFT);\r\netscfg->prioritytable[i * 2 + 1] = priority;\r\noffset++;\r\n}\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\r\netscfg->tcbwtable[i] = buf[offset++];\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\r\netscfg->tsatable[i] = buf[offset++];\r\n}\r\nstatic void i40e_parse_ieee_etsrec_tlv(struct i40e_lldp_org_tlv *tlv,\r\nstruct i40e_dcbx_config *dcbcfg)\r\n{\r\nu8 *buf = tlv->tlvinfo;\r\nu16 offset = 0;\r\nu8 priority;\r\nint i;\r\noffset++;\r\nfor (i = 0; i < 4; i++) {\r\npriority = (u8)((buf[offset] & I40E_IEEE_ETS_PRIO_1_MASK) >>\r\nI40E_IEEE_ETS_PRIO_1_SHIFT);\r\ndcbcfg->etsrec.prioritytable[i*2] = priority;\r\npriority = (u8)((buf[offset] & I40E_IEEE_ETS_PRIO_0_MASK) >>\r\nI40E_IEEE_ETS_PRIO_0_SHIFT);\r\ndcbcfg->etsrec.prioritytable[i*2 + 1] = priority;\r\noffset++;\r\n}\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\r\ndcbcfg->etsrec.tcbwtable[i] = buf[offset++];\r\nfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\r\ndcbcfg->etsrec.tsatable[i] = buf[offset++];\r\n}\r\nstatic void i40e_parse_ieee_pfccfg_tlv(struct i40e_lldp_org_tlv *tlv,\r\nstruct i40e_dcbx_config *dcbcfg)\r\n{\r\nu8 *buf = tlv->tlvinfo;\r\ndcbcfg->pfc.willing = (u8)((buf[0] & I40E_IEEE_PFC_WILLING_MASK) >>\r\nI40E_IEEE_PFC_WILLING_SHIFT);\r\ndcbcfg->pfc.mbc = (u8)((buf[0] & I40E_IEEE_PFC_MBC_MASK) >>\r\nI40E_IEEE_PFC_MBC_SHIFT);\r\ndcbcfg->pfc.pfccap = (u8)((buf[0] & I40E_IEEE_PFC_CAP_MASK) >>\r\nI40E_IEEE_PFC_CAP_SHIFT);\r\ndcbcfg->pfc.pfcenable = buf[1];\r\n}\r\nstatic void i40e_parse_ieee_app_tlv(struct i40e_lldp_org_tlv *tlv,\r\nstruct i40e_dcbx_config *dcbcfg)\r\n{\r\nu16 typelength;\r\nu16 offset = 0;\r\nu16 length;\r\nint i = 0;\r\nu8 *buf;\r\ntypelength = ntohs(tlv->typelength);\r\nlength = (u16)((typelength & I40E_LLDP_TLV_LEN_MASK) >>\r\nI40E_LLDP_TLV_LEN_SHIFT);\r\nbuf = tlv->tlvinfo;\r\nlength -= (sizeof(tlv->ouisubtype) + 1);\r\noffset++;\r\nwhile (offset < length) {\r\ndcbcfg->app[i].priority = (u8)((buf[offset] &\r\nI40E_IEEE_APP_PRIO_MASK) >>\r\nI40E_IEEE_APP_PRIO_SHIFT);\r\ndcbcfg->app[i].selector = (u8)((buf[offset] &\r\nI40E_IEEE_APP_SEL_MASK) >>\r\nI40E_IEEE_APP_SEL_SHIFT);\r\ndcbcfg->app[i].protocolid = (buf[offset + 1] << 0x8) |\r\nbuf[offset + 2];\r\noffset += 3;\r\ni++;\r\nif (i >= I40E_DCBX_MAX_APPS)\r\nbreak;\r\n}\r\ndcbcfg->numapps = i;\r\n}\r\nstatic void i40e_parse_ieee_tlv(struct i40e_lldp_org_tlv *tlv,\r\nstruct i40e_dcbx_config *dcbcfg)\r\n{\r\nu32 ouisubtype;\r\nu8 subtype;\r\nouisubtype = ntohl(tlv->ouisubtype);\r\nsubtype = (u8)((ouisubtype & I40E_LLDP_TLV_SUBTYPE_MASK) >>\r\nI40E_LLDP_TLV_SUBTYPE_SHIFT);\r\nswitch (subtype) {\r\ncase I40E_IEEE_SUBTYPE_ETS_CFG:\r\ni40e_parse_ieee_etscfg_tlv(tlv, dcbcfg);\r\nbreak;\r\ncase I40E_IEEE_SUBTYPE_ETS_REC:\r\ni40e_parse_ieee_etsrec_tlv(tlv, dcbcfg);\r\nbreak;\r\ncase I40E_IEEE_SUBTYPE_PFC_CFG:\r\ni40e_parse_ieee_pfccfg_tlv(tlv, dcbcfg);\r\nbreak;\r\ncase I40E_IEEE_SUBTYPE_APP_PRI:\r\ni40e_parse_ieee_app_tlv(tlv, dcbcfg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void i40e_parse_org_tlv(struct i40e_lldp_org_tlv *tlv,\r\nstruct i40e_dcbx_config *dcbcfg)\r\n{\r\nu32 ouisubtype;\r\nu32 oui;\r\nouisubtype = ntohl(tlv->ouisubtype);\r\noui = (u32)((ouisubtype & I40E_LLDP_TLV_OUI_MASK) >>\r\nI40E_LLDP_TLV_OUI_SHIFT);\r\nswitch (oui) {\r\ncase I40E_IEEE_8021QAZ_OUI:\r\ni40e_parse_ieee_tlv(tlv, dcbcfg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ni40e_status i40e_lldp_to_dcb_config(u8 *lldpmib,\r\nstruct i40e_dcbx_config *dcbcfg)\r\n{\r\ni40e_status ret = 0;\r\nstruct i40e_lldp_org_tlv *tlv;\r\nu16 type;\r\nu16 length;\r\nu16 typelength;\r\nu16 offset = 0;\r\nif (!lldpmib || !dcbcfg)\r\nreturn I40E_ERR_PARAM;\r\nlldpmib += ETH_HLEN;\r\ntlv = (struct i40e_lldp_org_tlv *)lldpmib;\r\nwhile (1) {\r\ntypelength = ntohs(tlv->typelength);\r\ntype = (u16)((typelength & I40E_LLDP_TLV_TYPE_MASK) >>\r\nI40E_LLDP_TLV_TYPE_SHIFT);\r\nlength = (u16)((typelength & I40E_LLDP_TLV_LEN_MASK) >>\r\nI40E_LLDP_TLV_LEN_SHIFT);\r\noffset += sizeof(typelength) + length;\r\nif ((type == I40E_TLV_TYPE_END) || (offset > I40E_LLDPDU_SIZE))\r\nbreak;\r\nswitch (type) {\r\ncase I40E_TLV_TYPE_ORG:\r\ni40e_parse_org_tlv(tlv, dcbcfg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntlv = (struct i40e_lldp_org_tlv *)((char *)tlv +\r\nsizeof(tlv->typelength) +\r\nlength);\r\n}\r\nreturn ret;\r\n}\r\ni40e_status i40e_aq_get_dcb_config(struct i40e_hw *hw, u8 mib_type,\r\nu8 bridgetype,\r\nstruct i40e_dcbx_config *dcbcfg)\r\n{\r\ni40e_status ret = 0;\r\nstruct i40e_virt_mem mem;\r\nu8 *lldpmib;\r\nret = i40e_allocate_virt_mem(hw, &mem, I40E_LLDPDU_SIZE);\r\nif (ret)\r\nreturn ret;\r\nlldpmib = (u8 *)mem.va;\r\nret = i40e_aq_get_lldp_mib(hw, bridgetype, mib_type,\r\n(void *)lldpmib, I40E_LLDPDU_SIZE,\r\nNULL, NULL, NULL);\r\nif (ret)\r\ngoto free_mem;\r\nret = i40e_lldp_to_dcb_config(lldpmib, dcbcfg);\r\nfree_mem:\r\ni40e_free_virt_mem(hw, &mem);\r\nreturn ret;\r\n}\r\ni40e_status i40e_get_dcb_config(struct i40e_hw *hw)\r\n{\r\ni40e_status ret = 0;\r\nret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_LOCAL, 0,\r\n&hw->local_dcbx_config);\r\nif (ret)\r\ngoto out;\r\nret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_REMOTE,\r\nI40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE,\r\n&hw->remote_dcbx_config);\r\nout:\r\nreturn ret;\r\n}\r\ni40e_status i40e_init_dcb(struct i40e_hw *hw)\r\n{\r\ni40e_status ret = 0;\r\nif (!hw->func_caps.dcb)\r\nreturn ret;\r\nret = i40e_get_dcbx_status(hw, &hw->dcbx_status);\r\nif (ret)\r\nreturn ret;\r\nswitch (hw->dcbx_status) {\r\ncase I40E_DCBX_STATUS_DONE:\r\ncase I40E_DCBX_STATUS_IN_PROGRESS:\r\nret = i40e_get_dcb_config(hw);\r\nbreak;\r\ncase I40E_DCBX_STATUS_DISABLED:\r\nreturn ret;\r\ncase I40E_DCBX_STATUS_NOT_STARTED:\r\ncase I40E_DCBX_STATUS_MULTIPLE_PEERS:\r\ndefault:\r\nbreak;\r\n}\r\nret = i40e_aq_cfg_lldp_mib_change_event(hw, true, NULL);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}
