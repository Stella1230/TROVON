static void dump_ipv6_packet(struct nf_log_buf *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb, unsigned int ip6hoff,\r\nint recurse)\r\n{\r\nu_int8_t currenthdr;\r\nint fragment;\r\nstruct ipv6hdr _ip6h;\r\nconst struct ipv6hdr *ih;\r\nunsigned int ptr;\r\nunsigned int hdrlen = 0;\r\nunsigned int logflags;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nelse\r\nlogflags = NF_LOG_MASK;\r\nih = skb_header_pointer(skb, ip6hoff, sizeof(_ip6h), &_ip6h);\r\nif (ih == NULL) {\r\nnf_log_buf_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nnf_log_buf_add(m, "SRC=%pI6 DST=%pI6 ", &ih->saddr, &ih->daddr);\r\nnf_log_buf_add(m, "LEN=%Zu TC=%u HOPLIMIT=%u FLOWLBL=%u ",\r\nntohs(ih->payload_len) + sizeof(struct ipv6hdr),\r\n(ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,\r\nih->hop_limit,\r\n(ntohl(*(__be32 *)ih) & 0x000fffff));\r\nfragment = 0;\r\nptr = ip6hoff + sizeof(struct ipv6hdr);\r\ncurrenthdr = ih->nexthdr;\r\nwhile (currenthdr != NEXTHDR_NONE && ip6t_ext_hdr(currenthdr)) {\r\nstruct ipv6_opt_hdr _hdr;\r\nconst struct ipv6_opt_hdr *hp;\r\nhp = skb_header_pointer(skb, ptr, sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\nnf_log_buf_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nif (logflags & XT_LOG_IPOPT)\r\nnf_log_buf_add(m, "OPT ( ");\r\nswitch (currenthdr) {\r\ncase IPPROTO_FRAGMENT: {\r\nstruct frag_hdr _fhdr;\r\nconst struct frag_hdr *fh;\r\nnf_log_buf_add(m, "FRAG:");\r\nfh = skb_header_pointer(skb, ptr, sizeof(_fhdr),\r\n&_fhdr);\r\nif (fh == NULL) {\r\nnf_log_buf_add(m, "TRUNCATED ");\r\nreturn;\r\n}\r\nnf_log_buf_add(m, "%u ", ntohs(fh->frag_off) & 0xFFF8);\r\nif (fh->frag_off & htons(0x0001))\r\nnf_log_buf_add(m, "INCOMPLETE ");\r\nnf_log_buf_add(m, "ID:%08x ",\r\nntohl(fh->identification));\r\nif (ntohs(fh->frag_off) & 0xFFF8)\r\nfragment = 1;\r\nhdrlen = 8;\r\nbreak;\r\n}\r\ncase IPPROTO_DSTOPTS:\r\ncase IPPROTO_ROUTING:\r\ncase IPPROTO_HOPOPTS:\r\nif (fragment) {\r\nif (logflags & XT_LOG_IPOPT)\r\nnf_log_buf_add(m, ")");\r\nreturn;\r\n}\r\nhdrlen = ipv6_optlen(hp);\r\nbreak;\r\ncase IPPROTO_AH:\r\nif (logflags & XT_LOG_IPOPT) {\r\nstruct ip_auth_hdr _ahdr;\r\nconst struct ip_auth_hdr *ah;\r\nnf_log_buf_add(m, "AH ");\r\nif (fragment) {\r\nnf_log_buf_add(m, ")");\r\nreturn;\r\n}\r\nah = skb_header_pointer(skb, ptr, sizeof(_ahdr),\r\n&_ahdr);\r\nif (ah == NULL) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] )",\r\nskb->len - ptr);\r\nreturn;\r\n}\r\nnf_log_buf_add(m, "SPI=0x%x ", ntohl(ah->spi));\r\n}\r\nhdrlen = (hp->hdrlen+2)<<2;\r\nbreak;\r\ncase IPPROTO_ESP:\r\nif (logflags & XT_LOG_IPOPT) {\r\nstruct ip_esp_hdr _esph;\r\nconst struct ip_esp_hdr *eh;\r\nnf_log_buf_add(m, "ESP ");\r\nif (fragment) {\r\nnf_log_buf_add(m, ")");\r\nreturn;\r\n}\r\neh = skb_header_pointer(skb, ptr, sizeof(_esph),\r\n&_esph);\r\nif (eh == NULL) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] )",\r\nskb->len - ptr);\r\nreturn;\r\n}\r\nnf_log_buf_add(m, "SPI=0x%x )",\r\nntohl(eh->spi));\r\n}\r\nreturn;\r\ndefault:\r\nnf_log_buf_add(m, "Unknown Ext Hdr %u", currenthdr);\r\nreturn;\r\n}\r\nif (logflags & XT_LOG_IPOPT)\r\nnf_log_buf_add(m, ") ");\r\ncurrenthdr = hp->nexthdr;\r\nptr += hdrlen;\r\n}\r\nswitch (currenthdr) {\r\ncase IPPROTO_TCP:\r\nif (nf_log_dump_tcp_header(m, skb, currenthdr, fragment,\r\nptr, logflags))\r\nreturn;\r\nbreak;\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\nif (nf_log_dump_udp_header(m, skb, currenthdr, fragment, ptr))\r\nreturn;\r\nbreak;\r\ncase IPPROTO_ICMPV6: {\r\nstruct icmp6hdr _icmp6h;\r\nconst struct icmp6hdr *ic;\r\nnf_log_buf_add(m, "PROTO=ICMPv6 ");\r\nif (fragment)\r\nbreak;\r\nic = skb_header_pointer(skb, ptr, sizeof(_icmp6h), &_icmp6h);\r\nif (ic == NULL) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - ptr);\r\nreturn;\r\n}\r\nnf_log_buf_add(m, "TYPE=%u CODE=%u ",\r\nic->icmp6_type, ic->icmp6_code);\r\nswitch (ic->icmp6_type) {\r\ncase ICMPV6_ECHO_REQUEST:\r\ncase ICMPV6_ECHO_REPLY:\r\nnf_log_buf_add(m, "ID=%u SEQ=%u ",\r\nntohs(ic->icmp6_identifier),\r\nntohs(ic->icmp6_sequence));\r\nbreak;\r\ncase ICMPV6_MGM_QUERY:\r\ncase ICMPV6_MGM_REPORT:\r\ncase ICMPV6_MGM_REDUCTION:\r\nbreak;\r\ncase ICMPV6_PARAMPROB:\r\nnf_log_buf_add(m, "POINTER=%08x ",\r\nntohl(ic->icmp6_pointer));\r\ncase ICMPV6_DEST_UNREACH:\r\ncase ICMPV6_PKT_TOOBIG:\r\ncase ICMPV6_TIME_EXCEED:\r\nif (recurse) {\r\nnf_log_buf_add(m, "[");\r\ndump_ipv6_packet(m, info, skb,\r\nptr + sizeof(_icmp6h), 0);\r\nnf_log_buf_add(m, "] ");\r\n}\r\nif (ic->icmp6_type == ICMPV6_PKT_TOOBIG) {\r\nnf_log_buf_add(m, "MTU=%u ",\r\nntohl(ic->icmp6_mtu));\r\n}\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nnf_log_buf_add(m, "PROTO=%u ", currenthdr);\r\n}\r\nif ((logflags & XT_LOG_UID) && recurse)\r\nnf_log_dump_sk_uid_gid(m, skb->sk);\r\nif (recurse && skb->mark)\r\nnf_log_buf_add(m, "MARK=0x%x ", skb->mark);\r\n}\r\nstatic void dump_ipv6_mac_header(struct nf_log_buf *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nunsigned int logflags = 0;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nif (!(logflags & XT_LOG_MACDECODE))\r\ngoto fallback;\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\nnf_log_buf_add(m, "MACSRC=%pM MACDST=%pM MACPROTO=%04x ",\r\neth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\r\nntohs(eth_hdr(skb)->h_proto));\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nfallback:\r\nnf_log_buf_add(m, "MAC=");\r\nif (dev->hard_header_len &&\r\nskb->mac_header != skb->network_header) {\r\nconst unsigned char *p = skb_mac_header(skb);\r\nunsigned int len = dev->hard_header_len;\r\nunsigned int i;\r\nif (dev->type == ARPHRD_SIT) {\r\np -= ETH_HLEN;\r\nif (p < skb->head)\r\np = NULL;\r\n}\r\nif (p != NULL) {\r\nnf_log_buf_add(m, "%02x", *p++);\r\nfor (i = 1; i < len; i++)\r\nnf_log_buf_add(m, ":%02x", *p++);\r\n}\r\nnf_log_buf_add(m, " ");\r\nif (dev->type == ARPHRD_SIT) {\r\nconst struct iphdr *iph =\r\n(struct iphdr *)skb_mac_header(skb);\r\nnf_log_buf_add(m, "TUNNEL=%pI4->%pI4 ", &iph->saddr,\r\n&iph->daddr);\r\n}\r\n} else {\r\nnf_log_buf_add(m, " ");\r\n}\r\n}\r\nstatic void nf_log_ip6_packet(struct net *net, u_int8_t pf,\r\nunsigned int hooknum, const struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nstruct nf_log_buf *m;\r\nif (!net_eq(net, &init_net))\r\nreturn;\r\nm = nf_log_buf_open();\r\nif (!loginfo)\r\nloginfo = &default_loginfo;\r\nnf_log_dump_packet_common(m, pf, hooknum, skb, in, out,\r\nloginfo, prefix);\r\nif (in != NULL)\r\ndump_ipv6_mac_header(m, loginfo, skb);\r\ndump_ipv6_packet(m, loginfo, skb, skb_network_offset(skb), 1);\r\nnf_log_buf_close(m);\r\n}\r\nstatic int __net_init nf_log_ipv6_net_init(struct net *net)\r\n{\r\nnf_log_set(net, NFPROTO_IPV6, &nf_ip6_logger);\r\nreturn 0;\r\n}\r\nstatic void __net_exit nf_log_ipv6_net_exit(struct net *net)\r\n{\r\nnf_log_unset(net, &nf_ip6_logger);\r\n}\r\nstatic int __init nf_log_ipv6_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&nf_log_ipv6_net_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nnf_log_register(NFPROTO_IPV6, &nf_ip6_logger);\r\nreturn 0;\r\n}\r\nstatic void __exit nf_log_ipv6_exit(void)\r\n{\r\nunregister_pernet_subsys(&nf_log_ipv6_net_ops);\r\nnf_log_unregister(&nf_ip6_logger);\r\n}
