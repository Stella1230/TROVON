static void *usbvision_rvmalloc(unsigned long size)\r\n{\r\nvoid *mem;\r\nunsigned long adr;\r\nsize = PAGE_ALIGN(size);\r\nmem = vmalloc_32(size);\r\nif (!mem)\r\nreturn NULL;\r\nmemset(mem, 0, size);\r\nadr = (unsigned long) mem;\r\nwhile (size > 0) {\r\nSetPageReserved(vmalloc_to_page((void *)adr));\r\nadr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nreturn mem;\r\n}\r\nstatic void usbvision_rvfree(void *mem, unsigned long size)\r\n{\r\nunsigned long adr;\r\nif (!mem)\r\nreturn;\r\nsize = PAGE_ALIGN(size);\r\nadr = (unsigned long) mem;\r\nwhile ((long) size > 0) {\r\nClearPageReserved(vmalloc_to_page((void *)adr));\r\nadr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nvfree(mem);\r\n}\r\nstatic void usbvision_hexdump(const unsigned char *data, int len)\r\n{\r\nchar tmp[80];\r\nint i, k;\r\nfor (i = k = 0; len > 0; i++, len--) {\r\nif (i > 0 && (i % 16 == 0)) {\r\nprintk("%s\n", tmp);\r\nk = 0;\r\n}\r\nk += sprintf(&tmp[k], "%02x ", data[i]);\r\n}\r\nif (k > 0)\r\nprintk(KERN_CONT "%s\n", tmp);\r\n}\r\nstatic int scratch_len(struct usb_usbvision *usbvision)\r\n{\r\nint len = usbvision->scratch_write_ptr - usbvision->scratch_read_ptr;\r\nif (len < 0)\r\nlen += scratch_buf_size;\r\nPDEBUG(DBG_SCRATCH, "scratch_len() = %d\n", len);\r\nreturn len;\r\n}\r\nstatic int scratch_free(struct usb_usbvision *usbvision)\r\n{\r\nint free = usbvision->scratch_read_ptr - usbvision->scratch_write_ptr;\r\nif (free <= 0)\r\nfree += scratch_buf_size;\r\nif (free) {\r\nfree -= 1;\r\n}\r\nPDEBUG(DBG_SCRATCH, "return %d\n", free);\r\nreturn free;\r\n}\r\nstatic int scratch_put(struct usb_usbvision *usbvision, unsigned char *data,\r\nint len)\r\n{\r\nint len_part;\r\nif (usbvision->scratch_write_ptr + len < scratch_buf_size) {\r\nmemcpy(usbvision->scratch + usbvision->scratch_write_ptr, data, len);\r\nusbvision->scratch_write_ptr += len;\r\n} else {\r\nlen_part = scratch_buf_size - usbvision->scratch_write_ptr;\r\nmemcpy(usbvision->scratch + usbvision->scratch_write_ptr, data, len_part);\r\nif (len == len_part) {\r\nusbvision->scratch_write_ptr = 0;\r\n} else {\r\nmemcpy(usbvision->scratch, data + len_part, len - len_part);\r\nusbvision->scratch_write_ptr = len - len_part;\r\n}\r\n}\r\nPDEBUG(DBG_SCRATCH, "len=%d, new write_ptr=%d\n", len, usbvision->scratch_write_ptr);\r\nreturn len;\r\n}\r\nstatic void scratch_mark_header(struct usb_usbvision *usbvision)\r\n{\r\nPDEBUG(DBG_SCRATCH, "header at write_ptr=%d\n", usbvision->scratch_headermarker_write_ptr);\r\nusbvision->scratch_headermarker[usbvision->scratch_headermarker_write_ptr] =\r\nusbvision->scratch_write_ptr;\r\nusbvision->scratch_headermarker_write_ptr += 1;\r\nusbvision->scratch_headermarker_write_ptr %= USBVISION_NUM_HEADERMARKER;\r\n}\r\nstatic int scratch_get_extra(struct usb_usbvision *usbvision,\r\nunsigned char *data, int *ptr, int len)\r\n{\r\nint len_part;\r\nif (*ptr + len < scratch_buf_size) {\r\nmemcpy(data, usbvision->scratch + *ptr, len);\r\n*ptr += len;\r\n} else {\r\nlen_part = scratch_buf_size - *ptr;\r\nmemcpy(data, usbvision->scratch + *ptr, len_part);\r\nif (len == len_part) {\r\n*ptr = 0;\r\n} else {\r\nmemcpy(data + len_part, usbvision->scratch, len - len_part);\r\n*ptr = len - len_part;\r\n}\r\n}\r\nPDEBUG(DBG_SCRATCH, "len=%d, new ptr=%d\n", len, *ptr);\r\nreturn len;\r\n}\r\nstatic void scratch_set_extra_ptr(struct usb_usbvision *usbvision, int *ptr,\r\nint len)\r\n{\r\n*ptr = (usbvision->scratch_read_ptr + len) % scratch_buf_size;\r\nPDEBUG(DBG_SCRATCH, "ptr=%d\n", *ptr);\r\n}\r\nstatic void scratch_inc_extra_ptr(int *ptr, int len)\r\n{\r\n*ptr = (*ptr + len) % scratch_buf_size;\r\nPDEBUG(DBG_SCRATCH, "ptr=%d\n", *ptr);\r\n}\r\nstatic int scratch_get(struct usb_usbvision *usbvision, unsigned char *data,\r\nint len)\r\n{\r\nint len_part;\r\nif (usbvision->scratch_read_ptr + len < scratch_buf_size) {\r\nmemcpy(data, usbvision->scratch + usbvision->scratch_read_ptr, len);\r\nusbvision->scratch_read_ptr += len;\r\n} else {\r\nlen_part = scratch_buf_size - usbvision->scratch_read_ptr;\r\nmemcpy(data, usbvision->scratch + usbvision->scratch_read_ptr, len_part);\r\nif (len == len_part) {\r\nusbvision->scratch_read_ptr = 0;\r\n} else {\r\nmemcpy(data + len_part, usbvision->scratch, len - len_part);\r\nusbvision->scratch_read_ptr = len - len_part;\r\n}\r\n}\r\nPDEBUG(DBG_SCRATCH, "len=%d, new read_ptr=%d\n", len, usbvision->scratch_read_ptr);\r\nreturn len;\r\n}\r\nstatic int scratch_get_header(struct usb_usbvision *usbvision,\r\nstruct usbvision_frame_header *header)\r\n{\r\nint err_code = 0;\r\nPDEBUG(DBG_SCRATCH, "from read_ptr=%d", usbvision->scratch_headermarker_read_ptr);\r\nwhile (usbvision->scratch_headermarker_write_ptr -\r\nusbvision->scratch_headermarker_read_ptr != 0) {\r\nusbvision->scratch_read_ptr =\r\nusbvision->scratch_headermarker[usbvision->scratch_headermarker_read_ptr];\r\nusbvision->scratch_headermarker_read_ptr += 1;\r\nusbvision->scratch_headermarker_read_ptr %= USBVISION_NUM_HEADERMARKER;\r\nscratch_get(usbvision, (unsigned char *)header, USBVISION_HEADER_LENGTH);\r\nif ((header->magic_1 == USBVISION_MAGIC_1)\r\n&& (header->magic_2 == USBVISION_MAGIC_2)\r\n&& (header->header_length == USBVISION_HEADER_LENGTH)) {\r\nerr_code = USBVISION_HEADER_LENGTH;\r\nheader->frame_width = header->frame_width_lo + (header->frame_width_hi << 8);\r\nheader->frame_height = header->frame_height_lo + (header->frame_height_hi << 8);\r\nbreak;\r\n}\r\n}\r\nreturn err_code;\r\n}\r\nstatic void scratch_rm_old(struct usb_usbvision *usbvision, int len)\r\n{\r\nusbvision->scratch_read_ptr += len;\r\nusbvision->scratch_read_ptr %= scratch_buf_size;\r\nPDEBUG(DBG_SCRATCH, "read_ptr is now %d\n", usbvision->scratch_read_ptr);\r\n}\r\nstatic void scratch_reset(struct usb_usbvision *usbvision)\r\n{\r\nPDEBUG(DBG_SCRATCH, "\n");\r\nusbvision->scratch_read_ptr = 0;\r\nusbvision->scratch_write_ptr = 0;\r\nusbvision->scratch_headermarker_read_ptr = 0;\r\nusbvision->scratch_headermarker_write_ptr = 0;\r\nusbvision->isocstate = isoc_state_no_frame;\r\n}\r\nint usbvision_scratch_alloc(struct usb_usbvision *usbvision)\r\n{\r\nusbvision->scratch = vmalloc_32(scratch_buf_size);\r\nscratch_reset(usbvision);\r\nif (usbvision->scratch == NULL) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: unable to allocate %d bytes for scratch\n",\r\n__func__, scratch_buf_size);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid usbvision_scratch_free(struct usb_usbvision *usbvision)\r\n{\r\nvfree(usbvision->scratch);\r\nusbvision->scratch = NULL;\r\n}\r\nint usbvision_decompress_alloc(struct usb_usbvision *usbvision)\r\n{\r\nint IFB_size = MAX_FRAME_WIDTH * MAX_FRAME_HEIGHT * 3 / 2;\r\nusbvision->intra_frame_buffer = vmalloc_32(IFB_size);\r\nif (usbvision->intra_frame_buffer == NULL) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: unable to allocate %d for compr. frame buffer\n",\r\n__func__, IFB_size);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid usbvision_decompress_free(struct usb_usbvision *usbvision)\r\n{\r\nvfree(usbvision->intra_frame_buffer);\r\nusbvision->intra_frame_buffer = NULL;\r\n}\r\nstatic enum parse_state usbvision_find_header(struct usb_usbvision *usbvision)\r\n{\r\nstruct usbvision_frame *frame;\r\nint found_header = 0;\r\nframe = usbvision->cur_frame;\r\nwhile (scratch_get_header(usbvision, &frame->isoc_header) == USBVISION_HEADER_LENGTH) {\r\nPDEBUG(DBG_HEADER, "found header: 0x%02x%02x %d %d %d %d %#x 0x%02x %u %u",\r\nframe->isoc_header.magic_2,\r\nframe->isoc_header.magic_1,\r\nframe->isoc_header.header_length,\r\nframe->isoc_header.frame_num,\r\nframe->isoc_header.frame_phase,\r\nframe->isoc_header.frame_latency,\r\nframe->isoc_header.data_format,\r\nframe->isoc_header.format_param,\r\nframe->isoc_header.frame_width,\r\nframe->isoc_header.frame_height);\r\nif (usbvision->request_intra) {\r\nif (frame->isoc_header.format_param & 0x80) {\r\nfound_header = 1;\r\nusbvision->last_isoc_frame_num = -1;\r\nusbvision_unrequest_intra(usbvision);\r\nbreak;\r\n}\r\n} else {\r\nfound_header = 1;\r\nbreak;\r\n}\r\n}\r\nif (found_header) {\r\nframe->frmwidth = frame->isoc_header.frame_width * usbvision->stretch_width;\r\nframe->frmheight = frame->isoc_header.frame_height * usbvision->stretch_height;\r\nframe->v4l2_linesize = (frame->frmwidth * frame->v4l2_format.depth) >> 3;\r\n} else {\r\nPDEBUG(DBG_HEADER, "skipping scratch data, no header");\r\nscratch_reset(usbvision);\r\nreturn parse_state_end_parse;\r\n}\r\nif (frame->isoc_header.data_format == ISOC_MODE_COMPRESS) {\r\nif (usbvision->last_isoc_frame_num >= 0) {\r\nif (((usbvision->last_isoc_frame_num + 1) % 32) != frame->isoc_header.frame_num) {\r\nPDEBUG(DBG_HEADER, "Lost frame before %d on USB", frame->isoc_header.frame_num);\r\nusbvision_request_intra(usbvision);\r\nreturn parse_state_next_frame;\r\n}\r\n}\r\nusbvision->last_isoc_frame_num = frame->isoc_header.frame_num;\r\n}\r\nusbvision->header_count++;\r\nframe->scanstate = scan_state_lines;\r\nframe->curline = 0;\r\nreturn parse_state_continue;\r\n}\r\nstatic enum parse_state usbvision_parse_lines_422(struct usb_usbvision *usbvision,\r\nlong *pcopylen)\r\n{\r\nvolatile struct usbvision_frame *frame;\r\nunsigned char *f;\r\nint len;\r\nint i;\r\nunsigned char yuyv[4] = { 180, 128, 10, 128 };\r\nunsigned char rv, gv, bv;\r\nint clipmask_index, bytes_per_pixel;\r\nint stretch_bytes, clipmask_add;\r\nframe = usbvision->cur_frame;\r\nf = frame->data + (frame->v4l2_linesize * frame->curline);\r\nlen = (frame->isoc_header.frame_width * 2) + 5;\r\nif (scratch_len(usbvision) < len) {\r\nPDEBUG(DBG_PARSE, "out of data in line %d, need %u.\n", frame->curline, len);\r\nreturn parse_state_out;\r\n}\r\nif ((frame->curline + 1) >= frame->frmheight)\r\nreturn parse_state_next_frame;\r\nbytes_per_pixel = frame->v4l2_format.bytes_per_pixel;\r\nstretch_bytes = (usbvision->stretch_width - 1) * bytes_per_pixel;\r\nclipmask_index = frame->curline * MAX_FRAME_WIDTH;\r\nclipmask_add = usbvision->stretch_width;\r\nfor (i = 0; i < frame->frmwidth; i += (2 * usbvision->stretch_width)) {\r\nscratch_get(usbvision, &yuyv[0], 4);\r\nif (frame->v4l2_format.format == V4L2_PIX_FMT_YUYV) {\r\n*f++ = yuyv[0];\r\n*f++ = yuyv[3];\r\n} else {\r\nYUV_TO_RGB_BY_THE_BOOK(yuyv[0], yuyv[1], yuyv[3], rv, gv, bv);\r\nswitch (frame->v4l2_format.format) {\r\ncase V4L2_PIX_FMT_RGB565:\r\n*f++ = (0x1F & rv) |\r\n(0xE0 & (gv << 5));\r\n*f++ = (0x07 & (gv >> 3)) |\r\n(0xF8 & bv);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\n*f++ = rv;\r\n*f++ = gv;\r\n*f++ = bv;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\n*f++ = rv;\r\n*f++ = gv;\r\n*f++ = bv;\r\nf++;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\n*f++ = (0x1F & rv) |\r\n(0xE0 & (gv << 5));\r\n*f++ = (0x03 & (gv >> 3)) |\r\n(0x7C & (bv << 2));\r\nbreak;\r\n}\r\n}\r\nclipmask_index += clipmask_add;\r\nf += stretch_bytes;\r\nif (frame->v4l2_format.format == V4L2_PIX_FMT_YUYV) {\r\n*f++ = yuyv[2];\r\n*f++ = yuyv[1];\r\n} else {\r\nYUV_TO_RGB_BY_THE_BOOK(yuyv[2], yuyv[1], yuyv[3], rv, gv, bv);\r\nswitch (frame->v4l2_format.format) {\r\ncase V4L2_PIX_FMT_RGB565:\r\n*f++ = (0x1F & rv) |\r\n(0xE0 & (gv << 5));\r\n*f++ = (0x07 & (gv >> 3)) |\r\n(0xF8 & bv);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\n*f++ = rv;\r\n*f++ = gv;\r\n*f++ = bv;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\n*f++ = rv;\r\n*f++ = gv;\r\n*f++ = bv;\r\nf++;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\n*f++ = (0x1F & rv) |\r\n(0xE0 & (gv << 5));\r\n*f++ = (0x03 & (gv >> 3)) |\r\n(0x7C & (bv << 2));\r\nbreak;\r\n}\r\n}\r\nclipmask_index += clipmask_add;\r\nf += stretch_bytes;\r\n}\r\nframe->curline += usbvision->stretch_height;\r\n*pcopylen += frame->v4l2_linesize * usbvision->stretch_height;\r\nif (frame->curline >= frame->frmheight)\r\nreturn parse_state_next_frame;\r\nreturn parse_state_continue;\r\n}\r\nstatic int usbvision_decompress(struct usb_usbvision *usbvision, unsigned char *compressed,\r\nunsigned char *decompressed, int *start_pos,\r\nint *block_typestart_pos, int len)\r\n{\r\nint rest_pixel, idx, pos, extra_pos, block_len, block_type_pos, block_type_len;\r\nunsigned char block_byte, block_code, block_type, block_type_byte, integrator;\r\nintegrator = 0;\r\npos = *start_pos;\r\nblock_type_pos = *block_typestart_pos;\r\nextra_pos = pos;\r\nblock_len = 0;\r\nblock_byte = 0;\r\nblock_code = 0;\r\nblock_type = 0;\r\nblock_type_byte = 0;\r\nblock_type_len = 0;\r\nrest_pixel = len;\r\nfor (idx = 0; idx < len; idx++) {\r\nif (block_len == 0) {\r\nif (block_type_len == 0) {\r\nblock_type_byte = compressed[block_type_pos];\r\nblock_type_pos++;\r\nblock_type_len = 4;\r\n}\r\nblock_type = (block_type_byte & 0xC0) >> 6;\r\nusbvision->compr_block_types[block_type]++;\r\npos = extra_pos;\r\nif (block_type == 0) {\r\nif (rest_pixel >= 24) {\r\nidx += 23;\r\nrest_pixel -= 24;\r\nintegrator = decompressed[idx];\r\n} else {\r\nidx += rest_pixel - 1;\r\nrest_pixel = 0;\r\n}\r\n} else {\r\nblock_code = compressed[pos];\r\npos++;\r\nif (rest_pixel >= 24)\r\nblock_len = 24;\r\nelse\r\nblock_len = rest_pixel;\r\nrest_pixel -= block_len;\r\nextra_pos = pos + (block_len / 4);\r\n}\r\nblock_type_byte <<= 2;\r\nblock_type_len -= 1;\r\n}\r\nif (block_len > 0) {\r\nif ((block_len % 4) == 0) {\r\nblock_byte = compressed[pos];\r\npos++;\r\n}\r\nif (block_type == 1)\r\nintegrator = decompressed[idx];\r\nswitch (block_byte & 0xC0) {\r\ncase 0x03 << 6:\r\nintegrator += compressed[extra_pos];\r\nextra_pos++;\r\nbreak;\r\ncase 0x02 << 6:\r\nintegrator += block_code;\r\nbreak;\r\ncase 0x00:\r\nintegrator -= block_code;\r\nbreak;\r\n}\r\ndecompressed[idx] = integrator;\r\nblock_byte <<= 2;\r\nblock_len -= 1;\r\n}\r\n}\r\n*start_pos = extra_pos;\r\n*block_typestart_pos = block_type_pos;\r\nreturn idx;\r\n}\r\nstatic enum parse_state usbvision_parse_compress(struct usb_usbvision *usbvision,\r\nlong *pcopylen)\r\n{\r\n#define USBVISION_STRIP_MAGIC 0x5A\r\n#define USBVISION_STRIP_LEN_MAX 400\r\n#define USBVISION_STRIP_HEADER_LEN 3\r\nstruct usbvision_frame *frame;\r\nunsigned char *f, *u = NULL, *v = NULL;\r\nunsigned char strip_data[USBVISION_STRIP_LEN_MAX];\r\nunsigned char strip_header[USBVISION_STRIP_HEADER_LEN];\r\nint idx, idx_end, strip_len, strip_ptr, startblock_pos, block_pos, block_type_pos;\r\nint clipmask_index;\r\nint image_size;\r\nunsigned char rv, gv, bv;\r\nstatic unsigned char *Y, *U, *V;\r\nframe = usbvision->cur_frame;\r\nimage_size = frame->frmwidth * frame->frmheight;\r\nif ((frame->v4l2_format.format == V4L2_PIX_FMT_YUV422P) ||\r\n(frame->v4l2_format.format == V4L2_PIX_FMT_YVU420)) {\r\nf = frame->data + (frame->width * frame->curline);\r\n} else\r\nf = frame->data + (frame->v4l2_linesize * frame->curline);\r\nif (frame->v4l2_format.format == V4L2_PIX_FMT_YUYV) {\r\nu = frame->data\r\n+ image_size\r\n+ (frame->frmwidth >> 1) * frame->curline;\r\nv = u + (image_size >> 1);\r\n} else if (frame->v4l2_format.format == V4L2_PIX_FMT_YVU420) {\r\nv = frame->data + image_size + ((frame->curline * (frame->width)) >> 2);\r\nu = v + (image_size >> 2);\r\n}\r\nif (frame->curline == 0)\r\nusbvision_adjust_compression(usbvision);\r\nif (scratch_len(usbvision) < USBVISION_STRIP_HEADER_LEN)\r\nreturn parse_state_out;\r\nscratch_set_extra_ptr(usbvision, &strip_ptr, 0);\r\nscratch_get_extra(usbvision, &strip_header[0], &strip_ptr,\r\nUSBVISION_STRIP_HEADER_LEN);\r\nif (strip_header[0] != USBVISION_STRIP_MAGIC) {\r\nusbvision->strip_magic_errors++;\r\nreturn parse_state_next_frame;\r\n}\r\nif (frame->curline != (int)strip_header[2]) {\r\nusbvision->strip_line_number_errors++;\r\n}\r\nstrip_len = 2 * (unsigned int)strip_header[1];\r\nif (strip_len > USBVISION_STRIP_LEN_MAX) {\r\nusbvision_request_intra(usbvision);\r\n}\r\nif (scratch_len(usbvision) < strip_len) {\r\nreturn parse_state_out;\r\n}\r\nif (usbvision->intra_frame_buffer) {\r\nY = usbvision->intra_frame_buffer + frame->frmwidth * frame->curline;\r\nU = usbvision->intra_frame_buffer + image_size + (frame->frmwidth / 2) * (frame->curline / 2);\r\nV = usbvision->intra_frame_buffer + image_size / 4 * 5 + (frame->frmwidth / 2) * (frame->curline / 2);\r\n} else {\r\nreturn parse_state_next_frame;\r\n}\r\nclipmask_index = frame->curline * MAX_FRAME_WIDTH;\r\nscratch_get(usbvision, strip_data, strip_len);\r\nidx_end = frame->frmwidth;\r\nblock_type_pos = USBVISION_STRIP_HEADER_LEN;\r\nstartblock_pos = block_type_pos + (idx_end - 1) / 96 + (idx_end / 2 - 1) / 96 + 2;\r\nblock_pos = startblock_pos;\r\nusbvision->block_pos = block_pos;\r\nusbvision_decompress(usbvision, strip_data, Y, &block_pos, &block_type_pos, idx_end);\r\nif (strip_len > usbvision->max_strip_len)\r\nusbvision->max_strip_len = strip_len;\r\nif (frame->curline % 2)\r\nusbvision_decompress(usbvision, strip_data, V, &block_pos, &block_type_pos, idx_end / 2);\r\nelse\r\nusbvision_decompress(usbvision, strip_data, U, &block_pos, &block_type_pos, idx_end / 2);\r\nif (block_pos > usbvision->comprblock_pos)\r\nusbvision->comprblock_pos = block_pos;\r\nif (block_pos > strip_len)\r\nusbvision->strip_len_errors++;\r\nfor (idx = 0; idx < idx_end; idx++) {\r\nif (frame->v4l2_format.format == V4L2_PIX_FMT_YUYV) {\r\n*f++ = Y[idx];\r\n*f++ = idx & 0x01 ? U[idx / 2] : V[idx / 2];\r\n} else if (frame->v4l2_format.format == V4L2_PIX_FMT_YUV422P) {\r\n*f++ = Y[idx];\r\nif (idx & 0x01)\r\n*u++ = U[idx >> 1];\r\nelse\r\n*v++ = V[idx >> 1];\r\n} else if (frame->v4l2_format.format == V4L2_PIX_FMT_YVU420) {\r\n*f++ = Y[idx];\r\nif (!((idx & 0x01) | (frame->curline & 0x01))) {\r\n*u++ = U[idx >> 1];\r\n*v++ = V[idx >> 1];\r\n}\r\n} else {\r\nYUV_TO_RGB_BY_THE_BOOK(Y[idx], U[idx / 2], V[idx / 2], rv, gv, bv);\r\nswitch (frame->v4l2_format.format) {\r\ncase V4L2_PIX_FMT_GREY:\r\n*f++ = Y[idx];\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\n*f++ = (0x1F & rv) |\r\n(0xE0 & (gv << 5));\r\n*f++ = (0x03 & (gv >> 3)) |\r\n(0x7C & (bv << 2));\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\n*f++ = (0x1F & rv) |\r\n(0xE0 & (gv << 5));\r\n*f++ = (0x07 & (gv >> 3)) |\r\n(0xF8 & bv);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\n*f++ = rv;\r\n*f++ = gv;\r\n*f++ = bv;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\n*f++ = rv;\r\n*f++ = gv;\r\n*f++ = bv;\r\nf++;\r\nbreak;\r\n}\r\n}\r\nclipmask_index++;\r\n}\r\nif (frame->v4l2_format.format != V4L2_PIX_FMT_YVU420)\r\n*pcopylen += frame->v4l2_linesize;\r\nelse\r\n*pcopylen += frame->curline & 0x01 ? frame->v4l2_linesize : frame->v4l2_linesize << 1;\r\nframe->curline += 1;\r\nif (frame->curline >= frame->frmheight)\r\nreturn parse_state_next_frame;\r\nreturn parse_state_continue;\r\n}\r\nstatic enum parse_state usbvision_parse_lines_420(struct usb_usbvision *usbvision,\r\nlong *pcopylen)\r\n{\r\nstruct usbvision_frame *frame;\r\nunsigned char *f_even = NULL, *f_odd = NULL;\r\nunsigned int pixel_per_line, block;\r\nint pixel, block_split;\r\nint y_ptr, u_ptr, v_ptr, y_odd_offset;\r\nconst int y_block_size = 128;\r\nconst int uv_block_size = 64;\r\nconst int sub_block_size = 32;\r\nconst int y_step[] = { 0, 0, 0, 2 }, y_step_size = 4;\r\nconst int uv_step[] = { 0, 0, 0, 4 }, uv_step_size = 4;\r\nunsigned char y[2], u, v;\r\nint y_, u_, v_, vb, uvg, ur;\r\nint r_, g_, b_;\r\nunsigned char g;\r\nint clipmask_even_index, clipmask_odd_index, bytes_per_pixel;\r\nint clipmask_add, stretch_bytes;\r\nframe = usbvision->cur_frame;\r\nf_even = frame->data + (frame->v4l2_linesize * frame->curline);\r\nf_odd = f_even + frame->v4l2_linesize * usbvision->stretch_height;\r\nbytes_per_pixel = frame->v4l2_format.bytes_per_pixel;\r\nstretch_bytes = (usbvision->stretch_width - 1) * bytes_per_pixel;\r\nclipmask_even_index = frame->curline * MAX_FRAME_WIDTH;\r\nclipmask_odd_index = clipmask_even_index + MAX_FRAME_WIDTH;\r\nclipmask_add = usbvision->stretch_width;\r\npixel_per_line = frame->isoc_header.frame_width;\r\nif (scratch_len(usbvision) < (int)pixel_per_line * 3) {\r\nreturn parse_state_out;\r\n}\r\nif ((frame->curline + 1) >= frame->frmheight)\r\nreturn parse_state_next_frame;\r\nblock_split = (pixel_per_line%y_block_size) ? 1 : 0;\r\ny_odd_offset = (pixel_per_line / y_block_size) * (y_block_size + uv_block_size)\r\n+ block_split * uv_block_size;\r\nscratch_set_extra_ptr(usbvision, &y_ptr, y_odd_offset);\r\nscratch_set_extra_ptr(usbvision, &u_ptr, y_block_size);\r\nscratch_set_extra_ptr(usbvision, &v_ptr, y_odd_offset\r\n+ (4 - block_split) * sub_block_size);\r\nfor (block = 0; block < (pixel_per_line / sub_block_size); block++) {\r\nfor (pixel = 0; pixel < sub_block_size; pixel += 2) {\r\nscratch_get(usbvision, &y[0], 2);\r\nscratch_get_extra(usbvision, &u, &u_ptr, 1);\r\nscratch_get_extra(usbvision, &v, &v_ptr, 1);\r\nv_ = v - 128;\r\nu_ = u - 128;\r\nvb = 132252 * v_;\r\nuvg = -53281 * u_ - 25625 * v_;\r\nur = 104595 * u_;\r\nif (frame->v4l2_format.format == V4L2_PIX_FMT_YUYV) {\r\n*f_even++ = y[0];\r\n*f_even++ = v;\r\n} else {\r\ny_ = 76284 * (y[0] - 16);\r\nb_ = (y_ + vb) >> 16;\r\ng_ = (y_ + uvg) >> 16;\r\nr_ = (y_ + ur) >> 16;\r\nswitch (frame->v4l2_format.format) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ng = LIMIT_RGB(g_);\r\n*f_even++ =\r\n(0x1F & LIMIT_RGB(r_)) |\r\n(0xE0 & (g << 5));\r\n*f_even++ =\r\n(0x07 & (g >> 3)) |\r\n(0xF8 & LIMIT_RGB(b_));\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\n*f_even++ = LIMIT_RGB(r_);\r\n*f_even++ = LIMIT_RGB(g_);\r\n*f_even++ = LIMIT_RGB(b_);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\n*f_even++ = LIMIT_RGB(r_);\r\n*f_even++ = LIMIT_RGB(g_);\r\n*f_even++ = LIMIT_RGB(b_);\r\nf_even++;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ng = LIMIT_RGB(g_);\r\n*f_even++ = (0x1F & LIMIT_RGB(r_)) |\r\n(0xE0 & (g << 5));\r\n*f_even++ = (0x03 & (g >> 3)) |\r\n(0x7C & (LIMIT_RGB(b_) << 2));\r\nbreak;\r\n}\r\n}\r\nclipmask_even_index += clipmask_add;\r\nf_even += stretch_bytes;\r\nif (frame->v4l2_format.format == V4L2_PIX_FMT_YUYV) {\r\n*f_even++ = y[1];\r\n*f_even++ = u;\r\n} else {\r\ny_ = 76284 * (y[1] - 16);\r\nb_ = (y_ + vb) >> 16;\r\ng_ = (y_ + uvg) >> 16;\r\nr_ = (y_ + ur) >> 16;\r\nswitch (frame->v4l2_format.format) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ng = LIMIT_RGB(g_);\r\n*f_even++ =\r\n(0x1F & LIMIT_RGB(r_)) |\r\n(0xE0 & (g << 5));\r\n*f_even++ =\r\n(0x07 & (g >> 3)) |\r\n(0xF8 & LIMIT_RGB(b_));\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\n*f_even++ = LIMIT_RGB(r_);\r\n*f_even++ = LIMIT_RGB(g_);\r\n*f_even++ = LIMIT_RGB(b_);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\n*f_even++ = LIMIT_RGB(r_);\r\n*f_even++ = LIMIT_RGB(g_);\r\n*f_even++ = LIMIT_RGB(b_);\r\nf_even++;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ng = LIMIT_RGB(g_);\r\n*f_even++ = (0x1F & LIMIT_RGB(r_)) |\r\n(0xE0 & (g << 5));\r\n*f_even++ = (0x03 & (g >> 3)) |\r\n(0x7C & (LIMIT_RGB(b_) << 2));\r\nbreak;\r\n}\r\n}\r\nclipmask_even_index += clipmask_add;\r\nf_even += stretch_bytes;\r\nscratch_get_extra(usbvision, &y[0], &y_ptr, 2);\r\nif (frame->v4l2_format.format == V4L2_PIX_FMT_YUYV) {\r\n*f_odd++ = y[0];\r\n*f_odd++ = v;\r\n} else {\r\ny_ = 76284 * (y[0] - 16);\r\nb_ = (y_ + vb) >> 16;\r\ng_ = (y_ + uvg) >> 16;\r\nr_ = (y_ + ur) >> 16;\r\nswitch (frame->v4l2_format.format) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ng = LIMIT_RGB(g_);\r\n*f_odd++ =\r\n(0x1F & LIMIT_RGB(r_)) |\r\n(0xE0 & (g << 5));\r\n*f_odd++ =\r\n(0x07 & (g >> 3)) |\r\n(0xF8 & LIMIT_RGB(b_));\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\n*f_odd++ = LIMIT_RGB(r_);\r\n*f_odd++ = LIMIT_RGB(g_);\r\n*f_odd++ = LIMIT_RGB(b_);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\n*f_odd++ = LIMIT_RGB(r_);\r\n*f_odd++ = LIMIT_RGB(g_);\r\n*f_odd++ = LIMIT_RGB(b_);\r\nf_odd++;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ng = LIMIT_RGB(g_);\r\n*f_odd++ = (0x1F & LIMIT_RGB(r_)) |\r\n(0xE0 & (g << 5));\r\n*f_odd++ = (0x03 & (g >> 3)) |\r\n(0x7C & (LIMIT_RGB(b_) << 2));\r\nbreak;\r\n}\r\n}\r\nclipmask_odd_index += clipmask_add;\r\nf_odd += stretch_bytes;\r\nif (frame->v4l2_format.format == V4L2_PIX_FMT_YUYV) {\r\n*f_odd++ = y[1];\r\n*f_odd++ = u;\r\n} else {\r\ny_ = 76284 * (y[1] - 16);\r\nb_ = (y_ + vb) >> 16;\r\ng_ = (y_ + uvg) >> 16;\r\nr_ = (y_ + ur) >> 16;\r\nswitch (frame->v4l2_format.format) {\r\ncase V4L2_PIX_FMT_RGB565:\r\ng = LIMIT_RGB(g_);\r\n*f_odd++ =\r\n(0x1F & LIMIT_RGB(r_)) |\r\n(0xE0 & (g << 5));\r\n*f_odd++ =\r\n(0x07 & (g >> 3)) |\r\n(0xF8 & LIMIT_RGB(b_));\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\n*f_odd++ = LIMIT_RGB(r_);\r\n*f_odd++ = LIMIT_RGB(g_);\r\n*f_odd++ = LIMIT_RGB(b_);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\n*f_odd++ = LIMIT_RGB(r_);\r\n*f_odd++ = LIMIT_RGB(g_);\r\n*f_odd++ = LIMIT_RGB(b_);\r\nf_odd++;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ng = LIMIT_RGB(g_);\r\n*f_odd++ = (0x1F & LIMIT_RGB(r_)) |\r\n(0xE0 & (g << 5));\r\n*f_odd++ = (0x03 & (g >> 3)) |\r\n(0x7C & (LIMIT_RGB(b_) << 2));\r\nbreak;\r\n}\r\n}\r\nclipmask_odd_index += clipmask_add;\r\nf_odd += stretch_bytes;\r\n}\r\nscratch_rm_old(usbvision, y_step[block % y_step_size] * sub_block_size);\r\nscratch_inc_extra_ptr(&y_ptr, y_step[(block + 2 * block_split) % y_step_size]\r\n* sub_block_size);\r\nscratch_inc_extra_ptr(&u_ptr, uv_step[block % uv_step_size]\r\n* sub_block_size);\r\nscratch_inc_extra_ptr(&v_ptr, uv_step[(block + 2 * block_split) % uv_step_size]\r\n* sub_block_size);\r\n}\r\nscratch_rm_old(usbvision, pixel_per_line * 3 / 2\r\n+ block_split * sub_block_size);\r\nframe->curline += 2 * usbvision->stretch_height;\r\n*pcopylen += frame->v4l2_linesize * 2 * usbvision->stretch_height;\r\nif (frame->curline >= frame->frmheight)\r\nreturn parse_state_next_frame;\r\nreturn parse_state_continue;\r\n}\r\nstatic void usbvision_parse_data(struct usb_usbvision *usbvision)\r\n{\r\nstruct usbvision_frame *frame;\r\nenum parse_state newstate;\r\nlong copylen = 0;\r\nunsigned long lock_flags;\r\nframe = usbvision->cur_frame;\r\nPDEBUG(DBG_PARSE, "parsing len=%d\n", scratch_len(usbvision));\r\nwhile (1) {\r\nnewstate = parse_state_out;\r\nif (scratch_len(usbvision)) {\r\nif (frame->scanstate == scan_state_scanning) {\r\nnewstate = usbvision_find_header(usbvision);\r\n} else if (frame->scanstate == scan_state_lines) {\r\nif (usbvision->isoc_mode == ISOC_MODE_YUV420)\r\nnewstate = usbvision_parse_lines_420(usbvision, &copylen);\r\nelse if (usbvision->isoc_mode == ISOC_MODE_YUV422)\r\nnewstate = usbvision_parse_lines_422(usbvision, &copylen);\r\nelse if (usbvision->isoc_mode == ISOC_MODE_COMPRESS)\r\nnewstate = usbvision_parse_compress(usbvision, &copylen);\r\n}\r\n}\r\nif (newstate == parse_state_continue)\r\ncontinue;\r\nif ((newstate == parse_state_next_frame) || (newstate == parse_state_out))\r\nbreak;\r\nreturn;\r\n}\r\nif (newstate == parse_state_next_frame) {\r\nframe->grabstate = frame_state_done;\r\nv4l2_get_timestamp(&(frame->timestamp));\r\nframe->sequence = usbvision->frame_num;\r\nspin_lock_irqsave(&usbvision->queue_lock, lock_flags);\r\nlist_move_tail(&(frame->frame), &usbvision->outqueue);\r\nusbvision->cur_frame = NULL;\r\nspin_unlock_irqrestore(&usbvision->queue_lock, lock_flags);\r\nusbvision->frame_num++;\r\nif (waitqueue_active(&usbvision->wait_frame)) {\r\nPDEBUG(DBG_PARSE, "Wake up !");\r\nwake_up_interruptible(&usbvision->wait_frame);\r\n}\r\n} else {\r\nframe->grabstate = frame_state_grabbing;\r\n}\r\nframe->scanlength += copylen;\r\n}\r\nstatic int usbvision_compress_isochronous(struct usb_usbvision *usbvision,\r\nstruct urb *urb)\r\n{\r\nunsigned char *packet_data;\r\nint i, totlen = 0;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nint packet_len = urb->iso_frame_desc[i].actual_length;\r\nint packet_stat = urb->iso_frame_desc[i].status;\r\npacket_data = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (packet_stat) {\r\nPDEBUG(DBG_ISOC, "data error: [%d] len=%d, status=%X", i, packet_len, packet_stat);\r\nusbvision->isoc_err_count++;\r\ncontinue;\r\n}\r\nif (packet_len < 0) {\r\nPDEBUG(DBG_ISOC, "error packet [%d]", i);\r\nusbvision->isoc_skip_count++;\r\ncontinue;\r\n} else if (packet_len == 0) {\r\nPDEBUG(DBG_ISOC, "null packet [%d]", i);\r\nusbvision->isocstate = isoc_state_no_frame;\r\nusbvision->isoc_skip_count++;\r\ncontinue;\r\n} else if (packet_len > usbvision->isoc_packet_size) {\r\nPDEBUG(DBG_ISOC, "packet[%d] > isoc_packet_size", i);\r\nusbvision->isoc_skip_count++;\r\ncontinue;\r\n}\r\nPDEBUG(DBG_ISOC, "packet ok [%d] len=%d", i, packet_len);\r\nif (usbvision->isocstate == isoc_state_no_frame) {\r\nusbvision->isocstate = isoc_state_in_frame;\r\nscratch_mark_header(usbvision);\r\nusbvision_measure_bandwidth(usbvision);\r\nPDEBUG(DBG_ISOC, "packet with header");\r\n}\r\nif (scratch_free(usbvision) < packet_len) {\r\nusbvision->scratch_ovf_count++;\r\nPDEBUG(DBG_ISOC, "scratch buf overflow! scr_len: %d, n: %d",\r\nscratch_len(usbvision), packet_len);\r\nscratch_rm_old(usbvision, packet_len - scratch_free(usbvision));\r\n}\r\nscratch_put(usbvision, packet_data, packet_len);\r\ntotlen += packet_len;\r\nusbvision->isoc_data_count += packet_len;\r\nusbvision->isoc_packet_count++;\r\n}\r\n#if ENABLE_HEXDUMP\r\nif (totlen > 0) {\r\nstatic int foo;\r\nif (foo < 1) {\r\nprintk(KERN_DEBUG "+%d.\n", usbvision->scratchlen);\r\nusbvision_hexdump(data0, (totlen > 64) ? 64 : totlen);\r\n++foo;\r\n}\r\n}\r\n#endif\r\nreturn totlen;\r\n}\r\nstatic void usbvision_isoc_irq(struct urb *urb)\r\n{\r\nint err_code = 0;\r\nint len;\r\nstruct usb_usbvision *usbvision = urb->context;\r\nint i;\r\nunsigned long start_time = jiffies;\r\nstruct usbvision_frame **f;\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn;\r\nif (urb->status == -ENOENT)\r\nreturn;\r\nf = &usbvision->cur_frame;\r\nif (usbvision->streaming == stream_interrupt) {\r\nusbvision->streaming = stream_idle;\r\nif ((*f)) {\r\n(*f)->grabstate = frame_state_ready;\r\n(*f)->scanstate = scan_state_scanning;\r\n}\r\nPDEBUG(DBG_IRQ, "stream interrupted");\r\nwake_up_interruptible(&usbvision->wait_stream);\r\n}\r\nlen = usbvision_compress_isochronous(usbvision, urb);\r\nusbvision->isoc_urb_count++;\r\nusbvision->urb_length = len;\r\nif (usbvision->streaming == stream_on) {\r\nif (scratch_len(usbvision) > USBVISION_HEADER_LENGTH &&\r\n!list_empty(&(usbvision->inqueue))) {\r\nif (!(*f)) {\r\n(*f) = list_entry(usbvision->inqueue.next,\r\nstruct usbvision_frame,\r\nframe);\r\n}\r\nusbvision_parse_data(usbvision);\r\n} else {\r\nPDEBUG(DBG_IRQ,\r\n"received data, but no one needs it");\r\nscratch_reset(usbvision);\r\n}\r\n} else {\r\nPDEBUG(DBG_IRQ, "received data, but no one needs it");\r\nscratch_reset(usbvision);\r\n}\r\nusbvision->time_in_irq += jiffies - start_time;\r\nfor (i = 0; i < USBVISION_URB_FRAMES; i++) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nurb->status = 0;\r\nurb->dev = usbvision->dev;\r\nerr_code = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err_code) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: usb_submit_urb failed: error %d\n",\r\n__func__, err_code);\r\n}\r\nreturn;\r\n}\r\nint usbvision_read_reg(struct usb_usbvision *usbvision, unsigned char reg)\r\n{\r\nint err_code = 0;\r\nunsigned char buffer[1];\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn -1;\r\nerr_code = usb_control_msg(usbvision->dev, usb_rcvctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT,\r\n0, (__u16) reg, buffer, 1, HZ);\r\nif (err_code < 0) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: failed: error %d\n", __func__, err_code);\r\nreturn err_code;\r\n}\r\nreturn buffer[0];\r\n}\r\nint usbvision_write_reg(struct usb_usbvision *usbvision, unsigned char reg,\r\nunsigned char value)\r\n{\r\nint err_code = 0;\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn 0;\r\nerr_code = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_ENDPOINT, 0, (__u16) reg, &value, 1, HZ);\r\nif (err_code < 0) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: failed: error %d\n", __func__, err_code);\r\n}\r\nreturn err_code;\r\n}\r\nstatic void usbvision_ctrl_urb_complete(struct urb *urb)\r\n{\r\nstruct usb_usbvision *usbvision = (struct usb_usbvision *)urb->context;\r\nPDEBUG(DBG_IRQ, "");\r\nusbvision->ctrl_urb_busy = 0;\r\nif (waitqueue_active(&usbvision->ctrl_urb_wq))\r\nwake_up_interruptible(&usbvision->ctrl_urb_wq);\r\n}\r\nstatic int usbvision_write_reg_irq(struct usb_usbvision *usbvision, int address,\r\nunsigned char *data, int len)\r\n{\r\nint err_code = 0;\r\nPDEBUG(DBG_IRQ, "");\r\nif (len > 8)\r\nreturn -EFAULT;\r\nif (usbvision->ctrl_urb_busy)\r\nreturn -EBUSY;\r\nusbvision->ctrl_urb_busy = 1;\r\nusbvision->ctrl_urb_setup.bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT;\r\nusbvision->ctrl_urb_setup.bRequest = USBVISION_OP_CODE;\r\nusbvision->ctrl_urb_setup.wValue = 0;\r\nusbvision->ctrl_urb_setup.wIndex = cpu_to_le16(address);\r\nusbvision->ctrl_urb_setup.wLength = cpu_to_le16(len);\r\nusb_fill_control_urb(usbvision->ctrl_urb, usbvision->dev,\r\nusb_sndctrlpipe(usbvision->dev, 1),\r\n(unsigned char *)&usbvision->ctrl_urb_setup,\r\n(void *)usbvision->ctrl_urb_buffer, len,\r\nusbvision_ctrl_urb_complete,\r\n(void *)usbvision);\r\nmemcpy(usbvision->ctrl_urb_buffer, data, len);\r\nerr_code = usb_submit_urb(usbvision->ctrl_urb, GFP_ATOMIC);\r\nif (err_code < 0) {\r\nusbvision->ctrl_urb_busy = 0;\r\n}\r\nPDEBUG(DBG_IRQ, "submit %d byte: error %d", len, err_code);\r\nreturn err_code;\r\n}\r\nstatic int usbvision_init_compression(struct usb_usbvision *usbvision)\r\n{\r\nusbvision->last_isoc_frame_num = -1;\r\nusbvision->isoc_data_count = 0;\r\nusbvision->isoc_packet_count = 0;\r\nusbvision->isoc_skip_count = 0;\r\nusbvision->compr_level = 50;\r\nusbvision->last_compr_level = -1;\r\nusbvision->isoc_urb_count = 0;\r\nusbvision->request_intra = 1;\r\nusbvision->isoc_measure_bandwidth_count = 0;\r\nreturn 0;\r\n}\r\nstatic int usbvision_measure_bandwidth(struct usb_usbvision *usbvision)\r\n{\r\nif (usbvision->isoc_measure_bandwidth_count < 2) {\r\nusbvision->isoc_measure_bandwidth_count++;\r\nreturn 0;\r\n}\r\nif ((usbvision->isoc_packet_size > 0) && (usbvision->isoc_packet_count > 0)) {\r\nusbvision->used_bandwidth = usbvision->isoc_data_count /\r\n(usbvision->isoc_packet_count + usbvision->isoc_skip_count) *\r\n100 / usbvision->isoc_packet_size;\r\n}\r\nusbvision->isoc_measure_bandwidth_count = 0;\r\nusbvision->isoc_data_count = 0;\r\nusbvision->isoc_packet_count = 0;\r\nusbvision->isoc_skip_count = 0;\r\nreturn 0;\r\n}\r\nstatic int usbvision_adjust_compression(struct usb_usbvision *usbvision)\r\n{\r\nint err_code = 0;\r\nunsigned char buffer[6];\r\nPDEBUG(DBG_IRQ, "");\r\nif ((adjust_compression) && (usbvision->used_bandwidth > 0)) {\r\nusbvision->compr_level += (usbvision->used_bandwidth - 90) / 2;\r\nRESTRICT_TO_RANGE(usbvision->compr_level, 0, 100);\r\nif (usbvision->compr_level != usbvision->last_compr_level) {\r\nint distortion;\r\nif (usbvision->bridge_type == BRIDGE_NT1004 || usbvision->bridge_type == BRIDGE_NT1005) {\r\nbuffer[0] = (unsigned char)(4 + 16 * usbvision->compr_level / 100);\r\nbuffer[1] = (unsigned char)(4 + 8 * usbvision->compr_level / 100);\r\ndistortion = 7 + 248 * usbvision->compr_level / 100;\r\nbuffer[2] = (unsigned char)(distortion & 0xFF);\r\nbuffer[3] = (unsigned char)(distortion & 0xFF);\r\ndistortion = 1 + 42 * usbvision->compr_level / 100;\r\nbuffer[4] = (unsigned char)(distortion & 0xFF);\r\nbuffer[5] = (unsigned char)(distortion & 0xFF);\r\n} else {\r\nbuffer[0] = (unsigned char)(4 + 16 * usbvision->compr_level / 100);\r\nbuffer[1] = (unsigned char)(4 + 8 * usbvision->compr_level / 100);\r\ndistortion = 2 + 253 * usbvision->compr_level / 100;\r\nbuffer[2] = (unsigned char)(distortion & 0xFF);\r\nbuffer[3] = 0;\r\ndistortion = 0 + 43 * usbvision->compr_level / 100;\r\nbuffer[4] = (unsigned char)(distortion & 0xFF);\r\nbuffer[5] = 0;\r\n}\r\nerr_code = usbvision_write_reg_irq(usbvision, USBVISION_PCM_THR1, buffer, 6);\r\nif (err_code == 0) {\r\nPDEBUG(DBG_IRQ, "new compr params %#02x %#02x %#02x %#02x %#02x %#02x", buffer[0],\r\nbuffer[1], buffer[2], buffer[3], buffer[4], buffer[5]);\r\nusbvision->last_compr_level = usbvision->compr_level;\r\n}\r\n}\r\n}\r\nreturn err_code;\r\n}\r\nstatic int usbvision_request_intra(struct usb_usbvision *usbvision)\r\n{\r\nunsigned char buffer[1];\r\nPDEBUG(DBG_IRQ, "");\r\nusbvision->request_intra = 1;\r\nbuffer[0] = 1;\r\nusbvision_write_reg_irq(usbvision, USBVISION_FORCE_INTRA, buffer, 1);\r\nreturn 0;\r\n}\r\nstatic int usbvision_unrequest_intra(struct usb_usbvision *usbvision)\r\n{\r\nunsigned char buffer[1];\r\nPDEBUG(DBG_IRQ, "");\r\nusbvision->request_intra = 0;\r\nbuffer[0] = 0;\r\nusbvision_write_reg_irq(usbvision, USBVISION_FORCE_INTRA, buffer, 1);\r\nreturn 0;\r\n}\r\nint usbvision_power_off(struct usb_usbvision *usbvision)\r\n{\r\nint err_code = 0;\r\nPDEBUG(DBG_FUNC, "");\r\nerr_code = usbvision_write_reg(usbvision, USBVISION_PWR_REG, USBVISION_SSPND_EN);\r\nif (err_code == 1)\r\nusbvision->power = 0;\r\nPDEBUG(DBG_FUNC, "%s: err_code %d", (err_code != 1) ? "ERROR" : "power is off", err_code);\r\nreturn err_code;\r\n}\r\nstatic int usbvision_init_webcam(struct usb_usbvision *usbvision)\r\n{\r\nint rc;\r\nint i;\r\nstatic char init_values[38][3] = {\r\n{ 0x04, 0x12, 0x08 }, { 0x05, 0xff, 0xc8 }, { 0x06, 0x18, 0x07 }, { 0x07, 0x90, 0x00 },\r\n{ 0x09, 0x00, 0x00 }, { 0x0a, 0x00, 0x00 }, { 0x0b, 0x08, 0x00 }, { 0x0d, 0xcc, 0xcc },\r\n{ 0x0e, 0x13, 0x14 }, { 0x10, 0x9b, 0x83 }, { 0x11, 0x5a, 0x3f }, { 0x12, 0xe4, 0x73 },\r\n{ 0x13, 0x88, 0x84 }, { 0x14, 0x89, 0x80 }, { 0x15, 0x00, 0x20 }, { 0x16, 0x00, 0x00 },\r\n{ 0x17, 0xff, 0xa0 }, { 0x18, 0x6b, 0x20 }, { 0x19, 0x22, 0x40 }, { 0x1a, 0x10, 0x07 },\r\n{ 0x1b, 0x00, 0x47 }, { 0x1c, 0x03, 0xe0 }, { 0x1d, 0x00, 0x00 }, { 0x1e, 0x00, 0x00 },\r\n{ 0x1f, 0x00, 0x00 }, { 0x20, 0x00, 0x00 }, { 0x21, 0x00, 0x00 }, { 0x22, 0x00, 0x00 },\r\n{ 0x23, 0x00, 0x00 }, { 0x24, 0x00, 0x00 }, { 0x25, 0x00, 0x00 }, { 0x26, 0x00, 0x00 },\r\n{ 0x27, 0x00, 0x00 }, { 0x28, 0x00, 0x00 }, { 0x29, 0x00, 0x00 }, { 0x08, 0x80, 0x60 },\r\n{ 0x0f, 0x2d, 0x24 }, { 0x0c, 0x80, 0x80 }\r\n};\r\nchar value[3];\r\nif (usbvision_device_data[usbvision->dev_model].video_norm == V4L2_STD_NTSC)\r\ninit_values[4][1] = 0x34;\r\nfor (i = 0; i < sizeof(init_values) / 3; i++) {\r\nusbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_SER_MODE_SOFT);\r\nmemcpy(value, init_values[i], 3);\r\nrc = usb_control_msg(usbvision->dev,\r\nusb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_ENDPOINT, 0,\r\n(__u16) USBVISION_SER_DAT1, value,\r\n3, HZ);\r\nif (rc < 0)\r\nreturn rc;\r\nusbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_SER_MODE_SIO);\r\nusbvision_write_reg(usbvision, USBVISION_SER_CONT, 3 | 0x10);\r\nusbvision_write_reg(usbvision, USBVISION_IOPIN_REG, 0);\r\nusbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_SER_MODE_SOFT);\r\nusbvision_write_reg(usbvision, USBVISION_IOPIN_REG, USBVISION_IO_2);\r\nusbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_SER_MODE_SOFT | USBVISION_CLK_OUT);\r\nusbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_SER_MODE_SOFT | USBVISION_DAT_IO);\r\nusbvision_write_reg(usbvision, USBVISION_SER_MODE, USBVISION_SER_MODE_SOFT | USBVISION_CLK_OUT | USBVISION_DAT_IO);\r\n}\r\nreturn 0;\r\n}\r\nstatic int usbvision_set_video_format(struct usb_usbvision *usbvision, int format)\r\n{\r\nstatic const char proc[] = "usbvision_set_video_format";\r\nint rc;\r\nunsigned char value[2];\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn 0;\r\nPDEBUG(DBG_FUNC, "isoc_mode %#02x", format);\r\nif ((format != ISOC_MODE_YUV422)\r\n&& (format != ISOC_MODE_YUV420)\r\n&& (format != ISOC_MODE_COMPRESS)) {\r\nprintk(KERN_ERR "usbvision: unknown video format %02x, using default YUV420",\r\nformat);\r\nformat = ISOC_MODE_YUV420;\r\n}\r\nvalue[0] = 0x0A;\r\nvalue[1] = format;\r\nrc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_ENDPOINT, 0,\r\n(__u16) USBVISION_FILT_CONT, value, 2, HZ);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%s: ERROR=%d. USBVISION stopped - "\r\n"reconnect or reload driver.\n", proc, rc);\r\n}\r\nusbvision->isoc_mode = format;\r\nreturn rc;\r\n}\r\nint usbvision_set_output(struct usb_usbvision *usbvision, int width,\r\nint height)\r\n{\r\nint err_code = 0;\r\nint usb_width, usb_height;\r\nunsigned int frame_rate = 0, frame_drop = 0;\r\nunsigned char value[4];\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn 0;\r\nif (width > MAX_USB_WIDTH) {\r\nusb_width = width / 2;\r\nusbvision->stretch_width = 2;\r\n} else {\r\nusb_width = width;\r\nusbvision->stretch_width = 1;\r\n}\r\nif (height > MAX_USB_HEIGHT) {\r\nusb_height = height / 2;\r\nusbvision->stretch_height = 2;\r\n} else {\r\nusb_height = height;\r\nusbvision->stretch_height = 1;\r\n}\r\nRESTRICT_TO_RANGE(usb_width, MIN_FRAME_WIDTH, MAX_USB_WIDTH);\r\nusb_width &= ~(MIN_FRAME_WIDTH-1);\r\nRESTRICT_TO_RANGE(usb_height, MIN_FRAME_HEIGHT, MAX_USB_HEIGHT);\r\nusb_height &= ~(1);\r\nPDEBUG(DBG_FUNC, "usb %dx%d; screen %dx%d; stretch %dx%d",\r\nusb_width, usb_height, width, height,\r\nusbvision->stretch_width, usbvision->stretch_height);\r\nif ((usb_width != usbvision->curwidth) || (usb_height != usbvision->curheight)) {\r\nvalue[0] = usb_width & 0xff;\r\nvalue[1] = (usb_width >> 8) & 0x03;\r\nvalue[2] = usb_height & 0xff;\r\nvalue[3] = (usb_height >> 8) & 0x03;\r\nerr_code = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT,\r\n0, (__u16) USBVISION_LXSIZE_O, value, 4, HZ);\r\nif (err_code < 0) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s failed: error %d\n", __func__, err_code);\r\nreturn err_code;\r\n}\r\nusbvision->curwidth = usbvision->stretch_width * usb_width;\r\nusbvision->curheight = usbvision->stretch_height * usb_height;\r\n}\r\nif (usbvision->isoc_mode == ISOC_MODE_YUV422)\r\nframe_rate = (usbvision->isoc_packet_size * 1000) / (usb_width * usb_height * 2);\r\nelse if (usbvision->isoc_mode == ISOC_MODE_YUV420)\r\nframe_rate = (usbvision->isoc_packet_size * 1000) / ((usb_width * usb_height * 12) / 8);\r\nelse\r\nframe_rate = FRAMERATE_MAX;\r\nif (usbvision->tvnorm_id & V4L2_STD_625_50)\r\nframe_drop = frame_rate * 32 / 25 - 1;\r\nelse if (usbvision->tvnorm_id & V4L2_STD_525_60)\r\nframe_drop = frame_rate * 32 / 30 - 1;\r\nRESTRICT_TO_RANGE(frame_drop, FRAMERATE_MIN, FRAMERATE_MAX);\r\nPDEBUG(DBG_FUNC, "frame_rate %d fps, frame_drop %d", frame_rate, frame_drop);\r\nframe_drop = FRAMERATE_MAX;\r\nif (usbvision_device_data[usbvision->dev_model].codec == CODEC_WEBCAM) {\r\nif (usbvision_device_data[usbvision->dev_model].video_norm == V4L2_STD_PAL)\r\nframe_drop = 25;\r\nelse\r\nframe_drop = 30;\r\n}\r\nerr_code = usbvision_write_reg(usbvision, USBVISION_FRM_RATE, frame_drop);\r\nreturn err_code;\r\n}\r\nint usbvision_frames_alloc(struct usb_usbvision *usbvision, int number_of_frames)\r\n{\r\nint i;\r\nusbvision->max_frame_size = PAGE_ALIGN(usbvision->curwidth *\r\nusbvision->curheight *\r\nusbvision->palette.bytes_per_pixel);\r\nusbvision->num_frames = number_of_frames;\r\nwhile (usbvision->num_frames > 0) {\r\nusbvision->fbuf_size = usbvision->num_frames * usbvision->max_frame_size;\r\nusbvision->fbuf = usbvision_rvmalloc(usbvision->fbuf_size);\r\nif (usbvision->fbuf)\r\nbreak;\r\nusbvision->num_frames--;\r\n}\r\nspin_lock_init(&usbvision->queue_lock);\r\ninit_waitqueue_head(&usbvision->wait_frame);\r\ninit_waitqueue_head(&usbvision->wait_stream);\r\nfor (i = 0; i < usbvision->num_frames; i++) {\r\nusbvision->frame[i].index = i;\r\nusbvision->frame[i].grabstate = frame_state_unused;\r\nusbvision->frame[i].data = usbvision->fbuf +\r\ni * usbvision->max_frame_size;\r\nusbvision->stretch_width = 1;\r\nusbvision->stretch_height = 1;\r\nusbvision->frame[i].width = usbvision->curwidth;\r\nusbvision->frame[i].height = usbvision->curheight;\r\nusbvision->frame[i].bytes_read = 0;\r\n}\r\nPDEBUG(DBG_FUNC, "allocated %d frames (%d bytes per frame)",\r\nusbvision->num_frames, usbvision->max_frame_size);\r\nreturn usbvision->num_frames;\r\n}\r\nvoid usbvision_frames_free(struct usb_usbvision *usbvision)\r\n{\r\nPDEBUG(DBG_FUNC, "free %d frames", usbvision->num_frames);\r\nif (usbvision->fbuf != NULL) {\r\nusbvision_rvfree(usbvision->fbuf, usbvision->fbuf_size);\r\nusbvision->fbuf = NULL;\r\nusbvision->num_frames = 0;\r\n}\r\n}\r\nvoid usbvision_empty_framequeues(struct usb_usbvision *usbvision)\r\n{\r\nu32 i;\r\nINIT_LIST_HEAD(&(usbvision->inqueue));\r\nINIT_LIST_HEAD(&(usbvision->outqueue));\r\nfor (i = 0; i < USBVISION_NUMFRAMES; i++) {\r\nusbvision->frame[i].grabstate = frame_state_unused;\r\nusbvision->frame[i].bytes_read = 0;\r\n}\r\n}\r\nint usbvision_stream_interrupt(struct usb_usbvision *usbvision)\r\n{\r\nint ret = 0;\r\nusbvision->streaming = stream_interrupt;\r\nret = wait_event_timeout(usbvision->wait_stream,\r\n(usbvision->streaming == stream_idle),\r\nmsecs_to_jiffies(USBVISION_NUMSBUF*USBVISION_URB_FRAMES));\r\nreturn ret;\r\n}\r\nstatic int usbvision_set_compress_params(struct usb_usbvision *usbvision)\r\n{\r\nstatic const char proc[] = "usbvision_set_compresion_params: ";\r\nint rc;\r\nunsigned char value[6];\r\nvalue[0] = 0x0F;\r\nvalue[1] = 0x01;\r\nvalue[2] = 0x00;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0xA2;\r\nvalue[5] = 0x00;\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn 0;\r\nrc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_ENDPOINT, 0,\r\n(__u16) USBVISION_INTRA_CYC, value, 5, HZ);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%sERROR=%d. USBVISION stopped - "\r\n"reconnect or reload driver.\n", proc, rc);\r\nreturn rc;\r\n}\r\nif (usbvision->bridge_type == BRIDGE_NT1004) {\r\nvalue[0] = 20;\r\nvalue[1] = 12;\r\nvalue[2] = 255;\r\nvalue[3] = 255;\r\nvalue[4] = 43;\r\nvalue[5] = 43;\r\n} else {\r\nvalue[0] = 20;\r\nvalue[1] = 12;\r\nvalue[2] = 255;\r\nvalue[3] = 0;\r\nvalue[4] = 43;\r\nvalue[5] = 0;\r\n}\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn 0;\r\nrc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_ENDPOINT, 0,\r\n(__u16) USBVISION_PCM_THR1, value, 6, HZ);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%sERROR=%d. USBVISION stopped - "\r\n"reconnect or reload driver.\n", proc, rc);\r\n}\r\nreturn rc;\r\n}\r\nint usbvision_set_input(struct usb_usbvision *usbvision)\r\n{\r\nstatic const char proc[] = "usbvision_set_input: ";\r\nint rc;\r\nunsigned char value[8];\r\nunsigned char dvi_yuv_value;\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn 0;\r\nif (usbvision_device_data[usbvision->dev_model].vin_reg1_override) {\r\nvalue[0] = usbvision_device_data[usbvision->dev_model].vin_reg1;\r\n} else if (usbvision_device_data[usbvision->dev_model].codec == CODEC_SAA7113) {\r\nvalue[0] = USBVISION_8_422_SYNC;\r\n} else {\r\nvalue[0] = USBVISION_16_422_SYNC;\r\n}\r\nrc = usbvision_write_reg(usbvision, USBVISION_VIN_REG1, value[0]);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%sERROR=%d. USBVISION stopped - "\r\n"reconnect or reload driver.\n", proc, rc);\r\nreturn rc;\r\n}\r\nif (usbvision->tvnorm_id & V4L2_STD_PAL) {\r\nvalue[0] = 0xC0;\r\nvalue[1] = 0x02;\r\nvalue[2] = 0x20;\r\nvalue[3] = 0x01;\r\nvalue[4] = 0x60;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x16;\r\nvalue[7] = 0x00;\r\n} else if (usbvision->tvnorm_id & V4L2_STD_SECAM) {\r\nvalue[0] = 0xC0;\r\nvalue[1] = 0x02;\r\nvalue[2] = 0x20;\r\nvalue[3] = 0x01;\r\nvalue[4] = 0x01;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x01;\r\nvalue[7] = 0x00;\r\n} else {\r\nvalue[0] = 0xD0;\r\nvalue[1] = 0x02;\r\nvalue[2] = 0xF0;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x50;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x10;\r\nvalue[7] = 0x00;\r\n}\r\nif (usbvision_device_data[usbvision->dev_model].codec == CODEC_WEBCAM) {\r\nvalue[0] = 0xe0;\r\nvalue[1] = 0x01;\r\n}\r\nif (usbvision_device_data[usbvision->dev_model].x_offset >= 0) {\r\nvalue[4] = usbvision_device_data[usbvision->dev_model].x_offset & 0xff;\r\nvalue[5] = (usbvision_device_data[usbvision->dev_model].x_offset & 0x0300) >> 8;\r\n}\r\nif (adjust_x_offset != -1) {\r\nvalue[4] = adjust_x_offset & 0xff;\r\nvalue[5] = (adjust_x_offset & 0x0300) >> 8;\r\n}\r\nif (usbvision_device_data[usbvision->dev_model].y_offset >= 0) {\r\nvalue[6] = usbvision_device_data[usbvision->dev_model].y_offset & 0xff;\r\nvalue[7] = (usbvision_device_data[usbvision->dev_model].y_offset & 0x0300) >> 8;\r\n}\r\nif (adjust_y_offset != -1) {\r\nvalue[6] = adjust_y_offset & 0xff;\r\nvalue[7] = (adjust_y_offset & 0x0300) >> 8;\r\n}\r\nrc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_ENDPOINT, 0,\r\n(__u16) USBVISION_LXSIZE_I, value, 8, HZ);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%sERROR=%d. USBVISION stopped - "\r\n"reconnect or reload driver.\n", proc, rc);\r\nreturn rc;\r\n}\r\ndvi_yuv_value = 0x00;\r\nif (usbvision_device_data[usbvision->dev_model].dvi_yuv_override) {\r\ndvi_yuv_value = usbvision_device_data[usbvision->dev_model].dvi_yuv;\r\n} else if (usbvision_device_data[usbvision->dev_model].codec == CODEC_SAA7113) {\r\ndvi_yuv_value = 0x06;\r\n}\r\nreturn usbvision_write_reg(usbvision, USBVISION_DVI_YUV, dvi_yuv_value);\r\n}\r\nstatic int usbvision_set_dram_settings(struct usb_usbvision *usbvision)\r\n{\r\nint rc;\r\nunsigned char value[8];\r\nif (usbvision->isoc_mode == ISOC_MODE_COMPRESS) {\r\nvalue[0] = 0x42;\r\nvalue[1] = 0x71;\r\nvalue[2] = 0xff;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x98;\r\nvalue[5] = 0xe0;\r\nvalue[6] = 0x71;\r\nvalue[7] = 0xff;\r\n} else {\r\nvalue[0] = 0x42;\r\nvalue[1] = 0x00;\r\nvalue[2] = 0xff;\r\nvalue[3] = 0x00;\r\nvalue[4] = 0x00;\r\nvalue[5] = 0x00;\r\nvalue[6] = 0x00;\r\nvalue[7] = 0xff;\r\n}\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn 0;\r\nrc = usb_control_msg(usbvision->dev, usb_sndctrlpipe(usbvision->dev, 1),\r\nUSBVISION_OP_CODE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_ENDPOINT, 0,\r\n(__u16) USBVISION_DRM_PRM1, value, 8, HZ);\r\nif (rc < 0) {\r\ndev_err(&usbvision->dev->dev, "%s: ERROR=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = usbvision_write_reg(usbvision, USBVISION_DRM_CONT, USBVISION_RES_UR |\r\nUSBVISION_RES_FDL | USBVISION_RES_VDW);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = usbvision_write_reg(usbvision, USBVISION_DRM_CONT, 0x00);\r\nreturn rc;\r\n}\r\nint usbvision_power_on(struct usb_usbvision *usbvision)\r\n{\r\nint err_code = 0;\r\nPDEBUG(DBG_FUNC, "");\r\nusbvision_write_reg(usbvision, USBVISION_PWR_REG, USBVISION_SSPND_EN);\r\nusbvision_write_reg(usbvision, USBVISION_PWR_REG,\r\nUSBVISION_SSPND_EN | USBVISION_RES2);\r\nif (usbvision_device_data[usbvision->dev_model].codec == CODEC_WEBCAM) {\r\nusbvision_write_reg(usbvision, USBVISION_VIN_REG1,\r\nUSBVISION_16_422_SYNC | USBVISION_HVALID_PO);\r\nusbvision_write_reg(usbvision, USBVISION_VIN_REG2,\r\nUSBVISION_NOHVALID | USBVISION_KEEP_BLANK);\r\n}\r\nusbvision_write_reg(usbvision, USBVISION_PWR_REG,\r\nUSBVISION_SSPND_EN | USBVISION_PWR_VID);\r\nmdelay(10);\r\nerr_code = usbvision_write_reg(usbvision, USBVISION_PWR_REG,\r\nUSBVISION_SSPND_EN | USBVISION_PWR_VID | USBVISION_RES2);\r\nif (err_code == 1)\r\nusbvision->power = 1;\r\nPDEBUG(DBG_FUNC, "%s: err_code %d", (err_code < 0) ? "ERROR" : "power is on", err_code);\r\nreturn err_code;\r\n}\r\nstatic void call_usbvision_power_off(struct work_struct *work)\r\n{\r\nstruct usb_usbvision *usbvision = container_of(work, struct usb_usbvision, power_off_work);\r\nPDEBUG(DBG_FUNC, "");\r\nif (mutex_lock_interruptible(&usbvision->v4l2_lock))\r\nreturn;\r\nif (usbvision->user == 0) {\r\nusbvision_i2c_unregister(usbvision);\r\nusbvision_power_off(usbvision);\r\nusbvision->initialized = 0;\r\n}\r\nmutex_unlock(&usbvision->v4l2_lock);\r\n}\r\nstatic void usbvision_power_off_timer(unsigned long data)\r\n{\r\nstruct usb_usbvision *usbvision = (void *)data;\r\nPDEBUG(DBG_FUNC, "");\r\ndel_timer(&usbvision->power_off_timer);\r\nINIT_WORK(&usbvision->power_off_work, call_usbvision_power_off);\r\n(void) schedule_work(&usbvision->power_off_work);\r\n}\r\nvoid usbvision_init_power_off_timer(struct usb_usbvision *usbvision)\r\n{\r\ninit_timer(&usbvision->power_off_timer);\r\nusbvision->power_off_timer.data = (long)usbvision;\r\nusbvision->power_off_timer.function = usbvision_power_off_timer;\r\n}\r\nvoid usbvision_set_power_off_timer(struct usb_usbvision *usbvision)\r\n{\r\nmod_timer(&usbvision->power_off_timer, jiffies + USBVISION_POWEROFF_TIME);\r\n}\r\nvoid usbvision_reset_power_off_timer(struct usb_usbvision *usbvision)\r\n{\r\nif (timer_pending(&usbvision->power_off_timer))\r\ndel_timer(&usbvision->power_off_timer);\r\n}\r\nint usbvision_begin_streaming(struct usb_usbvision *usbvision)\r\n{\r\nif (usbvision->isoc_mode == ISOC_MODE_COMPRESS)\r\nusbvision_init_compression(usbvision);\r\nreturn usbvision_write_reg(usbvision, USBVISION_VIN_REG2,\r\nUSBVISION_NOHVALID | usbvision->vin_reg2_preset);\r\n}\r\nint usbvision_restart_isoc(struct usb_usbvision *usbvision)\r\n{\r\nint ret;\r\nret = usbvision_write_reg(usbvision, USBVISION_PWR_REG,\r\nUSBVISION_SSPND_EN | USBVISION_PWR_VID);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usbvision_write_reg(usbvision, USBVISION_PWR_REG,\r\nUSBVISION_SSPND_EN | USBVISION_PWR_VID |\r\nUSBVISION_RES2);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usbvision_write_reg(usbvision, USBVISION_VIN_REG2,\r\nUSBVISION_KEEP_BLANK | USBVISION_NOHVALID |\r\nusbvision->vin_reg2_preset);\r\nif (ret < 0)\r\nreturn ret;\r\nwhile ((usbvision_read_reg(usbvision, USBVISION_STATUS_REG) & 0x01) != 1)\r\n;\r\nreturn 0;\r\n}\r\nint usbvision_audio_off(struct usb_usbvision *usbvision)\r\n{\r\nif (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, USBVISION_AUDIO_MUTE) < 0) {\r\nprintk(KERN_ERR "usbvision_audio_off: can't write reg\n");\r\nreturn -1;\r\n}\r\nusbvision->audio_mute = 0;\r\nusbvision->audio_channel = USBVISION_AUDIO_MUTE;\r\nreturn 0;\r\n}\r\nint usbvision_set_audio(struct usb_usbvision *usbvision, int audio_channel)\r\n{\r\nif (!usbvision->audio_mute) {\r\nif (usbvision_write_reg(usbvision, USBVISION_IOPIN_REG, audio_channel) < 0) {\r\nprintk(KERN_ERR "usbvision_set_audio: can't write iopin register for audio switching\n");\r\nreturn -1;\r\n}\r\n}\r\nusbvision->audio_channel = audio_channel;\r\nreturn 0;\r\n}\r\nint usbvision_setup(struct usb_usbvision *usbvision, int format)\r\n{\r\nif (usbvision_device_data[usbvision->dev_model].codec == CODEC_WEBCAM)\r\nusbvision_init_webcam(usbvision);\r\nusbvision_set_video_format(usbvision, format);\r\nusbvision_set_dram_settings(usbvision);\r\nusbvision_set_compress_params(usbvision);\r\nusbvision_set_input(usbvision);\r\nusbvision_set_output(usbvision, MAX_USB_WIDTH, MAX_USB_HEIGHT);\r\nusbvision_restart_isoc(usbvision);\r\nreturn USBVISION_IS_OPERATIONAL(usbvision);\r\n}\r\nint usbvision_set_alternate(struct usb_usbvision *dev)\r\n{\r\nint err_code, prev_alt = dev->iface_alt;\r\nint i;\r\ndev->iface_alt = 0;\r\nfor (i = 0; i < dev->num_alt; i++)\r\nif (dev->alt_max_pkt_size[i] > dev->alt_max_pkt_size[dev->iface_alt])\r\ndev->iface_alt = i;\r\nif (dev->iface_alt != prev_alt) {\r\ndev->isoc_packet_size = dev->alt_max_pkt_size[dev->iface_alt];\r\nPDEBUG(DBG_FUNC, "setting alternate %d with max_packet_size=%u",\r\ndev->iface_alt, dev->isoc_packet_size);\r\nerr_code = usb_set_interface(dev->dev, dev->iface, dev->iface_alt);\r\nif (err_code < 0) {\r\ndev_err(&dev->dev->dev,\r\n"cannot change alternate number to %d (error=%i)\n",\r\ndev->iface_alt, err_code);\r\nreturn err_code;\r\n}\r\n}\r\nPDEBUG(DBG_ISOC, "ISO Packet Length:%d", dev->isoc_packet_size);\r\nreturn 0;\r\n}\r\nint usbvision_init_isoc(struct usb_usbvision *usbvision)\r\n{\r\nstruct usb_device *dev = usbvision->dev;\r\nint buf_idx, err_code, reg_value;\r\nint sb_size;\r\nif (!USBVISION_IS_OPERATIONAL(usbvision))\r\nreturn -EFAULT;\r\nusbvision->cur_frame = NULL;\r\nscratch_reset(usbvision);\r\nerr_code = usbvision_set_alternate(usbvision);\r\nif (err_code < 0) {\r\nusbvision->last_error = err_code;\r\nreturn -EBUSY;\r\n}\r\nsb_size = USBVISION_URB_FRAMES * usbvision->isoc_packet_size;\r\nreg_value = (16 - usbvision_read_reg(usbvision,\r\nUSBVISION_ALTER_REG)) & 0x0F;\r\nusbvision->usb_bandwidth = reg_value >> 1;\r\nPDEBUG(DBG_ISOC, "USB Bandwidth Usage: %dMbit/Sec",\r\nusbvision->usb_bandwidth);\r\nfor (buf_idx = 0; buf_idx < USBVISION_NUMSBUF; buf_idx++) {\r\nint j, k;\r\nstruct urb *urb;\r\nurb = usb_alloc_urb(USBVISION_URB_FRAMES, GFP_KERNEL);\r\nif (urb == NULL) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: usb_alloc_urb() failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nusbvision->sbuf[buf_idx].urb = urb;\r\nusbvision->sbuf[buf_idx].data =\r\nusb_alloc_coherent(usbvision->dev,\r\nsb_size,\r\nGFP_KERNEL,\r\n&urb->transfer_dma);\r\nurb->dev = dev;\r\nurb->context = usbvision;\r\nurb->pipe = usb_rcvisocpipe(dev, usbvision->video_endp);\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nurb->interval = 1;\r\nurb->transfer_buffer = usbvision->sbuf[buf_idx].data;\r\nurb->complete = usbvision_isoc_irq;\r\nurb->number_of_packets = USBVISION_URB_FRAMES;\r\nurb->transfer_buffer_length =\r\nusbvision->isoc_packet_size * USBVISION_URB_FRAMES;\r\nfor (j = k = 0; j < USBVISION_URB_FRAMES; j++,\r\nk += usbvision->isoc_packet_size) {\r\nurb->iso_frame_desc[j].offset = k;\r\nurb->iso_frame_desc[j].length =\r\nusbvision->isoc_packet_size;\r\n}\r\n}\r\nfor (buf_idx = 0; buf_idx < USBVISION_NUMSBUF; buf_idx++) {\r\nerr_code = usb_submit_urb(usbvision->sbuf[buf_idx].urb,\r\nGFP_KERNEL);\r\nif (err_code) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: usb_submit_urb(%d) failed: error %d\n",\r\n__func__, buf_idx, err_code);\r\n}\r\n}\r\nusbvision->streaming = stream_idle;\r\nPDEBUG(DBG_ISOC, "%s: streaming=1 usbvision->video_endp=$%02x",\r\n__func__,\r\nusbvision->video_endp);\r\nreturn 0;\r\n}\r\nvoid usbvision_stop_isoc(struct usb_usbvision *usbvision)\r\n{\r\nint buf_idx, err_code, reg_value;\r\nint sb_size = USBVISION_URB_FRAMES * usbvision->isoc_packet_size;\r\nif ((usbvision->streaming == stream_off) || (usbvision->dev == NULL))\r\nreturn;\r\nfor (buf_idx = 0; buf_idx < USBVISION_NUMSBUF; buf_idx++) {\r\nusb_kill_urb(usbvision->sbuf[buf_idx].urb);\r\nif (usbvision->sbuf[buf_idx].data) {\r\nusb_free_coherent(usbvision->dev,\r\nsb_size,\r\nusbvision->sbuf[buf_idx].data,\r\nusbvision->sbuf[buf_idx].urb->transfer_dma);\r\n}\r\nusb_free_urb(usbvision->sbuf[buf_idx].urb);\r\nusbvision->sbuf[buf_idx].urb = NULL;\r\n}\r\nPDEBUG(DBG_ISOC, "%s: streaming=stream_off\n", __func__);\r\nusbvision->streaming = stream_off;\r\nif (!usbvision->remove_pending) {\r\nusbvision->iface_alt = 0;\r\nerr_code = usb_set_interface(usbvision->dev, usbvision->iface,\r\nusbvision->iface_alt);\r\nif (err_code < 0) {\r\ndev_err(&usbvision->dev->dev,\r\n"%s: usb_set_interface() failed: error %d\n",\r\n__func__, err_code);\r\nusbvision->last_error = err_code;\r\n}\r\nreg_value = (16-usbvision_read_reg(usbvision, USBVISION_ALTER_REG)) & 0x0F;\r\nusbvision->isoc_packet_size =\r\n(reg_value == 0) ? 0 : (reg_value * 64) - 1;\r\nPDEBUG(DBG_ISOC, "ISO Packet Length:%d",\r\nusbvision->isoc_packet_size);\r\nusbvision->usb_bandwidth = reg_value >> 1;\r\nPDEBUG(DBG_ISOC, "USB Bandwidth Usage: %dMbit/Sec",\r\nusbvision->usb_bandwidth);\r\n}\r\n}\r\nint usbvision_muxsel(struct usb_usbvision *usbvision, int channel)\r\n{\r\nint mode[4] = { SAA7115_COMPOSITE0, 0, 0, SAA7115_COMPOSITE3 };\r\nint audio[] = { 1, 0, 0, 0 };\r\nRESTRICT_TO_RANGE(channel, 0, usbvision->video_inputs);\r\nusbvision->ctl_input = channel;\r\nswitch (usbvision_device_data[usbvision->dev_model].codec) {\r\ncase CODEC_SAA7113:\r\nmode[1] = SAA7115_COMPOSITE2;\r\nif (switch_svideo_input) {\r\nmode[2] = SAA7115_COMPOSITE1;\r\n} else {\r\nmode[2] = SAA7115_SVIDEO1;\r\n}\r\nbreak;\r\ncase CODEC_SAA7111:\r\ndefault:\r\nmode[1] = SAA7115_COMPOSITE1;\r\nmode[2] = SAA7115_SVIDEO1;\r\nbreak;\r\n}\r\ncall_all(usbvision, video, s_routing, mode[channel], 0, 0);\r\nusbvision_set_audio(usbvision, audio[channel]);\r\nreturn 0;\r\n}
