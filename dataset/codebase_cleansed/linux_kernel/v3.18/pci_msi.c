static irqreturn_t sparc64_msiq_interrupt(int irq, void *cookie)\r\n{\r\nstruct sparc64_msiq_cookie *msiq_cookie = cookie;\r\nstruct pci_pbm_info *pbm = msiq_cookie->pbm;\r\nunsigned long msiqid = msiq_cookie->msiqid;\r\nconst struct sparc64_msiq_ops *ops;\r\nunsigned long orig_head, head;\r\nint err;\r\nops = pbm->msi_ops;\r\nerr = ops->get_head(pbm, msiqid, &head);\r\nif (unlikely(err < 0))\r\ngoto err_get_head;\r\norig_head = head;\r\nfor (;;) {\r\nunsigned long msi;\r\nerr = ops->dequeue_msi(pbm, msiqid, &head, &msi);\r\nif (likely(err > 0)) {\r\nunsigned int irq;\r\nirq = pbm->msi_irq_table[msi - pbm->msi_first];\r\ngeneric_handle_irq(irq);\r\n}\r\nif (unlikely(err < 0))\r\ngoto err_dequeue;\r\nif (err == 0)\r\nbreak;\r\n}\r\nif (likely(head != orig_head)) {\r\nerr = ops->set_head(pbm, msiqid, head);\r\nif (unlikely(err < 0))\r\ngoto err_set_head;\r\n}\r\nreturn IRQ_HANDLED;\r\nerr_get_head:\r\nprintk(KERN_EMERG "MSI: Get head on msiqid[%lu] gives error %d\n",\r\nmsiqid, err);\r\ngoto err_out;\r\nerr_dequeue:\r\nprintk(KERN_EMERG "MSI: Dequeue head[%lu] from msiqid[%lu] "\r\n"gives error %d\n",\r\nhead, msiqid, err);\r\ngoto err_out;\r\nerr_set_head:\r\nprintk(KERN_EMERG "MSI: Set head[%lu] on msiqid[%lu] "\r\n"gives error %d\n",\r\nhead, msiqid, err);\r\ngoto err_out;\r\nerr_out:\r\nreturn IRQ_NONE;\r\n}\r\nstatic u32 pick_msiq(struct pci_pbm_info *pbm)\r\n{\r\nstatic DEFINE_SPINLOCK(rotor_lock);\r\nunsigned long flags;\r\nu32 ret, rotor;\r\nspin_lock_irqsave(&rotor_lock, flags);\r\nrotor = pbm->msiq_rotor;\r\nret = pbm->msiq_first + rotor;\r\nif (++rotor >= pbm->msiq_num)\r\nrotor = 0;\r\npbm->msiq_rotor = rotor;\r\nspin_unlock_irqrestore(&rotor_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int alloc_msi(struct pci_pbm_info *pbm)\r\n{\r\nint i;\r\nfor (i = 0; i < pbm->msi_num; i++) {\r\nif (!test_and_set_bit(i, pbm->msi_bitmap))\r\nreturn i + pbm->msi_first;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void free_msi(struct pci_pbm_info *pbm, int msi_num)\r\n{\r\nmsi_num -= pbm->msi_first;\r\nclear_bit(msi_num, pbm->msi_bitmap);\r\n}\r\nstatic int sparc64_setup_msi_irq(unsigned int *irq_p,\r\nstruct pci_dev *pdev,\r\nstruct msi_desc *entry)\r\n{\r\nstruct pci_pbm_info *pbm = pdev->dev.archdata.host_controller;\r\nconst struct sparc64_msiq_ops *ops = pbm->msi_ops;\r\nstruct msi_msg msg;\r\nint msi, err;\r\nu32 msiqid;\r\n*irq_p = irq_alloc(0, 0);\r\nerr = -ENOMEM;\r\nif (!*irq_p)\r\ngoto out_err;\r\nirq_set_chip_and_handler_name(*irq_p, &msi_irq, handle_simple_irq,\r\n"MSI");\r\nerr = alloc_msi(pbm);\r\nif (unlikely(err < 0))\r\ngoto out_irq_free;\r\nmsi = err;\r\nmsiqid = pick_msiq(pbm);\r\nerr = ops->msi_setup(pbm, msiqid, msi,\r\n(entry->msi_attrib.is_64 ? 1 : 0));\r\nif (err)\r\ngoto out_msi_free;\r\npbm->msi_irq_table[msi - pbm->msi_first] = *irq_p;\r\nif (entry->msi_attrib.is_64) {\r\nmsg.address_hi = pbm->msi64_start >> 32;\r\nmsg.address_lo = pbm->msi64_start & 0xffffffff;\r\n} else {\r\nmsg.address_hi = 0;\r\nmsg.address_lo = pbm->msi32_start;\r\n}\r\nmsg.data = msi;\r\nirq_set_msi_desc(*irq_p, entry);\r\nwrite_msi_msg(*irq_p, &msg);\r\nreturn 0;\r\nout_msi_free:\r\nfree_msi(pbm, msi);\r\nout_irq_free:\r\nirq_set_chip(*irq_p, NULL);\r\nirq_free(*irq_p);\r\n*irq_p = 0;\r\nout_err:\r\nreturn err;\r\n}\r\nstatic void sparc64_teardown_msi_irq(unsigned int irq,\r\nstruct pci_dev *pdev)\r\n{\r\nstruct pci_pbm_info *pbm = pdev->dev.archdata.host_controller;\r\nconst struct sparc64_msiq_ops *ops = pbm->msi_ops;\r\nunsigned int msi_num;\r\nint i, err;\r\nfor (i = 0; i < pbm->msi_num; i++) {\r\nif (pbm->msi_irq_table[i] == irq)\r\nbreak;\r\n}\r\nif (i >= pbm->msi_num) {\r\nprintk(KERN_ERR "%s: teardown: No MSI for irq %u\n",\r\npbm->name, irq);\r\nreturn;\r\n}\r\nmsi_num = pbm->msi_first + i;\r\npbm->msi_irq_table[i] = ~0U;\r\nerr = ops->msi_teardown(pbm, msi_num);\r\nif (err) {\r\nprintk(KERN_ERR "%s: teardown: ops->teardown() on MSI %u, "\r\n"irq %u, gives error %d\n",\r\npbm->name, msi_num, irq, err);\r\nreturn;\r\n}\r\nfree_msi(pbm, msi_num);\r\nirq_set_chip(irq, NULL);\r\nirq_free(irq);\r\n}\r\nstatic int msi_bitmap_alloc(struct pci_pbm_info *pbm)\r\n{\r\nunsigned long size, bits_per_ulong;\r\nbits_per_ulong = sizeof(unsigned long) * 8;\r\nsize = (pbm->msi_num + (bits_per_ulong - 1)) & ~(bits_per_ulong - 1);\r\nsize /= 8;\r\nBUG_ON(size % sizeof(unsigned long));\r\npbm->msi_bitmap = kzalloc(size, GFP_KERNEL);\r\nif (!pbm->msi_bitmap)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void msi_bitmap_free(struct pci_pbm_info *pbm)\r\n{\r\nkfree(pbm->msi_bitmap);\r\npbm->msi_bitmap = NULL;\r\n}\r\nstatic int msi_table_alloc(struct pci_pbm_info *pbm)\r\n{\r\nint size, i;\r\nsize = pbm->msiq_num * sizeof(struct sparc64_msiq_cookie);\r\npbm->msiq_irq_cookies = kzalloc(size, GFP_KERNEL);\r\nif (!pbm->msiq_irq_cookies)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pbm->msiq_num; i++) {\r\nstruct sparc64_msiq_cookie *p;\r\np = &pbm->msiq_irq_cookies[i];\r\np->pbm = pbm;\r\np->msiqid = pbm->msiq_first + i;\r\n}\r\nsize = pbm->msi_num * sizeof(unsigned int);\r\npbm->msi_irq_table = kzalloc(size, GFP_KERNEL);\r\nif (!pbm->msi_irq_table) {\r\nkfree(pbm->msiq_irq_cookies);\r\npbm->msiq_irq_cookies = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void msi_table_free(struct pci_pbm_info *pbm)\r\n{\r\nkfree(pbm->msiq_irq_cookies);\r\npbm->msiq_irq_cookies = NULL;\r\nkfree(pbm->msi_irq_table);\r\npbm->msi_irq_table = NULL;\r\n}\r\nstatic int bringup_one_msi_queue(struct pci_pbm_info *pbm,\r\nconst struct sparc64_msiq_ops *ops,\r\nunsigned long msiqid,\r\nunsigned long devino)\r\n{\r\nint irq = ops->msiq_build_irq(pbm, msiqid, devino);\r\nint err, nid;\r\nif (irq < 0)\r\nreturn irq;\r\nnid = pbm->numa_node;\r\nif (nid != -1) {\r\ncpumask_t numa_mask;\r\ncpumask_copy(&numa_mask, cpumask_of_node(nid));\r\nirq_set_affinity(irq, &numa_mask);\r\n}\r\nerr = request_irq(irq, sparc64_msiq_interrupt, 0,\r\n"MSIQ",\r\n&pbm->msiq_irq_cookies[msiqid - pbm->msiq_first]);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int sparc64_bringup_msi_queues(struct pci_pbm_info *pbm,\r\nconst struct sparc64_msiq_ops *ops)\r\n{\r\nint i;\r\nfor (i = 0; i < pbm->msiq_num; i++) {\r\nunsigned long msiqid = i + pbm->msiq_first;\r\nunsigned long devino = i + pbm->msiq_first_devino;\r\nint err;\r\nerr = bringup_one_msi_queue(pbm, ops, msiqid, devino);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid sparc64_pbm_msi_init(struct pci_pbm_info *pbm,\r\nconst struct sparc64_msiq_ops *ops)\r\n{\r\nconst u32 *val;\r\nint len;\r\nval = of_get_property(pbm->op->dev.of_node, "#msi-eqs", &len);\r\nif (!val || len != 4)\r\ngoto no_msi;\r\npbm->msiq_num = *val;\r\nif (pbm->msiq_num) {\r\nconst struct msiq_prop {\r\nu32 first_msiq;\r\nu32 num_msiq;\r\nu32 first_devino;\r\n} *mqp;\r\nconst struct msi_range_prop {\r\nu32 first_msi;\r\nu32 num_msi;\r\n} *mrng;\r\nconst struct addr_range_prop {\r\nu32 msi32_high;\r\nu32 msi32_low;\r\nu32 msi32_len;\r\nu32 msi64_high;\r\nu32 msi64_low;\r\nu32 msi64_len;\r\n} *arng;\r\nval = of_get_property(pbm->op->dev.of_node, "msi-eq-size", &len);\r\nif (!val || len != 4)\r\ngoto no_msi;\r\npbm->msiq_ent_count = *val;\r\nmqp = of_get_property(pbm->op->dev.of_node,\r\n"msi-eq-to-devino", &len);\r\nif (!mqp)\r\nmqp = of_get_property(pbm->op->dev.of_node,\r\n"msi-eq-devino", &len);\r\nif (!mqp || len != sizeof(struct msiq_prop))\r\ngoto no_msi;\r\npbm->msiq_first = mqp->first_msiq;\r\npbm->msiq_first_devino = mqp->first_devino;\r\nval = of_get_property(pbm->op->dev.of_node, "#msi", &len);\r\nif (!val || len != 4)\r\ngoto no_msi;\r\npbm->msi_num = *val;\r\nmrng = of_get_property(pbm->op->dev.of_node, "msi-ranges", &len);\r\nif (!mrng || len != sizeof(struct msi_range_prop))\r\ngoto no_msi;\r\npbm->msi_first = mrng->first_msi;\r\nval = of_get_property(pbm->op->dev.of_node, "msi-data-mask", &len);\r\nif (!val || len != 4)\r\ngoto no_msi;\r\npbm->msi_data_mask = *val;\r\nval = of_get_property(pbm->op->dev.of_node, "msix-data-width", &len);\r\nif (!val || len != 4)\r\ngoto no_msi;\r\npbm->msix_data_width = *val;\r\narng = of_get_property(pbm->op->dev.of_node, "msi-address-ranges",\r\n&len);\r\nif (!arng || len != sizeof(struct addr_range_prop))\r\ngoto no_msi;\r\npbm->msi32_start = ((u64)arng->msi32_high << 32) |\r\n(u64) arng->msi32_low;\r\npbm->msi64_start = ((u64)arng->msi64_high << 32) |\r\n(u64) arng->msi64_low;\r\npbm->msi32_len = arng->msi32_len;\r\npbm->msi64_len = arng->msi64_len;\r\nif (msi_bitmap_alloc(pbm))\r\ngoto no_msi;\r\nif (msi_table_alloc(pbm)) {\r\nmsi_bitmap_free(pbm);\r\ngoto no_msi;\r\n}\r\nif (ops->msiq_alloc(pbm)) {\r\nmsi_table_free(pbm);\r\nmsi_bitmap_free(pbm);\r\ngoto no_msi;\r\n}\r\nif (sparc64_bringup_msi_queues(pbm, ops)) {\r\nops->msiq_free(pbm);\r\nmsi_table_free(pbm);\r\nmsi_bitmap_free(pbm);\r\ngoto no_msi;\r\n}\r\nprintk(KERN_INFO "%s: MSI Queue first[%u] num[%u] count[%u] "\r\n"devino[0x%x]\n",\r\npbm->name,\r\npbm->msiq_first, pbm->msiq_num,\r\npbm->msiq_ent_count,\r\npbm->msiq_first_devino);\r\nprintk(KERN_INFO "%s: MSI first[%u] num[%u] mask[0x%x] "\r\n"width[%u]\n",\r\npbm->name,\r\npbm->msi_first, pbm->msi_num, pbm->msi_data_mask,\r\npbm->msix_data_width);\r\nprintk(KERN_INFO "%s: MSI addr32[0x%llx:0x%x] "\r\n"addr64[0x%llx:0x%x]\n",\r\npbm->name,\r\npbm->msi32_start, pbm->msi32_len,\r\npbm->msi64_start, pbm->msi64_len);\r\nprintk(KERN_INFO "%s: MSI queues at RA [%016lx]\n",\r\npbm->name,\r\n__pa(pbm->msi_queues));\r\npbm->msi_ops = ops;\r\npbm->setup_msi_irq = sparc64_setup_msi_irq;\r\npbm->teardown_msi_irq = sparc64_teardown_msi_irq;\r\n}\r\nreturn;\r\nno_msi:\r\npbm->msiq_num = 0;\r\nprintk(KERN_INFO "%s: No MSI support.\n", pbm->name);\r\n}
