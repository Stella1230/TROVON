static inline u8 get_chip_id(u8 val)\r\n{\r\nreturn (val >> ID1_CHIPID_S) & ID1_CHIPID_M;\r\n}\r\nstatic inline u8 get_chip_rev(u8 val)\r\n{\r\nreturn (val >> ID1_REVISION_S) & ID1_REVISION_M;\r\n}\r\nstatic int ks8995_read(struct ks8995_switch *ks, char *buf,\r\nunsigned offset, size_t count)\r\n{\r\nu8 cmd[2];\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nint err;\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt[0].tx_buf = cmd;\r\nt[0].len = sizeof(cmd);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = count;\r\nspi_message_add_tail(&t[1], &m);\r\ncmd[0] = KS8995_CMD_READ;\r\ncmd[1] = offset;\r\nmutex_lock(&ks->lock);\r\nerr = spi_sync(ks->spi, &m);\r\nmutex_unlock(&ks->lock);\r\nreturn err ? err : count;\r\n}\r\nstatic int ks8995_write(struct ks8995_switch *ks, char *buf,\r\nunsigned offset, size_t count)\r\n{\r\nu8 cmd[2];\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nint err;\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt[0].tx_buf = cmd;\r\nt[0].len = sizeof(cmd);\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = buf;\r\nt[1].len = count;\r\nspi_message_add_tail(&t[1], &m);\r\ncmd[0] = KS8995_CMD_WRITE;\r\ncmd[1] = offset;\r\nmutex_lock(&ks->lock);\r\nerr = spi_sync(ks->spi, &m);\r\nmutex_unlock(&ks->lock);\r\nreturn err ? err : count;\r\n}\r\nstatic inline int ks8995_read_reg(struct ks8995_switch *ks, u8 addr, u8 *buf)\r\n{\r\nreturn ks8995_read(ks, buf, addr, 1) != 1;\r\n}\r\nstatic inline int ks8995_write_reg(struct ks8995_switch *ks, u8 addr, u8 val)\r\n{\r\nchar buf = val;\r\nreturn ks8995_write(ks, &buf, addr, 1) != 1;\r\n}\r\nstatic int ks8995_stop(struct ks8995_switch *ks)\r\n{\r\nreturn ks8995_write_reg(ks, KS8995_REG_ID1, 0);\r\n}\r\nstatic int ks8995_start(struct ks8995_switch *ks)\r\n{\r\nreturn ks8995_write_reg(ks, KS8995_REG_ID1, 1);\r\n}\r\nstatic int ks8995_reset(struct ks8995_switch *ks)\r\n{\r\nint err;\r\nerr = ks8995_stop(ks);\r\nif (err)\r\nreturn err;\r\nudelay(KS8995_RESET_DELAY);\r\nreturn ks8995_start(ks);\r\n}\r\nstatic ssize_t ks8995_registers_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev;\r\nstruct ks8995_switch *ks8995;\r\ndev = container_of(kobj, struct device, kobj);\r\nks8995 = dev_get_drvdata(dev);\r\nif (unlikely(off > ks8995->regs_attr.size))\r\nreturn 0;\r\nif ((off + count) > ks8995->regs_attr.size)\r\ncount = ks8995->regs_attr.size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\nreturn ks8995_read(ks8995, buf, off, count);\r\n}\r\nstatic ssize_t ks8995_registers_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev;\r\nstruct ks8995_switch *ks8995;\r\ndev = container_of(kobj, struct device, kobj);\r\nks8995 = dev_get_drvdata(dev);\r\nif (unlikely(off >= ks8995->regs_attr.size))\r\nreturn -EFBIG;\r\nif ((off + count) > ks8995->regs_attr.size)\r\ncount = ks8995->regs_attr.size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\nreturn ks8995_write(ks8995, buf, off, count);\r\n}\r\nstatic int ks8995_probe(struct spi_device *spi)\r\n{\r\nstruct ks8995_switch *ks;\r\nstruct ks8995_pdata *pdata;\r\nu8 ids[2];\r\nint err;\r\npdata = spi->dev.platform_data;\r\nks = devm_kzalloc(&spi->dev, sizeof(*ks), GFP_KERNEL);\r\nif (!ks)\r\nreturn -ENOMEM;\r\nmutex_init(&ks->lock);\r\nks->pdata = pdata;\r\nks->spi = spi_dev_get(spi);\r\nspi_set_drvdata(spi, ks);\r\nspi->mode = SPI_MODE_0;\r\nspi->bits_per_word = 8;\r\nerr = spi_setup(spi);\r\nif (err) {\r\ndev_err(&spi->dev, "spi_setup failed, err=%d\n", err);\r\nreturn err;\r\n}\r\nerr = ks8995_read(ks, ids, KS8995_REG_ID0, sizeof(ids));\r\nif (err < 0) {\r\ndev_err(&spi->dev, "unable to read id registers, err=%d\n",\r\nerr);\r\nreturn err;\r\n}\r\nswitch (ids[0]) {\r\ncase FAMILY_KS8995:\r\nbreak;\r\ndefault:\r\ndev_err(&spi->dev, "unknown family id:%02x\n", ids[0]);\r\nreturn -ENODEV;\r\n}\r\nmemcpy(&ks->regs_attr, &ks8995_registers_attr, sizeof(ks->regs_attr));\r\nif (get_chip_id(ids[1]) != CHIPID_M) {\r\nu8 val;\r\nerr = ks8995_read(ks, &val, KSZ8864_REG_ID1, sizeof(val));\r\nif (err < 0) {\r\ndev_err(&spi->dev,\r\n"unable to read chip id register, err=%d\n",\r\nerr);\r\nreturn err;\r\n}\r\nif ((val & 0x80) == 0) {\r\ndev_err(&spi->dev, "unknown chip:%02x,0\n", ids[1]);\r\nreturn err;\r\n}\r\nks->regs_attr.size = KSZ8864_REGS_SIZE;\r\n}\r\nerr = ks8995_reset(ks);\r\nif (err)\r\nreturn err;\r\nerr = sysfs_create_bin_file(&spi->dev.kobj, &ks->regs_attr);\r\nif (err) {\r\ndev_err(&spi->dev, "unable to create sysfs file, err=%d\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (get_chip_id(ids[1]) == CHIPID_M) {\r\ndev_info(&spi->dev,\r\n"KS8995 device found, Chip ID:%x, Revision:%x\n",\r\nget_chip_id(ids[1]), get_chip_rev(ids[1]));\r\n} else {\r\ndev_info(&spi->dev, "KSZ8864 device found, Revision:%x\n",\r\nget_chip_rev(ids[1]));\r\n}\r\nreturn 0;\r\n}\r\nstatic int ks8995_remove(struct spi_device *spi)\r\n{\r\nsysfs_remove_bin_file(&spi->dev.kobj, &ks8995_registers_attr);\r\nreturn 0;\r\n}
