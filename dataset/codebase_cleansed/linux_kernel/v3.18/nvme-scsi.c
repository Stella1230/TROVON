static int nvme_trans_copy_to_user(struct sg_io_hdr *hdr, void *from,\r\nunsigned long n)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nunsigned long not_copied;\r\nint i;\r\nvoid *index = from;\r\nsize_t remaining = n;\r\nsize_t xfer_len;\r\nif (hdr->iovec_count > 0) {\r\nstruct sg_iovec sgl;\r\nfor (i = 0; i < hdr->iovec_count; i++) {\r\nnot_copied = copy_from_user(&sgl, hdr->dxferp +\r\ni * sizeof(struct sg_iovec),\r\nsizeof(struct sg_iovec));\r\nif (not_copied)\r\nreturn -EFAULT;\r\nxfer_len = min(remaining, sgl.iov_len);\r\nnot_copied = copy_to_user(sgl.iov_base, index,\r\nxfer_len);\r\nif (not_copied) {\r\nres = -EFAULT;\r\nbreak;\r\n}\r\nindex += xfer_len;\r\nremaining -= xfer_len;\r\nif (remaining == 0)\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nnot_copied = copy_to_user(hdr->dxferp, from, n);\r\nif (not_copied)\r\nres = -EFAULT;\r\nreturn res;\r\n}\r\nstatic int nvme_trans_copy_from_user(struct sg_io_hdr *hdr, void *to,\r\nunsigned long n)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nunsigned long not_copied;\r\nint i;\r\nvoid *index = to;\r\nsize_t remaining = n;\r\nsize_t xfer_len;\r\nif (hdr->iovec_count > 0) {\r\nstruct sg_iovec sgl;\r\nfor (i = 0; i < hdr->iovec_count; i++) {\r\nnot_copied = copy_from_user(&sgl, hdr->dxferp +\r\ni * sizeof(struct sg_iovec),\r\nsizeof(struct sg_iovec));\r\nif (not_copied)\r\nreturn -EFAULT;\r\nxfer_len = min(remaining, sgl.iov_len);\r\nnot_copied = copy_from_user(index, sgl.iov_base,\r\nxfer_len);\r\nif (not_copied) {\r\nres = -EFAULT;\r\nbreak;\r\n}\r\nindex += xfer_len;\r\nremaining -= xfer_len;\r\nif (remaining == 0)\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nnot_copied = copy_from_user(to, hdr->dxferp, n);\r\nif (not_copied)\r\nres = -EFAULT;\r\nreturn res;\r\n}\r\nstatic int nvme_trans_completion(struct sg_io_hdr *hdr, u8 status, u8 sense_key,\r\nu8 asc, u8 ascq)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu8 xfer_len;\r\nu8 resp[DESC_FMT_SENSE_DATA_SIZE];\r\nif (scsi_status_is_good(status)) {\r\nhdr->status = SAM_STAT_GOOD;\r\nhdr->masked_status = GOOD;\r\nhdr->host_status = DID_OK;\r\nhdr->driver_status = DRIVER_OK;\r\nhdr->sb_len_wr = 0;\r\n} else {\r\nhdr->status = status;\r\nhdr->masked_status = status >> 1;\r\nhdr->host_status = DID_OK;\r\nhdr->driver_status = DRIVER_OK;\r\nmemset(resp, 0, DESC_FMT_SENSE_DATA_SIZE);\r\nresp[0] = DESC_FORMAT_SENSE_DATA;\r\nresp[1] = sense_key;\r\nresp[2] = asc;\r\nresp[3] = ascq;\r\nxfer_len = min_t(u8, hdr->mx_sb_len, DESC_FMT_SENSE_DATA_SIZE);\r\nhdr->sb_len_wr = xfer_len;\r\nif (copy_to_user(hdr->sbp, resp, xfer_len) > 0)\r\nres = -EFAULT;\r\n}\r\nreturn res;\r\n}\r\nstatic int nvme_trans_status_code(struct sg_io_hdr *hdr, int nvme_sc)\r\n{\r\nu8 status, sense_key, asc, ascq;\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nif (nvme_sc < 0)\r\nreturn nvme_sc;\r\nnvme_sc &= 0x7FF;\r\nswitch (nvme_sc) {\r\ncase NVME_SC_SUCCESS:\r\nstatus = SAM_STAT_GOOD;\r\nsense_key = NO_SENSE;\r\nasc = SCSI_ASC_NO_SENSE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_INVALID_OPCODE:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = ILLEGAL_REQUEST;\r\nasc = SCSI_ASC_ILLEGAL_COMMAND;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_INVALID_FIELD:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = ILLEGAL_REQUEST;\r\nasc = SCSI_ASC_INVALID_CDB;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_DATA_XFER_ERROR:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = MEDIUM_ERROR;\r\nasc = SCSI_ASC_NO_SENSE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_POWER_LOSS:\r\nstatus = SAM_STAT_TASK_ABORTED;\r\nsense_key = ABORTED_COMMAND;\r\nasc = SCSI_ASC_WARNING;\r\nascq = SCSI_ASCQ_POWER_LOSS_EXPECTED;\r\nbreak;\r\ncase NVME_SC_INTERNAL:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = HARDWARE_ERROR;\r\nasc = SCSI_ASC_INTERNAL_TARGET_FAILURE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_ABORT_REQ:\r\nstatus = SAM_STAT_TASK_ABORTED;\r\nsense_key = ABORTED_COMMAND;\r\nasc = SCSI_ASC_NO_SENSE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_ABORT_QUEUE:\r\nstatus = SAM_STAT_TASK_ABORTED;\r\nsense_key = ABORTED_COMMAND;\r\nasc = SCSI_ASC_NO_SENSE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_FUSED_FAIL:\r\nstatus = SAM_STAT_TASK_ABORTED;\r\nsense_key = ABORTED_COMMAND;\r\nasc = SCSI_ASC_NO_SENSE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_FUSED_MISSING:\r\nstatus = SAM_STAT_TASK_ABORTED;\r\nsense_key = ABORTED_COMMAND;\r\nasc = SCSI_ASC_NO_SENSE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_INVALID_NS:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = ILLEGAL_REQUEST;\r\nasc = SCSI_ASC_ACCESS_DENIED_INVALID_LUN_ID;\r\nascq = SCSI_ASCQ_INVALID_LUN_ID;\r\nbreak;\r\ncase NVME_SC_LBA_RANGE:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = ILLEGAL_REQUEST;\r\nasc = SCSI_ASC_ILLEGAL_BLOCK;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_CAP_EXCEEDED:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = MEDIUM_ERROR;\r\nasc = SCSI_ASC_NO_SENSE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_NS_NOT_READY:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = NOT_READY;\r\nasc = SCSI_ASC_LUN_NOT_READY;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_INVALID_FORMAT:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = ILLEGAL_REQUEST;\r\nasc = SCSI_ASC_FORMAT_COMMAND_FAILED;\r\nascq = SCSI_ASCQ_FORMAT_COMMAND_FAILED;\r\nbreak;\r\ncase NVME_SC_BAD_ATTRIBUTES:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = ILLEGAL_REQUEST;\r\nasc = SCSI_ASC_INVALID_CDB;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_WRITE_FAULT:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = MEDIUM_ERROR;\r\nasc = SCSI_ASC_PERIPHERAL_DEV_WRITE_FAULT;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_READ_ERROR:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = MEDIUM_ERROR;\r\nasc = SCSI_ASC_UNRECOVERED_READ_ERROR;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_GUARD_CHECK:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = MEDIUM_ERROR;\r\nasc = SCSI_ASC_LOG_BLOCK_GUARD_CHECK_FAILED;\r\nascq = SCSI_ASCQ_LOG_BLOCK_GUARD_CHECK_FAILED;\r\nbreak;\r\ncase NVME_SC_APPTAG_CHECK:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = MEDIUM_ERROR;\r\nasc = SCSI_ASC_LOG_BLOCK_APPTAG_CHECK_FAILED;\r\nascq = SCSI_ASCQ_LOG_BLOCK_APPTAG_CHECK_FAILED;\r\nbreak;\r\ncase NVME_SC_REFTAG_CHECK:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = MEDIUM_ERROR;\r\nasc = SCSI_ASC_LOG_BLOCK_REFTAG_CHECK_FAILED;\r\nascq = SCSI_ASCQ_LOG_BLOCK_REFTAG_CHECK_FAILED;\r\nbreak;\r\ncase NVME_SC_COMPARE_FAILED:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = MISCOMPARE;\r\nasc = SCSI_ASC_MISCOMPARE_DURING_VERIFY;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\ncase NVME_SC_ACCESS_DENIED:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = ILLEGAL_REQUEST;\r\nasc = SCSI_ASC_ACCESS_DENIED_INVALID_LUN_ID;\r\nascq = SCSI_ASCQ_INVALID_LUN_ID;\r\nbreak;\r\ncase NVME_SC_CMDID_CONFLICT:\r\ncase NVME_SC_CMD_SEQ_ERROR:\r\ncase NVME_SC_CQ_INVALID:\r\ncase NVME_SC_QID_INVALID:\r\ncase NVME_SC_QUEUE_SIZE:\r\ncase NVME_SC_ABORT_LIMIT:\r\ncase NVME_SC_ABORT_MISSING:\r\ncase NVME_SC_ASYNC_LIMIT:\r\ncase NVME_SC_FIRMWARE_SLOT:\r\ncase NVME_SC_FIRMWARE_IMAGE:\r\ncase NVME_SC_INVALID_VECTOR:\r\ncase NVME_SC_INVALID_LOG_PAGE:\r\ndefault:\r\nstatus = SAM_STAT_CHECK_CONDITION;\r\nsense_key = ILLEGAL_REQUEST;\r\nasc = SCSI_ASC_NO_SENSE;\r\nascq = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\nbreak;\r\n}\r\nres = nvme_trans_completion(hdr, status, sense_key, asc, ascq);\r\nreturn res;\r\n}\r\nstatic int nvme_trans_standard_inquiry_page(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, u8 *inq_response,\r\nint alloc_len)\r\n{\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ns *id_ns;\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nint xfer_len;\r\nu8 resp_data_format = 0x02;\r\nu8 protect;\r\nu8 cmdque = 0x01 << 1;\r\nu8 fw_offset = sizeof(dev->firmware_rev);\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nnvme_sc = nvme_identify(dev, ns->ns_id, 0, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_free;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_free;\r\n}\r\nid_ns = mem;\r\n(id_ns->dps) ? (protect = 0x01) : (protect = 0);\r\nmemset(inq_response, 0, STANDARD_INQUIRY_LENGTH);\r\ninq_response[2] = VERSION_SPC_4;\r\ninq_response[3] = resp_data_format;\r\ninq_response[4] = ADDITIONAL_STD_INQ_LENGTH;\r\ninq_response[5] = protect;\r\ninq_response[7] = cmdque;\r\nstrncpy(&inq_response[8], "NVMe ", 8);\r\nstrncpy(&inq_response[16], dev->model, 16);\r\nwhile (dev->firmware_rev[fw_offset - 1] == ' ' && fw_offset > 4)\r\nfw_offset--;\r\nfw_offset -= 4;\r\nstrncpy(&inq_response[32], dev->firmware_rev + fw_offset, 4);\r\nxfer_len = min(alloc_len, STANDARD_INQUIRY_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, inq_response, xfer_len);\r\nout_free:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns), mem,\r\ndma_addr);\r\nout_dma:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_supported_vpd_pages(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, u8 *inq_response,\r\nint alloc_len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint xfer_len;\r\nmemset(inq_response, 0, STANDARD_INQUIRY_LENGTH);\r\ninq_response[1] = INQ_SUPPORTED_VPD_PAGES_PAGE;\r\ninq_response[3] = INQ_NUM_SUPPORTED_VPD_PAGES;\r\ninq_response[4] = INQ_SUPPORTED_VPD_PAGES_PAGE;\r\ninq_response[5] = INQ_UNIT_SERIAL_NUMBER_PAGE;\r\ninq_response[6] = INQ_DEVICE_IDENTIFICATION_PAGE;\r\ninq_response[7] = INQ_EXTENDED_INQUIRY_DATA_PAGE;\r\ninq_response[8] = INQ_BDEV_CHARACTERISTICS_PAGE;\r\nxfer_len = min(alloc_len, STANDARD_INQUIRY_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, inq_response, xfer_len);\r\nreturn res;\r\n}\r\nstatic int nvme_trans_unit_serial_page(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, u8 *inq_response,\r\nint alloc_len)\r\n{\r\nstruct nvme_dev *dev = ns->dev;\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint xfer_len;\r\nmemset(inq_response, 0, STANDARD_INQUIRY_LENGTH);\r\ninq_response[1] = INQ_UNIT_SERIAL_NUMBER_PAGE;\r\ninq_response[3] = INQ_SERIAL_NUMBER_LENGTH;\r\nstrncpy(&inq_response[4], dev->serial, INQ_SERIAL_NUMBER_LENGTH);\r\nxfer_len = min(alloc_len, STANDARD_INQUIRY_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, inq_response, xfer_len);\r\nreturn res;\r\n}\r\nstatic int nvme_trans_device_id_page(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *inq_response, int alloc_len)\r\n{\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ctrl *id_ctrl;\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nu8 ieee[4];\r\nint xfer_len;\r\n__be32 tmp_id = cpu_to_be32(ns->ns_id);\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nnvme_sc = nvme_identify(dev, 0, 1, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_free;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_free;\r\n}\r\nid_ctrl = mem;\r\nieee[0] = id_ctrl->ieee[0] << 4;\r\nieee[1] = id_ctrl->ieee[0] >> 4 | id_ctrl->ieee[1] << 4;\r\nieee[2] = id_ctrl->ieee[1] >> 4 | id_ctrl->ieee[2] << 4;\r\nieee[3] = id_ctrl->ieee[2] >> 4;\r\nmemset(inq_response, 0, STANDARD_INQUIRY_LENGTH);\r\ninq_response[1] = INQ_DEVICE_IDENTIFICATION_PAGE;\r\ninq_response[3] = 20;\r\ninq_response[4] = 0x01;\r\ninq_response[5] = 0x03;\r\ninq_response[6] = 0x00;\r\ninq_response[7] = 16;\r\ninq_response[8] = 0x60 | ieee[3];\r\ninq_response[9] = ieee[2];\r\ninq_response[10] = ieee[1];\r\ninq_response[11] = ieee[0];\r\ninq_response[12] = (dev->pci_dev->vendor & 0xFF00) >> 8;\r\ninq_response[13] = (dev->pci_dev->vendor & 0x00FF);\r\ninq_response[14] = dev->serial[0];\r\ninq_response[15] = dev->serial[1];\r\ninq_response[16] = dev->model[0];\r\ninq_response[17] = dev->model[1];\r\nmemcpy(&inq_response[18], &tmp_id, sizeof(u32));\r\nxfer_len = min(alloc_len, STANDARD_INQUIRY_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, inq_response, xfer_len);\r\nout_free:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns), mem,\r\ndma_addr);\r\nout_dma:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_ext_inq_page(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nint alloc_len)\r\n{\r\nu8 *inq_response;\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ctrl *id_ctrl;\r\nstruct nvme_id_ns *id_ns;\r\nint xfer_len;\r\nu8 microcode = 0x80;\r\nu8 spt;\r\nu8 spt_lut[8] = {0, 0, 2, 1, 4, 6, 5, 7};\r\nu8 grd_chk, app_chk, ref_chk, protect;\r\nu8 uask_sup = 0x20;\r\nu8 v_sup;\r\nu8 luiclr = 0x01;\r\ninq_response = kmalloc(EXTENDED_INQUIRY_DATA_PAGE_LENGTH, GFP_KERNEL);\r\nif (inq_response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_mem;\r\n}\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nnvme_sc = nvme_identify(dev, ns->ns_id, 0, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_free;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_free;\r\n}\r\nid_ns = mem;\r\nspt = spt_lut[(id_ns->dpc) & 0x07] << 3;\r\n(id_ns->dps) ? (protect = 0x01) : (protect = 0);\r\ngrd_chk = protect << 2;\r\napp_chk = protect << 1;\r\nref_chk = protect;\r\nnvme_sc = nvme_identify(dev, 0, 1, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_free;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_free;\r\n}\r\nid_ctrl = mem;\r\nv_sup = id_ctrl->vwc;\r\nmemset(inq_response, 0, EXTENDED_INQUIRY_DATA_PAGE_LENGTH);\r\ninq_response[1] = INQ_EXTENDED_INQUIRY_DATA_PAGE;\r\ninq_response[2] = 0x00;\r\ninq_response[3] = 0x3C;\r\ninq_response[4] = microcode | spt | grd_chk | app_chk | ref_chk;\r\ninq_response[5] = uask_sup;\r\ninq_response[6] = v_sup;\r\ninq_response[7] = luiclr;\r\ninq_response[8] = 0;\r\ninq_response[9] = 0;\r\nxfer_len = min(alloc_len, EXTENDED_INQUIRY_DATA_PAGE_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, inq_response, xfer_len);\r\nout_free:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns), mem,\r\ndma_addr);\r\nout_dma:\r\nkfree(inq_response);\r\nout_mem:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_bdev_char_page(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nint alloc_len)\r\n{\r\nu8 *inq_response;\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint xfer_len;\r\ninq_response = kzalloc(EXTENDED_INQUIRY_DATA_PAGE_LENGTH, GFP_KERNEL);\r\nif (inq_response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_mem;\r\n}\r\ninq_response[1] = INQ_BDEV_CHARACTERISTICS_PAGE;\r\ninq_response[2] = 0x00;\r\ninq_response[3] = 0x3C;\r\ninq_response[4] = 0x00;\r\ninq_response[5] = 0x01;\r\ninq_response[6] = 0x00;\r\nxfer_len = min(alloc_len, EXTENDED_INQUIRY_DATA_PAGE_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, inq_response, xfer_len);\r\nkfree(inq_response);\r\nout_mem:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_log_supp_pages(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nint alloc_len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint xfer_len;\r\nu8 *log_response;\r\nlog_response = kzalloc(LOG_PAGE_SUPPORTED_LOG_PAGES_LENGTH, GFP_KERNEL);\r\nif (log_response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_mem;\r\n}\r\nlog_response[0] = LOG_PAGE_SUPPORTED_LOG_PAGES_PAGE;\r\nlog_response[3] = SUPPORTED_LOG_PAGES_PAGE_LENGTH;\r\nlog_response[4] = LOG_PAGE_SUPPORTED_LOG_PAGES_PAGE;\r\nlog_response[5] = LOG_PAGE_INFORMATIONAL_EXCEPTIONS_PAGE;\r\nlog_response[6] = LOG_PAGE_TEMPERATURE_PAGE;\r\nxfer_len = min(alloc_len, LOG_PAGE_SUPPORTED_LOG_PAGES_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, log_response, xfer_len);\r\nkfree(log_response);\r\nout_mem:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_log_info_exceptions(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, int alloc_len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint xfer_len;\r\nu8 *log_response;\r\nstruct nvme_command c;\r\nstruct nvme_dev *dev = ns->dev;\r\nstruct nvme_smart_log *smart_log;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nu8 temp_c;\r\nu16 temp_k;\r\nlog_response = kzalloc(LOG_INFO_EXCP_PAGE_LENGTH, GFP_KERNEL);\r\nif (log_response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_mem;\r\n}\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev,\r\nsizeof(struct nvme_smart_log),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nmemset(&c, 0, sizeof(c));\r\nc.common.opcode = nvme_admin_get_log_page;\r\nc.common.nsid = cpu_to_le32(0xFFFFFFFF);\r\nc.common.prp1 = cpu_to_le64(dma_addr);\r\nc.common.cdw10[0] = cpu_to_le32((((sizeof(struct nvme_smart_log) /\r\nBYTES_TO_DWORDS) - 1) << 16) | NVME_LOG_SMART);\r\nres = nvme_submit_admin_cmd(dev, &c, NULL);\r\nif (res != NVME_SC_SUCCESS) {\r\ntemp_c = LOG_TEMP_UNKNOWN;\r\n} else {\r\nsmart_log = mem;\r\ntemp_k = (smart_log->temperature[1] << 8) +\r\n(smart_log->temperature[0]);\r\ntemp_c = temp_k - KELVIN_TEMP_FACTOR;\r\n}\r\nlog_response[0] = LOG_PAGE_INFORMATIONAL_EXCEPTIONS_PAGE;\r\nlog_response[3] = REMAINING_INFO_EXCP_PAGE_LENGTH;\r\nlog_response[6] = 0x23;\r\nlog_response[7] = 0x04;\r\nlog_response[10] = temp_c;\r\nxfer_len = min(alloc_len, LOG_INFO_EXCP_PAGE_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, log_response, xfer_len);\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_smart_log),\r\nmem, dma_addr);\r\nout_dma:\r\nkfree(log_response);\r\nout_mem:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_log_temperature(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nint alloc_len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint xfer_len;\r\nu8 *log_response;\r\nstruct nvme_command c;\r\nstruct nvme_dev *dev = ns->dev;\r\nstruct nvme_smart_log *smart_log;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nu32 feature_resp;\r\nu8 temp_c_cur, temp_c_thresh;\r\nu16 temp_k;\r\nlog_response = kzalloc(LOG_TEMP_PAGE_LENGTH, GFP_KERNEL);\r\nif (log_response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_mem;\r\n}\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev,\r\nsizeof(struct nvme_smart_log),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nmemset(&c, 0, sizeof(c));\r\nc.common.opcode = nvme_admin_get_log_page;\r\nc.common.nsid = cpu_to_le32(0xFFFFFFFF);\r\nc.common.prp1 = cpu_to_le64(dma_addr);\r\nc.common.cdw10[0] = cpu_to_le32((((sizeof(struct nvme_smart_log) /\r\nBYTES_TO_DWORDS) - 1) << 16) | NVME_LOG_SMART);\r\nres = nvme_submit_admin_cmd(dev, &c, NULL);\r\nif (res != NVME_SC_SUCCESS) {\r\ntemp_c_cur = LOG_TEMP_UNKNOWN;\r\n} else {\r\nsmart_log = mem;\r\ntemp_k = (smart_log->temperature[1] << 8) +\r\n(smart_log->temperature[0]);\r\ntemp_c_cur = temp_k - KELVIN_TEMP_FACTOR;\r\n}\r\nres = nvme_get_features(dev, NVME_FEAT_TEMP_THRESH, 0, 0,\r\n&feature_resp);\r\nif (res != NVME_SC_SUCCESS)\r\ntemp_c_thresh = LOG_TEMP_UNKNOWN;\r\nelse\r\ntemp_c_thresh = (feature_resp & 0xFFFF) - KELVIN_TEMP_FACTOR;\r\nlog_response[0] = LOG_PAGE_TEMPERATURE_PAGE;\r\nlog_response[3] = REMAINING_TEMP_PAGE_LENGTH;\r\nlog_response[6] = 0x01;\r\nlog_response[7] = 0x02;\r\nlog_response[9] = temp_c_cur;\r\nlog_response[11] = 0x01;\r\nlog_response[12] = 0x01;\r\nlog_response[13] = 0x02;\r\nlog_response[15] = temp_c_thresh;\r\nxfer_len = min(alloc_len, LOG_TEMP_PAGE_LENGTH);\r\nres = nvme_trans_copy_to_user(hdr, log_response, xfer_len);\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_smart_log),\r\nmem, dma_addr);\r\nout_dma:\r\nkfree(log_response);\r\nout_mem:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_fill_mode_parm_hdr(u8 *resp, int len, u8 cdb10, u8 llbaa,\r\nu16 mode_data_length, u16 blk_desc_len)\r\n{\r\nif ((cdb10 && len < 8) || (!cdb10 && len < 4))\r\nreturn SNTI_INTERNAL_ERROR;\r\nif (cdb10) {\r\nresp[0] = (mode_data_length & 0xFF00) >> 8;\r\nresp[1] = (mode_data_length & 0x00FF);\r\nresp[4] = llbaa;\r\nresp[5] = RESERVED_FIELD;\r\nresp[6] = (blk_desc_len & 0xFF00) >> 8;\r\nresp[7] = (blk_desc_len & 0x00FF);\r\n} else {\r\nresp[0] = (mode_data_length & 0x00FF);\r\nresp[3] = (blk_desc_len & 0x00FF);\r\n}\r\nreturn SNTI_TRANSLATION_SUCCESS;\r\n}\r\nstatic int nvme_trans_fill_blk_desc(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *resp, int len, u8 llbaa)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ns *id_ns;\r\nu8 flbas;\r\nu32 lba_length;\r\nif (llbaa == 0 && len < MODE_PAGE_BLK_DES_LEN)\r\nreturn SNTI_INTERNAL_ERROR;\r\nelse if (llbaa > 0 && len < MODE_PAGE_LLBAA_BLK_DES_LEN)\r\nreturn SNTI_INTERNAL_ERROR;\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nnvme_sc = nvme_identify(dev, ns->ns_id, 0, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_dma;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_dma;\r\n}\r\nid_ns = mem;\r\nflbas = (id_ns->flbas) & 0x0F;\r\nlba_length = (1 << (id_ns->lbaf[flbas].ds));\r\nif (llbaa == 0) {\r\n__be32 tmp_cap = cpu_to_be32(le64_to_cpu(id_ns->ncap));\r\n__be32 tmp_len = cpu_to_be32(lba_length & 0x00FFFFFF);\r\nmemcpy(resp, &tmp_cap, sizeof(u32));\r\nmemcpy(&resp[4], &tmp_len, sizeof(u32));\r\n} else {\r\n__be64 tmp_cap = cpu_to_be64(le64_to_cpu(id_ns->ncap));\r\n__be32 tmp_len = cpu_to_be32(lba_length);\r\nmemcpy(resp, &tmp_cap, sizeof(u64));\r\nmemcpy(&resp[12], &tmp_len, sizeof(u32));\r\n}\r\nout_dma:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns), mem,\r\ndma_addr);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_fill_control_page(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, u8 *resp,\r\nint len)\r\n{\r\nif (len < MODE_PAGE_CONTROL_LEN)\r\nreturn SNTI_INTERNAL_ERROR;\r\nresp[0] = MODE_PAGE_CONTROL;\r\nresp[1] = MODE_PAGE_CONTROL_LEN_FIELD;\r\nresp[2] = 0x0E;\r\nresp[3] = 0x12;\r\nresp[5] = 0x40;\r\nresp[8] = 0xFF;\r\nresp[9] = 0xFF;\r\nreturn SNTI_TRANSLATION_SUCCESS;\r\n}\r\nstatic int nvme_trans_fill_caching_page(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr,\r\nu8 *resp, int len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\nu32 feature_resp;\r\nu8 vwc;\r\nif (len < MODE_PAGE_CACHING_LEN)\r\nreturn SNTI_INTERNAL_ERROR;\r\nnvme_sc = nvme_get_features(dev, NVME_FEAT_VOLATILE_WC, 0, 0,\r\n&feature_resp);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out;\r\n}\r\nvwc = feature_resp & 0x00000001;\r\nresp[0] = MODE_PAGE_CACHING;\r\nresp[1] = MODE_PAGE_CACHING_LEN_FIELD;\r\nresp[2] = vwc << 2;\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_fill_pow_cnd_page(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, u8 *resp,\r\nint len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nif (len < MODE_PAGE_POW_CND_LEN)\r\nreturn SNTI_INTERNAL_ERROR;\r\nresp[0] = MODE_PAGE_POWER_CONDITION;\r\nresp[1] = MODE_PAGE_POW_CND_LEN_FIELD;\r\nreturn res;\r\n}\r\nstatic int nvme_trans_fill_inf_exc_page(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, u8 *resp,\r\nint len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nif (len < MODE_PAGE_INF_EXC_LEN)\r\nreturn SNTI_INTERNAL_ERROR;\r\nresp[0] = MODE_PAGE_INFO_EXCEP;\r\nresp[1] = MODE_PAGE_INF_EXC_LEN_FIELD;\r\nresp[2] = 0x88;\r\nreturn res;\r\n}\r\nstatic int nvme_trans_fill_all_pages(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *resp, int len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu16 mode_pages_offset_1 = 0;\r\nu16 mode_pages_offset_2, mode_pages_offset_3, mode_pages_offset_4;\r\nmode_pages_offset_2 = mode_pages_offset_1 + MODE_PAGE_CACHING_LEN;\r\nmode_pages_offset_3 = mode_pages_offset_2 + MODE_PAGE_CONTROL_LEN;\r\nmode_pages_offset_4 = mode_pages_offset_3 + MODE_PAGE_POW_CND_LEN;\r\nres = nvme_trans_fill_caching_page(ns, hdr, &resp[mode_pages_offset_1],\r\nMODE_PAGE_CACHING_LEN);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\nres = nvme_trans_fill_control_page(ns, hdr, &resp[mode_pages_offset_2],\r\nMODE_PAGE_CONTROL_LEN);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\nres = nvme_trans_fill_pow_cnd_page(ns, hdr, &resp[mode_pages_offset_3],\r\nMODE_PAGE_POW_CND_LEN);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\nres = nvme_trans_fill_inf_exc_page(ns, hdr, &resp[mode_pages_offset_4],\r\nMODE_PAGE_INF_EXC_LEN);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\nout:\r\nreturn res;\r\n}\r\nstatic inline int nvme_trans_get_blk_desc_len(u8 dbd, u8 llbaa)\r\n{\r\nif (dbd == MODE_SENSE_BLK_DESC_ENABLED) {\r\nreturn 8 * (llbaa + 1) * MODE_SENSE_BLK_DESC_COUNT;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int nvme_trans_mode_page_create(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, u8 *cmd,\r\nu16 alloc_len, u8 cdb10,\r\nint (*mode_page_fill_func)\r\n(struct nvme_ns *,\r\nstruct sg_io_hdr *hdr, u8 *, int),\r\nu16 mode_pages_tot_len)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint xfer_len;\r\nu8 *response;\r\nu8 dbd, llbaa;\r\nu16 resp_size;\r\nint mph_size;\r\nu16 mode_pages_offset_1;\r\nu16 blk_desc_len, blk_desc_offset, mode_data_length;\r\ndbd = GET_MODE_SENSE_DBD(cmd);\r\nllbaa = GET_MODE_SENSE_LLBAA(cmd);\r\nmph_size = GET_MODE_SENSE_MPH_SIZE(cdb10);\r\nblk_desc_len = nvme_trans_get_blk_desc_len(dbd, llbaa);\r\nresp_size = mph_size + blk_desc_len + mode_pages_tot_len;\r\nmode_data_length = 3 + (3 * cdb10) + blk_desc_len + mode_pages_tot_len;\r\nblk_desc_offset = mph_size;\r\nmode_pages_offset_1 = blk_desc_offset + blk_desc_len;\r\nresponse = kzalloc(resp_size, GFP_KERNEL);\r\nif (response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_mem;\r\n}\r\nres = nvme_trans_fill_mode_parm_hdr(&response[0], mph_size, cdb10,\r\nllbaa, mode_data_length, blk_desc_len);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out_free;\r\nif (blk_desc_len > 0) {\r\nres = nvme_trans_fill_blk_desc(ns, hdr,\r\n&response[blk_desc_offset],\r\nblk_desc_len, llbaa);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out_free;\r\n}\r\nres = mode_page_fill_func(ns, hdr, &response[mode_pages_offset_1],\r\nmode_pages_tot_len);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out_free;\r\nxfer_len = min(alloc_len, resp_size);\r\nres = nvme_trans_copy_to_user(hdr, response, xfer_len);\r\nout_free:\r\nkfree(response);\r\nout_mem:\r\nreturn res;\r\n}\r\nstatic void nvme_trans_fill_read_cap(u8 *response, struct nvme_id_ns *id_ns,\r\nu8 cdb16)\r\n{\r\nu8 flbas;\r\nu32 lba_length;\r\nu64 rlba;\r\nu8 prot_en;\r\nu8 p_type_lut[4] = {0, 0, 1, 2};\r\n__be64 tmp_rlba;\r\n__be32 tmp_rlba_32;\r\n__be32 tmp_len;\r\nflbas = (id_ns->flbas) & 0x0F;\r\nlba_length = (1 << (id_ns->lbaf[flbas].ds));\r\nrlba = le64_to_cpup(&id_ns->nsze) - 1;\r\n(id_ns->dps) ? (prot_en = 0x01) : (prot_en = 0);\r\nif (!cdb16) {\r\nif (rlba > 0xFFFFFFFF)\r\nrlba = 0xFFFFFFFF;\r\ntmp_rlba_32 = cpu_to_be32(rlba);\r\ntmp_len = cpu_to_be32(lba_length);\r\nmemcpy(response, &tmp_rlba_32, sizeof(u32));\r\nmemcpy(&response[4], &tmp_len, sizeof(u32));\r\n} else {\r\ntmp_rlba = cpu_to_be64(rlba);\r\ntmp_len = cpu_to_be32(lba_length);\r\nmemcpy(response, &tmp_rlba, sizeof(u64));\r\nmemcpy(&response[8], &tmp_len, sizeof(u32));\r\nresponse[12] = (p_type_lut[id_ns->dps & 0x3] << 1) | prot_en;\r\n}\r\n}\r\nstatic int nvme_trans_power_state(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 pc, u8 pcmod, u8 start)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ctrl *id_ctrl;\r\nint lowest_pow_st;\r\nunsigned ps_desired = 0;\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev,\r\nsizeof(struct nvme_id_ctrl),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nnvme_sc = nvme_identify(dev, 0, 1, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_dma;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_dma;\r\n}\r\nid_ctrl = mem;\r\nlowest_pow_st = max(POWER_STATE_0, (int)(id_ctrl->npss - 1));\r\nswitch (pc) {\r\ncase NVME_POWER_STATE_START_VALID:\r\nif (pcmod == 0 && start == 0x1)\r\nps_desired = POWER_STATE_0;\r\nif (pcmod == 0 && start == 0x0)\r\nps_desired = lowest_pow_st;\r\nbreak;\r\ncase NVME_POWER_STATE_ACTIVE:\r\nif (pcmod == 0)\r\nps_desired = POWER_STATE_0;\r\nbreak;\r\ncase NVME_POWER_STATE_IDLE:\r\nif (pcmod == 0x0)\r\nps_desired = POWER_STATE_1;\r\nelse if (pcmod == 0x1)\r\nps_desired = POWER_STATE_2;\r\nelse if (pcmod == 0x2)\r\nps_desired = POWER_STATE_3;\r\nbreak;\r\ncase NVME_POWER_STATE_STANDBY:\r\nif (pcmod == 0x0)\r\nps_desired = max(POWER_STATE_0, (lowest_pow_st - 2));\r\nelse if (pcmod == 0x1)\r\nps_desired = max(POWER_STATE_0, (lowest_pow_st - 1));\r\nbreak;\r\ncase NVME_POWER_STATE_LU_CONTROL:\r\ndefault:\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nbreak;\r\n}\r\nnvme_sc = nvme_set_features(dev, NVME_FEAT_POWER_MGMT, ps_desired, 0,\r\nNULL);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_dma;\r\nif (nvme_sc)\r\nres = nvme_sc;\r\nout_dma:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ctrl), mem,\r\ndma_addr);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_send_fw_cmd(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 opcode, u32 tot_len, u32 offset,\r\nu8 buffer_id)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\nstruct nvme_command c;\r\nstruct nvme_iod *iod = NULL;\r\nunsigned length;\r\nmemset(&c, 0, sizeof(c));\r\nc.common.opcode = opcode;\r\nif (opcode == nvme_admin_download_fw) {\r\nif (hdr->iovec_count > 0) {\r\nres = nvme_trans_completion(hdr,\r\nSAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST,\r\nSCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n}\r\niod = nvme_map_user_pages(dev, DMA_TO_DEVICE,\r\n(unsigned long)hdr->dxferp, tot_len);\r\nif (IS_ERR(iod)) {\r\nres = PTR_ERR(iod);\r\ngoto out;\r\n}\r\nlength = nvme_setup_prps(dev, iod, tot_len, GFP_KERNEL);\r\nif (length != tot_len) {\r\nres = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nc.dlfw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));\r\nc.dlfw.prp2 = cpu_to_le64(iod->first_dma);\r\nc.dlfw.numd = cpu_to_le32((tot_len/BYTES_TO_DWORDS) - 1);\r\nc.dlfw.offset = cpu_to_le32(offset/BYTES_TO_DWORDS);\r\n} else if (opcode == nvme_admin_activate_fw) {\r\nu32 cdw10 = buffer_id | NVME_FWACT_REPL_ACTV;\r\nc.common.cdw10[0] = cpu_to_le32(cdw10);\r\n}\r\nnvme_sc = nvme_submit_admin_cmd(dev, &c, NULL);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_unmap;\r\nif (nvme_sc)\r\nres = nvme_sc;\r\nout_unmap:\r\nif (opcode == nvme_admin_download_fw) {\r\nnvme_unmap_user_pages(dev, DMA_TO_DEVICE, iod);\r\nnvme_free_iod(dev, iod);\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic inline void nvme_trans_modesel_get_bd_len(u8 *parm_list, u8 cdb10,\r\nu16 *bd_len, u8 *llbaa)\r\n{\r\nif (cdb10) {\r\n*bd_len = (parm_list[MODE_SELECT_10_BD_OFFSET] << 8) +\r\nparm_list[MODE_SELECT_10_BD_OFFSET + 1];\r\n*llbaa = parm_list[MODE_SELECT_10_LLBAA_OFFSET] &&\r\nMODE_SELECT_10_LLBAA_MASK;\r\n} else {\r\n*bd_len = parm_list[MODE_SELECT_6_BD_OFFSET];\r\n}\r\n}\r\nstatic void nvme_trans_modesel_save_bd(struct nvme_ns *ns, u8 *parm_list,\r\nu16 idx, u16 bd_len, u8 llbaa)\r\n{\r\nu16 bd_num;\r\nbd_num = bd_len / ((llbaa == 0) ?\r\nSHORT_DESC_BLOCK : LONG_DESC_BLOCK);\r\nif (llbaa == 0) {\r\nns->mode_select_num_blocks =\r\n(parm_list[idx + 1] << 16) +\r\n(parm_list[idx + 2] << 8) +\r\n(parm_list[idx + 3]);\r\nns->mode_select_block_len =\r\n(parm_list[idx + 5] << 16) +\r\n(parm_list[idx + 6] << 8) +\r\n(parm_list[idx + 7]);\r\n} else {\r\nns->mode_select_num_blocks =\r\n(((u64)parm_list[idx + 0]) << 56) +\r\n(((u64)parm_list[idx + 1]) << 48) +\r\n(((u64)parm_list[idx + 2]) << 40) +\r\n(((u64)parm_list[idx + 3]) << 32) +\r\n(((u64)parm_list[idx + 4]) << 24) +\r\n(((u64)parm_list[idx + 5]) << 16) +\r\n(((u64)parm_list[idx + 6]) << 8) +\r\n((u64)parm_list[idx + 7]);\r\nns->mode_select_block_len =\r\n(parm_list[idx + 12] << 24) +\r\n(parm_list[idx + 13] << 16) +\r\n(parm_list[idx + 14] << 8) +\r\n(parm_list[idx + 15]);\r\n}\r\n}\r\nstatic int nvme_trans_modesel_get_mp(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *mode_page, u8 page_code)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\nunsigned dword11;\r\nswitch (page_code) {\r\ncase MODE_PAGE_CACHING:\r\ndword11 = ((mode_page[2] & CACHING_MODE_PAGE_WCE_MASK) ? 1 : 0);\r\nnvme_sc = nvme_set_features(dev, NVME_FEAT_VOLATILE_WC, dword11,\r\n0, NULL);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\nbreak;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\nbreak;\r\n}\r\nbreak;\r\ncase MODE_PAGE_CONTROL:\r\nbreak;\r\ncase MODE_PAGE_POWER_CONDITION:\r\nif ((mode_page[2] & 0x01) != 0 || (mode_page[3] & 0x0F) != 0) {\r\nres = nvme_trans_completion(hdr,\r\nSAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST,\r\nSCSI_ASC_INVALID_PARAMETER,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nif (!res)\r\nres = SNTI_INTERNAL_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nif (!res)\r\nres = SNTI_INTERNAL_ERROR;\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nstatic int nvme_trans_modesel_data(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd, u16 parm_list_len, u8 pf,\r\nu8 sp, u8 cdb10)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu8 *parm_list;\r\nu16 bd_len;\r\nu8 llbaa = 0;\r\nu16 index, saved_index;\r\nu8 page_code;\r\nu16 mp_size;\r\nparm_list = kmalloc(parm_list_len, GFP_KERNEL);\r\nif (parm_list == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nres = nvme_trans_copy_from_user(hdr, parm_list, parm_list_len);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out_mem;\r\nnvme_trans_modesel_get_bd_len(parm_list, cdb10, &bd_len, &llbaa);\r\nindex = (cdb10) ? (MODE_SELECT_10_MPH_SIZE) : (MODE_SELECT_6_MPH_SIZE);\r\nif (bd_len != 0) {\r\nnvme_trans_modesel_save_bd(ns, parm_list, index, bd_len, llbaa);\r\nindex += bd_len;\r\n}\r\nsaved_index = index;\r\ndo {\r\npage_code = parm_list[index] & MODE_SELECT_PAGE_CODE_MASK;\r\nmp_size = parm_list[index + 1] + 2;\r\nif ((page_code != MODE_PAGE_CACHING) &&\r\n(page_code != MODE_PAGE_CONTROL) &&\r\n(page_code != MODE_PAGE_POWER_CONDITION)) {\r\nres = nvme_trans_completion(hdr,\r\nSAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST,\r\nSCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out_mem;\r\n}\r\nindex += mp_size;\r\n} while (index < parm_list_len);\r\nindex = saved_index;\r\ndo {\r\npage_code = parm_list[index] & MODE_SELECT_PAGE_CODE_MASK;\r\nmp_size = parm_list[index + 1] + 2;\r\nres = nvme_trans_modesel_get_mp(ns, hdr, &parm_list[index],\r\npage_code);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\nbreak;\r\nindex += mp_size;\r\n} while (index < parm_list_len);\r\nout_mem:\r\nkfree(parm_list);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_fmt_set_blk_size_count(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ns *id_ns;\r\nu8 flbas;\r\nif (ns->mode_select_num_blocks == 0 || ns->mode_select_block_len == 0) {\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev,\r\nsizeof(struct nvme_id_ns), &dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nnvme_sc = nvme_identify(dev, ns->ns_id, 0, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_dma;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_dma;\r\n}\r\nid_ns = mem;\r\nif (ns->mode_select_num_blocks == 0)\r\nns->mode_select_num_blocks = le64_to_cpu(id_ns->ncap);\r\nif (ns->mode_select_block_len == 0) {\r\nflbas = (id_ns->flbas) & 0x0F;\r\nns->mode_select_block_len =\r\n(1 << (id_ns->lbaf[flbas].ds));\r\n}\r\nout_dma:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),\r\nmem, dma_addr);\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_fmt_get_parm_header(struct sg_io_hdr *hdr, u8 len,\r\nu8 format_prot_info, u8 *nvme_pf_code)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu8 *parm_list;\r\nu8 pf_usage, pf_code;\r\nparm_list = kmalloc(len, GFP_KERNEL);\r\nif (parm_list == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nres = nvme_trans_copy_from_user(hdr, parm_list, len);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out_mem;\r\nif ((parm_list[FORMAT_UNIT_IMMED_OFFSET] &\r\nFORMAT_UNIT_IMMED_MASK) != 0) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out_mem;\r\n}\r\nif (len == FORMAT_UNIT_LONG_PARM_LIST_LEN &&\r\n(parm_list[FORMAT_UNIT_PROT_INT_OFFSET] & 0x0F) != 0) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out_mem;\r\n}\r\npf_usage = parm_list[FORMAT_UNIT_PROT_FIELD_USAGE_OFFSET] &\r\nFORMAT_UNIT_PROT_FIELD_USAGE_MASK;\r\npf_code = (pf_usage << 2) | format_prot_info;\r\nswitch (pf_code) {\r\ncase 0:\r\n*nvme_pf_code = 0;\r\nbreak;\r\ncase 2:\r\n*nvme_pf_code = 1;\r\nbreak;\r\ncase 3:\r\n*nvme_pf_code = 2;\r\nbreak;\r\ncase 7:\r\n*nvme_pf_code = 3;\r\nbreak;\r\ndefault:\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nbreak;\r\n}\r\nout_mem:\r\nkfree(parm_list);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_fmt_send_cmd(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 prot_info)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ns *id_ns;\r\nu8 i;\r\nu8 flbas, nlbaf;\r\nu8 selected_lbaf = 0xFF;\r\nu32 cdw10 = 0;\r\nstruct nvme_command c;\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nnvme_sc = nvme_identify(dev, ns->ns_id, 0, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_dma;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_dma;\r\n}\r\nid_ns = mem;\r\nflbas = (id_ns->flbas) & 0x0F;\r\nnlbaf = id_ns->nlbaf;\r\nfor (i = 0; i < nlbaf; i++) {\r\nif (ns->mode_select_block_len == (1 << (id_ns->lbaf[i].ds))) {\r\nselected_lbaf = i;\r\nbreak;\r\n}\r\n}\r\nif (selected_lbaf > 0x0F) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_PARAMETER,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\n}\r\nif (ns->mode_select_num_blocks != le64_to_cpu(id_ns->ncap)) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_PARAMETER,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\n}\r\ncdw10 |= prot_info << 5;\r\ncdw10 |= selected_lbaf & 0x0F;\r\nmemset(&c, 0, sizeof(c));\r\nc.format.opcode = nvme_admin_format_nvm;\r\nc.format.nsid = cpu_to_le32(ns->ns_id);\r\nc.format.cdw10 = cpu_to_le32(cdw10);\r\nnvme_sc = nvme_submit_admin_cmd(dev, &c, NULL);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_dma;\r\nif (nvme_sc)\r\nres = nvme_sc;\r\nout_dma:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns), mem,\r\ndma_addr);\r\nout:\r\nreturn res;\r\n}\r\nstatic inline void nvme_trans_get_io_cdb6(u8 *cmd,\r\nstruct nvme_trans_io_cdb *cdb_info)\r\n{\r\ncdb_info->fua = 0;\r\ncdb_info->prot_info = 0;\r\ncdb_info->lba = GET_U32_FROM_CDB(cmd, IO_6_CDB_LBA_OFFSET) &\r\nIO_6_CDB_LBA_MASK;\r\ncdb_info->xfer_len = GET_U8_FROM_CDB(cmd, IO_6_CDB_TX_LEN_OFFSET);\r\nif (cdb_info->xfer_len == 0)\r\ncdb_info->xfer_len = IO_6_DEFAULT_TX_LEN;\r\n}\r\nstatic inline void nvme_trans_get_io_cdb10(u8 *cmd,\r\nstruct nvme_trans_io_cdb *cdb_info)\r\n{\r\ncdb_info->fua = GET_U8_FROM_CDB(cmd, IO_10_CDB_FUA_OFFSET) &\r\nIO_CDB_FUA_MASK;\r\ncdb_info->prot_info = GET_U8_FROM_CDB(cmd, IO_10_CDB_WP_OFFSET) &\r\nIO_CDB_WP_MASK >> IO_CDB_WP_SHIFT;\r\ncdb_info->lba = GET_U32_FROM_CDB(cmd, IO_10_CDB_LBA_OFFSET);\r\ncdb_info->xfer_len = GET_U16_FROM_CDB(cmd, IO_10_CDB_TX_LEN_OFFSET);\r\n}\r\nstatic inline void nvme_trans_get_io_cdb12(u8 *cmd,\r\nstruct nvme_trans_io_cdb *cdb_info)\r\n{\r\ncdb_info->fua = GET_U8_FROM_CDB(cmd, IO_12_CDB_FUA_OFFSET) &\r\nIO_CDB_FUA_MASK;\r\ncdb_info->prot_info = GET_U8_FROM_CDB(cmd, IO_12_CDB_WP_OFFSET) &\r\nIO_CDB_WP_MASK >> IO_CDB_WP_SHIFT;\r\ncdb_info->lba = GET_U32_FROM_CDB(cmd, IO_12_CDB_LBA_OFFSET);\r\ncdb_info->xfer_len = GET_U32_FROM_CDB(cmd, IO_12_CDB_TX_LEN_OFFSET);\r\n}\r\nstatic inline void nvme_trans_get_io_cdb16(u8 *cmd,\r\nstruct nvme_trans_io_cdb *cdb_info)\r\n{\r\ncdb_info->fua = GET_U8_FROM_CDB(cmd, IO_16_CDB_FUA_OFFSET) &\r\nIO_CDB_FUA_MASK;\r\ncdb_info->prot_info = GET_U8_FROM_CDB(cmd, IO_16_CDB_WP_OFFSET) &\r\nIO_CDB_WP_MASK >> IO_CDB_WP_SHIFT;\r\ncdb_info->lba = GET_U64_FROM_CDB(cmd, IO_16_CDB_LBA_OFFSET);\r\ncdb_info->xfer_len = GET_U32_FROM_CDB(cmd, IO_16_CDB_TX_LEN_OFFSET);\r\n}\r\nstatic inline u32 nvme_trans_io_get_num_cmds(struct sg_io_hdr *hdr,\r\nstruct nvme_trans_io_cdb *cdb_info,\r\nu32 max_blocks)\r\n{\r\nif (hdr->iovec_count > 0)\r\nreturn hdr->iovec_count;\r\nelse if (cdb_info->xfer_len > max_blocks)\r\nreturn ((cdb_info->xfer_len - 1) / max_blocks) + 1;\r\nelse\r\nreturn 1;\r\n}\r\nstatic u16 nvme_trans_io_get_control(struct nvme_ns *ns,\r\nstruct nvme_trans_io_cdb *cdb_info)\r\n{\r\nu16 control = 0;\r\nif (cdb_info->fua > 0)\r\ncontrol |= NVME_RW_FUA;\r\nreturn control;\r\n}\r\nstatic int nvme_trans_do_nvme_io(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nstruct nvme_trans_io_cdb *cdb_info, u8 is_write)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_dev *dev = ns->dev;\r\nu32 num_cmds;\r\nstruct nvme_iod *iod;\r\nu64 unit_len;\r\nu64 unit_num_blocks;\r\nu32 retcode;\r\nu32 i = 0;\r\nu64 nvme_offset = 0;\r\nvoid __user *next_mapping_addr;\r\nstruct nvme_command c;\r\nu8 opcode = (is_write ? nvme_cmd_write : nvme_cmd_read);\r\nu16 control;\r\nu32 max_blocks = queue_max_hw_sectors(ns->queue);\r\nnum_cmds = nvme_trans_io_get_num_cmds(hdr, cdb_info, max_blocks);\r\nfor (i = 0; i < num_cmds; i++) {\r\nmemset(&c, 0, sizeof(c));\r\nif (hdr->iovec_count > 0) {\r\nstruct sg_iovec sgl;\r\nretcode = copy_from_user(&sgl, hdr->dxferp +\r\ni * sizeof(struct sg_iovec),\r\nsizeof(struct sg_iovec));\r\nif (retcode)\r\nreturn -EFAULT;\r\nunit_len = sgl.iov_len;\r\nunit_num_blocks = unit_len >> ns->lba_shift;\r\nnext_mapping_addr = sgl.iov_base;\r\n} else {\r\nunit_num_blocks = min((u64)max_blocks,\r\n(cdb_info->xfer_len - nvme_offset));\r\nunit_len = unit_num_blocks << ns->lba_shift;\r\nnext_mapping_addr = hdr->dxferp +\r\n((1 << ns->lba_shift) * nvme_offset);\r\n}\r\nc.rw.opcode = opcode;\r\nc.rw.nsid = cpu_to_le32(ns->ns_id);\r\nc.rw.slba = cpu_to_le64(cdb_info->lba + nvme_offset);\r\nc.rw.length = cpu_to_le16(unit_num_blocks - 1);\r\ncontrol = nvme_trans_io_get_control(ns, cdb_info);\r\nc.rw.control = cpu_to_le16(control);\r\niod = nvme_map_user_pages(dev,\r\n(is_write) ? DMA_TO_DEVICE : DMA_FROM_DEVICE,\r\n(unsigned long)next_mapping_addr, unit_len);\r\nif (IS_ERR(iod)) {\r\nres = PTR_ERR(iod);\r\ngoto out;\r\n}\r\nretcode = nvme_setup_prps(dev, iod, unit_len, GFP_KERNEL);\r\nif (retcode != unit_len) {\r\nnvme_unmap_user_pages(dev,\r\n(is_write) ? DMA_TO_DEVICE : DMA_FROM_DEVICE,\r\niod);\r\nnvme_free_iod(dev, iod);\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nc.rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));\r\nc.rw.prp2 = cpu_to_le64(iod->first_dma);\r\nnvme_offset += unit_num_blocks;\r\nnvme_sc = nvme_submit_io_cmd(dev, &c, NULL);\r\nif (nvme_sc != NVME_SC_SUCCESS) {\r\nnvme_unmap_user_pages(dev,\r\n(is_write) ? DMA_TO_DEVICE : DMA_FROM_DEVICE,\r\niod);\r\nnvme_free_iod(dev, iod);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\ngoto out;\r\n}\r\nnvme_unmap_user_pages(dev,\r\n(is_write) ? DMA_TO_DEVICE : DMA_FROM_DEVICE,\r\niod);\r\nnvme_free_iod(dev, iod);\r\n}\r\nres = nvme_trans_status_code(hdr, NVME_SC_SUCCESS);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_io(struct nvme_ns *ns, struct sg_io_hdr *hdr, u8 is_write,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nstruct nvme_trans_io_cdb cdb_info;\r\nu8 opcode = cmd[0];\r\nu64 xfer_bytes;\r\nu64 sum_iov_len = 0;\r\nstruct sg_iovec sgl;\r\nint i;\r\nsize_t not_copied;\r\nswitch (opcode) {\r\ncase WRITE_6:\r\ncase READ_6:\r\nnvme_trans_get_io_cdb6(cmd, &cdb_info);\r\nbreak;\r\ncase WRITE_10:\r\ncase READ_10:\r\nnvme_trans_get_io_cdb10(cmd, &cdb_info);\r\nbreak;\r\ncase WRITE_12:\r\ncase READ_12:\r\nnvme_trans_get_io_cdb12(cmd, &cdb_info);\r\nbreak;\r\ncase WRITE_16:\r\ncase READ_16:\r\nnvme_trans_get_io_cdb16(cmd, &cdb_info);\r\nbreak;\r\ndefault:\r\nres = SNTI_INTERNAL_ERROR;\r\ngoto out;\r\n}\r\nif (hdr->iovec_count > 0) {\r\nfor (i = 0; i < hdr->iovec_count; i++) {\r\nnot_copied = copy_from_user(&sgl, hdr->dxferp +\r\ni * sizeof(struct sg_iovec),\r\nsizeof(struct sg_iovec));\r\nif (not_copied)\r\nreturn -EFAULT;\r\nsum_iov_len += sgl.iov_len;\r\nif (sgl.iov_len % (1 << ns->lba_shift) != 0) {\r\nres = nvme_trans_completion(hdr,\r\nSAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST,\r\nSCSI_ASC_INVALID_PARAMETER,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n}\r\n}\r\n} else {\r\nsum_iov_len = hdr->dxfer_len;\r\n}\r\nxfer_bytes = min(((u64)hdr->dxfer_len), sum_iov_len);\r\nif (xfer_bytes != (cdb_info.xfer_len << ns->lba_shift)) {\r\nres = -EINVAL;\r\ngoto out;\r\n}\r\nif (cdb_info.xfer_len == 0)\r\ngoto out;\r\nres = nvme_trans_do_nvme_io(ns, hdr, &cdb_info, is_write);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_inquiry(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu8 evpd;\r\nu8 page_code;\r\nint alloc_len;\r\nu8 *inq_response;\r\nevpd = GET_INQ_EVPD_BIT(cmd);\r\npage_code = GET_INQ_PAGE_CODE(cmd);\r\nalloc_len = GET_INQ_ALLOC_LENGTH(cmd);\r\ninq_response = kmalloc(STANDARD_INQUIRY_LENGTH, GFP_KERNEL);\r\nif (inq_response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_mem;\r\n}\r\nif (evpd == 0) {\r\nif (page_code == INQ_STANDARD_INQUIRY_PAGE) {\r\nres = nvme_trans_standard_inquiry_page(ns, hdr,\r\ninq_response, alloc_len);\r\n} else {\r\nres = nvme_trans_completion(hdr,\r\nSAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST,\r\nSCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\n}\r\n} else {\r\nswitch (page_code) {\r\ncase VPD_SUPPORTED_PAGES:\r\nres = nvme_trans_supported_vpd_pages(ns, hdr,\r\ninq_response, alloc_len);\r\nbreak;\r\ncase VPD_SERIAL_NUMBER:\r\nres = nvme_trans_unit_serial_page(ns, hdr, inq_response,\r\nalloc_len);\r\nbreak;\r\ncase VPD_DEVICE_IDENTIFIERS:\r\nres = nvme_trans_device_id_page(ns, hdr, inq_response,\r\nalloc_len);\r\nbreak;\r\ncase VPD_EXTENDED_INQUIRY:\r\nres = nvme_trans_ext_inq_page(ns, hdr, alloc_len);\r\nbreak;\r\ncase VPD_BLOCK_DEV_CHARACTERISTICS:\r\nres = nvme_trans_bdev_char_page(ns, hdr, alloc_len);\r\nbreak;\r\ndefault:\r\nres = nvme_trans_completion(hdr,\r\nSAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST,\r\nSCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nbreak;\r\n}\r\n}\r\nkfree(inq_response);\r\nout_mem:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_log_sense(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu16 alloc_len;\r\nu8 sp;\r\nu8 pc;\r\nu8 page_code;\r\nsp = GET_U8_FROM_CDB(cmd, LOG_SENSE_CDB_SP_OFFSET);\r\nif (sp != LOG_SENSE_CDB_SP_NOT_ENABLED) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n}\r\npc = GET_U8_FROM_CDB(cmd, LOG_SENSE_CDB_PC_OFFSET);\r\npage_code = pc & LOG_SENSE_CDB_PAGE_CODE_MASK;\r\npc = (pc & LOG_SENSE_CDB_PC_MASK) >> LOG_SENSE_CDB_PC_SHIFT;\r\nif (pc != LOG_SENSE_CDB_PC_CUMULATIVE_VALUES) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n}\r\nalloc_len = GET_U16_FROM_CDB(cmd, LOG_SENSE_CDB_ALLOC_LENGTH_OFFSET);\r\nswitch (page_code) {\r\ncase LOG_PAGE_SUPPORTED_LOG_PAGES_PAGE:\r\nres = nvme_trans_log_supp_pages(ns, hdr, alloc_len);\r\nbreak;\r\ncase LOG_PAGE_INFORMATIONAL_EXCEPTIONS_PAGE:\r\nres = nvme_trans_log_info_exceptions(ns, hdr, alloc_len);\r\nbreak;\r\ncase LOG_PAGE_TEMPERATURE_PAGE:\r\nres = nvme_trans_log_temperature(ns, hdr, alloc_len);\r\nbreak;\r\ndefault:\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nbreak;\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_mode_select(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu8 cdb10 = 0;\r\nu16 parm_list_len;\r\nu8 page_format;\r\nu8 save_pages;\r\npage_format = GET_U8_FROM_CDB(cmd, MODE_SELECT_CDB_PAGE_FORMAT_OFFSET);\r\npage_format &= MODE_SELECT_CDB_PAGE_FORMAT_MASK;\r\nsave_pages = GET_U8_FROM_CDB(cmd, MODE_SELECT_CDB_SAVE_PAGES_OFFSET);\r\nsave_pages &= MODE_SELECT_CDB_SAVE_PAGES_MASK;\r\nif (GET_OPCODE(cmd) == MODE_SELECT) {\r\nparm_list_len = GET_U8_FROM_CDB(cmd,\r\nMODE_SELECT_6_CDB_PARAM_LIST_LENGTH_OFFSET);\r\n} else {\r\nparm_list_len = GET_U16_FROM_CDB(cmd,\r\nMODE_SELECT_10_CDB_PARAM_LIST_LENGTH_OFFSET);\r\ncdb10 = 1;\r\n}\r\nif (parm_list_len != 0) {\r\nres = nvme_trans_modesel_data(ns, hdr, cmd, parm_list_len,\r\npage_format, save_pages, cdb10);\r\n}\r\nreturn res;\r\n}\r\nstatic int nvme_trans_mode_sense(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu16 alloc_len;\r\nu8 cdb10 = 0;\r\nu8 page_code;\r\nu8 pc;\r\nif (GET_OPCODE(cmd) == MODE_SENSE) {\r\nalloc_len = GET_U8_FROM_CDB(cmd, MODE_SENSE6_ALLOC_LEN_OFFSET);\r\n} else {\r\nalloc_len = GET_U16_FROM_CDB(cmd,\r\nMODE_SENSE10_ALLOC_LEN_OFFSET);\r\ncdb10 = 1;\r\n}\r\npc = GET_U8_FROM_CDB(cmd, MODE_SENSE_PAGE_CONTROL_OFFSET) &\r\nMODE_SENSE_PAGE_CONTROL_MASK;\r\nif (pc != MODE_SENSE_PC_CURRENT_VALUES) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n}\r\npage_code = GET_U8_FROM_CDB(cmd, MODE_SENSE_PAGE_CODE_OFFSET) &\r\nMODE_SENSE_PAGE_CODE_MASK;\r\nswitch (page_code) {\r\ncase MODE_PAGE_CACHING:\r\nres = nvme_trans_mode_page_create(ns, hdr, cmd, alloc_len,\r\ncdb10,\r\n&nvme_trans_fill_caching_page,\r\nMODE_PAGE_CACHING_LEN);\r\nbreak;\r\ncase MODE_PAGE_CONTROL:\r\nres = nvme_trans_mode_page_create(ns, hdr, cmd, alloc_len,\r\ncdb10,\r\n&nvme_trans_fill_control_page,\r\nMODE_PAGE_CONTROL_LEN);\r\nbreak;\r\ncase MODE_PAGE_POWER_CONDITION:\r\nres = nvme_trans_mode_page_create(ns, hdr, cmd, alloc_len,\r\ncdb10,\r\n&nvme_trans_fill_pow_cnd_page,\r\nMODE_PAGE_POW_CND_LEN);\r\nbreak;\r\ncase MODE_PAGE_INFO_EXCEP:\r\nres = nvme_trans_mode_page_create(ns, hdr, cmd, alloc_len,\r\ncdb10,\r\n&nvme_trans_fill_inf_exc_page,\r\nMODE_PAGE_INF_EXC_LEN);\r\nbreak;\r\ncase MODE_PAGE_RETURN_ALL:\r\nres = nvme_trans_mode_page_create(ns, hdr, cmd, alloc_len,\r\ncdb10,\r\n&nvme_trans_fill_all_pages,\r\nMODE_PAGE_ALL_LEN);\r\nbreak;\r\ndefault:\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nbreak;\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_read_capacity(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nu32 alloc_len = READ_CAP_10_RESP_SIZE;\r\nu32 resp_size = READ_CAP_10_RESP_SIZE;\r\nu32 xfer_len;\r\nu8 cdb16;\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ns *id_ns;\r\nu8 *response;\r\ncdb16 = IS_READ_CAP_16(cmd);\r\nif (cdb16) {\r\nalloc_len = GET_READ_CAP_16_ALLOC_LENGTH(cmd);\r\nresp_size = READ_CAP_16_RESP_SIZE;\r\n}\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nnvme_sc = nvme_identify(dev, ns->ns_id, 0, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_dma;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_dma;\r\n}\r\nid_ns = mem;\r\nresponse = kzalloc(resp_size, GFP_KERNEL);\r\nif (response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nnvme_trans_fill_read_cap(response, id_ns, cdb16);\r\nxfer_len = min(alloc_len, resp_size);\r\nres = nvme_trans_copy_to_user(hdr, response, xfer_len);\r\nkfree(response);\r\nout_dma:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ns), mem,\r\ndma_addr);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_report_luns(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nu32 alloc_len, xfer_len, resp_size;\r\nu8 select_report;\r\nu8 *response;\r\nstruct nvme_dev *dev = ns->dev;\r\ndma_addr_t dma_addr;\r\nvoid *mem;\r\nstruct nvme_id_ctrl *id_ctrl;\r\nu32 ll_length, lun_id;\r\nu8 lun_id_offset = REPORT_LUNS_FIRST_LUN_OFFSET;\r\n__be32 tmp_len;\r\nalloc_len = GET_REPORT_LUNS_ALLOC_LENGTH(cmd);\r\nselect_report = GET_U8_FROM_CDB(cmd, REPORT_LUNS_SR_OFFSET);\r\nif ((select_report != ALL_LUNS_RETURNED) &&\r\n(select_report != ALL_WELL_KNOWN_LUNS_RETURNED) &&\r\n(select_report != RESTRICTED_LUNS_RETURNED)) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n} else {\r\nmem = dma_alloc_coherent(&dev->pci_dev->dev,\r\nsizeof(struct nvme_id_ctrl),\r\n&dma_addr, GFP_KERNEL);\r\nif (mem == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nnvme_sc = nvme_identify(dev, 0, 1, dma_addr);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out_dma;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out_dma;\r\n}\r\nid_ctrl = mem;\r\nll_length = le32_to_cpu(id_ctrl->nn) * LUN_ENTRY_SIZE;\r\nresp_size = ll_length + LUN_DATA_HEADER_SIZE;\r\nif (alloc_len < resp_size) {\r\nres = nvme_trans_completion(hdr,\r\nSAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out_dma;\r\n}\r\nresponse = kzalloc(resp_size, GFP_KERNEL);\r\nif (response == NULL) {\r\nres = -ENOMEM;\r\ngoto out_dma;\r\n}\r\nfor (lun_id = 0; lun_id < le32_to_cpu(id_ctrl->nn); lun_id++) {\r\n__be64 tmp_id = cpu_to_be64(lun_id);\r\nmemcpy(&response[lun_id_offset], &tmp_id, sizeof(u64));\r\nlun_id_offset += LUN_ENTRY_SIZE;\r\n}\r\ntmp_len = cpu_to_be32(ll_length);\r\nmemcpy(response, &tmp_len, sizeof(u32));\r\n}\r\nxfer_len = min(alloc_len, resp_size);\r\nres = nvme_trans_copy_to_user(hdr, response, xfer_len);\r\nkfree(response);\r\nout_dma:\r\ndma_free_coherent(&dev->pci_dev->dev, sizeof(struct nvme_id_ctrl), mem,\r\ndma_addr);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_request_sense(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu8 alloc_len, xfer_len, resp_size;\r\nu8 desc_format;\r\nu8 *response;\r\nalloc_len = GET_REQUEST_SENSE_ALLOC_LENGTH(cmd);\r\ndesc_format = GET_U8_FROM_CDB(cmd, REQUEST_SENSE_DESC_OFFSET);\r\ndesc_format &= REQUEST_SENSE_DESC_MASK;\r\nresp_size = ((desc_format) ? (DESC_FMT_SENSE_DATA_SIZE) :\r\n(FIXED_FMT_SENSE_DATA_SIZE));\r\nresponse = kzalloc(resp_size, GFP_KERNEL);\r\nif (response == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nif (desc_format == DESCRIPTOR_FORMAT_SENSE_DATA_TYPE) {\r\nresponse[0] = DESC_FORMAT_SENSE_DATA;\r\nresponse[1] = NO_SENSE;\r\nresponse[2] = SCSI_ASC_NO_SENSE;\r\nresponse[3] = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\n} else {\r\nresponse[0] = FIXED_SENSE_DATA;\r\nresponse[2] = NO_SENSE;\r\nresponse[7] = FIXED_SENSE_DATA_ADD_LENGTH;\r\nresponse[12] = SCSI_ASC_NO_SENSE;\r\nresponse[13] = SCSI_ASCQ_CAUSE_NOT_REPORTABLE;\r\n}\r\nxfer_len = min(alloc_len, resp_size);\r\nres = nvme_trans_copy_to_user(hdr, response, xfer_len);\r\nkfree(response);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_security_protocol(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nreturn nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_ILLEGAL_COMMAND,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\n}\r\nstatic int nvme_trans_start_stop(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_command c;\r\nu8 immed, pcmod, pc, no_flush, start;\r\nimmed = GET_U8_FROM_CDB(cmd, START_STOP_UNIT_CDB_IMMED_OFFSET);\r\npcmod = GET_U8_FROM_CDB(cmd, START_STOP_UNIT_CDB_POWER_COND_MOD_OFFSET);\r\npc = GET_U8_FROM_CDB(cmd, START_STOP_UNIT_CDB_POWER_COND_OFFSET);\r\nno_flush = GET_U8_FROM_CDB(cmd, START_STOP_UNIT_CDB_NO_FLUSH_OFFSET);\r\nstart = GET_U8_FROM_CDB(cmd, START_STOP_UNIT_CDB_START_OFFSET);\r\nimmed &= START_STOP_UNIT_CDB_IMMED_MASK;\r\npcmod &= START_STOP_UNIT_CDB_POWER_COND_MOD_MASK;\r\npc = (pc & START_STOP_UNIT_CDB_POWER_COND_MASK) >> NIBBLE_SHIFT;\r\nno_flush &= START_STOP_UNIT_CDB_NO_FLUSH_MASK;\r\nstart &= START_STOP_UNIT_CDB_START_MASK;\r\nif (immed != 0) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\n} else {\r\nif (no_flush == 0) {\r\nmemset(&c, 0, sizeof(c));\r\nc.common.opcode = nvme_cmd_flush;\r\nc.common.nsid = cpu_to_le32(ns->ns_id);\r\nnvme_sc = nvme_submit_io_cmd(ns->dev, &c, NULL);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out;\r\nif (nvme_sc) {\r\nres = nvme_sc;\r\ngoto out;\r\n}\r\n}\r\nres = nvme_trans_power_state(ns, hdr, pc, pcmod, start);\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_synchronize_cache(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr, u8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nint nvme_sc;\r\nstruct nvme_command c;\r\nmemset(&c, 0, sizeof(c));\r\nc.common.opcode = nvme_cmd_flush;\r\nc.common.nsid = cpu_to_le32(ns->ns_id);\r\nnvme_sc = nvme_submit_io_cmd(ns->dev, &c, NULL);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\nif (res)\r\ngoto out;\r\nif (nvme_sc)\r\nres = nvme_sc;\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_format_unit(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu8 parm_hdr_len = 0;\r\nu8 nvme_pf_code = 0;\r\nu8 format_prot_info, long_list, format_data;\r\nformat_prot_info = GET_U8_FROM_CDB(cmd,\r\nFORMAT_UNIT_CDB_FORMAT_PROT_INFO_OFFSET);\r\nlong_list = GET_U8_FROM_CDB(cmd, FORMAT_UNIT_CDB_LONG_LIST_OFFSET);\r\nformat_data = GET_U8_FROM_CDB(cmd, FORMAT_UNIT_CDB_FORMAT_DATA_OFFSET);\r\nformat_prot_info = (format_prot_info &\r\nFORMAT_UNIT_CDB_FORMAT_PROT_INFO_MASK) >>\r\nFORMAT_UNIT_CDB_FORMAT_PROT_INFO_SHIFT;\r\nlong_list &= FORMAT_UNIT_CDB_LONG_LIST_MASK;\r\nformat_data &= FORMAT_UNIT_CDB_FORMAT_DATA_MASK;\r\nif (format_data != 0) {\r\nif (format_prot_info != 0) {\r\nif (long_list == 0)\r\nparm_hdr_len = FORMAT_UNIT_SHORT_PARM_LIST_LEN;\r\nelse\r\nparm_hdr_len = FORMAT_UNIT_LONG_PARM_LIST_LEN;\r\n}\r\n} else if (format_data == 0 && format_prot_info != 0) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n}\r\nif (parm_hdr_len > 0) {\r\nres = nvme_trans_fmt_get_parm_header(hdr, parm_hdr_len,\r\nformat_prot_info, &nvme_pf_code);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\n}\r\nres = nvme_trans_send_fw_cmd(ns, hdr, nvme_admin_activate_fw, 0, 0, 0);\r\nres = nvme_trans_fmt_set_blk_size_count(ns, hdr);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\nres = nvme_trans_fmt_send_cmd(ns, hdr, nvme_pf_code);\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_test_unit_ready(struct nvme_ns *ns,\r\nstruct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nstruct nvme_dev *dev = ns->dev;\r\nif (!(readl(&dev->bar->csts) & NVME_CSTS_RDY))\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nNOT_READY, SCSI_ASC_LUN_NOT_READY,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nelse\r\nres = nvme_trans_completion(hdr, SAM_STAT_GOOD, NO_SENSE, 0, 0);\r\nreturn res;\r\n}\r\nstatic int nvme_trans_write_buffer(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nint res = SNTI_TRANSLATION_SUCCESS;\r\nu32 buffer_offset, parm_list_length;\r\nu8 buffer_id, mode;\r\nparm_list_length =\r\nGET_U24_FROM_CDB(cmd, WRITE_BUFFER_CDB_PARM_LIST_LENGTH_OFFSET);\r\nif (parm_list_length % BYTES_TO_DWORDS != 0) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n}\r\nbuffer_id = GET_U8_FROM_CDB(cmd, WRITE_BUFFER_CDB_BUFFER_ID_OFFSET);\r\nif (buffer_id > NVME_MAX_FIRMWARE_SLOT) {\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\ngoto out;\r\n}\r\nmode = GET_U8_FROM_CDB(cmd, WRITE_BUFFER_CDB_MODE_OFFSET) &\r\nWRITE_BUFFER_CDB_MODE_MASK;\r\nbuffer_offset =\r\nGET_U24_FROM_CDB(cmd, WRITE_BUFFER_CDB_BUFFER_OFFSET_OFFSET);\r\nswitch (mode) {\r\ncase DOWNLOAD_SAVE_ACTIVATE:\r\nres = nvme_trans_send_fw_cmd(ns, hdr, nvme_admin_download_fw,\r\nparm_list_length, buffer_offset,\r\nbuffer_id);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\nres = nvme_trans_send_fw_cmd(ns, hdr, nvme_admin_activate_fw,\r\nparm_list_length, buffer_offset,\r\nbuffer_id);\r\nbreak;\r\ncase DOWNLOAD_SAVE_DEFER_ACTIVATE:\r\nres = nvme_trans_send_fw_cmd(ns, hdr, nvme_admin_download_fw,\r\nparm_list_length, buffer_offset,\r\nbuffer_id);\r\nbreak;\r\ncase ACTIVATE_DEFERRED_MICROCODE:\r\nres = nvme_trans_send_fw_cmd(ns, hdr, nvme_admin_activate_fw,\r\nparm_list_length, buffer_offset,\r\nbuffer_id);\r\nbreak;\r\ndefault:\r\nres = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_INVALID_CDB,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nbreak;\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic int nvme_trans_unmap(struct nvme_ns *ns, struct sg_io_hdr *hdr,\r\nu8 *cmd)\r\n{\r\nstruct nvme_dev *dev = ns->dev;\r\nstruct scsi_unmap_parm_list *plist;\r\nstruct nvme_dsm_range *range;\r\nstruct nvme_command c;\r\nint i, nvme_sc, res = -ENOMEM;\r\nu16 ndesc, list_len;\r\ndma_addr_t dma_addr;\r\nlist_len = GET_U16_FROM_CDB(cmd, UNMAP_CDB_PARAM_LIST_LENGTH_OFFSET);\r\nif (!list_len)\r\nreturn -EINVAL;\r\nplist = kmalloc(list_len, GFP_KERNEL);\r\nif (!plist)\r\nreturn -ENOMEM;\r\nres = nvme_trans_copy_from_user(hdr, plist, list_len);\r\nif (res != SNTI_TRANSLATION_SUCCESS)\r\ngoto out;\r\nndesc = be16_to_cpu(plist->unmap_blk_desc_data_len) >> 4;\r\nif (!ndesc || ndesc > 256) {\r\nres = -EINVAL;\r\ngoto out;\r\n}\r\nrange = dma_alloc_coherent(&dev->pci_dev->dev, ndesc * sizeof(*range),\r\n&dma_addr, GFP_KERNEL);\r\nif (!range)\r\ngoto out;\r\nfor (i = 0; i < ndesc; i++) {\r\nrange[i].nlb = cpu_to_le32(be32_to_cpu(plist->desc[i].nlb));\r\nrange[i].slba = cpu_to_le64(be64_to_cpu(plist->desc[i].slba));\r\nrange[i].cattr = 0;\r\n}\r\nmemset(&c, 0, sizeof(c));\r\nc.dsm.opcode = nvme_cmd_dsm;\r\nc.dsm.nsid = cpu_to_le32(ns->ns_id);\r\nc.dsm.prp1 = cpu_to_le64(dma_addr);\r\nc.dsm.nr = cpu_to_le32(ndesc - 1);\r\nc.dsm.attributes = cpu_to_le32(NVME_DSMGMT_AD);\r\nnvme_sc = nvme_submit_io_cmd(dev, &c, NULL);\r\nres = nvme_trans_status_code(hdr, nvme_sc);\r\ndma_free_coherent(&dev->pci_dev->dev, ndesc * sizeof(*range),\r\nrange, dma_addr);\r\nout:\r\nkfree(plist);\r\nreturn res;\r\n}\r\nstatic int nvme_scsi_translate(struct nvme_ns *ns, struct sg_io_hdr *hdr)\r\n{\r\nu8 cmd[BLK_MAX_CDB];\r\nint retcode;\r\nunsigned int opcode;\r\nif (hdr->cmdp == NULL)\r\nreturn -EMSGSIZE;\r\nif (copy_from_user(cmd, hdr->cmdp, hdr->cmd_len))\r\nreturn -EFAULT;\r\nopcode = cmd[0];\r\nswitch (opcode) {\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_12:\r\ncase READ_16:\r\nretcode = nvme_trans_io(ns, hdr, 0, cmd);\r\nbreak;\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_12:\r\ncase WRITE_16:\r\nretcode = nvme_trans_io(ns, hdr, 1, cmd);\r\nbreak;\r\ncase INQUIRY:\r\nretcode = nvme_trans_inquiry(ns, hdr, cmd);\r\nbreak;\r\ncase LOG_SENSE:\r\nretcode = nvme_trans_log_sense(ns, hdr, cmd);\r\nbreak;\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\nretcode = nvme_trans_mode_select(ns, hdr, cmd);\r\nbreak;\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\nretcode = nvme_trans_mode_sense(ns, hdr, cmd);\r\nbreak;\r\ncase READ_CAPACITY:\r\nretcode = nvme_trans_read_capacity(ns, hdr, cmd);\r\nbreak;\r\ncase SERVICE_ACTION_IN:\r\nif (IS_READ_CAP_16(cmd))\r\nretcode = nvme_trans_read_capacity(ns, hdr, cmd);\r\nelse\r\ngoto out;\r\nbreak;\r\ncase REPORT_LUNS:\r\nretcode = nvme_trans_report_luns(ns, hdr, cmd);\r\nbreak;\r\ncase REQUEST_SENSE:\r\nretcode = nvme_trans_request_sense(ns, hdr, cmd);\r\nbreak;\r\ncase SECURITY_PROTOCOL_IN:\r\ncase SECURITY_PROTOCOL_OUT:\r\nretcode = nvme_trans_security_protocol(ns, hdr, cmd);\r\nbreak;\r\ncase START_STOP:\r\nretcode = nvme_trans_start_stop(ns, hdr, cmd);\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\nretcode = nvme_trans_synchronize_cache(ns, hdr, cmd);\r\nbreak;\r\ncase FORMAT_UNIT:\r\nretcode = nvme_trans_format_unit(ns, hdr, cmd);\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nretcode = nvme_trans_test_unit_ready(ns, hdr, cmd);\r\nbreak;\r\ncase WRITE_BUFFER:\r\nretcode = nvme_trans_write_buffer(ns, hdr, cmd);\r\nbreak;\r\ncase UNMAP:\r\nretcode = nvme_trans_unmap(ns, hdr, cmd);\r\nbreak;\r\ndefault:\r\nout:\r\nretcode = nvme_trans_completion(hdr, SAM_STAT_CHECK_CONDITION,\r\nILLEGAL_REQUEST, SCSI_ASC_ILLEGAL_COMMAND,\r\nSCSI_ASCQ_CAUSE_NOT_REPORTABLE);\r\nbreak;\r\n}\r\nreturn retcode;\r\n}\r\nint nvme_sg_io(struct nvme_ns *ns, struct sg_io_hdr __user *u_hdr)\r\n{\r\nstruct sg_io_hdr hdr;\r\nint retcode;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (copy_from_user(&hdr, u_hdr, sizeof(hdr)))\r\nreturn -EFAULT;\r\nif (hdr.interface_id != 'S')\r\nreturn -EINVAL;\r\nif (hdr.cmd_len > BLK_MAX_CDB)\r\nreturn -EINVAL;\r\nretcode = nvme_scsi_translate(ns, &hdr);\r\nif (retcode < 0)\r\nreturn retcode;\r\nif (retcode > 0)\r\nretcode = SNTI_TRANSLATION_SUCCESS;\r\nif (copy_to_user(u_hdr, &hdr, sizeof(sg_io_hdr_t)) > 0)\r\nreturn -EFAULT;\r\nreturn retcode;\r\n}\r\nstatic int sg_build_iovec(sg_io_hdr_t __user *sgio, void __user *dxferp, u16 iovec_count)\r\n{\r\nsg_iovec_t __user *iov = (sg_iovec_t __user *) (sgio + 1);\r\nsg_iovec32_t __user *iov32 = dxferp;\r\nint i;\r\nfor (i = 0; i < iovec_count; i++) {\r\nu32 base, len;\r\nif (get_user(base, &iov32[i].iov_base) ||\r\nget_user(len, &iov32[i].iov_len) ||\r\nput_user(compat_ptr(base), &iov[i].iov_base) ||\r\nput_user(len, &iov[i].iov_len))\r\nreturn -EFAULT;\r\n}\r\nif (put_user(iov, &sgio->dxferp))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint nvme_sg_io32(struct nvme_ns *ns, unsigned long arg)\r\n{\r\nsg_io_hdr32_t __user *sgio32 = (sg_io_hdr32_t __user *)arg;\r\nsg_io_hdr_t __user *sgio;\r\nu16 iovec_count;\r\nu32 data;\r\nvoid __user *dxferp;\r\nint err;\r\nint interface_id;\r\nif (get_user(interface_id, &sgio32->interface_id))\r\nreturn -EFAULT;\r\nif (interface_id != 'S')\r\nreturn -EINVAL;\r\nif (get_user(iovec_count, &sgio32->iovec_count))\r\nreturn -EFAULT;\r\n{\r\nvoid __user *top = compat_alloc_user_space(0);\r\nvoid __user *new = compat_alloc_user_space(sizeof(sg_io_hdr_t) +\r\n(iovec_count * sizeof(sg_iovec_t)));\r\nif (new > top)\r\nreturn -EINVAL;\r\nsgio = new;\r\n}\r\nif (copy_in_user(&sgio->interface_id, &sgio32->interface_id,\r\n(2 * sizeof(int)) +\r\n(2 * sizeof(unsigned char)) +\r\n(1 * sizeof(unsigned short)) +\r\n(1 * sizeof(unsigned int))))\r\nreturn -EFAULT;\r\nif (get_user(data, &sgio32->dxferp))\r\nreturn -EFAULT;\r\ndxferp = compat_ptr(data);\r\nif (iovec_count) {\r\nif (sg_build_iovec(sgio, dxferp, iovec_count))\r\nreturn -EFAULT;\r\n} else {\r\nif (put_user(dxferp, &sgio->dxferp))\r\nreturn -EFAULT;\r\n}\r\n{\r\nunsigned char __user *cmdp;\r\nunsigned char __user *sbp;\r\nif (get_user(data, &sgio32->cmdp))\r\nreturn -EFAULT;\r\ncmdp = compat_ptr(data);\r\nif (get_user(data, &sgio32->sbp))\r\nreturn -EFAULT;\r\nsbp = compat_ptr(data);\r\nif (put_user(cmdp, &sgio->cmdp) ||\r\nput_user(sbp, &sgio->sbp))\r\nreturn -EFAULT;\r\n}\r\nif (copy_in_user(&sgio->timeout, &sgio32->timeout,\r\n3 * sizeof(int)))\r\nreturn -EFAULT;\r\nif (get_user(data, &sgio32->usr_ptr))\r\nreturn -EFAULT;\r\nif (put_user(compat_ptr(data), &sgio->usr_ptr))\r\nreturn -EFAULT;\r\nerr = nvme_sg_io(ns, sgio);\r\nif (err >= 0) {\r\nvoid __user *datap;\r\nif (copy_in_user(&sgio32->pack_id, &sgio->pack_id,\r\nsizeof(int)) ||\r\nget_user(datap, &sgio->usr_ptr) ||\r\nput_user((u32)(unsigned long)datap,\r\n&sgio32->usr_ptr) ||\r\ncopy_in_user(&sgio32->status, &sgio->status,\r\n(4 * sizeof(unsigned char)) +\r\n(2 * sizeof(unsigned short)) +\r\n(3 * sizeof(int))))\r\nerr = -EFAULT;\r\n}\r\nreturn err;\r\n}\r\nint nvme_sg_get_version_num(int __user *ip)\r\n{\r\nreturn put_user(sg_version_num, ip);\r\n}
