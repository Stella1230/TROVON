phys_t __weak mips_cpc_phys_base(void)\r\n{\r\nu32 cpc_base;\r\nif (!mips_cm_present())\r\nreturn 0;\r\nif (!(read_gcr_cpc_status() & CM_GCR_CPC_STATUS_EX_MSK))\r\nreturn 0;\r\ncpc_base = read_gcr_cpc_base();\r\nif (cpc_base & CM_GCR_CPC_BASE_CPCEN_MSK)\r\nreturn cpc_base & CM_GCR_CPC_BASE_CPCBASE_MSK;\r\ncpc_base = mips_cpc_default_phys_base();\r\nwrite_gcr_cpc_base(cpc_base | CM_GCR_CPC_BASE_CPCEN_MSK);\r\nreturn cpc_base;\r\n}\r\nint mips_cpc_probe(void)\r\n{\r\nphys_t addr;\r\nunsigned cpu;\r\nfor_each_possible_cpu(cpu)\r\nspin_lock_init(&per_cpu(cpc_core_lock, cpu));\r\naddr = mips_cpc_phys_base();\r\nif (!addr)\r\nreturn -ENODEV;\r\nmips_cpc_base = ioremap_nocache(addr, 0x8000);\r\nif (!mips_cpc_base)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nvoid mips_cpc_lock_other(unsigned int core)\r\n{\r\nunsigned curr_core;\r\npreempt_disable();\r\ncurr_core = current_cpu_data.core;\r\nspin_lock_irqsave(&per_cpu(cpc_core_lock, curr_core),\r\nper_cpu(cpc_core_lock_flags, curr_core));\r\nwrite_cpc_cl_other(core << CPC_Cx_OTHER_CORENUM_SHF);\r\n}\r\nvoid mips_cpc_unlock_other(void)\r\n{\r\nunsigned curr_core = current_cpu_data.core;\r\nspin_unlock_irqrestore(&per_cpu(cpc_core_lock, curr_core),\r\nper_cpu(cpc_core_lock_flags, curr_core));\r\npreempt_enable();\r\n}
