static int\r\nde4x5_hw_init(struct net_device *dev, u_long iobase, struct device *gendev)\r\n{\r\nchar name[DE4X5_NAME_LENGTH + 1];\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nstruct pci_dev *pdev = NULL;\r\nint i, status=0;\r\ndev_set_drvdata(gendev, dev);\r\nif (lp->bus == EISA) {\r\noutb(WAKEUP, PCI_CFPM);\r\n} else {\r\npdev = to_pci_dev (gendev);\r\npci_write_config_byte(pdev, PCI_CFDA_PSM, WAKEUP);\r\n}\r\nmdelay(10);\r\nRESET_DE4X5;\r\nif ((inl(DE4X5_STS) & (STS_TS | STS_RS)) != 0) {\r\nreturn -ENXIO;\r\n}\r\nlp->useSROM = false;\r\nif (lp->bus == PCI) {\r\nPCI_signature(name, lp);\r\n} else {\r\nEISA_signature(name, gendev);\r\n}\r\nif (*name == '\0') {\r\nreturn -ENXIO;\r\n}\r\ndev->base_addr = iobase;\r\nprintk ("%s: %s at 0x%04lx", dev_name(gendev), name, iobase);\r\nstatus = get_hw_addr(dev);\r\nprintk(", h/w address %pM\n", dev->dev_addr);\r\nif (status != 0) {\r\nprintk(" which has an Ethernet PROM CRC error.\n");\r\nreturn -ENXIO;\r\n} else {\r\nskb_queue_head_init(&lp->cache.queue);\r\nlp->cache.gepc = GEP_INIT;\r\nlp->asBit = GEP_SLNK;\r\nlp->asPolarity = GEP_SLNK;\r\nlp->asBitValid = ~0;\r\nlp->timeout = -1;\r\nlp->gendev = gendev;\r\nspin_lock_init(&lp->lock);\r\ninit_timer(&lp->timer);\r\nlp->timer.function = (void (*)(unsigned long))de4x5_ast;\r\nlp->timer.data = (unsigned long)dev;\r\nde4x5_parse_params(dev);\r\nlp->autosense = lp->params.autosense;\r\nif (lp->chipset != DC21140) {\r\nif ((lp->chipset==DC21040) && (lp->params.autosense&TP_NW)) {\r\nlp->params.autosense = TP;\r\n}\r\nif ((lp->chipset==DC21041) && (lp->params.autosense&BNC_AUI)) {\r\nlp->params.autosense = BNC;\r\n}\r\n}\r\nlp->fdx = lp->params.fdx;\r\nsprintf(lp->adapter_name,"%s (%s)", name, dev_name(gendev));\r\nlp->dma_size = (NUM_RX_DESC + NUM_TX_DESC) * sizeof(struct de4x5_desc);\r\n#if defined(__alpha__) || defined(__powerpc__) || defined(CONFIG_SPARC) || defined(DE4X5_DO_MEMCPY)\r\nlp->dma_size += RX_BUFF_SZ * NUM_RX_DESC + DE4X5_ALIGN;\r\n#endif\r\nlp->rx_ring = dma_alloc_coherent(gendev, lp->dma_size,\r\n&lp->dma_rings, GFP_ATOMIC);\r\nif (lp->rx_ring == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nlp->tx_ring = lp->rx_ring + NUM_RX_DESC;\r\n#if !defined(__alpha__) && !defined(__powerpc__) && !defined(CONFIG_SPARC) && !defined(DE4X5_DO_MEMCPY)\r\nfor (i=0; i<NUM_RX_DESC; i++) {\r\nlp->rx_ring[i].status = 0;\r\nlp->rx_ring[i].des1 = cpu_to_le32(RX_BUFF_SZ);\r\nlp->rx_ring[i].buf = 0;\r\nlp->rx_ring[i].next = 0;\r\nlp->rx_skb[i] = (struct sk_buff *) 1;\r\n}\r\n#else\r\n{\r\ndma_addr_t dma_rx_bufs;\r\ndma_rx_bufs = lp->dma_rings + (NUM_RX_DESC + NUM_TX_DESC)\r\n* sizeof(struct de4x5_desc);\r\ndma_rx_bufs = (dma_rx_bufs + DE4X5_ALIGN) & ~DE4X5_ALIGN;\r\nlp->rx_bufs = (char *)(((long)(lp->rx_ring + NUM_RX_DESC\r\n+ NUM_TX_DESC) + DE4X5_ALIGN) & ~DE4X5_ALIGN);\r\nfor (i=0; i<NUM_RX_DESC; i++) {\r\nlp->rx_ring[i].status = 0;\r\nlp->rx_ring[i].des1 = cpu_to_le32(RX_BUFF_SZ);\r\nlp->rx_ring[i].buf =\r\ncpu_to_le32(dma_rx_bufs+i*RX_BUFF_SZ);\r\nlp->rx_ring[i].next = 0;\r\nlp->rx_skb[i] = (struct sk_buff *) 1;\r\n}\r\n}\r\n#endif\r\nbarrier();\r\nlp->rxRingSize = NUM_RX_DESC;\r\nlp->txRingSize = NUM_TX_DESC;\r\nlp->rx_ring[lp->rxRingSize - 1].des1 |= cpu_to_le32(RD_RER);\r\nlp->tx_ring[lp->txRingSize - 1].des1 |= cpu_to_le32(TD_TER);\r\noutl(lp->dma_rings, DE4X5_RRBA);\r\noutl(lp->dma_rings + NUM_RX_DESC * sizeof(struct de4x5_desc),\r\nDE4X5_TRBA);\r\nlp->irq_mask = IMR_RIM | IMR_TIM | IMR_TUM | IMR_UNM;\r\nlp->irq_en = IMR_NIM | IMR_AIM;\r\ncreate_packet(dev, lp->frame, sizeof(lp->frame));\r\ni = lp->cfrv & 0x000000fe;\r\nif ((lp->chipset == DC21140) && (i == 0x20)) {\r\nlp->rx_ovf = 1;\r\n}\r\nif (lp->useSROM) {\r\nlp->state = INITIALISED;\r\nif (srom_infoleaf_info(dev)) {\r\ndma_free_coherent (gendev, lp->dma_size,\r\nlp->rx_ring, lp->dma_rings);\r\nreturn -ENXIO;\r\n}\r\nsrom_init(dev);\r\n}\r\nlp->state = CLOSED;\r\nif ((lp->chipset != DC21040) && (lp->chipset != DC21041)) {\r\nmii_get_phy(dev);\r\n}\r\nprintk(" and requires IRQ%d (provided by %s).\n", dev->irq,\r\n((lp->bus == PCI) ? "PCI BIOS" : "EISA CNFG"));\r\n}\r\nif (de4x5_debug & DEBUG_VERSION) {\r\nprintk(version);\r\n}\r\nSET_NETDEV_DEV(dev, gendev);\r\ndev->netdev_ops = &de4x5_netdev_ops;\r\ndev->mem_start = 0;\r\nif ((status = register_netdev (dev))) {\r\ndma_free_coherent (gendev, lp->dma_size,\r\nlp->rx_ring, lp->dma_rings);\r\nreturn status;\r\n}\r\nyawn(dev, SLEEP);\r\nreturn status;\r\n}\r\nstatic int\r\nde4x5_open(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint i, status = 0;\r\ns32 omr;\r\nfor (i=0; i<lp->rxRingSize; i++) {\r\nif (de4x5_alloc_rx_buff(dev, i, 0) == NULL) {\r\nde4x5_free_rx_buffs(dev);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nyawn(dev, WAKEUP);\r\nstatus = de4x5_init(dev);\r\nspin_lock_init(&lp->lock);\r\nlp->state = OPEN;\r\nde4x5_dbg_open(dev);\r\nif (request_irq(dev->irq, de4x5_interrupt, IRQF_SHARED,\r\nlp->adapter_name, dev)) {\r\nprintk("de4x5_open(): Requested IRQ%d is busy - attemping FAST/SHARE...", dev->irq);\r\nif (request_irq(dev->irq, de4x5_interrupt, IRQF_SHARED,\r\nlp->adapter_name, dev)) {\r\nprintk("\n Cannot get IRQ- reconfigure your hardware.\n");\r\ndisable_ast(dev);\r\nde4x5_free_rx_buffs(dev);\r\nde4x5_free_tx_buffs(dev);\r\nyawn(dev, SLEEP);\r\nlp->state = CLOSED;\r\nreturn -EAGAIN;\r\n} else {\r\nprintk("\n Succeeded, but you should reconfigure your hardware to avoid this.\n");\r\nprintk("WARNING: there may be IRQ related problems in heavily loaded systems.\n");\r\n}\r\n}\r\nlp->interrupt = UNMASK_INTERRUPTS;\r\ndev->trans_start = jiffies;\r\nSTART_DE4X5;\r\nde4x5_setup_intr(dev);\r\nif (de4x5_debug & DEBUG_OPEN) {\r\nprintk("\tsts: 0x%08x\n", inl(DE4X5_STS));\r\nprintk("\tbmr: 0x%08x\n", inl(DE4X5_BMR));\r\nprintk("\timr: 0x%08x\n", inl(DE4X5_IMR));\r\nprintk("\tomr: 0x%08x\n", inl(DE4X5_OMR));\r\nprintk("\tsisr: 0x%08x\n", inl(DE4X5_SISR));\r\nprintk("\tsicr: 0x%08x\n", inl(DE4X5_SICR));\r\nprintk("\tstrr: 0x%08x\n", inl(DE4X5_STRR));\r\nprintk("\tsigr: 0x%08x\n", inl(DE4X5_SIGR));\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nde4x5_init(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nde4x5_sw_reset(dev);\r\nautoconf_media(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nde4x5_sw_reset(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint i, j, status = 0;\r\ns32 bmr, omr;\r\nif (!lp->useSROM) {\r\nif (lp->phy[lp->active].id != 0) {\r\nlp->infoblock_csr6 = OMR_SDP | OMR_PS | OMR_HBD;\r\n} else {\r\nlp->infoblock_csr6 = OMR_SDP | OMR_TTM;\r\n}\r\nde4x5_switch_mac_port(dev);\r\n}\r\nbmr = (lp->chipset==DC21140 ? PBL_8 : PBL_4) | DESC_SKIP_LEN | DE4X5_CACHE_ALIGN;\r\nbmr |= ((lp->chipset & ~0x00ff)==DC2114x ? BMR_RML : 0);\r\noutl(bmr, DE4X5_BMR);\r\nomr = inl(DE4X5_OMR) & ~OMR_PR;\r\nif (lp->chipset == DC21140) {\r\nomr |= (OMR_SDP | OMR_SB);\r\n}\r\nlp->setup_f = PERFECT;\r\noutl(lp->dma_rings, DE4X5_RRBA);\r\noutl(lp->dma_rings + NUM_RX_DESC * sizeof(struct de4x5_desc),\r\nDE4X5_TRBA);\r\nlp->rx_new = lp->rx_old = 0;\r\nlp->tx_new = lp->tx_old = 0;\r\nfor (i = 0; i < lp->rxRingSize; i++) {\r\nlp->rx_ring[i].status = cpu_to_le32(R_OWN);\r\n}\r\nfor (i = 0; i < lp->txRingSize; i++) {\r\nlp->tx_ring[i].status = cpu_to_le32(0);\r\n}\r\nbarrier();\r\nSetMulticastFilter(dev);\r\nload_packet(dev, lp->setup_frame, PERFECT_F|TD_SET|SETUP_FRAME_LEN, (struct sk_buff *)1);\r\noutl(omr|OMR_ST, DE4X5_OMR);\r\nfor (j=0, i=0;(i<500) && (j==0);i++) {\r\nmdelay(1);\r\nif ((s32)le32_to_cpu(lp->tx_ring[lp->tx_new].status) >= 0) j=1;\r\n}\r\noutl(omr, DE4X5_OMR);\r\nif (j == 0) {\r\nprintk("%s: Setup frame timed out, status %08x\n", dev->name,\r\ninl(DE4X5_STS));\r\nstatus = -EIO;\r\n}\r\nlp->tx_new = (lp->tx_new + 1) % lp->txRingSize;\r\nlp->tx_old = lp->tx_new;\r\nreturn status;\r\n}\r\nstatic netdev_tx_t\r\nde4x5_queue_pkt(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nu_long flags = 0;\r\nnetif_stop_queue(dev);\r\nif (!lp->tx_enable)\r\nreturn NETDEV_TX_LOCKED;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nde4x5_tx(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (test_and_set_bit(0, (void *)&lp->cache.lock) && !lp->interrupt)\r\nreturn NETDEV_TX_LOCKED;\r\nif (netif_queue_stopped(dev) || (u_long) lp->tx_skb[lp->tx_new] > 1) {\r\nif (lp->interrupt) {\r\nde4x5_putb_cache(dev, skb);\r\n} else {\r\nde4x5_put_cache(dev, skb);\r\n}\r\nif (de4x5_debug & DEBUG_TX) {\r\nprintk("%s: transmit busy, lost media or stale skb found:\n STS:%08x\n tbusy:%d\n IMR:%08x\n OMR:%08x\n Stale skb: %s\n",dev->name, inl(DE4X5_STS), netif_queue_stopped(dev), inl(DE4X5_IMR), inl(DE4X5_OMR), ((u_long) lp->tx_skb[lp->tx_new] > 1) ? "YES" : "NO");\r\n}\r\n} else if (skb->len > 0) {\r\nif (!skb_queue_empty(&lp->cache.queue) && !lp->interrupt) {\r\nde4x5_put_cache(dev, skb);\r\nskb = de4x5_get_cache(dev);\r\n}\r\nwhile (skb && !netif_queue_stopped(dev) &&\r\n(u_long) lp->tx_skb[lp->tx_new] <= 1) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nnetif_stop_queue(dev);\r\nload_packet(dev, skb->data, TD_IC | TD_LS | TD_FS | skb->len, skb);\r\nlp->stats.tx_bytes += skb->len;\r\noutl(POLL_DEMAND, DE4X5_TPD);\r\nlp->tx_new = (lp->tx_new + 1) % lp->txRingSize;\r\nif (TX_BUFFS_AVAIL) {\r\nnetif_start_queue(dev);\r\n}\r\nskb = de4x5_get_cache(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nif (skb) de4x5_putb_cache(dev, skb);\r\n}\r\nlp->cache.lock = 0;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\nde4x5_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct de4x5_private *lp;\r\ns32 imr, omr, sts, limit;\r\nu_long iobase;\r\nunsigned int handled = 0;\r\nlp = netdev_priv(dev);\r\nspin_lock(&lp->lock);\r\niobase = dev->base_addr;\r\nDISABLE_IRQs;\r\nif (test_and_set_bit(MASK_INTERRUPTS, (void*) &lp->interrupt))\r\nprintk("%s: Re-entering the interrupt handler.\n", dev->name);\r\nsynchronize_irq(dev->irq);\r\nfor (limit=0; limit<8; limit++) {\r\nsts = inl(DE4X5_STS);\r\noutl(sts, DE4X5_STS);\r\nif (!(sts & lp->irq_mask)) break;\r\nhandled = 1;\r\nif (sts & (STS_RI | STS_RU))\r\nde4x5_rx(dev);\r\nif (sts & (STS_TI | STS_TU))\r\nde4x5_tx(dev);\r\nif (sts & STS_LNF) {\r\nlp->irq_mask &= ~IMR_LFM;\r\n}\r\nif (sts & STS_UNF) {\r\nde4x5_txur(dev);\r\n}\r\nif (sts & STS_SE) {\r\nSTOP_DE4X5;\r\nprintk("%s: Fatal bus error occurred, sts=%#8x, device stopped.\n",\r\ndev->name, sts);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nif (!test_and_set_bit(0, (void *)&lp->cache.lock)) {\r\nwhile (!skb_queue_empty(&lp->cache.queue) && !netif_queue_stopped(dev) && lp->tx_enable) {\r\nde4x5_queue_pkt(de4x5_get_cache(dev), dev);\r\n}\r\nlp->cache.lock = 0;\r\n}\r\nlp->interrupt = UNMASK_INTERRUPTS;\r\nENABLE_IRQs;\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int\r\nde4x5_rx(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint entry;\r\ns32 status;\r\nfor (entry=lp->rx_new; (s32)le32_to_cpu(lp->rx_ring[entry].status)>=0;\r\nentry=lp->rx_new) {\r\nstatus = (s32)le32_to_cpu(lp->rx_ring[entry].status);\r\nif (lp->rx_ovf) {\r\nif (inl(DE4X5_MFC) & MFC_FOCM) {\r\nde4x5_rx_ovfc(dev);\r\nbreak;\r\n}\r\n}\r\nif (status & RD_FS) {\r\nlp->rx_old = entry;\r\n}\r\nif (status & RD_LS) {\r\nif (lp->tx_enable) lp->linkOK++;\r\nif (status & RD_ES) {\r\nlp->stats.rx_errors++;\r\nif (status & (RD_RF | RD_TL)) lp->stats.rx_frame_errors++;\r\nif (status & RD_CE) lp->stats.rx_crc_errors++;\r\nif (status & RD_OF) lp->stats.rx_fifo_errors++;\r\nif (status & RD_TL) lp->stats.rx_length_errors++;\r\nif (status & RD_RF) lp->pktStats.rx_runt_frames++;\r\nif (status & RD_CS) lp->pktStats.rx_collision++;\r\nif (status & RD_DB) lp->pktStats.rx_dribble++;\r\nif (status & RD_OF) lp->pktStats.rx_overflow++;\r\n} else {\r\nstruct sk_buff *skb;\r\nshort pkt_len = (short)(le32_to_cpu(lp->rx_ring[entry].status)\r\n>> 16) - 4;\r\nif ((skb = de4x5_alloc_rx_buff(dev, entry, pkt_len)) == NULL) {\r\nprintk("%s: Insufficient memory; nuking packet.\n",\r\ndev->name);\r\nlp->stats.rx_dropped++;\r\n} else {\r\nde4x5_dbg_rx(skb, pkt_len);\r\nskb->protocol=eth_type_trans(skb,dev);\r\nde4x5_local_stats(dev, skb->data, pkt_len);\r\nnetif_rx(skb);\r\nlp->stats.rx_packets++;\r\nlp->stats.rx_bytes += pkt_len;\r\n}\r\n}\r\nfor (;lp->rx_old!=entry;lp->rx_old=(lp->rx_old + 1)%lp->rxRingSize) {\r\nlp->rx_ring[lp->rx_old].status = cpu_to_le32(R_OWN);\r\nbarrier();\r\n}\r\nlp->rx_ring[entry].status = cpu_to_le32(R_OWN);\r\nbarrier();\r\n}\r\nlp->rx_new = (lp->rx_new + 1) % lp->rxRingSize;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nde4x5_free_tx_buff(struct de4x5_private *lp, int entry)\r\n{\r\ndma_unmap_single(lp->gendev, le32_to_cpu(lp->tx_ring[entry].buf),\r\nle32_to_cpu(lp->tx_ring[entry].des1) & TD_TBS1,\r\nDMA_TO_DEVICE);\r\nif ((u_long) lp->tx_skb[entry] > 1)\r\ndev_kfree_skb_irq(lp->tx_skb[entry]);\r\nlp->tx_skb[entry] = NULL;\r\n}\r\nstatic int\r\nde4x5_tx(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint entry;\r\ns32 status;\r\nfor (entry = lp->tx_old; entry != lp->tx_new; entry = lp->tx_old) {\r\nstatus = (s32)le32_to_cpu(lp->tx_ring[entry].status);\r\nif (status < 0) {\r\nbreak;\r\n} else if (status != 0x7fffffff) {\r\nif (status & TD_ES) {\r\nlp->stats.tx_errors++;\r\nif (status & TD_NC) lp->stats.tx_carrier_errors++;\r\nif (status & TD_LC) lp->stats.tx_window_errors++;\r\nif (status & TD_UF) lp->stats.tx_fifo_errors++;\r\nif (status & TD_EC) lp->pktStats.excessive_collisions++;\r\nif (status & TD_DE) lp->stats.tx_aborted_errors++;\r\nif (TX_PKT_PENDING) {\r\noutl(POLL_DEMAND, DE4X5_TPD);\r\n}\r\n} else {\r\nlp->stats.tx_packets++;\r\nif (lp->tx_enable) lp->linkOK++;\r\n}\r\nlp->stats.collisions += ((status & TD_EC) ? 16 :\r\n((status & TD_CC) >> 3));\r\nif (lp->tx_skb[entry] != NULL)\r\nde4x5_free_tx_buff(lp, entry);\r\n}\r\nlp->tx_old = (lp->tx_old + 1) % lp->txRingSize;\r\n}\r\nif (TX_BUFFS_AVAIL && netif_queue_stopped(dev)) {\r\nif (lp->interrupt)\r\nnetif_wake_queue(dev);\r\nelse\r\nnetif_start_queue(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nde4x5_ast(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\nint dt;\r\nif (lp->useSROM)\r\nnext_tick = srom_autoconf(dev);\r\nelse if (lp->chipset == DC21140)\r\nnext_tick = dc21140m_autoconf(dev);\r\nelse if (lp->chipset == DC21041)\r\nnext_tick = dc21041_autoconf(dev);\r\nelse if (lp->chipset == DC21040)\r\nnext_tick = dc21040_autoconf(dev);\r\nlp->linkOK = 0;\r\ndt = (next_tick * HZ) / 1000;\r\nif (!dt)\r\ndt = 1;\r\nmod_timer(&lp->timer, jiffies + dt);\r\n}\r\nstatic int\r\nde4x5_txur(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint omr;\r\nomr = inl(DE4X5_OMR);\r\nif (!(omr & OMR_SF) || (lp->chipset==DC21041) || (lp->chipset==DC21040)) {\r\nomr &= ~(OMR_ST|OMR_SR);\r\noutl(omr, DE4X5_OMR);\r\nwhile (inl(DE4X5_STS) & STS_TS);\r\nif ((omr & OMR_TR) < OMR_TR) {\r\nomr += 0x4000;\r\n} else {\r\nomr |= OMR_SF;\r\n}\r\noutl(omr | OMR_ST | OMR_SR, DE4X5_OMR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nde4x5_rx_ovfc(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint omr;\r\nomr = inl(DE4X5_OMR);\r\noutl(omr & ~OMR_SR, DE4X5_OMR);\r\nwhile (inl(DE4X5_STS) & STS_RS);\r\nfor (; (s32)le32_to_cpu(lp->rx_ring[lp->rx_new].status)>=0;) {\r\nlp->rx_ring[lp->rx_new].status = cpu_to_le32(R_OWN);\r\nlp->rx_new = (lp->rx_new + 1) % lp->rxRingSize;\r\n}\r\noutl(omr, DE4X5_OMR);\r\nreturn 0;\r\n}\r\nstatic int\r\nde4x5_close(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ns32 imr, omr;\r\ndisable_ast(dev);\r\nnetif_stop_queue(dev);\r\nif (de4x5_debug & DEBUG_CLOSE) {\r\nprintk("%s: Shutting down ethercard, status was %8.8x.\n",\r\ndev->name, inl(DE4X5_STS));\r\n}\r\nDISABLE_IRQs;\r\nSTOP_DE4X5;\r\nfree_irq(dev->irq, dev);\r\nlp->state = CLOSED;\r\nde4x5_free_rx_buffs(dev);\r\nde4x5_free_tx_buffs(dev);\r\nyawn(dev, SLEEP);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *\r\nde4x5_get_stats(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nlp->stats.rx_missed_errors = (int)(inl(DE4X5_MFC) & (MFC_OVFL | MFC_CNTR));\r\nreturn &lp->stats;\r\n}\r\nstatic void\r\nde4x5_local_stats(struct net_device *dev, char *buf, int pkt_len)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint i;\r\nfor (i=1; i<DE4X5_PKT_STAT_SZ-1; i++) {\r\nif (pkt_len < (i*DE4X5_PKT_BIN_SZ)) {\r\nlp->pktStats.bins[i]++;\r\ni = DE4X5_PKT_STAT_SZ;\r\n}\r\n}\r\nif (is_multicast_ether_addr(buf)) {\r\nif (is_broadcast_ether_addr(buf)) {\r\nlp->pktStats.broadcast++;\r\n} else {\r\nlp->pktStats.multicast++;\r\n}\r\n} else if (ether_addr_equal(buf, dev->dev_addr)) {\r\nlp->pktStats.unicast++;\r\n}\r\nlp->pktStats.bins[0]++;\r\nif (lp->pktStats.bins[0] == 0) {\r\nmemset((char *)&lp->pktStats, 0, sizeof(lp->pktStats));\r\n}\r\n}\r\nstatic void\r\nload_packet(struct net_device *dev, char *buf, u32 flags, struct sk_buff *skb)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint entry = (lp->tx_new ? lp->tx_new-1 : lp->txRingSize-1);\r\ndma_addr_t buf_dma = dma_map_single(lp->gendev, buf, flags & TD_TBS1, DMA_TO_DEVICE);\r\nlp->tx_ring[lp->tx_new].buf = cpu_to_le32(buf_dma);\r\nlp->tx_ring[lp->tx_new].des1 &= cpu_to_le32(TD_TER);\r\nlp->tx_ring[lp->tx_new].des1 |= cpu_to_le32(flags);\r\nlp->tx_skb[lp->tx_new] = skb;\r\nlp->tx_ring[entry].des1 &= cpu_to_le32(~TD_IC);\r\nbarrier();\r\nlp->tx_ring[lp->tx_new].status = cpu_to_le32(T_OWN);\r\nbarrier();\r\n}\r\nstatic void\r\nset_multicast_list(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nif (lp->state == OPEN) {\r\nif (dev->flags & IFF_PROMISC) {\r\nu32 omr;\r\nomr = inl(DE4X5_OMR);\r\nomr |= OMR_PR;\r\noutl(omr, DE4X5_OMR);\r\n} else {\r\nSetMulticastFilter(dev);\r\nload_packet(dev, lp->setup_frame, TD_IC | PERFECT_F | TD_SET |\r\nSETUP_FRAME_LEN, (struct sk_buff *)1);\r\nlp->tx_new = (lp->tx_new + 1) % lp->txRingSize;\r\noutl(POLL_DEMAND, DE4X5_TPD);\r\ndev->trans_start = jiffies;\r\n}\r\n}\r\n}\r\nstatic void\r\nSetMulticastFilter(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nu_long iobase = dev->base_addr;\r\nint i, bit, byte;\r\nu16 hashcode;\r\nu32 omr, crc;\r\nchar *pa;\r\nunsigned char *addrs;\r\nomr = inl(DE4X5_OMR);\r\nomr &= ~(OMR_PR | OMR_PM);\r\npa = build_setup_frame(dev, ALL);\r\nif ((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 14)) {\r\nomr |= OMR_PM;\r\n} else if (lp->setup_f == HASH_PERF) {\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(ETH_ALEN, ha->addr);\r\nhashcode = crc & HASH_BITS;\r\nbyte = hashcode >> 3;\r\nbit = 1 << (hashcode & 0x07);\r\nbyte <<= 1;\r\nif (byte & 0x02) {\r\nbyte -= 1;\r\n}\r\nlp->setup_frame[byte] |= bit;\r\n}\r\n} else {\r\nnetdev_for_each_mc_addr(ha, dev) {\r\naddrs = ha->addr;\r\nfor (i=0; i<ETH_ALEN; i++) {\r\n*(pa + (i&1)) = *addrs++;\r\nif (i & 0x01) pa += 4;\r\n}\r\n}\r\n}\r\noutl(omr, DE4X5_OMR);\r\n}\r\nstatic int __init de4x5_eisa_probe (struct device *gendev)\r\n{\r\nstruct eisa_device *edev;\r\nu_long iobase;\r\nu_char irq, regval;\r\nu_short vendor;\r\nu32 cfid;\r\nint status, device;\r\nstruct net_device *dev;\r\nstruct de4x5_private *lp;\r\nedev = to_eisa_device (gendev);\r\niobase = edev->base_addr;\r\nif (!request_region (iobase, DE4X5_EISA_TOTAL_SIZE, "de4x5"))\r\nreturn -EBUSY;\r\nif (!request_region (iobase + DE4X5_EISA_IO_PORTS,\r\nDE4X5_EISA_TOTAL_SIZE, "de4x5")) {\r\nstatus = -EBUSY;\r\ngoto release_reg_1;\r\n}\r\nif (!(dev = alloc_etherdev (sizeof (struct de4x5_private)))) {\r\nstatus = -ENOMEM;\r\ngoto release_reg_2;\r\n}\r\nlp = netdev_priv(dev);\r\ncfid = (u32) inl(PCI_CFID);\r\nlp->cfrv = (u_short) inl(PCI_CFRV);\r\ndevice = (cfid >> 8) & 0x00ffff00;\r\nvendor = (u_short) cfid;\r\nregval = inb(EISA_REG0) & (ER0_INTL | ER0_INTT);\r\n#ifdef CONFIG_ALPHA\r\noutb (ER1_IAM | 1, EISA_REG1);\r\nmdelay (1);\r\noutb (ER1_IAM, EISA_REG1);\r\nmdelay (1);\r\noutb (ER3_BWE | ER3_BRE, EISA_REG3);\r\noutb (ER0_BSW | ER0_BMW | ER0_EPT | regval, EISA_REG0);\r\n#endif\r\nirq = de4x5_irq[(regval >> 1) & 0x03];\r\nif (is_DC2114x) {\r\ndevice = ((lp->cfrv & CFRV_RN) < DC2114x_BRK ? DC21142 : DC21143);\r\n}\r\nlp->chipset = device;\r\nlp->bus = EISA;\r\noutl(PCI_COMMAND_IO | PCI_COMMAND_MASTER, PCI_CFCS);\r\noutl(0x00006000, PCI_CFLT);\r\noutl(iobase, PCI_CBIO);\r\nDevicePresent(dev, EISA_APROM);\r\ndev->irq = irq;\r\nif (!(status = de4x5_hw_init (dev, iobase, gendev))) {\r\nreturn 0;\r\n}\r\nfree_netdev (dev);\r\nrelease_reg_2:\r\nrelease_region (iobase + DE4X5_EISA_IO_PORTS, DE4X5_EISA_TOTAL_SIZE);\r\nrelease_reg_1:\r\nrelease_region (iobase, DE4X5_EISA_TOTAL_SIZE);\r\nreturn status;\r\n}\r\nstatic int de4x5_eisa_remove(struct device *device)\r\n{\r\nstruct net_device *dev;\r\nu_long iobase;\r\ndev = dev_get_drvdata(device);\r\niobase = dev->base_addr;\r\nunregister_netdev (dev);\r\nfree_netdev (dev);\r\nrelease_region (iobase + DE4X5_EISA_IO_PORTS, DE4X5_EISA_TOTAL_SIZE);\r\nrelease_region (iobase, DE4X5_EISA_TOTAL_SIZE);\r\nreturn 0;\r\n}\r\nstatic void\r\nsrom_search(struct net_device *dev, struct pci_dev *pdev)\r\n{\r\nu_char pb;\r\nu_short vendor, status;\r\nu_int irq = 0, device;\r\nu_long iobase = 0;\r\nint i, j;\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nstruct pci_dev *this_dev;\r\nlist_for_each_entry(this_dev, &pdev->bus->devices, bus_list) {\r\nvendor = this_dev->vendor;\r\ndevice = this_dev->device << 8;\r\nif (!(is_DC21040 || is_DC21041 || is_DC21140 || is_DC2114x)) continue;\r\npb = this_dev->bus->number;\r\nlp->device = PCI_SLOT(this_dev->devfn);\r\nlp->bus_num = pb;\r\nif (is_DC2114x) {\r\ndevice = ((this_dev->revision & CFRV_RN) < DC2114x_BRK\r\n? DC21142 : DC21143);\r\n}\r\nlp->chipset = device;\r\niobase = pci_resource_start(this_dev, 0);\r\nirq = this_dev->irq;\r\nif ((irq == 0) || (irq == 0xff) || ((int)irq == -1)) continue;\r\npci_read_config_word(this_dev, PCI_COMMAND, &status);\r\nif (!(status & PCI_COMMAND_IO)) continue;\r\nDevicePresent(dev, DE4X5_APROM);\r\nfor (j=0, i=0; i<ETH_ALEN; i++) {\r\nj += (u_char) *((u_char *)&lp->srom + SROM_HWADD + i);\r\n}\r\nif (j != 0 && j != 6 * 0xff) {\r\nlast.chipset = device;\r\nlast.bus = pb;\r\nlast.irq = irq;\r\nfor (i=0; i<ETH_ALEN; i++) {\r\nlast.addr[i] = (u_char)*((u_char *)&lp->srom + SROM_HWADD + i);\r\n}\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int de4x5_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nu_char pb, pbus = 0, dev_num, dnum = 0, timer;\r\nu_short vendor, status;\r\nu_int irq = 0, device;\r\nu_long iobase = 0;\r\nint error;\r\nstruct net_device *dev;\r\nstruct de4x5_private *lp;\r\ndev_num = PCI_SLOT(pdev->devfn);\r\npb = pdev->bus->number;\r\nif (io) {\r\npbus = (u_short)(io >> 8);\r\ndnum = (u_short)(io & 0xff);\r\nif ((pbus != pb) || (dnum != dev_num))\r\nreturn -ENODEV;\r\n}\r\nvendor = pdev->vendor;\r\ndevice = pdev->device << 8;\r\nif (!(is_DC21040 || is_DC21041 || is_DC21140 || is_DC2114x))\r\nreturn -ENODEV;\r\nif ((error = pci_enable_device (pdev)))\r\nreturn error;\r\nif (!(dev = alloc_etherdev (sizeof (struct de4x5_private)))) {\r\nerror = -ENOMEM;\r\ngoto disable_dev;\r\n}\r\nlp = netdev_priv(dev);\r\nlp->bus = PCI;\r\nlp->bus_num = 0;\r\nif (lp->bus_num != pb) {\r\nlp->bus_num = pb;\r\nsrom_search(dev, pdev);\r\n}\r\nlp->cfrv = pdev->revision;\r\nlp->device = dev_num;\r\nlp->bus_num = pb;\r\nif (is_DC2114x) {\r\ndevice = ((lp->cfrv & CFRV_RN) < DC2114x_BRK ? DC21142 : DC21143);\r\n}\r\nlp->chipset = device;\r\niobase = pci_resource_start(pdev, 0);\r\nirq = pdev->irq;\r\nif ((irq == 0) || (irq == 0xff) || ((int)irq == -1)) {\r\nerror = -ENODEV;\r\ngoto free_dev;\r\n}\r\npci_read_config_word(pdev, PCI_COMMAND, &status);\r\n#ifdef __powerpc__\r\nif (!(status & PCI_COMMAND_IO)) {\r\nstatus |= PCI_COMMAND_IO;\r\npci_write_config_word(pdev, PCI_COMMAND, status);\r\npci_read_config_word(pdev, PCI_COMMAND, &status);\r\n}\r\n#endif\r\nif (!(status & PCI_COMMAND_IO)) {\r\nerror = -ENODEV;\r\ngoto free_dev;\r\n}\r\nif (!(status & PCI_COMMAND_MASTER)) {\r\nstatus |= PCI_COMMAND_MASTER;\r\npci_write_config_word(pdev, PCI_COMMAND, status);\r\npci_read_config_word(pdev, PCI_COMMAND, &status);\r\n}\r\nif (!(status & PCI_COMMAND_MASTER)) {\r\nerror = -ENODEV;\r\ngoto free_dev;\r\n}\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &timer);\r\nif (timer < 0x60) {\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x60);\r\n}\r\nDevicePresent(dev, DE4X5_APROM);\r\nif (!request_region (iobase, DE4X5_PCI_TOTAL_SIZE, "de4x5")) {\r\nerror = -EBUSY;\r\ngoto free_dev;\r\n}\r\ndev->irq = irq;\r\nif ((error = de4x5_hw_init(dev, iobase, &pdev->dev))) {\r\ngoto release;\r\n}\r\nreturn 0;\r\nrelease:\r\nrelease_region (iobase, DE4X5_PCI_TOTAL_SIZE);\r\nfree_dev:\r\nfree_netdev (dev);\r\ndisable_dev:\r\npci_disable_device (pdev);\r\nreturn error;\r\n}\r\nstatic void de4x5_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev;\r\nu_long iobase;\r\ndev = pci_get_drvdata(pdev);\r\niobase = dev->base_addr;\r\nunregister_netdev (dev);\r\nfree_netdev (dev);\r\nrelease_region (iobase, DE4X5_PCI_TOTAL_SIZE);\r\npci_disable_device (pdev);\r\n}\r\nstatic int\r\nautoconf_media(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ndisable_ast(dev);\r\nlp->c_media = AUTO;\r\ninl(DE4X5_MFC);\r\nlp->media = INIT;\r\nlp->tcount = 0;\r\nde4x5_ast(dev);\r\nreturn lp->media;\r\n}\r\nstatic int\r\ndc21040_autoconf(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\ns32 imr;\r\nswitch (lp->media) {\r\ncase INIT:\r\nDISABLE_IRQs;\r\nlp->tx_enable = false;\r\nlp->timeout = -1;\r\nde4x5_save_skbs(dev);\r\nif ((lp->autosense == AUTO) || (lp->autosense == TP)) {\r\nlp->media = TP;\r\n} else if ((lp->autosense == BNC) || (lp->autosense == AUI) || (lp->autosense == BNC_AUI)) {\r\nlp->media = BNC_AUI;\r\n} else if (lp->autosense == EXT_SIA) {\r\nlp->media = EXT_SIA;\r\n} else {\r\nlp->media = NC;\r\n}\r\nlp->local_state = 0;\r\nnext_tick = dc21040_autoconf(dev);\r\nbreak;\r\ncase TP:\r\nnext_tick = dc21040_state(dev, 0x8f01, 0xffff, 0x0000, 3000, BNC_AUI,\r\nTP_SUSPECT, test_tp);\r\nbreak;\r\ncase TP_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, TP, test_tp, dc21040_autoconf);\r\nbreak;\r\ncase BNC:\r\ncase AUI:\r\ncase BNC_AUI:\r\nnext_tick = dc21040_state(dev, 0x8f09, 0x0705, 0x0006, 3000, EXT_SIA,\r\nBNC_AUI_SUSPECT, ping_media);\r\nbreak;\r\ncase BNC_AUI_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, BNC_AUI, ping_media, dc21040_autoconf);\r\nbreak;\r\ncase EXT_SIA:\r\nnext_tick = dc21040_state(dev, 0x3041, 0x0000, 0x0006, 3000,\r\nNC, EXT_SIA_SUSPECT, ping_media);\r\nbreak;\r\ncase EXT_SIA_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, EXT_SIA, ping_media, dc21040_autoconf);\r\nbreak;\r\ncase NC:\r\nreset_init_sia(dev, 0x8f01, 0xffff, 0x0000);\r\nif (lp->media != lp->c_media) {\r\nde4x5_dbg_media(dev);\r\nlp->c_media = lp->media;\r\n}\r\nlp->media = INIT;\r\nlp->tx_enable = false;\r\nbreak;\r\n}\r\nreturn next_tick;\r\n}\r\nstatic int\r\ndc21040_state(struct net_device *dev, int csr13, int csr14, int csr15, int timeout,\r\nint next_state, int suspect_state,\r\nint (*fn)(struct net_device *, int))\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\nint linkBad;\r\nswitch (lp->local_state) {\r\ncase 0:\r\nreset_init_sia(dev, csr13, csr14, csr15);\r\nlp->local_state++;\r\nnext_tick = 500;\r\nbreak;\r\ncase 1:\r\nif (!lp->tx_enable) {\r\nlinkBad = fn(dev, timeout);\r\nif (linkBad < 0) {\r\nnext_tick = linkBad & ~TIMER_CB;\r\n} else {\r\nif (linkBad && (lp->autosense == AUTO)) {\r\nlp->local_state = 0;\r\nlp->media = next_state;\r\n} else {\r\nde4x5_init_connection(dev);\r\n}\r\n}\r\n} else if (!lp->linkOK && (lp->autosense == AUTO)) {\r\nlp->media = suspect_state;\r\nnext_tick = 3000;\r\n}\r\nbreak;\r\n}\r\nreturn next_tick;\r\n}\r\nstatic int\r\nde4x5_suspect_state(struct net_device *dev, int timeout, int prev_state,\r\nint (*fn)(struct net_device *, int),\r\nint (*asfn)(struct net_device *))\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\nint linkBad;\r\nswitch (lp->local_state) {\r\ncase 1:\r\nif (lp->linkOK) {\r\nlp->media = prev_state;\r\n} else {\r\nlp->local_state++;\r\nnext_tick = asfn(dev);\r\n}\r\nbreak;\r\ncase 2:\r\nlinkBad = fn(dev, timeout);\r\nif (linkBad < 0) {\r\nnext_tick = linkBad & ~TIMER_CB;\r\n} else if (!linkBad) {\r\nlp->local_state--;\r\nlp->media = prev_state;\r\n} else {\r\nlp->media = INIT;\r\nlp->tcount++;\r\n}\r\n}\r\nreturn next_tick;\r\n}\r\nstatic int\r\ndc21041_autoconf(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ns32 sts, irqs, irq_mask, imr, omr;\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\nswitch (lp->media) {\r\ncase INIT:\r\nDISABLE_IRQs;\r\nlp->tx_enable = false;\r\nlp->timeout = -1;\r\nde4x5_save_skbs(dev);\r\nif ((lp->autosense == AUTO) || (lp->autosense == TP_NW)) {\r\nlp->media = TP;\r\n} else if (lp->autosense == TP) {\r\nlp->media = TP;\r\n} else if (lp->autosense == BNC) {\r\nlp->media = BNC;\r\n} else if (lp->autosense == AUI) {\r\nlp->media = AUI;\r\n} else {\r\nlp->media = NC;\r\n}\r\nlp->local_state = 0;\r\nnext_tick = dc21041_autoconf(dev);\r\nbreak;\r\ncase TP_NW:\r\nif (lp->timeout < 0) {\r\nomr = inl(DE4X5_OMR);\r\noutl(omr | OMR_FDX, DE4X5_OMR);\r\n}\r\nirqs = STS_LNF | STS_LNP;\r\nirq_mask = IMR_LFM | IMR_LPM;\r\nsts = test_media(dev, irqs, irq_mask, 0xef01, 0xffff, 0x0008, 2400);\r\nif (sts < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nif (sts & STS_LNP) {\r\nlp->media = ANS;\r\n} else {\r\nlp->media = AUI;\r\n}\r\nnext_tick = dc21041_autoconf(dev);\r\n}\r\nbreak;\r\ncase ANS:\r\nif (!lp->tx_enable) {\r\nirqs = STS_LNP;\r\nirq_mask = IMR_LPM;\r\nsts = test_ans(dev, irqs, irq_mask, 3000);\r\nif (sts < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nif (!(sts & STS_LNP) && (lp->autosense == AUTO)) {\r\nlp->media = TP;\r\nnext_tick = dc21041_autoconf(dev);\r\n} else {\r\nlp->local_state = 1;\r\nde4x5_init_connection(dev);\r\n}\r\n}\r\n} else if (!lp->linkOK && (lp->autosense == AUTO)) {\r\nlp->media = ANS_SUSPECT;\r\nnext_tick = 3000;\r\n}\r\nbreak;\r\ncase ANS_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, ANS, test_tp, dc21041_autoconf);\r\nbreak;\r\ncase TP:\r\nif (!lp->tx_enable) {\r\nif (lp->timeout < 0) {\r\nomr = inl(DE4X5_OMR);\r\noutl(omr & ~OMR_FDX, DE4X5_OMR);\r\n}\r\nirqs = STS_LNF | STS_LNP;\r\nirq_mask = IMR_LFM | IMR_LPM;\r\nsts = test_media(dev,irqs, irq_mask, 0xef01, 0xff3f, 0x0008, 2400);\r\nif (sts < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nif (!(sts & STS_LNP) && (lp->autosense == AUTO)) {\r\nif (inl(DE4X5_SISR) & SISR_NRA) {\r\nlp->media = AUI;\r\n} else {\r\nlp->media = BNC;\r\n}\r\nnext_tick = dc21041_autoconf(dev);\r\n} else {\r\nlp->local_state = 1;\r\nde4x5_init_connection(dev);\r\n}\r\n}\r\n} else if (!lp->linkOK && (lp->autosense == AUTO)) {\r\nlp->media = TP_SUSPECT;\r\nnext_tick = 3000;\r\n}\r\nbreak;\r\ncase TP_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, TP, test_tp, dc21041_autoconf);\r\nbreak;\r\ncase AUI:\r\nif (!lp->tx_enable) {\r\nif (lp->timeout < 0) {\r\nomr = inl(DE4X5_OMR);\r\noutl(omr & ~OMR_FDX, DE4X5_OMR);\r\n}\r\nirqs = 0;\r\nirq_mask = 0;\r\nsts = test_media(dev,irqs, irq_mask, 0xef09, 0xf73d, 0x000e, 1000);\r\nif (sts < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nif (!(inl(DE4X5_SISR) & SISR_SRA) && (lp->autosense == AUTO)) {\r\nlp->media = BNC;\r\nnext_tick = dc21041_autoconf(dev);\r\n} else {\r\nlp->local_state = 1;\r\nde4x5_init_connection(dev);\r\n}\r\n}\r\n} else if (!lp->linkOK && (lp->autosense == AUTO)) {\r\nlp->media = AUI_SUSPECT;\r\nnext_tick = 3000;\r\n}\r\nbreak;\r\ncase AUI_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, AUI, ping_media, dc21041_autoconf);\r\nbreak;\r\ncase BNC:\r\nswitch (lp->local_state) {\r\ncase 0:\r\nif (lp->timeout < 0) {\r\nomr = inl(DE4X5_OMR);\r\noutl(omr & ~OMR_FDX, DE4X5_OMR);\r\n}\r\nirqs = 0;\r\nirq_mask = 0;\r\nsts = test_media(dev,irqs, irq_mask, 0xef09, 0xf73d, 0x0006, 1000);\r\nif (sts < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nlp->local_state++;\r\nnext_tick = dc21041_autoconf(dev);\r\n}\r\nbreak;\r\ncase 1:\r\nif (!lp->tx_enable) {\r\nif ((sts = ping_media(dev, 3000)) < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nif (sts) {\r\nlp->local_state = 0;\r\nlp->media = NC;\r\n} else {\r\nde4x5_init_connection(dev);\r\n}\r\n}\r\n} else if (!lp->linkOK && (lp->autosense == AUTO)) {\r\nlp->media = BNC_SUSPECT;\r\nnext_tick = 3000;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase BNC_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, BNC, ping_media, dc21041_autoconf);\r\nbreak;\r\ncase NC:\r\nomr = inl(DE4X5_OMR);\r\noutl(omr | OMR_FDX, DE4X5_OMR);\r\nreset_init_sia(dev, 0xef01, 0xffff, 0x0008);\r\nif (lp->media != lp->c_media) {\r\nde4x5_dbg_media(dev);\r\nlp->c_media = lp->media;\r\n}\r\nlp->media = INIT;\r\nlp->tx_enable = false;\r\nbreak;\r\n}\r\nreturn next_tick;\r\n}\r\nstatic int\r\ndc21140m_autoconf(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint ana, anlpa, cap, cr, slnk, sr;\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\nu_long imr, omr, iobase = dev->base_addr;\r\nswitch(lp->media) {\r\ncase INIT:\r\nif (lp->timeout < 0) {\r\nDISABLE_IRQs;\r\nlp->tx_enable = false;\r\nlp->linkOK = 0;\r\nde4x5_save_skbs(dev);\r\n}\r\nif ((next_tick = de4x5_reset_phy(dev)) < 0) {\r\nnext_tick &= ~TIMER_CB;\r\n} else {\r\nif (lp->useSROM) {\r\nif (srom_map_media(dev) < 0) {\r\nlp->tcount++;\r\nreturn next_tick;\r\n}\r\nsrom_exec(dev, lp->phy[lp->active].gep);\r\nif (lp->infoblock_media == ANS) {\r\nana = lp->phy[lp->active].ana | MII_ANA_CSMA;\r\nmii_wr(ana, MII_ANA, lp->phy[lp->active].addr, DE4X5_MII);\r\n}\r\n} else {\r\nlp->tmp = MII_SR_ASSC;\r\nSET_10Mb;\r\nif (lp->autosense == _100Mb) {\r\nlp->media = _100Mb;\r\n} else if (lp->autosense == _10Mb) {\r\nlp->media = _10Mb;\r\n} else if ((lp->autosense == AUTO) &&\r\n((sr=is_anc_capable(dev)) & MII_SR_ANC)) {\r\nana = (((sr >> 6) & MII_ANA_TAF) | MII_ANA_CSMA);\r\nana &= (lp->fdx ? ~0 : ~MII_ANA_FDAM);\r\nmii_wr(ana, MII_ANA, lp->phy[lp->active].addr, DE4X5_MII);\r\nlp->media = ANS;\r\n} else if (lp->autosense == AUTO) {\r\nlp->media = SPD_DET;\r\n} else if (is_spd_100(dev) && is_100_up(dev)) {\r\nlp->media = _100Mb;\r\n} else {\r\nlp->media = NC;\r\n}\r\n}\r\nlp->local_state = 0;\r\nnext_tick = dc21140m_autoconf(dev);\r\n}\r\nbreak;\r\ncase ANS:\r\nswitch (lp->local_state) {\r\ncase 0:\r\nif (lp->timeout < 0) {\r\nmii_wr(MII_CR_ASSE | MII_CR_RAN, MII_CR, lp->phy[lp->active].addr, DE4X5_MII);\r\n}\r\ncr = test_mii_reg(dev, MII_CR, MII_CR_RAN, false, 500);\r\nif (cr < 0) {\r\nnext_tick = cr & ~TIMER_CB;\r\n} else {\r\nif (cr) {\r\nlp->local_state = 0;\r\nlp->media = SPD_DET;\r\n} else {\r\nlp->local_state++;\r\n}\r\nnext_tick = dc21140m_autoconf(dev);\r\n}\r\nbreak;\r\ncase 1:\r\nif ((sr=test_mii_reg(dev, MII_SR, MII_SR_ASSC, true, 2000)) < 0) {\r\nnext_tick = sr & ~TIMER_CB;\r\n} else {\r\nlp->media = SPD_DET;\r\nlp->local_state = 0;\r\nif (sr) {\r\nlp->tmp = MII_SR_ASSC;\r\nanlpa = mii_rd(MII_ANLPA, lp->phy[lp->active].addr, DE4X5_MII);\r\nana = mii_rd(MII_ANA, lp->phy[lp->active].addr, DE4X5_MII);\r\nif (!(anlpa & MII_ANLPA_RF) &&\r\n(cap = anlpa & MII_ANLPA_TAF & ana)) {\r\nif (cap & MII_ANA_100M) {\r\nlp->fdx = (ana & anlpa & MII_ANA_FDAM & MII_ANA_100M) != 0;\r\nlp->media = _100Mb;\r\n} else if (cap & MII_ANA_10M) {\r\nlp->fdx = (ana & anlpa & MII_ANA_FDAM & MII_ANA_10M) != 0;\r\nlp->media = _10Mb;\r\n}\r\n}\r\n}\r\nnext_tick = dc21140m_autoconf(dev);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase SPD_DET:\r\nif (lp->timeout < 0) {\r\nlp->tmp = (lp->phy[lp->active].id ? MII_SR_LKS :\r\n(~gep_rd(dev) & GEP_LNP));\r\nSET_100Mb_PDET;\r\n}\r\nif ((slnk = test_for_100Mb(dev, 6500)) < 0) {\r\nnext_tick = slnk & ~TIMER_CB;\r\n} else {\r\nif (is_spd_100(dev) && is_100_up(dev)) {\r\nlp->media = _100Mb;\r\n} else if ((!is_spd_100(dev) && (is_10_up(dev) & lp->tmp))) {\r\nlp->media = _10Mb;\r\n} else {\r\nlp->media = NC;\r\n}\r\nnext_tick = dc21140m_autoconf(dev);\r\n}\r\nbreak;\r\ncase _100Mb:\r\nnext_tick = 3000;\r\nif (!lp->tx_enable) {\r\nSET_100Mb;\r\nde4x5_init_connection(dev);\r\n} else {\r\nif (!lp->linkOK && (lp->autosense == AUTO)) {\r\nif (!is_100_up(dev) || (!lp->useSROM && !is_spd_100(dev))) {\r\nlp->media = INIT;\r\nlp->tcount++;\r\nnext_tick = DE4X5_AUTOSENSE_MS;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase BNC:\r\ncase AUI:\r\ncase _10Mb:\r\nnext_tick = 3000;\r\nif (!lp->tx_enable) {\r\nSET_10Mb;\r\nde4x5_init_connection(dev);\r\n} else {\r\nif (!lp->linkOK && (lp->autosense == AUTO)) {\r\nif (!is_10_up(dev) || (!lp->useSROM && is_spd_100(dev))) {\r\nlp->media = INIT;\r\nlp->tcount++;\r\nnext_tick = DE4X5_AUTOSENSE_MS;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase NC:\r\nif (lp->media != lp->c_media) {\r\nde4x5_dbg_media(dev);\r\nlp->c_media = lp->media;\r\n}\r\nlp->media = INIT;\r\nlp->tx_enable = false;\r\nbreak;\r\n}\r\nreturn next_tick;\r\n}\r\nstatic int\r\ndc2114x_autoconf(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ns32 cr, anlpa, ana, cap, irqs, irq_mask, imr, omr, slnk, sr, sts;\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\nswitch (lp->media) {\r\ncase INIT:\r\nif (lp->timeout < 0) {\r\nDISABLE_IRQs;\r\nlp->tx_enable = false;\r\nlp->linkOK = 0;\r\nlp->timeout = -1;\r\nde4x5_save_skbs(dev);\r\nif (lp->params.autosense & ~AUTO) {\r\nsrom_map_media(dev);\r\nif (lp->media != lp->params.autosense) {\r\nlp->tcount++;\r\nlp->media = INIT;\r\nreturn next_tick;\r\n}\r\nlp->media = INIT;\r\n}\r\n}\r\nif ((next_tick = de4x5_reset_phy(dev)) < 0) {\r\nnext_tick &= ~TIMER_CB;\r\n} else {\r\nif (lp->autosense == _100Mb) {\r\nlp->media = _100Mb;\r\n} else if (lp->autosense == _10Mb) {\r\nlp->media = _10Mb;\r\n} else if (lp->autosense == TP) {\r\nlp->media = TP;\r\n} else if (lp->autosense == BNC) {\r\nlp->media = BNC;\r\n} else if (lp->autosense == AUI) {\r\nlp->media = AUI;\r\n} else {\r\nlp->media = SPD_DET;\r\nif ((lp->infoblock_media == ANS) &&\r\n((sr=is_anc_capable(dev)) & MII_SR_ANC)) {\r\nana = (((sr >> 6) & MII_ANA_TAF) | MII_ANA_CSMA);\r\nana &= (lp->fdx ? ~0 : ~MII_ANA_FDAM);\r\nmii_wr(ana, MII_ANA, lp->phy[lp->active].addr, DE4X5_MII);\r\nlp->media = ANS;\r\n}\r\n}\r\nlp->local_state = 0;\r\nnext_tick = dc2114x_autoconf(dev);\r\n}\r\nbreak;\r\ncase ANS:\r\nswitch (lp->local_state) {\r\ncase 0:\r\nif (lp->timeout < 0) {\r\nmii_wr(MII_CR_ASSE | MII_CR_RAN, MII_CR, lp->phy[lp->active].addr, DE4X5_MII);\r\n}\r\ncr = test_mii_reg(dev, MII_CR, MII_CR_RAN, false, 500);\r\nif (cr < 0) {\r\nnext_tick = cr & ~TIMER_CB;\r\n} else {\r\nif (cr) {\r\nlp->local_state = 0;\r\nlp->media = SPD_DET;\r\n} else {\r\nlp->local_state++;\r\n}\r\nnext_tick = dc2114x_autoconf(dev);\r\n}\r\nbreak;\r\ncase 1:\r\nsr = test_mii_reg(dev, MII_SR, MII_SR_ASSC, true, 2000);\r\nif (sr < 0) {\r\nnext_tick = sr & ~TIMER_CB;\r\n} else {\r\nlp->media = SPD_DET;\r\nlp->local_state = 0;\r\nif (sr) {\r\nlp->tmp = MII_SR_ASSC;\r\nanlpa = mii_rd(MII_ANLPA, lp->phy[lp->active].addr, DE4X5_MII);\r\nana = mii_rd(MII_ANA, lp->phy[lp->active].addr, DE4X5_MII);\r\nif (!(anlpa & MII_ANLPA_RF) &&\r\n(cap = anlpa & MII_ANLPA_TAF & ana)) {\r\nif (cap & MII_ANA_100M) {\r\nlp->fdx = (ana & anlpa & MII_ANA_FDAM & MII_ANA_100M) != 0;\r\nlp->media = _100Mb;\r\n} else if (cap & MII_ANA_10M) {\r\nlp->fdx = (ana & anlpa & MII_ANA_FDAM & MII_ANA_10M) != 0;\r\nlp->media = _10Mb;\r\n}\r\n}\r\n}\r\nnext_tick = dc2114x_autoconf(dev);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase AUI:\r\nif (!lp->tx_enable) {\r\nif (lp->timeout < 0) {\r\nomr = inl(DE4X5_OMR);\r\noutl(omr & ~OMR_FDX, DE4X5_OMR);\r\n}\r\nirqs = 0;\r\nirq_mask = 0;\r\nsts = test_media(dev,irqs, irq_mask, 0, 0, 0, 1000);\r\nif (sts < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nif (!(inl(DE4X5_SISR) & SISR_SRA) && (lp->autosense == AUTO)) {\r\nlp->media = BNC;\r\nnext_tick = dc2114x_autoconf(dev);\r\n} else {\r\nlp->local_state = 1;\r\nde4x5_init_connection(dev);\r\n}\r\n}\r\n} else if (!lp->linkOK && (lp->autosense == AUTO)) {\r\nlp->media = AUI_SUSPECT;\r\nnext_tick = 3000;\r\n}\r\nbreak;\r\ncase AUI_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, AUI, ping_media, dc2114x_autoconf);\r\nbreak;\r\ncase BNC:\r\nswitch (lp->local_state) {\r\ncase 0:\r\nif (lp->timeout < 0) {\r\nomr = inl(DE4X5_OMR);\r\noutl(omr & ~OMR_FDX, DE4X5_OMR);\r\n}\r\nirqs = 0;\r\nirq_mask = 0;\r\nsts = test_media(dev,irqs, irq_mask, 0, 0, 0, 1000);\r\nif (sts < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nlp->local_state++;\r\nnext_tick = dc2114x_autoconf(dev);\r\n}\r\nbreak;\r\ncase 1:\r\nif (!lp->tx_enable) {\r\nif ((sts = ping_media(dev, 3000)) < 0) {\r\nnext_tick = sts & ~TIMER_CB;\r\n} else {\r\nif (sts) {\r\nlp->local_state = 0;\r\nlp->tcount++;\r\nlp->media = INIT;\r\n} else {\r\nde4x5_init_connection(dev);\r\n}\r\n}\r\n} else if (!lp->linkOK && (lp->autosense == AUTO)) {\r\nlp->media = BNC_SUSPECT;\r\nnext_tick = 3000;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase BNC_SUSPECT:\r\nnext_tick = de4x5_suspect_state(dev, 1000, BNC, ping_media, dc2114x_autoconf);\r\nbreak;\r\ncase SPD_DET:\r\nif (srom_map_media(dev) < 0) {\r\nlp->tcount++;\r\nlp->media = INIT;\r\nreturn next_tick;\r\n}\r\nif (lp->media == _100Mb) {\r\nif ((slnk = test_for_100Mb(dev, 6500)) < 0) {\r\nlp->media = SPD_DET;\r\nreturn slnk & ~TIMER_CB;\r\n}\r\n} else {\r\nif (wait_for_link(dev) < 0) {\r\nlp->media = SPD_DET;\r\nreturn PDET_LINK_WAIT;\r\n}\r\n}\r\nif (lp->media == ANS) {\r\nif (is_spd_100(dev)) {\r\nlp->media = _100Mb;\r\n} else {\r\nlp->media = _10Mb;\r\n}\r\nnext_tick = dc2114x_autoconf(dev);\r\n} else if (((lp->media == _100Mb) && is_100_up(dev)) ||\r\n(((lp->media == _10Mb) || (lp->media == TP) ||\r\n(lp->media == BNC) || (lp->media == AUI)) &&\r\nis_10_up(dev))) {\r\nnext_tick = dc2114x_autoconf(dev);\r\n} else {\r\nlp->tcount++;\r\nlp->media = INIT;\r\n}\r\nbreak;\r\ncase _10Mb:\r\nnext_tick = 3000;\r\nif (!lp->tx_enable) {\r\nSET_10Mb;\r\nde4x5_init_connection(dev);\r\n} else {\r\nif (!lp->linkOK && (lp->autosense == AUTO)) {\r\nif (!is_10_up(dev) || (!lp->useSROM && is_spd_100(dev))) {\r\nlp->media = INIT;\r\nlp->tcount++;\r\nnext_tick = DE4X5_AUTOSENSE_MS;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase _100Mb:\r\nnext_tick = 3000;\r\nif (!lp->tx_enable) {\r\nSET_100Mb;\r\nde4x5_init_connection(dev);\r\n} else {\r\nif (!lp->linkOK && (lp->autosense == AUTO)) {\r\nif (!is_100_up(dev) || (!lp->useSROM && !is_spd_100(dev))) {\r\nlp->media = INIT;\r\nlp->tcount++;\r\nnext_tick = DE4X5_AUTOSENSE_MS;\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nlp->tcount++;\r\nprintk("Huh?: media:%02x\n", lp->media);\r\nlp->media = INIT;\r\nbreak;\r\n}\r\nreturn next_tick;\r\n}\r\nstatic int\r\nsrom_autoconf(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nreturn lp->infoleaf_fn(dev);\r\n}\r\nstatic int\r\nsrom_map_media(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nlp->fdx = false;\r\nif (lp->infoblock_media == lp->media)\r\nreturn 0;\r\nswitch(lp->infoblock_media) {\r\ncase SROM_10BASETF:\r\nif (!lp->params.fdx) return -1;\r\nlp->fdx = true;\r\ncase SROM_10BASET:\r\nif (lp->params.fdx && !lp->fdx) return -1;\r\nif ((lp->chipset == DC21140) || ((lp->chipset & ~0x00ff) == DC2114x)) {\r\nlp->media = _10Mb;\r\n} else {\r\nlp->media = TP;\r\n}\r\nbreak;\r\ncase SROM_10BASE2:\r\nlp->media = BNC;\r\nbreak;\r\ncase SROM_10BASE5:\r\nlp->media = AUI;\r\nbreak;\r\ncase SROM_100BASETF:\r\nif (!lp->params.fdx) return -1;\r\nlp->fdx = true;\r\ncase SROM_100BASET:\r\nif (lp->params.fdx && !lp->fdx) return -1;\r\nlp->media = _100Mb;\r\nbreak;\r\ncase SROM_100BASET4:\r\nlp->media = _100Mb;\r\nbreak;\r\ncase SROM_100BASEFF:\r\nif (!lp->params.fdx) return -1;\r\nlp->fdx = true;\r\ncase SROM_100BASEF:\r\nif (lp->params.fdx && !lp->fdx) return -1;\r\nlp->media = _100Mb;\r\nbreak;\r\ncase ANS:\r\nlp->media = ANS;\r\nlp->fdx = lp->params.fdx;\r\nbreak;\r\ndefault:\r\nprintk("%s: Bad media code [%d] detected in SROM!\n", dev->name,\r\nlp->infoblock_media);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nde4x5_init_connection(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nu_long flags = 0;\r\nif (lp->media != lp->c_media) {\r\nde4x5_dbg_media(dev);\r\nlp->c_media = lp->media;\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nde4x5_rst_desc_ring(dev);\r\nde4x5_setup_intr(dev);\r\nlp->tx_enable = true;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\noutl(POLL_DEMAND, DE4X5_TPD);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int\r\nde4x5_reset_phy(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint next_tick = 0;\r\nif ((lp->useSROM) || (lp->phy[lp->active].id)) {\r\nif (lp->timeout < 0) {\r\nif (lp->useSROM) {\r\nif (lp->phy[lp->active].rst) {\r\nsrom_exec(dev, lp->phy[lp->active].rst);\r\nsrom_exec(dev, lp->phy[lp->active].rst);\r\n} else if (lp->rst) {\r\nsrom_exec(dev, lp->rst);\r\nsrom_exec(dev, lp->rst);\r\n}\r\n} else {\r\nPHY_HARD_RESET;\r\n}\r\nif (lp->useMII) {\r\nmii_wr(MII_CR_RST, MII_CR, lp->phy[lp->active].addr, DE4X5_MII);\r\n}\r\n}\r\nif (lp->useMII) {\r\nnext_tick = test_mii_reg(dev, MII_CR, MII_CR_RST, false, 500);\r\n}\r\n} else if (lp->chipset == DC21140) {\r\nPHY_HARD_RESET;\r\n}\r\nreturn next_tick;\r\n}\r\nstatic int\r\ntest_media(struct net_device *dev, s32 irqs, s32 irq_mask, s32 csr13, s32 csr14, s32 csr15, s32 msec)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ns32 sts, csr12;\r\nif (lp->timeout < 0) {\r\nlp->timeout = msec/100;\r\nif (!lp->useSROM) {\r\nreset_init_sia(dev, csr13, csr14, csr15);\r\n}\r\noutl(irq_mask, DE4X5_IMR);\r\nsts = inl(DE4X5_STS);\r\noutl(sts, DE4X5_STS);\r\nif ((lp->chipset == DC21041) || lp->useSROM) {\r\ncsr12 = inl(DE4X5_SISR);\r\noutl(csr12, DE4X5_SISR);\r\n}\r\n}\r\nsts = inl(DE4X5_STS) & ~TIMER_CB;\r\nif (!(sts & irqs) && --lp->timeout) {\r\nsts = 100 | TIMER_CB;\r\n} else {\r\nlp->timeout = -1;\r\n}\r\nreturn sts;\r\n}\r\nstatic int\r\ntest_tp(struct net_device *dev, s32 msec)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint sisr;\r\nif (lp->timeout < 0) {\r\nlp->timeout = msec/100;\r\n}\r\nsisr = (inl(DE4X5_SISR) & ~TIMER_CB) & (SISR_LKF | SISR_NCR);\r\nif (sisr && --lp->timeout) {\r\nsisr = 100 | TIMER_CB;\r\n} else {\r\nlp->timeout = -1;\r\n}\r\nreturn sisr;\r\n}\r\nstatic int\r\ntest_for_100Mb(struct net_device *dev, int msec)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint gep = 0, ret = ((lp->chipset & ~0x00ff)==DC2114x? -1 :GEP_SLNK);\r\nif (lp->timeout < 0) {\r\nif ((msec/SAMPLE_INTERVAL) <= 0) return 0;\r\nif (msec > SAMPLE_DELAY) {\r\nlp->timeout = (msec - SAMPLE_DELAY)/SAMPLE_INTERVAL;\r\ngep = SAMPLE_DELAY | TIMER_CB;\r\nreturn gep;\r\n} else {\r\nlp->timeout = msec/SAMPLE_INTERVAL;\r\n}\r\n}\r\nif (lp->phy[lp->active].id || lp->useSROM) {\r\ngep = is_100_up(dev) | is_spd_100(dev);\r\n} else {\r\ngep = (~gep_rd(dev) & (GEP_SLNK | GEP_LNP));\r\n}\r\nif (!(gep & ret) && --lp->timeout) {\r\ngep = SAMPLE_INTERVAL | TIMER_CB;\r\n} else {\r\nlp->timeout = -1;\r\n}\r\nreturn gep;\r\n}\r\nstatic int\r\nwait_for_link(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nif (lp->timeout < 0) {\r\nlp->timeout = 1;\r\n}\r\nif (lp->timeout--) {\r\nreturn TIMER_CB;\r\n} else {\r\nlp->timeout = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ntest_mii_reg(struct net_device *dev, int reg, int mask, bool pol, long msec)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint test;\r\nu_long iobase = dev->base_addr;\r\nif (lp->timeout < 0) {\r\nlp->timeout = msec/100;\r\n}\r\nreg = mii_rd((u_char)reg, lp->phy[lp->active].addr, DE4X5_MII) & mask;\r\ntest = (reg ^ (pol ? ~0 : 0)) & mask;\r\nif (test && --lp->timeout) {\r\nreg = 100 | TIMER_CB;\r\n} else {\r\nlp->timeout = -1;\r\n}\r\nreturn reg;\r\n}\r\nstatic int\r\nis_spd_100(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint spd;\r\nif (lp->useMII) {\r\nspd = mii_rd(lp->phy[lp->active].spd.reg, lp->phy[lp->active].addr, DE4X5_MII);\r\nspd = ~(spd ^ lp->phy[lp->active].spd.value);\r\nspd &= lp->phy[lp->active].spd.mask;\r\n} else if (!lp->useSROM) {\r\nspd = ((~gep_rd(dev)) & GEP_SLNK);\r\n} else {\r\nif ((lp->ibn == 2) || !lp->asBitValid)\r\nreturn (lp->chipset == DC21143) ? (~inl(DE4X5_SISR)&SISR_LS100) : 0;\r\nspd = (lp->asBitValid & (lp->asPolarity ^ (gep_rd(dev) & lp->asBit))) |\r\n(lp->linkOK & ~lp->asBitValid);\r\n}\r\nreturn spd;\r\n}\r\nstatic int\r\nis_100_up(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nif (lp->useMII) {\r\nmii_rd(MII_SR, lp->phy[lp->active].addr, DE4X5_MII);\r\nreturn mii_rd(MII_SR, lp->phy[lp->active].addr, DE4X5_MII) & MII_SR_LKS;\r\n} else if (!lp->useSROM) {\r\nreturn (~gep_rd(dev)) & GEP_SLNK;\r\n} else {\r\nif ((lp->ibn == 2) || !lp->asBitValid)\r\nreturn (lp->chipset == DC21143) ? (~inl(DE4X5_SISR)&SISR_LS100) : 0;\r\nreturn (lp->asBitValid&(lp->asPolarity^(gep_rd(dev)&lp->asBit))) |\r\n(lp->linkOK & ~lp->asBitValid);\r\n}\r\n}\r\nstatic int\r\nis_10_up(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nif (lp->useMII) {\r\nmii_rd(MII_SR, lp->phy[lp->active].addr, DE4X5_MII);\r\nreturn mii_rd(MII_SR, lp->phy[lp->active].addr, DE4X5_MII) & MII_SR_LKS;\r\n} else if (!lp->useSROM) {\r\nreturn (~gep_rd(dev)) & GEP_LNP;\r\n} else {\r\nif ((lp->ibn == 2) || !lp->asBitValid)\r\nreturn ((lp->chipset & ~0x00ff) == DC2114x) ?\r\n(~inl(DE4X5_SISR)&SISR_LS10):\r\n0;\r\nreturn (lp->asBitValid&(lp->asPolarity^(gep_rd(dev)&lp->asBit))) |\r\n(lp->linkOK & ~lp->asBitValid);\r\n}\r\n}\r\nstatic int\r\nis_anc_capable(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nif (lp->phy[lp->active].id && (!lp->useSROM || lp->useMII)) {\r\nreturn mii_rd(MII_SR, lp->phy[lp->active].addr, DE4X5_MII);\r\n} else if ((lp->chipset & ~0x00ff) == DC2114x) {\r\nreturn (inl(DE4X5_SISR) & SISR_LPN) >> 12;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int\r\nping_media(struct net_device *dev, int msec)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint sisr;\r\nif (lp->timeout < 0) {\r\nlp->timeout = msec/100;\r\nlp->tmp = lp->tx_new;\r\nload_packet(dev, lp->frame, TD_LS | TD_FS | sizeof(lp->frame), (struct sk_buff *)1);\r\nlp->tx_new = (lp->tx_new + 1) % lp->txRingSize;\r\noutl(POLL_DEMAND, DE4X5_TPD);\r\n}\r\nsisr = inl(DE4X5_SISR);\r\nif ((!(sisr & SISR_NCR)) &&\r\n((s32)le32_to_cpu(lp->tx_ring[lp->tmp].status) < 0) &&\r\n(--lp->timeout)) {\r\nsisr = 100 | TIMER_CB;\r\n} else {\r\nif ((!(sisr & SISR_NCR)) &&\r\n!(le32_to_cpu(lp->tx_ring[lp->tmp].status) & (T_OWN | TD_ES)) &&\r\nlp->timeout) {\r\nsisr = 0;\r\n} else {\r\nsisr = 1;\r\n}\r\nlp->timeout = -1;\r\n}\r\nreturn sisr;\r\n}\r\nstatic struct sk_buff *\r\nde4x5_alloc_rx_buff(struct net_device *dev, int index, int len)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nstruct sk_buff *p;\r\n#if !defined(__alpha__) && !defined(__powerpc__) && !defined(CONFIG_SPARC) && !defined(DE4X5_DO_MEMCPY)\r\nstruct sk_buff *ret;\r\nu_long i=0, tmp;\r\np = netdev_alloc_skb(dev, IEEE802_3_SZ + DE4X5_ALIGN + 2);\r\nif (!p) return NULL;\r\ntmp = virt_to_bus(p->data);\r\ni = ((tmp + DE4X5_ALIGN) & ~DE4X5_ALIGN) - tmp;\r\nskb_reserve(p, i);\r\nlp->rx_ring[index].buf = cpu_to_le32(tmp + i);\r\nret = lp->rx_skb[index];\r\nlp->rx_skb[index] = p;\r\nif ((u_long) ret > 1) {\r\nskb_put(ret, len);\r\n}\r\nreturn ret;\r\n#else\r\nif (lp->state != OPEN) return (struct sk_buff *)1;\r\np = netdev_alloc_skb(dev, len + 2);\r\nif (!p) return NULL;\r\nskb_reserve(p, 2);\r\nif (index < lp->rx_old) {\r\nshort tlen = (lp->rxRingSize - lp->rx_old) * RX_BUFF_SZ;\r\nmemcpy(skb_put(p,tlen),lp->rx_bufs + lp->rx_old * RX_BUFF_SZ,tlen);\r\nmemcpy(skb_put(p,len-tlen),lp->rx_bufs,len-tlen);\r\n} else {\r\nmemcpy(skb_put(p,len),lp->rx_bufs + lp->rx_old * RX_BUFF_SZ,len);\r\n}\r\nreturn p;\r\n#endif\r\n}\r\nstatic void\r\nde4x5_free_rx_buffs(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint i;\r\nfor (i=0; i<lp->rxRingSize; i++) {\r\nif ((u_long) lp->rx_skb[i] > 1) {\r\ndev_kfree_skb(lp->rx_skb[i]);\r\n}\r\nlp->rx_ring[i].status = 0;\r\nlp->rx_skb[i] = (struct sk_buff *)1;\r\n}\r\n}\r\nstatic void\r\nde4x5_free_tx_buffs(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint i;\r\nfor (i=0; i<lp->txRingSize; i++) {\r\nif (lp->tx_skb[i])\r\nde4x5_free_tx_buff(lp, i);\r\nlp->tx_ring[i].status = 0;\r\n}\r\n__skb_queue_purge(&lp->cache.queue);\r\n}\r\nstatic void\r\nde4x5_save_skbs(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ns32 omr;\r\nif (!lp->cache.save_cnt) {\r\nSTOP_DE4X5;\r\nde4x5_tx(dev);\r\nde4x5_free_tx_buffs(dev);\r\nde4x5_cache_state(dev, DE4X5_SAVE_STATE);\r\nde4x5_sw_reset(dev);\r\nde4x5_cache_state(dev, DE4X5_RESTORE_STATE);\r\nlp->cache.save_cnt++;\r\nSTART_DE4X5;\r\n}\r\n}\r\nstatic void\r\nde4x5_rst_desc_ring(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint i;\r\ns32 omr;\r\nif (lp->cache.save_cnt) {\r\nSTOP_DE4X5;\r\noutl(lp->dma_rings, DE4X5_RRBA);\r\noutl(lp->dma_rings + NUM_RX_DESC * sizeof(struct de4x5_desc),\r\nDE4X5_TRBA);\r\nlp->rx_new = lp->rx_old = 0;\r\nlp->tx_new = lp->tx_old = 0;\r\nfor (i = 0; i < lp->rxRingSize; i++) {\r\nlp->rx_ring[i].status = cpu_to_le32(R_OWN);\r\n}\r\nfor (i = 0; i < lp->txRingSize; i++) {\r\nlp->tx_ring[i].status = cpu_to_le32(0);\r\n}\r\nbarrier();\r\nlp->cache.save_cnt--;\r\nSTART_DE4X5;\r\n}\r\n}\r\nstatic void\r\nde4x5_cache_state(struct net_device *dev, int flag)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nswitch(flag) {\r\ncase DE4X5_SAVE_STATE:\r\nlp->cache.csr0 = inl(DE4X5_BMR);\r\nlp->cache.csr6 = (inl(DE4X5_OMR) & ~(OMR_ST | OMR_SR));\r\nlp->cache.csr7 = inl(DE4X5_IMR);\r\nbreak;\r\ncase DE4X5_RESTORE_STATE:\r\noutl(lp->cache.csr0, DE4X5_BMR);\r\noutl(lp->cache.csr6, DE4X5_OMR);\r\noutl(lp->cache.csr7, DE4X5_IMR);\r\nif (lp->chipset == DC21140) {\r\ngep_wr(lp->cache.gepc, dev);\r\ngep_wr(lp->cache.gep, dev);\r\n} else {\r\nreset_init_sia(dev, lp->cache.csr13, lp->cache.csr14,\r\nlp->cache.csr15);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nde4x5_put_cache(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\n__skb_queue_tail(&lp->cache.queue, skb);\r\n}\r\nstatic void\r\nde4x5_putb_cache(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\n__skb_queue_head(&lp->cache.queue, skb);\r\n}\r\nstatic struct sk_buff *\r\nde4x5_get_cache(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nreturn __skb_dequeue(&lp->cache.queue);\r\n}\r\nstatic int\r\ntest_ans(struct net_device *dev, s32 irqs, s32 irq_mask, s32 msec)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ns32 sts, ans;\r\nif (lp->timeout < 0) {\r\nlp->timeout = msec/100;\r\noutl(irq_mask, DE4X5_IMR);\r\nsts = inl(DE4X5_STS);\r\noutl(sts, DE4X5_STS);\r\n}\r\nans = inl(DE4X5_SISR) & SISR_ANS;\r\nsts = inl(DE4X5_STS) & ~TIMER_CB;\r\nif (!(sts & irqs) && (ans ^ ANS_NWOK) && --lp->timeout) {\r\nsts = 100 | TIMER_CB;\r\n} else {\r\nlp->timeout = -1;\r\n}\r\nreturn sts;\r\n}\r\nstatic void\r\nde4x5_setup_intr(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ns32 imr, sts;\r\nif (inl(DE4X5_OMR) & OMR_SR) {\r\nimr = 0;\r\nUNMASK_IRQs;\r\nsts = inl(DE4X5_STS);\r\noutl(sts, DE4X5_STS);\r\nENABLE_IRQs;\r\n}\r\n}\r\nstatic void\r\nreset_init_sia(struct net_device *dev, s32 csr13, s32 csr14, s32 csr15)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nRESET_SIA;\r\nif (lp->useSROM) {\r\nif (lp->ibn == 3) {\r\nsrom_exec(dev, lp->phy[lp->active].rst);\r\nsrom_exec(dev, lp->phy[lp->active].gep);\r\noutl(1, DE4X5_SICR);\r\nreturn;\r\n} else {\r\ncsr15 = lp->cache.csr15;\r\ncsr14 = lp->cache.csr14;\r\ncsr13 = lp->cache.csr13;\r\noutl(csr15 | lp->cache.gepc, DE4X5_SIGR);\r\noutl(csr15 | lp->cache.gep, DE4X5_SIGR);\r\n}\r\n} else {\r\noutl(csr15, DE4X5_SIGR);\r\n}\r\noutl(csr14, DE4X5_STRR);\r\noutl(csr13, DE4X5_SICR);\r\nmdelay(10);\r\n}\r\nstatic void\r\ncreate_packet(struct net_device *dev, char *frame, int len)\r\n{\r\nint i;\r\nchar *buf = frame;\r\nfor (i=0; i<ETH_ALEN; i++) {\r\n*buf++ = dev->dev_addr[i];\r\n}\r\nfor (i=0; i<ETH_ALEN; i++) {\r\n*buf++ = dev->dev_addr[i];\r\n}\r\n*buf++ = 0;\r\n*buf++ = 1;\r\n}\r\nstatic int\r\nEISA_signature(char *name, struct device *device)\r\n{\r\nint i, status = 0, siglen = ARRAY_SIZE(de4x5_signatures);\r\nstruct eisa_device *edev;\r\n*name = '\0';\r\nedev = to_eisa_device (device);\r\ni = edev->id.driver_data;\r\nif (i >= 0 && i < siglen) {\r\nstrcpy (name, de4x5_signatures[i]);\r\nstatus = 1;\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nPCI_signature(char *name, struct de4x5_private *lp)\r\n{\r\nint i, status = 0, siglen = ARRAY_SIZE(de4x5_signatures);\r\nif (lp->chipset == DC21040) {\r\nstrcpy(name, "DE434/5");\r\nreturn status;\r\n} else {\r\nint tmp = *((char *)&lp->srom + 19) * 3;\r\nstrncpy(name, (char *)&lp->srom + 26 + tmp, 8);\r\n}\r\nname[8] = '\0';\r\nfor (i=0; i<siglen; i++) {\r\nif (strstr(name,de4x5_signatures[i])!=NULL) break;\r\n}\r\nif (i == siglen) {\r\nif (dec_only) {\r\n*name = '\0';\r\n} else {\r\nstrcpy(name, (((lp->chipset == DC21040) ? "DC21040" :\r\n((lp->chipset == DC21041) ? "DC21041" :\r\n((lp->chipset == DC21140) ? "DC21140" :\r\n((lp->chipset == DC21142) ? "DC21142" :\r\n((lp->chipset == DC21143) ? "DC21143" : "UNKNOWN"\r\n)))))));\r\n}\r\nif (lp->chipset != DC21041) {\r\nlp->useSROM = true;\r\n}\r\n} else if ((lp->chipset & ~0x00ff) == DC2114x) {\r\nlp->useSROM = true;\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nDevicePresent(struct net_device *dev, u_long aprom_addr)\r\n{\r\nint i, j=0;\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nif (lp->chipset == DC21040) {\r\nif (lp->bus == EISA) {\r\nenet_addr_rst(aprom_addr);\r\n} else {\r\noutl(0, aprom_addr);\r\n}\r\n} else {\r\nu_short tmp;\r\n__le16 *p = (__le16 *)((char *)&lp->srom + SROM_HWADD);\r\nfor (i=0; i<(ETH_ALEN>>1); i++) {\r\ntmp = srom_rd(aprom_addr, (SROM_HWADD>>1) + i);\r\nj += tmp;\r\n*p = cpu_to_le16(tmp);\r\n}\r\nif (j == 0 || j == 3 * 0xffff) {\r\nreturn;\r\n}\r\np = (__le16 *)&lp->srom;\r\nfor (i=0; i<(sizeof(struct de4x5_srom)>>1); i++) {\r\ntmp = srom_rd(aprom_addr, i);\r\n*p++ = cpu_to_le16(tmp);\r\n}\r\nde4x5_dbg_srom(&lp->srom);\r\n}\r\n}\r\nstatic void\r\nenet_addr_rst(u_long aprom_addr)\r\n{\r\nunion {\r\nstruct {\r\nu32 a;\r\nu32 b;\r\n} llsig;\r\nchar Sig[sizeof(u32) << 1];\r\n} dev;\r\nshort sigLength=0;\r\ns8 data;\r\nint i, j;\r\ndev.llsig.a = ETH_PROM_SIG;\r\ndev.llsig.b = ETH_PROM_SIG;\r\nsigLength = sizeof(u32) << 1;\r\nfor (i=0,j=0;j<sigLength && i<PROBE_LENGTH+sigLength-1;i++) {\r\ndata = inb(aprom_addr);\r\nif (dev.Sig[j] == data) {\r\nj++;\r\n} else {\r\nif (data == dev.Sig[0]) {\r\nj=1;\r\n} else {\r\nj=0;\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\nget_hw_addr(struct net_device *dev)\r\n{\r\nu_long iobase = dev->base_addr;\r\nint broken, i, k, tmp, status = 0;\r\nu_short j,chksum;\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nbroken = de4x5_bad_srom(lp);\r\nfor (i=0,k=0,j=0;j<3;j++) {\r\nk <<= 1;\r\nif (k > 0xffff) k-=0xffff;\r\nif (lp->bus == PCI) {\r\nif (lp->chipset == DC21040) {\r\nwhile ((tmp = inl(DE4X5_APROM)) < 0);\r\nk += (u_char) tmp;\r\ndev->dev_addr[i++] = (u_char) tmp;\r\nwhile ((tmp = inl(DE4X5_APROM)) < 0);\r\nk += (u_short) (tmp << 8);\r\ndev->dev_addr[i++] = (u_char) tmp;\r\n} else if (!broken) {\r\ndev->dev_addr[i] = (u_char) lp->srom.ieee_addr[i]; i++;\r\ndev->dev_addr[i] = (u_char) lp->srom.ieee_addr[i]; i++;\r\n} else if ((broken == SMC) || (broken == ACCTON)) {\r\ndev->dev_addr[i] = *((u_char *)&lp->srom + i); i++;\r\ndev->dev_addr[i] = *((u_char *)&lp->srom + i); i++;\r\n}\r\n} else {\r\nk += (u_char) (tmp = inb(EISA_APROM));\r\ndev->dev_addr[i++] = (u_char) tmp;\r\nk += (u_short) ((tmp = inb(EISA_APROM)) << 8);\r\ndev->dev_addr[i++] = (u_char) tmp;\r\n}\r\nif (k > 0xffff) k-=0xffff;\r\n}\r\nif (k == 0xffff) k=0;\r\nif (lp->bus == PCI) {\r\nif (lp->chipset == DC21040) {\r\nwhile ((tmp = inl(DE4X5_APROM)) < 0);\r\nchksum = (u_char) tmp;\r\nwhile ((tmp = inl(DE4X5_APROM)) < 0);\r\nchksum |= (u_short) (tmp << 8);\r\nif ((k != chksum) && (dec_only)) status = -1;\r\n}\r\n} else {\r\nchksum = (u_char) inb(EISA_APROM);\r\nchksum |= (u_short) (inb(EISA_APROM) << 8);\r\nif ((k != chksum) && (dec_only)) status = -1;\r\n}\r\nsrom_repair(dev, broken);\r\n#ifdef CONFIG_PPC_PMAC\r\nif ( machine_is(powermac) &&\r\n(dev->dev_addr[0] == 0) &&\r\n(dev->dev_addr[1] == 0xa0) )\r\n{\r\nfor (i = 0; i < ETH_ALEN; ++i)\r\n{\r\nint x = dev->dev_addr[i];\r\nx = ((x & 0xf) << 4) + ((x & 0xf0) >> 4);\r\nx = ((x & 0x33) << 2) + ((x & 0xcc) >> 2);\r\ndev->dev_addr[i] = ((x & 0x55) << 1) + ((x & 0xaa) >> 1);\r\n}\r\n}\r\n#endif\r\nstatus = test_bad_enet(dev, status);\r\nreturn status;\r\n}\r\nstatic int\r\nde4x5_bad_srom(struct de4x5_private *lp)\r\n{\r\nint i, status = 0;\r\nfor (i = 0; i < ARRAY_SIZE(enet_det); i++) {\r\nif (!de4x5_strncmp((char *)&lp->srom, (char *)&enet_det[i], 3) &&\r\n!de4x5_strncmp((char *)&lp->srom+0x10, (char *)&enet_det[i], 3)) {\r\nif (i == 0) {\r\nstatus = SMC;\r\n} else if (i == 1) {\r\nstatus = ACCTON;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nde4x5_strncmp(char *a, char *b, int n)\r\n{\r\nint ret=0;\r\nfor (;n && !ret; n--) {\r\nret = *a++ - *b++;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nsrom_repair(struct net_device *dev, int card)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nswitch(card) {\r\ncase SMC:\r\nmemset((char *)&lp->srom, 0, sizeof(struct de4x5_srom));\r\nmemcpy(lp->srom.ieee_addr, (char *)dev->dev_addr, ETH_ALEN);\r\nmemcpy(lp->srom.info, (char *)&srom_repair_info[SMC-1], 100);\r\nlp->useSROM = true;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ntest_bad_enet(struct net_device *dev, int status)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint i, tmp;\r\nfor (tmp=0,i=0; i<ETH_ALEN; i++) tmp += (u_char)dev->dev_addr[i];\r\nif ((tmp == 0) || (tmp == 0x5fa)) {\r\nif ((lp->chipset == last.chipset) &&\r\n(lp->bus_num == last.bus) && (lp->bus_num > 0)) {\r\nfor (i=0; i<ETH_ALEN; i++) dev->dev_addr[i] = last.addr[i];\r\nfor (i=ETH_ALEN-1; i>2; --i) {\r\ndev->dev_addr[i] += 1;\r\nif (dev->dev_addr[i] != 0) break;\r\n}\r\nfor (i=0; i<ETH_ALEN; i++) last.addr[i] = dev->dev_addr[i];\r\nif (!an_exception(lp)) {\r\ndev->irq = last.irq;\r\n}\r\nstatus = 0;\r\n}\r\n} else if (!status) {\r\nlast.chipset = lp->chipset;\r\nlast.bus = lp->bus_num;\r\nlast.irq = dev->irq;\r\nfor (i=0; i<ETH_ALEN; i++) last.addr[i] = dev->dev_addr[i];\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nan_exception(struct de4x5_private *lp)\r\n{\r\nif ((*(u_short *)lp->srom.sub_vendor_id == 0x00c0) &&\r\n(*(u_short *)lp->srom.sub_system_id == 0x95e0)) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic short\r\nsrom_rd(u_long addr, u_char offset)\r\n{\r\nsendto_srom(SROM_RD | SROM_SR, addr);\r\nsrom_latch(SROM_RD | SROM_SR | DT_CS, addr);\r\nsrom_command(SROM_RD | SROM_SR | DT_IN | DT_CS, addr);\r\nsrom_address(SROM_RD | SROM_SR | DT_CS, addr, offset);\r\nreturn srom_data(SROM_RD | SROM_SR | DT_CS, addr);\r\n}\r\nstatic void\r\nsrom_latch(u_int command, u_long addr)\r\n{\r\nsendto_srom(command, addr);\r\nsendto_srom(command | DT_CLK, addr);\r\nsendto_srom(command, addr);\r\n}\r\nstatic void\r\nsrom_command(u_int command, u_long addr)\r\n{\r\nsrom_latch(command, addr);\r\nsrom_latch(command, addr);\r\nsrom_latch((command & 0x0000ff00) | DT_CS, addr);\r\n}\r\nstatic void\r\nsrom_address(u_int command, u_long addr, u_char offset)\r\n{\r\nint i, a;\r\na = offset << 2;\r\nfor (i=0; i<6; i++, a <<= 1) {\r\nsrom_latch(command | ((a & 0x80) ? DT_IN : 0), addr);\r\n}\r\nudelay(1);\r\ni = (getfrom_srom(addr) >> 3) & 0x01;\r\n}\r\nstatic short\r\nsrom_data(u_int command, u_long addr)\r\n{\r\nint i;\r\nshort word = 0;\r\ns32 tmp;\r\nfor (i=0; i<16; i++) {\r\nsendto_srom(command | DT_CLK, addr);\r\ntmp = getfrom_srom(addr);\r\nsendto_srom(command, addr);\r\nword = (word << 1) | ((tmp >> 3) & 0x01);\r\n}\r\nsendto_srom(command & 0x0000ff00, addr);\r\nreturn word;\r\n}\r\nstatic void\r\nsendto_srom(u_int command, u_long addr)\r\n{\r\noutl(command, addr);\r\nudelay(1);\r\n}\r\nstatic int\r\ngetfrom_srom(u_long addr)\r\n{\r\ns32 tmp;\r\ntmp = inl(addr);\r\nudelay(1);\r\nreturn tmp;\r\n}\r\nstatic int\r\nsrom_infoleaf_info(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint i, count;\r\nu_char *p;\r\nfor (i=0; i<INFOLEAF_SIZE; i++) {\r\nif (lp->chipset == infoleaf_array[i].chipset) break;\r\n}\r\nif (i == INFOLEAF_SIZE) {\r\nlp->useSROM = false;\r\nprintk("%s: Cannot find correct chipset for SROM decoding!\n",\r\ndev->name);\r\nreturn -ENXIO;\r\n}\r\nlp->infoleaf_fn = infoleaf_array[i].fn;\r\ncount = *((u_char *)&lp->srom + 19);\r\np = (u_char *)&lp->srom + 26;\r\nif (count > 1) {\r\nfor (i=count; i; --i, p+=3) {\r\nif (lp->device == *p) break;\r\n}\r\nif (i == 0) {\r\nlp->useSROM = false;\r\nprintk("%s: Cannot find correct PCI device [%d] for SROM decoding!\n",\r\ndev->name, lp->device);\r\nreturn -ENXIO;\r\n}\r\n}\r\nlp->infoleaf_offset = get_unaligned_le16(p + 1);\r\nreturn 0;\r\n}\r\nstatic void\r\nsrom_init(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char *p = (u_char *)&lp->srom + lp->infoleaf_offset;\r\nu_char count;\r\np+=2;\r\nif (lp->chipset == DC21140) {\r\nlp->cache.gepc = (*p++ | GEP_CTRL);\r\ngep_wr(lp->cache.gepc, dev);\r\n}\r\ncount = *p++;\r\nfor (;count; --count) {\r\nif (*p < 128) {\r\np += COMPACT_LEN;\r\n} else if (*(p+1) == 5) {\r\ntype5_infoblock(dev, 1, p);\r\np += ((*p & BLOCK_LEN) + 1);\r\n} else if (*(p+1) == 4) {\r\np += ((*p & BLOCK_LEN) + 1);\r\n} else if (*(p+1) == 3) {\r\ntype3_infoblock(dev, 1, p);\r\np += ((*p & BLOCK_LEN) + 1);\r\n} else if (*(p+1) == 2) {\r\np += ((*p & BLOCK_LEN) + 1);\r\n} else if (*(p+1) == 1) {\r\ntype1_infoblock(dev, 1, p);\r\np += ((*p & BLOCK_LEN) + 1);\r\n} else {\r\np += ((*p & BLOCK_LEN) + 1);\r\n}\r\n}\r\n}\r\nstatic void\r\nsrom_exec(struct net_device *dev, u_char *p)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nu_char count = (p ? *p++ : 0);\r\nu_short *w = (u_short *)p;\r\nif (((lp->ibn != 1) && (lp->ibn != 3) && (lp->ibn != 5)) || !count) return;\r\nif (lp->chipset != DC21140) RESET_SIA;\r\nwhile (count--) {\r\ngep_wr(((lp->chipset==DC21140) && (lp->ibn!=5) ?\r\n*p++ : get_unaligned_le16(w++)), dev);\r\nmdelay(2);\r\n}\r\nif (lp->chipset != DC21140) {\r\noutl(lp->cache.csr14, DE4X5_STRR);\r\noutl(lp->cache.csr13, DE4X5_SICR);\r\n}\r\n}\r\nstatic int\r\ndc21041_infoleaf(struct net_device *dev)\r\n{\r\nreturn DE4X5_AUTOSENSE_MS;\r\n}\r\nstatic int\r\ndc21140_infoleaf(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char count = 0;\r\nu_char *p = (u_char *)&lp->srom + lp->infoleaf_offset;\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\np+=2;\r\nlp->cache.gepc = (*p++ | GEP_CTRL);\r\ncount = *p++;\r\nif (*p < 128) {\r\nnext_tick = dc_infoblock[COMPACT](dev, count, p);\r\n} else {\r\nnext_tick = dc_infoblock[*(p+1)](dev, count, p);\r\n}\r\nif (lp->tcount == count) {\r\nlp->media = NC;\r\nif (lp->media != lp->c_media) {\r\nde4x5_dbg_media(dev);\r\nlp->c_media = lp->media;\r\n}\r\nlp->media = INIT;\r\nlp->tcount = 0;\r\nlp->tx_enable = false;\r\n}\r\nreturn next_tick & ~TIMER_CB;\r\n}\r\nstatic int\r\ndc21142_infoleaf(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char count = 0;\r\nu_char *p = (u_char *)&lp->srom + lp->infoleaf_offset;\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\np+=2;\r\ncount = *p++;\r\nif (*p < 128) {\r\nnext_tick = dc_infoblock[COMPACT](dev, count, p);\r\n} else {\r\nnext_tick = dc_infoblock[*(p+1)](dev, count, p);\r\n}\r\nif (lp->tcount == count) {\r\nlp->media = NC;\r\nif (lp->media != lp->c_media) {\r\nde4x5_dbg_media(dev);\r\nlp->c_media = lp->media;\r\n}\r\nlp->media = INIT;\r\nlp->tcount = 0;\r\nlp->tx_enable = false;\r\n}\r\nreturn next_tick & ~TIMER_CB;\r\n}\r\nstatic int\r\ndc21143_infoleaf(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char count = 0;\r\nu_char *p = (u_char *)&lp->srom + lp->infoleaf_offset;\r\nint next_tick = DE4X5_AUTOSENSE_MS;\r\np+=2;\r\ncount = *p++;\r\nif (*p < 128) {\r\nnext_tick = dc_infoblock[COMPACT](dev, count, p);\r\n} else {\r\nnext_tick = dc_infoblock[*(p+1)](dev, count, p);\r\n}\r\nif (lp->tcount == count) {\r\nlp->media = NC;\r\nif (lp->media != lp->c_media) {\r\nde4x5_dbg_media(dev);\r\nlp->c_media = lp->media;\r\n}\r\nlp->media = INIT;\r\nlp->tcount = 0;\r\nlp->tx_enable = false;\r\n}\r\nreturn next_tick & ~TIMER_CB;\r\n}\r\nstatic int\r\ncompact_infoblock(struct net_device *dev, u_char count, u_char *p)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char flags, csr6;\r\nif (--count > lp->tcount) {\r\nif (*(p+COMPACT_LEN) < 128) {\r\nreturn dc_infoblock[COMPACT](dev, count, p+COMPACT_LEN);\r\n} else {\r\nreturn dc_infoblock[*(p+COMPACT_LEN+1)](dev, count, p+COMPACT_LEN);\r\n}\r\n}\r\nif ((lp->media == INIT) && (lp->timeout < 0)) {\r\nlp->ibn = COMPACT;\r\nlp->active = 0;\r\ngep_wr(lp->cache.gepc, dev);\r\nlp->infoblock_media = (*p++) & COMPACT_MC;\r\nlp->cache.gep = *p++;\r\ncsr6 = *p++;\r\nflags = *p++;\r\nlp->asBitValid = (flags & 0x80) ? 0 : -1;\r\nlp->defMedium = (flags & 0x40) ? -1 : 0;\r\nlp->asBit = 1 << ((csr6 >> 1) & 0x07);\r\nlp->asPolarity = ((csr6 & 0x80) ? -1 : 0) & lp->asBit;\r\nlp->infoblock_csr6 = OMR_DEF | ((csr6 & 0x71) << 18);\r\nlp->useMII = false;\r\nde4x5_switch_mac_port(dev);\r\n}\r\nreturn dc21140m_autoconf(dev);\r\n}\r\nstatic int\r\ntype0_infoblock(struct net_device *dev, u_char count, u_char *p)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char flags, csr6, len = (*p & BLOCK_LEN)+1;\r\nif (--count > lp->tcount) {\r\nif (*(p+len) < 128) {\r\nreturn dc_infoblock[COMPACT](dev, count, p+len);\r\n} else {\r\nreturn dc_infoblock[*(p+len+1)](dev, count, p+len);\r\n}\r\n}\r\nif ((lp->media == INIT) && (lp->timeout < 0)) {\r\nlp->ibn = 0;\r\nlp->active = 0;\r\ngep_wr(lp->cache.gepc, dev);\r\np+=2;\r\nlp->infoblock_media = (*p++) & BLOCK0_MC;\r\nlp->cache.gep = *p++;\r\ncsr6 = *p++;\r\nflags = *p++;\r\nlp->asBitValid = (flags & 0x80) ? 0 : -1;\r\nlp->defMedium = (flags & 0x40) ? -1 : 0;\r\nlp->asBit = 1 << ((csr6 >> 1) & 0x07);\r\nlp->asPolarity = ((csr6 & 0x80) ? -1 : 0) & lp->asBit;\r\nlp->infoblock_csr6 = OMR_DEF | ((csr6 & 0x71) << 18);\r\nlp->useMII = false;\r\nde4x5_switch_mac_port(dev);\r\n}\r\nreturn dc21140m_autoconf(dev);\r\n}\r\nstatic int\r\ntype1_infoblock(struct net_device *dev, u_char count, u_char *p)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char len = (*p & BLOCK_LEN)+1;\r\nif (--count > lp->tcount) {\r\nif (*(p+len) < 128) {\r\nreturn dc_infoblock[COMPACT](dev, count, p+len);\r\n} else {\r\nreturn dc_infoblock[*(p+len+1)](dev, count, p+len);\r\n}\r\n}\r\np += 2;\r\nif (lp->state == INITIALISED) {\r\nlp->ibn = 1;\r\nlp->active = *p++;\r\nlp->phy[lp->active].gep = (*p ? p : NULL); p += (*p + 1);\r\nlp->phy[lp->active].rst = (*p ? p : NULL); p += (*p + 1);\r\nlp->phy[lp->active].mc = get_unaligned_le16(p); p += 2;\r\nlp->phy[lp->active].ana = get_unaligned_le16(p); p += 2;\r\nlp->phy[lp->active].fdx = get_unaligned_le16(p); p += 2;\r\nlp->phy[lp->active].ttm = get_unaligned_le16(p);\r\nreturn 0;\r\n} else if ((lp->media == INIT) && (lp->timeout < 0)) {\r\nlp->ibn = 1;\r\nlp->active = *p;\r\nlp->infoblock_csr6 = OMR_MII_100;\r\nlp->useMII = true;\r\nlp->infoblock_media = ANS;\r\nde4x5_switch_mac_port(dev);\r\n}\r\nreturn dc21140m_autoconf(dev);\r\n}\r\nstatic int\r\ntype2_infoblock(struct net_device *dev, u_char count, u_char *p)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char len = (*p & BLOCK_LEN)+1;\r\nif (--count > lp->tcount) {\r\nif (*(p+len) < 128) {\r\nreturn dc_infoblock[COMPACT](dev, count, p+len);\r\n} else {\r\nreturn dc_infoblock[*(p+len+1)](dev, count, p+len);\r\n}\r\n}\r\nif ((lp->media == INIT) && (lp->timeout < 0)) {\r\nlp->ibn = 2;\r\nlp->active = 0;\r\np += 2;\r\nlp->infoblock_media = (*p) & MEDIA_CODE;\r\nif ((*p++) & EXT_FIELD) {\r\nlp->cache.csr13 = get_unaligned_le16(p); p += 2;\r\nlp->cache.csr14 = get_unaligned_le16(p); p += 2;\r\nlp->cache.csr15 = get_unaligned_le16(p); p += 2;\r\n} else {\r\nlp->cache.csr13 = CSR13;\r\nlp->cache.csr14 = CSR14;\r\nlp->cache.csr15 = CSR15;\r\n}\r\nlp->cache.gepc = ((s32)(get_unaligned_le16(p)) << 16); p += 2;\r\nlp->cache.gep = ((s32)(get_unaligned_le16(p)) << 16);\r\nlp->infoblock_csr6 = OMR_SIA;\r\nlp->useMII = false;\r\nde4x5_switch_mac_port(dev);\r\n}\r\nreturn dc2114x_autoconf(dev);\r\n}\r\nstatic int\r\ntype3_infoblock(struct net_device *dev, u_char count, u_char *p)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char len = (*p & BLOCK_LEN)+1;\r\nif (--count > lp->tcount) {\r\nif (*(p+len) < 128) {\r\nreturn dc_infoblock[COMPACT](dev, count, p+len);\r\n} else {\r\nreturn dc_infoblock[*(p+len+1)](dev, count, p+len);\r\n}\r\n}\r\np += 2;\r\nif (lp->state == INITIALISED) {\r\nlp->ibn = 3;\r\nlp->active = *p++;\r\nif (MOTO_SROM_BUG) lp->active = 0;\r\nlp->phy[lp->active].gep = (*p ? p : NULL); p += (2 * (*p) + 1);\r\nlp->phy[lp->active].rst = (*p ? p : NULL); p += (2 * (*p) + 1);\r\nlp->phy[lp->active].mc = get_unaligned_le16(p); p += 2;\r\nlp->phy[lp->active].ana = get_unaligned_le16(p); p += 2;\r\nlp->phy[lp->active].fdx = get_unaligned_le16(p); p += 2;\r\nlp->phy[lp->active].ttm = get_unaligned_le16(p); p += 2;\r\nlp->phy[lp->active].mci = *p;\r\nreturn 0;\r\n} else if ((lp->media == INIT) && (lp->timeout < 0)) {\r\nlp->ibn = 3;\r\nlp->active = *p;\r\nif (MOTO_SROM_BUG) lp->active = 0;\r\nlp->infoblock_csr6 = OMR_MII_100;\r\nlp->useMII = true;\r\nlp->infoblock_media = ANS;\r\nde4x5_switch_mac_port(dev);\r\n}\r\nreturn dc2114x_autoconf(dev);\r\n}\r\nstatic int\r\ntype4_infoblock(struct net_device *dev, u_char count, u_char *p)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char flags, csr6, len = (*p & BLOCK_LEN)+1;\r\nif (--count > lp->tcount) {\r\nif (*(p+len) < 128) {\r\nreturn dc_infoblock[COMPACT](dev, count, p+len);\r\n} else {\r\nreturn dc_infoblock[*(p+len+1)](dev, count, p+len);\r\n}\r\n}\r\nif ((lp->media == INIT) && (lp->timeout < 0)) {\r\nlp->ibn = 4;\r\nlp->active = 0;\r\np+=2;\r\nlp->infoblock_media = (*p++) & MEDIA_CODE;\r\nlp->cache.csr13 = CSR13;\r\nlp->cache.csr14 = CSR14;\r\nlp->cache.csr15 = CSR15;\r\nlp->cache.gepc = ((s32)(get_unaligned_le16(p)) << 16); p += 2;\r\nlp->cache.gep = ((s32)(get_unaligned_le16(p)) << 16); p += 2;\r\ncsr6 = *p++;\r\nflags = *p++;\r\nlp->asBitValid = (flags & 0x80) ? 0 : -1;\r\nlp->defMedium = (flags & 0x40) ? -1 : 0;\r\nlp->asBit = 1 << ((csr6 >> 1) & 0x07);\r\nlp->asPolarity = ((csr6 & 0x80) ? -1 : 0) & lp->asBit;\r\nlp->infoblock_csr6 = OMR_DEF | ((csr6 & 0x71) << 18);\r\nlp->useMII = false;\r\nde4x5_switch_mac_port(dev);\r\n}\r\nreturn dc2114x_autoconf(dev);\r\n}\r\nstatic int\r\ntype5_infoblock(struct net_device *dev, u_char count, u_char *p)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_char len = (*p & BLOCK_LEN)+1;\r\nif (--count > lp->tcount) {\r\nif (*(p+len) < 128) {\r\nreturn dc_infoblock[COMPACT](dev, count, p+len);\r\n} else {\r\nreturn dc_infoblock[*(p+len+1)](dev, count, p+len);\r\n}\r\n}\r\nif ((lp->state == INITIALISED) || (lp->media == INIT)) {\r\np+=2;\r\nlp->rst = p;\r\nsrom_exec(dev, lp->rst);\r\n}\r\nreturn DE4X5_AUTOSENSE_MS;\r\n}\r\nstatic int\r\nmii_rd(u_char phyreg, u_char phyaddr, u_long ioaddr)\r\n{\r\nmii_wdata(MII_PREAMBLE, 2, ioaddr);\r\nmii_wdata(MII_PREAMBLE, 32, ioaddr);\r\nmii_wdata(MII_STRD, 4, ioaddr);\r\nmii_address(phyaddr, ioaddr);\r\nmii_address(phyreg, ioaddr);\r\nmii_ta(MII_STRD, ioaddr);\r\nreturn mii_rdata(ioaddr);\r\n}\r\nstatic void\r\nmii_wr(int data, u_char phyreg, u_char phyaddr, u_long ioaddr)\r\n{\r\nmii_wdata(MII_PREAMBLE, 2, ioaddr);\r\nmii_wdata(MII_PREAMBLE, 32, ioaddr);\r\nmii_wdata(MII_STWR, 4, ioaddr);\r\nmii_address(phyaddr, ioaddr);\r\nmii_address(phyreg, ioaddr);\r\nmii_ta(MII_STWR, ioaddr);\r\ndata = mii_swap(data, 16);\r\nmii_wdata(data, 16, ioaddr);\r\n}\r\nstatic int\r\nmii_rdata(u_long ioaddr)\r\n{\r\nint i;\r\ns32 tmp = 0;\r\nfor (i=0; i<16; i++) {\r\ntmp <<= 1;\r\ntmp |= getfrom_mii(MII_MRD | MII_RD, ioaddr);\r\n}\r\nreturn tmp;\r\n}\r\nstatic void\r\nmii_wdata(int data, int len, u_long ioaddr)\r\n{\r\nint i;\r\nfor (i=0; i<len; i++) {\r\nsendto_mii(MII_MWR | MII_WR, data, ioaddr);\r\ndata >>= 1;\r\n}\r\n}\r\nstatic void\r\nmii_address(u_char addr, u_long ioaddr)\r\n{\r\nint i;\r\naddr = mii_swap(addr, 5);\r\nfor (i=0; i<5; i++) {\r\nsendto_mii(MII_MWR | MII_WR, addr, ioaddr);\r\naddr >>= 1;\r\n}\r\n}\r\nstatic void\r\nmii_ta(u_long rw, u_long ioaddr)\r\n{\r\nif (rw == MII_STWR) {\r\nsendto_mii(MII_MWR | MII_WR, 1, ioaddr);\r\nsendto_mii(MII_MWR | MII_WR, 0, ioaddr);\r\n} else {\r\ngetfrom_mii(MII_MRD | MII_RD, ioaddr);\r\n}\r\n}\r\nstatic int\r\nmii_swap(int data, int len)\r\n{\r\nint i, tmp = 0;\r\nfor (i=0; i<len; i++) {\r\ntmp <<= 1;\r\ntmp |= (data & 1);\r\ndata >>= 1;\r\n}\r\nreturn tmp;\r\n}\r\nstatic void\r\nsendto_mii(u32 command, int data, u_long ioaddr)\r\n{\r\nu32 j;\r\nj = (data & 1) << 17;\r\noutl(command | j, ioaddr);\r\nudelay(1);\r\noutl(command | MII_MDC | j, ioaddr);\r\nudelay(1);\r\n}\r\nstatic int\r\ngetfrom_mii(u32 command, u_long ioaddr)\r\n{\r\noutl(command, ioaddr);\r\nudelay(1);\r\noutl(command | MII_MDC, ioaddr);\r\nudelay(1);\r\nreturn (inl(ioaddr) >> 19) & 1;\r\n}\r\nstatic int\r\nmii_get_oui(u_char phyaddr, u_long ioaddr)\r\n{\r\nint r2, r3;\r\nr2 = mii_rd(MII_ID0, phyaddr, ioaddr);\r\nr3 = mii_rd(MII_ID1, phyaddr, ioaddr);\r\nreturn r2;\r\n}\r\nstatic int\r\nmii_get_phy(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nint i, j, k, n, limit=ARRAY_SIZE(phy_info);\r\nint id;\r\nlp->active = 0;\r\nlp->useMII = true;\r\nfor (n=0, lp->mii_cnt=0, i=1; !((i==1) && (n==1)); i=(i+1)%DE4X5_MAX_MII) {\r\nlp->phy[lp->active].addr = i;\r\nif (i==0) n++;\r\nwhile (de4x5_reset_phy(dev)<0) udelay(100);\r\nid = mii_get_oui(i, DE4X5_MII);\r\nif ((id == 0) || (id == 65535)) continue;\r\nfor (j=0; j<limit; j++) {\r\nif (id != phy_info[j].id) continue;\r\nfor (k=0; k < DE4X5_MAX_PHY && lp->phy[k].id; k++);\r\nif (k < DE4X5_MAX_PHY) {\r\nmemcpy((char *)&lp->phy[k],\r\n(char *)&phy_info[j], sizeof(struct phy_table));\r\nlp->phy[k].addr = i;\r\nlp->mii_cnt++;\r\nlp->active++;\r\n} else {\r\ngoto purgatory;\r\n}\r\nbreak;\r\n}\r\nif ((j == limit) && (i < DE4X5_MAX_MII)) {\r\nfor (k=0; k < DE4X5_MAX_PHY && lp->phy[k].id; k++);\r\nlp->phy[k].addr = i;\r\nlp->phy[k].id = id;\r\nlp->phy[k].spd.reg = GENERIC_REG;\r\nlp->phy[k].spd.mask = GENERIC_MASK;\r\nlp->phy[k].spd.value = GENERIC_VALUE;\r\nlp->mii_cnt++;\r\nlp->active++;\r\nprintk("%s: Using generic MII device control. If the board doesn't operate,\nplease mail the following dump to the author:\n", dev->name);\r\nj = de4x5_debug;\r\nde4x5_debug |= DEBUG_MII;\r\nde4x5_dbg_mii(dev, k);\r\nde4x5_debug = j;\r\nprintk("\n");\r\n}\r\n}\r\npurgatory:\r\nlp->active = 0;\r\nif (lp->phy[0].id) {\r\nfor (k=0; k < DE4X5_MAX_PHY && lp->phy[k].id; k++) {\r\nmii_wr(MII_CR_RST, MII_CR, lp->phy[k].addr, DE4X5_MII);\r\nwhile (mii_rd(MII_CR, lp->phy[k].addr, DE4X5_MII) & MII_CR_RST);\r\nde4x5_dbg_mii(dev, k);\r\n}\r\n}\r\nif (!lp->mii_cnt) lp->useMII = false;\r\nreturn lp->mii_cnt;\r\n}\r\nstatic char *\r\nbuild_setup_frame(struct net_device *dev, int mode)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint i;\r\nchar *pa = lp->setup_frame;\r\nif (mode == ALL) {\r\nmemset(lp->setup_frame, 0, SETUP_FRAME_LEN);\r\n}\r\nif (lp->setup_f == HASH_PERF) {\r\nfor (pa=lp->setup_frame+IMPERF_PA_OFFSET, i=0; i<ETH_ALEN; i++) {\r\n*(pa + i) = dev->dev_addr[i];\r\nif (i & 0x01) pa += 2;\r\n}\r\n*(lp->setup_frame + (HASH_TABLE_LEN >> 3) - 3) = 0x80;\r\n} else {\r\nfor (i=0; i<ETH_ALEN; i++) {\r\n*(pa + (i&1)) = dev->dev_addr[i];\r\nif (i & 0x01) pa += 4;\r\n}\r\nfor (i=0; i<ETH_ALEN; i++) {\r\n*(pa + (i&1)) = (char) 0xff;\r\nif (i & 0x01) pa += 4;\r\n}\r\n}\r\nreturn pa;\r\n}\r\nstatic void\r\ndisable_ast(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\ndel_timer_sync(&lp->timer);\r\n}\r\nstatic long\r\nde4x5_switch_mac_port(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\ns32 omr;\r\nSTOP_DE4X5;\r\nomr = (inl(DE4X5_OMR) & ~(OMR_PS | OMR_HBD | OMR_TTM | OMR_PCS | OMR_SCR |\r\nOMR_FDX));\r\nomr |= lp->infoblock_csr6;\r\nif (omr & OMR_PS) omr |= OMR_HBD;\r\noutl(omr, DE4X5_OMR);\r\nRESET_DE4X5;\r\nif (lp->chipset == DC21140) {\r\ngep_wr(lp->cache.gepc, dev);\r\ngep_wr(lp->cache.gep, dev);\r\n} else if ((lp->chipset & ~0x0ff) == DC2114x) {\r\nreset_init_sia(dev, lp->cache.csr13, lp->cache.csr14, lp->cache.csr15);\r\n}\r\noutl(omr, DE4X5_OMR);\r\ninl(DE4X5_MFC);\r\nreturn omr;\r\n}\r\nstatic void\r\ngep_wr(s32 data, struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nif (lp->chipset == DC21140) {\r\noutl(data, DE4X5_GEP);\r\n} else if ((lp->chipset & ~0x00ff) == DC2114x) {\r\noutl((data<<16) | lp->cache.csr15, DE4X5_SIGR);\r\n}\r\n}\r\nstatic int\r\ngep_rd(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nif (lp->chipset == DC21140) {\r\nreturn inl(DE4X5_GEP);\r\n} else if ((lp->chipset & ~0x00ff) == DC2114x) {\r\nreturn inl(DE4X5_SIGR) & 0x000fffff;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nyawn(struct net_device *dev, int state)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nif ((lp->chipset == DC21040) || (lp->chipset == DC21140)) return;\r\nif(lp->bus == EISA) {\r\nswitch(state) {\r\ncase WAKEUP:\r\noutb(WAKEUP, PCI_CFPM);\r\nmdelay(10);\r\nbreak;\r\ncase SNOOZE:\r\noutb(SNOOZE, PCI_CFPM);\r\nbreak;\r\ncase SLEEP:\r\noutl(0, DE4X5_SICR);\r\noutb(SLEEP, PCI_CFPM);\r\nbreak;\r\n}\r\n} else {\r\nstruct pci_dev *pdev = to_pci_dev (lp->gendev);\r\nswitch(state) {\r\ncase WAKEUP:\r\npci_write_config_byte(pdev, PCI_CFDA_PSM, WAKEUP);\r\nmdelay(10);\r\nbreak;\r\ncase SNOOZE:\r\npci_write_config_byte(pdev, PCI_CFDA_PSM, SNOOZE);\r\nbreak;\r\ncase SLEEP:\r\noutl(0, DE4X5_SICR);\r\npci_write_config_byte(pdev, PCI_CFDA_PSM, SLEEP);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nde4x5_parse_params(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nchar *p, *q, t;\r\nlp->params.fdx = false;\r\nlp->params.autosense = AUTO;\r\nif (args == NULL) return;\r\nif ((p = strstr(args, dev->name))) {\r\nif (!(q = strstr(p+strlen(dev->name), "eth"))) q = p + strlen(p);\r\nt = *q;\r\n*q = '\0';\r\nif (strstr(p, "fdx") || strstr(p, "FDX")) lp->params.fdx = true;\r\nif (strstr(p, "autosense") || strstr(p, "AUTOSENSE")) {\r\nif (strstr(p, "TP")) {\r\nlp->params.autosense = TP;\r\n} else if (strstr(p, "TP_NW")) {\r\nlp->params.autosense = TP_NW;\r\n} else if (strstr(p, "BNC")) {\r\nlp->params.autosense = BNC;\r\n} else if (strstr(p, "AUI")) {\r\nlp->params.autosense = AUI;\r\n} else if (strstr(p, "BNC_AUI")) {\r\nlp->params.autosense = BNC;\r\n} else if (strstr(p, "10Mb")) {\r\nlp->params.autosense = _10Mb;\r\n} else if (strstr(p, "100Mb")) {\r\nlp->params.autosense = _100Mb;\r\n} else if (strstr(p, "AUTO")) {\r\nlp->params.autosense = AUTO;\r\n}\r\n}\r\n*q = t;\r\n}\r\n}\r\nstatic void\r\nde4x5_dbg_open(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nint i;\r\nif (de4x5_debug & DEBUG_OPEN) {\r\nprintk("%s: de4x5 opening with irq %d\n",dev->name,dev->irq);\r\nprintk("\tphysical address: %pM\n", dev->dev_addr);\r\nprintk("Descriptor head addresses:\n");\r\nprintk("\t0x%8.8lx 0x%8.8lx\n",(u_long)lp->rx_ring,(u_long)lp->tx_ring);\r\nprintk("Descriptor addresses:\nRX: ");\r\nfor (i=0;i<lp->rxRingSize-1;i++){\r\nif (i < 3) {\r\nprintk("0x%8.8lx ",(u_long)&lp->rx_ring[i].status);\r\n}\r\n}\r\nprintk("...0x%8.8lx\n",(u_long)&lp->rx_ring[i].status);\r\nprintk("TX: ");\r\nfor (i=0;i<lp->txRingSize-1;i++){\r\nif (i < 3) {\r\nprintk("0x%8.8lx ", (u_long)&lp->tx_ring[i].status);\r\n}\r\n}\r\nprintk("...0x%8.8lx\n", (u_long)&lp->tx_ring[i].status);\r\nprintk("Descriptor buffers:\nRX: ");\r\nfor (i=0;i<lp->rxRingSize-1;i++){\r\nif (i < 3) {\r\nprintk("0x%8.8x ",le32_to_cpu(lp->rx_ring[i].buf));\r\n}\r\n}\r\nprintk("...0x%8.8x\n",le32_to_cpu(lp->rx_ring[i].buf));\r\nprintk("TX: ");\r\nfor (i=0;i<lp->txRingSize-1;i++){\r\nif (i < 3) {\r\nprintk("0x%8.8x ", le32_to_cpu(lp->tx_ring[i].buf));\r\n}\r\n}\r\nprintk("...0x%8.8x\n", le32_to_cpu(lp->tx_ring[i].buf));\r\nprintk("Ring size:\nRX: %d\nTX: %d\n",\r\n(short)lp->rxRingSize,\r\n(short)lp->txRingSize);\r\n}\r\n}\r\nstatic void\r\nde4x5_dbg_mii(struct net_device *dev, int k)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nu_long iobase = dev->base_addr;\r\nif (de4x5_debug & DEBUG_MII) {\r\nprintk("\nMII device address: %d\n", lp->phy[k].addr);\r\nprintk("MII CR: %x\n",mii_rd(MII_CR,lp->phy[k].addr,DE4X5_MII));\r\nprintk("MII SR: %x\n",mii_rd(MII_SR,lp->phy[k].addr,DE4X5_MII));\r\nprintk("MII ID0: %x\n",mii_rd(MII_ID0,lp->phy[k].addr,DE4X5_MII));\r\nprintk("MII ID1: %x\n",mii_rd(MII_ID1,lp->phy[k].addr,DE4X5_MII));\r\nif (lp->phy[k].id != BROADCOM_T4) {\r\nprintk("MII ANA: %x\n",mii_rd(0x04,lp->phy[k].addr,DE4X5_MII));\r\nprintk("MII ANC: %x\n",mii_rd(0x05,lp->phy[k].addr,DE4X5_MII));\r\n}\r\nprintk("MII 16: %x\n",mii_rd(0x10,lp->phy[k].addr,DE4X5_MII));\r\nif (lp->phy[k].id != BROADCOM_T4) {\r\nprintk("MII 17: %x\n",mii_rd(0x11,lp->phy[k].addr,DE4X5_MII));\r\nprintk("MII 18: %x\n",mii_rd(0x12,lp->phy[k].addr,DE4X5_MII));\r\n} else {\r\nprintk("MII 20: %x\n",mii_rd(0x14,lp->phy[k].addr,DE4X5_MII));\r\n}\r\n}\r\n}\r\nstatic void\r\nde4x5_dbg_media(struct net_device *dev)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nif (lp->media != lp->c_media) {\r\nif (de4x5_debug & DEBUG_MEDIA) {\r\nprintk("%s: media is %s%s\n", dev->name,\r\n(lp->media == NC ? "unconnected, link down or incompatible connection" :\r\n(lp->media == TP ? "TP" :\r\n(lp->media == ANS ? "TP/Nway" :\r\n(lp->media == BNC ? "BNC" :\r\n(lp->media == AUI ? "AUI" :\r\n(lp->media == BNC_AUI ? "BNC/AUI" :\r\n(lp->media == EXT_SIA ? "EXT SIA" :\r\n(lp->media == _100Mb ? "100Mb/s" :\r\n(lp->media == _10Mb ? "10Mb/s" :\r\n"???"\r\n))))))))), (lp->fdx?" full duplex.":"."));\r\n}\r\nlp->c_media = lp->media;\r\n}\r\n}\r\nstatic void\r\nde4x5_dbg_srom(struct de4x5_srom *p)\r\n{\r\nint i;\r\nif (de4x5_debug & DEBUG_SROM) {\r\nprintk("Sub-system Vendor ID: %04x\n", *((u_short *)p->sub_vendor_id));\r\nprintk("Sub-system ID: %04x\n", *((u_short *)p->sub_system_id));\r\nprintk("ID Block CRC: %02x\n", (u_char)(p->id_block_crc));\r\nprintk("SROM version: %02x\n", (u_char)(p->version));\r\nprintk("# controllers: %02x\n", (u_char)(p->num_controllers));\r\nprintk("Hardware Address: %pM\n", p->ieee_addr);\r\nprintk("CRC checksum: %04x\n", (u_short)(p->chksum));\r\nfor (i=0; i<64; i++) {\r\nprintk("%3d %04x\n", i<<1, (u_short)*((u_short *)p+i));\r\n}\r\n}\r\n}\r\nstatic void\r\nde4x5_dbg_rx(struct sk_buff *skb, int len)\r\n{\r\nint i, j;\r\nif (de4x5_debug & DEBUG_RX) {\r\nprintk("R: %pM <- %pM len/SAP:%02x%02x [%d]\n",\r\nskb->data, &skb->data[6],\r\n(u_char)skb->data[12],\r\n(u_char)skb->data[13],\r\nlen);\r\nfor (j=0; len>0;j+=16, len-=16) {\r\nprintk(" %03x: ",j);\r\nfor (i=0; i<16 && i<len; i++) {\r\nprintk("%02x ",(u_char)skb->data[i+j]);\r\n}\r\nprintk("\n");\r\n}\r\n}\r\n}\r\nstatic int\r\nde4x5_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct de4x5_private *lp = netdev_priv(dev);\r\nstruct de4x5_ioctl *ioc = (struct de4x5_ioctl *) &rq->ifr_ifru;\r\nu_long iobase = dev->base_addr;\r\nint i, j, status = 0;\r\ns32 omr;\r\nunion {\r\nu8 addr[144];\r\nu16 sval[72];\r\nu32 lval[36];\r\n} tmp;\r\nu_long flags = 0;\r\nswitch(ioc->cmd) {\r\ncase DE4X5_GET_HWADDR:\r\nioc->len = ETH_ALEN;\r\nfor (i=0; i<ETH_ALEN; i++) {\r\ntmp.addr[i] = dev->dev_addr[i];\r\n}\r\nif (copy_to_user(ioc->data, tmp.addr, ioc->len)) return -EFAULT;\r\nbreak;\r\ncase DE4X5_SET_HWADDR:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nif (copy_from_user(tmp.addr, ioc->data, ETH_ALEN)) return -EFAULT;\r\nif (netif_queue_stopped(dev))\r\nreturn -EBUSY;\r\nnetif_stop_queue(dev);\r\nfor (i=0; i<ETH_ALEN; i++) {\r\ndev->dev_addr[i] = tmp.addr[i];\r\n}\r\nbuild_setup_frame(dev, PHYS_ADDR_ONLY);\r\nload_packet(dev, lp->setup_frame, TD_IC | PERFECT_F | TD_SET |\r\nSETUP_FRAME_LEN, (struct sk_buff *)1);\r\nlp->tx_new = (lp->tx_new + 1) % lp->txRingSize;\r\noutl(POLL_DEMAND, DE4X5_TPD);\r\nnetif_wake_queue(dev);\r\nbreak;\r\ncase DE4X5_SAY_BOO:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nprintk("%s: Boo!\n", dev->name);\r\nbreak;\r\ncase DE4X5_MCA_EN:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nomr = inl(DE4X5_OMR);\r\nomr |= OMR_PM;\r\noutl(omr, DE4X5_OMR);\r\nbreak;\r\ncase DE4X5_GET_STATS:\r\n{\r\nstruct pkt_stats statbuf;\r\nioc->len = sizeof(statbuf);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nmemcpy(&statbuf, &lp->pktStats, ioc->len);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif (copy_to_user(ioc->data, &statbuf, ioc->len))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase DE4X5_CLR_STATS:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nmemset(&lp->pktStats, 0, sizeof(lp->pktStats));\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nbreak;\r\ncase DE4X5_GET_OMR:\r\ntmp.addr[0] = inl(DE4X5_OMR);\r\nif (copy_to_user(ioc->data, tmp.addr, 1)) return -EFAULT;\r\nbreak;\r\ncase DE4X5_SET_OMR:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nif (copy_from_user(tmp.addr, ioc->data, 1)) return -EFAULT;\r\noutl(tmp.addr[0], DE4X5_OMR);\r\nbreak;\r\ncase DE4X5_GET_REG:\r\nj = 0;\r\ntmp.lval[0] = inl(DE4X5_STS); j+=4;\r\ntmp.lval[1] = inl(DE4X5_BMR); j+=4;\r\ntmp.lval[2] = inl(DE4X5_IMR); j+=4;\r\ntmp.lval[3] = inl(DE4X5_OMR); j+=4;\r\ntmp.lval[4] = inl(DE4X5_SISR); j+=4;\r\ntmp.lval[5] = inl(DE4X5_SICR); j+=4;\r\ntmp.lval[6] = inl(DE4X5_STRR); j+=4;\r\ntmp.lval[7] = inl(DE4X5_SIGR); j+=4;\r\nioc->len = j;\r\nif (copy_to_user(ioc->data, tmp.lval, ioc->len))\r\nreturn -EFAULT;\r\nbreak;\r\n#define DE4X5_DUMP 0x0f\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn status;\r\n}\r\nstatic int __init de4x5_module_init (void)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_PCI\r\nerr = pci_register_driver(&de4x5_pci_driver);\r\n#endif\r\n#ifdef CONFIG_EISA\r\nerr |= eisa_driver_register (&de4x5_eisa_driver);\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit de4x5_module_exit (void)\r\n{\r\n#ifdef CONFIG_PCI\r\npci_unregister_driver (&de4x5_pci_driver);\r\n#endif\r\n#ifdef CONFIG_EISA\r\neisa_driver_unregister (&de4x5_eisa_driver);\r\n#endif\r\n}
