int PHSTransmit(struct bcm_mini_adapter *Adapter,\r\nstruct sk_buff **pPacket,\r\nUSHORT Vcid,\r\nB_UINT16 uiClassifierRuleID,\r\nbool bHeaderSuppressionEnabled,\r\nUINT *PacketLen,\r\nUCHAR bEthCSSupport)\r\n{\r\nUINT unPHSPktHdrBytesCopied = 0;\r\nUINT unPhsOldHdrSize = 0;\r\nUINT unPHSNewPktHeaderLen = 0;\r\nPUCHAR pucPHSPktHdrInBuf =\r\nAdapter->stPhsTxContextInfo.ucaHdrSuppressionInBuf;\r\nPUCHAR pucPHSPktHdrOutBuf =\r\nAdapter->stPhsTxContextInfo.ucaHdrSuppressionOutBuf;\r\nUINT usPacketType;\r\nUINT BytesToRemove = 0;\r\nbool bPHSI = 0;\r\nLONG ulPhsStatus = 0;\r\nUINT numBytesCompressed = 0;\r\nstruct sk_buff *newPacket = NULL;\r\nstruct sk_buff *Packet = *pPacket;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"In PHSTransmit");\r\nif (!bEthCSSupport)\r\nBytesToRemove = ETH_HLEN;\r\nusPacketType = ((struct ethhdr *)(Packet->data))->h_proto;\r\npucPHSPktHdrInBuf = Packet->data + BytesToRemove;\r\nif ((*PacketLen - BytesToRemove) < MAX_PHS_LENGTHS)\r\nunPHSPktHdrBytesCopied = (*PacketLen - BytesToRemove);\r\nelse\r\nunPHSPktHdrBytesCopied = MAX_PHS_LENGTHS;\r\nif ((unPHSPktHdrBytesCopied > 0) &&\r\n(unPHSPktHdrBytesCopied <= MAX_PHS_LENGTHS)) {\r\nif (((usPacketType == ETHERNET_FRAMETYPE_IPV4) ||\r\n(usPacketType == ETHERNET_FRAMETYPE_IPV6)) &&\r\n(bHeaderSuppressionEnabled)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND,\r\nDBG_LVL_ALL,\r\n"\nTrying to PHS Compress Using Classifier rule 0x%X",\r\nuiClassifierRuleID);\r\nunPHSNewPktHeaderLen = unPHSPktHdrBytesCopied;\r\nulPhsStatus = PhsCompress(&Adapter->stBCMPhsContext,\r\nVcid,\r\nuiClassifierRuleID,\r\npucPHSPktHdrInBuf,\r\npucPHSPktHdrOutBuf,\r\n&unPhsOldHdrSize,\r\n&unPHSNewPktHeaderLen);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND,\r\nDBG_LVL_ALL,\r\n"\nPHS Old header Size : %d New Header Size %d\n",\r\nunPhsOldHdrSize, unPHSNewPktHeaderLen);\r\nif (unPHSNewPktHeaderLen == unPhsOldHdrSize) {\r\nif (ulPhsStatus == STATUS_PHS_COMPRESSED)\r\nbPHSI = *pucPHSPktHdrOutBuf;\r\nulPhsStatus = STATUS_PHS_NOCOMPRESSION;\r\n}\r\nif (ulPhsStatus == STATUS_PHS_COMPRESSED) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nPHS_SEND, DBG_LVL_ALL,\r\n"PHS Sending packet Compressed");\r\nif (skb_cloned(Packet)) {\r\nnewPacket =\r\nskb_copy(Packet, GFP_ATOMIC);\r\nif (newPacket == NULL)\r\nreturn STATUS_FAILURE;\r\ndev_kfree_skb(Packet);\r\n*pPacket = Packet = newPacket;\r\npucPHSPktHdrInBuf =\r\nPacket->data + BytesToRemove;\r\n}\r\nnumBytesCompressed = unPhsOldHdrSize -\r\n(unPHSNewPktHeaderLen + PHSI_LEN);\r\nmemcpy(pucPHSPktHdrInBuf + numBytesCompressed,\r\npucPHSPktHdrOutBuf,\r\nunPHSNewPktHeaderLen + PHSI_LEN);\r\nmemcpy(Packet->data + numBytesCompressed,\r\nPacket->data, BytesToRemove);\r\nskb_pull(Packet, numBytesCompressed);\r\nreturn STATUS_SUCCESS;\r\n} else {\r\nif (!(skb_headroom(Packet) > 0)) {\r\nif (skb_cow(Packet, 1)) {\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_PRINTK,\r\n0, 0,\r\n"SKB Cow Failed\n");\r\nreturn STATUS_FAILURE;\r\n}\r\n}\r\nskb_push(Packet, 1);\r\n*(Packet->data + BytesToRemove) = bPHSI;\r\nreturn STATUS_SUCCESS;\r\n}\r\n} else {\r\nif (!bHeaderSuppressionEnabled)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nPHS_SEND, DBG_LVL_ALL,\r\n"\nHeader Suppression Disabled For SF: No PHS\n");\r\nreturn STATUS_SUCCESS;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint PHSReceive(struct bcm_mini_adapter *Adapter,\r\nUSHORT usVcid,\r\nstruct sk_buff *packet,\r\nUINT *punPacketLen,\r\nUCHAR *pucEthernetHdr,\r\nUINT bHeaderSuppressionEnabled)\r\n{\r\nu32 nStandardPktHdrLen = 0;\r\nu32 nTotalsuppressedPktHdrBytes = 0;\r\nint ulPhsStatus = 0;\r\nPUCHAR pucInBuff = NULL;\r\nUINT TotalBytesAdded = 0;\r\nif (!bHeaderSuppressionEnabled) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE,\r\nDBG_LVL_ALL,\r\n"\nPhs Disabled for incoming packet");\r\nreturn ulPhsStatus;\r\n}\r\npucInBuff = packet->data;\r\nnStandardPktHdrLen = packet->len;\r\nulPhsStatus = PhsDeCompress(&Adapter->stBCMPhsContext,\r\nusVcid,\r\npucInBuff,\r\nAdapter->ucaPHSPktRestoreBuf,\r\n&nTotalsuppressedPktHdrBytes,\r\n&nStandardPktHdrLen);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL,\r\n"\nSuppressed PktHdrLen : 0x%x Restored PktHdrLen : 0x%x",\r\nnTotalsuppressedPktHdrBytes, nStandardPktHdrLen);\r\nif (ulPhsStatus != STATUS_PHS_COMPRESSED) {\r\nskb_pull(packet, 1);\r\nreturn STATUS_SUCCESS;\r\n} else {\r\nTotalBytesAdded = nStandardPktHdrLen -\r\nnTotalsuppressedPktHdrBytes - PHSI_LEN;\r\nif (TotalBytesAdded) {\r\nif (skb_headroom(packet) >= (SKB_RESERVE_ETHERNET_HEADER + TotalBytesAdded))\r\nskb_push(packet, TotalBytesAdded);\r\nelse {\r\nif (skb_cow(packet, skb_headroom(packet) + TotalBytesAdded)) {\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_PRINTK, 0, 0,\r\n"cow failed in receive\n");\r\nreturn STATUS_FAILURE;\r\n}\r\nskb_push(packet, TotalBytesAdded);\r\n}\r\n}\r\nmemcpy(packet->data, Adapter->ucaPHSPktRestoreBuf,\r\nnStandardPktHdrLen);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid DumpFullPacket(UCHAR *pBuf, UINT nPktLen)\r\n{\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, IPV4_DBG, DBG_LVL_ALL,\r\n"Dumping Data Packet");\r\nBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_TX, IPV4_DBG, DBG_LVL_ALL,\r\npBuf, nPktLen);\r\n}\r\nint phs_init(struct bcm_phs_extension *pPhsdeviceExtension,\r\nstruct bcm_mini_adapter *Adapter)\r\n{\r\nint i;\r\nstruct bcm_phs_table *pstServiceFlowTable;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"\nPHS:phs_init function");\r\nif (pPhsdeviceExtension->pstServiceFlowPhsRulesTable)\r\nreturn -EINVAL;\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable =\r\nkzalloc(sizeof(struct bcm_phs_table), GFP_KERNEL);\r\nif (!pPhsdeviceExtension->pstServiceFlowPhsRulesTable) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL,\r\n"\nAllocation ServiceFlowPhsRulesTable failed");\r\nreturn -ENOMEM;\r\n}\r\npstServiceFlowTable = pPhsdeviceExtension->pstServiceFlowPhsRulesTable;\r\nfor (i = 0; i < MAX_SERVICEFLOWS; i++) {\r\nstruct bcm_phs_entry sServiceFlow =\r\npstServiceFlowTable->stSFList[i];\r\nsServiceFlow.pstClassifierTable =\r\nkzalloc(sizeof(struct bcm_phs_classifier_table),\r\nGFP_KERNEL);\r\nif (!sServiceFlow.pstClassifierTable) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL, "\nAllocation failed");\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->pstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\npPhsdeviceExtension->CompressedTxBuffer = kmalloc(PHS_BUFFER_SIZE, GFP_KERNEL);\r\nif (pPhsdeviceExtension->CompressedTxBuffer == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL, "\nAllocation failed");\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->pstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\npPhsdeviceExtension->UnCompressedRxBuffer =\r\nkmalloc(PHS_BUFFER_SIZE, GFP_KERNEL);\r\nif (pPhsdeviceExtension->UnCompressedRxBuffer == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL, "\nAllocation failed");\r\nkfree(pPhsdeviceExtension->CompressedTxBuffer);\r\nfree_phs_serviceflow_rules(pPhsdeviceExtension->pstServiceFlowPhsRulesTable);\r\npPhsdeviceExtension->pstServiceFlowPhsRulesTable = NULL;\r\nreturn -ENOMEM;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"\n phs_init Successful");\r\nreturn STATUS_SUCCESS;\r\n}\r\nint PhsCleanup(IN struct bcm_phs_extension *pPHSDeviceExt)\r\n{\r\nif (pPHSDeviceExt->pstServiceFlowPhsRulesTable) {\r\nfree_phs_serviceflow_rules(pPHSDeviceExt->pstServiceFlowPhsRulesTable);\r\npPHSDeviceExt->pstServiceFlowPhsRulesTable = NULL;\r\n}\r\nkfree(pPHSDeviceExt->CompressedTxBuffer);\r\npPHSDeviceExt->CompressedTxBuffer = NULL;\r\nkfree(pPHSDeviceExt->UnCompressedRxBuffer);\r\npPHSDeviceExt->UnCompressedRxBuffer = NULL;\r\nreturn 0;\r\n}\r\nULONG PhsUpdateClassifierRule(IN void *pvContext,\r\nIN B_UINT16 uiVcid ,\r\nIN B_UINT16 uiClsId ,\r\nIN struct bcm_phs_rule *psPhsRule,\r\nIN B_UINT8 u8AssociatedPHSI)\r\n{\r\nULONG lStatus = 0;\r\nUINT nSFIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension =\r\n(struct bcm_phs_extension *)pvContext;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"PHS With Corr2 Changes\n");\r\nif (pDeviceExtension == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL, "Invalid Device Extension\n");\r\nreturn ERR_PHS_INVALID_DEVICE_EXETENSION;\r\n}\r\nif (u8AssociatedPHSI == 0)\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nlStatus = CreateSFToClassifierRuleMapping(uiVcid, uiClsId,\r\npDeviceExtension->pstServiceFlowPhsRulesTable,\r\npsPhsRule,\r\nu8AssociatedPHSI);\r\nreturn lStatus;\r\n}\r\nlStatus = CreateClassiferToPHSRuleMapping(uiVcid, uiClsId,\r\npstServiceFlowEntry,\r\npsPhsRule,\r\nu8AssociatedPHSI);\r\nreturn lStatus;\r\n}\r\nULONG PhsDeletePHSRule(IN void *pvContext,\r\nIN B_UINT16 uiVcid,\r\nIN B_UINT8 u8PHSI)\r\n{\r\nUINT nSFIndex = 0, nClsidIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_classifier_table *pstClassifierRulesTable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension = (struct bcm_phs_extension *)pvContext;\r\nstruct bcm_phs_classifier_entry *curr_entry;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"======>\n");\r\nif (pDeviceExtension) {\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL, "SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\npstClassifierRulesTable = pstServiceFlowEntry->pstClassifierTable;\r\nif (pstClassifierRulesTable) {\r\nfor (nClsidIndex = 0; nClsidIndex < MAX_PHSRULE_PER_SF; nClsidIndex++) {\r\ncurr_entry = &pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex];\r\nif (curr_entry->bUsed &&\r\ncurr_entry->pstPhsRule &&\r\n(curr_entry->pstPhsRule->u8PHSI == u8PHSI)) {\r\nif (curr_entry->pstPhsRule->u8RefCnt)\r\ncurr_entry->pstPhsRule->u8RefCnt--;\r\nif (0 == curr_entry->pstPhsRule->u8RefCnt)\r\nkfree(curr_entry->pstPhsRule);\r\nmemset(curr_entry,\r\n0,\r\nsizeof(struct bcm_phs_classifier_entry));\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nULONG PhsDeleteClassifierRule(IN void *pvContext,\r\nIN B_UINT16 uiVcid,\r\nIN B_UINT16 uiClsId)\r\n{\r\nUINT nSFIndex = 0, nClsidIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_classifier_entry *pstClassifierEntry = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension =\r\n(struct bcm_phs_extension *)pvContext;\r\nif (!pDeviceExtension)\r\ngoto out;\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL, "SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\nnClsidIndex =\r\nGetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId,\r\neActiveClassifierRuleContext,\r\n&pstClassifierEntry);\r\nif ((nClsidIndex != PHS_INVALID_TABLE_INDEX) &&\r\n(!pstClassifierEntry->bUnclassifiedPHSRule)) {\r\nif (pstClassifierEntry->pstPhsRule) {\r\nif (pstClassifierEntry->pstPhsRule->u8RefCnt)\r\npstClassifierEntry->pstPhsRule->u8RefCnt--;\r\nif (0 == pstClassifierEntry->pstPhsRule->u8RefCnt)\r\nkfree(pstClassifierEntry->pstPhsRule);\r\n}\r\nmemset(pstClassifierEntry, 0,\r\nsizeof(struct bcm_phs_classifier_entry));\r\n}\r\nnClsidIndex =\r\nGetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId,\r\neOldClassifierRuleContext,\r\n&pstClassifierEntry);\r\nif ((nClsidIndex != PHS_INVALID_TABLE_INDEX) &&\r\n(!pstClassifierEntry->bUnclassifiedPHSRule)) {\r\nkfree(pstClassifierEntry->pstPhsRule);\r\nmemset(pstClassifierEntry, 0,\r\nsizeof(struct bcm_phs_classifier_entry));\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nULONG PhsDeleteSFRules(IN void *pvContext, IN B_UINT16 uiVcid)\r\n{\r\nUINT nSFIndex = 0, nClsidIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_classifier_table *pstClassifierRulesTable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension =\r\n(struct bcm_phs_extension *)pvContext;\r\nstruct bcm_phs_classifier_entry *curr_clsf_entry;\r\nstruct bcm_phs_classifier_entry *curr_rules_list;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"====>\n");\r\nif (!pDeviceExtension)\r\ngoto out;\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL, "SFID Match Failed\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\npstClassifierRulesTable = pstServiceFlowEntry->pstClassifierTable;\r\nif (pstClassifierRulesTable) {\r\nfor (nClsidIndex = 0; nClsidIndex < MAX_PHSRULE_PER_SF; nClsidIndex++) {\r\ncurr_clsf_entry =\r\n&pstClassifierRulesTable->stActivePhsRulesList[nClsidIndex];\r\ncurr_rules_list =\r\n&pstClassifierRulesTable->stOldPhsRulesList[nClsidIndex];\r\nif (curr_clsf_entry->pstPhsRule) {\r\nif (curr_clsf_entry->pstPhsRule->u8RefCnt)\r\ncurr_clsf_entry->pstPhsRule->u8RefCnt--;\r\nif (0 == curr_clsf_entry->pstPhsRule->u8RefCnt)\r\nkfree(curr_clsf_entry->pstPhsRule);\r\ncurr_clsf_entry->pstPhsRule = NULL;\r\n}\r\nmemset(curr_clsf_entry, 0,\r\nsizeof(struct bcm_phs_classifier_entry));\r\nif (curr_rules_list->pstPhsRule) {\r\nif (curr_rules_list->pstPhsRule->u8RefCnt)\r\ncurr_rules_list->pstPhsRule->u8RefCnt--;\r\nif (0 == curr_rules_list->pstPhsRule->u8RefCnt)\r\nkfree(curr_rules_list->pstPhsRule);\r\ncurr_rules_list->pstPhsRule = NULL;\r\n}\r\nmemset(curr_rules_list, 0,\r\nsizeof(struct bcm_phs_classifier_entry));\r\n}\r\n}\r\npstServiceFlowEntry->bUsed = false;\r\npstServiceFlowEntry->uiVcid = 0;\r\nout:\r\nreturn 0;\r\n}\r\nstatic ULONG PhsCompress(IN void *pvContext,\r\nIN B_UINT16 uiVcid,\r\nIN B_UINT16 uiClsId,\r\nIN void *pvInputBuffer,\r\nOUT void *pvOutputBuffer,\r\nOUT UINT *pOldHeaderSize,\r\nOUT UINT *pNewHeaderSize)\r\n{\r\nUINT nSFIndex = 0, nClsidIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_classifier_entry *pstClassifierEntry = NULL;\r\nstruct bcm_phs_rule *pstPhsRule = NULL;\r\nULONG lStatus = 0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension =\r\n(struct bcm_phs_extension *)pvContext;\r\nif (pDeviceExtension == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"Invalid Device Extension\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION;\r\nreturn lStatus;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"Suppressing header\n");\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"SFID Match Failed\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION;\r\nreturn lStatus;\r\n}\r\nnClsidIndex = GetClassifierEntry(pstServiceFlowEntry->pstClassifierTable,\r\nuiClsId, eActiveClassifierRuleContext,\r\n&pstClassifierEntry);\r\nif (nClsidIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"No PHS Rule Defined For Classifier\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION;\r\nreturn lStatus;\r\n}\r\npstPhsRule = pstClassifierEntry->pstPhsRule;\r\nif (!ValidatePHSRuleComplete(pstPhsRule)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"PHS Rule Defined For Classifier But Not Complete\n");\r\nlStatus = STATUS_PHS_NOCOMPRESSION;\r\nreturn lStatus;\r\n}\r\nlStatus = phs_compress(pstPhsRule,\r\n(PUCHAR)pvInputBuffer,\r\n(PUCHAR)pvOutputBuffer,\r\npOldHeaderSize,\r\npNewHeaderSize);\r\nif (lStatus == STATUS_PHS_COMPRESSED) {\r\npstPhsRule->PHSModifiedBytes +=\r\n*pOldHeaderSize - *pNewHeaderSize - 1;\r\npstPhsRule->PHSModifiedNumPackets++;\r\n} else {\r\npstPhsRule->PHSErrorNumPackets++;\r\n}\r\nreturn lStatus;\r\n}\r\nstatic ULONG PhsDeCompress(IN void *pvContext,\r\nIN B_UINT16 uiVcid,\r\nIN void *pvInputBuffer,\r\nOUT void *pvOutputBuffer,\r\nOUT UINT *pInHeaderSize,\r\nOUT UINT *pOutHeaderSize)\r\n{\r\nUINT nSFIndex = 0, nPhsRuleIndex = 0;\r\nstruct bcm_phs_entry *pstServiceFlowEntry = NULL;\r\nstruct bcm_phs_rule *pstPhsRule = NULL;\r\nUINT phsi;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_extension *pDeviceExtension =\r\n(struct bcm_phs_extension *)pvContext;\r\n*pInHeaderSize = 0;\r\nif (pDeviceExtension == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE,\r\nDBG_LVL_ALL, "Invalid Device Extension\n");\r\nreturn ERR_PHS_INVALID_DEVICE_EXETENSION;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL,\r\n"Restoring header\n");\r\nphsi = *((unsigned char *)(pvInputBuffer));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL,\r\n"PHSI To Be Used For restore : %x\n", phsi);\r\nif (phsi == UNCOMPRESSED_PACKET)\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\nnSFIndex = GetServiceFlowEntry(pDeviceExtension->pstServiceFlowPhsRulesTable,\r\nuiVcid, &pstServiceFlowEntry);\r\nif (nSFIndex == PHS_INVALID_TABLE_INDEX) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE,\r\nDBG_LVL_ALL,\r\n"SFID Match Failed During Lookup\n");\r\nreturn ERR_SF_MATCH_FAIL;\r\n}\r\nnPhsRuleIndex = GetPhsRuleEntry(pstServiceFlowEntry->pstClassifierTable,\r\nphsi,\r\neActiveClassifierRuleContext,\r\n&pstPhsRule);\r\nif (nPhsRuleIndex == PHS_INVALID_TABLE_INDEX) {\r\nnPhsRuleIndex = GetPhsRuleEntry(pstServiceFlowEntry->pstClassifierTable,\r\nphsi,\r\neOldClassifierRuleContext,\r\n&pstPhsRule);\r\nif (nPhsRuleIndex == PHS_INVALID_TABLE_INDEX)\r\nreturn ERR_PHSRULE_MATCH_FAIL;\r\n}\r\n*pInHeaderSize = phs_decompress((PUCHAR)pvInputBuffer,\r\n(PUCHAR)pvOutputBuffer,\r\npstPhsRule,\r\npOutHeaderSize);\r\npstPhsRule->PHSModifiedBytes += *pOutHeaderSize - *pInHeaderSize - 1;\r\npstPhsRule->PHSModifiedNumPackets++;\r\nreturn STATUS_PHS_COMPRESSED;\r\n}\r\nstatic void free_phs_serviceflow_rules(struct bcm_phs_table *psServiceFlowRulesTable)\r\n{\r\nint i, j;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nstruct bcm_phs_classifier_entry *curr_act_rules_list;\r\nstruct bcm_phs_classifier_entry *curr_old_rules_list;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"=======>\n");\r\nif (!psServiceFlowRulesTable)\r\ngoto out;\r\nfor (i = 0; i < MAX_SERVICEFLOWS; i++) {\r\nstruct bcm_phs_entry stServiceFlowEntry =\r\npsServiceFlowRulesTable->stSFList[i];\r\nstruct bcm_phs_classifier_table *pstClassifierRulesTable =\r\nstServiceFlowEntry.pstClassifierTable;\r\nif (pstClassifierRulesTable) {\r\nfor (j = 0; j < MAX_PHSRULE_PER_SF; j++) {\r\ncurr_act_rules_list =\r\n&pstClassifierRulesTable->stActivePhsRulesList[j];\r\ncurr_old_rules_list =\r\n&pstClassifierRulesTable->stOldPhsRulesList[j];\r\nif (curr_act_rules_list->pstPhsRule) {\r\nif (curr_act_rules_list->pstPhsRule->u8RefCnt)\r\ncurr_act_rules_list->pstPhsRule->u8RefCnt--;\r\nif (0 == curr_act_rules_list->pstPhsRule->u8RefCnt)\r\nkfree(curr_act_rules_list->pstPhsRule);\r\ncurr_act_rules_list->pstPhsRule = NULL;\r\n}\r\nif (curr_old_rules_list->pstPhsRule) {\r\nif (curr_old_rules_list->pstPhsRule->u8RefCnt)\r\ncurr_old_rules_list->pstPhsRule->u8RefCnt--;\r\nif (0 == curr_old_rules_list->pstPhsRule->u8RefCnt)\r\nkfree(curr_old_rules_list->pstPhsRule);\r\ncurr_old_rules_list->pstPhsRule = NULL;\r\n}\r\n}\r\nkfree(pstClassifierRulesTable);\r\nstServiceFlowEntry.pstClassifierTable =\r\npstClassifierRulesTable = NULL;\r\n}\r\n}\r\nout:\r\nkfree(psServiceFlowRulesTable);\r\npsServiceFlowRulesTable = NULL;\r\n}\r\nUINT GetServiceFlowEntry(IN struct bcm_phs_table *psServiceFlowTable,\r\nIN B_UINT16 uiVcid,\r\nstruct bcm_phs_entry **ppstServiceFlowEntry)\r\n{\r\nint i;\r\nstruct bcm_phs_entry *curr_sf_list;\r\nfor (i = 0; i < MAX_SERVICEFLOWS; i++) {\r\ncurr_sf_list = &psServiceFlowTable->stSFList[i];\r\nif (curr_sf_list->bUsed && (curr_sf_list->uiVcid == uiVcid)) {\r\n*ppstServiceFlowEntry = curr_sf_list;\r\nreturn i;\r\n}\r\n}\r\n*ppstServiceFlowEntry = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nstatic UINT GetClassifierEntry(IN struct bcm_phs_classifier_table *pstClassifierTable,\r\nIN B_UINT32 uiClsid,\r\nenum bcm_phs_classifier_context eClsContext,\r\nOUT struct bcm_phs_classifier_entry **ppstClassifierEntry)\r\n{\r\nint i;\r\nstruct bcm_phs_classifier_entry *psClassifierRules = NULL;\r\nfor (i = 0; i < MAX_PHSRULE_PER_SF; i++) {\r\nif (eClsContext == eActiveClassifierRuleContext)\r\npsClassifierRules =\r\n&pstClassifierTable->stActivePhsRulesList[i];\r\nelse\r\npsClassifierRules =\r\n&pstClassifierTable->stOldPhsRulesList[i];\r\nif (psClassifierRules->bUsed &&\r\n(psClassifierRules->uiClassifierRuleId == uiClsid)) {\r\n*ppstClassifierEntry = psClassifierRules;\r\nreturn i;\r\n}\r\n}\r\n*ppstClassifierEntry = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nstatic UINT GetPhsRuleEntry(IN struct bcm_phs_classifier_table *pstClassifierTable,\r\nIN B_UINT32 uiPHSI,\r\nenum bcm_phs_classifier_context eClsContext,\r\nOUT struct bcm_phs_rule **ppstPhsRule)\r\n{\r\nint i;\r\nstruct bcm_phs_classifier_entry *pstClassifierRule = NULL;\r\nfor (i = 0; i < MAX_PHSRULE_PER_SF; i++) {\r\nif (eClsContext == eActiveClassifierRuleContext)\r\npstClassifierRule =\r\n&pstClassifierTable->stActivePhsRulesList[i];\r\nelse\r\npstClassifierRule =\r\n&pstClassifierTable->stOldPhsRulesList[i];\r\nif (pstClassifierRule->bUsed &&\r\n(pstClassifierRule->u8PHSI == uiPHSI)) {\r\n*ppstPhsRule = pstClassifierRule->pstPhsRule;\r\nreturn i;\r\n}\r\n}\r\n*ppstPhsRule = NULL;\r\nreturn PHS_INVALID_TABLE_INDEX;\r\n}\r\nstatic UINT CreateSFToClassifierRuleMapping(IN B_UINT16 uiVcid,\r\nIN B_UINT16 uiClsId,\r\nIN struct bcm_phs_table *psServiceFlowTable,\r\nstruct bcm_phs_rule *psPhsRule,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nstruct bcm_phs_classifier_table *psaClassifiertable = NULL;\r\nUINT uiStatus = 0;\r\nint iSfIndex;\r\nbool bFreeEntryFound = false;\r\nstruct bcm_phs_entry *curr_list;\r\nfor (iSfIndex = 0; iSfIndex < MAX_SERVICEFLOWS; iSfIndex++) {\r\ncurr_list = &psServiceFlowTable->stSFList[iSfIndex];\r\nif (!curr_list->bUsed) {\r\nbFreeEntryFound = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (!bFreeEntryFound)\r\nreturn ERR_SFTABLE_FULL;\r\npsaClassifiertable = curr_list->pstClassifierTable;\r\nuiStatus = CreateClassifierPHSRule(uiClsId,\r\npsaClassifiertable,\r\npsPhsRule,\r\neActiveClassifierRuleContext,\r\nu8AssociatedPHSI);\r\nif (uiStatus == PHS_SUCCESS) {\r\ncurr_list->bUsed = TRUE;\r\ncurr_list->uiVcid = uiVcid;\r\n}\r\nreturn uiStatus;\r\n}\r\nstatic UINT CreateClassiferToPHSRuleMapping(IN B_UINT16 uiVcid,\r\nIN B_UINT16 uiClsId,\r\nIN struct bcm_phs_entry *pstServiceFlowEntry,\r\nstruct bcm_phs_rule *psPhsRule,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nstruct bcm_phs_classifier_entry *pstClassifierEntry = NULL;\r\nUINT uiStatus = PHS_SUCCESS;\r\nUINT nClassifierIndex = 0;\r\nstruct bcm_phs_classifier_table *psaClassifiertable = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\npsaClassifiertable = pstServiceFlowEntry->pstClassifierTable;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"==>");\r\nnClassifierIndex = GetClassifierEntry(\r\npstServiceFlowEntry->pstClassifierTable,\r\nuiClsId,\r\neActiveClassifierRuleContext,\r\n&pstClassifierEntry);\r\nif (nClassifierIndex == PHS_INVALID_TABLE_INDEX) {\r\nuiStatus = CreateClassifierPHSRule(uiClsId, psaClassifiertable,\r\npsPhsRule,\r\neActiveClassifierRuleContext,\r\nu8AssociatedPHSI);\r\nreturn uiStatus;\r\n}\r\nif (pstClassifierEntry->u8PHSI == psPhsRule->u8PHSI) {\r\nif (pstClassifierEntry->pstPhsRule == NULL)\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\nif (psPhsRule->u8PHSFLength) {\r\nmemcpy(pstClassifierEntry->pstPhsRule->u8PHSF,\r\npsPhsRule->u8PHSF,\r\nMAX_PHS_LENGTHS);\r\n}\r\nif (psPhsRule->u8PHSFLength) {\r\npstClassifierEntry->pstPhsRule->u8PHSFLength =\r\npsPhsRule->u8PHSFLength;\r\n}\r\nif (psPhsRule->u8PHSMLength) {\r\nmemcpy(pstClassifierEntry->pstPhsRule->u8PHSM,\r\npsPhsRule->u8PHSM,\r\nMAX_PHS_LENGTHS);\r\n}\r\nif (psPhsRule->u8PHSMLength) {\r\npstClassifierEntry->pstPhsRule->u8PHSMLength =\r\npsPhsRule->u8PHSMLength;\r\n}\r\nif (psPhsRule->u8PHSS) {\r\npstClassifierEntry->pstPhsRule->u8PHSS =\r\npsPhsRule->u8PHSS;\r\n}\r\npstClassifierEntry->pstPhsRule->u8PHSV = psPhsRule->u8PHSV;\r\n} else {\r\nuiStatus = UpdateClassifierPHSRule(uiClsId,\r\npstClassifierEntry,\r\npsaClassifiertable,\r\npsPhsRule,\r\nu8AssociatedPHSI);\r\n}\r\nreturn uiStatus;\r\n}\r\nstatic UINT CreateClassifierPHSRule(IN B_UINT16 uiClsId,\r\nstruct bcm_phs_classifier_table *psaClassifiertable,\r\nstruct bcm_phs_rule *psPhsRule,\r\nenum bcm_phs_classifier_context eClsContext,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nUINT iClassifierIndex = 0;\r\nbool bFreeEntryFound = false;\r\nstruct bcm_phs_classifier_entry *psClassifierRules = NULL;\r\nUINT nStatus = PHS_SUCCESS;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH, DBG_LVL_ALL,\r\n"Inside CreateClassifierPHSRule");\r\nif (psaClassifiertable == NULL)\r\nreturn ERR_INVALID_CLASSIFIERTABLE_FOR_SF;\r\nif (eClsContext == eOldClassifierRuleContext) {\r\niClassifierIndex = GetClassifierEntry(psaClassifiertable,\r\nuiClsId,\r\neClsContext,\r\n&psClassifierRules);\r\nif (iClassifierIndex != PHS_INVALID_TABLE_INDEX) {\r\nbFreeEntryFound = TRUE;\r\n}\r\n}\r\nif (!bFreeEntryFound) {\r\nfor (iClassifierIndex = 0; iClassifierIndex <\r\nMAX_PHSRULE_PER_SF; iClassifierIndex++) {\r\nif (eClsContext == eActiveClassifierRuleContext)\r\npsClassifierRules = &psaClassifiertable->stActivePhsRulesList[iClassifierIndex];\r\nelse\r\npsClassifierRules = &psaClassifiertable->stOldPhsRulesList[iClassifierIndex];\r\nif (!psClassifierRules->bUsed) {\r\nbFreeEntryFound = TRUE;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!bFreeEntryFound) {\r\nif (eClsContext == eActiveClassifierRuleContext)\r\nreturn ERR_CLSASSIFIER_TABLE_FULL;\r\nelse {\r\nif (psaClassifiertable->uiOldestPhsRuleIndex >= MAX_PHSRULE_PER_SF)\r\npsaClassifiertable->uiOldestPhsRuleIndex = 0;\r\niClassifierIndex =\r\npsaClassifiertable->uiOldestPhsRuleIndex;\r\npsClassifierRules =\r\n&psaClassifiertable->stOldPhsRulesList[iClassifierIndex];\r\n(psaClassifiertable->uiOldestPhsRuleIndex)++;\r\n}\r\n}\r\nif (eClsContext == eOldClassifierRuleContext) {\r\nif (psClassifierRules->pstPhsRule == NULL) {\r\npsClassifierRules->pstPhsRule =\r\nkmalloc(sizeof(struct bcm_phs_rule),\r\nGFP_KERNEL);\r\nif (NULL == psClassifierRules->pstPhsRule)\r\nreturn ERR_PHSRULE_MEMALLOC_FAIL;\r\n}\r\npsClassifierRules->bUsed = TRUE;\r\npsClassifierRules->uiClassifierRuleId = uiClsId;\r\npsClassifierRules->u8PHSI = psPhsRule->u8PHSI;\r\npsClassifierRules->bUnclassifiedPHSRule =\r\npsPhsRule->bUnclassifiedPHSRule;\r\nmemcpy(psClassifierRules->pstPhsRule, psPhsRule,\r\nsizeof(struct bcm_phs_rule));\r\n} else\r\nnStatus = UpdateClassifierPHSRule(uiClsId,\r\npsClassifierRules,\r\npsaClassifiertable,\r\npsPhsRule,\r\nu8AssociatedPHSI);\r\nreturn nStatus;\r\n}\r\nstatic UINT UpdateClassifierPHSRule(IN B_UINT16 uiClsId,\r\nIN struct bcm_phs_classifier_entry *pstClassifierEntry,\r\nstruct bcm_phs_classifier_table *psaClassifiertable,\r\nstruct bcm_phs_rule *psPhsRule,\r\nB_UINT8 u8AssociatedPHSI)\r\n{\r\nstruct bcm_phs_rule *pstAddPhsRule = NULL;\r\nUINT nPhsRuleIndex = 0;\r\nbool bPHSRuleOrphaned = false;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\npsPhsRule->u8RefCnt = 0;\r\nbPHSRuleOrphaned = DerefPhsRule(uiClsId, psaClassifiertable,\r\npstClassifierEntry->pstPhsRule);\r\nnPhsRuleIndex = GetPhsRuleEntry(psaClassifiertable, u8AssociatedPHSI,\r\neActiveClassifierRuleContext,\r\n&pstAddPhsRule);\r\nif (PHS_INVALID_TABLE_INDEX == nPhsRuleIndex) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL,\r\n"\nAdding New PHSRuleEntry For Classifier");\r\nif (psPhsRule->u8PHSI == 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL, "\nError PHSI is Zero\n");\r\nreturn ERR_PHS_INVALID_PHS_RULE;\r\n}\r\nif (false == bPHSRuleOrphaned) {\r\npstClassifierEntry->pstPhsRule =\r\nkmalloc(sizeof(struct bcm_phs_rule),\r\nGFP_KERNEL);\r\nif (NULL == pstClassifierEntry->pstPhsRule)\r\nreturn ERR_PHSRULE_MEMALLOC_FAIL;\r\n}\r\nmemcpy(pstClassifierEntry->pstPhsRule, psPhsRule,\r\nsizeof(struct bcm_phs_rule));\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_DISPATCH,\r\nDBG_LVL_ALL,\r\n"\nTying Classifier to Existing PHS Rule");\r\nif (bPHSRuleOrphaned) {\r\nkfree(pstClassifierEntry->pstPhsRule);\r\npstClassifierEntry->pstPhsRule = NULL;\r\n}\r\npstClassifierEntry->pstPhsRule = pstAddPhsRule;\r\n}\r\npstClassifierEntry->bUsed = TRUE;\r\npstClassifierEntry->u8PHSI = pstClassifierEntry->pstPhsRule->u8PHSI;\r\npstClassifierEntry->uiClassifierRuleId = uiClsId;\r\npstClassifierEntry->pstPhsRule->u8RefCnt++;\r\npstClassifierEntry->bUnclassifiedPHSRule =\r\npstClassifierEntry->pstPhsRule->bUnclassifiedPHSRule;\r\nreturn PHS_SUCCESS;\r\n}\r\nstatic bool DerefPhsRule(IN B_UINT16 uiClsId,\r\nstruct bcm_phs_classifier_table *psaClassifiertable,\r\nstruct bcm_phs_rule *pstPhsRule)\r\n{\r\nif (pstPhsRule == NULL)\r\nreturn false;\r\nif (pstPhsRule->u8RefCnt)\r\npstPhsRule->u8RefCnt--;\r\nreturn (0 == pstPhsRule->u8RefCnt);\r\n}\r\nstatic void dbg_print_st_cls_entry(struct bcm_mini_adapter *ad,\r\nstruct bcm_phs_entry *st_serv_flow_entry,\r\nstruct bcm_phs_classifier_entry *st_cls_entry)\r\n{\r\nint k;\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL, "\n VCID : %#X", st_serv_flow_entry->uiVcid);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n ClassifierID : %#X", st_cls_entry->uiClassifierRuleId);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSRuleID : %#X", st_cls_entry->u8PHSI);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n****************PHS Rule********************\n");\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSI : %#X", st_cls_entry->pstPhsRule->u8PHSI);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSFLength : %#X ", st_cls_entry->pstPhsRule->u8PHSFLength);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSF : ");\r\nfor (k = 0 ; k < st_cls_entry->pstPhsRule->u8PHSFLength; k++)\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "%#X ", st_cls_entry->pstPhsRule->u8PHSF[k]);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSMLength : %#X", st_cls_entry->pstPhsRule->u8PHSMLength);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSM :");\r\nfor (k = 0; k < st_cls_entry->pstPhsRule->u8PHSMLength; k++)\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "%#X ", st_cls_entry->pstPhsRule->u8PHSM[k]);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSS : %#X ", st_cls_entry->pstPhsRule->u8PHSS);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, (DBG_LVL_ALL|DBG_NO_FUNC_PRINT), "\n PHSV : %#X", st_cls_entry->pstPhsRule->u8PHSV);\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL, "\n********************************************\n");\r\n}\r\nstatic void phsrules_per_sf_dbg_print(struct bcm_mini_adapter *ad,\r\nstruct bcm_phs_entry *st_serv_flow_entry)\r\n{\r\nint j, l;\r\nstruct bcm_phs_classifier_entry st_cls_entry;\r\nfor (j = 0; j < MAX_PHSRULE_PER_SF; j++) {\r\nfor (l = 0; l < 2; l++) {\r\nif (l == 0) {\r\nst_cls_entry = st_serv_flow_entry->pstClassifierTable->stActivePhsRulesList[j];\r\nif (st_cls_entry.bUsed)\r\nBCM_DEBUG_PRINT(ad,\r\nDBG_TYPE_OTHERS,\r\nDUMP_INFO,\r\n(DBG_LVL_ALL | DBG_NO_FUNC_PRINT),\r\n"\n Active PHS Rule :\n");\r\n} else {\r\nst_cls_entry = st_serv_flow_entry->pstClassifierTable->stOldPhsRulesList[j];\r\nif (st_cls_entry.bUsed)\r\nBCM_DEBUG_PRINT(ad,\r\nDBG_TYPE_OTHERS,\r\nDUMP_INFO,\r\n(DBG_LVL_ALL | DBG_NO_FUNC_PRINT),\r\n"\n Old PHS Rule :\n");\r\n}\r\nif (st_cls_entry.bUsed) {\r\ndbg_print_st_cls_entry(ad,\r\nst_serv_flow_entry,\r\n&st_cls_entry);\r\n}\r\n}\r\n}\r\n}\r\nvoid DumpPhsRules(struct bcm_phs_extension *pDeviceExtension)\r\n{\r\nint i;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_INFO, DBG_LVL_ALL,\r\n"\n Dumping PHS Rules :\n");\r\nfor (i = 0; i < MAX_SERVICEFLOWS; i++) {\r\nstruct bcm_phs_entry stServFlowEntry =\r\npDeviceExtension->pstServiceFlowPhsRulesTable->stSFList[i];\r\nif (!stServFlowEntry.bUsed)\r\ncontinue;\r\nphsrules_per_sf_dbg_print(Adapter, &stServFlowEntry);\r\n}\r\n}\r\nstatic int phs_decompress(unsigned char *in_buf,\r\nunsigned char *out_buf,\r\nstruct bcm_phs_rule *decomp_phs_rules,\r\nUINT *header_size)\r\n{\r\nint phss, size = 0;\r\nstruct bcm_phs_rule *tmp_memb;\r\nint bit, i = 0;\r\nunsigned char *phsf, *phsm;\r\nint in_buf_len = *header_size - 1;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nin_buf++;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE, DBG_LVL_ALL,\r\n"====>\n");\r\n*header_size = 0;\r\nif (decomp_phs_rules == NULL)\r\nreturn 0;\r\ntmp_memb = decomp_phs_rules;\r\nphss = tmp_memb->u8PHSS;\r\nphsf = tmp_memb->u8PHSF;\r\nphsm = tmp_memb->u8PHSM;\r\nif (phss > MAX_PHS_LENGTHS)\r\nphss = MAX_PHS_LENGTHS;\r\nwhile ((phss > 0) && (size < in_buf_len)) {\r\nbit = ((*phsm << i) & SUPPRESS);\r\nif (bit == SUPPRESS) {\r\n*out_buf = *phsf;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE,\r\nDBG_LVL_ALL,\r\n"\nDECOMP:In phss %d phsf %d output %d",\r\nphss, *phsf, *out_buf);\r\n} else {\r\n*out_buf = *in_buf;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_RECEIVE,\r\nDBG_LVL_ALL,\r\n"\nDECOMP:In phss %d input %d output %d",\r\nphss, *in_buf, *out_buf);\r\nin_buf++;\r\nsize++;\r\n}\r\nout_buf++;\r\nphsf++;\r\nphss--;\r\ni++;\r\n*header_size = *header_size + 1;\r\nif (i > MAX_NO_BIT) {\r\ni = 0;\r\nphsm++;\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic int phs_compress(struct bcm_phs_rule *phs_rule,\r\nunsigned char *in_buf,\r\nunsigned char *out_buf,\r\nUINT *header_size,\r\nUINT *new_header_size)\r\n{\r\nunsigned char *old_addr = out_buf;\r\nint suppress = 0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif (phs_rule == NULL) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"\nphs_compress(): phs_rule null!");\r\n*out_buf = ZERO_PHSI;\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\n}\r\nif (phs_rule->u8PHSS <= *new_header_size)\r\n*header_size = phs_rule->u8PHSS;\r\nelse\r\n*header_size = *new_header_size;\r\nout_buf++;\r\nsuppress = verify_suppress_phsf(in_buf, out_buf, phs_rule->u8PHSF,\r\nphs_rule->u8PHSM, phs_rule->u8PHSS,\r\nphs_rule->u8PHSV, new_header_size);\r\nif (suppress == STATUS_PHS_COMPRESSED) {\r\n*old_addr = (unsigned char)phs_rule->u8PHSI;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"\nCOMP:In phs_compress phsi %d",\r\nphs_rule->u8PHSI);\r\n} else {\r\n*old_addr = ZERO_PHSI;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"\nCOMP:In phs_compress PHSV Verification failed");\r\n}\r\nreturn suppress;\r\n}\r\nstatic int verify_suppress_phsf(unsigned char *in_buffer,\r\nunsigned char *out_buffer,\r\nunsigned char *phsf,\r\nunsigned char *phsm,\r\nunsigned int phss,\r\nunsigned int phsv,\r\nUINT *new_header_size)\r\n{\r\nunsigned int size = 0;\r\nint bit, i = 0;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"\nCOMP:In verify_phsf PHSM - 0x%X", *phsm);\r\nif (phss > (*new_header_size))\r\nphss = *new_header_size;\r\nwhile (phss > 0) {\r\nbit = ((*phsm << i) & SUPPRESS);\r\nif (bit == SUPPRESS) {\r\nif (*in_buffer != *phsf) {\r\nif (phsv == VERIFY) {\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nPHS_SEND,\r\nDBG_LVL_ALL,\r\n"\nCOMP:In verify_phsf failed for field %d buf %d phsf %d",\r\nphss,\r\n*in_buffer,\r\n*phsf);\r\nreturn STATUS_PHS_NOCOMPRESSION;\r\n}\r\n} else\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nPHS_SEND,\r\nDBG_LVL_ALL,\r\n"\nCOMP:In verify_phsf success for field %d buf %d phsf %d",\r\nphss,\r\n*in_buffer,\r\n*phsf);\r\n} else {\r\n*out_buffer = *in_buffer;\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nPHS_SEND,\r\nDBG_LVL_ALL,\r\n"\nCOMP:In copying_header input %d out %d",\r\n*in_buffer,\r\n*out_buffer);\r\nout_buffer++;\r\nsize++;\r\n}\r\nin_buffer++;\r\nphsf++;\r\nphss--;\r\ni++;\r\nif (i > MAX_NO_BIT) {\r\ni = 0;\r\nphsm++;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, PHS_SEND, DBG_LVL_ALL,\r\n"\nCOMP:In verify_phsf success");\r\n*new_header_size = size;\r\nreturn STATUS_PHS_COMPRESSED;\r\n}
