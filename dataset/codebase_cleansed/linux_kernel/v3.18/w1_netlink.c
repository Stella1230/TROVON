static u16 w1_reply_len(struct w1_cb_block *block)\r\n{\r\nif (!block->cn)\r\nreturn 0;\r\nreturn (u8 *)block->cn - (u8 *)block->first_cn + block->cn->len;\r\n}\r\nstatic void w1_unref_block(struct w1_cb_block *block)\r\n{\r\nif (atomic_sub_return(1, &block->refcnt) == 0) {\r\nu16 len = w1_reply_len(block);\r\nif (len) {\r\ncn_netlink_send_mult(block->first_cn, len,\r\nblock->portid, 0, GFP_KERNEL);\r\n}\r\nkfree(block);\r\n}\r\n}\r\nstatic void w1_reply_make_space(struct w1_cb_block *block, u16 space)\r\n{\r\nu16 len = w1_reply_len(block);\r\nif (len + space >= block->maxlen) {\r\ncn_netlink_send_mult(block->first_cn, len, block->portid, 0, GFP_KERNEL);\r\nblock->first_cn->len = 0;\r\nblock->cn = NULL;\r\nblock->msg = NULL;\r\nblock->cmd = NULL;\r\n}\r\n}\r\nstatic void w1_netlink_check_send(struct w1_cb_block *block)\r\n{\r\nif (!(block->request_cn.flags & W1_CN_BUNDLE) && block->cn)\r\nw1_reply_make_space(block, block->maxlen);\r\n}\r\nstatic void w1_netlink_setup_msg(struct w1_cb_block *block, u32 ack)\r\n{\r\nif (block->cn && block->cn->ack == ack) {\r\nblock->msg = (struct w1_netlink_msg *)(block->cn->data + block->cn->len);\r\n} else {\r\nif (block->cn)\r\nblock->cn = (struct cn_msg *)(block->cn->data +\r\nblock->cn->len);\r\nelse\r\nblock->cn = block->first_cn;\r\nmemcpy(block->cn, &block->request_cn, sizeof(*block->cn));\r\nblock->cn->len = 0;\r\nblock->cn->ack = ack;\r\nblock->msg = (struct w1_netlink_msg *)block->cn->data;\r\n}\r\n}\r\nstatic void w1_netlink_queue_cmd(struct w1_cb_block *block,\r\nstruct w1_netlink_cmd *cmd)\r\n{\r\nu32 space;\r\nw1_reply_make_space(block, sizeof(struct cn_msg) +\r\nsizeof(struct w1_netlink_msg) + sizeof(*cmd) + cmd->len);\r\nw1_netlink_setup_msg(block, block->request_cn.seq + 1);\r\nmemcpy(block->msg, block->cur_msg, sizeof(*block->msg));\r\nblock->cn->len += sizeof(*block->msg);\r\nblock->msg->len = 0;\r\nblock->cmd = (struct w1_netlink_cmd *)(block->msg->data);\r\nspace = sizeof(*cmd) + cmd->len;\r\nif (block->cmd != cmd)\r\nmemcpy(block->cmd, cmd, space);\r\nblock->cn->len += space;\r\nblock->msg->len += space;\r\n}\r\nstatic void w1_netlink_queue_status(struct w1_cb_block *block,\r\nstruct w1_netlink_msg *req_msg, struct w1_netlink_cmd *req_cmd,\r\nint error)\r\n{\r\nu16 space = sizeof(struct cn_msg) + sizeof(*req_msg) + sizeof(*req_cmd);\r\nw1_reply_make_space(block, space);\r\nw1_netlink_setup_msg(block, block->request_cn.ack);\r\nmemcpy(block->msg, req_msg, sizeof(*req_msg));\r\nblock->cn->len += sizeof(*req_msg);\r\nblock->msg->len = 0;\r\nblock->msg->status = (u8)-error;\r\nif (req_cmd) {\r\nstruct w1_netlink_cmd *cmd = (struct w1_netlink_cmd *)block->msg->data;\r\nmemcpy(cmd, req_cmd, sizeof(*cmd));\r\nblock->cn->len += sizeof(*cmd);\r\nblock->msg->len += sizeof(*cmd);\r\ncmd->len = 0;\r\n}\r\nw1_netlink_check_send(block);\r\n}\r\nstatic void w1_netlink_send_error(struct cn_msg *cn, struct w1_netlink_msg *msg,\r\nint portid, int error)\r\n{\r\nstruct {\r\nstruct cn_msg cn;\r\nstruct w1_netlink_msg msg;\r\n} packet;\r\nmemcpy(&packet.cn, cn, sizeof(packet.cn));\r\nmemcpy(&packet.msg, msg, sizeof(packet.msg));\r\npacket.cn.len = sizeof(packet.msg);\r\npacket.msg.len = 0;\r\npacket.msg.status = (u8)-error;\r\ncn_netlink_send(&packet.cn, portid, 0, GFP_KERNEL);\r\n}\r\nvoid w1_netlink_send(struct w1_master *dev, struct w1_netlink_msg *msg)\r\n{\r\nstruct {\r\nstruct cn_msg cn;\r\nstruct w1_netlink_msg msg;\r\n} packet;\r\nmemset(&packet, 0, sizeof(packet));\r\npacket.cn.id.idx = CN_W1_IDX;\r\npacket.cn.id.val = CN_W1_VAL;\r\npacket.cn.seq = dev->seq++;\r\npacket.cn.len = sizeof(*msg);\r\nmemcpy(&packet.msg, msg, sizeof(*msg));\r\npacket.msg.len = 0;\r\ncn_netlink_send(&packet.cn, 0, 0, GFP_KERNEL);\r\n}\r\nstatic void w1_send_slave(struct w1_master *dev, u64 rn)\r\n{\r\nstruct w1_cb_block *block = dev->priv;\r\nstruct w1_netlink_cmd *cache_cmd = block->cmd;\r\nu64 *data;\r\nw1_reply_make_space(block, sizeof(*data));\r\nif (!block->cmd) {\r\ncache_cmd->len = 0;\r\nw1_netlink_queue_cmd(block, cache_cmd);\r\n}\r\ndata = (u64 *)(block->cmd->data + block->cmd->len);\r\n*data = rn;\r\nblock->cn->len += sizeof(*data);\r\nblock->msg->len += sizeof(*data);\r\nblock->cmd->len += sizeof(*data);\r\n}\r\nstatic void w1_found_send_slave(struct w1_master *dev, u64 rn)\r\n{\r\nw1_slave_found(dev, rn);\r\nw1_send_slave(dev, rn);\r\n}\r\nstatic int w1_get_slaves(struct w1_master *dev, struct w1_netlink_cmd *req_cmd)\r\n{\r\nstruct w1_slave *sl;\r\nreq_cmd->len = 0;\r\nw1_netlink_queue_cmd(dev->priv, req_cmd);\r\nif (req_cmd->cmd == W1_CMD_LIST_SLAVES) {\r\nu64 rn;\r\nmutex_lock(&dev->list_mutex);\r\nlist_for_each_entry(sl, &dev->slist, w1_slave_entry) {\r\nmemcpy(&rn, &sl->reg_num, sizeof(rn));\r\nw1_send_slave(dev, rn);\r\n}\r\nmutex_unlock(&dev->list_mutex);\r\n} else {\r\nw1_search_process_cb(dev, req_cmd->cmd == W1_CMD_ALARM_SEARCH ?\r\nW1_ALARM_SEARCH : W1_SEARCH, w1_found_send_slave);\r\n}\r\nreturn 0;\r\n}\r\nstatic int w1_process_command_io(struct w1_master *dev,\r\nstruct w1_netlink_cmd *cmd)\r\n{\r\nint err = 0;\r\nswitch (cmd->cmd) {\r\ncase W1_CMD_TOUCH:\r\nw1_touch_block(dev, cmd->data, cmd->len);\r\nw1_netlink_queue_cmd(dev->priv, cmd);\r\nbreak;\r\ncase W1_CMD_READ:\r\nw1_read_block(dev, cmd->data, cmd->len);\r\nw1_netlink_queue_cmd(dev->priv, cmd);\r\nbreak;\r\ncase W1_CMD_WRITE:\r\nw1_write_block(dev, cmd->data, cmd->len);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int w1_process_command_addremove(struct w1_master *dev,\r\nstruct w1_netlink_cmd *cmd)\r\n{\r\nstruct w1_slave *sl;\r\nint err = 0;\r\nstruct w1_reg_num *id;\r\nif (cmd->len != sizeof(*id))\r\nreturn -EINVAL;\r\nid = (struct w1_reg_num *)cmd->data;\r\nsl = w1_slave_search_device(dev, id);\r\nswitch (cmd->cmd) {\r\ncase W1_CMD_SLAVE_ADD:\r\nif (sl)\r\nerr = -EINVAL;\r\nelse\r\nerr = w1_attach_slave_device(dev, id);\r\nbreak;\r\ncase W1_CMD_SLAVE_REMOVE:\r\nif (sl)\r\nw1_slave_detach(sl);\r\nelse\r\nerr = -EINVAL;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int w1_process_command_master(struct w1_master *dev,\r\nstruct w1_netlink_cmd *req_cmd)\r\n{\r\nint err = -EINVAL;\r\nswitch (req_cmd->cmd) {\r\ncase W1_CMD_SEARCH:\r\ncase W1_CMD_ALARM_SEARCH:\r\ncase W1_CMD_LIST_SLAVES:\r\nmutex_unlock(&dev->bus_mutex);\r\nerr = w1_get_slaves(dev, req_cmd);\r\nmutex_lock(&dev->bus_mutex);\r\nbreak;\r\ncase W1_CMD_READ:\r\ncase W1_CMD_WRITE:\r\ncase W1_CMD_TOUCH:\r\nerr = w1_process_command_io(dev, req_cmd);\r\nbreak;\r\ncase W1_CMD_RESET:\r\nerr = w1_reset_bus(dev);\r\nbreak;\r\ncase W1_CMD_SLAVE_ADD:\r\ncase W1_CMD_SLAVE_REMOVE:\r\nmutex_unlock(&dev->bus_mutex);\r\nmutex_lock(&dev->mutex);\r\nerr = w1_process_command_addremove(dev, req_cmd);\r\nmutex_unlock(&dev->mutex);\r\nmutex_lock(&dev->bus_mutex);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int w1_process_command_slave(struct w1_slave *sl,\r\nstruct w1_netlink_cmd *cmd)\r\n{\r\ndev_dbg(&sl->master->dev, "%s: %02x.%012llx.%02x: cmd=%02x, len=%u.\n",\r\n__func__, sl->reg_num.family, (unsigned long long)sl->reg_num.id,\r\nsl->reg_num.crc, cmd->cmd, cmd->len);\r\nreturn w1_process_command_io(sl->master, cmd);\r\n}\r\nstatic int w1_process_command_root(struct cn_msg *req_cn, u32 portid)\r\n{\r\nstruct w1_master *dev;\r\nstruct cn_msg *cn;\r\nstruct w1_netlink_msg *msg;\r\nu32 *id;\r\ncn = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!cn)\r\nreturn -ENOMEM;\r\ncn->id.idx = CN_W1_IDX;\r\ncn->id.val = CN_W1_VAL;\r\ncn->seq = req_cn->seq;\r\ncn->ack = req_cn->seq + 1;\r\ncn->len = sizeof(struct w1_netlink_msg);\r\nmsg = (struct w1_netlink_msg *)cn->data;\r\nmsg->type = W1_LIST_MASTERS;\r\nmsg->status = 0;\r\nmsg->len = 0;\r\nid = (u32 *)msg->data;\r\nmutex_lock(&w1_mlock);\r\nlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\r\nif (cn->len + sizeof(*id) > PAGE_SIZE - sizeof(struct cn_msg)) {\r\ncn_netlink_send(cn, portid, 0, GFP_KERNEL);\r\ncn->len = sizeof(struct w1_netlink_msg);\r\nmsg->len = 0;\r\nid = (u32 *)msg->data;\r\n}\r\n*id = dev->id;\r\nmsg->len += sizeof(*id);\r\ncn->len += sizeof(*id);\r\nid++;\r\n}\r\ncn_netlink_send(cn, portid, 0, GFP_KERNEL);\r\nmutex_unlock(&w1_mlock);\r\nkfree(cn);\r\nreturn 0;\r\n}\r\nstatic void w1_process_cb(struct w1_master *dev, struct w1_async_cmd *async_cmd)\r\n{\r\nstruct w1_cb_node *node = container_of(async_cmd, struct w1_cb_node,\r\nasync);\r\nu16 mlen = node->msg->len;\r\nu16 len;\r\nint err = 0;\r\nstruct w1_slave *sl = node->sl;\r\nstruct w1_netlink_cmd *cmd = (struct w1_netlink_cmd *)node->msg->data;\r\nmutex_lock(&dev->bus_mutex);\r\ndev->priv = node->block;\r\nif (sl && w1_reset_select_slave(sl))\r\nerr = -ENODEV;\r\nnode->block->cur_msg = node->msg;\r\nwhile (mlen && !err) {\r\nif (cmd->len + sizeof(struct w1_netlink_cmd) > mlen) {\r\nerr = -E2BIG;\r\nbreak;\r\n}\r\nif (sl)\r\nerr = w1_process_command_slave(sl, cmd);\r\nelse\r\nerr = w1_process_command_master(dev, cmd);\r\nw1_netlink_check_send(node->block);\r\nw1_netlink_queue_status(node->block, node->msg, cmd, err);\r\nerr = 0;\r\nlen = sizeof(*cmd) + cmd->len;\r\ncmd = (struct w1_netlink_cmd *)((u8 *)cmd + len);\r\nmlen -= len;\r\n}\r\nif (!cmd || err)\r\nw1_netlink_queue_status(node->block, node->msg, cmd, err);\r\nif (sl)\r\nw1_unref_slave(sl);\r\nelse\r\natomic_dec(&dev->refcnt);\r\ndev->priv = NULL;\r\nmutex_unlock(&dev->bus_mutex);\r\nmutex_lock(&dev->list_mutex);\r\nlist_del(&async_cmd->async_entry);\r\nmutex_unlock(&dev->list_mutex);\r\nw1_unref_block(node->block);\r\n}\r\nstatic void w1_list_count_cmds(struct w1_netlink_msg *msg, int *cmd_count,\r\nu16 *slave_len)\r\n{\r\nstruct w1_netlink_cmd *cmd = (struct w1_netlink_cmd *)msg->data;\r\nu16 mlen = msg->len;\r\nu16 len;\r\nint slave_list = 0;\r\nwhile (mlen) {\r\nif (cmd->len + sizeof(struct w1_netlink_cmd) > mlen)\r\nbreak;\r\nswitch (cmd->cmd) {\r\ncase W1_CMD_SEARCH:\r\ncase W1_CMD_ALARM_SEARCH:\r\ncase W1_CMD_LIST_SLAVES:\r\n++slave_list;\r\n}\r\n++*cmd_count;\r\nlen = sizeof(*cmd) + cmd->len;\r\ncmd = (struct w1_netlink_cmd *)((u8 *)cmd + len);\r\nmlen -= len;\r\n}\r\nif (slave_list) {\r\nstruct w1_master *dev = w1_search_master_id(msg->id.mst.id);\r\nif (dev) {\r\n*slave_len += sizeof(struct w1_reg_num) * slave_list *\r\n(dev->slave_count + dev->max_slave_count);\r\natomic_dec(&dev->refcnt);\r\n}\r\n}\r\n}\r\nstatic void w1_cn_callback(struct cn_msg *cn, struct netlink_skb_parms *nsp)\r\n{\r\nstruct w1_netlink_msg *msg = (struct w1_netlink_msg *)(cn + 1);\r\nstruct w1_slave *sl;\r\nstruct w1_master *dev;\r\nu16 msg_len;\r\nu16 slave_len = 0;\r\nint err = 0;\r\nstruct w1_cb_block *block = NULL;\r\nstruct w1_cb_node *node = NULL;\r\nint node_count = 0;\r\nint cmd_count = 0;\r\nif (cn->flags & ~(W1_CN_BUNDLE)) {\r\nw1_netlink_send_error(cn, msg, nsp->portid, -EINVAL);\r\nreturn;\r\n}\r\nmsg_len = cn->len;\r\nwhile (msg_len && !err) {\r\nif (msg->len + sizeof(struct w1_netlink_msg) > msg_len) {\r\nerr = -E2BIG;\r\nbreak;\r\n}\r\nif (msg->type == W1_MASTER_CMD || msg->type == W1_SLAVE_CMD) {\r\n++node_count;\r\nw1_list_count_cmds(msg, &cmd_count, &slave_len);\r\n}\r\nmsg_len -= sizeof(struct w1_netlink_msg) + msg->len;\r\nmsg = (struct w1_netlink_msg *)(((u8 *)msg) +\r\nsizeof(struct w1_netlink_msg) + msg->len);\r\n}\r\nmsg = (struct w1_netlink_msg *)(cn + 1);\r\nif (node_count) {\r\nint size;\r\nu16 reply_size = sizeof(*cn) + cn->len + slave_len;\r\nif (cn->flags & W1_CN_BUNDLE) {\r\nreply_size += 2 * cmd_count * (sizeof(struct cn_msg) +\r\nsizeof(struct w1_netlink_msg) +\r\nsizeof(struct w1_netlink_cmd));\r\n}\r\nreply_size = MIN(CONNECTOR_MAX_MSG_SIZE, reply_size);\r\nsize =\r\nsizeof(struct w1_cb_block) + sizeof(*cn) + cn->len +\r\nnode_count * sizeof(struct w1_cb_node) +\r\nsizeof(struct cn_msg) + reply_size;\r\nblock = kzalloc(size, GFP_KERNEL);\r\nif (!block) {\r\nw1_netlink_send_error(cn, msg, nsp->portid, -ENOMEM);\r\nreturn;\r\n}\r\natomic_set(&block->refcnt, 1);\r\nblock->portid = nsp->portid;\r\nmemcpy(&block->request_cn, cn, sizeof(*cn) + cn->len);\r\nnode = (struct w1_cb_node *)(block->request_cn.data + cn->len);\r\nblock->maxlen = reply_size;\r\nblock->first_cn = (struct cn_msg *)(node + node_count);\r\nmemset(block->first_cn, 0, sizeof(*block->first_cn));\r\n}\r\nmsg_len = cn->len;\r\nwhile (msg_len && !err) {\r\ndev = NULL;\r\nsl = NULL;\r\nif (msg->len + sizeof(struct w1_netlink_msg) > msg_len) {\r\nerr = -E2BIG;\r\nbreak;\r\n}\r\nif (msg->type == W1_LIST_MASTERS) {\r\nerr = w1_process_command_root(cn, nsp->portid);\r\ngoto out_cont;\r\n}\r\nif (!msg->len) {\r\nerr = -EPROTO;\r\ngoto out_cont;\r\n}\r\nif (msg->type == W1_MASTER_CMD) {\r\ndev = w1_search_master_id(msg->id.mst.id);\r\n} else if (msg->type == W1_SLAVE_CMD) {\r\nsl = w1_search_slave((struct w1_reg_num *)msg->id.id);\r\nif (sl)\r\ndev = sl->master;\r\n} else {\r\npr_notice("%s: cn: %x.%x, wrong type: %u, len: %u.\n",\r\n__func__, cn->id.idx, cn->id.val,\r\nmsg->type, msg->len);\r\nerr = -EPROTO;\r\ngoto out_cont;\r\n}\r\nif (!dev) {\r\nerr = -ENODEV;\r\ngoto out_cont;\r\n}\r\nerr = 0;\r\natomic_inc(&block->refcnt);\r\nnode->async.cb = w1_process_cb;\r\nnode->block = block;\r\nnode->msg = (struct w1_netlink_msg *)((u8 *)&block->request_cn +\r\n(size_t)((u8 *)msg - (u8 *)cn));\r\nnode->sl = sl;\r\nnode->dev = dev;\r\nmutex_lock(&dev->list_mutex);\r\nlist_add_tail(&node->async.async_entry, &dev->async_list);\r\nwake_up_process(dev->thread);\r\nmutex_unlock(&dev->list_mutex);\r\n++node;\r\nout_cont:\r\nif (err)\r\nw1_netlink_send_error(cn, msg, nsp->portid, err);\r\nmsg_len -= sizeof(struct w1_netlink_msg) + msg->len;\r\nmsg = (struct w1_netlink_msg *)(((u8 *)msg) +\r\nsizeof(struct w1_netlink_msg) + msg->len);\r\nif (err == -ENODEV)\r\nerr = 0;\r\n}\r\nif (block)\r\nw1_unref_block(block);\r\n}\r\nint w1_init_netlink(void)\r\n{\r\nstruct cb_id w1_id = {.idx = CN_W1_IDX, .val = CN_W1_VAL};\r\nreturn cn_add_callback(&w1_id, "w1", &w1_cn_callback);\r\n}\r\nvoid w1_fini_netlink(void)\r\n{\r\nstruct cb_id w1_id = {.idx = CN_W1_IDX, .val = CN_W1_VAL};\r\ncn_del_callback(&w1_id);\r\n}\r\nvoid w1_netlink_send(struct w1_master *dev, struct w1_netlink_msg *cn)\r\n{\r\n}\r\nint w1_init_netlink(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid w1_fini_netlink(void)\r\n{\r\n}
