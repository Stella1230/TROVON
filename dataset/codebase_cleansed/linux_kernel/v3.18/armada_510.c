static int armada510_crtc_init(struct armada_crtc *dcrtc, struct device *dev)\r\n{\r\nstruct clk *clk;\r\nclk = devm_clk_get(dev, "ext_ref_clk1");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk) == -ENOENT ? -EPROBE_DEFER : PTR_ERR(clk);\r\ndcrtc->extclk[0] = clk;\r\narmada_updatel(0x20, (1 << 11) | 0xff, dcrtc->base + LCD_CFG_RDREG4F);\r\nreturn 0;\r\n}\r\nstatic int armada510_crtc_compute_clock(struct armada_crtc *dcrtc,\r\nconst struct drm_display_mode *mode, uint32_t *sclk)\r\n{\r\nstruct clk *clk = dcrtc->extclk[0];\r\nint ret;\r\nif (dcrtc->num == 1)\r\nreturn -EINVAL;\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nif (dcrtc->clk != clk) {\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\nreturn ret;\r\ndcrtc->clk = clk;\r\n}\r\nif (sclk) {\r\nuint32_t rate, ref, div;\r\nrate = mode->clock * 1000;\r\nref = clk_round_rate(clk, rate);\r\ndiv = DIV_ROUND_UP(ref, rate);\r\nif (div < 1)\r\ndiv = 1;\r\nclk_set_rate(clk, ref);\r\n*sclk = div | SCLK_510_EXTCLK1;\r\n}\r\nreturn 0;\r\n}
