static void i82875p_get_error_info(struct mem_ctl_info *mci,\r\nstruct i82875p_error_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(mci->pdev);\r\npci_read_config_word(pdev, I82875P_ERRSTS, &info->errsts);\r\nif (!(info->errsts & 0x0081))\r\nreturn;\r\npci_read_config_dword(pdev, I82875P_EAP, &info->eap);\r\npci_read_config_byte(pdev, I82875P_DES, &info->des);\r\npci_read_config_byte(pdev, I82875P_DERRSYN, &info->derrsyn);\r\npci_read_config_word(pdev, I82875P_ERRSTS, &info->errsts2);\r\nif ((info->errsts ^ info->errsts2) & 0x0081) {\r\npci_read_config_dword(pdev, I82875P_EAP, &info->eap);\r\npci_read_config_byte(pdev, I82875P_DES, &info->des);\r\npci_read_config_byte(pdev, I82875P_DERRSYN, &info->derrsyn);\r\n}\r\npci_write_bits16(pdev, I82875P_ERRSTS, 0x0081, 0x0081);\r\n}\r\nstatic int i82875p_process_error_info(struct mem_ctl_info *mci,\r\nstruct i82875p_error_info *info,\r\nint handle_errors)\r\n{\r\nint row, multi_chan;\r\nmulti_chan = mci->csrows[0]->nr_channels - 1;\r\nif (!(info->errsts & 0x0081))\r\nreturn 0;\r\nif (!handle_errors)\r\nreturn 1;\r\nif ((info->errsts ^ info->errsts2) & 0x0081) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1,\r\n"UE overwrote CE", "");\r\ninfo->errsts = info->errsts2;\r\n}\r\ninfo->eap >>= PAGE_SHIFT;\r\nrow = edac_mc_find_csrow_by_page(mci, info->eap);\r\nif (info->errsts & 0x0080)\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\ninfo->eap, 0, 0,\r\nrow, -1, -1,\r\n"i82875p UE", "");\r\nelse\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\ninfo->eap, 0, info->derrsyn,\r\nrow, multi_chan ? (info->des & 0x1) : 0,\r\n-1, "i82875p CE", "");\r\nreturn 1;\r\n}\r\nstatic void i82875p_check(struct mem_ctl_info *mci)\r\n{\r\nstruct i82875p_error_info info;\r\nedac_dbg(1, "MC%d\n", mci->mc_idx);\r\ni82875p_get_error_info(mci, &info);\r\ni82875p_process_error_info(mci, &info, 1);\r\n}\r\nstatic int i82875p_setup_overfl_dev(struct pci_dev *pdev,\r\nstruct pci_dev **ovrfl_pdev,\r\nvoid __iomem **ovrfl_window)\r\n{\r\nstruct pci_dev *dev;\r\nvoid __iomem *window;\r\n*ovrfl_pdev = NULL;\r\n*ovrfl_window = NULL;\r\ndev = pci_get_device(PCI_VEND_DEV(INTEL, 82875_6), NULL);\r\nif (dev == NULL) {\r\npci_write_bits8(pdev, 0xf4, 0x2, 0x2);\r\ndev = pci_scan_single_device(pdev->bus, PCI_DEVFN(6, 0));\r\nif (dev == NULL)\r\nreturn 1;\r\npci_bus_assign_resources(dev->bus);\r\npci_bus_add_device(dev);\r\n}\r\n*ovrfl_pdev = dev;\r\nif (pci_enable_device(dev)) {\r\ni82875p_printk(KERN_ERR, "%s(): Failed to enable overflow "\r\n"device\n", __func__);\r\nreturn 1;\r\n}\r\nif (pci_request_regions(dev, pci_name(dev))) {\r\n#ifdef CORRECT_BIOS\r\ngoto fail0;\r\n#endif\r\n}\r\nwindow = pci_ioremap_bar(dev, 0);\r\nif (window == NULL) {\r\ni82875p_printk(KERN_ERR, "%s(): Failed to ioremap bar6\n",\r\n__func__);\r\ngoto fail1;\r\n}\r\n*ovrfl_window = window;\r\nreturn 0;\r\nfail1:\r\npci_release_regions(dev);\r\n#ifdef CORRECT_BIOS\r\nfail0:\r\npci_disable_device(dev);\r\n#endif\r\nreturn 1;\r\n}\r\nstatic inline int dual_channel_active(u32 drc)\r\n{\r\nreturn (drc >> 21) & 0x1;\r\n}\r\nstatic void i82875p_init_csrows(struct mem_ctl_info *mci,\r\nstruct pci_dev *pdev,\r\nvoid __iomem * ovrfl_window, u32 drc)\r\n{\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nunsigned nr_chans = dual_channel_active(drc) + 1;\r\nunsigned long last_cumul_size;\r\nu8 value;\r\nu32 drc_ddim;\r\nu32 cumul_size, nr_pages;\r\nint index, j;\r\ndrc_ddim = (drc >> 18) & 0x1;\r\nlast_cumul_size = 0;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\ncsrow = mci->csrows[index];\r\nvalue = readb(ovrfl_window + I82875P_DRB + index);\r\ncumul_size = value << (I82875P_DRB_SHIFT - PAGE_SHIFT);\r\nedac_dbg(3, "(%d) cumul_size 0x%x\n", index, cumul_size);\r\nif (cumul_size == last_cumul_size)\r\ncontinue;\r\ncsrow->first_page = last_cumul_size;\r\ncsrow->last_page = cumul_size - 1;\r\nnr_pages = cumul_size - last_cumul_size;\r\nlast_cumul_size = cumul_size;\r\nfor (j = 0; j < nr_chans; j++) {\r\ndimm = csrow->channels[j]->dimm;\r\ndimm->nr_pages = nr_pages / nr_chans;\r\ndimm->grain = 1 << 12;\r\ndimm->mtype = MEM_DDR;\r\ndimm->dtype = DEV_UNKNOWN;\r\ndimm->edac_mode = drc_ddim ? EDAC_SECDED : EDAC_NONE;\r\n}\r\n}\r\n}\r\nstatic int i82875p_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nint rc = -ENODEV;\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct i82875p_pvt *pvt;\r\nstruct pci_dev *ovrfl_pdev;\r\nvoid __iomem *ovrfl_window;\r\nu32 drc;\r\nu32 nr_chans;\r\nstruct i82875p_error_info discard;\r\nedac_dbg(0, "\n");\r\nif (i82875p_setup_overfl_dev(pdev, &ovrfl_pdev, &ovrfl_window))\r\nreturn -ENODEV;\r\ndrc = readl(ovrfl_window + I82875P_DRC);\r\nnr_chans = dual_channel_active(drc) + 1;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = I82875P_NR_CSROWS(nr_chans);\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = nr_chans;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\r\nif (!mci) {\r\nrc = -ENOMEM;\r\ngoto fail0;\r\n}\r\nedac_dbg(3, "init mci\n");\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_DDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_UNKNOWN;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = I82875P_REVISION;\r\nmci->ctl_name = i82875p_devs[dev_idx].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = i82875p_check;\r\nmci->ctl_page_to_phys = NULL;\r\nedac_dbg(3, "init pvt\n");\r\npvt = (struct i82875p_pvt *)mci->pvt_info;\r\npvt->ovrfl_pdev = ovrfl_pdev;\r\npvt->ovrfl_window = ovrfl_window;\r\ni82875p_init_csrows(mci, pdev, ovrfl_window, drc);\r\ni82875p_get_error_info(mci, &discard);\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto fail1;\r\n}\r\ni82875p_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!i82875p_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nfail1:\r\nedac_mc_free(mci);\r\nfail0:\r\niounmap(ovrfl_window);\r\npci_release_regions(ovrfl_pdev);\r\npci_disable_device(ovrfl_pdev);\r\nreturn rc;\r\n}\r\nstatic int i82875p_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint rc;\r\nedac_dbg(0, "\n");\r\ni82875p_printk(KERN_INFO, "i82875p init one\n");\r\nif (pci_enable_device(pdev) < 0)\r\nreturn -EIO;\r\nrc = i82875p_probe1(pdev, ent->driver_data);\r\nif (mci_pdev == NULL)\r\nmci_pdev = pci_dev_get(pdev);\r\nreturn rc;\r\n}\r\nstatic void i82875p_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct i82875p_pvt *pvt = NULL;\r\nedac_dbg(0, "\n");\r\nif (i82875p_pci)\r\nedac_pci_release_generic_ctl(i82875p_pci);\r\nif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\r\nreturn;\r\npvt = (struct i82875p_pvt *)mci->pvt_info;\r\nif (pvt->ovrfl_window)\r\niounmap(pvt->ovrfl_window);\r\nif (pvt->ovrfl_pdev) {\r\n#ifdef CORRECT_BIOS\r\npci_release_regions(pvt->ovrfl_pdev);\r\n#endif\r\npci_disable_device(pvt->ovrfl_pdev);\r\npci_dev_put(pvt->ovrfl_pdev);\r\n}\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i82875p_init(void)\r\n{\r\nint pci_rc;\r\nedac_dbg(3, "\n");\r\nopstate_init();\r\npci_rc = pci_register_driver(&i82875p_driver);\r\nif (pci_rc < 0)\r\ngoto fail0;\r\nif (mci_pdev == NULL) {\r\nmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82875_0, NULL);\r\nif (!mci_pdev) {\r\nedac_dbg(0, "875p pci_get_device fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\npci_rc = i82875p_init_one(mci_pdev, i82875p_pci_tbl);\r\nif (pci_rc < 0) {\r\nedac_dbg(0, "875p init fail\n");\r\npci_rc = -ENODEV;\r\ngoto fail1;\r\n}\r\n}\r\nreturn 0;\r\nfail1:\r\npci_unregister_driver(&i82875p_driver);\r\nfail0:\r\nif (mci_pdev != NULL)\r\npci_dev_put(mci_pdev);\r\nreturn pci_rc;\r\n}\r\nstatic void __exit i82875p_exit(void)\r\n{\r\nedac_dbg(3, "\n");\r\ni82875p_remove_one(mci_pdev);\r\npci_dev_put(mci_pdev);\r\npci_unregister_driver(&i82875p_driver);\r\n}
