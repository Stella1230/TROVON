static void strfilter_node__delete(struct strfilter_node *node)\r\n{\r\nif (node) {\r\nif (node->p && !is_operator(*node->p))\r\nzfree((char **)&node->p);\r\nstrfilter_node__delete(node->l);\r\nstrfilter_node__delete(node->r);\r\nfree(node);\r\n}\r\n}\r\nvoid strfilter__delete(struct strfilter *filter)\r\n{\r\nif (filter) {\r\nstrfilter_node__delete(filter->root);\r\nfree(filter);\r\n}\r\n}\r\nstatic const char *get_token(const char *s, const char **e)\r\n{\r\nconst char *p;\r\nwhile (isspace(*s))\r\ns++;\r\nif (*s == '\0') {\r\np = s;\r\ngoto end;\r\n}\r\np = s + 1;\r\nif (!is_separator(*s)) {\r\nretry:\r\nwhile (*p && !is_separator(*p) && !isspace(*p))\r\np++;\r\nif (*(p - 1) == '\\' || (*p == '!' && *(p - 1) == '[')) {\r\np++;\r\ngoto retry;\r\n}\r\n}\r\nend:\r\n*e = p;\r\nreturn s;\r\n}\r\nstatic struct strfilter_node *strfilter_node__alloc(const char *op,\r\nstruct strfilter_node *l,\r\nstruct strfilter_node *r)\r\n{\r\nstruct strfilter_node *node = zalloc(sizeof(*node));\r\nif (node) {\r\nnode->p = op;\r\nnode->l = l;\r\nnode->r = r;\r\n}\r\nreturn node;\r\n}\r\nstatic struct strfilter_node *strfilter_node__new(const char *s,\r\nconst char **ep)\r\n{\r\nstruct strfilter_node root, *cur, *last_op;\r\nconst char *e;\r\nif (!s)\r\nreturn NULL;\r\nmemset(&root, 0, sizeof(root));\r\nlast_op = cur = &root;\r\ns = get_token(s, &e);\r\nwhile (*s != '\0' && *s != ')') {\r\nswitch (*s) {\r\ncase '&':\r\nif (!cur->r || !last_op->r)\r\ngoto error;\r\ncur = strfilter_node__alloc(OP_and, last_op->r, NULL);\r\nif (!cur)\r\ngoto nomem;\r\nlast_op->r = cur;\r\nlast_op = cur;\r\nbreak;\r\ncase '|':\r\nif (!cur->r || !root.r)\r\ngoto error;\r\ncur = strfilter_node__alloc(OP_or, root.r, NULL);\r\nif (!cur)\r\ngoto nomem;\r\nroot.r = cur;\r\nlast_op = cur;\r\nbreak;\r\ncase '!':\r\nif (cur->r)\r\ngoto error;\r\ncur->r = strfilter_node__alloc(OP_not, NULL, NULL);\r\nif (!cur->r)\r\ngoto nomem;\r\ncur = cur->r;\r\nbreak;\r\ncase '(':\r\nif (cur->r)\r\ngoto error;\r\ncur->r = strfilter_node__new(s + 1, &s);\r\nif (!s)\r\ngoto nomem;\r\nif (!cur->r || *s != ')')\r\ngoto error;\r\ne = s + 1;\r\nbreak;\r\ndefault:\r\nif (cur->r)\r\ngoto error;\r\ncur->r = strfilter_node__alloc(NULL, NULL, NULL);\r\nif (!cur->r)\r\ngoto nomem;\r\ncur->r->p = strndup(s, e - s);\r\nif (!cur->r->p)\r\ngoto nomem;\r\n}\r\ns = get_token(e, &e);\r\n}\r\nif (!cur->r)\r\ngoto error;\r\n*ep = s;\r\nreturn root.r;\r\nnomem:\r\ns = NULL;\r\nerror:\r\n*ep = s;\r\nstrfilter_node__delete(root.r);\r\nreturn NULL;\r\n}\r\nstruct strfilter *strfilter__new(const char *rules, const char **err)\r\n{\r\nstruct strfilter *filter = zalloc(sizeof(*filter));\r\nconst char *ep = NULL;\r\nif (filter)\r\nfilter->root = strfilter_node__new(rules, &ep);\r\nif (!filter || !filter->root || *ep != '\0') {\r\nif (err)\r\n*err = ep;\r\nstrfilter__delete(filter);\r\nfilter = NULL;\r\n}\r\nreturn filter;\r\n}\r\nstatic bool strfilter_node__compare(struct strfilter_node *node,\r\nconst char *str)\r\n{\r\nif (!node || !node->p)\r\nreturn false;\r\nswitch (*node->p) {\r\ncase '|':\r\nreturn strfilter_node__compare(node->l, str) ||\r\nstrfilter_node__compare(node->r, str);\r\ncase '&':\r\nreturn strfilter_node__compare(node->l, str) &&\r\nstrfilter_node__compare(node->r, str);\r\ncase '!':\r\nreturn !strfilter_node__compare(node->r, str);\r\ndefault:\r\nreturn strglobmatch(str, node->p);\r\n}\r\n}\r\nbool strfilter__compare(struct strfilter *filter, const char *str)\r\n{\r\nif (!filter)\r\nreturn false;\r\nreturn strfilter_node__compare(filter->root, str);\r\n}
