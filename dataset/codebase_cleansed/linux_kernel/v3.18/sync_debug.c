void sync_timeline_debug_add(struct sync_timeline *obj)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sync_timeline_list_lock, flags);\r\nlist_add_tail(&obj->sync_timeline_list, &sync_timeline_list_head);\r\nspin_unlock_irqrestore(&sync_timeline_list_lock, flags);\r\n}\r\nvoid sync_timeline_debug_remove(struct sync_timeline *obj)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sync_timeline_list_lock, flags);\r\nlist_del(&obj->sync_timeline_list);\r\nspin_unlock_irqrestore(&sync_timeline_list_lock, flags);\r\n}\r\nvoid sync_fence_debug_add(struct sync_fence *fence)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sync_fence_list_lock, flags);\r\nlist_add_tail(&fence->sync_fence_list, &sync_fence_list_head);\r\nspin_unlock_irqrestore(&sync_fence_list_lock, flags);\r\n}\r\nvoid sync_fence_debug_remove(struct sync_fence *fence)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sync_fence_list_lock, flags);\r\nlist_del(&fence->sync_fence_list);\r\nspin_unlock_irqrestore(&sync_fence_list_lock, flags);\r\n}\r\nstatic const char *sync_status_str(int status)\r\n{\r\nif (status == 0)\r\nreturn "signaled";\r\nif (status > 0)\r\nreturn "active";\r\nreturn "error";\r\n}\r\nstatic void sync_print_pt(struct seq_file *s, struct sync_pt *pt, bool fence)\r\n{\r\nint status = 1;\r\nstruct sync_timeline *parent = sync_pt_parent(pt);\r\nif (fence_is_signaled_locked(&pt->base))\r\nstatus = pt->base.status;\r\nseq_printf(s, " %s%spt %s",\r\nfence ? parent->name : "",\r\nfence ? "_" : "",\r\nsync_status_str(status));\r\nif (status <= 0) {\r\nstruct timeval tv = ktime_to_timeval(pt->base.timestamp);\r\nseq_printf(s, "@%ld.%06ld", tv.tv_sec, tv.tv_usec);\r\n}\r\nif (parent->ops->timeline_value_str &&\r\nparent->ops->pt_value_str) {\r\nchar value[64];\r\nparent->ops->pt_value_str(pt, value, sizeof(value));\r\nseq_printf(s, ": %s", value);\r\nif (fence) {\r\nparent->ops->timeline_value_str(parent, value,\r\nsizeof(value));\r\nseq_printf(s, " / %s", value);\r\n}\r\n}\r\nseq_puts(s, "\n");\r\n}\r\nstatic void sync_print_obj(struct seq_file *s, struct sync_timeline *obj)\r\n{\r\nstruct list_head *pos;\r\nunsigned long flags;\r\nseq_printf(s, "%s %s", obj->name, obj->ops->driver_name);\r\nif (obj->ops->timeline_value_str) {\r\nchar value[64];\r\nobj->ops->timeline_value_str(obj, value, sizeof(value));\r\nseq_printf(s, ": %s", value);\r\n}\r\nseq_puts(s, "\n");\r\nspin_lock_irqsave(&obj->child_list_lock, flags);\r\nlist_for_each(pos, &obj->child_list_head) {\r\nstruct sync_pt *pt =\r\ncontainer_of(pos, struct sync_pt, child_list);\r\nsync_print_pt(s, pt, false);\r\n}\r\nspin_unlock_irqrestore(&obj->child_list_lock, flags);\r\n}\r\nstatic void sync_print_fence(struct seq_file *s, struct sync_fence *fence)\r\n{\r\nwait_queue_t *pos;\r\nunsigned long flags;\r\nint i;\r\nseq_printf(s, "[%p] %s: %s\n", fence, fence->name,\r\nsync_status_str(atomic_read(&fence->status)));\r\nfor (i = 0; i < fence->num_fences; ++i) {\r\nstruct sync_pt *pt =\r\ncontainer_of(fence->cbs[i].sync_pt,\r\nstruct sync_pt, base);\r\nsync_print_pt(s, pt, true);\r\n}\r\nspin_lock_irqsave(&fence->wq.lock, flags);\r\nlist_for_each_entry(pos, &fence->wq.task_list, task_list) {\r\nstruct sync_fence_waiter *waiter;\r\nif (pos->func != &sync_fence_wake_up_wq)\r\ncontinue;\r\nwaiter = container_of(pos, struct sync_fence_waiter, work);\r\nseq_printf(s, "waiter %pF\n", waiter->callback);\r\n}\r\nspin_unlock_irqrestore(&fence->wq.lock, flags);\r\n}\r\nstatic int sync_debugfs_show(struct seq_file *s, void *unused)\r\n{\r\nunsigned long flags;\r\nstruct list_head *pos;\r\nseq_puts(s, "objs:\n--------------\n");\r\nspin_lock_irqsave(&sync_timeline_list_lock, flags);\r\nlist_for_each(pos, &sync_timeline_list_head) {\r\nstruct sync_timeline *obj =\r\ncontainer_of(pos, struct sync_timeline,\r\nsync_timeline_list);\r\nsync_print_obj(s, obj);\r\nseq_puts(s, "\n");\r\n}\r\nspin_unlock_irqrestore(&sync_timeline_list_lock, flags);\r\nseq_puts(s, "fences:\n--------------\n");\r\nspin_lock_irqsave(&sync_fence_list_lock, flags);\r\nlist_for_each(pos, &sync_fence_list_head) {\r\nstruct sync_fence *fence =\r\ncontainer_of(pos, struct sync_fence, sync_fence_list);\r\nsync_print_fence(s, fence);\r\nseq_puts(s, "\n");\r\n}\r\nspin_unlock_irqrestore(&sync_fence_list_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sync_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sync_debugfs_show, inode->i_private);\r\n}\r\nstatic __init int sync_debugfs_init(void)\r\n{\r\ndebugfs_create_file("sync", S_IRUGO, NULL, NULL, &sync_debugfs_fops);\r\nreturn 0;\r\n}\r\nvoid sync_dump(void)\r\n{\r\nstruct seq_file s = {\r\n.buf = sync_dump_buf,\r\n.size = sizeof(sync_dump_buf) - 1,\r\n};\r\nint i;\r\nsync_debugfs_show(&s, NULL);\r\nfor (i = 0; i < s.count; i += DUMP_CHUNK) {\r\nif ((s.count - i) > DUMP_CHUNK) {\r\nchar c = s.buf[i + DUMP_CHUNK];\r\ns.buf[i + DUMP_CHUNK] = 0;\r\npr_cont("%s", s.buf + i);\r\ns.buf[i + DUMP_CHUNK] = c;\r\n} else {\r\ns.buf[s.count] = 0;\r\npr_cont("%s", s.buf + i);\r\n}\r\n}\r\n}
