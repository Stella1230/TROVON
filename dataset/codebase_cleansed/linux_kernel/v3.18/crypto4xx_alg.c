static void set_dynamic_sa_command_0(struct dynamic_sa_ctl *sa, u32 save_h,\r\nu32 save_iv, u32 ld_h, u32 ld_iv,\r\nu32 hdr_proc, u32 h, u32 c, u32 pad_type,\r\nu32 op_grp, u32 op, u32 dir)\r\n{\r\nsa->sa_command_0.w = 0;\r\nsa->sa_command_0.bf.save_hash_state = save_h;\r\nsa->sa_command_0.bf.save_iv = save_iv;\r\nsa->sa_command_0.bf.load_hash_state = ld_h;\r\nsa->sa_command_0.bf.load_iv = ld_iv;\r\nsa->sa_command_0.bf.hdr_proc = hdr_proc;\r\nsa->sa_command_0.bf.hash_alg = h;\r\nsa->sa_command_0.bf.cipher_alg = c;\r\nsa->sa_command_0.bf.pad_type = pad_type & 3;\r\nsa->sa_command_0.bf.extend_pad = pad_type >> 2;\r\nsa->sa_command_0.bf.op_group = op_grp;\r\nsa->sa_command_0.bf.opcode = op;\r\nsa->sa_command_0.bf.dir = dir;\r\n}\r\nstatic void set_dynamic_sa_command_1(struct dynamic_sa_ctl *sa, u32 cm,\r\nu32 hmac_mc, u32 cfb, u32 esn,\r\nu32 sn_mask, u32 mute, u32 cp_pad,\r\nu32 cp_pay, u32 cp_hdr)\r\n{\r\nsa->sa_command_1.w = 0;\r\nsa->sa_command_1.bf.crypto_mode31 = (cm & 4) >> 2;\r\nsa->sa_command_1.bf.crypto_mode9_8 = cm & 3;\r\nsa->sa_command_1.bf.feedback_mode = cfb,\r\nsa->sa_command_1.bf.sa_rev = 1;\r\nsa->sa_command_1.bf.extended_seq_num = esn;\r\nsa->sa_command_1.bf.seq_num_mask = sn_mask;\r\nsa->sa_command_1.bf.mutable_bit_proc = mute;\r\nsa->sa_command_1.bf.copy_pad = cp_pad;\r\nsa->sa_command_1.bf.copy_payload = cp_pay;\r\nsa->sa_command_1.bf.copy_hdr = cp_hdr;\r\n}\r\nint crypto4xx_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nctx->direction = DIR_OUTBOUND;\r\nctx->hash_final = 0;\r\nctx->is_hash = 0;\r\nctx->pd_ctl = 0x1;\r\nreturn crypto4xx_build_pd(&req->base, ctx, req->src, req->dst,\r\nreq->nbytes, req->info,\r\nget_dynamic_sa_iv_size(ctx));\r\n}\r\nint crypto4xx_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nctx->direction = DIR_INBOUND;\r\nctx->hash_final = 0;\r\nctx->is_hash = 0;\r\nctx->pd_ctl = 1;\r\nreturn crypto4xx_build_pd(&req->base, ctx, req->src, req->dst,\r\nreq->nbytes, req->info,\r\nget_dynamic_sa_iv_size(ctx));\r\n}\r\nstatic int crypto4xx_setkey_aes(struct crypto_ablkcipher *cipher,\r\nconst u8 *key,\r\nunsigned int keylen,\r\nunsigned char cm,\r\nu8 fb)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct dynamic_sa_ctl *sa;\r\nint rc;\r\nif (keylen != AES_KEYSIZE_256 &&\r\nkeylen != AES_KEYSIZE_192 && keylen != AES_KEYSIZE_128) {\r\ncrypto_ablkcipher_set_flags(cipher,\r\nCRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nif (ctx->sa_in_dma_addr || ctx->sa_out_dma_addr)\r\ncrypto4xx_free_sa(ctx);\r\nrc = crypto4xx_alloc_sa(ctx, SA_AES128_LEN + (keylen-16) / 4);\r\nif (rc)\r\nreturn rc;\r\nif (ctx->state_record_dma_addr == 0) {\r\nrc = crypto4xx_alloc_state_record(ctx);\r\nif (rc) {\r\ncrypto4xx_free_sa(ctx);\r\nreturn rc;\r\n}\r\n}\r\nsa = (struct dynamic_sa_ctl *) ctx->sa_in;\r\nctx->hash_final = 0;\r\nset_dynamic_sa_command_0(sa, SA_NOT_SAVE_HASH, SA_NOT_SAVE_IV,\r\nSA_LOAD_HASH_FROM_SA, SA_LOAD_IV_FROM_STATE,\r\nSA_NO_HEADER_PROC, SA_HASH_ALG_NULL,\r\nSA_CIPHER_ALG_AES, SA_PAD_TYPE_ZERO,\r\nSA_OP_GROUP_BASIC, SA_OPCODE_DECRYPT,\r\nDIR_INBOUND);\r\nset_dynamic_sa_command_1(sa, cm, SA_HASH_MODE_HASH,\r\nfb, SA_EXTENDED_SN_OFF,\r\nSA_SEQ_MASK_OFF, SA_MC_ENABLE,\r\nSA_NOT_COPY_PAD, SA_NOT_COPY_PAYLOAD,\r\nSA_NOT_COPY_HDR);\r\ncrypto4xx_memcpy_le(ctx->sa_in + get_dynamic_sa_offset_key_field(ctx),\r\nkey, keylen);\r\nsa->sa_contents = SA_AES_CONTENTS | (keylen << 2);\r\nsa->sa_command_1.bf.key_len = keylen >> 3;\r\nctx->is_hash = 0;\r\nctx->direction = DIR_INBOUND;\r\nmemcpy(ctx->sa_in + get_dynamic_sa_offset_state_ptr_field(ctx),\r\n(void *)&ctx->state_record_dma_addr, 4);\r\nctx->offset_to_sr_ptr = get_dynamic_sa_offset_state_ptr_field(ctx);\r\nmemcpy(ctx->sa_out, ctx->sa_in, ctx->sa_len * 4);\r\nsa = (struct dynamic_sa_ctl *) ctx->sa_out;\r\nsa->sa_command_0.bf.dir = DIR_OUTBOUND;\r\nreturn 0;\r\n}\r\nint crypto4xx_setkey_aes_cbc(struct crypto_ablkcipher *cipher,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nreturn crypto4xx_setkey_aes(cipher, key, keylen, CRYPTO_MODE_CBC,\r\nCRYPTO_FEEDBACK_MODE_NO_FB);\r\n}\r\nstatic int crypto4xx_hash_alg_init(struct crypto_tfm *tfm,\r\nunsigned int sa_len,\r\nunsigned char ha,\r\nunsigned char hm)\r\n{\r\nstruct crypto_alg *alg = tfm->__crt_alg;\r\nstruct crypto4xx_alg *my_alg = crypto_alg_to_crypto4xx_alg(alg);\r\nstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct dynamic_sa_ctl *sa;\r\nstruct dynamic_sa_hash160 *sa_in;\r\nint rc;\r\nctx->dev = my_alg->dev;\r\nctx->is_hash = 1;\r\nctx->hash_final = 0;\r\nif (ctx->sa_in_dma_addr || ctx->sa_out_dma_addr)\r\ncrypto4xx_free_sa(ctx);\r\nrc = crypto4xx_alloc_sa(ctx, sa_len);\r\nif (rc)\r\nreturn rc;\r\nif (ctx->state_record_dma_addr == 0) {\r\ncrypto4xx_alloc_state_record(ctx);\r\nif (!ctx->state_record_dma_addr) {\r\ncrypto4xx_free_sa(ctx);\r\nreturn -ENOMEM;\r\n}\r\n}\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct crypto4xx_ctx));\r\nsa = (struct dynamic_sa_ctl *) ctx->sa_in;\r\nset_dynamic_sa_command_0(sa, SA_SAVE_HASH, SA_NOT_SAVE_IV,\r\nSA_NOT_LOAD_HASH, SA_LOAD_IV_FROM_SA,\r\nSA_NO_HEADER_PROC, ha, SA_CIPHER_ALG_NULL,\r\nSA_PAD_TYPE_ZERO, SA_OP_GROUP_BASIC,\r\nSA_OPCODE_HASH, DIR_INBOUND);\r\nset_dynamic_sa_command_1(sa, 0, SA_HASH_MODE_HASH,\r\nCRYPTO_FEEDBACK_MODE_NO_FB, SA_EXTENDED_SN_OFF,\r\nSA_SEQ_MASK_OFF, SA_MC_ENABLE,\r\nSA_NOT_COPY_PAD, SA_NOT_COPY_PAYLOAD,\r\nSA_NOT_COPY_HDR);\r\nctx->direction = DIR_INBOUND;\r\nsa->sa_contents = SA_HASH160_CONTENTS;\r\nsa_in = (struct dynamic_sa_hash160 *) ctx->sa_in;\r\nmemset(sa_in->inner_digest, 0, sizeof(sa_in->inner_digest));\r\nmemset(sa_in->outer_digest, 0, sizeof(sa_in->outer_digest));\r\nsa_in->state_ptr = ctx->state_record_dma_addr;\r\nctx->offset_to_sr_ptr = get_dynamic_sa_offset_state_ptr_field(ctx);\r\nreturn 0;\r\n}\r\nint crypto4xx_hash_init(struct ahash_request *req)\r\n{\r\nstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nint ds;\r\nstruct dynamic_sa_ctl *sa;\r\nsa = (struct dynamic_sa_ctl *) ctx->sa_in;\r\nds = crypto_ahash_digestsize(\r\n__crypto_ahash_cast(req->base.tfm));\r\nsa->sa_command_0.bf.digest_len = ds >> 2;\r\nsa->sa_command_0.bf.load_hash_state = SA_LOAD_HASH_FROM_SA;\r\nctx->is_hash = 1;\r\nctx->direction = DIR_INBOUND;\r\nreturn 0;\r\n}\r\nint crypto4xx_hash_update(struct ahash_request *req)\r\n{\r\nstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nctx->is_hash = 1;\r\nctx->hash_final = 0;\r\nctx->pd_ctl = 0x11;\r\nctx->direction = DIR_INBOUND;\r\nreturn crypto4xx_build_pd(&req->base, ctx, req->src,\r\n(struct scatterlist *) req->result,\r\nreq->nbytes, NULL, 0);\r\n}\r\nint crypto4xx_hash_final(struct ahash_request *req)\r\n{\r\nreturn 0;\r\n}\r\nint crypto4xx_hash_digest(struct ahash_request *req)\r\n{\r\nstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nctx->hash_final = 1;\r\nctx->pd_ctl = 0x11;\r\nctx->direction = DIR_INBOUND;\r\nreturn crypto4xx_build_pd(&req->base, ctx, req->src,\r\n(struct scatterlist *) req->result,\r\nreq->nbytes, NULL, 0);\r\n}\r\nint crypto4xx_sha1_alg_init(struct crypto_tfm *tfm)\r\n{\r\nreturn crypto4xx_hash_alg_init(tfm, SA_HASH160_LEN, SA_HASH_ALG_SHA1,\r\nSA_HASH_MODE_HASH);\r\n}
