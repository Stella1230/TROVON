int rsnd_src_ssiu_start(struct rsnd_mod *ssi_mod,\r\nstruct rsnd_dai *rdai,\r\nint use_busif)\r\n{\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(ssi_mod);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nint ssi_id = rsnd_mod_id(ssi_mod);\r\nrsnd_mod_bset(ssi_mod, SSI_MODE0, (1 << ssi_id),\r\n!use_busif << ssi_id);\r\nif (rsnd_ssi_is_pin_sharing(ssi_mod)) {\r\nint shift = -1;\r\nswitch (ssi_id) {\r\ncase 1:\r\nshift = 0;\r\nbreak;\r\ncase 2:\r\nshift = 2;\r\nbreak;\r\ncase 4:\r\nshift = 16;\r\nbreak;\r\n}\r\nif (shift >= 0)\r\nrsnd_mod_bset(ssi_mod, SSI_MODE1,\r\n0x3 << shift,\r\nrsnd_dai_is_clk_master(rdai) ?\r\n0x2 << shift : 0x1 << shift);\r\n}\r\nif (use_busif) {\r\nu32 val = 0x76543210;\r\nu32 mask = ~0;\r\nrsnd_mod_write(ssi_mod, SSI_BUSIF_ADINR,\r\nrsnd_get_adinr(ssi_mod));\r\nrsnd_mod_write(ssi_mod, SSI_BUSIF_MODE, 1);\r\nrsnd_mod_write(ssi_mod, SSI_CTRL, 0x1);\r\nmask <<= runtime->channels * 4;\r\nval = val & mask;\r\nswitch (runtime->sample_bits) {\r\ncase 16:\r\nval |= 0x67452301 & ~mask;\r\nbreak;\r\ncase 32:\r\nval |= 0x76543210 & ~mask;\r\nbreak;\r\n}\r\nrsnd_mod_write(ssi_mod, BUSIF_DALIGN, val);\r\n}\r\nreturn 0;\r\n}\r\nint rsnd_src_ssiu_stop(struct rsnd_mod *ssi_mod,\r\nstruct rsnd_dai *rdai,\r\nint use_busif)\r\n{\r\nif (use_busif)\r\nrsnd_mod_write(ssi_mod, SSI_CTRL, 0);\r\nreturn 0;\r\n}\r\nint rsnd_src_enable_ssi_irq(struct rsnd_mod *ssi_mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(ssi_mod);\r\nif (rsnd_is_gen2(priv))\r\nrsnd_mod_write(ssi_mod, INT_ENABLE, 0x0f000000);\r\nreturn 0;\r\n}\r\nunsigned int rsnd_src_get_ssi_rate(struct rsnd_priv *priv,\r\nstruct rsnd_dai_stream *io,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nstruct rsnd_mod *src_mod = rsnd_io_to_mod_src(io);\r\nstruct rsnd_src *src;\r\nunsigned int rate = 0;\r\nif (src_mod) {\r\nsrc = rsnd_mod_to_src(src_mod);\r\nrate = rsnd_src_convert_rate(src);\r\n}\r\nif (!rate)\r\nrate = runtime->rate;\r\nreturn rate;\r\n}\r\nstatic int rsnd_src_set_convert_rate(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nu32 convert_rate = rsnd_src_convert_rate(src);\r\nu32 fsrate = 0;\r\nif (convert_rate)\r\nfsrate = 0x0400000 / convert_rate * runtime->rate;\r\nrsnd_mod_write(mod, SRC_SWRSR, 0);\r\nrsnd_mod_write(mod, SRC_SWRSR, 1);\r\nrsnd_mod_write(mod, SRC_SRCIR, 1);\r\nrsnd_mod_write(mod, SRC_ADINR, rsnd_get_adinr(mod));\r\nif (fsrate) {\r\nrsnd_mod_write(mod, SRC_IFSCR, 1);\r\nrsnd_mod_write(mod, SRC_IFSVR, fsrate);\r\n}\r\nrsnd_mod_write(mod, SRC_BUSIF_MODE, 1);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_init(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nclk_prepare_enable(src->clk);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_quit(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nclk_disable_unprepare(src->clk);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_start(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nrsnd_mod_write(mod, SRC_SRCIR, 0);\r\nif (rsnd_src_convert_rate(src))\r\nrsnd_mod_write(mod, SRC_ROUTE_MODE0, 1);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_stop(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nif (rsnd_src_convert_rate(src))\r\nrsnd_mod_write(mod, SRC_ROUTE_MODE0, 0);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_set_route_gen1(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nstruct src_route_config {\r\nu32 mask;\r\nint shift;\r\n} routes[] = {\r\n{ 0xF, 0, },\r\n{ 0xF, 4, },\r\n{ 0xF, 8, },\r\n{ 0x7, 12, },\r\n{ 0x7, 16, },\r\n{ 0x7, 20, },\r\n{ 0x7, 24, },\r\n{ 0x3, 28, },\r\n{ 0x3, 30, },\r\n};\r\nu32 mask;\r\nu32 val;\r\nint id;\r\nid = rsnd_mod_id(mod);\r\nif (id < 0 || id >= ARRAY_SIZE(routes))\r\nreturn -EIO;\r\nval = rsnd_dai_is_play(rdai, io) ? 0x1 : 0x2;\r\nval = val << routes[id].shift;\r\nmask = routes[id].mask << routes[id].shift;\r\nrsnd_mod_bset(mod, SRC_ROUTE_SEL, mask, val);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_set_convert_timing_gen1(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nu32 convert_rate = rsnd_src_convert_rate(src);\r\nu32 mask;\r\nu32 val;\r\nint shift;\r\nint id = rsnd_mod_id(mod);\r\nint ret;\r\nshift = (id % 4) * 8;\r\nmask = 0x1F << shift;\r\nret = 0;\r\nif (convert_rate) {\r\nval = 0;\r\nret = rsnd_adg_set_convert_clk_gen1(priv, mod,\r\nruntime->rate,\r\nconvert_rate);\r\n} else if (8 == id) {\r\nval = id << shift;\r\n} else {\r\nval = (id + 1) << shift;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (id / 4) {\r\ncase 0:\r\nrsnd_mod_bset(mod, SRC_TMG_SEL0, mask, val);\r\nbreak;\r\ncase 1:\r\nrsnd_mod_bset(mod, SRC_TMG_SEL1, mask, val);\r\nbreak;\r\ncase 2:\r\nrsnd_mod_bset(mod, SRC_TMG_SEL2, mask, val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_set_convert_rate_gen1(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nint ret;\r\nret = rsnd_src_set_convert_rate(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nrsnd_mod_write(mod, SRC_SRCCR, 0x00010110);\r\nrsnd_mod_write(mod, SRC_MNFSR,\r\nrsnd_mod_read(mod, SRC_IFSVR) / 100 * 98);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_probe_gen1(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\ndev_dbg(dev, "%s (Gen1) is probed\n", rsnd_mod_name(mod));\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_init_gen1(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nint ret;\r\nret = rsnd_src_init(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rsnd_src_set_route_gen1(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rsnd_src_set_convert_rate_gen1(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rsnd_src_set_convert_timing_gen1(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_start_gen1(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nint id = rsnd_mod_id(mod);\r\nrsnd_mod_bset(mod, SRC_ROUTE_CTRL, (1 << id), (1 << id));\r\nreturn rsnd_src_start(mod, rdai);\r\n}\r\nstatic int rsnd_src_stop_gen1(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nint id = rsnd_mod_id(mod);\r\nrsnd_mod_bset(mod, SRC_ROUTE_CTRL, (1 << id), 0);\r\nreturn rsnd_src_stop(mod, rdai);\r\n}\r\nstatic int rsnd_src_set_convert_rate_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nuint ratio;\r\nint ret;\r\nif (!rsnd_src_convert_rate(src))\r\nratio = 0;\r\nelse if (rsnd_src_convert_rate(src) > runtime->rate)\r\nratio = 100 * rsnd_src_convert_rate(src) / runtime->rate;\r\nelse\r\nratio = 100 * runtime->rate / rsnd_src_convert_rate(src);\r\nif (ratio > 600) {\r\ndev_err(dev, "FSO/FSI ratio error\n");\r\nreturn -EINVAL;\r\n}\r\nret = rsnd_src_set_convert_rate(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nrsnd_mod_write(mod, SRC_SRCCR, 0x00011110);\r\nswitch (rsnd_mod_id(mod)) {\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ncase 8:\r\nrsnd_mod_write(mod, SRC_BSDSR, 0x02400000);\r\nbreak;\r\ndefault:\r\nrsnd_mod_write(mod, SRC_BSDSR, 0x01800000);\r\nbreak;\r\n}\r\nrsnd_mod_write(mod, SRC_BSISR, 0x00100060);\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_set_convert_timing_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nu32 convert_rate = rsnd_src_convert_rate(src);\r\nint ret;\r\nif (convert_rate)\r\nret = rsnd_adg_set_convert_clk_gen2(mod, rdai, io,\r\nruntime->rate,\r\nconvert_rate);\r\nelse\r\nret = rsnd_adg_set_convert_timing_gen2(mod, rdai, io);\r\nreturn ret;\r\n}\r\nstatic int rsnd_src_probe_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nint ret;\r\nret = rsnd_dma_init(priv,\r\nrsnd_mod_to_dma(mod),\r\nrsnd_info_is_playback(priv, src),\r\nsrc->info->dma_id);\r\nif (ret < 0)\r\ndev_err(dev, "SRC DMA failed\n");\r\ndev_dbg(dev, "%s (Gen2) is probed\n", rsnd_mod_name(mod));\r\nreturn ret;\r\n}\r\nstatic int rsnd_src_remove_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nrsnd_dma_quit(rsnd_mod_to_priv(mod), rsnd_mod_to_dma(mod));\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_init_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nint ret;\r\nret = rsnd_src_init(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rsnd_src_set_convert_rate_gen2(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rsnd_src_set_convert_timing_gen2(mod, rdai);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rsnd_src_start_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_dai_stream *io = rsnd_mod_to_io(mod);\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nu32 val = rsnd_io_to_mod_dvc(io) ? 0x01 : 0x11;\r\nrsnd_dma_start(rsnd_mod_to_dma(&src->mod));\r\nrsnd_mod_write(mod, SRC_CTRL, val);\r\nreturn rsnd_src_start(mod, rdai);\r\n}\r\nstatic int rsnd_src_stop_gen2(struct rsnd_mod *mod,\r\nstruct rsnd_dai *rdai)\r\n{\r\nstruct rsnd_src *src = rsnd_mod_to_src(mod);\r\nrsnd_mod_write(mod, SRC_CTRL, 0);\r\nrsnd_dma_stop(rsnd_mod_to_dma(&src->mod));\r\nreturn rsnd_src_stop(mod, rdai);\r\n}\r\nstruct rsnd_mod *rsnd_src_mod_get(struct rsnd_priv *priv, int id)\r\n{\r\nif (WARN_ON(id < 0 || id >= rsnd_src_nr(priv)))\r\nid = 0;\r\nreturn &((struct rsnd_src *)(priv->src) + id)->mod;\r\n}\r\nstatic void rsnd_of_parse_src(struct platform_device *pdev,\r\nconst struct rsnd_of_data *of_data,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct device_node *src_node;\r\nstruct rcar_snd_info *info = rsnd_priv_to_info(priv);\r\nstruct rsnd_src_platform_info *src_info;\r\nstruct device *dev = &pdev->dev;\r\nint nr;\r\nif (!of_data)\r\nreturn;\r\nsrc_node = of_get_child_by_name(dev->of_node, "rcar_sound,src");\r\nif (!src_node)\r\nreturn;\r\nnr = of_get_child_count(src_node);\r\nif (!nr)\r\ngoto rsnd_of_parse_src_end;\r\nsrc_info = devm_kzalloc(dev,\r\nsizeof(struct rsnd_src_platform_info) * nr,\r\nGFP_KERNEL);\r\nif (!src_info) {\r\ndev_err(dev, "src info allocation error\n");\r\ngoto rsnd_of_parse_src_end;\r\n}\r\ninfo->src_info = src_info;\r\ninfo->src_info_nr = nr;\r\nrsnd_of_parse_src_end:\r\nof_node_put(src_node);\r\n}\r\nint rsnd_src_probe(struct platform_device *pdev,\r\nconst struct rsnd_of_data *of_data,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rcar_snd_info *info = rsnd_priv_to_info(priv);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_src *src;\r\nstruct rsnd_mod_ops *ops;\r\nstruct clk *clk;\r\nchar name[RSND_SRC_NAME_SIZE];\r\nint i, nr;\r\nops = NULL;\r\nif (rsnd_is_gen1(priv))\r\nops = &rsnd_src_gen1_ops;\r\nif (rsnd_is_gen2(priv))\r\nops = &rsnd_src_gen2_ops;\r\nif (!ops) {\r\ndev_err(dev, "unknown Generation\n");\r\nreturn -EIO;\r\n}\r\nrsnd_of_parse_src(pdev, of_data, priv);\r\nnr = info->src_info_nr;\r\nif (!nr)\r\nreturn 0;\r\nsrc = devm_kzalloc(dev, sizeof(*src) * nr, GFP_KERNEL);\r\nif (!src) {\r\ndev_err(dev, "SRC allocate failed\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->src_nr = nr;\r\npriv->src = src;\r\nfor_each_rsnd_src(src, priv, i) {\r\nsnprintf(name, RSND_SRC_NAME_SIZE, "%s.%d",\r\nSRC_NAME, i);\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nsrc->info = &info->src_info[i];\r\nsrc->clk = clk;\r\nrsnd_mod_init(priv, &src->mod, ops, RSND_MOD_SRC, i);\r\ndev_dbg(dev, "SRC%d probed\n", i);\r\n}\r\nreturn 0;\r\n}
