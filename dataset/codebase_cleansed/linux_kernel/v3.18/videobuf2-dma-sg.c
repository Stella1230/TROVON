static int vb2_dma_sg_alloc_compacted(struct vb2_dma_sg_buf *buf,\r\ngfp_t gfp_flags)\r\n{\r\nunsigned int last_page = 0;\r\nint size = buf->size;\r\nwhile (size > 0) {\r\nstruct page *pages;\r\nint order;\r\nint i;\r\norder = get_order(size);\r\nif ((PAGE_SIZE << order) > size)\r\norder--;\r\npages = NULL;\r\nwhile (!pages) {\r\npages = alloc_pages(GFP_KERNEL | __GFP_ZERO |\r\n__GFP_NOWARN | gfp_flags, order);\r\nif (pages)\r\nbreak;\r\nif (order == 0) {\r\nwhile (last_page--)\r\n__free_page(buf->pages[last_page]);\r\nreturn -ENOMEM;\r\n}\r\norder--;\r\n}\r\nsplit_page(pages, order);\r\nfor (i = 0; i < (1 << order); i++)\r\nbuf->pages[last_page++] = &pages[i];\r\nsize -= PAGE_SIZE << order;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *vb2_dma_sg_alloc(void *alloc_ctx, unsigned long size, gfp_t gfp_flags)\r\n{\r\nstruct vb2_dma_sg_buf *buf;\r\nint ret;\r\nint num_pages;\r\nbuf = kzalloc(sizeof *buf, GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->vaddr = NULL;\r\nbuf->write = 0;\r\nbuf->offset = 0;\r\nbuf->size = size;\r\nbuf->num_pages = size >> PAGE_SHIFT;\r\nbuf->pages = kzalloc(buf->num_pages * sizeof(struct page *),\r\nGFP_KERNEL);\r\nif (!buf->pages)\r\ngoto fail_pages_array_alloc;\r\nret = vb2_dma_sg_alloc_compacted(buf, gfp_flags);\r\nif (ret)\r\ngoto fail_pages_alloc;\r\nret = sg_alloc_table_from_pages(&buf->sg_table, buf->pages,\r\nbuf->num_pages, 0, size, GFP_KERNEL);\r\nif (ret)\r\ngoto fail_table_alloc;\r\nbuf->handler.refcount = &buf->refcount;\r\nbuf->handler.put = vb2_dma_sg_put;\r\nbuf->handler.arg = buf;\r\natomic_inc(&buf->refcount);\r\ndprintk(1, "%s: Allocated buffer of %d pages\n",\r\n__func__, buf->num_pages);\r\nreturn buf;\r\nfail_table_alloc:\r\nnum_pages = buf->num_pages;\r\nwhile (num_pages--)\r\n__free_page(buf->pages[num_pages]);\r\nfail_pages_alloc:\r\nkfree(buf->pages);\r\nfail_pages_array_alloc:\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nstatic void vb2_dma_sg_put(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nint i = buf->num_pages;\r\nif (atomic_dec_and_test(&buf->refcount)) {\r\ndprintk(1, "%s: Freeing buffer of %d pages\n", __func__,\r\nbuf->num_pages);\r\nif (buf->vaddr)\r\nvm_unmap_ram(buf->vaddr, buf->num_pages);\r\nsg_free_table(&buf->sg_table);\r\nwhile (--i >= 0)\r\n__free_page(buf->pages[i]);\r\nkfree(buf->pages);\r\nkfree(buf);\r\n}\r\n}\r\nstatic inline int vma_is_io(struct vm_area_struct *vma)\r\n{\r\nreturn !!(vma->vm_flags & (VM_IO | VM_PFNMAP));\r\n}\r\nstatic void *vb2_dma_sg_get_userptr(void *alloc_ctx, unsigned long vaddr,\r\nunsigned long size, int write)\r\n{\r\nstruct vb2_dma_sg_buf *buf;\r\nunsigned long first, last;\r\nint num_pages_from_user;\r\nstruct vm_area_struct *vma;\r\nbuf = kzalloc(sizeof *buf, GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->vaddr = NULL;\r\nbuf->write = write;\r\nbuf->offset = vaddr & ~PAGE_MASK;\r\nbuf->size = size;\r\nfirst = (vaddr & PAGE_MASK) >> PAGE_SHIFT;\r\nlast = ((vaddr + size - 1) & PAGE_MASK) >> PAGE_SHIFT;\r\nbuf->num_pages = last - first + 1;\r\nbuf->pages = kzalloc(buf->num_pages * sizeof(struct page *),\r\nGFP_KERNEL);\r\nif (!buf->pages)\r\ngoto userptr_fail_alloc_pages;\r\nvma = find_vma(current->mm, vaddr);\r\nif (!vma) {\r\ndprintk(1, "no vma for address %lu\n", vaddr);\r\ngoto userptr_fail_find_vma;\r\n}\r\nif (vma->vm_end < vaddr + size) {\r\ndprintk(1, "vma at %lu is too small for %lu bytes\n",\r\nvaddr, size);\r\ngoto userptr_fail_find_vma;\r\n}\r\nbuf->vma = vb2_get_vma(vma);\r\nif (!buf->vma) {\r\ndprintk(1, "failed to copy vma\n");\r\ngoto userptr_fail_find_vma;\r\n}\r\nif (vma_is_io(buf->vma)) {\r\nfor (num_pages_from_user = 0;\r\nnum_pages_from_user < buf->num_pages;\r\n++num_pages_from_user, vaddr += PAGE_SIZE) {\r\nunsigned long pfn;\r\nif (follow_pfn(vma, vaddr, &pfn)) {\r\ndprintk(1, "no page for address %lu\n", vaddr);\r\nbreak;\r\n}\r\nbuf->pages[num_pages_from_user] = pfn_to_page(pfn);\r\n}\r\n} else\r\nnum_pages_from_user = get_user_pages(current, current->mm,\r\nvaddr & PAGE_MASK,\r\nbuf->num_pages,\r\nwrite,\r\n1,\r\nbuf->pages,\r\nNULL);\r\nif (num_pages_from_user != buf->num_pages)\r\ngoto userptr_fail_get_user_pages;\r\nif (sg_alloc_table_from_pages(&buf->sg_table, buf->pages,\r\nbuf->num_pages, buf->offset, size, 0))\r\ngoto userptr_fail_alloc_table_from_pages;\r\nreturn buf;\r\nuserptr_fail_alloc_table_from_pages:\r\nuserptr_fail_get_user_pages:\r\ndprintk(1, "get_user_pages requested/got: %d/%d]\n",\r\nbuf->num_pages, num_pages_from_user);\r\nif (!vma_is_io(buf->vma))\r\nwhile (--num_pages_from_user >= 0)\r\nput_page(buf->pages[num_pages_from_user]);\r\nvb2_put_vma(buf->vma);\r\nuserptr_fail_find_vma:\r\nkfree(buf->pages);\r\nuserptr_fail_alloc_pages:\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nstatic void vb2_dma_sg_put_userptr(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nint i = buf->num_pages;\r\ndprintk(1, "%s: Releasing userspace buffer of %d pages\n",\r\n__func__, buf->num_pages);\r\nif (buf->vaddr)\r\nvm_unmap_ram(buf->vaddr, buf->num_pages);\r\nsg_free_table(&buf->sg_table);\r\nwhile (--i >= 0) {\r\nif (buf->write)\r\nset_page_dirty_lock(buf->pages[i]);\r\nif (!vma_is_io(buf->vma))\r\nput_page(buf->pages[i]);\r\n}\r\nkfree(buf->pages);\r\nvb2_put_vma(buf->vma);\r\nkfree(buf);\r\n}\r\nstatic void *vb2_dma_sg_vaddr(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nBUG_ON(!buf);\r\nif (!buf->vaddr)\r\nbuf->vaddr = vm_map_ram(buf->pages,\r\nbuf->num_pages,\r\n-1,\r\nPAGE_KERNEL);\r\nreturn buf->vaddr + buf->offset;\r\n}\r\nstatic unsigned int vb2_dma_sg_num_users(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nreturn atomic_read(&buf->refcount);\r\n}\r\nstatic int vb2_dma_sg_mmap(void *buf_priv, struct vm_area_struct *vma)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nunsigned long uaddr = vma->vm_start;\r\nunsigned long usize = vma->vm_end - vma->vm_start;\r\nint i = 0;\r\nif (!buf) {\r\nprintk(KERN_ERR "No memory to map\n");\r\nreturn -EINVAL;\r\n}\r\ndo {\r\nint ret;\r\nret = vm_insert_page(vma, uaddr, buf->pages[i++]);\r\nif (ret) {\r\nprintk(KERN_ERR "Remapping memory, error: %d\n", ret);\r\nreturn ret;\r\n}\r\nuaddr += PAGE_SIZE;\r\nusize -= PAGE_SIZE;\r\n} while (usize > 0);\r\nvma->vm_private_data = &buf->handler;\r\nvma->vm_ops = &vb2_common_vm_ops;\r\nvma->vm_ops->open(vma);\r\nreturn 0;\r\n}\r\nstatic void *vb2_dma_sg_cookie(void *buf_priv)\r\n{\r\nstruct vb2_dma_sg_buf *buf = buf_priv;\r\nreturn &buf->sg_table;\r\n}
