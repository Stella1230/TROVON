static inline int intid2obj(unsigned int intid)\r\n{\r\nif (intid == 2)\r\nreturn 0;\r\nelse\r\nreturn MSGOBJ_LAST + 2 - intid;\r\n}\r\nstatic void enable_all_objs(const struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nu8 msgcfg;\r\nunsigned char obj_flags;\r\nunsigned int o, mo;\r\nfor (o = 0; o < ARRAY_SIZE(priv->obj_flags); o++) {\r\nobj_flags = priv->obj_flags[o];\r\nmo = obj2msgobj(o);\r\nif (obj_flags & CC770_OBJ_FLAG_RX) {\r\nif (priv->control_normal_mode & CTRL_EAF) {\r\nif (o > 0)\r\ncontinue;\r\nnetdev_dbg(dev, "Message object %d for "\r\n"RX data, RTR, SFF and EFF\n", mo);\r\n} else {\r\nnetdev_dbg(dev,\r\n"Message object %d for RX %s %s\n",\r\nmo, obj_flags & CC770_OBJ_FLAG_RTR ?\r\n"RTR" : "data",\r\nobj_flags & CC770_OBJ_FLAG_EFF ?\r\n"EFF" : "SFF");\r\n}\r\nif (obj_flags & CC770_OBJ_FLAG_EFF)\r\nmsgcfg = MSGCFG_XTD;\r\nelse\r\nmsgcfg = 0;\r\nif (obj_flags & CC770_OBJ_FLAG_RTR)\r\nmsgcfg |= MSGCFG_DIR;\r\ncc770_write_reg(priv, msgobj[mo].config, msgcfg);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_SET | TXIE_RES |\r\nRXIE_SET | INTPND_RES);\r\nif (obj_flags & CC770_OBJ_FLAG_RTR)\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nNEWDAT_RES | CPUUPD_SET |\r\nTXRQST_RES | RMTPND_RES);\r\nelse\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nNEWDAT_RES | MSGLST_RES |\r\nTXRQST_RES | RMTPND_RES);\r\n} else {\r\nnetdev_dbg(dev, "Message object %d for "\r\n"TX data, RTR, SFF and EFF\n", mo);\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nRMTPND_RES | TXRQST_RES |\r\nCPUUPD_RES | NEWDAT_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_RES | TXIE_RES |\r\nRXIE_RES | INTPND_RES);\r\n}\r\n}\r\n}\r\nstatic void disable_all_objs(const struct cc770_priv *priv)\r\n{\r\nint o, mo;\r\nfor (o = 0; o < ARRAY_SIZE(priv->obj_flags); o++) {\r\nmo = obj2msgobj(o);\r\nif (priv->obj_flags[o] & CC770_OBJ_FLAG_RX) {\r\nif (o > 0 && priv->control_normal_mode & CTRL_EAF)\r\ncontinue;\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nNEWDAT_RES | MSGLST_RES |\r\nTXRQST_RES | RMTPND_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_RES | TXIE_RES |\r\nRXIE_RES | INTPND_RES);\r\n} else {\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nRMTPND_RES | TXRQST_RES |\r\nCPUUPD_RES | NEWDAT_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_RES | TXIE_RES |\r\nRXIE_RES | INTPND_RES);\r\n}\r\n}\r\n}\r\nstatic void set_reset_mode(struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\ncc770_write_reg(priv, control, CTRL_CCE | CTRL_INI);\r\npriv->can.state = CAN_STATE_STOPPED;\r\ncc770_read_reg(priv, interrupt);\r\ncc770_write_reg(priv, status, 0);\r\ndisable_all_objs(priv);\r\n}\r\nstatic void set_normal_mode(struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\ncc770_read_reg(priv, interrupt);\r\ncc770_write_reg(priv, status, STAT_LEC_MASK);\r\nenable_all_objs(dev);\r\ncc770_write_reg(priv, control, priv->control_normal_mode);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nstatic void chipset_init(struct cc770_priv *priv)\r\n{\r\nint mo, id, data;\r\ncc770_write_reg(priv, control, (CTRL_CCE | CTRL_INI));\r\ncc770_write_reg(priv, clkout, priv->clkout);\r\ncc770_write_reg(priv, cpu_interface, priv->cpu_interface);\r\ncc770_write_reg(priv, bus_config, priv->bus_config);\r\ncc770_read_reg(priv, interrupt);\r\ncc770_write_reg(priv, status, 0);\r\nfor (mo = MSGOBJ_FIRST; mo <= MSGOBJ_LAST; mo++) {\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nINTPND_UNC | RXIE_RES |\r\nTXIE_RES | MSGVAL_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nINTPND_RES | RXIE_RES |\r\nTXIE_RES | MSGVAL_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nNEWDAT_RES | MSGLST_RES |\r\nTXRQST_RES | RMTPND_RES);\r\nfor (data = 0; data < 8; data++)\r\ncc770_write_reg(priv, msgobj[mo].data[data], 0);\r\nfor (id = 0; id < 4; id++)\r\ncc770_write_reg(priv, msgobj[mo].id[id], 0);\r\ncc770_write_reg(priv, msgobj[mo].config, 0);\r\n}\r\ncc770_write_reg(priv, global_mask_std[0], 0);\r\ncc770_write_reg(priv, global_mask_std[1], 0);\r\ncc770_write_reg(priv, global_mask_ext[0], 0);\r\ncc770_write_reg(priv, global_mask_ext[1], 0);\r\ncc770_write_reg(priv, global_mask_ext[2], 0);\r\ncc770_write_reg(priv, global_mask_ext[3], 0);\r\n}\r\nstatic int cc770_probe_chip(struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\ncc770_write_reg(priv, control, CTRL_CCE | CTRL_EAF | CTRL_INI);\r\ncc770_write_reg(priv, cpu_interface, priv->cpu_interface);\r\nif (cc770_read_reg(priv, cpu_interface) & CPUIF_RST) {\r\nnetdev_info(dev, "probing @0x%p failed (reset)\n",\r\npriv->reg_base);\r\nreturn -ENODEV;\r\n}\r\ncc770_write_reg(priv, msgobj[1].data[1], 0x25);\r\ncc770_write_reg(priv, msgobj[2].data[3], 0x52);\r\ncc770_write_reg(priv, msgobj[10].data[6], 0xc3);\r\nif ((cc770_read_reg(priv, msgobj[1].data[1]) != 0x25) ||\r\n(cc770_read_reg(priv, msgobj[2].data[3]) != 0x52) ||\r\n(cc770_read_reg(priv, msgobj[10].data[6]) != 0xc3)) {\r\nnetdev_info(dev, "probing @0x%p failed (pattern)\n",\r\npriv->reg_base);\r\nreturn -ENODEV;\r\n}\r\nif (cc770_read_reg(priv, control) & CTRL_EAF)\r\npriv->control_normal_mode |= CTRL_EAF;\r\nreturn 0;\r\n}\r\nstatic void cc770_start(struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nif (priv->can.state != CAN_STATE_STOPPED)\r\nset_reset_mode(dev);\r\nset_normal_mode(dev);\r\n}\r\nstatic int cc770_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\ncc770_start(dev);\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cc770_set_bittiming(struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nu8 btr0, btr1;\r\nbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\r\nbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\r\n(((bt->phase_seg2 - 1) & 0x7) << 4);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nbtr1 |= 0x80;\r\nnetdev_info(dev, "setting BTR0=0x%02x BTR1=0x%02x\n", btr0, btr1);\r\ncc770_write_reg(priv, bit_timing_0, btr0);\r\ncc770_write_reg(priv, bit_timing_1, btr1);\r\nreturn 0;\r\n}\r\nstatic int cc770_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nbec->txerr = cc770_read_reg(priv, tx_error_counter);\r\nbec->rxerr = cc770_read_reg(priv, rx_error_counter);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t cc770_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nunsigned int mo = obj2msgobj(CC770_OBJ_TX);\r\nu8 dlc, rtr;\r\nu32 id;\r\nint i;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nif ((cc770_read_reg(priv,\r\nmsgobj[mo].ctrl1) & TXRQST_UNC) == TXRQST_SET) {\r\nnetdev_err(dev, "TX register is still occupied!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nnetif_stop_queue(dev);\r\ndlc = cf->can_dlc;\r\nid = cf->can_id;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nrtr = 0;\r\nelse\r\nrtr = MSGCFG_DIR;\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nRMTPND_RES | TXRQST_RES | CPUUPD_SET | NEWDAT_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_SET | TXIE_SET | RXIE_RES | INTPND_RES);\r\nif (id & CAN_EFF_FLAG) {\r\nid &= CAN_EFF_MASK;\r\ncc770_write_reg(priv, msgobj[mo].config,\r\n(dlc << 4) | rtr | MSGCFG_XTD);\r\ncc770_write_reg(priv, msgobj[mo].id[3], id << 3);\r\ncc770_write_reg(priv, msgobj[mo].id[2], id >> 5);\r\ncc770_write_reg(priv, msgobj[mo].id[1], id >> 13);\r\ncc770_write_reg(priv, msgobj[mo].id[0], id >> 21);\r\n} else {\r\nid &= CAN_SFF_MASK;\r\ncc770_write_reg(priv, msgobj[mo].config, (dlc << 4) | rtr);\r\ncc770_write_reg(priv, msgobj[mo].id[0], id >> 3);\r\ncc770_write_reg(priv, msgobj[mo].id[1], id << 5);\r\n}\r\nfor (i = 0; i < dlc; i++)\r\ncc770_write_reg(priv, msgobj[mo].data[i], cf->data[i]);\r\ncan_put_echo_skb(skb, dev, 0);\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nRMTPND_RES | TXRQST_SET | CPUUPD_RES | NEWDAT_UNC);\r\nstats->tx_bytes += dlc;\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_UNC | TXIE_UNC | RXIE_UNC | INTPND_RES);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void cc770_rx(struct net_device *dev, unsigned int mo, u8 ctrl1)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu8 config;\r\nu32 id;\r\nint i;\r\nskb = alloc_can_skb(dev, &cf);\r\nif (!skb)\r\nreturn;\r\nconfig = cc770_read_reg(priv, msgobj[mo].config);\r\nif (ctrl1 & RMTPND_SET) {\r\ncf->can_id = CAN_RTR_FLAG;\r\nif (config & MSGCFG_XTD)\r\ncf->can_id |= CAN_EFF_FLAG;\r\ncf->can_dlc = 0;\r\n} else {\r\nif (config & MSGCFG_XTD) {\r\nid = cc770_read_reg(priv, msgobj[mo].id[3]);\r\nid |= cc770_read_reg(priv, msgobj[mo].id[2]) << 8;\r\nid |= cc770_read_reg(priv, msgobj[mo].id[1]) << 16;\r\nid |= cc770_read_reg(priv, msgobj[mo].id[0]) << 24;\r\nid >>= 3;\r\nid |= CAN_EFF_FLAG;\r\n} else {\r\nid = cc770_read_reg(priv, msgobj[mo].id[1]);\r\nid |= cc770_read_reg(priv, msgobj[mo].id[0]) << 8;\r\nid >>= 5;\r\n}\r\ncf->can_id = id;\r\ncf->can_dlc = get_can_dlc((config & 0xf0) >> 4);\r\nfor (i = 0; i < cf->can_dlc; i++)\r\ncf->data[i] = cc770_read_reg(priv, msgobj[mo].data[i]);\r\n}\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\nstatic int cc770_err(struct net_device *dev, u8 status)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nu8 lec;\r\nnetdev_dbg(dev, "status interrupt (%#x)\n", status);\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (priv->control_normal_mode & CTRL_EAF) {\r\ncf->data[6] = cc770_read_reg(priv, tx_error_counter);\r\ncf->data[7] = cc770_read_reg(priv, rx_error_counter);\r\n}\r\nif (status & STAT_BOFF) {\r\ncc770_write_reg(priv, control, CTRL_INI);\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\npriv->can.state = CAN_STATE_BUS_OFF;\r\ncan_bus_off(dev);\r\n} else if (status & STAT_WARN) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (cf->data[7] > 127) {\r\ncf->data[1] = CAN_ERR_CRTL_RX_PASSIVE |\r\nCAN_ERR_CRTL_TX_PASSIVE;\r\npriv->can.state = CAN_STATE_ERROR_PASSIVE;\r\npriv->can.can_stats.error_passive++;\r\n} else {\r\ncf->data[1] = CAN_ERR_CRTL_RX_WARNING |\r\nCAN_ERR_CRTL_TX_WARNING;\r\npriv->can.state = CAN_STATE_ERROR_WARNING;\r\npriv->can.can_stats.error_warning++;\r\n}\r\n} else {\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_ACTIVE;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nlec = status & STAT_LEC_MASK;\r\nif (lec < 7 && lec > 0) {\r\nif (lec == STAT_LEC_ACK) {\r\ncf->can_id |= CAN_ERR_ACK;\r\n} else {\r\ncf->can_id |= CAN_ERR_PROT;\r\nswitch (lec) {\r\ncase STAT_LEC_STUFF:\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ncase STAT_LEC_FORM:\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase STAT_LEC_BIT1:\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\nbreak;\r\ncase STAT_LEC_BIT0:\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\nbreak;\r\ncase STAT_LEC_CRC:\r\ncf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;\r\nbreak;\r\n}\r\n}\r\n}\r\nnetif_rx(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nreturn 0;\r\n}\r\nstatic int cc770_status_interrupt(struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nu8 status;\r\nstatus = cc770_read_reg(priv, status);\r\ncc770_write_reg(priv, status, STAT_LEC_MASK);\r\nif (status & (STAT_WARN | STAT_BOFF) ||\r\n(status & STAT_LEC_MASK) != STAT_LEC_MASK) {\r\ncc770_err(dev, status);\r\nreturn status & STAT_BOFF;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cc770_rx_interrupt(struct net_device *dev, unsigned int o)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nunsigned int mo = obj2msgobj(o);\r\nu8 ctrl1;\r\nint n = CC770_MAX_MSG;\r\nwhile (n--) {\r\nctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);\r\nif (!(ctrl1 & NEWDAT_SET)) {\r\nif (priv->control_normal_mode & CTRL_EAF) {\r\nif (!(cc770_read_reg(priv, msgobj[mo].ctrl0) &\r\nINTPND_SET))\r\nbreak;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (ctrl1 & MSGLST_SET) {\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\n}\r\nif (mo < MSGOBJ_LAST)\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nNEWDAT_RES | MSGLST_RES |\r\nTXRQST_UNC | RMTPND_UNC);\r\ncc770_rx(dev, mo, ctrl1);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_SET | TXIE_RES |\r\nRXIE_SET | INTPND_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nNEWDAT_RES | MSGLST_RES |\r\nTXRQST_RES | RMTPND_RES);\r\n}\r\n}\r\nstatic void cc770_rtr_interrupt(struct net_device *dev, unsigned int o)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nunsigned int mo = obj2msgobj(o);\r\nu8 ctrl0, ctrl1;\r\nint n = CC770_MAX_MSG;\r\nwhile (n--) {\r\nctrl0 = cc770_read_reg(priv, msgobj[mo].ctrl0);\r\nif (!(ctrl0 & INTPND_SET))\r\nbreak;\r\nctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);\r\ncc770_rx(dev, mo, ctrl1);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_SET | TXIE_RES |\r\nRXIE_SET | INTPND_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl1,\r\nNEWDAT_RES | CPUUPD_SET |\r\nTXRQST_RES | RMTPND_RES);\r\n}\r\n}\r\nstatic void cc770_tx_interrupt(struct net_device *dev, unsigned int o)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nunsigned int mo = obj2msgobj(o);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_RES | TXIE_RES | RXIE_RES | INTPND_RES);\r\ncc770_write_reg(priv, msgobj[mo].ctrl0,\r\nMSGVAL_UNC | TXIE_UNC | RXIE_UNC | INTPND_RES);\r\nstats->tx_packets++;\r\ncan_get_echo_skb(dev, 0);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic irqreturn_t cc770_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nu8 intid;\r\nint o, n = 0;\r\nif (priv->can.state == CAN_STATE_STOPPED)\r\nreturn IRQ_NONE;\r\nif (priv->pre_irq)\r\npriv->pre_irq(priv);\r\nwhile (n < CC770_MAX_IRQ) {\r\nintid = cc770_read_reg(priv, interrupt);\r\nif (!intid)\r\nbreak;\r\nn++;\r\nif (intid == 1) {\r\nif (cc770_status_interrupt(dev))\r\nbreak;\r\n} else {\r\no = intid2obj(intid);\r\nif (o >= CC770_OBJ_MAX) {\r\nnetdev_err(dev, "Unexpected interrupt id %d\n",\r\nintid);\r\ncontinue;\r\n}\r\nif (priv->obj_flags[o] & CC770_OBJ_FLAG_RTR)\r\ncc770_rtr_interrupt(dev, o);\r\nelse if (priv->obj_flags[o] & CC770_OBJ_FLAG_RX)\r\ncc770_rx_interrupt(dev, o);\r\nelse\r\ncc770_tx_interrupt(dev, o);\r\n}\r\n}\r\nif (priv->post_irq)\r\npriv->post_irq(priv);\r\nif (n >= CC770_MAX_IRQ)\r\nnetdev_dbg(dev, "%d messages handled in ISR", n);\r\nreturn (n) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int cc770_open(struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nint err;\r\nset_reset_mode(dev);\r\nerr = open_candev(dev);\r\nif (err)\r\nreturn err;\r\nerr = request_irq(dev->irq, &cc770_interrupt, priv->irq_flags,\r\ndev->name, dev);\r\nif (err) {\r\nclose_candev(dev);\r\nreturn -EAGAIN;\r\n}\r\ncc770_start(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int cc770_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nset_reset_mode(dev);\r\nfree_irq(dev->irq, dev);\r\nclose_candev(dev);\r\nreturn 0;\r\n}\r\nstruct net_device *alloc_cc770dev(int sizeof_priv)\r\n{\r\nstruct net_device *dev;\r\nstruct cc770_priv *priv;\r\ndev = alloc_candev(sizeof(struct cc770_priv) + sizeof_priv,\r\nCC770_ECHO_SKB_MAX);\r\nif (!dev)\r\nreturn NULL;\r\npriv = netdev_priv(dev);\r\npriv->dev = dev;\r\npriv->can.bittiming_const = &cc770_bittiming_const;\r\npriv->can.do_set_bittiming = cc770_set_bittiming;\r\npriv->can.do_set_mode = cc770_set_mode;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\nmemcpy(priv->obj_flags, cc770_obj_flags, sizeof(cc770_obj_flags));\r\nif (sizeof_priv)\r\npriv->priv = (void *)priv + sizeof(struct cc770_priv);\r\nreturn dev;\r\n}\r\nvoid free_cc770dev(struct net_device *dev)\r\n{\r\nfree_candev(dev);\r\n}\r\nint register_cc770dev(struct net_device *dev)\r\n{\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = cc770_probe_chip(dev);\r\nif (err)\r\nreturn err;\r\ndev->netdev_ops = &cc770_netdev_ops;\r\ndev->flags |= IFF_ECHO;\r\nif (!i82527_compat && priv->control_normal_mode & CTRL_EAF) {\r\npriv->can.do_get_berr_counter = cc770_get_berr_counter;\r\npriv->control_normal_mode = CTRL_IE | CTRL_EAF | CTRL_EIE;\r\nnetdev_dbg(dev, "i82527 mode with additional functions\n");\r\n} else {\r\npriv->control_normal_mode = CTRL_IE | CTRL_EIE;\r\nnetdev_dbg(dev, "strict i82527 compatibility mode\n");\r\n}\r\nchipset_init(priv);\r\nset_reset_mode(dev);\r\nreturn register_candev(dev);\r\n}\r\nvoid unregister_cc770dev(struct net_device *dev)\r\n{\r\nset_reset_mode(dev);\r\nunregister_candev(dev);\r\n}\r\nstatic __init int cc770_init(void)\r\n{\r\nif (msgobj15_eff) {\r\ncc770_obj_flags[CC770_OBJ_RX0] |= CC770_OBJ_FLAG_EFF;\r\ncc770_obj_flags[CC770_OBJ_RX1] &= ~CC770_OBJ_FLAG_EFF;\r\n}\r\npr_info("CAN netdevice driver\n");\r\nreturn 0;\r\n}\r\nstatic __exit void cc770_exit(void)\r\n{\r\npr_info("driver removed\n");\r\n}
