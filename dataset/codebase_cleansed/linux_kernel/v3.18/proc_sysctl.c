void proc_sys_poll_notify(struct ctl_table_poll *poll)\r\n{\r\nif (!poll)\r\nreturn;\r\natomic_inc(&poll->event);\r\nwake_up_interruptible(&poll->wait);\r\n}\r\nstatic void sysctl_print_dir(struct ctl_dir *dir)\r\n{\r\nif (dir->header.parent)\r\nsysctl_print_dir(dir->header.parent);\r\npr_cont("%s/", dir->header.ctl_table[0].procname);\r\n}\r\nstatic int namecmp(const char *name1, int len1, const char *name2, int len2)\r\n{\r\nint minlen;\r\nint cmp;\r\nminlen = len1;\r\nif (minlen > len2)\r\nminlen = len2;\r\ncmp = memcmp(name1, name2, minlen);\r\nif (cmp == 0)\r\ncmp = len1 - len2;\r\nreturn cmp;\r\n}\r\nstatic struct ctl_table *find_entry(struct ctl_table_header **phead,\r\nstruct ctl_dir *dir, const char *name, int namelen)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct ctl_table *entry;\r\nstruct rb_node *node = dir->root.rb_node;\r\nwhile (node)\r\n{\r\nstruct ctl_node *ctl_node;\r\nconst char *procname;\r\nint cmp;\r\nctl_node = rb_entry(node, struct ctl_node, node);\r\nhead = ctl_node->header;\r\nentry = &head->ctl_table[ctl_node - head->node];\r\nprocname = entry->procname;\r\ncmp = namecmp(name, namelen, procname, strlen(procname));\r\nif (cmp < 0)\r\nnode = node->rb_left;\r\nelse if (cmp > 0)\r\nnode = node->rb_right;\r\nelse {\r\n*phead = head;\r\nreturn entry;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int insert_entry(struct ctl_table_header *head, struct ctl_table *entry)\r\n{\r\nstruct rb_node *node = &head->node[entry - head->ctl_table].node;\r\nstruct rb_node **p = &head->parent->root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nconst char *name = entry->procname;\r\nint namelen = strlen(name);\r\nwhile (*p) {\r\nstruct ctl_table_header *parent_head;\r\nstruct ctl_table *parent_entry;\r\nstruct ctl_node *parent_node;\r\nconst char *parent_name;\r\nint cmp;\r\nparent = *p;\r\nparent_node = rb_entry(parent, struct ctl_node, node);\r\nparent_head = parent_node->header;\r\nparent_entry = &parent_head->ctl_table[parent_node - parent_head->node];\r\nparent_name = parent_entry->procname;\r\ncmp = namecmp(name, namelen, parent_name, strlen(parent_name));\r\nif (cmp < 0)\r\np = &(*p)->rb_left;\r\nelse if (cmp > 0)\r\np = &(*p)->rb_right;\r\nelse {\r\npr_err("sysctl duplicate entry: ");\r\nsysctl_print_dir(head->parent);\r\npr_cont("/%s\n", entry->procname);\r\nreturn -EEXIST;\r\n}\r\n}\r\nrb_link_node(node, parent, p);\r\nrb_insert_color(node, &head->parent->root);\r\nreturn 0;\r\n}\r\nstatic void erase_entry(struct ctl_table_header *head, struct ctl_table *entry)\r\n{\r\nstruct rb_node *node = &head->node[entry - head->ctl_table].node;\r\nrb_erase(node, &head->parent->root);\r\n}\r\nstatic void init_header(struct ctl_table_header *head,\r\nstruct ctl_table_root *root, struct ctl_table_set *set,\r\nstruct ctl_node *node, struct ctl_table *table)\r\n{\r\nhead->ctl_table = table;\r\nhead->ctl_table_arg = table;\r\nhead->used = 0;\r\nhead->count = 1;\r\nhead->nreg = 1;\r\nhead->unregistering = NULL;\r\nhead->root = root;\r\nhead->set = set;\r\nhead->parent = NULL;\r\nhead->node = node;\r\nif (node) {\r\nstruct ctl_table *entry;\r\nfor (entry = table; entry->procname; entry++, node++)\r\nnode->header = head;\r\n}\r\n}\r\nstatic void erase_header(struct ctl_table_header *head)\r\n{\r\nstruct ctl_table *entry;\r\nfor (entry = head->ctl_table; entry->procname; entry++)\r\nerase_entry(head, entry);\r\n}\r\nstatic int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\r\n{\r\nstruct ctl_table *entry;\r\nint err;\r\ndir->header.nreg++;\r\nheader->parent = dir;\r\nerr = insert_links(header);\r\nif (err)\r\ngoto fail_links;\r\nfor (entry = header->ctl_table; entry->procname; entry++) {\r\nerr = insert_entry(header, entry);\r\nif (err)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nerase_header(header);\r\nput_links(header);\r\nfail_links:\r\nheader->parent = NULL;\r\ndrop_sysctl_table(&dir->header);\r\nreturn err;\r\n}\r\nstatic int use_table(struct ctl_table_header *p)\r\n{\r\nif (unlikely(p->unregistering))\r\nreturn 0;\r\np->used++;\r\nreturn 1;\r\n}\r\nstatic void unuse_table(struct ctl_table_header *p)\r\n{\r\nif (!--p->used)\r\nif (unlikely(p->unregistering))\r\ncomplete(p->unregistering);\r\n}\r\nstatic void start_unregistering(struct ctl_table_header *p)\r\n{\r\nif (unlikely(p->used)) {\r\nstruct completion wait;\r\ninit_completion(&wait);\r\np->unregistering = &wait;\r\nspin_unlock(&sysctl_lock);\r\nwait_for_completion(&wait);\r\nspin_lock(&sysctl_lock);\r\n} else {\r\np->unregistering = ERR_PTR(-EINVAL);\r\n}\r\nerase_header(p);\r\n}\r\nstatic void sysctl_head_get(struct ctl_table_header *head)\r\n{\r\nspin_lock(&sysctl_lock);\r\nhead->count++;\r\nspin_unlock(&sysctl_lock);\r\n}\r\nvoid sysctl_head_put(struct ctl_table_header *head)\r\n{\r\nspin_lock(&sysctl_lock);\r\nif (!--head->count)\r\nkfree_rcu(head, rcu);\r\nspin_unlock(&sysctl_lock);\r\n}\r\nstatic struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\r\n{\r\nBUG_ON(!head);\r\nspin_lock(&sysctl_lock);\r\nif (!use_table(head))\r\nhead = ERR_PTR(-ENOENT);\r\nspin_unlock(&sysctl_lock);\r\nreturn head;\r\n}\r\nstatic void sysctl_head_finish(struct ctl_table_header *head)\r\n{\r\nif (!head)\r\nreturn;\r\nspin_lock(&sysctl_lock);\r\nunuse_table(head);\r\nspin_unlock(&sysctl_lock);\r\n}\r\nstatic struct ctl_table_set *\r\nlookup_header_set(struct ctl_table_root *root, struct nsproxy *namespaces)\r\n{\r\nstruct ctl_table_set *set = &root->default_set;\r\nif (root->lookup)\r\nset = root->lookup(root, namespaces);\r\nreturn set;\r\n}\r\nstatic struct ctl_table *lookup_entry(struct ctl_table_header **phead,\r\nstruct ctl_dir *dir,\r\nconst char *name, int namelen)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct ctl_table *entry;\r\nspin_lock(&sysctl_lock);\r\nentry = find_entry(&head, dir, name, namelen);\r\nif (entry && use_table(head))\r\n*phead = head;\r\nelse\r\nentry = NULL;\r\nspin_unlock(&sysctl_lock);\r\nreturn entry;\r\n}\r\nstatic struct ctl_node *first_usable_entry(struct rb_node *node)\r\n{\r\nstruct ctl_node *ctl_node;\r\nfor (;node; node = rb_next(node)) {\r\nctl_node = rb_entry(node, struct ctl_node, node);\r\nif (use_table(ctl_node->header))\r\nreturn ctl_node;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void first_entry(struct ctl_dir *dir,\r\nstruct ctl_table_header **phead, struct ctl_table **pentry)\r\n{\r\nstruct ctl_table_header *head = NULL;\r\nstruct ctl_table *entry = NULL;\r\nstruct ctl_node *ctl_node;\r\nspin_lock(&sysctl_lock);\r\nctl_node = first_usable_entry(rb_first(&dir->root));\r\nspin_unlock(&sysctl_lock);\r\nif (ctl_node) {\r\nhead = ctl_node->header;\r\nentry = &head->ctl_table[ctl_node - head->node];\r\n}\r\n*phead = head;\r\n*pentry = entry;\r\n}\r\nstatic void next_entry(struct ctl_table_header **phead, struct ctl_table **pentry)\r\n{\r\nstruct ctl_table_header *head = *phead;\r\nstruct ctl_table *entry = *pentry;\r\nstruct ctl_node *ctl_node = &head->node[entry - head->ctl_table];\r\nspin_lock(&sysctl_lock);\r\nunuse_table(head);\r\nctl_node = first_usable_entry(rb_next(&ctl_node->node));\r\nspin_unlock(&sysctl_lock);\r\nhead = NULL;\r\nif (ctl_node) {\r\nhead = ctl_node->header;\r\nentry = &head->ctl_table[ctl_node - head->node];\r\n}\r\n*phead = head;\r\n*pentry = entry;\r\n}\r\nvoid register_sysctl_root(struct ctl_table_root *root)\r\n{\r\n}\r\nstatic int test_perm(int mode, int op)\r\n{\r\nif (uid_eq(current_euid(), GLOBAL_ROOT_UID))\r\nmode >>= 6;\r\nelse if (in_egroup_p(GLOBAL_ROOT_GID))\r\nmode >>= 3;\r\nif ((op & ~mode & (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)\r\nreturn 0;\r\nreturn -EACCES;\r\n}\r\nstatic int sysctl_perm(struct ctl_table_header *head, struct ctl_table *table, int op)\r\n{\r\nstruct ctl_table_root *root = head->root;\r\nint mode;\r\nif (root->permissions)\r\nmode = root->permissions(head, table);\r\nelse\r\nmode = table->mode;\r\nreturn test_perm(mode, op);\r\n}\r\nstatic struct inode *proc_sys_make_inode(struct super_block *sb,\r\nstruct ctl_table_header *head, struct ctl_table *table)\r\n{\r\nstruct inode *inode;\r\nstruct proc_inode *ei;\r\ninode = new_inode(sb);\r\nif (!inode)\r\ngoto out;\r\ninode->i_ino = get_next_ino();\r\nsysctl_head_get(head);\r\nei = PROC_I(inode);\r\nei->sysctl = head;\r\nei->sysctl_entry = table;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_mode = table->mode;\r\nif (!S_ISDIR(table->mode)) {\r\ninode->i_mode |= S_IFREG;\r\ninode->i_op = &proc_sys_inode_operations;\r\ninode->i_fop = &proc_sys_file_operations;\r\n} else {\r\ninode->i_mode |= S_IFDIR;\r\ninode->i_op = &proc_sys_dir_operations;\r\ninode->i_fop = &proc_sys_dir_file_operations;\r\n}\r\nout:\r\nreturn inode;\r\n}\r\nstatic struct ctl_table_header *grab_header(struct inode *inode)\r\n{\r\nstruct ctl_table_header *head = PROC_I(inode)->sysctl;\r\nif (!head)\r\nhead = &sysctl_table_root.default_set.dir.header;\r\nreturn sysctl_head_grab(head);\r\n}\r\nstatic struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct ctl_table_header *head = grab_header(dir);\r\nstruct ctl_table_header *h = NULL;\r\nstruct qstr *name = &dentry->d_name;\r\nstruct ctl_table *p;\r\nstruct inode *inode;\r\nstruct dentry *err = ERR_PTR(-ENOENT);\r\nstruct ctl_dir *ctl_dir;\r\nint ret;\r\nif (IS_ERR(head))\r\nreturn ERR_CAST(head);\r\nctl_dir = container_of(head, struct ctl_dir, header);\r\np = lookup_entry(&h, ctl_dir, name->name, name->len);\r\nif (!p)\r\ngoto out;\r\nif (S_ISLNK(p->mode)) {\r\nret = sysctl_follow_link(&h, &p, current->nsproxy);\r\nerr = ERR_PTR(ret);\r\nif (ret)\r\ngoto out;\r\n}\r\nerr = ERR_PTR(-ENOMEM);\r\ninode = proc_sys_make_inode(dir->i_sb, h ? h : head, p);\r\nif (!inode)\r\ngoto out;\r\nerr = NULL;\r\nd_set_d_op(dentry, &proc_sys_dentry_operations);\r\nd_add(dentry, inode);\r\nout:\r\nif (h)\r\nsysctl_head_finish(h);\r\nsysctl_head_finish(head);\r\nreturn err;\r\n}\r\nstatic ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,\r\nsize_t count, loff_t *ppos, int write)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nstruct ctl_table_header *head = grab_header(inode);\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nssize_t error;\r\nsize_t res;\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\nerror = -EPERM;\r\nif (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))\r\ngoto out;\r\nerror = -EINVAL;\r\nif (!table->proc_handler)\r\ngoto out;\r\nres = count;\r\nerror = table->proc_handler(table, write, buf, &res, ppos);\r\nif (!error)\r\nerror = res;\r\nout:\r\nsysctl_head_finish(head);\r\nreturn error;\r\n}\r\nstatic ssize_t proc_sys_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 0);\r\n}\r\nstatic ssize_t proc_sys_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 1);\r\n}\r\nstatic int proc_sys_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct ctl_table_header *head = grab_header(inode);\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\nif (table->poll)\r\nfilp->private_data = proc_sys_poll_event(table->poll);\r\nsysctl_head_finish(head);\r\nreturn 0;\r\n}\r\nstatic unsigned int proc_sys_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nstruct ctl_table_header *head = grab_header(inode);\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nunsigned int ret = DEFAULT_POLLMASK;\r\nunsigned long event;\r\nif (IS_ERR(head))\r\nreturn POLLERR | POLLHUP;\r\nif (!table->proc_handler)\r\ngoto out;\r\nif (!table->poll)\r\ngoto out;\r\nevent = (unsigned long)filp->private_data;\r\npoll_wait(filp, &table->poll->wait, wait);\r\nif (event != atomic_read(&table->poll->event)) {\r\nfilp->private_data = proc_sys_poll_event(table->poll);\r\nret = POLLIN | POLLRDNORM | POLLERR | POLLPRI;\r\n}\r\nout:\r\nsysctl_head_finish(head);\r\nreturn ret;\r\n}\r\nstatic bool proc_sys_fill_cache(struct file *file,\r\nstruct dir_context *ctx,\r\nstruct ctl_table_header *head,\r\nstruct ctl_table *table)\r\n{\r\nstruct dentry *child, *dir = file->f_path.dentry;\r\nstruct inode *inode;\r\nstruct qstr qname;\r\nino_t ino = 0;\r\nunsigned type = DT_UNKNOWN;\r\nqname.name = table->procname;\r\nqname.len = strlen(table->procname);\r\nqname.hash = full_name_hash(qname.name, qname.len);\r\nchild = d_lookup(dir, &qname);\r\nif (!child) {\r\nchild = d_alloc(dir, &qname);\r\nif (child) {\r\ninode = proc_sys_make_inode(dir->d_sb, head, table);\r\nif (!inode) {\r\ndput(child);\r\nreturn false;\r\n} else {\r\nd_set_d_op(child, &proc_sys_dentry_operations);\r\nd_add(child, inode);\r\n}\r\n} else {\r\nreturn false;\r\n}\r\n}\r\ninode = child->d_inode;\r\nino = inode->i_ino;\r\ntype = inode->i_mode >> 12;\r\ndput(child);\r\nreturn dir_emit(ctx, qname.name, qname.len, ino, type);\r\n}\r\nstatic bool proc_sys_link_fill_cache(struct file *file,\r\nstruct dir_context *ctx,\r\nstruct ctl_table_header *head,\r\nstruct ctl_table *table)\r\n{\r\nbool ret = true;\r\nhead = sysctl_head_grab(head);\r\nif (S_ISLNK(table->mode)) {\r\nint err = sysctl_follow_link(&head, &table, current->nsproxy);\r\nif (err)\r\ngoto out;\r\n}\r\nret = proc_sys_fill_cache(file, ctx, head, table);\r\nout:\r\nsysctl_head_finish(head);\r\nreturn ret;\r\n}\r\nstatic int scan(struct ctl_table_header *head, struct ctl_table *table,\r\nunsigned long *pos, struct file *file,\r\nstruct dir_context *ctx)\r\n{\r\nbool res;\r\nif ((*pos)++ < ctx->pos)\r\nreturn true;\r\nif (unlikely(S_ISLNK(table->mode)))\r\nres = proc_sys_link_fill_cache(file, ctx, head, table);\r\nelse\r\nres = proc_sys_fill_cache(file, ctx, head, table);\r\nif (res)\r\nctx->pos = *pos;\r\nreturn res;\r\n}\r\nstatic int proc_sys_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct ctl_table_header *head = grab_header(file_inode(file));\r\nstruct ctl_table_header *h = NULL;\r\nstruct ctl_table *entry;\r\nstruct ctl_dir *ctl_dir;\r\nunsigned long pos;\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\nctl_dir = container_of(head, struct ctl_dir, header);\r\nif (!dir_emit_dots(file, ctx))\r\nreturn 0;\r\npos = 2;\r\nfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\r\nif (!scan(h, entry, &pos, file, ctx)) {\r\nsysctl_head_finish(h);\r\nbreak;\r\n}\r\n}\r\nsysctl_head_finish(head);\r\nreturn 0;\r\n}\r\nstatic int proc_sys_permission(struct inode *inode, int mask)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct ctl_table *table;\r\nint error;\r\nif ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))\r\nreturn -EACCES;\r\nhead = grab_header(inode);\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\ntable = PROC_I(inode)->sysctl_entry;\r\nif (!table)\r\nerror = mask & MAY_WRITE ? -EACCES : 0;\r\nelse\r\nerror = sysctl_perm(head, table, mask & ~MAY_NOT_BLOCK);\r\nsysctl_head_finish(head);\r\nreturn error;\r\n}\r\nstatic int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nint error;\r\nif (attr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\r\nreturn -EPERM;\r\nerror = inode_change_ok(inode, attr);\r\nif (error)\r\nreturn error;\r\nsetattr_copy(inode, attr);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nstatic int proc_sys_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct ctl_table_header *head = grab_header(inode);\r\nstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\r\nif (IS_ERR(head))\r\nreturn PTR_ERR(head);\r\ngeneric_fillattr(inode, stat);\r\nif (table)\r\nstat->mode = (stat->mode & S_IFMT) | table->mode;\r\nsysctl_head_finish(head);\r\nreturn 0;\r\n}\r\nstatic int proc_sys_revalidate(struct dentry *dentry, unsigned int flags)\r\n{\r\nif (flags & LOOKUP_RCU)\r\nreturn -ECHILD;\r\nreturn !PROC_I(dentry->d_inode)->sysctl->unregistering;\r\n}\r\nstatic int proc_sys_delete(const struct dentry *dentry)\r\n{\r\nreturn !!PROC_I(dentry->d_inode)->sysctl->unregistering;\r\n}\r\nstatic int sysctl_is_seen(struct ctl_table_header *p)\r\n{\r\nstruct ctl_table_set *set = p->set;\r\nint res;\r\nspin_lock(&sysctl_lock);\r\nif (p->unregistering)\r\nres = 0;\r\nelse if (!set->is_seen)\r\nres = 1;\r\nelse\r\nres = set->is_seen(set);\r\nspin_unlock(&sysctl_lock);\r\nreturn res;\r\n}\r\nstatic int proc_sys_compare(const struct dentry *parent, const struct dentry *dentry,\r\nunsigned int len, const char *str, const struct qstr *name)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct inode *inode;\r\ninode = ACCESS_ONCE(dentry->d_inode);\r\nif (!inode)\r\nreturn 1;\r\nif (name->len != len)\r\nreturn 1;\r\nif (memcmp(name->name, str, len))\r\nreturn 1;\r\nhead = rcu_dereference(PROC_I(inode)->sysctl);\r\nreturn !head || !sysctl_is_seen(head);\r\n}\r\nstatic struct ctl_dir *find_subdir(struct ctl_dir *dir,\r\nconst char *name, int namelen)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct ctl_table *entry;\r\nentry = find_entry(&head, dir, name, namelen);\r\nif (!entry)\r\nreturn ERR_PTR(-ENOENT);\r\nif (!S_ISDIR(entry->mode))\r\nreturn ERR_PTR(-ENOTDIR);\r\nreturn container_of(head, struct ctl_dir, header);\r\n}\r\nstatic struct ctl_dir *new_dir(struct ctl_table_set *set,\r\nconst char *name, int namelen)\r\n{\r\nstruct ctl_table *table;\r\nstruct ctl_dir *new;\r\nstruct ctl_node *node;\r\nchar *new_name;\r\nnew = kzalloc(sizeof(*new) + sizeof(struct ctl_node) +\r\nsizeof(struct ctl_table)*2 + namelen + 1,\r\nGFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\nnode = (struct ctl_node *)(new + 1);\r\ntable = (struct ctl_table *)(node + 1);\r\nnew_name = (char *)(table + 2);\r\nmemcpy(new_name, name, namelen);\r\nnew_name[namelen] = '\0';\r\ntable[0].procname = new_name;\r\ntable[0].mode = S_IFDIR|S_IRUGO|S_IXUGO;\r\ninit_header(&new->header, set->dir.header.root, set, node, table);\r\nreturn new;\r\n}\r\nstatic struct ctl_dir *get_subdir(struct ctl_dir *dir,\r\nconst char *name, int namelen)\r\n{\r\nstruct ctl_table_set *set = dir->header.set;\r\nstruct ctl_dir *subdir, *new = NULL;\r\nint err;\r\nspin_lock(&sysctl_lock);\r\nsubdir = find_subdir(dir, name, namelen);\r\nif (!IS_ERR(subdir))\r\ngoto found;\r\nif (PTR_ERR(subdir) != -ENOENT)\r\ngoto failed;\r\nspin_unlock(&sysctl_lock);\r\nnew = new_dir(set, name, namelen);\r\nspin_lock(&sysctl_lock);\r\nsubdir = ERR_PTR(-ENOMEM);\r\nif (!new)\r\ngoto failed;\r\nsubdir = find_subdir(dir, name, namelen);\r\nif (!IS_ERR(subdir))\r\ngoto found;\r\nif (PTR_ERR(subdir) != -ENOENT)\r\ngoto failed;\r\nerr = insert_header(dir, &new->header);\r\nsubdir = ERR_PTR(err);\r\nif (err)\r\ngoto failed;\r\nsubdir = new;\r\nfound:\r\nsubdir->header.nreg++;\r\nfailed:\r\nif (unlikely(IS_ERR(subdir))) {\r\npr_err("sysctl could not get directory: ");\r\nsysctl_print_dir(dir);\r\npr_cont("/%*.*s %ld\n",\r\nnamelen, namelen, name, PTR_ERR(subdir));\r\n}\r\ndrop_sysctl_table(&dir->header);\r\nif (new)\r\ndrop_sysctl_table(&new->header);\r\nspin_unlock(&sysctl_lock);\r\nreturn subdir;\r\n}\r\nstatic struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\r\n{\r\nstruct ctl_dir *parent;\r\nconst char *procname;\r\nif (!dir->header.parent)\r\nreturn &set->dir;\r\nparent = xlate_dir(set, dir->header.parent);\r\nif (IS_ERR(parent))\r\nreturn parent;\r\nprocname = dir->header.ctl_table[0].procname;\r\nreturn find_subdir(parent, procname, strlen(procname));\r\n}\r\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\r\nstruct ctl_table **pentry, struct nsproxy *namespaces)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct ctl_table_root *root;\r\nstruct ctl_table_set *set;\r\nstruct ctl_table *entry;\r\nstruct ctl_dir *dir;\r\nint ret;\r\nret = 0;\r\nspin_lock(&sysctl_lock);\r\nroot = (*pentry)->data;\r\nset = lookup_header_set(root, namespaces);\r\ndir = xlate_dir(set, (*phead)->parent);\r\nif (IS_ERR(dir))\r\nret = PTR_ERR(dir);\r\nelse {\r\nconst char *procname = (*pentry)->procname;\r\nhead = NULL;\r\nentry = find_entry(&head, dir, procname, strlen(procname));\r\nret = -ENOENT;\r\nif (entry && use_table(head)) {\r\nunuse_table(*phead);\r\n*phead = head;\r\n*pentry = entry;\r\nret = 0;\r\n}\r\n}\r\nspin_unlock(&sysctl_lock);\r\nreturn ret;\r\n}\r\nstatic int sysctl_err(const char *path, struct ctl_table *table, char *fmt, ...)\r\n{\r\nstruct va_format vaf;\r\nva_list args;\r\nva_start(args, fmt);\r\nvaf.fmt = fmt;\r\nvaf.va = &args;\r\npr_err("sysctl table check failed: %s/%s %pV\n",\r\npath, table->procname, &vaf);\r\nva_end(args);\r\nreturn -EINVAL;\r\n}\r\nstatic int sysctl_check_table(const char *path, struct ctl_table *table)\r\n{\r\nint err = 0;\r\nfor (; table->procname; table++) {\r\nif (table->child)\r\nerr = sysctl_err(path, table, "Not a file");\r\nif ((table->proc_handler == proc_dostring) ||\r\n(table->proc_handler == proc_dointvec) ||\r\n(table->proc_handler == proc_dointvec_minmax) ||\r\n(table->proc_handler == proc_dointvec_jiffies) ||\r\n(table->proc_handler == proc_dointvec_userhz_jiffies) ||\r\n(table->proc_handler == proc_dointvec_ms_jiffies) ||\r\n(table->proc_handler == proc_doulongvec_minmax) ||\r\n(table->proc_handler == proc_doulongvec_ms_jiffies_minmax)) {\r\nif (!table->data)\r\nerr = sysctl_err(path, table, "No data");\r\nif (!table->maxlen)\r\nerr = sysctl_err(path, table, "No maxlen");\r\n}\r\nif (!table->proc_handler)\r\nerr = sysctl_err(path, table, "No proc_handler");\r\nif ((table->mode & (S_IRUGO|S_IWUGO)) != table->mode)\r\nerr = sysctl_err(path, table, "bogus .mode 0%o",\r\ntable->mode);\r\n}\r\nreturn err;\r\n}\r\nstatic struct ctl_table_header *new_links(struct ctl_dir *dir, struct ctl_table *table,\r\nstruct ctl_table_root *link_root)\r\n{\r\nstruct ctl_table *link_table, *entry, *link;\r\nstruct ctl_table_header *links;\r\nstruct ctl_node *node;\r\nchar *link_name;\r\nint nr_entries, name_bytes;\r\nname_bytes = 0;\r\nnr_entries = 0;\r\nfor (entry = table; entry->procname; entry++) {\r\nnr_entries++;\r\nname_bytes += strlen(entry->procname) + 1;\r\n}\r\nlinks = kzalloc(sizeof(struct ctl_table_header) +\r\nsizeof(struct ctl_node)*nr_entries +\r\nsizeof(struct ctl_table)*(nr_entries + 1) +\r\nname_bytes,\r\nGFP_KERNEL);\r\nif (!links)\r\nreturn NULL;\r\nnode = (struct ctl_node *)(links + 1);\r\nlink_table = (struct ctl_table *)(node + nr_entries);\r\nlink_name = (char *)&link_table[nr_entries + 1];\r\nfor (link = link_table, entry = table; entry->procname; link++, entry++) {\r\nint len = strlen(entry->procname) + 1;\r\nmemcpy(link_name, entry->procname, len);\r\nlink->procname = link_name;\r\nlink->mode = S_IFLNK|S_IRWXUGO;\r\nlink->data = link_root;\r\nlink_name += len;\r\n}\r\ninit_header(links, dir->header.root, dir->header.set, node, link_table);\r\nlinks->nreg = nr_entries;\r\nreturn links;\r\n}\r\nstatic bool get_links(struct ctl_dir *dir,\r\nstruct ctl_table *table, struct ctl_table_root *link_root)\r\n{\r\nstruct ctl_table_header *head;\r\nstruct ctl_table *entry, *link;\r\nfor (entry = table; entry->procname; entry++) {\r\nconst char *procname = entry->procname;\r\nlink = find_entry(&head, dir, procname, strlen(procname));\r\nif (!link)\r\nreturn false;\r\nif (S_ISDIR(link->mode) && S_ISDIR(entry->mode))\r\ncontinue;\r\nif (S_ISLNK(link->mode) && (link->data == link_root))\r\ncontinue;\r\nreturn false;\r\n}\r\nfor (entry = table; entry->procname; entry++) {\r\nconst char *procname = entry->procname;\r\nlink = find_entry(&head, dir, procname, strlen(procname));\r\nhead->nreg++;\r\n}\r\nreturn true;\r\n}\r\nstatic int insert_links(struct ctl_table_header *head)\r\n{\r\nstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\r\nstruct ctl_dir *core_parent = NULL;\r\nstruct ctl_table_header *links;\r\nint err;\r\nif (head->set == root_set)\r\nreturn 0;\r\ncore_parent = xlate_dir(root_set, head->parent);\r\nif (IS_ERR(core_parent))\r\nreturn 0;\r\nif (get_links(core_parent, head->ctl_table, head->root))\r\nreturn 0;\r\ncore_parent->header.nreg++;\r\nspin_unlock(&sysctl_lock);\r\nlinks = new_links(core_parent, head->ctl_table, head->root);\r\nspin_lock(&sysctl_lock);\r\nerr = -ENOMEM;\r\nif (!links)\r\ngoto out;\r\nerr = 0;\r\nif (get_links(core_parent, head->ctl_table, head->root)) {\r\nkfree(links);\r\ngoto out;\r\n}\r\nerr = insert_header(core_parent, links);\r\nif (err)\r\nkfree(links);\r\nout:\r\ndrop_sysctl_table(&core_parent->header);\r\nreturn err;\r\n}\r\nstruct ctl_table_header *__register_sysctl_table(\r\nstruct ctl_table_set *set,\r\nconst char *path, struct ctl_table *table)\r\n{\r\nstruct ctl_table_root *root = set->dir.header.root;\r\nstruct ctl_table_header *header;\r\nconst char *name, *nextname;\r\nstruct ctl_dir *dir;\r\nstruct ctl_table *entry;\r\nstruct ctl_node *node;\r\nint nr_entries = 0;\r\nfor (entry = table; entry->procname; entry++)\r\nnr_entries++;\r\nheader = kzalloc(sizeof(struct ctl_table_header) +\r\nsizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\r\nif (!header)\r\nreturn NULL;\r\nnode = (struct ctl_node *)(header + 1);\r\ninit_header(header, root, set, node, table);\r\nif (sysctl_check_table(path, table))\r\ngoto fail;\r\nspin_lock(&sysctl_lock);\r\ndir = &set->dir;\r\ndir->header.nreg++;\r\nspin_unlock(&sysctl_lock);\r\nfor (name = path; name; name = nextname) {\r\nint namelen;\r\nnextname = strchr(name, '/');\r\nif (nextname) {\r\nnamelen = nextname - name;\r\nnextname++;\r\n} else {\r\nnamelen = strlen(name);\r\n}\r\nif (namelen == 0)\r\ncontinue;\r\ndir = get_subdir(dir, name, namelen);\r\nif (IS_ERR(dir))\r\ngoto fail;\r\n}\r\nspin_lock(&sysctl_lock);\r\nif (insert_header(dir, header))\r\ngoto fail_put_dir_locked;\r\ndrop_sysctl_table(&dir->header);\r\nspin_unlock(&sysctl_lock);\r\nreturn header;\r\nfail_put_dir_locked:\r\ndrop_sysctl_table(&dir->header);\r\nspin_unlock(&sysctl_lock);\r\nfail:\r\nkfree(header);\r\ndump_stack();\r\nreturn NULL;\r\n}\r\nstruct ctl_table_header *register_sysctl(const char *path, struct ctl_table *table)\r\n{\r\nreturn __register_sysctl_table(&sysctl_table_root.default_set,\r\npath, table);\r\n}\r\nstatic char *append_path(const char *path, char *pos, const char *name)\r\n{\r\nint namelen;\r\nnamelen = strlen(name);\r\nif (((pos - path) + namelen + 2) >= PATH_MAX)\r\nreturn NULL;\r\nmemcpy(pos, name, namelen);\r\npos[namelen] = '/';\r\npos[namelen + 1] = '\0';\r\npos += namelen + 1;\r\nreturn pos;\r\n}\r\nstatic int count_subheaders(struct ctl_table *table)\r\n{\r\nint has_files = 0;\r\nint nr_subheaders = 0;\r\nstruct ctl_table *entry;\r\nif (!table || !table->procname)\r\nreturn 1;\r\nfor (entry = table; entry->procname; entry++) {\r\nif (entry->child)\r\nnr_subheaders += count_subheaders(entry->child);\r\nelse\r\nhas_files = 1;\r\n}\r\nreturn nr_subheaders + has_files;\r\n}\r\nstatic int register_leaf_sysctl_tables(const char *path, char *pos,\r\nstruct ctl_table_header ***subheader, struct ctl_table_set *set,\r\nstruct ctl_table *table)\r\n{\r\nstruct ctl_table *ctl_table_arg = NULL;\r\nstruct ctl_table *entry, *files;\r\nint nr_files = 0;\r\nint nr_dirs = 0;\r\nint err = -ENOMEM;\r\nfor (entry = table; entry->procname; entry++) {\r\nif (entry->child)\r\nnr_dirs++;\r\nelse\r\nnr_files++;\r\n}\r\nfiles = table;\r\nif (nr_dirs && nr_files) {\r\nstruct ctl_table *new;\r\nfiles = kzalloc(sizeof(struct ctl_table) * (nr_files + 1),\r\nGFP_KERNEL);\r\nif (!files)\r\ngoto out;\r\nctl_table_arg = files;\r\nfor (new = files, entry = table; entry->procname; entry++) {\r\nif (entry->child)\r\ncontinue;\r\n*new = *entry;\r\nnew++;\r\n}\r\n}\r\nif (nr_files || !nr_dirs) {\r\nstruct ctl_table_header *header;\r\nheader = __register_sysctl_table(set, path, files);\r\nif (!header) {\r\nkfree(ctl_table_arg);\r\ngoto out;\r\n}\r\nheader->ctl_table_arg = ctl_table_arg;\r\n**subheader = header;\r\n(*subheader)++;\r\n}\r\nfor (entry = table; entry->procname; entry++) {\r\nchar *child_pos;\r\nif (!entry->child)\r\ncontinue;\r\nerr = -ENAMETOOLONG;\r\nchild_pos = append_path(path, pos, entry->procname);\r\nif (!child_pos)\r\ngoto out;\r\nerr = register_leaf_sysctl_tables(path, child_pos, subheader,\r\nset, entry->child);\r\npos[0] = '\0';\r\nif (err)\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstruct ctl_table_header *__register_sysctl_paths(\r\nstruct ctl_table_set *set,\r\nconst struct ctl_path *path, struct ctl_table *table)\r\n{\r\nstruct ctl_table *ctl_table_arg = table;\r\nint nr_subheaders = count_subheaders(table);\r\nstruct ctl_table_header *header = NULL, **subheaders, **subheader;\r\nconst struct ctl_path *component;\r\nchar *new_path, *pos;\r\npos = new_path = kmalloc(PATH_MAX, GFP_KERNEL);\r\nif (!new_path)\r\nreturn NULL;\r\npos[0] = '\0';\r\nfor (component = path; component->procname; component++) {\r\npos = append_path(new_path, pos, component->procname);\r\nif (!pos)\r\ngoto out;\r\n}\r\nwhile (table->procname && table->child && !table[1].procname) {\r\npos = append_path(new_path, pos, table->procname);\r\nif (!pos)\r\ngoto out;\r\ntable = table->child;\r\n}\r\nif (nr_subheaders == 1) {\r\nheader = __register_sysctl_table(set, new_path, table);\r\nif (header)\r\nheader->ctl_table_arg = ctl_table_arg;\r\n} else {\r\nheader = kzalloc(sizeof(*header) +\r\nsizeof(*subheaders)*nr_subheaders, GFP_KERNEL);\r\nif (!header)\r\ngoto out;\r\nsubheaders = (struct ctl_table_header **) (header + 1);\r\nsubheader = subheaders;\r\nheader->ctl_table_arg = ctl_table_arg;\r\nif (register_leaf_sysctl_tables(new_path, pos, &subheader,\r\nset, table))\r\ngoto err_register_leaves;\r\n}\r\nout:\r\nkfree(new_path);\r\nreturn header;\r\nerr_register_leaves:\r\nwhile (subheader > subheaders) {\r\nstruct ctl_table_header *subh = *(--subheader);\r\nstruct ctl_table *table = subh->ctl_table_arg;\r\nunregister_sysctl_table(subh);\r\nkfree(table);\r\n}\r\nkfree(header);\r\nheader = NULL;\r\ngoto out;\r\n}\r\nstruct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\r\nstruct ctl_table *table)\r\n{\r\nreturn __register_sysctl_paths(&sysctl_table_root.default_set,\r\npath, table);\r\n}\r\nstruct ctl_table_header *register_sysctl_table(struct ctl_table *table)\r\n{\r\nstatic const struct ctl_path null_path[] = { {} };\r\nreturn register_sysctl_paths(null_path, table);\r\n}\r\nstatic void put_links(struct ctl_table_header *header)\r\n{\r\nstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\r\nstruct ctl_table_root *root = header->root;\r\nstruct ctl_dir *parent = header->parent;\r\nstruct ctl_dir *core_parent;\r\nstruct ctl_table *entry;\r\nif (header->set == root_set)\r\nreturn;\r\ncore_parent = xlate_dir(root_set, parent);\r\nif (IS_ERR(core_parent))\r\nreturn;\r\nfor (entry = header->ctl_table; entry->procname; entry++) {\r\nstruct ctl_table_header *link_head;\r\nstruct ctl_table *link;\r\nconst char *name = entry->procname;\r\nlink = find_entry(&link_head, core_parent, name, strlen(name));\r\nif (link &&\r\n((S_ISDIR(link->mode) && S_ISDIR(entry->mode)) ||\r\n(S_ISLNK(link->mode) && (link->data == root)))) {\r\ndrop_sysctl_table(link_head);\r\n}\r\nelse {\r\npr_err("sysctl link missing during unregister: ");\r\nsysctl_print_dir(parent);\r\npr_cont("/%s\n", name);\r\n}\r\n}\r\n}\r\nstatic void drop_sysctl_table(struct ctl_table_header *header)\r\n{\r\nstruct ctl_dir *parent = header->parent;\r\nif (--header->nreg)\r\nreturn;\r\nput_links(header);\r\nstart_unregistering(header);\r\nif (!--header->count)\r\nkfree_rcu(header, rcu);\r\nif (parent)\r\ndrop_sysctl_table(&parent->header);\r\n}\r\nvoid unregister_sysctl_table(struct ctl_table_header * header)\r\n{\r\nint nr_subheaders;\r\nmight_sleep();\r\nif (header == NULL)\r\nreturn;\r\nnr_subheaders = count_subheaders(header->ctl_table_arg);\r\nif (unlikely(nr_subheaders > 1)) {\r\nstruct ctl_table_header **subheaders;\r\nint i;\r\nsubheaders = (struct ctl_table_header **)(header + 1);\r\nfor (i = nr_subheaders -1; i >= 0; i--) {\r\nstruct ctl_table_header *subh = subheaders[i];\r\nstruct ctl_table *table = subh->ctl_table_arg;\r\nunregister_sysctl_table(subh);\r\nkfree(table);\r\n}\r\nkfree(header);\r\nreturn;\r\n}\r\nspin_lock(&sysctl_lock);\r\ndrop_sysctl_table(header);\r\nspin_unlock(&sysctl_lock);\r\n}\r\nvoid setup_sysctl_set(struct ctl_table_set *set,\r\nstruct ctl_table_root *root,\r\nint (*is_seen)(struct ctl_table_set *))\r\n{\r\nmemset(set, 0, sizeof(*set));\r\nset->is_seen = is_seen;\r\ninit_header(&set->dir.header, root, set, NULL, root_table);\r\n}\r\nvoid retire_sysctl_set(struct ctl_table_set *set)\r\n{\r\nWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\r\n}\r\nint __init proc_sys_init(void)\r\n{\r\nstruct proc_dir_entry *proc_sys_root;\r\nproc_sys_root = proc_mkdir("sys", NULL);\r\nproc_sys_root->proc_iops = &proc_sys_dir_operations;\r\nproc_sys_root->proc_fops = &proc_sys_dir_file_operations;\r\nproc_sys_root->nlink = 0;\r\nreturn sysctl_init();\r\n}
