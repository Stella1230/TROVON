static inline struct bcm2835_dmadev *to_bcm2835_dma_dev(struct dma_device *d)\r\n{\r\nreturn container_of(d, struct bcm2835_dmadev, ddev);\r\n}\r\nstatic inline struct bcm2835_chan *to_bcm2835_dma_chan(struct dma_chan *c)\r\n{\r\nreturn container_of(c, struct bcm2835_chan, vc.chan);\r\n}\r\nstatic inline struct bcm2835_desc *to_bcm2835_dma_desc(\r\nstruct dma_async_tx_descriptor *t)\r\n{\r\nreturn container_of(t, struct bcm2835_desc, vd.tx);\r\n}\r\nstatic void bcm2835_dma_desc_free(struct virt_dma_desc *vd)\r\n{\r\nstruct bcm2835_desc *desc = container_of(vd, struct bcm2835_desc, vd);\r\ndma_free_coherent(desc->vd.tx.chan->device->dev,\r\ndesc->control_block_size,\r\ndesc->control_block_base,\r\ndesc->control_block_base_phys);\r\nkfree(desc);\r\n}\r\nstatic int bcm2835_dma_abort(void __iomem *chan_base)\r\n{\r\nunsigned long cs;\r\nlong int timeout = 10000;\r\ncs = readl(chan_base + BCM2835_DMA_CS);\r\nif (!(cs & BCM2835_DMA_ACTIVE))\r\nreturn 0;\r\nwritel(0, chan_base + BCM2835_DMA_CS);\r\nwhile ((cs & BCM2835_DMA_ISPAUSED) && --timeout) {\r\ncpu_relax();\r\ncs = readl(chan_base + BCM2835_DMA_CS);\r\n}\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\nif (!(cs & BCM2835_DMA_ACTIVE))\r\nreturn 0;\r\nwritel(0, chan_base + BCM2835_DMA_NEXTCB);\r\nwritel(BCM2835_DMA_ABORT | BCM2835_DMA_ACTIVE,\r\nchan_base + BCM2835_DMA_CS);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_dma_start_desc(struct bcm2835_chan *c)\r\n{\r\nstruct virt_dma_desc *vd = vchan_next_desc(&c->vc);\r\nstruct bcm2835_desc *d;\r\nif (!vd) {\r\nc->desc = NULL;\r\nreturn;\r\n}\r\nlist_del(&vd->node);\r\nc->desc = d = to_bcm2835_dma_desc(&vd->tx);\r\nwritel(d->control_block_base_phys, c->chan_base + BCM2835_DMA_ADDR);\r\nwritel(BCM2835_DMA_ACTIVE, c->chan_base + BCM2835_DMA_CS);\r\n}\r\nstatic irqreturn_t bcm2835_dma_callback(int irq, void *data)\r\n{\r\nstruct bcm2835_chan *c = data;\r\nstruct bcm2835_desc *d;\r\nunsigned long flags;\r\nspin_lock_irqsave(&c->vc.lock, flags);\r\nwritel(BCM2835_DMA_INT, c->chan_base + BCM2835_DMA_CS);\r\nd = c->desc;\r\nif (d) {\r\nvchan_cyclic_callback(&d->vd);\r\n}\r\nwritel(BCM2835_DMA_ACTIVE, c->chan_base + BCM2835_DMA_CS);\r\nspin_unlock_irqrestore(&c->vc.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm2835_dma_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\r\ndev_dbg(c->vc.chan.device->dev,\r\n"Allocating DMA channel %d\n", c->ch);\r\nreturn request_irq(c->irq_number,\r\nbcm2835_dma_callback, 0, "DMA IRQ", c);\r\n}\r\nstatic void bcm2835_dma_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\r\nvchan_free_chan_resources(&c->vc);\r\nfree_irq(c->irq_number, c);\r\ndev_dbg(c->vc.chan.device->dev, "Freeing DMA channel %u\n", c->ch);\r\n}\r\nstatic size_t bcm2835_dma_desc_size(struct bcm2835_desc *d)\r\n{\r\nreturn d->size;\r\n}\r\nstatic size_t bcm2835_dma_desc_size_pos(struct bcm2835_desc *d, dma_addr_t addr)\r\n{\r\nunsigned int i;\r\nsize_t size;\r\nfor (size = i = 0; i < d->frames; i++) {\r\nstruct bcm2835_dma_cb *control_block =\r\n&d->control_block_base[i];\r\nsize_t this_size = control_block->length;\r\ndma_addr_t dma;\r\nif (d->dir == DMA_DEV_TO_MEM)\r\ndma = control_block->dst;\r\nelse\r\ndma = control_block->src;\r\nif (size)\r\nsize += this_size;\r\nelse if (addr >= dma && addr < dma + this_size)\r\nsize += dma + this_size - addr;\r\n}\r\nreturn size;\r\n}\r\nstatic enum dma_status bcm2835_dma_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie, struct dma_tx_state *txstate)\r\n{\r\nstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\r\nstruct virt_dma_desc *vd;\r\nenum dma_status ret;\r\nunsigned long flags;\r\nret = dma_cookie_status(chan, cookie, txstate);\r\nif (ret == DMA_COMPLETE || !txstate)\r\nreturn ret;\r\nspin_lock_irqsave(&c->vc.lock, flags);\r\nvd = vchan_find_desc(&c->vc, cookie);\r\nif (vd) {\r\ntxstate->residue =\r\nbcm2835_dma_desc_size(to_bcm2835_dma_desc(&vd->tx));\r\n} else if (c->desc && c->desc->vd.tx.cookie == cookie) {\r\nstruct bcm2835_desc *d = c->desc;\r\ndma_addr_t pos;\r\nif (d->dir == DMA_MEM_TO_DEV)\r\npos = readl(c->chan_base + BCM2835_DMA_SOURCE_AD);\r\nelse if (d->dir == DMA_DEV_TO_MEM)\r\npos = readl(c->chan_base + BCM2835_DMA_DEST_AD);\r\nelse\r\npos = 0;\r\ntxstate->residue = bcm2835_dma_desc_size_pos(d, pos);\r\n} else {\r\ntxstate->residue = 0;\r\n}\r\nspin_unlock_irqrestore(&c->vc.lock, flags);\r\nreturn ret;\r\n}\r\nstatic void bcm2835_dma_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\r\nunsigned long flags;\r\nc->cyclic = true;\r\nspin_lock_irqsave(&c->vc.lock, flags);\r\nif (vchan_issue_pending(&c->vc) && !c->desc)\r\nbcm2835_dma_start_desc(c);\r\nspin_unlock_irqrestore(&c->vc.lock, flags);\r\n}\r\nstatic struct dma_async_tx_descriptor *bcm2835_dma_prep_dma_cyclic(\r\nstruct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,\r\nsize_t period_len, enum dma_transfer_direction direction,\r\nunsigned long flags)\r\n{\r\nstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\r\nenum dma_slave_buswidth dev_width;\r\nstruct bcm2835_desc *d;\r\ndma_addr_t dev_addr;\r\nunsigned int es, sync_type;\r\nunsigned int frame;\r\nif (!is_slave_direction(direction)) {\r\ndev_err(chan->device->dev, "%s: bad direction?\n", __func__);\r\nreturn NULL;\r\n}\r\nif (direction == DMA_DEV_TO_MEM) {\r\ndev_addr = c->cfg.src_addr;\r\ndev_width = c->cfg.src_addr_width;\r\nsync_type = BCM2835_DMA_S_DREQ;\r\n} else {\r\ndev_addr = c->cfg.dst_addr;\r\ndev_width = c->cfg.dst_addr_width;\r\nsync_type = BCM2835_DMA_D_DREQ;\r\n}\r\nswitch (dev_width) {\r\ncase DMA_SLAVE_BUSWIDTH_4_BYTES:\r\nes = BCM2835_DMA_DATA_TYPE_S32;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nd = kzalloc(sizeof(*d), GFP_NOWAIT);\r\nif (!d)\r\nreturn NULL;\r\nd->dir = direction;\r\nd->frames = buf_len / period_len;\r\nd->control_block_size = d->frames * sizeof(struct bcm2835_dma_cb);\r\nd->control_block_base = dma_zalloc_coherent(chan->device->dev,\r\nd->control_block_size, &d->control_block_base_phys,\r\nGFP_NOWAIT);\r\nif (!d->control_block_base) {\r\nkfree(d);\r\nreturn NULL;\r\n}\r\nfor (frame = 0; frame < d->frames; frame++) {\r\nstruct bcm2835_dma_cb *control_block =\r\n&d->control_block_base[frame];\r\nif (d->dir == DMA_DEV_TO_MEM) {\r\ncontrol_block->info = BCM2835_DMA_D_INC;\r\ncontrol_block->src = dev_addr;\r\ncontrol_block->dst = buf_addr + frame * period_len;\r\n} else {\r\ncontrol_block->info = BCM2835_DMA_S_INC;\r\ncontrol_block->src = buf_addr + frame * period_len;\r\ncontrol_block->dst = dev_addr;\r\n}\r\ncontrol_block->info |= BCM2835_DMA_INT_EN;\r\nif (sync_type != 0)\r\ncontrol_block->info |= sync_type;\r\nif (c->dreq != 0)\r\ncontrol_block->info |=\r\nBCM2835_DMA_PER_MAP(c->dreq);\r\ncontrol_block->length = period_len;\r\nd->size += control_block->length;\r\ncontrol_block->next = d->control_block_base_phys +\r\nsizeof(struct bcm2835_dma_cb)\r\n* ((frame + 1) % d->frames);\r\n}\r\nreturn vchan_tx_prep(&c->vc, &d->vd, flags);\r\n}\r\nstatic int bcm2835_dma_slave_config(struct bcm2835_chan *c,\r\nstruct dma_slave_config *cfg)\r\n{\r\nif ((cfg->direction == DMA_DEV_TO_MEM &&\r\ncfg->src_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES) ||\r\n(cfg->direction == DMA_MEM_TO_DEV &&\r\ncfg->dst_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES) ||\r\n!is_slave_direction(cfg->direction)) {\r\nreturn -EINVAL;\r\n}\r\nc->cfg = *cfg;\r\nreturn 0;\r\n}\r\nstatic int bcm2835_dma_terminate_all(struct bcm2835_chan *c)\r\n{\r\nstruct bcm2835_dmadev *d = to_bcm2835_dma_dev(c->vc.chan.device);\r\nunsigned long flags;\r\nint timeout = 10000;\r\nLIST_HEAD(head);\r\nspin_lock_irqsave(&c->vc.lock, flags);\r\nspin_lock(&d->lock);\r\nlist_del_init(&c->node);\r\nspin_unlock(&d->lock);\r\nif (c->desc) {\r\nc->desc = NULL;\r\nbcm2835_dma_abort(c->chan_base);\r\nwhile (--timeout) {\r\nif (!(readl(c->chan_base + BCM2835_DMA_CS) &\r\nBCM2835_DMA_ACTIVE))\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (!timeout)\r\ndev_err(d->ddev.dev, "DMA transfer could not be terminated\n");\r\n}\r\nvchan_get_all_descriptors(&c->vc, &head);\r\nspin_unlock_irqrestore(&c->vc.lock, flags);\r\nvchan_dma_desc_free_list(&c->vc, &head);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,\r\nunsigned long arg)\r\n{\r\nstruct bcm2835_chan *c = to_bcm2835_dma_chan(chan);\r\nswitch (cmd) {\r\ncase DMA_SLAVE_CONFIG:\r\nreturn bcm2835_dma_slave_config(c,\r\n(struct dma_slave_config *)arg);\r\ncase DMA_TERMINATE_ALL:\r\nreturn bcm2835_dma_terminate_all(c);\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\n}\r\nstatic int bcm2835_dma_chan_init(struct bcm2835_dmadev *d, int chan_id, int irq)\r\n{\r\nstruct bcm2835_chan *c;\r\nc = devm_kzalloc(d->ddev.dev, sizeof(*c), GFP_KERNEL);\r\nif (!c)\r\nreturn -ENOMEM;\r\nc->vc.desc_free = bcm2835_dma_desc_free;\r\nvchan_init(&c->vc, &d->ddev);\r\nINIT_LIST_HEAD(&c->node);\r\nd->ddev.chancnt++;\r\nc->chan_base = BCM2835_DMA_CHANIO(d->base, chan_id);\r\nc->ch = chan_id;\r\nc->irq_number = irq;\r\nreturn 0;\r\n}\r\nstatic void bcm2835_dma_free(struct bcm2835_dmadev *od)\r\n{\r\nstruct bcm2835_chan *c, *next;\r\nlist_for_each_entry_safe(c, next, &od->ddev.channels,\r\nvc.chan.device_node) {\r\nlist_del(&c->vc.chan.device_node);\r\ntasklet_kill(&c->vc.task);\r\n}\r\n}\r\nstatic struct dma_chan *bcm2835_dma_xlate(struct of_phandle_args *spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct bcm2835_dmadev *d = ofdma->of_dma_data;\r\nstruct dma_chan *chan;\r\nchan = dma_get_any_slave_channel(&d->ddev);\r\nif (!chan)\r\nreturn NULL;\r\nto_bcm2835_dma_chan(chan)->dreq = spec->args[0];\r\nreturn chan;\r\n}\r\nstatic int bcm2835_dma_device_slave_caps(struct dma_chan *dchan,\r\nstruct dma_slave_caps *caps)\r\n{\r\ncaps->src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\r\ncaps->dstn_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\r\ncaps->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);\r\ncaps->cmd_pause = false;\r\ncaps->cmd_terminate = true;\r\nreturn 0;\r\n}\r\nstatic int bcm2835_dma_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm2835_dmadev *od;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint rc;\r\nint i;\r\nint irq;\r\nuint32_t chans_available;\r\nif (!pdev->dev.dma_mask)\r\npdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;\r\nrc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (rc)\r\nreturn rc;\r\nod = devm_kzalloc(&pdev->dev, sizeof(*od), GFP_KERNEL);\r\nif (!od)\r\nreturn -ENOMEM;\r\npdev->dev.dma_parms = &od->dma_parms;\r\ndma_set_max_seg_size(&pdev->dev, 0x3FFFFFFF);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nod->base = base;\r\ndma_cap_set(DMA_SLAVE, od->ddev.cap_mask);\r\ndma_cap_set(DMA_PRIVATE, od->ddev.cap_mask);\r\ndma_cap_set(DMA_CYCLIC, od->ddev.cap_mask);\r\nod->ddev.device_alloc_chan_resources = bcm2835_dma_alloc_chan_resources;\r\nod->ddev.device_free_chan_resources = bcm2835_dma_free_chan_resources;\r\nod->ddev.device_tx_status = bcm2835_dma_tx_status;\r\nod->ddev.device_issue_pending = bcm2835_dma_issue_pending;\r\nod->ddev.device_slave_caps = bcm2835_dma_device_slave_caps;\r\nod->ddev.device_prep_dma_cyclic = bcm2835_dma_prep_dma_cyclic;\r\nod->ddev.device_control = bcm2835_dma_control;\r\nod->ddev.dev = &pdev->dev;\r\nINIT_LIST_HEAD(&od->ddev.channels);\r\nspin_lock_init(&od->lock);\r\nplatform_set_drvdata(pdev, od);\r\nif (of_property_read_u32(pdev->dev.of_node,\r\n"brcm,dma-channel-mask",\r\n&chans_available)) {\r\ndev_err(&pdev->dev, "Failed to get channel mask\n");\r\nrc = -EINVAL;\r\ngoto err_no_dma;\r\n}\r\nchans_available &= ~(BCM2835_DMA_FIQ_MASK | BCM2835_DMA_BULK_MASK);\r\nfor (i = 0; i < pdev->num_resources; i++) {\r\nirq = platform_get_irq(pdev, i);\r\nif (irq < 0)\r\nbreak;\r\nif (chans_available & (1 << i)) {\r\nrc = bcm2835_dma_chan_init(od, i, irq);\r\nif (rc)\r\ngoto err_no_dma;\r\n}\r\n}\r\ndev_dbg(&pdev->dev, "Initialized %i DMA channels\n", i);\r\nrc = of_dma_controller_register(pdev->dev.of_node,\r\nbcm2835_dma_xlate, od);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Failed to register DMA controller\n");\r\ngoto err_no_dma;\r\n}\r\nrc = dma_async_device_register(&od->ddev);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"Failed to register slave DMA engine device: %d\n", rc);\r\ngoto err_no_dma;\r\n}\r\ndev_dbg(&pdev->dev, "Load BCM2835 DMA engine driver\n");\r\nreturn 0;\r\nerr_no_dma:\r\nbcm2835_dma_free(od);\r\nreturn rc;\r\n}\r\nstatic int bcm2835_dma_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm2835_dmadev *od = platform_get_drvdata(pdev);\r\ndma_async_device_unregister(&od->ddev);\r\nbcm2835_dma_free(od);\r\nreturn 0;\r\n}
