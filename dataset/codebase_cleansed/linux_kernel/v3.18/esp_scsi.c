static void esp_log_fill_regs(struct esp *esp,\r\nstruct esp_event_ent *p)\r\n{\r\np->sreg = esp->sreg;\r\np->seqreg = esp->seqreg;\r\np->sreg2 = esp->sreg2;\r\np->ireg = esp->ireg;\r\np->select_state = esp->select_state;\r\np->event = esp->event;\r\n}\r\nvoid scsi_esp_cmd(struct esp *esp, u8 val)\r\n{\r\nstruct esp_event_ent *p;\r\nint idx = esp->esp_event_cur;\r\np = &esp->esp_event_log[idx];\r\np->type = ESP_EVENT_TYPE_CMD;\r\np->val = val;\r\nesp_log_fill_regs(esp, p);\r\nesp->esp_event_cur = (idx + 1) & (ESP_EVENT_LOG_SZ - 1);\r\nesp_write8(val, ESP_CMD);\r\n}\r\nstatic void esp_event(struct esp *esp, u8 val)\r\n{\r\nstruct esp_event_ent *p;\r\nint idx = esp->esp_event_cur;\r\np = &esp->esp_event_log[idx];\r\np->type = ESP_EVENT_TYPE_EVENT;\r\np->val = val;\r\nesp_log_fill_regs(esp, p);\r\nesp->esp_event_cur = (idx + 1) & (ESP_EVENT_LOG_SZ - 1);\r\nesp->event = val;\r\n}\r\nstatic void esp_dump_cmd_log(struct esp *esp)\r\n{\r\nint idx = esp->esp_event_cur;\r\nint stop = idx;\r\nprintk(KERN_INFO PFX "esp%d: Dumping command log\n",\r\nesp->host->unique_id);\r\ndo {\r\nstruct esp_event_ent *p = &esp->esp_event_log[idx];\r\nprintk(KERN_INFO PFX "esp%d: ent[%d] %s ",\r\nesp->host->unique_id, idx,\r\np->type == ESP_EVENT_TYPE_CMD ? "CMD" : "EVENT");\r\nprintk("val[%02x] sreg[%02x] seqreg[%02x] "\r\n"sreg2[%02x] ireg[%02x] ss[%02x] event[%02x]\n",\r\np->val, p->sreg, p->seqreg,\r\np->sreg2, p->ireg, p->select_state, p->event);\r\nidx = (idx + 1) & (ESP_EVENT_LOG_SZ - 1);\r\n} while (idx != stop);\r\n}\r\nstatic void esp_flush_fifo(struct esp *esp)\r\n{\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nif (esp->rev == ESP236) {\r\nint lim = 1000;\r\nwhile (esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES) {\r\nif (--lim == 0) {\r\nprintk(KERN_ALERT PFX "esp%d: ESP_FF_BYTES "\r\n"will not clear!\n",\r\nesp->host->unique_id);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\n}\r\nstatic void hme_read_fifo(struct esp *esp)\r\n{\r\nint fcnt = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;\r\nint idx = 0;\r\nwhile (fcnt--) {\r\nesp->fifo[idx++] = esp_read8(ESP_FDATA);\r\nesp->fifo[idx++] = esp_read8(ESP_FDATA);\r\n}\r\nif (esp->sreg2 & ESP_STAT2_F1BYTE) {\r\nesp_write8(0, ESP_FDATA);\r\nesp->fifo[idx++] = esp_read8(ESP_FDATA);\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\n}\r\nesp->fifo_cnt = idx;\r\n}\r\nstatic void esp_set_all_config3(struct esp *esp, u8 val)\r\n{\r\nint i;\r\nfor (i = 0; i < ESP_MAX_TARGET; i++)\r\nesp->target[i].esp_config3 = val;\r\n}\r\nstatic void esp_reset_esp(struct esp *esp)\r\n{\r\nu8 family_code, version;\r\nscsi_esp_cmd(esp, ESP_CMD_RC);\r\nscsi_esp_cmd(esp, ESP_CMD_NULL | ESP_CMD_DMA);\r\nif (esp->rev == FAST)\r\nesp_write8(ESP_CONFIG2_FENAB, ESP_CFG2);\r\nscsi_esp_cmd(esp, ESP_CMD_NULL | ESP_CMD_DMA);\r\nesp->max_period = ((35 * esp->ccycle) / 1000);\r\nif (esp->rev == FAST) {\r\nversion = esp_read8(ESP_UID);\r\nfamily_code = (version & 0xf8) >> 3;\r\nif (family_code == 0x02)\r\nesp->rev = FAS236;\r\nelse if (family_code == 0x0a)\r\nesp->rev = FASHME;\r\nelse\r\nesp->rev = FAS100A;\r\nesp->min_period = ((4 * esp->ccycle) / 1000);\r\n} else {\r\nesp->min_period = ((5 * esp->ccycle) / 1000);\r\n}\r\nesp->max_period = (esp->max_period + 3)>>2;\r\nesp->min_period = (esp->min_period + 3)>>2;\r\nesp_write8(esp->config1, ESP_CFG1);\r\nswitch (esp->rev) {\r\ncase ESP100:\r\nbreak;\r\ncase ESP100A:\r\nesp_write8(esp->config2, ESP_CFG2);\r\nbreak;\r\ncase ESP236:\r\nesp_write8(esp->config2, ESP_CFG2);\r\nesp->prev_cfg3 = esp->target[0].esp_config3;\r\nesp_write8(esp->prev_cfg3, ESP_CFG3);\r\nbreak;\r\ncase FASHME:\r\nesp->config2 |= (ESP_CONFIG2_HME32 | ESP_CONFIG2_HMEFENAB);\r\ncase FAS236:\r\nesp_write8(esp->config2, ESP_CFG2);\r\nif (esp->rev == FASHME) {\r\nu8 cfg3 = esp->target[0].esp_config3;\r\ncfg3 |= ESP_CONFIG3_FCLOCK | ESP_CONFIG3_OBPUSH;\r\nif (esp->scsi_id >= 8)\r\ncfg3 |= ESP_CONFIG3_IDBIT3;\r\nesp_set_all_config3(esp, cfg3);\r\n} else {\r\nu32 cfg3 = esp->target[0].esp_config3;\r\ncfg3 |= ESP_CONFIG3_FCLK;\r\nesp_set_all_config3(esp, cfg3);\r\n}\r\nesp->prev_cfg3 = esp->target[0].esp_config3;\r\nesp_write8(esp->prev_cfg3, ESP_CFG3);\r\nif (esp->rev == FASHME) {\r\nesp->radelay = 80;\r\n} else {\r\nif (esp->flags & ESP_FLAG_DIFFERENTIAL)\r\nesp->radelay = 0;\r\nelse\r\nesp->radelay = 96;\r\n}\r\nbreak;\r\ncase FAS100A:\r\nesp_write8(esp->config2, ESP_CFG2);\r\nesp_set_all_config3(esp,\r\n(esp->target[0].esp_config3 |\r\nESP_CONFIG3_FCLOCK));\r\nesp->prev_cfg3 = esp->target[0].esp_config3;\r\nesp_write8(esp->prev_cfg3, ESP_CFG3);\r\nesp->radelay = 32;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nesp_write8(esp->cfact, ESP_CFACT);\r\nesp->prev_stp = 0;\r\nesp_write8(esp->prev_stp, ESP_STP);\r\nesp->prev_soff = 0;\r\nesp_write8(esp->prev_soff, ESP_SOFF);\r\nesp_write8(esp->neg_defp, ESP_TIMEO);\r\nesp_read8(ESP_INTRPT);\r\nudelay(100);\r\n}\r\nstatic void esp_map_dma(struct esp *esp, struct scsi_cmnd *cmd)\r\n{\r\nstruct esp_cmd_priv *spriv = ESP_CMD_PRIV(cmd);\r\nstruct scatterlist *sg = scsi_sglist(cmd);\r\nint dir = cmd->sc_data_direction;\r\nint total, i;\r\nif (dir == DMA_NONE)\r\nreturn;\r\nspriv->u.num_sg = esp->ops->map_sg(esp, sg, scsi_sg_count(cmd), dir);\r\nspriv->cur_residue = sg_dma_len(sg);\r\nspriv->cur_sg = sg;\r\ntotal = 0;\r\nfor (i = 0; i < spriv->u.num_sg; i++)\r\ntotal += sg_dma_len(&sg[i]);\r\nspriv->tot_residue = total;\r\n}\r\nstatic dma_addr_t esp_cur_dma_addr(struct esp_cmd_entry *ent,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct esp_cmd_priv *p = ESP_CMD_PRIV(cmd);\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nreturn ent->sense_dma +\r\n(ent->sense_ptr - cmd->sense_buffer);\r\n}\r\nreturn sg_dma_address(p->cur_sg) +\r\n(sg_dma_len(p->cur_sg) -\r\np->cur_residue);\r\n}\r\nstatic unsigned int esp_cur_dma_len(struct esp_cmd_entry *ent,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct esp_cmd_priv *p = ESP_CMD_PRIV(cmd);\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nreturn SCSI_SENSE_BUFFERSIZE -\r\n(ent->sense_ptr - cmd->sense_buffer);\r\n}\r\nreturn p->cur_residue;\r\n}\r\nstatic void esp_advance_dma(struct esp *esp, struct esp_cmd_entry *ent,\r\nstruct scsi_cmnd *cmd, unsigned int len)\r\n{\r\nstruct esp_cmd_priv *p = ESP_CMD_PRIV(cmd);\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nent->sense_ptr += len;\r\nreturn;\r\n}\r\np->cur_residue -= len;\r\np->tot_residue -= len;\r\nif (p->cur_residue < 0 || p->tot_residue < 0) {\r\nprintk(KERN_ERR PFX "esp%d: Data transfer overflow.\n",\r\nesp->host->unique_id);\r\nprintk(KERN_ERR PFX "esp%d: cur_residue[%d] tot_residue[%d] "\r\n"len[%u]\n",\r\nesp->host->unique_id,\r\np->cur_residue, p->tot_residue, len);\r\np->cur_residue = 0;\r\np->tot_residue = 0;\r\n}\r\nif (!p->cur_residue && p->tot_residue) {\r\np->cur_sg++;\r\np->cur_residue = sg_dma_len(p->cur_sg);\r\n}\r\n}\r\nstatic void esp_unmap_dma(struct esp *esp, struct scsi_cmnd *cmd)\r\n{\r\nstruct esp_cmd_priv *spriv = ESP_CMD_PRIV(cmd);\r\nint dir = cmd->sc_data_direction;\r\nif (dir == DMA_NONE)\r\nreturn;\r\nesp->ops->unmap_sg(esp, scsi_sglist(cmd), spriv->u.num_sg, dir);\r\n}\r\nstatic void esp_save_pointers(struct esp *esp, struct esp_cmd_entry *ent)\r\n{\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nstruct esp_cmd_priv *spriv = ESP_CMD_PRIV(cmd);\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nent->saved_sense_ptr = ent->sense_ptr;\r\nreturn;\r\n}\r\nent->saved_cur_residue = spriv->cur_residue;\r\nent->saved_cur_sg = spriv->cur_sg;\r\nent->saved_tot_residue = spriv->tot_residue;\r\n}\r\nstatic void esp_restore_pointers(struct esp *esp, struct esp_cmd_entry *ent)\r\n{\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nstruct esp_cmd_priv *spriv = ESP_CMD_PRIV(cmd);\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nent->sense_ptr = ent->saved_sense_ptr;\r\nreturn;\r\n}\r\nspriv->cur_residue = ent->saved_cur_residue;\r\nspriv->cur_sg = ent->saved_cur_sg;\r\nspriv->tot_residue = ent->saved_tot_residue;\r\n}\r\nstatic void esp_check_command_len(struct esp *esp, struct scsi_cmnd *cmd)\r\n{\r\nif (cmd->cmd_len == 6 ||\r\ncmd->cmd_len == 10 ||\r\ncmd->cmd_len == 12) {\r\nesp->flags &= ~ESP_FLAG_DOING_SLOWCMD;\r\n} else {\r\nesp->flags |= ESP_FLAG_DOING_SLOWCMD;\r\n}\r\n}\r\nstatic void esp_write_tgt_config3(struct esp *esp, int tgt)\r\n{\r\nif (esp->rev > ESP100A) {\r\nu8 val = esp->target[tgt].esp_config3;\r\nif (val != esp->prev_cfg3) {\r\nesp->prev_cfg3 = val;\r\nesp_write8(val, ESP_CFG3);\r\n}\r\n}\r\n}\r\nstatic void esp_write_tgt_sync(struct esp *esp, int tgt)\r\n{\r\nu8 off = esp->target[tgt].esp_offset;\r\nu8 per = esp->target[tgt].esp_period;\r\nif (off != esp->prev_soff) {\r\nesp->prev_soff = off;\r\nesp_write8(off, ESP_SOFF);\r\n}\r\nif (per != esp->prev_stp) {\r\nesp->prev_stp = per;\r\nesp_write8(per, ESP_STP);\r\n}\r\n}\r\nstatic u32 esp_dma_length_limit(struct esp *esp, u32 dma_addr, u32 dma_len)\r\n{\r\nif (esp->rev == FASHME) {\r\nif (dma_len > (1U << 24))\r\ndma_len = (1U << 24);\r\n} else {\r\nu32 base, end;\r\nif (dma_len > (1U << 16))\r\ndma_len = (1U << 16);\r\nbase = dma_addr & ((1U << 24) - 1U);\r\nend = base + dma_len;\r\nif (end > (1U << 24))\r\nend = (1U <<24);\r\ndma_len = end - base;\r\n}\r\nreturn dma_len;\r\n}\r\nstatic int esp_need_to_nego_wide(struct esp_target_data *tp)\r\n{\r\nstruct scsi_target *target = tp->starget;\r\nreturn spi_width(target) != tp->nego_goal_width;\r\n}\r\nstatic int esp_need_to_nego_sync(struct esp_target_data *tp)\r\n{\r\nstruct scsi_target *target = tp->starget;\r\nif (!spi_offset(target) && !tp->nego_goal_offset)\r\nreturn 0;\r\nif (spi_offset(target) == tp->nego_goal_offset &&\r\nspi_period(target) == tp->nego_goal_period)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int esp_alloc_lun_tag(struct esp_cmd_entry *ent,\r\nstruct esp_lun_data *lp)\r\n{\r\nif (!ent->orig_tag[0]) {\r\nif (lp->non_tagged_cmd)\r\nreturn -EBUSY;\r\nif (lp->hold) {\r\nif (lp->num_tagged)\r\nreturn -EBUSY;\r\nlp->hold = 0;\r\n} else if (lp->num_tagged) {\r\nlp->hold = 1;\r\nreturn -EBUSY;\r\n}\r\nlp->non_tagged_cmd = ent;\r\nreturn 0;\r\n} else {\r\nif (lp->non_tagged_cmd || lp->hold)\r\nreturn -EBUSY;\r\n}\r\nBUG_ON(lp->tagged_cmds[ent->orig_tag[1]]);\r\nlp->tagged_cmds[ent->orig_tag[1]] = ent;\r\nlp->num_tagged++;\r\nreturn 0;\r\n}\r\nstatic void esp_free_lun_tag(struct esp_cmd_entry *ent,\r\nstruct esp_lun_data *lp)\r\n{\r\nif (ent->orig_tag[0]) {\r\nBUG_ON(lp->tagged_cmds[ent->orig_tag[1]] != ent);\r\nlp->tagged_cmds[ent->orig_tag[1]] = NULL;\r\nlp->num_tagged--;\r\n} else {\r\nBUG_ON(lp->non_tagged_cmd != ent);\r\nlp->non_tagged_cmd = NULL;\r\n}\r\n}\r\nstatic void esp_autosense(struct esp *esp, struct esp_cmd_entry *ent)\r\n{\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nstruct scsi_device *dev = cmd->device;\r\nint tgt, lun;\r\nu8 *p, val;\r\ntgt = dev->id;\r\nlun = dev->lun;\r\nif (!ent->sense_ptr) {\r\nesp_log_autosense("esp%d: Doing auto-sense for "\r\n"tgt[%d] lun[%d]\n",\r\nesp->host->unique_id, tgt, lun);\r\nent->sense_ptr = cmd->sense_buffer;\r\nent->sense_dma = esp->ops->map_single(esp,\r\nent->sense_ptr,\r\nSCSI_SENSE_BUFFERSIZE,\r\nDMA_FROM_DEVICE);\r\n}\r\nent->saved_sense_ptr = ent->sense_ptr;\r\nesp->active_cmd = ent;\r\np = esp->command_block;\r\nesp->msg_out_len = 0;\r\n*p++ = IDENTIFY(0, lun);\r\n*p++ = REQUEST_SENSE;\r\n*p++ = ((dev->scsi_level <= SCSI_2) ?\r\n(lun << 5) : 0);\r\n*p++ = 0;\r\n*p++ = 0;\r\n*p++ = SCSI_SENSE_BUFFERSIZE;\r\n*p++ = 0;\r\nesp->select_state = ESP_SELECT_BASIC;\r\nval = tgt;\r\nif (esp->rev == FASHME)\r\nval |= ESP_BUSID_RESELID | ESP_BUSID_CTR32BIT;\r\nesp_write8(val, ESP_BUSID);\r\nesp_write_tgt_sync(esp, tgt);\r\nesp_write_tgt_config3(esp, tgt);\r\nval = (p - esp->command_block);\r\nif (esp->rev == FASHME)\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nesp->ops->send_dma_cmd(esp, esp->command_block_dma,\r\nval, 16, 0, ESP_CMD_DMA | ESP_CMD_SELA);\r\n}\r\nstatic struct esp_cmd_entry *find_and_prep_issuable_command(struct esp *esp)\r\n{\r\nstruct esp_cmd_entry *ent;\r\nlist_for_each_entry(ent, &esp->queued_cmds, list) {\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nstruct scsi_device *dev = cmd->device;\r\nstruct esp_lun_data *lp = dev->hostdata;\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nent->tag[0] = 0;\r\nent->tag[1] = 0;\r\nreturn ent;\r\n}\r\nif (!scsi_populate_tag_msg(cmd, &ent->tag[0])) {\r\nent->tag[0] = 0;\r\nent->tag[1] = 0;\r\n}\r\nent->orig_tag[0] = ent->tag[0];\r\nent->orig_tag[1] = ent->tag[1];\r\nif (esp_alloc_lun_tag(ent, lp) < 0)\r\ncontinue;\r\nreturn ent;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void esp_maybe_execute_command(struct esp *esp)\r\n{\r\nstruct esp_target_data *tp;\r\nstruct esp_lun_data *lp;\r\nstruct scsi_device *dev;\r\nstruct scsi_cmnd *cmd;\r\nstruct esp_cmd_entry *ent;\r\nint tgt, lun, i;\r\nu32 val, start_cmd;\r\nu8 *p;\r\nif (esp->active_cmd ||\r\n(esp->flags & ESP_FLAG_RESETTING))\r\nreturn;\r\nent = find_and_prep_issuable_command(esp);\r\nif (!ent)\r\nreturn;\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nesp_autosense(esp, ent);\r\nreturn;\r\n}\r\ncmd = ent->cmd;\r\ndev = cmd->device;\r\ntgt = dev->id;\r\nlun = dev->lun;\r\ntp = &esp->target[tgt];\r\nlp = dev->hostdata;\r\nlist_move(&ent->list, &esp->active_cmds);\r\nesp->active_cmd = ent;\r\nesp_map_dma(esp, cmd);\r\nesp_save_pointers(esp, ent);\r\nesp_check_command_len(esp, cmd);\r\np = esp->command_block;\r\nesp->msg_out_len = 0;\r\nif (tp->flags & ESP_TGT_CHECK_NEGO) {\r\nif (tp->flags & ESP_TGT_BROKEN) {\r\ntp->flags &= ~ESP_TGT_DISCONNECT;\r\ntp->nego_goal_period = 0;\r\ntp->nego_goal_offset = 0;\r\ntp->nego_goal_width = 0;\r\ntp->nego_goal_tags = 0;\r\n}\r\nif (spi_width(tp->starget) == tp->nego_goal_width &&\r\nspi_period(tp->starget) == tp->nego_goal_period &&\r\nspi_offset(tp->starget) == tp->nego_goal_offset) {\r\ntp->flags &= ~ESP_TGT_CHECK_NEGO;\r\ngoto build_identify;\r\n}\r\nif (esp->rev == FASHME && esp_need_to_nego_wide(tp)) {\r\nesp->msg_out_len =\r\nspi_populate_width_msg(&esp->msg_out[0],\r\n(tp->nego_goal_width ?\r\n1 : 0));\r\ntp->flags |= ESP_TGT_NEGO_WIDE;\r\n} else if (esp_need_to_nego_sync(tp)) {\r\nesp->msg_out_len =\r\nspi_populate_sync_msg(&esp->msg_out[0],\r\ntp->nego_goal_period,\r\ntp->nego_goal_offset);\r\ntp->flags |= ESP_TGT_NEGO_SYNC;\r\n} else {\r\ntp->flags &= ~ESP_TGT_CHECK_NEGO;\r\n}\r\nif (tp->flags & (ESP_TGT_NEGO_WIDE | ESP_TGT_NEGO_SYNC))\r\nesp->flags |= ESP_FLAG_DOING_SLOWCMD;\r\n}\r\nbuild_identify:\r\nif (lp && (tp->flags & ESP_TGT_DISCONNECT) && ent->tag[0])\r\n*p++ = IDENTIFY(1, lun);\r\nelse\r\n*p++ = IDENTIFY(0, lun);\r\nif (ent->tag[0] && esp->rev == ESP100) {\r\nesp->flags |= ESP_FLAG_DOING_SLOWCMD;\r\n}\r\nif (!(esp->flags & ESP_FLAG_DOING_SLOWCMD)) {\r\nstart_cmd = ESP_CMD_DMA | ESP_CMD_SELA;\r\nif (ent->tag[0]) {\r\n*p++ = ent->tag[0];\r\n*p++ = ent->tag[1];\r\nstart_cmd = ESP_CMD_DMA | ESP_CMD_SA3;\r\n}\r\nfor (i = 0; i < cmd->cmd_len; i++)\r\n*p++ = cmd->cmnd[i];\r\nesp->select_state = ESP_SELECT_BASIC;\r\n} else {\r\nesp->cmd_bytes_left = cmd->cmd_len;\r\nesp->cmd_bytes_ptr = &cmd->cmnd[0];\r\nif (ent->tag[0]) {\r\nfor (i = esp->msg_out_len - 1;\r\ni >= 0; i--)\r\nesp->msg_out[i + 2] = esp->msg_out[i];\r\nesp->msg_out[0] = ent->tag[0];\r\nesp->msg_out[1] = ent->tag[1];\r\nesp->msg_out_len += 2;\r\n}\r\nstart_cmd = ESP_CMD_DMA | ESP_CMD_SELAS;\r\nesp->select_state = ESP_SELECT_MSGOUT;\r\n}\r\nval = tgt;\r\nif (esp->rev == FASHME)\r\nval |= ESP_BUSID_RESELID | ESP_BUSID_CTR32BIT;\r\nesp_write8(val, ESP_BUSID);\r\nesp_write_tgt_sync(esp, tgt);\r\nesp_write_tgt_config3(esp, tgt);\r\nval = (p - esp->command_block);\r\nif (esp_debug & ESP_DEBUG_SCSICMD) {\r\nprintk("ESP: tgt[%d] lun[%d] scsi_cmd [ ", tgt, lun);\r\nfor (i = 0; i < cmd->cmd_len; i++)\r\nprintk("%02x ", cmd->cmnd[i]);\r\nprintk("]\n");\r\n}\r\nif (esp->rev == FASHME)\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nesp->ops->send_dma_cmd(esp, esp->command_block_dma,\r\nval, 16, 0, start_cmd);\r\n}\r\nstatic struct esp_cmd_entry *esp_get_ent(struct esp *esp)\r\n{\r\nstruct list_head *head = &esp->esp_cmd_pool;\r\nstruct esp_cmd_entry *ret;\r\nif (list_empty(head)) {\r\nret = kzalloc(sizeof(struct esp_cmd_entry), GFP_ATOMIC);\r\n} else {\r\nret = list_entry(head->next, struct esp_cmd_entry, list);\r\nlist_del(&ret->list);\r\nmemset(ret, 0, sizeof(*ret));\r\n}\r\nreturn ret;\r\n}\r\nstatic void esp_put_ent(struct esp *esp, struct esp_cmd_entry *ent)\r\n{\r\nlist_add(&ent->list, &esp->esp_cmd_pool);\r\n}\r\nstatic void esp_cmd_is_done(struct esp *esp, struct esp_cmd_entry *ent,\r\nstruct scsi_cmnd *cmd, unsigned int result)\r\n{\r\nstruct scsi_device *dev = cmd->device;\r\nint tgt = dev->id;\r\nint lun = dev->lun;\r\nesp->active_cmd = NULL;\r\nesp_unmap_dma(esp, cmd);\r\nesp_free_lun_tag(ent, dev->hostdata);\r\ncmd->result = result;\r\nif (ent->eh_done) {\r\ncomplete(ent->eh_done);\r\nent->eh_done = NULL;\r\n}\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nesp->ops->unmap_single(esp, ent->sense_dma,\r\nSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nent->sense_ptr = NULL;\r\ncmd->result = ((DRIVER_SENSE << 24) |\r\n(DID_OK << 16) |\r\n(COMMAND_COMPLETE << 8) |\r\n(SAM_STAT_CHECK_CONDITION << 0));\r\nent->flags &= ~ESP_CMD_FLAG_AUTOSENSE;\r\nif (esp_debug & ESP_DEBUG_AUTOSENSE) {\r\nint i;\r\nprintk("esp%d: tgt[%d] lun[%d] AUTO SENSE[ ",\r\nesp->host->unique_id, tgt, lun);\r\nfor (i = 0; i < 18; i++)\r\nprintk("%02x ", cmd->sense_buffer[i]);\r\nprintk("]\n");\r\n}\r\n}\r\ncmd->scsi_done(cmd);\r\nlist_del(&ent->list);\r\nesp_put_ent(esp, ent);\r\nesp_maybe_execute_command(esp);\r\n}\r\nstatic unsigned int compose_result(unsigned int status, unsigned int message,\r\nunsigned int driver_code)\r\n{\r\nreturn (status | (message << 8) | (driver_code << 16));\r\n}\r\nstatic void esp_event_queue_full(struct esp *esp, struct esp_cmd_entry *ent)\r\n{\r\nstruct scsi_device *dev = ent->cmd->device;\r\nstruct esp_lun_data *lp = dev->hostdata;\r\nscsi_track_queue_full(dev, lp->num_tagged - 1);\r\n}\r\nstatic int esp_queuecommand_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct scsi_device *dev = cmd->device;\r\nstruct esp *esp = shost_priv(dev->host);\r\nstruct esp_cmd_priv *spriv;\r\nstruct esp_cmd_entry *ent;\r\nent = esp_get_ent(esp);\r\nif (!ent)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nent->cmd = cmd;\r\ncmd->scsi_done = done;\r\nspriv = ESP_CMD_PRIV(cmd);\r\nspriv->u.dma_addr = ~(dma_addr_t)0x0;\r\nlist_add_tail(&ent->list, &esp->queued_cmds);\r\nesp_maybe_execute_command(esp);\r\nreturn 0;\r\n}\r\nint esp_check_spur_intr(struct esp *esp)\r\n{\r\nswitch (esp->rev) {\r\ncase ESP100:\r\ncase ESP100A:\r\nesp->sreg &= ~ESP_STAT_INTR;\r\nbreak;\r\ndefault:\r\nif (!(esp->sreg & ESP_STAT_INTR)) {\r\nesp->ireg = esp_read8(ESP_INTRPT);\r\nif (esp->ireg & ESP_INTR_SR)\r\nreturn 1;\r\nif (!esp->ops->dma_error(esp)) {\r\nprintk(KERN_ERR PFX "esp%d: Spurious irq, "\r\n"sreg=%02x.\n",\r\nesp->host->unique_id, esp->sreg);\r\nreturn -1;\r\n}\r\nprintk(KERN_ERR PFX "esp%d: DMA error\n",\r\nesp->host->unique_id);\r\nreturn -1;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void esp_schedule_reset(struct esp *esp)\r\n{\r\nesp_log_reset("ESP: esp_schedule_reset() from %pf\n",\r\n__builtin_return_address(0));\r\nesp->flags |= ESP_FLAG_RESETTING;\r\nesp_event(esp, ESP_EVENT_RESET);\r\n}\r\nstatic struct esp_cmd_entry *esp_reconnect_with_tag(struct esp *esp,\r\nstruct esp_lun_data *lp)\r\n{\r\nstruct esp_cmd_entry *ent;\r\nint i;\r\nif (!lp->num_tagged) {\r\nprintk(KERN_ERR PFX "esp%d: Reconnect w/num_tagged==0\n",\r\nesp->host->unique_id);\r\nreturn NULL;\r\n}\r\nesp_log_reconnect("ESP: reconnect tag, ");\r\nfor (i = 0; i < ESP_QUICKIRQ_LIMIT; i++) {\r\nif (esp->ops->irq_pending(esp))\r\nbreak;\r\n}\r\nif (i == ESP_QUICKIRQ_LIMIT) {\r\nprintk(KERN_ERR PFX "esp%d: Reconnect IRQ1 timeout\n",\r\nesp->host->unique_id);\r\nreturn NULL;\r\n}\r\nesp->sreg = esp_read8(ESP_STATUS);\r\nesp->ireg = esp_read8(ESP_INTRPT);\r\nesp_log_reconnect("IRQ(%d:%x:%x), ",\r\ni, esp->ireg, esp->sreg);\r\nif (esp->ireg & ESP_INTR_DC) {\r\nprintk(KERN_ERR PFX "esp%d: Reconnect, got disconnect.\n",\r\nesp->host->unique_id);\r\nreturn NULL;\r\n}\r\nif ((esp->sreg & ESP_STAT_PMASK) != ESP_MIP) {\r\nprintk(KERN_ERR PFX "esp%d: Reconnect, not MIP sreg[%02x].\n",\r\nesp->host->unique_id, esp->sreg);\r\nreturn NULL;\r\n}\r\nesp->command_block[0] = 0xff;\r\nesp->command_block[1] = 0xff;\r\nesp->ops->send_dma_cmd(esp, esp->command_block_dma,\r\n2, 2, 1, ESP_CMD_DMA | ESP_CMD_TI);\r\nscsi_esp_cmd(esp, ESP_CMD_MOK);\r\nfor (i = 0; i < ESP_RESELECT_TAG_LIMIT; i++) {\r\nif (esp->ops->irq_pending(esp)) {\r\nesp->sreg = esp_read8(ESP_STATUS);\r\nesp->ireg = esp_read8(ESP_INTRPT);\r\nif (esp->ireg & ESP_INTR_FDONE)\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (i == ESP_RESELECT_TAG_LIMIT) {\r\nprintk(KERN_ERR PFX "esp%d: Reconnect IRQ2 timeout\n",\r\nesp->host->unique_id);\r\nreturn NULL;\r\n}\r\nesp->ops->dma_drain(esp);\r\nesp->ops->dma_invalidate(esp);\r\nesp_log_reconnect("IRQ2(%d:%x:%x) tag[%x:%x]\n",\r\ni, esp->ireg, esp->sreg,\r\nesp->command_block[0],\r\nesp->command_block[1]);\r\nif (esp->command_block[0] < SIMPLE_QUEUE_TAG ||\r\nesp->command_block[0] > ORDERED_QUEUE_TAG) {\r\nprintk(KERN_ERR PFX "esp%d: Reconnect, bad tag "\r\n"type %02x.\n",\r\nesp->host->unique_id, esp->command_block[0]);\r\nreturn NULL;\r\n}\r\nent = lp->tagged_cmds[esp->command_block[1]];\r\nif (!ent) {\r\nprintk(KERN_ERR PFX "esp%d: Reconnect, no entry for "\r\n"tag %02x.\n",\r\nesp->host->unique_id, esp->command_block[1]);\r\nreturn NULL;\r\n}\r\nreturn ent;\r\n}\r\nstatic int esp_reconnect(struct esp *esp)\r\n{\r\nstruct esp_cmd_entry *ent;\r\nstruct esp_target_data *tp;\r\nstruct esp_lun_data *lp;\r\nstruct scsi_device *dev;\r\nint target, lun;\r\nBUG_ON(esp->active_cmd);\r\nif (esp->rev == FASHME) {\r\ntarget = esp->fifo[0];\r\nlun = esp->fifo[1] & 0x7;\r\n} else {\r\nu8 bits = esp_read8(ESP_FDATA);\r\nif (!(bits & esp->scsi_id_mask))\r\ngoto do_reset;\r\nbits &= ~esp->scsi_id_mask;\r\nif (!bits || (bits & (bits - 1)))\r\ngoto do_reset;\r\ntarget = ffs(bits) - 1;\r\nlun = (esp_read8(ESP_FDATA) & 0x7);\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nif (esp->rev == ESP100) {\r\nu8 ireg = esp_read8(ESP_INTRPT);\r\nif (ireg & ESP_INTR_SR)\r\ngoto do_reset;\r\n}\r\nscsi_esp_cmd(esp, ESP_CMD_NULL);\r\n}\r\nesp_write_tgt_sync(esp, target);\r\nesp_write_tgt_config3(esp, target);\r\nscsi_esp_cmd(esp, ESP_CMD_MOK);\r\nif (esp->rev == FASHME)\r\nesp_write8(target | ESP_BUSID_RESELID | ESP_BUSID_CTR32BIT,\r\nESP_BUSID);\r\ntp = &esp->target[target];\r\ndev = __scsi_device_lookup_by_target(tp->starget, lun);\r\nif (!dev) {\r\nprintk(KERN_ERR PFX "esp%d: Reconnect, no lp "\r\n"tgt[%u] lun[%u]\n",\r\nesp->host->unique_id, target, lun);\r\ngoto do_reset;\r\n}\r\nlp = dev->hostdata;\r\nent = lp->non_tagged_cmd;\r\nif (!ent) {\r\nent = esp_reconnect_with_tag(esp, lp);\r\nif (!ent)\r\ngoto do_reset;\r\n}\r\nesp->active_cmd = ent;\r\nif (ent->flags & ESP_CMD_FLAG_ABORT) {\r\nesp->msg_out[0] = ABORT_TASK_SET;\r\nesp->msg_out_len = 1;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\n}\r\nesp_event(esp, ESP_EVENT_CHECK_PHASE);\r\nesp_restore_pointers(esp, ent);\r\nesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\r\nreturn 1;\r\ndo_reset:\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nstatic int esp_finish_select(struct esp *esp)\r\n{\r\nstruct esp_cmd_entry *ent;\r\nstruct scsi_cmnd *cmd;\r\nu8 orig_select_state;\r\norig_select_state = esp->select_state;\r\nesp->select_state = ESP_SELECT_NONE;\r\nesp->seqreg = esp_read8(ESP_SSTEP) & ESP_STEP_VBITS;\r\nent = esp->active_cmd;\r\ncmd = ent->cmd;\r\nif (esp->ops->dma_error(esp)) {\r\nesp_schedule_reset(esp);\r\nesp_cmd_is_done(esp, ent, cmd, (DID_ERROR << 16));\r\nreturn 0;\r\n}\r\nesp->ops->dma_invalidate(esp);\r\nif (esp->ireg == (ESP_INTR_RSEL | ESP_INTR_FDONE)) {\r\nstruct esp_target_data *tp = &esp->target[cmd->device->id];\r\nif (!(ent->flags & ESP_CMD_FLAG_AUTOSENSE)) {\r\nesp_unmap_dma(esp, cmd);\r\nesp_free_lun_tag(ent, cmd->device->hostdata);\r\ntp->flags &= ~(ESP_TGT_NEGO_SYNC | ESP_TGT_NEGO_WIDE);\r\nesp->flags &= ~ESP_FLAG_DOING_SLOWCMD;\r\nesp->cmd_bytes_ptr = NULL;\r\nesp->cmd_bytes_left = 0;\r\n} else {\r\nesp->ops->unmap_single(esp, ent->sense_dma,\r\nSCSI_SENSE_BUFFERSIZE,\r\nDMA_FROM_DEVICE);\r\nent->sense_ptr = NULL;\r\n}\r\nlist_move(&ent->list, &esp->queued_cmds);\r\nesp->active_cmd = NULL;\r\nreturn 0;\r\n}\r\nif (esp->ireg == ESP_INTR_DC) {\r\nstruct scsi_device *dev = cmd->device;\r\nesp->target[dev->id].flags |= ESP_TGT_CHECK_NEGO;\r\nscsi_esp_cmd(esp, ESP_CMD_ESEL);\r\nesp_cmd_is_done(esp, ent, cmd, (DID_BAD_TARGET << 16));\r\nreturn 1;\r\n}\r\nif (esp->ireg == (ESP_INTR_FDONE | ESP_INTR_BSERV)) {\r\nif (esp->rev <= ESP236) {\r\nint fcnt = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;\r\nscsi_esp_cmd(esp, ESP_CMD_NULL);\r\nif (!fcnt &&\r\n(!esp->prev_soff ||\r\n((esp->sreg & ESP_STAT_PMASK) != ESP_DIP)))\r\nesp_flush_fifo(esp);\r\n}\r\nesp_event(esp, ESP_EVENT_CHECK_PHASE);\r\nreturn 0;\r\n}\r\nprintk("ESP: Unexpected selection completion ireg[%x].\n",\r\nesp->ireg);\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nstatic int esp_data_bytes_sent(struct esp *esp, struct esp_cmd_entry *ent,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nint fifo_cnt, ecount, bytes_sent, flush_fifo;\r\nfifo_cnt = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;\r\nif (esp->prev_cfg3 & ESP_CONFIG3_EWIDE)\r\nfifo_cnt <<= 1;\r\necount = 0;\r\nif (!(esp->sreg & ESP_STAT_TCNT)) {\r\necount = ((unsigned int)esp_read8(ESP_TCLOW) |\r\n(((unsigned int)esp_read8(ESP_TCMED)) << 8));\r\nif (esp->rev == FASHME)\r\necount |= ((unsigned int)esp_read8(FAS_RLO)) << 16;\r\n}\r\nbytes_sent = esp->data_dma_len;\r\nbytes_sent -= ecount;\r\nif (!(ent->flags & ESP_CMD_FLAG_WRITE))\r\nbytes_sent -= fifo_cnt;\r\nflush_fifo = 0;\r\nif (!esp->prev_soff) {\r\nflush_fifo = 1;\r\n} else {\r\nif (esp->rev == ESP100) {\r\nu32 fflags, phase;\r\nesp->sreg = esp_read8(ESP_STATUS);\r\nphase = esp->sreg & ESP_STAT_PMASK;\r\nfflags = esp_read8(ESP_FFLAGS);\r\nif ((phase == ESP_DOP &&\r\n(fflags & ESP_FF_ONOTZERO)) ||\r\n(phase == ESP_DIP &&\r\n(fflags & ESP_FF_FBYTES)))\r\nreturn -1;\r\n}\r\nif (!(ent->flags & ESP_CMD_FLAG_WRITE))\r\nflush_fifo = 1;\r\n}\r\nif (flush_fifo)\r\nesp_flush_fifo(esp);\r\nreturn bytes_sent;\r\n}\r\nstatic void esp_setsync(struct esp *esp, struct esp_target_data *tp,\r\nu8 scsi_period, u8 scsi_offset,\r\nu8 esp_stp, u8 esp_soff)\r\n{\r\nspi_period(tp->starget) = scsi_period;\r\nspi_offset(tp->starget) = scsi_offset;\r\nspi_width(tp->starget) = (tp->flags & ESP_TGT_WIDE) ? 1 : 0;\r\nif (esp_soff) {\r\nesp_stp &= 0x1f;\r\nesp_soff |= esp->radelay;\r\nif (esp->rev >= FAS236) {\r\nu8 bit = ESP_CONFIG3_FSCSI;\r\nif (esp->rev >= FAS100A)\r\nbit = ESP_CONFIG3_FAST;\r\nif (scsi_period < 50) {\r\nif (esp->rev == FASHME)\r\nesp_soff &= ~esp->radelay;\r\ntp->esp_config3 |= bit;\r\n} else {\r\ntp->esp_config3 &= ~bit;\r\n}\r\nesp->prev_cfg3 = tp->esp_config3;\r\nesp_write8(esp->prev_cfg3, ESP_CFG3);\r\n}\r\n}\r\ntp->esp_period = esp->prev_stp = esp_stp;\r\ntp->esp_offset = esp->prev_soff = esp_soff;\r\nesp_write8(esp_soff, ESP_SOFF);\r\nesp_write8(esp_stp, ESP_STP);\r\ntp->flags &= ~(ESP_TGT_NEGO_SYNC | ESP_TGT_CHECK_NEGO);\r\nspi_display_xfer_agreement(tp->starget);\r\n}\r\nstatic void esp_msgin_reject(struct esp *esp)\r\n{\r\nstruct esp_cmd_entry *ent = esp->active_cmd;\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nstruct esp_target_data *tp;\r\nint tgt;\r\ntgt = cmd->device->id;\r\ntp = &esp->target[tgt];\r\nif (tp->flags & ESP_TGT_NEGO_WIDE) {\r\ntp->flags &= ~(ESP_TGT_NEGO_WIDE | ESP_TGT_WIDE);\r\nif (!esp_need_to_nego_sync(tp)) {\r\ntp->flags &= ~ESP_TGT_CHECK_NEGO;\r\nscsi_esp_cmd(esp, ESP_CMD_RATN);\r\n} else {\r\nesp->msg_out_len =\r\nspi_populate_sync_msg(&esp->msg_out[0],\r\ntp->nego_goal_period,\r\ntp->nego_goal_offset);\r\ntp->flags |= ESP_TGT_NEGO_SYNC;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\n}\r\nreturn;\r\n}\r\nif (tp->flags & ESP_TGT_NEGO_SYNC) {\r\ntp->flags &= ~(ESP_TGT_NEGO_SYNC | ESP_TGT_CHECK_NEGO);\r\ntp->esp_period = 0;\r\ntp->esp_offset = 0;\r\nesp_setsync(esp, tp, 0, 0, 0, 0);\r\nscsi_esp_cmd(esp, ESP_CMD_RATN);\r\nreturn;\r\n}\r\nesp->msg_out[0] = ABORT_TASK_SET;\r\nesp->msg_out_len = 1;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\n}\r\nstatic void esp_msgin_sdtr(struct esp *esp, struct esp_target_data *tp)\r\n{\r\nu8 period = esp->msg_in[3];\r\nu8 offset = esp->msg_in[4];\r\nu8 stp;\r\nif (!(tp->flags & ESP_TGT_NEGO_SYNC))\r\ngoto do_reject;\r\nif (offset > 15)\r\ngoto do_reject;\r\nif (offset) {\r\nint one_clock;\r\nif (period > esp->max_period) {\r\nperiod = offset = 0;\r\ngoto do_sdtr;\r\n}\r\nif (period < esp->min_period)\r\ngoto do_reject;\r\none_clock = esp->ccycle / 1000;\r\nstp = DIV_ROUND_UP(period << 2, one_clock);\r\nif (stp && esp->rev >= FAS236) {\r\nif (stp >= 50)\r\nstp--;\r\n}\r\n} else {\r\nstp = 0;\r\n}\r\nesp_setsync(esp, tp, period, offset, stp, offset);\r\nreturn;\r\ndo_reject:\r\nesp->msg_out[0] = MESSAGE_REJECT;\r\nesp->msg_out_len = 1;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\nreturn;\r\ndo_sdtr:\r\ntp->nego_goal_period = period;\r\ntp->nego_goal_offset = offset;\r\nesp->msg_out_len =\r\nspi_populate_sync_msg(&esp->msg_out[0],\r\ntp->nego_goal_period,\r\ntp->nego_goal_offset);\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\n}\r\nstatic void esp_msgin_wdtr(struct esp *esp, struct esp_target_data *tp)\r\n{\r\nint size = 8 << esp->msg_in[3];\r\nu8 cfg3;\r\nif (esp->rev != FASHME)\r\ngoto do_reject;\r\nif (size != 8 && size != 16)\r\ngoto do_reject;\r\nif (!(tp->flags & ESP_TGT_NEGO_WIDE))\r\ngoto do_reject;\r\ncfg3 = tp->esp_config3;\r\nif (size == 16) {\r\ntp->flags |= ESP_TGT_WIDE;\r\ncfg3 |= ESP_CONFIG3_EWIDE;\r\n} else {\r\ntp->flags &= ~ESP_TGT_WIDE;\r\ncfg3 &= ~ESP_CONFIG3_EWIDE;\r\n}\r\ntp->esp_config3 = cfg3;\r\nesp->prev_cfg3 = cfg3;\r\nesp_write8(cfg3, ESP_CFG3);\r\ntp->flags &= ~ESP_TGT_NEGO_WIDE;\r\nspi_period(tp->starget) = 0;\r\nspi_offset(tp->starget) = 0;\r\nif (!esp_need_to_nego_sync(tp)) {\r\ntp->flags &= ~ESP_TGT_CHECK_NEGO;\r\nscsi_esp_cmd(esp, ESP_CMD_RATN);\r\n} else {\r\nesp->msg_out_len =\r\nspi_populate_sync_msg(&esp->msg_out[0],\r\ntp->nego_goal_period,\r\ntp->nego_goal_offset);\r\ntp->flags |= ESP_TGT_NEGO_SYNC;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\n}\r\nreturn;\r\ndo_reject:\r\nesp->msg_out[0] = MESSAGE_REJECT;\r\nesp->msg_out_len = 1;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\n}\r\nstatic void esp_msgin_extended(struct esp *esp)\r\n{\r\nstruct esp_cmd_entry *ent = esp->active_cmd;\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nstruct esp_target_data *tp;\r\nint tgt = cmd->device->id;\r\ntp = &esp->target[tgt];\r\nif (esp->msg_in[2] == EXTENDED_SDTR) {\r\nesp_msgin_sdtr(esp, tp);\r\nreturn;\r\n}\r\nif (esp->msg_in[2] == EXTENDED_WDTR) {\r\nesp_msgin_wdtr(esp, tp);\r\nreturn;\r\n}\r\nprintk("ESP: Unexpected extended msg type %x\n",\r\nesp->msg_in[2]);\r\nesp->msg_out[0] = ABORT_TASK_SET;\r\nesp->msg_out_len = 1;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\n}\r\nstatic int esp_msgin_process(struct esp *esp)\r\n{\r\nu8 msg0 = esp->msg_in[0];\r\nint len = esp->msg_in_len;\r\nif (msg0 & 0x80) {\r\nprintk("ESP: Unexpected msgin identify\n");\r\nreturn 0;\r\n}\r\nswitch (msg0) {\r\ncase EXTENDED_MESSAGE:\r\nif (len == 1)\r\nreturn 1;\r\nif (len < esp->msg_in[1] + 2)\r\nreturn 1;\r\nesp_msgin_extended(esp);\r\nreturn 0;\r\ncase IGNORE_WIDE_RESIDUE: {\r\nstruct esp_cmd_entry *ent;\r\nstruct esp_cmd_priv *spriv;\r\nif (len == 1)\r\nreturn 1;\r\nif (esp->msg_in[1] != 1)\r\ngoto do_reject;\r\nent = esp->active_cmd;\r\nspriv = ESP_CMD_PRIV(ent->cmd);\r\nif (spriv->cur_residue == sg_dma_len(spriv->cur_sg)) {\r\nspriv->cur_sg--;\r\nspriv->cur_residue = 1;\r\n} else\r\nspriv->cur_residue++;\r\nspriv->tot_residue++;\r\nreturn 0;\r\n}\r\ncase NOP:\r\nreturn 0;\r\ncase RESTORE_POINTERS:\r\nesp_restore_pointers(esp, esp->active_cmd);\r\nreturn 0;\r\ncase SAVE_POINTERS:\r\nesp_save_pointers(esp, esp->active_cmd);\r\nreturn 0;\r\ncase COMMAND_COMPLETE:\r\ncase DISCONNECT: {\r\nstruct esp_cmd_entry *ent = esp->active_cmd;\r\nent->message = msg0;\r\nesp_event(esp, ESP_EVENT_FREE_BUS);\r\nesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\r\nreturn 0;\r\n}\r\ncase MESSAGE_REJECT:\r\nesp_msgin_reject(esp);\r\nreturn 0;\r\ndefault:\r\ndo_reject:\r\nesp->msg_out[0] = MESSAGE_REJECT;\r\nesp->msg_out_len = 1;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\nreturn 0;\r\n}\r\n}\r\nstatic int esp_process_event(struct esp *esp)\r\n{\r\nint write;\r\nagain:\r\nwrite = 0;\r\nswitch (esp->event) {\r\ncase ESP_EVENT_CHECK_PHASE:\r\nswitch (esp->sreg & ESP_STAT_PMASK) {\r\ncase ESP_DOP:\r\nesp_event(esp, ESP_EVENT_DATA_OUT);\r\nbreak;\r\ncase ESP_DIP:\r\nesp_event(esp, ESP_EVENT_DATA_IN);\r\nbreak;\r\ncase ESP_STATP:\r\nesp_flush_fifo(esp);\r\nscsi_esp_cmd(esp, ESP_CMD_ICCSEQ);\r\nesp_event(esp, ESP_EVENT_STATUS);\r\nesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\r\nreturn 1;\r\ncase ESP_MOP:\r\nesp_event(esp, ESP_EVENT_MSGOUT);\r\nbreak;\r\ncase ESP_MIP:\r\nesp_event(esp, ESP_EVENT_MSGIN);\r\nbreak;\r\ncase ESP_CMDP:\r\nesp_event(esp, ESP_EVENT_CMD_START);\r\nbreak;\r\ndefault:\r\nprintk("ESP: Unexpected phase, sreg=%02x\n",\r\nesp->sreg);\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\ngoto again;\r\nbreak;\r\ncase ESP_EVENT_DATA_IN:\r\nwrite = 1;\r\ncase ESP_EVENT_DATA_OUT: {\r\nstruct esp_cmd_entry *ent = esp->active_cmd;\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\ndma_addr_t dma_addr = esp_cur_dma_addr(ent, cmd);\r\nunsigned int dma_len = esp_cur_dma_len(ent, cmd);\r\nif (esp->rev == ESP100)\r\nscsi_esp_cmd(esp, ESP_CMD_NULL);\r\nif (write)\r\nent->flags |= ESP_CMD_FLAG_WRITE;\r\nelse\r\nent->flags &= ~ESP_CMD_FLAG_WRITE;\r\nif (esp->ops->dma_length_limit)\r\ndma_len = esp->ops->dma_length_limit(esp, dma_addr,\r\ndma_len);\r\nelse\r\ndma_len = esp_dma_length_limit(esp, dma_addr, dma_len);\r\nesp->data_dma_len = dma_len;\r\nif (!dma_len) {\r\nprintk(KERN_ERR PFX "esp%d: DMA length is zero!\n",\r\nesp->host->unique_id);\r\nprintk(KERN_ERR PFX "esp%d: cur adr[%08llx] len[%08x]\n",\r\nesp->host->unique_id,\r\n(unsigned long long)esp_cur_dma_addr(ent, cmd),\r\nesp_cur_dma_len(ent, cmd));\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nesp_log_datastart("ESP: start data addr[%08llx] len[%u] "\r\n"write(%d)\n",\r\n(unsigned long long)dma_addr, dma_len, write);\r\nesp->ops->send_dma_cmd(esp, dma_addr, dma_len, dma_len,\r\nwrite, ESP_CMD_DMA | ESP_CMD_TI);\r\nesp_event(esp, ESP_EVENT_DATA_DONE);\r\nbreak;\r\n}\r\ncase ESP_EVENT_DATA_DONE: {\r\nstruct esp_cmd_entry *ent = esp->active_cmd;\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nint bytes_sent;\r\nif (esp->ops->dma_error(esp)) {\r\nprintk("ESP: data done, DMA error, resetting\n");\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nif (ent->flags & ESP_CMD_FLAG_WRITE) {\r\nesp->ops->dma_drain(esp);\r\n}\r\nesp->ops->dma_invalidate(esp);\r\nif (esp->ireg != ESP_INTR_BSERV) {\r\nprintk("ESP: data done, not BSERV, resetting\n");\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nbytes_sent = esp_data_bytes_sent(esp, ent, cmd);\r\nesp_log_datadone("ESP: data done flgs[%x] sent[%d]\n",\r\nent->flags, bytes_sent);\r\nif (bytes_sent < 0) {\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nesp_advance_dma(esp, ent, cmd, bytes_sent);\r\nesp_event(esp, ESP_EVENT_CHECK_PHASE);\r\ngoto again;\r\n}\r\ncase ESP_EVENT_STATUS: {\r\nstruct esp_cmd_entry *ent = esp->active_cmd;\r\nif (esp->ireg & ESP_INTR_FDONE) {\r\nent->status = esp_read8(ESP_FDATA);\r\nent->message = esp_read8(ESP_FDATA);\r\nscsi_esp_cmd(esp, ESP_CMD_MOK);\r\n} else if (esp->ireg == ESP_INTR_BSERV) {\r\nent->status = esp_read8(ESP_FDATA);\r\nent->message = 0xff;\r\nesp_event(esp, ESP_EVENT_MSGIN);\r\nreturn 0;\r\n}\r\nif (ent->message != COMMAND_COMPLETE) {\r\nprintk("ESP: Unexpected message %x in status\n",\r\nent->message);\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nesp_event(esp, ESP_EVENT_FREE_BUS);\r\nesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\r\nbreak;\r\n}\r\ncase ESP_EVENT_FREE_BUS: {\r\nstruct esp_cmd_entry *ent = esp->active_cmd;\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nif (ent->message == COMMAND_COMPLETE ||\r\nent->message == DISCONNECT)\r\nscsi_esp_cmd(esp, ESP_CMD_ESEL);\r\nif (ent->message == COMMAND_COMPLETE) {\r\nesp_log_cmddone("ESP: Command done status[%x] "\r\n"message[%x]\n",\r\nent->status, ent->message);\r\nif (ent->status == SAM_STAT_TASK_SET_FULL)\r\nesp_event_queue_full(esp, ent);\r\nif (ent->status == SAM_STAT_CHECK_CONDITION &&\r\n!(ent->flags & ESP_CMD_FLAG_AUTOSENSE)) {\r\nent->flags |= ESP_CMD_FLAG_AUTOSENSE;\r\nesp_autosense(esp, ent);\r\n} else {\r\nesp_cmd_is_done(esp, ent, cmd,\r\ncompose_result(ent->status,\r\nent->message,\r\nDID_OK));\r\n}\r\n} else if (ent->message == DISCONNECT) {\r\nesp_log_disconnect("ESP: Disconnecting tgt[%d] "\r\n"tag[%x:%x]\n",\r\ncmd->device->id,\r\nent->tag[0], ent->tag[1]);\r\nesp->active_cmd = NULL;\r\nesp_maybe_execute_command(esp);\r\n} else {\r\nprintk("ESP: Unexpected message %x in freebus\n",\r\nent->message);\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nif (esp->active_cmd)\r\nesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\r\nbreak;\r\n}\r\ncase ESP_EVENT_MSGOUT: {\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nif (esp_debug & ESP_DEBUG_MSGOUT) {\r\nint i;\r\nprintk("ESP: Sending message [ ");\r\nfor (i = 0; i < esp->msg_out_len; i++)\r\nprintk("%02x ", esp->msg_out[i]);\r\nprintk("]\n");\r\n}\r\nif (esp->rev == FASHME) {\r\nint i;\r\nfor (i = 0; i < esp->msg_out_len; i++) {\r\nesp_write8(esp->msg_out[i], ESP_FDATA);\r\nesp_write8(0, ESP_FDATA);\r\n}\r\nscsi_esp_cmd(esp, ESP_CMD_TI);\r\n} else {\r\nif (esp->msg_out_len == 1) {\r\nesp_write8(esp->msg_out[0], ESP_FDATA);\r\nscsi_esp_cmd(esp, ESP_CMD_TI);\r\n} else {\r\nmemcpy(esp->command_block,\r\nesp->msg_out,\r\nesp->msg_out_len);\r\nesp->ops->send_dma_cmd(esp,\r\nesp->command_block_dma,\r\nesp->msg_out_len,\r\nesp->msg_out_len,\r\n0,\r\nESP_CMD_DMA|ESP_CMD_TI);\r\n}\r\n}\r\nesp_event(esp, ESP_EVENT_MSGOUT_DONE);\r\nbreak;\r\n}\r\ncase ESP_EVENT_MSGOUT_DONE:\r\nif (esp->rev == FASHME) {\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\n} else {\r\nif (esp->msg_out_len > 1)\r\nesp->ops->dma_invalidate(esp);\r\n}\r\nif (!(esp->ireg & ESP_INTR_DC)) {\r\nif (esp->rev != FASHME)\r\nscsi_esp_cmd(esp, ESP_CMD_NULL);\r\n}\r\nesp_event(esp, ESP_EVENT_CHECK_PHASE);\r\ngoto again;\r\ncase ESP_EVENT_MSGIN:\r\nif (esp->ireg & ESP_INTR_BSERV) {\r\nif (esp->rev == FASHME) {\r\nif (!(esp_read8(ESP_STATUS2) &\r\nESP_STAT2_FEMPTY))\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\n} else {\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nif (esp->rev == ESP100)\r\nscsi_esp_cmd(esp, ESP_CMD_NULL);\r\n}\r\nscsi_esp_cmd(esp, ESP_CMD_TI);\r\nesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\r\nreturn 1;\r\n}\r\nif (esp->ireg & ESP_INTR_FDONE) {\r\nu8 val;\r\nif (esp->rev == FASHME)\r\nval = esp->fifo[0];\r\nelse\r\nval = esp_read8(ESP_FDATA);\r\nesp->msg_in[esp->msg_in_len++] = val;\r\nesp_log_msgin("ESP: Got msgin byte %x\n", val);\r\nif (!esp_msgin_process(esp))\r\nesp->msg_in_len = 0;\r\nif (esp->rev == FASHME)\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nscsi_esp_cmd(esp, ESP_CMD_MOK);\r\nif (esp->event != ESP_EVENT_FREE_BUS)\r\nesp_event(esp, ESP_EVENT_CHECK_PHASE);\r\n} else {\r\nprintk("ESP: MSGIN neither BSERV not FDON, resetting");\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ESP_EVENT_CMD_START:\r\nmemcpy(esp->command_block, esp->cmd_bytes_ptr,\r\nesp->cmd_bytes_left);\r\nif (esp->rev == FASHME)\r\nscsi_esp_cmd(esp, ESP_CMD_FLUSH);\r\nesp->ops->send_dma_cmd(esp, esp->command_block_dma,\r\nesp->cmd_bytes_left, 16, 0,\r\nESP_CMD_DMA | ESP_CMD_TI);\r\nesp_event(esp, ESP_EVENT_CMD_DONE);\r\nesp->flags |= ESP_FLAG_QUICKIRQ_CHECK;\r\nbreak;\r\ncase ESP_EVENT_CMD_DONE:\r\nesp->ops->dma_invalidate(esp);\r\nif (esp->ireg & ESP_INTR_BSERV) {\r\nesp_event(esp, ESP_EVENT_CHECK_PHASE);\r\ngoto again;\r\n}\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\nbreak;\r\ncase ESP_EVENT_RESET:\r\nscsi_esp_cmd(esp, ESP_CMD_RS);\r\nbreak;\r\ndefault:\r\nprintk("ESP: Unexpected event %x, resetting\n",\r\nesp->event);\r\nesp_schedule_reset(esp);\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic void esp_reset_cleanup_one(struct esp *esp, struct esp_cmd_entry *ent)\r\n{\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nesp_unmap_dma(esp, cmd);\r\nesp_free_lun_tag(ent, cmd->device->hostdata);\r\ncmd->result = DID_RESET << 16;\r\nif (ent->flags & ESP_CMD_FLAG_AUTOSENSE) {\r\nesp->ops->unmap_single(esp, ent->sense_dma,\r\nSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nent->sense_ptr = NULL;\r\n}\r\ncmd->scsi_done(cmd);\r\nlist_del(&ent->list);\r\nesp_put_ent(esp, ent);\r\n}\r\nstatic void esp_clear_hold(struct scsi_device *dev, void *data)\r\n{\r\nstruct esp_lun_data *lp = dev->hostdata;\r\nBUG_ON(lp->num_tagged);\r\nlp->hold = 0;\r\n}\r\nstatic void esp_reset_cleanup(struct esp *esp)\r\n{\r\nstruct esp_cmd_entry *ent, *tmp;\r\nint i;\r\nlist_for_each_entry_safe(ent, tmp, &esp->queued_cmds, list) {\r\nstruct scsi_cmnd *cmd = ent->cmd;\r\nlist_del(&ent->list);\r\ncmd->result = DID_RESET << 16;\r\ncmd->scsi_done(cmd);\r\nesp_put_ent(esp, ent);\r\n}\r\nlist_for_each_entry_safe(ent, tmp, &esp->active_cmds, list) {\r\nif (ent == esp->active_cmd)\r\nesp->active_cmd = NULL;\r\nesp_reset_cleanup_one(esp, ent);\r\n}\r\nBUG_ON(esp->active_cmd != NULL);\r\nfor (i = 0; i < ESP_MAX_TARGET; i++) {\r\nstruct esp_target_data *tp = &esp->target[i];\r\ntp->esp_period = 0;\r\ntp->esp_offset = 0;\r\ntp->esp_config3 &= ~(ESP_CONFIG3_EWIDE |\r\nESP_CONFIG3_FSCSI |\r\nESP_CONFIG3_FAST);\r\ntp->flags &= ~ESP_TGT_WIDE;\r\ntp->flags |= ESP_TGT_CHECK_NEGO;\r\nif (tp->starget)\r\n__starget_for_each_device(tp->starget, NULL,\r\nesp_clear_hold);\r\n}\r\nesp->flags &= ~ESP_FLAG_RESETTING;\r\n}\r\nstatic void __esp_interrupt(struct esp *esp)\r\n{\r\nint finish_reset, intr_done;\r\nu8 phase;\r\nesp->sreg = esp_read8(ESP_STATUS);\r\nif (esp->flags & ESP_FLAG_RESETTING) {\r\nfinish_reset = 1;\r\n} else {\r\nif (esp_check_gross_error(esp))\r\nreturn;\r\nfinish_reset = esp_check_spur_intr(esp);\r\nif (finish_reset < 0)\r\nreturn;\r\n}\r\nesp->ireg = esp_read8(ESP_INTRPT);\r\nif (esp->ireg & ESP_INTR_SR)\r\nfinish_reset = 1;\r\nif (finish_reset) {\r\nesp_reset_cleanup(esp);\r\nif (esp->eh_reset) {\r\ncomplete(esp->eh_reset);\r\nesp->eh_reset = NULL;\r\n}\r\nreturn;\r\n}\r\nphase = (esp->sreg & ESP_STAT_PMASK);\r\nif (esp->rev == FASHME) {\r\nif (((phase != ESP_DIP && phase != ESP_DOP) &&\r\nesp->select_state == ESP_SELECT_NONE &&\r\nesp->event != ESP_EVENT_STATUS &&\r\nesp->event != ESP_EVENT_DATA_DONE) ||\r\n(esp->ireg & ESP_INTR_RSEL)) {\r\nesp->sreg2 = esp_read8(ESP_STATUS2);\r\nif (!(esp->sreg2 & ESP_STAT2_FEMPTY) ||\r\n(esp->sreg2 & ESP_STAT2_F1BYTE))\r\nhme_read_fifo(esp);\r\n}\r\n}\r\nesp_log_intr("ESP: intr sreg[%02x] seqreg[%02x] "\r\n"sreg2[%02x] ireg[%02x]\n",\r\nesp->sreg, esp->seqreg, esp->sreg2, esp->ireg);\r\nintr_done = 0;\r\nif (esp->ireg & (ESP_INTR_S | ESP_INTR_SATN | ESP_INTR_IC)) {\r\nprintk("ESP: unexpected IREG %02x\n", esp->ireg);\r\nif (esp->ireg & ESP_INTR_IC)\r\nesp_dump_cmd_log(esp);\r\nesp_schedule_reset(esp);\r\n} else {\r\nif (!(esp->ireg & ESP_INTR_RSEL)) {\r\nif (esp->select_state != ESP_SELECT_NONE)\r\nintr_done = esp_finish_select(esp);\r\n} else if (esp->ireg & ESP_INTR_RSEL) {\r\nif (esp->active_cmd)\r\n(void) esp_finish_select(esp);\r\nintr_done = esp_reconnect(esp);\r\n}\r\n}\r\nwhile (!intr_done)\r\nintr_done = esp_process_event(esp);\r\n}\r\nirqreturn_t scsi_esp_intr(int irq, void *dev_id)\r\n{\r\nstruct esp *esp = dev_id;\r\nunsigned long flags;\r\nirqreturn_t ret;\r\nspin_lock_irqsave(esp->host->host_lock, flags);\r\nret = IRQ_NONE;\r\nif (esp->ops->irq_pending(esp)) {\r\nret = IRQ_HANDLED;\r\nfor (;;) {\r\nint i;\r\n__esp_interrupt(esp);\r\nif (!(esp->flags & ESP_FLAG_QUICKIRQ_CHECK))\r\nbreak;\r\nesp->flags &= ~ESP_FLAG_QUICKIRQ_CHECK;\r\nfor (i = 0; i < ESP_QUICKIRQ_LIMIT; i++) {\r\nif (esp->ops->irq_pending(esp))\r\nbreak;\r\n}\r\nif (i == ESP_QUICKIRQ_LIMIT)\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void esp_get_revision(struct esp *esp)\r\n{\r\nu8 val;\r\nesp->config1 = (ESP_CONFIG1_PENABLE | (esp->scsi_id & 7));\r\nesp->config2 = (ESP_CONFIG2_SCSI2ENAB | ESP_CONFIG2_REGPARITY);\r\nesp_write8(esp->config2, ESP_CFG2);\r\nval = esp_read8(ESP_CFG2);\r\nval &= ~ESP_CONFIG2_MAGIC;\r\nif (val != (ESP_CONFIG2_SCSI2ENAB | ESP_CONFIG2_REGPARITY)) {\r\nesp->rev = ESP100;\r\n} else {\r\nesp->config2 = 0;\r\nesp_set_all_config3(esp, 5);\r\nesp->prev_cfg3 = 5;\r\nesp_write8(esp->config2, ESP_CFG2);\r\nesp_write8(0, ESP_CFG3);\r\nesp_write8(esp->prev_cfg3, ESP_CFG3);\r\nval = esp_read8(ESP_CFG3);\r\nif (val != 5) {\r\nesp->rev = ESP100A;\r\n} else {\r\nesp_set_all_config3(esp, 0);\r\nesp->prev_cfg3 = 0;\r\nesp_write8(esp->prev_cfg3, ESP_CFG3);\r\nif (esp->cfact == 0 || esp->cfact > ESP_CCF_F5) {\r\nesp->rev = FAST;\r\nesp->sync_defp = SYNC_DEFP_FAST;\r\n} else {\r\nesp->rev = ESP236;\r\n}\r\nesp->config2 = 0;\r\nesp_write8(esp->config2, ESP_CFG2);\r\n}\r\n}\r\n}\r\nstatic void esp_init_swstate(struct esp *esp)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&esp->queued_cmds);\r\nINIT_LIST_HEAD(&esp->active_cmds);\r\nINIT_LIST_HEAD(&esp->esp_cmd_pool);\r\nfor (i = 0 ; i < ESP_MAX_TARGET; i++) {\r\nesp->target[i].flags = 0;\r\nesp->target[i].nego_goal_period = 0;\r\nesp->target[i].nego_goal_offset = 0;\r\nesp->target[i].nego_goal_width = 0;\r\nesp->target[i].nego_goal_tags = 0;\r\n}\r\n}\r\nstatic void esp_bootup_reset(struct esp *esp)\r\n{\r\nu8 val;\r\nesp->ops->reset_dma(esp);\r\nesp_reset_esp(esp);\r\nval = esp_read8(ESP_CFG1);\r\nval |= ESP_CONFIG1_SRRDISAB;\r\nesp_write8(val, ESP_CFG1);\r\nscsi_esp_cmd(esp, ESP_CMD_RS);\r\nudelay(400);\r\nesp_write8(esp->config1, ESP_CFG1);\r\nesp_read8(ESP_INTRPT);\r\n}\r\nstatic void esp_set_clock_params(struct esp *esp)\r\n{\r\nint fhz;\r\nu8 ccf;\r\nfhz = esp->cfreq;\r\nccf = ((fhz / 1000000) + 4) / 5;\r\nif (ccf == 1)\r\nccf = 2;\r\nif (fhz <= 5000000 || ccf < 1 || ccf > 8) {\r\nfhz = 20000000;\r\nccf = 4;\r\n}\r\nesp->cfact = (ccf == 8 ? 0 : ccf);\r\nesp->cfreq = fhz;\r\nesp->ccycle = ESP_HZ_TO_CYCLE(fhz);\r\nesp->ctick = ESP_TICK(ccf, esp->ccycle);\r\nesp->neg_defp = ESP_NEG_DEFP(fhz, ccf);\r\nesp->sync_defp = SYNC_DEFP_SLOW;\r\n}\r\nint scsi_esp_register(struct esp *esp, struct device *dev)\r\n{\r\nstatic int instance;\r\nint err;\r\nesp->host->transportt = esp_transport_template;\r\nesp->host->max_lun = ESP_MAX_LUN;\r\nesp->host->cmd_per_lun = 2;\r\nesp->host->unique_id = instance;\r\nesp_set_clock_params(esp);\r\nesp_get_revision(esp);\r\nesp_init_swstate(esp);\r\nesp_bootup_reset(esp);\r\nprintk(KERN_INFO PFX "esp%u, regs[%1p:%1p] irq[%u]\n",\r\nesp->host->unique_id, esp->regs, esp->dma_regs,\r\nesp->host->irq);\r\nprintk(KERN_INFO PFX "esp%u is a %s, %u MHz (ccf=%u), SCSI ID %u\n",\r\nesp->host->unique_id, esp_chip_names[esp->rev],\r\nesp->cfreq / 1000000, esp->cfact, esp->scsi_id);\r\nssleep(esp_bus_reset_settle);\r\nerr = scsi_add_host(esp->host, dev);\r\nif (err)\r\nreturn err;\r\ninstance++;\r\nscsi_scan_host(esp->host);\r\nreturn 0;\r\n}\r\nvoid scsi_esp_unregister(struct esp *esp)\r\n{\r\nscsi_remove_host(esp->host);\r\n}\r\nstatic int esp_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct esp *esp = shost_priv(dev_to_shost(&starget->dev));\r\nstruct esp_target_data *tp = &esp->target[starget->id];\r\ntp->starget = starget;\r\nreturn 0;\r\n}\r\nstatic void esp_target_destroy(struct scsi_target *starget)\r\n{\r\nstruct esp *esp = shost_priv(dev_to_shost(&starget->dev));\r\nstruct esp_target_data *tp = &esp->target[starget->id];\r\ntp->starget = NULL;\r\n}\r\nstatic int esp_slave_alloc(struct scsi_device *dev)\r\n{\r\nstruct esp *esp = shost_priv(dev->host);\r\nstruct esp_target_data *tp = &esp->target[dev->id];\r\nstruct esp_lun_data *lp;\r\nlp = kzalloc(sizeof(*lp), GFP_KERNEL);\r\nif (!lp)\r\nreturn -ENOMEM;\r\ndev->hostdata = lp;\r\nspi_min_period(tp->starget) = esp->min_period;\r\nspi_max_offset(tp->starget) = 15;\r\nif (esp->flags & ESP_FLAG_WIDE_CAPABLE)\r\nspi_max_width(tp->starget) = 1;\r\nelse\r\nspi_max_width(tp->starget) = 0;\r\nreturn 0;\r\n}\r\nstatic int esp_slave_configure(struct scsi_device *dev)\r\n{\r\nstruct esp *esp = shost_priv(dev->host);\r\nstruct esp_target_data *tp = &esp->target[dev->id];\r\nint goal_tags, queue_depth;\r\ngoal_tags = 0;\r\nif (dev->tagged_supported) {\r\ngoal_tags = ESP_DEFAULT_TAGS;\r\nif (goal_tags > ESP_MAX_TAG)\r\ngoal_tags = ESP_MAX_TAG;\r\n}\r\nqueue_depth = goal_tags;\r\nif (queue_depth < dev->host->cmd_per_lun)\r\nqueue_depth = dev->host->cmd_per_lun;\r\nif (goal_tags) {\r\nscsi_set_tag_type(dev, MSG_ORDERED_TAG);\r\nscsi_activate_tcq(dev, queue_depth);\r\n} else {\r\nscsi_deactivate_tcq(dev, queue_depth);\r\n}\r\ntp->flags |= ESP_TGT_DISCONNECT;\r\nif (!spi_initial_dv(dev->sdev_target))\r\nspi_dv_device(dev);\r\nreturn 0;\r\n}\r\nstatic void esp_slave_destroy(struct scsi_device *dev)\r\n{\r\nstruct esp_lun_data *lp = dev->hostdata;\r\nkfree(lp);\r\ndev->hostdata = NULL;\r\n}\r\nstatic int esp_eh_abort_handler(struct scsi_cmnd *cmd)\r\n{\r\nstruct esp *esp = shost_priv(cmd->device->host);\r\nstruct esp_cmd_entry *ent, *tmp;\r\nstruct completion eh_done;\r\nunsigned long flags;\r\nspin_lock_irqsave(esp->host->host_lock, flags);\r\nprintk(KERN_ERR PFX "esp%d: Aborting command [%p:%02x]\n",\r\nesp->host->unique_id, cmd, cmd->cmnd[0]);\r\nent = esp->active_cmd;\r\nif (ent)\r\nprintk(KERN_ERR PFX "esp%d: Current command [%p:%02x]\n",\r\nesp->host->unique_id, ent->cmd, ent->cmd->cmnd[0]);\r\nlist_for_each_entry(ent, &esp->queued_cmds, list) {\r\nprintk(KERN_ERR PFX "esp%d: Queued command [%p:%02x]\n",\r\nesp->host->unique_id, ent->cmd, ent->cmd->cmnd[0]);\r\n}\r\nlist_for_each_entry(ent, &esp->active_cmds, list) {\r\nprintk(KERN_ERR PFX "esp%d: Active command [%p:%02x]\n",\r\nesp->host->unique_id, ent->cmd, ent->cmd->cmnd[0]);\r\n}\r\nesp_dump_cmd_log(esp);\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nspin_lock_irqsave(esp->host->host_lock, flags);\r\nent = NULL;\r\nlist_for_each_entry(tmp, &esp->queued_cmds, list) {\r\nif (tmp->cmd == cmd) {\r\nent = tmp;\r\nbreak;\r\n}\r\n}\r\nif (ent) {\r\nlist_del(&ent->list);\r\ncmd->result = DID_ABORT << 16;\r\ncmd->scsi_done(cmd);\r\nesp_put_ent(esp, ent);\r\ngoto out_success;\r\n}\r\ninit_completion(&eh_done);\r\nent = esp->active_cmd;\r\nif (ent && ent->cmd == cmd) {\r\nif (esp->msg_out_len)\r\ngoto out_failure;\r\nesp->msg_out[0] = ABORT_TASK_SET;\r\nesp->msg_out_len = 1;\r\nent->eh_done = &eh_done;\r\nscsi_esp_cmd(esp, ESP_CMD_SATN);\r\n} else {\r\ngoto out_failure;\r\n}\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nif (!wait_for_completion_timeout(&eh_done, 5 * HZ)) {\r\nspin_lock_irqsave(esp->host->host_lock, flags);\r\nent->eh_done = NULL;\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nreturn FAILED;\r\n}\r\nreturn SUCCESS;\r\nout_success:\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nreturn SUCCESS;\r\nout_failure:\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nreturn FAILED;\r\n}\r\nstatic int esp_eh_bus_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nstruct esp *esp = shost_priv(cmd->device->host);\r\nstruct completion eh_reset;\r\nunsigned long flags;\r\ninit_completion(&eh_reset);\r\nspin_lock_irqsave(esp->host->host_lock, flags);\r\nesp->eh_reset = &eh_reset;\r\nesp->flags |= ESP_FLAG_RESETTING;\r\nscsi_esp_cmd(esp, ESP_CMD_RS);\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nssleep(esp_bus_reset_settle);\r\nif (!wait_for_completion_timeout(&eh_reset, 5 * HZ)) {\r\nspin_lock_irqsave(esp->host->host_lock, flags);\r\nesp->eh_reset = NULL;\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nreturn FAILED;\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int esp_eh_host_reset_handler(struct scsi_cmnd *cmd)\r\n{\r\nstruct esp *esp = shost_priv(cmd->device->host);\r\nunsigned long flags;\r\nspin_lock_irqsave(esp->host->host_lock, flags);\r\nesp_bootup_reset(esp);\r\nesp_reset_cleanup(esp);\r\nspin_unlock_irqrestore(esp->host->host_lock, flags);\r\nssleep(esp_bus_reset_settle);\r\nreturn SUCCESS;\r\n}\r\nstatic const char *esp_info(struct Scsi_Host *host)\r\n{\r\nreturn "esp";\r\n}\r\nstatic void esp_get_signalling(struct Scsi_Host *host)\r\n{\r\nstruct esp *esp = shost_priv(host);\r\nenum spi_signal_type type;\r\nif (esp->flags & ESP_FLAG_DIFFERENTIAL)\r\ntype = SPI_SIGNAL_HVD;\r\nelse\r\ntype = SPI_SIGNAL_SE;\r\nspi_signalling(host) = type;\r\n}\r\nstatic void esp_set_offset(struct scsi_target *target, int offset)\r\n{\r\nstruct Scsi_Host *host = dev_to_shost(target->dev.parent);\r\nstruct esp *esp = shost_priv(host);\r\nstruct esp_target_data *tp = &esp->target[target->id];\r\nif (esp->flags & ESP_FLAG_DISABLE_SYNC)\r\ntp->nego_goal_offset = 0;\r\nelse\r\ntp->nego_goal_offset = offset;\r\ntp->flags |= ESP_TGT_CHECK_NEGO;\r\n}\r\nstatic void esp_set_period(struct scsi_target *target, int period)\r\n{\r\nstruct Scsi_Host *host = dev_to_shost(target->dev.parent);\r\nstruct esp *esp = shost_priv(host);\r\nstruct esp_target_data *tp = &esp->target[target->id];\r\ntp->nego_goal_period = period;\r\ntp->flags |= ESP_TGT_CHECK_NEGO;\r\n}\r\nstatic void esp_set_width(struct scsi_target *target, int width)\r\n{\r\nstruct Scsi_Host *host = dev_to_shost(target->dev.parent);\r\nstruct esp *esp = shost_priv(host);\r\nstruct esp_target_data *tp = &esp->target[target->id];\r\ntp->nego_goal_width = (width ? 1 : 0);\r\ntp->flags |= ESP_TGT_CHECK_NEGO;\r\n}\r\nstatic int __init esp_init(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct scsi_pointer) <\r\nsizeof(struct esp_cmd_priv));\r\nesp_transport_template = spi_attach_transport(&esp_transport_ops);\r\nif (!esp_transport_template)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __exit esp_exit(void)\r\n{\r\nspi_release_transport(esp_transport_template);\r\n}
