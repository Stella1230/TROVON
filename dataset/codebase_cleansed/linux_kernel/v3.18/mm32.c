static int alloc_xen_mm32_scratch_page(int cpu)\r\n{\r\nstruct page *page;\r\nunsigned long virt;\r\npmd_t *pmdp;\r\npte_t *ptep;\r\nif (per_cpu(xen_mm32_scratch_ptep, cpu) != NULL)\r\nreturn 0;\r\npage = alloc_page(GFP_KERNEL);\r\nif (page == NULL) {\r\npr_warn("Failed to allocate xen_mm32_scratch_page for cpu %d\n", cpu);\r\nreturn -ENOMEM;\r\n}\r\nvirt = (unsigned long)__va(page_to_phys(page));\r\npmdp = pmd_offset(pud_offset(pgd_offset_k(virt), virt), virt);\r\nptep = pte_offset_kernel(pmdp, virt);\r\nper_cpu(xen_mm32_scratch_virt, cpu) = virt;\r\nper_cpu(xen_mm32_scratch_ptep, cpu) = ptep;\r\nreturn 0;\r\n}\r\nstatic int xen_mm32_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nint cpu = (long)hcpu;\r\nswitch (action) {\r\ncase CPU_UP_PREPARE:\r\nif (alloc_xen_mm32_scratch_page(cpu))\r\nreturn NOTIFY_BAD;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void* xen_mm32_remap_page(dma_addr_t handle)\r\n{\r\nunsigned long virt = get_cpu_var(xen_mm32_scratch_virt);\r\npte_t *ptep = __get_cpu_var(xen_mm32_scratch_ptep);\r\n*ptep = pfn_pte(handle >> PAGE_SHIFT, PAGE_KERNEL);\r\nlocal_flush_tlb_kernel_page(virt);\r\nreturn (void*)virt;\r\n}\r\nstatic void xen_mm32_unmap(void *vaddr)\r\n{\r\nput_cpu_var(xen_mm32_scratch_virt);\r\n}\r\nstatic void dma_cache_maint(dma_addr_t handle, unsigned long offset,\r\nsize_t size, enum dma_data_direction dir,\r\nvoid (*op)(const void *, size_t, int))\r\n{\r\nunsigned long pfn;\r\nsize_t left = size;\r\npfn = (handle >> PAGE_SHIFT) + offset / PAGE_SIZE;\r\noffset %= PAGE_SIZE;\r\ndo {\r\nsize_t len = left;\r\nvoid *vaddr;\r\nif (!pfn_valid(pfn))\r\n{\r\nif (!xen_feature(XENFEAT_grant_map_identity))\r\nreturn;\r\nvaddr = xen_mm32_remap_page(handle) + offset;\r\nop(vaddr, len, dir);\r\nxen_mm32_unmap(vaddr - offset);\r\n} else {\r\nstruct page *page = pfn_to_page(pfn);\r\nif (PageHighMem(page)) {\r\nif (len + offset > PAGE_SIZE)\r\nlen = PAGE_SIZE - offset;\r\nif (cache_is_vipt_nonaliasing()) {\r\nvaddr = kmap_atomic(page);\r\nop(vaddr + offset, len, dir);\r\nkunmap_atomic(vaddr);\r\n} else {\r\nvaddr = kmap_high_get(page);\r\nif (vaddr) {\r\nop(vaddr + offset, len, dir);\r\nkunmap_high(page);\r\n}\r\n}\r\n} else {\r\nvaddr = page_address(page) + offset;\r\nop(vaddr, len, dir);\r\n}\r\n}\r\noffset = 0;\r\npfn++;\r\nleft -= len;\r\n} while (left);\r\n}\r\nstatic void __xen_dma_page_dev_to_cpu(struct device *hwdev, dma_addr_t handle,\r\nsize_t size, enum dma_data_direction dir)\r\n{\r\nif (dir != DMA_TO_DEVICE)\r\nouter_inv_range(handle, handle + size);\r\ndma_cache_maint(handle & PAGE_MASK, handle & ~PAGE_MASK, size, dir, dmac_unmap_area);\r\n}\r\nstatic void __xen_dma_page_cpu_to_dev(struct device *hwdev, dma_addr_t handle,\r\nsize_t size, enum dma_data_direction dir)\r\n{\r\ndma_cache_maint(handle & PAGE_MASK, handle & ~PAGE_MASK, size, dir, dmac_map_area);\r\nif (dir == DMA_FROM_DEVICE) {\r\nouter_inv_range(handle, handle + size);\r\n} else {\r\nouter_clean_range(handle, handle + size);\r\n}\r\n}\r\nvoid xen_dma_unmap_page(struct device *hwdev, dma_addr_t handle,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (!__generic_dma_ops(hwdev)->unmap_page)\r\nreturn;\r\nif (dma_get_attr(DMA_ATTR_SKIP_CPU_SYNC, attrs))\r\nreturn;\r\n__xen_dma_page_dev_to_cpu(hwdev, handle, size, dir);\r\n}\r\nvoid xen_dma_sync_single_for_cpu(struct device *hwdev,\r\ndma_addr_t handle, size_t size, enum dma_data_direction dir)\r\n{\r\nif (!__generic_dma_ops(hwdev)->sync_single_for_cpu)\r\nreturn;\r\n__xen_dma_page_dev_to_cpu(hwdev, handle, size, dir);\r\n}\r\nvoid xen_dma_sync_single_for_device(struct device *hwdev,\r\ndma_addr_t handle, size_t size, enum dma_data_direction dir)\r\n{\r\nif (!__generic_dma_ops(hwdev)->sync_single_for_device)\r\nreturn;\r\n__xen_dma_page_cpu_to_dev(hwdev, handle, size, dir);\r\n}\r\nint __init xen_mm32_init(void)\r\n{\r\nint cpu;\r\nif (!xen_initial_domain())\r\nreturn 0;\r\nregister_cpu_notifier(&xen_mm32_cpu_notifier);\r\nget_online_cpus();\r\nfor_each_online_cpu(cpu) {\r\nif (alloc_xen_mm32_scratch_page(cpu)) {\r\nput_online_cpus();\r\nunregister_cpu_notifier(&xen_mm32_cpu_notifier);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nput_online_cpus();\r\nreturn 0;\r\n}
