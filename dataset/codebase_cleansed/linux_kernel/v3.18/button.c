static int acpi_button_state_seq_show(struct seq_file *seq, void *offset)\r\n{\r\nstruct acpi_device *device = seq->private;\r\nacpi_status status;\r\nunsigned long long state;\r\nstatus = acpi_evaluate_integer(device->handle, "_LID", NULL, &state);\r\nseq_printf(seq, "state: %s\n",\r\nACPI_FAILURE(status) ? "unsupported" :\r\n(state ? "open" : "closed"));\r\nreturn 0;\r\n}\r\nstatic int acpi_button_state_open_fs(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, acpi_button_state_seq_show, PDE_DATA(inode));\r\n}\r\nstatic int acpi_button_add_fs(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nstruct proc_dir_entry *entry = NULL;\r\nint ret = 0;\r\nif (button->type != ACPI_BUTTON_TYPE_LID)\r\nreturn 0;\r\nif (acpi_button_dir || acpi_lid_dir) {\r\nprintk(KERN_ERR PREFIX "More than one Lid device found!\n");\r\nreturn -EEXIST;\r\n}\r\nacpi_button_dir = proc_mkdir(ACPI_BUTTON_CLASS, acpi_root_dir);\r\nif (!acpi_button_dir)\r\nreturn -ENODEV;\r\nacpi_lid_dir = proc_mkdir(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\r\nif (!acpi_lid_dir) {\r\nret = -ENODEV;\r\ngoto remove_button_dir;\r\n}\r\nacpi_device_dir(device) = proc_mkdir(acpi_device_bid(device), acpi_lid_dir);\r\nif (!acpi_device_dir(device)) {\r\nret = -ENODEV;\r\ngoto remove_lid_dir;\r\n}\r\nentry = proc_create_data(ACPI_BUTTON_FILE_STATE,\r\nS_IRUGO, acpi_device_dir(device),\r\n&acpi_button_state_fops, device);\r\nif (!entry) {\r\nret = -ENODEV;\r\ngoto remove_dev_dir;\r\n}\r\ndone:\r\nreturn ret;\r\nremove_dev_dir:\r\nremove_proc_entry(acpi_device_bid(device),\r\nacpi_lid_dir);\r\nacpi_device_dir(device) = NULL;\r\nremove_lid_dir:\r\nremove_proc_entry(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\r\nremove_button_dir:\r\nremove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);\r\ngoto done;\r\n}\r\nstatic int acpi_button_remove_fs(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nif (button->type != ACPI_BUTTON_TYPE_LID)\r\nreturn 0;\r\nremove_proc_entry(ACPI_BUTTON_FILE_STATE,\r\nacpi_device_dir(device));\r\nremove_proc_entry(acpi_device_bid(device),\r\nacpi_lid_dir);\r\nacpi_device_dir(device) = NULL;\r\nremove_proc_entry(ACPI_BUTTON_SUBCLASS_LID, acpi_button_dir);\r\nremove_proc_entry(ACPI_BUTTON_CLASS, acpi_root_dir);\r\nreturn 0;\r\n}\r\nint acpi_lid_notifier_register(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&acpi_lid_notifier, nb);\r\n}\r\nint acpi_lid_notifier_unregister(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&acpi_lid_notifier, nb);\r\n}\r\nint acpi_lid_open(void)\r\n{\r\nacpi_status status;\r\nunsigned long long state;\r\nif (!lid_device)\r\nreturn -ENODEV;\r\nstatus = acpi_evaluate_integer(lid_device->handle, "_LID", NULL,\r\n&state);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nreturn !!state;\r\n}\r\nstatic int acpi_lid_send_state(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nunsigned long long state;\r\nacpi_status status;\r\nint ret;\r\nstatus = acpi_evaluate_integer(device->handle, "_LID", NULL, &state);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\ninput_report_switch(button->input, SW_LID, !state);\r\ninput_sync(button->input);\r\nif (state)\r\npm_wakeup_event(&device->dev, 0);\r\nret = blocking_notifier_call_chain(&acpi_lid_notifier, state, device);\r\nif (ret == NOTIFY_DONE)\r\nret = blocking_notifier_call_chain(&acpi_lid_notifier, state,\r\ndevice);\r\nif (ret == NOTIFY_DONE || ret == NOTIFY_OK) {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void acpi_button_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nstruct input_dev *input;\r\nswitch (event) {\r\ncase ACPI_FIXED_HARDWARE_EVENT:\r\nevent = ACPI_BUTTON_NOTIFY_STATUS;\r\ncase ACPI_BUTTON_NOTIFY_STATUS:\r\ninput = button->input;\r\nif (button->type == ACPI_BUTTON_TYPE_LID) {\r\nacpi_lid_send_state(device);\r\n} else {\r\nint keycode;\r\npm_wakeup_event(&device->dev, 0);\r\nif (button->suspended)\r\nbreak;\r\nkeycode = test_bit(KEY_SLEEP, input->keybit) ?\r\nKEY_SLEEP : KEY_POWER;\r\ninput_report_key(input, keycode, 1);\r\ninput_sync(input);\r\ninput_report_key(input, keycode, 0);\r\ninput_sync(input);\r\nacpi_bus_generate_netlink_event(\r\ndevice->pnp.device_class,\r\ndev_name(&device->dev),\r\nevent, ++button->pushed);\r\n}\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\n}\r\nstatic int acpi_button_suspend(struct device *dev)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nbutton->suspended = true;\r\nreturn 0;\r\n}\r\nstatic int acpi_button_resume(struct device *dev)\r\n{\r\nstruct acpi_device *device = to_acpi_device(dev);\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nbutton->suspended = false;\r\nif (button->type == ACPI_BUTTON_TYPE_LID)\r\nreturn acpi_lid_send_state(device);\r\nreturn 0;\r\n}\r\nstatic int acpi_button_add(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button;\r\nstruct input_dev *input;\r\nconst char *hid = acpi_device_hid(device);\r\nchar *name, *class;\r\nint error;\r\nbutton = kzalloc(sizeof(struct acpi_button), GFP_KERNEL);\r\nif (!button)\r\nreturn -ENOMEM;\r\ndevice->driver_data = button;\r\nbutton->input = input = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto err_free_button;\r\n}\r\nname = acpi_device_name(device);\r\nclass = acpi_device_class(device);\r\nif (!strcmp(hid, ACPI_BUTTON_HID_POWER) ||\r\n!strcmp(hid, ACPI_BUTTON_HID_POWERF)) {\r\nbutton->type = ACPI_BUTTON_TYPE_POWER;\r\nstrcpy(name, ACPI_BUTTON_DEVICE_NAME_POWER);\r\nsprintf(class, "%s/%s",\r\nACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_POWER);\r\n} else if (!strcmp(hid, ACPI_BUTTON_HID_SLEEP) ||\r\n!strcmp(hid, ACPI_BUTTON_HID_SLEEPF)) {\r\nbutton->type = ACPI_BUTTON_TYPE_SLEEP;\r\nstrcpy(name, ACPI_BUTTON_DEVICE_NAME_SLEEP);\r\nsprintf(class, "%s/%s",\r\nACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_SLEEP);\r\n} else if (!strcmp(hid, ACPI_BUTTON_HID_LID)) {\r\nbutton->type = ACPI_BUTTON_TYPE_LID;\r\nstrcpy(name, ACPI_BUTTON_DEVICE_NAME_LID);\r\nsprintf(class, "%s/%s",\r\nACPI_BUTTON_CLASS, ACPI_BUTTON_SUBCLASS_LID);\r\n} else {\r\nprintk(KERN_ERR PREFIX "Unsupported hid [%s]\n", hid);\r\nerror = -ENODEV;\r\ngoto err_free_input;\r\n}\r\nerror = acpi_button_add_fs(device);\r\nif (error)\r\ngoto err_free_input;\r\nsnprintf(button->phys, sizeof(button->phys), "%s/button/input0", hid);\r\ninput->name = name;\r\ninput->phys = button->phys;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.product = button->type;\r\ninput->dev.parent = &device->dev;\r\nswitch (button->type) {\r\ncase ACPI_BUTTON_TYPE_POWER:\r\ninput_set_capability(input, EV_KEY, KEY_POWER);\r\nbreak;\r\ncase ACPI_BUTTON_TYPE_SLEEP:\r\ninput_set_capability(input, EV_KEY, KEY_SLEEP);\r\nbreak;\r\ncase ACPI_BUTTON_TYPE_LID:\r\ninput_set_capability(input, EV_SW, SW_LID);\r\nbreak;\r\n}\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_remove_fs;\r\nif (button->type == ACPI_BUTTON_TYPE_LID) {\r\nacpi_lid_send_state(device);\r\nlid_device = device;\r\n}\r\nprintk(KERN_INFO PREFIX "%s [%s]\n", name, acpi_device_bid(device));\r\nreturn 0;\r\nerr_remove_fs:\r\nacpi_button_remove_fs(device);\r\nerr_free_input:\r\ninput_free_device(input);\r\nerr_free_button:\r\nkfree(button);\r\nreturn error;\r\n}\r\nstatic int acpi_button_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_button *button = acpi_driver_data(device);\r\nacpi_button_remove_fs(device);\r\ninput_unregister_device(button->input);\r\nkfree(button);\r\nreturn 0;\r\n}
