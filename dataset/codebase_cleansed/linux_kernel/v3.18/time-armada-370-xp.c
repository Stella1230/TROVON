static void local_timer_ctrl_clrset(u32 clr, u32 set)\r\n{\r\nwritel((readl(local_base + TIMER_CTRL_OFF) & ~clr) | set,\r\nlocal_base + TIMER_CTRL_OFF);\r\n}\r\nstatic u64 notrace armada_370_xp_read_sched_clock(void)\r\n{\r\nreturn ~readl(timer_base + TIMER0_VAL_OFF);\r\n}\r\nstatic int\r\narmada_370_xp_clkevt_next_event(unsigned long delta,\r\nstruct clock_event_device *dev)\r\n{\r\nwritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\r\nwritel(delta, local_base + TIMER0_VAL_OFF);\r\nlocal_timer_ctrl_clrset(TIMER0_RELOAD_EN, enable_mask);\r\nreturn 0;\r\n}\r\nstatic void\r\narmada_370_xp_clkevt_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *dev)\r\n{\r\nif (mode == CLOCK_EVT_MODE_PERIODIC) {\r\nwritel(ticks_per_jiffy - 1, local_base + TIMER0_RELOAD_OFF);\r\nwritel(ticks_per_jiffy - 1, local_base + TIMER0_VAL_OFF);\r\nlocal_timer_ctrl_clrset(0, TIMER0_RELOAD_EN | enable_mask);\r\n} else {\r\nlocal_timer_ctrl_clrset(TIMER0_EN, 0);\r\nwritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\r\n}\r\n}\r\nstatic irqreturn_t armada_370_xp_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nwritel(TIMER0_CLR_MASK, local_base + LCL_TIMER_EVENTS_STATUS);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int armada_370_xp_timer_setup(struct clock_event_device *evt)\r\n{\r\nu32 clr = 0, set = 0;\r\nint cpu = smp_processor_id();\r\nif (timer25Mhz)\r\nset = TIMER0_25MHZ;\r\nelse\r\nclr = TIMER0_25MHZ;\r\nlocal_timer_ctrl_clrset(clr, set);\r\nevt->name = "armada_370_xp_per_cpu_tick",\r\nevt->features = CLOCK_EVT_FEAT_ONESHOT |\r\nCLOCK_EVT_FEAT_PERIODIC;\r\nevt->shift = 32,\r\nevt->rating = 300,\r\nevt->set_next_event = armada_370_xp_clkevt_next_event,\r\nevt->set_mode = armada_370_xp_clkevt_mode,\r\nevt->irq = armada_370_xp_clkevt_irq;\r\nevt->cpumask = cpumask_of(cpu);\r\nclockevents_config_and_register(evt, timer_clk, 1, 0xfffffffe);\r\nenable_percpu_irq(evt->irq, 0);\r\nreturn 0;\r\n}\r\nstatic void armada_370_xp_timer_stop(struct clock_event_device *evt)\r\n{\r\nevt->set_mode(CLOCK_EVT_MODE_UNUSED, evt);\r\ndisable_percpu_irq(evt->irq);\r\n}\r\nstatic int armada_370_xp_timer_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_STARTING:\r\narmada_370_xp_timer_setup(this_cpu_ptr(armada_370_xp_evt));\r\nbreak;\r\ncase CPU_DYING:\r\narmada_370_xp_timer_stop(this_cpu_ptr(armada_370_xp_evt));\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init armada_370_xp_timer_common_init(struct device_node *np)\r\n{\r\nu32 clr = 0, set = 0;\r\nint res;\r\ntimer_base = of_iomap(np, 0);\r\nWARN_ON(!timer_base);\r\nlocal_base = of_iomap(np, 1);\r\nif (timer25Mhz) {\r\nset = TIMER0_25MHZ;\r\nenable_mask = TIMER0_EN;\r\n} else {\r\nclr = TIMER0_25MHZ;\r\nenable_mask = TIMER0_EN | TIMER0_DIV(TIMER_DIVIDER_SHIFT);\r\n}\r\natomic_io_modify(timer_base + TIMER_CTRL_OFF, clr | set, set);\r\nlocal_timer_ctrl_clrset(clr, set);\r\narmada_370_xp_clkevt_irq = irq_of_parse_and_map(np, 4);\r\nticks_per_jiffy = (timer_clk + HZ / 2) / HZ;\r\nwritel(0xffffffff, timer_base + TIMER0_VAL_OFF);\r\nwritel(0xffffffff, timer_base + TIMER0_RELOAD_OFF);\r\natomic_io_modify(timer_base + TIMER_CTRL_OFF,\r\nTIMER0_RELOAD_EN | enable_mask,\r\nTIMER0_RELOAD_EN | enable_mask);\r\nsched_clock_register(armada_370_xp_read_sched_clock, 32, timer_clk);\r\nclocksource_mmio_init(timer_base + TIMER0_VAL_OFF,\r\n"armada_370_xp_clocksource",\r\ntimer_clk, 300, 32, clocksource_mmio_readl_down);\r\nregister_cpu_notifier(&armada_370_xp_timer_cpu_nb);\r\narmada_370_xp_evt = alloc_percpu(struct clock_event_device);\r\nres = request_percpu_irq(armada_370_xp_clkevt_irq,\r\narmada_370_xp_timer_interrupt,\r\n"armada_370_xp_per_cpu_tick",\r\narmada_370_xp_evt);\r\nif (!res)\r\narmada_370_xp_timer_setup(this_cpu_ptr(armada_370_xp_evt));\r\n}\r\nstatic void __init armada_xp_timer_init(struct device_node *np)\r\n{\r\nstruct clk *clk = of_clk_get_by_name(np, "fixed");\r\nBUG_ON(IS_ERR(clk));\r\ntimer_clk = clk_get_rate(clk);\r\narmada_370_xp_timer_common_init(np);\r\n}\r\nstatic void __init armada_370_timer_init(struct device_node *np)\r\n{\r\nstruct clk *clk = of_clk_get(np, 0);\r\nBUG_ON(IS_ERR(clk));\r\ntimer_clk = clk_get_rate(clk) / TIMER_DIVIDER;\r\ntimer25Mhz = false;\r\narmada_370_xp_timer_common_init(np);\r\n}
