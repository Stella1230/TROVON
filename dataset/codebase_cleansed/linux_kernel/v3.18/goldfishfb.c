static irqreturn_t goldfish_fb_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long irq_flags;\r\nstruct goldfish_fb *fb = dev_id;\r\nu32 status;\r\nspin_lock_irqsave(&fb->lock, irq_flags);\r\nstatus = readl(fb->reg_base + FB_INT_STATUS);\r\nif (status & FB_INT_BASE_UPDATE_DONE) {\r\nfb->base_update_count++;\r\nwake_up(&fb->wait);\r\n}\r\nspin_unlock_irqrestore(&fb->lock, irq_flags);\r\nreturn status ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic inline u32 convert_bitfield(int val, struct fb_bitfield *bf)\r\n{\r\nunsigned int mask = (1 << bf->length) - 1;\r\nreturn (val >> (16 - bf->length) & mask) << bf->offset;\r\n}\r\nstatic int\r\ngoldfish_fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,\r\nunsigned int blue, unsigned int transp, struct fb_info *info)\r\n{\r\nstruct goldfish_fb *fb = container_of(info, struct goldfish_fb, fb);\r\nif (regno < 16) {\r\nfb->cmap[regno] = convert_bitfield(transp, &fb->fb.var.transp) |\r\nconvert_bitfield(blue, &fb->fb.var.blue) |\r\nconvert_bitfield(green, &fb->fb.var.green) |\r\nconvert_bitfield(red, &fb->fb.var.red);\r\nreturn 0;\r\n} else {\r\nreturn 1;\r\n}\r\n}\r\nstatic int goldfish_fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif ((var->rotate & 1) != (info->var.rotate & 1)) {\r\nif ((var->xres != info->var.yres) ||\r\n(var->yres != info->var.xres) ||\r\n(var->xres_virtual != info->var.yres) ||\r\n(var->yres_virtual > info->var.xres * 2) ||\r\n(var->yres_virtual < info->var.xres)) {\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif ((var->xres != info->var.xres) ||\r\n(var->yres != info->var.yres) ||\r\n(var->xres_virtual != info->var.xres) ||\r\n(var->yres_virtual > info->var.yres * 2) ||\r\n(var->yres_virtual < info->var.yres)) {\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((var->xoffset != info->var.xoffset) ||\r\n(var->bits_per_pixel != info->var.bits_per_pixel) ||\r\n(var->grayscale != info->var.grayscale)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int goldfish_fb_set_par(struct fb_info *info)\r\n{\r\nstruct goldfish_fb *fb = container_of(info, struct goldfish_fb, fb);\r\nif (fb->rotation != fb->fb.var.rotate) {\r\ninfo->fix.line_length = info->var.xres * 2;\r\nfb->rotation = fb->fb.var.rotate;\r\nwritel(fb->rotation, fb->reg_base + FB_SET_ROTATION);\r\n}\r\nreturn 0;\r\n}\r\nstatic int goldfish_fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nunsigned long irq_flags;\r\nint base_update_count;\r\nstruct goldfish_fb *fb = container_of(info, struct goldfish_fb, fb);\r\nspin_lock_irqsave(&fb->lock, irq_flags);\r\nbase_update_count = fb->base_update_count;\r\nwritel(fb->fb.fix.smem_start + fb->fb.var.xres * 2 * var->yoffset,\r\nfb->reg_base + FB_SET_BASE);\r\nspin_unlock_irqrestore(&fb->lock, irq_flags);\r\nwait_event_timeout(fb->wait,\r\nfb->base_update_count != base_update_count, HZ / 15);\r\nif (fb->base_update_count == base_update_count)\r\npr_err("goldfish_fb_pan_display: timeout waiting for base update\n");\r\nreturn 0;\r\n}\r\nstatic int goldfish_fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct goldfish_fb *fb = container_of(info, struct goldfish_fb, fb);\r\nswitch (blank) {\r\ncase FB_BLANK_NORMAL:\r\nwritel(1, fb->reg_base + FB_SET_BLANK);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nwritel(0, fb->reg_base + FB_SET_BLANK);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int goldfish_fb_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct resource *r;\r\nstruct goldfish_fb *fb;\r\nsize_t framesize;\r\nu32 width, height;\r\ndma_addr_t fbpaddr;\r\nfb = kzalloc(sizeof(*fb), GFP_KERNEL);\r\nif (fb == NULL) {\r\nret = -ENOMEM;\r\ngoto err_fb_alloc_failed;\r\n}\r\nspin_lock_init(&fb->lock);\r\ninit_waitqueue_head(&fb->wait);\r\nplatform_set_drvdata(pdev, fb);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nret = -ENODEV;\r\ngoto err_no_io_base;\r\n}\r\nfb->reg_base = ioremap(r->start, PAGE_SIZE);\r\nif (fb->reg_base == NULL) {\r\nret = -ENOMEM;\r\ngoto err_no_io_base;\r\n}\r\nfb->irq = platform_get_irq(pdev, 0);\r\nif (fb->irq <= 0) {\r\nret = -ENODEV;\r\ngoto err_no_irq;\r\n}\r\nwidth = readl(fb->reg_base + FB_GET_WIDTH);\r\nheight = readl(fb->reg_base + FB_GET_HEIGHT);\r\nfb->fb.fbops = &goldfish_fb_ops;\r\nfb->fb.flags = FBINFO_FLAG_DEFAULT;\r\nfb->fb.pseudo_palette = fb->cmap;\r\nfb->fb.fix.type = FB_TYPE_PACKED_PIXELS;\r\nfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\r\nfb->fb.fix.line_length = width * 2;\r\nfb->fb.fix.accel = FB_ACCEL_NONE;\r\nfb->fb.fix.ypanstep = 1;\r\nfb->fb.var.xres = width;\r\nfb->fb.var.yres = height;\r\nfb->fb.var.xres_virtual = width;\r\nfb->fb.var.yres_virtual = height * 2;\r\nfb->fb.var.bits_per_pixel = 16;\r\nfb->fb.var.activate = FB_ACTIVATE_NOW;\r\nfb->fb.var.height = readl(fb->reg_base + FB_GET_PHYS_HEIGHT);\r\nfb->fb.var.width = readl(fb->reg_base + FB_GET_PHYS_WIDTH);\r\nfb->fb.var.pixclock = 10000;\r\nfb->fb.var.red.offset = 11;\r\nfb->fb.var.red.length = 5;\r\nfb->fb.var.green.offset = 5;\r\nfb->fb.var.green.length = 6;\r\nfb->fb.var.blue.offset = 0;\r\nfb->fb.var.blue.length = 5;\r\nframesize = width * height * 2 * 2;\r\nfb->fb.screen_base = (char __force __iomem *)dma_alloc_coherent(\r\n&pdev->dev, framesize,\r\n&fbpaddr, GFP_KERNEL);\r\npr_debug("allocating frame buffer %d * %d, got %p\n",\r\nwidth, height, fb->fb.screen_base);\r\nif (fb->fb.screen_base == NULL) {\r\nret = -ENOMEM;\r\ngoto err_alloc_screen_base_failed;\r\n}\r\nfb->fb.fix.smem_start = fbpaddr;\r\nfb->fb.fix.smem_len = framesize;\r\nret = fb_set_var(&fb->fb, &fb->fb.var);\r\nif (ret)\r\ngoto err_fb_set_var_failed;\r\nret = request_irq(fb->irq, goldfish_fb_interrupt, IRQF_SHARED,\r\npdev->name, fb);\r\nif (ret)\r\ngoto err_request_irq_failed;\r\nwritel(FB_INT_BASE_UPDATE_DONE, fb->reg_base + FB_INT_ENABLE);\r\ngoldfish_fb_pan_display(&fb->fb.var, &fb->fb);\r\nret = register_framebuffer(&fb->fb);\r\nif (ret)\r\ngoto err_register_framebuffer_failed;\r\nreturn 0;\r\nerr_register_framebuffer_failed:\r\nfree_irq(fb->irq, fb);\r\nerr_request_irq_failed:\r\nerr_fb_set_var_failed:\r\ndma_free_coherent(&pdev->dev, framesize,\r\n(void *)fb->fb.screen_base,\r\nfb->fb.fix.smem_start);\r\nerr_alloc_screen_base_failed:\r\nerr_no_irq:\r\niounmap(fb->reg_base);\r\nerr_no_io_base:\r\nkfree(fb);\r\nerr_fb_alloc_failed:\r\nreturn ret;\r\n}\r\nstatic int goldfish_fb_remove(struct platform_device *pdev)\r\n{\r\nsize_t framesize;\r\nstruct goldfish_fb *fb = platform_get_drvdata(pdev);\r\nframesize = fb->fb.var.xres_virtual * fb->fb.var.yres_virtual * 2;\r\nunregister_framebuffer(&fb->fb);\r\nfree_irq(fb->irq, fb);\r\ndma_free_coherent(&pdev->dev, framesize, (void *)fb->fb.screen_base,\r\nfb->fb.fix.smem_start);\r\niounmap(fb->reg_base);\r\nreturn 0;\r\n}
