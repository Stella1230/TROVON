static int brcmf_cfg80211_vndr_cmds_dcmd_handler(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nconst void *data, int len)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg);\r\nconst struct brcmf_vndr_dcmd_hdr *cmdhdr = data;\r\nstruct sk_buff *reply;\r\nint ret, payload, ret_len;\r\nvoid *dcmd_buf = NULL, *wr_pointer;\r\nu16 msglen, maxmsglen = PAGE_SIZE - 0x100;\r\nbrcmf_dbg(TRACE, "cmd %x set %d len %d\n", cmdhdr->cmd, cmdhdr->set,\r\ncmdhdr->len);\r\nlen -= sizeof(struct brcmf_vndr_dcmd_hdr);\r\nret_len = cmdhdr->len;\r\nif (ret_len > 0 || len > 0) {\r\nif (len > BRCMF_DCMD_MAXLEN) {\r\nbrcmf_err("oversize input buffer %d\n", len);\r\nlen = BRCMF_DCMD_MAXLEN;\r\n}\r\nif (ret_len > BRCMF_DCMD_MAXLEN) {\r\nbrcmf_err("oversize return buffer %d\n", ret_len);\r\nret_len = BRCMF_DCMD_MAXLEN;\r\n}\r\npayload = max(ret_len, len) + 1;\r\ndcmd_buf = vzalloc(payload);\r\nif (NULL == dcmd_buf)\r\nreturn -ENOMEM;\r\nmemcpy(dcmd_buf, (void *)cmdhdr + cmdhdr->offset, len);\r\n*(char *)(dcmd_buf + len) = '\0';\r\n}\r\nif (cmdhdr->set)\r\nret = brcmf_fil_cmd_data_set(netdev_priv(ndev), cmdhdr->cmd,\r\ndcmd_buf, ret_len);\r\nelse\r\nret = brcmf_fil_cmd_data_get(netdev_priv(ndev), cmdhdr->cmd,\r\ndcmd_buf, ret_len);\r\nif (ret != 0)\r\ngoto exit;\r\nwr_pointer = dcmd_buf;\r\nwhile (ret_len > 0) {\r\nmsglen = ret_len > maxmsglen ? maxmsglen : ret_len;\r\nret_len -= msglen;\r\npayload = msglen + sizeof(msglen);\r\nreply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);\r\nif (NULL == reply) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nif (nla_put(reply, BRCMF_NLATTR_DATA, msglen, wr_pointer) ||\r\nnla_put_u16(reply, BRCMF_NLATTR_LEN, msglen)) {\r\nkfree_skb(reply);\r\nret = -ENOBUFS;\r\nbreak;\r\n}\r\nret = cfg80211_vendor_cmd_reply(reply);\r\nif (ret)\r\nbreak;\r\nwr_pointer += msglen;\r\n}\r\nexit:\r\nvfree(dcmd_buf);\r\nreturn ret;\r\n}
