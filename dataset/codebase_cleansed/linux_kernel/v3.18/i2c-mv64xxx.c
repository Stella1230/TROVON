static void\r\nmv64xxx_i2c_prepare_for_io(struct mv64xxx_i2c_data *drv_data,\r\nstruct i2c_msg *msg)\r\n{\r\nu32 dir = 0;\r\ndrv_data->cntl_bits = MV64XXX_I2C_REG_CONTROL_ACK |\r\nMV64XXX_I2C_REG_CONTROL_INTEN | MV64XXX_I2C_REG_CONTROL_TWSIEN;\r\nif (msg->flags & I2C_M_RD)\r\ndir = 1;\r\nif (msg->flags & I2C_M_TEN) {\r\ndrv_data->addr1 = 0xf0 | (((u32)msg->addr & 0x300) >> 7) | dir;\r\ndrv_data->addr2 = (u32)msg->addr & 0xff;\r\n} else {\r\ndrv_data->addr1 = MV64XXX_I2C_ADDR_ADDR((u32)msg->addr) | dir;\r\ndrv_data->addr2 = 0;\r\n}\r\n}\r\nstatic int mv64xxx_i2c_offload_msg(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nunsigned long data_reg_hi = 0;\r\nunsigned long data_reg_lo = 0;\r\nunsigned long ctrl_reg;\r\nstruct i2c_msg *msg = drv_data->msgs;\r\nif (!drv_data->offload_enabled)\r\nreturn -EOPNOTSUPP;\r\nif ((msg->flags & ~(I2C_M_TEN | I2C_M_RD)) != 0)\r\nreturn -EINVAL;\r\nif (msg->len < 1 || msg->len > 8)\r\nreturn -EINVAL;\r\nctrl_reg = MV64XXX_I2C_BRIDGE_CONTROL_ENABLE |\r\n(msg->addr << MV64XXX_I2C_BRIDGE_CONTROL_ADDR_SHIFT);\r\nif ((msg->flags & I2C_M_TEN) != 0)\r\nctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_ADDR_EXT;\r\nif ((msg->flags & I2C_M_RD) == 0) {\r\nu8 local_buf[8] = { 0 };\r\nmemcpy(local_buf, msg->buf, msg->len);\r\ndata_reg_lo = cpu_to_le32(*((u32 *)local_buf));\r\ndata_reg_hi = cpu_to_le32(*((u32 *)(local_buf+4)));\r\nctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_WR |\r\n(msg->len - 1) << MV64XXX_I2C_BRIDGE_CONTROL_TX_SIZE_SHIFT;\r\nwritel(data_reg_lo,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_TX_DATA_LO);\r\nwritel(data_reg_hi,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_TX_DATA_HI);\r\n} else {\r\nctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_RD |\r\n(msg->len - 1) << MV64XXX_I2C_BRIDGE_CONTROL_RX_SIZE_SHIFT;\r\n}\r\nwritel(ctrl_reg, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_CONTROL);\r\nreturn 0;\r\n}\r\nstatic void\r\nmv64xxx_i2c_update_offload_data(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nstruct i2c_msg *msg = drv_data->msg;\r\nif (msg->flags & I2C_M_RD) {\r\nu32 data_reg_lo = readl(drv_data->reg_base +\r\nMV64XXX_I2C_REG_RX_DATA_LO);\r\nu32 data_reg_hi = readl(drv_data->reg_base +\r\nMV64XXX_I2C_REG_RX_DATA_HI);\r\nu8 local_buf[8] = { 0 };\r\n*((u32 *)local_buf) = le32_to_cpu(data_reg_lo);\r\n*((u32 *)(local_buf+4)) = le32_to_cpu(data_reg_hi);\r\nmemcpy(msg->buf, local_buf, msg->len);\r\n}\r\n}\r\nstatic void\r\nmv64xxx_i2c_hw_init(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nif (drv_data->offload_enabled) {\r\nwritel(0, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_CONTROL);\r\nwritel(0, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_TIMING);\r\nwritel(0, drv_data->reg_base +\r\nMV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);\r\nwritel(0, drv_data->reg_base +\r\nMV64XXX_I2C_REG_BRIDGE_INTR_MASK);\r\n}\r\nwritel(0, drv_data->reg_base + drv_data->reg_offsets.soft_reset);\r\nwritel(MV64XXX_I2C_BAUD_DIV_M(drv_data->freq_m) | MV64XXX_I2C_BAUD_DIV_N(drv_data->freq_n),\r\ndrv_data->reg_base + drv_data->reg_offsets.clock);\r\nwritel(0, drv_data->reg_base + drv_data->reg_offsets.addr);\r\nwritel(0, drv_data->reg_base + drv_data->reg_offsets.ext_addr);\r\nwritel(MV64XXX_I2C_REG_CONTROL_TWSIEN | MV64XXX_I2C_REG_CONTROL_STOP,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\n}\r\nstatic void\r\nmv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)\r\n{\r\nif (drv_data->state == MV64XXX_I2C_STATE_IDLE) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\nreturn;\r\n}\r\nswitch (status) {\r\ncase MV64XXX_I2C_STATUS_MAST_START:\r\ncase MV64XXX_I2C_STATUS_MAST_REPEAT_START:\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_1;\r\ndrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK;\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_MAST_WR_ADDR_ACK:\r\nif (drv_data->msg->flags & I2C_M_TEN) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;\r\nbreak;\r\n}\r\ncase MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK:\r\ncase MV64XXX_I2C_STATUS_MAST_WR_ACK:\r\nif ((drv_data->bytes_left == 0)\r\n|| (drv_data->aborting\r\n&& (drv_data->byte_posn != 0))) {\r\nif (drv_data->send_stop || drv_data->aborting) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\n} else {\r\ndrv_data->action =\r\nMV64XXX_I2C_ACTION_SEND_RESTART;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_RESTART;\r\n}\r\n} else {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;\r\ndrv_data->bytes_left--;\r\n}\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_MAST_RD_ADDR_ACK:\r\nif (drv_data->msg->flags & I2C_M_TEN) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;\r\nbreak;\r\n}\r\ncase MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK:\r\nif (drv_data->bytes_left == 0) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\nbreak;\r\n}\r\ncase MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK:\r\nif (status != MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK)\r\ndrv_data->action = MV64XXX_I2C_ACTION_CONTINUE;\r\nelse {\r\ndrv_data->action = MV64XXX_I2C_ACTION_RCV_DATA;\r\ndrv_data->bytes_left--;\r\n}\r\ndrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;\r\nif ((drv_data->bytes_left == 1) || drv_data->aborting)\r\ndrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_ACK;\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_MAST_RD_DATA_NO_ACK:\r\ndrv_data->action = MV64XXX_I2C_ACTION_RCV_DATA_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK:\r\ncase MV64XXX_I2C_STATUS_MAST_WR_NO_ACK:\r\ncase MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK:\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\ndrv_data->rc = -ENXIO;\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_OFFLOAD_OK:\r\nif (drv_data->send_stop || drv_data->aborting) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_OFFLOAD_SEND_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\n} else {\r\ndrv_data->action = MV64XXX_I2C_ACTION_OFFLOAD_RESTART;\r\ndrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_RESTART;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx_i2c_fsm: Ctlr Error -- state: 0x%x, "\r\n"status: 0x%x, addr: 0x%x, flags: 0x%x\n",\r\ndrv_data->state, status, drv_data->msg->addr,\r\ndrv_data->msg->flags);\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\nmv64xxx_i2c_hw_init(drv_data);\r\ndrv_data->rc = -EIO;\r\n}\r\n}\r\nstatic void mv64xxx_i2c_send_start(struct mv64xxx_i2c_data *drv_data)\r\n{\r\ndrv_data->msg = drv_data->msgs;\r\ndrv_data->byte_posn = 0;\r\ndrv_data->bytes_left = drv_data->msg->len;\r\ndrv_data->aborting = 0;\r\ndrv_data->rc = 0;\r\nif (mv64xxx_i2c_offload_msg(drv_data) < 0) {\r\nmv64xxx_i2c_prepare_for_io(drv_data, drv_data->msgs);\r\nwritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_START,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\n}\r\n}\r\nstatic void\r\nmv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nswitch(drv_data->action) {\r\ncase MV64XXX_I2C_ACTION_OFFLOAD_RESTART:\r\nmv64xxx_i2c_update_offload_data(drv_data);\r\nwritel(0, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_CONTROL);\r\nwritel(0, drv_data->reg_base +\r\nMV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);\r\ncase MV64XXX_I2C_ACTION_SEND_RESTART:\r\nBUG_ON(drv_data->num_msgs == 0);\r\ndrv_data->msgs++;\r\ndrv_data->num_msgs--;\r\nmv64xxx_i2c_send_start(drv_data);\r\nif (drv_data->errata_delay)\r\nudelay(5);\r\ndrv_data->send_stop = drv_data->num_msgs == 1;\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_CONTINUE:\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_SEND_ADDR_1:\r\nwritel(drv_data->addr1,\r\ndrv_data->reg_base + drv_data->reg_offsets.data);\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_SEND_ADDR_2:\r\nwritel(drv_data->addr2,\r\ndrv_data->reg_base + drv_data->reg_offsets.data);\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_SEND_DATA:\r\nwritel(drv_data->msg->buf[drv_data->byte_posn++],\r\ndrv_data->reg_base + drv_data->reg_offsets.data);\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_RCV_DATA:\r\ndrv_data->msg->buf[drv_data->byte_posn++] =\r\nreadl(drv_data->reg_base + drv_data->reg_offsets.data);\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_RCV_DATA_STOP:\r\ndrv_data->msg->buf[drv_data->byte_posn++] =\r\nreadl(drv_data->reg_base + drv_data->reg_offsets.data);\r\ndrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;\r\nwritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\ndrv_data->block = 0;\r\nif (drv_data->errata_delay)\r\nudelay(5);\r\nwake_up(&drv_data->waitq);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_INVALID:\r\ndefault:\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx_i2c_do_action: Invalid action: %d\n",\r\ndrv_data->action);\r\ndrv_data->rc = -EIO;\r\ncase MV64XXX_I2C_ACTION_SEND_STOP:\r\ndrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;\r\nwritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\ndrv_data->block = 0;\r\nwake_up(&drv_data->waitq);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_OFFLOAD_SEND_STOP:\r\nmv64xxx_i2c_update_offload_data(drv_data);\r\nwritel(0, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_CONTROL);\r\nwritel(0, drv_data->reg_base +\r\nMV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);\r\ndrv_data->block = 0;\r\nwake_up(&drv_data->waitq);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t\r\nmv64xxx_i2c_intr(int irq, void *dev_id)\r\n{\r\nstruct mv64xxx_i2c_data *drv_data = dev_id;\r\nunsigned long flags;\r\nu32 status;\r\nirqreturn_t rc = IRQ_NONE;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (drv_data->offload_enabled) {\r\nwhile (readl(drv_data->reg_base +\r\nMV64XXX_I2C_REG_BRIDGE_INTR_CAUSE)) {\r\nint reg_status = readl(drv_data->reg_base +\r\nMV64XXX_I2C_REG_BRIDGE_STATUS);\r\nif (reg_status & MV64XXX_I2C_BRIDGE_STATUS_ERROR)\r\nstatus = MV64XXX_I2C_STATUS_OFFLOAD_ERROR;\r\nelse\r\nstatus = MV64XXX_I2C_STATUS_OFFLOAD_OK;\r\nmv64xxx_i2c_fsm(drv_data, status);\r\nmv64xxx_i2c_do_action(drv_data);\r\nrc = IRQ_HANDLED;\r\n}\r\n}\r\nwhile (readl(drv_data->reg_base + drv_data->reg_offsets.control) &\r\nMV64XXX_I2C_REG_CONTROL_IFLG) {\r\nstatus = readl(drv_data->reg_base + drv_data->reg_offsets.status);\r\nmv64xxx_i2c_fsm(drv_data, status);\r\nmv64xxx_i2c_do_action(drv_data);\r\nif (drv_data->irq_clear_inverted)\r\nwritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_IFLG,\r\ndrv_data->reg_base + drv_data->reg_offsets.control);\r\nrc = IRQ_HANDLED;\r\n}\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nmv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nlong time_left;\r\nunsigned long flags;\r\nchar abort = 0;\r\ntime_left = wait_event_timeout(drv_data->waitq,\r\n!drv_data->block, drv_data->adapter.timeout);\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (!time_left) {\r\ndrv_data->rc = -ETIMEDOUT;\r\nabort = 1;\r\n} else if (time_left < 0) {\r\ndrv_data->rc = time_left;\r\nabort = 1;\r\n}\r\nif (abort && drv_data->block) {\r\ndrv_data->aborting = 1;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\ntime_left = wait_event_timeout(drv_data->waitq,\r\n!drv_data->block, drv_data->adapter.timeout);\r\nif ((time_left <= 0) && drv_data->block) {\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx: I2C bus locked, block: %d, "\r\n"time_left: %d\n", drv_data->block,\r\n(int)time_left);\r\nmv64xxx_i2c_hw_init(drv_data);\r\n}\r\n} else\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\n}\r\nstatic int\r\nmv64xxx_i2c_execute_msg(struct mv64xxx_i2c_data *drv_data, struct i2c_msg *msg,\r\nint is_last)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\ndrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_START_COND;\r\ndrv_data->send_stop = is_last;\r\ndrv_data->block = 1;\r\nmv64xxx_i2c_send_start(drv_data);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nmv64xxx_i2c_wait_for_completion(drv_data);\r\nreturn drv_data->rc;\r\n}\r\nstatic u32\r\nmv64xxx_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int\r\nmv64xxx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);\r\nint rc, ret = num;\r\nBUG_ON(drv_data->msgs != NULL);\r\ndrv_data->msgs = msgs;\r\ndrv_data->num_msgs = num;\r\nrc = mv64xxx_i2c_execute_msg(drv_data, &msgs[0], num == 1);\r\nif (rc < 0)\r\nret = rc;\r\ndrv_data->num_msgs = 0;\r\ndrv_data->msgs = NULL;\r\nreturn ret;\r\n}\r\nstatic int\r\nmv64xxx_calc_freq(const int tclk, const int n, const int m)\r\n{\r\nreturn tclk / (10 * (m + 1) * (2 << n));\r\n}\r\nstatic bool\r\nmv64xxx_find_baud_factors(const u32 req_freq, const u32 tclk, u32 *best_n,\r\nu32 *best_m)\r\n{\r\nint freq, delta, best_delta = INT_MAX;\r\nint m, n;\r\nfor (n = 0; n <= 7; n++)\r\nfor (m = 0; m <= 15; m++) {\r\nfreq = mv64xxx_calc_freq(tclk, n, m);\r\ndelta = req_freq - freq;\r\nif (delta >= 0 && delta < best_delta) {\r\n*best_m = m;\r\n*best_n = n;\r\nbest_delta = delta;\r\n}\r\nif (best_delta == 0)\r\nreturn true;\r\n}\r\nif (best_delta == INT_MAX)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int\r\nmv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,\r\nstruct device *dev)\r\n{\r\n#if !defined(CONFIG_HAVE_CLK)\r\nreturn -ENODEV;\r\n#else\r\nconst struct of_device_id *device;\r\nstruct device_node *np = dev->of_node;\r\nu32 bus_freq, tclk;\r\nint rc = 0;\r\nif (IS_ERR(drv_data->clk)) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\ntclk = clk_get_rate(drv_data->clk);\r\nif (of_property_read_u32(np, "clock-frequency", &bus_freq))\r\nbus_freq = 100000;\r\nif (!mv64xxx_find_baud_factors(bus_freq, tclk,\r\n&drv_data->freq_n, &drv_data->freq_m)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndrv_data->irq = irq_of_parse_and_map(np, 0);\r\ndrv_data->rstc = devm_reset_control_get_optional(dev, NULL);\r\nif (IS_ERR(drv_data->rstc)) {\r\nif (PTR_ERR(drv_data->rstc) == -EPROBE_DEFER) {\r\nrc = -EPROBE_DEFER;\r\ngoto out;\r\n}\r\n} else {\r\nreset_control_deassert(drv_data->rstc);\r\n}\r\ndrv_data->adapter.timeout = HZ;\r\ndevice = of_match_device(mv64xxx_i2c_of_match_table, dev);\r\nif (!device)\r\nreturn -ENODEV;\r\nmemcpy(&drv_data->reg_offsets, device->data, sizeof(drv_data->reg_offsets));\r\nif (of_device_is_compatible(np, "marvell,mv78230-i2c")) {\r\ndrv_data->offload_enabled = true;\r\ndrv_data->errata_delay = true;\r\n}\r\nif (of_device_is_compatible(np, "marvell,mv78230-a0-i2c")) {\r\ndrv_data->offload_enabled = false;\r\ndrv_data->errata_delay = true;\r\n}\r\nif (of_device_is_compatible(np, "allwinner,sun6i-a31-i2c"))\r\ndrv_data->irq_clear_inverted = true;\r\nout:\r\nreturn rc;\r\n#endif\r\n}\r\nstatic int\r\nmv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,\r\nstruct device *dev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nmv64xxx_i2c_probe(struct platform_device *pd)\r\n{\r\nstruct mv64xxx_i2c_data *drv_data;\r\nstruct mv64xxx_i2c_pdata *pdata = dev_get_platdata(&pd->dev);\r\nstruct resource *r;\r\nint rc;\r\nif ((!pdata && !pd->dev.of_node))\r\nreturn -ENODEV;\r\ndrv_data = devm_kzalloc(&pd->dev, sizeof(struct mv64xxx_i2c_data),\r\nGFP_KERNEL);\r\nif (!drv_data)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pd, IORESOURCE_MEM, 0);\r\ndrv_data->reg_base = devm_ioremap_resource(&pd->dev, r);\r\nif (IS_ERR(drv_data->reg_base))\r\nreturn PTR_ERR(drv_data->reg_base);\r\nstrlcpy(drv_data->adapter.name, MV64XXX_I2C_CTLR_NAME " adapter",\r\nsizeof(drv_data->adapter.name));\r\ninit_waitqueue_head(&drv_data->waitq);\r\nspin_lock_init(&drv_data->lock);\r\n#if defined(CONFIG_HAVE_CLK)\r\ndrv_data->clk = devm_clk_get(&pd->dev, NULL);\r\nif (!IS_ERR(drv_data->clk)) {\r\nclk_prepare(drv_data->clk);\r\nclk_enable(drv_data->clk);\r\n}\r\n#endif\r\nif (pdata) {\r\ndrv_data->freq_m = pdata->freq_m;\r\ndrv_data->freq_n = pdata->freq_n;\r\ndrv_data->irq = platform_get_irq(pd, 0);\r\ndrv_data->adapter.timeout = msecs_to_jiffies(pdata->timeout);\r\ndrv_data->offload_enabled = false;\r\nmemcpy(&drv_data->reg_offsets, &mv64xxx_i2c_regs_mv64xxx, sizeof(drv_data->reg_offsets));\r\n} else if (pd->dev.of_node) {\r\nrc = mv64xxx_of_config(drv_data, &pd->dev);\r\nif (rc)\r\ngoto exit_clk;\r\n}\r\nif (drv_data->irq < 0) {\r\nrc = -ENXIO;\r\ngoto exit_reset;\r\n}\r\ndrv_data->adapter.dev.parent = &pd->dev;\r\ndrv_data->adapter.algo = &mv64xxx_i2c_algo;\r\ndrv_data->adapter.owner = THIS_MODULE;\r\ndrv_data->adapter.class = I2C_CLASS_DEPRECATED;\r\ndrv_data->adapter.nr = pd->id;\r\ndrv_data->adapter.dev.of_node = pd->dev.of_node;\r\nplatform_set_drvdata(pd, drv_data);\r\ni2c_set_adapdata(&drv_data->adapter, drv_data);\r\nmv64xxx_i2c_hw_init(drv_data);\r\nrc = request_irq(drv_data->irq, mv64xxx_i2c_intr, 0,\r\nMV64XXX_I2C_CTLR_NAME, drv_data);\r\nif (rc) {\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx: Can't register intr handler irq%d: %d\n",\r\ndrv_data->irq, rc);\r\ngoto exit_reset;\r\n} else if ((rc = i2c_add_numbered_adapter(&drv_data->adapter)) != 0) {\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx: Can't add i2c adapter, rc: %d\n", -rc);\r\ngoto exit_free_irq;\r\n}\r\nreturn 0;\r\nexit_free_irq:\r\nfree_irq(drv_data->irq, drv_data);\r\nexit_reset:\r\nif (!IS_ERR_OR_NULL(drv_data->rstc))\r\nreset_control_assert(drv_data->rstc);\r\nexit_clk:\r\n#if defined(CONFIG_HAVE_CLK)\r\nif (!IS_ERR(drv_data->clk)) {\r\nclk_disable(drv_data->clk);\r\nclk_unprepare(drv_data->clk);\r\n}\r\n#endif\r\nreturn rc;\r\n}\r\nstatic int\r\nmv64xxx_i2c_remove(struct platform_device *dev)\r\n{\r\nstruct mv64xxx_i2c_data *drv_data = platform_get_drvdata(dev);\r\ni2c_del_adapter(&drv_data->adapter);\r\nfree_irq(drv_data->irq, drv_data);\r\nif (!IS_ERR_OR_NULL(drv_data->rstc))\r\nreset_control_assert(drv_data->rstc);\r\n#if defined(CONFIG_HAVE_CLK)\r\nif (!IS_ERR(drv_data->clk)) {\r\nclk_disable(drv_data->clk);\r\nclk_unprepare(drv_data->clk);\r\n}\r\n#endif\r\nreturn 0;\r\n}
