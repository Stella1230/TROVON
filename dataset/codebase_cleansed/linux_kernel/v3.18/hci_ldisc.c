int hci_uart_register_proto(struct hci_uart_proto *p)\r\n{\r\nif (p->id >= HCI_UART_MAX_PROTO)\r\nreturn -EINVAL;\r\nif (hup[p->id])\r\nreturn -EEXIST;\r\nhup[p->id] = p;\r\nreturn 0;\r\n}\r\nint hci_uart_unregister_proto(struct hci_uart_proto *p)\r\n{\r\nif (p->id >= HCI_UART_MAX_PROTO)\r\nreturn -EINVAL;\r\nif (!hup[p->id])\r\nreturn -EINVAL;\r\nhup[p->id] = NULL;\r\nreturn 0;\r\n}\r\nstatic struct hci_uart_proto *hci_uart_get_proto(unsigned int id)\r\n{\r\nif (id >= HCI_UART_MAX_PROTO)\r\nreturn NULL;\r\nreturn hup[id];\r\n}\r\nstatic inline void hci_uart_tx_complete(struct hci_uart *hu, int pkt_type)\r\n{\r\nstruct hci_dev *hdev = hu->hdev;\r\nswitch (pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n}\r\n}\r\nstatic inline struct sk_buff *hci_uart_dequeue(struct hci_uart *hu)\r\n{\r\nstruct sk_buff *skb = hu->tx_skb;\r\nif (!skb)\r\nskb = hu->proto->dequeue(hu);\r\nelse\r\nhu->tx_skb = NULL;\r\nreturn skb;\r\n}\r\nint hci_uart_tx_wakeup(struct hci_uart *hu)\r\n{\r\nif (test_and_set_bit(HCI_UART_SENDING, &hu->tx_state)) {\r\nset_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\r\nreturn 0;\r\n}\r\nBT_DBG("");\r\nschedule_work(&hu->write_work);\r\nreturn 0;\r\n}\r\nstatic void hci_uart_write_work(struct work_struct *work)\r\n{\r\nstruct hci_uart *hu = container_of(work, struct hci_uart, write_work);\r\nstruct tty_struct *tty = hu->tty;\r\nstruct hci_dev *hdev = hu->hdev;\r\nstruct sk_buff *skb;\r\nrestart:\r\nclear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\r\nwhile ((skb = hci_uart_dequeue(hu))) {\r\nint len;\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nlen = tty->ops->write(tty, skb->data, skb->len);\r\nhdev->stat.byte_tx += len;\r\nskb_pull(skb, len);\r\nif (skb->len) {\r\nhu->tx_skb = skb;\r\nbreak;\r\n}\r\nhci_uart_tx_complete(hu, bt_cb(skb)->pkt_type);\r\nkfree_skb(skb);\r\n}\r\nif (test_bit(HCI_UART_TX_WAKEUP, &hu->tx_state))\r\ngoto restart;\r\nclear_bit(HCI_UART_SENDING, &hu->tx_state);\r\n}\r\nstatic void hci_uart_init_work(struct work_struct *work)\r\n{\r\nstruct hci_uart *hu = container_of(work, struct hci_uart, init_ready);\r\nint err;\r\nif (!test_and_clear_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\r\nreturn;\r\nerr = hci_register_dev(hu->hdev);\r\nif (err < 0) {\r\nBT_ERR("Can't register HCI device");\r\nhci_free_dev(hu->hdev);\r\nhu->hdev = NULL;\r\nhu->proto->close(hu);\r\n}\r\nset_bit(HCI_UART_REGISTERED, &hu->flags);\r\n}\r\nint hci_uart_init_ready(struct hci_uart *hu)\r\n{\r\nif (!test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\r\nreturn -EALREADY;\r\nschedule_work(&hu->init_ready);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_open(struct hci_dev *hdev)\r\n{\r\nBT_DBG("%s %p", hdev->name, hdev);\r\nset_bit(HCI_RUNNING, &hdev->flags);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_flush(struct hci_dev *hdev)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct tty_struct *tty = hu->tty;\r\nBT_DBG("hdev %p tty %p", hdev, tty);\r\nif (hu->tx_skb) {\r\nkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\r\n}\r\ntty_ldisc_flush(tty);\r\ntty_driver_flush_buffer(tty);\r\nif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\r\nhu->proto->flush(hu);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_close(struct hci_dev *hdev)\r\n{\r\nBT_DBG("hdev %p", hdev);\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nhci_uart_flush(hdev);\r\nhdev->flush = NULL;\r\nreturn 0;\r\n}\r\nstatic int hci_uart_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\nBT_DBG("%s: type %d len %d", hdev->name, bt_cb(skb)->pkt_type, skb->len);\r\nhu->proto->enqueue(hu, skb);\r\nhci_uart_tx_wakeup(hu);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_tty_open(struct tty_struct *tty)\r\n{\r\nstruct hci_uart *hu;\r\nBT_DBG("tty %p", tty);\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\nhu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL);\r\nif (!hu) {\r\nBT_ERR("Can't allocate control structure");\r\nreturn -ENFILE;\r\n}\r\ntty->disc_data = hu;\r\nhu->tty = tty;\r\ntty->receive_room = 65536;\r\nINIT_WORK(&hu->init_ready, hci_uart_init_work);\r\nINIT_WORK(&hu->write_work, hci_uart_write_work);\r\nspin_lock_init(&hu->rx_lock);\r\nif (tty->ldisc->ops->flush_buffer)\r\ntty->ldisc->ops->flush_buffer(tty);\r\ntty_driver_flush_buffer(tty);\r\nreturn 0;\r\n}\r\nstatic void hci_uart_tty_close(struct tty_struct *tty)\r\n{\r\nstruct hci_uart *hu = (void *)tty->disc_data;\r\nstruct hci_dev *hdev;\r\nBT_DBG("tty %p", tty);\r\ntty->disc_data = NULL;\r\nif (!hu)\r\nreturn;\r\nhdev = hu->hdev;\r\nif (hdev)\r\nhci_uart_close(hdev);\r\ncancel_work_sync(&hu->write_work);\r\nif (test_and_clear_bit(HCI_UART_PROTO_SET, &hu->flags)) {\r\nif (hdev) {\r\nif (test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\n}\r\nhu->proto->close(hu);\r\n}\r\nkfree(hu);\r\n}\r\nstatic void hci_uart_tty_wakeup(struct tty_struct *tty)\r\n{\r\nstruct hci_uart *hu = (void *)tty->disc_data;\r\nBT_DBG("");\r\nif (!hu)\r\nreturn;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nif (tty != hu->tty)\r\nreturn;\r\nif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data, char *flags, int count)\r\n{\r\nstruct hci_uart *hu = (void *)tty->disc_data;\r\nif (!hu || tty != hu->tty)\r\nreturn;\r\nif (!test_bit(HCI_UART_PROTO_SET, &hu->flags))\r\nreturn;\r\nspin_lock(&hu->rx_lock);\r\nhu->proto->recv(hu, (void *) data, count);\r\nif (hu->hdev)\r\nhu->hdev->stat.byte_rx += count;\r\nspin_unlock(&hu->rx_lock);\r\ntty_unthrottle(tty);\r\n}\r\nstatic int hci_uart_register_dev(struct hci_uart *hu)\r\n{\r\nstruct hci_dev *hdev;\r\nBT_DBG("");\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can't allocate HCI device");\r\nreturn -ENOMEM;\r\n}\r\nhu->hdev = hdev;\r\nhdev->bus = HCI_UART;\r\nhci_set_drvdata(hdev, hu);\r\nhdev->open = hci_uart_open;\r\nhdev->close = hci_uart_close;\r\nhdev->flush = hci_uart_flush;\r\nhdev->send = hci_uart_send_frame;\r\nSET_HCIDEV_DEV(hdev, hu->tty->dev);\r\nif (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))\r\nset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\r\nif (test_bit(HCI_UART_EXT_CONFIG, &hu->hdev_flags))\r\nset_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks);\r\nif (!test_bit(HCI_UART_RESET_ON_INIT, &hu->hdev_flags))\r\nset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\r\nif (test_bit(HCI_UART_CREATE_AMP, &hu->hdev_flags))\r\nhdev->dev_type = HCI_AMP;\r\nelse\r\nhdev->dev_type = HCI_BREDR;\r\nif (test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\r\nreturn 0;\r\nif (hci_register_dev(hdev) < 0) {\r\nBT_ERR("Can't register HCI device");\r\nhci_free_dev(hdev);\r\nreturn -ENODEV;\r\n}\r\nset_bit(HCI_UART_REGISTERED, &hu->flags);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_set_proto(struct hci_uart *hu, int id)\r\n{\r\nstruct hci_uart_proto *p;\r\nint err;\r\np = hci_uart_get_proto(id);\r\nif (!p)\r\nreturn -EPROTONOSUPPORT;\r\nerr = p->open(hu);\r\nif (err)\r\nreturn err;\r\nhu->proto = p;\r\nerr = hci_uart_register_dev(hu);\r\nif (err) {\r\np->close(hu);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hci_uart_set_flags(struct hci_uart *hu, unsigned long flags)\r\n{\r\nunsigned long valid_flags = BIT(HCI_UART_RAW_DEVICE) |\r\nBIT(HCI_UART_RESET_ON_INIT) |\r\nBIT(HCI_UART_CREATE_AMP) |\r\nBIT(HCI_UART_INIT_PENDING) |\r\nBIT(HCI_UART_EXT_CONFIG);\r\nif ((flags & ~valid_flags))\r\nreturn -EINVAL;\r\nhu->hdev_flags = flags;\r\nreturn 0;\r\n}\r\nstatic int hci_uart_tty_ioctl(struct tty_struct *tty, struct file * file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct hci_uart *hu = (void *)tty->disc_data;\r\nint err = 0;\r\nBT_DBG("");\r\nif (!hu)\r\nreturn -EBADF;\r\nswitch (cmd) {\r\ncase HCIUARTSETPROTO:\r\nif (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {\r\nerr = hci_uart_set_proto(hu, arg);\r\nif (err) {\r\nclear_bit(HCI_UART_PROTO_SET, &hu->flags);\r\nreturn err;\r\n}\r\n} else\r\nreturn -EBUSY;\r\nbreak;\r\ncase HCIUARTGETPROTO:\r\nif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\r\nreturn hu->proto->id;\r\nreturn -EUNATCH;\r\ncase HCIUARTGETDEVICE:\r\nif (test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nreturn hu->hdev->id;\r\nreturn -EUNATCH;\r\ncase HCIUARTSETFLAGS:\r\nif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\r\nreturn -EBUSY;\r\nerr = hci_uart_set_flags(hu, arg);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase HCIUARTGETFLAGS:\r\nreturn hu->hdev_flags;\r\ndefault:\r\nerr = n_tty_ioctl_helper(tty, file, cmd, arg);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t hci_uart_tty_read(struct tty_struct *tty, struct file *file,\r\nunsigned char __user *buf, size_t nr)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t hci_uart_tty_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *data, size_t count)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int hci_uart_tty_poll(struct tty_struct *tty,\r\nstruct file *filp, poll_table *wait)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init hci_uart_init(void)\r\n{\r\nstatic struct tty_ldisc_ops hci_uart_ldisc;\r\nint err;\r\nBT_INFO("HCI UART driver ver %s", VERSION);\r\nmemset(&hci_uart_ldisc, 0, sizeof (hci_uart_ldisc));\r\nhci_uart_ldisc.magic = TTY_LDISC_MAGIC;\r\nhci_uart_ldisc.name = "n_hci";\r\nhci_uart_ldisc.open = hci_uart_tty_open;\r\nhci_uart_ldisc.close = hci_uart_tty_close;\r\nhci_uart_ldisc.read = hci_uart_tty_read;\r\nhci_uart_ldisc.write = hci_uart_tty_write;\r\nhci_uart_ldisc.ioctl = hci_uart_tty_ioctl;\r\nhci_uart_ldisc.poll = hci_uart_tty_poll;\r\nhci_uart_ldisc.receive_buf = hci_uart_tty_receive;\r\nhci_uart_ldisc.write_wakeup = hci_uart_tty_wakeup;\r\nhci_uart_ldisc.owner = THIS_MODULE;\r\nerr = tty_register_ldisc(N_HCI, &hci_uart_ldisc);\r\nif (err) {\r\nBT_ERR("HCI line discipline registration failed. (%d)", err);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_BT_HCIUART_H4\r\nh4_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_BCSP\r\nbcsp_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_LL\r\nll_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_ATH3K\r\nath_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_3WIRE\r\nh5_init();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit hci_uart_exit(void)\r\n{\r\nint err;\r\n#ifdef CONFIG_BT_HCIUART_H4\r\nh4_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_BCSP\r\nbcsp_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_LL\r\nll_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_ATH3K\r\nath_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_3WIRE\r\nh5_deinit();\r\n#endif\r\nerr = tty_unregister_ldisc(N_HCI);\r\nif (err)\r\nBT_ERR("Can't unregister HCI line discipline (%d)", err);\r\n}
