static int i40evf_send_pf_msg(struct i40evf_adapter *adapter,\r\nenum i40e_virtchnl_ops op, u8 *msg, u16 len)\r\n{\r\nstruct i40e_hw *hw = &adapter->hw;\r\ni40e_status err;\r\nif (adapter->flags & I40EVF_FLAG_PF_COMMS_FAILED)\r\nreturn 0;\r\nerr = i40e_aq_send_msg_to_pf(hw, op, 0, msg, len, NULL);\r\nif (err)\r\ndev_err(&adapter->pdev->dev, "Unable to send opcode %d to PF, error %d, aq status %d\n",\r\nop, err, hw->aq.asq_last_status);\r\nreturn err;\r\n}\r\nint i40evf_send_api_ver(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_version_info vvi;\r\nvvi.major = I40E_VIRTCHNL_VERSION_MAJOR;\r\nvvi.minor = I40E_VIRTCHNL_VERSION_MINOR;\r\nreturn i40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_VERSION, (u8 *)&vvi,\r\nsizeof(vvi));\r\n}\r\nint i40evf_verify_api_ver(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_version_info *pf_vvi;\r\nstruct i40e_hw *hw = &adapter->hw;\r\nstruct i40e_arq_event_info event;\r\ni40e_status err;\r\nevent.msg_size = I40EVF_MAX_AQ_BUF_SIZE;\r\nevent.msg_buf = kzalloc(event.msg_size, GFP_KERNEL);\r\nif (!event.msg_buf) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = i40evf_clean_arq_element(hw, &event, NULL);\r\nif (err == I40E_ERR_ADMIN_QUEUE_NO_WORK)\r\ngoto out_alloc;\r\nerr = (i40e_status)le32_to_cpu(event.desc.cookie_low);\r\nif (err)\r\ngoto out_alloc;\r\nif ((enum i40e_virtchnl_ops)le32_to_cpu(event.desc.cookie_high) !=\r\nI40E_VIRTCHNL_OP_VERSION) {\r\ndev_info(&adapter->pdev->dev, "Invalid reply type %d from PF\n",\r\nle32_to_cpu(event.desc.cookie_high));\r\nerr = -EIO;\r\ngoto out_alloc;\r\n}\r\npf_vvi = (struct i40e_virtchnl_version_info *)event.msg_buf;\r\nif ((pf_vvi->major != I40E_VIRTCHNL_VERSION_MAJOR) ||\r\n(pf_vvi->minor != I40E_VIRTCHNL_VERSION_MINOR))\r\nerr = -EIO;\r\nout_alloc:\r\nkfree(event.msg_buf);\r\nout:\r\nreturn err;\r\n}\r\nint i40evf_send_vf_config_msg(struct i40evf_adapter *adapter)\r\n{\r\nreturn i40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_GET_VF_RESOURCES,\r\nNULL, 0);\r\n}\r\nint i40evf_get_vf_config(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_hw *hw = &adapter->hw;\r\nstruct i40e_arq_event_info event;\r\nu16 len;\r\ni40e_status err;\r\nlen = sizeof(struct i40e_virtchnl_vf_resource) +\r\nI40E_MAX_VF_VSI * sizeof(struct i40e_virtchnl_vsi_resource);\r\nevent.msg_size = len;\r\nevent.msg_buf = kzalloc(event.msg_size, GFP_KERNEL);\r\nif (!event.msg_buf) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = i40evf_clean_arq_element(hw, &event, NULL);\r\nif (err == I40E_ERR_ADMIN_QUEUE_NO_WORK)\r\ngoto out_alloc;\r\nerr = (i40e_status)le32_to_cpu(event.desc.cookie_low);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Error returned from PF, %d, %d\n", __func__,\r\nle32_to_cpu(event.desc.cookie_high),\r\nle32_to_cpu(event.desc.cookie_low));\r\nerr = -EIO;\r\ngoto out_alloc;\r\n}\r\nif ((enum i40e_virtchnl_ops)le32_to_cpu(event.desc.cookie_high) !=\r\nI40E_VIRTCHNL_OP_GET_VF_RESOURCES) {\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Invalid response from PF, %d, %d\n", __func__,\r\nle32_to_cpu(event.desc.cookie_high),\r\nle32_to_cpu(event.desc.cookie_low));\r\nerr = -EIO;\r\ngoto out_alloc;\r\n}\r\nmemcpy(adapter->vf_res, event.msg_buf, min(event.msg_size, len));\r\ni40e_vf_parse_hw_config(hw, adapter->vf_res);\r\nout_alloc:\r\nkfree(event.msg_buf);\r\nout:\r\nreturn err;\r\n}\r\nvoid i40evf_configure_queues(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_vsi_queue_config_info *vqci;\r\nstruct i40e_virtchnl_queue_pair_info *vqpi;\r\nint pairs = adapter->vsi_res->num_queue_pairs;\r\nint i, len;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES;\r\nlen = sizeof(struct i40e_virtchnl_vsi_queue_config_info) +\r\n(sizeof(struct i40e_virtchnl_queue_pair_info) * pairs);\r\nvqci = kzalloc(len, GFP_ATOMIC);\r\nif (!vqci)\r\nreturn;\r\nvqci->vsi_id = adapter->vsi_res->vsi_id;\r\nvqci->num_queue_pairs = pairs;\r\nvqpi = vqci->qpair;\r\nfor (i = 0; i < pairs; i++) {\r\nvqpi->txq.vsi_id = vqci->vsi_id;\r\nvqpi->txq.queue_id = i;\r\nvqpi->txq.ring_len = adapter->tx_rings[i]->count;\r\nvqpi->txq.dma_ring_addr = adapter->tx_rings[i]->dma;\r\nvqpi->txq.headwb_enabled = 1;\r\nvqpi->txq.dma_headwb_addr = vqpi->txq.dma_ring_addr +\r\n(vqpi->txq.ring_len * sizeof(struct i40e_tx_desc));\r\nvqpi->rxq.vsi_id = vqci->vsi_id;\r\nvqpi->rxq.queue_id = i;\r\nvqpi->rxq.ring_len = adapter->rx_rings[i]->count;\r\nvqpi->rxq.dma_ring_addr = adapter->rx_rings[i]->dma;\r\nvqpi->rxq.max_pkt_size = adapter->netdev->mtu\r\n+ ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN;\r\nvqpi->rxq.databuffer_size = adapter->rx_rings[i]->rx_buf_len;\r\nvqpi++;\r\n}\r\nadapter->aq_pending |= I40EVF_FLAG_AQ_CONFIGURE_QUEUES;\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_CONFIGURE_QUEUES;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES,\r\n(u8 *)vqci, len);\r\nkfree(vqci);\r\n}\r\nvoid i40evf_enable_queues(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_queue_select vqs;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_ENABLE_QUEUES;\r\nvqs.vsi_id = adapter->vsi_res->vsi_id;\r\nvqs.tx_queues = (1 << adapter->vsi_res->num_queue_pairs) - 1;\r\nvqs.rx_queues = vqs.tx_queues;\r\nadapter->aq_pending |= I40EVF_FLAG_AQ_ENABLE_QUEUES;\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_ENABLE_QUEUES;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_ENABLE_QUEUES,\r\n(u8 *)&vqs, sizeof(vqs));\r\n}\r\nvoid i40evf_disable_queues(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_queue_select vqs;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_DISABLE_QUEUES;\r\nvqs.vsi_id = adapter->vsi_res->vsi_id;\r\nvqs.tx_queues = (1 << adapter->vsi_res->num_queue_pairs) - 1;\r\nvqs.rx_queues = vqs.tx_queues;\r\nadapter->aq_pending |= I40EVF_FLAG_AQ_DISABLE_QUEUES;\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_DISABLE_QUEUES;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_DISABLE_QUEUES,\r\n(u8 *)&vqs, sizeof(vqs));\r\n}\r\nvoid i40evf_map_queues(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_irq_map_info *vimi;\r\nint v_idx, q_vectors, len;\r\nstruct i40e_q_vector *q_vector;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP;\r\nq_vectors = adapter->num_msix_vectors - NONQ_VECS;\r\nlen = sizeof(struct i40e_virtchnl_irq_map_info) +\r\n(adapter->num_msix_vectors *\r\nsizeof(struct i40e_virtchnl_vector_map));\r\nvimi = kzalloc(len, GFP_ATOMIC);\r\nif (!vimi)\r\nreturn;\r\nvimi->num_vectors = adapter->num_msix_vectors;\r\nfor (v_idx = 0; v_idx < q_vectors; v_idx++) {\r\nq_vector = adapter->q_vector[v_idx];\r\nvimi->vecmap[v_idx].vsi_id = adapter->vsi_res->vsi_id;\r\nvimi->vecmap[v_idx].vector_id = v_idx + NONQ_VECS;\r\nvimi->vecmap[v_idx].txq_map = q_vector->ring_mask;\r\nvimi->vecmap[v_idx].rxq_map = q_vector->ring_mask;\r\n}\r\nvimi->vecmap[v_idx].vsi_id = adapter->vsi_res->vsi_id;\r\nvimi->vecmap[v_idx].vector_id = 0;\r\nvimi->vecmap[v_idx].txq_map = 0;\r\nvimi->vecmap[v_idx].rxq_map = 0;\r\nadapter->aq_pending |= I40EVF_FLAG_AQ_MAP_VECTORS;\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_MAP_VECTORS;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP,\r\n(u8 *)vimi, len);\r\nkfree(vimi);\r\n}\r\nvoid i40evf_add_ether_addrs(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_ether_addr_list *veal;\r\nint len, i = 0, count = 0;\r\nstruct i40evf_mac_filter *f;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nlist_for_each_entry(f, &adapter->mac_filter_list, list) {\r\nif (f->add)\r\ncount++;\r\n}\r\nif (!count) {\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_ADD_MAC_FILTER;\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS;\r\nlen = sizeof(struct i40e_virtchnl_ether_addr_list) +\r\n(count * sizeof(struct i40e_virtchnl_ether_addr));\r\nif (len > I40EVF_MAX_AQ_BUF_SIZE) {\r\ndev_warn(&adapter->pdev->dev, "%s: Too many MAC address changes in one request\n",\r\n__func__);\r\ncount = (I40EVF_MAX_AQ_BUF_SIZE -\r\nsizeof(struct i40e_virtchnl_ether_addr_list)) /\r\nsizeof(struct i40e_virtchnl_ether_addr);\r\nlen = I40EVF_MAX_AQ_BUF_SIZE;\r\n}\r\nveal = kzalloc(len, GFP_ATOMIC);\r\nif (!veal)\r\nreturn;\r\nveal->vsi_id = adapter->vsi_res->vsi_id;\r\nveal->num_elements = count;\r\nlist_for_each_entry(f, &adapter->mac_filter_list, list) {\r\nif (f->add) {\r\nether_addr_copy(veal->list[i].addr, f->macaddr);\r\ni++;\r\nf->add = false;\r\n}\r\n}\r\nadapter->aq_pending |= I40EVF_FLAG_AQ_ADD_MAC_FILTER;\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_ADD_MAC_FILTER;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS,\r\n(u8 *)veal, len);\r\nkfree(veal);\r\n}\r\nvoid i40evf_del_ether_addrs(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_ether_addr_list *veal;\r\nstruct i40evf_mac_filter *f, *ftmp;\r\nint len, i = 0, count = 0;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nlist_for_each_entry(f, &adapter->mac_filter_list, list) {\r\nif (f->remove)\r\ncount++;\r\n}\r\nif (!count) {\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_DEL_MAC_FILTER;\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS;\r\nlen = sizeof(struct i40e_virtchnl_ether_addr_list) +\r\n(count * sizeof(struct i40e_virtchnl_ether_addr));\r\nif (len > I40EVF_MAX_AQ_BUF_SIZE) {\r\ndev_warn(&adapter->pdev->dev, "%s: Too many MAC address changes in one request\n",\r\n__func__);\r\ncount = (I40EVF_MAX_AQ_BUF_SIZE -\r\nsizeof(struct i40e_virtchnl_ether_addr_list)) /\r\nsizeof(struct i40e_virtchnl_ether_addr);\r\nlen = I40EVF_MAX_AQ_BUF_SIZE;\r\n}\r\nveal = kzalloc(len, GFP_ATOMIC);\r\nif (!veal)\r\nreturn;\r\nveal->vsi_id = adapter->vsi_res->vsi_id;\r\nveal->num_elements = count;\r\nlist_for_each_entry_safe(f, ftmp, &adapter->mac_filter_list, list) {\r\nif (f->remove) {\r\nether_addr_copy(veal->list[i].addr, f->macaddr);\r\ni++;\r\nlist_del(&f->list);\r\nkfree(f);\r\n}\r\n}\r\nadapter->aq_pending |= I40EVF_FLAG_AQ_DEL_MAC_FILTER;\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_DEL_MAC_FILTER;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS,\r\n(u8 *)veal, len);\r\nkfree(veal);\r\n}\r\nvoid i40evf_add_vlans(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_vlan_filter_list *vvfl;\r\nint len, i = 0, count = 0;\r\nstruct i40evf_vlan_filter *f;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nlist_for_each_entry(f, &adapter->vlan_filter_list, list) {\r\nif (f->add)\r\ncount++;\r\n}\r\nif (!count) {\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_ADD_VLAN_FILTER;\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_ADD_VLAN;\r\nlen = sizeof(struct i40e_virtchnl_vlan_filter_list) +\r\n(count * sizeof(u16));\r\nif (len > I40EVF_MAX_AQ_BUF_SIZE) {\r\ndev_warn(&adapter->pdev->dev, "%s: Too many VLAN changes in one request\n",\r\n__func__);\r\ncount = (I40EVF_MAX_AQ_BUF_SIZE -\r\nsizeof(struct i40e_virtchnl_vlan_filter_list)) /\r\nsizeof(u16);\r\nlen = I40EVF_MAX_AQ_BUF_SIZE;\r\n}\r\nvvfl = kzalloc(len, GFP_ATOMIC);\r\nif (!vvfl)\r\nreturn;\r\nvvfl->vsi_id = adapter->vsi_res->vsi_id;\r\nvvfl->num_elements = count;\r\nlist_for_each_entry(f, &adapter->vlan_filter_list, list) {\r\nif (f->add) {\r\nvvfl->vlan_id[i] = f->vlan;\r\ni++;\r\nf->add = false;\r\n}\r\n}\r\nadapter->aq_pending |= I40EVF_FLAG_AQ_ADD_VLAN_FILTER;\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_ADD_VLAN_FILTER;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_ADD_VLAN, (u8 *)vvfl, len);\r\nkfree(vvfl);\r\n}\r\nvoid i40evf_del_vlans(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_vlan_filter_list *vvfl;\r\nstruct i40evf_vlan_filter *f, *ftmp;\r\nint len, i = 0, count = 0;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nlist_for_each_entry(f, &adapter->vlan_filter_list, list) {\r\nif (f->remove)\r\ncount++;\r\n}\r\nif (!count) {\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_DEL_VLAN_FILTER;\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_DEL_VLAN;\r\nlen = sizeof(struct i40e_virtchnl_vlan_filter_list) +\r\n(count * sizeof(u16));\r\nif (len > I40EVF_MAX_AQ_BUF_SIZE) {\r\ndev_warn(&adapter->pdev->dev, "%s: Too many VLAN changes in one request\n",\r\n__func__);\r\ncount = (I40EVF_MAX_AQ_BUF_SIZE -\r\nsizeof(struct i40e_virtchnl_vlan_filter_list)) /\r\nsizeof(u16);\r\nlen = I40EVF_MAX_AQ_BUF_SIZE;\r\n}\r\nvvfl = kzalloc(len, GFP_ATOMIC);\r\nif (!vvfl)\r\nreturn;\r\nvvfl->vsi_id = adapter->vsi_res->vsi_id;\r\nvvfl->num_elements = count;\r\nlist_for_each_entry_safe(f, ftmp, &adapter->vlan_filter_list, list) {\r\nif (f->remove) {\r\nvvfl->vlan_id[i] = f->vlan;\r\ni++;\r\nlist_del(&f->list);\r\nkfree(f);\r\n}\r\n}\r\nadapter->aq_pending |= I40EVF_FLAG_AQ_DEL_VLAN_FILTER;\r\nadapter->aq_required &= ~I40EVF_FLAG_AQ_DEL_VLAN_FILTER;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_DEL_VLAN, (u8 *)vvfl, len);\r\nkfree(vvfl);\r\n}\r\nvoid i40evf_set_promiscuous(struct i40evf_adapter *adapter, int flags)\r\n{\r\nstruct i40e_virtchnl_promisc_info vpi;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\ndev_err(&adapter->pdev->dev, "%s: command %d pending\n",\r\n__func__, adapter->current_op);\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE;\r\nvpi.vsi_id = adapter->vsi_res->vsi_id;\r\nvpi.flags = flags;\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,\r\n(u8 *)&vpi, sizeof(vpi));\r\n}\r\nvoid i40evf_request_stats(struct i40evf_adapter *adapter)\r\n{\r\nstruct i40e_virtchnl_queue_select vqs;\r\nif (adapter->current_op != I40E_VIRTCHNL_OP_UNKNOWN) {\r\nreturn;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_GET_STATS;\r\nvqs.vsi_id = adapter->vsi_res->vsi_id;\r\nif (i40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_GET_STATS,\r\n(u8 *)&vqs, sizeof(vqs)))\r\nadapter->current_op = I40E_VIRTCHNL_OP_UNKNOWN;\r\n}\r\nvoid i40evf_request_reset(struct i40evf_adapter *adapter)\r\n{\r\ni40evf_send_pf_msg(adapter, I40E_VIRTCHNL_OP_RESET_VF, NULL, 0);\r\nadapter->current_op = I40E_VIRTCHNL_OP_UNKNOWN;\r\n}\r\nvoid i40evf_virtchnl_completion(struct i40evf_adapter *adapter,\r\nenum i40e_virtchnl_ops v_opcode,\r\ni40e_status v_retval,\r\nu8 *msg, u16 msglen)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (v_opcode == I40E_VIRTCHNL_OP_EVENT) {\r\nstruct i40e_virtchnl_pf_event *vpe =\r\n(struct i40e_virtchnl_pf_event *)msg;\r\nswitch (vpe->event) {\r\ncase I40E_VIRTCHNL_EVENT_LINK_CHANGE:\r\nadapter->link_up =\r\nvpe->event_data.link_event.link_status;\r\nif (adapter->link_up && !netif_carrier_ok(netdev)) {\r\ndev_info(&adapter->pdev->dev, "NIC Link is Up\n");\r\nnetif_carrier_on(netdev);\r\nnetif_tx_wake_all_queues(netdev);\r\n} else if (!adapter->link_up) {\r\ndev_info(&adapter->pdev->dev, "NIC Link is Down\n");\r\nnetif_carrier_off(netdev);\r\nnetif_tx_stop_all_queues(netdev);\r\n}\r\nbreak;\r\ncase I40E_VIRTCHNL_EVENT_RESET_IMPENDING:\r\ndev_info(&adapter->pdev->dev, "PF reset warning received\n");\r\nif (!(adapter->flags & I40EVF_FLAG_RESET_PENDING)) {\r\nadapter->flags |= I40EVF_FLAG_RESET_PENDING;\r\ndev_info(&adapter->pdev->dev, "Scheduling reset task\n");\r\nschedule_work(&adapter->reset_task);\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->pdev->dev,\r\n"%s: Unknown event %d from pf\n",\r\n__func__, vpe->event);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nif (v_opcode != adapter->current_op) {\r\ndev_err(&adapter->pdev->dev, "%s: Pending op is %d, received %d\n",\r\n__func__, adapter->current_op, v_opcode);\r\nadapter->current_op = I40E_VIRTCHNL_OP_UNKNOWN;\r\nreturn;\r\n}\r\nif (v_retval) {\r\ndev_err(&adapter->pdev->dev, "%s: PF returned error %d to our request %d\n",\r\n__func__, v_retval, v_opcode);\r\n}\r\nswitch (v_opcode) {\r\ncase I40E_VIRTCHNL_OP_GET_STATS: {\r\nstruct i40e_eth_stats *stats =\r\n(struct i40e_eth_stats *)msg;\r\nadapter->net_stats.rx_packets = stats->rx_unicast +\r\nstats->rx_multicast +\r\nstats->rx_broadcast;\r\nadapter->net_stats.tx_packets = stats->tx_unicast +\r\nstats->tx_multicast +\r\nstats->tx_broadcast;\r\nadapter->net_stats.rx_bytes = stats->rx_bytes;\r\nadapter->net_stats.tx_bytes = stats->tx_bytes;\r\nadapter->net_stats.tx_errors = stats->tx_errors;\r\nadapter->net_stats.rx_dropped = stats->rx_discards;\r\nadapter->net_stats.tx_dropped = stats->tx_discards;\r\nadapter->current_stats = *stats;\r\n}\r\nbreak;\r\ncase I40E_VIRTCHNL_OP_ADD_ETHER_ADDRESS:\r\nadapter->aq_pending &= ~(I40EVF_FLAG_AQ_ADD_MAC_FILTER);\r\nbreak;\r\ncase I40E_VIRTCHNL_OP_DEL_ETHER_ADDRESS:\r\nadapter->aq_pending &= ~(I40EVF_FLAG_AQ_DEL_MAC_FILTER);\r\nbreak;\r\ncase I40E_VIRTCHNL_OP_ADD_VLAN:\r\nadapter->aq_pending &= ~(I40EVF_FLAG_AQ_ADD_VLAN_FILTER);\r\nbreak;\r\ncase I40E_VIRTCHNL_OP_DEL_VLAN:\r\nadapter->aq_pending &= ~(I40EVF_FLAG_AQ_DEL_VLAN_FILTER);\r\nbreak;\r\ncase I40E_VIRTCHNL_OP_ENABLE_QUEUES:\r\nadapter->aq_pending &= ~(I40EVF_FLAG_AQ_ENABLE_QUEUES);\r\ni40evf_irq_enable(adapter, true);\r\nnetif_tx_start_all_queues(adapter->netdev);\r\nnetif_carrier_on(adapter->netdev);\r\nbreak;\r\ncase I40E_VIRTCHNL_OP_DISABLE_QUEUES:\r\nadapter->aq_pending &= ~(I40EVF_FLAG_AQ_DISABLE_QUEUES);\r\nbreak;\r\ncase I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES:\r\nadapter->aq_pending &= ~(I40EVF_FLAG_AQ_CONFIGURE_QUEUES);\r\nbreak;\r\ncase I40E_VIRTCHNL_OP_CONFIG_IRQ_MAP:\r\nadapter->aq_pending &= ~(I40EVF_FLAG_AQ_MAP_VECTORS);\r\nbreak;\r\ndefault:\r\ndev_warn(&adapter->pdev->dev, "%s: Received unexpected message %d from PF\n",\r\n__func__, v_opcode);\r\nbreak;\r\n}\r\nadapter->current_op = I40E_VIRTCHNL_OP_UNKNOWN;\r\n}
