static int kgdbts_unreg_thread(void *ptr)\r\n{\r\nwhile (!final_ack)\r\nmsleep_interruptible(1500);\r\nmsleep_interruptible(1000);\r\nif (configured)\r\nkgdb_unregister_io_module(&kgdbts_io_ops);\r\nconfigured = 0;\r\nreturn 0;\r\n}\r\nstatic noinline void kgdbts_break_test(void)\r\n{\r\nv2printk("kgdbts: breakpoint complete\n");\r\n}\r\nstatic unsigned long lookup_addr(char *arg)\r\n{\r\nunsigned long addr = 0;\r\nif (!strcmp(arg, "kgdbts_break_test"))\r\naddr = (unsigned long)kgdbts_break_test;\r\nelse if (!strcmp(arg, "sys_open"))\r\naddr = (unsigned long)do_sys_open;\r\nelse if (!strcmp(arg, "do_fork"))\r\naddr = (unsigned long)do_fork;\r\nelse if (!strcmp(arg, "hw_break_val"))\r\naddr = (unsigned long)&hw_break_val;\r\naddr = (unsigned long) dereference_function_descriptor((void *)addr);\r\nreturn addr;\r\n}\r\nstatic void break_helper(char *bp_type, char *arg, unsigned long vaddr)\r\n{\r\nunsigned long addr;\r\nif (arg)\r\naddr = lookup_addr(arg);\r\nelse\r\naddr = vaddr;\r\nsprintf(scratch_buf, "%s,%lx,%i", bp_type, addr,\r\nBREAK_INSTR_SIZE);\r\nfill_get_buf(scratch_buf);\r\n}\r\nstatic void sw_break(char *arg)\r\n{\r\nbreak_helper(force_hwbrks ? "Z1" : "Z0", arg, 0);\r\n}\r\nstatic void sw_rem_break(char *arg)\r\n{\r\nbreak_helper(force_hwbrks ? "z1" : "z0", arg, 0);\r\n}\r\nstatic void hw_break(char *arg)\r\n{\r\nbreak_helper("Z1", arg, 0);\r\n}\r\nstatic void hw_rem_break(char *arg)\r\n{\r\nbreak_helper("z1", arg, 0);\r\n}\r\nstatic void hw_write_break(char *arg)\r\n{\r\nbreak_helper("Z2", arg, 0);\r\n}\r\nstatic void hw_rem_write_break(char *arg)\r\n{\r\nbreak_helper("z2", arg, 0);\r\n}\r\nstatic void hw_access_break(char *arg)\r\n{\r\nbreak_helper("Z4", arg, 0);\r\n}\r\nstatic void hw_rem_access_break(char *arg)\r\n{\r\nbreak_helper("z4", arg, 0);\r\n}\r\nstatic void hw_break_val_access(void)\r\n{\r\nhw_break_val2 = hw_break_val;\r\n}\r\nstatic void hw_break_val_write(void)\r\n{\r\nhw_break_val++;\r\n}\r\nstatic int get_thread_id_continue(char *put_str, char *arg)\r\n{\r\nchar *ptr = &put_str[11];\r\nif (put_str[1] != 'T' || put_str[2] != '0')\r\nreturn 1;\r\nkgdb_hex2long(&ptr, &cont_thread_id);\r\nreturn 0;\r\n}\r\nstatic int check_and_rewind_pc(char *put_str, char *arg)\r\n{\r\nunsigned long addr = lookup_addr(arg);\r\nunsigned long ip;\r\nint offset = 0;\r\nkgdb_hex2mem(&put_str[1], (char *)kgdbts_gdb_regs,\r\nNUMREGBYTES);\r\ngdb_regs_to_pt_regs(kgdbts_gdb_regs, &kgdbts_regs);\r\nip = instruction_pointer(&kgdbts_regs);\r\nv2printk("Stopped at IP: %lx\n", ip);\r\n#ifdef GDB_ADJUSTS_BREAK_OFFSET\r\nif (addr + BREAK_INSTR_SIZE == ip)\r\noffset = -BREAK_INSTR_SIZE;\r\n#endif\r\nif (arch_needs_sstep_emulation && sstep_addr &&\r\nip + offset == sstep_addr &&\r\n((!strcmp(arg, "sys_open") || !strcmp(arg, "do_fork")))) {\r\nv2printk("Emul: rewind hit single step bp\n");\r\nrestart_from_top_after_write = 1;\r\n} else if (strcmp(arg, "silent") && ip + offset != addr) {\r\neprintk("kgdbts: BP mismatch %lx expected %lx\n",\r\nip + offset, addr);\r\nreturn 1;\r\n}\r\nip += offset;\r\ncont_addr = ip;\r\n#ifdef GDB_ADJUSTS_BREAK_OFFSET\r\ninstruction_pointer_set(&kgdbts_regs, ip);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int check_single_step(char *put_str, char *arg)\r\n{\r\nunsigned long addr = lookup_addr(arg);\r\nstatic int matched_id;\r\nkgdb_hex2mem(&put_str[1], (char *)kgdbts_gdb_regs,\r\nNUMREGBYTES);\r\ngdb_regs_to_pt_regs(kgdbts_gdb_regs, &kgdbts_regs);\r\nv2printk("Singlestep stopped at IP: %lx\n",\r\ninstruction_pointer(&kgdbts_regs));\r\nif (sstep_thread_id != cont_thread_id) {\r\nv2printk("ThrID does not match: %lx\n", cont_thread_id);\r\nif (arch_needs_sstep_emulation) {\r\nif (matched_id &&\r\ninstruction_pointer(&kgdbts_regs) != addr)\r\ngoto continue_test;\r\nmatched_id++;\r\nts.idx -= 2;\r\nsstep_state = 0;\r\nreturn 0;\r\n}\r\ncont_instead_of_sstep = 1;\r\nts.idx -= 4;\r\nreturn 0;\r\n}\r\ncontinue_test:\r\nmatched_id = 0;\r\nif (instruction_pointer(&kgdbts_regs) == addr) {\r\neprintk("kgdbts: SingleStep failed at %lx\n",\r\ninstruction_pointer(&kgdbts_regs));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void write_regs(char *arg)\r\n{\r\nmemset(scratch_buf, 0, sizeof(scratch_buf));\r\nscratch_buf[0] = 'G';\r\npt_regs_to_gdb_regs(kgdbts_gdb_regs, &kgdbts_regs);\r\nkgdb_mem2hex((char *)kgdbts_gdb_regs, &scratch_buf[1], NUMREGBYTES);\r\nfill_get_buf(scratch_buf);\r\n}\r\nstatic void skip_back_repeat_test(char *arg)\r\n{\r\nint go_back = simple_strtol(arg, NULL, 10);\r\nrepeat_test--;\r\nif (repeat_test <= 0)\r\nts.idx++;\r\nelse\r\nts.idx -= go_back;\r\nfill_get_buf(ts.tst[ts.idx].get);\r\n}\r\nstatic int got_break(char *put_str, char *arg)\r\n{\r\ntest_complete = 1;\r\nif (!strncmp(put_str+1, arg, 2)) {\r\nif (!strncmp(arg, "T0", 2))\r\ntest_complete = 2;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void get_cont_catch(char *arg)\r\n{\r\nfill_get_buf("D");\r\n}\r\nstatic int put_cont_catch(char *put_str, char *arg)\r\n{\r\nv2printk("kgdbts: cleanup task: %lx\n", sstep_thread_id);\r\nts.idx--;\r\nreturn 0;\r\n}\r\nstatic int emul_reset(char *put_str, char *arg)\r\n{\r\nif (strncmp(put_str, "$OK", 3))\r\nreturn 1;\r\nif (restart_from_top_after_write) {\r\nrestart_from_top_after_write = 0;\r\nts.idx = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void emul_sstep_get(char *arg)\r\n{\r\nif (!arch_needs_sstep_emulation) {\r\nif (cont_instead_of_sstep) {\r\ncont_instead_of_sstep = 0;\r\nfill_get_buf("c");\r\n} else {\r\nfill_get_buf(arg);\r\n}\r\nreturn;\r\n}\r\nswitch (sstep_state) {\r\ncase 0:\r\nv2printk("Emulate single step\n");\r\nfill_get_buf("g");\r\nbreak;\r\ncase 1:\r\nbreak_helper("Z0", NULL, sstep_addr);\r\nbreak;\r\ncase 2:\r\nfill_get_buf("c");\r\nbreak;\r\ncase 3:\r\nbreak_helper("z0", NULL, sstep_addr);\r\nbreak;\r\ndefault:\r\neprintk("kgdbts: ERROR failed sstep get emulation\n");\r\n}\r\nsstep_state++;\r\n}\r\nstatic int emul_sstep_put(char *put_str, char *arg)\r\n{\r\nif (!arch_needs_sstep_emulation) {\r\nchar *ptr = &put_str[11];\r\nif (put_str[1] != 'T' || put_str[2] != '0')\r\nreturn 1;\r\nkgdb_hex2long(&ptr, &sstep_thread_id);\r\nreturn 0;\r\n}\r\nswitch (sstep_state) {\r\ncase 1:\r\nkgdb_hex2mem(&put_str[1], (char *)kgdbts_gdb_regs,\r\nNUMREGBYTES);\r\ngdb_regs_to_pt_regs(kgdbts_gdb_regs, &kgdbts_regs);\r\nv2printk("Stopped at IP: %lx\n",\r\ninstruction_pointer(&kgdbts_regs));\r\nsstep_addr = cont_addr + BREAK_INSTR_SIZE;\r\nbreak;\r\ncase 2:\r\nif (strncmp(put_str, "$OK", 3)) {\r\neprintk("kgdbts: failed sstep break set\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase 3:\r\nif (strncmp(put_str, "$T0", 3)) {\r\neprintk("kgdbts: failed continue sstep\n");\r\nreturn 1;\r\n} else {\r\nchar *ptr = &put_str[11];\r\nkgdb_hex2long(&ptr, &sstep_thread_id);\r\n}\r\nbreak;\r\ncase 4:\r\nif (strncmp(put_str, "$OK", 3)) {\r\neprintk("kgdbts: failed sstep break unset\n");\r\nreturn 1;\r\n}\r\nsstep_state = 0;\r\nreturn 0;\r\ndefault:\r\neprintk("kgdbts: ERROR failed sstep put emulation\n");\r\n}\r\nts.idx--;\r\nreturn 0;\r\n}\r\nstatic int final_ack_set(char *put_str, char *arg)\r\n{\r\nif (strncmp(put_str+1, arg, 2))\r\nreturn 1;\r\nfinal_ack = 1;\r\nreturn 0;\r\n}\r\nstatic void fill_get_buf(char *buf)\r\n{\r\nunsigned char checksum = 0;\r\nint count = 0;\r\nchar ch;\r\nstrcpy(get_buf, "$");\r\nstrcat(get_buf, buf);\r\nwhile ((ch = buf[count])) {\r\nchecksum += ch;\r\ncount++;\r\n}\r\nstrcat(get_buf, "#");\r\nget_buf[count + 2] = hex_asc_hi(checksum);\r\nget_buf[count + 3] = hex_asc_lo(checksum);\r\nget_buf[count + 4] = '\0';\r\nv2printk("get%i: %s\n", ts.idx, get_buf);\r\n}\r\nstatic int validate_simple_test(char *put_str)\r\n{\r\nchar *chk_str;\r\nif (ts.tst[ts.idx].put_handler)\r\nreturn ts.tst[ts.idx].put_handler(put_str,\r\nts.tst[ts.idx].put);\r\nchk_str = ts.tst[ts.idx].put;\r\nif (*put_str == '$')\r\nput_str++;\r\nwhile (*chk_str != '\0' && *put_str != '\0') {\r\nif (*put_str == '#' || *chk_str == '*')\r\nreturn 0;\r\nif (*put_str != *chk_str)\r\nreturn 1;\r\nchk_str++;\r\nput_str++;\r\n}\r\nif (*chk_str == '\0' && (*put_str == '\0' || *put_str == '#'))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int run_simple_test(int is_get_char, int chr)\r\n{\r\nint ret = 0;\r\nif (is_get_char) {\r\nif (send_ack) {\r\nsend_ack = 0;\r\nreturn '+';\r\n}\r\nif (get_buf_cnt == 0) {\r\nif (ts.tst[ts.idx].get_handler)\r\nts.tst[ts.idx].get_handler(ts.tst[ts.idx].get);\r\nelse\r\nfill_get_buf(ts.tst[ts.idx].get);\r\n}\r\nif (get_buf[get_buf_cnt] == '\0') {\r\neprintk("kgdbts: ERROR GET: EOB on '%s' at %i\n",\r\nts.name, ts.idx);\r\nget_buf_cnt = 0;\r\nfill_get_buf("D");\r\n}\r\nret = get_buf[get_buf_cnt];\r\nget_buf_cnt++;\r\nreturn ret;\r\n}\r\nif (ts.tst[ts.idx].get[0] == '\0' && ts.tst[ts.idx].put[0] == '\0' &&\r\n!ts.tst[ts.idx].get_handler) {\r\neprintk("kgdbts: ERROR: beyond end of test on"\r\n" '%s' line %i\n", ts.name, ts.idx);\r\nreturn 0;\r\n}\r\nif (put_buf_cnt >= BUFMAX) {\r\neprintk("kgdbts: ERROR: put buffer overflow on"\r\n" '%s' line %i\n", ts.name, ts.idx);\r\nput_buf_cnt = 0;\r\nreturn 0;\r\n}\r\nif (put_buf_cnt == 0 && chr != '$')\r\nreturn 0;\r\nput_buf[put_buf_cnt] = chr;\r\nput_buf_cnt++;\r\nif (put_buf_cnt > 3 && put_buf[put_buf_cnt - 3] == '#') {\r\nif (put_buf_cnt >= BUFMAX) {\r\neprintk("kgdbts: ERROR: put buffer overflow on"\r\n" '%s' line %i\n", ts.name, ts.idx);\r\nput_buf_cnt = 0;\r\nreturn 0;\r\n}\r\nput_buf[put_buf_cnt] = '\0';\r\nv2printk("put%i: %s\n", ts.idx, put_buf);\r\nif (ts.validate_put && ts.validate_put(put_buf)) {\r\neprintk("kgdbts: ERROR PUT: end of test "\r\n"buffer on '%s' line %i expected %s got %s\n",\r\nts.name, ts.idx, ts.tst[ts.idx].put, put_buf);\r\n}\r\nts.idx++;\r\nput_buf_cnt = 0;\r\nget_buf_cnt = 0;\r\nsend_ack = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void init_simple_test(void)\r\n{\r\nmemset(&ts, 0, sizeof(ts));\r\nts.run_test = run_simple_test;\r\nts.validate_put = validate_simple_test;\r\n}\r\nstatic void run_plant_and_detach_test(int is_early)\r\n{\r\nchar before[BREAK_INSTR_SIZE];\r\nchar after[BREAK_INSTR_SIZE];\r\nprobe_kernel_read(before, (char *)kgdbts_break_test,\r\nBREAK_INSTR_SIZE);\r\ninit_simple_test();\r\nts.tst = plant_and_detach_test;\r\nts.name = "plant_and_detach_test";\r\nif (!is_early)\r\nkgdb_breakpoint();\r\nprobe_kernel_read(after, (char *)kgdbts_break_test,\r\nBREAK_INSTR_SIZE);\r\nif (memcmp(before, after, BREAK_INSTR_SIZE)) {\r\nprintk(KERN_CRIT "kgdbts: ERROR kgdb corrupted memory\n");\r\npanic("kgdb memory corruption");\r\n}\r\nif (!is_early)\r\nkgdbts_break_test();\r\n}\r\nstatic void run_breakpoint_test(int is_hw_breakpoint)\r\n{\r\ntest_complete = 0;\r\ninit_simple_test();\r\nif (is_hw_breakpoint) {\r\nts.tst = hw_breakpoint_test;\r\nts.name = "hw_breakpoint_test";\r\n} else {\r\nts.tst = sw_breakpoint_test;\r\nts.name = "sw_breakpoint_test";\r\n}\r\nkgdb_breakpoint();\r\nkgdbts_break_test();\r\nkgdb_breakpoint();\r\nif (test_complete)\r\nreturn;\r\neprintk("kgdbts: ERROR %s test failed\n", ts.name);\r\nif (is_hw_breakpoint)\r\nhwbreaks_ok = 0;\r\n}\r\nstatic void run_hw_break_test(int is_write_test)\r\n{\r\ntest_complete = 0;\r\ninit_simple_test();\r\nif (is_write_test) {\r\nts.tst = hw_write_break_test;\r\nts.name = "hw_write_break_test";\r\n} else {\r\nts.tst = hw_access_break_test;\r\nts.name = "hw_access_break_test";\r\n}\r\nkgdb_breakpoint();\r\nhw_break_val_access();\r\nif (is_write_test) {\r\nif (test_complete == 2) {\r\neprintk("kgdbts: ERROR %s broke on access\n",\r\nts.name);\r\nhwbreaks_ok = 0;\r\n}\r\nhw_break_val_write();\r\n}\r\nkgdb_breakpoint();\r\nif (test_complete == 1)\r\nreturn;\r\neprintk("kgdbts: ERROR %s test failed\n", ts.name);\r\nhwbreaks_ok = 0;\r\n}\r\nstatic void run_nmi_sleep_test(int nmi_sleep)\r\n{\r\nunsigned long flags;\r\ninit_simple_test();\r\nts.tst = nmi_sleep_test;\r\nts.name = "nmi_sleep_test";\r\nkgdb_breakpoint();\r\nlocal_irq_save(flags);\r\nmdelay(nmi_sleep*1000);\r\ntouch_nmi_watchdog();\r\nlocal_irq_restore(flags);\r\nif (test_complete != 2)\r\neprintk("kgdbts: ERROR nmi_test did not hit nmi\n");\r\nkgdb_breakpoint();\r\nif (test_complete == 1)\r\nreturn;\r\neprintk("kgdbts: ERROR %s test failed\n", ts.name);\r\n}\r\nstatic void run_bad_read_test(void)\r\n{\r\ninit_simple_test();\r\nts.tst = bad_read_test;\r\nts.name = "bad_read_test";\r\nkgdb_breakpoint();\r\n}\r\nstatic void run_do_fork_test(void)\r\n{\r\ninit_simple_test();\r\nts.tst = do_fork_test;\r\nts.name = "do_fork_test";\r\nkgdb_breakpoint();\r\n}\r\nstatic void run_sys_open_test(void)\r\n{\r\ninit_simple_test();\r\nts.tst = sys_open_test;\r\nts.name = "sys_open_test";\r\nkgdb_breakpoint();\r\n}\r\nstatic void run_singlestep_break_test(void)\r\n{\r\ninit_simple_test();\r\nts.tst = singlestep_break_test;\r\nts.name = "singlestep_breakpoint_test";\r\nkgdb_breakpoint();\r\nkgdbts_break_test();\r\nkgdbts_break_test();\r\n}\r\nstatic void kgdbts_run_tests(void)\r\n{\r\nchar *ptr;\r\nint fork_test = 0;\r\nint do_sys_open_test = 0;\r\nint sstep_test = 1000;\r\nint nmi_sleep = 0;\r\nint i;\r\nptr = strchr(config, 'F');\r\nif (ptr)\r\nfork_test = simple_strtol(ptr + 1, NULL, 10);\r\nptr = strchr(config, 'S');\r\nif (ptr)\r\ndo_sys_open_test = simple_strtol(ptr + 1, NULL, 10);\r\nptr = strchr(config, 'N');\r\nif (ptr)\r\nnmi_sleep = simple_strtol(ptr+1, NULL, 10);\r\nptr = strchr(config, 'I');\r\nif (ptr)\r\nsstep_test = simple_strtol(ptr+1, NULL, 10);\r\nif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT) {\r\nhwbreaks_ok = 1;\r\nv1printk("kgdbts:RUN hw breakpoint test\n");\r\nrun_breakpoint_test(1);\r\nv1printk("kgdbts:RUN hw write breakpoint test\n");\r\nrun_hw_break_test(1);\r\nv1printk("kgdbts:RUN access write breakpoint test\n");\r\nrun_hw_break_test(0);\r\n}\r\nv1printk("kgdbts:RUN plant and detach test\n");\r\nrun_plant_and_detach_test(0);\r\nv1printk("kgdbts:RUN sw breakpoint test\n");\r\nrun_breakpoint_test(0);\r\nv1printk("kgdbts:RUN bad memory access test\n");\r\nrun_bad_read_test();\r\nv1printk("kgdbts:RUN singlestep test %i iterations\n", sstep_test);\r\nfor (i = 0; i < sstep_test; i++) {\r\nrun_singlestep_break_test();\r\nif (i % 100 == 0)\r\nv1printk("kgdbts:RUN singlestep [%i/%i]\n",\r\ni, sstep_test);\r\n}\r\nif (nmi_sleep) {\r\nv1printk("kgdbts:RUN NMI sleep %i seconds test\n", nmi_sleep);\r\nrun_nmi_sleep_test(nmi_sleep);\r\n}\r\nif (fork_test) {\r\nrepeat_test = fork_test;\r\nprintk(KERN_INFO "kgdbts:RUN do_fork for %i breakpoints\n",\r\nrepeat_test);\r\nkthread_run(kgdbts_unreg_thread, NULL, "kgdbts_unreg");\r\nrun_do_fork_test();\r\nreturn;\r\n}\r\nif (do_sys_open_test) {\r\nrepeat_test = do_sys_open_test;\r\nprintk(KERN_INFO "kgdbts:RUN sys_open for %i breakpoints\n",\r\nrepeat_test);\r\nkthread_run(kgdbts_unreg_thread, NULL, "kgdbts_unreg");\r\nrun_sys_open_test();\r\nreturn;\r\n}\r\nkgdb_unregister_io_module(&kgdbts_io_ops);\r\nconfigured = 0;\r\n}\r\nstatic int kgdbts_option_setup(char *opt)\r\n{\r\nif (strlen(opt) >= MAX_CONFIG_LEN) {\r\nprintk(KERN_ERR "kgdbts: config string too long\n");\r\nreturn -ENOSPC;\r\n}\r\nstrcpy(config, opt);\r\nverbose = 0;\r\nif (strstr(config, "V1"))\r\nverbose = 1;\r\nif (strstr(config, "V2"))\r\nverbose = 2;\r\nreturn 0;\r\n}\r\nstatic int configure_kgdbts(void)\r\n{\r\nint err = 0;\r\nif (!strlen(config) || isspace(config[0]))\r\ngoto noconfig;\r\nerr = kgdbts_option_setup(config);\r\nif (err)\r\ngoto noconfig;\r\nfinal_ack = 0;\r\nrun_plant_and_detach_test(1);\r\nerr = kgdb_register_io_module(&kgdbts_io_ops);\r\nif (err) {\r\nconfigured = 0;\r\nreturn err;\r\n}\r\nconfigured = 1;\r\nkgdbts_run_tests();\r\nreturn err;\r\nnoconfig:\r\nconfig[0] = 0;\r\nconfigured = 0;\r\nreturn err;\r\n}\r\nstatic int __init init_kgdbts(void)\r\n{\r\nif (configured == 1)\r\nreturn 0;\r\nreturn configure_kgdbts();\r\n}\r\nstatic int kgdbts_get_char(void)\r\n{\r\nint val = 0;\r\nif (ts.run_test)\r\nval = ts.run_test(1, 0);\r\nreturn val;\r\n}\r\nstatic void kgdbts_put_char(u8 chr)\r\n{\r\nif (ts.run_test)\r\nts.run_test(0, chr);\r\n}\r\nstatic int param_set_kgdbts_var(const char *kmessage, struct kernel_param *kp)\r\n{\r\nint len = strlen(kmessage);\r\nif (len >= MAX_CONFIG_LEN) {\r\nprintk(KERN_ERR "kgdbts: config string too long\n");\r\nreturn -ENOSPC;\r\n}\r\nif (configured < 0) {\r\nstrcpy(config, kmessage);\r\nreturn 0;\r\n}\r\nif (configured == 1) {\r\nprintk(KERN_ERR "kgdbts: ERROR: Already configured and running.\n");\r\nreturn -EBUSY;\r\n}\r\nstrcpy(config, kmessage);\r\nif (config[len - 1] == '\n')\r\nconfig[len - 1] = '\0';\r\nreturn configure_kgdbts();\r\n}\r\nstatic void kgdbts_pre_exp_handler(void)\r\n{\r\nif (!kgdb_connected)\r\ntry_module_get(THIS_MODULE);\r\n}\r\nstatic void kgdbts_post_exp_handler(void)\r\n{\r\nif (!kgdb_connected)\r\nmodule_put(THIS_MODULE);\r\n}
