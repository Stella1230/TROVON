static inline struct crypto_ccm_req_priv_ctx *crypto_ccm_reqctx(\r\nstruct aead_request *req)\r\n{\r\nunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\r\nreturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\r\n}\r\nstatic int set_msg_len(u8 *block, unsigned int msglen, int csize)\r\n{\r\n__be32 data;\r\nmemset(block, 0, csize);\r\nblock += csize;\r\nif (csize >= 4)\r\ncsize = 4;\r\nelse if (msglen > (1 << (8 * csize)))\r\nreturn -EOVERFLOW;\r\ndata = cpu_to_be32(msglen);\r\nmemcpy(block - csize, (u8 *)&data + 4 - csize, csize);\r\nreturn 0;\r\n}\r\nstatic int crypto_ccm_setkey(struct crypto_aead *aead, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ablkcipher *ctr = ctx->ctr;\r\nstruct crypto_cipher *tfm = ctx->cipher;\r\nint err = 0;\r\ncrypto_ablkcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ablkcipher_set_flags(ctr, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(ctr, key, keylen);\r\ncrypto_aead_set_flags(aead, crypto_ablkcipher_get_flags(ctr) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (err)\r\ngoto out;\r\ncrypto_cipher_clear_flags(tfm, CRYPTO_TFM_REQ_MASK);\r\ncrypto_cipher_set_flags(tfm, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_cipher_setkey(tfm, key, keylen);\r\ncrypto_aead_set_flags(aead, crypto_cipher_get_flags(tfm) &\r\nCRYPTO_TFM_RES_MASK);\r\nout:\r\nreturn err;\r\n}\r\nstatic int crypto_ccm_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nswitch (authsize) {\r\ncase 4:\r\ncase 6:\r\ncase 8:\r\ncase 10:\r\ncase 12:\r\ncase 14:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int format_input(u8 *info, struct aead_request *req,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nunsigned int lp = req->iv[0];\r\nunsigned int l = lp + 1;\r\nunsigned int m;\r\nm = crypto_aead_authsize(aead);\r\nmemcpy(info, req->iv, 16);\r\n*info |= (8 * ((m - 2) / 2));\r\nif (req->assoclen)\r\n*info |= 64;\r\nreturn set_msg_len(info + 16 - l, cryptlen, l);\r\n}\r\nstatic int format_adata(u8 *adata, unsigned int a)\r\n{\r\nint len = 0;\r\nif (a < 65280) {\r\n*(__be16 *)adata = cpu_to_be16(a);\r\nlen = 2;\r\n} else {\r\n*(__be16 *)adata = cpu_to_be16(0xfffe);\r\n*(__be32 *)&adata[2] = cpu_to_be32(a);\r\nlen = 6;\r\n}\r\nreturn len;\r\n}\r\nstatic void compute_mac(struct crypto_cipher *tfm, u8 *data, int n,\r\nstruct crypto_ccm_req_priv_ctx *pctx)\r\n{\r\nunsigned int bs = 16;\r\nu8 *odata = pctx->odata;\r\nu8 *idata = pctx->idata;\r\nint datalen, getlen;\r\ndatalen = n;\r\ngetlen = bs - pctx->ilen;\r\nif (datalen >= getlen) {\r\nmemcpy(idata + pctx->ilen, data, getlen);\r\ncrypto_xor(odata, idata, bs);\r\ncrypto_cipher_encrypt_one(tfm, odata, odata);\r\ndatalen -= getlen;\r\ndata += getlen;\r\npctx->ilen = 0;\r\n}\r\nwhile (datalen >= bs) {\r\ncrypto_xor(odata, data, bs);\r\ncrypto_cipher_encrypt_one(tfm, odata, odata);\r\ndatalen -= bs;\r\ndata += bs;\r\n}\r\nif (datalen) {\r\nmemcpy(idata + pctx->ilen, data, datalen);\r\npctx->ilen += datalen;\r\n}\r\n}\r\nstatic void get_data_to_compute(struct crypto_cipher *tfm,\r\nstruct crypto_ccm_req_priv_ctx *pctx,\r\nstruct scatterlist *sg, unsigned int len)\r\n{\r\nstruct scatter_walk walk;\r\nu8 *data_src;\r\nint n;\r\nscatterwalk_start(&walk, sg);\r\nwhile (len) {\r\nn = scatterwalk_clamp(&walk, len);\r\nif (!n) {\r\nscatterwalk_start(&walk, sg_next(walk.sg));\r\nn = scatterwalk_clamp(&walk, len);\r\n}\r\ndata_src = scatterwalk_map(&walk);\r\ncompute_mac(tfm, data_src, n, pctx);\r\nlen -= n;\r\nscatterwalk_unmap(data_src);\r\nscatterwalk_advance(&walk, n);\r\nscatterwalk_done(&walk, 0, len);\r\nif (len)\r\ncrypto_yield(pctx->flags);\r\n}\r\nif (pctx->ilen) {\r\nint padlen;\r\nu8 *odata = pctx->odata;\r\nu8 *idata = pctx->idata;\r\npadlen = 16 - pctx->ilen;\r\nmemset(idata + pctx->ilen, 0, padlen);\r\ncrypto_xor(odata, idata, 16);\r\ncrypto_cipher_encrypt_one(tfm, odata, odata);\r\npctx->ilen = 0;\r\n}\r\n}\r\nstatic int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct crypto_cipher *cipher = ctx->cipher;\r\nunsigned int assoclen = req->assoclen;\r\nu8 *odata = pctx->odata;\r\nu8 *idata = pctx->idata;\r\nint err;\r\nerr = format_input(odata, req, cryptlen);\r\nif (err)\r\ngoto out;\r\ncrypto_cipher_encrypt_one(cipher, odata, odata);\r\nif (assoclen) {\r\npctx->ilen = format_adata(idata, assoclen);\r\nget_data_to_compute(cipher, pctx, req->assoc, req->assoclen);\r\n} else {\r\npctx->ilen = 0;\r\n}\r\nif (cryptlen)\r\nget_data_to_compute(cipher, pctx, plain, cryptlen);\r\nout:\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_encrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nu8 *odata = pctx->odata;\r\nif (!err)\r\nscatterwalk_map_and_copy(odata, req->dst, req->cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\naead_request_complete(req, err);\r\n}\r\nstatic inline int crypto_ccm_check_iv(const u8 *iv)\r\n{\r\nif (1 > iv[0] || iv[0] > 7)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int crypto_ccm_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->abreq;\r\nstruct scatterlist *dst;\r\nunsigned int cryptlen = req->cryptlen;\r\nu8 *odata = pctx->odata;\r\nu8 *iv = req->iv;\r\nint err;\r\nerr = crypto_ccm_check_iv(iv);\r\nif (err)\r\nreturn err;\r\npctx->flags = aead_request_flags(req);\r\nerr = crypto_ccm_auth(req, req->src, cryptlen);\r\nif (err)\r\nreturn err;\r\nmemset(iv + 15 - iv[0], 0, iv[0] + 1);\r\nsg_init_table(pctx->src, 2);\r\nsg_set_buf(pctx->src, odata, 16);\r\nscatterwalk_sg_chain(pctx->src, 2, req->src);\r\ndst = pctx->src;\r\nif (req->src != req->dst) {\r\nsg_init_table(pctx->dst, 2);\r\nsg_set_buf(pctx->dst, odata, 16);\r\nscatterwalk_sg_chain(pctx->dst, 2, req->dst);\r\ndst = pctx->dst;\r\n}\r\nablkcipher_request_set_tfm(abreq, ctx->ctr);\r\nablkcipher_request_set_callback(abreq, pctx->flags,\r\ncrypto_ccm_encrypt_done, req);\r\nablkcipher_request_set_crypt(abreq, pctx->src, dst, cryptlen + 16, iv);\r\nerr = crypto_ablkcipher_encrypt(abreq);\r\nif (err)\r\nreturn err;\r\nscatterwalk_map_and_copy(odata, req->dst, cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_decrypt_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen - authsize;\r\nif (!err) {\r\nerr = crypto_ccm_auth(req, req->dst, cryptlen);\r\nif (!err && crypto_memneq(pctx->auth_tag, pctx->odata, authsize))\r\nerr = -EBADMSG;\r\n}\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_ccm_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct ablkcipher_request *abreq = &pctx->abreq;\r\nstruct scatterlist *dst;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen;\r\nu8 *authtag = pctx->auth_tag;\r\nu8 *odata = pctx->odata;\r\nu8 *iv = req->iv;\r\nint err;\r\nif (cryptlen < authsize)\r\nreturn -EINVAL;\r\ncryptlen -= authsize;\r\nerr = crypto_ccm_check_iv(iv);\r\nif (err)\r\nreturn err;\r\npctx->flags = aead_request_flags(req);\r\nscatterwalk_map_and_copy(authtag, req->src, cryptlen, authsize, 0);\r\nmemset(iv + 15 - iv[0], 0, iv[0] + 1);\r\nsg_init_table(pctx->src, 2);\r\nsg_set_buf(pctx->src, authtag, 16);\r\nscatterwalk_sg_chain(pctx->src, 2, req->src);\r\ndst = pctx->src;\r\nif (req->src != req->dst) {\r\nsg_init_table(pctx->dst, 2);\r\nsg_set_buf(pctx->dst, authtag, 16);\r\nscatterwalk_sg_chain(pctx->dst, 2, req->dst);\r\ndst = pctx->dst;\r\n}\r\nablkcipher_request_set_tfm(abreq, ctx->ctr);\r\nablkcipher_request_set_callback(abreq, pctx->flags,\r\ncrypto_ccm_decrypt_done, req);\r\nablkcipher_request_set_crypt(abreq, pctx->src, dst, cryptlen + 16, iv);\r\nerr = crypto_ablkcipher_decrypt(abreq);\r\nif (err)\r\nreturn err;\r\nerr = crypto_ccm_auth(req, req->dst, cryptlen);\r\nif (err)\r\nreturn err;\r\nif (crypto_memneq(authtag, odata, authsize))\r\nreturn -EBADMSG;\r\nreturn err;\r\n}\r\nstatic int crypto_ccm_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct ccm_instance_ctx *ictx = crypto_instance_ctx(inst);\r\nstruct crypto_ccm_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_cipher *cipher;\r\nstruct crypto_ablkcipher *ctr;\r\nunsigned long align;\r\nint err;\r\ncipher = crypto_spawn_cipher(&ictx->cipher);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctr = crypto_spawn_skcipher(&ictx->ctr);\r\nerr = PTR_ERR(ctr);\r\nif (IS_ERR(ctr))\r\ngoto err_free_cipher;\r\nctx->cipher = cipher;\r\nctx->ctr = ctr;\r\nalign = crypto_tfm_alg_alignmask(tfm);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ntfm->crt_aead.reqsize = align +\r\nsizeof(struct crypto_ccm_req_priv_ctx) +\r\ncrypto_ablkcipher_reqsize(ctr);\r\nreturn 0;\r\nerr_free_cipher:\r\ncrypto_free_cipher(cipher);\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_ccm_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->cipher);\r\ncrypto_free_ablkcipher(ctx->ctr);\r\n}\r\nstatic struct crypto_instance *crypto_ccm_alloc_common(struct rtattr **tb,\r\nconst char *full_name,\r\nconst char *ctr_name,\r\nconst char *cipher_name)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *ctr;\r\nstruct crypto_alg *cipher;\r\nstruct ccm_instance_ctx *ictx;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn ERR_CAST(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\ncipher = crypto_alg_mod_lookup(cipher_name, CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(cipher))\r\nreturn ERR_CAST(cipher);\r\nerr = -EINVAL;\r\nif (cipher->cra_blocksize != 16)\r\ngoto out_put_cipher;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ictx), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!inst)\r\ngoto out_put_cipher;\r\nictx = crypto_instance_ctx(inst);\r\nerr = crypto_init_spawn(&ictx->cipher, cipher, inst,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (err)\r\ngoto err_free_inst;\r\ncrypto_set_skcipher_spawn(&ictx->ctr, inst);\r\nerr = crypto_grab_skcipher(&ictx->ctr, ctr_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_cipher;\r\nctr = crypto_skcipher_spawn_alg(&ictx->ctr);\r\nerr = -EINVAL;\r\nif (ctr->cra_blocksize != 1)\r\ngoto err_drop_ctr;\r\nif (ctr->cra_ablkcipher.ivsize != 16)\r\ngoto err_drop_ctr;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"ccm_base(%s,%s)", ctr->cra_driver_name,\r\ncipher->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_ctr;\r\nmemcpy(inst->alg.cra_name, full_name, CRYPTO_MAX_ALG_NAME);\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\r\ninst->alg.cra_flags |= ctr->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_priority = cipher->cra_priority + ctr->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = cipher->cra_alignmask | ctr->cra_alignmask |\r\n(__alignof__(u32) - 1);\r\ninst->alg.cra_type = &crypto_aead_type;\r\ninst->alg.cra_aead.ivsize = 16;\r\ninst->alg.cra_aead.maxauthsize = 16;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_ccm_ctx);\r\ninst->alg.cra_init = crypto_ccm_init_tfm;\r\ninst->alg.cra_exit = crypto_ccm_exit_tfm;\r\ninst->alg.cra_aead.setkey = crypto_ccm_setkey;\r\ninst->alg.cra_aead.setauthsize = crypto_ccm_setauthsize;\r\ninst->alg.cra_aead.encrypt = crypto_ccm_encrypt;\r\ninst->alg.cra_aead.decrypt = crypto_ccm_decrypt;\r\nout:\r\ncrypto_mod_put(cipher);\r\nreturn inst;\r\nerr_drop_ctr:\r\ncrypto_drop_skcipher(&ictx->ctr);\r\nerr_drop_cipher:\r\ncrypto_drop_spawn(&ictx->cipher);\r\nerr_free_inst:\r\nkfree(inst);\r\nout_put_cipher:\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic struct crypto_instance *crypto_ccm_alloc(struct rtattr **tb)\r\n{\r\nconst char *cipher_name;\r\nchar ctr_name[CRYPTO_MAX_ALG_NAME];\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\ncipher_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(cipher_name))\r\nreturn ERR_CAST(cipher_name);\r\nif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, "ctr(%s)",\r\ncipher_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "ccm(%s)", cipher_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nreturn crypto_ccm_alloc_common(tb, full_name, ctr_name, cipher_name);\r\n}\r\nstatic void crypto_ccm_free(struct crypto_instance *inst)\r\n{\r\nstruct ccm_instance_ctx *ctx = crypto_instance_ctx(inst);\r\ncrypto_drop_spawn(&ctx->cipher);\r\ncrypto_drop_skcipher(&ctx->ctr);\r\nkfree(inst);\r\n}\r\nstatic struct crypto_instance *crypto_ccm_base_alloc(struct rtattr **tb)\r\n{\r\nconst char *ctr_name;\r\nconst char *cipher_name;\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\nctr_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ctr_name))\r\nreturn ERR_CAST(ctr_name);\r\ncipher_name = crypto_attr_alg_name(tb[2]);\r\nif (IS_ERR(cipher_name))\r\nreturn ERR_CAST(cipher_name);\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "ccm_base(%s,%s)",\r\nctr_name, cipher_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nreturn crypto_ccm_alloc_common(tb, full_name, ctr_name, cipher_name);\r\n}\r\nstatic int crypto_rfc4309_setkey(struct crypto_aead *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nint err;\r\nif (keylen < 3)\r\nreturn -EINVAL;\r\nkeylen -= 3;\r\nmemcpy(ctx->nonce, key + keylen, 3);\r\ncrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_aead_setkey(child, key, keylen);\r\ncrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc4309_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\r\nswitch (authsize) {\r\ncase 8:\r\ncase 12:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstatic struct aead_request *crypto_rfc4309_crypt(struct aead_request *req)\r\n{\r\nstruct aead_request *subreq = aead_request_ctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_aead *child = ctx->child;\r\nu8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),\r\ncrypto_aead_alignmask(child) + 1);\r\niv[0] = 3;\r\nmemcpy(iv + 1, ctx->nonce, 3);\r\nmemcpy(iv + 4, req->iv, 8);\r\naead_request_set_tfm(subreq, child);\r\naead_request_set_callback(subreq, req->base.flags, req->base.complete,\r\nreq->base.data);\r\naead_request_set_crypt(subreq, req->src, req->dst, req->cryptlen, iv);\r\naead_request_set_assoc(subreq, req->assoc, req->assoclen);\r\nreturn subreq;\r\n}\r\nstatic int crypto_rfc4309_encrypt(struct aead_request *req)\r\n{\r\nreq = crypto_rfc4309_crypt(req);\r\nreturn crypto_aead_encrypt(req);\r\n}\r\nstatic int crypto_rfc4309_decrypt(struct aead_request *req)\r\n{\r\nreq = crypto_rfc4309_crypt(req);\r\nreturn crypto_aead_decrypt(req);\r\n}\r\nstatic int crypto_rfc4309_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_aead_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_rfc4309_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_aead *aead;\r\nunsigned long align;\r\naead = crypto_spawn_aead(spawn);\r\nif (IS_ERR(aead))\r\nreturn PTR_ERR(aead);\r\nctx->child = aead;\r\nalign = crypto_aead_alignmask(aead);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ntfm->crt_aead.reqsize = sizeof(struct aead_request) +\r\nALIGN(crypto_aead_reqsize(aead),\r\ncrypto_tfm_ctx_alignment()) +\r\nalign + 16;\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc4309_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_rfc4309_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct crypto_alg *alg;\r\nconst char *ccm_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn ERR_CAST(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\nccm_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ccm_name))\r\nreturn ERR_CAST(ccm_name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn ERR_PTR(-ENOMEM);\r\nspawn = crypto_instance_ctx(inst);\r\ncrypto_set_aead_spawn(spawn, inst);\r\nerr = crypto_grab_aead(spawn, ccm_name, 0,\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (err)\r\ngoto out_free_inst;\r\nalg = crypto_aead_spawn_alg(spawn);\r\nerr = -EINVAL;\r\nif (alg->cra_aead.ivsize != 16)\r\ngoto out_drop_alg;\r\nif (alg->cra_blocksize != 1)\r\ngoto out_drop_alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4309(%s)", alg->cra_name) >= CRYPTO_MAX_ALG_NAME ||\r\nsnprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4309(%s)", alg->cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_alg;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\r\ninst->alg.cra_flags |= alg->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = 1;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.cra_type = &crypto_nivaead_type;\r\ninst->alg.cra_aead.ivsize = 8;\r\ninst->alg.cra_aead.maxauthsize = 16;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_rfc4309_ctx);\r\ninst->alg.cra_init = crypto_rfc4309_init_tfm;\r\ninst->alg.cra_exit = crypto_rfc4309_exit_tfm;\r\ninst->alg.cra_aead.setkey = crypto_rfc4309_setkey;\r\ninst->alg.cra_aead.setauthsize = crypto_rfc4309_setauthsize;\r\ninst->alg.cra_aead.encrypt = crypto_rfc4309_encrypt;\r\ninst->alg.cra_aead.decrypt = crypto_rfc4309_decrypt;\r\ninst->alg.cra_aead.geniv = "seqiv";\r\nout:\r\nreturn inst;\r\nout_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nout_free_inst:\r\nkfree(inst);\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic void crypto_rfc4309_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int __init crypto_ccm_module_init(void)\r\n{\r\nint err;\r\nerr = crypto_register_template(&crypto_ccm_base_tmpl);\r\nif (err)\r\ngoto out;\r\nerr = crypto_register_template(&crypto_ccm_tmpl);\r\nif (err)\r\ngoto out_undo_base;\r\nerr = crypto_register_template(&crypto_rfc4309_tmpl);\r\nif (err)\r\ngoto out_undo_ccm;\r\nout:\r\nreturn err;\r\nout_undo_ccm:\r\ncrypto_unregister_template(&crypto_ccm_tmpl);\r\nout_undo_base:\r\ncrypto_unregister_template(&crypto_ccm_base_tmpl);\r\ngoto out;\r\n}\r\nstatic void __exit crypto_ccm_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_rfc4309_tmpl);\r\ncrypto_unregister_template(&crypto_ccm_tmpl);\r\ncrypto_unregister_template(&crypto_ccm_base_tmpl);\r\n}
