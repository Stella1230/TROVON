static int ptn3460_read_bytes(struct ptn3460_bridge *ptn_bridge, char addr,\r\nu8 *buf, int len)\r\n{\r\nint ret;\r\nret = i2c_master_send(ptn_bridge->client, &addr, 1);\r\nif (ret <= 0) {\r\nDRM_ERROR("Failed to send i2c command, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nret = i2c_master_recv(ptn_bridge->client, buf, len);\r\nif (ret <= 0) {\r\nDRM_ERROR("Failed to recv i2c data, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ptn3460_write_byte(struct ptn3460_bridge *ptn_bridge, char addr,\r\nchar val)\r\n{\r\nint ret;\r\nchar buf[2];\r\nbuf[0] = addr;\r\nbuf[1] = val;\r\nret = i2c_master_send(ptn_bridge->client, buf, ARRAY_SIZE(buf));\r\nif (ret <= 0) {\r\nDRM_ERROR("Failed to send i2c command, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ptn3460_select_edid(struct ptn3460_bridge *ptn_bridge)\r\n{\r\nint ret;\r\nchar val;\r\nret = ptn3460_write_byte(ptn_bridge, PTN3460_EDID_SRAM_LOAD_ADDR,\r\nptn_bridge->edid_emulation);\r\nif (ret) {\r\nDRM_ERROR("Failed to transfer edid to sram, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nval = 1 << PTN3460_EDID_ENABLE_EMULATION |\r\nptn_bridge->edid_emulation << PTN3460_EDID_EMULATION_SELECTION;\r\nret = ptn3460_write_byte(ptn_bridge, PTN3460_EDID_EMULATION_ADDR, val);\r\nif (ret) {\r\nDRM_ERROR("Failed to write edid value, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ptn3460_pre_enable(struct drm_bridge *bridge)\r\n{\r\nstruct ptn3460_bridge *ptn_bridge = bridge->driver_private;\r\nint ret;\r\nif (ptn_bridge->enabled)\r\nreturn;\r\nif (gpio_is_valid(ptn_bridge->gpio_pd_n))\r\ngpio_set_value(ptn_bridge->gpio_pd_n, 1);\r\nif (gpio_is_valid(ptn_bridge->gpio_rst_n)) {\r\ngpio_set_value(ptn_bridge->gpio_rst_n, 0);\r\nudelay(10);\r\ngpio_set_value(ptn_bridge->gpio_rst_n, 1);\r\n}\r\nmsleep(90);\r\nret = ptn3460_select_edid(ptn_bridge);\r\nif (ret)\r\nDRM_ERROR("Select edid failed ret=%d\n", ret);\r\nptn_bridge->enabled = true;\r\n}\r\nstatic void ptn3460_enable(struct drm_bridge *bridge)\r\n{\r\n}\r\nstatic void ptn3460_disable(struct drm_bridge *bridge)\r\n{\r\nstruct ptn3460_bridge *ptn_bridge = bridge->driver_private;\r\nif (!ptn_bridge->enabled)\r\nreturn;\r\nptn_bridge->enabled = false;\r\nif (gpio_is_valid(ptn_bridge->gpio_rst_n))\r\ngpio_set_value(ptn_bridge->gpio_rst_n, 1);\r\nif (gpio_is_valid(ptn_bridge->gpio_pd_n))\r\ngpio_set_value(ptn_bridge->gpio_pd_n, 0);\r\n}\r\nstatic void ptn3460_post_disable(struct drm_bridge *bridge)\r\n{\r\n}\r\nvoid ptn3460_bridge_destroy(struct drm_bridge *bridge)\r\n{\r\nstruct ptn3460_bridge *ptn_bridge = bridge->driver_private;\r\ndrm_bridge_cleanup(bridge);\r\nif (gpio_is_valid(ptn_bridge->gpio_pd_n))\r\ngpio_free(ptn_bridge->gpio_pd_n);\r\nif (gpio_is_valid(ptn_bridge->gpio_rst_n))\r\ngpio_free(ptn_bridge->gpio_rst_n);\r\n}\r\nint ptn3460_get_modes(struct drm_connector *connector)\r\n{\r\nstruct ptn3460_bridge *ptn_bridge;\r\nu8 *edid;\r\nint ret, num_modes;\r\nbool power_off;\r\nptn_bridge = container_of(connector, struct ptn3460_bridge, connector);\r\nif (ptn_bridge->edid)\r\nreturn drm_add_edid_modes(connector, ptn_bridge->edid);\r\npower_off = !ptn_bridge->enabled;\r\nptn3460_pre_enable(ptn_bridge->bridge);\r\nedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\r\nif (!edid) {\r\nDRM_ERROR("Failed to allocate edid\n");\r\nreturn 0;\r\n}\r\nret = ptn3460_read_bytes(ptn_bridge, PTN3460_EDID_ADDR, edid,\r\nEDID_LENGTH);\r\nif (ret) {\r\nkfree(edid);\r\nnum_modes = 0;\r\ngoto out;\r\n}\r\nptn_bridge->edid = (struct edid *)edid;\r\ndrm_mode_connector_update_edid_property(connector, ptn_bridge->edid);\r\nnum_modes = drm_add_edid_modes(connector, ptn_bridge->edid);\r\nout:\r\nif (power_off)\r\nptn3460_disable(ptn_bridge->bridge);\r\nreturn num_modes;\r\n}\r\nstruct drm_encoder *ptn3460_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct ptn3460_bridge *ptn_bridge;\r\nptn_bridge = container_of(connector, struct ptn3460_bridge, connector);\r\nreturn ptn_bridge->encoder;\r\n}\r\nenum drm_connector_status ptn3460_detect(struct drm_connector *connector,\r\nbool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nvoid ptn3460_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_cleanup(connector);\r\n}\r\nint ptn3460_init(struct drm_device *dev, struct drm_encoder *encoder,\r\nstruct i2c_client *client, struct device_node *node)\r\n{\r\nint ret;\r\nstruct drm_bridge *bridge;\r\nstruct ptn3460_bridge *ptn_bridge;\r\nbridge = devm_kzalloc(dev->dev, sizeof(*bridge), GFP_KERNEL);\r\nif (!bridge) {\r\nDRM_ERROR("Failed to allocate drm bridge\n");\r\nreturn -ENOMEM;\r\n}\r\nptn_bridge = devm_kzalloc(dev->dev, sizeof(*ptn_bridge), GFP_KERNEL);\r\nif (!ptn_bridge) {\r\nDRM_ERROR("Failed to allocate ptn bridge\n");\r\nreturn -ENOMEM;\r\n}\r\nptn_bridge->client = client;\r\nptn_bridge->encoder = encoder;\r\nptn_bridge->bridge = bridge;\r\nptn_bridge->gpio_pd_n = of_get_named_gpio(node, "powerdown-gpio", 0);\r\nif (gpio_is_valid(ptn_bridge->gpio_pd_n)) {\r\nret = gpio_request_one(ptn_bridge->gpio_pd_n,\r\nGPIOF_OUT_INIT_HIGH, "PTN3460_PD_N");\r\nif (ret) {\r\nDRM_ERROR("Request powerdown-gpio failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nptn_bridge->gpio_rst_n = of_get_named_gpio(node, "reset-gpio", 0);\r\nif (gpio_is_valid(ptn_bridge->gpio_rst_n)) {\r\nret = gpio_request_one(ptn_bridge->gpio_rst_n,\r\nGPIOF_OUT_INIT_LOW, "PTN3460_RST_N");\r\nif (ret) {\r\nDRM_ERROR("Request reset-gpio failed (%d)\n", ret);\r\ngpio_free(ptn_bridge->gpio_pd_n);\r\nreturn ret;\r\n}\r\n}\r\nret = of_property_read_u32(node, "edid-emulation",\r\n&ptn_bridge->edid_emulation);\r\nif (ret) {\r\nDRM_ERROR("Can't read edid emulation value\n");\r\ngoto err;\r\n}\r\nret = drm_bridge_init(dev, bridge, &ptn3460_bridge_funcs);\r\nif (ret) {\r\nDRM_ERROR("Failed to initialize bridge with drm\n");\r\ngoto err;\r\n}\r\nbridge->driver_private = ptn_bridge;\r\nencoder->bridge = bridge;\r\nret = drm_connector_init(dev, &ptn_bridge->connector,\r\n&ptn3460_connector_funcs, DRM_MODE_CONNECTOR_LVDS);\r\nif (ret) {\r\nDRM_ERROR("Failed to initialize connector with drm\n");\r\ngoto err;\r\n}\r\ndrm_connector_helper_add(&ptn_bridge->connector,\r\n&ptn3460_connector_helper_funcs);\r\ndrm_connector_register(&ptn_bridge->connector);\r\ndrm_mode_connector_attach_encoder(&ptn_bridge->connector, encoder);\r\nreturn 0;\r\nerr:\r\nif (gpio_is_valid(ptn_bridge->gpio_pd_n))\r\ngpio_free(ptn_bridge->gpio_pd_n);\r\nif (gpio_is_valid(ptn_bridge->gpio_rst_n))\r\ngpio_free(ptn_bridge->gpio_rst_n);\r\nreturn ret;\r\n}
