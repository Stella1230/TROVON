static void reg_r_i(struct gspca_dev *gspca_dev,\r\nu16 req,\r\nu16 index,\r\nu16 len)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\nreq,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n1,\r\nindex, gspca_dev->usb_buf, len,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_r err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_r(struct gspca_dev *gspca_dev,\r\nu16 req,\r\nu16 index,\r\nu16 len)\r\n{\r\nreg_r_i(gspca_dev, req, index, len);\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (len == 1)\r\nPDEBUG(D_USBI, "GET %02x 0001 %04x %02x", req, index,\r\ngspca_dev->usb_buf[0]);\r\nelse\r\nPDEBUG(D_USBI, "GET %02x 0001 %04x %*ph",\r\nreq, index, 3, gspca_dev->usb_buf);\r\n}\r\nstatic void reg_w_i(struct gspca_dev *gspca_dev,\r\nu16 req,\r\nu16 value,\r\nu16 index)\r\n{\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, NULL, 0,\r\n500);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\nu16 req,\r\nu16 value,\r\nu16 index)\r\n{\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nPDEBUG(D_USBO, "SET %02x %04x %04x", req, value, index);\r\nreg_w_i(gspca_dev, req, value, index);\r\n}\r\nstatic u16 read_sensor_register(struct gspca_dev *gspca_dev,\r\nu16 address)\r\n{\r\nu8 ldata, mdata, hdata;\r\nint retry = 50;\r\nreg_r(gspca_dev, 0xa1, 0xb33f, 1);\r\nif (!(gspca_dev->usb_buf[0] & 0x02)) {\r\npr_err("I2c Bus Busy Wait %02x\n", gspca_dev->usb_buf[0]);\r\nreturn 0;\r\n}\r\nreg_w(gspca_dev, 0xa0, address, 0xb33a);\r\nreg_w(gspca_dev, 0xa0, 0x02, 0xb339);\r\ndo {\r\nreg_r(gspca_dev, 0xa1, 0xb33b, 1);\r\nif (gspca_dev->usb_buf[0] == 0x00)\r\nbreak;\r\nmsleep(40);\r\n} while (--retry >= 0);\r\nreg_r(gspca_dev, 0xa1, 0xb33e, 1);\r\nldata = gspca_dev->usb_buf[0];\r\nreg_r(gspca_dev, 0xa1, 0xb33d, 1);\r\nmdata = gspca_dev->usb_buf[0];\r\nreg_r(gspca_dev, 0xa1, 0xb33c, 1);\r\nhdata = gspca_dev->usb_buf[0];\r\nif (hdata != 0 && mdata != 0 && ldata != 0)\r\nPDEBUG(D_PROBE, "Read Sensor %02x%02x %02x",\r\nhdata, mdata, ldata);\r\nreg_r(gspca_dev, 0xa1, 0xb334, 1);\r\nif (gspca_dev->usb_buf[0] == 0x02)\r\nreturn (hdata << 8) + mdata;\r\nreturn hdata;\r\n}\r\nstatic int vc032x_probe_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, n;\r\nu16 value;\r\nconst struct sensor_info *ptsensor_info;\r\nif (sd->flags & FL_SAMSUNG) {\r\nreg_w(gspca_dev, 0xa0, 0x01, 0xb301);\r\nreg_w(gspca_dev, 0x89, 0xf0ff, 0xffff);\r\n}\r\nreg_r(gspca_dev, 0xa1, 0xbfcf, 1);\r\nPDEBUG(D_PROBE, "vc032%d check sensor header %02x",\r\nsd->bridge == BRIDGE_VC0321 ? 1 : 3, gspca_dev->usb_buf[0]);\r\nif (sd->bridge == BRIDGE_VC0321) {\r\nptsensor_info = vc0321_probe_data;\r\nn = ARRAY_SIZE(vc0321_probe_data);\r\n} else {\r\nptsensor_info = vc0323_probe_data;\r\nn = ARRAY_SIZE(vc0323_probe_data);\r\n}\r\nfor (i = 0; i < n; i++) {\r\nreg_w(gspca_dev, 0xa0, 0x02, 0xb334);\r\nreg_w(gspca_dev, 0xa0, ptsensor_info->m1, 0xb300);\r\nreg_w(gspca_dev, 0xa0, ptsensor_info->m2, 0xb300);\r\nreg_w(gspca_dev, 0xa0, 0x01, 0xb308);\r\nreg_w(gspca_dev, 0xa0, 0x0c, 0xb309);\r\nreg_w(gspca_dev, 0xa0, ptsensor_info->I2cAdd, 0xb335);\r\nreg_w(gspca_dev, 0xa0, ptsensor_info->op, 0xb301);\r\nvalue = read_sensor_register(gspca_dev, ptsensor_info->IdAdd);\r\nif (value == 0 && ptsensor_info->IdAdd == 0x82)\r\nvalue = read_sensor_register(gspca_dev, 0x83);\r\nif (value != 0) {\r\nPDEBUG(D_PROBE, "Sensor ID %04x (%d)", value, i);\r\nif (value == ptsensor_info->VpId)\r\nreturn ptsensor_info->sensorId;\r\nswitch (value) {\r\ncase 0x3130:\r\nreturn SENSOR_PO3130NC;\r\ncase 0x7673:\r\nreturn SENSOR_OV7670;\r\ncase 0x8243:\r\nreturn SENSOR_MI0360;\r\n}\r\n}\r\nptsensor_info++;\r\n}\r\nreturn -1;\r\n}\r\nstatic void i2c_write(struct gspca_dev *gspca_dev,\r\nu8 reg, const u8 *val,\r\nu8 size)\r\n{\r\nint retry;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (size == 1)\r\nPDEBUG(D_USBO, "i2c_w %02x %02x", reg, *val);\r\nelse\r\nPDEBUG(D_USBO, "i2c_w %02x %02x%02x", reg, *val, val[1]);\r\nreg_r_i(gspca_dev, 0xa1, 0xb33f, 1);\r\nreg_w_i(gspca_dev, 0xa0, size, 0xb334);\r\nreg_w_i(gspca_dev, 0xa0, reg, 0xb33a);\r\nreg_w_i(gspca_dev, 0xa0, val[0], 0xb336);\r\nif (size > 1)\r\nreg_w_i(gspca_dev, 0xa0, val[1], 0xb337);\r\nreg_w_i(gspca_dev, 0xa0, 0x01, 0xb339);\r\nretry = 4;\r\ndo {\r\nreg_r_i(gspca_dev, 0xa1, 0xb33b, 1);\r\nif (gspca_dev->usb_buf[0] == 0)\r\nbreak;\r\nmsleep(20);\r\n} while (--retry > 0);\r\nif (retry <= 0)\r\npr_err("i2c_write timeout\n");\r\n}\r\nstatic void put_tab_to_reg(struct gspca_dev *gspca_dev,\r\nconst u8 *tab, u8 tabsize, u16 addr)\r\n{\r\nint j;\r\nu16 ad = addr;\r\nfor (j = 0; j < tabsize; j++)\r\nreg_w(gspca_dev, 0xa0, tab[j], ad++);\r\n}\r\nstatic void usb_exchange(struct gspca_dev *gspca_dev,\r\nconst u8 data[][4])\r\n{\r\nint i = 0;\r\nfor (;;) {\r\nswitch (data[i][3]) {\r\ndefault:\r\nreturn;\r\ncase 0xcc:\r\nreg_w(gspca_dev, 0xa0, data[i][2],\r\n(data[i][0]) << 8 | data[i][1]);\r\nbreak;\r\ncase 0xaa:\r\ni2c_write(gspca_dev, data[i][1], &data[i][2], 1);\r\nbreak;\r\ncase 0xbb:\r\ni2c_write(gspca_dev, data[i][0], &data[i][1], 2);\r\nbreak;\r\ncase 0xdd:\r\nmsleep(data[i][1] * 256 + data[i][2] + 10);\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->bridge = id->driver_info >> 8;\r\nsd->flags = id->driver_info & 0xff;\r\nif (id->idVendor == 0x046d &&\r\n(id->idProduct == 0x0892 || id->idProduct == 0x0896))\r\nsd->sensor = SENSOR_POxxxx;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nint sensor;\r\nstatic u8 npkt[NSENSORS] = {\r\n[SENSOR_HV7131R] = 64,\r\n[SENSOR_MI0360] = 32,\r\n[SENSOR_MI1310_SOC] = 32,\r\n[SENSOR_MI1320] = 64,\r\n[SENSOR_MI1320_SOC] = 128,\r\n[SENSOR_OV7660] = 32,\r\n[SENSOR_OV7670] = 64,\r\n[SENSOR_PO1200] = 128,\r\n[SENSOR_PO3130NC] = 128,\r\n[SENSOR_POxxxx] = 128,\r\n};\r\nif (sd->sensor != SENSOR_POxxxx)\r\nsensor = vc032x_probe_sensor(gspca_dev);\r\nelse\r\nsensor = sd->sensor;\r\nswitch (sensor) {\r\ncase -1:\r\npr_err("Unknown sensor...\n");\r\nreturn -EINVAL;\r\ncase SENSOR_HV7131R:\r\nPDEBUG(D_PROBE, "Find Sensor HV7131R");\r\nbreak;\r\ncase SENSOR_MI0360:\r\nPDEBUG(D_PROBE, "Find Sensor MI0360");\r\nsd->bridge = BRIDGE_VC0323;\r\nbreak;\r\ncase SENSOR_MI1310_SOC:\r\nPDEBUG(D_PROBE, "Find Sensor MI1310_SOC");\r\nbreak;\r\ncase SENSOR_MI1320:\r\nPDEBUG(D_PROBE, "Find Sensor MI1320");\r\nbreak;\r\ncase SENSOR_MI1320_SOC:\r\nPDEBUG(D_PROBE, "Find Sensor MI1320_SOC");\r\nbreak;\r\ncase SENSOR_OV7660:\r\nPDEBUG(D_PROBE, "Find Sensor OV7660");\r\nbreak;\r\ncase SENSOR_OV7670:\r\nPDEBUG(D_PROBE, "Find Sensor OV7670");\r\nbreak;\r\ncase SENSOR_PO1200:\r\nPDEBUG(D_PROBE, "Find Sensor PO1200");\r\nbreak;\r\ncase SENSOR_PO3130NC:\r\nPDEBUG(D_PROBE, "Find Sensor PO3130NC");\r\nbreak;\r\ncase SENSOR_POxxxx:\r\nPDEBUG(D_PROBE, "Sensor POxxxx");\r\nbreak;\r\n}\r\nsd->sensor = sensor;\r\ncam = &gspca_dev->cam;\r\nif (sd->bridge == BRIDGE_VC0321) {\r\ncam->cam_mode = vc0321_mode;\r\ncam->nmodes = ARRAY_SIZE(vc0321_mode);\r\n} else {\r\nswitch (sensor) {\r\ncase SENSOR_PO1200:\r\ncam->cam_mode = svga_mode;\r\ncam->nmodes = ARRAY_SIZE(svga_mode);\r\nbreak;\r\ncase SENSOR_MI1310_SOC:\r\ncam->cam_mode = vc0323_mode;\r\ncam->nmodes = ARRAY_SIZE(vc0323_mode);\r\nbreak;\r\ncase SENSOR_MI1320_SOC:\r\ncam->cam_mode = bi_mode;\r\ncam->nmodes = ARRAY_SIZE(bi_mode);\r\nbreak;\r\ncase SENSOR_OV7670:\r\ncam->cam_mode = bi_mode;\r\ncam->nmodes = ARRAY_SIZE(bi_mode) - 1;\r\nbreak;\r\ndefault:\r\ncam->cam_mode = vc0323_mode;\r\ncam->nmodes = ARRAY_SIZE(vc0323_mode) - 1;\r\nbreak;\r\n}\r\n}\r\ncam->npkt = npkt[sd->sensor];\r\nif (sd->sensor == SENSOR_OV7670)\r\nsd->flags |= FL_HFLIP | FL_VFLIP;\r\nif (sd->bridge == BRIDGE_VC0321) {\r\nreg_r(gspca_dev, 0x8a, 0, 3);\r\nreg_w(gspca_dev, 0x87, 0x00, 0x0f0f);\r\nreg_r(gspca_dev, 0x8b, 0, 3);\r\nreg_w(gspca_dev, 0x88, 0x00, 0x0202);\r\nif (sd->sensor == SENSOR_POxxxx) {\r\nreg_r(gspca_dev, 0xa1, 0xb300, 1);\r\nif (gspca_dev->usb_buf[0] != 0) {\r\nreg_w(gspca_dev, 0xa0, 0x26, 0xb300);\r\nreg_w(gspca_dev, 0xa0, 0x04, 0xb300);\r\n}\r\nreg_w(gspca_dev, 0xa0, 0x00, 0xb300);\r\n}\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu8 data;\r\ndata = val;\r\nif (data >= 0x80)\r\ndata &= 0x7f;\r\nelse\r\ndata = 0xff ^ data;\r\ni2c_write(gspca_dev, 0x98, &data, 1);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, u8 val)\r\n{\r\ni2c_write(gspca_dev, 0x99, &val, 1);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev, u8 val)\r\n{\r\nu8 data;\r\ndata = val - (val >> 3) - 1;\r\ni2c_write(gspca_dev, 0x94, &data, 1);\r\ni2c_write(gspca_dev, 0x95, &val, 1);\r\n}\r\nstatic void sethvflip(struct gspca_dev *gspca_dev, bool hflip, bool vflip)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 data[2];\r\nif (sd->flags & FL_HFLIP)\r\nhflip = !hflip;\r\nif (sd->flags & FL_VFLIP)\r\nvflip = !vflip;\r\nswitch (sd->sensor) {\r\ncase SENSOR_MI1310_SOC:\r\ncase SENSOR_MI1320:\r\ncase SENSOR_MI1320_SOC:\r\ndata[0] = data[1] = 0;\r\ni2c_write(gspca_dev, 0xf0, data, 2);\r\ndata[0] = sd->sensor == SENSOR_MI1310_SOC ? 0x03 : 0x01;\r\ndata[1] = 0x02 * hflip\r\n| 0x01 * vflip;\r\ni2c_write(gspca_dev, 0x20, data, 2);\r\nbreak;\r\ncase SENSOR_OV7660:\r\ncase SENSOR_OV7670:\r\ndata[0] = sd->sensor == SENSOR_OV7660 ? 0x01 : 0x07;\r\ndata[0] |= OV7660_MVFP_MIRROR * hflip\r\n| OV7660_MVFP_VFLIP * vflip;\r\ni2c_write(gspca_dev, OV7660_REG_MVFP, data, 1);\r\nbreak;\r\ncase SENSOR_PO1200:\r\ndata[0] = 0;\r\ni2c_write(gspca_dev, 0x03, data, 1);\r\ndata[0] = 0x80 * hflip\r\n| 0x40 * vflip\r\n| 0x06;\r\ni2c_write(gspca_dev, 0x1e, data, 1);\r\nbreak;\r\n}\r\n}\r\nstatic void setlightfreq(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstatic const u8 (*ov7660_freq_tb[3])[4] =\r\n{ov7660_NoFliker, ov7660_50HZ, ov7660_60HZ};\r\nif (sd->sensor != SENSOR_OV7660)\r\nreturn;\r\nusb_exchange(gspca_dev, ov7660_freq_tb[val]);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 data;\r\nswitch (sd->sensor) {\r\ncase SENSOR_PO1200:\r\ndata = 0;\r\ni2c_write(gspca_dev, 0x03, &data, 1);\r\nif (val < 0)\r\ndata = 0x6a;\r\nelse\r\ndata = 0xb5 + val * 3;\r\ni2c_write(gspca_dev, 0x61, &data, 1);\r\nbreak;\r\ncase SENSOR_POxxxx:\r\nif (val < 0)\r\ndata = 0x7e;\r\nelse\r\ndata = 0x60 + val * 0x0f;\r\ni2c_write(gspca_dev, 0x59, &data, 1);\r\nbreak;\r\n}\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev, u8 val)\r\n{\r\ni2c_write(gspca_dev, 0x15, &val, 1);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu8 data;\r\ndata = val >> 8;\r\ni2c_write(gspca_dev, 0x1a, &data, 1);\r\ndata = val;\r\ni2c_write(gspca_dev, 0x1b, &data, 1);\r\n}\r\nstatic void setautogain(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstatic const u8 data[2] = {0x28, 0x3c};\r\ni2c_write(gspca_dev, 0xd1, &data[val], 1);\r\n}\r\nstatic void setgamma(struct gspca_dev *gspca_dev)\r\n{\r\nusb_exchange(gspca_dev, poxxxx_gamma);\r\n}\r\nstatic void setbacklight(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu16 v;\r\nu8 data;\r\ndata = (val << 4) | 0x0f;\r\ni2c_write(gspca_dev, 0xaa, &data, 1);\r\nv = 613 + 12 * val;\r\ndata = v >> 8;\r\ni2c_write(gspca_dev, 0xc4, &data, 1);\r\ndata = v;\r\ni2c_write(gspca_dev, 0xc5, &data, 1);\r\nv = 1093 - 12 * val;\r\ndata = v >> 8;\r\ni2c_write(gspca_dev, 0xc6, &data, 1);\r\ndata = v;\r\ni2c_write(gspca_dev, 0xc7, &data, 1);\r\nv = 342 + 9 * val;\r\ndata = v >> 8;\r\ni2c_write(gspca_dev, 0xc8, &data, 1);\r\ndata = v;\r\ni2c_write(gspca_dev, 0xc9, &data, 1);\r\nv = 702 - 9 * val;\r\ndata = v >> 8;\r\ni2c_write(gspca_dev, 0xca, &data, 1);\r\ndata = v;\r\ni2c_write(gspca_dev, 0xcb, &data, 1);\r\n}\r\nstatic void setwb(struct gspca_dev *gspca_dev)\r\n{\r\nstatic const u8 data[2] = {0x00, 0x00};\r\ni2c_write(gspca_dev, 0x16, &data[0], 1);\r\ni2c_write(gspca_dev, 0x18, &data[1], 1);\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst u8 (*init)[4];\r\nconst u8 *GammaT = NULL;\r\nconst u8 *MatrixT = NULL;\r\nint mode;\r\nstatic const u8 (*mi1320_soc_init[])[4] = {\r\nmi1320_soc_InitSXGA,\r\nmi1320_soc_InitVGA,\r\nmi1320_soc_InitQVGA,\r\n};\r\nif (sd->flags & FL_SAMSUNG) {\r\nreg_w(gspca_dev, 0x89, 0xf0ff, 0xffff);\r\nreg_w(gspca_dev, 0xa9, 0x8348, 0x000e);\r\nreg_w(gspca_dev, 0xa9, 0x0000, 0x001a);\r\n}\r\nif (sd->bridge == BRIDGE_VC0321) {\r\nreg_w(gspca_dev, 0xa0, 0xff, 0xbfec);\r\nreg_w(gspca_dev, 0xa0, 0xff, 0xbfed);\r\nreg_w(gspca_dev, 0xa0, 0xff, 0xbfee);\r\nreg_w(gspca_dev, 0xa0, 0xff, 0xbfef);\r\nsd->image_offset = 46;\r\n} else {\r\nif (gspca_dev->cam.cam_mode[gspca_dev->curr_mode].pixelformat\r\n== V4L2_PIX_FMT_JPEG)\r\nsd->image_offset = 0;\r\nelse\r\nsd->image_offset = 32;\r\n}\r\nmode = gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv;\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131R:\r\nGammaT = hv7131r_gamma;\r\nMatrixT = hv7131r_matrix;\r\nif (mode)\r\ninit = hv7131r_initQVGA_data;\r\nelse\r\ninit = hv7131r_initVGA_data;\r\nbreak;\r\ncase SENSOR_OV7660:\r\nGammaT = ov7660_gamma;\r\nMatrixT = ov7660_matrix;\r\nif (mode)\r\ninit = ov7660_initQVGA_data;\r\nelse\r\ninit = ov7660_initVGA_data;\r\nbreak;\r\ncase SENSOR_MI0360:\r\nGammaT = mi1320_gamma;\r\nMatrixT = mi0360_matrix;\r\nif (mode)\r\ninit = mi0360_initQVGA_JPG;\r\nelse\r\ninit = mi0360_initVGA_JPG;\r\nbreak;\r\ncase SENSOR_MI1310_SOC:\r\nGammaT = mi1320_gamma;\r\nMatrixT = mi1320_matrix;\r\nswitch (mode) {\r\ncase 1:\r\ninit = mi1310_socinitQVGA_JPG;\r\nbreak;\r\ncase 0:\r\ninit = mi1310_socinitVGA_JPG;\r\nbreak;\r\ndefault:\r\ninit = mi1310_soc_InitSXGA_JPG;\r\nbreak;\r\n}\r\nbreak;\r\ncase SENSOR_MI1320:\r\nGammaT = mi1320_gamma;\r\nMatrixT = mi1320_matrix;\r\nif (mode)\r\ninit = mi1320_initQVGA_data;\r\nelse\r\ninit = mi1320_initVGA_data;\r\nbreak;\r\ncase SENSOR_MI1320_SOC:\r\nGammaT = mi1320_gamma;\r\nMatrixT = mi1320_matrix;\r\ninit = mi1320_soc_init[mode];\r\nbreak;\r\ncase SENSOR_OV7670:\r\ninit = mode == 1 ? ov7670_InitVGA : ov7670_InitQVGA;\r\nbreak;\r\ncase SENSOR_PO3130NC:\r\nGammaT = po3130_gamma;\r\nMatrixT = po3130_matrix;\r\nif (mode)\r\ninit = po3130_initQVGA_data;\r\nelse\r\ninit = po3130_initVGA_data;\r\nusb_exchange(gspca_dev, init);\r\ninit = po3130_rundata;\r\nbreak;\r\ncase SENSOR_PO1200:\r\nGammaT = po1200_gamma;\r\nMatrixT = po1200_matrix;\r\ninit = po1200_initVGA_data;\r\nbreak;\r\ndefault:\r\nusb_exchange(gspca_dev, poxxxx_init_common);\r\nsetgamma(gspca_dev);\r\nusb_exchange(gspca_dev, poxxxx_init_start_3);\r\nif (mode)\r\ninit = poxxxx_initQVGA;\r\nelse\r\ninit = poxxxx_initVGA;\r\nusb_exchange(gspca_dev, init);\r\nreg_r(gspca_dev, 0x8c, 0x0000, 3);\r\nreg_w(gspca_dev, 0xa0,\r\ngspca_dev->usb_buf[2] & 1 ? 0 : 1,\r\n0xb35c);\r\nmsleep(300);\r\ninit = poxxxx_init_end_1;\r\nbreak;\r\n}\r\nusb_exchange(gspca_dev, init);\r\nif (GammaT && MatrixT) {\r\nput_tab_to_reg(gspca_dev, GammaT, 17, 0xb84a);\r\nput_tab_to_reg(gspca_dev, GammaT, 17, 0xb85b);\r\nput_tab_to_reg(gspca_dev, GammaT, 17, 0xb86c);\r\nput_tab_to_reg(gspca_dev, MatrixT, 9, 0xb82c);\r\nswitch (sd->sensor) {\r\ncase SENSOR_PO1200:\r\ncase SENSOR_HV7131R:\r\nreg_w(gspca_dev, 0x89, 0x0400, 0x1415);\r\nbreak;\r\ncase SENSOR_MI1310_SOC:\r\nreg_w(gspca_dev, 0x89, 0x058c, 0x0000);\r\nbreak;\r\n}\r\nmsleep(100);\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV7670:\r\nreg_w(gspca_dev, 0x87, 0xffff, 0xffff);\r\nreg_w(gspca_dev, 0x88, 0xff00, 0xf0f1);\r\nreg_w(gspca_dev, 0xa0, 0x0000, 0xbfff);\r\nbreak;\r\ncase SENSOR_POxxxx:\r\nusb_exchange(gspca_dev, poxxxx_init_end_2);\r\nsetwb(gspca_dev);\r\nmsleep(80);\r\nreg_w(gspca_dev, 0x89, 0xffff, 0xfdff);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_MI1310_SOC:\r\nreg_w(gspca_dev, 0x89, 0x058c, 0x00ff);\r\nbreak;\r\ncase SENSOR_POxxxx:\r\nreturn;\r\ndefault:\r\nif (!(sd->flags & FL_SAMSUNG))\r\nreg_w(gspca_dev, 0x89, 0xffff, 0xffff);\r\nbreak;\r\n}\r\nreg_w(gspca_dev, 0xa0, 0x01, 0xb301);\r\nreg_w(gspca_dev, 0xa0, 0x09, 0xb003);\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!gspca_dev->present)\r\nreturn;\r\nif (sd->sensor == SENSOR_MI1310_SOC)\r\nreg_w(gspca_dev, 0x89, 0x058c, 0x00ff);\r\nelse if (!(sd->flags & FL_SAMSUNG))\r\nreg_w(gspca_dev, 0x89, 0xffff, 0xffff);\r\nif (sd->sensor == SENSOR_POxxxx) {\r\nreg_w(gspca_dev, 0xa0, 0x26, 0xb300);\r\nreg_w(gspca_dev, 0xa0, 0x04, 0xb300);\r\nreg_w(gspca_dev, 0xa0, 0x00, 0xb300);\r\n}\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (data[0] == 0xff && data[1] == 0xd8) {\r\nPDEBUG(D_PACK,\r\n"vc032x header packet found len %d", len);\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ndata += sd->image_offset;\r\nlen -= sd->image_offset;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\r\nreturn;\r\n}\r\nif (sd->bridge == BRIDGE_VC0321) {\r\nint size, l;\r\nl = gspca_dev->image_len;\r\nsize = gspca_dev->frsz;\r\nif (len > size - l)\r\nlen = size - l;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming && ctrl->id != V4L2_CID_POWER_LINE_FREQUENCY)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nsethvflip(gspca_dev, sd->hflip->val, sd->vflip->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nsetsharpness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nsetautogain(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nsetgain(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nsetexposure(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BACKLIGHT_COMPENSATION:\r\nsetbacklight(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nsetlightfreq(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\nbool has_brightness = false;\r\nbool has_contrast = false;\r\nbool has_sat = false;\r\nbool has_hvflip = false;\r\nbool has_freq = false;\r\nbool has_backlight = false;\r\nbool has_exposure = false;\r\nbool has_autogain = false;\r\nbool has_gain = false;\r\nbool has_sharpness = false;\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131R:\r\ncase SENSOR_MI0360:\r\ncase SENSOR_PO3130NC:\r\nbreak;\r\ncase SENSOR_MI1310_SOC:\r\ncase SENSOR_MI1320:\r\ncase SENSOR_MI1320_SOC:\r\ncase SENSOR_OV7660:\r\nhas_hvflip = true;\r\nbreak;\r\ncase SENSOR_OV7670:\r\nhas_hvflip = has_freq = true;\r\nbreak;\r\ncase SENSOR_PO1200:\r\nhas_hvflip = has_sharpness = true;\r\nbreak;\r\ncase SENSOR_POxxxx:\r\nhas_brightness = has_contrast = has_sat = has_backlight =\r\nhas_exposure = has_autogain = has_gain =\r\nhas_sharpness = true;\r\nbreak;\r\n}\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 8);\r\nif (has_brightness)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nif (has_contrast)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 127);\r\nif (has_sat)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 1, 127, 1, 63);\r\nif (has_hvflip) {\r\nsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\n}\r\nif (has_sharpness)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SHARPNESS, -1, 2, 1, -1);\r\nif (has_freq)\r\nv4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0,\r\nV4L2_CID_POWER_LINE_FREQUENCY_50HZ);\r\nif (has_autogain)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nif (has_gain)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 78, 1, 0);\r\nif (has_exposure)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 4095, 1, 450);\r\nif (has_backlight)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BACKLIGHT_COMPENSATION, 0, 15, 1, 15);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nif (sd->hflip)\r\nv4l2_ctrl_cluster(2, &sd->hflip);\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
