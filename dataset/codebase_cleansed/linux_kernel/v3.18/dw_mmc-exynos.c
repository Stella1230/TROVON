static int dw_mci_exynos_priv_init(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS5420_SMU) {\r\nmci_writel(host, MPSBEGIN0, 0);\r\nmci_writel(host, MPSEND0, DWMCI_BLOCK_NUM);\r\nmci_writel(host, MPSCTRL0, DWMCI_MPSCTRL_SECURE_WRITE_BIT |\r\nDWMCI_MPSCTRL_NON_SECURE_READ_BIT |\r\nDWMCI_MPSCTRL_VALID |\r\nDWMCI_MPSCTRL_NON_SECURE_WRITE_BIT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dw_mci_exynos_setup_clock(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nunsigned long rate = clk_get_rate(host->ciu_clk);\r\nhost->bus_hz = rate / (priv->ciu_div + 1);\r\nreturn 0;\r\n}\r\nstatic int dw_mci_exynos_suspend(struct device *dev)\r\n{\r\nstruct dw_mci *host = dev_get_drvdata(dev);\r\nreturn dw_mci_suspend(host);\r\n}\r\nstatic int dw_mci_exynos_resume(struct device *dev)\r\n{\r\nstruct dw_mci *host = dev_get_drvdata(dev);\r\ndw_mci_exynos_priv_init(host);\r\nreturn dw_mci_resume(host);\r\n}\r\nstatic int dw_mci_exynos_resume_noirq(struct device *dev)\r\n{\r\nstruct dw_mci *host = dev_get_drvdata(dev);\r\nu32 clksel;\r\nclksel = mci_readl(host, CLKSEL);\r\nif (clksel & SDMMC_CLKSEL_WAKEUP_INT)\r\nmci_writel(host, CLKSEL, clksel);\r\nreturn 0;\r\n}\r\nstatic void dw_mci_exynos_prepare_command(struct dw_mci *host, u32 *cmdr)\r\n{\r\nif (SDMMC_CLKSEL_GET_DRV_WD3(mci_readl(host, CLKSEL)))\r\n*cmdr |= SDMMC_CMD_USE_HOLD_REG;\r\n}\r\nstatic void dw_mci_exynos_set_ios(struct dw_mci *host, struct mmc_ios *ios)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv = host->priv;\r\nunsigned int wanted = ios->clock;\r\nunsigned long actual;\r\nu8 div = priv->ciu_div + 1;\r\nif (ios->timing == MMC_TIMING_MMC_DDR52) {\r\nmci_writel(host, CLKSEL, priv->ddr_timing);\r\nif (ios->bus_width == MMC_BUS_WIDTH_8)\r\nwanted <<= 1;\r\n} else {\r\nmci_writel(host, CLKSEL, priv->sdr_timing);\r\n}\r\nif (!wanted)\r\nreturn;\r\nif (wanted < EXYNOS_CCLKIN_MIN)\r\nwanted = EXYNOS_CCLKIN_MIN;\r\nif (wanted != priv->cur_speed) {\r\nint ret = clk_set_rate(host->ciu_clk, wanted * div);\r\nif (ret)\r\ndev_warn(host->dev,\r\n"failed to set clk-rate %u error: %d\n",\r\nwanted * div, ret);\r\nactual = clk_get_rate(host->ciu_clk);\r\nhost->bus_hz = actual / div;\r\npriv->cur_speed = wanted;\r\nhost->current_speed = 0;\r\n}\r\n}\r\nstatic int dw_mci_exynos_parse_dt(struct dw_mci *host)\r\n{\r\nstruct dw_mci_exynos_priv_data *priv;\r\nstruct device_node *np = host->dev->of_node;\r\nu32 timing[2];\r\nu32 div = 0;\r\nint idx;\r\nint ret;\r\npriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(host->dev, "mem alloc failed for private data\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(exynos_compat); idx++) {\r\nif (of_device_is_compatible(np, exynos_compat[idx].compatible))\r\npriv->ctrl_type = exynos_compat[idx].ctrl_type;\r\n}\r\nif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4412)\r\npriv->ciu_div = EXYNOS4412_FIXED_CIU_CLK_DIV - 1;\r\nelse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4210)\r\npriv->ciu_div = EXYNOS4210_FIXED_CIU_CLK_DIV - 1;\r\nelse {\r\nof_property_read_u32(np, "samsung,dw-mshc-ciu-div", &div);\r\npriv->ciu_div = div;\r\n}\r\nret = of_property_read_u32_array(np,\r\n"samsung,dw-mshc-sdr-timing", timing, 2);\r\nif (ret)\r\nreturn ret;\r\npriv->sdr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);\r\nret = of_property_read_u32_array(np,\r\n"samsung,dw-mshc-ddr-timing", timing, 2);\r\nif (ret)\r\nreturn ret;\r\npriv->ddr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);\r\nhost->priv = priv;\r\nreturn 0;\r\n}\r\nstatic inline u8 dw_mci_exynos_get_clksmpl(struct dw_mci *host)\r\n{\r\nreturn SDMMC_CLKSEL_CCLK_SAMPLE(mci_readl(host, CLKSEL));\r\n}\r\nstatic inline void dw_mci_exynos_set_clksmpl(struct dw_mci *host, u8 sample)\r\n{\r\nu32 clksel;\r\nclksel = mci_readl(host, CLKSEL);\r\nclksel = (clksel & ~0x7) | SDMMC_CLKSEL_CCLK_SAMPLE(sample);\r\nmci_writel(host, CLKSEL, clksel);\r\n}\r\nstatic inline u8 dw_mci_exynos_move_next_clksmpl(struct dw_mci *host)\r\n{\r\nu32 clksel;\r\nu8 sample;\r\nclksel = mci_readl(host, CLKSEL);\r\nsample = (clksel + 1) & 0x7;\r\nclksel = (clksel & ~0x7) | sample;\r\nmci_writel(host, CLKSEL, clksel);\r\nreturn sample;\r\n}\r\nstatic s8 dw_mci_exynos_get_best_clksmpl(u8 candiates)\r\n{\r\nconst u8 iter = 8;\r\nu8 __c;\r\ns8 i, loc = -1;\r\nfor (i = 0; i < iter; i++) {\r\n__c = ror8(candiates, i);\r\nif ((__c & 0xc7) == 0xc7) {\r\nloc = i;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < iter; i++) {\r\n__c = ror8(candiates, i);\r\nif ((__c & 0x83) == 0x83) {\r\nloc = i;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn loc;\r\n}\r\nstatic int dw_mci_exynos_execute_tuning(struct dw_mci_slot *slot, u32 opcode,\r\nstruct dw_mci_tuning_data *tuning_data)\r\n{\r\nstruct dw_mci *host = slot->host;\r\nstruct mmc_host *mmc = slot->mmc;\r\nconst u8 *blk_pattern = tuning_data->blk_pattern;\r\nu8 *blk_test;\r\nunsigned int blksz = tuning_data->blksz;\r\nu8 start_smpl, smpl, candiates = 0;\r\ns8 found = -1;\r\nint ret = 0;\r\nblk_test = kmalloc(blksz, GFP_KERNEL);\r\nif (!blk_test)\r\nreturn -ENOMEM;\r\nstart_smpl = dw_mci_exynos_get_clksmpl(host);\r\ndo {\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_command stop = {0};\r\nstruct mmc_data data = {0};\r\nstruct scatterlist sg;\r\ncmd.opcode = opcode;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;\r\nstop.opcode = MMC_STOP_TRANSMISSION;\r\nstop.arg = 0;\r\nstop.flags = MMC_RSP_R1B | MMC_CMD_AC;\r\ndata.blksz = blksz;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.sg = &sg;\r\ndata.sg_len = 1;\r\nsg_init_one(&sg, blk_test, blksz);\r\nmrq.cmd = &cmd;\r\nmrq.stop = &stop;\r\nmrq.data = &data;\r\nhost->mrq = &mrq;\r\nmci_writel(host, TMOUT, ~0);\r\nsmpl = dw_mci_exynos_move_next_clksmpl(host);\r\nmmc_wait_for_req(mmc, &mrq);\r\nif (!cmd.error && !data.error) {\r\nif (!memcmp(blk_pattern, blk_test, blksz))\r\ncandiates |= (1 << smpl);\r\n} else {\r\ndev_dbg(host->dev,\r\n"Tuning error: cmd.error:%d, data.error:%d\n",\r\ncmd.error, data.error);\r\n}\r\n} while (start_smpl != smpl);\r\nfound = dw_mci_exynos_get_best_clksmpl(candiates);\r\nif (found >= 0)\r\ndw_mci_exynos_set_clksmpl(host, found);\r\nelse\r\nret = -EIO;\r\nkfree(blk_test);\r\nreturn ret;\r\n}\r\nstatic int dw_mci_exynos_probe(struct platform_device *pdev)\r\n{\r\nconst struct dw_mci_drv_data *drv_data;\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(dw_mci_exynos_match, pdev->dev.of_node);\r\ndrv_data = match->data;\r\nreturn dw_mci_pltfm_register(pdev, drv_data);\r\n}
