static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\r\n{\r\ncred->securebits = SECUREBITS_DEFAULT;\r\ncred->cap_inheritable = CAP_EMPTY_SET;\r\ncred->cap_permitted = CAP_FULL_SET;\r\ncred->cap_effective = CAP_FULL_SET;\r\ncred->cap_bset = CAP_FULL_SET;\r\n#ifdef CONFIG_KEYS\r\nkey_put(cred->request_key_auth);\r\ncred->request_key_auth = NULL;\r\n#endif\r\ncred->user_ns = user_ns;\r\n}\r\nint create_user_ns(struct cred *new)\r\n{\r\nstruct user_namespace *ns, *parent_ns = new->user_ns;\r\nkuid_t owner = new->euid;\r\nkgid_t group = new->egid;\r\nint ret;\r\nif (parent_ns->level > 32)\r\nreturn -EUSERS;\r\nif (current_chrooted())\r\nreturn -EPERM;\r\nif (!kuid_has_mapping(parent_ns, owner) ||\r\n!kgid_has_mapping(parent_ns, group))\r\nreturn -EPERM;\r\nns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\r\nif (!ns)\r\nreturn -ENOMEM;\r\nret = proc_alloc_inum(&ns->proc_inum);\r\nif (ret) {\r\nkmem_cache_free(user_ns_cachep, ns);\r\nreturn ret;\r\n}\r\natomic_set(&ns->count, 1);\r\nns->parent = parent_ns;\r\nns->level = parent_ns->level + 1;\r\nns->owner = owner;\r\nns->group = group;\r\nset_cred_user_ns(new, ns);\r\n#ifdef CONFIG_PERSISTENT_KEYRINGS\r\ninit_rwsem(&ns->persistent_keyring_register_sem);\r\n#endif\r\nreturn 0;\r\n}\r\nint unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\r\n{\r\nstruct cred *cred;\r\nint err = -ENOMEM;\r\nif (!(unshare_flags & CLONE_NEWUSER))\r\nreturn 0;\r\ncred = prepare_creds();\r\nif (cred) {\r\nerr = create_user_ns(cred);\r\nif (err)\r\nput_cred(cred);\r\nelse\r\n*new_cred = cred;\r\n}\r\nreturn err;\r\n}\r\nvoid free_user_ns(struct user_namespace *ns)\r\n{\r\nstruct user_namespace *parent;\r\ndo {\r\nparent = ns->parent;\r\n#ifdef CONFIG_PERSISTENT_KEYRINGS\r\nkey_put(ns->persistent_keyring_register);\r\n#endif\r\nproc_free_inum(ns->proc_inum);\r\nkmem_cache_free(user_ns_cachep, ns);\r\nns = parent;\r\n} while (atomic_dec_and_test(&parent->count));\r\n}\r\nstatic u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last, id2;\r\nid2 = id + count - 1;\r\nextents = map->nr_extents;\r\nsmp_rmb();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last &&\r\n(id2 >= first && id2 <= last))\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].lower_first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nstatic u32 map_id_down(struct uid_gid_map *map, u32 id)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last;\r\nextents = map->nr_extents;\r\nsmp_rmb();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last)\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].lower_first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nstatic u32 map_id_up(struct uid_gid_map *map, u32 id)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last;\r\nextents = map->nr_extents;\r\nsmp_rmb();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].lower_first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last)\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\r\n{\r\nreturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\r\n}\r\nuid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\r\n{\r\nreturn map_id_up(&targ->uid_map, __kuid_val(kuid));\r\n}\r\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\r\n{\r\nuid_t uid;\r\nuid = from_kuid(targ, kuid);\r\nif (uid == (uid_t) -1)\r\nuid = overflowuid;\r\nreturn uid;\r\n}\r\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\r\n{\r\nreturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\r\n}\r\ngid_t from_kgid(struct user_namespace *targ, kgid_t kgid)\r\n{\r\nreturn map_id_up(&targ->gid_map, __kgid_val(kgid));\r\n}\r\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\r\n{\r\ngid_t gid;\r\ngid = from_kgid(targ, kgid);\r\nif (gid == (gid_t) -1)\r\ngid = overflowgid;\r\nreturn gid;\r\n}\r\nkprojid_t make_kprojid(struct user_namespace *ns, projid_t projid)\r\n{\r\nreturn KPROJIDT_INIT(map_id_down(&ns->projid_map, projid));\r\n}\r\nprojid_t from_kprojid(struct user_namespace *targ, kprojid_t kprojid)\r\n{\r\nreturn map_id_up(&targ->projid_map, __kprojid_val(kprojid));\r\n}\r\nprojid_t from_kprojid_munged(struct user_namespace *targ, kprojid_t kprojid)\r\n{\r\nprojid_t projid;\r\nprojid = from_kprojid(targ, kprojid);\r\nif (projid == (projid_t) -1)\r\nprojid = OVERFLOW_PROJID;\r\nreturn projid;\r\n}\r\nstatic int uid_m_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_extent *extent = v;\r\nstruct user_namespace *lower_ns;\r\nuid_t lower;\r\nlower_ns = seq_user_ns(seq);\r\nif ((lower_ns == ns) && lower_ns->parent)\r\nlower_ns = lower_ns->parent;\r\nlower = from_kuid(lower_ns, KUIDT_INIT(extent->lower_first));\r\nseq_printf(seq, "%10u %10u %10u\n",\r\nextent->first,\r\nlower,\r\nextent->count);\r\nreturn 0;\r\n}\r\nstatic int gid_m_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_extent *extent = v;\r\nstruct user_namespace *lower_ns;\r\ngid_t lower;\r\nlower_ns = seq_user_ns(seq);\r\nif ((lower_ns == ns) && lower_ns->parent)\r\nlower_ns = lower_ns->parent;\r\nlower = from_kgid(lower_ns, KGIDT_INIT(extent->lower_first));\r\nseq_printf(seq, "%10u %10u %10u\n",\r\nextent->first,\r\nlower,\r\nextent->count);\r\nreturn 0;\r\n}\r\nstatic int projid_m_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_extent *extent = v;\r\nstruct user_namespace *lower_ns;\r\nprojid_t lower;\r\nlower_ns = seq_user_ns(seq);\r\nif ((lower_ns == ns) && lower_ns->parent)\r\nlower_ns = lower_ns->parent;\r\nlower = from_kprojid(lower_ns, KPROJIDT_INIT(extent->lower_first));\r\nseq_printf(seq, "%10u %10u %10u\n",\r\nextent->first,\r\nlower,\r\nextent->count);\r\nreturn 0;\r\n}\r\nstatic void *m_start(struct seq_file *seq, loff_t *ppos,\r\nstruct uid_gid_map *map)\r\n{\r\nstruct uid_gid_extent *extent = NULL;\r\nloff_t pos = *ppos;\r\nif (pos < map->nr_extents)\r\nextent = &map->extent[pos];\r\nreturn extent;\r\n}\r\nstatic void *uid_m_start(struct seq_file *seq, loff_t *ppos)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nreturn m_start(seq, ppos, &ns->uid_map);\r\n}\r\nstatic void *gid_m_start(struct seq_file *seq, loff_t *ppos)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nreturn m_start(seq, ppos, &ns->gid_map);\r\n}\r\nstatic void *projid_m_start(struct seq_file *seq, loff_t *ppos)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nreturn m_start(seq, ppos, &ns->projid_map);\r\n}\r\nstatic void *m_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn seq->op->start(seq, pos);\r\n}\r\nstatic void m_stop(struct seq_file *seq, void *v)\r\n{\r\nreturn;\r\n}\r\nstatic bool mappings_overlap(struct uid_gid_map *new_map,\r\nstruct uid_gid_extent *extent)\r\n{\r\nu32 upper_first, lower_first, upper_last, lower_last;\r\nunsigned idx;\r\nupper_first = extent->first;\r\nlower_first = extent->lower_first;\r\nupper_last = upper_first + extent->count - 1;\r\nlower_last = lower_first + extent->count - 1;\r\nfor (idx = 0; idx < new_map->nr_extents; idx++) {\r\nu32 prev_upper_first, prev_lower_first;\r\nu32 prev_upper_last, prev_lower_last;\r\nstruct uid_gid_extent *prev;\r\nprev = &new_map->extent[idx];\r\nprev_upper_first = prev->first;\r\nprev_lower_first = prev->lower_first;\r\nprev_upper_last = prev_upper_first + prev->count - 1;\r\nprev_lower_last = prev_lower_first + prev->count - 1;\r\nif ((prev_upper_first <= upper_last) &&\r\n(prev_upper_last >= upper_first))\r\nreturn true;\r\nif ((prev_lower_first <= lower_last) &&\r\n(prev_lower_last >= lower_first))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic ssize_t map_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos,\r\nint cap_setid,\r\nstruct uid_gid_map *map,\r\nstruct uid_gid_map *parent_map)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_map new_map;\r\nunsigned idx;\r\nstruct uid_gid_extent *extent = NULL;\r\nunsigned long page = 0;\r\nchar *kbuf, *pos, *next_line;\r\nssize_t ret = -EINVAL;\r\nmutex_lock(&id_map_mutex);\r\nret = -EPERM;\r\nif (map->nr_extents != 0)\r\ngoto out;\r\nif (cap_valid(cap_setid) && !file_ns_capable(file, ns, CAP_SYS_ADMIN))\r\ngoto out;\r\nret = -ENOMEM;\r\npage = __get_free_page(GFP_TEMPORARY);\r\nkbuf = (char *) page;\r\nif (!page)\r\ngoto out;\r\nret = -EINVAL;\r\nif ((*ppos != 0) || (count >= PAGE_SIZE))\r\ngoto out;\r\nret = -EFAULT;\r\nif (copy_from_user(kbuf, buf, count))\r\ngoto out;\r\nkbuf[count] = '\0';\r\nret = -EINVAL;\r\npos = kbuf;\r\nnew_map.nr_extents = 0;\r\nfor (; pos; pos = next_line) {\r\nextent = &new_map.extent[new_map.nr_extents];\r\nnext_line = strchr(pos, '\n');\r\nif (next_line) {\r\n*next_line = '\0';\r\nnext_line++;\r\nif (*next_line == '\0')\r\nnext_line = NULL;\r\n}\r\npos = skip_spaces(pos);\r\nextent->first = simple_strtoul(pos, &pos, 10);\r\nif (!isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nextent->lower_first = simple_strtoul(pos, &pos, 10);\r\nif (!isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nextent->count = simple_strtoul(pos, &pos, 10);\r\nif (*pos && !isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nif (*pos != '\0')\r\ngoto out;\r\nif ((extent->first == (u32) -1) ||\r\n(extent->lower_first == (u32) -1))\r\ngoto out;\r\nif ((extent->first + extent->count) <= extent->first)\r\ngoto out;\r\nif ((extent->lower_first + extent->count) <=\r\nextent->lower_first)\r\ngoto out;\r\nif (mappings_overlap(&new_map, extent))\r\ngoto out;\r\nnew_map.nr_extents++;\r\nif ((new_map.nr_extents == UID_GID_MAP_MAX_EXTENTS) &&\r\n(next_line != NULL))\r\ngoto out;\r\n}\r\nif (new_map.nr_extents == 0)\r\ngoto out;\r\nret = -EPERM;\r\nif (!new_idmap_permitted(file, ns, cap_setid, &new_map))\r\ngoto out;\r\nfor (idx = 0; idx < new_map.nr_extents; idx++) {\r\nu32 lower_first;\r\nextent = &new_map.extent[idx];\r\nlower_first = map_id_range_down(parent_map,\r\nextent->lower_first,\r\nextent->count);\r\nif (lower_first == (u32) -1)\r\ngoto out;\r\nextent->lower_first = lower_first;\r\n}\r\nmemcpy(map->extent, new_map.extent,\r\nnew_map.nr_extents*sizeof(new_map.extent[0]));\r\nsmp_wmb();\r\nmap->nr_extents = new_map.nr_extents;\r\n*ppos = count;\r\nret = count;\r\nout:\r\nmutex_unlock(&id_map_mutex);\r\nif (page)\r\nfree_page(page);\r\nreturn ret;\r\n}\r\nssize_t proc_uid_map_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct user_namespace *seq_ns = seq_user_ns(seq);\r\nif (!ns->parent)\r\nreturn -EPERM;\r\nif ((seq_ns != ns) && (seq_ns != ns->parent))\r\nreturn -EPERM;\r\nreturn map_write(file, buf, size, ppos, CAP_SETUID,\r\n&ns->uid_map, &ns->parent->uid_map);\r\n}\r\nssize_t proc_gid_map_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct user_namespace *seq_ns = seq_user_ns(seq);\r\nif (!ns->parent)\r\nreturn -EPERM;\r\nif ((seq_ns != ns) && (seq_ns != ns->parent))\r\nreturn -EPERM;\r\nreturn map_write(file, buf, size, ppos, CAP_SETGID,\r\n&ns->gid_map, &ns->parent->gid_map);\r\n}\r\nssize_t proc_projid_map_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct user_namespace *seq_ns = seq_user_ns(seq);\r\nif (!ns->parent)\r\nreturn -EPERM;\r\nif ((seq_ns != ns) && (seq_ns != ns->parent))\r\nreturn -EPERM;\r\nreturn map_write(file, buf, size, ppos, -1,\r\n&ns->projid_map, &ns->parent->projid_map);\r\n}\r\nstatic bool new_idmap_permitted(const struct file *file,\r\nstruct user_namespace *ns, int cap_setid,\r\nstruct uid_gid_map *new_map)\r\n{\r\nif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\r\nu32 id = new_map->extent[0].lower_first;\r\nif (cap_setid == CAP_SETUID) {\r\nkuid_t uid = make_kuid(ns->parent, id);\r\nif (uid_eq(uid, file->f_cred->fsuid))\r\nreturn true;\r\n} else if (cap_setid == CAP_SETGID) {\r\nkgid_t gid = make_kgid(ns->parent, id);\r\nif (gid_eq(gid, file->f_cred->fsgid))\r\nreturn true;\r\n}\r\n}\r\nif (!cap_valid(cap_setid))\r\nreturn true;\r\nif (ns_capable(ns->parent, cap_setid) &&\r\nfile_ns_capable(file, ns->parent, cap_setid))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void *userns_get(struct task_struct *task)\r\n{\r\nstruct user_namespace *user_ns;\r\nrcu_read_lock();\r\nuser_ns = get_user_ns(__task_cred(task)->user_ns);\r\nrcu_read_unlock();\r\nreturn user_ns;\r\n}\r\nstatic void userns_put(void *ns)\r\n{\r\nput_user_ns(ns);\r\n}\r\nstatic int userns_install(struct nsproxy *nsproxy, void *ns)\r\n{\r\nstruct user_namespace *user_ns = ns;\r\nstruct cred *cred;\r\nif (user_ns == current_user_ns())\r\nreturn -EINVAL;\r\nif (atomic_read(&current->mm->mm_users) > 1)\r\nreturn -EINVAL;\r\nif (current->fs->users != 1)\r\nreturn -EINVAL;\r\nif (!ns_capable(user_ns, CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ncred = prepare_creds();\r\nif (!cred)\r\nreturn -ENOMEM;\r\nput_user_ns(cred->user_ns);\r\nset_cred_user_ns(cred, get_user_ns(user_ns));\r\nreturn commit_creds(cred);\r\n}\r\nstatic unsigned int userns_inum(void *ns)\r\n{\r\nstruct user_namespace *user_ns = ns;\r\nreturn user_ns->proc_inum;\r\n}\r\nstatic __init int user_namespaces_init(void)\r\n{\r\nuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC);\r\nreturn 0;\r\n}
