static bool nft_rbtree_lookup(const struct nft_set *set,\r\nconst struct nft_data *key,\r\nstruct nft_data *data)\r\n{\r\nconst struct nft_rbtree *priv = nft_set_priv(set);\r\nconst struct nft_rbtree_elem *rbe, *interval = NULL;\r\nconst struct rb_node *parent = priv->root.rb_node;\r\nint d;\r\nspin_lock_bh(&nft_rbtree_lock);\r\nwhile (parent != NULL) {\r\nrbe = rb_entry(parent, struct nft_rbtree_elem, node);\r\nd = nft_data_cmp(&rbe->key, key, set->klen);\r\nif (d < 0) {\r\nparent = parent->rb_left;\r\ninterval = rbe;\r\n} else if (d > 0)\r\nparent = parent->rb_right;\r\nelse {\r\nfound:\r\nif (rbe->flags & NFT_SET_ELEM_INTERVAL_END)\r\ngoto out;\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_copy(data, rbe->data);\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn true;\r\n}\r\n}\r\nif (set->flags & NFT_SET_INTERVAL && interval != NULL) {\r\nrbe = interval;\r\ngoto found;\r\n}\r\nout:\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn false;\r\n}\r\nstatic void nft_rbtree_elem_destroy(const struct nft_set *set,\r\nstruct nft_rbtree_elem *rbe)\r\n{\r\nnft_data_uninit(&rbe->key, NFT_DATA_VALUE);\r\nif (set->flags & NFT_SET_MAP &&\r\n!(rbe->flags & NFT_SET_ELEM_INTERVAL_END))\r\nnft_data_uninit(rbe->data, set->dtype);\r\nkfree(rbe);\r\n}\r\nstatic int __nft_rbtree_insert(const struct nft_set *set,\r\nstruct nft_rbtree_elem *new)\r\n{\r\nstruct nft_rbtree *priv = nft_set_priv(set);\r\nstruct nft_rbtree_elem *rbe;\r\nstruct rb_node *parent, **p;\r\nint d;\r\nparent = NULL;\r\np = &priv->root.rb_node;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nrbe = rb_entry(parent, struct nft_rbtree_elem, node);\r\nd = nft_data_cmp(&rbe->key, &new->key, set->klen);\r\nif (d < 0)\r\np = &parent->rb_left;\r\nelse if (d > 0)\r\np = &parent->rb_right;\r\nelse\r\nreturn -EEXIST;\r\n}\r\nrb_link_node(&new->node, parent, p);\r\nrb_insert_color(&new->node, &priv->root);\r\nreturn 0;\r\n}\r\nstatic int nft_rbtree_insert(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_rbtree_elem *rbe;\r\nunsigned int size;\r\nint err;\r\nsize = sizeof(*rbe);\r\nif (set->flags & NFT_SET_MAP &&\r\n!(elem->flags & NFT_SET_ELEM_INTERVAL_END))\r\nsize += sizeof(rbe->data[0]);\r\nrbe = kzalloc(size, GFP_KERNEL);\r\nif (rbe == NULL)\r\nreturn -ENOMEM;\r\nrbe->flags = elem->flags;\r\nnft_data_copy(&rbe->key, &elem->key);\r\nif (set->flags & NFT_SET_MAP &&\r\n!(rbe->flags & NFT_SET_ELEM_INTERVAL_END))\r\nnft_data_copy(rbe->data, &elem->data);\r\nspin_lock_bh(&nft_rbtree_lock);\r\nerr = __nft_rbtree_insert(set, rbe);\r\nif (err < 0)\r\nkfree(rbe);\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn err;\r\n}\r\nstatic void nft_rbtree_remove(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_rbtree *priv = nft_set_priv(set);\r\nstruct nft_rbtree_elem *rbe = elem->cookie;\r\nspin_lock_bh(&nft_rbtree_lock);\r\nrb_erase(&rbe->node, &priv->root);\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nkfree(rbe);\r\n}\r\nstatic int nft_rbtree_get(const struct nft_set *set, struct nft_set_elem *elem)\r\n{\r\nconst struct nft_rbtree *priv = nft_set_priv(set);\r\nconst struct rb_node *parent = priv->root.rb_node;\r\nstruct nft_rbtree_elem *rbe;\r\nint d;\r\nspin_lock_bh(&nft_rbtree_lock);\r\nwhile (parent != NULL) {\r\nrbe = rb_entry(parent, struct nft_rbtree_elem, node);\r\nd = nft_data_cmp(&rbe->key, &elem->key, set->klen);\r\nif (d < 0)\r\nparent = parent->rb_left;\r\nelse if (d > 0)\r\nparent = parent->rb_right;\r\nelse {\r\nelem->cookie = rbe;\r\nif (set->flags & NFT_SET_MAP &&\r\n!(rbe->flags & NFT_SET_ELEM_INTERVAL_END))\r\nnft_data_copy(&elem->data, rbe->data);\r\nelem->flags = rbe->flags;\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn -ENOENT;\r\n}\r\nstatic void nft_rbtree_walk(const struct nft_ctx *ctx,\r\nconst struct nft_set *set,\r\nstruct nft_set_iter *iter)\r\n{\r\nconst struct nft_rbtree *priv = nft_set_priv(set);\r\nconst struct nft_rbtree_elem *rbe;\r\nstruct nft_set_elem elem;\r\nstruct rb_node *node;\r\nspin_lock_bh(&nft_rbtree_lock);\r\nfor (node = rb_first(&priv->root); node != NULL; node = rb_next(node)) {\r\nif (iter->count < iter->skip)\r\ngoto cont;\r\nrbe = rb_entry(node, struct nft_rbtree_elem, node);\r\nnft_data_copy(&elem.key, &rbe->key);\r\nif (set->flags & NFT_SET_MAP &&\r\n!(rbe->flags & NFT_SET_ELEM_INTERVAL_END))\r\nnft_data_copy(&elem.data, rbe->data);\r\nelem.flags = rbe->flags;\r\niter->err = iter->fn(ctx, set, iter, &elem);\r\nif (iter->err < 0) {\r\nspin_unlock_bh(&nft_rbtree_lock);\r\nreturn;\r\n}\r\ncont:\r\niter->count++;\r\n}\r\nspin_unlock_bh(&nft_rbtree_lock);\r\n}\r\nstatic unsigned int nft_rbtree_privsize(const struct nlattr * const nla[])\r\n{\r\nreturn sizeof(struct nft_rbtree);\r\n}\r\nstatic int nft_rbtree_init(const struct nft_set *set,\r\nconst struct nft_set_desc *desc,\r\nconst struct nlattr * const nla[])\r\n{\r\nstruct nft_rbtree *priv = nft_set_priv(set);\r\npriv->root = RB_ROOT;\r\nreturn 0;\r\n}\r\nstatic void nft_rbtree_destroy(const struct nft_set *set)\r\n{\r\nstruct nft_rbtree *priv = nft_set_priv(set);\r\nstruct nft_rbtree_elem *rbe;\r\nstruct rb_node *node;\r\nwhile ((node = priv->root.rb_node) != NULL) {\r\nrb_erase(node, &priv->root);\r\nrbe = rb_entry(node, struct nft_rbtree_elem, node);\r\nnft_rbtree_elem_destroy(set, rbe);\r\n}\r\n}\r\nstatic bool nft_rbtree_estimate(const struct nft_set_desc *desc, u32 features,\r\nstruct nft_set_estimate *est)\r\n{\r\nunsigned int nsize;\r\nnsize = sizeof(struct nft_rbtree_elem);\r\nif (features & NFT_SET_MAP)\r\nnsize += FIELD_SIZEOF(struct nft_rbtree_elem, data[0]);\r\nif (desc->size)\r\nest->size = sizeof(struct nft_rbtree) + desc->size * nsize;\r\nelse\r\nest->size = nsize;\r\nest->class = NFT_SET_CLASS_O_LOG_N;\r\nreturn true;\r\n}\r\nstatic int __init nft_rbtree_module_init(void)\r\n{\r\nreturn nft_register_set(&nft_rbtree_ops);\r\n}\r\nstatic void __exit nft_rbtree_module_exit(void)\r\n{\r\nnft_unregister_set(&nft_rbtree_ops);\r\n}
