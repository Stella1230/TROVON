static inline size_t buffer_size(struct persistent_ram_zone *prz)\r\n{\r\nreturn atomic_read(&prz->buffer->size);\r\n}\r\nstatic inline size_t buffer_start(struct persistent_ram_zone *prz)\r\n{\r\nreturn atomic_read(&prz->buffer->start);\r\n}\r\nstatic size_t buffer_start_add_atomic(struct persistent_ram_zone *prz, size_t a)\r\n{\r\nint old;\r\nint new;\r\ndo {\r\nold = atomic_read(&prz->buffer->start);\r\nnew = old + a;\r\nwhile (unlikely(new >= prz->buffer_size))\r\nnew -= prz->buffer_size;\r\n} while (atomic_cmpxchg(&prz->buffer->start, old, new) != old);\r\nreturn old;\r\n}\r\nstatic void buffer_size_add_atomic(struct persistent_ram_zone *prz, size_t a)\r\n{\r\nsize_t old;\r\nsize_t new;\r\nif (atomic_read(&prz->buffer->size) == prz->buffer_size)\r\nreturn;\r\ndo {\r\nold = atomic_read(&prz->buffer->size);\r\nnew = old + a;\r\nif (new > prz->buffer_size)\r\nnew = prz->buffer_size;\r\n} while (atomic_cmpxchg(&prz->buffer->size, old, new) != old);\r\n}\r\nstatic size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)\r\n{\r\nint old;\r\nint new;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&buffer_lock, flags);\r\nold = atomic_read(&prz->buffer->start);\r\nnew = old + a;\r\nwhile (unlikely(new >= prz->buffer_size))\r\nnew -= prz->buffer_size;\r\natomic_set(&prz->buffer->start, new);\r\nraw_spin_unlock_irqrestore(&buffer_lock, flags);\r\nreturn old;\r\n}\r\nstatic void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)\r\n{\r\nsize_t old;\r\nsize_t new;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&buffer_lock, flags);\r\nold = atomic_read(&prz->buffer->size);\r\nif (old == prz->buffer_size)\r\ngoto exit;\r\nnew = old + a;\r\nif (new > prz->buffer_size)\r\nnew = prz->buffer_size;\r\natomic_set(&prz->buffer->size, new);\r\nexit:\r\nraw_spin_unlock_irqrestore(&buffer_lock, flags);\r\n}\r\nstatic void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,\r\nuint8_t *data, size_t len, uint8_t *ecc)\r\n{\r\nint i;\r\nuint16_t par[prz->ecc_info.ecc_size];\r\nmemset(par, 0, sizeof(par));\r\nencode_rs8(prz->rs_decoder, data, len, par, 0);\r\nfor (i = 0; i < prz->ecc_info.ecc_size; i++)\r\necc[i] = par[i];\r\n}\r\nstatic int persistent_ram_decode_rs8(struct persistent_ram_zone *prz,\r\nvoid *data, size_t len, uint8_t *ecc)\r\n{\r\nint i;\r\nuint16_t par[prz->ecc_info.ecc_size];\r\nfor (i = 0; i < prz->ecc_info.ecc_size; i++)\r\npar[i] = ecc[i];\r\nreturn decode_rs8(prz->rs_decoder, data, par, len,\r\nNULL, 0, NULL, 0, NULL);\r\n}\r\nstatic void notrace persistent_ram_update_ecc(struct persistent_ram_zone *prz,\r\nunsigned int start, unsigned int count)\r\n{\r\nstruct persistent_ram_buffer *buffer = prz->buffer;\r\nuint8_t *buffer_end = buffer->data + prz->buffer_size;\r\nuint8_t *block;\r\nuint8_t *par;\r\nint ecc_block_size = prz->ecc_info.block_size;\r\nint ecc_size = prz->ecc_info.ecc_size;\r\nint size = ecc_block_size;\r\nif (!ecc_size)\r\nreturn;\r\nblock = buffer->data + (start & ~(ecc_block_size - 1));\r\npar = prz->par_buffer + (start / ecc_block_size) * ecc_size;\r\ndo {\r\nif (block + ecc_block_size > buffer_end)\r\nsize = buffer_end - block;\r\npersistent_ram_encode_rs8(prz, block, size, par);\r\nblock += ecc_block_size;\r\npar += ecc_size;\r\n} while (block < buffer->data + start + count);\r\n}\r\nstatic void persistent_ram_update_header_ecc(struct persistent_ram_zone *prz)\r\n{\r\nstruct persistent_ram_buffer *buffer = prz->buffer;\r\nif (!prz->ecc_info.ecc_size)\r\nreturn;\r\npersistent_ram_encode_rs8(prz, (uint8_t *)buffer, sizeof(*buffer),\r\nprz->par_header);\r\n}\r\nstatic void persistent_ram_ecc_old(struct persistent_ram_zone *prz)\r\n{\r\nstruct persistent_ram_buffer *buffer = prz->buffer;\r\nuint8_t *block;\r\nuint8_t *par;\r\nif (!prz->ecc_info.ecc_size)\r\nreturn;\r\nblock = buffer->data;\r\npar = prz->par_buffer;\r\nwhile (block < buffer->data + buffer_size(prz)) {\r\nint numerr;\r\nint size = prz->ecc_info.block_size;\r\nif (block + size > buffer->data + prz->buffer_size)\r\nsize = buffer->data + prz->buffer_size - block;\r\nnumerr = persistent_ram_decode_rs8(prz, block, size, par);\r\nif (numerr > 0) {\r\npr_devel("error in block %p, %d\n", block, numerr);\r\nprz->corrected_bytes += numerr;\r\n} else if (numerr < 0) {\r\npr_devel("uncorrectable error in block %p\n", block);\r\nprz->bad_blocks++;\r\n}\r\nblock += prz->ecc_info.block_size;\r\npar += prz->ecc_info.ecc_size;\r\n}\r\n}\r\nstatic int persistent_ram_init_ecc(struct persistent_ram_zone *prz,\r\nstruct persistent_ram_ecc_info *ecc_info)\r\n{\r\nint numerr;\r\nstruct persistent_ram_buffer *buffer = prz->buffer;\r\nint ecc_blocks;\r\nsize_t ecc_total;\r\nif (!ecc_info || !ecc_info->ecc_size)\r\nreturn 0;\r\nprz->ecc_info.block_size = ecc_info->block_size ?: 128;\r\nprz->ecc_info.ecc_size = ecc_info->ecc_size ?: 16;\r\nprz->ecc_info.symsize = ecc_info->symsize ?: 8;\r\nprz->ecc_info.poly = ecc_info->poly ?: 0x11d;\r\necc_blocks = DIV_ROUND_UP(prz->buffer_size - prz->ecc_info.ecc_size,\r\nprz->ecc_info.block_size +\r\nprz->ecc_info.ecc_size);\r\necc_total = (ecc_blocks + 1) * prz->ecc_info.ecc_size;\r\nif (ecc_total >= prz->buffer_size) {\r\npr_err("%s: invalid ecc_size %u (total %zu, buffer size %zu)\n",\r\n__func__, prz->ecc_info.ecc_size,\r\necc_total, prz->buffer_size);\r\nreturn -EINVAL;\r\n}\r\nprz->buffer_size -= ecc_total;\r\nprz->par_buffer = buffer->data + prz->buffer_size;\r\nprz->par_header = prz->par_buffer +\r\necc_blocks * prz->ecc_info.ecc_size;\r\nprz->rs_decoder = init_rs(prz->ecc_info.symsize, prz->ecc_info.poly,\r\n0, 1, prz->ecc_info.ecc_size);\r\nif (prz->rs_decoder == NULL) {\r\npr_info("init_rs failed\n");\r\nreturn -EINVAL;\r\n}\r\nprz->corrected_bytes = 0;\r\nprz->bad_blocks = 0;\r\nnumerr = persistent_ram_decode_rs8(prz, buffer, sizeof(*buffer),\r\nprz->par_header);\r\nif (numerr > 0) {\r\npr_info("error in header, %d\n", numerr);\r\nprz->corrected_bytes += numerr;\r\n} else if (numerr < 0) {\r\npr_info("uncorrectable error in header\n");\r\nprz->bad_blocks++;\r\n}\r\nreturn 0;\r\n}\r\nssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,\r\nchar *str, size_t len)\r\n{\r\nssize_t ret;\r\nif (!prz->ecc_info.ecc_size)\r\nreturn 0;\r\nif (prz->corrected_bytes || prz->bad_blocks)\r\nret = snprintf(str, len, ""\r\n"\n%d Corrected bytes, %d unrecoverable blocks\n",\r\nprz->corrected_bytes, prz->bad_blocks);\r\nelse\r\nret = snprintf(str, len, "\nNo errors detected\n");\r\nreturn ret;\r\n}\r\nstatic void notrace persistent_ram_update(struct persistent_ram_zone *prz,\r\nconst void *s, unsigned int start, unsigned int count)\r\n{\r\nstruct persistent_ram_buffer *buffer = prz->buffer;\r\nmemcpy(buffer->data + start, s, count);\r\npersistent_ram_update_ecc(prz, start, count);\r\n}\r\nvoid persistent_ram_save_old(struct persistent_ram_zone *prz)\r\n{\r\nstruct persistent_ram_buffer *buffer = prz->buffer;\r\nsize_t size = buffer_size(prz);\r\nsize_t start = buffer_start(prz);\r\nif (!size)\r\nreturn;\r\nif (!prz->old_log) {\r\npersistent_ram_ecc_old(prz);\r\nprz->old_log = kmalloc(size, GFP_KERNEL);\r\n}\r\nif (!prz->old_log) {\r\npr_err("failed to allocate buffer\n");\r\nreturn;\r\n}\r\nprz->old_log_size = size;\r\nmemcpy(prz->old_log, &buffer->data[start], size - start);\r\nmemcpy(prz->old_log + size - start, &buffer->data[0], start);\r\n}\r\nint notrace persistent_ram_write(struct persistent_ram_zone *prz,\r\nconst void *s, unsigned int count)\r\n{\r\nint rem;\r\nint c = count;\r\nsize_t start;\r\nif (unlikely(c > prz->buffer_size)) {\r\ns += c - prz->buffer_size;\r\nc = prz->buffer_size;\r\n}\r\nbuffer_size_add(prz, c);\r\nstart = buffer_start_add(prz, c);\r\nrem = prz->buffer_size - start;\r\nif (unlikely(rem < c)) {\r\npersistent_ram_update(prz, s, start, rem);\r\ns += rem;\r\nc -= rem;\r\nstart = 0;\r\n}\r\npersistent_ram_update(prz, s, start, c);\r\npersistent_ram_update_header_ecc(prz);\r\nreturn count;\r\n}\r\nsize_t persistent_ram_old_size(struct persistent_ram_zone *prz)\r\n{\r\nreturn prz->old_log_size;\r\n}\r\nvoid *persistent_ram_old(struct persistent_ram_zone *prz)\r\n{\r\nreturn prz->old_log;\r\n}\r\nvoid persistent_ram_free_old(struct persistent_ram_zone *prz)\r\n{\r\nkfree(prz->old_log);\r\nprz->old_log = NULL;\r\nprz->old_log_size = 0;\r\n}\r\nvoid persistent_ram_zap(struct persistent_ram_zone *prz)\r\n{\r\natomic_set(&prz->buffer->start, 0);\r\natomic_set(&prz->buffer->size, 0);\r\npersistent_ram_update_header_ecc(prz);\r\n}\r\nstatic void *persistent_ram_vmap(phys_addr_t start, size_t size)\r\n{\r\nstruct page **pages;\r\nphys_addr_t page_start;\r\nunsigned int page_count;\r\npgprot_t prot;\r\nunsigned int i;\r\nvoid *vaddr;\r\npage_start = start - offset_in_page(start);\r\npage_count = DIV_ROUND_UP(size + offset_in_page(start), PAGE_SIZE);\r\nprot = pgprot_noncached(PAGE_KERNEL);\r\npages = kmalloc_array(page_count, sizeof(struct page *), GFP_KERNEL);\r\nif (!pages) {\r\npr_err("%s: Failed to allocate array for %u pages\n",\r\n__func__, page_count);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < page_count; i++) {\r\nphys_addr_t addr = page_start + i * PAGE_SIZE;\r\npages[i] = pfn_to_page(addr >> PAGE_SHIFT);\r\n}\r\nvaddr = vmap(pages, page_count, VM_MAP, prot);\r\nkfree(pages);\r\nreturn vaddr;\r\n}\r\nstatic void *persistent_ram_iomap(phys_addr_t start, size_t size)\r\n{\r\nif (!request_mem_region(start, size, "persistent_ram")) {\r\npr_err("request mem region (0x%llx@0x%llx) failed\n",\r\n(unsigned long long)size, (unsigned long long)start);\r\nreturn NULL;\r\n}\r\nbuffer_start_add = buffer_start_add_locked;\r\nbuffer_size_add = buffer_size_add_locked;\r\nreturn ioremap(start, size);\r\n}\r\nstatic int persistent_ram_buffer_map(phys_addr_t start, phys_addr_t size,\r\nstruct persistent_ram_zone *prz)\r\n{\r\nprz->paddr = start;\r\nprz->size = size;\r\nif (pfn_valid(start >> PAGE_SHIFT))\r\nprz->vaddr = persistent_ram_vmap(start, size);\r\nelse\r\nprz->vaddr = persistent_ram_iomap(start, size);\r\nif (!prz->vaddr) {\r\npr_err("%s: Failed to map 0x%llx pages at 0x%llx\n", __func__,\r\n(unsigned long long)size, (unsigned long long)start);\r\nreturn -ENOMEM;\r\n}\r\nprz->buffer = prz->vaddr + offset_in_page(start);\r\nprz->buffer_size = size - sizeof(struct persistent_ram_buffer);\r\nreturn 0;\r\n}\r\nstatic int persistent_ram_post_init(struct persistent_ram_zone *prz, u32 sig,\r\nstruct persistent_ram_ecc_info *ecc_info)\r\n{\r\nint ret;\r\nret = persistent_ram_init_ecc(prz, ecc_info);\r\nif (ret)\r\nreturn ret;\r\nsig ^= PERSISTENT_RAM_SIG;\r\nif (prz->buffer->sig == sig) {\r\nif (buffer_size(prz) > prz->buffer_size ||\r\nbuffer_start(prz) > buffer_size(prz))\r\npr_info("found existing invalid buffer, size %zu, start %zu\n",\r\nbuffer_size(prz), buffer_start(prz));\r\nelse {\r\npr_debug("found existing buffer, size %zu, start %zu\n",\r\nbuffer_size(prz), buffer_start(prz));\r\npersistent_ram_save_old(prz);\r\nreturn 0;\r\n}\r\n} else {\r\npr_debug("no valid data in buffer (sig = 0x%08x)\n",\r\nprz->buffer->sig);\r\n}\r\nprz->buffer->sig = sig;\r\npersistent_ram_zap(prz);\r\nreturn 0;\r\n}\r\nvoid persistent_ram_free(struct persistent_ram_zone *prz)\r\n{\r\nif (!prz)\r\nreturn;\r\nif (prz->vaddr) {\r\nif (pfn_valid(prz->paddr >> PAGE_SHIFT)) {\r\nvunmap(prz->vaddr);\r\n} else {\r\niounmap(prz->vaddr);\r\nrelease_mem_region(prz->paddr, prz->size);\r\n}\r\nprz->vaddr = NULL;\r\n}\r\npersistent_ram_free_old(prz);\r\nkfree(prz);\r\n}\r\nstruct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,\r\nu32 sig, struct persistent_ram_ecc_info *ecc_info)\r\n{\r\nstruct persistent_ram_zone *prz;\r\nint ret = -ENOMEM;\r\nprz = kzalloc(sizeof(struct persistent_ram_zone), GFP_KERNEL);\r\nif (!prz) {\r\npr_err("failed to allocate persistent ram zone\n");\r\ngoto err;\r\n}\r\nret = persistent_ram_buffer_map(start, size, prz);\r\nif (ret)\r\ngoto err;\r\nret = persistent_ram_post_init(prz, sig, ecc_info);\r\nif (ret)\r\ngoto err;\r\nreturn prz;\r\nerr:\r\npersistent_ram_free(prz);\r\nreturn ERR_PTR(ret);\r\n}
