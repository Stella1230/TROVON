static inline struct pfkey_sock *pfkey_sk(struct sock *sk)\r\n{\r\nreturn (struct pfkey_sock *)sk;\r\n}\r\nstatic int pfkey_can_dump(const struct sock *sk)\r\n{\r\nif (3 * atomic_read(&sk->sk_rmem_alloc) <= 2 * sk->sk_rcvbuf)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void pfkey_terminate_dump(struct pfkey_sock *pfk)\r\n{\r\nif (pfk->dump.dump) {\r\nif (pfk->dump.skb) {\r\nkfree_skb(pfk->dump.skb);\r\npfk->dump.skb = NULL;\r\n}\r\npfk->dump.done(pfk);\r\npfk->dump.dump = NULL;\r\npfk->dump.done = NULL;\r\n}\r\n}\r\nstatic void pfkey_sock_destruct(struct sock *sk)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\npfkey_terminate_dump(pfkey_sk(sk));\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\npr_err("Attempt to release alive pfkey socket: %p\n", sk);\r\nreturn;\r\n}\r\nWARN_ON(atomic_read(&sk->sk_rmem_alloc));\r\nWARN_ON(atomic_read(&sk->sk_wmem_alloc));\r\natomic_dec(&net_pfkey->socks_nr);\r\n}\r\nstatic void pfkey_insert(struct sock *sk)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\nmutex_lock(&pfkey_mutex);\r\nsk_add_node_rcu(sk, &net_pfkey->table);\r\nmutex_unlock(&pfkey_mutex);\r\n}\r\nstatic void pfkey_remove(struct sock *sk)\r\n{\r\nmutex_lock(&pfkey_mutex);\r\nsk_del_node_init_rcu(sk);\r\nmutex_unlock(&pfkey_mutex);\r\n}\r\nstatic int pfkey_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\nstruct sock *sk;\r\nint err;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (sock->type != SOCK_RAW)\r\nreturn -ESOCKTNOSUPPORT;\r\nif (protocol != PF_KEY_V2)\r\nreturn -EPROTONOSUPPORT;\r\nerr = -ENOMEM;\r\nsk = sk_alloc(net, PF_KEY, GFP_KERNEL, &key_proto);\r\nif (sk == NULL)\r\ngoto out;\r\nsock->ops = &pfkey_ops;\r\nsock_init_data(sock, sk);\r\nsk->sk_family = PF_KEY;\r\nsk->sk_destruct = pfkey_sock_destruct;\r\natomic_inc(&net_pfkey->socks_nr);\r\npfkey_insert(sk);\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int pfkey_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (!sk)\r\nreturn 0;\r\npfkey_remove(sk);\r\nsock_orphan(sk);\r\nsock->sk = NULL;\r\nskb_queue_purge(&sk->sk_write_queue);\r\nsynchronize_rcu();\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,\r\ngfp_t allocation, struct sock *sk)\r\n{\r\nint err = -ENOBUFS;\r\nsock_hold(sk);\r\nif (*skb2 == NULL) {\r\nif (atomic_read(&skb->users) != 1) {\r\n*skb2 = skb_clone(skb, allocation);\r\n} else {\r\n*skb2 = skb;\r\natomic_inc(&skb->users);\r\n}\r\n}\r\nif (*skb2 != NULL) {\r\nif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf) {\r\nskb_set_owner_r(*skb2, sk);\r\nskb_queue_tail(&sk->sk_receive_queue, *skb2);\r\nsk->sk_data_ready(sk);\r\n*skb2 = NULL;\r\nerr = 0;\r\n}\r\n}\r\nsock_put(sk);\r\nreturn err;\r\n}\r\nstatic int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,\r\nint broadcast_flags, struct sock *one_sk,\r\nstruct net *net)\r\n{\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\nstruct sock *sk;\r\nstruct sk_buff *skb2 = NULL;\r\nint err = -ESRCH;\r\nif (!skb)\r\nreturn -ENOMEM;\r\nrcu_read_lock();\r\nsk_for_each_rcu(sk, &net_pfkey->table) {\r\nstruct pfkey_sock *pfk = pfkey_sk(sk);\r\nint err2;\r\nif (pfk->promisc)\r\npfkey_broadcast_one(skb, &skb2, allocation, sk);\r\nif (sk == one_sk)\r\ncontinue;\r\nif (broadcast_flags != BROADCAST_ALL) {\r\nif (broadcast_flags & BROADCAST_PROMISC_ONLY)\r\ncontinue;\r\nif ((broadcast_flags & BROADCAST_REGISTERED) &&\r\n!pfk->registered)\r\ncontinue;\r\nif (broadcast_flags & BROADCAST_ONE)\r\ncontinue;\r\n}\r\nerr2 = pfkey_broadcast_one(skb, &skb2, allocation, sk);\r\nif ((broadcast_flags & BROADCAST_REGISTERED) && err)\r\nerr = err2;\r\n}\r\nrcu_read_unlock();\r\nif (one_sk != NULL)\r\nerr = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);\r\nkfree_skb(skb2);\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int pfkey_do_dump(struct pfkey_sock *pfk)\r\n{\r\nstruct sadb_msg *hdr;\r\nint rc;\r\nrc = pfk->dump.dump(pfk);\r\nif (rc == -ENOBUFS)\r\nreturn 0;\r\nif (pfk->dump.skb) {\r\nif (!pfkey_can_dump(&pfk->sk))\r\nreturn 0;\r\nhdr = (struct sadb_msg *) pfk->dump.skb->data;\r\nhdr->sadb_msg_seq = 0;\r\nhdr->sadb_msg_errno = rc;\r\npfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\r\n&pfk->sk, sock_net(&pfk->sk));\r\npfk->dump.skb = NULL;\r\n}\r\npfkey_terminate_dump(pfk);\r\nreturn rc;\r\n}\r\nstatic inline void pfkey_hdr_dup(struct sadb_msg *new,\r\nconst struct sadb_msg *orig)\r\n{\r\n*new = *orig;\r\n}\r\nstatic int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)\r\n{\r\nstruct sk_buff *skb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_KERNEL);\r\nstruct sadb_msg *hdr;\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nerr = -err;\r\nif (err == ERESTARTSYS ||\r\nerr == ERESTARTNOHAND ||\r\nerr == ERESTARTNOINTR)\r\nerr = EINTR;\r\nif (err >= 512)\r\nerr = EINVAL;\r\nBUG_ON(err <= 0 || err >= 256);\r\nhdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\r\npfkey_hdr_dup(hdr, orig);\r\nhdr->sadb_msg_errno = (uint8_t) err;\r\nhdr->sadb_msg_len = (sizeof(struct sadb_msg) /\r\nsizeof(uint64_t));\r\npfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));\r\nreturn 0;\r\n}\r\nstatic int verify_address_len(const void *p)\r\n{\r\nconst struct sadb_address *sp = p;\r\nconst struct sockaddr *addr = (const struct sockaddr *)(sp + 1);\r\nconst struct sockaddr_in *sin;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nconst struct sockaddr_in6 *sin6;\r\n#endif\r\nint len;\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\nlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin), sizeof(uint64_t));\r\nif (sp->sadb_address_len != len ||\r\nsp->sadb_address_prefixlen > 32)\r\nreturn -EINVAL;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nlen = DIV_ROUND_UP(sizeof(*sp) + sizeof(*sin6), sizeof(uint64_t));\r\nif (sp->sadb_address_len != len ||\r\nsp->sadb_address_prefixlen > 128)\r\nreturn -EINVAL;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int pfkey_sec_ctx_len(const struct sadb_x_sec_ctx *sec_ctx)\r\n{\r\nreturn DIV_ROUND_UP(sizeof(struct sadb_x_sec_ctx) +\r\nsec_ctx->sadb_x_ctx_len,\r\nsizeof(uint64_t));\r\n}\r\nstatic inline int verify_sec_ctx_len(const void *p)\r\n{\r\nconst struct sadb_x_sec_ctx *sec_ctx = p;\r\nint len = sec_ctx->sadb_x_ctx_len;\r\nif (len > PAGE_SIZE)\r\nreturn -EINVAL;\r\nlen = pfkey_sec_ctx_len(sec_ctx);\r\nif (sec_ctx->sadb_x_sec_len != len)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline struct xfrm_user_sec_ctx *pfkey_sadb2xfrm_user_sec_ctx(const struct sadb_x_sec_ctx *sec_ctx,\r\ngfp_t gfp)\r\n{\r\nstruct xfrm_user_sec_ctx *uctx = NULL;\r\nint ctx_size = sec_ctx->sadb_x_ctx_len;\r\nuctx = kmalloc((sizeof(*uctx)+ctx_size), gfp);\r\nif (!uctx)\r\nreturn NULL;\r\nuctx->len = pfkey_sec_ctx_len(sec_ctx);\r\nuctx->exttype = sec_ctx->sadb_x_sec_exttype;\r\nuctx->ctx_doi = sec_ctx->sadb_x_ctx_doi;\r\nuctx->ctx_alg = sec_ctx->sadb_x_ctx_alg;\r\nuctx->ctx_len = sec_ctx->sadb_x_ctx_len;\r\nmemcpy(uctx + 1, sec_ctx + 1,\r\nuctx->ctx_len);\r\nreturn uctx;\r\n}\r\nstatic int present_and_same_family(const struct sadb_address *src,\r\nconst struct sadb_address *dst)\r\n{\r\nconst struct sockaddr *s_addr, *d_addr;\r\nif (!src || !dst)\r\nreturn 0;\r\ns_addr = (const struct sockaddr *)(src + 1);\r\nd_addr = (const struct sockaddr *)(dst + 1);\r\nif (s_addr->sa_family != d_addr->sa_family)\r\nreturn 0;\r\nif (s_addr->sa_family != AF_INET\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n&& s_addr->sa_family != AF_INET6\r\n#endif\r\n)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int parse_exthdrs(struct sk_buff *skb, const struct sadb_msg *hdr, void **ext_hdrs)\r\n{\r\nconst char *p = (char *) hdr;\r\nint len = skb->len;\r\nlen -= sizeof(*hdr);\r\np += sizeof(*hdr);\r\nwhile (len > 0) {\r\nconst struct sadb_ext *ehdr = (const struct sadb_ext *) p;\r\nuint16_t ext_type;\r\nint ext_len;\r\next_len = ehdr->sadb_ext_len;\r\next_len *= sizeof(uint64_t);\r\next_type = ehdr->sadb_ext_type;\r\nif (ext_len < sizeof(uint64_t) ||\r\next_len > len ||\r\next_type == SADB_EXT_RESERVED)\r\nreturn -EINVAL;\r\nif (ext_type <= SADB_EXT_MAX) {\r\nint min = (int) sadb_ext_min_len[ext_type];\r\nif (ext_len < min)\r\nreturn -EINVAL;\r\nif (ext_hdrs[ext_type-1] != NULL)\r\nreturn -EINVAL;\r\nif (ext_type == SADB_EXT_ADDRESS_SRC ||\r\next_type == SADB_EXT_ADDRESS_DST ||\r\next_type == SADB_EXT_ADDRESS_PROXY ||\r\next_type == SADB_X_EXT_NAT_T_OA) {\r\nif (verify_address_len(p))\r\nreturn -EINVAL;\r\n}\r\nif (ext_type == SADB_X_EXT_SEC_CTX) {\r\nif (verify_sec_ctx_len(p))\r\nreturn -EINVAL;\r\n}\r\next_hdrs[ext_type-1] = (void *) p;\r\n}\r\np += ext_len;\r\nlen -= ext_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic uint16_t\r\npfkey_satype2proto(uint8_t satype)\r\n{\r\nswitch (satype) {\r\ncase SADB_SATYPE_UNSPEC:\r\nreturn IPSEC_PROTO_ANY;\r\ncase SADB_SATYPE_AH:\r\nreturn IPPROTO_AH;\r\ncase SADB_SATYPE_ESP:\r\nreturn IPPROTO_ESP;\r\ncase SADB_X_SATYPE_IPCOMP:\r\nreturn IPPROTO_COMP;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic uint8_t\r\npfkey_proto2satype(uint16_t proto)\r\n{\r\nswitch (proto) {\r\ncase IPPROTO_AH:\r\nreturn SADB_SATYPE_AH;\r\ncase IPPROTO_ESP:\r\nreturn SADB_SATYPE_ESP;\r\ncase IPPROTO_COMP:\r\nreturn SADB_X_SATYPE_IPCOMP;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic uint8_t pfkey_proto_to_xfrm(uint8_t proto)\r\n{\r\nreturn proto == IPSEC_PROTO_ANY ? 0 : proto;\r\n}\r\nstatic uint8_t pfkey_proto_from_xfrm(uint8_t proto)\r\n{\r\nreturn proto ? proto : IPSEC_PROTO_ANY;\r\n}\r\nstatic inline int pfkey_sockaddr_len(sa_family_t family)\r\n{\r\nswitch (family) {\r\ncase AF_INET:\r\nreturn sizeof(struct sockaddr_in);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nreturn sizeof(struct sockaddr_in6);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nint pfkey_sockaddr_extract(const struct sockaddr *sa, xfrm_address_t *xaddr)\r\n{\r\nswitch (sa->sa_family) {\r\ncase AF_INET:\r\nxaddr->a4 =\r\n((struct sockaddr_in *)sa)->sin_addr.s_addr;\r\nreturn AF_INET;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nmemcpy(xaddr->a6,\r\n&((struct sockaddr_in6 *)sa)->sin6_addr,\r\nsizeof(struct in6_addr));\r\nreturn AF_INET6;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nint pfkey_sadb_addr2xfrm_addr(const struct sadb_address *addr, xfrm_address_t *xaddr)\r\n{\r\nreturn pfkey_sockaddr_extract((struct sockaddr *)(addr + 1),\r\nxaddr);\r\n}\r\nstatic struct xfrm_state *pfkey_xfrm_state_lookup(struct net *net, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nconst struct sadb_sa *sa;\r\nconst struct sadb_address *addr;\r\nuint16_t proto;\r\nunsigned short family;\r\nxfrm_address_t *xaddr;\r\nsa = ext_hdrs[SADB_EXT_SA - 1];\r\nif (sa == NULL)\r\nreturn NULL;\r\nproto = pfkey_satype2proto(hdr->sadb_msg_satype);\r\nif (proto == 0)\r\nreturn NULL;\r\naddr = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];\r\nif (addr == NULL)\r\nreturn NULL;\r\nfamily = ((const struct sockaddr *)(addr + 1))->sa_family;\r\nswitch (family) {\r\ncase AF_INET:\r\nxaddr = (xfrm_address_t *)&((const struct sockaddr_in *)(addr + 1))->sin_addr;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nxaddr = (xfrm_address_t *)&((const struct sockaddr_in6 *)(addr + 1))->sin6_addr;\r\nbreak;\r\n#endif\r\ndefault:\r\nxaddr = NULL;\r\n}\r\nif (!xaddr)\r\nreturn NULL;\r\nreturn xfrm_state_lookup(net, DUMMY_MARK, xaddr, sa->sadb_sa_spi, proto, family);\r\n}\r\nstatic int\r\npfkey_sockaddr_size(sa_family_t family)\r\n{\r\nreturn PFKEY_ALIGN8(pfkey_sockaddr_len(family));\r\n}\r\nstatic inline int pfkey_mode_from_xfrm(int mode)\r\n{\r\nswitch(mode) {\r\ncase XFRM_MODE_TRANSPORT:\r\nreturn IPSEC_MODE_TRANSPORT;\r\ncase XFRM_MODE_TUNNEL:\r\nreturn IPSEC_MODE_TUNNEL;\r\ncase XFRM_MODE_BEET:\r\nreturn IPSEC_MODE_BEET;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic inline int pfkey_mode_to_xfrm(int mode)\r\n{\r\nswitch(mode) {\r\ncase IPSEC_MODE_ANY:\r\ncase IPSEC_MODE_TRANSPORT:\r\nreturn XFRM_MODE_TRANSPORT;\r\ncase IPSEC_MODE_TUNNEL:\r\nreturn XFRM_MODE_TUNNEL;\r\ncase IPSEC_MODE_BEET:\r\nreturn XFRM_MODE_BEET;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic unsigned int pfkey_sockaddr_fill(const xfrm_address_t *xaddr, __be16 port,\r\nstruct sockaddr *sa,\r\nunsigned short family)\r\n{\r\nswitch (family) {\r\ncase AF_INET:\r\n{\r\nstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\r\nsin->sin_family = AF_INET;\r\nsin->sin_port = port;\r\nsin->sin_addr.s_addr = xaddr->a4;\r\nmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\r\nreturn 32;\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\n{\r\nstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;\r\nsin6->sin6_family = AF_INET6;\r\nsin6->sin6_port = port;\r\nsin6->sin6_flowinfo = 0;\r\nsin6->sin6_addr = *(struct in6_addr *)xaddr->a6;\r\nsin6->sin6_scope_id = 0;\r\nreturn 128;\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *__pfkey_xfrm_state2msg(const struct xfrm_state *x,\r\nint add_keys, int hsc)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sadb_msg *hdr;\r\nstruct sadb_sa *sa;\r\nstruct sadb_lifetime *lifetime;\r\nstruct sadb_address *addr;\r\nstruct sadb_key *key;\r\nstruct sadb_x_sa2 *sa2;\r\nstruct sadb_x_sec_ctx *sec_ctx;\r\nstruct xfrm_sec_ctx *xfrm_ctx;\r\nint ctx_size = 0;\r\nint size;\r\nint auth_key_size = 0;\r\nint encrypt_key_size = 0;\r\nint sockaddr_size;\r\nstruct xfrm_encap_tmpl *natt = NULL;\r\nint mode;\r\nsockaddr_size = pfkey_sockaddr_size(x->props.family);\r\nif (!sockaddr_size)\r\nreturn ERR_PTR(-EINVAL);\r\nsize = sizeof(struct sadb_msg) +sizeof(struct sadb_sa) +\r\nsizeof(struct sadb_lifetime) +\r\n((hsc & 1) ? sizeof(struct sadb_lifetime) : 0) +\r\n((hsc & 2) ? sizeof(struct sadb_lifetime) : 0) +\r\nsizeof(struct sadb_address)*2 +\r\nsockaddr_size*2 +\r\nsizeof(struct sadb_x_sa2);\r\nif ((xfrm_ctx = x->security)) {\r\nctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\r\nsize += sizeof(struct sadb_x_sec_ctx) + ctx_size;\r\n}\r\nif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr, x->props.family))\r\nsize += sizeof(struct sadb_address) + sockaddr_size;\r\nif (add_keys) {\r\nif (x->aalg && x->aalg->alg_key_len) {\r\nauth_key_size =\r\nPFKEY_ALIGN8((x->aalg->alg_key_len + 7) / 8);\r\nsize += sizeof(struct sadb_key) + auth_key_size;\r\n}\r\nif (x->ealg && x->ealg->alg_key_len) {\r\nencrypt_key_size =\r\nPFKEY_ALIGN8((x->ealg->alg_key_len+7) / 8);\r\nsize += sizeof(struct sadb_key) + encrypt_key_size;\r\n}\r\n}\r\nif (x->encap)\r\nnatt = x->encap;\r\nif (natt && natt->encap_type) {\r\nsize += sizeof(struct sadb_x_nat_t_type);\r\nsize += sizeof(struct sadb_x_nat_t_port);\r\nsize += sizeof(struct sadb_x_nat_t_port);\r\n}\r\nskb = alloc_skb(size + 16, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn ERR_PTR(-ENOBUFS);\r\nhdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\r\nmemset(hdr, 0, size);\r\nhdr->sadb_msg_len = size / sizeof(uint64_t);\r\nsa = (struct sadb_sa *) skb_put(skb, sizeof(struct sadb_sa));\r\nsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\r\nsa->sadb_sa_exttype = SADB_EXT_SA;\r\nsa->sadb_sa_spi = x->id.spi;\r\nsa->sadb_sa_replay = x->props.replay_window;\r\nswitch (x->km.state) {\r\ncase XFRM_STATE_VALID:\r\nsa->sadb_sa_state = x->km.dying ?\r\nSADB_SASTATE_DYING : SADB_SASTATE_MATURE;\r\nbreak;\r\ncase XFRM_STATE_ACQ:\r\nsa->sadb_sa_state = SADB_SASTATE_LARVAL;\r\nbreak;\r\ndefault:\r\nsa->sadb_sa_state = SADB_SASTATE_DEAD;\r\nbreak;\r\n}\r\nsa->sadb_sa_auth = 0;\r\nif (x->aalg) {\r\nstruct xfrm_algo_desc *a = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\r\nsa->sadb_sa_auth = (a && a->pfkey_supported) ?\r\na->desc.sadb_alg_id : 0;\r\n}\r\nsa->sadb_sa_encrypt = 0;\r\nBUG_ON(x->ealg && x->calg);\r\nif (x->ealg) {\r\nstruct xfrm_algo_desc *a = xfrm_ealg_get_byname(x->ealg->alg_name, 0);\r\nsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\r\na->desc.sadb_alg_id : 0;\r\n}\r\nif (x->calg) {\r\nstruct xfrm_algo_desc *a = xfrm_calg_get_byname(x->calg->alg_name, 0);\r\nsa->sadb_sa_encrypt = (a && a->pfkey_supported) ?\r\na->desc.sadb_alg_id : 0;\r\n}\r\nsa->sadb_sa_flags = 0;\r\nif (x->props.flags & XFRM_STATE_NOECN)\r\nsa->sadb_sa_flags |= SADB_SAFLAGS_NOECN;\r\nif (x->props.flags & XFRM_STATE_DECAP_DSCP)\r\nsa->sadb_sa_flags |= SADB_SAFLAGS_DECAP_DSCP;\r\nif (x->props.flags & XFRM_STATE_NOPMTUDISC)\r\nsa->sadb_sa_flags |= SADB_SAFLAGS_NOPMTUDISC;\r\nif (hsc & 2) {\r\nlifetime = (struct sadb_lifetime *) skb_put(skb,\r\nsizeof(struct sadb_lifetime));\r\nlifetime->sadb_lifetime_len =\r\nsizeof(struct sadb_lifetime)/sizeof(uint64_t);\r\nlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\r\nlifetime->sadb_lifetime_allocations = _X2KEY(x->lft.hard_packet_limit);\r\nlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.hard_byte_limit);\r\nlifetime->sadb_lifetime_addtime = x->lft.hard_add_expires_seconds;\r\nlifetime->sadb_lifetime_usetime = x->lft.hard_use_expires_seconds;\r\n}\r\nif (hsc & 1) {\r\nlifetime = (struct sadb_lifetime *) skb_put(skb,\r\nsizeof(struct sadb_lifetime));\r\nlifetime->sadb_lifetime_len =\r\nsizeof(struct sadb_lifetime)/sizeof(uint64_t);\r\nlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\r\nlifetime->sadb_lifetime_allocations = _X2KEY(x->lft.soft_packet_limit);\r\nlifetime->sadb_lifetime_bytes = _X2KEY(x->lft.soft_byte_limit);\r\nlifetime->sadb_lifetime_addtime = x->lft.soft_add_expires_seconds;\r\nlifetime->sadb_lifetime_usetime = x->lft.soft_use_expires_seconds;\r\n}\r\nlifetime = (struct sadb_lifetime *) skb_put(skb,\r\nsizeof(struct sadb_lifetime));\r\nlifetime->sadb_lifetime_len =\r\nsizeof(struct sadb_lifetime)/sizeof(uint64_t);\r\nlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\r\nlifetime->sadb_lifetime_allocations = x->curlft.packets;\r\nlifetime->sadb_lifetime_bytes = x->curlft.bytes;\r\nlifetime->sadb_lifetime_addtime = x->curlft.add_time;\r\nlifetime->sadb_lifetime_usetime = x->curlft.use_time;\r\naddr = (struct sadb_address*) skb_put(skb,\r\nsizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\r\naddr->sadb_address_proto = 0;\r\naddr->sadb_address_reserved = 0;\r\naddr->sadb_address_prefixlen =\r\npfkey_sockaddr_fill(&x->props.saddr, 0,\r\n(struct sockaddr *) (addr + 1),\r\nx->props.family);\r\nif (!addr->sadb_address_prefixlen)\r\nBUG();\r\naddr = (struct sadb_address*) skb_put(skb,\r\nsizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\r\naddr->sadb_address_proto = 0;\r\naddr->sadb_address_reserved = 0;\r\naddr->sadb_address_prefixlen =\r\npfkey_sockaddr_fill(&x->id.daddr, 0,\r\n(struct sockaddr *) (addr + 1),\r\nx->props.family);\r\nif (!addr->sadb_address_prefixlen)\r\nBUG();\r\nif (!xfrm_addr_equal(&x->sel.saddr, &x->props.saddr,\r\nx->props.family)) {\r\naddr = (struct sadb_address*) skb_put(skb,\r\nsizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;\r\naddr->sadb_address_proto =\r\npfkey_proto_from_xfrm(x->sel.proto);\r\naddr->sadb_address_prefixlen = x->sel.prefixlen_s;\r\naddr->sadb_address_reserved = 0;\r\npfkey_sockaddr_fill(&x->sel.saddr, x->sel.sport,\r\n(struct sockaddr *) (addr + 1),\r\nx->props.family);\r\n}\r\nif (add_keys && auth_key_size) {\r\nkey = (struct sadb_key *) skb_put(skb,\r\nsizeof(struct sadb_key)+auth_key_size);\r\nkey->sadb_key_len = (sizeof(struct sadb_key) + auth_key_size) /\r\nsizeof(uint64_t);\r\nkey->sadb_key_exttype = SADB_EXT_KEY_AUTH;\r\nkey->sadb_key_bits = x->aalg->alg_key_len;\r\nkey->sadb_key_reserved = 0;\r\nmemcpy(key + 1, x->aalg->alg_key, (x->aalg->alg_key_len+7)/8);\r\n}\r\nif (add_keys && encrypt_key_size) {\r\nkey = (struct sadb_key *) skb_put(skb,\r\nsizeof(struct sadb_key)+encrypt_key_size);\r\nkey->sadb_key_len = (sizeof(struct sadb_key) +\r\nencrypt_key_size) / sizeof(uint64_t);\r\nkey->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;\r\nkey->sadb_key_bits = x->ealg->alg_key_len;\r\nkey->sadb_key_reserved = 0;\r\nmemcpy(key + 1, x->ealg->alg_key,\r\n(x->ealg->alg_key_len+7)/8);\r\n}\r\nsa2 = (struct sadb_x_sa2 *) skb_put(skb, sizeof(struct sadb_x_sa2));\r\nsa2->sadb_x_sa2_len = sizeof(struct sadb_x_sa2)/sizeof(uint64_t);\r\nsa2->sadb_x_sa2_exttype = SADB_X_EXT_SA2;\r\nif ((mode = pfkey_mode_from_xfrm(x->props.mode)) < 0) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nsa2->sadb_x_sa2_mode = mode;\r\nsa2->sadb_x_sa2_reserved1 = 0;\r\nsa2->sadb_x_sa2_reserved2 = 0;\r\nsa2->sadb_x_sa2_sequence = 0;\r\nsa2->sadb_x_sa2_reqid = x->props.reqid;\r\nif (natt && natt->encap_type) {\r\nstruct sadb_x_nat_t_type *n_type;\r\nstruct sadb_x_nat_t_port *n_port;\r\nn_type = (struct sadb_x_nat_t_type*) skb_put(skb, sizeof(*n_type));\r\nn_type->sadb_x_nat_t_type_len = sizeof(*n_type)/sizeof(uint64_t);\r\nn_type->sadb_x_nat_t_type_exttype = SADB_X_EXT_NAT_T_TYPE;\r\nn_type->sadb_x_nat_t_type_type = natt->encap_type;\r\nn_type->sadb_x_nat_t_type_reserved[0] = 0;\r\nn_type->sadb_x_nat_t_type_reserved[1] = 0;\r\nn_type->sadb_x_nat_t_type_reserved[2] = 0;\r\nn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\r\nn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\r\nn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\r\nn_port->sadb_x_nat_t_port_port = natt->encap_sport;\r\nn_port->sadb_x_nat_t_port_reserved = 0;\r\nn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\r\nn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\r\nn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\r\nn_port->sadb_x_nat_t_port_port = natt->encap_dport;\r\nn_port->sadb_x_nat_t_port_reserved = 0;\r\n}\r\nif (xfrm_ctx) {\r\nsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb,\r\nsizeof(struct sadb_x_sec_ctx) + ctx_size);\r\nsec_ctx->sadb_x_sec_len =\r\n(sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\r\nsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\r\nsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\r\nsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\r\nsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\r\nmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\r\nxfrm_ctx->ctx_len);\r\n}\r\nreturn skb;\r\n}\r\nstatic inline struct sk_buff *pfkey_xfrm_state2msg(const struct xfrm_state *x)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __pfkey_xfrm_state2msg(x, 1, 3);\r\nreturn skb;\r\n}\r\nstatic inline struct sk_buff *pfkey_xfrm_state2msg_expire(const struct xfrm_state *x,\r\nint hsc)\r\n{\r\nreturn __pfkey_xfrm_state2msg(x, 0, hsc);\r\n}\r\nstatic struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,\r\nconst struct sadb_msg *hdr,\r\nvoid * const *ext_hdrs)\r\n{\r\nstruct xfrm_state *x;\r\nconst struct sadb_lifetime *lifetime;\r\nconst struct sadb_sa *sa;\r\nconst struct sadb_key *key;\r\nconst struct sadb_x_sec_ctx *sec_ctx;\r\nuint16_t proto;\r\nint err;\r\nsa = ext_hdrs[SADB_EXT_SA - 1];\r\nif (!sa ||\r\n!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\r\next_hdrs[SADB_EXT_ADDRESS_DST-1]))\r\nreturn ERR_PTR(-EINVAL);\r\nif (hdr->sadb_msg_satype == SADB_SATYPE_ESP &&\r\n!ext_hdrs[SADB_EXT_KEY_ENCRYPT-1])\r\nreturn ERR_PTR(-EINVAL);\r\nif (hdr->sadb_msg_satype == SADB_SATYPE_AH &&\r\n!ext_hdrs[SADB_EXT_KEY_AUTH-1])\r\nreturn ERR_PTR(-EINVAL);\r\nif (!!ext_hdrs[SADB_EXT_LIFETIME_HARD-1] !=\r\n!!ext_hdrs[SADB_EXT_LIFETIME_SOFT-1])\r\nreturn ERR_PTR(-EINVAL);\r\nproto = pfkey_satype2proto(hdr->sadb_msg_satype);\r\nif (proto == 0)\r\nreturn ERR_PTR(-EINVAL);\r\nerr = -ENOBUFS;\r\nif (sa->sadb_sa_auth > SADB_AALG_MAX ||\r\n(hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP &&\r\nsa->sadb_sa_encrypt > SADB_X_CALG_MAX) ||\r\nsa->sadb_sa_encrypt > SADB_EALG_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\r\nif (key != NULL &&\r\nsa->sadb_sa_auth != SADB_X_AALG_NULL &&\r\n((key->sadb_key_bits+7) / 8 == 0 ||\r\n(key->sadb_key_bits+7) / 8 > key->sadb_key_len * sizeof(uint64_t)))\r\nreturn ERR_PTR(-EINVAL);\r\nkey = ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\r\nif (key != NULL &&\r\nsa->sadb_sa_encrypt != SADB_EALG_NULL &&\r\n((key->sadb_key_bits+7) / 8 == 0 ||\r\n(key->sadb_key_bits+7) / 8 > key->sadb_key_len * sizeof(uint64_t)))\r\nreturn ERR_PTR(-EINVAL);\r\nx = xfrm_state_alloc(net);\r\nif (x == NULL)\r\nreturn ERR_PTR(-ENOBUFS);\r\nx->id.proto = proto;\r\nx->id.spi = sa->sadb_sa_spi;\r\nx->props.replay_window = min_t(unsigned int, sa->sadb_sa_replay,\r\n(sizeof(x->replay.bitmap) * 8));\r\nif (sa->sadb_sa_flags & SADB_SAFLAGS_NOECN)\r\nx->props.flags |= XFRM_STATE_NOECN;\r\nif (sa->sadb_sa_flags & SADB_SAFLAGS_DECAP_DSCP)\r\nx->props.flags |= XFRM_STATE_DECAP_DSCP;\r\nif (sa->sadb_sa_flags & SADB_SAFLAGS_NOPMTUDISC)\r\nx->props.flags |= XFRM_STATE_NOPMTUDISC;\r\nlifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD - 1];\r\nif (lifetime != NULL) {\r\nx->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\r\nx->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\r\nx->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\r\nx->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\r\n}\r\nlifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT - 1];\r\nif (lifetime != NULL) {\r\nx->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\r\nx->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\r\nx->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\r\nx->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\r\n}\r\nsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\r\nif (sec_ctx != NULL) {\r\nstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\r\nif (!uctx)\r\ngoto out;\r\nerr = security_xfrm_state_alloc(x, uctx);\r\nkfree(uctx);\r\nif (err)\r\ngoto out;\r\n}\r\nkey = ext_hdrs[SADB_EXT_KEY_AUTH - 1];\r\nif (sa->sadb_sa_auth) {\r\nint keysize = 0;\r\nstruct xfrm_algo_desc *a = xfrm_aalg_get_byid(sa->sadb_sa_auth);\r\nif (!a || !a->pfkey_supported) {\r\nerr = -ENOSYS;\r\ngoto out;\r\n}\r\nif (key)\r\nkeysize = (key->sadb_key_bits + 7) / 8;\r\nx->aalg = kmalloc(sizeof(*x->aalg) + keysize, GFP_KERNEL);\r\nif (!x->aalg)\r\ngoto out;\r\nstrcpy(x->aalg->alg_name, a->name);\r\nx->aalg->alg_key_len = 0;\r\nif (key) {\r\nx->aalg->alg_key_len = key->sadb_key_bits;\r\nmemcpy(x->aalg->alg_key, key+1, keysize);\r\n}\r\nx->aalg->alg_trunc_len = a->uinfo.auth.icv_truncbits;\r\nx->props.aalgo = sa->sadb_sa_auth;\r\n}\r\nif (sa->sadb_sa_encrypt) {\r\nif (hdr->sadb_msg_satype == SADB_X_SATYPE_IPCOMP) {\r\nstruct xfrm_algo_desc *a = xfrm_calg_get_byid(sa->sadb_sa_encrypt);\r\nif (!a || !a->pfkey_supported) {\r\nerr = -ENOSYS;\r\ngoto out;\r\n}\r\nx->calg = kmalloc(sizeof(*x->calg), GFP_KERNEL);\r\nif (!x->calg)\r\ngoto out;\r\nstrcpy(x->calg->alg_name, a->name);\r\nx->props.calgo = sa->sadb_sa_encrypt;\r\n} else {\r\nint keysize = 0;\r\nstruct xfrm_algo_desc *a = xfrm_ealg_get_byid(sa->sadb_sa_encrypt);\r\nif (!a || !a->pfkey_supported) {\r\nerr = -ENOSYS;\r\ngoto out;\r\n}\r\nkey = (struct sadb_key*) ext_hdrs[SADB_EXT_KEY_ENCRYPT-1];\r\nif (key)\r\nkeysize = (key->sadb_key_bits + 7) / 8;\r\nx->ealg = kmalloc(sizeof(*x->ealg) + keysize, GFP_KERNEL);\r\nif (!x->ealg)\r\ngoto out;\r\nstrcpy(x->ealg->alg_name, a->name);\r\nx->ealg->alg_key_len = 0;\r\nif (key) {\r\nx->ealg->alg_key_len = key->sadb_key_bits;\r\nmemcpy(x->ealg->alg_key, key+1, keysize);\r\n}\r\nx->props.ealgo = sa->sadb_sa_encrypt;\r\n}\r\n}\r\nx->props.family = pfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\r\n&x->props.saddr);\r\npfkey_sadb_addr2xfrm_addr((struct sadb_address *) ext_hdrs[SADB_EXT_ADDRESS_DST-1],\r\n&x->id.daddr);\r\nif (ext_hdrs[SADB_X_EXT_SA2-1]) {\r\nconst struct sadb_x_sa2 *sa2 = ext_hdrs[SADB_X_EXT_SA2-1];\r\nint mode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\r\nif (mode < 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nx->props.mode = mode;\r\nx->props.reqid = sa2->sadb_x_sa2_reqid;\r\n}\r\nif (ext_hdrs[SADB_EXT_ADDRESS_PROXY-1]) {\r\nconst struct sadb_address *addr = ext_hdrs[SADB_EXT_ADDRESS_PROXY-1];\r\nx->sel.family = pfkey_sadb_addr2xfrm_addr(addr, &x->sel.saddr);\r\nx->sel.prefixlen_s = addr->sadb_address_prefixlen;\r\n}\r\nif (!x->sel.family)\r\nx->sel.family = x->props.family;\r\nif (ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1]) {\r\nconst struct sadb_x_nat_t_type* n_type;\r\nstruct xfrm_encap_tmpl *natt;\r\nx->encap = kmalloc(sizeof(*x->encap), GFP_KERNEL);\r\nif (!x->encap)\r\ngoto out;\r\nnatt = x->encap;\r\nn_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];\r\nnatt->encap_type = n_type->sadb_x_nat_t_type_type;\r\nif (ext_hdrs[SADB_X_EXT_NAT_T_SPORT-1]) {\r\nconst struct sadb_x_nat_t_port *n_port =\r\next_hdrs[SADB_X_EXT_NAT_T_SPORT-1];\r\nnatt->encap_sport = n_port->sadb_x_nat_t_port_port;\r\n}\r\nif (ext_hdrs[SADB_X_EXT_NAT_T_DPORT-1]) {\r\nconst struct sadb_x_nat_t_port *n_port =\r\next_hdrs[SADB_X_EXT_NAT_T_DPORT-1];\r\nnatt->encap_dport = n_port->sadb_x_nat_t_port_port;\r\n}\r\nmemset(&natt->encap_oa, 0, sizeof(natt->encap_oa));\r\n}\r\nerr = xfrm_init_state(x);\r\nif (err)\r\ngoto out;\r\nx->km.seq = hdr->sadb_msg_seq;\r\nreturn x;\r\nout:\r\nx->km.state = XFRM_STATE_DEAD;\r\nxfrm_state_put(x);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int pfkey_reserved(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct sk_buff *resp_skb;\r\nstruct sadb_x_sa2 *sa2;\r\nstruct sadb_address *saddr, *daddr;\r\nstruct sadb_msg *out_hdr;\r\nstruct sadb_spirange *range;\r\nstruct xfrm_state *x = NULL;\r\nint mode;\r\nint err;\r\nu32 min_spi, max_spi;\r\nu32 reqid;\r\nu8 proto;\r\nunsigned short family;\r\nxfrm_address_t *xsaddr = NULL, *xdaddr = NULL;\r\nif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\r\next_hdrs[SADB_EXT_ADDRESS_DST-1]))\r\nreturn -EINVAL;\r\nproto = pfkey_satype2proto(hdr->sadb_msg_satype);\r\nif (proto == 0)\r\nreturn -EINVAL;\r\nif ((sa2 = ext_hdrs[SADB_X_EXT_SA2-1]) != NULL) {\r\nmode = pfkey_mode_to_xfrm(sa2->sadb_x_sa2_mode);\r\nif (mode < 0)\r\nreturn -EINVAL;\r\nreqid = sa2->sadb_x_sa2_reqid;\r\n} else {\r\nmode = 0;\r\nreqid = 0;\r\n}\r\nsaddr = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\r\ndaddr = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\r\nfamily = ((struct sockaddr *)(saddr + 1))->sa_family;\r\nswitch (family) {\r\ncase AF_INET:\r\nxdaddr = (xfrm_address_t *)&((struct sockaddr_in *)(daddr + 1))->sin_addr.s_addr;\r\nxsaddr = (xfrm_address_t *)&((struct sockaddr_in *)(saddr + 1))->sin_addr.s_addr;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nxdaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(daddr + 1))->sin6_addr;\r\nxsaddr = (xfrm_address_t *)&((struct sockaddr_in6 *)(saddr + 1))->sin6_addr;\r\nbreak;\r\n#endif\r\n}\r\nif (hdr->sadb_msg_seq) {\r\nx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\r\nif (x && !xfrm_addr_equal(&x->id.daddr, xdaddr, family)) {\r\nxfrm_state_put(x);\r\nx = NULL;\r\n}\r\n}\r\nif (!x)\r\nx = xfrm_find_acq(net, &dummy_mark, mode, reqid, proto, xdaddr, xsaddr, 1, family);\r\nif (x == NULL)\r\nreturn -ENOENT;\r\nmin_spi = 0x100;\r\nmax_spi = 0x0fffffff;\r\nrange = ext_hdrs[SADB_EXT_SPIRANGE-1];\r\nif (range) {\r\nmin_spi = range->sadb_spirange_min;\r\nmax_spi = range->sadb_spirange_max;\r\n}\r\nerr = verify_spi_info(x->id.proto, min_spi, max_spi);\r\nif (err) {\r\nxfrm_state_put(x);\r\nreturn err;\r\n}\r\nerr = xfrm_alloc_spi(x, min_spi, max_spi);\r\nresp_skb = err ? ERR_PTR(err) : pfkey_xfrm_state2msg(x);\r\nif (IS_ERR(resp_skb)) {\r\nxfrm_state_put(x);\r\nreturn PTR_ERR(resp_skb);\r\n}\r\nout_hdr = (struct sadb_msg *) resp_skb->data;\r\nout_hdr->sadb_msg_version = hdr->sadb_msg_version;\r\nout_hdr->sadb_msg_type = SADB_GETSPI;\r\nout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\r\nout_hdr->sadb_msg_errno = 0;\r\nout_hdr->sadb_msg_reserved = 0;\r\nout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\r\nout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\r\nxfrm_state_put(x);\r\npfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);\r\nreturn 0;\r\n}\r\nstatic int pfkey_acquire(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct xfrm_state *x;\r\nif (hdr->sadb_msg_len != sizeof(struct sadb_msg)/8)\r\nreturn -EOPNOTSUPP;\r\nif (hdr->sadb_msg_seq == 0 || hdr->sadb_msg_errno == 0)\r\nreturn 0;\r\nx = xfrm_find_acq_byseq(net, DUMMY_MARK, hdr->sadb_msg_seq);\r\nif (x == NULL)\r\nreturn 0;\r\nspin_lock_bh(&x->lock);\r\nif (x->km.state == XFRM_STATE_ACQ)\r\nx->km.state = XFRM_STATE_ERROR;\r\nspin_unlock_bh(&x->lock);\r\nxfrm_state_put(x);\r\nreturn 0;\r\n}\r\nstatic inline int event2poltype(int event)\r\n{\r\nswitch (event) {\r\ncase XFRM_MSG_DELPOLICY:\r\nreturn SADB_X_SPDDELETE;\r\ncase XFRM_MSG_NEWPOLICY:\r\nreturn SADB_X_SPDADD;\r\ncase XFRM_MSG_UPDPOLICY:\r\nreturn SADB_X_SPDUPDATE;\r\ncase XFRM_MSG_POLEXPIRE:\r\ndefault:\r\npr_err("pfkey: Unknown policy event %d\n", event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int event2keytype(int event)\r\n{\r\nswitch (event) {\r\ncase XFRM_MSG_DELSA:\r\nreturn SADB_DELETE;\r\ncase XFRM_MSG_NEWSA:\r\nreturn SADB_ADD;\r\ncase XFRM_MSG_UPDSA:\r\nreturn SADB_UPDATE;\r\ncase XFRM_MSG_EXPIRE:\r\nreturn SADB_EXPIRE;\r\ndefault:\r\npr_err("pfkey: Unknown SA event %d\n", event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int key_notify_sa(struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sadb_msg *hdr;\r\nskb = pfkey_xfrm_state2msg(x);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nhdr = (struct sadb_msg *) skb->data;\r\nhdr->sadb_msg_version = PF_KEY_V2;\r\nhdr->sadb_msg_type = event2keytype(c->event);\r\nhdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\r\nhdr->sadb_msg_errno = 0;\r\nhdr->sadb_msg_reserved = 0;\r\nhdr->sadb_msg_seq = c->seq;\r\nhdr->sadb_msg_pid = c->portid;\r\npfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));\r\nreturn 0;\r\n}\r\nstatic int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct xfrm_state *x;\r\nint err;\r\nstruct km_event c;\r\nx = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);\r\nif (IS_ERR(x))\r\nreturn PTR_ERR(x);\r\nxfrm_state_hold(x);\r\nif (hdr->sadb_msg_type == SADB_ADD)\r\nerr = xfrm_state_add(x);\r\nelse\r\nerr = xfrm_state_update(x);\r\nxfrm_audit_state_add(x, err ? 0 : 1, true);\r\nif (err < 0) {\r\nx->km.state = XFRM_STATE_DEAD;\r\n__xfrm_state_put(x);\r\ngoto out;\r\n}\r\nif (hdr->sadb_msg_type == SADB_ADD)\r\nc.event = XFRM_MSG_NEWSA;\r\nelse\r\nc.event = XFRM_MSG_UPDSA;\r\nc.seq = hdr->sadb_msg_seq;\r\nc.portid = hdr->sadb_msg_pid;\r\nkm_state_notify(x, &c);\r\nout:\r\nxfrm_state_put(x);\r\nreturn err;\r\n}\r\nstatic int pfkey_delete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct xfrm_state *x;\r\nstruct km_event c;\r\nint err;\r\nif (!ext_hdrs[SADB_EXT_SA-1] ||\r\n!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\r\next_hdrs[SADB_EXT_ADDRESS_DST-1]))\r\nreturn -EINVAL;\r\nx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\r\nif (x == NULL)\r\nreturn -ESRCH;\r\nif ((err = security_xfrm_state_delete(x)))\r\ngoto out;\r\nif (xfrm_state_kern(x)) {\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nerr = xfrm_state_delete(x);\r\nif (err < 0)\r\ngoto out;\r\nc.seq = hdr->sadb_msg_seq;\r\nc.portid = hdr->sadb_msg_pid;\r\nc.event = XFRM_MSG_DELSA;\r\nkm_state_notify(x, &c);\r\nout:\r\nxfrm_audit_state_delete(x, err ? 0 : 1, true);\r\nxfrm_state_put(x);\r\nreturn err;\r\n}\r\nstatic int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\n__u8 proto;\r\nstruct sk_buff *out_skb;\r\nstruct sadb_msg *out_hdr;\r\nstruct xfrm_state *x;\r\nif (!ext_hdrs[SADB_EXT_SA-1] ||\r\n!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\r\next_hdrs[SADB_EXT_ADDRESS_DST-1]))\r\nreturn -EINVAL;\r\nx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\r\nif (x == NULL)\r\nreturn -ESRCH;\r\nout_skb = pfkey_xfrm_state2msg(x);\r\nproto = x->id.proto;\r\nxfrm_state_put(x);\r\nif (IS_ERR(out_skb))\r\nreturn PTR_ERR(out_skb);\r\nout_hdr = (struct sadb_msg *) out_skb->data;\r\nout_hdr->sadb_msg_version = hdr->sadb_msg_version;\r\nout_hdr->sadb_msg_type = SADB_GET;\r\nout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\r\nout_hdr->sadb_msg_errno = 0;\r\nout_hdr->sadb_msg_reserved = 0;\r\nout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\r\nout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\r\npfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *compose_sadb_supported(const struct sadb_msg *orig,\r\ngfp_t allocation)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sadb_msg *hdr;\r\nint len, auth_len, enc_len, i;\r\nauth_len = xfrm_count_pfkey_auth_supported();\r\nif (auth_len) {\r\nauth_len *= sizeof(struct sadb_alg);\r\nauth_len += sizeof(struct sadb_supported);\r\n}\r\nenc_len = xfrm_count_pfkey_enc_supported();\r\nif (enc_len) {\r\nenc_len *= sizeof(struct sadb_alg);\r\nenc_len += sizeof(struct sadb_supported);\r\n}\r\nlen = enc_len + auth_len + sizeof(struct sadb_msg);\r\nskb = alloc_skb(len + 16, allocation);\r\nif (!skb)\r\ngoto out_put_algs;\r\nhdr = (struct sadb_msg *) skb_put(skb, sizeof(*hdr));\r\npfkey_hdr_dup(hdr, orig);\r\nhdr->sadb_msg_errno = 0;\r\nhdr->sadb_msg_len = len / sizeof(uint64_t);\r\nif (auth_len) {\r\nstruct sadb_supported *sp;\r\nstruct sadb_alg *ap;\r\nsp = (struct sadb_supported *) skb_put(skb, auth_len);\r\nap = (struct sadb_alg *) (sp + 1);\r\nsp->sadb_supported_len = auth_len / sizeof(uint64_t);\r\nsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_AUTH;\r\nfor (i = 0; ; i++) {\r\nstruct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\r\nif (!aalg)\r\nbreak;\r\nif (!aalg->pfkey_supported)\r\ncontinue;\r\nif (aalg->available)\r\n*ap++ = aalg->desc;\r\n}\r\n}\r\nif (enc_len) {\r\nstruct sadb_supported *sp;\r\nstruct sadb_alg *ap;\r\nsp = (struct sadb_supported *) skb_put(skb, enc_len);\r\nap = (struct sadb_alg *) (sp + 1);\r\nsp->sadb_supported_len = enc_len / sizeof(uint64_t);\r\nsp->sadb_supported_exttype = SADB_EXT_SUPPORTED_ENCRYPT;\r\nfor (i = 0; ; i++) {\r\nstruct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\r\nif (!ealg)\r\nbreak;\r\nif (!ealg->pfkey_supported)\r\ncontinue;\r\nif (ealg->available)\r\n*ap++ = ealg->desc;\r\n}\r\n}\r\nout_put_algs:\r\nreturn skb;\r\n}\r\nstatic int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct pfkey_sock *pfk = pfkey_sk(sk);\r\nstruct sk_buff *supp_skb;\r\nif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\r\nreturn -EINVAL;\r\nif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\r\nif (pfk->registered&(1<<hdr->sadb_msg_satype))\r\nreturn -EEXIST;\r\npfk->registered |= (1<<hdr->sadb_msg_satype);\r\n}\r\nxfrm_probe_algs();\r\nsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\r\nif (!supp_skb) {\r\nif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\r\npfk->registered &= ~(1<<hdr->sadb_msg_satype);\r\nreturn -ENOBUFS;\r\n}\r\npfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk));\r\nreturn 0;\r\n}\r\nstatic int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sadb_msg *hdr;\r\nskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nhdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\r\nmemcpy(hdr, ihdr, sizeof(struct sadb_msg));\r\nhdr->sadb_msg_errno = (uint8_t) 0;\r\nhdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\r\nreturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\r\n}\r\nstatic int key_notify_sa_flush(const struct km_event *c)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sadb_msg *hdr;\r\nskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nhdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\r\nhdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\r\nhdr->sadb_msg_type = SADB_FLUSH;\r\nhdr->sadb_msg_seq = c->seq;\r\nhdr->sadb_msg_pid = c->portid;\r\nhdr->sadb_msg_version = PF_KEY_V2;\r\nhdr->sadb_msg_errno = (uint8_t) 0;\r\nhdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\r\nhdr->sadb_msg_reserved = 0;\r\npfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\r\nreturn 0;\r\n}\r\nstatic int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nunsigned int proto;\r\nstruct km_event c;\r\nint err, err2;\r\nproto = pfkey_satype2proto(hdr->sadb_msg_satype);\r\nif (proto == 0)\r\nreturn -EINVAL;\r\nerr = xfrm_state_flush(net, proto, true);\r\nerr2 = unicast_flush_resp(sk, hdr);\r\nif (err || err2) {\r\nif (err == -ESRCH)\r\nerr = 0;\r\nreturn err ? err : err2;\r\n}\r\nc.data.proto = proto;\r\nc.seq = hdr->sadb_msg_seq;\r\nc.portid = hdr->sadb_msg_pid;\r\nc.event = XFRM_MSG_FLUSHSA;\r\nc.net = net;\r\nkm_state_notify(NULL, &c);\r\nreturn 0;\r\n}\r\nstatic int dump_sa(struct xfrm_state *x, int count, void *ptr)\r\n{\r\nstruct pfkey_sock *pfk = ptr;\r\nstruct sk_buff *out_skb;\r\nstruct sadb_msg *out_hdr;\r\nif (!pfkey_can_dump(&pfk->sk))\r\nreturn -ENOBUFS;\r\nout_skb = pfkey_xfrm_state2msg(x);\r\nif (IS_ERR(out_skb))\r\nreturn PTR_ERR(out_skb);\r\nout_hdr = (struct sadb_msg *) out_skb->data;\r\nout_hdr->sadb_msg_version = pfk->dump.msg_version;\r\nout_hdr->sadb_msg_type = SADB_DUMP;\r\nout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\r\nout_hdr->sadb_msg_errno = 0;\r\nout_hdr->sadb_msg_reserved = 0;\r\nout_hdr->sadb_msg_seq = count + 1;\r\nout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\r\nif (pfk->dump.skb)\r\npfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\r\n&pfk->sk, sock_net(&pfk->sk));\r\npfk->dump.skb = out_skb;\r\nreturn 0;\r\n}\r\nstatic int pfkey_dump_sa(struct pfkey_sock *pfk)\r\n{\r\nstruct net *net = sock_net(&pfk->sk);\r\nreturn xfrm_state_walk(net, &pfk->dump.u.state, dump_sa, (void *) pfk);\r\n}\r\nstatic void pfkey_dump_sa_done(struct pfkey_sock *pfk)\r\n{\r\nstruct net *net = sock_net(&pfk->sk);\r\nxfrm_state_walk_done(&pfk->dump.u.state, net);\r\n}\r\nstatic int pfkey_dump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nu8 proto;\r\nstruct xfrm_address_filter *filter = NULL;\r\nstruct pfkey_sock *pfk = pfkey_sk(sk);\r\nif (pfk->dump.dump != NULL)\r\nreturn -EBUSY;\r\nproto = pfkey_satype2proto(hdr->sadb_msg_satype);\r\nif (proto == 0)\r\nreturn -EINVAL;\r\nif (ext_hdrs[SADB_X_EXT_FILTER - 1]) {\r\nstruct sadb_x_filter *xfilter = ext_hdrs[SADB_X_EXT_FILTER - 1];\r\nfilter = kmalloc(sizeof(*filter), GFP_KERNEL);\r\nif (filter == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(&filter->saddr, &xfilter->sadb_x_filter_saddr,\r\nsizeof(xfrm_address_t));\r\nmemcpy(&filter->daddr, &xfilter->sadb_x_filter_daddr,\r\nsizeof(xfrm_address_t));\r\nfilter->family = xfilter->sadb_x_filter_family;\r\nfilter->splen = xfilter->sadb_x_filter_splen;\r\nfilter->dplen = xfilter->sadb_x_filter_dplen;\r\n}\r\npfk->dump.msg_version = hdr->sadb_msg_version;\r\npfk->dump.msg_portid = hdr->sadb_msg_pid;\r\npfk->dump.dump = pfkey_dump_sa;\r\npfk->dump.done = pfkey_dump_sa_done;\r\nxfrm_state_walk_init(&pfk->dump.u.state, proto, filter);\r\nreturn pfkey_do_dump(pfk);\r\n}\r\nstatic int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct pfkey_sock *pfk = pfkey_sk(sk);\r\nint satype = hdr->sadb_msg_satype;\r\nbool reset_errno = false;\r\nif (hdr->sadb_msg_len == (sizeof(*hdr) / sizeof(uint64_t))) {\r\nreset_errno = true;\r\nif (satype != 0 && satype != 1)\r\nreturn -EINVAL;\r\npfk->promisc = satype;\r\n}\r\nif (reset_errno && skb_cloned(skb))\r\nskb = skb_copy(skb, GFP_KERNEL);\r\nelse\r\nskb = skb_clone(skb, GFP_KERNEL);\r\nif (reset_errno && skb) {\r\nstruct sadb_msg *new_hdr = (struct sadb_msg *) skb->data;\r\nnew_hdr->sadb_msg_errno = 0;\r\n}\r\npfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));\r\nreturn 0;\r\n}\r\nstatic int check_reqid(struct xfrm_policy *xp, int dir, int count, void *ptr)\r\n{\r\nint i;\r\nu32 reqid = *(u32*)ptr;\r\nfor (i=0; i<xp->xfrm_nr; i++) {\r\nif (xp->xfrm_vec[i].reqid == reqid)\r\nreturn -EEXIST;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 gen_reqid(struct net *net)\r\n{\r\nstruct xfrm_policy_walk walk;\r\nu32 start;\r\nint rc;\r\nstatic u32 reqid = IPSEC_MANUAL_REQID_MAX;\r\nstart = reqid;\r\ndo {\r\n++reqid;\r\nif (reqid == 0)\r\nreqid = IPSEC_MANUAL_REQID_MAX+1;\r\nxfrm_policy_walk_init(&walk, XFRM_POLICY_TYPE_MAIN);\r\nrc = xfrm_policy_walk(net, &walk, check_reqid, (void*)&reqid);\r\nxfrm_policy_walk_done(&walk, net);\r\nif (rc != -EEXIST)\r\nreturn reqid;\r\n} while (reqid != start);\r\nreturn 0;\r\n}\r\nstatic int\r\nparse_ipsecrequest(struct xfrm_policy *xp, struct sadb_x_ipsecrequest *rq)\r\n{\r\nstruct net *net = xp_net(xp);\r\nstruct xfrm_tmpl *t = xp->xfrm_vec + xp->xfrm_nr;\r\nint mode;\r\nif (xp->xfrm_nr >= XFRM_MAX_DEPTH)\r\nreturn -ELOOP;\r\nif (rq->sadb_x_ipsecrequest_mode == 0)\r\nreturn -EINVAL;\r\nt->id.proto = rq->sadb_x_ipsecrequest_proto;\r\nif ((mode = pfkey_mode_to_xfrm(rq->sadb_x_ipsecrequest_mode)) < 0)\r\nreturn -EINVAL;\r\nt->mode = mode;\r\nif (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_USE)\r\nt->optional = 1;\r\nelse if (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_UNIQUE) {\r\nt->reqid = rq->sadb_x_ipsecrequest_reqid;\r\nif (t->reqid > IPSEC_MANUAL_REQID_MAX)\r\nt->reqid = 0;\r\nif (!t->reqid && !(t->reqid = gen_reqid(net)))\r\nreturn -ENOBUFS;\r\n}\r\nif (t->mode == XFRM_MODE_TUNNEL) {\r\nu8 *sa = (u8 *) (rq + 1);\r\nint family, socklen;\r\nfamily = pfkey_sockaddr_extract((struct sockaddr *)sa,\r\n&t->saddr);\r\nif (!family)\r\nreturn -EINVAL;\r\nsocklen = pfkey_sockaddr_len(family);\r\nif (pfkey_sockaddr_extract((struct sockaddr *)(sa + socklen),\r\n&t->id.daddr) != family)\r\nreturn -EINVAL;\r\nt->encap_family = family;\r\n} else\r\nt->encap_family = xp->family;\r\nt->allalgs = 1;\r\nxp->xfrm_nr++;\r\nreturn 0;\r\n}\r\nstatic int\r\nparse_ipsecrequests(struct xfrm_policy *xp, struct sadb_x_policy *pol)\r\n{\r\nint err;\r\nint len = pol->sadb_x_policy_len*8 - sizeof(struct sadb_x_policy);\r\nstruct sadb_x_ipsecrequest *rq = (void*)(pol+1);\r\nif (pol->sadb_x_policy_len * 8 < sizeof(struct sadb_x_policy))\r\nreturn -EINVAL;\r\nwhile (len >= sizeof(struct sadb_x_ipsecrequest)) {\r\nif ((err = parse_ipsecrequest(xp, rq)) < 0)\r\nreturn err;\r\nlen -= rq->sadb_x_ipsecrequest_len;\r\nrq = (void*)((u8*)rq + rq->sadb_x_ipsecrequest_len);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int pfkey_xfrm_policy2sec_ctx_size(const struct xfrm_policy *xp)\r\n{\r\nstruct xfrm_sec_ctx *xfrm_ctx = xp->security;\r\nif (xfrm_ctx) {\r\nint len = sizeof(struct sadb_x_sec_ctx);\r\nlen += xfrm_ctx->ctx_len;\r\nreturn PFKEY_ALIGN8(len);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pfkey_xfrm_policy2msg_size(const struct xfrm_policy *xp)\r\n{\r\nconst struct xfrm_tmpl *t;\r\nint sockaddr_size = pfkey_sockaddr_size(xp->family);\r\nint socklen = 0;\r\nint i;\r\nfor (i=0; i<xp->xfrm_nr; i++) {\r\nt = xp->xfrm_vec + i;\r\nsocklen += pfkey_sockaddr_len(t->encap_family);\r\n}\r\nreturn sizeof(struct sadb_msg) +\r\n(sizeof(struct sadb_lifetime) * 3) +\r\n(sizeof(struct sadb_address) * 2) +\r\n(sockaddr_size * 2) +\r\nsizeof(struct sadb_x_policy) +\r\n(xp->xfrm_nr * sizeof(struct sadb_x_ipsecrequest)) +\r\n(socklen * 2) +\r\npfkey_xfrm_policy2sec_ctx_size(xp);\r\n}\r\nstatic struct sk_buff * pfkey_xfrm_policy2msg_prep(const struct xfrm_policy *xp)\r\n{\r\nstruct sk_buff *skb;\r\nint size;\r\nsize = pfkey_xfrm_policy2msg_size(xp);\r\nskb = alloc_skb(size + 16, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn ERR_PTR(-ENOBUFS);\r\nreturn skb;\r\n}\r\nstatic int pfkey_xfrm_policy2msg(struct sk_buff *skb, const struct xfrm_policy *xp, int dir)\r\n{\r\nstruct sadb_msg *hdr;\r\nstruct sadb_address *addr;\r\nstruct sadb_lifetime *lifetime;\r\nstruct sadb_x_policy *pol;\r\nstruct sadb_x_sec_ctx *sec_ctx;\r\nstruct xfrm_sec_ctx *xfrm_ctx;\r\nint i;\r\nint size;\r\nint sockaddr_size = pfkey_sockaddr_size(xp->family);\r\nint socklen = pfkey_sockaddr_len(xp->family);\r\nsize = pfkey_xfrm_policy2msg_size(xp);\r\nhdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\r\nmemset(hdr, 0, size);\r\naddr = (struct sadb_address*) skb_put(skb,\r\nsizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\r\naddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\r\naddr->sadb_address_prefixlen = xp->selector.prefixlen_s;\r\naddr->sadb_address_reserved = 0;\r\nif (!pfkey_sockaddr_fill(&xp->selector.saddr,\r\nxp->selector.sport,\r\n(struct sockaddr *) (addr + 1),\r\nxp->family))\r\nBUG();\r\naddr = (struct sadb_address*) skb_put(skb,\r\nsizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\r\naddr->sadb_address_proto = pfkey_proto_from_xfrm(xp->selector.proto);\r\naddr->sadb_address_prefixlen = xp->selector.prefixlen_d;\r\naddr->sadb_address_reserved = 0;\r\npfkey_sockaddr_fill(&xp->selector.daddr, xp->selector.dport,\r\n(struct sockaddr *) (addr + 1),\r\nxp->family);\r\nlifetime = (struct sadb_lifetime *) skb_put(skb,\r\nsizeof(struct sadb_lifetime));\r\nlifetime->sadb_lifetime_len =\r\nsizeof(struct sadb_lifetime)/sizeof(uint64_t);\r\nlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;\r\nlifetime->sadb_lifetime_allocations = _X2KEY(xp->lft.hard_packet_limit);\r\nlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.hard_byte_limit);\r\nlifetime->sadb_lifetime_addtime = xp->lft.hard_add_expires_seconds;\r\nlifetime->sadb_lifetime_usetime = xp->lft.hard_use_expires_seconds;\r\nlifetime = (struct sadb_lifetime *) skb_put(skb,\r\nsizeof(struct sadb_lifetime));\r\nlifetime->sadb_lifetime_len =\r\nsizeof(struct sadb_lifetime)/sizeof(uint64_t);\r\nlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;\r\nlifetime->sadb_lifetime_allocations = _X2KEY(xp->lft.soft_packet_limit);\r\nlifetime->sadb_lifetime_bytes = _X2KEY(xp->lft.soft_byte_limit);\r\nlifetime->sadb_lifetime_addtime = xp->lft.soft_add_expires_seconds;\r\nlifetime->sadb_lifetime_usetime = xp->lft.soft_use_expires_seconds;\r\nlifetime = (struct sadb_lifetime *) skb_put(skb,\r\nsizeof(struct sadb_lifetime));\r\nlifetime->sadb_lifetime_len =\r\nsizeof(struct sadb_lifetime)/sizeof(uint64_t);\r\nlifetime->sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;\r\nlifetime->sadb_lifetime_allocations = xp->curlft.packets;\r\nlifetime->sadb_lifetime_bytes = xp->curlft.bytes;\r\nlifetime->sadb_lifetime_addtime = xp->curlft.add_time;\r\nlifetime->sadb_lifetime_usetime = xp->curlft.use_time;\r\npol = (struct sadb_x_policy *) skb_put(skb, sizeof(struct sadb_x_policy));\r\npol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\r\npol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\r\npol->sadb_x_policy_type = IPSEC_POLICY_DISCARD;\r\nif (xp->action == XFRM_POLICY_ALLOW) {\r\nif (xp->xfrm_nr)\r\npol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\r\nelse\r\npol->sadb_x_policy_type = IPSEC_POLICY_NONE;\r\n}\r\npol->sadb_x_policy_dir = dir+1;\r\npol->sadb_x_policy_reserved = 0;\r\npol->sadb_x_policy_id = xp->index;\r\npol->sadb_x_policy_priority = xp->priority;\r\nfor (i=0; i<xp->xfrm_nr; i++) {\r\nconst struct xfrm_tmpl *t = xp->xfrm_vec + i;\r\nstruct sadb_x_ipsecrequest *rq;\r\nint req_size;\r\nint mode;\r\nreq_size = sizeof(struct sadb_x_ipsecrequest);\r\nif (t->mode == XFRM_MODE_TUNNEL) {\r\nsocklen = pfkey_sockaddr_len(t->encap_family);\r\nreq_size += socklen * 2;\r\n} else {\r\nsize -= 2*socklen;\r\n}\r\nrq = (void*)skb_put(skb, req_size);\r\npol->sadb_x_policy_len += req_size/8;\r\nmemset(rq, 0, sizeof(*rq));\r\nrq->sadb_x_ipsecrequest_len = req_size;\r\nrq->sadb_x_ipsecrequest_proto = t->id.proto;\r\nif ((mode = pfkey_mode_from_xfrm(t->mode)) < 0)\r\nreturn -EINVAL;\r\nrq->sadb_x_ipsecrequest_mode = mode;\r\nrq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_REQUIRE;\r\nif (t->reqid)\r\nrq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_UNIQUE;\r\nif (t->optional)\r\nrq->sadb_x_ipsecrequest_level = IPSEC_LEVEL_USE;\r\nrq->sadb_x_ipsecrequest_reqid = t->reqid;\r\nif (t->mode == XFRM_MODE_TUNNEL) {\r\nu8 *sa = (void *)(rq + 1);\r\npfkey_sockaddr_fill(&t->saddr, 0,\r\n(struct sockaddr *)sa,\r\nt->encap_family);\r\npfkey_sockaddr_fill(&t->id.daddr, 0,\r\n(struct sockaddr *) (sa + socklen),\r\nt->encap_family);\r\n}\r\n}\r\nif ((xfrm_ctx = xp->security)) {\r\nint ctx_size = pfkey_xfrm_policy2sec_ctx_size(xp);\r\nsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb, ctx_size);\r\nsec_ctx->sadb_x_sec_len = ctx_size / sizeof(uint64_t);\r\nsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\r\nsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\r\nsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\r\nsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\r\nmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\r\nxfrm_ctx->ctx_len);\r\n}\r\nhdr->sadb_msg_len = size / sizeof(uint64_t);\r\nhdr->sadb_msg_reserved = atomic_read(&xp->refcnt);\r\nreturn 0;\r\n}\r\nstatic int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\r\n{\r\nstruct sk_buff *out_skb;\r\nstruct sadb_msg *out_hdr;\r\nint err;\r\nout_skb = pfkey_xfrm_policy2msg_prep(xp);\r\nif (IS_ERR(out_skb))\r\nreturn PTR_ERR(out_skb);\r\nerr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\r\nif (err < 0)\r\nreturn err;\r\nout_hdr = (struct sadb_msg *) out_skb->data;\r\nout_hdr->sadb_msg_version = PF_KEY_V2;\r\nif (c->data.byid && c->event == XFRM_MSG_DELPOLICY)\r\nout_hdr->sadb_msg_type = SADB_X_SPDDELETE2;\r\nelse\r\nout_hdr->sadb_msg_type = event2poltype(c->event);\r\nout_hdr->sadb_msg_errno = 0;\r\nout_hdr->sadb_msg_seq = c->seq;\r\nout_hdr->sadb_msg_pid = c->portid;\r\npfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));\r\nreturn 0;\r\n}\r\nstatic int pfkey_spdadd(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nint err = 0;\r\nstruct sadb_lifetime *lifetime;\r\nstruct sadb_address *sa;\r\nstruct sadb_x_policy *pol;\r\nstruct xfrm_policy *xp;\r\nstruct km_event c;\r\nstruct sadb_x_sec_ctx *sec_ctx;\r\nif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\r\next_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\r\n!ext_hdrs[SADB_X_EXT_POLICY-1])\r\nreturn -EINVAL;\r\npol = ext_hdrs[SADB_X_EXT_POLICY-1];\r\nif (pol->sadb_x_policy_type > IPSEC_POLICY_IPSEC)\r\nreturn -EINVAL;\r\nif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\r\nreturn -EINVAL;\r\nxp = xfrm_policy_alloc(net, GFP_KERNEL);\r\nif (xp == NULL)\r\nreturn -ENOBUFS;\r\nxp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\r\nXFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\r\nxp->priority = pol->sadb_x_policy_priority;\r\nsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\r\nxp->family = pfkey_sadb_addr2xfrm_addr(sa, &xp->selector.saddr);\r\nxp->selector.family = xp->family;\r\nxp->selector.prefixlen_s = sa->sadb_address_prefixlen;\r\nxp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\r\nxp->selector.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\r\nif (xp->selector.sport)\r\nxp->selector.sport_mask = htons(0xffff);\r\nsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\r\npfkey_sadb_addr2xfrm_addr(sa, &xp->selector.daddr);\r\nxp->selector.prefixlen_d = sa->sadb_address_prefixlen;\r\nxp->selector.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\r\nxp->selector.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\r\nif (xp->selector.dport)\r\nxp->selector.dport_mask = htons(0xffff);\r\nsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\r\nif (sec_ctx != NULL) {\r\nstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\r\nif (!uctx) {\r\nerr = -ENOBUFS;\r\ngoto out;\r\n}\r\nerr = security_xfrm_policy_alloc(&xp->security, uctx, GFP_KERNEL);\r\nkfree(uctx);\r\nif (err)\r\ngoto out;\r\n}\r\nxp->lft.soft_byte_limit = XFRM_INF;\r\nxp->lft.hard_byte_limit = XFRM_INF;\r\nxp->lft.soft_packet_limit = XFRM_INF;\r\nxp->lft.hard_packet_limit = XFRM_INF;\r\nif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_HARD-1]) != NULL) {\r\nxp->lft.hard_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\r\nxp->lft.hard_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\r\nxp->lft.hard_add_expires_seconds = lifetime->sadb_lifetime_addtime;\r\nxp->lft.hard_use_expires_seconds = lifetime->sadb_lifetime_usetime;\r\n}\r\nif ((lifetime = ext_hdrs[SADB_EXT_LIFETIME_SOFT-1]) != NULL) {\r\nxp->lft.soft_packet_limit = _KEY2X(lifetime->sadb_lifetime_allocations);\r\nxp->lft.soft_byte_limit = _KEY2X(lifetime->sadb_lifetime_bytes);\r\nxp->lft.soft_add_expires_seconds = lifetime->sadb_lifetime_addtime;\r\nxp->lft.soft_use_expires_seconds = lifetime->sadb_lifetime_usetime;\r\n}\r\nxp->xfrm_nr = 0;\r\nif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\r\n(err = parse_ipsecrequests(xp, pol)) < 0)\r\ngoto out;\r\nerr = xfrm_policy_insert(pol->sadb_x_policy_dir-1, xp,\r\nhdr->sadb_msg_type != SADB_X_SPDUPDATE);\r\nxfrm_audit_policy_add(xp, err ? 0 : 1, true);\r\nif (err)\r\ngoto out;\r\nif (hdr->sadb_msg_type == SADB_X_SPDUPDATE)\r\nc.event = XFRM_MSG_UPDPOLICY;\r\nelse\r\nc.event = XFRM_MSG_NEWPOLICY;\r\nc.seq = hdr->sadb_msg_seq;\r\nc.portid = hdr->sadb_msg_pid;\r\nkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\r\nxfrm_pol_put(xp);\r\nreturn 0;\r\nout:\r\nxp->walk.dead = 1;\r\nxfrm_policy_destroy(xp);\r\nreturn err;\r\n}\r\nstatic int pfkey_spddelete(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nint err;\r\nstruct sadb_address *sa;\r\nstruct sadb_x_policy *pol;\r\nstruct xfrm_policy *xp;\r\nstruct xfrm_selector sel;\r\nstruct km_event c;\r\nstruct sadb_x_sec_ctx *sec_ctx;\r\nstruct xfrm_sec_ctx *pol_ctx = NULL;\r\nif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\r\next_hdrs[SADB_EXT_ADDRESS_DST-1]) ||\r\n!ext_hdrs[SADB_X_EXT_POLICY-1])\r\nreturn -EINVAL;\r\npol = ext_hdrs[SADB_X_EXT_POLICY-1];\r\nif (!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir >= IPSEC_DIR_MAX)\r\nreturn -EINVAL;\r\nmemset(&sel, 0, sizeof(sel));\r\nsa = ext_hdrs[SADB_EXT_ADDRESS_SRC-1];\r\nsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\r\nsel.prefixlen_s = sa->sadb_address_prefixlen;\r\nsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\r\nsel.sport = ((struct sockaddr_in *)(sa+1))->sin_port;\r\nif (sel.sport)\r\nsel.sport_mask = htons(0xffff);\r\nsa = ext_hdrs[SADB_EXT_ADDRESS_DST-1];\r\npfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\r\nsel.prefixlen_d = sa->sadb_address_prefixlen;\r\nsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\r\nsel.dport = ((struct sockaddr_in *)(sa+1))->sin_port;\r\nif (sel.dport)\r\nsel.dport_mask = htons(0xffff);\r\nsec_ctx = ext_hdrs[SADB_X_EXT_SEC_CTX - 1];\r\nif (sec_ctx != NULL) {\r\nstruct xfrm_user_sec_ctx *uctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_KERNEL);\r\nif (!uctx)\r\nreturn -ENOMEM;\r\nerr = security_xfrm_policy_alloc(&pol_ctx, uctx, GFP_KERNEL);\r\nkfree(uctx);\r\nif (err)\r\nreturn err;\r\n}\r\nxp = xfrm_policy_bysel_ctx(net, DUMMY_MARK, XFRM_POLICY_TYPE_MAIN,\r\npol->sadb_x_policy_dir - 1, &sel, pol_ctx,\r\n1, &err);\r\nsecurity_xfrm_policy_free(pol_ctx);\r\nif (xp == NULL)\r\nreturn -ENOENT;\r\nxfrm_audit_policy_delete(xp, err ? 0 : 1, true);\r\nif (err)\r\ngoto out;\r\nc.seq = hdr->sadb_msg_seq;\r\nc.portid = hdr->sadb_msg_pid;\r\nc.data.byid = 0;\r\nc.event = XFRM_MSG_DELPOLICY;\r\nkm_policy_notify(xp, pol->sadb_x_policy_dir-1, &c);\r\nout:\r\nxfrm_pol_put(xp);\r\nif (err == 0)\r\nxfrm_garbage_collect(net);\r\nreturn err;\r\n}\r\nstatic int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struct sadb_msg *hdr, int dir)\r\n{\r\nint err;\r\nstruct sk_buff *out_skb;\r\nstruct sadb_msg *out_hdr;\r\nerr = 0;\r\nout_skb = pfkey_xfrm_policy2msg_prep(xp);\r\nif (IS_ERR(out_skb)) {\r\nerr = PTR_ERR(out_skb);\r\ngoto out;\r\n}\r\nerr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\r\nif (err < 0)\r\ngoto out;\r\nout_hdr = (struct sadb_msg *) out_skb->data;\r\nout_hdr->sadb_msg_version = hdr->sadb_msg_version;\r\nout_hdr->sadb_msg_type = hdr->sadb_msg_type;\r\nout_hdr->sadb_msg_satype = 0;\r\nout_hdr->sadb_msg_errno = 0;\r\nout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\r\nout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\r\npfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int pfkey_sockaddr_pair_size(sa_family_t family)\r\n{\r\nreturn PFKEY_ALIGN8(pfkey_sockaddr_len(family) * 2);\r\n}\r\nstatic int parse_sockaddr_pair(struct sockaddr *sa, int ext_len,\r\nxfrm_address_t *saddr, xfrm_address_t *daddr,\r\nu16 *family)\r\n{\r\nint af, socklen;\r\nif (ext_len < pfkey_sockaddr_pair_size(sa->sa_family))\r\nreturn -EINVAL;\r\naf = pfkey_sockaddr_extract(sa, saddr);\r\nif (!af)\r\nreturn -EINVAL;\r\nsocklen = pfkey_sockaddr_len(af);\r\nif (pfkey_sockaddr_extract((struct sockaddr *) (((u8 *)sa) + socklen),\r\ndaddr) != af)\r\nreturn -EINVAL;\r\n*family = af;\r\nreturn 0;\r\n}\r\nstatic int ipsecrequests_to_migrate(struct sadb_x_ipsecrequest *rq1, int len,\r\nstruct xfrm_migrate *m)\r\n{\r\nint err;\r\nstruct sadb_x_ipsecrequest *rq2;\r\nint mode;\r\nif (len <= sizeof(struct sadb_x_ipsecrequest) ||\r\nlen < rq1->sadb_x_ipsecrequest_len)\r\nreturn -EINVAL;\r\nerr = parse_sockaddr_pair((struct sockaddr *)(rq1 + 1),\r\nrq1->sadb_x_ipsecrequest_len,\r\n&m->old_saddr, &m->old_daddr,\r\n&m->old_family);\r\nif (err)\r\nreturn err;\r\nrq2 = (struct sadb_x_ipsecrequest *)((u8 *)rq1 + rq1->sadb_x_ipsecrequest_len);\r\nlen -= rq1->sadb_x_ipsecrequest_len;\r\nif (len <= sizeof(struct sadb_x_ipsecrequest) ||\r\nlen < rq2->sadb_x_ipsecrequest_len)\r\nreturn -EINVAL;\r\nerr = parse_sockaddr_pair((struct sockaddr *)(rq2 + 1),\r\nrq2->sadb_x_ipsecrequest_len,\r\n&m->new_saddr, &m->new_daddr,\r\n&m->new_family);\r\nif (err)\r\nreturn err;\r\nif (rq1->sadb_x_ipsecrequest_proto != rq2->sadb_x_ipsecrequest_proto ||\r\nrq1->sadb_x_ipsecrequest_mode != rq2->sadb_x_ipsecrequest_mode ||\r\nrq1->sadb_x_ipsecrequest_reqid != rq2->sadb_x_ipsecrequest_reqid)\r\nreturn -EINVAL;\r\nm->proto = rq1->sadb_x_ipsecrequest_proto;\r\nif ((mode = pfkey_mode_to_xfrm(rq1->sadb_x_ipsecrequest_mode)) < 0)\r\nreturn -EINVAL;\r\nm->mode = mode;\r\nm->reqid = rq1->sadb_x_ipsecrequest_reqid;\r\nreturn ((int)(rq1->sadb_x_ipsecrequest_len +\r\nrq2->sadb_x_ipsecrequest_len));\r\n}\r\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\r\nconst struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nint i, len, ret, err = -EINVAL;\r\nu8 dir;\r\nstruct sadb_address *sa;\r\nstruct sadb_x_kmaddress *kma;\r\nstruct sadb_x_policy *pol;\r\nstruct sadb_x_ipsecrequest *rq;\r\nstruct xfrm_selector sel;\r\nstruct xfrm_migrate m[XFRM_MAX_DEPTH];\r\nstruct xfrm_kmaddress k;\r\nstruct net *net = sock_net(sk);\r\nif (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC - 1],\r\next_hdrs[SADB_EXT_ADDRESS_DST - 1]) ||\r\n!ext_hdrs[SADB_X_EXT_POLICY - 1]) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nkma = ext_hdrs[SADB_X_EXT_KMADDRESS - 1];\r\npol = ext_hdrs[SADB_X_EXT_POLICY - 1];\r\nif (pol->sadb_x_policy_dir >= IPSEC_DIR_MAX) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (kma) {\r\nk.reserved = kma->sadb_x_kmaddress_reserved;\r\nret = parse_sockaddr_pair((struct sockaddr *)(kma + 1),\r\n8*(kma->sadb_x_kmaddress_len) - sizeof(*kma),\r\n&k.local, &k.remote, &k.family);\r\nif (ret < 0) {\r\nerr = ret;\r\ngoto out;\r\n}\r\n}\r\ndir = pol->sadb_x_policy_dir - 1;\r\nmemset(&sel, 0, sizeof(sel));\r\nsa = ext_hdrs[SADB_EXT_ADDRESS_SRC - 1];\r\nsel.family = pfkey_sadb_addr2xfrm_addr(sa, &sel.saddr);\r\nsel.prefixlen_s = sa->sadb_address_prefixlen;\r\nsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\r\nsel.sport = ((struct sockaddr_in *)(sa + 1))->sin_port;\r\nif (sel.sport)\r\nsel.sport_mask = htons(0xffff);\r\nsa = ext_hdrs[SADB_EXT_ADDRESS_DST - 1];\r\npfkey_sadb_addr2xfrm_addr(sa, &sel.daddr);\r\nsel.prefixlen_d = sa->sadb_address_prefixlen;\r\nsel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);\r\nsel.dport = ((struct sockaddr_in *)(sa + 1))->sin_port;\r\nif (sel.dport)\r\nsel.dport_mask = htons(0xffff);\r\nrq = (struct sadb_x_ipsecrequest *)(pol + 1);\r\ni = 0;\r\nlen = pol->sadb_x_policy_len * 8 - sizeof(struct sadb_x_policy);\r\nwhile (len > 0 && i < XFRM_MAX_DEPTH) {\r\nret = ipsecrequests_to_migrate(rq, len, &m[i]);\r\nif (ret < 0) {\r\nerr = ret;\r\ngoto out;\r\n} else {\r\nrq = (struct sadb_x_ipsecrequest *)((u8 *)rq + ret);\r\nlen -= ret;\r\ni++;\r\n}\r\n}\r\nif (!i || len > 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nreturn xfrm_migrate(&sel, dir, XFRM_POLICY_TYPE_MAIN, m, i,\r\nkma ? &k : NULL, net);\r\nout:\r\nreturn err;\r\n}\r\nstatic int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\r\nconst struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nreturn -ENOPROTOOPT;\r\n}\r\nstatic int pfkey_spdget(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nunsigned int dir;\r\nint err = 0, delete;\r\nstruct sadb_x_policy *pol;\r\nstruct xfrm_policy *xp;\r\nstruct km_event c;\r\nif ((pol = ext_hdrs[SADB_X_EXT_POLICY-1]) == NULL)\r\nreturn -EINVAL;\r\ndir = xfrm_policy_id2dir(pol->sadb_x_policy_id);\r\nif (dir >= XFRM_POLICY_MAX)\r\nreturn -EINVAL;\r\ndelete = (hdr->sadb_msg_type == SADB_X_SPDDELETE2);\r\nxp = xfrm_policy_byid(net, DUMMY_MARK, XFRM_POLICY_TYPE_MAIN,\r\ndir, pol->sadb_x_policy_id, delete, &err);\r\nif (xp == NULL)\r\nreturn -ENOENT;\r\nif (delete) {\r\nxfrm_audit_policy_delete(xp, err ? 0 : 1, true);\r\nif (err)\r\ngoto out;\r\nc.seq = hdr->sadb_msg_seq;\r\nc.portid = hdr->sadb_msg_pid;\r\nc.data.byid = 1;\r\nc.event = XFRM_MSG_DELPOLICY;\r\nkm_policy_notify(xp, dir, &c);\r\n} else {\r\nerr = key_pol_get_resp(sk, xp, hdr, dir);\r\n}\r\nout:\r\nxfrm_pol_put(xp);\r\nif (delete && err == 0)\r\nxfrm_garbage_collect(net);\r\nreturn err;\r\n}\r\nstatic int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)\r\n{\r\nstruct pfkey_sock *pfk = ptr;\r\nstruct sk_buff *out_skb;\r\nstruct sadb_msg *out_hdr;\r\nint err;\r\nif (!pfkey_can_dump(&pfk->sk))\r\nreturn -ENOBUFS;\r\nout_skb = pfkey_xfrm_policy2msg_prep(xp);\r\nif (IS_ERR(out_skb))\r\nreturn PTR_ERR(out_skb);\r\nerr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\r\nif (err < 0)\r\nreturn err;\r\nout_hdr = (struct sadb_msg *) out_skb->data;\r\nout_hdr->sadb_msg_version = pfk->dump.msg_version;\r\nout_hdr->sadb_msg_type = SADB_X_SPDDUMP;\r\nout_hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\r\nout_hdr->sadb_msg_errno = 0;\r\nout_hdr->sadb_msg_seq = count + 1;\r\nout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\r\nif (pfk->dump.skb)\r\npfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\r\n&pfk->sk, sock_net(&pfk->sk));\r\npfk->dump.skb = out_skb;\r\nreturn 0;\r\n}\r\nstatic int pfkey_dump_sp(struct pfkey_sock *pfk)\r\n{\r\nstruct net *net = sock_net(&pfk->sk);\r\nreturn xfrm_policy_walk(net, &pfk->dump.u.policy, dump_sp, (void *) pfk);\r\n}\r\nstatic void pfkey_dump_sp_done(struct pfkey_sock *pfk)\r\n{\r\nstruct net *net = sock_net((struct sock *)pfk);\r\nxfrm_policy_walk_done(&pfk->dump.u.policy, net);\r\n}\r\nstatic int pfkey_spddump(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct pfkey_sock *pfk = pfkey_sk(sk);\r\nif (pfk->dump.dump != NULL)\r\nreturn -EBUSY;\r\npfk->dump.msg_version = hdr->sadb_msg_version;\r\npfk->dump.msg_portid = hdr->sadb_msg_pid;\r\npfk->dump.dump = pfkey_dump_sp;\r\npfk->dump.done = pfkey_dump_sp_done;\r\nxfrm_policy_walk_init(&pfk->dump.u.policy, XFRM_POLICY_TYPE_MAIN);\r\nreturn pfkey_do_dump(pfk);\r\n}\r\nstatic int key_notify_policy_flush(const struct km_event *c)\r\n{\r\nstruct sk_buff *skb_out;\r\nstruct sadb_msg *hdr;\r\nskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\r\nif (!skb_out)\r\nreturn -ENOBUFS;\r\nhdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\r\nhdr->sadb_msg_type = SADB_X_SPDFLUSH;\r\nhdr->sadb_msg_seq = c->seq;\r\nhdr->sadb_msg_pid = c->portid;\r\nhdr->sadb_msg_version = PF_KEY_V2;\r\nhdr->sadb_msg_errno = (uint8_t) 0;\r\nhdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\r\nhdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\r\nhdr->sadb_msg_reserved = 0;\r\npfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\r\nreturn 0;\r\n}\r\nstatic int pfkey_spdflush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct km_event c;\r\nint err, err2;\r\nerr = xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, true);\r\nerr2 = unicast_flush_resp(sk, hdr);\r\nif (err || err2) {\r\nif (err == -ESRCH)\r\nreturn 0;\r\nreturn err;\r\n}\r\nc.data.type = XFRM_POLICY_TYPE_MAIN;\r\nc.event = XFRM_MSG_FLUSHPOLICY;\r\nc.portid = hdr->sadb_msg_pid;\r\nc.seq = hdr->sadb_msg_seq;\r\nc.net = net;\r\nkm_policy_notify(NULL, 0, &c);\r\nreturn 0;\r\n}\r\nstatic int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\r\n{\r\nvoid *ext_hdrs[SADB_EXT_MAX];\r\nint err;\r\npfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\r\nBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\r\nmemset(ext_hdrs, 0, sizeof(ext_hdrs));\r\nerr = parse_exthdrs(skb, hdr, ext_hdrs);\r\nif (!err) {\r\nerr = -EOPNOTSUPP;\r\nif (pfkey_funcs[hdr->sadb_msg_type])\r\nerr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\r\n}\r\nreturn err;\r\n}\r\nstatic struct sadb_msg *pfkey_get_base_msg(struct sk_buff *skb, int *errp)\r\n{\r\nstruct sadb_msg *hdr = NULL;\r\nif (skb->len < sizeof(*hdr)) {\r\n*errp = -EMSGSIZE;\r\n} else {\r\nhdr = (struct sadb_msg *) skb->data;\r\nif (hdr->sadb_msg_version != PF_KEY_V2 ||\r\nhdr->sadb_msg_reserved != 0 ||\r\n(hdr->sadb_msg_type <= SADB_RESERVED ||\r\nhdr->sadb_msg_type > SADB_MAX)) {\r\nhdr = NULL;\r\n*errp = -EINVAL;\r\n} else if (hdr->sadb_msg_len != (skb->len /\r\nsizeof(uint64_t)) ||\r\nhdr->sadb_msg_len < (sizeof(struct sadb_msg) /\r\nsizeof(uint64_t))) {\r\nhdr = NULL;\r\n*errp = -EMSGSIZE;\r\n} else {\r\n*errp = 0;\r\n}\r\n}\r\nreturn hdr;\r\n}\r\nstatic inline int aalg_tmpl_set(const struct xfrm_tmpl *t,\r\nconst struct xfrm_algo_desc *d)\r\n{\r\nunsigned int id = d->desc.sadb_alg_id;\r\nif (id >= sizeof(t->aalgos) * 8)\r\nreturn 0;\r\nreturn (t->aalgos >> id) & 1;\r\n}\r\nstatic inline int ealg_tmpl_set(const struct xfrm_tmpl *t,\r\nconst struct xfrm_algo_desc *d)\r\n{\r\nunsigned int id = d->desc.sadb_alg_id;\r\nif (id >= sizeof(t->ealgos) * 8)\r\nreturn 0;\r\nreturn (t->ealgos >> id) & 1;\r\n}\r\nstatic int count_ah_combs(const struct xfrm_tmpl *t)\r\n{\r\nint i, sz = 0;\r\nfor (i = 0; ; i++) {\r\nconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\r\nif (!aalg)\r\nbreak;\r\nif (!aalg->pfkey_supported)\r\ncontinue;\r\nif (aalg_tmpl_set(t, aalg) && aalg->available)\r\nsz += sizeof(struct sadb_comb);\r\n}\r\nreturn sz + sizeof(struct sadb_prop);\r\n}\r\nstatic int count_esp_combs(const struct xfrm_tmpl *t)\r\n{\r\nint i, k, sz = 0;\r\nfor (i = 0; ; i++) {\r\nconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\r\nif (!ealg)\r\nbreak;\r\nif (!ealg->pfkey_supported)\r\ncontinue;\r\nif (!(ealg_tmpl_set(t, ealg) && ealg->available))\r\ncontinue;\r\nfor (k = 1; ; k++) {\r\nconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\r\nif (!aalg)\r\nbreak;\r\nif (!aalg->pfkey_supported)\r\ncontinue;\r\nif (aalg_tmpl_set(t, aalg) && aalg->available)\r\nsz += sizeof(struct sadb_comb);\r\n}\r\n}\r\nreturn sz + sizeof(struct sadb_prop);\r\n}\r\nstatic void dump_ah_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\r\n{\r\nstruct sadb_prop *p;\r\nint i;\r\np = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));\r\np->sadb_prop_len = sizeof(struct sadb_prop)/8;\r\np->sadb_prop_exttype = SADB_EXT_PROPOSAL;\r\np->sadb_prop_replay = 32;\r\nmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\r\nfor (i = 0; ; i++) {\r\nconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\r\nif (!aalg)\r\nbreak;\r\nif (!aalg->pfkey_supported)\r\ncontinue;\r\nif (aalg_tmpl_set(t, aalg) && aalg->available) {\r\nstruct sadb_comb *c;\r\nc = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));\r\nmemset(c, 0, sizeof(*c));\r\np->sadb_prop_len += sizeof(struct sadb_comb)/8;\r\nc->sadb_comb_auth = aalg->desc.sadb_alg_id;\r\nc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\r\nc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\r\nc->sadb_comb_hard_addtime = 24*60*60;\r\nc->sadb_comb_soft_addtime = 20*60*60;\r\nc->sadb_comb_hard_usetime = 8*60*60;\r\nc->sadb_comb_soft_usetime = 7*60*60;\r\n}\r\n}\r\n}\r\nstatic void dump_esp_combs(struct sk_buff *skb, const struct xfrm_tmpl *t)\r\n{\r\nstruct sadb_prop *p;\r\nint i, k;\r\np = (struct sadb_prop*)skb_put(skb, sizeof(struct sadb_prop));\r\np->sadb_prop_len = sizeof(struct sadb_prop)/8;\r\np->sadb_prop_exttype = SADB_EXT_PROPOSAL;\r\np->sadb_prop_replay = 32;\r\nmemset(p->sadb_prop_reserved, 0, sizeof(p->sadb_prop_reserved));\r\nfor (i=0; ; i++) {\r\nconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\r\nif (!ealg)\r\nbreak;\r\nif (!ealg->pfkey_supported)\r\ncontinue;\r\nif (!(ealg_tmpl_set(t, ealg) && ealg->available))\r\ncontinue;\r\nfor (k = 1; ; k++) {\r\nstruct sadb_comb *c;\r\nconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\r\nif (!aalg)\r\nbreak;\r\nif (!aalg->pfkey_supported)\r\ncontinue;\r\nif (!(aalg_tmpl_set(t, aalg) && aalg->available))\r\ncontinue;\r\nc = (struct sadb_comb*)skb_put(skb, sizeof(struct sadb_comb));\r\nmemset(c, 0, sizeof(*c));\r\np->sadb_prop_len += sizeof(struct sadb_comb)/8;\r\nc->sadb_comb_auth = aalg->desc.sadb_alg_id;\r\nc->sadb_comb_auth_minbits = aalg->desc.sadb_alg_minbits;\r\nc->sadb_comb_auth_maxbits = aalg->desc.sadb_alg_maxbits;\r\nc->sadb_comb_encrypt = ealg->desc.sadb_alg_id;\r\nc->sadb_comb_encrypt_minbits = ealg->desc.sadb_alg_minbits;\r\nc->sadb_comb_encrypt_maxbits = ealg->desc.sadb_alg_maxbits;\r\nc->sadb_comb_hard_addtime = 24*60*60;\r\nc->sadb_comb_soft_addtime = 20*60*60;\r\nc->sadb_comb_hard_usetime = 8*60*60;\r\nc->sadb_comb_soft_usetime = 7*60*60;\r\n}\r\n}\r\n}\r\nstatic int key_notify_policy_expire(struct xfrm_policy *xp, const struct km_event *c)\r\n{\r\nreturn 0;\r\n}\r\nstatic int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct sk_buff *out_skb;\r\nstruct sadb_msg *out_hdr;\r\nint hard;\r\nint hsc;\r\nhard = c->data.hard;\r\nif (hard)\r\nhsc = 2;\r\nelse\r\nhsc = 1;\r\nout_skb = pfkey_xfrm_state2msg_expire(x, hsc);\r\nif (IS_ERR(out_skb))\r\nreturn PTR_ERR(out_skb);\r\nout_hdr = (struct sadb_msg *) out_skb->data;\r\nout_hdr->sadb_msg_version = PF_KEY_V2;\r\nout_hdr->sadb_msg_type = SADB_EXPIRE;\r\nout_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\r\nout_hdr->sadb_msg_errno = 0;\r\nout_hdr->sadb_msg_reserved = 0;\r\nout_hdr->sadb_msg_seq = 0;\r\nout_hdr->sadb_msg_pid = 0;\r\npfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\r\nreturn 0;\r\n}\r\nstatic int pfkey_send_notify(struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct net *net = x ? xs_net(x) : c->net;\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\nif (atomic_read(&net_pfkey->socks_nr) == 0)\r\nreturn 0;\r\nswitch (c->event) {\r\ncase XFRM_MSG_EXPIRE:\r\nreturn key_notify_sa_expire(x, c);\r\ncase XFRM_MSG_DELSA:\r\ncase XFRM_MSG_NEWSA:\r\ncase XFRM_MSG_UPDSA:\r\nreturn key_notify_sa(x, c);\r\ncase XFRM_MSG_FLUSHSA:\r\nreturn key_notify_sa_flush(c);\r\ncase XFRM_MSG_NEWAE:\r\nbreak;\r\ndefault:\r\npr_err("pfkey: Unknown SA event %d\n", c->event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pfkey_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\r\n{\r\nif (xp && xp->type != XFRM_POLICY_TYPE_MAIN)\r\nreturn 0;\r\nswitch (c->event) {\r\ncase XFRM_MSG_POLEXPIRE:\r\nreturn key_notify_policy_expire(xp, c);\r\ncase XFRM_MSG_DELPOLICY:\r\ncase XFRM_MSG_NEWPOLICY:\r\ncase XFRM_MSG_UPDPOLICY:\r\nreturn key_notify_policy(xp, dir, c);\r\ncase XFRM_MSG_FLUSHPOLICY:\r\nif (c->data.type != XFRM_POLICY_TYPE_MAIN)\r\nbreak;\r\nreturn key_notify_policy_flush(c);\r\ndefault:\r\npr_err("pfkey: Unknown policy event %d\n", c->event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 get_acqseq(void)\r\n{\r\nu32 res;\r\nstatic atomic_t acqseq;\r\ndo {\r\nres = atomic_inc_return(&acqseq);\r\n} while (!res);\r\nreturn res;\r\n}\r\nstatic bool pfkey_is_alive(const struct km_event *c)\r\n{\r\nstruct netns_pfkey *net_pfkey = net_generic(c->net, pfkey_net_id);\r\nstruct sock *sk;\r\nbool is_alive = false;\r\nrcu_read_lock();\r\nsk_for_each_rcu(sk, &net_pfkey->table) {\r\nif (pfkey_sk(sk)->registered) {\r\nis_alive = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn is_alive;\r\n}\r\nstatic int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *xp)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sadb_msg *hdr;\r\nstruct sadb_address *addr;\r\nstruct sadb_x_policy *pol;\r\nint sockaddr_size;\r\nint size;\r\nstruct sadb_x_sec_ctx *sec_ctx;\r\nstruct xfrm_sec_ctx *xfrm_ctx;\r\nint ctx_size = 0;\r\nsockaddr_size = pfkey_sockaddr_size(x->props.family);\r\nif (!sockaddr_size)\r\nreturn -EINVAL;\r\nsize = sizeof(struct sadb_msg) +\r\n(sizeof(struct sadb_address) * 2) +\r\n(sockaddr_size * 2) +\r\nsizeof(struct sadb_x_policy);\r\nif (x->id.proto == IPPROTO_AH)\r\nsize += count_ah_combs(t);\r\nelse if (x->id.proto == IPPROTO_ESP)\r\nsize += count_esp_combs(t);\r\nif ((xfrm_ctx = x->security)) {\r\nctx_size = PFKEY_ALIGN8(xfrm_ctx->ctx_len);\r\nsize += sizeof(struct sadb_x_sec_ctx) + ctx_size;\r\n}\r\nskb = alloc_skb(size + 16, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nhdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\r\nhdr->sadb_msg_version = PF_KEY_V2;\r\nhdr->sadb_msg_type = SADB_ACQUIRE;\r\nhdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);\r\nhdr->sadb_msg_len = size / sizeof(uint64_t);\r\nhdr->sadb_msg_errno = 0;\r\nhdr->sadb_msg_reserved = 0;\r\nhdr->sadb_msg_seq = x->km.seq = get_acqseq();\r\nhdr->sadb_msg_pid = 0;\r\naddr = (struct sadb_address*) skb_put(skb,\r\nsizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\r\naddr->sadb_address_proto = 0;\r\naddr->sadb_address_reserved = 0;\r\naddr->sadb_address_prefixlen =\r\npfkey_sockaddr_fill(&x->props.saddr, 0,\r\n(struct sockaddr *) (addr + 1),\r\nx->props.family);\r\nif (!addr->sadb_address_prefixlen)\r\nBUG();\r\naddr = (struct sadb_address*) skb_put(skb,\r\nsizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\r\naddr->sadb_address_proto = 0;\r\naddr->sadb_address_reserved = 0;\r\naddr->sadb_address_prefixlen =\r\npfkey_sockaddr_fill(&x->id.daddr, 0,\r\n(struct sockaddr *) (addr + 1),\r\nx->props.family);\r\nif (!addr->sadb_address_prefixlen)\r\nBUG();\r\npol = (struct sadb_x_policy *) skb_put(skb, sizeof(struct sadb_x_policy));\r\npol->sadb_x_policy_len = sizeof(struct sadb_x_policy)/sizeof(uint64_t);\r\npol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\r\npol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\r\npol->sadb_x_policy_dir = XFRM_POLICY_OUT + 1;\r\npol->sadb_x_policy_reserved = 0;\r\npol->sadb_x_policy_id = xp->index;\r\npol->sadb_x_policy_priority = xp->priority;\r\nif (x->id.proto == IPPROTO_AH)\r\ndump_ah_combs(skb, t);\r\nelse if (x->id.proto == IPPROTO_ESP)\r\ndump_esp_combs(skb, t);\r\nif (xfrm_ctx) {\r\nsec_ctx = (struct sadb_x_sec_ctx *) skb_put(skb,\r\nsizeof(struct sadb_x_sec_ctx) + ctx_size);\r\nsec_ctx->sadb_x_sec_len =\r\n(sizeof(struct sadb_x_sec_ctx) + ctx_size) / sizeof(uint64_t);\r\nsec_ctx->sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX;\r\nsec_ctx->sadb_x_ctx_doi = xfrm_ctx->ctx_doi;\r\nsec_ctx->sadb_x_ctx_alg = xfrm_ctx->ctx_alg;\r\nsec_ctx->sadb_x_ctx_len = xfrm_ctx->ctx_len;\r\nmemcpy(sec_ctx + 1, xfrm_ctx->ctx_str,\r\nxfrm_ctx->ctx_len);\r\n}\r\nreturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\r\n}\r\nstatic struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,\r\nu8 *data, int len, int *dir)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct xfrm_policy *xp;\r\nstruct sadb_x_policy *pol = (struct sadb_x_policy*)data;\r\nstruct sadb_x_sec_ctx *sec_ctx;\r\nswitch (sk->sk_family) {\r\ncase AF_INET:\r\nif (opt != IP_IPSEC_POLICY) {\r\n*dir = -EOPNOTSUPP;\r\nreturn NULL;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nif (opt != IPV6_IPSEC_POLICY) {\r\n*dir = -EOPNOTSUPP;\r\nreturn NULL;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\n*dir = -EINVAL;\r\nreturn NULL;\r\n}\r\n*dir = -EINVAL;\r\nif (len < sizeof(struct sadb_x_policy) ||\r\npol->sadb_x_policy_len*8 > len ||\r\npol->sadb_x_policy_type > IPSEC_POLICY_BYPASS ||\r\n(!pol->sadb_x_policy_dir || pol->sadb_x_policy_dir > IPSEC_DIR_OUTBOUND))\r\nreturn NULL;\r\nxp = xfrm_policy_alloc(net, GFP_ATOMIC);\r\nif (xp == NULL) {\r\n*dir = -ENOBUFS;\r\nreturn NULL;\r\n}\r\nxp->action = (pol->sadb_x_policy_type == IPSEC_POLICY_DISCARD ?\r\nXFRM_POLICY_BLOCK : XFRM_POLICY_ALLOW);\r\nxp->lft.soft_byte_limit = XFRM_INF;\r\nxp->lft.hard_byte_limit = XFRM_INF;\r\nxp->lft.soft_packet_limit = XFRM_INF;\r\nxp->lft.hard_packet_limit = XFRM_INF;\r\nxp->family = sk->sk_family;\r\nxp->xfrm_nr = 0;\r\nif (pol->sadb_x_policy_type == IPSEC_POLICY_IPSEC &&\r\n(*dir = parse_ipsecrequests(xp, pol)) < 0)\r\ngoto out;\r\nif (len >= (pol->sadb_x_policy_len*8 +\r\nsizeof(struct sadb_x_sec_ctx))) {\r\nchar *p = (char *)pol;\r\nstruct xfrm_user_sec_ctx *uctx;\r\np += pol->sadb_x_policy_len*8;\r\nsec_ctx = (struct sadb_x_sec_ctx *)p;\r\nif (len < pol->sadb_x_policy_len*8 +\r\nsec_ctx->sadb_x_sec_len) {\r\n*dir = -EINVAL;\r\ngoto out;\r\n}\r\nif ((*dir = verify_sec_ctx_len(p)))\r\ngoto out;\r\nuctx = pfkey_sadb2xfrm_user_sec_ctx(sec_ctx, GFP_ATOMIC);\r\n*dir = security_xfrm_policy_alloc(&xp->security, uctx, GFP_ATOMIC);\r\nkfree(uctx);\r\nif (*dir)\r\ngoto out;\r\n}\r\n*dir = pol->sadb_x_policy_dir-1;\r\nreturn xp;\r\nout:\r\nxp->walk.dead = 1;\r\nxfrm_policy_destroy(xp);\r\nreturn NULL;\r\n}\r\nstatic int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sadb_msg *hdr;\r\nstruct sadb_sa *sa;\r\nstruct sadb_address *addr;\r\nstruct sadb_x_nat_t_port *n_port;\r\nint sockaddr_size;\r\nint size;\r\n__u8 satype = (x->id.proto == IPPROTO_ESP ? SADB_SATYPE_ESP : 0);\r\nstruct xfrm_encap_tmpl *natt = NULL;\r\nsockaddr_size = pfkey_sockaddr_size(x->props.family);\r\nif (!sockaddr_size)\r\nreturn -EINVAL;\r\nif (!satype)\r\nreturn -EINVAL;\r\nif (!x->encap)\r\nreturn -EINVAL;\r\nnatt = x->encap;\r\nsize = sizeof(struct sadb_msg) +\r\nsizeof(struct sadb_sa) +\r\n(sizeof(struct sadb_address) * 2) +\r\n(sockaddr_size * 2) +\r\n(sizeof(struct sadb_x_nat_t_port) * 2);\r\nskb = alloc_skb(size + 16, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nhdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\r\nhdr->sadb_msg_version = PF_KEY_V2;\r\nhdr->sadb_msg_type = SADB_X_NAT_T_NEW_MAPPING;\r\nhdr->sadb_msg_satype = satype;\r\nhdr->sadb_msg_len = size / sizeof(uint64_t);\r\nhdr->sadb_msg_errno = 0;\r\nhdr->sadb_msg_reserved = 0;\r\nhdr->sadb_msg_seq = x->km.seq = get_acqseq();\r\nhdr->sadb_msg_pid = 0;\r\nsa = (struct sadb_sa *) skb_put(skb, sizeof(struct sadb_sa));\r\nsa->sadb_sa_len = sizeof(struct sadb_sa)/sizeof(uint64_t);\r\nsa->sadb_sa_exttype = SADB_EXT_SA;\r\nsa->sadb_sa_spi = x->id.spi;\r\nsa->sadb_sa_replay = 0;\r\nsa->sadb_sa_state = 0;\r\nsa->sadb_sa_auth = 0;\r\nsa->sadb_sa_encrypt = 0;\r\nsa->sadb_sa_flags = 0;\r\naddr = (struct sadb_address*)\r\nskb_put(skb, sizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;\r\naddr->sadb_address_proto = 0;\r\naddr->sadb_address_reserved = 0;\r\naddr->sadb_address_prefixlen =\r\npfkey_sockaddr_fill(&x->props.saddr, 0,\r\n(struct sockaddr *) (addr + 1),\r\nx->props.family);\r\nif (!addr->sadb_address_prefixlen)\r\nBUG();\r\nn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\r\nn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\r\nn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_SPORT;\r\nn_port->sadb_x_nat_t_port_port = natt->encap_sport;\r\nn_port->sadb_x_nat_t_port_reserved = 0;\r\naddr = (struct sadb_address*)\r\nskb_put(skb, sizeof(struct sadb_address)+sockaddr_size);\r\naddr->sadb_address_len =\r\n(sizeof(struct sadb_address)+sockaddr_size)/\r\nsizeof(uint64_t);\r\naddr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;\r\naddr->sadb_address_proto = 0;\r\naddr->sadb_address_reserved = 0;\r\naddr->sadb_address_prefixlen =\r\npfkey_sockaddr_fill(ipaddr, 0,\r\n(struct sockaddr *) (addr + 1),\r\nx->props.family);\r\nif (!addr->sadb_address_prefixlen)\r\nBUG();\r\nn_port = (struct sadb_x_nat_t_port*) skb_put(skb, sizeof (*n_port));\r\nn_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);\r\nn_port->sadb_x_nat_t_port_exttype = SADB_X_EXT_NAT_T_DPORT;\r\nn_port->sadb_x_nat_t_port_port = sport;\r\nn_port->sadb_x_nat_t_port_reserved = 0;\r\nreturn pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));\r\n}\r\nstatic int set_sadb_address(struct sk_buff *skb, int sasize, int type,\r\nconst struct xfrm_selector *sel)\r\n{\r\nstruct sadb_address *addr;\r\naddr = (struct sadb_address *)skb_put(skb, sizeof(struct sadb_address) + sasize);\r\naddr->sadb_address_len = (sizeof(struct sadb_address) + sasize)/8;\r\naddr->sadb_address_exttype = type;\r\naddr->sadb_address_proto = sel->proto;\r\naddr->sadb_address_reserved = 0;\r\nswitch (type) {\r\ncase SADB_EXT_ADDRESS_SRC:\r\naddr->sadb_address_prefixlen = sel->prefixlen_s;\r\npfkey_sockaddr_fill(&sel->saddr, 0,\r\n(struct sockaddr *)(addr + 1),\r\nsel->family);\r\nbreak;\r\ncase SADB_EXT_ADDRESS_DST:\r\naddr->sadb_address_prefixlen = sel->prefixlen_d;\r\npfkey_sockaddr_fill(&sel->daddr, 0,\r\n(struct sockaddr *)(addr + 1),\r\nsel->family);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_sadb_kmaddress(struct sk_buff *skb, const struct xfrm_kmaddress *k)\r\n{\r\nstruct sadb_x_kmaddress *kma;\r\nu8 *sa;\r\nint family = k->family;\r\nint socklen = pfkey_sockaddr_len(family);\r\nint size_req;\r\nsize_req = (sizeof(struct sadb_x_kmaddress) +\r\npfkey_sockaddr_pair_size(family));\r\nkma = (struct sadb_x_kmaddress *)skb_put(skb, size_req);\r\nmemset(kma, 0, size_req);\r\nkma->sadb_x_kmaddress_len = size_req / 8;\r\nkma->sadb_x_kmaddress_exttype = SADB_X_EXT_KMADDRESS;\r\nkma->sadb_x_kmaddress_reserved = k->reserved;\r\nsa = (u8 *)(kma + 1);\r\nif (!pfkey_sockaddr_fill(&k->local, 0, (struct sockaddr *)sa, family) ||\r\n!pfkey_sockaddr_fill(&k->remote, 0, (struct sockaddr *)(sa+socklen), family))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int set_ipsecrequest(struct sk_buff *skb,\r\nuint8_t proto, uint8_t mode, int level,\r\nuint32_t reqid, uint8_t family,\r\nconst xfrm_address_t *src, const xfrm_address_t *dst)\r\n{\r\nstruct sadb_x_ipsecrequest *rq;\r\nu8 *sa;\r\nint socklen = pfkey_sockaddr_len(family);\r\nint size_req;\r\nsize_req = sizeof(struct sadb_x_ipsecrequest) +\r\npfkey_sockaddr_pair_size(family);\r\nrq = (struct sadb_x_ipsecrequest *)skb_put(skb, size_req);\r\nmemset(rq, 0, size_req);\r\nrq->sadb_x_ipsecrequest_len = size_req;\r\nrq->sadb_x_ipsecrequest_proto = proto;\r\nrq->sadb_x_ipsecrequest_mode = mode;\r\nrq->sadb_x_ipsecrequest_level = level;\r\nrq->sadb_x_ipsecrequest_reqid = reqid;\r\nsa = (u8 *) (rq + 1);\r\nif (!pfkey_sockaddr_fill(src, 0, (struct sockaddr *)sa, family) ||\r\n!pfkey_sockaddr_fill(dst, 0, (struct sockaddr *)(sa + socklen), family))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\r\nconst struct xfrm_migrate *m, int num_bundles,\r\nconst struct xfrm_kmaddress *k)\r\n{\r\nint i;\r\nint sasize_sel;\r\nint size = 0;\r\nint size_pol = 0;\r\nstruct sk_buff *skb;\r\nstruct sadb_msg *hdr;\r\nstruct sadb_x_policy *pol;\r\nconst struct xfrm_migrate *mp;\r\nif (type != XFRM_POLICY_TYPE_MAIN)\r\nreturn 0;\r\nif (num_bundles <= 0 || num_bundles > XFRM_MAX_DEPTH)\r\nreturn -EINVAL;\r\nif (k != NULL) {\r\nsize += PFKEY_ALIGN8(sizeof(struct sadb_x_kmaddress) +\r\npfkey_sockaddr_pair_size(k->family));\r\n}\r\nsasize_sel = pfkey_sockaddr_size(sel->family);\r\nif (!sasize_sel)\r\nreturn -EINVAL;\r\nsize += (sizeof(struct sadb_address) + sasize_sel) * 2;\r\nsize_pol += sizeof(struct sadb_x_policy);\r\nfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\r\nsize_pol += sizeof(struct sadb_x_ipsecrequest) +\r\npfkey_sockaddr_pair_size(mp->old_family);\r\nsize_pol += sizeof(struct sadb_x_ipsecrequest) +\r\npfkey_sockaddr_pair_size(mp->new_family);\r\n}\r\nsize += sizeof(struct sadb_msg) + size_pol;\r\nskb = alloc_skb(size, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nhdr = (struct sadb_msg *)skb_put(skb, sizeof(struct sadb_msg));\r\nhdr->sadb_msg_version = PF_KEY_V2;\r\nhdr->sadb_msg_type = SADB_X_MIGRATE;\r\nhdr->sadb_msg_satype = pfkey_proto2satype(m->proto);\r\nhdr->sadb_msg_len = size / 8;\r\nhdr->sadb_msg_errno = 0;\r\nhdr->sadb_msg_reserved = 0;\r\nhdr->sadb_msg_seq = 0;\r\nhdr->sadb_msg_pid = 0;\r\nif (k != NULL && (set_sadb_kmaddress(skb, k) < 0))\r\ngoto err;\r\nset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_SRC, sel);\r\nset_sadb_address(skb, sasize_sel, SADB_EXT_ADDRESS_DST, sel);\r\npol = (struct sadb_x_policy *)skb_put(skb, sizeof(struct sadb_x_policy));\r\npol->sadb_x_policy_len = size_pol / 8;\r\npol->sadb_x_policy_exttype = SADB_X_EXT_POLICY;\r\npol->sadb_x_policy_type = IPSEC_POLICY_IPSEC;\r\npol->sadb_x_policy_dir = dir + 1;\r\npol->sadb_x_policy_reserved = 0;\r\npol->sadb_x_policy_id = 0;\r\npol->sadb_x_policy_priority = 0;\r\nfor (i = 0, mp = m; i < num_bundles; i++, mp++) {\r\nint mode = pfkey_mode_from_xfrm(mp->mode);\r\nif (mode < 0)\r\ngoto err;\r\nif (set_ipsecrequest(skb, mp->proto, mode,\r\n(mp->reqid ? IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\r\nmp->reqid, mp->old_family,\r\n&mp->old_saddr, &mp->old_daddr) < 0)\r\ngoto err;\r\nif (set_ipsecrequest(skb, mp->proto, mode,\r\n(mp->reqid ? IPSEC_LEVEL_UNIQUE : IPSEC_LEVEL_REQUIRE),\r\nmp->reqid, mp->new_family,\r\n&mp->new_saddr, &mp->new_daddr) < 0)\r\ngoto err;\r\n}\r\npfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &init_net);\r\nreturn 0;\r\nerr:\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\r\nconst struct xfrm_migrate *m, int num_bundles,\r\nconst struct xfrm_kmaddress *k)\r\n{\r\nreturn -ENOPROTOOPT;\r\n}\r\nstatic int pfkey_sendmsg(struct kiocb *kiocb,\r\nstruct socket *sock, struct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb = NULL;\r\nstruct sadb_msg *hdr = NULL;\r\nint err;\r\nstruct net *net = sock_net(sk);\r\nerr = -EOPNOTSUPP;\r\nif (msg->msg_flags & MSG_OOB)\r\ngoto out;\r\nerr = -EMSGSIZE;\r\nif ((unsigned int)len > sk->sk_sndbuf - 32)\r\ngoto out;\r\nerr = -ENOBUFS;\r\nskb = alloc_skb(len, GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto out;\r\nerr = -EFAULT;\r\nif (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len))\r\ngoto out;\r\nhdr = pfkey_get_base_msg(skb, &err);\r\nif (!hdr)\r\ngoto out;\r\nmutex_lock(&net->xfrm.xfrm_cfg_mutex);\r\nerr = pfkey_process(sk, skb, hdr);\r\nmutex_unlock(&net->xfrm.xfrm_cfg_mutex);\r\nout:\r\nif (err && hdr && pfkey_error(hdr, err, sk) == 0)\r\nerr = 0;\r\nkfree_skb(skb);\r\nreturn err ? : len;\r\n}\r\nstatic int pfkey_recvmsg(struct kiocb *kiocb,\r\nstruct socket *sock, struct msghdr *msg, size_t len,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct pfkey_sock *pfk = pfkey_sk(sk);\r\nstruct sk_buff *skb;\r\nint copied, err;\r\nerr = -EINVAL;\r\nif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\r\ngoto out;\r\nskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\r\nif (skb == NULL)\r\ngoto out;\r\ncopied = skb->len;\r\nif (copied > len) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nskb_reset_transport_header(skb);\r\nerr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (err)\r\ngoto out_free;\r\nsock_recv_ts_and_drops(msg, sk, skb);\r\nerr = (flags & MSG_TRUNC) ? skb->len : copied;\r\nif (pfk->dump.dump != NULL &&\r\n3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\r\npfkey_do_dump(pfk);\r\nout_free:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nreturn err;\r\n}\r\nstatic int pfkey_seq_show(struct seq_file *f, void *v)\r\n{\r\nstruct sock *s = sk_entry(v);\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(f ,"sk RefCnt Rmem Wmem User Inode\n");\r\nelse\r\nseq_printf(f, "%pK %-6d %-6u %-6u %-6u %-6lu\n",\r\ns,\r\natomic_read(&s->sk_refcnt),\r\nsk_rmem_alloc_get(s),\r\nsk_wmem_alloc_get(s),\r\nfrom_kuid_munged(seq_user_ns(f), sock_i_uid(s)),\r\nsock_i_ino(s)\r\n);\r\nreturn 0;\r\n}\r\nstatic void *pfkey_seq_start(struct seq_file *f, loff_t *ppos)\r\n__acquires(rcu)\r\n{\r\nstruct net *net = seq_file_net(f);\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\nrcu_read_lock();\r\nreturn seq_hlist_start_head_rcu(&net_pfkey->table, *ppos);\r\n}\r\nstatic void *pfkey_seq_next(struct seq_file *f, void *v, loff_t *ppos)\r\n{\r\nstruct net *net = seq_file_net(f);\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\nreturn seq_hlist_next_rcu(v, &net_pfkey->table, ppos);\r\n}\r\nstatic void pfkey_seq_stop(struct seq_file *f, void *v)\r\n__releases(rcu)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int pfkey_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &pfkey_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int __net_init pfkey_init_proc(struct net *net)\r\n{\r\nstruct proc_dir_entry *e;\r\ne = proc_create("pfkey", 0, net->proc_net, &pfkey_proc_ops);\r\nif (e == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit pfkey_exit_proc(struct net *net)\r\n{\r\nremove_proc_entry("pfkey", net->proc_net);\r\n}\r\nstatic inline int pfkey_init_proc(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void pfkey_exit_proc(struct net *net)\r\n{\r\n}\r\nstatic int __net_init pfkey_net_init(struct net *net)\r\n{\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\nint rv;\r\nINIT_HLIST_HEAD(&net_pfkey->table);\r\natomic_set(&net_pfkey->socks_nr, 0);\r\nrv = pfkey_init_proc(net);\r\nreturn rv;\r\n}\r\nstatic void __net_exit pfkey_net_exit(struct net *net)\r\n{\r\nstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\r\npfkey_exit_proc(net);\r\nBUG_ON(!hlist_empty(&net_pfkey->table));\r\n}\r\nstatic void __exit ipsec_pfkey_exit(void)\r\n{\r\nxfrm_unregister_km(&pfkeyv2_mgr);\r\nsock_unregister(PF_KEY);\r\nunregister_pernet_subsys(&pfkey_net_ops);\r\nproto_unregister(&key_proto);\r\n}\r\nstatic int __init ipsec_pfkey_init(void)\r\n{\r\nint err = proto_register(&key_proto, 0);\r\nif (err != 0)\r\ngoto out;\r\nerr = register_pernet_subsys(&pfkey_net_ops);\r\nif (err != 0)\r\ngoto out_unregister_key_proto;\r\nerr = sock_register(&pfkey_family_ops);\r\nif (err != 0)\r\ngoto out_unregister_pernet;\r\nerr = xfrm_register_km(&pfkeyv2_mgr);\r\nif (err != 0)\r\ngoto out_sock_unregister;\r\nout:\r\nreturn err;\r\nout_sock_unregister:\r\nsock_unregister(PF_KEY);\r\nout_unregister_pernet:\r\nunregister_pernet_subsys(&pfkey_net_ops);\r\nout_unregister_key_proto:\r\nproto_unregister(&key_proto);\r\ngoto out;\r\n}
