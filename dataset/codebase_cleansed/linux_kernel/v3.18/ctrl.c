static int\r\nnouveau_control_mthd_pstate_info(struct nouveau_object *object,\r\nvoid *data, u32 size)\r\n{\r\nunion {\r\nstruct nvif_control_pstate_info_v0 v0;\r\n} *args = data;\r\nstruct nouveau_clock *clk = nouveau_clock(object);\r\nint ret;\r\nnv_ioctl(object, "control pstate info size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, false)) {\r\nnv_ioctl(object, "control pstate info vers %d\n",\r\nargs->v0.version);\r\n} else\r\nreturn ret;\r\nif (clk) {\r\nargs->v0.count = clk->state_nr;\r\nargs->v0.ustate_ac = clk->ustate_ac;\r\nargs->v0.ustate_dc = clk->ustate_dc;\r\nargs->v0.pwrsrc = clk->pwrsrc;\r\nargs->v0.pstate = clk->pstate;\r\n} else {\r\nargs->v0.count = 0;\r\nargs->v0.ustate_ac = NVIF_CONTROL_PSTATE_INFO_V0_USTATE_DISABLE;\r\nargs->v0.ustate_dc = NVIF_CONTROL_PSTATE_INFO_V0_USTATE_DISABLE;\r\nargs->v0.pwrsrc = -ENOSYS;\r\nargs->v0.pstate = NVIF_CONTROL_PSTATE_INFO_V0_PSTATE_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_control_mthd_pstate_attr(struct nouveau_object *object,\r\nvoid *data, u32 size)\r\n{\r\nunion {\r\nstruct nvif_control_pstate_attr_v0 v0;\r\n} *args = data;\r\nstruct nouveau_clock *clk = nouveau_clock(object);\r\nstruct nouveau_clocks *domain;\r\nstruct nouveau_pstate *pstate;\r\nstruct nouveau_cstate *cstate;\r\nint i = 0, j = -1;\r\nu32 lo, hi;\r\nint ret;\r\nnv_ioctl(object, "control pstate attr size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, false)) {\r\nnv_ioctl(object, "control pstate attr vers %d state %d "\r\n"index %d\n",\r\nargs->v0.version, args->v0.state, args->v0.index);\r\nif (!clk)\r\nreturn -ENODEV;\r\nif (args->v0.state < NVIF_CONTROL_PSTATE_ATTR_V0_STATE_CURRENT)\r\nreturn -EINVAL;\r\nif (args->v0.state >= clk->state_nr)\r\nreturn -EINVAL;\r\n} else\r\nreturn ret;\r\ndomain = clk->domains;\r\nwhile (domain->name != nv_clk_src_max) {\r\nif (domain->mname && ++j == args->v0.index)\r\nbreak;\r\ndomain++;\r\n}\r\nif (domain->name == nv_clk_src_max)\r\nreturn -EINVAL;\r\nif (args->v0.state != NVIF_CONTROL_PSTATE_ATTR_V0_STATE_CURRENT) {\r\nlist_for_each_entry(pstate, &clk->states, head) {\r\nif (i++ == args->v0.state)\r\nbreak;\r\n}\r\nlo = pstate->base.domain[domain->name];\r\nhi = lo;\r\nlist_for_each_entry(cstate, &pstate->list, head) {\r\nlo = min(lo, cstate->domain[domain->name]);\r\nhi = max(hi, cstate->domain[domain->name]);\r\n}\r\nargs->v0.state = pstate->pstate;\r\n} else {\r\nlo = max(clk->read(clk, domain->name), 0);\r\nhi = lo;\r\n}\r\nsnprintf(args->v0.name, sizeof(args->v0.name), "%s", domain->mname);\r\nsnprintf(args->v0.unit, sizeof(args->v0.unit), "MHz");\r\nargs->v0.min = lo / domain->mdiv;\r\nargs->v0.max = hi / domain->mdiv;\r\nargs->v0.index = 0;\r\nwhile ((++domain)->name != nv_clk_src_max) {\r\nif (domain->mname) {\r\nargs->v0.index = ++j;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_control_mthd_pstate_user(struct nouveau_object *object,\r\nvoid *data, u32 size)\r\n{\r\nunion {\r\nstruct nvif_control_pstate_user_v0 v0;\r\n} *args = data;\r\nstruct nouveau_clock *clk = nouveau_clock(object);\r\nint ret;\r\nnv_ioctl(object, "control pstate user size %d\n", size);\r\nif (nvif_unpack(args->v0, 0, 0, false)) {\r\nnv_ioctl(object, "control pstate user vers %d ustate %d "\r\n"pwrsrc %d\n", args->v0.version,\r\nargs->v0.ustate, args->v0.pwrsrc);\r\nif (!clk)\r\nreturn -ENODEV;\r\n} else\r\nreturn ret;\r\nif (args->v0.pwrsrc >= 0) {\r\nret |= nouveau_clock_ustate(clk, args->v0.ustate, args->v0.pwrsrc);\r\n} else {\r\nret |= nouveau_clock_ustate(clk, args->v0.ustate, 0);\r\nret |= nouveau_clock_ustate(clk, args->v0.ustate, 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnouveau_control_mthd(struct nouveau_object *object, u32 mthd,\r\nvoid *data, u32 size)\r\n{\r\nswitch (mthd) {\r\ncase NVIF_CONTROL_PSTATE_INFO:\r\nreturn nouveau_control_mthd_pstate_info(object, data, size);\r\ncase NVIF_CONTROL_PSTATE_ATTR:\r\nreturn nouveau_control_mthd_pstate_attr(object, data, size);\r\ncase NVIF_CONTROL_PSTATE_USER:\r\nreturn nouveau_control_mthd_pstate_user(object, data, size);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}
