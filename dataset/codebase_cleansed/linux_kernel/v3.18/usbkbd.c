static void usb_kbd_irq(struct urb *urb)\r\n{\r\nstruct usb_kbd *kbd = urb->context;\r\nint i;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ngoto resubmit;\r\n}\r\nfor (i = 0; i < 8; i++)\r\ninput_report_key(kbd->dev, usb_kbd_keycode[i + 224], (kbd->new[0] >> i) & 1);\r\nfor (i = 2; i < 8; i++) {\r\nif (kbd->old[i] > 3 && memscan(kbd->new + 2, kbd->old[i], 6) == kbd->new + 8) {\r\nif (usb_kbd_keycode[kbd->old[i]])\r\ninput_report_key(kbd->dev, usb_kbd_keycode[kbd->old[i]], 0);\r\nelse\r\nhid_info(urb->dev,\r\n"Unknown key (scancode %#x) released.\n",\r\nkbd->old[i]);\r\n}\r\nif (kbd->new[i] > 3 && memscan(kbd->old + 2, kbd->new[i], 6) == kbd->old + 8) {\r\nif (usb_kbd_keycode[kbd->new[i]])\r\ninput_report_key(kbd->dev, usb_kbd_keycode[kbd->new[i]], 1);\r\nelse\r\nhid_info(urb->dev,\r\n"Unknown key (scancode %#x) pressed.\n",\r\nkbd->new[i]);\r\n}\r\n}\r\ninput_sync(kbd->dev);\r\nmemcpy(kbd->old, kbd->new, 8);\r\nresubmit:\r\ni = usb_submit_urb (urb, GFP_ATOMIC);\r\nif (i)\r\nhid_err(urb->dev, "can't resubmit intr, %s-%s/input0, status %d",\r\nkbd->usbdev->bus->bus_name,\r\nkbd->usbdev->devpath, i);\r\n}\r\nstatic int usb_kbd_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nunsigned long flags;\r\nstruct usb_kbd *kbd = input_get_drvdata(dev);\r\nif (type != EV_LED)\r\nreturn -1;\r\nspin_lock_irqsave(&kbd->leds_lock, flags);\r\nkbd->newleds = (!!test_bit(LED_KANA, dev->led) << 3) | (!!test_bit(LED_COMPOSE, dev->led) << 3) |\r\n(!!test_bit(LED_SCROLLL, dev->led) << 2) | (!!test_bit(LED_CAPSL, dev->led) << 1) |\r\n(!!test_bit(LED_NUML, dev->led));\r\nif (kbd->led_urb_submitted){\r\nspin_unlock_irqrestore(&kbd->leds_lock, flags);\r\nreturn 0;\r\n}\r\nif (*(kbd->leds) == kbd->newleds){\r\nspin_unlock_irqrestore(&kbd->leds_lock, flags);\r\nreturn 0;\r\n}\r\n*(kbd->leds) = kbd->newleds;\r\nkbd->led->dev = kbd->usbdev;\r\nif (usb_submit_urb(kbd->led, GFP_ATOMIC))\r\npr_err("usb_submit_urb(leds) failed\n");\r\nelse\r\nkbd->led_urb_submitted = true;\r\nspin_unlock_irqrestore(&kbd->leds_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void usb_kbd_led(struct urb *urb)\r\n{\r\nunsigned long flags;\r\nstruct usb_kbd *kbd = urb->context;\r\nif (urb->status)\r\nhid_warn(urb->dev, "led urb status %d received\n",\r\nurb->status);\r\nspin_lock_irqsave(&kbd->leds_lock, flags);\r\nif (*(kbd->leds) == kbd->newleds){\r\nkbd->led_urb_submitted = false;\r\nspin_unlock_irqrestore(&kbd->leds_lock, flags);\r\nreturn;\r\n}\r\n*(kbd->leds) = kbd->newleds;\r\nkbd->led->dev = kbd->usbdev;\r\nif (usb_submit_urb(kbd->led, GFP_ATOMIC)){\r\nhid_err(urb->dev, "usb_submit_urb(leds) failed\n");\r\nkbd->led_urb_submitted = false;\r\n}\r\nspin_unlock_irqrestore(&kbd->leds_lock, flags);\r\n}\r\nstatic int usb_kbd_open(struct input_dev *dev)\r\n{\r\nstruct usb_kbd *kbd = input_get_drvdata(dev);\r\nkbd->irq->dev = kbd->usbdev;\r\nif (usb_submit_urb(kbd->irq, GFP_KERNEL))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void usb_kbd_close(struct input_dev *dev)\r\n{\r\nstruct usb_kbd *kbd = input_get_drvdata(dev);\r\nusb_kill_urb(kbd->irq);\r\n}\r\nstatic int usb_kbd_alloc_mem(struct usb_device *dev, struct usb_kbd *kbd)\r\n{\r\nif (!(kbd->irq = usb_alloc_urb(0, GFP_KERNEL)))\r\nreturn -1;\r\nif (!(kbd->led = usb_alloc_urb(0, GFP_KERNEL)))\r\nreturn -1;\r\nif (!(kbd->new = usb_alloc_coherent(dev, 8, GFP_ATOMIC, &kbd->new_dma)))\r\nreturn -1;\r\nif (!(kbd->cr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL)))\r\nreturn -1;\r\nif (!(kbd->leds = usb_alloc_coherent(dev, 1, GFP_ATOMIC, &kbd->leds_dma)))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void usb_kbd_free_mem(struct usb_device *dev, struct usb_kbd *kbd)\r\n{\r\nusb_free_urb(kbd->irq);\r\nusb_free_urb(kbd->led);\r\nusb_free_coherent(dev, 8, kbd->new, kbd->new_dma);\r\nkfree(kbd->cr);\r\nusb_free_coherent(dev, 1, kbd->leds, kbd->leds_dma);\r\n}\r\nstatic int usb_kbd_probe(struct usb_interface *iface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(iface);\r\nstruct usb_host_interface *interface;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_kbd *kbd;\r\nstruct input_dev *input_dev;\r\nint i, pipe, maxp;\r\nint error = -ENOMEM;\r\ninterface = iface->cur_altsetting;\r\nif (interface->desc.bNumEndpoints != 1)\r\nreturn -ENODEV;\r\nendpoint = &interface->endpoint[0].desc;\r\nif (!usb_endpoint_is_int_in(endpoint))\r\nreturn -ENODEV;\r\npipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\r\nmaxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));\r\nkbd = kzalloc(sizeof(struct usb_kbd), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!kbd || !input_dev)\r\ngoto fail1;\r\nif (usb_kbd_alloc_mem(dev, kbd))\r\ngoto fail2;\r\nkbd->usbdev = dev;\r\nkbd->dev = input_dev;\r\nspin_lock_init(&kbd->leds_lock);\r\nif (dev->manufacturer)\r\nstrlcpy(kbd->name, dev->manufacturer, sizeof(kbd->name));\r\nif (dev->product) {\r\nif (dev->manufacturer)\r\nstrlcat(kbd->name, " ", sizeof(kbd->name));\r\nstrlcat(kbd->name, dev->product, sizeof(kbd->name));\r\n}\r\nif (!strlen(kbd->name))\r\nsnprintf(kbd->name, sizeof(kbd->name),\r\n"USB HIDBP Keyboard %04x:%04x",\r\nle16_to_cpu(dev->descriptor.idVendor),\r\nle16_to_cpu(dev->descriptor.idProduct));\r\nusb_make_path(dev, kbd->phys, sizeof(kbd->phys));\r\nstrlcat(kbd->phys, "/input0", sizeof(kbd->phys));\r\ninput_dev->name = kbd->name;\r\ninput_dev->phys = kbd->phys;\r\nusb_to_input_id(dev, &input_dev->id);\r\ninput_dev->dev.parent = &iface->dev;\r\ninput_set_drvdata(input_dev, kbd);\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\r\nBIT_MASK(EV_REP);\r\ninput_dev->ledbit[0] = BIT_MASK(LED_NUML) | BIT_MASK(LED_CAPSL) |\r\nBIT_MASK(LED_SCROLLL) | BIT_MASK(LED_COMPOSE) |\r\nBIT_MASK(LED_KANA);\r\nfor (i = 0; i < 255; i++)\r\nset_bit(usb_kbd_keycode[i], input_dev->keybit);\r\nclear_bit(0, input_dev->keybit);\r\ninput_dev->event = usb_kbd_event;\r\ninput_dev->open = usb_kbd_open;\r\ninput_dev->close = usb_kbd_close;\r\nusb_fill_int_urb(kbd->irq, dev, pipe,\r\nkbd->new, (maxp > 8 ? 8 : maxp),\r\nusb_kbd_irq, kbd, endpoint->bInterval);\r\nkbd->irq->transfer_dma = kbd->new_dma;\r\nkbd->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nkbd->cr->bRequestType = USB_TYPE_CLASS | USB_RECIP_INTERFACE;\r\nkbd->cr->bRequest = 0x09;\r\nkbd->cr->wValue = cpu_to_le16(0x200);\r\nkbd->cr->wIndex = cpu_to_le16(interface->desc.bInterfaceNumber);\r\nkbd->cr->wLength = cpu_to_le16(1);\r\nusb_fill_control_urb(kbd->led, dev, usb_sndctrlpipe(dev, 0),\r\n(void *) kbd->cr, kbd->leds, 1,\r\nusb_kbd_led, kbd);\r\nkbd->led->transfer_dma = kbd->leds_dma;\r\nkbd->led->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nerror = input_register_device(kbd->dev);\r\nif (error)\r\ngoto fail2;\r\nusb_set_intfdata(iface, kbd);\r\ndevice_set_wakeup_enable(&dev->dev, 1);\r\nreturn 0;\r\nfail2:\r\nusb_kbd_free_mem(dev, kbd);\r\nfail1:\r\ninput_free_device(input_dev);\r\nkfree(kbd);\r\nreturn error;\r\n}\r\nstatic void usb_kbd_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_kbd *kbd = usb_get_intfdata (intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (kbd) {\r\nusb_kill_urb(kbd->irq);\r\ninput_unregister_device(kbd->dev);\r\nusb_kill_urb(kbd->led);\r\nusb_kbd_free_mem(interface_to_usbdev(intf), kbd);\r\nkfree(kbd);\r\n}\r\n}
