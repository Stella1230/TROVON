static void drain_midi_queue(int dev)\r\n{\r\nif (midi_devs[dev]->buffer_status != NULL)\r\nwait_event_interruptible_timeout(midi_sleeper[dev],\r\n!midi_devs[dev]->buffer_status(dev), HZ/10);\r\n}\r\nstatic void midi_input_intr(int dev, unsigned char data)\r\n{\r\nif (midi_in_buf[dev] == NULL)\r\nreturn;\r\nif (data == 0xfe)\r\nreturn;\r\nif (SPACE_AVAIL(midi_in_buf[dev])) {\r\nQUEUE_BYTE(midi_in_buf[dev], data);\r\nwake_up(&input_sleeper[dev]);\r\n}\r\n}\r\nstatic void midi_output_intr(int dev)\r\n{\r\n}\r\nstatic void midi_poll(unsigned long dummy)\r\n{\r\nunsigned long flags;\r\nint dev;\r\nspin_lock_irqsave(&lock, flags);\r\nif (open_devs)\r\n{\r\nfor (dev = 0; dev < num_midis; dev++)\r\nif (midi_devs[dev] != NULL && midi_out_buf[dev] != NULL)\r\n{\r\nwhile (DATA_AVAIL(midi_out_buf[dev]))\r\n{\r\nint ok;\r\nint c = midi_out_buf[dev]->queue[midi_out_buf[dev]->head];\r\nspin_unlock_irqrestore(&lock,flags);\r\nok = midi_devs[dev]->outputc(dev, c);\r\nspin_lock_irqsave(&lock, flags);\r\nif (!ok)\r\nbreak;\r\nmidi_out_buf[dev]->head = (midi_out_buf[dev]->head + 1) % MAX_QUEUE_SIZE;\r\nmidi_out_buf[dev]->len--;\r\n}\r\nif (DATA_AVAIL(midi_out_buf[dev]) < 100)\r\nwake_up(&midi_sleeper[dev]);\r\n}\r\npoll_timer.expires = (1) + jiffies;\r\nadd_timer(&poll_timer);\r\n}\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\nint MIDIbuf_open(int dev, struct file *file)\r\n{\r\nint mode, err;\r\ndev = dev >> 4;\r\nmode = translate_mode(file);\r\nif (num_midis > MAX_MIDI_DEV)\r\n{\r\nprintk(KERN_ERR "midi: Too many midi interfaces\n");\r\nnum_midis = MAX_MIDI_DEV;\r\n}\r\nif (dev < 0 || dev >= num_midis || midi_devs[dev] == NULL)\r\nreturn -ENXIO;\r\nmodule_put(midi_devs[dev]->owner);\r\nif ((err = midi_devs[dev]->open(dev, mode,\r\nmidi_input_intr, midi_output_intr)) < 0)\r\nreturn err;\r\nparms[dev].prech_timeout = MAX_SCHEDULE_TIMEOUT;\r\nmidi_in_buf[dev] = vmalloc(sizeof(struct midi_buf));\r\nif (midi_in_buf[dev] == NULL)\r\n{\r\nprintk(KERN_WARNING "midi: Can't allocate buffer\n");\r\nmidi_devs[dev]->close(dev);\r\nreturn -EIO;\r\n}\r\nmidi_in_buf[dev]->len = midi_in_buf[dev]->head = midi_in_buf[dev]->tail = 0;\r\nmidi_out_buf[dev] = vmalloc(sizeof(struct midi_buf));\r\nif (midi_out_buf[dev] == NULL)\r\n{\r\nprintk(KERN_WARNING "midi: Can't allocate buffer\n");\r\nmidi_devs[dev]->close(dev);\r\nvfree(midi_in_buf[dev]);\r\nmidi_in_buf[dev] = NULL;\r\nreturn -EIO;\r\n}\r\nmidi_out_buf[dev]->len = midi_out_buf[dev]->head = midi_out_buf[dev]->tail = 0;\r\nopen_devs++;\r\ninit_waitqueue_head(&midi_sleeper[dev]);\r\ninit_waitqueue_head(&input_sleeper[dev]);\r\nif (open_devs < 2)\r\n{\r\npoll_timer.expires = 1 + jiffies;\r\nadd_timer(&poll_timer);\r\n}\r\nreturn err;\r\n}\r\nvoid MIDIbuf_release(int dev, struct file *file)\r\n{\r\nint mode;\r\ndev = dev >> 4;\r\nmode = translate_mode(file);\r\nif (dev < 0 || dev >= num_midis || midi_devs[dev] == NULL)\r\nreturn;\r\nif (mode != OPEN_READ)\r\n{\r\nmidi_devs[dev]->outputc(dev, 0xfe);\r\nwait_event_interruptible(midi_sleeper[dev],\r\n!DATA_AVAIL(midi_out_buf[dev]));\r\ndrain_midi_queue(dev);\r\n}\r\nmidi_devs[dev]->close(dev);\r\nopen_devs--;\r\nif (open_devs == 0)\r\ndel_timer_sync(&poll_timer);\r\nvfree(midi_in_buf[dev]);\r\nvfree(midi_out_buf[dev]);\r\nmidi_in_buf[dev] = NULL;\r\nmidi_out_buf[dev] = NULL;\r\nmodule_put(midi_devs[dev]->owner);\r\n}\r\nint MIDIbuf_write(int dev, struct file *file, const char __user *buf, int count)\r\n{\r\nint c, n, i;\r\nunsigned char tmp_data;\r\ndev = dev >> 4;\r\nif (!count)\r\nreturn 0;\r\nc = 0;\r\nwhile (c < count)\r\n{\r\nn = SPACE_AVAIL(midi_out_buf[dev]);\r\nif (n == 0) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nc = -EAGAIN;\r\ngoto out;\r\n}\r\nif (wait_event_interruptible(midi_sleeper[dev],\r\nSPACE_AVAIL(midi_out_buf[dev])))\r\n{\r\nc = -EINTR;\r\ngoto out;\r\n}\r\nn = SPACE_AVAIL(midi_out_buf[dev]);\r\n}\r\nif (n > (count - c))\r\nn = count - c;\r\nfor (i = 0; i < n; i++)\r\n{\r\nif (copy_from_user((char *) &tmp_data, &(buf)[c], 1)) {\r\nc = -EFAULT;\r\ngoto out;\r\n}\r\nQUEUE_BYTE(midi_out_buf[dev], tmp_data);\r\nc++;\r\n}\r\n}\r\nout:\r\nreturn c;\r\n}\r\nint MIDIbuf_read(int dev, struct file *file, char __user *buf, int count)\r\n{\r\nint n, c = 0;\r\nunsigned char tmp_data;\r\ndev = dev >> 4;\r\nif (!DATA_AVAIL(midi_in_buf[dev])) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nc = -EAGAIN;\r\ngoto out;\r\n}\r\nwait_event_interruptible_timeout(input_sleeper[dev],\r\nDATA_AVAIL(midi_in_buf[dev]),\r\nparms[dev].prech_timeout);\r\nif (signal_pending(current))\r\nc = -EINTR;\r\n}\r\nif (c == 0 && DATA_AVAIL(midi_in_buf[dev]))\r\n{\r\nn = DATA_AVAIL(midi_in_buf[dev]);\r\nif (n > count)\r\nn = count;\r\nc = 0;\r\nwhile (c < n)\r\n{\r\nchar *fixit;\r\nREMOVE_BYTE(midi_in_buf[dev], tmp_data);\r\nfixit = (char *) &tmp_data;\r\nif (copy_to_user(&(buf)[c], fixit, 1)) {\r\nc = -EFAULT;\r\ngoto out;\r\n}\r\nc++;\r\n}\r\n}\r\nout:\r\nreturn c;\r\n}\r\nint MIDIbuf_ioctl(int dev, struct file *file,\r\nunsigned int cmd, void __user *arg)\r\n{\r\nint val;\r\ndev = dev >> 4;\r\nif (((cmd >> 8) & 0xff) == 'C')\r\n{\r\nif (midi_devs[dev]->coproc)\r\nreturn midi_devs[dev]->coproc->ioctl(midi_devs[dev]->coproc->devc, cmd, arg, 0);\r\nreturn -ENXIO;\r\n}\r\nelse\r\n{\r\nswitch (cmd)\r\n{\r\ncase SNDCTL_MIDI_PRETIME:\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nif (val < 0)\r\nval = 0;\r\nval = (HZ * val) / 10;\r\nparms[dev].prech_timeout = val;\r\nreturn put_user(val, (int __user *)arg);\r\ndefault:\r\nif (!midi_devs[dev]->ioctl)\r\nreturn -EINVAL;\r\nreturn midi_devs[dev]->ioctl(dev, cmd, arg);\r\n}\r\n}\r\n}\r\nunsigned int MIDIbuf_poll(int dev, struct file *file, poll_table * wait)\r\n{\r\nunsigned int mask = 0;\r\ndev = dev >> 4;\r\npoll_wait(file, &input_sleeper[dev], wait);\r\nif (DATA_AVAIL(midi_in_buf[dev]))\r\nmask |= POLLIN | POLLRDNORM;\r\npoll_wait(file, &midi_sleeper[dev], wait);\r\nif (!SPACE_AVAIL(midi_out_buf[dev]))\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nint MIDIbuf_avail(int dev)\r\n{\r\nif (midi_in_buf[dev])\r\nreturn DATA_AVAIL (midi_in_buf[dev]);\r\nreturn 0;\r\n}
