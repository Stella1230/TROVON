static void nftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\r\n{\r\nstruct NFTLrecord *nftl;\r\nunsigned long temp;\r\nif (!mtd_type_is_nand(mtd) || mtd->size > UINT_MAX)\r\nreturn;\r\nif (memcmp(mtd->name, "DiskOnChip", 10))\r\nreturn;\r\npr_debug("NFTL: add_mtd for %s\n", mtd->name);\r\nnftl = kzalloc(sizeof(struct NFTLrecord), GFP_KERNEL);\r\nif (!nftl)\r\nreturn;\r\nnftl->mbd.mtd = mtd;\r\nnftl->mbd.devnum = -1;\r\nnftl->mbd.tr = tr;\r\nif (NFTL_mount(nftl) < 0) {\r\nprintk(KERN_WARNING "NFTL: could not mount device\n");\r\nkfree(nftl);\r\nreturn;\r\n}\r\nnftl->cylinders = 1024;\r\nnftl->heads = 16;\r\ntemp = nftl->cylinders * nftl->heads;\r\nnftl->sectors = nftl->mbd.size / temp;\r\nif (nftl->mbd.size % temp) {\r\nnftl->sectors++;\r\ntemp = nftl->cylinders * nftl->sectors;\r\nnftl->heads = nftl->mbd.size / temp;\r\nif (nftl->mbd.size % temp) {\r\nnftl->heads++;\r\ntemp = nftl->heads * nftl->sectors;\r\nnftl->cylinders = nftl->mbd.size / temp;\r\n}\r\n}\r\nif (nftl->mbd.size != nftl->heads * nftl->cylinders * nftl->sectors) {\r\nprintk(KERN_WARNING "NFTL: cannot calculate a geometry to "\r\n"match size of 0x%lx.\n", nftl->mbd.size);\r\nprintk(KERN_WARNING "NFTL: using C:%d H:%d S:%d "\r\n"(== 0x%lx sects)\n",\r\nnftl->cylinders, nftl->heads , nftl->sectors,\r\n(long)nftl->cylinders * (long)nftl->heads *\r\n(long)nftl->sectors );\r\n}\r\nif (add_mtd_blktrans_dev(&nftl->mbd)) {\r\nkfree(nftl->ReplUnitTable);\r\nkfree(nftl->EUNtable);\r\nkfree(nftl);\r\nreturn;\r\n}\r\n#ifdef PSYCHO_DEBUG\r\nprintk(KERN_INFO "NFTL: Found new nftl%c\n", nftl->mbd.devnum + 'a');\r\n#endif\r\n}\r\nstatic void nftl_remove_dev(struct mtd_blktrans_dev *dev)\r\n{\r\nstruct NFTLrecord *nftl = (void *)dev;\r\npr_debug("NFTL: remove_dev (i=%d)\n", dev->devnum);\r\ndel_mtd_blktrans_dev(dev);\r\nkfree(nftl->ReplUnitTable);\r\nkfree(nftl->EUNtable);\r\n}\r\nint nftl_read_oob(struct mtd_info *mtd, loff_t offs, size_t len,\r\nsize_t *retlen, uint8_t *buf)\r\n{\r\nloff_t mask = mtd->writesize - 1;\r\nstruct mtd_oob_ops ops;\r\nint res;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.ooboffs = offs & mask;\r\nops.ooblen = len;\r\nops.oobbuf = buf;\r\nops.datbuf = NULL;\r\nres = mtd_read_oob(mtd, offs & ~mask, &ops);\r\n*retlen = ops.oobretlen;\r\nreturn res;\r\n}\r\nint nftl_write_oob(struct mtd_info *mtd, loff_t offs, size_t len,\r\nsize_t *retlen, uint8_t *buf)\r\n{\r\nloff_t mask = mtd->writesize - 1;\r\nstruct mtd_oob_ops ops;\r\nint res;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.ooboffs = offs & mask;\r\nops.ooblen = len;\r\nops.oobbuf = buf;\r\nops.datbuf = NULL;\r\nres = mtd_write_oob(mtd, offs & ~mask, &ops);\r\n*retlen = ops.oobretlen;\r\nreturn res;\r\n}\r\nstatic int nftl_write(struct mtd_info *mtd, loff_t offs, size_t len,\r\nsize_t *retlen, uint8_t *buf, uint8_t *oob)\r\n{\r\nloff_t mask = mtd->writesize - 1;\r\nstruct mtd_oob_ops ops;\r\nint res;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.ooboffs = offs & mask;\r\nops.ooblen = mtd->oobsize;\r\nops.oobbuf = oob;\r\nops.datbuf = buf;\r\nops.len = len;\r\nres = mtd_write_oob(mtd, offs & ~mask, &ops);\r\n*retlen = ops.retlen;\r\nreturn res;\r\n}\r\nstatic u16 NFTL_findfreeblock(struct NFTLrecord *nftl, int desperate )\r\n{\r\nu16 pot = nftl->LastFreeEUN;\r\nint silly = nftl->nb_blocks;\r\nif (!desperate && nftl->numfreeEUNs < 2) {\r\npr_debug("NFTL_findfreeblock: there are too few free EUNs\n");\r\nreturn BLOCK_NIL;\r\n}\r\ndo {\r\nif (nftl->ReplUnitTable[pot] == BLOCK_FREE) {\r\nnftl->LastFreeEUN = pot;\r\nnftl->numfreeEUNs--;\r\nreturn pot;\r\n}\r\nif (++pot > nftl->lastEUN)\r\npot = le16_to_cpu(nftl->MediaHdr.FirstPhysicalEUN);\r\nif (!silly--) {\r\nprintk("Argh! No free blocks found! LastFreeEUN = %d, "\r\n"FirstEUN = %d\n", nftl->LastFreeEUN,\r\nle16_to_cpu(nftl->MediaHdr.FirstPhysicalEUN));\r\nreturn BLOCK_NIL;\r\n}\r\n} while (pot != nftl->LastFreeEUN);\r\nreturn BLOCK_NIL;\r\n}\r\nstatic u16 NFTL_foldchain (struct NFTLrecord *nftl, unsigned thisVUC, unsigned pendingblock )\r\n{\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nu16 BlockMap[MAX_SECTORS_PER_UNIT];\r\nunsigned char BlockLastState[MAX_SECTORS_PER_UNIT];\r\nunsigned char BlockFreeFound[MAX_SECTORS_PER_UNIT];\r\nunsigned int thisEUN;\r\nint block;\r\nint silly;\r\nunsigned int targetEUN;\r\nstruct nftl_oob oob;\r\nint inplace = 1;\r\nsize_t retlen;\r\nmemset(BlockMap, 0xff, sizeof(BlockMap));\r\nmemset(BlockFreeFound, 0, sizeof(BlockFreeFound));\r\nthisEUN = nftl->EUNtable[thisVUC];\r\nif (thisEUN == BLOCK_NIL) {\r\nprintk(KERN_WARNING "Trying to fold non-existent "\r\n"Virtual Unit Chain %d!\n", thisVUC);\r\nreturn BLOCK_NIL;\r\n}\r\nsilly = MAX_LOOPS;\r\ntargetEUN = BLOCK_NIL;\r\nwhile (thisEUN <= nftl->lastEUN ) {\r\nunsigned int status, foldmark;\r\ntargetEUN = thisEUN;\r\nfor (block = 0; block < nftl->EraseSize / 512; block ++) {\r\nnftl_read_oob(mtd, (thisEUN * nftl->EraseSize) +\r\n(block * 512), 16 , &retlen,\r\n(char *)&oob);\r\nif (block == 2) {\r\nfoldmark = oob.u.c.FoldMark | oob.u.c.FoldMark1;\r\nif (foldmark == FOLD_MARK_IN_PROGRESS) {\r\npr_debug("Write Inhibited on EUN %d\n", thisEUN);\r\ninplace = 0;\r\n} else {\r\ninplace = 1;\r\n}\r\n}\r\nstatus = oob.b.Status | oob.b.Status1;\r\nBlockLastState[block] = status;\r\nswitch(status) {\r\ncase SECTOR_FREE:\r\nBlockFreeFound[block] = 1;\r\nbreak;\r\ncase SECTOR_USED:\r\nif (!BlockFreeFound[block])\r\nBlockMap[block] = thisEUN;\r\nelse\r\nprintk(KERN_WARNING\r\n"SECTOR_USED found after SECTOR_FREE "\r\n"in Virtual Unit Chain %d for block %d\n",\r\nthisVUC, block);\r\nbreak;\r\ncase SECTOR_DELETED:\r\nif (!BlockFreeFound[block])\r\nBlockMap[block] = BLOCK_NIL;\r\nelse\r\nprintk(KERN_WARNING\r\n"SECTOR_DELETED found after SECTOR_FREE "\r\n"in Virtual Unit Chain %d for block %d\n",\r\nthisVUC, block);\r\nbreak;\r\ncase SECTOR_IGNORE:\r\nbreak;\r\ndefault:\r\nprintk("Unknown status for block %d in EUN %d: %x\n",\r\nblock, thisEUN, status);\r\n}\r\n}\r\nif (!silly--) {\r\nprintk(KERN_WARNING "Infinite loop in Virtual Unit Chain 0x%x\n",\r\nthisVUC);\r\nreturn BLOCK_NIL;\r\n}\r\nthisEUN = nftl->ReplUnitTable[thisEUN];\r\n}\r\nif (inplace) {\r\nfor (block = 0; block < nftl->EraseSize / 512 ; block++) {\r\nif (BlockLastState[block] != SECTOR_FREE &&\r\nBlockMap[block] != BLOCK_NIL &&\r\nBlockMap[block] != targetEUN) {\r\npr_debug("Setting inplace to 0. VUC %d, "\r\n"block %d was %x lastEUN, "\r\n"and is in EUN %d (%s) %d\n",\r\nthisVUC, block, BlockLastState[block],\r\nBlockMap[block],\r\nBlockMap[block]== targetEUN ? "==" : "!=",\r\ntargetEUN);\r\ninplace = 0;\r\nbreak;\r\n}\r\n}\r\nif (pendingblock >= (thisVUC * (nftl->EraseSize / 512)) &&\r\npendingblock < ((thisVUC + 1)* (nftl->EraseSize / 512)) &&\r\nBlockLastState[pendingblock - (thisVUC * (nftl->EraseSize / 512))] !=\r\nSECTOR_FREE) {\r\npr_debug("Pending write not free in EUN %d. "\r\n"Folding out of place.\n", targetEUN);\r\ninplace = 0;\r\n}\r\n}\r\nif (!inplace) {\r\npr_debug("Cannot fold Virtual Unit Chain %d in place. "\r\n"Trying out-of-place\n", thisVUC);\r\ntargetEUN = NFTL_findfreeblock(nftl, 1);\r\nif (targetEUN == BLOCK_NIL) {\r\nprintk(KERN_WARNING\r\n"NFTL_findfreeblock(desperate) returns 0xffff.\n");\r\nreturn BLOCK_NIL;\r\n}\r\n} else {\r\noob.u.c.FoldMark = oob.u.c.FoldMark1 = cpu_to_le16(FOLD_MARK_IN_PROGRESS);\r\noob.u.c.unused = 0xffffffff;\r\nnftl_write_oob(mtd, (nftl->EraseSize * targetEUN) + 2 * 512 + 8,\r\n8, &retlen, (char *)&oob.u);\r\n}\r\npr_debug("Folding chain %d into unit %d\n", thisVUC, targetEUN);\r\nfor (block = 0; block < nftl->EraseSize / 512 ; block++) {\r\nunsigned char movebuf[512];\r\nint ret;\r\nif (BlockMap[block] == targetEUN ||\r\n(pendingblock == (thisVUC * (nftl->EraseSize / 512) + block))) {\r\ncontinue;\r\n}\r\nif (BlockMap[block] == BLOCK_NIL)\r\ncontinue;\r\nret = mtd_read(mtd,\r\n(nftl->EraseSize * BlockMap[block]) + (block * 512),\r\n512,\r\n&retlen,\r\nmovebuf);\r\nif (ret < 0 && !mtd_is_bitflip(ret)) {\r\nret = mtd_read(mtd,\r\n(nftl->EraseSize * BlockMap[block]) + (block * 512),\r\n512,\r\n&retlen,\r\nmovebuf);\r\nif (ret != -EIO)\r\nprintk("Error went away on retry.\n");\r\n}\r\nmemset(&oob, 0xff, sizeof(struct nftl_oob));\r\noob.b.Status = oob.b.Status1 = SECTOR_USED;\r\nnftl_write(nftl->mbd.mtd, (nftl->EraseSize * targetEUN) +\r\n(block * 512), 512, &retlen, movebuf, (char *)&oob);\r\n}\r\noob.u.a.VirtUnitNum = oob.u.a.SpareVirtUnitNum = cpu_to_le16(thisVUC);\r\noob.u.a.ReplUnitNum = oob.u.a.SpareReplUnitNum = BLOCK_NIL;\r\nnftl_write_oob(mtd, (nftl->EraseSize * targetEUN) + 8,\r\n8, &retlen, (char *)&oob.u);\r\nthisEUN = nftl->EUNtable[thisVUC];\r\npr_debug("Want to erase\n");\r\nwhile (thisEUN <= nftl->lastEUN && thisEUN != targetEUN) {\r\nunsigned int EUNtmp;\r\nEUNtmp = nftl->ReplUnitTable[thisEUN];\r\nif (NFTL_formatblock(nftl, thisEUN) < 0) {\r\nnftl->ReplUnitTable[thisEUN] = BLOCK_RESERVED;\r\n} else {\r\nnftl->ReplUnitTable[thisEUN] = BLOCK_FREE;\r\nnftl->numfreeEUNs++;\r\n}\r\nthisEUN = EUNtmp;\r\n}\r\nnftl->ReplUnitTable[targetEUN] = BLOCK_NIL;\r\nnftl->EUNtable[thisVUC] = targetEUN;\r\nreturn targetEUN;\r\n}\r\nstatic u16 NFTL_makefreeblock( struct NFTLrecord *nftl , unsigned pendingblock)\r\n{\r\nu16 LongestChain = 0;\r\nu16 ChainLength = 0, thislen;\r\nu16 chain, EUN;\r\nfor (chain = 0; chain < le32_to_cpu(nftl->MediaHdr.FormattedSize) / nftl->EraseSize; chain++) {\r\nEUN = nftl->EUNtable[chain];\r\nthislen = 0;\r\nwhile (EUN <= nftl->lastEUN) {\r\nthislen++;\r\nEUN = nftl->ReplUnitTable[EUN] & 0x7fff;\r\nif (thislen > 0xff00) {\r\nprintk("Endless loop in Virtual Chain %d: Unit %x\n",\r\nchain, EUN);\r\n}\r\nif (thislen > 0xff10) {\r\nthislen = 0;\r\nbreak;\r\n}\r\n}\r\nif (thislen > ChainLength) {\r\nChainLength = thislen;\r\nLongestChain = chain;\r\n}\r\n}\r\nif (ChainLength < 2) {\r\nprintk(KERN_WARNING "No Virtual Unit Chains available for folding. "\r\n"Failing request\n");\r\nreturn BLOCK_NIL;\r\n}\r\nreturn NFTL_foldchain (nftl, LongestChain, pendingblock);\r\n}\r\nstatic inline u16 NFTL_findwriteunit(struct NFTLrecord *nftl, unsigned block)\r\n{\r\nu16 lastEUN;\r\nu16 thisVUC = block / (nftl->EraseSize / 512);\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nunsigned int writeEUN;\r\nunsigned long blockofs = (block * 512) & (nftl->EraseSize -1);\r\nsize_t retlen;\r\nint silly, silly2 = 3;\r\nstruct nftl_oob oob;\r\ndo {\r\nlastEUN = BLOCK_NIL;\r\nwriteEUN = nftl->EUNtable[thisVUC];\r\nsilly = MAX_LOOPS;\r\nwhile (writeEUN <= nftl->lastEUN) {\r\nstruct nftl_bci bci;\r\nsize_t retlen;\r\nunsigned int status;\r\nlastEUN = writeEUN;\r\nnftl_read_oob(mtd,\r\n(writeEUN * nftl->EraseSize) + blockofs,\r\n8, &retlen, (char *)&bci);\r\npr_debug("Status of block %d in EUN %d is %x\n",\r\nblock , writeEUN, le16_to_cpu(bci.Status));\r\nstatus = bci.Status | bci.Status1;\r\nswitch(status) {\r\ncase SECTOR_FREE:\r\nreturn writeEUN;\r\ncase SECTOR_DELETED:\r\ncase SECTOR_USED:\r\ncase SECTOR_IGNORE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!silly--) {\r\nprintk(KERN_WARNING\r\n"Infinite loop in Virtual Unit Chain 0x%x\n",\r\nthisVUC);\r\nreturn BLOCK_NIL;\r\n}\r\nwriteEUN = nftl->ReplUnitTable[writeEUN];\r\n}\r\nwriteEUN = NFTL_findfreeblock(nftl, 0);\r\nif (writeEUN == BLOCK_NIL) {\r\nwriteEUN = NFTL_makefreeblock(nftl, BLOCK_NIL);\r\nif (writeEUN == BLOCK_NIL) {\r\npr_debug("Using desperate==1 to find free EUN to accommodate write to VUC %d\n", thisVUC);\r\nwriteEUN = NFTL_findfreeblock(nftl, 1);\r\n}\r\nif (writeEUN == BLOCK_NIL) {\r\nprintk(KERN_WARNING "Cannot make free space.\n");\r\nreturn BLOCK_NIL;\r\n}\r\nlastEUN = BLOCK_NIL;\r\ncontinue;\r\n}\r\nif (lastEUN != BLOCK_NIL) {\r\nthisVUC |= 0x8000;\r\n} else {\r\nnftl->EUNtable[thisVUC] = writeEUN;\r\n}\r\nnftl->ReplUnitTable[writeEUN] = BLOCK_NIL;\r\nnftl_read_oob(mtd, writeEUN * nftl->EraseSize + 8, 8,\r\n&retlen, (char *)&oob.u);\r\noob.u.a.VirtUnitNum = oob.u.a.SpareVirtUnitNum = cpu_to_le16(thisVUC);\r\nnftl_write_oob(mtd, writeEUN * nftl->EraseSize + 8, 8,\r\n&retlen, (char *)&oob.u);\r\nif (lastEUN != BLOCK_NIL) {\r\nnftl->ReplUnitTable[lastEUN] = writeEUN;\r\nnftl_read_oob(mtd, (lastEUN * nftl->EraseSize) + 8,\r\n8, &retlen, (char *)&oob.u);\r\noob.u.a.ReplUnitNum = oob.u.a.SpareReplUnitNum\r\n= cpu_to_le16(writeEUN);\r\nnftl_write_oob(mtd, (lastEUN * nftl->EraseSize) + 8,\r\n8, &retlen, (char *)&oob.u);\r\n}\r\nreturn writeEUN;\r\n} while (silly2--);\r\nprintk(KERN_WARNING "Error folding to make room for Virtual Unit Chain 0x%x\n",\r\nthisVUC);\r\nreturn BLOCK_NIL;\r\n}\r\nstatic int nftl_writeblock(struct mtd_blktrans_dev *mbd, unsigned long block,\r\nchar *buffer)\r\n{\r\nstruct NFTLrecord *nftl = (void *)mbd;\r\nu16 writeEUN;\r\nunsigned long blockofs = (block * 512) & (nftl->EraseSize - 1);\r\nsize_t retlen;\r\nstruct nftl_oob oob;\r\nwriteEUN = NFTL_findwriteunit(nftl, block);\r\nif (writeEUN == BLOCK_NIL) {\r\nprintk(KERN_WARNING\r\n"NFTL_writeblock(): Cannot find block to write to\n");\r\nreturn 1;\r\n}\r\nmemset(&oob, 0xff, sizeof(struct nftl_oob));\r\noob.b.Status = oob.b.Status1 = SECTOR_USED;\r\nnftl_write(nftl->mbd.mtd, (writeEUN * nftl->EraseSize) + blockofs,\r\n512, &retlen, (char *)buffer, (char *)&oob);\r\nreturn 0;\r\n}\r\nstatic int nftl_readblock(struct mtd_blktrans_dev *mbd, unsigned long block,\r\nchar *buffer)\r\n{\r\nstruct NFTLrecord *nftl = (void *)mbd;\r\nstruct mtd_info *mtd = nftl->mbd.mtd;\r\nu16 lastgoodEUN;\r\nu16 thisEUN = nftl->EUNtable[block / (nftl->EraseSize / 512)];\r\nunsigned long blockofs = (block * 512) & (nftl->EraseSize - 1);\r\nunsigned int status;\r\nint silly = MAX_LOOPS;\r\nsize_t retlen;\r\nstruct nftl_bci bci;\r\nlastgoodEUN = BLOCK_NIL;\r\nif (thisEUN != BLOCK_NIL) {\r\nwhile (thisEUN < nftl->nb_blocks) {\r\nif (nftl_read_oob(mtd, (thisEUN * nftl->EraseSize) +\r\nblockofs, 8, &retlen,\r\n(char *)&bci) < 0)\r\nstatus = SECTOR_IGNORE;\r\nelse\r\nstatus = bci.Status | bci.Status1;\r\nswitch (status) {\r\ncase SECTOR_FREE:\r\ngoto the_end;\r\ncase SECTOR_DELETED:\r\nlastgoodEUN = BLOCK_NIL;\r\nbreak;\r\ncase SECTOR_USED:\r\nlastgoodEUN = thisEUN;\r\nbreak;\r\ncase SECTOR_IGNORE:\r\nbreak;\r\ndefault:\r\nprintk("Unknown status for block %ld in EUN %d: %x\n",\r\nblock, thisEUN, status);\r\nbreak;\r\n}\r\nif (!silly--) {\r\nprintk(KERN_WARNING "Infinite loop in Virtual Unit Chain 0x%lx\n",\r\nblock / (nftl->EraseSize / 512));\r\nreturn 1;\r\n}\r\nthisEUN = nftl->ReplUnitTable[thisEUN];\r\n}\r\n}\r\nthe_end:\r\nif (lastgoodEUN == BLOCK_NIL) {\r\nmemset(buffer, 0, 512);\r\n} else {\r\nloff_t ptr = (lastgoodEUN * nftl->EraseSize) + blockofs;\r\nsize_t retlen;\r\nint res = mtd_read(mtd, ptr, 512, &retlen, buffer);\r\nif (res < 0 && !mtd_is_bitflip(res))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\r\n{\r\nstruct NFTLrecord *nftl = (void *)dev;\r\ngeo->heads = nftl->heads;\r\ngeo->sectors = nftl->sectors;\r\ngeo->cylinders = nftl->cylinders;\r\nreturn 0;\r\n}\r\nstatic int __init init_nftl(void)\r\n{\r\nreturn register_mtd_blktrans(&nftl_tr);\r\n}\r\nstatic void __exit cleanup_nftl(void)\r\n{\r\nderegister_mtd_blktrans(&nftl_tr);\r\n}
