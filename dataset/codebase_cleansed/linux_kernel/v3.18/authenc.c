static void authenc_request_complete(struct aead_request *req, int err)\r\n{\r\nif (err != -EINPROGRESS)\r\naead_request_complete(req, err);\r\n}\r\nint crypto_authenc_extractkeys(struct crypto_authenc_keys *keys, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct rtattr *rta = (struct rtattr *)key;\r\nstruct crypto_authenc_key_param *param;\r\nif (!RTA_OK(rta, keylen))\r\nreturn -EINVAL;\r\nif (rta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM)\r\nreturn -EINVAL;\r\nif (RTA_PAYLOAD(rta) < sizeof(*param))\r\nreturn -EINVAL;\r\nparam = RTA_DATA(rta);\r\nkeys->enckeylen = be32_to_cpu(param->enckeylen);\r\nkey += RTA_ALIGN(rta->rta_len);\r\nkeylen -= RTA_ALIGN(rta->rta_len);\r\nif (keylen < keys->enckeylen)\r\nreturn -EINVAL;\r\nkeys->authkeylen = keylen - keys->enckeylen;\r\nkeys->authkey = key;\r\nkeys->enckey = key + keys->authkeylen;\r\nreturn 0;\r\n}\r\nstatic int crypto_authenc_setkey(struct crypto_aead *authenc, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nstruct crypto_ablkcipher *enc = ctx->enc;\r\nstruct crypto_authenc_keys keys;\r\nint err = -EINVAL;\r\nif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\r\ngoto badkey;\r\ncrypto_ahash_clear_flags(auth, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ahash_setkey(auth, keys.authkey, keys.authkeylen);\r\ncrypto_aead_set_flags(authenc, crypto_ahash_get_flags(auth) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (err)\r\ngoto out;\r\ncrypto_ablkcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ablkcipher_set_flags(enc, crypto_aead_get_flags(authenc) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ablkcipher_setkey(enc, keys.enckey, keys.enckeylen);\r\ncrypto_aead_set_flags(authenc, crypto_ablkcipher_get_flags(enc) &\r\nCRYPTO_TFM_RES_MASK);\r\nout:\r\nreturn err;\r\nbadkey:\r\ncrypto_aead_set_flags(authenc, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\ngoto out;\r\n}\r\nstatic void authenc_geniv_ahash_update_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\r\nif (err)\r\ngoto out;\r\nahash_request_set_crypt(ahreq, areq_ctx->sg, ahreq->result,\r\nareq_ctx->cryptlen);\r\nahash_request_set_callback(ahreq, aead_request_flags(req) &\r\nCRYPTO_TFM_REQ_MAY_SLEEP,\r\nareq_ctx->complete, req);\r\nerr = crypto_ahash_finup(ahreq);\r\nif (err)\r\ngoto out;\r\nscatterwalk_map_and_copy(ahreq->result, areq_ctx->sg,\r\nareq_ctx->cryptlen,\r\ncrypto_aead_authsize(authenc), 1);\r\nout:\r\nauthenc_request_complete(req, err);\r\n}\r\nstatic void authenc_geniv_ahash_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\r\nif (err)\r\ngoto out;\r\nscatterwalk_map_and_copy(ahreq->result, areq_ctx->sg,\r\nareq_ctx->cryptlen,\r\ncrypto_aead_authsize(authenc), 1);\r\nout:\r\naead_request_complete(req, err);\r\n}\r\nstatic void authenc_verify_ahash_update_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nu8 *ihash;\r\nunsigned int authsize;\r\nstruct ablkcipher_request *abreq;\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\r\nunsigned int cryptlen = req->cryptlen;\r\nif (err)\r\ngoto out;\r\nahash_request_set_crypt(ahreq, areq_ctx->sg, ahreq->result,\r\nareq_ctx->cryptlen);\r\nahash_request_set_callback(ahreq, aead_request_flags(req) &\r\nCRYPTO_TFM_REQ_MAY_SLEEP,\r\nareq_ctx->complete, req);\r\nerr = crypto_ahash_finup(ahreq);\r\nif (err)\r\ngoto out;\r\nauthsize = crypto_aead_authsize(authenc);\r\ncryptlen -= authsize;\r\nihash = ahreq->result + authsize;\r\nscatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,\r\nauthsize, 0);\r\nerr = crypto_memneq(ihash, ahreq->result, authsize) ? -EBADMSG : 0;\r\nif (err)\r\ngoto out;\r\nabreq = aead_request_ctx(req);\r\nablkcipher_request_set_tfm(abreq, ctx->enc);\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\nreq->base.complete, req->base.data);\r\nablkcipher_request_set_crypt(abreq, req->src, req->dst,\r\ncryptlen, req->iv);\r\nerr = crypto_ablkcipher_decrypt(abreq);\r\nout:\r\nauthenc_request_complete(req, err);\r\n}\r\nstatic void authenc_verify_ahash_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nu8 *ihash;\r\nunsigned int authsize;\r\nstruct ablkcipher_request *abreq;\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\r\nunsigned int cryptlen = req->cryptlen;\r\nif (err)\r\ngoto out;\r\nauthsize = crypto_aead_authsize(authenc);\r\ncryptlen -= authsize;\r\nihash = ahreq->result + authsize;\r\nscatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,\r\nauthsize, 0);\r\nerr = crypto_memneq(ihash, ahreq->result, authsize) ? -EBADMSG : 0;\r\nif (err)\r\ngoto out;\r\nabreq = aead_request_ctx(req);\r\nablkcipher_request_set_tfm(abreq, ctx->enc);\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\nreq->base.complete, req->base.data);\r\nablkcipher_request_set_crypt(abreq, req->src, req->dst,\r\ncryptlen, req->iv);\r\nerr = crypto_ablkcipher_decrypt(abreq);\r\nout:\r\nauthenc_request_complete(req, err);\r\n}\r\nstatic u8 *crypto_authenc_ahash_fb(struct aead_request *req, unsigned int flags)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\r\nu8 *hash = areq_ctx->tail;\r\nint err;\r\nhash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),\r\ncrypto_ahash_alignmask(auth) + 1);\r\nahash_request_set_tfm(ahreq, auth);\r\nerr = crypto_ahash_init(ahreq);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nahash_request_set_crypt(ahreq, req->assoc, hash, req->assoclen);\r\nahash_request_set_callback(ahreq, aead_request_flags(req) & flags,\r\nareq_ctx->update_complete, req);\r\nerr = crypto_ahash_update(ahreq);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nahash_request_set_crypt(ahreq, areq_ctx->sg, hash,\r\nareq_ctx->cryptlen);\r\nahash_request_set_callback(ahreq, aead_request_flags(req) & flags,\r\nareq_ctx->complete, req);\r\nerr = crypto_ahash_finup(ahreq);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nreturn hash;\r\n}\r\nstatic u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\r\nu8 *hash = areq_ctx->tail;\r\nint err;\r\nhash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),\r\ncrypto_ahash_alignmask(auth) + 1);\r\nahash_request_set_tfm(ahreq, auth);\r\nahash_request_set_crypt(ahreq, areq_ctx->sg, hash,\r\nareq_ctx->cryptlen);\r\nahash_request_set_callback(ahreq, aead_request_flags(req) & flags,\r\nareq_ctx->complete, req);\r\nerr = crypto_ahash_digest(ahreq);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nreturn hash;\r\n}\r\nstatic int crypto_authenc_genicv(struct aead_request *req, u8 *iv,\r\nunsigned int flags)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct scatterlist *dst = req->dst;\r\nstruct scatterlist *assoc = req->assoc;\r\nstruct scatterlist *cipher = areq_ctx->cipher;\r\nstruct scatterlist *asg = areq_ctx->asg;\r\nunsigned int ivsize = crypto_aead_ivsize(authenc);\r\nunsigned int cryptlen = req->cryptlen;\r\nauthenc_ahash_t authenc_ahash_fn = crypto_authenc_ahash_fb;\r\nstruct page *dstp;\r\nu8 *vdst;\r\nu8 *hash;\r\ndstp = sg_page(dst);\r\nvdst = PageHighMem(dstp) ? NULL : page_address(dstp) + dst->offset;\r\nif (ivsize) {\r\nsg_init_table(cipher, 2);\r\nsg_set_buf(cipher, iv, ivsize);\r\nscatterwalk_crypto_chain(cipher, dst, vdst == iv + ivsize, 2);\r\ndst = cipher;\r\ncryptlen += ivsize;\r\n}\r\nif (req->assoclen && sg_is_last(assoc)) {\r\nauthenc_ahash_fn = crypto_authenc_ahash;\r\nsg_init_table(asg, 2);\r\nsg_set_page(asg, sg_page(assoc), assoc->length, assoc->offset);\r\nscatterwalk_crypto_chain(asg, dst, 0, 2);\r\ndst = asg;\r\ncryptlen += req->assoclen;\r\n}\r\nareq_ctx->cryptlen = cryptlen;\r\nareq_ctx->sg = dst;\r\nareq_ctx->complete = authenc_geniv_ahash_done;\r\nareq_ctx->update_complete = authenc_geniv_ahash_update_done;\r\nhash = authenc_ahash_fn(req, flags);\r\nif (IS_ERR(hash))\r\nreturn PTR_ERR(hash);\r\nscatterwalk_map_and_copy(hash, dst, cryptlen,\r\ncrypto_aead_authsize(authenc), 1);\r\nreturn 0;\r\n}\r\nstatic void crypto_authenc_encrypt_done(struct crypto_async_request *req,\r\nint err)\r\n{\r\nstruct aead_request *areq = req->data;\r\nif (!err) {\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(areq);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(areq);\r\nstruct ablkcipher_request *abreq = (void *)(areq_ctx->tail\r\n+ ctx->reqoff);\r\nu8 *iv = (u8 *)abreq - crypto_ablkcipher_ivsize(ctx->enc);\r\nerr = crypto_authenc_genicv(areq, iv, 0);\r\n}\r\nauthenc_request_complete(areq, err);\r\n}\r\nstatic int crypto_authenc_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct crypto_ablkcipher *enc = ctx->enc;\r\nstruct scatterlist *dst = req->dst;\r\nunsigned int cryptlen = req->cryptlen;\r\nstruct ablkcipher_request *abreq = (void *)(areq_ctx->tail\r\n+ ctx->reqoff);\r\nu8 *iv = (u8 *)abreq - crypto_ablkcipher_ivsize(enc);\r\nint err;\r\nablkcipher_request_set_tfm(abreq, enc);\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\ncrypto_authenc_encrypt_done, req);\r\nablkcipher_request_set_crypt(abreq, req->src, dst, cryptlen, req->iv);\r\nmemcpy(iv, req->iv, crypto_aead_ivsize(authenc));\r\nerr = crypto_ablkcipher_encrypt(abreq);\r\nif (err)\r\nreturn err;\r\nreturn crypto_authenc_genicv(req, iv, CRYPTO_TFM_REQ_MAY_SLEEP);\r\n}\r\nstatic void crypto_authenc_givencrypt_done(struct crypto_async_request *req,\r\nint err)\r\n{\r\nstruct aead_request *areq = req->data;\r\nif (!err) {\r\nstruct skcipher_givcrypt_request *greq = aead_request_ctx(areq);\r\nerr = crypto_authenc_genicv(areq, greq->giv, 0);\r\n}\r\nauthenc_request_complete(areq, err);\r\n}\r\nstatic int crypto_authenc_givencrypt(struct aead_givcrypt_request *req)\r\n{\r\nstruct crypto_aead *authenc = aead_givcrypt_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct aead_request *areq = &req->areq;\r\nstruct skcipher_givcrypt_request *greq = aead_request_ctx(areq);\r\nu8 *iv = req->giv;\r\nint err;\r\nskcipher_givcrypt_set_tfm(greq, ctx->enc);\r\nskcipher_givcrypt_set_callback(greq, aead_request_flags(areq),\r\ncrypto_authenc_givencrypt_done, areq);\r\nskcipher_givcrypt_set_crypt(greq, areq->src, areq->dst, areq->cryptlen,\r\nareq->iv);\r\nskcipher_givcrypt_set_giv(greq, iv, req->seq);\r\nerr = crypto_skcipher_givencrypt(greq);\r\nif (err)\r\nreturn err;\r\nreturn crypto_authenc_genicv(areq, iv, CRYPTO_TFM_REQ_MAY_SLEEP);\r\n}\r\nstatic int crypto_authenc_verify(struct aead_request *req,\r\nauthenc_ahash_t authenc_ahash_fn)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nu8 *ohash;\r\nu8 *ihash;\r\nunsigned int authsize;\r\nareq_ctx->complete = authenc_verify_ahash_done;\r\nareq_ctx->update_complete = authenc_verify_ahash_update_done;\r\nohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (IS_ERR(ohash))\r\nreturn PTR_ERR(ohash);\r\nauthsize = crypto_aead_authsize(authenc);\r\nihash = ohash + authsize;\r\nscatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,\r\nauthsize, 0);\r\nreturn crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;\r\n}\r\nstatic int crypto_authenc_iverify(struct aead_request *req, u8 *iv,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct scatterlist *src = req->src;\r\nstruct scatterlist *assoc = req->assoc;\r\nstruct scatterlist *cipher = areq_ctx->cipher;\r\nstruct scatterlist *asg = areq_ctx->asg;\r\nunsigned int ivsize = crypto_aead_ivsize(authenc);\r\nauthenc_ahash_t authenc_ahash_fn = crypto_authenc_ahash_fb;\r\nstruct page *srcp;\r\nu8 *vsrc;\r\nsrcp = sg_page(src);\r\nvsrc = PageHighMem(srcp) ? NULL : page_address(srcp) + src->offset;\r\nif (ivsize) {\r\nsg_init_table(cipher, 2);\r\nsg_set_buf(cipher, iv, ivsize);\r\nscatterwalk_crypto_chain(cipher, src, vsrc == iv + ivsize, 2);\r\nsrc = cipher;\r\ncryptlen += ivsize;\r\n}\r\nif (req->assoclen && sg_is_last(assoc)) {\r\nauthenc_ahash_fn = crypto_authenc_ahash;\r\nsg_init_table(asg, 2);\r\nsg_set_page(asg, sg_page(assoc), assoc->length, assoc->offset);\r\nscatterwalk_crypto_chain(asg, src, 0, 2);\r\nsrc = asg;\r\ncryptlen += req->assoclen;\r\n}\r\nareq_ctx->cryptlen = cryptlen;\r\nareq_ctx->sg = src;\r\nreturn crypto_authenc_verify(req, authenc_ahash_fn);\r\n}\r\nstatic int crypto_authenc_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\r\nstruct ablkcipher_request *abreq = aead_request_ctx(req);\r\nunsigned int cryptlen = req->cryptlen;\r\nunsigned int authsize = crypto_aead_authsize(authenc);\r\nu8 *iv = req->iv;\r\nint err;\r\nif (cryptlen < authsize)\r\nreturn -EINVAL;\r\ncryptlen -= authsize;\r\nerr = crypto_authenc_iverify(req, iv, cryptlen);\r\nif (err)\r\nreturn err;\r\nablkcipher_request_set_tfm(abreq, ctx->enc);\r\nablkcipher_request_set_callback(abreq, aead_request_flags(req),\r\nreq->base.complete, req->base.data);\r\nablkcipher_request_set_crypt(abreq, req->src, req->dst, cryptlen, iv);\r\nreturn crypto_ablkcipher_decrypt(abreq);\r\n}\r\nstatic int crypto_authenc_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = crypto_tfm_alg_instance(tfm);\r\nstruct authenc_instance_ctx *ictx = crypto_instance_ctx(inst);\r\nstruct crypto_authenc_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_ahash *auth;\r\nstruct crypto_ablkcipher *enc;\r\nint err;\r\nauth = crypto_spawn_ahash(&ictx->auth);\r\nif (IS_ERR(auth))\r\nreturn PTR_ERR(auth);\r\nenc = crypto_spawn_skcipher(&ictx->enc);\r\nerr = PTR_ERR(enc);\r\nif (IS_ERR(enc))\r\ngoto err_free_ahash;\r\nctx->auth = auth;\r\nctx->enc = enc;\r\nctx->reqoff = ALIGN(2 * crypto_ahash_digestsize(auth) +\r\ncrypto_ahash_alignmask(auth),\r\ncrypto_ahash_alignmask(auth) + 1) +\r\ncrypto_ablkcipher_ivsize(enc);\r\ntfm->crt_aead.reqsize = sizeof(struct authenc_request_ctx) +\r\nctx->reqoff +\r\nmax_t(unsigned int,\r\ncrypto_ahash_reqsize(auth) +\r\nsizeof(struct ahash_request),\r\nsizeof(struct skcipher_givcrypt_request) +\r\ncrypto_ablkcipher_reqsize(enc));\r\nreturn 0;\r\nerr_free_ahash:\r\ncrypto_free_ahash(auth);\r\nreturn err;\r\n}\r\nstatic void crypto_authenc_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_authenc_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_ahash(ctx->auth);\r\ncrypto_free_ablkcipher(ctx->enc);\r\n}\r\nstatic struct crypto_instance *crypto_authenc_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_instance *inst;\r\nstruct hash_alg_common *auth;\r\nstruct crypto_alg *auth_base;\r\nstruct crypto_alg *enc;\r\nstruct authenc_instance_ctx *ctx;\r\nconst char *enc_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn ERR_CAST(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn ERR_PTR(-EINVAL);\r\nauth = ahash_attr_alg(tb[1], CRYPTO_ALG_TYPE_HASH,\r\nCRYPTO_ALG_TYPE_AHASH_MASK);\r\nif (IS_ERR(auth))\r\nreturn ERR_CAST(auth);\r\nauth_base = &auth->base;\r\nenc_name = crypto_attr_alg_name(tb[2]);\r\nerr = PTR_ERR(enc_name);\r\nif (IS_ERR(enc_name))\r\ngoto out_put_auth;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!inst)\r\ngoto out_put_auth;\r\nctx = crypto_instance_ctx(inst);\r\nerr = crypto_init_ahash_spawn(&ctx->auth, auth, inst);\r\nif (err)\r\ngoto err_free_inst;\r\ncrypto_set_skcipher_spawn(&ctx->enc, inst);\r\nerr = crypto_grab_skcipher(&ctx->enc, enc_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_auth;\r\nenc = crypto_skcipher_spawn_alg(&ctx->enc);\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"authenc(%s,%s)", auth_base->cra_name, enc->cra_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_enc;\r\nif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"authenc(%s,%s)", auth_base->cra_driver_name,\r\nenc->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_enc;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\r\ninst->alg.cra_flags |= enc->cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.cra_priority = enc->cra_priority *\r\n10 + auth_base->cra_priority;\r\ninst->alg.cra_blocksize = enc->cra_blocksize;\r\ninst->alg.cra_alignmask = auth_base->cra_alignmask | enc->cra_alignmask;\r\ninst->alg.cra_type = &crypto_aead_type;\r\ninst->alg.cra_aead.ivsize = enc->cra_ablkcipher.ivsize;\r\ninst->alg.cra_aead.maxauthsize = auth->digestsize;\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_authenc_ctx);\r\ninst->alg.cra_init = crypto_authenc_init_tfm;\r\ninst->alg.cra_exit = crypto_authenc_exit_tfm;\r\ninst->alg.cra_aead.setkey = crypto_authenc_setkey;\r\ninst->alg.cra_aead.encrypt = crypto_authenc_encrypt;\r\ninst->alg.cra_aead.decrypt = crypto_authenc_decrypt;\r\ninst->alg.cra_aead.givencrypt = crypto_authenc_givencrypt;\r\nout:\r\ncrypto_mod_put(auth_base);\r\nreturn inst;\r\nerr_drop_enc:\r\ncrypto_drop_skcipher(&ctx->enc);\r\nerr_drop_auth:\r\ncrypto_drop_ahash(&ctx->auth);\r\nerr_free_inst:\r\nkfree(inst);\r\nout_put_auth:\r\ninst = ERR_PTR(err);\r\ngoto out;\r\n}\r\nstatic void crypto_authenc_free(struct crypto_instance *inst)\r\n{\r\nstruct authenc_instance_ctx *ctx = crypto_instance_ctx(inst);\r\ncrypto_drop_skcipher(&ctx->enc);\r\ncrypto_drop_ahash(&ctx->auth);\r\nkfree(inst);\r\n}\r\nstatic int __init crypto_authenc_module_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_authenc_tmpl);\r\n}\r\nstatic void __exit crypto_authenc_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_authenc_tmpl);\r\n}
