static inline int hsi_dummy_msg(struct hsi_msg *msg __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int hsi_dummy_cl(struct hsi_client *cl __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline unsigned int ssi_wakein(struct hsi_port *port)\r\n{\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nreturn gpio_get_value(omap_port->wake_gpio);\r\n}\r\nstatic void ssi_debug_remove_port(struct hsi_port *port)\r\n{\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\ndebugfs_remove_recursive(omap_port->dir);\r\n}\r\nstatic int ssi_debug_port_show(struct seq_file *m, void *p __maybe_unused)\r\n{\r\nstruct hsi_port *port = m->private;\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nvoid __iomem *base = omap_ssi->sys;\r\nunsigned int ch;\r\npm_runtime_get_sync(omap_port->pdev);\r\nif (omap_port->wake_irq > 0)\r\nseq_printf(m, "CAWAKE\t\t: %d\n", ssi_wakein(port));\r\nseq_printf(m, "WAKE\t\t: 0x%08x\n",\r\nreadl(base + SSI_WAKE_REG(port->num)));\r\nseq_printf(m, "MPU_ENABLE_IRQ%d\t: 0x%08x\n", 0,\r\nreadl(base + SSI_MPU_ENABLE_REG(port->num, 0)));\r\nseq_printf(m, "MPU_STATUS_IRQ%d\t: 0x%08x\n", 0,\r\nreadl(base + SSI_MPU_STATUS_REG(port->num, 0)));\r\nbase = omap_port->sst_base;\r\nseq_puts(m, "\nSST\n===\n");\r\nseq_printf(m, "ID SST\t\t: 0x%08x\n",\r\nreadl(base + SSI_SST_ID_REG));\r\nseq_printf(m, "MODE\t\t: 0x%08x\n",\r\nreadl(base + SSI_SST_MODE_REG));\r\nseq_printf(m, "FRAMESIZE\t: 0x%08x\n",\r\nreadl(base + SSI_SST_FRAMESIZE_REG));\r\nseq_printf(m, "DIVISOR\t\t: 0x%08x\n",\r\nreadl(base + SSI_SST_DIVISOR_REG));\r\nseq_printf(m, "CHANNELS\t: 0x%08x\n",\r\nreadl(base + SSI_SST_CHANNELS_REG));\r\nseq_printf(m, "ARBMODE\t\t: 0x%08x\n",\r\nreadl(base + SSI_SST_ARBMODE_REG));\r\nseq_printf(m, "TXSTATE\t\t: 0x%08x\n",\r\nreadl(base + SSI_SST_TXSTATE_REG));\r\nseq_printf(m, "BUFSTATE\t: 0x%08x\n",\r\nreadl(base + SSI_SST_BUFSTATE_REG));\r\nseq_printf(m, "BREAK\t\t: 0x%08x\n",\r\nreadl(base + SSI_SST_BREAK_REG));\r\nfor (ch = 0; ch < omap_port->channels; ch++) {\r\nseq_printf(m, "BUFFER_CH%d\t: 0x%08x\n", ch,\r\nreadl(base + SSI_SST_BUFFER_CH_REG(ch)));\r\n}\r\nbase = omap_port->ssr_base;\r\nseq_puts(m, "\nSSR\n===\n");\r\nseq_printf(m, "ID SSR\t\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_ID_REG));\r\nseq_printf(m, "MODE\t\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_MODE_REG));\r\nseq_printf(m, "FRAMESIZE\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_FRAMESIZE_REG));\r\nseq_printf(m, "CHANNELS\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_CHANNELS_REG));\r\nseq_printf(m, "TIMEOUT\t\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_TIMEOUT_REG));\r\nseq_printf(m, "RXSTATE\t\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_RXSTATE_REG));\r\nseq_printf(m, "BUFSTATE\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_BUFSTATE_REG));\r\nseq_printf(m, "BREAK\t\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_BREAK_REG));\r\nseq_printf(m, "ERROR\t\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_ERROR_REG));\r\nseq_printf(m, "ERRORACK\t: 0x%08x\n",\r\nreadl(base + SSI_SSR_ERRORACK_REG));\r\nfor (ch = 0; ch < omap_port->channels; ch++) {\r\nseq_printf(m, "BUFFER_CH%d\t: 0x%08x\n", ch,\r\nreadl(base + SSI_SSR_BUFFER_CH_REG(ch)));\r\n}\r\npm_runtime_put_sync(omap_port->pdev);\r\nreturn 0;\r\n}\r\nstatic int ssi_port_regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ssi_debug_port_show, inode->i_private);\r\n}\r\nstatic int ssi_div_get(void *data, u64 *val)\r\n{\r\nstruct hsi_port *port = data;\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\npm_runtime_get_sync(omap_port->pdev);\r\n*val = readl(omap_port->sst_base + SSI_SST_DIVISOR_REG);\r\npm_runtime_put_sync(omap_port->pdev);\r\nreturn 0;\r\n}\r\nstatic int ssi_div_set(void *data, u64 val)\r\n{\r\nstruct hsi_port *port = data;\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nif (val > 127)\r\nreturn -EINVAL;\r\npm_runtime_get_sync(omap_port->pdev);\r\nwritel(val, omap_port->sst_base + SSI_SST_DIVISOR_REG);\r\nomap_port->sst.divisor = val;\r\npm_runtime_put_sync(omap_port->pdev);\r\nreturn 0;\r\n}\r\nstatic int __init ssi_debug_add_port(struct omap_ssi_port *omap_port,\r\nstruct dentry *dir)\r\n{\r\nstruct hsi_port *port = to_hsi_port(omap_port->dev);\r\ndir = debugfs_create_dir(dev_name(omap_port->dev), dir);\r\nif (!dir)\r\nreturn -ENOMEM;\r\nomap_port->dir = dir;\r\ndebugfs_create_file("regs", S_IRUGO, dir, port, &ssi_port_regs_fops);\r\ndir = debugfs_create_dir("sst", dir);\r\nif (!dir)\r\nreturn -ENOMEM;\r\ndebugfs_create_file("divisor", S_IRUGO | S_IWUSR, dir, port,\r\n&ssi_sst_div_fops);\r\nreturn 0;\r\n}\r\nstatic int ssi_claim_lch(struct hsi_msg *msg)\r\n{\r\nstruct hsi_port *port = hsi_get_port(msg->cl);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nint lch;\r\nfor (lch = 0; lch < SSI_MAX_GDD_LCH; lch++)\r\nif (!omap_ssi->gdd_trn[lch].msg) {\r\nomap_ssi->gdd_trn[lch].msg = msg;\r\nomap_ssi->gdd_trn[lch].sg = msg->sgt.sgl;\r\nreturn lch;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int ssi_start_dma(struct hsi_msg *msg, int lch)\r\n{\r\nstruct hsi_port *port = hsi_get_port(msg->cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nvoid __iomem *gdd = omap_ssi->gdd;\r\nint err;\r\nu16 csdp;\r\nu16 ccr;\r\nu32 s_addr;\r\nu32 d_addr;\r\nu32 tmp;\r\nif (msg->ttype == HSI_MSG_READ) {\r\nerr = dma_map_sg(&ssi->device, msg->sgt.sgl, msg->sgt.nents,\r\nDMA_FROM_DEVICE);\r\nif (err < 0) {\r\ndev_dbg(&ssi->device, "DMA map SG failed !\n");\r\nreturn err;\r\n}\r\ncsdp = SSI_DST_BURST_4x32_BIT | SSI_DST_MEMORY_PORT |\r\nSSI_SRC_SINGLE_ACCESS0 | SSI_SRC_PERIPHERAL_PORT |\r\nSSI_DATA_TYPE_S32;\r\nccr = msg->channel + 0x10 + (port->num * 8);\r\nccr |= SSI_DST_AMODE_POSTINC | SSI_SRC_AMODE_CONST |\r\nSSI_CCR_ENABLE;\r\ns_addr = omap_port->ssr_dma +\r\nSSI_SSR_BUFFER_CH_REG(msg->channel);\r\nd_addr = sg_dma_address(msg->sgt.sgl);\r\n} else {\r\nerr = dma_map_sg(&ssi->device, msg->sgt.sgl, msg->sgt.nents,\r\nDMA_TO_DEVICE);\r\nif (err < 0) {\r\ndev_dbg(&ssi->device, "DMA map SG failed !\n");\r\nreturn err;\r\n}\r\ncsdp = SSI_SRC_BURST_4x32_BIT | SSI_SRC_MEMORY_PORT |\r\nSSI_DST_SINGLE_ACCESS0 | SSI_DST_PERIPHERAL_PORT |\r\nSSI_DATA_TYPE_S32;\r\nccr = (msg->channel + 1 + (port->num * 8)) & 0xf;\r\nccr |= SSI_SRC_AMODE_POSTINC | SSI_DST_AMODE_CONST |\r\nSSI_CCR_ENABLE;\r\ns_addr = sg_dma_address(msg->sgt.sgl);\r\nd_addr = omap_port->sst_dma +\r\nSSI_SST_BUFFER_CH_REG(msg->channel);\r\n}\r\ndev_dbg(&ssi->device, "lch %d cdsp %08x ccr %04x s_addr %08x d_addr %08x\n",\r\nlch, csdp, ccr, s_addr, d_addr);\r\npm_runtime_get_sync(omap_port->pdev);\r\nwritew_relaxed(csdp, gdd + SSI_GDD_CSDP_REG(lch));\r\nwritew_relaxed(SSI_BLOCK_IE | SSI_TOUT_IE, gdd + SSI_GDD_CICR_REG(lch));\r\nwritel_relaxed(d_addr, gdd + SSI_GDD_CDSA_REG(lch));\r\nwritel_relaxed(s_addr, gdd + SSI_GDD_CSSA_REG(lch));\r\nwritew_relaxed(SSI_BYTES_TO_FRAMES(msg->sgt.sgl->length),\r\ngdd + SSI_GDD_CEN_REG(lch));\r\nspin_lock_bh(&omap_ssi->lock);\r\ntmp = readl(omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\ntmp |= SSI_GDD_LCH(lch);\r\nwritel_relaxed(tmp, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\nspin_unlock_bh(&omap_ssi->lock);\r\nwritew(ccr, gdd + SSI_GDD_CCR_REG(lch));\r\nmsg->status = HSI_STATUS_PROCEEDING;\r\nreturn 0;\r\n}\r\nstatic int ssi_start_pio(struct hsi_msg *msg)\r\n{\r\nstruct hsi_port *port = hsi_get_port(msg->cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nu32 val;\r\npm_runtime_get_sync(omap_port->pdev);\r\nif (msg->ttype == HSI_MSG_WRITE) {\r\nval = SSI_DATAACCEPT(msg->channel);\r\npm_runtime_get_sync(omap_port->pdev);\r\n} else {\r\nval = SSI_DATAAVAILABLE(msg->channel) | SSI_ERROROCCURED;\r\n}\r\ndev_dbg(&port->device, "Single %s transfer\n",\r\nmsg->ttype ? "write" : "read");\r\nval |= readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nwritel(val, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\npm_runtime_put_sync(omap_port->pdev);\r\nmsg->actual_len = 0;\r\nmsg->status = HSI_STATUS_PROCEEDING;\r\nreturn 0;\r\n}\r\nstatic int ssi_start_transfer(struct list_head *queue)\r\n{\r\nstruct hsi_msg *msg;\r\nint lch = -1;\r\nif (list_empty(queue))\r\nreturn 0;\r\nmsg = list_first_entry(queue, struct hsi_msg, link);\r\nif (msg->status != HSI_STATUS_QUEUED)\r\nreturn 0;\r\nif ((msg->sgt.nents) && (msg->sgt.sgl->length > sizeof(u32)))\r\nlch = ssi_claim_lch(msg);\r\nif (lch >= 0)\r\nreturn ssi_start_dma(msg, lch);\r\nelse\r\nreturn ssi_start_pio(msg);\r\n}\r\nstatic int ssi_async_break(struct hsi_msg *msg)\r\n{\r\nstruct hsi_port *port = hsi_get_port(msg->cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nint err = 0;\r\nu32 tmp;\r\npm_runtime_get_sync(omap_port->pdev);\r\nif (msg->ttype == HSI_MSG_WRITE) {\r\nif (omap_port->sst.mode != SSI_MODE_FRAME) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nwritel(1, omap_port->sst_base + SSI_SST_BREAK_REG);\r\nmsg->status = HSI_STATUS_COMPLETED;\r\nmsg->complete(msg);\r\n} else {\r\nif (omap_port->ssr.mode != SSI_MODE_FRAME) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nspin_lock_bh(&omap_port->lock);\r\ntmp = readl(omap_ssi->sys +\r\nSSI_MPU_ENABLE_REG(port->num, 0));\r\nwritel(tmp | SSI_BREAKDETECTED,\r\nomap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nmsg->status = HSI_STATUS_PROCEEDING;\r\nlist_add_tail(&msg->link, &omap_port->brkqueue);\r\nspin_unlock_bh(&omap_port->lock);\r\n}\r\nout:\r\npm_runtime_put_sync(omap_port->pdev);\r\nreturn err;\r\n}\r\nstatic int ssi_async(struct hsi_msg *msg)\r\n{\r\nstruct hsi_port *port = hsi_get_port(msg->cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct list_head *queue;\r\nint err = 0;\r\nBUG_ON(!msg);\r\nif (msg->sgt.nents > 1)\r\nreturn -ENOSYS;\r\nif (msg->break_frame)\r\nreturn ssi_async_break(msg);\r\nif (msg->ttype) {\r\nBUG_ON(msg->channel >= omap_port->sst.channels);\r\nqueue = &omap_port->txqueue[msg->channel];\r\n} else {\r\nBUG_ON(msg->channel >= omap_port->ssr.channels);\r\nqueue = &omap_port->rxqueue[msg->channel];\r\n}\r\nmsg->status = HSI_STATUS_QUEUED;\r\nspin_lock_bh(&omap_port->lock);\r\nlist_add_tail(&msg->link, queue);\r\nerr = ssi_start_transfer(queue);\r\nif (err < 0) {\r\nlist_del(&msg->link);\r\nmsg->status = HSI_STATUS_ERROR;\r\n}\r\nspin_unlock_bh(&omap_port->lock);\r\ndev_dbg(&port->device, "msg status %d ttype %d ch %d\n",\r\nmsg->status, msg->ttype, msg->channel);\r\nreturn err;\r\n}\r\nstatic u32 ssi_calculate_div(struct hsi_controller *ssi)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nu32 tx_fckrate = (u32) omap_ssi->fck_rate;\r\ntx_fckrate >>= 1;\r\ntx_fckrate--;\r\ndev_dbg(&ssi->device, "TX div %d for fck_rate %lu Khz speed %d Kb/s\n",\r\ntx_fckrate / omap_ssi->max_speed, omap_ssi->fck_rate,\r\nomap_ssi->max_speed);\r\nreturn tx_fckrate / omap_ssi->max_speed;\r\n}\r\nstatic void ssi_flush_queue(struct list_head *queue, struct hsi_client *cl)\r\n{\r\nstruct list_head *node, *tmp;\r\nstruct hsi_msg *msg;\r\nlist_for_each_safe(node, tmp, queue) {\r\nmsg = list_entry(node, struct hsi_msg, link);\r\nif ((cl) && (cl != msg->cl))\r\ncontinue;\r\nlist_del(node);\r\npr_debug("flush queue: ch %d, msg %p len %d type %d ctxt %p\n",\r\nmsg->channel, msg, msg->sgt.sgl->length,\r\nmsg->ttype, msg->context);\r\nif (msg->destructor)\r\nmsg->destructor(msg);\r\nelse\r\nhsi_free_msg(msg);\r\n}\r\n}\r\nstatic int ssi_setup(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = to_hsi_port(cl->device.parent);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nvoid __iomem *sst = omap_port->sst_base;\r\nvoid __iomem *ssr = omap_port->ssr_base;\r\nu32 div;\r\nu32 val;\r\nint err = 0;\r\npm_runtime_get_sync(omap_port->pdev);\r\nspin_lock_bh(&omap_port->lock);\r\nif (cl->tx_cfg.speed)\r\nomap_ssi->max_speed = cl->tx_cfg.speed;\r\ndiv = ssi_calculate_div(ssi);\r\nif (div > SSI_MAX_DIVISOR) {\r\ndev_err(&cl->device, "Invalid TX speed %d Mb/s (div %d)\n",\r\ncl->tx_cfg.speed, div);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nwritel_relaxed(SSI_MODE_SLEEP, sst + SSI_SST_MODE_REG);\r\nwritel_relaxed(SSI_MODE_SLEEP, ssr + SSI_SSR_MODE_REG);\r\nval = readl(ssr + SSI_SSR_MODE_REG);\r\nwritel_relaxed(31, sst + SSI_SST_FRAMESIZE_REG);\r\nwritel_relaxed(div, sst + SSI_SST_DIVISOR_REG);\r\nwritel_relaxed(cl->tx_cfg.num_hw_channels, sst + SSI_SST_CHANNELS_REG);\r\nwritel_relaxed(cl->tx_cfg.arb_mode, sst + SSI_SST_ARBMODE_REG);\r\nwritel_relaxed(cl->tx_cfg.mode, sst + SSI_SST_MODE_REG);\r\nwritel_relaxed(31, ssr + SSI_SSR_FRAMESIZE_REG);\r\nwritel_relaxed(cl->rx_cfg.num_hw_channels, ssr + SSI_SSR_CHANNELS_REG);\r\nwritel_relaxed(0, ssr + SSI_SSR_TIMEOUT_REG);\r\nif ((omap_port->ssr.mode == SSI_MODE_FRAME) &&\r\n(cl->rx_cfg.mode != SSI_MODE_FRAME))\r\nssi_flush_queue(&omap_port->brkqueue, cl);\r\nwritel_relaxed(cl->rx_cfg.mode, ssr + SSI_SSR_MODE_REG);\r\nomap_port->channels = max(cl->rx_cfg.num_hw_channels,\r\ncl->tx_cfg.num_hw_channels);\r\nomap_port->sst.divisor = div;\r\nomap_port->sst.frame_size = 31;\r\nomap_port->sst.channels = cl->tx_cfg.num_hw_channels;\r\nomap_port->sst.arb_mode = cl->tx_cfg.arb_mode;\r\nomap_port->sst.mode = cl->tx_cfg.mode;\r\nomap_port->ssr.frame_size = 31;\r\nomap_port->ssr.timeout = 0;\r\nomap_port->ssr.channels = cl->rx_cfg.num_hw_channels;\r\nomap_port->ssr.mode = cl->rx_cfg.mode;\r\nout:\r\nspin_unlock_bh(&omap_port->lock);\r\npm_runtime_put_sync(omap_port->pdev);\r\nreturn err;\r\n}\r\nstatic int ssi_flush(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nstruct hsi_msg *msg;\r\nvoid __iomem *sst = omap_port->sst_base;\r\nvoid __iomem *ssr = omap_port->ssr_base;\r\nunsigned int i;\r\nu32 err;\r\npm_runtime_get_sync(omap_port->pdev);\r\nspin_lock_bh(&omap_port->lock);\r\nfor (i = 0; i < SSI_MAX_GDD_LCH; i++) {\r\nmsg = omap_ssi->gdd_trn[i].msg;\r\nif (!msg || (port != hsi_get_port(msg->cl)))\r\ncontinue;\r\nwritew_relaxed(0, omap_ssi->gdd + SSI_GDD_CCR_REG(i));\r\nif (msg->ttype == HSI_MSG_READ)\r\npm_runtime_put_sync(omap_port->pdev);\r\nomap_ssi->gdd_trn[i].msg = NULL;\r\n}\r\nwritel_relaxed(0, sst + SSI_SST_BUFSTATE_REG);\r\nwritel_relaxed(0, sst + SSI_SST_TXSTATE_REG);\r\nwritel_relaxed(0, ssr + SSI_SSR_RXSTATE_REG);\r\nwritel_relaxed(0, ssr + SSI_SSR_BUFSTATE_REG);\r\nerr = readl(ssr + SSI_SSR_ERROR_REG);\r\nwritel_relaxed(err, ssr + SSI_SSR_ERRORACK_REG);\r\nwritel_relaxed(0, ssr + SSI_SSR_BREAK_REG);\r\nwritel_relaxed(0, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nwritel_relaxed(0xffffff00,\r\nomap_ssi->sys + SSI_MPU_STATUS_REG(port->num, 0));\r\nwritel_relaxed(0, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\nwritel(0xff, omap_ssi->sys + SSI_GDD_MPU_IRQ_STATUS_REG);\r\nfor (i = 0; i < omap_port->channels; i++) {\r\nif (!list_empty(&omap_port->txqueue[i]))\r\npm_runtime_put_sync(omap_port->pdev);\r\nssi_flush_queue(&omap_port->txqueue[i], NULL);\r\nssi_flush_queue(&omap_port->rxqueue[i], NULL);\r\n}\r\nssi_flush_queue(&omap_port->brkqueue, NULL);\r\nspin_unlock_bh(&omap_port->lock);\r\npm_runtime_put_sync(omap_port->pdev);\r\nreturn 0;\r\n}\r\nstatic int ssi_start_tx(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\ndev_dbg(&port->device, "Wake out high %d\n", omap_port->wk_refcount);\r\nspin_lock_bh(&omap_port->wk_lock);\r\nif (omap_port->wk_refcount++) {\r\nspin_unlock_bh(&omap_port->wk_lock);\r\nreturn 0;\r\n}\r\npm_runtime_get_sync(omap_port->pdev);\r\nwritel(SSI_WAKE(0), omap_ssi->sys + SSI_SET_WAKE_REG(port->num));\r\nspin_unlock_bh(&omap_port->wk_lock);\r\nreturn 0;\r\n}\r\nstatic int ssi_stop_tx(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\ndev_dbg(&port->device, "Wake out low %d\n", omap_port->wk_refcount);\r\nspin_lock_bh(&omap_port->wk_lock);\r\nBUG_ON(!omap_port->wk_refcount);\r\nif (--omap_port->wk_refcount) {\r\nspin_unlock_bh(&omap_port->wk_lock);\r\nreturn 0;\r\n}\r\nwritel(SSI_WAKE(0), omap_ssi->sys + SSI_CLEAR_WAKE_REG(port->num));\r\npm_runtime_put_sync(omap_port->pdev);\r\nspin_unlock_bh(&omap_port->wk_lock);\r\nreturn 0;\r\n}\r\nstatic void ssi_transfer(struct omap_ssi_port *omap_port,\r\nstruct list_head *queue)\r\n{\r\nstruct hsi_msg *msg;\r\nint err = -1;\r\nspin_lock_bh(&omap_port->lock);\r\nwhile (err < 0) {\r\nerr = ssi_start_transfer(queue);\r\nif (err < 0) {\r\nmsg = list_first_entry(queue, struct hsi_msg, link);\r\nmsg->status = HSI_STATUS_ERROR;\r\nmsg->actual_len = 0;\r\nlist_del(&msg->link);\r\nspin_unlock_bh(&omap_port->lock);\r\nmsg->complete(msg);\r\nspin_lock_bh(&omap_port->lock);\r\n}\r\n}\r\nspin_unlock_bh(&omap_port->lock);\r\n}\r\nstatic void ssi_cleanup_queues(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nstruct hsi_msg *msg;\r\nunsigned int i;\r\nu32 rxbufstate = 0;\r\nu32 txbufstate = 0;\r\nu32 status = SSI_ERROROCCURED;\r\nu32 tmp;\r\nssi_flush_queue(&omap_port->brkqueue, cl);\r\nif (list_empty(&omap_port->brkqueue))\r\nstatus |= SSI_BREAKDETECTED;\r\nfor (i = 0; i < omap_port->channels; i++) {\r\nif (list_empty(&omap_port->txqueue[i]))\r\ncontinue;\r\nmsg = list_first_entry(&omap_port->txqueue[i], struct hsi_msg,\r\nlink);\r\nif ((msg->cl == cl) && (msg->status == HSI_STATUS_PROCEEDING)) {\r\ntxbufstate |= (1 << i);\r\nstatus |= SSI_DATAACCEPT(i);\r\npm_runtime_put_sync(omap_port->pdev);\r\n}\r\nssi_flush_queue(&omap_port->txqueue[i], cl);\r\n}\r\nfor (i = 0; i < omap_port->channels; i++) {\r\nif (list_empty(&omap_port->rxqueue[i]))\r\ncontinue;\r\nmsg = list_first_entry(&omap_port->rxqueue[i], struct hsi_msg,\r\nlink);\r\nif ((msg->cl == cl) && (msg->status == HSI_STATUS_PROCEEDING)) {\r\nrxbufstate |= (1 << i);\r\nstatus |= SSI_DATAAVAILABLE(i);\r\n}\r\nssi_flush_queue(&omap_port->rxqueue[i], cl);\r\nif (!list_empty(&omap_port->rxqueue[i]))\r\nstatus &= ~SSI_ERROROCCURED;\r\n}\r\ntmp = readl(omap_port->sst_base + SSI_SST_BUFSTATE_REG);\r\ntmp &= ~txbufstate;\r\nwritel_relaxed(tmp, omap_port->sst_base + SSI_SST_BUFSTATE_REG);\r\ntmp = readl(omap_port->ssr_base + SSI_SSR_BUFSTATE_REG);\r\ntmp &= ~rxbufstate;\r\nwritel_relaxed(tmp, omap_port->ssr_base + SSI_SSR_BUFSTATE_REG);\r\ntmp = readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\ntmp &= ~status;\r\nwritel_relaxed(tmp, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nwritel_relaxed(status, omap_ssi->sys +\r\nSSI_MPU_STATUS_REG(port->num, 0));\r\n}\r\nstatic void ssi_cleanup_gdd(struct hsi_controller *ssi, struct hsi_client *cl)\r\n{\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_msg *msg;\r\nunsigned int i;\r\nu32 val = 0;\r\nu32 tmp;\r\nfor (i = 0; i < SSI_MAX_GDD_LCH; i++) {\r\nmsg = omap_ssi->gdd_trn[i].msg;\r\nif ((!msg) || (msg->cl != cl))\r\ncontinue;\r\nwritew_relaxed(0, omap_ssi->gdd + SSI_GDD_CCR_REG(i));\r\nval |= (1 << i);\r\nif (msg->ttype == HSI_MSG_READ)\r\npm_runtime_put_sync(omap_port->pdev);\r\nomap_ssi->gdd_trn[i].msg = NULL;\r\n}\r\ntmp = readl_relaxed(omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\ntmp &= ~val;\r\nwritel_relaxed(tmp, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\nwritel(val, omap_ssi->sys + SSI_GDD_MPU_IRQ_STATUS_REG);\r\n}\r\nstatic int ssi_set_port_mode(struct omap_ssi_port *omap_port, u32 mode)\r\n{\r\nwritel(mode, omap_port->sst_base + SSI_SST_MODE_REG);\r\nwritel(mode, omap_port->ssr_base + SSI_SSR_MODE_REG);\r\nmode = readl(omap_port->ssr_base + SSI_SSR_MODE_REG);\r\nreturn 0;\r\n}\r\nstatic int ssi_release(struct hsi_client *cl)\r\n{\r\nstruct hsi_port *port = hsi_get_port(cl);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nspin_lock_bh(&omap_port->lock);\r\npm_runtime_get_sync(omap_port->pdev);\r\nssi_cleanup_gdd(ssi, cl);\r\nssi_cleanup_queues(cl);\r\npm_runtime_put_sync(omap_port->pdev);\r\nif (port->claimed <= 1) {\r\nif (omap_port->wkin_cken) {\r\npm_runtime_put_sync(omap_port->pdev);\r\nomap_port->wkin_cken = 0;\r\n}\r\npm_runtime_get_sync(omap_port->pdev);\r\nssi_set_port_mode(omap_port, SSI_MODE_SLEEP);\r\nomap_port->sst.mode = SSI_MODE_SLEEP;\r\nomap_port->ssr.mode = SSI_MODE_SLEEP;\r\npm_runtime_put_sync(omap_port->pdev);\r\nWARN_ON(omap_port->wk_refcount != 0);\r\n}\r\nspin_unlock_bh(&omap_port->lock);\r\nreturn 0;\r\n}\r\nstatic void ssi_error(struct hsi_port *port)\r\n{\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nstruct hsi_msg *msg;\r\nunsigned int i;\r\nu32 err;\r\nu32 val;\r\nu32 tmp;\r\nerr = readl(omap_port->ssr_base + SSI_SSR_ERROR_REG);\r\ndev_err(&port->device, "SSI error: 0x%02x\n", err);\r\nif (!err) {\r\ndev_dbg(&port->device, "spurious SSI error ignored!\n");\r\nreturn;\r\n}\r\nspin_lock(&omap_ssi->lock);\r\nfor (i = 0, val = 0; i < SSI_MAX_GDD_LCH; i++) {\r\nmsg = omap_ssi->gdd_trn[i].msg;\r\nif ((msg) && (msg->ttype == HSI_MSG_READ)) {\r\nwritew_relaxed(0, omap_ssi->gdd + SSI_GDD_CCR_REG(i));\r\nval |= (1 << i);\r\nomap_ssi->gdd_trn[i].msg = NULL;\r\n}\r\n}\r\ntmp = readl(omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\ntmp &= ~val;\r\nwritel_relaxed(tmp, omap_ssi->sys + SSI_GDD_MPU_IRQ_ENABLE_REG);\r\nspin_unlock(&omap_ssi->lock);\r\nspin_lock(&omap_port->lock);\r\ntmp = readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\ntmp &= 0xfeff00ff;\r\nwritel_relaxed(tmp, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nwritel_relaxed(err, omap_port->ssr_base + SSI_SSR_ERRORACK_REG);\r\nwritel_relaxed(SSI_ERROROCCURED,\r\nomap_ssi->sys + SSI_MPU_STATUS_REG(port->num, 0));\r\nfor (i = 0; i < omap_port->channels; i++) {\r\nif (list_empty(&omap_port->rxqueue[i]))\r\ncontinue;\r\nmsg = list_first_entry(&omap_port->rxqueue[i], struct hsi_msg,\r\nlink);\r\nlist_del(&msg->link);\r\nmsg->status = HSI_STATUS_ERROR;\r\nspin_unlock(&omap_port->lock);\r\nmsg->complete(msg);\r\nssi_transfer(omap_port, &omap_port->rxqueue[i]);\r\nspin_lock(&omap_port->lock);\r\n}\r\nspin_unlock(&omap_port->lock);\r\n}\r\nstatic void ssi_break_complete(struct hsi_port *port)\r\n{\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nstruct hsi_msg *msg;\r\nstruct hsi_msg *tmp;\r\nu32 val;\r\ndev_dbg(&port->device, "HWBREAK received\n");\r\nspin_lock(&omap_port->lock);\r\nval = readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nval &= ~SSI_BREAKDETECTED;\r\nwritel_relaxed(val, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nwritel_relaxed(0, omap_port->ssr_base + SSI_SSR_BREAK_REG);\r\nwritel(SSI_BREAKDETECTED,\r\nomap_ssi->sys + SSI_MPU_STATUS_REG(port->num, 0));\r\nspin_unlock(&omap_port->lock);\r\nlist_for_each_entry_safe(msg, tmp, &omap_port->brkqueue, link) {\r\nmsg->status = HSI_STATUS_COMPLETED;\r\nspin_lock(&omap_port->lock);\r\nlist_del(&msg->link);\r\nspin_unlock(&omap_port->lock);\r\nmsg->complete(msg);\r\n}\r\n}\r\nstatic void ssi_pio_complete(struct hsi_port *port, struct list_head *queue)\r\n{\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_msg *msg;\r\nu32 *buf;\r\nu32 reg;\r\nu32 val;\r\nspin_lock(&omap_port->lock);\r\nmsg = list_first_entry(queue, struct hsi_msg, link);\r\nif ((!msg->sgt.nents) || (!msg->sgt.sgl->length)) {\r\nmsg->actual_len = 0;\r\nmsg->status = HSI_STATUS_PENDING;\r\n}\r\nif (msg->ttype == HSI_MSG_WRITE)\r\nval = SSI_DATAACCEPT(msg->channel);\r\nelse\r\nval = SSI_DATAAVAILABLE(msg->channel);\r\nif (msg->status == HSI_STATUS_PROCEEDING) {\r\nbuf = sg_virt(msg->sgt.sgl) + msg->actual_len;\r\nif (msg->ttype == HSI_MSG_WRITE)\r\nwritel(*buf, omap_port->sst_base +\r\nSSI_SST_BUFFER_CH_REG(msg->channel));\r\nelse\r\n*buf = readl(omap_port->ssr_base +\r\nSSI_SSR_BUFFER_CH_REG(msg->channel));\r\ndev_dbg(&port->device, "ch %d ttype %d 0x%08x\n", msg->channel,\r\nmsg->ttype, *buf);\r\nmsg->actual_len += sizeof(*buf);\r\nif (msg->actual_len >= msg->sgt.sgl->length)\r\nmsg->status = HSI_STATUS_COMPLETED;\r\nif ((msg->status == HSI_STATUS_PROCEEDING) ||\r\n((msg->status == HSI_STATUS_COMPLETED) &&\r\n(msg->ttype == HSI_MSG_WRITE))) {\r\nwritel(val, omap_ssi->sys +\r\nSSI_MPU_STATUS_REG(port->num, 0));\r\nspin_unlock(&omap_port->lock);\r\nreturn;\r\n}\r\n}\r\nreg = readl(omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nif (msg->ttype == HSI_MSG_WRITE) {\r\npm_runtime_put_sync(omap_port->pdev);\r\n}\r\nreg &= ~val;\r\nwritel_relaxed(reg, omap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nwritel_relaxed(val, omap_ssi->sys + SSI_MPU_STATUS_REG(port->num, 0));\r\nlist_del(&msg->link);\r\nspin_unlock(&omap_port->lock);\r\nmsg->complete(msg);\r\nssi_transfer(omap_port, queue);\r\n}\r\nstatic void ssi_pio_tasklet(unsigned long ssi_port)\r\n{\r\nstruct hsi_port *port = (struct hsi_port *)ssi_port;\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nvoid __iomem *sys = omap_ssi->sys;\r\nunsigned int ch;\r\nu32 status_reg;\r\npm_runtime_get_sync(omap_port->pdev);\r\nstatus_reg = readl(sys + SSI_MPU_STATUS_REG(port->num, 0));\r\nstatus_reg &= readl(sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nfor (ch = 0; ch < omap_port->channels; ch++) {\r\nif (status_reg & SSI_DATAACCEPT(ch))\r\nssi_pio_complete(port, &omap_port->txqueue[ch]);\r\nif (status_reg & SSI_DATAAVAILABLE(ch))\r\nssi_pio_complete(port, &omap_port->rxqueue[ch]);\r\n}\r\nif (status_reg & SSI_BREAKDETECTED)\r\nssi_break_complete(port);\r\nif (status_reg & SSI_ERROROCCURED)\r\nssi_error(port);\r\nstatus_reg = readl(sys + SSI_MPU_STATUS_REG(port->num, 0));\r\nstatus_reg &= readl(sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\npm_runtime_put_sync(omap_port->pdev);\r\nif (status_reg)\r\ntasklet_hi_schedule(&omap_port->pio_tasklet);\r\nelse\r\nenable_irq(omap_port->irq);\r\n}\r\nstatic irqreturn_t ssi_pio_isr(int irq, void *port)\r\n{\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\ntasklet_hi_schedule(&omap_port->pio_tasklet);\r\ndisable_irq_nosync(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ssi_wake_tasklet(unsigned long ssi_port)\r\n{\r\nstruct hsi_port *port = (struct hsi_port *)ssi_port;\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nif (ssi_wakein(port)) {\r\nspin_lock(&omap_port->lock);\r\nif (!omap_port->wkin_cken) {\r\nomap_port->wkin_cken = 1;\r\npm_runtime_get_sync(omap_port->pdev);\r\n}\r\nspin_unlock(&omap_port->lock);\r\ndev_dbg(&ssi->device, "Wake in high\n");\r\nif (omap_port->wktest) {\r\nwritel(SSI_WAKE(0),\r\nomap_ssi->sys + SSI_SET_WAKE_REG(port->num));\r\n}\r\nhsi_event(port, HSI_EVENT_START_RX);\r\n} else {\r\ndev_dbg(&ssi->device, "Wake in low\n");\r\nif (omap_port->wktest) {\r\nwritel(SSI_WAKE(0),\r\nomap_ssi->sys + SSI_CLEAR_WAKE_REG(port->num));\r\n}\r\nhsi_event(port, HSI_EVENT_STOP_RX);\r\nspin_lock(&omap_port->lock);\r\nif (omap_port->wkin_cken) {\r\npm_runtime_put_sync(omap_port->pdev);\r\nomap_port->wkin_cken = 0;\r\n}\r\nspin_unlock(&omap_port->lock);\r\n}\r\n}\r\nstatic irqreturn_t ssi_wake_isr(int irq __maybe_unused, void *ssi_port)\r\n{\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(ssi_port);\r\ntasklet_hi_schedule(&omap_port->wake_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init ssi_port_irq(struct hsi_port *port,\r\nstruct platform_device *pd)\r\n{\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nint err;\r\nerr = platform_get_irq(pd, 0);\r\nif (err < 0) {\r\ndev_err(&port->device, "Port IRQ resource missing\n");\r\nreturn err;\r\n}\r\nomap_port->irq = err;\r\ntasklet_init(&omap_port->pio_tasklet, ssi_pio_tasklet,\r\n(unsigned long)port);\r\nerr = devm_request_irq(&port->device, omap_port->irq, ssi_pio_isr,\r\n0, "mpu_irq0", port);\r\nif (err < 0)\r\ndev_err(&port->device, "Request IRQ %d failed (%d)\n",\r\nomap_port->irq, err);\r\nreturn err;\r\n}\r\nstatic int __init ssi_wake_irq(struct hsi_port *port,\r\nstruct platform_device *pd)\r\n{\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nint cawake_irq;\r\nint err;\r\nif (omap_port->wake_gpio == -1) {\r\nomap_port->wake_irq = -1;\r\nreturn 0;\r\n}\r\ncawake_irq = gpio_to_irq(omap_port->wake_gpio);\r\nomap_port->wake_irq = cawake_irq;\r\ntasklet_init(&omap_port->wake_tasklet, ssi_wake_tasklet,\r\n(unsigned long)port);\r\nerr = devm_request_irq(&port->device, cawake_irq, ssi_wake_isr,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"cawake", port);\r\nif (err < 0)\r\ndev_err(&port->device, "Request Wake in IRQ %d failed %d\n",\r\ncawake_irq, err);\r\nerr = enable_irq_wake(cawake_irq);\r\nif (err < 0)\r\ndev_err(&port->device, "Enable wake on the wakeline in irq %d failed %d\n",\r\ncawake_irq, err);\r\nreturn err;\r\n}\r\nstatic void __init ssi_queues_init(struct omap_ssi_port *omap_port)\r\n{\r\nunsigned int ch;\r\nfor (ch = 0; ch < SSI_MAX_CHANNELS; ch++) {\r\nINIT_LIST_HEAD(&omap_port->txqueue[ch]);\r\nINIT_LIST_HEAD(&omap_port->rxqueue[ch]);\r\n}\r\nINIT_LIST_HEAD(&omap_port->brkqueue);\r\n}\r\nstatic int __init ssi_port_get_iomem(struct platform_device *pd,\r\nconst char *name, void __iomem **pbase, dma_addr_t *phy)\r\n{\r\nstruct hsi_port *port = platform_get_drvdata(pd);\r\nstruct resource *mem;\r\nstruct resource *ioarea;\r\nvoid __iomem *base;\r\nmem = platform_get_resource_byname(pd, IORESOURCE_MEM, name);\r\nif (!mem) {\r\ndev_err(&pd->dev, "IO memory region missing (%s)\n", name);\r\nreturn -ENXIO;\r\n}\r\nioarea = devm_request_mem_region(&port->device, mem->start,\r\nresource_size(mem), dev_name(&pd->dev));\r\nif (!ioarea) {\r\ndev_err(&pd->dev, "%s IO memory region request failed\n",\r\nmem->name);\r\nreturn -ENXIO;\r\n}\r\nbase = devm_ioremap(&port->device, mem->start, resource_size(mem));\r\nif (!base) {\r\ndev_err(&pd->dev, "%s IO remap failed\n", mem->name);\r\nreturn -ENXIO;\r\n}\r\n*pbase = base;\r\nif (phy)\r\n*phy = mem->start;\r\nreturn 0;\r\n}\r\nstatic int __init ssi_port_probe(struct platform_device *pd)\r\n{\r\nstruct device_node *np = pd->dev.of_node;\r\nstruct hsi_port *port;\r\nstruct omap_ssi_port *omap_port;\r\nstruct hsi_controller *ssi = dev_get_drvdata(pd->dev.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nu32 cawake_gpio = 0;\r\nu32 port_id;\r\nint err;\r\ndev_dbg(&pd->dev, "init ssi port...\n");\r\nif (!try_module_get(ssi->owner)) {\r\ndev_err(&pd->dev, "could not increment parent module refcount (err=%d)\n",\r\nerr);\r\nreturn -ENODEV;\r\n}\r\nif (!ssi->port || !omap_ssi->port) {\r\ndev_err(&pd->dev, "ssi controller not initialized!\n");\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nfor (port_id = 0; port_id < ssi->num_ports && omap_ssi->port[port_id];\r\nport_id++)\r\n;\r\nif (port_id >= ssi->num_ports) {\r\ndev_err(&pd->dev, "port id out of range!\n");\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nport = ssi->port[port_id];\r\nif (!np) {\r\ndev_err(&pd->dev, "missing device tree data\n");\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\ncawake_gpio = of_get_named_gpio(np, "ti,ssi-cawake-gpio", 0);\r\nif (cawake_gpio < 0) {\r\ndev_err(&pd->dev, "DT data is missing cawake gpio (err=%d)\n",\r\ncawake_gpio);\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nerr = devm_gpio_request_one(&port->device, cawake_gpio, GPIOF_DIR_IN,\r\n"cawake");\r\nif (err) {\r\ndev_err(&pd->dev, "could not request cawake gpio (err=%d)!\n",\r\nerr);\r\nerr = -ENXIO;\r\ngoto error;\r\n}\r\nomap_port = devm_kzalloc(&port->device, sizeof(*omap_port), GFP_KERNEL);\r\nif (!omap_port) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nomap_port->wake_gpio = cawake_gpio;\r\nomap_port->pdev = &pd->dev;\r\nomap_port->port_id = port_id;\r\nport->async = ssi_async;\r\nport->setup = ssi_setup;\r\nport->flush = ssi_flush;\r\nport->start_tx = ssi_start_tx;\r\nport->stop_tx = ssi_stop_tx;\r\nport->release = ssi_release;\r\nhsi_port_set_drvdata(port, omap_port);\r\nomap_ssi->port[port_id] = omap_port;\r\nplatform_set_drvdata(pd, port);\r\nerr = ssi_port_get_iomem(pd, "tx", &omap_port->sst_base,\r\n&omap_port->sst_dma);\r\nif (err < 0)\r\ngoto error;\r\nerr = ssi_port_get_iomem(pd, "rx", &omap_port->ssr_base,\r\n&omap_port->ssr_dma);\r\nif (err < 0)\r\ngoto error;\r\nerr = ssi_port_irq(port, pd);\r\nif (err < 0)\r\ngoto error;\r\nerr = ssi_wake_irq(port, pd);\r\nif (err < 0)\r\ngoto error;\r\nssi_queues_init(omap_port);\r\nspin_lock_init(&omap_port->lock);\r\nspin_lock_init(&omap_port->wk_lock);\r\nomap_port->dev = &port->device;\r\npm_runtime_irq_safe(omap_port->pdev);\r\npm_runtime_enable(omap_port->pdev);\r\n#ifdef CONFIG_DEBUG_FS\r\nerr = ssi_debug_add_port(omap_port, omap_ssi->dir);\r\nif (err < 0) {\r\npm_runtime_disable(omap_port->pdev);\r\ngoto error;\r\n}\r\n#endif\r\nhsi_add_clients_from_dt(port, np);\r\ndev_info(&pd->dev, "ssi port %u successfully initialized (cawake=%d)\n",\r\nport_id, cawake_gpio);\r\nreturn 0;\r\nerror:\r\nreturn err;\r\n}\r\nstatic int __exit ssi_port_remove(struct platform_device *pd)\r\n{\r\nstruct hsi_port *port = platform_get_drvdata(pd);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\n#ifdef CONFIG_DEBUG_FS\r\nssi_debug_remove_port(port);\r\n#endif\r\nhsi_port_unregister_clients(port);\r\ntasklet_kill(&omap_port->wake_tasklet);\r\ntasklet_kill(&omap_port->pio_tasklet);\r\nport->async = hsi_dummy_msg;\r\nport->setup = hsi_dummy_cl;\r\nport->flush = hsi_dummy_cl;\r\nport->start_tx = hsi_dummy_cl;\r\nport->stop_tx = hsi_dummy_cl;\r\nport->release = hsi_dummy_cl;\r\nomap_ssi->port[omap_port->port_id] = NULL;\r\nplatform_set_drvdata(pd, NULL);\r\nmodule_put(ssi->owner);\r\npm_runtime_disable(&pd->dev);\r\nreturn 0;\r\n}\r\nstatic int ssi_save_port_ctx(struct omap_ssi_port *omap_port)\r\n{\r\nstruct hsi_port *port = to_hsi_port(omap_port->dev);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nomap_port->sys_mpu_enable = readl(omap_ssi->sys +\r\nSSI_MPU_ENABLE_REG(port->num, 0));\r\nreturn 0;\r\n}\r\nstatic int ssi_restore_port_ctx(struct omap_ssi_port *omap_port)\r\n{\r\nstruct hsi_port *port = to_hsi_port(omap_port->dev);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\nvoid __iomem *base;\r\nwritel_relaxed(omap_port->sys_mpu_enable,\r\nomap_ssi->sys + SSI_MPU_ENABLE_REG(port->num, 0));\r\nbase = omap_port->sst_base;\r\nwritel_relaxed(omap_port->sst.frame_size, base + SSI_SST_FRAMESIZE_REG);\r\nwritel_relaxed(omap_port->sst.channels, base + SSI_SST_CHANNELS_REG);\r\nwritel_relaxed(omap_port->sst.arb_mode, base + SSI_SST_ARBMODE_REG);\r\nbase = omap_port->ssr_base;\r\nwritel_relaxed(omap_port->ssr.frame_size, base + SSI_SSR_FRAMESIZE_REG);\r\nwritel_relaxed(omap_port->ssr.channels, base + SSI_SSR_CHANNELS_REG);\r\nwritel_relaxed(omap_port->ssr.timeout, base + SSI_SSR_TIMEOUT_REG);\r\nreturn 0;\r\n}\r\nstatic int ssi_restore_port_mode(struct omap_ssi_port *omap_port)\r\n{\r\nu32 mode;\r\nwritel_relaxed(omap_port->sst.mode,\r\nomap_port->sst_base + SSI_SST_MODE_REG);\r\nwritel_relaxed(omap_port->ssr.mode,\r\nomap_port->ssr_base + SSI_SSR_MODE_REG);\r\nmode = readl(omap_port->ssr_base + SSI_SSR_MODE_REG);\r\nreturn 0;\r\n}\r\nstatic int ssi_restore_divisor(struct omap_ssi_port *omap_port)\r\n{\r\nwritel_relaxed(omap_port->sst.divisor,\r\nomap_port->sst_base + SSI_SST_DIVISOR_REG);\r\nreturn 0;\r\n}\r\nstatic int omap_ssi_port_runtime_suspend(struct device *dev)\r\n{\r\nstruct hsi_port *port = dev_get_drvdata(dev);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\ndev_dbg(dev, "port runtime suspend!\n");\r\nssi_set_port_mode(omap_port, SSI_MODE_SLEEP);\r\nif (omap_ssi->get_loss)\r\nomap_port->loss_count =\r\nomap_ssi->get_loss(ssi->device.parent);\r\nssi_save_port_ctx(omap_port);\r\nreturn 0;\r\n}\r\nstatic int omap_ssi_port_runtime_resume(struct device *dev)\r\n{\r\nstruct hsi_port *port = dev_get_drvdata(dev);\r\nstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\r\nstruct hsi_controller *ssi = to_hsi_controller(port->device.parent);\r\nstruct omap_ssi_controller *omap_ssi = hsi_controller_drvdata(ssi);\r\ndev_dbg(dev, "port runtime resume!\n");\r\nif ((omap_ssi->get_loss) && (omap_port->loss_count ==\r\nomap_ssi->get_loss(ssi->device.parent)))\r\ngoto mode;\r\nssi_restore_port_ctx(omap_port);\r\nmode:\r\nssi_restore_divisor(omap_port);\r\nssi_restore_port_mode(omap_port);\r\nreturn 0;\r\n}
