static int mdp5_select_hw_cfg(struct msm_kms *kms)\r\n{\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nuint32_t version, major, minor;\r\nint i, ret = 0;\r\nmdp5_enable(mdp5_kms);\r\nversion = mdp5_read(mdp5_kms, REG_MDP5_MDP_VERSION);\r\nmdp5_disable(mdp5_kms);\r\nmajor = FIELD(version, MDP5_MDP_VERSION_MAJOR);\r\nminor = FIELD(version, MDP5_MDP_VERSION_MINOR);\r\nDBG("found MDP5 version v%d.%d", major, minor);\r\nif (major != 1) {\r\ndev_err(dev->dev, "unexpected MDP major version: v%d.%d\n",\r\nmajor, minor);\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nmdp5_kms->rev = minor;\r\nfor (i = 0; i < ARRAY_SIZE(mdp5_configs); i++) {\r\nif (mdp5_configs[i].revision != minor)\r\ncontinue;\r\nmdp5_kms->hw_cfg = mdp5_cfg = mdp5_configs[i].config;\r\nbreak;\r\n}\r\nif (unlikely(!mdp5_kms->hw_cfg)) {\r\ndev_err(dev->dev, "unexpected MDP minor revision: v%d.%d\n",\r\nmajor, minor);\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nDBG("MDP5: %s config selected", mdp5_kms->hw_cfg->name);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int mdp5_hw_init(struct msm_kms *kms)\r\n{\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nint i;\r\npm_runtime_get_sync(dev->dev);\r\nmdp5_write(mdp5_kms, REG_MDP5_DISP_INTF_SEL, 0);\r\nfor (i = 0; i < mdp5_kms->hw_cfg->ctl.count; i++)\r\nmdp5_write(mdp5_kms, REG_MDP5_CTL_OP(i), 0);\r\npm_runtime_put_sync(dev->dev);\r\nreturn 0;\r\n}\r\nstatic long mdp5_round_pixclk(struct msm_kms *kms, unsigned long rate,\r\nstruct drm_encoder *encoder)\r\n{\r\nreturn rate;\r\n}\r\nstatic void mdp5_preclose(struct msm_kms *kms, struct drm_file *file)\r\n{\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nstruct msm_drm_private *priv = mdp5_kms->dev->dev_private;\r\nunsigned i;\r\nfor (i = 0; i < priv->num_crtcs; i++)\r\nmdp5_crtc_cancel_pending_flip(priv->crtcs[i], file);\r\n}\r\nstatic void mdp5_destroy(struct msm_kms *kms)\r\n{\r\nstruct mdp5_kms *mdp5_kms = to_mdp5_kms(to_mdp_kms(kms));\r\nstruct msm_mmu *mmu = mdp5_kms->mmu;\r\nif (mmu) {\r\nmmu->funcs->detach(mmu, iommu_ports, ARRAY_SIZE(iommu_ports));\r\nmmu->funcs->destroy(mmu);\r\n}\r\nkfree(mdp5_kms);\r\n}\r\nint mdp5_disable(struct mdp5_kms *mdp5_kms)\r\n{\r\nDBG("");\r\nclk_disable_unprepare(mdp5_kms->ahb_clk);\r\nclk_disable_unprepare(mdp5_kms->axi_clk);\r\nclk_disable_unprepare(mdp5_kms->core_clk);\r\nclk_disable_unprepare(mdp5_kms->lut_clk);\r\nreturn 0;\r\n}\r\nint mdp5_enable(struct mdp5_kms *mdp5_kms)\r\n{\r\nDBG("");\r\nclk_prepare_enable(mdp5_kms->ahb_clk);\r\nclk_prepare_enable(mdp5_kms->axi_clk);\r\nclk_prepare_enable(mdp5_kms->core_clk);\r\nclk_prepare_enable(mdp5_kms->lut_clk);\r\nreturn 0;\r\n}\r\nstatic int modeset_init(struct mdp5_kms *mdp5_kms)\r\n{\r\nstatic const enum mdp5_pipe crtcs[] = {\r\nSSPP_RGB0, SSPP_RGB1, SSPP_RGB2, SSPP_RGB3,\r\n};\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nint i, ret;\r\nfor (i = 0; i < mdp5_kms->hw_cfg->pipe_rgb.count; i++) {\r\nstruct drm_plane *plane;\r\nstruct drm_crtc *crtc;\r\nplane = mdp5_plane_init(dev, crtcs[i], true);\r\nif (IS_ERR(plane)) {\r\nret = PTR_ERR(plane);\r\ndev_err(dev->dev, "failed to construct plane for %s (%d)\n",\r\npipe2name(crtcs[i]), ret);\r\ngoto fail;\r\n}\r\ncrtc = mdp5_crtc_init(dev, plane, i);\r\nif (IS_ERR(crtc)) {\r\nret = PTR_ERR(crtc);\r\ndev_err(dev->dev, "failed to construct crtc for %s (%d)\n",\r\npipe2name(crtcs[i]), ret);\r\ngoto fail;\r\n}\r\npriv->crtcs[priv->num_crtcs++] = crtc;\r\n}\r\nencoder = mdp5_encoder_init(dev, 3, INTF_HDMI);\r\nif (IS_ERR(encoder)) {\r\ndev_err(dev->dev, "failed to construct encoder\n");\r\nret = PTR_ERR(encoder);\r\ngoto fail;\r\n}\r\nencoder->possible_crtcs = BIT(0);\r\nmdp5_crtc_set_intf(priv->crtcs[0], 3, INTF_HDMI);\r\npriv->encoders[priv->num_encoders++] = encoder;\r\nmdp5_kms->hdmi = hdmi_init(dev, encoder);\r\nif (IS_ERR(mdp5_kms->hdmi)) {\r\nret = PTR_ERR(mdp5_kms->hdmi);\r\ndev_err(dev->dev, "failed to initialize HDMI: %d\n", ret);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int get_clk(struct platform_device *pdev, struct clk **clkp,\r\nconst char *name)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct clk *clk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "failed to get %s (%ld)\n", name, PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\n*clkp = clk;\r\nreturn 0;\r\n}\r\nstruct msm_kms *mdp5_kms_init(struct drm_device *dev)\r\n{\r\nstruct platform_device *pdev = dev->platformdev;\r\nstruct mdp5_platform_config *config = mdp5_get_config(pdev);\r\nstruct mdp5_kms *mdp5_kms;\r\nstruct msm_kms *kms = NULL;\r\nstruct msm_mmu *mmu;\r\nint i, ret;\r\nmdp5_kms = kzalloc(sizeof(*mdp5_kms), GFP_KERNEL);\r\nif (!mdp5_kms) {\r\ndev_err(dev->dev, "failed to allocate kms\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmdp_kms_init(&mdp5_kms->base, &kms_funcs);\r\nkms = &mdp5_kms->base.base;\r\nmdp5_kms->dev = dev;\r\nmdp5_kms->smp_blk_cnt = config->smp_blk_cnt;\r\nmdp5_kms->mmio = msm_ioremap(pdev, "mdp_phys", "MDP5");\r\nif (IS_ERR(mdp5_kms->mmio)) {\r\nret = PTR_ERR(mdp5_kms->mmio);\r\ngoto fail;\r\n}\r\nmdp5_kms->vbif = msm_ioremap(pdev, "vbif_phys", "VBIF");\r\nif (IS_ERR(mdp5_kms->vbif)) {\r\nret = PTR_ERR(mdp5_kms->vbif);\r\ngoto fail;\r\n}\r\nmdp5_kms->vdd = devm_regulator_get(&pdev->dev, "vdd");\r\nif (IS_ERR(mdp5_kms->vdd)) {\r\nret = PTR_ERR(mdp5_kms->vdd);\r\ngoto fail;\r\n}\r\nret = regulator_enable(mdp5_kms->vdd);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to enable regulator vdd: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = get_clk(pdev, &mdp5_kms->axi_clk, "bus_clk");\r\nif (ret)\r\ngoto fail;\r\nret = get_clk(pdev, &mdp5_kms->ahb_clk, "iface_clk");\r\nif (ret)\r\ngoto fail;\r\nret = get_clk(pdev, &mdp5_kms->src_clk, "core_clk_src");\r\nif (ret)\r\ngoto fail;\r\nret = get_clk(pdev, &mdp5_kms->core_clk, "core_clk");\r\nif (ret)\r\ngoto fail;\r\nret = get_clk(pdev, &mdp5_kms->lut_clk, "lut_clk");\r\nif (ret)\r\ngoto fail;\r\nret = get_clk(pdev, &mdp5_kms->vsync_clk, "vsync_clk");\r\nif (ret)\r\ngoto fail;\r\nret = clk_set_rate(mdp5_kms->src_clk, config->max_clk);\r\nret = mdp5_select_hw_cfg(kms);\r\nif (ret)\r\ngoto fail;\r\nmdp5_enable(mdp5_kms);\r\nfor (i = 0; i < mdp5_kms->hw_cfg->intf.count; i++)\r\nmdp5_write(mdp5_kms, REG_MDP5_INTF_TIMING_ENGINE_EN(i), 0);\r\nmdp5_disable(mdp5_kms);\r\nmdelay(16);\r\nif (config->iommu) {\r\nmmu = msm_iommu_new(&pdev->dev, config->iommu);\r\nif (IS_ERR(mmu)) {\r\nret = PTR_ERR(mmu);\r\ndev_err(dev->dev, "failed to init iommu: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = mmu->funcs->attach(mmu, iommu_ports,\r\nARRAY_SIZE(iommu_ports));\r\nif (ret) {\r\ndev_err(dev->dev, "failed to attach iommu: %d\n", ret);\r\nmmu->funcs->destroy(mmu);\r\ngoto fail;\r\n}\r\n} else {\r\ndev_info(dev->dev, "no iommu, fallback to phys "\r\n"contig buffers for scanout\n");\r\nmmu = NULL;\r\n}\r\nmdp5_kms->mmu = mmu;\r\nmdp5_kms->id = msm_register_mmu(dev, mmu);\r\nif (mdp5_kms->id < 0) {\r\nret = mdp5_kms->id;\r\ndev_err(dev->dev, "failed to register mdp5 iommu: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = modeset_init(mdp5_kms);\r\nif (ret) {\r\ndev_err(dev->dev, "modeset_init failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nreturn kms;\r\nfail:\r\nif (kms)\r\nmdp5_destroy(kms);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct mdp5_platform_config *mdp5_get_config(struct platform_device *dev)\r\n{\r\nstatic struct mdp5_platform_config config = {};\r\n#ifdef CONFIG_OF\r\n#endif\r\nconfig.iommu = iommu_domain_alloc(&platform_bus_type);\r\nconfig.max_clk = 200000000;\r\nconfig.smp_blk_cnt = 22;\r\nreturn &config;\r\n}
