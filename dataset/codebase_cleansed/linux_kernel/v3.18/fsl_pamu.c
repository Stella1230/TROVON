u32 pamu_get_max_subwin_cnt(void)\r\n{\r\nreturn max_subwindow_count;\r\n}\r\nstatic struct paace *pamu_get_ppaace(int liodn)\r\n{\r\nif (!ppaact || liodn >= PAACE_NUMBER_ENTRIES) {\r\npr_debug("PPAACT doesn't exist\n");\r\nreturn NULL;\r\n}\r\nreturn &ppaact[liodn];\r\n}\r\nint pamu_enable_liodn(int liodn)\r\n{\r\nstruct paace *ppaace;\r\nppaace = pamu_get_ppaace(liodn);\r\nif (!ppaace) {\r\npr_debug("Invalid primary paace entry\n");\r\nreturn -ENOENT;\r\n}\r\nif (!get_bf(ppaace->addr_bitfields, PPAACE_AF_WSE)) {\r\npr_debug("liodn %d not configured\n", liodn);\r\nreturn -EINVAL;\r\n}\r\nmb();\r\nset_bf(ppaace->addr_bitfields, PAACE_AF_V, PAACE_V_VALID);\r\nmb();\r\nreturn 0;\r\n}\r\nint pamu_disable_liodn(int liodn)\r\n{\r\nstruct paace *ppaace;\r\nppaace = pamu_get_ppaace(liodn);\r\nif (!ppaace) {\r\npr_debug("Invalid primary paace entry\n");\r\nreturn -ENOENT;\r\n}\r\nset_bf(ppaace->addr_bitfields, PAACE_AF_V, PAACE_V_INVALID);\r\nmb();\r\nreturn 0;\r\n}\r\nstatic unsigned int map_addrspace_size_to_wse(phys_addr_t addrspace_size)\r\n{\r\nBUG_ON((addrspace_size & (addrspace_size - 1)));\r\nreturn fls64(addrspace_size) - 2;\r\n}\r\nstatic unsigned int map_subwindow_cnt_to_wce(u32 subwindow_cnt)\r\n{\r\nreturn __ffs(subwindow_cnt) - 1;\r\n}\r\nstatic void pamu_init_ppaace(struct paace *ppaace)\r\n{\r\nset_bf(ppaace->addr_bitfields, PAACE_AF_PT, PAACE_PT_PRIMARY);\r\nset_bf(ppaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,\r\nPAACE_M_COHERENCE_REQ);\r\n}\r\nstatic void pamu_init_spaace(struct paace *spaace)\r\n{\r\nset_bf(spaace->addr_bitfields, PAACE_AF_PT, PAACE_PT_SECONDARY);\r\nset_bf(spaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,\r\nPAACE_M_COHERENCE_REQ);\r\n}\r\nstatic struct paace *pamu_get_spaace(struct paace *paace, u32 wnum)\r\n{\r\nu32 subwin_cnt;\r\nstruct paace *spaace = NULL;\r\nsubwin_cnt = 1UL << (get_bf(paace->impl_attr, PAACE_IA_WCE) + 1);\r\nif (wnum < subwin_cnt)\r\nspaace = &spaact[paace->fspi + wnum];\r\nelse\r\npr_debug("secondary paace out of bounds\n");\r\nreturn spaace;\r\n}\r\nstatic unsigned long pamu_get_fspi_and_allocate(u32 subwin_cnt)\r\n{\r\nunsigned long spaace_addr;\r\nspaace_addr = gen_pool_alloc(spaace_pool, subwin_cnt * sizeof(struct paace));\r\nif (!spaace_addr)\r\nreturn ULONG_MAX;\r\nreturn (spaace_addr - (unsigned long)spaact) / (sizeof(struct paace));\r\n}\r\nvoid pamu_free_subwins(int liodn)\r\n{\r\nstruct paace *ppaace;\r\nu32 subwin_cnt, size;\r\nppaace = pamu_get_ppaace(liodn);\r\nif (!ppaace) {\r\npr_debug("Invalid liodn entry\n");\r\nreturn;\r\n}\r\nif (get_bf(ppaace->addr_bitfields, PPAACE_AF_MW)) {\r\nsubwin_cnt = 1UL << (get_bf(ppaace->impl_attr, PAACE_IA_WCE) + 1);\r\nsize = (subwin_cnt - 1) * sizeof(struct paace);\r\ngen_pool_free(spaace_pool, (unsigned long)&spaact[ppaace->fspi], size);\r\nset_bf(ppaace->addr_bitfields, PPAACE_AF_MW, 0);\r\n}\r\n}\r\nint pamu_update_paace_stash(int liodn, u32 subwin, u32 value)\r\n{\r\nstruct paace *paace;\r\npaace = pamu_get_ppaace(liodn);\r\nif (!paace) {\r\npr_debug("Invalid liodn entry\n");\r\nreturn -ENOENT;\r\n}\r\nif (subwin) {\r\npaace = pamu_get_spaace(paace, subwin - 1);\r\nif (!paace) {\r\nreturn -ENOENT;\r\n}\r\n}\r\nset_bf(paace->impl_attr, PAACE_IA_CID, value);\r\nmb();\r\nreturn 0;\r\n}\r\nint pamu_disable_spaace(int liodn, u32 subwin)\r\n{\r\nstruct paace *paace;\r\npaace = pamu_get_ppaace(liodn);\r\nif (!paace) {\r\npr_debug("Invalid liodn entry\n");\r\nreturn -ENOENT;\r\n}\r\nif (subwin) {\r\npaace = pamu_get_spaace(paace, subwin - 1);\r\nif (!paace) {\r\nreturn -ENOENT;\r\n}\r\nset_bf(paace->addr_bitfields, PAACE_AF_V,\r\nPAACE_V_INVALID);\r\n} else {\r\nset_bf(paace->addr_bitfields, PAACE_AF_AP,\r\nPAACE_AP_PERMS_DENIED);\r\n}\r\nmb();\r\nreturn 0;\r\n}\r\nint pamu_config_ppaace(int liodn, phys_addr_t win_addr, phys_addr_t win_size,\r\nu32 omi, unsigned long rpn, u32 snoopid, u32 stashid,\r\nu32 subwin_cnt, int prot)\r\n{\r\nstruct paace *ppaace;\r\nunsigned long fspi;\r\nif ((win_size & (win_size - 1)) || win_size < PAMU_PAGE_SIZE) {\r\npr_debug("window size too small or not a power of two %llx\n", win_size);\r\nreturn -EINVAL;\r\n}\r\nif (win_addr & (win_size - 1)) {\r\npr_debug("window address is not aligned with window size\n");\r\nreturn -EINVAL;\r\n}\r\nppaace = pamu_get_ppaace(liodn);\r\nif (!ppaace) {\r\nreturn -ENOENT;\r\n}\r\nset_bf(ppaace->addr_bitfields, PPAACE_AF_WSE,\r\nmap_addrspace_size_to_wse(win_size));\r\npamu_init_ppaace(ppaace);\r\nppaace->wbah = win_addr >> (PAMU_PAGE_SHIFT + 20);\r\nset_bf(ppaace->addr_bitfields, PPAACE_AF_WBAL,\r\n(win_addr >> PAMU_PAGE_SHIFT));\r\nif (omi < OME_NUMBER_ENTRIES) {\r\nset_bf(ppaace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);\r\nppaace->op_encode.index_ot.omi = omi;\r\n} else if (~omi != 0) {\r\npr_debug("bad operation mapping index: %d\n", omi);\r\nreturn -EINVAL;\r\n}\r\nif (~stashid != 0)\r\nset_bf(ppaace->impl_attr, PAACE_IA_CID, stashid);\r\nif (~snoopid != 0)\r\nppaace->domain_attr.to_host.snpid = snoopid;\r\nif (subwin_cnt) {\r\nfspi = pamu_get_fspi_and_allocate(subwin_cnt - 1);\r\nif (fspi == ULONG_MAX) {\r\npr_debug("spaace indexes exhausted\n");\r\nreturn -EINVAL;\r\n}\r\nset_bf(ppaace->impl_attr, PAACE_IA_WCE,\r\nmap_subwindow_cnt_to_wce(subwin_cnt));\r\nset_bf(ppaace->addr_bitfields, PPAACE_AF_MW, 0x1);\r\nppaace->fspi = fspi;\r\n} else {\r\nset_bf(ppaace->impl_attr, PAACE_IA_ATM, PAACE_ATM_WINDOW_XLATE);\r\nppaace->twbah = rpn >> 20;\r\nset_bf(ppaace->win_bitfields, PAACE_WIN_TWBAL, rpn);\r\nset_bf(ppaace->addr_bitfields, PAACE_AF_AP, prot);\r\nset_bf(ppaace->impl_attr, PAACE_IA_WCE, 0);\r\nset_bf(ppaace->addr_bitfields, PPAACE_AF_MW, 0);\r\n}\r\nmb();\r\nreturn 0;\r\n}\r\nint pamu_config_spaace(int liodn, u32 subwin_cnt, u32 subwin,\r\nphys_addr_t subwin_size, u32 omi, unsigned long rpn,\r\nu32 snoopid, u32 stashid, int enable, int prot)\r\n{\r\nstruct paace *paace;\r\nif (!subwin_cnt) {\r\npr_debug("Invalid subwindow count\n");\r\nreturn -EINVAL;\r\n}\r\npaace = pamu_get_ppaace(liodn);\r\nif (subwin > 0 && subwin < subwin_cnt && paace) {\r\npaace = pamu_get_spaace(paace, subwin - 1);\r\nif (paace && !(paace->addr_bitfields & PAACE_V_VALID)) {\r\npamu_init_spaace(paace);\r\nset_bf(paace->addr_bitfields, SPAACE_AF_LIODN, liodn);\r\n}\r\n}\r\nif (!paace) {\r\npr_debug("Invalid liodn entry\n");\r\nreturn -ENOENT;\r\n}\r\nif ((subwin_size & (subwin_size - 1)) || subwin_size < PAMU_PAGE_SIZE) {\r\npr_debug("subwindow size out of range, or not a power of 2\n");\r\nreturn -EINVAL;\r\n}\r\nif (rpn == ULONG_MAX) {\r\npr_debug("real page number out of range\n");\r\nreturn -EINVAL;\r\n}\r\nset_bf(paace->win_bitfields, PAACE_WIN_SWSE,\r\nmap_addrspace_size_to_wse(subwin_size));\r\nset_bf(paace->impl_attr, PAACE_IA_ATM, PAACE_ATM_WINDOW_XLATE);\r\npaace->twbah = rpn >> 20;\r\nset_bf(paace->win_bitfields, PAACE_WIN_TWBAL, rpn);\r\nset_bf(paace->addr_bitfields, PAACE_AF_AP, prot);\r\nif (~snoopid != 0)\r\npaace->domain_attr.to_host.snpid = snoopid;\r\nif (omi < OME_NUMBER_ENTRIES) {\r\nset_bf(paace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);\r\npaace->op_encode.index_ot.omi = omi;\r\n} else if (~omi != 0) {\r\npr_debug("bad operation mapping index: %d\n", omi);\r\nreturn -EINVAL;\r\n}\r\nif (~stashid != 0)\r\nset_bf(paace->impl_attr, PAACE_IA_CID, stashid);\r\nsmp_wmb();\r\nif (enable)\r\nset_bf(paace->addr_bitfields, PAACE_AF_V, PAACE_V_VALID);\r\nmb();\r\nreturn 0;\r\n}\r\nvoid get_ome_index(u32 *omi_index, struct device *dev)\r\n{\r\nif (of_device_is_compatible(dev->of_node, "fsl,qman-portal"))\r\n*omi_index = OMI_QMAN;\r\nif (of_device_is_compatible(dev->of_node, "fsl,qman"))\r\n*omi_index = OMI_QMAN_PRIV;\r\n}\r\nu32 get_stash_id(u32 stash_dest_hint, u32 vcpu)\r\n{\r\nconst u32 *prop;\r\nstruct device_node *node;\r\nu32 cache_level;\r\nint len, found = 0;\r\nint i;\r\nif (stash_dest_hint == PAMU_ATTR_CACHE_L3) {\r\nnode = of_find_matching_node(NULL, l3_device_ids);\r\nif (node) {\r\nprop = of_get_property(node, "cache-stash-id", 0);\r\nif (!prop) {\r\npr_debug("missing cache-stash-id at %s\n", node->full_name);\r\nof_node_put(node);\r\nreturn ~(u32)0;\r\n}\r\nof_node_put(node);\r\nreturn be32_to_cpup(prop);\r\n}\r\nreturn ~(u32)0;\r\n}\r\nfor_each_node_by_type(node, "cpu") {\r\nprop = of_get_property(node, "reg", &len);\r\nfor (i = 0; i < len / sizeof(u32); i++) {\r\nif (be32_to_cpup(&prop[i]) == vcpu) {\r\nfound = 1;\r\ngoto found_cpu_node;\r\n}\r\n}\r\n}\r\nfound_cpu_node:\r\nfor (cache_level = PAMU_ATTR_CACHE_L1; (cache_level < PAMU_ATTR_CACHE_L3) && found; cache_level++) {\r\nif (stash_dest_hint == cache_level) {\r\nprop = of_get_property(node, "cache-stash-id", 0);\r\nif (!prop) {\r\npr_debug("missing cache-stash-id at %s\n", node->full_name);\r\nof_node_put(node);\r\nreturn ~(u32)0;\r\n}\r\nof_node_put(node);\r\nreturn be32_to_cpup(prop);\r\n}\r\nprop = of_get_property(node, "next-level-cache", 0);\r\nif (!prop) {\r\npr_debug("can't find next-level-cache at %s\n",\r\nnode->full_name);\r\nof_node_put(node);\r\nreturn ~(u32)0;\r\n}\r\nof_node_put(node);\r\nnode = of_find_node_by_phandle(*prop);\r\nif (!node) {\r\npr_debug("Invalid node for cache hierarchy\n");\r\nreturn ~(u32)0;\r\n}\r\n}\r\npr_debug("stash dest not found for %d on vcpu %d\n",\r\nstash_dest_hint, vcpu);\r\nreturn ~(u32)0;\r\n}\r\nstatic void setup_qbman_paace(struct paace *ppaace, int paace_type)\r\n{\r\nswitch (paace_type) {\r\ncase QMAN_PAACE:\r\nset_bf(ppaace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);\r\nppaace->op_encode.index_ot.omi = OMI_QMAN_PRIV;\r\nset_bf(ppaace->impl_attr, PAACE_IA_CID, get_stash_id(PAMU_ATTR_CACHE_L3, 0));\r\nset_bf(ppaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,\r\n0);\r\nbreak;\r\ncase QMAN_PORTAL_PAACE:\r\nset_bf(ppaace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);\r\nppaace->op_encode.index_ot.omi = OMI_QMAN;\r\nset_bf(ppaace->impl_attr, PAACE_IA_CID, get_stash_id(PAMU_ATTR_CACHE_L3, 0));\r\nbreak;\r\ncase BMAN_PAACE:\r\nset_bf(ppaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,\r\n0);\r\nbreak;\r\n}\r\n}\r\nstatic void __init setup_omt(struct ome *omt)\r\n{\r\nstruct ome *ome;\r\nome = &omt[OMI_QMAN];\r\nome->moe[IOE_READ_IDX] = EOE_VALID | EOE_READ;\r\nome->moe[IOE_EREAD0_IDX] = EOE_VALID | EOE_RSA;\r\nome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;\r\nome->moe[IOE_EWRITE0_IDX] = EOE_VALID | EOE_WWSAO;\r\nome->moe[IOE_DIRECT0_IDX] = EOE_VALID | EOE_LDEC;\r\nome->moe[IOE_DIRECT1_IDX] = EOE_VALID | EOE_LDECPE;\r\nome = &omt[OMI_FMAN];\r\nome->moe[IOE_READ_IDX] = EOE_VALID | EOE_READI;\r\nome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;\r\nome = &omt[OMI_QMAN_PRIV];\r\nome->moe[IOE_READ_IDX] = EOE_VALID | EOE_READ;\r\nome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;\r\nome->moe[IOE_EREAD0_IDX] = EOE_VALID | EOE_RSA;\r\nome->moe[IOE_EWRITE0_IDX] = EOE_VALID | EOE_WWSA;\r\nome = &omt[OMI_CAAM];\r\nome->moe[IOE_READ_IDX] = EOE_VALID | EOE_READI;\r\nome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;\r\n}\r\nstatic void get_pamu_cap_values(unsigned long pamu_reg_base)\r\n{\r\nu32 pc_val;\r\npc_val = in_be32((u32 *)(pamu_reg_base + PAMU_PC3));\r\nmax_subwindow_count = 1 << (1 + PAMU_PC3_MWCE(pc_val));\r\n}\r\nint setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,\r\nphys_addr_t ppaact_phys, phys_addr_t spaact_phys,\r\nphys_addr_t omt_phys)\r\n{\r\nu32 *pc;\r\nstruct pamu_mmap_regs *pamu_regs;\r\npc = (u32 *) (pamu_reg_base + PAMU_PC);\r\npamu_regs = (struct pamu_mmap_regs *)\r\n(pamu_reg_base + PAMU_MMAP_REGS_BASE);\r\nout_be32(&pamu_regs->ppbah, upper_32_bits(ppaact_phys));\r\nout_be32(&pamu_regs->ppbal, lower_32_bits(ppaact_phys));\r\nppaact_phys = ppaact_phys + PAACT_SIZE;\r\nout_be32(&pamu_regs->pplah, upper_32_bits(ppaact_phys));\r\nout_be32(&pamu_regs->pplal, lower_32_bits(ppaact_phys));\r\nout_be32(&pamu_regs->spbah, upper_32_bits(spaact_phys));\r\nout_be32(&pamu_regs->spbal, lower_32_bits(spaact_phys));\r\nspaact_phys = spaact_phys + SPAACT_SIZE;\r\nout_be32(&pamu_regs->splah, upper_32_bits(spaact_phys));\r\nout_be32(&pamu_regs->splal, lower_32_bits(spaact_phys));\r\nout_be32(&pamu_regs->obah, upper_32_bits(omt_phys));\r\nout_be32(&pamu_regs->obal, lower_32_bits(omt_phys));\r\nomt_phys = omt_phys + OMT_SIZE;\r\nout_be32(&pamu_regs->olah, upper_32_bits(omt_phys));\r\nout_be32(&pamu_regs->olal, lower_32_bits(omt_phys));\r\nout_be32((u32 *)(pamu_reg_base + PAMU_PICS),\r\nPAMU_ACCESS_VIOLATION_ENABLE);\r\nout_be32(pc, PAMU_PC_PE | PAMU_PC_OCE | PAMU_PC_SPCC | PAMU_PC_PPCC);\r\nreturn 0;\r\n}\r\nstatic void __init setup_liodns(void)\r\n{\r\nint i, len;\r\nstruct paace *ppaace;\r\nstruct device_node *node = NULL;\r\nconst u32 *prop;\r\nfor_each_node_with_property(node, "fsl,liodn") {\r\nprop = of_get_property(node, "fsl,liodn", &len);\r\nfor (i = 0; i < len / sizeof(u32); i++) {\r\nint liodn;\r\nliodn = be32_to_cpup(&prop[i]);\r\nif (liodn >= PAACE_NUMBER_ENTRIES) {\r\npr_debug("Invalid LIODN value %d\n", liodn);\r\ncontinue;\r\n}\r\nppaace = pamu_get_ppaace(liodn);\r\npamu_init_ppaace(ppaace);\r\nset_bf(ppaace->addr_bitfields, PPAACE_AF_WSE, 35);\r\nppaace->wbah = 0;\r\nset_bf(ppaace->addr_bitfields, PPAACE_AF_WBAL, 0);\r\nset_bf(ppaace->impl_attr, PAACE_IA_ATM,\r\nPAACE_ATM_NO_XLATE);\r\nset_bf(ppaace->addr_bitfields, PAACE_AF_AP,\r\nPAACE_AP_PERMS_ALL);\r\nif (of_device_is_compatible(node, "fsl,qman-portal"))\r\nsetup_qbman_paace(ppaace, QMAN_PORTAL_PAACE);\r\nif (of_device_is_compatible(node, "fsl,qman"))\r\nsetup_qbman_paace(ppaace, QMAN_PAACE);\r\nif (of_device_is_compatible(node, "fsl,bman"))\r\nsetup_qbman_paace(ppaace, BMAN_PAACE);\r\nmb();\r\npamu_enable_liodn(liodn);\r\n}\r\n}\r\n}\r\nirqreturn_t pamu_av_isr(int irq, void *arg)\r\n{\r\nstruct pamu_isr_data *data = arg;\r\nphys_addr_t phys;\r\nunsigned int i, j, ret;\r\npr_emerg("access violation interrupt\n");\r\nfor (i = 0; i < data->count; i++) {\r\nvoid __iomem *p = data->pamu_reg_base + i * PAMU_OFFSET;\r\nu32 pics = in_be32(p + PAMU_PICS);\r\nif (pics & PAMU_ACCESS_VIOLATION_STAT) {\r\nu32 avs1 = in_be32(p + PAMU_AVS1);\r\nstruct paace *paace;\r\npr_emerg("POES1=%08x\n", in_be32(p + PAMU_POES1));\r\npr_emerg("POES2=%08x\n", in_be32(p + PAMU_POES2));\r\npr_emerg("AVS1=%08x\n", avs1);\r\npr_emerg("AVS2=%08x\n", in_be32(p + PAMU_AVS2));\r\npr_emerg("AVA=%016llx\n", make64(in_be32(p + PAMU_AVAH),\r\nin_be32(p + PAMU_AVAL)));\r\npr_emerg("UDAD=%08x\n", in_be32(p + PAMU_UDAD));\r\npr_emerg("POEA=%016llx\n", make64(in_be32(p + PAMU_POEAH),\r\nin_be32(p + PAMU_POEAL)));\r\nphys = make64(in_be32(p + PAMU_POEAH),\r\nin_be32(p + PAMU_POEAL));\r\nif (phys) {\r\nu32 *paace = phys_to_virt(phys);\r\nfor (j = 0; j < 4; j++)\r\npr_emerg("PAACE[%u]=%08x\n", j, in_be32(paace + j));\r\n}\r\nout_be32((p + PAMU_AVS1), avs1 & PAMU_AV_MASK);\r\npaace = pamu_get_ppaace(avs1 >> PAMU_AVS1_LIODN_SHIFT);\r\nBUG_ON(!paace);\r\nif (!get_bf(paace->addr_bitfields, PAACE_AF_V)) {\r\npics &= ~PAMU_ACCESS_VIOLATION_ENABLE;\r\n} else {\r\nret = pamu_disable_liodn(avs1 >> PAMU_AVS1_LIODN_SHIFT);\r\nBUG_ON(ret);\r\npr_emerg("Disabling liodn %x\n", avs1 >> PAMU_AVS1_LIODN_SHIFT);\r\n}\r\nout_be32((p + PAMU_PICS), pics);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init create_csd(phys_addr_t phys, size_t size, u32 csd_port_id)\r\n{\r\nstruct device_node *np;\r\nconst __be32 *iprop;\r\nvoid __iomem *lac = NULL;\r\nstruct ccsr_law __iomem *law;\r\nvoid __iomem *ccm = NULL;\r\nu32 __iomem *csdids;\r\nunsigned int i, num_laws, num_csds;\r\nu32 law_target = 0;\r\nu32 csd_id = 0;\r\nint ret = 0;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,corenet-law");\r\nif (!np)\r\nreturn -ENODEV;\r\niprop = of_get_property(np, "fsl,num-laws", NULL);\r\nif (!iprop) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nnum_laws = be32_to_cpup(iprop);\r\nif (!num_laws) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nlac = of_iomap(np, 0);\r\nif (!lac) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nlaw = lac + 0xC00;\r\nof_node_put(np);\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,corenet-cf");\r\nif (!np) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\niprop = of_get_property(np, "fsl,ccf-num-csdids", NULL);\r\nif (!iprop) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nnum_csds = be32_to_cpup(iprop);\r\nif (!num_csds) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nccm = of_iomap(np, 0);\r\nif (!ccm) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\ncsdids = ccm + 0x600;\r\nof_node_put(np);\r\nnp = NULL;\r\nfor (csd_id = 0; csd_id < num_csds; csd_id++) {\r\nif (!csdids[csd_id])\r\nbreak;\r\n}\r\ncsdids[csd_id] = csd_port_id;\r\nfor (i = 0; i < num_laws; i++) {\r\nif (law[i].lawar & LAWAR_EN) {\r\nphys_addr_t law_start, law_end;\r\nlaw_start = make64(law[i].lawbarh, law[i].lawbarl);\r\nlaw_end = law_start +\r\n(2ULL << (law[i].lawar & LAWAR_SIZE_MASK));\r\nif (law_start <= phys && phys < law_end) {\r\nlaw_target = law[i].lawar & LAWAR_TARGET_MASK;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i == 0 || i == num_laws) {\r\nret = -ENOENT;\r\ngoto error;\r\n}\r\nwhile (law[--i].lawar & LAWAR_EN) {\r\nif (i == 0) {\r\nret = -ENOENT;\r\ngoto error;\r\n}\r\n}\r\nlaw[i].lawbarh = upper_32_bits(phys);\r\nlaw[i].lawbarl = lower_32_bits(phys);\r\nwmb();\r\nlaw[i].lawar = LAWAR_EN | law_target | (csd_id << LAWAR_CSDID_SHIFT) |\r\n(LAW_SIZE_4K + get_order(size));\r\nwmb();\r\nerror:\r\nif (ccm)\r\niounmap(ccm);\r\nif (lac)\r\niounmap(lac);\r\nif (np)\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic int __init fsl_pamu_probe(struct platform_device *pdev)\r\n{\r\nvoid __iomem *pamu_regs = NULL;\r\nstruct ccsr_guts __iomem *guts_regs = NULL;\r\nu32 pamubypenr, pamu_counter;\r\nunsigned long pamu_reg_off;\r\nunsigned long pamu_reg_base;\r\nstruct pamu_isr_data *data = NULL;\r\nstruct device_node *guts_node;\r\nu64 size;\r\nstruct page *p;\r\nint ret = 0;\r\nint irq;\r\nphys_addr_t ppaact_phys;\r\nphys_addr_t spaact_phys;\r\nphys_addr_t omt_phys;\r\nsize_t mem_size = 0;\r\nunsigned int order = 0;\r\nu32 csd_port_id = 0;\r\nunsigned i;\r\npamu_regs = of_iomap(pdev->dev.of_node, 0);\r\nif (!pamu_regs) {\r\ndev_err(&pdev->dev, "ioremap of PAMU node failed\n");\r\nreturn -ENOMEM;\r\n}\r\nof_get_address(pdev->dev.of_node, 0, &size, NULL);\r\nirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (irq == NO_IRQ) {\r\ndev_warn(&pdev->dev, "no interrupts listed in PAMU node\n");\r\ngoto error;\r\n}\r\ndata = kzalloc(sizeof(struct pamu_isr_data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&pdev->dev, "PAMU isr data memory allocation failed\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\ndata->pamu_reg_base = pamu_regs;\r\ndata->count = size / PAMU_OFFSET;\r\nret = request_irq(irq, pamu_av_isr, 0, "pamu", data);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "error %i installing ISR for irq %i\n",\r\nret, irq);\r\ngoto error;\r\n}\r\nguts_node = of_find_matching_node(NULL, guts_device_ids);\r\nif (!guts_node) {\r\ndev_err(&pdev->dev, "could not find GUTS node %s\n",\r\npdev->dev.of_node->full_name);\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nguts_regs = of_iomap(guts_node, 0);\r\nof_node_put(guts_node);\r\nif (!guts_regs) {\r\ndev_err(&pdev->dev, "ioremap of GUTS node failed\n");\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nget_pamu_cap_values((unsigned long)pamu_regs);\r\nmem_size = (PAGE_SIZE << get_order(PAACT_SIZE)) +\r\n(PAGE_SIZE << get_order(SPAACT_SIZE)) +\r\n(PAGE_SIZE << get_order(OMT_SIZE));\r\norder = get_order(mem_size);\r\np = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);\r\nif (!p) {\r\ndev_err(&pdev->dev, "unable to allocate PAACT/SPAACT/OMT block\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nppaact = page_address(p);\r\nppaact_phys = page_to_phys(p);\r\nif (ppaact_phys & ((PAGE_SIZE << order) - 1)) {\r\ndev_err(&pdev->dev, "PAACT/OMT block is unaligned\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nspaact = (void *)ppaact + (PAGE_SIZE << get_order(PAACT_SIZE));\r\nomt = (void *)spaact + (PAGE_SIZE << get_order(SPAACT_SIZE));\r\ndev_dbg(&pdev->dev, "ppaact virt=%p phys=0x%llx\n", ppaact,\r\n(unsigned long long) ppaact_phys);\r\nfor (i = 0; i < ARRAY_SIZE(port_id_map); i++) {\r\nif (port_id_map[i].svr == (mfspr(SPRN_SVR) & ~SVR_SECURITY)) {\r\ncsd_port_id = port_id_map[i].port_id;\r\ndev_dbg(&pdev->dev, "found matching SVR %08x\n",\r\nport_id_map[i].svr);\r\nbreak;\r\n}\r\n}\r\nif (csd_port_id) {\r\ndev_dbg(&pdev->dev, "creating coherency subdomain at address "\r\n"0x%llx, size %zu, port id 0x%08x", ppaact_phys,\r\nmem_size, csd_port_id);\r\nret = create_csd(ppaact_phys, mem_size, csd_port_id);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not create coherence "\r\n"subdomain\n");\r\nreturn ret;\r\n}\r\n}\r\nspaact_phys = virt_to_phys(spaact);\r\nomt_phys = virt_to_phys(omt);\r\nspaace_pool = gen_pool_create(ilog2(sizeof(struct paace)), -1);\r\nif (!spaace_pool) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "PAMU : failed to allocate spaace gen pool\n");\r\ngoto error;\r\n}\r\nret = gen_pool_add(spaace_pool, (unsigned long)spaact, SPAACT_SIZE, -1);\r\nif (ret)\r\ngoto error_genpool;\r\npamubypenr = in_be32(&guts_regs->pamubypenr);\r\nfor (pamu_reg_off = 0, pamu_counter = 0x80000000; pamu_reg_off < size;\r\npamu_reg_off += PAMU_OFFSET, pamu_counter >>= 1) {\r\npamu_reg_base = (unsigned long) pamu_regs + pamu_reg_off;\r\nsetup_one_pamu(pamu_reg_base, pamu_reg_off, ppaact_phys,\r\nspaact_phys, omt_phys);\r\npamubypenr &= ~pamu_counter;\r\n}\r\nsetup_omt(omt);\r\nout_be32(&guts_regs->pamubypenr, pamubypenr);\r\niounmap(guts_regs);\r\nsetup_liodns();\r\nreturn 0;\r\nerror_genpool:\r\ngen_pool_destroy(spaace_pool);\r\nerror:\r\nif (irq != NO_IRQ)\r\nfree_irq(irq, data);\r\nif (data) {\r\nmemset(data, 0, sizeof(struct pamu_isr_data));\r\nkfree(data);\r\n}\r\nif (pamu_regs)\r\niounmap(pamu_regs);\r\nif (guts_regs)\r\niounmap(guts_regs);\r\nif (ppaact)\r\nfree_pages((unsigned long)ppaact, order);\r\nppaact = NULL;\r\nreturn ret;\r\n}\r\nstatic __init int fsl_pamu_init(void)\r\n{\r\nstruct platform_device *pdev = NULL;\r\nstruct device_node *np;\r\nint ret;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,pamu");\r\nif (!np) {\r\npr_err("could not find a PAMU node\n");\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&fsl_of_pamu_driver);\r\nif (ret) {\r\npr_err("could not register driver (err=%i)\n", ret);\r\ngoto error_driver_register;\r\n}\r\npdev = platform_device_alloc("fsl-of-pamu", 0);\r\nif (!pdev) {\r\npr_err("could not allocate device %s\n",\r\nnp->full_name);\r\nret = -ENOMEM;\r\ngoto error_device_alloc;\r\n}\r\npdev->dev.of_node = of_node_get(np);\r\nret = pamu_domain_init();\r\nif (ret)\r\ngoto error_device_add;\r\nret = platform_device_add(pdev);\r\nif (ret) {\r\npr_err("could not add device %s (err=%i)\n",\r\nnp->full_name, ret);\r\ngoto error_device_add;\r\n}\r\nreturn 0;\r\nerror_device_add:\r\nof_node_put(pdev->dev.of_node);\r\npdev->dev.of_node = NULL;\r\nplatform_device_put(pdev);\r\nerror_device_alloc:\r\nplatform_driver_unregister(&fsl_of_pamu_driver);\r\nerror_driver_register:\r\nof_node_put(np);\r\nreturn ret;\r\n}
