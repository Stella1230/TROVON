static unsigned int rate_to_index(unsigned int rate)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(dice_rates); ++i)\r\nif (dice_rates[i] == rate)\r\nreturn i;\r\nreturn 0;\r\n}\r\nstatic unsigned int rate_index_to_mode(unsigned int rate_index)\r\n{\r\nreturn ((int)rate_index - 1) / 2;\r\n}\r\nstatic void dice_lock_changed(struct dice *dice)\r\n{\r\ndice->dev_lock_changed = true;\r\nwake_up(&dice->hwdep_wait);\r\n}\r\nstatic int dice_try_lock(struct dice *dice)\r\n{\r\nint err;\r\nspin_lock_irq(&dice->lock);\r\nif (dice->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (dice->dev_lock_count++ == 0)\r\ndice_lock_changed(dice);\r\nerr = 0;\r\nout:\r\nspin_unlock_irq(&dice->lock);\r\nreturn err;\r\n}\r\nstatic void dice_unlock(struct dice *dice)\r\n{\r\nspin_lock_irq(&dice->lock);\r\nif (WARN_ON(dice->dev_lock_count <= 0))\r\ngoto out;\r\nif (--dice->dev_lock_count == 0)\r\ndice_lock_changed(dice);\r\nout:\r\nspin_unlock_irq(&dice->lock);\r\n}\r\nstatic inline u64 global_address(struct dice *dice, unsigned int offset)\r\n{\r\nreturn DICE_PRIVATE_SPACE + dice->global_offset + offset;\r\n}\r\nstatic inline u64 rx_address(struct dice *dice, unsigned int offset)\r\n{\r\nreturn DICE_PRIVATE_SPACE + dice->rx_offset + offset;\r\n}\r\nstatic int dice_owner_set(struct dice *dice)\r\n{\r\nstruct fw_device *device = fw_parent_device(dice->unit);\r\n__be64 *buffer;\r\nint err, errors = 0;\r\nbuffer = kmalloc(2 * 8, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nfor (;;) {\r\nbuffer[0] = cpu_to_be64(OWNER_NO_OWNER);\r\nbuffer[1] = cpu_to_be64(\r\n((u64)device->card->node_id << OWNER_NODE_SHIFT) |\r\ndice->notification_handler.offset);\r\ndice->owner_generation = device->generation;\r\nsmp_rmb();\r\nerr = snd_fw_transaction(dice->unit,\r\nTCODE_LOCK_COMPARE_SWAP,\r\nglobal_address(dice, GLOBAL_OWNER),\r\nbuffer, 2 * 8,\r\nFW_FIXED_GENERATION |\r\ndice->owner_generation);\r\nif (err == 0) {\r\nif (buffer[0] != cpu_to_be64(OWNER_NO_OWNER)) {\r\ndev_err(&dice->unit->device,\r\n"device is already in use\n");\r\nerr = -EBUSY;\r\n}\r\nbreak;\r\n}\r\nif (err != -EAGAIN || ++errors >= 3)\r\nbreak;\r\nmsleep(20);\r\n}\r\nkfree(buffer);\r\nreturn err;\r\n}\r\nstatic int dice_owner_update(struct dice *dice)\r\n{\r\nstruct fw_device *device = fw_parent_device(dice->unit);\r\n__be64 *buffer;\r\nint err;\r\nif (dice->owner_generation == -1)\r\nreturn 0;\r\nbuffer = kmalloc(2 * 8, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer[0] = cpu_to_be64(OWNER_NO_OWNER);\r\nbuffer[1] = cpu_to_be64(\r\n((u64)device->card->node_id << OWNER_NODE_SHIFT) |\r\ndice->notification_handler.offset);\r\ndice->owner_generation = device->generation;\r\nsmp_rmb();\r\nerr = snd_fw_transaction(dice->unit, TCODE_LOCK_COMPARE_SWAP,\r\nglobal_address(dice, GLOBAL_OWNER),\r\nbuffer, 2 * 8,\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\nif (err == 0) {\r\nif (buffer[0] != cpu_to_be64(OWNER_NO_OWNER)) {\r\ndev_err(&dice->unit->device,\r\n"device is already in use\n");\r\nerr = -EBUSY;\r\n}\r\n} else if (err == -EAGAIN) {\r\nerr = 0;\r\n}\r\nkfree(buffer);\r\nif (err < 0)\r\ndice->owner_generation = -1;\r\nreturn err;\r\n}\r\nstatic void dice_owner_clear(struct dice *dice)\r\n{\r\nstruct fw_device *device = fw_parent_device(dice->unit);\r\n__be64 *buffer;\r\nbuffer = kmalloc(2 * 8, GFP_KERNEL);\r\nif (!buffer)\r\nreturn;\r\nbuffer[0] = cpu_to_be64(\r\n((u64)device->card->node_id << OWNER_NODE_SHIFT) |\r\ndice->notification_handler.offset);\r\nbuffer[1] = cpu_to_be64(OWNER_NO_OWNER);\r\nsnd_fw_transaction(dice->unit, TCODE_LOCK_COMPARE_SWAP,\r\nglobal_address(dice, GLOBAL_OWNER),\r\nbuffer, 2 * 8, FW_QUIET |\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\nkfree(buffer);\r\ndice->owner_generation = -1;\r\n}\r\nstatic int dice_enable_set(struct dice *dice)\r\n{\r\n__be32 value;\r\nint err;\r\nvalue = cpu_to_be32(1);\r\nerr = snd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nglobal_address(dice, GLOBAL_ENABLE),\r\n&value, 4,\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\nif (err < 0)\r\nreturn err;\r\ndice->global_enabled = true;\r\nreturn 0;\r\n}\r\nstatic void dice_enable_clear(struct dice *dice)\r\n{\r\n__be32 value;\r\nif (!dice->global_enabled)\r\nreturn;\r\nvalue = 0;\r\nsnd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nglobal_address(dice, GLOBAL_ENABLE),\r\n&value, 4, FW_QUIET |\r\nFW_FIXED_GENERATION | dice->owner_generation);\r\ndice->global_enabled = false;\r\n}\r\nstatic void dice_notification(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct dice *dice = callback_data;\r\nu32 bits;\r\nunsigned long flags;\r\nif (tcode != TCODE_WRITE_QUADLET_REQUEST) {\r\nfw_send_response(card, request, RCODE_TYPE_ERROR);\r\nreturn;\r\n}\r\nif ((offset & 3) != 0) {\r\nfw_send_response(card, request, RCODE_ADDRESS_ERROR);\r\nreturn;\r\n}\r\nbits = be32_to_cpup(data);\r\nspin_lock_irqsave(&dice->lock, flags);\r\ndice->notification_bits |= bits;\r\nspin_unlock_irqrestore(&dice->lock, flags);\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\nif (bits & NOTIFY_CLOCK_ACCEPTED)\r\ncomplete(&dice->clock_accepted);\r\nwake_up(&dice->hwdep_wait);\r\n}\r\nstatic int dice_rate_constraint(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct dice *dice = rule->private;\r\nconst struct snd_interval *channels =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *rate =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval allowed_rates = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nunsigned int i, mode;\r\nfor (i = 0; i < ARRAY_SIZE(dice_rates); ++i) {\r\nmode = rate_index_to_mode(i);\r\nif ((dice->clock_caps & (1 << i)) &&\r\nsnd_interval_test(channels, dice->rx_channels[mode])) {\r\nallowed_rates.min = min(allowed_rates.min,\r\ndice_rates[i]);\r\nallowed_rates.max = max(allowed_rates.max,\r\ndice_rates[i]);\r\n}\r\n}\r\nreturn snd_interval_refine(rate, &allowed_rates);\r\n}\r\nstatic int dice_channels_constraint(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct dice *dice = rule->private;\r\nconst struct snd_interval *rate =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval allowed_channels = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nunsigned int i, mode;\r\nfor (i = 0; i < ARRAY_SIZE(dice_rates); ++i)\r\nif ((dice->clock_caps & (1 << i)) &&\r\nsnd_interval_test(rate, dice_rates[i])) {\r\nmode = rate_index_to_mode(i);\r\nallowed_channels.min = min(allowed_channels.min,\r\ndice->rx_channels[mode]);\r\nallowed_channels.max = max(allowed_channels.max,\r\ndice->rx_channels[mode]);\r\n}\r\nreturn snd_interval_refine(channels, &allowed_channels);\r\n}\r\nstatic int dice_open(struct snd_pcm_substream *substream)\r\n{\r\nstatic const struct snd_pcm_hardware hardware = {\r\n.info = SNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID |\r\nSNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER,\r\n.formats = AMDTP_OUT_PCM_FORMAT_BITS,\r\n.channels_min = UINT_MAX,\r\n.channels_max = 0,\r\n.buffer_bytes_max = 16 * 1024 * 1024,\r\n.period_bytes_min = 1,\r\n.period_bytes_max = UINT_MAX,\r\n.periods_min = 1,\r\n.periods_max = UINT_MAX,\r\n};\r\nstruct dice *dice = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int i;\r\nint err;\r\nerr = dice_try_lock(dice);\r\nif (err < 0)\r\ngoto error;\r\nruntime->hw = hardware;\r\nfor (i = 0; i < ARRAY_SIZE(dice_rates); ++i)\r\nif (dice->clock_caps & (1 << i))\r\nruntime->hw.rates |=\r\nsnd_pcm_rate_to_rate_bit(dice_rates[i]);\r\nsnd_pcm_limit_hw_rates(runtime);\r\nfor (i = 0; i < 3; ++i)\r\nif (dice->rx_channels[i]) {\r\nruntime->hw.channels_min = min(runtime->hw.channels_min,\r\ndice->rx_channels[i]);\r\nruntime->hw.channels_max = max(runtime->hw.channels_max,\r\ndice->rx_channels[i]);\r\n}\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\ndice_rate_constraint, dice,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\ngoto err_lock;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\ndice_channels_constraint, dice,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\ngoto err_lock;\r\nerr = amdtp_stream_add_pcm_hw_constraints(&dice->stream, runtime);\r\nif (err < 0)\r\ngoto err_lock;\r\nreturn 0;\r\nerr_lock:\r\ndice_unlock(dice);\r\nerror:\r\nreturn err;\r\n}\r\nstatic int dice_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct dice *dice = substream->private_data;\r\ndice_unlock(dice);\r\nreturn 0;\r\n}\r\nstatic int dice_stream_start_packets(struct dice *dice)\r\n{\r\nint err;\r\nif (amdtp_stream_running(&dice->stream))\r\nreturn 0;\r\nerr = amdtp_stream_start(&dice->stream, dice->resources.channel,\r\nfw_parent_device(dice->unit)->max_speed);\r\nif (err < 0)\r\nreturn err;\r\nerr = dice_enable_set(dice);\r\nif (err < 0) {\r\namdtp_stream_stop(&dice->stream);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dice_stream_start(struct dice *dice)\r\n{\r\n__be32 channel;\r\nint err;\r\nif (!dice->resources.allocated) {\r\nerr = fw_iso_resources_allocate(&dice->resources,\r\namdtp_stream_get_max_payload(&dice->stream),\r\nfw_parent_device(dice->unit)->max_speed);\r\nif (err < 0)\r\ngoto error;\r\nchannel = cpu_to_be32(dice->resources.channel);\r\nerr = snd_fw_transaction(dice->unit,\r\nTCODE_WRITE_QUADLET_REQUEST,\r\nrx_address(dice, RX_ISOCHRONOUS),\r\n&channel, 4, 0);\r\nif (err < 0)\r\ngoto err_resources;\r\n}\r\nerr = dice_stream_start_packets(dice);\r\nif (err < 0)\r\ngoto err_rx_channel;\r\nreturn 0;\r\nerr_rx_channel:\r\nchannel = cpu_to_be32((u32)-1);\r\nsnd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nrx_address(dice, RX_ISOCHRONOUS), &channel, 4, 0);\r\nerr_resources:\r\nfw_iso_resources_free(&dice->resources);\r\nerror:\r\nreturn err;\r\n}\r\nstatic void dice_stream_stop_packets(struct dice *dice)\r\n{\r\nif (amdtp_stream_running(&dice->stream)) {\r\ndice_enable_clear(dice);\r\namdtp_stream_stop(&dice->stream);\r\n}\r\n}\r\nstatic void dice_stream_stop(struct dice *dice)\r\n{\r\n__be32 channel;\r\ndice_stream_stop_packets(dice);\r\nif (!dice->resources.allocated)\r\nreturn;\r\nchannel = cpu_to_be32((u32)-1);\r\nsnd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nrx_address(dice, RX_ISOCHRONOUS), &channel, 4, 0);\r\nfw_iso_resources_free(&dice->resources);\r\n}\r\nstatic int dice_change_rate(struct dice *dice, unsigned int clock_rate)\r\n{\r\n__be32 value;\r\nint err;\r\nreinit_completion(&dice->clock_accepted);\r\nvalue = cpu_to_be32(clock_rate | CLOCK_SOURCE_ARX1);\r\nerr = snd_fw_transaction(dice->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nglobal_address(dice, GLOBAL_CLOCK_SELECT),\r\n&value, 4, 0);\r\nif (err < 0)\r\nreturn err;\r\nif (!wait_for_completion_timeout(&dice->clock_accepted,\r\nmsecs_to_jiffies(100)))\r\ndev_warn(&dice->unit->device, "clock change timed out\n");\r\nreturn 0;\r\n}\r\nstatic int dice_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct dice *dice = substream->private_data;\r\nunsigned int rate_index, mode, rate, channels, i;\r\nint err;\r\nmutex_lock(&dice->mutex);\r\ndice_stream_stop(dice);\r\nmutex_unlock(&dice->mutex);\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nrate = params_rate(hw_params);\r\nrate_index = rate_to_index(rate);\r\nerr = dice_change_rate(dice, rate_index << CLOCK_RATE_SHIFT);\r\nif (err < 0)\r\nreturn err;\r\nchannels = params_channels(hw_params);\r\nif (rate_index > 4) {\r\nif (channels > AMDTP_MAX_CHANNELS_FOR_PCM / 2) {\r\nerr = -ENOSYS;\r\nreturn err;\r\n}\r\nrate /= 2;\r\nchannels *= 2;\r\ndice->stream.double_pcm_frames = true;\r\n} else {\r\ndice->stream.double_pcm_frames = false;\r\n}\r\nmode = rate_index_to_mode(rate_index);\r\namdtp_stream_set_parameters(&dice->stream, rate, channels,\r\ndice->rx_midi_ports[mode]);\r\nif (rate_index > 4) {\r\nchannels /= 2;\r\nfor (i = 0; i < channels; i++) {\r\ndice->stream.pcm_positions[i] = i * 2;\r\ndice->stream.pcm_positions[i + channels] = i * 2 + 1;\r\n}\r\n}\r\namdtp_stream_set_pcm_format(&dice->stream,\r\nparams_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int dice_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct dice *dice = substream->private_data;\r\nmutex_lock(&dice->mutex);\r\ndice_stream_stop(dice);\r\nmutex_unlock(&dice->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int dice_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct dice *dice = substream->private_data;\r\nint err;\r\nmutex_lock(&dice->mutex);\r\nif (amdtp_streaming_error(&dice->stream))\r\ndice_stream_stop_packets(dice);\r\nerr = dice_stream_start(dice);\r\nif (err < 0) {\r\nmutex_unlock(&dice->mutex);\r\nreturn err;\r\n}\r\nmutex_unlock(&dice->mutex);\r\namdtp_stream_pcm_prepare(&dice->stream);\r\nreturn 0;\r\n}\r\nstatic int dice_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct dice *dice = substream->private_data;\r\nstruct snd_pcm_substream *pcm;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\npcm = substream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\npcm = NULL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\namdtp_stream_pcm_trigger(&dice->stream, pcm);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t dice_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct dice *dice = substream->private_data;\r\nreturn amdtp_stream_pcm_pointer(&dice->stream);\r\n}\r\nstatic int dice_create_pcm(struct dice *dice)\r\n{\r\nstatic struct snd_pcm_ops ops = {\r\n.open = dice_open,\r\n.close = dice_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = dice_hw_params,\r\n.hw_free = dice_hw_free,\r\n.prepare = dice_prepare,\r\n.trigger = dice_trigger,\r\n.pointer = dice_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(dice->card, "DICE", 0, 1, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = dice;\r\nstrcpy(pcm->name, dice->card->shortname);\r\npcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->ops = &ops;\r\nreturn 0;\r\n}\r\nstatic long dice_hwdep_read(struct snd_hwdep *hwdep, char __user *buf,\r\nlong count, loff_t *offset)\r\n{\r\nstruct dice *dice = hwdep->private_data;\r\nDEFINE_WAIT(wait);\r\nunion snd_firewire_event event;\r\nspin_lock_irq(&dice->lock);\r\nwhile (!dice->dev_lock_changed && dice->notification_bits == 0) {\r\nprepare_to_wait(&dice->hwdep_wait, &wait, TASK_INTERRUPTIBLE);\r\nspin_unlock_irq(&dice->lock);\r\nschedule();\r\nfinish_wait(&dice->hwdep_wait, &wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irq(&dice->lock);\r\n}\r\nmemset(&event, 0, sizeof(event));\r\nif (dice->dev_lock_changed) {\r\nevent.lock_status.type = SNDRV_FIREWIRE_EVENT_LOCK_STATUS;\r\nevent.lock_status.status = dice->dev_lock_count > 0;\r\ndice->dev_lock_changed = false;\r\ncount = min(count, (long)sizeof(event.lock_status));\r\n} else {\r\nevent.dice_notification.type = SNDRV_FIREWIRE_EVENT_DICE_NOTIFICATION;\r\nevent.dice_notification.notification = dice->notification_bits;\r\ndice->notification_bits = 0;\r\ncount = min(count, (long)sizeof(event.dice_notification));\r\n}\r\nspin_unlock_irq(&dice->lock);\r\nif (copy_to_user(buf, &event, count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic unsigned int dice_hwdep_poll(struct snd_hwdep *hwdep, struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct dice *dice = hwdep->private_data;\r\nunsigned int events;\r\npoll_wait(file, &dice->hwdep_wait, wait);\r\nspin_lock_irq(&dice->lock);\r\nif (dice->dev_lock_changed || dice->notification_bits != 0)\r\nevents = POLLIN | POLLRDNORM;\r\nelse\r\nevents = 0;\r\nspin_unlock_irq(&dice->lock);\r\nreturn events;\r\n}\r\nstatic int dice_hwdep_get_info(struct dice *dice, void __user *arg)\r\n{\r\nstruct fw_device *dev = fw_parent_device(dice->unit);\r\nstruct snd_firewire_get_info info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.type = SNDRV_FIREWIRE_TYPE_DICE;\r\ninfo.card = dev->card->index;\r\n*(__be32 *)&info.guid[0] = cpu_to_be32(dev->config_rom[3]);\r\n*(__be32 *)&info.guid[4] = cpu_to_be32(dev->config_rom[4]);\r\nstrlcpy(info.device_name, dev_name(&dev->device),\r\nsizeof(info.device_name));\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int dice_hwdep_lock(struct dice *dice)\r\n{\r\nint err;\r\nspin_lock_irq(&dice->lock);\r\nif (dice->dev_lock_count == 0) {\r\ndice->dev_lock_count = -1;\r\nerr = 0;\r\n} else {\r\nerr = -EBUSY;\r\n}\r\nspin_unlock_irq(&dice->lock);\r\nreturn err;\r\n}\r\nstatic int dice_hwdep_unlock(struct dice *dice)\r\n{\r\nint err;\r\nspin_lock_irq(&dice->lock);\r\nif (dice->dev_lock_count == -1) {\r\ndice->dev_lock_count = 0;\r\nerr = 0;\r\n} else {\r\nerr = -EBADFD;\r\n}\r\nspin_unlock_irq(&dice->lock);\r\nreturn err;\r\n}\r\nstatic int dice_hwdep_release(struct snd_hwdep *hwdep, struct file *file)\r\n{\r\nstruct dice *dice = hwdep->private_data;\r\nspin_lock_irq(&dice->lock);\r\nif (dice->dev_lock_count == -1)\r\ndice->dev_lock_count = 0;\r\nspin_unlock_irq(&dice->lock);\r\nreturn 0;\r\n}\r\nstatic int dice_hwdep_ioctl(struct snd_hwdep *hwdep, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct dice *dice = hwdep->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_FIREWIRE_IOCTL_GET_INFO:\r\nreturn dice_hwdep_get_info(dice, (void __user *)arg);\r\ncase SNDRV_FIREWIRE_IOCTL_LOCK:\r\nreturn dice_hwdep_lock(dice);\r\ncase SNDRV_FIREWIRE_IOCTL_UNLOCK:\r\nreturn dice_hwdep_unlock(dice);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int dice_hwdep_compat_ioctl(struct snd_hwdep *hwdep, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn dice_hwdep_ioctl(hwdep, file, cmd,\r\n(unsigned long)compat_ptr(arg));\r\n}\r\nstatic int dice_create_hwdep(struct dice *dice)\r\n{\r\nstatic const struct snd_hwdep_ops ops = {\r\n.read = dice_hwdep_read,\r\n.release = dice_hwdep_release,\r\n.poll = dice_hwdep_poll,\r\n.ioctl = dice_hwdep_ioctl,\r\n.ioctl_compat = dice_hwdep_compat_ioctl,\r\n};\r\nstruct snd_hwdep *hwdep;\r\nint err;\r\nerr = snd_hwdep_new(dice->card, "DICE", 0, &hwdep);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(hwdep->name, "DICE");\r\nhwdep->iface = SNDRV_HWDEP_IFACE_FW_DICE;\r\nhwdep->ops = ops;\r\nhwdep->private_data = dice;\r\nhwdep->exclusive = true;\r\nreturn 0;\r\n}\r\nstatic int dice_proc_read_mem(struct dice *dice, void *buffer,\r\nunsigned int offset_q, unsigned int quadlets)\r\n{\r\nunsigned int i;\r\nint err;\r\nerr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\r\nDICE_PRIVATE_SPACE + 4 * offset_q,\r\nbuffer, 4 * quadlets, 0);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < quadlets; ++i)\r\nbe32_to_cpus(&((u32 *)buffer)[i]);\r\nreturn 0;\r\n}\r\nstatic const char *str_from_array(const char *const strs[], unsigned int count,\r\nunsigned int i)\r\n{\r\nif (i < count)\r\nreturn strs[i];\r\nelse\r\nreturn "(unknown)";\r\n}\r\nstatic void dice_proc_fixup_string(char *s, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < size; i += 4)\r\ncpu_to_le32s((u32 *)(s + i));\r\nfor (i = 0; i < size - 2; ++i) {\r\nif (s[i] == '\0')\r\nreturn;\r\nif (s[i] == '\\' && s[i + 1] == '\\') {\r\ns[i + 2] = '\0';\r\nreturn;\r\n}\r\n}\r\ns[size - 1] = '\0';\r\n}\r\nstatic void dice_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstatic const char *const section_names[5] = {\r\n"global", "tx", "rx", "ext_sync", "unused2"\r\n};\r\nstatic const char *const clock_sources[] = {\r\n"aes1", "aes2", "aes3", "aes4", "aes", "adat", "tdif",\r\n"wc", "arx1", "arx2", "arx3", "arx4", "internal"\r\n};\r\nstatic const char *const rates[] = {\r\n"32000", "44100", "48000", "88200", "96000", "176400", "192000",\r\n"any low", "any mid", "any high", "none"\r\n};\r\nstruct dice *dice = entry->private_data;\r\nu32 sections[ARRAY_SIZE(section_names) * 2];\r\nstruct {\r\nu32 number;\r\nu32 size;\r\n} tx_rx_header;\r\nunion {\r\nstruct {\r\nu32 owner_hi, owner_lo;\r\nu32 notification;\r\nchar nick_name[NICK_NAME_SIZE];\r\nu32 clock_select;\r\nu32 enable;\r\nu32 status;\r\nu32 extended_status;\r\nu32 sample_rate;\r\nu32 version;\r\nu32 clock_caps;\r\nchar clock_source_names[CLOCK_SOURCE_NAMES_SIZE];\r\n} global;\r\nstruct {\r\nu32 iso;\r\nu32 number_audio;\r\nu32 number_midi;\r\nu32 speed;\r\nchar names[TX_NAMES_SIZE];\r\nu32 ac3_caps;\r\nu32 ac3_enable;\r\n} tx;\r\nstruct {\r\nu32 iso;\r\nu32 seq_start;\r\nu32 number_audio;\r\nu32 number_midi;\r\nchar names[RX_NAMES_SIZE];\r\nu32 ac3_caps;\r\nu32 ac3_enable;\r\n} rx;\r\nstruct {\r\nu32 clock_source;\r\nu32 locked;\r\nu32 rate;\r\nu32 adat_user_data;\r\n} ext_sync;\r\n} buf;\r\nunsigned int quadlets, stream, i;\r\nif (dice_proc_read_mem(dice, sections, 0, ARRAY_SIZE(sections)) < 0)\r\nreturn;\r\nsnd_iprintf(buffer, "sections:\n");\r\nfor (i = 0; i < ARRAY_SIZE(section_names); ++i)\r\nsnd_iprintf(buffer, " %s: offset %u, size %u\n",\r\nsection_names[i],\r\nsections[i * 2], sections[i * 2 + 1]);\r\nquadlets = min_t(u32, sections[1], sizeof(buf.global) / 4);\r\nif (dice_proc_read_mem(dice, &buf.global, sections[0], quadlets) < 0)\r\nreturn;\r\nsnd_iprintf(buffer, "global:\n");\r\nsnd_iprintf(buffer, " owner: %04x:%04x%08x\n",\r\nbuf.global.owner_hi >> 16,\r\nbuf.global.owner_hi & 0xffff, buf.global.owner_lo);\r\nsnd_iprintf(buffer, " notification: %08x\n", buf.global.notification);\r\ndice_proc_fixup_string(buf.global.nick_name, NICK_NAME_SIZE);\r\nsnd_iprintf(buffer, " nick name: %s\n", buf.global.nick_name);\r\nsnd_iprintf(buffer, " clock select: %s %s\n",\r\nstr_from_array(clock_sources, ARRAY_SIZE(clock_sources),\r\nbuf.global.clock_select & CLOCK_SOURCE_MASK),\r\nstr_from_array(rates, ARRAY_SIZE(rates),\r\n(buf.global.clock_select & CLOCK_RATE_MASK)\r\n>> CLOCK_RATE_SHIFT));\r\nsnd_iprintf(buffer, " enable: %u\n", buf.global.enable);\r\nsnd_iprintf(buffer, " status: %slocked %s\n",\r\nbuf.global.status & STATUS_SOURCE_LOCKED ? "" : "un",\r\nstr_from_array(rates, ARRAY_SIZE(rates),\r\n(buf.global.status &\r\nSTATUS_NOMINAL_RATE_MASK)\r\n>> CLOCK_RATE_SHIFT));\r\nsnd_iprintf(buffer, " ext status: %08x\n", buf.global.extended_status);\r\nsnd_iprintf(buffer, " sample rate: %u\n", buf.global.sample_rate);\r\nsnd_iprintf(buffer, " version: %u.%u.%u.%u\n",\r\n(buf.global.version >> 24) & 0xff,\r\n(buf.global.version >> 16) & 0xff,\r\n(buf.global.version >> 8) & 0xff,\r\n(buf.global.version >> 0) & 0xff);\r\nif (quadlets >= 90) {\r\nsnd_iprintf(buffer, " clock caps:");\r\nfor (i = 0; i <= 6; ++i)\r\nif (buf.global.clock_caps & (1 << i))\r\nsnd_iprintf(buffer, " %s", rates[i]);\r\nfor (i = 0; i <= 12; ++i)\r\nif (buf.global.clock_caps & (1 << (16 + i)))\r\nsnd_iprintf(buffer, " %s", clock_sources[i]);\r\nsnd_iprintf(buffer, "\n");\r\ndice_proc_fixup_string(buf.global.clock_source_names,\r\nCLOCK_SOURCE_NAMES_SIZE);\r\nsnd_iprintf(buffer, " clock source names: %s\n",\r\nbuf.global.clock_source_names);\r\n}\r\nif (dice_proc_read_mem(dice, &tx_rx_header, sections[2], 2) < 0)\r\nreturn;\r\nquadlets = min_t(u32, tx_rx_header.size, sizeof(buf.tx) / 4);\r\nfor (stream = 0; stream < tx_rx_header.number; ++stream) {\r\nif (dice_proc_read_mem(dice, &buf.tx, sections[2] + 2 +\r\nstream * tx_rx_header.size,\r\nquadlets) < 0)\r\nbreak;\r\nsnd_iprintf(buffer, "tx %u:\n", stream);\r\nsnd_iprintf(buffer, " iso channel: %d\n", (int)buf.tx.iso);\r\nsnd_iprintf(buffer, " audio channels: %u\n",\r\nbuf.tx.number_audio);\r\nsnd_iprintf(buffer, " midi ports: %u\n", buf.tx.number_midi);\r\nsnd_iprintf(buffer, " speed: S%u\n", 100u << buf.tx.speed);\r\nif (quadlets >= 68) {\r\ndice_proc_fixup_string(buf.tx.names, TX_NAMES_SIZE);\r\nsnd_iprintf(buffer, " names: %s\n", buf.tx.names);\r\n}\r\nif (quadlets >= 70) {\r\nsnd_iprintf(buffer, " ac3 caps: %08x\n",\r\nbuf.tx.ac3_caps);\r\nsnd_iprintf(buffer, " ac3 enable: %08x\n",\r\nbuf.tx.ac3_enable);\r\n}\r\n}\r\nif (dice_proc_read_mem(dice, &tx_rx_header, sections[4], 2) < 0)\r\nreturn;\r\nquadlets = min_t(u32, tx_rx_header.size, sizeof(buf.rx) / 4);\r\nfor (stream = 0; stream < tx_rx_header.number; ++stream) {\r\nif (dice_proc_read_mem(dice, &buf.rx, sections[4] + 2 +\r\nstream * tx_rx_header.size,\r\nquadlets) < 0)\r\nbreak;\r\nsnd_iprintf(buffer, "rx %u:\n", stream);\r\nsnd_iprintf(buffer, " iso channel: %d\n", (int)buf.rx.iso);\r\nsnd_iprintf(buffer, " sequence start: %u\n", buf.rx.seq_start);\r\nsnd_iprintf(buffer, " audio channels: %u\n",\r\nbuf.rx.number_audio);\r\nsnd_iprintf(buffer, " midi ports: %u\n", buf.rx.number_midi);\r\nif (quadlets >= 68) {\r\ndice_proc_fixup_string(buf.rx.names, RX_NAMES_SIZE);\r\nsnd_iprintf(buffer, " names: %s\n", buf.rx.names);\r\n}\r\nif (quadlets >= 70) {\r\nsnd_iprintf(buffer, " ac3 caps: %08x\n",\r\nbuf.rx.ac3_caps);\r\nsnd_iprintf(buffer, " ac3 enable: %08x\n",\r\nbuf.rx.ac3_enable);\r\n}\r\n}\r\nquadlets = min_t(u32, sections[7], sizeof(buf.ext_sync) / 4);\r\nif (quadlets >= 4) {\r\nif (dice_proc_read_mem(dice, &buf.ext_sync,\r\nsections[6], 4) < 0)\r\nreturn;\r\nsnd_iprintf(buffer, "ext status:\n");\r\nsnd_iprintf(buffer, " clock source: %s\n",\r\nstr_from_array(clock_sources,\r\nARRAY_SIZE(clock_sources),\r\nbuf.ext_sync.clock_source));\r\nsnd_iprintf(buffer, " locked: %u\n", buf.ext_sync.locked);\r\nsnd_iprintf(buffer, " rate: %s\n",\r\nstr_from_array(rates, ARRAY_SIZE(rates),\r\nbuf.ext_sync.rate));\r\nsnd_iprintf(buffer, " adat user data: ");\r\nif (buf.ext_sync.adat_user_data & ADAT_USER_DATA_NO_DATA)\r\nsnd_iprintf(buffer, "-\n");\r\nelse\r\nsnd_iprintf(buffer, "%x\n",\r\nbuf.ext_sync.adat_user_data);\r\n}\r\n}\r\nstatic void dice_create_proc(struct dice *dice)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(dice->card, "dice", &entry))\r\nsnd_info_set_text_ops(entry, dice, dice_proc_read);\r\n}\r\nstatic void dice_card_free(struct snd_card *card)\r\n{\r\nstruct dice *dice = card->private_data;\r\namdtp_stream_destroy(&dice->stream);\r\nfw_core_remove_address_handler(&dice->notification_handler);\r\nmutex_destroy(&dice->mutex);\r\n}\r\nstatic int dice_interface_check(struct fw_unit *unit)\r\n{\r\nstatic const int min_values[10] = {\r\n10, 0x64 / 4,\r\n10, 0x18 / 4,\r\n10, 0x18 / 4,\r\n0, 0,\r\n0, 0,\r\n};\r\nstruct fw_device *device = fw_parent_device(unit);\r\nstruct fw_csr_iterator it;\r\nint key, value, vendor = -1, model = -1, err;\r\nunsigned int category, i;\r\n__be32 pointers[ARRAY_SIZE(min_values)];\r\n__be32 tx_data[4];\r\n__be32 version;\r\nfw_csr_iterator_init(&it, unit->directory);\r\nwhile (fw_csr_iterator_next(&it, &key, &value)) {\r\nswitch (key) {\r\ncase CSR_SPECIFIER_ID:\r\nvendor = value;\r\nbreak;\r\ncase CSR_MODEL:\r\nmodel = value;\r\nbreak;\r\n}\r\n}\r\nif (vendor == OUI_WEISS)\r\ncategory = WEISS_CATEGORY_ID;\r\nelse\r\ncategory = DICE_CATEGORY_ID;\r\nif (device->config_rom[3] != ((vendor << 8) | category) ||\r\ndevice->config_rom[4] >> 22 != model)\r\nreturn -ENODEV;\r\nerr = snd_fw_transaction(unit, TCODE_READ_BLOCK_REQUEST,\r\nDICE_PRIVATE_SPACE,\r\npointers, sizeof(pointers), 0);\r\nif (err < 0)\r\nreturn -ENODEV;\r\nfor (i = 0; i < ARRAY_SIZE(pointers); ++i) {\r\nvalue = be32_to_cpu(pointers[i]);\r\nif (value < min_values[i] || value >= 0x40000)\r\nreturn -ENODEV;\r\n}\r\nerr = snd_fw_transaction(unit, TCODE_READ_BLOCK_REQUEST,\r\nDICE_PRIVATE_SPACE +\r\nbe32_to_cpu(pointers[2]) * 4,\r\ntx_data, sizeof(tx_data), 0);\r\nif (err < 0 || (tx_data[0] && tx_data[3]))\r\nreturn -ENODEV;\r\nerr = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,\r\nDICE_PRIVATE_SPACE +\r\nbe32_to_cpu(pointers[0]) * 4 + GLOBAL_VERSION,\r\n&version, 4, 0);\r\nif (err < 0)\r\nreturn -ENODEV;\r\nif ((version & cpu_to_be32(0xff000000)) != cpu_to_be32(0x01000000)) {\r\ndev_err(&unit->device,\r\n"unknown DICE version: 0x%08x\n", be32_to_cpu(version));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int highest_supported_mode_rate(struct dice *dice, unsigned int mode)\r\n{\r\nint i;\r\nfor (i = ARRAY_SIZE(dice_rates) - 1; i >= 0; --i)\r\nif ((dice->clock_caps & (1 << i)) &&\r\nrate_index_to_mode(i) == mode)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic int dice_read_mode_params(struct dice *dice, unsigned int mode)\r\n{\r\n__be32 values[2];\r\nint rate_index, err;\r\nrate_index = highest_supported_mode_rate(dice, mode);\r\nif (rate_index < 0) {\r\ndice->rx_channels[mode] = 0;\r\ndice->rx_midi_ports[mode] = 0;\r\nreturn 0;\r\n}\r\nerr = dice_change_rate(dice, rate_index << CLOCK_RATE_SHIFT);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\r\nrx_address(dice, RX_NUMBER_AUDIO),\r\nvalues, 2 * 4, 0);\r\nif (err < 0)\r\nreturn err;\r\ndice->rx_channels[mode] = be32_to_cpu(values[0]);\r\ndice->rx_midi_ports[mode] = be32_to_cpu(values[1]);\r\nreturn 0;\r\n}\r\nstatic int dice_read_params(struct dice *dice)\r\n{\r\n__be32 pointers[6];\r\n__be32 value;\r\nint mode, err;\r\nerr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\r\nDICE_PRIVATE_SPACE,\r\npointers, sizeof(pointers), 0);\r\nif (err < 0)\r\nreturn err;\r\ndice->global_offset = be32_to_cpu(pointers[0]) * 4;\r\ndice->rx_offset = be32_to_cpu(pointers[4]) * 4;\r\nif (be32_to_cpu(pointers[1]) * 4 >= GLOBAL_CLOCK_CAPABILITIES + 4) {\r\nerr = snd_fw_transaction(\r\ndice->unit, TCODE_READ_QUADLET_REQUEST,\r\nglobal_address(dice, GLOBAL_CLOCK_CAPABILITIES),\r\n&value, 4, 0);\r\nif (err < 0)\r\nreturn err;\r\ndice->clock_caps = be32_to_cpu(value);\r\n} else {\r\ndice->clock_caps = CLOCK_CAP_RATE_44100 |\r\nCLOCK_CAP_RATE_48000 |\r\nCLOCK_CAP_SOURCE_ARX1 |\r\nCLOCK_CAP_SOURCE_INTERNAL;\r\n}\r\nfor (mode = 2; mode >= 0; --mode) {\r\nerr = dice_read_mode_params(dice, mode);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dice_card_strings(struct dice *dice)\r\n{\r\nstruct snd_card *card = dice->card;\r\nstruct fw_device *dev = fw_parent_device(dice->unit);\r\nchar vendor[32], model[32];\r\nunsigned int i;\r\nint err;\r\nstrcpy(card->driver, "DICE");\r\nstrcpy(card->shortname, "DICE");\r\nBUILD_BUG_ON(NICK_NAME_SIZE < sizeof(card->shortname));\r\nerr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\r\nglobal_address(dice, GLOBAL_NICK_NAME),\r\ncard->shortname, sizeof(card->shortname), 0);\r\nif (err >= 0) {\r\nBUILD_BUG_ON(sizeof(card->shortname) % 4 != 0);\r\nfor (i = 0; i < sizeof(card->shortname); i += 4)\r\nswab32s((u32 *)&card->shortname[i]);\r\ncard->shortname[sizeof(card->shortname) - 1] = '\0';\r\n}\r\nstrcpy(vendor, "?");\r\nfw_csr_string(dev->config_rom + 5, CSR_VENDOR, vendor, sizeof(vendor));\r\nstrcpy(model, "?");\r\nfw_csr_string(dice->unit->directory, CSR_MODEL, model, sizeof(model));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s %s (serial %u) at %s, S%d",\r\nvendor, model, dev->config_rom[4] & 0x3fffff,\r\ndev_name(&dice->unit->device), 100 << dev->max_speed);\r\nstrcpy(card->mixername, "DICE");\r\n}\r\nstatic int dice_probe(struct fw_unit *unit, const struct ieee1394_device_id *id)\r\n{\r\nstruct snd_card *card;\r\nstruct dice *dice;\r\n__be32 clock_sel;\r\nint err;\r\nerr = dice_interface_check(unit);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_card_new(&unit->device, -1, NULL, THIS_MODULE,\r\nsizeof(*dice), &card);\r\nif (err < 0)\r\nreturn err;\r\ndice = card->private_data;\r\ndice->card = card;\r\nspin_lock_init(&dice->lock);\r\nmutex_init(&dice->mutex);\r\ndice->unit = unit;\r\ninit_completion(&dice->clock_accepted);\r\ninit_waitqueue_head(&dice->hwdep_wait);\r\ndice->notification_handler.length = 4;\r\ndice->notification_handler.address_callback = dice_notification;\r\ndice->notification_handler.callback_data = dice;\r\nerr = fw_core_add_address_handler(&dice->notification_handler,\r\n&fw_high_memory_region);\r\nif (err < 0)\r\ngoto err_mutex;\r\nerr = dice_owner_set(dice);\r\nif (err < 0)\r\ngoto err_notification_handler;\r\nerr = dice_read_params(dice);\r\nif (err < 0)\r\ngoto err_owner;\r\nerr = fw_iso_resources_init(&dice->resources, unit);\r\nif (err < 0)\r\ngoto err_owner;\r\ndice->resources.channels_mask = 0x00000000ffffffffuLL;\r\nerr = amdtp_stream_init(&dice->stream, unit, AMDTP_OUT_STREAM,\r\nCIP_BLOCKING);\r\nif (err < 0)\r\ngoto err_resources;\r\ncard->private_free = dice_card_free;\r\ndice_card_strings(dice);\r\nerr = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,\r\nglobal_address(dice, GLOBAL_CLOCK_SELECT),\r\n&clock_sel, 4, 0);\r\nif (err < 0)\r\ngoto error;\r\nclock_sel &= cpu_to_be32(~CLOCK_SOURCE_MASK);\r\nclock_sel |= cpu_to_be32(CLOCK_SOURCE_ARX1);\r\nerr = snd_fw_transaction(unit, TCODE_WRITE_QUADLET_REQUEST,\r\nglobal_address(dice, GLOBAL_CLOCK_SELECT),\r\n&clock_sel, 4, 0);\r\nif (err < 0)\r\ngoto error;\r\nerr = dice_create_pcm(dice);\r\nif (err < 0)\r\ngoto error;\r\nerr = dice_create_hwdep(dice);\r\nif (err < 0)\r\ngoto error;\r\ndice_create_proc(dice);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto error;\r\ndev_set_drvdata(&unit->device, dice);\r\nreturn 0;\r\nerr_resources:\r\nfw_iso_resources_destroy(&dice->resources);\r\nerr_owner:\r\ndice_owner_clear(dice);\r\nerr_notification_handler:\r\nfw_core_remove_address_handler(&dice->notification_handler);\r\nerr_mutex:\r\nmutex_destroy(&dice->mutex);\r\nerror:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void dice_remove(struct fw_unit *unit)\r\n{\r\nstruct dice *dice = dev_get_drvdata(&unit->device);\r\namdtp_stream_pcm_abort(&dice->stream);\r\nsnd_card_disconnect(dice->card);\r\nmutex_lock(&dice->mutex);\r\ndice_stream_stop(dice);\r\ndice_owner_clear(dice);\r\nmutex_unlock(&dice->mutex);\r\nsnd_card_free_when_closed(dice->card);\r\n}\r\nstatic void dice_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct dice *dice = dev_get_drvdata(&unit->device);\r\namdtp_stream_pcm_abort(&dice->stream);\r\nmutex_lock(&dice->mutex);\r\ndice->global_enabled = false;\r\ndice_stream_stop_packets(dice);\r\ndice_owner_update(dice);\r\nfw_iso_resources_update(&dice->resources);\r\nmutex_unlock(&dice->mutex);\r\n}\r\nstatic int __init alsa_dice_init(void)\r\n{\r\nreturn driver_register(&dice_driver.driver);\r\n}\r\nstatic void __exit alsa_dice_exit(void)\r\n{\r\ndriver_unregister(&dice_driver.driver);\r\n}
