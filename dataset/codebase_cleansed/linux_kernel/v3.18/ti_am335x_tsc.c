static unsigned int titsc_readl(struct titsc *ts, unsigned int reg)\r\n{\r\nreturn readl(ts->mfd_tscadc->tscadc_base + reg);\r\n}\r\nstatic void titsc_writel(struct titsc *tsc, unsigned int reg,\r\nunsigned int val)\r\n{\r\nwritel(val, tsc->mfd_tscadc->tscadc_base + reg);\r\n}\r\nstatic int titsc_config_wires(struct titsc *ts_dev)\r\n{\r\nu32 analog_line[4];\r\nu32 wire_order[4];\r\nint i, bit_cfg;\r\nfor (i = 0; i < 4; i++) {\r\nanalog_line[i] = (ts_dev->config_inp[i] & 0xF0) >> 4;\r\nwire_order[i] = ts_dev->config_inp[i] & 0x0F;\r\nif (WARN_ON(analog_line[i] > 7))\r\nreturn -EINVAL;\r\nif (WARN_ON(wire_order[i] > ARRAY_SIZE(config_pins)))\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nint an_line;\r\nint wi_order;\r\nan_line = analog_line[i];\r\nwi_order = wire_order[i];\r\nbit_cfg = config_pins[wi_order];\r\nif (bit_cfg == 0)\r\nreturn -EINVAL;\r\nswitch (wi_order) {\r\ncase 0:\r\nts_dev->bit_xp = bit_cfg;\r\nts_dev->inp_xp = an_line;\r\nbreak;\r\ncase 1:\r\nts_dev->bit_xn = bit_cfg;\r\nts_dev->inp_xn = an_line;\r\nbreak;\r\ncase 2:\r\nts_dev->bit_yp = bit_cfg;\r\nts_dev->inp_yp = an_line;\r\nbreak;\r\ncase 3:\r\nts_dev->bit_yn = bit_cfg;\r\nts_dev->inp_yn = an_line;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void titsc_step_config(struct titsc *ts_dev)\r\n{\r\nunsigned int config;\r\nint i;\r\nint end_step;\r\nu32 stepenable;\r\nconfig = STEPCONFIG_MODE_HWSYNC |\r\nSTEPCONFIG_AVG_16 | ts_dev->bit_xp;\r\nswitch (ts_dev->wires) {\r\ncase 4:\r\nconfig |= STEPCONFIG_INP(ts_dev->inp_yp) | ts_dev->bit_xn;\r\nbreak;\r\ncase 5:\r\nconfig |= ts_dev->bit_yn |\r\nSTEPCONFIG_INP_AN4 | ts_dev->bit_xn |\r\nts_dev->bit_yp;\r\nbreak;\r\ncase 8:\r\nconfig |= STEPCONFIG_INP(ts_dev->inp_yp) | ts_dev->bit_xn;\r\nbreak;\r\n}\r\nend_step = ts_dev->coordinate_readouts;\r\nfor (i = 0; i < end_step; i++) {\r\ntitsc_writel(ts_dev, REG_STEPCONFIG(i), config);\r\ntitsc_writel(ts_dev, REG_STEPDELAY(i), STEPCONFIG_OPENDLY);\r\n}\r\nconfig = 0;\r\nconfig = STEPCONFIG_MODE_HWSYNC |\r\nSTEPCONFIG_AVG_16 | ts_dev->bit_yn |\r\nSTEPCONFIG_INM_ADCREFM;\r\nswitch (ts_dev->wires) {\r\ncase 4:\r\nconfig |= ts_dev->bit_yp | STEPCONFIG_INP(ts_dev->inp_xp);\r\nbreak;\r\ncase 5:\r\nconfig |= ts_dev->bit_xp | STEPCONFIG_INP_AN4 |\r\nts_dev->bit_xn | ts_dev->bit_yp;\r\nbreak;\r\ncase 8:\r\nconfig |= ts_dev->bit_yp | STEPCONFIG_INP(ts_dev->inp_xp);\r\nbreak;\r\n}\r\nend_step = ts_dev->coordinate_readouts * 2;\r\nfor (i = ts_dev->coordinate_readouts; i < end_step; i++) {\r\ntitsc_writel(ts_dev, REG_STEPCONFIG(i), config);\r\ntitsc_writel(ts_dev, REG_STEPDELAY(i), STEPCONFIG_OPENDLY);\r\n}\r\nconfig = ts_dev->bit_xp | ts_dev->bit_yn |\r\nSTEPCHARGE_RFP_XPUL | STEPCHARGE_RFM_XNUR |\r\nSTEPCHARGE_INM_AN1 | STEPCHARGE_INP(ts_dev->inp_yp);\r\ntitsc_writel(ts_dev, REG_CHARGECONFIG, config);\r\ntitsc_writel(ts_dev, REG_CHARGEDELAY, CHARGEDLY_OPENDLY);\r\nconfig = STEPCONFIG_MODE_HWSYNC |\r\nSTEPCONFIG_AVG_16 | ts_dev->bit_yp |\r\nts_dev->bit_xn | STEPCONFIG_INM_ADCREFM |\r\nSTEPCONFIG_INP(ts_dev->inp_xp);\r\ntitsc_writel(ts_dev, REG_STEPCONFIG(end_step), config);\r\ntitsc_writel(ts_dev, REG_STEPDELAY(end_step),\r\nSTEPCONFIG_OPENDLY);\r\nend_step++;\r\nconfig |= STEPCONFIG_INP(ts_dev->inp_yn);\r\ntitsc_writel(ts_dev, REG_STEPCONFIG(end_step), config);\r\ntitsc_writel(ts_dev, REG_STEPDELAY(end_step),\r\nSTEPCONFIG_OPENDLY);\r\nstepenable = (1 << (end_step + 2)) - 1;\r\nts_dev->step_mask = stepenable;\r\nam335x_tsc_se_set_cache(ts_dev->mfd_tscadc, ts_dev->step_mask);\r\n}\r\nstatic void titsc_read_coordinates(struct titsc *ts_dev,\r\nu32 *x, u32 *y, u32 *z1, u32 *z2)\r\n{\r\nunsigned int fifocount = titsc_readl(ts_dev, REG_FIFO0CNT);\r\nunsigned int prev_val_x = ~0, prev_val_y = ~0;\r\nunsigned int prev_diff_x = ~0, prev_diff_y = ~0;\r\nunsigned int read, diff;\r\nunsigned int i, channel;\r\nunsigned int creads = ts_dev->coordinate_readouts;\r\n*z1 = *z2 = 0;\r\nif (fifocount % (creads * 2 + 2))\r\nfifocount -= fifocount % (creads * 2 + 2);\r\nfor (i = 0; i < fifocount; i++) {\r\nread = titsc_readl(ts_dev, REG_FIFO0);\r\nchannel = (read & 0xf0000) >> 16;\r\nread &= 0xfff;\r\nif (channel < creads) {\r\ndiff = abs(read - prev_val_x);\r\nif (diff < prev_diff_x) {\r\nprev_diff_x = diff;\r\n*x = read;\r\n}\r\nprev_val_x = read;\r\n} else if (channel < creads * 2) {\r\ndiff = abs(read - prev_val_y);\r\nif (diff < prev_diff_y) {\r\nprev_diff_y = diff;\r\n*y = read;\r\n}\r\nprev_val_y = read;\r\n} else if (channel < creads * 2 + 1) {\r\n*z1 = read;\r\n} else if (channel < creads * 2 + 2) {\r\n*z2 = read;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t titsc_irq(int irq, void *dev)\r\n{\r\nstruct titsc *ts_dev = dev;\r\nstruct input_dev *input_dev = ts_dev->input;\r\nunsigned int status, irqclr = 0;\r\nunsigned int x = 0, y = 0;\r\nunsigned int z1, z2, z;\r\nunsigned int fsm;\r\nstatus = titsc_readl(ts_dev, REG_IRQSTATUS);\r\nif (status & IRQENB_FIFO0THRES) {\r\ntitsc_read_coordinates(ts_dev, &x, &y, &z1, &z2);\r\nif (ts_dev->pen_down && z1 != 0 && z2 != 0) {\r\nz = z1 - z2;\r\nz *= x;\r\nz *= ts_dev->x_plate_resistance;\r\nz /= z2;\r\nz = (z + 2047) >> 12;\r\nif (z <= MAX_12BIT) {\r\ninput_report_abs(input_dev, ABS_X, x);\r\ninput_report_abs(input_dev, ABS_Y, y);\r\ninput_report_abs(input_dev, ABS_PRESSURE, z);\r\ninput_report_key(input_dev, BTN_TOUCH, 1);\r\ninput_sync(input_dev);\r\n}\r\n}\r\nirqclr |= IRQENB_FIFO0THRES;\r\n}\r\nudelay(SEQ_SETTLE);\r\nstatus = titsc_readl(ts_dev, REG_RAWIRQSTATUS);\r\nif (status & IRQENB_PENUP) {\r\nfsm = titsc_readl(ts_dev, REG_ADCFSM);\r\nif (fsm == ADCFSM_STEPID) {\r\nts_dev->pen_down = false;\r\ninput_report_key(input_dev, BTN_TOUCH, 0);\r\ninput_report_abs(input_dev, ABS_PRESSURE, 0);\r\ninput_sync(input_dev);\r\n} else {\r\nts_dev->pen_down = true;\r\n}\r\nirqclr |= IRQENB_PENUP;\r\n}\r\nif (status & IRQENB_HW_PEN) {\r\ntitsc_writel(ts_dev, REG_IRQWAKEUP, 0x00);\r\ntitsc_writel(ts_dev, REG_IRQCLR, IRQENB_HW_PEN);\r\n}\r\nif (irqclr) {\r\ntitsc_writel(ts_dev, REG_IRQSTATUS, irqclr);\r\nam335x_tsc_se_set_cache(ts_dev->mfd_tscadc, ts_dev->step_mask);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int titsc_parse_dt(struct platform_device *pdev,\r\nstruct titsc *ts_dev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nint err;\r\nif (!node)\r\nreturn -EINVAL;\r\nerr = of_property_read_u32(node, "ti,wires", &ts_dev->wires);\r\nif (err < 0)\r\nreturn err;\r\nswitch (ts_dev->wires) {\r\ncase 4:\r\ncase 5:\r\ncase 8:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = of_property_read_u32(node, "ti,x-plate-resistance",\r\n&ts_dev->x_plate_resistance);\r\nif (err < 0)\r\nreturn err;\r\nerr = of_property_read_u32(node, "ti,coordinate-readouts",\r\n&ts_dev->coordinate_readouts);\r\nif (err < 0) {\r\ndev_warn(&pdev->dev, "please use 'ti,coordinate-readouts' instead\n");\r\nerr = of_property_read_u32(node, "ti,coordiante-readouts",\r\n&ts_dev->coordinate_readouts);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nreturn of_property_read_u32_array(node, "ti,wire-config",\r\nts_dev->config_inp, ARRAY_SIZE(ts_dev->config_inp));\r\n}\r\nstatic int titsc_probe(struct platform_device *pdev)\r\n{\r\nstruct titsc *ts_dev;\r\nstruct input_dev *input_dev;\r\nstruct ti_tscadc_dev *tscadc_dev = ti_tscadc_dev_get(pdev);\r\nint err;\r\nts_dev = kzalloc(sizeof(struct titsc), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts_dev || !input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate memory.\n");\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ntscadc_dev->tsc = ts_dev;\r\nts_dev->mfd_tscadc = tscadc_dev;\r\nts_dev->input = input_dev;\r\nts_dev->irq = tscadc_dev->irq;\r\nerr = titsc_parse_dt(pdev, ts_dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Could not find valid DT data.\n");\r\ngoto err_free_mem;\r\n}\r\nerr = request_irq(ts_dev->irq, titsc_irq,\r\nIRQF_SHARED, pdev->dev.driver->name, ts_dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to allocate irq.\n");\r\ngoto err_free_mem;\r\n}\r\ntitsc_writel(ts_dev, REG_IRQENABLE, IRQENB_FIFO0THRES);\r\nerr = titsc_config_wires(ts_dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "wrong i/p wire configuration\n");\r\ngoto err_free_irq;\r\n}\r\ntitsc_step_config(ts_dev);\r\ntitsc_writel(ts_dev, REG_FIFO0THR,\r\nts_dev->coordinate_readouts * 2 + 2 - 1);\r\ninput_dev->name = "ti-tsc";\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT, 0, 0);\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_free_irq;\r\nplatform_set_drvdata(pdev, ts_dev);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(ts_dev->irq, ts_dev);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ts_dev);\r\nreturn err;\r\n}\r\nstatic int titsc_remove(struct platform_device *pdev)\r\n{\r\nstruct titsc *ts_dev = platform_get_drvdata(pdev);\r\nu32 steps;\r\nfree_irq(ts_dev->irq, ts_dev);\r\nsteps = 2 * ts_dev->coordinate_readouts + 2;\r\nsteps = (1 << steps) - 1;\r\nam335x_tsc_se_clr(ts_dev->mfd_tscadc, steps);\r\ninput_unregister_device(ts_dev->input);\r\nkfree(ts_dev);\r\nreturn 0;\r\n}\r\nstatic int titsc_suspend(struct device *dev)\r\n{\r\nstruct titsc *ts_dev = dev_get_drvdata(dev);\r\nstruct ti_tscadc_dev *tscadc_dev;\r\nunsigned int idle;\r\ntscadc_dev = ti_tscadc_dev_get(to_platform_device(dev));\r\nif (device_may_wakeup(tscadc_dev->dev)) {\r\nidle = titsc_readl(ts_dev, REG_IRQENABLE);\r\ntitsc_writel(ts_dev, REG_IRQENABLE,\r\n(idle | IRQENB_HW_PEN));\r\ntitsc_writel(ts_dev, REG_IRQWAKEUP, IRQWKUP_ENB);\r\n}\r\nreturn 0;\r\n}\r\nstatic int titsc_resume(struct device *dev)\r\n{\r\nstruct titsc *ts_dev = dev_get_drvdata(dev);\r\nstruct ti_tscadc_dev *tscadc_dev;\r\ntscadc_dev = ti_tscadc_dev_get(to_platform_device(dev));\r\nif (device_may_wakeup(tscadc_dev->dev)) {\r\ntitsc_writel(ts_dev, REG_IRQWAKEUP,\r\n0x00);\r\ntitsc_writel(ts_dev, REG_IRQCLR, IRQENB_HW_PEN);\r\n}\r\ntitsc_step_config(ts_dev);\r\ntitsc_writel(ts_dev, REG_FIFO0THR,\r\nts_dev->coordinate_readouts * 2 + 2 - 1);\r\nreturn 0;\r\n}
