static inline uchar read_3393(struct IN2000_hostdata *hostdata, uchar reg_num)\r\n{\r\nwrite1_io(reg_num, IO_WD_ADDR);\r\nreturn read1_io(IO_WD_DATA);\r\n}\r\nstatic inline void write_3393(struct IN2000_hostdata *hostdata, uchar reg_num, uchar value)\r\n{\r\nwrite1_io(reg_num, IO_WD_ADDR);\r\nwrite1_io(value, IO_WD_DATA);\r\n}\r\nstatic inline void write_3393_cmd(struct IN2000_hostdata *hostdata, uchar cmd)\r\n{\r\nwrite1_io(WD_COMMAND, IO_WD_ADDR);\r\nwrite1_io(cmd, IO_WD_DATA);\r\n}\r\nstatic uchar read_1_byte(struct IN2000_hostdata *hostdata)\r\n{\r\nuchar asr, x = 0;\r\nwrite_3393(hostdata, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite_3393_cmd(hostdata, WD_CMD_TRANS_INFO | 0x80);\r\ndo {\r\nasr = READ_AUX_STAT();\r\nif (asr & ASR_DBR)\r\nx = read_3393(hostdata, WD_DATA);\r\n} while (!(asr & ASR_INT));\r\nreturn x;\r\n}\r\nstatic void write_3393_count(struct IN2000_hostdata *hostdata, unsigned long value)\r\n{\r\nwrite1_io(WD_TRANSFER_COUNT_MSB, IO_WD_ADDR);\r\nwrite1_io((value >> 16), IO_WD_DATA);\r\nwrite1_io((value >> 8), IO_WD_DATA);\r\nwrite1_io(value, IO_WD_DATA);\r\n}\r\nstatic unsigned long read_3393_count(struct IN2000_hostdata *hostdata)\r\n{\r\nunsigned long value;\r\nwrite1_io(WD_TRANSFER_COUNT_MSB, IO_WD_ADDR);\r\nvalue = read1_io(IO_WD_DATA) << 16;\r\nvalue |= read1_io(IO_WD_DATA) << 8;\r\nvalue |= read1_io(IO_WD_DATA);\r\nreturn value;\r\n}\r\nstatic int is_dir_out(Scsi_Cmnd * cmd)\r\n{\r\nswitch (cmd->cmnd[0]) {\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_12:\r\ncase WRITE_LONG:\r\ncase WRITE_SAME:\r\ncase WRITE_BUFFER:\r\ncase WRITE_VERIFY:\r\ncase WRITE_VERIFY_12:\r\ncase COMPARE:\r\ncase COPY:\r\ncase COPY_VERIFY:\r\ncase SEARCH_EQUAL:\r\ncase SEARCH_HIGH:\r\ncase SEARCH_LOW:\r\ncase SEARCH_EQUAL_12:\r\ncase SEARCH_HIGH_12:\r\ncase SEARCH_LOW_12:\r\ncase FORMAT_UNIT:\r\ncase REASSIGN_BLOCKS:\r\ncase RESERVE:\r\ncase MODE_SELECT:\r\ncase MODE_SELECT_10:\r\ncase LOG_SELECT:\r\ncase SEND_DIAGNOSTIC:\r\ncase CHANGE_DEFINITION:\r\ncase UPDATE_BLOCK:\r\ncase SET_WINDOW:\r\ncase MEDIUM_SCAN:\r\ncase SEND_VOLUME_TAG:\r\ncase 0xea:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int round_period(unsigned int period)\r\n{\r\nint x;\r\nfor (x = 1; sx_table[x].period_ns; x++) {\r\nif ((period <= sx_table[x - 0].period_ns) && (period > sx_table[x - 1].period_ns)) {\r\nreturn x;\r\n}\r\n}\r\nreturn 7;\r\n}\r\nstatic uchar calc_sync_xfer(unsigned int period, unsigned int offset)\r\n{\r\nuchar result;\r\nperiod *= 4;\r\nresult = sx_table[round_period(period)].reg_value;\r\nresult |= (offset < OPTIMUM_SX_OFF) ? offset : OPTIMUM_SX_OFF;\r\nreturn result;\r\n}\r\nstatic int in2000_queuecommand_lck(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))\r\n{\r\nstruct Scsi_Host *instance;\r\nstruct IN2000_hostdata *hostdata;\r\nScsi_Cmnd *tmp;\r\ninstance = cmd->device->host;\r\nhostdata = (struct IN2000_hostdata *) instance->hostdata;\r\nDB(DB_QUEUE_COMMAND, scmd_printk(KERN_DEBUG, cmd, "Q-%02x(", cmd->cmnd[0]))\r\ncmd->host_scribble = NULL;\r\ncmd->scsi_done = done;\r\ncmd->result = 0;\r\nif (scsi_bufflen(cmd)) {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\n} else {\r\ncmd->SCp.buffer = NULL;\r\ncmd->SCp.buffers_residual = 0;\r\ncmd->SCp.ptr = NULL;\r\ncmd->SCp.this_residual = 0;\r\n}\r\ncmd->SCp.have_data_in = 0;\r\ncmd->SCp.Status = ILLEGAL_STATUS_BYTE;\r\nif (!(hostdata->input_Q) || (cmd->cmnd[0] == REQUEST_SENSE)) {\r\ncmd->host_scribble = (uchar *) hostdata->input_Q;\r\nhostdata->input_Q = cmd;\r\n} else {\r\nfor (tmp = (Scsi_Cmnd *) hostdata->input_Q; tmp->host_scribble; tmp = (Scsi_Cmnd *) tmp->host_scribble);\r\ntmp->host_scribble = (uchar *) cmd;\r\n}\r\nin2000_execute(cmd->device->host);\r\nDB(DB_QUEUE_COMMAND, printk(")Q "))\r\nreturn 0;\r\n}\r\nvoid transfer_pio(uchar * buf, int cnt, int data_in_dir, struct IN2000_hostdata *hostdata)\r\n{\r\nuchar asr;\r\nDB(DB_TRANSFER, printk("(%p,%d,%s)", buf, cnt, data_in_dir ? "in" : "out"))\r\nwrite_3393(hostdata, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite_3393_count(hostdata, cnt);\r\nwrite_3393_cmd(hostdata, WD_CMD_TRANS_INFO);\r\nif (data_in_dir) {\r\ndo {\r\nasr = READ_AUX_STAT();\r\nif (asr & ASR_DBR)\r\n*buf++ = read_3393(hostdata, WD_DATA);\r\n} while (!(asr & ASR_INT));\r\n} else {\r\ndo {\r\nasr = READ_AUX_STAT();\r\nif (asr & ASR_DBR)\r\nwrite_3393(hostdata, WD_DATA, *buf++);\r\n} while (!(asr & ASR_INT));\r\n}\r\n}\r\nstatic void transfer_bytes(Scsi_Cmnd * cmd, int data_in_dir)\r\n{\r\nstruct IN2000_hostdata *hostdata;\r\nunsigned short *sp;\r\nunsigned short f;\r\nint i;\r\nhostdata = (struct IN2000_hostdata *) cmd->device->host->hostdata;\r\nif (!cmd->SCp.this_residual && cmd->SCp.buffers_residual) {\r\n++cmd->SCp.buffer;\r\n--cmd->SCp.buffers_residual;\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\n}\r\nwrite_3393(hostdata, WD_SYNCHRONOUS_TRANSFER, hostdata->sync_xfer[cmd->device->id]);\r\nwrite_3393_count(hostdata, cmd->SCp.this_residual);\r\nwrite_3393(hostdata, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_BUS);\r\nwrite1_io(0, IO_FIFO_WRITE);\r\nif (data_in_dir) {\r\nwrite1_io(0, IO_FIFO_READ);\r\nif ((hostdata->level2 >= L2_DATA) || (hostdata->level2 == L2_BASIC && cmd->SCp.phase == 0)) {\r\nwrite_3393(hostdata, WD_COMMAND_PHASE, 0x45);\r\nwrite_3393_cmd(hostdata, WD_CMD_SEL_ATN_XFER);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\n} else\r\nwrite_3393_cmd(hostdata, WD_CMD_TRANS_INFO);\r\nhostdata->fifo = FI_FIFO_READING;\r\ncmd->SCp.have_data_in = 0;\r\nreturn;\r\n}\r\nif ((hostdata->level2 >= L2_DATA) || (hostdata->level2 == L2_BASIC && cmd->SCp.phase == 0)) {\r\nwrite_3393(hostdata, WD_COMMAND_PHASE, 0x45);\r\nwrite_3393_cmd(hostdata, WD_CMD_SEL_ATN_XFER);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\n} else\r\nwrite_3393_cmd(hostdata, WD_CMD_TRANS_INFO);\r\nhostdata->fifo = FI_FIFO_WRITING;\r\nsp = (unsigned short *) cmd->SCp.ptr;\r\nif ((i = cmd->SCp.this_residual) > IN2000_FIFO_SIZE)\r\ni = IN2000_FIFO_SIZE;\r\ncmd->SCp.have_data_in = i;\r\ni >>= 1;\r\nf = hostdata->io_base + IO_FIFO;\r\n#ifdef FAST_WRITE_IO\r\nFAST_WRITE2_IO();\r\n#else\r\nwhile (i--)\r\nwrite2_io(*sp++, IO_FIFO);\r\n#endif\r\n}\r\nstatic irqreturn_t in2000_intr(int irqnum, void *dev_id)\r\n{\r\nstruct Scsi_Host *instance = dev_id;\r\nstruct IN2000_hostdata *hostdata;\r\nScsi_Cmnd *patch, *cmd;\r\nuchar asr, sr, phs, id, lun, *ucp, msg;\r\nint i, j;\r\nunsigned long length;\r\nunsigned short *sp;\r\nunsigned short f;\r\nunsigned long flags;\r\nhostdata = (struct IN2000_hostdata *) instance->hostdata;\r\nspin_lock_irqsave(instance->host_lock, flags);\r\n#ifdef PROC_STATISTICS\r\nhostdata->int_cnt++;\r\n#endif\r\nwrite1_io(0, IO_LED_ON);\r\nasr = READ_AUX_STAT();\r\nif (!(asr & ASR_INT)) {\r\ncmd = (Scsi_Cmnd *) hostdata->connected;\r\nCHECK_NULL(cmd, "fifo_int")\r\nif (hostdata->fifo == FI_FIFO_READING) {\r\nDB(DB_FIFO, printk("{R:%02x} ", read1_io(IO_FIFO_COUNT)))\r\nsp = (unsigned short *) (cmd->SCp.ptr + cmd->SCp.have_data_in);\r\ni = read1_io(IO_FIFO_COUNT) & 0xfe;\r\ni <<= 2;\r\nf = hostdata->io_base + IO_FIFO;\r\n#ifdef FAST_READ_IO\r\nFAST_READ2_IO();\r\n#else\r\nwhile (i--)\r\n*sp++ = read2_io(IO_FIFO);\r\n#endif\r\ni = sp - (unsigned short *) (cmd->SCp.ptr + cmd->SCp.have_data_in);\r\ni <<= 1;\r\ncmd->SCp.have_data_in += i;\r\n}\r\nelse if (hostdata->fifo == FI_FIFO_WRITING) {\r\nDB(DB_FIFO, printk("{W:%02x} ", read1_io(IO_FIFO_COUNT)))\r\nif (cmd->SCp.this_residual == cmd->SCp.have_data_in) {\r\ni = 16;\r\nwhile (i--)\r\nwrite2_io(0, IO_FIFO);\r\n}\r\nelse {\r\nsp = (unsigned short *) (cmd->SCp.ptr + cmd->SCp.have_data_in);\r\ni = cmd->SCp.this_residual - cmd->SCp.have_data_in;\r\nj = read1_io(IO_FIFO_COUNT) & 0xfe;\r\nj <<= 2;\r\nif ((j << 1) > i)\r\nj = (i >> 1);\r\nwhile (j--)\r\nwrite2_io(*sp++, IO_FIFO);\r\ni = sp - (unsigned short *) (cmd->SCp.ptr + cmd->SCp.have_data_in);\r\ni <<= 1;\r\ncmd->SCp.have_data_in += i;\r\n}\r\n}\r\nelse {\r\nprintk("*** Spurious FIFO interrupt ***");\r\n}\r\nwrite1_io(0, IO_LED_OFF);\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\ncmd = (Scsi_Cmnd *) hostdata->connected;\r\nsr = read_3393(hostdata, WD_SCSI_STATUS);\r\nphs = read_3393(hostdata, WD_COMMAND_PHASE);\r\nif (!cmd && (sr != CSR_RESEL_AM && sr != CSR_TIMEOUT && sr != CSR_SELECT)) {\r\nprintk("\nNR:wd-intr-1\n");\r\nwrite1_io(0, IO_LED_OFF);\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nDB(DB_INTR, printk("{%02x:%02x-", asr, sr))\r\nif (hostdata->fifo == FI_FIFO_READING) {\r\nsp = (unsigned short *) (cmd->SCp.ptr + cmd->SCp.have_data_in);\r\ni = (cmd->SCp.this_residual - read_3393_count(hostdata)) - cmd->SCp.have_data_in;\r\ni >>= 1;\r\nf = hostdata->io_base + IO_FIFO;\r\n#ifdef FAST_READ_IO\r\nFAST_READ2_IO();\r\n#else\r\nwhile (i--)\r\n*sp++ = read2_io(IO_FIFO);\r\n#endif\r\nhostdata->fifo = FI_FIFO_UNUSED;\r\nlength = cmd->SCp.this_residual;\r\ncmd->SCp.this_residual = read_3393_count(hostdata);\r\ncmd->SCp.ptr += (length - cmd->SCp.this_residual);\r\nDB(DB_TRANSFER, printk("(%p,%d)", cmd->SCp.ptr, cmd->SCp.this_residual))\r\n}\r\nelse if (hostdata->fifo == FI_FIFO_WRITING) {\r\nhostdata->fifo = FI_FIFO_UNUSED;\r\nlength = cmd->SCp.this_residual;\r\ncmd->SCp.this_residual = read_3393_count(hostdata);\r\ncmd->SCp.ptr += (length - cmd->SCp.this_residual);\r\nDB(DB_TRANSFER, printk("(%p,%d)", cmd->SCp.ptr, cmd->SCp.this_residual))\r\n}\r\nswitch (sr) {\r\ncase CSR_TIMEOUT:\r\nDB(DB_INTR, printk("TIMEOUT"))\r\nif (hostdata->state == S_RUNNING_LEVEL2)\r\nhostdata->connected = NULL;\r\nelse {\r\ncmd = (Scsi_Cmnd *) hostdata->selecting;\r\nCHECK_NULL(cmd, "csr_timeout")\r\nhostdata->selecting = NULL;\r\n}\r\ncmd->result = DID_NO_CONNECT << 16;\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\nhostdata->state = S_UNCONNECTED;\r\ncmd->scsi_done(cmd);\r\nin2000_execute(instance);\r\nbreak;\r\ncase CSR_SELECT:\r\nDB(DB_INTR, printk("SELECT"))\r\nhostdata->connected = cmd = (Scsi_Cmnd *) hostdata->selecting;\r\nCHECK_NULL(cmd, "csr_select")\r\nhostdata->selecting = NULL;\r\nhostdata->outgoing_msg[0] = (0x80 | 0x00 | cmd->device->lun);\r\nif (cmd->SCp.phase)\r\nhostdata->outgoing_msg[0] |= 0x40;\r\nif (hostdata->sync_stat[cmd->device->id] == SS_FIRST) {\r\n#ifdef SYNC_DEBUG\r\nprintk(" sending SDTR ");\r\n#endif\r\nhostdata->sync_stat[cmd->device->id] = SS_WAITING;\r\nhostdata->outgoing_msg[1] = EXTENDED_MESSAGE;\r\nhostdata->outgoing_msg[2] = 3;\r\nhostdata->outgoing_msg[3] = EXTENDED_SDTR;\r\nhostdata->outgoing_msg[4] = OPTIMUM_SX_PER / 4;\r\nhostdata->outgoing_msg[5] = OPTIMUM_SX_OFF;\r\nhostdata->outgoing_len = 6;\r\n} else\r\nhostdata->outgoing_len = 1;\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_DATA_IN:\r\ncase CSR_UNEXP | PHS_DATA_IN:\r\ncase CSR_SRV_REQ | PHS_DATA_IN:\r\nDB(DB_INTR, printk("IN-%d.%d", cmd->SCp.this_residual, cmd->SCp.buffers_residual))\r\ntransfer_bytes(cmd, DATA_IN_DIR);\r\nif (hostdata->state != S_RUNNING_LEVEL2)\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_DATA_OUT:\r\ncase CSR_UNEXP | PHS_DATA_OUT:\r\ncase CSR_SRV_REQ | PHS_DATA_OUT:\r\nDB(DB_INTR, printk("OUT-%d.%d", cmd->SCp.this_residual, cmd->SCp.buffers_residual))\r\ntransfer_bytes(cmd, DATA_OUT_DIR);\r\nif (hostdata->state != S_RUNNING_LEVEL2)\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_COMMAND:\r\ncase CSR_UNEXP | PHS_COMMAND:\r\ncase CSR_SRV_REQ | PHS_COMMAND:\r\nDB(DB_INTR, printk("CMND-%02x", cmd->cmnd[0]))\r\ntransfer_pio(cmd->cmnd, cmd->cmd_len, DATA_OUT_DIR, hostdata);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_STATUS:\r\ncase CSR_UNEXP | PHS_STATUS:\r\ncase CSR_SRV_REQ | PHS_STATUS:\r\nDB(DB_INTR, printk("STATUS="))\r\ncmd->SCp.Status = read_1_byte(hostdata);\r\nDB(DB_INTR, printk("%02x", cmd->SCp.Status))\r\nif (hostdata->level2 >= L2_BASIC) {\r\nsr = read_3393(hostdata, WD_SCSI_STATUS);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\nwrite_3393(hostdata, WD_COMMAND_PHASE, 0x50);\r\nwrite_3393_cmd(hostdata, WD_CMD_SEL_ATN_XFER);\r\n} else {\r\nhostdata->state = S_CONNECTED;\r\n}\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_MESS_IN:\r\ncase CSR_UNEXP | PHS_MESS_IN:\r\ncase CSR_SRV_REQ | PHS_MESS_IN:\r\nDB(DB_INTR, printk("MSG_IN="))\r\nmsg = read_1_byte(hostdata);\r\nsr = read_3393(hostdata, WD_SCSI_STATUS);\r\nhostdata->incoming_msg[hostdata->incoming_ptr] = msg;\r\nif (hostdata->incoming_msg[0] == EXTENDED_MESSAGE)\r\nmsg = EXTENDED_MESSAGE;\r\nelse\r\nhostdata->incoming_ptr = 0;\r\ncmd->SCp.Message = msg;\r\nswitch (msg) {\r\ncase COMMAND_COMPLETE:\r\nDB(DB_INTR, printk("CCMP"))\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_PRE_CMP_DISC;\r\nbreak;\r\ncase SAVE_POINTERS:\r\nDB(DB_INTR, printk("SDP"))\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nDB(DB_INTR, printk("RDP"))\r\nif (hostdata->level2 >= L2_BASIC) {\r\nwrite_3393(hostdata, WD_COMMAND_PHASE, 0x45);\r\nwrite_3393_cmd(hostdata, WD_CMD_SEL_ATN_XFER);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\n} else {\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\n}\r\nbreak;\r\ncase DISCONNECT:\r\nDB(DB_INTR, printk("DIS"))\r\ncmd->device->disconnect = 1;\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_PRE_TMP_DISC;\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nDB(DB_INTR, printk("REJ"))\r\n#ifdef SYNC_DEBUG\r\nprintk("-REJ-");\r\n#endif\r\nif (hostdata->sync_stat[cmd->device->id] == SS_WAITING)\r\nhostdata->sync_stat[cmd->device->id] = SS_SET;\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nDB(DB_INTR, printk("EXT"))\r\nucp = hostdata->incoming_msg;\r\n#ifdef SYNC_DEBUG\r\nprintk("%02x", ucp[hostdata->incoming_ptr]);\r\n#endif\r\nif ((hostdata->incoming_ptr >= 2) && (hostdata->incoming_ptr == (ucp[1] + 1))) {\r\nswitch (ucp[2]) {\r\ncase EXTENDED_SDTR:\r\nid = calc_sync_xfer(ucp[3], ucp[4]);\r\nif (hostdata->sync_stat[cmd->device->id] != SS_WAITING) {\r\nwrite_3393_cmd(hostdata, WD_CMD_ASSERT_ATN);\r\nhostdata->outgoing_msg[0] = EXTENDED_MESSAGE;\r\nhostdata->outgoing_msg[1] = 3;\r\nhostdata->outgoing_msg[2] = EXTENDED_SDTR;\r\nhostdata->outgoing_msg[3] = hostdata->default_sx_per / 4;\r\nhostdata->outgoing_msg[4] = 0;\r\nhostdata->outgoing_len = 5;\r\nhostdata->sync_xfer[cmd->device->id] = calc_sync_xfer(hostdata->default_sx_per / 4, 0);\r\n} else {\r\nhostdata->sync_xfer[cmd->device->id] = id;\r\n}\r\n#ifdef SYNC_DEBUG\r\nprintk("sync_xfer=%02x", hostdata->sync_xfer[cmd->device->id]);\r\n#endif\r\nhostdata->sync_stat[cmd->device->id] = SS_SET;\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase EXTENDED_WDTR:\r\nwrite_3393_cmd(hostdata, WD_CMD_ASSERT_ATN);\r\nprintk("sending WDTR ");\r\nhostdata->outgoing_msg[0] = EXTENDED_MESSAGE;\r\nhostdata->outgoing_msg[1] = 2;\r\nhostdata->outgoing_msg[2] = EXTENDED_WDTR;\r\nhostdata->outgoing_msg[3] = 0;\r\nhostdata->outgoing_len = 4;\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ndefault:\r\nwrite_3393_cmd(hostdata, WD_CMD_ASSERT_ATN);\r\nprintk("Rejecting Unknown Extended Message(%02x). ", ucp[2]);\r\nhostdata->outgoing_msg[0] = MESSAGE_REJECT;\r\nhostdata->outgoing_len = 1;\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\n}\r\nhostdata->incoming_ptr = 0;\r\n}\r\nelse {\r\nhostdata->incoming_ptr++;\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("Rejecting Unknown Message(%02x) ", msg);\r\nwrite_3393_cmd(hostdata, WD_CMD_ASSERT_ATN);\r\nhostdata->outgoing_msg[0] = MESSAGE_REJECT;\r\nhostdata->outgoing_len = 1;\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\n}\r\nbreak;\r\ncase CSR_SEL_XFER_DONE:\r\nwrite_3393(hostdata, WD_SOURCE_ID, SRCID_ER);\r\nif (phs == 0x60) {\r\nDB(DB_INTR, printk("SX-DONE"))\r\ncmd->SCp.Message = COMMAND_COMPLETE;\r\nlun = read_3393(hostdata, WD_TARGET_LUN);\r\nDB(DB_INTR, printk(":%d.%d", cmd->SCp.Status, lun))\r\nhostdata->connected = NULL;\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\nhostdata->state = S_UNCONNECTED;\r\nif (cmd->SCp.Status == ILLEGAL_STATUS_BYTE)\r\ncmd->SCp.Status = lun;\r\nif (cmd->cmnd[0] == REQUEST_SENSE && cmd->SCp.Status != GOOD)\r\ncmd->result = (cmd->result & 0x00ffff) | (DID_ERROR << 16);\r\nelse\r\ncmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8);\r\ncmd->scsi_done(cmd);\r\nin2000_execute(instance);\r\n} else {\r\nprintk("%02x:%02x:%02x: Unknown SEL_XFER_DONE phase!!---", asr, sr, phs);\r\n}\r\nbreak;\r\ncase CSR_SDP:\r\nDB(DB_INTR, printk("SDP"))\r\nhostdata->state = S_RUNNING_LEVEL2;\r\nwrite_3393(hostdata, WD_COMMAND_PHASE, 0x41);\r\nwrite_3393_cmd(hostdata, WD_CMD_SEL_ATN_XFER);\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_MESS_OUT:\r\ncase CSR_UNEXP | PHS_MESS_OUT:\r\ncase CSR_SRV_REQ | PHS_MESS_OUT:\r\nDB(DB_INTR, printk("MSG_OUT="))\r\nif (hostdata->outgoing_len == 0) {\r\nhostdata->outgoing_len = 1;\r\nhostdata->outgoing_msg[0] = NOP;\r\n}\r\ntransfer_pio(hostdata->outgoing_msg, hostdata->outgoing_len, DATA_OUT_DIR, hostdata);\r\nDB(DB_INTR, printk("%02x", hostdata->outgoing_msg[0]))\r\nhostdata->outgoing_len = 0;\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase CSR_UNEXP_DISC:\r\nwrite_3393(hostdata, WD_SOURCE_ID, SRCID_ER);\r\nif (cmd == NULL) {\r\nprintk(" - Already disconnected! ");\r\nhostdata->state = S_UNCONNECTED;\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nDB(DB_INTR, printk("UNEXP_DISC"))\r\nhostdata->connected = NULL;\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\nhostdata->state = S_UNCONNECTED;\r\nif (cmd->cmnd[0] == REQUEST_SENSE && cmd->SCp.Status != GOOD)\r\ncmd->result = (cmd->result & 0x00ffff) | (DID_ERROR << 16);\r\nelse\r\ncmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8);\r\ncmd->scsi_done(cmd);\r\nin2000_execute(instance);\r\nbreak;\r\ncase CSR_DISC:\r\nwrite_3393(hostdata, WD_SOURCE_ID, SRCID_ER);\r\nDB(DB_INTR, printk("DISC"))\r\nif (cmd == NULL) {\r\nprintk(" - Already disconnected! ");\r\nhostdata->state = S_UNCONNECTED;\r\n}\r\nswitch (hostdata->state) {\r\ncase S_PRE_CMP_DISC:\r\nhostdata->connected = NULL;\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\nhostdata->state = S_UNCONNECTED;\r\nDB(DB_INTR, printk(":%d", cmd->SCp.Status))\r\nif (cmd->cmnd[0] == REQUEST_SENSE && cmd->SCp.Status != GOOD)\r\ncmd->result = (cmd->result & 0x00ffff) | (DID_ERROR << 16);\r\nelse\r\ncmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8);\r\ncmd->scsi_done(cmd);\r\nbreak;\r\ncase S_PRE_TMP_DISC:\r\ncase S_RUNNING_LEVEL2:\r\ncmd->host_scribble = (uchar *) hostdata->disconnected_Q;\r\nhostdata->disconnected_Q = cmd;\r\nhostdata->connected = NULL;\r\nhostdata->state = S_UNCONNECTED;\r\n#ifdef PROC_STATISTICS\r\nhostdata->disc_done_cnt[cmd->device->id]++;\r\n#endif\r\nbreak;\r\ndefault:\r\nprintk("*** Unexpected DISCONNECT interrupt! ***");\r\nhostdata->state = S_UNCONNECTED;\r\n}\r\nin2000_execute(instance);\r\nbreak;\r\ncase CSR_RESEL_AM:\r\nDB(DB_INTR, printk("RESEL"))\r\nif (hostdata->level2 <= L2_NONE) {\r\nif (hostdata->selecting) {\r\ncmd = (Scsi_Cmnd *) hostdata->selecting;\r\nhostdata->selecting = NULL;\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\ncmd->host_scribble = (uchar *) hostdata->input_Q;\r\nhostdata->input_Q = cmd;\r\n}\r\n}\r\nelse {\r\nif (cmd) {\r\nif (phs == 0x00) {\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\ncmd->host_scribble = (uchar *) hostdata->input_Q;\r\nhostdata->input_Q = cmd;\r\n} else {\r\nprintk("---%02x:%02x:%02x-TROUBLE: Intrusive ReSelect!---", asr, sr, phs);\r\nwhile (1)\r\nprintk("\r");\r\n}\r\n}\r\n}\r\nid = read_3393(hostdata, WD_SOURCE_ID);\r\nid &= SRCID_MASK;\r\nlun = read_3393(hostdata, WD_DATA);\r\nif (hostdata->level2 < L2_RESELECT)\r\nwrite_3393_cmd(hostdata, WD_CMD_NEGATE_ACK);\r\nlun &= 7;\r\ncmd = (Scsi_Cmnd *) hostdata->disconnected_Q;\r\npatch = NULL;\r\nwhile (cmd) {\r\nif (id == cmd->device->id && lun == cmd->device->lun)\r\nbreak;\r\npatch = cmd;\r\ncmd = (Scsi_Cmnd *) cmd->host_scribble;\r\n}\r\nif (!cmd) {\r\nprintk("---TROUBLE: target %d.%d not in disconnect queue---", id, lun);\r\nbreak;\r\n}\r\nif (patch)\r\npatch->host_scribble = cmd->host_scribble;\r\nelse\r\nhostdata->disconnected_Q = (Scsi_Cmnd *) cmd->host_scribble;\r\nhostdata->connected = cmd;\r\nif (is_dir_out(cmd))\r\nwrite_3393(hostdata, WD_DESTINATION_ID, cmd->device->id);\r\nelse\r\nwrite_3393(hostdata, WD_DESTINATION_ID, cmd->device->id | DSTID_DPD);\r\nif (hostdata->level2 >= L2_RESELECT) {\r\nwrite_3393_count(hostdata, 0);\r\nwrite_3393(hostdata, WD_COMMAND_PHASE, 0x45);\r\nwrite_3393_cmd(hostdata, WD_CMD_SEL_ATN_XFER);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\n} else\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ndefault:\r\nprintk("--UNKNOWN INTERRUPT:%02x:%02x:%02x--", asr, sr, phs);\r\n}\r\nwrite1_io(0, IO_LED_OFF);\r\nDB(DB_INTR, printk("} "))\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int reset_hardware(struct Scsi_Host *instance, int type)\r\n{\r\nstruct IN2000_hostdata *hostdata;\r\nint qt, x;\r\nhostdata = (struct IN2000_hostdata *) instance->hostdata;\r\nwrite1_io(0, IO_LED_ON);\r\nif (type == RESET_CARD_AND_BUS) {\r\nwrite1_io(0, IO_CARD_RESET);\r\nx = read1_io(IO_HARDWARE);\r\n}\r\nx = read_3393(hostdata, WD_SCSI_STATUS);\r\nwrite_3393(hostdata, WD_OWN_ID, instance->this_id | OWNID_EAF | OWNID_RAF | OWNID_FS_8);\r\nwrite_3393(hostdata, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite_3393(hostdata, WD_SYNCHRONOUS_TRANSFER, calc_sync_xfer(hostdata->default_sx_per / 4, DEFAULT_SX_OFF));\r\nwrite1_io(0, IO_FIFO_WRITE);\r\nwrite1_io(0, IO_FIFO_READ);\r\nwrite_3393(hostdata, WD_COMMAND, WD_CMD_RESET);\r\nwhile (!(READ_AUX_STAT() & ASR_INT))\r\ncpu_relax();\r\nx = read_3393(hostdata, WD_SCSI_STATUS);\r\nwrite_3393(hostdata, WD_QUEUE_TAG, 0xa5);\r\nqt = read_3393(hostdata, WD_QUEUE_TAG);\r\nif (qt == 0xa5) {\r\nx |= B_FLAG;\r\nwrite_3393(hostdata, WD_QUEUE_TAG, 0);\r\n}\r\nwrite_3393(hostdata, WD_TIMEOUT_PERIOD, TIMEOUT_PERIOD_VALUE);\r\nwrite_3393(hostdata, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite1_io(0, IO_LED_OFF);\r\nreturn x;\r\n}\r\nstatic int in2000_bus_reset(Scsi_Cmnd * cmd)\r\n{\r\nstruct Scsi_Host *instance;\r\nstruct IN2000_hostdata *hostdata;\r\nint x;\r\nunsigned long flags;\r\ninstance = cmd->device->host;\r\nhostdata = (struct IN2000_hostdata *) instance->hostdata;\r\nprintk(KERN_WARNING "scsi%d: Reset. ", instance->host_no);\r\nspin_lock_irqsave(instance->host_lock, flags);\r\nreset_hardware(instance, RESET_CARD_AND_BUS);\r\nfor (x = 0; x < 8; x++) {\r\nhostdata->busy[x] = 0;\r\nhostdata->sync_xfer[x] = calc_sync_xfer(DEFAULT_SX_PER / 4, DEFAULT_SX_OFF);\r\nhostdata->sync_stat[x] = SS_UNSET;\r\n}\r\nhostdata->input_Q = NULL;\r\nhostdata->selecting = NULL;\r\nhostdata->connected = NULL;\r\nhostdata->disconnected_Q = NULL;\r\nhostdata->state = S_UNCONNECTED;\r\nhostdata->fifo = FI_FIFO_UNUSED;\r\nhostdata->incoming_ptr = 0;\r\nhostdata->outgoing_len = 0;\r\ncmd->result = DID_RESET << 16;\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int __in2000_abort(Scsi_Cmnd * cmd)\r\n{\r\nstruct Scsi_Host *instance;\r\nstruct IN2000_hostdata *hostdata;\r\nScsi_Cmnd *tmp, *prev;\r\nuchar sr, asr;\r\nunsigned long timeout;\r\ninstance = cmd->device->host;\r\nhostdata = (struct IN2000_hostdata *) instance->hostdata;\r\nprintk(KERN_DEBUG "scsi%d: Abort-", instance->host_no);\r\nprintk("(asr=%02x,count=%ld,resid=%d,buf_resid=%d,have_data=%d,FC=%02x)- ", READ_AUX_STAT(), read_3393_count(hostdata), cmd->SCp.this_residual, cmd->SCp.buffers_residual, cmd->SCp.have_data_in, read1_io(IO_FIFO_COUNT));\r\ntmp = (Scsi_Cmnd *) hostdata->input_Q;\r\nprev = NULL;\r\nwhile (tmp) {\r\nif (tmp == cmd) {\r\nif (prev)\r\nprev->host_scribble = cmd->host_scribble;\r\ncmd->host_scribble = NULL;\r\ncmd->result = DID_ABORT << 16;\r\nprintk(KERN_WARNING "scsi%d: Abort - removing command from input_Q. ", instance->host_no);\r\ncmd->scsi_done(cmd);\r\nreturn SUCCESS;\r\n}\r\nprev = tmp;\r\ntmp = (Scsi_Cmnd *) tmp->host_scribble;\r\n}\r\nif (hostdata->connected == cmd) {\r\nprintk(KERN_WARNING "scsi%d: Aborting connected command - ", instance->host_no);\r\nprintk("sending wd33c93 ABORT command - ");\r\nwrite_3393(hostdata, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite_3393_cmd(hostdata, WD_CMD_ABORT);\r\nprintk("flushing fifo - ");\r\ntimeout = 1000000;\r\ndo {\r\nasr = READ_AUX_STAT();\r\nif (asr & ASR_DBR)\r\nread_3393(hostdata, WD_DATA);\r\n} while (!(asr & ASR_INT) && timeout-- > 0);\r\nsr = read_3393(hostdata, WD_SCSI_STATUS);\r\nprintk("asr=%02x, sr=%02x, %ld bytes un-transferred (timeout=%ld) - ", asr, sr, read_3393_count(hostdata), timeout);\r\nprintk("sending wd33c93 DISCONNECT command - ");\r\nwrite_3393_cmd(hostdata, WD_CMD_DISCONNECT);\r\ntimeout = 1000000;\r\nasr = READ_AUX_STAT();\r\nwhile ((asr & ASR_CIP) && timeout-- > 0)\r\nasr = READ_AUX_STAT();\r\nsr = read_3393(hostdata, WD_SCSI_STATUS);\r\nprintk("asr=%02x, sr=%02x.", asr, sr);\r\nhostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);\r\nhostdata->connected = NULL;\r\nhostdata->state = S_UNCONNECTED;\r\ncmd->result = DID_ABORT << 16;\r\ncmd->scsi_done(cmd);\r\nin2000_execute(instance);\r\nreturn SUCCESS;\r\n}\r\nfor (tmp = (Scsi_Cmnd *) hostdata->disconnected_Q; tmp; tmp = (Scsi_Cmnd *) tmp->host_scribble)\r\nif (cmd == tmp) {\r\nprintk(KERN_DEBUG "scsi%d: unable to abort disconnected command.\n", instance->host_no);\r\nreturn FAILED;\r\n}\r\nin2000_execute(instance);\r\nprintk("scsi%d: warning : SCSI command probably completed successfully" " before abortion. ", instance->host_no);\r\nreturn SUCCESS;\r\n}\r\nstatic int in2000_abort(Scsi_Cmnd * cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = __in2000_abort(cmd);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic void __init in2000_setup(char *str, int *ints)\r\n{\r\nint i;\r\nchar *p1, *p2;\r\nstrlcpy(setup_buffer, str, SETUP_BUFFER_SIZE);\r\np1 = setup_buffer;\r\ni = 0;\r\nwhile (*p1 && (i < MAX_SETUP_ARGS)) {\r\np2 = strchr(p1, ',');\r\nif (p2) {\r\n*p2 = '\0';\r\nif (p1 != p2)\r\nsetup_args[i] = p1;\r\np1 = p2 + 1;\r\ni++;\r\n} else {\r\nsetup_args[i] = p1;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < MAX_SETUP_ARGS; i++)\r\nsetup_used[i] = 0;\r\ndone_setup = 1;\r\n}\r\nstatic int __init check_setup_args(char *key, int *val, char *buf)\r\n{\r\nint x;\r\nchar *cp;\r\nfor (x = 0; x < MAX_SETUP_ARGS; x++) {\r\nif (setup_used[x])\r\ncontinue;\r\nif (!strncmp(setup_args[x], key, strlen(key)))\r\nbreak;\r\n}\r\nif (x == MAX_SETUP_ARGS)\r\nreturn 0;\r\nsetup_used[x] = 1;\r\ncp = setup_args[x] + strlen(key);\r\n*val = -1;\r\nif (*cp != ':')\r\nreturn ++x;\r\ncp++;\r\nif ((*cp >= '0') && (*cp <= '9')) {\r\n*val = simple_strtoul(cp, NULL, 0);\r\n}\r\nreturn ++x;\r\n}\r\nstatic int probe_bios(u32 addr, u32 *s1, uchar *switches)\r\n{\r\nvoid __iomem *p = ioremap(addr, 0x34);\r\nif (!p)\r\nreturn 0;\r\n*s1 = readl(p + 0x10);\r\nif (*s1 == 0x41564f4e || readl(p + 0x30) == 0x61776c41) {\r\n*switches = ~readb(p + 0x20);\r\niounmap(p);\r\nreturn 1;\r\n}\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic int __init in2000_detect(struct scsi_host_template * tpnt)\r\n{\r\nstruct Scsi_Host *instance;\r\nstruct IN2000_hostdata *hostdata;\r\nint detect_count;\r\nint bios;\r\nint x;\r\nunsigned short base;\r\nuchar switches;\r\nuchar hrev;\r\nunsigned long flags;\r\nint val;\r\nchar buf[32];\r\nif (!done_setup && setup_strings)\r\nin2000_setup(setup_strings, NULL);\r\ndetect_count = 0;\r\nfor (bios = 0; bios_tab[bios]; bios++) {\r\nu32 s1 = 0;\r\nif (check_setup_args("ioport", &val, buf)) {\r\nbase = val;\r\nswitches = ~inb(base + IO_SWITCHES) & 0xff;\r\nprintk("Forcing IN2000 detection at IOport 0x%x ", base);\r\nbios = 2;\r\n}\r\nelse if (probe_bios(bios_tab[bios], &s1, &switches)) {\r\nprintk("Found IN2000 BIOS at 0x%x ", (unsigned int) bios_tab[bios]);\r\nx = switches & (SW_ADDR0 | SW_ADDR1);\r\nbase = base_tab[x];\r\nx = ~inb(base + IO_SWITCHES) & 0xff;\r\nif (x != switches) {\r\nprintk("Bad IO signature: %02x vs %02x.\n", x, switches);\r\ncontinue;\r\n}\r\n} else\r\ncontinue;\r\nif (!(switches & SW_BIT7)) {\r\nprintk("There is no IN-2000 SCSI card at IOport 0x%03x!\n", base);\r\ncontinue;\r\n}\r\nhrev = inb(base + IO_HARDWARE);\r\nif (switches & SW_DISINT) {\r\nprintk("The IN-2000 SCSI card at IOport 0x%03x ", base);\r\nprintk("is not configured for interrupt operation!\n");\r\nprintk("This driver requires an interrupt: cancelling detection.\n");\r\ncontinue;\r\n}\r\ntpnt->proc_name = "in2000";\r\ninstance = scsi_register(tpnt, sizeof(struct IN2000_hostdata));\r\nif (instance == NULL)\r\ncontinue;\r\ndetect_count++;\r\nhostdata = (struct IN2000_hostdata *) instance->hostdata;\r\ninstance->io_port = hostdata->io_base = base;\r\nhostdata->dip_switch = switches;\r\nhostdata->hrev = hrev;\r\nwrite1_io(0, IO_FIFO_WRITE);\r\nwrite1_io(0, IO_FIFO_READ);\r\nwrite1_io(0, IO_INTR_MASK);\r\nx = int_tab[(switches & (SW_INT0 | SW_INT1)) >> SW_INT_SHIFT];\r\nif (request_irq(x, in2000_intr, 0, "in2000", instance)) {\r\nprintk("in2000_detect: Unable to allocate IRQ.\n");\r\ndetect_count--;\r\ncontinue;\r\n}\r\ninstance->irq = x;\r\ninstance->n_io_port = 13;\r\nrequest_region(base, 13, "in2000");\r\nfor (x = 0; x < 8; x++) {\r\nhostdata->busy[x] = 0;\r\nhostdata->sync_xfer[x] = calc_sync_xfer(DEFAULT_SX_PER / 4, DEFAULT_SX_OFF);\r\nhostdata->sync_stat[x] = SS_UNSET;\r\n#ifdef PROC_STATISTICS\r\nhostdata->cmd_cnt[x] = 0;\r\nhostdata->disc_allowed_cnt[x] = 0;\r\nhostdata->disc_done_cnt[x] = 0;\r\n#endif\r\n}\r\nhostdata->input_Q = NULL;\r\nhostdata->selecting = NULL;\r\nhostdata->connected = NULL;\r\nhostdata->disconnected_Q = NULL;\r\nhostdata->state = S_UNCONNECTED;\r\nhostdata->fifo = FI_FIFO_UNUSED;\r\nhostdata->level2 = L2_BASIC;\r\nhostdata->disconnect = DIS_ADAPTIVE;\r\nhostdata->args = DEBUG_DEFAULTS;\r\nhostdata->incoming_ptr = 0;\r\nhostdata->outgoing_len = 0;\r\nhostdata->default_sx_per = DEFAULT_SX_PER;\r\nif (s1 == 0x41564f4e && (switches & SW_SYNC_DOS5))\r\nhostdata->sync_off = 0x00;\r\nelse\r\nhostdata->sync_off = 0xff;\r\n#ifdef PROC_INTERFACE\r\nhostdata->proc = PR_VERSION | PR_INFO | PR_STATISTICS | PR_CONNECTED | PR_INPUTQ | PR_DISCQ | PR_STOP;\r\n#ifdef PROC_STATISTICS\r\nhostdata->int_cnt = 0;\r\n#endif\r\n#endif\r\nif (check_setup_args("nosync", &val, buf))\r\nhostdata->sync_off = val;\r\nif (check_setup_args("period", &val, buf))\r\nhostdata->default_sx_per = sx_table[round_period((unsigned int) val)].period_ns;\r\nif (check_setup_args("disconnect", &val, buf)) {\r\nif ((val >= DIS_NEVER) && (val <= DIS_ALWAYS))\r\nhostdata->disconnect = val;\r\nelse\r\nhostdata->disconnect = DIS_ADAPTIVE;\r\n}\r\nif (check_setup_args("noreset", &val, buf))\r\nhostdata->args ^= A_NO_SCSI_RESET;\r\nif (check_setup_args("level2", &val, buf))\r\nhostdata->level2 = val;\r\nif (check_setup_args("debug", &val, buf))\r\nhostdata->args = (val & DB_MASK);\r\n#ifdef PROC_INTERFACE\r\nif (check_setup_args("proc", &val, buf))\r\nhostdata->proc = val;\r\n#endif\r\nspin_lock_irqsave(instance->host_lock, flags);\r\nx = reset_hardware(instance, (hostdata->args & A_NO_SCSI_RESET) ? RESET_CARD : RESET_CARD_AND_BUS);\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nhostdata->microcode = read_3393(hostdata, WD_CDB_1);\r\nif (x & 0x01) {\r\nif (x & B_FLAG)\r\nhostdata->chip = C_WD33C93B;\r\nelse\r\nhostdata->chip = C_WD33C93A;\r\n} else\r\nhostdata->chip = C_WD33C93;\r\nprintk("dip_switch=%02x irq=%d ioport=%02x floppy=%s sync/DOS5=%s ", (switches & 0x7f), instance->irq, hostdata->io_base, (switches & SW_FLOPPY) ? "Yes" : "No", (switches & SW_SYNC_DOS5) ? "Yes" : "No");\r\nprintk("hardware_ver=%02x chip=%s microcode=%02x\n", hrev, (hostdata->chip == C_WD33C93) ? "WD33c93" : (hostdata->chip == C_WD33C93A) ? "WD33c93A" : (hostdata->chip == C_WD33C93B) ? "WD33c93B" : "unknown", hostdata->microcode);\r\n#ifdef DEBUGGING_ON\r\nprintk("setup_args = ");\r\nfor (x = 0; x < MAX_SETUP_ARGS; x++)\r\nprintk("%s,", setup_args[x]);\r\nprintk("\n");\r\n#endif\r\nif (hostdata->sync_off == 0xff)\r\nprintk("Sync-transfer DISABLED on all devices: ENABLE from command-line\n");\r\nprintk("IN2000 driver version %s - %s\n", IN2000_VERSION, IN2000_DATE);\r\n}\r\nreturn detect_count;\r\n}\r\nstatic int in2000_release(struct Scsi_Host *shost)\r\n{\r\nif (shost->irq)\r\nfree_irq(shost->irq, shost);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nreturn 0;\r\n}\r\nstatic int in2000_biosparam(struct scsi_device *sdev, struct block_device *bdev, sector_t capacity, int *iinfo)\r\n{\r\nint size;\r\nsize = capacity;\r\niinfo[0] = 64;\r\niinfo[1] = 32;\r\niinfo[2] = size >> 11;\r\nif (iinfo[2] > 1024) {\r\niinfo[0] = 64;\r\niinfo[1] = 63;\r\niinfo[2] = (unsigned long) capacity / (iinfo[0] * iinfo[1]);\r\n}\r\nif (iinfo[2] > 1024) {\r\niinfo[0] = 128;\r\niinfo[1] = 63;\r\niinfo[2] = (unsigned long) capacity / (iinfo[0] * iinfo[1]);\r\n}\r\nif (iinfo[2] > 1024) {\r\niinfo[0] = 255;\r\niinfo[1] = 63;\r\niinfo[2] = (unsigned long) capacity / (iinfo[0] * iinfo[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int in2000_write_info(struct Scsi_Host *instance, char *buf, int len)\r\n{\r\n#ifdef PROC_INTERFACE\r\nchar *bp;\r\nstruct IN2000_hostdata *hd;\r\nint x, i;\r\nhd = (struct IN2000_hostdata *) instance->hostdata;\r\nbuf[len] = '\0';\r\nbp = buf;\r\nif (!strncmp(bp, "debug:", 6)) {\r\nbp += 6;\r\nhd->args = simple_strtoul(bp, NULL, 0) & DB_MASK;\r\n} else if (!strncmp(bp, "disconnect:", 11)) {\r\nbp += 11;\r\nx = simple_strtoul(bp, NULL, 0);\r\nif (x < DIS_NEVER || x > DIS_ALWAYS)\r\nx = DIS_ADAPTIVE;\r\nhd->disconnect = x;\r\n} else if (!strncmp(bp, "period:", 7)) {\r\nbp += 7;\r\nx = simple_strtoul(bp, NULL, 0);\r\nhd->default_sx_per = sx_table[round_period((unsigned int) x)].period_ns;\r\n} else if (!strncmp(bp, "resync:", 7)) {\r\nbp += 7;\r\nx = simple_strtoul(bp, NULL, 0);\r\nfor (i = 0; i < 7; i++)\r\nif (x & (1 << i))\r\nhd->sync_stat[i] = SS_UNSET;\r\n} else if (!strncmp(bp, "proc:", 5)) {\r\nbp += 5;\r\nhd->proc = simple_strtoul(bp, NULL, 0);\r\n} else if (!strncmp(bp, "level2:", 7)) {\r\nbp += 7;\r\nhd->level2 = simple_strtoul(bp, NULL, 0);\r\n}\r\n#endif\r\nreturn len;\r\n}\r\nstatic int in2000_show_info(struct seq_file *m, struct Scsi_Host *instance)\r\n{\r\n#ifdef PROC_INTERFACE\r\nunsigned long flags;\r\nstruct IN2000_hostdata *hd;\r\nScsi_Cmnd *cmd;\r\nint x;\r\nhd = (struct IN2000_hostdata *) instance->hostdata;\r\nspin_lock_irqsave(instance->host_lock, flags);\r\nif (hd->proc & PR_VERSION)\r\nseq_printf(m, "\nVersion %s - %s.", IN2000_VERSION, IN2000_DATE);\r\nif (hd->proc & PR_INFO) {\r\nseq_printf(m, "\ndip_switch=%02x: irq=%d io=%02x floppy=%s sync/DOS5=%s", (hd->dip_switch & 0x7f), instance->irq, hd->io_base, (hd->dip_switch & 0x40) ? "Yes" : "No", (hd->dip_switch & 0x20) ? "Yes" : "No");\r\nseq_printf(m, "\nsync_xfer[] = ");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%02x", hd->sync_xfer[x]);\r\nseq_printf(m, "\nsync_stat[] = ");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%02x", hd->sync_stat[x]);\r\n}\r\n#ifdef PROC_STATISTICS\r\nif (hd->proc & PR_STATISTICS) {\r\nseq_printf(m, "\ncommands issued: ");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%ld", hd->cmd_cnt[x]);\r\nseq_printf(m, "\ndisconnects allowed:");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%ld", hd->disc_allowed_cnt[x]);\r\nseq_printf(m, "\ndisconnects done: ");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%ld", hd->disc_done_cnt[x]);\r\nseq_printf(m, "\ninterrupts: \t%ld", hd->int_cnt);\r\n}\r\n#endif\r\nif (hd->proc & PR_CONNECTED) {\r\nseq_printf(m, "\nconnected: ");\r\nif (hd->connected) {\r\ncmd = (Scsi_Cmnd *) hd->connected;\r\nseq_printf(m, " %d:%llu(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);\r\n}\r\n}\r\nif (hd->proc & PR_INPUTQ) {\r\nseq_printf(m, "\ninput_Q: ");\r\ncmd = (Scsi_Cmnd *) hd->input_Q;\r\nwhile (cmd) {\r\nseq_printf(m, " %d:%llu(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);\r\ncmd = (Scsi_Cmnd *) cmd->host_scribble;\r\n}\r\n}\r\nif (hd->proc & PR_DISCQ) {\r\nseq_printf(m, "\ndisconnected_Q:");\r\ncmd = (Scsi_Cmnd *) hd->disconnected_Q;\r\nwhile (cmd) {\r\nseq_printf(m, " %d:%llu(%02x)", cmd->device->id, cmd->device->lun, cmd->cmnd[0]);\r\ncmd = (Scsi_Cmnd *) cmd->host_scribble;\r\n}\r\n}\r\nif (hd->proc & PR_TEST) {\r\n;\r\n}\r\nseq_printf(m, "\n");\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\n#endif\r\nreturn 0;\r\n}
