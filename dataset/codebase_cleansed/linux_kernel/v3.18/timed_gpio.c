static enum hrtimer_restart gpio_timer_func(struct hrtimer *timer)\r\n{\r\nstruct timed_gpio_data *data =\r\ncontainer_of(timer, struct timed_gpio_data, timer);\r\ngpio_direction_output(data->gpio, data->active_low ? 1 : 0);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int gpio_get_time(struct timed_output_dev *dev)\r\n{\r\nstruct timed_gpio_data *data;\r\nstruct timeval t;\r\ndata = container_of(dev, struct timed_gpio_data, dev);\r\nif (!hrtimer_active(&data->timer))\r\nreturn 0;\r\nt = ktime_to_timeval(hrtimer_get_remaining(&data->timer));\r\nreturn t.tv_sec * 1000 + t.tv_usec / 1000;\r\n}\r\nstatic void gpio_enable(struct timed_output_dev *dev, int value)\r\n{\r\nstruct timed_gpio_data *data =\r\ncontainer_of(dev, struct timed_gpio_data, dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhrtimer_cancel(&data->timer);\r\ngpio_direction_output(data->gpio, data->active_low ? !value : !!value);\r\nif (value > 0) {\r\nif (value > data->max_timeout)\r\nvalue = data->max_timeout;\r\nhrtimer_start(&data->timer,\r\nktime_set(value / 1000, (value % 1000) * 1000000),\r\nHRTIMER_MODE_REL);\r\n}\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\nstatic int timed_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct timed_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nstruct timed_gpio *cur_gpio;\r\nstruct timed_gpio_data *gpio_data, *gpio_dat;\r\nint i, ret;\r\nif (!pdata)\r\nreturn -EBUSY;\r\ngpio_data = devm_kzalloc(&pdev->dev,\r\nsizeof(struct timed_gpio_data) * pdata->num_gpios,\r\nGFP_KERNEL);\r\nif (!gpio_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pdata->num_gpios; i++) {\r\ncur_gpio = &pdata->gpios[i];\r\ngpio_dat = &gpio_data[i];\r\nhrtimer_init(&gpio_dat->timer, CLOCK_MONOTONIC,\r\nHRTIMER_MODE_REL);\r\ngpio_dat->timer.function = gpio_timer_func;\r\nspin_lock_init(&gpio_dat->lock);\r\ngpio_dat->dev.name = cur_gpio->name;\r\ngpio_dat->dev.get_time = gpio_get_time;\r\ngpio_dat->dev.enable = gpio_enable;\r\nret = gpio_request(cur_gpio->gpio, cur_gpio->name);\r\nif (ret < 0)\r\ngoto err_out;\r\nret = timed_output_dev_register(&gpio_dat->dev);\r\nif (ret < 0) {\r\ngpio_free(cur_gpio->gpio);\r\ngoto err_out;\r\n}\r\ngpio_dat->gpio = cur_gpio->gpio;\r\ngpio_dat->max_timeout = cur_gpio->max_timeout;\r\ngpio_dat->active_low = cur_gpio->active_low;\r\ngpio_direction_output(gpio_dat->gpio, gpio_dat->active_low);\r\n}\r\nplatform_set_drvdata(pdev, gpio_data);\r\nreturn 0;\r\nerr_out:\r\nwhile (--i >= 0) {\r\ntimed_output_dev_unregister(&gpio_data[i].dev);\r\ngpio_free(gpio_data[i].gpio);\r\n}\r\nreturn ret;\r\n}\r\nstatic int timed_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct timed_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nstruct timed_gpio_data *gpio_data = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < pdata->num_gpios; i++) {\r\ntimed_output_dev_unregister(&gpio_data[i].dev);\r\ngpio_free(gpio_data[i].gpio);\r\n}\r\nreturn 0;\r\n}
