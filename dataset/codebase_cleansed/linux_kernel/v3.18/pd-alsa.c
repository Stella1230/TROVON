static int snd_pd_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct poseidon *p = snd_pcm_substream_chip(substream);\r\nstruct poseidon_audio *pa = &p->audio;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (!p)\r\nreturn -ENODEV;\r\npa->users++;\r\npa->card_close = 0;\r\npa->capture_pcm_substream = substream;\r\nruntime->private_data = p;\r\nruntime->hw = snd_pd_hw_capture;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nusb_autopm_get_interface(p->interface);\r\nkref_get(&p->kref);\r\nreturn 0;\r\n}\r\nstatic int snd_pd_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct poseidon *p = snd_pcm_substream_chip(substream);\r\nstruct poseidon_audio *pa = &p->audio;\r\npa->users--;\r\npa->card_close = 1;\r\nusb_autopm_put_interface(p->interface);\r\nkref_put(&p->kref, poseidon_delete);\r\nreturn 0;\r\n}\r\nstatic int snd_pd_hw_capture_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int size;\r\nsize = params_buffer_bytes(hw_params);\r\nif (runtime->dma_area) {\r\nif (runtime->dma_bytes > size)\r\nreturn 0;\r\nvfree(runtime->dma_area);\r\n}\r\nruntime->dma_area = vmalloc(size);\r\nif (!runtime->dma_area)\r\nreturn -ENOMEM;\r\nelse\r\nruntime->dma_bytes = size;\r\nreturn 0;\r\n}\r\nstatic int audio_buf_free(struct poseidon *p)\r\n{\r\nstruct poseidon_audio *pa = &p->audio;\r\nint i;\r\nfor (i = 0; i < AUDIO_BUFS; i++)\r\nif (pa->urb_array[i])\r\nusb_kill_urb(pa->urb_array[i]);\r\nfree_all_urb_generic(pa->urb_array, AUDIO_BUFS);\r\nlogpm();\r\nreturn 0;\r\n}\r\nstatic int snd_pd_hw_capture_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct poseidon *p = snd_pcm_substream_chip(substream);\r\nlogpm();\r\naudio_buf_free(p);\r\nreturn 0;\r\n}\r\nstatic int snd_pd_prepare(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void handle_audio_data(struct urb *urb, int *period_elapsed)\r\n{\r\nstruct poseidon_audio *pa = urb->context;\r\nstruct snd_pcm_runtime *runtime = pa->capture_pcm_substream->runtime;\r\nint stride = runtime->frame_bits >> 3;\r\nint len = urb->actual_length / stride;\r\nunsigned char *cp = urb->transfer_buffer;\r\nunsigned int oldptr = pa->rcv_position;\r\nif (urb->actual_length == AUDIO_BUF_SIZE - 4)\r\nlen -= (AUDIO_TRAILER_SIZE / stride);\r\nif (oldptr + len >= runtime->buffer_size) {\r\nunsigned int cnt = runtime->buffer_size - oldptr;\r\nmemcpy(runtime->dma_area + oldptr * stride, cp, cnt * stride);\r\nmemcpy(runtime->dma_area, (cp + cnt * stride),\r\n(len * stride - cnt * stride));\r\n} else\r\nmemcpy(runtime->dma_area + oldptr * stride, cp, len * stride);\r\nsnd_pcm_stream_lock(pa->capture_pcm_substream);\r\npa->rcv_position += len;\r\nif (pa->rcv_position >= runtime->buffer_size)\r\npa->rcv_position -= runtime->buffer_size;\r\npa->copied_position += (len);\r\nif (pa->copied_position >= runtime->period_size) {\r\npa->copied_position -= runtime->period_size;\r\n*period_elapsed = 1;\r\n}\r\nsnd_pcm_stream_unlock(pa->capture_pcm_substream);\r\n}\r\nstatic void complete_handler_audio(struct urb *urb)\r\n{\r\nstruct poseidon_audio *pa = urb->context;\r\nstruct snd_pcm_substream *substream = pa->capture_pcm_substream;\r\nint period_elapsed = 0;\r\nint ret;\r\nif (1 == pa->card_close || pa->capture_stream != STREAM_ON)\r\nreturn;\r\nif (urb->status != 0) {\r\nreturn;\r\n}\r\nif (substream) {\r\nif (urb->actual_length) {\r\nhandle_audio_data(urb, &period_elapsed);\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\n}\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0)\r\nlog("audio urb failed (errcod = %i)", ret);\r\nreturn;\r\n}\r\nstatic int fire_audio_urb(struct poseidon *p)\r\n{\r\nint i, ret = 0;\r\nstruct poseidon_audio *pa = &p->audio;\r\nalloc_bulk_urbs_generic(pa->urb_array, AUDIO_BUFS,\r\np->udev, AUDIO_EP,\r\nAUDIO_BUF_SIZE, GFP_ATOMIC,\r\ncomplete_handler_audio, pa);\r\nfor (i = 0; i < AUDIO_BUFS; i++) {\r\nret = usb_submit_urb(pa->urb_array[i], GFP_KERNEL);\r\nif (ret)\r\nlog("urb err : %d", ret);\r\n}\r\nlog();\r\nreturn ret;\r\n}\r\nstatic int snd_pd_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct poseidon *p = snd_pcm_substream_chip(substream);\r\nstruct poseidon_audio *pa = &p->audio;\r\nif (debug_mode)\r\nlog("cmd %d, audio stat : %d\n", cmd, pa->capture_stream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (pa->capture_stream == STREAM_ON)\r\nreturn 0;\r\npa->rcv_position = pa->copied_position = 0;\r\npa->capture_stream = STREAM_ON;\r\nif (in_hibernation(p))\r\nreturn 0;\r\nfire_audio_urb(p);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\npa->capture_stream = STREAM_SUSPEND;\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\npa->capture_stream = STREAM_OFF;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_pd_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct poseidon *p = snd_pcm_substream_chip(substream);\r\nstruct poseidon_audio *pa = &p->audio;\r\nreturn pa->rcv_position;\r\n}\r\nstatic struct page *snd_pcm_pd_get_page(struct snd_pcm_substream *subs,\r\nunsigned long offset)\r\n{\r\nvoid *pageptr = subs->runtime->dma_area + offset;\r\nreturn vmalloc_to_page(pageptr);\r\n}\r\nint pm_alsa_suspend(struct poseidon *p)\r\n{\r\nlogpm(p);\r\naudio_buf_free(p);\r\nreturn 0;\r\n}\r\nint pm_alsa_resume(struct poseidon *p)\r\n{\r\nlogpm(p);\r\nfire_audio_urb(p);\r\nreturn 0;\r\n}\r\nint poseidon_audio_init(struct poseidon *p)\r\n{\r\nstruct poseidon_audio *pa = &p->audio;\r\nstruct snd_card *card;\r\nstruct snd_pcm *pcm;\r\nint ret;\r\nret = snd_card_new(&p->interface->dev, -1, "Telegent",\r\nTHIS_MODULE, 0, &card);\r\nif (ret != 0)\r\nreturn ret;\r\nret = snd_pcm_new(card, "poseidon audio", 0, 0, 1, &pcm);\r\nif (ret < 0) {\r\nsnd_card_free(card);\r\nreturn ret;\r\n}\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pcm_capture_ops);\r\npcm->info_flags = 0;\r\npcm->private_data = p;\r\nstrcpy(pcm->name, "poseidon audio capture");\r\nstrcpy(card->driver, "ALSA driver");\r\nstrcpy(card->shortname, "poseidon Audio");\r\nstrcpy(card->longname, "poseidon ALSA Audio");\r\nif (snd_card_register(card)) {\r\nsnd_card_free(card);\r\nreturn -ENOMEM;\r\n}\r\npa->card = card;\r\nreturn 0;\r\n}\r\nint poseidon_audio_free(struct poseidon *p)\r\n{\r\nstruct poseidon_audio *pa = &p->audio;\r\nif (pa->card)\r\nsnd_card_free(pa->card);\r\nreturn 0;\r\n}
