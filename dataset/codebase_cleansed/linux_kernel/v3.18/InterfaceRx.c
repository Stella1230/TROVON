static void handle_control_packet(struct bcm_interface_adapter *interface,\r\nstruct bcm_mini_adapter *ad,\r\nstruct bcm_leader *leader,\r\nstruct sk_buff *skb,\r\nstruct urb *urb)\r\n{\r\nBCM_DEBUG_PRINT(interface->psAdapter, DBG_TYPE_RX, RX_CTRL, DBG_LVL_ALL,\r\n"Received control pkt...");\r\n*(PUSHORT)skb->data = leader->Status;\r\nmemcpy(skb->data+sizeof(USHORT), urb->transfer_buffer +\r\n(sizeof(struct bcm_leader)), leader->PLength);\r\nskb->len = leader->PLength + sizeof(USHORT);\r\nspin_lock(&ad->control_queue_lock);\r\nENQUEUEPACKET(ad->RxControlHead, ad->RxControlTail, skb);\r\nspin_unlock(&ad->control_queue_lock);\r\natomic_inc(&ad->cntrlpktCnt);\r\nwake_up(&ad->process_rx_cntrlpkt);\r\n}\r\nstatic void format_eth_hdr_to_stack(struct bcm_interface_adapter *interface,\r\nstruct bcm_mini_adapter *ad,\r\nstruct bcm_leader *p_leader,\r\nstruct sk_buff *skb,\r\nstruct urb *urb,\r\nUINT ui_index,\r\nint queue_index,\r\nbool b_header_supression_endabled)\r\n{\r\nBCM_DEBUG_PRINT(interface->psAdapter, DBG_TYPE_RX, RX_DATA,\r\nDBG_LVL_ALL, "Received Data pkt...");\r\nskb_reserve(skb, 2 + SKB_RESERVE_PHS_BYTES);\r\nmemcpy(skb->data+ETH_HLEN, (PUCHAR)urb->transfer_buffer +\r\nsizeof(struct bcm_leader), p_leader->PLength);\r\nskb->dev = ad->dev;\r\nskb_put(skb, p_leader->PLength + ETH_HLEN);\r\nad->PackInfo[queue_index].uiTotalRxBytes += p_leader->PLength;\r\nad->PackInfo[queue_index].uiThisPeriodRxBytes += p_leader->PLength;\r\nBCM_DEBUG_PRINT(interface->psAdapter, DBG_TYPE_RX, RX_DATA,\r\nDBG_LVL_ALL, "Received Data pkt of len :0x%X",\r\np_leader->PLength);\r\nif (netif_running(ad->dev)) {\r\nskb_pull(skb, ETH_HLEN);\r\nPHSReceive(ad, p_leader->Vcid, skb, &skb->len,\r\nNULL, b_header_supression_endabled);\r\nif (!ad->PackInfo[queue_index].bEthCSSupport) {\r\nskb_push(skb, ETH_HLEN);\r\nmemcpy(skb->data, skb->dev->dev_addr, 6);\r\nmemcpy(skb->data+6, skb->dev->dev_addr, 6);\r\n(*(skb->data+11))++;\r\n*(skb->data+12) = 0x08;\r\n*(skb->data+13) = 0x00;\r\np_leader->PLength += ETH_HLEN;\r\n}\r\nskb->protocol = eth_type_trans(skb, ad->dev);\r\nnetif_rx(skb);\r\n} else {\r\nBCM_DEBUG_PRINT(interface->psAdapter, DBG_TYPE_RX,\r\nRX_DATA, DBG_LVL_ALL,\r\n"i/f not up hance freeing SKB...");\r\ndev_kfree_skb(skb);\r\n}\r\n++ad->dev->stats.rx_packets;\r\nad->dev->stats.rx_bytes += p_leader->PLength;\r\nfor (ui_index = 0; ui_index < MIBS_MAX_HIST_ENTRIES; ui_index++) {\r\nif ((p_leader->PLength <=\r\nMIBS_PKTSIZEHIST_RANGE*(ui_index+1)) &&\r\n(p_leader->PLength > MIBS_PKTSIZEHIST_RANGE*(ui_index)))\r\nad->aRxPktSizeHist[ui_index]++;\r\n}\r\n}\r\nstatic int SearchVcid(struct bcm_mini_adapter *Adapter, unsigned short usVcid)\r\n{\r\nint iIndex = 0;\r\nfor (iIndex = (NO_OF_QUEUES-1); iIndex >= 0; iIndex--)\r\nif (Adapter->PackInfo[iIndex].usVCID_Value == usVcid)\r\nreturn iIndex;\r\nreturn NO_OF_QUEUES+1;\r\n}\r\nstatic struct bcm_usb_rcb *\r\nGetBulkInRcb(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nstruct bcm_usb_rcb *pRcb = NULL;\r\nUINT index = 0;\r\nif ((atomic_read(&psIntfAdapter->uNumRcbUsed) < MAXIMUM_USB_RCB) &&\r\n(psIntfAdapter->psAdapter->StopAllXaction == false)) {\r\nindex = atomic_read(&psIntfAdapter->uCurrRcb);\r\npRcb = &psIntfAdapter->asUsbRcb[index];\r\npRcb->bUsed = TRUE;\r\npRcb->psIntfAdapter = psIntfAdapter;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_RX, RX_DPC,\r\nDBG_LVL_ALL, "Got Rx desc %d used %d", index,\r\natomic_read(&psIntfAdapter->uNumRcbUsed));\r\nindex = (index + 1) % MAXIMUM_USB_RCB;\r\natomic_set(&psIntfAdapter->uCurrRcb, index);\r\natomic_inc(&psIntfAdapter->uNumRcbUsed);\r\n}\r\nreturn pRcb;\r\n}\r\nstatic void read_bulk_callback(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nbool bHeaderSupressionEnabled = false;\r\nint QueueIndex = NO_OF_QUEUES + 1;\r\nUINT uiIndex = 0;\r\nstruct bcm_usb_rcb *pRcb = (struct bcm_usb_rcb *)urb->context;\r\nstruct bcm_interface_adapter *psIntfAdapter = pRcb->psIntfAdapter;\r\nstruct bcm_mini_adapter *Adapter = psIntfAdapter->psAdapter;\r\nstruct bcm_leader *pLeader = urb->transfer_buffer;\r\nif (unlikely(netif_msg_rx_status(Adapter)))\r\npr_info(PFX "%s: rx urb status %d length %d\n",\r\nAdapter->dev->name, urb->status, urb->actual_length);\r\nif ((Adapter->device_removed == TRUE) ||\r\n(TRUE == Adapter->bEndPointHalted) ||\r\n(0 == urb->actual_length)) {\r\npRcb->bUsed = false;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nif (urb->status != STATUS_SUCCESS) {\r\nif (urb->status == -EPIPE) {\r\nAdapter->bEndPointHalted = TRUE;\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC,\r\nDBG_LVL_ALL,\r\n"Rx URB has got cancelled. status :%d",\r\nurb->status);\r\n}\r\npRcb->bUsed = false;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nurb->status = STATUS_SUCCESS;\r\nreturn;\r\n}\r\nif (Adapter->bDoSuspend && (Adapter->bPreparingForLowPowerMode)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL,\r\n"device is going in low power mode while PMU option selected..hence rx packet should not be process");\r\nreturn;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL,\r\n"Read back done len %d\n", pLeader->PLength);\r\nif (!pLeader->PLength) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL,\r\n"Leader Length 0");\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_RX, RX_DPC, DBG_LVL_ALL,\r\n"Leader Status:0x%hX, Length:0x%hX, VCID:0x%hX",\r\npLeader->Status, pLeader->PLength, pLeader->Vcid);\r\nif (MAX_CNTL_PKT_SIZE < pLeader->PLength) {\r\nif (netif_msg_rx_err(Adapter))\r\npr_info(PFX "%s: corrupted leader length...%d\n",\r\nAdapter->dev->name, pLeader->PLength);\r\n++Adapter->dev->stats.rx_dropped;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nQueueIndex = SearchVcid(Adapter, pLeader->Vcid);\r\nif (QueueIndex < NO_OF_QUEUES) {\r\nbHeaderSupressionEnabled =\r\nAdapter->PackInfo[QueueIndex].bHeaderSuppressionEnabled;\r\nbHeaderSupressionEnabled =\r\nbHeaderSupressionEnabled & Adapter->bPHSEnabled;\r\n}\r\nskb = dev_alloc_skb(pLeader->PLength + SKB_RESERVE_PHS_BYTES +\r\nSKB_RESERVE_ETHERNET_HEADER);\r\nif (!skb) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\r\n"NO SKBUFF!!! Dropping the Packet");\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\nreturn;\r\n}\r\nif ((ntohs(pLeader->Vcid) == VCID_CONTROL_PACKET) ||\r\n(!(pLeader->Status >= 0x20 && pLeader->Status <= 0x3F))) {\r\nhandle_control_packet(psIntfAdapter, Adapter, pLeader, skb,\r\nurb);\r\n} else {\r\nformat_eth_hdr_to_stack(psIntfAdapter, Adapter, pLeader, skb,\r\nurb, uiIndex, QueueIndex,\r\nbHeaderSupressionEnabled);\r\n}\r\nAdapter->PrevNumRecvDescs++;\r\npRcb->bUsed = false;\r\natomic_dec(&psIntfAdapter->uNumRcbUsed);\r\n}\r\nstatic int ReceiveRcb(struct bcm_interface_adapter *psIntfAdapter,\r\nstruct bcm_usb_rcb *pRcb)\r\n{\r\nstruct urb *urb = pRcb->urb;\r\nint retval = 0;\r\nusb_fill_bulk_urb(urb, psIntfAdapter->udev,\r\nusb_rcvbulkpipe(psIntfAdapter->udev,\r\npsIntfAdapter->sBulkIn.bulk_in_endpointAddr),\r\nurb->transfer_buffer,\r\nBCM_USB_MAX_READ_LENGTH,\r\nread_bulk_callback, pRcb);\r\nif (false == psIntfAdapter->psAdapter->device_removed &&\r\nfalse == psIntfAdapter->psAdapter->bEndPointHalted &&\r\nfalse == psIntfAdapter->bSuspended &&\r\nfalse == psIntfAdapter->bPreparingForBusSuspend) {\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_RX,\r\nRX_DPC, DBG_LVL_ALL,\r\n"failed submitting read urb, error %d",\r\nretval);\r\nif (retval == -EPIPE) {\r\npsIntfAdapter->psAdapter->bEndPointHalted = TRUE;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nbool InterfaceRx(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nUSHORT RxDescCount = NUM_RX_DESC -\r\natomic_read(&psIntfAdapter->uNumRcbUsed);\r\nstruct bcm_usb_rcb *pRcb = NULL;\r\nwhile (RxDescCount) {\r\npRcb = GetBulkInRcb(psIntfAdapter);\r\nif (pRcb == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_PRINTK, 0, 0,\r\n"Unable to get Rcb pointer");\r\nreturn false;\r\n}\r\nReceiveRcb(psIntfAdapter, pRcb);\r\nRxDescCount--;\r\n}\r\nreturn TRUE;\r\n}
