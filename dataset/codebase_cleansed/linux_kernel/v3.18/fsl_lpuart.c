static u32 lpuart32_read(void __iomem *addr)\r\n{\r\nreturn ioread32be(addr);\r\n}\r\nstatic void lpuart32_write(u32 val, void __iomem *addr)\r\n{\r\niowrite32be(val, addr);\r\n}\r\nstatic void lpuart_stop_tx(struct uart_port *port)\r\n{\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTCR2);\r\ntemp &= ~(UARTCR2_TIE | UARTCR2_TCIE);\r\nwriteb(temp, port->membase + UARTCR2);\r\n}\r\nstatic void lpuart32_stop_tx(struct uart_port *port)\r\n{\r\nunsigned long temp;\r\ntemp = lpuart32_read(port->membase + UARTCTRL);\r\ntemp &= ~(UARTCTRL_TIE | UARTCTRL_TCIE);\r\nlpuart32_write(temp, port->membase + UARTCTRL);\r\n}\r\nstatic void lpuart_stop_rx(struct uart_port *port)\r\n{\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTCR2);\r\nwriteb(temp & ~UARTCR2_RE, port->membase + UARTCR2);\r\n}\r\nstatic void lpuart32_stop_rx(struct uart_port *port)\r\n{\r\nunsigned long temp;\r\ntemp = lpuart32_read(port->membase + UARTCTRL);\r\nlpuart32_write(temp & ~UARTCTRL_RE, port->membase + UARTCTRL);\r\n}\r\nstatic void lpuart_copy_rx_to_tty(struct lpuart_port *sport,\r\nstruct tty_port *tty, int count)\r\n{\r\nint copied;\r\nsport->port.icount.rx += count;\r\nif (!tty) {\r\ndev_err(sport->port.dev, "No tty port\n");\r\nreturn;\r\n}\r\ndma_sync_single_for_cpu(sport->port.dev, sport->dma_rx_buf_bus,\r\nFSL_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);\r\ncopied = tty_insert_flip_string(tty,\r\n((unsigned char *)(sport->dma_rx_buf_virt)), count);\r\nif (copied != count) {\r\nWARN_ON(1);\r\ndev_err(sport->port.dev, "RxData copy to tty layer failed\n");\r\n}\r\ndma_sync_single_for_device(sport->port.dev, sport->dma_rx_buf_bus,\r\nFSL_UART_RX_DMA_BUFFER_SIZE, DMA_TO_DEVICE);\r\n}\r\nstatic void lpuart_pio_tx(struct lpuart_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwhile (!uart_circ_empty(xmit) &&\r\nreadb(sport->port.membase + UARTTCFIFO) < sport->txfifo_size) {\r\nwriteb(xmit->buf[xmit->tail], sport->port.membase + UARTDR);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (uart_circ_empty(xmit))\r\nwriteb(readb(sport->port.membase + UARTCR5) | UARTCR5_TDMAS,\r\nsport->port.membase + UARTCR5);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic int lpuart_dma_tx(struct lpuart_port *sport, unsigned long count)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\ndma_addr_t tx_bus_addr;\r\ndma_sync_single_for_device(sport->port.dev, sport->dma_tx_buf_bus,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\nsport->dma_tx_bytes = count & ~(sport->txfifo_size - 1);\r\ntx_bus_addr = sport->dma_tx_buf_bus + xmit->tail;\r\nsport->dma_tx_desc = dmaengine_prep_slave_single(sport->dma_tx_chan,\r\ntx_bus_addr, sport->dma_tx_bytes,\r\nDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\r\nif (!sport->dma_tx_desc) {\r\ndev_err(sport->port.dev, "Not able to get desc for tx\n");\r\nreturn -EIO;\r\n}\r\nsport->dma_tx_desc->callback = lpuart_dma_tx_complete;\r\nsport->dma_tx_desc->callback_param = sport;\r\nsport->dma_tx_in_progress = 1;\r\nsport->dma_tx_cookie = dmaengine_submit(sport->dma_tx_desc);\r\ndma_async_issue_pending(sport->dma_tx_chan);\r\nreturn 0;\r\n}\r\nstatic void lpuart_prepare_tx(struct lpuart_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long count = CIRC_CNT_TO_END(xmit->head,\r\nxmit->tail, UART_XMIT_SIZE);\r\nif (!count)\r\nreturn;\r\nif (count < sport->txfifo_size)\r\nwriteb(readb(sport->port.membase + UARTCR5) & ~UARTCR5_TDMAS,\r\nsport->port.membase + UARTCR5);\r\nelse {\r\nwriteb(readb(sport->port.membase + UARTCR5) | UARTCR5_TDMAS,\r\nsport->port.membase + UARTCR5);\r\nlpuart_dma_tx(sport, count);\r\n}\r\n}\r\nstatic void lpuart_dma_tx_complete(void *arg)\r\n{\r\nstruct lpuart_port *sport = arg;\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long flags;\r\nasync_tx_ack(sport->dma_tx_desc);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nxmit->tail = (xmit->tail + sport->dma_tx_bytes) & (UART_XMIT_SIZE - 1);\r\nsport->dma_tx_in_progress = 0;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nlpuart_prepare_tx(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic int lpuart_dma_rx(struct lpuart_port *sport)\r\n{\r\ndma_sync_single_for_device(sport->port.dev, sport->dma_rx_buf_bus,\r\nFSL_UART_RX_DMA_BUFFER_SIZE, DMA_TO_DEVICE);\r\nsport->dma_rx_desc = dmaengine_prep_slave_single(sport->dma_rx_chan,\r\nsport->dma_rx_buf_bus, FSL_UART_RX_DMA_BUFFER_SIZE,\r\nDMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);\r\nif (!sport->dma_rx_desc) {\r\ndev_err(sport->port.dev, "Not able to get desc for rx\n");\r\nreturn -EIO;\r\n}\r\nsport->dma_rx_desc->callback = lpuart_dma_rx_complete;\r\nsport->dma_rx_desc->callback_param = sport;\r\nsport->dma_rx_in_progress = 1;\r\nsport->dma_rx_cookie = dmaengine_submit(sport->dma_rx_desc);\r\ndma_async_issue_pending(sport->dma_rx_chan);\r\nreturn 0;\r\n}\r\nstatic void lpuart_dma_rx_complete(void *arg)\r\n{\r\nstruct lpuart_port *sport = arg;\r\nstruct tty_port *port = &sport->port.state->port;\r\nunsigned long flags;\r\nasync_tx_ack(sport->dma_rx_desc);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->dma_rx_in_progress = 0;\r\nlpuart_copy_rx_to_tty(sport, port, FSL_UART_RX_DMA_BUFFER_SIZE);\r\ntty_flip_buffer_push(port);\r\nlpuart_dma_rx(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic void lpuart_timer_func(unsigned long data)\r\n{\r\nstruct lpuart_port *sport = (struct lpuart_port *)data;\r\nstruct tty_port *port = &sport->port.state->port;\r\nstruct dma_tx_state state;\r\nunsigned long flags;\r\nunsigned char temp;\r\nint count;\r\ndel_timer(&sport->lpuart_timer);\r\ndmaengine_pause(sport->dma_rx_chan);\r\ndmaengine_tx_status(sport->dma_rx_chan, sport->dma_rx_cookie, &state);\r\ndmaengine_terminate_all(sport->dma_rx_chan);\r\ncount = FSL_UART_RX_DMA_BUFFER_SIZE - state.residue;\r\nasync_tx_ack(sport->dma_rx_desc);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->dma_rx_in_progress = 0;\r\nlpuart_copy_rx_to_tty(sport, port, count);\r\ntty_flip_buffer_push(port);\r\ntemp = readb(sport->port.membase + UARTCR5);\r\nwriteb(temp & ~UARTCR5_RDMAS, sport->port.membase + UARTCR5);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic inline void lpuart_prepare_rx(struct lpuart_port *sport)\r\n{\r\nunsigned long flags;\r\nunsigned char temp;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ninit_timer(&sport->lpuart_timer);\r\nsport->lpuart_timer.function = lpuart_timer_func;\r\nsport->lpuart_timer.data = (unsigned long)sport;\r\nsport->lpuart_timer.expires = jiffies + sport->dma_rx_timeout;\r\nadd_timer(&sport->lpuart_timer);\r\nlpuart_dma_rx(sport);\r\ntemp = readb(sport->port.membase + UARTCR5);\r\nwriteb(temp | UARTCR5_RDMAS, sport->port.membase + UARTCR5);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic inline void lpuart_transmit_buffer(struct lpuart_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nwhile (!uart_circ_empty(xmit) &&\r\n(readb(sport->port.membase + UARTTCFIFO) < sport->txfifo_size)) {\r\nwriteb(xmit->buf[xmit->tail], sport->port.membase + UARTDR);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (uart_circ_empty(xmit))\r\nlpuart_stop_tx(&sport->port);\r\n}\r\nstatic inline void lpuart32_transmit_buffer(struct lpuart_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long txcnt;\r\ntxcnt = lpuart32_read(sport->port.membase + UARTWATER);\r\ntxcnt = txcnt >> UARTWATER_TXCNT_OFF;\r\ntxcnt &= UARTWATER_COUNT_MASK;\r\nwhile (!uart_circ_empty(xmit) && (txcnt < sport->txfifo_size)) {\r\nlpuart32_write(xmit->buf[xmit->tail], sport->port.membase + UARTDATA);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\ntxcnt = lpuart32_read(sport->port.membase + UARTWATER);\r\ntxcnt = txcnt >> UARTWATER_TXCNT_OFF;\r\ntxcnt &= UARTWATER_COUNT_MASK;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (uart_circ_empty(xmit))\r\nlpuart32_stop_tx(&sport->port);\r\n}\r\nstatic void lpuart_start_tx(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port,\r\nstruct lpuart_port, port);\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTCR2);\r\nwriteb(temp | UARTCR2_TIE, port->membase + UARTCR2);\r\nif (sport->lpuart_dma_use) {\r\nif (!uart_circ_empty(xmit) && !sport->dma_tx_in_progress)\r\nlpuart_prepare_tx(sport);\r\n} else {\r\nif (readb(port->membase + UARTSR1) & UARTSR1_TDRE)\r\nlpuart_transmit_buffer(sport);\r\n}\r\n}\r\nstatic void lpuart32_start_tx(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nunsigned long temp;\r\ntemp = lpuart32_read(port->membase + UARTCTRL);\r\nlpuart32_write(temp | UARTCTRL_TIE, port->membase + UARTCTRL);\r\nif (lpuart32_read(port->membase + UARTSTAT) & UARTSTAT_TDRE)\r\nlpuart32_transmit_buffer(sport);\r\n}\r\nstatic irqreturn_t lpuart_txint(int irq, void *dev_id)\r\n{\r\nstruct lpuart_port *sport = dev_id;\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nif (sport->port.x_char) {\r\nif (sport->lpuart32)\r\nlpuart32_write(sport->port.x_char, sport->port.membase + UARTDATA);\r\nelse\r\nwriteb(sport->port.x_char, sport->port.membase + UARTDR);\r\ngoto out;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {\r\nif (sport->lpuart32)\r\nlpuart32_stop_tx(&sport->port);\r\nelse\r\nlpuart_stop_tx(&sport->port);\r\ngoto out;\r\n}\r\nif (sport->lpuart32)\r\nlpuart32_transmit_buffer(sport);\r\nelse\r\nlpuart_transmit_buffer(sport);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lpuart_rxint(int irq, void *dev_id)\r\n{\r\nstruct lpuart_port *sport = dev_id;\r\nunsigned int flg, ignored = 0;\r\nstruct tty_port *port = &sport->port.state->port;\r\nunsigned long flags;\r\nunsigned char rx, sr;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwhile (!(readb(sport->port.membase + UARTSFIFO) & UARTSFIFO_RXEMPT)) {\r\nflg = TTY_NORMAL;\r\nsport->port.icount.rx++;\r\nsr = readb(sport->port.membase + UARTSR1);\r\nrx = readb(sport->port.membase + UARTDR);\r\nif (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))\r\ncontinue;\r\nif (sr & (UARTSR1_PE | UARTSR1_OR | UARTSR1_FE)) {\r\nif (sr & UARTSR1_PE)\r\nsport->port.icount.parity++;\r\nelse if (sr & UARTSR1_FE)\r\nsport->port.icount.frame++;\r\nif (sr & UARTSR1_OR)\r\nsport->port.icount.overrun++;\r\nif (sr & sport->port.ignore_status_mask) {\r\nif (++ignored > 100)\r\ngoto out;\r\ncontinue;\r\n}\r\nsr &= sport->port.read_status_mask;\r\nif (sr & UARTSR1_PE)\r\nflg = TTY_PARITY;\r\nelse if (sr & UARTSR1_FE)\r\nflg = TTY_FRAME;\r\nif (sr & UARTSR1_OR)\r\nflg = TTY_OVERRUN;\r\n#ifdef SUPPORT_SYSRQ\r\nsport->port.sysrq = 0;\r\n#endif\r\n}\r\ntty_insert_flip_char(port, rx, flg);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\ntty_flip_buffer_push(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lpuart32_rxint(int irq, void *dev_id)\r\n{\r\nstruct lpuart_port *sport = dev_id;\r\nunsigned int flg, ignored = 0;\r\nstruct tty_port *port = &sport->port.state->port;\r\nunsigned long flags;\r\nunsigned long rx, sr;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwhile (!(lpuart32_read(sport->port.membase + UARTFIFO) & UARTFIFO_RXEMPT)) {\r\nflg = TTY_NORMAL;\r\nsport->port.icount.rx++;\r\nsr = lpuart32_read(sport->port.membase + UARTSTAT);\r\nrx = lpuart32_read(sport->port.membase + UARTDATA);\r\nrx &= 0x3ff;\r\nif (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))\r\ncontinue;\r\nif (sr & (UARTSTAT_PE | UARTSTAT_OR | UARTSTAT_FE)) {\r\nif (sr & UARTSTAT_PE)\r\nsport->port.icount.parity++;\r\nelse if (sr & UARTSTAT_FE)\r\nsport->port.icount.frame++;\r\nif (sr & UARTSTAT_OR)\r\nsport->port.icount.overrun++;\r\nif (sr & sport->port.ignore_status_mask) {\r\nif (++ignored > 100)\r\ngoto out;\r\ncontinue;\r\n}\r\nsr &= sport->port.read_status_mask;\r\nif (sr & UARTSTAT_PE)\r\nflg = TTY_PARITY;\r\nelse if (sr & UARTSTAT_FE)\r\nflg = TTY_FRAME;\r\nif (sr & UARTSTAT_OR)\r\nflg = TTY_OVERRUN;\r\n#ifdef SUPPORT_SYSRQ\r\nsport->port.sysrq = 0;\r\n#endif\r\n}\r\ntty_insert_flip_char(port, rx, flg);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\ntty_flip_buffer_push(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lpuart_int(int irq, void *dev_id)\r\n{\r\nstruct lpuart_port *sport = dev_id;\r\nunsigned char sts;\r\nsts = readb(sport->port.membase + UARTSR1);\r\nif (sts & UARTSR1_RDRF) {\r\nif (sport->lpuart_dma_use)\r\nlpuart_prepare_rx(sport);\r\nelse\r\nlpuart_rxint(irq, dev_id);\r\n}\r\nif (sts & UARTSR1_TDRE &&\r\n!(readb(sport->port.membase + UARTCR5) & UARTCR5_TDMAS)) {\r\nif (sport->lpuart_dma_use)\r\nlpuart_pio_tx(sport);\r\nelse\r\nlpuart_txint(irq, dev_id);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lpuart32_int(int irq, void *dev_id)\r\n{\r\nstruct lpuart_port *sport = dev_id;\r\nunsigned long sts, rxcount;\r\nsts = lpuart32_read(sport->port.membase + UARTSTAT);\r\nrxcount = lpuart32_read(sport->port.membase + UARTWATER);\r\nrxcount = rxcount >> UARTWATER_RXCNT_OFF;\r\nif (sts & UARTSTAT_RDRF || rxcount > 0)\r\nlpuart32_rxint(irq, dev_id);\r\nif ((sts & UARTSTAT_TDRE) &&\r\n!(lpuart32_read(sport->port.membase + UARTBAUD) & UARTBAUD_TDMAE))\r\nlpuart_txint(irq, dev_id);\r\nlpuart32_write(sts, sport->port.membase + UARTSTAT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int lpuart_tx_empty(struct uart_port *port)\r\n{\r\nreturn (readb(port->membase + UARTSR1) & UARTSR1_TC) ?\r\nTIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int lpuart32_tx_empty(struct uart_port *port)\r\n{\r\nreturn (lpuart32_read(port->membase + UARTSTAT) & UARTSTAT_TC) ?\r\nTIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int lpuart_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int temp = 0;\r\nunsigned char reg;\r\nreg = readb(port->membase + UARTMODEM);\r\nif (reg & UARTMODEM_TXCTSE)\r\ntemp |= TIOCM_CTS;\r\nif (reg & UARTMODEM_RXRTSE)\r\ntemp |= TIOCM_RTS;\r\nreturn temp;\r\n}\r\nstatic unsigned int lpuart32_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int temp = 0;\r\nunsigned long reg;\r\nreg = lpuart32_read(port->membase + UARTMODIR);\r\nif (reg & UARTMODIR_TXCTSE)\r\ntemp |= TIOCM_CTS;\r\nif (reg & UARTMODIR_RXRTSE)\r\ntemp |= TIOCM_RTS;\r\nreturn temp;\r\n}\r\nstatic void lpuart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTMODEM) &\r\n~(UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\r\nif (mctrl & TIOCM_RTS)\r\ntemp |= UARTMODEM_RXRTSE;\r\nif (mctrl & TIOCM_CTS)\r\ntemp |= UARTMODEM_TXCTSE;\r\nwriteb(temp, port->membase + UARTMODEM);\r\n}\r\nstatic void lpuart32_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned long temp;\r\ntemp = lpuart32_read(port->membase + UARTMODIR) &\r\n~(UARTMODIR_RXRTSE | UARTMODIR_TXCTSE);\r\nif (mctrl & TIOCM_RTS)\r\ntemp |= UARTMODIR_RXRTSE;\r\nif (mctrl & TIOCM_CTS)\r\ntemp |= UARTMODIR_TXCTSE;\r\nlpuart32_write(temp, port->membase + UARTMODIR);\r\n}\r\nstatic void lpuart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned char temp;\r\ntemp = readb(port->membase + UARTCR2) & ~UARTCR2_SBK;\r\nif (break_state != 0)\r\ntemp |= UARTCR2_SBK;\r\nwriteb(temp, port->membase + UARTCR2);\r\n}\r\nstatic void lpuart32_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned long temp;\r\ntemp = lpuart32_read(port->membase + UARTCTRL) & ~UARTCTRL_SBK;\r\nif (break_state != 0)\r\ntemp |= UARTCTRL_SBK;\r\nlpuart32_write(temp, port->membase + UARTCTRL);\r\n}\r\nstatic void lpuart_setup_watermark(struct lpuart_port *sport)\r\n{\r\nunsigned char val, cr2;\r\nunsigned char cr2_saved;\r\ncr2 = readb(sport->port.membase + UARTCR2);\r\ncr2_saved = cr2;\r\ncr2 &= ~(UARTCR2_TIE | UARTCR2_TCIE | UARTCR2_TE |\r\nUARTCR2_RIE | UARTCR2_RE);\r\nwriteb(cr2, sport->port.membase + UARTCR2);\r\nval = readb(sport->port.membase + UARTPFIFO);\r\nwriteb(val | UARTPFIFO_TXFE | UARTPFIFO_RXFE,\r\nsport->port.membase + UARTPFIFO);\r\nwriteb(UARTCFIFO_TXFLUSH | UARTCFIFO_RXFLUSH,\r\nsport->port.membase + UARTCFIFO);\r\nwriteb(0, sport->port.membase + UARTTWFIFO);\r\nwriteb(1, sport->port.membase + UARTRWFIFO);\r\nwriteb(cr2_saved, sport->port.membase + UARTCR2);\r\n}\r\nstatic void lpuart32_setup_watermark(struct lpuart_port *sport)\r\n{\r\nunsigned long val, ctrl;\r\nunsigned long ctrl_saved;\r\nctrl = lpuart32_read(sport->port.membase + UARTCTRL);\r\nctrl_saved = ctrl;\r\nctrl &= ~(UARTCTRL_TIE | UARTCTRL_TCIE | UARTCTRL_TE |\r\nUARTCTRL_RIE | UARTCTRL_RE);\r\nlpuart32_write(ctrl, sport->port.membase + UARTCTRL);\r\nval = lpuart32_read(sport->port.membase + UARTFIFO);\r\nval |= UARTFIFO_TXFE | UARTFIFO_RXFE;\r\nval |= UARTFIFO_TXFLUSH | UARTFIFO_RXFLUSH;\r\nlpuart32_write(val, sport->port.membase + UARTFIFO);\r\nval = (0x1 << UARTWATER_RXWATER_OFF) | (0x0 << UARTWATER_TXWATER_OFF);\r\nlpuart32_write(val, sport->port.membase + UARTWATER);\r\nlpuart32_write(ctrl_saved, sport->port.membase + UARTCTRL);\r\n}\r\nstatic int lpuart_dma_tx_request(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port,\r\nstruct lpuart_port, port);\r\nstruct dma_chan *tx_chan;\r\nstruct dma_slave_config dma_tx_sconfig;\r\ndma_addr_t dma_bus;\r\nunsigned char *dma_buf;\r\nint ret;\r\ntx_chan = dma_request_slave_channel(sport->port.dev, "tx");\r\nif (!tx_chan) {\r\ndev_err(sport->port.dev, "Dma tx channel request failed!\n");\r\nreturn -ENODEV;\r\n}\r\ndma_bus = dma_map_single(tx_chan->device->dev,\r\nsport->port.state->xmit.buf,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\nif (dma_mapping_error(tx_chan->device->dev, dma_bus)) {\r\ndev_err(sport->port.dev, "dma_map_single tx failed\n");\r\ndma_release_channel(tx_chan);\r\nreturn -ENOMEM;\r\n}\r\ndma_buf = sport->port.state->xmit.buf;\r\ndma_tx_sconfig.dst_addr = sport->port.mapbase + UARTDR;\r\ndma_tx_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndma_tx_sconfig.dst_maxburst = sport->txfifo_size;\r\ndma_tx_sconfig.direction = DMA_MEM_TO_DEV;\r\nret = dmaengine_slave_config(tx_chan, &dma_tx_sconfig);\r\nif (ret < 0) {\r\ndev_err(sport->port.dev,\r\n"Dma slave config failed, err = %d\n", ret);\r\ndma_release_channel(tx_chan);\r\nreturn ret;\r\n}\r\nsport->dma_tx_chan = tx_chan;\r\nsport->dma_tx_buf_virt = dma_buf;\r\nsport->dma_tx_buf_bus = dma_bus;\r\nsport->dma_tx_in_progress = 0;\r\nreturn 0;\r\n}\r\nstatic int lpuart_dma_rx_request(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port,\r\nstruct lpuart_port, port);\r\nstruct dma_chan *rx_chan;\r\nstruct dma_slave_config dma_rx_sconfig;\r\ndma_addr_t dma_bus;\r\nunsigned char *dma_buf;\r\nint ret;\r\nrx_chan = dma_request_slave_channel(sport->port.dev, "rx");\r\nif (!rx_chan) {\r\ndev_err(sport->port.dev, "Dma rx channel request failed!\n");\r\nreturn -ENODEV;\r\n}\r\ndma_buf = devm_kzalloc(sport->port.dev,\r\nFSL_UART_RX_DMA_BUFFER_SIZE, GFP_KERNEL);\r\nif (!dma_buf) {\r\ndev_err(sport->port.dev, "Dma rx alloc failed\n");\r\ndma_release_channel(rx_chan);\r\nreturn -ENOMEM;\r\n}\r\ndma_bus = dma_map_single(rx_chan->device->dev, dma_buf,\r\nFSL_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(rx_chan->device->dev, dma_bus)) {\r\ndev_err(sport->port.dev, "dma_map_single rx failed\n");\r\ndma_release_channel(rx_chan);\r\nreturn -ENOMEM;\r\n}\r\ndma_rx_sconfig.src_addr = sport->port.mapbase + UARTDR;\r\ndma_rx_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndma_rx_sconfig.src_maxburst = 1;\r\ndma_rx_sconfig.direction = DMA_DEV_TO_MEM;\r\nret = dmaengine_slave_config(rx_chan, &dma_rx_sconfig);\r\nif (ret < 0) {\r\ndev_err(sport->port.dev,\r\n"Dma slave config failed, err = %d\n", ret);\r\ndma_release_channel(rx_chan);\r\nreturn ret;\r\n}\r\nsport->dma_rx_chan = rx_chan;\r\nsport->dma_rx_buf_virt = dma_buf;\r\nsport->dma_rx_buf_bus = dma_bus;\r\nsport->dma_rx_in_progress = 0;\r\nreturn 0;\r\n}\r\nstatic void lpuart_dma_tx_free(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port,\r\nstruct lpuart_port, port);\r\nstruct dma_chan *dma_chan;\r\ndma_unmap_single(sport->port.dev, sport->dma_tx_buf_bus,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\ndma_chan = sport->dma_tx_chan;\r\nsport->dma_tx_chan = NULL;\r\nsport->dma_tx_buf_bus = 0;\r\nsport->dma_tx_buf_virt = NULL;\r\ndma_release_channel(dma_chan);\r\n}\r\nstatic void lpuart_dma_rx_free(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port,\r\nstruct lpuart_port, port);\r\nstruct dma_chan *dma_chan;\r\ndma_unmap_single(sport->port.dev, sport->dma_rx_buf_bus,\r\nFSL_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);\r\ndma_chan = sport->dma_rx_chan;\r\nsport->dma_rx_chan = NULL;\r\nsport->dma_rx_buf_bus = 0;\r\nsport->dma_rx_buf_virt = NULL;\r\ndma_release_channel(dma_chan);\r\n}\r\nstatic int lpuart_startup(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nint ret;\r\nunsigned long flags;\r\nunsigned char temp;\r\ntemp = readb(sport->port.membase + UARTPFIFO);\r\nsport->txfifo_size = 0x1 << (((temp >> UARTPFIFO_TXSIZE_OFF) &\r\nUARTPFIFO_FIFOSIZE_MASK) + 1);\r\nsport->rxfifo_size = 0x1 << (((temp >> UARTPFIFO_RXSIZE_OFF) &\r\nUARTPFIFO_FIFOSIZE_MASK) + 1);\r\nif (lpuart_dma_tx_request(port) || lpuart_dma_rx_request(port)) {\r\nsport->lpuart_dma_use = false;\r\n} else {\r\nsport->lpuart_dma_use = true;\r\ntemp = readb(port->membase + UARTCR5);\r\nwriteb(temp | UARTCR5_TDMAS, port->membase + UARTCR5);\r\n}\r\nret = devm_request_irq(port->dev, port->irq, lpuart_int, 0,\r\nDRIVER_NAME, sport);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nlpuart_setup_watermark(sport);\r\ntemp = readb(sport->port.membase + UARTCR2);\r\ntemp |= (UARTCR2_RIE | UARTCR2_TIE | UARTCR2_RE | UARTCR2_TE);\r\nwriteb(temp, sport->port.membase + UARTCR2);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int lpuart32_startup(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nint ret;\r\nunsigned long flags;\r\nunsigned long temp;\r\ntemp = lpuart32_read(sport->port.membase + UARTFIFO);\r\nsport->txfifo_size = 0x1 << (((temp >> UARTFIFO_TXSIZE_OFF) &\r\nUARTFIFO_FIFOSIZE_MASK) - 1);\r\nsport->rxfifo_size = 0x1 << (((temp >> UARTFIFO_RXSIZE_OFF) &\r\nUARTFIFO_FIFOSIZE_MASK) - 1);\r\nret = devm_request_irq(port->dev, port->irq, lpuart32_int, 0,\r\nDRIVER_NAME, sport);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nlpuart32_setup_watermark(sport);\r\ntemp = lpuart32_read(sport->port.membase + UARTCTRL);\r\ntemp |= (UARTCTRL_RIE | UARTCTRL_TIE | UARTCTRL_RE | UARTCTRL_TE);\r\ntemp |= UARTCTRL_ILIE;\r\nlpuart32_write(temp, sport->port.membase + UARTCTRL);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void lpuart_shutdown(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nunsigned char temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntemp = readb(port->membase + UARTCR2);\r\ntemp &= ~(UARTCR2_TE | UARTCR2_RE |\r\nUARTCR2_TIE | UARTCR2_TCIE | UARTCR2_RIE);\r\nwriteb(temp, port->membase + UARTCR2);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndevm_free_irq(port->dev, port->irq, sport);\r\nif (sport->lpuart_dma_use) {\r\nlpuart_dma_tx_free(port);\r\nlpuart_dma_rx_free(port);\r\n}\r\n}\r\nstatic void lpuart32_shutdown(struct uart_port *port)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nunsigned long temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntemp = lpuart32_read(port->membase + UARTCTRL);\r\ntemp &= ~(UARTCTRL_TE | UARTCTRL_RE |\r\nUARTCTRL_TIE | UARTCTRL_TCIE | UARTCTRL_RIE);\r\nlpuart32_write(temp, port->membase + UARTCTRL);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndevm_free_irq(port->dev, port->irq, sport);\r\n}\r\nstatic void\r\nlpuart_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nunsigned long flags;\r\nunsigned char cr1, old_cr1, old_cr2, cr4, bdh, modem;\r\nunsigned int baud;\r\nunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\r\nunsigned int sbr, brfa;\r\ncr1 = old_cr1 = readb(sport->port.membase + UARTCR1);\r\nold_cr2 = readb(sport->port.membase + UARTCR2);\r\ncr4 = readb(sport->port.membase + UARTCR4);\r\nbdh = readb(sport->port.membase + UARTBDH);\r\nmodem = readb(sport->port.membase + UARTMODEM);\r\nwhile ((termios->c_cflag & CSIZE) != CS8 &&\r\n(termios->c_cflag & CSIZE) != CS7) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= old_csize;\r\nold_csize = CS8;\r\n}\r\nif ((termios->c_cflag & CSIZE) == CS8 ||\r\n(termios->c_cflag & CSIZE) == CS7)\r\ncr1 = old_cr1 & ~UARTCR1_M;\r\nif (termios->c_cflag & CMSPAR) {\r\nif ((termios->c_cflag & CSIZE) != CS8) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\n}\r\ncr1 |= UARTCR1_M;\r\n}\r\nif (termios->c_cflag & CRTSCTS) {\r\nmodem |= (UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\r\n} else {\r\ntermios->c_cflag &= ~CRTSCTS;\r\nmodem &= ~(UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ntermios->c_cflag &= ~CSTOPB;\r\nif ((termios->c_cflag & CSIZE) == CS7)\r\ntermios->c_cflag |= PARENB;\r\nif ((termios->c_cflag & PARENB)) {\r\nif (termios->c_cflag & CMSPAR) {\r\ncr1 &= ~UARTCR1_PE;\r\ncr1 |= UARTCR1_M;\r\n} else {\r\ncr1 |= UARTCR1_PE;\r\nif ((termios->c_cflag & CSIZE) == CS8)\r\ncr1 |= UARTCR1_M;\r\nif (termios->c_cflag & PARODD)\r\ncr1 |= UARTCR1_PT;\r\nelse\r\ncr1 &= ~UARTCR1_PT;\r\n}\r\n}\r\nbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->port.read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nsport->port.read_status_mask |= (UARTSR1_FE | UARTSR1_PE);\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nsport->port.read_status_mask |= UARTSR1_FE;\r\nsport->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= UARTSR1_PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nsport->port.ignore_status_mask |= UARTSR1_FE;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= UARTSR1_OR;\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nif (sport->lpuart_dma_use) {\r\nsport->dma_rx_timeout = (sport->port.timeout - HZ / 50) *\r\nFSL_UART_RX_DMA_BUFFER_SIZE * 3 /\r\nsport->rxfifo_size / 2;\r\ndev_dbg(port->dev, "DMA Rx t-out %ums, tty t-out %u jiffies\n",\r\nsport->dma_rx_timeout * 1000 / HZ, sport->port.timeout);\r\nif (sport->dma_rx_timeout < msecs_to_jiffies(20))\r\nsport->dma_rx_timeout = msecs_to_jiffies(20);\r\n}\r\nwhile (!(readb(sport->port.membase + UARTSR1) & UARTSR1_TC))\r\nbarrier();\r\nwriteb(old_cr2 & ~(UARTCR2_TE | UARTCR2_RE),\r\nsport->port.membase + UARTCR2);\r\nsbr = sport->port.uartclk / (16 * baud);\r\nbrfa = ((sport->port.uartclk - (16 * sbr * baud)) * 2) / baud;\r\nbdh &= ~UARTBDH_SBR_MASK;\r\nbdh |= (sbr >> 8) & 0x1F;\r\ncr4 &= ~UARTCR4_BRFA_MASK;\r\nbrfa &= UARTCR4_BRFA_MASK;\r\nwriteb(cr4 | brfa, sport->port.membase + UARTCR4);\r\nwriteb(bdh, sport->port.membase + UARTBDH);\r\nwriteb(sbr & 0xFF, sport->port.membase + UARTBDL);\r\nwriteb(cr1, sport->port.membase + UARTCR1);\r\nwriteb(modem, sport->port.membase + UARTMODEM);\r\nwriteb(old_cr2, sport->port.membase + UARTCR2);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic void\r\nlpuart32_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct lpuart_port *sport = container_of(port, struct lpuart_port, port);\r\nunsigned long flags;\r\nunsigned long ctrl, old_ctrl, bd, modem;\r\nunsigned int baud;\r\nunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\r\nunsigned int sbr;\r\nctrl = old_ctrl = lpuart32_read(sport->port.membase + UARTCTRL);\r\nbd = lpuart32_read(sport->port.membase + UARTBAUD);\r\nmodem = lpuart32_read(sport->port.membase + UARTMODIR);\r\nwhile ((termios->c_cflag & CSIZE) != CS8 &&\r\n(termios->c_cflag & CSIZE) != CS7) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= old_csize;\r\nold_csize = CS8;\r\n}\r\nif ((termios->c_cflag & CSIZE) == CS8 ||\r\n(termios->c_cflag & CSIZE) == CS7)\r\nctrl = old_ctrl & ~UARTCTRL_M;\r\nif (termios->c_cflag & CMSPAR) {\r\nif ((termios->c_cflag & CSIZE) != CS8) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\n}\r\nctrl |= UARTCTRL_M;\r\n}\r\nif (termios->c_cflag & CRTSCTS) {\r\nmodem |= (UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\r\n} else {\r\ntermios->c_cflag &= ~CRTSCTS;\r\nmodem &= ~(UARTMODEM_RXRTSE | UARTMODEM_TXCTSE);\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ntermios->c_cflag &= ~CSTOPB;\r\nif ((termios->c_cflag & CSIZE) == CS7)\r\ntermios->c_cflag |= PARENB;\r\nif ((termios->c_cflag & PARENB)) {\r\nif (termios->c_cflag & CMSPAR) {\r\nctrl &= ~UARTCTRL_PE;\r\nctrl |= UARTCTRL_M;\r\n} else {\r\nctrl |= UARTCR1_PE;\r\nif ((termios->c_cflag & CSIZE) == CS8)\r\nctrl |= UARTCTRL_M;\r\nif (termios->c_cflag & PARODD)\r\nctrl |= UARTCTRL_PT;\r\nelse\r\nctrl &= ~UARTCTRL_PT;\r\n}\r\n}\r\nbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->port.read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nsport->port.read_status_mask |= (UARTSTAT_FE | UARTSTAT_PE);\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nsport->port.read_status_mask |= UARTSTAT_FE;\r\nsport->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= UARTSTAT_PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nsport->port.ignore_status_mask |= UARTSTAT_FE;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= UARTSTAT_OR;\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nwhile (!(lpuart32_read(sport->port.membase + UARTSTAT) & UARTSTAT_TC))\r\nbarrier();\r\nlpuart32_write(old_ctrl & ~(UARTCTRL_TE | UARTCTRL_RE),\r\nsport->port.membase + UARTCTRL);\r\nsbr = sport->port.uartclk / (16 * baud);\r\nbd &= ~UARTBAUD_SBR_MASK;\r\nbd |= sbr & UARTBAUD_SBR_MASK;\r\nbd |= UARTBAUD_BOTHEDGE;\r\nbd &= ~(UARTBAUD_TDMAE | UARTBAUD_RDMAE);\r\nlpuart32_write(bd, sport->port.membase + UARTBAUD);\r\nlpuart32_write(modem, sport->port.membase + UARTMODIR);\r\nlpuart32_write(ctrl, sport->port.membase + UARTCTRL);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic const char *lpuart_type(struct uart_port *port)\r\n{\r\nreturn "FSL_LPUART";\r\n}\r\nstatic void lpuart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int lpuart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void lpuart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_LPUART;\r\n}\r\nstatic int lpuart_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_LPUART)\r\nret = -EINVAL;\r\nif (port->irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->io_type != UPIO_MEM)\r\nret = -EINVAL;\r\nif (port->uartclk / 16 != ser->baud_base)\r\nret = -EINVAL;\r\nif (port->iobase != ser->port)\r\nret = -EINVAL;\r\nif (ser->hub6 != 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void lpuart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (!(readb(port->membase + UARTSR1) & UARTSR1_TDRE))\r\nbarrier();\r\nwriteb(ch, port->membase + UARTDR);\r\n}\r\nstatic void lpuart32_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (!(lpuart32_read(port->membase + UARTSTAT) & UARTSTAT_TDRE))\r\nbarrier();\r\nlpuart32_write(ch, port->membase + UARTDATA);\r\n}\r\nstatic void\r\nlpuart_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct lpuart_port *sport = lpuart_ports[co->index];\r\nunsigned char old_cr2, cr2;\r\ncr2 = old_cr2 = readb(sport->port.membase + UARTCR2);\r\ncr2 |= (UARTCR2_TE | UARTCR2_RE);\r\ncr2 &= ~(UARTCR2_TIE | UARTCR2_TCIE | UARTCR2_RIE);\r\nwriteb(cr2, sport->port.membase + UARTCR2);\r\nuart_console_write(&sport->port, s, count, lpuart_console_putchar);\r\nwhile (!(readb(sport->port.membase + UARTSR1) & UARTSR1_TC))\r\nbarrier();\r\nwriteb(old_cr2, sport->port.membase + UARTCR2);\r\n}\r\nstatic void\r\nlpuart32_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct lpuart_port *sport = lpuart_ports[co->index];\r\nunsigned long old_cr, cr;\r\ncr = old_cr = lpuart32_read(sport->port.membase + UARTCTRL);\r\ncr |= (UARTCTRL_TE | UARTCTRL_RE);\r\ncr &= ~(UARTCTRL_TIE | UARTCTRL_TCIE | UARTCTRL_RIE);\r\nlpuart32_write(cr, sport->port.membase + UARTCTRL);\r\nuart_console_write(&sport->port, s, count, lpuart32_console_putchar);\r\nwhile (!(lpuart32_read(sport->port.membase + UARTSTAT) & UARTSTAT_TC))\r\nbarrier();\r\nlpuart32_write(old_cr, sport->port.membase + UARTCTRL);\r\n}\r\nstatic void __init\r\nlpuart_console_get_options(struct lpuart_port *sport, int *baud,\r\nint *parity, int *bits)\r\n{\r\nunsigned char cr, bdh, bdl, brfa;\r\nunsigned int sbr, uartclk, baud_raw;\r\ncr = readb(sport->port.membase + UARTCR2);\r\ncr &= UARTCR2_TE | UARTCR2_RE;\r\nif (!cr)\r\nreturn;\r\ncr = readb(sport->port.membase + UARTCR1);\r\n*parity = 'n';\r\nif (cr & UARTCR1_PE) {\r\nif (cr & UARTCR1_PT)\r\n*parity = 'o';\r\nelse\r\n*parity = 'e';\r\n}\r\nif (cr & UARTCR1_M)\r\n*bits = 9;\r\nelse\r\n*bits = 8;\r\nbdh = readb(sport->port.membase + UARTBDH);\r\nbdh &= UARTBDH_SBR_MASK;\r\nbdl = readb(sport->port.membase + UARTBDL);\r\nsbr = bdh;\r\nsbr <<= 8;\r\nsbr |= bdl;\r\nbrfa = readb(sport->port.membase + UARTCR4);\r\nbrfa &= UARTCR4_BRFA_MASK;\r\nuartclk = clk_get_rate(sport->clk);\r\nbaud_raw = uartclk / (16 * (sbr + brfa / 32));\r\nif (*baud != baud_raw)\r\nprintk(KERN_INFO "Serial: Console lpuart rounded baud rate"\r\n"from %d to %d\n", baud_raw, *baud);\r\n}\r\nstatic void __init\r\nlpuart32_console_get_options(struct lpuart_port *sport, int *baud,\r\nint *parity, int *bits)\r\n{\r\nunsigned long cr, bd;\r\nunsigned int sbr, uartclk, baud_raw;\r\ncr = lpuart32_read(sport->port.membase + UARTCTRL);\r\ncr &= UARTCTRL_TE | UARTCTRL_RE;\r\nif (!cr)\r\nreturn;\r\ncr = lpuart32_read(sport->port.membase + UARTCTRL);\r\n*parity = 'n';\r\nif (cr & UARTCTRL_PE) {\r\nif (cr & UARTCTRL_PT)\r\n*parity = 'o';\r\nelse\r\n*parity = 'e';\r\n}\r\nif (cr & UARTCTRL_M)\r\n*bits = 9;\r\nelse\r\n*bits = 8;\r\nbd = lpuart32_read(sport->port.membase + UARTBAUD);\r\nbd &= UARTBAUD_SBR_MASK;\r\nsbr = bd;\r\nuartclk = clk_get_rate(sport->clk);\r\nbaud_raw = uartclk / (16 * sbr);\r\nif (*baud != baud_raw)\r\nprintk(KERN_INFO "Serial: Console lpuart rounded baud rate"\r\n"from %d to %d\n", baud_raw, *baud);\r\n}\r\nstatic int __init lpuart_console_setup(struct console *co, char *options)\r\n{\r\nstruct lpuart_port *sport;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index == -1 || co->index >= ARRAY_SIZE(lpuart_ports))\r\nco->index = 0;\r\nsport = lpuart_ports[co->index];\r\nif (sport == NULL)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nif (sport->lpuart32)\r\nlpuart32_console_get_options(sport, &baud, &parity, &bits);\r\nelse\r\nlpuart_console_get_options(sport, &baud, &parity, &bits);\r\nif (sport->lpuart32)\r\nlpuart32_setup_watermark(sport);\r\nelse\r\nlpuart_setup_watermark(sport);\r\nreturn uart_set_options(&sport->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int lpuart_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct lpuart_port *sport;\r\nstruct resource *res;\r\nint ret;\r\nsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\r\nif (!sport)\r\nreturn -ENOMEM;\r\npdev->dev.coherent_dma_mask = 0;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.line = ret;\r\nsport->lpuart32 = of_device_is_compatible(np, "fsl,ls1021a-lpuart");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nsport->port.mapbase = res->start;\r\nsport->port.membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(sport->port.membase))\r\nreturn PTR_ERR(sport->port.membase);\r\nsport->port.dev = &pdev->dev;\r\nsport->port.type = PORT_LPUART;\r\nsport->port.iotype = UPIO_MEM;\r\nsport->port.irq = platform_get_irq(pdev, 0);\r\nif (sport->lpuart32)\r\nsport->port.ops = &lpuart32_pops;\r\nelse\r\nsport->port.ops = &lpuart_pops;\r\nsport->port.flags = UPF_BOOT_AUTOCONF;\r\nsport->clk = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(sport->clk)) {\r\nret = PTR_ERR(sport->clk);\r\ndev_err(&pdev->dev, "failed to get uart clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(sport->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable uart clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.uartclk = clk_get_rate(sport->clk);\r\nlpuart_ports[sport->port.line] = sport;\r\nplatform_set_drvdata(pdev, &sport->port);\r\nif (sport->lpuart32)\r\nlpuart_reg.cons = LPUART32_CONSOLE;\r\nelse\r\nlpuart_reg.cons = LPUART_CONSOLE;\r\nret = uart_add_one_port(&lpuart_reg, &sport->port);\r\nif (ret) {\r\nclk_disable_unprepare(sport->clk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpuart_remove(struct platform_device *pdev)\r\n{\r\nstruct lpuart_port *sport = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&lpuart_reg, &sport->port);\r\nclk_disable_unprepare(sport->clk);\r\nreturn 0;\r\n}\r\nstatic int lpuart_suspend(struct device *dev)\r\n{\r\nstruct lpuart_port *sport = dev_get_drvdata(dev);\r\nuart_suspend_port(&lpuart_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int lpuart_resume(struct device *dev)\r\n{\r\nstruct lpuart_port *sport = dev_get_drvdata(dev);\r\nuart_resume_port(&lpuart_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int __init lpuart_serial_init(void)\r\n{\r\nint ret;\r\npr_info("serial: Freescale lpuart driver\n");\r\nret = uart_register_driver(&lpuart_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&lpuart_driver);\r\nif (ret)\r\nuart_unregister_driver(&lpuart_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit lpuart_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&lpuart_driver);\r\nuart_unregister_driver(&lpuart_reg);\r\n}
