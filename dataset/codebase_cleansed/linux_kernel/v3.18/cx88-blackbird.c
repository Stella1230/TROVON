static void host_setup(struct cx88_core *core)\r\n{\r\ncx_write(MO_GPHST_SOFT_RST, 1);\r\nudelay(100);\r\ncx_write(MO_GPHST_SOFT_RST, 0);\r\nudelay(100);\r\ncx_write(MO_GPHST_WSC, 0x44444444U);\r\ncx_write(MO_GPHST_XFR, 0);\r\ncx_write(MO_GPHST_WDTH, 15);\r\ncx_write(MO_GPHST_HDSHK, 0);\r\ncx_write(MO_GPHST_MUX16, 0x44448888U);\r\ncx_write(MO_GPHST_MODE, 0);\r\n}\r\nstatic int wait_ready_gpio0_bit1(struct cx88_core *core, u32 state)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1);\r\nu32 gpio0,need;\r\nneed = state ? 2 : 0;\r\nfor (;;) {\r\ngpio0 = cx_read(MO_GP0_IO) & 2;\r\nif (need == gpio0)\r\nreturn 0;\r\nif (time_after(jiffies,timeout))\r\nreturn -1;\r\nudelay(1);\r\n}\r\n}\r\nstatic int memory_write(struct cx88_core *core, u32 address, u32 value)\r\n{\r\ncx_writeb(P1_MDATA0, (unsigned int)value);\r\ncx_writeb(P1_MDATA1, (unsigned int)(value >> 8));\r\ncx_writeb(P1_MDATA2, (unsigned int)(value >> 16));\r\ncx_writeb(P1_MDATA3, (unsigned int)(value >> 24));\r\ncx_writeb(P1_MADDR2, (unsigned int)(address >> 16) | 0x40);\r\ncx_writeb(P1_MADDR1, (unsigned int)(address >> 8));\r\ncx_writeb(P1_MADDR0, (unsigned int)address);\r\ncx_read(P1_MDATA0);\r\ncx_read(P1_MADDR0);\r\nreturn wait_ready_gpio0_bit1(core,1);\r\n}\r\nstatic int memory_read(struct cx88_core *core, u32 address, u32 *value)\r\n{\r\nint retval;\r\nu32 val;\r\ncx_writeb(P1_MADDR2, (unsigned int)(address >> 16) & ~0xC0);\r\ncx_writeb(P1_MADDR1, (unsigned int)(address >> 8));\r\ncx_writeb(P1_MADDR0, (unsigned int)address);\r\ncx_read(P1_MADDR0);\r\nretval = wait_ready_gpio0_bit1(core,1);\r\ncx_writeb(P1_MDATA3, 0);\r\nval = (unsigned char)cx_read(P1_MDATA3) << 24;\r\ncx_writeb(P1_MDATA2, 0);\r\nval |= (unsigned char)cx_read(P1_MDATA2) << 16;\r\ncx_writeb(P1_MDATA1, 0);\r\nval |= (unsigned char)cx_read(P1_MDATA1) << 8;\r\ncx_writeb(P1_MDATA0, 0);\r\nval |= (unsigned char)cx_read(P1_MDATA0);\r\n*value = val;\r\nreturn retval;\r\n}\r\nstatic int register_write(struct cx88_core *core, u32 address, u32 value)\r\n{\r\ncx_writeb(P1_RDATA0, (unsigned int)value);\r\ncx_writeb(P1_RDATA1, (unsigned int)(value >> 8));\r\ncx_writeb(P1_RDATA2, (unsigned int)(value >> 16));\r\ncx_writeb(P1_RDATA3, (unsigned int)(value >> 24));\r\ncx_writeb(P1_RADDR0, (unsigned int)address);\r\ncx_writeb(P1_RADDR1, (unsigned int)(address >> 8));\r\ncx_writeb(P1_RRDWR, 1);\r\ncx_read(P1_RDATA0);\r\ncx_read(P1_RADDR0);\r\nreturn wait_ready_gpio0_bit1(core,1);\r\n}\r\nstatic int register_read(struct cx88_core *core, u32 address, u32 *value)\r\n{\r\nint retval;\r\nu32 val;\r\ncx_writeb(P1_RADDR0, (unsigned int)address);\r\ncx_writeb(P1_RADDR1, (unsigned int)(address >> 8));\r\ncx_writeb(P1_RRDWR, 0);\r\ncx_read(P1_RADDR0);\r\nretval = wait_ready_gpio0_bit1(core,1);\r\nval = (unsigned char)cx_read(P1_RDATA0);\r\nval |= (unsigned char)cx_read(P1_RDATA1) << 8;\r\nval |= (unsigned char)cx_read(P1_RDATA2) << 16;\r\nval |= (unsigned char)cx_read(P1_RDATA3) << 24;\r\n*value = val;\r\nreturn retval;\r\n}\r\nstatic int blackbird_mbox_func(void *priv, u32 command, int in, int out, u32 data[CX2341X_MBOX_MAX_DATA])\r\n{\r\nstruct cx8802_dev *dev = priv;\r\nunsigned long timeout;\r\nu32 value, flag, retval;\r\nint i;\r\ndprintk(1,"%s: 0x%X\n", __func__, command);\r\nmemory_read(dev->core, dev->mailbox - 4, &value);\r\nif (value != 0x12345678) {\r\ndprintk(0, "Firmware and/or mailbox pointer not initialized or corrupted\n");\r\nreturn -1;\r\n}\r\nmemory_read(dev->core, dev->mailbox, &flag);\r\nif (flag) {\r\ndprintk(0, "ERROR: Mailbox appears to be in use (%x)\n", flag);\r\nreturn -1;\r\n}\r\nflag |= 1;\r\nmemory_write(dev->core, dev->mailbox, flag);\r\nmemory_write(dev->core, dev->mailbox + 1, command);\r\nmemory_write(dev->core, dev->mailbox + 3, IVTV_API_STD_TIMEOUT);\r\nfor (i = 0; i < in; i++) {\r\nmemory_write(dev->core, dev->mailbox + 4 + i, data[i]);\r\ndprintk(1, "API Input %d = %d\n", i, data[i]);\r\n}\r\nfor (; i < CX2341X_MBOX_MAX_DATA; i++)\r\nmemory_write(dev->core, dev->mailbox + 4 + i, 0);\r\nflag |= 3;\r\nmemory_write(dev->core, dev->mailbox, flag);\r\ntimeout = jiffies + msecs_to_jiffies(10);\r\nfor (;;) {\r\nmemory_read(dev->core, dev->mailbox, &flag);\r\nif (0 != (flag & 4))\r\nbreak;\r\nif (time_after(jiffies,timeout)) {\r\ndprintk(0, "ERROR: API Mailbox timeout\n");\r\nreturn -1;\r\n}\r\nudelay(10);\r\n}\r\nfor (i = 0; i < out; i++) {\r\nmemory_read(dev->core, dev->mailbox + 4 + i, data + i);\r\ndprintk(1, "API Output %d = %d\n", i, data[i]);\r\n}\r\nmemory_read(dev->core, dev->mailbox + 2, &retval);\r\ndprintk(1, "API result = %d\n",retval);\r\nflag = 0;\r\nmemory_write(dev->core, dev->mailbox, flag);\r\nreturn retval;\r\n}\r\nstatic int blackbird_api_cmd(struct cx8802_dev *dev, u32 command,\r\nu32 inputcnt, u32 outputcnt, ...)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nva_list vargs;\r\nint i, err;\r\nva_start(vargs, outputcnt);\r\nfor (i = 0; i < inputcnt; i++) {\r\ndata[i] = va_arg(vargs, int);\r\n}\r\nerr = blackbird_mbox_func(dev, command, inputcnt, outputcnt, data);\r\nfor (i = 0; i < outputcnt; i++) {\r\nint *vptr = va_arg(vargs, int *);\r\n*vptr = data[i];\r\n}\r\nva_end(vargs);\r\nreturn err;\r\n}\r\nstatic int blackbird_find_mailbox(struct cx8802_dev *dev)\r\n{\r\nu32 signature[4]={0x12345678, 0x34567812, 0x56781234, 0x78123456};\r\nint signaturecnt=0;\r\nu32 value;\r\nint i;\r\nfor (i = 0; i < BLACKBIRD_FIRM_IMAGE_SIZE; i++) {\r\nmemory_read(dev->core, i, &value);\r\nif (value == signature[signaturecnt])\r\nsignaturecnt++;\r\nelse\r\nsignaturecnt = 0;\r\nif (4 == signaturecnt) {\r\ndprintk(1, "Mailbox signature found\n");\r\nreturn i+1;\r\n}\r\n}\r\ndprintk(0, "Mailbox signature values not found!\n");\r\nreturn -1;\r\n}\r\nstatic int blackbird_load_firmware(struct cx8802_dev *dev)\r\n{\r\nstatic const unsigned char magic[8] = {\r\n0xa7, 0x0d, 0x00, 0x00, 0x66, 0xbb, 0x55, 0xaa\r\n};\r\nconst struct firmware *firmware;\r\nint i, retval = 0;\r\nu32 value = 0;\r\nu32 checksum = 0;\r\nu32 *dataptr;\r\nretval = register_write(dev->core, IVTV_REG_VPU, 0xFFFFFFED);\r\nretval |= register_write(dev->core, IVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\r\nretval |= register_write(dev->core, IVTV_REG_ENC_SDRAM_REFRESH, 0x80000640);\r\nretval |= register_write(dev->core, IVTV_REG_ENC_SDRAM_PRECHARGE, 0x1A);\r\nmsleep(1);\r\nretval |= register_write(dev->core, IVTV_REG_APU, 0);\r\nif (retval < 0)\r\ndprintk(0, "Error with register_write\n");\r\nretval = request_firmware(&firmware, CX2341X_FIRM_ENC_FILENAME,\r\n&dev->pci->dev);\r\nif (retval != 0) {\r\ndprintk(0, "ERROR: Hotplug firmware request failed (%s).\n",\r\nCX2341X_FIRM_ENC_FILENAME);\r\ndprintk(0, "Please fix your hotplug setup, the board will "\r\n"not work without firmware loaded!\n");\r\nreturn -1;\r\n}\r\nif (firmware->size != BLACKBIRD_FIRM_IMAGE_SIZE) {\r\ndprintk(0, "ERROR: Firmware size mismatch (have %zd, expected %d)\n",\r\nfirmware->size, BLACKBIRD_FIRM_IMAGE_SIZE);\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nif (0 != memcmp(firmware->data, magic, 8)) {\r\ndprintk(0, "ERROR: Firmware magic mismatch, wrong file?\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\ndprintk(1,"Loading firmware ...\n");\r\ndataptr = (u32*)firmware->data;\r\nfor (i = 0; i < (firmware->size >> 2); i++) {\r\nvalue = le32_to_cpu(*dataptr);\r\nchecksum += ~value;\r\nmemory_write(dev->core, i, value);\r\ndataptr++;\r\n}\r\nfor (i--; i >= 0; i--) {\r\nmemory_read(dev->core, i, &value);\r\nchecksum -= ~value;\r\n}\r\nif (checksum) {\r\ndprintk(0, "ERROR: Firmware load failed (checksum mismatch).\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nrelease_firmware(firmware);\r\ndprintk(0, "Firmware upload successful.\n");\r\nretval |= register_write(dev->core, IVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\r\nretval |= register_read(dev->core, IVTV_REG_SPU, &value);\r\nretval |= register_write(dev->core, IVTV_REG_SPU, value & 0xFFFFFFFE);\r\nmsleep(1);\r\nretval |= register_read(dev->core, IVTV_REG_VPU, &value);\r\nretval |= register_write(dev->core, IVTV_REG_VPU, value & 0xFFFFFFE8);\r\nif (retval < 0)\r\ndprintk(0, "Error with register_write\n");\r\nreturn 0;\r\n}\r\nstatic void blackbird_codec_settings(struct cx8802_dev *dev)\r\n{\r\nblackbird_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\r\ndev->height, dev->width);\r\ndev->cxhdl.width = dev->width;\r\ndev->cxhdl.height = dev->height;\r\ncx2341x_handler_set_50hz(&dev->cxhdl, dev->core->tvnorm & V4L2_STD_625_50);\r\ncx2341x_handler_setup(&dev->cxhdl);\r\n}\r\nstatic int blackbird_initialize_codec(struct cx8802_dev *dev)\r\n{\r\nstruct cx88_core *core = dev->core;\r\nint version;\r\nint retval;\r\ndprintk(1,"Initialize codec\n");\r\nretval = blackbird_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\ndev->mpeg_active = 0;\r\ncx_write(MO_SRST_IO, 0);\r\ncx_write(MO_SRST_IO, 1);\r\nretval = blackbird_load_firmware(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = blackbird_find_mailbox(dev);\r\nif (retval < 0)\r\nreturn -1;\r\ndev->mailbox = retval;\r\nretval = blackbird_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\ndprintk(0, "ERROR: Firmware ping failed!\n");\r\nreturn -1;\r\n}\r\nretval = blackbird_api_cmd(dev, CX2341X_ENC_GET_VERSION, 0, 1, &version);\r\nif (retval < 0) {\r\ndprintk(0, "ERROR: Firmware get encoder version failed!\n");\r\nreturn -1;\r\n}\r\ndprintk(0, "Firmware version is 0x%08x\n", version);\r\n}\r\ncx_write(MO_PINMUX_IO, 0x88);\r\ncx_clear(MO_INPUT_FORMAT, 0x100);\r\ncx_write(MO_VBOS_CONTROL, 0x84A00);\r\ncx_clear(MO_OUTPUT_FORMAT, 0x0008);\r\nblackbird_codec_settings(dev);\r\nblackbird_api_cmd(dev, CX2341X_ENC_SET_NUM_VSYNC_LINES, 2, 0,\r\nBLACKBIRD_FIELD1_SAA7115,\r\nBLACKBIRD_FIELD2_SAA7115\r\n);\r\nblackbird_api_cmd(dev, CX2341X_ENC_SET_PLACEHOLDER, 12, 0,\r\nBLACKBIRD_CUSTOM_EXTENSION_USR_DATA,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int blackbird_start_codec(struct file *file, void *priv)\r\n{\r\nstruct cx8802_dev *dev = ((struct cx8802_fh *)priv)->dev;\r\nstruct cx88_core *core = dev->core;\r\nu32 reg;\r\nint i;\r\nint lastchange = -1;\r\nint lastval = 0;\r\nfor (i = 0; (i < 10) && (i < (lastchange + 4)); i++) {\r\nreg = cx_read(AUD_STATUS);\r\ndprintk(1, "AUD_STATUS:%dL: 0x%x\n", i, reg);\r\nif ((reg & 0x0F) != lastval) {\r\nlastval = reg & 0x0F;\r\nlastchange = i;\r\n}\r\nmsleep(100);\r\n}\r\ncx_clear(AUD_VOL_CTL, (1 << 6));\r\nblackbird_api_cmd(dev, CX2341X_ENC_REFRESH_INPUT, 0, 0);\r\nblackbird_api_cmd(dev, CX2341X_ENC_INITIALIZE_INPUT, 0, 0);\r\ncx2341x_handler_set_busy(&dev->cxhdl, 1);\r\nblackbird_api_cmd(dev, CX2341X_ENC_START_CAPTURE, 2, 0,\r\nBLACKBIRD_MPEG_CAPTURE,\r\nBLACKBIRD_RAW_BITS_NONE\r\n);\r\ndev->mpeg_active = 1;\r\nreturn 0;\r\n}\r\nstatic int blackbird_stop_codec(struct cx8802_dev *dev)\r\n{\r\nblackbird_api_cmd(dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\r\nBLACKBIRD_END_NOW,\r\nBLACKBIRD_MPEG_CAPTURE,\r\nBLACKBIRD_RAW_BITS_NONE\r\n);\r\ncx2341x_handler_set_busy(&dev->cxhdl, 0);\r\ndev->mpeg_active = 0;\r\nreturn 0;\r\n}\r\nstatic int bb_buf_setup(struct videobuf_queue *q,\r\nunsigned int *count, unsigned int *size)\r\n{\r\nstruct cx8802_fh *fh = q->priv_data;\r\nfh->dev->ts_packet_size = 188 * 4;\r\nfh->dev->ts_packet_count = mpegbufs;\r\n*size = fh->dev->ts_packet_size * fh->dev->ts_packet_count;\r\n*count = fh->dev->ts_packet_count;\r\nreturn 0;\r\n}\r\nstatic int\r\nbb_buf_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct cx8802_fh *fh = q->priv_data;\r\nreturn cx8802_buf_prepare(q, fh->dev, (struct cx88_buffer*)vb, field);\r\n}\r\nstatic void\r\nbb_buf_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct cx8802_fh *fh = q->priv_data;\r\ncx8802_buf_queue(fh->dev, (struct cx88_buffer*)vb);\r\n}\r\nstatic void\r\nbb_buf_release(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\ncx88_free_buffer(q, (struct cx88_buffer*)vb);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx8802_dev *dev = ((struct cx8802_fh *)priv)->dev;\r\nstruct cx88_core *core = dev->core;\r\nstrcpy(cap->driver, "cx88_blackbird");\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncx88_querycap(file, core, cap);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap (struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "MPEG", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap (struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nstruct cx8802_dev *dev = fh->dev;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = 188 * 4 * mpegbufs;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = fh->mpegq.field;\r\ndprintk(1, "VIDIOC_G_FMT: w: %d, h: %d, f: %d\n",\r\ndev->width, dev->height, fh->mpegq.field );\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap (struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nstruct cx8802_dev *dev = fh->dev;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = 188 * 4 * mpegbufs;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\ndprintk(1, "VIDIOC_TRY_FMT: w: %d, h: %d, f: %d\n",\r\ndev->width, dev->height, fh->mpegq.field );\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap (struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nstruct cx8802_dev *dev = fh->dev;\r\nstruct cx88_core *core = dev->core;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = 188 * 4 * mpegbufs;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\nfh->mpegq.field = f->fmt.pix.field;\r\ncx88_set_scale(core, f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\r\nblackbird_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\r\nf->fmt.pix.height, f->fmt.pix.width);\r\ndprintk(1, "VIDIOC_S_FMT: w: %d, h: %d, f: %d\n",\r\nf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field );\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs (struct file *file, void *priv, struct v4l2_requestbuffers *p)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nreturn (videobuf_reqbufs(&fh->mpegq, p));\r\n}\r\nstatic int vidioc_querybuf (struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nreturn (videobuf_querybuf(&fh->mpegq, p));\r\n}\r\nstatic int vidioc_qbuf (struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nreturn (videobuf_qbuf(&fh->mpegq, p));\r\n}\r\nstatic int vidioc_dqbuf (struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nreturn (videobuf_dqbuf(&fh->mpegq, p,\r\nfile->f_flags & O_NONBLOCK));\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nstruct cx8802_dev *dev = fh->dev;\r\nif (!dev->mpeg_active)\r\nblackbird_start_codec(file, fh);\r\nreturn videobuf_streamon(&fh->mpegq);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nstruct cx8802_dev *dev = fh->dev;\r\nif (dev->mpeg_active)\r\nblackbird_stop_codec(dev);\r\nreturn videobuf_streamoff(&fh->mpegq);\r\n}\r\nstatic int vidioc_s_frequency (struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nstruct cx8802_dev *dev = fh->dev;\r\nstruct cx88_core *core = dev->core;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\nif (dev->mpeg_active)\r\nblackbird_stop_codec(dev);\r\ncx88_set_freq (core,f);\r\nblackbird_initialize_codec(dev);\r\ncx88_set_scale(dev->core, dev->width, dev->height,\r\nfh->mpegq.field);\r\nreturn 0;\r\n}\r\nstatic int vidioc_log_status (struct file *file, void *priv)\r\n{\r\nstruct cx8802_dev *dev = ((struct cx8802_fh *)priv)->dev;\r\nstruct cx88_core *core = dev->core;\r\nchar name[32 + 2];\r\nsnprintf(name, sizeof(name), "%s/2", core->name);\r\ncall_all(core, core, log_status);\r\nv4l2_ctrl_handler_log_status(&dev->cxhdl.hdl, name);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input (struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx88_core *core = ((struct cx8802_fh *)priv)->dev->core;\r\nreturn cx88_enum_input (core,i);\r\n}\r\nstatic int vidioc_g_frequency (struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx8802_fh *fh = priv;\r\nstruct cx88_core *core = fh->dev->core;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\nf->frequency = core->freq;\r\ncall_all(core, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input (struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx88_core *core = ((struct cx8802_fh *)priv)->dev->core;\r\n*i = core->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input (struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx88_core *core = ((struct cx8802_fh *)priv)->dev->core;\r\nif (i >= 4)\r\nreturn -EINVAL;\r\nif (0 == INPUT(i).type)\r\nreturn -EINVAL;\r\nmutex_lock(&core->lock);\r\ncx88_newstation(core);\r\ncx88_video_mux(core,i);\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner (struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx88_core *core = ((struct cx8802_fh *)priv)->dev->core;\r\nu32 reg;\r\nif (unlikely(UNSET == core->board.tuner_type))\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nt->rangehigh = 0xffffffffUL;\r\ncall_all(core, tuner, g_tuner, t);\r\ncx88_get_stereo(core ,t);\r\nreg = cx_read(MO_DEVICE_STATUS);\r\nt->signal = (reg & (1<<5)) ? 0xffff : 0x0000;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner (struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct cx88_core *core = ((struct cx8802_fh *)priv)->dev->core;\r\nif (UNSET == core->board.tuner_type)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncx88_set_stereo(core, t->audmode, 1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *tvnorm)\r\n{\r\nstruct cx88_core *core = ((struct cx8802_fh *)priv)->dev->core;\r\n*tvnorm = core->tvnorm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct cx88_core *core = ((struct cx8802_fh *)priv)->dev->core;\r\nmutex_lock(&core->lock);\r\ncx88_set_tvnorm(core, id);\r\nmutex_unlock(&core->lock);\r\nreturn 0;\r\n}\r\nstatic int mpeg_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct cx8802_dev *dev = video_drvdata(file);\r\nstruct cx8802_fh *fh;\r\nstruct cx8802_driver *drv = NULL;\r\nint err;\r\ndprintk( 1, "%s\n", __func__);\r\nmutex_lock(&dev->core->lock);\r\ndrv = cx8802_get_driver(dev, CX88_MPEG_BLACKBIRD);\r\nif (!drv) {\r\ndprintk(1, "%s: blackbird driver is not loaded\n", __func__);\r\nmutex_unlock(&dev->core->lock);\r\nreturn -ENODEV;\r\n}\r\nerr = drv->request_acquire(drv);\r\nif (err != 0) {\r\ndprintk(1,"%s: Unable to acquire hardware, %d\n", __func__, err);\r\nmutex_unlock(&dev->core->lock);\r\nreturn err;\r\n}\r\nif (!dev->core->mpeg_users && blackbird_initialize_codec(dev) < 0) {\r\ndrv->request_release(drv);\r\nmutex_unlock(&dev->core->lock);\r\nreturn -EINVAL;\r\n}\r\ndprintk(1, "open dev=%s\n", video_device_node_name(vdev));\r\nfh = kzalloc(sizeof(*fh),GFP_KERNEL);\r\nif (NULL == fh) {\r\ndrv->request_release(drv);\r\nmutex_unlock(&dev->core->lock);\r\nreturn -ENOMEM;\r\n}\r\nv4l2_fh_init(&fh->fh, vdev);\r\nfile->private_data = fh;\r\nfh->dev = dev;\r\nvideobuf_queue_sg_init(&fh->mpegq, &blackbird_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct cx88_buffer),\r\nfh, NULL);\r\ncx88_set_scale(dev->core, dev->width, dev->height,\r\nfh->mpegq.field);\r\ndev->core->mpeg_users++;\r\nmutex_unlock(&dev->core->lock);\r\nv4l2_fh_add(&fh->fh);\r\nreturn 0;\r\n}\r\nstatic int mpeg_release(struct file *file)\r\n{\r\nstruct cx8802_fh *fh = file->private_data;\r\nstruct cx8802_dev *dev = fh->dev;\r\nstruct cx8802_driver *drv = NULL;\r\nmutex_lock(&dev->core->lock);\r\nif (dev->mpeg_active && dev->core->mpeg_users == 1)\r\nblackbird_stop_codec(dev);\r\ncx8802_cancel_buffers(fh->dev);\r\nvideobuf_stop(&fh->mpegq);\r\nvideobuf_mmap_free(&fh->mpegq);\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\ndrv = cx8802_get_driver(dev, CX88_MPEG_BLACKBIRD);\r\nWARN_ON(!drv);\r\nif (drv)\r\ndrv->request_release(drv);\r\ndev->core->mpeg_users--;\r\nmutex_unlock(&dev->core->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nmpeg_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct cx8802_fh *fh = file->private_data;\r\nstruct cx8802_dev *dev = fh->dev;\r\nif (!dev->mpeg_active)\r\nblackbird_start_codec(file, fh);\r\nreturn videobuf_read_stream(&fh->mpegq, data, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic unsigned int\r\nmpeg_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct cx8802_fh *fh = file->private_data;\r\nstruct cx8802_dev *dev = fh->dev;\r\nif (!dev->mpeg_active && (req_events & (POLLIN | POLLRDNORM)))\r\nblackbird_start_codec(file, fh);\r\nreturn v4l2_ctrl_poll(file, wait) | videobuf_poll_stream(file, &fh->mpegq, wait);\r\n}\r\nstatic int\r\nmpeg_mmap(struct file *file, struct vm_area_struct * vma)\r\n{\r\nstruct cx8802_fh *fh = file->private_data;\r\nreturn videobuf_mmap_mapper(&fh->mpegq, vma);\r\n}\r\nstatic int cx8802_blackbird_advise_acquire(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nint err = 0;\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_HAUPPAUGE_HVR1300:\r\ncx_set(MO_GP0_IO, 0x00000080);\r\nudelay(1000);\r\ncx_clear(MO_GP0_IO, 0x00000080);\r\nudelay(50);\r\ncx_set(MO_GP0_IO, 0x00000080);\r\nudelay(1000);\r\ncx_set(MO_GP0_IO, 0x00000004);\r\nudelay(1000);\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\n}\r\nreturn err;\r\n}\r\nstatic int cx8802_blackbird_advise_release(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nint err = 0;\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_HAUPPAUGE_HVR1300:\r\nbreak;\r\ndefault:\r\nerr = -ENODEV;\r\n}\r\nreturn err;\r\n}\r\nstatic void blackbird_unregister_video(struct cx8802_dev *dev)\r\n{\r\nif (dev->mpeg_dev) {\r\nif (video_is_registered(dev->mpeg_dev))\r\nvideo_unregister_device(dev->mpeg_dev);\r\nelse\r\nvideo_device_release(dev->mpeg_dev);\r\ndev->mpeg_dev = NULL;\r\n}\r\n}\r\nstatic int blackbird_register_video(struct cx8802_dev *dev)\r\n{\r\nint err;\r\ndev->mpeg_dev = cx88_vdev_init(dev->core,dev->pci,\r\n&cx8802_mpeg_template,"mpeg");\r\ndev->mpeg_dev->ctrl_handler = &dev->cxhdl.hdl;\r\nvideo_set_drvdata(dev->mpeg_dev, dev);\r\nerr = video_register_device(dev->mpeg_dev,VFL_TYPE_GRABBER, -1);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s/2: can't register mpeg device\n",\r\ndev->core->name);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "%s/2: registered device %s [mpeg]\n",\r\ndev->core->name, video_device_node_name(dev->mpeg_dev));\r\nreturn 0;\r\n}\r\nstatic int cx8802_blackbird_probe(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nstruct cx8802_dev *dev = core->dvbdev;\r\nint err;\r\ndprintk( 1, "%s\n", __func__);\r\ndprintk( 1, " ->being probed by Card=%d Name=%s, PCI %02x:%02x\n",\r\ncore->boardnr,\r\ncore->name,\r\ncore->pci_bus,\r\ncore->pci_slot);\r\nerr = -ENODEV;\r\nif (!(core->board.mpeg & CX88_MPEG_BLACKBIRD))\r\ngoto fail_core;\r\ndev->width = 720;\r\nif (core->tvnorm & V4L2_STD_525_60) {\r\ndev->height = 480;\r\n} else {\r\ndev->height = 576;\r\n}\r\ndev->cxhdl.port = CX2341X_PORT_STREAMING;\r\ndev->cxhdl.width = dev->width;\r\ndev->cxhdl.height = dev->height;\r\ndev->cxhdl.func = blackbird_mbox_func;\r\ndev->cxhdl.priv = dev;\r\nerr = cx2341x_handler_init(&dev->cxhdl, 36);\r\nif (err)\r\ngoto fail_core;\r\nv4l2_ctrl_add_handler(&dev->cxhdl.hdl, &core->video_hdl, NULL);\r\nprintk("%s/2: cx23416 based mpeg encoder (blackbird reference design)\n",\r\ncore->name);\r\nhost_setup(dev->core);\r\nblackbird_initialize_codec(dev);\r\ncx88_set_tvnorm(core,core->tvnorm);\r\ncx88_video_mux(core,0);\r\ncx2341x_handler_set_50hz(&dev->cxhdl, dev->height == 576);\r\ncx2341x_handler_setup(&dev->cxhdl);\r\nblackbird_register_video(dev);\r\nreturn 0;\r\nfail_core:\r\nreturn err;\r\n}\r\nstatic int cx8802_blackbird_remove(struct cx8802_driver *drv)\r\n{\r\nstruct cx88_core *core = drv->core;\r\nstruct cx8802_dev *dev = core->dvbdev;\r\nblackbird_unregister_video(drv->core->dvbdev);\r\nv4l2_ctrl_handler_free(&dev->cxhdl.hdl);\r\nreturn 0;\r\n}\r\nstatic int __init blackbird_init(void)\r\n{\r\nprintk(KERN_INFO "cx2388x blackbird driver version %s loaded\n",\r\nCX88_VERSION);\r\nreturn cx8802_register_driver(&cx8802_blackbird_driver);\r\n}\r\nstatic void __exit blackbird_fini(void)\r\n{\r\ncx8802_unregister_driver(&cx8802_blackbird_driver);\r\n}
