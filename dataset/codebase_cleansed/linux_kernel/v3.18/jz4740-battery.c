static inline struct jz_battery *psy_to_jz_battery(struct power_supply *psy)\r\n{\r\nreturn container_of(psy, struct jz_battery, battery);\r\n}\r\nstatic irqreturn_t jz_battery_irq_handler(int irq, void *devid)\r\n{\r\nstruct jz_battery *battery = devid;\r\ncomplete(&battery->read_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic long jz_battery_read_voltage(struct jz_battery *battery)\r\n{\r\nlong t;\r\nunsigned long val;\r\nlong voltage;\r\nmutex_lock(&battery->lock);\r\nreinit_completion(&battery->read_completion);\r\nenable_irq(battery->irq);\r\nbattery->cell->enable(battery->pdev);\r\nt = wait_for_completion_interruptible_timeout(&battery->read_completion,\r\nHZ);\r\nif (t > 0) {\r\nval = readw(battery->base) & 0xfff;\r\nif (battery->pdata->info.voltage_max_design <= 2500000)\r\nval = (val * 78125UL) >> 7UL;\r\nelse\r\nval = ((val * 924375UL) >> 9UL) + 33000;\r\nvoltage = (long)val;\r\n} else {\r\nvoltage = t ? t : -ETIMEDOUT;\r\n}\r\nbattery->cell->disable(battery->pdev);\r\ndisable_irq(battery->irq);\r\nmutex_unlock(&battery->lock);\r\nreturn voltage;\r\n}\r\nstatic int jz_battery_get_capacity(struct power_supply *psy)\r\n{\r\nstruct jz_battery *jz_battery = psy_to_jz_battery(psy);\r\nstruct power_supply_info *info = &jz_battery->pdata->info;\r\nlong voltage;\r\nint ret;\r\nint voltage_span;\r\nvoltage = jz_battery_read_voltage(jz_battery);\r\nif (voltage < 0)\r\nreturn voltage;\r\nvoltage_span = info->voltage_max_design - info->voltage_min_design;\r\nret = ((voltage - info->voltage_min_design) * 100) / voltage_span;\r\nif (ret > 100)\r\nret = 100;\r\nelse if (ret < 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int jz_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp, union power_supply_propval *val)\r\n{\r\nstruct jz_battery *jz_battery = psy_to_jz_battery(psy);\r\nstruct power_supply_info *info = &jz_battery->pdata->info;\r\nlong voltage;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = jz_battery->status;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = jz_battery->pdata->info.technology;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nvoltage = jz_battery_read_voltage(jz_battery);\r\nif (voltage < info->voltage_min_design)\r\nval->intval = POWER_SUPPLY_HEALTH_DEAD;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nval->intval = jz_battery_get_capacity(psy);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nval->intval = jz_battery_read_voltage(jz_battery);\r\nif (val->intval < 0)\r\nreturn val->intval;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nval->intval = info->voltage_max_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = info->voltage_min_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void jz_battery_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct jz_battery *jz_battery = psy_to_jz_battery(psy);\r\nmod_delayed_work(system_wq, &jz_battery->work, 0);\r\n}\r\nstatic irqreturn_t jz_battery_charge_irq(int irq, void *data)\r\n{\r\nstruct jz_battery *jz_battery = data;\r\nmod_delayed_work(system_wq, &jz_battery->work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void jz_battery_update(struct jz_battery *jz_battery)\r\n{\r\nint status;\r\nlong voltage;\r\nbool has_changed = false;\r\nint is_charging;\r\nif (gpio_is_valid(jz_battery->pdata->gpio_charge)) {\r\nis_charging = gpio_get_value(jz_battery->pdata->gpio_charge);\r\nis_charging ^= jz_battery->pdata->gpio_charge_active_low;\r\nif (is_charging)\r\nstatus = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nif (status != jz_battery->status) {\r\njz_battery->status = status;\r\nhas_changed = true;\r\n}\r\n}\r\nvoltage = jz_battery_read_voltage(jz_battery);\r\nif (abs(voltage - jz_battery->voltage) < 50000) {\r\njz_battery->voltage = voltage;\r\nhas_changed = true;\r\n}\r\nif (has_changed)\r\npower_supply_changed(&jz_battery->battery);\r\n}\r\nstatic void jz_battery_work(struct work_struct *work)\r\n{\r\nconst int interval = HZ * 30;\r\nstruct jz_battery *jz_battery = container_of(work, struct jz_battery,\r\nwork.work);\r\njz_battery_update(jz_battery);\r\nschedule_delayed_work(&jz_battery->work, interval);\r\n}\r\nstatic int jz_battery_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct jz_battery_platform_data *pdata = pdev->dev.parent->platform_data;\r\nstruct jz_battery *jz_battery;\r\nstruct power_supply *battery;\r\nstruct resource *mem;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform_data supplied\n");\r\nreturn -ENXIO;\r\n}\r\njz_battery = devm_kzalloc(&pdev->dev, sizeof(*jz_battery), GFP_KERNEL);\r\nif (!jz_battery) {\r\ndev_err(&pdev->dev, "Failed to allocate driver structure\n");\r\nreturn -ENOMEM;\r\n}\r\njz_battery->cell = mfd_get_cell(pdev);\r\njz_battery->irq = platform_get_irq(pdev, 0);\r\nif (jz_battery->irq < 0) {\r\ndev_err(&pdev->dev, "Failed to get platform irq: %d\n", ret);\r\nreturn jz_battery->irq;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\njz_battery->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(jz_battery->base))\r\nreturn PTR_ERR(jz_battery->base);\r\nbattery = &jz_battery->battery;\r\nbattery->name = pdata->info.name;\r\nbattery->type = POWER_SUPPLY_TYPE_BATTERY;\r\nbattery->properties = jz_battery_properties;\r\nbattery->num_properties = ARRAY_SIZE(jz_battery_properties);\r\nbattery->get_property = jz_battery_get_property;\r\nbattery->external_power_changed = jz_battery_external_power_changed;\r\nbattery->use_for_apm = 1;\r\njz_battery->pdata = pdata;\r\njz_battery->pdev = pdev;\r\ninit_completion(&jz_battery->read_completion);\r\nmutex_init(&jz_battery->lock);\r\nINIT_DELAYED_WORK(&jz_battery->work, jz_battery_work);\r\nret = request_irq(jz_battery->irq, jz_battery_irq_handler, 0, pdev->name,\r\njz_battery);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq %d\n", ret);\r\nreturn ret;\r\n}\r\ndisable_irq(jz_battery->irq);\r\nif (gpio_is_valid(pdata->gpio_charge)) {\r\nret = gpio_request(pdata->gpio_charge, dev_name(&pdev->dev));\r\nif (ret) {\r\ndev_err(&pdev->dev, "charger state gpio request failed.\n");\r\ngoto err_free_irq;\r\n}\r\nret = gpio_direction_input(pdata->gpio_charge);\r\nif (ret) {\r\ndev_err(&pdev->dev, "charger state gpio set direction failed.\n");\r\ngoto err_free_gpio;\r\n}\r\njz_battery->charge_irq = gpio_to_irq(pdata->gpio_charge);\r\nif (jz_battery->charge_irq >= 0) {\r\nret = request_irq(jz_battery->charge_irq,\r\njz_battery_charge_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\ndev_name(&pdev->dev), jz_battery);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request charge irq: %d\n", ret);\r\ngoto err_free_gpio;\r\n}\r\n}\r\n} else {\r\njz_battery->charge_irq = -1;\r\n}\r\nif (jz_battery->pdata->info.voltage_max_design <= 2500000)\r\njz4740_adc_set_config(pdev->dev.parent, JZ_ADC_CONFIG_BAT_MB,\r\nJZ_ADC_CONFIG_BAT_MB);\r\nelse\r\njz4740_adc_set_config(pdev->dev.parent, JZ_ADC_CONFIG_BAT_MB, 0);\r\nret = power_supply_register(&pdev->dev, &jz_battery->battery);\r\nif (ret) {\r\ndev_err(&pdev->dev, "power supply battery register failed.\n");\r\ngoto err_free_charge_irq;\r\n}\r\nplatform_set_drvdata(pdev, jz_battery);\r\nschedule_delayed_work(&jz_battery->work, 0);\r\nreturn 0;\r\nerr_free_charge_irq:\r\nif (jz_battery->charge_irq >= 0)\r\nfree_irq(jz_battery->charge_irq, jz_battery);\r\nerr_free_gpio:\r\nif (gpio_is_valid(pdata->gpio_charge))\r\ngpio_free(jz_battery->pdata->gpio_charge);\r\nerr_free_irq:\r\nfree_irq(jz_battery->irq, jz_battery);\r\nreturn ret;\r\n}\r\nstatic int jz_battery_remove(struct platform_device *pdev)\r\n{\r\nstruct jz_battery *jz_battery = platform_get_drvdata(pdev);\r\ncancel_delayed_work_sync(&jz_battery->work);\r\nif (gpio_is_valid(jz_battery->pdata->gpio_charge)) {\r\nif (jz_battery->charge_irq >= 0)\r\nfree_irq(jz_battery->charge_irq, jz_battery);\r\ngpio_free(jz_battery->pdata->gpio_charge);\r\n}\r\npower_supply_unregister(&jz_battery->battery);\r\nfree_irq(jz_battery->irq, jz_battery);\r\nreturn 0;\r\n}\r\nstatic int jz_battery_suspend(struct device *dev)\r\n{\r\nstruct jz_battery *jz_battery = dev_get_drvdata(dev);\r\ncancel_delayed_work_sync(&jz_battery->work);\r\njz_battery->status = POWER_SUPPLY_STATUS_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic int jz_battery_resume(struct device *dev)\r\n{\r\nstruct jz_battery *jz_battery = dev_get_drvdata(dev);\r\nschedule_delayed_work(&jz_battery->work, 0);\r\nreturn 0;\r\n}
