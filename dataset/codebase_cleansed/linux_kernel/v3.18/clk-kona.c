static inline u32 bitfield_mask(u32 shift, u32 width)\r\n{\r\nreturn ((1 << width) - 1) << shift;\r\n}\r\nstatic inline u32 bitfield_extract(u32 reg_val, u32 shift, u32 width)\r\n{\r\nreturn (reg_val & bitfield_mask(shift, width)) >> shift;\r\n}\r\nstatic inline u32 bitfield_replace(u32 reg_val, u32 shift, u32 width, u32 val)\r\n{\r\nu32 mask = bitfield_mask(shift, width);\r\nreturn (reg_val & ~mask) | (val << shift);\r\n}\r\nu64 do_div_round_closest(u64 dividend, unsigned long divisor)\r\n{\r\nu64 result;\r\nresult = dividend + ((u64)divisor >> 1);\r\n(void)do_div(result, divisor);\r\nreturn result;\r\n}\r\nstatic inline u64 scaled_div_value(struct bcm_clk_div *div, u32 reg_div)\r\n{\r\nreturn (u64)reg_div + ((u64)1 << div->u.s.frac_width);\r\n}\r\nu64 scaled_div_build(struct bcm_clk_div *div, u32 div_value, u32 billionths)\r\n{\r\nu64 combined;\r\nBUG_ON(!div_value);\r\nBUG_ON(billionths >= BILLION);\r\ncombined = (u64)div_value * BILLION + billionths;\r\ncombined <<= div->u.s.frac_width;\r\nreturn do_div_round_closest(combined, BILLION);\r\n}\r\nstatic inline u64\r\nscaled_div_min(struct bcm_clk_div *div)\r\n{\r\nif (divider_is_fixed(div))\r\nreturn (u64)div->u.fixed;\r\nreturn scaled_div_value(div, 0);\r\n}\r\nu64 scaled_div_max(struct bcm_clk_div *div)\r\n{\r\nu32 reg_div;\r\nif (divider_is_fixed(div))\r\nreturn (u64)div->u.fixed;\r\nreg_div = ((u32)1 << div->u.s.width) - 1;\r\nreturn scaled_div_value(div, reg_div);\r\n}\r\nstatic inline u32\r\ndivider(struct bcm_clk_div *div, u64 scaled_div)\r\n{\r\nBUG_ON(scaled_div < scaled_div_min(div));\r\nBUG_ON(scaled_div > scaled_div_max(div));\r\nreturn (u32)(scaled_div - ((u64)1 << div->u.s.frac_width));\r\n}\r\nstatic inline u64\r\nscale_rate(struct bcm_clk_div *div, u32 rate)\r\n{\r\nif (divider_is_fixed(div))\r\nreturn (u64)rate;\r\nreturn (u64)rate << div->u.s.frac_width;\r\n}\r\nstatic inline u32 __ccu_read(struct ccu_data *ccu, u32 reg_offset)\r\n{\r\nreturn readl(ccu->base + reg_offset);\r\n}\r\nstatic inline void\r\n__ccu_write(struct ccu_data *ccu, u32 reg_offset, u32 reg_val)\r\n{\r\nwritel(reg_val, ccu->base + reg_offset);\r\n}\r\nstatic inline unsigned long ccu_lock(struct ccu_data *ccu)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ccu->lock, flags);\r\nreturn flags;\r\n}\r\nstatic inline void ccu_unlock(struct ccu_data *ccu, unsigned long flags)\r\n{\r\nspin_unlock_irqrestore(&ccu->lock, flags);\r\n}\r\nstatic inline void __ccu_write_enable(struct ccu_data *ccu)\r\n{\r\nif (ccu->write_enabled) {\r\npr_err("%s: access already enabled for %s\n", __func__,\r\nccu->name);\r\nreturn;\r\n}\r\nccu->write_enabled = true;\r\n__ccu_write(ccu, 0, CCU_ACCESS_PASSWORD | 1);\r\n}\r\nstatic inline void __ccu_write_disable(struct ccu_data *ccu)\r\n{\r\nif (!ccu->write_enabled) {\r\npr_err("%s: access wasn't enabled for %s\n", __func__,\r\nccu->name);\r\nreturn;\r\n}\r\n__ccu_write(ccu, 0, CCU_ACCESS_PASSWORD);\r\nccu->write_enabled = false;\r\n}\r\nstatic inline bool\r\n__ccu_wait_bit(struct ccu_data *ccu, u32 reg_offset, u32 bit, bool want)\r\n{\r\nunsigned int tries;\r\nu32 bit_mask = 1 << bit;\r\nfor (tries = 0; tries < CLK_GATE_DELAY_LOOP; tries++) {\r\nu32 val;\r\nbool bit_val;\r\nval = __ccu_read(ccu, reg_offset);\r\nbit_val = (val & bit_mask) != 0;\r\nif (bit_val == want)\r\nreturn true;\r\nudelay(1);\r\n}\r\npr_warn("%s: %s/0x%04x bit %u was never %s\n", __func__,\r\nccu->name, reg_offset, bit, want ? "set" : "clear");\r\nreturn false;\r\n}\r\nstatic bool __ccu_policy_engine_start(struct ccu_data *ccu, bool sync)\r\n{\r\nstruct bcm_policy_ctl *control = &ccu->policy.control;\r\nu32 offset;\r\nu32 go_bit;\r\nu32 mask;\r\nbool ret;\r\nif (!policy_ctl_exists(control))\r\nreturn true;\r\noffset = control->offset;\r\ngo_bit = control->go_bit;\r\nret = __ccu_wait_bit(ccu, offset, go_bit, false);\r\nif (!ret) {\r\npr_err("%s: ccu %s policy engine wouldn't go idle\n",\r\n__func__, ccu->name);\r\nreturn false;\r\n}\r\nmask = (u32)1 << go_bit;\r\nif (sync)\r\nmask |= 1 << control->atl_bit;\r\nelse\r\nmask |= 1 << control->ac_bit;\r\n__ccu_write(ccu, offset, mask);\r\nret = __ccu_wait_bit(ccu, offset, go_bit, false);\r\nif (!ret)\r\npr_err("%s: ccu %s policy engine never started\n",\r\n__func__, ccu->name);\r\nreturn ret;\r\n}\r\nstatic bool __ccu_policy_engine_stop(struct ccu_data *ccu)\r\n{\r\nstruct bcm_lvm_en *enable = &ccu->policy.enable;\r\nu32 offset;\r\nu32 enable_bit;\r\nbool ret;\r\nif (!policy_lvm_en_exists(enable))\r\nreturn true;\r\noffset = enable->offset;\r\nenable_bit = enable->bit;\r\nret = __ccu_wait_bit(ccu, offset, enable_bit, false);\r\nif (!ret) {\r\npr_err("%s: ccu %s policy engine already stopped\n",\r\n__func__, ccu->name);\r\nreturn false;\r\n}\r\n__ccu_write(ccu, offset, (u32)1 << enable_bit);\r\nret = __ccu_wait_bit(ccu, offset, enable_bit, false);\r\nif (!ret)\r\npr_err("%s: ccu %s policy engine never stopped\n",\r\n__func__, ccu->name);\r\nreturn ret;\r\n}\r\nstatic bool policy_init(struct ccu_data *ccu, struct bcm_clk_policy *policy)\r\n{\r\nu32 offset;\r\nu32 mask;\r\nint i;\r\nbool ret;\r\nif (!policy_exists(policy))\r\nreturn true;\r\nif (!__ccu_policy_engine_stop(ccu)) {\r\npr_err("%s: unable to stop CCU %s policy engine\n",\r\n__func__, ccu->name);\r\nreturn false;\r\n}\r\noffset = policy->offset;\r\nmask = (u32)1 << policy->bit;\r\nfor (i = 0; i < CCU_POLICY_COUNT; i++) {\r\nu32 reg_val;\r\nreg_val = __ccu_read(ccu, offset);\r\nreg_val |= mask;\r\n__ccu_write(ccu, offset, reg_val);\r\noffset += sizeof(u32);\r\n}\r\nret = __ccu_policy_engine_start(ccu, true);\r\nif (!ret)\r\npr_err("%s: unable to restart CCU %s policy engine\n",\r\n__func__, ccu->name);\r\nreturn ret;\r\n}\r\nstatic bool\r\n__is_clk_gate_enabled(struct ccu_data *ccu, struct bcm_clk_gate *gate)\r\n{\r\nu32 bit_mask;\r\nu32 reg_val;\r\nif (!gate_exists(gate))\r\nreturn true;\r\nbit_mask = 1 << gate->status_bit;\r\nreg_val = __ccu_read(ccu, gate->offset);\r\nreturn (reg_val & bit_mask) != 0;\r\n}\r\nstatic bool\r\nis_clk_gate_enabled(struct ccu_data *ccu, struct bcm_clk_gate *gate)\r\n{\r\nlong flags;\r\nbool ret;\r\nif (!gate_exists(gate))\r\nreturn true;\r\nflags = ccu_lock(ccu);\r\nret = __is_clk_gate_enabled(ccu, gate);\r\nccu_unlock(ccu, flags);\r\nreturn ret;\r\n}\r\nstatic bool\r\n__gate_commit(struct ccu_data *ccu, struct bcm_clk_gate *gate)\r\n{\r\nu32 reg_val;\r\nu32 mask;\r\nbool enabled = false;\r\nBUG_ON(!gate_exists(gate));\r\nif (!gate_is_sw_controllable(gate))\r\nreturn true;\r\nreg_val = __ccu_read(ccu, gate->offset);\r\nif (gate_is_hw_controllable(gate)) {\r\nmask = (u32)1 << gate->hw_sw_sel_bit;\r\nif (gate_is_sw_managed(gate))\r\nreg_val |= mask;\r\nelse\r\nreg_val &= ~mask;\r\n}\r\nmask = (u32)1 << gate->en_bit;\r\nif (gate_is_sw_managed(gate) && (enabled = gate_is_enabled(gate)) &&\r\n!gate_is_no_disable(gate))\r\nreg_val |= mask;\r\nelse\r\nreg_val &= ~mask;\r\n__ccu_write(ccu, gate->offset, reg_val);\r\nif (!gate_is_sw_managed(gate))\r\nreturn true;\r\nreturn __ccu_wait_bit(ccu, gate->offset, gate->status_bit, enabled);\r\n}\r\nstatic bool gate_init(struct ccu_data *ccu, struct bcm_clk_gate *gate)\r\n{\r\nif (!gate_exists(gate))\r\nreturn true;\r\nreturn __gate_commit(ccu, gate);\r\n}\r\nstatic bool\r\n__clk_gate(struct ccu_data *ccu, struct bcm_clk_gate *gate, bool enable)\r\n{\r\nbool ret;\r\nif (!gate_exists(gate) || !gate_is_sw_managed(gate))\r\nreturn true;\r\nif (!enable && gate_is_no_disable(gate)) {\r\npr_warn("%s: invalid gate disable request (ignoring)\n",\r\n__func__);\r\nreturn true;\r\n}\r\nif (enable == gate_is_enabled(gate))\r\nreturn true;\r\ngate_flip_enabled(gate);\r\nret = __gate_commit(ccu, gate);\r\nif (!ret)\r\ngate_flip_enabled(gate);\r\nreturn ret;\r\n}\r\nstatic int clk_gate(struct ccu_data *ccu, const char *name,\r\nstruct bcm_clk_gate *gate, bool enable)\r\n{\r\nunsigned long flags;\r\nbool success;\r\nif (!gate_exists(gate) || !gate_is_sw_managed(gate))\r\nreturn 0;\r\nif (!enable && gate_is_no_disable(gate))\r\nreturn 0;\r\nflags = ccu_lock(ccu);\r\n__ccu_write_enable(ccu);\r\nsuccess = __clk_gate(ccu, gate, enable);\r\n__ccu_write_disable(ccu);\r\nccu_unlock(ccu, flags);\r\nif (success)\r\nreturn 0;\r\npr_err("%s: failed to %s gate for %s\n", __func__,\r\nenable ? "enable" : "disable", name);\r\nreturn -EIO;\r\n}\r\nstatic bool hyst_init(struct ccu_data *ccu, struct bcm_clk_hyst *hyst)\r\n{\r\nu32 offset;\r\nu32 reg_val;\r\nu32 mask;\r\nif (!hyst_exists(hyst))\r\nreturn true;\r\noffset = hyst->offset;\r\nmask = (u32)1 << hyst->en_bit;\r\nmask |= (u32)1 << hyst->val_bit;\r\nreg_val = __ccu_read(ccu, offset);\r\nreg_val |= mask;\r\n__ccu_write(ccu, offset, reg_val);\r\nreturn true;\r\n}\r\nstatic bool __clk_trigger(struct ccu_data *ccu, struct bcm_clk_trig *trig)\r\n{\r\n__ccu_write(ccu, trig->offset, 1 << trig->bit);\r\nreturn __ccu_wait_bit(ccu, trig->offset, trig->bit, false);\r\n}\r\nstatic u64 divider_read_scaled(struct ccu_data *ccu, struct bcm_clk_div *div)\r\n{\r\nunsigned long flags;\r\nu32 reg_val;\r\nu32 reg_div;\r\nif (divider_is_fixed(div))\r\nreturn (u64)div->u.fixed;\r\nflags = ccu_lock(ccu);\r\nreg_val = __ccu_read(ccu, div->u.s.offset);\r\nccu_unlock(ccu, flags);\r\nreg_div = bitfield_extract(reg_val, div->u.s.shift, div->u.s.width);\r\nreturn scaled_div_value(div, reg_div);\r\n}\r\nstatic int __div_commit(struct ccu_data *ccu, struct bcm_clk_gate *gate,\r\nstruct bcm_clk_div *div, struct bcm_clk_trig *trig)\r\n{\r\nbool enabled;\r\nu32 reg_div;\r\nu32 reg_val;\r\nint ret = 0;\r\nBUG_ON(divider_is_fixed(div));\r\nif (div->u.s.scaled_div == BAD_SCALED_DIV_VALUE) {\r\nreg_val = __ccu_read(ccu, div->u.s.offset);\r\nreg_div = bitfield_extract(reg_val, div->u.s.shift,\r\ndiv->u.s.width);\r\ndiv->u.s.scaled_div = scaled_div_value(div, reg_div);\r\nreturn 0;\r\n}\r\nreg_div = divider(div, div->u.s.scaled_div);\r\nenabled = __is_clk_gate_enabled(ccu, gate);\r\nif (!enabled && !__clk_gate(ccu, gate, true)) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nreg_val = __ccu_read(ccu, div->u.s.offset);\r\nreg_val = bitfield_replace(reg_val, div->u.s.shift, div->u.s.width,\r\nreg_div);\r\n__ccu_write(ccu, div->u.s.offset, reg_val);\r\nif (!__clk_trigger(ccu, trig))\r\nret = -EIO;\r\nif (!enabled && !__clk_gate(ccu, gate, false))\r\nret = ret ? ret : -ENXIO;\r\nout:\r\nreturn ret;\r\n}\r\nstatic bool div_init(struct ccu_data *ccu, struct bcm_clk_gate *gate,\r\nstruct bcm_clk_div *div, struct bcm_clk_trig *trig)\r\n{\r\nif (!divider_exists(div) || divider_is_fixed(div))\r\nreturn true;\r\nreturn !__div_commit(ccu, gate, div, trig);\r\n}\r\nstatic int divider_write(struct ccu_data *ccu, struct bcm_clk_gate *gate,\r\nstruct bcm_clk_div *div, struct bcm_clk_trig *trig,\r\nu64 scaled_div)\r\n{\r\nunsigned long flags;\r\nu64 previous;\r\nint ret;\r\nBUG_ON(divider_is_fixed(div));\r\nprevious = div->u.s.scaled_div;\r\nif (previous == scaled_div)\r\nreturn 0;\r\ndiv->u.s.scaled_div = scaled_div;\r\nflags = ccu_lock(ccu);\r\n__ccu_write_enable(ccu);\r\nret = __div_commit(ccu, gate, div, trig);\r\n__ccu_write_disable(ccu);\r\nccu_unlock(ccu, flags);\r\nif (ret)\r\ndiv->u.s.scaled_div = previous;\r\nreturn ret;\r\n}\r\nstatic unsigned long clk_recalc_rate(struct ccu_data *ccu,\r\nstruct bcm_clk_div *div, struct bcm_clk_div *pre_div,\r\nunsigned long parent_rate)\r\n{\r\nu64 scaled_parent_rate;\r\nu64 scaled_div;\r\nu64 result;\r\nif (!divider_exists(div))\r\nreturn parent_rate;\r\nif (parent_rate > (unsigned long)LONG_MAX)\r\nreturn 0;\r\nif (pre_div && divider_exists(pre_div)) {\r\nu64 scaled_rate;\r\nscaled_rate = scale_rate(pre_div, parent_rate);\r\nscaled_rate = scale_rate(div, scaled_rate);\r\nscaled_div = divider_read_scaled(ccu, pre_div);\r\nscaled_parent_rate = do_div_round_closest(scaled_rate,\r\nscaled_div);\r\n} else {\r\nscaled_parent_rate = scale_rate(div, parent_rate);\r\n}\r\nscaled_div = divider_read_scaled(ccu, div);\r\nresult = do_div_round_closest(scaled_parent_rate, scaled_div);\r\nreturn (unsigned long)result;\r\n}\r\nstatic long round_rate(struct ccu_data *ccu, struct bcm_clk_div *div,\r\nstruct bcm_clk_div *pre_div,\r\nunsigned long rate, unsigned long parent_rate,\r\nu64 *scaled_div)\r\n{\r\nu64 scaled_parent_rate;\r\nu64 min_scaled_div;\r\nu64 max_scaled_div;\r\nu64 best_scaled_div;\r\nu64 result;\r\nBUG_ON(!divider_exists(div));\r\nBUG_ON(!rate);\r\nBUG_ON(parent_rate > (u64)LONG_MAX);\r\nif (divider_exists(pre_div)) {\r\nu64 scaled_rate;\r\nu64 scaled_pre_div;\r\nscaled_rate = scale_rate(pre_div, parent_rate);\r\nscaled_rate = scale_rate(div, scaled_rate);\r\nscaled_pre_div = divider_read_scaled(ccu, pre_div);\r\nscaled_parent_rate = do_div_round_closest(scaled_rate,\r\nscaled_pre_div);\r\n} else {\r\nscaled_parent_rate = scale_rate(div, parent_rate);\r\n}\r\nif (!divider_is_fixed(div)) {\r\nbest_scaled_div = do_div_round_closest(scaled_parent_rate,\r\nrate);\r\nmin_scaled_div = scaled_div_min(div);\r\nmax_scaled_div = scaled_div_max(div);\r\nif (best_scaled_div > max_scaled_div)\r\nbest_scaled_div = max_scaled_div;\r\nelse if (best_scaled_div < min_scaled_div)\r\nbest_scaled_div = min_scaled_div;\r\n} else {\r\nbest_scaled_div = divider_read_scaled(ccu, div);\r\n}\r\nresult = do_div_round_closest(scaled_parent_rate, best_scaled_div);\r\nif (scaled_div)\r\n*scaled_div = best_scaled_div;\r\nreturn (long)result;\r\n}\r\nstatic u8 parent_index(struct bcm_clk_sel *sel, u8 parent_sel)\r\n{\r\nu8 i;\r\nBUG_ON(sel->parent_count > (u32)U8_MAX);\r\nfor (i = 0; i < sel->parent_count; i++)\r\nif (sel->parent_sel[i] == parent_sel)\r\nreturn i;\r\nreturn BAD_CLK_INDEX;\r\n}\r\nstatic u8 selector_read_index(struct ccu_data *ccu, struct bcm_clk_sel *sel)\r\n{\r\nunsigned long flags;\r\nu32 reg_val;\r\nu32 parent_sel;\r\nu8 index;\r\nif (!selector_exists(sel))\r\nreturn 0;\r\nflags = ccu_lock(ccu);\r\nreg_val = __ccu_read(ccu, sel->offset);\r\nccu_unlock(ccu, flags);\r\nparent_sel = bitfield_extract(reg_val, sel->shift, sel->width);\r\nindex = parent_index(sel, parent_sel);\r\nif (index == BAD_CLK_INDEX)\r\npr_err("%s: out-of-range parent selector %u (%s 0x%04x)\n",\r\n__func__, parent_sel, ccu->name, sel->offset);\r\nreturn index;\r\n}\r\nstatic int\r\n__sel_commit(struct ccu_data *ccu, struct bcm_clk_gate *gate,\r\nstruct bcm_clk_sel *sel, struct bcm_clk_trig *trig)\r\n{\r\nu32 parent_sel;\r\nu32 reg_val;\r\nbool enabled;\r\nint ret = 0;\r\nBUG_ON(!selector_exists(sel));\r\nif (sel->clk_index == BAD_CLK_INDEX) {\r\nu8 index;\r\nreg_val = __ccu_read(ccu, sel->offset);\r\nparent_sel = bitfield_extract(reg_val, sel->shift, sel->width);\r\nindex = parent_index(sel, parent_sel);\r\nif (index == BAD_CLK_INDEX)\r\nreturn -EINVAL;\r\nsel->clk_index = index;\r\nreturn 0;\r\n}\r\nBUG_ON((u32)sel->clk_index >= sel->parent_count);\r\nparent_sel = sel->parent_sel[sel->clk_index];\r\nenabled = __is_clk_gate_enabled(ccu, gate);\r\nif (!enabled && !__clk_gate(ccu, gate, true))\r\nreturn -ENXIO;\r\nreg_val = __ccu_read(ccu, sel->offset);\r\nreg_val = bitfield_replace(reg_val, sel->shift, sel->width, parent_sel);\r\n__ccu_write(ccu, sel->offset, reg_val);\r\nif (!__clk_trigger(ccu, trig))\r\nret = -EIO;\r\nif (!enabled && !__clk_gate(ccu, gate, false))\r\nret = ret ? ret : -ENXIO;\r\nreturn ret;\r\n}\r\nstatic bool sel_init(struct ccu_data *ccu, struct bcm_clk_gate *gate,\r\nstruct bcm_clk_sel *sel, struct bcm_clk_trig *trig)\r\n{\r\nif (!selector_exists(sel))\r\nreturn true;\r\nreturn !__sel_commit(ccu, gate, sel, trig);\r\n}\r\nstatic int selector_write(struct ccu_data *ccu, struct bcm_clk_gate *gate,\r\nstruct bcm_clk_sel *sel, struct bcm_clk_trig *trig,\r\nu8 index)\r\n{\r\nunsigned long flags;\r\nu8 previous;\r\nint ret;\r\nprevious = sel->clk_index;\r\nif (previous == index)\r\nreturn 0;\r\nsel->clk_index = index;\r\nflags = ccu_lock(ccu);\r\n__ccu_write_enable(ccu);\r\nret = __sel_commit(ccu, gate, sel, trig);\r\n__ccu_write_disable(ccu);\r\nccu_unlock(ccu, flags);\r\nif (ret)\r\nsel->clk_index = previous;\r\nreturn ret;\r\n}\r\nstatic int kona_peri_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct bcm_clk_gate *gate = &bcm_clk->u.peri->gate;\r\nreturn clk_gate(bcm_clk->ccu, bcm_clk->init_data.name, gate, true);\r\n}\r\nstatic void kona_peri_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct bcm_clk_gate *gate = &bcm_clk->u.peri->gate;\r\n(void)clk_gate(bcm_clk->ccu, bcm_clk->init_data.name, gate, false);\r\n}\r\nstatic int kona_peri_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct bcm_clk_gate *gate = &bcm_clk->u.peri->gate;\r\nreturn is_clk_gate_enabled(bcm_clk->ccu, gate) ? 1 : 0;\r\n}\r\nstatic unsigned long kona_peri_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct peri_clk_data *data = bcm_clk->u.peri;\r\nreturn clk_recalc_rate(bcm_clk->ccu, &data->div, &data->pre_div,\r\nparent_rate);\r\n}\r\nstatic long kona_peri_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct bcm_clk_div *div = &bcm_clk->u.peri->div;\r\nif (!divider_exists(div))\r\nreturn __clk_get_rate(hw->clk);\r\nreturn round_rate(bcm_clk->ccu, div, &bcm_clk->u.peri->pre_div,\r\nrate ? rate : 1, *parent_rate, NULL);\r\n}\r\nstatic long kona_peri_clk_determine_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *best_parent_rate, struct clk **best_parent)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct clk *clk = hw->clk;\r\nstruct clk *current_parent;\r\nunsigned long parent_rate;\r\nunsigned long best_delta;\r\nunsigned long best_rate;\r\nu32 parent_count;\r\nu32 which;\r\nWARN_ON_ONCE(bcm_clk->init_data.flags & CLK_SET_RATE_NO_REPARENT);\r\nparent_count = (u32)bcm_clk->init_data.num_parents;\r\nif (parent_count < 2)\r\nreturn kona_peri_clk_round_rate(hw, rate, best_parent_rate);\r\ncurrent_parent = clk_get_parent(clk);\r\nparent_rate = __clk_get_rate(current_parent);\r\nbest_rate = kona_peri_clk_round_rate(hw, rate, &parent_rate);\r\nbest_delta = abs(best_rate - rate);\r\nfor (which = 0; which < parent_count; which++) {\r\nstruct clk *parent = clk_get_parent_by_index(clk, which);\r\nunsigned long delta;\r\nunsigned long other_rate;\r\nBUG_ON(!parent);\r\nif (parent == current_parent)\r\ncontinue;\r\nparent_rate = __clk_get_rate(parent);\r\nother_rate = kona_peri_clk_round_rate(hw, rate, &parent_rate);\r\ndelta = abs(other_rate - rate);\r\nif (delta < best_delta) {\r\nbest_delta = delta;\r\nbest_rate = other_rate;\r\n*best_parent = parent;\r\n*best_parent_rate = parent_rate;\r\n}\r\n}\r\nreturn best_rate;\r\n}\r\nstatic int kona_peri_clk_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct peri_clk_data *data = bcm_clk->u.peri;\r\nstruct bcm_clk_sel *sel = &data->sel;\r\nstruct bcm_clk_trig *trig;\r\nint ret;\r\nBUG_ON(index >= sel->parent_count);\r\nif (!selector_exists(sel))\r\nreturn 0;\r\ntrig = trigger_exists(&data->pre_trig) ? &data->pre_trig\r\n: &data->trig;\r\nret = selector_write(bcm_clk->ccu, &data->gate, sel, trig, index);\r\nif (ret == -ENXIO) {\r\npr_err("%s: gating failure for %s\n", __func__,\r\nbcm_clk->init_data.name);\r\nret = -EIO;\r\n} else if (ret == -EIO) {\r\npr_err("%s: %strigger failed for %s\n", __func__,\r\ntrig == &data->pre_trig ? "pre-" : "",\r\nbcm_clk->init_data.name);\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 kona_peri_clk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct peri_clk_data *data = bcm_clk->u.peri;\r\nu8 index;\r\nindex = selector_read_index(bcm_clk->ccu, &data->sel);\r\nreturn index == BAD_CLK_INDEX ? 0 : index;\r\n}\r\nstatic int kona_peri_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct kona_clk *bcm_clk = to_kona_clk(hw);\r\nstruct peri_clk_data *data = bcm_clk->u.peri;\r\nstruct bcm_clk_div *div = &data->div;\r\nu64 scaled_div = 0;\r\nint ret;\r\nif (parent_rate > (unsigned long)LONG_MAX)\r\nreturn -EINVAL;\r\nif (rate == __clk_get_rate(hw->clk))\r\nreturn 0;\r\nif (!divider_exists(div))\r\nreturn rate == parent_rate ? 0 : -EINVAL;\r\nif (divider_is_fixed(&data->div))\r\nreturn rate == parent_rate ? 0 : -EINVAL;\r\n(void)round_rate(bcm_clk->ccu, div, &data->pre_div,\r\nrate ? rate : 1, parent_rate, &scaled_div);\r\nret = divider_write(bcm_clk->ccu, &data->gate, &data->div,\r\n&data->trig, scaled_div);\r\nif (ret == -ENXIO) {\r\npr_err("%s: gating failure for %s\n", __func__,\r\nbcm_clk->init_data.name);\r\nret = -EIO;\r\n} else if (ret == -EIO) {\r\npr_err("%s: trigger failed for %s\n", __func__,\r\nbcm_clk->init_data.name);\r\n}\r\nreturn ret;\r\n}\r\nstatic bool __peri_clk_init(struct kona_clk *bcm_clk)\r\n{\r\nstruct ccu_data *ccu = bcm_clk->ccu;\r\nstruct peri_clk_data *peri = bcm_clk->u.peri;\r\nconst char *name = bcm_clk->init_data.name;\r\nstruct bcm_clk_trig *trig;\r\nBUG_ON(bcm_clk->type != bcm_clk_peri);\r\nif (!policy_init(ccu, &peri->policy)) {\r\npr_err("%s: error initializing policy for %s\n",\r\n__func__, name);\r\nreturn false;\r\n}\r\nif (!gate_init(ccu, &peri->gate)) {\r\npr_err("%s: error initializing gate for %s\n", __func__, name);\r\nreturn false;\r\n}\r\nif (!hyst_init(ccu, &peri->hyst)) {\r\npr_err("%s: error initializing hyst for %s\n", __func__, name);\r\nreturn false;\r\n}\r\nif (!div_init(ccu, &peri->gate, &peri->div, &peri->trig)) {\r\npr_err("%s: error initializing divider for %s\n", __func__,\r\nname);\r\nreturn false;\r\n}\r\ntrig = trigger_exists(&peri->pre_trig) ? &peri->pre_trig\r\n: &peri->trig;\r\nif (!div_init(ccu, &peri->gate, &peri->pre_div, trig)) {\r\npr_err("%s: error initializing pre-divider for %s\n", __func__,\r\nname);\r\nreturn false;\r\n}\r\nif (!sel_init(ccu, &peri->gate, &peri->sel, trig)) {\r\npr_err("%s: error initializing selector for %s\n", __func__,\r\nname);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool __kona_clk_init(struct kona_clk *bcm_clk)\r\n{\r\nswitch (bcm_clk->type) {\r\ncase bcm_clk_peri:\r\nreturn __peri_clk_init(bcm_clk);\r\ndefault:\r\nBUG();\r\n}\r\nreturn -EINVAL;\r\n}\r\nbool __init kona_ccu_init(struct ccu_data *ccu)\r\n{\r\nunsigned long flags;\r\nunsigned int which;\r\nstruct clk **clks = ccu->clk_data.clks;\r\nbool success = true;\r\nflags = ccu_lock(ccu);\r\n__ccu_write_enable(ccu);\r\nfor (which = 0; which < ccu->clk_data.clk_num; which++) {\r\nstruct kona_clk *bcm_clk;\r\nif (!clks[which])\r\ncontinue;\r\nbcm_clk = to_kona_clk(__clk_get_hw(clks[which]));\r\nsuccess &= __kona_clk_init(bcm_clk);\r\n}\r\n__ccu_write_disable(ccu);\r\nccu_unlock(ccu, flags);\r\nreturn success;\r\n}
