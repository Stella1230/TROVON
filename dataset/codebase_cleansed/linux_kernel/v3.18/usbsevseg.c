static inline size_t my_memlen(const char *buf, size_t count)\r\n{\r\nif (count > 0 && buf[count-1] == '\n')\r\nreturn count - 1;\r\nelse\r\nreturn count;\r\n}\r\nstatic void update_display_powered(struct usb_sevsegdev *mydev)\r\n{\r\nint rc;\r\nif (mydev->powered && !mydev->has_interface_pm) {\r\nrc = usb_autopm_get_interface(mydev->intf);\r\nif (rc < 0)\r\nreturn;\r\nmydev->has_interface_pm = 1;\r\n}\r\nif (mydev->shadow_power != 1)\r\nreturn;\r\nrc = usb_control_msg(mydev->udev,\r\nusb_sndctrlpipe(mydev->udev, 0),\r\n0x12,\r\n0x48,\r\n(80 * 0x100) + 10,\r\n(0x00 * 0x100) + (mydev->powered ? 1 : 0),\r\nNULL,\r\n0,\r\n2000);\r\nif (rc < 0)\r\ndev_dbg(&mydev->udev->dev, "power retval = %d\n", rc);\r\nif (!mydev->powered && mydev->has_interface_pm) {\r\nusb_autopm_put_interface(mydev->intf);\r\nmydev->has_interface_pm = 0;\r\n}\r\n}\r\nstatic void update_display_mode(struct usb_sevsegdev *mydev)\r\n{\r\nint rc;\r\nif(mydev->shadow_power != 1)\r\nreturn;\r\nrc = usb_control_msg(mydev->udev,\r\nusb_sndctrlpipe(mydev->udev, 0),\r\n0x12,\r\n0x48,\r\n(82 * 0x100) + 10,\r\n(mydev->mode_msb * 0x100) + mydev->mode_lsb,\r\nNULL,\r\n0,\r\n2000);\r\nif (rc < 0)\r\ndev_dbg(&mydev->udev->dev, "mode retval = %d\n", rc);\r\n}\r\nstatic void update_display_visual(struct usb_sevsegdev *mydev, gfp_t mf)\r\n{\r\nint rc;\r\nint i;\r\nunsigned char *buffer;\r\nu8 decimals = 0;\r\nif(mydev->shadow_power != 1)\r\nreturn;\r\nbuffer = kzalloc(MAXLEN, mf);\r\nif (!buffer) {\r\ndev_err(&mydev->udev->dev, "out of memory\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < mydev->textlength; i++)\r\nbuffer[i] = mydev->text[mydev->textlength-1-i];\r\nrc = usb_control_msg(mydev->udev,\r\nusb_sndctrlpipe(mydev->udev, 0),\r\n0x12,\r\n0x48,\r\n(85 * 0x100) + 10,\r\n(0 * 0x100) + mydev->textmode,\r\nbuffer,\r\nmydev->textlength,\r\n2000);\r\nif (rc < 0)\r\ndev_dbg(&mydev->udev->dev, "write retval = %d\n", rc);\r\nkfree(buffer);\r\nfor (i = 0; i < sizeof(mydev->decimals); i++)\r\ndecimals |= mydev->decimals[i] << i;\r\nrc = usb_control_msg(mydev->udev,\r\nusb_sndctrlpipe(mydev->udev, 0),\r\n0x12,\r\n0x48,\r\n(86 * 0x100) + 10,\r\n(0 * 0x100) + decimals,\r\nNULL,\r\n0,\r\n2000);\r\nif (rc < 0)\r\ndev_dbg(&mydev->udev->dev, "decimal retval = %d\n", rc);\r\n}\r\nstatic ssize_t show_attr_text(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\r\nreturn snprintf(buf, mydev->textlength, "%s\n", mydev->text);\r\n}\r\nstatic ssize_t set_attr_text(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\r\nsize_t end = my_memlen(buf, count);\r\nif (end > sizeof(mydev->text))\r\nreturn -EINVAL;\r\nmemset(mydev->text, 0, sizeof(mydev->text));\r\nmydev->textlength = end;\r\nif (end > 0)\r\nmemcpy(mydev->text, buf, end);\r\nupdate_display_visual(mydev, GFP_KERNEL);\r\nreturn count;\r\n}\r\nstatic ssize_t show_attr_decimals(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\r\nint i;\r\nint pos;\r\nfor (i = 0; i < sizeof(mydev->decimals); i++) {\r\npos = sizeof(mydev->decimals) - 1 - i;\r\nif (mydev->decimals[i] == 0)\r\nbuf[pos] = '0';\r\nelse if (mydev->decimals[i] == 1)\r\nbuf[pos] = '1';\r\nelse\r\nbuf[pos] = 'x';\r\n}\r\nbuf[sizeof(mydev->decimals)] = '\n';\r\nreturn sizeof(mydev->decimals) + 1;\r\n}\r\nstatic ssize_t set_attr_decimals(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\r\nsize_t end = my_memlen(buf, count);\r\nint i;\r\nif (end > sizeof(mydev->decimals))\r\nreturn -EINVAL;\r\nfor (i = 0; i < end; i++)\r\nif (buf[i] != '0' && buf[i] != '1')\r\nreturn -EINVAL;\r\nmemset(mydev->decimals, 0, sizeof(mydev->decimals));\r\nfor (i = 0; i < end; i++)\r\nif (buf[i] == '1')\r\nmydev->decimals[end-1-i] = 1;\r\nupdate_display_visual(mydev, GFP_KERNEL);\r\nreturn count;\r\n}\r\nstatic ssize_t show_attr_textmode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\r\nint i;\r\nbuf[0] = 0;\r\nfor (i = 0; display_textmodes[i]; i++) {\r\nif (mydev->textmode == i) {\r\nstrcat(buf, " [");\r\nstrcat(buf, display_textmodes[i]);\r\nstrcat(buf, "] ");\r\n} else {\r\nstrcat(buf, " ");\r\nstrcat(buf, display_textmodes[i]);\r\nstrcat(buf, " ");\r\n}\r\n}\r\nstrcat(buf, "\n");\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t set_attr_textmode(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\r\nint i;\r\nfor (i = 0; display_textmodes[i]; i++) {\r\nif (sysfs_streq(display_textmodes[i], buf)) {\r\nmydev->textmode = i;\r\nupdate_display_visual(mydev, GFP_KERNEL);\r\nreturn count;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sevseg_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_sevsegdev *mydev = NULL;\r\nint rc = -ENOMEM;\r\nmydev = kzalloc(sizeof(struct usb_sevsegdev), GFP_KERNEL);\r\nif (mydev == NULL) {\r\ndev_err(&interface->dev, "Out of memory\n");\r\ngoto error_mem;\r\n}\r\nmydev->udev = usb_get_dev(udev);\r\nmydev->intf = interface;\r\nusb_set_intfdata(interface, mydev);\r\nmydev->shadow_power = 1;\r\nmydev->has_interface_pm = 0;\r\nmydev->textmode = 0x02;\r\nmydev->mode_msb = 0x06;\r\nmydev->mode_lsb = 0x3f;\r\nrc = sysfs_create_group(&interface->dev.kobj, &dev_attr_grp);\r\nif (rc)\r\ngoto error;\r\ndev_info(&interface->dev, "USB 7 Segment device now attached\n");\r\nreturn 0;\r\nerror:\r\nusb_set_intfdata(interface, NULL);\r\nusb_put_dev(mydev->udev);\r\nkfree(mydev);\r\nerror_mem:\r\nreturn rc;\r\n}\r\nstatic void sevseg_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_sevsegdev *mydev;\r\nmydev = usb_get_intfdata(interface);\r\nsysfs_remove_group(&interface->dev.kobj, &dev_attr_grp);\r\nusb_set_intfdata(interface, NULL);\r\nusb_put_dev(mydev->udev);\r\nkfree(mydev);\r\ndev_info(&interface->dev, "USB 7 Segment now disconnected\n");\r\n}\r\nstatic int sevseg_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usb_sevsegdev *mydev;\r\nmydev = usb_get_intfdata(intf);\r\nmydev->shadow_power = 0;\r\nreturn 0;\r\n}\r\nstatic int sevseg_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_sevsegdev *mydev;\r\nmydev = usb_get_intfdata(intf);\r\nmydev->shadow_power = 1;\r\nupdate_display_mode(mydev);\r\nupdate_display_visual(mydev, GFP_NOIO);\r\nreturn 0;\r\n}\r\nstatic int sevseg_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_sevsegdev *mydev;\r\nmydev = usb_get_intfdata(intf);\r\nmydev->shadow_power = 1;\r\nupdate_display_mode(mydev);\r\nupdate_display_visual(mydev, GFP_NOIO);\r\nreturn 0;\r\n}
