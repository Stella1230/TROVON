static int pefile_parse_binary(const void *pebuf, unsigned int pelen,\r\nstruct pefile_context *ctx)\r\n{\r\nconst struct mz_hdr *mz = pebuf;\r\nconst struct pe_hdr *pe;\r\nconst struct pe32_opt_hdr *pe32;\r\nconst struct pe32plus_opt_hdr *pe64;\r\nconst struct data_directory *ddir;\r\nconst struct data_dirent *dde;\r\nconst struct section_header *secs, *sec;\r\nsize_t cursor, datalen = pelen;\r\nkenter("");\r\n#define chkaddr(base, x, s) \\r\ndo { \\r\nif ((x) < base || (s) >= datalen || (x) > datalen - (s)) \\r\nreturn -ELIBBAD; \\r\n} while (0)\r\nchkaddr(0, 0, sizeof(*mz));\r\nif (mz->magic != MZ_MAGIC)\r\nreturn -ELIBBAD;\r\ncursor = sizeof(*mz);\r\nchkaddr(cursor, mz->peaddr, sizeof(*pe));\r\npe = pebuf + mz->peaddr;\r\nif (pe->magic != PE_MAGIC)\r\nreturn -ELIBBAD;\r\ncursor = mz->peaddr + sizeof(*pe);\r\nchkaddr(0, cursor, sizeof(pe32->magic));\r\npe32 = pebuf + cursor;\r\npe64 = pebuf + cursor;\r\nswitch (pe32->magic) {\r\ncase PE_OPT_MAGIC_PE32:\r\nchkaddr(0, cursor, sizeof(*pe32));\r\nctx->image_checksum_offset =\r\n(unsigned long)&pe32->csum - (unsigned long)pebuf;\r\nctx->header_size = pe32->header_size;\r\ncursor += sizeof(*pe32);\r\nctx->n_data_dirents = pe32->data_dirs;\r\nbreak;\r\ncase PE_OPT_MAGIC_PE32PLUS:\r\nchkaddr(0, cursor, sizeof(*pe64));\r\nctx->image_checksum_offset =\r\n(unsigned long)&pe64->csum - (unsigned long)pebuf;\r\nctx->header_size = pe64->header_size;\r\ncursor += sizeof(*pe64);\r\nctx->n_data_dirents = pe64->data_dirs;\r\nbreak;\r\ndefault:\r\npr_debug("Unknown PEOPT magic = %04hx\n", pe32->magic);\r\nreturn -ELIBBAD;\r\n}\r\npr_debug("checksum @ %x\n", ctx->image_checksum_offset);\r\npr_debug("header size = %x\n", ctx->header_size);\r\nif (cursor >= ctx->header_size || ctx->header_size >= datalen)\r\nreturn -ELIBBAD;\r\nif (ctx->n_data_dirents > (ctx->header_size - cursor) / sizeof(*dde))\r\nreturn -ELIBBAD;\r\nddir = pebuf + cursor;\r\ncursor += sizeof(*dde) * ctx->n_data_dirents;\r\nctx->cert_dirent_offset =\r\n(unsigned long)&ddir->certs - (unsigned long)pebuf;\r\nctx->certs_size = ddir->certs.size;\r\nif (!ddir->certs.virtual_address || !ddir->certs.size) {\r\npr_debug("Unsigned PE binary\n");\r\nreturn -EKEYREJECTED;\r\n}\r\nchkaddr(ctx->header_size, ddir->certs.virtual_address,\r\nddir->certs.size);\r\nctx->sig_offset = ddir->certs.virtual_address;\r\nctx->sig_len = ddir->certs.size;\r\npr_debug("cert = %x @%x [%*ph]\n",\r\nctx->sig_len, ctx->sig_offset,\r\nctx->sig_len, pebuf + ctx->sig_offset);\r\nctx->n_sections = pe->sections;\r\nif (ctx->n_sections > (ctx->header_size - cursor) / sizeof(*sec))\r\nreturn -ELIBBAD;\r\nctx->secs = secs = pebuf + cursor;\r\nreturn 0;\r\n}\r\nstatic int pefile_strip_sig_wrapper(const void *pebuf,\r\nstruct pefile_context *ctx)\r\n{\r\nstruct win_certificate wrapper;\r\nconst u8 *pkcs7;\r\nunsigned len;\r\nif (ctx->sig_len < sizeof(wrapper)) {\r\npr_debug("Signature wrapper too short\n");\r\nreturn -ELIBBAD;\r\n}\r\nmemcpy(&wrapper, pebuf + ctx->sig_offset, sizeof(wrapper));\r\npr_debug("sig wrapper = { %x, %x, %x }\n",\r\nwrapper.length, wrapper.revision, wrapper.cert_type);\r\nif (round_up(wrapper.length, 8) != ctx->sig_len) {\r\npr_debug("Signature wrapper len wrong\n");\r\nreturn -ELIBBAD;\r\n}\r\nif (wrapper.revision != WIN_CERT_REVISION_2_0) {\r\npr_debug("Signature is not revision 2.0\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (wrapper.cert_type != WIN_CERT_TYPE_PKCS_SIGNED_DATA) {\r\npr_debug("Signature certificate type is not PKCS\n");\r\nreturn -ENOTSUPP;\r\n}\r\nctx->sig_len = wrapper.length;\r\nctx->sig_offset += sizeof(wrapper);\r\nctx->sig_len -= sizeof(wrapper);\r\nif (ctx->sig_len < 4) {\r\npr_debug("Signature data missing\n");\r\nreturn -EKEYREJECTED;\r\n}\r\npkcs7 = pebuf + ctx->sig_offset;\r\nif (pkcs7[0] != (ASN1_CONS_BIT | ASN1_SEQ))\r\ngoto not_pkcs7;\r\nswitch (pkcs7[1]) {\r\ncase 0 ... 0x7f:\r\nlen = pkcs7[1] + 2;\r\ngoto check_len;\r\ncase ASN1_INDEFINITE_LENGTH:\r\nreturn 0;\r\ncase 0x81:\r\nlen = pkcs7[2] + 3;\r\ngoto check_len;\r\ncase 0x82:\r\nlen = ((pkcs7[2] << 8) | pkcs7[3]) + 4;\r\ngoto check_len;\r\ncase 0x83 ... 0xff:\r\nreturn -EMSGSIZE;\r\ndefault:\r\ngoto not_pkcs7;\r\n}\r\ncheck_len:\r\nif (len <= ctx->sig_len) {\r\nctx->sig_len = len;\r\nreturn 0;\r\n}\r\nnot_pkcs7:\r\npr_debug("Signature data not PKCS#7\n");\r\nreturn -ELIBBAD;\r\n}\r\nstatic int pefile_compare_shdrs(const void *a, const void *b)\r\n{\r\nconst struct section_header *shdra = a;\r\nconst struct section_header *shdrb = b;\r\nint rc;\r\nif (shdra->data_addr > shdrb->data_addr)\r\nreturn 1;\r\nif (shdrb->data_addr > shdra->data_addr)\r\nreturn -1;\r\nif (shdra->virtual_address > shdrb->virtual_address)\r\nreturn 1;\r\nif (shdrb->virtual_address > shdra->virtual_address)\r\nreturn -1;\r\nrc = strcmp(shdra->name, shdrb->name);\r\nif (rc != 0)\r\nreturn rc;\r\nif (shdra->virtual_size > shdrb->virtual_size)\r\nreturn 1;\r\nif (shdrb->virtual_size > shdra->virtual_size)\r\nreturn -1;\r\nif (shdra->raw_data_size > shdrb->raw_data_size)\r\nreturn 1;\r\nif (shdrb->raw_data_size > shdra->raw_data_size)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int pefile_digest_pe_contents(const void *pebuf, unsigned int pelen,\r\nstruct pefile_context *ctx,\r\nstruct shash_desc *desc)\r\n{\r\nunsigned *canon, tmp, loop, i, hashed_bytes;\r\nint ret;\r\nret = crypto_shash_update(desc, pebuf, ctx->image_checksum_offset);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = ctx->image_checksum_offset + sizeof(uint32_t);\r\nret = crypto_shash_update(desc, pebuf + tmp,\r\nctx->cert_dirent_offset - tmp);\r\nif (ret < 0)\r\nreturn ret;\r\ntmp = ctx->cert_dirent_offset + sizeof(struct data_dirent);\r\nret = crypto_shash_update(desc, pebuf + tmp, ctx->header_size - tmp);\r\nif (ret < 0)\r\nreturn ret;\r\ncanon = kcalloc(ctx->n_sections, sizeof(unsigned), GFP_KERNEL);\r\nif (!canon)\r\nreturn -ENOMEM;\r\ncanon[0] = 0;\r\nfor (loop = 1; loop < ctx->n_sections; loop++) {\r\nfor (i = 0; i < loop; i++) {\r\nif (pefile_compare_shdrs(&ctx->secs[canon[i]],\r\n&ctx->secs[loop]) > 0) {\r\nmemmove(&canon[i + 1], &canon[i],\r\n(loop - i) * sizeof(canon[0]));\r\nbreak;\r\n}\r\n}\r\ncanon[i] = loop;\r\n}\r\nhashed_bytes = ctx->header_size;\r\nfor (loop = 0; loop < ctx->n_sections; loop++) {\r\ni = canon[loop];\r\nif (ctx->secs[i].raw_data_size == 0)\r\ncontinue;\r\nret = crypto_shash_update(desc,\r\npebuf + ctx->secs[i].data_addr,\r\nctx->secs[i].raw_data_size);\r\nif (ret < 0) {\r\nkfree(canon);\r\nreturn ret;\r\n}\r\nhashed_bytes += ctx->secs[i].raw_data_size;\r\n}\r\nkfree(canon);\r\nif (pelen > hashed_bytes) {\r\ntmp = hashed_bytes + ctx->certs_size;\r\nret = crypto_shash_update(desc,\r\npebuf + hashed_bytes,\r\npelen - tmp);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pefile_digest_pe(const void *pebuf, unsigned int pelen,\r\nstruct pefile_context *ctx)\r\n{\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nsize_t digest_size, desc_size;\r\nvoid *digest;\r\nint ret;\r\nkenter(",%u", ctx->digest_algo);\r\ntfm = crypto_alloc_shash(hash_algo_name[ctx->digest_algo], 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn (PTR_ERR(tfm) == -ENOENT) ? -ENOPKG : PTR_ERR(tfm);\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\ndigest_size = crypto_shash_digestsize(tfm);\r\nif (digest_size != ctx->digest_len) {\r\npr_debug("Digest size mismatch (%zx != %x)\n",\r\ndigest_size, ctx->digest_len);\r\nret = -EBADMSG;\r\ngoto error_no_desc;\r\n}\r\npr_debug("Digest: desc=%zu size=%zu\n", desc_size, digest_size);\r\nret = -ENOMEM;\r\ndesc = kzalloc(desc_size + digest_size, GFP_KERNEL);\r\nif (!desc)\r\ngoto error_no_desc;\r\ndesc->tfm = tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\nret = pefile_digest_pe_contents(pebuf, pelen, ctx, desc);\r\nif (ret < 0)\r\ngoto error;\r\ndigest = (void *)desc + desc_size;\r\nret = crypto_shash_final(desc, digest);\r\nif (ret < 0)\r\ngoto error;\r\npr_debug("Digest calc = [%*ph]\n", ctx->digest_len, digest);\r\nif (memcmp(digest, ctx->digest, ctx->digest_len) != 0) {\r\npr_debug("Digest mismatch\n");\r\nret = -EKEYREJECTED;\r\n} else {\r\npr_debug("The digests match!\n");\r\n}\r\nerror:\r\nkfree(desc);\r\nerror_no_desc:\r\ncrypto_free_shash(tfm);\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint verify_pefile_signature(const void *pebuf, unsigned pelen,\r\nstruct key *trusted_keyring, bool *_trusted)\r\n{\r\nstruct pkcs7_message *pkcs7;\r\nstruct pefile_context ctx;\r\nconst void *data;\r\nsize_t datalen;\r\nint ret;\r\nkenter("");\r\nmemset(&ctx, 0, sizeof(ctx));\r\nret = pefile_parse_binary(pebuf, pelen, &ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pefile_strip_sig_wrapper(pebuf, &ctx);\r\nif (ret < 0)\r\nreturn ret;\r\npkcs7 = pkcs7_parse_message(pebuf + ctx.sig_offset, ctx.sig_len);\r\nif (IS_ERR(pkcs7))\r\nreturn PTR_ERR(pkcs7);\r\nctx.pkcs7 = pkcs7;\r\nret = pkcs7_get_content_data(ctx.pkcs7, &data, &datalen, false);\r\nif (ret < 0 || datalen == 0) {\r\npr_devel("PKCS#7 message does not contain data\n");\r\nret = -EBADMSG;\r\ngoto error;\r\n}\r\nret = mscode_parse(&ctx);\r\nif (ret < 0)\r\ngoto error;\r\npr_debug("Digest: %u [%*ph]\n",\r\nctx.digest_len, ctx.digest_len, ctx.digest);\r\nret = pefile_digest_pe(pebuf, pelen, &ctx);\r\nif (ret < 0)\r\ngoto error;\r\nret = pkcs7_verify(pkcs7);\r\nif (ret < 0)\r\ngoto error;\r\nret = pkcs7_validate_trust(pkcs7, trusted_keyring, _trusted);\r\nerror:\r\npkcs7_free_message(ctx.pkcs7);\r\nreturn ret;\r\n}
