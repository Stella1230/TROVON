static ksock_interface_t *\r\nksocknal_ip2iface(lnet_ni_t *ni, __u32 ip)\r\n{\r\nksock_net_t *net = ni->ni_data;\r\nint i;\r\nksock_interface_t *iface;\r\nfor (i = 0; i < net->ksnn_ninterfaces; i++) {\r\nLASSERT(i < LNET_MAX_INTERFACES);\r\niface = &net->ksnn_interfaces[i];\r\nif (iface->ksni_ipaddr == ip)\r\nreturn iface;\r\n}\r\nreturn NULL;\r\n}\r\nstatic ksock_route_t *\r\nksocknal_create_route (__u32 ipaddr, int port)\r\n{\r\nksock_route_t *route;\r\nLIBCFS_ALLOC (route, sizeof (*route));\r\nif (route == NULL)\r\nreturn NULL;\r\natomic_set (&route->ksnr_refcount, 1);\r\nroute->ksnr_peer = NULL;\r\nroute->ksnr_retry_interval = 0;\r\nroute->ksnr_ipaddr = ipaddr;\r\nroute->ksnr_port = port;\r\nroute->ksnr_scheduled = 0;\r\nroute->ksnr_connecting = 0;\r\nroute->ksnr_connected = 0;\r\nroute->ksnr_deleted = 0;\r\nroute->ksnr_conn_count = 0;\r\nroute->ksnr_share_count = 0;\r\nreturn route;\r\n}\r\nvoid\r\nksocknal_destroy_route (ksock_route_t *route)\r\n{\r\nLASSERT (atomic_read(&route->ksnr_refcount) == 0);\r\nif (route->ksnr_peer != NULL)\r\nksocknal_peer_decref(route->ksnr_peer);\r\nLIBCFS_FREE (route, sizeof (*route));\r\n}\r\nstatic int\r\nksocknal_create_peer (ksock_peer_t **peerp, lnet_ni_t *ni, lnet_process_id_t id)\r\n{\r\nksock_net_t *net = ni->ni_data;\r\nksock_peer_t *peer;\r\nLASSERT (id.nid != LNET_NID_ANY);\r\nLASSERT (id.pid != LNET_PID_ANY);\r\nLASSERT (!in_interrupt());\r\nLIBCFS_ALLOC (peer, sizeof (*peer));\r\nif (peer == NULL)\r\nreturn -ENOMEM;\r\npeer->ksnp_ni = ni;\r\npeer->ksnp_id = id;\r\natomic_set (&peer->ksnp_refcount, 1);\r\npeer->ksnp_closing = 0;\r\npeer->ksnp_accepting = 0;\r\npeer->ksnp_proto = NULL;\r\npeer->ksnp_last_alive = 0;\r\npeer->ksnp_zc_next_cookie = SOCKNAL_KEEPALIVE_PING + 1;\r\nINIT_LIST_HEAD (&peer->ksnp_conns);\r\nINIT_LIST_HEAD (&peer->ksnp_routes);\r\nINIT_LIST_HEAD (&peer->ksnp_tx_queue);\r\nINIT_LIST_HEAD (&peer->ksnp_zc_req_list);\r\nspin_lock_init(&peer->ksnp_lock);\r\nspin_lock_bh(&net->ksnn_lock);\r\nif (net->ksnn_shutdown) {\r\nspin_unlock_bh(&net->ksnn_lock);\r\nLIBCFS_FREE(peer, sizeof(*peer));\r\nCERROR("Can't create peer: network shutdown\n");\r\nreturn -ESHUTDOWN;\r\n}\r\nnet->ksnn_npeers++;\r\nspin_unlock_bh(&net->ksnn_lock);\r\n*peerp = peer;\r\nreturn 0;\r\n}\r\nvoid\r\nksocknal_destroy_peer (ksock_peer_t *peer)\r\n{\r\nksock_net_t *net = peer->ksnp_ni->ni_data;\r\nCDEBUG (D_NET, "peer %s %p deleted\n",\r\nlibcfs_id2str(peer->ksnp_id), peer);\r\nLASSERT (atomic_read (&peer->ksnp_refcount) == 0);\r\nLASSERT (peer->ksnp_accepting == 0);\r\nLASSERT (list_empty (&peer->ksnp_conns));\r\nLASSERT (list_empty (&peer->ksnp_routes));\r\nLASSERT (list_empty (&peer->ksnp_tx_queue));\r\nLASSERT (list_empty (&peer->ksnp_zc_req_list));\r\nLIBCFS_FREE (peer, sizeof (*peer));\r\nspin_lock_bh(&net->ksnn_lock);\r\nnet->ksnn_npeers--;\r\nspin_unlock_bh(&net->ksnn_lock);\r\n}\r\nksock_peer_t *\r\nksocknal_find_peer_locked (lnet_ni_t *ni, lnet_process_id_t id)\r\n{\r\nstruct list_head *peer_list = ksocknal_nid2peerlist(id.nid);\r\nstruct list_head *tmp;\r\nksock_peer_t *peer;\r\nlist_for_each (tmp, peer_list) {\r\npeer = list_entry (tmp, ksock_peer_t, ksnp_list);\r\nLASSERT (!peer->ksnp_closing);\r\nif (peer->ksnp_ni != ni)\r\ncontinue;\r\nif (peer->ksnp_id.nid != id.nid ||\r\npeer->ksnp_id.pid != id.pid)\r\ncontinue;\r\nCDEBUG(D_NET, "got peer [%p] -> %s (%d)\n",\r\npeer, libcfs_id2str(id),\r\natomic_read(&peer->ksnp_refcount));\r\nreturn peer;\r\n}\r\nreturn NULL;\r\n}\r\nksock_peer_t *\r\nksocknal_find_peer (lnet_ni_t *ni, lnet_process_id_t id)\r\n{\r\nksock_peer_t *peer;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\npeer = ksocknal_find_peer_locked(ni, id);\r\nif (peer != NULL)\r\nksocknal_peer_addref(peer);\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn peer;\r\n}\r\nstatic void\r\nksocknal_unlink_peer_locked (ksock_peer_t *peer)\r\n{\r\nint i;\r\n__u32 ip;\r\nksock_interface_t *iface;\r\nfor (i = 0; i < peer->ksnp_n_passive_ips; i++) {\r\nLASSERT (i < LNET_MAX_INTERFACES);\r\nip = peer->ksnp_passive_ips[i];\r\niface = ksocknal_ip2iface(peer->ksnp_ni, ip);\r\nLASSERT (iface != NULL);\r\nCDEBUG(D_NET, "peer=%p iface=%p ksni_nroutes=%d\n",\r\npeer, iface, iface->ksni_nroutes);\r\niface->ksni_npeers--;\r\n}\r\nLASSERT (list_empty(&peer->ksnp_conns));\r\nLASSERT (list_empty(&peer->ksnp_routes));\r\nLASSERT (!peer->ksnp_closing);\r\npeer->ksnp_closing = 1;\r\nlist_del (&peer->ksnp_list);\r\nksocknal_peer_decref(peer);\r\n}\r\nstatic int\r\nksocknal_get_peer_info (lnet_ni_t *ni, int index,\r\nlnet_process_id_t *id, __u32 *myip, __u32 *peer_ip,\r\nint *port, int *conn_count, int *share_count)\r\n{\r\nksock_peer_t *peer;\r\nstruct list_head *ptmp;\r\nksock_route_t *route;\r\nstruct list_head *rtmp;\r\nint i;\r\nint j;\r\nint rc = -ENOENT;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nfor (i = 0; i < ksocknal_data.ksnd_peer_hash_size; i++) {\r\nlist_for_each (ptmp, &ksocknal_data.ksnd_peers[i]) {\r\npeer = list_entry (ptmp, ksock_peer_t, ksnp_list);\r\nif (peer->ksnp_ni != ni)\r\ncontinue;\r\nif (peer->ksnp_n_passive_ips == 0 &&\r\nlist_empty(&peer->ksnp_routes)) {\r\nif (index-- > 0)\r\ncontinue;\r\n*id = peer->ksnp_id;\r\n*myip = 0;\r\n*peer_ip = 0;\r\n*port = 0;\r\n*conn_count = 0;\r\n*share_count = 0;\r\nrc = 0;\r\ngoto out;\r\n}\r\nfor (j = 0; j < peer->ksnp_n_passive_ips; j++) {\r\nif (index-- > 0)\r\ncontinue;\r\n*id = peer->ksnp_id;\r\n*myip = peer->ksnp_passive_ips[j];\r\n*peer_ip = 0;\r\n*port = 0;\r\n*conn_count = 0;\r\n*share_count = 0;\r\nrc = 0;\r\ngoto out;\r\n}\r\nlist_for_each (rtmp, &peer->ksnp_routes) {\r\nif (index-- > 0)\r\ncontinue;\r\nroute = list_entry(rtmp, ksock_route_t,\r\nksnr_list);\r\n*id = peer->ksnp_id;\r\n*myip = route->ksnr_myipaddr;\r\n*peer_ip = route->ksnr_ipaddr;\r\n*port = route->ksnr_port;\r\n*conn_count = route->ksnr_conn_count;\r\n*share_count = route->ksnr_share_count;\r\nrc = 0;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn rc;\r\n}\r\nstatic void\r\nksocknal_associate_route_conn_locked(ksock_route_t *route, ksock_conn_t *conn)\r\n{\r\nksock_peer_t *peer = route->ksnr_peer;\r\nint type = conn->ksnc_type;\r\nksock_interface_t *iface;\r\nconn->ksnc_route = route;\r\nksocknal_route_addref(route);\r\nif (route->ksnr_myipaddr != conn->ksnc_myipaddr) {\r\nif (route->ksnr_myipaddr == 0) {\r\nCDEBUG(D_NET, "Binding %s %pI4h to %pI4h\n",\r\nlibcfs_id2str(peer->ksnp_id),\r\n&route->ksnr_ipaddr,\r\n&conn->ksnc_myipaddr);\r\n} else {\r\nCDEBUG(D_NET, "Rebinding %s %pI4h from "\r\n"%pI4h to %pI4h\n",\r\nlibcfs_id2str(peer->ksnp_id),\r\n&route->ksnr_ipaddr,\r\n&route->ksnr_myipaddr,\r\n&conn->ksnc_myipaddr);\r\niface = ksocknal_ip2iface(route->ksnr_peer->ksnp_ni,\r\nroute->ksnr_myipaddr);\r\nif (iface != NULL)\r\niface->ksni_nroutes--;\r\n}\r\nroute->ksnr_myipaddr = conn->ksnc_myipaddr;\r\niface = ksocknal_ip2iface(route->ksnr_peer->ksnp_ni,\r\nroute->ksnr_myipaddr);\r\nif (iface != NULL)\r\niface->ksni_nroutes++;\r\n}\r\nroute->ksnr_connected |= (1<<type);\r\nroute->ksnr_conn_count++;\r\nroute->ksnr_retry_interval = 0;\r\n}\r\nstatic void\r\nksocknal_add_route_locked (ksock_peer_t *peer, ksock_route_t *route)\r\n{\r\nstruct list_head *tmp;\r\nksock_conn_t *conn;\r\nksock_route_t *route2;\r\nLASSERT (!peer->ksnp_closing);\r\nLASSERT (route->ksnr_peer == NULL);\r\nLASSERT (!route->ksnr_scheduled);\r\nLASSERT (!route->ksnr_connecting);\r\nLASSERT (route->ksnr_connected == 0);\r\nlist_for_each(tmp, &peer->ksnp_routes) {\r\nroute2 = list_entry(tmp, ksock_route_t, ksnr_list);\r\nif (route2->ksnr_ipaddr == route->ksnr_ipaddr) {\r\nCERROR("Duplicate route %s %pI4h\n",\r\nlibcfs_id2str(peer->ksnp_id),\r\n&route->ksnr_ipaddr);\r\nLBUG();\r\n}\r\n}\r\nroute->ksnr_peer = peer;\r\nksocknal_peer_addref(peer);\r\nlist_add_tail(&route->ksnr_list, &peer->ksnp_routes);\r\nlist_for_each(tmp, &peer->ksnp_conns) {\r\nconn = list_entry(tmp, ksock_conn_t, ksnc_list);\r\nif (conn->ksnc_ipaddr != route->ksnr_ipaddr)\r\ncontinue;\r\nksocknal_associate_route_conn_locked(route, conn);\r\n}\r\n}\r\nstatic void\r\nksocknal_del_route_locked (ksock_route_t *route)\r\n{\r\nksock_peer_t *peer = route->ksnr_peer;\r\nksock_interface_t *iface;\r\nksock_conn_t *conn;\r\nstruct list_head *ctmp;\r\nstruct list_head *cnxt;\r\nLASSERT (!route->ksnr_deleted);\r\nlist_for_each_safe (ctmp, cnxt, &peer->ksnp_conns) {\r\nconn = list_entry(ctmp, ksock_conn_t, ksnc_list);\r\nif (conn->ksnc_route != route)\r\ncontinue;\r\nksocknal_close_conn_locked (conn, 0);\r\n}\r\nif (route->ksnr_myipaddr != 0) {\r\niface = ksocknal_ip2iface(route->ksnr_peer->ksnp_ni,\r\nroute->ksnr_myipaddr);\r\nif (iface != NULL)\r\niface->ksni_nroutes--;\r\n}\r\nroute->ksnr_deleted = 1;\r\nlist_del (&route->ksnr_list);\r\nksocknal_route_decref(route);\r\nif (list_empty (&peer->ksnp_routes) &&\r\nlist_empty (&peer->ksnp_conns)) {\r\nksocknal_unlink_peer_locked (peer);\r\n}\r\n}\r\nint\r\nksocknal_add_peer (lnet_ni_t *ni, lnet_process_id_t id, __u32 ipaddr, int port)\r\n{\r\nstruct list_head *tmp;\r\nksock_peer_t *peer;\r\nksock_peer_t *peer2;\r\nksock_route_t *route;\r\nksock_route_t *route2;\r\nint rc;\r\nif (id.nid == LNET_NID_ANY ||\r\nid.pid == LNET_PID_ANY)\r\nreturn -EINVAL;\r\nrc = ksocknal_create_peer(&peer, ni, id);\r\nif (rc != 0)\r\nreturn rc;\r\nroute = ksocknal_create_route (ipaddr, port);\r\nif (route == NULL) {\r\nksocknal_peer_decref(peer);\r\nreturn -ENOMEM;\r\n}\r\nwrite_lock_bh(&ksocknal_data.ksnd_global_lock);\r\nLASSERT (((ksock_net_t *) ni->ni_data)->ksnn_shutdown == 0);\r\npeer2 = ksocknal_find_peer_locked (ni, id);\r\nif (peer2 != NULL) {\r\nksocknal_peer_decref(peer);\r\npeer = peer2;\r\n} else {\r\nlist_add_tail (&peer->ksnp_list,\r\nksocknal_nid2peerlist (id.nid));\r\n}\r\nroute2 = NULL;\r\nlist_for_each (tmp, &peer->ksnp_routes) {\r\nroute2 = list_entry(tmp, ksock_route_t, ksnr_list);\r\nif (route2->ksnr_ipaddr == ipaddr)\r\nbreak;\r\nroute2 = NULL;\r\n}\r\nif (route2 == NULL) {\r\nksocknal_add_route_locked(peer, route);\r\nroute->ksnr_share_count++;\r\n} else {\r\nksocknal_route_decref(route);\r\nroute2->ksnr_share_count++;\r\n}\r\nwrite_unlock_bh(&ksocknal_data.ksnd_global_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nksocknal_del_peer_locked (ksock_peer_t *peer, __u32 ip)\r\n{\r\nksock_conn_t *conn;\r\nksock_route_t *route;\r\nstruct list_head *tmp;\r\nstruct list_head *nxt;\r\nint nshared;\r\nLASSERT (!peer->ksnp_closing);\r\nksocknal_peer_addref(peer);\r\nlist_for_each_safe (tmp, nxt, &peer->ksnp_routes) {\r\nroute = list_entry(tmp, ksock_route_t, ksnr_list);\r\nif (!(ip == 0 || route->ksnr_ipaddr == ip))\r\ncontinue;\r\nroute->ksnr_share_count = 0;\r\nksocknal_del_route_locked (route);\r\n}\r\nnshared = 0;\r\nlist_for_each_safe (tmp, nxt, &peer->ksnp_routes) {\r\nroute = list_entry(tmp, ksock_route_t, ksnr_list);\r\nnshared += route->ksnr_share_count;\r\n}\r\nif (nshared == 0) {\r\nlist_for_each_safe (tmp, nxt, &peer->ksnp_routes) {\r\nroute = list_entry(tmp, ksock_route_t, ksnr_list);\r\nLASSERT(route->ksnr_share_count == 0);\r\nksocknal_del_route_locked (route);\r\n}\r\nlist_for_each_safe (tmp, nxt, &peer->ksnp_conns) {\r\nconn = list_entry(tmp, ksock_conn_t, ksnc_list);\r\nksocknal_close_conn_locked(conn, 0);\r\n}\r\n}\r\nksocknal_peer_decref(peer);\r\n}\r\nstatic int\r\nksocknal_del_peer (lnet_ni_t *ni, lnet_process_id_t id, __u32 ip)\r\n{\r\nLIST_HEAD (zombies);\r\nstruct list_head *ptmp;\r\nstruct list_head *pnxt;\r\nksock_peer_t *peer;\r\nint lo;\r\nint hi;\r\nint i;\r\nint rc = -ENOENT;\r\nwrite_lock_bh(&ksocknal_data.ksnd_global_lock);\r\nif (id.nid != LNET_NID_ANY)\r\nlo = hi = (int)(ksocknal_nid2peerlist(id.nid) - ksocknal_data.ksnd_peers);\r\nelse {\r\nlo = 0;\r\nhi = ksocknal_data.ksnd_peer_hash_size - 1;\r\n}\r\nfor (i = lo; i <= hi; i++) {\r\nlist_for_each_safe (ptmp, pnxt,\r\n&ksocknal_data.ksnd_peers[i]) {\r\npeer = list_entry (ptmp, ksock_peer_t, ksnp_list);\r\nif (peer->ksnp_ni != ni)\r\ncontinue;\r\nif (!((id.nid == LNET_NID_ANY || peer->ksnp_id.nid == id.nid) &&\r\n(id.pid == LNET_PID_ANY || peer->ksnp_id.pid == id.pid)))\r\ncontinue;\r\nksocknal_peer_addref(peer);\r\nksocknal_del_peer_locked (peer, ip);\r\nif (peer->ksnp_closing &&\r\n!list_empty(&peer->ksnp_tx_queue)) {\r\nLASSERT (list_empty(&peer->ksnp_conns));\r\nLASSERT (list_empty(&peer->ksnp_routes));\r\nlist_splice_init(&peer->ksnp_tx_queue,\r\n&zombies);\r\n}\r\nksocknal_peer_decref(peer);\r\nrc = 0;\r\n}\r\n}\r\nwrite_unlock_bh(&ksocknal_data.ksnd_global_lock);\r\nksocknal_txlist_done(ni, &zombies, 1);\r\nreturn rc;\r\n}\r\nstatic ksock_conn_t *\r\nksocknal_get_conn_by_idx (lnet_ni_t *ni, int index)\r\n{\r\nksock_peer_t *peer;\r\nstruct list_head *ptmp;\r\nksock_conn_t *conn;\r\nstruct list_head *ctmp;\r\nint i;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nfor (i = 0; i < ksocknal_data.ksnd_peer_hash_size; i++) {\r\nlist_for_each (ptmp, &ksocknal_data.ksnd_peers[i]) {\r\npeer = list_entry (ptmp, ksock_peer_t, ksnp_list);\r\nLASSERT (!peer->ksnp_closing);\r\nif (peer->ksnp_ni != ni)\r\ncontinue;\r\nlist_for_each (ctmp, &peer->ksnp_conns) {\r\nif (index-- > 0)\r\ncontinue;\r\nconn = list_entry (ctmp, ksock_conn_t,\r\nksnc_list);\r\nksocknal_conn_addref(conn);\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn conn;\r\n}\r\n}\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn NULL;\r\n}\r\nstatic ksock_sched_t *\r\nksocknal_choose_scheduler_locked(unsigned int cpt)\r\n{\r\nstruct ksock_sched_info *info = ksocknal_data.ksnd_sched_info[cpt];\r\nksock_sched_t *sched;\r\nint i;\r\nLASSERT(info->ksi_nthreads > 0);\r\nsched = &info->ksi_scheds[0];\r\nfor (i = 1; i < info->ksi_nthreads; i++) {\r\nif (sched->kss_nconns > info->ksi_scheds[i].kss_nconns)\r\nsched = &info->ksi_scheds[i];\r\n}\r\nreturn sched;\r\n}\r\nstatic int\r\nksocknal_local_ipvec (lnet_ni_t *ni, __u32 *ipaddrs)\r\n{\r\nksock_net_t *net = ni->ni_data;\r\nint i;\r\nint nip;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nnip = net->ksnn_ninterfaces;\r\nLASSERT (nip <= LNET_MAX_INTERFACES);\r\nif (nip < 2) {\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < nip; i++) {\r\nipaddrs[i] = net->ksnn_interfaces[i].ksni_ipaddr;\r\nLASSERT (ipaddrs[i] != 0);\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn nip;\r\n}\r\nstatic int\r\nksocknal_match_peerip (ksock_interface_t *iface, __u32 *ips, int nips)\r\n{\r\nint best_netmatch = 0;\r\nint best_xor = 0;\r\nint best = -1;\r\nint this_xor;\r\nint this_netmatch;\r\nint i;\r\nfor (i = 0; i < nips; i++) {\r\nif (ips[i] == 0)\r\ncontinue;\r\nthis_xor = (ips[i] ^ iface->ksni_ipaddr);\r\nthis_netmatch = ((this_xor & iface->ksni_netmask) == 0) ? 1 : 0;\r\nif (!(best < 0 ||\r\nbest_netmatch < this_netmatch ||\r\n(best_netmatch == this_netmatch &&\r\nbest_xor > this_xor)))\r\ncontinue;\r\nbest = i;\r\nbest_netmatch = this_netmatch;\r\nbest_xor = this_xor;\r\n}\r\nLASSERT (best >= 0);\r\nreturn best;\r\n}\r\nstatic int\r\nksocknal_select_ips(ksock_peer_t *peer, __u32 *peerips, int n_peerips)\r\n{\r\nrwlock_t *global_lock = &ksocknal_data.ksnd_global_lock;\r\nksock_net_t *net = peer->ksnp_ni->ni_data;\r\nksock_interface_t *iface;\r\nksock_interface_t *best_iface;\r\nint n_ips;\r\nint i;\r\nint j;\r\nint k;\r\n__u32 ip;\r\n__u32 xor;\r\nint this_netmatch;\r\nint best_netmatch;\r\nint best_npeers;\r\nwrite_lock_bh(global_lock);\r\nLASSERT (n_peerips <= LNET_MAX_INTERFACES);\r\nLASSERT (net->ksnn_ninterfaces <= LNET_MAX_INTERFACES);\r\nn_ips = (net->ksnn_ninterfaces < 2) ? 0 :\r\nMIN(n_peerips, net->ksnn_ninterfaces);\r\nfor (i = 0; peer->ksnp_n_passive_ips < n_ips; i++) {\r\nif (i < peer->ksnp_n_passive_ips) {\r\nip = peer->ksnp_passive_ips[i];\r\nbest_iface = ksocknal_ip2iface(peer->ksnp_ni, ip);\r\n} else {\r\nLASSERT (i == peer->ksnp_n_passive_ips);\r\nbest_iface = NULL;\r\nbest_netmatch = 0;\r\nbest_npeers = 0;\r\nfor (j = 0; j < net->ksnn_ninterfaces; j++) {\r\niface = &net->ksnn_interfaces[j];\r\nip = iface->ksni_ipaddr;\r\nfor (k = 0; k < peer->ksnp_n_passive_ips; k++)\r\nif (peer->ksnp_passive_ips[k] == ip)\r\nbreak;\r\nif (k < peer->ksnp_n_passive_ips)\r\ncontinue;\r\nk = ksocknal_match_peerip(iface, peerips, n_peerips);\r\nxor = (ip ^ peerips[k]);\r\nthis_netmatch = ((xor & iface->ksni_netmask) == 0) ? 1 : 0;\r\nif (!(best_iface == NULL ||\r\nbest_netmatch < this_netmatch ||\r\n(best_netmatch == this_netmatch &&\r\nbest_npeers > iface->ksni_npeers)))\r\ncontinue;\r\nbest_iface = iface;\r\nbest_netmatch = this_netmatch;\r\nbest_npeers = iface->ksni_npeers;\r\n}\r\nbest_iface->ksni_npeers++;\r\nip = best_iface->ksni_ipaddr;\r\npeer->ksnp_passive_ips[i] = ip;\r\npeer->ksnp_n_passive_ips = i+1;\r\n}\r\nj = ksocknal_match_peerip(best_iface, peerips, n_peerips);\r\npeerips[j] = 0;\r\n}\r\nmemcpy(peerips, peer->ksnp_passive_ips, n_ips * sizeof(*peerips));\r\nwrite_unlock_bh(global_lock);\r\nreturn n_ips;\r\n}\r\nstatic void\r\nksocknal_create_routes(ksock_peer_t *peer, int port,\r\n__u32 *peer_ipaddrs, int npeer_ipaddrs)\r\n{\r\nksock_route_t *newroute = NULL;\r\nrwlock_t *global_lock = &ksocknal_data.ksnd_global_lock;\r\nlnet_ni_t *ni = peer->ksnp_ni;\r\nksock_net_t *net = ni->ni_data;\r\nstruct list_head *rtmp;\r\nksock_route_t *route;\r\nksock_interface_t *iface;\r\nksock_interface_t *best_iface;\r\nint best_netmatch;\r\nint this_netmatch;\r\nint best_nroutes;\r\nint i;\r\nint j;\r\nwrite_lock_bh(global_lock);\r\nif (net->ksnn_ninterfaces < 2) {\r\nwrite_unlock_bh(global_lock);\r\nreturn;\r\n}\r\nLASSERT (npeer_ipaddrs <= LNET_MAX_INTERFACES);\r\nfor (i = 0; i < npeer_ipaddrs; i++) {\r\nif (newroute != NULL) {\r\nnewroute->ksnr_ipaddr = peer_ipaddrs[i];\r\n} else {\r\nwrite_unlock_bh(global_lock);\r\nnewroute = ksocknal_create_route(peer_ipaddrs[i], port);\r\nif (newroute == NULL)\r\nreturn;\r\nwrite_lock_bh(global_lock);\r\n}\r\nif (peer->ksnp_closing) {\r\nbreak;\r\n}\r\nroute = NULL;\r\nlist_for_each(rtmp, &peer->ksnp_routes) {\r\nroute = list_entry(rtmp, ksock_route_t, ksnr_list);\r\nif (route->ksnr_ipaddr == newroute->ksnr_ipaddr)\r\nbreak;\r\nroute = NULL;\r\n}\r\nif (route != NULL)\r\ncontinue;\r\nbest_iface = NULL;\r\nbest_nroutes = 0;\r\nbest_netmatch = 0;\r\nLASSERT (net->ksnn_ninterfaces <= LNET_MAX_INTERFACES);\r\nfor (j = 0; j < net->ksnn_ninterfaces; j++) {\r\niface = &net->ksnn_interfaces[j];\r\nlist_for_each(rtmp, &peer->ksnp_routes) {\r\nroute = list_entry(rtmp, ksock_route_t,\r\nksnr_list);\r\nif (route->ksnr_myipaddr == iface->ksni_ipaddr)\r\nbreak;\r\nroute = NULL;\r\n}\r\nif (route != NULL)\r\ncontinue;\r\nthis_netmatch = (((iface->ksni_ipaddr ^\r\nnewroute->ksnr_ipaddr) &\r\niface->ksni_netmask) == 0) ? 1 : 0;\r\nif (!(best_iface == NULL ||\r\nbest_netmatch < this_netmatch ||\r\n(best_netmatch == this_netmatch &&\r\nbest_nroutes > iface->ksni_nroutes)))\r\ncontinue;\r\nbest_iface = iface;\r\nbest_netmatch = this_netmatch;\r\nbest_nroutes = iface->ksni_nroutes;\r\n}\r\nif (best_iface == NULL)\r\ncontinue;\r\nnewroute->ksnr_myipaddr = best_iface->ksni_ipaddr;\r\nbest_iface->ksni_nroutes++;\r\nksocknal_add_route_locked(peer, newroute);\r\nnewroute = NULL;\r\n}\r\nwrite_unlock_bh(global_lock);\r\nif (newroute != NULL)\r\nksocknal_route_decref(newroute);\r\n}\r\nint\r\nksocknal_accept (lnet_ni_t *ni, struct socket *sock)\r\n{\r\nksock_connreq_t *cr;\r\nint rc;\r\n__u32 peer_ip;\r\nint peer_port;\r\nrc = libcfs_sock_getaddr(sock, 1, &peer_ip, &peer_port);\r\nLASSERT (rc == 0);\r\nLIBCFS_ALLOC(cr, sizeof(*cr));\r\nif (cr == NULL) {\r\nLCONSOLE_ERROR_MSG(0x12f, "Dropping connection request from "\r\n"%pI4h: memory exhausted\n",\r\n&peer_ip);\r\nreturn -ENOMEM;\r\n}\r\nlnet_ni_addref(ni);\r\ncr->ksncr_ni = ni;\r\ncr->ksncr_sock = sock;\r\nspin_lock_bh(&ksocknal_data.ksnd_connd_lock);\r\nlist_add_tail(&cr->ksncr_list, &ksocknal_data.ksnd_connd_connreqs);\r\nwake_up(&ksocknal_data.ksnd_connd_waitq);\r\nspin_unlock_bh(&ksocknal_data.ksnd_connd_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nksocknal_connecting (ksock_peer_t *peer, __u32 ipaddr)\r\n{\r\nksock_route_t *route;\r\nlist_for_each_entry (route, &peer->ksnp_routes, ksnr_list) {\r\nif (route->ksnr_ipaddr == ipaddr)\r\nreturn route->ksnr_connecting;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nksocknal_create_conn (lnet_ni_t *ni, ksock_route_t *route,\r\nstruct socket *sock, int type)\r\n{\r\nrwlock_t *global_lock = &ksocknal_data.ksnd_global_lock;\r\nLIST_HEAD (zombies);\r\nlnet_process_id_t peerid;\r\nstruct list_head *tmp;\r\n__u64 incarnation;\r\nksock_conn_t *conn;\r\nksock_conn_t *conn2;\r\nksock_peer_t *peer = NULL;\r\nksock_peer_t *peer2;\r\nksock_sched_t *sched;\r\nksock_hello_msg_t *hello;\r\nint cpt;\r\nksock_tx_t *tx;\r\nksock_tx_t *txtmp;\r\nint rc;\r\nint active;\r\nchar *warn = NULL;\r\nactive = (route != NULL);\r\nLASSERT (active == (type != SOCKLND_CONN_NONE));\r\nLIBCFS_ALLOC(conn, sizeof(*conn));\r\nif (conn == NULL) {\r\nrc = -ENOMEM;\r\ngoto failed_0;\r\n}\r\nconn->ksnc_peer = NULL;\r\nconn->ksnc_route = NULL;\r\nconn->ksnc_sock = sock;\r\natomic_set (&conn->ksnc_sock_refcount, 2);\r\nconn->ksnc_type = type;\r\nksocknal_lib_save_callback(sock, conn);\r\natomic_set (&conn->ksnc_conn_refcount, 1);\r\nconn->ksnc_rx_ready = 0;\r\nconn->ksnc_rx_scheduled = 0;\r\nINIT_LIST_HEAD (&conn->ksnc_tx_queue);\r\nconn->ksnc_tx_ready = 0;\r\nconn->ksnc_tx_scheduled = 0;\r\nconn->ksnc_tx_carrier = NULL;\r\natomic_set (&conn->ksnc_tx_nob, 0);\r\nLIBCFS_ALLOC(hello, offsetof(ksock_hello_msg_t,\r\nkshm_ips[LNET_MAX_INTERFACES]));\r\nif (hello == NULL) {\r\nrc = -ENOMEM;\r\ngoto failed_1;\r\n}\r\nrc = ksocknal_lib_get_conn_addrs (conn);\r\nif (rc != 0)\r\ngoto failed_1;\r\nif (active) {\r\npeer = route->ksnr_peer;\r\nLASSERT(ni == peer->ksnp_ni);\r\nhello->kshm_nips = ksocknal_local_ipvec(ni, hello->kshm_ips);\r\npeerid = peer->ksnp_id;\r\nwrite_lock_bh(global_lock);\r\nconn->ksnc_proto = peer->ksnp_proto;\r\nwrite_unlock_bh(global_lock);\r\nif (conn->ksnc_proto == NULL) {\r\nconn->ksnc_proto = &ksocknal_protocol_v3x;\r\n#if SOCKNAL_VERSION_DEBUG\r\nif (*ksocknal_tunables.ksnd_protocol == 2)\r\nconn->ksnc_proto = &ksocknal_protocol_v2x;\r\nelse if (*ksocknal_tunables.ksnd_protocol == 1)\r\nconn->ksnc_proto = &ksocknal_protocol_v1x;\r\n#endif\r\n}\r\nrc = ksocknal_send_hello (ni, conn, peerid.nid, hello);\r\nif (rc != 0)\r\ngoto failed_1;\r\n} else {\r\npeerid.nid = LNET_NID_ANY;\r\npeerid.pid = LNET_PID_ANY;\r\nconn->ksnc_proto = NULL;\r\n}\r\nrc = ksocknal_recv_hello (ni, conn, hello, &peerid, &incarnation);\r\nif (rc < 0)\r\ngoto failed_1;\r\nLASSERT (rc == 0 || active);\r\nLASSERT (conn->ksnc_proto != NULL);\r\nLASSERT (peerid.nid != LNET_NID_ANY);\r\ncpt = lnet_cpt_of_nid(peerid.nid);\r\nif (active) {\r\nksocknal_peer_addref(peer);\r\nwrite_lock_bh(global_lock);\r\n} else {\r\nrc = ksocknal_create_peer(&peer, ni, peerid);\r\nif (rc != 0)\r\ngoto failed_1;\r\nwrite_lock_bh(global_lock);\r\nLASSERT (((ksock_net_t *) ni->ni_data)->ksnn_shutdown == 0);\r\npeer2 = ksocknal_find_peer_locked(ni, peerid);\r\nif (peer2 == NULL) {\r\nlist_add_tail(&peer->ksnp_list,\r\nksocknal_nid2peerlist(peerid.nid));\r\n} else {\r\nksocknal_peer_decref(peer);\r\npeer = peer2;\r\n}\r\nksocknal_peer_addref(peer);\r\npeer->ksnp_accepting++;\r\nif (peerid.nid < ni->ni_nid &&\r\nksocknal_connecting(peer, conn->ksnc_ipaddr)) {\r\nrc = EALREADY;\r\nwarn = "connection race resolution";\r\ngoto failed_2;\r\n}\r\n}\r\nif (peer->ksnp_closing ||\r\n(active && route->ksnr_deleted)) {\r\nrc = -ESTALE;\r\nwarn = "peer/route removed";\r\ngoto failed_2;\r\n}\r\nif (peer->ksnp_proto == NULL) {\r\nLASSERT (list_empty(&peer->ksnp_conns));\r\npeer->ksnp_proto = conn->ksnc_proto;\r\npeer->ksnp_incarnation = incarnation;\r\n}\r\nif (peer->ksnp_proto != conn->ksnc_proto ||\r\npeer->ksnp_incarnation != incarnation) {\r\nksocknal_close_peer_conns_locked(peer, 0, 0);\r\npeer->ksnp_proto = NULL;\r\nrc = ESTALE;\r\nwarn = peer->ksnp_incarnation != incarnation ?\r\n"peer rebooted" :\r\n"wrong proto version";\r\ngoto failed_2;\r\n}\r\nswitch (rc) {\r\ndefault:\r\nLBUG();\r\ncase 0:\r\nbreak;\r\ncase EALREADY:\r\nwarn = "lost conn race";\r\ngoto failed_2;\r\ncase EPROTO:\r\nwarn = "retry with different protocol version";\r\ngoto failed_2;\r\n}\r\nif (conn->ksnc_ipaddr != conn->ksnc_myipaddr) {\r\nlist_for_each(tmp, &peer->ksnp_conns) {\r\nconn2 = list_entry(tmp, ksock_conn_t, ksnc_list);\r\nif (conn2->ksnc_ipaddr != conn->ksnc_ipaddr ||\r\nconn2->ksnc_myipaddr != conn->ksnc_myipaddr ||\r\nconn2->ksnc_type != conn->ksnc_type)\r\ncontinue;\r\nLASSERT (rc == 0);\r\nif (!active)\r\nrc = EALREADY;\r\nwarn = "duplicate";\r\ngoto failed_2;\r\n}\r\n}\r\nif (active &&\r\nroute->ksnr_ipaddr != conn->ksnc_ipaddr) {\r\nCERROR("Route %s %pI4h connected to %pI4h\n",\r\nlibcfs_id2str(peer->ksnp_id),\r\n&route->ksnr_ipaddr,\r\n&conn->ksnc_ipaddr);\r\n}\r\nlist_for_each (tmp, &peer->ksnp_routes) {\r\nroute = list_entry(tmp, ksock_route_t, ksnr_list);\r\nif (route->ksnr_ipaddr != conn->ksnc_ipaddr)\r\ncontinue;\r\nksocknal_associate_route_conn_locked(route, conn);\r\nbreak;\r\n}\r\nconn->ksnc_peer = peer;\r\npeer->ksnp_last_alive = cfs_time_current();\r\npeer->ksnp_send_keepalive = 0;\r\npeer->ksnp_error = 0;\r\nsched = ksocknal_choose_scheduler_locked(cpt);\r\nsched->kss_nconns++;\r\nconn->ksnc_scheduler = sched;\r\nconn->ksnc_tx_last_post = cfs_time_current();\r\nconn->ksnc_tx_bufnob = sock->sk->sk_wmem_queued;\r\nconn->ksnc_tx_deadline = cfs_time_shift(*ksocknal_tunables.ksnd_timeout);\r\nmb();\r\nlist_add (&conn->ksnc_list, &peer->ksnp_conns);\r\nksocknal_conn_addref(conn);\r\nksocknal_new_packet(conn, 0);\r\nconn->ksnc_zc_capable = ksocknal_lib_zc_capable(conn);\r\nlist_for_each_entry_safe(tx, txtmp, &peer->ksnp_tx_queue, tx_list) {\r\nif (conn->ksnc_proto->pro_match_tx(conn, tx, tx->tx_nonblk) == SOCKNAL_MATCH_NO)\r\ncontinue;\r\nlist_del (&tx->tx_list);\r\nksocknal_queue_tx_locked (tx, conn);\r\n}\r\nwrite_unlock_bh(global_lock);\r\nCDEBUG(D_NET, "New conn %s p %d.x %pI4h -> %pI4h/%d"\r\n" incarnation:%lld sched[%d:%d]\n",\r\nlibcfs_id2str(peerid), conn->ksnc_proto->pro_version,\r\n&conn->ksnc_myipaddr, &conn->ksnc_ipaddr,\r\nconn->ksnc_port, incarnation, cpt,\r\n(int)(sched - &sched->kss_info->ksi_scheds[0]));\r\nif (active) {\r\nksocknal_create_routes(peer, conn->ksnc_port,\r\nhello->kshm_ips, hello->kshm_nips);\r\n} else {\r\nhello->kshm_nips = ksocknal_select_ips(peer, hello->kshm_ips,\r\nhello->kshm_nips);\r\nrc = ksocknal_send_hello(ni, conn, peerid.nid, hello);\r\n}\r\nLIBCFS_FREE(hello, offsetof(ksock_hello_msg_t,\r\nkshm_ips[LNET_MAX_INTERFACES]));\r\nif (rc == 0)\r\nrc = ksocknal_lib_setup_sock(sock);\r\nwrite_lock_bh(global_lock);\r\nksocknal_lib_set_callback(sock, conn);\r\nif (!active)\r\npeer->ksnp_accepting--;\r\nwrite_unlock_bh(global_lock);\r\nif (rc != 0) {\r\nwrite_lock_bh(global_lock);\r\nif (!conn->ksnc_closing) {\r\nksocknal_close_conn_locked(conn, rc);\r\n}\r\nwrite_unlock_bh(global_lock);\r\n} else if (ksocknal_connsock_addref(conn) == 0) {\r\nksocknal_read_callback(conn);\r\nksocknal_write_callback(conn);\r\nksocknal_connsock_decref(conn);\r\n}\r\nksocknal_connsock_decref(conn);\r\nksocknal_conn_decref(conn);\r\nreturn rc;\r\nfailed_2:\r\nif (!peer->ksnp_closing &&\r\nlist_empty (&peer->ksnp_conns) &&\r\nlist_empty (&peer->ksnp_routes)) {\r\nlist_add(&zombies, &peer->ksnp_tx_queue);\r\nlist_del_init(&peer->ksnp_tx_queue);\r\nksocknal_unlink_peer_locked(peer);\r\n}\r\nwrite_unlock_bh(global_lock);\r\nif (warn != NULL) {\r\nif (rc < 0)\r\nCERROR("Not creating conn %s type %d: %s\n",\r\nlibcfs_id2str(peerid), conn->ksnc_type, warn);\r\nelse\r\nCDEBUG(D_NET, "Not creating conn %s type %d: %s\n",\r\nlibcfs_id2str(peerid), conn->ksnc_type, warn);\r\n}\r\nif (!active) {\r\nif (rc > 0) {\r\nconn->ksnc_type = SOCKLND_CONN_NONE;\r\nhello->kshm_nips = 0;\r\nksocknal_send_hello(ni, conn, peerid.nid, hello);\r\n}\r\nwrite_lock_bh(global_lock);\r\npeer->ksnp_accepting--;\r\nwrite_unlock_bh(global_lock);\r\n}\r\nksocknal_txlist_done(ni, &zombies, 1);\r\nksocknal_peer_decref(peer);\r\nfailed_1:\r\nif (hello != NULL)\r\nLIBCFS_FREE(hello, offsetof(ksock_hello_msg_t,\r\nkshm_ips[LNET_MAX_INTERFACES]));\r\nLIBCFS_FREE (conn, sizeof(*conn));\r\nfailed_0:\r\nlibcfs_sock_release(sock);\r\nreturn rc;\r\n}\r\nvoid\r\nksocknal_close_conn_locked (ksock_conn_t *conn, int error)\r\n{\r\nksock_peer_t *peer = conn->ksnc_peer;\r\nksock_route_t *route;\r\nksock_conn_t *conn2;\r\nstruct list_head *tmp;\r\nLASSERT (peer->ksnp_error == 0);\r\nLASSERT (!conn->ksnc_closing);\r\nconn->ksnc_closing = 1;\r\nlist_del (&conn->ksnc_list);\r\nroute = conn->ksnc_route;\r\nif (route != NULL) {\r\nLASSERT (!route->ksnr_deleted);\r\nLASSERT ((route->ksnr_connected & (1 << conn->ksnc_type)) != 0);\r\nconn2 = NULL;\r\nlist_for_each(tmp, &peer->ksnp_conns) {\r\nconn2 = list_entry(tmp, ksock_conn_t, ksnc_list);\r\nif (conn2->ksnc_route == route &&\r\nconn2->ksnc_type == conn->ksnc_type)\r\nbreak;\r\nconn2 = NULL;\r\n}\r\nif (conn2 == NULL)\r\nroute->ksnr_connected &= ~(1 << conn->ksnc_type);\r\nconn->ksnc_route = NULL;\r\n#if 0\r\nlist_del (&route->ksnr_list);\r\nlist_add_tail (&route->ksnr_list, &peer->ksnp_routes);\r\n#endif\r\nksocknal_route_decref(route);\r\n}\r\nif (list_empty (&peer->ksnp_conns)) {\r\nif (!list_empty(&peer->ksnp_tx_queue)) {\r\nksock_tx_t *tx;\r\nLASSERT (conn->ksnc_proto == &ksocknal_protocol_v3x);\r\nlist_for_each_entry(tx, &peer->ksnp_tx_queue,\r\ntx_list)\r\nksocknal_tx_prep(conn, tx);\r\nspin_lock_bh(&conn->ksnc_scheduler->kss_lock);\r\nlist_splice_init(&peer->ksnp_tx_queue,\r\n&conn->ksnc_tx_queue);\r\nspin_unlock_bh(&conn->ksnc_scheduler->kss_lock);\r\n}\r\npeer->ksnp_proto = NULL;\r\npeer->ksnp_error = error;\r\nif (list_empty (&peer->ksnp_routes)) {\r\nksocknal_unlink_peer_locked (peer);\r\n}\r\n}\r\nspin_lock_bh(&ksocknal_data.ksnd_reaper_lock);\r\nlist_add_tail(&conn->ksnc_list,\r\n&ksocknal_data.ksnd_deathrow_conns);\r\nwake_up(&ksocknal_data.ksnd_reaper_waitq);\r\nspin_unlock_bh(&ksocknal_data.ksnd_reaper_lock);\r\n}\r\nvoid\r\nksocknal_peer_failed (ksock_peer_t *peer)\r\n{\r\nint notify = 0;\r\nunsigned long last_alive = 0;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nif ((peer->ksnp_id.pid & LNET_PID_USERFLAG) == 0 &&\r\nlist_empty(&peer->ksnp_conns) &&\r\npeer->ksnp_accepting == 0 &&\r\nksocknal_find_connecting_route_locked(peer) == NULL) {\r\nnotify = 1;\r\nlast_alive = peer->ksnp_last_alive;\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nif (notify)\r\nlnet_notify (peer->ksnp_ni, peer->ksnp_id.nid, 0,\r\nlast_alive);\r\n}\r\nvoid\r\nksocknal_finalize_zcreq(ksock_conn_t *conn)\r\n{\r\nksock_peer_t *peer = conn->ksnc_peer;\r\nksock_tx_t *tx;\r\nksock_tx_t *tmp;\r\nLIST_HEAD (zlist);\r\nLASSERT (conn->ksnc_sock == NULL);\r\nspin_lock(&peer->ksnp_lock);\r\nlist_for_each_entry_safe(tx, tmp, &peer->ksnp_zc_req_list, tx_zc_list) {\r\nif (tx->tx_conn != conn)\r\ncontinue;\r\nLASSERT (tx->tx_msg.ksm_zc_cookies[0] != 0);\r\ntx->tx_msg.ksm_zc_cookies[0] = 0;\r\ntx->tx_zc_aborted = 1;\r\nlist_del(&tx->tx_zc_list);\r\nlist_add(&tx->tx_zc_list, &zlist);\r\n}\r\nspin_unlock(&peer->ksnp_lock);\r\nwhile (!list_empty(&zlist)) {\r\ntx = list_entry(zlist.next, ksock_tx_t, tx_zc_list);\r\nlist_del(&tx->tx_zc_list);\r\nksocknal_tx_decref(tx);\r\n}\r\n}\r\nvoid\r\nksocknal_terminate_conn (ksock_conn_t *conn)\r\n{\r\nksock_peer_t *peer = conn->ksnc_peer;\r\nksock_sched_t *sched = conn->ksnc_scheduler;\r\nint failed = 0;\r\nLASSERT(conn->ksnc_closing);\r\nspin_lock_bh(&sched->kss_lock);\r\nconn->ksnc_tx_ready = 1;\r\nif (!conn->ksnc_tx_scheduled &&\r\n!list_empty(&conn->ksnc_tx_queue)) {\r\nlist_add_tail (&conn->ksnc_tx_list,\r\n&sched->kss_tx_conns);\r\nconn->ksnc_tx_scheduled = 1;\r\nksocknal_conn_addref(conn);\r\nwake_up (&sched->kss_waitq);\r\n}\r\nspin_unlock_bh(&sched->kss_lock);\r\nwrite_lock_bh(&ksocknal_data.ksnd_global_lock);\r\nksocknal_lib_reset_callback(conn->ksnc_sock, conn);\r\nconn->ksnc_scheduler->kss_nconns--;\r\nif (peer->ksnp_error != 0) {\r\nLASSERT (list_empty (&peer->ksnp_conns));\r\nfailed = 1;\r\npeer->ksnp_error = 0;\r\n}\r\nwrite_unlock_bh(&ksocknal_data.ksnd_global_lock);\r\nif (failed)\r\nksocknal_peer_failed(peer);\r\nksocknal_connsock_decref(conn);\r\n}\r\nvoid\r\nksocknal_queue_zombie_conn (ksock_conn_t *conn)\r\n{\r\nLASSERT(atomic_read(&conn->ksnc_conn_refcount) == 0);\r\nspin_lock_bh(&ksocknal_data.ksnd_reaper_lock);\r\nlist_add_tail(&conn->ksnc_list, &ksocknal_data.ksnd_zombie_conns);\r\nwake_up(&ksocknal_data.ksnd_reaper_waitq);\r\nspin_unlock_bh(&ksocknal_data.ksnd_reaper_lock);\r\n}\r\nvoid\r\nksocknal_destroy_conn (ksock_conn_t *conn)\r\n{\r\nunsigned long last_rcv;\r\nCDEBUG (D_NET, "connection %p\n", conn);\r\nLASSERT (atomic_read (&conn->ksnc_conn_refcount) == 0);\r\nLASSERT (atomic_read (&conn->ksnc_sock_refcount) == 0);\r\nLASSERT (conn->ksnc_sock == NULL);\r\nLASSERT (conn->ksnc_route == NULL);\r\nLASSERT (!conn->ksnc_tx_scheduled);\r\nLASSERT (!conn->ksnc_rx_scheduled);\r\nLASSERT (list_empty(&conn->ksnc_tx_queue));\r\nswitch (conn->ksnc_rx_state) {\r\ncase SOCKNAL_RX_LNET_PAYLOAD:\r\nlast_rcv = conn->ksnc_rx_deadline -\r\ncfs_time_seconds(*ksocknal_tunables.ksnd_timeout);\r\nCERROR("Completing partial receive from %s[%d]"\r\n", ip %pI4h:%d, with error, wanted: %d, left: %d, "\r\n"last alive is %ld secs ago\n",\r\nlibcfs_id2str(conn->ksnc_peer->ksnp_id), conn->ksnc_type,\r\n&conn->ksnc_ipaddr, conn->ksnc_port,\r\nconn->ksnc_rx_nob_wanted, conn->ksnc_rx_nob_left,\r\ncfs_duration_sec(cfs_time_sub(cfs_time_current(),\r\nlast_rcv)));\r\nlnet_finalize (conn->ksnc_peer->ksnp_ni,\r\nconn->ksnc_cookie, -EIO);\r\nbreak;\r\ncase SOCKNAL_RX_LNET_HEADER:\r\nif (conn->ksnc_rx_started)\r\nCERROR("Incomplete receive of lnet header from %s"\r\n", ip %pI4h:%d, with error, protocol: %d.x.\n",\r\nlibcfs_id2str(conn->ksnc_peer->ksnp_id),\r\n&conn->ksnc_ipaddr, conn->ksnc_port,\r\nconn->ksnc_proto->pro_version);\r\nbreak;\r\ncase SOCKNAL_RX_KSM_HEADER:\r\nif (conn->ksnc_rx_started)\r\nCERROR("Incomplete receive of ksock message from %s"\r\n", ip %pI4h:%d, with error, protocol: %d.x.\n",\r\nlibcfs_id2str(conn->ksnc_peer->ksnp_id),\r\n&conn->ksnc_ipaddr, conn->ksnc_port,\r\nconn->ksnc_proto->pro_version);\r\nbreak;\r\ncase SOCKNAL_RX_SLOP:\r\nif (conn->ksnc_rx_started)\r\nCERROR("Incomplete receive of slops from %s"\r\n", ip %pI4h:%d, with error\n",\r\nlibcfs_id2str(conn->ksnc_peer->ksnp_id),\r\n&conn->ksnc_ipaddr, conn->ksnc_port);\r\nbreak;\r\ndefault:\r\nLBUG ();\r\nbreak;\r\n}\r\nksocknal_peer_decref(conn->ksnc_peer);\r\nLIBCFS_FREE (conn, sizeof (*conn));\r\n}\r\nint\r\nksocknal_close_peer_conns_locked (ksock_peer_t *peer, __u32 ipaddr, int why)\r\n{\r\nksock_conn_t *conn;\r\nstruct list_head *ctmp;\r\nstruct list_head *cnxt;\r\nint count = 0;\r\nlist_for_each_safe (ctmp, cnxt, &peer->ksnp_conns) {\r\nconn = list_entry (ctmp, ksock_conn_t, ksnc_list);\r\nif (ipaddr == 0 ||\r\nconn->ksnc_ipaddr == ipaddr) {\r\ncount++;\r\nksocknal_close_conn_locked (conn, why);\r\n}\r\n}\r\nreturn count;\r\n}\r\nint\r\nksocknal_close_conn_and_siblings (ksock_conn_t *conn, int why)\r\n{\r\nksock_peer_t *peer = conn->ksnc_peer;\r\n__u32 ipaddr = conn->ksnc_ipaddr;\r\nint count;\r\nwrite_lock_bh(&ksocknal_data.ksnd_global_lock);\r\ncount = ksocknal_close_peer_conns_locked (peer, ipaddr, why);\r\nwrite_unlock_bh(&ksocknal_data.ksnd_global_lock);\r\nreturn count;\r\n}\r\nint\r\nksocknal_close_matching_conns (lnet_process_id_t id, __u32 ipaddr)\r\n{\r\nksock_peer_t *peer;\r\nstruct list_head *ptmp;\r\nstruct list_head *pnxt;\r\nint lo;\r\nint hi;\r\nint i;\r\nint count = 0;\r\nwrite_lock_bh(&ksocknal_data.ksnd_global_lock);\r\nif (id.nid != LNET_NID_ANY)\r\nlo = hi = (int)(ksocknal_nid2peerlist(id.nid) - ksocknal_data.ksnd_peers);\r\nelse {\r\nlo = 0;\r\nhi = ksocknal_data.ksnd_peer_hash_size - 1;\r\n}\r\nfor (i = lo; i <= hi; i++) {\r\nlist_for_each_safe (ptmp, pnxt,\r\n&ksocknal_data.ksnd_peers[i]) {\r\npeer = list_entry (ptmp, ksock_peer_t, ksnp_list);\r\nif (!((id.nid == LNET_NID_ANY || id.nid == peer->ksnp_id.nid) &&\r\n(id.pid == LNET_PID_ANY || id.pid == peer->ksnp_id.pid)))\r\ncontinue;\r\ncount += ksocknal_close_peer_conns_locked (peer, ipaddr, 0);\r\n}\r\n}\r\nwrite_unlock_bh(&ksocknal_data.ksnd_global_lock);\r\nif (id.nid == LNET_NID_ANY || id.pid == LNET_PID_ANY || ipaddr == 0)\r\nreturn 0;\r\nif (count == 0)\r\nreturn -ENOENT;\r\nelse\r\nreturn 0;\r\n}\r\nvoid\r\nksocknal_notify (lnet_ni_t *ni, lnet_nid_t gw_nid, int alive)\r\n{\r\nlnet_process_id_t id = {0};\r\nid.nid = gw_nid;\r\nid.pid = LNET_PID_ANY;\r\nCDEBUG (D_NET, "gw %s %s\n", libcfs_nid2str(gw_nid),\r\nalive ? "up" : "down");\r\nif (!alive) {\r\nksocknal_close_matching_conns (id, 0);\r\nreturn;\r\n}\r\n}\r\nvoid\r\nksocknal_query (lnet_ni_t *ni, lnet_nid_t nid, unsigned long *when)\r\n{\r\nint connect = 1;\r\nunsigned long last_alive = 0;\r\nunsigned long now = cfs_time_current();\r\nksock_peer_t *peer = NULL;\r\nrwlock_t *glock = &ksocknal_data.ksnd_global_lock;\r\nlnet_process_id_t id = {.nid = nid, .pid = LUSTRE_SRV_LNET_PID};\r\nread_lock(glock);\r\npeer = ksocknal_find_peer_locked(ni, id);\r\nif (peer != NULL) {\r\nstruct list_head *tmp;\r\nksock_conn_t *conn;\r\nint bufnob;\r\nlist_for_each (tmp, &peer->ksnp_conns) {\r\nconn = list_entry(tmp, ksock_conn_t, ksnc_list);\r\nbufnob = conn->ksnc_sock->sk->sk_wmem_queued;\r\nif (bufnob < conn->ksnc_tx_bufnob) {\r\nconn->ksnc_tx_deadline =\r\ncfs_time_shift(*ksocknal_tunables.ksnd_timeout);\r\npeer->ksnp_last_alive = now;\r\nconn->ksnc_tx_bufnob = bufnob;\r\n}\r\n}\r\nlast_alive = peer->ksnp_last_alive;\r\nif (ksocknal_find_connectable_route_locked(peer) == NULL)\r\nconnect = 0;\r\n}\r\nread_unlock(glock);\r\nif (last_alive != 0)\r\n*when = last_alive;\r\nCDEBUG(D_NET, "Peer %s %p, alive %ld secs ago, connect %d\n",\r\nlibcfs_nid2str(nid), peer,\r\nlast_alive ? cfs_duration_sec(now - last_alive) : -1,\r\nconnect);\r\nif (!connect)\r\nreturn;\r\nksocknal_add_peer(ni, id, LNET_NIDADDR(nid), lnet_acceptor_port());\r\nwrite_lock_bh(glock);\r\npeer = ksocknal_find_peer_locked(ni, id);\r\nif (peer != NULL)\r\nksocknal_launch_all_connections_locked(peer);\r\nwrite_unlock_bh(glock);\r\nreturn;\r\n}\r\nstatic void\r\nksocknal_push_peer (ksock_peer_t *peer)\r\n{\r\nint index;\r\nint i;\r\nstruct list_head *tmp;\r\nksock_conn_t *conn;\r\nfor (index = 0; ; index++) {\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\ni = 0;\r\nconn = NULL;\r\nlist_for_each (tmp, &peer->ksnp_conns) {\r\nif (i++ == index) {\r\nconn = list_entry (tmp, ksock_conn_t,\r\nksnc_list);\r\nksocknal_conn_addref(conn);\r\nbreak;\r\n}\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nif (conn == NULL)\r\nbreak;\r\nksocknal_lib_push_conn (conn);\r\nksocknal_conn_decref(conn);\r\n}\r\n}\r\nstatic int\r\nksocknal_push (lnet_ni_t *ni, lnet_process_id_t id)\r\n{\r\nksock_peer_t *peer;\r\nstruct list_head *tmp;\r\nint index;\r\nint i;\r\nint j;\r\nint rc = -ENOENT;\r\nfor (i = 0; i < ksocknal_data.ksnd_peer_hash_size; i++) {\r\nfor (j = 0; ; j++) {\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nindex = 0;\r\npeer = NULL;\r\nlist_for_each (tmp, &ksocknal_data.ksnd_peers[i]) {\r\npeer = list_entry(tmp, ksock_peer_t,\r\nksnp_list);\r\nif (!((id.nid == LNET_NID_ANY ||\r\nid.nid == peer->ksnp_id.nid) &&\r\n(id.pid == LNET_PID_ANY ||\r\nid.pid == peer->ksnp_id.pid))) {\r\npeer = NULL;\r\ncontinue;\r\n}\r\nif (index++ == j) {\r\nksocknal_peer_addref(peer);\r\nbreak;\r\n}\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nif (peer != NULL) {\r\nrc = 0;\r\nksocknal_push_peer (peer);\r\nksocknal_peer_decref(peer);\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nksocknal_add_interface(lnet_ni_t *ni, __u32 ipaddress, __u32 netmask)\r\n{\r\nksock_net_t *net = ni->ni_data;\r\nksock_interface_t *iface;\r\nint rc;\r\nint i;\r\nint j;\r\nstruct list_head *ptmp;\r\nksock_peer_t *peer;\r\nstruct list_head *rtmp;\r\nksock_route_t *route;\r\nif (ipaddress == 0 ||\r\nnetmask == 0)\r\nreturn -EINVAL;\r\nwrite_lock_bh(&ksocknal_data.ksnd_global_lock);\r\niface = ksocknal_ip2iface(ni, ipaddress);\r\nif (iface != NULL) {\r\nrc = 0;\r\n} else if (net->ksnn_ninterfaces == LNET_MAX_INTERFACES) {\r\nrc = -ENOSPC;\r\n} else {\r\niface = &net->ksnn_interfaces[net->ksnn_ninterfaces++];\r\niface->ksni_ipaddr = ipaddress;\r\niface->ksni_netmask = netmask;\r\niface->ksni_nroutes = 0;\r\niface->ksni_npeers = 0;\r\nfor (i = 0; i < ksocknal_data.ksnd_peer_hash_size; i++) {\r\nlist_for_each(ptmp, &ksocknal_data.ksnd_peers[i]) {\r\npeer = list_entry(ptmp, ksock_peer_t,\r\nksnp_list);\r\nfor (j = 0; j < peer->ksnp_n_passive_ips; j++)\r\nif (peer->ksnp_passive_ips[j] == ipaddress)\r\niface->ksni_npeers++;\r\nlist_for_each(rtmp, &peer->ksnp_routes) {\r\nroute = list_entry(rtmp,\r\nksock_route_t,\r\nksnr_list);\r\nif (route->ksnr_myipaddr == ipaddress)\r\niface->ksni_nroutes++;\r\n}\r\n}\r\n}\r\nrc = 0;\r\n}\r\nwrite_unlock_bh(&ksocknal_data.ksnd_global_lock);\r\nreturn rc;\r\n}\r\nstatic void\r\nksocknal_peer_del_interface_locked(ksock_peer_t *peer, __u32 ipaddr)\r\n{\r\nstruct list_head *tmp;\r\nstruct list_head *nxt;\r\nksock_route_t *route;\r\nksock_conn_t *conn;\r\nint i;\r\nint j;\r\nfor (i = 0; i < peer->ksnp_n_passive_ips; i++)\r\nif (peer->ksnp_passive_ips[i] == ipaddr) {\r\nfor (j = i+1; j < peer->ksnp_n_passive_ips; j++)\r\npeer->ksnp_passive_ips[j-1] =\r\npeer->ksnp_passive_ips[j];\r\npeer->ksnp_n_passive_ips--;\r\nbreak;\r\n}\r\nlist_for_each_safe(tmp, nxt, &peer->ksnp_routes) {\r\nroute = list_entry (tmp, ksock_route_t, ksnr_list);\r\nif (route->ksnr_myipaddr != ipaddr)\r\ncontinue;\r\nif (route->ksnr_share_count != 0) {\r\nroute->ksnr_myipaddr = 0;\r\n} else {\r\nksocknal_del_route_locked(route);\r\n}\r\n}\r\nlist_for_each_safe(tmp, nxt, &peer->ksnp_conns) {\r\nconn = list_entry(tmp, ksock_conn_t, ksnc_list);\r\nif (conn->ksnc_myipaddr == ipaddr)\r\nksocknal_close_conn_locked (conn, 0);\r\n}\r\n}\r\nstatic int\r\nksocknal_del_interface(lnet_ni_t *ni, __u32 ipaddress)\r\n{\r\nksock_net_t *net = ni->ni_data;\r\nint rc = -ENOENT;\r\nstruct list_head *tmp;\r\nstruct list_head *nxt;\r\nksock_peer_t *peer;\r\n__u32 this_ip;\r\nint i;\r\nint j;\r\nwrite_lock_bh(&ksocknal_data.ksnd_global_lock);\r\nfor (i = 0; i < net->ksnn_ninterfaces; i++) {\r\nthis_ip = net->ksnn_interfaces[i].ksni_ipaddr;\r\nif (!(ipaddress == 0 ||\r\nipaddress == this_ip))\r\ncontinue;\r\nrc = 0;\r\nfor (j = i+1; j < net->ksnn_ninterfaces; j++)\r\nnet->ksnn_interfaces[j-1] =\r\nnet->ksnn_interfaces[j];\r\nnet->ksnn_ninterfaces--;\r\nfor (j = 0; j < ksocknal_data.ksnd_peer_hash_size; j++) {\r\nlist_for_each_safe(tmp, nxt,\r\n&ksocknal_data.ksnd_peers[j]) {\r\npeer = list_entry(tmp, ksock_peer_t,\r\nksnp_list);\r\nif (peer->ksnp_ni != ni)\r\ncontinue;\r\nksocknal_peer_del_interface_locked(peer, this_ip);\r\n}\r\n}\r\n}\r\nwrite_unlock_bh(&ksocknal_data.ksnd_global_lock);\r\nreturn rc;\r\n}\r\nint\r\nksocknal_ctl(lnet_ni_t *ni, unsigned int cmd, void *arg)\r\n{\r\nlnet_process_id_t id = {0};\r\nstruct libcfs_ioctl_data *data = arg;\r\nint rc;\r\nswitch (cmd) {\r\ncase IOC_LIBCFS_GET_INTERFACE: {\r\nksock_net_t *net = ni->ni_data;\r\nksock_interface_t *iface;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nif (data->ioc_count >= (__u32)net->ksnn_ninterfaces) {\r\nrc = -ENOENT;\r\n} else {\r\nrc = 0;\r\niface = &net->ksnn_interfaces[data->ioc_count];\r\ndata->ioc_u32[0] = iface->ksni_ipaddr;\r\ndata->ioc_u32[1] = iface->ksni_netmask;\r\ndata->ioc_u32[2] = iface->ksni_npeers;\r\ndata->ioc_u32[3] = iface->ksni_nroutes;\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn rc;\r\n}\r\ncase IOC_LIBCFS_ADD_INTERFACE:\r\nreturn ksocknal_add_interface(ni,\r\ndata->ioc_u32[0],\r\ndata->ioc_u32[1]);\r\ncase IOC_LIBCFS_DEL_INTERFACE:\r\nreturn ksocknal_del_interface(ni,\r\ndata->ioc_u32[0]);\r\ncase IOC_LIBCFS_GET_PEER: {\r\n__u32 myip = 0;\r\n__u32 ip = 0;\r\nint port = 0;\r\nint conn_count = 0;\r\nint share_count = 0;\r\nrc = ksocknal_get_peer_info(ni, data->ioc_count,\r\n&id, &myip, &ip, &port,\r\n&conn_count, &share_count);\r\nif (rc != 0)\r\nreturn rc;\r\ndata->ioc_nid = id.nid;\r\ndata->ioc_count = share_count;\r\ndata->ioc_u32[0] = ip;\r\ndata->ioc_u32[1] = port;\r\ndata->ioc_u32[2] = myip;\r\ndata->ioc_u32[3] = conn_count;\r\ndata->ioc_u32[4] = id.pid;\r\nreturn 0;\r\n}\r\ncase IOC_LIBCFS_ADD_PEER:\r\nid.nid = data->ioc_nid;\r\nid.pid = LUSTRE_SRV_LNET_PID;\r\nreturn ksocknal_add_peer (ni, id,\r\ndata->ioc_u32[0],\r\ndata->ioc_u32[1]);\r\ncase IOC_LIBCFS_DEL_PEER:\r\nid.nid = data->ioc_nid;\r\nid.pid = LNET_PID_ANY;\r\nreturn ksocknal_del_peer (ni, id,\r\ndata->ioc_u32[0]);\r\ncase IOC_LIBCFS_GET_CONN: {\r\nint txmem;\r\nint rxmem;\r\nint nagle;\r\nksock_conn_t *conn = ksocknal_get_conn_by_idx (ni, data->ioc_count);\r\nif (conn == NULL)\r\nreturn -ENOENT;\r\nksocknal_lib_get_conn_tunables(conn, &txmem, &rxmem, &nagle);\r\ndata->ioc_count = txmem;\r\ndata->ioc_nid = conn->ksnc_peer->ksnp_id.nid;\r\ndata->ioc_flags = nagle;\r\ndata->ioc_u32[0] = conn->ksnc_ipaddr;\r\ndata->ioc_u32[1] = conn->ksnc_port;\r\ndata->ioc_u32[2] = conn->ksnc_myipaddr;\r\ndata->ioc_u32[3] = conn->ksnc_type;\r\ndata->ioc_u32[4] = conn->ksnc_scheduler->kss_info->ksi_cpt;\r\ndata->ioc_u32[5] = rxmem;\r\ndata->ioc_u32[6] = conn->ksnc_peer->ksnp_id.pid;\r\nksocknal_conn_decref(conn);\r\nreturn 0;\r\n}\r\ncase IOC_LIBCFS_CLOSE_CONNECTION:\r\nid.nid = data->ioc_nid;\r\nid.pid = LNET_PID_ANY;\r\nreturn ksocknal_close_matching_conns (id,\r\ndata->ioc_u32[0]);\r\ncase IOC_LIBCFS_REGISTER_MYNID:\r\nif (data->ioc_nid == ni->ni_nid)\r\nreturn 0;\r\nCERROR("obsolete IOC_LIBCFS_REGISTER_MYNID: %s(%s)\n",\r\nlibcfs_nid2str(data->ioc_nid),\r\nlibcfs_nid2str(ni->ni_nid));\r\nreturn -EINVAL;\r\ncase IOC_LIBCFS_PUSH_CONNECTION:\r\nid.nid = data->ioc_nid;\r\nid.pid = LNET_PID_ANY;\r\nreturn ksocknal_push(ni, id);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void\r\nksocknal_free_buffers (void)\r\n{\r\nLASSERT (atomic_read(&ksocknal_data.ksnd_nactive_txs) == 0);\r\nif (ksocknal_data.ksnd_sched_info != NULL) {\r\nstruct ksock_sched_info *info;\r\nint i;\r\ncfs_percpt_for_each(info, i, ksocknal_data.ksnd_sched_info) {\r\nif (info->ksi_scheds != NULL) {\r\nLIBCFS_FREE(info->ksi_scheds,\r\ninfo->ksi_nthreads_max *\r\nsizeof(info->ksi_scheds[0]));\r\n}\r\n}\r\ncfs_percpt_free(ksocknal_data.ksnd_sched_info);\r\n}\r\nLIBCFS_FREE (ksocknal_data.ksnd_peers,\r\nsizeof (struct list_head) *\r\nksocknal_data.ksnd_peer_hash_size);\r\nspin_lock(&ksocknal_data.ksnd_tx_lock);\r\nif (!list_empty(&ksocknal_data.ksnd_idle_noop_txs)) {\r\nstruct list_head zlist;\r\nksock_tx_t *tx;\r\nlist_add(&zlist, &ksocknal_data.ksnd_idle_noop_txs);\r\nlist_del_init(&ksocknal_data.ksnd_idle_noop_txs);\r\nspin_unlock(&ksocknal_data.ksnd_tx_lock);\r\nwhile (!list_empty(&zlist)) {\r\ntx = list_entry(zlist.next, ksock_tx_t, tx_list);\r\nlist_del(&tx->tx_list);\r\nLIBCFS_FREE(tx, tx->tx_desc_size);\r\n}\r\n} else {\r\nspin_unlock(&ksocknal_data.ksnd_tx_lock);\r\n}\r\n}\r\nstatic void\r\nksocknal_base_shutdown(void)\r\n{\r\nstruct ksock_sched_info *info;\r\nksock_sched_t *sched;\r\nint i;\r\nint j;\r\nCDEBUG(D_MALLOC, "before NAL cleanup: kmem %d\n",\r\natomic_read (&libcfs_kmemory));\r\nLASSERT (ksocknal_data.ksnd_nnets == 0);\r\nswitch (ksocknal_data.ksnd_init) {\r\ndefault:\r\nLASSERT (0);\r\ncase SOCKNAL_INIT_ALL:\r\ncase SOCKNAL_INIT_DATA:\r\nLASSERT (ksocknal_data.ksnd_peers != NULL);\r\nfor (i = 0; i < ksocknal_data.ksnd_peer_hash_size; i++) {\r\nLASSERT (list_empty (&ksocknal_data.ksnd_peers[i]));\r\n}\r\nLASSERT(list_empty(&ksocknal_data.ksnd_nets));\r\nLASSERT (list_empty (&ksocknal_data.ksnd_enomem_conns));\r\nLASSERT (list_empty (&ksocknal_data.ksnd_zombie_conns));\r\nLASSERT (list_empty (&ksocknal_data.ksnd_connd_connreqs));\r\nLASSERT (list_empty (&ksocknal_data.ksnd_connd_routes));\r\nif (ksocknal_data.ksnd_sched_info != NULL) {\r\ncfs_percpt_for_each(info, i,\r\nksocknal_data.ksnd_sched_info) {\r\nif (info->ksi_scheds == NULL)\r\ncontinue;\r\nfor (j = 0; j < info->ksi_nthreads_max; j++) {\r\nsched = &info->ksi_scheds[j];\r\nLASSERT(list_empty(\r\n&sched->kss_tx_conns));\r\nLASSERT(list_empty(\r\n&sched->kss_rx_conns));\r\nLASSERT(list_empty(\r\n&sched->kss_zombie_noop_txs));\r\nLASSERT(sched->kss_nconns == 0);\r\n}\r\n}\r\n}\r\nksocknal_data.ksnd_shuttingdown = 1;\r\nwake_up_all(&ksocknal_data.ksnd_connd_waitq);\r\nwake_up_all(&ksocknal_data.ksnd_reaper_waitq);\r\nif (ksocknal_data.ksnd_sched_info != NULL) {\r\ncfs_percpt_for_each(info, i,\r\nksocknal_data.ksnd_sched_info) {\r\nif (info->ksi_scheds == NULL)\r\ncontinue;\r\nfor (j = 0; j < info->ksi_nthreads_max; j++) {\r\nsched = &info->ksi_scheds[j];\r\nwake_up_all(&sched->kss_waitq);\r\n}\r\n}\r\n}\r\ni = 4;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nwhile (ksocknal_data.ksnd_nthreads != 0) {\r\ni++;\r\nCDEBUG(((i & (-i)) == i) ? D_WARNING : D_NET,\r\n"waiting for %d threads to terminate\n",\r\nksocknal_data.ksnd_nthreads);\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1));\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nksocknal_free_buffers();\r\nksocknal_data.ksnd_init = SOCKNAL_INIT_NOTHING;\r\nbreak;\r\n}\r\nCDEBUG(D_MALLOC, "after NAL cleanup: kmem %d\n",\r\natomic_read (&libcfs_kmemory));\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic __u64\r\nksocknal_new_incarnation (void)\r\n{\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nreturn (((__u64)tv.tv_sec) * 1000000) + tv.tv_usec;\r\n}\r\nstatic int\r\nksocknal_base_startup(void)\r\n{\r\nstruct ksock_sched_info *info;\r\nint rc;\r\nint i;\r\nLASSERT (ksocknal_data.ksnd_init == SOCKNAL_INIT_NOTHING);\r\nLASSERT (ksocknal_data.ksnd_nnets == 0);\r\nmemset (&ksocknal_data, 0, sizeof (ksocknal_data));\r\nksocknal_data.ksnd_peer_hash_size = SOCKNAL_PEER_HASH_SIZE;\r\nLIBCFS_ALLOC (ksocknal_data.ksnd_peers,\r\nsizeof (struct list_head) *\r\nksocknal_data.ksnd_peer_hash_size);\r\nif (ksocknal_data.ksnd_peers == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ksocknal_data.ksnd_peer_hash_size; i++)\r\nINIT_LIST_HEAD(&ksocknal_data.ksnd_peers[i]);\r\nrwlock_init(&ksocknal_data.ksnd_global_lock);\r\nINIT_LIST_HEAD(&ksocknal_data.ksnd_nets);\r\nspin_lock_init(&ksocknal_data.ksnd_reaper_lock);\r\nINIT_LIST_HEAD (&ksocknal_data.ksnd_enomem_conns);\r\nINIT_LIST_HEAD (&ksocknal_data.ksnd_zombie_conns);\r\nINIT_LIST_HEAD (&ksocknal_data.ksnd_deathrow_conns);\r\ninit_waitqueue_head(&ksocknal_data.ksnd_reaper_waitq);\r\nspin_lock_init(&ksocknal_data.ksnd_connd_lock);\r\nINIT_LIST_HEAD (&ksocknal_data.ksnd_connd_connreqs);\r\nINIT_LIST_HEAD (&ksocknal_data.ksnd_connd_routes);\r\ninit_waitqueue_head(&ksocknal_data.ksnd_connd_waitq);\r\nspin_lock_init(&ksocknal_data.ksnd_tx_lock);\r\nINIT_LIST_HEAD (&ksocknal_data.ksnd_idle_noop_txs);\r\nksocknal_data.ksnd_init = SOCKNAL_INIT_DATA;\r\ntry_module_get(THIS_MODULE);\r\nksocknal_data.ksnd_sched_info = cfs_percpt_alloc(lnet_cpt_table(),\r\nsizeof(*info));\r\nif (ksocknal_data.ksnd_sched_info == NULL)\r\ngoto failed;\r\ncfs_percpt_for_each(info, i, ksocknal_data.ksnd_sched_info) {\r\nksock_sched_t *sched;\r\nint nthrs;\r\nnthrs = cfs_cpt_weight(lnet_cpt_table(), i);\r\nif (*ksocknal_tunables.ksnd_nscheds > 0) {\r\nnthrs = min(nthrs, *ksocknal_tunables.ksnd_nscheds);\r\n} else {\r\nnthrs = min(max(SOCKNAL_NSCHEDS, nthrs >> 1), nthrs);\r\n}\r\ninfo->ksi_nthreads_max = nthrs;\r\ninfo->ksi_cpt = i;\r\nLIBCFS_CPT_ALLOC(info->ksi_scheds, lnet_cpt_table(), i,\r\ninfo->ksi_nthreads_max * sizeof(*sched));\r\nif (info->ksi_scheds == NULL)\r\ngoto failed;\r\nfor (; nthrs > 0; nthrs--) {\r\nsched = &info->ksi_scheds[nthrs - 1];\r\nsched->kss_info = info;\r\nspin_lock_init(&sched->kss_lock);\r\nINIT_LIST_HEAD(&sched->kss_rx_conns);\r\nINIT_LIST_HEAD(&sched->kss_tx_conns);\r\nINIT_LIST_HEAD(&sched->kss_zombie_noop_txs);\r\ninit_waitqueue_head(&sched->kss_waitq);\r\n}\r\n}\r\nksocknal_data.ksnd_connd_starting = 0;\r\nksocknal_data.ksnd_connd_failed_stamp = 0;\r\nksocknal_data.ksnd_connd_starting_stamp = get_seconds();\r\nif (*ksocknal_tunables.ksnd_nconnds < SOCKNAL_CONND_RESV + 1)\r\n*ksocknal_tunables.ksnd_nconnds = SOCKNAL_CONND_RESV + 1;\r\nif (*ksocknal_tunables.ksnd_nconnds_max <\r\n*ksocknal_tunables.ksnd_nconnds) {\r\nksocknal_tunables.ksnd_nconnds_max =\r\nksocknal_tunables.ksnd_nconnds;\r\n}\r\nfor (i = 0; i < *ksocknal_tunables.ksnd_nconnds; i++) {\r\nchar name[16];\r\nspin_lock_bh(&ksocknal_data.ksnd_connd_lock);\r\nksocknal_data.ksnd_connd_starting++;\r\nspin_unlock_bh(&ksocknal_data.ksnd_connd_lock);\r\nsnprintf(name, sizeof(name), "socknal_cd%02d", i);\r\nrc = ksocknal_thread_start(ksocknal_connd,\r\n(void *)((ulong_ptr_t)i), name);\r\nif (rc != 0) {\r\nspin_lock_bh(&ksocknal_data.ksnd_connd_lock);\r\nksocknal_data.ksnd_connd_starting--;\r\nspin_unlock_bh(&ksocknal_data.ksnd_connd_lock);\r\nCERROR("Can't spawn socknal connd: %d\n", rc);\r\ngoto failed;\r\n}\r\n}\r\nrc = ksocknal_thread_start(ksocknal_reaper, NULL, "socknal_reaper");\r\nif (rc != 0) {\r\nCERROR ("Can't spawn socknal reaper: %d\n", rc);\r\ngoto failed;\r\n}\r\nksocknal_data.ksnd_init = SOCKNAL_INIT_ALL;\r\nreturn 0;\r\nfailed:\r\nksocknal_base_shutdown();\r\nreturn -ENETDOWN;\r\n}\r\nstatic void\r\nksocknal_debug_peerhash (lnet_ni_t *ni)\r\n{\r\nksock_peer_t *peer = NULL;\r\nstruct list_head *tmp;\r\nint i;\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nfor (i = 0; i < ksocknal_data.ksnd_peer_hash_size; i++) {\r\nlist_for_each (tmp, &ksocknal_data.ksnd_peers[i]) {\r\npeer = list_entry (tmp, ksock_peer_t, ksnp_list);\r\nif (peer->ksnp_ni == ni)\r\nbreak;\r\npeer = NULL;\r\n}\r\n}\r\nif (peer != NULL) {\r\nksock_route_t *route;\r\nksock_conn_t *conn;\r\nCWARN ("Active peer on shutdown: %s, ref %d, scnt %d, "\r\n"closing %d, accepting %d, err %d, zcookie %llu, "\r\n"txq %d, zc_req %d\n", libcfs_id2str(peer->ksnp_id),\r\natomic_read(&peer->ksnp_refcount),\r\npeer->ksnp_sharecount, peer->ksnp_closing,\r\npeer->ksnp_accepting, peer->ksnp_error,\r\npeer->ksnp_zc_next_cookie,\r\n!list_empty(&peer->ksnp_tx_queue),\r\n!list_empty(&peer->ksnp_zc_req_list));\r\nlist_for_each (tmp, &peer->ksnp_routes) {\r\nroute = list_entry(tmp, ksock_route_t, ksnr_list);\r\nCWARN ("Route: ref %d, schd %d, conn %d, cnted %d, "\r\n"del %d\n", atomic_read(&route->ksnr_refcount),\r\nroute->ksnr_scheduled, route->ksnr_connecting,\r\nroute->ksnr_connected, route->ksnr_deleted);\r\n}\r\nlist_for_each (tmp, &peer->ksnp_conns) {\r\nconn = list_entry(tmp, ksock_conn_t, ksnc_list);\r\nCWARN ("Conn: ref %d, sref %d, t %d, c %d\n",\r\natomic_read(&conn->ksnc_conn_refcount),\r\natomic_read(&conn->ksnc_sock_refcount),\r\nconn->ksnc_type, conn->ksnc_closing);\r\n}\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn;\r\n}\r\nvoid\r\nksocknal_shutdown (lnet_ni_t *ni)\r\n{\r\nksock_net_t *net = ni->ni_data;\r\nint i;\r\nlnet_process_id_t anyid = {0};\r\nanyid.nid = LNET_NID_ANY;\r\nanyid.pid = LNET_PID_ANY;\r\nLASSERT(ksocknal_data.ksnd_init == SOCKNAL_INIT_ALL);\r\nLASSERT(ksocknal_data.ksnd_nnets > 0);\r\nspin_lock_bh(&net->ksnn_lock);\r\nnet->ksnn_shutdown = 1;\r\nspin_unlock_bh(&net->ksnn_lock);\r\nksocknal_del_peer(ni, anyid, 0);\r\ni = 2;\r\nspin_lock_bh(&net->ksnn_lock);\r\nwhile (net->ksnn_npeers != 0) {\r\nspin_unlock_bh(&net->ksnn_lock);\r\ni++;\r\nCDEBUG(((i & (-i)) == i) ? D_WARNING : D_NET,\r\n"waiting for %d peers to disconnect\n",\r\nnet->ksnn_npeers);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1));\r\nksocknal_debug_peerhash(ni);\r\nspin_lock_bh(&net->ksnn_lock);\r\n}\r\nspin_unlock_bh(&net->ksnn_lock);\r\nfor (i = 0; i < net->ksnn_ninterfaces; i++) {\r\nLASSERT (net->ksnn_interfaces[i].ksni_npeers == 0);\r\nLASSERT (net->ksnn_interfaces[i].ksni_nroutes == 0);\r\n}\r\nlist_del(&net->ksnn_list);\r\nLIBCFS_FREE(net, sizeof(*net));\r\nksocknal_data.ksnd_nnets--;\r\nif (ksocknal_data.ksnd_nnets == 0)\r\nksocknal_base_shutdown();\r\n}\r\nstatic int\r\nksocknal_enumerate_interfaces(ksock_net_t *net)\r\n{\r\nchar **names;\r\nint i;\r\nint j;\r\nint rc;\r\nint n;\r\nn = libcfs_ipif_enumerate(&names);\r\nif (n <= 0) {\r\nCERROR("Can't enumerate interfaces: %d\n", n);\r\nreturn n;\r\n}\r\nfor (i = j = 0; i < n; i++) {\r\nint up;\r\n__u32 ip;\r\n__u32 mask;\r\nif (!strcmp(names[i], "lo"))\r\ncontinue;\r\nrc = libcfs_ipif_query(names[i], &up, &ip, &mask);\r\nif (rc != 0) {\r\nCWARN("Can't get interface %s info: %d\n",\r\nnames[i], rc);\r\ncontinue;\r\n}\r\nif (!up) {\r\nCWARN("Ignoring interface %s (down)\n",\r\nnames[i]);\r\ncontinue;\r\n}\r\nif (j == LNET_MAX_INTERFACES) {\r\nCWARN("Ignoring interface %s (too many interfaces)\n",\r\nnames[i]);\r\ncontinue;\r\n}\r\nnet->ksnn_interfaces[j].ksni_ipaddr = ip;\r\nnet->ksnn_interfaces[j].ksni_netmask = mask;\r\nstrncpy(&net->ksnn_interfaces[j].ksni_name[0],\r\nnames[i], IFNAMSIZ);\r\nj++;\r\n}\r\nlibcfs_ipif_free_enumeration(names, n);\r\nif (j == 0)\r\nCERROR("Can't find any usable interfaces\n");\r\nreturn j;\r\n}\r\nstatic int\r\nksocknal_search_new_ipif(ksock_net_t *net)\r\n{\r\nint new_ipif = 0;\r\nint i;\r\nfor (i = 0; i < net->ksnn_ninterfaces; i++) {\r\nchar *ifnam = &net->ksnn_interfaces[i].ksni_name[0];\r\nchar *colon = strchr(ifnam, ':');\r\nint found = 0;\r\nksock_net_t *tmp;\r\nint j;\r\nif (colon != NULL)\r\n*colon = 0;\r\nlist_for_each_entry(tmp, &ksocknal_data.ksnd_nets,\r\nksnn_list) {\r\nfor (j = 0; !found && j < tmp->ksnn_ninterfaces; j++) {\r\nchar *ifnam2 =\r\n&tmp->ksnn_interfaces[j].ksni_name[0];\r\nchar *colon2 = strchr(ifnam2, ':');\r\nif (colon2 != NULL)\r\n*colon2 = 0;\r\nfound = strcmp(ifnam, ifnam2) == 0;\r\nif (colon2 != NULL)\r\n*colon2 = ':';\r\n}\r\nif (found)\r\nbreak;\r\n}\r\nnew_ipif += !found;\r\nif (colon != NULL)\r\n*colon = ':';\r\n}\r\nreturn new_ipif;\r\n}\r\nstatic int\r\nksocknal_start_schedulers(struct ksock_sched_info *info)\r\n{\r\nint nthrs;\r\nint rc = 0;\r\nint i;\r\nif (info->ksi_nthreads == 0) {\r\nif (*ksocknal_tunables.ksnd_nscheds > 0) {\r\nnthrs = info->ksi_nthreads_max;\r\n} else {\r\nnthrs = cfs_cpt_weight(lnet_cpt_table(),\r\ninfo->ksi_cpt);\r\nnthrs = min(max(SOCKNAL_NSCHEDS, nthrs >> 1), nthrs);\r\nnthrs = min(SOCKNAL_NSCHEDS_HIGH, nthrs);\r\n}\r\nnthrs = min(nthrs, info->ksi_nthreads_max);\r\n} else {\r\nLASSERT(info->ksi_nthreads <= info->ksi_nthreads_max);\r\nnthrs = min(2, info->ksi_nthreads_max - info->ksi_nthreads);\r\n}\r\nfor (i = 0; i < nthrs; i++) {\r\nlong id;\r\nchar name[20];\r\nksock_sched_t *sched;\r\nid = KSOCK_THREAD_ID(info->ksi_cpt, info->ksi_nthreads + i);\r\nsched = &info->ksi_scheds[KSOCK_THREAD_SID(id)];\r\nsnprintf(name, sizeof(name), "socknal_sd%02d_%02d",\r\ninfo->ksi_cpt, (int)(sched - &info->ksi_scheds[0]));\r\nrc = ksocknal_thread_start(ksocknal_scheduler,\r\n(void *)id, name);\r\nif (rc == 0)\r\ncontinue;\r\nCERROR("Can't spawn thread %d for scheduler[%d]: %d\n",\r\ninfo->ksi_cpt, info->ksi_nthreads + i, rc);\r\nbreak;\r\n}\r\ninfo->ksi_nthreads += i;\r\nreturn rc;\r\n}\r\nstatic int\r\nksocknal_net_start_threads(ksock_net_t *net, __u32 *cpts, int ncpts)\r\n{\r\nint newif = ksocknal_search_new_ipif(net);\r\nint rc;\r\nint i;\r\nLASSERT(ncpts > 0 && ncpts <= cfs_cpt_number(lnet_cpt_table()));\r\nfor (i = 0; i < ncpts; i++) {\r\nstruct ksock_sched_info *info;\r\nint cpt = (cpts == NULL) ? i : cpts[i];\r\nLASSERT(cpt < cfs_cpt_number(lnet_cpt_table()));\r\ninfo = ksocknal_data.ksnd_sched_info[cpt];\r\nif (!newif && info->ksi_nthreads > 0)\r\ncontinue;\r\nrc = ksocknal_start_schedulers(info);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nksocknal_startup (lnet_ni_t *ni)\r\n{\r\nksock_net_t *net;\r\nint rc;\r\nint i;\r\nLASSERT (ni->ni_lnd == &the_ksocklnd);\r\nif (ksocknal_data.ksnd_init == SOCKNAL_INIT_NOTHING) {\r\nrc = ksocknal_base_startup();\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nLIBCFS_ALLOC(net, sizeof(*net));\r\nif (net == NULL)\r\ngoto fail_0;\r\nspin_lock_init(&net->ksnn_lock);\r\nnet->ksnn_incarnation = ksocknal_new_incarnation();\r\nni->ni_data = net;\r\nni->ni_peertimeout = *ksocknal_tunables.ksnd_peertimeout;\r\nni->ni_maxtxcredits = *ksocknal_tunables.ksnd_credits;\r\nni->ni_peertxcredits = *ksocknal_tunables.ksnd_peertxcredits;\r\nni->ni_peerrtrcredits = *ksocknal_tunables.ksnd_peerrtrcredits;\r\nif (ni->ni_interfaces[0] == NULL) {\r\nrc = ksocknal_enumerate_interfaces(net);\r\nif (rc <= 0)\r\ngoto fail_1;\r\nnet->ksnn_ninterfaces = 1;\r\n} else {\r\nfor (i = 0; i < LNET_MAX_INTERFACES; i++) {\r\nint up;\r\nif (ni->ni_interfaces[i] == NULL)\r\nbreak;\r\nrc = libcfs_ipif_query(\r\nni->ni_interfaces[i], &up,\r\n&net->ksnn_interfaces[i].ksni_ipaddr,\r\n&net->ksnn_interfaces[i].ksni_netmask);\r\nif (rc != 0) {\r\nCERROR("Can't get interface %s info: %d\n",\r\nni->ni_interfaces[i], rc);\r\ngoto fail_1;\r\n}\r\nif (!up) {\r\nCERROR("Interface %s is down\n",\r\nni->ni_interfaces[i]);\r\ngoto fail_1;\r\n}\r\nstrncpy(&net->ksnn_interfaces[i].ksni_name[0],\r\nni->ni_interfaces[i], IFNAMSIZ);\r\n}\r\nnet->ksnn_ninterfaces = i;\r\n}\r\nrc = ksocknal_net_start_threads(net, ni->ni_cpts, ni->ni_ncpts);\r\nif (rc != 0)\r\ngoto fail_1;\r\nni->ni_nid = LNET_MKNID(LNET_NIDNET(ni->ni_nid),\r\nnet->ksnn_interfaces[0].ksni_ipaddr);\r\nlist_add(&net->ksnn_list, &ksocknal_data.ksnd_nets);\r\nksocknal_data.ksnd_nnets++;\r\nreturn 0;\r\nfail_1:\r\nLIBCFS_FREE(net, sizeof(*net));\r\nfail_0:\r\nif (ksocknal_data.ksnd_nnets == 0)\r\nksocknal_base_shutdown();\r\nreturn -ENETDOWN;\r\n}\r\nstatic void __exit\r\nksocknal_module_fini (void)\r\n{\r\nlnet_unregister_lnd(&the_ksocklnd);\r\n}\r\nstatic int __init\r\nksocknal_module_init (void)\r\n{\r\nint rc;\r\nCLASSERT (SOCKLND_CONN_NTYPES <= 4);\r\nCLASSERT (SOCKLND_CONN_ACK == SOCKLND_CONN_BULK_IN);\r\nthe_ksocklnd.lnd_type = SOCKLND;\r\nthe_ksocklnd.lnd_startup = ksocknal_startup;\r\nthe_ksocklnd.lnd_shutdown = ksocknal_shutdown;\r\nthe_ksocklnd.lnd_ctl = ksocknal_ctl;\r\nthe_ksocklnd.lnd_send = ksocknal_send;\r\nthe_ksocklnd.lnd_recv = ksocknal_recv;\r\nthe_ksocklnd.lnd_notify = ksocknal_notify;\r\nthe_ksocklnd.lnd_query = ksocknal_query;\r\nthe_ksocklnd.lnd_accept = ksocknal_accept;\r\nrc = ksocknal_tunables_init();\r\nif (rc != 0)\r\nreturn rc;\r\nlnet_register_lnd(&the_ksocklnd);\r\nreturn 0;\r\n}
