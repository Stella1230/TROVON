static inline imm_struct *imm_dev(struct Scsi_Host *host)\r\n{\r\nreturn *(imm_struct **)&host->hostdata;\r\n}\r\nstatic void got_it(imm_struct *dev)\r\n{\r\ndev->base = dev->dev->port->base;\r\nif (dev->cur_cmd)\r\ndev->cur_cmd->SCp.phase = 1;\r\nelse\r\nwake_up(dev->waiting);\r\n}\r\nstatic void imm_wakeup(void *ref)\r\n{\r\nimm_struct *dev = (imm_struct *) ref;\r\nunsigned long flags;\r\nspin_lock_irqsave(&arbitration_lock, flags);\r\nif (dev->wanted) {\r\nparport_claim(dev->dev);\r\ngot_it(dev);\r\ndev->wanted = 0;\r\n}\r\nspin_unlock_irqrestore(&arbitration_lock, flags);\r\n}\r\nstatic int imm_pb_claim(imm_struct *dev)\r\n{\r\nunsigned long flags;\r\nint res = 1;\r\nspin_lock_irqsave(&arbitration_lock, flags);\r\nif (parport_claim(dev->dev) == 0) {\r\ngot_it(dev);\r\nres = 0;\r\n}\r\ndev->wanted = res;\r\nspin_unlock_irqrestore(&arbitration_lock, flags);\r\nreturn res;\r\n}\r\nstatic void imm_pb_dismiss(imm_struct *dev)\r\n{\r\nunsigned long flags;\r\nint wanted;\r\nspin_lock_irqsave(&arbitration_lock, flags);\r\nwanted = dev->wanted;\r\ndev->wanted = 0;\r\nspin_unlock_irqrestore(&arbitration_lock, flags);\r\nif (!wanted)\r\nparport_release(dev->dev);\r\n}\r\nstatic inline void imm_pb_release(imm_struct *dev)\r\n{\r\nparport_release(dev->dev);\r\n}\r\nstatic int imm_write_info(struct Scsi_Host *host, char *buffer, int length)\r\n{\r\nimm_struct *dev = imm_dev(host);\r\nif ((length > 5) && (strncmp(buffer, "mode=", 5) == 0)) {\r\ndev->mode = simple_strtoul(buffer + 5, NULL, 0);\r\nreturn length;\r\n}\r\nprintk("imm /proc: invalid variable\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int imm_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nimm_struct *dev = imm_dev(host);\r\nseq_printf(m, "Version : %s\n", IMM_VERSION);\r\nseq_printf(m, "Parport : %s\n", dev->dev->port->name);\r\nseq_printf(m, "Mode : %s\n", IMM_MODE_STRING[dev->mode]);\r\nreturn 0;\r\n}\r\nstatic unsigned char imm_wait(imm_struct *dev)\r\n{\r\nint k;\r\nunsigned short ppb = dev->base;\r\nunsigned char r;\r\nw_ctr(ppb, 0x0c);\r\nk = IMM_SPIN_TMO;\r\ndo {\r\nr = r_str(ppb);\r\nk--;\r\nudelay(1);\r\n}\r\nwhile (!(r & 0x80) && (k));\r\nw_ctr(ppb, 0x04);\r\nif (k)\r\nreturn (r & 0xb8);\r\nimm_fail(dev, DID_TIME_OUT);\r\nprintk("imm timeout in imm_wait\n");\r\nreturn 0;\r\n}\r\nstatic int imm_negotiate(imm_struct * tmp)\r\n{\r\nunsigned short base = tmp->base;\r\nunsigned char a, mode;\r\nswitch (tmp->mode) {\r\ncase IMM_NIBBLE:\r\nmode = 0x00;\r\nbreak;\r\ncase IMM_PS2:\r\nmode = 0x01;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nw_ctr(base, 0x04);\r\nudelay(5);\r\nw_dtr(base, mode);\r\nudelay(100);\r\nw_ctr(base, 0x06);\r\nudelay(5);\r\na = (r_str(base) & 0x20) ? 0 : 1;\r\nudelay(5);\r\nw_ctr(base, 0x07);\r\nudelay(5);\r\nw_ctr(base, 0x06);\r\nif (a) {\r\nprintk\r\n("IMM: IEEE1284 negotiate indicates no data available.\n");\r\nimm_fail(tmp, DID_ERROR);\r\n}\r\nreturn a;\r\n}\r\nstatic inline void epp_reset(unsigned short ppb)\r\n{\r\nint i;\r\ni = r_str(ppb);\r\nw_str(ppb, i);\r\nw_str(ppb, i & 0xfe);\r\n}\r\nstatic inline void ecp_sync(imm_struct *dev)\r\n{\r\nint i, ppb_hi = dev->base_hi;\r\nif (ppb_hi == 0)\r\nreturn;\r\nif ((r_ecr(ppb_hi) & 0xe0) == 0x60) {\r\nfor (i = 0; i < 100; i++) {\r\nif (r_ecr(ppb_hi) & 0x01)\r\nreturn;\r\nudelay(5);\r\n}\r\nprintk("imm: ECP sync failed as data still present in FIFO.\n");\r\n}\r\n}\r\nstatic int imm_byte_out(unsigned short base, const char *buffer, int len)\r\n{\r\nint i;\r\nw_ctr(base, 0x4);\r\nfor (i = len >> 1; i; i--) {\r\nw_dtr(base, *buffer++);\r\nw_ctr(base, 0x5);\r\nw_dtr(base, *buffer++);\r\nw_ctr(base, 0x0);\r\n}\r\nw_ctr(base, 0x4);\r\nreturn 1;\r\n}\r\nstatic int imm_nibble_in(unsigned short base, char *buffer, int len)\r\n{\r\nunsigned char l;\r\nint i;\r\nw_ctr(base, 0x4);\r\nfor (i = len; i; i--) {\r\nw_ctr(base, 0x6);\r\nl = (r_str(base) & 0xf0) >> 4;\r\nw_ctr(base, 0x5);\r\n*buffer++ = (r_str(base) & 0xf0) | l;\r\nw_ctr(base, 0x4);\r\n}\r\nreturn 1;\r\n}\r\nstatic int imm_byte_in(unsigned short base, char *buffer, int len)\r\n{\r\nint i;\r\nw_ctr(base, 0x4);\r\nfor (i = len; i; i--) {\r\nw_ctr(base, 0x26);\r\n*buffer++ = r_dtr(base);\r\nw_ctr(base, 0x25);\r\n}\r\nreturn 1;\r\n}\r\nstatic int imm_out(imm_struct *dev, char *buffer, int len)\r\n{\r\nunsigned short ppb = dev->base;\r\nint r = imm_wait(dev);\r\nif ((r & 0x18) != 0x08) {\r\nimm_fail(dev, DID_ERROR);\r\nprintk("IMM: returned SCSI status %2x\n", r);\r\nreturn 0;\r\n}\r\nswitch (dev->mode) {\r\ncase IMM_EPP_32:\r\ncase IMM_EPP_16:\r\ncase IMM_EPP_8:\r\nepp_reset(ppb);\r\nw_ctr(ppb, 0x4);\r\n#ifdef CONFIG_SCSI_IZIP_EPP16\r\nif (!(((long) buffer | len) & 0x01))\r\noutsw(ppb + 4, buffer, len >> 1);\r\n#else\r\nif (!(((long) buffer | len) & 0x03))\r\noutsl(ppb + 4, buffer, len >> 2);\r\n#endif\r\nelse\r\noutsb(ppb + 4, buffer, len);\r\nw_ctr(ppb, 0xc);\r\nr = !(r_str(ppb) & 0x01);\r\nw_ctr(ppb, 0xc);\r\necp_sync(dev);\r\nbreak;\r\ncase IMM_NIBBLE:\r\ncase IMM_PS2:\r\nr = imm_byte_out(ppb, buffer, len);\r\nbreak;\r\ndefault:\r\nprintk("IMM: bug in imm_out()\n");\r\nr = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic int imm_in(imm_struct *dev, char *buffer, int len)\r\n{\r\nunsigned short ppb = dev->base;\r\nint r = imm_wait(dev);\r\nif ((r & 0x18) != 0x18) {\r\nimm_fail(dev, DID_ERROR);\r\nreturn 0;\r\n}\r\nswitch (dev->mode) {\r\ncase IMM_NIBBLE:\r\nr = imm_nibble_in(ppb, buffer, len);\r\nw_ctr(ppb, 0xc);\r\nbreak;\r\ncase IMM_PS2:\r\nr = imm_byte_in(ppb, buffer, len);\r\nw_ctr(ppb, 0xc);\r\nbreak;\r\ncase IMM_EPP_32:\r\ncase IMM_EPP_16:\r\ncase IMM_EPP_8:\r\nepp_reset(ppb);\r\nw_ctr(ppb, 0x24);\r\n#ifdef CONFIG_SCSI_IZIP_EPP16\r\nif (!(((long) buffer | len) & 0x01))\r\ninsw(ppb + 4, buffer, len >> 1);\r\n#else\r\nif (!(((long) buffer | len) & 0x03))\r\ninsl(ppb + 4, buffer, len >> 2);\r\n#endif\r\nelse\r\ninsb(ppb + 4, buffer, len);\r\nw_ctr(ppb, 0x2c);\r\nr = !(r_str(ppb) & 0x01);\r\nw_ctr(ppb, 0x2c);\r\necp_sync(dev);\r\nbreak;\r\ndefault:\r\nprintk("IMM: bug in imm_ins()\n");\r\nr = 0;\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic int imm_cpp(unsigned short ppb, unsigned char b)\r\n{\r\nunsigned char s1, s2, s3;\r\nw_ctr(ppb, 0x0c);\r\nudelay(2);\r\nw_dtr(ppb, 0xaa);\r\nudelay(10);\r\nw_dtr(ppb, 0x55);\r\nudelay(10);\r\nw_dtr(ppb, 0x00);\r\nudelay(10);\r\nw_dtr(ppb, 0xff);\r\nudelay(10);\r\ns1 = r_str(ppb) & 0xb8;\r\nw_dtr(ppb, 0x87);\r\nudelay(10);\r\ns2 = r_str(ppb) & 0xb8;\r\nw_dtr(ppb, 0x78);\r\nudelay(10);\r\ns3 = r_str(ppb) & 0x38;\r\nw_dtr(ppb, b);\r\nudelay(2);\r\nw_ctr(ppb, 0x0c);\r\nudelay(10);\r\nw_ctr(ppb, 0x0d);\r\nudelay(2);\r\nw_ctr(ppb, 0x0c);\r\nudelay(10);\r\nw_dtr(ppb, 0xff);\r\nudelay(10);\r\nif ((s1 == 0xb8) && (s2 == 0x18) && (s3 == 0x30))\r\nreturn 1;\r\nif ((s1 == 0xb8) && (s2 == 0x18) && (s3 == 0x38))\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic inline int imm_connect(imm_struct *dev, int flag)\r\n{\r\nunsigned short ppb = dev->base;\r\nimm_cpp(ppb, 0xe0);\r\nimm_cpp(ppb, 0x30);\r\nif ((dev->mode == IMM_EPP_8) ||\r\n(dev->mode == IMM_EPP_16) ||\r\n(dev->mode == IMM_EPP_32))\r\nreturn imm_cpp(ppb, 0x28);\r\nreturn imm_cpp(ppb, 0xe0);\r\n}\r\nstatic void imm_disconnect(imm_struct *dev)\r\n{\r\nimm_cpp(dev->base, 0x30);\r\n}\r\nstatic int imm_select(imm_struct *dev, int target)\r\n{\r\nint k;\r\nunsigned short ppb = dev->base;\r\nw_ctr(ppb, 0xc);\r\nk = IMM_SELECT_TMO;\r\ndo {\r\nk--;\r\n} while ((r_str(ppb) & 0x08) && (k));\r\nif (!k)\r\nreturn 0;\r\nw_ctr(ppb, 0x4);\r\nw_dtr(ppb, 0x80 | (1 << target));\r\nudelay(1);\r\nw_ctr(ppb, 0xc);\r\nw_ctr(ppb, 0xd);\r\nk = IMM_SELECT_TMO;\r\ndo {\r\nk--;\r\n}\r\nwhile (!(r_str(ppb) & 0x08) && (k));\r\nw_ctr(ppb, 0xc);\r\nreturn (k) ? 1 : 0;\r\n}\r\nstatic int imm_init(imm_struct *dev)\r\n{\r\nif (imm_connect(dev, 0) != 1)\r\nreturn -EIO;\r\nimm_reset_pulse(dev->base);\r\nmdelay(1);\r\nimm_disconnect(dev);\r\nmdelay(1);\r\nreturn device_check(dev);\r\n}\r\nstatic inline int imm_send_command(struct scsi_cmnd *cmd)\r\n{\r\nimm_struct *dev = imm_dev(cmd->device->host);\r\nint k;\r\nfor (k = 0; k < cmd->cmd_len; k += 2)\r\nif (!imm_out(dev, &cmd->cmnd[k], 2))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int imm_completion(struct scsi_cmnd *cmd)\r\n{\r\nimm_struct *dev = imm_dev(cmd->device->host);\r\nunsigned short ppb = dev->base;\r\nunsigned long start_jiffies = jiffies;\r\nunsigned char r, v;\r\nint fast, bulk, status;\r\nv = cmd->cmnd[0];\r\nbulk = ((v == READ_6) ||\r\n(v == READ_10) || (v == WRITE_6) || (v == WRITE_10));\r\nw_ctr(ppb, 0x0c);\r\nr = (r_str(ppb) & 0xb8);\r\nwhile (r != (unsigned char) 0xb8) {\r\nif (time_after(jiffies, start_jiffies + 1))\r\nreturn 0;\r\nif (((r & 0x88) != 0x88) || (cmd->SCp.this_residual <= 0)) {\r\nimm_fail(dev, DID_ERROR);\r\nreturn -1;\r\n}\r\nif (dev->rd == 0) {\r\nfast = (bulk\r\n&& (cmd->SCp.this_residual >=\r\nIMM_BURST_SIZE)) ? IMM_BURST_SIZE : 2;\r\nstatus = imm_out(dev, cmd->SCp.ptr, fast);\r\n} else {\r\nfast = (bulk\r\n&& (cmd->SCp.this_residual >=\r\nIMM_BURST_SIZE)) ? IMM_BURST_SIZE : 1;\r\nstatus = imm_in(dev, cmd->SCp.ptr, fast);\r\n}\r\ncmd->SCp.ptr += fast;\r\ncmd->SCp.this_residual -= fast;\r\nif (!status) {\r\nimm_fail(dev, DID_BUS_BUSY);\r\nreturn -1;\r\n}\r\nif (cmd->SCp.buffer && !cmd->SCp.this_residual) {\r\nif (cmd->SCp.buffers_residual--) {\r\ncmd->SCp.buffer++;\r\ncmd->SCp.this_residual =\r\ncmd->SCp.buffer->length;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\nif (cmd->SCp.this_residual & 0x01)\r\ncmd->SCp.this_residual++;\r\n}\r\n}\r\nw_ctr(ppb, 0x0c);\r\nr = (r_str(ppb) & 0xb8);\r\nif (!(r & 0x80))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void imm_interrupt(struct work_struct *work)\r\n{\r\nimm_struct *dev = container_of(work, imm_struct, imm_tq.work);\r\nstruct scsi_cmnd *cmd = dev->cur_cmd;\r\nstruct Scsi_Host *host = cmd->device->host;\r\nunsigned long flags;\r\nif (imm_engine(dev, cmd)) {\r\nschedule_delayed_work(&dev->imm_tq, 1);\r\nreturn;\r\n}\r\n#if IMM_DEBUG > 0\r\nswitch ((cmd->result >> 16) & 0xff) {\r\ncase DID_OK:\r\nbreak;\r\ncase DID_NO_CONNECT:\r\nprintk("imm: no device at SCSI ID %i\n", cmd->device->id);\r\nbreak;\r\ncase DID_BUS_BUSY:\r\nprintk("imm: BUS BUSY - EPP timeout detected\n");\r\nbreak;\r\ncase DID_TIME_OUT:\r\nprintk("imm: unknown timeout\n");\r\nbreak;\r\ncase DID_ABORT:\r\nprintk("imm: told to abort\n");\r\nbreak;\r\ncase DID_PARITY:\r\nprintk("imm: parity error (???)\n");\r\nbreak;\r\ncase DID_ERROR:\r\nprintk("imm: internal driver error\n");\r\nbreak;\r\ncase DID_RESET:\r\nprintk("imm: told to reset device\n");\r\nbreak;\r\ncase DID_BAD_INTR:\r\nprintk("imm: bad interrupt (???)\n");\r\nbreak;\r\ndefault:\r\nprintk("imm: bad return code (%02x)\n",\r\n(cmd->result >> 16) & 0xff);\r\n}\r\n#endif\r\nif (cmd->SCp.phase > 1)\r\nimm_disconnect(dev);\r\nimm_pb_dismiss(dev);\r\nspin_lock_irqsave(host->host_lock, flags);\r\ndev->cur_cmd = NULL;\r\ncmd->scsi_done(cmd);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn;\r\n}\r\nstatic int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)\r\n{\r\nunsigned short ppb = dev->base;\r\nunsigned char l = 0, h = 0;\r\nint retv, x;\r\nif (dev->failed)\r\nreturn 0;\r\nswitch (cmd->SCp.phase) {\r\ncase 0:\r\nif (time_after(jiffies, dev->jstart + HZ)) {\r\nimm_fail(dev, DID_BUS_BUSY);\r\nreturn 0;\r\n}\r\nreturn 1;\r\ncase 1:\r\nimm_connect(dev, CONNECT_EPP_MAYBE);\r\ncmd->SCp.phase++;\r\ncase 2:\r\nif (!imm_select(dev, scmd_id(cmd))) {\r\nimm_fail(dev, DID_NO_CONNECT);\r\nreturn 0;\r\n}\r\ncmd->SCp.phase++;\r\ncase 3:\r\nw_ctr(ppb, 0x0c);\r\nif (!(r_str(ppb) & 0x80))\r\nreturn 1;\r\nif (!imm_send_command(cmd))\r\nreturn 0;\r\ncmd->SCp.phase++;\r\ncase 4:\r\nif (scsi_bufflen(cmd)) {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\n} else {\r\ncmd->SCp.buffer = NULL;\r\ncmd->SCp.this_residual = 0;\r\ncmd->SCp.ptr = NULL;\r\n}\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;\r\ncmd->SCp.phase++;\r\nif (cmd->SCp.this_residual & 0x01)\r\ncmd->SCp.this_residual++;\r\ncase 5:\r\nw_ctr(ppb, 0x0c);\r\nif (!(r_str(ppb) & 0x80))\r\nreturn 1;\r\nx = (r_str(ppb) & 0xb8);\r\ndev->rd = (x & 0x10) ? 1 : 0;\r\ndev->dp = (x & 0x20) ? 0 : 1;\r\nif ((dev->dp) && (dev->rd))\r\nif (imm_negotiate(dev))\r\nreturn 0;\r\ncmd->SCp.phase++;\r\ncase 6:\r\nw_ctr(ppb, 0x0c);\r\nif (!(r_str(ppb) & 0x80))\r\nreturn 1;\r\nif (dev->dp) {\r\nretv = imm_completion(cmd);\r\nif (retv == -1)\r\nreturn 0;\r\nif (retv == 0)\r\nreturn 1;\r\n}\r\ncmd->SCp.phase++;\r\ncase 7:\r\nif ((dev->dp) && (dev->rd)) {\r\nif ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {\r\nw_ctr(ppb, 0x4);\r\nw_ctr(ppb, 0xc);\r\nw_ctr(ppb, 0xe);\r\nw_ctr(ppb, 0x4);\r\n}\r\n}\r\ncmd->SCp.phase++;\r\ncase 8:\r\nif (imm_wait(dev) != (unsigned char) 0xb8) {\r\nimm_fail(dev, DID_ERROR);\r\nreturn 0;\r\n}\r\nif (imm_negotiate(dev))\r\nreturn 0;\r\nif (imm_in(dev, &l, 1)) {\r\nif (imm_wait(dev) == (unsigned char) 0xb8)\r\nimm_in(dev, &h, 1);\r\ncmd->result = (DID_OK << 16) + (l & STATUS_MASK);\r\n}\r\nif ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {\r\nw_ctr(ppb, 0x4);\r\nw_ctr(ppb, 0xc);\r\nw_ctr(ppb, 0xe);\r\nw_ctr(ppb, 0x4);\r\n}\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nprintk("imm: Invalid scsi phase\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int imm_queuecommand_lck(struct scsi_cmnd *cmd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nimm_struct *dev = imm_dev(cmd->device->host);\r\nif (dev->cur_cmd) {\r\nprintk("IMM: bug in imm_queuecommand\n");\r\nreturn 0;\r\n}\r\ndev->failed = 0;\r\ndev->jstart = jiffies;\r\ndev->cur_cmd = cmd;\r\ncmd->scsi_done = done;\r\ncmd->result = DID_ERROR << 16;\r\ncmd->SCp.phase = 0;\r\nschedule_delayed_work(&dev->imm_tq, 0);\r\nimm_pb_claim(dev);\r\nreturn 0;\r\n}\r\nint imm_abort(struct scsi_cmnd *cmd)\r\n{\r\nimm_struct *dev = imm_dev(cmd->device->host);\r\nswitch (cmd->SCp.phase) {\r\ncase 0:\r\ncase 1:\r\ndev->cur_cmd = NULL;\r\nreturn SUCCESS;\r\nbreak;\r\ndefault:\r\nreturn FAILED;\r\nbreak;\r\n}\r\n}\r\nstatic void imm_reset_pulse(unsigned int base)\r\n{\r\nw_ctr(base, 0x04);\r\nw_dtr(base, 0x40);\r\nudelay(1);\r\nw_ctr(base, 0x0c);\r\nw_ctr(base, 0x0d);\r\nudelay(50);\r\nw_ctr(base, 0x0c);\r\nw_ctr(base, 0x04);\r\n}\r\nstatic int imm_reset(struct scsi_cmnd *cmd)\r\n{\r\nimm_struct *dev = imm_dev(cmd->device->host);\r\nif (cmd->SCp.phase)\r\nimm_disconnect(dev);\r\ndev->cur_cmd = NULL;\r\nimm_connect(dev, CONNECT_NORMAL);\r\nimm_reset_pulse(dev->base);\r\nmdelay(1);\r\nimm_disconnect(dev);\r\nmdelay(1);\r\nreturn SUCCESS;\r\n}\r\nstatic int device_check(imm_struct *dev)\r\n{\r\nstatic char cmd[6] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nint loop, old_mode, status, k, ppb = dev->base;\r\nunsigned char l;\r\nold_mode = dev->mode;\r\nfor (loop = 0; loop < 8; loop++) {\r\nif ((ppb & 0x0007) == 0x0000)\r\ndev->mode = IMM_EPP_32;\r\nsecond_pass:\r\nimm_connect(dev, CONNECT_EPP_MAYBE);\r\nif (!imm_select(dev, loop)) {\r\nimm_disconnect(dev);\r\ncontinue;\r\n}\r\nprintk("imm: Found device at ID %i, Attempting to use %s\n",\r\nloop, IMM_MODE_STRING[dev->mode]);\r\nstatus = 1;\r\nw_ctr(ppb, 0x0c);\r\nfor (l = 0; (l < 3) && (status); l++)\r\nstatus = imm_out(dev, &cmd[l << 1], 2);\r\nif (!status) {\r\nimm_disconnect(dev);\r\nimm_connect(dev, CONNECT_EPP_MAYBE);\r\nimm_reset_pulse(dev->base);\r\nudelay(1000);\r\nimm_disconnect(dev);\r\nudelay(1000);\r\nif (dev->mode == IMM_EPP_32) {\r\ndev->mode = old_mode;\r\ngoto second_pass;\r\n}\r\nprintk("imm: Unable to establish communication\n");\r\nreturn -EIO;\r\n}\r\nw_ctr(ppb, 0x0c);\r\nk = 1000000;\r\ndo {\r\nl = r_str(ppb);\r\nk--;\r\nudelay(1);\r\n} while (!(l & 0x80) && (k));\r\nl &= 0xb8;\r\nif (l != 0xb8) {\r\nimm_disconnect(dev);\r\nimm_connect(dev, CONNECT_EPP_MAYBE);\r\nimm_reset_pulse(dev->base);\r\nudelay(1000);\r\nimm_disconnect(dev);\r\nudelay(1000);\r\nif (dev->mode == IMM_EPP_32) {\r\ndev->mode = old_mode;\r\ngoto second_pass;\r\n}\r\nprintk\r\n("imm: Unable to establish communication\n");\r\nreturn -EIO;\r\n}\r\nimm_disconnect(dev);\r\nprintk\r\n("imm: Communication established at 0x%x with ID %i using %s\n",\r\nppb, loop, IMM_MODE_STRING[dev->mode]);\r\nimm_connect(dev, CONNECT_EPP_MAYBE);\r\nimm_reset_pulse(dev->base);\r\nudelay(1000);\r\nimm_disconnect(dev);\r\nudelay(1000);\r\nreturn 0;\r\n}\r\nprintk("imm: No devices found\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int imm_adjust_queue(struct scsi_device *device)\r\n{\r\nblk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);\r\nreturn 0;\r\n}\r\nstatic int __imm_attach(struct parport *pb)\r\n{\r\nstruct Scsi_Host *host;\r\nimm_struct *dev;\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waiting);\r\nDEFINE_WAIT(wait);\r\nint ports;\r\nint modes, ppb;\r\nint err = -ENOMEM;\r\ninit_waitqueue_head(&waiting);\r\ndev = kzalloc(sizeof(imm_struct), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->base = -1;\r\ndev->mode = IMM_AUTODETECT;\r\nINIT_LIST_HEAD(&dev->list);\r\ndev->dev = parport_register_device(pb, "imm", NULL, imm_wakeup,\r\nNULL, 0, dev);\r\nif (!dev->dev)\r\ngoto out;\r\nerr = -EBUSY;\r\ndev->waiting = &waiting;\r\nprepare_to_wait(&waiting, &wait, TASK_UNINTERRUPTIBLE);\r\nif (imm_pb_claim(dev))\r\nschedule_timeout(3 * HZ);\r\nif (dev->wanted) {\r\nprintk(KERN_ERR "imm%d: failed to claim parport because "\r\n"a pardevice is owning the port for too long "\r\n"time!\n", pb->number);\r\nimm_pb_dismiss(dev);\r\ndev->waiting = NULL;\r\nfinish_wait(&waiting, &wait);\r\ngoto out1;\r\n}\r\ndev->waiting = NULL;\r\nfinish_wait(&waiting, &wait);\r\nppb = dev->base = dev->dev->port->base;\r\ndev->base_hi = dev->dev->port->base_hi;\r\nw_ctr(ppb, 0x0c);\r\nmodes = dev->dev->port->modes;\r\ndev->mode = IMM_NIBBLE;\r\nif (modes & PARPORT_MODE_TRISTATE)\r\ndev->mode = IMM_PS2;\r\nerr = imm_init(dev);\r\nimm_pb_release(dev);\r\nif (err)\r\ngoto out1;\r\nif (dev->mode == IMM_NIBBLE || dev->mode == IMM_PS2)\r\nports = 3;\r\nelse\r\nports = 8;\r\nINIT_DELAYED_WORK(&dev->imm_tq, imm_interrupt);\r\nerr = -ENOMEM;\r\nhost = scsi_host_alloc(&imm_template, sizeof(imm_struct *));\r\nif (!host)\r\ngoto out1;\r\nhost->io_port = pb->base;\r\nhost->n_io_port = ports;\r\nhost->dma_channel = -1;\r\nhost->unique_id = pb->number;\r\n*(imm_struct **)&host->hostdata = dev;\r\ndev->host = host;\r\nlist_add_tail(&dev->list, &imm_hosts);\r\nerr = scsi_add_host(host, NULL);\r\nif (err)\r\ngoto out2;\r\nscsi_scan_host(host);\r\nreturn 0;\r\nout2:\r\nlist_del_init(&dev->list);\r\nscsi_host_put(host);\r\nout1:\r\nparport_unregister_device(dev->dev);\r\nout:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void imm_attach(struct parport *pb)\r\n{\r\n__imm_attach(pb);\r\n}\r\nstatic void imm_detach(struct parport *pb)\r\n{\r\nimm_struct *dev;\r\nlist_for_each_entry(dev, &imm_hosts, list) {\r\nif (dev->dev->port == pb) {\r\nlist_del_init(&dev->list);\r\nscsi_remove_host(dev->host);\r\nscsi_host_put(dev->host);\r\nparport_unregister_device(dev->dev);\r\nkfree(dev);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int __init imm_driver_init(void)\r\n{\r\nprintk("imm: Version %s\n", IMM_VERSION);\r\nreturn parport_register_driver(&imm_driver);\r\n}\r\nstatic void __exit imm_driver_exit(void)\r\n{\r\nparport_unregister_driver(&imm_driver);\r\n}
