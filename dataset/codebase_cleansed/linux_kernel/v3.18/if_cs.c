static inline unsigned int if_cs_read8(struct if_cs_card *card, uint reg)\r\n{\r\nunsigned int val = ioread8(card->iobase + reg);\r\nif (debug_output)\r\nprintk(KERN_INFO "inb %08x<%02x\n", reg, val);\r\nreturn val;\r\n}\r\nstatic inline unsigned int if_cs_read16(struct if_cs_card *card, uint reg)\r\n{\r\nunsigned int val = ioread16(card->iobase + reg);\r\nif (debug_output)\r\nprintk(KERN_INFO "inw %08x<%04x\n", reg, val);\r\nreturn val;\r\n}\r\nstatic inline void if_cs_read16_rep(\r\nstruct if_cs_card *card,\r\nuint reg,\r\nvoid *buf,\r\nunsigned long count)\r\n{\r\nif (debug_output)\r\nprintk(KERN_INFO "insw %08x<(0x%lx words)\n",\r\nreg, count);\r\nioread16_rep(card->iobase + reg, buf, count);\r\n}\r\nstatic inline void if_cs_write8(struct if_cs_card *card, uint reg, u8 val)\r\n{\r\nif (debug_output)\r\nprintk(KERN_INFO "outb %08x>%02x\n", reg, val);\r\niowrite8(val, card->iobase + reg);\r\n}\r\nstatic inline void if_cs_write16(struct if_cs_card *card, uint reg, u16 val)\r\n{\r\nif (debug_output)\r\nprintk(KERN_INFO "outw %08x>%04x\n", reg, val);\r\niowrite16(val, card->iobase + reg);\r\n}\r\nstatic inline void if_cs_write16_rep(\r\nstruct if_cs_card *card,\r\nuint reg,\r\nconst void *buf,\r\nunsigned long count)\r\n{\r\nif (debug_output)\r\nprintk(KERN_INFO "outsw %08x>(0x%lx words)\n",\r\nreg, count);\r\niowrite16_rep(card->iobase + reg, buf, count);\r\n}\r\nstatic int if_cs_poll_while_fw_download(struct if_cs_card *card, uint addr, u8 reg)\r\n{\r\nint i;\r\nfor (i = 0; i < 100000; i++) {\r\nu8 val = if_cs_read8(card, addr);\r\nif (val == reg)\r\nreturn 0;\r\nudelay(5);\r\n}\r\nreturn -ETIME;\r\n}\r\nstatic inline u32 get_model(u16 manf_id, u16 card_id)\r\n{\r\nif (manf_id == CF8305_MANFID && card_id == CF8305_CARDID)\r\nreturn MODEL_8305;\r\nelse if (manf_id == CF8381_MANFID && card_id == CF8381_CARDID)\r\nreturn MODEL_8381;\r\nelse if (manf_id == CF8385_MANFID && card_id == CF8385_CARDID)\r\nreturn MODEL_8385;\r\nreturn MODEL_UNKNOWN;\r\n}\r\nstatic inline void if_cs_enable_ints(struct if_cs_card *card)\r\n{\r\nlbs_deb_enter(LBS_DEB_CS);\r\nif_cs_write16(card, IF_CS_HOST_INT_MASK, 0);\r\n}\r\nstatic inline void if_cs_disable_ints(struct if_cs_card *card)\r\n{\r\nlbs_deb_enter(LBS_DEB_CS);\r\nif_cs_write16(card, IF_CS_HOST_INT_MASK, IF_CS_BIT_MASK);\r\n}\r\nstatic int if_cs_send_cmd(struct lbs_private *priv, u8 *buf, u16 nb)\r\n{\r\nstruct if_cs_card *card = (struct if_cs_card *)priv->card;\r\nint ret = -1;\r\nint loops = 0;\r\nlbs_deb_enter(LBS_DEB_CS);\r\nif_cs_disable_ints(card);\r\nwhile (1) {\r\nu16 status = if_cs_read16(card, IF_CS_CARD_STATUS);\r\nif (status & IF_CS_BIT_COMMAND)\r\nbreak;\r\nif (++loops > 100) {\r\nnetdev_err(priv->dev, "card not ready for commands\n");\r\ngoto done;\r\n}\r\nmdelay(1);\r\n}\r\nif_cs_write16(card, IF_CS_CMD_LEN, nb);\r\nif_cs_write16_rep(card, IF_CS_CMD, buf, nb / 2);\r\nif (nb & 1)\r\nif_cs_write8(card, IF_CS_CMD, buf[nb-1]);\r\nif_cs_write16(card, IF_CS_HOST_STATUS, IF_CS_BIT_COMMAND);\r\nif_cs_write16(card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_COMMAND);\r\nret = 0;\r\ndone:\r\nif_cs_enable_ints(card);\r\nlbs_deb_leave_args(LBS_DEB_CS, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void if_cs_send_data(struct lbs_private *priv, u8 *buf, u16 nb)\r\n{\r\nstruct if_cs_card *card = (struct if_cs_card *)priv->card;\r\nu16 status;\r\nlbs_deb_enter(LBS_DEB_CS);\r\nif_cs_disable_ints(card);\r\nstatus = if_cs_read16(card, IF_CS_CARD_STATUS);\r\nBUG_ON((status & IF_CS_BIT_TX) == 0);\r\nif_cs_write16(card, IF_CS_WRITE_LEN, nb);\r\nif_cs_write16_rep(card, IF_CS_WRITE, buf, nb / 2);\r\nif (nb & 1)\r\nif_cs_write8(card, IF_CS_WRITE, buf[nb-1]);\r\nif_cs_write16(card, IF_CS_HOST_STATUS, IF_CS_BIT_TX);\r\nif_cs_write16(card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_TX);\r\nif_cs_enable_ints(card);\r\nlbs_deb_leave(LBS_DEB_CS);\r\n}\r\nstatic int if_cs_receive_cmdres(struct lbs_private *priv, u8 *data, u32 *len)\r\n{\r\nunsigned long flags;\r\nint ret = -1;\r\nu16 status;\r\nlbs_deb_enter(LBS_DEB_CS);\r\nstatus = if_cs_read16(priv->card, IF_CS_CARD_STATUS);\r\nif ((status & IF_CS_BIT_RESP) == 0) {\r\nnetdev_err(priv->dev, "no cmd response in card\n");\r\n*len = 0;\r\ngoto out;\r\n}\r\n*len = if_cs_read16(priv->card, IF_CS_RESP_LEN);\r\nif ((*len == 0) || (*len > LBS_CMD_BUFFER_SIZE)) {\r\nnetdev_err(priv->dev,\r\n"card cmd buffer has invalid # of bytes (%d)\n",\r\n*len);\r\ngoto out;\r\n}\r\nif_cs_read16_rep(priv->card, IF_CS_RESP, data, *len/sizeof(u16));\r\nif (*len & 1)\r\ndata[*len-1] = if_cs_read8(priv->card, IF_CS_RESP);\r\n*len -= 8;\r\nret = 0;\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\npriv->dnld_sent = DNLD_RES_RECEIVED;\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_CS, "ret %d, len %d", ret, *len);\r\nreturn ret;\r\n}\r\nstatic struct sk_buff *if_cs_receive_data(struct lbs_private *priv)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nu16 len;\r\nu8 *data;\r\nlbs_deb_enter(LBS_DEB_CS);\r\nlen = if_cs_read16(priv->card, IF_CS_READ_LEN);\r\nif (len == 0 || len > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {\r\nnetdev_err(priv->dev,\r\n"card data buffer has invalid # of bytes (%d)\n",\r\nlen);\r\npriv->dev->stats.rx_dropped++;\r\ngoto dat_err;\r\n}\r\nskb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE + 2);\r\nif (!skb)\r\ngoto out;\r\nskb_put(skb, len);\r\nskb_reserve(skb, 2);\r\ndata = skb->data;\r\nif_cs_read16_rep(priv->card, IF_CS_READ, data, len/sizeof(u16));\r\nif (len & 1)\r\ndata[len-1] = if_cs_read8(priv->card, IF_CS_READ);\r\ndat_err:\r\nif_cs_write16(priv->card, IF_CS_HOST_STATUS, IF_CS_BIT_RX);\r\nif_cs_write16(priv->card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_RX);\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_CS, "ret %p", skb);\r\nreturn skb;\r\n}\r\nstatic irqreturn_t if_cs_interrupt(int irq, void *data)\r\n{\r\nstruct if_cs_card *card = data;\r\nstruct lbs_private *priv = card->priv;\r\nu16 cause;\r\nlbs_deb_enter(LBS_DEB_CS);\r\ncause = if_cs_read16(card, IF_CS_CARD_INT_CAUSE);\r\nlbs_deb_cs("cause 0x%04x\n", cause);\r\nif (cause == 0) {\r\nreturn IRQ_NONE;\r\n}\r\nif (cause == 0xffff) {\r\ncard->priv->surpriseremoved = 1;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (cause & IF_CS_BIT_RX) {\r\nstruct sk_buff *skb;\r\nlbs_deb_cs("rx packet\n");\r\nskb = if_cs_receive_data(priv);\r\nif (skb)\r\nlbs_process_rxed_packet(priv, skb);\r\n}\r\nif (cause & IF_CS_BIT_TX) {\r\nlbs_deb_cs("tx done\n");\r\nlbs_host_to_card_done(priv);\r\n}\r\nif (cause & IF_CS_BIT_RESP) {\r\nunsigned long flags;\r\nu8 i;\r\nlbs_deb_cs("cmd resp\n");\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\ni = (priv->resp_idx == 0) ? 1 : 0;\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\nBUG_ON(priv->resp_len[i]);\r\nif_cs_receive_cmdres(priv, priv->resp_buf[i],\r\n&priv->resp_len[i]);\r\nspin_lock_irqsave(&priv->driver_lock, flags);\r\nlbs_notify_command_response(priv, i);\r\nspin_unlock_irqrestore(&priv->driver_lock, flags);\r\n}\r\nif (cause & IF_CS_BIT_EVENT) {\r\nu16 status = if_cs_read16(priv->card, IF_CS_CARD_STATUS);\r\nif_cs_write16(priv->card, IF_CS_HOST_INT_CAUSE,\r\nIF_CS_BIT_EVENT);\r\nlbs_queue_event(priv, (status & IF_CS_CARD_STATUS_MASK) >> 8);\r\n}\r\nif_cs_write16(card, IF_CS_CARD_INT_CAUSE, cause & IF_CS_BIT_MASK);\r\nlbs_deb_leave(LBS_DEB_CS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int if_cs_prog_helper(struct if_cs_card *card, const struct firmware *fw)\r\n{\r\nint ret = 0;\r\nint sent = 0;\r\nu8 scratch;\r\nlbs_deb_enter(LBS_DEB_CS);\r\nif (card->align_regs)\r\nscratch = if_cs_read16(card, IF_CS_SCRATCH) >> 8;\r\nelse\r\nscratch = if_cs_read8(card, IF_CS_SCRATCH);\r\nif (scratch == IF_CS_SCRATCH_HELPER_OK)\r\ngoto done;\r\nif (scratch != IF_CS_SCRATCH_BOOT_OK) {\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nlbs_deb_cs("helper size %td\n", fw->size);\r\nfor (;;) {\r\nint count = 256;\r\nint remain = fw->size - sent;\r\nif (remain < count)\r\ncount = remain;\r\nif_cs_write16(card, IF_CS_CMD_LEN, count);\r\nif (count)\r\nif_cs_write16_rep(card, IF_CS_CMD,\r\n&fw->data[sent],\r\ncount >> 1);\r\nif_cs_write8(card, IF_CS_HOST_STATUS, IF_CS_BIT_COMMAND);\r\nif_cs_write16(card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_COMMAND);\r\nret = if_cs_poll_while_fw_download(card, IF_CS_CARD_STATUS,\r\nIF_CS_BIT_COMMAND);\r\nif (ret < 0) {\r\npr_err("can't download helper at 0x%x, ret %d\n",\r\nsent, ret);\r\ngoto done;\r\n}\r\nif (count == 0)\r\nbreak;\r\nsent += count;\r\n}\r\ndone:\r\nlbs_deb_leave_args(LBS_DEB_CS, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic int if_cs_prog_real(struct if_cs_card *card, const struct firmware *fw)\r\n{\r\nint ret = 0;\r\nint retry = 0;\r\nint len = 0;\r\nint sent;\r\nlbs_deb_enter(LBS_DEB_CS);\r\nlbs_deb_cs("fw size %td\n", fw->size);\r\nret = if_cs_poll_while_fw_download(card, IF_CS_SQ_READ_LOW,\r\nIF_CS_SQ_HELPER_OK);\r\nif (ret < 0) {\r\npr_err("helper firmware doesn't answer\n");\r\ngoto done;\r\n}\r\nfor (sent = 0; sent < fw->size; sent += len) {\r\nlen = if_cs_read16(card, IF_CS_SQ_READ_LOW);\r\nif (len & 1) {\r\nretry++;\r\npr_info("odd, need to retry this firmware block\n");\r\n} else {\r\nretry = 0;\r\n}\r\nif (retry > 20) {\r\npr_err("could not download firmware\n");\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif (retry) {\r\nsent -= len;\r\n}\r\nif_cs_write16(card, IF_CS_CMD_LEN, len);\r\nif_cs_write16_rep(card, IF_CS_CMD,\r\n&fw->data[sent],\r\n(len+1) >> 1);\r\nif_cs_write8(card, IF_CS_HOST_STATUS, IF_CS_BIT_COMMAND);\r\nif_cs_write16(card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_COMMAND);\r\nret = if_cs_poll_while_fw_download(card, IF_CS_CARD_STATUS,\r\nIF_CS_BIT_COMMAND);\r\nif (ret < 0) {\r\npr_err("can't download firmware at 0x%x\n", sent);\r\ngoto done;\r\n}\r\n}\r\nret = if_cs_poll_while_fw_download(card, IF_CS_SCRATCH, 0x5a);\r\nif (ret < 0)\r\npr_err("firmware download failed\n");\r\ndone:\r\nlbs_deb_leave_args(LBS_DEB_CS, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void if_cs_prog_firmware(struct lbs_private *priv, int ret,\r\nconst struct firmware *helper,\r\nconst struct firmware *mainfw)\r\n{\r\nstruct if_cs_card *card = priv->card;\r\nif (ret) {\r\npr_err("failed to find firmware (%d)\n", ret);\r\nreturn;\r\n}\r\nret = if_cs_prog_helper(card, helper);\r\nif (ret == 0 && (card->model != MODEL_8305))\r\nret = if_cs_prog_real(card, mainfw);\r\nif (ret)\r\nreturn;\r\nret = request_irq(card->p_dev->irq, if_cs_interrupt,\r\nIRQF_SHARED, DRV_NAME, card);\r\nif (ret) {\r\npr_err("error in request_irq\n");\r\nreturn;\r\n}\r\nif_cs_write16(card, IF_CS_CARD_INT_CAUSE, IF_CS_BIT_MASK);\r\nif_cs_enable_ints(card);\r\npriv->fw_ready = 1;\r\nif (lbs_start_card(priv) != 0) {\r\npr_err("could not activate card\n");\r\nfree_irq(card->p_dev->irq, card);\r\n}\r\n}\r\nstatic int if_cs_host_to_card(struct lbs_private *priv,\r\nu8 type,\r\nu8 *buf,\r\nu16 nb)\r\n{\r\nint ret = -1;\r\nlbs_deb_enter_args(LBS_DEB_CS, "type %d, bytes %d", type, nb);\r\nswitch (type) {\r\ncase MVMS_DAT:\r\npriv->dnld_sent = DNLD_DATA_SENT;\r\nif_cs_send_data(priv, buf, nb);\r\nret = 0;\r\nbreak;\r\ncase MVMS_CMD:\r\npriv->dnld_sent = DNLD_CMD_SENT;\r\nret = if_cs_send_cmd(priv, buf, nb);\r\nbreak;\r\ndefault:\r\nnetdev_err(priv->dev, "%s: unsupported type %d\n",\r\n__func__, type);\r\n}\r\nlbs_deb_leave_args(LBS_DEB_CS, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void if_cs_release(struct pcmcia_device *p_dev)\r\n{\r\nstruct if_cs_card *card = p_dev->priv;\r\nlbs_deb_enter(LBS_DEB_CS);\r\nfree_irq(p_dev->irq, card);\r\npcmcia_disable_device(p_dev);\r\nif (card->iobase)\r\nioport_unmap(card->iobase);\r\nlbs_deb_leave(LBS_DEB_CS);\r\n}\r\nstatic int if_cs_ioprobe(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\nif (p_dev->resource[1]->end) {\r\npr_err("wrong CIS (check number of IO windows)\n");\r\nreturn -ENODEV;\r\n}\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int if_cs_probe(struct pcmcia_device *p_dev)\r\n{\r\nint ret = -ENOMEM;\r\nunsigned int prod_id;\r\nstruct lbs_private *priv;\r\nstruct if_cs_card *card;\r\nlbs_deb_enter(LBS_DEB_CS);\r\ncard = kzalloc(sizeof(struct if_cs_card), GFP_KERNEL);\r\nif (!card)\r\ngoto out;\r\ncard->p_dev = p_dev;\r\np_dev->priv = card;\r\np_dev->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nif (pcmcia_loop_config(p_dev, if_cs_ioprobe, NULL)) {\r\npr_err("error in pcmcia_loop_config\n");\r\ngoto out1;\r\n}\r\nif (!p_dev->irq)\r\ngoto out1;\r\ncard->iobase = ioport_map(p_dev->resource[0]->start,\r\nresource_size(p_dev->resource[0]));\r\nif (!card->iobase) {\r\npr_err("error in ioport_map\n");\r\nret = -EIO;\r\ngoto out1;\r\n}\r\nret = pcmcia_enable_device(p_dev);\r\nif (ret) {\r\npr_err("error in pcmcia_enable_device\n");\r\ngoto out2;\r\n}\r\nlbs_deb_cs("irq %d, io %pR", p_dev->irq, p_dev->resource[0]);\r\ncard->align_regs = false;\r\ncard->model = get_model(p_dev->manf_id, p_dev->card_id);\r\nif (card->model == MODEL_UNKNOWN) {\r\npr_err("unsupported manf_id 0x%04x / card_id 0x%04x\n",\r\np_dev->manf_id, p_dev->card_id);\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\nprod_id = if_cs_read8(card, IF_CS_PRODUCT_ID);\r\nif (card->model == MODEL_8305) {\r\ncard->align_regs = true;\r\nif (prod_id < IF_CS_CF8305_B1_REV) {\r\npr_err("8305 rev B0 and older are not supported\n");\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\n}\r\nif ((card->model == MODEL_8381) && prod_id < IF_CS_CF8381_B3_REV) {\r\npr_err("8381 rev B2 and older are not supported\n");\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\nif ((card->model == MODEL_8385) && prod_id < IF_CS_CF8385_B1_REV) {\r\npr_err("8385 rev B0 and older are not supported\n");\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\npriv = lbs_add_card(card, &p_dev->dev);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto out2;\r\n}\r\ncard->priv = priv;\r\npriv->card = card;\r\npriv->hw_host_to_card = if_cs_host_to_card;\r\npriv->enter_deep_sleep = NULL;\r\npriv->exit_deep_sleep = NULL;\r\npriv->reset_deep_sleep_wakeup = NULL;\r\nret = lbs_get_firmware_async(priv, &p_dev->dev, card->model, fw_table,\r\nif_cs_prog_firmware);\r\nif (ret) {\r\npr_err("failed to find firmware (%d)\n", ret);\r\ngoto out3;\r\n}\r\ngoto out;\r\nout3:\r\nlbs_remove_card(priv);\r\nout2:\r\nioport_unmap(card->iobase);\r\nout1:\r\npcmcia_disable_device(p_dev);\r\nout:\r\nlbs_deb_leave_args(LBS_DEB_CS, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic void if_cs_detach(struct pcmcia_device *p_dev)\r\n{\r\nstruct if_cs_card *card = p_dev->priv;\r\nlbs_deb_enter(LBS_DEB_CS);\r\nlbs_stop_card(card->priv);\r\nlbs_remove_card(card->priv);\r\nif_cs_disable_ints(card);\r\nif_cs_release(p_dev);\r\nkfree(card);\r\nlbs_deb_leave(LBS_DEB_CS);\r\n}
