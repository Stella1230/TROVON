static void smsg_app_event_free(struct smsg_app_event *ev)\r\n{\r\nkfree(ev->buf);\r\nkfree(ev);\r\n}\r\nstatic struct smsg_app_event *smsg_app_event_alloc(const char *from,\r\nconst char *msg)\r\n{\r\nstruct smsg_app_event *ev;\r\nev = kzalloc(sizeof(*ev), GFP_ATOMIC);\r\nif (!ev)\r\nreturn NULL;\r\nev->buf = kzalloc(ENV_SENDER_LEN + ENV_PREFIX_LEN +\r\nENV_TEXT_LEN(msg), GFP_ATOMIC);\r\nif (!ev->buf) {\r\nkfree(ev);\r\nreturn NULL;\r\n}\r\nev->envp[0] = ev->buf;\r\nev->envp[1] = ev->envp[0] + ENV_SENDER_LEN;\r\nev->envp[2] = ev->envp[1] + ENV_PREFIX_LEN;\r\nev->envp[3] = NULL;\r\nsnprintf(ev->envp[0], ENV_SENDER_LEN, ENV_SENDER_STR "%s", from);\r\nsnprintf(ev->envp[1], ENV_PREFIX_LEN, ENV_PREFIX_STR "%s", SMSG_PREFIX);\r\nsnprintf(ev->envp[2], ENV_TEXT_LEN(msg), ENV_TEXT_STR "%s", msg);\r\nreturn ev;\r\n}\r\nstatic void smsg_event_work_fn(struct work_struct *work)\r\n{\r\nLIST_HEAD(event_queue);\r\nstruct smsg_app_event *p, *n;\r\nstruct device *dev;\r\ndev = get_device(smsg_app_dev);\r\nif (!dev)\r\nreturn;\r\nspin_lock_bh(&smsg_event_queue_lock);\r\nlist_splice_init(&smsg_event_queue, &event_queue);\r\nspin_unlock_bh(&smsg_event_queue_lock);\r\nlist_for_each_entry_safe(p, n, &event_queue, list) {\r\nlist_del(&p->list);\r\nkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, p->envp);\r\nsmsg_app_event_free(p);\r\n}\r\nput_device(dev);\r\n}\r\nstatic void smsg_app_callback(const char *from, char *msg)\r\n{\r\nstruct smsg_app_event *se;\r\nif (sender && strlen(sender) > 0 && strcmp(from, sender) != 0)\r\nreturn;\r\nmsg += strlen(SMSG_PREFIX);\r\nwhile (*msg && isspace(*msg))\r\nmsg++;\r\nif (*msg == '\0')\r\nreturn;\r\nse = smsg_app_event_alloc(from, msg);\r\nif (!se)\r\nreturn;\r\nspin_lock(&smsg_event_queue_lock);\r\nlist_add_tail(&se->list, &smsg_event_queue);\r\nspin_unlock(&smsg_event_queue_lock);\r\nschedule_work(&smsg_event_work);\r\nreturn;\r\n}\r\nstatic int __init smsgiucv_app_init(void)\r\n{\r\nstruct device_driver *smsgiucv_drv;\r\nint rc;\r\nif (!MACHINE_IS_VM)\r\nreturn -ENODEV;\r\nsmsg_app_dev = kzalloc(sizeof(*smsg_app_dev), GFP_KERNEL);\r\nif (!smsg_app_dev)\r\nreturn -ENOMEM;\r\nsmsgiucv_drv = driver_find(SMSGIUCV_DRV_NAME, &iucv_bus);\r\nif (!smsgiucv_drv) {\r\nkfree(smsg_app_dev);\r\nreturn -ENODEV;\r\n}\r\nrc = dev_set_name(smsg_app_dev, KMSG_COMPONENT);\r\nif (rc) {\r\nkfree(smsg_app_dev);\r\ngoto fail;\r\n}\r\nsmsg_app_dev->bus = &iucv_bus;\r\nsmsg_app_dev->parent = iucv_root;\r\nsmsg_app_dev->release = (void (*)(struct device *)) kfree;\r\nsmsg_app_dev->driver = smsgiucv_drv;\r\nrc = device_register(smsg_app_dev);\r\nif (rc) {\r\nput_device(smsg_app_dev);\r\ngoto fail;\r\n}\r\nif (sender) {\r\nint len = strlen(sender);\r\nwhile (len--)\r\nsender[len] = toupper(sender[len]);\r\n}\r\nrc = smsg_register_callback(SMSG_PREFIX, smsg_app_callback);\r\nif (rc) {\r\ndevice_unregister(smsg_app_dev);\r\ngoto fail;\r\n}\r\nrc = 0;\r\nfail:\r\nreturn rc;\r\n}\r\nstatic void __exit smsgiucv_app_exit(void)\r\n{\r\nsmsg_unregister_callback(SMSG_PREFIX, smsg_app_callback);\r\ncancel_work_sync(&smsg_event_work);\r\nsmsg_event_work_fn(&smsg_event_work);\r\ndevice_unregister(smsg_app_dev);\r\n}
