static void ohci_da8xx_clock(int on)\r\n{\r\nu32 cfgchip2;\r\ncfgchip2 = __raw_readl(CFGCHIP2);\r\nif (on) {\r\nclk_enable(usb11_clk);\r\nif (!(cfgchip2 & CFGCHIP2_USB1PHYCLKMUX)) {\r\nclk_enable(usb20_clk);\r\ncfgchip2 &= ~(CFGCHIP2_RESET | CFGCHIP2_PHYPWRDN);\r\ncfgchip2 |= CFGCHIP2_PHY_PLLON;\r\n__raw_writel(cfgchip2, CFGCHIP2);\r\npr_info("Waiting for USB PHY clock good...\n");\r\nwhile (!(__raw_readl(CFGCHIP2) & CFGCHIP2_PHYCLKGD))\r\ncpu_relax();\r\n}\r\ncfgchip2 |= CFGCHIP2_USB1SUSPENDM;\r\n} else {\r\nclk_disable(usb11_clk);\r\nif (!(cfgchip2 & CFGCHIP2_USB1PHYCLKMUX))\r\nclk_disable(usb20_clk);\r\ncfgchip2 &= ~CFGCHIP2_USB1SUSPENDM;\r\n}\r\n__raw_writel(cfgchip2, CFGCHIP2);\r\n}\r\nstatic void ohci_da8xx_ocic_handler(struct da8xx_ohci_root_hub *hub,\r\nunsigned port)\r\n{\r\nocic_mask |= 1 << port;\r\nif (hub->get_oci(port) > 0)\r\nhub->set_power(port, 0);\r\n}\r\nstatic int ohci_da8xx_init(struct usb_hcd *hcd)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint result;\r\nu32 rh_a;\r\ndev_dbg(dev, "starting USB controller\n");\r\nohci_da8xx_clock(1);\r\nohci->num_ports = 1;\r\nresult = ohci_init(ohci);\r\nif (result < 0)\r\nreturn result;\r\nrh_a = ohci_readl(ohci, &ohci->regs->roothub.a);\r\nif (hub->set_power) {\r\nrh_a &= ~RH_A_NPS;\r\nrh_a |= RH_A_PSM;\r\n}\r\nif (hub->get_oci) {\r\nrh_a &= ~RH_A_NOCP;\r\nrh_a |= RH_A_OCPM;\r\n}\r\nrh_a &= ~RH_A_POTPGT;\r\nrh_a |= hub->potpgt << 24;\r\nohci_writel(ohci, rh_a, &ohci->regs->roothub.a);\r\nreturn result;\r\n}\r\nstatic void ohci_da8xx_stop(struct usb_hcd *hcd)\r\n{\r\nohci_stop(hcd);\r\nohci_da8xx_clock(0);\r\n}\r\nstatic int ohci_da8xx_start(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint result;\r\nresult = ohci_run(ohci);\r\nif (result < 0)\r\nohci_da8xx_stop(hcd);\r\nreturn result;\r\n}\r\nstatic int ohci_da8xx_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nint length = ohci_hub_status_data(hcd, buf);\r\nif (ocic_mask & (1 << 1)) {\r\ndev_dbg(hcd->self.controller, "over-current indicator change "\r\n"on port 1\n");\r\nif (!length)\r\nlength = 1;\r\nbuf[0] |= 1 << 1;\r\n}\r\nreturn length;\r\n}\r\nstatic int ohci_da8xx_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(dev);\r\nint temp;\r\nswitch (typeReq) {\r\ncase GetPortStatus:\r\nif (wIndex != 1)\r\nbreak;\r\ndev_dbg(dev, "GetPortStatus(%u)\n", wIndex);\r\ntemp = roothub_portstatus(hcd_to_ohci(hcd), wIndex - 1);\r\nif (hub->get_power && hub->get_power(wIndex) == 0)\r\ntemp &= ~RH_PS_PPS;\r\nif (hub->get_oci && hub->get_oci(wIndex) > 0)\r\ntemp |= RH_PS_POCI;\r\nif (ocic_mask & (1 << wIndex))\r\ntemp |= RH_PS_OCIC;\r\nput_unaligned(cpu_to_le32(temp), (__le32 *)buf);\r\nreturn 0;\r\ncase SetPortFeature:\r\ntemp = 1;\r\ngoto check_port;\r\ncase ClearPortFeature:\r\ntemp = 0;\r\ncheck_port:\r\nif (wIndex != 1)\r\nbreak;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(dev, "%sPortFeature(%u): %s\n",\r\ntemp ? "Set" : "Clear", wIndex, "POWER");\r\nif (!hub->set_power)\r\nreturn -EPIPE;\r\nreturn hub->set_power(wIndex, temp) ? -EPIPE : 0;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ndev_dbg(dev, "%sPortFeature(%u): %s\n",\r\ntemp ? "Set" : "Clear", wIndex,\r\n"C_OVER_CURRENT");\r\nif (temp)\r\nocic_mask |= 1 << wIndex;\r\nelse\r\nocic_mask &= ~(1 << wIndex);\r\nreturn 0;\r\n}\r\n}\r\nreturn ohci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);\r\n}\r\nstatic int usb_hcd_da8xx_probe(const struct hc_driver *driver,\r\nstruct platform_device *pdev)\r\n{\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(&pdev->dev);\r\nstruct usb_hcd *hcd;\r\nstruct resource *mem;\r\nint error, irq;\r\nif (hub == NULL)\r\nreturn -ENODEV;\r\nusb11_clk = devm_clk_get(&pdev->dev, "usb11");\r\nif (IS_ERR(usb11_clk))\r\nreturn PTR_ERR(usb11_clk);\r\nusb20_clk = devm_clk_get(&pdev->dev, "usb20");\r\nif (IS_ERR(usb20_clk))\r\nreturn PTR_ERR(usb20_clk);\r\nhcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -ENODEV;\r\nhcd->rsrc_start = mem->start;\r\nhcd->rsrc_len = resource_size(mem);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(hcd->regs)) {\r\nerror = PTR_ERR(hcd->regs);\r\ngoto err;\r\n}\r\nohci_hcd_init(hcd_to_ohci(hcd));\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nerror = -ENODEV;\r\ngoto err;\r\n}\r\nerror = usb_add_hcd(hcd, irq, 0);\r\nif (error)\r\ngoto err;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nif (hub->ocic_notify) {\r\nerror = hub->ocic_notify(ohci_da8xx_ocic_handler);\r\nif (!error)\r\nreturn 0;\r\n}\r\nusb_remove_hcd(hcd);\r\nerr:\r\nusb_put_hcd(hcd);\r\nreturn error;\r\n}\r\nstatic inline void\r\nusb_hcd_da8xx_remove(struct usb_hcd *hcd, struct platform_device *pdev)\r\n{\r\nstruct da8xx_ohci_root_hub *hub = dev_get_platdata(&pdev->dev);\r\nhub->ocic_notify(NULL);\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\n}\r\nstatic int ohci_hcd_da8xx_drv_probe(struct platform_device *dev)\r\n{\r\nreturn usb_hcd_da8xx_probe(&ohci_da8xx_hc_driver, dev);\r\n}\r\nstatic int ohci_hcd_da8xx_drv_remove(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nusb_hcd_da8xx_remove(hcd, dev);\r\nreturn 0;\r\n}\r\nstatic int ohci_da8xx_suspend(struct platform_device *pdev,\r\npm_message_t message)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nbool do_wakeup = device_may_wakeup(&pdev->dev);\r\nint ret;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nret = ohci_suspend(hcd, do_wakeup);\r\nif (ret)\r\nreturn ret;\r\nohci_da8xx_clock(0);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nreturn ret;\r\n}\r\nstatic int ohci_da8xx_resume(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nohci_da8xx_clock(1);\r\ndev->dev.power.power_state = PMSG_ON;\r\nusb_hcd_resume_root_hub(hcd);\r\nreturn 0;\r\n}
