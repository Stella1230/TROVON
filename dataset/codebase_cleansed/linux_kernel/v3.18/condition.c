static bool tomoyo_argv(const unsigned int index, const char *arg_ptr,\r\nconst int argc, const struct tomoyo_argv *argv,\r\nu8 *checked)\r\n{\r\nint i;\r\nstruct tomoyo_path_info arg;\r\narg.name = arg_ptr;\r\nfor (i = 0; i < argc; argv++, checked++, i++) {\r\nbool result;\r\nif (index != argv->index)\r\ncontinue;\r\n*checked = 1;\r\ntomoyo_fill_path_info(&arg);\r\nresult = tomoyo_path_matches_pattern(&arg, argv->value);\r\nif (argv->is_not)\r\nresult = !result;\r\nif (!result)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool tomoyo_envp(const char *env_name, const char *env_value,\r\nconst int envc, const struct tomoyo_envp *envp,\r\nu8 *checked)\r\n{\r\nint i;\r\nstruct tomoyo_path_info name;\r\nstruct tomoyo_path_info value;\r\nname.name = env_name;\r\ntomoyo_fill_path_info(&name);\r\nvalue.name = env_value;\r\ntomoyo_fill_path_info(&value);\r\nfor (i = 0; i < envc; envp++, checked++, i++) {\r\nbool result;\r\nif (!tomoyo_path_matches_pattern(&name, envp->name))\r\ncontinue;\r\n*checked = 1;\r\nif (envp->value) {\r\nresult = tomoyo_path_matches_pattern(&value,\r\nenvp->value);\r\nif (envp->is_not)\r\nresult = !result;\r\n} else {\r\nresult = true;\r\nif (!envp->is_not)\r\nresult = !result;\r\n}\r\nif (!result)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool tomoyo_scan_bprm(struct tomoyo_execve *ee,\r\nconst u16 argc, const struct tomoyo_argv *argv,\r\nconst u16 envc, const struct tomoyo_envp *envp)\r\n{\r\nstruct linux_binprm *bprm = ee->bprm;\r\nstruct tomoyo_page_dump *dump = &ee->dump;\r\nchar *arg_ptr = ee->tmp;\r\nint arg_len = 0;\r\nunsigned long pos = bprm->p;\r\nint offset = pos % PAGE_SIZE;\r\nint argv_count = bprm->argc;\r\nint envp_count = bprm->envc;\r\nbool result = true;\r\nu8 local_checked[32];\r\nu8 *checked;\r\nif (argc + envc <= sizeof(local_checked)) {\r\nchecked = local_checked;\r\nmemset(local_checked, 0, sizeof(local_checked));\r\n} else {\r\nchecked = kzalloc(argc + envc, GFP_NOFS);\r\nif (!checked)\r\nreturn false;\r\n}\r\nwhile (argv_count || envp_count) {\r\nif (!tomoyo_dump_page(bprm, pos, dump)) {\r\nresult = false;\r\ngoto out;\r\n}\r\npos += PAGE_SIZE - offset;\r\nwhile (offset < PAGE_SIZE) {\r\nconst char *kaddr = dump->data;\r\nconst unsigned char c = kaddr[offset++];\r\nif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\r\nif (c == '\\') {\r\narg_ptr[arg_len++] = '\\';\r\narg_ptr[arg_len++] = '\\';\r\n} else if (c > ' ' && c < 127) {\r\narg_ptr[arg_len++] = c;\r\n} else {\r\narg_ptr[arg_len++] = '\\';\r\narg_ptr[arg_len++] = (c >> 6) + '0';\r\narg_ptr[arg_len++] =\r\n((c >> 3) & 7) + '0';\r\narg_ptr[arg_len++] = (c & 7) + '0';\r\n}\r\n} else {\r\narg_ptr[arg_len] = '\0';\r\n}\r\nif (c)\r\ncontinue;\r\nif (argv_count) {\r\nif (!tomoyo_argv(bprm->argc - argv_count,\r\narg_ptr, argc, argv,\r\nchecked)) {\r\nresult = false;\r\nbreak;\r\n}\r\nargv_count--;\r\n} else if (envp_count) {\r\nchar *cp = strchr(arg_ptr, '=');\r\nif (cp) {\r\n*cp = '\0';\r\nif (!tomoyo_envp(arg_ptr, cp + 1,\r\nenvc, envp,\r\nchecked + argc)) {\r\nresult = false;\r\nbreak;\r\n}\r\n}\r\nenvp_count--;\r\n} else {\r\nbreak;\r\n}\r\narg_len = 0;\r\n}\r\noffset = 0;\r\nif (!result)\r\nbreak;\r\n}\r\nout:\r\nif (result) {\r\nint i;\r\nfor (i = 0; i < argc; i++) {\r\nif (checked[i])\r\ncontinue;\r\nif (argv[i].is_not)\r\ncontinue;\r\nresult = false;\r\nbreak;\r\n}\r\nfor (i = 0; i < envc; envp++, i++) {\r\nif (checked[argc + i])\r\ncontinue;\r\nif ((!envp->value && !envp->is_not) ||\r\n(envp->value && envp->is_not))\r\ncontinue;\r\nresult = false;\r\nbreak;\r\n}\r\n}\r\nif (checked != local_checked)\r\nkfree(checked);\r\nreturn result;\r\n}\r\nstatic bool tomoyo_scan_exec_realpath(struct file *file,\r\nconst struct tomoyo_name_union *ptr,\r\nconst bool match)\r\n{\r\nbool result;\r\nstruct tomoyo_path_info exe;\r\nif (!file)\r\nreturn false;\r\nexe.name = tomoyo_realpath_from_path(&file->f_path);\r\nif (!exe.name)\r\nreturn false;\r\ntomoyo_fill_path_info(&exe);\r\nresult = tomoyo_compare_name_union(&exe, ptr);\r\nkfree(exe.name);\r\nreturn result == match;\r\n}\r\nstatic const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\r\n{\r\nchar *cp = start + strlen(start) - 1;\r\nif (cp == start || *start++ != '"' || *cp != '"')\r\nreturn NULL;\r\n*cp = '\0';\r\nif (*start && !tomoyo_correct_word(start))\r\nreturn NULL;\r\nreturn tomoyo_get_name(start);\r\n}\r\nstatic bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\r\nstruct tomoyo_name_union *ptr)\r\n{\r\nchar *filename = param->data;\r\nif (*filename == '@')\r\nreturn tomoyo_parse_name_union(param, ptr);\r\nptr->filename = tomoyo_get_dqword(filename);\r\nreturn ptr->filename != NULL;\r\n}\r\nstatic bool tomoyo_parse_argv(char *left, char *right,\r\nstruct tomoyo_argv *argv)\r\n{\r\nif (tomoyo_parse_ulong(&argv->index, &left) !=\r\nTOMOYO_VALUE_TYPE_DECIMAL || *left++ != ']' || *left)\r\nreturn false;\r\nargv->value = tomoyo_get_dqword(right);\r\nreturn argv->value != NULL;\r\n}\r\nstatic bool tomoyo_parse_envp(char *left, char *right,\r\nstruct tomoyo_envp *envp)\r\n{\r\nconst struct tomoyo_path_info *name;\r\nconst struct tomoyo_path_info *value;\r\nchar *cp = left + strlen(left) - 1;\r\nif (*cp-- != ']' || *cp != '"')\r\ngoto out;\r\n*cp = '\0';\r\nif (!tomoyo_correct_word(left))\r\ngoto out;\r\nname = tomoyo_get_name(left);\r\nif (!name)\r\ngoto out;\r\nif (!strcmp(right, "NULL")) {\r\nvalue = NULL;\r\n} else {\r\nvalue = tomoyo_get_dqword(right);\r\nif (!value) {\r\ntomoyo_put_name(name);\r\ngoto out;\r\n}\r\n}\r\nenvp->name = name;\r\nenvp->value = value;\r\nreturn true;\r\nout:\r\nreturn false;\r\n}\r\nstatic inline bool tomoyo_same_condition(const struct tomoyo_condition *a,\r\nconst struct tomoyo_condition *b)\r\n{\r\nreturn a->size == b->size && a->condc == b->condc &&\r\na->numbers_count == b->numbers_count &&\r\na->names_count == b->names_count &&\r\na->argc == b->argc && a->envc == b->envc &&\r\na->grant_log == b->grant_log && a->transit == b->transit &&\r\n!memcmp(a + 1, b + 1, a->size - sizeof(*a));\r\n}\r\nstatic u8 tomoyo_condition_type(const char *word)\r\n{\r\nu8 i;\r\nfor (i = 0; i < TOMOYO_MAX_CONDITION_KEYWORD; i++) {\r\nif (!strcmp(word, tomoyo_condition_keyword[i]))\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic struct tomoyo_condition *tomoyo_commit_condition\r\n(struct tomoyo_condition *entry)\r\n{\r\nstruct tomoyo_condition *ptr;\r\nbool found = false;\r\nif (mutex_lock_interruptible(&tomoyo_policy_lock)) {\r\ndprintk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);\r\nptr = NULL;\r\nfound = true;\r\ngoto out;\r\n}\r\nlist_for_each_entry(ptr, &tomoyo_condition_list, head.list) {\r\nif (!tomoyo_same_condition(ptr, entry) ||\r\natomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\r\ncontinue;\r\natomic_inc(&ptr->head.users);\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found) {\r\nif (tomoyo_memory_ok(entry)) {\r\natomic_set(&entry->head.users, 1);\r\nlist_add(&entry->head.list, &tomoyo_condition_list);\r\n} else {\r\nfound = true;\r\nptr = NULL;\r\n}\r\n}\r\nmutex_unlock(&tomoyo_policy_lock);\r\nout:\r\nif (found) {\r\ntomoyo_del_condition(&entry->head.list);\r\nkfree(entry);\r\nentry = ptr;\r\n}\r\nreturn entry;\r\n}\r\nstatic char *tomoyo_get_transit_preference(struct tomoyo_acl_param *param,\r\nstruct tomoyo_condition *e)\r\n{\r\nchar * const pos = param->data;\r\nbool flag;\r\nif (*pos == '<') {\r\ne->transit = tomoyo_get_domainname(param);\r\ngoto done;\r\n}\r\n{\r\nchar *cp = strchr(pos, ' ');\r\nif (cp)\r\n*cp = '\0';\r\nflag = tomoyo_correct_path(pos) || !strcmp(pos, "keep") ||\r\n!strcmp(pos, "initialize") || !strcmp(pos, "reset") ||\r\n!strcmp(pos, "child") || !strcmp(pos, "parent");\r\nif (cp)\r\n*cp = ' ';\r\n}\r\nif (!flag)\r\nreturn pos;\r\ne->transit = tomoyo_get_name(tomoyo_read_token(param));\r\ndone:\r\nif (e->transit)\r\nreturn param->data;\r\nreturn "/";\r\n}\r\nstruct tomoyo_condition *tomoyo_get_condition(struct tomoyo_acl_param *param)\r\n{\r\nstruct tomoyo_condition *entry = NULL;\r\nstruct tomoyo_condition_element *condp = NULL;\r\nstruct tomoyo_number_union *numbers_p = NULL;\r\nstruct tomoyo_name_union *names_p = NULL;\r\nstruct tomoyo_argv *argv = NULL;\r\nstruct tomoyo_envp *envp = NULL;\r\nstruct tomoyo_condition e = { };\r\nchar * const start_of_string =\r\ntomoyo_get_transit_preference(param, &e);\r\nchar * const end_of_string = start_of_string + strlen(start_of_string);\r\nchar *pos;\r\nrerun:\r\npos = start_of_string;\r\nwhile (1) {\r\nu8 left = -1;\r\nu8 right = -1;\r\nchar *left_word = pos;\r\nchar *cp;\r\nchar *right_word;\r\nbool is_not;\r\nif (!*left_word)\r\nbreak;\r\ncp = strchr(pos, ' ');\r\nif (cp) {\r\n*cp = '\0';\r\npos = cp + 1;\r\n} else {\r\npos = "";\r\n}\r\nright_word = strchr(left_word, '=');\r\nif (!right_word || right_word == left_word)\r\ngoto out;\r\nis_not = *(right_word - 1) == '!';\r\nif (is_not)\r\n*(right_word++ - 1) = '\0';\r\nelse if (*(right_word + 1) != '=')\r\n*right_word++ = '\0';\r\nelse\r\ngoto out;\r\ndprintk(KERN_WARNING "%u: <%s>%s=<%s>\n", __LINE__, left_word,\r\nis_not ? "!" : "", right_word);\r\nif (!strcmp(left_word, "grant_log")) {\r\nif (entry) {\r\nif (is_not ||\r\nentry->grant_log != TOMOYO_GRANTLOG_AUTO)\r\ngoto out;\r\nelse if (!strcmp(right_word, "yes"))\r\nentry->grant_log = TOMOYO_GRANTLOG_YES;\r\nelse if (!strcmp(right_word, "no"))\r\nentry->grant_log = TOMOYO_GRANTLOG_NO;\r\nelse\r\ngoto out;\r\n}\r\ncontinue;\r\n}\r\nif (!strncmp(left_word, "exec.argv[", 10)) {\r\nif (!argv) {\r\ne.argc++;\r\ne.condc++;\r\n} else {\r\ne.argc--;\r\ne.condc--;\r\nleft = TOMOYO_ARGV_ENTRY;\r\nargv->is_not = is_not;\r\nif (!tomoyo_parse_argv(left_word + 10,\r\nright_word, argv++))\r\ngoto out;\r\n}\r\ngoto store_value;\r\n}\r\nif (!strncmp(left_word, "exec.envp[\"", 11)) {\r\nif (!envp) {\r\ne.envc++;\r\ne.condc++;\r\n} else {\r\ne.envc--;\r\ne.condc--;\r\nleft = TOMOYO_ENVP_ENTRY;\r\nenvp->is_not = is_not;\r\nif (!tomoyo_parse_envp(left_word + 11,\r\nright_word, envp++))\r\ngoto out;\r\n}\r\ngoto store_value;\r\n}\r\nleft = tomoyo_condition_type(left_word);\r\ndprintk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__, left_word,\r\nleft);\r\nif (left == TOMOYO_MAX_CONDITION_KEYWORD) {\r\nif (!numbers_p) {\r\ne.numbers_count++;\r\n} else {\r\ne.numbers_count--;\r\nleft = TOMOYO_NUMBER_UNION;\r\nparam->data = left_word;\r\nif (*left_word == '@' ||\r\n!tomoyo_parse_number_union(param,\r\nnumbers_p++))\r\ngoto out;\r\n}\r\n}\r\nif (!condp)\r\ne.condc++;\r\nelse\r\ne.condc--;\r\nif (left == TOMOYO_EXEC_REALPATH ||\r\nleft == TOMOYO_SYMLINK_TARGET) {\r\nif (!names_p) {\r\ne.names_count++;\r\n} else {\r\ne.names_count--;\r\nright = TOMOYO_NAME_UNION;\r\nparam->data = right_word;\r\nif (!tomoyo_parse_name_union_quoted(param,\r\nnames_p++))\r\ngoto out;\r\n}\r\ngoto store_value;\r\n}\r\nright = tomoyo_condition_type(right_word);\r\nif (right == TOMOYO_MAX_CONDITION_KEYWORD) {\r\nif (!numbers_p) {\r\ne.numbers_count++;\r\n} else {\r\ne.numbers_count--;\r\nright = TOMOYO_NUMBER_UNION;\r\nparam->data = right_word;\r\nif (!tomoyo_parse_number_union(param,\r\nnumbers_p++))\r\ngoto out;\r\n}\r\n}\r\nstore_value:\r\nif (!condp) {\r\ndprintk(KERN_WARNING "%u: dry_run left=%u right=%u "\r\n"match=%u\n", __LINE__, left, right, !is_not);\r\ncontinue;\r\n}\r\ncondp->left = left;\r\ncondp->right = right;\r\ncondp->equals = !is_not;\r\ndprintk(KERN_WARNING "%u: left=%u right=%u match=%u\n",\r\n__LINE__, condp->left, condp->right,\r\ncondp->equals);\r\ncondp++;\r\n}\r\ndprintk(KERN_INFO "%u: cond=%u numbers=%u names=%u ac=%u ec=%u\n",\r\n__LINE__, e.condc, e.numbers_count, e.names_count, e.argc,\r\ne.envc);\r\nif (entry) {\r\nBUG_ON(e.names_count | e.numbers_count | e.argc | e.envc |\r\ne.condc);\r\nreturn tomoyo_commit_condition(entry);\r\n}\r\ne.size = sizeof(*entry)\r\n+ e.condc * sizeof(struct tomoyo_condition_element)\r\n+ e.numbers_count * sizeof(struct tomoyo_number_union)\r\n+ e.names_count * sizeof(struct tomoyo_name_union)\r\n+ e.argc * sizeof(struct tomoyo_argv)\r\n+ e.envc * sizeof(struct tomoyo_envp);\r\nentry = kzalloc(e.size, GFP_NOFS);\r\nif (!entry)\r\ngoto out2;\r\n*entry = e;\r\ne.transit = NULL;\r\ncondp = (struct tomoyo_condition_element *) (entry + 1);\r\nnumbers_p = (struct tomoyo_number_union *) (condp + e.condc);\r\nnames_p = (struct tomoyo_name_union *) (numbers_p + e.numbers_count);\r\nargv = (struct tomoyo_argv *) (names_p + e.names_count);\r\nenvp = (struct tomoyo_envp *) (argv + e.argc);\r\n{\r\nbool flag = false;\r\nfor (pos = start_of_string; pos < end_of_string; pos++) {\r\nif (*pos)\r\ncontinue;\r\nif (flag)\r\n*pos = ' ';\r\nelse if (*(pos + 1) == '=')\r\n*pos = '!';\r\nelse\r\n*pos = '=';\r\nflag = !flag;\r\n}\r\n}\r\ngoto rerun;\r\nout:\r\ndprintk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);\r\nif (entry) {\r\ntomoyo_del_condition(&entry->head.list);\r\nkfree(entry);\r\n}\r\nout2:\r\ntomoyo_put_name(e.transit);\r\nreturn NULL;\r\n}\r\nvoid tomoyo_get_attributes(struct tomoyo_obj_info *obj)\r\n{\r\nu8 i;\r\nstruct dentry *dentry = NULL;\r\nfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\r\nstruct inode *inode;\r\nswitch (i) {\r\ncase TOMOYO_PATH1:\r\ndentry = obj->path1.dentry;\r\nif (!dentry)\r\ncontinue;\r\nbreak;\r\ncase TOMOYO_PATH2:\r\ndentry = obj->path2.dentry;\r\nif (!dentry)\r\ncontinue;\r\nbreak;\r\ndefault:\r\nif (!dentry)\r\ncontinue;\r\ndentry = dget_parent(dentry);\r\nbreak;\r\n}\r\ninode = dentry->d_inode;\r\nif (inode) {\r\nstruct tomoyo_mini_stat *stat = &obj->stat[i];\r\nstat->uid = inode->i_uid;\r\nstat->gid = inode->i_gid;\r\nstat->ino = inode->i_ino;\r\nstat->mode = inode->i_mode;\r\nstat->dev = inode->i_sb->s_dev;\r\nstat->rdev = inode->i_rdev;\r\nobj->stat_valid[i] = true;\r\n}\r\nif (i & 1)\r\ndput(dentry);\r\n}\r\n}\r\nbool tomoyo_condition(struct tomoyo_request_info *r,\r\nconst struct tomoyo_condition *cond)\r\n{\r\nu32 i;\r\nunsigned long min_v[2] = { 0, 0 };\r\nunsigned long max_v[2] = { 0, 0 };\r\nconst struct tomoyo_condition_element *condp;\r\nconst struct tomoyo_number_union *numbers_p;\r\nconst struct tomoyo_name_union *names_p;\r\nconst struct tomoyo_argv *argv;\r\nconst struct tomoyo_envp *envp;\r\nstruct tomoyo_obj_info *obj;\r\nu16 condc;\r\nu16 argc;\r\nu16 envc;\r\nstruct linux_binprm *bprm = NULL;\r\nif (!cond)\r\nreturn true;\r\ncondc = cond->condc;\r\nargc = cond->argc;\r\nenvc = cond->envc;\r\nobj = r->obj;\r\nif (r->ee)\r\nbprm = r->ee->bprm;\r\nif (!bprm && (argc || envc))\r\nreturn false;\r\ncondp = (struct tomoyo_condition_element *) (cond + 1);\r\nnumbers_p = (const struct tomoyo_number_union *) (condp + condc);\r\nnames_p = (const struct tomoyo_name_union *)\r\n(numbers_p + cond->numbers_count);\r\nargv = (const struct tomoyo_argv *) (names_p + cond->names_count);\r\nenvp = (const struct tomoyo_envp *) (argv + argc);\r\nfor (i = 0; i < condc; i++) {\r\nconst bool match = condp->equals;\r\nconst u8 left = condp->left;\r\nconst u8 right = condp->right;\r\nbool is_bitop[2] = { false, false };\r\nu8 j;\r\ncondp++;\r\nif (left == TOMOYO_ARGV_ENTRY || left == TOMOYO_ENVP_ENTRY)\r\ncontinue;\r\nif (right == TOMOYO_NAME_UNION) {\r\nconst struct tomoyo_name_union *ptr = names_p++;\r\nswitch (left) {\r\nstruct tomoyo_path_info *symlink;\r\nstruct tomoyo_execve *ee;\r\nstruct file *file;\r\ncase TOMOYO_SYMLINK_TARGET:\r\nsymlink = obj ? obj->symlink_target : NULL;\r\nif (!symlink ||\r\n!tomoyo_compare_name_union(symlink, ptr)\r\n== match)\r\ngoto out;\r\nbreak;\r\ncase TOMOYO_EXEC_REALPATH:\r\nee = r->ee;\r\nfile = ee ? ee->bprm->file : NULL;\r\nif (!tomoyo_scan_exec_realpath(file, ptr,\r\nmatch))\r\ngoto out;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nfor (j = 0; j < 2; j++) {\r\nconst u8 index = j ? right : left;\r\nunsigned long value = 0;\r\nswitch (index) {\r\ncase TOMOYO_TASK_UID:\r\nvalue = from_kuid(&init_user_ns, current_uid());\r\nbreak;\r\ncase TOMOYO_TASK_EUID:\r\nvalue = from_kuid(&init_user_ns, current_euid());\r\nbreak;\r\ncase TOMOYO_TASK_SUID:\r\nvalue = from_kuid(&init_user_ns, current_suid());\r\nbreak;\r\ncase TOMOYO_TASK_FSUID:\r\nvalue = from_kuid(&init_user_ns, current_fsuid());\r\nbreak;\r\ncase TOMOYO_TASK_GID:\r\nvalue = from_kgid(&init_user_ns, current_gid());\r\nbreak;\r\ncase TOMOYO_TASK_EGID:\r\nvalue = from_kgid(&init_user_ns, current_egid());\r\nbreak;\r\ncase TOMOYO_TASK_SGID:\r\nvalue = from_kgid(&init_user_ns, current_sgid());\r\nbreak;\r\ncase TOMOYO_TASK_FSGID:\r\nvalue = from_kgid(&init_user_ns, current_fsgid());\r\nbreak;\r\ncase TOMOYO_TASK_PID:\r\nvalue = tomoyo_sys_getpid();\r\nbreak;\r\ncase TOMOYO_TASK_PPID:\r\nvalue = tomoyo_sys_getppid();\r\nbreak;\r\ncase TOMOYO_TYPE_IS_SOCKET:\r\nvalue = S_IFSOCK;\r\nbreak;\r\ncase TOMOYO_TYPE_IS_SYMLINK:\r\nvalue = S_IFLNK;\r\nbreak;\r\ncase TOMOYO_TYPE_IS_FILE:\r\nvalue = S_IFREG;\r\nbreak;\r\ncase TOMOYO_TYPE_IS_BLOCK_DEV:\r\nvalue = S_IFBLK;\r\nbreak;\r\ncase TOMOYO_TYPE_IS_DIRECTORY:\r\nvalue = S_IFDIR;\r\nbreak;\r\ncase TOMOYO_TYPE_IS_CHAR_DEV:\r\nvalue = S_IFCHR;\r\nbreak;\r\ncase TOMOYO_TYPE_IS_FIFO:\r\nvalue = S_IFIFO;\r\nbreak;\r\ncase TOMOYO_MODE_SETUID:\r\nvalue = S_ISUID;\r\nbreak;\r\ncase TOMOYO_MODE_SETGID:\r\nvalue = S_ISGID;\r\nbreak;\r\ncase TOMOYO_MODE_STICKY:\r\nvalue = S_ISVTX;\r\nbreak;\r\ncase TOMOYO_MODE_OWNER_READ:\r\nvalue = S_IRUSR;\r\nbreak;\r\ncase TOMOYO_MODE_OWNER_WRITE:\r\nvalue = S_IWUSR;\r\nbreak;\r\ncase TOMOYO_MODE_OWNER_EXECUTE:\r\nvalue = S_IXUSR;\r\nbreak;\r\ncase TOMOYO_MODE_GROUP_READ:\r\nvalue = S_IRGRP;\r\nbreak;\r\ncase TOMOYO_MODE_GROUP_WRITE:\r\nvalue = S_IWGRP;\r\nbreak;\r\ncase TOMOYO_MODE_GROUP_EXECUTE:\r\nvalue = S_IXGRP;\r\nbreak;\r\ncase TOMOYO_MODE_OTHERS_READ:\r\nvalue = S_IROTH;\r\nbreak;\r\ncase TOMOYO_MODE_OTHERS_WRITE:\r\nvalue = S_IWOTH;\r\nbreak;\r\ncase TOMOYO_MODE_OTHERS_EXECUTE:\r\nvalue = S_IXOTH;\r\nbreak;\r\ncase TOMOYO_EXEC_ARGC:\r\nif (!bprm)\r\ngoto out;\r\nvalue = bprm->argc;\r\nbreak;\r\ncase TOMOYO_EXEC_ENVC:\r\nif (!bprm)\r\ngoto out;\r\nvalue = bprm->envc;\r\nbreak;\r\ncase TOMOYO_NUMBER_UNION:\r\nbreak;\r\ndefault:\r\nif (!obj)\r\ngoto out;\r\nif (!obj->validate_done) {\r\ntomoyo_get_attributes(obj);\r\nobj->validate_done = true;\r\n}\r\n{\r\nu8 stat_index;\r\nstruct tomoyo_mini_stat *stat;\r\nswitch (index) {\r\ncase TOMOYO_PATH1_UID:\r\ncase TOMOYO_PATH1_GID:\r\ncase TOMOYO_PATH1_INO:\r\ncase TOMOYO_PATH1_MAJOR:\r\ncase TOMOYO_PATH1_MINOR:\r\ncase TOMOYO_PATH1_TYPE:\r\ncase TOMOYO_PATH1_DEV_MAJOR:\r\ncase TOMOYO_PATH1_DEV_MINOR:\r\ncase TOMOYO_PATH1_PERM:\r\nstat_index = TOMOYO_PATH1;\r\nbreak;\r\ncase TOMOYO_PATH2_UID:\r\ncase TOMOYO_PATH2_GID:\r\ncase TOMOYO_PATH2_INO:\r\ncase TOMOYO_PATH2_MAJOR:\r\ncase TOMOYO_PATH2_MINOR:\r\ncase TOMOYO_PATH2_TYPE:\r\ncase TOMOYO_PATH2_DEV_MAJOR:\r\ncase TOMOYO_PATH2_DEV_MINOR:\r\ncase TOMOYO_PATH2_PERM:\r\nstat_index = TOMOYO_PATH2;\r\nbreak;\r\ncase TOMOYO_PATH1_PARENT_UID:\r\ncase TOMOYO_PATH1_PARENT_GID:\r\ncase TOMOYO_PATH1_PARENT_INO:\r\ncase TOMOYO_PATH1_PARENT_PERM:\r\nstat_index =\r\nTOMOYO_PATH1_PARENT;\r\nbreak;\r\ncase TOMOYO_PATH2_PARENT_UID:\r\ncase TOMOYO_PATH2_PARENT_GID:\r\ncase TOMOYO_PATH2_PARENT_INO:\r\ncase TOMOYO_PATH2_PARENT_PERM:\r\nstat_index =\r\nTOMOYO_PATH2_PARENT;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nif (!obj->stat_valid[stat_index])\r\ngoto out;\r\nstat = &obj->stat[stat_index];\r\nswitch (index) {\r\ncase TOMOYO_PATH1_UID:\r\ncase TOMOYO_PATH2_UID:\r\ncase TOMOYO_PATH1_PARENT_UID:\r\ncase TOMOYO_PATH2_PARENT_UID:\r\nvalue = from_kuid(&init_user_ns, stat->uid);\r\nbreak;\r\ncase TOMOYO_PATH1_GID:\r\ncase TOMOYO_PATH2_GID:\r\ncase TOMOYO_PATH1_PARENT_GID:\r\ncase TOMOYO_PATH2_PARENT_GID:\r\nvalue = from_kgid(&init_user_ns, stat->gid);\r\nbreak;\r\ncase TOMOYO_PATH1_INO:\r\ncase TOMOYO_PATH2_INO:\r\ncase TOMOYO_PATH1_PARENT_INO:\r\ncase TOMOYO_PATH2_PARENT_INO:\r\nvalue = stat->ino;\r\nbreak;\r\ncase TOMOYO_PATH1_MAJOR:\r\ncase TOMOYO_PATH2_MAJOR:\r\nvalue = MAJOR(stat->dev);\r\nbreak;\r\ncase TOMOYO_PATH1_MINOR:\r\ncase TOMOYO_PATH2_MINOR:\r\nvalue = MINOR(stat->dev);\r\nbreak;\r\ncase TOMOYO_PATH1_TYPE:\r\ncase TOMOYO_PATH2_TYPE:\r\nvalue = stat->mode & S_IFMT;\r\nbreak;\r\ncase TOMOYO_PATH1_DEV_MAJOR:\r\ncase TOMOYO_PATH2_DEV_MAJOR:\r\nvalue = MAJOR(stat->rdev);\r\nbreak;\r\ncase TOMOYO_PATH1_DEV_MINOR:\r\ncase TOMOYO_PATH2_DEV_MINOR:\r\nvalue = MINOR(stat->rdev);\r\nbreak;\r\ncase TOMOYO_PATH1_PERM:\r\ncase TOMOYO_PATH2_PERM:\r\ncase TOMOYO_PATH1_PARENT_PERM:\r\ncase TOMOYO_PATH2_PARENT_PERM:\r\nvalue = stat->mode & S_IALLUGO;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nmax_v[j] = value;\r\nmin_v[j] = value;\r\nswitch (index) {\r\ncase TOMOYO_MODE_SETUID:\r\ncase TOMOYO_MODE_SETGID:\r\ncase TOMOYO_MODE_STICKY:\r\ncase TOMOYO_MODE_OWNER_READ:\r\ncase TOMOYO_MODE_OWNER_WRITE:\r\ncase TOMOYO_MODE_OWNER_EXECUTE:\r\ncase TOMOYO_MODE_GROUP_READ:\r\ncase TOMOYO_MODE_GROUP_WRITE:\r\ncase TOMOYO_MODE_GROUP_EXECUTE:\r\ncase TOMOYO_MODE_OTHERS_READ:\r\ncase TOMOYO_MODE_OTHERS_WRITE:\r\ncase TOMOYO_MODE_OTHERS_EXECUTE:\r\nis_bitop[j] = true;\r\n}\r\n}\r\nif (left == TOMOYO_NUMBER_UNION) {\r\nconst struct tomoyo_number_union *ptr = numbers_p++;\r\nmin_v[0] = ptr->values[0];\r\nmax_v[0] = ptr->values[1];\r\n}\r\nif (right == TOMOYO_NUMBER_UNION) {\r\nconst struct tomoyo_number_union *ptr = numbers_p++;\r\nif (ptr->group) {\r\nif (tomoyo_number_matches_group(min_v[0],\r\nmax_v[0],\r\nptr->group)\r\n== match)\r\ncontinue;\r\n} else {\r\nif ((min_v[0] <= ptr->values[1] &&\r\nmax_v[0] >= ptr->values[0]) == match)\r\ncontinue;\r\n}\r\ngoto out;\r\n}\r\nif (is_bitop[0] && is_bitop[1]) {\r\ngoto out;\r\n} else if (is_bitop[0]) {\r\nswitch (right) {\r\ncase TOMOYO_PATH1_PERM:\r\ncase TOMOYO_PATH1_PARENT_PERM:\r\ncase TOMOYO_PATH2_PERM:\r\ncase TOMOYO_PATH2_PARENT_PERM:\r\nif (!(max_v[0] & max_v[1]) == !match)\r\ncontinue;\r\n}\r\ngoto out;\r\n} else if (is_bitop[1]) {\r\nswitch (left) {\r\ncase TOMOYO_PATH1_PERM:\r\ncase TOMOYO_PATH1_PARENT_PERM:\r\ncase TOMOYO_PATH2_PERM:\r\ncase TOMOYO_PATH2_PARENT_PERM:\r\nif (!(max_v[0] & max_v[1]) == !match)\r\ncontinue;\r\n}\r\ngoto out;\r\n}\r\nif ((min_v[0] <= max_v[1] && max_v[0] >= min_v[1]) == match)\r\ncontinue;\r\nout:\r\nreturn false;\r\n}\r\nif (r->ee && (argc || envc))\r\nreturn tomoyo_scan_bprm(r->ee, argc, argv, envc, envp);\r\nreturn true;\r\n}
