static long cp_oldabi_stat64(struct kstat *stat,\r\nstruct oldabi_stat64 __user *statbuf)\r\n{\r\nstruct oldabi_stat64 tmp;\r\ntmp.st_dev = huge_encode_dev(stat->dev);\r\ntmp.__pad1 = 0;\r\ntmp.__st_ino = stat->ino;\r\ntmp.st_mode = stat->mode;\r\ntmp.st_nlink = stat->nlink;\r\ntmp.st_uid = from_kuid_munged(current_user_ns(), stat->uid);\r\ntmp.st_gid = from_kgid_munged(current_user_ns(), stat->gid);\r\ntmp.st_rdev = huge_encode_dev(stat->rdev);\r\ntmp.st_size = stat->size;\r\ntmp.st_blocks = stat->blocks;\r\ntmp.__pad2 = 0;\r\ntmp.st_blksize = stat->blksize;\r\ntmp.st_atime = stat->atime.tv_sec;\r\ntmp.st_atime_nsec = stat->atime.tv_nsec;\r\ntmp.st_mtime = stat->mtime.tv_sec;\r\ntmp.st_mtime_nsec = stat->mtime.tv_nsec;\r\ntmp.st_ctime = stat->ctime.tv_sec;\r\ntmp.st_ctime_nsec = stat->ctime.tv_nsec;\r\ntmp.st_ino = stat->ino;\r\nreturn copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;\r\n}\r\nasmlinkage long sys_oabi_stat64(const char __user * filename,\r\nstruct oldabi_stat64 __user * statbuf)\r\n{\r\nstruct kstat stat;\r\nint error = vfs_stat(filename, &stat);\r\nif (!error)\r\nerror = cp_oldabi_stat64(&stat, statbuf);\r\nreturn error;\r\n}\r\nasmlinkage long sys_oabi_lstat64(const char __user * filename,\r\nstruct oldabi_stat64 __user * statbuf)\r\n{\r\nstruct kstat stat;\r\nint error = vfs_lstat(filename, &stat);\r\nif (!error)\r\nerror = cp_oldabi_stat64(&stat, statbuf);\r\nreturn error;\r\n}\r\nasmlinkage long sys_oabi_fstat64(unsigned long fd,\r\nstruct oldabi_stat64 __user * statbuf)\r\n{\r\nstruct kstat stat;\r\nint error = vfs_fstat(fd, &stat);\r\nif (!error)\r\nerror = cp_oldabi_stat64(&stat, statbuf);\r\nreturn error;\r\n}\r\nasmlinkage long sys_oabi_fstatat64(int dfd,\r\nconst char __user *filename,\r\nstruct oldabi_stat64 __user *statbuf,\r\nint flag)\r\n{\r\nstruct kstat stat;\r\nint error;\r\nerror = vfs_fstatat(dfd, filename, &stat, flag);\r\nif (error)\r\nreturn error;\r\nreturn cp_oldabi_stat64(&stat, statbuf);\r\n}\r\nasmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct oabi_flock64 user;\r\nstruct flock64 kernel;\r\nmm_segment_t fs = USER_DS;\r\nunsigned long local_arg = arg;\r\nint ret;\r\nswitch (cmd) {\r\ncase F_OFD_GETLK:\r\ncase F_OFD_SETLK:\r\ncase F_OFD_SETLKW:\r\ncase F_GETLK64:\r\ncase F_SETLK64:\r\ncase F_SETLKW64:\r\nif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\r\nsizeof(user)))\r\nreturn -EFAULT;\r\nkernel.l_type = user.l_type;\r\nkernel.l_whence = user.l_whence;\r\nkernel.l_start = user.l_start;\r\nkernel.l_len = user.l_len;\r\nkernel.l_pid = user.l_pid;\r\nlocal_arg = (unsigned long)&kernel;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\n}\r\nret = sys_fcntl64(fd, cmd, local_arg);\r\nswitch (cmd) {\r\ncase F_GETLK64:\r\nif (!ret) {\r\nuser.l_type = kernel.l_type;\r\nuser.l_whence = kernel.l_whence;\r\nuser.l_start = kernel.l_start;\r\nuser.l_len = kernel.l_len;\r\nuser.l_pid = kernel.l_pid;\r\nif (copy_to_user((struct oabi_flock64 __user *)arg,\r\n&user, sizeof(user)))\r\nret = -EFAULT;\r\n}\r\ncase F_SETLK64:\r\ncase F_SETLKW64:\r\nset_fs(fs);\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long sys_oabi_epoll_ctl(int epfd, int op, int fd,\r\nstruct oabi_epoll_event __user *event)\r\n{\r\nstruct oabi_epoll_event user;\r\nstruct epoll_event kernel;\r\nmm_segment_t fs;\r\nlong ret;\r\nif (op == EPOLL_CTL_DEL)\r\nreturn sys_epoll_ctl(epfd, op, fd, NULL);\r\nif (copy_from_user(&user, event, sizeof(user)))\r\nreturn -EFAULT;\r\nkernel.events = user.events;\r\nkernel.data = user.data;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = sys_epoll_ctl(epfd, op, fd, &kernel);\r\nset_fs(fs);\r\nreturn ret;\r\n}\r\nasmlinkage long sys_oabi_epoll_wait(int epfd,\r\nstruct oabi_epoll_event __user *events,\r\nint maxevents, int timeout)\r\n{\r\nstruct epoll_event *kbuf;\r\nmm_segment_t fs;\r\nlong ret, err, i;\r\nif (maxevents <= 0 || maxevents > (INT_MAX/sizeof(struct epoll_event)))\r\nreturn -EINVAL;\r\nkbuf = kmalloc(sizeof(*kbuf) * maxevents, GFP_KERNEL);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = sys_epoll_wait(epfd, kbuf, maxevents, timeout);\r\nset_fs(fs);\r\nerr = 0;\r\nfor (i = 0; i < ret; i++) {\r\n__put_user_error(kbuf[i].events, &events->events, err);\r\n__put_user_error(kbuf[i].data, &events->data, err);\r\nevents++;\r\n}\r\nkfree(kbuf);\r\nreturn err ? -EFAULT : ret;\r\n}\r\nasmlinkage long sys_oabi_semtimedop(int semid,\r\nstruct oabi_sembuf __user *tsops,\r\nunsigned nsops,\r\nconst struct timespec __user *timeout)\r\n{\r\nstruct sembuf *sops;\r\nstruct timespec local_timeout;\r\nlong err;\r\nint i;\r\nif (nsops < 1 || nsops > SEMOPM)\r\nreturn -EINVAL;\r\nsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\r\nif (!sops)\r\nreturn -ENOMEM;\r\nerr = 0;\r\nfor (i = 0; i < nsops; i++) {\r\n__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\r\n__get_user_error(sops[i].sem_op, &tsops->sem_op, err);\r\n__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\r\ntsops++;\r\n}\r\nif (timeout) {\r\nerr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\r\ntimeout = &local_timeout;\r\n}\r\nif (err) {\r\nerr = -EFAULT;\r\n} else {\r\nmm_segment_t fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = sys_semtimedop(semid, sops, nsops, timeout);\r\nset_fs(fs);\r\n}\r\nkfree(sops);\r\nreturn err;\r\n}\r\nasmlinkage long sys_oabi_semop(int semid, struct oabi_sembuf __user *tsops,\r\nunsigned nsops)\r\n{\r\nreturn sys_oabi_semtimedop(semid, tsops, nsops, NULL);\r\n}\r\nasmlinkage int sys_oabi_ipc(uint call, int first, int second, int third,\r\nvoid __user *ptr, long fifth)\r\n{\r\nswitch (call & 0xffff) {\r\ncase SEMOP:\r\nreturn sys_oabi_semtimedop(first,\r\n(struct oabi_sembuf __user *)ptr,\r\nsecond, NULL);\r\ncase SEMTIMEDOP:\r\nreturn sys_oabi_semtimedop(first,\r\n(struct oabi_sembuf __user *)ptr,\r\nsecond,\r\n(const struct timespec __user *)fifth);\r\ndefault:\r\nreturn sys_ipc(call, first, second, third, ptr, fifth);\r\n}\r\n}\r\nasmlinkage long sys_oabi_bind(int fd, struct sockaddr __user *addr, int addrlen)\r\n{\r\nsa_family_t sa_family;\r\nif (addrlen == 112 &&\r\nget_user(sa_family, &addr->sa_family) == 0 &&\r\nsa_family == AF_UNIX)\r\naddrlen = 110;\r\nreturn sys_bind(fd, addr, addrlen);\r\n}\r\nasmlinkage long sys_oabi_connect(int fd, struct sockaddr __user *addr, int addrlen)\r\n{\r\nsa_family_t sa_family;\r\nif (addrlen == 112 &&\r\nget_user(sa_family, &addr->sa_family) == 0 &&\r\nsa_family == AF_UNIX)\r\naddrlen = 110;\r\nreturn sys_connect(fd, addr, addrlen);\r\n}\r\nasmlinkage long sys_oabi_sendto(int fd, void __user *buff,\r\nsize_t len, unsigned flags,\r\nstruct sockaddr __user *addr,\r\nint addrlen)\r\n{\r\nsa_family_t sa_family;\r\nif (addrlen == 112 &&\r\nget_user(sa_family, &addr->sa_family) == 0 &&\r\nsa_family == AF_UNIX)\r\naddrlen = 110;\r\nreturn sys_sendto(fd, buff, len, flags, addr, addrlen);\r\n}\r\nasmlinkage long sys_oabi_sendmsg(int fd, struct msghdr __user *msg, unsigned flags)\r\n{\r\nstruct sockaddr __user *addr;\r\nint msg_namelen;\r\nsa_family_t sa_family;\r\nif (msg &&\r\nget_user(msg_namelen, &msg->msg_namelen) == 0 &&\r\nmsg_namelen == 112 &&\r\nget_user(addr, &msg->msg_name) == 0 &&\r\nget_user(sa_family, &addr->sa_family) == 0 &&\r\nsa_family == AF_UNIX)\r\n{\r\nput_user(110, &msg->msg_namelen);\r\n}\r\nreturn sys_sendmsg(fd, msg, flags);\r\n}\r\nasmlinkage long sys_oabi_socketcall(int call, unsigned long __user *args)\r\n{\r\nunsigned long r = -EFAULT, a[6];\r\nswitch (call) {\r\ncase SYS_BIND:\r\nif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\r\nr = sys_oabi_bind(a[0], (struct sockaddr __user *)a[1], a[2]);\r\nbreak;\r\ncase SYS_CONNECT:\r\nif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\r\nr = sys_oabi_connect(a[0], (struct sockaddr __user *)a[1], a[2]);\r\nbreak;\r\ncase SYS_SENDTO:\r\nif (copy_from_user(a, args, 6 * sizeof(long)) == 0)\r\nr = sys_oabi_sendto(a[0], (void __user *)a[1], a[2], a[3],\r\n(struct sockaddr __user *)a[4], a[5]);\r\nbreak;\r\ncase SYS_SENDMSG:\r\nif (copy_from_user(a, args, 3 * sizeof(long)) == 0)\r\nr = sys_oabi_sendmsg(a[0], (struct msghdr __user *)a[1], a[2]);\r\nbreak;\r\ndefault:\r\nr = sys_socketcall(call, args);\r\n}\r\nreturn r;\r\n}
