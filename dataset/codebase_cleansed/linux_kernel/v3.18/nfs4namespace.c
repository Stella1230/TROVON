static inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\r\nchar *buffer, ssize_t buflen)\r\n{\r\nchar *end = buffer + buflen;\r\nint n;\r\n*--end = '\0';\r\nbuflen--;\r\nn = pathname->ncomponents;\r\nwhile (--n >= 0) {\r\nconst struct nfs4_string *component = &pathname->components[n];\r\nbuflen -= component->len + 1;\r\nif (buflen < 0)\r\ngoto Elong;\r\nend -= component->len;\r\nmemcpy(end, component->data, component->len);\r\n*--end = '/';\r\n}\r\nreturn end;\r\nElong:\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\n}\r\nstatic char *nfs_path_component(const char *nfspath, const char *end)\r\n{\r\nchar *p;\r\nif (*nfspath == '[') {\r\np = strchr(nfspath, ']');\r\nif (p != NULL && ++p < end && *p == ':')\r\nreturn p + 1;\r\n} else {\r\np = strchr(nfspath, ':');\r\nif (p != NULL && p < end)\r\nreturn p + 1;\r\n}\r\nreturn NULL;\r\n}\r\nstatic char *nfs4_path(struct dentry *dentry, char *buffer, ssize_t buflen)\r\n{\r\nchar *limit;\r\nchar *path = nfs_path(&limit, dentry, buffer, buflen,\r\nNFS_PATH_CANONICAL);\r\nif (!IS_ERR(path)) {\r\nchar *path_component = nfs_path_component(path, limit);\r\nif (path_component)\r\nreturn path_component;\r\n}\r\nreturn path;\r\n}\r\nstatic int nfs4_validate_fspath(struct dentry *dentry,\r\nconst struct nfs4_fs_locations *locations,\r\nchar *page, char *page2)\r\n{\r\nconst char *path, *fs_path;\r\npath = nfs4_path(dentry, page, PAGE_SIZE);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nfs_path = nfs4_pathname_string(&locations->fs_path, page2, PAGE_SIZE);\r\nif (IS_ERR(fs_path))\r\nreturn PTR_ERR(fs_path);\r\nif (strncmp(path, fs_path, strlen(fs_path)) != 0) {\r\ndprintk("%s: path %s does not begin with fsroot %s\n",\r\n__func__, path, fs_path);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t nfs_parse_server_name(char *string, size_t len,\r\nstruct sockaddr *sa, size_t salen, struct net *net)\r\n{\r\nssize_t ret;\r\nret = rpc_pton(net, string, len, sa, salen);\r\nif (ret == 0) {\r\nret = nfs_dns_resolve_name(net, string, len, sa, salen);\r\nif (ret < 0)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct rpc_clnt *nfs_find_best_sec(struct rpc_clnt *clnt,\r\nstruct nfs_server *server,\r\nstruct nfs4_secinfo_flavors *flavors)\r\n{\r\nrpc_authflavor_t pflavor;\r\nstruct nfs4_secinfo4 *secinfo;\r\nunsigned int i;\r\nfor (i = 0; i < flavors->num_flavors; i++) {\r\nsecinfo = &flavors->flavors[i];\r\nswitch (secinfo->flavor) {\r\ncase RPC_AUTH_NULL:\r\ncase RPC_AUTH_UNIX:\r\ncase RPC_AUTH_GSS:\r\npflavor = rpcauth_get_pseudoflavor(secinfo->flavor,\r\n&secinfo->flavor_info);\r\nif (pflavor != RPC_AUTH_MAXFLAVOR &&\r\nnfs_auth_info_match(&server->auth_info, pflavor)) {\r\nstruct rpc_clnt *new;\r\nstruct rpc_cred *cred;\r\nnew = rpc_clone_client_set_auth(clnt, pflavor);\r\nif (IS_ERR(new))\r\ncontinue;\r\ncred = rpcauth_lookupcred(new->cl_auth, 0);\r\nif (IS_ERR(cred)) {\r\nrpc_shutdown_client(new);\r\ncontinue;\r\n}\r\nput_rpccred(cred);\r\nreturn new;\r\n}\r\n}\r\n}\r\nreturn ERR_PTR(-EPERM);\r\n}\r\nstruct rpc_clnt *\r\nnfs4_negotiate_security(struct rpc_clnt *clnt, struct inode *inode,\r\nstruct qstr *name)\r\n{\r\nstruct page *page;\r\nstruct nfs4_secinfo_flavors *flavors;\r\nstruct rpc_clnt *new;\r\nint err;\r\npage = alloc_page(GFP_KERNEL);\r\nif (!page)\r\nreturn ERR_PTR(-ENOMEM);\r\nflavors = page_address(page);\r\nerr = nfs4_proc_secinfo(inode, name, flavors);\r\nif (err < 0) {\r\nnew = ERR_PTR(err);\r\ngoto out;\r\n}\r\nnew = nfs_find_best_sec(clnt, NFS_SERVER(inode), flavors);\r\nout:\r\nput_page(page);\r\nreturn new;\r\n}\r\nstatic struct vfsmount *try_location(struct nfs_clone_mount *mountdata,\r\nchar *page, char *page2,\r\nconst struct nfs4_fs_location *location)\r\n{\r\nconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\r\nstruct net *net = rpc_net_ns(NFS_SB(mountdata->sb)->client);\r\nstruct vfsmount *mnt = ERR_PTR(-ENOENT);\r\nchar *mnt_path;\r\nunsigned int maxbuflen;\r\nunsigned int s;\r\nmnt_path = nfs4_pathname_string(&location->rootpath, page2, PAGE_SIZE);\r\nif (IS_ERR(mnt_path))\r\nreturn ERR_CAST(mnt_path);\r\nmountdata->mnt_path = mnt_path;\r\nmaxbuflen = mnt_path - 1 - page2;\r\nmountdata->addr = kmalloc(addr_bufsize, GFP_KERNEL);\r\nif (mountdata->addr == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (s = 0; s < location->nservers; s++) {\r\nconst struct nfs4_string *buf = &location->servers[s];\r\nif (buf->len <= 0 || buf->len >= maxbuflen)\r\ncontinue;\r\nif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))\r\ncontinue;\r\nmountdata->addrlen = nfs_parse_server_name(buf->data, buf->len,\r\nmountdata->addr, addr_bufsize, net);\r\nif (mountdata->addrlen == 0)\r\ncontinue;\r\nrpc_set_port(mountdata->addr, NFS_PORT);\r\nmemcpy(page2, buf->data, buf->len);\r\npage2[buf->len] = '\0';\r\nmountdata->hostname = page2;\r\nsnprintf(page, PAGE_SIZE, "%s:%s",\r\nmountdata->hostname,\r\nmountdata->mnt_path);\r\nmnt = vfs_kern_mount(&nfs4_referral_fs_type, 0, page, mountdata);\r\nif (!IS_ERR(mnt))\r\nbreak;\r\n}\r\nkfree(mountdata->addr);\r\nreturn mnt;\r\n}\r\nstatic struct vfsmount *nfs_follow_referral(struct dentry *dentry,\r\nconst struct nfs4_fs_locations *locations)\r\n{\r\nstruct vfsmount *mnt = ERR_PTR(-ENOENT);\r\nstruct nfs_clone_mount mountdata = {\r\n.sb = dentry->d_sb,\r\n.dentry = dentry,\r\n.authflavor = NFS_SB(dentry->d_sb)->client->cl_auth->au_flavor,\r\n};\r\nchar *page = NULL, *page2 = NULL;\r\nint loc, error;\r\nif (locations == NULL || locations->nlocations <= 0)\r\ngoto out;\r\ndprintk("%s: referral at %pd2\n", __func__, dentry);\r\npage = (char *) __get_free_page(GFP_USER);\r\nif (!page)\r\ngoto out;\r\npage2 = (char *) __get_free_page(GFP_USER);\r\nif (!page2)\r\ngoto out;\r\nerror = nfs4_validate_fspath(dentry, locations, page, page2);\r\nif (error < 0) {\r\nmnt = ERR_PTR(error);\r\ngoto out;\r\n}\r\nfor (loc = 0; loc < locations->nlocations; loc++) {\r\nconst struct nfs4_fs_location *location = &locations->locations[loc];\r\nif (location == NULL || location->nservers <= 0 ||\r\nlocation->rootpath.ncomponents == 0)\r\ncontinue;\r\nmnt = try_location(&mountdata, page, page2, location);\r\nif (!IS_ERR(mnt))\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long) page);\r\nfree_page((unsigned long) page2);\r\ndprintk("%s: done\n", __func__);\r\nreturn mnt;\r\n}\r\nstatic struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)\r\n{\r\nstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\r\nstruct dentry *parent;\r\nstruct nfs4_fs_locations *fs_locations = NULL;\r\nstruct page *page;\r\nint err;\r\ndprintk("%s: enter\n", __func__);\r\npage = alloc_page(GFP_KERNEL);\r\nif (page == NULL)\r\ngoto out;\r\nfs_locations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\r\nif (fs_locations == NULL)\r\ngoto out_free;\r\nmnt = ERR_PTR(-ENOENT);\r\nparent = dget_parent(dentry);\r\ndprintk("%s: getting locations for %pd2\n",\r\n__func__, dentry);\r\nerr = nfs4_proc_fs_locations(client, parent->d_inode, &dentry->d_name, fs_locations, page);\r\ndput(parent);\r\nif (err != 0 ||\r\nfs_locations->nlocations <= 0 ||\r\nfs_locations->fs_path.ncomponents <= 0)\r\ngoto out_free;\r\nmnt = nfs_follow_referral(dentry, fs_locations);\r\nout_free:\r\n__free_page(page);\r\nkfree(fs_locations);\r\nout:\r\ndprintk("%s: done\n", __func__);\r\nreturn mnt;\r\n}\r\nstruct vfsmount *nfs4_submount(struct nfs_server *server, struct dentry *dentry,\r\nstruct nfs_fh *fh, struct nfs_fattr *fattr)\r\n{\r\nrpc_authflavor_t flavor = server->client->cl_auth->au_flavor;\r\nstruct dentry *parent = dget_parent(dentry);\r\nstruct inode *dir = parent->d_inode;\r\nstruct qstr *name = &dentry->d_name;\r\nstruct rpc_clnt *client;\r\nstruct vfsmount *mnt;\r\nclient = nfs4_proc_lookup_mountpoint(dir, name, fh, fattr);\r\ndput(parent);\r\nif (IS_ERR(client))\r\nreturn ERR_CAST(client);\r\nif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\r\nmnt = nfs_do_refmount(client, dentry);\r\ngoto out;\r\n}\r\nif (client->cl_auth->au_flavor != flavor)\r\nflavor = client->cl_auth->au_flavor;\r\nmnt = nfs_do_submount(dentry, fh, fattr, flavor);\r\nout:\r\nrpc_shutdown_client(client);\r\nreturn mnt;\r\n}\r\nstatic int nfs4_try_replacing_one_location(struct nfs_server *server,\r\nchar *page, char *page2,\r\nconst struct nfs4_fs_location *location)\r\n{\r\nconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\r\nstruct net *net = rpc_net_ns(server->client);\r\nstruct sockaddr *sap;\r\nunsigned int s;\r\nsize_t salen;\r\nint error;\r\nsap = kmalloc(addr_bufsize, GFP_KERNEL);\r\nif (sap == NULL)\r\nreturn -ENOMEM;\r\nerror = -ENOENT;\r\nfor (s = 0; s < location->nservers; s++) {\r\nconst struct nfs4_string *buf = &location->servers[s];\r\nchar *hostname;\r\nif (buf->len <= 0 || buf->len > PAGE_SIZE)\r\ncontinue;\r\nif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len) != NULL)\r\ncontinue;\r\nsalen = nfs_parse_server_name(buf->data, buf->len,\r\nsap, addr_bufsize, net);\r\nif (salen == 0)\r\ncontinue;\r\nrpc_set_port(sap, NFS_PORT);\r\nerror = -ENOMEM;\r\nhostname = kstrndup(buf->data, buf->len, GFP_KERNEL);\r\nif (hostname == NULL)\r\nbreak;\r\nerror = nfs4_update_server(server, hostname, sap, salen, net);\r\nkfree(hostname);\r\nif (error == 0)\r\nbreak;\r\n}\r\nkfree(sap);\r\nreturn error;\r\n}\r\nint nfs4_replace_transport(struct nfs_server *server,\r\nconst struct nfs4_fs_locations *locations)\r\n{\r\nchar *page = NULL, *page2 = NULL;\r\nint loc, error;\r\nerror = -ENOENT;\r\nif (locations == NULL || locations->nlocations <= 0)\r\ngoto out;\r\nerror = -ENOMEM;\r\npage = (char *) __get_free_page(GFP_USER);\r\nif (!page)\r\ngoto out;\r\npage2 = (char *) __get_free_page(GFP_USER);\r\nif (!page2)\r\ngoto out;\r\nfor (loc = 0; loc < locations->nlocations; loc++) {\r\nconst struct nfs4_fs_location *location =\r\n&locations->locations[loc];\r\nif (location == NULL || location->nservers <= 0 ||\r\nlocation->rootpath.ncomponents == 0)\r\ncontinue;\r\nerror = nfs4_try_replacing_one_location(server, page,\r\npage2, location);\r\nif (error == 0)\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long)page);\r\nfree_page((unsigned long)page2);\r\nreturn error;\r\n}
