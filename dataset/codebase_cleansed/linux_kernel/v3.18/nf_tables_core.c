static void nft_cmp_fast_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1])\r\n{\r\nconst struct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\r\nu32 mask = nft_cmp_fast_mask(priv->len);\r\nif ((data[priv->sreg].data[0] & mask) == priv->data)\r\nreturn;\r\ndata[NFT_REG_VERDICT].verdict = NFT_BREAK;\r\n}\r\nstatic bool nft_payload_fast_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nstruct nft_data *dest = &data[priv->dreg];\r\nunsigned char *ptr;\r\nif (priv->base == NFT_PAYLOAD_NETWORK_HEADER)\r\nptr = skb_network_header(skb);\r\nelse\r\nptr = skb_network_header(skb) + pkt->xt.thoff;\r\nptr += priv->offset;\r\nif (unlikely(ptr + priv->len >= skb_tail_pointer(skb)))\r\nreturn false;\r\nif (priv->len == 2)\r\n*(u16 *)dest->data = *(u16 *)ptr;\r\nelse if (priv->len == 4)\r\n*(u32 *)dest->data = *(u32 *)ptr;\r\nelse\r\n*(u8 *)dest->data = *(u8 *)ptr;\r\nreturn true;\r\n}\r\nstatic void nft_trace_packet(const struct nft_pktinfo *pkt,\r\nconst struct nft_chain *chain,\r\nint rulenum, enum nft_trace type)\r\n{\r\nstruct net *net = dev_net(pkt->in ? pkt->in : pkt->out);\r\nnf_log_packet(net, pkt->xt.family, pkt->ops->hooknum, pkt->skb, pkt->in,\r\npkt->out, &trace_loginfo, "TRACE: %s:%s:%s:%u ",\r\nchain->table->name, chain->name, comments[type],\r\nrulenum);\r\n}\r\nunsigned int\r\nnft_do_chain(struct nft_pktinfo *pkt, const struct nf_hook_ops *ops)\r\n{\r\nconst struct nft_chain *chain = ops->priv, *basechain = chain;\r\nconst struct nft_rule *rule;\r\nconst struct nft_expr *expr, *last;\r\nstruct nft_data data[NFT_REG_MAX + 1];\r\nunsigned int stackptr = 0;\r\nstruct nft_jumpstack jumpstack[NFT_JUMP_STACK_SIZE];\r\nstruct nft_stats *stats;\r\nint rulenum;\r\nunsigned int gencursor = ACCESS_ONCE(chain->net->nft.gencursor);\r\ndo_chain:\r\nrulenum = 0;\r\nrule = list_entry(&chain->rules, struct nft_rule, list);\r\nnext_rule:\r\ndata[NFT_REG_VERDICT].verdict = NFT_CONTINUE;\r\nlist_for_each_entry_continue_rcu(rule, &chain->rules, list) {\r\nif (unlikely(rule->genmask & (1 << gencursor)))\r\ncontinue;\r\nrulenum++;\r\nnft_rule_for_each_expr(expr, last, rule) {\r\nif (expr->ops == &nft_cmp_fast_ops)\r\nnft_cmp_fast_eval(expr, data);\r\nelse if (expr->ops != &nft_payload_fast_ops ||\r\n!nft_payload_fast_eval(expr, data, pkt))\r\nexpr->ops->eval(expr, data, pkt);\r\nif (data[NFT_REG_VERDICT].verdict != NFT_CONTINUE)\r\nbreak;\r\n}\r\nswitch (data[NFT_REG_VERDICT].verdict) {\r\ncase NFT_BREAK:\r\ndata[NFT_REG_VERDICT].verdict = NFT_CONTINUE;\r\ncontinue;\r\ncase NFT_CONTINUE:\r\nif (unlikely(pkt->skb->nf_trace))\r\nnft_trace_packet(pkt, chain, rulenum, NFT_TRACE_RULE);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nswitch (data[NFT_REG_VERDICT].verdict & NF_VERDICT_MASK) {\r\ncase NF_ACCEPT:\r\ncase NF_DROP:\r\ncase NF_QUEUE:\r\nif (unlikely(pkt->skb->nf_trace))\r\nnft_trace_packet(pkt, chain, rulenum, NFT_TRACE_RULE);\r\nreturn data[NFT_REG_VERDICT].verdict;\r\n}\r\nswitch (data[NFT_REG_VERDICT].verdict) {\r\ncase NFT_JUMP:\r\nif (unlikely(pkt->skb->nf_trace))\r\nnft_trace_packet(pkt, chain, rulenum, NFT_TRACE_RULE);\r\nBUG_ON(stackptr >= NFT_JUMP_STACK_SIZE);\r\njumpstack[stackptr].chain = chain;\r\njumpstack[stackptr].rule = rule;\r\njumpstack[stackptr].rulenum = rulenum;\r\nstackptr++;\r\nchain = data[NFT_REG_VERDICT].chain;\r\ngoto do_chain;\r\ncase NFT_GOTO:\r\nif (unlikely(pkt->skb->nf_trace))\r\nnft_trace_packet(pkt, chain, rulenum, NFT_TRACE_RULE);\r\nchain = data[NFT_REG_VERDICT].chain;\r\ngoto do_chain;\r\ncase NFT_RETURN:\r\nif (unlikely(pkt->skb->nf_trace))\r\nnft_trace_packet(pkt, chain, rulenum, NFT_TRACE_RETURN);\r\nbreak;\r\ncase NFT_CONTINUE:\r\nif (unlikely(pkt->skb->nf_trace && !(chain->flags & NFT_BASE_CHAIN)))\r\nnft_trace_packet(pkt, chain, ++rulenum, NFT_TRACE_RETURN);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nif (stackptr > 0) {\r\nstackptr--;\r\nchain = jumpstack[stackptr].chain;\r\nrule = jumpstack[stackptr].rule;\r\nrulenum = jumpstack[stackptr].rulenum;\r\ngoto next_rule;\r\n}\r\nif (unlikely(pkt->skb->nf_trace))\r\nnft_trace_packet(pkt, basechain, -1, NFT_TRACE_POLICY);\r\nrcu_read_lock_bh();\r\nstats = this_cpu_ptr(rcu_dereference(nft_base_chain(basechain)->stats));\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->pkts++;\r\nstats->bytes += pkt->skb->len;\r\nu64_stats_update_end(&stats->syncp);\r\nrcu_read_unlock_bh();\r\nreturn nft_base_chain(basechain)->policy;\r\n}\r\nint __init nf_tables_core_module_init(void)\r\n{\r\nint err;\r\nerr = nft_immediate_module_init();\r\nif (err < 0)\r\ngoto err1;\r\nerr = nft_cmp_module_init();\r\nif (err < 0)\r\ngoto err2;\r\nerr = nft_lookup_module_init();\r\nif (err < 0)\r\ngoto err3;\r\nerr = nft_bitwise_module_init();\r\nif (err < 0)\r\ngoto err4;\r\nerr = nft_byteorder_module_init();\r\nif (err < 0)\r\ngoto err5;\r\nerr = nft_payload_module_init();\r\nif (err < 0)\r\ngoto err6;\r\nreturn 0;\r\nerr6:\r\nnft_byteorder_module_exit();\r\nerr5:\r\nnft_bitwise_module_exit();\r\nerr4:\r\nnft_lookup_module_exit();\r\nerr3:\r\nnft_cmp_module_exit();\r\nerr2:\r\nnft_immediate_module_exit();\r\nerr1:\r\nreturn err;\r\n}\r\nvoid nf_tables_core_module_exit(void)\r\n{\r\nnft_payload_module_exit();\r\nnft_byteorder_module_exit();\r\nnft_bitwise_module_exit();\r\nnft_lookup_module_exit();\r\nnft_cmp_module_exit();\r\nnft_immediate_module_exit();\r\n}
