static unsigned int mcf_tx_empty(struct uart_port *port)\r\n{\r\nreturn (readb(port->membase + MCFUART_USR) & MCFUART_USR_TXEMPTY) ?\r\nTIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int mcf_get_mctrl(struct uart_port *port)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\nunsigned int sigs;\r\nsigs = (readb(port->membase + MCFUART_UIPR) & MCFUART_UIPR_CTS) ?\r\n0 : TIOCM_CTS;\r\nsigs |= (pp->sigs & TIOCM_RTS);\r\nsigs |= (mcf_getppdcd(port->line) ? TIOCM_CD : 0);\r\nsigs |= (mcf_getppdtr(port->line) ? TIOCM_DTR : 0);\r\nreturn sigs;\r\n}\r\nstatic void mcf_set_mctrl(struct uart_port *port, unsigned int sigs)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\npp->sigs = sigs;\r\nmcf_setppdtr(port->line, (sigs & TIOCM_DTR));\r\nif (sigs & TIOCM_RTS)\r\nwriteb(MCFUART_UOP_RTS, port->membase + MCFUART_UOP1);\r\nelse\r\nwriteb(MCFUART_UOP_RTS, port->membase + MCFUART_UOP0);\r\n}\r\nstatic void mcf_start_tx(struct uart_port *port)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\nif (pp->rs485.flags & SER_RS485_ENABLED) {\r\nwriteb(MCFUART_UCR_TXENABLE, port->membase + MCFUART_UCR);\r\nwriteb(MCFUART_UOP_RTS, port->membase + MCFUART_UOP1);\r\n}\r\npp->imr |= MCFUART_UIR_TXREADY;\r\nwriteb(pp->imr, port->membase + MCFUART_UIMR);\r\n}\r\nstatic void mcf_stop_tx(struct uart_port *port)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\npp->imr &= ~MCFUART_UIR_TXREADY;\r\nwriteb(pp->imr, port->membase + MCFUART_UIMR);\r\n}\r\nstatic void mcf_stop_rx(struct uart_port *port)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\npp->imr &= ~MCFUART_UIR_RXREADY;\r\nwriteb(pp->imr, port->membase + MCFUART_UIMR);\r\n}\r\nstatic void mcf_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (break_state == -1)\r\nwriteb(MCFUART_UCR_CMDBREAKSTART, port->membase + MCFUART_UCR);\r\nelse\r\nwriteb(MCFUART_UCR_CMDBREAKSTOP, port->membase + MCFUART_UCR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int mcf_startup(struct uart_port *port)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwriteb(MCFUART_UCR_CMDRESETRX, port->membase + MCFUART_UCR);\r\nwriteb(MCFUART_UCR_CMDRESETTX, port->membase + MCFUART_UCR);\r\nwriteb(MCFUART_UCR_RXENABLE | MCFUART_UCR_TXENABLE,\r\nport->membase + MCFUART_UCR);\r\npp->imr = MCFUART_UIR_RXREADY;\r\nwriteb(pp->imr, port->membase + MCFUART_UIMR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mcf_shutdown(struct uart_port *port)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\npp->imr = 0;\r\nwriteb(pp->imr, port->membase + MCFUART_UIMR);\r\nwriteb(MCFUART_UCR_CMDRESETRX, port->membase + MCFUART_UCR);\r\nwriteb(MCFUART_UCR_CMDRESETTX, port->membase + MCFUART_UCR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void mcf_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\nunsigned long flags;\r\nunsigned int baud, baudclk;\r\n#if defined(CONFIG_M5272)\r\nunsigned int baudfr;\r\n#endif\r\nunsigned char mr1, mr2;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 230400);\r\n#if defined(CONFIG_M5272)\r\nbaudclk = (MCF_BUSCLK / baud) / 32;\r\nbaudfr = (((MCF_BUSCLK / baud) + 1) / 2) % 16;\r\n#else\r\nbaudclk = ((MCF_BUSCLK / baud) + 16) / 32;\r\n#endif\r\nmr1 = MCFUART_MR1_RXIRQRDY | MCFUART_MR1_RXERRCHAR;\r\nmr2 = 0;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5: mr1 |= MCFUART_MR1_CS5; break;\r\ncase CS6: mr1 |= MCFUART_MR1_CS6; break;\r\ncase CS7: mr1 |= MCFUART_MR1_CS7; break;\r\ncase CS8:\r\ndefault: mr1 |= MCFUART_MR1_CS8; break;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\nmr1 |= MCFUART_MR1_PARITYMARK;\r\nelse\r\nmr1 |= MCFUART_MR1_PARITYSPACE;\r\n} else {\r\nif (termios->c_cflag & PARODD)\r\nmr1 |= MCFUART_MR1_PARITYODD;\r\nelse\r\nmr1 |= MCFUART_MR1_PARITYEVEN;\r\n}\r\n} else {\r\nmr1 |= MCFUART_MR1_PARITYNONE;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nmr2 |= MCFUART_MR2_STOP2;\r\nelse\r\nmr2 |= MCFUART_MR2_STOP1;\r\nif (termios->c_cflag & CRTSCTS) {\r\nmr1 |= MCFUART_MR1_RXRTS;\r\nmr2 |= MCFUART_MR2_TXCTS;\r\n}\r\nif (pp->rs485.flags & SER_RS485_ENABLED) {\r\ndev_dbg(port->dev, "Setting UART to RS485\n");\r\nmr2 |= MCFUART_MR2_TXRTS;\r\n}\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nwriteb(MCFUART_UCR_CMDRESETRX, port->membase + MCFUART_UCR);\r\nwriteb(MCFUART_UCR_CMDRESETTX, port->membase + MCFUART_UCR);\r\nwriteb(MCFUART_UCR_CMDRESETMRPTR, port->membase + MCFUART_UCR);\r\nwriteb(mr1, port->membase + MCFUART_UMR);\r\nwriteb(mr2, port->membase + MCFUART_UMR);\r\nwriteb((baudclk & 0xff00) >> 8, port->membase + MCFUART_UBG1);\r\nwriteb((baudclk & 0xff), port->membase + MCFUART_UBG2);\r\n#if defined(CONFIG_M5272)\r\nwriteb((baudfr & 0x0f), port->membase + MCFUART_UFPD);\r\n#endif\r\nwriteb(MCFUART_UCSR_RXCLKTIMER | MCFUART_UCSR_TXCLKTIMER,\r\nport->membase + MCFUART_UCSR);\r\nwriteb(MCFUART_UCR_RXENABLE | MCFUART_UCR_TXENABLE,\r\nport->membase + MCFUART_UCR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void mcf_rx_chars(struct mcf_uart *pp)\r\n{\r\nstruct uart_port *port = &pp->port;\r\nunsigned char status, ch, flag;\r\nwhile ((status = readb(port->membase + MCFUART_USR)) & MCFUART_USR_RXREADY) {\r\nch = readb(port->membase + MCFUART_URB);\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (status & MCFUART_USR_RXERR) {\r\nwriteb(MCFUART_UCR_CMDRESETERR,\r\nport->membase + MCFUART_UCR);\r\nif (status & MCFUART_USR_RXBREAK) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (status & MCFUART_USR_RXPARITY) {\r\nport->icount.parity++;\r\n} else if (status & MCFUART_USR_RXOVERRUN) {\r\nport->icount.overrun++;\r\n} else if (status & MCFUART_USR_RXFRAMING) {\r\nport->icount.frame++;\r\n}\r\nstatus &= port->read_status_mask;\r\nif (status & MCFUART_USR_RXBREAK)\r\nflag = TTY_BREAK;\r\nelse if (status & MCFUART_USR_RXPARITY)\r\nflag = TTY_PARITY;\r\nelse if (status & MCFUART_USR_RXFRAMING)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nuart_insert_char(port, status, MCFUART_USR_RXOVERRUN, ch, flag);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(&port->state->port);\r\nspin_lock(&port->lock);\r\n}\r\nstatic void mcf_tx_chars(struct mcf_uart *pp)\r\n{\r\nstruct uart_port *port = &pp->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\nwriteb(port->x_char, port->membase + MCFUART_UTB);\r\nport->x_char = 0;\r\nport->icount.tx++;\r\nreturn;\r\n}\r\nwhile (readb(port->membase + MCFUART_USR) & MCFUART_USR_TXREADY) {\r\nif (xmit->head == xmit->tail)\r\nbreak;\r\nwriteb(xmit->buf[xmit->tail], port->membase + MCFUART_UTB);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE -1);\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (xmit->head == xmit->tail) {\r\npp->imr &= ~MCFUART_UIR_TXREADY;\r\nwriteb(pp->imr, port->membase + MCFUART_UIMR);\r\nif (pp->rs485.flags & SER_RS485_ENABLED)\r\nwriteb(MCFUART_UCR_TXDISABLE,\r\nport->membase + MCFUART_UCR);\r\n}\r\n}\r\nstatic irqreturn_t mcf_interrupt(int irq, void *data)\r\n{\r\nstruct uart_port *port = data;\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\nunsigned int isr;\r\nirqreturn_t ret = IRQ_NONE;\r\nisr = readb(port->membase + MCFUART_UISR) & pp->imr;\r\nspin_lock(&port->lock);\r\nif (isr & MCFUART_UIR_RXREADY) {\r\nmcf_rx_chars(pp);\r\nret = IRQ_HANDLED;\r\n}\r\nif (isr & MCFUART_UIR_TXREADY) {\r\nmcf_tx_chars(pp);\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock(&port->lock);\r\nreturn ret;\r\n}\r\nstatic void mcf_config_port(struct uart_port *port, int flags)\r\n{\r\nport->type = PORT_MCF;\r\nport->fifosize = MCFUART_TXFIFOSIZE;\r\nwriteb(0, port->membase + MCFUART_UIMR);\r\nif (request_irq(port->irq, mcf_interrupt, 0, "UART", port))\r\nprintk(KERN_ERR "MCF: unable to attach ColdFire UART %d "\r\n"interrupt vector=%d\n", port->line, port->irq);\r\n}\r\nstatic const char *mcf_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_MCF) ? "ColdFire UART" : NULL;\r\n}\r\nstatic int mcf_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mcf_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int mcf_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif ((ser->type != PORT_UNKNOWN) && (ser->type != PORT_MCF))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void mcf_config_rs485(struct uart_port *port, struct serial_rs485 *rs485)\r\n{\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\nunsigned long flags;\r\nunsigned char mr1, mr2;\r\nspin_lock_irqsave(&port->lock, flags);\r\nmr1 = readb(port->membase + MCFUART_UMR);\r\nmr2 = readb(port->membase + MCFUART_UMR);\r\nif (rs485->flags & SER_RS485_ENABLED) {\r\ndev_dbg(port->dev, "Setting UART to RS485\n");\r\nmr2 |= MCFUART_MR2_TXRTS;\r\n} else {\r\ndev_dbg(port->dev, "Setting UART to RS232\n");\r\nmr2 &= ~MCFUART_MR2_TXRTS;\r\n}\r\nwriteb(mr1, port->membase + MCFUART_UMR);\r\nwriteb(mr2, port->membase + MCFUART_UMR);\r\npp->rs485 = *rs485;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int mcf_ioctl(struct uart_port *port, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase TIOCSRS485: {\r\nstruct serial_rs485 rs485;\r\nif (copy_from_user(&rs485, (struct serial_rs485 *)arg,\r\nsizeof(struct serial_rs485)))\r\nreturn -EFAULT;\r\nmcf_config_rs485(port, &rs485);\r\nbreak;\r\n}\r\ncase TIOCGRS485: {\r\nstruct mcf_uart *pp = container_of(port, struct mcf_uart, port);\r\nif (copy_to_user((struct serial_rs485 *)arg, &pp->rs485,\r\nsizeof(struct serial_rs485)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nint __init early_mcf_setup(struct mcf_platform_uart *platp)\r\n{\r\nstruct uart_port *port;\r\nint i;\r\nfor (i = 0; ((i < MCF_MAXPORTS) && (platp[i].mapbase)); i++) {\r\nport = &mcf_ports[i].port;\r\nport->line = i;\r\nport->type = PORT_MCF;\r\nport->mapbase = platp[i].mapbase;\r\nport->membase = (platp[i].membase) ? platp[i].membase :\r\n(unsigned char __iomem *) port->mapbase;\r\nport->iotype = SERIAL_IO_MEM;\r\nport->irq = platp[i].irq;\r\nport->uartclk = MCF_BUSCLK;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->ops = &mcf_uart_ops;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mcf_console_putc(struct console *co, const char c)\r\n{\r\nstruct uart_port *port = &(mcf_ports + co->index)->port;\r\nint i;\r\nfor (i = 0; (i < 0x10000); i++) {\r\nif (readb(port->membase + MCFUART_USR) & MCFUART_USR_TXREADY)\r\nbreak;\r\n}\r\nwriteb(c, port->membase + MCFUART_UTB);\r\nfor (i = 0; (i < 0x10000); i++) {\r\nif (readb(port->membase + MCFUART_USR) & MCFUART_USR_TXREADY)\r\nbreak;\r\n}\r\n}\r\nstatic void mcf_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nfor (; (count); count--, s++) {\r\nmcf_console_putc(co, *s);\r\nif (*s == '\n')\r\nmcf_console_putc(co, '\r');\r\n}\r\n}\r\nstatic int __init mcf_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = CONFIG_SERIAL_MCF_BAUDRATE;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif ((co->index < 0) || (co->index >= MCF_MAXPORTS))\r\nco->index = 0;\r\nport = &mcf_ports[co->index].port;\r\nif (port->membase == 0)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init mcf_console_init(void)\r\n{\r\nregister_console(&mcf_console);\r\nreturn 0;\r\n}\r\nstatic int mcf_probe(struct platform_device *pdev)\r\n{\r\nstruct mcf_platform_uart *platp = dev_get_platdata(&pdev->dev);\r\nstruct uart_port *port;\r\nint i;\r\nfor (i = 0; ((i < MCF_MAXPORTS) && (platp[i].mapbase)); i++) {\r\nport = &mcf_ports[i].port;\r\nport->line = i;\r\nport->type = PORT_MCF;\r\nport->mapbase = platp[i].mapbase;\r\nport->membase = (platp[i].membase) ? platp[i].membase :\r\n(unsigned char __iomem *) platp[i].mapbase;\r\nport->iotype = SERIAL_IO_MEM;\r\nport->irq = platp[i].irq;\r\nport->uartclk = MCF_BUSCLK;\r\nport->ops = &mcf_uart_ops;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nuart_add_one_port(&mcf_driver, port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcf_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port;\r\nint i;\r\nfor (i = 0; (i < MCF_MAXPORTS); i++) {\r\nport = &mcf_ports[i].port;\r\nif (port)\r\nuart_remove_one_port(&mcf_driver, port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mcf_init(void)\r\n{\r\nint rc;\r\nprintk("ColdFire internal UART serial driver\n");\r\nrc = uart_register_driver(&mcf_driver);\r\nif (rc)\r\nreturn rc;\r\nrc = platform_driver_register(&mcf_platform_driver);\r\nif (rc) {\r\nuart_unregister_driver(&mcf_driver);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit mcf_exit(void)\r\n{\r\nplatform_driver_unregister(&mcf_platform_driver);\r\nuart_unregister_driver(&mcf_driver);\r\n}
