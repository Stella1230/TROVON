static int mx27vis_aic32x4_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nint ret;\r\nu32 dai_format;\r\ndai_format = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF |\r\nSND_SOC_DAIFMT_CBM_CFM;\r\nsnd_soc_dai_set_fmt(codec_dai, dai_format);\r\nsnd_soc_dai_set_fmt(cpu_dai, dai_format);\r\nret = snd_soc_dai_set_sysclk(codec_dai, 0,\r\n25000000, SND_SOC_CLOCK_OUT);\r\nif (ret) {\r\npr_err("%s: failed setting codec sysclk\n", __func__);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0,\r\nSND_SOC_CLOCK_IN);\r\nif (ret) {\r\npr_err("can't set CPU system clock IMX_SSP_SYS_CLK\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mx27vis_amp_set(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nint value = ucontrol->value.integer.value[0];\r\nunsigned int reg = mc->reg;\r\nint max = mc->max;\r\nif (value > max)\r\nreturn -EINVAL;\r\nswitch (reg) {\r\ncase MX27VIS_AMP_GAIN:\r\ngpio_set_value(mx27vis_amp_gain0_gpio, value & 1);\r\ngpio_set_value(mx27vis_amp_gain1_gpio, value >> 1);\r\nmx27vis_amp_gain = value;\r\nbreak;\r\ncase MX27VIS_AMP_MUTE:\r\ngpio_set_value(mx27vis_amp_mutel_gpio, value & 1);\r\ngpio_set_value(mx27vis_amp_muter_gpio, value >> 1);\r\nmx27vis_amp_mute = value;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mx27vis_amp_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int reg = mc->reg;\r\nswitch (reg) {\r\ncase MX27VIS_AMP_GAIN:\r\nucontrol->value.integer.value[0] = mx27vis_amp_gain;\r\nbreak;\r\ncase MX27VIS_AMP_MUTE:\r\nucontrol->value.integer.value[0] = mx27vis_amp_mute;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mx27vis_aic32x4_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_mx27vis_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\nmx27vis_amp_gain0_gpio = pdata->amp_gain0_gpio;\r\nmx27vis_amp_gain1_gpio = pdata->amp_gain1_gpio;\r\nmx27vis_amp_mutel_gpio = pdata->amp_mutel_gpio;\r\nmx27vis_amp_muter_gpio = pdata->amp_muter_gpio;\r\nmx27vis_aic32x4.dev = &pdev->dev;\r\nret = snd_soc_register_card(&mx27vis_aic32x4);\r\nif (ret) {\r\ndev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nimx_audmux_v1_configure_port(MX27_AUDMUX_HPCR1_SSI0,\r\nIMX_AUDMUX_V1_PCR_SYN |\r\nIMX_AUDMUX_V1_PCR_TFSDIR |\r\nIMX_AUDMUX_V1_PCR_TCLKDIR |\r\nIMX_AUDMUX_V1_PCR_TFCSEL(MX27_AUDMUX_PPCR1_SSI_PINS_1) |\r\nIMX_AUDMUX_V1_PCR_RXDSEL(MX27_AUDMUX_PPCR1_SSI_PINS_1)\r\n);\r\nimx_audmux_v1_configure_port(MX27_AUDMUX_PPCR1_SSI_PINS_1,\r\nIMX_AUDMUX_V1_PCR_SYN |\r\nIMX_AUDMUX_V1_PCR_RXDSEL(MX27_AUDMUX_HPCR1_SSI0)\r\n);\r\nreturn ret;\r\n}\r\nstatic int mx27vis_aic32x4_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_card(&mx27vis_aic32x4);\r\nreturn 0;\r\n}
