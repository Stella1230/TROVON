struct tipc_media *tipc_media_find(const char *name)\r\n{\r\nu32 i;\r\nfor (i = 0; media_info_array[i] != NULL; i++) {\r\nif (!strcmp(media_info_array[i]->name, name))\r\nbreak;\r\n}\r\nreturn media_info_array[i];\r\n}\r\nstatic struct tipc_media *media_find_id(u8 type)\r\n{\r\nu32 i;\r\nfor (i = 0; media_info_array[i] != NULL; i++) {\r\nif (media_info_array[i]->type_id == type)\r\nbreak;\r\n}\r\nreturn media_info_array[i];\r\n}\r\nvoid tipc_media_addr_printf(char *buf, int len, struct tipc_media_addr *a)\r\n{\r\nchar addr_str[MAX_ADDR_STR];\r\nstruct tipc_media *m_ptr;\r\nint ret;\r\nm_ptr = media_find_id(a->media_id);\r\nif (m_ptr && !m_ptr->addr2str(a, addr_str, sizeof(addr_str)))\r\nret = tipc_snprintf(buf, len, "%s(%s)", m_ptr->name, addr_str);\r\nelse {\r\nu32 i;\r\nret = tipc_snprintf(buf, len, "UNKNOWN(%u)", a->media_id);\r\nfor (i = 0; i < sizeof(a->value); i++)\r\nret += tipc_snprintf(buf - ret, len + ret,\r\n"-%02x", a->value[i]);\r\n}\r\n}\r\nstruct sk_buff *tipc_media_get_names(void)\r\n{\r\nstruct sk_buff *buf;\r\nint i;\r\nbuf = tipc_cfg_reply_alloc(MAX_MEDIA * TLV_SPACE(TIPC_MAX_MEDIA_NAME));\r\nif (!buf)\r\nreturn NULL;\r\nfor (i = 0; media_info_array[i] != NULL; i++) {\r\ntipc_cfg_append_tlv(buf, TIPC_TLV_MEDIA_NAME,\r\nmedia_info_array[i]->name,\r\nstrlen(media_info_array[i]->name) + 1);\r\n}\r\nreturn buf;\r\n}\r\nstatic int bearer_name_validate(const char *name,\r\nstruct tipc_bearer_names *name_parts)\r\n{\r\nchar name_copy[TIPC_MAX_BEARER_NAME];\r\nchar *media_name;\r\nchar *if_name;\r\nu32 media_len;\r\nu32 if_len;\r\nname_copy[TIPC_MAX_BEARER_NAME - 1] = 0;\r\nstrncpy(name_copy, name, TIPC_MAX_BEARER_NAME);\r\nif (name_copy[TIPC_MAX_BEARER_NAME - 1] != 0)\r\nreturn 0;\r\nmedia_name = name_copy;\r\nif_name = strchr(media_name, ':');\r\nif (if_name == NULL)\r\nreturn 0;\r\n*(if_name++) = 0;\r\nmedia_len = if_name - media_name;\r\nif_len = strlen(if_name) + 1;\r\nif ((media_len <= 1) || (media_len > TIPC_MAX_MEDIA_NAME) ||\r\n(if_len <= 1) || (if_len > TIPC_MAX_IF_NAME))\r\nreturn 0;\r\nif (name_parts) {\r\nstrcpy(name_parts->media_name, media_name);\r\nstrcpy(name_parts->if_name, if_name);\r\n}\r\nreturn 1;\r\n}\r\nstruct tipc_bearer *tipc_bearer_find(const char *name)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nu32 i;\r\nfor (i = 0; i < MAX_BEARERS; i++) {\r\nb_ptr = rtnl_dereference(bearer_list[i]);\r\nif (b_ptr && (!strcmp(b_ptr->name, name)))\r\nreturn b_ptr;\r\n}\r\nreturn NULL;\r\n}\r\nstruct sk_buff *tipc_bearer_get_names(void)\r\n{\r\nstruct sk_buff *buf;\r\nstruct tipc_bearer *b;\r\nint i, j;\r\nbuf = tipc_cfg_reply_alloc(MAX_BEARERS * TLV_SPACE(TIPC_MAX_BEARER_NAME));\r\nif (!buf)\r\nreturn NULL;\r\nfor (i = 0; media_info_array[i] != NULL; i++) {\r\nfor (j = 0; j < MAX_BEARERS; j++) {\r\nb = rtnl_dereference(bearer_list[j]);\r\nif (!b)\r\ncontinue;\r\nif (b->media == media_info_array[i]) {\r\ntipc_cfg_append_tlv(buf, TIPC_TLV_BEARER_NAME,\r\nb->name,\r\nstrlen(b->name) + 1);\r\n}\r\n}\r\n}\r\nreturn buf;\r\n}\r\nvoid tipc_bearer_add_dest(u32 bearer_id, u32 dest)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nrcu_read_lock();\r\nb_ptr = rcu_dereference_rtnl(bearer_list[bearer_id]);\r\nif (b_ptr) {\r\ntipc_bcbearer_sort(&b_ptr->nodes, dest, true);\r\ntipc_disc_add_dest(b_ptr->link_req);\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid tipc_bearer_remove_dest(u32 bearer_id, u32 dest)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nrcu_read_lock();\r\nb_ptr = rcu_dereference_rtnl(bearer_list[bearer_id]);\r\nif (b_ptr) {\r\ntipc_bcbearer_sort(&b_ptr->nodes, dest, false);\r\ntipc_disc_remove_dest(b_ptr->link_req);\r\n}\r\nrcu_read_unlock();\r\n}\r\nint tipc_enable_bearer(const char *name, u32 disc_domain, u32 priority)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nstruct tipc_media *m_ptr;\r\nstruct tipc_bearer_names b_names;\r\nchar addr_string[16];\r\nu32 bearer_id;\r\nu32 with_this_prio;\r\nu32 i;\r\nint res = -EINVAL;\r\nif (!tipc_own_addr) {\r\npr_warn("Bearer <%s> rejected, not supported in standalone mode\n",\r\nname);\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (!bearer_name_validate(name, &b_names)) {\r\npr_warn("Bearer <%s> rejected, illegal name\n", name);\r\nreturn -EINVAL;\r\n}\r\nif (tipc_addr_domain_valid(disc_domain) &&\r\n(disc_domain != tipc_own_addr)) {\r\nif (tipc_in_scope(disc_domain, tipc_own_addr)) {\r\ndisc_domain = tipc_own_addr & TIPC_CLUSTER_MASK;\r\nres = 0;\r\n} else if (in_own_cluster_exact(disc_domain))\r\nres = 0;\r\n}\r\nif (res) {\r\npr_warn("Bearer <%s> rejected, illegal discovery domain\n",\r\nname);\r\nreturn -EINVAL;\r\n}\r\nif ((priority > TIPC_MAX_LINK_PRI) &&\r\n(priority != TIPC_MEDIA_LINK_PRI)) {\r\npr_warn("Bearer <%s> rejected, illegal priority\n", name);\r\nreturn -EINVAL;\r\n}\r\nm_ptr = tipc_media_find(b_names.media_name);\r\nif (!m_ptr) {\r\npr_warn("Bearer <%s> rejected, media <%s> not registered\n",\r\nname, b_names.media_name);\r\nreturn -EINVAL;\r\n}\r\nif (priority == TIPC_MEDIA_LINK_PRI)\r\npriority = m_ptr->priority;\r\nrestart:\r\nbearer_id = MAX_BEARERS;\r\nwith_this_prio = 1;\r\nfor (i = MAX_BEARERS; i-- != 0; ) {\r\nb_ptr = rtnl_dereference(bearer_list[i]);\r\nif (!b_ptr) {\r\nbearer_id = i;\r\ncontinue;\r\n}\r\nif (!strcmp(name, b_ptr->name)) {\r\npr_warn("Bearer <%s> rejected, already enabled\n",\r\nname);\r\nreturn -EINVAL;\r\n}\r\nif ((b_ptr->priority == priority) &&\r\n(++with_this_prio > 2)) {\r\nif (priority-- == 0) {\r\npr_warn("Bearer <%s> rejected, duplicate priority\n",\r\nname);\r\nreturn -EINVAL;\r\n}\r\npr_warn("Bearer <%s> priority adjustment required %u->%u\n",\r\nname, priority + 1, priority);\r\ngoto restart;\r\n}\r\n}\r\nif (bearer_id >= MAX_BEARERS) {\r\npr_warn("Bearer <%s> rejected, bearer limit reached (%u)\n",\r\nname, MAX_BEARERS);\r\nreturn -EINVAL;\r\n}\r\nb_ptr = kzalloc(sizeof(*b_ptr), GFP_ATOMIC);\r\nif (!b_ptr)\r\nreturn -ENOMEM;\r\nstrcpy(b_ptr->name, name);\r\nb_ptr->media = m_ptr;\r\nres = m_ptr->enable_media(b_ptr);\r\nif (res) {\r\npr_warn("Bearer <%s> rejected, enable failure (%d)\n",\r\nname, -res);\r\nreturn -EINVAL;\r\n}\r\nb_ptr->identity = bearer_id;\r\nb_ptr->tolerance = m_ptr->tolerance;\r\nb_ptr->window = m_ptr->window;\r\nb_ptr->domain = disc_domain;\r\nb_ptr->net_plane = bearer_id + 'A';\r\nb_ptr->priority = priority;\r\nres = tipc_disc_create(b_ptr, &b_ptr->bcast_addr);\r\nif (res) {\r\nbearer_disable(b_ptr, false);\r\npr_warn("Bearer <%s> rejected, discovery object creation failed\n",\r\nname);\r\nreturn -EINVAL;\r\n}\r\nrcu_assign_pointer(bearer_list[bearer_id], b_ptr);\r\npr_info("Enabled bearer <%s>, discovery domain %s, priority %u\n",\r\nname,\r\ntipc_addr_string_fill(addr_string, disc_domain), priority);\r\nreturn res;\r\n}\r\nstatic int tipc_reset_bearer(struct tipc_bearer *b_ptr)\r\n{\r\npr_info("Resetting bearer <%s>\n", b_ptr->name);\r\ntipc_link_reset_list(b_ptr->identity);\r\ntipc_disc_reset(b_ptr);\r\nreturn 0;\r\n}\r\nstatic void bearer_disable(struct tipc_bearer *b_ptr, bool shutting_down)\r\n{\r\nu32 i;\r\npr_info("Disabling bearer <%s>\n", b_ptr->name);\r\nb_ptr->media->disable_media(b_ptr);\r\ntipc_link_delete_list(b_ptr->identity, shutting_down);\r\nif (b_ptr->link_req)\r\ntipc_disc_delete(b_ptr->link_req);\r\nfor (i = 0; i < MAX_BEARERS; i++) {\r\nif (b_ptr == rtnl_dereference(bearer_list[i])) {\r\nRCU_INIT_POINTER(bearer_list[i], NULL);\r\nbreak;\r\n}\r\n}\r\nkfree_rcu(b_ptr, rcu);\r\n}\r\nint tipc_disable_bearer(const char *name)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nint res;\r\nb_ptr = tipc_bearer_find(name);\r\nif (b_ptr == NULL) {\r\npr_warn("Attempt to disable unknown bearer <%s>\n", name);\r\nres = -EINVAL;\r\n} else {\r\nbearer_disable(b_ptr, false);\r\nres = 0;\r\n}\r\nreturn res;\r\n}\r\nint tipc_enable_l2_media(struct tipc_bearer *b)\r\n{\r\nstruct net_device *dev;\r\nchar *driver_name = strchr((const char *)b->name, ':') + 1;\r\ndev = dev_get_by_name(&init_net, driver_name);\r\nif (!dev)\r\nreturn -ENODEV;\r\nrcu_assign_pointer(b->media_ptr, dev);\r\nmemset(&b->bcast_addr, 0, sizeof(b->bcast_addr));\r\nmemcpy(b->bcast_addr.value, dev->broadcast, b->media->hwaddr_len);\r\nb->bcast_addr.media_id = b->media->type_id;\r\nb->bcast_addr.broadcast = 1;\r\nb->mtu = dev->mtu;\r\nb->media->raw2addr(b, &b->addr, (char *)dev->dev_addr);\r\nrcu_assign_pointer(dev->tipc_ptr, b);\r\nreturn 0;\r\n}\r\nvoid tipc_disable_l2_media(struct tipc_bearer *b)\r\n{\r\nstruct net_device *dev;\r\ndev = (struct net_device *)rtnl_dereference(b->media_ptr);\r\nRCU_INIT_POINTER(b->media_ptr, NULL);\r\nRCU_INIT_POINTER(dev->tipc_ptr, NULL);\r\nsynchronize_net();\r\ndev_put(dev);\r\n}\r\nint tipc_l2_send_msg(struct sk_buff *buf, struct tipc_bearer *b,\r\nstruct tipc_media_addr *dest)\r\n{\r\nstruct sk_buff *clone;\r\nstruct net_device *dev;\r\nint delta;\r\ndev = (struct net_device *)rcu_dereference_rtnl(b->media_ptr);\r\nif (!dev)\r\nreturn 0;\r\nclone = skb_clone(buf, GFP_ATOMIC);\r\nif (!clone)\r\nreturn 0;\r\ndelta = dev->hard_header_len - skb_headroom(buf);\r\nif ((delta > 0) &&\r\npskb_expand_head(clone, SKB_DATA_ALIGN(delta), 0, GFP_ATOMIC)) {\r\nkfree_skb(clone);\r\nreturn 0;\r\n}\r\nskb_reset_network_header(clone);\r\nclone->dev = dev;\r\nclone->protocol = htons(ETH_P_TIPC);\r\ndev_hard_header(clone, dev, ETH_P_TIPC, dest->value,\r\ndev->dev_addr, clone->len);\r\ndev_queue_xmit(clone);\r\nreturn 0;\r\n}\r\nvoid tipc_bearer_send(u32 bearer_id, struct sk_buff *buf,\r\nstruct tipc_media_addr *dest)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nrcu_read_lock();\r\nb_ptr = rcu_dereference_rtnl(bearer_list[bearer_id]);\r\nif (likely(b_ptr))\r\nb_ptr->media->send_msg(buf, b_ptr, dest);\r\nrcu_read_unlock();\r\n}\r\nstatic int tipc_l2_rcv_msg(struct sk_buff *buf, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nif (!net_eq(dev_net(dev), &init_net)) {\r\nkfree_skb(buf);\r\nreturn NET_RX_DROP;\r\n}\r\nrcu_read_lock();\r\nb_ptr = rcu_dereference_rtnl(dev->tipc_ptr);\r\nif (likely(b_ptr)) {\r\nif (likely(buf->pkt_type <= PACKET_BROADCAST)) {\r\nbuf->next = NULL;\r\ntipc_rcv(buf, b_ptr);\r\nrcu_read_unlock();\r\nreturn NET_RX_SUCCESS;\r\n}\r\n}\r\nrcu_read_unlock();\r\nkfree_skb(buf);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,\r\nvoid *ptr)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nb_ptr = rtnl_dereference(dev->tipc_ptr);\r\nif (!b_ptr)\r\nreturn NOTIFY_DONE;\r\nb_ptr->mtu = dev->mtu;\r\nswitch (evt) {\r\ncase NETDEV_CHANGE:\r\nif (netif_carrier_ok(dev))\r\nbreak;\r\ncase NETDEV_DOWN:\r\ncase NETDEV_CHANGEMTU:\r\ntipc_reset_bearer(b_ptr);\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nb_ptr->media->raw2addr(b_ptr, &b_ptr->addr,\r\n(char *)dev->dev_addr);\r\ntipc_reset_bearer(b_ptr);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\ncase NETDEV_CHANGENAME:\r\nbearer_disable(b_ptr, false);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nint tipc_bearer_setup(void)\r\n{\r\nint err;\r\nerr = register_netdevice_notifier(&notifier);\r\nif (err)\r\nreturn err;\r\ndev_add_pack(&tipc_packet_type);\r\nreturn 0;\r\n}\r\nvoid tipc_bearer_cleanup(void)\r\n{\r\nunregister_netdevice_notifier(&notifier);\r\ndev_remove_pack(&tipc_packet_type);\r\n}\r\nvoid tipc_bearer_stop(void)\r\n{\r\nstruct tipc_bearer *b_ptr;\r\nu32 i;\r\nfor (i = 0; i < MAX_BEARERS; i++) {\r\nb_ptr = rtnl_dereference(bearer_list[i]);\r\nif (b_ptr) {\r\nbearer_disable(b_ptr, true);\r\nbearer_list[i] = NULL;\r\n}\r\n}\r\n}
