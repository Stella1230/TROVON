int SearchSfid(struct bcm_mini_adapter *Adapter, UINT uiSfid)\r\n{\r\nint i;\r\nfor (i = (NO_OF_QUEUES-1); i >= 0; i--)\r\nif (Adapter->PackInfo[i].ulSFID == uiSfid)\r\nreturn i;\r\nreturn NO_OF_QUEUES+1;\r\n}\r\nstatic int SearchFreeSfid(struct bcm_mini_adapter *Adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < (NO_OF_QUEUES-1); i++)\r\nif (Adapter->PackInfo[i].ulSFID == 0)\r\nreturn i;\r\nreturn NO_OF_QUEUES+1;\r\n}\r\nstatic int SearchClsid(struct bcm_mini_adapter *Adapter,\r\nULONG ulSFID,\r\nB_UINT16 uiClassifierID)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CLASSIFIERS; i++) {\r\nif ((Adapter->astClassifierTable[i].bUsed) &&\r\n(Adapter->astClassifierTable[i].uiClassifierRuleIndex\r\n== uiClassifierID) &&\r\n(Adapter->astClassifierTable[i].ulSFID == ulSFID))\r\nreturn i;\r\n}\r\nreturn MAX_CLASSIFIERS+1;\r\n}\r\nstatic int SearchFreeClsid(struct bcm_mini_adapter *Adapter )\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CLASSIFIERS; i++) {\r\nif (!Adapter->astClassifierTable[i].bUsed)\r\nreturn i;\r\n}\r\nreturn MAX_CLASSIFIERS+1;\r\n}\r\nstatic VOID deleteSFBySfid(struct bcm_mini_adapter *Adapter,\r\nUINT uiSearchRuleIndex)\r\n{\r\nflush_queue(Adapter, uiSearchRuleIndex);\r\nDeleteAllClassifiersForSF(Adapter, uiSearchRuleIndex);\r\nmemset((PVOID)&Adapter->PackInfo[uiSearchRuleIndex], 0,\r\nsizeof(struct bcm_mibs_table));\r\n}\r\nstatic inline VOID\r\nCopyIpAddrToClassifier(struct bcm_classifier_rule *pstClassifierEntry,\r\nB_UINT8 u8IpAddressLen, B_UINT8 *pu8IpAddressMaskSrc,\r\nbool bIpVersion6, enum bcm_ipaddr_context eIpAddrContext)\r\n{\r\nint i = 0;\r\nUINT nSizeOfIPAddressInBytes = IP_LENGTH_OF_ADDRESS;\r\nUCHAR *ptrClassifierIpAddress = NULL;\r\nUCHAR *ptrClassifierIpMask = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif (bIpVersion6)\r\nnSizeOfIPAddressInBytes = IPV6_ADDRESS_SIZEINBYTES;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Ip Address Range Length:0x%X ", u8IpAddressLen);\r\nif ((bIpVersion6 ? (IPV6_ADDRESS_SIZEINBYTES * MAX_IP_RANGE_LENGTH * 2) :\r\n(TOTAL_MASKED_ADDRESS_IN_BYTES)) >= u8IpAddressLen) {\r\nunion u_ip_address *st_dest_ip =\r\n&pstClassifierEntry->stDestIpAddress;\r\nunion u_ip_address *st_src_ip =\r\n&pstClassifierEntry->stSrcIpAddress;\r\nif (eIpAddrContext == eDestIpAddress) {\r\npstClassifierEntry->ucIPDestinationAddressLength =\r\nu8IpAddressLen/(nSizeOfIPAddressInBytes * 2);\r\nif (bIpVersion6) {\r\nptrClassifierIpAddress =\r\nst_dest_ip->ucIpv6Address;\r\nptrClassifierIpMask =\r\nst_dest_ip->ucIpv6Mask;\r\n} else {\r\nptrClassifierIpAddress =\r\nst_dest_ip->ucIpv4Address;\r\nptrClassifierIpMask =\r\nst_dest_ip->ucIpv4Mask;\r\n}\r\n} else if (eIpAddrContext == eSrcIpAddress) {\r\npstClassifierEntry->ucIPSourceAddressLength =\r\nu8IpAddressLen/(nSizeOfIPAddressInBytes * 2);\r\nif (bIpVersion6) {\r\nptrClassifierIpAddress =\r\nst_src_ip->ucIpv6Address;\r\nptrClassifierIpMask = st_src_ip->ucIpv6Mask;\r\n} else {\r\nptrClassifierIpAddress =\r\nst_src_ip->ucIpv4Address;\r\nptrClassifierIpMask = st_src_ip->ucIpv4Mask;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Address Length:0x%X\n",\r\npstClassifierEntry->ucIPDestinationAddressLength);\r\nwhile ((u8IpAddressLen >= nSizeOfIPAddressInBytes)\r\n&& (i < MAX_IP_RANGE_LENGTH)) {\r\nmemcpy(ptrClassifierIpAddress +\r\n(i * nSizeOfIPAddressInBytes),\r\n(pu8IpAddressMaskSrc\r\n+ (i * nSizeOfIPAddressInBytes * 2)),\r\nnSizeOfIPAddressInBytes);\r\nif (!bIpVersion6) {\r\nif (eIpAddrContext == eSrcIpAddress) {\r\nst_src_ip->ulIpv4Addr[i] =\r\nntohl(st_src_ip->ulIpv4Addr[i]);\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nCONN_MSG,\r\nDBG_LVL_ALL,\r\n"Src Ip Address:0x%luX ",\r\nst_src_ip->ulIpv4Addr[i]);\r\n} else if (eIpAddrContext == eDestIpAddress) {\r\nst_dest_ip->ulIpv4Addr[i] =\r\nntohl(st_dest_ip->ulIpv4Addr[i]);\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nCONN_MSG,\r\nDBG_LVL_ALL,\r\n"Dest Ip Address:0x%luX ",\r\nst_dest_ip->ulIpv4Addr[i]);\r\n}\r\n}\r\nu8IpAddressLen -= nSizeOfIPAddressInBytes;\r\nif (u8IpAddressLen >= nSizeOfIPAddressInBytes) {\r\nmemcpy(ptrClassifierIpMask +\r\n(i * nSizeOfIPAddressInBytes),\r\n(pu8IpAddressMaskSrc\r\n+ nSizeOfIPAddressInBytes\r\n+ (i * nSizeOfIPAddressInBytes * 2)),\r\nnSizeOfIPAddressInBytes);\r\nif (!bIpVersion6) {\r\nif (eIpAddrContext == eSrcIpAddress) {\r\nst_src_ip->ulIpv4Mask[i] =\r\nntohl(st_src_ip->ulIpv4Mask[i]);\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nCONN_MSG,\r\nDBG_LVL_ALL,\r\n"Src Ip Mask Address:0x%luX ",\r\nst_src_ip->ulIpv4Mask[i]);\r\n} else if (eIpAddrContext == eDestIpAddress) {\r\nst_dest_ip->ulIpv4Mask[i] =\r\nntohl(st_dest_ip->ulIpv4Mask[i]);\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nCONN_MSG,\r\nDBG_LVL_ALL,\r\n"Dest Ip Mask Address:0x%luX ",\r\nst_dest_ip->ulIpv4Mask[i]);\r\n}\r\n}\r\nu8IpAddressLen -= nSizeOfIPAddressInBytes;\r\n}\r\nif (u8IpAddressLen == 0)\r\npstClassifierEntry->bDestIpValid = TRUE;\r\ni++;\r\n}\r\nif (bIpVersion6) {\r\nrestore_endianess_of_pstClassifierEntry(\r\npstClassifierEntry,\r\neIpAddrContext\r\n);\r\n}\r\n}\r\n}\r\nvoid ClearTargetDSXBuffer(struct bcm_mini_adapter *Adapter, B_UINT16 TID, bool bFreeAll)\r\n{\r\nint i;\r\nstruct bcm_targetdsx_buffer *curr_buf;\r\nfor (i = 0; i < Adapter->ulTotalTargetBuffersAvailable; i++) {\r\ncurr_buf = &Adapter->astTargetDsxBuffer[i];\r\nif (curr_buf->valid)\r\ncontinue;\r\nif ((bFreeAll) || (curr_buf->tid == TID)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\r\n"ClearTargetDSXBuffer: found tid %d buffer cleared %lx\n",\r\nTID, curr_buf->ulTargetDsxBuffer);\r\ncurr_buf->valid = 1;\r\ncurr_buf->tid = 0;\r\nAdapter->ulFreeTargetBufferCnt++;\r\n}\r\n}\r\n}\r\nstatic inline VOID CopyClassifierRuleToSF(struct bcm_mini_adapter *Adapter,\r\nstruct bcm_convergence_types *psfCSType,\r\nUINT uiSearchRuleIndex,\r\nUINT nClassifierIndex)\r\n{\r\nstruct bcm_classifier_rule *pstClassifierEntry = NULL;\r\nint i;\r\nstruct bcm_packet_class_rules *pack_class_rule =\r\n&psfCSType->cCPacketClassificationRule;\r\nif (Adapter->PackInfo[uiSearchRuleIndex].usVCID_Value == 0 ||\r\nnClassifierIndex > (MAX_CLASSIFIERS-1))\r\nreturn;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Storing Classifier Rule Index : %X",\r\nntohs(pack_class_rule->u16PacketClassificationRuleIndex));\r\nif (nClassifierIndex > MAX_CLASSIFIERS-1)\r\nreturn;\r\npstClassifierEntry = &Adapter->astClassifierTable[nClassifierIndex];\r\nif (pstClassifierEntry) {\r\npstClassifierEntry->bIpv6Protocol =\r\n(Adapter->PackInfo[uiSearchRuleIndex].ucIpVersion == IPV6) ? TRUE : false;\r\npstClassifierEntry->ucDestPortRangeLength =\r\npack_class_rule->u8ProtocolDestPortRangeLength / 4;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Destination Port Range Length:0x%X ",\r\npstClassifierEntry->ucDestPortRangeLength);\r\nif (pack_class_rule->u8ProtocolDestPortRangeLength <= MAX_PORT_RANGE) {\r\nfor (i = 0; i < (pstClassifierEntry->ucDestPortRangeLength); i++) {\r\npstClassifierEntry->usDestPortRangeLo[i] =\r\n*((PUSHORT)(pack_class_rule->u8ProtocolDestPortRange+i));\r\npstClassifierEntry->usDestPortRangeHi[i] =\r\n*((PUSHORT)(pack_class_rule->u8ProtocolDestPortRange+2+i));\r\npstClassifierEntry->usDestPortRangeLo[i] =\r\nntohs(pstClassifierEntry->usDestPortRangeLo[i]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nCONN_MSG, DBG_LVL_ALL,\r\n"Destination Port Range Lo:0x%X ",\r\npstClassifierEntry->usDestPortRangeLo[i]);\r\npstClassifierEntry->usDestPortRangeHi[i] =\r\nntohs(pstClassifierEntry->usDestPortRangeHi[i]);\r\n}\r\n} else {\r\npstClassifierEntry->ucDestPortRangeLength = 0;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Source Port Range Length:0x%X ",\r\npack_class_rule->u8ProtocolSourcePortRangeLength);\r\nif (pack_class_rule->u8ProtocolSourcePortRangeLength <= MAX_PORT_RANGE) {\r\npstClassifierEntry->ucSrcPortRangeLength =\r\npack_class_rule->u8ProtocolSourcePortRangeLength/4;\r\nfor (i = 0; i < (pstClassifierEntry->ucSrcPortRangeLength); i++) {\r\npstClassifierEntry->usSrcPortRangeLo[i] =\r\n*((PUSHORT)(pack_class_rule->\r\nu8ProtocolSourcePortRange+i));\r\npstClassifierEntry->usSrcPortRangeHi[i] =\r\n*((PUSHORT)(pack_class_rule->\r\nu8ProtocolSourcePortRange+2+i));\r\npstClassifierEntry->usSrcPortRangeLo[i] =\r\nntohs(pstClassifierEntry->usSrcPortRangeLo[i]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nCONN_MSG, DBG_LVL_ALL,\r\n"Source Port Range Lo:0x%X ",\r\npstClassifierEntry->usSrcPortRangeLo[i]);\r\npstClassifierEntry->usSrcPortRangeHi[i] =\r\nntohs(pstClassifierEntry->usSrcPortRangeHi[i]);\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Ip Destination Parameters : ");\r\nCopyIpAddrToClassifier(pstClassifierEntry,\r\npack_class_rule->u8IPDestinationAddressLength,\r\npack_class_rule->u8IPDestinationAddress,\r\n(Adapter->PackInfo[uiSearchRuleIndex].ucIpVersion == IPV6) ?\r\nTRUE : false, eDestIpAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Ip Source Parameters : ");\r\nCopyIpAddrToClassifier(pstClassifierEntry,\r\npack_class_rule->u8IPMaskedSourceAddressLength,\r\npack_class_rule->u8IPMaskedSourceAddress,\r\n(Adapter->PackInfo[uiSearchRuleIndex].ucIpVersion == IPV6) ? TRUE : false,\r\neSrcIpAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"TOS Length:0x%X ",\r\npack_class_rule->u8IPTypeOfServiceLength);\r\nif (pack_class_rule->u8IPTypeOfServiceLength == 3) {\r\npstClassifierEntry->ucIPTypeOfServiceLength =\r\npack_class_rule->u8IPTypeOfServiceLength;\r\npstClassifierEntry->ucTosLow =\r\npack_class_rule->u8IPTypeOfService[0];\r\npstClassifierEntry->ucTosHigh =\r\npack_class_rule->u8IPTypeOfService[1];\r\npstClassifierEntry->ucTosMask =\r\npack_class_rule->u8IPTypeOfService[2];\r\npstClassifierEntry->bTOSValid = TRUE;\r\n}\r\nif (pack_class_rule->u8Protocol == 0) {\r\npstClassifierEntry->ucProtocolLength = 0;\r\n} else {\r\npstClassifierEntry->ucProtocolLength = 1;\r\n}\r\npstClassifierEntry->ucProtocol[0] = pack_class_rule->u8Protocol;\r\npstClassifierEntry->u8ClassifierRulePriority =\r\npack_class_rule->u8ClassifierRulePriority;\r\npstClassifierEntry->ucDirection =\r\nAdapter->PackInfo[uiSearchRuleIndex].ucDirection;\r\npstClassifierEntry->uiClassifierRuleIndex =\r\nntohs(pack_class_rule->u16PacketClassificationRuleIndex);\r\npstClassifierEntry->usVCID_Value =\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value;\r\npstClassifierEntry->ulSFID =\r\nAdapter->PackInfo[uiSearchRuleIndex].ulSFID;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Search Index %d Dir: %d, Index: %d, Vcid: %d\n",\r\nuiSearchRuleIndex,\r\npstClassifierEntry->ucDirection,\r\npstClassifierEntry->uiClassifierRuleIndex,\r\npstClassifierEntry->usVCID_Value);\r\nif (pack_class_rule->u8AssociatedPHSI)\r\npstClassifierEntry->u8AssociatedPHSI =\r\npack_class_rule->u8AssociatedPHSI;\r\npstClassifierEntry->ucEthCSSrcMACLen =\r\n(pack_class_rule->u8EthernetSourceMACAddressLength);\r\nmemcpy(pstClassifierEntry->au8EThCSSrcMAC,\r\npack_class_rule->u8EthernetSourceMACAddress,\r\nMAC_ADDRESS_SIZE);\r\nmemcpy(pstClassifierEntry->au8EThCSSrcMACMask,\r\npack_class_rule->u8EthernetSourceMACAddress\r\n+ MAC_ADDRESS_SIZE, MAC_ADDRESS_SIZE);\r\npstClassifierEntry->ucEthCSDestMACLen =\r\n(pack_class_rule->u8EthernetDestMacAddressLength);\r\nmemcpy(pstClassifierEntry->au8EThCSDestMAC,\r\npack_class_rule->u8EthernetDestMacAddress,\r\nMAC_ADDRESS_SIZE);\r\nmemcpy(pstClassifierEntry->au8EThCSDestMACMask,\r\npack_class_rule->u8EthernetDestMacAddress\r\n+ MAC_ADDRESS_SIZE, MAC_ADDRESS_SIZE);\r\npstClassifierEntry->ucEtherTypeLen =\r\n(pack_class_rule->u8EthertypeLength);\r\nmemcpy(pstClassifierEntry->au8EthCSEtherType,\r\npack_class_rule->u8Ethertype,\r\nNUM_ETHERTYPE_BYTES);\r\nmemcpy(pstClassifierEntry->usUserPriority,\r\n&pack_class_rule->u16UserPriority, 2);\r\npstClassifierEntry->usVLANID =\r\nntohs(pack_class_rule->u16VLANID);\r\npstClassifierEntry->usValidityBitMap =\r\nntohs(pack_class_rule->u16ValidityBitMap);\r\npstClassifierEntry->bUsed = TRUE;\r\n}\r\n}\r\nstatic inline VOID DeleteClassifierRuleFromSF(struct bcm_mini_adapter *Adapter,\r\nUINT uiSearchRuleIndex, UINT nClassifierIndex)\r\n{\r\nstruct bcm_classifier_rule *pstClassifierEntry = NULL;\r\nB_UINT16 u16PacketClassificationRuleIndex;\r\nUSHORT usVCID;\r\nusVCID = Adapter->PackInfo[uiSearchRuleIndex].usVCID_Value;\r\nif (nClassifierIndex > MAX_CLASSIFIERS-1)\r\nreturn;\r\nif (usVCID == 0)\r\nreturn;\r\nu16PacketClassificationRuleIndex =\r\nAdapter->astClassifierTable[nClassifierIndex].uiClassifierRuleIndex;\r\npstClassifierEntry = &Adapter->astClassifierTable[nClassifierIndex];\r\nif (pstClassifierEntry) {\r\npstClassifierEntry->bUsed = false;\r\npstClassifierEntry->uiClassifierRuleIndex = 0;\r\nmemset(pstClassifierEntry, 0,\r\nsizeof(struct bcm_classifier_rule));\r\nPhsDeleteClassifierRule(&Adapter->stBCMPhsContext, usVCID,\r\nu16PacketClassificationRuleIndex);\r\n}\r\n}\r\nVOID DeleteAllClassifiersForSF(struct bcm_mini_adapter *Adapter,\r\nUINT uiSearchRuleIndex)\r\n{\r\nstruct bcm_classifier_rule *pstClassifierEntry = NULL;\r\nint i;\r\nUSHORT ulVCID;\r\nulVCID = Adapter->PackInfo[uiSearchRuleIndex].usVCID_Value;\r\nif (ulVCID == 0)\r\nreturn;\r\nfor (i = 0; i < MAX_CLASSIFIERS; i++) {\r\nif (Adapter->astClassifierTable[i].usVCID_Value == ulVCID) {\r\npstClassifierEntry = &Adapter->astClassifierTable[i];\r\nif (pstClassifierEntry->bUsed)\r\nDeleteClassifierRuleFromSF(Adapter,\r\nuiSearchRuleIndex, i);\r\n}\r\n}\r\nPhsDeleteSFRules(&Adapter->stBCMPhsContext, ulVCID);\r\n}\r\nstatic VOID CopyToAdapter(register struct bcm_mini_adapter *Adapter,\r\nregister struct bcm_connect_mgr_params *psfLocalSet,\r\nregister UINT uiSearchRuleIndex,\r\nregister UCHAR ucDsxType,\r\nstruct bcm_add_indication_alt *pstAddIndication) {\r\nULONG ulSFID;\r\nUINT nClassifierIndex = 0;\r\nenum E_CLASSIFIER_ACTION eClassifierAction = eInvalidClassifierAction;\r\nB_UINT16 u16PacketClassificationRuleIndex = 0;\r\nint i;\r\nstruct bcm_convergence_types *psfCSType = NULL;\r\nstruct bcm_phs_rule sPhsRule;\r\nstruct bcm_packet_info *curr_packinfo =\r\n&Adapter->PackInfo[uiSearchRuleIndex];\r\nUSHORT uVCID = curr_packinfo->usVCID_Value;\r\nUINT UGIValue = 0;\r\ncurr_packinfo->bValid = TRUE;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Search Rule Index = %d\n", uiSearchRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"%s: SFID= %x ", __func__, ntohl(psfLocalSet->u32SFID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Updating Queue %d", uiSearchRuleIndex);\r\nulSFID = ntohl(psfLocalSet->u32SFID);\r\ncurr_packinfo->bIPCSSupport = 0;\r\ncurr_packinfo->bEthCSSupport = 0;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"CopyToAdapter : u8CSSpecification : %X\n",\r\npsfLocalSet->u8CSSpecification);\r\nswitch (psfLocalSet->u8CSSpecification) {\r\ncase eCSPacketIPV4:\r\ncurr_packinfo->bIPCSSupport = IPV4_CS;\r\nbreak;\r\ncase eCSPacketIPV6:\r\ncurr_packinfo->bIPCSSupport = IPV6_CS;\r\nbreak;\r\ncase eCS802_3PacketEthernet:\r\ncase eCS802_1QPacketVLAN:\r\ncurr_packinfo->bEthCSSupport = ETH_CS_802_3;\r\nbreak;\r\ncase eCSPacketIPV4Over802_1QVLAN:\r\ncase eCSPacketIPV4Over802_3Ethernet:\r\ncurr_packinfo->bIPCSSupport = IPV4_CS;\r\ncurr_packinfo->bEthCSSupport = ETH_CS_802_3;\r\nbreak;\r\ncase eCSPacketIPV6Over802_1QVLAN:\r\ncase eCSPacketIPV6Over802_3Ethernet:\r\ncurr_packinfo->bIPCSSupport = IPV6_CS;\r\ncurr_packinfo->bEthCSSupport = ETH_CS_802_3;\r\nbreak;\r\ndefault:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Error in value of CS Classification.. setting default to IP CS\n");\r\ncurr_packinfo->bIPCSSupport = IPV4_CS;\r\nbreak;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"CopyToAdapter : Queue No : %X ETH CS Support : %X , IP CS Support : %X\n",\r\nuiSearchRuleIndex,\r\ncurr_packinfo->bEthCSSupport,\r\ncurr_packinfo->bIPCSSupport);\r\nif (curr_packinfo->bIPCSSupport == IPV6_CS)\r\ncurr_packinfo->ucIpVersion = IPV6;\r\nelse\r\ncurr_packinfo->ucIpVersion = IPV4;\r\nif (!Adapter->bETHCSEnabled)\r\ncurr_packinfo->bEthCSSupport = 0;\r\nif (psfLocalSet->u8ServiceClassNameLength > 0 && psfLocalSet->u8ServiceClassNameLength < 32)\r\nmemcpy(curr_packinfo->ucServiceClassName,\r\npsfLocalSet->u8ServiceClassName,\r\npsfLocalSet->u8ServiceClassNameLength);\r\ncurr_packinfo->u8QueueType = psfLocalSet->u8ServiceFlowSchedulingType;\r\nif (curr_packinfo->u8QueueType == BE && curr_packinfo->ucDirection)\r\nAdapter->usBestEffortQueueIndex = uiSearchRuleIndex;\r\ncurr_packinfo->ulSFID = ntohl(psfLocalSet->u32SFID);\r\ncurr_packinfo->u8TrafficPriority = psfLocalSet->u8TrafficPriority;\r\nfor (i = 0; i < psfLocalSet->u8TotalClassifiers; i++) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Classifier index =%d", i);\r\npsfCSType = &psfLocalSet->cConvergenceSLTypes[i];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Classifier index =%d", i);\r\nif (psfCSType->cCPacketClassificationRule.u8ClassifierRulePriority)\r\ncurr_packinfo->bClassifierPriority = TRUE;\r\nif (psfCSType->cCPacketClassificationRule.u8ClassifierRulePriority)\r\ncurr_packinfo->bClassifierPriority = TRUE;\r\nif (ucDsxType == DSA_ACK) {\r\neClassifierAction = eAddClassifier;\r\n} else if (ucDsxType == DSC_ACK) {\r\nswitch (psfCSType->u8ClassfierDSCAction) {\r\ncase 0:\r\neClassifierAction = eAddClassifier;\r\nbreak;\r\ncase 1:\r\neClassifierAction = eReplaceClassifier;\r\nbreak;\r\ncase 2:\r\neClassifierAction = eDeleteClassifier;\r\nbreak;\r\ndefault:\r\neClassifierAction = eInvalidClassifierAction;\r\n}\r\n}\r\nu16PacketClassificationRuleIndex = ntohs(psfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex);\r\nswitch (eClassifierAction) {\r\ncase eAddClassifier:\r\nnClassifierIndex = SearchClsid(Adapter,\r\nulSFID,\r\nu16PacketClassificationRuleIndex);\r\nif (nClassifierIndex > MAX_CLASSIFIERS) {\r\nnClassifierIndex = SearchFreeClsid(Adapter);\r\nif (nClassifierIndex > MAX_CLASSIFIERS) {\r\nBCM_DEBUG_PRINT(Adapter,\r\nDBG_TYPE_OTHERS,\r\nCONN_MSG,\r\nDBG_LVL_ALL,\r\n"Error Failed To get a free Classifier Entry");\r\nbreak;\r\n}\r\nCopyClassifierRuleToSF(Adapter, psfCSType,\r\nuiSearchRuleIndex,\r\nnClassifierIndex);\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nCONN_MSG,\r\nDBG_LVL_ALL,\r\n"CopyToAdapter: Error The Specified Classifier Already Exists and attempted To Add Classifier with Same PCRI : 0x%x\n",\r\nu16PacketClassificationRuleIndex);\r\n}\r\nbreak;\r\ncase eReplaceClassifier:\r\nnClassifierIndex = SearchClsid(Adapter, ulSFID,\r\nu16PacketClassificationRuleIndex);\r\nif (nClassifierIndex > MAX_CLASSIFIERS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nCONN_MSG, DBG_LVL_ALL,\r\n"Error Search for Classifier To be replaced failed");\r\nbreak;\r\n}\r\nCopyClassifierRuleToSF(Adapter, psfCSType,\r\nuiSearchRuleIndex, nClassifierIndex);\r\nbreak;\r\ncase eDeleteClassifier:\r\nnClassifierIndex = SearchClsid(Adapter, ulSFID,\r\nu16PacketClassificationRuleIndex);\r\nif (nClassifierIndex > MAX_CLASSIFIERS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nCONN_MSG, DBG_LVL_ALL,\r\n"Error Search for Classifier To be deleted failed");\r\nbreak;\r\n}\r\nDeleteClassifierRuleFromSF(Adapter, uiSearchRuleIndex,\r\nnClassifierIndex);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < psfLocalSet->u8TotalClassifiers; i++) {\r\npsfCSType = &psfLocalSet->cConvergenceSLTypes[i];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"psfCSType->u8PhsDSCAction : 0x%x\n",\r\npsfCSType->u8PhsDSCAction);\r\nswitch (psfCSType->u8PhsDSCAction) {\r\ncase eDeleteAllPHSRules:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG,\r\nDBG_LVL_ALL,\r\n"Deleting All PHS Rules For VCID: 0x%X\n",\r\nuVCID);\r\nPhsDeleteSFRules(&Adapter->stBCMPhsContext, uVCID);\r\nbreak;\r\ncase eDeletePHSRule:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG,\r\nDBG_LVL_ALL,\r\n"PHS DSC Action = Delete PHS Rule\n");\r\nif (psfCSType->cPhsRule.u8PHSI)\r\nPhsDeletePHSRule(&Adapter->stBCMPhsContext,\r\nuVCID,\r\npsfCSType->cCPacketClassificationRule.u8AssociatedPHSI);\r\nbreak;\r\ndefault:\r\nif (ucDsxType == DSC_ACK) {\r\nbreak;\r\n}\r\ncase eAddPHSRule:\r\ncase eSetPHSRule:\r\nif (psfCSType->cPhsRule.u8PHSI) {\r\napply_phs_rule_to_all_classifiers(Adapter,\r\nuiSearchRuleIndex,\r\nuVCID,\r\n&sPhsRule,\r\n&psfCSType->cPhsRule,\r\npstAddIndication);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (psfLocalSet->u32MaxSustainedTrafficRate == 0) {\r\ncurr_packinfo->uiMaxAllowedRate = WIMAX_MAX_ALLOWED_RATE;\r\n} else if (ntohl(psfLocalSet->u32MaxSustainedTrafficRate) > WIMAX_MAX_ALLOWED_RATE) {\r\ncurr_packinfo->uiMaxAllowedRate = WIMAX_MAX_ALLOWED_RATE;\r\n} else {\r\ncurr_packinfo->uiMaxAllowedRate =\r\nntohl(psfLocalSet->u32MaxSustainedTrafficRate);\r\n}\r\ncurr_packinfo->uiMaxLatency = ntohl(psfLocalSet->u32MaximumLatency);\r\nif (curr_packinfo->uiMaxLatency == 0)\r\ncurr_packinfo->uiMaxLatency = MAX_LATENCY_ALLOWED;\r\nif ((curr_packinfo->u8QueueType == ERTPS ||\r\ncurr_packinfo->u8QueueType == UGS))\r\nUGIValue = ntohs(psfLocalSet->u16UnsolicitedGrantInterval);\r\nif (UGIValue == 0)\r\nUGIValue = DEFAULT_UG_INTERVAL;\r\ncurr_packinfo->uiMaxBucketSize =\r\n(DEFAULT_UGI_FACTOR*curr_packinfo->uiMaxAllowedRate*UGIValue)/1000;\r\nif (curr_packinfo->uiMaxBucketSize < WIMAX_MAX_MTU*8) {\r\nUINT UGIFactor = 0;\r\nUGIFactor = (curr_packinfo->uiMaxLatency/UGIValue + 1);\r\nif (UGIFactor > DEFAULT_UGI_FACTOR)\r\ncurr_packinfo->uiMaxBucketSize =\r\n(UGIFactor*curr_packinfo->uiMaxAllowedRate*UGIValue)/1000;\r\nif (curr_packinfo->uiMaxBucketSize > WIMAX_MAX_MTU*8)\r\ncurr_packinfo->uiMaxBucketSize = WIMAX_MAX_MTU*8;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"LAT: %d, UGI: %d\n", curr_packinfo->uiMaxLatency,\r\nUGIValue);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"uiMaxAllowedRate: 0x%x, u32MaxSustainedTrafficRate: 0x%x ,uiMaxBucketSize: 0x%x",\r\ncurr_packinfo->uiMaxAllowedRate,\r\nntohl(psfLocalSet->u32MaxSustainedTrafficRate),\r\ncurr_packinfo->uiMaxBucketSize);\r\nCopyMIBSExtendedSFParameters(Adapter, psfLocalSet, uiSearchRuleIndex);\r\ncurr_packinfo->bHeaderSuppressionEnabled =\r\n!(psfLocalSet->u8RequesttransmissionPolicy &\r\nMASK_DISABLE_HEADER_SUPPRESSION);\r\nkfree(curr_packinfo->pstSFIndication);\r\ncurr_packinfo->pstSFIndication = pstAddIndication;\r\nSortPackInfo(Adapter);\r\nSortClassifiers(Adapter);\r\nDumpPhsRules(&Adapter->stBCMPhsContext);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"%s <=====", __func__);\r\n}\r\nstatic VOID DumpCmControlPacket(PVOID pvBuffer)\r\n{\r\nint uiLoopIndex;\r\nint nIndex;\r\nstruct bcm_add_indication_alt *pstAddIndication;\r\nUINT nCurClassifierCnt;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\npstAddIndication = pvBuffer;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "======>");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Type: 0x%X", pstAddIndication->u8Type);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Direction: 0x%X", pstAddIndication->u8Direction);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TID: 0x%X", ntohs(pstAddIndication->u16TID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16CID: 0x%X", ntohs(pstAddIndication->u16CID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16VCID: 0x%X", ntohs(pstAddIndication->u16VCID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " AuthorizedSet--->");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32SFID: 0x%X", htonl(pstAddIndication->sfAuthorizedSet.u32SFID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16CID: 0x%X", htons(pstAddIndication->sfAuthorizedSet.u16CID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceClassNameLength: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassNameLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceClassName: 0x%X ,0x%X , 0x%X, 0x%X, 0x%X, 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[0],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[1],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[2],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[3],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[4],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[5]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8MBSService: 0x%X", pstAddIndication->sfAuthorizedSet.u8MBSService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8QosParamSet: 0x%X", pstAddIndication->sfAuthorizedSet.u8QosParamSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficPriority: 0x%X, %p",\r\npstAddIndication->sfAuthorizedSet.u8TrafficPriority, &pstAddIndication->sfAuthorizedSet.u8TrafficPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaxSustainedTrafficRate: 0x%X 0x%p",\r\npstAddIndication->sfAuthorizedSet.u32MaxSustainedTrafficRate,\r\n&pstAddIndication->sfAuthorizedSet.u32MaxSustainedTrafficRate);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaxTrafficBurst: 0x%X", pstAddIndication->sfAuthorizedSet.u32MaxTrafficBurst);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MinReservedTrafficRate : 0x%X",\r\npstAddIndication->sfAuthorizedSet.u32MinReservedTrafficRate);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParamLength: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8VendorSpecificQoSParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParam: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8VendorSpecificQoSParam[0]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceFlowSchedulingType: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8ServiceFlowSchedulingType);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32ToleratedJitter: 0x%X", pstAddIndication->sfAuthorizedSet.u32ToleratedJitter);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaximumLatency: 0x%X", pstAddIndication->sfAuthorizedSet.u32MaximumLatency);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8FixedLengthVSVariableLengthSDUIndicator: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8FixedLengthVSVariableLengthSDUIndicator);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8SDUSize: 0x%X", pstAddIndication->sfAuthorizedSet.u8SDUSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TargetSAID: 0x%X", pstAddIndication->sfAuthorizedSet.u16TargetSAID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ARQEnable: 0x%X", pstAddIndication->sfAuthorizedSet.u8ARQEnable);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQWindowSize: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQWindowSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRetryTxTimeOut: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQRetryTxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRetryRxTimeOut: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQRetryRxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQBlockLifeTime: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQBlockLifeTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQSyncLossTimeOut: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQSyncLossTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ARQDeliverInOrder: 0x%X", pstAddIndication->sfAuthorizedSet.u8ARQDeliverInOrder);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRxPurgeTimeOut: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQRxPurgeTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQBlockSize: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQBlockSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8CSSpecification: 0x%X", pstAddIndication->sfAuthorizedSet.u8CSSpecification);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TypeOfDataDeliveryService: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8TypeOfDataDeliveryService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16SDUInterArrivalTime: 0x%X", pstAddIndication->sfAuthorizedSet.u16SDUInterArrivalTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TimeBase: 0x%X", pstAddIndication->sfAuthorizedSet.u16TimeBase);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8PagingPreference: 0x%X", pstAddIndication->sfAuthorizedSet.u8PagingPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16UnsolicitedPollingInterval: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u16UnsolicitedPollingInterval);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "sfAuthorizedSet.u8HARQChannelMapping %x %x %x ",\r\n*(unsigned int *)pstAddIndication->sfAuthorizedSet.u8HARQChannelMapping,\r\n*(unsigned int *)&pstAddIndication->sfAuthorizedSet.u8HARQChannelMapping[4],\r\n*(USHORT *)&pstAddIndication->sfAuthorizedSet.u8HARQChannelMapping[8]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficIndicationPreference: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8TrafficIndicationPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " Total Classifiers Received: 0x%X", pstAddIndication->sfAuthorizedSet.u8TotalClassifiers);\r\nnCurClassifierCnt = pstAddIndication->sfAuthorizedSet.u8TotalClassifiers;\r\nif (nCurClassifierCnt > MAX_CLASSIFIERS_IN_SF)\r\nnCurClassifierCnt = MAX_CLASSIFIERS_IN_SF;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "pstAddIndication->sfAuthorizedSet.bValid %d", pstAddIndication->sfAuthorizedSet.bValid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "pstAddIndication->sfAuthorizedSet.u16MacOverhead %x", pstAddIndication->sfAuthorizedSet.u16MacOverhead);\r\nif (!pstAddIndication->sfAuthorizedSet.bValid)\r\npstAddIndication->sfAuthorizedSet.bValid = 1;\r\nfor (nIndex = 0; nIndex < nCurClassifierCnt; nIndex++) {\r\nstruct bcm_convergence_types *psfCSType = NULL;\r\npsfCSType = &pstAddIndication->sfAuthorizedSet.cConvergenceSLTypes[nIndex];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "psfCSType = %p", psfCSType);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "CCPacketClassificationRuleSI====>");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ClassifierRulePriority: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ClassifierRulePriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPTypeOfServiceLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfServiceLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPTypeOfService[3]: 0x%X ,0x%X ,0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[0],\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[1],\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[2]);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 1; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Protocol: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8Protocol);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddressLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddress[32]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddressLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddress[32]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolSourcePortRangeLength:0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolSourcePortRange[4]: 0x%02X ,0x%02X ,0x%02X ,0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[0],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[1],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[2],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[3]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolDestPortRangeLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolDestPortRange[4]: 0x%02X ,0x%02X ,0x%02X ,0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[0],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[1],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[2],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[3]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetDestMacAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8EthernetDestMacAddress[6]: %pM",\r\npsfCSType->cCPacketClassificationRule.\r\nu8EthernetDestMacAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetSourceMACAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8EthernetSourceMACAddress[6]: %pM",\r\npsfCSType->cCPacketClassificationRule.\r\nu8EthernetSourceMACAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthertypeLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthertypeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Ethertype[3]: 0x%02X ,0x%02X ,0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[0],\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[1],\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[2]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16UserPriority: 0x%X ", psfCSType->cCPacketClassificationRule.u16UserPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16VLANID: 0x%X ", psfCSType->cCPacketClassificationRule.u16VLANID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8AssociatedPHSI: 0x%02X ", psfCSType->cCPacketClassificationRule.u8AssociatedPHSI);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16PacketClassificationRuleIndex: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificClassifierParamLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificClassifierParam[1]: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParam[0]);\r\n#ifdef VERSION_D5\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPv6FlowLableLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLableLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8IPv6FlowLable[6]: 0x%*ph ",\r\n6, psfCSType->cCPacketClassificationRule.\r\nu8IPv6FlowLable);\r\n#endif\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "bValid: 0x%02X", pstAddIndication->sfAuthorizedSet.bValid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "AdmittedSet--->");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32SFID: 0x%X", pstAddIndication->sfAdmittedSet.u32SFID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16CID: 0x%X", pstAddIndication->sfAdmittedSet.u16CID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceClassNameLength: 0x%X",\r\npstAddIndication->sfAdmittedSet.u8ServiceClassNameLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,\r\n"u8ServiceClassName: 0x%*ph",\r\n6, pstAddIndication->sfAdmittedSet.u8ServiceClassName);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8MBSService: 0x%02X", pstAddIndication->sfAdmittedSet.u8MBSService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8QosParamSet: 0x%02X", pstAddIndication->sfAdmittedSet.u8QosParamSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficPriority: 0x%02X", pstAddIndication->sfAdmittedSet.u8TrafficPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaxTrafficBurst: 0x%X", pstAddIndication->sfAdmittedSet.u32MaxTrafficBurst);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MinReservedTrafficRate: 0x%X",\r\npstAddIndication->sfAdmittedSet.u32MinReservedTrafficRate);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParamLength: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8VendorSpecificQoSParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParam: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8VendorSpecificQoSParam[0]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceFlowSchedulingType: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8ServiceFlowSchedulingType);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32ToleratedJitter: 0x%X", pstAddIndication->sfAdmittedSet.u32ToleratedJitter);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaximumLatency: 0x%X", pstAddIndication->sfAdmittedSet.u32MaximumLatency);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8FixedLengthVSVariableLengthSDUIndicator: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8FixedLengthVSVariableLengthSDUIndicator);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8SDUSize: 0x%02X", pstAddIndication->sfAdmittedSet.u8SDUSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TargetSAID: 0x%02X", pstAddIndication->sfAdmittedSet.u16TargetSAID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ARQEnable: 0x%02X", pstAddIndication->sfAdmittedSet.u8ARQEnable);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQWindowSize: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQWindowSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRetryTxTimeOut: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQRetryTxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRetryRxTimeOut: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQRetryRxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQBlockLifeTime: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQBlockLifeTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQSyncLossTimeOut: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQSyncLossTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ARQDeliverInOrder: 0x%02X", pstAddIndication->sfAdmittedSet.u8ARQDeliverInOrder);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRxPurgeTimeOut: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQRxPurgeTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQBlockSize: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQBlockSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8CSSpecification: 0x%02X", pstAddIndication->sfAdmittedSet.u8CSSpecification);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TypeOfDataDeliveryService: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8TypeOfDataDeliveryService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16SDUInterArrivalTime: 0x%X", pstAddIndication->sfAdmittedSet.u16SDUInterArrivalTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TimeBase: 0x%X", pstAddIndication->sfAdmittedSet.u16TimeBase);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8PagingPreference: 0x%X", pstAddIndication->sfAdmittedSet.u8PagingPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficIndicationPreference: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8TrafficIndicationPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " Total Classifiers Received: 0x%X", pstAddIndication->sfAdmittedSet.u8TotalClassifiers);\r\nnCurClassifierCnt = pstAddIndication->sfAdmittedSet.u8TotalClassifiers;\r\nif (nCurClassifierCnt > MAX_CLASSIFIERS_IN_SF)\r\nnCurClassifierCnt = MAX_CLASSIFIERS_IN_SF;\r\nfor (nIndex = 0; nIndex < nCurClassifierCnt; nIndex++) {\r\nstruct bcm_convergence_types *psfCSType = NULL;\r\npsfCSType = &pstAddIndication->sfAdmittedSet.cConvergenceSLTypes[nIndex];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " CCPacketClassificationRuleSI====>");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ClassifierRulePriority: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ClassifierRulePriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPTypeOfServiceLength: 0x%02X",\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfServiceLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8IPTypeOfService[3]: 0x%*ph",\r\n3, psfCSType->cCPacketClassificationRule.\r\nu8IPTypeOfService);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 1; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Protocol: 0x%02X ", psfCSType->cCPacketClassificationRule.u8Protocol);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddress[32]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddress[32]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolSourcePortRangeLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8ProtocolSourcePortRange[4]: 0x%*ph ",\r\n4, psfCSType->cCPacketClassificationRule.\r\nu8ProtocolSourcePortRange);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolDestPortRangeLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8ProtocolDestPortRange[4]: 0x%*ph ",\r\n4, psfCSType->cCPacketClassificationRule.\r\nu8ProtocolDestPortRange);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetDestMacAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8EthernetDestMacAddress[6]: %pM",\r\npsfCSType->cCPacketClassificationRule.\r\nu8EthernetDestMacAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetSourceMACAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8EthernetSourceMACAddress[6]: %pM",\r\npsfCSType->cCPacketClassificationRule.\r\nu8EthernetSourceMACAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthertypeLength: 0x%02X ", psfCSType->cCPacketClassificationRule.u8EthertypeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8Ethertype[3]: 0x%*ph",\r\n3, psfCSType->cCPacketClassificationRule.\r\nu8Ethertype);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16UserPriority: 0x%X ", psfCSType->cCPacketClassificationRule.u16UserPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16VLANID: 0x%X ", psfCSType->cCPacketClassificationRule.u16VLANID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8AssociatedPHSI: 0x%02X ", psfCSType->cCPacketClassificationRule.u8AssociatedPHSI);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16PacketClassificationRuleIndex: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificClassifierParamLength: 0x%02X",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificClassifierParam[1]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParam[0]);\r\n#ifdef VERSION_D5\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPv6FlowLableLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLableLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8IPv6FlowLable[6]: 0x%*ph ",\r\n6, psfCSType->cCPacketClassificationRule.\r\nu8IPv6FlowLable);\r\n#endif\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "bValid: 0x%X", pstAddIndication->sfAdmittedSet.bValid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " ActiveSet--->");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32SFID: 0x%X", pstAddIndication->sfActiveSet.u32SFID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16CID: 0x%X", pstAddIndication->sfActiveSet.u16CID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceClassNameLength: 0x%X", pstAddIndication->sfActiveSet.u8ServiceClassNameLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,\r\n"u8ServiceClassName: 0x%*ph",\r\n6, pstAddIndication->sfActiveSet.u8ServiceClassName);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8MBSService: 0x%02X", pstAddIndication->sfActiveSet.u8MBSService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8QosParamSet: 0x%02X", pstAddIndication->sfActiveSet.u8QosParamSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficPriority: 0x%02X", pstAddIndication->sfActiveSet.u8TrafficPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaxTrafficBurst: 0x%X", pstAddIndication->sfActiveSet.u32MaxTrafficBurst);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MinReservedTrafficRate: 0x%X",\r\npstAddIndication->sfActiveSet.u32MinReservedTrafficRate);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParamLength: 0x%02X",\r\npstAddIndication->sfActiveSet.u8VendorSpecificQoSParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParam: 0x%02X",\r\npstAddIndication->sfActiveSet.u8VendorSpecificQoSParam[0]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceFlowSchedulingType: 0x%02X",\r\npstAddIndication->sfActiveSet.u8ServiceFlowSchedulingType);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32ToleratedJitter: 0x%X", pstAddIndication->sfActiveSet.u32ToleratedJitter);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaximumLatency: 0x%X", pstAddIndication->sfActiveSet.u32MaximumLatency);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8FixedLengthVSVariableLengthSDUIndicator: 0x%02X",\r\npstAddIndication->sfActiveSet.u8FixedLengthVSVariableLengthSDUIndicator);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8SDUSize: 0x%X", pstAddIndication->sfActiveSet.u8SDUSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16TargetSAID: 0x%X", pstAddIndication->sfActiveSet.u16TargetSAID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ARQEnable: 0x%X", pstAddIndication->sfActiveSet.u8ARQEnable);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQWindowSize: 0x%X", pstAddIndication->sfActiveSet.u16ARQWindowSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQRetryTxTimeOut: 0x%X", pstAddIndication->sfActiveSet.u16ARQRetryTxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQRetryRxTimeOut: 0x%X", pstAddIndication->sfActiveSet.u16ARQRetryRxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQBlockLifeTime: 0x%X", pstAddIndication->sfActiveSet.u16ARQBlockLifeTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQSyncLossTimeOut: 0x%X", pstAddIndication->sfActiveSet.u16ARQSyncLossTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ARQDeliverInOrder: 0x%X", pstAddIndication->sfActiveSet.u8ARQDeliverInOrder);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQRxPurgeTimeOut: 0x%X", pstAddIndication->sfActiveSet.u16ARQRxPurgeTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQBlockSize: 0x%X", pstAddIndication->sfActiveSet.u16ARQBlockSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8CSSpecification: 0x%X", pstAddIndication->sfActiveSet.u8CSSpecification);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8TypeOfDataDeliveryService: 0x%X",\r\npstAddIndication->sfActiveSet.u8TypeOfDataDeliveryService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16SDUInterArrivalTime: 0x%X", pstAddIndication->sfActiveSet.u16SDUInterArrivalTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16TimeBase: 0x%X", pstAddIndication->sfActiveSet.u16TimeBase);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8PagingPreference: 0x%X", pstAddIndication->sfActiveSet.u8PagingPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8TrafficIndicationPreference: 0x%X",\r\npstAddIndication->sfActiveSet.u8TrafficIndicationPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " Total Classifiers Received: 0x%X", pstAddIndication->sfActiveSet.u8TotalClassifiers);\r\nnCurClassifierCnt = pstAddIndication->sfActiveSet.u8TotalClassifiers;\r\nif (nCurClassifierCnt > MAX_CLASSIFIERS_IN_SF)\r\nnCurClassifierCnt = MAX_CLASSIFIERS_IN_SF;\r\nfor (nIndex = 0; nIndex < nCurClassifierCnt; nIndex++) {\r\nstruct bcm_convergence_types *psfCSType = NULL;\r\nstruct bcm_packet_class_rules *clsRule = NULL;\r\npsfCSType = &pstAddIndication->sfActiveSet.cConvergenceSLTypes[nIndex];\r\nclsRule = &psfCSType->cCPacketClassificationRule;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, " CCPacketClassificationRuleSI====>");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, " u8ClassifierRulePriority: 0x%X ",\r\nclsRule->u8ClassifierRulePriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, " u8IPTypeOfServiceLength: 0x%X ",\r\nclsRule->u8IPTypeOfServiceLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8IPTypeOfService[3]: 0x%X ,0x%X ,0x%X ",\r\nclsRule->u8IPTypeOfService[0],\r\nclsRule->u8IPTypeOfService[1],\r\nclsRule->u8IPTypeOfService[2]);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 1; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8Protocol: 0x%X ",\r\nclsRule->u8Protocol);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n"u8IPMaskedSourceAddressLength: 0x%X ",\r\nclsRule->u8IPMaskedSourceAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n"u8IPMaskedSourceAddress[32]: 0x%X ",\r\nclsRule->u8IPMaskedSourceAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n"u8IPDestinationAddressLength: 0x%02X ",\r\nclsRule->u8IPDestinationAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8IPDestinationAddress[32]:0x%X ",\r\nclsRule->u8IPDestinationAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8ProtocolSourcePortRangeLength: 0x%X ",\r\nclsRule->u8ProtocolSourcePortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8ProtocolSourcePortRange[4]: 0x%X ,0x%X ,0x%X ,0x%X ",\r\nclsRule->u8ProtocolSourcePortRange[0],\r\nclsRule->u8ProtocolSourcePortRange[1],\r\nclsRule->u8ProtocolSourcePortRange[2],\r\nclsRule->u8ProtocolSourcePortRange[3]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8ProtocolDestPortRangeLength: 0x%X ",\r\nclsRule->u8ProtocolDestPortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8ProtocolDestPortRange[4]: 0x%X ,0x%X ,0x%X ,0x%X ",\r\nclsRule->u8ProtocolDestPortRange[0],\r\nclsRule->u8ProtocolDestPortRange[1],\r\nclsRule->u8ProtocolDestPortRange[2],\r\nclsRule->u8ProtocolDestPortRange[3]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8EthernetDestMacAddressLength: 0x%X ",\r\nclsRule->u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8EthernetDestMacAddress[6]: 0x%X ,0x%X ,0x%X ,0x%X ,0x%X ,0x%X",\r\nclsRule->u8EthernetDestMacAddress[0],\r\nclsRule->u8EthernetDestMacAddress[1],\r\nclsRule->u8EthernetDestMacAddress[2],\r\nclsRule->u8EthernetDestMacAddress[3],\r\nclsRule->u8EthernetDestMacAddress[4],\r\nclsRule->u8EthernetDestMacAddress[5]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8EthernetSourceMACAddressLength: 0x%X ",\r\nclsRule->u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n"u8EthernetSourceMACAddress[6]: 0x%X ,0x%X ,0x%X ,0x%X ,0x%X ,0x%X",\r\nclsRule->u8EthernetSourceMACAddress[0],\r\nclsRule->u8EthernetSourceMACAddress[1],\r\nclsRule->u8EthernetSourceMACAddress[2],\r\nclsRule->u8EthernetSourceMACAddress[3],\r\nclsRule->u8EthernetSourceMACAddress[4],\r\nclsRule->u8EthernetSourceMACAddress[5]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, " u8EthertypeLength: 0x%X ",\r\nclsRule->u8EthertypeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8Ethertype[3]: 0x%X ,0x%X ,0x%X ",\r\nclsRule->u8Ethertype[0],\r\nclsRule->u8Ethertype[1],\r\nclsRule->u8Ethertype[2]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, " u16UserPriority: 0x%X ",\r\nclsRule->u16UserPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, " u16VLANID: 0x%X ",\r\nclsRule->u16VLANID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, " u8AssociatedPHSI: 0x%X ",\r\nclsRule->u8AssociatedPHSI);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u16PacketClassificationRuleIndex:0x%X ",\r\nclsRule->u16PacketClassificationRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8VendorSpecificClassifierParamLength:0x%X ",\r\nclsRule->u8VendorSpecificClassifierParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8VendorSpecificClassifierParam[1]:0x%X ",\r\nclsRule->u8VendorSpecificClassifierParam[0]);\r\n#ifdef VERSION_D5\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, " u8IPv6FlowLableLength: 0x%X ",\r\nclsRule->u8IPv6FlowLableLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL,\r\n" u8IPv6FlowLable[6]: 0x%X ,0x%X ,0x%X ,0x%X ,0x%X ,0x%X ",\r\nclsRule->u8IPv6FlowLable[0],\r\nclsRule->u8IPv6FlowLable[1],\r\nclsRule->u8IPv6FlowLable[2],\r\nclsRule->u8IPv6FlowLable[3],\r\nclsRule->u8IPv6FlowLable[4],\r\nclsRule->u8IPv6FlowLable[5]);\r\n#endif\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,\r\n" bValid: 0x%X", pstAddIndication->sfActiveSet.bValid);\r\n}\r\nstatic inline ULONG RestoreSFParam(struct bcm_mini_adapter *Adapter,\r\nULONG ulAddrSFParamSet, PUCHAR pucDestBuffer)\r\n{\r\nUINT nBytesToRead = sizeof(struct bcm_connect_mgr_params);\r\nif (ulAddrSFParamSet == 0 || NULL == pucDestBuffer) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Got Param address as 0!!");\r\nreturn 0;\r\n}\r\nulAddrSFParamSet = ntohl(ulAddrSFParamSet);\r\nif (rdm(Adapter, ulAddrSFParamSet, (PUCHAR)pucDestBuffer, nBytesToRead) < 0)\r\nreturn STATUS_FAILURE;\r\nreturn 1;\r\n}\r\nstatic ULONG StoreSFParam(struct bcm_mini_adapter *Adapter, PUCHAR pucSrcBuffer,\r\nULONG ulAddrSFParamSet)\r\n{\r\nUINT nBytesToWrite = sizeof(struct bcm_connect_mgr_params);\r\nint ret = 0;\r\nif (ulAddrSFParamSet == 0 || NULL == pucSrcBuffer)\r\nreturn 0;\r\nret = wrm(Adapter, ulAddrSFParamSet, (u8 *)pucSrcBuffer, nBytesToWrite);\r\nif (ret < 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"%s:%d WRM failed", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nreturn 1;\r\n}\r\nULONG StoreCmControlResponseMessage(struct bcm_mini_adapter *Adapter,\r\nPVOID pvBuffer, UINT *puBufferLength)\r\n{\r\nstruct bcm_add_indication_alt *pstAddIndicationAlt = NULL;\r\nstruct bcm_add_indication *pstAddIndication = NULL;\r\nstruct bcm_del_request *pstDeletionRequest;\r\nUINT uiSearchRuleIndex;\r\nULONG ulSFID;\r\npstAddIndicationAlt = pvBuffer;\r\nif (pstAddIndicationAlt->u8Type == DSD_REQ) {\r\npstDeletionRequest = pvBuffer;\r\nulSFID = ntohl(pstDeletionRequest->u32SFID);\r\nuiSearchRuleIndex = SearchSfid(Adapter, ulSFID);\r\nif (uiSearchRuleIndex < NO_OF_QUEUES) {\r\ndeleteSFBySfid(Adapter, uiSearchRuleIndex);\r\nAdapter->u32TotalDSD++;\r\n}\r\nreturn 1;\r\n}\r\nif ((pstAddIndicationAlt->u8Type == DSD_RSP) ||\r\n(pstAddIndicationAlt->u8Type == DSD_ACK)) {\r\nreturn 1;\r\n}\r\npstAddIndication = kmalloc(sizeof(struct bcm_add_indication),\r\nGFP_KERNEL);\r\nif (pstAddIndication == NULL)\r\nreturn 0;\r\npstAddIndication->psfAuthorizedSet = (struct bcm_connect_mgr_params *)\r\nGetNextTargetBufferLocation(Adapter,\r\npstAddIndicationAlt->u16TID);\r\nif (!pstAddIndication->psfAuthorizedSet) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\nif (StoreSFParam(Adapter, (PUCHAR)&pstAddIndicationAlt->sfAuthorizedSet,\r\n(ULONG)pstAddIndication->psfAuthorizedSet) != 1) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\npstAddIndication->psfAuthorizedSet =\r\n(struct bcm_connect_mgr_params *) ntohl(\r\n(ULONG)pstAddIndication->psfAuthorizedSet);\r\nif (pstAddIndicationAlt->u8Type == DSA_REQ) {\r\nstruct bcm_add_request AddRequest;\r\nAddRequest.u8Type = pstAddIndicationAlt->u8Type;\r\nAddRequest.eConnectionDir = pstAddIndicationAlt->u8Direction;\r\nAddRequest.u16TID = pstAddIndicationAlt->u16TID;\r\nAddRequest.u16CID = pstAddIndicationAlt->u16CID;\r\nAddRequest.u16VCID = pstAddIndicationAlt->u16VCID;\r\nAddRequest.psfParameterSet = pstAddIndication->psfAuthorizedSet;\r\n(*puBufferLength) = sizeof(struct bcm_add_request);\r\nmemcpy(pvBuffer, &AddRequest, sizeof(struct bcm_add_request));\r\nkfree(pstAddIndication);\r\nreturn 1;\r\n}\r\npstAddIndication->u8Type = pstAddIndicationAlt->u8Type;\r\npstAddIndication->eConnectionDir = pstAddIndicationAlt->u8Direction;\r\npstAddIndication->u16TID = pstAddIndicationAlt->u16TID;\r\npstAddIndication->u16CID = pstAddIndicationAlt->u16CID;\r\npstAddIndication->u16VCID = pstAddIndicationAlt->u16VCID;\r\npstAddIndication->u8CC = pstAddIndicationAlt->u8CC;\r\npstAddIndication->psfAdmittedSet = (struct bcm_connect_mgr_params *)\r\nGetNextTargetBufferLocation(Adapter,\r\npstAddIndicationAlt->u16TID);\r\nif (!pstAddIndication->psfAdmittedSet) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\nif (StoreSFParam(Adapter, (PUCHAR)&pstAddIndicationAlt->sfAdmittedSet,\r\n(ULONG)pstAddIndication->psfAdmittedSet) != 1) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\npstAddIndication->psfAdmittedSet =\r\n(struct bcm_connect_mgr_params *) ntohl(\r\n(ULONG) pstAddIndication->psfAdmittedSet);\r\npstAddIndication->psfActiveSet = (struct bcm_connect_mgr_params *)\r\nGetNextTargetBufferLocation(Adapter,\r\npstAddIndicationAlt->u16TID);\r\nif (!pstAddIndication->psfActiveSet) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\nif (StoreSFParam(Adapter, (PUCHAR)&pstAddIndicationAlt->sfActiveSet,\r\n(ULONG)pstAddIndication->psfActiveSet) != 1) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\npstAddIndication->psfActiveSet =\r\n(struct bcm_connect_mgr_params *) ntohl(\r\n(ULONG)pstAddIndication->psfActiveSet);\r\n(*puBufferLength) = sizeof(struct bcm_add_indication);\r\n*(struct bcm_add_indication *)pvBuffer = *pstAddIndication;\r\nkfree(pstAddIndication);\r\nreturn 1;\r\n}\r\nstatic inline struct bcm_add_indication_alt\r\n*RestoreCmControlResponseMessage(register struct bcm_mini_adapter *Adapter,\r\nregister PVOID pvBuffer)\r\n{\r\nULONG ulStatus = 0;\r\nstruct bcm_add_indication *pstAddIndication = NULL;\r\nstruct bcm_add_indication_alt *pstAddIndicationDest = NULL;\r\npstAddIndication = pvBuffer;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"=====>");\r\nif ((pstAddIndication->u8Type == DSD_REQ) ||\r\n(pstAddIndication->u8Type == DSD_RSP) ||\r\n(pstAddIndication->u8Type == DSD_ACK))\r\nreturn pvBuffer;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Inside RestoreCmControlResponseMessage ");\r\npstAddIndicationDest = kmalloc(sizeof(struct bcm_add_indication_alt),\r\nGFP_KERNEL);\r\nif (pstAddIndicationDest) {\r\nmemset(pstAddIndicationDest, 0,\r\nsizeof(struct bcm_add_indication_alt));\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG,\r\nDBG_LVL_ALL,\r\n"Failed to allocate memory for SF Add Indication Structure ");\r\nreturn NULL;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"AddIndication-u8Type : 0x%X",\r\npstAddIndication->u8Type);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"AddIndication-u8Direction : 0x%X",\r\npstAddIndication->eConnectionDir);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"AddIndication-u8TID : 0x%X",\r\nntohs(pstAddIndication->u16TID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"AddIndication-u8CID : 0x%X",\r\nntohs(pstAddIndication->u16CID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"AddIndication-u16VCID : 0x%X",\r\nntohs(pstAddIndication->u16VCID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"AddIndication-autorized set loc : %p",\r\npstAddIndication->psfAuthorizedSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"AddIndication-admitted set loc : %p",\r\npstAddIndication->psfAdmittedSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"AddIndication-Active set loc : %p",\r\npstAddIndication->psfActiveSet);\r\npstAddIndicationDest->u8Type = pstAddIndication->u8Type;\r\npstAddIndicationDest->u8Direction = pstAddIndication->eConnectionDir;\r\npstAddIndicationDest->u16TID = pstAddIndication->u16TID;\r\npstAddIndicationDest->u16CID = pstAddIndication->u16CID;\r\npstAddIndicationDest->u16VCID = pstAddIndication->u16VCID;\r\npstAddIndicationDest->u8CC = pstAddIndication->u8CC;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Restoring Active Set ");\r\nulStatus = RestoreSFParam(Adapter,\r\n(ULONG)pstAddIndication->psfActiveSet,\r\n(PUCHAR)&pstAddIndicationDest->sfActiveSet);\r\nif (ulStatus != 1)\r\ngoto failed_restore_sf_param;\r\nif (pstAddIndicationDest->sfActiveSet.u8TotalClassifiers > MAX_CLASSIFIERS_IN_SF)\r\npstAddIndicationDest->sfActiveSet.u8TotalClassifiers =\r\nMAX_CLASSIFIERS_IN_SF;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Restoring Admitted Set ");\r\nulStatus = RestoreSFParam(Adapter,\r\n(ULONG)pstAddIndication->psfAdmittedSet,\r\n(PUCHAR)&pstAddIndicationDest->sfAdmittedSet);\r\nif (ulStatus != 1)\r\ngoto failed_restore_sf_param;\r\nif (pstAddIndicationDest->sfAdmittedSet.u8TotalClassifiers > MAX_CLASSIFIERS_IN_SF)\r\npstAddIndicationDest->sfAdmittedSet.u8TotalClassifiers =\r\nMAX_CLASSIFIERS_IN_SF;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Restoring Authorized Set ");\r\nulStatus = RestoreSFParam(Adapter,\r\n(ULONG)pstAddIndication->psfAuthorizedSet,\r\n(PUCHAR)&pstAddIndicationDest->sfAuthorizedSet);\r\nif (ulStatus != 1)\r\ngoto failed_restore_sf_param;\r\nif (pstAddIndicationDest->sfAuthorizedSet.u8TotalClassifiers > MAX_CLASSIFIERS_IN_SF)\r\npstAddIndicationDest->sfAuthorizedSet.u8TotalClassifiers =\r\nMAX_CLASSIFIERS_IN_SF;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Dumping the whole raw packet");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"============================================================");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n" pstAddIndicationDest->sfActiveSet size %zx %p",\r\nsizeof(*pstAddIndicationDest), pstAddIndicationDest);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"============================================================");\r\nreturn pstAddIndicationDest;\r\nfailed_restore_sf_param:\r\nkfree(pstAddIndicationDest);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"<=====");\r\nreturn NULL;\r\n}\r\nULONG SetUpTargetDsxBuffers(struct bcm_mini_adapter *Adapter)\r\n{\r\nULONG ulTargetDsxBuffersBase = 0;\r\nULONG ulCntTargetBuffers;\r\nULONG i;\r\nint Status;\r\nif (!Adapter) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Adapter was NULL!!!");\r\nreturn 0;\r\n}\r\nif (Adapter->astTargetDsxBuffer[0].ulTargetDsxBuffer)\r\nreturn 1;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Size of Each DSX Buffer(Also size of connection manager parameters): %zx ",\r\nsizeof(struct bcm_connect_mgr_params));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Reading DSX buffer From Target location %x ",\r\nDSX_MESSAGE_EXCHANGE_BUFFER);\r\nStatus = rdmalt(Adapter, DSX_MESSAGE_EXCHANGE_BUFFER,\r\n(PUINT)&ulTargetDsxBuffersBase, sizeof(UINT));\r\nif (Status < 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"RDM failed!!");\r\nreturn 0;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Base Address Of DSX Target Buffer : 0x%lx",\r\nulTargetDsxBuffersBase);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Tgt Buffer is Now %lx :", ulTargetDsxBuffersBase);\r\nulCntTargetBuffers = DSX_MESSAGE_EXCHANGE_BUFFER_SIZE /\r\nsizeof(struct bcm_connect_mgr_params);\r\nAdapter->ulTotalTargetBuffersAvailable =\r\nulCntTargetBuffers > MAX_TARGET_DSX_BUFFERS ?\r\nMAX_TARGET_DSX_BUFFERS : ulCntTargetBuffers;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n" Total Target DSX Buffer setup %lx ",\r\nAdapter->ulTotalTargetBuffersAvailable);\r\nfor (i = 0; i < Adapter->ulTotalTargetBuffersAvailable; i++) {\r\nAdapter->astTargetDsxBuffer[i].ulTargetDsxBuffer = ulTargetDsxBuffersBase;\r\nAdapter->astTargetDsxBuffer[i].valid = 1;\r\nAdapter->astTargetDsxBuffer[i].tid = 0;\r\nulTargetDsxBuffersBase += sizeof(struct bcm_connect_mgr_params);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, " Target DSX Buffer %lx setup at 0x%lx",\r\ni, Adapter->astTargetDsxBuffer[i].ulTargetDsxBuffer);\r\n}\r\nAdapter->ulCurrentTargetBuffer = 0;\r\nAdapter->ulFreeTargetBufferCnt = Adapter->ulTotalTargetBuffersAvailable;\r\nreturn 1;\r\n}\r\nstatic ULONG GetNextTargetBufferLocation(struct bcm_mini_adapter *Adapter,\r\nB_UINT16 tid)\r\n{\r\nULONG dsx_buf;\r\nULONG idx, max_try;\r\nif ((Adapter->ulTotalTargetBuffersAvailable == 0)\r\n|| (Adapter->ulFreeTargetBufferCnt == 0)) {\r\nClearTargetDSXBuffer(Adapter, tid, false);\r\nreturn 0;\r\n}\r\nidx = Adapter->ulCurrentTargetBuffer;\r\nmax_try = Adapter->ulTotalTargetBuffersAvailable;\r\nwhile ((max_try) && (Adapter->astTargetDsxBuffer[idx].valid != 1)) {\r\nidx = (idx+1) % Adapter->ulTotalTargetBuffersAvailable;\r\nmax_try--;\r\n}\r\nif (max_try == 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\r\n"\n GetNextTargetBufferLocation : Error No Free Target DSX Buffers FreeCnt : %lx ",\r\nAdapter->ulFreeTargetBufferCnt);\r\nClearTargetDSXBuffer(Adapter, tid, false);\r\nreturn 0;\r\n}\r\ndsx_buf = Adapter->astTargetDsxBuffer[idx].ulTargetDsxBuffer;\r\nAdapter->astTargetDsxBuffer[idx].valid = 0;\r\nAdapter->astTargetDsxBuffer[idx].tid = tid;\r\nAdapter->ulFreeTargetBufferCnt--;\r\nidx = (idx+1)%Adapter->ulTotalTargetBuffersAvailable;\r\nAdapter->ulCurrentTargetBuffer = idx;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\r\n"GetNextTargetBufferLocation :Returning address %lx tid %d\n",\r\ndsx_buf, tid);\r\nreturn dsx_buf;\r\n}\r\nint AllocAdapterDsxBuffer(struct bcm_mini_adapter *Adapter)\r\n{\r\nAdapter->caDsxReqResp = kmalloc(sizeof(struct bcm_add_indication_alt)\r\n+ LEADER_SIZE, GFP_KERNEL);\r\nif (!Adapter->caDsxReqResp)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint FreeAdapterDsxBuffer(struct bcm_mini_adapter *Adapter)\r\n{\r\nkfree(Adapter->caDsxReqResp);\r\nreturn 0;\r\n}\r\nbool CmControlResponseMessage(struct bcm_mini_adapter *Adapter,\r\nPVOID pvBuffer )\r\n{\r\nstruct bcm_connect_mgr_params *psfLocalSet = NULL;\r\nstruct bcm_add_indication_alt *pstAddIndication = NULL;\r\nstruct bcm_change_indication *pstChangeIndication = NULL;\r\nstruct bcm_leader *pLeader = NULL;\r\nINT uiSearchRuleIndex = 0;\r\nULONG ulSFID;\r\npstAddIndication = RestoreCmControlResponseMessage(Adapter, pvBuffer);\r\nif (pstAddIndication == NULL) {\r\nClearTargetDSXBuffer(Adapter, ((struct bcm_add_indication *)pvBuffer)->u16TID, false);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "Error in restoring Service Flow param structure from DSx message");\r\nreturn false;\r\n}\r\nDumpCmControlPacket(pstAddIndication);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "====>");\r\npLeader = (struct bcm_leader *)Adapter->caDsxReqResp;\r\npLeader->Status = CM_CONTROL_NEWDSX_MULTICLASSIFIER_REQ;\r\npLeader->Vcid = 0;\r\nClearTargetDSXBuffer(Adapter, pstAddIndication->u16TID, false);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "### TID RECEIVED %d\n", pstAddIndication->u16TID);\r\nswitch (pstAddIndication->u8Type) {\r\ncase DSA_REQ:\r\npLeader->PLength = sizeof(struct bcm_add_indication_alt);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Sending DSA Response....\n");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSA RESPONSE TO MAC %d", pLeader->PLength);\r\n*((struct bcm_add_indication_alt *)&(Adapter->caDsxReqResp[LEADER_SIZE]))\r\n= *pstAddIndication;\r\n((struct bcm_add_indication_alt *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSA_RSP;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, " VCID = %x", ntohs(pstAddIndication->u16VCID));\r\nCopyBufferToControlPacket(Adapter, (PVOID)Adapter->caDsxReqResp);\r\nkfree(pstAddIndication);\r\nbreak;\r\ncase DSA_RSP:\r\npLeader->PLength = sizeof(struct bcm_add_indication_alt);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSA ACK TO MAC %d",\r\npLeader->PLength);\r\n*((struct bcm_add_indication_alt *)&(Adapter->caDsxReqResp[LEADER_SIZE]))\r\n= *pstAddIndication;\r\n((struct bcm_add_indication_alt *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSA_ACK;\r\ncase DSA_ACK:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "VCID:0x%X",\r\nntohs(pstAddIndication->u16VCID));\r\nuiSearchRuleIndex = SearchFreeSfid(Adapter);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "uiSearchRuleIndex:0x%X ",\r\nuiSearchRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Direction:0x%X ",\r\npstAddIndication->u8Direction);\r\nif (uiSearchRuleIndex < NO_OF_QUEUES) {\r\nAdapter->PackInfo[uiSearchRuleIndex].ucDirection =\r\npstAddIndication->u8Direction;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "bValid:0x%X ",\r\npstAddIndication->sfActiveSet.bValid);\r\nif (pstAddIndication->sfActiveSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bActiveSet = TRUE;\r\nif (pstAddIndication->sfAuthorizedSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAuthorizedSet = TRUE;\r\nif (pstAddIndication->sfAdmittedSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAdmittedSet = TRUE;\r\nif (pstAddIndication->sfActiveSet.bValid == false) {\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActivateRequestSent = false;\r\nif (pstAddIndication->sfAdmittedSet.bValid)\r\npsfLocalSet = &pstAddIndication->sfAdmittedSet;\r\nelse if (pstAddIndication->sfAuthorizedSet.bValid)\r\npsfLocalSet = &pstAddIndication->sfAuthorizedSet;\r\n} else {\r\npsfLocalSet = &pstAddIndication->sfActiveSet;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = TRUE;\r\n}\r\nif (!psfLocalSet) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "No set is valid\n");\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bValid = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = 0;\r\nkfree(pstAddIndication);\r\n} else if (psfLocalSet->bValid && (pstAddIndication->u8CC == 0)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "DSA ACK");\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = ntohs(pstAddIndication->u16VCID);\r\nAdapter->PackInfo[uiSearchRuleIndex].usCID = ntohs(pstAddIndication->u16CID);\r\nif (UPLINK_DIR == pstAddIndication->u8Direction)\r\natomic_set(&Adapter->PackInfo[uiSearchRuleIndex].uiPerSFTxResourceCount, DEFAULT_PERSFCOUNT);\r\nCopyToAdapter(Adapter, psfLocalSet, uiSearchRuleIndex, DSA_ACK, pstAddIndication);\r\nmemcpy((((PUCHAR)pvBuffer)+1), &psfLocalSet->u32SFID, 4);\r\nif (pstAddIndication->sfActiveSet.bValid == TRUE) {\r\nif (UPLINK_DIR == pstAddIndication->u8Direction) {\r\nif (!Adapter->LinkUpStatus) {\r\nnetif_carrier_on(Adapter->dev);\r\nnetif_start_queue(Adapter->dev);\r\nAdapter->LinkUpStatus = 1;\r\nif (netif_msg_link(Adapter))\r\npr_info(PFX "%s: link up\n", Adapter->dev->name);\r\natomic_set(&Adapter->TxPktAvail, 1);\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\nAdapter->liTimeSinceLastNetEntry = get_seconds();\r\n}\r\n}\r\n}\r\n} else {\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bValid = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = 0;\r\nkfree(pstAddIndication);\r\n}\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "DSA ACK did not get valid SFID");\r\nkfree(pstAddIndication);\r\nreturn false;\r\n}\r\nbreak;\r\ncase DSC_REQ:\r\npLeader->PLength = sizeof(struct bcm_change_indication);\r\npstChangeIndication = (struct bcm_change_indication *)pstAddIndication;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSC RESPONSE TO MAC %d", pLeader->PLength);\r\n*((struct bcm_change_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE])) = *pstChangeIndication;\r\n((struct bcm_change_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSC_RSP;\r\nCopyBufferToControlPacket(Adapter, (PVOID)Adapter->caDsxReqResp);\r\nkfree(pstAddIndication);\r\nbreak;\r\ncase DSC_RSP:\r\npLeader->PLength = sizeof(struct bcm_change_indication);\r\npstChangeIndication = (struct bcm_change_indication *)pstAddIndication;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSC ACK TO MAC %d", pLeader->PLength);\r\n*((struct bcm_change_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE])) = *pstChangeIndication;\r\n((struct bcm_change_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSC_ACK;\r\ncase DSC_ACK:\r\npstChangeIndication = (struct bcm_change_indication *)pstAddIndication;\r\nuiSearchRuleIndex = SearchSfid(Adapter, ntohl(pstChangeIndication->sfActiveSet.u32SFID));\r\nif (uiSearchRuleIndex > NO_OF_QUEUES-1)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "SF doesn't exist for which DSC_ACK is received");\r\nif (uiSearchRuleIndex < NO_OF_QUEUES) {\r\nAdapter->PackInfo[uiSearchRuleIndex].ucDirection = pstChangeIndication->u8Direction;\r\nif (pstChangeIndication->sfActiveSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bActiveSet = TRUE;\r\nif (pstChangeIndication->sfAuthorizedSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAuthorizedSet = TRUE;\r\nif (pstChangeIndication->sfAdmittedSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAdmittedSet = TRUE;\r\nif (pstChangeIndication->sfActiveSet.bValid == false) {\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActivateRequestSent = false;\r\nif (pstChangeIndication->sfAdmittedSet.bValid)\r\npsfLocalSet = &pstChangeIndication->sfAdmittedSet;\r\nelse if (pstChangeIndication->sfAuthorizedSet.bValid)\r\npsfLocalSet = &pstChangeIndication->sfAuthorizedSet;\r\n} else {\r\npsfLocalSet = &pstChangeIndication->sfActiveSet;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = TRUE;\r\n}\r\nif (!psfLocalSet) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "No set is valid\n");\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bValid = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = 0;\r\nkfree(pstAddIndication);\r\n} else if (psfLocalSet->bValid && (pstChangeIndication->u8CC == 0)) {\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = ntohs(pstChangeIndication->u16VCID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "CC field is %d bvalid = %d\n",\r\npstChangeIndication->u8CC, psfLocalSet->bValid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "VCID= %d\n", ntohs(pstChangeIndication->u16VCID));\r\nAdapter->PackInfo[uiSearchRuleIndex].usCID = ntohs(pstChangeIndication->u16CID);\r\nCopyToAdapter(Adapter, psfLocalSet, uiSearchRuleIndex, DSC_ACK, pstAddIndication);\r\n*(PULONG)(((PUCHAR)pvBuffer)+1) = psfLocalSet->u32SFID;\r\n} else if (pstChangeIndication->u8CC == 6) {\r\ndeleteSFBySfid(Adapter, uiSearchRuleIndex);\r\nkfree(pstAddIndication);\r\n}\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "DSC ACK did not get valid SFID");\r\nkfree(pstAddIndication);\r\nreturn false;\r\n}\r\nbreak;\r\ncase DSD_REQ:\r\npLeader->PLength = sizeof(struct bcm_del_indication);\r\n*((struct bcm_del_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE])) = *((struct bcm_del_indication *)pstAddIndication);\r\nulSFID = ntohl(((struct bcm_del_indication *)pstAddIndication)->u32SFID);\r\nuiSearchRuleIndex = SearchSfid(Adapter, ulSFID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "DSD - Removing connection %x", uiSearchRuleIndex);\r\nif (uiSearchRuleIndex < NO_OF_QUEUES) {\r\ndeleteSFBySfid(Adapter, uiSearchRuleIndex);\r\nAdapter->u32TotalDSD++;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSD RESPONSE TO MAC");\r\n((struct bcm_del_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSD_RSP;\r\nCopyBufferToControlPacket(Adapter, (PVOID)Adapter->caDsxReqResp);\r\ncase DSD_RSP:\r\nbreak;\r\ncase DSD_ACK:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "DSD ACK Rcd, let App handle it\n");\r\nbreak;\r\ndefault:\r\nkfree(pstAddIndication);\r\nreturn false;\r\n}\r\nreturn TRUE;\r\n}\r\nint get_dsx_sf_data_to_application(struct bcm_mini_adapter *Adapter,\r\nUINT uiSFId, void __user *user_buffer)\r\n{\r\nint status = 0;\r\nstruct bcm_packet_info *psSfInfo = NULL;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"status =%d", status);\r\nstatus = SearchSfid(Adapter, uiSFId);\r\nif (status >= NO_OF_QUEUES) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"SFID %d not present in queue !!!", uiSFId);\r\nreturn -EINVAL;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"status =%d", status);\r\npsSfInfo = &Adapter->PackInfo[status];\r\nif (psSfInfo->pstSFIndication\r\n&& copy_to_user(user_buffer, psSfInfo->pstSFIndication,\r\nsizeof(struct bcm_add_indication_alt))) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\r\n"copy to user failed SFID %d, present in queue !!!",\r\nuiSFId);\r\nstatus = -EFAULT;\r\nreturn status;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nVOID OverrideServiceFlowParams(struct bcm_mini_adapter *Adapter,\r\nPUINT puiBuffer)\r\n{\r\nB_UINT32 u32NumofSFsinMsg = ntohl(*(puiBuffer + 1));\r\nstruct bcm_stim_sfhostnotify *pHostInfo = NULL;\r\nUINT uiSearchRuleIndex = 0;\r\nULONG ulSFID = 0;\r\npuiBuffer += 2;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"u32NumofSFsinMsg: 0x%x\n", u32NumofSFsinMsg);\r\nwhile (u32NumofSFsinMsg != 0 && u32NumofSFsinMsg < NO_OF_QUEUES) {\r\nu32NumofSFsinMsg--;\r\npHostInfo = (struct bcm_stim_sfhostnotify *)puiBuffer;\r\npuiBuffer = (PUINT)(pHostInfo + 1);\r\nulSFID = ntohl(pHostInfo->SFID);\r\nuiSearchRuleIndex = SearchSfid(Adapter, ulSFID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"SFID: 0x%lx\n", ulSFID);\r\nif (uiSearchRuleIndex >= NO_OF_QUEUES\r\n|| uiSearchRuleIndex == HiPriority) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG,\r\nDBG_LVL_ALL,\r\n"The SFID <%lx> doesn't exist in host entry or is Invalid\n",\r\nulSFID);\r\ncontinue;\r\n}\r\nif (pHostInfo->RetainSF == false) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG,\r\nDBG_LVL_ALL, "Going to Delete SF");\r\ndeleteSFBySfid(Adapter, uiSearchRuleIndex);\r\n} else {\r\nstruct bcm_packet_info *packinfo =\r\n&Adapter->PackInfo[uiSearchRuleIndex];\r\npackinfo->usVCID_Value = ntohs(pHostInfo->VCID);\r\npackinfo->usCID = ntohs(pHostInfo->newCID);\r\npackinfo->bActive = false;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG,\r\nDBG_LVL_ALL,\r\n"pHostInfo->QoSParamSet: 0x%x\n",\r\npHostInfo->QoSParamSet);\r\nif (pHostInfo->QoSParamSet & 0x1)\r\npackinfo->bAuthorizedSet = TRUE;\r\nif (pHostInfo->QoSParamSet & 0x2)\r\npackinfo->bAdmittedSet = TRUE;\r\nif (pHostInfo->QoSParamSet & 0x4) {\r\npackinfo->bActiveSet = TRUE;\r\npackinfo->bActive = TRUE;\r\n}\r\n}\r\n}\r\n}\r\nstatic void restore_endianess_of_pstClassifierEntry(\r\nstruct bcm_classifier_rule *pstClassifierEntry,\r\nenum bcm_ipaddr_context eIpAddrContext)\r\n{\r\nint i;\r\nunion u_ip_address *stSrc = &pstClassifierEntry->stSrcIpAddress;\r\nunion u_ip_address *stDest = &pstClassifierEntry->stDestIpAddress;\r\nfor (i = 0; i < MAX_IP_RANGE_LENGTH * 4; i++) {\r\nif (eIpAddrContext == eSrcIpAddress) {\r\nstSrc->ulIpv6Addr[i] = ntohl(stSrc->ulIpv6Addr[i]);\r\nstSrc->ulIpv6Mask[i] = ntohl(stSrc->ulIpv6Mask[i]);\r\n} else if (eIpAddrContext == eDestIpAddress) {\r\nstDest->ulIpv6Addr[i] = ntohl(stDest->ulIpv6Addr[i]);\r\nstDest->ulIpv6Mask[i] = ntohl(stDest->ulIpv6Mask[i]);\r\n}\r\n}\r\n}\r\nstatic void apply_phs_rule_to_all_classifiers(\r\nregister struct bcm_mini_adapter *Adapter,\r\nregister UINT uiSearchRuleIndex,\r\nUSHORT uVCID,\r\nstruct bcm_phs_rule *sPhsRule,\r\nstruct bcm_phs_rules *cPhsRule,\r\nstruct bcm_add_indication_alt *pstAddIndication)\r\n{\r\nunsigned int uiClassifierIndex = 0;\r\nstruct bcm_classifier_rule *curr_classifier = NULL;\r\nif (pstAddIndication->u8Direction == UPLINK_DIR) {\r\nfor (uiClassifierIndex = 0; uiClassifierIndex < MAX_CLASSIFIERS; uiClassifierIndex++) {\r\ncurr_classifier =\r\n&Adapter->astClassifierTable[uiClassifierIndex];\r\nif ((curr_classifier->bUsed) &&\r\n(curr_classifier->ulSFID == Adapter->PackInfo[uiSearchRuleIndex].ulSFID) &&\r\n(curr_classifier->u8AssociatedPHSI == cPhsRule->u8PHSI)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Adding PHS Rule For Classifier: 0x%x cPhsRule.u8PHSI: 0x%x\n",\r\ncurr_classifier->uiClassifierRuleIndex,\r\ncPhsRule->u8PHSI);\r\nsPhsRule->u8PHSI = cPhsRule->u8PHSI;\r\nsPhsRule->u8PHSFLength = cPhsRule->u8PHSFLength;\r\nsPhsRule->u8PHSMLength = cPhsRule->u8PHSMLength;\r\nsPhsRule->u8PHSS = cPhsRule->u8PHSS;\r\nsPhsRule->u8PHSV = cPhsRule->u8PHSV;\r\nmemcpy(sPhsRule->u8PHSF, cPhsRule->u8PHSF, MAX_PHS_LENGTHS);\r\nmemcpy(sPhsRule->u8PHSM, cPhsRule->u8PHSM, MAX_PHS_LENGTHS);\r\nsPhsRule->u8RefCnt = 0;\r\nsPhsRule->bUnclassifiedPHSRule = false;\r\nsPhsRule->PHSModifiedBytes = 0;\r\nsPhsRule->PHSModifiedNumPackets = 0;\r\nsPhsRule->PHSErrorNumPackets = 0;\r\nPhsUpdateClassifierRule(\r\n&Adapter->stBCMPhsContext,\r\nuVCID,\r\ncurr_classifier->uiClassifierRuleIndex,\r\nsPhsRule,\r\ncurr_classifier->u8AssociatedPHSI);\r\nif (sPhsRule->u8PHSI) {\r\ncurr_classifier->u32PHSRuleID = sPhsRule->u8PHSI;\r\nmemcpy(&curr_classifier->sPhsRule, sPhsRule, sizeof(struct bcm_phs_rule));\r\n}\r\n}\r\n}\r\n} else {\r\nsPhsRule->u8PHSI = cPhsRule->u8PHSI;\r\nsPhsRule->u8PHSFLength = cPhsRule->u8PHSFLength;\r\nsPhsRule->u8PHSMLength = cPhsRule->u8PHSMLength;\r\nsPhsRule->u8PHSS = cPhsRule->u8PHSS;\r\nsPhsRule->u8PHSV = cPhsRule->u8PHSV;\r\nmemcpy(sPhsRule->u8PHSF, cPhsRule->u8PHSF, MAX_PHS_LENGTHS);\r\nmemcpy(sPhsRule->u8PHSM, cPhsRule->u8PHSM, MAX_PHS_LENGTHS);\r\nsPhsRule->u8RefCnt = 0;\r\nsPhsRule->bUnclassifiedPHSRule = TRUE;\r\nsPhsRule->PHSModifiedBytes = 0;\r\nsPhsRule->PHSModifiedNumPackets = 0;\r\nsPhsRule->PHSErrorNumPackets = 0;\r\nPhsUpdateClassifierRule(\r\n&Adapter->stBCMPhsContext,\r\nuVCID,\r\nsPhsRule->u8PHSI,\r\nsPhsRule,\r\nsPhsRule->u8PHSI);\r\n}\r\n}
