static inline bool is_secondary(struct i2s_dai *i2s)\r\n{\r\nreturn i2s->pri_dai ? true : false;\r\n}\r\nstatic inline bool is_slave(struct i2s_dai *i2s)\r\n{\r\nreturn (readl(i2s->addr + I2SMOD) & MOD_SLAVE) ? true : false;\r\n}\r\nstatic inline bool tx_active(struct i2s_dai *i2s)\r\n{\r\nu32 active;\r\nif (!i2s)\r\nreturn false;\r\nactive = readl(i2s->addr + I2SCON);\r\nif (is_secondary(i2s))\r\nactive &= CON_TXSDMA_ACTIVE;\r\nelse\r\nactive &= CON_TXDMA_ACTIVE;\r\nreturn active ? true : false;\r\n}\r\nstatic inline bool other_tx_active(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nreturn tx_active(other);\r\n}\r\nstatic inline bool any_tx_active(struct i2s_dai *i2s)\r\n{\r\nreturn tx_active(i2s) || other_tx_active(i2s);\r\n}\r\nstatic inline bool rx_active(struct i2s_dai *i2s)\r\n{\r\nu32 active;\r\nif (!i2s)\r\nreturn false;\r\nactive = readl(i2s->addr + I2SCON) & CON_RXDMA_ACTIVE;\r\nreturn active ? true : false;\r\n}\r\nstatic inline bool other_rx_active(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nreturn rx_active(other);\r\n}\r\nstatic inline bool any_rx_active(struct i2s_dai *i2s)\r\n{\r\nreturn rx_active(i2s) || other_rx_active(i2s);\r\n}\r\nstatic inline bool other_active(struct i2s_dai *i2s)\r\n{\r\nreturn other_rx_active(i2s) || other_tx_active(i2s);\r\n}\r\nstatic inline bool this_active(struct i2s_dai *i2s)\r\n{\r\nreturn tx_active(i2s) || rx_active(i2s);\r\n}\r\nstatic inline bool any_active(struct i2s_dai *i2s)\r\n{\r\nreturn this_active(i2s) || other_active(i2s);\r\n}\r\nstatic inline struct i2s_dai *to_info(struct snd_soc_dai *dai)\r\n{\r\nreturn snd_soc_dai_get_drvdata(dai);\r\n}\r\nstatic inline bool is_opened(struct i2s_dai *i2s)\r\n{\r\nif (i2s && (i2s->mode & DAI_OPENED))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic inline bool is_manager(struct i2s_dai *i2s)\r\n{\r\nif (is_opened(i2s) && (i2s->mode & DAI_MANAGER))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic inline unsigned get_rfs(struct i2s_dai *i2s)\r\n{\r\nu32 rfs;\r\nif (i2s->quirks & QUIRK_SUPPORTS_TDM)\r\nrfs = readl(i2s->addr + I2SMOD) >> EXYNOS5420_MOD_RCLK_SHIFT;\r\nelse\r\nrfs = (readl(i2s->addr + I2SMOD) >> MOD_RCLK_SHIFT);\r\nrfs &= MOD_RCLK_MASK;\r\nswitch (rfs) {\r\ncase 3: return 768;\r\ncase 2: return 384;\r\ncase 1: return 512;\r\ndefault: return 256;\r\n}\r\n}\r\nstatic inline void set_rfs(struct i2s_dai *i2s, unsigned rfs)\r\n{\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nint rfs_shift;\r\nif (i2s->quirks & QUIRK_SUPPORTS_TDM)\r\nrfs_shift = EXYNOS5420_MOD_RCLK_SHIFT;\r\nelse\r\nrfs_shift = MOD_RCLK_SHIFT;\r\nmod &= ~(MOD_RCLK_MASK << rfs_shift);\r\nswitch (rfs) {\r\ncase 768:\r\nmod |= (MOD_RCLK_768FS << rfs_shift);\r\nbreak;\r\ncase 512:\r\nmod |= (MOD_RCLK_512FS << rfs_shift);\r\nbreak;\r\ncase 384:\r\nmod |= (MOD_RCLK_384FS << rfs_shift);\r\nbreak;\r\ndefault:\r\nmod |= (MOD_RCLK_256FS << rfs_shift);\r\nbreak;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\n}\r\nstatic inline unsigned get_bfs(struct i2s_dai *i2s)\r\n{\r\nu32 bfs;\r\nif (i2s->quirks & QUIRK_SUPPORTS_TDM) {\r\nbfs = readl(i2s->addr + I2SMOD) >> EXYNOS5420_MOD_BCLK_SHIFT;\r\nbfs &= EXYNOS5420_MOD_BCLK_MASK;\r\n} else {\r\nbfs = readl(i2s->addr + I2SMOD) >> MOD_BCLK_SHIFT;\r\nbfs &= MOD_BCLK_MASK;\r\n}\r\nswitch (bfs) {\r\ncase 8: return 256;\r\ncase 7: return 192;\r\ncase 6: return 128;\r\ncase 5: return 96;\r\ncase 4: return 64;\r\ncase 3: return 24;\r\ncase 2: return 16;\r\ncase 1: return 48;\r\ndefault: return 32;\r\n}\r\n}\r\nstatic inline void set_bfs(struct i2s_dai *i2s, unsigned bfs)\r\n{\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nint bfs_shift;\r\nint tdm = i2s->quirks & QUIRK_SUPPORTS_TDM;\r\nif (i2s->quirks & QUIRK_SUPPORTS_TDM) {\r\nbfs_shift = EXYNOS5420_MOD_BCLK_SHIFT;\r\nmod &= ~(EXYNOS5420_MOD_BCLK_MASK << bfs_shift);\r\n} else {\r\nbfs_shift = MOD_BCLK_SHIFT;\r\nmod &= ~(MOD_BCLK_MASK << bfs_shift);\r\n}\r\nif (!tdm && bfs > 48) {\r\ndev_err(&i2s->pdev->dev, "Unsupported BCLK divider\n");\r\nreturn;\r\n}\r\nswitch (bfs) {\r\ncase 48:\r\nmod |= (MOD_BCLK_48FS << bfs_shift);\r\nbreak;\r\ncase 32:\r\nmod |= (MOD_BCLK_32FS << bfs_shift);\r\nbreak;\r\ncase 24:\r\nmod |= (MOD_BCLK_24FS << bfs_shift);\r\nbreak;\r\ncase 16:\r\nmod |= (MOD_BCLK_16FS << bfs_shift);\r\nbreak;\r\ncase 64:\r\nmod |= (EXYNOS5420_MOD_BCLK_64FS << bfs_shift);\r\nbreak;\r\ncase 96:\r\nmod |= (EXYNOS5420_MOD_BCLK_96FS << bfs_shift);\r\nbreak;\r\ncase 128:\r\nmod |= (EXYNOS5420_MOD_BCLK_128FS << bfs_shift);\r\nbreak;\r\ncase 192:\r\nmod |= (EXYNOS5420_MOD_BCLK_192FS << bfs_shift);\r\nbreak;\r\ncase 256:\r\nmod |= (EXYNOS5420_MOD_BCLK_256FS << bfs_shift);\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Wrong BCLK Divider!\n");\r\nreturn;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\n}\r\nstatic inline int get_blc(struct i2s_dai *i2s)\r\n{\r\nint blc = readl(i2s->addr + I2SMOD);\r\nblc = (blc >> 13) & 0x3;\r\nswitch (blc) {\r\ncase 2: return 24;\r\ncase 1: return 8;\r\ndefault: return 16;\r\n}\r\n}\r\nstatic void i2s_txctrl(struct i2s_dai *i2s, int on)\r\n{\r\nvoid __iomem *addr = i2s->addr;\r\nu32 con = readl(addr + I2SCON);\r\nu32 mod = readl(addr + I2SMOD) & ~MOD_MASK;\r\nif (on) {\r\ncon |= CON_ACTIVE;\r\ncon &= ~CON_TXCH_PAUSE;\r\nif (is_secondary(i2s)) {\r\ncon |= CON_TXSDMA_ACTIVE;\r\ncon &= ~CON_TXSDMA_PAUSE;\r\n} else {\r\ncon |= CON_TXDMA_ACTIVE;\r\ncon &= ~CON_TXDMA_PAUSE;\r\n}\r\nif (any_rx_active(i2s))\r\nmod |= MOD_TXRX;\r\nelse\r\nmod |= MOD_TXONLY;\r\n} else {\r\nif (is_secondary(i2s)) {\r\ncon |= CON_TXSDMA_PAUSE;\r\ncon &= ~CON_TXSDMA_ACTIVE;\r\n} else {\r\ncon |= CON_TXDMA_PAUSE;\r\ncon &= ~CON_TXDMA_ACTIVE;\r\n}\r\nif (other_tx_active(i2s)) {\r\nwritel(con, addr + I2SCON);\r\nreturn;\r\n}\r\ncon |= CON_TXCH_PAUSE;\r\nif (any_rx_active(i2s))\r\nmod |= MOD_RXONLY;\r\nelse\r\ncon &= ~CON_ACTIVE;\r\n}\r\nwritel(mod, addr + I2SMOD);\r\nwritel(con, addr + I2SCON);\r\n}\r\nstatic void i2s_rxctrl(struct i2s_dai *i2s, int on)\r\n{\r\nvoid __iomem *addr = i2s->addr;\r\nu32 con = readl(addr + I2SCON);\r\nu32 mod = readl(addr + I2SMOD) & ~MOD_MASK;\r\nif (on) {\r\ncon |= CON_RXDMA_ACTIVE | CON_ACTIVE;\r\ncon &= ~(CON_RXDMA_PAUSE | CON_RXCH_PAUSE);\r\nif (any_tx_active(i2s))\r\nmod |= MOD_TXRX;\r\nelse\r\nmod |= MOD_RXONLY;\r\n} else {\r\ncon |= CON_RXDMA_PAUSE | CON_RXCH_PAUSE;\r\ncon &= ~CON_RXDMA_ACTIVE;\r\nif (any_tx_active(i2s))\r\nmod |= MOD_TXONLY;\r\nelse\r\ncon &= ~CON_ACTIVE;\r\n}\r\nwritel(mod, addr + I2SMOD);\r\nwritel(con, addr + I2SCON);\r\n}\r\nstatic inline void i2s_fifo(struct i2s_dai *i2s, u32 flush)\r\n{\r\nvoid __iomem *fic;\r\nu32 val;\r\nif (!i2s)\r\nreturn;\r\nif (is_secondary(i2s))\r\nfic = i2s->addr + I2SFICS;\r\nelse\r\nfic = i2s->addr + I2SFIC;\r\nwritel(readl(fic) | flush, fic);\r\nval = msecs_to_loops(1) / 1000;\r\nwhile (--val)\r\ncpu_relax();\r\nwritel(readl(fic) & ~flush, fic);\r\n}\r\nstatic int i2s_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int rfs, int dir)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nswitch (clk_id) {\r\ncase SAMSUNG_I2S_OPCLK:\r\nmod &= ~MOD_OPCLK_MASK;\r\nmod |= dir;\r\nbreak;\r\ncase SAMSUNG_I2S_CDCLK:\r\nif (dir == SND_SOC_CLOCK_IN)\r\nrfs = 0;\r\nif ((rfs && other && other->rfs && (other->rfs != rfs)) ||\r\n(any_active(i2s) &&\r\n(((dir == SND_SOC_CLOCK_IN)\r\n&& !(mod & MOD_CDCLKCON)) ||\r\n((dir == SND_SOC_CLOCK_OUT)\r\n&& (mod & MOD_CDCLKCON))))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nif (dir == SND_SOC_CLOCK_IN)\r\nmod |= MOD_CDCLKCON;\r\nelse\r\nmod &= ~MOD_CDCLKCON;\r\ni2s->rfs = rfs;\r\nbreak;\r\ncase SAMSUNG_I2S_RCLKSRC_0:\r\ncase SAMSUNG_I2S_RCLKSRC_1:\r\nif ((i2s->quirks & QUIRK_NO_MUXPSR)\r\n|| (clk_id == SAMSUNG_I2S_RCLKSRC_0))\r\nclk_id = 0;\r\nelse\r\nclk_id = 1;\r\nif (!any_active(i2s)) {\r\nif (i2s->op_clk && !IS_ERR(i2s->op_clk)) {\r\nif ((clk_id && !(mod & MOD_IMS_SYSMUX)) ||\r\n(!clk_id && (mod & MOD_IMS_SYSMUX))) {\r\nclk_disable_unprepare(i2s->op_clk);\r\nclk_put(i2s->op_clk);\r\n} else {\r\ni2s->rclk_srcrate =\r\nclk_get_rate(i2s->op_clk);\r\nreturn 0;\r\n}\r\n}\r\nif (clk_id)\r\ni2s->op_clk = clk_get(&i2s->pdev->dev,\r\n"i2s_opclk1");\r\nelse\r\ni2s->op_clk = clk_get(&i2s->pdev->dev,\r\n"i2s_opclk0");\r\nif (WARN_ON(IS_ERR(i2s->op_clk)))\r\nreturn PTR_ERR(i2s->op_clk);\r\nclk_prepare_enable(i2s->op_clk);\r\ni2s->rclk_srcrate = clk_get_rate(i2s->op_clk);\r\nif (other) {\r\nother->op_clk = i2s->op_clk;\r\nother->rclk_srcrate = i2s->rclk_srcrate;\r\n}\r\n} else if ((!clk_id && (mod & MOD_IMS_SYSMUX))\r\n|| (clk_id && !(mod & MOD_IMS_SYSMUX))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n} else {\r\ni2s->op_clk = other->op_clk;\r\ni2s->rclk_srcrate = other->rclk_srcrate;\r\nreturn 0;\r\n}\r\nif (clk_id == 0)\r\nmod &= ~MOD_IMS_SYSMUX;\r\nelse\r\nmod |= MOD_IMS_SYSMUX;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "We don't serve that!\n");\r\nreturn -EINVAL;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\nreturn 0;\r\n}\r\nstatic int i2s_set_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nint lrp_shift, sdf_shift, sdf_mask, lrp_rlow;\r\nu32 tmp = 0;\r\nif (i2s->quirks & QUIRK_SUPPORTS_TDM) {\r\nlrp_shift = EXYNOS5420_MOD_LRP_SHIFT;\r\nsdf_shift = EXYNOS5420_MOD_SDF_SHIFT;\r\n} else {\r\nlrp_shift = MOD_LRP_SHIFT;\r\nsdf_shift = MOD_SDF_SHIFT;\r\n}\r\nsdf_mask = MOD_SDF_MASK << sdf_shift;\r\nlrp_rlow = MOD_LR_RLOW << lrp_shift;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ntmp |= lrp_rlow;\r\ntmp |= (MOD_SDF_MSB << sdf_shift);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ntmp |= lrp_rlow;\r\ntmp |= (MOD_SDF_LSB << sdf_shift);\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ntmp |= (MOD_SDF_IIS << sdf_shift);\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nif (tmp & lrp_rlow)\r\ntmp &= ~lrp_rlow;\r\nelse\r\ntmp |= lrp_rlow;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Polarity not supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ntmp |= MOD_SLAVE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nif (i2s->rclk_srcrate == 0)\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_RCLKSRC_0,\r\n0, SND_SOC_CLOCK_IN);\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "master/slave format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (any_active(i2s) &&\r\n((mod & (sdf_mask | lrp_rlow | MOD_SLAVE)) != tmp)) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nmod &= ~(sdf_mask | lrp_rlow | MOD_SLAVE);\r\nmod |= tmp;\r\nwritel(mod, i2s->addr + I2SMOD);\r\nreturn 0;\r\n}\r\nstatic int i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nif (!is_secondary(i2s))\r\nmod &= ~(MOD_DC2_EN | MOD_DC1_EN);\r\nswitch (params_channels(params)) {\r\ncase 6:\r\nmod |= MOD_DC2_EN;\r\ncase 4:\r\nmod |= MOD_DC1_EN;\r\nbreak;\r\ncase 2:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ni2s->dma_playback.dma_size = 4;\r\nelse\r\ni2s->dma_capture.dma_size = 4;\r\nbreak;\r\ncase 1:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ni2s->dma_playback.dma_size = 2;\r\nelse\r\ni2s->dma_capture.dma_size = 2;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "%d channels not supported\n",\r\nparams_channels(params));\r\nreturn -EINVAL;\r\n}\r\nif (is_secondary(i2s))\r\nmod &= ~MOD_BLCS_MASK;\r\nelse\r\nmod &= ~MOD_BLCP_MASK;\r\nif (is_manager(i2s))\r\nmod &= ~MOD_BLC_MASK;\r\nswitch (params_width(params)) {\r\ncase 8:\r\nif (is_secondary(i2s))\r\nmod |= MOD_BLCS_8BIT;\r\nelse\r\nmod |= MOD_BLCP_8BIT;\r\nif (is_manager(i2s))\r\nmod |= MOD_BLC_8BIT;\r\nbreak;\r\ncase 16:\r\nif (is_secondary(i2s))\r\nmod |= MOD_BLCS_16BIT;\r\nelse\r\nmod |= MOD_BLCP_16BIT;\r\nif (is_manager(i2s))\r\nmod |= MOD_BLC_16BIT;\r\nbreak;\r\ncase 24:\r\nif (is_secondary(i2s))\r\nmod |= MOD_BLCS_24BIT;\r\nelse\r\nmod |= MOD_BLCP_24BIT;\r\nif (is_manager(i2s))\r\nmod |= MOD_BLC_24BIT;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Format(%d) not supported\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\nsamsung_asoc_init_dma_data(dai, &i2s->dma_playback, &i2s->dma_capture);\r\ni2s->frmclk = params_rate(params);\r\nreturn 0;\r\n}\r\nstatic int i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\ni2s->mode |= DAI_OPENED;\r\nif (is_manager(other))\r\ni2s->mode &= ~DAI_MANAGER;\r\nelse\r\ni2s->mode |= DAI_MANAGER;\r\nif (!any_active(i2s) && (i2s->quirks & QUIRK_NEED_RSTCLR))\r\nwritel(CON_RSTCLR, i2s->addr + I2SCON);\r\nspin_unlock_irqrestore(&lock, flags);\r\nif (!is_opened(other) && i2s->cdclk_out)\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,\r\n0, SND_SOC_CLOCK_OUT);\r\nreturn 0;\r\n}\r\nstatic void i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\ni2s->mode &= ~DAI_OPENED;\r\ni2s->mode &= ~DAI_MANAGER;\r\nif (is_opened(other)) {\r\nother->mode |= DAI_MANAGER;\r\n} else {\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\ni2s->cdclk_out = !(mod & MOD_CDCLKCON);\r\nif (other)\r\nother->cdclk_out = i2s->cdclk_out;\r\n}\r\ni2s->rfs = 0;\r\ni2s->bfs = 0;\r\nspin_unlock_irqrestore(&lock, flags);\r\nif (!is_opened(other))\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,\r\n0, SND_SOC_CLOCK_IN);\r\n}\r\nstatic int config_setup(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nunsigned rfs, bfs, blc;\r\nu32 psr;\r\nblc = get_blc(i2s);\r\nbfs = i2s->bfs;\r\nif (!bfs && other)\r\nbfs = other->bfs;\r\nif (!bfs)\r\nbfs = blc * 2;\r\nrfs = i2s->rfs;\r\nif (!rfs && other)\r\nrfs = other->rfs;\r\nif ((rfs == 256 || rfs == 512) && (blc == 24)) {\r\ndev_err(&i2s->pdev->dev,\r\n"%d-RFS not supported for 24-blc\n", rfs);\r\nreturn -EINVAL;\r\n}\r\nif (!rfs) {\r\nif (bfs == 16 || bfs == 32)\r\nrfs = 256;\r\nelse\r\nrfs = 384;\r\n}\r\nif (any_active(i2s) && (get_rfs(i2s) != rfs || get_bfs(i2s) != bfs)) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nset_bfs(i2s, bfs);\r\nset_rfs(i2s, rfs);\r\nif (is_slave(i2s))\r\nreturn 0;\r\nif (!(i2s->quirks & QUIRK_NO_MUXPSR)) {\r\npsr = i2s->rclk_srcrate / i2s->frmclk / rfs;\r\nwritel(((psr - 1) << 8) | PSR_PSREN, i2s->addr + I2SPSR);\r\ndev_dbg(&i2s->pdev->dev,\r\n"RCLK_SRC=%luHz PSR=%u, RCLK=%dfs, BCLK=%dfs\n",\r\ni2s->rclk_srcrate, psr, rfs, bfs);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2s_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nint capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct i2s_dai *i2s = to_info(rtd->cpu_dai);\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nlocal_irq_save(flags);\r\nif (config_setup(i2s)) {\r\nlocal_irq_restore(flags);\r\nreturn -EINVAL;\r\n}\r\nif (capture)\r\ni2s_rxctrl(i2s, 1);\r\nelse\r\ni2s_txctrl(i2s, 1);\r\nlocal_irq_restore(flags);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nlocal_irq_save(flags);\r\nif (capture) {\r\ni2s_rxctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_RXFLUSH);\r\n} else {\r\ni2s_txctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_TXFLUSH);\r\n}\r\nlocal_irq_restore(flags);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2s_set_clkdiv(struct snd_soc_dai *dai,\r\nint div_id, int div)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nswitch (div_id) {\r\ncase SAMSUNG_I2S_DIV_BCLK:\r\nif ((any_active(i2s) && div && (get_bfs(i2s) != div))\r\n|| (other && other->bfs && (other->bfs != div))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\ni2s->bfs = div;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev,\r\n"Invalid clock divider(%d)\n", div_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_sframes_t\r\ni2s_delay(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nu32 reg = readl(i2s->addr + I2SFIC);\r\nsnd_pcm_sframes_t delay;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ndelay = FIC_RXCOUNT(reg);\r\nelse if (is_secondary(i2s))\r\ndelay = FICS_TXCOUNT(readl(i2s->addr + I2SFICS));\r\nelse\r\ndelay = FIC_TXCOUNT(reg);\r\nreturn delay;\r\n}\r\nstatic int i2s_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\ni2s->suspend_i2smod = readl(i2s->addr + I2SMOD);\r\ni2s->suspend_i2scon = readl(i2s->addr + I2SCON);\r\ni2s->suspend_i2spsr = readl(i2s->addr + I2SPSR);\r\nreturn 0;\r\n}\r\nstatic int i2s_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nwritel(i2s->suspend_i2scon, i2s->addr + I2SCON);\r\nwritel(i2s->suspend_i2smod, i2s->addr + I2SMOD);\r\nwritel(i2s->suspend_i2spsr, i2s->addr + I2SPSR);\r\nreturn 0;\r\n}\r\nstatic int samsung_i2s_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nif (other && other->clk) {\r\nsamsung_asoc_init_dma_data(dai, &other->sec_dai->dma_playback,\r\nNULL);\r\ngoto probe_exit;\r\n}\r\ni2s->addr = ioremap(i2s->base, 0x100);\r\nif (i2s->addr == NULL) {\r\ndev_err(&i2s->pdev->dev, "cannot ioremap registers\n");\r\nreturn -ENXIO;\r\n}\r\ni2s->clk = clk_get(&i2s->pdev->dev, "iis");\r\nif (IS_ERR(i2s->clk)) {\r\ndev_err(&i2s->pdev->dev, "failed to get i2s_clock\n");\r\niounmap(i2s->addr);\r\nreturn -ENOENT;\r\n}\r\nclk_prepare_enable(i2s->clk);\r\nsamsung_asoc_init_dma_data(dai, &i2s->dma_playback, &i2s->dma_capture);\r\nif (other) {\r\nother->addr = i2s->addr;\r\nother->clk = i2s->clk;\r\n}\r\nif (i2s->quirks & QUIRK_NEED_RSTCLR)\r\nwritel(CON_RSTCLR, i2s->addr + I2SCON);\r\nif (i2s->quirks & QUIRK_SEC_DAI)\r\nidma_reg_addr_init(i2s->addr,\r\ni2s->sec_dai->idma_playback.dma_addr);\r\nprobe_exit:\r\ni2s->rfs = 0;\r\ni2s->bfs = 0;\r\ni2s->rclk_srcrate = 0;\r\ni2s_txctrl(i2s, 0);\r\ni2s_rxctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_TXFLUSH);\r\ni2s_fifo(other, FIC_TXFLUSH);\r\ni2s_fifo(i2s, FIC_RXFLUSH);\r\nif (!is_opened(other))\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,\r\n0, SND_SOC_CLOCK_IN);\r\nreturn 0;\r\n}\r\nstatic int samsung_i2s_dai_remove(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = snd_soc_dai_get_drvdata(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nif (!other || !other->clk) {\r\nif (i2s->quirks & QUIRK_NEED_RSTCLR)\r\nwritel(0, i2s->addr + I2SCON);\r\nclk_disable_unprepare(i2s->clk);\r\nclk_put(i2s->clk);\r\niounmap(i2s->addr);\r\n}\r\ni2s->clk = NULL;\r\nreturn 0;\r\n}\r\nstatic struct i2s_dai *i2s_alloc_dai(struct platform_device *pdev, bool sec)\r\n{\r\nstruct i2s_dai *i2s;\r\nint ret;\r\ni2s = devm_kzalloc(&pdev->dev, sizeof(struct i2s_dai), GFP_KERNEL);\r\nif (i2s == NULL)\r\nreturn NULL;\r\ni2s->pdev = pdev;\r\ni2s->pri_dai = NULL;\r\ni2s->sec_dai = NULL;\r\ni2s->i2s_dai_drv.symmetric_rates = 1;\r\ni2s->i2s_dai_drv.probe = samsung_i2s_dai_probe;\r\ni2s->i2s_dai_drv.remove = samsung_i2s_dai_remove;\r\ni2s->i2s_dai_drv.ops = &samsung_i2s_dai_ops;\r\ni2s->i2s_dai_drv.suspend = i2s_suspend;\r\ni2s->i2s_dai_drv.resume = i2s_resume;\r\ni2s->i2s_dai_drv.playback.channels_min = 1;\r\ni2s->i2s_dai_drv.playback.channels_max = 2;\r\ni2s->i2s_dai_drv.playback.rates = SAMSUNG_I2S_RATES;\r\ni2s->i2s_dai_drv.playback.formats = SAMSUNG_I2S_FMTS;\r\nif (!sec) {\r\ni2s->i2s_dai_drv.capture.channels_min = 1;\r\ni2s->i2s_dai_drv.capture.channels_max = 2;\r\ni2s->i2s_dai_drv.capture.rates = SAMSUNG_I2S_RATES;\r\ni2s->i2s_dai_drv.capture.formats = SAMSUNG_I2S_FMTS;\r\ndev_set_drvdata(&i2s->pdev->dev, i2s);\r\n} else {\r\ni2s->pdev = platform_device_alloc("samsung-i2s-sec", -1);\r\nif (!i2s->pdev)\r\nreturn NULL;\r\ni2s->pdev->dev.parent = &pdev->dev;\r\nplatform_set_drvdata(i2s->pdev, i2s);\r\nret = platform_device_add(i2s->pdev);\r\nif (ret < 0)\r\nreturn NULL;\r\n}\r\nreturn i2s;\r\n}\r\nstatic inline const struct samsung_i2s_dai_data *samsung_i2s_get_driver_data(\r\nstruct platform_device *pdev)\r\n{\r\n#ifdef CONFIG_OF\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos_i2s_match, pdev->dev.of_node);\r\nreturn match->data;\r\n} else\r\n#endif\r\nreturn (struct samsung_i2s_dai_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nstatic int i2s_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2s_dai *i2s = dev_get_drvdata(dev);\r\nclk_disable_unprepare(i2s->clk);\r\nreturn 0;\r\n}\r\nstatic int i2s_runtime_resume(struct device *dev)\r\n{\r\nstruct i2s_dai *i2s = dev_get_drvdata(dev);\r\nclk_prepare_enable(i2s->clk);\r\nreturn 0;\r\n}\r\nstatic int samsung_i2s_probe(struct platform_device *pdev)\r\n{\r\nstruct i2s_dai *pri_dai, *sec_dai = NULL;\r\nstruct s3c_audio_pdata *i2s_pdata = pdev->dev.platform_data;\r\nstruct samsung_i2s *i2s_cfg = NULL;\r\nstruct resource *res;\r\nu32 regs_base, quirks = 0, idma_addr = 0;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct samsung_i2s_dai_data *i2s_dai_data;\r\nint ret = 0;\r\ni2s_dai_data = samsung_i2s_get_driver_data(pdev);\r\nif (i2s_dai_data->dai_type == TYPE_SEC) {\r\nsec_dai = dev_get_drvdata(&pdev->dev);\r\nif (!sec_dai) {\r\ndev_err(&pdev->dev, "Unable to get drvdata\n");\r\nreturn -EFAULT;\r\n}\r\ndevm_snd_soc_register_component(&sec_dai->pdev->dev,\r\n&samsung_i2s_component,\r\n&sec_dai->i2s_dai_drv, 1);\r\nsamsung_asoc_dma_platform_register(&pdev->dev);\r\nreturn 0;\r\n}\r\npri_dai = i2s_alloc_dai(pdev, false);\r\nif (!pri_dai) {\r\ndev_err(&pdev->dev, "Unable to alloc I2S_pri\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!np) {\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev,\r\n"Unable to get I2S-TX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\npri_dai->dma_playback.channel = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev,\r\n"Unable to get I2S-RX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\npri_dai->dma_capture.channel = res->start;\r\nif (i2s_pdata == NULL) {\r\ndev_err(&pdev->dev, "Can't work without s3c_audio_pdata\n");\r\nreturn -EINVAL;\r\n}\r\nif (&i2s_pdata->type)\r\ni2s_cfg = &i2s_pdata->type.i2s;\r\nif (i2s_cfg) {\r\nquirks = i2s_cfg->quirks;\r\nidma_addr = i2s_cfg->idma_addr;\r\n}\r\n} else {\r\nquirks = i2s_dai_data->quirks;\r\nif (of_property_read_u32(np, "samsung,idma-addr",\r\n&idma_addr)) {\r\nif (quirks & QUIRK_SEC_DAI) {\r\ndev_err(&pdev->dev, "idma address is not"\\r\n"specified");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Unable to get I2S SFR address\n");\r\nreturn -ENXIO;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res),\r\n"samsung-i2s")) {\r\ndev_err(&pdev->dev, "Unable to request SFR region\n");\r\nreturn -EBUSY;\r\n}\r\nregs_base = res->start;\r\npri_dai->dma_playback.dma_addr = regs_base + I2STXD;\r\npri_dai->dma_capture.dma_addr = regs_base + I2SRXD;\r\npri_dai->dma_playback.ch_name = "tx";\r\npri_dai->dma_capture.ch_name = "rx";\r\npri_dai->dma_playback.dma_size = 4;\r\npri_dai->dma_capture.dma_size = 4;\r\npri_dai->base = regs_base;\r\npri_dai->quirks = quirks;\r\nif (quirks & QUIRK_PRI_6CHAN)\r\npri_dai->i2s_dai_drv.playback.channels_max = 6;\r\nif (quirks & QUIRK_SEC_DAI) {\r\nsec_dai = i2s_alloc_dai(pdev, true);\r\nif (!sec_dai) {\r\ndev_err(&pdev->dev, "Unable to alloc I2S_sec\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsec_dai->dma_playback.dma_addr = regs_base + I2STXDS;\r\nsec_dai->dma_playback.ch_name = "tx-sec";\r\nif (!np) {\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 2);\r\nif (res)\r\nsec_dai->dma_playback.channel = res->start;\r\n}\r\nsec_dai->dma_playback.dma_size = 4;\r\nsec_dai->base = regs_base;\r\nsec_dai->quirks = quirks;\r\nsec_dai->idma_playback.dma_addr = idma_addr;\r\nsec_dai->pri_dai = pri_dai;\r\npri_dai->sec_dai = sec_dai;\r\n}\r\nif (i2s_pdata && i2s_pdata->cfg_gpio && i2s_pdata->cfg_gpio(pdev)) {\r\ndev_err(&pdev->dev, "Unable to configure gpio\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndevm_snd_soc_register_component(&pri_dai->pdev->dev,\r\n&samsung_i2s_component,\r\n&pri_dai->i2s_dai_drv, 1);\r\npm_runtime_enable(&pdev->dev);\r\nsamsung_asoc_dma_platform_register(&pdev->dev);\r\nreturn 0;\r\nerr:\r\nif (res)\r\nrelease_mem_region(regs_base, resource_size(res));\r\nreturn ret;\r\n}\r\nstatic int samsung_i2s_remove(struct platform_device *pdev)\r\n{\r\nstruct i2s_dai *i2s, *other;\r\nstruct resource *res;\r\ni2s = dev_get_drvdata(&pdev->dev);\r\nother = i2s->pri_dai ? : i2s->sec_dai;\r\nif (other) {\r\nother->pri_dai = NULL;\r\nother->sec_dai = NULL;\r\n} else {\r\npm_runtime_disable(&pdev->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\n}\r\ni2s->pri_dai = NULL;\r\ni2s->sec_dai = NULL;\r\nreturn 0;\r\n}
