acpi_status acpi_tb_initialize_facs(void)\r\n{\r\nacpi_status status;\r\nif (acpi_gbl_reduced_hardware) {\r\nacpi_gbl_FACS = NULL;\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,\r\nACPI_CAST_INDIRECT_PTR(struct\r\nacpi_table_header,\r\n&acpi_gbl_FACS));\r\nreturn (status);\r\n}\r\nu8 acpi_tb_tables_loaded(void)\r\n{\r\nif (acpi_gbl_root_table_list.current_table_count >= 3) {\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nvoid acpi_tb_check_dsdt_header(void)\r\n{\r\nif (acpi_gbl_original_dsdt_header.length != acpi_gbl_DSDT->length ||\r\nacpi_gbl_original_dsdt_header.checksum != acpi_gbl_DSDT->checksum) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"The DSDT has been corrupted or replaced - "\r\n"old, new headers below"));\r\nacpi_tb_print_table_header(0, &acpi_gbl_original_dsdt_header);\r\nacpi_tb_print_table_header(0, acpi_gbl_DSDT);\r\nACPI_ERROR((AE_INFO,\r\n"Please send DMI info to linux-acpi@vger.kernel.org\n"\r\n"If system does not work as expected, please boot with acpi=copy_dsdt"));\r\nacpi_gbl_original_dsdt_header.length = acpi_gbl_DSDT->length;\r\nacpi_gbl_original_dsdt_header.checksum =\r\nacpi_gbl_DSDT->checksum;\r\n}\r\n}\r\nstruct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index)\r\n{\r\nstruct acpi_table_header *new_table;\r\nstruct acpi_table_desc *table_desc;\r\ntable_desc = &acpi_gbl_root_table_list.tables[table_index];\r\nnew_table = ACPI_ALLOCATE(table_desc->length);\r\nif (!new_table) {\r\nACPI_ERROR((AE_INFO, "Could not copy DSDT of length 0x%X",\r\ntable_desc->length));\r\nreturn (NULL);\r\n}\r\nACPI_MEMCPY(new_table, table_desc->pointer, table_desc->length);\r\nacpi_tb_uninstall_table(table_desc);\r\nacpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.\r\ntables[ACPI_TABLE_INDEX_DSDT],\r\nACPI_PTR_TO_PHYSADDR(new_table),\r\nACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL,\r\nnew_table);\r\nACPI_INFO((AE_INFO,\r\n"Forced DSDT copy: length 0x%05X copied locally, original unmapped",\r\nnew_table->length));\r\nreturn (new_table);\r\n}\r\nstatic acpi_physical_address\r\nacpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size)\r\n{\r\nu64 address64;\r\nif (table_entry_size == ACPI_RSDT_ENTRY_SIZE) {\r\nreturn ((acpi_physical_address)\r\n(*ACPI_CAST_PTR(u32, table_entry)));\r\n} else {\r\nACPI_MOVE_64_TO_64(&address64, table_entry);\r\n#if ACPI_MACHINE_WIDTH == 32\r\nif (address64 > ACPI_UINT32_MAX) {\r\nACPI_BIOS_WARNING((AE_INFO,\r\n"64-bit Physical Address in XSDT is too large (0x%8.8X%8.8X),"\r\n" truncating",\r\nACPI_FORMAT_UINT64(address64)));\r\n}\r\n#endif\r\nreturn ((acpi_physical_address) (address64));\r\n}\r\n}\r\nacpi_status __init acpi_tb_parse_root_table(acpi_physical_address rsdp_address)\r\n{\r\nstruct acpi_table_rsdp *rsdp;\r\nu32 table_entry_size;\r\nu32 i;\r\nu32 table_count;\r\nstruct acpi_table_header *table;\r\nacpi_physical_address address;\r\nu32 length;\r\nu8 *table_entry;\r\nacpi_status status;\r\nu32 table_index;\r\nACPI_FUNCTION_TRACE(tb_parse_root_table);\r\nrsdp = acpi_os_map_memory(rsdp_address, sizeof(struct acpi_table_rsdp));\r\nif (!rsdp) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_tb_print_table_header(rsdp_address,\r\nACPI_CAST_PTR(struct acpi_table_header,\r\nrsdp));\r\nif ((rsdp->revision > 1) &&\r\nrsdp->xsdt_physical_address && !acpi_gbl_do_not_use_xsdt) {\r\naddress = (acpi_physical_address) rsdp->xsdt_physical_address;\r\ntable_entry_size = ACPI_XSDT_ENTRY_SIZE;\r\n} else {\r\naddress = (acpi_physical_address) rsdp->rsdt_physical_address;\r\ntable_entry_size = ACPI_RSDT_ENTRY_SIZE;\r\n}\r\nacpi_os_unmap_memory(rsdp, sizeof(struct acpi_table_rsdp));\r\ntable = acpi_os_map_memory(address, sizeof(struct acpi_table_header));\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nacpi_tb_print_table_header(address, table);\r\nlength = table->length;\r\nacpi_os_unmap_memory(table, sizeof(struct acpi_table_header));\r\nif (length < (sizeof(struct acpi_table_header) + table_entry_size)) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"Invalid table length 0x%X in RSDT/XSDT",\r\nlength));\r\nreturn_ACPI_STATUS(AE_INVALID_TABLE_LENGTH);\r\n}\r\ntable = acpi_os_map_memory(address, length);\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nstatus = acpi_tb_verify_checksum(table, length);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_unmap_memory(table, length);\r\nreturn_ACPI_STATUS(status);\r\n}\r\ntable_count = (u32)((table->length - sizeof(struct acpi_table_header)) /\r\ntable_entry_size);\r\ntable_entry = ACPI_ADD_PTR(u8, table, sizeof(struct acpi_table_header));\r\nacpi_gbl_root_table_list.current_table_count = 2;\r\nfor (i = 0; i < table_count; i++) {\r\naddress =\r\nacpi_tb_get_root_table_entry(table_entry, table_entry_size);\r\nif (!address) {\r\ngoto next_table;\r\n}\r\nstatus = acpi_tb_install_standard_table(address,\r\nACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL,\r\nFALSE, TRUE,\r\n&table_index);\r\nif (ACPI_SUCCESS(status) &&\r\nACPI_COMPARE_NAME(&acpi_gbl_root_table_list.\r\ntables[table_index].signature,\r\nACPI_SIG_FADT)) {\r\nacpi_tb_parse_fadt(table_index);\r\n}\r\nnext_table:\r\ntable_entry += table_entry_size;\r\n}\r\nacpi_os_unmap_memory(table, length);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}
