static inline s64 ntp_offset_chunk(s64 offset)\r\n{\r\nif (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)\r\nreturn offset;\r\nelse\r\nreturn shift_right(offset, SHIFT_PLL + time_constant);\r\n}\r\nstatic inline void pps_reset_freq_interval(void)\r\n{\r\npps_shift = PPS_INTMIN;\r\npps_intcnt = 0;\r\n}\r\nstatic inline void pps_clear(void)\r\n{\r\npps_reset_freq_interval();\r\npps_tf[0] = 0;\r\npps_tf[1] = 0;\r\npps_tf[2] = 0;\r\npps_fbase.tv_sec = pps_fbase.tv_nsec = 0;\r\npps_freq = 0;\r\n}\r\nstatic inline void pps_dec_valid(void)\r\n{\r\nif (pps_valid > 0)\r\npps_valid--;\r\nelse {\r\ntime_status &= ~(STA_PPSSIGNAL | STA_PPSJITTER |\r\nSTA_PPSWANDER | STA_PPSERROR);\r\npps_clear();\r\n}\r\n}\r\nstatic inline void pps_set_freq(s64 freq)\r\n{\r\npps_freq = freq;\r\n}\r\nstatic inline int is_error_status(int status)\r\n{\r\nreturn (status & (STA_UNSYNC|STA_CLOCKERR))\r\n|| ((status & (STA_PPSFREQ|STA_PPSTIME))\r\n&& !(status & STA_PPSSIGNAL))\r\n|| ((status & (STA_PPSTIME|STA_PPSJITTER))\r\n== (STA_PPSTIME|STA_PPSJITTER))\r\n|| ((status & STA_PPSFREQ)\r\n&& (status & (STA_PPSWANDER|STA_PPSERROR)));\r\n}\r\nstatic inline void pps_fill_timex(struct timex *txc)\r\n{\r\ntxc->ppsfreq = shift_right((pps_freq >> PPM_SCALE_INV_SHIFT) *\r\nPPM_SCALE_INV, NTP_SCALE_SHIFT);\r\ntxc->jitter = pps_jitter;\r\nif (!(time_status & STA_NANO))\r\ntxc->jitter /= NSEC_PER_USEC;\r\ntxc->shift = pps_shift;\r\ntxc->stabil = pps_stabil;\r\ntxc->jitcnt = pps_jitcnt;\r\ntxc->calcnt = pps_calcnt;\r\ntxc->errcnt = pps_errcnt;\r\ntxc->stbcnt = pps_stbcnt;\r\n}\r\nstatic inline s64 ntp_offset_chunk(s64 offset)\r\n{\r\nreturn shift_right(offset, SHIFT_PLL + time_constant);\r\n}\r\nstatic inline void pps_reset_freq_interval(void) {}\r\nstatic inline void pps_clear(void) {}\r\nstatic inline void pps_dec_valid(void) {}\r\nstatic inline void pps_set_freq(s64 freq) {}\r\nstatic inline int is_error_status(int status)\r\n{\r\nreturn status & (STA_UNSYNC|STA_CLOCKERR);\r\n}\r\nstatic inline void pps_fill_timex(struct timex *txc)\r\n{\r\ntxc->ppsfreq = 0;\r\ntxc->jitter = 0;\r\ntxc->shift = 0;\r\ntxc->stabil = 0;\r\ntxc->jitcnt = 0;\r\ntxc->calcnt = 0;\r\ntxc->errcnt = 0;\r\ntxc->stbcnt = 0;\r\n}\r\nstatic inline int ntp_synced(void)\r\n{\r\nreturn !(time_status & STA_UNSYNC);\r\n}\r\nstatic void ntp_update_frequency(void)\r\n{\r\nu64 second_length;\r\nu64 new_base;\r\nsecond_length = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\r\n<< NTP_SCALE_SHIFT;\r\nsecond_length += ntp_tick_adj;\r\nsecond_length += time_freq;\r\ntick_nsec = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\r\nnew_base = div_u64(second_length, NTP_INTERVAL_FREQ);\r\ntick_length += new_base - tick_length_base;\r\ntick_length_base = new_base;\r\n}\r\nstatic inline s64 ntp_update_offset_fll(s64 offset64, long secs)\r\n{\r\ntime_status &= ~STA_MODE;\r\nif (secs < MINSEC)\r\nreturn 0;\r\nif (!(time_status & STA_FLL) && (secs <= MAXSEC))\r\nreturn 0;\r\ntime_status |= STA_MODE;\r\nreturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\r\n}\r\nstatic void ntp_update_offset(long offset)\r\n{\r\ns64 freq_adj;\r\ns64 offset64;\r\nlong secs;\r\nif (!(time_status & STA_PLL))\r\nreturn;\r\nif (!(time_status & STA_NANO))\r\noffset *= NSEC_PER_USEC;\r\noffset = min(offset, MAXPHASE);\r\noffset = max(offset, -MAXPHASE);\r\nsecs = get_seconds() - time_reftime;\r\nif (unlikely(time_status & STA_FREQHOLD))\r\nsecs = 0;\r\ntime_reftime = get_seconds();\r\noffset64 = offset;\r\nfreq_adj = ntp_update_offset_fll(offset64, secs);\r\nif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\r\nsecs = 1 << (SHIFT_PLL + 1 + time_constant);\r\nfreq_adj += (offset64 * secs) <<\r\n(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\r\nfreq_adj = min(freq_adj + time_freq, MAXFREQ_SCALED);\r\ntime_freq = max(freq_adj, -MAXFREQ_SCALED);\r\ntime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\r\n}\r\nvoid ntp_clear(void)\r\n{\r\ntime_adjust = 0;\r\ntime_status |= STA_UNSYNC;\r\ntime_maxerror = NTP_PHASE_LIMIT;\r\ntime_esterror = NTP_PHASE_LIMIT;\r\nntp_update_frequency();\r\ntick_length = tick_length_base;\r\ntime_offset = 0;\r\npps_clear();\r\n}\r\nu64 ntp_tick_length(void)\r\n{\r\nreturn tick_length;\r\n}\r\nint second_overflow(unsigned long secs)\r\n{\r\ns64 delta;\r\nint leap = 0;\r\nswitch (time_state) {\r\ncase TIME_OK:\r\nif (time_status & STA_INS)\r\ntime_state = TIME_INS;\r\nelse if (time_status & STA_DEL)\r\ntime_state = TIME_DEL;\r\nbreak;\r\ncase TIME_INS:\r\nif (!(time_status & STA_INS))\r\ntime_state = TIME_OK;\r\nelse if (secs % 86400 == 0) {\r\nleap = -1;\r\ntime_state = TIME_OOP;\r\nprintk(KERN_NOTICE\r\n"Clock: inserting leap second 23:59:60 UTC\n");\r\n}\r\nbreak;\r\ncase TIME_DEL:\r\nif (!(time_status & STA_DEL))\r\ntime_state = TIME_OK;\r\nelse if ((secs + 1) % 86400 == 0) {\r\nleap = 1;\r\ntime_state = TIME_WAIT;\r\nprintk(KERN_NOTICE\r\n"Clock: deleting leap second 23:59:59 UTC\n");\r\n}\r\nbreak;\r\ncase TIME_OOP:\r\ntime_state = TIME_WAIT;\r\nbreak;\r\ncase TIME_WAIT:\r\nif (!(time_status & (STA_INS | STA_DEL)))\r\ntime_state = TIME_OK;\r\nbreak;\r\n}\r\ntime_maxerror += MAXFREQ / NSEC_PER_USEC;\r\nif (time_maxerror > NTP_PHASE_LIMIT) {\r\ntime_maxerror = NTP_PHASE_LIMIT;\r\ntime_status |= STA_UNSYNC;\r\n}\r\ntick_length = tick_length_base;\r\ndelta = ntp_offset_chunk(time_offset);\r\ntime_offset -= delta;\r\ntick_length += delta;\r\npps_dec_valid();\r\nif (!time_adjust)\r\ngoto out;\r\nif (time_adjust > MAX_TICKADJ) {\r\ntime_adjust -= MAX_TICKADJ;\r\ntick_length += MAX_TICKADJ_SCALED;\r\ngoto out;\r\n}\r\nif (time_adjust < -MAX_TICKADJ) {\r\ntime_adjust += MAX_TICKADJ;\r\ntick_length -= MAX_TICKADJ_SCALED;\r\ngoto out;\r\n}\r\ntick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\r\n<< NTP_SCALE_SHIFT;\r\ntime_adjust = 0;\r\nout:\r\nreturn leap;\r\n}\r\nstatic void sync_cmos_clock(struct work_struct *work)\r\n{\r\nstruct timespec64 now;\r\nstruct timespec next;\r\nint fail = 1;\r\nif (!ntp_synced()) {\r\nreturn;\r\n}\r\ngetnstimeofday64(&now);\r\nif (abs(now.tv_nsec - (NSEC_PER_SEC / 2)) <= tick_nsec * 5) {\r\nstruct timespec adjust = timespec64_to_timespec(now);\r\nfail = -ENODEV;\r\nif (persistent_clock_is_local)\r\nadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\r\n#ifdef CONFIG_GENERIC_CMOS_UPDATE\r\nfail = update_persistent_clock(adjust);\r\n#endif\r\n#ifdef CONFIG_RTC_SYSTOHC\r\nif (fail == -ENODEV)\r\nfail = rtc_set_ntp_time(adjust);\r\n#endif\r\n}\r\nnext.tv_nsec = (NSEC_PER_SEC / 2) - now.tv_nsec - (TICK_NSEC / 2);\r\nif (next.tv_nsec <= 0)\r\nnext.tv_nsec += NSEC_PER_SEC;\r\nif (!fail || fail == -ENODEV)\r\nnext.tv_sec = 659;\r\nelse\r\nnext.tv_sec = 0;\r\nif (next.tv_nsec >= NSEC_PER_SEC) {\r\nnext.tv_sec++;\r\nnext.tv_nsec -= NSEC_PER_SEC;\r\n}\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&sync_cmos_work, timespec_to_jiffies(&next));\r\n}\r\nvoid ntp_notify_cmos_timer(void)\r\n{\r\nqueue_delayed_work(system_power_efficient_wq, &sync_cmos_work, 0);\r\n}\r\nvoid ntp_notify_cmos_timer(void) { }\r\nstatic inline void process_adj_status(struct timex *txc, struct timespec64 *ts)\r\n{\r\nif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\r\ntime_state = TIME_OK;\r\ntime_status = STA_UNSYNC;\r\npps_reset_freq_interval();\r\n}\r\nif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\r\ntime_reftime = get_seconds();\r\ntime_status &= STA_RONLY;\r\ntime_status |= txc->status & ~STA_RONLY;\r\n}\r\nstatic inline void process_adjtimex_modes(struct timex *txc,\r\nstruct timespec64 *ts,\r\ns32 *time_tai)\r\n{\r\nif (txc->modes & ADJ_STATUS)\r\nprocess_adj_status(txc, ts);\r\nif (txc->modes & ADJ_NANO)\r\ntime_status |= STA_NANO;\r\nif (txc->modes & ADJ_MICRO)\r\ntime_status &= ~STA_NANO;\r\nif (txc->modes & ADJ_FREQUENCY) {\r\ntime_freq = txc->freq * PPM_SCALE;\r\ntime_freq = min(time_freq, MAXFREQ_SCALED);\r\ntime_freq = max(time_freq, -MAXFREQ_SCALED);\r\npps_set_freq(time_freq);\r\n}\r\nif (txc->modes & ADJ_MAXERROR)\r\ntime_maxerror = txc->maxerror;\r\nif (txc->modes & ADJ_ESTERROR)\r\ntime_esterror = txc->esterror;\r\nif (txc->modes & ADJ_TIMECONST) {\r\ntime_constant = txc->constant;\r\nif (!(time_status & STA_NANO))\r\ntime_constant += 4;\r\ntime_constant = min(time_constant, (long)MAXTC);\r\ntime_constant = max(time_constant, 0l);\r\n}\r\nif (txc->modes & ADJ_TAI && txc->constant > 0)\r\n*time_tai = txc->constant;\r\nif (txc->modes & ADJ_OFFSET)\r\nntp_update_offset(txc->offset);\r\nif (txc->modes & ADJ_TICK)\r\ntick_usec = txc->tick;\r\nif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\r\nntp_update_frequency();\r\n}\r\nint ntp_validate_timex(struct timex *txc)\r\n{\r\nif (txc->modes & ADJ_ADJTIME) {\r\nif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\r\nreturn -EINVAL;\r\nif (!(txc->modes & ADJ_OFFSET_READONLY) &&\r\n!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\n} else {\r\nif (txc->modes && !capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\nif (txc->modes & ADJ_TICK &&\r\n(txc->tick < 900000/USER_HZ ||\r\ntxc->tick > 1100000/USER_HZ))\r\nreturn -EINVAL;\r\n}\r\nif ((txc->modes & ADJ_SETOFFSET) && (!capable(CAP_SYS_TIME)))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nint __do_adjtimex(struct timex *txc, struct timespec64 *ts, s32 *time_tai)\r\n{\r\nint result;\r\nif (txc->modes & ADJ_ADJTIME) {\r\nlong save_adjust = time_adjust;\r\nif (!(txc->modes & ADJ_OFFSET_READONLY)) {\r\ntime_adjust = txc->offset;\r\nntp_update_frequency();\r\n}\r\ntxc->offset = save_adjust;\r\n} else {\r\nif (txc->modes)\r\nprocess_adjtimex_modes(txc, ts, time_tai);\r\ntxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\r\nNTP_SCALE_SHIFT);\r\nif (!(time_status & STA_NANO))\r\ntxc->offset /= NSEC_PER_USEC;\r\n}\r\nresult = time_state;\r\nif (is_error_status(time_status))\r\nresult = TIME_ERROR;\r\ntxc->freq = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\r\nPPM_SCALE_INV, NTP_SCALE_SHIFT);\r\ntxc->maxerror = time_maxerror;\r\ntxc->esterror = time_esterror;\r\ntxc->status = time_status;\r\ntxc->constant = time_constant;\r\ntxc->precision = 1;\r\ntxc->tolerance = MAXFREQ_SCALED / PPM_SCALE;\r\ntxc->tick = tick_usec;\r\ntxc->tai = *time_tai;\r\npps_fill_timex(txc);\r\ntxc->time.tv_sec = (time_t)ts->tv_sec;\r\ntxc->time.tv_usec = ts->tv_nsec;\r\nif (!(time_status & STA_NANO))\r\ntxc->time.tv_usec /= NSEC_PER_USEC;\r\nreturn result;\r\n}\r\nstatic inline struct pps_normtime pps_normalize_ts(struct timespec ts)\r\n{\r\nstruct pps_normtime norm = {\r\n.sec = ts.tv_sec,\r\n.nsec = ts.tv_nsec\r\n};\r\nif (norm.nsec > (NSEC_PER_SEC >> 1)) {\r\nnorm.nsec -= NSEC_PER_SEC;\r\nnorm.sec++;\r\n}\r\nreturn norm;\r\n}\r\nstatic inline long pps_phase_filter_get(long *jitter)\r\n{\r\n*jitter = pps_tf[0] - pps_tf[1];\r\nif (*jitter < 0)\r\n*jitter = -*jitter;\r\nreturn pps_tf[0];\r\n}\r\nstatic inline void pps_phase_filter_add(long err)\r\n{\r\npps_tf[2] = pps_tf[1];\r\npps_tf[1] = pps_tf[0];\r\npps_tf[0] = err;\r\n}\r\nstatic inline void pps_dec_freq_interval(void)\r\n{\r\nif (--pps_intcnt <= -PPS_INTCOUNT) {\r\npps_intcnt = -PPS_INTCOUNT;\r\nif (pps_shift > PPS_INTMIN) {\r\npps_shift--;\r\npps_intcnt = 0;\r\n}\r\n}\r\n}\r\nstatic inline void pps_inc_freq_interval(void)\r\n{\r\nif (++pps_intcnt >= PPS_INTCOUNT) {\r\npps_intcnt = PPS_INTCOUNT;\r\nif (pps_shift < PPS_INTMAX) {\r\npps_shift++;\r\npps_intcnt = 0;\r\n}\r\n}\r\n}\r\nstatic long hardpps_update_freq(struct pps_normtime freq_norm)\r\n{\r\nlong delta, delta_mod;\r\ns64 ftemp;\r\nif (freq_norm.sec > (2 << pps_shift)) {\r\ntime_status |= STA_PPSERROR;\r\npps_errcnt++;\r\npps_dec_freq_interval();\r\nprintk_deferred(KERN_ERR\r\n"hardpps: PPSERROR: interval too long - %ld s\n",\r\nfreq_norm.sec);\r\nreturn 0;\r\n}\r\nftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\r\nfreq_norm.sec);\r\ndelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\r\npps_freq = ftemp;\r\nif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\r\nprintk_deferred(KERN_WARNING\r\n"hardpps: PPSWANDER: change=%ld\n", delta);\r\ntime_status |= STA_PPSWANDER;\r\npps_stbcnt++;\r\npps_dec_freq_interval();\r\n} else {\r\npps_inc_freq_interval();\r\n}\r\ndelta_mod = delta;\r\nif (delta_mod < 0)\r\ndelta_mod = -delta_mod;\r\npps_stabil += (div_s64(((s64)delta_mod) <<\r\n(NTP_SCALE_SHIFT - SHIFT_USEC),\r\nNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\r\nif ((time_status & STA_PPSFREQ) != 0 &&\r\n(time_status & STA_FREQHOLD) == 0) {\r\ntime_freq = pps_freq;\r\nntp_update_frequency();\r\n}\r\nreturn delta;\r\n}\r\nstatic void hardpps_update_phase(long error)\r\n{\r\nlong correction = -error;\r\nlong jitter;\r\npps_phase_filter_add(correction);\r\ncorrection = pps_phase_filter_get(&jitter);\r\nif (jitter > (pps_jitter << PPS_POPCORN)) {\r\nprintk_deferred(KERN_WARNING\r\n"hardpps: PPSJITTER: jitter=%ld, limit=%ld\n",\r\njitter, (pps_jitter << PPS_POPCORN));\r\ntime_status |= STA_PPSJITTER;\r\npps_jitcnt++;\r\n} else if (time_status & STA_PPSTIME) {\r\ntime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\r\nNTP_INTERVAL_FREQ);\r\ntime_adjust = 0;\r\n}\r\npps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\r\n}\r\nvoid __hardpps(const struct timespec *phase_ts, const struct timespec *raw_ts)\r\n{\r\nstruct pps_normtime pts_norm, freq_norm;\r\npts_norm = pps_normalize_ts(*phase_ts);\r\ntime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\r\ntime_status |= STA_PPSSIGNAL;\r\npps_valid = PPS_VALID;\r\nif (unlikely(pps_fbase.tv_sec == 0)) {\r\npps_fbase = *raw_ts;\r\nreturn;\r\n}\r\nfreq_norm = pps_normalize_ts(timespec_sub(*raw_ts, pps_fbase));\r\nif ((freq_norm.sec == 0) ||\r\n(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\r\n(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\r\ntime_status |= STA_PPSJITTER;\r\npps_fbase = *raw_ts;\r\nprintk_deferred(KERN_ERR "hardpps: PPSJITTER: bad pulse\n");\r\nreturn;\r\n}\r\nif (freq_norm.sec >= (1 << pps_shift)) {\r\npps_calcnt++;\r\npps_fbase = *raw_ts;\r\nhardpps_update_freq(freq_norm);\r\n}\r\nhardpps_update_phase(pts_norm.nsec);\r\n}\r\nstatic int __init ntp_tick_adj_setup(char *str)\r\n{\r\nint rc = kstrtol(str, 0, (long *)&ntp_tick_adj);\r\nif (rc)\r\nreturn rc;\r\nntp_tick_adj <<= NTP_SCALE_SHIFT;\r\nreturn 1;\r\n}\r\nvoid __init ntp_init(void)\r\n{\r\nntp_clear();\r\n}
