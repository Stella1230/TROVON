struct dma_info *get_dma_info(unsigned int chan)\r\n{\r\nstruct dma_info *info;\r\nlist_for_each_entry(info, &registered_dmac_list, list) {\r\nif ((chan < info->first_vchannel_nr) ||\r\n(chan >= info->first_vchannel_nr + info->nr_channels))\r\ncontinue;\r\nreturn info;\r\n}\r\nreturn NULL;\r\n}\r\nstruct dma_info *get_dma_info_by_name(const char *dmac_name)\r\n{\r\nstruct dma_info *info;\r\nlist_for_each_entry(info, &registered_dmac_list, list) {\r\nif (dmac_name && (strcmp(dmac_name, info->name) != 0))\r\ncontinue;\r\nelse\r\nreturn info;\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int get_nr_channels(void)\r\n{\r\nstruct dma_info *info;\r\nunsigned int nr = 0;\r\nif (unlikely(list_empty(&registered_dmac_list)))\r\nreturn nr;\r\nlist_for_each_entry(info, &registered_dmac_list, list)\r\nnr += info->nr_channels;\r\nreturn nr;\r\n}\r\nstruct dma_channel *get_dma_channel(unsigned int chan)\r\n{\r\nstruct dma_info *info = get_dma_info(chan);\r\nstruct dma_channel *channel;\r\nint i;\r\nif (unlikely(!info))\r\nreturn ERR_PTR(-EINVAL);\r\nfor (i = 0; i < info->nr_channels; i++) {\r\nchannel = &info->channels[i];\r\nif (channel->vchan == chan)\r\nreturn channel;\r\n}\r\nreturn NULL;\r\n}\r\nint get_dma_residue(unsigned int chan)\r\n{\r\nstruct dma_info *info = get_dma_info(chan);\r\nstruct dma_channel *channel = get_dma_channel(chan);\r\nif (info->ops->get_residue)\r\nreturn info->ops->get_residue(channel);\r\nreturn 0;\r\n}\r\nstatic int search_cap(const char **haystack, const char *needle)\r\n{\r\nconst char **p;\r\nfor (p = haystack; *p; p++)\r\nif (strcmp(*p, needle) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint request_dma_bycap(const char **dmac, const char **caps, const char *dev_id)\r\n{\r\nunsigned int found = 0;\r\nstruct dma_info *info;\r\nconst char **p;\r\nint i;\r\nBUG_ON(!dmac || !caps);\r\nlist_for_each_entry(info, &registered_dmac_list, list)\r\nif (strcmp(*dmac, info->name) == 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn -ENODEV;\r\nfor (i = 0; i < info->nr_channels; i++) {\r\nstruct dma_channel *channel = &info->channels[i];\r\nif (unlikely(!channel->caps))\r\ncontinue;\r\nfor (p = caps; *p; p++) {\r\nif (!search_cap(channel->caps, *p))\r\nbreak;\r\nif (request_dma(channel->chan, dev_id) == 0)\r\nreturn channel->chan;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint dmac_search_free_channel(const char *dev_id)\r\n{\r\nstruct dma_channel *channel = { 0 };\r\nstruct dma_info *info = get_dma_info(0);\r\nint i;\r\nfor (i = 0; i < info->nr_channels; i++) {\r\nchannel = &info->channels[i];\r\nif (unlikely(!channel))\r\nreturn -ENODEV;\r\nif (atomic_read(&channel->busy) == 0)\r\nbreak;\r\n}\r\nif (info->ops->request) {\r\nint result = info->ops->request(channel);\r\nif (result)\r\nreturn result;\r\natomic_set(&channel->busy, 1);\r\nreturn channel->chan;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nint request_dma(unsigned int chan, const char *dev_id)\r\n{\r\nstruct dma_channel *channel = { 0 };\r\nstruct dma_info *info = get_dma_info(chan);\r\nint result;\r\nchannel = get_dma_channel(chan);\r\nif (atomic_xchg(&channel->busy, 1))\r\nreturn -EBUSY;\r\nstrlcpy(channel->dev_id, dev_id, sizeof(channel->dev_id));\r\nif (info->ops->request) {\r\nresult = info->ops->request(channel);\r\nif (result)\r\natomic_set(&channel->busy, 0);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nvoid free_dma(unsigned int chan)\r\n{\r\nstruct dma_info *info = get_dma_info(chan);\r\nstruct dma_channel *channel = get_dma_channel(chan);\r\nif (info->ops->free)\r\ninfo->ops->free(channel);\r\natomic_set(&channel->busy, 0);\r\n}\r\nvoid dma_wait_for_completion(unsigned int chan)\r\n{\r\nstruct dma_info *info = get_dma_info(chan);\r\nstruct dma_channel *channel = get_dma_channel(chan);\r\nif (channel->flags & DMA_TEI_CAPABLE) {\r\nwait_event(channel->wait_queue,\r\n(info->ops->get_residue(channel) == 0));\r\nreturn;\r\n}\r\nwhile (info->ops->get_residue(channel))\r\ncpu_relax();\r\n}\r\nint register_chan_caps(const char *dmac, struct dma_chan_caps *caps)\r\n{\r\nstruct dma_info *info;\r\nunsigned int found = 0;\r\nint i;\r\nlist_for_each_entry(info, &registered_dmac_list, list)\r\nif (strcmp(dmac, info->name) == 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\nif (unlikely(!found))\r\nreturn -ENODEV;\r\nfor (i = 0; i < info->nr_channels; i++, caps++) {\r\nstruct dma_channel *channel;\r\nif ((info->first_channel_nr + i) != caps->ch_num)\r\nreturn -EINVAL;\r\nchannel = &info->channels[i];\r\nchannel->caps = caps->caplist;\r\n}\r\nreturn 0;\r\n}\r\nvoid dma_configure_channel(unsigned int chan, unsigned long flags)\r\n{\r\nstruct dma_info *info = get_dma_info(chan);\r\nstruct dma_channel *channel = get_dma_channel(chan);\r\nif (info->ops->configure)\r\ninfo->ops->configure(channel, flags);\r\n}\r\nint dma_xfer(unsigned int chan, unsigned long from,\r\nunsigned long to, size_t size, unsigned int mode)\r\n{\r\nstruct dma_info *info = get_dma_info(chan);\r\nstruct dma_channel *channel = get_dma_channel(chan);\r\nchannel->sar = from;\r\nchannel->dar = to;\r\nchannel->count = size;\r\nchannel->mode = mode;\r\nreturn info->ops->xfer(channel);\r\n}\r\nint dma_extend(unsigned int chan, unsigned long op, void *param)\r\n{\r\nstruct dma_info *info = get_dma_info(chan);\r\nstruct dma_channel *channel = get_dma_channel(chan);\r\nif (info->ops->extend)\r\nreturn info->ops->extend(channel, op, param);\r\nreturn -ENOSYS;\r\n}\r\nstatic int dma_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct dma_info *info = v;\r\nif (list_empty(&registered_dmac_list))\r\nreturn 0;\r\nlist_for_each_entry(info, &registered_dmac_list, list) {\r\nint i;\r\nfor (i = 0; i < info->nr_channels; i++) {\r\nstruct dma_channel *channel = info->channels + i;\r\nif (!(channel->flags & DMA_CONFIGURED))\r\ncontinue;\r\nseq_printf(m, "%2d: %14s %s\n", i,\r\ninfo->name, channel->dev_id);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dma_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dma_proc_show, NULL);\r\n}\r\nint register_dmac(struct dma_info *info)\r\n{\r\nunsigned int total_channels, i;\r\nINIT_LIST_HEAD(&info->list);\r\nprintk(KERN_INFO "DMA: Registering %s handler (%d channel%s).\n",\r\ninfo->name, info->nr_channels, info->nr_channels > 1 ? "s" : "");\r\nBUG_ON((info->flags & DMAC_CHANNELS_CONFIGURED) && !info->channels);\r\ninfo->pdev = platform_device_register_simple(info->name, -1,\r\nNULL, 0);\r\nif (IS_ERR(info->pdev))\r\nreturn PTR_ERR(info->pdev);\r\nif (!(info->flags & DMAC_CHANNELS_CONFIGURED)) {\r\nunsigned int size;\r\nsize = sizeof(struct dma_channel) * info->nr_channels;\r\ninfo->channels = kzalloc(size, GFP_KERNEL);\r\nif (!info->channels)\r\nreturn -ENOMEM;\r\n}\r\ntotal_channels = get_nr_channels();\r\ninfo->first_vchannel_nr = total_channels;\r\nfor (i = 0; i < info->nr_channels; i++) {\r\nstruct dma_channel *chan = &info->channels[i];\r\natomic_set(&chan->busy, 0);\r\nchan->chan = info->first_channel_nr + i;\r\nchan->vchan = info->first_channel_nr + i + total_channels;\r\nmemcpy(chan->dev_id, "Unused", 7);\r\nif (info->flags & DMAC_CHANNELS_TEI_CAPABLE)\r\nchan->flags |= DMA_TEI_CAPABLE;\r\ninit_waitqueue_head(&chan->wait_queue);\r\ndma_create_sysfs_files(chan, info);\r\n}\r\nlist_add(&info->list, &registered_dmac_list);\r\nreturn 0;\r\n}\r\nvoid unregister_dmac(struct dma_info *info)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < info->nr_channels; i++)\r\ndma_remove_sysfs_files(info->channels + i, info);\r\nif (!(info->flags & DMAC_CHANNELS_CONFIGURED))\r\nkfree(info->channels);\r\nlist_del(&info->list);\r\nplatform_device_unregister(info->pdev);\r\n}\r\nstatic int __init dma_api_init(void)\r\n{\r\nprintk(KERN_NOTICE "DMA: Registering DMA API.\n");\r\nreturn proc_create("dma", 0, NULL, &dma_proc_fops) ? 0 : -ENOMEM;\r\n}
