static struct intel_crt *intel_encoder_to_crt(struct intel_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct intel_crt, base);\r\n}\r\nstatic struct intel_crt *intel_attached_crt(struct drm_connector *connector)\r\n{\r\nreturn intel_encoder_to_crt(intel_attached_encoder(connector));\r\n}\r\nstatic bool intel_crt_get_hw_state(struct intel_encoder *encoder,\r\nenum pipe *pipe)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crt *crt = intel_encoder_to_crt(encoder);\r\nenum intel_display_power_domain power_domain;\r\nu32 tmp;\r\npower_domain = intel_display_port_power_domain(encoder);\r\nif (!intel_display_power_enabled(dev_priv, power_domain))\r\nreturn false;\r\ntmp = I915_READ(crt->adpa_reg);\r\nif (!(tmp & ADPA_DAC_ENABLE))\r\nreturn false;\r\nif (HAS_PCH_CPT(dev))\r\n*pipe = PORT_TO_PIPE_CPT(tmp);\r\nelse\r\n*pipe = PORT_TO_PIPE(tmp);\r\nreturn true;\r\n}\r\nstatic unsigned int intel_crt_get_flags(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = encoder->base.dev->dev_private;\r\nstruct intel_crt *crt = intel_encoder_to_crt(encoder);\r\nu32 tmp, flags = 0;\r\ntmp = I915_READ(crt->adpa_reg);\r\nif (tmp & ADPA_HSYNC_ACTIVE_HIGH)\r\nflags |= DRM_MODE_FLAG_PHSYNC;\r\nelse\r\nflags |= DRM_MODE_FLAG_NHSYNC;\r\nif (tmp & ADPA_VSYNC_ACTIVE_HIGH)\r\nflags |= DRM_MODE_FLAG_PVSYNC;\r\nelse\r\nflags |= DRM_MODE_FLAG_NVSYNC;\r\nreturn flags;\r\n}\r\nstatic void intel_crt_get_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nint dotclock;\r\npipe_config->adjusted_mode.flags |= intel_crt_get_flags(encoder);\r\ndotclock = pipe_config->port_clock;\r\nif (HAS_PCH_SPLIT(dev))\r\nironlake_check_encoder_dotclock(pipe_config, dotclock);\r\npipe_config->adjusted_mode.crtc_clock = dotclock;\r\n}\r\nstatic void hsw_crt_get_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\nintel_ddi_get_config(encoder, pipe_config);\r\npipe_config->adjusted_mode.flags &= ~(DRM_MODE_FLAG_PHSYNC |\r\nDRM_MODE_FLAG_NHSYNC |\r\nDRM_MODE_FLAG_PVSYNC |\r\nDRM_MODE_FLAG_NVSYNC);\r\npipe_config->adjusted_mode.flags |= intel_crt_get_flags(encoder);\r\n}\r\nstatic void hsw_crt_pre_enable(struct intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nWARN(I915_READ(SPLL_CTL) & SPLL_PLL_ENABLE, "SPLL already enabled\n");\r\nI915_WRITE(SPLL_CTL,\r\nSPLL_PLL_ENABLE | SPLL_PLL_FREQ_1350MHz | SPLL_PLL_SSC);\r\nPOSTING_READ(SPLL_CTL);\r\nudelay(20);\r\n}\r\nstatic void intel_crt_set_dpms(struct intel_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crt *crt = intel_encoder_to_crt(encoder);\r\nstruct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);\r\nstruct drm_display_mode *adjusted_mode = &crtc->config.adjusted_mode;\r\nu32 adpa;\r\nif (INTEL_INFO(dev)->gen >= 5)\r\nadpa = ADPA_HOTPLUG_BITS;\r\nelse\r\nadpa = 0;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nadpa |= ADPA_HSYNC_ACTIVE_HIGH;\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nadpa |= ADPA_VSYNC_ACTIVE_HIGH;\r\nif (HAS_PCH_LPT(dev))\r\n;\r\nelse if (HAS_PCH_CPT(dev))\r\nadpa |= PORT_TRANS_SEL_CPT(crtc->pipe);\r\nelse if (crtc->pipe == 0)\r\nadpa |= ADPA_PIPE_A_SELECT;\r\nelse\r\nadpa |= ADPA_PIPE_B_SELECT;\r\nif (!HAS_PCH_SPLIT(dev))\r\nI915_WRITE(BCLRPAT(crtc->pipe), 0);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nadpa |= ADPA_DAC_ENABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\nadpa |= ADPA_DAC_ENABLE | ADPA_HSYNC_CNTL_DISABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nadpa |= ADPA_DAC_ENABLE | ADPA_VSYNC_CNTL_DISABLE;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nadpa |= ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE;\r\nbreak;\r\n}\r\nI915_WRITE(crt->adpa_reg, adpa);\r\n}\r\nstatic void intel_disable_crt(struct intel_encoder *encoder)\r\n{\r\nintel_crt_set_dpms(encoder, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void hsw_crt_post_disable(struct intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nuint32_t val;\r\nDRM_DEBUG_KMS("Disabling SPLL\n");\r\nval = I915_READ(SPLL_CTL);\r\nWARN_ON(!(val & SPLL_PLL_ENABLE));\r\nI915_WRITE(SPLL_CTL, val & ~SPLL_PLL_ENABLE);\r\nPOSTING_READ(SPLL_CTL);\r\n}\r\nstatic void intel_enable_crt(struct intel_encoder *encoder)\r\n{\r\nstruct intel_crt *crt = intel_encoder_to_crt(encoder);\r\nintel_crt_set_dpms(encoder, crt->connector->base.dpms);\r\n}\r\nstatic void intel_crt_dpms(struct drm_connector *connector, int mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct intel_encoder *encoder = intel_attached_encoder(connector);\r\nstruct drm_crtc *crtc;\r\nint old_dpms;\r\nif (INTEL_INFO(dev)->gen >= 5 && mode != DRM_MODE_DPMS_ON)\r\nmode = DRM_MODE_DPMS_OFF;\r\nif (mode == connector->dpms)\r\nreturn;\r\nold_dpms = connector->dpms;\r\nconnector->dpms = mode;\r\ncrtc = encoder->base.crtc;\r\nif (!crtc) {\r\nencoder->connectors_active = false;\r\nreturn;\r\n}\r\nif (mode == DRM_MODE_DPMS_OFF)\r\nencoder->connectors_active = false;\r\nelse\r\nencoder->connectors_active = true;\r\nif (mode < old_dpms) {\r\nintel_crtc_update_dpms(crtc);\r\nintel_crt_set_dpms(encoder, mode);\r\n} else {\r\nintel_crt_set_dpms(encoder, mode);\r\nintel_crtc_update_dpms(crtc);\r\n}\r\nintel_modeset_check_state(connector->dev);\r\n}\r\nstatic enum drm_mode_status\r\nintel_crt_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nint max_clock = 0;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (mode->clock < 25000)\r\nreturn MODE_CLOCK_LOW;\r\nif (IS_GEN2(dev))\r\nmax_clock = 350000;\r\nelse\r\nmax_clock = 400000;\r\nif (mode->clock > max_clock)\r\nreturn MODE_CLOCK_HIGH;\r\nif (HAS_PCH_LPT(dev) &&\r\n(ironlake_get_lanes_required(mode->clock, 270000, 24) > 2))\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic bool intel_crt_compute_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nif (HAS_PCH_SPLIT(dev))\r\npipe_config->has_pch_encoder = true;\r\nif (HAS_PCH_LPT(dev))\r\npipe_config->pipe_bpp = 24;\r\nif (HAS_DDI(dev)) {\r\npipe_config->ddi_pll_sel = PORT_CLK_SEL_SPLL;\r\npipe_config->port_clock = 135000 * 2;\r\n}\r\nreturn true;\r\n}\r\nstatic bool intel_ironlake_crt_detect_hotplug(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 adpa;\r\nbool ret;\r\nif (crt->force_hotplug_required) {\r\nbool turn_off_dac = HAS_PCH_SPLIT(dev);\r\nu32 save_adpa;\r\ncrt->force_hotplug_required = 0;\r\nsave_adpa = adpa = I915_READ(crt->adpa_reg);\r\nDRM_DEBUG_KMS("trigger hotplug detect cycle: adpa=0x%x\n", adpa);\r\nadpa |= ADPA_CRT_HOTPLUG_FORCE_TRIGGER;\r\nif (turn_off_dac)\r\nadpa &= ~ADPA_DAC_ENABLE;\r\nI915_WRITE(crt->adpa_reg, adpa);\r\nif (wait_for((I915_READ(crt->adpa_reg) & ADPA_CRT_HOTPLUG_FORCE_TRIGGER) == 0,\r\n1000))\r\nDRM_DEBUG_KMS("timed out waiting for FORCE_TRIGGER");\r\nif (turn_off_dac) {\r\nI915_WRITE(crt->adpa_reg, save_adpa);\r\nPOSTING_READ(crt->adpa_reg);\r\n}\r\n}\r\nadpa = I915_READ(crt->adpa_reg);\r\nif ((adpa & ADPA_CRT_HOTPLUG_MONITOR_MASK) != 0)\r\nret = true;\r\nelse\r\nret = false;\r\nDRM_DEBUG_KMS("ironlake hotplug adpa=0x%x, result %d\n", adpa, ret);\r\nreturn ret;\r\n}\r\nstatic bool valleyview_crt_detect_hotplug(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 adpa;\r\nbool ret;\r\nu32 save_adpa;\r\nsave_adpa = adpa = I915_READ(crt->adpa_reg);\r\nDRM_DEBUG_KMS("trigger hotplug detect cycle: adpa=0x%x\n", adpa);\r\nadpa |= ADPA_CRT_HOTPLUG_FORCE_TRIGGER;\r\nI915_WRITE(crt->adpa_reg, adpa);\r\nif (wait_for((I915_READ(crt->adpa_reg) & ADPA_CRT_HOTPLUG_FORCE_TRIGGER) == 0,\r\n1000)) {\r\nDRM_DEBUG_KMS("timed out waiting for FORCE_TRIGGER");\r\nI915_WRITE(crt->adpa_reg, save_adpa);\r\n}\r\nadpa = I915_READ(crt->adpa_reg);\r\nif ((adpa & ADPA_CRT_HOTPLUG_MONITOR_MASK) != 0)\r\nret = true;\r\nelse\r\nret = false;\r\nDRM_DEBUG_KMS("valleyview hotplug adpa=0x%x, result %d\n", adpa, ret);\r\nreturn ret;\r\n}\r\nstatic bool intel_crt_detect_hotplug(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 hotplug_en, orig, stat;\r\nbool ret = false;\r\nint i, tries = 0;\r\nif (HAS_PCH_SPLIT(dev))\r\nreturn intel_ironlake_crt_detect_hotplug(connector);\r\nif (IS_VALLEYVIEW(dev))\r\nreturn valleyview_crt_detect_hotplug(connector);\r\nif (IS_G4X(dev) && !IS_GM45(dev))\r\ntries = 2;\r\nelse\r\ntries = 1;\r\nhotplug_en = orig = I915_READ(PORT_HOTPLUG_EN);\r\nhotplug_en |= CRT_HOTPLUG_FORCE_DETECT;\r\nfor (i = 0; i < tries ; i++) {\r\nI915_WRITE(PORT_HOTPLUG_EN, hotplug_en);\r\nif (wait_for((I915_READ(PORT_HOTPLUG_EN) &\r\nCRT_HOTPLUG_FORCE_DETECT) == 0,\r\n1000))\r\nDRM_DEBUG_KMS("timed out waiting for FORCE_DETECT to go off");\r\n}\r\nstat = I915_READ(PORT_HOTPLUG_STAT);\r\nif ((stat & CRT_HOTPLUG_MONITOR_MASK) != CRT_HOTPLUG_MONITOR_NONE)\r\nret = true;\r\nI915_WRITE(PORT_HOTPLUG_STAT, CRT_HOTPLUG_INT_STATUS);\r\nI915_WRITE(PORT_HOTPLUG_EN, orig);\r\nreturn ret;\r\n}\r\nstatic struct edid *intel_crt_get_edid(struct drm_connector *connector,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct edid *edid;\r\nedid = drm_get_edid(connector, i2c);\r\nif (!edid && !intel_gmbus_is_forced_bit(i2c)) {\r\nDRM_DEBUG_KMS("CRT GMBUS EDID read failed, retry using GPIO bit-banging\n");\r\nintel_gmbus_force_bit(i2c, true);\r\nedid = drm_get_edid(connector, i2c);\r\nintel_gmbus_force_bit(i2c, false);\r\n}\r\nreturn edid;\r\n}\r\nstatic int intel_crt_ddc_get_modes(struct drm_connector *connector,\r\nstruct i2c_adapter *adapter)\r\n{\r\nstruct edid *edid;\r\nint ret;\r\nedid = intel_crt_get_edid(connector, adapter);\r\nif (!edid)\r\nreturn 0;\r\nret = intel_connector_update_modes(connector, edid);\r\nkfree(edid);\r\nreturn ret;\r\n}\r\nstatic bool intel_crt_detect_ddc(struct drm_connector *connector)\r\n{\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nstruct drm_i915_private *dev_priv = crt->base.base.dev->dev_private;\r\nstruct edid *edid;\r\nstruct i2c_adapter *i2c;\r\nBUG_ON(crt->base.type != INTEL_OUTPUT_ANALOG);\r\ni2c = intel_gmbus_get_adapter(dev_priv, dev_priv->vbt.crt_ddc_pin);\r\nedid = intel_crt_get_edid(connector, i2c);\r\nif (edid) {\r\nbool is_digital = edid->input & DRM_EDID_INPUT_DIGITAL;\r\nif (!is_digital) {\r\nDRM_DEBUG_KMS("CRT detected via DDC:0x50 [EDID]\n");\r\nreturn true;\r\n}\r\nDRM_DEBUG_KMS("CRT not detected via DDC:0x50 [EDID reports a digital panel]\n");\r\n} else {\r\nDRM_DEBUG_KMS("CRT not detected via DDC:0x50 [no valid EDID found]\n");\r\n}\r\nkfree(edid);\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status\r\nintel_crt_load_detect(struct intel_crt *crt)\r\n{\r\nstruct drm_device *dev = crt->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nuint32_t pipe = to_intel_crtc(crt->base.base.crtc)->pipe;\r\nuint32_t save_bclrpat;\r\nuint32_t save_vtotal;\r\nuint32_t vtotal, vactive;\r\nuint32_t vsample;\r\nuint32_t vblank, vblank_start, vblank_end;\r\nuint32_t dsl;\r\nuint32_t bclrpat_reg;\r\nuint32_t vtotal_reg;\r\nuint32_t vblank_reg;\r\nuint32_t vsync_reg;\r\nuint32_t pipeconf_reg;\r\nuint32_t pipe_dsl_reg;\r\nuint8_t st00;\r\nenum drm_connector_status status;\r\nDRM_DEBUG_KMS("starting load-detect on CRT\n");\r\nbclrpat_reg = BCLRPAT(pipe);\r\nvtotal_reg = VTOTAL(pipe);\r\nvblank_reg = VBLANK(pipe);\r\nvsync_reg = VSYNC(pipe);\r\npipeconf_reg = PIPECONF(pipe);\r\npipe_dsl_reg = PIPEDSL(pipe);\r\nsave_bclrpat = I915_READ(bclrpat_reg);\r\nsave_vtotal = I915_READ(vtotal_reg);\r\nvblank = I915_READ(vblank_reg);\r\nvtotal = ((save_vtotal >> 16) & 0xfff) + 1;\r\nvactive = (save_vtotal & 0x7ff) + 1;\r\nvblank_start = (vblank & 0xfff) + 1;\r\nvblank_end = ((vblank >> 16) & 0xfff) + 1;\r\nI915_WRITE(bclrpat_reg, 0x500050);\r\nif (!IS_GEN2(dev)) {\r\nuint32_t pipeconf = I915_READ(pipeconf_reg);\r\nI915_WRITE(pipeconf_reg, pipeconf | PIPECONF_FORCE_BORDER);\r\nPOSTING_READ(pipeconf_reg);\r\nintel_wait_for_vblank(dev, pipe);\r\nst00 = I915_READ8(VGA_MSR_WRITE);\r\nstatus = ((st00 & (1 << 4)) != 0) ?\r\nconnector_status_connected :\r\nconnector_status_disconnected;\r\nI915_WRITE(pipeconf_reg, pipeconf);\r\n} else {\r\nbool restore_vblank = false;\r\nint count, detect;\r\nif (vblank_start <= vactive && vblank_end >= vtotal) {\r\nuint32_t vsync = I915_READ(vsync_reg);\r\nuint32_t vsync_start = (vsync & 0xffff) + 1;\r\nvblank_start = vsync_start;\r\nI915_WRITE(vblank_reg,\r\n(vblank_start - 1) |\r\n((vblank_end - 1) << 16));\r\nrestore_vblank = true;\r\n}\r\nif (vblank_start - vactive >= vtotal - vblank_end)\r\nvsample = (vblank_start + vactive) >> 1;\r\nelse\r\nvsample = (vtotal + vblank_end) >> 1;\r\nwhile (I915_READ(pipe_dsl_reg) >= vactive)\r\n;\r\nwhile ((dsl = I915_READ(pipe_dsl_reg)) <= vsample)\r\n;\r\ndetect = 0;\r\ncount = 0;\r\ndo {\r\ncount++;\r\nst00 = I915_READ8(VGA_MSR_WRITE);\r\nif (st00 & (1 << 4))\r\ndetect++;\r\n} while ((I915_READ(pipe_dsl_reg) == dsl));\r\nif (restore_vblank)\r\nI915_WRITE(vblank_reg, vblank);\r\nstatus = detect * 4 > count * 3 ?\r\nconnector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nI915_WRITE(bclrpat_reg, save_bclrpat);\r\nreturn status;\r\n}\r\nstatic enum drm_connector_status\r\nintel_crt_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nstruct intel_encoder *intel_encoder = &crt->base;\r\nenum intel_display_power_domain power_domain;\r\nenum drm_connector_status status;\r\nstruct intel_load_detect_pipe tmp;\r\nstruct drm_modeset_acquire_ctx ctx;\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] force=%d\n",\r\nconnector->base.id, connector->name,\r\nforce);\r\npower_domain = intel_display_port_power_domain(intel_encoder);\r\nintel_display_power_get(dev_priv, power_domain);\r\nif (I915_HAS_HOTPLUG(dev)) {\r\nif (intel_crt_detect_hotplug(connector)) {\r\nDRM_DEBUG_KMS("CRT detected via hotplug\n");\r\nstatus = connector_status_connected;\r\ngoto out;\r\n} else\r\nDRM_DEBUG_KMS("CRT not detected via hotplug\n");\r\n}\r\nif (intel_crt_detect_ddc(connector)) {\r\nstatus = connector_status_connected;\r\ngoto out;\r\n}\r\nif (I915_HAS_HOTPLUG(dev)) {\r\nstatus = connector_status_disconnected;\r\ngoto out;\r\n}\r\nif (!force) {\r\nstatus = connector->status;\r\ngoto out;\r\n}\r\ndrm_modeset_acquire_init(&ctx, 0);\r\nif (intel_get_load_detect_pipe(connector, NULL, &tmp, &ctx)) {\r\nif (intel_crt_detect_ddc(connector))\r\nstatus = connector_status_connected;\r\nelse\r\nstatus = intel_crt_load_detect(crt);\r\nintel_release_load_detect_pipe(connector, &tmp);\r\n} else\r\nstatus = connector_status_unknown;\r\ndrm_modeset_drop_locks(&ctx);\r\ndrm_modeset_acquire_fini(&ctx);\r\nout:\r\nintel_display_power_put(dev_priv, power_domain);\r\nreturn status;\r\n}\r\nstatic void intel_crt_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic int intel_crt_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nstruct intel_encoder *intel_encoder = &crt->base;\r\nenum intel_display_power_domain power_domain;\r\nint ret;\r\nstruct i2c_adapter *i2c;\r\npower_domain = intel_display_port_power_domain(intel_encoder);\r\nintel_display_power_get(dev_priv, power_domain);\r\ni2c = intel_gmbus_get_adapter(dev_priv, dev_priv->vbt.crt_ddc_pin);\r\nret = intel_crt_ddc_get_modes(connector, i2c);\r\nif (ret || !IS_G4X(dev))\r\ngoto out;\r\ni2c = intel_gmbus_get_adapter(dev_priv, GMBUS_PORT_DPB);\r\nret = intel_crt_ddc_get_modes(connector, i2c);\r\nout:\r\nintel_display_power_put(dev_priv, power_domain);\r\nreturn ret;\r\n}\r\nstatic int intel_crt_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nreturn 0;\r\n}\r\nstatic void intel_crt_reset(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crt *crt = intel_attached_crt(connector);\r\nif (INTEL_INFO(dev)->gen >= 5) {\r\nu32 adpa;\r\nadpa = I915_READ(crt->adpa_reg);\r\nadpa &= ~ADPA_CRT_HOTPLUG_MASK;\r\nadpa |= ADPA_HOTPLUG_BITS;\r\nI915_WRITE(crt->adpa_reg, adpa);\r\nPOSTING_READ(crt->adpa_reg);\r\nDRM_DEBUG_KMS("pch crt adpa set to 0x%x\n", adpa);\r\ncrt->force_hotplug_required = 1;\r\n}\r\n}\r\nstatic int intel_no_crt_dmi_callback(const struct dmi_system_id *id)\r\n{\r\nDRM_INFO("Skipping CRT initialization for %s\n", id->ident);\r\nreturn 1;\r\n}\r\nvoid intel_crt_init(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector;\r\nstruct intel_crt *crt;\r\nstruct intel_connector *intel_connector;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (dmi_check_system(intel_no_crt))\r\nreturn;\r\ncrt = kzalloc(sizeof(struct intel_crt), GFP_KERNEL);\r\nif (!crt)\r\nreturn;\r\nintel_connector = kzalloc(sizeof(*intel_connector), GFP_KERNEL);\r\nif (!intel_connector) {\r\nkfree(crt);\r\nreturn;\r\n}\r\nconnector = &intel_connector->base;\r\ncrt->connector = intel_connector;\r\ndrm_connector_init(dev, &intel_connector->base,\r\n&intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);\r\ndrm_encoder_init(dev, &crt->base.base, &intel_crt_enc_funcs,\r\nDRM_MODE_ENCODER_DAC);\r\nintel_connector_attach_encoder(intel_connector, &crt->base);\r\ncrt->base.type = INTEL_OUTPUT_ANALOG;\r\ncrt->base.cloneable = (1 << INTEL_OUTPUT_DVO) | (1 << INTEL_OUTPUT_HDMI);\r\nif (IS_I830(dev))\r\ncrt->base.crtc_mask = (1 << 0);\r\nelse\r\ncrt->base.crtc_mask = (1 << 0) | (1 << 1) | (1 << 2);\r\nif (IS_GEN2(dev))\r\nconnector->interlace_allowed = 0;\r\nelse\r\nconnector->interlace_allowed = 1;\r\nconnector->doublescan_allowed = 0;\r\nif (HAS_PCH_SPLIT(dev))\r\ncrt->adpa_reg = PCH_ADPA;\r\nelse if (IS_VALLEYVIEW(dev))\r\ncrt->adpa_reg = VLV_ADPA;\r\nelse\r\ncrt->adpa_reg = ADPA;\r\ncrt->base.compute_config = intel_crt_compute_config;\r\ncrt->base.disable = intel_disable_crt;\r\ncrt->base.enable = intel_enable_crt;\r\nif (I915_HAS_HOTPLUG(dev))\r\ncrt->base.hpd_pin = HPD_CRT;\r\nif (HAS_DDI(dev)) {\r\ncrt->base.get_config = hsw_crt_get_config;\r\ncrt->base.get_hw_state = intel_ddi_get_hw_state;\r\ncrt->base.pre_enable = hsw_crt_pre_enable;\r\ncrt->base.post_disable = hsw_crt_post_disable;\r\n} else {\r\ncrt->base.get_config = intel_crt_get_config;\r\ncrt->base.get_hw_state = intel_crt_get_hw_state;\r\n}\r\nintel_connector->get_hw_state = intel_connector_get_hw_state;\r\nintel_connector->unregister = intel_connector_unregister;\r\ndrm_connector_helper_add(connector, &intel_crt_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\nif (!I915_HAS_HOTPLUG(dev))\r\nintel_connector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\ncrt->force_hotplug_required = 0;\r\nif (HAS_PCH_LPT(dev)) {\r\nu32 fdi_config = FDI_RX_POLARITY_REVERSED_LPT |\r\nFDI_RX_LINK_REVERSAL_OVERRIDE;\r\ndev_priv->fdi_rx_config = I915_READ(_FDI_RXA_CTL) & fdi_config;\r\n}\r\nintel_crt_reset(connector);\r\n}
