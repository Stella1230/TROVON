void nilfs_set_last_segment(struct the_nilfs *nilfs,\r\nsector_t start_blocknr, u64 seq, __u64 cno)\r\n{\r\nspin_lock(&nilfs->ns_last_segment_lock);\r\nnilfs->ns_last_pseg = start_blocknr;\r\nnilfs->ns_last_seq = seq;\r\nnilfs->ns_last_cno = cno;\r\nif (!nilfs_sb_dirty(nilfs)) {\r\nif (nilfs->ns_prev_seq == nilfs->ns_last_seq)\r\ngoto stay_cursor;\r\nset_nilfs_sb_dirty(nilfs);\r\n}\r\nnilfs->ns_prev_seq = nilfs->ns_last_seq;\r\nstay_cursor:\r\nspin_unlock(&nilfs->ns_last_segment_lock);\r\n}\r\nstruct the_nilfs *alloc_nilfs(struct block_device *bdev)\r\n{\r\nstruct the_nilfs *nilfs;\r\nnilfs = kzalloc(sizeof(*nilfs), GFP_KERNEL);\r\nif (!nilfs)\r\nreturn NULL;\r\nnilfs->ns_bdev = bdev;\r\natomic_set(&nilfs->ns_ndirtyblks, 0);\r\ninit_rwsem(&nilfs->ns_sem);\r\nmutex_init(&nilfs->ns_snapshot_mount_mutex);\r\nINIT_LIST_HEAD(&nilfs->ns_dirty_files);\r\nINIT_LIST_HEAD(&nilfs->ns_gc_inodes);\r\nspin_lock_init(&nilfs->ns_inode_lock);\r\nspin_lock_init(&nilfs->ns_next_gen_lock);\r\nspin_lock_init(&nilfs->ns_last_segment_lock);\r\nnilfs->ns_cptree = RB_ROOT;\r\nspin_lock_init(&nilfs->ns_cptree_lock);\r\ninit_rwsem(&nilfs->ns_segctor_sem);\r\nnilfs->ns_sb_update_freq = NILFS_SB_FREQ;\r\nreturn nilfs;\r\n}\r\nvoid destroy_nilfs(struct the_nilfs *nilfs)\r\n{\r\nmight_sleep();\r\nif (nilfs_init(nilfs)) {\r\nnilfs_sysfs_delete_device_group(nilfs);\r\nbrelse(nilfs->ns_sbh[0]);\r\nbrelse(nilfs->ns_sbh[1]);\r\n}\r\nkfree(nilfs);\r\n}\r\nstatic int nilfs_load_super_root(struct the_nilfs *nilfs,\r\nstruct super_block *sb, sector_t sr_block)\r\n{\r\nstruct buffer_head *bh_sr;\r\nstruct nilfs_super_root *raw_sr;\r\nstruct nilfs_super_block **sbp = nilfs->ns_sbp;\r\nstruct nilfs_inode *rawi;\r\nunsigned dat_entry_size, segment_usage_size, checkpoint_size;\r\nunsigned inode_size;\r\nint err;\r\nerr = nilfs_read_super_root_block(nilfs, sr_block, &bh_sr, 1);\r\nif (unlikely(err))\r\nreturn err;\r\ndown_read(&nilfs->ns_sem);\r\ndat_entry_size = le16_to_cpu(sbp[0]->s_dat_entry_size);\r\ncheckpoint_size = le16_to_cpu(sbp[0]->s_checkpoint_size);\r\nsegment_usage_size = le16_to_cpu(sbp[0]->s_segment_usage_size);\r\nup_read(&nilfs->ns_sem);\r\ninode_size = nilfs->ns_inode_size;\r\nrawi = (void *)bh_sr->b_data + NILFS_SR_DAT_OFFSET(inode_size);\r\nerr = nilfs_dat_read(sb, dat_entry_size, rawi, &nilfs->ns_dat);\r\nif (err)\r\ngoto failed;\r\nrawi = (void *)bh_sr->b_data + NILFS_SR_CPFILE_OFFSET(inode_size);\r\nerr = nilfs_cpfile_read(sb, checkpoint_size, rawi, &nilfs->ns_cpfile);\r\nif (err)\r\ngoto failed_dat;\r\nrawi = (void *)bh_sr->b_data + NILFS_SR_SUFILE_OFFSET(inode_size);\r\nerr = nilfs_sufile_read(sb, segment_usage_size, rawi,\r\n&nilfs->ns_sufile);\r\nif (err)\r\ngoto failed_cpfile;\r\nraw_sr = (struct nilfs_super_root *)bh_sr->b_data;\r\nnilfs->ns_nongc_ctime = le64_to_cpu(raw_sr->sr_nongc_ctime);\r\nfailed:\r\nbrelse(bh_sr);\r\nreturn err;\r\nfailed_cpfile:\r\niput(nilfs->ns_cpfile);\r\nfailed_dat:\r\niput(nilfs->ns_dat);\r\ngoto failed;\r\n}\r\nstatic void nilfs_init_recovery_info(struct nilfs_recovery_info *ri)\r\n{\r\nmemset(ri, 0, sizeof(*ri));\r\nINIT_LIST_HEAD(&ri->ri_used_segments);\r\n}\r\nstatic void nilfs_clear_recovery_info(struct nilfs_recovery_info *ri)\r\n{\r\nnilfs_dispose_segment_list(&ri->ri_used_segments);\r\n}\r\nstatic int nilfs_store_log_cursor(struct the_nilfs *nilfs,\r\nstruct nilfs_super_block *sbp)\r\n{\r\nint ret = 0;\r\nnilfs->ns_last_pseg = le64_to_cpu(sbp->s_last_pseg);\r\nnilfs->ns_last_cno = le64_to_cpu(sbp->s_last_cno);\r\nnilfs->ns_last_seq = le64_to_cpu(sbp->s_last_seq);\r\nnilfs->ns_prev_seq = nilfs->ns_last_seq;\r\nnilfs->ns_seg_seq = nilfs->ns_last_seq;\r\nnilfs->ns_segnum =\r\nnilfs_get_segnum_of_block(nilfs, nilfs->ns_last_pseg);\r\nnilfs->ns_cno = nilfs->ns_last_cno + 1;\r\nif (nilfs->ns_segnum >= nilfs->ns_nsegments) {\r\nprintk(KERN_ERR "NILFS invalid last segment number.\n");\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint load_nilfs(struct the_nilfs *nilfs, struct super_block *sb)\r\n{\r\nstruct nilfs_recovery_info ri;\r\nunsigned int s_flags = sb->s_flags;\r\nint really_read_only = bdev_read_only(nilfs->ns_bdev);\r\nint valid_fs = nilfs_valid_fs(nilfs);\r\nint err;\r\nif (!valid_fs) {\r\nprintk(KERN_WARNING "NILFS warning: mounting unchecked fs\n");\r\nif (s_flags & MS_RDONLY) {\r\nprintk(KERN_INFO "NILFS: INFO: recovery "\r\n"required for readonly filesystem.\n");\r\nprintk(KERN_INFO "NILFS: write access will "\r\n"be enabled during recovery.\n");\r\n}\r\n}\r\nnilfs_init_recovery_info(&ri);\r\nerr = nilfs_search_super_root(nilfs, &ri);\r\nif (unlikely(err)) {\r\nstruct nilfs_super_block **sbp = nilfs->ns_sbp;\r\nint blocksize;\r\nif (err != -EINVAL)\r\ngoto scan_error;\r\nif (!nilfs_valid_sb(sbp[1])) {\r\nprintk(KERN_WARNING\r\n"NILFS warning: unable to fall back to spare"\r\n"super block\n");\r\ngoto scan_error;\r\n}\r\nprintk(KERN_INFO\r\n"NILFS: try rollback from an earlier position\n");\r\nmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\r\nnilfs->ns_crc_seed = le32_to_cpu(sbp[0]->s_crc_seed);\r\nnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\r\nblocksize = BLOCK_SIZE << le32_to_cpu(sbp[0]->s_log_block_size);\r\nif (blocksize != nilfs->ns_blocksize) {\r\nprintk(KERN_WARNING\r\n"NILFS warning: blocksize differs between "\r\n"two super blocks (%d != %d)\n",\r\nblocksize, nilfs->ns_blocksize);\r\ngoto scan_error;\r\n}\r\nerr = nilfs_store_log_cursor(nilfs, sbp[0]);\r\nif (err)\r\ngoto scan_error;\r\nnilfs->ns_mount_state &= ~NILFS_VALID_FS;\r\nvalid_fs = 0;\r\nerr = nilfs_search_super_root(nilfs, &ri);\r\nif (err)\r\ngoto scan_error;\r\n}\r\nerr = nilfs_load_super_root(nilfs, sb, ri.ri_super_root);\r\nif (unlikely(err)) {\r\nprintk(KERN_ERR "NILFS: error loading super root.\n");\r\ngoto failed;\r\n}\r\nif (valid_fs)\r\ngoto skip_recovery;\r\nif (s_flags & MS_RDONLY) {\r\n__u64 features;\r\nif (nilfs_test_opt(nilfs, NORECOVERY)) {\r\nprintk(KERN_INFO "NILFS: norecovery option specified. "\r\n"skipping roll-forward recovery\n");\r\ngoto skip_recovery;\r\n}\r\nfeatures = le64_to_cpu(nilfs->ns_sbp[0]->s_feature_compat_ro) &\r\n~NILFS_FEATURE_COMPAT_RO_SUPP;\r\nif (features) {\r\nprintk(KERN_ERR "NILFS: couldn't proceed with "\r\n"recovery because of unsupported optional "\r\n"features (%llx)\n",\r\n(unsigned long long)features);\r\nerr = -EROFS;\r\ngoto failed_unload;\r\n}\r\nif (really_read_only) {\r\nprintk(KERN_ERR "NILFS: write access "\r\n"unavailable, cannot proceed.\n");\r\nerr = -EROFS;\r\ngoto failed_unload;\r\n}\r\nsb->s_flags &= ~MS_RDONLY;\r\n} else if (nilfs_test_opt(nilfs, NORECOVERY)) {\r\nprintk(KERN_ERR "NILFS: recovery cancelled because norecovery "\r\n"option was specified for a read/write mount\n");\r\nerr = -EINVAL;\r\ngoto failed_unload;\r\n}\r\nerr = nilfs_salvage_orphan_logs(nilfs, sb, &ri);\r\nif (err)\r\ngoto failed_unload;\r\ndown_write(&nilfs->ns_sem);\r\nnilfs->ns_mount_state |= NILFS_VALID_FS;\r\nerr = nilfs_cleanup_super(sb);\r\nup_write(&nilfs->ns_sem);\r\nif (err) {\r\nprintk(KERN_ERR "NILFS: failed to update super block. "\r\n"recovery unfinished.\n");\r\ngoto failed_unload;\r\n}\r\nprintk(KERN_INFO "NILFS: recovery complete.\n");\r\nskip_recovery:\r\nnilfs_clear_recovery_info(&ri);\r\nsb->s_flags = s_flags;\r\nreturn 0;\r\nscan_error:\r\nprintk(KERN_ERR "NILFS: error searching super root.\n");\r\ngoto failed;\r\nfailed_unload:\r\niput(nilfs->ns_cpfile);\r\niput(nilfs->ns_sufile);\r\niput(nilfs->ns_dat);\r\nfailed:\r\nnilfs_clear_recovery_info(&ri);\r\nsb->s_flags = s_flags;\r\nreturn err;\r\n}\r\nstatic unsigned long long nilfs_max_size(unsigned int blkbits)\r\n{\r\nunsigned int max_bits;\r\nunsigned long long res = MAX_LFS_FILESIZE;\r\nmax_bits = blkbits + NILFS_BMAP_KEY_BIT;\r\nif (max_bits < 64)\r\nres = min_t(unsigned long long, res, (1ULL << max_bits) - 1);\r\nreturn res;\r\n}\r\nunsigned long nilfs_nrsvsegs(struct the_nilfs *nilfs, unsigned long nsegs)\r\n{\r\nreturn max_t(unsigned long, NILFS_MIN_NRSVSEGS,\r\nDIV_ROUND_UP(nsegs * nilfs->ns_r_segments_percentage,\r\n100));\r\n}\r\nvoid nilfs_set_nsegments(struct the_nilfs *nilfs, unsigned long nsegs)\r\n{\r\nnilfs->ns_nsegments = nsegs;\r\nnilfs->ns_nrsvsegs = nilfs_nrsvsegs(nilfs, nsegs);\r\n}\r\nstatic int nilfs_store_disk_layout(struct the_nilfs *nilfs,\r\nstruct nilfs_super_block *sbp)\r\n{\r\nif (le32_to_cpu(sbp->s_rev_level) < NILFS_MIN_SUPP_REV) {\r\nprintk(KERN_ERR "NILFS: unsupported revision "\r\n"(superblock rev.=%d.%d, current rev.=%d.%d). "\r\n"Please check the version of mkfs.nilfs.\n",\r\nle32_to_cpu(sbp->s_rev_level),\r\nle16_to_cpu(sbp->s_minor_rev_level),\r\nNILFS_CURRENT_REV, NILFS_MINOR_REV);\r\nreturn -EINVAL;\r\n}\r\nnilfs->ns_sbsize = le16_to_cpu(sbp->s_bytes);\r\nif (nilfs->ns_sbsize > BLOCK_SIZE)\r\nreturn -EINVAL;\r\nnilfs->ns_inode_size = le16_to_cpu(sbp->s_inode_size);\r\nif (nilfs->ns_inode_size > nilfs->ns_blocksize) {\r\nprintk(KERN_ERR "NILFS: too large inode size: %d bytes.\n",\r\nnilfs->ns_inode_size);\r\nreturn -EINVAL;\r\n} else if (nilfs->ns_inode_size < NILFS_MIN_INODE_SIZE) {\r\nprintk(KERN_ERR "NILFS: too small inode size: %d bytes.\n",\r\nnilfs->ns_inode_size);\r\nreturn -EINVAL;\r\n}\r\nnilfs->ns_first_ino = le32_to_cpu(sbp->s_first_ino);\r\nnilfs->ns_blocks_per_segment = le32_to_cpu(sbp->s_blocks_per_segment);\r\nif (nilfs->ns_blocks_per_segment < NILFS_SEG_MIN_BLOCKS) {\r\nprintk(KERN_ERR "NILFS: too short segment.\n");\r\nreturn -EINVAL;\r\n}\r\nnilfs->ns_first_data_block = le64_to_cpu(sbp->s_first_data_block);\r\nnilfs->ns_r_segments_percentage =\r\nle32_to_cpu(sbp->s_r_segments_percentage);\r\nif (nilfs->ns_r_segments_percentage < 1 ||\r\nnilfs->ns_r_segments_percentage > 99) {\r\nprintk(KERN_ERR "NILFS: invalid reserved segments percentage.\n");\r\nreturn -EINVAL;\r\n}\r\nnilfs_set_nsegments(nilfs, le64_to_cpu(sbp->s_nsegments));\r\nnilfs->ns_crc_seed = le32_to_cpu(sbp->s_crc_seed);\r\nreturn 0;\r\n}\r\nstatic int nilfs_valid_sb(struct nilfs_super_block *sbp)\r\n{\r\nstatic unsigned char sum[4];\r\nconst int sumoff = offsetof(struct nilfs_super_block, s_sum);\r\nsize_t bytes;\r\nu32 crc;\r\nif (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)\r\nreturn 0;\r\nbytes = le16_to_cpu(sbp->s_bytes);\r\nif (bytes > BLOCK_SIZE)\r\nreturn 0;\r\ncrc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,\r\nsumoff);\r\ncrc = crc32_le(crc, sum, 4);\r\ncrc = crc32_le(crc, (unsigned char *)sbp + sumoff + 4,\r\nbytes - sumoff - 4);\r\nreturn crc == le32_to_cpu(sbp->s_sum);\r\n}\r\nstatic int nilfs_sb2_bad_offset(struct nilfs_super_block *sbp, u64 offset)\r\n{\r\nreturn offset < ((le64_to_cpu(sbp->s_nsegments) *\r\nle32_to_cpu(sbp->s_blocks_per_segment)) <<\r\n(le32_to_cpu(sbp->s_log_block_size) + 10));\r\n}\r\nstatic void nilfs_release_super_block(struct the_nilfs *nilfs)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (nilfs->ns_sbp[i]) {\r\nbrelse(nilfs->ns_sbh[i]);\r\nnilfs->ns_sbh[i] = NULL;\r\nnilfs->ns_sbp[i] = NULL;\r\n}\r\n}\r\n}\r\nvoid nilfs_fall_back_super_block(struct the_nilfs *nilfs)\r\n{\r\nbrelse(nilfs->ns_sbh[0]);\r\nnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\r\nnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\r\nnilfs->ns_sbh[1] = NULL;\r\nnilfs->ns_sbp[1] = NULL;\r\n}\r\nvoid nilfs_swap_super_block(struct the_nilfs *nilfs)\r\n{\r\nstruct buffer_head *tsbh = nilfs->ns_sbh[0];\r\nstruct nilfs_super_block *tsbp = nilfs->ns_sbp[0];\r\nnilfs->ns_sbh[0] = nilfs->ns_sbh[1];\r\nnilfs->ns_sbp[0] = nilfs->ns_sbp[1];\r\nnilfs->ns_sbh[1] = tsbh;\r\nnilfs->ns_sbp[1] = tsbp;\r\n}\r\nstatic int nilfs_load_super_block(struct the_nilfs *nilfs,\r\nstruct super_block *sb, int blocksize,\r\nstruct nilfs_super_block **sbpp)\r\n{\r\nstruct nilfs_super_block **sbp = nilfs->ns_sbp;\r\nstruct buffer_head **sbh = nilfs->ns_sbh;\r\nu64 sb2off = NILFS_SB2_OFFSET_BYTES(nilfs->ns_bdev->bd_inode->i_size);\r\nint valid[2], swp = 0;\r\nsbp[0] = nilfs_read_super_block(sb, NILFS_SB_OFFSET_BYTES, blocksize,\r\n&sbh[0]);\r\nsbp[1] = nilfs_read_super_block(sb, sb2off, blocksize, &sbh[1]);\r\nif (!sbp[0]) {\r\nif (!sbp[1]) {\r\nprintk(KERN_ERR "NILFS: unable to read superblock\n");\r\nreturn -EIO;\r\n}\r\nprintk(KERN_WARNING\r\n"NILFS warning: unable to read primary superblock "\r\n"(blocksize = %d)\n", blocksize);\r\n} else if (!sbp[1]) {\r\nprintk(KERN_WARNING\r\n"NILFS warning: unable to read secondary superblock "\r\n"(blocksize = %d)\n", blocksize);\r\n}\r\nvalid[0] = nilfs_valid_sb(sbp[0]);\r\nvalid[1] = nilfs_valid_sb(sbp[1]);\r\nswp = valid[1] && (!valid[0] ||\r\nle64_to_cpu(sbp[1]->s_last_cno) >\r\nle64_to_cpu(sbp[0]->s_last_cno));\r\nif (valid[swp] && nilfs_sb2_bad_offset(sbp[swp], sb2off)) {\r\nbrelse(sbh[1]);\r\nsbh[1] = NULL;\r\nsbp[1] = NULL;\r\nvalid[1] = 0;\r\nswp = 0;\r\n}\r\nif (!valid[swp]) {\r\nnilfs_release_super_block(nilfs);\r\nprintk(KERN_ERR "NILFS: Can't find nilfs on dev %s.\n",\r\nsb->s_id);\r\nreturn -EINVAL;\r\n}\r\nif (!valid[!swp])\r\nprintk(KERN_WARNING "NILFS warning: broken superblock. "\r\n"using spare superblock (blocksize = %d).\n", blocksize);\r\nif (swp)\r\nnilfs_swap_super_block(nilfs);\r\nnilfs->ns_sbwcount = 0;\r\nnilfs->ns_sbwtime = le64_to_cpu(sbp[0]->s_wtime);\r\nnilfs->ns_prot_seq = le64_to_cpu(sbp[valid[1] & !swp]->s_last_seq);\r\n*sbpp = sbp[0];\r\nreturn 0;\r\n}\r\nint init_nilfs(struct the_nilfs *nilfs, struct super_block *sb, char *data)\r\n{\r\nstruct nilfs_super_block *sbp;\r\nint blocksize;\r\nint err;\r\ndown_write(&nilfs->ns_sem);\r\nblocksize = sb_min_blocksize(sb, NILFS_MIN_BLOCK_SIZE);\r\nif (!blocksize) {\r\nprintk(KERN_ERR "NILFS: unable to set blocksize\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\r\nif (err)\r\ngoto out;\r\nerr = nilfs_store_magic_and_option(sb, sbp, data);\r\nif (err)\r\ngoto failed_sbh;\r\nerr = nilfs_check_feature_compatibility(sb, sbp);\r\nif (err)\r\ngoto failed_sbh;\r\nblocksize = BLOCK_SIZE << le32_to_cpu(sbp->s_log_block_size);\r\nif (blocksize < NILFS_MIN_BLOCK_SIZE ||\r\nblocksize > NILFS_MAX_BLOCK_SIZE) {\r\nprintk(KERN_ERR "NILFS: couldn't mount because of unsupported "\r\n"filesystem blocksize %d\n", blocksize);\r\nerr = -EINVAL;\r\ngoto failed_sbh;\r\n}\r\nif (sb->s_blocksize != blocksize) {\r\nint hw_blocksize = bdev_logical_block_size(sb->s_bdev);\r\nif (blocksize < hw_blocksize) {\r\nprintk(KERN_ERR\r\n"NILFS: blocksize %d too small for device "\r\n"(sector-size = %d).\n",\r\nblocksize, hw_blocksize);\r\nerr = -EINVAL;\r\ngoto failed_sbh;\r\n}\r\nnilfs_release_super_block(nilfs);\r\nsb_set_blocksize(sb, blocksize);\r\nerr = nilfs_load_super_block(nilfs, sb, blocksize, &sbp);\r\nif (err)\r\ngoto out;\r\n}\r\nnilfs->ns_blocksize_bits = sb->s_blocksize_bits;\r\nnilfs->ns_blocksize = blocksize;\r\nget_random_bytes(&nilfs->ns_next_generation,\r\nsizeof(nilfs->ns_next_generation));\r\nerr = nilfs_store_disk_layout(nilfs, sbp);\r\nif (err)\r\ngoto failed_sbh;\r\nsb->s_maxbytes = nilfs_max_size(sb->s_blocksize_bits);\r\nnilfs->ns_mount_state = le16_to_cpu(sbp->s_state);\r\nerr = nilfs_store_log_cursor(nilfs, sbp);\r\nif (err)\r\ngoto failed_sbh;\r\nerr = nilfs_sysfs_create_device_group(sb);\r\nif (err)\r\ngoto failed_sbh;\r\nset_nilfs_init(nilfs);\r\nerr = 0;\r\nout:\r\nup_write(&nilfs->ns_sem);\r\nreturn err;\r\nfailed_sbh:\r\nnilfs_release_super_block(nilfs);\r\ngoto out;\r\n}\r\nint nilfs_discard_segments(struct the_nilfs *nilfs, __u64 *segnump,\r\nsize_t nsegs)\r\n{\r\nsector_t seg_start, seg_end;\r\nsector_t start = 0, nblocks = 0;\r\nunsigned int sects_per_block;\r\n__u64 *sn;\r\nint ret = 0;\r\nsects_per_block = (1 << nilfs->ns_blocksize_bits) /\r\nbdev_logical_block_size(nilfs->ns_bdev);\r\nfor (sn = segnump; sn < segnump + nsegs; sn++) {\r\nnilfs_get_segment_range(nilfs, *sn, &seg_start, &seg_end);\r\nif (!nblocks) {\r\nstart = seg_start;\r\nnblocks = seg_end - seg_start + 1;\r\n} else if (start + nblocks == seg_start) {\r\nnblocks += seg_end - seg_start + 1;\r\n} else {\r\nret = blkdev_issue_discard(nilfs->ns_bdev,\r\nstart * sects_per_block,\r\nnblocks * sects_per_block,\r\nGFP_NOFS, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nnblocks = 0;\r\n}\r\n}\r\nif (nblocks)\r\nret = blkdev_issue_discard(nilfs->ns_bdev,\r\nstart * sects_per_block,\r\nnblocks * sects_per_block,\r\nGFP_NOFS, 0);\r\nreturn ret;\r\n}\r\nint nilfs_count_free_blocks(struct the_nilfs *nilfs, sector_t *nblocks)\r\n{\r\nunsigned long ncleansegs;\r\ndown_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\r\nncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\r\nup_read(&NILFS_MDT(nilfs->ns_dat)->mi_sem);\r\n*nblocks = (sector_t)ncleansegs * nilfs->ns_blocks_per_segment;\r\nreturn 0;\r\n}\r\nint nilfs_near_disk_full(struct the_nilfs *nilfs)\r\n{\r\nunsigned long ncleansegs, nincsegs;\r\nncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\r\nnincsegs = atomic_read(&nilfs->ns_ndirtyblks) /\r\nnilfs->ns_blocks_per_segment + 1;\r\nreturn ncleansegs <= nilfs->ns_nrsvsegs + nincsegs;\r\n}\r\nstruct nilfs_root *nilfs_lookup_root(struct the_nilfs *nilfs, __u64 cno)\r\n{\r\nstruct rb_node *n;\r\nstruct nilfs_root *root;\r\nspin_lock(&nilfs->ns_cptree_lock);\r\nn = nilfs->ns_cptree.rb_node;\r\nwhile (n) {\r\nroot = rb_entry(n, struct nilfs_root, rb_node);\r\nif (cno < root->cno) {\r\nn = n->rb_left;\r\n} else if (cno > root->cno) {\r\nn = n->rb_right;\r\n} else {\r\natomic_inc(&root->count);\r\nspin_unlock(&nilfs->ns_cptree_lock);\r\nreturn root;\r\n}\r\n}\r\nspin_unlock(&nilfs->ns_cptree_lock);\r\nreturn NULL;\r\n}\r\nstruct nilfs_root *\r\nnilfs_find_or_create_root(struct the_nilfs *nilfs, __u64 cno)\r\n{\r\nstruct rb_node **p, *parent;\r\nstruct nilfs_root *root, *new;\r\nint err;\r\nroot = nilfs_lookup_root(nilfs, cno);\r\nif (root)\r\nreturn root;\r\nnew = kzalloc(sizeof(*root), GFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\nspin_lock(&nilfs->ns_cptree_lock);\r\np = &nilfs->ns_cptree.rb_node;\r\nparent = NULL;\r\nwhile (*p) {\r\nparent = *p;\r\nroot = rb_entry(parent, struct nilfs_root, rb_node);\r\nif (cno < root->cno) {\r\np = &(*p)->rb_left;\r\n} else if (cno > root->cno) {\r\np = &(*p)->rb_right;\r\n} else {\r\natomic_inc(&root->count);\r\nspin_unlock(&nilfs->ns_cptree_lock);\r\nkfree(new);\r\nreturn root;\r\n}\r\n}\r\nnew->cno = cno;\r\nnew->ifile = NULL;\r\nnew->nilfs = nilfs;\r\natomic_set(&new->count, 1);\r\natomic64_set(&new->inodes_count, 0);\r\natomic64_set(&new->blocks_count, 0);\r\nrb_link_node(&new->rb_node, parent, p);\r\nrb_insert_color(&new->rb_node, &nilfs->ns_cptree);\r\nspin_unlock(&nilfs->ns_cptree_lock);\r\nerr = nilfs_sysfs_create_snapshot_group(new);\r\nif (err) {\r\nkfree(new);\r\nnew = NULL;\r\n}\r\nreturn new;\r\n}\r\nvoid nilfs_put_root(struct nilfs_root *root)\r\n{\r\nif (atomic_dec_and_test(&root->count)) {\r\nstruct the_nilfs *nilfs = root->nilfs;\r\nnilfs_sysfs_delete_snapshot_group(root);\r\nspin_lock(&nilfs->ns_cptree_lock);\r\nrb_erase(&root->rb_node, &nilfs->ns_cptree);\r\nspin_unlock(&nilfs->ns_cptree_lock);\r\nif (root->ifile)\r\niput(root->ifile);\r\nkfree(root);\r\n}\r\n}
