void rxrpc_remove_user_ID(struct rxrpc_sock *rx, struct rxrpc_call *call)\r\n{\r\n_debug("RELEASE CALL %d", call->debug_id);\r\nif (test_bit(RXRPC_CALL_HAS_USERID, &call->flags)) {\r\nwrite_lock_bh(&rx->call_lock);\r\nrb_erase(&call->sock_node, &call->socket->calls);\r\nclear_bit(RXRPC_CALL_HAS_USERID, &call->flags);\r\nwrite_unlock_bh(&rx->call_lock);\r\n}\r\nread_lock_bh(&call->state_lock);\r\nif (!test_bit(RXRPC_CALL_RELEASED, &call->flags) &&\r\n!test_and_set_bit(RXRPC_CALL_RELEASE, &call->events))\r\nrxrpc_queue_call(call);\r\nread_unlock_bh(&call->state_lock);\r\n}\r\nint rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nstruct rxrpc_call *call = NULL, *continue_call = NULL;\r\nstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\r\nstruct sk_buff *skb;\r\nlong timeo;\r\nint copy, ret, ullen, offset, copied = 0;\r\nu32 abort_code;\r\nDEFINE_WAIT(wait);\r\n_enter(",,,%zu,%d", len, flags);\r\nif (flags & (MSG_OOB | MSG_TRUNC))\r\nreturn -EOPNOTSUPP;\r\nullen = msg->msg_flags & MSG_CMSG_COMPAT ? 4 : sizeof(unsigned long);\r\ntimeo = sock_rcvtimeo(&rx->sk, flags & MSG_DONTWAIT);\r\nmsg->msg_flags |= MSG_MORE;\r\nlock_sock(&rx->sk);\r\nfor (;;) {\r\nif (RB_EMPTY_ROOT(&rx->calls)) {\r\nif (copied)\r\ngoto out;\r\nif (rx->sk.sk_state != RXRPC_SERVER_LISTENING) {\r\nrelease_sock(&rx->sk);\r\nif (continue_call)\r\nrxrpc_put_call(continue_call);\r\nreturn -ENODATA;\r\n}\r\n}\r\nskb = skb_peek(&rx->sk.sk_receive_queue);\r\nif (!skb) {\r\nif (copied &&\r\n(msg->msg_flags & MSG_PEEK || timeo == 0))\r\ngoto out;\r\nrelease_sock(&rx->sk);\r\nprepare_to_wait_exclusive(sk_sleep(&rx->sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\nret = sock_error(&rx->sk);\r\nif (ret)\r\ngoto wait_error;\r\nif (skb_queue_empty(&rx->sk.sk_receive_queue)) {\r\nif (signal_pending(current))\r\ngoto wait_interrupted;\r\ntimeo = schedule_timeout(timeo);\r\n}\r\nfinish_wait(sk_sleep(&rx->sk), &wait);\r\nlock_sock(&rx->sk);\r\ncontinue;\r\n}\r\npeek_next_packet:\r\nsp = rxrpc_skb(skb);\r\ncall = sp->call;\r\nASSERT(call != NULL);\r\n_debug("next pkt %s", rxrpc_pkts[sp->hdr.type]);\r\nspin_lock_bh(&call->lock);\r\nspin_unlock_bh(&call->lock);\r\nif (test_bit(RXRPC_CALL_RELEASED, &call->flags)) {\r\n_debug("packet from released call");\r\nif (skb_dequeue(&rx->sk.sk_receive_queue) != skb)\r\nBUG();\r\nrxrpc_free_skb(skb);\r\ncontinue;\r\n}\r\nif (continue_call) {\r\n_debug("maybe cont");\r\nif (call != continue_call ||\r\nskb->mark != RXRPC_SKB_MARK_DATA) {\r\nrelease_sock(&rx->sk);\r\nrxrpc_put_call(continue_call);\r\n_leave(" = %d [noncont]", copied);\r\nreturn copied;\r\n}\r\n}\r\nrxrpc_get_call(call);\r\nif (!continue_call) {\r\nif (msg->msg_name) {\r\nsize_t len =\r\nsizeof(call->conn->trans->peer->srx);\r\nmemcpy(msg->msg_name,\r\n&call->conn->trans->peer->srx, len);\r\nmsg->msg_namelen = len;\r\n}\r\nsock_recv_ts_and_drops(msg, &rx->sk, skb);\r\n}\r\nif (skb->mark != RXRPC_SKB_MARK_DATA)\r\ngoto receive_non_data_message;\r\n_debug("recvmsg DATA #%u { %d, %d }",\r\nntohl(sp->hdr.seq), skb->len, sp->offset);\r\nif (!continue_call) {\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_USER_CALL_ID,\r\nullen, &call->user_call_ID);\r\nif (ret < 0)\r\ngoto copy_error;\r\nASSERT(test_bit(RXRPC_CALL_HAS_USERID, &call->flags));\r\n}\r\nASSERTCMP(ntohl(sp->hdr.seq), >=, call->rx_data_recv);\r\nASSERTCMP(ntohl(sp->hdr.seq), <=, call->rx_data_recv + 1);\r\ncall->rx_data_recv = ntohl(sp->hdr.seq);\r\nASSERTCMP(ntohl(sp->hdr.seq), >, call->rx_data_eaten);\r\noffset = sp->offset;\r\ncopy = skb->len - offset;\r\nif (copy > len - copied)\r\ncopy = len - copied;\r\nret = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copy);\r\nif (ret < 0)\r\ngoto copy_error;\r\n_debug("copied %d+%d", copy, copied);\r\noffset += copy;\r\ncopied += copy;\r\nif (!(flags & MSG_PEEK))\r\nsp->offset = offset;\r\nif (sp->offset < skb->len) {\r\n_debug("buffer full");\r\nASSERTCMP(copied, ==, len);\r\nbreak;\r\n}\r\nif (sp->hdr.flags & RXRPC_LAST_PACKET) {\r\n_debug("last");\r\nif (call->conn->out_clientflag) {\r\nret = copied;\r\ngoto terminal_message;\r\n}\r\nif (!(flags & MSG_PEEK)) {\r\n_debug("eat packet");\r\nif (skb_dequeue(&rx->sk.sk_receive_queue) !=\r\nskb)\r\nBUG();\r\nrxrpc_free_skb(skb);\r\n}\r\nmsg->msg_flags &= ~MSG_MORE;\r\nbreak;\r\n}\r\n_debug("next");\r\nif (!continue_call)\r\ncontinue_call = sp->call;\r\nelse\r\nrxrpc_put_call(call);\r\ncall = NULL;\r\nif (flags & MSG_PEEK) {\r\n_debug("peek next");\r\nskb = skb->next;\r\nif (skb == (struct sk_buff *) &rx->sk.sk_receive_queue)\r\nbreak;\r\ngoto peek_next_packet;\r\n}\r\n_debug("eat packet");\r\nif (skb_dequeue(&rx->sk.sk_receive_queue) != skb)\r\nBUG();\r\nrxrpc_free_skb(skb);\r\n}\r\n_debug("end rcv data");\r\nout:\r\nrelease_sock(&rx->sk);\r\nif (call)\r\nrxrpc_put_call(call);\r\nif (continue_call)\r\nrxrpc_put_call(continue_call);\r\n_leave(" = %d [data]", copied);\r\nreturn copied;\r\nreceive_non_data_message:\r\n_debug("non-data");\r\nif (skb->mark == RXRPC_SKB_MARK_NEW_CALL) {\r\n_debug("RECV NEW CALL");\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_NEW_CALL, 0, &abort_code);\r\nif (ret < 0)\r\ngoto copy_error;\r\nif (!(flags & MSG_PEEK)) {\r\nif (skb_dequeue(&rx->sk.sk_receive_queue) != skb)\r\nBUG();\r\nrxrpc_free_skb(skb);\r\n}\r\ngoto out;\r\n}\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_USER_CALL_ID,\r\nullen, &call->user_call_ID);\r\nif (ret < 0)\r\ngoto copy_error;\r\nASSERT(test_bit(RXRPC_CALL_HAS_USERID, &call->flags));\r\nswitch (skb->mark) {\r\ncase RXRPC_SKB_MARK_DATA:\r\nBUG();\r\ncase RXRPC_SKB_MARK_FINAL_ACK:\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_ACK, 0, &abort_code);\r\nbreak;\r\ncase RXRPC_SKB_MARK_BUSY:\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_BUSY, 0, &abort_code);\r\nbreak;\r\ncase RXRPC_SKB_MARK_REMOTE_ABORT:\r\nabort_code = call->abort_code;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_ABORT, 4, &abort_code);\r\nbreak;\r\ncase RXRPC_SKB_MARK_NET_ERROR:\r\n_debug("RECV NET ERROR %d", sp->error);\r\nabort_code = sp->error;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_NET_ERROR, 4, &abort_code);\r\nbreak;\r\ncase RXRPC_SKB_MARK_LOCAL_ERROR:\r\n_debug("RECV LOCAL ERROR %d", sp->error);\r\nabort_code = sp->error;\r\nret = put_cmsg(msg, SOL_RXRPC, RXRPC_LOCAL_ERROR, 4,\r\n&abort_code);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (ret < 0)\r\ngoto copy_error;\r\nterminal_message:\r\n_debug("terminal");\r\nmsg->msg_flags &= ~MSG_MORE;\r\nmsg->msg_flags |= MSG_EOR;\r\nif (!(flags & MSG_PEEK)) {\r\n_net("free terminal skb %p", skb);\r\nif (skb_dequeue(&rx->sk.sk_receive_queue) != skb)\r\nBUG();\r\nrxrpc_free_skb(skb);\r\nrxrpc_remove_user_ID(rx, call);\r\n}\r\nrelease_sock(&rx->sk);\r\nrxrpc_put_call(call);\r\nif (continue_call)\r\nrxrpc_put_call(continue_call);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\ncopy_error:\r\n_debug("copy error");\r\nrelease_sock(&rx->sk);\r\nrxrpc_put_call(call);\r\nif (continue_call)\r\nrxrpc_put_call(continue_call);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nwait_interrupted:\r\nret = sock_intr_errno(timeo);\r\nwait_error:\r\nfinish_wait(sk_sleep(&rx->sk), &wait);\r\nif (continue_call)\r\nrxrpc_put_call(continue_call);\r\nif (copied)\r\ncopied = ret;\r\n_leave(" = %d [waitfail %d]", copied, ret);\r\nreturn copied;\r\n}\r\nvoid rxrpc_kernel_data_delivered(struct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nstruct rxrpc_call *call = sp->call;\r\nASSERTCMP(ntohl(sp->hdr.seq), >=, call->rx_data_recv);\r\nASSERTCMP(ntohl(sp->hdr.seq), <=, call->rx_data_recv + 1);\r\ncall->rx_data_recv = ntohl(sp->hdr.seq);\r\nASSERTCMP(ntohl(sp->hdr.seq), >, call->rx_data_eaten);\r\nrxrpc_free_skb(skb);\r\n}\r\nbool rxrpc_kernel_is_data_last(struct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nASSERTCMP(skb->mark, ==, RXRPC_SKB_MARK_DATA);\r\nreturn sp->hdr.flags & RXRPC_LAST_PACKET;\r\n}\r\nu32 rxrpc_kernel_get_abort_code(struct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nASSERTCMP(skb->mark, ==, RXRPC_SKB_MARK_REMOTE_ABORT);\r\nreturn sp->call->abort_code;\r\n}\r\nint rxrpc_kernel_get_error_number(struct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nreturn sp->error;\r\n}
