static inline void snd_cs4281_pokeBA0(struct cs4281 *chip, unsigned long offset,\r\nunsigned int val)\r\n{\r\nwritel(val, chip->ba0 + offset);\r\n}\r\nstatic inline unsigned int snd_cs4281_peekBA0(struct cs4281 *chip, unsigned long offset)\r\n{\r\nreturn readl(chip->ba0 + offset);\r\n}\r\nstatic void snd_cs4281_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg, unsigned short val)\r\n{\r\nstruct cs4281 *chip = ac97->private_data;\r\nint count;\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCAD, reg);\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCDA, val);\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_DCV | BA0_ACCTL_VFRM |\r\nBA0_ACCTL_ESYN | (ac97->num ? BA0_ACCTL_TC : 0));\r\nfor (count = 0; count < 2000; count++) {\r\nudelay(10);\r\nif (!(snd_cs4281_peekBA0(chip, BA0_ACCTL) & BA0_ACCTL_DCV)) {\r\nreturn;\r\n}\r\n}\r\ndev_err(chip->card->dev,\r\n"AC'97 write problem, reg = 0x%x, val = 0x%x\n", reg, val);\r\n}\r\nstatic unsigned short snd_cs4281_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct cs4281 *chip = ac97->private_data;\r\nint count;\r\nunsigned short result;\r\nvolatile int ac97_num = ((volatile struct snd_ac97 *)ac97)->num;\r\nsnd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSDA2 : BA0_ACSDA);\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCAD, reg);\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCDA, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_DCV | BA0_ACCTL_CRW |\r\nBA0_ACCTL_VFRM | BA0_ACCTL_ESYN |\r\n(ac97_num ? BA0_ACCTL_TC : 0));\r\nfor (count = 0; count < 500; count++) {\r\nudelay(10);\r\nif (!(snd_cs4281_peekBA0(chip, BA0_ACCTL) & BA0_ACCTL_DCV))\r\ngoto __ok1;\r\n}\r\ndev_err(chip->card->dev,\r\n"AC'97 read problem (ACCTL_DCV), reg = 0x%x\n", reg);\r\nresult = 0xffff;\r\ngoto __end;\r\n__ok1:\r\nfor (count = 0; count < 100; count++) {\r\nif (snd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSTS2 : BA0_ACSTS) & BA0_ACSTS_VSTS)\r\ngoto __ok2;\r\nudelay(10);\r\n}\r\ndev_err(chip->card->dev,\r\n"AC'97 read problem (ACSTS_VSTS), reg = 0x%x\n", reg);\r\nresult = 0xffff;\r\ngoto __end;\r\n__ok2:\r\nresult = snd_cs4281_peekBA0(chip, ac97_num ? BA0_ACSDA2 : BA0_ACSDA);\r\n__end:\r\nreturn result;\r\n}\r\nstatic int snd_cs4281_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct cs4281_dma *dma = substream->runtime->private_data;\r\nstruct cs4281 *chip = snd_pcm_substream_chip(substream);\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndma->valDCR |= BA0_DCR_MSK;\r\ndma->valFCR |= BA0_FCR_FEN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ndma->valDCR &= ~BA0_DCR_MSK;\r\ndma->valFCR &= ~BA0_FCR_FEN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nsnd_cs4281_pokeBA0(chip, dma->regDMR, dma->valDMR & ~BA0_DMR_DMA);\r\ndma->valDMR |= BA0_DMR_DMA;\r\ndma->valDCR &= ~BA0_DCR_MSK;\r\ndma->valFCR |= BA0_FCR_FEN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndma->valDMR &= ~(BA0_DMR_DMA|BA0_DMR_POLL);\r\ndma->valDCR |= BA0_DCR_MSK;\r\ndma->valFCR &= ~BA0_FCR_FEN;\r\nif (dma->regFCR != BA0_FCR0)\r\ndma->valFCR &= ~BA0_FCR_FEN;\r\nbreak;\r\ndefault:\r\nspin_unlock(&chip->reg_lock);\r\nreturn -EINVAL;\r\n}\r\nsnd_cs4281_pokeBA0(chip, dma->regDMR, dma->valDMR);\r\nsnd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR);\r\nsnd_cs4281_pokeBA0(chip, dma->regDCR, dma->valDCR);\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic unsigned int snd_cs4281_rate(unsigned int rate, unsigned int *real_rate)\r\n{\r\nunsigned int val = ~0;\r\nif (real_rate)\r\n*real_rate = rate;\r\nswitch (rate) {\r\ncase 8000: return 5;\r\ncase 11025: return 4;\r\ncase 16000: return 3;\r\ncase 22050: return 2;\r\ncase 44100: return 1;\r\ncase 48000: return 0;\r\ndefault:\r\ngoto __variable;\r\n}\r\n__variable:\r\nval = 1536000 / rate;\r\nif (real_rate)\r\n*real_rate = 1536000 / val;\r\nreturn val;\r\n}\r\nstatic void snd_cs4281_mode(struct cs4281 *chip, struct cs4281_dma *dma,\r\nstruct snd_pcm_runtime *runtime,\r\nint capture, int src)\r\n{\r\nint rec_mono;\r\ndma->valDMR = BA0_DMR_TYPE_SINGLE | BA0_DMR_AUTO |\r\n(capture ? BA0_DMR_TR_WRITE : BA0_DMR_TR_READ);\r\nif (runtime->channels == 1)\r\ndma->valDMR |= BA0_DMR_MONO;\r\nif (snd_pcm_format_unsigned(runtime->format) > 0)\r\ndma->valDMR |= BA0_DMR_USIGN;\r\nif (snd_pcm_format_big_endian(runtime->format) > 0)\r\ndma->valDMR |= BA0_DMR_BEND;\r\nswitch (snd_pcm_format_width(runtime->format)) {\r\ncase 8: dma->valDMR |= BA0_DMR_SIZE8;\r\nif (runtime->channels == 1)\r\ndma->valDMR |= BA0_DMR_SWAPC;\r\nbreak;\r\ncase 32: dma->valDMR |= BA0_DMR_SIZE20; break;\r\n}\r\ndma->frag = 0;\r\ndma->valDCR = BA0_DCR_TCIE | BA0_DCR_MSK;\r\nif (runtime->buffer_size != runtime->period_size)\r\ndma->valDCR |= BA0_DCR_HTCIE;\r\nsnd_cs4281_pokeBA0(chip, dma->regDBA, runtime->dma_addr);\r\nsnd_cs4281_pokeBA0(chip, dma->regDBC, runtime->buffer_size - 1);\r\nrec_mono = (chip->dma[1].valDMR & BA0_DMR_MONO) == BA0_DMR_MONO;\r\nsnd_cs4281_pokeBA0(chip, BA0_SRCSA, (chip->src_left_play_slot << 0) |\r\n(chip->src_right_play_slot << 8) |\r\n(chip->src_left_rec_slot << 16) |\r\n((rec_mono ? 31 : chip->src_right_rec_slot) << 24));\r\nif (!src)\r\ngoto __skip_src;\r\nif (!capture) {\r\nif (dma->left_slot == chip->src_left_play_slot) {\r\nunsigned int val = snd_cs4281_rate(runtime->rate, NULL);\r\nsnd_BUG_ON(dma->right_slot != chip->src_right_play_slot);\r\nsnd_cs4281_pokeBA0(chip, BA0_DACSR, val);\r\n}\r\n} else {\r\nif (dma->left_slot == chip->src_left_rec_slot) {\r\nunsigned int val = snd_cs4281_rate(runtime->rate, NULL);\r\nsnd_BUG_ON(dma->right_slot != chip->src_right_rec_slot);\r\nsnd_cs4281_pokeBA0(chip, BA0_ADCSR, val);\r\n}\r\n}\r\n__skip_src:\r\nif (dma->regFCR == BA0_FCR0)\r\nsnd_cs4281_pokeBA0(chip, dma->regFCR, snd_cs4281_peekBA0(chip, dma->regFCR) & ~BA0_FCR_FEN);\r\ndma->valFCR = BA0_FCR_LS(dma->left_slot) |\r\nBA0_FCR_RS(capture && (dma->valDMR & BA0_DMR_MONO) ? 31 : dma->right_slot) |\r\nBA0_FCR_SZ(CS4281_FIFO_SIZE) |\r\nBA0_FCR_OF(dma->fifo_offset);\r\nsnd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR | (capture ? BA0_FCR_PSH : 0));\r\nif (dma->regFCR == BA0_FCR0)\r\nsnd_cs4281_pokeBA0(chip, dma->regFCR, dma->valFCR | BA0_FCR_FEN);\r\nsnd_cs4281_pokeBA0(chip, dma->regFSIC, 0);\r\n}\r\nstatic int snd_cs4281_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_cs4281_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_cs4281_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cs4281_dma *dma = runtime->private_data;\r\nstruct cs4281 *chip = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_cs4281_mode(chip, dma, runtime, 0, 1);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cs4281_dma *dma = runtime->private_data;\r\nstruct cs4281 *chip = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_cs4281_mode(chip, dma, runtime, 1, 1);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_cs4281_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cs4281_dma *dma = runtime->private_data;\r\nstruct cs4281 *chip = snd_pcm_substream_chip(substream);\r\nreturn runtime->buffer_size -\r\nsnd_cs4281_peekBA0(chip, dma->regDCC) - 1;\r\n}\r\nstatic int snd_cs4281_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct cs4281 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cs4281_dma *dma;\r\ndma = &chip->dma[0];\r\ndma->substream = substream;\r\ndma->left_slot = 0;\r\ndma->right_slot = 1;\r\nruntime->private_data = dma;\r\nruntime->hw = snd_cs4281_playback;\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct cs4281 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cs4281_dma *dma;\r\ndma = &chip->dma[1];\r\ndma->substream = substream;\r\ndma->left_slot = 10;\r\ndma->right_slot = 11;\r\nruntime->private_data = dma;\r\nruntime->hw = snd_cs4281_capture;\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct cs4281_dma *dma = substream->runtime->private_data;\r\ndma->substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct cs4281_dma *dma = substream->runtime->private_data;\r\ndma->substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_pcm(struct cs4281 *chip, int device,\r\nstruct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nerr = snd_pcm_new(chip->card, "CS4281", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cs4281_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cs4281_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "CS4281");\r\nchip->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 512*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_info_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = CS_VOL_MASK;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_get_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cs4281 *chip = snd_kcontrol_chip(kcontrol);\r\nint regL = (kcontrol->private_value >> 16) & 0xffff;\r\nint regR = kcontrol->private_value & 0xffff;\r\nint volL, volR;\r\nvolL = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regL) & CS_VOL_MASK);\r\nvolR = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regR) & CS_VOL_MASK);\r\nucontrol->value.integer.value[0] = volL;\r\nucontrol->value.integer.value[1] = volR;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_put_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cs4281 *chip = snd_kcontrol_chip(kcontrol);\r\nint change = 0;\r\nint regL = (kcontrol->private_value >> 16) & 0xffff;\r\nint regR = kcontrol->private_value & 0xffff;\r\nint volL, volR;\r\nvolL = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regL) & CS_VOL_MASK);\r\nvolR = CS_VOL_MASK - (snd_cs4281_peekBA0(chip, regR) & CS_VOL_MASK);\r\nif (ucontrol->value.integer.value[0] != volL) {\r\nvolL = CS_VOL_MASK - (ucontrol->value.integer.value[0] & CS_VOL_MASK);\r\nsnd_cs4281_pokeBA0(chip, regL, volL);\r\nchange = 1;\r\n}\r\nif (ucontrol->value.integer.value[1] != volR) {\r\nvolR = CS_VOL_MASK - (ucontrol->value.integer.value[1] & CS_VOL_MASK);\r\nsnd_cs4281_pokeBA0(chip, regR, volR);\r\nchange = 1;\r\n}\r\nreturn change;\r\n}\r\nstatic void snd_cs4281_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\r\n{\r\nstruct cs4281 *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void snd_cs4281_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct cs4281 *chip = ac97->private_data;\r\nif (ac97->num)\r\nchip->ac97_secondary = NULL;\r\nelse\r\nchip->ac97 = NULL;\r\n}\r\nstatic int snd_cs4281_mixer(struct cs4281 *chip)\r\n{\r\nstruct snd_card *card = chip->card;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_cs4281_ac97_write,\r\n.read = snd_cs4281_ac97_read,\r\n};\r\nif ((err = snd_ac97_bus(card, 0, &ops, chip, &chip->ac97_bus)) < 0)\r\nreturn err;\r\nchip->ac97_bus->private_free = snd_cs4281_mixer_free_ac97_bus;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_cs4281_mixer_free_ac97;\r\nif ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)\r\nreturn err;\r\nif (chip->dual_codec) {\r\nac97.num = 1;\r\nif ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97_secondary)) < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cs4281_fm_vol, chip))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cs4281_pcm_vol, chip))) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void snd_cs4281_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct cs4281 *chip = entry->private_data;\r\nsnd_iprintf(buffer, "Cirrus Logic CS4281\n\n");\r\nsnd_iprintf(buffer, "Spurious half IRQs : %u\n", chip->spurious_dhtc_irq);\r\nsnd_iprintf(buffer, "Spurious end IRQs : %u\n", chip->spurious_dtc_irq);\r\n}\r\nstatic ssize_t snd_cs4281_BA0_read(struct snd_info_entry *entry,\r\nvoid *file_private_data,\r\nstruct file *file, char __user *buf,\r\nsize_t count, loff_t pos)\r\n{\r\nstruct cs4281 *chip = entry->private_data;\r\nif (copy_to_user_fromio(buf, chip->ba0 + pos, count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic ssize_t snd_cs4281_BA1_read(struct snd_info_entry *entry,\r\nvoid *file_private_data,\r\nstruct file *file, char __user *buf,\r\nsize_t count, loff_t pos)\r\n{\r\nstruct cs4281 *chip = entry->private_data;\r\nif (copy_to_user_fromio(buf, chip->ba1 + pos, count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic void snd_cs4281_proc_init(struct cs4281 *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(chip->card, "cs4281", &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_cs4281_proc_read);\r\nif (! snd_card_proc_new(chip->card, "cs4281_BA0", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = chip;\r\nentry->c.ops = &snd_cs4281_proc_ops_BA0;\r\nentry->size = CS4281_BA0_SIZE;\r\n}\r\nif (! snd_card_proc_new(chip->card, "cs4281_BA1", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = chip;\r\nentry->c.ops = &snd_cs4281_proc_ops_BA1;\r\nentry->size = CS4281_BA1_SIZE;\r\n}\r\n}\r\nstatic void snd_cs4281_gameport_trigger(struct gameport *gameport)\r\n{\r\nstruct cs4281 *chip = gameport_get_port_data(gameport);\r\nif (snd_BUG_ON(!chip))\r\nreturn;\r\nsnd_cs4281_pokeBA0(chip, BA0_JSPT, 0xff);\r\n}\r\nstatic unsigned char snd_cs4281_gameport_read(struct gameport *gameport)\r\n{\r\nstruct cs4281 *chip = gameport_get_port_data(gameport);\r\nif (snd_BUG_ON(!chip))\r\nreturn 0;\r\nreturn snd_cs4281_peekBA0(chip, BA0_JSPT);\r\n}\r\nstatic int snd_cs4281_gameport_cooked_read(struct gameport *gameport,\r\nint *axes, int *buttons)\r\n{\r\nstruct cs4281 *chip = gameport_get_port_data(gameport);\r\nunsigned js1, js2, jst;\r\nif (snd_BUG_ON(!chip))\r\nreturn 0;\r\njs1 = snd_cs4281_peekBA0(chip, BA0_JSC1);\r\njs2 = snd_cs4281_peekBA0(chip, BA0_JSC2);\r\njst = snd_cs4281_peekBA0(chip, BA0_JSPT);\r\n*buttons = (~jst >> 4) & 0x0F;\r\naxes[0] = ((js1 & JSC1_Y1V_MASK) >> JSC1_Y1V_SHIFT) & 0xFFFF;\r\naxes[1] = ((js1 & JSC1_X1V_MASK) >> JSC1_X1V_SHIFT) & 0xFFFF;\r\naxes[2] = ((js2 & JSC2_Y2V_MASK) >> JSC2_Y2V_SHIFT) & 0xFFFF;\r\naxes[3] = ((js2 & JSC2_X2V_MASK) >> JSC2_X2V_SHIFT) & 0xFFFF;\r\nfor (jst = 0; jst < 4; ++jst)\r\nif (axes[jst] == 0xFFFF) axes[jst] = -1;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_gameport_open(struct gameport *gameport, int mode)\r\n{\r\nswitch (mode) {\r\n#ifdef COOKED_MODE\r\ncase GAMEPORT_MODE_COOKED:\r\nreturn 0;\r\n#endif\r\ncase GAMEPORT_MODE_RAW:\r\nreturn 0;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_create_gameport(struct cs4281 *chip)\r\n{\r\nstruct gameport *gp;\r\nchip->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\ndev_err(chip->card->dev,\r\n"cannot allocate memory for gameport\n");\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "CS4281 Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));\r\ngameport_set_dev_parent(gp, &chip->pci->dev);\r\ngp->open = snd_cs4281_gameport_open;\r\ngp->read = snd_cs4281_gameport_read;\r\ngp->trigger = snd_cs4281_gameport_trigger;\r\ngp->cooked_read = snd_cs4281_gameport_cooked_read;\r\ngameport_set_port_data(gp, chip);\r\nsnd_cs4281_pokeBA0(chip, BA0_JSIO, 0xFF);\r\nsnd_cs4281_pokeBA0(chip, BA0_JSCTL, JSCTL_SP_MEDIUM_SLOW);\r\ngameport_register_port(gp);\r\nreturn 0;\r\n}\r\nstatic void snd_cs4281_free_gameport(struct cs4281 *chip)\r\n{\r\nif (chip->gameport) {\r\ngameport_unregister_port(chip->gameport);\r\nchip->gameport = NULL;\r\n}\r\n}\r\nstatic inline int snd_cs4281_create_gameport(struct cs4281 *chip) { return -ENOSYS; }\r\nstatic inline void snd_cs4281_free_gameport(struct cs4281 *chip) { }\r\nstatic int snd_cs4281_free(struct cs4281 *chip)\r\n{\r\nsnd_cs4281_free_gameport(chip);\r\nif (chip->irq >= 0)\r\nsynchronize_irq(chip->irq);\r\nsnd_cs4281_pokeBA0(chip, BA0_HIMR, 0x7fffffff);\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_SSPM, 0);\r\npci_set_power_state(chip->pci, PCI_D3hot);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nif (chip->ba0)\r\niounmap(chip->ba0);\r\nif (chip->ba1)\r\niounmap(chip->ba1);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_dev_free(struct snd_device *device)\r\n{\r\nstruct cs4281 *chip = device->device_data;\r\nreturn snd_cs4281_free(chip);\r\n}\r\nstatic int snd_cs4281_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct cs4281 **rchip,\r\nint dual_codec)\r\n{\r\nstruct cs4281 *chip;\r\nunsigned int tmp;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_cs4281_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\npci_set_master(pci);\r\nif (dual_codec < 0 || dual_codec > 3) {\r\ndev_err(card->dev, "invalid dual_codec option %d\n", dual_codec);\r\ndual_codec = 0;\r\n}\r\nchip->dual_codec = dual_codec;\r\nif ((err = pci_request_regions(pci, "CS4281")) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->ba0_addr = pci_resource_start(pci, 0);\r\nchip->ba1_addr = pci_resource_start(pci, 1);\r\nchip->ba0 = pci_ioremap_bar(pci, 0);\r\nchip->ba1 = pci_ioremap_bar(pci, 1);\r\nif (!chip->ba0 || !chip->ba1) {\r\nsnd_cs4281_free(chip);\r\nreturn -ENOMEM;\r\n}\r\nif (request_irq(pci->irq, snd_cs4281_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_cs4281_free(chip);\r\nreturn -ENOMEM;\r\n}\r\nchip->irq = pci->irq;\r\ntmp = snd_cs4281_chip_init(chip);\r\nif (tmp) {\r\nsnd_cs4281_free(chip);\r\nreturn tmp;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_cs4281_free(chip);\r\nreturn err;\r\n}\r\nsnd_cs4281_proc_init(chip);\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_chip_init(struct cs4281 *chip)\r\n{\r\nunsigned int tmp;\r\nunsigned long end_time;\r\nint retry_count = 2;\r\ntmp = snd_cs4281_peekBA0(chip, BA0_EPPMC);\r\nif (tmp & BA0_EPPMC_FPDN)\r\nsnd_cs4281_pokeBA0(chip, BA0_EPPMC, tmp & ~BA0_EPPMC_FPDN);\r\n__retry:\r\ntmp = snd_cs4281_peekBA0(chip, BA0_CFLR);\r\nif (tmp != BA0_CFLR_DEFAULT) {\r\nsnd_cs4281_pokeBA0(chip, BA0_CFLR, BA0_CFLR_DEFAULT);\r\ntmp = snd_cs4281_peekBA0(chip, BA0_CFLR);\r\nif (tmp != BA0_CFLR_DEFAULT) {\r\ndev_err(chip->card->dev,\r\n"CFLR setup failed (0x%x)\n", tmp);\r\nreturn -EIO;\r\n}\r\n}\r\nsnd_cs4281_pokeBA0(chip, BA0_CWPR, 0x4281);\r\nif ((tmp = snd_cs4281_peekBA0(chip, BA0_SERC1)) != (BA0_SERC1_SO1EN | BA0_SERC1_AC97)) {\r\ndev_err(chip->card->dev,\r\n"SERC1 AC'97 check failed (0x%x)\n", tmp);\r\nreturn -EIO;\r\n}\r\nif ((tmp = snd_cs4281_peekBA0(chip, BA0_SERC2)) != (BA0_SERC2_SI1EN | BA0_SERC2_AC97)) {\r\ndev_err(chip->card->dev,\r\n"SERC2 AC'97 check failed (0x%x)\n", tmp);\r\nreturn -EIO;\r\n}\r\nsnd_cs4281_pokeBA0(chip, BA0_SSPM, BA0_SSPM_MIXEN | BA0_SSPM_CSRCEN |\r\nBA0_SSPM_PSRCEN | BA0_SSPM_JSEN |\r\nBA0_SSPM_ACLEN | BA0_SSPM_FMEN);\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_SERMC, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCTL, 0);\r\nudelay(50);\r\nsnd_cs4281_pokeBA0(chip, BA0_SPMC, 0);\r\nudelay(50);\r\nsnd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN);\r\nmsleep(50);\r\nif (chip->dual_codec)\r\nsnd_cs4281_pokeBA0(chip, BA0_SPMC, BA0_SPMC_RSTN | BA0_SPMC_ASDI2E);\r\nsnd_cs4281_pokeBA0(chip, BA0_SERMC,\r\n(chip->dual_codec ? BA0_SERMC_TCID(chip->dual_codec) : BA0_SERMC_TCID(1)) |\r\nBA0_SERMC_PTC_AC97 | BA0_SERMC_MSPE);\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, BA0_CLKCR1_DLLP);\r\nmsleep(50);\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, BA0_CLKCR1_SWCE | BA0_CLKCR1_DLLP);\r\nend_time = jiffies + HZ;\r\ndo {\r\nif (snd_cs4281_peekBA0(chip, BA0_CLKCR1) & BA0_CLKCR1_DLLRDY)\r\ngoto __ok0;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\ndev_err(chip->card->dev, "DLLRDY not seen\n");\r\nreturn -EIO;\r\n__ok0:\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_ESYN);\r\nend_time = jiffies + HZ;\r\ndo {\r\nif (snd_cs4281_peekBA0(chip, BA0_ACSTS) & BA0_ACSTS_CRDY)\r\ngoto __ok1;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\ndev_err(chip->card->dev,\r\n"never read codec ready from AC'97 (0x%x)\n",\r\nsnd_cs4281_peekBA0(chip, BA0_ACSTS));\r\nreturn -EIO;\r\n__ok1:\r\nif (chip->dual_codec) {\r\nend_time = jiffies + HZ;\r\ndo {\r\nif (snd_cs4281_peekBA0(chip, BA0_ACSTS2) & BA0_ACSTS_CRDY)\r\ngoto __codec2_ok;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\ndev_info(chip->card->dev,\r\n"secondary codec doesn't respond. disable it...\n");\r\nchip->dual_codec = 0;\r\n__codec2_ok: ;\r\n}\r\nsnd_cs4281_pokeBA0(chip, BA0_ACCTL, BA0_ACCTL_VFRM | BA0_ACCTL_ESYN);\r\nend_time = jiffies + HZ;\r\ndo {\r\nif ((snd_cs4281_peekBA0(chip, BA0_ACISV) & (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4))) == (BA0_ACISV_SLV(3) | BA0_ACISV_SLV(4)))\r\ngoto __ok2;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\nif (--retry_count > 0)\r\ngoto __retry;\r\ndev_err(chip->card->dev, "never read ISV3 and ISV4 from AC'97\n");\r\nreturn -EIO;\r\n__ok2:\r\nsnd_cs4281_pokeBA0(chip, BA0_ACOSV, BA0_ACOSV_SLV(3) | BA0_ACOSV_SLV(4));\r\nfor (tmp = 0; tmp < 4; tmp++) {\r\nstruct cs4281_dma *dma = &chip->dma[tmp];\r\ndma->regDBA = BA0_DBA0 + (tmp * 0x10);\r\ndma->regDCA = BA0_DCA0 + (tmp * 0x10);\r\ndma->regDBC = BA0_DBC0 + (tmp * 0x10);\r\ndma->regDCC = BA0_DCC0 + (tmp * 0x10);\r\ndma->regDMR = BA0_DMR0 + (tmp * 8);\r\ndma->regDCR = BA0_DCR0 + (tmp * 8);\r\ndma->regHDSR = BA0_HDSR0 + (tmp * 4);\r\ndma->regFCR = BA0_FCR0 + (tmp * 4);\r\ndma->regFSIC = BA0_FSIC0 + (tmp * 4);\r\ndma->fifo_offset = tmp * CS4281_FIFO_SIZE;\r\nsnd_cs4281_pokeBA0(chip, dma->regFCR,\r\nBA0_FCR_LS(31) |\r\nBA0_FCR_RS(31) |\r\nBA0_FCR_SZ(CS4281_FIFO_SIZE) |\r\nBA0_FCR_OF(dma->fifo_offset));\r\n}\r\nchip->src_left_play_slot = 0;\r\nchip->src_right_play_slot = 1;\r\nchip->src_left_rec_slot = 10;\r\nchip->src_right_rec_slot = 11;\r\nchip->dma[0].valFCR = BA0_FCR_FEN | BA0_FCR_LS(0) |\r\nBA0_FCR_RS(1) |\r\nBA0_FCR_SZ(CS4281_FIFO_SIZE) |\r\nBA0_FCR_OF(chip->dma[0].fifo_offset);\r\nsnd_cs4281_pokeBA0(chip, chip->dma[0].regFCR, chip->dma[0].valFCR);\r\nsnd_cs4281_pokeBA0(chip, BA0_SRCSA, (chip->src_left_play_slot << 0) |\r\n(chip->src_right_play_slot << 8) |\r\n(chip->src_left_rec_slot << 16) |\r\n(chip->src_right_rec_slot << 24));\r\nsnd_cs4281_pokeBA0(chip, BA0_PPLVC, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_PPRVC, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);\r\nsnd_cs4281_pokeBA0(chip, BA0_HIMR, 0x7fffffff & ~(\r\nBA0_HISR_MIDI |\r\nBA0_HISR_DMAI |\r\nBA0_HISR_DMA(0) |\r\nBA0_HISR_DMA(1) |\r\nBA0_HISR_DMA(2) |\r\nBA0_HISR_DMA(3)));\r\nsynchronize_irq(chip->irq);\r\nreturn 0;\r\n}\r\nstatic void snd_cs4281_midi_reset(struct cs4281 *chip)\r\n{\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr | BA0_MIDCR_MRST);\r\nudelay(100);\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nstatic int snd_cs4281_midi_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct cs4281 *chip = substream->rmidi->private_data;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->midcr |= BA0_MIDCR_RXE;\r\nchip->midi_input = substream;\r\nif (!(chip->uartm & CS4281_MODE_OUTPUT)) {\r\nsnd_cs4281_midi_reset(chip);\r\n} else {\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_midi_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct cs4281 *chip = substream->rmidi->private_data;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->midcr &= ~(BA0_MIDCR_RXE | BA0_MIDCR_RIE);\r\nchip->midi_input = NULL;\r\nif (!(chip->uartm & CS4281_MODE_OUTPUT)) {\r\nsnd_cs4281_midi_reset(chip);\r\n} else {\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nchip->uartm &= ~CS4281_MODE_INPUT;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_midi_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct cs4281 *chip = substream->rmidi->private_data;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->uartm |= CS4281_MODE_OUTPUT;\r\nchip->midcr |= BA0_MIDCR_TXE;\r\nchip->midi_output = substream;\r\nif (!(chip->uartm & CS4281_MODE_INPUT)) {\r\nsnd_cs4281_midi_reset(chip);\r\n} else {\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cs4281_midi_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct cs4281 *chip = substream->rmidi->private_data;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->midcr &= ~(BA0_MIDCR_TXE | BA0_MIDCR_TIE);\r\nchip->midi_output = NULL;\r\nif (!(chip->uartm & CS4281_MODE_INPUT)) {\r\nsnd_cs4281_midi_reset(chip);\r\n} else {\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\nchip->uartm &= ~CS4281_MODE_OUTPUT;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic void snd_cs4281_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nunsigned long flags;\r\nstruct cs4281 *chip = substream->rmidi->private_data;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (up) {\r\nif ((chip->midcr & BA0_MIDCR_RIE) == 0) {\r\nchip->midcr |= BA0_MIDCR_RIE;\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\n} else {\r\nif (chip->midcr & BA0_MIDCR_RIE) {\r\nchip->midcr &= ~BA0_MIDCR_RIE;\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_cs4281_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nunsigned long flags;\r\nstruct cs4281 *chip = substream->rmidi->private_data;\r\nunsigned char byte;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (up) {\r\nif ((chip->midcr & BA0_MIDCR_TIE) == 0) {\r\nchip->midcr |= BA0_MIDCR_TIE;\r\nwhile ((chip->midcr & BA0_MIDCR_TIE) &&\r\n(snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_TBF) == 0) {\r\nif (snd_rawmidi_transmit(substream, &byte, 1) != 1) {\r\nchip->midcr &= ~BA0_MIDCR_TIE;\r\n} else {\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDWP, byte);\r\n}\r\n}\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\n} else {\r\nif (chip->midcr & BA0_MIDCR_TIE) {\r\nchip->midcr &= ~BA0_MIDCR_TIE;\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic int snd_cs4281_midi(struct cs4281 *chip, int device,\r\nstruct snd_rawmidi **rrawmidi)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nif (rrawmidi)\r\n*rrawmidi = NULL;\r\nif ((err = snd_rawmidi_new(chip->card, "CS4281", device, 1, 1, &rmidi)) < 0)\r\nreturn err;\r\nstrcpy(rmidi->name, "CS4281");\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_cs4281_midi_output);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_cs4281_midi_input);\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT | SNDRV_RAWMIDI_INFO_INPUT | SNDRV_RAWMIDI_INFO_DUPLEX;\r\nrmidi->private_data = chip;\r\nchip->rmidi = rmidi;\r\nif (rrawmidi)\r\n*rrawmidi = rmidi;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_cs4281_interrupt(int irq, void *dev_id)\r\n{\r\nstruct cs4281 *chip = dev_id;\r\nunsigned int status, dma, val;\r\nstruct cs4281_dma *cdma;\r\nif (chip == NULL)\r\nreturn IRQ_NONE;\r\nstatus = snd_cs4281_peekBA0(chip, BA0_HISR);\r\nif ((status & 0x7fffffff) == 0) {\r\nsnd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);\r\nreturn IRQ_NONE;\r\n}\r\nif (status & (BA0_HISR_DMA(0)|BA0_HISR_DMA(1)|BA0_HISR_DMA(2)|BA0_HISR_DMA(3))) {\r\nfor (dma = 0; dma < 4; dma++)\r\nif (status & BA0_HISR_DMA(dma)) {\r\ncdma = &chip->dma[dma];\r\nspin_lock(&chip->reg_lock);\r\nval = snd_cs4281_peekBA0(chip, cdma->regHDSR);\r\ncdma->frag++;\r\nif ((val & BA0_HDSR_DHTC) && !(cdma->frag & 1)) {\r\ncdma->frag--;\r\nchip->spurious_dhtc_irq++;\r\nspin_unlock(&chip->reg_lock);\r\ncontinue;\r\n}\r\nif ((val & BA0_HDSR_DTC) && (cdma->frag & 1)) {\r\ncdma->frag--;\r\nchip->spurious_dtc_irq++;\r\nspin_unlock(&chip->reg_lock);\r\ncontinue;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(cdma->substream);\r\n}\r\n}\r\nif ((status & BA0_HISR_MIDI) && chip->rmidi) {\r\nunsigned char c;\r\nspin_lock(&chip->reg_lock);\r\nwhile ((snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_RBE) == 0) {\r\nc = snd_cs4281_peekBA0(chip, BA0_MIDRP);\r\nif ((chip->midcr & BA0_MIDCR_RIE) == 0)\r\ncontinue;\r\nsnd_rawmidi_receive(chip->midi_input, &c, 1);\r\n}\r\nwhile ((snd_cs4281_peekBA0(chip, BA0_MIDSR) & BA0_MIDSR_TBF) == 0) {\r\nif ((chip->midcr & BA0_MIDCR_TIE) == 0)\r\nbreak;\r\nif (snd_rawmidi_transmit(chip->midi_output, &c, 1) != 1) {\r\nchip->midcr &= ~BA0_MIDCR_TIE;\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDCR, chip->midcr);\r\nbreak;\r\n}\r\nsnd_cs4281_pokeBA0(chip, BA0_MIDWP, c);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nsnd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_EOI);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void snd_cs4281_opl3_command(struct snd_opl3 *opl3, unsigned short cmd,\r\nunsigned char val)\r\n{\r\nunsigned long flags;\r\nstruct cs4281 *chip = opl3->private_data;\r\nvoid __iomem *port;\r\nif (cmd & OPL3_RIGHT)\r\nport = chip->ba0 + BA0_B1AP;\r\nelse\r\nport = chip->ba0 + BA0_B0AP;\r\nspin_lock_irqsave(&opl3->reg_lock, flags);\r\nwritel((unsigned int)cmd, port);\r\nudelay(10);\r\nwritel((unsigned int)val, port + 4);\r\nudelay(30);\r\nspin_unlock_irqrestore(&opl3->reg_lock, flags);\r\n}\r\nstatic int snd_cs4281_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct cs4281 *chip;\r\nstruct snd_opl3 *opl3;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_cs4281_create(card, pci, &chip, dual_codec[dev])) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nif ((err = snd_cs4281_mixer(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_cs4281_pcm(chip, 0, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_cs4281_midi(chip, 0, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_opl3_new(card, OPL3_HW_OPL3_CS4281, &opl3)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nopl3->private_data = chip;\r\nopl3->command = snd_cs4281_opl3_command;\r\nsnd_opl3_init(opl3);\r\nif ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_cs4281_create_gameport(chip);\r\nstrcpy(card->driver, "CS4281");\r\nstrcpy(card->shortname, "Cirrus Logic CS4281");\r\nsprintf(card->longname, "%s at 0x%lx, irq %d",\r\ncard->shortname,\r\nchip->ba0_addr,\r\nchip->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_cs4281_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}\r\nstatic int cs4281_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct cs4281 *chip = card->private_data;\r\nu32 ulCLK;\r\nunsigned int i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_ac97_suspend(chip->ac97);\r\nsnd_ac97_suspend(chip->ac97_secondary);\r\nulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);\r\nulCLK |= CLKCR1_CKRA;\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);\r\nsnd_cs4281_pokeBA0(chip, BA0_HICR, BA0_HICR_CHGM);\r\nfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\r\nif (saved_regs[i])\r\nchip->suspend_regs[i] = snd_cs4281_peekBA0(chip, saved_regs[i]);\r\nsnd_cs4281_pokeBA0(chip, BA0_SERMC, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_SSPM, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, 0);\r\nsnd_cs4281_pokeBA0(chip, BA0_SPMC, 0);\r\nulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);\r\nulCLK &= ~CLKCR1_CKRA;\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int cs4281_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct cs4281 *chip = card->private_data;\r\nunsigned int i;\r\nu32 ulCLK;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\ndev_err(dev, "pci_enable_device failed, disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);\r\nulCLK |= CLKCR1_CKRA;\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);\r\nsnd_cs4281_chip_init(chip);\r\nfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\r\nif (saved_regs[i])\r\nsnd_cs4281_pokeBA0(chip, saved_regs[i], chip->suspend_regs[i]);\r\nsnd_ac97_resume(chip->ac97);\r\nsnd_ac97_resume(chip->ac97_secondary);\r\nulCLK = snd_cs4281_peekBA0(chip, BA0_CLKCR1);\r\nulCLK &= ~CLKCR1_CKRA;\r\nsnd_cs4281_pokeBA0(chip, BA0_CLKCR1, ulCLK);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
