static int vmcp_open(struct inode *inode, struct file *file)\r\n{\r\nstruct vmcp_session *session;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nsession = kmalloc(sizeof(*session), GFP_KERNEL);\r\nif (!session)\r\nreturn -ENOMEM;\r\nsession->bufsize = PAGE_SIZE;\r\nsession->response = NULL;\r\nsession->resp_size = 0;\r\nmutex_init(&session->mutex);\r\nfile->private_data = session;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int vmcp_release(struct inode *inode, struct file *file)\r\n{\r\nstruct vmcp_session *session;\r\nsession = file->private_data;\r\nfile->private_data = NULL;\r\nfree_pages((unsigned long)session->response, get_order(session->bufsize));\r\nkfree(session);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nvmcp_read(struct file *file, char __user *buff, size_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nsize_t size;\r\nstruct vmcp_session *session;\r\nsession = file->private_data;\r\nif (mutex_lock_interruptible(&session->mutex))\r\nreturn -ERESTARTSYS;\r\nif (!session->response) {\r\nmutex_unlock(&session->mutex);\r\nreturn 0;\r\n}\r\nsize = min_t(size_t, session->resp_size, session->bufsize);\r\nret = simple_read_from_buffer(buff, count, ppos,\r\nsession->response, size);\r\nmutex_unlock(&session->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nvmcp_write(struct file *file, const char __user *buff, size_t count,\r\nloff_t *ppos)\r\n{\r\nchar *cmd;\r\nstruct vmcp_session *session;\r\nif (count > 240)\r\nreturn -EINVAL;\r\ncmd = kmalloc(count + 1, GFP_KERNEL);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nif (copy_from_user(cmd, buff, count)) {\r\nkfree(cmd);\r\nreturn -EFAULT;\r\n}\r\ncmd[count] = '\0';\r\nsession = file->private_data;\r\nif (mutex_lock_interruptible(&session->mutex)) {\r\nkfree(cmd);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (!session->response)\r\nsession->response = (char *)__get_free_pages(GFP_KERNEL\r\n| __GFP_REPEAT | GFP_DMA,\r\nget_order(session->bufsize));\r\nif (!session->response) {\r\nmutex_unlock(&session->mutex);\r\nkfree(cmd);\r\nreturn -ENOMEM;\r\n}\r\ndebug_text_event(vmcp_debug, 1, cmd);\r\nsession->resp_size = cpcmd(cmd, session->response, session->bufsize,\r\n&session->resp_code);\r\nmutex_unlock(&session->mutex);\r\nkfree(cmd);\r\n*ppos = 0;\r\nreturn count;\r\n}\r\nstatic long vmcp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct vmcp_session *session;\r\nint __user *argp;\r\nint temp;\r\nsession = file->private_data;\r\nif (is_compat_task())\r\nargp = compat_ptr(arg);\r\nelse\r\nargp = (int __user *)arg;\r\nif (mutex_lock_interruptible(&session->mutex))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase VMCP_GETCODE:\r\ntemp = session->resp_code;\r\nmutex_unlock(&session->mutex);\r\nreturn put_user(temp, argp);\r\ncase VMCP_SETBUF:\r\nfree_pages((unsigned long)session->response,\r\nget_order(session->bufsize));\r\nsession->response=NULL;\r\ntemp = get_user(session->bufsize, argp);\r\nif (get_order(session->bufsize) > 8) {\r\nsession->bufsize = PAGE_SIZE;\r\ntemp = -EINVAL;\r\n}\r\nmutex_unlock(&session->mutex);\r\nreturn temp;\r\ncase VMCP_GETSIZE:\r\ntemp = session->resp_size;\r\nmutex_unlock(&session->mutex);\r\nreturn put_user(temp, argp);\r\ndefault:\r\nmutex_unlock(&session->mutex);\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int __init vmcp_init(void)\r\n{\r\nint ret;\r\nif (!MACHINE_IS_VM)\r\nreturn 0;\r\nvmcp_debug = debug_register("vmcp", 1, 1, 240);\r\nif (!vmcp_debug)\r\nreturn -ENOMEM;\r\nret = debug_register_view(vmcp_debug, &debug_hex_ascii_view);\r\nif (ret) {\r\ndebug_unregister(vmcp_debug);\r\nreturn ret;\r\n}\r\nret = misc_register(&vmcp_dev);\r\nif (ret)\r\ndebug_unregister(vmcp_debug);\r\nreturn ret;\r\n}
