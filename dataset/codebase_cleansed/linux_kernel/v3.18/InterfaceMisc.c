static int adapter_err_occurred(const struct bcm_interface_adapter *ad)\r\n{\r\nif (ad->psAdapter->device_removed == TRUE) {\r\nBCM_DEBUG_PRINT(ad->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"Device got removed");\r\nreturn -ENODEV;\r\n}\r\nif ((ad->psAdapter->StopAllXaction == TRUE) &&\r\n(ad->psAdapter->chip_id >= T3LPB)) {\r\nBCM_DEBUG_PRINT(ad->psAdapter, DBG_TYPE_OTHERS, RDM,\r\nDBG_LVL_ALL,\r\n"Currently Xaction is not allowed on the bus");\r\nreturn -EACCES;\r\n}\r\nif (ad->bSuspended == TRUE || ad->bPreparingForBusSuspend == TRUE) {\r\nBCM_DEBUG_PRINT(ad->psAdapter, DBG_TYPE_OTHERS, RDM,\r\nDBG_LVL_ALL,\r\n"Bus is in suspended states hence RDM not allowed..");\r\nreturn -EACCES;\r\n}\r\nreturn 0;\r\n}\r\nint InterfaceRDM(struct bcm_interface_adapter *psIntfAdapter,\r\nunsigned int addr,\r\nvoid *buff,\r\nint len)\r\n{\r\nint bytes;\r\nint err = 0;\r\nif (!psIntfAdapter)\r\nreturn -EINVAL;\r\nerr = adapter_err_occurred(psIntfAdapter);\r\nif (err)\r\nreturn err;\r\npsIntfAdapter->psAdapter->DeviceAccess = TRUE;\r\nbytes = usb_control_msg(psIntfAdapter->udev,\r\nusb_rcvctrlpipe(psIntfAdapter->udev, 0),\r\n0x02,\r\n0xC2,\r\n(addr & 0xFFFF),\r\n((addr >> 16) & 0xFFFF),\r\nbuff,\r\nlen,\r\n5000);\r\nif (-ENODEV == bytes)\r\npsIntfAdapter->psAdapter->device_removed = TRUE;\r\nif (bytes < 0)\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, RDM,\r\nDBG_LVL_ALL, "RDM failed status :%d", bytes);\r\nelse\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, RDM,\r\nDBG_LVL_ALL, "RDM sent %d", bytes);\r\npsIntfAdapter->psAdapter->DeviceAccess = false;\r\nreturn bytes;\r\n}\r\nint InterfaceWRM(struct bcm_interface_adapter *psIntfAdapter,\r\nunsigned int addr,\r\nvoid *buff,\r\nint len)\r\n{\r\nint retval = 0;\r\nint err = 0;\r\nif (!psIntfAdapter)\r\nreturn -EINVAL;\r\nerr = adapter_err_occurred(psIntfAdapter);\r\nif (err)\r\nreturn err;\r\npsIntfAdapter->psAdapter->DeviceAccess = TRUE;\r\nretval = usb_control_msg(psIntfAdapter->udev,\r\nusb_sndctrlpipe(psIntfAdapter->udev, 0),\r\n0x01,\r\n0x42,\r\n(addr & 0xFFFF),\r\n((addr >> 16) & 0xFFFF),\r\nbuff,\r\nlen,\r\n5000);\r\nif (-ENODEV == retval)\r\npsIntfAdapter->psAdapter->device_removed = TRUE;\r\nif (retval < 0) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, WRM,\r\nDBG_LVL_ALL, "WRM failed status :%d", retval);\r\npsIntfAdapter->psAdapter->DeviceAccess = false;\r\nreturn retval;\r\n} else {\r\npsIntfAdapter->psAdapter->DeviceAccess = false;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, WRM,\r\nDBG_LVL_ALL, "WRM sent %d", retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\n}\r\nint BcmRDM(void *arg,\r\nunsigned int addr,\r\nvoid *buff,\r\nint len)\r\n{\r\nreturn InterfaceRDM((struct bcm_interface_adapter *)arg, addr, buff,\r\nlen);\r\n}\r\nint BcmWRM(void *arg,\r\nunsigned int addr,\r\nvoid *buff,\r\nint len)\r\n{\r\nreturn InterfaceWRM((struct bcm_interface_adapter *)arg, addr, buff,\r\nlen);\r\n}\r\nint Bcm_clear_halt_of_endpoints(struct bcm_mini_adapter *Adapter)\r\n{\r\nstruct bcm_interface_adapter *psIntfAdapter =\r\n(struct bcm_interface_adapter *)(Adapter->pvInterfaceAdapter);\r\nint status = STATUS_SUCCESS;\r\nBcm_kill_all_URBs(psIntfAdapter);\r\nstatus = usb_clear_halt(psIntfAdapter->udev,\r\npsIntfAdapter->sIntrIn.int_in_pipe);\r\nif (status != STATUS_SUCCESS)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL,\r\n"Unable to Clear Halt of Interrupt IN end point. :%d ",\r\nstatus);\r\nstatus = usb_clear_halt(psIntfAdapter->udev,\r\npsIntfAdapter->sBulkIn.bulk_in_pipe);\r\nif (status != STATUS_SUCCESS)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL,\r\n"Unable to Clear Halt of Bulk IN end point. :%d ",\r\nstatus);\r\nstatus = usb_clear_halt(psIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut.bulk_out_pipe);\r\nif (status != STATUS_SUCCESS)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL,\r\n"Unable to Clear Halt of Bulk OUT end point. :%d ",\r\nstatus);\r\nreturn status;\r\n}\r\nvoid Bcm_kill_all_URBs(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nstruct urb *tempUrb = NULL;\r\nunsigned int i;\r\nif (psIntfAdapter->psInterruptUrb) {\r\nif (psIntfAdapter->psInterruptUrb->status == -EINPROGRESS)\r\nusb_kill_urb(psIntfAdapter->psInterruptUrb);\r\n}\r\nfor (i = 0; i < MAXIMUM_USB_TCB; i++) {\r\ntempUrb = psIntfAdapter->asUsbTcb[i].urb;\r\nif (tempUrb) {\r\nif (tempUrb->status == -EINPROGRESS)\r\nusb_kill_urb(tempUrb);\r\n}\r\n}\r\nfor (i = 0; i < MAXIMUM_USB_RCB; i++) {\r\ntempUrb = psIntfAdapter->asUsbRcb[i].urb;\r\nif (tempUrb) {\r\nif (tempUrb->status == -EINPROGRESS)\r\nusb_kill_urb(tempUrb);\r\n}\r\n}\r\natomic_set(&psIntfAdapter->uNumTcbUsed, 0);\r\natomic_set(&psIntfAdapter->uCurrTcb, 0);\r\natomic_set(&psIntfAdapter->uNumRcbUsed, 0);\r\natomic_set(&psIntfAdapter->uCurrRcb, 0);\r\n}\r\nvoid putUsbSuspend(struct work_struct *work)\r\n{\r\nstruct bcm_interface_adapter *psIntfAdapter = NULL;\r\nstruct usb_interface *intf = NULL;\r\npsIntfAdapter = container_of(work, struct bcm_interface_adapter,\r\nusbSuspendWork);\r\nintf = psIntfAdapter->interface;\r\nif (psIntfAdapter->bSuspended == false)\r\nusb_autopm_put_interface(intf);\r\n}
