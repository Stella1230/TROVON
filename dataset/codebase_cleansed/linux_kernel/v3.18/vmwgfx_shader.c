static inline struct vmw_shader *\r\nvmw_res_to_shader(struct vmw_resource *res)\r\n{\r\nreturn container_of(res, struct vmw_shader, res);\r\n}\r\nstatic void vmw_hw_shader_destroy(struct vmw_resource *res)\r\n{\r\n(void) vmw_gb_shader_destroy(res);\r\n}\r\nstatic int vmw_gb_shader_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nuint32_t size,\r\nuint64_t offset,\r\nSVGA3dShaderType type,\r\nstruct vmw_dma_buffer *byte_code,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nstruct vmw_shader *shader = vmw_res_to_shader(res);\r\nint ret;\r\nret = vmw_resource_init(dev_priv, res, true,\r\nres_free, &vmw_gb_shader_func);\r\nif (unlikely(ret != 0)) {\r\nif (res_free)\r\nres_free(res);\r\nelse\r\nkfree(res);\r\nreturn ret;\r\n}\r\nres->backup_size = size;\r\nif (byte_code) {\r\nres->backup = vmw_dmabuf_reference(byte_code);\r\nres->backup_offset = offset;\r\n}\r\nshader->size = size;\r\nshader->type = type;\r\nvmw_resource_activate(res, vmw_hw_shader_destroy);\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_create(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_shader *shader = vmw_res_to_shader(res);\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineGBShader body;\r\n} *cmd;\r\nif (likely(res->id != -1))\r\nreturn 0;\r\nret = vmw_resource_alloc_id(res);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a shader id.\n");\r\ngoto out_no_id;\r\n}\r\nif (unlikely(res->id >= VMWGFX_NUM_GB_SHADER)) {\r\nret = -EBUSY;\r\ngoto out_no_fifo;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"creation.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DEFINE_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.type = shader->type;\r\ncmd->body.sizeInBytes = shader->size;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_3d_resource_inc(dev_priv, false);\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_resource_release_id(res);\r\nout_no_id:\r\nreturn ret;\r\n}\r\nstatic int vmw_gb_shader_bind(struct vmw_resource *res,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBShader body;\r\n} *cmd;\r\nstruct ttm_buffer_object *bo = val_buf->bo;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"binding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.mobid = bo->mem.start;\r\ncmd->body.offsetInBytes = 0;\r\nres->backup_dirty = false;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_unbind(struct vmw_resource *res,\r\nbool readback,\r\nstruct ttm_validate_buffer *val_buf)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdBindGBShader body;\r\n} *cmd;\r\nstruct vmw_fence_obj *fence;\r\nBUG_ON(res->backup->base.mem.mem_type != VMW_PL_MOB);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"unbinding.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_BIND_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\ncmd->body.mobid = SVGA3D_INVALID_ID;\r\ncmd->body.offsetInBytes = 0;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nvmw_fence_single_bo(val_buf->bo, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nreturn 0;\r\n}\r\nstatic int vmw_gb_shader_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyGBShader body;\r\n} *cmd;\r\nif (likely(res->id == -1))\r\nreturn 0;\r\nmutex_lock(&dev_priv->binding_mutex);\r\nvmw_context_binding_res_list_scrub(&res->binding_head);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for shader "\r\n"destruction.\n");\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_DESTROY_GB_SHADER;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.shid = res->id;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nmutex_unlock(&dev_priv->binding_mutex);\r\nvmw_resource_release_id(res);\r\nvmw_3d_resource_dec(dev_priv, false);\r\nreturn 0;\r\n}\r\nstatic struct vmw_resource *\r\nvmw_user_shader_base_to_res(struct ttm_base_object *base)\r\n{\r\nreturn &(container_of(base, struct vmw_user_shader, base)->\r\nshader.res);\r\n}\r\nstatic void vmw_user_shader_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_shader *ushader =\r\ncontainer_of(res, struct vmw_user_shader, shader.res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nttm_base_object_kfree(ushader, base);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size);\r\n}\r\nstatic void vmw_shader_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_shader *shader = vmw_res_to_shader(res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nkfree(shader);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_shader_size);\r\n}\r\nstatic void vmw_user_shader_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_resource *res = vmw_user_shader_base_to_res(base);\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_shader_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_shader_arg *arg = (struct drm_vmw_shader_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nreturn ttm_ref_object_base_unref(tfile, arg->handle,\r\nTTM_REF_USAGE);\r\n}\r\nstatic int vmw_user_shader_alloc(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buffer,\r\nsize_t shader_size,\r\nsize_t offset,\r\nSVGA3dShaderType shader_type,\r\nstruct ttm_object_file *tfile,\r\nu32 *handle)\r\n{\r\nstruct vmw_user_shader *ushader;\r\nstruct vmw_resource *res, *tmp;\r\nint ret;\r\nif (unlikely(vmw_user_shader_size == 0))\r\nvmw_user_shader_size =\r\nttm_round_pot(sizeof(struct vmw_user_shader)) + 128;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for shader "\r\n"creation.\n");\r\ngoto out;\r\n}\r\nushader = kzalloc(sizeof(*ushader), GFP_KERNEL);\r\nif (unlikely(ushader == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_shader_size);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nres = &ushader->shader.res;\r\nushader->base.shareable = false;\r\nushader->base.tfile = NULL;\r\nret = vmw_gb_shader_init(dev_priv, res, shader_size,\r\noffset, shader_type, buffer,\r\nvmw_user_shader_free);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\ntmp = vmw_resource_reference(res);\r\nret = ttm_base_object_init(tfile, &ushader->base, false,\r\nVMW_RES_SHADER,\r\n&vmw_user_shader_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\nif (handle)\r\n*handle = ushader->base.hash.key;\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout:\r\nreturn ret;\r\n}\r\nstruct vmw_resource *vmw_shader_alloc(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *buffer,\r\nsize_t shader_size,\r\nsize_t offset,\r\nSVGA3dShaderType shader_type)\r\n{\r\nstruct vmw_shader *shader;\r\nstruct vmw_resource *res;\r\nint ret;\r\nif (unlikely(vmw_shader_size == 0))\r\nvmw_shader_size =\r\nttm_round_pot(sizeof(struct vmw_shader)) + 128;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_shader_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for shader "\r\n"creation.\n");\r\ngoto out_err;\r\n}\r\nshader = kzalloc(sizeof(*shader), GFP_KERNEL);\r\nif (unlikely(shader == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_shader_size);\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nres = &shader->res;\r\nret = vmw_gb_shader_init(dev_priv, res, shader_size,\r\noffset, shader_type, buffer,\r\nvmw_shader_free);\r\nout_err:\r\nreturn ret ? ERR_PTR(ret) : res;\r\n}\r\nint vmw_shader_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_shader_create_arg *arg =\r\n(struct drm_vmw_shader_create_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_dma_buffer *buffer = NULL;\r\nSVGA3dShaderType shader_type;\r\nint ret;\r\nif (arg->buffer_handle != SVGA3D_INVALID_ID) {\r\nret = vmw_user_dmabuf_lookup(tfile, arg->buffer_handle,\r\n&buffer);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Could not find buffer for shader "\r\n"creation.\n");\r\nreturn ret;\r\n}\r\nif ((u64)buffer->base.num_pages * PAGE_SIZE <\r\n(u64)arg->size + (u64)arg->offset) {\r\nDRM_ERROR("Illegal buffer- or shader size.\n");\r\nret = -EINVAL;\r\ngoto out_bad_arg;\r\n}\r\n}\r\nswitch (arg->shader_type) {\r\ncase drm_vmw_shader_type_vs:\r\nshader_type = SVGA3D_SHADERTYPE_VS;\r\nbreak;\r\ncase drm_vmw_shader_type_ps:\r\nshader_type = SVGA3D_SHADERTYPE_PS;\r\nbreak;\r\ncase drm_vmw_shader_type_gs:\r\nshader_type = SVGA3D_SHADERTYPE_GS;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Illegal shader type.\n");\r\nret = -EINVAL;\r\ngoto out_bad_arg;\r\n}\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0))\r\ngoto out_bad_arg;\r\nret = vmw_user_shader_alloc(dev_priv, buffer, arg->size, arg->offset,\r\nshader_type, tfile, &arg->shader_handle);\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nout_bad_arg:\r\nvmw_dmabuf_unreference(&buffer);\r\nreturn ret;\r\n}\r\nstatic bool vmw_compat_shader_id_ok(u32 user_key, SVGA3dShaderType shader_type)\r\n{\r\nreturn user_key <= ((1 << 20) - 1) && (unsigned) shader_type < 16;\r\n}\r\nstatic u32 vmw_compat_shader_key(u32 user_key, SVGA3dShaderType shader_type)\r\n{\r\nreturn user_key | (shader_type << 20);\r\n}\r\nint vmw_compat_shader_remove(struct vmw_cmdbuf_res_manager *man,\r\nu32 user_key, SVGA3dShaderType shader_type,\r\nstruct list_head *list)\r\n{\r\nif (!vmw_compat_shader_id_ok(user_key, shader_type))\r\nreturn -EINVAL;\r\nreturn vmw_cmdbuf_res_remove(man, vmw_cmdbuf_res_compat_shader,\r\nvmw_compat_shader_key(user_key,\r\nshader_type),\r\nlist);\r\n}\r\nint vmw_compat_shader_add(struct vmw_private *dev_priv,\r\nstruct vmw_cmdbuf_res_manager *man,\r\nu32 user_key, const void *bytecode,\r\nSVGA3dShaderType shader_type,\r\nsize_t size,\r\nstruct list_head *list)\r\n{\r\nstruct vmw_dma_buffer *buf;\r\nstruct ttm_bo_kmap_obj map;\r\nbool is_iomem;\r\nint ret;\r\nstruct vmw_resource *res;\r\nif (!vmw_compat_shader_id_ok(user_key, shader_type))\r\nreturn -EINVAL;\r\nbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (unlikely(buf == NULL))\r\nreturn -ENOMEM;\r\nret = vmw_dmabuf_init(dev_priv, buf, size, &vmw_sys_ne_placement,\r\ntrue, vmw_dmabuf_bo_free);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\nret = ttm_bo_reserve(&buf->base, false, true, false, NULL);\r\nif (unlikely(ret != 0))\r\ngoto no_reserve;\r\nret = ttm_bo_kmap(&buf->base, 0, PAGE_ALIGN(size) >> PAGE_SHIFT,\r\n&map);\r\nif (unlikely(ret != 0)) {\r\nttm_bo_unreserve(&buf->base);\r\ngoto no_reserve;\r\n}\r\nmemcpy(ttm_kmap_obj_virtual(&map, &is_iomem), bytecode, size);\r\nWARN_ON(is_iomem);\r\nttm_bo_kunmap(&map);\r\nret = ttm_bo_validate(&buf->base, &vmw_sys_placement, false, true);\r\nWARN_ON(ret != 0);\r\nttm_bo_unreserve(&buf->base);\r\nres = vmw_shader_alloc(dev_priv, buf, size, 0, shader_type);\r\nif (unlikely(ret != 0))\r\ngoto no_reserve;\r\nret = vmw_cmdbuf_res_add(man, vmw_cmdbuf_res_compat_shader,\r\nvmw_compat_shader_key(user_key, shader_type),\r\nres, list);\r\nvmw_resource_unreference(&res);\r\nno_reserve:\r\nvmw_dmabuf_unreference(&buf);\r\nout:\r\nreturn ret;\r\n}\r\nstruct vmw_resource *\r\nvmw_compat_shader_lookup(struct vmw_cmdbuf_res_manager *man,\r\nu32 user_key,\r\nSVGA3dShaderType shader_type)\r\n{\r\nif (!vmw_compat_shader_id_ok(user_key, shader_type))\r\nreturn ERR_PTR(-EINVAL);\r\nreturn vmw_cmdbuf_res_lookup(man, vmw_cmdbuf_res_compat_shader,\r\nvmw_compat_shader_key(user_key,\r\nshader_type));\r\n}
