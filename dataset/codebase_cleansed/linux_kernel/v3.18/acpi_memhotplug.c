static acpi_status\r\nacpi_memory_get_resource(struct acpi_resource *resource, void *context)\r\n{\r\nstruct acpi_memory_device *mem_device = context;\r\nstruct acpi_resource_address64 address64;\r\nstruct acpi_memory_info *info, *new;\r\nacpi_status status;\r\nstatus = acpi_resource_to_address64(resource, &address64);\r\nif (ACPI_FAILURE(status) ||\r\n(address64.resource_type != ACPI_MEMORY_RANGE))\r\nreturn AE_OK;\r\nlist_for_each_entry(info, &mem_device->res_list, list) {\r\nif ((info->caching == address64.info.mem.caching) &&\r\n(info->write_protect == address64.info.mem.write_protect) &&\r\n(info->start_addr + info->length == address64.minimum)) {\r\ninfo->length += address64.address_length;\r\nreturn AE_OK;\r\n}\r\n}\r\nnew = kzalloc(sizeof(struct acpi_memory_info), GFP_KERNEL);\r\nif (!new)\r\nreturn AE_ERROR;\r\nINIT_LIST_HEAD(&new->list);\r\nnew->caching = address64.info.mem.caching;\r\nnew->write_protect = address64.info.mem.write_protect;\r\nnew->start_addr = address64.minimum;\r\nnew->length = address64.address_length;\r\nlist_add_tail(&new->list, &mem_device->res_list);\r\nreturn AE_OK;\r\n}\r\nstatic void\r\nacpi_memory_free_device_resources(struct acpi_memory_device *mem_device)\r\n{\r\nstruct acpi_memory_info *info, *n;\r\nlist_for_each_entry_safe(info, n, &mem_device->res_list, list)\r\nkfree(info);\r\nINIT_LIST_HEAD(&mem_device->res_list);\r\n}\r\nstatic int\r\nacpi_memory_get_device_resources(struct acpi_memory_device *mem_device)\r\n{\r\nacpi_status status;\r\nif (!list_empty(&mem_device->res_list))\r\nreturn 0;\r\nstatus = acpi_walk_resources(mem_device->device->handle, METHOD_NAME__CRS,\r\nacpi_memory_get_resource, mem_device);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_memory_free_device_resources(mem_device);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_memory_check_device(struct acpi_memory_device *mem_device)\r\n{\r\nunsigned long long current_status;\r\nif (ACPI_FAILURE(acpi_evaluate_integer(mem_device->device->handle,\r\nMETHOD_NAME__STA, NULL,\r\n&current_status)))\r\nreturn -ENODEV;\r\nif (!((current_status & ACPI_STA_DEVICE_PRESENT)\r\n&& (current_status & ACPI_STA_DEVICE_ENABLED)\r\n&& (current_status & ACPI_STA_DEVICE_FUNCTIONING)))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic unsigned long acpi_meminfo_start_pfn(struct acpi_memory_info *info)\r\n{\r\nreturn PFN_DOWN(info->start_addr);\r\n}\r\nstatic unsigned long acpi_meminfo_end_pfn(struct acpi_memory_info *info)\r\n{\r\nreturn PFN_UP(info->start_addr + info->length-1);\r\n}\r\nstatic int acpi_bind_memblk(struct memory_block *mem, void *arg)\r\n{\r\nreturn acpi_bind_one(&mem->dev, arg);\r\n}\r\nstatic int acpi_bind_memory_blocks(struct acpi_memory_info *info,\r\nstruct acpi_device *adev)\r\n{\r\nreturn walk_memory_range(acpi_meminfo_start_pfn(info),\r\nacpi_meminfo_end_pfn(info), adev,\r\nacpi_bind_memblk);\r\n}\r\nstatic int acpi_unbind_memblk(struct memory_block *mem, void *arg)\r\n{\r\nacpi_unbind_one(&mem->dev);\r\nreturn 0;\r\n}\r\nstatic void acpi_unbind_memory_blocks(struct acpi_memory_info *info)\r\n{\r\nwalk_memory_range(acpi_meminfo_start_pfn(info),\r\nacpi_meminfo_end_pfn(info), NULL, acpi_unbind_memblk);\r\n}\r\nstatic int acpi_memory_enable_device(struct acpi_memory_device *mem_device)\r\n{\r\nacpi_handle handle = mem_device->device->handle;\r\nint result, num_enabled = 0;\r\nstruct acpi_memory_info *info;\r\nint node;\r\nnode = acpi_get_node(handle);\r\nlist_for_each_entry(info, &mem_device->res_list, list) {\r\nif (info->enabled) {\r\nnum_enabled++;\r\ncontinue;\r\n}\r\nif (!info->length)\r\ncontinue;\r\nif (node < 0)\r\nnode = memory_add_physaddr_to_nid(info->start_addr);\r\nresult = add_memory(node, info->start_addr, info->length);\r\nif (result && result != -EEXIST)\r\ncontinue;\r\nresult = acpi_bind_memory_blocks(info, mem_device->device);\r\nif (result) {\r\nacpi_unbind_memory_blocks(info);\r\nreturn -ENODEV;\r\n}\r\ninfo->enabled = 1;\r\nnum_enabled++;\r\n}\r\nif (!num_enabled) {\r\ndev_err(&mem_device->device->dev, "add_memory failed\n");\r\nmem_device->state = MEMORY_INVALID_STATE;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_memory_remove_memory(struct acpi_memory_device *mem_device)\r\n{\r\nacpi_handle handle = mem_device->device->handle;\r\nstruct acpi_memory_info *info, *n;\r\nint nid = acpi_get_node(handle);\r\nlist_for_each_entry_safe(info, n, &mem_device->res_list, list) {\r\nif (!info->enabled)\r\ncontinue;\r\nif (nid == NUMA_NO_NODE)\r\nnid = memory_add_physaddr_to_nid(info->start_addr);\r\nacpi_unbind_memory_blocks(info);\r\nremove_memory(nid, info->start_addr, info->length);\r\nlist_del(&info->list);\r\nkfree(info);\r\n}\r\n}\r\nstatic void acpi_memory_device_free(struct acpi_memory_device *mem_device)\r\n{\r\nif (!mem_device)\r\nreturn;\r\nacpi_memory_free_device_resources(mem_device);\r\nmem_device->device->driver_data = NULL;\r\nkfree(mem_device);\r\n}\r\nstatic int acpi_memory_device_add(struct acpi_device *device,\r\nconst struct acpi_device_id *not_used)\r\n{\r\nstruct acpi_memory_device *mem_device;\r\nint result;\r\nif (!device)\r\nreturn -EINVAL;\r\nmem_device = kzalloc(sizeof(struct acpi_memory_device), GFP_KERNEL);\r\nif (!mem_device)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&mem_device->res_list);\r\nmem_device->device = device;\r\nsprintf(acpi_device_name(device), "%s", ACPI_MEMORY_DEVICE_NAME);\r\nsprintf(acpi_device_class(device), "%s", ACPI_MEMORY_DEVICE_CLASS);\r\ndevice->driver_data = mem_device;\r\nresult = acpi_memory_get_device_resources(mem_device);\r\nif (result) {\r\ndevice->driver_data = NULL;\r\nkfree(mem_device);\r\nreturn result;\r\n}\r\nmem_device->state = MEMORY_POWER_ON_STATE;\r\nresult = acpi_memory_check_device(mem_device);\r\nif (result) {\r\nacpi_memory_device_free(mem_device);\r\nreturn 0;\r\n}\r\nresult = acpi_memory_enable_device(mem_device);\r\nif (result) {\r\ndev_err(&device->dev, "acpi_memory_enable_device() error\n");\r\nacpi_memory_device_free(mem_device);\r\nreturn result;\r\n}\r\ndev_dbg(&device->dev, "Memory device configured by ACPI\n");\r\nreturn 1;\r\n}\r\nstatic void acpi_memory_device_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_memory_device *mem_device;\r\nif (!device || !acpi_driver_data(device))\r\nreturn;\r\nmem_device = acpi_driver_data(device);\r\nacpi_memory_remove_memory(mem_device);\r\nacpi_memory_device_free(mem_device);\r\n}\r\nvoid __init acpi_memory_hotplug_init(void)\r\n{\r\nif (acpi_no_memhotplug) {\r\nmemory_device_handler.attach = NULL;\r\nacpi_scan_add_handler(&memory_device_handler);\r\nreturn;\r\n}\r\nacpi_scan_add_handler_with_hotplug(&memory_device_handler, "memory");\r\n}\r\nstatic int __init disable_acpi_memory_hotplug(char *str)\r\n{\r\nacpi_no_memhotplug = true;\r\nreturn 1;\r\n}\r\nvoid __init acpi_memory_hotplug_init(void)\r\n{\r\nacpi_scan_add_handler(&memory_device_handler);\r\n}
