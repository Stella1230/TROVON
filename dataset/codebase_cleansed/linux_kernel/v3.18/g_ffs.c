static int __init gfs_init(void)\r\n{\r\nstruct f_fs_opts *opts;\r\nint i;\r\nint ret = 0;\r\nENTER();\r\nif (func_num < 2) {\r\ngfs_single_func = true;\r\nfunc_num = 1;\r\n}\r\nf_ffs[0] = kcalloc(func_num * N_CONF, sizeof(*f_ffs), GFP_KERNEL);\r\nif (!f_ffs[0]) {\r\nret = -ENOMEM;\r\ngoto no_func;\r\n}\r\nfor (i = 1; i < N_CONF; ++i)\r\nf_ffs[i] = f_ffs[0] + i * func_num;\r\nfi_ffs = kcalloc(func_num, sizeof(*fi_ffs), GFP_KERNEL);\r\nif (!fi_ffs) {\r\nret = -ENOMEM;\r\ngoto no_func;\r\n}\r\nfor (i = 0; i < func_num; i++) {\r\nfi_ffs[i] = usb_get_function_instance("ffs");\r\nif (IS_ERR(fi_ffs[i])) {\r\nret = PTR_ERR(fi_ffs[i]);\r\n--i;\r\ngoto no_dev;\r\n}\r\nopts = to_f_fs_opts(fi_ffs[i]);\r\nif (gfs_single_func)\r\nret = ffs_single_dev(opts->dev);\r\nelse\r\nret = ffs_name_dev(opts->dev, func_names[i]);\r\nif (ret)\r\ngoto no_dev;\r\nopts->dev->ffs_ready_callback = functionfs_ready_callback;\r\nopts->dev->ffs_closed_callback = functionfs_closed_callback;\r\nopts->dev->ffs_acquire_dev_callback = functionfs_acquire_dev;\r\nopts->dev->ffs_release_dev_callback = functionfs_release_dev;\r\nopts->no_configfs = true;\r\n}\r\nmissing_funcs = func_num;\r\nreturn 0;\r\nno_dev:\r\nwhile (i >= 0)\r\nusb_put_function_instance(fi_ffs[i--]);\r\nkfree(fi_ffs);\r\nno_func:\r\nkfree(f_ffs[0]);\r\nreturn ret;\r\n}\r\nstatic void __exit gfs_exit(void)\r\n{\r\nint i;\r\nENTER();\r\nif (gfs_registered)\r\nusb_composite_unregister(&gfs_driver);\r\ngfs_registered = false;\r\nkfree(f_ffs[0]);\r\nfor (i = 0; i < func_num; i++)\r\nusb_put_function_instance(fi_ffs[i]);\r\nkfree(fi_ffs);\r\n}\r\nstatic void *functionfs_acquire_dev(struct ffs_dev *dev)\r\n{\r\nif (!try_module_get(THIS_MODULE))\r\nreturn ERR_PTR(-ENOENT);\r\nreturn 0;\r\n}\r\nstatic void functionfs_release_dev(struct ffs_dev *dev)\r\n{\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int functionfs_ready_callback(struct ffs_data *ffs)\r\n{\r\nint ret = 0;\r\nif (--missing_funcs)\r\nreturn 0;\r\nif (gfs_registered)\r\nreturn -EBUSY;\r\ngfs_registered = true;\r\nret = usb_composite_probe(&gfs_driver);\r\nif (unlikely(ret < 0))\r\ngfs_registered = false;\r\nreturn ret;\r\n}\r\nstatic void functionfs_closed_callback(struct ffs_data *ffs)\r\n{\r\nmissing_funcs++;\r\nif (gfs_registered)\r\nusb_composite_unregister(&gfs_driver);\r\ngfs_registered = false;\r\n}\r\nstatic int gfs_bind(struct usb_composite_dev *cdev)\r\n{\r\n#if defined CONFIG_USB_FUNCTIONFS_ETH || defined CONFIG_USB_FUNCTIONFS_RNDIS\r\nstruct net_device *net;\r\n#endif\r\nint ret, i;\r\nENTER();\r\nif (missing_funcs)\r\nreturn -ENODEV;\r\n#if defined CONFIG_USB_FUNCTIONFS_ETH\r\nif (can_support_ecm(cdev->gadget)) {\r\nstruct f_ecm_opts *ecm_opts;\r\nfi_ecm = usb_get_function_instance("ecm");\r\nif (IS_ERR(fi_ecm))\r\nreturn PTR_ERR(fi_ecm);\r\necm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);\r\nnet = ecm_opts->net;\r\n} else {\r\nstruct f_gether_opts *geth_opts;\r\nfi_geth = usb_get_function_instance("geth");\r\nif (IS_ERR(fi_geth))\r\nreturn PTR_ERR(fi_geth);\r\ngeth_opts = container_of(fi_geth, struct f_gether_opts,\r\nfunc_inst);\r\nnet = geth_opts->net;\r\n}\r\n#endif\r\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\r\n{\r\nstruct f_rndis_opts *rndis_opts;\r\nfi_rndis = usb_get_function_instance("rndis");\r\nif (IS_ERR(fi_rndis)) {\r\nret = PTR_ERR(fi_rndis);\r\ngoto error;\r\n}\r\nrndis_opts = container_of(fi_rndis, struct f_rndis_opts,\r\nfunc_inst);\r\n#ifndef CONFIG_USB_FUNCTIONFS_ETH\r\nnet = rndis_opts->net;\r\n#endif\r\n}\r\n#endif\r\n#if defined CONFIG_USB_FUNCTIONFS_ETH || defined CONFIG_USB_FUNCTIONFS_RNDIS\r\ngether_set_qmult(net, qmult);\r\nif (!gether_set_host_addr(net, host_addr))\r\npr_info("using host ethernet address: %s", host_addr);\r\nif (!gether_set_dev_addr(net, dev_addr))\r\npr_info("using self ethernet address: %s", dev_addr);\r\n#endif\r\n#if defined CONFIG_USB_FUNCTIONFS_RNDIS && defined CONFIG_USB_FUNCTIONFS_ETH\r\ngether_set_gadget(net, cdev->gadget);\r\nret = gether_register_netdev(net);\r\nif (ret)\r\ngoto error_rndis;\r\nif (can_support_ecm(cdev->gadget)) {\r\nstruct f_ecm_opts *ecm_opts;\r\necm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);\r\necm_opts->bound = true;\r\n} else {\r\nstruct f_gether_opts *geth_opts;\r\ngeth_opts = container_of(fi_geth, struct f_gether_opts,\r\nfunc_inst);\r\ngeth_opts->bound = true;\r\n}\r\nrndis_borrow_net(fi_rndis, net);\r\n#endif\r\nret = usb_string_ids_tab(cdev, gfs_strings);\r\nif (unlikely(ret < 0))\r\ngoto error_rndis;\r\ngfs_dev_desc.iProduct = gfs_strings[USB_GADGET_PRODUCT_IDX].id;\r\nfor (i = 0; i < ARRAY_SIZE(gfs_configurations); ++i) {\r\nstruct gfs_configuration *c = gfs_configurations + i;\r\nint sid = USB_GADGET_FIRST_AVAIL_IDX + i;\r\nc->c.label = gfs_strings[sid].s;\r\nc->c.iConfiguration = gfs_strings[sid].id;\r\nc->c.bConfigurationValue = 1 + i;\r\nc->c.bmAttributes = USB_CONFIG_ATT_SELFPOWER;\r\nc->num = i;\r\nret = usb_add_config(cdev, &c->c, gfs_do_config);\r\nif (unlikely(ret < 0))\r\ngoto error_unbind;\r\n}\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\nreturn 0;\r\nerror_unbind:\r\nerror_rndis:\r\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\r\nusb_put_function_instance(fi_rndis);\r\nerror:\r\n#endif\r\n#if defined CONFIG_USB_FUNCTIONFS_ETH\r\nif (can_support_ecm(cdev->gadget))\r\nusb_put_function_instance(fi_ecm);\r\nelse\r\nusb_put_function_instance(fi_geth);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int gfs_unbind(struct usb_composite_dev *cdev)\r\n{\r\nint i;\r\nENTER();\r\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\r\nusb_put_function(f_rndis);\r\nusb_put_function_instance(fi_rndis);\r\n#endif\r\n#if defined CONFIG_USB_FUNCTIONFS_ETH\r\nif (can_support_ecm(cdev->gadget)) {\r\nusb_put_function(f_ecm);\r\nusb_put_function_instance(fi_ecm);\r\n} else {\r\nusb_put_function(f_geth);\r\nusb_put_function_instance(fi_geth);\r\n}\r\n#endif\r\nfor (i = 0; i < N_CONF * func_num; ++i)\r\nusb_put_function(*(f_ffs[0] + i));\r\nreturn 0;\r\n}\r\nstatic int gfs_do_config(struct usb_configuration *c)\r\n{\r\nstruct gfs_configuration *gc =\r\ncontainer_of(c, struct gfs_configuration, c);\r\nint i;\r\nint ret;\r\nif (missing_funcs)\r\nreturn -ENODEV;\r\nif (gadget_is_otg(c->cdev->gadget)) {\r\nc->descriptors = gfs_otg_desc;\r\nc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nif (gc->eth) {\r\nret = gc->eth(c);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n}\r\nfor (i = 0; i < func_num; i++) {\r\nf_ffs[gc->num][i] = usb_get_function(fi_ffs[i]);\r\nif (IS_ERR(f_ffs[gc->num][i])) {\r\nret = PTR_ERR(f_ffs[gc->num][i]);\r\ngoto error;\r\n}\r\nret = usb_add_function(c, f_ffs[gc->num][i]);\r\nif (ret < 0) {\r\nusb_put_function(f_ffs[gc->num][i]);\r\ngoto error;\r\n}\r\n}\r\nif (c->next_interface_id < ARRAY_SIZE(c->interface))\r\nc->interface[c->next_interface_id] = NULL;\r\nreturn 0;\r\nerror:\r\nwhile (--i >= 0) {\r\nif (!IS_ERR(f_ffs[gc->num][i]))\r\nusb_remove_function(c, f_ffs[gc->num][i]);\r\nusb_put_function(f_ffs[gc->num][i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int eth_bind_config(struct usb_configuration *c)\r\n{\r\nint status = 0;\r\nif (can_support_ecm(c->cdev->gadget)) {\r\nf_ecm = usb_get_function(fi_ecm);\r\nif (IS_ERR(f_ecm))\r\nreturn PTR_ERR(f_ecm);\r\nstatus = usb_add_function(c, f_ecm);\r\nif (status < 0)\r\nusb_put_function(f_ecm);\r\n} else {\r\nf_geth = usb_get_function(fi_geth);\r\nif (IS_ERR(f_geth))\r\nreturn PTR_ERR(f_geth);\r\nstatus = usb_add_function(c, f_geth);\r\nif (status < 0)\r\nusb_put_function(f_geth);\r\n}\r\nreturn status;\r\n}\r\nstatic int bind_rndis_config(struct usb_configuration *c)\r\n{\r\nint status = 0;\r\nf_rndis = usb_get_function(fi_rndis);\r\nif (IS_ERR(f_rndis))\r\nreturn PTR_ERR(f_rndis);\r\nstatus = usb_add_function(c, f_rndis);\r\nif (status < 0)\r\nusb_put_function(f_rndis);\r\nreturn status;\r\n}
