static int\r\nmISDN_open(struct inode *ino, struct file *filep)\r\n{\r\nstruct mISDNtimerdev *dev;\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s(%p,%p)\n", __func__, ino, filep);\r\ndev = kmalloc(sizeof(struct mISDNtimerdev) , GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->next_id = 1;\r\nINIT_LIST_HEAD(&dev->pending);\r\nINIT_LIST_HEAD(&dev->expired);\r\nspin_lock_init(&dev->lock);\r\ndev->work = 0;\r\ninit_waitqueue_head(&dev->wait);\r\nfilep->private_data = dev;\r\nreturn nonseekable_open(ino, filep);\r\n}\r\nstatic int\r\nmISDN_close(struct inode *ino, struct file *filep)\r\n{\r\nstruct mISDNtimerdev *dev = filep->private_data;\r\nstruct list_head *list = &dev->pending;\r\nstruct mISDNtimer *timer, *next;\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s(%p,%p)\n", __func__, ino, filep);\r\nspin_lock_irq(&dev->lock);\r\nwhile (!list_empty(list)) {\r\ntimer = list_first_entry(list, struct mISDNtimer, list);\r\nspin_unlock_irq(&dev->lock);\r\ndel_timer_sync(&timer->tl);\r\nspin_lock_irq(&dev->lock);\r\nlist_del(&timer->list);\r\nkfree(timer);\r\n}\r\nspin_unlock_irq(&dev->lock);\r\nlist_for_each_entry_safe(timer, next, &dev->expired, list) {\r\nkfree(timer);\r\n}\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nmISDN_read(struct file *filep, char __user *buf, size_t count, loff_t *off)\r\n{\r\nstruct mISDNtimerdev *dev = filep->private_data;\r\nstruct list_head *list = &dev->expired;\r\nstruct mISDNtimer *timer;\r\nint ret = 0;\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s(%p, %p, %d, %p)\n", __func__,\r\nfilep, buf, (int)count, off);\r\nif (count < sizeof(int))\r\nreturn -ENOSPC;\r\nspin_lock_irq(&dev->lock);\r\nwhile (list_empty(list) && (dev->work == 0)) {\r\nspin_unlock_irq(&dev->lock);\r\nif (filep->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nwait_event_interruptible(dev->wait, (dev->work ||\r\n!list_empty(list)));\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irq(&dev->lock);\r\n}\r\nif (dev->work)\r\ndev->work = 0;\r\nif (!list_empty(list)) {\r\ntimer = list_first_entry(list, struct mISDNtimer, list);\r\nlist_del(&timer->list);\r\nspin_unlock_irq(&dev->lock);\r\nif (put_user(timer->id, (int __user *)buf))\r\nret = -EFAULT;\r\nelse\r\nret = sizeof(int);\r\nkfree(timer);\r\n} else {\r\nspin_unlock_irq(&dev->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nmISDN_poll(struct file *filep, poll_table *wait)\r\n{\r\nstruct mISDNtimerdev *dev = filep->private_data;\r\nunsigned int mask = POLLERR;\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s(%p, %p)\n", __func__, filep, wait);\r\nif (dev) {\r\npoll_wait(filep, &dev->wait, wait);\r\nmask = 0;\r\nif (dev->work || !list_empty(&dev->expired))\r\nmask |= (POLLIN | POLLRDNORM);\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s work(%d) empty(%d)\n", __func__,\r\ndev->work, list_empty(&dev->expired));\r\n}\r\nreturn mask;\r\n}\r\nstatic void\r\ndev_expire_timer(unsigned long data)\r\n{\r\nstruct mISDNtimer *timer = (void *)data;\r\nu_long flags;\r\nspin_lock_irqsave(&timer->dev->lock, flags);\r\nif (timer->id >= 0)\r\nlist_move_tail(&timer->list, &timer->dev->expired);\r\nspin_unlock_irqrestore(&timer->dev->lock, flags);\r\nwake_up_interruptible(&timer->dev->wait);\r\n}\r\nstatic int\r\nmisdn_add_timer(struct mISDNtimerdev *dev, int timeout)\r\n{\r\nint id;\r\nstruct mISDNtimer *timer;\r\nif (!timeout) {\r\ndev->work = 1;\r\nwake_up_interruptible(&dev->wait);\r\nid = 0;\r\n} else {\r\ntimer = kzalloc(sizeof(struct mISDNtimer), GFP_KERNEL);\r\nif (!timer)\r\nreturn -ENOMEM;\r\ntimer->dev = dev;\r\nsetup_timer(&timer->tl, dev_expire_timer, (long)timer);\r\nspin_lock_irq(&dev->lock);\r\nid = timer->id = dev->next_id++;\r\nif (dev->next_id < 0)\r\ndev->next_id = 1;\r\nlist_add_tail(&timer->list, &dev->pending);\r\ntimer->tl.expires = jiffies + ((HZ * (u_long)timeout) / 1000);\r\nadd_timer(&timer->tl);\r\nspin_unlock_irq(&dev->lock);\r\n}\r\nreturn id;\r\n}\r\nstatic int\r\nmisdn_del_timer(struct mISDNtimerdev *dev, int id)\r\n{\r\nstruct mISDNtimer *timer;\r\nspin_lock_irq(&dev->lock);\r\nlist_for_each_entry(timer, &dev->pending, list) {\r\nif (timer->id == id) {\r\nlist_del_init(&timer->list);\r\ntimer->id = -1;\r\nspin_unlock_irq(&dev->lock);\r\ndel_timer_sync(&timer->tl);\r\nkfree(timer);\r\nreturn id;\r\n}\r\n}\r\nspin_unlock_irq(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic long\r\nmISDN_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct mISDNtimerdev *dev = filep->private_data;\r\nint id, tout, ret = 0;\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s(%p, %x, %lx)\n", __func__,\r\nfilep, cmd, arg);\r\nmutex_lock(&mISDN_mutex);\r\nswitch (cmd) {\r\ncase IMADDTIMER:\r\nif (get_user(tout, (int __user *)arg)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nid = misdn_add_timer(dev, tout);\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s add %d id %d\n", __func__,\r\ntout, id);\r\nif (id < 0) {\r\nret = id;\r\nbreak;\r\n}\r\nif (put_user(id, (int __user *)arg))\r\nret = -EFAULT;\r\nbreak;\r\ncase IMDELTIMER:\r\nif (get_user(id, (int __user *)arg)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (*debug & DEBUG_TIMER)\r\nprintk(KERN_DEBUG "%s del id %d\n", __func__, id);\r\nid = misdn_del_timer(dev, id);\r\nif (put_user(id, (int __user *)arg))\r\nret = -EFAULT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&mISDN_mutex);\r\nreturn ret;\r\n}\r\nint\r\nmISDN_inittimer(u_int *deb)\r\n{\r\nint err;\r\ndebug = deb;\r\nerr = misc_register(&mISDNtimer);\r\nif (err)\r\nprintk(KERN_WARNING "mISDN: Could not register timer device\n");\r\nreturn err;\r\n}\r\nvoid mISDN_timer_cleanup(void)\r\n{\r\nmisc_deregister(&mISDNtimer);\r\n}
