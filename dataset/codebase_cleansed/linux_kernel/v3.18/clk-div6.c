static int cpg_div6_clock_enable(struct clk_hw *hw)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nclk_writel(CPG_DIV6_DIV(clock->div - 1), clock->reg);\r\nreturn 0;\r\n}\r\nstatic void cpg_div6_clock_disable(struct clk_hw *hw)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nclk_writel(CPG_DIV6_CKSTP | CPG_DIV6_DIV(CPG_DIV6_DIV_MASK),\r\nclock->reg);\r\n}\r\nstatic int cpg_div6_clock_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nreturn !(clk_readl(clock->reg) & CPG_DIV6_CKSTP);\r\n}\r\nstatic unsigned long cpg_div6_clock_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nunsigned int div = (clk_readl(clock->reg) & CPG_DIV6_DIV_MASK) + 1;\r\nreturn parent_rate / div;\r\n}\r\nstatic unsigned int cpg_div6_clock_calc_div(unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nunsigned int div;\r\ndiv = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nreturn clamp_t(unsigned int, div, 1, 64);\r\n}\r\nstatic long cpg_div6_clock_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned int div = cpg_div6_clock_calc_div(rate, *parent_rate);\r\nreturn *parent_rate / div;\r\n}\r\nstatic int cpg_div6_clock_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct div6_clock *clock = to_div6_clock(hw);\r\nunsigned int div = cpg_div6_clock_calc_div(rate, parent_rate);\r\nclock->div = div;\r\nif (!(clk_readl(clock->reg) & CPG_DIV6_CKSTP))\r\nclk_writel(CPG_DIV6_DIV(clock->div - 1), clock->reg);\r\nreturn 0;\r\n}\r\nstatic void __init cpg_div6_clock_init(struct device_node *np)\r\n{\r\nstruct clk_init_data init;\r\nstruct div6_clock *clock;\r\nconst char *parent_name;\r\nconst char *name;\r\nstruct clk *clk;\r\nint ret;\r\nclock = kzalloc(sizeof(*clock), GFP_KERNEL);\r\nif (!clock) {\r\npr_err("%s: failed to allocate %s DIV6 clock\n",\r\n__func__, np->name);\r\nreturn;\r\n}\r\nclock->reg = of_iomap(np, 0);\r\nif (clock->reg == NULL) {\r\npr_err("%s: failed to map %s DIV6 clock register\n",\r\n__func__, np->name);\r\ngoto error;\r\n}\r\nclock->div = (clk_readl(clock->reg) & CPG_DIV6_DIV_MASK) + 1;\r\nret = of_property_read_string(np, "clock-output-names", &name);\r\nif (ret < 0) {\r\npr_err("%s: failed to get %s DIV6 clock output name\n",\r\n__func__, np->name);\r\ngoto error;\r\n}\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (parent_name == NULL) {\r\npr_err("%s: failed to get %s DIV6 clock parent name\n",\r\n__func__, np->name);\r\ngoto error;\r\n}\r\ninit.name = name;\r\ninit.ops = &cpg_div6_clock_ops;\r\ninit.flags = CLK_IS_BASIC;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclock->hw.init = &init;\r\nclk = clk_register(NULL, &clock->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: failed to register %s DIV6 clock (%ld)\n",\r\n__func__, np->name, PTR_ERR(clk));\r\ngoto error;\r\n}\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nreturn;\r\nerror:\r\nif (clock->reg)\r\niounmap(clock->reg);\r\nkfree(clock);\r\n}
