static int w1_master_match(struct device *dev, struct device_driver *drv)\r\n{\r\nreturn 1;\r\n}\r\nstatic int w1_master_probe(struct device *dev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic void w1_master_release(struct device *dev)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\ndev_dbg(dev, "%s: Releasing %s.\n", __func__, md->name);\r\nmemset(md, 0, sizeof(struct w1_master) + sizeof(struct w1_bus_master));\r\nkfree(md);\r\n}\r\nstatic void w1_slave_release(struct device *dev)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(dev);\r\ndev_dbg(dev, "%s: Releasing %s [%p]\n", __func__, sl->name, sl);\r\nw1_family_put(sl->family);\r\nsl->master->slave_count--;\r\n}\r\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(dev);\r\nreturn sprintf(buf, "%s\n", sl->name);\r\n}\r\nstatic ssize_t id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(dev);\r\nssize_t count = sizeof(sl->reg_num);\r\nmemcpy(buf, (u8 *)&sl->reg_num, count);\r\nreturn count;\r\n}\r\nstatic ssize_t rw_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nmutex_lock(&sl->master->mutex);\r\nif (w1_reset_select_slave(sl)) {\r\ncount = 0;\r\ngoto out_up;\r\n}\r\nw1_write_block(sl->master, buf, count);\r\nout_up:\r\nmutex_unlock(&sl->master->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t rw_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nmutex_lock(&sl->master->mutex);\r\nw1_read_block(sl->master, buf, count);\r\nmutex_unlock(&sl->master->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_name(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nssize_t count;\r\nmutex_lock(&md->mutex);\r\ncount = sprintf(buf, "%s\n", md->name);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_store_search(struct device * dev,\r\nstruct device_attribute *attr,\r\nconst char * buf, size_t count)\r\n{\r\nlong tmp;\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nint ret;\r\nret = kstrtol(buf, 0, &tmp);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&md->mutex);\r\nmd->search_count = tmp;\r\nmutex_unlock(&md->mutex);\r\nif (tmp)\r\nwake_up_process(md->thread);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_search(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nssize_t count;\r\nmutex_lock(&md->mutex);\r\ncount = sprintf(buf, "%d\n", md->search_count);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_store_pullup(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nlong tmp;\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nint ret;\r\nret = kstrtol(buf, 0, &tmp);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&md->mutex);\r\nmd->enable_pullup = tmp;\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_pullup(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nssize_t count;\r\nmutex_lock(&md->mutex);\r\ncount = sprintf(buf, "%d\n", md->enable_pullup);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_pointer(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nssize_t count;\r\nmutex_lock(&md->mutex);\r\ncount = sprintf(buf, "0x%p\n", md->bus_master);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_timeout(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nssize_t count;\r\ncount = sprintf(buf, "%d\n", w1_timeout);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_store_max_slave_count(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint tmp;\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nif (kstrtoint(buf, 0, &tmp) == -EINVAL || tmp < 1)\r\nreturn -EINVAL;\r\nmutex_lock(&md->mutex);\r\nmd->max_slave_count = tmp;\r\nclear_bit(W1_WARN_MAX_COUNT, &md->flags);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_max_slave_count(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nssize_t count;\r\nmutex_lock(&md->mutex);\r\ncount = sprintf(buf, "%d\n", md->max_slave_count);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_attempts(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nssize_t count;\r\nmutex_lock(&md->mutex);\r\ncount = sprintf(buf, "%lu\n", md->attempts);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_slave_count(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nssize_t count;\r\nmutex_lock(&md->mutex);\r\ncount = sprintf(buf, "%d\n", md->slave_count);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t w1_master_attribute_show_slaves(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nint c = PAGE_SIZE;\r\nstruct list_head *ent, *n;\r\nstruct w1_slave *sl = NULL;\r\nmutex_lock(&md->list_mutex);\r\nlist_for_each_safe(ent, n, &md->slist) {\r\nsl = list_entry(ent, struct w1_slave, w1_slave_entry);\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "%s\n", sl->name);\r\n}\r\nif (!sl)\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "not found.\n");\r\nmutex_unlock(&md->list_mutex);\r\nreturn PAGE_SIZE - c;\r\n}\r\nstatic ssize_t w1_master_attribute_show_add(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint c = PAGE_SIZE;\r\nc -= snprintf(buf+PAGE_SIZE - c, c,\r\n"write device id xx-xxxxxxxxxxxx to add slave\n");\r\nreturn PAGE_SIZE - c;\r\n}\r\nstatic int w1_atoreg_num(struct device *dev, const char *buf, size_t count,\r\nstruct w1_reg_num *rn)\r\n{\r\nunsigned int family;\r\nunsigned long long id;\r\nint i;\r\nu64 rn64_le;\r\nconst char *error_msg = "bad slave string format, expecting "\r\n"ff-dddddddddddd\n";\r\nif (buf[2] != '-') {\r\ndev_err(dev, "%s", error_msg);\r\nreturn -EINVAL;\r\n}\r\ni = sscanf(buf, "%02x-%012llx", &family, &id);\r\nif (i != 2) {\r\ndev_err(dev, "%s", error_msg);\r\nreturn -EINVAL;\r\n}\r\nrn->family = family;\r\nrn->id = id;\r\nrn64_le = cpu_to_le64(*(u64 *)rn);\r\nrn->crc = w1_calc_crc8((u8 *)&rn64_le, 7);\r\n#if 0\r\ndev_info(dev, "With CRC device is %02x.%012llx.%02x.\n",\r\nrn->family, (unsigned long long)rn->id, rn->crc);\r\n#endif\r\nreturn 0;\r\n}\r\nstruct w1_slave *w1_slave_search_device(struct w1_master *dev,\r\nstruct w1_reg_num *rn)\r\n{\r\nstruct w1_slave *sl;\r\nmutex_lock(&dev->list_mutex);\r\nlist_for_each_entry(sl, &dev->slist, w1_slave_entry) {\r\nif (sl->reg_num.family == rn->family &&\r\nsl->reg_num.id == rn->id &&\r\nsl->reg_num.crc == rn->crc) {\r\nmutex_unlock(&dev->list_mutex);\r\nreturn sl;\r\n}\r\n}\r\nmutex_unlock(&dev->list_mutex);\r\nreturn NULL;\r\n}\r\nstatic ssize_t w1_master_attribute_store_add(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nstruct w1_reg_num rn;\r\nstruct w1_slave *sl;\r\nssize_t result = count;\r\nif (w1_atoreg_num(dev, buf, count, &rn))\r\nreturn -EINVAL;\r\nmutex_lock(&md->mutex);\r\nsl = w1_slave_search_device(md, &rn);\r\nif (sl) {\r\ndev_info(dev, "Device %s already exists\n", sl->name);\r\nresult = -EINVAL;\r\n} else {\r\nw1_attach_slave_device(md, &rn);\r\n}\r\nmutex_unlock(&md->mutex);\r\nreturn result;\r\n}\r\nstatic ssize_t w1_master_attribute_show_remove(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint c = PAGE_SIZE;\r\nc -= snprintf(buf+PAGE_SIZE - c, c,\r\n"write device id xx-xxxxxxxxxxxx to remove slave\n");\r\nreturn PAGE_SIZE - c;\r\n}\r\nstatic ssize_t w1_master_attribute_store_remove(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w1_master *md = dev_to_w1_master(dev);\r\nstruct w1_reg_num rn;\r\nstruct w1_slave *sl;\r\nssize_t result = count;\r\nif (w1_atoreg_num(dev, buf, count, &rn))\r\nreturn -EINVAL;\r\nmutex_lock(&md->mutex);\r\nsl = w1_slave_search_device(md, &rn);\r\nif (sl) {\r\nresult = w1_slave_detach(sl);\r\nif (result == 0)\r\nresult = count;\r\n} else {\r\ndev_info(dev, "Device %02x-%012llx doesn't exists\n", rn.family,\r\n(unsigned long long)rn.id);\r\nresult = -EINVAL;\r\n}\r\nmutex_unlock(&md->mutex);\r\nreturn result;\r\n}\r\nint w1_create_master_attributes(struct w1_master *master)\r\n{\r\nreturn sysfs_create_group(&master->dev.kobj, &w1_master_defattr_group);\r\n}\r\nvoid w1_destroy_master_attributes(struct w1_master *master)\r\n{\r\nsysfs_remove_group(&master->dev.kobj, &w1_master_defattr_group);\r\n}\r\nstatic int w1_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct w1_master *md = NULL;\r\nstruct w1_slave *sl = NULL;\r\nchar *event_owner, *name;\r\nint err = 0;\r\nif (dev->driver == &w1_master_driver) {\r\nmd = container_of(dev, struct w1_master, dev);\r\nevent_owner = "master";\r\nname = md->name;\r\n} else if (dev->driver == &w1_slave_driver) {\r\nsl = container_of(dev, struct w1_slave, dev);\r\nevent_owner = "slave";\r\nname = sl->name;\r\n} else {\r\ndev_dbg(dev, "Unknown event.\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "Hotplug event for %s %s, bus_id=%s.\n",\r\nevent_owner, name, dev_name(dev));\r\nif (dev->driver != &w1_slave_driver || !sl)\r\ngoto end;\r\nerr = add_uevent_var(env, "W1_FID=%02X", sl->reg_num.family);\r\nif (err)\r\ngoto end;\r\nerr = add_uevent_var(env, "W1_SLAVE_ID=%024LX",\r\n(unsigned long long)sl->reg_num.id);\r\nend:\r\nreturn err;\r\n}\r\nstatic int w1_family_notify(unsigned long action, struct w1_slave *sl)\r\n{\r\nstruct w1_family_ops *fops;\r\nint err;\r\nfops = sl->family->fops;\r\nif (!fops)\r\nreturn 0;\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nif (fops->add_slave) {\r\nerr = fops->add_slave(sl);\r\nif (err < 0) {\r\ndev_err(&sl->dev,\r\n"add_slave() call failed. err=%d\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\nif (fops->groups) {\r\nerr = sysfs_create_groups(&sl->dev.kobj, fops->groups);\r\nif (err) {\r\ndev_err(&sl->dev,\r\n"sysfs group creation failed. err=%d\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nif (fops->remove_slave)\r\nsl->family->fops->remove_slave(sl);\r\nif (fops->groups)\r\nsysfs_remove_groups(&sl->dev.kobj, fops->groups);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __w1_attach_slave_device(struct w1_slave *sl)\r\n{\r\nint err;\r\nsl->dev.parent = &sl->master->dev;\r\nsl->dev.driver = &w1_slave_driver;\r\nsl->dev.bus = &w1_bus_type;\r\nsl->dev.release = &w1_slave_release;\r\nsl->dev.groups = w1_slave_groups;\r\ndev_set_name(&sl->dev, "%02x-%012llx",\r\n(unsigned int) sl->reg_num.family,\r\n(unsigned long long) sl->reg_num.id);\r\nsnprintf(&sl->name[0], sizeof(sl->name),\r\n"%02x-%012llx",\r\n(unsigned int) sl->reg_num.family,\r\n(unsigned long long) sl->reg_num.id);\r\ndev_dbg(&sl->dev, "%s: registering %s as %p.\n", __func__,\r\ndev_name(&sl->dev), sl);\r\ndev_set_uevent_suppress(&sl->dev, true);\r\nerr = device_register(&sl->dev);\r\nif (err < 0) {\r\ndev_err(&sl->dev,\r\n"Device registration [%s] failed. err=%d\n",\r\ndev_name(&sl->dev), err);\r\nreturn err;\r\n}\r\nw1_family_notify(BUS_NOTIFY_ADD_DEVICE, sl);\r\ndev_set_uevent_suppress(&sl->dev, false);\r\nkobject_uevent(&sl->dev.kobj, KOBJ_ADD);\r\nmutex_lock(&sl->master->list_mutex);\r\nlist_add_tail(&sl->w1_slave_entry, &sl->master->slist);\r\nmutex_unlock(&sl->master->list_mutex);\r\nreturn 0;\r\n}\r\nint w1_attach_slave_device(struct w1_master *dev, struct w1_reg_num *rn)\r\n{\r\nstruct w1_slave *sl;\r\nstruct w1_family *f;\r\nint err;\r\nstruct w1_netlink_msg msg;\r\nsl = kzalloc(sizeof(struct w1_slave), GFP_KERNEL);\r\nif (!sl) {\r\ndev_err(&dev->dev,\r\n"%s: failed to allocate new slave device.\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nsl->owner = THIS_MODULE;\r\nsl->master = dev;\r\nset_bit(W1_SLAVE_ACTIVE, &sl->flags);\r\nmemset(&msg, 0, sizeof(msg));\r\nmemcpy(&sl->reg_num, rn, sizeof(sl->reg_num));\r\natomic_set(&sl->refcnt, 1);\r\natomic_inc(&sl->master->refcnt);\r\nmutex_unlock(&dev->mutex);\r\nrequest_module("w1-family-0x%0x", rn->family);\r\nmutex_lock(&dev->mutex);\r\nspin_lock(&w1_flock);\r\nf = w1_family_registered(rn->family);\r\nif (!f) {\r\nf= &w1_default_family;\r\ndev_info(&dev->dev, "Family %x for %02x.%012llx.%02x is not registered.\n",\r\nrn->family, rn->family,\r\n(unsigned long long)rn->id, rn->crc);\r\n}\r\n__w1_family_get(f);\r\nspin_unlock(&w1_flock);\r\nsl->family = f;\r\nerr = __w1_attach_slave_device(sl);\r\nif (err < 0) {\r\ndev_err(&dev->dev, "%s: Attaching %s failed.\n", __func__,\r\nsl->name);\r\nw1_family_put(sl->family);\r\nkfree(sl);\r\nreturn err;\r\n}\r\nsl->ttl = dev->slave_ttl;\r\ndev->slave_count++;\r\nmemcpy(msg.id.id, rn, sizeof(msg.id));\r\nmsg.type = W1_SLAVE_ADD;\r\nw1_netlink_send(dev, &msg);\r\nreturn 0;\r\n}\r\nint w1_unref_slave(struct w1_slave *sl)\r\n{\r\nstruct w1_master *dev = sl->master;\r\nint refcnt;\r\nmutex_lock(&dev->list_mutex);\r\nrefcnt = atomic_sub_return(1, &sl->refcnt);\r\nif (refcnt == 0) {\r\nstruct w1_netlink_msg msg;\r\ndev_dbg(&sl->dev, "%s: detaching %s [%p].\n", __func__,\r\nsl->name, sl);\r\nlist_del(&sl->w1_slave_entry);\r\nmemset(&msg, 0, sizeof(msg));\r\nmemcpy(msg.id.id, &sl->reg_num, sizeof(msg.id));\r\nmsg.type = W1_SLAVE_REMOVE;\r\nw1_netlink_send(sl->master, &msg);\r\nw1_family_notify(BUS_NOTIFY_DEL_DEVICE, sl);\r\ndevice_unregister(&sl->dev);\r\n#ifdef DEBUG\r\nmemset(sl, 0, sizeof(*sl));\r\n#endif\r\nkfree(sl);\r\n}\r\natomic_dec(&dev->refcnt);\r\nmutex_unlock(&dev->list_mutex);\r\nreturn refcnt;\r\n}\r\nint w1_slave_detach(struct w1_slave *sl)\r\n{\r\nint destroy_now;\r\nmutex_lock(&sl->master->list_mutex);\r\ndestroy_now = !test_bit(W1_SLAVE_DETACH, &sl->flags);\r\nset_bit(W1_SLAVE_DETACH, &sl->flags);\r\nmutex_unlock(&sl->master->list_mutex);\r\nif (destroy_now)\r\ndestroy_now = !w1_unref_slave(sl);\r\nreturn destroy_now ? 0 : -EBUSY;\r\n}\r\nstruct w1_master *w1_search_master_id(u32 id)\r\n{\r\nstruct w1_master *dev;\r\nint found = 0;\r\nmutex_lock(&w1_mlock);\r\nlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\r\nif (dev->id == id) {\r\nfound = 1;\r\natomic_inc(&dev->refcnt);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&w1_mlock);\r\nreturn (found)?dev:NULL;\r\n}\r\nstruct w1_slave *w1_search_slave(struct w1_reg_num *id)\r\n{\r\nstruct w1_master *dev;\r\nstruct w1_slave *sl = NULL;\r\nint found = 0;\r\nmutex_lock(&w1_mlock);\r\nlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\r\nmutex_lock(&dev->list_mutex);\r\nlist_for_each_entry(sl, &dev->slist, w1_slave_entry) {\r\nif (sl->reg_num.family == id->family &&\r\nsl->reg_num.id == id->id &&\r\nsl->reg_num.crc == id->crc) {\r\nfound = 1;\r\natomic_inc(&dev->refcnt);\r\natomic_inc(&sl->refcnt);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&dev->list_mutex);\r\nif (found)\r\nbreak;\r\n}\r\nmutex_unlock(&w1_mlock);\r\nreturn (found)?sl:NULL;\r\n}\r\nvoid w1_reconnect_slaves(struct w1_family *f, int attach)\r\n{\r\nstruct w1_slave *sl, *sln;\r\nstruct w1_master *dev;\r\nmutex_lock(&w1_mlock);\r\nlist_for_each_entry(dev, &w1_masters, w1_master_entry) {\r\ndev_dbg(&dev->dev, "Reconnecting slaves in device %s "\r\n"for family %02x.\n", dev->name, f->fid);\r\nmutex_lock(&dev->mutex);\r\nmutex_lock(&dev->list_mutex);\r\nlist_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry) {\r\nif ((attach && sl->family->fid == W1_FAMILY_DEFAULT\r\n&& sl->reg_num.family == f->fid) ||\r\n(!attach && sl->family->fid == f->fid)) {\r\nstruct w1_reg_num rn;\r\nmutex_unlock(&dev->list_mutex);\r\nmemcpy(&rn, &sl->reg_num, sizeof(rn));\r\nif (!w1_slave_detach(sl))\r\nw1_attach_slave_device(dev, &rn);\r\nmutex_lock(&dev->list_mutex);\r\n}\r\n}\r\ndev_dbg(&dev->dev, "Reconnecting slaves in device %s "\r\n"has been finished.\n", dev->name);\r\nmutex_unlock(&dev->list_mutex);\r\nmutex_unlock(&dev->mutex);\r\n}\r\nmutex_unlock(&w1_mlock);\r\n}\r\nvoid w1_slave_found(struct w1_master *dev, u64 rn)\r\n{\r\nstruct w1_slave *sl;\r\nstruct w1_reg_num *tmp;\r\nu64 rn_le = cpu_to_le64(rn);\r\natomic_inc(&dev->refcnt);\r\ntmp = (struct w1_reg_num *) &rn;\r\nsl = w1_slave_search_device(dev, tmp);\r\nif (sl) {\r\nset_bit(W1_SLAVE_ACTIVE, &sl->flags);\r\n} else {\r\nif (rn && tmp->crc == w1_calc_crc8((u8 *)&rn_le, 7))\r\nw1_attach_slave_device(dev, tmp);\r\n}\r\natomic_dec(&dev->refcnt);\r\n}\r\nvoid w1_search(struct w1_master *dev, u8 search_type, w1_slave_found_callback cb)\r\n{\r\nu64 last_rn, rn, tmp64;\r\nint i, slave_count = 0;\r\nint last_zero, last_device;\r\nint search_bit, desc_bit;\r\nu8 triplet_ret = 0;\r\nsearch_bit = 0;\r\nrn = dev->search_id;\r\nlast_rn = 0;\r\nlast_device = 0;\r\nlast_zero = -1;\r\ndesc_bit = 64;\r\nwhile ( !last_device && (slave_count++ < dev->max_slave_count) ) {\r\nlast_rn = rn;\r\nrn = 0;\r\nmutex_lock(&dev->bus_mutex);\r\nif (w1_reset_bus(dev)) {\r\nmutex_unlock(&dev->bus_mutex);\r\ndev_dbg(&dev->dev, "No devices present on the wire.\n");\r\nbreak;\r\n}\r\nif (dev->max_slave_count == 1) {\r\nint rv;\r\nw1_write_8(dev, W1_READ_ROM);\r\nrv = w1_read_block(dev, (u8 *)&rn, 8);\r\nmutex_unlock(&dev->bus_mutex);\r\nif (rv == 8 && rn)\r\ncb(dev, rn);\r\nbreak;\r\n}\r\nw1_write_8(dev, search_type);\r\nfor (i = 0; i < 64; ++i) {\r\nif (i == desc_bit)\r\nsearch_bit = 1;\r\nelse if (i > desc_bit)\r\nsearch_bit = 0;\r\nelse\r\nsearch_bit = ((last_rn >> i) & 0x1);\r\ntriplet_ret = w1_triplet(dev, search_bit);\r\nif ( (triplet_ret & 0x03) == 0x03 )\r\nbreak;\r\nif (triplet_ret == 0)\r\nlast_zero = i;\r\ntmp64 = (triplet_ret >> 2);\r\nrn |= (tmp64 << i);\r\nif (test_bit(W1_ABORT_SEARCH, &dev->flags)) {\r\nmutex_unlock(&dev->bus_mutex);\r\ndev_dbg(&dev->dev, "Abort w1_search\n");\r\nreturn;\r\n}\r\n}\r\nmutex_unlock(&dev->bus_mutex);\r\nif ( (triplet_ret & 0x03) != 0x03 ) {\r\nif ((desc_bit == last_zero) || (last_zero < 0)) {\r\nlast_device = 1;\r\ndev->search_id = 0;\r\n} else {\r\ndev->search_id = rn;\r\n}\r\ndesc_bit = last_zero;\r\ncb(dev, rn);\r\n}\r\nif (!last_device && slave_count == dev->max_slave_count &&\r\n!test_bit(W1_WARN_MAX_COUNT, &dev->flags)) {\r\ndev_info(&dev->dev, "%s: max_slave_count %d reached, "\r\n"will continue next search.\n", __func__,\r\ndev->max_slave_count);\r\nset_bit(W1_WARN_MAX_COUNT, &dev->flags);\r\n}\r\n}\r\n}\r\nvoid w1_search_process_cb(struct w1_master *dev, u8 search_type,\r\nw1_slave_found_callback cb)\r\n{\r\nstruct w1_slave *sl, *sln;\r\nmutex_lock(&dev->list_mutex);\r\nlist_for_each_entry(sl, &dev->slist, w1_slave_entry)\r\nclear_bit(W1_SLAVE_ACTIVE, &sl->flags);\r\nmutex_unlock(&dev->list_mutex);\r\nw1_search_devices(dev, search_type, cb);\r\nmutex_lock(&dev->list_mutex);\r\nlist_for_each_entry_safe(sl, sln, &dev->slist, w1_slave_entry) {\r\nif (!test_bit(W1_SLAVE_ACTIVE, &sl->flags) && !--sl->ttl) {\r\nmutex_unlock(&dev->list_mutex);\r\nw1_slave_detach(sl);\r\nmutex_lock(&dev->list_mutex);\r\n}\r\nelse if (test_bit(W1_SLAVE_ACTIVE, &sl->flags))\r\nsl->ttl = dev->slave_ttl;\r\n}\r\nmutex_unlock(&dev->list_mutex);\r\nif (dev->search_count > 0)\r\ndev->search_count--;\r\n}\r\nstatic void w1_search_process(struct w1_master *dev, u8 search_type)\r\n{\r\nw1_search_process_cb(dev, search_type, w1_slave_found);\r\n}\r\nint w1_process_callbacks(struct w1_master *dev)\r\n{\r\nint ret = 0;\r\nstruct w1_async_cmd *async_cmd, *async_n;\r\nwhile (!list_empty(&dev->async_list)) {\r\nlist_for_each_entry_safe(async_cmd, async_n, &dev->async_list,\r\nasync_entry) {\r\nmutex_unlock(&dev->list_mutex);\r\nasync_cmd->cb(dev, async_cmd);\r\nret = 1;\r\nmutex_lock(&dev->list_mutex);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint w1_process(void *data)\r\n{\r\nstruct w1_master *dev = (struct w1_master *) data;\r\nconst unsigned long jtime = msecs_to_jiffies(w1_timeout * 1000);\r\nunsigned long jremain = 0;\r\nfor (;;) {\r\nif (!jremain && dev->search_count) {\r\nmutex_lock(&dev->mutex);\r\nw1_search_process(dev, W1_SEARCH);\r\nmutex_unlock(&dev->mutex);\r\n}\r\nmutex_lock(&dev->list_mutex);\r\nif (!w1_process_callbacks(dev) && jremain) {\r\njremain = 1;\r\n}\r\ntry_to_freeze();\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nmutex_unlock(&dev->list_mutex);\r\nif (kthread_should_stop())\r\nbreak;\r\nif (dev->search_count) {\r\nif (!jremain)\r\njremain = jtime;\r\njremain = schedule_timeout(jremain);\r\n}\r\nelse\r\nschedule();\r\n}\r\natomic_dec(&dev->refcnt);\r\nreturn 0;\r\n}\r\nstatic int __init w1_init(void)\r\n{\r\nint retval;\r\npr_info("Driver for 1-wire Dallas network protocol.\n");\r\nw1_init_netlink();\r\nretval = bus_register(&w1_bus_type);\r\nif (retval) {\r\npr_err("Failed to register bus. err=%d.\n", retval);\r\ngoto err_out_exit_init;\r\n}\r\nretval = driver_register(&w1_master_driver);\r\nif (retval) {\r\npr_err("Failed to register master driver. err=%d.\n",\r\nretval);\r\ngoto err_out_bus_unregister;\r\n}\r\nretval = driver_register(&w1_slave_driver);\r\nif (retval) {\r\npr_err("Failed to register slave driver. err=%d.\n",\r\nretval);\r\ngoto err_out_master_unregister;\r\n}\r\nreturn 0;\r\n#if 0\r\nerr_out_slave_unregister:\r\ndriver_unregister(&w1_slave_driver);\r\n#endif\r\nerr_out_master_unregister:\r\ndriver_unregister(&w1_master_driver);\r\nerr_out_bus_unregister:\r\nbus_unregister(&w1_bus_type);\r\nerr_out_exit_init:\r\nreturn retval;\r\n}\r\nstatic void __exit w1_fini(void)\r\n{\r\nstruct w1_master *dev;\r\nlist_for_each_entry(dev, &w1_masters, w1_master_entry)\r\n__w1_remove_master_device(dev);\r\nw1_fini_netlink();\r\ndriver_unregister(&w1_slave_driver);\r\ndriver_unregister(&w1_master_driver);\r\nbus_unregister(&w1_bus_type);\r\n}
