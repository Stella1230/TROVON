static bool snd_soc_set_cache_val(void *base, unsigned int idx,\r\nunsigned int val, unsigned int word_size)\r\n{\r\nswitch (word_size) {\r\ncase 1: {\r\nu8 *cache = base;\r\nif (cache[idx] == val)\r\nreturn true;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ncase 2: {\r\nu16 *cache = base;\r\nif (cache[idx] == val)\r\nreturn true;\r\ncache[idx] = val;\r\nbreak;\r\n}\r\ndefault:\r\nWARN(1, "Invalid word_size %d\n", word_size);\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic unsigned int snd_soc_get_cache_val(const void *base, unsigned int idx,\r\nunsigned int word_size)\r\n{\r\nif (!base)\r\nreturn -1;\r\nswitch (word_size) {\r\ncase 1: {\r\nconst u8 *cache = base;\r\nreturn cache[idx];\r\n}\r\ncase 2: {\r\nconst u16 *cache = base;\r\nreturn cache[idx];\r\n}\r\ndefault:\r\nWARN(1, "Invalid word_size %d\n", word_size);\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nint snd_soc_cache_init(struct snd_soc_codec *codec)\r\n{\r\nconst struct snd_soc_codec_driver *codec_drv = codec->driver;\r\nsize_t reg_size;\r\nreg_size = codec_drv->reg_cache_size * codec_drv->reg_word_size;\r\nif (!reg_size)\r\nreturn 0;\r\nmutex_init(&codec->cache_rw_mutex);\r\ndev_dbg(codec->dev, "ASoC: Initializing cache for %s codec\n",\r\ncodec->component.name);\r\nif (codec_drv->reg_cache_default)\r\ncodec->reg_cache = kmemdup(codec_drv->reg_cache_default,\r\nreg_size, GFP_KERNEL);\r\nelse\r\ncodec->reg_cache = kzalloc(reg_size, GFP_KERNEL);\r\nif (!codec->reg_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint snd_soc_cache_exit(struct snd_soc_codec *codec)\r\n{\r\ndev_dbg(codec->dev, "ASoC: Destroying cache for %s codec\n",\r\ncodec->component.name);\r\nkfree(codec->reg_cache);\r\ncodec->reg_cache = NULL;\r\nreturn 0;\r\n}\r\nint snd_soc_cache_read(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int *value)\r\n{\r\nif (!value)\r\nreturn -EINVAL;\r\nmutex_lock(&codec->cache_rw_mutex);\r\nif (!ZERO_OR_NULL_PTR(codec->reg_cache))\r\n*value = snd_soc_get_cache_val(codec->reg_cache, reg,\r\ncodec->driver->reg_word_size);\r\nmutex_unlock(&codec->cache_rw_mutex);\r\nreturn 0;\r\n}\r\nint snd_soc_cache_write(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int value)\r\n{\r\nmutex_lock(&codec->cache_rw_mutex);\r\nif (!ZERO_OR_NULL_PTR(codec->reg_cache))\r\nsnd_soc_set_cache_val(codec->reg_cache, reg, value,\r\ncodec->driver->reg_word_size);\r\nmutex_unlock(&codec->cache_rw_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_soc_flat_cache_sync(struct snd_soc_codec *codec)\r\n{\r\nint i;\r\nint ret;\r\nconst struct snd_soc_codec_driver *codec_drv;\r\nunsigned int val;\r\ncodec_drv = codec->driver;\r\nfor (i = 0; i < codec_drv->reg_cache_size; ++i) {\r\nret = snd_soc_cache_read(codec, i, &val);\r\nif (ret)\r\nreturn ret;\r\nif (codec_drv->reg_cache_default)\r\nif (snd_soc_get_cache_val(codec_drv->reg_cache_default,\r\ni, codec_drv->reg_word_size) == val)\r\ncontinue;\r\nret = snd_soc_write(codec, i, val);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(codec->dev, "ASoC: Synced register %#x, value = %#x\n",\r\ni, val);\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_cache_sync(struct snd_soc_codec *codec)\r\n{\r\nconst char *name = "flat";\r\nint ret;\r\nif (!codec->cache_sync)\r\nreturn 0;\r\ndev_dbg(codec->dev, "ASoC: Syncing cache for %s codec\n",\r\ncodec->component.name);\r\ntrace_snd_soc_cache_sync(codec, name, "start");\r\nret = snd_soc_flat_cache_sync(codec);\r\nif (!ret)\r\ncodec->cache_sync = 0;\r\ntrace_snd_soc_cache_sync(codec, name, "end");\r\nreturn ret;\r\n}
