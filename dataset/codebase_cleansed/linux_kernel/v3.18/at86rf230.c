static inline int\r\n__at86rf230_write(struct at86rf230_local *lp,\r\nunsigned int addr, unsigned int data)\r\n{\r\nreturn regmap_write(lp->regmap, addr, data);\r\n}\r\nstatic inline int\r\n__at86rf230_read(struct at86rf230_local *lp,\r\nunsigned int addr, unsigned int *data)\r\n{\r\nreturn regmap_read(lp->regmap, addr, data);\r\n}\r\nstatic inline int\r\nat86rf230_read_subreg(struct at86rf230_local *lp,\r\nunsigned int addr, unsigned int mask,\r\nunsigned int shift, unsigned int *data)\r\n{\r\nint rc;\r\nrc = __at86rf230_read(lp, addr, data);\r\nif (rc > 0)\r\n*data = (*data & mask) >> shift;\r\nreturn rc;\r\n}\r\nstatic inline int\r\nat86rf230_write_subreg(struct at86rf230_local *lp,\r\nunsigned int addr, unsigned int mask,\r\nunsigned int shift, unsigned int data)\r\n{\r\nreturn regmap_update_bits(lp->regmap, addr, mask, data << shift);\r\n}\r\nstatic bool\r\nat86rf230_reg_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RG_TRX_STATE:\r\ncase RG_TRX_CTRL_0:\r\ncase RG_TRX_CTRL_1:\r\ncase RG_PHY_TX_PWR:\r\ncase RG_PHY_ED_LEVEL:\r\ncase RG_PHY_CC_CCA:\r\ncase RG_CCA_THRES:\r\ncase RG_RX_CTRL:\r\ncase RG_SFD_VALUE:\r\ncase RG_TRX_CTRL_2:\r\ncase RG_ANT_DIV:\r\ncase RG_IRQ_MASK:\r\ncase RG_VREG_CTRL:\r\ncase RG_BATMON:\r\ncase RG_XOSC_CTRL:\r\ncase RG_RX_SYN:\r\ncase RG_XAH_CTRL_1:\r\ncase RG_FTN_CTRL:\r\ncase RG_PLL_CF:\r\ncase RG_PLL_DCU:\r\ncase RG_SHORT_ADDR_0:\r\ncase RG_SHORT_ADDR_1:\r\ncase RG_PAN_ID_0:\r\ncase RG_PAN_ID_1:\r\ncase RG_IEEE_ADDR_0:\r\ncase RG_IEEE_ADDR_1:\r\ncase RG_IEEE_ADDR_2:\r\ncase RG_IEEE_ADDR_3:\r\ncase RG_IEEE_ADDR_4:\r\ncase RG_IEEE_ADDR_5:\r\ncase RG_IEEE_ADDR_6:\r\ncase RG_IEEE_ADDR_7:\r\ncase RG_XAH_CTRL_0:\r\ncase RG_CSMA_SEED_0:\r\ncase RG_CSMA_SEED_1:\r\ncase RG_CSMA_BE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nat86rf230_reg_readable(struct device *dev, unsigned int reg)\r\n{\r\nbool rc;\r\nrc = at86rf230_reg_writeable(dev, reg);\r\nif (rc)\r\nreturn rc;\r\nswitch (reg) {\r\ncase RG_TRX_STATUS:\r\ncase RG_PHY_RSSI:\r\ncase RG_IRQ_STATUS:\r\ncase RG_PART_NUM:\r\ncase RG_VERSION_NUM:\r\ncase RG_MAN_ID_1:\r\ncase RG_MAN_ID_0:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nat86rf230_reg_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RG_TRX_STATUS:\r\ncase RG_TRX_STATE:\r\ncase RG_PHY_RSSI:\r\ncase RG_PHY_ED_LEVEL:\r\ncase RG_IRQ_STATUS:\r\ncase RG_VREG_CTRL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool\r\nat86rf230_reg_precious(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RG_IRQ_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void\r\nat86rf230_async_error_recover(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nat86rf230_async_state_change(lp, ctx, STATE_RX_AACK_ON, NULL);\r\n}\r\nstatic void\r\nat86rf230_async_error(struct at86rf230_local *lp,\r\nstruct at86rf230_state_change *ctx, int rc)\r\n{\r\ndev_err(&lp->spi->dev, "spi_async error %d\n", rc);\r\nat86rf230_async_state_change(lp, ctx, STATE_FORCE_TRX_OFF,\r\nat86rf230_async_error_recover);\r\n}\r\nstatic int\r\nat86rf230_async_read_reg(struct at86rf230_local *lp, const u8 reg,\r\nstruct at86rf230_state_change *ctx,\r\nvoid (*complete)(void *context))\r\n{\r\nu8 *tx_buf = ctx->buf;\r\ntx_buf[0] = (reg & CMD_REG_MASK) | CMD_REG;\r\nctx->trx.len = 2;\r\nctx->msg.complete = complete;\r\nreturn spi_async(lp->spi, &ctx->msg);\r\n}\r\nstatic void\r\nat86rf230_async_state_assert(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nconst u8 *buf = ctx->buf;\r\nconst u8 trx_state = buf[1] & 0x1f;\r\nif (trx_state != ctx->to_state) {\r\nif (trx_state == STATE_BUSY_RX_AACK) {\r\nif (ctx->to_state == STATE_RX_AACK_ON)\r\ngoto done;\r\nif (ctx->to_state == STATE_TX_ON) {\r\nat86rf230_async_state_change(lp, ctx,\r\nSTATE_FORCE_TX_ON,\r\nctx->complete);\r\nreturn;\r\n}\r\n}\r\ndev_warn(&lp->spi->dev, "unexcept state change from 0x%02x to 0x%02x. Actual state: 0x%02x\n",\r\nctx->from_state, ctx->to_state, trx_state);\r\n}\r\ndone:\r\nif (ctx->complete)\r\nctx->complete(context);\r\n}\r\nstatic void\r\nat86rf230_async_state_delay(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nstruct at86rf2xx_chip_data *c = lp->data;\r\nbool force = false;\r\nint rc;\r\nswitch (ctx->to_state) {\r\ncase STATE_FORCE_TX_ON:\r\nctx->to_state = STATE_TX_ON;\r\nforce = true;\r\nbreak;\r\ncase STATE_FORCE_TRX_OFF:\r\nctx->to_state = STATE_TRX_OFF;\r\nforce = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (ctx->from_state) {\r\ncase STATE_TRX_OFF:\r\nswitch (ctx->to_state) {\r\ncase STATE_RX_AACK_ON:\r\nusleep_range(c->t_off_to_aack, c->t_off_to_aack + 10);\r\ngoto change;\r\ncase STATE_TX_ON:\r\nusleep_range(c->t_off_to_tx_on,\r\nc->t_off_to_tx_on + 10);\r\ngoto change;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_BUSY_RX_AACK:\r\nswitch (ctx->to_state) {\r\ncase STATE_TX_ON:\r\nif (!force) {\r\nusleep_range(c->t_frame + c->t_p_ack,\r\nc->t_frame + c->t_p_ack + 1000);\r\ngoto change;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_P_ON:\r\nswitch (ctx->to_state) {\r\ncase STATE_TRX_OFF:\r\nusleep_range(c->t_reset_to_off, c->t_reset_to_off + 10);\r\ngoto change;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nudelay(1);\r\nchange:\r\nrc = at86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\r\nat86rf230_async_state_assert);\r\nif (rc)\r\ndev_err(&lp->spi->dev, "spi_async error %d\n", rc);\r\n}\r\nstatic void\r\nat86rf230_async_state_change_start(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nu8 *buf = ctx->buf;\r\nconst u8 trx_state = buf[1] & 0x1f;\r\nint rc;\r\nif (trx_state == STATE_TRANSITION_IN_PROGRESS) {\r\nudelay(1);\r\nrc = at86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\r\nat86rf230_async_state_change_start);\r\nif (rc)\r\ndev_err(&lp->spi->dev, "spi_async error %d\n", rc);\r\nreturn;\r\n}\r\nif (trx_state == ctx->to_state) {\r\nif (ctx->complete)\r\nctx->complete(context);\r\nreturn;\r\n}\r\nctx->from_state = trx_state;\r\nbuf[0] = (RG_TRX_STATE & CMD_REG_MASK) | CMD_REG | CMD_WRITE;\r\nbuf[1] = ctx->to_state;\r\nctx->trx.len = 2;\r\nctx->msg.complete = at86rf230_async_state_delay;\r\nrc = spi_async(lp->spi, &ctx->msg);\r\nif (rc)\r\ndev_err(&lp->spi->dev, "spi_async error %d\n", rc);\r\n}\r\nstatic int\r\nat86rf230_async_state_change(struct at86rf230_local *lp,\r\nstruct at86rf230_state_change *ctx,\r\nconst u8 state, void (*complete)(void *context))\r\n{\r\nctx->to_state = state;\r\nctx->complete = complete;\r\nreturn at86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\r\nat86rf230_async_state_change_start);\r\n}\r\nstatic void\r\nat86rf230_sync_state_change_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\ncomplete(&lp->state_complete);\r\n}\r\nstatic int\r\nat86rf230_sync_state_change(struct at86rf230_local *lp, unsigned int state)\r\n{\r\nint rc;\r\nrc = at86rf230_async_state_change(lp, &lp->state, state,\r\nat86rf230_sync_state_change_complete);\r\nif (rc) {\r\nat86rf230_async_error(lp, &lp->state, rc);\r\nreturn rc;\r\n}\r\nrc = wait_for_completion_timeout(&lp->state_complete,\r\nmsecs_to_jiffies(100));\r\nif (!rc)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void\r\nat86rf230_tx_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\ncomplete(&lp->tx_complete);\r\n}\r\nstatic void\r\nat86rf230_tx_on(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nint rc;\r\nrc = at86rf230_async_state_change(lp, &lp->irq, STATE_RX_AACK_ON,\r\nat86rf230_tx_complete);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\nstatic void\r\nat86rf230_tx_trac_error(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nint rc;\r\nrc = at86rf230_async_state_change(lp, ctx, STATE_TX_ON,\r\nat86rf230_tx_on);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\nstatic void\r\nat86rf230_tx_trac_check(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nconst u8 *buf = ctx->buf;\r\nconst u8 trac = (buf[1] & 0xe0) >> 5;\r\nint rc;\r\nif (trac) {\r\nrc = at86rf230_async_state_change(lp, ctx, STATE_FORCE_TRX_OFF,\r\nat86rf230_tx_trac_error);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\nreturn;\r\n}\r\nat86rf230_tx_on(context);\r\n}\r\nstatic void\r\nat86rf230_tx_trac_status(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nint rc;\r\nrc = at86rf230_async_read_reg(lp, RG_TRX_STATE, ctx,\r\nat86rf230_tx_trac_check);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\nstatic void\r\nat86rf230_rx(struct at86rf230_local *lp,\r\nconst u8 *data, u8 len)\r\n{\r\nu8 lqi;\r\nstruct sk_buff *skb;\r\nu8 rx_local_buf[AT86RF2XX_MAX_BUF];\r\nif (len < 2)\r\nreturn;\r\nif (len > IEEE802154_MTU) {\r\nlqi = 0;\r\nlen = IEEE802154_MTU;\r\ndev_vdbg(&lp->spi->dev, "corrupted frame received\n");\r\n} else {\r\nlqi = data[len];\r\n}\r\nmemcpy(rx_local_buf, data, len);\r\nenable_irq(lp->spi->irq);\r\nskb = alloc_skb(IEEE802154_MTU, GFP_ATOMIC);\r\nif (!skb) {\r\ndev_vdbg(&lp->spi->dev, "failed to allocate sk_buff\n");\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, len), rx_local_buf, len);\r\nskb_trim(skb, len - 2);\r\nieee802154_rx_irqsafe(lp->dev, skb, lqi);\r\n}\r\nstatic void\r\nat86rf230_rx_read_frame_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nconst u8 *buf = lp->irq.buf;\r\nconst u8 len = buf[1];\r\nat86rf230_rx(lp, buf + 2, len);\r\n}\r\nstatic int\r\nat86rf230_rx_read_frame(struct at86rf230_local *lp)\r\n{\r\nu8 *buf = lp->irq.buf;\r\nbuf[0] = CMD_FB;\r\nlp->irq.trx.len = AT86RF2XX_MAX_BUF;\r\nlp->irq.msg.complete = at86rf230_rx_read_frame_complete;\r\nreturn spi_async(lp->spi, &lp->irq.msg);\r\n}\r\nstatic void\r\nat86rf230_rx_trac_check(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nint rc;\r\nrc = at86rf230_rx_read_frame(lp);\r\nif (rc) {\r\nenable_irq(lp->spi->irq);\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\n}\r\nstatic int\r\nat86rf230_irq_trx_end(struct at86rf230_local *lp)\r\n{\r\nspin_lock(&lp->lock);\r\nif (lp->is_tx) {\r\nlp->is_tx = 0;\r\nspin_unlock(&lp->lock);\r\nenable_irq(lp->spi->irq);\r\nif (lp->tx_aret)\r\nreturn at86rf230_async_state_change(lp, &lp->irq,\r\nSTATE_FORCE_TX_ON,\r\nat86rf230_tx_trac_status);\r\nelse\r\nreturn at86rf230_async_state_change(lp, &lp->irq,\r\nSTATE_RX_AACK_ON,\r\nat86rf230_tx_complete);\r\n} else {\r\nspin_unlock(&lp->lock);\r\nreturn at86rf230_async_read_reg(lp, RG_TRX_STATE, &lp->irq,\r\nat86rf230_rx_trac_check);\r\n}\r\n}\r\nstatic void\r\nat86rf230_irq_status(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nconst u8 *buf = lp->irq.buf;\r\nconst u8 irq = buf[1];\r\nint rc;\r\nif (irq & IRQ_TRX_END) {\r\nrc = at86rf230_irq_trx_end(lp);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n} else {\r\nenable_irq(lp->spi->irq);\r\ndev_err(&lp->spi->dev, "not supported irq %02x received\n",\r\nirq);\r\n}\r\n}\r\nstatic irqreturn_t at86rf230_isr(int irq, void *data)\r\n{\r\nstruct at86rf230_local *lp = data;\r\nstruct at86rf230_state_change *ctx = &lp->irq;\r\nu8 *buf = ctx->buf;\r\nint rc;\r\ndisable_irq_nosync(lp->spi->irq);\r\nbuf[0] = (RG_IRQ_STATUS & CMD_REG_MASK) | CMD_REG;\r\nctx->trx.len = 2;\r\nctx->msg.complete = at86rf230_irq_status;\r\nrc = spi_async(lp->spi, &ctx->msg);\r\nif (rc) {\r\nat86rf230_async_error(lp, ctx, rc);\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nat86rf230_write_frame_complete(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nu8 *buf = ctx->buf;\r\nint rc;\r\nbuf[0] = (RG_TRX_STATE & CMD_REG_MASK) | CMD_REG | CMD_WRITE;\r\nbuf[1] = STATE_BUSY_TX;\r\nctx->trx.len = 2;\r\nctx->msg.complete = NULL;\r\nrc = spi_async(lp->spi, &ctx->msg);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\nstatic void\r\nat86rf230_write_frame(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nstruct sk_buff *skb = lp->tx_skb;\r\nu8 *buf = lp->tx.buf;\r\nint rc;\r\nspin_lock(&lp->lock);\r\nlp->is_tx = 1;\r\nspin_unlock(&lp->lock);\r\nbuf[0] = CMD_FB | CMD_WRITE;\r\nbuf[1] = skb->len + 2;\r\nmemcpy(buf + 2, skb->data, skb->len);\r\nlp->tx.trx.len = skb->len + 2;\r\nlp->tx.msg.complete = at86rf230_write_frame_complete;\r\nrc = spi_async(lp->spi, &lp->tx.msg);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\nstatic void\r\nat86rf230_xmit_tx_on(void *context)\r\n{\r\nstruct at86rf230_state_change *ctx = context;\r\nstruct at86rf230_local *lp = ctx->lp;\r\nint rc;\r\nrc = at86rf230_async_state_change(lp, ctx, STATE_TX_ARET_ON,\r\nat86rf230_write_frame);\r\nif (rc)\r\nat86rf230_async_error(lp, ctx, rc);\r\n}\r\nstatic int\r\nat86rf230_xmit(struct ieee802154_dev *dev, struct sk_buff *skb)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nstruct at86rf230_state_change *ctx = &lp->tx;\r\nvoid (*tx_complete)(void *context) = at86rf230_write_frame;\r\nint rc;\r\nlp->tx_skb = skb;\r\nif (lp->tx_aret)\r\ntx_complete = at86rf230_xmit_tx_on;\r\nrc = at86rf230_async_state_change(lp, ctx, STATE_TX_ON,\r\ntx_complete);\r\nif (rc) {\r\nat86rf230_async_error(lp, ctx, rc);\r\nreturn rc;\r\n}\r\nrc = wait_for_completion_interruptible_timeout(&lp->tx_complete,\r\nmsecs_to_jiffies(lp->data->t_tx_timeout));\r\nif (!rc) {\r\nat86rf230_async_error(lp, ctx, rc);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (skb->len > 18)\r\nusleep_range(lp->data->t_lifs, lp->data->t_lifs + 10);\r\nelse\r\nusleep_range(lp->data->t_sifs, lp->data->t_sifs + 10);\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_ed(struct ieee802154_dev *dev, u8 *level)\r\n{\r\nmight_sleep();\r\nBUG_ON(!level);\r\n*level = 0xbe;\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_start(struct ieee802154_dev *dev)\r\n{\r\nreturn at86rf230_sync_state_change(dev->priv, STATE_RX_AACK_ON);\r\n}\r\nstatic void\r\nat86rf230_stop(struct ieee802154_dev *dev)\r\n{\r\nat86rf230_sync_state_change(dev->priv, STATE_FORCE_TRX_OFF);\r\n}\r\nstatic int\r\nat86rf23x_set_channel(struct at86rf230_local *lp, int page, int channel)\r\n{\r\nreturn at86rf230_write_subreg(lp, SR_CHANNEL, channel);\r\n}\r\nstatic int\r\nat86rf212_set_channel(struct at86rf230_local *lp, int page, int channel)\r\n{\r\nint rc;\r\nif (channel == 0)\r\nrc = at86rf230_write_subreg(lp, SR_SUB_MODE, 0);\r\nelse\r\nrc = at86rf230_write_subreg(lp, SR_SUB_MODE, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nif (page == 0) {\r\nrc = at86rf230_write_subreg(lp, SR_BPSK_QPSK, 0);\r\nlp->data->rssi_base_val = -100;\r\n} else {\r\nrc = at86rf230_write_subreg(lp, SR_BPSK_QPSK, 1);\r\nlp->data->rssi_base_val = -98;\r\n}\r\nif (rc < 0)\r\nreturn rc;\r\nreturn at86rf230_write_subreg(lp, SR_CHANNEL, channel);\r\n}\r\nstatic int\r\nat86rf230_channel(struct ieee802154_dev *dev, int page, int channel)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nint rc;\r\nmight_sleep();\r\nif (page < 0 || page > 31 ||\r\n!(lp->dev->phy->channels_supported[page] & BIT(channel))) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nrc = lp->data->set_channel(lp, page, channel);\r\nif (rc < 0)\r\nreturn rc;\r\nusleep_range(lp->data->t_channel_switch,\r\nlp->data->t_channel_switch + 10);\r\ndev->phy->current_channel = channel;\r\ndev->phy->current_page = page;\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_set_hw_addr_filt(struct ieee802154_dev *dev,\r\nstruct ieee802154_hw_addr_filt *filt,\r\nunsigned long changed)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nif (changed & IEEE802515_AFILT_SADDR_CHANGED) {\r\nu16 addr = le16_to_cpu(filt->short_addr);\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for saddr\n");\r\n__at86rf230_write(lp, RG_SHORT_ADDR_0, addr);\r\n__at86rf230_write(lp, RG_SHORT_ADDR_1, addr >> 8);\r\n}\r\nif (changed & IEEE802515_AFILT_PANID_CHANGED) {\r\nu16 pan = le16_to_cpu(filt->pan_id);\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for pan id\n");\r\n__at86rf230_write(lp, RG_PAN_ID_0, pan);\r\n__at86rf230_write(lp, RG_PAN_ID_1, pan >> 8);\r\n}\r\nif (changed & IEEE802515_AFILT_IEEEADDR_CHANGED) {\r\nu8 i, addr[8];\r\nmemcpy(addr, &filt->ieee_addr, 8);\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for IEEE addr\n");\r\nfor (i = 0; i < 8; i++)\r\n__at86rf230_write(lp, RG_IEEE_ADDR_0 + i, addr[i]);\r\n}\r\nif (changed & IEEE802515_AFILT_PANC_CHANGED) {\r\ndev_vdbg(&lp->spi->dev,\r\n"at86rf230_set_hw_addr_filt called for panc change\n");\r\nif (filt->pan_coord)\r\nat86rf230_write_subreg(lp, SR_AACK_I_AM_COORD, 1);\r\nelse\r\nat86rf230_write_subreg(lp, SR_AACK_I_AM_COORD, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nat86rf230_set_txpower(struct ieee802154_dev *dev, int db)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nif (db > 5 || db < -26)\r\nreturn -EINVAL;\r\ndb = -(db - 5);\r\nreturn __at86rf230_write(lp, RG_PHY_TX_PWR, 0x60 | db);\r\n}\r\nstatic int\r\nat86rf230_set_lbt(struct ieee802154_dev *dev, bool on)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nreturn at86rf230_write_subreg(lp, SR_CSMA_LBT_MODE, on);\r\n}\r\nstatic int\r\nat86rf230_set_cca_mode(struct ieee802154_dev *dev, u8 mode)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nreturn at86rf230_write_subreg(lp, SR_CCA_MODE, mode);\r\n}\r\nstatic int\r\nat86rf212_get_desens_steps(struct at86rf230_local *lp, s32 level)\r\n{\r\nreturn (level - lp->data->rssi_base_val) * 100 / 207;\r\n}\r\nstatic int\r\nat86rf23x_get_desens_steps(struct at86rf230_local *lp, s32 level)\r\n{\r\nreturn (level - lp->data->rssi_base_val) / 2;\r\n}\r\nstatic int\r\nat86rf230_set_cca_ed_level(struct ieee802154_dev *dev, s32 level)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nif (level < lp->data->rssi_base_val || level > 30)\r\nreturn -EINVAL;\r\nreturn at86rf230_write_subreg(lp, SR_CCA_ED_THRES,\r\nlp->data->get_desense_steps(lp, level));\r\n}\r\nstatic int\r\nat86rf230_set_csma_params(struct ieee802154_dev *dev, u8 min_be, u8 max_be,\r\nu8 retries)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nint rc;\r\nif (min_be > max_be || max_be > 8 || retries > 5)\r\nreturn -EINVAL;\r\nrc = at86rf230_write_subreg(lp, SR_MIN_BE, min_be);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_MAX_BE, max_be);\r\nif (rc)\r\nreturn rc;\r\nreturn at86rf230_write_subreg(lp, SR_MAX_CSMA_RETRIES, retries);\r\n}\r\nstatic int\r\nat86rf230_set_frame_retries(struct ieee802154_dev *dev, s8 retries)\r\n{\r\nstruct at86rf230_local *lp = dev->priv;\r\nint rc = 0;\r\nif (retries < -1 || retries > 15)\r\nreturn -EINVAL;\r\nlp->tx_aret = retries >= 0;\r\nif (retries >= 0)\r\nrc = at86rf230_write_subreg(lp, SR_MAX_FRAME_RETRIES, retries);\r\nreturn rc;\r\n}\r\nstatic int at86rf230_hw_init(struct at86rf230_local *lp)\r\n{\r\nint rc, irq_type, irq_pol = IRQ_ACTIVE_HIGH;\r\nunsigned int dvdd;\r\nu8 csma_seed[2];\r\nrc = at86rf230_sync_state_change(lp, STATE_FORCE_TRX_OFF);\r\nif (rc)\r\nreturn rc;\r\nirq_type = irq_get_trigger_type(lp->spi->irq);\r\nif (irq_type == IRQ_TYPE_EDGE_FALLING)\r\nirq_pol = IRQ_ACTIVE_LOW;\r\nrc = at86rf230_write_subreg(lp, SR_IRQ_POLARITY, irq_pol);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_RX_SAFE_MODE, 1);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_IRQ_MASK, IRQ_TRX_END);\r\nif (rc)\r\nreturn rc;\r\nget_random_bytes(csma_seed, ARRAY_SIZE(csma_seed));\r\nrc = at86rf230_write_subreg(lp, SR_CSMA_SEED_0, csma_seed[0]);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_CSMA_SEED_1, csma_seed[1]);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_CLKM_SHA_SEL, 0x00);\r\nif (rc)\r\nreturn rc;\r\nrc = at86rf230_write_subreg(lp, SR_CLKM_CTRL, 0x00);\r\nif (rc)\r\nreturn rc;\r\nusleep_range(lp->data->t_sleep_cycle,\r\nlp->data->t_sleep_cycle + 100);\r\nrc = at86rf230_read_subreg(lp, SR_DVDD_OK, &dvdd);\r\nif (rc)\r\nreturn rc;\r\nif (!dvdd) {\r\ndev_err(&lp->spi->dev, "DVDD error\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct at86rf230_platform_data *\r\nat86rf230_get_pdata(struct spi_device *spi)\r\n{\r\nstruct at86rf230_platform_data *pdata;\r\nif (!IS_ENABLED(CONFIG_OF) || !spi->dev.of_node)\r\nreturn spi->dev.platform_data;\r\npdata = devm_kzalloc(&spi->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\ngoto done;\r\npdata->rstn = of_get_named_gpio(spi->dev.of_node, "reset-gpio", 0);\r\npdata->slp_tr = of_get_named_gpio(spi->dev.of_node, "sleep-gpio", 0);\r\nspi->dev.platform_data = pdata;\r\ndone:\r\nreturn pdata;\r\n}\r\nstatic int\r\nat86rf230_detect_device(struct at86rf230_local *lp)\r\n{\r\nunsigned int part, version, val;\r\nu16 man_id = 0;\r\nconst char *chip;\r\nint rc;\r\nrc = __at86rf230_read(lp, RG_MAN_ID_0, &val);\r\nif (rc)\r\nreturn rc;\r\nman_id |= val;\r\nrc = __at86rf230_read(lp, RG_MAN_ID_1, &val);\r\nif (rc)\r\nreturn rc;\r\nman_id |= (val << 8);\r\nrc = __at86rf230_read(lp, RG_PART_NUM, &part);\r\nif (rc)\r\nreturn rc;\r\nrc = __at86rf230_read(lp, RG_PART_NUM, &version);\r\nif (rc)\r\nreturn rc;\r\nif (man_id != 0x001f) {\r\ndev_err(&lp->spi->dev, "Non-Atmel dev found (MAN_ID %02x %02x)\n",\r\nman_id >> 8, man_id & 0xFF);\r\nreturn -EINVAL;\r\n}\r\nlp->dev->extra_tx_headroom = 0;\r\nlp->dev->flags = IEEE802154_HW_OMIT_CKSUM | IEEE802154_HW_AACK |\r\nIEEE802154_HW_TXPOWER | IEEE802154_HW_CSMA;\r\nswitch (part) {\r\ncase 2:\r\nchip = "at86rf230";\r\nrc = -ENOTSUPP;\r\nbreak;\r\ncase 3:\r\nchip = "at86rf231";\r\nlp->data = &at86rf231_data;\r\nlp->dev->phy->channels_supported[0] = 0x7FFF800;\r\nbreak;\r\ncase 7:\r\nchip = "at86rf212";\r\nif (version == 1) {\r\nlp->data = &at86rf212_data;\r\nlp->dev->flags |= IEEE802154_HW_LBT;\r\nlp->dev->phy->channels_supported[0] = 0x00007FF;\r\nlp->dev->phy->channels_supported[2] = 0x00007FF;\r\n} else {\r\nrc = -ENOTSUPP;\r\n}\r\nbreak;\r\ncase 11:\r\nchip = "at86rf233";\r\nlp->data = &at86rf233_data;\r\nlp->dev->phy->channels_supported[0] = 0x7FFF800;\r\nbreak;\r\ndefault:\r\nchip = "unkown";\r\nrc = -ENOTSUPP;\r\nbreak;\r\n}\r\ndev_info(&lp->spi->dev, "Detected %s chip version %d\n", chip, version);\r\nreturn rc;\r\n}\r\nstatic void\r\nat86rf230_setup_spi_messages(struct at86rf230_local *lp)\r\n{\r\nlp->state.lp = lp;\r\nspi_message_init(&lp->state.msg);\r\nlp->state.msg.context = &lp->state;\r\nlp->state.trx.tx_buf = lp->state.buf;\r\nlp->state.trx.rx_buf = lp->state.buf;\r\nspi_message_add_tail(&lp->state.trx, &lp->state.msg);\r\nlp->irq.lp = lp;\r\nspi_message_init(&lp->irq.msg);\r\nlp->irq.msg.context = &lp->irq;\r\nlp->irq.trx.tx_buf = lp->irq.buf;\r\nlp->irq.trx.rx_buf = lp->irq.buf;\r\nspi_message_add_tail(&lp->irq.trx, &lp->irq.msg);\r\nlp->tx.lp = lp;\r\nspi_message_init(&lp->tx.msg);\r\nlp->tx.msg.context = &lp->tx;\r\nlp->tx.trx.tx_buf = lp->tx.buf;\r\nlp->tx.trx.rx_buf = lp->tx.buf;\r\nspi_message_add_tail(&lp->tx.trx, &lp->tx.msg);\r\n}\r\nstatic int at86rf230_probe(struct spi_device *spi)\r\n{\r\nstruct at86rf230_platform_data *pdata;\r\nstruct ieee802154_dev *dev;\r\nstruct at86rf230_local *lp;\r\nunsigned int status;\r\nint rc, irq_type;\r\nif (!spi->irq) {\r\ndev_err(&spi->dev, "no IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\npdata = at86rf230_get_pdata(spi);\r\nif (!pdata) {\r\ndev_err(&spi->dev, "no platform_data\n");\r\nreturn -EINVAL;\r\n}\r\nif (gpio_is_valid(pdata->rstn)) {\r\nrc = devm_gpio_request_one(&spi->dev, pdata->rstn,\r\nGPIOF_OUT_INIT_HIGH, "rstn");\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (gpio_is_valid(pdata->slp_tr)) {\r\nrc = devm_gpio_request_one(&spi->dev, pdata->slp_tr,\r\nGPIOF_OUT_INIT_LOW, "slp_tr");\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (gpio_is_valid(pdata->rstn)) {\r\nudelay(1);\r\ngpio_set_value(pdata->rstn, 0);\r\nudelay(1);\r\ngpio_set_value(pdata->rstn, 1);\r\nusleep_range(120, 240);\r\n}\r\ndev = ieee802154_alloc_device(sizeof(*lp), &at86rf230_ops);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = dev->priv;\r\nlp->dev = dev;\r\nlp->spi = spi;\r\ndev->parent = &spi->dev;\r\nlp->regmap = devm_regmap_init_spi(spi, &at86rf230_regmap_spi_config);\r\nif (IS_ERR(lp->regmap)) {\r\nrc = PTR_ERR(lp->regmap);\r\ndev_err(&spi->dev, "Failed to allocate register map: %d\n",\r\nrc);\r\ngoto free_dev;\r\n}\r\nat86rf230_setup_spi_messages(lp);\r\nrc = at86rf230_detect_device(lp);\r\nif (rc < 0)\r\ngoto free_dev;\r\nspin_lock_init(&lp->lock);\r\ninit_completion(&lp->tx_complete);\r\ninit_completion(&lp->state_complete);\r\nspi_set_drvdata(spi, lp);\r\nrc = at86rf230_hw_init(lp);\r\nif (rc)\r\ngoto free_dev;\r\nrc = at86rf230_read_subreg(lp, RG_IRQ_STATUS, 0xff, 0, &status);\r\nif (rc)\r\ngoto free_dev;\r\nirq_type = irq_get_trigger_type(spi->irq);\r\nif (!irq_type)\r\nirq_type = IRQF_TRIGGER_RISING;\r\nrc = devm_request_irq(&spi->dev, spi->irq, at86rf230_isr,\r\nIRQF_SHARED | irq_type, dev_name(&spi->dev), lp);\r\nif (rc)\r\ngoto free_dev;\r\nrc = ieee802154_register_device(lp->dev);\r\nif (rc)\r\ngoto free_dev;\r\nreturn rc;\r\nfree_dev:\r\nieee802154_free_device(lp->dev);\r\nreturn rc;\r\n}\r\nstatic int at86rf230_remove(struct spi_device *spi)\r\n{\r\nstruct at86rf230_local *lp = spi_get_drvdata(spi);\r\nat86rf230_write_subreg(lp, SR_IRQ_MASK, 0);\r\nieee802154_unregister_device(lp->dev);\r\nieee802154_free_device(lp->dev);\r\ndev_dbg(&spi->dev, "unregistered at86rf230\n");\r\nreturn 0;\r\n}
