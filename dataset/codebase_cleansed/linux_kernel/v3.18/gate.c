static int omap36xx_gate_clk_enable_with_hsdiv_restore(struct clk_hw *clk)\r\n{\r\nstruct clk_divider *parent;\r\nstruct clk_hw *parent_hw;\r\nu32 dummy_v, orig_v;\r\nint ret;\r\nret = omap2_dflt_clk_enable(clk);\r\nparent_hw = __clk_get_hw(__clk_get_parent(__clk_get_parent(clk->clk)));\r\nparent = to_clk_divider(parent_hw);\r\nif (!ret) {\r\norig_v = ti_clk_ll_ops->clk_readl(parent->reg);\r\ndummy_v = orig_v;\r\ndummy_v ^= (1 << parent->shift);\r\nti_clk_ll_ops->clk_writel(dummy_v, parent->reg);\r\nti_clk_ll_ops->clk_writel(orig_v, parent->reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __init _of_ti_gate_clk_setup(struct device_node *node,\r\nconst struct clk_ops *ops,\r\nconst struct clk_hw_omap_ops *hw_ops)\r\n{\r\nstruct clk *clk;\r\nstruct clk_init_data init = { NULL };\r\nstruct clk_hw_omap *clk_hw;\r\nconst char *clk_name = node->name;\r\nconst char *parent_name;\r\nu32 val;\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\nif (!clk_hw)\r\nreturn;\r\nclk_hw->hw.init = &init;\r\ninit.name = clk_name;\r\ninit.ops = ops;\r\nif (ops != &omap_gate_clkdm_clk_ops) {\r\nclk_hw->enable_reg = ti_clk_get_reg_addr(node, 0);\r\nif (!clk_hw->enable_reg)\r\ngoto cleanup;\r\nif (!of_property_read_u32(node, "ti,bit-shift", &val))\r\nclk_hw->enable_bit = val;\r\n}\r\nclk_hw->ops = hw_ops;\r\nclk_hw->flags = MEMMAP_ADDRESSING;\r\nif (of_clk_get_parent_count(node) != 1) {\r\npr_err("%s must have 1 parent\n", clk_name);\r\ngoto cleanup;\r\n}\r\nparent_name = of_clk_get_parent_name(node, 0);\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nif (of_property_read_bool(node, "ti,set-rate-parent"))\r\ninit.flags |= CLK_SET_RATE_PARENT;\r\nif (of_property_read_bool(node, "ti,set-bit-to-disable"))\r\nclk_hw->flags |= INVERT_ENABLE;\r\nclk = clk_register(NULL, &clk_hw->hw);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nreturn;\r\n}\r\ncleanup:\r\nkfree(clk_hw);\r\n}\r\nstatic void __init\r\n_of_ti_composite_gate_clk_setup(struct device_node *node,\r\nconst struct clk_hw_omap_ops *hw_ops)\r\n{\r\nstruct clk_hw_omap *gate;\r\nu32 val = 0;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\nreturn;\r\ngate->enable_reg = ti_clk_get_reg_addr(node, 0);\r\nif (!gate->enable_reg)\r\ngoto cleanup;\r\nof_property_read_u32(node, "ti,bit-shift", &val);\r\ngate->enable_bit = val;\r\ngate->ops = hw_ops;\r\ngate->flags = MEMMAP_ADDRESSING;\r\nif (!ti_clk_add_component(node, &gate->hw, CLK_COMPONENT_TYPE_GATE))\r\nreturn;\r\ncleanup:\r\nkfree(gate);\r\n}\r\nstatic void __init\r\nof_ti_composite_no_wait_gate_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_composite_gate_clk_setup(node, NULL);\r\n}\r\nstatic void __init of_ti_composite_interface_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_composite_gate_clk_setup(node, &clkhwops_iclk_wait);\r\n}\r\nstatic void __init of_ti_composite_gate_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_composite_gate_clk_setup(node, &clkhwops_wait);\r\n}\r\nstatic void __init of_ti_clkdm_gate_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_gate_clk_setup(node, &omap_gate_clkdm_clk_ops, NULL);\r\n}\r\nstatic void __init of_ti_hsdiv_gate_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_gate_clk_setup(node, &omap_gate_clk_hsdiv_restore_ops,\r\n&clkhwops_wait);\r\n}\r\nstatic void __init of_ti_gate_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_gate_clk_setup(node, &omap_gate_clk_ops, NULL);\r\n}\r\nstatic void __init of_ti_wait_gate_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_gate_clk_setup(node, &omap_gate_clk_ops, &clkhwops_wait);\r\n}\r\nstatic void __init of_ti_am35xx_gate_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_gate_clk_setup(node, &omap_gate_clk_ops,\r\n&clkhwops_am35xx_ipss_module_wait);\r\n}\r\nstatic void __init of_ti_dss_gate_clk_setup(struct device_node *node)\r\n{\r\n_of_ti_gate_clk_setup(node, &omap_gate_clk_ops,\r\n&clkhwops_omap3430es2_dss_usbhost_wait);\r\n}
