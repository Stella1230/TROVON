static int handle_noop(struct kvm_vcpu *vcpu)\r\n{\r\nswitch (vcpu->arch.sie_block->icptcode) {\r\ncase 0x0:\r\nvcpu->stat.exit_null++;\r\nbreak;\r\ncase 0x10:\r\nvcpu->stat.exit_external_request++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_stop(struct kvm_vcpu *vcpu)\r\n{\r\nint rc = 0;\r\nunsigned int action_bits;\r\nvcpu->stat.exit_stop_request++;\r\ntrace_kvm_s390_stop_request(vcpu->arch.local_int.action_bits);\r\naction_bits = vcpu->arch.local_int.action_bits;\r\nif (!(action_bits & ACTION_STOP_ON_STOP))\r\nreturn 0;\r\nif (action_bits & ACTION_STORE_ON_STOP) {\r\nrc = kvm_s390_vcpu_store_status(vcpu,\r\nKVM_S390_STORE_STATUS_NOADDR);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (!kvm_s390_user_cpu_state_ctrl(vcpu->kvm))\r\nkvm_s390_vcpu_stop(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_validity(struct kvm_vcpu *vcpu)\r\n{\r\nint viwhy = vcpu->arch.sie_block->ipb >> 16;\r\nvcpu->stat.exit_validity++;\r\ntrace_kvm_s390_intercept_validity(vcpu, viwhy);\r\nWARN_ONCE(true, "kvm: unhandled validity intercept 0x%x\n", viwhy);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_instruction(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nvcpu->stat.exit_instruction++;\r\ntrace_kvm_s390_intercept_instruction(vcpu,\r\nvcpu->arch.sie_block->ipa,\r\nvcpu->arch.sie_block->ipb);\r\nhandler = instruction_handlers[vcpu->arch.sie_block->ipa >> 8];\r\nif (handler)\r\nreturn handler(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void __extract_prog_irq(struct kvm_vcpu *vcpu,\r\nstruct kvm_s390_pgm_info *pgm_info)\r\n{\r\nmemset(pgm_info, 0, sizeof(struct kvm_s390_pgm_info));\r\npgm_info->code = vcpu->arch.sie_block->iprcc;\r\nswitch (vcpu->arch.sie_block->iprcc & ~PGM_PER) {\r\ncase PGM_AFX_TRANSLATION:\r\ncase PGM_ASX_TRANSLATION:\r\ncase PGM_EX_TRANSLATION:\r\ncase PGM_LFX_TRANSLATION:\r\ncase PGM_LSTE_SEQUENCE:\r\ncase PGM_LSX_TRANSLATION:\r\ncase PGM_LX_TRANSLATION:\r\ncase PGM_PRIMARY_AUTHORITY:\r\ncase PGM_SECONDARY_AUTHORITY:\r\ncase PGM_SPACE_SWITCH:\r\npgm_info->trans_exc_code = vcpu->arch.sie_block->tecmc;\r\nbreak;\r\ncase PGM_ALEN_TRANSLATION:\r\ncase PGM_ALE_SEQUENCE:\r\ncase PGM_ASTE_INSTANCE:\r\ncase PGM_ASTE_SEQUENCE:\r\ncase PGM_ASTE_VALIDITY:\r\ncase PGM_EXTENDED_AUTHORITY:\r\npgm_info->exc_access_id = vcpu->arch.sie_block->eai;\r\nbreak;\r\ncase PGM_ASCE_TYPE:\r\ncase PGM_PAGE_TRANSLATION:\r\ncase PGM_REGION_FIRST_TRANS:\r\ncase PGM_REGION_SECOND_TRANS:\r\ncase PGM_REGION_THIRD_TRANS:\r\ncase PGM_SEGMENT_TRANSLATION:\r\npgm_info->trans_exc_code = vcpu->arch.sie_block->tecmc;\r\npgm_info->exc_access_id = vcpu->arch.sie_block->eai;\r\npgm_info->op_access_id = vcpu->arch.sie_block->oai;\r\nbreak;\r\ncase PGM_MONITOR:\r\npgm_info->mon_class_nr = vcpu->arch.sie_block->mcn;\r\npgm_info->mon_code = vcpu->arch.sie_block->tecmc;\r\nbreak;\r\ncase PGM_DATA:\r\npgm_info->data_exc_code = vcpu->arch.sie_block->dxc;\r\nbreak;\r\ncase PGM_PROTECTION:\r\npgm_info->trans_exc_code = vcpu->arch.sie_block->tecmc;\r\npgm_info->exc_access_id = vcpu->arch.sie_block->eai;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (vcpu->arch.sie_block->iprcc & PGM_PER) {\r\npgm_info->per_code = vcpu->arch.sie_block->perc;\r\npgm_info->per_atmid = vcpu->arch.sie_block->peratmid;\r\npgm_info->per_address = vcpu->arch.sie_block->peraddr;\r\npgm_info->per_access_id = vcpu->arch.sie_block->peraid;\r\n}\r\n}\r\nstatic int handle_itdb(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_s390_itdb *itdb;\r\nint rc;\r\nif (!IS_TE_ENABLED(vcpu) || !IS_ITDB_VALID(vcpu))\r\nreturn 0;\r\nif (current->thread.per_flags & PER_FLAG_NO_TE)\r\nreturn 0;\r\nitdb = (struct kvm_s390_itdb *)vcpu->arch.sie_block->itdba;\r\nrc = write_guest_lc(vcpu, __LC_PGM_TDB, itdb, sizeof(*itdb));\r\nif (rc)\r\nreturn rc;\r\nmemset(itdb, 0, sizeof(*itdb));\r\nreturn 0;\r\n}\r\nstatic int handle_prog(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_s390_pgm_info pgm_info;\r\npsw_t psw;\r\nint rc;\r\nvcpu->stat.exit_program_interruption++;\r\nif (guestdbg_enabled(vcpu) && per_event(vcpu)) {\r\nkvm_s390_handle_per_event(vcpu);\r\nif (vcpu->arch.sie_block->iprcc == 0)\r\nreturn 0;\r\n}\r\ntrace_kvm_s390_intercept_prog(vcpu, vcpu->arch.sie_block->iprcc);\r\nif (vcpu->arch.sie_block->iprcc == PGM_SPECIFICATION) {\r\nrc = read_guest_lc(vcpu, __LC_PGM_NEW_PSW, &psw, sizeof(psw_t));\r\nif (rc)\r\nreturn rc;\r\nif (!is_valid_psw(&psw))\r\nreturn -EOPNOTSUPP;\r\n}\r\nrc = handle_itdb(vcpu);\r\nif (rc)\r\nreturn rc;\r\n__extract_prog_irq(vcpu, &pgm_info);\r\nreturn kvm_s390_inject_prog_irq(vcpu, &pgm_info);\r\n}\r\nstatic int handle_instruction_and_prog(struct kvm_vcpu *vcpu)\r\n{\r\nint rc, rc2;\r\nvcpu->stat.exit_instr_and_program++;\r\nrc = handle_instruction(vcpu);\r\nrc2 = handle_prog(vcpu);\r\nif (rc == -EOPNOTSUPP)\r\nvcpu->arch.sie_block->icptcode = 0x04;\r\nif (rc)\r\nreturn rc;\r\nreturn rc2;\r\n}\r\nstatic int handle_external_interrupt(struct kvm_vcpu *vcpu)\r\n{\r\nu16 eic = vcpu->arch.sie_block->eic;\r\nstruct kvm_s390_interrupt irq;\r\npsw_t newpsw;\r\nint rc;\r\nvcpu->stat.exit_external_interrupt++;\r\nrc = read_guest_lc(vcpu, __LC_EXT_NEW_PSW, &newpsw, sizeof(psw_t));\r\nif (rc)\r\nreturn rc;\r\nif ((eic == EXT_IRQ_CLK_COMP || eic == EXT_IRQ_CPU_TIMER) &&\r\n(newpsw.mask & PSW_MASK_EXT))\r\nreturn -EOPNOTSUPP;\r\nswitch (eic) {\r\ncase EXT_IRQ_CLK_COMP:\r\nirq.type = KVM_S390_INT_CLOCK_COMP;\r\nbreak;\r\ncase EXT_IRQ_CPU_TIMER:\r\nirq.type = KVM_S390_INT_CPU_TIMER;\r\nbreak;\r\ncase EXT_IRQ_EXTERNAL_CALL:\r\nif (kvm_s390_si_ext_call_pending(vcpu))\r\nreturn 0;\r\nirq.type = KVM_S390_INT_EXTERNAL_CALL;\r\nirq.parm = vcpu->arch.sie_block->extcpuaddr;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn kvm_s390_inject_vcpu(vcpu, &irq);\r\n}\r\nstatic int handle_mvpg_pei(struct kvm_vcpu *vcpu)\r\n{\r\npsw_t *psw = &vcpu->arch.sie_block->gpsw;\r\nunsigned long srcaddr, dstaddr;\r\nint reg1, reg2, rc;\r\nkvm_s390_get_regs_rre(vcpu, &reg1, &reg2);\r\nsrcaddr = kvm_s390_real_to_abs(vcpu, vcpu->run->s.regs.gprs[reg2]);\r\nif (kvm_is_error_gpa(vcpu->kvm, srcaddr))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\nrc = kvm_arch_fault_in_page(vcpu, srcaddr, 0);\r\nif (rc != 0)\r\nreturn rc;\r\ndstaddr = kvm_s390_real_to_abs(vcpu, vcpu->run->s.regs.gprs[reg1]);\r\nif (kvm_is_error_gpa(vcpu->kvm, dstaddr))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\nrc = kvm_arch_fault_in_page(vcpu, dstaddr, 1);\r\nif (rc != 0)\r\nreturn rc;\r\npsw->addr = __rewind_psw(*psw, 4);\r\nreturn 0;\r\n}\r\nstatic int handle_partial_execution(struct kvm_vcpu *vcpu)\r\n{\r\nif (vcpu->arch.sie_block->ipa == 0xb254)\r\nreturn handle_mvpg_pei(vcpu);\r\nif (vcpu->arch.sie_block->ipa >> 8 == 0xae)\r\nreturn kvm_s390_handle_sigp_pei(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nint kvm_handle_sie_intercept(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t func;\r\nu8 code = vcpu->arch.sie_block->icptcode;\r\nif (code & 3 || (code >> 2) >= ARRAY_SIZE(intercept_funcs))\r\nreturn -EOPNOTSUPP;\r\nfunc = intercept_funcs[code >> 2];\r\nif (func)\r\nreturn func(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}
