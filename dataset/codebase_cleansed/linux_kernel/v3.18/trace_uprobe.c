static unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\r\n{\r\nreturn addr - (n * sizeof(long));\r\n}\r\nstatic unsigned long adjust_stack_addr(unsigned long addr, unsigned int n)\r\n{\r\nreturn addr + (n * sizeof(long));\r\n}\r\nstatic unsigned long get_user_stack_nth(struct pt_regs *regs, unsigned int n)\r\n{\r\nunsigned long ret;\r\nunsigned long addr = user_stack_pointer(regs);\r\naddr = adjust_stack_addr(addr, n);\r\nif (copy_from_user(&ret, (void __force __user *) addr, sizeof(ret)))\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic unsigned long translate_user_vaddr(void *file_offset)\r\n{\r\nunsigned long base_addr;\r\nstruct uprobe_dispatch_data *udd;\r\nudd = (void *) current->utask->vaddr;\r\nbase_addr = udd->bp_addr - udd->tu->offset;\r\nreturn base_addr + (unsigned long)file_offset;\r\n}\r\nstatic inline void init_trace_uprobe_filter(struct trace_uprobe_filter *filter)\r\n{\r\nrwlock_init(&filter->rwlock);\r\nfilter->nr_systemwide = 0;\r\nINIT_LIST_HEAD(&filter->perf_events);\r\n}\r\nstatic inline bool uprobe_filter_is_empty(struct trace_uprobe_filter *filter)\r\n{\r\nreturn !filter->nr_systemwide && list_empty(&filter->perf_events);\r\n}\r\nstatic inline bool is_ret_probe(struct trace_uprobe *tu)\r\n{\r\nreturn tu->consumer.ret_handler != NULL;\r\n}\r\nstatic struct trace_uprobe *\r\nalloc_trace_uprobe(const char *group, const char *event, int nargs, bool is_ret)\r\n{\r\nstruct trace_uprobe *tu;\r\nif (!event || !is_good_name(event))\r\nreturn ERR_PTR(-EINVAL);\r\nif (!group || !is_good_name(group))\r\nreturn ERR_PTR(-EINVAL);\r\ntu = kzalloc(SIZEOF_TRACE_UPROBE(nargs), GFP_KERNEL);\r\nif (!tu)\r\nreturn ERR_PTR(-ENOMEM);\r\ntu->tp.call.class = &tu->tp.class;\r\ntu->tp.call.name = kstrdup(event, GFP_KERNEL);\r\nif (!tu->tp.call.name)\r\ngoto error;\r\ntu->tp.class.system = kstrdup(group, GFP_KERNEL);\r\nif (!tu->tp.class.system)\r\ngoto error;\r\nINIT_LIST_HEAD(&tu->list);\r\nINIT_LIST_HEAD(&tu->tp.files);\r\ntu->consumer.handler = uprobe_dispatcher;\r\nif (is_ret)\r\ntu->consumer.ret_handler = uretprobe_dispatcher;\r\ninit_trace_uprobe_filter(&tu->filter);\r\nreturn tu;\r\nerror:\r\nkfree(tu->tp.call.name);\r\nkfree(tu);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void free_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nint i;\r\nfor (i = 0; i < tu->tp.nr_args; i++)\r\ntraceprobe_free_probe_arg(&tu->tp.args[i]);\r\niput(tu->inode);\r\nkfree(tu->tp.call.class->system);\r\nkfree(tu->tp.call.name);\r\nkfree(tu->filename);\r\nkfree(tu);\r\n}\r\nstatic struct trace_uprobe *find_probe_event(const char *event, const char *group)\r\n{\r\nstruct trace_uprobe *tu;\r\nlist_for_each_entry(tu, &uprobe_list, list)\r\nif (strcmp(ftrace_event_name(&tu->tp.call), event) == 0 &&\r\nstrcmp(tu->tp.call.class->system, group) == 0)\r\nreturn tu;\r\nreturn NULL;\r\n}\r\nstatic int unregister_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nint ret;\r\nret = unregister_uprobe_event(tu);\r\nif (ret)\r\nreturn ret;\r\nlist_del(&tu->list);\r\nfree_trace_uprobe(tu);\r\nreturn 0;\r\n}\r\nstatic int register_trace_uprobe(struct trace_uprobe *tu)\r\n{\r\nstruct trace_uprobe *old_tu;\r\nint ret;\r\nmutex_lock(&uprobe_lock);\r\nold_tu = find_probe_event(ftrace_event_name(&tu->tp.call),\r\ntu->tp.call.class->system);\r\nif (old_tu) {\r\nret = unregister_trace_uprobe(old_tu);\r\nif (ret)\r\ngoto end;\r\n}\r\nret = register_uprobe_event(tu);\r\nif (ret) {\r\npr_warning("Failed to register probe event(%d)\n", ret);\r\ngoto end;\r\n}\r\nlist_add_tail(&tu->list, &uprobe_list);\r\nend:\r\nmutex_unlock(&uprobe_lock);\r\nreturn ret;\r\n}\r\nstatic int create_trace_uprobe(int argc, char **argv)\r\n{\r\nstruct trace_uprobe *tu;\r\nstruct inode *inode;\r\nchar *arg, *event, *group, *filename;\r\nchar buf[MAX_EVENT_NAME_LEN];\r\nstruct path path;\r\nunsigned long offset;\r\nbool is_delete, is_return;\r\nint i, ret;\r\ninode = NULL;\r\nret = 0;\r\nis_delete = false;\r\nis_return = false;\r\nevent = NULL;\r\ngroup = NULL;\r\nif (argv[0][0] == '-')\r\nis_delete = true;\r\nelse if (argv[0][0] == 'r')\r\nis_return = true;\r\nelse if (argv[0][0] != 'p') {\r\npr_info("Probe definition must be started with 'p', 'r' or '-'.\n");\r\nreturn -EINVAL;\r\n}\r\nif (argv[0][1] == ':') {\r\nevent = &argv[0][2];\r\narg = strchr(event, '/');\r\nif (arg) {\r\ngroup = event;\r\nevent = arg + 1;\r\nevent[-1] = '\0';\r\nif (strlen(group) == 0) {\r\npr_info("Group name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (strlen(event) == 0) {\r\npr_info("Event name is not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!group)\r\ngroup = UPROBE_EVENT_SYSTEM;\r\nif (is_delete) {\r\nint ret;\r\nif (!event) {\r\npr_info("Delete command needs an event name.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&uprobe_lock);\r\ntu = find_probe_event(event, group);\r\nif (!tu) {\r\nmutex_unlock(&uprobe_lock);\r\npr_info("Event %s/%s doesn't exist.\n", group, event);\r\nreturn -ENOENT;\r\n}\r\nret = unregister_trace_uprobe(tu);\r\nmutex_unlock(&uprobe_lock);\r\nreturn ret;\r\n}\r\nif (argc < 2) {\r\npr_info("Probe point is not specified.\n");\r\nreturn -EINVAL;\r\n}\r\nif (isdigit(argv[1][0])) {\r\npr_info("probe point must be have a filename.\n");\r\nreturn -EINVAL;\r\n}\r\narg = strchr(argv[1], ':');\r\nif (!arg) {\r\nret = -EINVAL;\r\ngoto fail_address_parse;\r\n}\r\n*arg++ = '\0';\r\nfilename = argv[1];\r\nret = kern_path(filename, LOOKUP_FOLLOW, &path);\r\nif (ret)\r\ngoto fail_address_parse;\r\ninode = igrab(path.dentry->d_inode);\r\npath_put(&path);\r\nif (!inode || !S_ISREG(inode->i_mode)) {\r\nret = -EINVAL;\r\ngoto fail_address_parse;\r\n}\r\nret = kstrtoul(arg, 0, &offset);\r\nif (ret)\r\ngoto fail_address_parse;\r\nargc -= 2;\r\nargv += 2;\r\nif (!event) {\r\nchar *tail;\r\nchar *ptr;\r\ntail = kstrdup(kbasename(filename), GFP_KERNEL);\r\nif (!tail) {\r\nret = -ENOMEM;\r\ngoto fail_address_parse;\r\n}\r\nptr = strpbrk(tail, ".-_");\r\nif (ptr)\r\n*ptr = '\0';\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "%c_%s_0x%lx", 'p', tail, offset);\r\nevent = buf;\r\nkfree(tail);\r\n}\r\ntu = alloc_trace_uprobe(group, event, argc, is_return);\r\nif (IS_ERR(tu)) {\r\npr_info("Failed to allocate trace_uprobe.(%d)\n", (int)PTR_ERR(tu));\r\nret = PTR_ERR(tu);\r\ngoto fail_address_parse;\r\n}\r\ntu->offset = offset;\r\ntu->inode = inode;\r\ntu->filename = kstrdup(filename, GFP_KERNEL);\r\nif (!tu->filename) {\r\npr_info("Failed to allocate filename.\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = 0;\r\nfor (i = 0; i < argc && i < MAX_TRACE_ARGS; i++) {\r\nstruct probe_arg *parg = &tu->tp.args[i];\r\ntu->tp.nr_args++;\r\narg = strchr(argv[i], '=');\r\nif (arg) {\r\n*arg++ = '\0';\r\nparg->name = kstrdup(argv[i], GFP_KERNEL);\r\n} else {\r\narg = argv[i];\r\nsnprintf(buf, MAX_EVENT_NAME_LEN, "arg%d", i + 1);\r\nparg->name = kstrdup(buf, GFP_KERNEL);\r\n}\r\nif (!parg->name) {\r\npr_info("Failed to allocate argument[%d] name.\n", i);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (!is_good_name(parg->name)) {\r\npr_info("Invalid argument[%d] name: %s\n", i, parg->name);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (traceprobe_conflict_field_name(parg->name, tu->tp.args, i)) {\r\npr_info("Argument[%d] name '%s' conflicts with "\r\n"another field.\n", i, argv[i]);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = traceprobe_parse_probe_arg(arg, &tu->tp.size, parg,\r\nis_return, false);\r\nif (ret) {\r\npr_info("Parse error at argument[%d]. (%d)\n", i, ret);\r\ngoto error;\r\n}\r\n}\r\nret = register_trace_uprobe(tu);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nfree_trace_uprobe(tu);\r\nreturn ret;\r\nfail_address_parse:\r\nif (inode)\r\niput(inode);\r\npr_info("Failed to parse address or file.\n");\r\nreturn ret;\r\n}\r\nstatic int cleanup_all_probes(void)\r\n{\r\nstruct trace_uprobe *tu;\r\nint ret = 0;\r\nmutex_lock(&uprobe_lock);\r\nwhile (!list_empty(&uprobe_list)) {\r\ntu = list_entry(uprobe_list.next, struct trace_uprobe, list);\r\nret = unregister_trace_uprobe(tu);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(&uprobe_lock);\r\nreturn ret;\r\n}\r\nstatic void *probes_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nmutex_lock(&uprobe_lock);\r\nreturn seq_list_start(&uprobe_list, *pos);\r\n}\r\nstatic void *probes_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &uprobe_list, pos);\r\n}\r\nstatic void probes_seq_stop(struct seq_file *m, void *v)\r\n{\r\nmutex_unlock(&uprobe_lock);\r\n}\r\nstatic int probes_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_uprobe *tu = v;\r\nchar c = is_ret_probe(tu) ? 'r' : 'p';\r\nint i;\r\nseq_printf(m, "%c:%s/%s", c, tu->tp.call.class->system,\r\nftrace_event_name(&tu->tp.call));\r\nseq_printf(m, " %s:0x%p", tu->filename, (void *)tu->offset);\r\nfor (i = 0; i < tu->tp.nr_args; i++)\r\nseq_printf(m, " %s=%s", tu->tp.args[i].name, tu->tp.args[i].comm);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int probes_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\r\nret = cleanup_all_probes();\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn seq_open(file, &probes_seq_op);\r\n}\r\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn traceprobe_probes_write(file, buffer, count, ppos, create_trace_uprobe);\r\n}\r\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_uprobe *tu = v;\r\nseq_printf(m, " %s %-44s %15lu\n", tu->filename,\r\nftrace_event_name(&tu->tp.call), tu->nhit);\r\nreturn 0;\r\n}\r\nstatic int profile_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &profile_seq_op);\r\n}\r\nstatic int uprobe_buffer_init(void)\r\n{\r\nint cpu, err_cpu;\r\nuprobe_cpu_buffer = alloc_percpu(struct uprobe_cpu_buffer);\r\nif (uprobe_cpu_buffer == NULL)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(cpu) {\r\nstruct page *p = alloc_pages_node(cpu_to_node(cpu),\r\nGFP_KERNEL, 0);\r\nif (p == NULL) {\r\nerr_cpu = cpu;\r\ngoto err;\r\n}\r\nper_cpu_ptr(uprobe_cpu_buffer, cpu)->buf = page_address(p);\r\nmutex_init(&per_cpu_ptr(uprobe_cpu_buffer, cpu)->mutex);\r\n}\r\nreturn 0;\r\nerr:\r\nfor_each_possible_cpu(cpu) {\r\nif (cpu == err_cpu)\r\nbreak;\r\nfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer, cpu)->buf);\r\n}\r\nfree_percpu(uprobe_cpu_buffer);\r\nreturn -ENOMEM;\r\n}\r\nstatic int uprobe_buffer_enable(void)\r\n{\r\nint ret = 0;\r\nBUG_ON(!mutex_is_locked(&event_mutex));\r\nif (uprobe_buffer_refcnt++ == 0) {\r\nret = uprobe_buffer_init();\r\nif (ret < 0)\r\nuprobe_buffer_refcnt--;\r\n}\r\nreturn ret;\r\n}\r\nstatic void uprobe_buffer_disable(void)\r\n{\r\nint cpu;\r\nBUG_ON(!mutex_is_locked(&event_mutex));\r\nif (--uprobe_buffer_refcnt == 0) {\r\nfor_each_possible_cpu(cpu)\r\nfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\r\ncpu)->buf);\r\nfree_percpu(uprobe_cpu_buffer);\r\nuprobe_cpu_buffer = NULL;\r\n}\r\n}\r\nstatic struct uprobe_cpu_buffer *uprobe_buffer_get(void)\r\n{\r\nstruct uprobe_cpu_buffer *ucb;\r\nint cpu;\r\ncpu = raw_smp_processor_id();\r\nucb = per_cpu_ptr(uprobe_cpu_buffer, cpu);\r\nmutex_lock(&ucb->mutex);\r\nreturn ucb;\r\n}\r\nstatic void uprobe_buffer_put(struct uprobe_cpu_buffer *ucb)\r\n{\r\nmutex_unlock(&ucb->mutex);\r\n}\r\nstatic void __uprobe_trace_func(struct trace_uprobe *tu,\r\nunsigned long func, struct pt_regs *regs,\r\nstruct uprobe_cpu_buffer *ucb, int dsize,\r\nstruct ftrace_event_file *ftrace_file)\r\n{\r\nstruct uprobe_trace_entry_head *entry;\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nvoid *data;\r\nint size, esize;\r\nstruct ftrace_event_call *call = &tu->tp.call;\r\nWARN_ON(call != ftrace_file->event_call);\r\nif (WARN_ON_ONCE(tu->tp.size + dsize > PAGE_SIZE))\r\nreturn;\r\nif (ftrace_trigger_soft_disabled(ftrace_file))\r\nreturn;\r\nesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\r\nsize = esize + tu->tp.size + dsize;\r\nevent = trace_event_buffer_lock_reserve(&buffer, ftrace_file,\r\ncall->event.type, size, 0, 0);\r\nif (!event)\r\nreturn;\r\nentry = ring_buffer_event_data(event);\r\nif (is_ret_probe(tu)) {\r\nentry->vaddr[0] = func;\r\nentry->vaddr[1] = instruction_pointer(regs);\r\ndata = DATAOF_TRACE_ENTRY(entry, true);\r\n} else {\r\nentry->vaddr[0] = instruction_pointer(regs);\r\ndata = DATAOF_TRACE_ENTRY(entry, false);\r\n}\r\nmemcpy(data, ucb->buf, tu->tp.size + dsize);\r\nevent_trigger_unlock_commit(ftrace_file, buffer, event, entry, 0, 0);\r\n}\r\nstatic int uprobe_trace_func(struct trace_uprobe *tu, struct pt_regs *regs,\r\nstruct uprobe_cpu_buffer *ucb, int dsize)\r\n{\r\nstruct event_file_link *link;\r\nif (is_ret_probe(tu))\r\nreturn 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(link, &tu->tp.files, list)\r\n__uprobe_trace_func(tu, 0, regs, ucb, dsize, link->file);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic void uretprobe_trace_func(struct trace_uprobe *tu, unsigned long func,\r\nstruct pt_regs *regs,\r\nstruct uprobe_cpu_buffer *ucb, int dsize)\r\n{\r\nstruct event_file_link *link;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(link, &tu->tp.files, list)\r\n__uprobe_trace_func(tu, func, regs, ucb, dsize, link->file);\r\nrcu_read_unlock();\r\n}\r\nstatic enum print_line_t\r\nprint_uprobe_event(struct trace_iterator *iter, int flags, struct trace_event *event)\r\n{\r\nstruct uprobe_trace_entry_head *entry;\r\nstruct trace_seq *s = &iter->seq;\r\nstruct trace_uprobe *tu;\r\nu8 *data;\r\nint i;\r\nentry = (struct uprobe_trace_entry_head *)iter->ent;\r\ntu = container_of(event, struct trace_uprobe, tp.call.event);\r\nif (is_ret_probe(tu)) {\r\nif (!trace_seq_printf(s, "%s: (0x%lx <- 0x%lx)",\r\nftrace_event_name(&tu->tp.call),\r\nentry->vaddr[1], entry->vaddr[0]))\r\ngoto partial;\r\ndata = DATAOF_TRACE_ENTRY(entry, true);\r\n} else {\r\nif (!trace_seq_printf(s, "%s: (0x%lx)",\r\nftrace_event_name(&tu->tp.call),\r\nentry->vaddr[0]))\r\ngoto partial;\r\ndata = DATAOF_TRACE_ENTRY(entry, false);\r\n}\r\nfor (i = 0; i < tu->tp.nr_args; i++) {\r\nstruct probe_arg *parg = &tu->tp.args[i];\r\nif (!parg->type->print(s, parg->name, data + parg->offset, entry))\r\ngoto partial;\r\n}\r\nif (trace_seq_puts(s, "\n"))\r\nreturn TRACE_TYPE_HANDLED;\r\npartial:\r\nreturn TRACE_TYPE_PARTIAL_LINE;\r\n}\r\nstatic int\r\nprobe_event_enable(struct trace_uprobe *tu, struct ftrace_event_file *file,\r\nfilter_func_t filter)\r\n{\r\nbool enabled = trace_probe_is_enabled(&tu->tp);\r\nstruct event_file_link *link = NULL;\r\nint ret;\r\nif (file) {\r\nif (tu->tp.flags & TP_FLAG_PROFILE)\r\nreturn -EINTR;\r\nlink = kmalloc(sizeof(*link), GFP_KERNEL);\r\nif (!link)\r\nreturn -ENOMEM;\r\nlink->file = file;\r\nlist_add_tail_rcu(&link->list, &tu->tp.files);\r\ntu->tp.flags |= TP_FLAG_TRACE;\r\n} else {\r\nif (tu->tp.flags & TP_FLAG_TRACE)\r\nreturn -EINTR;\r\ntu->tp.flags |= TP_FLAG_PROFILE;\r\n}\r\nWARN_ON(!uprobe_filter_is_empty(&tu->filter));\r\nif (enabled)\r\nreturn 0;\r\nret = uprobe_buffer_enable();\r\nif (ret)\r\ngoto err_flags;\r\ntu->consumer.filter = filter;\r\nret = uprobe_register(tu->inode, tu->offset, &tu->consumer);\r\nif (ret)\r\ngoto err_buffer;\r\nreturn 0;\r\nerr_buffer:\r\nuprobe_buffer_disable();\r\nerr_flags:\r\nif (file) {\r\nlist_del(&link->list);\r\nkfree(link);\r\ntu->tp.flags &= ~TP_FLAG_TRACE;\r\n} else {\r\ntu->tp.flags &= ~TP_FLAG_PROFILE;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nprobe_event_disable(struct trace_uprobe *tu, struct ftrace_event_file *file)\r\n{\r\nif (!trace_probe_is_enabled(&tu->tp))\r\nreturn;\r\nif (file) {\r\nstruct event_file_link *link;\r\nlink = find_event_file_link(&tu->tp, file);\r\nif (!link)\r\nreturn;\r\nlist_del_rcu(&link->list);\r\nsynchronize_sched();\r\nkfree(link);\r\nif (!list_empty(&tu->tp.files))\r\nreturn;\r\n}\r\nWARN_ON(!uprobe_filter_is_empty(&tu->filter));\r\nuprobe_unregister(tu->inode, tu->offset, &tu->consumer);\r\ntu->tp.flags &= file ? ~TP_FLAG_TRACE : ~TP_FLAG_PROFILE;\r\nuprobe_buffer_disable();\r\n}\r\nstatic int uprobe_event_define_fields(struct ftrace_event_call *event_call)\r\n{\r\nint ret, i, size;\r\nstruct uprobe_trace_entry_head field;\r\nstruct trace_uprobe *tu = event_call->data;\r\nif (is_ret_probe(tu)) {\r\nDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_FUNC, 0);\r\nDEFINE_FIELD(unsigned long, vaddr[1], FIELD_STRING_RETIP, 0);\r\nsize = SIZEOF_TRACE_ENTRY(true);\r\n} else {\r\nDEFINE_FIELD(unsigned long, vaddr[0], FIELD_STRING_IP, 0);\r\nsize = SIZEOF_TRACE_ENTRY(false);\r\n}\r\nfor (i = 0; i < tu->tp.nr_args; i++) {\r\nstruct probe_arg *parg = &tu->tp.args[i];\r\nret = trace_define_field(event_call, parg->type->fmttype,\r\nparg->name, size + parg->offset,\r\nparg->type->size, parg->type->is_signed,\r\nFILTER_OTHER);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool\r\n__uprobe_perf_filter(struct trace_uprobe_filter *filter, struct mm_struct *mm)\r\n{\r\nstruct perf_event *event;\r\nif (filter->nr_systemwide)\r\nreturn true;\r\nlist_for_each_entry(event, &filter->perf_events, hw.tp_list) {\r\nif (event->hw.tp_target->mm == mm)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline bool\r\nuprobe_filter_event(struct trace_uprobe *tu, struct perf_event *event)\r\n{\r\nreturn __uprobe_perf_filter(&tu->filter, event->hw.tp_target->mm);\r\n}\r\nstatic int uprobe_perf_close(struct trace_uprobe *tu, struct perf_event *event)\r\n{\r\nbool done;\r\nwrite_lock(&tu->filter.rwlock);\r\nif (event->hw.tp_target) {\r\nlist_del(&event->hw.tp_list);\r\ndone = tu->filter.nr_systemwide ||\r\n(event->hw.tp_target->flags & PF_EXITING) ||\r\nuprobe_filter_event(tu, event);\r\n} else {\r\ntu->filter.nr_systemwide--;\r\ndone = tu->filter.nr_systemwide;\r\n}\r\nwrite_unlock(&tu->filter.rwlock);\r\nif (!done)\r\nreturn uprobe_apply(tu->inode, tu->offset, &tu->consumer, false);\r\nreturn 0;\r\n}\r\nstatic int uprobe_perf_open(struct trace_uprobe *tu, struct perf_event *event)\r\n{\r\nbool done;\r\nint err;\r\nwrite_lock(&tu->filter.rwlock);\r\nif (event->hw.tp_target) {\r\ndone = tu->filter.nr_systemwide ||\r\nevent->parent || event->attr.enable_on_exec ||\r\nuprobe_filter_event(tu, event);\r\nlist_add(&event->hw.tp_list, &tu->filter.perf_events);\r\n} else {\r\ndone = tu->filter.nr_systemwide;\r\ntu->filter.nr_systemwide++;\r\n}\r\nwrite_unlock(&tu->filter.rwlock);\r\nerr = 0;\r\nif (!done) {\r\nerr = uprobe_apply(tu->inode, tu->offset, &tu->consumer, true);\r\nif (err)\r\nuprobe_perf_close(tu, event);\r\n}\r\nreturn err;\r\n}\r\nstatic bool uprobe_perf_filter(struct uprobe_consumer *uc,\r\nenum uprobe_filter_ctx ctx, struct mm_struct *mm)\r\n{\r\nstruct trace_uprobe *tu;\r\nint ret;\r\ntu = container_of(uc, struct trace_uprobe, consumer);\r\nread_lock(&tu->filter.rwlock);\r\nret = __uprobe_perf_filter(&tu->filter, mm);\r\nread_unlock(&tu->filter.rwlock);\r\nreturn ret;\r\n}\r\nstatic void __uprobe_perf_func(struct trace_uprobe *tu,\r\nunsigned long func, struct pt_regs *regs,\r\nstruct uprobe_cpu_buffer *ucb, int dsize)\r\n{\r\nstruct ftrace_event_call *call = &tu->tp.call;\r\nstruct uprobe_trace_entry_head *entry;\r\nstruct hlist_head *head;\r\nvoid *data;\r\nint size, esize;\r\nint rctx;\r\nesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\r\nsize = esize + tu->tp.size + dsize;\r\nsize = ALIGN(size + sizeof(u32), sizeof(u64)) - sizeof(u32);\r\nif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE, "profile buffer not large enough"))\r\nreturn;\r\npreempt_disable();\r\nhead = this_cpu_ptr(call->perf_events);\r\nif (hlist_empty(head))\r\ngoto out;\r\nentry = perf_trace_buf_prepare(size, call->event.type, regs, &rctx);\r\nif (!entry)\r\ngoto out;\r\nif (is_ret_probe(tu)) {\r\nentry->vaddr[0] = func;\r\nentry->vaddr[1] = instruction_pointer(regs);\r\ndata = DATAOF_TRACE_ENTRY(entry, true);\r\n} else {\r\nentry->vaddr[0] = instruction_pointer(regs);\r\ndata = DATAOF_TRACE_ENTRY(entry, false);\r\n}\r\nmemcpy(data, ucb->buf, tu->tp.size + dsize);\r\nif (size - esize > tu->tp.size + dsize) {\r\nint len = tu->tp.size + dsize;\r\nmemset(data + len, 0, size - esize - len);\r\n}\r\nperf_trace_buf_submit(entry, size, rctx, 0, 1, regs, head, NULL);\r\nout:\r\npreempt_enable();\r\n}\r\nstatic int uprobe_perf_func(struct trace_uprobe *tu, struct pt_regs *regs,\r\nstruct uprobe_cpu_buffer *ucb, int dsize)\r\n{\r\nif (!uprobe_perf_filter(&tu->consumer, 0, current->mm))\r\nreturn UPROBE_HANDLER_REMOVE;\r\nif (!is_ret_probe(tu))\r\n__uprobe_perf_func(tu, 0, regs, ucb, dsize);\r\nreturn 0;\r\n}\r\nstatic void uretprobe_perf_func(struct trace_uprobe *tu, unsigned long func,\r\nstruct pt_regs *regs,\r\nstruct uprobe_cpu_buffer *ucb, int dsize)\r\n{\r\n__uprobe_perf_func(tu, func, regs, ucb, dsize);\r\n}\r\nstatic int\r\ntrace_uprobe_register(struct ftrace_event_call *event, enum trace_reg type,\r\nvoid *data)\r\n{\r\nstruct trace_uprobe *tu = event->data;\r\nstruct ftrace_event_file *file = data;\r\nswitch (type) {\r\ncase TRACE_REG_REGISTER:\r\nreturn probe_event_enable(tu, file, NULL);\r\ncase TRACE_REG_UNREGISTER:\r\nprobe_event_disable(tu, file);\r\nreturn 0;\r\n#ifdef CONFIG_PERF_EVENTS\r\ncase TRACE_REG_PERF_REGISTER:\r\nreturn probe_event_enable(tu, NULL, uprobe_perf_filter);\r\ncase TRACE_REG_PERF_UNREGISTER:\r\nprobe_event_disable(tu, NULL);\r\nreturn 0;\r\ncase TRACE_REG_PERF_OPEN:\r\nreturn uprobe_perf_open(tu, data);\r\ncase TRACE_REG_PERF_CLOSE:\r\nreturn uprobe_perf_close(tu, data);\r\n#endif\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uprobe_dispatcher(struct uprobe_consumer *con, struct pt_regs *regs)\r\n{\r\nstruct trace_uprobe *tu;\r\nstruct uprobe_dispatch_data udd;\r\nstruct uprobe_cpu_buffer *ucb;\r\nint dsize, esize;\r\nint ret = 0;\r\ntu = container_of(con, struct trace_uprobe, consumer);\r\ntu->nhit++;\r\nudd.tu = tu;\r\nudd.bp_addr = instruction_pointer(regs);\r\ncurrent->utask->vaddr = (unsigned long) &udd;\r\nif (WARN_ON_ONCE(!uprobe_cpu_buffer))\r\nreturn 0;\r\ndsize = __get_data_size(&tu->tp, regs);\r\nesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\r\nucb = uprobe_buffer_get();\r\nstore_trace_args(esize, &tu->tp, regs, ucb->buf, dsize);\r\nif (tu->tp.flags & TP_FLAG_TRACE)\r\nret |= uprobe_trace_func(tu, regs, ucb, dsize);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tu->tp.flags & TP_FLAG_PROFILE)\r\nret |= uprobe_perf_func(tu, regs, ucb, dsize);\r\n#endif\r\nuprobe_buffer_put(ucb);\r\nreturn ret;\r\n}\r\nstatic int uretprobe_dispatcher(struct uprobe_consumer *con,\r\nunsigned long func, struct pt_regs *regs)\r\n{\r\nstruct trace_uprobe *tu;\r\nstruct uprobe_dispatch_data udd;\r\nstruct uprobe_cpu_buffer *ucb;\r\nint dsize, esize;\r\ntu = container_of(con, struct trace_uprobe, consumer);\r\nudd.tu = tu;\r\nudd.bp_addr = func;\r\ncurrent->utask->vaddr = (unsigned long) &udd;\r\nif (WARN_ON_ONCE(!uprobe_cpu_buffer))\r\nreturn 0;\r\ndsize = __get_data_size(&tu->tp, regs);\r\nesize = SIZEOF_TRACE_ENTRY(is_ret_probe(tu));\r\nucb = uprobe_buffer_get();\r\nstore_trace_args(esize, &tu->tp, regs, ucb->buf, dsize);\r\nif (tu->tp.flags & TP_FLAG_TRACE)\r\nuretprobe_trace_func(tu, func, regs, ucb, dsize);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (tu->tp.flags & TP_FLAG_PROFILE)\r\nuretprobe_perf_func(tu, func, regs, ucb, dsize);\r\n#endif\r\nuprobe_buffer_put(ucb);\r\nreturn 0;\r\n}\r\nstatic int register_uprobe_event(struct trace_uprobe *tu)\r\n{\r\nstruct ftrace_event_call *call = &tu->tp.call;\r\nint ret;\r\nINIT_LIST_HEAD(&call->class->fields);\r\ncall->event.funcs = &uprobe_funcs;\r\ncall->class->define_fields = uprobe_event_define_fields;\r\nif (set_print_fmt(&tu->tp, is_ret_probe(tu)) < 0)\r\nreturn -ENOMEM;\r\nret = register_ftrace_event(&call->event);\r\nif (!ret) {\r\nkfree(call->print_fmt);\r\nreturn -ENODEV;\r\n}\r\ncall->class->reg = trace_uprobe_register;\r\ncall->data = tu;\r\nret = trace_add_event_call(call);\r\nif (ret) {\r\npr_info("Failed to register uprobe event: %s\n",\r\nftrace_event_name(call));\r\nkfree(call->print_fmt);\r\nunregister_ftrace_event(&call->event);\r\n}\r\nreturn ret;\r\n}\r\nstatic int unregister_uprobe_event(struct trace_uprobe *tu)\r\n{\r\nint ret;\r\nret = trace_remove_event_call(&tu->tp.call);\r\nif (ret)\r\nreturn ret;\r\nkfree(tu->tp.call.print_fmt);\r\ntu->tp.call.print_fmt = NULL;\r\nreturn 0;\r\n}\r\nstatic __init int init_uprobe_trace(void)\r\n{\r\nstruct dentry *d_tracer;\r\nd_tracer = tracing_init_dentry();\r\nif (!d_tracer)\r\nreturn 0;\r\ntrace_create_file("uprobe_events", 0644, d_tracer,\r\nNULL, &uprobe_events_ops);\r\ntrace_create_file("uprobe_profile", 0444, d_tracer,\r\nNULL, &uprobe_profile_ops);\r\nreturn 0;\r\n}
