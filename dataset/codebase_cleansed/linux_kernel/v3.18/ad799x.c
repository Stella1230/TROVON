static int ad799x_write_config(struct ad799x_state *st, u16 val)\r\n{\r\nswitch (st->id) {\r\ncase ad7997:\r\ncase ad7998:\r\nreturn i2c_smbus_write_word_swapped(st->client, AD7998_CONF_REG,\r\nval);\r\ndefault:\r\nreturn i2c_smbus_write_byte_data(st->client, AD7998_CONF_REG,\r\nval);\r\n}\r\n}\r\nstatic int ad799x_read_config(struct ad799x_state *st)\r\n{\r\nswitch (st->id) {\r\ncase ad7997:\r\ncase ad7998:\r\nreturn i2c_smbus_read_word_swapped(st->client, AD7998_CONF_REG);\r\ndefault:\r\nreturn i2c_smbus_read_byte_data(st->client, AD7998_CONF_REG);\r\n}\r\n}\r\nstatic irqreturn_t ad799x_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nint b_sent;\r\nu8 cmd;\r\nswitch (st->id) {\r\ncase ad7991:\r\ncase ad7995:\r\ncase ad7999:\r\ncmd = st->config |\r\n(*indio_dev->active_scan_mask << AD799X_CHANNEL_SHIFT);\r\nbreak;\r\ncase ad7992:\r\ncase ad7993:\r\ncase ad7994:\r\ncmd = (*indio_dev->active_scan_mask << AD799X_CHANNEL_SHIFT) |\r\nAD7998_CONV_RES_REG;\r\nbreak;\r\ncase ad7997:\r\ncase ad7998:\r\ncmd = AD7997_8_READ_SEQUENCE | AD7998_CONV_RES_REG;\r\nbreak;\r\ndefault:\r\ncmd = 0;\r\n}\r\nb_sent = i2c_smbus_read_i2c_block_data(st->client,\r\ncmd, st->transfer_size, st->rx_buf);\r\nif (b_sent < 0)\r\ngoto out;\r\niio_push_to_buffers_with_timestamp(indio_dev, st->rx_buf,\r\niio_get_time_ns());\r\nout:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ad799x_update_scan_mode(struct iio_dev *indio_dev,\r\nconst unsigned long *scan_mask)\r\n{\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nkfree(st->rx_buf);\r\nst->rx_buf = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);\r\nif (!st->rx_buf)\r\nreturn -ENOMEM;\r\nst->transfer_size = bitmap_weight(scan_mask, indio_dev->masklength) * 2;\r\nswitch (st->id) {\r\ncase ad7992:\r\ncase ad7993:\r\ncase ad7994:\r\ncase ad7997:\r\ncase ad7998:\r\nst->config &= ~(GENMASK(7, 0) << AD799X_CHANNEL_SHIFT);\r\nst->config |= (*scan_mask << AD799X_CHANNEL_SHIFT);\r\nreturn ad799x_write_config(st, st->config);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int ad799x_scan_direct(struct ad799x_state *st, unsigned ch)\r\n{\r\nu8 cmd;\r\nswitch (st->id) {\r\ncase ad7991:\r\ncase ad7995:\r\ncase ad7999:\r\ncmd = st->config | (BIT(ch) << AD799X_CHANNEL_SHIFT);\r\nbreak;\r\ncase ad7992:\r\ncase ad7993:\r\ncase ad7994:\r\ncmd = BIT(ch) << AD799X_CHANNEL_SHIFT;\r\nbreak;\r\ncase ad7997:\r\ncase ad7998:\r\ncmd = (ch << AD799X_CHANNEL_SHIFT) | AD7997_8_READ_SINGLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn i2c_smbus_read_word_swapped(st->client, cmd);\r\n}\r\nstatic int ad799x_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nint ret;\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&indio_dev->mlock);\r\nif (iio_buffer_enabled(indio_dev))\r\nret = -EBUSY;\r\nelse\r\nret = ad799x_scan_direct(st, chan->scan_index);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (ret >> chan->scan_type.shift) &\r\nGENMASK(chan->scan_type.realbits - 1, 0);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = regulator_get_voltage(st->vref);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret / 1000;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ad799x_read_frequency(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nint ret = i2c_smbus_read_byte_data(st->client, AD7998_CYCLE_TMR_REG);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%u\n", ad7998_frequencies[ret & AD7998_CYC_MASK]);\r\n}\r\nstatic ssize_t ad799x_write_frequency(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nlong val;\r\nint ret, i;\r\nret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&indio_dev->mlock);\r\nret = i2c_smbus_read_byte_data(st->client, AD7998_CYCLE_TMR_REG);\r\nif (ret < 0)\r\ngoto error_ret_mutex;\r\nret &= ~AD7998_CYC_MASK;\r\nfor (i = 0; i < ARRAY_SIZE(ad7998_frequencies); i++)\r\nif (val == ad7998_frequencies[i])\r\nbreak;\r\nif (i == ARRAY_SIZE(ad7998_frequencies)) {\r\nret = -EINVAL;\r\ngoto error_ret_mutex;\r\n}\r\nret = i2c_smbus_write_byte_data(st->client, AD7998_CYCLE_TMR_REG,\r\nret | i);\r\nif (ret < 0)\r\ngoto error_ret_mutex;\r\nret = len;\r\nerror_ret_mutex:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad799x_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nif (!(st->config & AD7998_ALERT_EN))\r\nreturn 0;\r\nif ((st->config >> AD799X_CHANNEL_SHIFT) & BIT(chan->scan_index))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ad799x_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint state)\r\n{\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nif (iio_buffer_enabled(indio_dev)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nif (state)\r\nst->config |= BIT(chan->scan_index) << AD799X_CHANNEL_SHIFT;\r\nelse\r\nst->config &= ~(BIT(chan->scan_index) << AD799X_CHANNEL_SHIFT);\r\nif (st->config >> AD799X_CHANNEL_SHIFT)\r\nst->config |= AD7998_ALERT_EN;\r\nelse\r\nst->config &= ~AD7998_ALERT_EN;\r\nret = ad799x_write_config(st, st->config);\r\ndone:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic unsigned int ad799x_threshold_reg(const struct iio_chan_spec *chan,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info)\r\n{\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\nif (dir == IIO_EV_DIR_FALLING)\r\nreturn AD7998_DATALOW_REG(chan->channel);\r\nelse\r\nreturn AD7998_DATAHIGH_REG(chan->channel);\r\ncase IIO_EV_INFO_HYSTERESIS:\r\nreturn AD7998_HYST_REG(chan->channel);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad799x_write_event_value(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nint ret;\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nif (val < 0 || val > GENMASK(chan->scan_type.realbits - 1, 0))\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nret = i2c_smbus_write_word_swapped(st->client,\r\nad799x_threshold_reg(chan, dir, info),\r\nval << chan->scan_type.shift);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad799x_read_event_value(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nint ret;\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\nmutex_lock(&indio_dev->mlock);\r\nret = i2c_smbus_read_word_swapped(st->client,\r\nad799x_threshold_reg(chan, dir, info));\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (ret >> chan->scan_type.shift) &\r\nGENMASK(chan->scan_type.realbits - 1 , 0);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic irqreturn_t ad799x_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct ad799x_state *st = iio_priv(private);\r\nint i, ret;\r\nret = i2c_smbus_read_byte_data(st->client, AD7998_ALERT_STAT_REG);\r\nif (ret <= 0)\r\ngoto done;\r\nif (i2c_smbus_write_byte_data(st->client, AD7998_ALERT_STAT_REG,\r\nAD7998_ALERT_STAT_CLEAR) < 0)\r\ngoto done;\r\nfor (i = 0; i < 8; i++) {\r\nif (ret & BIT(i))\r\niio_push_event(indio_dev,\r\ni & 0x1 ?\r\nIIO_UNMOD_EVENT_CODE(IIO_VOLTAGE,\r\n(i >> 1),\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING) :\r\nIIO_UNMOD_EVENT_CODE(IIO_VOLTAGE,\r\n(i >> 1),\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\niio_get_time_ns());\r\n}\r\ndone:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ad799x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct ad799x_state *st;\r\nstruct iio_dev *indio_dev;\r\nconst struct ad799x_chip_info *chip_info =\r\n&ad799x_chip_info_tbl[id->driver_data];\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nst->id = id->driver_data;\r\nif (client->irq > 0 && chip_info->irq_config.info)\r\nst->chip_config = &chip_info->irq_config;\r\nelse\r\nst->chip_config = &chip_info->noirq_config;\r\nst->reg = devm_regulator_get(&client->dev, "vcc");\r\nif (IS_ERR(st->reg))\r\nreturn PTR_ERR(st->reg);\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\nreturn ret;\r\nst->vref = devm_regulator_get(&client->dev, "vref");\r\nif (IS_ERR(st->vref)) {\r\nret = PTR_ERR(st->vref);\r\ngoto error_disable_reg;\r\n}\r\nret = regulator_enable(st->vref);\r\nif (ret)\r\ngoto error_disable_reg;\r\nst->client = client;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->name = id->name;\r\nindio_dev->info = st->chip_config->info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = st->chip_config->channel;\r\nindio_dev->num_channels = chip_info->num_channels;\r\nret = ad799x_write_config(st, st->chip_config->default_config);\r\nif (ret < 0)\r\ngoto error_disable_reg;\r\nret = ad799x_read_config(st);\r\nif (ret < 0)\r\ngoto error_disable_reg;\r\nst->config = ret;\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\n&ad799x_trigger_handler, NULL);\r\nif (ret)\r\ngoto error_disable_vref;\r\nif (client->irq > 0) {\r\nret = devm_request_threaded_irq(&client->dev,\r\nclient->irq,\r\nNULL,\r\nad799x_event_handler,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\nclient->name,\r\nindio_dev);\r\nif (ret)\r\ngoto error_cleanup_ring;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_cleanup_ring;\r\nreturn 0;\r\nerror_cleanup_ring:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerror_disable_vref:\r\nregulator_disable(st->vref);\r\nerror_disable_reg:\r\nregulator_disable(st->reg);\r\nreturn ret;\r\n}\r\nstatic int ad799x_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ad799x_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nregulator_disable(st->vref);\r\nregulator_disable(st->reg);\r\nkfree(st->rx_buf);\r\nreturn 0;\r\n}
