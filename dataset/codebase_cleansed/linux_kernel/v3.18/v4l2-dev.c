static ssize_t index_show(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nreturn sprintf(buf, "%i\n", vdev->index);\r\n}\r\nstatic ssize_t debug_show(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nreturn sprintf(buf, "%i\n", vdev->debug);\r\n}\r\nstatic ssize_t debug_store(struct device *cd, struct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nint res = 0;\r\nu16 value;\r\nres = kstrtou16(buf, 0, &value);\r\nif (res)\r\nreturn res;\r\nvdev->debug = value;\r\nreturn len;\r\n}\r\nstatic ssize_t name_show(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nreturn sprintf(buf, "%.*s\n", (int)sizeof(vdev->name), vdev->name);\r\n}\r\nstatic inline unsigned long *devnode_bits(int vfl_type)\r\n{\r\nint idx = (vfl_type > VFL_TYPE_RADIO) ? VFL_TYPE_MAX - 1 : vfl_type;\r\nreturn devnode_nums[idx];\r\n}\r\nstatic inline unsigned long *devnode_bits(int vfl_type)\r\n{\r\nreturn devnode_nums[vfl_type];\r\n}\r\nstatic inline void devnode_set(struct video_device *vdev)\r\n{\r\nset_bit(vdev->num, devnode_bits(vdev->vfl_type));\r\n}\r\nstatic inline void devnode_clear(struct video_device *vdev)\r\n{\r\nclear_bit(vdev->num, devnode_bits(vdev->vfl_type));\r\n}\r\nstatic inline int devnode_find(struct video_device *vdev, int from, int to)\r\n{\r\nreturn find_next_zero_bit(devnode_bits(vdev->vfl_type), to, from);\r\n}\r\nstruct video_device *video_device_alloc(void)\r\n{\r\nreturn kzalloc(sizeof(struct video_device), GFP_KERNEL);\r\n}\r\nvoid video_device_release(struct video_device *vdev)\r\n{\r\nkfree(vdev);\r\n}\r\nvoid video_device_release_empty(struct video_device *vdev)\r\n{\r\n}\r\nstatic inline void video_get(struct video_device *vdev)\r\n{\r\nget_device(&vdev->dev);\r\n}\r\nstatic inline void video_put(struct video_device *vdev)\r\n{\r\nput_device(&vdev->dev);\r\n}\r\nstatic void v4l2_device_release(struct device *cd)\r\n{\r\nstruct video_device *vdev = to_video_device(cd);\r\nstruct v4l2_device *v4l2_dev = vdev->v4l2_dev;\r\nmutex_lock(&videodev_lock);\r\nif (WARN_ON(video_device[vdev->minor] != vdev)) {\r\nmutex_unlock(&videodev_lock);\r\nreturn;\r\n}\r\nvideo_device[vdev->minor] = NULL;\r\ncdev_del(vdev->cdev);\r\nvdev->cdev = NULL;\r\ndevnode_clear(vdev);\r\nmutex_unlock(&videodev_lock);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (v4l2_dev && v4l2_dev->mdev &&\r\nvdev->vfl_type != VFL_TYPE_SUBDEV)\r\nmedia_device_unregister_entity(&vdev->entity);\r\n#endif\r\nif (v4l2_dev && v4l2_dev->release == NULL)\r\nv4l2_dev = NULL;\r\nvdev->release(vdev);\r\nif (v4l2_dev)\r\nv4l2_device_put(v4l2_dev);\r\n}\r\nstruct video_device *video_devdata(struct file *file)\r\n{\r\nreturn video_device[iminor(file_inode(file))];\r\n}\r\nstatic inline bool prio_is_valid(enum v4l2_priority prio)\r\n{\r\nreturn prio == V4L2_PRIORITY_BACKGROUND ||\r\nprio == V4L2_PRIORITY_INTERACTIVE ||\r\nprio == V4L2_PRIORITY_RECORD;\r\n}\r\nvoid v4l2_prio_init(struct v4l2_prio_state *global)\r\n{\r\nmemset(global, 0, sizeof(*global));\r\n}\r\nint v4l2_prio_change(struct v4l2_prio_state *global, enum v4l2_priority *local,\r\nenum v4l2_priority new)\r\n{\r\nif (!prio_is_valid(new))\r\nreturn -EINVAL;\r\nif (*local == new)\r\nreturn 0;\r\natomic_inc(&global->prios[new]);\r\nif (prio_is_valid(*local))\r\natomic_dec(&global->prios[*local]);\r\n*local = new;\r\nreturn 0;\r\n}\r\nvoid v4l2_prio_open(struct v4l2_prio_state *global, enum v4l2_priority *local)\r\n{\r\nv4l2_prio_change(global, local, V4L2_PRIORITY_DEFAULT);\r\n}\r\nvoid v4l2_prio_close(struct v4l2_prio_state *global, enum v4l2_priority local)\r\n{\r\nif (prio_is_valid(local))\r\natomic_dec(&global->prios[local]);\r\n}\r\nenum v4l2_priority v4l2_prio_max(struct v4l2_prio_state *global)\r\n{\r\nif (atomic_read(&global->prios[V4L2_PRIORITY_RECORD]) > 0)\r\nreturn V4L2_PRIORITY_RECORD;\r\nif (atomic_read(&global->prios[V4L2_PRIORITY_INTERACTIVE]) > 0)\r\nreturn V4L2_PRIORITY_INTERACTIVE;\r\nif (atomic_read(&global->prios[V4L2_PRIORITY_BACKGROUND]) > 0)\r\nreturn V4L2_PRIORITY_BACKGROUND;\r\nreturn V4L2_PRIORITY_UNSET;\r\n}\r\nint v4l2_prio_check(struct v4l2_prio_state *global, enum v4l2_priority local)\r\n{\r\nreturn (local < v4l2_prio_max(global)) ? -EBUSY : 0;\r\n}\r\nstatic ssize_t v4l2_read(struct file *filp, char __user *buf,\r\nsize_t sz, loff_t *off)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = -ENODEV;\r\nif (!vdev->fops->read)\r\nreturn -EINVAL;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->read(filp, buf, sz, off);\r\nif (vdev->debug)\r\nprintk(KERN_DEBUG "%s: read: %zd (%d)\n",\r\nvideo_device_node_name(vdev), sz, ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t v4l2_write(struct file *filp, const char __user *buf,\r\nsize_t sz, loff_t *off)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = -ENODEV;\r\nif (!vdev->fops->write)\r\nreturn -EINVAL;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->write(filp, buf, sz, off);\r\nif (vdev->debug)\r\nprintk(KERN_DEBUG "%s: write: %zd (%d)\n",\r\nvideo_device_node_name(vdev), sz, ret);\r\nreturn ret;\r\n}\r\nstatic unsigned int v4l2_poll(struct file *filp, struct poll_table_struct *poll)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nunsigned int res = POLLERR | POLLHUP;\r\nif (!vdev->fops->poll)\r\nreturn DEFAULT_POLLMASK;\r\nif (video_is_registered(vdev))\r\nres = vdev->fops->poll(filp, poll);\r\nif (vdev->debug > 2)\r\nprintk(KERN_DEBUG "%s: poll: %08x\n",\r\nvideo_device_node_name(vdev), res);\r\nreturn res;\r\n}\r\nstatic long v4l2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = -ENODEV;\r\nif (vdev->fops->unlocked_ioctl) {\r\nstruct mutex *lock = v4l2_ioctl_get_lock(vdev, cmd);\r\nif (lock && mutex_lock_interruptible(lock))\r\nreturn -ERESTARTSYS;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->unlocked_ioctl(filp, cmd, arg);\r\nif (lock)\r\nmutex_unlock(lock);\r\n} else if (vdev->fops->ioctl) {\r\nstatic DEFINE_MUTEX(v4l2_ioctl_mutex);\r\nstruct mutex *m = vdev->v4l2_dev ?\r\n&vdev->v4l2_dev->ioctl_lock : &v4l2_ioctl_mutex;\r\nif (cmd != VIDIOC_DQBUF && mutex_lock_interruptible(m))\r\nreturn -ERESTARTSYS;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->ioctl(filp, cmd, arg);\r\nif (cmd != VIDIOC_DQBUF)\r\nmutex_unlock(m);\r\n} else\r\nret = -ENOTTY;\r\nreturn ret;\r\n}\r\nstatic unsigned long v4l2_get_unmapped_area(struct file *filp,\r\nunsigned long addr, unsigned long len, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret;\r\nif (!vdev->fops->get_unmapped_area)\r\nreturn -ENOSYS;\r\nif (!video_is_registered(vdev))\r\nreturn -ENODEV;\r\nret = vdev->fops->get_unmapped_area(filp, addr, len, pgoff, flags);\r\nif (vdev->debug)\r\nprintk(KERN_DEBUG "%s: get_unmapped_area (%d)\n",\r\nvideo_device_node_name(vdev), ret);\r\nreturn ret;\r\n}\r\nstatic int v4l2_mmap(struct file *filp, struct vm_area_struct *vm)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = -ENODEV;\r\nif (!vdev->fops->mmap)\r\nreturn -ENODEV;\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->mmap(filp, vm);\r\nif (vdev->debug)\r\nprintk(KERN_DEBUG "%s: mmap (%d)\n",\r\nvideo_device_node_name(vdev), ret);\r\nreturn ret;\r\n}\r\nstatic int v4l2_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct video_device *vdev;\r\nint ret = 0;\r\nmutex_lock(&videodev_lock);\r\nvdev = video_devdata(filp);\r\nif (vdev == NULL || !video_is_registered(vdev)) {\r\nmutex_unlock(&videodev_lock);\r\nreturn -ENODEV;\r\n}\r\nvideo_get(vdev);\r\nmutex_unlock(&videodev_lock);\r\nif (vdev->fops->open) {\r\nif (video_is_registered(vdev))\r\nret = vdev->fops->open(filp);\r\nelse\r\nret = -ENODEV;\r\n}\r\nif (vdev->debug)\r\nprintk(KERN_DEBUG "%s: open (%d)\n",\r\nvideo_device_node_name(vdev), ret);\r\nif (ret)\r\nvideo_put(vdev);\r\nreturn ret;\r\n}\r\nstatic int v4l2_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nint ret = 0;\r\nif (vdev->fops->release)\r\nret = vdev->fops->release(filp);\r\nif (vdev->debug)\r\nprintk(KERN_DEBUG "%s: release\n",\r\nvideo_device_node_name(vdev));\r\nvideo_put(vdev);\r\nreturn ret;\r\n}\r\nstatic int get_index(struct video_device *vdev)\r\n{\r\nstatic DECLARE_BITMAP(used, VIDEO_NUM_DEVICES);\r\nint i;\r\nbitmap_zero(used, VIDEO_NUM_DEVICES);\r\nfor (i = 0; i < VIDEO_NUM_DEVICES; i++) {\r\nif (video_device[i] != NULL &&\r\nvideo_device[i]->v4l2_dev == vdev->v4l2_dev) {\r\nset_bit(video_device[i]->index, used);\r\n}\r\n}\r\nreturn find_first_zero_bit(used, VIDEO_NUM_DEVICES);\r\n}\r\nstatic void determine_valid_ioctls(struct video_device *vdev)\r\n{\r\nDECLARE_BITMAP(valid_ioctls, BASE_VIDIOC_PRIVATE);\r\nconst struct v4l2_ioctl_ops *ops = vdev->ioctl_ops;\r\nbool is_vid = vdev->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_vbi = vdev->vfl_type == VFL_TYPE_VBI;\r\nbool is_radio = vdev->vfl_type == VFL_TYPE_RADIO;\r\nbool is_sdr = vdev->vfl_type == VFL_TYPE_SDR;\r\nbool is_rx = vdev->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vdev->vfl_dir != VFL_DIR_RX;\r\nbitmap_zero(valid_ioctls, BASE_VIDIOC_PRIVATE);\r\nSET_VALID_IOCTL(ops, VIDIOC_QUERYCAP, vidioc_querycap);\r\nif (ops->vidioc_g_priority)\r\nset_bit(_IOC_NR(VIDIOC_G_PRIORITY), valid_ioctls);\r\nif (ops->vidioc_s_priority)\r\nset_bit(_IOC_NR(VIDIOC_S_PRIORITY), valid_ioctls);\r\nif (vdev->ctrl_handler || ops->vidioc_queryctrl)\r\nset_bit(_IOC_NR(VIDIOC_QUERYCTRL), valid_ioctls);\r\nif (vdev->ctrl_handler || ops->vidioc_query_ext_ctrl)\r\nset_bit(_IOC_NR(VIDIOC_QUERY_EXT_CTRL), valid_ioctls);\r\nif (vdev->ctrl_handler || ops->vidioc_g_ctrl || ops->vidioc_g_ext_ctrls)\r\nset_bit(_IOC_NR(VIDIOC_G_CTRL), valid_ioctls);\r\nif (vdev->ctrl_handler || ops->vidioc_s_ctrl || ops->vidioc_s_ext_ctrls)\r\nset_bit(_IOC_NR(VIDIOC_S_CTRL), valid_ioctls);\r\nif (vdev->ctrl_handler || ops->vidioc_g_ext_ctrls)\r\nset_bit(_IOC_NR(VIDIOC_G_EXT_CTRLS), valid_ioctls);\r\nif (vdev->ctrl_handler || ops->vidioc_s_ext_ctrls)\r\nset_bit(_IOC_NR(VIDIOC_S_EXT_CTRLS), valid_ioctls);\r\nif (vdev->ctrl_handler || ops->vidioc_try_ext_ctrls)\r\nset_bit(_IOC_NR(VIDIOC_TRY_EXT_CTRLS), valid_ioctls);\r\nif (vdev->ctrl_handler || ops->vidioc_querymenu)\r\nset_bit(_IOC_NR(VIDIOC_QUERYMENU), valid_ioctls);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_FREQUENCY, vidioc_g_frequency);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_FREQUENCY, vidioc_s_frequency);\r\nSET_VALID_IOCTL(ops, VIDIOC_LOG_STATUS, vidioc_log_status);\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nset_bit(_IOC_NR(VIDIOC_DBG_G_CHIP_INFO), valid_ioctls);\r\nset_bit(_IOC_NR(VIDIOC_DBG_G_REGISTER), valid_ioctls);\r\nset_bit(_IOC_NR(VIDIOC_DBG_S_REGISTER), valid_ioctls);\r\n#endif\r\nSET_VALID_IOCTL(ops, VIDIOC_DQEVENT, vidioc_subscribe_event);\r\nSET_VALID_IOCTL(ops, VIDIOC_SUBSCRIBE_EVENT, vidioc_subscribe_event);\r\nSET_VALID_IOCTL(ops, VIDIOC_UNSUBSCRIBE_EVENT, vidioc_unsubscribe_event);\r\nif (ops->vidioc_enum_freq_bands || ops->vidioc_g_tuner || ops->vidioc_g_modulator)\r\nset_bit(_IOC_NR(VIDIOC_ENUM_FREQ_BANDS), valid_ioctls);\r\nif (is_vid) {\r\nif ((is_rx && (ops->vidioc_enum_fmt_vid_cap ||\r\nops->vidioc_enum_fmt_vid_cap_mplane ||\r\nops->vidioc_enum_fmt_vid_overlay)) ||\r\n(is_tx && (ops->vidioc_enum_fmt_vid_out ||\r\nops->vidioc_enum_fmt_vid_out_mplane)))\r\nset_bit(_IOC_NR(VIDIOC_ENUM_FMT), valid_ioctls);\r\nif ((is_rx && (ops->vidioc_g_fmt_vid_cap ||\r\nops->vidioc_g_fmt_vid_cap_mplane ||\r\nops->vidioc_g_fmt_vid_overlay)) ||\r\n(is_tx && (ops->vidioc_g_fmt_vid_out ||\r\nops->vidioc_g_fmt_vid_out_mplane ||\r\nops->vidioc_g_fmt_vid_out_overlay)))\r\nset_bit(_IOC_NR(VIDIOC_G_FMT), valid_ioctls);\r\nif ((is_rx && (ops->vidioc_s_fmt_vid_cap ||\r\nops->vidioc_s_fmt_vid_cap_mplane ||\r\nops->vidioc_s_fmt_vid_overlay)) ||\r\n(is_tx && (ops->vidioc_s_fmt_vid_out ||\r\nops->vidioc_s_fmt_vid_out_mplane ||\r\nops->vidioc_s_fmt_vid_out_overlay)))\r\nset_bit(_IOC_NR(VIDIOC_S_FMT), valid_ioctls);\r\nif ((is_rx && (ops->vidioc_try_fmt_vid_cap ||\r\nops->vidioc_try_fmt_vid_cap_mplane ||\r\nops->vidioc_try_fmt_vid_overlay)) ||\r\n(is_tx && (ops->vidioc_try_fmt_vid_out ||\r\nops->vidioc_try_fmt_vid_out_mplane ||\r\nops->vidioc_try_fmt_vid_out_overlay)))\r\nset_bit(_IOC_NR(VIDIOC_TRY_FMT), valid_ioctls);\r\nSET_VALID_IOCTL(ops, VIDIOC_OVERLAY, vidioc_overlay);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_FBUF, vidioc_g_fbuf);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_FBUF, vidioc_s_fbuf);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_JPEGCOMP, vidioc_g_jpegcomp);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_JPEGCOMP, vidioc_s_jpegcomp);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_ENC_INDEX, vidioc_g_enc_index);\r\nSET_VALID_IOCTL(ops, VIDIOC_ENCODER_CMD, vidioc_encoder_cmd);\r\nSET_VALID_IOCTL(ops, VIDIOC_TRY_ENCODER_CMD, vidioc_try_encoder_cmd);\r\nSET_VALID_IOCTL(ops, VIDIOC_DECODER_CMD, vidioc_decoder_cmd);\r\nSET_VALID_IOCTL(ops, VIDIOC_TRY_DECODER_CMD, vidioc_try_decoder_cmd);\r\nSET_VALID_IOCTL(ops, VIDIOC_ENUM_FRAMESIZES, vidioc_enum_framesizes);\r\nSET_VALID_IOCTL(ops, VIDIOC_ENUM_FRAMEINTERVALS, vidioc_enum_frameintervals);\r\n} else if (is_vbi) {\r\nif ((is_rx && (ops->vidioc_g_fmt_vbi_cap ||\r\nops->vidioc_g_fmt_sliced_vbi_cap)) ||\r\n(is_tx && (ops->vidioc_g_fmt_vbi_out ||\r\nops->vidioc_g_fmt_sliced_vbi_out)))\r\nset_bit(_IOC_NR(VIDIOC_G_FMT), valid_ioctls);\r\nif ((is_rx && (ops->vidioc_s_fmt_vbi_cap ||\r\nops->vidioc_s_fmt_sliced_vbi_cap)) ||\r\n(is_tx && (ops->vidioc_s_fmt_vbi_out ||\r\nops->vidioc_s_fmt_sliced_vbi_out)))\r\nset_bit(_IOC_NR(VIDIOC_S_FMT), valid_ioctls);\r\nif ((is_rx && (ops->vidioc_try_fmt_vbi_cap ||\r\nops->vidioc_try_fmt_sliced_vbi_cap)) ||\r\n(is_tx && (ops->vidioc_try_fmt_vbi_out ||\r\nops->vidioc_try_fmt_sliced_vbi_out)))\r\nset_bit(_IOC_NR(VIDIOC_TRY_FMT), valid_ioctls);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_SLICED_VBI_CAP, vidioc_g_sliced_vbi_cap);\r\n} else if (is_sdr) {\r\nif (ops->vidioc_enum_fmt_sdr_cap)\r\nset_bit(_IOC_NR(VIDIOC_ENUM_FMT), valid_ioctls);\r\nif (ops->vidioc_g_fmt_sdr_cap)\r\nset_bit(_IOC_NR(VIDIOC_G_FMT), valid_ioctls);\r\nif (ops->vidioc_s_fmt_sdr_cap)\r\nset_bit(_IOC_NR(VIDIOC_S_FMT), valid_ioctls);\r\nif (ops->vidioc_try_fmt_sdr_cap)\r\nset_bit(_IOC_NR(VIDIOC_TRY_FMT), valid_ioctls);\r\n}\r\nif (is_vid || is_vbi || is_sdr) {\r\nSET_VALID_IOCTL(ops, VIDIOC_REQBUFS, vidioc_reqbufs);\r\nSET_VALID_IOCTL(ops, VIDIOC_QUERYBUF, vidioc_querybuf);\r\nSET_VALID_IOCTL(ops, VIDIOC_QBUF, vidioc_qbuf);\r\nSET_VALID_IOCTL(ops, VIDIOC_EXPBUF, vidioc_expbuf);\r\nSET_VALID_IOCTL(ops, VIDIOC_DQBUF, vidioc_dqbuf);\r\nSET_VALID_IOCTL(ops, VIDIOC_CREATE_BUFS, vidioc_create_bufs);\r\nSET_VALID_IOCTL(ops, VIDIOC_PREPARE_BUF, vidioc_prepare_buf);\r\nSET_VALID_IOCTL(ops, VIDIOC_STREAMON, vidioc_streamon);\r\nSET_VALID_IOCTL(ops, VIDIOC_STREAMOFF, vidioc_streamoff);\r\n}\r\nif (is_vid || is_vbi) {\r\nif (ops->vidioc_s_std)\r\nset_bit(_IOC_NR(VIDIOC_ENUMSTD), valid_ioctls);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_STD, vidioc_s_std);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_STD, vidioc_g_std);\r\nif (is_rx) {\r\nSET_VALID_IOCTL(ops, VIDIOC_QUERYSTD, vidioc_querystd);\r\nSET_VALID_IOCTL(ops, VIDIOC_ENUMINPUT, vidioc_enum_input);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_INPUT, vidioc_g_input);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_INPUT, vidioc_s_input);\r\nSET_VALID_IOCTL(ops, VIDIOC_ENUMAUDIO, vidioc_enumaudio);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_AUDIO, vidioc_g_audio);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_AUDIO, vidioc_s_audio);\r\nSET_VALID_IOCTL(ops, VIDIOC_QUERY_DV_TIMINGS, vidioc_query_dv_timings);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_EDID, vidioc_s_edid);\r\n}\r\nif (is_tx) {\r\nSET_VALID_IOCTL(ops, VIDIOC_ENUMOUTPUT, vidioc_enum_output);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_OUTPUT, vidioc_g_output);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_OUTPUT, vidioc_s_output);\r\nSET_VALID_IOCTL(ops, VIDIOC_ENUMAUDOUT, vidioc_enumaudout);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_AUDOUT, vidioc_g_audout);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_AUDOUT, vidioc_s_audout);\r\n}\r\nif (ops->vidioc_g_crop || ops->vidioc_g_selection)\r\nset_bit(_IOC_NR(VIDIOC_G_CROP), valid_ioctls);\r\nif (ops->vidioc_s_crop || ops->vidioc_s_selection)\r\nset_bit(_IOC_NR(VIDIOC_S_CROP), valid_ioctls);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_SELECTION, vidioc_g_selection);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_SELECTION, vidioc_s_selection);\r\nif (ops->vidioc_cropcap || ops->vidioc_g_selection)\r\nset_bit(_IOC_NR(VIDIOC_CROPCAP), valid_ioctls);\r\nif (ops->vidioc_g_parm || (vdev->vfl_type == VFL_TYPE_GRABBER &&\r\nops->vidioc_g_std))\r\nset_bit(_IOC_NR(VIDIOC_G_PARM), valid_ioctls);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_PARM, vidioc_s_parm);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_DV_TIMINGS, vidioc_s_dv_timings);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_DV_TIMINGS, vidioc_g_dv_timings);\r\nSET_VALID_IOCTL(ops, VIDIOC_ENUM_DV_TIMINGS, vidioc_enum_dv_timings);\r\nSET_VALID_IOCTL(ops, VIDIOC_DV_TIMINGS_CAP, vidioc_dv_timings_cap);\r\nSET_VALID_IOCTL(ops, VIDIOC_G_EDID, vidioc_g_edid);\r\n}\r\nif (is_tx && (is_radio || is_sdr)) {\r\nSET_VALID_IOCTL(ops, VIDIOC_G_MODULATOR, vidioc_g_modulator);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_MODULATOR, vidioc_s_modulator);\r\n}\r\nif (is_rx) {\r\nSET_VALID_IOCTL(ops, VIDIOC_G_TUNER, vidioc_g_tuner);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_TUNER, vidioc_s_tuner);\r\nSET_VALID_IOCTL(ops, VIDIOC_S_HW_FREQ_SEEK, vidioc_s_hw_freq_seek);\r\n}\r\nbitmap_andnot(vdev->valid_ioctls, valid_ioctls, vdev->valid_ioctls,\r\nBASE_VIDIOC_PRIVATE);\r\n}\r\nint __video_register_device(struct video_device *vdev, int type, int nr,\r\nint warn_if_nr_in_use, struct module *owner)\r\n{\r\nint i = 0;\r\nint ret;\r\nint minor_offset = 0;\r\nint minor_cnt = VIDEO_NUM_DEVICES;\r\nconst char *name_base;\r\nvdev->minor = -1;\r\nif (WARN_ON(!vdev->release))\r\nreturn -EINVAL;\r\nif (WARN_ON(!vdev->v4l2_dev))\r\nreturn -EINVAL;\r\nspin_lock_init(&vdev->fh_lock);\r\nINIT_LIST_HEAD(&vdev->fh_list);\r\nswitch (type) {\r\ncase VFL_TYPE_GRABBER:\r\nname_base = "video";\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nname_base = "vbi";\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nname_base = "radio";\r\nbreak;\r\ncase VFL_TYPE_SUBDEV:\r\nname_base = "v4l-subdev";\r\nbreak;\r\ncase VFL_TYPE_SDR:\r\nname_base = "swradio";\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s called with unknown type: %d\n",\r\n__func__, type);\r\nreturn -EINVAL;\r\n}\r\nvdev->vfl_type = type;\r\nvdev->cdev = NULL;\r\nif (vdev->dev_parent == NULL)\r\nvdev->dev_parent = vdev->v4l2_dev->dev;\r\nif (vdev->ctrl_handler == NULL)\r\nvdev->ctrl_handler = vdev->v4l2_dev->ctrl_handler;\r\nif (vdev->prio == NULL)\r\nvdev->prio = &vdev->v4l2_dev->prio;\r\n#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES\r\nswitch (type) {\r\ncase VFL_TYPE_GRABBER:\r\nminor_offset = 0;\r\nminor_cnt = 64;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nminor_offset = 64;\r\nminor_cnt = 64;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nminor_offset = 224;\r\nminor_cnt = 32;\r\nbreak;\r\ndefault:\r\nminor_offset = 128;\r\nminor_cnt = 64;\r\nbreak;\r\n}\r\n#endif\r\nmutex_lock(&videodev_lock);\r\nnr = devnode_find(vdev, nr == -1 ? 0 : nr, minor_cnt);\r\nif (nr == minor_cnt)\r\nnr = devnode_find(vdev, 0, minor_cnt);\r\nif (nr == minor_cnt) {\r\nprintk(KERN_ERR "could not get a free device node number\n");\r\nmutex_unlock(&videodev_lock);\r\nreturn -ENFILE;\r\n}\r\n#ifdef CONFIG_VIDEO_FIXED_MINOR_RANGES\r\ni = nr;\r\n#else\r\nfor (i = 0; i < VIDEO_NUM_DEVICES; i++)\r\nif (video_device[i] == NULL)\r\nbreak;\r\nif (i == VIDEO_NUM_DEVICES) {\r\nmutex_unlock(&videodev_lock);\r\nprintk(KERN_ERR "could not get a free minor\n");\r\nreturn -ENFILE;\r\n}\r\n#endif\r\nvdev->minor = i + minor_offset;\r\nvdev->num = nr;\r\ndevnode_set(vdev);\r\nWARN_ON(video_device[vdev->minor] != NULL);\r\nvdev->index = get_index(vdev);\r\nvideo_device[vdev->minor] = vdev;\r\nmutex_unlock(&videodev_lock);\r\nif (vdev->ioctl_ops)\r\ndetermine_valid_ioctls(vdev);\r\nvdev->cdev = cdev_alloc();\r\nif (vdev->cdev == NULL) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nvdev->cdev->ops = &v4l2_fops;\r\nvdev->cdev->owner = owner;\r\nret = cdev_add(vdev->cdev, MKDEV(VIDEO_MAJOR, vdev->minor), 1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: cdev_add failed\n", __func__);\r\nkfree(vdev->cdev);\r\nvdev->cdev = NULL;\r\ngoto cleanup;\r\n}\r\nvdev->dev.class = &video_class;\r\nvdev->dev.devt = MKDEV(VIDEO_MAJOR, vdev->minor);\r\nvdev->dev.parent = vdev->dev_parent;\r\ndev_set_name(&vdev->dev, "%s%d", name_base, vdev->num);\r\nret = device_register(&vdev->dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s: device_register failed\n", __func__);\r\ngoto cleanup;\r\n}\r\nvdev->dev.release = v4l2_device_release;\r\nif (nr != -1 && nr != vdev->num && warn_if_nr_in_use)\r\nprintk(KERN_WARNING "%s: requested %s%d, got %s\n", __func__,\r\nname_base, nr, video_device_node_name(vdev));\r\nif (vdev->v4l2_dev)\r\nv4l2_device_get(vdev->v4l2_dev);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (vdev->v4l2_dev && vdev->v4l2_dev->mdev &&\r\nvdev->vfl_type != VFL_TYPE_SUBDEV) {\r\nvdev->entity.type = MEDIA_ENT_T_DEVNODE_V4L;\r\nvdev->entity.name = vdev->name;\r\nvdev->entity.info.v4l.major = VIDEO_MAJOR;\r\nvdev->entity.info.v4l.minor = vdev->minor;\r\nret = media_device_register_entity(vdev->v4l2_dev->mdev,\r\n&vdev->entity);\r\nif (ret < 0)\r\nprintk(KERN_WARNING\r\n"%s: media_device_register_entity failed\n",\r\n__func__);\r\n}\r\n#endif\r\nset_bit(V4L2_FL_REGISTERED, &vdev->flags);\r\nreturn 0;\r\ncleanup:\r\nmutex_lock(&videodev_lock);\r\nif (vdev->cdev)\r\ncdev_del(vdev->cdev);\r\nvideo_device[vdev->minor] = NULL;\r\ndevnode_clear(vdev);\r\nmutex_unlock(&videodev_lock);\r\nvdev->minor = -1;\r\nreturn ret;\r\n}\r\nvoid video_unregister_device(struct video_device *vdev)\r\n{\r\nif (!vdev || !video_is_registered(vdev))\r\nreturn;\r\nmutex_lock(&videodev_lock);\r\nclear_bit(V4L2_FL_REGISTERED, &vdev->flags);\r\nmutex_unlock(&videodev_lock);\r\ndevice_unregister(&vdev->dev);\r\n}\r\nstatic int __init videodev_init(void)\r\n{\r\ndev_t dev = MKDEV(VIDEO_MAJOR, 0);\r\nint ret;\r\nprintk(KERN_INFO "Linux video capture interface: v2.00\n");\r\nret = register_chrdev_region(dev, VIDEO_NUM_DEVICES, VIDEO_NAME);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "videodev: unable to get major %d\n",\r\nVIDEO_MAJOR);\r\nreturn ret;\r\n}\r\nret = class_register(&video_class);\r\nif (ret < 0) {\r\nunregister_chrdev_region(dev, VIDEO_NUM_DEVICES);\r\nprintk(KERN_WARNING "video_dev: class_register failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit videodev_exit(void)\r\n{\r\ndev_t dev = MKDEV(VIDEO_MAJOR, 0);\r\nclass_unregister(&video_class);\r\nunregister_chrdev_region(dev, VIDEO_NUM_DEVICES);\r\n}
