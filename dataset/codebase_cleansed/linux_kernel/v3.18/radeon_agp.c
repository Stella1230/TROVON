int radeon_agp_init(struct radeon_device *rdev)\r\n{\r\n#if __OS_HAS_AGP\r\nstruct radeon_agpmode_quirk *p = radeon_agpmode_quirk_list;\r\nstruct drm_agp_mode mode;\r\nstruct drm_agp_info info;\r\nuint32_t agp_status;\r\nint default_mode;\r\nbool is_v3;\r\nint ret;\r\nret = drm_agp_acquire(rdev->ddev);\r\nif (ret) {\r\nDRM_ERROR("Unable to acquire AGP: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = drm_agp_info(rdev->ddev, &info);\r\nif (ret) {\r\ndrm_agp_release(rdev->ddev);\r\nDRM_ERROR("Unable to get AGP info: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (rdev->ddev->agp->agp_info.aper_size < 32) {\r\ndrm_agp_release(rdev->ddev);\r\ndev_warn(rdev->dev, "AGP aperture too small (%zuM) "\r\n"need at least 32M, disabling AGP\n",\r\nrdev->ddev->agp->agp_info.aper_size);\r\nreturn -EINVAL;\r\n}\r\nmode.mode = info.mode;\r\nif (rdev->family <= CHIP_RV350)\r\nagp_status = (RREG32(RADEON_AGP_STATUS) | RADEON_AGPv3_MODE) & mode.mode;\r\nelse\r\nagp_status = mode.mode;\r\nis_v3 = !!(agp_status & RADEON_AGPv3_MODE);\r\nif (is_v3) {\r\ndefault_mode = (agp_status & RADEON_AGPv3_8X_MODE) ? 8 : 4;\r\n} else {\r\nif (agp_status & RADEON_AGP_4X_MODE) {\r\ndefault_mode = 4;\r\n} else if (agp_status & RADEON_AGP_2X_MODE) {\r\ndefault_mode = 2;\r\n} else {\r\ndefault_mode = 1;\r\n}\r\n}\r\nwhile (p && p->chip_device != 0) {\r\nif (info.id_vendor == p->hostbridge_vendor &&\r\ninfo.id_device == p->hostbridge_device &&\r\nrdev->pdev->vendor == p->chip_vendor &&\r\nrdev->pdev->device == p->chip_device &&\r\nrdev->pdev->subsystem_vendor == p->subsys_vendor &&\r\nrdev->pdev->subsystem_device == p->subsys_device) {\r\ndefault_mode = p->default_mode;\r\n}\r\n++p;\r\n}\r\nif (radeon_agpmode > 0) {\r\nif ((radeon_agpmode < (is_v3 ? 4 : 1)) ||\r\n(radeon_agpmode > (is_v3 ? 8 : 4)) ||\r\n(radeon_agpmode & (radeon_agpmode - 1))) {\r\nDRM_ERROR("Illegal AGP Mode: %d (valid %s), leaving at %d\n",\r\nradeon_agpmode, is_v3 ? "4, 8" : "1, 2, 4",\r\ndefault_mode);\r\nradeon_agpmode = default_mode;\r\n} else {\r\nDRM_INFO("AGP mode requested: %d\n", radeon_agpmode);\r\n}\r\n} else {\r\nradeon_agpmode = default_mode;\r\n}\r\nmode.mode &= ~RADEON_AGP_MODE_MASK;\r\nif (is_v3) {\r\nswitch (radeon_agpmode) {\r\ncase 8:\r\nmode.mode |= RADEON_AGPv3_8X_MODE;\r\nbreak;\r\ncase 4:\r\ndefault:\r\nmode.mode |= RADEON_AGPv3_4X_MODE;\r\nbreak;\r\n}\r\n} else {\r\nswitch (radeon_agpmode) {\r\ncase 4:\r\nmode.mode |= RADEON_AGP_4X_MODE;\r\nbreak;\r\ncase 2:\r\nmode.mode |= RADEON_AGP_2X_MODE;\r\nbreak;\r\ncase 1:\r\ndefault:\r\nmode.mode |= RADEON_AGP_1X_MODE;\r\nbreak;\r\n}\r\n}\r\nmode.mode &= ~RADEON_AGP_FW_MODE;\r\nret = drm_agp_enable(rdev->ddev, mode);\r\nif (ret) {\r\nDRM_ERROR("Unable to enable AGP (mode = 0x%lx)\n", mode.mode);\r\ndrm_agp_release(rdev->ddev);\r\nreturn ret;\r\n}\r\nrdev->mc.agp_base = rdev->ddev->agp->agp_info.aper_base;\r\nrdev->mc.gtt_size = rdev->ddev->agp->agp_info.aper_size << 20;\r\nrdev->mc.gtt_start = rdev->mc.agp_base;\r\nrdev->mc.gtt_end = rdev->mc.gtt_start + rdev->mc.gtt_size - 1;\r\ndev_info(rdev->dev, "GTT: %lluM 0x%08llX - 0x%08llX\n",\r\nrdev->mc.gtt_size >> 20, rdev->mc.gtt_start, rdev->mc.gtt_end);\r\nif (rdev->family < CHIP_R200) {\r\nWREG32(RADEON_AGP_CNTL, RREG32(RADEON_AGP_CNTL) | 0x000e0000);\r\n}\r\nreturn 0;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nvoid radeon_agp_resume(struct radeon_device *rdev)\r\n{\r\n#if __OS_HAS_AGP\r\nint r;\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nr = radeon_agp_init(rdev);\r\nif (r)\r\ndev_warn(rdev->dev, "radeon AGP reinit failed\n");\r\n}\r\n#endif\r\n}\r\nvoid radeon_agp_fini(struct radeon_device *rdev)\r\n{\r\n#if __OS_HAS_AGP\r\nif (rdev->ddev->agp && rdev->ddev->agp->acquired) {\r\ndrm_agp_release(rdev->ddev);\r\n}\r\n#endif\r\n}\r\nvoid radeon_agp_suspend(struct radeon_device *rdev)\r\n{\r\nradeon_agp_fini(rdev);\r\n}
