static void vcan_rx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\r\nstruct net_device_stats *stats = &dev->stats;\r\nstats->rx_packets++;\r\nstats->rx_bytes += cfd->len;\r\nskb->pkt_type = PACKET_BROADCAST;\r\nskb->dev = dev;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnetif_rx_ni(skb);\r\n}\r\nstatic netdev_tx_t vcan_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\r\nstruct net_device_stats *stats = &dev->stats;\r\nint loop;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nstats->tx_packets++;\r\nstats->tx_bytes += cfd->len;\r\nloop = skb->pkt_type == PACKET_LOOPBACK;\r\nif (!echo) {\r\nif (loop) {\r\nstats->rx_packets++;\r\nstats->rx_bytes += cfd->len;\r\n}\r\nconsume_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (loop) {\r\nskb = can_create_echo_skb(skb);\r\nif (!skb)\r\nreturn NETDEV_TX_OK;\r\nvcan_rx(skb, dev);\r\n} else {\r\nconsume_skb(skb);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int vcan_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nif (new_mtu != CAN_MTU && new_mtu != CANFD_MTU)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void vcan_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_CAN;\r\ndev->mtu = CAN_MTU;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->tx_queue_len = 0;\r\ndev->flags = IFF_NOARP;\r\nif (echo)\r\ndev->flags |= IFF_ECHO;\r\ndev->netdev_ops = &vcan_netdev_ops;\r\ndev->destructor = free_netdev;\r\n}\r\nstatic __init int vcan_init_module(void)\r\n{\r\nprintk(banner);\r\nif (echo)\r\nprintk(KERN_INFO "vcan: enabled echo on driver level.\n");\r\nreturn rtnl_link_register(&vcan_link_ops);\r\n}\r\nstatic __exit void vcan_cleanup_module(void)\r\n{\r\nrtnl_link_unregister(&vcan_link_ops);\r\n}
