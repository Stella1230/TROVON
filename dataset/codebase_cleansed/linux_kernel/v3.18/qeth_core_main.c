int qeth_card_hw_is_reachable(struct qeth_card *card)\r\n{\r\nreturn (card->state == CARD_STATE_SOFTSETUP) ||\r\n(card->state == CARD_STATE_UP);\r\n}\r\nstatic void qeth_close_dev_handler(struct work_struct *work)\r\n{\r\nstruct qeth_card *card;\r\ncard = container_of(work, struct qeth_card, close_dev_work);\r\nQETH_CARD_TEXT(card, 2, "cldevhdl");\r\nrtnl_lock();\r\ndev_close(card->dev);\r\nrtnl_unlock();\r\nccwgroup_set_offline(card->gdev);\r\n}\r\nvoid qeth_close_dev(struct qeth_card *card)\r\n{\r\nQETH_CARD_TEXT(card, 2, "cldevsubm");\r\nqueue_work(qeth_wq, &card->close_dev_work);\r\n}\r\nstatic inline const char *qeth_get_cardname(struct qeth_card *card)\r\n{\r\nif (card->info.guestlan) {\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_OSD:\r\nreturn " Virtual NIC QDIO";\r\ncase QETH_CARD_TYPE_IQD:\r\nreturn " Virtual NIC Hiper";\r\ncase QETH_CARD_TYPE_OSM:\r\nreturn " Virtual NIC QDIO - OSM";\r\ncase QETH_CARD_TYPE_OSX:\r\nreturn " Virtual NIC QDIO - OSX";\r\ndefault:\r\nreturn " unknown";\r\n}\r\n} else {\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_OSD:\r\nreturn " OSD Express";\r\ncase QETH_CARD_TYPE_IQD:\r\nreturn " HiperSockets";\r\ncase QETH_CARD_TYPE_OSN:\r\nreturn " OSN QDIO";\r\ncase QETH_CARD_TYPE_OSM:\r\nreturn " OSM QDIO";\r\ncase QETH_CARD_TYPE_OSX:\r\nreturn " OSX QDIO";\r\ndefault:\r\nreturn " unknown";\r\n}\r\n}\r\nreturn " n/a";\r\n}\r\nconst char *qeth_get_cardname_short(struct qeth_card *card)\r\n{\r\nif (card->info.guestlan) {\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_OSD:\r\nreturn "Virt.NIC QDIO";\r\ncase QETH_CARD_TYPE_IQD:\r\nreturn "Virt.NIC Hiper";\r\ncase QETH_CARD_TYPE_OSM:\r\nreturn "Virt.NIC OSM";\r\ncase QETH_CARD_TYPE_OSX:\r\nreturn "Virt.NIC OSX";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n} else {\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_OSD:\r\nswitch (card->info.link_type) {\r\ncase QETH_LINK_TYPE_FAST_ETH:\r\nreturn "OSD_100";\r\ncase QETH_LINK_TYPE_HSTR:\r\nreturn "HSTR";\r\ncase QETH_LINK_TYPE_GBIT_ETH:\r\nreturn "OSD_1000";\r\ncase QETH_LINK_TYPE_10GBIT_ETH:\r\nreturn "OSD_10GIG";\r\ncase QETH_LINK_TYPE_LANE_ETH100:\r\nreturn "OSD_FE_LANE";\r\ncase QETH_LINK_TYPE_LANE_TR:\r\nreturn "OSD_TR_LANE";\r\ncase QETH_LINK_TYPE_LANE_ETH1000:\r\nreturn "OSD_GbE_LANE";\r\ncase QETH_LINK_TYPE_LANE:\r\nreturn "OSD_ATM_LANE";\r\ndefault:\r\nreturn "OSD_Express";\r\n}\r\ncase QETH_CARD_TYPE_IQD:\r\nreturn "HiperSockets";\r\ncase QETH_CARD_TYPE_OSN:\r\nreturn "OSN";\r\ncase QETH_CARD_TYPE_OSM:\r\nreturn "OSM_1000";\r\ncase QETH_CARD_TYPE_OSX:\r\nreturn "OSX_10GIG";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nreturn "n/a";\r\n}\r\nvoid qeth_set_recovery_task(struct qeth_card *card)\r\n{\r\ncard->recovery_task = current;\r\n}\r\nvoid qeth_clear_recovery_task(struct qeth_card *card)\r\n{\r\ncard->recovery_task = NULL;\r\n}\r\nstatic bool qeth_is_recovery_task(const struct qeth_card *card)\r\n{\r\nreturn card->recovery_task == current;\r\n}\r\nvoid qeth_set_allowed_threads(struct qeth_card *card, unsigned long threads,\r\nint clear_start_mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->thread_mask_lock, flags);\r\ncard->thread_allowed_mask = threads;\r\nif (clear_start_mask)\r\ncard->thread_start_mask &= threads;\r\nspin_unlock_irqrestore(&card->thread_mask_lock, flags);\r\nwake_up(&card->wait_q);\r\n}\r\nint qeth_threads_running(struct qeth_card *card, unsigned long threads)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&card->thread_mask_lock, flags);\r\nrc = (card->thread_running_mask & threads);\r\nspin_unlock_irqrestore(&card->thread_mask_lock, flags);\r\nreturn rc;\r\n}\r\nint qeth_wait_for_threads(struct qeth_card *card, unsigned long threads)\r\n{\r\nif (qeth_is_recovery_task(card))\r\nreturn 0;\r\nreturn wait_event_interruptible(card->wait_q,\r\nqeth_threads_running(card, threads) == 0);\r\n}\r\nvoid qeth_clear_working_pool_list(struct qeth_card *card)\r\n{\r\nstruct qeth_buffer_pool_entry *pool_entry, *tmp;\r\nQETH_CARD_TEXT(card, 5, "clwrklst");\r\nlist_for_each_entry_safe(pool_entry, tmp,\r\n&card->qdio.in_buf_pool.entry_list, list){\r\nlist_del(&pool_entry->list);\r\n}\r\n}\r\nstatic int qeth_alloc_buffer_pool(struct qeth_card *card)\r\n{\r\nstruct qeth_buffer_pool_entry *pool_entry;\r\nvoid *ptr;\r\nint i, j;\r\nQETH_CARD_TEXT(card, 5, "alocpool");\r\nfor (i = 0; i < card->qdio.init_pool.buf_count; ++i) {\r\npool_entry = kzalloc(sizeof(*pool_entry), GFP_KERNEL);\r\nif (!pool_entry) {\r\nqeth_free_buffer_pool(card);\r\nreturn -ENOMEM;\r\n}\r\nfor (j = 0; j < QETH_MAX_BUFFER_ELEMENTS(card); ++j) {\r\nptr = (void *) __get_free_page(GFP_KERNEL);\r\nif (!ptr) {\r\nwhile (j > 0)\r\nfree_page((unsigned long)\r\npool_entry->elements[--j]);\r\nkfree(pool_entry);\r\nqeth_free_buffer_pool(card);\r\nreturn -ENOMEM;\r\n}\r\npool_entry->elements[j] = ptr;\r\n}\r\nlist_add(&pool_entry->init_list,\r\n&card->qdio.init_pool.entry_list);\r\n}\r\nreturn 0;\r\n}\r\nint qeth_realloc_buffer_pool(struct qeth_card *card, int bufcnt)\r\n{\r\nQETH_CARD_TEXT(card, 2, "realcbp");\r\nif ((card->state != CARD_STATE_DOWN) &&\r\n(card->state != CARD_STATE_RECOVER))\r\nreturn -EPERM;\r\nqeth_clear_working_pool_list(card);\r\nqeth_free_buffer_pool(card);\r\ncard->qdio.in_buf_pool.buf_count = bufcnt;\r\ncard->qdio.init_pool.buf_count = bufcnt;\r\nreturn qeth_alloc_buffer_pool(card);\r\n}\r\nstatic void qeth_free_qdio_queue(struct qeth_qdio_q *q)\r\n{\r\nif (!q)\r\nreturn;\r\nqdio_free_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q);\r\nkfree(q);\r\n}\r\nstatic struct qeth_qdio_q *qeth_alloc_qdio_queue(void)\r\n{\r\nstruct qeth_qdio_q *q = kzalloc(sizeof(*q), GFP_KERNEL);\r\nint i;\r\nif (!q)\r\nreturn NULL;\r\nif (qdio_alloc_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q)) {\r\nkfree(q);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i)\r\nq->bufs[i].buffer = q->qdio_bufs[i];\r\nQETH_DBF_HEX(SETUP, 2, &q, sizeof(void *));\r\nreturn q;\r\n}\r\nstatic inline int qeth_cq_init(struct qeth_card *card)\r\n{\r\nint rc;\r\nif (card->options.cq == QETH_CQ_ENABLED) {\r\nQETH_DBF_TEXT(SETUP, 2, "cqinit");\r\nqdio_reset_buffers(card->qdio.c_q->qdio_bufs,\r\nQDIO_MAX_BUFFERS_PER_Q);\r\ncard->qdio.c_q->next_buf_to_init = 127;\r\nrc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT,\r\ncard->qdio.no_in_queues - 1, 0,\r\n127);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\ngoto out;\r\n}\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic inline int qeth_alloc_cq(struct qeth_card *card)\r\n{\r\nint rc;\r\nif (card->options.cq == QETH_CQ_ENABLED) {\r\nint i;\r\nstruct qdio_outbuf_state *outbuf_states;\r\nQETH_DBF_TEXT(SETUP, 2, "cqon");\r\ncard->qdio.c_q = qeth_alloc_qdio_queue();\r\nif (!card->qdio.c_q) {\r\nrc = -1;\r\ngoto kmsg_out;\r\n}\r\ncard->qdio.no_in_queues = 2;\r\ncard->qdio.out_bufstates =\r\nkzalloc(card->qdio.no_out_queues *\r\nQDIO_MAX_BUFFERS_PER_Q *\r\nsizeof(struct qdio_outbuf_state), GFP_KERNEL);\r\noutbuf_states = card->qdio.out_bufstates;\r\nif (outbuf_states == NULL) {\r\nrc = -1;\r\ngoto free_cq_out;\r\n}\r\nfor (i = 0; i < card->qdio.no_out_queues; ++i) {\r\ncard->qdio.out_qs[i]->bufstates = outbuf_states;\r\noutbuf_states += QDIO_MAX_BUFFERS_PER_Q;\r\n}\r\n} else {\r\nQETH_DBF_TEXT(SETUP, 2, "nocq");\r\ncard->qdio.c_q = NULL;\r\ncard->qdio.no_in_queues = 1;\r\n}\r\nQETH_DBF_TEXT_(SETUP, 2, "iqc%d", card->qdio.no_in_queues);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nfree_cq_out:\r\nqeth_free_qdio_queue(card->qdio.c_q);\r\ncard->qdio.c_q = NULL;\r\nkmsg_out:\r\ndev_err(&card->gdev->dev, "Failed to create completion queue\n");\r\ngoto out;\r\n}\r\nstatic inline void qeth_free_cq(struct qeth_card *card)\r\n{\r\nif (card->qdio.c_q) {\r\n--card->qdio.no_in_queues;\r\nqeth_free_qdio_queue(card->qdio.c_q);\r\ncard->qdio.c_q = NULL;\r\n}\r\nkfree(card->qdio.out_bufstates);\r\ncard->qdio.out_bufstates = NULL;\r\n}\r\nstatic inline enum iucv_tx_notify qeth_compute_cq_notification(int sbalf15,\r\nint delayed) {\r\nenum iucv_tx_notify n;\r\nswitch (sbalf15) {\r\ncase 0:\r\nn = delayed ? TX_NOTIFY_DELAYED_OK : TX_NOTIFY_OK;\r\nbreak;\r\ncase 4:\r\ncase 16:\r\ncase 17:\r\ncase 18:\r\nn = delayed ? TX_NOTIFY_DELAYED_UNREACHABLE :\r\nTX_NOTIFY_UNREACHABLE;\r\nbreak;\r\ndefault:\r\nn = delayed ? TX_NOTIFY_DELAYED_GENERALERROR :\r\nTX_NOTIFY_GENERALERROR;\r\nbreak;\r\n}\r\nreturn n;\r\n}\r\nstatic inline void qeth_cleanup_handled_pending(struct qeth_qdio_out_q *q,\r\nint bidx, int forced_cleanup)\r\n{\r\nif (q->card->options.cq != QETH_CQ_ENABLED)\r\nreturn;\r\nif (q->bufs[bidx]->next_pending != NULL) {\r\nstruct qeth_qdio_out_buffer *head = q->bufs[bidx];\r\nstruct qeth_qdio_out_buffer *c = q->bufs[bidx]->next_pending;\r\nwhile (c) {\r\nif (forced_cleanup ||\r\natomic_read(&c->state) ==\r\nQETH_QDIO_BUF_HANDLED_DELAYED) {\r\nstruct qeth_qdio_out_buffer *f = c;\r\nQETH_CARD_TEXT(f->q->card, 5, "fp");\r\nQETH_CARD_TEXT_(f->q->card, 5, "%lx", (long) f);\r\nqeth_release_skbs(c);\r\nc = f->next_pending;\r\nWARN_ON_ONCE(head->next_pending != f);\r\nhead->next_pending = c;\r\nkmem_cache_free(qeth_qdio_outbuf_cache, f);\r\n} else {\r\nhead = c;\r\nc = c->next_pending;\r\n}\r\n}\r\n}\r\nif (forced_cleanup && (atomic_read(&(q->bufs[bidx]->state)) ==\r\nQETH_QDIO_BUF_HANDLED_DELAYED)) {\r\nq->bufs[bidx]->aob = q->bufstates[bidx].aob;\r\nqeth_init_qdio_out_buf(q, bidx);\r\nQETH_CARD_TEXT(q->card, 2, "clprecov");\r\n}\r\n}\r\nstatic inline void qeth_qdio_handle_aob(struct qeth_card *card,\r\nunsigned long phys_aob_addr) {\r\nstruct qaob *aob;\r\nstruct qeth_qdio_out_buffer *buffer;\r\nenum iucv_tx_notify notification;\r\naob = (struct qaob *) phys_to_virt(phys_aob_addr);\r\nQETH_CARD_TEXT(card, 5, "haob");\r\nQETH_CARD_TEXT_(card, 5, "%lx", phys_aob_addr);\r\nbuffer = (struct qeth_qdio_out_buffer *) aob->user1;\r\nQETH_CARD_TEXT_(card, 5, "%lx", aob->user1);\r\nif (atomic_cmpxchg(&buffer->state, QETH_QDIO_BUF_PRIMED,\r\nQETH_QDIO_BUF_IN_CQ) == QETH_QDIO_BUF_PRIMED) {\r\nnotification = TX_NOTIFY_OK;\r\n} else {\r\nWARN_ON_ONCE(atomic_read(&buffer->state) !=\r\nQETH_QDIO_BUF_PENDING);\r\natomic_set(&buffer->state, QETH_QDIO_BUF_IN_CQ);\r\nnotification = TX_NOTIFY_DELAYED_OK;\r\n}\r\nif (aob->aorc != 0) {\r\nQETH_CARD_TEXT_(card, 2, "aorc%02X", aob->aorc);\r\nnotification = qeth_compute_cq_notification(aob->aorc, 1);\r\n}\r\nqeth_notify_skbs(buffer->q, buffer, notification);\r\nbuffer->aob = NULL;\r\nqeth_clear_output_buffer(buffer->q, buffer,\r\nQETH_QDIO_BUF_HANDLED_DELAYED);\r\nqdio_release_aob(aob);\r\n}\r\nstatic inline int qeth_is_cq(struct qeth_card *card, unsigned int queue)\r\n{\r\nreturn card->options.cq == QETH_CQ_ENABLED &&\r\ncard->qdio.c_q != NULL &&\r\nqueue != 0 &&\r\nqueue == card->qdio.no_in_queues - 1;\r\n}\r\nstatic int qeth_issue_next_read(struct qeth_card *card)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_CARD_TEXT(card, 5, "issnxrd");\r\nif (card->read.state != CH_STATE_UP)\r\nreturn -EIO;\r\niob = qeth_get_buffer(&card->read);\r\nif (!iob) {\r\ndev_warn(&card->gdev->dev, "The qeth device driver "\r\n"failed to recover an error on the device\n");\r\nQETH_DBF_MESSAGE(2, "%s issue_next_read failed: no iob "\r\n"available\n", dev_name(&card->gdev->dev));\r\nreturn -ENOMEM;\r\n}\r\nqeth_setup_ccw(&card->read, iob->data, QETH_BUFSIZE);\r\nQETH_CARD_TEXT(card, 6, "noirqpnd");\r\nrc = ccw_device_start(card->read.ccwdev, &card->read.ccw,\r\n(addr_t) iob, 0, 0);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "%s error in starting next read ccw! "\r\n"rc=%i\n", dev_name(&card->gdev->dev), rc);\r\natomic_set(&card->read.irq_pending, 0);\r\ncard->read_or_write_problem = 1;\r\nqeth_schedule_recovery(card);\r\nwake_up(&card->wait_q);\r\n}\r\nreturn rc;\r\n}\r\nstatic struct qeth_reply *qeth_alloc_reply(struct qeth_card *card)\r\n{\r\nstruct qeth_reply *reply;\r\nreply = kzalloc(sizeof(struct qeth_reply), GFP_ATOMIC);\r\nif (reply) {\r\natomic_set(&reply->refcnt, 1);\r\natomic_set(&reply->received, 0);\r\nreply->card = card;\r\n}\r\nreturn reply;\r\n}\r\nstatic void qeth_get_reply(struct qeth_reply *reply)\r\n{\r\nWARN_ON(atomic_read(&reply->refcnt) <= 0);\r\natomic_inc(&reply->refcnt);\r\n}\r\nstatic void qeth_put_reply(struct qeth_reply *reply)\r\n{\r\nWARN_ON(atomic_read(&reply->refcnt) <= 0);\r\nif (atomic_dec_and_test(&reply->refcnt))\r\nkfree(reply);\r\n}\r\nstatic void qeth_issue_ipa_msg(struct qeth_ipa_cmd *cmd, int rc,\r\nstruct qeth_card *card)\r\n{\r\nchar *ipa_name;\r\nint com = cmd->hdr.command;\r\nipa_name = qeth_get_ipa_cmd_name(com);\r\nif (rc)\r\nQETH_DBF_MESSAGE(2, "IPA: %s(x%X) for %s/%s returned "\r\n"x%X \"%s\"\n",\r\nipa_name, com, dev_name(&card->gdev->dev),\r\nQETH_CARD_IFNAME(card), rc,\r\nqeth_get_ipa_msg(rc));\r\nelse\r\nQETH_DBF_MESSAGE(5, "IPA: %s(x%X) for %s/%s succeeded\n",\r\nipa_name, com, dev_name(&card->gdev->dev),\r\nQETH_CARD_IFNAME(card));\r\n}\r\nstatic struct qeth_ipa_cmd *qeth_check_ipa_data(struct qeth_card *card,\r\nstruct qeth_cmd_buffer *iob)\r\n{\r\nstruct qeth_ipa_cmd *cmd = NULL;\r\nQETH_CARD_TEXT(card, 5, "chkipad");\r\nif (IS_IPA(iob->data)) {\r\ncmd = (struct qeth_ipa_cmd *) PDU_ENCAPSULATION(iob->data);\r\nif (IS_IPA_REPLY(cmd)) {\r\nif (cmd->hdr.command != IPA_CMD_SETCCID &&\r\ncmd->hdr.command != IPA_CMD_DELCCID &&\r\ncmd->hdr.command != IPA_CMD_MODCCID &&\r\ncmd->hdr.command != IPA_CMD_SET_DIAG_ASS)\r\nqeth_issue_ipa_msg(cmd,\r\ncmd->hdr.return_code, card);\r\nreturn cmd;\r\n} else {\r\nswitch (cmd->hdr.command) {\r\ncase IPA_CMD_STOPLAN:\r\nif (cmd->hdr.return_code ==\r\nIPA_RC_VEPA_TO_VEB_TRANSITION) {\r\ndev_err(&card->gdev->dev,\r\n"Interface %s is down because the "\r\n"adjacent port is no longer in "\r\n"reflective relay mode\n",\r\nQETH_CARD_IFNAME(card));\r\nqeth_close_dev(card);\r\n} else {\r\ndev_warn(&card->gdev->dev,\r\n"The link for interface %s on CHPID"\r\n" 0x%X failed\n",\r\nQETH_CARD_IFNAME(card),\r\ncard->info.chpid);\r\nqeth_issue_ipa_msg(cmd,\r\ncmd->hdr.return_code, card);\r\n}\r\ncard->lan_online = 0;\r\nif (card->dev && netif_carrier_ok(card->dev))\r\nnetif_carrier_off(card->dev);\r\nreturn NULL;\r\ncase IPA_CMD_STARTLAN:\r\ndev_info(&card->gdev->dev,\r\n"The link for %s on CHPID 0x%X has"\r\n" been restored\n",\r\nQETH_CARD_IFNAME(card),\r\ncard->info.chpid);\r\nnetif_carrier_on(card->dev);\r\ncard->lan_online = 1;\r\nif (card->info.hwtrap)\r\ncard->info.hwtrap = 2;\r\nqeth_schedule_recovery(card);\r\nreturn NULL;\r\ncase IPA_CMD_SETBRIDGEPORT:\r\ncase IPA_CMD_ADDRESS_CHANGE_NOTIF:\r\nif (card->discipline->control_event_handler\r\n(card, cmd))\r\nreturn cmd;\r\nelse\r\nreturn NULL;\r\ncase IPA_CMD_MODCCID:\r\nreturn cmd;\r\ncase IPA_CMD_REGISTER_LOCAL_ADDR:\r\nQETH_CARD_TEXT(card, 3, "irla");\r\nbreak;\r\ncase IPA_CMD_UNREGISTER_LOCAL_ADDR:\r\nQETH_CARD_TEXT(card, 3, "urla");\r\nbreak;\r\ndefault:\r\nQETH_DBF_MESSAGE(2, "Received data is IPA "\r\n"but not a reply!\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn cmd;\r\n}\r\nvoid qeth_clear_ipacmd_list(struct qeth_card *card)\r\n{\r\nstruct qeth_reply *reply, *r;\r\nunsigned long flags;\r\nQETH_CARD_TEXT(card, 4, "clipalst");\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {\r\nqeth_get_reply(reply);\r\nreply->rc = -EIO;\r\natomic_inc(&reply->received);\r\nlist_del_init(&reply->list);\r\nwake_up(&reply->wait_q);\r\nqeth_put_reply(reply);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\natomic_set(&card->write.irq_pending, 0);\r\n}\r\nstatic int qeth_check_idx_response(struct qeth_card *card,\r\nunsigned char *buffer)\r\n{\r\nif (!buffer)\r\nreturn 0;\r\nQETH_DBF_HEX(CTRL, 2, buffer, QETH_DBF_CTRL_LEN);\r\nif ((buffer[2] & 0xc0) == 0xc0) {\r\nQETH_DBF_MESSAGE(2, "received an IDX TERMINATE "\r\n"with cause code 0x%02x%s\n",\r\nbuffer[4],\r\n((buffer[4] == 0x22) ?\r\n" -- try another portname" : ""));\r\nQETH_CARD_TEXT(card, 2, "ckidxres");\r\nQETH_CARD_TEXT(card, 2, " idxterm");\r\nQETH_CARD_TEXT_(card, 2, " rc%d", -EIO);\r\nif (buffer[4] == 0xf6) {\r\ndev_err(&card->gdev->dev,\r\n"The qeth device is not configured "\r\n"for the OSI layer required by z/VM\n");\r\nreturn -EPERM;\r\n}\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qeth_setup_ccw(struct qeth_channel *channel, unsigned char *iob,\r\n__u32 len)\r\n{\r\nstruct qeth_card *card;\r\ncard = CARD_FROM_CDEV(channel->ccwdev);\r\nQETH_CARD_TEXT(card, 4, "setupccw");\r\nif (channel == &card->read)\r\nmemcpy(&channel->ccw, READ_CCW, sizeof(struct ccw1));\r\nelse\r\nmemcpy(&channel->ccw, WRITE_CCW, sizeof(struct ccw1));\r\nchannel->ccw.count = len;\r\nchannel->ccw.cda = (__u32) __pa(iob);\r\n}\r\nstatic struct qeth_cmd_buffer *__qeth_get_buffer(struct qeth_channel *channel)\r\n{\r\n__u8 index;\r\nQETH_CARD_TEXT(CARD_FROM_CDEV(channel->ccwdev), 6, "getbuff");\r\nindex = channel->io_buf_no;\r\ndo {\r\nif (channel->iob[index].state == BUF_STATE_FREE) {\r\nchannel->iob[index].state = BUF_STATE_LOCKED;\r\nchannel->io_buf_no = (channel->io_buf_no + 1) %\r\nQETH_CMD_BUFFER_NO;\r\nmemset(channel->iob[index].data, 0, QETH_BUFSIZE);\r\nreturn channel->iob + index;\r\n}\r\nindex = (index + 1) % QETH_CMD_BUFFER_NO;\r\n} while (index != channel->io_buf_no);\r\nreturn NULL;\r\n}\r\nvoid qeth_release_buffer(struct qeth_channel *channel,\r\nstruct qeth_cmd_buffer *iob)\r\n{\r\nunsigned long flags;\r\nQETH_CARD_TEXT(CARD_FROM_CDEV(channel->ccwdev), 6, "relbuff");\r\nspin_lock_irqsave(&channel->iob_lock, flags);\r\nmemset(iob->data, 0, QETH_BUFSIZE);\r\niob->state = BUF_STATE_FREE;\r\niob->callback = qeth_send_control_data_cb;\r\niob->rc = 0;\r\nspin_unlock_irqrestore(&channel->iob_lock, flags);\r\nwake_up(&channel->wait_q);\r\n}\r\nstatic struct qeth_cmd_buffer *qeth_get_buffer(struct qeth_channel *channel)\r\n{\r\nstruct qeth_cmd_buffer *buffer = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&channel->iob_lock, flags);\r\nbuffer = __qeth_get_buffer(channel);\r\nspin_unlock_irqrestore(&channel->iob_lock, flags);\r\nreturn buffer;\r\n}\r\nstruct qeth_cmd_buffer *qeth_wait_for_buffer(struct qeth_channel *channel)\r\n{\r\nstruct qeth_cmd_buffer *buffer;\r\nwait_event(channel->wait_q,\r\n((buffer = qeth_get_buffer(channel)) != NULL));\r\nreturn buffer;\r\n}\r\nvoid qeth_clear_cmd_buffers(struct qeth_channel *channel)\r\n{\r\nint cnt;\r\nfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++)\r\nqeth_release_buffer(channel, &channel->iob[cnt]);\r\nchannel->buf_no = 0;\r\nchannel->io_buf_no = 0;\r\n}\r\nstatic void qeth_send_control_data_cb(struct qeth_channel *channel,\r\nstruct qeth_cmd_buffer *iob)\r\n{\r\nstruct qeth_card *card;\r\nstruct qeth_reply *reply, *r;\r\nstruct qeth_ipa_cmd *cmd;\r\nunsigned long flags;\r\nint keep_reply;\r\nint rc = 0;\r\ncard = CARD_FROM_CDEV(channel->ccwdev);\r\nQETH_CARD_TEXT(card, 4, "sndctlcb");\r\nrc = qeth_check_idx_response(card, iob->data);\r\nswitch (rc) {\r\ncase 0:\r\nbreak;\r\ncase -EIO:\r\nqeth_clear_ipacmd_list(card);\r\nqeth_schedule_recovery(card);\r\ndefault:\r\ngoto out;\r\n}\r\ncmd = qeth_check_ipa_data(card, iob);\r\nif ((cmd == NULL) && (card->state != CARD_STATE_DOWN))\r\ngoto out;\r\nif (card->info.type == QETH_CARD_TYPE_OSN &&\r\ncmd &&\r\ncmd->hdr.command != IPA_CMD_STARTLAN &&\r\ncard->osn_info.assist_cb != NULL) {\r\ncard->osn_info.assist_cb(card->dev, cmd);\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {\r\nif ((reply->seqno == QETH_IDX_COMMAND_SEQNO) ||\r\n((cmd) && (reply->seqno == cmd->hdr.seqno))) {\r\nqeth_get_reply(reply);\r\nlist_del_init(&reply->list);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nkeep_reply = 0;\r\nif (reply->callback != NULL) {\r\nif (cmd) {\r\nreply->offset = (__u16)((char *)cmd -\r\n(char *)iob->data);\r\nkeep_reply = reply->callback(card,\r\nreply,\r\n(unsigned long)cmd);\r\n} else\r\nkeep_reply = reply->callback(card,\r\nreply,\r\n(unsigned long)iob);\r\n}\r\nif (cmd)\r\nreply->rc = (u16) cmd->hdr.return_code;\r\nelse if (iob->rc)\r\nreply->rc = iob->rc;\r\nif (keep_reply) {\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_add_tail(&reply->list,\r\n&card->cmd_waiter_list);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n} else {\r\natomic_inc(&reply->received);\r\nwake_up(&reply->wait_q);\r\n}\r\nqeth_put_reply(reply);\r\ngoto out;\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nout:\r\nmemcpy(&card->seqno.pdu_hdr_ack,\r\nQETH_PDU_HEADER_SEQ_NO(iob->data),\r\nQETH_SEQ_NO_LENGTH);\r\nqeth_release_buffer(channel, iob);\r\n}\r\nstatic int qeth_setup_channel(struct qeth_channel *channel)\r\n{\r\nint cnt;\r\nQETH_DBF_TEXT(SETUP, 2, "setupch");\r\nfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++) {\r\nchannel->iob[cnt].data =\r\nkzalloc(QETH_BUFSIZE, GFP_DMA|GFP_KERNEL);\r\nif (channel->iob[cnt].data == NULL)\r\nbreak;\r\nchannel->iob[cnt].state = BUF_STATE_FREE;\r\nchannel->iob[cnt].channel = channel;\r\nchannel->iob[cnt].callback = qeth_send_control_data_cb;\r\nchannel->iob[cnt].rc = 0;\r\n}\r\nif (cnt < QETH_CMD_BUFFER_NO) {\r\nwhile (cnt-- > 0)\r\nkfree(channel->iob[cnt].data);\r\nreturn -ENOMEM;\r\n}\r\nchannel->buf_no = 0;\r\nchannel->io_buf_no = 0;\r\natomic_set(&channel->irq_pending, 0);\r\nspin_lock_init(&channel->iob_lock);\r\ninit_waitqueue_head(&channel->wait_q);\r\nreturn 0;\r\n}\r\nstatic int qeth_set_thread_start_bit(struct qeth_card *card,\r\nunsigned long thread)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->thread_mask_lock, flags);\r\nif (!(card->thread_allowed_mask & thread) ||\r\n(card->thread_start_mask & thread)) {\r\nspin_unlock_irqrestore(&card->thread_mask_lock, flags);\r\nreturn -EPERM;\r\n}\r\ncard->thread_start_mask |= thread;\r\nspin_unlock_irqrestore(&card->thread_mask_lock, flags);\r\nreturn 0;\r\n}\r\nvoid qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->thread_mask_lock, flags);\r\ncard->thread_start_mask &= ~thread;\r\nspin_unlock_irqrestore(&card->thread_mask_lock, flags);\r\nwake_up(&card->wait_q);\r\n}\r\nvoid qeth_clear_thread_running_bit(struct qeth_card *card, unsigned long thread)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->thread_mask_lock, flags);\r\ncard->thread_running_mask &= ~thread;\r\nspin_unlock_irqrestore(&card->thread_mask_lock, flags);\r\nwake_up(&card->wait_q);\r\n}\r\nstatic int __qeth_do_run_thread(struct qeth_card *card, unsigned long thread)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&card->thread_mask_lock, flags);\r\nif (card->thread_start_mask & thread) {\r\nif ((card->thread_allowed_mask & thread) &&\r\n!(card->thread_running_mask & thread)) {\r\nrc = 1;\r\ncard->thread_start_mask &= ~thread;\r\ncard->thread_running_mask |= thread;\r\n} else\r\nrc = -EPERM;\r\n}\r\nspin_unlock_irqrestore(&card->thread_mask_lock, flags);\r\nreturn rc;\r\n}\r\nint qeth_do_run_thread(struct qeth_card *card, unsigned long thread)\r\n{\r\nint rc = 0;\r\nwait_event(card->wait_q,\r\n(rc = __qeth_do_run_thread(card, thread)) >= 0);\r\nreturn rc;\r\n}\r\nvoid qeth_schedule_recovery(struct qeth_card *card)\r\n{\r\nQETH_CARD_TEXT(card, 2, "startrec");\r\nif (qeth_set_thread_start_bit(card, QETH_RECOVER_THREAD) == 0)\r\nschedule_work(&card->kernel_thread_starter);\r\n}\r\nstatic int qeth_get_problem(struct ccw_device *cdev, struct irb *irb)\r\n{\r\nint dstat, cstat;\r\nchar *sense;\r\nstruct qeth_card *card;\r\nsense = (char *) irb->ecw;\r\ncstat = irb->scsw.cmd.cstat;\r\ndstat = irb->scsw.cmd.dstat;\r\ncard = CARD_FROM_CDEV(cdev);\r\nif (cstat & (SCHN_STAT_CHN_CTRL_CHK | SCHN_STAT_INTF_CTRL_CHK |\r\nSCHN_STAT_CHN_DATA_CHK | SCHN_STAT_CHAIN_CHECK |\r\nSCHN_STAT_PROT_CHECK | SCHN_STAT_PROG_CHECK)) {\r\nQETH_CARD_TEXT(card, 2, "CGENCHK");\r\ndev_warn(&cdev->dev, "The qeth device driver "\r\n"failed to recover an error on the device\n");\r\nQETH_DBF_MESSAGE(2, "%s check on device dstat=x%x, cstat=x%x\n",\r\ndev_name(&cdev->dev), dstat, cstat);\r\nprint_hex_dump(KERN_WARNING, "qeth: irb ", DUMP_PREFIX_OFFSET,\r\n16, 1, irb, 64, 1);\r\nreturn 1;\r\n}\r\nif (dstat & DEV_STAT_UNIT_CHECK) {\r\nif (sense[SENSE_RESETTING_EVENT_BYTE] &\r\nSENSE_RESETTING_EVENT_FLAG) {\r\nQETH_CARD_TEXT(card, 2, "REVIND");\r\nreturn 1;\r\n}\r\nif (sense[SENSE_COMMAND_REJECT_BYTE] &\r\nSENSE_COMMAND_REJECT_FLAG) {\r\nQETH_CARD_TEXT(card, 2, "CMDREJi");\r\nreturn 1;\r\n}\r\nif ((sense[2] == 0xaf) && (sense[3] == 0xfe)) {\r\nQETH_CARD_TEXT(card, 2, "AFFE");\r\nreturn 1;\r\n}\r\nif ((!sense[0]) && (!sense[1]) && (!sense[2]) && (!sense[3])) {\r\nQETH_CARD_TEXT(card, 2, "ZEROSEN");\r\nreturn 0;\r\n}\r\nQETH_CARD_TEXT(card, 2, "DGENCHK");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic long __qeth_check_irb_error(struct ccw_device *cdev,\r\nunsigned long intparm, struct irb *irb)\r\n{\r\nstruct qeth_card *card;\r\ncard = CARD_FROM_CDEV(cdev);\r\nif (!card || !IS_ERR(irb))\r\nreturn 0;\r\nswitch (PTR_ERR(irb)) {\r\ncase -EIO:\r\nQETH_DBF_MESSAGE(2, "%s i/o-error on device\n",\r\ndev_name(&cdev->dev));\r\nQETH_CARD_TEXT(card, 2, "ckirberr");\r\nQETH_CARD_TEXT_(card, 2, " rc%d", -EIO);\r\nbreak;\r\ncase -ETIMEDOUT:\r\ndev_warn(&cdev->dev, "A hardware operation timed out"\r\n" on the device\n");\r\nQETH_CARD_TEXT(card, 2, "ckirberr");\r\nQETH_CARD_TEXT_(card, 2, " rc%d", -ETIMEDOUT);\r\nif (intparm == QETH_RCD_PARM) {\r\nif (card->data.ccwdev == cdev) {\r\ncard->data.state = CH_STATE_DOWN;\r\nwake_up(&card->wait_q);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nQETH_DBF_MESSAGE(2, "%s unknown error %ld on device\n",\r\ndev_name(&cdev->dev), PTR_ERR(irb));\r\nQETH_CARD_TEXT(card, 2, "ckirberr");\r\nQETH_CARD_TEXT(card, 2, " rc???");\r\n}\r\nreturn PTR_ERR(irb);\r\n}\r\nstatic void qeth_irq(struct ccw_device *cdev, unsigned long intparm,\r\nstruct irb *irb)\r\n{\r\nint rc;\r\nint cstat, dstat;\r\nstruct qeth_cmd_buffer *buffer;\r\nstruct qeth_channel *channel;\r\nstruct qeth_card *card;\r\nstruct qeth_cmd_buffer *iob;\r\n__u8 index;\r\nif (__qeth_check_irb_error(cdev, intparm, irb))\r\nreturn;\r\ncstat = irb->scsw.cmd.cstat;\r\ndstat = irb->scsw.cmd.dstat;\r\ncard = CARD_FROM_CDEV(cdev);\r\nif (!card)\r\nreturn;\r\nQETH_CARD_TEXT(card, 5, "irq");\r\nif (card->read.ccwdev == cdev) {\r\nchannel = &card->read;\r\nQETH_CARD_TEXT(card, 5, "read");\r\n} else if (card->write.ccwdev == cdev) {\r\nchannel = &card->write;\r\nQETH_CARD_TEXT(card, 5, "write");\r\n} else {\r\nchannel = &card->data;\r\nQETH_CARD_TEXT(card, 5, "data");\r\n}\r\natomic_set(&channel->irq_pending, 0);\r\nif (irb->scsw.cmd.fctl & (SCSW_FCTL_CLEAR_FUNC))\r\nchannel->state = CH_STATE_STOPPED;\r\nif (irb->scsw.cmd.fctl & (SCSW_FCTL_HALT_FUNC))\r\nchannel->state = CH_STATE_HALTED;\r\nif ((channel == &card->data) && (intparm != 0) &&\r\n(intparm != QETH_RCD_PARM))\r\ngoto out;\r\nif (intparm == QETH_CLEAR_CHANNEL_PARM) {\r\nQETH_CARD_TEXT(card, 6, "clrchpar");\r\nintparm = 0;\r\n}\r\nif (intparm == QETH_HALT_CHANNEL_PARM) {\r\nQETH_CARD_TEXT(card, 6, "hltchpar");\r\nintparm = 0;\r\n}\r\nif ((dstat & DEV_STAT_UNIT_EXCEP) ||\r\n(dstat & DEV_STAT_UNIT_CHECK) ||\r\n(cstat)) {\r\nif (irb->esw.esw0.erw.cons) {\r\ndev_warn(&channel->ccwdev->dev,\r\n"The qeth device driver failed to recover "\r\n"an error on the device\n");\r\nQETH_DBF_MESSAGE(2, "%s sense data available. cstat "\r\n"0x%X dstat 0x%X\n",\r\ndev_name(&channel->ccwdev->dev), cstat, dstat);\r\nprint_hex_dump(KERN_WARNING, "qeth: irb ",\r\nDUMP_PREFIX_OFFSET, 16, 1, irb, 32, 1);\r\nprint_hex_dump(KERN_WARNING, "qeth: sense data ",\r\nDUMP_PREFIX_OFFSET, 16, 1, irb->ecw, 32, 1);\r\n}\r\nif (intparm == QETH_RCD_PARM) {\r\nchannel->state = CH_STATE_DOWN;\r\ngoto out;\r\n}\r\nrc = qeth_get_problem(cdev, irb);\r\nif (rc) {\r\nqeth_clear_ipacmd_list(card);\r\nqeth_schedule_recovery(card);\r\ngoto out;\r\n}\r\n}\r\nif (intparm == QETH_RCD_PARM) {\r\nchannel->state = CH_STATE_RCD_DONE;\r\ngoto out;\r\n}\r\nif (intparm) {\r\nbuffer = (struct qeth_cmd_buffer *) __va((addr_t)intparm);\r\nbuffer->state = BUF_STATE_PROCESSED;\r\n}\r\nif (channel == &card->data)\r\nreturn;\r\nif (channel == &card->read &&\r\nchannel->state == CH_STATE_UP)\r\nqeth_issue_next_read(card);\r\niob = channel->iob;\r\nindex = channel->buf_no;\r\nwhile (iob[index].state == BUF_STATE_PROCESSED) {\r\nif (iob[index].callback != NULL)\r\niob[index].callback(channel, iob + index);\r\nindex = (index + 1) % QETH_CMD_BUFFER_NO;\r\n}\r\nchannel->buf_no = index;\r\nout:\r\nwake_up(&card->wait_q);\r\nreturn;\r\n}\r\nstatic void qeth_notify_skbs(struct qeth_qdio_out_q *q,\r\nstruct qeth_qdio_out_buffer *buf,\r\nenum iucv_tx_notify notification)\r\n{\r\nstruct sk_buff *skb;\r\nif (skb_queue_empty(&buf->skb_list))\r\ngoto out;\r\nskb = skb_peek(&buf->skb_list);\r\nwhile (skb) {\r\nQETH_CARD_TEXT_(q->card, 5, "skbn%d", notification);\r\nQETH_CARD_TEXT_(q->card, 5, "%lx", (long) skb);\r\nif (skb->protocol == ETH_P_AF_IUCV) {\r\nif (skb->sk) {\r\nstruct iucv_sock *iucv = iucv_sk(skb->sk);\r\niucv->sk_txnotify(skb, notification);\r\n}\r\n}\r\nif (skb_queue_is_last(&buf->skb_list, skb))\r\nskb = NULL;\r\nelse\r\nskb = skb_queue_next(&buf->skb_list, skb);\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic void qeth_release_skbs(struct qeth_qdio_out_buffer *buf)\r\n{\r\nstruct sk_buff *skb;\r\nstruct iucv_sock *iucv;\r\nint notify_general_error = 0;\r\nif (atomic_read(&buf->state) == QETH_QDIO_BUF_PENDING)\r\nnotify_general_error = 1;\r\nWARN_ON_ONCE(atomic_read(&buf->state) == QETH_QDIO_BUF_IN_CQ);\r\nskb = skb_dequeue(&buf->skb_list);\r\nwhile (skb) {\r\nQETH_CARD_TEXT(buf->q->card, 5, "skbr");\r\nQETH_CARD_TEXT_(buf->q->card, 5, "%lx", (long) skb);\r\nif (notify_general_error && skb->protocol == ETH_P_AF_IUCV) {\r\nif (skb->sk) {\r\niucv = iucv_sk(skb->sk);\r\niucv->sk_txnotify(skb, TX_NOTIFY_GENERALERROR);\r\n}\r\n}\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_any(skb);\r\nskb = skb_dequeue(&buf->skb_list);\r\n}\r\n}\r\nstatic void qeth_clear_output_buffer(struct qeth_qdio_out_q *queue,\r\nstruct qeth_qdio_out_buffer *buf,\r\nenum qeth_qdio_buffer_states newbufstate)\r\n{\r\nint i;\r\nif (buf->buffer->element[0].sflags & SBAL_SFLAGS0_PCI_REQ)\r\natomic_dec(&queue->set_pci_flags_count);\r\nif (newbufstate == QETH_QDIO_BUF_EMPTY) {\r\nqeth_release_skbs(buf);\r\n}\r\nfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(queue->card); ++i) {\r\nif (buf->buffer->element[i].addr && buf->is_header[i])\r\nkmem_cache_free(qeth_core_header_cache,\r\nbuf->buffer->element[i].addr);\r\nbuf->is_header[i] = 0;\r\nbuf->buffer->element[i].length = 0;\r\nbuf->buffer->element[i].addr = NULL;\r\nbuf->buffer->element[i].eflags = 0;\r\nbuf->buffer->element[i].sflags = 0;\r\n}\r\nbuf->buffer->element[15].eflags = 0;\r\nbuf->buffer->element[15].sflags = 0;\r\nbuf->next_element_to_fill = 0;\r\natomic_set(&buf->state, newbufstate);\r\n}\r\nstatic void qeth_clear_outq_buffers(struct qeth_qdio_out_q *q, int free)\r\n{\r\nint j;\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\r\nif (!q->bufs[j])\r\ncontinue;\r\nqeth_cleanup_handled_pending(q, j, 1);\r\nqeth_clear_output_buffer(q, q->bufs[j], QETH_QDIO_BUF_EMPTY);\r\nif (free) {\r\nkmem_cache_free(qeth_qdio_outbuf_cache, q->bufs[j]);\r\nq->bufs[j] = NULL;\r\n}\r\n}\r\n}\r\nvoid qeth_clear_qdio_buffers(struct qeth_card *card)\r\n{\r\nint i;\r\nQETH_CARD_TEXT(card, 2, "clearqdbf");\r\nfor (i = 0; i < card->qdio.no_out_queues; ++i) {\r\nif (card->qdio.out_qs[i]) {\r\nqeth_clear_outq_buffers(card->qdio.out_qs[i], 0);\r\n}\r\n}\r\n}\r\nstatic void qeth_free_buffer_pool(struct qeth_card *card)\r\n{\r\nstruct qeth_buffer_pool_entry *pool_entry, *tmp;\r\nint i = 0;\r\nlist_for_each_entry_safe(pool_entry, tmp,\r\n&card->qdio.init_pool.entry_list, init_list){\r\nfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i)\r\nfree_page((unsigned long)pool_entry->elements[i]);\r\nlist_del(&pool_entry->init_list);\r\nkfree(pool_entry);\r\n}\r\n}\r\nstatic void qeth_clean_channel(struct qeth_channel *channel)\r\n{\r\nint cnt;\r\nQETH_DBF_TEXT(SETUP, 2, "freech");\r\nfor (cnt = 0; cnt < QETH_CMD_BUFFER_NO; cnt++)\r\nkfree(channel->iob[cnt].data);\r\n}\r\nstatic void qeth_set_single_write_queues(struct qeth_card *card)\r\n{\r\nif ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&\r\n(card->qdio.no_out_queues == 4))\r\nqeth_free_qdio_buffers(card);\r\ncard->qdio.no_out_queues = 1;\r\nif (card->qdio.default_out_queue != 0)\r\ndev_info(&card->gdev->dev, "Priority Queueing not supported\n");\r\ncard->qdio.default_out_queue = 0;\r\n}\r\nstatic void qeth_set_multiple_write_queues(struct qeth_card *card)\r\n{\r\nif ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&\r\n(card->qdio.no_out_queues == 1)) {\r\nqeth_free_qdio_buffers(card);\r\ncard->qdio.default_out_queue = 2;\r\n}\r\ncard->qdio.no_out_queues = 4;\r\n}\r\nstatic void qeth_update_from_chp_desc(struct qeth_card *card)\r\n{\r\nstruct ccw_device *ccwdev;\r\nstruct channel_path_desc *chp_dsc;\r\nQETH_DBF_TEXT(SETUP, 2, "chp_desc");\r\nccwdev = card->data.ccwdev;\r\nchp_dsc = ccw_device_get_chp_desc(ccwdev, 0);\r\nif (!chp_dsc)\r\ngoto out;\r\ncard->info.func_level = 0x4100 + chp_dsc->desc;\r\nif (card->info.type == QETH_CARD_TYPE_IQD)\r\ngoto out;\r\nif ((chp_dsc->chpp & 0x02) == 0x02)\r\nqeth_set_single_write_queues(card);\r\nelse\r\nqeth_set_multiple_write_queues(card);\r\nout:\r\nkfree(chp_dsc);\r\nQETH_DBF_TEXT_(SETUP, 2, "nr:%x", card->qdio.no_out_queues);\r\nQETH_DBF_TEXT_(SETUP, 2, "lvl:%02x", card->info.func_level);\r\n}\r\nstatic void qeth_init_qdio_info(struct qeth_card *card)\r\n{\r\nQETH_DBF_TEXT(SETUP, 4, "intqdinf");\r\natomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);\r\ncard->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;\r\nif (card->info.type == QETH_CARD_TYPE_IQD)\r\ncard->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_HSDEFAULT;\r\nelse\r\ncard->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_DEFAULT;\r\ncard->qdio.in_buf_pool.buf_count = card->qdio.init_pool.buf_count;\r\nINIT_LIST_HEAD(&card->qdio.in_buf_pool.entry_list);\r\nINIT_LIST_HEAD(&card->qdio.init_pool.entry_list);\r\n}\r\nstatic void qeth_set_intial_options(struct qeth_card *card)\r\n{\r\ncard->options.route4.type = NO_ROUTER;\r\ncard->options.route6.type = NO_ROUTER;\r\ncard->options.fake_broadcast = 0;\r\ncard->options.add_hhlen = DEFAULT_ADD_HHLEN;\r\ncard->options.performance_stats = 0;\r\ncard->options.rx_sg_cb = QETH_RX_SG_CB;\r\ncard->options.isolation = ISOLATION_MODE_NONE;\r\ncard->options.cq = QETH_CQ_DISABLED;\r\n}\r\nstatic int qeth_do_start_thread(struct qeth_card *card, unsigned long thread)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&card->thread_mask_lock, flags);\r\nQETH_CARD_TEXT_(card, 4, " %02x%02x%02x",\r\n(u8) card->thread_start_mask,\r\n(u8) card->thread_allowed_mask,\r\n(u8) card->thread_running_mask);\r\nrc = (card->thread_start_mask & thread);\r\nspin_unlock_irqrestore(&card->thread_mask_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void qeth_start_kernel_thread(struct work_struct *work)\r\n{\r\nstruct task_struct *ts;\r\nstruct qeth_card *card = container_of(work, struct qeth_card,\r\nkernel_thread_starter);\r\nQETH_CARD_TEXT(card , 2, "strthrd");\r\nif (card->read.state != CH_STATE_UP &&\r\ncard->write.state != CH_STATE_UP)\r\nreturn;\r\nif (qeth_do_start_thread(card, QETH_RECOVER_THREAD)) {\r\nts = kthread_run(card->discipline->recover, (void *)card,\r\n"qeth_recover");\r\nif (IS_ERR(ts)) {\r\nqeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);\r\nqeth_clear_thread_running_bit(card,\r\nQETH_RECOVER_THREAD);\r\n}\r\n}\r\n}\r\nstatic int qeth_setup_card(struct qeth_card *card)\r\n{\r\nQETH_DBF_TEXT(SETUP, 2, "setupcrd");\r\nQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\r\ncard->read.state = CH_STATE_DOWN;\r\ncard->write.state = CH_STATE_DOWN;\r\ncard->data.state = CH_STATE_DOWN;\r\ncard->state = CARD_STATE_DOWN;\r\ncard->lan_online = 0;\r\ncard->read_or_write_problem = 0;\r\ncard->dev = NULL;\r\nspin_lock_init(&card->vlanlock);\r\nspin_lock_init(&card->mclock);\r\nspin_lock_init(&card->lock);\r\nspin_lock_init(&card->ip_lock);\r\nspin_lock_init(&card->thread_mask_lock);\r\nmutex_init(&card->conf_mutex);\r\nmutex_init(&card->discipline_mutex);\r\ncard->thread_start_mask = 0;\r\ncard->thread_allowed_mask = 0;\r\ncard->thread_running_mask = 0;\r\nINIT_WORK(&card->kernel_thread_starter, qeth_start_kernel_thread);\r\nINIT_LIST_HEAD(&card->ip_list);\r\nINIT_LIST_HEAD(card->ip_tbd_list);\r\nINIT_LIST_HEAD(&card->cmd_waiter_list);\r\ninit_waitqueue_head(&card->wait_q);\r\nqeth_set_intial_options(card);\r\nINIT_LIST_HEAD(&card->ipato.entries);\r\ncard->ipato.enabled = 0;\r\ncard->ipato.invert4 = 0;\r\ncard->ipato.invert6 = 0;\r\nqeth_init_qdio_info(card);\r\nINIT_DELAYED_WORK(&card->buffer_reclaim_work, qeth_buffer_reclaim_work);\r\nINIT_WORK(&card->close_dev_work, qeth_close_dev_handler);\r\nreturn 0;\r\n}\r\nstatic void qeth_core_sl_print(struct seq_file *m, struct service_level *slr)\r\n{\r\nstruct qeth_card *card = container_of(slr, struct qeth_card,\r\nqeth_service_level);\r\nif (card->info.mcl_level[0])\r\nseq_printf(m, "qeth: %s firmware level %s\n",\r\nCARD_BUS_ID(card), card->info.mcl_level);\r\n}\r\nstatic struct qeth_card *qeth_alloc_card(void)\r\n{\r\nstruct qeth_card *card;\r\nQETH_DBF_TEXT(SETUP, 2, "alloccrd");\r\ncard = kzalloc(sizeof(struct qeth_card), GFP_DMA|GFP_KERNEL);\r\nif (!card)\r\ngoto out;\r\nQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\r\ncard->ip_tbd_list = kzalloc(sizeof(struct list_head), GFP_KERNEL);\r\nif (!card->ip_tbd_list) {\r\nQETH_DBF_TEXT(SETUP, 0, "iptbdnom");\r\ngoto out_card;\r\n}\r\nif (qeth_setup_channel(&card->read))\r\ngoto out_ip;\r\nif (qeth_setup_channel(&card->write))\r\ngoto out_channel;\r\ncard->options.layer2 = -1;\r\ncard->qeth_service_level.seq_print = qeth_core_sl_print;\r\nregister_service_level(&card->qeth_service_level);\r\nreturn card;\r\nout_channel:\r\nqeth_clean_channel(&card->read);\r\nout_ip:\r\nkfree(card->ip_tbd_list);\r\nout_card:\r\nkfree(card);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic int qeth_determine_card_type(struct qeth_card *card)\r\n{\r\nint i = 0;\r\nQETH_DBF_TEXT(SETUP, 2, "detcdtyp");\r\ncard->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;\r\ncard->qdio.default_out_queue = QETH_DEFAULT_QUEUE;\r\nwhile (known_devices[i][QETH_DEV_MODEL_IND]) {\r\nif ((CARD_RDEV(card)->id.dev_type ==\r\nknown_devices[i][QETH_DEV_TYPE_IND]) &&\r\n(CARD_RDEV(card)->id.dev_model ==\r\nknown_devices[i][QETH_DEV_MODEL_IND])) {\r\ncard->info.type = known_devices[i][QETH_DEV_MODEL_IND];\r\ncard->qdio.no_out_queues =\r\nknown_devices[i][QETH_QUEUE_NO_IND];\r\ncard->qdio.no_in_queues = 1;\r\ncard->info.is_multicast_different =\r\nknown_devices[i][QETH_MULTICAST_IND];\r\nqeth_update_from_chp_desc(card);\r\nreturn 0;\r\n}\r\ni++;\r\n}\r\ncard->info.type = QETH_CARD_TYPE_UNKNOWN;\r\ndev_err(&card->gdev->dev, "The adapter hardware is of an "\r\n"unknown type\n");\r\nreturn -ENOENT;\r\n}\r\nstatic int qeth_clear_channel(struct qeth_channel *channel)\r\n{\r\nunsigned long flags;\r\nstruct qeth_card *card;\r\nint rc;\r\ncard = CARD_FROM_CDEV(channel->ccwdev);\r\nQETH_CARD_TEXT(card, 3, "clearch");\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nrc = ccw_device_clear(channel->ccwdev, QETH_CLEAR_CHANNEL_PARM);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (rc)\r\nreturn rc;\r\nrc = wait_event_interruptible_timeout(card->wait_q,\r\nchannel->state == CH_STATE_STOPPED, QETH_TIMEOUT);\r\nif (rc == -ERESTARTSYS)\r\nreturn rc;\r\nif (channel->state != CH_STATE_STOPPED)\r\nreturn -ETIME;\r\nchannel->state = CH_STATE_DOWN;\r\nreturn 0;\r\n}\r\nstatic int qeth_halt_channel(struct qeth_channel *channel)\r\n{\r\nunsigned long flags;\r\nstruct qeth_card *card;\r\nint rc;\r\ncard = CARD_FROM_CDEV(channel->ccwdev);\r\nQETH_CARD_TEXT(card, 3, "haltch");\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nrc = ccw_device_halt(channel->ccwdev, QETH_HALT_CHANNEL_PARM);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (rc)\r\nreturn rc;\r\nrc = wait_event_interruptible_timeout(card->wait_q,\r\nchannel->state == CH_STATE_HALTED, QETH_TIMEOUT);\r\nif (rc == -ERESTARTSYS)\r\nreturn rc;\r\nif (channel->state != CH_STATE_HALTED)\r\nreturn -ETIME;\r\nreturn 0;\r\n}\r\nstatic int qeth_halt_channels(struct qeth_card *card)\r\n{\r\nint rc1 = 0, rc2 = 0, rc3 = 0;\r\nQETH_CARD_TEXT(card, 3, "haltchs");\r\nrc1 = qeth_halt_channel(&card->read);\r\nrc2 = qeth_halt_channel(&card->write);\r\nrc3 = qeth_halt_channel(&card->data);\r\nif (rc1)\r\nreturn rc1;\r\nif (rc2)\r\nreturn rc2;\r\nreturn rc3;\r\n}\r\nstatic int qeth_clear_channels(struct qeth_card *card)\r\n{\r\nint rc1 = 0, rc2 = 0, rc3 = 0;\r\nQETH_CARD_TEXT(card, 3, "clearchs");\r\nrc1 = qeth_clear_channel(&card->read);\r\nrc2 = qeth_clear_channel(&card->write);\r\nrc3 = qeth_clear_channel(&card->data);\r\nif (rc1)\r\nreturn rc1;\r\nif (rc2)\r\nreturn rc2;\r\nreturn rc3;\r\n}\r\nstatic int qeth_clear_halt_card(struct qeth_card *card, int halt)\r\n{\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 3, "clhacrd");\r\nif (halt)\r\nrc = qeth_halt_channels(card);\r\nif (rc)\r\nreturn rc;\r\nreturn qeth_clear_channels(card);\r\n}\r\nint qeth_qdio_clear_card(struct qeth_card *card, int use_halt)\r\n{\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 3, "qdioclr");\r\nswitch (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ESTABLISHED,\r\nQETH_QDIO_CLEANING)) {\r\ncase QETH_QDIO_ESTABLISHED:\r\nif (card->info.type == QETH_CARD_TYPE_IQD)\r\nrc = qdio_shutdown(CARD_DDEV(card),\r\nQDIO_FLAG_CLEANUP_USING_HALT);\r\nelse\r\nrc = qdio_shutdown(CARD_DDEV(card),\r\nQDIO_FLAG_CLEANUP_USING_CLEAR);\r\nif (rc)\r\nQETH_CARD_TEXT_(card, 3, "1err%d", rc);\r\natomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\r\nbreak;\r\ncase QETH_QDIO_CLEANING:\r\nreturn rc;\r\ndefault:\r\nbreak;\r\n}\r\nrc = qeth_clear_halt_card(card, use_halt);\r\nif (rc)\r\nQETH_CARD_TEXT_(card, 3, "2err%d", rc);\r\ncard->state = CARD_STATE_DOWN;\r\nreturn rc;\r\n}\r\nstatic int qeth_read_conf_data(struct qeth_card *card, void **buffer,\r\nint *length)\r\n{\r\nstruct ciw *ciw;\r\nchar *rcd_buf;\r\nint ret;\r\nstruct qeth_channel *channel = &card->data;\r\nunsigned long flags;\r\nciw = ccw_device_get_ciw(channel->ccwdev, CIW_TYPE_RCD);\r\nif (!ciw || ciw->cmd == 0)\r\nreturn -EOPNOTSUPP;\r\nrcd_buf = kzalloc(ciw->count, GFP_KERNEL | GFP_DMA);\r\nif (!rcd_buf)\r\nreturn -ENOMEM;\r\nchannel->ccw.cmd_code = ciw->cmd;\r\nchannel->ccw.cda = (__u32) __pa(rcd_buf);\r\nchannel->ccw.count = ciw->count;\r\nchannel->ccw.flags = CCW_FLAG_SLI;\r\nchannel->state = CH_STATE_RCD;\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nret = ccw_device_start_timeout(channel->ccwdev, &channel->ccw,\r\nQETH_RCD_PARM, LPM_ANYPATH, 0,\r\nQETH_RCD_TIMEOUT);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (!ret)\r\nwait_event(card->wait_q,\r\n(channel->state == CH_STATE_RCD_DONE ||\r\nchannel->state == CH_STATE_DOWN));\r\nif (channel->state == CH_STATE_DOWN)\r\nret = -EIO;\r\nelse\r\nchannel->state = CH_STATE_DOWN;\r\nif (ret) {\r\nkfree(rcd_buf);\r\n*buffer = NULL;\r\n*length = 0;\r\n} else {\r\n*length = ciw->count;\r\n*buffer = rcd_buf;\r\n}\r\nreturn ret;\r\n}\r\nstatic void qeth_configure_unitaddr(struct qeth_card *card, char *prcd)\r\n{\r\nQETH_DBF_TEXT(SETUP, 2, "cfgunit");\r\ncard->info.chpid = prcd[30];\r\ncard->info.unit_addr2 = prcd[31];\r\ncard->info.cula = prcd[63];\r\ncard->info.guestlan = ((prcd[0x10] == _ascebc['V']) &&\r\n(prcd[0x11] == _ascebc['M']));\r\n}\r\nstatic void qeth_configure_blkt_default(struct qeth_card *card, char *prcd)\r\n{\r\nQETH_DBF_TEXT(SETUP, 2, "cfgblkt");\r\nif (prcd[74] == 0xF0 && prcd[75] == 0xF0 &&\r\nprcd[76] >= 0xF1 && prcd[76] <= 0xF4) {\r\ncard->info.blkt.time_total = 0;\r\ncard->info.blkt.inter_packet = 0;\r\ncard->info.blkt.inter_packet_jumbo = 0;\r\n} else {\r\ncard->info.blkt.time_total = 250;\r\ncard->info.blkt.inter_packet = 5;\r\ncard->info.blkt.inter_packet_jumbo = 15;\r\n}\r\n}\r\nstatic void qeth_init_tokens(struct qeth_card *card)\r\n{\r\ncard->token.issuer_rm_w = 0x00010103UL;\r\ncard->token.cm_filter_w = 0x00010108UL;\r\ncard->token.cm_connection_w = 0x0001010aUL;\r\ncard->token.ulp_filter_w = 0x0001010bUL;\r\ncard->token.ulp_connection_w = 0x0001010dUL;\r\n}\r\nstatic void qeth_init_func_level(struct qeth_card *card)\r\n{\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_IQD:\r\ncard->info.func_level = QETH_IDX_FUNC_LEVEL_IQD;\r\nbreak;\r\ncase QETH_CARD_TYPE_OSD:\r\ncase QETH_CARD_TYPE_OSN:\r\ncard->info.func_level = QETH_IDX_FUNC_LEVEL_OSD;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int qeth_idx_activate_get_answer(struct qeth_channel *channel,\r\nvoid (*idx_reply_cb)(struct qeth_channel *,\r\nstruct qeth_cmd_buffer *))\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nunsigned long flags;\r\nint rc;\r\nstruct qeth_card *card;\r\nQETH_DBF_TEXT(SETUP, 2, "idxanswr");\r\ncard = CARD_FROM_CDEV(channel->ccwdev);\r\niob = qeth_get_buffer(channel);\r\niob->callback = idx_reply_cb;\r\nmemcpy(&channel->ccw, READ_CCW, sizeof(struct ccw1));\r\nchannel->ccw.count = QETH_BUFSIZE;\r\nchannel->ccw.cda = (__u32) __pa(iob->data);\r\nwait_event(card->wait_q,\r\natomic_cmpxchg(&channel->irq_pending, 0, 1) == 0);\r\nQETH_DBF_TEXT(SETUP, 6, "noirqpnd");\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nrc = ccw_device_start(channel->ccwdev,\r\n&channel->ccw, (addr_t) iob, 0, 0);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "Error2 in activating channel rc=%d\n", rc);\r\nQETH_DBF_TEXT_(SETUP, 2, "2err%d", rc);\r\natomic_set(&channel->irq_pending, 0);\r\nwake_up(&card->wait_q);\r\nreturn rc;\r\n}\r\nrc = wait_event_interruptible_timeout(card->wait_q,\r\nchannel->state == CH_STATE_UP, QETH_TIMEOUT);\r\nif (rc == -ERESTARTSYS)\r\nreturn rc;\r\nif (channel->state != CH_STATE_UP) {\r\nrc = -ETIME;\r\nQETH_DBF_TEXT_(SETUP, 2, "3err%d", rc);\r\nqeth_clear_cmd_buffers(channel);\r\n} else\r\nrc = 0;\r\nreturn rc;\r\n}\r\nstatic int qeth_idx_activate_channel(struct qeth_channel *channel,\r\nvoid (*idx_reply_cb)(struct qeth_channel *,\r\nstruct qeth_cmd_buffer *))\r\n{\r\nstruct qeth_card *card;\r\nstruct qeth_cmd_buffer *iob;\r\nunsigned long flags;\r\n__u16 temp;\r\n__u8 tmp;\r\nint rc;\r\nstruct ccw_dev_id temp_devid;\r\ncard = CARD_FROM_CDEV(channel->ccwdev);\r\nQETH_DBF_TEXT(SETUP, 2, "idxactch");\r\niob = qeth_get_buffer(channel);\r\niob->callback = idx_reply_cb;\r\nmemcpy(&channel->ccw, WRITE_CCW, sizeof(struct ccw1));\r\nchannel->ccw.count = IDX_ACTIVATE_SIZE;\r\nchannel->ccw.cda = (__u32) __pa(iob->data);\r\nif (channel == &card->write) {\r\nmemcpy(iob->data, IDX_ACTIVATE_WRITE, IDX_ACTIVATE_SIZE);\r\nmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\r\n&card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\r\ncard->seqno.trans_hdr++;\r\n} else {\r\nmemcpy(iob->data, IDX_ACTIVATE_READ, IDX_ACTIVATE_SIZE);\r\nmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\r\n&card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\r\n}\r\ntmp = ((__u8)card->info.portno) | 0x80;\r\nmemcpy(QETH_IDX_ACT_PNO(iob->data), &tmp, 1);\r\nmemcpy(QETH_IDX_ACT_ISSUER_RM_TOKEN(iob->data),\r\n&card->token.issuer_rm_w, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_IDX_ACT_FUNC_LEVEL(iob->data),\r\n&card->info.func_level, sizeof(__u16));\r\nccw_device_get_id(CARD_DDEV(card), &temp_devid);\r\nmemcpy(QETH_IDX_ACT_QDIO_DEV_CUA(iob->data), &temp_devid.devno, 2);\r\ntemp = (card->info.cula << 8) + card->info.unit_addr2;\r\nmemcpy(QETH_IDX_ACT_QDIO_DEV_REALADDR(iob->data), &temp, 2);\r\nwait_event(card->wait_q,\r\natomic_cmpxchg(&channel->irq_pending, 0, 1) == 0);\r\nQETH_DBF_TEXT(SETUP, 6, "noirqpnd");\r\nspin_lock_irqsave(get_ccwdev_lock(channel->ccwdev), flags);\r\nrc = ccw_device_start(channel->ccwdev,\r\n&channel->ccw, (addr_t) iob, 0, 0);\r\nspin_unlock_irqrestore(get_ccwdev_lock(channel->ccwdev), flags);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "Error1 in activating channel. rc=%d\n",\r\nrc);\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\natomic_set(&channel->irq_pending, 0);\r\nwake_up(&card->wait_q);\r\nreturn rc;\r\n}\r\nrc = wait_event_interruptible_timeout(card->wait_q,\r\nchannel->state == CH_STATE_ACTIVATING, QETH_TIMEOUT);\r\nif (rc == -ERESTARTSYS)\r\nreturn rc;\r\nif (channel->state != CH_STATE_ACTIVATING) {\r\ndev_warn(&channel->ccwdev->dev, "The qeth device driver"\r\n" failed to recover an error on the device\n");\r\nQETH_DBF_MESSAGE(2, "%s IDX activate timed out\n",\r\ndev_name(&channel->ccwdev->dev));\r\nQETH_DBF_TEXT_(SETUP, 2, "2err%d", -ETIME);\r\nqeth_clear_cmd_buffers(channel);\r\nreturn -ETIME;\r\n}\r\nreturn qeth_idx_activate_get_answer(channel, idx_reply_cb);\r\n}\r\nstatic int qeth_peer_func_level(int level)\r\n{\r\nif ((level & 0xff) == 8)\r\nreturn (level & 0xff) + 0x400;\r\nif (((level >> 8) & 3) == 1)\r\nreturn (level & 0xff) + 0x200;\r\nreturn level;\r\n}\r\nstatic void qeth_idx_write_cb(struct qeth_channel *channel,\r\nstruct qeth_cmd_buffer *iob)\r\n{\r\nstruct qeth_card *card;\r\n__u16 temp;\r\nQETH_DBF_TEXT(SETUP , 2, "idxwrcb");\r\nif (channel->state == CH_STATE_DOWN) {\r\nchannel->state = CH_STATE_ACTIVATING;\r\ngoto out;\r\n}\r\ncard = CARD_FROM_CDEV(channel->ccwdev);\r\nif (!(QETH_IS_IDX_ACT_POS_REPLY(iob->data))) {\r\nif (QETH_IDX_ACT_CAUSE_CODE(iob->data) == QETH_IDX_ACT_ERR_EXCL)\r\ndev_err(&card->write.ccwdev->dev,\r\n"The adapter is used exclusively by another "\r\n"host\n");\r\nelse\r\nQETH_DBF_MESSAGE(2, "%s IDX_ACTIVATE on write channel:"\r\n" negative reply\n",\r\ndev_name(&card->write.ccwdev->dev));\r\ngoto out;\r\n}\r\nmemcpy(&temp, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);\r\nif ((temp & ~0x0100) != qeth_peer_func_level(card->info.func_level)) {\r\nQETH_DBF_MESSAGE(2, "%s IDX_ACTIVATE on write channel: "\r\n"function level mismatch (sent: 0x%x, received: "\r\n"0x%x)\n", dev_name(&card->write.ccwdev->dev),\r\ncard->info.func_level, temp);\r\ngoto out;\r\n}\r\nchannel->state = CH_STATE_UP;\r\nout:\r\nqeth_release_buffer(channel, iob);\r\n}\r\nstatic void qeth_idx_read_cb(struct qeth_channel *channel,\r\nstruct qeth_cmd_buffer *iob)\r\n{\r\nstruct qeth_card *card;\r\n__u16 temp;\r\nQETH_DBF_TEXT(SETUP , 2, "idxrdcb");\r\nif (channel->state == CH_STATE_DOWN) {\r\nchannel->state = CH_STATE_ACTIVATING;\r\ngoto out;\r\n}\r\ncard = CARD_FROM_CDEV(channel->ccwdev);\r\nif (qeth_check_idx_response(card, iob->data))\r\ngoto out;\r\nif (!(QETH_IS_IDX_ACT_POS_REPLY(iob->data))) {\r\nswitch (QETH_IDX_ACT_CAUSE_CODE(iob->data)) {\r\ncase QETH_IDX_ACT_ERR_EXCL:\r\ndev_err(&card->write.ccwdev->dev,\r\n"The adapter is used exclusively by another "\r\n"host\n");\r\nbreak;\r\ncase QETH_IDX_ACT_ERR_AUTH:\r\ncase QETH_IDX_ACT_ERR_AUTH_USER:\r\ndev_err(&card->read.ccwdev->dev,\r\n"Setting the device online failed because of "\r\n"insufficient authorization\n");\r\nbreak;\r\ndefault:\r\nQETH_DBF_MESSAGE(2, "%s IDX_ACTIVATE on read channel:"\r\n" negative reply\n",\r\ndev_name(&card->read.ccwdev->dev));\r\n}\r\nQETH_CARD_TEXT_(card, 2, "idxread%c",\r\nQETH_IDX_ACT_CAUSE_CODE(iob->data));\r\ngoto out;\r\n}\r\nif ((!QETH_IDX_NO_PORTNAME_REQUIRED(iob->data)) ||\r\n(card->info.type == QETH_CARD_TYPE_OSD))\r\ncard->info.portname_required = 1;\r\nmemcpy(&temp, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);\r\nif (temp != qeth_peer_func_level(card->info.func_level)) {\r\nQETH_DBF_MESSAGE(2, "%s IDX_ACTIVATE on read channel: function "\r\n"level mismatch (sent: 0x%x, received: 0x%x)\n",\r\ndev_name(&card->read.ccwdev->dev),\r\ncard->info.func_level, temp);\r\ngoto out;\r\n}\r\nmemcpy(&card->token.issuer_rm_r,\r\nQETH_IDX_ACT_ISSUER_RM_TOKEN(iob->data),\r\nQETH_MPC_TOKEN_LENGTH);\r\nmemcpy(&card->info.mcl_level[0],\r\nQETH_IDX_REPLY_LEVEL(iob->data), QETH_MCL_LENGTH);\r\nchannel->state = CH_STATE_UP;\r\nout:\r\nqeth_release_buffer(channel, iob);\r\n}\r\nvoid qeth_prepare_control_data(struct qeth_card *card, int len,\r\nstruct qeth_cmd_buffer *iob)\r\n{\r\nqeth_setup_ccw(&card->write, iob->data, len);\r\niob->callback = qeth_release_buffer;\r\nmemcpy(QETH_TRANSPORT_HEADER_SEQ_NO(iob->data),\r\n&card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);\r\ncard->seqno.trans_hdr++;\r\nmemcpy(QETH_PDU_HEADER_SEQ_NO(iob->data),\r\n&card->seqno.pdu_hdr, QETH_SEQ_NO_LENGTH);\r\ncard->seqno.pdu_hdr++;\r\nmemcpy(QETH_PDU_HEADER_ACK_SEQ_NO(iob->data),\r\n&card->seqno.pdu_hdr_ack, QETH_SEQ_NO_LENGTH);\r\nQETH_DBF_HEX(CTRL, 2, iob->data, QETH_DBF_CTRL_LEN);\r\n}\r\nint qeth_send_control_data(struct qeth_card *card, int len,\r\nstruct qeth_cmd_buffer *iob,\r\nint (*reply_cb)(struct qeth_card *, struct qeth_reply *,\r\nunsigned long),\r\nvoid *reply_param)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nstruct qeth_reply *reply = NULL;\r\nunsigned long timeout, event_timeout;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 2, "sendctl");\r\nif (card->read_or_write_problem) {\r\nqeth_release_buffer(iob->channel, iob);\r\nreturn -EIO;\r\n}\r\nreply = qeth_alloc_reply(card);\r\nif (!reply) {\r\nreturn -ENOMEM;\r\n}\r\nreply->callback = reply_cb;\r\nreply->param = reply_param;\r\nif (card->state == CARD_STATE_DOWN)\r\nreply->seqno = QETH_IDX_COMMAND_SEQNO;\r\nelse\r\nreply->seqno = card->seqno.ipa++;\r\ninit_waitqueue_head(&reply->wait_q);\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_add_tail(&reply->list, &card->cmd_waiter_list);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nQETH_DBF_HEX(CTRL, 2, iob->data, QETH_DBF_CTRL_LEN);\r\nwhile (atomic_cmpxchg(&card->write.irq_pending, 0, 1)) ;\r\nqeth_prepare_control_data(card, len, iob);\r\nif (IS_IPA(iob->data))\r\nevent_timeout = QETH_IPA_TIMEOUT;\r\nelse\r\nevent_timeout = QETH_TIMEOUT;\r\ntimeout = jiffies + event_timeout;\r\nQETH_CARD_TEXT(card, 6, "noirqpnd");\r\nspin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);\r\nrc = ccw_device_start(card->write.ccwdev, &card->write.ccw,\r\n(addr_t) iob, 0, 0);\r\nspin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "%s qeth_send_control_data: "\r\n"ccw_device_start rc = %i\n",\r\ndev_name(&card->write.ccwdev->dev), rc);\r\nQETH_CARD_TEXT_(card, 2, " err%d", rc);\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_del_init(&reply->list);\r\nqeth_put_reply(reply);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nqeth_release_buffer(iob->channel, iob);\r\natomic_set(&card->write.irq_pending, 0);\r\nwake_up(&card->wait_q);\r\nreturn rc;\r\n}\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\nif ((cmd->hdr.command == IPA_CMD_SETIP) &&\r\n(cmd->hdr.prot_version == QETH_PROT_IPV4)) {\r\nif (!wait_event_timeout(reply->wait_q,\r\natomic_read(&reply->received), event_timeout))\r\ngoto time_err;\r\n} else {\r\nwhile (!atomic_read(&reply->received)) {\r\nif (time_after(jiffies, timeout))\r\ngoto time_err;\r\ncpu_relax();\r\n}\r\n}\r\nif (reply->rc == -EIO)\r\ngoto error;\r\nrc = reply->rc;\r\nqeth_put_reply(reply);\r\nreturn rc;\r\ntime_err:\r\nreply->rc = -ETIME;\r\nspin_lock_irqsave(&reply->card->lock, flags);\r\nlist_del_init(&reply->list);\r\nspin_unlock_irqrestore(&reply->card->lock, flags);\r\natomic_inc(&reply->received);\r\nerror:\r\natomic_set(&card->write.irq_pending, 0);\r\nqeth_release_buffer(iob->channel, iob);\r\ncard->write.buf_no = (card->write.buf_no + 1) % QETH_CMD_BUFFER_NO;\r\nrc = reply->rc;\r\nqeth_put_reply(reply);\r\nreturn rc;\r\n}\r\nstatic int qeth_cm_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "cmenblcb");\r\niob = (struct qeth_cmd_buffer *) data;\r\nmemcpy(&card->token.cm_filter_r,\r\nQETH_CM_ENABLE_RESP_FILTER_TOKEN(iob->data),\r\nQETH_MPC_TOKEN_LENGTH);\r\nQETH_DBF_TEXT_(SETUP, 2, " rc%d", iob->rc);\r\nreturn 0;\r\n}\r\nstatic int qeth_cm_enable(struct qeth_card *card)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "cmenable");\r\niob = qeth_wait_for_buffer(&card->write);\r\nmemcpy(iob->data, CM_ENABLE, CM_ENABLE_SIZE);\r\nmemcpy(QETH_CM_ENABLE_ISSUER_RM_TOKEN(iob->data),\r\n&card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_CM_ENABLE_FILTER_TOKEN(iob->data),\r\n&card->token.cm_filter_w, QETH_MPC_TOKEN_LENGTH);\r\nrc = qeth_send_control_data(card, CM_ENABLE_SIZE, iob,\r\nqeth_cm_enable_cb, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_cm_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "cmsetpcb");\r\niob = (struct qeth_cmd_buffer *) data;\r\nmemcpy(&card->token.cm_connection_r,\r\nQETH_CM_SETUP_RESP_DEST_ADDR(iob->data),\r\nQETH_MPC_TOKEN_LENGTH);\r\nQETH_DBF_TEXT_(SETUP, 2, " rc%d", iob->rc);\r\nreturn 0;\r\n}\r\nstatic int qeth_cm_setup(struct qeth_card *card)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "cmsetup");\r\niob = qeth_wait_for_buffer(&card->write);\r\nmemcpy(iob->data, CM_SETUP, CM_SETUP_SIZE);\r\nmemcpy(QETH_CM_SETUP_DEST_ADDR(iob->data),\r\n&card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_CM_SETUP_CONNECTION_TOKEN(iob->data),\r\n&card->token.cm_connection_w, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_CM_SETUP_FILTER_TOKEN(iob->data),\r\n&card->token.cm_filter_r, QETH_MPC_TOKEN_LENGTH);\r\nrc = qeth_send_control_data(card, CM_SETUP_SIZE, iob,\r\nqeth_cm_setup_cb, NULL);\r\nreturn rc;\r\n}\r\nstatic inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)\r\n{\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_UNKNOWN:\r\nreturn 1500;\r\ncase QETH_CARD_TYPE_IQD:\r\nreturn card->info.max_mtu;\r\ncase QETH_CARD_TYPE_OSD:\r\nswitch (card->info.link_type) {\r\ncase QETH_LINK_TYPE_HSTR:\r\ncase QETH_LINK_TYPE_LANE_TR:\r\nreturn 2000;\r\ndefault:\r\nreturn card->options.layer2 ? 1500 : 1492;\r\n}\r\ncase QETH_CARD_TYPE_OSM:\r\ncase QETH_CARD_TYPE_OSX:\r\nreturn card->options.layer2 ? 1500 : 1492;\r\ndefault:\r\nreturn 1500;\r\n}\r\n}\r\nstatic inline int qeth_get_mtu_outof_framesize(int framesize)\r\n{\r\nswitch (framesize) {\r\ncase 0x4000:\r\nreturn 8192;\r\ncase 0x6000:\r\nreturn 16384;\r\ncase 0xa000:\r\nreturn 32768;\r\ncase 0xffff:\r\nreturn 57344;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline int qeth_mtu_is_valid(struct qeth_card *card, int mtu)\r\n{\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_OSD:\r\ncase QETH_CARD_TYPE_OSM:\r\ncase QETH_CARD_TYPE_OSX:\r\ncase QETH_CARD_TYPE_IQD:\r\nreturn ((mtu >= 576) &&\r\n(mtu <= card->info.max_mtu));\r\ncase QETH_CARD_TYPE_OSN:\r\ncase QETH_CARD_TYPE_UNKNOWN:\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int qeth_ulp_enable_cb(struct qeth_card *card, struct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\n__u16 mtu, framesize;\r\n__u16 len;\r\n__u8 link_type;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "ulpenacb");\r\niob = (struct qeth_cmd_buffer *) data;\r\nmemcpy(&card->token.ulp_filter_r,\r\nQETH_ULP_ENABLE_RESP_FILTER_TOKEN(iob->data),\r\nQETH_MPC_TOKEN_LENGTH);\r\nif (card->info.type == QETH_CARD_TYPE_IQD) {\r\nmemcpy(&framesize, QETH_ULP_ENABLE_RESP_MAX_MTU(iob->data), 2);\r\nmtu = qeth_get_mtu_outof_framesize(framesize);\r\nif (!mtu) {\r\niob->rc = -EINVAL;\r\nQETH_DBF_TEXT_(SETUP, 2, " rc%d", iob->rc);\r\nreturn 0;\r\n}\r\nif (card->info.initial_mtu && (card->info.initial_mtu != mtu)) {\r\nif (card->dev &&\r\n((card->dev->mtu == card->info.initial_mtu) ||\r\n(card->dev->mtu > mtu)))\r\ncard->dev->mtu = mtu;\r\nqeth_free_qdio_buffers(card);\r\n}\r\ncard->info.initial_mtu = mtu;\r\ncard->info.max_mtu = mtu;\r\ncard->qdio.in_buf_size = mtu + 2 * PAGE_SIZE;\r\n} else {\r\ncard->info.max_mtu = *(__u16 *)QETH_ULP_ENABLE_RESP_MAX_MTU(\r\niob->data);\r\ncard->info.initial_mtu = min(card->info.max_mtu,\r\nqeth_get_initial_mtu_for_card(card));\r\ncard->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;\r\n}\r\nmemcpy(&len, QETH_ULP_ENABLE_RESP_DIFINFO_LEN(iob->data), 2);\r\nif (len >= QETH_MPC_DIFINFO_LEN_INDICATES_LINK_TYPE) {\r\nmemcpy(&link_type,\r\nQETH_ULP_ENABLE_RESP_LINK_TYPE(iob->data), 1);\r\ncard->info.link_type = link_type;\r\n} else\r\ncard->info.link_type = 0;\r\nQETH_DBF_TEXT_(SETUP, 2, "link%d", card->info.link_type);\r\nQETH_DBF_TEXT_(SETUP, 2, " rc%d", iob->rc);\r\nreturn 0;\r\n}\r\nstatic int qeth_ulp_enable(struct qeth_card *card)\r\n{\r\nint rc;\r\nchar prot_type;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "ulpenabl");\r\niob = qeth_wait_for_buffer(&card->write);\r\nmemcpy(iob->data, ULP_ENABLE, ULP_ENABLE_SIZE);\r\n*(QETH_ULP_ENABLE_LINKNUM(iob->data)) =\r\n(__u8) card->info.portno;\r\nif (card->options.layer2)\r\nif (card->info.type == QETH_CARD_TYPE_OSN)\r\nprot_type = QETH_PROT_OSN2;\r\nelse\r\nprot_type = QETH_PROT_LAYER2;\r\nelse\r\nprot_type = QETH_PROT_TCPIP;\r\nmemcpy(QETH_ULP_ENABLE_PROT_TYPE(iob->data), &prot_type, 1);\r\nmemcpy(QETH_ULP_ENABLE_DEST_ADDR(iob->data),\r\n&card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_ULP_ENABLE_FILTER_TOKEN(iob->data),\r\n&card->token.ulp_filter_w, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_ULP_ENABLE_PORTNAME_AND_LL(iob->data),\r\ncard->info.portname, 9);\r\nrc = qeth_send_control_data(card, ULP_ENABLE_SIZE, iob,\r\nqeth_ulp_enable_cb, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_ulp_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "ulpstpcb");\r\niob = (struct qeth_cmd_buffer *) data;\r\nmemcpy(&card->token.ulp_connection_r,\r\nQETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\r\nQETH_MPC_TOKEN_LENGTH);\r\nif (!strncmp("00S", QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\r\n3)) {\r\nQETH_DBF_TEXT(SETUP, 2, "olmlimit");\r\ndev_err(&card->gdev->dev, "A connection could not be "\r\n"established because of an OLM limit\n");\r\niob->rc = -EMLINK;\r\n}\r\nQETH_DBF_TEXT_(SETUP, 2, " rc%d", iob->rc);\r\nreturn 0;\r\n}\r\nstatic int qeth_ulp_setup(struct qeth_card *card)\r\n{\r\nint rc;\r\n__u16 temp;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct ccw_dev_id dev_id;\r\nQETH_DBF_TEXT(SETUP, 2, "ulpsetup");\r\niob = qeth_wait_for_buffer(&card->write);\r\nmemcpy(iob->data, ULP_SETUP, ULP_SETUP_SIZE);\r\nmemcpy(QETH_ULP_SETUP_DEST_ADDR(iob->data),\r\n&card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_ULP_SETUP_CONNECTION_TOKEN(iob->data),\r\n&card->token.ulp_connection_w, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_ULP_SETUP_FILTER_TOKEN(iob->data),\r\n&card->token.ulp_filter_r, QETH_MPC_TOKEN_LENGTH);\r\nccw_device_get_id(CARD_DDEV(card), &dev_id);\r\nmemcpy(QETH_ULP_SETUP_CUA(iob->data), &dev_id.devno, 2);\r\ntemp = (card->info.cula << 8) + card->info.unit_addr2;\r\nmemcpy(QETH_ULP_SETUP_REAL_DEVADDR(iob->data), &temp, 2);\r\nrc = qeth_send_control_data(card, ULP_SETUP_SIZE, iob,\r\nqeth_ulp_setup_cb, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_init_qdio_out_buf(struct qeth_qdio_out_q *q, int bidx)\r\n{\r\nint rc;\r\nstruct qeth_qdio_out_buffer *newbuf;\r\nrc = 0;\r\nnewbuf = kmem_cache_zalloc(qeth_qdio_outbuf_cache, GFP_ATOMIC);\r\nif (!newbuf) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nnewbuf->buffer = q->qdio_bufs[bidx];\r\nskb_queue_head_init(&newbuf->skb_list);\r\nlockdep_set_class(&newbuf->skb_list.lock, &qdio_out_skb_queue_key);\r\nnewbuf->q = q;\r\nnewbuf->aob = NULL;\r\nnewbuf->next_pending = q->bufs[bidx];\r\natomic_set(&newbuf->state, QETH_QDIO_BUF_EMPTY);\r\nq->bufs[bidx] = newbuf;\r\nif (q->bufstates) {\r\nq->bufstates[bidx].user = newbuf;\r\nQETH_CARD_TEXT_(q->card, 2, "nbs%d", bidx);\r\nQETH_CARD_TEXT_(q->card, 2, "%lx", (long) newbuf);\r\nQETH_CARD_TEXT_(q->card, 2, "%lx",\r\n(long) newbuf->next_pending);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic void qeth_free_qdio_out_buf(struct qeth_qdio_out_q *q)\r\n{\r\nif (!q)\r\nreturn;\r\nqdio_free_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q);\r\nkfree(q);\r\n}\r\nstatic struct qeth_qdio_out_q *qeth_alloc_qdio_out_buf(void)\r\n{\r\nstruct qeth_qdio_out_q *q = kzalloc(sizeof(*q), GFP_KERNEL);\r\nif (!q)\r\nreturn NULL;\r\nif (qdio_alloc_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q)) {\r\nkfree(q);\r\nreturn NULL;\r\n}\r\nreturn q;\r\n}\r\nstatic int qeth_alloc_qdio_buffers(struct qeth_card *card)\r\n{\r\nint i, j;\r\nQETH_DBF_TEXT(SETUP, 2, "allcqdbf");\r\nif (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED,\r\nQETH_QDIO_ALLOCATED) != QETH_QDIO_UNINITIALIZED)\r\nreturn 0;\r\nQETH_DBF_TEXT(SETUP, 2, "inq");\r\ncard->qdio.in_q = qeth_alloc_qdio_queue();\r\nif (!card->qdio.in_q)\r\ngoto out_nomem;\r\nif (qeth_alloc_buffer_pool(card))\r\ngoto out_freeinq;\r\ncard->qdio.out_qs =\r\nkzalloc(card->qdio.no_out_queues *\r\nsizeof(struct qeth_qdio_out_q *), GFP_KERNEL);\r\nif (!card->qdio.out_qs)\r\ngoto out_freepool;\r\nfor (i = 0; i < card->qdio.no_out_queues; ++i) {\r\ncard->qdio.out_qs[i] = qeth_alloc_qdio_out_buf();\r\nif (!card->qdio.out_qs[i])\r\ngoto out_freeoutq;\r\nQETH_DBF_TEXT_(SETUP, 2, "outq %i", i);\r\nQETH_DBF_HEX(SETUP, 2, &card->qdio.out_qs[i], sizeof(void *));\r\ncard->qdio.out_qs[i]->queue_no = i;\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\r\nWARN_ON(card->qdio.out_qs[i]->bufs[j] != NULL);\r\nif (qeth_init_qdio_out_buf(card->qdio.out_qs[i], j))\r\ngoto out_freeoutqbufs;\r\n}\r\n}\r\nif (qeth_alloc_cq(card))\r\ngoto out_freeoutq;\r\nreturn 0;\r\nout_freeoutqbufs:\r\nwhile (j > 0) {\r\n--j;\r\nkmem_cache_free(qeth_qdio_outbuf_cache,\r\ncard->qdio.out_qs[i]->bufs[j]);\r\ncard->qdio.out_qs[i]->bufs[j] = NULL;\r\n}\r\nout_freeoutq:\r\nwhile (i > 0) {\r\nqeth_free_qdio_out_buf(card->qdio.out_qs[--i]);\r\nqeth_clear_outq_buffers(card->qdio.out_qs[i], 1);\r\n}\r\nkfree(card->qdio.out_qs);\r\ncard->qdio.out_qs = NULL;\r\nout_freepool:\r\nqeth_free_buffer_pool(card);\r\nout_freeinq:\r\nqeth_free_qdio_queue(card->qdio.in_q);\r\ncard->qdio.in_q = NULL;\r\nout_nomem:\r\natomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);\r\nreturn -ENOMEM;\r\n}\r\nstatic void qeth_free_qdio_buffers(struct qeth_card *card)\r\n{\r\nint i, j;\r\nif (atomic_xchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED) ==\r\nQETH_QDIO_UNINITIALIZED)\r\nreturn;\r\nqeth_free_cq(card);\r\ncancel_delayed_work_sync(&card->buffer_reclaim_work);\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\r\nif (card->qdio.in_q->bufs[j].rx_skb)\r\ndev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb);\r\n}\r\nqeth_free_qdio_queue(card->qdio.in_q);\r\ncard->qdio.in_q = NULL;\r\nqeth_free_buffer_pool(card);\r\nif (card->qdio.out_qs) {\r\nfor (i = 0; i < card->qdio.no_out_queues; ++i) {\r\nqeth_clear_outq_buffers(card->qdio.out_qs[i], 1);\r\nqeth_free_qdio_out_buf(card->qdio.out_qs[i]);\r\n}\r\nkfree(card->qdio.out_qs);\r\ncard->qdio.out_qs = NULL;\r\n}\r\n}\r\nstatic void qeth_create_qib_param_field(struct qeth_card *card,\r\nchar *param_field)\r\n{\r\nparam_field[0] = _ascebc['P'];\r\nparam_field[1] = _ascebc['C'];\r\nparam_field[2] = _ascebc['I'];\r\nparam_field[3] = _ascebc['T'];\r\n*((unsigned int *) (&param_field[4])) = QETH_PCI_THRESHOLD_A(card);\r\n*((unsigned int *) (&param_field[8])) = QETH_PCI_THRESHOLD_B(card);\r\n*((unsigned int *) (&param_field[12])) = QETH_PCI_TIMER_VALUE(card);\r\n}\r\nstatic void qeth_create_qib_param_field_blkt(struct qeth_card *card,\r\nchar *param_field)\r\n{\r\nparam_field[16] = _ascebc['B'];\r\nparam_field[17] = _ascebc['L'];\r\nparam_field[18] = _ascebc['K'];\r\nparam_field[19] = _ascebc['T'];\r\n*((unsigned int *) (&param_field[20])) = card->info.blkt.time_total;\r\n*((unsigned int *) (&param_field[24])) = card->info.blkt.inter_packet;\r\n*((unsigned int *) (&param_field[28])) =\r\ncard->info.blkt.inter_packet_jumbo;\r\n}\r\nstatic int qeth_qdio_activate(struct qeth_card *card)\r\n{\r\nQETH_DBF_TEXT(SETUP, 3, "qdioact");\r\nreturn qdio_activate(CARD_DDEV(card));\r\n}\r\nstatic int qeth_dm_act(struct qeth_card *card)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "dmact");\r\niob = qeth_wait_for_buffer(&card->write);\r\nmemcpy(iob->data, DM_ACT, DM_ACT_SIZE);\r\nmemcpy(QETH_DM_ACT_DEST_ADDR(iob->data),\r\n&card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\r\nmemcpy(QETH_DM_ACT_CONNECTION_TOKEN(iob->data),\r\n&card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\r\nrc = qeth_send_control_data(card, DM_ACT_SIZE, iob, NULL, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_mpc_initialize(struct qeth_card *card)\r\n{\r\nint rc;\r\nQETH_DBF_TEXT(SETUP, 2, "mpcinit");\r\nrc = qeth_issue_next_read(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\nreturn rc;\r\n}\r\nrc = qeth_cm_enable(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "2err%d", rc);\r\ngoto out_qdio;\r\n}\r\nrc = qeth_cm_setup(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "3err%d", rc);\r\ngoto out_qdio;\r\n}\r\nrc = qeth_ulp_enable(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "4err%d", rc);\r\ngoto out_qdio;\r\n}\r\nrc = qeth_ulp_setup(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "5err%d", rc);\r\ngoto out_qdio;\r\n}\r\nrc = qeth_alloc_qdio_buffers(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "5err%d", rc);\r\ngoto out_qdio;\r\n}\r\nrc = qeth_qdio_establish(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "6err%d", rc);\r\nqeth_free_qdio_buffers(card);\r\ngoto out_qdio;\r\n}\r\nrc = qeth_qdio_activate(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "7err%d", rc);\r\ngoto out_qdio;\r\n}\r\nrc = qeth_dm_act(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "8err%d", rc);\r\ngoto out_qdio;\r\n}\r\nreturn 0;\r\nout_qdio:\r\nqeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);\r\nqdio_free(CARD_DDEV(card));\r\nreturn rc;\r\n}\r\nstatic void qeth_print_status_with_portname(struct qeth_card *card)\r\n{\r\nchar dbf_text[15];\r\nint i;\r\nsprintf(dbf_text, "%s", card->info.portname + 1);\r\nfor (i = 0; i < 8; i++)\r\ndbf_text[i] =\r\n(char) _ebcasc[(__u8) dbf_text[i]];\r\ndbf_text[8] = 0;\r\ndev_info(&card->gdev->dev, "Device is a%s card%s%s%s\n"\r\n"with link type %s (portname: %s)\n",\r\nqeth_get_cardname(card),\r\n(card->info.mcl_level[0]) ? " (level: " : "",\r\n(card->info.mcl_level[0]) ? card->info.mcl_level : "",\r\n(card->info.mcl_level[0]) ? ")" : "",\r\nqeth_get_cardname_short(card),\r\ndbf_text);\r\n}\r\nstatic void qeth_print_status_no_portname(struct qeth_card *card)\r\n{\r\nif (card->info.portname[0])\r\ndev_info(&card->gdev->dev, "Device is a%s "\r\n"card%s%s%s\nwith link type %s "\r\n"(no portname needed by interface).\n",\r\nqeth_get_cardname(card),\r\n(card->info.mcl_level[0]) ? " (level: " : "",\r\n(card->info.mcl_level[0]) ? card->info.mcl_level : "",\r\n(card->info.mcl_level[0]) ? ")" : "",\r\nqeth_get_cardname_short(card));\r\nelse\r\ndev_info(&card->gdev->dev, "Device is a%s "\r\n"card%s%s%s\nwith link type %s.\n",\r\nqeth_get_cardname(card),\r\n(card->info.mcl_level[0]) ? " (level: " : "",\r\n(card->info.mcl_level[0]) ? card->info.mcl_level : "",\r\n(card->info.mcl_level[0]) ? ")" : "",\r\nqeth_get_cardname_short(card));\r\n}\r\nvoid qeth_print_status_message(struct qeth_card *card)\r\n{\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_OSD:\r\ncase QETH_CARD_TYPE_OSM:\r\ncase QETH_CARD_TYPE_OSX:\r\nif (!card->info.mcl_level[0]) {\r\nsprintf(card->info.mcl_level, "%02x%02x",\r\ncard->info.mcl_level[2],\r\ncard->info.mcl_level[3]);\r\ncard->info.mcl_level[QETH_MCL_LENGTH] = 0;\r\nbreak;\r\n}\r\ncase QETH_CARD_TYPE_IQD:\r\nif ((card->info.guestlan) ||\r\n(card->info.mcl_level[0] & 0x80)) {\r\ncard->info.mcl_level[0] = (char) _ebcasc[(__u8)\r\ncard->info.mcl_level[0]];\r\ncard->info.mcl_level[1] = (char) _ebcasc[(__u8)\r\ncard->info.mcl_level[1]];\r\ncard->info.mcl_level[2] = (char) _ebcasc[(__u8)\r\ncard->info.mcl_level[2]];\r\ncard->info.mcl_level[3] = (char) _ebcasc[(__u8)\r\ncard->info.mcl_level[3]];\r\ncard->info.mcl_level[QETH_MCL_LENGTH] = 0;\r\n}\r\nbreak;\r\ndefault:\r\nmemset(&card->info.mcl_level[0], 0, QETH_MCL_LENGTH + 1);\r\n}\r\nif (card->info.portname_required)\r\nqeth_print_status_with_portname(card);\r\nelse\r\nqeth_print_status_no_portname(card);\r\n}\r\nstatic void qeth_initialize_working_pool_list(struct qeth_card *card)\r\n{\r\nstruct qeth_buffer_pool_entry *entry;\r\nQETH_CARD_TEXT(card, 5, "inwrklst");\r\nlist_for_each_entry(entry,\r\n&card->qdio.init_pool.entry_list, init_list) {\r\nqeth_put_buffer_pool_entry(card, entry);\r\n}\r\n}\r\nstatic inline struct qeth_buffer_pool_entry *qeth_find_free_buffer_pool_entry(\r\nstruct qeth_card *card)\r\n{\r\nstruct list_head *plh;\r\nstruct qeth_buffer_pool_entry *entry;\r\nint i, free;\r\nstruct page *page;\r\nif (list_empty(&card->qdio.in_buf_pool.entry_list))\r\nreturn NULL;\r\nlist_for_each(plh, &card->qdio.in_buf_pool.entry_list) {\r\nentry = list_entry(plh, struct qeth_buffer_pool_entry, list);\r\nfree = 1;\r\nfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\r\nif (page_count(virt_to_page(entry->elements[i])) > 1) {\r\nfree = 0;\r\nbreak;\r\n}\r\n}\r\nif (free) {\r\nlist_del_init(&entry->list);\r\nreturn entry;\r\n}\r\n}\r\nentry = list_entry(card->qdio.in_buf_pool.entry_list.next,\r\nstruct qeth_buffer_pool_entry, list);\r\nfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\r\nif (page_count(virt_to_page(entry->elements[i])) > 1) {\r\npage = alloc_page(GFP_ATOMIC);\r\nif (!page) {\r\nreturn NULL;\r\n} else {\r\nfree_page((unsigned long)entry->elements[i]);\r\nentry->elements[i] = page_address(page);\r\nif (card->options.performance_stats)\r\ncard->perf_stats.sg_alloc_page_rx++;\r\n}\r\n}\r\n}\r\nlist_del_init(&entry->list);\r\nreturn entry;\r\n}\r\nstatic int qeth_init_input_buffer(struct qeth_card *card,\r\nstruct qeth_qdio_buffer *buf)\r\n{\r\nstruct qeth_buffer_pool_entry *pool_entry;\r\nint i;\r\nif ((card->options.cq == QETH_CQ_ENABLED) && (!buf->rx_skb)) {\r\nbuf->rx_skb = dev_alloc_skb(QETH_RX_PULL_LEN + ETH_HLEN);\r\nif (!buf->rx_skb)\r\nreturn 1;\r\n}\r\npool_entry = qeth_find_free_buffer_pool_entry(card);\r\nif (!pool_entry)\r\nreturn 1;\r\nbuf->pool_entry = pool_entry;\r\nfor (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i) {\r\nbuf->buffer->element[i].length = PAGE_SIZE;\r\nbuf->buffer->element[i].addr = pool_entry->elements[i];\r\nif (i == QETH_MAX_BUFFER_ELEMENTS(card) - 1)\r\nbuf->buffer->element[i].eflags = SBAL_EFLAGS_LAST_ENTRY;\r\nelse\r\nbuf->buffer->element[i].eflags = 0;\r\nbuf->buffer->element[i].sflags = 0;\r\n}\r\nreturn 0;\r\n}\r\nint qeth_init_qdio_queues(struct qeth_card *card)\r\n{\r\nint i, j;\r\nint rc;\r\nQETH_DBF_TEXT(SETUP, 2, "initqdqs");\r\nqdio_reset_buffers(card->qdio.in_q->qdio_bufs,\r\nQDIO_MAX_BUFFERS_PER_Q);\r\nqeth_initialize_working_pool_list(card);\r\nfor (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)\r\nqeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);\r\ncard->qdio.in_q->next_buf_to_init =\r\ncard->qdio.in_buf_pool.buf_count - 1;\r\nrc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0, 0,\r\ncard->qdio.in_buf_pool.buf_count - 1);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\nreturn rc;\r\n}\r\nrc = qeth_cq_init(card);\r\nif (rc) {\r\nreturn rc;\r\n}\r\nfor (i = 0; i < card->qdio.no_out_queues; ++i) {\r\nqdio_reset_buffers(card->qdio.out_qs[i]->qdio_bufs,\r\nQDIO_MAX_BUFFERS_PER_Q);\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {\r\nqeth_clear_output_buffer(card->qdio.out_qs[i],\r\ncard->qdio.out_qs[i]->bufs[j],\r\nQETH_QDIO_BUF_EMPTY);\r\n}\r\ncard->qdio.out_qs[i]->card = card;\r\ncard->qdio.out_qs[i]->next_buf_to_fill = 0;\r\ncard->qdio.out_qs[i]->do_pack = 0;\r\natomic_set(&card->qdio.out_qs[i]->used_buffers, 0);\r\natomic_set(&card->qdio.out_qs[i]->set_pci_flags_count, 0);\r\natomic_set(&card->qdio.out_qs[i]->state,\r\nQETH_OUT_Q_UNLOCKED);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline __u8 qeth_get_ipa_adp_type(enum qeth_link_types link_type)\r\n{\r\nswitch (link_type) {\r\ncase QETH_LINK_TYPE_HSTR:\r\nreturn 2;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic void qeth_fill_ipacmd_header(struct qeth_card *card,\r\nstruct qeth_ipa_cmd *cmd, __u8 command,\r\nenum qeth_prot_versions prot)\r\n{\r\nmemset(cmd, 0, sizeof(struct qeth_ipa_cmd));\r\ncmd->hdr.command = command;\r\ncmd->hdr.initiator = IPA_CMD_INITIATOR_HOST;\r\ncmd->hdr.seqno = card->seqno.ipa;\r\ncmd->hdr.adapter_type = qeth_get_ipa_adp_type(card->info.link_type);\r\ncmd->hdr.rel_adapter_no = (__u8) card->info.portno;\r\nif (card->options.layer2)\r\ncmd->hdr.prim_version_no = 2;\r\nelse\r\ncmd->hdr.prim_version_no = 1;\r\ncmd->hdr.param_count = 1;\r\ncmd->hdr.prot_version = prot;\r\ncmd->hdr.ipa_supported = 0;\r\ncmd->hdr.ipa_enabled = 0;\r\n}\r\nstruct qeth_cmd_buffer *qeth_get_ipacmd_buffer(struct qeth_card *card,\r\nenum qeth_ipa_cmds ipacmd, enum qeth_prot_versions prot)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\niob = qeth_wait_for_buffer(&card->write);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\nqeth_fill_ipacmd_header(card, cmd, ipacmd, prot);\r\nreturn iob;\r\n}\r\nvoid qeth_prepare_ipa_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,\r\nchar prot_type)\r\n{\r\nmemcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);\r\nmemcpy(QETH_IPA_CMD_PROT_TYPE(iob->data), &prot_type, 1);\r\nmemcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),\r\n&card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\r\n}\r\nint qeth_send_ipa_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,\r\nint (*reply_cb)(struct qeth_card *, struct qeth_reply*,\r\nunsigned long),\r\nvoid *reply_param)\r\n{\r\nint rc;\r\nchar prot_type;\r\nQETH_CARD_TEXT(card, 4, "sendipa");\r\nif (card->options.layer2)\r\nif (card->info.type == QETH_CARD_TYPE_OSN)\r\nprot_type = QETH_PROT_OSN2;\r\nelse\r\nprot_type = QETH_PROT_LAYER2;\r\nelse\r\nprot_type = QETH_PROT_TCPIP;\r\nqeth_prepare_ipa_cmd(card, iob, prot_type);\r\nrc = qeth_send_control_data(card, IPA_CMD_LENGTH,\r\niob, reply_cb, reply_param);\r\nif (rc == -ETIME) {\r\nqeth_clear_ipacmd_list(card);\r\nqeth_schedule_recovery(card);\r\n}\r\nreturn rc;\r\n}\r\nint qeth_send_startlan(struct qeth_card *card)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT(SETUP, 2, "strtlan");\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_STARTLAN, 0);\r\nrc = qeth_send_ipa_cmd(card, iob, NULL, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_default_setadapterparms_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 4, "defadpcb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nif (cmd->hdr.return_code == 0)\r\ncmd->hdr.return_code =\r\ncmd->data.setadapterparms.hdr.return_code;\r\nreturn 0;\r\n}\r\nstatic int qeth_query_setadapterparms_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 3, "quyadpcb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nif (cmd->data.setadapterparms.data.query_cmds_supp.lan_type & 0x7f) {\r\ncard->info.link_type =\r\ncmd->data.setadapterparms.data.query_cmds_supp.lan_type;\r\nQETH_DBF_TEXT_(SETUP, 2, "lnk %d", card->info.link_type);\r\n}\r\ncard->options.adp.supported_funcs =\r\ncmd->data.setadapterparms.data.query_cmds_supp.supported_cmds;\r\nreturn qeth_default_setadapterparms_cb(card, reply, (unsigned long)cmd);\r\n}\r\nstatic struct qeth_cmd_buffer *qeth_get_adapter_cmd(struct qeth_card *card,\r\n__u32 command, __u32 cmdlen)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETADAPTERPARMS,\r\nQETH_PROT_IPV4);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.setadapterparms.hdr.cmdlength = cmdlen;\r\ncmd->data.setadapterparms.hdr.command_code = command;\r\ncmd->data.setadapterparms.hdr.used_total = 1;\r\ncmd->data.setadapterparms.hdr.seq_no = 1;\r\nreturn iob;\r\n}\r\nint qeth_query_setadapterparms(struct qeth_card *card)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_CARD_TEXT(card, 3, "queryadp");\r\niob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_COMMANDS_SUPPORTED,\r\nsizeof(struct qeth_ipacmd_setadpparms));\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_query_setadapterparms_cb, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_query_ipassists_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_DBF_TEXT(SETUP, 2, "qipasscb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nswitch (cmd->hdr.return_code) {\r\ncase IPA_RC_NOTSUPP:\r\ncase IPA_RC_L2_UNSUPPORTED_CMD:\r\nQETH_DBF_TEXT(SETUP, 2, "ipaunsup");\r\ncard->options.ipa4.supported_funcs |= IPA_SETADAPTERPARMS;\r\ncard->options.ipa6.supported_funcs |= IPA_SETADAPTERPARMS;\r\nreturn -0;\r\ndefault:\r\nif (cmd->hdr.return_code) {\r\nQETH_DBF_MESSAGE(1, "%s IPA_CMD_QIPASSIST: Unhandled "\r\n"rc=%d\n",\r\ndev_name(&card->gdev->dev),\r\ncmd->hdr.return_code);\r\nreturn 0;\r\n}\r\n}\r\nif (cmd->hdr.prot_version == QETH_PROT_IPV4) {\r\ncard->options.ipa4.supported_funcs = cmd->hdr.ipa_supported;\r\ncard->options.ipa4.enabled_funcs = cmd->hdr.ipa_enabled;\r\n} else if (cmd->hdr.prot_version == QETH_PROT_IPV6) {\r\ncard->options.ipa6.supported_funcs = cmd->hdr.ipa_supported;\r\ncard->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;\r\n} else\r\nQETH_DBF_MESSAGE(1, "%s IPA_CMD_QIPASSIST: Flawed LIC detected"\r\n"\n", dev_name(&card->gdev->dev));\r\nreturn 0;\r\n}\r\nint qeth_query_ipassists(struct qeth_card *card, enum qeth_prot_versions prot)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_DBF_TEXT_(SETUP, 2, "qipassi%i", prot);\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_QIPASSIST, prot);\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_query_ipassists_cb, NULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_query_switch_attributes_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_switch_info *sw_info;\r\nstruct qeth_query_switch_attributes *attrs;\r\nQETH_CARD_TEXT(card, 2, "qswiatcb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nsw_info = (struct qeth_switch_info *)reply->param;\r\nif (cmd->data.setadapterparms.hdr.return_code == 0) {\r\nattrs = &cmd->data.setadapterparms.data.query_switch_attributes;\r\nsw_info->capabilities = attrs->capabilities;\r\nsw_info->settings = attrs->settings;\r\nQETH_CARD_TEXT_(card, 2, "%04x%04x", sw_info->capabilities,\r\nsw_info->settings);\r\n}\r\nqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\r\nreturn 0;\r\n}\r\nint qeth_query_switch_attributes(struct qeth_card *card,\r\nstruct qeth_switch_info *sw_info)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_CARD_TEXT(card, 2, "qswiattr");\r\nif (!qeth_adp_supported(card, IPA_SETADP_QUERY_SWITCH_ATTRIBUTES))\r\nreturn -EOPNOTSUPP;\r\nif (!netif_carrier_ok(card->dev))\r\nreturn -ENOMEDIUM;\r\niob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_SWITCH_ATTRIBUTES,\r\nsizeof(struct qeth_ipacmd_setadpparms_hdr));\r\nreturn qeth_send_ipa_cmd(card, iob,\r\nqeth_query_switch_attributes_cb, sw_info);\r\n}\r\nstatic int qeth_query_setdiagass_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\n__u16 rc;\r\ncmd = (struct qeth_ipa_cmd *)data;\r\nrc = cmd->hdr.return_code;\r\nif (rc)\r\nQETH_CARD_TEXT_(card, 2, "diagq:%x", rc);\r\nelse\r\ncard->info.diagass_support = cmd->data.diagass.ext;\r\nreturn 0;\r\n}\r\nstatic int qeth_query_setdiagass(struct qeth_card *card)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_DBF_TEXT(SETUP, 2, "qdiagass");\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_SET_DIAG_ASS, 0);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.diagass.subcmd_len = 16;\r\ncmd->data.diagass.subcmd = QETH_DIAGS_CMD_QUERY;\r\nreturn qeth_send_ipa_cmd(card, iob, qeth_query_setdiagass_cb, NULL);\r\n}\r\nstatic void qeth_get_trap_id(struct qeth_card *card, struct qeth_trap_id *tid)\r\n{\r\nunsigned long info = get_zeroed_page(GFP_KERNEL);\r\nstruct sysinfo_2_2_2 *info222 = (struct sysinfo_2_2_2 *)info;\r\nstruct sysinfo_3_2_2 *info322 = (struct sysinfo_3_2_2 *)info;\r\nstruct ccw_dev_id ccwid;\r\nint level;\r\ntid->chpid = card->info.chpid;\r\nccw_device_get_id(CARD_RDEV(card), &ccwid);\r\ntid->ssid = ccwid.ssid;\r\ntid->devno = ccwid.devno;\r\nif (!info)\r\nreturn;\r\nlevel = stsi(NULL, 0, 0, 0);\r\nif ((level >= 2) && (stsi(info222, 2, 2, 2) == 0))\r\ntid->lparnr = info222->lpar_number;\r\nif ((level >= 3) && (stsi(info322, 3, 2, 2) == 0)) {\r\nEBCASC(info322->vm[0].name, sizeof(info322->vm[0].name));\r\nmemcpy(tid->vmname, info322->vm[0].name, sizeof(tid->vmname));\r\n}\r\nfree_page(info);\r\nreturn;\r\n}\r\nstatic int qeth_hw_trap_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\n__u16 rc;\r\ncmd = (struct qeth_ipa_cmd *)data;\r\nrc = cmd->hdr.return_code;\r\nif (rc)\r\nQETH_CARD_TEXT_(card, 2, "trapc:%x", rc);\r\nreturn 0;\r\n}\r\nint qeth_hw_trap(struct qeth_card *card, enum qeth_diags_trap_action action)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_DBF_TEXT(SETUP, 2, "diagtrap");\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_SET_DIAG_ASS, 0);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.diagass.subcmd_len = 80;\r\ncmd->data.diagass.subcmd = QETH_DIAGS_CMD_TRAP;\r\ncmd->data.diagass.type = 1;\r\ncmd->data.diagass.action = action;\r\nswitch (action) {\r\ncase QETH_DIAGS_TRAP_ARM:\r\ncmd->data.diagass.options = 0x0003;\r\ncmd->data.diagass.ext = 0x00010000 +\r\nsizeof(struct qeth_trap_id);\r\nqeth_get_trap_id(card,\r\n(struct qeth_trap_id *)cmd->data.diagass.cdata);\r\nbreak;\r\ncase QETH_DIAGS_TRAP_DISARM:\r\ncmd->data.diagass.options = 0x0001;\r\nbreak;\r\ncase QETH_DIAGS_TRAP_CAPTURE:\r\nbreak;\r\n}\r\nreturn qeth_send_ipa_cmd(card, iob, qeth_hw_trap_cb, NULL);\r\n}\r\nint qeth_check_qdio_errors(struct qeth_card *card, struct qdio_buffer *buf,\r\nunsigned int qdio_error, const char *dbftext)\r\n{\r\nif (qdio_error) {\r\nQETH_CARD_TEXT(card, 2, dbftext);\r\nQETH_CARD_TEXT_(card, 2, " F15=%02X",\r\nbuf->element[15].sflags);\r\nQETH_CARD_TEXT_(card, 2, " F14=%02X",\r\nbuf->element[14].sflags);\r\nQETH_CARD_TEXT_(card, 2, " qerr=%X", qdio_error);\r\nif ((buf->element[15].sflags) == 0x12) {\r\ncard->stats.rx_dropped++;\r\nreturn 0;\r\n} else\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid qeth_buffer_reclaim_work(struct work_struct *work)\r\n{\r\nstruct qeth_card *card = container_of(work, struct qeth_card,\r\nbuffer_reclaim_work.work);\r\nQETH_CARD_TEXT_(card, 2, "brw:%x", card->reclaim_index);\r\nqeth_queue_input_buffer(card, card->reclaim_index);\r\n}\r\nvoid qeth_queue_input_buffer(struct qeth_card *card, int index)\r\n{\r\nstruct qeth_qdio_q *queue = card->qdio.in_q;\r\nstruct list_head *lh;\r\nint count;\r\nint i;\r\nint rc;\r\nint newcount = 0;\r\ncount = (index < queue->next_buf_to_init)?\r\ncard->qdio.in_buf_pool.buf_count -\r\n(queue->next_buf_to_init - index) :\r\ncard->qdio.in_buf_pool.buf_count -\r\n(queue->next_buf_to_init + QDIO_MAX_BUFFERS_PER_Q - index);\r\nif (count >= QETH_IN_BUF_REQUEUE_THRESHOLD(card)) {\r\nfor (i = queue->next_buf_to_init;\r\ni < queue->next_buf_to_init + count; ++i) {\r\nif (qeth_init_input_buffer(card,\r\n&queue->bufs[i % QDIO_MAX_BUFFERS_PER_Q])) {\r\nbreak;\r\n} else {\r\nnewcount++;\r\n}\r\n}\r\nif (newcount < count) {\r\natomic_set(&card->force_alloc_skb, 3);\r\ncount = newcount;\r\n} else {\r\natomic_add_unless(&card->force_alloc_skb, -1, 0);\r\n}\r\nif (!count) {\r\ni = 0;\r\nlist_for_each(lh, &card->qdio.in_buf_pool.entry_list)\r\ni++;\r\nif (i == card->qdio.in_buf_pool.buf_count) {\r\nQETH_CARD_TEXT(card, 2, "qsarbw");\r\ncard->reclaim_index = index;\r\nschedule_delayed_work(\r\n&card->buffer_reclaim_work,\r\nQETH_RECLAIM_WORK_TIME);\r\n}\r\nreturn;\r\n}\r\nif (card->options.performance_stats) {\r\ncard->perf_stats.inbound_do_qdio_cnt++;\r\ncard->perf_stats.inbound_do_qdio_start_time =\r\nqeth_get_micros();\r\n}\r\nrc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, 0,\r\nqueue->next_buf_to_init, count);\r\nif (card->options.performance_stats)\r\ncard->perf_stats.inbound_do_qdio_time +=\r\nqeth_get_micros() -\r\ncard->perf_stats.inbound_do_qdio_start_time;\r\nif (rc) {\r\nQETH_CARD_TEXT(card, 2, "qinberr");\r\n}\r\nqueue->next_buf_to_init = (queue->next_buf_to_init + count) %\r\nQDIO_MAX_BUFFERS_PER_Q;\r\n}\r\n}\r\nstatic int qeth_handle_send_error(struct qeth_card *card,\r\nstruct qeth_qdio_out_buffer *buffer, unsigned int qdio_err)\r\n{\r\nint sbalf15 = buffer->buffer->element[15].sflags;\r\nQETH_CARD_TEXT(card, 6, "hdsnderr");\r\nif (card->info.type == QETH_CARD_TYPE_IQD) {\r\nif (sbalf15 == 0) {\r\nqdio_err = 0;\r\n} else {\r\nqdio_err = 1;\r\n}\r\n}\r\nqeth_check_qdio_errors(card, buffer->buffer, qdio_err, "qouterr");\r\nif (!qdio_err)\r\nreturn QETH_SEND_ERROR_NONE;\r\nif ((sbalf15 >= 15) && (sbalf15 <= 31))\r\nreturn QETH_SEND_ERROR_RETRY;\r\nQETH_CARD_TEXT(card, 1, "lnkfail");\r\nQETH_CARD_TEXT_(card, 1, "%04x %02x",\r\n(u16)qdio_err, (u8)sbalf15);\r\nreturn QETH_SEND_ERROR_LINK_FAILURE;\r\n}\r\nstatic void qeth_switch_to_packing_if_needed(struct qeth_qdio_out_q *queue)\r\n{\r\nif (!queue->do_pack) {\r\nif (atomic_read(&queue->used_buffers)\r\n>= QETH_HIGH_WATERMARK_PACK){\r\nQETH_CARD_TEXT(queue->card, 6, "np->pack");\r\nif (queue->card->options.performance_stats)\r\nqueue->card->perf_stats.sc_dp_p++;\r\nqueue->do_pack = 1;\r\n}\r\n}\r\n}\r\nstatic int qeth_switch_to_nonpacking_if_needed(struct qeth_qdio_out_q *queue)\r\n{\r\nstruct qeth_qdio_out_buffer *buffer;\r\nint flush_count = 0;\r\nif (queue->do_pack) {\r\nif (atomic_read(&queue->used_buffers)\r\n<= QETH_LOW_WATERMARK_PACK) {\r\nQETH_CARD_TEXT(queue->card, 6, "pack->np");\r\nif (queue->card->options.performance_stats)\r\nqueue->card->perf_stats.sc_p_dp++;\r\nqueue->do_pack = 0;\r\nbuffer = queue->bufs[queue->next_buf_to_fill];\r\nif ((atomic_read(&buffer->state) ==\r\nQETH_QDIO_BUF_EMPTY) &&\r\n(buffer->next_element_to_fill > 0)) {\r\natomic_set(&buffer->state,\r\nQETH_QDIO_BUF_PRIMED);\r\nflush_count++;\r\nqueue->next_buf_to_fill =\r\n(queue->next_buf_to_fill + 1) %\r\nQDIO_MAX_BUFFERS_PER_Q;\r\n}\r\n}\r\n}\r\nreturn flush_count;\r\n}\r\nstatic int qeth_flush_buffers_on_no_pci(struct qeth_qdio_out_q *queue)\r\n{\r\nstruct qeth_qdio_out_buffer *buffer;\r\nbuffer = queue->bufs[queue->next_buf_to_fill];\r\nif ((atomic_read(&buffer->state) == QETH_QDIO_BUF_EMPTY) &&\r\n(buffer->next_element_to_fill > 0)) {\r\natomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\r\nqueue->next_buf_to_fill =\r\n(queue->next_buf_to_fill + 1) % QDIO_MAX_BUFFERS_PER_Q;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qeth_flush_buffers(struct qeth_qdio_out_q *queue, int index,\r\nint count)\r\n{\r\nstruct qeth_qdio_out_buffer *buf;\r\nint rc;\r\nint i;\r\nunsigned int qdio_flags;\r\nfor (i = index; i < index + count; ++i) {\r\nint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\r\nbuf = queue->bufs[bidx];\r\nbuf->buffer->element[buf->next_element_to_fill - 1].eflags |=\r\nSBAL_EFLAGS_LAST_ENTRY;\r\nif (queue->bufstates)\r\nqueue->bufstates[bidx].user = buf;\r\nif (queue->card->info.type == QETH_CARD_TYPE_IQD)\r\ncontinue;\r\nif (!queue->do_pack) {\r\nif ((atomic_read(&queue->used_buffers) >=\r\n(QETH_HIGH_WATERMARK_PACK -\r\nQETH_WATERMARK_PACK_FUZZ)) &&\r\n!atomic_read(&queue->set_pci_flags_count)) {\r\natomic_inc(&queue->set_pci_flags_count);\r\nbuf->buffer->element[0].sflags |= SBAL_SFLAGS0_PCI_REQ;\r\n}\r\n} else {\r\nif (!atomic_read(&queue->set_pci_flags_count)) {\r\natomic_inc(&queue->set_pci_flags_count);\r\nbuf->buffer->element[0].sflags |= SBAL_SFLAGS0_PCI_REQ;\r\n}\r\n}\r\n}\r\nqueue->card->dev->trans_start = jiffies;\r\nif (queue->card->options.performance_stats) {\r\nqueue->card->perf_stats.outbound_do_qdio_cnt++;\r\nqueue->card->perf_stats.outbound_do_qdio_start_time =\r\nqeth_get_micros();\r\n}\r\nqdio_flags = QDIO_FLAG_SYNC_OUTPUT;\r\nif (atomic_read(&queue->set_pci_flags_count))\r\nqdio_flags |= QDIO_FLAG_PCI_OUT;\r\nrc = do_QDIO(CARD_DDEV(queue->card), qdio_flags,\r\nqueue->queue_no, index, count);\r\nif (queue->card->options.performance_stats)\r\nqueue->card->perf_stats.outbound_do_qdio_time +=\r\nqeth_get_micros() -\r\nqueue->card->perf_stats.outbound_do_qdio_start_time;\r\natomic_add(count, &queue->used_buffers);\r\nif (rc) {\r\nqueue->card->stats.tx_errors += count;\r\nif (rc == -ENOBUFS)\r\nreturn;\r\nQETH_CARD_TEXT(queue->card, 2, "flushbuf");\r\nQETH_CARD_TEXT_(queue->card, 2, " q%d", queue->queue_no);\r\nQETH_CARD_TEXT_(queue->card, 2, " idx%d", index);\r\nQETH_CARD_TEXT_(queue->card, 2, " c%d", count);\r\nQETH_CARD_TEXT_(queue->card, 2, " err%d", rc);\r\nqeth_schedule_recovery(queue->card);\r\nreturn;\r\n}\r\nif (queue->card->options.performance_stats)\r\nqueue->card->perf_stats.bufs_sent += count;\r\n}\r\nstatic void qeth_check_outbound_queue(struct qeth_qdio_out_q *queue)\r\n{\r\nint index;\r\nint flush_cnt = 0;\r\nint q_was_packing = 0;\r\nif ((atomic_read(&queue->used_buffers) <= QETH_LOW_WATERMARK_PACK) ||\r\n!atomic_read(&queue->set_pci_flags_count)) {\r\nif (atomic_xchg(&queue->state, QETH_OUT_Q_LOCKED_FLUSH) ==\r\nQETH_OUT_Q_UNLOCKED) {\r\nnetif_stop_queue(queue->card->dev);\r\nindex = queue->next_buf_to_fill;\r\nq_was_packing = queue->do_pack;\r\nbarrier();\r\nflush_cnt += qeth_switch_to_nonpacking_if_needed(queue);\r\nif (!flush_cnt &&\r\n!atomic_read(&queue->set_pci_flags_count))\r\nflush_cnt +=\r\nqeth_flush_buffers_on_no_pci(queue);\r\nif (queue->card->options.performance_stats &&\r\nq_was_packing)\r\nqueue->card->perf_stats.bufs_sent_pack +=\r\nflush_cnt;\r\nif (flush_cnt)\r\nqeth_flush_buffers(queue, index, flush_cnt);\r\natomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\r\n}\r\n}\r\n}\r\nvoid qeth_qdio_start_poll(struct ccw_device *ccwdev, int queue,\r\nunsigned long card_ptr)\r\n{\r\nstruct qeth_card *card = (struct qeth_card *)card_ptr;\r\nif (card->dev && (card->dev->flags & IFF_UP))\r\nnapi_schedule(&card->napi);\r\n}\r\nint qeth_configure_cq(struct qeth_card *card, enum qeth_cq cq)\r\n{\r\nint rc;\r\nif (card->options.cq == QETH_CQ_NOTAVAILABLE) {\r\nrc = -1;\r\ngoto out;\r\n} else {\r\nif (card->options.cq == cq) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (card->state != CARD_STATE_DOWN &&\r\ncard->state != CARD_STATE_RECOVER) {\r\nrc = -1;\r\ngoto out;\r\n}\r\nqeth_free_qdio_buffers(card);\r\ncard->options.cq = cq;\r\nrc = 0;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic void qeth_qdio_cq_handler(struct qeth_card *card,\r\nunsigned int qdio_err,\r\nunsigned int queue, int first_element, int count) {\r\nstruct qeth_qdio_q *cq = card->qdio.c_q;\r\nint i;\r\nint rc;\r\nif (!qeth_is_cq(card, queue))\r\ngoto out;\r\nQETH_CARD_TEXT_(card, 5, "qcqhe%d", first_element);\r\nQETH_CARD_TEXT_(card, 5, "qcqhc%d", count);\r\nQETH_CARD_TEXT_(card, 5, "qcqherr%d", qdio_err);\r\nif (qdio_err) {\r\nnetif_stop_queue(card->dev);\r\nqeth_schedule_recovery(card);\r\ngoto out;\r\n}\r\nif (card->options.performance_stats) {\r\ncard->perf_stats.cq_cnt++;\r\ncard->perf_stats.cq_start_time = qeth_get_micros();\r\n}\r\nfor (i = first_element; i < first_element + count; ++i) {\r\nint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\r\nstruct qdio_buffer *buffer = cq->qdio_bufs[bidx];\r\nint e;\r\ne = 0;\r\nwhile (buffer->element[e].addr) {\r\nunsigned long phys_aob_addr;\r\nphys_aob_addr = (unsigned long) buffer->element[e].addr;\r\nqeth_qdio_handle_aob(card, phys_aob_addr);\r\nbuffer->element[e].addr = NULL;\r\nbuffer->element[e].eflags = 0;\r\nbuffer->element[e].sflags = 0;\r\nbuffer->element[e].length = 0;\r\n++e;\r\n}\r\nbuffer->element[15].eflags = 0;\r\nbuffer->element[15].sflags = 0;\r\n}\r\nrc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT, queue,\r\ncard->qdio.c_q->next_buf_to_init,\r\ncount);\r\nif (rc) {\r\ndev_warn(&card->gdev->dev,\r\n"QDIO reported an error, rc=%i\n", rc);\r\nQETH_CARD_TEXT(card, 2, "qcqherr");\r\n}\r\ncard->qdio.c_q->next_buf_to_init = (card->qdio.c_q->next_buf_to_init\r\n+ count) % QDIO_MAX_BUFFERS_PER_Q;\r\nnetif_wake_queue(card->dev);\r\nif (card->options.performance_stats) {\r\nint delta_t = qeth_get_micros();\r\ndelta_t -= card->perf_stats.cq_start_time;\r\ncard->perf_stats.cq_time += delta_t;\r\n}\r\nout:\r\nreturn;\r\n}\r\nvoid qeth_qdio_input_handler(struct ccw_device *ccwdev, unsigned int qdio_err,\r\nunsigned int queue, int first_elem, int count,\r\nunsigned long card_ptr)\r\n{\r\nstruct qeth_card *card = (struct qeth_card *)card_ptr;\r\nQETH_CARD_TEXT_(card, 2, "qihq%d", queue);\r\nQETH_CARD_TEXT_(card, 2, "qiec%d", qdio_err);\r\nif (qeth_is_cq(card, queue))\r\nqeth_qdio_cq_handler(card, qdio_err, queue, first_elem, count);\r\nelse if (qdio_err)\r\nqeth_schedule_recovery(card);\r\n}\r\nvoid qeth_qdio_output_handler(struct ccw_device *ccwdev,\r\nunsigned int qdio_error, int __queue, int first_element,\r\nint count, unsigned long card_ptr)\r\n{\r\nstruct qeth_card *card = (struct qeth_card *) card_ptr;\r\nstruct qeth_qdio_out_q *queue = card->qdio.out_qs[__queue];\r\nstruct qeth_qdio_out_buffer *buffer;\r\nint i;\r\nQETH_CARD_TEXT(card, 6, "qdouhdl");\r\nif (qdio_error & QDIO_ERROR_FATAL) {\r\nQETH_CARD_TEXT(card, 2, "achkcond");\r\nnetif_stop_queue(card->dev);\r\nqeth_schedule_recovery(card);\r\nreturn;\r\n}\r\nif (card->options.performance_stats) {\r\ncard->perf_stats.outbound_handler_cnt++;\r\ncard->perf_stats.outbound_handler_start_time =\r\nqeth_get_micros();\r\n}\r\nfor (i = first_element; i < (first_element + count); ++i) {\r\nint bidx = i % QDIO_MAX_BUFFERS_PER_Q;\r\nbuffer = queue->bufs[bidx];\r\nqeth_handle_send_error(card, buffer, qdio_error);\r\nif (queue->bufstates &&\r\n(queue->bufstates[bidx].flags &\r\nQDIO_OUTBUF_STATE_FLAG_PENDING) != 0) {\r\nWARN_ON_ONCE(card->options.cq != QETH_CQ_ENABLED);\r\nif (atomic_cmpxchg(&buffer->state,\r\nQETH_QDIO_BUF_PRIMED,\r\nQETH_QDIO_BUF_PENDING) ==\r\nQETH_QDIO_BUF_PRIMED) {\r\nqeth_notify_skbs(queue, buffer,\r\nTX_NOTIFY_PENDING);\r\n}\r\nbuffer->aob = queue->bufstates[bidx].aob;\r\nQETH_CARD_TEXT_(queue->card, 5, "pel%d", bidx);\r\nQETH_CARD_TEXT(queue->card, 5, "aob");\r\nQETH_CARD_TEXT_(queue->card, 5, "%lx",\r\nvirt_to_phys(buffer->aob));\r\nif (qeth_init_qdio_out_buf(queue, bidx)) {\r\nQETH_CARD_TEXT(card, 2, "outofbuf");\r\nqeth_schedule_recovery(card);\r\n}\r\n} else {\r\nif (card->options.cq == QETH_CQ_ENABLED) {\r\nenum iucv_tx_notify n;\r\nn = qeth_compute_cq_notification(\r\nbuffer->buffer->element[15].sflags, 0);\r\nqeth_notify_skbs(queue, buffer, n);\r\n}\r\nqeth_clear_output_buffer(queue, buffer,\r\nQETH_QDIO_BUF_EMPTY);\r\n}\r\nqeth_cleanup_handled_pending(queue, bidx, 0);\r\n}\r\natomic_sub(count, &queue->used_buffers);\r\nif (card->info.type != QETH_CARD_TYPE_IQD)\r\nqeth_check_outbound_queue(queue);\r\nnetif_wake_queue(queue->card->dev);\r\nif (card->options.performance_stats)\r\ncard->perf_stats.outbound_handler_time += qeth_get_micros() -\r\ncard->perf_stats.outbound_handler_start_time;\r\n}\r\nint qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb,\r\nint ipv, int cast_type)\r\n{\r\n__be16 *tci;\r\nu8 tos;\r\nif (cast_type && card->info.is_multicast_different)\r\nreturn card->info.is_multicast_different &\r\n(card->qdio.no_out_queues - 1);\r\nswitch (card->qdio.do_prio_queueing) {\r\ncase QETH_PRIO_Q_ING_TOS:\r\ncase QETH_PRIO_Q_ING_PREC:\r\nswitch (ipv) {\r\ncase 4:\r\ntos = ipv4_get_dsfield(ip_hdr(skb));\r\nbreak;\r\ncase 6:\r\ntos = ipv6_get_dsfield(ipv6_hdr(skb));\r\nbreak;\r\ndefault:\r\nreturn card->qdio.default_out_queue;\r\n}\r\nif (card->qdio.do_prio_queueing == QETH_PRIO_Q_ING_PREC)\r\nreturn ~tos >> 6 & 3;\r\nif (tos & IPTOS_MINCOST)\r\nreturn 3;\r\nif (tos & IPTOS_RELIABILITY)\r\nreturn 2;\r\nif (tos & IPTOS_THROUGHPUT)\r\nreturn 1;\r\nif (tos & IPTOS_LOWDELAY)\r\nreturn 0;\r\nbreak;\r\ncase QETH_PRIO_Q_ING_SKB:\r\nif (skb->priority > 5)\r\nreturn 0;\r\nreturn ~skb->priority >> 1 & 3;\r\ncase QETH_PRIO_Q_ING_VLAN:\r\ntci = &((struct ethhdr *)skb->data)->h_proto;\r\nif (*tci == ETH_P_8021Q)\r\nreturn ~*(tci + 1) >> (VLAN_PRIO_SHIFT + 1) & 3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn card->qdio.default_out_queue;\r\n}\r\nint qeth_get_elements_for_frags(struct sk_buff *skb)\r\n{\r\nint cnt, length, e, elements = 0;\r\nstruct skb_frag_struct *frag;\r\nchar *data;\r\nfor (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {\r\nfrag = &skb_shinfo(skb)->frags[cnt];\r\ndata = (char *)page_to_phys(skb_frag_page(frag)) +\r\nfrag->page_offset;\r\nlength = frag->size;\r\ne = PFN_UP((unsigned long)data + length - 1) -\r\nPFN_DOWN((unsigned long)data);\r\nelements += e;\r\n}\r\nreturn elements;\r\n}\r\nint qeth_get_elements_no(struct qeth_card *card,\r\nstruct sk_buff *skb, int elems)\r\n{\r\nint dlen = skb->len - skb->data_len;\r\nint elements_needed = PFN_UP((unsigned long)skb->data + dlen - 1) -\r\nPFN_DOWN((unsigned long)skb->data);\r\nelements_needed += qeth_get_elements_for_frags(skb);\r\nif ((elements_needed + elems) > QETH_MAX_BUFFER_ELEMENTS(card)) {\r\nQETH_DBF_MESSAGE(2, "Invalid size of IP packet "\r\n"(Number=%d / Length=%d). Discarded.\n",\r\n(elements_needed+elems), skb->len);\r\nreturn 0;\r\n}\r\nreturn elements_needed;\r\n}\r\nint qeth_hdr_chk_and_bounce(struct sk_buff *skb, struct qeth_hdr **hdr, int len)\r\n{\r\nint hroom, inpage, rest;\r\nif (((unsigned long)skb->data & PAGE_MASK) !=\r\n(((unsigned long)skb->data + len - 1) & PAGE_MASK)) {\r\nhroom = skb_headroom(skb);\r\ninpage = PAGE_SIZE - ((unsigned long) skb->data % PAGE_SIZE);\r\nrest = len - inpage;\r\nif (rest > hroom)\r\nreturn 1;\r\nmemmove(skb->data - rest, skb->data, skb->len - skb->data_len);\r\nskb->data -= rest;\r\nskb->tail -= rest;\r\n*hdr = (struct qeth_hdr *)skb->data;\r\nQETH_DBF_MESSAGE(2, "skb bounce len: %d rest: %d\n", len, rest);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void __qeth_fill_buffer(struct sk_buff *skb,\r\nstruct qdio_buffer *buffer, int is_tso, int *next_element_to_fill,\r\nint offset)\r\n{\r\nint length = skb->len - skb->data_len;\r\nint length_here;\r\nint element;\r\nchar *data;\r\nint first_lap, cnt;\r\nstruct skb_frag_struct *frag;\r\nelement = *next_element_to_fill;\r\ndata = skb->data;\r\nfirst_lap = (is_tso == 0 ? 1 : 0);\r\nif (offset >= 0) {\r\ndata = skb->data + offset;\r\nlength -= offset;\r\nfirst_lap = 0;\r\n}\r\nwhile (length > 0) {\r\nlength_here = PAGE_SIZE - ((unsigned long) data % PAGE_SIZE);\r\nif (length < length_here)\r\nlength_here = length;\r\nbuffer->element[element].addr = data;\r\nbuffer->element[element].length = length_here;\r\nlength -= length_here;\r\nif (!length) {\r\nif (first_lap)\r\nif (skb_shinfo(skb)->nr_frags)\r\nbuffer->element[element].eflags =\r\nSBAL_EFLAGS_FIRST_FRAG;\r\nelse\r\nbuffer->element[element].eflags = 0;\r\nelse\r\nbuffer->element[element].eflags =\r\nSBAL_EFLAGS_MIDDLE_FRAG;\r\n} else {\r\nif (first_lap)\r\nbuffer->element[element].eflags =\r\nSBAL_EFLAGS_FIRST_FRAG;\r\nelse\r\nbuffer->element[element].eflags =\r\nSBAL_EFLAGS_MIDDLE_FRAG;\r\n}\r\ndata += length_here;\r\nelement++;\r\nfirst_lap = 0;\r\n}\r\nfor (cnt = 0; cnt < skb_shinfo(skb)->nr_frags; cnt++) {\r\nfrag = &skb_shinfo(skb)->frags[cnt];\r\ndata = (char *)page_to_phys(skb_frag_page(frag)) +\r\nfrag->page_offset;\r\nlength = frag->size;\r\nwhile (length > 0) {\r\nlength_here = PAGE_SIZE -\r\n((unsigned long) data % PAGE_SIZE);\r\nif (length < length_here)\r\nlength_here = length;\r\nbuffer->element[element].addr = data;\r\nbuffer->element[element].length = length_here;\r\nbuffer->element[element].eflags =\r\nSBAL_EFLAGS_MIDDLE_FRAG;\r\nlength -= length_here;\r\ndata += length_here;\r\nelement++;\r\n}\r\n}\r\nif (buffer->element[element - 1].eflags)\r\nbuffer->element[element - 1].eflags = SBAL_EFLAGS_LAST_FRAG;\r\n*next_element_to_fill = element;\r\n}\r\nstatic inline int qeth_fill_buffer(struct qeth_qdio_out_q *queue,\r\nstruct qeth_qdio_out_buffer *buf, struct sk_buff *skb,\r\nstruct qeth_hdr *hdr, int offset, int hd_len)\r\n{\r\nstruct qdio_buffer *buffer;\r\nint flush_cnt = 0, hdr_len, large_send = 0;\r\nbuffer = buf->buffer;\r\natomic_inc(&skb->users);\r\nskb_queue_tail(&buf->skb_list, skb);\r\nif (hdr->hdr.l3.id == QETH_HEADER_TYPE_TSO) {\r\nint element = buf->next_element_to_fill;\r\nhdr_len = sizeof(struct qeth_hdr_tso) +\r\n((struct qeth_hdr_tso *)hdr)->ext.dg_hdr_len;\r\nbuffer->element[element].addr = skb->data;\r\nbuffer->element[element].length = hdr_len;\r\nbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\r\nbuf->next_element_to_fill++;\r\nskb->data += hdr_len;\r\nskb->len -= hdr_len;\r\nlarge_send = 1;\r\n}\r\nif (offset >= 0) {\r\nint element = buf->next_element_to_fill;\r\nbuffer->element[element].addr = hdr;\r\nbuffer->element[element].length = sizeof(struct qeth_hdr) +\r\nhd_len;\r\nbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\r\nbuf->is_header[element] = 1;\r\nbuf->next_element_to_fill++;\r\n}\r\n__qeth_fill_buffer(skb, buffer, large_send,\r\n(int *)&buf->next_element_to_fill, offset);\r\nif (!queue->do_pack) {\r\nQETH_CARD_TEXT(queue->card, 6, "fillbfnp");\r\natomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\r\nflush_cnt = 1;\r\n} else {\r\nQETH_CARD_TEXT(queue->card, 6, "fillbfpa");\r\nif (queue->card->options.performance_stats)\r\nqueue->card->perf_stats.skbs_sent_pack++;\r\nif (buf->next_element_to_fill >=\r\nQETH_MAX_BUFFER_ELEMENTS(queue->card)) {\r\natomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\r\nflush_cnt = 1;\r\n}\r\n}\r\nreturn flush_cnt;\r\n}\r\nint qeth_do_send_packet_fast(struct qeth_card *card,\r\nstruct qeth_qdio_out_q *queue, struct sk_buff *skb,\r\nstruct qeth_hdr *hdr, int elements_needed,\r\nint offset, int hd_len)\r\n{\r\nstruct qeth_qdio_out_buffer *buffer;\r\nint index;\r\nwhile (atomic_cmpxchg(&queue->state, QETH_OUT_Q_UNLOCKED,\r\nQETH_OUT_Q_LOCKED) != QETH_OUT_Q_UNLOCKED);\r\nindex = queue->next_buf_to_fill;\r\nbuffer = queue->bufs[queue->next_buf_to_fill];\r\nif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY)\r\ngoto out;\r\nqueue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %\r\nQDIO_MAX_BUFFERS_PER_Q;\r\natomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\r\nqeth_fill_buffer(queue, buffer, skb, hdr, offset, hd_len);\r\nqeth_flush_buffers(queue, index, 1);\r\nreturn 0;\r\nout:\r\natomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\r\nreturn -EBUSY;\r\n}\r\nint qeth_do_send_packet(struct qeth_card *card, struct qeth_qdio_out_q *queue,\r\nstruct sk_buff *skb, struct qeth_hdr *hdr,\r\nint elements_needed)\r\n{\r\nstruct qeth_qdio_out_buffer *buffer;\r\nint start_index;\r\nint flush_count = 0;\r\nint do_pack = 0;\r\nint tmp;\r\nint rc = 0;\r\nwhile (atomic_cmpxchg(&queue->state, QETH_OUT_Q_UNLOCKED,\r\nQETH_OUT_Q_LOCKED) != QETH_OUT_Q_UNLOCKED);\r\nstart_index = queue->next_buf_to_fill;\r\nbuffer = queue->bufs[queue->next_buf_to_fill];\r\nif (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY) {\r\natomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);\r\nreturn -EBUSY;\r\n}\r\nqeth_switch_to_packing_if_needed(queue);\r\nif (queue->do_pack) {\r\ndo_pack = 1;\r\nif ((QETH_MAX_BUFFER_ELEMENTS(card) -\r\nbuffer->next_element_to_fill) < elements_needed) {\r\natomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);\r\nflush_count++;\r\nqueue->next_buf_to_fill =\r\n(queue->next_buf_to_fill + 1) %\r\nQDIO_MAX_BUFFERS_PER_Q;\r\nbuffer = queue->bufs[queue->next_buf_to_fill];\r\nif (atomic_read(&buffer->state) !=\r\nQETH_QDIO_BUF_EMPTY) {\r\nqeth_flush_buffers(queue, start_index,\r\nflush_count);\r\natomic_set(&queue->state,\r\nQETH_OUT_Q_UNLOCKED);\r\nreturn -EBUSY;\r\n}\r\n}\r\n}\r\ntmp = qeth_fill_buffer(queue, buffer, skb, hdr, -1, 0);\r\nqueue->next_buf_to_fill = (queue->next_buf_to_fill + tmp) %\r\nQDIO_MAX_BUFFERS_PER_Q;\r\nflush_count += tmp;\r\nif (flush_count)\r\nqeth_flush_buffers(queue, start_index, flush_count);\r\nelse if (!atomic_read(&queue->set_pci_flags_count))\r\natomic_xchg(&queue->state, QETH_OUT_Q_LOCKED_FLUSH);\r\nwhile (atomic_dec_return(&queue->state)) {\r\nflush_count = 0;\r\nstart_index = queue->next_buf_to_fill;\r\nflush_count += qeth_switch_to_nonpacking_if_needed(queue);\r\nif (!flush_count && !atomic_read(&queue->set_pci_flags_count))\r\nflush_count += qeth_flush_buffers_on_no_pci(queue);\r\nif (flush_count)\r\nqeth_flush_buffers(queue, start_index, flush_count);\r\n}\r\nif (queue->card->options.performance_stats && do_pack)\r\nqueue->card->perf_stats.bufs_sent_pack += flush_count;\r\nreturn rc;\r\n}\r\nstatic int qeth_setadp_promisc_mode_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_ipacmd_setadpparms *setparms;\r\nQETH_CARD_TEXT(card, 4, "prmadpcb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nsetparms = &(cmd->data.setadapterparms);\r\nqeth_default_setadapterparms_cb(card, reply, (unsigned long)cmd);\r\nif (cmd->hdr.return_code) {\r\nQETH_CARD_TEXT_(card, 4, "prmrc%2.2x", cmd->hdr.return_code);\r\nsetparms->data.mode = SET_PROMISC_MODE_OFF;\r\n}\r\ncard->info.promisc_mode = setparms->data.mode;\r\nreturn 0;\r\n}\r\nvoid qeth_setadp_promisc_mode(struct qeth_card *card)\r\n{\r\nenum qeth_ipa_promisc_modes mode;\r\nstruct net_device *dev = card->dev;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 4, "setprom");\r\nif (((dev->flags & IFF_PROMISC) &&\r\n(card->info.promisc_mode == SET_PROMISC_MODE_ON)) ||\r\n(!(dev->flags & IFF_PROMISC) &&\r\n(card->info.promisc_mode == SET_PROMISC_MODE_OFF)))\r\nreturn;\r\nmode = SET_PROMISC_MODE_OFF;\r\nif (dev->flags & IFF_PROMISC)\r\nmode = SET_PROMISC_MODE_ON;\r\nQETH_CARD_TEXT_(card, 4, "mode:%x", mode);\r\niob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_PROMISC_MODE,\r\nsizeof(struct qeth_ipacmd_setadpparms));\r\ncmd = (struct qeth_ipa_cmd *)(iob->data + IPA_PDU_HEADER_SIZE);\r\ncmd->data.setadapterparms.data.mode = mode;\r\nqeth_send_ipa_cmd(card, iob, qeth_setadp_promisc_mode_cb, NULL);\r\n}\r\nint qeth_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct qeth_card *card;\r\nchar dbf_text[15];\r\ncard = dev->ml_priv;\r\nQETH_CARD_TEXT(card, 4, "chgmtu");\r\nsprintf(dbf_text, "%8x", new_mtu);\r\nQETH_CARD_TEXT(card, 4, dbf_text);\r\nif (new_mtu < 64)\r\nreturn -EINVAL;\r\nif (new_mtu > 65535)\r\nreturn -EINVAL;\r\nif ((!qeth_is_supported(card, IPA_IP_FRAGMENTATION)) &&\r\n(!qeth_mtu_is_valid(card, new_mtu)))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstruct net_device_stats *qeth_get_stats(struct net_device *dev)\r\n{\r\nstruct qeth_card *card;\r\ncard = dev->ml_priv;\r\nQETH_CARD_TEXT(card, 5, "getstat");\r\nreturn &card->stats;\r\n}\r\nstatic int qeth_setadpparms_change_macaddr_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 4, "chgmaccb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nif (!card->options.layer2 ||\r\n!(card->info.mac_bits & QETH_LAYER2_MAC_READ)) {\r\nmemcpy(card->dev->dev_addr,\r\n&cmd->data.setadapterparms.data.change_addr.addr,\r\nOSA_ADDR_LEN);\r\ncard->info.mac_bits |= QETH_LAYER2_MAC_READ;\r\n}\r\nqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\r\nreturn 0;\r\n}\r\nint qeth_setadpparms_change_macaddr(struct qeth_card *card)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 4, "chgmac");\r\niob = qeth_get_adapter_cmd(card, IPA_SETADP_ALTER_MAC_ADDRESS,\r\nsizeof(struct qeth_ipacmd_setadpparms));\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.setadapterparms.data.change_addr.cmd = CHANGE_ADDR_READ_MAC;\r\ncmd->data.setadapterparms.data.change_addr.addr_size = OSA_ADDR_LEN;\r\nmemcpy(&cmd->data.setadapterparms.data.change_addr.addr,\r\ncard->dev->dev_addr, OSA_ADDR_LEN);\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_change_macaddr_cb,\r\nNULL);\r\nreturn rc;\r\n}\r\nstatic int qeth_setadpparms_set_access_ctrl_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_set_access_ctrl *access_ctrl_req;\r\nint fallback = *(int *)reply->param;\r\nQETH_CARD_TEXT(card, 4, "setaccb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\naccess_ctrl_req = &cmd->data.setadapterparms.data.set_access_ctrl;\r\nQETH_DBF_TEXT_(SETUP, 2, "setaccb");\r\nQETH_DBF_TEXT_(SETUP, 2, "%s", card->gdev->dev.kobj.name);\r\nQETH_DBF_TEXT_(SETUP, 2, "rc=%d",\r\ncmd->data.setadapterparms.hdr.return_code);\r\nif (cmd->data.setadapterparms.hdr.return_code !=\r\nSET_ACCESS_CTRL_RC_SUCCESS)\r\nQETH_DBF_MESSAGE(3, "ERR:SET_ACCESS_CTRL(%s,%d)==%d\n",\r\ncard->gdev->dev.kobj.name,\r\naccess_ctrl_req->subcmd_code,\r\ncmd->data.setadapterparms.hdr.return_code);\r\nswitch (cmd->data.setadapterparms.hdr.return_code) {\r\ncase SET_ACCESS_CTRL_RC_SUCCESS:\r\nif (card->options.isolation == ISOLATION_MODE_NONE) {\r\ndev_info(&card->gdev->dev,\r\n"QDIO data connection isolation is deactivated\n");\r\n} else {\r\ndev_info(&card->gdev->dev,\r\n"QDIO data connection isolation is activated\n");\r\n}\r\nbreak;\r\ncase SET_ACCESS_CTRL_RC_ALREADY_NOT_ISOLATED:\r\nQETH_DBF_MESSAGE(2, "%s QDIO data connection isolation already "\r\n"deactivated\n", dev_name(&card->gdev->dev));\r\nif (fallback)\r\ncard->options.isolation = card->options.prev_isolation;\r\nbreak;\r\ncase SET_ACCESS_CTRL_RC_ALREADY_ISOLATED:\r\nQETH_DBF_MESSAGE(2, "%s QDIO data connection isolation already"\r\n" activated\n", dev_name(&card->gdev->dev));\r\nif (fallback)\r\ncard->options.isolation = card->options.prev_isolation;\r\nbreak;\r\ncase SET_ACCESS_CTRL_RC_NOT_SUPPORTED:\r\ndev_err(&card->gdev->dev, "Adapter does not "\r\n"support QDIO data connection isolation\n");\r\nbreak;\r\ncase SET_ACCESS_CTRL_RC_NONE_SHARED_ADAPTER:\r\ndev_err(&card->gdev->dev,\r\n"Adapter is dedicated. "\r\n"QDIO data connection isolation not supported\n");\r\nif (fallback)\r\ncard->options.isolation = card->options.prev_isolation;\r\nbreak;\r\ncase SET_ACCESS_CTRL_RC_ACTIVE_CHECKSUM_OFF:\r\ndev_err(&card->gdev->dev,\r\n"TSO does not permit QDIO data connection isolation\n");\r\nif (fallback)\r\ncard->options.isolation = card->options.prev_isolation;\r\nbreak;\r\ncase SET_ACCESS_CTRL_RC_REFLREL_UNSUPPORTED:\r\ndev_err(&card->gdev->dev, "The adjacent switch port does not "\r\n"support reflective relay mode\n");\r\nif (fallback)\r\ncard->options.isolation = card->options.prev_isolation;\r\nbreak;\r\ncase SET_ACCESS_CTRL_RC_REFLREL_FAILED:\r\ndev_err(&card->gdev->dev, "The reflective relay mode cannot be "\r\n"enabled at the adjacent switch port");\r\nif (fallback)\r\ncard->options.isolation = card->options.prev_isolation;\r\nbreak;\r\ncase SET_ACCESS_CTRL_RC_REFLREL_DEACT_FAILED:\r\ndev_warn(&card->gdev->dev, "Turning off reflective relay mode "\r\n"at the adjacent switch failed\n");\r\nbreak;\r\ndefault:\r\nif (fallback)\r\ncard->options.isolation = card->options.prev_isolation;\r\nbreak;\r\n}\r\nqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\r\nreturn 0;\r\n}\r\nstatic int qeth_setadpparms_set_access_ctrl(struct qeth_card *card,\r\nenum qeth_ipa_isolation_modes isolation, int fallback)\r\n{\r\nint rc;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_set_access_ctrl *access_ctrl_req;\r\nQETH_CARD_TEXT(card, 4, "setacctl");\r\nQETH_DBF_TEXT_(SETUP, 2, "setacctl");\r\nQETH_DBF_TEXT_(SETUP, 2, "%s", card->gdev->dev.kobj.name);\r\niob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_ACCESS_CONTROL,\r\nsizeof(struct qeth_ipacmd_setadpparms_hdr) +\r\nsizeof(struct qeth_set_access_ctrl));\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\naccess_ctrl_req = &cmd->data.setadapterparms.data.set_access_ctrl;\r\naccess_ctrl_req->subcmd_code = isolation;\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_set_access_ctrl_cb,\r\n&fallback);\r\nQETH_DBF_TEXT_(SETUP, 2, "rc=%d", rc);\r\nreturn rc;\r\n}\r\nint qeth_set_access_ctrl_online(struct qeth_card *card, int fallback)\r\n{\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 4, "setactlo");\r\nif ((card->info.type == QETH_CARD_TYPE_OSD ||\r\ncard->info.type == QETH_CARD_TYPE_OSX) &&\r\nqeth_adp_supported(card, IPA_SETADP_SET_ACCESS_CONTROL)) {\r\nrc = qeth_setadpparms_set_access_ctrl(card,\r\ncard->options.isolation, fallback);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(3,\r\n"IPA(SET_ACCESS_CTRL,%s,%d) sent failed\n",\r\ncard->gdev->dev.kobj.name,\r\nrc);\r\nrc = -EOPNOTSUPP;\r\n}\r\n} else if (card->options.isolation != ISOLATION_MODE_NONE) {\r\ncard->options.isolation = ISOLATION_MODE_NONE;\r\ndev_err(&card->gdev->dev, "Adapter does not "\r\n"support QDIO data connection isolation\n");\r\nrc = -EOPNOTSUPP;\r\n}\r\nreturn rc;\r\n}\r\nvoid qeth_tx_timeout(struct net_device *dev)\r\n{\r\nstruct qeth_card *card;\r\ncard = dev->ml_priv;\r\nQETH_CARD_TEXT(card, 4, "txtimeo");\r\ncard->stats.tx_errors++;\r\nqeth_schedule_recovery(card);\r\n}\r\nint qeth_mdio_read(struct net_device *dev, int phy_id, int regnum)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nint rc = 0;\r\nswitch (regnum) {\r\ncase MII_BMCR:\r\nrc = BMCR_FULLDPLX;\r\nif ((card->info.link_type != QETH_LINK_TYPE_GBIT_ETH) &&\r\n(card->info.link_type != QETH_LINK_TYPE_OSN) &&\r\n(card->info.link_type != QETH_LINK_TYPE_10GBIT_ETH))\r\nrc |= BMCR_SPEED100;\r\nbreak;\r\ncase MII_BMSR:\r\nrc = BMSR_ERCAP | BMSR_ANEGCOMPLETE | BMSR_LSTATUS |\r\nBMSR_10HALF | BMSR_10FULL | BMSR_100HALF | BMSR_100FULL |\r\nBMSR_100BASE4;\r\nbreak;\r\ncase MII_PHYSID1:\r\nrc = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 8) |\r\ndev->dev_addr[2];\r\nrc = (rc >> 5) & 0xFFFF;\r\nbreak;\r\ncase MII_PHYSID2:\r\nrc = (dev->dev_addr[2] << 10) & 0xFFFF;\r\nbreak;\r\ncase MII_ADVERTISE:\r\nrc = ADVERTISE_ALL;\r\nbreak;\r\ncase MII_LPA:\r\nrc = LPA_10HALF | LPA_10FULL | LPA_100HALF | LPA_100FULL |\r\nLPA_100BASE4 | LPA_LPACK;\r\nbreak;\r\ncase MII_EXPANSION:\r\nbreak;\r\ncase MII_DCOUNTER:\r\nbreak;\r\ncase MII_FCSCOUNTER:\r\nbreak;\r\ncase MII_NWAYTEST:\r\nbreak;\r\ncase MII_RERRCOUNTER:\r\nrc = card->stats.rx_errors;\r\nbreak;\r\ncase MII_SREVISION:\r\nbreak;\r\ncase MII_RESV1:\r\nbreak;\r\ncase MII_LBRERROR:\r\nbreak;\r\ncase MII_PHYADDR:\r\nbreak;\r\ncase MII_RESV2:\r\nbreak;\r\ncase MII_TPISTATUS:\r\nbreak;\r\ncase MII_NCONFIG:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_send_ipa_snmp_cmd(struct qeth_card *card,\r\nstruct qeth_cmd_buffer *iob, int len,\r\nint (*reply_cb)(struct qeth_card *, struct qeth_reply *,\r\nunsigned long),\r\nvoid *reply_param)\r\n{\r\nu16 s1, s2;\r\nQETH_CARD_TEXT(card, 4, "sendsnmp");\r\nmemcpy(iob->data, IPA_PDU_HEADER, IPA_PDU_HEADER_SIZE);\r\nmemcpy(QETH_IPA_CMD_DEST_ADDR(iob->data),\r\n&card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);\r\ns1 = (u32) IPA_PDU_HEADER_SIZE + len;\r\ns2 = (u32) len;\r\nmemcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);\r\nmemcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);\r\nmemcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);\r\nmemcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);\r\nreturn qeth_send_control_data(card, IPA_PDU_HEADER_SIZE + len, iob,\r\nreply_cb, reply_param);\r\n}\r\nstatic int qeth_snmp_command_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long sdata)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_arp_query_info *qinfo;\r\nstruct qeth_snmp_cmd *snmp;\r\nunsigned char *data;\r\n__u16 data_len;\r\nQETH_CARD_TEXT(card, 3, "snpcmdcb");\r\ncmd = (struct qeth_ipa_cmd *) sdata;\r\ndata = (unsigned char *)((char *)cmd - reply->offset);\r\nqinfo = (struct qeth_arp_query_info *) reply->param;\r\nsnmp = &cmd->data.setadapterparms.data.snmp;\r\nif (cmd->hdr.return_code) {\r\nQETH_CARD_TEXT_(card, 4, "scer1%i", cmd->hdr.return_code);\r\nreturn 0;\r\n}\r\nif (cmd->data.setadapterparms.hdr.return_code) {\r\ncmd->hdr.return_code =\r\ncmd->data.setadapterparms.hdr.return_code;\r\nQETH_CARD_TEXT_(card, 4, "scer2%i", cmd->hdr.return_code);\r\nreturn 0;\r\n}\r\ndata_len = *((__u16 *)QETH_IPA_PDU_LEN_PDU1(data));\r\nif (cmd->data.setadapterparms.hdr.seq_no == 1)\r\ndata_len -= (__u16)((char *)&snmp->data - (char *)cmd);\r\nelse\r\ndata_len -= (__u16)((char *)&snmp->request - (char *)cmd);\r\nif ((qinfo->udata_len - qinfo->udata_offset) < data_len) {\r\nQETH_CARD_TEXT_(card, 4, "scer3%i", -ENOMEM);\r\ncmd->hdr.return_code = IPA_RC_ENOMEM;\r\nreturn 0;\r\n}\r\nQETH_CARD_TEXT_(card, 4, "snore%i",\r\ncmd->data.setadapterparms.hdr.used_total);\r\nQETH_CARD_TEXT_(card, 4, "sseqn%i",\r\ncmd->data.setadapterparms.hdr.seq_no);\r\nif (cmd->data.setadapterparms.hdr.seq_no == 1) {\r\nmemcpy(qinfo->udata + qinfo->udata_offset,\r\n(char *)snmp,\r\ndata_len + offsetof(struct qeth_snmp_cmd, data));\r\nqinfo->udata_offset += offsetof(struct qeth_snmp_cmd, data);\r\n} else {\r\nmemcpy(qinfo->udata + qinfo->udata_offset,\r\n(char *)&snmp->request, data_len);\r\n}\r\nqinfo->udata_offset += data_len;\r\nQETH_CARD_TEXT_(card, 4, "srtot%i",\r\ncmd->data.setadapterparms.hdr.used_total);\r\nQETH_CARD_TEXT_(card, 4, "srseq%i",\r\ncmd->data.setadapterparms.hdr.seq_no);\r\nif (cmd->data.setadapterparms.hdr.seq_no <\r\ncmd->data.setadapterparms.hdr.used_total)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint qeth_snmp_command(struct qeth_card *card, char __user *udata)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_snmp_ureq *ureq;\r\nunsigned int req_len;\r\nstruct qeth_arp_query_info qinfo = {0, };\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 3, "snmpcmd");\r\nif (card->info.guestlan)\r\nreturn -EOPNOTSUPP;\r\nif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\r\n(!card->options.layer2)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\r\nreturn -EFAULT;\r\nif (req_len > (QETH_BUFSIZE - IPA_PDU_HEADER_SIZE -\r\nsizeof(struct qeth_ipacmd_hdr) -\r\nsizeof(struct qeth_ipacmd_setadpparms_hdr)))\r\nreturn -EINVAL;\r\nureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\r\nif (IS_ERR(ureq)) {\r\nQETH_CARD_TEXT(card, 2, "snmpnome");\r\nreturn PTR_ERR(ureq);\r\n}\r\nqinfo.udata_len = ureq->hdr.data_len;\r\nqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\r\nif (!qinfo.udata) {\r\nkfree(ureq);\r\nreturn -ENOMEM;\r\n}\r\nqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\r\niob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\r\nQETH_SNMP_SETADP_CMDLENGTH + req_len);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\nmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\r\nrc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\r\nqeth_snmp_command_cb, (void *)&qinfo);\r\nif (rc)\r\nQETH_DBF_MESSAGE(2, "SNMP command failed on %s: (0x%x)\n",\r\nQETH_CARD_IFNAME(card), rc);\r\nelse {\r\nif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\r\nrc = -EFAULT;\r\n}\r\nkfree(ureq);\r\nkfree(qinfo.udata);\r\nreturn rc;\r\n}\r\nstatic int qeth_setadpparms_query_oat_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_qoat_priv *priv;\r\nchar *resdata;\r\nint resdatalen;\r\nQETH_CARD_TEXT(card, 3, "qoatcb");\r\ncmd = (struct qeth_ipa_cmd *)data;\r\npriv = (struct qeth_qoat_priv *)reply->param;\r\nresdatalen = cmd->data.setadapterparms.hdr.cmdlength;\r\nresdata = (char *)data + 28;\r\nif (resdatalen > (priv->buffer_len - priv->response_len)) {\r\ncmd->hdr.return_code = IPA_RC_FFFF;\r\nreturn 0;\r\n}\r\nmemcpy((priv->buffer + priv->response_len), resdata,\r\nresdatalen);\r\npriv->response_len += resdatalen;\r\nif (cmd->data.setadapterparms.hdr.seq_no <\r\ncmd->data.setadapterparms.hdr.used_total)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint qeth_query_oat_command(struct qeth_card *card, char __user *udata)\r\n{\r\nint rc = 0;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_query_oat *oat_req;\r\nstruct qeth_query_oat_data oat_data;\r\nstruct qeth_qoat_priv priv;\r\nvoid __user *tmp;\r\nQETH_CARD_TEXT(card, 3, "qoatcmd");\r\nif (!qeth_adp_supported(card, IPA_SETADP_QUERY_OAT)) {\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (copy_from_user(&oat_data, udata,\r\nsizeof(struct qeth_query_oat_data))) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\npriv.buffer_len = oat_data.buffer_len;\r\npriv.response_len = 0;\r\npriv.buffer = kzalloc(oat_data.buffer_len, GFP_KERNEL);\r\nif (!priv.buffer) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\niob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_OAT,\r\nsizeof(struct qeth_ipacmd_setadpparms_hdr) +\r\nsizeof(struct qeth_query_oat));\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\noat_req = &cmd->data.setadapterparms.data.query_oat;\r\noat_req->subcmd_code = oat_data.command;\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_setadpparms_query_oat_cb,\r\n&priv);\r\nif (!rc) {\r\nif (is_compat_task())\r\ntmp = compat_ptr(oat_data.ptr);\r\nelse\r\ntmp = (void __user *)(unsigned long)oat_data.ptr;\r\nif (copy_to_user(tmp, priv.buffer,\r\npriv.response_len)) {\r\nrc = -EFAULT;\r\ngoto out_free;\r\n}\r\noat_data.response_len = priv.response_len;\r\nif (copy_to_user(udata, &oat_data,\r\nsizeof(struct qeth_query_oat_data)))\r\nrc = -EFAULT;\r\n} else\r\nif (rc == IPA_RC_FFFF)\r\nrc = -EFAULT;\r\nout_free:\r\nkfree(priv.buffer);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int qeth_query_card_info_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_query_card_info *card_info;\r\nstruct carrier_info *carrier_info;\r\nQETH_CARD_TEXT(card, 2, "qcrdincb");\r\ncarrier_info = (struct carrier_info *)reply->param;\r\ncmd = (struct qeth_ipa_cmd *)data;\r\ncard_info = &cmd->data.setadapterparms.data.card_info;\r\nif (cmd->data.setadapterparms.hdr.return_code == 0) {\r\ncarrier_info->card_type = card_info->card_type;\r\ncarrier_info->port_mode = card_info->port_mode;\r\ncarrier_info->port_speed = card_info->port_speed;\r\n}\r\nqeth_default_setadapterparms_cb(card, reply, (unsigned long) cmd);\r\nreturn 0;\r\n}\r\nint qeth_query_card_info(struct qeth_card *card,\r\nstruct carrier_info *carrier_info)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_CARD_TEXT(card, 2, "qcrdinfo");\r\nif (!qeth_adp_supported(card, IPA_SETADP_QUERY_CARD_INFO))\r\nreturn -EOPNOTSUPP;\r\niob = qeth_get_adapter_cmd(card, IPA_SETADP_QUERY_CARD_INFO,\r\nsizeof(struct qeth_ipacmd_setadpparms_hdr));\r\nreturn qeth_send_ipa_cmd(card, iob, qeth_query_card_info_cb,\r\n(void *)carrier_info);\r\n}\r\nstatic inline int qeth_get_qdio_q_format(struct qeth_card *card)\r\n{\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_IQD:\r\nreturn 2;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void qeth_determine_capabilities(struct qeth_card *card)\r\n{\r\nint rc;\r\nint length;\r\nchar *prcd;\r\nstruct ccw_device *ddev;\r\nint ddev_offline = 0;\r\nQETH_DBF_TEXT(SETUP, 2, "detcapab");\r\nddev = CARD_DDEV(card);\r\nif (!ddev->online) {\r\nddev_offline = 1;\r\nrc = ccw_device_set_online(ddev);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "3err%d", rc);\r\ngoto out;\r\n}\r\n}\r\nrc = qeth_read_conf_data(card, (void **) &prcd, &length);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "%s qeth_read_conf_data returned %i\n",\r\ndev_name(&card->gdev->dev), rc);\r\nQETH_DBF_TEXT_(SETUP, 2, "5err%d", rc);\r\ngoto out_offline;\r\n}\r\nqeth_configure_unitaddr(card, prcd);\r\nif (ddev_offline)\r\nqeth_configure_blkt_default(card, prcd);\r\nkfree(prcd);\r\nrc = qdio_get_ssqd_desc(ddev, &card->ssqd);\r\nif (rc)\r\nQETH_DBF_TEXT_(SETUP, 2, "6err%d", rc);\r\nQETH_DBF_TEXT_(SETUP, 2, "qfmt%d", card->ssqd.qfmt);\r\nQETH_DBF_TEXT_(SETUP, 2, "%d", card->ssqd.qdioac1);\r\nQETH_DBF_TEXT_(SETUP, 2, "%d", card->ssqd.qdioac3);\r\nQETH_DBF_TEXT_(SETUP, 2, "icnt%d", card->ssqd.icnt);\r\nif (!((card->ssqd.qfmt != QDIO_IQDIO_QFMT) ||\r\n((card->ssqd.qdioac1 & CHSC_AC1_INITIATE_INPUTQ) == 0) ||\r\n((card->ssqd.qdioac3 & CHSC_AC3_FORMAT2_CQ_AVAILABLE) == 0))) {\r\ndev_info(&card->gdev->dev,\r\n"Completion Queueing supported\n");\r\n} else {\r\ncard->options.cq = QETH_CQ_NOTAVAILABLE;\r\n}\r\nout_offline:\r\nif (ddev_offline == 1)\r\nccw_device_set_offline(ddev);\r\nout:\r\nreturn;\r\n}\r\nstatic inline void qeth_qdio_establish_cq(struct qeth_card *card,\r\nstruct qdio_buffer **in_sbal_ptrs,\r\nvoid (**queue_start_poll) (struct ccw_device *, int, unsigned long)) {\r\nint i;\r\nif (card->options.cq == QETH_CQ_ENABLED) {\r\nint offset = QDIO_MAX_BUFFERS_PER_Q *\r\n(card->qdio.no_in_queues - 1);\r\ni = QDIO_MAX_BUFFERS_PER_Q * (card->qdio.no_in_queues - 1);\r\nfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\r\nin_sbal_ptrs[offset + i] = (struct qdio_buffer *)\r\nvirt_to_phys(card->qdio.c_q->bufs[i].buffer);\r\n}\r\nqueue_start_poll[card->qdio.no_in_queues - 1] = NULL;\r\n}\r\n}\r\nstatic int qeth_qdio_establish(struct qeth_card *card)\r\n{\r\nstruct qdio_initialize init_data;\r\nchar *qib_param_field;\r\nstruct qdio_buffer **in_sbal_ptrs;\r\nvoid (**queue_start_poll) (struct ccw_device *, int, unsigned long);\r\nstruct qdio_buffer **out_sbal_ptrs;\r\nint i, j, k;\r\nint rc = 0;\r\nQETH_DBF_TEXT(SETUP, 2, "qdioest");\r\nqib_param_field = kzalloc(QDIO_MAX_BUFFERS_PER_Q * sizeof(char),\r\nGFP_KERNEL);\r\nif (!qib_param_field) {\r\nrc = -ENOMEM;\r\ngoto out_free_nothing;\r\n}\r\nqeth_create_qib_param_field(card, qib_param_field);\r\nqeth_create_qib_param_field_blkt(card, qib_param_field);\r\nin_sbal_ptrs = kzalloc(card->qdio.no_in_queues *\r\nQDIO_MAX_BUFFERS_PER_Q * sizeof(void *),\r\nGFP_KERNEL);\r\nif (!in_sbal_ptrs) {\r\nrc = -ENOMEM;\r\ngoto out_free_qib_param;\r\n}\r\nfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; ++i) {\r\nin_sbal_ptrs[i] = (struct qdio_buffer *)\r\nvirt_to_phys(card->qdio.in_q->bufs[i].buffer);\r\n}\r\nqueue_start_poll = kzalloc(sizeof(void *) * card->qdio.no_in_queues,\r\nGFP_KERNEL);\r\nif (!queue_start_poll) {\r\nrc = -ENOMEM;\r\ngoto out_free_in_sbals;\r\n}\r\nfor (i = 0; i < card->qdio.no_in_queues; ++i)\r\nqueue_start_poll[i] = card->discipline->start_poll;\r\nqeth_qdio_establish_cq(card, in_sbal_ptrs, queue_start_poll);\r\nout_sbal_ptrs =\r\nkzalloc(card->qdio.no_out_queues * QDIO_MAX_BUFFERS_PER_Q *\r\nsizeof(void *), GFP_KERNEL);\r\nif (!out_sbal_ptrs) {\r\nrc = -ENOMEM;\r\ngoto out_free_queue_start_poll;\r\n}\r\nfor (i = 0, k = 0; i < card->qdio.no_out_queues; ++i)\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j, ++k) {\r\nout_sbal_ptrs[k] = (struct qdio_buffer *)virt_to_phys(\r\ncard->qdio.out_qs[i]->bufs[j]->buffer);\r\n}\r\nmemset(&init_data, 0, sizeof(struct qdio_initialize));\r\ninit_data.cdev = CARD_DDEV(card);\r\ninit_data.q_format = qeth_get_qdio_q_format(card);\r\ninit_data.qib_param_field_format = 0;\r\ninit_data.qib_param_field = qib_param_field;\r\ninit_data.no_input_qs = card->qdio.no_in_queues;\r\ninit_data.no_output_qs = card->qdio.no_out_queues;\r\ninit_data.input_handler = card->discipline->input_handler;\r\ninit_data.output_handler = card->discipline->output_handler;\r\ninit_data.queue_start_poll_array = queue_start_poll;\r\ninit_data.int_parm = (unsigned long) card;\r\ninit_data.input_sbal_addr_array = (void **) in_sbal_ptrs;\r\ninit_data.output_sbal_addr_array = (void **) out_sbal_ptrs;\r\ninit_data.output_sbal_state_array = card->qdio.out_bufstates;\r\ninit_data.scan_threshold =\r\n(card->info.type == QETH_CARD_TYPE_IQD) ? 1 : 32;\r\nif (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ALLOCATED,\r\nQETH_QDIO_ESTABLISHED) == QETH_QDIO_ALLOCATED) {\r\nrc = qdio_allocate(&init_data);\r\nif (rc) {\r\natomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\r\ngoto out;\r\n}\r\nrc = qdio_establish(&init_data);\r\nif (rc) {\r\natomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);\r\nqdio_free(CARD_DDEV(card));\r\n}\r\n}\r\nswitch (card->options.cq) {\r\ncase QETH_CQ_ENABLED:\r\ndev_info(&card->gdev->dev, "Completion Queue support enabled");\r\nbreak;\r\ncase QETH_CQ_DISABLED:\r\ndev_info(&card->gdev->dev, "Completion Queue support disabled");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nkfree(out_sbal_ptrs);\r\nout_free_queue_start_poll:\r\nkfree(queue_start_poll);\r\nout_free_in_sbals:\r\nkfree(in_sbal_ptrs);\r\nout_free_qib_param:\r\nkfree(qib_param_field);\r\nout_free_nothing:\r\nreturn rc;\r\n}\r\nstatic void qeth_core_free_card(struct qeth_card *card)\r\n{\r\nQETH_DBF_TEXT(SETUP, 2, "freecrd");\r\nQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\r\nqeth_clean_channel(&card->read);\r\nqeth_clean_channel(&card->write);\r\nif (card->dev)\r\nfree_netdev(card->dev);\r\nkfree(card->ip_tbd_list);\r\nqeth_free_qdio_buffers(card);\r\nunregister_service_level(&card->qeth_service_level);\r\nkfree(card);\r\n}\r\nvoid qeth_trace_features(struct qeth_card *card)\r\n{\r\nQETH_CARD_TEXT(card, 2, "features");\r\nQETH_CARD_TEXT_(card, 2, "%x", card->options.ipa4.supported_funcs);\r\nQETH_CARD_TEXT_(card, 2, "%x", card->options.ipa4.enabled_funcs);\r\nQETH_CARD_TEXT_(card, 2, "%x", card->options.ipa6.supported_funcs);\r\nQETH_CARD_TEXT_(card, 2, "%x", card->options.ipa6.enabled_funcs);\r\nQETH_CARD_TEXT_(card, 2, "%x", card->options.adp.supported_funcs);\r\nQETH_CARD_TEXT_(card, 2, "%x", card->options.adp.enabled_funcs);\r\nQETH_CARD_TEXT_(card, 2, "%x", card->info.diagass_support);\r\n}\r\nint qeth_core_hardsetup_card(struct qeth_card *card)\r\n{\r\nint retries = 3;\r\nint rc;\r\nQETH_DBF_TEXT(SETUP, 2, "hrdsetup");\r\natomic_set(&card->force_alloc_skb, 0);\r\nqeth_update_from_chp_desc(card);\r\nretry:\r\nif (retries < 3)\r\nQETH_DBF_MESSAGE(2, "%s Retrying to do IDX activates.\n",\r\ndev_name(&card->gdev->dev));\r\nrc = qeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);\r\nccw_device_set_offline(CARD_DDEV(card));\r\nccw_device_set_offline(CARD_WDEV(card));\r\nccw_device_set_offline(CARD_RDEV(card));\r\nqdio_free(CARD_DDEV(card));\r\nrc = ccw_device_set_online(CARD_RDEV(card));\r\nif (rc)\r\ngoto retriable;\r\nrc = ccw_device_set_online(CARD_WDEV(card));\r\nif (rc)\r\ngoto retriable;\r\nrc = ccw_device_set_online(CARD_DDEV(card));\r\nif (rc)\r\ngoto retriable;\r\nretriable:\r\nif (rc == -ERESTARTSYS) {\r\nQETH_DBF_TEXT(SETUP, 2, "break1");\r\nreturn rc;\r\n} else if (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\nif (--retries < 0)\r\ngoto out;\r\nelse\r\ngoto retry;\r\n}\r\nqeth_determine_capabilities(card);\r\nqeth_init_tokens(card);\r\nqeth_init_func_level(card);\r\nrc = qeth_idx_activate_channel(&card->read, qeth_idx_read_cb);\r\nif (rc == -ERESTARTSYS) {\r\nQETH_DBF_TEXT(SETUP, 2, "break2");\r\nreturn rc;\r\n} else if (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "3err%d", rc);\r\nif (--retries < 0)\r\ngoto out;\r\nelse\r\ngoto retry;\r\n}\r\nrc = qeth_idx_activate_channel(&card->write, qeth_idx_write_cb);\r\nif (rc == -ERESTARTSYS) {\r\nQETH_DBF_TEXT(SETUP, 2, "break3");\r\nreturn rc;\r\n} else if (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "4err%d", rc);\r\nif (--retries < 0)\r\ngoto out;\r\nelse\r\ngoto retry;\r\n}\r\ncard->read_or_write_problem = 0;\r\nrc = qeth_mpc_initialize(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "5err%d", rc);\r\ngoto out;\r\n}\r\ncard->options.ipa4.supported_funcs = 0;\r\ncard->options.adp.supported_funcs = 0;\r\ncard->options.sbp.supported_funcs = 0;\r\ncard->info.diagass_support = 0;\r\nqeth_query_ipassists(card, QETH_PROT_IPV4);\r\nif (qeth_is_supported(card, IPA_SETADAPTERPARMS))\r\nqeth_query_setadapterparms(card);\r\nif (qeth_adp_supported(card, IPA_SETADP_SET_DIAG_ASSIST))\r\nqeth_query_setdiagass(card);\r\nreturn 0;\r\nout:\r\ndev_warn(&card->gdev->dev, "The qeth device driver failed to recover "\r\n"an error on the device\n");\r\nQETH_DBF_MESSAGE(2, "%s Initialization in hardsetup failed! rc=%d\n",\r\ndev_name(&card->gdev->dev), rc);\r\nreturn rc;\r\n}\r\nstatic inline int qeth_create_skb_frag(struct qeth_qdio_buffer *qethbuffer,\r\nstruct qdio_buffer_element *element,\r\nstruct sk_buff **pskb, int offset, int *pfrag, int data_len)\r\n{\r\nstruct page *page = virt_to_page(element->addr);\r\nif (*pskb == NULL) {\r\nif (qethbuffer->rx_skb) {\r\n*pskb = qethbuffer->rx_skb;\r\nqethbuffer->rx_skb = NULL;\r\n} else {\r\n*pskb = dev_alloc_skb(QETH_RX_PULL_LEN + ETH_HLEN);\r\nif (!(*pskb))\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(*pskb, ETH_HLEN);\r\nif (data_len <= QETH_RX_PULL_LEN) {\r\nmemcpy(skb_put(*pskb, data_len), element->addr + offset,\r\ndata_len);\r\n} else {\r\nget_page(page);\r\nmemcpy(skb_put(*pskb, QETH_RX_PULL_LEN),\r\nelement->addr + offset, QETH_RX_PULL_LEN);\r\nskb_fill_page_desc(*pskb, *pfrag, page,\r\noffset + QETH_RX_PULL_LEN,\r\ndata_len - QETH_RX_PULL_LEN);\r\n(*pskb)->data_len += data_len - QETH_RX_PULL_LEN;\r\n(*pskb)->len += data_len - QETH_RX_PULL_LEN;\r\n(*pskb)->truesize += data_len - QETH_RX_PULL_LEN;\r\n(*pfrag)++;\r\n}\r\n} else {\r\nget_page(page);\r\nskb_fill_page_desc(*pskb, *pfrag, page, offset, data_len);\r\n(*pskb)->data_len += data_len;\r\n(*pskb)->len += data_len;\r\n(*pskb)->truesize += data_len;\r\n(*pfrag)++;\r\n}\r\nreturn 0;\r\n}\r\nstruct sk_buff *qeth_core_get_next_skb(struct qeth_card *card,\r\nstruct qeth_qdio_buffer *qethbuffer,\r\nstruct qdio_buffer_element **__element, int *__offset,\r\nstruct qeth_hdr **hdr)\r\n{\r\nstruct qdio_buffer_element *element = *__element;\r\nstruct qdio_buffer *buffer = qethbuffer->buffer;\r\nint offset = *__offset;\r\nstruct sk_buff *skb = NULL;\r\nint skb_len = 0;\r\nvoid *data_ptr;\r\nint data_len;\r\nint headroom = 0;\r\nint use_rx_sg = 0;\r\nint frag = 0;\r\nif (element->length < offset + sizeof(struct qeth_hdr)) {\r\nif (qeth_is_last_sbale(element))\r\nreturn NULL;\r\nelement++;\r\noffset = 0;\r\nif (element->length < sizeof(struct qeth_hdr))\r\nreturn NULL;\r\n}\r\n*hdr = element->addr + offset;\r\noffset += sizeof(struct qeth_hdr);\r\nswitch ((*hdr)->hdr.l2.id) {\r\ncase QETH_HEADER_TYPE_LAYER2:\r\nskb_len = (*hdr)->hdr.l2.pkt_length;\r\nbreak;\r\ncase QETH_HEADER_TYPE_LAYER3:\r\nskb_len = (*hdr)->hdr.l3.length;\r\nheadroom = ETH_HLEN;\r\nbreak;\r\ncase QETH_HEADER_TYPE_OSN:\r\nskb_len = (*hdr)->hdr.osn.pdu_length;\r\nheadroom = sizeof(struct qeth_hdr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!skb_len)\r\nreturn NULL;\r\nif (((skb_len >= card->options.rx_sg_cb) &&\r\n(!(card->info.type == QETH_CARD_TYPE_OSN)) &&\r\n(!atomic_read(&card->force_alloc_skb))) ||\r\n(card->options.cq == QETH_CQ_ENABLED)) {\r\nuse_rx_sg = 1;\r\n} else {\r\nskb = dev_alloc_skb(skb_len + headroom);\r\nif (!skb)\r\ngoto no_mem;\r\nif (headroom)\r\nskb_reserve(skb, headroom);\r\n}\r\ndata_ptr = element->addr + offset;\r\nwhile (skb_len) {\r\ndata_len = min(skb_len, (int)(element->length - offset));\r\nif (data_len) {\r\nif (use_rx_sg) {\r\nif (qeth_create_skb_frag(qethbuffer, element,\r\n&skb, offset, &frag, data_len))\r\ngoto no_mem;\r\n} else {\r\nmemcpy(skb_put(skb, data_len), data_ptr,\r\ndata_len);\r\n}\r\n}\r\nskb_len -= data_len;\r\nif (skb_len) {\r\nif (qeth_is_last_sbale(element)) {\r\nQETH_CARD_TEXT(card, 4, "unexeob");\r\nQETH_CARD_HEX(card, 2, buffer, sizeof(void *));\r\ndev_kfree_skb_any(skb);\r\ncard->stats.rx_errors++;\r\nreturn NULL;\r\n}\r\nelement++;\r\noffset = 0;\r\ndata_ptr = element->addr;\r\n} else {\r\noffset += data_len;\r\n}\r\n}\r\n*__element = element;\r\n*__offset = offset;\r\nif (use_rx_sg && card->options.performance_stats) {\r\ncard->perf_stats.sg_skbs_rx++;\r\ncard->perf_stats.sg_frags_rx += skb_shinfo(skb)->nr_frags;\r\n}\r\nreturn skb;\r\nno_mem:\r\nif (net_ratelimit()) {\r\nQETH_CARD_TEXT(card, 2, "noskbmem");\r\n}\r\ncard->stats.rx_dropped++;\r\nreturn NULL;\r\n}\r\nstatic void qeth_unregister_dbf_views(void)\r\n{\r\nint x;\r\nfor (x = 0; x < QETH_DBF_INFOS; x++) {\r\ndebug_unregister(qeth_dbf[x].id);\r\nqeth_dbf[x].id = NULL;\r\n}\r\n}\r\nvoid qeth_dbf_longtext(debug_info_t *id, int level, char *fmt, ...)\r\n{\r\nchar dbf_txt_buf[32];\r\nva_list args;\r\nif (!debug_level_enabled(id, level))\r\nreturn;\r\nva_start(args, fmt);\r\nvsnprintf(dbf_txt_buf, sizeof(dbf_txt_buf), fmt, args);\r\nva_end(args);\r\ndebug_text_event(id, level, dbf_txt_buf);\r\n}\r\nstatic int qeth_register_dbf_views(void)\r\n{\r\nint ret;\r\nint x;\r\nfor (x = 0; x < QETH_DBF_INFOS; x++) {\r\nqeth_dbf[x].id = debug_register(qeth_dbf[x].name,\r\nqeth_dbf[x].pages,\r\nqeth_dbf[x].areas,\r\nqeth_dbf[x].len);\r\nif (qeth_dbf[x].id == NULL) {\r\nqeth_unregister_dbf_views();\r\nreturn -ENOMEM;\r\n}\r\nret = debug_register_view(qeth_dbf[x].id, qeth_dbf[x].view);\r\nif (ret) {\r\nqeth_unregister_dbf_views();\r\nreturn ret;\r\n}\r\ndebug_set_level(qeth_dbf[x].id, qeth_dbf[x].level);\r\n}\r\nreturn 0;\r\n}\r\nint qeth_core_load_discipline(struct qeth_card *card,\r\nenum qeth_discipline_id discipline)\r\n{\r\nint rc = 0;\r\nmutex_lock(&qeth_mod_mutex);\r\nswitch (discipline) {\r\ncase QETH_DISCIPLINE_LAYER3:\r\ncard->discipline = try_then_request_module(\r\nsymbol_get(qeth_l3_discipline), "qeth_l3");\r\nbreak;\r\ncase QETH_DISCIPLINE_LAYER2:\r\ncard->discipline = try_then_request_module(\r\nsymbol_get(qeth_l2_discipline), "qeth_l2");\r\nbreak;\r\n}\r\nif (!card->discipline) {\r\ndev_err(&card->gdev->dev, "There is no kernel module to "\r\n"support discipline %d\n", discipline);\r\nrc = -EINVAL;\r\n}\r\nmutex_unlock(&qeth_mod_mutex);\r\nreturn rc;\r\n}\r\nvoid qeth_core_free_discipline(struct qeth_card *card)\r\n{\r\nif (card->options.layer2)\r\nsymbol_put(qeth_l2_discipline);\r\nelse\r\nsymbol_put(qeth_l3_discipline);\r\ncard->discipline = NULL;\r\n}\r\nstatic debug_info_t *qeth_get_dbf_entry(char *name)\r\n{\r\nstruct qeth_dbf_entry *entry;\r\ndebug_info_t *rc = NULL;\r\nmutex_lock(&qeth_dbf_list_mutex);\r\nlist_for_each_entry(entry, &qeth_dbf_list, dbf_list) {\r\nif (strcmp(entry->dbf_name, name) == 0) {\r\nrc = entry->dbf_info;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&qeth_dbf_list_mutex);\r\nreturn rc;\r\n}\r\nstatic int qeth_add_dbf_entry(struct qeth_card *card, char *name)\r\n{\r\nstruct qeth_dbf_entry *new_entry;\r\ncard->debug = debug_register(name, 2, 1, 8);\r\nif (!card->debug) {\r\nQETH_DBF_TEXT_(SETUP, 2, "%s", "qcdbf");\r\ngoto err;\r\n}\r\nif (debug_register_view(card->debug, &debug_hex_ascii_view))\r\ngoto err_dbg;\r\nnew_entry = kzalloc(sizeof(struct qeth_dbf_entry), GFP_KERNEL);\r\nif (!new_entry)\r\ngoto err_dbg;\r\nstrncpy(new_entry->dbf_name, name, DBF_NAME_LEN);\r\nnew_entry->dbf_info = card->debug;\r\nmutex_lock(&qeth_dbf_list_mutex);\r\nlist_add(&new_entry->dbf_list, &qeth_dbf_list);\r\nmutex_unlock(&qeth_dbf_list_mutex);\r\nreturn 0;\r\nerr_dbg:\r\ndebug_unregister(card->debug);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void qeth_clear_dbf_list(void)\r\n{\r\nstruct qeth_dbf_entry *entry, *tmp;\r\nmutex_lock(&qeth_dbf_list_mutex);\r\nlist_for_each_entry_safe(entry, tmp, &qeth_dbf_list, dbf_list) {\r\nlist_del(&entry->dbf_list);\r\ndebug_unregister(entry->dbf_info);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&qeth_dbf_list_mutex);\r\n}\r\nstatic int qeth_core_probe_device(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card;\r\nstruct device *dev;\r\nint rc;\r\nunsigned long flags;\r\nchar dbf_name[DBF_NAME_LEN];\r\nQETH_DBF_TEXT(SETUP, 2, "probedev");\r\ndev = &gdev->dev;\r\nif (!get_device(dev))\r\nreturn -ENODEV;\r\nQETH_DBF_TEXT_(SETUP, 2, "%s", dev_name(&gdev->dev));\r\ncard = qeth_alloc_card();\r\nif (!card) {\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", -ENOMEM);\r\nrc = -ENOMEM;\r\ngoto err_dev;\r\n}\r\nsnprintf(dbf_name, sizeof(dbf_name), "qeth_card_%s",\r\ndev_name(&gdev->dev));\r\ncard->debug = qeth_get_dbf_entry(dbf_name);\r\nif (!card->debug) {\r\nrc = qeth_add_dbf_entry(card, dbf_name);\r\nif (rc)\r\ngoto err_card;\r\n}\r\ncard->read.ccwdev = gdev->cdev[0];\r\ncard->write.ccwdev = gdev->cdev[1];\r\ncard->data.ccwdev = gdev->cdev[2];\r\ndev_set_drvdata(&gdev->dev, card);\r\ncard->gdev = gdev;\r\ngdev->cdev[0]->handler = qeth_irq;\r\ngdev->cdev[1]->handler = qeth_irq;\r\ngdev->cdev[2]->handler = qeth_irq;\r\nrc = qeth_determine_card_type(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "3err%d", rc);\r\ngoto err_card;\r\n}\r\nrc = qeth_setup_card(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "2err%d", rc);\r\ngoto err_card;\r\n}\r\nif (card->info.type == QETH_CARD_TYPE_OSN)\r\ngdev->dev.type = &qeth_osn_devtype;\r\nelse\r\ngdev->dev.type = &qeth_generic_devtype;\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_OSN:\r\ncase QETH_CARD_TYPE_OSM:\r\nrc = qeth_core_load_discipline(card, QETH_DISCIPLINE_LAYER2);\r\nif (rc)\r\ngoto err_card;\r\nrc = card->discipline->setup(card->gdev);\r\nif (rc)\r\ngoto err_disc;\r\ncase QETH_CARD_TYPE_OSD:\r\ncase QETH_CARD_TYPE_OSX:\r\ndefault:\r\nbreak;\r\n}\r\nwrite_lock_irqsave(&qeth_core_card_list.rwlock, flags);\r\nlist_add_tail(&card->list, &qeth_core_card_list.list);\r\nwrite_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\r\nqeth_determine_capabilities(card);\r\nreturn 0;\r\nerr_disc:\r\nqeth_core_free_discipline(card);\r\nerr_card:\r\nqeth_core_free_card(card);\r\nerr_dev:\r\nput_device(dev);\r\nreturn rc;\r\n}\r\nstatic void qeth_core_remove_device(struct ccwgroup_device *gdev)\r\n{\r\nunsigned long flags;\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nQETH_DBF_TEXT(SETUP, 2, "removedv");\r\nif (card->discipline) {\r\ncard->discipline->remove(gdev);\r\nqeth_core_free_discipline(card);\r\n}\r\nwrite_lock_irqsave(&qeth_core_card_list.rwlock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\r\nqeth_core_free_card(card);\r\ndev_set_drvdata(&gdev->dev, NULL);\r\nput_device(&gdev->dev);\r\nreturn;\r\n}\r\nstatic int qeth_core_set_online(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nint rc = 0;\r\nint def_discipline;\r\nif (!card->discipline) {\r\nif (card->info.type == QETH_CARD_TYPE_IQD)\r\ndef_discipline = QETH_DISCIPLINE_LAYER3;\r\nelse\r\ndef_discipline = QETH_DISCIPLINE_LAYER2;\r\nrc = qeth_core_load_discipline(card, def_discipline);\r\nif (rc)\r\ngoto err;\r\nrc = card->discipline->setup(card->gdev);\r\nif (rc)\r\ngoto err;\r\n}\r\nrc = card->discipline->set_online(gdev);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int qeth_core_set_offline(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nreturn card->discipline->set_offline(gdev);\r\n}\r\nstatic void qeth_core_shutdown(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nif (card->discipline && card->discipline->shutdown)\r\ncard->discipline->shutdown(gdev);\r\n}\r\nstatic int qeth_core_prepare(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nif (card->discipline && card->discipline->prepare)\r\nreturn card->discipline->prepare(gdev);\r\nreturn 0;\r\n}\r\nstatic void qeth_core_complete(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nif (card->discipline && card->discipline->complete)\r\ncard->discipline->complete(gdev);\r\n}\r\nstatic int qeth_core_freeze(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nif (card->discipline && card->discipline->freeze)\r\nreturn card->discipline->freeze(gdev);\r\nreturn 0;\r\n}\r\nstatic int qeth_core_thaw(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nif (card->discipline && card->discipline->thaw)\r\nreturn card->discipline->thaw(gdev);\r\nreturn 0;\r\n}\r\nstatic int qeth_core_restore(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nif (card->discipline && card->discipline->restore)\r\nreturn card->discipline->restore(gdev);\r\nreturn 0;\r\n}\r\nstatic ssize_t qeth_core_driver_group_store(struct device_driver *ddrv,\r\nconst char *buf, size_t count)\r\n{\r\nint err;\r\nerr = ccwgroup_create_dev(qeth_core_root_dev,\r\n&qeth_core_ccwgroup_driver, 3, buf);\r\nreturn err ? err : count;\r\n}\r\nint qeth_core_get_sset_count(struct net_device *dev, int stringset)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nreturn (sizeof(qeth_ethtool_stats_keys) / ETH_GSTRING_LEN);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nvoid qeth_core_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\ndata[0] = card->stats.rx_packets -\r\ncard->perf_stats.initial_rx_packets;\r\ndata[1] = card->perf_stats.bufs_rec;\r\ndata[2] = card->stats.tx_packets -\r\ncard->perf_stats.initial_tx_packets;\r\ndata[3] = card->perf_stats.bufs_sent;\r\ndata[4] = card->stats.tx_packets - card->perf_stats.initial_tx_packets\r\n- card->perf_stats.skbs_sent_pack;\r\ndata[5] = card->perf_stats.bufs_sent - card->perf_stats.bufs_sent_pack;\r\ndata[6] = card->perf_stats.skbs_sent_pack;\r\ndata[7] = card->perf_stats.bufs_sent_pack;\r\ndata[8] = card->perf_stats.sg_skbs_sent;\r\ndata[9] = card->perf_stats.sg_frags_sent;\r\ndata[10] = card->perf_stats.sg_skbs_rx;\r\ndata[11] = card->perf_stats.sg_frags_rx;\r\ndata[12] = card->perf_stats.sg_alloc_page_rx;\r\ndata[13] = (card->perf_stats.large_send_bytes >> 10);\r\ndata[14] = card->perf_stats.large_send_cnt;\r\ndata[15] = card->perf_stats.sc_dp_p;\r\ndata[16] = card->perf_stats.sc_p_dp;\r\ndata[17] = QETH_LOW_WATERMARK_PACK;\r\ndata[18] = QETH_HIGH_WATERMARK_PACK;\r\ndata[19] = atomic_read(&card->qdio.out_qs[0]->used_buffers);\r\ndata[20] = (card->qdio.no_out_queues > 1) ?\r\natomic_read(&card->qdio.out_qs[1]->used_buffers) : 0;\r\ndata[21] = (card->qdio.no_out_queues > 2) ?\r\natomic_read(&card->qdio.out_qs[2]->used_buffers) : 0;\r\ndata[22] = (card->qdio.no_out_queues > 3) ?\r\natomic_read(&card->qdio.out_qs[3]->used_buffers) : 0;\r\ndata[23] = card->perf_stats.inbound_time;\r\ndata[24] = card->perf_stats.inbound_cnt;\r\ndata[25] = card->perf_stats.inbound_do_qdio_time;\r\ndata[26] = card->perf_stats.inbound_do_qdio_cnt;\r\ndata[27] = card->perf_stats.outbound_handler_time;\r\ndata[28] = card->perf_stats.outbound_handler_cnt;\r\ndata[29] = card->perf_stats.outbound_time;\r\ndata[30] = card->perf_stats.outbound_cnt;\r\ndata[31] = card->perf_stats.outbound_do_qdio_time;\r\ndata[32] = card->perf_stats.outbound_do_qdio_cnt;\r\ndata[33] = card->perf_stats.tx_csum;\r\ndata[34] = card->perf_stats.tx_lin;\r\ndata[35] = card->perf_stats.cq_cnt;\r\ndata[36] = card->perf_stats.cq_time;\r\n}\r\nvoid qeth_core_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(data, &qeth_ethtool_stats_keys,\r\nsizeof(qeth_ethtool_stats_keys));\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nvoid qeth_core_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nstrlcpy(info->driver, card->options.layer2 ? "qeth_l2" : "qeth_l3",\r\nsizeof(info->driver));\r\nstrlcpy(info->version, "1.0", sizeof(info->version));\r\nstrlcpy(info->fw_version, card->info.mcl_level,\r\nsizeof(info->fw_version));\r\nsnprintf(info->bus_info, sizeof(info->bus_info), "%s/%s/%s",\r\nCARD_RDEV_ID(card), CARD_WDEV_ID(card), CARD_DDEV_ID(card));\r\n}\r\nstatic void qeth_set_ecmd_adv_sup(struct ethtool_cmd *ecmd,\r\nint maxspeed, int porttype)\r\n{\r\nint port_sup, port_adv, spd_sup, spd_adv;\r\nswitch (porttype) {\r\ncase PORT_TP:\r\nport_sup = SUPPORTED_TP;\r\nport_adv = ADVERTISED_TP;\r\nbreak;\r\ncase PORT_FIBRE:\r\nport_sup = SUPPORTED_FIBRE;\r\nport_adv = ADVERTISED_FIBRE;\r\nbreak;\r\ndefault:\r\nport_sup = SUPPORTED_TP;\r\nport_adv = ADVERTISED_TP;\r\nWARN_ON_ONCE(1);\r\n}\r\nspd_sup = 0;\r\nspd_adv = 0;\r\nswitch (maxspeed) {\r\ncase SPEED_10000:\r\nspd_sup |= SUPPORTED_10000baseT_Full;\r\nspd_adv |= ADVERTISED_10000baseT_Full;\r\ncase SPEED_1000:\r\nspd_sup |= SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full;\r\nspd_adv |= ADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full;\r\ncase SPEED_100:\r\nspd_sup |= SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full;\r\nspd_adv |= ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full;\r\ncase SPEED_10:\r\nspd_sup |= SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full;\r\nspd_adv |= ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full;\r\nbreak;\r\ndefault:\r\nspd_sup = SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full;\r\nspd_adv = ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full;\r\nWARN_ON_ONCE(1);\r\n}\r\necmd->advertising = ADVERTISED_Autoneg | port_adv | spd_adv;\r\necmd->supported = SUPPORTED_Autoneg | port_sup | spd_sup;\r\n}\r\nint qeth_core_ethtool_get_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct qeth_card *card = netdev->ml_priv;\r\nenum qeth_link_types link_type;\r\nstruct carrier_info carrier_info;\r\nint rc;\r\nu32 speed;\r\nif ((card->info.type == QETH_CARD_TYPE_IQD) || (card->info.guestlan))\r\nlink_type = QETH_LINK_TYPE_10GBIT_ETH;\r\nelse\r\nlink_type = card->info.link_type;\r\necmd->transceiver = XCVR_INTERNAL;\r\necmd->duplex = DUPLEX_FULL;\r\necmd->autoneg = AUTONEG_ENABLE;\r\nswitch (link_type) {\r\ncase QETH_LINK_TYPE_FAST_ETH:\r\ncase QETH_LINK_TYPE_LANE_ETH100:\r\nqeth_set_ecmd_adv_sup(ecmd, SPEED_100, PORT_TP);\r\nspeed = SPEED_100;\r\necmd->port = PORT_TP;\r\nbreak;\r\ncase QETH_LINK_TYPE_GBIT_ETH:\r\ncase QETH_LINK_TYPE_LANE_ETH1000:\r\nqeth_set_ecmd_adv_sup(ecmd, SPEED_1000, PORT_FIBRE);\r\nspeed = SPEED_1000;\r\necmd->port = PORT_FIBRE;\r\nbreak;\r\ncase QETH_LINK_TYPE_10GBIT_ETH:\r\nqeth_set_ecmd_adv_sup(ecmd, SPEED_10000, PORT_FIBRE);\r\nspeed = SPEED_10000;\r\necmd->port = PORT_FIBRE;\r\nbreak;\r\ndefault:\r\nqeth_set_ecmd_adv_sup(ecmd, SPEED_10, PORT_TP);\r\nspeed = SPEED_10;\r\necmd->port = PORT_TP;\r\n}\r\nethtool_cmd_speed_set(ecmd, speed);\r\nif (!qeth_card_hw_is_reachable(card))\r\nreturn -ENODEV;\r\nrc = qeth_query_card_info(card, &carrier_info);\r\nif (rc == -EOPNOTSUPP)\r\nreturn 0;\r\nif (rc)\r\nreturn rc;\r\nnetdev_dbg(netdev,\r\n"card info: card_type=0x%02x, port_mode=0x%04x, port_speed=0x%08x\n",\r\ncarrier_info.card_type,\r\ncarrier_info.port_mode,\r\ncarrier_info.port_speed);\r\nswitch (carrier_info.card_type) {\r\ncase CARD_INFO_TYPE_1G_COPPER_A:\r\ncase CARD_INFO_TYPE_1G_COPPER_B:\r\nqeth_set_ecmd_adv_sup(ecmd, SPEED_1000, PORT_TP);\r\necmd->port = PORT_TP;\r\nbreak;\r\ncase CARD_INFO_TYPE_1G_FIBRE_A:\r\ncase CARD_INFO_TYPE_1G_FIBRE_B:\r\nqeth_set_ecmd_adv_sup(ecmd, SPEED_1000, PORT_FIBRE);\r\necmd->port = PORT_FIBRE;\r\nbreak;\r\ncase CARD_INFO_TYPE_10G_FIBRE_A:\r\ncase CARD_INFO_TYPE_10G_FIBRE_B:\r\nqeth_set_ecmd_adv_sup(ecmd, SPEED_10000, PORT_FIBRE);\r\necmd->port = PORT_FIBRE;\r\nbreak;\r\n}\r\nswitch (carrier_info.port_mode) {\r\ncase CARD_INFO_PORTM_FULLDUPLEX:\r\necmd->duplex = DUPLEX_FULL;\r\nbreak;\r\ncase CARD_INFO_PORTM_HALFDUPLEX:\r\necmd->duplex = DUPLEX_HALF;\r\nbreak;\r\n}\r\nswitch (carrier_info.port_speed) {\r\ncase CARD_INFO_PORTS_10M:\r\nspeed = SPEED_10;\r\nbreak;\r\ncase CARD_INFO_PORTS_100M:\r\nspeed = SPEED_100;\r\nbreak;\r\ncase CARD_INFO_PORTS_1G:\r\nspeed = SPEED_1000;\r\nbreak;\r\ncase CARD_INFO_PORTS_10G:\r\nspeed = SPEED_10000;\r\nbreak;\r\n}\r\nethtool_cmd_speed_set(ecmd, speed);\r\nreturn 0;\r\n}\r\nstatic int __init qeth_core_init(void)\r\n{\r\nint rc;\r\npr_info("loading core functions\n");\r\nINIT_LIST_HEAD(&qeth_core_card_list.list);\r\nINIT_LIST_HEAD(&qeth_dbf_list);\r\nrwlock_init(&qeth_core_card_list.rwlock);\r\nmutex_init(&qeth_mod_mutex);\r\nqeth_wq = create_singlethread_workqueue("qeth_wq");\r\nrc = qeth_register_dbf_views();\r\nif (rc)\r\ngoto out_err;\r\nqeth_core_root_dev = root_device_register("qeth");\r\nrc = PTR_ERR_OR_ZERO(qeth_core_root_dev);\r\nif (rc)\r\ngoto register_err;\r\nqeth_core_header_cache = kmem_cache_create("qeth_hdr",\r\nsizeof(struct qeth_hdr) + ETH_HLEN, 64, 0, NULL);\r\nif (!qeth_core_header_cache) {\r\nrc = -ENOMEM;\r\ngoto slab_err;\r\n}\r\nqeth_qdio_outbuf_cache = kmem_cache_create("qeth_buf",\r\nsizeof(struct qeth_qdio_out_buffer), 0, 0, NULL);\r\nif (!qeth_qdio_outbuf_cache) {\r\nrc = -ENOMEM;\r\ngoto cqslab_err;\r\n}\r\nrc = ccw_driver_register(&qeth_ccw_driver);\r\nif (rc)\r\ngoto ccw_err;\r\nqeth_core_ccwgroup_driver.driver.groups = qeth_drv_attr_groups;\r\nrc = ccwgroup_driver_register(&qeth_core_ccwgroup_driver);\r\nif (rc)\r\ngoto ccwgroup_err;\r\nreturn 0;\r\nccwgroup_err:\r\nccw_driver_unregister(&qeth_ccw_driver);\r\nccw_err:\r\nkmem_cache_destroy(qeth_qdio_outbuf_cache);\r\ncqslab_err:\r\nkmem_cache_destroy(qeth_core_header_cache);\r\nslab_err:\r\nroot_device_unregister(qeth_core_root_dev);\r\nregister_err:\r\nqeth_unregister_dbf_views();\r\nout_err:\r\npr_err("Initializing the qeth device driver failed\n");\r\nreturn rc;\r\n}\r\nstatic void __exit qeth_core_exit(void)\r\n{\r\nqeth_clear_dbf_list();\r\ndestroy_workqueue(qeth_wq);\r\nccwgroup_driver_unregister(&qeth_core_ccwgroup_driver);\r\nccw_driver_unregister(&qeth_ccw_driver);\r\nkmem_cache_destroy(qeth_qdio_outbuf_cache);\r\nkmem_cache_destroy(qeth_core_header_cache);\r\nroot_device_unregister(qeth_core_root_dev);\r\nqeth_unregister_dbf_views();\r\npr_info("core functions removed\n");\r\n}
