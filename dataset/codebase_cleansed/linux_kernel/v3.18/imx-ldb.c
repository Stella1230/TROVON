static enum drm_connector_status imx_ldb_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic int imx_ldb_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = con_to_imx_ldb_ch(connector);\r\nint num_modes = 0;\r\nif (imx_ldb_ch->edid) {\r\ndrm_mode_connector_update_edid_property(connector,\r\nimx_ldb_ch->edid);\r\nnum_modes = drm_add_edid_modes(connector, imx_ldb_ch->edid);\r\n}\r\nif (imx_ldb_ch->mode_valid) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_create(connector->dev);\r\nif (!mode)\r\nreturn -EINVAL;\r\ndrm_mode_copy(mode, &imx_ldb_ch->mode);\r\nmode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nnum_modes++;\r\n}\r\nreturn num_modes;\r\n}\r\nstatic struct drm_encoder *imx_ldb_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = con_to_imx_ldb_ch(connector);\r\nreturn &imx_ldb_ch->encoder;\r\n}\r\nstatic void imx_ldb_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\n}\r\nstatic bool imx_ldb_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void imx_ldb_set_clock(struct imx_ldb *ldb, int mux, int chno,\r\nunsigned long serial_clk, unsigned long di_clk)\r\n{\r\nint ret;\r\ndev_dbg(ldb->dev, "%s: now: %ld want: %ld\n", __func__,\r\nclk_get_rate(ldb->clk_pll[chno]), serial_clk);\r\nclk_set_rate(ldb->clk_pll[chno], serial_clk);\r\ndev_dbg(ldb->dev, "%s after: %ld\n", __func__,\r\nclk_get_rate(ldb->clk_pll[chno]));\r\ndev_dbg(ldb->dev, "%s: now: %ld want: %ld\n", __func__,\r\nclk_get_rate(ldb->clk[chno]),\r\n(long int)di_clk);\r\nclk_set_rate(ldb->clk[chno], di_clk);\r\ndev_dbg(ldb->dev, "%s after: %ld\n", __func__,\r\nclk_get_rate(ldb->clk[chno]));\r\nret = clk_set_parent(ldb->clk_sel[mux], ldb->clk[chno]);\r\nif (ret)\r\ndev_err(ldb->dev,\r\n"unable to set di%d parent clock to ldb_di%d\n", mux,\r\nchno);\r\n}\r\nstatic void imx_ldb_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nstruct drm_display_mode *mode = &encoder->crtc->mode;\r\nu32 pixel_fmt;\r\nunsigned long serial_clk;\r\nunsigned long di_clk = mode->clock * 1000;\r\nint mux = imx_drm_encoder_get_mux_id(imx_ldb_ch->child, encoder);\r\nif (ldb->ldb_ctrl & LDB_SPLIT_MODE_EN) {\r\nserial_clk = 3500UL * mode->clock;\r\nimx_ldb_set_clock(ldb, mux, 0, serial_clk, di_clk);\r\nimx_ldb_set_clock(ldb, mux, 1, serial_clk, di_clk);\r\n} else {\r\nserial_clk = 7000UL * mode->clock;\r\nimx_ldb_set_clock(ldb, mux, imx_ldb_ch->chno, serial_clk,\r\ndi_clk);\r\n}\r\nswitch (imx_ldb_ch->chno) {\r\ncase 0:\r\npixel_fmt = (ldb->ldb_ctrl & LDB_DATA_WIDTH_CH0_24) ?\r\nV4L2_PIX_FMT_RGB24 : V4L2_PIX_FMT_BGR666;\r\nbreak;\r\ncase 1:\r\npixel_fmt = (ldb->ldb_ctrl & LDB_DATA_WIDTH_CH1_24) ?\r\nV4L2_PIX_FMT_RGB24 : V4L2_PIX_FMT_BGR666;\r\nbreak;\r\ndefault:\r\ndev_err(ldb->dev, "unable to config di%d panel format\n",\r\nimx_ldb_ch->chno);\r\npixel_fmt = V4L2_PIX_FMT_RGB24;\r\n}\r\nimx_drm_panel_format(encoder, pixel_fmt);\r\n}\r\nstatic void imx_ldb_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\r\nint mux = imx_drm_encoder_get_mux_id(imx_ldb_ch->child, encoder);\r\nif (dual) {\r\nclk_prepare_enable(ldb->clk[0]);\r\nclk_prepare_enable(ldb->clk[1]);\r\n}\r\nif (imx_ldb_ch == &ldb->channel[0] || dual) {\r\nldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\r\nif (mux == 0 || ldb->lvds_mux)\r\nldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI0;\r\nelse if (mux == 1)\r\nldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI1;\r\n}\r\nif (imx_ldb_ch == &ldb->channel[1] || dual) {\r\nldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\r\nif (mux == 1 || ldb->lvds_mux)\r\nldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI1;\r\nelse if (mux == 0)\r\nldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI0;\r\n}\r\nif (ldb->lvds_mux) {\r\nconst struct bus_mux *lvds_mux = NULL;\r\nif (imx_ldb_ch == &ldb->channel[0])\r\nlvds_mux = &ldb->lvds_mux[0];\r\nelse if (imx_ldb_ch == &ldb->channel[1])\r\nlvds_mux = &ldb->lvds_mux[1];\r\nregmap_update_bits(ldb->regmap, lvds_mux->reg, lvds_mux->mask,\r\nmux << lvds_mux->shift);\r\n}\r\nregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\r\n}\r\nstatic void imx_ldb_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\r\nif (mode->clock > 170000) {\r\ndev_warn(ldb->dev,\r\n"%s: mode exceeds 170 MHz pixel clock\n", __func__);\r\n}\r\nif (mode->clock > 85000 && !dual) {\r\ndev_warn(ldb->dev,\r\n"%s: mode exceeds 85 MHz pixel clock\n", __func__);\r\n}\r\nif (imx_ldb_ch == &ldb->channel[0]) {\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nldb->ldb_ctrl |= LDB_DI0_VS_POL_ACT_LOW;\r\nelse if (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nldb->ldb_ctrl &= ~LDB_DI0_VS_POL_ACT_LOW;\r\n}\r\nif (imx_ldb_ch == &ldb->channel[1]) {\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nldb->ldb_ctrl |= LDB_DI1_VS_POL_ACT_LOW;\r\nelse if (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nldb->ldb_ctrl &= ~LDB_DI1_VS_POL_ACT_LOW;\r\n}\r\n}\r\nstatic void imx_ldb_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nif (imx_ldb_ch == &ldb->channel[0] &&\r\n(ldb->ldb_ctrl & LDB_CH0_MODE_EN_MASK) == 0)\r\nreturn;\r\nelse if (imx_ldb_ch == &ldb->channel[1] &&\r\n(ldb->ldb_ctrl & LDB_CH1_MODE_EN_MASK) == 0)\r\nreturn;\r\nif (imx_ldb_ch == &ldb->channel[0])\r\nldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\r\nelse if (imx_ldb_ch == &ldb->channel[1])\r\nldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\r\nregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\r\nif (ldb->ldb_ctrl & LDB_SPLIT_MODE_EN) {\r\nclk_disable_unprepare(ldb->clk[0]);\r\nclk_disable_unprepare(ldb->clk[1]);\r\n}\r\n}\r\nstatic int imx_ldb_get_clk(struct imx_ldb *ldb, int chno)\r\n{\r\nchar clkname[16];\r\nsnprintf(clkname, sizeof(clkname), "di%d", chno);\r\nldb->clk[chno] = devm_clk_get(ldb->dev, clkname);\r\nif (IS_ERR(ldb->clk[chno]))\r\nreturn PTR_ERR(ldb->clk[chno]);\r\nsnprintf(clkname, sizeof(clkname), "di%d_pll", chno);\r\nldb->clk_pll[chno] = devm_clk_get(ldb->dev, clkname);\r\nreturn PTR_ERR_OR_ZERO(ldb->clk_pll[chno]);\r\n}\r\nstatic int imx_ldb_register(struct drm_device *drm,\r\nstruct imx_ldb_channel *imx_ldb_ch)\r\n{\r\nstruct imx_ldb *ldb = imx_ldb_ch->ldb;\r\nint ret;\r\nret = imx_drm_encoder_parse_of(drm, &imx_ldb_ch->encoder,\r\nimx_ldb_ch->child);\r\nif (ret)\r\nreturn ret;\r\nret = imx_ldb_get_clk(ldb, imx_ldb_ch->chno);\r\nif (ret)\r\nreturn ret;\r\nif (ldb->ldb_ctrl & LDB_SPLIT_MODE_EN) {\r\nret = imx_ldb_get_clk(ldb, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndrm_encoder_helper_add(&imx_ldb_ch->encoder,\r\n&imx_ldb_encoder_helper_funcs);\r\ndrm_encoder_init(drm, &imx_ldb_ch->encoder, &imx_ldb_encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\ndrm_connector_helper_add(&imx_ldb_ch->connector,\r\n&imx_ldb_connector_helper_funcs);\r\ndrm_connector_init(drm, &imx_ldb_ch->connector,\r\n&imx_ldb_connector_funcs, DRM_MODE_CONNECTOR_LVDS);\r\ndrm_mode_connector_attach_encoder(&imx_ldb_ch->connector,\r\n&imx_ldb_ch->encoder);\r\nreturn 0;\r\n}\r\nstatic const int of_get_data_mapping(struct device_node *np)\r\n{\r\nconst char *bm;\r\nint ret, i;\r\nret = of_property_read_string(np, "fsl,data-mapping", &bm);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(imx_ldb_bit_mappings); i++)\r\nif (!strcasecmp(bm, imx_ldb_bit_mappings[i]))\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic int imx_ldb_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct drm_device *drm = data;\r\nstruct device_node *np = dev->of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_ldb_dt_ids, dev);\r\nstruct device_node *child;\r\nconst u8 *edidp;\r\nstruct imx_ldb *imx_ldb;\r\nint datawidth;\r\nint mapping;\r\nint dual;\r\nint ret;\r\nint i;\r\nimx_ldb = devm_kzalloc(dev, sizeof(*imx_ldb), GFP_KERNEL);\r\nif (!imx_ldb)\r\nreturn -ENOMEM;\r\nimx_ldb->regmap = syscon_regmap_lookup_by_phandle(np, "gpr");\r\nif (IS_ERR(imx_ldb->regmap)) {\r\ndev_err(dev, "failed to get parent regmap\n");\r\nreturn PTR_ERR(imx_ldb->regmap);\r\n}\r\nimx_ldb->dev = dev;\r\nif (of_id)\r\nimx_ldb->lvds_mux = of_id->data;\r\ndual = of_property_read_bool(np, "fsl,dual-channel");\r\nif (dual)\r\nimx_ldb->ldb_ctrl |= LDB_SPLIT_MODE_EN;\r\nfor (i = 0; i < 4; i++) {\r\nchar clkname[16];\r\nsprintf(clkname, "di%d_sel", i);\r\nimx_ldb->clk_sel[i] = devm_clk_get(imx_ldb->dev, clkname);\r\nif (IS_ERR(imx_ldb->clk_sel[i])) {\r\nret = PTR_ERR(imx_ldb->clk_sel[i]);\r\nimx_ldb->clk_sel[i] = NULL;\r\nbreak;\r\n}\r\n}\r\nif (i == 0)\r\nreturn ret;\r\nfor_each_child_of_node(np, child) {\r\nstruct imx_ldb_channel *channel;\r\nret = of_property_read_u32(child, "reg", &i);\r\nif (ret || i < 0 || i > 1)\r\nreturn -EINVAL;\r\nif (dual && i > 0) {\r\ndev_warn(dev, "dual-channel mode, ignoring second output\n");\r\ncontinue;\r\n}\r\nif (!of_device_is_available(child))\r\ncontinue;\r\nchannel = &imx_ldb->channel[i];\r\nchannel->ldb = imx_ldb;\r\nchannel->chno = i;\r\nchannel->child = child;\r\nedidp = of_get_property(child, "edid", &channel->edid_len);\r\nif (edidp) {\r\nchannel->edid = kmemdup(edidp, channel->edid_len,\r\nGFP_KERNEL);\r\n} else {\r\nret = of_get_drm_display_mode(child, &channel->mode, 0);\r\nif (!ret)\r\nchannel->mode_valid = 1;\r\n}\r\nret = of_property_read_u32(child, "fsl,data-width", &datawidth);\r\nif (ret)\r\ndatawidth = 0;\r\nelse if (datawidth != 18 && datawidth != 24)\r\nreturn -EINVAL;\r\nmapping = of_get_data_mapping(child);\r\nswitch (mapping) {\r\ncase LVDS_BIT_MAP_SPWG:\r\nif (datawidth == 24) {\r\nif (i == 0 || dual)\r\nimx_ldb->ldb_ctrl |=\r\nLDB_DATA_WIDTH_CH0_24;\r\nif (i == 1 || dual)\r\nimx_ldb->ldb_ctrl |=\r\nLDB_DATA_WIDTH_CH1_24;\r\n}\r\nbreak;\r\ncase LVDS_BIT_MAP_JEIDA:\r\nif (datawidth == 18) {\r\ndev_err(dev, "JEIDA standard only supported in 24 bit\n");\r\nreturn -EINVAL;\r\n}\r\nif (i == 0 || dual)\r\nimx_ldb->ldb_ctrl |= LDB_DATA_WIDTH_CH0_24 |\r\nLDB_BIT_MAP_CH0_JEIDA;\r\nif (i == 1 || dual)\r\nimx_ldb->ldb_ctrl |= LDB_DATA_WIDTH_CH1_24 |\r\nLDB_BIT_MAP_CH1_JEIDA;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "data mapping not specified or invalid\n");\r\nreturn -EINVAL;\r\n}\r\nret = imx_ldb_register(drm, channel);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, imx_ldb);\r\nreturn 0;\r\n}\r\nstatic void imx_ldb_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct imx_ldb *imx_ldb = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct imx_ldb_channel *channel = &imx_ldb->channel[i];\r\nif (!channel->connector.funcs)\r\ncontinue;\r\nchannel->connector.funcs->destroy(&channel->connector);\r\nchannel->encoder.funcs->destroy(&channel->encoder);\r\n}\r\n}\r\nstatic int imx_ldb_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &imx_ldb_ops);\r\n}\r\nstatic int imx_ldb_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &imx_ldb_ops);\r\nreturn 0;\r\n}
