static unsigned short wm_get(struct snd_ice1712 *ice, int reg)\r\n{\r\nreg <<= 1;\r\nreturn ((unsigned short)ice->akm[0].images[reg] << 8) |\r\nice->akm[0].images[reg + 1];\r\n}\r\nstatic void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)\r\n{\r\nunsigned short cval;\r\ncval = (reg << 9) | val;\r\nsnd_vt1724_write_i2c(ice, WM_DEV, cval >> 8, cval & 0xff);\r\n}\r\nstatic void wm_put(struct snd_ice1712 *ice, int reg, unsigned short val)\r\n{\r\nwm_put_nocache(ice, reg, val);\r\nreg <<= 1;\r\nice->akm[0].images[reg] = val >> 8;\r\nice->akm[0].images[reg + 1] = val;\r\n}\r\nstatic void set_gpio_bit(struct snd_ice1712 *ice, unsigned int bit, int val)\r\n{\r\nunsigned int tmp = snd_ice1712_gpio_read(ice);\r\nif (val)\r\ntmp |= bit;\r\nelse\r\ntmp &= ~bit;\r\nsnd_ice1712_gpio_write(ice, tmp);\r\n}\r\nstatic void wm8766_spi_send_word(struct snd_ice1712 *ice, unsigned int data)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nset_gpio_bit(ice, WM8766_SPI_CLK, 0);\r\nudelay(1);\r\nset_gpio_bit(ice, WM8766_SPI_MD, data & 0x8000);\r\nudelay(1);\r\nset_gpio_bit(ice, WM8766_SPI_CLK, 1);\r\nudelay(1);\r\ndata <<= 1;\r\n}\r\n}\r\nstatic void wm8766_spi_write(struct snd_ice1712 *ice, unsigned int reg,\r\nunsigned int data)\r\n{\r\nunsigned int block;\r\nsnd_ice1712_gpio_set_dir(ice, WM8766_SPI_MD|\r\nWM8766_SPI_CLK|WM8766_SPI_ML);\r\nsnd_ice1712_gpio_set_mask(ice, ~(WM8766_SPI_MD|\r\nWM8766_SPI_CLK|WM8766_SPI_ML));\r\nset_gpio_bit(ice, WM8766_SPI_ML, 0);\r\nblock = (reg << 9) | (data & 0x1ff);\r\nwm8766_spi_send_word(ice, block);\r\nset_gpio_bit(ice, WM8766_SPI_ML, 1);\r\nudelay(1);\r\nsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask);\r\nsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction);\r\n}\r\nstatic void ak4396_send_word(struct snd_ice1712 *ice, unsigned int data)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nset_gpio_bit(ice, AK4396_CCLK, 0);\r\nudelay(1);\r\nset_gpio_bit(ice, AK4396_CDTI, data & 0x8000);\r\nudelay(1);\r\nset_gpio_bit(ice, AK4396_CCLK, 1);\r\nudelay(1);\r\ndata <<= 1;\r\n}\r\n}\r\nstatic void ak4396_write(struct snd_ice1712 *ice, unsigned int reg,\r\nunsigned int data)\r\n{\r\nunsigned int block;\r\nsnd_ice1712_gpio_set_dir(ice, AK4396_CSN|AK4396_CCLK|AK4396_CDTI);\r\nsnd_ice1712_gpio_set_mask(ice, ~(AK4396_CSN|AK4396_CCLK|AK4396_CDTI));\r\nset_gpio_bit(ice, AK4396_CSN, 0);\r\nblock = ((AK4396_ADDR & 0x03) << 14) | (1 << 13) |\r\n((reg & 0x1f) << 8) | (data & 0xff);\r\nak4396_send_word(ice, block);\r\nset_gpio_bit(ice, AK4396_CSN, 1);\r\nudelay(1);\r\nsnd_ice1712_gpio_set_mask(ice, ice->gpio.write_mask);\r\nsnd_ice1712_gpio_set_dir(ice, ice->gpio.direction);\r\n}\r\nstatic int ak4396_dac_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xFF;\r\nreturn 0;\r\n}\r\nstatic int ak4396_dac_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nucontrol->value.integer.value[i] = spec->vol[i];\r\nreturn 0;\r\n}\r\nstatic int ak4396_dac_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint i;\r\nint change = 0;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nif (ucontrol->value.integer.value[i] != spec->vol[i]) {\r\nspec->vol[i] = ucontrol->value.integer.value[i];\r\nak4396_write(ice, AK4396_LCH_ATT + i,\r\nspec->vol[i] & 0xff);\r\nchange = 1;\r\n}\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn change;\r\n}\r\nstatic void wm_set_vol(struct snd_ice1712 *ice, unsigned int index,\r\nunsigned short vol, unsigned short master)\r\n{\r\nunsigned char nvol;\r\nif ((master & WM_VOL_MUTE) || (vol & WM_VOL_MUTE))\r\nnvol = 0;\r\nelse {\r\nnvol = (((vol & ~WM_VOL_MUTE) * (master & ~WM_VOL_MUTE)) / 128)\r\n& WM_VOL_MAX;\r\nnvol = (nvol ? (nvol + DAC_MIN) : 0) & 0xff;\r\n}\r\nwm_put(ice, index, nvol);\r\nwm_put_nocache(ice, index, 0x100 | nvol);\r\n}\r\nstatic void wm8766_set_vol(struct snd_ice1712 *ice, unsigned int index,\r\nunsigned short vol, unsigned short master)\r\n{\r\nunsigned char nvol;\r\nif ((master & WM_VOL_MUTE) || (vol & WM_VOL_MUTE))\r\nnvol = 0;\r\nelse {\r\nnvol = (((vol & ~WM_VOL_MUTE) * (master & ~WM_VOL_MUTE)) / 128)\r\n& WM_VOL_MAX;\r\nnvol = (nvol ? (nvol + DAC_MIN) : 0) & 0xff;\r\n}\r\nwm8766_spi_write(ice, index, (0x0100 | nvol));\r\n}\r\nstatic int wm_dac_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = DAC_RES;\r\nreturn 0;\r\n}\r\nstatic int wm_dac_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nucontrol->value.integer.value[i] =\r\nspec->vol[2 + i] & ~WM_VOL_MUTE;\r\nreturn 0;\r\n}\r\nstatic int wm_dac_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint i, idx, change = 0;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nif (ucontrol->value.integer.value[i] != spec->vol[2 + i]) {\r\nidx = WM_DAC_ATTEN_L + i;\r\nspec->vol[2 + i] &= WM_VOL_MUTE;\r\nspec->vol[2 + i] |= ucontrol->value.integer.value[i];\r\nwm_set_vol(ice, idx, spec->vol[2 + i], spec->master[i]);\r\nchange = 1;\r\n}\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn change;\r\n}\r\nstatic int wm8766_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint voices = kcontrol->private_value >> 8;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = voices;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = DAC_RES;\r\nreturn 0;\r\n}\r\nstatic int wm8766_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint i, ofs, voices;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xff;\r\nfor (i = 0; i < voices; i++)\r\nucontrol->value.integer.value[i] = spec->vol[ofs + i];\r\nreturn 0;\r\n}\r\nstatic int wm8766_vol_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint i, idx, ofs, voices;\r\nint change = 0;\r\nvoices = kcontrol->private_value >> 8;\r\nofs = kcontrol->private_value & 0xff;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (i = 0; i < voices; i++) {\r\nif (ucontrol->value.integer.value[i] != spec->vol[ofs + i]) {\r\nidx = WM8766_LDA1 + ofs + i;\r\nspec->vol[ofs + i] &= WM_VOL_MUTE;\r\nspec->vol[ofs + i] |= ucontrol->value.integer.value[i];\r\nwm8766_set_vol(ice, idx,\r\nspec->vol[ofs + i], spec->master[i]);\r\nchange = 1;\r\n}\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn change;\r\n}\r\nstatic int wm_master_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = DAC_RES;\r\nreturn 0;\r\n}\r\nstatic int wm_master_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nucontrol->value.integer.value[i] = spec->master[i];\r\nreturn 0;\r\n}\r\nstatic int wm_master_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint ch, change = 0;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (ch = 0; ch < 2; ch++) {\r\nif (ucontrol->value.integer.value[ch] != spec->master[ch]) {\r\nspec->master[ch] = ucontrol->value.integer.value[ch];\r\nwm_set_vol(ice, WM_DAC_ATTEN_L + ch,\r\nspec->vol[2 + ch], spec->master[ch]);\r\nwm8766_set_vol(ice, WM8766_LDA1 + ch,\r\nspec->vol[0 + ch], spec->master[ch]);\r\nwm8766_set_vol(ice, WM8766_LDA2 + ch,\r\nspec->vol[4 + ch], spec->master[ch]);\r\nwm8766_set_vol(ice, WM8766_LDA3 + ch,\r\nspec->vol[6 + ch], spec->master[ch]);\r\nchange = 1;\r\n}\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn change;\r\n}\r\nstatic int wm_adc_mux_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char* texts[32] = {\r\n"NULL", WM_AIN1, WM_AIN2, WM_AIN1 "+" WM_AIN2,\r\nWM_AIN3, WM_AIN1 "+" WM_AIN3, WM_AIN2 "+" WM_AIN3,\r\nWM_AIN1 "+" WM_AIN2 "+" WM_AIN3,\r\nWM_AIN4, WM_AIN1 "+" WM_AIN4, WM_AIN2 "+" WM_AIN4,\r\nWM_AIN1 "+" WM_AIN2 "+" WM_AIN4,\r\nWM_AIN3 "+" WM_AIN4, WM_AIN1 "+" WM_AIN3 "+" WM_AIN4,\r\nWM_AIN2 "+" WM_AIN3 "+" WM_AIN4,\r\nWM_AIN1 "+" WM_AIN2 "+" WM_AIN3 "+" WM_AIN4,\r\nWM_AIN5, WM_AIN1 "+" WM_AIN5, WM_AIN2 "+" WM_AIN5,\r\nWM_AIN1 "+" WM_AIN2 "+" WM_AIN5,\r\nWM_AIN3 "+" WM_AIN5, WM_AIN1 "+" WM_AIN3 "+" WM_AIN5,\r\nWM_AIN2 "+" WM_AIN3 "+" WM_AIN5,\r\nWM_AIN1 "+" WM_AIN2 "+" WM_AIN3 "+" WM_AIN5,\r\nWM_AIN4 "+" WM_AIN5, WM_AIN1 "+" WM_AIN4 "+" WM_AIN5,\r\nWM_AIN2 "+" WM_AIN4 "+" WM_AIN5,\r\nWM_AIN1 "+" WM_AIN2 "+" WM_AIN4 "+" WM_AIN5,\r\nWM_AIN3 "+" WM_AIN4 "+" WM_AIN5,\r\nWM_AIN1 "+" WM_AIN3 "+" WM_AIN4 "+" WM_AIN5,\r\nWM_AIN2 "+" WM_AIN3 "+" WM_AIN4 "+" WM_AIN5,\r\nWM_AIN1 "+" WM_AIN2 "+" WM_AIN3 "+" WM_AIN4 "+" WM_AIN5\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 32;\r\nif (uinfo->value.enumerated.item > 31)\r\nuinfo->value.enumerated.item = 31;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int wm_adc_mux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] = wm_get(ice, WM_ADC_MUX) & 0x1f;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_adc_mux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short oval, nval;\r\nint change = 0;\r\nmutex_lock(&ice->gpio_mutex);\r\noval = wm_get(ice, WM_ADC_MUX);\r\nnval = (oval & 0xe0) | ucontrol->value.integer.value[0];\r\nif (nval != oval) {\r\nwm_put(ice, WM_ADC_MUX, nval);\r\nchange = 1;\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn change;\r\n}\r\nstatic int wm_adc_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = ADC_RES;\r\nreturn 0;\r\n}\r\nstatic int wm_adc_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short val;\r\nint i;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nval = wm_get(ice, WM_ADC_ATTEN_L + i) & 0xff;\r\nval = val > ADC_MIN ? (val - ADC_MIN) : 0;\r\nucontrol->value.integer.value[i] = val;\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_adc_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short ovol, nvol;\r\nint i, idx, change = 0;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nnvol = ucontrol->value.integer.value[i];\r\nnvol = nvol ? (nvol + ADC_MIN) : 0;\r\nidx = WM_ADC_ATTEN_L + i;\r\novol = wm_get(ice, idx) & 0xff;\r\nif (ovol != nvol) {\r\nwm_put(ice, idx, nvol);\r\nchange = 1;\r\n}\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn change;\r\n}\r\nstatic int wm_adc_mux_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint bit = kcontrol->private_value;\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] =\r\n(wm_get(ice, WM_ADC_MUX) & (1 << bit)) ? 1 : 0;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_adc_mux_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nint bit = kcontrol->private_value;\r\nunsigned short oval, nval;\r\nint change;\r\nmutex_lock(&ice->gpio_mutex);\r\nnval = oval = wm_get(ice, WM_ADC_MUX);\r\nif (ucontrol->value.integer.value[0])\r\nnval |= (1 << bit);\r\nelse\r\nnval &= ~(1 << bit);\r\nchange = nval != oval;\r\nif (change) {\r\nwm_put(ice, WM_ADC_MUX, nval);\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_bypass_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] =\r\n(wm_get(ice, WM_OUT_MUX) & 0x04) ? 1 : 0;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_bypass_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short val, oval;\r\nint change = 0;\r\nmutex_lock(&ice->gpio_mutex);\r\nval = oval = wm_get(ice, WM_OUT_MUX);\r\nif (ucontrol->value.integer.value[0])\r\nval |= 0x04;\r\nelse\r\nval &= ~0x04;\r\nif (val != oval) {\r\nwm_put(ice, WM_OUT_MUX, val);\r\nchange = 1;\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn change;\r\n}\r\nstatic int wm_chswap_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&ice->gpio_mutex);\r\nucontrol->value.integer.value[0] =\r\n(wm_get(ice, WM_DAC_CTRL1) & 0xf0) != 0x90;\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int wm_chswap_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ice1712 *ice = snd_kcontrol_chip(kcontrol);\r\nunsigned short val, oval;\r\nint change = 0;\r\nmutex_lock(&ice->gpio_mutex);\r\noval = wm_get(ice, WM_DAC_CTRL1);\r\nval = oval & 0x0f;\r\nif (ucontrol->value.integer.value[0])\r\nval |= 0x60;\r\nelse\r\nval |= 0x90;\r\nif (val != oval) {\r\nwm_put(ice, WM_DAC_CTRL1, val);\r\nwm_put_nocache(ice, WM_DAC_CTRL1, val);\r\nchange = 1;\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn change;\r\n}\r\nstatic void wm_proc_regs_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_ice1712 *ice = entry->private_data;\r\nchar line[64];\r\nunsigned int reg, val;\r\nmutex_lock(&ice->gpio_mutex);\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nif (sscanf(line, "%x %x", &reg, &val) != 2)\r\ncontinue;\r\nif (reg <= 0x17 && val <= 0xffff)\r\nwm_put(ice, reg, val);\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\n}\r\nstatic void wm_proc_regs_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_ice1712 *ice = entry->private_data;\r\nint reg, val;\r\nmutex_lock(&ice->gpio_mutex);\r\nfor (reg = 0; reg <= 0x17; reg++) {\r\nval = wm_get(ice, reg);\r\nsnd_iprintf(buffer, "%02x = %04x\n", reg, val);\r\n}\r\nmutex_unlock(&ice->gpio_mutex);\r\n}\r\nstatic void wm_proc_init(struct snd_ice1712 *ice)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(ice->card, "wm_codec", &entry)) {\r\nsnd_info_set_text_ops(entry, ice, wm_proc_regs_read);\r\nentry->mode |= S_IWUSR;\r\nentry->c.text.write = wm_proc_regs_write;\r\n}\r\n}\r\nstatic int prodigy_hifi_add_controls(struct snd_ice1712 *ice)\r\n{\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < ARRAY_SIZE(prodigy_hifi_controls); i++) {\r\nerr = snd_ctl_add(ice->card,\r\nsnd_ctl_new1(&prodigy_hifi_controls[i], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nwm_proc_init(ice);\r\nreturn 0;\r\n}\r\nstatic int prodigy_hd2_add_controls(struct snd_ice1712 *ice)\r\n{\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < ARRAY_SIZE(prodigy_hd2_controls); i++) {\r\nerr = snd_ctl_add(ice->card,\r\nsnd_ctl_new1(&prodigy_hd2_controls[i], ice));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nwm_proc_init(ice);\r\nreturn 0;\r\n}\r\nstatic int prodigy_hifi_init(struct snd_ice1712 *ice)\r\n{\r\nstatic unsigned short wm_inits[] = {\r\nWM_ADC_MUX, 0x0003,\r\nWM_DAC_MUTE, 0x0001,\r\nWM_DAC_CTRL1, 0x0000,\r\nWM_POWERDOWN, 0x0008,\r\nWM_RESET, 0x0000,\r\n};\r\nstatic unsigned short wm_inits2[] = {\r\nWM_MASTER_CTRL, 0x0022,\r\nWM_DAC_INT, 0x0022,\r\nWM_ADC_INT, 0x0022,\r\nWM_DAC_CTRL1, 0x0090,\r\nWM_OUT_MUX, 0x0001,\r\nWM_HP_ATTEN_L, 0x0179,\r\nWM_HP_ATTEN_R, 0x0179,\r\nWM_DAC_ATTEN_L, 0x0000,\r\nWM_DAC_ATTEN_L, 0x0100,\r\nWM_DAC_ATTEN_R, 0x0000,\r\nWM_DAC_ATTEN_R, 0x0100,\r\nWM_PHASE_SWAP, 0x0000,\r\n#if 0\r\nWM_DAC_MASTER, 0x0100,\r\n#endif\r\nWM_DAC_CTRL2, 0x0000,\r\nWM_ADC_ATTEN_L, 0x0000,\r\nWM_ADC_ATTEN_R, 0x0000,\r\n#if 1\r\nWM_ALC_CTRL1, 0x007b,\r\nWM_ALC_CTRL2, 0x0000,\r\nWM_ALC_CTRL3, 0x0000,\r\nWM_NOISE_GATE, 0x0000,\r\n#endif\r\nWM_DAC_MUTE, 0x0000,\r\nWM_ADC_MUX, 0x0003,\r\n};\r\nstatic unsigned short wm8766_inits[] = {\r\nWM8766_RESET, 0x0000,\r\nWM8766_DAC_CTRL, 0x0120,\r\nWM8766_INT_CTRL, 0x0022,\r\nWM8766_DAC_CTRL2, 0x0001,\r\nWM8766_DAC_CTRL3, 0x0080,\r\nWM8766_LDA1, 0x0100,\r\nWM8766_LDA2, 0x0100,\r\nWM8766_LDA3, 0x0100,\r\nWM8766_RDA1, 0x0100,\r\nWM8766_RDA2, 0x0100,\r\nWM8766_RDA3, 0x0100,\r\nWM8766_MUTE1, 0x0000,\r\nWM8766_MUTE2, 0x0000,\r\n};\r\nstruct prodigy_hifi_spec *spec;\r\nunsigned int i;\r\nice->vt1720 = 0;\r\nice->vt1724 = 1;\r\nice->num_total_dacs = 8;\r\nice->num_total_adcs = 1;\r\nice->gpio.saved[0] = 0;\r\nice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\r\nif (! ice->akm)\r\nreturn -ENOMEM;\r\nice->akm_codecs = 1;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nice->spec = spec;\r\nfor (i = 0; i < ARRAY_SIZE(wm_inits); i += 2)\r\nwm_put(ice, wm_inits[i], wm_inits[i+1]);\r\nschedule_timeout_uninterruptible(1);\r\nfor (i = 0; i < ARRAY_SIZE(wm_inits2); i += 2)\r\nwm_put(ice, wm_inits2[i], wm_inits2[i+1]);\r\nfor (i = 0; i < ARRAY_SIZE(wm8766_inits); i += 2)\r\nwm8766_spi_write(ice, wm8766_inits[i], wm8766_inits[i+1]);\r\nreturn 0;\r\n}\r\nstatic void ak4396_init(struct snd_ice1712 *ice)\r\n{\r\nstatic unsigned short ak4396_inits[] = {\r\nAK4396_CTRL1, 0x87,\r\nAK4396_CTRL2, 0x02,\r\nAK4396_CTRL3, 0x00,\r\nAK4396_LCH_ATT, 0x00,\r\nAK4396_RCH_ATT, 0x00,\r\n};\r\nunsigned int i;\r\nak4396_write(ice, AK4396_CTRL1, 0x86);\r\nmsleep(100);\r\nak4396_write(ice, AK4396_CTRL1, 0x87);\r\nfor (i = 0; i < ARRAY_SIZE(ak4396_inits); i += 2)\r\nak4396_write(ice, ak4396_inits[i], ak4396_inits[i+1]);\r\n}\r\nstatic int prodigy_hd2_resume(struct snd_ice1712 *ice)\r\n{\r\nstruct prodigy_hifi_spec *spec = ice->spec;\r\nint i;\r\nmutex_lock(&ice->gpio_mutex);\r\nak4396_init(ice);\r\nfor (i = 0; i < 2; i++)\r\nak4396_write(ice, AK4396_LCH_ATT + i, spec->vol[i] & 0xff);\r\nmutex_unlock(&ice->gpio_mutex);\r\nreturn 0;\r\n}\r\nstatic int prodigy_hd2_init(struct snd_ice1712 *ice)\r\n{\r\nstruct prodigy_hifi_spec *spec;\r\nice->vt1720 = 0;\r\nice->vt1724 = 1;\r\nice->num_total_dacs = 1;\r\nice->num_total_adcs = 1;\r\nice->gpio.saved[0] = 0;\r\nice->akm = kzalloc(sizeof(struct snd_akm4xxx), GFP_KERNEL);\r\nif (! ice->akm)\r\nreturn -ENOMEM;\r\nice->akm_codecs = 1;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nice->spec = spec;\r\n#ifdef CONFIG_PM_SLEEP\r\nice->pm_resume = &prodigy_hd2_resume;\r\nice->pm_suspend_enabled = 1;\r\n#endif\r\nak4396_init(ice);\r\nreturn 0;\r\n}
