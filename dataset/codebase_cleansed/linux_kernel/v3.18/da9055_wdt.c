static int da9055_wdt_set_timeout(struct watchdog_device *wdt_dev,\r\nunsigned int timeout)\r\n{\r\nstruct da9055_wdt_data *driver_data = watchdog_get_drvdata(wdt_dev);\r\nstruct da9055 *da9055 = driver_data->da9055;\r\nint ret, i;\r\nfor (i = 0; i < ARRAY_SIZE(da9055_wdt_maps); i++)\r\nif (da9055_wdt_maps[i].user_time == timeout)\r\nbreak;\r\nif (i == ARRAY_SIZE(da9055_wdt_maps))\r\nret = -EINVAL;\r\nelse\r\nret = da9055_reg_update(da9055, DA9055_REG_CONTROL_B,\r\nDA9055_TWDSCALE_MASK,\r\nda9055_wdt_maps[i].reg_val <<\r\nDA9055_TWDSCALE_SHIFT);\r\nif (ret < 0) {\r\ndev_err(da9055->dev,\r\n"Failed to update timescale bit, %d\n", ret);\r\nreturn ret;\r\n}\r\nwdt_dev->timeout = timeout;\r\nreturn 0;\r\n}\r\nstatic int da9055_wdt_ping(struct watchdog_device *wdt_dev)\r\n{\r\nstruct da9055_wdt_data *driver_data = watchdog_get_drvdata(wdt_dev);\r\nstruct da9055 *da9055 = driver_data->da9055;\r\nmdelay(DA9055_TWDMIN);\r\nreturn da9055_reg_update(da9055, DA9055_REG_CONTROL_E,\r\nDA9055_WATCHDOG_MASK, 1);\r\n}\r\nstatic void da9055_wdt_release_resources(struct kref *r)\r\n{\r\n}\r\nstatic void da9055_wdt_ref(struct watchdog_device *wdt_dev)\r\n{\r\nstruct da9055_wdt_data *driver_data = watchdog_get_drvdata(wdt_dev);\r\nkref_get(&driver_data->kref);\r\n}\r\nstatic void da9055_wdt_unref(struct watchdog_device *wdt_dev)\r\n{\r\nstruct da9055_wdt_data *driver_data = watchdog_get_drvdata(wdt_dev);\r\nkref_put(&driver_data->kref, da9055_wdt_release_resources);\r\n}\r\nstatic int da9055_wdt_start(struct watchdog_device *wdt_dev)\r\n{\r\nreturn da9055_wdt_set_timeout(wdt_dev, wdt_dev->timeout);\r\n}\r\nstatic int da9055_wdt_stop(struct watchdog_device *wdt_dev)\r\n{\r\nreturn da9055_wdt_set_timeout(wdt_dev, 0);\r\n}\r\nstatic int da9055_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct da9055 *da9055 = dev_get_drvdata(pdev->dev.parent);\r\nstruct da9055_wdt_data *driver_data;\r\nstruct watchdog_device *da9055_wdt;\r\nint ret;\r\ndriver_data = devm_kzalloc(&pdev->dev, sizeof(*driver_data),\r\nGFP_KERNEL);\r\nif (!driver_data)\r\nreturn -ENOMEM;\r\ndriver_data->da9055 = da9055;\r\nda9055_wdt = &driver_data->wdt;\r\nda9055_wdt->timeout = DA9055_DEF_TIMEOUT;\r\nda9055_wdt->info = &da9055_wdt_info;\r\nda9055_wdt->ops = &da9055_wdt_ops;\r\nwatchdog_set_nowayout(da9055_wdt, nowayout);\r\nwatchdog_set_drvdata(da9055_wdt, driver_data);\r\nkref_init(&driver_data->kref);\r\nret = da9055_wdt_stop(da9055_wdt);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to stop watchdog, %d\n", ret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, driver_data);\r\nret = watchdog_register_device(&driver_data->wdt);\r\nif (ret != 0)\r\ndev_err(da9055->dev, "watchdog_register_device() failed: %d\n",\r\nret);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int da9055_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct da9055_wdt_data *driver_data = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&driver_data->wdt);\r\nkref_put(&driver_data->kref, da9055_wdt_release_resources);\r\nreturn 0;\r\n}
