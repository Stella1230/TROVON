static int rsi_sdio_master_access_msword(struct rsi_hw *adapter,\r\nu16 ms_word)\r\n{\r\nu8 byte;\r\nu8 function = 0;\r\nint status = 0;\r\nbyte = (u8)(ms_word & 0x00FF);\r\nrsi_dbg(INIT_ZONE,\r\n"%s: MASTER_ACCESS_MSBYTE:0x%x\n", __func__, byte);\r\nstatus = rsi_sdio_write_register(adapter,\r\nfunction,\r\nSDIO_MASTER_ACCESS_MSBYTE,\r\n&byte);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: fail to access MASTER_ACCESS_MSBYTE\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nbyte = (u8)(ms_word >> 8);\r\nrsi_dbg(INIT_ZONE, "%s:MASTER_ACCESS_LSBYTE:0x%x\n", __func__, byte);\r\nstatus = rsi_sdio_write_register(adapter,\r\nfunction,\r\nSDIO_MASTER_ACCESS_LSBYTE,\r\n&byte);\r\nreturn status;\r\n}\r\nstatic int rsi_copy_to_card(struct rsi_common *common,\r\nconst u8 *fw,\r\nu32 len,\r\nu32 num_blocks)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nu32 indx, ii;\r\nu32 block_size = dev->tx_blk_size;\r\nu32 lsb_address;\r\n__le32 data[] = { TA_HOLD_THREAD_VALUE, TA_SOFT_RST_CLR,\r\nTA_PC_ZERO, TA_RELEASE_THREAD_VALUE };\r\nu32 address[] = { TA_HOLD_THREAD_REG, TA_SOFT_RESET_REG,\r\nTA_TH0_PC_REG, TA_RELEASE_THREAD_REG };\r\nu32 base_address;\r\nu16 msb_address;\r\nbase_address = TA_LOAD_ADDRESS;\r\nmsb_address = base_address >> 16;\r\nfor (indx = 0, ii = 0; ii < num_blocks; ii++, indx += block_size) {\r\nlsb_address = ((u16) base_address | RSI_SD_REQUEST_MASTER);\r\nif (rsi_sdio_write_register_multiple(adapter,\r\nlsb_address,\r\n(u8 *)(fw + indx),\r\nblock_size)) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Unable to load %s blk\n", __func__,\r\nFIRMWARE_RSI9113);\r\nreturn -1;\r\n}\r\nrsi_dbg(INIT_ZONE, "%s: loading block: %d\n", __func__, ii);\r\nbase_address += block_size;\r\nif ((base_address >> 16) != msb_address) {\r\nmsb_address += 1;\r\nif (rsi_sdio_master_access_msword(adapter,\r\nmsb_address)) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Unable to set ms word reg\n",\r\n__func__);\r\nreturn -1;\r\n}\r\n}\r\n}\r\nif (len % block_size) {\r\nlsb_address = ((u16) base_address | RSI_SD_REQUEST_MASTER);\r\nif (rsi_sdio_write_register_multiple(adapter,\r\nlsb_address,\r\n(u8 *)(fw + indx),\r\nlen % block_size)) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Unable to load f/w\n", __func__);\r\nreturn -1;\r\n}\r\n}\r\nrsi_dbg(INIT_ZONE,\r\n"%s: Succesfully loaded TA instructions\n", __func__);\r\nif (rsi_sdio_master_access_msword(adapter, TA_BASE_ADDR)) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Unable to set ms word to common reg\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nfor (ii = 0; ii < ARRAY_SIZE(data); ii++) {\r\nif (rsi_sdio_write_register_multiple(adapter,\r\n(address[ii] |\r\nRSI_SD_REQUEST_MASTER),\r\n(u8 *)&data[ii],\r\n4)) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Unable to hold TA threads\n", __func__);\r\nreturn -1;\r\n}\r\n}\r\nrsi_dbg(INIT_ZONE, "%s: loaded firmware\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int rsi_load_ta_instructions(struct rsi_common *common)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nu32 len;\r\nu32 num_blocks;\r\nconst u8 *fw;\r\nconst struct firmware *fw_entry = NULL;\r\nu32 block_size = dev->tx_blk_size;\r\nint status = 0;\r\nu32 base_address;\r\nu16 msb_address;\r\nif (rsi_sdio_master_access_msword(adapter, TA_BASE_ADDR)) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Unable to set ms word to common reg\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nbase_address = TA_LOAD_ADDRESS;\r\nmsb_address = (base_address >> 16);\r\nif (rsi_sdio_master_access_msword(adapter, msb_address)) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Unable to set ms word reg\n", __func__);\r\nreturn -1;\r\n}\r\nstatus = request_firmware(&fw_entry, FIRMWARE_RSI9113, adapter->device);\r\nif (status < 0) {\r\nrsi_dbg(ERR_ZONE, "%s Firmware file %s not found\n",\r\n__func__, FIRMWARE_RSI9113);\r\nreturn status;\r\n}\r\nfw = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);\r\nlen = fw_entry->size;\r\nif (len % 4)\r\nlen += (4 - (len % 4));\r\nnum_blocks = (len / block_size);\r\nrsi_dbg(INIT_ZONE, "%s: Instruction size:%d\n", __func__, len);\r\nrsi_dbg(INIT_ZONE, "%s: num blocks: %d\n", __func__, num_blocks);\r\nstatus = rsi_copy_to_card(common, fw, len, num_blocks);\r\nrelease_firmware(fw_entry);\r\nreturn status;\r\n}\r\nstatic int rsi_process_pkt(struct rsi_common *common)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nu8 num_blks = 0;\r\nu32 rcv_pkt_len = 0;\r\nint status = 0;\r\nstatus = rsi_sdio_read_register(adapter,\r\nSDIO_RX_NUM_BLOCKS_REG,\r\n&num_blks);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to read pkt length from the card:\n",\r\n__func__);\r\nreturn status;\r\n}\r\nrcv_pkt_len = (num_blks * 256);\r\ncommon->rx_data_pkt = kmalloc(rcv_pkt_len, GFP_KERNEL);\r\nif (!common->rx_data_pkt) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in memory allocation\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nstatus = rsi_sdio_host_intf_read_pkt(adapter,\r\ncommon->rx_data_pkt,\r\nrcv_pkt_len);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed to read packet from card\n",\r\n__func__);\r\ngoto fail;\r\n}\r\nstatus = rsi_read_pkt(common, rcv_pkt_len);\r\nfail:\r\nkfree(common->rx_data_pkt);\r\nreturn status;\r\n}\r\nint rsi_init_sdio_slave_regs(struct rsi_hw *adapter)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nu8 function = 0;\r\nu8 byte;\r\nint status = 0;\r\nif (dev->next_read_delay) {\r\nbyte = dev->next_read_delay;\r\nstatus = rsi_sdio_write_register(adapter,\r\nfunction,\r\nSDIO_NXT_RD_DELAY2,\r\n&byte);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to write SDIO_NXT_RD_DELAY2\n",\r\n__func__);\r\nreturn -1;\r\n}\r\n}\r\nif (dev->sdio_high_speed_enable) {\r\nrsi_dbg(INIT_ZONE, "%s: Enabling SDIO High speed\n", __func__);\r\nbyte = 0x3;\r\nstatus = rsi_sdio_write_register(adapter,\r\nfunction,\r\nSDIO_REG_HIGH_SPEED,\r\n&byte);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to enable SDIO high speed\n",\r\n__func__);\r\nreturn -1;\r\n}\r\n}\r\nrsi_dbg(INIT_ZONE, "%s: Initialzing SDIO read start level\n", __func__);\r\nbyte = 0x24;\r\nstatus = rsi_sdio_write_register(adapter,\r\nfunction,\r\nSDIO_READ_START_LVL,\r\n&byte);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to write SDIO_READ_START_LVL\n", __func__);\r\nreturn -1;\r\n}\r\nrsi_dbg(INIT_ZONE, "%s: Initialzing FIFO ctrl registers\n", __func__);\r\nbyte = (128 - 32);\r\nstatus = rsi_sdio_write_register(adapter,\r\nfunction,\r\nSDIO_READ_FIFO_CTL,\r\n&byte);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to write SDIO_READ_FIFO_CTL\n", __func__);\r\nreturn -1;\r\n}\r\nbyte = 32;\r\nstatus = rsi_sdio_write_register(adapter,\r\nfunction,\r\nSDIO_WRITE_FIFO_CTL,\r\n&byte);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to write SDIO_WRITE_FIFO_CTL\n", __func__);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid rsi_interrupt_handler(struct rsi_hw *adapter)\r\n{\r\nstruct rsi_common *common = adapter->priv;\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nint status;\r\nenum sdio_interrupt_type isr_type;\r\nu8 isr_status = 0;\r\nu8 fw_status = 0;\r\ndev->rx_info.sdio_int_counter++;\r\ndo {\r\nmutex_lock(&common->tx_rxlock);\r\nstatus = rsi_sdio_read_register(common->priv,\r\nRSI_FN1_INT_REGISTER,\r\n&isr_status);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to Read Intr Status Register\n",\r\n__func__);\r\nmutex_unlock(&common->tx_rxlock);\r\nreturn;\r\n}\r\nif (isr_status == 0) {\r\nrsi_set_event(&common->tx_thread.event);\r\ndev->rx_info.sdio_intr_status_zero++;\r\nmutex_unlock(&common->tx_rxlock);\r\nreturn;\r\n}\r\nrsi_dbg(ISR_ZONE, "%s: Intr_status = %x %d %d\n",\r\n__func__, isr_status, (1 << MSDU_PKT_PENDING),\r\n(1 << FW_ASSERT_IND));\r\ndo {\r\nRSI_GET_SDIO_INTERRUPT_TYPE(isr_status, isr_type);\r\nswitch (isr_type) {\r\ncase BUFFER_AVAILABLE:\r\ndev->rx_info.watch_bufferfull_count = 0;\r\ndev->rx_info.buffer_full = false;\r\ndev->rx_info.semi_buffer_full = false;\r\ndev->rx_info.mgmt_buffer_full = false;\r\nrsi_sdio_ack_intr(common->priv,\r\n(1 << PKT_BUFF_AVAILABLE));\r\nrsi_set_event(&common->tx_thread.event);\r\nrsi_dbg(ISR_ZONE,\r\n"%s: ==> BUFFER_AVAILABLE <==\n",\r\n__func__);\r\ndev->rx_info.buf_available_counter++;\r\nbreak;\r\ncase FIRMWARE_ASSERT_IND:\r\nrsi_dbg(ERR_ZONE,\r\n"%s: ==> FIRMWARE Assert <==\n",\r\n__func__);\r\nstatus = rsi_sdio_read_register(common->priv,\r\nSDIO_FW_STATUS_REG,\r\n&fw_status);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to read f/w reg\n",\r\n__func__);\r\n} else {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Firmware Status is 0x%x\n",\r\n__func__ , fw_status);\r\nrsi_sdio_ack_intr(common->priv,\r\n(1 << FW_ASSERT_IND));\r\n}\r\ncommon->fsm_state = FSM_CARD_NOT_READY;\r\nbreak;\r\ncase MSDU_PACKET_PENDING:\r\nrsi_dbg(ISR_ZONE, "Pkt pending interrupt\n");\r\ndev->rx_info.total_sdio_msdu_pending_intr++;\r\nstatus = rsi_process_pkt(common);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to read pkt\n",\r\n__func__);\r\nmutex_unlock(&common->tx_rxlock);\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nrsi_sdio_ack_intr(common->priv, isr_status);\r\ndev->rx_info.total_sdio_unknown_intr++;\r\nisr_status = 0;\r\nrsi_dbg(ISR_ZONE,\r\n"Unknown Interrupt %x\n",\r\nisr_status);\r\nbreak;\r\n}\r\nisr_status ^= BIT(isr_type - 1);\r\n} while (isr_status);\r\nmutex_unlock(&common->tx_rxlock);\r\n} while (1);\r\n}\r\nint rsi_sdio_device_init(struct rsi_common *common)\r\n{\r\nif (rsi_load_ta_instructions(common))\r\nreturn -1;\r\nif (rsi_sdio_master_access_msword(common->priv, MISC_CFG_BASE_ADDR)) {\r\nrsi_dbg(ERR_ZONE, "%s: Unable to set ms word reg\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nrsi_dbg(INIT_ZONE,\r\n"%s: Setting ms word to 0x41050000\n", __func__);\r\nreturn 0;\r\n}\r\nint rsi_sdio_read_buffer_status_register(struct rsi_hw *adapter, u8 q_num)\r\n{\r\nstruct rsi_common *common = adapter->priv;\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nu8 buf_status = 0;\r\nint status = 0;\r\nstatus = rsi_sdio_read_register(common->priv,\r\nRSI_DEVICE_BUFFER_STATUS_REGISTER,\r\n&buf_status);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Failed to read status register\n", __func__);\r\nreturn -1;\r\n}\r\nif (buf_status & (BIT(PKT_MGMT_BUFF_FULL))) {\r\nif (!dev->rx_info.mgmt_buffer_full)\r\ndev->rx_info.mgmt_buf_full_counter++;\r\ndev->rx_info.mgmt_buffer_full = true;\r\n} else {\r\ndev->rx_info.mgmt_buffer_full = false;\r\n}\r\nif (buf_status & (BIT(PKT_BUFF_FULL))) {\r\nif (!dev->rx_info.buffer_full)\r\ndev->rx_info.buf_full_counter++;\r\ndev->rx_info.buffer_full = true;\r\n} else {\r\ndev->rx_info.buffer_full = false;\r\n}\r\nif (buf_status & (BIT(PKT_BUFF_SEMI_FULL))) {\r\nif (!dev->rx_info.semi_buffer_full)\r\ndev->rx_info.buf_semi_full_counter++;\r\ndev->rx_info.semi_buffer_full = true;\r\n} else {\r\ndev->rx_info.semi_buffer_full = false;\r\n}\r\nif ((q_num == MGMT_SOFT_Q) && (dev->rx_info.mgmt_buffer_full))\r\nreturn QUEUE_FULL;\r\nif (dev->rx_info.buffer_full)\r\nreturn QUEUE_FULL;\r\nreturn QUEUE_NOT_FULL;\r\n}\r\nint rsi_sdio_determine_event_timeout(struct rsi_hw *adapter)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nif (dev->rx_info.buffer_full)\r\nreturn 2;\r\nreturn EVENT_WAIT_FOREVER;\r\n}
