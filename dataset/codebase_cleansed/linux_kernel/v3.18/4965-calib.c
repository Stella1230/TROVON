static int\r\nil4965_sens_energy_cck(struct il_priv *il, u32 norm_fa, u32 rx_enable_time,\r\nstruct stats_general_data *rx_info)\r\n{\r\nu32 max_nrg_cck = 0;\r\nint i = 0;\r\nu8 max_silence_rssi = 0;\r\nu32 silence_ref = 0;\r\nu8 silence_rssi_a = 0;\r\nu8 silence_rssi_b = 0;\r\nu8 silence_rssi_c = 0;\r\nu32 val;\r\nu32 false_alarms = norm_fa * 200 * 1024;\r\nu32 max_false_alarms = MAX_FA_CCK * rx_enable_time;\r\nu32 min_false_alarms = MIN_FA_CCK * rx_enable_time;\r\nstruct il_sensitivity_data *data = NULL;\r\nconst struct il_sensitivity_ranges *ranges = il->hw_params.sens;\r\ndata = &(il->sensitivity_data);\r\ndata->nrg_auto_corr_silence_diff = 0;\r\nsilence_rssi_a =\r\n(u8) ((rx_info->beacon_silence_rssi_a & ALL_BAND_FILTER) >> 8);\r\nsilence_rssi_b =\r\n(u8) ((rx_info->beacon_silence_rssi_b & ALL_BAND_FILTER) >> 8);\r\nsilence_rssi_c =\r\n(u8) ((rx_info->beacon_silence_rssi_c & ALL_BAND_FILTER) >> 8);\r\nval = max(silence_rssi_b, silence_rssi_c);\r\nmax_silence_rssi = max(silence_rssi_a, (u8) val);\r\ndata->nrg_silence_rssi[data->nrg_silence_idx] = max_silence_rssi;\r\ndata->nrg_silence_idx++;\r\nif (data->nrg_silence_idx >= NRG_NUM_PREV_STAT_L)\r\ndata->nrg_silence_idx = 0;\r\nfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++) {\r\nval = data->nrg_silence_rssi[i];\r\nsilence_ref = max(silence_ref, val);\r\n}\r\nD_CALIB("silence a %u, b %u, c %u, 20-bcn max %u\n", silence_rssi_a,\r\nsilence_rssi_b, silence_rssi_c, silence_ref);\r\ni = data->nrg_energy_idx;\r\nval = min(rx_info->beacon_energy_b, rx_info->beacon_energy_c);\r\ndata->nrg_value[i] = min(rx_info->beacon_energy_a, val);\r\ndata->nrg_energy_idx++;\r\nif (data->nrg_energy_idx >= 10)\r\ndata->nrg_energy_idx = 0;\r\nmax_nrg_cck = data->nrg_value[0];\r\nfor (i = 1; i < 10; i++)\r\nmax_nrg_cck = (u32) max(max_nrg_cck, (data->nrg_value[i]));\r\nmax_nrg_cck += 6;\r\nD_CALIB("rx energy a %u, b %u, c %u, 10-bcn max/min %u\n",\r\nrx_info->beacon_energy_a, rx_info->beacon_energy_b,\r\nrx_info->beacon_energy_c, max_nrg_cck - 6);\r\nif (false_alarms < min_false_alarms)\r\ndata->num_in_cck_no_fa++;\r\nelse\r\ndata->num_in_cck_no_fa = 0;\r\nD_CALIB("consecutive bcns with few false alarms = %u\n",\r\ndata->num_in_cck_no_fa);\r\nif (false_alarms > max_false_alarms &&\r\ndata->auto_corr_cck > AUTO_CORR_MAX_TH_CCK) {\r\nD_CALIB("norm FA %u > max FA %u\n", false_alarms,\r\nmax_false_alarms);\r\nD_CALIB("... reducing sensitivity\n");\r\ndata->nrg_curr_state = IL_FA_TOO_MANY;\r\ndata->nrg_silence_ref = silence_ref;\r\ndata->nrg_th_cck = data->nrg_th_cck - NRG_STEP_CCK;\r\n} else if (false_alarms < min_false_alarms) {\r\ndata->nrg_curr_state = IL_FA_TOO_FEW;\r\ndata->nrg_auto_corr_silence_diff =\r\n(s32) data->nrg_silence_ref - (s32) silence_ref;\r\nD_CALIB("norm FA %u < min FA %u, silence diff %d\n",\r\nfalse_alarms, min_false_alarms,\r\ndata->nrg_auto_corr_silence_diff);\r\nif (data->nrg_prev_state != IL_FA_TOO_MANY &&\r\n(data->nrg_auto_corr_silence_diff > NRG_DIFF ||\r\ndata->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA)) {\r\nD_CALIB("... increasing sensitivity\n");\r\nval = data->nrg_th_cck + NRG_STEP_CCK;\r\ndata->nrg_th_cck = min((u32) ranges->min_nrg_cck, val);\r\n} else {\r\nD_CALIB("... but not changing sensitivity\n");\r\n}\r\n} else {\r\nD_CALIB(" FA in safe zone\n");\r\ndata->nrg_curr_state = IL_FA_GOOD_RANGE;\r\ndata->nrg_silence_ref = silence_ref;\r\nif (IL_FA_TOO_MANY == data->nrg_prev_state) {\r\nD_CALIB("... increasing margin\n");\r\nif (data->nrg_th_cck > (max_nrg_cck + NRG_MARGIN))\r\ndata->nrg_th_cck -= NRG_MARGIN;\r\nelse\r\ndata->nrg_th_cck = max_nrg_cck;\r\n}\r\n}\r\ndata->nrg_th_cck = max(max_nrg_cck, data->nrg_th_cck);\r\nD_CALIB("new nrg_th_cck %u\n", data->nrg_th_cck);\r\ndata->nrg_prev_state = data->nrg_curr_state;\r\nif (false_alarms > min_false_alarms) {\r\nif (data->auto_corr_cck < AUTO_CORR_MAX_TH_CCK)\r\ndata->auto_corr_cck = AUTO_CORR_MAX_TH_CCK + 1;\r\nelse {\r\nval = data->auto_corr_cck + AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck =\r\nmin((u32) ranges->auto_corr_max_cck, val);\r\n}\r\nval = data->auto_corr_cck_mrc + AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck_mrc =\r\nmin((u32) ranges->auto_corr_max_cck_mrc, val);\r\n} else if (false_alarms < min_false_alarms &&\r\n(data->nrg_auto_corr_silence_diff > NRG_DIFF ||\r\ndata->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA)) {\r\nval = data->auto_corr_cck - AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck = max((u32) ranges->auto_corr_min_cck, val);\r\nval = data->auto_corr_cck_mrc - AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck_mrc =\r\nmax((u32) ranges->auto_corr_min_cck_mrc, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_sens_auto_corr_ofdm(struct il_priv *il, u32 norm_fa, u32 rx_enable_time)\r\n{\r\nu32 val;\r\nu32 false_alarms = norm_fa * 200 * 1024;\r\nu32 max_false_alarms = MAX_FA_OFDM * rx_enable_time;\r\nu32 min_false_alarms = MIN_FA_OFDM * rx_enable_time;\r\nstruct il_sensitivity_data *data = NULL;\r\nconst struct il_sensitivity_ranges *ranges = il->hw_params.sens;\r\ndata = &(il->sensitivity_data);\r\nif (false_alarms > max_false_alarms) {\r\nD_CALIB("norm FA %u > max FA %u)\n", false_alarms,\r\nmax_false_alarms);\r\nval = data->auto_corr_ofdm + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm =\r\nmin((u32) ranges->auto_corr_max_ofdm, val);\r\nval = data->auto_corr_ofdm_mrc + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc =\r\nmin((u32) ranges->auto_corr_max_ofdm_mrc, val);\r\nval = data->auto_corr_ofdm_x1 + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_x1 =\r\nmin((u32) ranges->auto_corr_max_ofdm_x1, val);\r\nval = data->auto_corr_ofdm_mrc_x1 + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc_x1 =\r\nmin((u32) ranges->auto_corr_max_ofdm_mrc_x1, val);\r\n}\r\nelse if (false_alarms < min_false_alarms) {\r\nD_CALIB("norm FA %u < min FA %u\n", false_alarms,\r\nmin_false_alarms);\r\nval = data->auto_corr_ofdm - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm =\r\nmax((u32) ranges->auto_corr_min_ofdm, val);\r\nval = data->auto_corr_ofdm_mrc - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc =\r\nmax((u32) ranges->auto_corr_min_ofdm_mrc, val);\r\nval = data->auto_corr_ofdm_x1 - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_x1 =\r\nmax((u32) ranges->auto_corr_min_ofdm_x1, val);\r\nval = data->auto_corr_ofdm_mrc_x1 - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc_x1 =\r\nmax((u32) ranges->auto_corr_min_ofdm_mrc_x1, val);\r\n} else {\r\nD_CALIB("min FA %u < norm FA %u < max FA %u OK\n",\r\nmin_false_alarms, false_alarms, max_false_alarms);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_prepare_legacy_sensitivity_tbl(struct il_priv *il,\r\nstruct il_sensitivity_data *data,\r\n__le16 *tbl)\r\n{\r\ntbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_IDX] =\r\ncpu_to_le16((u16) data->auto_corr_ofdm);\r\ntbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_MRC_IDX] =\r\ncpu_to_le16((u16) data->auto_corr_ofdm_mrc);\r\ntbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_IDX] =\r\ncpu_to_le16((u16) data->auto_corr_ofdm_x1);\r\ntbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_MRC_IDX] =\r\ncpu_to_le16((u16) data->auto_corr_ofdm_mrc_x1);\r\ntbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_IDX] =\r\ncpu_to_le16((u16) data->auto_corr_cck);\r\ntbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_IDX] =\r\ncpu_to_le16((u16) data->auto_corr_cck_mrc);\r\ntbl[HD_MIN_ENERGY_CCK_DET_IDX] = cpu_to_le16((u16) data->nrg_th_cck);\r\ntbl[HD_MIN_ENERGY_OFDM_DET_IDX] = cpu_to_le16((u16) data->nrg_th_ofdm);\r\ntbl[HD_BARKER_CORR_TH_ADD_MIN_IDX] =\r\ncpu_to_le16(data->barker_corr_th_min);\r\ntbl[HD_BARKER_CORR_TH_ADD_MIN_MRC_IDX] =\r\ncpu_to_le16(data->barker_corr_th_min_mrc);\r\ntbl[HD_OFDM_ENERGY_TH_IN_IDX] = cpu_to_le16(data->nrg_th_cca);\r\nD_CALIB("ofdm: ac %u mrc %u x1 %u mrc_x1 %u thresh %u\n",\r\ndata->auto_corr_ofdm, data->auto_corr_ofdm_mrc,\r\ndata->auto_corr_ofdm_x1, data->auto_corr_ofdm_mrc_x1,\r\ndata->nrg_th_ofdm);\r\nD_CALIB("cck: ac %u mrc %u thresh %u\n", data->auto_corr_cck,\r\ndata->auto_corr_cck_mrc, data->nrg_th_cck);\r\n}\r\nstatic int\r\nil4965_sensitivity_write(struct il_priv *il)\r\n{\r\nstruct il_sensitivity_cmd cmd;\r\nstruct il_sensitivity_data *data = NULL;\r\nstruct il_host_cmd cmd_out = {\r\n.id = C_SENSITIVITY,\r\n.len = sizeof(struct il_sensitivity_cmd),\r\n.flags = CMD_ASYNC,\r\n.data = &cmd,\r\n};\r\ndata = &(il->sensitivity_data);\r\nmemset(&cmd, 0, sizeof(cmd));\r\nil4965_prepare_legacy_sensitivity_tbl(il, data, &cmd.table[0]);\r\ncmd.control = C_SENSITIVITY_CONTROL_WORK_TBL;\r\nif (!memcmp\r\n(&cmd.table[0], &(il->sensitivity_tbl[0]),\r\nsizeof(u16) * HD_TBL_SIZE)) {\r\nD_CALIB("No change in C_SENSITIVITY\n");\r\nreturn 0;\r\n}\r\nmemcpy(&(il->sensitivity_tbl[0]), &(cmd.table[0]),\r\nsizeof(u16) * HD_TBL_SIZE);\r\nreturn il_send_cmd(il, &cmd_out);\r\n}\r\nvoid\r\nil4965_init_sensitivity(struct il_priv *il)\r\n{\r\nint ret = 0;\r\nint i;\r\nstruct il_sensitivity_data *data = NULL;\r\nconst struct il_sensitivity_ranges *ranges = il->hw_params.sens;\r\nif (il->disable_sens_cal)\r\nreturn;\r\nD_CALIB("Start il4965_init_sensitivity\n");\r\ndata = &(il->sensitivity_data);\r\nif (ranges == NULL)\r\nreturn;\r\nmemset(data, 0, sizeof(struct il_sensitivity_data));\r\ndata->num_in_cck_no_fa = 0;\r\ndata->nrg_curr_state = IL_FA_TOO_MANY;\r\ndata->nrg_prev_state = IL_FA_TOO_MANY;\r\ndata->nrg_silence_ref = 0;\r\ndata->nrg_silence_idx = 0;\r\ndata->nrg_energy_idx = 0;\r\nfor (i = 0; i < 10; i++)\r\ndata->nrg_value[i] = 0;\r\nfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++)\r\ndata->nrg_silence_rssi[i] = 0;\r\ndata->auto_corr_ofdm = ranges->auto_corr_min_ofdm;\r\ndata->auto_corr_ofdm_mrc = ranges->auto_corr_min_ofdm_mrc;\r\ndata->auto_corr_ofdm_x1 = ranges->auto_corr_min_ofdm_x1;\r\ndata->auto_corr_ofdm_mrc_x1 = ranges->auto_corr_min_ofdm_mrc_x1;\r\ndata->auto_corr_cck = AUTO_CORR_CCK_MIN_VAL_DEF;\r\ndata->auto_corr_cck_mrc = ranges->auto_corr_min_cck_mrc;\r\ndata->nrg_th_cck = ranges->nrg_th_cck;\r\ndata->nrg_th_ofdm = ranges->nrg_th_ofdm;\r\ndata->barker_corr_th_min = ranges->barker_corr_th_min;\r\ndata->barker_corr_th_min_mrc = ranges->barker_corr_th_min_mrc;\r\ndata->nrg_th_cca = ranges->nrg_th_cca;\r\ndata->last_bad_plcp_cnt_ofdm = 0;\r\ndata->last_fa_cnt_ofdm = 0;\r\ndata->last_bad_plcp_cnt_cck = 0;\r\ndata->last_fa_cnt_cck = 0;\r\nret |= il4965_sensitivity_write(il);\r\nD_CALIB("<<return 0x%X\n", ret);\r\n}\r\nvoid\r\nil4965_sensitivity_calibration(struct il_priv *il, void *resp)\r\n{\r\nu32 rx_enable_time;\r\nu32 fa_cck;\r\nu32 fa_ofdm;\r\nu32 bad_plcp_cck;\r\nu32 bad_plcp_ofdm;\r\nu32 norm_fa_ofdm;\r\nu32 norm_fa_cck;\r\nstruct il_sensitivity_data *data = NULL;\r\nstruct stats_rx_non_phy *rx_info;\r\nstruct stats_rx_phy *ofdm, *cck;\r\nunsigned long flags;\r\nstruct stats_general_data statis;\r\nif (il->disable_sens_cal)\r\nreturn;\r\ndata = &(il->sensitivity_data);\r\nif (!il_is_any_associated(il)) {\r\nD_CALIB("<< - not associated\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&il->lock, flags);\r\nrx_info = &(((struct il_notif_stats *)resp)->rx.general);\r\nofdm = &(((struct il_notif_stats *)resp)->rx.ofdm);\r\ncck = &(((struct il_notif_stats *)resp)->rx.cck);\r\nif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\r\nD_CALIB("<< invalid data.\n");\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nreturn;\r\n}\r\nrx_enable_time = le32_to_cpu(rx_info->channel_load);\r\nfa_cck = le32_to_cpu(cck->false_alarm_cnt);\r\nfa_ofdm = le32_to_cpu(ofdm->false_alarm_cnt);\r\nbad_plcp_cck = le32_to_cpu(cck->plcp_err);\r\nbad_plcp_ofdm = le32_to_cpu(ofdm->plcp_err);\r\nstatis.beacon_silence_rssi_a =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_a);\r\nstatis.beacon_silence_rssi_b =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_b);\r\nstatis.beacon_silence_rssi_c =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_c);\r\nstatis.beacon_energy_a = le32_to_cpu(rx_info->beacon_energy_a);\r\nstatis.beacon_energy_b = le32_to_cpu(rx_info->beacon_energy_b);\r\nstatis.beacon_energy_c = le32_to_cpu(rx_info->beacon_energy_c);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nD_CALIB("rx_enable_time = %u usecs\n", rx_enable_time);\r\nif (!rx_enable_time) {\r\nD_CALIB("<< RX Enable Time == 0!\n");\r\nreturn;\r\n}\r\nif (data->last_bad_plcp_cnt_cck > bad_plcp_cck)\r\ndata->last_bad_plcp_cnt_cck = bad_plcp_cck;\r\nelse {\r\nbad_plcp_cck -= data->last_bad_plcp_cnt_cck;\r\ndata->last_bad_plcp_cnt_cck += bad_plcp_cck;\r\n}\r\nif (data->last_bad_plcp_cnt_ofdm > bad_plcp_ofdm)\r\ndata->last_bad_plcp_cnt_ofdm = bad_plcp_ofdm;\r\nelse {\r\nbad_plcp_ofdm -= data->last_bad_plcp_cnt_ofdm;\r\ndata->last_bad_plcp_cnt_ofdm += bad_plcp_ofdm;\r\n}\r\nif (data->last_fa_cnt_ofdm > fa_ofdm)\r\ndata->last_fa_cnt_ofdm = fa_ofdm;\r\nelse {\r\nfa_ofdm -= data->last_fa_cnt_ofdm;\r\ndata->last_fa_cnt_ofdm += fa_ofdm;\r\n}\r\nif (data->last_fa_cnt_cck > fa_cck)\r\ndata->last_fa_cnt_cck = fa_cck;\r\nelse {\r\nfa_cck -= data->last_fa_cnt_cck;\r\ndata->last_fa_cnt_cck += fa_cck;\r\n}\r\nnorm_fa_ofdm = fa_ofdm + bad_plcp_ofdm;\r\nnorm_fa_cck = fa_cck + bad_plcp_cck;\r\nD_CALIB("cck: fa %u badp %u ofdm: fa %u badp %u\n", fa_cck,\r\nbad_plcp_cck, fa_ofdm, bad_plcp_ofdm);\r\nil4965_sens_auto_corr_ofdm(il, norm_fa_ofdm, rx_enable_time);\r\nil4965_sens_energy_cck(il, norm_fa_cck, rx_enable_time, &statis);\r\nil4965_sensitivity_write(il);\r\n}\r\nstatic inline u8\r\nil4965_find_first_chain(u8 mask)\r\n{\r\nif (mask & ANT_A)\r\nreturn CHAIN_A;\r\nif (mask & ANT_B)\r\nreturn CHAIN_B;\r\nreturn CHAIN_C;\r\n}\r\nstatic void\r\nil4965_find_disconn_antenna(struct il_priv *il, u32 * average_sig,\r\nstruct il_chain_noise_data *data)\r\n{\r\nu32 active_chains = 0;\r\nu32 max_average_sig;\r\nu16 max_average_sig_antenna_i;\r\nu8 num_tx_chains;\r\nu8 first_chain;\r\nu16 i = 0;\r\naverage_sig[0] =\r\ndata->chain_signal_a /\r\nil->cfg->chain_noise_num_beacons;\r\naverage_sig[1] =\r\ndata->chain_signal_b /\r\nil->cfg->chain_noise_num_beacons;\r\naverage_sig[2] =\r\ndata->chain_signal_c /\r\nil->cfg->chain_noise_num_beacons;\r\nif (average_sig[0] >= average_sig[1]) {\r\nmax_average_sig = average_sig[0];\r\nmax_average_sig_antenna_i = 0;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n} else {\r\nmax_average_sig = average_sig[1];\r\nmax_average_sig_antenna_i = 1;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n}\r\nif (average_sig[2] >= max_average_sig) {\r\nmax_average_sig = average_sig[2];\r\nmax_average_sig_antenna_i = 2;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n}\r\nD_CALIB("average_sig: a %d b %d c %d\n", average_sig[0], average_sig[1],\r\naverage_sig[2]);\r\nD_CALIB("max_average_sig = %d, antenna %d\n", max_average_sig,\r\nmax_average_sig_antenna_i);\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nif (i != max_average_sig_antenna_i) {\r\ns32 rssi_delta = (max_average_sig - average_sig[i]);\r\nif (rssi_delta > MAXIMUM_ALLOWED_PATHLOSS)\r\ndata->disconn_array[i] = 1;\r\nelse\r\nactive_chains |= (1 << i);\r\nD_CALIB("i = %d rssiDelta = %d "\r\n"disconn_array[i] = %d\n", i, rssi_delta,\r\ndata->disconn_array[i]);\r\n}\r\n}\r\nactive_chains &= il->hw_params.valid_rx_ant;\r\nnum_tx_chains = 0;\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nu8 ant_msk = (1 << i);\r\nif (!(il->hw_params.valid_tx_ant & ant_msk))\r\ncontinue;\r\nnum_tx_chains++;\r\nif (data->disconn_array[i] == 0)\r\nbreak;\r\nif (num_tx_chains == il->hw_params.tx_chains_num &&\r\ndata->disconn_array[i]) {\r\nfirst_chain =\r\nil4965_find_first_chain(il->cfg->valid_tx_ant);\r\ndata->disconn_array[first_chain] = 0;\r\nactive_chains |= BIT(first_chain);\r\nD_CALIB("All Tx chains are disconnected"\r\n"- declare %d as connected\n", first_chain);\r\nbreak;\r\n}\r\n}\r\nif (active_chains != il->hw_params.valid_rx_ant &&\r\nactive_chains != il->chain_noise_data.active_chains)\r\nD_CALIB("Detected that not all antennas are connected! "\r\n"Connected: %#x, valid: %#x.\n", active_chains,\r\nil->hw_params.valid_rx_ant);\r\ndata->active_chains = active_chains;\r\nD_CALIB("active_chains (bitwise) = 0x%x\n", active_chains);\r\n}\r\nstatic void\r\nil4965_gain_computation(struct il_priv *il, u32 * average_noise,\r\nu16 min_average_noise_antenna_i, u32 min_average_noise,\r\nu8 default_chain)\r\n{\r\nint i, ret;\r\nstruct il_chain_noise_data *data = &il->chain_noise_data;\r\ndata->delta_gain_code[min_average_noise_antenna_i] = 0;\r\nfor (i = default_chain; i < NUM_RX_CHAINS; i++) {\r\ns32 delta_g = 0;\r\nif (!data->disconn_array[i] &&\r\ndata->delta_gain_code[i] ==\r\nCHAIN_NOISE_DELTA_GAIN_INIT_VAL) {\r\ndelta_g = average_noise[i] - min_average_noise;\r\ndata->delta_gain_code[i] = (u8) ((delta_g * 10) / 15);\r\ndata->delta_gain_code[i] =\r\nmin(data->delta_gain_code[i],\r\n(u8) CHAIN_NOISE_MAX_DELTA_GAIN_CODE);\r\ndata->delta_gain_code[i] =\r\n(data->delta_gain_code[i] | (1 << 2));\r\n} else {\r\ndata->delta_gain_code[i] = 0;\r\n}\r\n}\r\nD_CALIB("delta_gain_codes: a %d b %d c %d\n", data->delta_gain_code[0],\r\ndata->delta_gain_code[1], data->delta_gain_code[2]);\r\nif (!data->radio_write) {\r\nstruct il_calib_diff_gain_cmd cmd;\r\ndata->radio_write = 1;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.hdr.op_code = IL_PHY_CALIBRATE_DIFF_GAIN_CMD;\r\ncmd.diff_gain_a = data->delta_gain_code[0];\r\ncmd.diff_gain_b = data->delta_gain_code[1];\r\ncmd.diff_gain_c = data->delta_gain_code[2];\r\nret = il_send_cmd_pdu(il, C_PHY_CALIBRATION, sizeof(cmd), &cmd);\r\nif (ret)\r\nD_CALIB("fail sending cmd " "C_PHY_CALIBRATION\n");\r\ndata->state = IL_CHAIN_NOISE_CALIBRATED;\r\n}\r\n}\r\nvoid\r\nil4965_chain_noise_calibration(struct il_priv *il, void *stat_resp)\r\n{\r\nstruct il_chain_noise_data *data = NULL;\r\nu32 chain_noise_a;\r\nu32 chain_noise_b;\r\nu32 chain_noise_c;\r\nu32 chain_sig_a;\r\nu32 chain_sig_b;\r\nu32 chain_sig_c;\r\nu32 average_sig[NUM_RX_CHAINS] = { INITIALIZATION_VALUE };\r\nu32 average_noise[NUM_RX_CHAINS] = { INITIALIZATION_VALUE };\r\nu32 min_average_noise = MIN_AVERAGE_NOISE_MAX_VALUE;\r\nu16 min_average_noise_antenna_i = INITIALIZATION_VALUE;\r\nu16 i = 0;\r\nu16 rxon_chnum = INITIALIZATION_VALUE;\r\nu16 stat_chnum = INITIALIZATION_VALUE;\r\nu8 rxon_band24;\r\nu8 stat_band24;\r\nunsigned long flags;\r\nstruct stats_rx_non_phy *rx_info;\r\nif (il->disable_chain_noise_cal)\r\nreturn;\r\ndata = &(il->chain_noise_data);\r\nif (data->state != IL_CHAIN_NOISE_ACCUMULATE) {\r\nif (data->state == IL_CHAIN_NOISE_ALIVE)\r\nD_CALIB("Wait for noise calib reset\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&il->lock, flags);\r\nrx_info = &(((struct il_notif_stats *)stat_resp)->rx.general);\r\nif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\r\nD_CALIB(" << Interference data unavailable\n");\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nreturn;\r\n}\r\nrxon_band24 = !!(il->staging.flags & RXON_FLG_BAND_24G_MSK);\r\nrxon_chnum = le16_to_cpu(il->staging.channel);\r\nstat_band24 =\r\n!!(((struct il_notif_stats *)stat_resp)->\r\nflag & STATS_REPLY_FLG_BAND_24G_MSK);\r\nstat_chnum =\r\nle32_to_cpu(((struct il_notif_stats *)stat_resp)->flag) >> 16;\r\nif (rxon_chnum != stat_chnum || rxon_band24 != stat_band24) {\r\nD_CALIB("Stats not from chan=%d, band24=%d\n", rxon_chnum,\r\nrxon_band24);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nreturn;\r\n}\r\nchain_noise_a =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_a) & IN_BAND_FILTER;\r\nchain_noise_b =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_b) & IN_BAND_FILTER;\r\nchain_noise_c =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_c) & IN_BAND_FILTER;\r\nchain_sig_a = le32_to_cpu(rx_info->beacon_rssi_a) & IN_BAND_FILTER;\r\nchain_sig_b = le32_to_cpu(rx_info->beacon_rssi_b) & IN_BAND_FILTER;\r\nchain_sig_c = le32_to_cpu(rx_info->beacon_rssi_c) & IN_BAND_FILTER;\r\nspin_unlock_irqrestore(&il->lock, flags);\r\ndata->beacon_count++;\r\ndata->chain_noise_a = (chain_noise_a + data->chain_noise_a);\r\ndata->chain_noise_b = (chain_noise_b + data->chain_noise_b);\r\ndata->chain_noise_c = (chain_noise_c + data->chain_noise_c);\r\ndata->chain_signal_a = (chain_sig_a + data->chain_signal_a);\r\ndata->chain_signal_b = (chain_sig_b + data->chain_signal_b);\r\ndata->chain_signal_c = (chain_sig_c + data->chain_signal_c);\r\nD_CALIB("chan=%d, band24=%d, beacon=%d\n", rxon_chnum, rxon_band24,\r\ndata->beacon_count);\r\nD_CALIB("chain_sig: a %d b %d c %d\n", chain_sig_a, chain_sig_b,\r\nchain_sig_c);\r\nD_CALIB("chain_noise: a %d b %d c %d\n", chain_noise_a, chain_noise_b,\r\nchain_noise_c);\r\nif (data->beacon_count != il->cfg->chain_noise_num_beacons)\r\nreturn;\r\nil4965_find_disconn_antenna(il, average_sig, data);\r\naverage_noise[0] =\r\ndata->chain_noise_a / il->cfg->chain_noise_num_beacons;\r\naverage_noise[1] =\r\ndata->chain_noise_b / il->cfg->chain_noise_num_beacons;\r\naverage_noise[2] =\r\ndata->chain_noise_c / il->cfg->chain_noise_num_beacons;\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nif (!data->disconn_array[i] &&\r\naverage_noise[i] <= min_average_noise) {\r\nmin_average_noise = average_noise[i];\r\nmin_average_noise_antenna_i = i;\r\n}\r\n}\r\nD_CALIB("average_noise: a %d b %d c %d\n", average_noise[0],\r\naverage_noise[1], average_noise[2]);\r\nD_CALIB("min_average_noise = %d, antenna %d\n", min_average_noise,\r\nmin_average_noise_antenna_i);\r\nil4965_gain_computation(il, average_noise, min_average_noise_antenna_i,\r\nmin_average_noise,\r\nil4965_find_first_chain(il->cfg->valid_rx_ant));\r\nif (il->ops->update_chain_flags)\r\nil->ops->update_chain_flags(il);\r\ndata->state = IL_CHAIN_NOISE_DONE;\r\nil_power_update_mode(il, false);\r\n}\r\nvoid\r\nil4965_reset_run_time_calib(struct il_priv *il)\r\n{\r\nint i;\r\nmemset(&(il->sensitivity_data), 0, sizeof(struct il_sensitivity_data));\r\nmemset(&(il->chain_noise_data), 0, sizeof(struct il_chain_noise_data));\r\nfor (i = 0; i < NUM_RX_CHAINS; i++)\r\nil->chain_noise_data.delta_gain_code[i] =\r\nCHAIN_NOISE_DELTA_GAIN_INIT_VAL;\r\nil_send_stats_request(il, CMD_ASYNC, true);\r\n}
