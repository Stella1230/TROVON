static int sunxi_reset_assert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct sunxi_reset_data *data = container_of(rcdev,\r\nstruct sunxi_reset_data,\r\nrcdev);\r\nint bank = id / BITS_PER_LONG;\r\nint offset = id % BITS_PER_LONG;\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&data->lock, flags);\r\nreg = readl(data->membase + (bank * 4));\r\nwritel(reg & ~BIT(offset), data->membase + (bank * 4));\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sunxi_reset_deassert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct sunxi_reset_data *data = container_of(rcdev,\r\nstruct sunxi_reset_data,\r\nrcdev);\r\nint bank = id / BITS_PER_LONG;\r\nint offset = id % BITS_PER_LONG;\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&data->lock, flags);\r\nreg = readl(data->membase + (bank * 4));\r\nwritel(reg | BIT(offset), data->membase + (bank * 4));\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sunxi_reset_init(struct device_node *np)\r\n{\r\nstruct sunxi_reset_data *data;\r\nstruct resource res;\r\nresource_size_t size;\r\nint ret;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret)\r\ngoto err_alloc;\r\nsize = resource_size(&res);\r\nif (!request_mem_region(res.start, size, np->name)) {\r\nret = -EBUSY;\r\ngoto err_alloc;\r\n}\r\ndata->membase = ioremap(res.start, size);\r\nif (!data->membase) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\ndata->rcdev.owner = THIS_MODULE;\r\ndata->rcdev.nr_resets = size * 32;\r\ndata->rcdev.ops = &sunxi_reset_ops;\r\ndata->rcdev.of_node = np;\r\nreset_controller_register(&data->rcdev);\r\nreturn 0;\r\nerr_alloc:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nvoid __init sun6i_reset_init(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_matching_node(np, sunxi_early_reset_dt_ids)\r\nsunxi_reset_init(np);\r\n}\r\nstatic int sunxi_reset_probe(struct platform_device *pdev)\r\n{\r\nstruct sunxi_reset_data *data;\r\nstruct resource *res;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->membase))\r\nreturn PTR_ERR(data->membase);\r\ndata->rcdev.owner = THIS_MODULE;\r\ndata->rcdev.nr_resets = resource_size(res) * 32;\r\ndata->rcdev.ops = &sunxi_reset_ops;\r\ndata->rcdev.of_node = pdev->dev.of_node;\r\nreturn reset_controller_register(&data->rcdev);\r\n}\r\nstatic int sunxi_reset_remove(struct platform_device *pdev)\r\n{\r\nstruct sunxi_reset_data *data = platform_get_drvdata(pdev);\r\nreset_controller_unregister(&data->rcdev);\r\nreturn 0;\r\n}
