int rpc_pipefs_notifier_register(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_cond_register(&rpc_pipefs_notifier_list, nb);\r\n}\r\nvoid rpc_pipefs_notifier_unregister(struct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_unregister(&rpc_pipefs_notifier_list, nb);\r\n}\r\nstatic void rpc_purge_list(wait_queue_head_t *waitq, struct list_head *head,\r\nvoid (*destroy_msg)(struct rpc_pipe_msg *), int err)\r\n{\r\nstruct rpc_pipe_msg *msg;\r\nif (list_empty(head))\r\nreturn;\r\ndo {\r\nmsg = list_entry(head->next, struct rpc_pipe_msg, list);\r\nlist_del_init(&msg->list);\r\nmsg->errno = err;\r\ndestroy_msg(msg);\r\n} while (!list_empty(head));\r\nif (waitq)\r\nwake_up(waitq);\r\n}\r\nstatic void\r\nrpc_timeout_upcall_queue(struct work_struct *work)\r\n{\r\nLIST_HEAD(free_list);\r\nstruct rpc_pipe *pipe =\r\ncontainer_of(work, struct rpc_pipe, queue_timeout.work);\r\nvoid (*destroy_msg)(struct rpc_pipe_msg *);\r\nstruct dentry *dentry;\r\nspin_lock(&pipe->lock);\r\ndestroy_msg = pipe->ops->destroy_msg;\r\nif (pipe->nreaders == 0) {\r\nlist_splice_init(&pipe->pipe, &free_list);\r\npipe->pipelen = 0;\r\n}\r\ndentry = dget(pipe->dentry);\r\nspin_unlock(&pipe->lock);\r\nrpc_purge_list(dentry ? &RPC_I(dentry->d_inode)->waitq : NULL,\r\n&free_list, destroy_msg, -ETIMEDOUT);\r\ndput(dentry);\r\n}\r\nssize_t rpc_pipe_generic_upcall(struct file *filp, struct rpc_pipe_msg *msg,\r\nchar __user *dst, size_t buflen)\r\n{\r\nchar *data = (char *)msg->data + msg->copied;\r\nsize_t mlen = min(msg->len - msg->copied, buflen);\r\nunsigned long left;\r\nleft = copy_to_user(dst, data, mlen);\r\nif (left == mlen) {\r\nmsg->errno = -EFAULT;\r\nreturn -EFAULT;\r\n}\r\nmlen -= left;\r\nmsg->copied += mlen;\r\nmsg->errno = 0;\r\nreturn mlen;\r\n}\r\nint\r\nrpc_queue_upcall(struct rpc_pipe *pipe, struct rpc_pipe_msg *msg)\r\n{\r\nint res = -EPIPE;\r\nstruct dentry *dentry;\r\nspin_lock(&pipe->lock);\r\nif (pipe->nreaders) {\r\nlist_add_tail(&msg->list, &pipe->pipe);\r\npipe->pipelen += msg->len;\r\nres = 0;\r\n} else if (pipe->flags & RPC_PIPE_WAIT_FOR_OPEN) {\r\nif (list_empty(&pipe->pipe))\r\nqueue_delayed_work(rpciod_workqueue,\r\n&pipe->queue_timeout,\r\nRPC_UPCALL_TIMEOUT);\r\nlist_add_tail(&msg->list, &pipe->pipe);\r\npipe->pipelen += msg->len;\r\nres = 0;\r\n}\r\ndentry = dget(pipe->dentry);\r\nspin_unlock(&pipe->lock);\r\nif (dentry) {\r\nwake_up(&RPC_I(dentry->d_inode)->waitq);\r\ndput(dentry);\r\n}\r\nreturn res;\r\n}\r\nstatic inline void\r\nrpc_inode_setowner(struct inode *inode, void *private)\r\n{\r\nRPC_I(inode)->private = private;\r\n}\r\nstatic void\r\nrpc_close_pipes(struct inode *inode)\r\n{\r\nstruct rpc_pipe *pipe = RPC_I(inode)->pipe;\r\nint need_release;\r\nLIST_HEAD(free_list);\r\nmutex_lock(&inode->i_mutex);\r\nspin_lock(&pipe->lock);\r\nneed_release = pipe->nreaders != 0 || pipe->nwriters != 0;\r\npipe->nreaders = 0;\r\nlist_splice_init(&pipe->in_upcall, &free_list);\r\nlist_splice_init(&pipe->pipe, &free_list);\r\npipe->pipelen = 0;\r\npipe->dentry = NULL;\r\nspin_unlock(&pipe->lock);\r\nrpc_purge_list(&RPC_I(inode)->waitq, &free_list, pipe->ops->destroy_msg, -EPIPE);\r\npipe->nwriters = 0;\r\nif (need_release && pipe->ops->release_pipe)\r\npipe->ops->release_pipe(inode);\r\ncancel_delayed_work_sync(&pipe->queue_timeout);\r\nrpc_inode_setowner(inode, NULL);\r\nRPC_I(inode)->pipe = NULL;\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\nstatic struct inode *\r\nrpc_alloc_inode(struct super_block *sb)\r\n{\r\nstruct rpc_inode *rpci;\r\nrpci = kmem_cache_alloc(rpc_inode_cachep, GFP_KERNEL);\r\nif (!rpci)\r\nreturn NULL;\r\nreturn &rpci->vfs_inode;\r\n}\r\nstatic void\r\nrpc_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkmem_cache_free(rpc_inode_cachep, RPC_I(inode));\r\n}\r\nstatic void\r\nrpc_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, rpc_i_callback);\r\n}\r\nstatic int\r\nrpc_pipe_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct rpc_pipe *pipe;\r\nint first_open;\r\nint res = -ENXIO;\r\nmutex_lock(&inode->i_mutex);\r\npipe = RPC_I(inode)->pipe;\r\nif (pipe == NULL)\r\ngoto out;\r\nfirst_open = pipe->nreaders == 0 && pipe->nwriters == 0;\r\nif (first_open && pipe->ops->open_pipe) {\r\nres = pipe->ops->open_pipe(inode);\r\nif (res)\r\ngoto out;\r\n}\r\nif (filp->f_mode & FMODE_READ)\r\npipe->nreaders++;\r\nif (filp->f_mode & FMODE_WRITE)\r\npipe->nwriters++;\r\nres = 0;\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn res;\r\n}\r\nstatic int\r\nrpc_pipe_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct rpc_pipe *pipe;\r\nstruct rpc_pipe_msg *msg;\r\nint last_close;\r\nmutex_lock(&inode->i_mutex);\r\npipe = RPC_I(inode)->pipe;\r\nif (pipe == NULL)\r\ngoto out;\r\nmsg = filp->private_data;\r\nif (msg != NULL) {\r\nspin_lock(&pipe->lock);\r\nmsg->errno = -EAGAIN;\r\nlist_del_init(&msg->list);\r\nspin_unlock(&pipe->lock);\r\npipe->ops->destroy_msg(msg);\r\n}\r\nif (filp->f_mode & FMODE_WRITE)\r\npipe->nwriters --;\r\nif (filp->f_mode & FMODE_READ) {\r\npipe->nreaders --;\r\nif (pipe->nreaders == 0) {\r\nLIST_HEAD(free_list);\r\nspin_lock(&pipe->lock);\r\nlist_splice_init(&pipe->pipe, &free_list);\r\npipe->pipelen = 0;\r\nspin_unlock(&pipe->lock);\r\nrpc_purge_list(&RPC_I(inode)->waitq, &free_list,\r\npipe->ops->destroy_msg, -EAGAIN);\r\n}\r\n}\r\nlast_close = pipe->nwriters == 0 && pipe->nreaders == 0;\r\nif (last_close && pipe->ops->release_pipe)\r\npipe->ops->release_pipe(inode);\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nrpc_pipe_read(struct file *filp, char __user *buf, size_t len, loff_t *offset)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nstruct rpc_pipe *pipe;\r\nstruct rpc_pipe_msg *msg;\r\nint res = 0;\r\nmutex_lock(&inode->i_mutex);\r\npipe = RPC_I(inode)->pipe;\r\nif (pipe == NULL) {\r\nres = -EPIPE;\r\ngoto out_unlock;\r\n}\r\nmsg = filp->private_data;\r\nif (msg == NULL) {\r\nspin_lock(&pipe->lock);\r\nif (!list_empty(&pipe->pipe)) {\r\nmsg = list_entry(pipe->pipe.next,\r\nstruct rpc_pipe_msg,\r\nlist);\r\nlist_move(&msg->list, &pipe->in_upcall);\r\npipe->pipelen -= msg->len;\r\nfilp->private_data = msg;\r\nmsg->copied = 0;\r\n}\r\nspin_unlock(&pipe->lock);\r\nif (msg == NULL)\r\ngoto out_unlock;\r\n}\r\nres = pipe->ops->upcall(filp, msg, buf, len);\r\nif (res < 0 || msg->len == msg->copied) {\r\nfilp->private_data = NULL;\r\nspin_lock(&pipe->lock);\r\nlist_del_init(&msg->list);\r\nspin_unlock(&pipe->lock);\r\npipe->ops->destroy_msg(msg);\r\n}\r\nout_unlock:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn res;\r\n}\r\nstatic ssize_t\r\nrpc_pipe_write(struct file *filp, const char __user *buf, size_t len, loff_t *offset)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nint res;\r\nmutex_lock(&inode->i_mutex);\r\nres = -EPIPE;\r\nif (RPC_I(inode)->pipe != NULL)\r\nres = RPC_I(inode)->pipe->ops->downcall(filp, buf, len);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn res;\r\n}\r\nstatic unsigned int\r\nrpc_pipe_poll(struct file *filp, struct poll_table_struct *wait)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nstruct rpc_inode *rpci = RPC_I(inode);\r\nunsigned int mask = POLLOUT | POLLWRNORM;\r\npoll_wait(filp, &rpci->waitq, wait);\r\nmutex_lock(&inode->i_mutex);\r\nif (rpci->pipe == NULL)\r\nmask |= POLLERR | POLLHUP;\r\nelse if (filp->private_data || !list_empty(&rpci->pipe->pipe))\r\nmask |= POLLIN | POLLRDNORM;\r\nmutex_unlock(&inode->i_mutex);\r\nreturn mask;\r\n}\r\nstatic long\r\nrpc_pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct inode *inode = file_inode(filp);\r\nstruct rpc_pipe *pipe;\r\nint len;\r\nswitch (cmd) {\r\ncase FIONREAD:\r\nmutex_lock(&inode->i_mutex);\r\npipe = RPC_I(inode)->pipe;\r\nif (pipe == NULL) {\r\nmutex_unlock(&inode->i_mutex);\r\nreturn -EPIPE;\r\n}\r\nspin_lock(&pipe->lock);\r\nlen = pipe->pipelen;\r\nif (filp->private_data) {\r\nstruct rpc_pipe_msg *msg;\r\nmsg = filp->private_data;\r\nlen += msg->len - msg->copied;\r\n}\r\nspin_unlock(&pipe->lock);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn put_user(len, (int __user *)arg);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int\r\nrpc_show_info(struct seq_file *m, void *v)\r\n{\r\nstruct rpc_clnt *clnt = m->private;\r\nrcu_read_lock();\r\nseq_printf(m, "RPC server: %s\n",\r\nrcu_dereference(clnt->cl_xprt)->servername);\r\nseq_printf(m, "service: %s (%d) version %d\n", clnt->cl_program->name,\r\nclnt->cl_prog, clnt->cl_vers);\r\nseq_printf(m, "address: %s\n", rpc_peeraddr2str(clnt, RPC_DISPLAY_ADDR));\r\nseq_printf(m, "protocol: %s\n", rpc_peeraddr2str(clnt, RPC_DISPLAY_PROTO));\r\nseq_printf(m, "port: %s\n", rpc_peeraddr2str(clnt, RPC_DISPLAY_PORT));\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int\r\nrpc_info_open(struct inode *inode, struct file *file)\r\n{\r\nstruct rpc_clnt *clnt = NULL;\r\nint ret = single_open(file, rpc_show_info, NULL);\r\nif (!ret) {\r\nstruct seq_file *m = file->private_data;\r\nspin_lock(&file->f_path.dentry->d_lock);\r\nif (!d_unhashed(file->f_path.dentry))\r\nclnt = RPC_I(inode)->private;\r\nif (clnt != NULL && atomic_inc_not_zero(&clnt->cl_count)) {\r\nspin_unlock(&file->f_path.dentry->d_lock);\r\nm->private = clnt;\r\n} else {\r\nspin_unlock(&file->f_path.dentry->d_lock);\r\nsingle_release(inode, file);\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nrpc_info_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nstruct rpc_clnt *clnt = (struct rpc_clnt *)m->private;\r\nif (clnt)\r\nrpc_release_client(clnt);\r\nreturn single_release(inode, file);\r\n}\r\nstatic struct inode *\r\nrpc_get_inode(struct super_block *sb, umode_t mode)\r\n{\r\nstruct inode *inode = new_inode(sb);\r\nif (!inode)\r\nreturn NULL;\r\ninode->i_ino = get_next_ino();\r\ninode->i_mode = mode;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\r\nswitch (mode & S_IFMT) {\r\ncase S_IFDIR:\r\ninode->i_fop = &simple_dir_operations;\r\ninode->i_op = &simple_dir_inode_operations;\r\ninc_nlink(inode);\r\ndefault:\r\nbreak;\r\n}\r\nreturn inode;\r\n}\r\nstatic int __rpc_create_common(struct inode *dir, struct dentry *dentry,\r\numode_t mode,\r\nconst struct file_operations *i_fop,\r\nvoid *private)\r\n{\r\nstruct inode *inode;\r\nd_drop(dentry);\r\ninode = rpc_get_inode(dir->i_sb, mode);\r\nif (!inode)\r\ngoto out_err;\r\ninode->i_ino = iunique(dir->i_sb, 100);\r\nif (i_fop)\r\ninode->i_fop = i_fop;\r\nif (private)\r\nrpc_inode_setowner(inode, private);\r\nd_add(dentry, inode);\r\nreturn 0;\r\nout_err:\r\nprintk(KERN_WARNING "%s: %s failed to allocate inode for dentry %pd\n",\r\n__FILE__, __func__, dentry);\r\ndput(dentry);\r\nreturn -ENOMEM;\r\n}\r\nstatic int __rpc_create(struct inode *dir, struct dentry *dentry,\r\numode_t mode,\r\nconst struct file_operations *i_fop,\r\nvoid *private)\r\n{\r\nint err;\r\nerr = __rpc_create_common(dir, dentry, S_IFREG | mode, i_fop, private);\r\nif (err)\r\nreturn err;\r\nfsnotify_create(dir, dentry);\r\nreturn 0;\r\n}\r\nstatic int __rpc_mkdir(struct inode *dir, struct dentry *dentry,\r\numode_t mode,\r\nconst struct file_operations *i_fop,\r\nvoid *private)\r\n{\r\nint err;\r\nerr = __rpc_create_common(dir, dentry, S_IFDIR | mode, i_fop, private);\r\nif (err)\r\nreturn err;\r\ninc_nlink(dir);\r\nfsnotify_mkdir(dir, dentry);\r\nreturn 0;\r\n}\r\nstatic void\r\ninit_pipe(struct rpc_pipe *pipe)\r\n{\r\npipe->nreaders = 0;\r\npipe->nwriters = 0;\r\nINIT_LIST_HEAD(&pipe->in_upcall);\r\nINIT_LIST_HEAD(&pipe->in_downcall);\r\nINIT_LIST_HEAD(&pipe->pipe);\r\npipe->pipelen = 0;\r\nINIT_DELAYED_WORK(&pipe->queue_timeout,\r\nrpc_timeout_upcall_queue);\r\npipe->ops = NULL;\r\nspin_lock_init(&pipe->lock);\r\npipe->dentry = NULL;\r\n}\r\nvoid rpc_destroy_pipe_data(struct rpc_pipe *pipe)\r\n{\r\nkfree(pipe);\r\n}\r\nstruct rpc_pipe *rpc_mkpipe_data(const struct rpc_pipe_ops *ops, int flags)\r\n{\r\nstruct rpc_pipe *pipe;\r\npipe = kzalloc(sizeof(struct rpc_pipe), GFP_KERNEL);\r\nif (!pipe)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit_pipe(pipe);\r\npipe->ops = ops;\r\npipe->flags = flags;\r\nreturn pipe;\r\n}\r\nstatic int __rpc_mkpipe_dentry(struct inode *dir, struct dentry *dentry,\r\numode_t mode,\r\nconst struct file_operations *i_fop,\r\nvoid *private,\r\nstruct rpc_pipe *pipe)\r\n{\r\nstruct rpc_inode *rpci;\r\nint err;\r\nerr = __rpc_create_common(dir, dentry, S_IFIFO | mode, i_fop, private);\r\nif (err)\r\nreturn err;\r\nrpci = RPC_I(dentry->d_inode);\r\nrpci->private = private;\r\nrpci->pipe = pipe;\r\nfsnotify_create(dir, dentry);\r\nreturn 0;\r\n}\r\nstatic int __rpc_rmdir(struct inode *dir, struct dentry *dentry)\r\n{\r\nint ret;\r\ndget(dentry);\r\nret = simple_rmdir(dir, dentry);\r\nd_delete(dentry);\r\ndput(dentry);\r\nreturn ret;\r\n}\r\nint rpc_rmdir(struct dentry *dentry)\r\n{\r\nstruct dentry *parent;\r\nstruct inode *dir;\r\nint error;\r\nparent = dget_parent(dentry);\r\ndir = parent->d_inode;\r\nmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\r\nerror = __rpc_rmdir(dir, dentry);\r\nmutex_unlock(&dir->i_mutex);\r\ndput(parent);\r\nreturn error;\r\n}\r\nstatic int __rpc_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nint ret;\r\ndget(dentry);\r\nret = simple_unlink(dir, dentry);\r\nd_delete(dentry);\r\ndput(dentry);\r\nreturn ret;\r\n}\r\nstatic int __rpc_rmpipe(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nrpc_close_pipes(inode);\r\nreturn __rpc_unlink(dir, dentry);\r\n}\r\nstatic struct dentry *__rpc_lookup_create_exclusive(struct dentry *parent,\r\nconst char *name)\r\n{\r\nstruct qstr q = QSTR_INIT(name, strlen(name));\r\nstruct dentry *dentry = d_hash_and_lookup(parent, &q);\r\nif (!dentry) {\r\ndentry = d_alloc(parent, &q);\r\nif (!dentry)\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (dentry->d_inode == NULL)\r\nreturn dentry;\r\ndput(dentry);\r\nreturn ERR_PTR(-EEXIST);\r\n}\r\nstatic void __rpc_depopulate(struct dentry *parent,\r\nconst struct rpc_filelist *files,\r\nint start, int eof)\r\n{\r\nstruct inode *dir = parent->d_inode;\r\nstruct dentry *dentry;\r\nstruct qstr name;\r\nint i;\r\nfor (i = start; i < eof; i++) {\r\nname.name = files[i].name;\r\nname.len = strlen(files[i].name);\r\ndentry = d_hash_and_lookup(parent, &name);\r\nif (dentry == NULL)\r\ncontinue;\r\nif (dentry->d_inode == NULL)\r\ngoto next;\r\nswitch (dentry->d_inode->i_mode & S_IFMT) {\r\ndefault:\r\nBUG();\r\ncase S_IFREG:\r\n__rpc_unlink(dir, dentry);\r\nbreak;\r\ncase S_IFDIR:\r\n__rpc_rmdir(dir, dentry);\r\n}\r\nnext:\r\ndput(dentry);\r\n}\r\n}\r\nstatic void rpc_depopulate(struct dentry *parent,\r\nconst struct rpc_filelist *files,\r\nint start, int eof)\r\n{\r\nstruct inode *dir = parent->d_inode;\r\nmutex_lock_nested(&dir->i_mutex, I_MUTEX_CHILD);\r\n__rpc_depopulate(parent, files, start, eof);\r\nmutex_unlock(&dir->i_mutex);\r\n}\r\nstatic int rpc_populate(struct dentry *parent,\r\nconst struct rpc_filelist *files,\r\nint start, int eof,\r\nvoid *private)\r\n{\r\nstruct inode *dir = parent->d_inode;\r\nstruct dentry *dentry;\r\nint i, err;\r\nmutex_lock(&dir->i_mutex);\r\nfor (i = start; i < eof; i++) {\r\ndentry = __rpc_lookup_create_exclusive(parent, files[i].name);\r\nerr = PTR_ERR(dentry);\r\nif (IS_ERR(dentry))\r\ngoto out_bad;\r\nswitch (files[i].mode & S_IFMT) {\r\ndefault:\r\nBUG();\r\ncase S_IFREG:\r\nerr = __rpc_create(dir, dentry,\r\nfiles[i].mode,\r\nfiles[i].i_fop,\r\nprivate);\r\nbreak;\r\ncase S_IFDIR:\r\nerr = __rpc_mkdir(dir, dentry,\r\nfiles[i].mode,\r\nNULL,\r\nprivate);\r\n}\r\nif (err != 0)\r\ngoto out_bad;\r\n}\r\nmutex_unlock(&dir->i_mutex);\r\nreturn 0;\r\nout_bad:\r\n__rpc_depopulate(parent, files, start, eof);\r\nmutex_unlock(&dir->i_mutex);\r\nprintk(KERN_WARNING "%s: %s failed to populate directory %pd\n",\r\n__FILE__, __func__, parent);\r\nreturn err;\r\n}\r\nstatic struct dentry *rpc_mkdir_populate(struct dentry *parent,\r\nconst char *name, umode_t mode, void *private,\r\nint (*populate)(struct dentry *, void *), void *args_populate)\r\n{\r\nstruct dentry *dentry;\r\nstruct inode *dir = parent->d_inode;\r\nint error;\r\nmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\r\ndentry = __rpc_lookup_create_exclusive(parent, name);\r\nif (IS_ERR(dentry))\r\ngoto out;\r\nerror = __rpc_mkdir(dir, dentry, mode, NULL, private);\r\nif (error != 0)\r\ngoto out_err;\r\nif (populate != NULL) {\r\nerror = populate(dentry, args_populate);\r\nif (error)\r\ngoto err_rmdir;\r\n}\r\nout:\r\nmutex_unlock(&dir->i_mutex);\r\nreturn dentry;\r\nerr_rmdir:\r\n__rpc_rmdir(dir, dentry);\r\nout_err:\r\ndentry = ERR_PTR(error);\r\ngoto out;\r\n}\r\nstatic int rpc_rmdir_depopulate(struct dentry *dentry,\r\nvoid (*depopulate)(struct dentry *))\r\n{\r\nstruct dentry *parent;\r\nstruct inode *dir;\r\nint error;\r\nparent = dget_parent(dentry);\r\ndir = parent->d_inode;\r\nmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\r\nif (depopulate != NULL)\r\ndepopulate(dentry);\r\nerror = __rpc_rmdir(dir, dentry);\r\nmutex_unlock(&dir->i_mutex);\r\ndput(parent);\r\nreturn error;\r\n}\r\nstruct dentry *rpc_mkpipe_dentry(struct dentry *parent, const char *name,\r\nvoid *private, struct rpc_pipe *pipe)\r\n{\r\nstruct dentry *dentry;\r\nstruct inode *dir = parent->d_inode;\r\numode_t umode = S_IFIFO | S_IRUSR | S_IWUSR;\r\nint err;\r\nif (pipe->ops->upcall == NULL)\r\numode &= ~S_IRUGO;\r\nif (pipe->ops->downcall == NULL)\r\numode &= ~S_IWUGO;\r\nmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\r\ndentry = __rpc_lookup_create_exclusive(parent, name);\r\nif (IS_ERR(dentry))\r\ngoto out;\r\nerr = __rpc_mkpipe_dentry(dir, dentry, umode, &rpc_pipe_fops,\r\nprivate, pipe);\r\nif (err)\r\ngoto out_err;\r\nout:\r\nmutex_unlock(&dir->i_mutex);\r\nreturn dentry;\r\nout_err:\r\ndentry = ERR_PTR(err);\r\nprintk(KERN_WARNING "%s: %s() failed to create pipe %pd/%s (errno = %d)\n",\r\n__FILE__, __func__, parent, name,\r\nerr);\r\ngoto out;\r\n}\r\nint\r\nrpc_unlink(struct dentry *dentry)\r\n{\r\nstruct dentry *parent;\r\nstruct inode *dir;\r\nint error = 0;\r\nparent = dget_parent(dentry);\r\ndir = parent->d_inode;\r\nmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\r\nerror = __rpc_rmpipe(dir, dentry);\r\nmutex_unlock(&dir->i_mutex);\r\ndput(parent);\r\nreturn error;\r\n}\r\nvoid rpc_init_pipe_dir_head(struct rpc_pipe_dir_head *pdh)\r\n{\r\nINIT_LIST_HEAD(&pdh->pdh_entries);\r\npdh->pdh_dentry = NULL;\r\n}\r\nvoid rpc_init_pipe_dir_object(struct rpc_pipe_dir_object *pdo,\r\nconst struct rpc_pipe_dir_object_ops *pdo_ops,\r\nvoid *pdo_data)\r\n{\r\nINIT_LIST_HEAD(&pdo->pdo_head);\r\npdo->pdo_ops = pdo_ops;\r\npdo->pdo_data = pdo_data;\r\n}\r\nstatic int\r\nrpc_add_pipe_dir_object_locked(struct net *net,\r\nstruct rpc_pipe_dir_head *pdh,\r\nstruct rpc_pipe_dir_object *pdo)\r\n{\r\nint ret = 0;\r\nif (pdh->pdh_dentry)\r\nret = pdo->pdo_ops->create(pdh->pdh_dentry, pdo);\r\nif (ret == 0)\r\nlist_add_tail(&pdo->pdo_head, &pdh->pdh_entries);\r\nreturn ret;\r\n}\r\nstatic void\r\nrpc_remove_pipe_dir_object_locked(struct net *net,\r\nstruct rpc_pipe_dir_head *pdh,\r\nstruct rpc_pipe_dir_object *pdo)\r\n{\r\nif (pdh->pdh_dentry)\r\npdo->pdo_ops->destroy(pdh->pdh_dentry, pdo);\r\nlist_del_init(&pdo->pdo_head);\r\n}\r\nint\r\nrpc_add_pipe_dir_object(struct net *net,\r\nstruct rpc_pipe_dir_head *pdh,\r\nstruct rpc_pipe_dir_object *pdo)\r\n{\r\nint ret = 0;\r\nif (list_empty(&pdo->pdo_head)) {\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nmutex_lock(&sn->pipefs_sb_lock);\r\nret = rpc_add_pipe_dir_object_locked(net, pdh, pdo);\r\nmutex_unlock(&sn->pipefs_sb_lock);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nrpc_remove_pipe_dir_object(struct net *net,\r\nstruct rpc_pipe_dir_head *pdh,\r\nstruct rpc_pipe_dir_object *pdo)\r\n{\r\nif (!list_empty(&pdo->pdo_head)) {\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nmutex_lock(&sn->pipefs_sb_lock);\r\nrpc_remove_pipe_dir_object_locked(net, pdh, pdo);\r\nmutex_unlock(&sn->pipefs_sb_lock);\r\n}\r\n}\r\nstatic void\r\nrpc_create_pipe_dir_objects(struct rpc_pipe_dir_head *pdh)\r\n{\r\nstruct rpc_pipe_dir_object *pdo;\r\nstruct dentry *dir = pdh->pdh_dentry;\r\nlist_for_each_entry(pdo, &pdh->pdh_entries, pdo_head)\r\npdo->pdo_ops->create(dir, pdo);\r\n}\r\nstatic void\r\nrpc_destroy_pipe_dir_objects(struct rpc_pipe_dir_head *pdh)\r\n{\r\nstruct rpc_pipe_dir_object *pdo;\r\nstruct dentry *dir = pdh->pdh_dentry;\r\nlist_for_each_entry(pdo, &pdh->pdh_entries, pdo_head)\r\npdo->pdo_ops->destroy(dir, pdo);\r\n}\r\nstatic int rpc_clntdir_populate(struct dentry *dentry, void *private)\r\n{\r\nreturn rpc_populate(dentry,\r\nauthfiles, RPCAUTH_info, RPCAUTH_EOF,\r\nprivate);\r\n}\r\nstatic void rpc_clntdir_depopulate(struct dentry *dentry)\r\n{\r\nrpc_depopulate(dentry, authfiles, RPCAUTH_info, RPCAUTH_EOF);\r\n}\r\nstruct dentry *rpc_create_client_dir(struct dentry *dentry,\r\nconst char *name,\r\nstruct rpc_clnt *rpc_client)\r\n{\r\nstruct dentry *ret;\r\nret = rpc_mkdir_populate(dentry, name, S_IRUGO | S_IXUGO, NULL,\r\nrpc_clntdir_populate, rpc_client);\r\nif (!IS_ERR(ret)) {\r\nrpc_client->cl_pipedir_objects.pdh_dentry = ret;\r\nrpc_create_pipe_dir_objects(&rpc_client->cl_pipedir_objects);\r\n}\r\nreturn ret;\r\n}\r\nint rpc_remove_client_dir(struct rpc_clnt *rpc_client)\r\n{\r\nstruct dentry *dentry = rpc_client->cl_pipedir_objects.pdh_dentry;\r\nif (dentry == NULL)\r\nreturn 0;\r\nrpc_destroy_pipe_dir_objects(&rpc_client->cl_pipedir_objects);\r\nrpc_client->cl_pipedir_objects.pdh_dentry = NULL;\r\nreturn rpc_rmdir_depopulate(dentry, rpc_clntdir_depopulate);\r\n}\r\nstatic int rpc_cachedir_populate(struct dentry *dentry, void *private)\r\n{\r\nreturn rpc_populate(dentry,\r\ncache_pipefs_files, 0, 3,\r\nprivate);\r\n}\r\nstatic void rpc_cachedir_depopulate(struct dentry *dentry)\r\n{\r\nrpc_depopulate(dentry, cache_pipefs_files, 0, 3);\r\n}\r\nstruct dentry *rpc_create_cache_dir(struct dentry *parent, const char *name,\r\numode_t umode, struct cache_detail *cd)\r\n{\r\nreturn rpc_mkdir_populate(parent, name, umode, NULL,\r\nrpc_cachedir_populate, cd);\r\n}\r\nvoid rpc_remove_cache_dir(struct dentry *dentry)\r\n{\r\nrpc_rmdir_depopulate(dentry, rpc_cachedir_depopulate);\r\n}\r\nstruct dentry *rpc_d_lookup_sb(const struct super_block *sb,\r\nconst unsigned char *dir_name)\r\n{\r\nstruct qstr dir = QSTR_INIT(dir_name, strlen(dir_name));\r\nreturn d_hash_and_lookup(sb->s_root, &dir);\r\n}\r\nint rpc_pipefs_init_net(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nsn->gssd_dummy = rpc_mkpipe_data(&gssd_dummy_pipe_ops, 0);\r\nif (IS_ERR(sn->gssd_dummy))\r\nreturn PTR_ERR(sn->gssd_dummy);\r\nmutex_init(&sn->pipefs_sb_lock);\r\nsn->pipe_version = -1;\r\nreturn 0;\r\n}\r\nvoid rpc_pipefs_exit_net(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nrpc_destroy_pipe_data(sn->gssd_dummy);\r\n}\r\nstruct super_block *rpc_get_sb_net(const struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nmutex_lock(&sn->pipefs_sb_lock);\r\nif (sn->pipefs_sb)\r\nreturn sn->pipefs_sb;\r\nmutex_unlock(&sn->pipefs_sb_lock);\r\nreturn NULL;\r\n}\r\nvoid rpc_put_sb_net(const struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nWARN_ON(sn->pipefs_sb == NULL);\r\nmutex_unlock(&sn->pipefs_sb_lock);\r\n}\r\nstatic ssize_t\r\ndummy_downcall(struct file *filp, const char __user *src, size_t len)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nrpc_show_dummy_info(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "RPC server: %s\n", utsname()->nodename);\r\nseq_printf(m, "service: foo (1) version 0\n");\r\nseq_printf(m, "address: 127.0.0.1\n");\r\nseq_printf(m, "protocol: tcp\n");\r\nseq_printf(m, "port: 0\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nrpc_dummy_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, rpc_show_dummy_info, NULL);\r\n}\r\nstatic struct dentry *\r\nrpc_gssd_dummy_populate(struct dentry *root, struct rpc_pipe *pipe_data)\r\n{\r\nint ret = 0;\r\nstruct dentry *gssd_dentry;\r\nstruct dentry *clnt_dentry = NULL;\r\nstruct dentry *pipe_dentry = NULL;\r\nstruct qstr q = QSTR_INIT(files[RPCAUTH_gssd].name,\r\nstrlen(files[RPCAUTH_gssd].name));\r\ngssd_dentry = d_hash_and_lookup(root, &q);\r\nif (!gssd_dentry)\r\nreturn ERR_PTR(-ENOENT);\r\nret = rpc_populate(gssd_dentry, gssd_dummy_clnt_dir, 0, 1, NULL);\r\nif (ret) {\r\npipe_dentry = ERR_PTR(ret);\r\ngoto out;\r\n}\r\nq.name = gssd_dummy_clnt_dir[0].name;\r\nq.len = strlen(gssd_dummy_clnt_dir[0].name);\r\nclnt_dentry = d_hash_and_lookup(gssd_dentry, &q);\r\nif (!clnt_dentry) {\r\npipe_dentry = ERR_PTR(-ENOENT);\r\ngoto out;\r\n}\r\nret = rpc_populate(clnt_dentry, gssd_dummy_info_file, 0, 1, NULL);\r\nif (ret) {\r\n__rpc_depopulate(gssd_dentry, gssd_dummy_clnt_dir, 0, 1);\r\npipe_dentry = ERR_PTR(ret);\r\ngoto out;\r\n}\r\npipe_dentry = rpc_mkpipe_dentry(clnt_dentry, "gssd", NULL, pipe_data);\r\nif (IS_ERR(pipe_dentry)) {\r\n__rpc_depopulate(clnt_dentry, gssd_dummy_info_file, 0, 1);\r\n__rpc_depopulate(gssd_dentry, gssd_dummy_clnt_dir, 0, 1);\r\n}\r\nout:\r\ndput(clnt_dentry);\r\ndput(gssd_dentry);\r\nreturn pipe_dentry;\r\n}\r\nstatic void\r\nrpc_gssd_dummy_depopulate(struct dentry *pipe_dentry)\r\n{\r\nstruct dentry *clnt_dir = pipe_dentry->d_parent;\r\nstruct dentry *gssd_dir = clnt_dir->d_parent;\r\n__rpc_rmpipe(clnt_dir->d_inode, pipe_dentry);\r\n__rpc_depopulate(clnt_dir, gssd_dummy_info_file, 0, 1);\r\n__rpc_depopulate(gssd_dir, gssd_dummy_clnt_dir, 0, 1);\r\ndput(pipe_dentry);\r\n}\r\nstatic int\r\nrpc_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nstruct inode *inode;\r\nstruct dentry *root, *gssd_dentry;\r\nstruct net *net = data;\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nint err;\r\nsb->s_blocksize = PAGE_CACHE_SIZE;\r\nsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\r\nsb->s_magic = RPCAUTH_GSSMAGIC;\r\nsb->s_op = &s_ops;\r\nsb->s_d_op = &simple_dentry_operations;\r\nsb->s_time_gran = 1;\r\ninode = rpc_get_inode(sb, S_IFDIR | S_IRUGO | S_IXUGO);\r\nsb->s_root = root = d_make_root(inode);\r\nif (!root)\r\nreturn -ENOMEM;\r\nif (rpc_populate(root, files, RPCAUTH_lockd, RPCAUTH_RootEOF, NULL))\r\nreturn -ENOMEM;\r\ngssd_dentry = rpc_gssd_dummy_populate(root, sn->gssd_dummy);\r\nif (IS_ERR(gssd_dentry)) {\r\n__rpc_depopulate(root, files, RPCAUTH_lockd, RPCAUTH_RootEOF);\r\nreturn PTR_ERR(gssd_dentry);\r\n}\r\ndprintk("RPC: sending pipefs MOUNT notification for net %p%s\n",\r\nnet, NET_NAME(net));\r\nmutex_lock(&sn->pipefs_sb_lock);\r\nsn->pipefs_sb = sb;\r\nerr = blocking_notifier_call_chain(&rpc_pipefs_notifier_list,\r\nRPC_PIPEFS_MOUNT,\r\nsb);\r\nif (err)\r\ngoto err_depopulate;\r\nsb->s_fs_info = get_net(net);\r\nmutex_unlock(&sn->pipefs_sb_lock);\r\nreturn 0;\r\nerr_depopulate:\r\nrpc_gssd_dummy_depopulate(gssd_dentry);\r\nblocking_notifier_call_chain(&rpc_pipefs_notifier_list,\r\nRPC_PIPEFS_UMOUNT,\r\nsb);\r\nsn->pipefs_sb = NULL;\r\n__rpc_depopulate(root, files, RPCAUTH_lockd, RPCAUTH_RootEOF);\r\nmutex_unlock(&sn->pipefs_sb_lock);\r\nreturn err;\r\n}\r\nbool\r\ngssd_running(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct rpc_pipe *pipe = sn->gssd_dummy;\r\nreturn pipe->nreaders || pipe->nwriters;\r\n}\r\nstatic struct dentry *\r\nrpc_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_ns(fs_type, flags, current->nsproxy->net_ns, rpc_fill_super);\r\n}\r\nstatic void rpc_kill_sb(struct super_block *sb)\r\n{\r\nstruct net *net = sb->s_fs_info;\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nmutex_lock(&sn->pipefs_sb_lock);\r\nif (sn->pipefs_sb != sb) {\r\nmutex_unlock(&sn->pipefs_sb_lock);\r\ngoto out;\r\n}\r\nsn->pipefs_sb = NULL;\r\ndprintk("RPC: sending pipefs UMOUNT notification for net %p%s\n",\r\nnet, NET_NAME(net));\r\nblocking_notifier_call_chain(&rpc_pipefs_notifier_list,\r\nRPC_PIPEFS_UMOUNT,\r\nsb);\r\nmutex_unlock(&sn->pipefs_sb_lock);\r\nput_net(net);\r\nout:\r\nkill_litter_super(sb);\r\n}\r\nstatic void\r\ninit_once(void *foo)\r\n{\r\nstruct rpc_inode *rpci = (struct rpc_inode *) foo;\r\ninode_init_once(&rpci->vfs_inode);\r\nrpci->private = NULL;\r\nrpci->pipe = NULL;\r\ninit_waitqueue_head(&rpci->waitq);\r\n}\r\nint register_rpc_pipefs(void)\r\n{\r\nint err;\r\nrpc_inode_cachep = kmem_cache_create("rpc_inode_cache",\r\nsizeof(struct rpc_inode),\r\n0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\r\nSLAB_MEM_SPREAD),\r\ninit_once);\r\nif (!rpc_inode_cachep)\r\nreturn -ENOMEM;\r\nerr = rpc_clients_notifier_register();\r\nif (err)\r\ngoto err_notifier;\r\nerr = register_filesystem(&rpc_pipe_fs_type);\r\nif (err)\r\ngoto err_register;\r\nreturn 0;\r\nerr_register:\r\nrpc_clients_notifier_unregister();\r\nerr_notifier:\r\nkmem_cache_destroy(rpc_inode_cachep);\r\nreturn err;\r\n}\r\nvoid unregister_rpc_pipefs(void)\r\n{\r\nrpc_clients_notifier_unregister();\r\nkmem_cache_destroy(rpc_inode_cachep);\r\nunregister_filesystem(&rpc_pipe_fs_type);\r\n}
