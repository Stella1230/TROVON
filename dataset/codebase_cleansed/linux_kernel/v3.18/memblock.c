static __init_memblock const char *\r\nmemblock_type_name(struct memblock_type *type)\r\n{\r\nif (type == &memblock.memory)\r\nreturn "memory";\r\nelse if (type == &memblock.reserved)\r\nreturn "reserved";\r\nelse\r\nreturn "unknown";\r\n}\r\nstatic inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)\r\n{\r\nreturn *size = min(*size, (phys_addr_t)ULLONG_MAX - base);\r\n}\r\nstatic unsigned long __init_memblock memblock_addrs_overlap(phys_addr_t base1, phys_addr_t size1,\r\nphys_addr_t base2, phys_addr_t size2)\r\n{\r\nreturn ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));\r\n}\r\nstatic long __init_memblock memblock_overlaps_region(struct memblock_type *type,\r\nphys_addr_t base, phys_addr_t size)\r\n{\r\nunsigned long i;\r\nfor (i = 0; i < type->cnt; i++) {\r\nphys_addr_t rgnbase = type->regions[i].base;\r\nphys_addr_t rgnsize = type->regions[i].size;\r\nif (memblock_addrs_overlap(base, size, rgnbase, rgnsize))\r\nbreak;\r\n}\r\nreturn (i < type->cnt) ? i : -1;\r\n}\r\nstatic phys_addr_t __init_memblock\r\n__memblock_find_range_bottom_up(phys_addr_t start, phys_addr_t end,\r\nphys_addr_t size, phys_addr_t align, int nid)\r\n{\r\nphys_addr_t this_start, this_end, cand;\r\nu64 i;\r\nfor_each_free_mem_range(i, nid, &this_start, &this_end, NULL) {\r\nthis_start = clamp(this_start, start, end);\r\nthis_end = clamp(this_end, start, end);\r\ncand = round_up(this_start, align);\r\nif (cand < this_end && this_end - cand >= size)\r\nreturn cand;\r\n}\r\nreturn 0;\r\n}\r\nstatic phys_addr_t __init_memblock\r\n__memblock_find_range_top_down(phys_addr_t start, phys_addr_t end,\r\nphys_addr_t size, phys_addr_t align, int nid)\r\n{\r\nphys_addr_t this_start, this_end, cand;\r\nu64 i;\r\nfor_each_free_mem_range_reverse(i, nid, &this_start, &this_end, NULL) {\r\nthis_start = clamp(this_start, start, end);\r\nthis_end = clamp(this_end, start, end);\r\nif (this_end < size)\r\ncontinue;\r\ncand = round_down(this_end - size, align);\r\nif (cand >= this_start)\r\nreturn cand;\r\n}\r\nreturn 0;\r\n}\r\nphys_addr_t __init_memblock memblock_find_in_range_node(phys_addr_t size,\r\nphys_addr_t align, phys_addr_t start,\r\nphys_addr_t end, int nid)\r\n{\r\nphys_addr_t kernel_end, ret;\r\nif (end == MEMBLOCK_ALLOC_ACCESSIBLE)\r\nend = memblock.current_limit;\r\nstart = max_t(phys_addr_t, start, PAGE_SIZE);\r\nend = max(start, end);\r\nkernel_end = __pa_symbol(_end);\r\nif (memblock_bottom_up() && end > kernel_end) {\r\nphys_addr_t bottom_up_start;\r\nbottom_up_start = max(start, kernel_end);\r\nret = __memblock_find_range_bottom_up(bottom_up_start, end,\r\nsize, align, nid);\r\nif (ret)\r\nreturn ret;\r\nWARN_ONCE(1, "memblock: bottom-up allocation failed, "\r\n"memory hotunplug may be affected\n");\r\n}\r\nreturn __memblock_find_range_top_down(start, end, size, align, nid);\r\n}\r\nphys_addr_t __init_memblock memblock_find_in_range(phys_addr_t start,\r\nphys_addr_t end, phys_addr_t size,\r\nphys_addr_t align)\r\n{\r\nreturn memblock_find_in_range_node(size, align, start, end,\r\nNUMA_NO_NODE);\r\n}\r\nstatic void __init_memblock memblock_remove_region(struct memblock_type *type, unsigned long r)\r\n{\r\ntype->total_size -= type->regions[r].size;\r\nmemmove(&type->regions[r], &type->regions[r + 1],\r\n(type->cnt - (r + 1)) * sizeof(type->regions[r]));\r\ntype->cnt--;\r\nif (type->cnt == 0) {\r\nWARN_ON(type->total_size != 0);\r\ntype->cnt = 1;\r\ntype->regions[0].base = 0;\r\ntype->regions[0].size = 0;\r\ntype->regions[0].flags = 0;\r\nmemblock_set_region_node(&type->regions[0], MAX_NUMNODES);\r\n}\r\n}\r\nphys_addr_t __init_memblock get_allocated_memblock_reserved_regions_info(\r\nphys_addr_t *addr)\r\n{\r\nif (memblock.reserved.regions == memblock_reserved_init_regions)\r\nreturn 0;\r\n*addr = __pa(memblock.reserved.regions);\r\nreturn PAGE_ALIGN(sizeof(struct memblock_region) *\r\nmemblock.reserved.max);\r\n}\r\nphys_addr_t __init_memblock get_allocated_memblock_memory_regions_info(\r\nphys_addr_t *addr)\r\n{\r\nif (memblock.memory.regions == memblock_memory_init_regions)\r\nreturn 0;\r\n*addr = __pa(memblock.memory.regions);\r\nreturn PAGE_ALIGN(sizeof(struct memblock_region) *\r\nmemblock.memory.max);\r\n}\r\nstatic int __init_memblock memblock_double_array(struct memblock_type *type,\r\nphys_addr_t new_area_start,\r\nphys_addr_t new_area_size)\r\n{\r\nstruct memblock_region *new_array, *old_array;\r\nphys_addr_t old_alloc_size, new_alloc_size;\r\nphys_addr_t old_size, new_size, addr;\r\nint use_slab = slab_is_available();\r\nint *in_slab;\r\nif (!memblock_can_resize)\r\nreturn -1;\r\nold_size = type->max * sizeof(struct memblock_region);\r\nnew_size = old_size << 1;\r\nold_alloc_size = PAGE_ALIGN(old_size);\r\nnew_alloc_size = PAGE_ALIGN(new_size);\r\nif (type == &memblock.memory)\r\nin_slab = &memblock_memory_in_slab;\r\nelse\r\nin_slab = &memblock_reserved_in_slab;\r\nif (use_slab) {\r\nnew_array = kmalloc(new_size, GFP_KERNEL);\r\naddr = new_array ? __pa(new_array) : 0;\r\n} else {\r\nif (type != &memblock.reserved)\r\nnew_area_start = new_area_size = 0;\r\naddr = memblock_find_in_range(new_area_start + new_area_size,\r\nmemblock.current_limit,\r\nnew_alloc_size, PAGE_SIZE);\r\nif (!addr && new_area_size)\r\naddr = memblock_find_in_range(0,\r\nmin(new_area_start, memblock.current_limit),\r\nnew_alloc_size, PAGE_SIZE);\r\nnew_array = addr ? __va(addr) : NULL;\r\n}\r\nif (!addr) {\r\npr_err("memblock: Failed to double %s array from %ld to %ld entries !\n",\r\nmemblock_type_name(type), type->max, type->max * 2);\r\nreturn -1;\r\n}\r\nmemblock_dbg("memblock: %s is doubled to %ld at [%#010llx-%#010llx]",\r\nmemblock_type_name(type), type->max * 2, (u64)addr,\r\n(u64)addr + new_size - 1);\r\nmemcpy(new_array, type->regions, old_size);\r\nmemset(new_array + type->max, 0, old_size);\r\nold_array = type->regions;\r\ntype->regions = new_array;\r\ntype->max <<= 1;\r\nif (*in_slab)\r\nkfree(old_array);\r\nelse if (old_array != memblock_memory_init_regions &&\r\nold_array != memblock_reserved_init_regions)\r\nmemblock_free(__pa(old_array), old_alloc_size);\r\nif (!use_slab)\r\nBUG_ON(memblock_reserve(addr, new_alloc_size));\r\n*in_slab = use_slab;\r\nreturn 0;\r\n}\r\nstatic void __init_memblock memblock_merge_regions(struct memblock_type *type)\r\n{\r\nint i = 0;\r\nwhile (i < type->cnt - 1) {\r\nstruct memblock_region *this = &type->regions[i];\r\nstruct memblock_region *next = &type->regions[i + 1];\r\nif (this->base + this->size != next->base ||\r\nmemblock_get_region_node(this) !=\r\nmemblock_get_region_node(next) ||\r\nthis->flags != next->flags) {\r\nBUG_ON(this->base + this->size > next->base);\r\ni++;\r\ncontinue;\r\n}\r\nthis->size += next->size;\r\nmemmove(next, next + 1, (type->cnt - (i + 2)) * sizeof(*next));\r\ntype->cnt--;\r\n}\r\n}\r\nstatic void __init_memblock memblock_insert_region(struct memblock_type *type,\r\nint idx, phys_addr_t base,\r\nphys_addr_t size,\r\nint nid, unsigned long flags)\r\n{\r\nstruct memblock_region *rgn = &type->regions[idx];\r\nBUG_ON(type->cnt >= type->max);\r\nmemmove(rgn + 1, rgn, (type->cnt - idx) * sizeof(*rgn));\r\nrgn->base = base;\r\nrgn->size = size;\r\nrgn->flags = flags;\r\nmemblock_set_region_node(rgn, nid);\r\ntype->cnt++;\r\ntype->total_size += size;\r\n}\r\nint __init_memblock memblock_add_range(struct memblock_type *type,\r\nphys_addr_t base, phys_addr_t size,\r\nint nid, unsigned long flags)\r\n{\r\nbool insert = false;\r\nphys_addr_t obase = base;\r\nphys_addr_t end = base + memblock_cap_size(base, &size);\r\nint i, nr_new;\r\nif (!size)\r\nreturn 0;\r\nif (type->regions[0].size == 0) {\r\nWARN_ON(type->cnt != 1 || type->total_size);\r\ntype->regions[0].base = base;\r\ntype->regions[0].size = size;\r\ntype->regions[0].flags = flags;\r\nmemblock_set_region_node(&type->regions[0], nid);\r\ntype->total_size = size;\r\nreturn 0;\r\n}\r\nrepeat:\r\nbase = obase;\r\nnr_new = 0;\r\nfor (i = 0; i < type->cnt; i++) {\r\nstruct memblock_region *rgn = &type->regions[i];\r\nphys_addr_t rbase = rgn->base;\r\nphys_addr_t rend = rbase + rgn->size;\r\nif (rbase >= end)\r\nbreak;\r\nif (rend <= base)\r\ncontinue;\r\nif (rbase > base) {\r\nnr_new++;\r\nif (insert)\r\nmemblock_insert_region(type, i++, base,\r\nrbase - base, nid,\r\nflags);\r\n}\r\nbase = min(rend, end);\r\n}\r\nif (base < end) {\r\nnr_new++;\r\nif (insert)\r\nmemblock_insert_region(type, i, base, end - base,\r\nnid, flags);\r\n}\r\nif (!insert) {\r\nwhile (type->cnt + nr_new > type->max)\r\nif (memblock_double_array(type, obase, size) < 0)\r\nreturn -ENOMEM;\r\ninsert = true;\r\ngoto repeat;\r\n} else {\r\nmemblock_merge_regions(type);\r\nreturn 0;\r\n}\r\n}\r\nint __init_memblock memblock_add_node(phys_addr_t base, phys_addr_t size,\r\nint nid)\r\n{\r\nreturn memblock_add_range(&memblock.memory, base, size, nid, 0);\r\n}\r\nint __init_memblock memblock_add(phys_addr_t base, phys_addr_t size)\r\n{\r\nreturn memblock_add_range(&memblock.memory, base, size,\r\nMAX_NUMNODES, 0);\r\n}\r\nstatic int __init_memblock memblock_isolate_range(struct memblock_type *type,\r\nphys_addr_t base, phys_addr_t size,\r\nint *start_rgn, int *end_rgn)\r\n{\r\nphys_addr_t end = base + memblock_cap_size(base, &size);\r\nint i;\r\n*start_rgn = *end_rgn = 0;\r\nif (!size)\r\nreturn 0;\r\nwhile (type->cnt + 2 > type->max)\r\nif (memblock_double_array(type, base, size) < 0)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < type->cnt; i++) {\r\nstruct memblock_region *rgn = &type->regions[i];\r\nphys_addr_t rbase = rgn->base;\r\nphys_addr_t rend = rbase + rgn->size;\r\nif (rbase >= end)\r\nbreak;\r\nif (rend <= base)\r\ncontinue;\r\nif (rbase < base) {\r\nrgn->base = base;\r\nrgn->size -= base - rbase;\r\ntype->total_size -= base - rbase;\r\nmemblock_insert_region(type, i, rbase, base - rbase,\r\nmemblock_get_region_node(rgn),\r\nrgn->flags);\r\n} else if (rend > end) {\r\nrgn->base = end;\r\nrgn->size -= end - rbase;\r\ntype->total_size -= end - rbase;\r\nmemblock_insert_region(type, i--, rbase, end - rbase,\r\nmemblock_get_region_node(rgn),\r\nrgn->flags);\r\n} else {\r\nif (!*end_rgn)\r\n*start_rgn = i;\r\n*end_rgn = i + 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __init_memblock memblock_remove_range(struct memblock_type *type,\r\nphys_addr_t base, phys_addr_t size)\r\n{\r\nint start_rgn, end_rgn;\r\nint i, ret;\r\nret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\r\nif (ret)\r\nreturn ret;\r\nfor (i = end_rgn - 1; i >= start_rgn; i--)\r\nmemblock_remove_region(type, i);\r\nreturn 0;\r\n}\r\nint __init_memblock memblock_remove(phys_addr_t base, phys_addr_t size)\r\n{\r\nreturn memblock_remove_range(&memblock.memory, base, size);\r\n}\r\nint __init_memblock memblock_free(phys_addr_t base, phys_addr_t size)\r\n{\r\nmemblock_dbg(" memblock_free: [%#016llx-%#016llx] %pF\n",\r\n(unsigned long long)base,\r\n(unsigned long long)base + size - 1,\r\n(void *)_RET_IP_);\r\nkmemleak_free_part(__va(base), size);\r\nreturn memblock_remove_range(&memblock.reserved, base, size);\r\n}\r\nstatic int __init_memblock memblock_reserve_region(phys_addr_t base,\r\nphys_addr_t size,\r\nint nid,\r\nunsigned long flags)\r\n{\r\nstruct memblock_type *_rgn = &memblock.reserved;\r\nmemblock_dbg("memblock_reserve: [%#016llx-%#016llx] flags %#02lx %pF\n",\r\n(unsigned long long)base,\r\n(unsigned long long)base + size - 1,\r\nflags, (void *)_RET_IP_);\r\nreturn memblock_add_range(_rgn, base, size, nid, flags);\r\n}\r\nint __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)\r\n{\r\nreturn memblock_reserve_region(base, size, MAX_NUMNODES, 0);\r\n}\r\nint __init_memblock memblock_mark_hotplug(phys_addr_t base, phys_addr_t size)\r\n{\r\nstruct memblock_type *type = &memblock.memory;\r\nint i, ret, start_rgn, end_rgn;\r\nret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\r\nif (ret)\r\nreturn ret;\r\nfor (i = start_rgn; i < end_rgn; i++)\r\nmemblock_set_region_flags(&type->regions[i], MEMBLOCK_HOTPLUG);\r\nmemblock_merge_regions(type);\r\nreturn 0;\r\n}\r\nint __init_memblock memblock_clear_hotplug(phys_addr_t base, phys_addr_t size)\r\n{\r\nstruct memblock_type *type = &memblock.memory;\r\nint i, ret, start_rgn, end_rgn;\r\nret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\r\nif (ret)\r\nreturn ret;\r\nfor (i = start_rgn; i < end_rgn; i++)\r\nmemblock_clear_region_flags(&type->regions[i],\r\nMEMBLOCK_HOTPLUG);\r\nmemblock_merge_regions(type);\r\nreturn 0;\r\n}\r\nvoid __init_memblock __next_mem_range(u64 *idx, int nid,\r\nstruct memblock_type *type_a,\r\nstruct memblock_type *type_b,\r\nphys_addr_t *out_start,\r\nphys_addr_t *out_end, int *out_nid)\r\n{\r\nint idx_a = *idx & 0xffffffff;\r\nint idx_b = *idx >> 32;\r\nif (WARN_ONCE(nid == MAX_NUMNODES,\r\n"Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))\r\nnid = NUMA_NO_NODE;\r\nfor (; idx_a < type_a->cnt; idx_a++) {\r\nstruct memblock_region *m = &type_a->regions[idx_a];\r\nphys_addr_t m_start = m->base;\r\nphys_addr_t m_end = m->base + m->size;\r\nint m_nid = memblock_get_region_node(m);\r\nif (nid != NUMA_NO_NODE && nid != m_nid)\r\ncontinue;\r\nif (movable_node_is_enabled() && memblock_is_hotpluggable(m))\r\ncontinue;\r\nif (!type_b) {\r\nif (out_start)\r\n*out_start = m_start;\r\nif (out_end)\r\n*out_end = m_end;\r\nif (out_nid)\r\n*out_nid = m_nid;\r\nidx_a++;\r\n*idx = (u32)idx_a | (u64)idx_b << 32;\r\nreturn;\r\n}\r\nfor (; idx_b < type_b->cnt + 1; idx_b++) {\r\nstruct memblock_region *r;\r\nphys_addr_t r_start;\r\nphys_addr_t r_end;\r\nr = &type_b->regions[idx_b];\r\nr_start = idx_b ? r[-1].base + r[-1].size : 0;\r\nr_end = idx_b < type_b->cnt ?\r\nr->base : ULLONG_MAX;\r\nif (r_start >= m_end)\r\nbreak;\r\nif (m_start < r_end) {\r\nif (out_start)\r\n*out_start =\r\nmax(m_start, r_start);\r\nif (out_end)\r\n*out_end = min(m_end, r_end);\r\nif (out_nid)\r\n*out_nid = m_nid;\r\nif (m_end <= r_end)\r\nidx_a++;\r\nelse\r\nidx_b++;\r\n*idx = (u32)idx_a | (u64)idx_b << 32;\r\nreturn;\r\n}\r\n}\r\n}\r\n*idx = ULLONG_MAX;\r\n}\r\nvoid __init_memblock __next_mem_range_rev(u64 *idx, int nid,\r\nstruct memblock_type *type_a,\r\nstruct memblock_type *type_b,\r\nphys_addr_t *out_start,\r\nphys_addr_t *out_end, int *out_nid)\r\n{\r\nint idx_a = *idx & 0xffffffff;\r\nint idx_b = *idx >> 32;\r\nif (WARN_ONCE(nid == MAX_NUMNODES, "Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))\r\nnid = NUMA_NO_NODE;\r\nif (*idx == (u64)ULLONG_MAX) {\r\nidx_a = type_a->cnt - 1;\r\nidx_b = type_b->cnt;\r\n}\r\nfor (; idx_a >= 0; idx_a--) {\r\nstruct memblock_region *m = &type_a->regions[idx_a];\r\nphys_addr_t m_start = m->base;\r\nphys_addr_t m_end = m->base + m->size;\r\nint m_nid = memblock_get_region_node(m);\r\nif (nid != NUMA_NO_NODE && nid != m_nid)\r\ncontinue;\r\nif (movable_node_is_enabled() && memblock_is_hotpluggable(m))\r\ncontinue;\r\nif (!type_b) {\r\nif (out_start)\r\n*out_start = m_start;\r\nif (out_end)\r\n*out_end = m_end;\r\nif (out_nid)\r\n*out_nid = m_nid;\r\nidx_a++;\r\n*idx = (u32)idx_a | (u64)idx_b << 32;\r\nreturn;\r\n}\r\nfor (; idx_b >= 0; idx_b--) {\r\nstruct memblock_region *r;\r\nphys_addr_t r_start;\r\nphys_addr_t r_end;\r\nr = &type_b->regions[idx_b];\r\nr_start = idx_b ? r[-1].base + r[-1].size : 0;\r\nr_end = idx_b < type_b->cnt ?\r\nr->base : ULLONG_MAX;\r\nif (r_end <= m_start)\r\nbreak;\r\nif (m_end > r_start) {\r\nif (out_start)\r\n*out_start = max(m_start, r_start);\r\nif (out_end)\r\n*out_end = min(m_end, r_end);\r\nif (out_nid)\r\n*out_nid = m_nid;\r\nif (m_start >= r_start)\r\nidx_a--;\r\nelse\r\nidx_b--;\r\n*idx = (u32)idx_a | (u64)idx_b << 32;\r\nreturn;\r\n}\r\n}\r\n}\r\n*idx = ULLONG_MAX;\r\n}\r\nvoid __init_memblock __next_mem_pfn_range(int *idx, int nid,\r\nunsigned long *out_start_pfn,\r\nunsigned long *out_end_pfn, int *out_nid)\r\n{\r\nstruct memblock_type *type = &memblock.memory;\r\nstruct memblock_region *r;\r\nwhile (++*idx < type->cnt) {\r\nr = &type->regions[*idx];\r\nif (PFN_UP(r->base) >= PFN_DOWN(r->base + r->size))\r\ncontinue;\r\nif (nid == MAX_NUMNODES || nid == r->nid)\r\nbreak;\r\n}\r\nif (*idx >= type->cnt) {\r\n*idx = -1;\r\nreturn;\r\n}\r\nif (out_start_pfn)\r\n*out_start_pfn = PFN_UP(r->base);\r\nif (out_end_pfn)\r\n*out_end_pfn = PFN_DOWN(r->base + r->size);\r\nif (out_nid)\r\n*out_nid = r->nid;\r\n}\r\nint __init_memblock memblock_set_node(phys_addr_t base, phys_addr_t size,\r\nstruct memblock_type *type, int nid)\r\n{\r\nint start_rgn, end_rgn;\r\nint i, ret;\r\nret = memblock_isolate_range(type, base, size, &start_rgn, &end_rgn);\r\nif (ret)\r\nreturn ret;\r\nfor (i = start_rgn; i < end_rgn; i++)\r\nmemblock_set_region_node(&type->regions[i], nid);\r\nmemblock_merge_regions(type);\r\nreturn 0;\r\n}\r\nstatic phys_addr_t __init memblock_alloc_range_nid(phys_addr_t size,\r\nphys_addr_t align, phys_addr_t start,\r\nphys_addr_t end, int nid)\r\n{\r\nphys_addr_t found;\r\nif (!align)\r\nalign = SMP_CACHE_BYTES;\r\nfound = memblock_find_in_range_node(size, align, start, end, nid);\r\nif (found && !memblock_reserve(found, size)) {\r\nkmemleak_alloc(__va(found), size, 0, 0);\r\nreturn found;\r\n}\r\nreturn 0;\r\n}\r\nphys_addr_t __init memblock_alloc_range(phys_addr_t size, phys_addr_t align,\r\nphys_addr_t start, phys_addr_t end)\r\n{\r\nreturn memblock_alloc_range_nid(size, align, start, end, NUMA_NO_NODE);\r\n}\r\nstatic phys_addr_t __init memblock_alloc_base_nid(phys_addr_t size,\r\nphys_addr_t align, phys_addr_t max_addr,\r\nint nid)\r\n{\r\nreturn memblock_alloc_range_nid(size, align, 0, max_addr, nid);\r\n}\r\nphys_addr_t __init memblock_alloc_nid(phys_addr_t size, phys_addr_t align, int nid)\r\n{\r\nreturn memblock_alloc_base_nid(size, align, MEMBLOCK_ALLOC_ACCESSIBLE, nid);\r\n}\r\nphys_addr_t __init __memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\r\n{\r\nreturn memblock_alloc_base_nid(size, align, max_addr, NUMA_NO_NODE);\r\n}\r\nphys_addr_t __init memblock_alloc_base(phys_addr_t size, phys_addr_t align, phys_addr_t max_addr)\r\n{\r\nphys_addr_t alloc;\r\nalloc = __memblock_alloc_base(size, align, max_addr);\r\nif (alloc == 0)\r\npanic("ERROR: Failed to allocate 0x%llx bytes below 0x%llx.\n",\r\n(unsigned long long) size, (unsigned long long) max_addr);\r\nreturn alloc;\r\n}\r\nphys_addr_t __init memblock_alloc(phys_addr_t size, phys_addr_t align)\r\n{\r\nreturn memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);\r\n}\r\nphys_addr_t __init memblock_alloc_try_nid(phys_addr_t size, phys_addr_t align, int nid)\r\n{\r\nphys_addr_t res = memblock_alloc_nid(size, align, nid);\r\nif (res)\r\nreturn res;\r\nreturn memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);\r\n}\r\nstatic void * __init memblock_virt_alloc_internal(\r\nphys_addr_t size, phys_addr_t align,\r\nphys_addr_t min_addr, phys_addr_t max_addr,\r\nint nid)\r\n{\r\nphys_addr_t alloc;\r\nvoid *ptr;\r\nif (WARN_ONCE(nid == MAX_NUMNODES, "Usage of MAX_NUMNODES is deprecated. Use NUMA_NO_NODE instead\n"))\r\nnid = NUMA_NO_NODE;\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc_node(size, GFP_NOWAIT, nid);\r\nif (!align)\r\nalign = SMP_CACHE_BYTES;\r\nif (max_addr > memblock.current_limit)\r\nmax_addr = memblock.current_limit;\r\nagain:\r\nalloc = memblock_find_in_range_node(size, align, min_addr, max_addr,\r\nnid);\r\nif (alloc)\r\ngoto done;\r\nif (nid != NUMA_NO_NODE) {\r\nalloc = memblock_find_in_range_node(size, align, min_addr,\r\nmax_addr, NUMA_NO_NODE);\r\nif (alloc)\r\ngoto done;\r\n}\r\nif (min_addr) {\r\nmin_addr = 0;\r\ngoto again;\r\n} else {\r\ngoto error;\r\n}\r\ndone:\r\nmemblock_reserve(alloc, size);\r\nptr = phys_to_virt(alloc);\r\nmemset(ptr, 0, size);\r\nkmemleak_alloc(ptr, size, 0, 0);\r\nreturn ptr;\r\nerror:\r\nreturn NULL;\r\n}\r\nvoid * __init memblock_virt_alloc_try_nid_nopanic(\r\nphys_addr_t size, phys_addr_t align,\r\nphys_addr_t min_addr, phys_addr_t max_addr,\r\nint nid)\r\n{\r\nmemblock_dbg("%s: %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx %pF\n",\r\n__func__, (u64)size, (u64)align, nid, (u64)min_addr,\r\n(u64)max_addr, (void *)_RET_IP_);\r\nreturn memblock_virt_alloc_internal(size, align, min_addr,\r\nmax_addr, nid);\r\n}\r\nvoid * __init memblock_virt_alloc_try_nid(\r\nphys_addr_t size, phys_addr_t align,\r\nphys_addr_t min_addr, phys_addr_t max_addr,\r\nint nid)\r\n{\r\nvoid *ptr;\r\nmemblock_dbg("%s: %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx %pF\n",\r\n__func__, (u64)size, (u64)align, nid, (u64)min_addr,\r\n(u64)max_addr, (void *)_RET_IP_);\r\nptr = memblock_virt_alloc_internal(size, align,\r\nmin_addr, max_addr, nid);\r\nif (ptr)\r\nreturn ptr;\r\npanic("%s: Failed to allocate %llu bytes align=0x%llx nid=%d from=0x%llx max_addr=0x%llx\n",\r\n__func__, (u64)size, (u64)align, nid, (u64)min_addr,\r\n(u64)max_addr);\r\nreturn NULL;\r\n}\r\nvoid __init __memblock_free_early(phys_addr_t base, phys_addr_t size)\r\n{\r\nmemblock_dbg("%s: [%#016llx-%#016llx] %pF\n",\r\n__func__, (u64)base, (u64)base + size - 1,\r\n(void *)_RET_IP_);\r\nkmemleak_free_part(__va(base), size);\r\nmemblock_remove_range(&memblock.reserved, base, size);\r\n}\r\nvoid __init __memblock_free_late(phys_addr_t base, phys_addr_t size)\r\n{\r\nu64 cursor, end;\r\nmemblock_dbg("%s: [%#016llx-%#016llx] %pF\n",\r\n__func__, (u64)base, (u64)base + size - 1,\r\n(void *)_RET_IP_);\r\nkmemleak_free_part(__va(base), size);\r\ncursor = PFN_UP(base);\r\nend = PFN_DOWN(base + size);\r\nfor (; cursor < end; cursor++) {\r\n__free_pages_bootmem(pfn_to_page(cursor), 0);\r\ntotalram_pages++;\r\n}\r\n}\r\nphys_addr_t __init memblock_phys_mem_size(void)\r\n{\r\nreturn memblock.memory.total_size;\r\n}\r\nphys_addr_t __init memblock_mem_size(unsigned long limit_pfn)\r\n{\r\nunsigned long pages = 0;\r\nstruct memblock_region *r;\r\nunsigned long start_pfn, end_pfn;\r\nfor_each_memblock(memory, r) {\r\nstart_pfn = memblock_region_memory_base_pfn(r);\r\nend_pfn = memblock_region_memory_end_pfn(r);\r\nstart_pfn = min_t(unsigned long, start_pfn, limit_pfn);\r\nend_pfn = min_t(unsigned long, end_pfn, limit_pfn);\r\npages += end_pfn - start_pfn;\r\n}\r\nreturn PFN_PHYS(pages);\r\n}\r\nphys_addr_t __init_memblock memblock_start_of_DRAM(void)\r\n{\r\nreturn memblock.memory.regions[0].base;\r\n}\r\nphys_addr_t __init_memblock memblock_end_of_DRAM(void)\r\n{\r\nint idx = memblock.memory.cnt - 1;\r\nreturn (memblock.memory.regions[idx].base + memblock.memory.regions[idx].size);\r\n}\r\nvoid __init memblock_enforce_memory_limit(phys_addr_t limit)\r\n{\r\nphys_addr_t max_addr = (phys_addr_t)ULLONG_MAX;\r\nstruct memblock_region *r;\r\nif (!limit)\r\nreturn;\r\nfor_each_memblock(memory, r) {\r\nif (limit <= r->size) {\r\nmax_addr = r->base + limit;\r\nbreak;\r\n}\r\nlimit -= r->size;\r\n}\r\nmemblock_remove_range(&memblock.memory, max_addr,\r\n(phys_addr_t)ULLONG_MAX);\r\nmemblock_remove_range(&memblock.reserved, max_addr,\r\n(phys_addr_t)ULLONG_MAX);\r\n}\r\nstatic int __init_memblock memblock_search(struct memblock_type *type, phys_addr_t addr)\r\n{\r\nunsigned int left = 0, right = type->cnt;\r\ndo {\r\nunsigned int mid = (right + left) / 2;\r\nif (addr < type->regions[mid].base)\r\nright = mid;\r\nelse if (addr >= (type->regions[mid].base +\r\ntype->regions[mid].size))\r\nleft = mid + 1;\r\nelse\r\nreturn mid;\r\n} while (left < right);\r\nreturn -1;\r\n}\r\nint __init memblock_is_reserved(phys_addr_t addr)\r\n{\r\nreturn memblock_search(&memblock.reserved, addr) != -1;\r\n}\r\nint __init_memblock memblock_is_memory(phys_addr_t addr)\r\n{\r\nreturn memblock_search(&memblock.memory, addr) != -1;\r\n}\r\nint __init_memblock memblock_search_pfn_nid(unsigned long pfn,\r\nunsigned long *start_pfn, unsigned long *end_pfn)\r\n{\r\nstruct memblock_type *type = &memblock.memory;\r\nint mid = memblock_search(type, PFN_PHYS(pfn));\r\nif (mid == -1)\r\nreturn -1;\r\n*start_pfn = PFN_DOWN(type->regions[mid].base);\r\n*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);\r\nreturn type->regions[mid].nid;\r\n}\r\nint __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)\r\n{\r\nint idx = memblock_search(&memblock.memory, base);\r\nphys_addr_t end = base + memblock_cap_size(base, &size);\r\nif (idx == -1)\r\nreturn 0;\r\nreturn memblock.memory.regions[idx].base <= base &&\r\n(memblock.memory.regions[idx].base +\r\nmemblock.memory.regions[idx].size) >= end;\r\n}\r\nint __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)\r\n{\r\nmemblock_cap_size(base, &size);\r\nreturn memblock_overlaps_region(&memblock.reserved, base, size) >= 0;\r\n}\r\nvoid __init_memblock memblock_trim_memory(phys_addr_t align)\r\n{\r\nphys_addr_t start, end, orig_start, orig_end;\r\nstruct memblock_region *r;\r\nfor_each_memblock(memory, r) {\r\norig_start = r->base;\r\norig_end = r->base + r->size;\r\nstart = round_up(orig_start, align);\r\nend = round_down(orig_end, align);\r\nif (start == orig_start && end == orig_end)\r\ncontinue;\r\nif (start < end) {\r\nr->base = start;\r\nr->size = end - start;\r\n} else {\r\nmemblock_remove_region(&memblock.memory,\r\nr - memblock.memory.regions);\r\nr--;\r\n}\r\n}\r\n}\r\nvoid __init_memblock memblock_set_current_limit(phys_addr_t limit)\r\n{\r\nmemblock.current_limit = limit;\r\n}\r\nphys_addr_t __init_memblock memblock_get_current_limit(void)\r\n{\r\nreturn memblock.current_limit;\r\n}\r\nstatic void __init_memblock memblock_dump(struct memblock_type *type, char *name)\r\n{\r\nunsigned long long base, size;\r\nunsigned long flags;\r\nint i;\r\npr_info(" %s.cnt = 0x%lx\n", name, type->cnt);\r\nfor (i = 0; i < type->cnt; i++) {\r\nstruct memblock_region *rgn = &type->regions[i];\r\nchar nid_buf[32] = "";\r\nbase = rgn->base;\r\nsize = rgn->size;\r\nflags = rgn->flags;\r\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\r\nif (memblock_get_region_node(rgn) != MAX_NUMNODES)\r\nsnprintf(nid_buf, sizeof(nid_buf), " on node %d",\r\nmemblock_get_region_node(rgn));\r\n#endif\r\npr_info(" %s[%#x]\t[%#016llx-%#016llx], %#llx bytes%s flags: %#lx\n",\r\nname, i, base, base + size - 1, size, nid_buf, flags);\r\n}\r\n}\r\nvoid __init_memblock __memblock_dump_all(void)\r\n{\r\npr_info("MEMBLOCK configuration:\n");\r\npr_info(" memory size = %#llx reserved size = %#llx\n",\r\n(unsigned long long)memblock.memory.total_size,\r\n(unsigned long long)memblock.reserved.total_size);\r\nmemblock_dump(&memblock.memory, "memory");\r\nmemblock_dump(&memblock.reserved, "reserved");\r\n}\r\nvoid __init memblock_allow_resize(void)\r\n{\r\nmemblock_can_resize = 1;\r\n}\r\nstatic int __init early_memblock(char *p)\r\n{\r\nif (p && strstr(p, "debug"))\r\nmemblock_debug = 1;\r\nreturn 0;\r\n}\r\nstatic int memblock_debug_show(struct seq_file *m, void *private)\r\n{\r\nstruct memblock_type *type = m->private;\r\nstruct memblock_region *reg;\r\nint i;\r\nfor (i = 0; i < type->cnt; i++) {\r\nreg = &type->regions[i];\r\nseq_printf(m, "%4d: ", i);\r\nif (sizeof(phys_addr_t) == 4)\r\nseq_printf(m, "0x%08lx..0x%08lx\n",\r\n(unsigned long)reg->base,\r\n(unsigned long)(reg->base + reg->size - 1));\r\nelse\r\nseq_printf(m, "0x%016llx..0x%016llx\n",\r\n(unsigned long long)reg->base,\r\n(unsigned long long)(reg->base + reg->size - 1));\r\n}\r\nreturn 0;\r\n}\r\nstatic int memblock_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, memblock_debug_show, inode->i_private);\r\n}\r\nstatic int __init memblock_init_debugfs(void)\r\n{\r\nstruct dentry *root = debugfs_create_dir("memblock", NULL);\r\nif (!root)\r\nreturn -ENXIO;\r\ndebugfs_create_file("memory", S_IRUGO, root, &memblock.memory, &memblock_debug_fops);\r\ndebugfs_create_file("reserved", S_IRUGO, root, &memblock.reserved, &memblock_debug_fops);\r\n#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP\r\ndebugfs_create_file("physmem", S_IRUGO, root, &memblock.physmem, &memblock_debug_fops);\r\n#endif\r\nreturn 0;\r\n}
