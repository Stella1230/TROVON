static struct a2mp_cmd *__a2mp_build(u8 code, u8 ident, u16 len, void *data)\r\n{\r\nstruct a2mp_cmd *cmd;\r\nint plen;\r\nplen = sizeof(*cmd) + len;\r\ncmd = kzalloc(plen, GFP_KERNEL);\r\nif (!cmd)\r\nreturn NULL;\r\ncmd->code = code;\r\ncmd->ident = ident;\r\ncmd->len = cpu_to_le16(len);\r\nmemcpy(cmd->data, data, len);\r\nreturn cmd;\r\n}\r\nvoid a2mp_send(struct amp_mgr *mgr, u8 code, u8 ident, u16 len, void *data)\r\n{\r\nstruct l2cap_chan *chan = mgr->a2mp_chan;\r\nstruct a2mp_cmd *cmd;\r\nu16 total_len = len + sizeof(*cmd);\r\nstruct kvec iv;\r\nstruct msghdr msg;\r\ncmd = __a2mp_build(code, ident, len, data);\r\nif (!cmd)\r\nreturn;\r\niv.iov_base = cmd;\r\niv.iov_len = total_len;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.msg_iov = (struct iovec *) &iv;\r\nmsg.msg_iovlen = 1;\r\nl2cap_chan_send(chan, &msg, total_len);\r\nkfree(cmd);\r\n}\r\nu8 __next_ident(struct amp_mgr *mgr)\r\n{\r\nif (++mgr->ident == 0)\r\nmgr->ident = 1;\r\nreturn mgr->ident;\r\n}\r\nstatic void __a2mp_add_cl(struct amp_mgr *mgr, struct a2mp_cl *cl)\r\n{\r\nstruct hci_dev *hdev;\r\nint i = 1;\r\ncl[0].id = AMP_ID_BREDR;\r\ncl[0].type = AMP_TYPE_BREDR;\r\ncl[0].status = AMP_STATUS_BLUETOOTH_ONLY;\r\nlist_for_each_entry(hdev, &hci_dev_list, list) {\r\nif (hdev->dev_type == HCI_AMP) {\r\ncl[i].id = hdev->id;\r\ncl[i].type = hdev->amp_type;\r\nif (test_bit(HCI_UP, &hdev->flags))\r\ncl[i].status = hdev->amp_status;\r\nelse\r\ncl[i].status = AMP_STATUS_POWERED_DOWN;\r\ni++;\r\n}\r\n}\r\n}\r\nstatic int a2mp_command_rej(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_cmd_rej *rej = (void *) skb->data;\r\nif (le16_to_cpu(hdr->len) < sizeof(*rej))\r\nreturn -EINVAL;\r\nBT_DBG("ident %d reason %d", hdr->ident, le16_to_cpu(rej->reason));\r\nskb_pull(skb, sizeof(*rej));\r\nreturn 0;\r\n}\r\nstatic int a2mp_discover_req(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_discov_req *req = (void *) skb->data;\r\nu16 len = le16_to_cpu(hdr->len);\r\nstruct a2mp_discov_rsp *rsp;\r\nu16 ext_feat;\r\nu8 num_ctrl;\r\nstruct hci_dev *hdev;\r\nif (len < sizeof(*req))\r\nreturn -EINVAL;\r\nskb_pull(skb, sizeof(*req));\r\next_feat = le16_to_cpu(req->ext_feat);\r\nBT_DBG("mtu %d efm 0x%4.4x", le16_to_cpu(req->mtu), ext_feat);\r\nwhile (ext_feat & A2MP_FEAT_EXT) {\r\nif (len < sizeof(ext_feat))\r\nreturn -EINVAL;\r\next_feat = get_unaligned_le16(skb->data);\r\nBT_DBG("efm 0x%4.4x", ext_feat);\r\nlen -= sizeof(ext_feat);\r\nskb_pull(skb, sizeof(ext_feat));\r\n}\r\nread_lock(&hci_dev_list_lock);\r\nnum_ctrl = 1;\r\nlist_for_each_entry(hdev, &hci_dev_list, list) {\r\nif (hdev->dev_type == HCI_AMP)\r\nnum_ctrl++;\r\n}\r\nlen = num_ctrl * sizeof(struct a2mp_cl) + sizeof(*rsp);\r\nrsp = kmalloc(len, GFP_ATOMIC);\r\nif (!rsp) {\r\nread_unlock(&hci_dev_list_lock);\r\nreturn -ENOMEM;\r\n}\r\nrsp->mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);\r\nrsp->ext_feat = 0;\r\n__a2mp_add_cl(mgr, rsp->cl);\r\nread_unlock(&hci_dev_list_lock);\r\na2mp_send(mgr, A2MP_DISCOVER_RSP, hdr->ident, len, rsp);\r\nkfree(rsp);\r\nreturn 0;\r\n}\r\nstatic int a2mp_discover_rsp(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_discov_rsp *rsp = (void *) skb->data;\r\nu16 len = le16_to_cpu(hdr->len);\r\nstruct a2mp_cl *cl;\r\nu16 ext_feat;\r\nbool found = false;\r\nif (len < sizeof(*rsp))\r\nreturn -EINVAL;\r\nlen -= sizeof(*rsp);\r\nskb_pull(skb, sizeof(*rsp));\r\next_feat = le16_to_cpu(rsp->ext_feat);\r\nBT_DBG("mtu %d efm 0x%4.4x", le16_to_cpu(rsp->mtu), ext_feat);\r\nwhile (ext_feat & A2MP_FEAT_EXT) {\r\nif (len < sizeof(ext_feat))\r\nreturn -EINVAL;\r\next_feat = get_unaligned_le16(skb->data);\r\nBT_DBG("efm 0x%4.4x", ext_feat);\r\nlen -= sizeof(ext_feat);\r\nskb_pull(skb, sizeof(ext_feat));\r\n}\r\ncl = (void *) skb->data;\r\nwhile (len >= sizeof(*cl)) {\r\nBT_DBG("Remote AMP id %d type %d status %d", cl->id, cl->type,\r\ncl->status);\r\nif (cl->id != AMP_ID_BREDR && cl->type != AMP_TYPE_BREDR) {\r\nstruct a2mp_info_req req;\r\nfound = true;\r\nreq.id = cl->id;\r\na2mp_send(mgr, A2MP_GETINFO_REQ, __next_ident(mgr),\r\nsizeof(req), &req);\r\n}\r\nlen -= sizeof(*cl);\r\ncl = (void *) skb_pull(skb, sizeof(*cl));\r\n}\r\nif (!found) {\r\nstruct l2cap_conn *conn = mgr->l2cap_conn;\r\nstruct l2cap_chan *chan;\r\nmutex_lock(&conn->chan_lock);\r\nlist_for_each_entry(chan, &conn->chan_l, list) {\r\nBT_DBG("chan %p state %s", chan,\r\nstate_to_string(chan->state));\r\nif (chan->scid == L2CAP_CID_A2MP)\r\ncontinue;\r\nl2cap_chan_lock(chan);\r\nif (chan->state == BT_CONNECT)\r\nl2cap_send_conn_req(chan);\r\nl2cap_chan_unlock(chan);\r\n}\r\nmutex_unlock(&conn->chan_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int a2mp_change_notify(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_cl *cl = (void *) skb->data;\r\nwhile (skb->len >= sizeof(*cl)) {\r\nBT_DBG("Controller id %d type %d status %d", cl->id, cl->type,\r\ncl->status);\r\ncl = (struct a2mp_cl *) skb_pull(skb, sizeof(*cl));\r\n}\r\nreturn 0;\r\n}\r\nstatic int a2mp_getinfo_req(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_info_req *req = (void *) skb->data;\r\nstruct hci_dev *hdev;\r\nif (le16_to_cpu(hdr->len) < sizeof(*req))\r\nreturn -EINVAL;\r\nBT_DBG("id %d", req->id);\r\nhdev = hci_dev_get(req->id);\r\nif (!hdev || hdev->dev_type != HCI_AMP) {\r\nstruct a2mp_info_rsp rsp;\r\nrsp.id = req->id;\r\nrsp.status = A2MP_STATUS_INVALID_CTRL_ID;\r\na2mp_send(mgr, A2MP_GETINFO_RSP, hdr->ident, sizeof(rsp),\r\n&rsp);\r\ngoto done;\r\n}\r\nset_bit(READ_LOC_AMP_INFO, &mgr->state);\r\nhci_send_cmd(hdev, HCI_OP_READ_LOCAL_AMP_INFO, 0, NULL);\r\ndone:\r\nif (hdev)\r\nhci_dev_put(hdev);\r\nskb_pull(skb, sizeof(*req));\r\nreturn 0;\r\n}\r\nstatic int a2mp_getinfo_rsp(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_info_rsp *rsp = (struct a2mp_info_rsp *) skb->data;\r\nstruct a2mp_amp_assoc_req req;\r\nstruct amp_ctrl *ctrl;\r\nif (le16_to_cpu(hdr->len) < sizeof(*rsp))\r\nreturn -EINVAL;\r\nBT_DBG("id %d status 0x%2.2x", rsp->id, rsp->status);\r\nif (rsp->status)\r\nreturn -EINVAL;\r\nctrl = amp_ctrl_add(mgr, rsp->id);\r\nif (!ctrl)\r\nreturn -ENOMEM;\r\nreq.id = rsp->id;\r\na2mp_send(mgr, A2MP_GETAMPASSOC_REQ, __next_ident(mgr), sizeof(req),\r\n&req);\r\nskb_pull(skb, sizeof(*rsp));\r\nreturn 0;\r\n}\r\nstatic int a2mp_getampassoc_req(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_amp_assoc_req *req = (void *) skb->data;\r\nstruct hci_dev *hdev;\r\nstruct amp_mgr *tmp;\r\nif (le16_to_cpu(hdr->len) < sizeof(*req))\r\nreturn -EINVAL;\r\nBT_DBG("id %d", req->id);\r\ntmp = amp_mgr_lookup_by_state(READ_LOC_AMP_ASSOC);\r\nhdev = hci_dev_get(req->id);\r\nif (!hdev || hdev->amp_type == AMP_TYPE_BREDR || tmp) {\r\nstruct a2mp_amp_assoc_rsp rsp;\r\nrsp.id = req->id;\r\nif (tmp) {\r\nrsp.status = A2MP_STATUS_COLLISION_OCCURED;\r\namp_mgr_put(tmp);\r\n} else {\r\nrsp.status = A2MP_STATUS_INVALID_CTRL_ID;\r\n}\r\na2mp_send(mgr, A2MP_GETAMPASSOC_RSP, hdr->ident, sizeof(rsp),\r\n&rsp);\r\ngoto done;\r\n}\r\namp_read_loc_assoc(hdev, mgr);\r\ndone:\r\nif (hdev)\r\nhci_dev_put(hdev);\r\nskb_pull(skb, sizeof(*req));\r\nreturn 0;\r\n}\r\nstatic int a2mp_getampassoc_rsp(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_amp_assoc_rsp *rsp = (void *) skb->data;\r\nu16 len = le16_to_cpu(hdr->len);\r\nstruct hci_dev *hdev;\r\nstruct amp_ctrl *ctrl;\r\nstruct hci_conn *hcon;\r\nsize_t assoc_len;\r\nif (len < sizeof(*rsp))\r\nreturn -EINVAL;\r\nassoc_len = len - sizeof(*rsp);\r\nBT_DBG("id %d status 0x%2.2x assoc len %zu", rsp->id, rsp->status,\r\nassoc_len);\r\nif (rsp->status)\r\nreturn -EINVAL;\r\nctrl = amp_ctrl_lookup(mgr, rsp->id);\r\nif (ctrl) {\r\nu8 *assoc;\r\nassoc = kmemdup(rsp->amp_assoc, assoc_len, GFP_KERNEL);\r\nif (!assoc) {\r\namp_ctrl_put(ctrl);\r\nreturn -ENOMEM;\r\n}\r\nctrl->assoc = assoc;\r\nctrl->assoc_len = assoc_len;\r\nctrl->assoc_rem_len = assoc_len;\r\nctrl->assoc_len_so_far = 0;\r\namp_ctrl_put(ctrl);\r\n}\r\nhdev = hci_dev_get(rsp->id);\r\nif (!hdev)\r\nreturn -EINVAL;\r\nhcon = phylink_add(hdev, mgr, rsp->id, true);\r\nif (!hcon)\r\ngoto done;\r\nBT_DBG("Created hcon %p: loc:%d -> rem:%d", hcon, hdev->id, rsp->id);\r\nmgr->bredr_chan->remote_amp_id = rsp->id;\r\namp_create_phylink(hdev, mgr, hcon);\r\ndone:\r\nhci_dev_put(hdev);\r\nskb_pull(skb, len);\r\nreturn 0;\r\n}\r\nstatic int a2mp_createphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_physlink_req *req = (void *) skb->data;\r\nstruct a2mp_physlink_rsp rsp;\r\nstruct hci_dev *hdev;\r\nstruct hci_conn *hcon;\r\nstruct amp_ctrl *ctrl;\r\nif (le16_to_cpu(hdr->len) < sizeof(*req))\r\nreturn -EINVAL;\r\nBT_DBG("local_id %d, remote_id %d", req->local_id, req->remote_id);\r\nrsp.local_id = req->remote_id;\r\nrsp.remote_id = req->local_id;\r\nhdev = hci_dev_get(req->remote_id);\r\nif (!hdev || hdev->amp_type == AMP_TYPE_BREDR) {\r\nrsp.status = A2MP_STATUS_INVALID_CTRL_ID;\r\ngoto send_rsp;\r\n}\r\nctrl = amp_ctrl_lookup(mgr, rsp.remote_id);\r\nif (!ctrl) {\r\nctrl = amp_ctrl_add(mgr, rsp.remote_id);\r\nif (ctrl) {\r\namp_ctrl_get(ctrl);\r\n} else {\r\nrsp.status = A2MP_STATUS_UNABLE_START_LINK_CREATION;\r\ngoto send_rsp;\r\n}\r\n}\r\nif (ctrl) {\r\nsize_t assoc_len = le16_to_cpu(hdr->len) - sizeof(*req);\r\nu8 *assoc;\r\nassoc = kmemdup(req->amp_assoc, assoc_len, GFP_KERNEL);\r\nif (!assoc) {\r\namp_ctrl_put(ctrl);\r\nreturn -ENOMEM;\r\n}\r\nctrl->assoc = assoc;\r\nctrl->assoc_len = assoc_len;\r\nctrl->assoc_rem_len = assoc_len;\r\nctrl->assoc_len_so_far = 0;\r\namp_ctrl_put(ctrl);\r\n}\r\nhcon = phylink_add(hdev, mgr, req->local_id, false);\r\nif (hcon) {\r\namp_accept_phylink(hdev, mgr, hcon);\r\nrsp.status = A2MP_STATUS_SUCCESS;\r\n} else {\r\nrsp.status = A2MP_STATUS_UNABLE_START_LINK_CREATION;\r\n}\r\nsend_rsp:\r\nif (hdev)\r\nhci_dev_put(hdev);\r\nif (rsp.status != A2MP_STATUS_SUCCESS) {\r\na2mp_send(mgr, A2MP_CREATEPHYSLINK_RSP, hdr->ident,\r\nsizeof(rsp), &rsp);\r\n} else {\r\nset_bit(WRITE_REMOTE_AMP_ASSOC, &mgr->state);\r\nmgr->ident = hdr->ident;\r\n}\r\nskb_pull(skb, le16_to_cpu(hdr->len));\r\nreturn 0;\r\n}\r\nstatic int a2mp_discphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nstruct a2mp_physlink_req *req = (void *) skb->data;\r\nstruct a2mp_physlink_rsp rsp;\r\nstruct hci_dev *hdev;\r\nstruct hci_conn *hcon;\r\nif (le16_to_cpu(hdr->len) < sizeof(*req))\r\nreturn -EINVAL;\r\nBT_DBG("local_id %d remote_id %d", req->local_id, req->remote_id);\r\nrsp.local_id = req->remote_id;\r\nrsp.remote_id = req->local_id;\r\nrsp.status = A2MP_STATUS_SUCCESS;\r\nhdev = hci_dev_get(req->remote_id);\r\nif (!hdev) {\r\nrsp.status = A2MP_STATUS_INVALID_CTRL_ID;\r\ngoto send_rsp;\r\n}\r\nhcon = hci_conn_hash_lookup_ba(hdev, AMP_LINK,\r\n&mgr->l2cap_conn->hcon->dst);\r\nif (!hcon) {\r\nBT_ERR("No phys link exist");\r\nrsp.status = A2MP_STATUS_NO_PHYSICAL_LINK_EXISTS;\r\ngoto clean;\r\n}\r\nclean:\r\nhci_dev_put(hdev);\r\nsend_rsp:\r\na2mp_send(mgr, A2MP_DISCONNPHYSLINK_RSP, hdr->ident, sizeof(rsp), &rsp);\r\nskb_pull(skb, sizeof(*req));\r\nreturn 0;\r\n}\r\nstatic inline int a2mp_cmd_rsp(struct amp_mgr *mgr, struct sk_buff *skb,\r\nstruct a2mp_cmd *hdr)\r\n{\r\nBT_DBG("ident %d code 0x%2.2x", hdr->ident, hdr->code);\r\nskb_pull(skb, le16_to_cpu(hdr->len));\r\nreturn 0;\r\n}\r\nstatic int a2mp_chan_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)\r\n{\r\nstruct a2mp_cmd *hdr;\r\nstruct amp_mgr *mgr = chan->data;\r\nint err = 0;\r\namp_mgr_get(mgr);\r\nwhile (skb->len >= sizeof(*hdr)) {\r\nu16 len;\r\nhdr = (void *) skb->data;\r\nlen = le16_to_cpu(hdr->len);\r\nBT_DBG("code 0x%2.2x id %d len %u", hdr->code, hdr->ident, len);\r\nskb_pull(skb, sizeof(*hdr));\r\nif (len > skb->len || !hdr->ident) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nmgr->ident = hdr->ident;\r\nswitch (hdr->code) {\r\ncase A2MP_COMMAND_REJ:\r\na2mp_command_rej(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_DISCOVER_REQ:\r\nerr = a2mp_discover_req(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_CHANGE_NOTIFY:\r\nerr = a2mp_change_notify(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_GETINFO_REQ:\r\nerr = a2mp_getinfo_req(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_GETAMPASSOC_REQ:\r\nerr = a2mp_getampassoc_req(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_CREATEPHYSLINK_REQ:\r\nerr = a2mp_createphyslink_req(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_DISCONNPHYSLINK_REQ:\r\nerr = a2mp_discphyslink_req(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_DISCOVER_RSP:\r\nerr = a2mp_discover_rsp(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_GETINFO_RSP:\r\nerr = a2mp_getinfo_rsp(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_GETAMPASSOC_RSP:\r\nerr = a2mp_getampassoc_rsp(mgr, skb, hdr);\r\nbreak;\r\ncase A2MP_CHANGE_RSP:\r\ncase A2MP_CREATEPHYSLINK_RSP:\r\ncase A2MP_DISCONNPHYSLINK_RSP:\r\nerr = a2mp_cmd_rsp(mgr, skb, hdr);\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown A2MP sig cmd 0x%2.2x", hdr->code);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (err) {\r\nstruct a2mp_cmd_rej rej;\r\nrej.reason = cpu_to_le16(0);\r\nhdr = (void *) skb->data;\r\nBT_DBG("Send A2MP Rej: cmd 0x%2.2x err %d", hdr->code, err);\r\na2mp_send(mgr, A2MP_COMMAND_REJ, hdr->ident, sizeof(rej),\r\n&rej);\r\n}\r\nkfree_skb(skb);\r\namp_mgr_put(mgr);\r\nreturn 0;\r\n}\r\nstatic void a2mp_chan_close_cb(struct l2cap_chan *chan)\r\n{\r\nl2cap_chan_put(chan);\r\n}\r\nstatic void a2mp_chan_state_change_cb(struct l2cap_chan *chan, int state,\r\nint err)\r\n{\r\nstruct amp_mgr *mgr = chan->data;\r\nif (!mgr)\r\nreturn;\r\nBT_DBG("chan %p state %s", chan, state_to_string(state));\r\nchan->state = state;\r\nswitch (state) {\r\ncase BT_CLOSED:\r\nif (mgr)\r\namp_mgr_put(mgr);\r\nbreak;\r\n}\r\n}\r\nstatic struct sk_buff *a2mp_chan_alloc_skb_cb(struct l2cap_chan *chan,\r\nunsigned long hdr_len,\r\nunsigned long len, int nb)\r\n{\r\nstruct sk_buff *skb;\r\nskb = bt_skb_alloc(hdr_len + len, GFP_KERNEL);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn skb;\r\n}\r\nstatic struct l2cap_chan *a2mp_chan_open(struct l2cap_conn *conn, bool locked)\r\n{\r\nstruct l2cap_chan *chan;\r\nint err;\r\nchan = l2cap_chan_create();\r\nif (!chan)\r\nreturn NULL;\r\nBT_DBG("chan %p", chan);\r\nchan->chan_type = L2CAP_CHAN_FIXED;\r\nchan->scid = L2CAP_CID_A2MP;\r\nchan->dcid = L2CAP_CID_A2MP;\r\nchan->omtu = L2CAP_A2MP_DEFAULT_MTU;\r\nchan->imtu = L2CAP_A2MP_DEFAULT_MTU;\r\nchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\r\nchan->ops = &a2mp_chan_ops;\r\nl2cap_chan_set_defaults(chan);\r\nchan->remote_max_tx = chan->max_tx;\r\nchan->remote_tx_win = chan->tx_win;\r\nchan->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\r\nchan->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\r\nskb_queue_head_init(&chan->tx_q);\r\nchan->mode = L2CAP_MODE_ERTM;\r\nerr = l2cap_ertm_init(chan);\r\nif (err < 0) {\r\nl2cap_chan_del(chan, 0);\r\nreturn NULL;\r\n}\r\nchan->conf_state = 0;\r\nif (locked)\r\n__l2cap_chan_add(conn, chan);\r\nelse\r\nl2cap_chan_add(conn, chan);\r\nchan->remote_mps = chan->omtu;\r\nchan->mps = chan->omtu;\r\nchan->state = BT_CONNECTED;\r\nreturn chan;\r\n}\r\nstruct amp_mgr *amp_mgr_get(struct amp_mgr *mgr)\r\n{\r\nBT_DBG("mgr %p orig refcnt %d", mgr, atomic_read(&mgr->kref.refcount));\r\nkref_get(&mgr->kref);\r\nreturn mgr;\r\n}\r\nstatic void amp_mgr_destroy(struct kref *kref)\r\n{\r\nstruct amp_mgr *mgr = container_of(kref, struct amp_mgr, kref);\r\nBT_DBG("mgr %p", mgr);\r\nmutex_lock(&amp_mgr_list_lock);\r\nlist_del(&mgr->list);\r\nmutex_unlock(&amp_mgr_list_lock);\r\namp_ctrl_list_flush(mgr);\r\nkfree(mgr);\r\n}\r\nint amp_mgr_put(struct amp_mgr *mgr)\r\n{\r\nBT_DBG("mgr %p orig refcnt %d", mgr, atomic_read(&mgr->kref.refcount));\r\nreturn kref_put(&mgr->kref, &amp_mgr_destroy);\r\n}\r\nstatic struct amp_mgr *amp_mgr_create(struct l2cap_conn *conn, bool locked)\r\n{\r\nstruct amp_mgr *mgr;\r\nstruct l2cap_chan *chan;\r\nmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\r\nif (!mgr)\r\nreturn NULL;\r\nBT_DBG("conn %p mgr %p", conn, mgr);\r\nmgr->l2cap_conn = conn;\r\nchan = a2mp_chan_open(conn, locked);\r\nif (!chan) {\r\nkfree(mgr);\r\nreturn NULL;\r\n}\r\nmgr->a2mp_chan = chan;\r\nchan->data = mgr;\r\nconn->hcon->amp_mgr = mgr;\r\nkref_init(&mgr->kref);\r\nINIT_LIST_HEAD(&mgr->amp_ctrls);\r\nmutex_init(&mgr->amp_ctrls_lock);\r\nmutex_lock(&amp_mgr_list_lock);\r\nlist_add(&mgr->list, &amp_mgr_list);\r\nmutex_unlock(&amp_mgr_list_lock);\r\nreturn mgr;\r\n}\r\nstruct l2cap_chan *a2mp_channel_create(struct l2cap_conn *conn,\r\nstruct sk_buff *skb)\r\n{\r\nstruct amp_mgr *mgr;\r\nif (conn->hcon->type != ACL_LINK)\r\nreturn NULL;\r\nmgr = amp_mgr_create(conn, false);\r\nif (!mgr) {\r\nBT_ERR("Could not create AMP manager");\r\nreturn NULL;\r\n}\r\nBT_DBG("mgr: %p chan %p", mgr, mgr->a2mp_chan);\r\nreturn mgr->a2mp_chan;\r\n}\r\nstruct amp_mgr *amp_mgr_lookup_by_state(u8 state)\r\n{\r\nstruct amp_mgr *mgr;\r\nmutex_lock(&amp_mgr_list_lock);\r\nlist_for_each_entry(mgr, &amp_mgr_list, list) {\r\nif (test_and_clear_bit(state, &mgr->state)) {\r\namp_mgr_get(mgr);\r\nmutex_unlock(&amp_mgr_list_lock);\r\nreturn mgr;\r\n}\r\n}\r\nmutex_unlock(&amp_mgr_list_lock);\r\nreturn NULL;\r\n}\r\nvoid a2mp_send_getinfo_rsp(struct hci_dev *hdev)\r\n{\r\nstruct amp_mgr *mgr;\r\nstruct a2mp_info_rsp rsp;\r\nmgr = amp_mgr_lookup_by_state(READ_LOC_AMP_INFO);\r\nif (!mgr)\r\nreturn;\r\nBT_DBG("%s mgr %p", hdev->name, mgr);\r\nrsp.id = hdev->id;\r\nrsp.status = A2MP_STATUS_INVALID_CTRL_ID;\r\nif (hdev->amp_type != AMP_TYPE_BREDR) {\r\nrsp.status = 0;\r\nrsp.total_bw = cpu_to_le32(hdev->amp_total_bw);\r\nrsp.max_bw = cpu_to_le32(hdev->amp_max_bw);\r\nrsp.min_latency = cpu_to_le32(hdev->amp_min_latency);\r\nrsp.pal_cap = cpu_to_le16(hdev->amp_pal_cap);\r\nrsp.assoc_size = cpu_to_le16(hdev->amp_assoc_size);\r\n}\r\na2mp_send(mgr, A2MP_GETINFO_RSP, mgr->ident, sizeof(rsp), &rsp);\r\namp_mgr_put(mgr);\r\n}\r\nvoid a2mp_send_getampassoc_rsp(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct amp_mgr *mgr;\r\nstruct amp_assoc *loc_assoc = &hdev->loc_assoc;\r\nstruct a2mp_amp_assoc_rsp *rsp;\r\nsize_t len;\r\nmgr = amp_mgr_lookup_by_state(READ_LOC_AMP_ASSOC);\r\nif (!mgr)\r\nreturn;\r\nBT_DBG("%s mgr %p", hdev->name, mgr);\r\nlen = sizeof(struct a2mp_amp_assoc_rsp) + loc_assoc->len;\r\nrsp = kzalloc(len, GFP_KERNEL);\r\nif (!rsp) {\r\namp_mgr_put(mgr);\r\nreturn;\r\n}\r\nrsp->id = hdev->id;\r\nif (status) {\r\nrsp->status = A2MP_STATUS_INVALID_CTRL_ID;\r\n} else {\r\nrsp->status = A2MP_STATUS_SUCCESS;\r\nmemcpy(rsp->amp_assoc, loc_assoc->data, loc_assoc->len);\r\n}\r\na2mp_send(mgr, A2MP_GETAMPASSOC_RSP, mgr->ident, len, rsp);\r\namp_mgr_put(mgr);\r\nkfree(rsp);\r\n}\r\nvoid a2mp_send_create_phy_link_req(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct amp_mgr *mgr;\r\nstruct amp_assoc *loc_assoc = &hdev->loc_assoc;\r\nstruct a2mp_physlink_req *req;\r\nstruct l2cap_chan *bredr_chan;\r\nsize_t len;\r\nmgr = amp_mgr_lookup_by_state(READ_LOC_AMP_ASSOC_FINAL);\r\nif (!mgr)\r\nreturn;\r\nlen = sizeof(*req) + loc_assoc->len;\r\nBT_DBG("%s mgr %p assoc_len %zu", hdev->name, mgr, len);\r\nreq = kzalloc(len, GFP_KERNEL);\r\nif (!req) {\r\namp_mgr_put(mgr);\r\nreturn;\r\n}\r\nbredr_chan = mgr->bredr_chan;\r\nif (!bredr_chan)\r\ngoto clean;\r\nreq->local_id = hdev->id;\r\nreq->remote_id = bredr_chan->remote_amp_id;\r\nmemcpy(req->amp_assoc, loc_assoc->data, loc_assoc->len);\r\na2mp_send(mgr, A2MP_CREATEPHYSLINK_REQ, __next_ident(mgr), len, req);\r\nclean:\r\namp_mgr_put(mgr);\r\nkfree(req);\r\n}\r\nvoid a2mp_send_create_phy_link_rsp(struct hci_dev *hdev, u8 status)\r\n{\r\nstruct amp_mgr *mgr;\r\nstruct a2mp_physlink_rsp rsp;\r\nstruct hci_conn *hs_hcon;\r\nmgr = amp_mgr_lookup_by_state(WRITE_REMOTE_AMP_ASSOC);\r\nif (!mgr)\r\nreturn;\r\nhs_hcon = hci_conn_hash_lookup_state(hdev, AMP_LINK, BT_CONNECT);\r\nif (!hs_hcon) {\r\nrsp.status = A2MP_STATUS_UNABLE_START_LINK_CREATION;\r\n} else {\r\nrsp.remote_id = hs_hcon->remote_id;\r\nrsp.status = A2MP_STATUS_SUCCESS;\r\n}\r\nBT_DBG("%s mgr %p hs_hcon %p status %u", hdev->name, mgr, hs_hcon,\r\nstatus);\r\nrsp.local_id = hdev->id;\r\na2mp_send(mgr, A2MP_CREATEPHYSLINK_RSP, mgr->ident, sizeof(rsp), &rsp);\r\namp_mgr_put(mgr);\r\n}\r\nvoid a2mp_discover_amp(struct l2cap_chan *chan)\r\n{\r\nstruct l2cap_conn *conn = chan->conn;\r\nstruct amp_mgr *mgr = conn->hcon->amp_mgr;\r\nstruct a2mp_discov_req req;\r\nBT_DBG("chan %p conn %p mgr %p", chan, conn, mgr);\r\nif (!mgr) {\r\nmgr = amp_mgr_create(conn, true);\r\nif (!mgr)\r\nreturn;\r\n}\r\nmgr->bredr_chan = chan;\r\nreq.mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);\r\nreq.ext_feat = 0;\r\na2mp_send(mgr, A2MP_DISCOVER_REQ, 1, sizeof(req), &req);\r\n}
