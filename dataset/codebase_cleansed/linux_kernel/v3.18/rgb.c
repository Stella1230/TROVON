static inline struct tegra_rgb *to_rgb(struct tegra_output *output)\r\n{\r\nreturn container_of(output, struct tegra_rgb, output);\r\n}\r\nstatic void tegra_dc_write_regs(struct tegra_dc *dc,\r\nconst struct reg_entry *table,\r\nunsigned int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i++)\r\ntegra_dc_writel(dc, table[i].value, table[i].offset);\r\n}\r\nstatic int tegra_output_rgb_enable(struct tegra_output *output)\r\n{\r\nstruct tegra_rgb *rgb = to_rgb(output);\r\nunsigned long value;\r\nif (rgb->enabled)\r\nreturn 0;\r\ntegra_dc_write_regs(rgb->dc, rgb_enable, ARRAY_SIZE(rgb_enable));\r\nvalue = DE_SELECT_ACTIVE | DE_CONTROL_NORMAL;\r\ntegra_dc_writel(rgb->dc, value, DC_DISP_DATA_ENABLE_OPTIONS);\r\nvalue = tegra_dc_readl(rgb->dc, DC_COM_PIN_OUTPUT_POLARITY(1));\r\nvalue &= ~LVS_OUTPUT_POLARITY_LOW;\r\nvalue &= ~LHS_OUTPUT_POLARITY_LOW;\r\ntegra_dc_writel(rgb->dc, value, DC_COM_PIN_OUTPUT_POLARITY(1));\r\nvalue = DISP_DATA_FORMAT_DF1P1C | DISP_ALIGNMENT_MSB |\r\nDISP_ORDER_RED_BLUE;\r\ntegra_dc_writel(rgb->dc, value, DC_DISP_DISP_INTERFACE_CONTROL);\r\nvalue = SC0_H_QUALIFIER_NONE | SC1_H_QUALIFIER_NONE;\r\ntegra_dc_writel(rgb->dc, value, DC_DISP_SHIFT_CLOCK_OPTIONS);\r\nvalue = tegra_dc_readl(rgb->dc, DC_CMD_DISPLAY_COMMAND);\r\nvalue &= ~DISP_CTRL_MODE_MASK;\r\nvalue |= DISP_CTRL_MODE_C_DISPLAY;\r\ntegra_dc_writel(rgb->dc, value, DC_CMD_DISPLAY_COMMAND);\r\nvalue = tegra_dc_readl(rgb->dc, DC_CMD_DISPLAY_POWER_CONTROL);\r\nvalue |= PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\r\nPW4_ENABLE | PM0_ENABLE | PM1_ENABLE;\r\ntegra_dc_writel(rgb->dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\r\ntegra_dc_writel(rgb->dc, GENERAL_ACT_REQ << 8, DC_CMD_STATE_CONTROL);\r\ntegra_dc_writel(rgb->dc, GENERAL_ACT_REQ, DC_CMD_STATE_CONTROL);\r\nrgb->enabled = true;\r\nreturn 0;\r\n}\r\nstatic int tegra_output_rgb_disable(struct tegra_output *output)\r\n{\r\nstruct tegra_rgb *rgb = to_rgb(output);\r\nunsigned long value;\r\nif (!rgb->enabled)\r\nreturn 0;\r\nvalue = tegra_dc_readl(rgb->dc, DC_CMD_DISPLAY_POWER_CONTROL);\r\nvalue &= ~(PW0_ENABLE | PW1_ENABLE | PW2_ENABLE | PW3_ENABLE |\r\nPW4_ENABLE | PM0_ENABLE | PM1_ENABLE);\r\ntegra_dc_writel(rgb->dc, value, DC_CMD_DISPLAY_POWER_CONTROL);\r\nvalue = tegra_dc_readl(rgb->dc, DC_CMD_DISPLAY_COMMAND);\r\nvalue &= ~DISP_CTRL_MODE_MASK;\r\ntegra_dc_writel(rgb->dc, value, DC_CMD_DISPLAY_COMMAND);\r\ntegra_dc_writel(rgb->dc, GENERAL_ACT_REQ << 8, DC_CMD_STATE_CONTROL);\r\ntegra_dc_writel(rgb->dc, GENERAL_ACT_REQ, DC_CMD_STATE_CONTROL);\r\ntegra_dc_write_regs(rgb->dc, rgb_disable, ARRAY_SIZE(rgb_disable));\r\nrgb->enabled = false;\r\nreturn 0;\r\n}\r\nstatic int tegra_output_rgb_setup_clock(struct tegra_output *output,\r\nstruct clk *clk, unsigned long pclk,\r\nunsigned int *div)\r\n{\r\nstruct tegra_rgb *rgb = to_rgb(output);\r\nint err;\r\nerr = clk_set_parent(clk, rgb->clk_parent);\r\nif (err < 0) {\r\ndev_err(output->dev, "failed to set parent: %d\n", err);\r\nreturn err;\r\n}\r\n*div = ((clk_get_rate(clk) * 2) / pclk) - 2;\r\nreturn 0;\r\n}\r\nstatic int tegra_output_rgb_check_mode(struct tegra_output *output,\r\nstruct drm_display_mode *mode,\r\nenum drm_mode_status *status)\r\n{\r\n*status = MODE_OK;\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_probe(struct tegra_dc *dc)\r\n{\r\nstruct device_node *np;\r\nstruct tegra_rgb *rgb;\r\nint err;\r\nnp = of_get_child_by_name(dc->dev->of_node, "rgb");\r\nif (!np || !of_device_is_available(np))\r\nreturn -ENODEV;\r\nrgb = devm_kzalloc(dc->dev, sizeof(*rgb), GFP_KERNEL);\r\nif (!rgb)\r\nreturn -ENOMEM;\r\nrgb->output.dev = dc->dev;\r\nrgb->output.of_node = np;\r\nrgb->dc = dc;\r\nerr = tegra_output_probe(&rgb->output);\r\nif (err < 0)\r\nreturn err;\r\nrgb->clk = devm_clk_get(dc->dev, NULL);\r\nif (IS_ERR(rgb->clk)) {\r\ndev_err(dc->dev, "failed to get clock\n");\r\nreturn PTR_ERR(rgb->clk);\r\n}\r\nrgb->clk_parent = devm_clk_get(dc->dev, "parent");\r\nif (IS_ERR(rgb->clk_parent)) {\r\ndev_err(dc->dev, "failed to get parent clock\n");\r\nreturn PTR_ERR(rgb->clk_parent);\r\n}\r\nerr = clk_set_parent(rgb->clk, rgb->clk_parent);\r\nif (err < 0) {\r\ndev_err(dc->dev, "failed to set parent clock: %d\n", err);\r\nreturn err;\r\n}\r\ndc->rgb = &rgb->output;\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_remove(struct tegra_dc *dc)\r\n{\r\nint err;\r\nif (!dc->rgb)\r\nreturn 0;\r\nerr = tegra_output_remove(dc->rgb);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_init(struct drm_device *drm, struct tegra_dc *dc)\r\n{\r\nstruct tegra_rgb *rgb = to_rgb(dc->rgb);\r\nint err;\r\nif (!dc->rgb)\r\nreturn -ENODEV;\r\nrgb->output.type = TEGRA_OUTPUT_RGB;\r\nrgb->output.ops = &rgb_ops;\r\nerr = tegra_output_init(dc->base.dev, &rgb->output);\r\nif (err < 0) {\r\ndev_err(dc->dev, "output setup failed: %d\n", err);\r\nreturn err;\r\n}\r\nrgb->output.encoder.possible_crtcs = drm_crtc_mask(&dc->base);\r\nreturn 0;\r\n}\r\nint tegra_dc_rgb_exit(struct tegra_dc *dc)\r\n{\r\nif (dc->rgb) {\r\nint err;\r\nerr = tegra_output_disable(dc->rgb);\r\nif (err < 0) {\r\ndev_err(dc->dev, "output failed to disable: %d\n", err);\r\nreturn err;\r\n}\r\nerr = tegra_output_exit(dc->rgb);\r\nif (err < 0) {\r\ndev_err(dc->dev, "output cleanup failed: %d\n", err);\r\nreturn err;\r\n}\r\ndc->rgb = NULL;\r\n}\r\nreturn 0;\r\n}
