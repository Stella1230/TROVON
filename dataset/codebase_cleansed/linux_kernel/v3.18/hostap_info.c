static void prism2_info_commtallies16(local_info_t *local, unsigned char *buf,\r\nint left)\r\n{\r\nstruct hfa384x_comm_tallies *tallies;\r\nif (left < sizeof(struct hfa384x_comm_tallies)) {\r\nprintk(KERN_DEBUG "%s: too short (len=%d) commtallies "\r\n"info frame\n", local->dev->name, left);\r\nreturn;\r\n}\r\ntallies = (struct hfa384x_comm_tallies *) buf;\r\n#define ADD_COMM_TALLIES(name) \\r\nlocal->comm_tallies.name += le16_to_cpu(tallies->name)\r\nADD_COMM_TALLIES(tx_unicast_frames);\r\nADD_COMM_TALLIES(tx_multicast_frames);\r\nADD_COMM_TALLIES(tx_fragments);\r\nADD_COMM_TALLIES(tx_unicast_octets);\r\nADD_COMM_TALLIES(tx_multicast_octets);\r\nADD_COMM_TALLIES(tx_deferred_transmissions);\r\nADD_COMM_TALLIES(tx_single_retry_frames);\r\nADD_COMM_TALLIES(tx_multiple_retry_frames);\r\nADD_COMM_TALLIES(tx_retry_limit_exceeded);\r\nADD_COMM_TALLIES(tx_discards);\r\nADD_COMM_TALLIES(rx_unicast_frames);\r\nADD_COMM_TALLIES(rx_multicast_frames);\r\nADD_COMM_TALLIES(rx_fragments);\r\nADD_COMM_TALLIES(rx_unicast_octets);\r\nADD_COMM_TALLIES(rx_multicast_octets);\r\nADD_COMM_TALLIES(rx_fcs_errors);\r\nADD_COMM_TALLIES(rx_discards_no_buffer);\r\nADD_COMM_TALLIES(tx_discards_wrong_sa);\r\nADD_COMM_TALLIES(rx_discards_wep_undecryptable);\r\nADD_COMM_TALLIES(rx_message_in_msg_fragments);\r\nADD_COMM_TALLIES(rx_message_in_bad_msg_fragments);\r\n#undef ADD_COMM_TALLIES\r\n}\r\nstatic void prism2_info_commtallies32(local_info_t *local, unsigned char *buf,\r\nint left)\r\n{\r\nstruct hfa384x_comm_tallies32 *tallies;\r\nif (left < sizeof(struct hfa384x_comm_tallies32)) {\r\nprintk(KERN_DEBUG "%s: too short (len=%d) commtallies32 "\r\n"info frame\n", local->dev->name, left);\r\nreturn;\r\n}\r\ntallies = (struct hfa384x_comm_tallies32 *) buf;\r\n#define ADD_COMM_TALLIES(name) \\r\nlocal->comm_tallies.name += le32_to_cpu(tallies->name)\r\nADD_COMM_TALLIES(tx_unicast_frames);\r\nADD_COMM_TALLIES(tx_multicast_frames);\r\nADD_COMM_TALLIES(tx_fragments);\r\nADD_COMM_TALLIES(tx_unicast_octets);\r\nADD_COMM_TALLIES(tx_multicast_octets);\r\nADD_COMM_TALLIES(tx_deferred_transmissions);\r\nADD_COMM_TALLIES(tx_single_retry_frames);\r\nADD_COMM_TALLIES(tx_multiple_retry_frames);\r\nADD_COMM_TALLIES(tx_retry_limit_exceeded);\r\nADD_COMM_TALLIES(tx_discards);\r\nADD_COMM_TALLIES(rx_unicast_frames);\r\nADD_COMM_TALLIES(rx_multicast_frames);\r\nADD_COMM_TALLIES(rx_fragments);\r\nADD_COMM_TALLIES(rx_unicast_octets);\r\nADD_COMM_TALLIES(rx_multicast_octets);\r\nADD_COMM_TALLIES(rx_fcs_errors);\r\nADD_COMM_TALLIES(rx_discards_no_buffer);\r\nADD_COMM_TALLIES(tx_discards_wrong_sa);\r\nADD_COMM_TALLIES(rx_discards_wep_undecryptable);\r\nADD_COMM_TALLIES(rx_message_in_msg_fragments);\r\nADD_COMM_TALLIES(rx_message_in_bad_msg_fragments);\r\n#undef ADD_COMM_TALLIES\r\n}\r\nstatic void prism2_info_commtallies(local_info_t *local, unsigned char *buf,\r\nint left)\r\n{\r\nif (local->tallies32)\r\nprism2_info_commtallies32(local, buf, left);\r\nelse\r\nprism2_info_commtallies16(local, buf, left);\r\n}\r\nstatic const char* hfa384x_linkstatus_str(u16 linkstatus)\r\n{\r\nswitch (linkstatus) {\r\ncase HFA384X_LINKSTATUS_CONNECTED:\r\nreturn "Connected";\r\ncase HFA384X_LINKSTATUS_DISCONNECTED:\r\nreturn "Disconnected";\r\ncase HFA384X_LINKSTATUS_AP_CHANGE:\r\nreturn "Access point change";\r\ncase HFA384X_LINKSTATUS_AP_OUT_OF_RANGE:\r\nreturn "Access point out of range";\r\ncase HFA384X_LINKSTATUS_AP_IN_RANGE:\r\nreturn "Access point in range";\r\ncase HFA384X_LINKSTATUS_ASSOC_FAILED:\r\nreturn "Association failed";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nstatic void prism2_info_linkstatus(local_info_t *local, unsigned char *buf,\r\nint left)\r\n{\r\nu16 val;\r\nint non_sta_mode;\r\nlocal->last_join_time = 0;\r\nif (left != 2) {\r\nprintk(KERN_DEBUG "%s: invalid linkstatus info frame "\r\n"length %d\n", local->dev->name, left);\r\nreturn;\r\n}\r\nnon_sta_mode = local->iw_mode == IW_MODE_MASTER ||\r\nlocal->iw_mode == IW_MODE_REPEAT ||\r\nlocal->iw_mode == IW_MODE_MONITOR;\r\nval = buf[0] | (buf[1] << 8);\r\nif (!non_sta_mode || val != HFA384X_LINKSTATUS_DISCONNECTED) {\r\nPDEBUG(DEBUG_EXTRA, "%s: LinkStatus=%d (%s)\n",\r\nlocal->dev->name, val, hfa384x_linkstatus_str(val));\r\n}\r\nif (non_sta_mode) {\r\nnetif_carrier_on(local->dev);\r\nnetif_carrier_on(local->ddev);\r\nreturn;\r\n}\r\nset_bit(PRISM2_INFO_PENDING_LINKSTATUS, &local->pending_info);\r\nlocal->prev_link_status = val;\r\nschedule_work(&local->info_queue);\r\n}\r\nstatic void prism2_host_roaming(local_info_t *local)\r\n{\r\nstruct hfa384x_join_request req;\r\nstruct net_device *dev = local->dev;\r\nstruct hfa384x_hostscan_result *selected, *entry;\r\nint i;\r\nunsigned long flags;\r\nif (local->last_join_time &&\r\ntime_before(jiffies, local->last_join_time + 10 * HZ)) {\r\nPDEBUG(DEBUG_EXTRA, "%s: last join request has not yet been "\r\n"completed - waiting for it before issuing new one\n",\r\ndev->name);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&local->lock, flags);\r\nif (local->last_scan_results == NULL ||\r\nlocal->last_scan_results_count == 0) {\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nPDEBUG(DEBUG_EXTRA, "%s: no scan results for host roaming\n",\r\ndev->name);\r\nreturn;\r\n}\r\nselected = &local->last_scan_results[0];\r\nif (local->preferred_ap[0] || local->preferred_ap[1] ||\r\nlocal->preferred_ap[2] || local->preferred_ap[3] ||\r\nlocal->preferred_ap[4] || local->preferred_ap[5]) {\r\nPDEBUG(DEBUG_EXTRA, "%s: Preferred AP BSSID %pM\n",\r\ndev->name, local->preferred_ap);\r\nfor (i = 0; i < local->last_scan_results_count; i++) {\r\nentry = &local->last_scan_results[i];\r\nif (memcmp(local->preferred_ap, entry->bssid, 6) == 0)\r\n{\r\nPDEBUG(DEBUG_EXTRA, "%s: using preferred AP "\r\n"selection\n", dev->name);\r\nselected = entry;\r\nbreak;\r\n}\r\n}\r\n}\r\nmemcpy(req.bssid, selected->bssid, ETH_ALEN);\r\nreq.channel = selected->chid;\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nPDEBUG(DEBUG_EXTRA, "%s: JoinRequest: BSSID=%pM"\r\n" channel=%d\n",\r\ndev->name, req.bssid, le16_to_cpu(req.channel));\r\nif (local->func->set_rid(dev, HFA384X_RID_JOINREQUEST, &req,\r\nsizeof(req))) {\r\nprintk(KERN_DEBUG "%s: JoinRequest failed\n", dev->name);\r\n}\r\nlocal->last_join_time = jiffies;\r\n}\r\nstatic void hostap_report_scan_complete(local_info_t *local)\r\n{\r\nunion iwreq_data wrqu;\r\nwrqu.data.length = 0;\r\nwrqu.data.flags = 0;\r\nwireless_send_event(local->dev, SIOCGIWSCAN, &wrqu, NULL);\r\nlocal->scan_timestamp = 0;\r\n}\r\nstatic void prism2_info_scanresults(local_info_t *local, unsigned char *buf,\r\nint left)\r\n{\r\nu16 *pos;\r\nint new_count, i;\r\nunsigned long flags;\r\nstruct hfa384x_scan_result *res;\r\nstruct hfa384x_hostscan_result *results, *prev;\r\nif (left < 4) {\r\nprintk(KERN_DEBUG "%s: invalid scanresult info frame "\r\n"length %d\n", local->dev->name, left);\r\nreturn;\r\n}\r\npos = (u16 *) buf;\r\npos++;\r\npos++;\r\nleft -= 4;\r\nnew_count = left / sizeof(struct hfa384x_scan_result);\r\nresults = kmalloc(new_count * sizeof(struct hfa384x_hostscan_result),\r\nGFP_ATOMIC);\r\nif (results == NULL)\r\nreturn;\r\nres = (struct hfa384x_scan_result *) pos;\r\nfor (i = 0; i < new_count; i++) {\r\nmemcpy(&results[i], &res[i],\r\nsizeof(struct hfa384x_scan_result));\r\nresults[i].atim = 0;\r\n}\r\nspin_lock_irqsave(&local->lock, flags);\r\nlocal->last_scan_type = PRISM2_SCAN;\r\nprev = local->last_scan_results;\r\nlocal->last_scan_results = results;\r\nlocal->last_scan_results_count = new_count;\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nkfree(prev);\r\nhostap_report_scan_complete(local);\r\nset_bit(PRISM2_INFO_PENDING_SCANRESULTS, &local->pending_info);\r\nschedule_work(&local->info_queue);\r\n}\r\nstatic void prism2_info_hostscanresults(local_info_t *local,\r\nunsigned char *buf, int left)\r\n{\r\nint i, result_size, copy_len, new_count;\r\nstruct hfa384x_hostscan_result *results, *prev;\r\nunsigned long flags;\r\n__le16 *pos;\r\nu8 *ptr;\r\nwake_up_interruptible(&local->hostscan_wq);\r\nif (left < 4) {\r\nprintk(KERN_DEBUG "%s: invalid hostscanresult info frame "\r\n"length %d\n", local->dev->name, left);\r\nreturn;\r\n}\r\npos = (__le16 *) buf;\r\ncopy_len = result_size = le16_to_cpu(*pos);\r\nif (result_size == 0) {\r\nprintk(KERN_DEBUG "%s: invalid result_size (0) in "\r\n"hostscanresults\n", local->dev->name);\r\nreturn;\r\n}\r\nif (copy_len > sizeof(struct hfa384x_hostscan_result))\r\ncopy_len = sizeof(struct hfa384x_hostscan_result);\r\npos++;\r\npos++;\r\nleft -= 4;\r\nptr = (u8 *) pos;\r\nnew_count = left / result_size;\r\nresults = kcalloc(new_count, sizeof(struct hfa384x_hostscan_result),\r\nGFP_ATOMIC);\r\nif (results == NULL)\r\nreturn;\r\nfor (i = 0; i < new_count; i++) {\r\nmemcpy(&results[i], ptr, copy_len);\r\nptr += result_size;\r\nleft -= result_size;\r\n}\r\nif (left) {\r\nprintk(KERN_DEBUG "%s: short HostScan result entry (%d/%d)\n",\r\nlocal->dev->name, left, result_size);\r\n}\r\nspin_lock_irqsave(&local->lock, flags);\r\nlocal->last_scan_type = PRISM2_HOSTSCAN;\r\nprev = local->last_scan_results;\r\nlocal->last_scan_results = results;\r\nlocal->last_scan_results_count = new_count;\r\nspin_unlock_irqrestore(&local->lock, flags);\r\nkfree(prev);\r\nhostap_report_scan_complete(local);\r\n}\r\nvoid hostap_info_process(local_info_t *local, struct sk_buff *skb)\r\n{\r\nstruct hfa384x_info_frame *info;\r\nunsigned char *buf;\r\nint left;\r\n#ifndef PRISM2_NO_DEBUG\r\nint i;\r\n#endif\r\ninfo = (struct hfa384x_info_frame *) skb->data;\r\nbuf = skb->data + sizeof(*info);\r\nleft = skb->len - sizeof(*info);\r\nswitch (le16_to_cpu(info->type)) {\r\ncase HFA384X_INFO_COMMTALLIES:\r\nprism2_info_commtallies(local, buf, left);\r\nbreak;\r\n#ifndef PRISM2_NO_STATION_MODES\r\ncase HFA384X_INFO_LINKSTATUS:\r\nprism2_info_linkstatus(local, buf, left);\r\nbreak;\r\ncase HFA384X_INFO_SCANRESULTS:\r\nprism2_info_scanresults(local, buf, left);\r\nbreak;\r\ncase HFA384X_INFO_HOSTSCANRESULTS:\r\nprism2_info_hostscanresults(local, buf, left);\r\nbreak;\r\n#endif\r\n#ifndef PRISM2_NO_DEBUG\r\ndefault:\r\nPDEBUG(DEBUG_EXTRA, "%s: INFO - len=%d type=0x%04x\n",\r\nlocal->dev->name, le16_to_cpu(info->len),\r\nle16_to_cpu(info->type));\r\nPDEBUG(DEBUG_EXTRA, "Unknown info frame:");\r\nfor (i = 0; i < (left < 100 ? left : 100); i++)\r\nPDEBUG2(DEBUG_EXTRA, " %02x", buf[i]);\r\nPDEBUG2(DEBUG_EXTRA, "\n");\r\nbreak;\r\n#endif\r\n}\r\n}\r\nstatic void handle_info_queue_linkstatus(local_info_t *local)\r\n{\r\nint val = local->prev_link_status;\r\nint connected;\r\nunion iwreq_data wrqu;\r\nconnected =\r\nval == HFA384X_LINKSTATUS_CONNECTED ||\r\nval == HFA384X_LINKSTATUS_AP_CHANGE ||\r\nval == HFA384X_LINKSTATUS_AP_IN_RANGE;\r\nif (local->func->get_rid(local->dev, HFA384X_RID_CURRENTBSSID,\r\nlocal->bssid, ETH_ALEN, 1) < 0) {\r\nprintk(KERN_DEBUG "%s: could not read CURRENTBSSID after "\r\n"LinkStatus event\n", local->dev->name);\r\n} else {\r\nPDEBUG(DEBUG_EXTRA, "%s: LinkStatus: BSSID=%pM\n",\r\nlocal->dev->name,\r\n(unsigned char *) local->bssid);\r\nif (local->wds_type & HOSTAP_WDS_AP_CLIENT)\r\nhostap_add_sta(local->ap, local->bssid);\r\n}\r\nif (connected) {\r\nnetif_carrier_on(local->dev);\r\nnetif_carrier_on(local->ddev);\r\nmemcpy(wrqu.ap_addr.sa_data, local->bssid, ETH_ALEN);\r\n} else {\r\nnetif_carrier_off(local->dev);\r\nnetif_carrier_off(local->ddev);\r\nmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\r\n}\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nif (connected || local->prev_linkstatus_connected)\r\nwireless_send_event(local->dev, SIOCGIWAP, &wrqu, NULL);\r\nlocal->prev_linkstatus_connected = connected;\r\n}\r\nstatic void handle_info_queue_scanresults(local_info_t *local)\r\n{\r\nif (local->host_roaming == 1 && local->iw_mode == IW_MODE_INFRA)\r\nprism2_host_roaming(local);\r\nif (local->host_roaming == 2 && local->iw_mode == IW_MODE_INFRA &&\r\n!is_zero_ether_addr(local->preferred_ap)) {\r\nprism2_host_roaming(local);\r\n}\r\n}\r\nstatic void handle_info_queue(struct work_struct *work)\r\n{\r\nlocal_info_t *local = container_of(work, local_info_t, info_queue);\r\nif (test_and_clear_bit(PRISM2_INFO_PENDING_LINKSTATUS,\r\n&local->pending_info))\r\nhandle_info_queue_linkstatus(local);\r\nif (test_and_clear_bit(PRISM2_INFO_PENDING_SCANRESULTS,\r\n&local->pending_info))\r\nhandle_info_queue_scanresults(local);\r\n}\r\nvoid hostap_info_init(local_info_t *local)\r\n{\r\nskb_queue_head_init(&local->info_list);\r\n#ifndef PRISM2_NO_STATION_MODES\r\nINIT_WORK(&local->info_queue, handle_info_queue);\r\n#endif\r\n}
