static int kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,\r\nstruct kvm *kvm, int irq_source_id, int level,\r\nbool line_status)\r\n{\r\n#ifdef CONFIG_X86\r\nstruct kvm_pic *pic = pic_irqchip(kvm);\r\nreturn kvm_pic_set_irq(pic, e->irqchip.pin, irq_source_id, level);\r\n#else\r\nreturn -1;\r\n#endif\r\n}\r\nstatic int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,\r\nstruct kvm *kvm, int irq_source_id, int level,\r\nbool line_status)\r\n{\r\nstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\r\nreturn kvm_ioapic_set_irq(ioapic, e->irqchip.pin, irq_source_id, level,\r\nline_status);\r\n}\r\ninline static bool kvm_is_dm_lowest_prio(struct kvm_lapic_irq *irq)\r\n{\r\n#ifdef CONFIG_IA64\r\nreturn irq->delivery_mode ==\r\n(IOSAPIC_LOWEST_PRIORITY << IOSAPIC_DELIVERY_SHIFT);\r\n#else\r\nreturn irq->delivery_mode == APIC_DM_LOWEST;\r\n#endif\r\n}\r\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\r\nstruct kvm_lapic_irq *irq, unsigned long *dest_map)\r\n{\r\nint i, r = -1;\r\nstruct kvm_vcpu *vcpu, *lowest = NULL;\r\nif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\r\nkvm_is_dm_lowest_prio(irq)) {\r\nprintk(KERN_INFO "kvm: apic: phys broadcast and lowest prio\n");\r\nirq->delivery_mode = APIC_DM_FIXED;\r\n}\r\nif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\r\nreturn r;\r\nkvm_for_each_vcpu(i, vcpu, kvm) {\r\nif (!kvm_apic_present(vcpu))\r\ncontinue;\r\nif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\r\nirq->dest_id, irq->dest_mode))\r\ncontinue;\r\nif (!kvm_is_dm_lowest_prio(irq)) {\r\nif (r < 0)\r\nr = 0;\r\nr += kvm_apic_set_irq(vcpu, irq, dest_map);\r\n} else if (kvm_lapic_enabled(vcpu)) {\r\nif (!lowest)\r\nlowest = vcpu;\r\nelse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\r\nlowest = vcpu;\r\n}\r\n}\r\nif (lowest)\r\nr = kvm_apic_set_irq(lowest, irq, dest_map);\r\nreturn r;\r\n}\r\nstatic inline void kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,\r\nstruct kvm_lapic_irq *irq)\r\n{\r\ntrace_kvm_msi_set_irq(e->msi.address_lo, e->msi.data);\r\nirq->dest_id = (e->msi.address_lo &\r\nMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\r\nirq->vector = (e->msi.data &\r\nMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\r\nirq->dest_mode = (1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo;\r\nirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\r\nirq->delivery_mode = e->msi.data & 0x700;\r\nirq->level = 1;\r\nirq->shorthand = 0;\r\n}\r\nint kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,\r\nstruct kvm *kvm, int irq_source_id, int level, bool line_status)\r\n{\r\nstruct kvm_lapic_irq irq;\r\nif (!level)\r\nreturn -1;\r\nkvm_set_msi_irq(e, &irq);\r\nreturn kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);\r\n}\r\nstatic int kvm_set_msi_inatomic(struct kvm_kernel_irq_routing_entry *e,\r\nstruct kvm *kvm)\r\n{\r\nstruct kvm_lapic_irq irq;\r\nint r;\r\nkvm_set_msi_irq(e, &irq);\r\nif (kvm_irq_delivery_to_apic_fast(kvm, NULL, &irq, &r, NULL))\r\nreturn r;\r\nelse\r\nreturn -EWOULDBLOCK;\r\n}\r\nint kvm_set_irq_inatomic(struct kvm *kvm, int irq_source_id, u32 irq, int level)\r\n{\r\nstruct kvm_kernel_irq_routing_entry entries[KVM_NR_IRQCHIPS];\r\nstruct kvm_kernel_irq_routing_entry *e;\r\nint ret = -EINVAL;\r\nint idx;\r\ntrace_kvm_set_irq(irq, level, irq_source_id);\r\nidx = srcu_read_lock(&kvm->irq_srcu);\r\nif (kvm_irq_map_gsi(kvm, entries, irq) > 0) {\r\ne = &entries[0];\r\nif (likely(e->type == KVM_IRQ_ROUTING_MSI))\r\nret = kvm_set_msi_inatomic(e, kvm);\r\nelse\r\nret = -EWOULDBLOCK;\r\n}\r\nsrcu_read_unlock(&kvm->irq_srcu, idx);\r\nreturn ret;\r\n}\r\nint kvm_request_irq_source_id(struct kvm *kvm)\r\n{\r\nunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\r\nint irq_source_id;\r\nmutex_lock(&kvm->irq_lock);\r\nirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\r\nif (irq_source_id >= BITS_PER_LONG) {\r\nprintk(KERN_WARNING "kvm: exhaust allocatable IRQ sources!\n");\r\nirq_source_id = -EFAULT;\r\ngoto unlock;\r\n}\r\nASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\r\n#ifdef CONFIG_X86\r\nASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\r\n#endif\r\nset_bit(irq_source_id, bitmap);\r\nunlock:\r\nmutex_unlock(&kvm->irq_lock);\r\nreturn irq_source_id;\r\n}\r\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\r\n{\r\nASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\r\n#ifdef CONFIG_X86\r\nASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\r\n#endif\r\nmutex_lock(&kvm->irq_lock);\r\nif (irq_source_id < 0 ||\r\nirq_source_id >= BITS_PER_LONG) {\r\nprintk(KERN_ERR "kvm: IRQ source ID out of range!\n");\r\ngoto unlock;\r\n}\r\nclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\r\nif (!irqchip_in_kernel(kvm))\r\ngoto unlock;\r\nkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\r\n#ifdef CONFIG_X86\r\nkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\r\n#endif\r\nunlock:\r\nmutex_unlock(&kvm->irq_lock);\r\n}\r\nvoid kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\r\nstruct kvm_irq_mask_notifier *kimn)\r\n{\r\nmutex_lock(&kvm->irq_lock);\r\nkimn->irq = irq;\r\nhlist_add_head_rcu(&kimn->link, &kvm->mask_notifier_list);\r\nmutex_unlock(&kvm->irq_lock);\r\n}\r\nvoid kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\r\nstruct kvm_irq_mask_notifier *kimn)\r\n{\r\nmutex_lock(&kvm->irq_lock);\r\nhlist_del_rcu(&kimn->link);\r\nmutex_unlock(&kvm->irq_lock);\r\nsynchronize_srcu(&kvm->irq_srcu);\r\n}\r\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\r\nbool mask)\r\n{\r\nstruct kvm_irq_mask_notifier *kimn;\r\nint idx, gsi;\r\nidx = srcu_read_lock(&kvm->irq_srcu);\r\ngsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\r\nif (gsi != -1)\r\nhlist_for_each_entry_rcu(kimn, &kvm->mask_notifier_list, link)\r\nif (kimn->irq == gsi)\r\nkimn->func(kimn, mask);\r\nsrcu_read_unlock(&kvm->irq_srcu, idx);\r\n}\r\nint kvm_set_routing_entry(struct kvm_kernel_irq_routing_entry *e,\r\nconst struct kvm_irq_routing_entry *ue)\r\n{\r\nint r = -EINVAL;\r\nint delta;\r\nunsigned max_pin;\r\nswitch (ue->type) {\r\ncase KVM_IRQ_ROUTING_IRQCHIP:\r\ndelta = 0;\r\nswitch (ue->u.irqchip.irqchip) {\r\ncase KVM_IRQCHIP_PIC_MASTER:\r\ne->set = kvm_set_pic_irq;\r\nmax_pin = PIC_NUM_PINS;\r\nbreak;\r\ncase KVM_IRQCHIP_PIC_SLAVE:\r\ne->set = kvm_set_pic_irq;\r\nmax_pin = PIC_NUM_PINS;\r\ndelta = 8;\r\nbreak;\r\ncase KVM_IRQCHIP_IOAPIC:\r\nmax_pin = KVM_IOAPIC_NUM_PINS;\r\ne->set = kvm_set_ioapic_irq;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\ne->irqchip.irqchip = ue->u.irqchip.irqchip;\r\ne->irqchip.pin = ue->u.irqchip.pin + delta;\r\nif (e->irqchip.pin >= max_pin)\r\ngoto out;\r\nbreak;\r\ncase KVM_IRQ_ROUTING_MSI:\r\ne->set = kvm_set_msi;\r\ne->msi.address_lo = ue->u.msi.address_lo;\r\ne->msi.address_hi = ue->u.msi.address_hi;\r\ne->msi.data = ue->u.msi.data;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nr = 0;\r\nout:\r\nreturn r;\r\n}\r\nint kvm_setup_default_irq_routing(struct kvm *kvm)\r\n{\r\nreturn kvm_set_irq_routing(kvm, default_routing,\r\nARRAY_SIZE(default_routing), 0);\r\n}
