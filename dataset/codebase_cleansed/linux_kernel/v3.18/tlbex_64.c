static int handle_tlbmiss(unsigned long long protection_flags,\r\nunsigned long address)\r\n{\r\npgd_t *pgd;\r\npud_t *pud;\r\npmd_t *pmd;\r\npte_t *pte;\r\npte_t entry;\r\nif (is_vmalloc_addr((void *)address)) {\r\npgd = pgd_offset_k(address);\r\n} else {\r\nif (unlikely(address >= TASK_SIZE || !current->mm))\r\nreturn 1;\r\npgd = pgd_offset(current->mm, address);\r\n}\r\npud = pud_offset(pgd, address);\r\nif (pud_none(*pud) || !pud_present(*pud))\r\nreturn 1;\r\npmd = pmd_offset(pud, address);\r\nif (pmd_none(*pmd) || !pmd_present(*pmd))\r\nreturn 1;\r\npte = pte_offset_kernel(pmd, address);\r\nentry = *pte;\r\nif (pte_none(entry) || !pte_present(entry))\r\nreturn 1;\r\nif ((pte_val(entry) & protection_flags) != protection_flags)\r\nreturn 1;\r\nupdate_mmu_cache(NULL, address, pte);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int\r\nexpevt_to_fault_code(unsigned long expevt)\r\n{\r\nif (expevt == 0xa40)\r\nreturn FAULT_CODE_ITLB;\r\nelse if (expevt == 0x060)\r\nreturn FAULT_CODE_WRITE;\r\nreturn 0;\r\n}\r\nasmlinkage int __kprobes\r\ndo_fast_page_fault(unsigned long long ssr_md, unsigned long long expevt,\r\nunsigned long address)\r\n{\r\nunsigned long long protection_flags;\r\nunsigned long long index;\r\nunsigned long long expevt4;\r\nunsigned int fault_code;\r\nexpevt4 = (expevt >> 4);\r\nindex = expevt4 ^ (expevt4 >> 5);\r\nindex &= 7;\r\nfault_code = expevt_to_fault_code(expevt);\r\nprotection_flags = expevt_lookup_table.protection_flags[index];\r\nif (expevt_lookup_table.is_text_access[index])\r\nfault_code |= FAULT_CODE_ITLB;\r\nif (!ssr_md)\r\nfault_code |= FAULT_CODE_USER;\r\nset_thread_fault_code(fault_code);\r\nreturn handle_tlbmiss(protection_flags, address);\r\n}
