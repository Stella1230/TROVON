static void zfcp_erp_adapter_block(struct zfcp_adapter *adapter, int mask)\r\n{\r\nzfcp_erp_clear_adapter_status(adapter,\r\nZFCP_STATUS_COMMON_UNBLOCKED | mask);\r\n}\r\nstatic int zfcp_erp_action_exists(struct zfcp_erp_action *act)\r\n{\r\nstruct zfcp_erp_action *curr_act;\r\nlist_for_each_entry(curr_act, &act->adapter->erp_running_head, list)\r\nif (act == curr_act)\r\nreturn ZFCP_ERP_ACTION_RUNNING;\r\nreturn 0;\r\n}\r\nstatic void zfcp_erp_action_ready(struct zfcp_erp_action *act)\r\n{\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nlist_move(&act->list, &act->adapter->erp_ready_head);\r\nzfcp_dbf_rec_run("erardy1", act);\r\nwake_up(&adapter->erp_ready_wq);\r\nzfcp_dbf_rec_run("erardy2", act);\r\n}\r\nstatic void zfcp_erp_action_dismiss(struct zfcp_erp_action *act)\r\n{\r\nact->status |= ZFCP_STATUS_ERP_DISMISSED;\r\nif (zfcp_erp_action_exists(act) == ZFCP_ERP_ACTION_RUNNING)\r\nzfcp_erp_action_ready(act);\r\n}\r\nstatic void zfcp_erp_action_dismiss_lun(struct scsi_device *sdev)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_ERP_INUSE)\r\nzfcp_erp_action_dismiss(&zfcp_sdev->erp_action);\r\n}\r\nstatic void zfcp_erp_action_dismiss_port(struct zfcp_port *port)\r\n{\r\nstruct scsi_device *sdev;\r\nif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_INUSE)\r\nzfcp_erp_action_dismiss(&port->erp_action);\r\nelse {\r\nspin_lock(port->adapter->scsi_host->host_lock);\r\n__shost_for_each_device(sdev, port->adapter->scsi_host)\r\nif (sdev_to_zfcp(sdev)->port == port)\r\nzfcp_erp_action_dismiss_lun(sdev);\r\nspin_unlock(port->adapter->scsi_host->host_lock);\r\n}\r\n}\r\nstatic void zfcp_erp_action_dismiss_adapter(struct zfcp_adapter *adapter)\r\n{\r\nstruct zfcp_port *port;\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_ERP_INUSE)\r\nzfcp_erp_action_dismiss(&adapter->erp_action);\r\nelse {\r\nread_lock(&adapter->port_list_lock);\r\nlist_for_each_entry(port, &adapter->port_list, list)\r\nzfcp_erp_action_dismiss_port(port);\r\nread_unlock(&adapter->port_list_lock);\r\n}\r\n}\r\nstatic int zfcp_erp_required_act(int want, struct zfcp_adapter *adapter,\r\nstruct zfcp_port *port,\r\nstruct scsi_device *sdev)\r\n{\r\nint need = want;\r\nint l_status, p_status, a_status;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nswitch (want) {\r\ncase ZFCP_ERP_ACTION_REOPEN_LUN:\r\nzfcp_sdev = sdev_to_zfcp(sdev);\r\nl_status = atomic_read(&zfcp_sdev->status);\r\nif (l_status & ZFCP_STATUS_COMMON_ERP_INUSE)\r\nreturn 0;\r\np_status = atomic_read(&port->status);\r\nif (!(p_status & ZFCP_STATUS_COMMON_RUNNING) ||\r\np_status & ZFCP_STATUS_COMMON_ERP_FAILED)\r\nreturn 0;\r\nif (!(p_status & ZFCP_STATUS_COMMON_UNBLOCKED))\r\nneed = ZFCP_ERP_ACTION_REOPEN_PORT;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\np_status = atomic_read(&port->status);\r\nif (!(p_status & ZFCP_STATUS_COMMON_OPEN))\r\nneed = ZFCP_ERP_ACTION_REOPEN_PORT;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\np_status = atomic_read(&port->status);\r\nif (p_status & ZFCP_STATUS_COMMON_ERP_INUSE)\r\nreturn 0;\r\na_status = atomic_read(&adapter->status);\r\nif (!(a_status & ZFCP_STATUS_COMMON_RUNNING) ||\r\na_status & ZFCP_STATUS_COMMON_ERP_FAILED)\r\nreturn 0;\r\nif (p_status & ZFCP_STATUS_COMMON_NOESC)\r\nreturn need;\r\nif (!(a_status & ZFCP_STATUS_COMMON_UNBLOCKED))\r\nneed = ZFCP_ERP_ACTION_REOPEN_ADAPTER;\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\na_status = atomic_read(&adapter->status);\r\nif (a_status & ZFCP_STATUS_COMMON_ERP_INUSE)\r\nreturn 0;\r\nif (!(a_status & ZFCP_STATUS_COMMON_RUNNING) &&\r\n!(a_status & ZFCP_STATUS_COMMON_OPEN))\r\nreturn 0;\r\n}\r\nreturn need;\r\n}\r\nstatic struct zfcp_erp_action *zfcp_erp_setup_act(int need, u32 act_status,\r\nstruct zfcp_adapter *adapter,\r\nstruct zfcp_port *port,\r\nstruct scsi_device *sdev)\r\n{\r\nstruct zfcp_erp_action *erp_action;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nswitch (need) {\r\ncase ZFCP_ERP_ACTION_REOPEN_LUN:\r\nzfcp_sdev = sdev_to_zfcp(sdev);\r\nif (!(act_status & ZFCP_STATUS_ERP_NO_REF))\r\nif (scsi_device_get(sdev))\r\nreturn NULL;\r\natomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE,\r\n&zfcp_sdev->status);\r\nerp_action = &zfcp_sdev->erp_action;\r\nmemset(erp_action, 0, sizeof(struct zfcp_erp_action));\r\nerp_action->port = port;\r\nerp_action->sdev = sdev;\r\nif (!(atomic_read(&zfcp_sdev->status) &\r\nZFCP_STATUS_COMMON_RUNNING))\r\nact_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\nif (!get_device(&port->dev))\r\nreturn NULL;\r\nzfcp_erp_action_dismiss_port(port);\r\natomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE, &port->status);\r\nerp_action = &port->erp_action;\r\nmemset(erp_action, 0, sizeof(struct zfcp_erp_action));\r\nerp_action->port = port;\r\nif (!(atomic_read(&port->status) & ZFCP_STATUS_COMMON_RUNNING))\r\nact_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\nkref_get(&adapter->ref);\r\nzfcp_erp_action_dismiss_adapter(adapter);\r\natomic_set_mask(ZFCP_STATUS_COMMON_ERP_INUSE, &adapter->status);\r\nerp_action = &adapter->erp_action;\r\nmemset(erp_action, 0, sizeof(struct zfcp_erp_action));\r\nif (!(atomic_read(&adapter->status) &\r\nZFCP_STATUS_COMMON_RUNNING))\r\nact_status |= ZFCP_STATUS_ERP_CLOSE_ONLY;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nerp_action->adapter = adapter;\r\nerp_action->action = need;\r\nerp_action->status = act_status;\r\nreturn erp_action;\r\n}\r\nstatic int zfcp_erp_action_enqueue(int want, struct zfcp_adapter *adapter,\r\nstruct zfcp_port *port,\r\nstruct scsi_device *sdev,\r\nchar *id, u32 act_status)\r\n{\r\nint retval = 1, need;\r\nstruct zfcp_erp_action *act;\r\nif (!adapter->erp_thread)\r\nreturn -EIO;\r\nneed = zfcp_erp_required_act(want, adapter, port, sdev);\r\nif (!need)\r\ngoto out;\r\nact = zfcp_erp_setup_act(need, act_status, adapter, port, sdev);\r\nif (!act)\r\ngoto out;\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_ERP_PENDING, &adapter->status);\r\n++adapter->erp_total_count;\r\nlist_add_tail(&act->list, &adapter->erp_ready_head);\r\nwake_up(&adapter->erp_ready_wq);\r\nretval = 0;\r\nout:\r\nzfcp_dbf_rec_trig(id, adapter, port, sdev, want, need);\r\nreturn retval;\r\n}\r\nstatic int _zfcp_erp_adapter_reopen(struct zfcp_adapter *adapter,\r\nint clear_mask, char *id)\r\n{\r\nzfcp_erp_adapter_block(adapter, clear_mask);\r\nzfcp_scsi_schedule_rports_block(adapter);\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_ERP_FAILED) {\r\nzfcp_erp_set_adapter_status(adapter,\r\nZFCP_STATUS_COMMON_ERP_FAILED);\r\nreturn -EIO;\r\n}\r\nreturn zfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_ADAPTER,\r\nadapter, NULL, NULL, id, 0);\r\n}\r\nvoid zfcp_erp_adapter_reopen(struct zfcp_adapter *adapter, int clear, char *id)\r\n{\r\nunsigned long flags;\r\nzfcp_erp_adapter_block(adapter, clear);\r\nzfcp_scsi_schedule_rports_block(adapter);\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\r\nzfcp_erp_set_adapter_status(adapter,\r\nZFCP_STATUS_COMMON_ERP_FAILED);\r\nelse\r\nzfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_ADAPTER, adapter,\r\nNULL, NULL, id, 0);\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\n}\r\nvoid zfcp_erp_adapter_shutdown(struct zfcp_adapter *adapter, int clear,\r\nchar *id)\r\n{\r\nint flags = ZFCP_STATUS_COMMON_RUNNING | ZFCP_STATUS_COMMON_ERP_FAILED;\r\nzfcp_erp_adapter_reopen(adapter, clear | flags, id);\r\n}\r\nvoid zfcp_erp_port_shutdown(struct zfcp_port *port, int clear, char *id)\r\n{\r\nint flags = ZFCP_STATUS_COMMON_RUNNING | ZFCP_STATUS_COMMON_ERP_FAILED;\r\nzfcp_erp_port_reopen(port, clear | flags, id);\r\n}\r\nstatic void zfcp_erp_port_block(struct zfcp_port *port, int clear)\r\n{\r\nzfcp_erp_clear_port_status(port,\r\nZFCP_STATUS_COMMON_UNBLOCKED | clear);\r\n}\r\nstatic void _zfcp_erp_port_forced_reopen(struct zfcp_port *port, int clear,\r\nchar *id)\r\n{\r\nzfcp_erp_port_block(port, clear);\r\nzfcp_scsi_schedule_rport_block(port);\r\nif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\r\nreturn;\r\nzfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_PORT_FORCED,\r\nport->adapter, port, NULL, id, 0);\r\n}\r\nvoid zfcp_erp_port_forced_reopen(struct zfcp_port *port, int clear, char *id)\r\n{\r\nunsigned long flags;\r\nstruct zfcp_adapter *adapter = port->adapter;\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\n_zfcp_erp_port_forced_reopen(port, clear, id);\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\n}\r\nstatic int _zfcp_erp_port_reopen(struct zfcp_port *port, int clear, char *id)\r\n{\r\nzfcp_erp_port_block(port, clear);\r\nzfcp_scsi_schedule_rport_block(port);\r\nif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_FAILED) {\r\nzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_ERP_FAILED);\r\nreturn -EIO;\r\n}\r\nreturn zfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_PORT,\r\nport->adapter, port, NULL, id, 0);\r\n}\r\nint zfcp_erp_port_reopen(struct zfcp_port *port, int clear, char *id)\r\n{\r\nint retval;\r\nunsigned long flags;\r\nstruct zfcp_adapter *adapter = port->adapter;\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\nretval = _zfcp_erp_port_reopen(port, clear, id);\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\nreturn retval;\r\n}\r\nstatic void zfcp_erp_lun_block(struct scsi_device *sdev, int clear_mask)\r\n{\r\nzfcp_erp_clear_lun_status(sdev,\r\nZFCP_STATUS_COMMON_UNBLOCKED | clear_mask);\r\n}\r\nstatic void _zfcp_erp_lun_reopen(struct scsi_device *sdev, int clear, char *id,\r\nu32 act_status)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\r\nzfcp_erp_lun_block(sdev, clear);\r\nif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_ERP_FAILED)\r\nreturn;\r\nzfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_LUN, adapter,\r\nzfcp_sdev->port, sdev, id, act_status);\r\n}\r\nvoid zfcp_erp_lun_reopen(struct scsi_device *sdev, int clear, char *id)\r\n{\r\nunsigned long flags;\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nstruct zfcp_port *port = zfcp_sdev->port;\r\nstruct zfcp_adapter *adapter = port->adapter;\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\n_zfcp_erp_lun_reopen(sdev, clear, id, 0);\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\n}\r\nvoid zfcp_erp_lun_shutdown(struct scsi_device *sdev, int clear, char *id)\r\n{\r\nint flags = ZFCP_STATUS_COMMON_RUNNING | ZFCP_STATUS_COMMON_ERP_FAILED;\r\nzfcp_erp_lun_reopen(sdev, clear | flags, id);\r\n}\r\nvoid zfcp_erp_lun_shutdown_wait(struct scsi_device *sdev, char *id)\r\n{\r\nunsigned long flags;\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nstruct zfcp_port *port = zfcp_sdev->port;\r\nstruct zfcp_adapter *adapter = port->adapter;\r\nint clear = ZFCP_STATUS_COMMON_RUNNING | ZFCP_STATUS_COMMON_ERP_FAILED;\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\n_zfcp_erp_lun_reopen(sdev, clear, id, ZFCP_STATUS_ERP_NO_REF);\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\nzfcp_erp_wait(adapter);\r\n}\r\nstatic int status_change_set(unsigned long mask, atomic_t *status)\r\n{\r\nreturn (atomic_read(status) ^ mask) & mask;\r\n}\r\nstatic void zfcp_erp_adapter_unblock(struct zfcp_adapter *adapter)\r\n{\r\nif (status_change_set(ZFCP_STATUS_COMMON_UNBLOCKED, &adapter->status))\r\nzfcp_dbf_rec_run("eraubl1", &adapter->erp_action);\r\natomic_set_mask(ZFCP_STATUS_COMMON_UNBLOCKED, &adapter->status);\r\n}\r\nstatic void zfcp_erp_port_unblock(struct zfcp_port *port)\r\n{\r\nif (status_change_set(ZFCP_STATUS_COMMON_UNBLOCKED, &port->status))\r\nzfcp_dbf_rec_run("erpubl1", &port->erp_action);\r\natomic_set_mask(ZFCP_STATUS_COMMON_UNBLOCKED, &port->status);\r\n}\r\nstatic void zfcp_erp_lun_unblock(struct scsi_device *sdev)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nif (status_change_set(ZFCP_STATUS_COMMON_UNBLOCKED, &zfcp_sdev->status))\r\nzfcp_dbf_rec_run("erlubl1", &sdev_to_zfcp(sdev)->erp_action);\r\natomic_set_mask(ZFCP_STATUS_COMMON_UNBLOCKED, &zfcp_sdev->status);\r\n}\r\nstatic void zfcp_erp_action_to_running(struct zfcp_erp_action *erp_action)\r\n{\r\nlist_move(&erp_action->list, &erp_action->adapter->erp_running_head);\r\nzfcp_dbf_rec_run("erator1", erp_action);\r\n}\r\nstatic void zfcp_erp_strategy_check_fsfreq(struct zfcp_erp_action *act)\r\n{\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nstruct zfcp_fsf_req *req;\r\nif (!act->fsf_req_id)\r\nreturn;\r\nspin_lock(&adapter->req_list->lock);\r\nreq = _zfcp_reqlist_find(adapter->req_list, act->fsf_req_id);\r\nif (req && req->erp_action == act) {\r\nif (act->status & (ZFCP_STATUS_ERP_DISMISSED |\r\nZFCP_STATUS_ERP_TIMEDOUT)) {\r\nreq->status |= ZFCP_STATUS_FSFREQ_DISMISSED;\r\nzfcp_dbf_rec_run("erscf_1", act);\r\nreq->erp_action = NULL;\r\n}\r\nif (act->status & ZFCP_STATUS_ERP_TIMEDOUT)\r\nzfcp_dbf_rec_run("erscf_2", act);\r\nif (req->status & ZFCP_STATUS_FSFREQ_DISMISSED)\r\nact->fsf_req_id = 0;\r\n} else\r\nact->fsf_req_id = 0;\r\nspin_unlock(&adapter->req_list->lock);\r\n}\r\nvoid zfcp_erp_notify(struct zfcp_erp_action *erp_action, unsigned long set_mask)\r\n{\r\nstruct zfcp_adapter *adapter = erp_action->adapter;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\nif (zfcp_erp_action_exists(erp_action) == ZFCP_ERP_ACTION_RUNNING) {\r\nerp_action->status |= set_mask;\r\nzfcp_erp_action_ready(erp_action);\r\n}\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\n}\r\nvoid zfcp_erp_timeout_handler(unsigned long data)\r\n{\r\nstruct zfcp_erp_action *act = (struct zfcp_erp_action *) data;\r\nzfcp_erp_notify(act, ZFCP_STATUS_ERP_TIMEDOUT);\r\n}\r\nstatic void zfcp_erp_memwait_handler(unsigned long data)\r\n{\r\nzfcp_erp_notify((struct zfcp_erp_action *)data, 0);\r\n}\r\nstatic void zfcp_erp_strategy_memwait(struct zfcp_erp_action *erp_action)\r\n{\r\ninit_timer(&erp_action->timer);\r\nerp_action->timer.function = zfcp_erp_memwait_handler;\r\nerp_action->timer.data = (unsigned long) erp_action;\r\nerp_action->timer.expires = jiffies + HZ;\r\nadd_timer(&erp_action->timer);\r\n}\r\nstatic void _zfcp_erp_port_reopen_all(struct zfcp_adapter *adapter,\r\nint clear, char *id)\r\n{\r\nstruct zfcp_port *port;\r\nread_lock(&adapter->port_list_lock);\r\nlist_for_each_entry(port, &adapter->port_list, list)\r\n_zfcp_erp_port_reopen(port, clear, id);\r\nread_unlock(&adapter->port_list_lock);\r\n}\r\nstatic void _zfcp_erp_lun_reopen_all(struct zfcp_port *port, int clear,\r\nchar *id)\r\n{\r\nstruct scsi_device *sdev;\r\nspin_lock(port->adapter->scsi_host->host_lock);\r\n__shost_for_each_device(sdev, port->adapter->scsi_host)\r\nif (sdev_to_zfcp(sdev)->port == port)\r\n_zfcp_erp_lun_reopen(sdev, clear, id, 0);\r\nspin_unlock(port->adapter->scsi_host->host_lock);\r\n}\r\nstatic void zfcp_erp_strategy_followup_failed(struct zfcp_erp_action *act)\r\n{\r\nswitch (act->action) {\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\n_zfcp_erp_adapter_reopen(act->adapter, 0, "ersff_1");\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\n_zfcp_erp_port_forced_reopen(act->port, 0, "ersff_2");\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\n_zfcp_erp_port_reopen(act->port, 0, "ersff_3");\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_LUN:\r\n_zfcp_erp_lun_reopen(act->sdev, 0, "ersff_4", 0);\r\nbreak;\r\n}\r\n}\r\nstatic void zfcp_erp_strategy_followup_success(struct zfcp_erp_action *act)\r\n{\r\nswitch (act->action) {\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\n_zfcp_erp_port_reopen_all(act->adapter, 0, "ersfs_1");\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\n_zfcp_erp_port_reopen(act->port, 0, "ersfs_2");\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\n_zfcp_erp_lun_reopen_all(act->port, 0, "ersfs_3");\r\nbreak;\r\n}\r\n}\r\nstatic void zfcp_erp_wakeup(struct zfcp_adapter *adapter)\r\n{\r\nunsigned long flags;\r\nread_lock_irqsave(&adapter->erp_lock, flags);\r\nif (list_empty(&adapter->erp_ready_head) &&\r\nlist_empty(&adapter->erp_running_head)) {\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_ERP_PENDING,\r\n&adapter->status);\r\nwake_up(&adapter->erp_done_wqh);\r\n}\r\nread_unlock_irqrestore(&adapter->erp_lock, flags);\r\n}\r\nstatic void zfcp_erp_enqueue_ptp_port(struct zfcp_adapter *adapter)\r\n{\r\nstruct zfcp_port *port;\r\nport = zfcp_port_enqueue(adapter, adapter->peer_wwpn, 0,\r\nadapter->peer_d_id);\r\nif (IS_ERR(port))\r\nreturn;\r\n_zfcp_erp_port_reopen(port, 0, "ereptp1");\r\n}\r\nstatic int zfcp_erp_adapter_strat_fsf_xconf(struct zfcp_erp_action *erp_action)\r\n{\r\nint retries;\r\nint sleep = 1;\r\nstruct zfcp_adapter *adapter = erp_action->adapter;\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_XCONFIG_OK, &adapter->status);\r\nfor (retries = 7; retries; retries--) {\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,\r\n&adapter->status);\r\nwrite_lock_irq(&adapter->erp_lock);\r\nzfcp_erp_action_to_running(erp_action);\r\nwrite_unlock_irq(&adapter->erp_lock);\r\nif (zfcp_fsf_exchange_config_data(erp_action)) {\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,\r\n&adapter->status);\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\nwait_event(adapter->erp_ready_wq,\r\n!list_empty(&adapter->erp_ready_head));\r\nif (erp_action->status & ZFCP_STATUS_ERP_TIMEDOUT)\r\nbreak;\r\nif (!(atomic_read(&adapter->status) &\r\nZFCP_STATUS_ADAPTER_HOST_CON_INIT))\r\nbreak;\r\nssleep(sleep);\r\nsleep *= 2;\r\n}\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,\r\n&adapter->status);\r\nif (!(atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_XCONFIG_OK))\r\nreturn ZFCP_ERP_FAILED;\r\nif (fc_host_port_type(adapter->scsi_host) == FC_PORTTYPE_PTP)\r\nzfcp_erp_enqueue_ptp_port(adapter);\r\nreturn ZFCP_ERP_SUCCEEDED;\r\n}\r\nstatic int zfcp_erp_adapter_strategy_open_fsf_xport(struct zfcp_erp_action *act)\r\n{\r\nint ret;\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nwrite_lock_irq(&adapter->erp_lock);\r\nzfcp_erp_action_to_running(act);\r\nwrite_unlock_irq(&adapter->erp_lock);\r\nret = zfcp_fsf_exchange_port_data(act);\r\nif (ret == -EOPNOTSUPP)\r\nreturn ZFCP_ERP_SUCCEEDED;\r\nif (ret)\r\nreturn ZFCP_ERP_FAILED;\r\nzfcp_dbf_rec_run("erasox1", act);\r\nwait_event(adapter->erp_ready_wq,\r\n!list_empty(&adapter->erp_ready_head));\r\nzfcp_dbf_rec_run("erasox2", act);\r\nif (act->status & ZFCP_STATUS_ERP_TIMEDOUT)\r\nreturn ZFCP_ERP_FAILED;\r\nreturn ZFCP_ERP_SUCCEEDED;\r\n}\r\nstatic int zfcp_erp_adapter_strategy_open_fsf(struct zfcp_erp_action *act)\r\n{\r\nif (zfcp_erp_adapter_strat_fsf_xconf(act) == ZFCP_ERP_FAILED)\r\nreturn ZFCP_ERP_FAILED;\r\nif (zfcp_erp_adapter_strategy_open_fsf_xport(act) == ZFCP_ERP_FAILED)\r\nreturn ZFCP_ERP_FAILED;\r\nif (mempool_resize(act->adapter->pool.sr_data,\r\nact->adapter->stat_read_buf_num, GFP_KERNEL))\r\nreturn ZFCP_ERP_FAILED;\r\nif (mempool_resize(act->adapter->pool.status_read_req,\r\nact->adapter->stat_read_buf_num, GFP_KERNEL))\r\nreturn ZFCP_ERP_FAILED;\r\natomic_set(&act->adapter->stat_miss, act->adapter->stat_read_buf_num);\r\nif (zfcp_status_read_refill(act->adapter))\r\nreturn ZFCP_ERP_FAILED;\r\nreturn ZFCP_ERP_SUCCEEDED;\r\n}\r\nstatic void zfcp_erp_adapter_strategy_close(struct zfcp_erp_action *act)\r\n{\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nzfcp_qdio_close(adapter->qdio);\r\nzfcp_fsf_req_dismiss_all(adapter);\r\nadapter->fsf_req_seq_no = 0;\r\nzfcp_fc_wka_ports_force_offline(adapter->gs);\r\nzfcp_erp_clear_adapter_status(adapter, ZFCP_STATUS_COMMON_OPEN);\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_XCONFIG_OK |\r\nZFCP_STATUS_ADAPTER_LINK_UNPLUGGED, &adapter->status);\r\n}\r\nstatic int zfcp_erp_adapter_strategy_open(struct zfcp_erp_action *act)\r\n{\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nif (zfcp_qdio_open(adapter->qdio)) {\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_XCONFIG_OK |\r\nZFCP_STATUS_ADAPTER_LINK_UNPLUGGED,\r\n&adapter->status);\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\nif (zfcp_erp_adapter_strategy_open_fsf(act)) {\r\nzfcp_erp_adapter_strategy_close(act);\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\natomic_set_mask(ZFCP_STATUS_COMMON_OPEN, &adapter->status);\r\nreturn ZFCP_ERP_SUCCEEDED;\r\n}\r\nstatic int zfcp_erp_adapter_strategy(struct zfcp_erp_action *act)\r\n{\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_OPEN) {\r\nzfcp_erp_adapter_strategy_close(act);\r\nif (act->status & ZFCP_STATUS_ERP_CLOSE_ONLY)\r\nreturn ZFCP_ERP_EXIT;\r\n}\r\nif (zfcp_erp_adapter_strategy_open(act)) {\r\nssleep(8);\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\nreturn ZFCP_ERP_SUCCEEDED;\r\n}\r\nstatic int zfcp_erp_port_forced_strategy_close(struct zfcp_erp_action *act)\r\n{\r\nint retval;\r\nretval = zfcp_fsf_close_physical_port(act);\r\nif (retval == -ENOMEM)\r\nreturn ZFCP_ERP_NOMEM;\r\nact->step = ZFCP_ERP_STEP_PHYS_PORT_CLOSING;\r\nif (retval)\r\nreturn ZFCP_ERP_FAILED;\r\nreturn ZFCP_ERP_CONTINUES;\r\n}\r\nstatic void zfcp_erp_port_strategy_clearstati(struct zfcp_port *port)\r\n{\r\natomic_clear_mask(ZFCP_STATUS_COMMON_ACCESS_DENIED, &port->status);\r\n}\r\nstatic int zfcp_erp_port_forced_strategy(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_port *port = erp_action->port;\r\nint status = atomic_read(&port->status);\r\nswitch (erp_action->step) {\r\ncase ZFCP_ERP_STEP_UNINITIALIZED:\r\nzfcp_erp_port_strategy_clearstati(port);\r\nif ((status & ZFCP_STATUS_PORT_PHYS_OPEN) &&\r\n(status & ZFCP_STATUS_COMMON_OPEN))\r\nreturn zfcp_erp_port_forced_strategy_close(erp_action);\r\nelse\r\nreturn ZFCP_ERP_FAILED;\r\ncase ZFCP_ERP_STEP_PHYS_PORT_CLOSING:\r\nif (!(status & ZFCP_STATUS_PORT_PHYS_OPEN))\r\nreturn ZFCP_ERP_SUCCEEDED;\r\n}\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\nstatic int zfcp_erp_port_strategy_close(struct zfcp_erp_action *erp_action)\r\n{\r\nint retval;\r\nretval = zfcp_fsf_close_port(erp_action);\r\nif (retval == -ENOMEM)\r\nreturn ZFCP_ERP_NOMEM;\r\nerp_action->step = ZFCP_ERP_STEP_PORT_CLOSING;\r\nif (retval)\r\nreturn ZFCP_ERP_FAILED;\r\nreturn ZFCP_ERP_CONTINUES;\r\n}\r\nstatic int zfcp_erp_port_strategy_open_port(struct zfcp_erp_action *erp_action)\r\n{\r\nint retval;\r\nretval = zfcp_fsf_open_port(erp_action);\r\nif (retval == -ENOMEM)\r\nreturn ZFCP_ERP_NOMEM;\r\nerp_action->step = ZFCP_ERP_STEP_PORT_OPENING;\r\nif (retval)\r\nreturn ZFCP_ERP_FAILED;\r\nreturn ZFCP_ERP_CONTINUES;\r\n}\r\nstatic int zfcp_erp_open_ptp_port(struct zfcp_erp_action *act)\r\n{\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nstruct zfcp_port *port = act->port;\r\nif (port->wwpn != adapter->peer_wwpn) {\r\nzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_ERP_FAILED);\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\nport->d_id = adapter->peer_d_id;\r\nreturn zfcp_erp_port_strategy_open_port(act);\r\n}\r\nstatic int zfcp_erp_port_strategy_open_common(struct zfcp_erp_action *act)\r\n{\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nstruct zfcp_port *port = act->port;\r\nint p_status = atomic_read(&port->status);\r\nswitch (act->step) {\r\ncase ZFCP_ERP_STEP_UNINITIALIZED:\r\ncase ZFCP_ERP_STEP_PHYS_PORT_CLOSING:\r\ncase ZFCP_ERP_STEP_PORT_CLOSING:\r\nif (fc_host_port_type(adapter->scsi_host) == FC_PORTTYPE_PTP)\r\nreturn zfcp_erp_open_ptp_port(act);\r\nif (!port->d_id) {\r\nzfcp_fc_trigger_did_lookup(port);\r\nreturn ZFCP_ERP_EXIT;\r\n}\r\nreturn zfcp_erp_port_strategy_open_port(act);\r\ncase ZFCP_ERP_STEP_PORT_OPENING:\r\nif (p_status & ZFCP_STATUS_COMMON_OPEN) {\r\nif (!port->d_id) {\r\nzfcp_fc_trigger_did_lookup(port);\r\nreturn ZFCP_ERP_EXIT;\r\n}\r\nreturn ZFCP_ERP_SUCCEEDED;\r\n}\r\nif (port->d_id && !(p_status & ZFCP_STATUS_COMMON_NOESC)) {\r\nport->d_id = 0;\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\n}\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\nstatic int zfcp_erp_port_strategy(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_port *port = erp_action->port;\r\nint p_status = atomic_read(&port->status);\r\nif ((p_status & ZFCP_STATUS_COMMON_NOESC) &&\r\n!(p_status & ZFCP_STATUS_COMMON_OPEN))\r\ngoto close_init_done;\r\nswitch (erp_action->step) {\r\ncase ZFCP_ERP_STEP_UNINITIALIZED:\r\nzfcp_erp_port_strategy_clearstati(port);\r\nif (p_status & ZFCP_STATUS_COMMON_OPEN)\r\nreturn zfcp_erp_port_strategy_close(erp_action);\r\nbreak;\r\ncase ZFCP_ERP_STEP_PORT_CLOSING:\r\nif (p_status & ZFCP_STATUS_COMMON_OPEN)\r\nreturn ZFCP_ERP_FAILED;\r\nbreak;\r\n}\r\nclose_init_done:\r\nif (erp_action->status & ZFCP_STATUS_ERP_CLOSE_ONLY)\r\nreturn ZFCP_ERP_EXIT;\r\nreturn zfcp_erp_port_strategy_open_common(erp_action);\r\n}\r\nstatic void zfcp_erp_lun_strategy_clearstati(struct scsi_device *sdev)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\natomic_clear_mask(ZFCP_STATUS_COMMON_ACCESS_DENIED,\r\n&zfcp_sdev->status);\r\n}\r\nstatic int zfcp_erp_lun_strategy_close(struct zfcp_erp_action *erp_action)\r\n{\r\nint retval = zfcp_fsf_close_lun(erp_action);\r\nif (retval == -ENOMEM)\r\nreturn ZFCP_ERP_NOMEM;\r\nerp_action->step = ZFCP_ERP_STEP_LUN_CLOSING;\r\nif (retval)\r\nreturn ZFCP_ERP_FAILED;\r\nreturn ZFCP_ERP_CONTINUES;\r\n}\r\nstatic int zfcp_erp_lun_strategy_open(struct zfcp_erp_action *erp_action)\r\n{\r\nint retval = zfcp_fsf_open_lun(erp_action);\r\nif (retval == -ENOMEM)\r\nreturn ZFCP_ERP_NOMEM;\r\nerp_action->step = ZFCP_ERP_STEP_LUN_OPENING;\r\nif (retval)\r\nreturn ZFCP_ERP_FAILED;\r\nreturn ZFCP_ERP_CONTINUES;\r\n}\r\nstatic int zfcp_erp_lun_strategy(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct scsi_device *sdev = erp_action->sdev;\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nswitch (erp_action->step) {\r\ncase ZFCP_ERP_STEP_UNINITIALIZED:\r\nzfcp_erp_lun_strategy_clearstati(sdev);\r\nif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_OPEN)\r\nreturn zfcp_erp_lun_strategy_close(erp_action);\r\ncase ZFCP_ERP_STEP_LUN_CLOSING:\r\nif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_OPEN)\r\nreturn ZFCP_ERP_FAILED;\r\nif (erp_action->status & ZFCP_STATUS_ERP_CLOSE_ONLY)\r\nreturn ZFCP_ERP_EXIT;\r\nreturn zfcp_erp_lun_strategy_open(erp_action);\r\ncase ZFCP_ERP_STEP_LUN_OPENING:\r\nif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_OPEN)\r\nreturn ZFCP_ERP_SUCCEEDED;\r\n}\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\nstatic int zfcp_erp_strategy_check_lun(struct scsi_device *sdev, int result)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nswitch (result) {\r\ncase ZFCP_ERP_SUCCEEDED :\r\natomic_set(&zfcp_sdev->erp_counter, 0);\r\nzfcp_erp_lun_unblock(sdev);\r\nbreak;\r\ncase ZFCP_ERP_FAILED :\r\natomic_inc(&zfcp_sdev->erp_counter);\r\nif (atomic_read(&zfcp_sdev->erp_counter) > ZFCP_MAX_ERPS) {\r\ndev_err(&zfcp_sdev->port->adapter->ccw_device->dev,\r\n"ERP failed for LUN 0x%016Lx on "\r\n"port 0x%016Lx\n",\r\n(unsigned long long)zfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn);\r\nzfcp_erp_set_lun_status(sdev,\r\nZFCP_STATUS_COMMON_ERP_FAILED);\r\n}\r\nbreak;\r\n}\r\nif (atomic_read(&zfcp_sdev->status) & ZFCP_STATUS_COMMON_ERP_FAILED) {\r\nzfcp_erp_lun_block(sdev, 0);\r\nresult = ZFCP_ERP_EXIT;\r\n}\r\nreturn result;\r\n}\r\nstatic int zfcp_erp_strategy_check_port(struct zfcp_port *port, int result)\r\n{\r\nswitch (result) {\r\ncase ZFCP_ERP_SUCCEEDED :\r\natomic_set(&port->erp_counter, 0);\r\nzfcp_erp_port_unblock(port);\r\nbreak;\r\ncase ZFCP_ERP_FAILED :\r\nif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_NOESC) {\r\nzfcp_erp_port_block(port, 0);\r\nresult = ZFCP_ERP_EXIT;\r\n}\r\natomic_inc(&port->erp_counter);\r\nif (atomic_read(&port->erp_counter) > ZFCP_MAX_ERPS) {\r\ndev_err(&port->adapter->ccw_device->dev,\r\n"ERP failed for remote port 0x%016Lx\n",\r\n(unsigned long long)port->wwpn);\r\nzfcp_erp_set_port_status(port,\r\nZFCP_STATUS_COMMON_ERP_FAILED);\r\n}\r\nbreak;\r\n}\r\nif (atomic_read(&port->status) & ZFCP_STATUS_COMMON_ERP_FAILED) {\r\nzfcp_erp_port_block(port, 0);\r\nresult = ZFCP_ERP_EXIT;\r\n}\r\nreturn result;\r\n}\r\nstatic int zfcp_erp_strategy_check_adapter(struct zfcp_adapter *adapter,\r\nint result)\r\n{\r\nswitch (result) {\r\ncase ZFCP_ERP_SUCCEEDED :\r\natomic_set(&adapter->erp_counter, 0);\r\nzfcp_erp_adapter_unblock(adapter);\r\nbreak;\r\ncase ZFCP_ERP_FAILED :\r\natomic_inc(&adapter->erp_counter);\r\nif (atomic_read(&adapter->erp_counter) > ZFCP_MAX_ERPS) {\r\ndev_err(&adapter->ccw_device->dev,\r\n"ERP cannot recover an error "\r\n"on the FCP device\n");\r\nzfcp_erp_set_adapter_status(adapter,\r\nZFCP_STATUS_COMMON_ERP_FAILED);\r\n}\r\nbreak;\r\n}\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_ERP_FAILED) {\r\nzfcp_erp_adapter_block(adapter, 0);\r\nresult = ZFCP_ERP_EXIT;\r\n}\r\nreturn result;\r\n}\r\nstatic int zfcp_erp_strategy_check_target(struct zfcp_erp_action *erp_action,\r\nint result)\r\n{\r\nstruct zfcp_adapter *adapter = erp_action->adapter;\r\nstruct zfcp_port *port = erp_action->port;\r\nstruct scsi_device *sdev = erp_action->sdev;\r\nswitch (erp_action->action) {\r\ncase ZFCP_ERP_ACTION_REOPEN_LUN:\r\nresult = zfcp_erp_strategy_check_lun(sdev, result);\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\nresult = zfcp_erp_strategy_check_port(port, result);\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\nresult = zfcp_erp_strategy_check_adapter(adapter, result);\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int zfcp_erp_strat_change_det(atomic_t *target_status, u32 erp_status)\r\n{\r\nint status = atomic_read(target_status);\r\nif ((status & ZFCP_STATUS_COMMON_RUNNING) &&\r\n(erp_status & ZFCP_STATUS_ERP_CLOSE_ONLY))\r\nreturn 1;\r\nif (!(status & ZFCP_STATUS_COMMON_RUNNING) &&\r\n!(erp_status & ZFCP_STATUS_ERP_CLOSE_ONLY))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int zfcp_erp_strategy_statechange(struct zfcp_erp_action *act, int ret)\r\n{\r\nint action = act->action;\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nstruct zfcp_port *port = act->port;\r\nstruct scsi_device *sdev = act->sdev;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nu32 erp_status = act->status;\r\nswitch (action) {\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\nif (zfcp_erp_strat_change_det(&adapter->status, erp_status)) {\r\n_zfcp_erp_adapter_reopen(adapter,\r\nZFCP_STATUS_COMMON_ERP_FAILED,\r\n"ersscg1");\r\nreturn ZFCP_ERP_EXIT;\r\n}\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\nif (zfcp_erp_strat_change_det(&port->status, erp_status)) {\r\n_zfcp_erp_port_reopen(port,\r\nZFCP_STATUS_COMMON_ERP_FAILED,\r\n"ersscg2");\r\nreturn ZFCP_ERP_EXIT;\r\n}\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_LUN:\r\nzfcp_sdev = sdev_to_zfcp(sdev);\r\nif (zfcp_erp_strat_change_det(&zfcp_sdev->status, erp_status)) {\r\n_zfcp_erp_lun_reopen(sdev,\r\nZFCP_STATUS_COMMON_ERP_FAILED,\r\n"ersscg3", 0);\r\nreturn ZFCP_ERP_EXIT;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void zfcp_erp_action_dequeue(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_adapter *adapter = erp_action->adapter;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nadapter->erp_total_count--;\r\nif (erp_action->status & ZFCP_STATUS_ERP_LOWMEM) {\r\nadapter->erp_low_mem_count--;\r\nerp_action->status &= ~ZFCP_STATUS_ERP_LOWMEM;\r\n}\r\nlist_del(&erp_action->list);\r\nzfcp_dbf_rec_run("eractd1", erp_action);\r\nswitch (erp_action->action) {\r\ncase ZFCP_ERP_ACTION_REOPEN_LUN:\r\nzfcp_sdev = sdev_to_zfcp(erp_action->sdev);\r\natomic_clear_mask(ZFCP_STATUS_COMMON_ERP_INUSE,\r\n&zfcp_sdev->status);\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\natomic_clear_mask(ZFCP_STATUS_COMMON_ERP_INUSE,\r\n&erp_action->port->status);\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\natomic_clear_mask(ZFCP_STATUS_COMMON_ERP_INUSE,\r\n&erp_action->adapter->status);\r\nbreak;\r\n}\r\n}\r\nstatic void zfcp_erp_action_cleanup(struct zfcp_erp_action *act, int result)\r\n{\r\nstruct zfcp_adapter *adapter = act->adapter;\r\nstruct zfcp_port *port = act->port;\r\nstruct scsi_device *sdev = act->sdev;\r\nswitch (act->action) {\r\ncase ZFCP_ERP_ACTION_REOPEN_LUN:\r\nif (!(act->status & ZFCP_STATUS_ERP_NO_REF))\r\nscsi_device_put(sdev);\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\nif (result == ZFCP_ERP_SUCCEEDED)\r\nzfcp_scsi_schedule_rport_register(port);\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\nput_device(&port->dev);\r\nbreak;\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\nif (result == ZFCP_ERP_SUCCEEDED) {\r\nregister_service_level(&adapter->service_level);\r\nzfcp_fc_conditional_port_scan(adapter);\r\nqueue_work(adapter->work_queue, &adapter->ns_up_work);\r\n} else\r\nunregister_service_level(&adapter->service_level);\r\nkref_put(&adapter->ref, zfcp_adapter_release);\r\nbreak;\r\n}\r\n}\r\nstatic int zfcp_erp_strategy_do_action(struct zfcp_erp_action *erp_action)\r\n{\r\nswitch (erp_action->action) {\r\ncase ZFCP_ERP_ACTION_REOPEN_ADAPTER:\r\nreturn zfcp_erp_adapter_strategy(erp_action);\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:\r\nreturn zfcp_erp_port_forced_strategy(erp_action);\r\ncase ZFCP_ERP_ACTION_REOPEN_PORT:\r\nreturn zfcp_erp_port_strategy(erp_action);\r\ncase ZFCP_ERP_ACTION_REOPEN_LUN:\r\nreturn zfcp_erp_lun_strategy(erp_action);\r\n}\r\nreturn ZFCP_ERP_FAILED;\r\n}\r\nstatic int zfcp_erp_strategy(struct zfcp_erp_action *erp_action)\r\n{\r\nint retval;\r\nunsigned long flags;\r\nstruct zfcp_adapter *adapter = erp_action->adapter;\r\nkref_get(&adapter->ref);\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\nzfcp_erp_strategy_check_fsfreq(erp_action);\r\nif (erp_action->status & ZFCP_STATUS_ERP_DISMISSED) {\r\nzfcp_erp_action_dequeue(erp_action);\r\nretval = ZFCP_ERP_DISMISSED;\r\ngoto unlock;\r\n}\r\nif (erp_action->status & ZFCP_STATUS_ERP_TIMEDOUT) {\r\nretval = ZFCP_ERP_FAILED;\r\ngoto check_target;\r\n}\r\nzfcp_erp_action_to_running(erp_action);\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\nretval = zfcp_erp_strategy_do_action(erp_action);\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\nif (erp_action->status & ZFCP_STATUS_ERP_DISMISSED)\r\nretval = ZFCP_ERP_CONTINUES;\r\nswitch (retval) {\r\ncase ZFCP_ERP_NOMEM:\r\nif (!(erp_action->status & ZFCP_STATUS_ERP_LOWMEM)) {\r\n++adapter->erp_low_mem_count;\r\nerp_action->status |= ZFCP_STATUS_ERP_LOWMEM;\r\n}\r\nif (adapter->erp_total_count == adapter->erp_low_mem_count)\r\n_zfcp_erp_adapter_reopen(adapter, 0, "erstgy1");\r\nelse {\r\nzfcp_erp_strategy_memwait(erp_action);\r\nretval = ZFCP_ERP_CONTINUES;\r\n}\r\ngoto unlock;\r\ncase ZFCP_ERP_CONTINUES:\r\nif (erp_action->status & ZFCP_STATUS_ERP_LOWMEM) {\r\n--adapter->erp_low_mem_count;\r\nerp_action->status &= ~ZFCP_STATUS_ERP_LOWMEM;\r\n}\r\ngoto unlock;\r\n}\r\ncheck_target:\r\nretval = zfcp_erp_strategy_check_target(erp_action, retval);\r\nzfcp_erp_action_dequeue(erp_action);\r\nretval = zfcp_erp_strategy_statechange(erp_action, retval);\r\nif (retval == ZFCP_ERP_EXIT)\r\ngoto unlock;\r\nif (retval == ZFCP_ERP_SUCCEEDED)\r\nzfcp_erp_strategy_followup_success(erp_action);\r\nif (retval == ZFCP_ERP_FAILED)\r\nzfcp_erp_strategy_followup_failed(erp_action);\r\nunlock:\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\nif (retval != ZFCP_ERP_CONTINUES)\r\nzfcp_erp_action_cleanup(erp_action, retval);\r\nkref_put(&adapter->ref, zfcp_adapter_release);\r\nreturn retval;\r\n}\r\nstatic int zfcp_erp_thread(void *data)\r\n{\r\nstruct zfcp_adapter *adapter = (struct zfcp_adapter *) data;\r\nstruct list_head *next;\r\nstruct zfcp_erp_action *act;\r\nunsigned long flags;\r\nfor (;;) {\r\nwait_event_interruptible(adapter->erp_ready_wq,\r\n!list_empty(&adapter->erp_ready_head) ||\r\nkthread_should_stop());\r\nif (kthread_should_stop())\r\nbreak;\r\nwrite_lock_irqsave(&adapter->erp_lock, flags);\r\nnext = adapter->erp_ready_head.next;\r\nwrite_unlock_irqrestore(&adapter->erp_lock, flags);\r\nif (next != &adapter->erp_ready_head) {\r\nact = list_entry(next, struct zfcp_erp_action, list);\r\nif (zfcp_erp_strategy(act) != ZFCP_ERP_DISMISSED)\r\nzfcp_erp_wakeup(adapter);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint zfcp_erp_thread_setup(struct zfcp_adapter *adapter)\r\n{\r\nstruct task_struct *thread;\r\nthread = kthread_run(zfcp_erp_thread, adapter, "zfcperp%s",\r\ndev_name(&adapter->ccw_device->dev));\r\nif (IS_ERR(thread)) {\r\ndev_err(&adapter->ccw_device->dev,\r\n"Creating an ERP thread for the FCP device failed.\n");\r\nreturn PTR_ERR(thread);\r\n}\r\nadapter->erp_thread = thread;\r\nreturn 0;\r\n}\r\nvoid zfcp_erp_thread_kill(struct zfcp_adapter *adapter)\r\n{\r\nkthread_stop(adapter->erp_thread);\r\nadapter->erp_thread = NULL;\r\nWARN_ON(!list_empty(&adapter->erp_ready_head));\r\nWARN_ON(!list_empty(&adapter->erp_running_head));\r\n}\r\nvoid zfcp_erp_wait(struct zfcp_adapter *adapter)\r\n{\r\nwait_event(adapter->erp_done_wqh,\r\n!(atomic_read(&adapter->status) &\r\nZFCP_STATUS_ADAPTER_ERP_PENDING));\r\n}\r\nvoid zfcp_erp_set_adapter_status(struct zfcp_adapter *adapter, u32 mask)\r\n{\r\nstruct zfcp_port *port;\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nu32 common_mask = mask & ZFCP_COMMON_FLAGS;\r\natomic_set_mask(mask, &adapter->status);\r\nif (!common_mask)\r\nreturn;\r\nread_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry(port, &adapter->port_list, list)\r\natomic_set_mask(common_mask, &port->status);\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\nspin_lock_irqsave(adapter->scsi_host->host_lock, flags);\r\n__shost_for_each_device(sdev, adapter->scsi_host)\r\natomic_set_mask(common_mask, &sdev_to_zfcp(sdev)->status);\r\nspin_unlock_irqrestore(adapter->scsi_host->host_lock, flags);\r\n}\r\nvoid zfcp_erp_clear_adapter_status(struct zfcp_adapter *adapter, u32 mask)\r\n{\r\nstruct zfcp_port *port;\r\nstruct scsi_device *sdev;\r\nunsigned long flags;\r\nu32 common_mask = mask & ZFCP_COMMON_FLAGS;\r\nu32 clear_counter = mask & ZFCP_STATUS_COMMON_ERP_FAILED;\r\natomic_clear_mask(mask, &adapter->status);\r\nif (!common_mask)\r\nreturn;\r\nif (clear_counter)\r\natomic_set(&adapter->erp_counter, 0);\r\nread_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry(port, &adapter->port_list, list) {\r\natomic_clear_mask(common_mask, &port->status);\r\nif (clear_counter)\r\natomic_set(&port->erp_counter, 0);\r\n}\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\nspin_lock_irqsave(adapter->scsi_host->host_lock, flags);\r\n__shost_for_each_device(sdev, adapter->scsi_host) {\r\natomic_clear_mask(common_mask, &sdev_to_zfcp(sdev)->status);\r\nif (clear_counter)\r\natomic_set(&sdev_to_zfcp(sdev)->erp_counter, 0);\r\n}\r\nspin_unlock_irqrestore(adapter->scsi_host->host_lock, flags);\r\n}\r\nvoid zfcp_erp_set_port_status(struct zfcp_port *port, u32 mask)\r\n{\r\nstruct scsi_device *sdev;\r\nu32 common_mask = mask & ZFCP_COMMON_FLAGS;\r\nunsigned long flags;\r\natomic_set_mask(mask, &port->status);\r\nif (!common_mask)\r\nreturn;\r\nspin_lock_irqsave(port->adapter->scsi_host->host_lock, flags);\r\n__shost_for_each_device(sdev, port->adapter->scsi_host)\r\nif (sdev_to_zfcp(sdev)->port == port)\r\natomic_set_mask(common_mask,\r\n&sdev_to_zfcp(sdev)->status);\r\nspin_unlock_irqrestore(port->adapter->scsi_host->host_lock, flags);\r\n}\r\nvoid zfcp_erp_clear_port_status(struct zfcp_port *port, u32 mask)\r\n{\r\nstruct scsi_device *sdev;\r\nu32 common_mask = mask & ZFCP_COMMON_FLAGS;\r\nu32 clear_counter = mask & ZFCP_STATUS_COMMON_ERP_FAILED;\r\nunsigned long flags;\r\natomic_clear_mask(mask, &port->status);\r\nif (!common_mask)\r\nreturn;\r\nif (clear_counter)\r\natomic_set(&port->erp_counter, 0);\r\nspin_lock_irqsave(port->adapter->scsi_host->host_lock, flags);\r\n__shost_for_each_device(sdev, port->adapter->scsi_host)\r\nif (sdev_to_zfcp(sdev)->port == port) {\r\natomic_clear_mask(common_mask,\r\n&sdev_to_zfcp(sdev)->status);\r\nif (clear_counter)\r\natomic_set(&sdev_to_zfcp(sdev)->erp_counter, 0);\r\n}\r\nspin_unlock_irqrestore(port->adapter->scsi_host->host_lock, flags);\r\n}\r\nvoid zfcp_erp_set_lun_status(struct scsi_device *sdev, u32 mask)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\natomic_set_mask(mask, &zfcp_sdev->status);\r\n}\r\nvoid zfcp_erp_clear_lun_status(struct scsi_device *sdev, u32 mask)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\natomic_clear_mask(mask, &zfcp_sdev->status);\r\nif (mask & ZFCP_STATUS_COMMON_ERP_FAILED)\r\natomic_set(&zfcp_sdev->erp_counter, 0);\r\n}
