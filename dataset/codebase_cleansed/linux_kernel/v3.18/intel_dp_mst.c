static bool intel_dp_mst_compute_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);\r\nstruct intel_digital_port *intel_dig_port = intel_mst->primary;\r\nstruct intel_dp *intel_dp = &intel_dig_port->dp;\r\nstruct drm_device *dev = encoder->base.dev;\r\nint bpp;\r\nint lane_count, slots;\r\nstruct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;\r\nstruct intel_connector *found = NULL, *intel_connector;\r\nint mst_pbn;\r\npipe_config->dp_encoder_is_mst = true;\r\npipe_config->has_pch_encoder = false;\r\npipe_config->has_dp_encoder = true;\r\nbpp = 24;\r\nlane_count = drm_dp_max_lane_count(intel_dp->dpcd);\r\nintel_dp->link_bw = intel_dp_max_link_bw(intel_dp);\r\nintel_dp->lane_count = lane_count;\r\npipe_config->pipe_bpp = 24;\r\npipe_config->port_clock = drm_dp_bw_code_to_link_rate(intel_dp->link_bw);\r\nlist_for_each_entry(intel_connector, &dev->mode_config.connector_list, base.head) {\r\nif (intel_connector->new_encoder == encoder) {\r\nfound = intel_connector;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nDRM_ERROR("can't find connector\n");\r\nreturn false;\r\n}\r\nmst_pbn = drm_dp_calc_pbn_mode(adjusted_mode->clock, bpp);\r\npipe_config->pbn = mst_pbn;\r\nslots = drm_dp_find_vcpi_slots(&intel_dp->mst_mgr, mst_pbn);\r\nintel_link_compute_m_n(bpp, lane_count,\r\nadjusted_mode->crtc_clock,\r\npipe_config->port_clock,\r\n&pipe_config->dp_m_n);\r\npipe_config->dp_m_n.tu = slots;\r\nreturn true;\r\n}\r\nstatic void intel_mst_disable_dp(struct intel_encoder *encoder)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);\r\nstruct intel_digital_port *intel_dig_port = intel_mst->primary;\r\nstruct intel_dp *intel_dp = &intel_dig_port->dp;\r\nint ret;\r\nDRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);\r\ndrm_dp_mst_reset_vcpi_slots(&intel_dp->mst_mgr, intel_mst->port);\r\nret = drm_dp_update_payload_part1(&intel_dp->mst_mgr);\r\nif (ret) {\r\nDRM_ERROR("failed to update payload %d\n", ret);\r\n}\r\n}\r\nstatic void intel_mst_post_disable_dp(struct intel_encoder *encoder)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);\r\nstruct intel_digital_port *intel_dig_port = intel_mst->primary;\r\nstruct intel_dp *intel_dp = &intel_dig_port->dp;\r\nDRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);\r\ndrm_dp_check_act_status(&intel_dp->mst_mgr);\r\ndrm_dp_update_payload_part2(&intel_dp->mst_mgr);\r\ndrm_dp_mst_deallocate_vcpi(&intel_dp->mst_mgr, intel_mst->port);\r\nintel_dp->active_mst_links--;\r\nintel_mst->port = NULL;\r\nif (intel_dp->active_mst_links == 0) {\r\nintel_dig_port->base.post_disable(&intel_dig_port->base);\r\nintel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_OFF);\r\n}\r\n}\r\nstatic void intel_mst_pre_enable_dp(struct intel_encoder *encoder)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);\r\nstruct intel_digital_port *intel_dig_port = intel_mst->primary;\r\nstruct intel_dp *intel_dp = &intel_dig_port->dp;\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nenum port port = intel_dig_port->port;\r\nint ret;\r\nuint32_t temp;\r\nstruct intel_connector *found = NULL, *intel_connector;\r\nint slots;\r\nstruct drm_crtc *crtc = encoder->base.crtc;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(crtc);\r\nlist_for_each_entry(intel_connector, &dev->mode_config.connector_list, base.head) {\r\nif (intel_connector->new_encoder == encoder) {\r\nfound = intel_connector;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nDRM_ERROR("can't find connector\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);\r\nintel_mst->port = found->port;\r\nif (intel_dp->active_mst_links == 0) {\r\nenum port port = intel_ddi_get_encoder_port(encoder);\r\nI915_WRITE(PORT_CLK_SEL(port), intel_crtc->config.ddi_pll_sel);\r\nintel_ddi_init_dp_buf_reg(&intel_dig_port->base);\r\nintel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);\r\nintel_dp_start_link_train(intel_dp);\r\nintel_dp_complete_link_train(intel_dp);\r\nintel_dp_stop_link_train(intel_dp);\r\n}\r\nret = drm_dp_mst_allocate_vcpi(&intel_dp->mst_mgr,\r\nintel_mst->port, intel_crtc->config.pbn, &slots);\r\nif (ret == false) {\r\nDRM_ERROR("failed to allocate vcpi\n");\r\nreturn;\r\n}\r\nintel_dp->active_mst_links++;\r\ntemp = I915_READ(DP_TP_STATUS(port));\r\nI915_WRITE(DP_TP_STATUS(port), temp);\r\nret = drm_dp_update_payload_part1(&intel_dp->mst_mgr);\r\n}\r\nstatic void intel_mst_enable_dp(struct intel_encoder *encoder)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);\r\nstruct intel_digital_port *intel_dig_port = intel_mst->primary;\r\nstruct intel_dp *intel_dp = &intel_dig_port->dp;\r\nstruct drm_device *dev = intel_dig_port->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nenum port port = intel_dig_port->port;\r\nint ret;\r\nDRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);\r\nif (wait_for((I915_READ(DP_TP_STATUS(port)) & DP_TP_STATUS_ACT_SENT),\r\n1))\r\nDRM_ERROR("Timed out waiting for ACT sent\n");\r\nret = drm_dp_check_act_status(&intel_dp->mst_mgr);\r\nret = drm_dp_update_payload_part2(&intel_dp->mst_mgr);\r\n}\r\nstatic bool intel_dp_mst_enc_get_hw_state(struct intel_encoder *encoder,\r\nenum pipe *pipe)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);\r\n*pipe = intel_mst->pipe;\r\nif (intel_mst->port)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void intel_dp_mst_enc_get_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);\r\nstruct intel_digital_port *intel_dig_port = intel_mst->primary;\r\nstruct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nenum transcoder cpu_transcoder = crtc->config.cpu_transcoder;\r\nu32 temp, flags = 0;\r\npipe_config->has_dp_encoder = true;\r\ntemp = I915_READ(TRANS_DDI_FUNC_CTL(cpu_transcoder));\r\nif (temp & TRANS_DDI_PHSYNC)\r\nflags |= DRM_MODE_FLAG_PHSYNC;\r\nelse\r\nflags |= DRM_MODE_FLAG_NHSYNC;\r\nif (temp & TRANS_DDI_PVSYNC)\r\nflags |= DRM_MODE_FLAG_PVSYNC;\r\nelse\r\nflags |= DRM_MODE_FLAG_NVSYNC;\r\nswitch (temp & TRANS_DDI_BPC_MASK) {\r\ncase TRANS_DDI_BPC_6:\r\npipe_config->pipe_bpp = 18;\r\nbreak;\r\ncase TRANS_DDI_BPC_8:\r\npipe_config->pipe_bpp = 24;\r\nbreak;\r\ncase TRANS_DDI_BPC_10:\r\npipe_config->pipe_bpp = 30;\r\nbreak;\r\ncase TRANS_DDI_BPC_12:\r\npipe_config->pipe_bpp = 36;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npipe_config->adjusted_mode.flags |= flags;\r\nintel_dp_get_m_n(crtc, pipe_config);\r\nintel_ddi_clock_get(&intel_dig_port->base, pipe_config);\r\n}\r\nstatic int intel_dp_mst_get_ddc_modes(struct drm_connector *connector)\r\n{\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nstruct intel_dp *intel_dp = intel_connector->mst_port;\r\nstruct edid *edid;\r\nint ret;\r\nedid = drm_dp_mst_get_edid(connector, &intel_dp->mst_mgr, intel_connector->port);\r\nif (!edid)\r\nreturn 0;\r\nret = intel_connector_update_modes(connector, edid);\r\nkfree(edid);\r\nreturn ret;\r\n}\r\nstatic enum drm_connector_status\r\nintel_mst_port_dp_detect(struct drm_connector *connector)\r\n{\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nstruct intel_dp *intel_dp = intel_connector->mst_port;\r\nreturn drm_dp_mst_detect_port(&intel_dp->mst_mgr, intel_connector->port);\r\n}\r\nstatic enum drm_connector_status\r\nintel_dp_mst_detect(struct drm_connector *connector, bool force)\r\n{\r\nenum drm_connector_status status;\r\nstatus = intel_mst_port_dp_detect(connector);\r\nreturn status;\r\n}\r\nstatic int\r\nintel_dp_mst_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nintel_dp_mst_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nif (!IS_ERR_OR_NULL(intel_connector->edid))\r\nkfree(intel_connector->edid);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic int intel_dp_mst_get_modes(struct drm_connector *connector)\r\n{\r\nreturn intel_dp_mst_get_ddc_modes(connector);\r\n}\r\nstatic enum drm_mode_status\r\nintel_dp_mst_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock < 10000)\r\nreturn MODE_CLOCK_LOW;\r\nif (mode->flags & DRM_MODE_FLAG_DBLCLK)\r\nreturn MODE_H_ILLEGAL;\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *intel_mst_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nstruct intel_dp *intel_dp = intel_connector->mst_port;\r\nreturn &intel_dp->mst_encoders[0]->base.base;\r\n}\r\nstatic void intel_dp_mst_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(intel_mst);\r\n}\r\nstatic bool intel_dp_mst_get_hw_state(struct intel_connector *connector)\r\n{\r\nif (connector->encoder) {\r\nenum pipe pipe;\r\nif (!connector->encoder->get_hw_state(connector->encoder, &pipe))\r\nreturn false;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void intel_connector_add_to_fbdev(struct intel_connector *connector)\r\n{\r\n#ifdef CONFIG_DRM_I915_FBDEV\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\ndrm_fb_helper_add_one_connector(&dev_priv->fbdev->helper, &connector->base);\r\n#endif\r\n}\r\nstatic void intel_connector_remove_from_fbdev(struct intel_connector *connector)\r\n{\r\n#ifdef CONFIG_DRM_I915_FBDEV\r\nstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\r\ndrm_fb_helper_remove_one_connector(&dev_priv->fbdev->helper, &connector->base);\r\n#endif\r\n}\r\nstatic struct drm_connector *intel_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port, char *pathprop)\r\n{\r\nstruct intel_dp *intel_dp = container_of(mgr, struct intel_dp, mst_mgr);\r\nstruct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);\r\nstruct drm_device *dev = intel_dig_port->base.base.dev;\r\nstruct intel_connector *intel_connector;\r\nstruct drm_connector *connector;\r\nint i;\r\nintel_connector = kzalloc(sizeof(*intel_connector), GFP_KERNEL);\r\nif (!intel_connector)\r\nreturn NULL;\r\nconnector = &intel_connector->base;\r\ndrm_connector_init(dev, connector, &intel_dp_mst_connector_funcs, DRM_MODE_CONNECTOR_DisplayPort);\r\ndrm_connector_helper_add(connector, &intel_dp_mst_connector_helper_funcs);\r\nintel_connector->unregister = intel_connector_unregister;\r\nintel_connector->get_hw_state = intel_dp_mst_get_hw_state;\r\nintel_connector->mst_port = intel_dp;\r\nintel_connector->port = port;\r\nfor (i = PIPE_A; i <= PIPE_C; i++) {\r\ndrm_mode_connector_attach_encoder(&intel_connector->base,\r\n&intel_dp->mst_encoders[i]->base.base);\r\n}\r\nintel_dp_add_properties(intel_dp, connector);\r\ndrm_object_attach_property(&connector->base, dev->mode_config.path_property, 0);\r\ndrm_mode_connector_set_path_property(connector, pathprop);\r\ndrm_reinit_primary_mode_group(dev);\r\nmutex_lock(&dev->mode_config.mutex);\r\nintel_connector_add_to_fbdev(intel_connector);\r\nmutex_unlock(&dev->mode_config.mutex);\r\ndrm_connector_register(&intel_connector->base);\r\nreturn connector;\r\n}\r\nstatic void intel_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,\r\nstruct drm_connector *connector)\r\n{\r\nstruct intel_connector *intel_connector = to_intel_connector(connector);\r\nstruct drm_device *dev = connector->dev;\r\nmutex_lock(&dev->mode_config.mutex);\r\nintel_connector_dpms(connector, DRM_MODE_DPMS_OFF);\r\nmutex_unlock(&dev->mode_config.mutex);\r\nintel_connector->unregister(intel_connector);\r\nmutex_lock(&dev->mode_config.mutex);\r\nintel_connector_remove_from_fbdev(intel_connector);\r\ndrm_connector_cleanup(connector);\r\nmutex_unlock(&dev->mode_config.mutex);\r\ndrm_reinit_primary_mode_group(dev);\r\nkfree(intel_connector);\r\nDRM_DEBUG_KMS("\n");\r\n}\r\nstatic void intel_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)\r\n{\r\nstruct intel_dp *intel_dp = container_of(mgr, struct intel_dp, mst_mgr);\r\nstruct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);\r\nstruct drm_device *dev = intel_dig_port->base.base.dev;\r\ndrm_kms_helper_hotplug_event(dev);\r\n}\r\nstatic struct intel_dp_mst_encoder *\r\nintel_dp_create_fake_mst_encoder(struct intel_digital_port *intel_dig_port, enum pipe pipe)\r\n{\r\nstruct intel_dp_mst_encoder *intel_mst;\r\nstruct intel_encoder *intel_encoder;\r\nstruct drm_device *dev = intel_dig_port->base.base.dev;\r\nintel_mst = kzalloc(sizeof(*intel_mst), GFP_KERNEL);\r\nif (!intel_mst)\r\nreturn NULL;\r\nintel_mst->pipe = pipe;\r\nintel_encoder = &intel_mst->base;\r\nintel_mst->primary = intel_dig_port;\r\ndrm_encoder_init(dev, &intel_encoder->base, &intel_dp_mst_enc_funcs,\r\nDRM_MODE_ENCODER_DPMST);\r\nintel_encoder->type = INTEL_OUTPUT_DP_MST;\r\nintel_encoder->crtc_mask = 0x7;\r\nintel_encoder->cloneable = 0;\r\nintel_encoder->compute_config = intel_dp_mst_compute_config;\r\nintel_encoder->disable = intel_mst_disable_dp;\r\nintel_encoder->post_disable = intel_mst_post_disable_dp;\r\nintel_encoder->pre_enable = intel_mst_pre_enable_dp;\r\nintel_encoder->enable = intel_mst_enable_dp;\r\nintel_encoder->get_hw_state = intel_dp_mst_enc_get_hw_state;\r\nintel_encoder->get_config = intel_dp_mst_enc_get_config;\r\nreturn intel_mst;\r\n}\r\nstatic bool\r\nintel_dp_create_fake_mst_encoders(struct intel_digital_port *intel_dig_port)\r\n{\r\nint i;\r\nstruct intel_dp *intel_dp = &intel_dig_port->dp;\r\nfor (i = PIPE_A; i <= PIPE_C; i++)\r\nintel_dp->mst_encoders[i] = intel_dp_create_fake_mst_encoder(intel_dig_port, i);\r\nreturn true;\r\n}\r\nint\r\nintel_dp_mst_encoder_init(struct intel_digital_port *intel_dig_port, int conn_base_id)\r\n{\r\nstruct intel_dp *intel_dp = &intel_dig_port->dp;\r\nstruct drm_device *dev = intel_dig_port->base.base.dev;\r\nint ret;\r\nintel_dp->can_mst = true;\r\nintel_dp->mst_mgr.cbs = &mst_cbs;\r\nintel_dp_create_fake_mst_encoders(intel_dig_port);\r\nret = drm_dp_mst_topology_mgr_init(&intel_dp->mst_mgr, dev->dev, &intel_dp->aux, 16, 3, conn_base_id);\r\nif (ret) {\r\nintel_dp->can_mst = false;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nintel_dp_mst_encoder_cleanup(struct intel_digital_port *intel_dig_port)\r\n{\r\nstruct intel_dp *intel_dp = &intel_dig_port->dp;\r\nif (!intel_dp->can_mst)\r\nreturn;\r\ndrm_dp_mst_topology_mgr_destroy(&intel_dp->mst_mgr);\r\n}
