int size_from_channelarray(struct iio_channel_info *channels, int num_channels)\r\n{\r\nint bytes = 0;\r\nint i = 0;\r\nwhile (i < num_channels) {\r\nif (bytes % channels[i].bytes == 0)\r\nchannels[i].location = bytes;\r\nelse\r\nchannels[i].location = bytes - bytes%channels[i].bytes\r\n+ channels[i].bytes;\r\nbytes = channels[i].location + channels[i].bytes;\r\ni++;\r\n}\r\nreturn bytes;\r\n}\r\nvoid print2byte(int input, struct iio_channel_info *info)\r\n{\r\nif (info->be)\r\ninput = be16toh((uint16_t)input);\r\nelse\r\ninput = le16toh((uint16_t)input);\r\ninput = input >> info->shift;\r\nif (info->is_signed) {\r\nint16_t val = input;\r\nval &= (1 << info->bits_used) - 1;\r\nval = (int16_t)(val << (16 - info->bits_used)) >>\r\n(16 - info->bits_used);\r\nprintf("%05f ", ((float)val + info->offset)*info->scale);\r\n} else {\r\nuint16_t val = input;\r\nval &= (1 << info->bits_used) - 1;\r\nprintf("%05f ", ((float)val + info->offset)*info->scale);\r\n}\r\n}\r\nvoid process_scan(char *data,\r\nstruct iio_channel_info *channels,\r\nint num_channels)\r\n{\r\nint k;\r\nfor (k = 0; k < num_channels; k++)\r\nswitch (channels[k].bytes) {\r\ncase 2:\r\nprint2byte(*(uint16_t *)(data + channels[k].location),\r\n&channels[k]);\r\nbreak;\r\ncase 4:\r\nif (!channels[k].is_signed) {\r\nuint32_t val = *(uint32_t *)\r\n(data + channels[k].location);\r\nprintf("%05f ", ((float)val +\r\nchannels[k].offset)*\r\nchannels[k].scale);\r\n}\r\nbreak;\r\ncase 8:\r\nif (channels[k].is_signed) {\r\nint64_t val = *(int64_t *)\r\n(data +\r\nchannels[k].location);\r\nif ((val >> channels[k].bits_used) & 1)\r\nval = (val & channels[k].mask) |\r\n~channels[k].mask;\r\nif (channels[k].scale == 1.0f &&\r\nchannels[k].offset == 0.0f)\r\nprintf("%" PRId64 " ", val);\r\nelse\r\nprintf("%05f ", ((float)val +\r\nchannels[k].offset)*\r\nchannels[k].scale);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nprintf("\n");\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nunsigned long num_loops = 2;\r\nunsigned long timedelay = 1000000;\r\nunsigned long buf_len = 128;\r\nint ret, c, i, j, toread;\r\nint fp;\r\nint num_channels;\r\nchar *trigger_name = NULL, *device_name = NULL;\r\nchar *dev_dir_name, *buf_dir_name;\r\nint datardytrigger = 1;\r\nchar *data;\r\nssize_t read_size;\r\nint dev_num, trig_num;\r\nchar *buffer_access;\r\nint scan_size;\r\nint noevents = 0;\r\nchar *dummy;\r\nstruct iio_channel_info *channels;\r\nwhile ((c = getopt(argc, argv, "l:w:c:et:n:")) != -1) {\r\nswitch (c) {\r\ncase 'n':\r\ndevice_name = optarg;\r\nbreak;\r\ncase 't':\r\ntrigger_name = optarg;\r\ndatardytrigger = 0;\r\nbreak;\r\ncase 'e':\r\nnoevents = 1;\r\nbreak;\r\ncase 'c':\r\nnum_loops = strtoul(optarg, &dummy, 10);\r\nbreak;\r\ncase 'w':\r\ntimedelay = strtoul(optarg, &dummy, 10);\r\nbreak;\r\ncase 'l':\r\nbuf_len = strtoul(optarg, &dummy, 10);\r\nbreak;\r\ncase '?':\r\nreturn -1;\r\n}\r\n}\r\nif (device_name == NULL)\r\nreturn -1;\r\ndev_num = find_type_by_name(device_name, "iio:device");\r\nif (dev_num < 0) {\r\nprintf("Failed to find the %s\n", device_name);\r\nret = -ENODEV;\r\ngoto error_ret;\r\n}\r\nprintf("iio device number being used is %d\n", dev_num);\r\nasprintf(&dev_dir_name, "%siio:device%d", iio_dir, dev_num);\r\nif (trigger_name == NULL) {\r\nret = asprintf(&trigger_name,\r\n"%s-dev%d", device_name, dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\n}\r\ntrig_num = find_type_by_name(trigger_name, "trigger");\r\nif (trig_num < 0) {\r\nprintf("Failed to find the trigger %s\n", trigger_name);\r\nret = -ENODEV;\r\ngoto error_free_triggername;\r\n}\r\nprintf("iio trigger number being used is %d\n", trig_num);\r\nret = build_channel_array(dev_dir_name, &channels, &num_channels);\r\nif (ret) {\r\nprintf("Problem reading scan element information\n");\r\nprintf("diag %s\n", dev_dir_name);\r\ngoto error_free_triggername;\r\n}\r\nret = asprintf(&buf_dir_name,\r\n"%siio:device%d/buffer", iio_dir, dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_free_triggername;\r\n}\r\nprintf("%s %s\n", dev_dir_name, trigger_name);\r\nret = write_sysfs_string_and_verify("trigger/current_trigger",\r\ndev_dir_name,\r\ntrigger_name);\r\nif (ret < 0) {\r\nprintf("Failed to write current_trigger file\n");\r\ngoto error_free_buf_dir_name;\r\n}\r\nret = write_sysfs_int("length", buf_dir_name, buf_len);\r\nif (ret < 0)\r\ngoto error_free_buf_dir_name;\r\nret = write_sysfs_int("enable", buf_dir_name, 1);\r\nif (ret < 0)\r\ngoto error_free_buf_dir_name;\r\nscan_size = size_from_channelarray(channels, num_channels);\r\ndata = malloc(scan_size*buf_len);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto error_free_buf_dir_name;\r\n}\r\nret = asprintf(&buffer_access, "/dev/iio:device%d", dev_num);\r\nif (ret < 0) {\r\nret = -ENOMEM;\r\ngoto error_free_data;\r\n}\r\nfp = open(buffer_access, O_RDONLY | O_NONBLOCK);\r\nif (fp == -1) {\r\nprintf("Failed to open %s\n", buffer_access);\r\nret = -errno;\r\ngoto error_free_buffer_access;\r\n}\r\nfor (j = 0; j < num_loops; j++) {\r\nif (!noevents) {\r\nstruct pollfd pfd = {\r\n.fd = fp,\r\n.events = POLLIN,\r\n};\r\npoll(&pfd, 1, -1);\r\ntoread = buf_len;\r\n} else {\r\nusleep(timedelay);\r\ntoread = 64;\r\n}\r\nread_size = read(fp,\r\ndata,\r\ntoread*scan_size);\r\nif (read_size < 0) {\r\nif (errno == -EAGAIN) {\r\nprintf("nothing available\n");\r\ncontinue;\r\n} else\r\nbreak;\r\n}\r\nfor (i = 0; i < read_size/scan_size; i++)\r\nprocess_scan(data + scan_size*i,\r\nchannels,\r\nnum_channels);\r\n}\r\nret = write_sysfs_int("enable", buf_dir_name, 0);\r\nif (ret < 0)\r\ngoto error_close_buffer_access;\r\nwrite_sysfs_string("trigger/current_trigger",\r\ndev_dir_name, "NULL");\r\nerror_close_buffer_access:\r\nclose(fp);\r\nerror_free_data:\r\nfree(data);\r\nerror_free_buffer_access:\r\nfree(buffer_access);\r\nerror_free_buf_dir_name:\r\nfree(buf_dir_name);\r\nerror_free_triggername:\r\nif (datardytrigger)\r\nfree(trigger_name);\r\nerror_ret:\r\nreturn ret;\r\n}
