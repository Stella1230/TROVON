static inline void w9966_set_state(struct w9966 *cam, int mask, int val)\r\n{\r\ncam->dev_state = (cam->dev_state & ~mask) ^ val;\r\n}\r\nstatic inline int w9966_get_state(struct w9966 *cam, int mask, int val)\r\n{\r\nreturn ((cam->dev_state & mask) == val);\r\n}\r\nstatic void w9966_pdev_claim(struct w9966 *cam)\r\n{\r\nif (w9966_get_state(cam, W9966_STATE_CLAIMED, W9966_STATE_CLAIMED))\r\nreturn;\r\nparport_claim_or_block(cam->pdev);\r\nw9966_set_state(cam, W9966_STATE_CLAIMED, W9966_STATE_CLAIMED);\r\n}\r\nstatic void w9966_pdev_release(struct w9966 *cam)\r\n{\r\nif (w9966_get_state(cam, W9966_STATE_CLAIMED, 0))\r\nreturn;\r\nparport_release(cam->pdev);\r\nw9966_set_state(cam, W9966_STATE_CLAIMED, 0);\r\n}\r\nstatic int w9966_read_reg(struct w9966 *cam, int reg)\r\n{\r\nconst unsigned char addr = 0x80 | (reg & 0x1f);\r\nunsigned char val;\r\nif (parport_negotiate(cam->pport, cam->ppmode | IEEE1284_ADDR) != 0)\r\nreturn -1;\r\nif (parport_write(cam->pport, &addr, 1) != 1)\r\nreturn -1;\r\nif (parport_negotiate(cam->pport, cam->ppmode | IEEE1284_DATA) != 0)\r\nreturn -1;\r\nif (parport_read(cam->pport, &val, 1) != 1)\r\nreturn -1;\r\nreturn val;\r\n}\r\nstatic int w9966_write_reg(struct w9966 *cam, int reg, int data)\r\n{\r\nconst unsigned char addr = 0xc0 | (reg & 0x1f);\r\nconst unsigned char val = data;\r\nif (parport_negotiate(cam->pport, cam->ppmode | IEEE1284_ADDR) != 0)\r\nreturn -1;\r\nif (parport_write(cam->pport, &addr, 1) != 1)\r\nreturn -1;\r\nif (parport_negotiate(cam->pport, cam->ppmode | IEEE1284_DATA) != 0)\r\nreturn -1;\r\nif (parport_write(cam->pport, &val, 1) != 1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void w9966_i2c_setsda(struct w9966 *cam, int state)\r\n{\r\nif (state)\r\ncam->i2c_state |= W9966_I2C_W_DATA;\r\nelse\r\ncam->i2c_state &= ~W9966_I2C_W_DATA;\r\nw9966_write_reg(cam, 0x18, cam->i2c_state);\r\nudelay(5);\r\n}\r\nstatic int w9966_i2c_getscl(struct w9966 *cam)\r\n{\r\nconst unsigned char state = w9966_read_reg(cam, 0x18);\r\nreturn ((state & W9966_I2C_R_CLOCK) > 0);\r\n}\r\nstatic int w9966_i2c_setscl(struct w9966 *cam, int state)\r\n{\r\nunsigned long timeout;\r\nif (state)\r\ncam->i2c_state |= W9966_I2C_W_CLOCK;\r\nelse\r\ncam->i2c_state &= ~W9966_I2C_W_CLOCK;\r\nw9966_write_reg(cam, 0x18, cam->i2c_state);\r\nudelay(5);\r\nif (state) {\r\ntimeout = jiffies + 100;\r\nwhile (!w9966_i2c_getscl(cam)) {\r\nif (time_after(jiffies, timeout))\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int w9966_i2c_wbyte(struct w9966 *cam, int data)\r\n{\r\nint i;\r\nfor (i = 7; i >= 0; i--) {\r\nw9966_i2c_setsda(cam, (data >> i) & 0x01);\r\nif (w9966_i2c_setscl(cam, 1) == -1)\r\nreturn -1;\r\nw9966_i2c_setscl(cam, 0);\r\n}\r\nw9966_i2c_setsda(cam, 1);\r\nif (w9966_i2c_setscl(cam, 1) == -1)\r\nreturn -1;\r\nw9966_i2c_setscl(cam, 0);\r\nreturn 0;\r\n}\r\nstatic int w9966_write_reg_i2c(struct w9966 *cam, int reg, int data)\r\n{\r\nw9966_i2c_setsda(cam, 0);\r\nw9966_i2c_setscl(cam, 0);\r\nif (w9966_i2c_wbyte(cam, W9966_I2C_W_ID) == -1 ||\r\nw9966_i2c_wbyte(cam, reg) == -1 ||\r\nw9966_i2c_wbyte(cam, data) == -1)\r\nreturn -1;\r\nw9966_i2c_setsda(cam, 0);\r\nif (w9966_i2c_setscl(cam, 1) == -1)\r\nreturn -1;\r\nw9966_i2c_setsda(cam, 1);\r\nreturn 0;\r\n}\r\nstatic int w9966_findlen(int near, int size, int maxlen)\r\n{\r\nint bestlen = size;\r\nint besterr = abs(near - bestlen);\r\nint len;\r\nfor (len = size + 1; len < maxlen; len++) {\r\nint err;\r\nif (((64 * size) % len) != 0)\r\ncontinue;\r\nerr = abs(near - len);\r\nif (err > besterr)\r\nbreak;\r\nbesterr = err;\r\nbestlen = len;\r\n}\r\nreturn bestlen;\r\n}\r\nstatic int w9966_calcscale(int size, int min, int max, int *beg, int *end, unsigned char *factor)\r\n{\r\nint maxlen = max - min;\r\nint len = *end - *beg + 1;\r\nint newlen = w9966_findlen(len, size, maxlen);\r\nint err = newlen - len;\r\nif (newlen > maxlen || newlen < size)\r\nreturn -1;\r\n*factor = (64 * size) / newlen;\r\nif (*factor == 64)\r\n*factor = 0x00;\r\nelse\r\n*factor |= 0x80;\r\n*beg -= err / 2;\r\n*end += err - (err / 2);\r\nif (*beg < min) {\r\n*end += min - *beg;\r\n*beg += min - *beg;\r\n}\r\nif (*end > max) {\r\n*beg -= *end - max;\r\n*end -= *end - max;\r\n}\r\nreturn 0;\r\n}\r\nstatic int w9966_setup(struct w9966 *cam, int x1, int y1, int x2, int y2, int w, int h)\r\n{\r\nunsigned int i;\r\nunsigned int enh_s, enh_e;\r\nunsigned char scale_x, scale_y;\r\nunsigned char regs[0x1c];\r\nunsigned char saa7111_regs[] = {\r\n0x21, 0x00, 0xd8, 0x23, 0x00, 0x80, 0x80, 0x00,\r\n0x88, 0x10, 0x80, 0x40, 0x40, 0x00, 0x01, 0x00,\r\n0x48, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x71, 0xe7, 0x00, 0x00, 0xc0\r\n};\r\nif (w * h * 2 > W9966_SRAMSIZE) {\r\nDPRINTF("capture window exceeds SRAM size!.\n");\r\nw = 200; h = 160;\r\n}\r\nw &= ~0x1;\r\nif (w < 2)\r\nw = 2;\r\nif (h < 1)\r\nh = 1;\r\nif (w > W9966_WND_MAX_W)\r\nw = W9966_WND_MAX_W;\r\nif (h > W9966_WND_MAX_H)\r\nh = W9966_WND_MAX_H;\r\ncam->width = w;\r\ncam->height = h;\r\nenh_s = 0;\r\nenh_e = w * h * 2;\r\nif (w9966_calcscale(w, W9966_WND_MIN_X, W9966_WND_MAX_X, &x1, &x2, &scale_x) != 0 ||\r\nw9966_calcscale(h, W9966_WND_MIN_Y, W9966_WND_MAX_Y, &y1, &y2, &scale_y) != 0)\r\nreturn -1;\r\nDPRINTF("%dx%d, x: %d<->%d, y: %d<->%d, sx: %d/64, sy: %d/64.\n",\r\nw, h, x1, x2, y1, y2, scale_x & ~0x80, scale_y & ~0x80);\r\nregs[0x00] = 0x00;\r\nregs[0x01] = 0x18;\r\nregs[0x02] = scale_y;\r\nregs[0x03] = scale_x;\r\nregs[0x04] = (x1 & 0x0ff);\r\nregs[0x05] = (x1 & 0x300)>>8;\r\nregs[0x06] = (y1 & 0x0ff);\r\nregs[0x07] = (y1 & 0x300)>>8;\r\nregs[0x08] = (x2 & 0x0ff);\r\nregs[0x09] = (x2 & 0x300)>>8;\r\nregs[0x0a] = (y2 & 0x0ff);\r\nregs[0x0c] = W9966_SRAMID;\r\nregs[0x0d] = (enh_s & 0x000ff);\r\nregs[0x0e] = (enh_s & 0x0ff00) >> 8;\r\nregs[0x0f] = (enh_s & 0x70000) >> 16;\r\nregs[0x10] = (enh_e & 0x000ff);\r\nregs[0x11] = (enh_e & 0x0ff00) >> 8;\r\nregs[0x12] = (enh_e & 0x70000) >> 16;\r\nregs[0x13] = 0x40;\r\nregs[0x17] = 0x00;\r\nregs[0x18] = cam->i2c_state = 0x00;\r\nregs[0x19] = 0xff;\r\nregs[0x1a] = 0xff;\r\nregs[0x1b] = 0x10;\r\nsaa7111_regs[0x0a] = cam->brightness;\r\nsaa7111_regs[0x0b] = cam->contrast;\r\nsaa7111_regs[0x0c] = cam->color;\r\nsaa7111_regs[0x0d] = cam->hue;\r\nif (w9966_write_reg(cam, 0x00, 0x03) == -1)\r\nreturn -1;\r\nfor (i = 0; i < 0x1c; i++)\r\nif (w9966_write_reg(cam, i, regs[i]) == -1)\r\nreturn -1;\r\nfor (i = 0; i < 0x20; i++)\r\nif (w9966_write_reg_i2c(cam, i, saa7111_regs[i]) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int cam_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *vcap)\r\n{\r\nstruct w9966 *cam = video_drvdata(file);\r\nstrlcpy(vcap->driver, cam->v4l2_dev.name, sizeof(vcap->driver));\r\nstrlcpy(vcap->card, W9966_DRIVERNAME, sizeof(vcap->card));\r\nstrlcpy(vcap->bus_info, "parport", sizeof(vcap->bus_info));\r\nvcap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE;\r\nvcap->capabilities = vcap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int cam_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\r\n{\r\nif (vin->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(vin->name, "Camera", sizeof(vin->name));\r\nvin->type = V4L2_INPUT_TYPE_CAMERA;\r\nvin->audioset = 0;\r\nvin->tuner = 0;\r\nvin->std = 0;\r\nvin->status = 0;\r\nreturn 0;\r\n}\r\nstatic int cam_g_input(struct file *file, void *fh, unsigned int *inp)\r\n{\r\n*inp = 0;\r\nreturn 0;\r\n}\r\nstatic int cam_s_input(struct file *file, void *fh, unsigned int inp)\r\n{\r\nreturn (inp > 0) ? -EINVAL : 0;\r\n}\r\nstatic int cam_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct w9966 *cam =\r\ncontainer_of(ctrl->handler, struct w9966, hdl);\r\nint ret = 0;\r\nmutex_lock(&cam->lock);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncam->brightness = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ncam->contrast = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ncam->color = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ncam->hue = ctrl->val;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret == 0) {\r\nw9966_pdev_claim(cam);\r\nif (w9966_write_reg_i2c(cam, 0x0a, cam->brightness) == -1 ||\r\nw9966_write_reg_i2c(cam, 0x0b, cam->contrast) == -1 ||\r\nw9966_write_reg_i2c(cam, 0x0c, cam->color) == -1 ||\r\nw9966_write_reg_i2c(cam, 0x0d, cam->hue) == -1) {\r\nret = -EIO;\r\n}\r\nw9966_pdev_release(cam);\r\n}\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int cam_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct w9966 *cam = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\npix->width = cam->width;\r\npix->height = cam->height;\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = 2 * cam->width;\r\npix->sizeimage = 2 * cam->width * cam->height;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int cam_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nif (pix->width < 2)\r\npix->width = 2;\r\nif (pix->height < 1)\r\npix->height = 1;\r\nif (pix->width > W9966_WND_MAX_W)\r\npix->width = W9966_WND_MAX_W;\r\nif (pix->height > W9966_WND_MAX_H)\r\npix->height = W9966_WND_MAX_H;\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = 2 * pix->width;\r\npix->sizeimage = 2 * pix->width * pix->height;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int cam_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct w9966 *cam = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nint ret = cam_try_fmt_vid_cap(file, fh, fmt);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&cam->lock);\r\nw9966_pdev_claim(cam);\r\nret = w9966_setup(cam, 0, 0, 1023, 1023, pix->width, pix->height);\r\nw9966_pdev_release(cam);\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int cam_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\r\n{\r\nstatic struct v4l2_fmtdesc formats[] = {\r\n{ 0, 0, 0,\r\n"YUV 4:2:2", V4L2_PIX_FMT_YUYV,\r\n{ 0, 0, 0, 0 }\r\n},\r\n};\r\nenum v4l2_buf_type type = fmt->type;\r\nif (fmt->index > 0)\r\nreturn -EINVAL;\r\n*fmt = formats[fmt->index];\r\nfmt->type = type;\r\nreturn 0;\r\n}\r\nstatic ssize_t w9966_v4l_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct w9966 *cam = video_drvdata(file);\r\nunsigned char addr = 0xa0;\r\nunsigned char __user *dest = (unsigned char __user *)buf;\r\nunsigned long dleft = count;\r\nunsigned char *tbuf;\r\nif (count > cam->width * cam->height * 2)\r\nreturn -EINVAL;\r\nmutex_lock(&cam->lock);\r\nw9966_pdev_claim(cam);\r\nw9966_write_reg(cam, 0x00, 0x02);\r\nw9966_write_reg(cam, 0x00, 0x00);\r\nw9966_write_reg(cam, 0x01, 0x98);\r\nif ((parport_negotiate(cam->pport, cam->ppmode|IEEE1284_ADDR) != 0) ||\r\n(parport_write(cam->pport, &addr, 1) != 1) ||\r\n(parport_negotiate(cam->pport, cam->ppmode|IEEE1284_DATA) != 0)) {\r\nw9966_pdev_release(cam);\r\nmutex_unlock(&cam->lock);\r\nreturn -EFAULT;\r\n}\r\ntbuf = kmalloc(W9966_RBUFFER, GFP_KERNEL);\r\nif (tbuf == NULL) {\r\ncount = -ENOMEM;\r\ngoto out;\r\n}\r\nwhile (dleft > 0) {\r\nunsigned long tsize = (dleft > W9966_RBUFFER) ? W9966_RBUFFER : dleft;\r\nif (parport_read(cam->pport, tbuf, tsize) < tsize) {\r\ncount = -EFAULT;\r\ngoto out;\r\n}\r\nif (copy_to_user(dest, tbuf, tsize) != 0) {\r\ncount = -EFAULT;\r\ngoto out;\r\n}\r\ndest += tsize;\r\ndleft -= tsize;\r\n}\r\nw9966_write_reg(cam, 0x01, 0x18);\r\nout:\r\nkfree(tbuf);\r\nw9966_pdev_release(cam);\r\nmutex_unlock(&cam->lock);\r\nreturn count;\r\n}\r\nstatic int w9966_init(struct w9966 *cam, struct parport *port)\r\n{\r\nstruct v4l2_device *v4l2_dev = &cam->v4l2_dev;\r\nif (cam->dev_state != 0)\r\nreturn -1;\r\nstrlcpy(v4l2_dev->name, "w9966", sizeof(v4l2_dev->name));\r\nif (v4l2_device_register(NULL, v4l2_dev) < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nreturn -1;\r\n}\r\nv4l2_ctrl_handler_init(&cam->hdl, 4);\r\nv4l2_ctrl_new_std(&cam->hdl, &cam_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&cam->hdl, &cam_ctrl_ops,\r\nV4L2_CID_CONTRAST, -64, 64, 1, 64);\r\nv4l2_ctrl_new_std(&cam->hdl, &cam_ctrl_ops,\r\nV4L2_CID_SATURATION, -64, 64, 1, 64);\r\nv4l2_ctrl_new_std(&cam->hdl, &cam_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nif (cam->hdl.error) {\r\nv4l2_err(v4l2_dev, "couldn't register controls\n");\r\nreturn -1;\r\n}\r\ncam->pport = port;\r\ncam->brightness = 128;\r\ncam->contrast = 64;\r\ncam->color = 64;\r\ncam->hue = 0;\r\nswitch (parmode) {\r\ndefault:\r\ncase 0:\r\nif (port->modes & PARPORT_MODE_ECP)\r\ncam->ppmode = IEEE1284_MODE_ECP;\r\nelse if (port->modes & PARPORT_MODE_EPP)\r\ncam->ppmode = IEEE1284_MODE_EPP;\r\nelse\r\ncam->ppmode = IEEE1284_MODE_ECP;\r\nbreak;\r\ncase 1:\r\ncam->ppmode = IEEE1284_MODE_ECP;\r\nbreak;\r\ncase 2:\r\ncam->ppmode = IEEE1284_MODE_EPP;\r\nbreak;\r\n}\r\ncam->pdev = parport_register_device(port, "w9966", NULL, NULL, NULL, 0, NULL);\r\nif (cam->pdev == NULL) {\r\nDPRINTF("parport_register_device() failed\n");\r\nreturn -1;\r\n}\r\nw9966_set_state(cam, W9966_STATE_PDEV, W9966_STATE_PDEV);\r\nw9966_pdev_claim(cam);\r\nif (w9966_setup(cam, 0, 0, 1023, 1023, 200, 160) != 0) {\r\nDPRINTF("w9966_setup() failed.\n");\r\nreturn -1;\r\n}\r\nw9966_pdev_release(cam);\r\nstrlcpy(cam->vdev.name, W9966_DRIVERNAME, sizeof(cam->vdev.name));\r\ncam->vdev.v4l2_dev = v4l2_dev;\r\ncam->vdev.fops = &w9966_fops;\r\ncam->vdev.ioctl_ops = &w9966_ioctl_ops;\r\ncam->vdev.release = video_device_release_empty;\r\ncam->vdev.ctrl_handler = &cam->hdl;\r\nvideo_set_drvdata(&cam->vdev, cam);\r\nmutex_init(&cam->lock);\r\nif (video_register_device(&cam->vdev, VFL_TYPE_GRABBER, video_nr) < 0)\r\nreturn -1;\r\nw9966_set_state(cam, W9966_STATE_VDEV, W9966_STATE_VDEV);\r\nv4l2_info(v4l2_dev, "Found and initialized a webcam on %s.\n",\r\ncam->pport->name);\r\nreturn 0;\r\n}\r\nstatic void w9966_term(struct w9966 *cam)\r\n{\r\nif (w9966_get_state(cam, W9966_STATE_VDEV, W9966_STATE_VDEV)) {\r\nvideo_unregister_device(&cam->vdev);\r\nw9966_set_state(cam, W9966_STATE_VDEV, 0);\r\n}\r\nv4l2_ctrl_handler_free(&cam->hdl);\r\nif (w9966_get_state(cam, W9966_STATE_PDEV, W9966_STATE_PDEV)) {\r\nw9966_pdev_claim(cam);\r\nparport_negotiate(cam->pport, IEEE1284_MODE_COMPAT);\r\nw9966_pdev_release(cam);\r\n}\r\nif (w9966_get_state(cam, W9966_STATE_PDEV, W9966_STATE_PDEV)) {\r\nparport_unregister_device(cam->pdev);\r\nw9966_set_state(cam, W9966_STATE_PDEV, 0);\r\n}\r\nmemset(cam, 0, sizeof(*cam));\r\n}\r\nstatic void w9966_attach(struct parport *port)\r\n{\r\nint i;\r\nfor (i = 0; i < W9966_MAXCAMS; i++) {\r\nif (w9966_cams[i].dev_state != 0)\r\ncontinue;\r\nif (strcmp(pardev[i], "aggressive") == 0 || strcmp(pardev[i], port->name) == 0) {\r\nif (w9966_init(&w9966_cams[i], port) != 0)\r\nw9966_term(&w9966_cams[i]);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void w9966_detach(struct parport *port)\r\n{\r\nint i;\r\nfor (i = 0; i < W9966_MAXCAMS; i++)\r\nif (w9966_cams[i].dev_state != 0 && w9966_cams[i].pport == port)\r\nw9966_term(&w9966_cams[i]);\r\n}\r\nstatic int __init w9966_mod_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < W9966_MAXCAMS; i++)\r\nw9966_cams[i].dev_state = 0;\r\nreturn parport_register_driver(&w9966_ppd);\r\n}\r\nstatic void __exit w9966_mod_term(void)\r\n{\r\nparport_unregister_driver(&w9966_ppd);\r\n}
