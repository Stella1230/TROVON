static inline u32 am33xx_cm_read_reg(u16 inst, u16 idx)\r\n{\r\nreturn readl_relaxed(cm_base + inst + idx);\r\n}\r\nstatic inline void am33xx_cm_write_reg(u32 val, u16 inst, u16 idx)\r\n{\r\nwritel_relaxed(val, cm_base + inst + idx);\r\n}\r\nstatic inline u32 am33xx_cm_rmw_reg_bits(u32 mask, u32 bits, s16 inst, s16 idx)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, idx);\r\nv &= ~mask;\r\nv |= bits;\r\nam33xx_cm_write_reg(v, inst, idx);\r\nreturn v;\r\n}\r\nstatic inline u32 am33xx_cm_set_reg_bits(u32 bits, s16 inst, s16 idx)\r\n{\r\nreturn am33xx_cm_rmw_reg_bits(bits, bits, inst, idx);\r\n}\r\nstatic inline u32 am33xx_cm_clear_reg_bits(u32 bits, s16 inst, s16 idx)\r\n{\r\nreturn am33xx_cm_rmw_reg_bits(bits, 0x0, inst, idx);\r\n}\r\nstatic inline u32 am33xx_cm_read_reg_bits(u16 inst, s16 idx, u32 mask)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, idx);\r\nv &= mask;\r\nv >>= __ffs(mask);\r\nreturn v;\r\n}\r\nstatic u32 _clkctrl_idlest(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nu32 v = am33xx_cm_read_reg(inst, clkctrl_offs);\r\nv &= AM33XX_IDLEST_MASK;\r\nv >>= AM33XX_IDLEST_SHIFT;\r\nreturn v;\r\n}\r\nstatic bool _is_module_ready(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = _clkctrl_idlest(inst, cdoffs, clkctrl_offs);\r\nreturn (v == CLKCTRL_IDLEST_FUNCTIONAL ||\r\nv == CLKCTRL_IDLEST_INTERFACE_IDLE) ? true : false;\r\n}\r\nstatic void _clktrctrl_write(u8 c, u16 inst, u16 cdoffs)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, cdoffs);\r\nv &= ~AM33XX_CLKTRCTRL_MASK;\r\nv |= c << AM33XX_CLKTRCTRL_SHIFT;\r\nam33xx_cm_write_reg(v, inst, cdoffs);\r\n}\r\nbool am33xx_cm_is_clkdm_in_hwsup(u16 inst, u16 cdoffs)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, cdoffs);\r\nv &= AM33XX_CLKTRCTRL_MASK;\r\nv >>= AM33XX_CLKTRCTRL_SHIFT;\r\nreturn (v == OMAP34XX_CLKSTCTRL_ENABLE_AUTO) ? true : false;\r\n}\r\nvoid am33xx_cm_clkdm_enable_hwsup(u16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_ENABLE_AUTO, inst, cdoffs);\r\n}\r\nvoid am33xx_cm_clkdm_disable_hwsup(u16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_DISABLE_AUTO, inst, cdoffs);\r\n}\r\nvoid am33xx_cm_clkdm_force_sleep(u16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_FORCE_SLEEP, inst, cdoffs);\r\n}\r\nvoid am33xx_cm_clkdm_force_wakeup(u16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_FORCE_WAKEUP, inst, cdoffs);\r\n}\r\nint am33xx_cm_wait_module_ready(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nint i = 0;\r\nomap_test_timeout(_is_module_ready(inst, cdoffs, clkctrl_offs),\r\nMAX_MODULE_READY_TIME, i);\r\nreturn (i < MAX_MODULE_READY_TIME) ? 0 : -EBUSY;\r\n}\r\nint am33xx_cm_wait_module_idle(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nint i = 0;\r\nif (!clkctrl_offs)\r\nreturn 0;\r\nomap_test_timeout((_clkctrl_idlest(inst, cdoffs, clkctrl_offs) ==\r\nCLKCTRL_IDLEST_DISABLED),\r\nMAX_MODULE_READY_TIME, i);\r\nreturn (i < MAX_MODULE_READY_TIME) ? 0 : -EBUSY;\r\n}\r\nvoid am33xx_cm_module_enable(u8 mode, u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, clkctrl_offs);\r\nv &= ~AM33XX_MODULEMODE_MASK;\r\nv |= mode << AM33XX_MODULEMODE_SHIFT;\r\nam33xx_cm_write_reg(v, inst, clkctrl_offs);\r\n}\r\nvoid am33xx_cm_module_disable(u16 inst, s16 cdoffs, u16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = am33xx_cm_read_reg(inst, clkctrl_offs);\r\nv &= ~AM33XX_MODULEMODE_MASK;\r\nam33xx_cm_write_reg(v, inst, clkctrl_offs);\r\n}\r\nstatic int am33xx_clkdm_sleep(struct clockdomain *clkdm)\r\n{\r\nam33xx_cm_clkdm_force_sleep(clkdm->cm_inst, clkdm->clkdm_offs);\r\nreturn 0;\r\n}\r\nstatic int am33xx_clkdm_wakeup(struct clockdomain *clkdm)\r\n{\r\nam33xx_cm_clkdm_force_wakeup(clkdm->cm_inst, clkdm->clkdm_offs);\r\nreturn 0;\r\n}\r\nstatic void am33xx_clkdm_allow_idle(struct clockdomain *clkdm)\r\n{\r\nam33xx_cm_clkdm_enable_hwsup(clkdm->cm_inst, clkdm->clkdm_offs);\r\n}\r\nstatic void am33xx_clkdm_deny_idle(struct clockdomain *clkdm)\r\n{\r\nam33xx_cm_clkdm_disable_hwsup(clkdm->cm_inst, clkdm->clkdm_offs);\r\n}\r\nstatic int am33xx_clkdm_clk_enable(struct clockdomain *clkdm)\r\n{\r\nif (clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)\r\nreturn am33xx_clkdm_wakeup(clkdm);\r\nreturn 0;\r\n}\r\nstatic int am33xx_clkdm_clk_disable(struct clockdomain *clkdm)\r\n{\r\nbool hwsup = false;\r\nhwsup = am33xx_cm_is_clkdm_in_hwsup(clkdm->cm_inst, clkdm->clkdm_offs);\r\nif (!hwsup && (clkdm->flags & CLKDM_CAN_FORCE_SLEEP))\r\nam33xx_clkdm_sleep(clkdm);\r\nreturn 0;\r\n}
