static inline struct ep93xx_pwm *to_ep93xx_pwm(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct ep93xx_pwm, chip);\r\n}\r\nstatic int ep93xx_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(chip->dev);\r\nreturn ep93xx_pwm_acquire_gpio(pdev);\r\n}\r\nstatic void ep93xx_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(chip->dev);\r\nep93xx_pwm_release_gpio(pdev);\r\n}\r\nstatic int ep93xx_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct ep93xx_pwm *ep93xx_pwm = to_ep93xx_pwm(chip);\r\nvoid __iomem *base = ep93xx_pwm->base;\r\nunsigned long long c;\r\nunsigned long period_cycles;\r\nunsigned long duty_cycles;\r\nunsigned long term;\r\nint ret = 0;\r\nif (!test_bit(PWMF_ENABLED, &pwm->flags)) {\r\nret = clk_enable(ep93xx_pwm->clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nc = clk_get_rate(ep93xx_pwm->clk);\r\nc *= period_ns;\r\ndo_div(c, 1000000000);\r\nperiod_cycles = c;\r\nc = period_cycles;\r\nc *= duty_ns;\r\ndo_div(c, period_ns);\r\nduty_cycles = c;\r\nif (period_cycles < 0x10000 && duty_cycles < 0x10000) {\r\nterm = readw(base + EP93XX_PWMx_TERM_COUNT);\r\nif (period_cycles > term) {\r\nwritew(period_cycles, base + EP93XX_PWMx_TERM_COUNT);\r\nwritew(duty_cycles, base + EP93XX_PWMx_DUTY_CYCLE);\r\n} else {\r\nwritew(duty_cycles, base + EP93XX_PWMx_DUTY_CYCLE);\r\nwritew(period_cycles, base + EP93XX_PWMx_TERM_COUNT);\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nif (!test_bit(PWMF_ENABLED, &pwm->flags))\r\nclk_disable(ep93xx_pwm->clk);\r\nreturn ret;\r\n}\r\nstatic int ep93xx_pwm_polarity(struct pwm_chip *chip, struct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct ep93xx_pwm *ep93xx_pwm = to_ep93xx_pwm(chip);\r\nint ret;\r\nret = clk_enable(ep93xx_pwm->clk);\r\nif (ret)\r\nreturn ret;\r\nif (polarity == PWM_POLARITY_INVERSED)\r\nwritew(0x1, ep93xx_pwm->base + EP93XX_PWMx_INVERT);\r\nelse\r\nwritew(0x0, ep93xx_pwm->base + EP93XX_PWMx_INVERT);\r\nclk_disable(ep93xx_pwm->clk);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct ep93xx_pwm *ep93xx_pwm = to_ep93xx_pwm(chip);\r\nint ret;\r\nret = clk_enable(ep93xx_pwm->clk);\r\nif (ret)\r\nreturn ret;\r\nwritew(0x1, ep93xx_pwm->base + EP93XX_PWMx_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void ep93xx_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct ep93xx_pwm *ep93xx_pwm = to_ep93xx_pwm(chip);\r\nwritew(0x0, ep93xx_pwm->base + EP93XX_PWMx_ENABLE);\r\nclk_disable(ep93xx_pwm->clk);\r\n}\r\nstatic int ep93xx_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_pwm *ep93xx_pwm;\r\nstruct resource *res;\r\nint ret;\r\nep93xx_pwm = devm_kzalloc(&pdev->dev, sizeof(*ep93xx_pwm), GFP_KERNEL);\r\nif (!ep93xx_pwm)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nep93xx_pwm->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ep93xx_pwm->base))\r\nreturn PTR_ERR(ep93xx_pwm->base);\r\nep93xx_pwm->clk = devm_clk_get(&pdev->dev, "pwm_clk");\r\nif (IS_ERR(ep93xx_pwm->clk))\r\nreturn PTR_ERR(ep93xx_pwm->clk);\r\nep93xx_pwm->chip.dev = &pdev->dev;\r\nep93xx_pwm->chip.ops = &ep93xx_pwm_ops;\r\nep93xx_pwm->chip.base = -1;\r\nep93xx_pwm->chip.npwm = 1;\r\nret = pwmchip_add(&ep93xx_pwm->chip);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, ep93xx_pwm);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_pwm *ep93xx_pwm = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&ep93xx_pwm->chip);\r\n}
