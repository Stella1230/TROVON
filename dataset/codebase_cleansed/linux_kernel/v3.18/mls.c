int mls_compute_context_len(struct context *context)\r\n{\r\nint i, l, len, head, prev;\r\nchar *nm;\r\nstruct ebitmap *e;\r\nstruct ebitmap_node *node;\r\nif (!policydb.mls_enabled)\r\nreturn 0;\r\nlen = 1;\r\nfor (l = 0; l < 2; l++) {\r\nint index_sens = context->range.level[l].sens;\r\nlen += strlen(sym_name(&policydb, SYM_LEVELS, index_sens - 1));\r\nhead = -2;\r\nprev = -2;\r\ne = &context->range.level[l].cat;\r\nebitmap_for_each_positive_bit(e, node, i) {\r\nif (i - prev > 1) {\r\nif (head != prev) {\r\nnm = sym_name(&policydb, SYM_CATS, prev);\r\nlen += strlen(nm) + 1;\r\n}\r\nnm = sym_name(&policydb, SYM_CATS, i);\r\nlen += strlen(nm) + 1;\r\nhead = i;\r\n}\r\nprev = i;\r\n}\r\nif (prev != head) {\r\nnm = sym_name(&policydb, SYM_CATS, prev);\r\nlen += strlen(nm) + 1;\r\n}\r\nif (l == 0) {\r\nif (mls_level_eq(&context->range.level[0],\r\n&context->range.level[1]))\r\nbreak;\r\nelse\r\nlen++;\r\n}\r\n}\r\nreturn len;\r\n}\r\nvoid mls_sid_to_context(struct context *context,\r\nchar **scontext)\r\n{\r\nchar *scontextp, *nm;\r\nint i, l, head, prev;\r\nstruct ebitmap *e;\r\nstruct ebitmap_node *node;\r\nif (!policydb.mls_enabled)\r\nreturn;\r\nscontextp = *scontext;\r\n*scontextp = ':';\r\nscontextp++;\r\nfor (l = 0; l < 2; l++) {\r\nstrcpy(scontextp, sym_name(&policydb, SYM_LEVELS,\r\ncontext->range.level[l].sens - 1));\r\nscontextp += strlen(scontextp);\r\nhead = -2;\r\nprev = -2;\r\ne = &context->range.level[l].cat;\r\nebitmap_for_each_positive_bit(e, node, i) {\r\nif (i - prev > 1) {\r\nif (prev != head) {\r\nif (prev - head > 1)\r\n*scontextp++ = '.';\r\nelse\r\n*scontextp++ = ',';\r\nnm = sym_name(&policydb, SYM_CATS, prev);\r\nstrcpy(scontextp, nm);\r\nscontextp += strlen(nm);\r\n}\r\nif (prev < 0)\r\n*scontextp++ = ':';\r\nelse\r\n*scontextp++ = ',';\r\nnm = sym_name(&policydb, SYM_CATS, i);\r\nstrcpy(scontextp, nm);\r\nscontextp += strlen(nm);\r\nhead = i;\r\n}\r\nprev = i;\r\n}\r\nif (prev != head) {\r\nif (prev - head > 1)\r\n*scontextp++ = '.';\r\nelse\r\n*scontextp++ = ',';\r\nnm = sym_name(&policydb, SYM_CATS, prev);\r\nstrcpy(scontextp, nm);\r\nscontextp += strlen(nm);\r\n}\r\nif (l == 0) {\r\nif (mls_level_eq(&context->range.level[0],\r\n&context->range.level[1]))\r\nbreak;\r\nelse\r\n*scontextp++ = '-';\r\n}\r\n}\r\n*scontext = scontextp;\r\nreturn;\r\n}\r\nint mls_level_isvalid(struct policydb *p, struct mls_level *l)\r\n{\r\nstruct level_datum *levdatum;\r\nif (!l->sens || l->sens > p->p_levels.nprim)\r\nreturn 0;\r\nlevdatum = hashtab_search(p->p_levels.table,\r\nsym_name(p, SYM_LEVELS, l->sens - 1));\r\nif (!levdatum)\r\nreturn 0;\r\nreturn ebitmap_contains(&levdatum->level->cat, &l->cat,\r\np->p_cats.nprim);\r\n}\r\nint mls_range_isvalid(struct policydb *p, struct mls_range *r)\r\n{\r\nreturn (mls_level_isvalid(p, &r->level[0]) &&\r\nmls_level_isvalid(p, &r->level[1]) &&\r\nmls_level_dom(&r->level[1], &r->level[0]));\r\n}\r\nint mls_context_isvalid(struct policydb *p, struct context *c)\r\n{\r\nstruct user_datum *usrdatum;\r\nif (!p->mls_enabled)\r\nreturn 1;\r\nif (!mls_range_isvalid(p, &c->range))\r\nreturn 0;\r\nif (c->role == OBJECT_R_VAL)\r\nreturn 1;\r\nif (!c->user || c->user > p->p_users.nprim)\r\nreturn 0;\r\nusrdatum = p->user_val_to_struct[c->user - 1];\r\nif (!mls_range_contains(usrdatum->range, c->range))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint mls_context_to_sid(struct policydb *pol,\r\nchar oldc,\r\nchar **scontext,\r\nstruct context *context,\r\nstruct sidtab *s,\r\nu32 def_sid)\r\n{\r\nchar delim;\r\nchar *scontextp, *p, *rngptr;\r\nstruct level_datum *levdatum;\r\nstruct cat_datum *catdatum, *rngdatum;\r\nint l, rc = -EINVAL;\r\nif (!pol->mls_enabled) {\r\nif (def_sid != SECSID_NULL && oldc)\r\n*scontext += strlen(*scontext) + 1;\r\nreturn 0;\r\n}\r\nif (!oldc) {\r\nstruct context *defcon;\r\nif (def_sid == SECSID_NULL)\r\ngoto out;\r\ndefcon = sidtab_search(s, def_sid);\r\nif (!defcon)\r\ngoto out;\r\nrc = mls_context_cpy(context, defcon);\r\ngoto out;\r\n}\r\nscontextp = p = *scontext;\r\nwhile (*p && *p != ':' && *p != '-')\r\np++;\r\ndelim = *p;\r\nif (delim != '\0')\r\n*p++ = '\0';\r\nfor (l = 0; l < 2; l++) {\r\nlevdatum = hashtab_search(pol->p_levels.table, scontextp);\r\nif (!levdatum) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ncontext->range.level[l].sens = levdatum->level->sens;\r\nif (delim == ':') {\r\nwhile (1) {\r\nscontextp = p;\r\nwhile (*p && *p != ',' && *p != '-')\r\np++;\r\ndelim = *p;\r\nif (delim != '\0')\r\n*p++ = '\0';\r\nrngptr = strchr(scontextp, '.');\r\nif (rngptr != NULL) {\r\n*rngptr++ = '\0';\r\n}\r\ncatdatum = hashtab_search(pol->p_cats.table,\r\nscontextp);\r\nif (!catdatum) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = ebitmap_set_bit(&context->range.level[l].cat,\r\ncatdatum->value - 1, 1);\r\nif (rc)\r\ngoto out;\r\nif (rngptr) {\r\nint i;\r\nrngdatum = hashtab_search(pol->p_cats.table, rngptr);\r\nif (!rngdatum) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (catdatum->value >= rngdatum->value) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = catdatum->value; i < rngdatum->value; i++) {\r\nrc = ebitmap_set_bit(&context->range.level[l].cat, i, 1);\r\nif (rc)\r\ngoto out;\r\n}\r\n}\r\nif (delim != ',')\r\nbreak;\r\n}\r\n}\r\nif (delim == '-') {\r\nscontextp = p;\r\nwhile (*p && *p != ':')\r\np++;\r\ndelim = *p;\r\nif (delim != '\0')\r\n*p++ = '\0';\r\n} else\r\nbreak;\r\n}\r\nif (l == 0) {\r\ncontext->range.level[1].sens = context->range.level[0].sens;\r\nrc = ebitmap_cpy(&context->range.level[1].cat,\r\n&context->range.level[0].cat);\r\nif (rc)\r\ngoto out;\r\n}\r\n*scontext = ++p;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nint mls_from_string(char *str, struct context *context, gfp_t gfp_mask)\r\n{\r\nchar *tmpstr, *freestr;\r\nint rc;\r\nif (!policydb.mls_enabled)\r\nreturn -EINVAL;\r\ntmpstr = freestr = kstrdup(str, gfp_mask);\r\nif (!tmpstr) {\r\nrc = -ENOMEM;\r\n} else {\r\nrc = mls_context_to_sid(&policydb, ':', &tmpstr, context,\r\nNULL, SECSID_NULL);\r\nkfree(freestr);\r\n}\r\nreturn rc;\r\n}\r\nint mls_range_set(struct context *context,\r\nstruct mls_range *range)\r\n{\r\nint l, rc = 0;\r\nfor (l = 0; l < 2; l++) {\r\ncontext->range.level[l].sens = range->level[l].sens;\r\nrc = ebitmap_cpy(&context->range.level[l].cat,\r\n&range->level[l].cat);\r\nif (rc)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint mls_setup_user_range(struct context *fromcon, struct user_datum *user,\r\nstruct context *usercon)\r\n{\r\nif (policydb.mls_enabled) {\r\nstruct mls_level *fromcon_sen = &(fromcon->range.level[0]);\r\nstruct mls_level *fromcon_clr = &(fromcon->range.level[1]);\r\nstruct mls_level *user_low = &(user->range.level[0]);\r\nstruct mls_level *user_clr = &(user->range.level[1]);\r\nstruct mls_level *user_def = &(user->dfltlevel);\r\nstruct mls_level *usercon_sen = &(usercon->range.level[0]);\r\nstruct mls_level *usercon_clr = &(usercon->range.level[1]);\r\nif (mls_level_between(user_def, fromcon_sen, fromcon_clr))\r\n*usercon_sen = *user_def;\r\nelse if (mls_level_between(fromcon_sen, user_def, user_clr))\r\n*usercon_sen = *fromcon_sen;\r\nelse if (mls_level_between(fromcon_clr, user_low, user_def))\r\n*usercon_sen = *user_low;\r\nelse\r\nreturn -EINVAL;\r\nif (mls_level_dom(user_clr, fromcon_clr))\r\n*usercon_clr = *fromcon_clr;\r\nelse if (mls_level_dom(fromcon_clr, user_clr))\r\n*usercon_clr = *user_clr;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint mls_convert_context(struct policydb *oldp,\r\nstruct policydb *newp,\r\nstruct context *c)\r\n{\r\nstruct level_datum *levdatum;\r\nstruct cat_datum *catdatum;\r\nstruct ebitmap bitmap;\r\nstruct ebitmap_node *node;\r\nint l, i;\r\nif (!policydb.mls_enabled)\r\nreturn 0;\r\nfor (l = 0; l < 2; l++) {\r\nlevdatum = hashtab_search(newp->p_levels.table,\r\nsym_name(oldp, SYM_LEVELS,\r\nc->range.level[l].sens - 1));\r\nif (!levdatum)\r\nreturn -EINVAL;\r\nc->range.level[l].sens = levdatum->level->sens;\r\nebitmap_init(&bitmap);\r\nebitmap_for_each_positive_bit(&c->range.level[l].cat, node, i) {\r\nint rc;\r\ncatdatum = hashtab_search(newp->p_cats.table,\r\nsym_name(oldp, SYM_CATS, i));\r\nif (!catdatum)\r\nreturn -EINVAL;\r\nrc = ebitmap_set_bit(&bitmap, catdatum->value - 1, 1);\r\nif (rc)\r\nreturn rc;\r\ncond_resched();\r\n}\r\nebitmap_destroy(&c->range.level[l].cat);\r\nc->range.level[l].cat = bitmap;\r\n}\r\nreturn 0;\r\n}\r\nint mls_compute_sid(struct context *scontext,\r\nstruct context *tcontext,\r\nu16 tclass,\r\nu32 specified,\r\nstruct context *newcontext,\r\nbool sock)\r\n{\r\nstruct range_trans rtr;\r\nstruct mls_range *r;\r\nstruct class_datum *cladatum;\r\nint default_range = 0;\r\nif (!policydb.mls_enabled)\r\nreturn 0;\r\nswitch (specified) {\r\ncase AVTAB_TRANSITION:\r\nrtr.source_type = scontext->type;\r\nrtr.target_type = tcontext->type;\r\nrtr.target_class = tclass;\r\nr = hashtab_search(policydb.range_tr, &rtr);\r\nif (r)\r\nreturn mls_range_set(newcontext, r);\r\nif (tclass && tclass <= policydb.p_classes.nprim) {\r\ncladatum = policydb.class_val_to_struct[tclass - 1];\r\nif (cladatum)\r\ndefault_range = cladatum->default_range;\r\n}\r\nswitch (default_range) {\r\ncase DEFAULT_SOURCE_LOW:\r\nreturn mls_context_cpy_low(newcontext, scontext);\r\ncase DEFAULT_SOURCE_HIGH:\r\nreturn mls_context_cpy_high(newcontext, scontext);\r\ncase DEFAULT_SOURCE_LOW_HIGH:\r\nreturn mls_context_cpy(newcontext, scontext);\r\ncase DEFAULT_TARGET_LOW:\r\nreturn mls_context_cpy_low(newcontext, tcontext);\r\ncase DEFAULT_TARGET_HIGH:\r\nreturn mls_context_cpy_high(newcontext, tcontext);\r\ncase DEFAULT_TARGET_LOW_HIGH:\r\nreturn mls_context_cpy(newcontext, tcontext);\r\n}\r\ncase AVTAB_CHANGE:\r\nif ((tclass == policydb.process_class) || (sock == true))\r\nreturn mls_context_cpy(newcontext, scontext);\r\nelse\r\nreturn mls_context_cpy_low(newcontext, scontext);\r\ncase AVTAB_MEMBER:\r\nreturn mls_context_cpy_low(newcontext, scontext);\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid mls_export_netlbl_lvl(struct context *context,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nif (!policydb.mls_enabled)\r\nreturn;\r\nsecattr->attr.mls.lvl = context->range.level[0].sens - 1;\r\nsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\r\n}\r\nvoid mls_import_netlbl_lvl(struct context *context,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nif (!policydb.mls_enabled)\r\nreturn;\r\ncontext->range.level[0].sens = secattr->attr.mls.lvl + 1;\r\ncontext->range.level[1].sens = context->range.level[0].sens;\r\n}\r\nint mls_export_netlbl_cat(struct context *context,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nint rc;\r\nif (!policydb.mls_enabled)\r\nreturn 0;\r\nrc = ebitmap_netlbl_export(&context->range.level[0].cat,\r\n&secattr->attr.mls.cat);\r\nif (rc == 0 && secattr->attr.mls.cat != NULL)\r\nsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\r\nreturn rc;\r\n}\r\nint mls_import_netlbl_cat(struct context *context,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nint rc;\r\nif (!policydb.mls_enabled)\r\nreturn 0;\r\nrc = ebitmap_netlbl_import(&context->range.level[0].cat,\r\nsecattr->attr.mls.cat);\r\nif (rc != 0)\r\ngoto import_netlbl_cat_failure;\r\nrc = ebitmap_cpy(&context->range.level[1].cat,\r\n&context->range.level[0].cat);\r\nif (rc != 0)\r\ngoto import_netlbl_cat_failure;\r\nreturn 0;\r\nimport_netlbl_cat_failure:\r\nebitmap_destroy(&context->range.level[0].cat);\r\nebitmap_destroy(&context->range.level[1].cat);\r\nreturn rc;\r\n}
