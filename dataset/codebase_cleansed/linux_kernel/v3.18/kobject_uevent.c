int kobject_action_type(const char *buf, size_t count,\r\nenum kobject_action *type)\r\n{\r\nenum kobject_action action;\r\nint ret = -EINVAL;\r\nif (count && (buf[count-1] == '\n' || buf[count-1] == '\0'))\r\ncount--;\r\nif (!count)\r\ngoto out;\r\nfor (action = 0; action < ARRAY_SIZE(kobject_actions); action++) {\r\nif (strncmp(kobject_actions[action], buf, count) != 0)\r\ncontinue;\r\nif (kobject_actions[action][count] != '\0')\r\ncontinue;\r\n*type = action;\r\nret = 0;\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int kobj_bcast_filter(struct sock *dsk, struct sk_buff *skb, void *data)\r\n{\r\nstruct kobject *kobj = data, *ksobj;\r\nconst struct kobj_ns_type_operations *ops;\r\nops = kobj_ns_ops(kobj);\r\nif (!ops && kobj->kset) {\r\nksobj = &kobj->kset->kobj;\r\nif (ksobj->parent != NULL)\r\nops = kobj_ns_ops(ksobj->parent);\r\n}\r\nif (ops && ops->netlink_ns && kobj->ktype->namespace) {\r\nconst void *sock_ns, *ns;\r\nns = kobj->ktype->namespace(kobj);\r\nsock_ns = ops->netlink_ns(dsk);\r\nreturn sock_ns != ns;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kobj_usermode_filter(struct kobject *kobj)\r\n{\r\nconst struct kobj_ns_type_operations *ops;\r\nops = kobj_ns_ops(kobj);\r\nif (ops) {\r\nconst void *init_ns, *ns;\r\nns = kobj->ktype->namespace(kobj);\r\ninit_ns = ops->initial_ns();\r\nreturn ns != init_ns;\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_uevent_argv(struct kobj_uevent_env *env, const char *subsystem)\r\n{\r\nint len;\r\nlen = strlcpy(&env->buf[env->buflen], subsystem,\r\nsizeof(env->buf) - env->buflen);\r\nif (len >= (sizeof(env->buf) - env->buflen)) {\r\nWARN(1, KERN_ERR "init_uevent_argv: buffer size too small\n");\r\nreturn -ENOMEM;\r\n}\r\nenv->argv[0] = uevent_helper;\r\nenv->argv[1] = &env->buf[env->buflen];\r\nenv->argv[2] = NULL;\r\nenv->buflen += len + 1;\r\nreturn 0;\r\n}\r\nstatic void cleanup_uevent_env(struct subprocess_info *info)\r\n{\r\nkfree(info->data);\r\n}\r\nint kobject_uevent_env(struct kobject *kobj, enum kobject_action action,\r\nchar *envp_ext[])\r\n{\r\nstruct kobj_uevent_env *env;\r\nconst char *action_string = kobject_actions[action];\r\nconst char *devpath = NULL;\r\nconst char *subsystem;\r\nstruct kobject *top_kobj;\r\nstruct kset *kset;\r\nconst struct kset_uevent_ops *uevent_ops;\r\nint i = 0;\r\nint retval = 0;\r\n#ifdef CONFIG_NET\r\nstruct uevent_sock *ue_sk;\r\n#endif\r\npr_debug("kobject: '%s' (%p): %s\n",\r\nkobject_name(kobj), kobj, __func__);\r\ntop_kobj = kobj;\r\nwhile (!top_kobj->kset && top_kobj->parent)\r\ntop_kobj = top_kobj->parent;\r\nif (!top_kobj->kset) {\r\npr_debug("kobject: '%s' (%p): %s: attempted to send uevent "\r\n"without kset!\n", kobject_name(kobj), kobj,\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nkset = top_kobj->kset;\r\nuevent_ops = kset->uevent_ops;\r\nif (kobj->uevent_suppress) {\r\npr_debug("kobject: '%s' (%p): %s: uevent_suppress "\r\n"caused the event to drop!\n",\r\nkobject_name(kobj), kobj, __func__);\r\nreturn 0;\r\n}\r\nif (uevent_ops && uevent_ops->filter)\r\nif (!uevent_ops->filter(kset, kobj)) {\r\npr_debug("kobject: '%s' (%p): %s: filter function "\r\n"caused the event to drop!\n",\r\nkobject_name(kobj), kobj, __func__);\r\nreturn 0;\r\n}\r\nif (uevent_ops && uevent_ops->name)\r\nsubsystem = uevent_ops->name(kset, kobj);\r\nelse\r\nsubsystem = kobject_name(&kset->kobj);\r\nif (!subsystem) {\r\npr_debug("kobject: '%s' (%p): %s: unset subsystem caused the "\r\n"event to drop!\n", kobject_name(kobj), kobj,\r\n__func__);\r\nreturn 0;\r\n}\r\nenv = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);\r\nif (!env)\r\nreturn -ENOMEM;\r\ndevpath = kobject_get_path(kobj, GFP_KERNEL);\r\nif (!devpath) {\r\nretval = -ENOENT;\r\ngoto exit;\r\n}\r\nretval = add_uevent_var(env, "ACTION=%s", action_string);\r\nif (retval)\r\ngoto exit;\r\nretval = add_uevent_var(env, "DEVPATH=%s", devpath);\r\nif (retval)\r\ngoto exit;\r\nretval = add_uevent_var(env, "SUBSYSTEM=%s", subsystem);\r\nif (retval)\r\ngoto exit;\r\nif (envp_ext) {\r\nfor (i = 0; envp_ext[i]; i++) {\r\nretval = add_uevent_var(env, "%s", envp_ext[i]);\r\nif (retval)\r\ngoto exit;\r\n}\r\n}\r\nif (uevent_ops && uevent_ops->uevent) {\r\nretval = uevent_ops->uevent(kset, kobj, env);\r\nif (retval) {\r\npr_debug("kobject: '%s' (%p): %s: uevent() returned "\r\n"%d\n", kobject_name(kobj), kobj,\r\n__func__, retval);\r\ngoto exit;\r\n}\r\n}\r\nif (action == KOBJ_ADD)\r\nkobj->state_add_uevent_sent = 1;\r\nelse if (action == KOBJ_REMOVE)\r\nkobj->state_remove_uevent_sent = 1;\r\nmutex_lock(&uevent_sock_mutex);\r\nretval = add_uevent_var(env, "SEQNUM=%llu", (unsigned long long)++uevent_seqnum);\r\nif (retval) {\r\nmutex_unlock(&uevent_sock_mutex);\r\ngoto exit;\r\n}\r\n#if defined(CONFIG_NET)\r\nlist_for_each_entry(ue_sk, &uevent_sock_list, list) {\r\nstruct sock *uevent_sock = ue_sk->sk;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nif (!netlink_has_listeners(uevent_sock, 1))\r\ncontinue;\r\nlen = strlen(action_string) + strlen(devpath) + 2;\r\nskb = alloc_skb(len + env->buflen, GFP_KERNEL);\r\nif (skb) {\r\nchar *scratch;\r\nscratch = skb_put(skb, len);\r\nsprintf(scratch, "%s@%s", action_string, devpath);\r\nfor (i = 0; i < env->envp_idx; i++) {\r\nlen = strlen(env->envp[i]) + 1;\r\nscratch = skb_put(skb, len);\r\nstrcpy(scratch, env->envp[i]);\r\n}\r\nNETLINK_CB(skb).dst_group = 1;\r\nretval = netlink_broadcast_filtered(uevent_sock, skb,\r\n0, 1, GFP_KERNEL,\r\nkobj_bcast_filter,\r\nkobj);\r\nif (retval == -ENOBUFS || retval == -ESRCH)\r\nretval = 0;\r\n} else\r\nretval = -ENOMEM;\r\n}\r\n#endif\r\nmutex_unlock(&uevent_sock_mutex);\r\n#ifdef CONFIG_UEVENT_HELPER\r\nif (uevent_helper[0] && !kobj_usermode_filter(kobj)) {\r\nstruct subprocess_info *info;\r\nretval = add_uevent_var(env, "HOME=/");\r\nif (retval)\r\ngoto exit;\r\nretval = add_uevent_var(env,\r\n"PATH=/sbin:/bin:/usr/sbin:/usr/bin");\r\nif (retval)\r\ngoto exit;\r\nretval = init_uevent_argv(env, subsystem);\r\nif (retval)\r\ngoto exit;\r\nretval = -ENOMEM;\r\ninfo = call_usermodehelper_setup(env->argv[0], env->argv,\r\nenv->envp, GFP_KERNEL,\r\nNULL, cleanup_uevent_env, env);\r\nif (info) {\r\nretval = call_usermodehelper_exec(info, UMH_NO_WAIT);\r\nenv = NULL;\r\n}\r\n}\r\n#endif\r\nexit:\r\nkfree(devpath);\r\nkfree(env);\r\nreturn retval;\r\n}\r\nint kobject_uevent(struct kobject *kobj, enum kobject_action action)\r\n{\r\nreturn kobject_uevent_env(kobj, action, NULL);\r\n}\r\nint add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)\r\n{\r\nva_list args;\r\nint len;\r\nif (env->envp_idx >= ARRAY_SIZE(env->envp)) {\r\nWARN(1, KERN_ERR "add_uevent_var: too many keys\n");\r\nreturn -ENOMEM;\r\n}\r\nva_start(args, format);\r\nlen = vsnprintf(&env->buf[env->buflen],\r\nsizeof(env->buf) - env->buflen,\r\nformat, args);\r\nva_end(args);\r\nif (len >= (sizeof(env->buf) - env->buflen)) {\r\nWARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");\r\nreturn -ENOMEM;\r\n}\r\nenv->envp[env->envp_idx++] = &env->buf[env->buflen];\r\nenv->buflen += len + 1;\r\nreturn 0;\r\n}\r\nstatic int uevent_net_init(struct net *net)\r\n{\r\nstruct uevent_sock *ue_sk;\r\nstruct netlink_kernel_cfg cfg = {\r\n.groups = 1,\r\n.flags = NL_CFG_F_NONROOT_RECV,\r\n};\r\nue_sk = kzalloc(sizeof(*ue_sk), GFP_KERNEL);\r\nif (!ue_sk)\r\nreturn -ENOMEM;\r\nue_sk->sk = netlink_kernel_create(net, NETLINK_KOBJECT_UEVENT, &cfg);\r\nif (!ue_sk->sk) {\r\nprintk(KERN_ERR\r\n"kobject_uevent: unable to create netlink socket!\n");\r\nkfree(ue_sk);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&uevent_sock_mutex);\r\nlist_add_tail(&ue_sk->list, &uevent_sock_list);\r\nmutex_unlock(&uevent_sock_mutex);\r\nreturn 0;\r\n}\r\nstatic void uevent_net_exit(struct net *net)\r\n{\r\nstruct uevent_sock *ue_sk;\r\nmutex_lock(&uevent_sock_mutex);\r\nlist_for_each_entry(ue_sk, &uevent_sock_list, list) {\r\nif (sock_net(ue_sk->sk) == net)\r\ngoto found;\r\n}\r\nmutex_unlock(&uevent_sock_mutex);\r\nreturn;\r\nfound:\r\nlist_del(&ue_sk->list);\r\nmutex_unlock(&uevent_sock_mutex);\r\nnetlink_kernel_release(ue_sk->sk);\r\nkfree(ue_sk);\r\n}\r\nstatic int __init kobject_uevent_init(void)\r\n{\r\nreturn register_pernet_subsys(&uevent_net_ops);\r\n}
