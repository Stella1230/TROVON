static void lov_req_completion(const struct lu_env *env,\r\nconst struct cl_req_slice *slice, int ioret)\r\n{\r\nstruct lov_req *lr;\r\nlr = cl2lov_req(slice);\r\nOBD_SLAB_FREE_PTR(lr, lov_req_kmem);\r\n}\r\nstatic void *lov_key_init(const struct lu_context *ctx,\r\nstruct lu_context_key *key)\r\n{\r\nstruct lov_thread_info *info;\r\nOBD_SLAB_ALLOC_PTR_GFP(info, lov_thread_kmem, GFP_NOFS);\r\nif (info != NULL)\r\nINIT_LIST_HEAD(&info->lti_closure.clc_list);\r\nelse\r\ninfo = ERR_PTR(-ENOMEM);\r\nreturn info;\r\n}\r\nstatic void lov_key_fini(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\nstruct lov_thread_info *info = data;\r\nLINVRNT(list_empty(&info->lti_closure.clc_list));\r\nOBD_SLAB_FREE_PTR(info, lov_thread_kmem);\r\n}\r\nstatic void *lov_session_key_init(const struct lu_context *ctx,\r\nstruct lu_context_key *key)\r\n{\r\nstruct lov_session *info;\r\nOBD_SLAB_ALLOC_PTR_GFP(info, lov_session_kmem, GFP_NOFS);\r\nif (info == NULL)\r\ninfo = ERR_PTR(-ENOMEM);\r\nreturn info;\r\n}\r\nstatic void lov_session_key_fini(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\nstruct lov_session *info = data;\r\nOBD_SLAB_FREE_PTR(info, lov_session_kmem);\r\n}\r\nstatic struct lu_device *lov_device_fini(const struct lu_env *env,\r\nstruct lu_device *d)\r\n{\r\nint i;\r\nstruct lov_device *ld = lu2lov_dev(d);\r\nLASSERT(ld->ld_lov != NULL);\r\nif (ld->ld_target == NULL)\r\nreturn NULL;\r\nlov_foreach_target(ld, i) {\r\nstruct lovsub_device *lsd;\r\nlsd = ld->ld_target[i];\r\nif (lsd != NULL) {\r\ncl_stack_fini(env, lovsub2cl_dev(lsd));\r\nld->ld_target[i] = NULL;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int lov_device_init(const struct lu_env *env, struct lu_device *d,\r\nconst char *name, struct lu_device *next)\r\n{\r\nstruct lov_device *ld = lu2lov_dev(d);\r\nint i;\r\nint rc = 0;\r\nLASSERT(d->ld_site != NULL);\r\nif (ld->ld_target == NULL)\r\nreturn rc;\r\nlov_foreach_target(ld, i) {\r\nstruct lovsub_device *lsd;\r\nstruct cl_device *cl;\r\nstruct lov_tgt_desc *desc;\r\ndesc = ld->ld_lov->lov_tgts[i];\r\nif (desc == NULL)\r\ncontinue;\r\ncl = cl_type_setup(env, d->ld_site, &lovsub_device_type,\r\ndesc->ltd_obd->obd_lu_dev);\r\nif (IS_ERR(cl)) {\r\nrc = PTR_ERR(cl);\r\nbreak;\r\n}\r\nlsd = cl2lovsub_dev(cl);\r\nlsd->acid_idx = i;\r\nlsd->acid_super = ld;\r\nld->ld_target[i] = lsd;\r\n}\r\nif (rc)\r\nlov_device_fini(env, d);\r\nelse\r\nld->ld_flags |= LOV_DEV_INITIALIZED;\r\nreturn rc;\r\n}\r\nstatic int lov_req_init(const struct lu_env *env, struct cl_device *dev,\r\nstruct cl_req *req)\r\n{\r\nstruct lov_req *lr;\r\nint result;\r\nOBD_SLAB_ALLOC_PTR_GFP(lr, lov_req_kmem, GFP_NOFS);\r\nif (lr != NULL) {\r\ncl_req_slice_add(req, &lr->lr_cl, dev, &lov_req_ops);\r\nresult = 0;\r\n} else\r\nresult = -ENOMEM;\r\nreturn result;\r\n}\r\nstatic void lov_emerg_free(struct lov_device_emerg **emrg, int nr)\r\n{\r\nint i;\r\nfor (i = 0; i < nr; ++i) {\r\nstruct lov_device_emerg *em;\r\nem = emrg[i];\r\nif (em != NULL) {\r\nLASSERT(em->emrg_page_list.pl_nr == 0);\r\nif (em->emrg_env != NULL)\r\ncl_env_put(em->emrg_env, &em->emrg_refcheck);\r\nOBD_FREE_PTR(em);\r\n}\r\n}\r\nOBD_FREE(emrg, nr * sizeof(emrg[0]));\r\n}\r\nstatic struct lu_device *lov_device_free(const struct lu_env *env,\r\nstruct lu_device *d)\r\n{\r\nstruct lov_device *ld = lu2lov_dev(d);\r\nconst int nr = ld->ld_target_nr;\r\ncl_device_fini(lu2cl_dev(d));\r\nif (ld->ld_target != NULL)\r\nOBD_FREE(ld->ld_target, nr * sizeof(ld->ld_target[0]));\r\nif (ld->ld_emrg != NULL)\r\nlov_emerg_free(ld->ld_emrg, nr);\r\nOBD_FREE_PTR(ld);\r\nreturn NULL;\r\n}\r\nstatic void lov_cl_del_target(const struct lu_env *env, struct lu_device *dev,\r\n__u32 index)\r\n{\r\nstruct lov_device *ld = lu2lov_dev(dev);\r\nif (ld->ld_target[index] != NULL) {\r\ncl_stack_fini(env, lovsub2cl_dev(ld->ld_target[index]));\r\nld->ld_target[index] = NULL;\r\n}\r\n}\r\nstatic struct lov_device_emerg **lov_emerg_alloc(int nr)\r\n{\r\nstruct lov_device_emerg **emerg;\r\nint i;\r\nint result;\r\nOBD_ALLOC(emerg, nr * sizeof(emerg[0]));\r\nif (emerg == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (result = i = 0; i < nr && result == 0; i++) {\r\nstruct lov_device_emerg *em;\r\nOBD_ALLOC_PTR(em);\r\nif (em != NULL) {\r\nemerg[i] = em;\r\ncl_page_list_init(&em->emrg_page_list);\r\nem->emrg_env = cl_env_alloc(&em->emrg_refcheck,\r\nLCT_REMEMBER|LCT_NOREF);\r\nif (!IS_ERR(em->emrg_env))\r\nem->emrg_env->le_ctx.lc_cookie = 0x2;\r\nelse {\r\nresult = PTR_ERR(em->emrg_env);\r\nem->emrg_env = NULL;\r\n}\r\n} else\r\nresult = -ENOMEM;\r\n}\r\nif (result != 0) {\r\nlov_emerg_free(emerg, nr);\r\nemerg = ERR_PTR(result);\r\n}\r\nreturn emerg;\r\n}\r\nstatic int lov_expand_targets(const struct lu_env *env, struct lov_device *dev)\r\n{\r\nint result;\r\n__u32 tgt_size;\r\n__u32 sub_size;\r\nresult = 0;\r\ntgt_size = dev->ld_lov->lov_tgt_size;\r\nsub_size = dev->ld_target_nr;\r\nif (sub_size < tgt_size) {\r\nstruct lovsub_device **newd;\r\nstruct lov_device_emerg **emerg;\r\nconst size_t sz = sizeof(newd[0]);\r\nemerg = lov_emerg_alloc(tgt_size);\r\nif (IS_ERR(emerg))\r\nreturn PTR_ERR(emerg);\r\nOBD_ALLOC(newd, tgt_size * sz);\r\nif (newd != NULL) {\r\nmutex_lock(&dev->ld_mutex);\r\nif (sub_size > 0) {\r\nmemcpy(newd, dev->ld_target, sub_size * sz);\r\nOBD_FREE(dev->ld_target, sub_size * sz);\r\n}\r\ndev->ld_target = newd;\r\ndev->ld_target_nr = tgt_size;\r\nif (dev->ld_emrg != NULL)\r\nlov_emerg_free(dev->ld_emrg, sub_size);\r\ndev->ld_emrg = emerg;\r\nmutex_unlock(&dev->ld_mutex);\r\n} else {\r\nlov_emerg_free(emerg, tgt_size);\r\nresult = -ENOMEM;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int lov_cl_add_target(const struct lu_env *env, struct lu_device *dev,\r\n__u32 index)\r\n{\r\nstruct obd_device *obd = dev->ld_obd;\r\nstruct lov_device *ld = lu2lov_dev(dev);\r\nstruct lov_tgt_desc *tgt;\r\nstruct lovsub_device *lsd;\r\nstruct cl_device *cl;\r\nint rc;\r\nobd_getref(obd);\r\ntgt = obd->u.lov.lov_tgts[index];\r\nLASSERT(tgt != NULL);\r\nLASSERT(tgt->ltd_obd != NULL);\r\nif (!tgt->ltd_obd->obd_set_up) {\r\nCERROR("Target %s not set up\n", obd_uuid2str(&tgt->ltd_uuid));\r\nreturn -EINVAL;\r\n}\r\nrc = lov_expand_targets(env, ld);\r\nif (rc == 0 && ld->ld_flags & LOV_DEV_INITIALIZED) {\r\nLASSERT(dev->ld_site != NULL);\r\ncl = cl_type_setup(env, dev->ld_site, &lovsub_device_type,\r\ntgt->ltd_obd->obd_lu_dev);\r\nif (!IS_ERR(cl)) {\r\nlsd = cl2lovsub_dev(cl);\r\nlsd->acid_idx = index;\r\nlsd->acid_super = ld;\r\nld->ld_target[index] = lsd;\r\n} else {\r\nCERROR("add failed (%d), deleting %s\n", rc,\r\nobd_uuid2str(&tgt->ltd_uuid));\r\nlov_cl_del_target(env, dev, index);\r\nrc = PTR_ERR(cl);\r\n}\r\n}\r\nobd_putref(obd);\r\nreturn rc;\r\n}\r\nstatic int lov_process_config(const struct lu_env *env,\r\nstruct lu_device *d, struct lustre_cfg *cfg)\r\n{\r\nstruct obd_device *obd = d->ld_obd;\r\nint cmd;\r\nint rc;\r\nint gen;\r\n__u32 index;\r\nobd_getref(obd);\r\ncmd = cfg->lcfg_command;\r\nrc = lov_process_config_base(d->ld_obd, cfg, &index, &gen);\r\nif (rc == 0) {\r\nswitch (cmd) {\r\ncase LCFG_LOV_ADD_OBD:\r\ncase LCFG_LOV_ADD_INA:\r\nrc = lov_cl_add_target(env, d, index);\r\nif (rc != 0)\r\nlov_del_target(d->ld_obd, index, NULL, 0);\r\nbreak;\r\ncase LCFG_LOV_DEL_OBD:\r\nlov_cl_del_target(env, d, index);\r\nbreak;\r\n}\r\n}\r\nobd_putref(obd);\r\nreturn rc;\r\n}\r\nstatic struct lu_device *lov_device_alloc(const struct lu_env *env,\r\nstruct lu_device_type *t,\r\nstruct lustre_cfg *cfg)\r\n{\r\nstruct lu_device *d;\r\nstruct lov_device *ld;\r\nstruct obd_device *obd;\r\nint rc;\r\nOBD_ALLOC_PTR(ld);\r\nif (ld == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ncl_device_init(&ld->ld_cl, t);\r\nd = lov2lu_dev(ld);\r\nd->ld_ops = &lov_lu_ops;\r\nld->ld_cl.cd_ops = &lov_cl_ops;\r\nmutex_init(&ld->ld_mutex);\r\nlockdep_set_class(&ld->ld_mutex, &cl_lov_device_mutex_class);\r\nobd = class_name2obd(lustre_cfg_string(cfg, 0));\r\nLASSERT(obd != NULL);\r\nrc = lov_setup(obd, cfg);\r\nif (rc) {\r\nlov_device_free(env, d);\r\nreturn ERR_PTR(rc);\r\n}\r\nld->ld_lov = &obd->u.lov;\r\nreturn d;\r\n}
