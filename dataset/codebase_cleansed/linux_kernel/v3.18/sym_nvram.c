void sym_nvram_setup_host(struct Scsi_Host *shost, struct sym_hcb *np, struct sym_nvram *nvram)\r\n{\r\nswitch (nvram->type) {\r\ncase SYM_SYMBIOS_NVRAM:\r\nif (!(nvram->data.Symbios.flags & SYMBIOS_PARITY_ENABLE))\r\nnp->rv_scntl0 &= ~0x0a;\r\nnp->myaddr = nvram->data.Symbios.host_id & 0x0f;\r\nif (nvram->data.Symbios.flags & SYMBIOS_VERBOSE_MSGS)\r\nnp->verbose += 1;\r\nif (nvram->data.Symbios.flags1 & SYMBIOS_SCAN_HI_LO)\r\nshost->reverse_ordering = 1;\r\nif (nvram->data.Symbios.flags2 & SYMBIOS_AVOID_BUS_RESET)\r\nnp->usrflags |= SYM_AVOID_BUS_RESET;\r\nbreak;\r\ncase SYM_TEKRAM_NVRAM:\r\nnp->myaddr = nvram->data.Tekram.host_id & 0x0f;\r\nbreak;\r\n#ifdef CONFIG_PARISC\r\ncase SYM_PARISC_PDC:\r\nif (nvram->data.parisc.host_id != -1)\r\nnp->myaddr = nvram->data.parisc.host_id;\r\nif (nvram->data.parisc.factor != -1)\r\nnp->minsync = nvram->data.parisc.factor;\r\nif (nvram->data.parisc.width != -1)\r\nnp->maxwide = nvram->data.parisc.width;\r\nswitch (nvram->data.parisc.mode) {\r\ncase 0: np->scsi_mode = SMODE_SE; break;\r\ncase 1: np->scsi_mode = SMODE_HVD; break;\r\ncase 2: np->scsi_mode = SMODE_LVD; break;\r\ndefault: break;\r\n}\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nsym_Symbios_setup_target(struct sym_tcb *tp, int target, Symbios_nvram *nvram)\r\n{\r\nSymbios_target *tn = &nvram->target[target];\r\nif (!(tn->flags & SYMBIOS_QUEUE_TAGS_ENABLED))\r\ntp->usrtags = 0;\r\nif (!(tn->flags & SYMBIOS_DISCONNECT_ENABLE))\r\ntp->usrflags &= ~SYM_DISC_ENABLED;\r\nif (!(tn->flags & SYMBIOS_SCAN_AT_BOOT_TIME))\r\ntp->usrflags |= SYM_SCAN_BOOT_DISABLED;\r\nif (!(tn->flags & SYMBIOS_SCAN_LUNS))\r\ntp->usrflags |= SYM_SCAN_LUNS_DISABLED;\r\ntp->usr_period = (tn->sync_period + 3) / 4;\r\ntp->usr_width = (tn->bus_width == 0x8) ? 0 : 1;\r\n}\r\nstatic void\r\nsym_Tekram_setup_target(struct sym_tcb *tp, int target, Tekram_nvram *nvram)\r\n{\r\nstruct Tekram_target *tn = &nvram->target[target];\r\nif (tn->flags & TEKRAM_TAGGED_COMMANDS) {\r\ntp->usrtags = 2 << nvram->max_tags_index;\r\n}\r\nif (tn->flags & TEKRAM_DISCONNECT_ENABLE)\r\ntp->usrflags |= SYM_DISC_ENABLED;\r\nif (tn->flags & TEKRAM_SYNC_NEGO)\r\ntp->usr_period = Tekram_sync[tn->sync_index & 0xf];\r\ntp->usr_width = (tn->flags & TEKRAM_WIDE_NEGO) ? 1 : 0;\r\n}\r\nvoid sym_nvram_setup_target(struct sym_tcb *tp, int target, struct sym_nvram *nvp)\r\n{\r\nswitch (nvp->type) {\r\ncase SYM_SYMBIOS_NVRAM:\r\nsym_Symbios_setup_target(tp, target, &nvp->data.Symbios);\r\nbreak;\r\ncase SYM_TEKRAM_NVRAM:\r\nsym_Tekram_setup_target(tp, target, &nvp->data.Tekram);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sym_display_Symbios_nvram(struct sym_device *np, Symbios_nvram *nvram)\r\n{\r\nint i;\r\nprintf("%s: HOST ID=%d%s%s%s%s%s%s\n",\r\nsym_name(np), nvram->host_id & 0x0f,\r\n(nvram->flags & SYMBIOS_SCAM_ENABLE) ? " SCAM" :"",\r\n(nvram->flags & SYMBIOS_PARITY_ENABLE) ? " PARITY" :"",\r\n(nvram->flags & SYMBIOS_VERBOSE_MSGS) ? " VERBOSE" :"",\r\n(nvram->flags & SYMBIOS_CHS_MAPPING) ? " CHS_ALT" :"",\r\n(nvram->flags2 & SYMBIOS_AVOID_BUS_RESET)?" NO_RESET" :"",\r\n(nvram->flags1 & SYMBIOS_SCAN_HI_LO) ? " HI_LO" :"");\r\nfor (i = 0 ; i < 15 ; i++) {\r\nstruct Symbios_target *tn = &nvram->target[i];\r\nprintf("%s-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d\n",\r\nsym_name(np), i,\r\n(tn->flags & SYMBIOS_DISCONNECT_ENABLE) ? " DISC" : "",\r\n(tn->flags & SYMBIOS_SCAN_AT_BOOT_TIME) ? " SCAN_BOOT" : "",\r\n(tn->flags & SYMBIOS_SCAN_LUNS) ? " SCAN_LUNS" : "",\r\n(tn->flags & SYMBIOS_QUEUE_TAGS_ENABLED)? " TCQ" : "",\r\ntn->bus_width,\r\ntn->sync_period / 4,\r\ntn->timeout);\r\n}\r\n}\r\nstatic void sym_display_Tekram_nvram(struct sym_device *np, Tekram_nvram *nvram)\r\n{\r\nint i, tags, boot_delay;\r\nchar *rem;\r\ntags = 2 << nvram->max_tags_index;\r\nboot_delay = 0;\r\nif (nvram->boot_delay_index < 6)\r\nboot_delay = Tekram_boot_delay[nvram->boot_delay_index];\r\nswitch ((nvram->flags & TEKRAM_REMOVABLE_FLAGS) >> 6) {\r\ndefault:\r\ncase 0: rem = ""; break;\r\ncase 1: rem = " REMOVABLE=boot device"; break;\r\ncase 2: rem = " REMOVABLE=all"; break;\r\n}\r\nprintf("%s: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d\n",\r\nsym_name(np), nvram->host_id & 0x0f,\r\n(nvram->flags1 & SYMBIOS_SCAM_ENABLE) ? " SCAM" :"",\r\n(nvram->flags & TEKRAM_MORE_THAN_2_DRIVES) ? " >2DRIVES":"",\r\n(nvram->flags & TEKRAM_DRIVES_SUP_1GB) ? " >1GB" :"",\r\n(nvram->flags & TEKRAM_RESET_ON_POWER_ON) ? " RESET" :"",\r\n(nvram->flags & TEKRAM_ACTIVE_NEGATION) ? " ACT_NEG" :"",\r\n(nvram->flags & TEKRAM_IMMEDIATE_SEEK) ? " IMM_SEEK" :"",\r\n(nvram->flags & TEKRAM_SCAN_LUNS) ? " SCAN_LUNS" :"",\r\n(nvram->flags1 & TEKRAM_F2_F6_ENABLED) ? " F2_F6" :"",\r\nrem, boot_delay, tags);\r\nfor (i = 0; i <= 15; i++) {\r\nint sync, j;\r\nstruct Tekram_target *tn = &nvram->target[i];\r\nj = tn->sync_index & 0xf;\r\nsync = Tekram_sync[j];\r\nprintf("%s-%d:%s%s%s%s%s%s PERIOD=%d\n",\r\nsym_name(np), i,\r\n(tn->flags & TEKRAM_PARITY_CHECK) ? " PARITY" : "",\r\n(tn->flags & TEKRAM_SYNC_NEGO) ? " SYNC" : "",\r\n(tn->flags & TEKRAM_DISCONNECT_ENABLE) ? " DISC" : "",\r\n(tn->flags & TEKRAM_START_CMD) ? " START" : "",\r\n(tn->flags & TEKRAM_TAGGED_COMMANDS) ? " TCQ" : "",\r\n(tn->flags & TEKRAM_WIDE_NEGO) ? " WIDE" : "",\r\nsync);\r\n}\r\n}\r\nstatic void sym_display_Symbios_nvram(struct sym_device *np, Symbios_nvram *nvram) { (void)np; (void)nvram; }\r\nstatic void sym_display_Tekram_nvram(struct sym_device *np, Tekram_nvram *nvram) { (void)np; (void)nvram; }\r\nstatic void S24C16_set_bit(struct sym_device *np, u_char write_bit, u_char *gpreg,\r\nint bit_mode)\r\n{\r\nudelay(5);\r\nswitch (bit_mode) {\r\ncase SET_BIT:\r\n*gpreg |= write_bit;\r\nbreak;\r\ncase CLR_BIT:\r\n*gpreg &= 0xfe;\r\nbreak;\r\ncase SET_CLK:\r\n*gpreg |= 0x02;\r\nbreak;\r\ncase CLR_CLK:\r\n*gpreg &= 0xfd;\r\nbreak;\r\n}\r\nOUTB(np, nc_gpreg, *gpreg);\r\nINB(np, nc_mbox1);\r\nudelay(5);\r\n}\r\nstatic void S24C16_start(struct sym_device *np, u_char *gpreg)\r\n{\r\nS24C16_set_bit(np, 1, gpreg, SET_BIT);\r\nS24C16_set_bit(np, 0, gpreg, SET_CLK);\r\nS24C16_set_bit(np, 0, gpreg, CLR_BIT);\r\nS24C16_set_bit(np, 0, gpreg, CLR_CLK);\r\n}\r\nstatic void S24C16_stop(struct sym_device *np, u_char *gpreg)\r\n{\r\nS24C16_set_bit(np, 0, gpreg, SET_CLK);\r\nS24C16_set_bit(np, 1, gpreg, SET_BIT);\r\n}\r\nstatic void S24C16_do_bit(struct sym_device *np, u_char *read_bit, u_char write_bit,\r\nu_char *gpreg)\r\n{\r\nS24C16_set_bit(np, write_bit, gpreg, SET_BIT);\r\nS24C16_set_bit(np, 0, gpreg, SET_CLK);\r\nif (read_bit)\r\n*read_bit = INB(np, nc_gpreg);\r\nS24C16_set_bit(np, 0, gpreg, CLR_CLK);\r\nS24C16_set_bit(np, 0, gpreg, CLR_BIT);\r\n}\r\nstatic void S24C16_write_ack(struct sym_device *np, u_char write_bit, u_char *gpreg,\r\nu_char *gpcntl)\r\n{\r\nOUTB(np, nc_gpcntl, *gpcntl & 0xfe);\r\nS24C16_do_bit(np, NULL, write_bit, gpreg);\r\nOUTB(np, nc_gpcntl, *gpcntl);\r\n}\r\nstatic void S24C16_read_ack(struct sym_device *np, u_char *read_bit, u_char *gpreg,\r\nu_char *gpcntl)\r\n{\r\nOUTB(np, nc_gpcntl, *gpcntl | 0x01);\r\nS24C16_do_bit(np, read_bit, 1, gpreg);\r\nOUTB(np, nc_gpcntl, *gpcntl);\r\n}\r\nstatic void S24C16_write_byte(struct sym_device *np, u_char *ack_data, u_char write_data,\r\nu_char *gpreg, u_char *gpcntl)\r\n{\r\nint x;\r\nfor (x = 0; x < 8; x++)\r\nS24C16_do_bit(np, NULL, (write_data >> (7 - x)) & 0x01, gpreg);\r\nS24C16_read_ack(np, ack_data, gpreg, gpcntl);\r\n}\r\nstatic void S24C16_read_byte(struct sym_device *np, u_char *read_data, u_char ack_data,\r\nu_char *gpreg, u_char *gpcntl)\r\n{\r\nint x;\r\nu_char read_bit;\r\n*read_data = 0;\r\nfor (x = 0; x < 8; x++) {\r\nS24C16_do_bit(np, &read_bit, 1, gpreg);\r\n*read_data |= ((read_bit & 0x01) << (7 - x));\r\n}\r\nS24C16_write_ack(np, ack_data, gpreg, gpcntl);\r\n}\r\nstatic int sym_write_S24C16_nvram(struct sym_device *np, int offset,\r\nu_char *data, int len)\r\n{\r\nu_char gpcntl, gpreg;\r\nu_char old_gpcntl, old_gpreg;\r\nu_char ack_data;\r\nint x;\r\nold_gpreg = INB(np, nc_gpreg);\r\nold_gpcntl = INB(np, nc_gpcntl);\r\ngpcntl = old_gpcntl & 0x1c;\r\nOUTB(np, nc_gpreg, old_gpreg);\r\nOUTB(np, nc_gpcntl, gpcntl);\r\ngpreg = old_gpreg;\r\nS24C16_set_bit(np, 0, &gpreg, CLR_CLK);\r\nS24C16_set_bit(np, 0, &gpreg, CLR_BIT);\r\nS24C16_stop(np, &gpreg);\r\nfor (x = 0; x < len ; x += 16) {\r\ndo {\r\nS24C16_start(np, &gpreg);\r\nS24C16_write_byte(np, &ack_data,\r\n0xa0 | (((offset+x) >> 7) & 0x0e),\r\n&gpreg, &gpcntl);\r\n} while (ack_data & 0x01);\r\nS24C16_write_byte(np, &ack_data, (offset+x) & 0xff,\r\n&gpreg, &gpcntl);\r\nfor (y = 0; y < 16; y++)\r\nS24C16_write_byte(np, &ack_data, data[x+y],\r\n&gpreg, &gpcntl);\r\nS24C16_stop(np, &gpreg);\r\n}\r\nOUTB(np, nc_gpcntl, old_gpcntl);\r\nOUTB(np, nc_gpreg, old_gpreg);\r\nreturn 0;\r\n}\r\nstatic int sym_read_S24C16_nvram(struct sym_device *np, int offset, u_char *data, int len)\r\n{\r\nu_char gpcntl, gpreg;\r\nu_char old_gpcntl, old_gpreg;\r\nu_char ack_data;\r\nint retv = 1;\r\nint x;\r\nold_gpreg = INB(np, nc_gpreg);\r\nold_gpcntl = INB(np, nc_gpcntl);\r\ngpcntl = old_gpcntl & 0x1c;\r\nOUTB(np, nc_gpreg, old_gpreg);\r\nOUTB(np, nc_gpcntl, gpcntl);\r\ngpreg = old_gpreg;\r\nS24C16_set_bit(np, 0, &gpreg, CLR_CLK);\r\nS24C16_set_bit(np, 0, &gpreg, CLR_BIT);\r\nS24C16_stop(np, &gpreg);\r\nS24C16_start(np, &gpreg);\r\nS24C16_write_byte(np, &ack_data,\r\n0xa0 | ((offset >> 7) & 0x0e), &gpreg, &gpcntl);\r\nif (ack_data & 0x01)\r\ngoto out;\r\nS24C16_write_byte(np, &ack_data,\r\noffset & 0xff, &gpreg, &gpcntl);\r\nif (ack_data & 0x01)\r\ngoto out;\r\nS24C16_start(np, &gpreg);\r\nS24C16_write_byte(np, &ack_data,\r\n0xa1 | ((offset >> 7) & 0x0e), &gpreg, &gpcntl);\r\nif (ack_data & 0x01)\r\ngoto out;\r\ngpcntl |= 0x01;\r\nOUTB(np, nc_gpcntl, gpcntl);\r\nfor (x = 0; x < len; x++)\r\nS24C16_read_byte(np, &data[x], (x == (len-1)), &gpreg, &gpcntl);\r\ngpcntl &= 0xfe;\r\nOUTB(np, nc_gpcntl, gpcntl);\r\nS24C16_stop(np, &gpreg);\r\nretv = 0;\r\nout:\r\nOUTB(np, nc_gpcntl, old_gpcntl);\r\nOUTB(np, nc_gpreg, old_gpreg);\r\nreturn retv;\r\n}\r\nstatic int sym_read_Symbios_nvram(struct sym_device *np, Symbios_nvram *nvram)\r\n{\r\nstatic u_char Symbios_trailer[6] = {0xfe, 0xfe, 0, 0, 0, 0};\r\nu_char *data = (u_char *) nvram;\r\nint len = sizeof(*nvram);\r\nu_short csum;\r\nint x;\r\nif (sym_read_S24C16_nvram (np, SYMBIOS_NVRAM_ADDRESS, data, len))\r\nreturn 1;\r\nif (nvram->type != 0 ||\r\nmemcmp(nvram->trailer, Symbios_trailer, 6) ||\r\nnvram->byte_count != len - 12)\r\nreturn 1;\r\nfor (x = 6, csum = 0; x < len - 6; x++)\r\ncsum += data[x];\r\nif (csum != nvram->checksum)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void T93C46_Clk(struct sym_device *np, u_char *gpreg)\r\n{\r\nOUTB(np, nc_gpreg, *gpreg | 0x04);\r\nINB(np, nc_mbox1);\r\nudelay(2);\r\nOUTB(np, nc_gpreg, *gpreg);\r\n}\r\nstatic void T93C46_Read_Bit(struct sym_device *np, u_char *read_bit, u_char *gpreg)\r\n{\r\nudelay(2);\r\nT93C46_Clk(np, gpreg);\r\n*read_bit = INB(np, nc_gpreg);\r\n}\r\nstatic void T93C46_Write_Bit(struct sym_device *np, u_char write_bit, u_char *gpreg)\r\n{\r\nif (write_bit & 0x01)\r\n*gpreg |= 0x02;\r\nelse\r\n*gpreg &= 0xfd;\r\n*gpreg |= 0x10;\r\nOUTB(np, nc_gpreg, *gpreg);\r\nINB(np, nc_mbox1);\r\nudelay(2);\r\nT93C46_Clk(np, gpreg);\r\n}\r\nstatic void T93C46_Stop(struct sym_device *np, u_char *gpreg)\r\n{\r\n*gpreg &= 0xef;\r\nOUTB(np, nc_gpreg, *gpreg);\r\nINB(np, nc_mbox1);\r\nudelay(2);\r\nT93C46_Clk(np, gpreg);\r\n}\r\nstatic void T93C46_Send_Command(struct sym_device *np, u_short write_data,\r\nu_char *read_bit, u_char *gpreg)\r\n{\r\nint x;\r\nfor (x = 0; x < 9; x++)\r\nT93C46_Write_Bit(np, (u_char) (write_data >> (8 - x)), gpreg);\r\n*read_bit = INB(np, nc_gpreg);\r\n}\r\nstatic void T93C46_Read_Word(struct sym_device *np,\r\nunsigned short *nvram_data, unsigned char *gpreg)\r\n{\r\nint x;\r\nu_char read_bit;\r\n*nvram_data = 0;\r\nfor (x = 0; x < 16; x++) {\r\nT93C46_Read_Bit(np, &read_bit, gpreg);\r\nif (read_bit & 0x01)\r\n*nvram_data |= (0x01 << (15 - x));\r\nelse\r\n*nvram_data &= ~(0x01 << (15 - x));\r\n}\r\n}\r\nstatic int T93C46_Read_Data(struct sym_device *np, unsigned short *data,\r\nint len, unsigned char *gpreg)\r\n{\r\nint x;\r\nfor (x = 0; x < len; x++) {\r\nunsigned char read_bit;\r\nT93C46_Send_Command(np, 0x180 | x, &read_bit, gpreg);\r\nif (read_bit & 0x01)\r\nreturn 1;\r\nT93C46_Read_Word(np, &data[x], gpreg);\r\nT93C46_Stop(np, gpreg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sym_read_T93C46_nvram(struct sym_device *np, Tekram_nvram *nvram)\r\n{\r\nu_char gpcntl, gpreg;\r\nu_char old_gpcntl, old_gpreg;\r\nint retv = 1;\r\nold_gpreg = INB(np, nc_gpreg);\r\nold_gpcntl = INB(np, nc_gpcntl);\r\ngpreg = old_gpreg & 0xe9;\r\nOUTB(np, nc_gpreg, gpreg);\r\ngpcntl = (old_gpcntl & 0xe9) | 0x09;\r\nOUTB(np, nc_gpcntl, gpcntl);\r\nretv = T93C46_Read_Data(np, (u_short *) nvram,\r\nsizeof(*nvram) / sizeof(short), &gpreg);\r\nOUTB(np, nc_gpcntl, old_gpcntl);\r\nOUTB(np, nc_gpreg, old_gpreg);\r\nreturn retv;\r\n}\r\nstatic int sym_read_Tekram_nvram (struct sym_device *np, Tekram_nvram *nvram)\r\n{\r\nu_char *data = (u_char *) nvram;\r\nint len = sizeof(*nvram);\r\nu_short csum;\r\nint x;\r\nswitch (np->pdev->device) {\r\ncase PCI_DEVICE_ID_NCR_53C885:\r\ncase PCI_DEVICE_ID_NCR_53C895:\r\ncase PCI_DEVICE_ID_NCR_53C896:\r\nx = sym_read_S24C16_nvram(np, TEKRAM_24C16_NVRAM_ADDRESS,\r\ndata, len);\r\nbreak;\r\ncase PCI_DEVICE_ID_NCR_53C875:\r\nx = sym_read_S24C16_nvram(np, TEKRAM_24C16_NVRAM_ADDRESS,\r\ndata, len);\r\nif (!x)\r\nbreak;\r\ndefault:\r\nx = sym_read_T93C46_nvram(np, nvram);\r\nbreak;\r\n}\r\nif (x)\r\nreturn 1;\r\nfor (x = 0, csum = 0; x < len - 1; x += 2)\r\ncsum += data[x] + (data[x+1] << 8);\r\nif (csum != 0x1234)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int sym_read_parisc_pdc(struct sym_device *np, struct pdc_initiator *pdc)\r\n{\r\nstruct hardware_path hwpath;\r\nget_pci_node_path(np->pdev, &hwpath);\r\nif (!pdc_get_initiator(&hwpath, pdc))\r\nreturn 0;\r\nreturn SYM_PARISC_PDC;\r\n}\r\nstatic inline int sym_read_parisc_pdc(struct sym_device *np,\r\nstruct pdc_initiator *x)\r\n{\r\nreturn 0;\r\n}\r\nint sym_read_nvram(struct sym_device *np, struct sym_nvram *nvp)\r\n{\r\nif (!sym_read_Symbios_nvram(np, &nvp->data.Symbios)) {\r\nnvp->type = SYM_SYMBIOS_NVRAM;\r\nsym_display_Symbios_nvram(np, &nvp->data.Symbios);\r\n} else if (!sym_read_Tekram_nvram(np, &nvp->data.Tekram)) {\r\nnvp->type = SYM_TEKRAM_NVRAM;\r\nsym_display_Tekram_nvram(np, &nvp->data.Tekram);\r\n} else {\r\nnvp->type = sym_read_parisc_pdc(np, &nvp->data.parisc);\r\n}\r\nreturn nvp->type;\r\n}\r\nchar *sym_nvram_type(struct sym_nvram *nvp)\r\n{\r\nswitch (nvp->type) {\r\ncase SYM_SYMBIOS_NVRAM:\r\nreturn "Symbios NVRAM";\r\ncase SYM_TEKRAM_NVRAM:\r\nreturn "Tekram NVRAM";\r\ncase SYM_PARISC_PDC:\r\nreturn "PA-RISC Firmware";\r\ndefault:\r\nreturn "No NVRAM";\r\n}\r\n}
