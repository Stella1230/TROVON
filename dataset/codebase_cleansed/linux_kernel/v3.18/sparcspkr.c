static u32 bbc_count_to_reg(struct bbc_beep_info *info, unsigned int count)\r\n{\r\nu32 val, clock_freq = info->clock_freq;\r\nint i;\r\nif (!count)\r\nreturn 0;\r\nif (count <= clock_freq >> 20)\r\nreturn 1 << 18;\r\nif (count >= clock_freq >> 12)\r\nreturn 1 << 10;\r\nval = 1 << 18;\r\nfor (i = 19; i >= 11; i--) {\r\nval >>= 1;\r\nif (count <= clock_freq >> i)\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic int bbc_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)\r\n{\r\nstruct sparcspkr_state *state = dev_get_drvdata(dev->dev.parent);\r\nstruct bbc_beep_info *info = &state->u.bbc;\r\nunsigned int count = 0;\r\nunsigned long flags;\r\nif (type != EV_SND)\r\nreturn -1;\r\nswitch (code) {\r\ncase SND_BELL: if (value) value = 1000;\r\ncase SND_TONE: break;\r\ndefault: return -1;\r\n}\r\nif (value > 20 && value < 32767)\r\ncount = 1193182 / value;\r\ncount = bbc_count_to_reg(info, count);\r\nspin_lock_irqsave(&state->lock, flags);\r\nif (count) {\r\nsbus_writeb(0x01, info->regs + 0);\r\nsbus_writeb(0x00, info->regs + 2);\r\nsbus_writeb((count >> 16) & 0xff, info->regs + 3);\r\nsbus_writeb((count >> 8) & 0xff, info->regs + 4);\r\nsbus_writeb(0x00, info->regs + 5);\r\n} else {\r\nsbus_writeb(0x00, info->regs + 0);\r\n}\r\nspin_unlock_irqrestore(&state->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int grover_spkr_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)\r\n{\r\nstruct sparcspkr_state *state = dev_get_drvdata(dev->dev.parent);\r\nstruct grover_beep_info *info = &state->u.grover;\r\nunsigned int count = 0;\r\nunsigned long flags;\r\nif (type != EV_SND)\r\nreturn -1;\r\nswitch (code) {\r\ncase SND_BELL: if (value) value = 1000;\r\ncase SND_TONE: break;\r\ndefault: return -1;\r\n}\r\nif (value > 20 && value < 32767)\r\ncount = 1193182 / value;\r\nspin_lock_irqsave(&state->lock, flags);\r\nif (count) {\r\nsbus_writeb(sbus_readb(info->enable_reg) | 3, info->enable_reg);\r\nsbus_writeb(0xB6, info->freq_regs + 1);\r\nsbus_writeb(count & 0xff, info->freq_regs + 0);\r\nsbus_writeb((count >> 8) & 0xff, info->freq_regs + 0);\r\n} else {\r\nsbus_writeb(sbus_readb(info->enable_reg) & 0xFC, info->enable_reg);\r\n}\r\nspin_unlock_irqrestore(&state->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sparcspkr_probe(struct device *dev)\r\n{\r\nstruct sparcspkr_state *state = dev_get_drvdata(dev);\r\nstruct input_dev *input_dev;\r\nint error;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ninput_dev->name = state->name;\r\ninput_dev->phys = "sparc/input0";\r\ninput_dev->id.bustype = BUS_ISA;\r\ninput_dev->id.vendor = 0x001f;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_SND);\r\ninput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\r\ninput_dev->event = state->event;\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ninput_free_device(input_dev);\r\nreturn error;\r\n}\r\nstate->input_dev = input_dev;\r\nreturn 0;\r\n}\r\nstatic void sparcspkr_shutdown(struct platform_device *dev)\r\n{\r\nstruct sparcspkr_state *state = platform_get_drvdata(dev);\r\nstruct input_dev *input_dev = state->input_dev;\r\nstate->event(input_dev, EV_SND, SND_BELL, 0);\r\n}\r\nstatic int bbc_beep_probe(struct platform_device *op)\r\n{\r\nstruct sparcspkr_state *state;\r\nstruct bbc_beep_info *info;\r\nstruct device_node *dp;\r\nint err = -ENOMEM;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\ngoto out_err;\r\nstate->name = "Sparc BBC Speaker";\r\nstate->event = bbc_spkr_event;\r\nspin_lock_init(&state->lock);\r\ndp = of_find_node_by_path("/");\r\nerr = -ENODEV;\r\nif (!dp)\r\ngoto out_free;\r\ninfo = &state->u.bbc;\r\ninfo->clock_freq = of_getintprop_default(dp, "clock-frequency", 0);\r\nif (!info->clock_freq)\r\ngoto out_free;\r\ninfo->regs = of_ioremap(&op->resource[0], 0, 6, "bbc beep");\r\nif (!info->regs)\r\ngoto out_free;\r\nplatform_set_drvdata(op, state);\r\nerr = sparcspkr_probe(&op->dev);\r\nif (err)\r\ngoto out_clear_drvdata;\r\nreturn 0;\r\nout_clear_drvdata:\r\nof_iounmap(&op->resource[0], info->regs, 6);\r\nout_free:\r\nkfree(state);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int bbc_remove(struct platform_device *op)\r\n{\r\nstruct sparcspkr_state *state = platform_get_drvdata(op);\r\nstruct input_dev *input_dev = state->input_dev;\r\nstruct bbc_beep_info *info = &state->u.bbc;\r\nstate->event(input_dev, EV_SND, SND_BELL, 0);\r\ninput_unregister_device(input_dev);\r\nof_iounmap(&op->resource[0], info->regs, 6);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic int grover_beep_probe(struct platform_device *op)\r\n{\r\nstruct sparcspkr_state *state;\r\nstruct grover_beep_info *info;\r\nint err = -ENOMEM;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\ngoto out_err;\r\nstate->name = "Sparc Grover Speaker";\r\nstate->event = grover_spkr_event;\r\nspin_lock_init(&state->lock);\r\ninfo = &state->u.grover;\r\ninfo->freq_regs = of_ioremap(&op->resource[2], 0, 2, "grover beep freq");\r\nif (!info->freq_regs)\r\ngoto out_free;\r\ninfo->enable_reg = of_ioremap(&op->resource[3], 0, 1, "grover beep enable");\r\nif (!info->enable_reg)\r\ngoto out_unmap_freq_regs;\r\nplatform_set_drvdata(op, state);\r\nerr = sparcspkr_probe(&op->dev);\r\nif (err)\r\ngoto out_clear_drvdata;\r\nreturn 0;\r\nout_clear_drvdata:\r\nof_iounmap(&op->resource[3], info->enable_reg, 1);\r\nout_unmap_freq_regs:\r\nof_iounmap(&op->resource[2], info->freq_regs, 2);\r\nout_free:\r\nkfree(state);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int grover_remove(struct platform_device *op)\r\n{\r\nstruct sparcspkr_state *state = platform_get_drvdata(op);\r\nstruct grover_beep_info *info = &state->u.grover;\r\nstruct input_dev *input_dev = state->input_dev;\r\nstate->event(input_dev, EV_SND, SND_BELL, 0);\r\ninput_unregister_device(input_dev);\r\nof_iounmap(&op->resource[3], info->enable_reg, 1);\r\nof_iounmap(&op->resource[2], info->freq_regs, 2);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic int __init sparcspkr_init(void)\r\n{\r\nint err = platform_driver_register(&bbc_beep_driver);\r\nif (!err) {\r\nerr = platform_driver_register(&grover_beep_driver);\r\nif (err)\r\nplatform_driver_unregister(&bbc_beep_driver);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit sparcspkr_exit(void)\r\n{\r\nplatform_driver_unregister(&bbc_beep_driver);\r\nplatform_driver_unregister(&grover_beep_driver);\r\n}
