int amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,\r\nenum amdtp_stream_direction dir, enum cip_flags flags)\r\n{\r\ns->unit = fw_unit_get(unit);\r\ns->direction = dir;\r\ns->flags = flags;\r\ns->context = ERR_PTR(-1);\r\nmutex_init(&s->mutex);\r\ntasklet_init(&s->period_tasklet, pcm_period_tasklet, (unsigned long)s);\r\ns->packet_index = 0;\r\ninit_waitqueue_head(&s->callback_wait);\r\ns->callbacked = false;\r\ns->sync_slave = NULL;\r\ns->rx_blocks_for_midi = UINT_MAX;\r\nreturn 0;\r\n}\r\nvoid amdtp_stream_destroy(struct amdtp_stream *s)\r\n{\r\nWARN_ON(amdtp_stream_running(s));\r\nmutex_destroy(&s->mutex);\r\nfw_unit_put(s->unit);\r\n}\r\nint amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint err;\r\nerr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\n5000, UINT_MAX);\r\nif (err < 0)\r\ngoto end;\r\nif (!(s->flags & CIP_BLOCKING))\r\ngoto end;\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, 32);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);\r\nend:\r\nreturn err;\r\n}\r\nvoid amdtp_stream_set_parameters(struct amdtp_stream *s,\r\nunsigned int rate,\r\nunsigned int pcm_channels,\r\nunsigned int midi_ports)\r\n{\r\nunsigned int i, sfc, midi_channels;\r\nmidi_channels = DIV_ROUND_UP(midi_ports, 8);\r\nif (WARN_ON(amdtp_stream_running(s)) |\r\nWARN_ON(pcm_channels > AMDTP_MAX_CHANNELS_FOR_PCM) |\r\nWARN_ON(midi_channels > AMDTP_MAX_CHANNELS_FOR_MIDI))\r\nreturn;\r\nfor (sfc = 0; sfc < ARRAY_SIZE(amdtp_rate_table); ++sfc)\r\nif (amdtp_rate_table[sfc] == rate)\r\ngoto sfc_found;\r\nWARN_ON(1);\r\nreturn;\r\nsfc_found:\r\ns->pcm_channels = pcm_channels;\r\ns->sfc = sfc;\r\ns->data_block_quadlets = s->pcm_channels + midi_channels;\r\ns->midi_ports = midi_ports;\r\ns->syt_interval = amdtp_syt_intervals[sfc];\r\ns->transfer_delay = TRANSFER_DELAY_TICKS - TICKS_PER_CYCLE;\r\nif (s->flags & CIP_BLOCKING)\r\ns->transfer_delay += TICKS_PER_SECOND * s->syt_interval / rate;\r\nfor (i = 0; i < pcm_channels; i++)\r\ns->pcm_positions[i] = i;\r\ns->midi_position = s->pcm_channels;\r\n}\r\nunsigned int amdtp_stream_get_max_payload(struct amdtp_stream *s)\r\n{\r\nreturn 8 + s->syt_interval * s->data_block_quadlets * 4;\r\n}\r\nvoid amdtp_stream_set_pcm_format(struct amdtp_stream *s,\r\nsnd_pcm_format_t format)\r\n{\r\nif (WARN_ON(amdtp_stream_pcm_running(s)))\r\nreturn;\r\nswitch (format) {\r\ndefault:\r\nWARN_ON(1);\r\ncase SNDRV_PCM_FORMAT_S16:\r\nif (s->direction == AMDTP_OUT_STREAM) {\r\ns->transfer_samples = amdtp_write_s16;\r\nbreak;\r\n}\r\nWARN_ON(1);\r\ncase SNDRV_PCM_FORMAT_S32:\r\nif (s->direction == AMDTP_OUT_STREAM)\r\ns->transfer_samples = amdtp_write_s32;\r\nelse\r\ns->transfer_samples = amdtp_read_s32;\r\nbreak;\r\n}\r\n}\r\nvoid amdtp_stream_pcm_prepare(struct amdtp_stream *s)\r\n{\r\ntasklet_kill(&s->period_tasklet);\r\ns->pcm_buffer_pointer = 0;\r\ns->pcm_period_pointer = 0;\r\ns->pointer_flush = true;\r\n}\r\nstatic unsigned int calculate_data_blocks(struct amdtp_stream *s)\r\n{\r\nunsigned int phase, data_blocks;\r\nif (s->flags & CIP_BLOCKING)\r\ndata_blocks = s->syt_interval;\r\nelse if (!cip_sfc_is_base_44100(s->sfc)) {\r\ndata_blocks = s->data_block_state;\r\n} else {\r\nphase = s->data_block_state;\r\nif (s->sfc == CIP_SFC_44100)\r\ndata_blocks = 5 + ((phase & 1) ^\r\n(phase == 0 || phase >= 40));\r\nelse\r\ndata_blocks = 11 * (s->sfc >> 1) + (phase == 0);\r\nif (++phase >= (80 >> (s->sfc >> 1)))\r\nphase = 0;\r\ns->data_block_state = phase;\r\n}\r\nreturn data_blocks;\r\n}\r\nstatic unsigned int calculate_syt(struct amdtp_stream *s,\r\nunsigned int cycle)\r\n{\r\nunsigned int syt_offset, phase, index, syt;\r\nif (s->last_syt_offset < TICKS_PER_CYCLE) {\r\nif (!cip_sfc_is_base_44100(s->sfc))\r\nsyt_offset = s->last_syt_offset + s->syt_offset_state;\r\nelse {\r\nphase = s->syt_offset_state;\r\nindex = phase % 13;\r\nsyt_offset = s->last_syt_offset;\r\nsyt_offset += 1386 + ((index && !(index & 3)) ||\r\nphase == 146);\r\nif (++phase >= 147)\r\nphase = 0;\r\ns->syt_offset_state = phase;\r\n}\r\n} else\r\nsyt_offset = s->last_syt_offset - TICKS_PER_CYCLE;\r\ns->last_syt_offset = syt_offset;\r\nif (syt_offset < TICKS_PER_CYCLE) {\r\nsyt_offset += s->transfer_delay;\r\nsyt = (cycle + syt_offset / TICKS_PER_CYCLE) << 12;\r\nsyt += syt_offset % TICKS_PER_CYCLE;\r\nreturn syt & CIP_SYT_MASK;\r\n} else {\r\nreturn CIP_SYT_NO_INFO;\r\n}\r\n}\r\nstatic void amdtp_write_s32(struct amdtp_stream *s,\r\nstruct snd_pcm_substream *pcm,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nunsigned int channels, remaining_frames, i, c;\r\nconst u32 *src;\r\nchannels = s->pcm_channels;\r\nsrc = (void *)runtime->dma_area +\r\nframes_to_bytes(runtime, s->pcm_buffer_pointer);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < channels; ++c) {\r\nbuffer[s->pcm_positions[c]] =\r\ncpu_to_be32((*src >> 8) | 0x40000000);\r\nsrc++;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--remaining_frames == 0)\r\nsrc = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void amdtp_write_s16(struct amdtp_stream *s,\r\nstruct snd_pcm_substream *pcm,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nunsigned int channels, remaining_frames, i, c;\r\nconst u16 *src;\r\nchannels = s->pcm_channels;\r\nsrc = (void *)runtime->dma_area +\r\nframes_to_bytes(runtime, s->pcm_buffer_pointer);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < channels; ++c) {\r\nbuffer[s->pcm_positions[c]] =\r\ncpu_to_be32((*src << 8) | 0x42000000);\r\nsrc++;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--remaining_frames == 0)\r\nsrc = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void amdtp_read_s32(struct amdtp_stream *s,\r\nstruct snd_pcm_substream *pcm,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nunsigned int channels, remaining_frames, i, c;\r\nu32 *dst;\r\nchannels = s->pcm_channels;\r\ndst = (void *)runtime->dma_area +\r\nframes_to_bytes(runtime, s->pcm_buffer_pointer);\r\nremaining_frames = runtime->buffer_size - s->pcm_buffer_pointer;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < channels; ++c) {\r\n*dst = be32_to_cpu(buffer[s->pcm_positions[c]]) << 8;\r\ndst++;\r\n}\r\nbuffer += s->data_block_quadlets;\r\nif (--remaining_frames == 0)\r\ndst = (void *)runtime->dma_area;\r\n}\r\n}\r\nstatic void amdtp_fill_pcm_silence(struct amdtp_stream *s,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nunsigned int i, c;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (c = 0; c < s->pcm_channels; ++c)\r\nbuffer[s->pcm_positions[c]] = cpu_to_be32(0x40000000);\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nstatic void amdtp_fill_midi(struct amdtp_stream *s,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nunsigned int f, port;\r\nu8 *b;\r\nfor (f = 0; f < frames; f++) {\r\nbuffer[s->midi_position] = 0;\r\nb = (u8 *)&buffer[s->midi_position];\r\nport = (s->data_block_counter + f) % 8;\r\nif ((f >= s->rx_blocks_for_midi) ||\r\n(s->midi[port] == NULL) ||\r\n(snd_rawmidi_transmit(s->midi[port], b + 1, 1) <= 0))\r\nb[0] = 0x80;\r\nelse\r\nb[0] = 0x81;\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nstatic void amdtp_pull_midi(struct amdtp_stream *s,\r\n__be32 *buffer, unsigned int frames)\r\n{\r\nunsigned int f, port;\r\nint len;\r\nu8 *b;\r\nfor (f = 0; f < frames; f++) {\r\nport = (s->data_block_counter + f) % 8;\r\nb = (u8 *)&buffer[s->midi_position];\r\nlen = b[0] - 0x80;\r\nif ((1 <= len) && (len <= 3) && (s->midi[port]))\r\nsnd_rawmidi_receive(s->midi[port], b + 1, len);\r\nbuffer += s->data_block_quadlets;\r\n}\r\n}\r\nstatic void update_pcm_pointers(struct amdtp_stream *s,\r\nstruct snd_pcm_substream *pcm,\r\nunsigned int frames)\r\n{\r\nunsigned int ptr;\r\nif (s->double_pcm_frames)\r\nframes *= 2;\r\nptr = s->pcm_buffer_pointer + frames;\r\nif (ptr >= pcm->runtime->buffer_size)\r\nptr -= pcm->runtime->buffer_size;\r\nACCESS_ONCE(s->pcm_buffer_pointer) = ptr;\r\ns->pcm_period_pointer += frames;\r\nif (s->pcm_period_pointer >= pcm->runtime->period_size) {\r\ns->pcm_period_pointer -= pcm->runtime->period_size;\r\ns->pointer_flush = false;\r\ntasklet_hi_schedule(&s->period_tasklet);\r\n}\r\n}\r\nstatic void pcm_period_tasklet(unsigned long data)\r\n{\r\nstruct amdtp_stream *s = (void *)data;\r\nstruct snd_pcm_substream *pcm = ACCESS_ONCE(s->pcm);\r\nif (pcm)\r\nsnd_pcm_period_elapsed(pcm);\r\n}\r\nstatic int queue_packet(struct amdtp_stream *s,\r\nunsigned int header_length,\r\nunsigned int payload_length, bool skip)\r\n{\r\nstruct fw_iso_packet p = {0};\r\nint err = 0;\r\nif (IS_ERR(s->context))\r\ngoto end;\r\np.interrupt = IS_ALIGNED(s->packet_index + 1, INTERRUPT_INTERVAL);\r\np.tag = TAG_CIP;\r\np.header_length = header_length;\r\np.payload_length = (!skip) ? payload_length : 0;\r\np.skip = skip;\r\nerr = fw_iso_context_queue(s->context, &p, &s->buffer.iso_buffer,\r\ns->buffer.packets[s->packet_index].offset);\r\nif (err < 0) {\r\ndev_err(&s->unit->device, "queueing error: %d\n", err);\r\ngoto end;\r\n}\r\nif (++s->packet_index >= QUEUE_LENGTH)\r\ns->packet_index = 0;\r\nend:\r\nreturn err;\r\n}\r\nstatic inline int queue_out_packet(struct amdtp_stream *s,\r\nunsigned int payload_length, bool skip)\r\n{\r\nreturn queue_packet(s, OUT_PACKET_HEADER_SIZE,\r\npayload_length, skip);\r\n}\r\nstatic inline int queue_in_packet(struct amdtp_stream *s)\r\n{\r\nreturn queue_packet(s, IN_PACKET_HEADER_SIZE,\r\namdtp_stream_get_max_payload(s), false);\r\n}\r\nstatic void handle_out_packet(struct amdtp_stream *s, unsigned int syt)\r\n{\r\n__be32 *buffer;\r\nunsigned int data_blocks, payload_length;\r\nstruct snd_pcm_substream *pcm;\r\nif (s->packet_index < 0)\r\nreturn;\r\nif (!(s->flags & CIP_BLOCKING) || (syt != CIP_SYT_NO_INFO))\r\ndata_blocks = calculate_data_blocks(s);\r\nelse\r\ndata_blocks = 0;\r\nbuffer = s->buffer.packets[s->packet_index].buffer;\r\nbuffer[0] = cpu_to_be32(ACCESS_ONCE(s->source_node_id_field) |\r\n(s->data_block_quadlets << AMDTP_DBS_SHIFT) |\r\ns->data_block_counter);\r\nbuffer[1] = cpu_to_be32(CIP_EOH | CIP_FMT_AM | AMDTP_FDF_AM824 |\r\n(s->sfc << CIP_FDF_SFC_SHIFT) | syt);\r\nbuffer += 2;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm)\r\ns->transfer_samples(s, pcm, buffer, data_blocks);\r\nelse\r\namdtp_fill_pcm_silence(s, buffer, data_blocks);\r\nif (s->midi_ports)\r\namdtp_fill_midi(s, buffer, data_blocks);\r\ns->data_block_counter = (s->data_block_counter + data_blocks) & 0xff;\r\npayload_length = 8 + data_blocks * 4 * s->data_block_quadlets;\r\nif (queue_out_packet(s, payload_length, false) < 0) {\r\ns->packet_index = -1;\r\namdtp_stream_pcm_abort(s);\r\nreturn;\r\n}\r\nif (pcm)\r\nupdate_pcm_pointers(s, pcm, data_blocks);\r\n}\r\nstatic void handle_in_packet(struct amdtp_stream *s,\r\nunsigned int payload_quadlets,\r\n__be32 *buffer)\r\n{\r\nu32 cip_header[2];\r\nunsigned int data_blocks, data_block_quadlets, data_block_counter,\r\ndbc_interval;\r\nstruct snd_pcm_substream *pcm = NULL;\r\nbool lost;\r\ncip_header[0] = be32_to_cpu(buffer[0]);\r\ncip_header[1] = be32_to_cpu(buffer[1]);\r\nif (((cip_header[0] & CIP_EOH_MASK) == CIP_EOH) ||\r\n((cip_header[1] & CIP_EOH_MASK) != CIP_EOH) ||\r\n((cip_header[1] & CIP_FMT_MASK) != CIP_FMT_AM)) {\r\ndev_info_ratelimited(&s->unit->device,\r\n"Invalid CIP header for AMDTP: %08X:%08X\n",\r\ncip_header[0], cip_header[1]);\r\ngoto end;\r\n}\r\nif (payload_quadlets < 3 ||\r\n((cip_header[1] & CIP_FDF_MASK) ==\r\n(AMDTP_FDF_NO_DATA << CIP_FDF_SFC_SHIFT))) {\r\ndata_blocks = 0;\r\n} else {\r\ndata_block_quadlets =\r\n(cip_header[0] & AMDTP_DBS_MASK) >> AMDTP_DBS_SHIFT;\r\nif (data_block_quadlets == 0) {\r\ndev_info_ratelimited(&s->unit->device,\r\n"Detect invalid value in dbs field: %08X\n",\r\ncip_header[0]);\r\ngoto err;\r\n}\r\nif (s->flags & CIP_WRONG_DBS)\r\ndata_block_quadlets = s->data_block_quadlets;\r\ndata_blocks = (payload_quadlets - 2) / data_block_quadlets;\r\n}\r\ndata_block_counter = cip_header[0] & AMDTP_DBC_MASK;\r\nif (data_blocks == 0 && (s->flags & CIP_EMPTY_HAS_WRONG_DBC) &&\r\ns->data_block_counter != UINT_MAX)\r\ndata_block_counter = s->data_block_counter;\r\nif (((s->flags & CIP_SKIP_DBC_ZERO_CHECK) && data_block_counter == 0) ||\r\n(s->data_block_counter == UINT_MAX)) {\r\nlost = false;\r\n} else if (!(s->flags & CIP_DBC_IS_END_EVENT)) {\r\nlost = data_block_counter != s->data_block_counter;\r\n} else {\r\nif ((data_blocks > 0) && (s->tx_dbc_interval > 0))\r\ndbc_interval = s->tx_dbc_interval;\r\nelse\r\ndbc_interval = data_blocks;\r\nlost = data_block_counter !=\r\n((s->data_block_counter + dbc_interval) & 0xff);\r\n}\r\nif (lost) {\r\ndev_info(&s->unit->device,\r\n"Detect discontinuity of CIP: %02X %02X\n",\r\ns->data_block_counter, data_block_counter);\r\ngoto err;\r\n}\r\nif (data_blocks > 0) {\r\nbuffer += 2;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm)\r\ns->transfer_samples(s, pcm, buffer, data_blocks);\r\nif (s->midi_ports)\r\namdtp_pull_midi(s, buffer, data_blocks);\r\n}\r\nif (s->flags & CIP_DBC_IS_END_EVENT)\r\ns->data_block_counter = data_block_counter;\r\nelse\r\ns->data_block_counter =\r\n(data_block_counter + data_blocks) & 0xff;\r\nend:\r\nif (queue_in_packet(s) < 0)\r\ngoto err;\r\nif (pcm)\r\nupdate_pcm_pointers(s, pcm, data_blocks);\r\nreturn;\r\nerr:\r\ns->packet_index = -1;\r\namdtp_stream_pcm_abort(s);\r\n}\r\nstatic void out_stream_callback(struct fw_iso_context *context, u32 cycle,\r\nsize_t header_length, void *header,\r\nvoid *private_data)\r\n{\r\nstruct amdtp_stream *s = private_data;\r\nunsigned int i, syt, packets = header_length / 4;\r\ncycle += QUEUE_LENGTH - packets;\r\nfor (i = 0; i < packets; ++i) {\r\nsyt = calculate_syt(s, ++cycle);\r\nhandle_out_packet(s, syt);\r\n}\r\nfw_iso_context_queue_flush(s->context);\r\n}\r\nstatic void in_stream_callback(struct fw_iso_context *context, u32 cycle,\r\nsize_t header_length, void *header,\r\nvoid *private_data)\r\n{\r\nstruct amdtp_stream *s = private_data;\r\nunsigned int p, syt, packets, payload_quadlets;\r\n__be32 *buffer, *headers = header;\r\npackets = header_length / IN_PACKET_HEADER_SIZE;\r\nfor (p = 0; p < packets; p++) {\r\nif (s->packet_index < 0)\r\nbreak;\r\nbuffer = s->buffer.packets[s->packet_index].buffer;\r\nif (s->sync_slave && s->sync_slave->callbacked) {\r\nsyt = be32_to_cpu(buffer[1]) & CIP_SYT_MASK;\r\nhandle_out_packet(s->sync_slave, syt);\r\n}\r\npayload_quadlets =\r\n(be32_to_cpu(headers[p]) >> ISO_DATA_LENGTH_SHIFT) / 4;\r\nhandle_in_packet(s, payload_quadlets, buffer);\r\n}\r\nif (s->packet_index < 0) {\r\nif (s->sync_slave) {\r\ns->sync_slave->packet_index = -1;\r\namdtp_stream_pcm_abort(s->sync_slave);\r\n}\r\nreturn;\r\n}\r\nif (s->sync_slave && s->sync_slave->callbacked)\r\nfw_iso_context_queue_flush(s->sync_slave->context);\r\nfw_iso_context_queue_flush(s->context);\r\n}\r\nstatic void slave_stream_callback(struct fw_iso_context *context, u32 cycle,\r\nsize_t header_length, void *header,\r\nvoid *private_data)\r\n{\r\nreturn;\r\n}\r\nstatic void amdtp_stream_first_callback(struct fw_iso_context *context,\r\nu32 cycle, size_t header_length,\r\nvoid *header, void *private_data)\r\n{\r\nstruct amdtp_stream *s = private_data;\r\ns->callbacked = true;\r\nwake_up(&s->callback_wait);\r\nif (s->direction == AMDTP_IN_STREAM)\r\ncontext->callback.sc = in_stream_callback;\r\nelse if ((s->flags & CIP_BLOCKING) && (s->flags & CIP_SYNC_TO_DEVICE))\r\ncontext->callback.sc = slave_stream_callback;\r\nelse\r\ncontext->callback.sc = out_stream_callback;\r\ncontext->callback.sc(context, cycle, header_length, header, s);\r\n}\r\nint amdtp_stream_start(struct amdtp_stream *s, int channel, int speed)\r\n{\r\nstatic const struct {\r\nunsigned int data_block;\r\nunsigned int syt_offset;\r\n} initial_state[] = {\r\n[CIP_SFC_32000] = { 4, 3072 },\r\n[CIP_SFC_48000] = { 6, 1024 },\r\n[CIP_SFC_96000] = { 12, 1024 },\r\n[CIP_SFC_192000] = { 24, 1024 },\r\n[CIP_SFC_44100] = { 0, 67 },\r\n[CIP_SFC_88200] = { 0, 67 },\r\n[CIP_SFC_176400] = { 0, 67 },\r\n};\r\nunsigned int header_size;\r\nenum dma_data_direction dir;\r\nint type, tag, err;\r\nmutex_lock(&s->mutex);\r\nif (WARN_ON(amdtp_stream_running(s) ||\r\n(s->data_block_quadlets < 1))) {\r\nerr = -EBADFD;\r\ngoto err_unlock;\r\n}\r\nif (s->direction == AMDTP_IN_STREAM &&\r\ns->flags & CIP_SKIP_INIT_DBC_CHECK)\r\ns->data_block_counter = UINT_MAX;\r\nelse\r\ns->data_block_counter = 0;\r\ns->data_block_state = initial_state[s->sfc].data_block;\r\ns->syt_offset_state = initial_state[s->sfc].syt_offset;\r\ns->last_syt_offset = TICKS_PER_CYCLE;\r\nif (s->direction == AMDTP_IN_STREAM) {\r\ndir = DMA_FROM_DEVICE;\r\ntype = FW_ISO_CONTEXT_RECEIVE;\r\nheader_size = IN_PACKET_HEADER_SIZE;\r\n} else {\r\ndir = DMA_TO_DEVICE;\r\ntype = FW_ISO_CONTEXT_TRANSMIT;\r\nheader_size = OUT_PACKET_HEADER_SIZE;\r\n}\r\nerr = iso_packets_buffer_init(&s->buffer, s->unit, QUEUE_LENGTH,\r\namdtp_stream_get_max_payload(s), dir);\r\nif (err < 0)\r\ngoto err_unlock;\r\ns->context = fw_iso_context_create(fw_parent_device(s->unit)->card,\r\ntype, channel, speed, header_size,\r\namdtp_stream_first_callback, s);\r\nif (IS_ERR(s->context)) {\r\nerr = PTR_ERR(s->context);\r\nif (err == -EBUSY)\r\ndev_err(&s->unit->device,\r\n"no free stream on this controller\n");\r\ngoto err_buffer;\r\n}\r\namdtp_stream_update(s);\r\ns->packet_index = 0;\r\ndo {\r\nif (s->direction == AMDTP_IN_STREAM)\r\nerr = queue_in_packet(s);\r\nelse\r\nerr = queue_out_packet(s, 0, true);\r\nif (err < 0)\r\ngoto err_context;\r\n} while (s->packet_index > 0);\r\ntag = FW_ISO_CONTEXT_MATCH_TAG1;\r\nif (s->flags & CIP_EMPTY_WITH_TAG0)\r\ntag |= FW_ISO_CONTEXT_MATCH_TAG0;\r\ns->callbacked = false;\r\nerr = fw_iso_context_start(s->context, -1, 0, tag);\r\nif (err < 0)\r\ngoto err_context;\r\nmutex_unlock(&s->mutex);\r\nreturn 0;\r\nerr_context:\r\nfw_iso_context_destroy(s->context);\r\ns->context = ERR_PTR(-1);\r\nerr_buffer:\r\niso_packets_buffer_destroy(&s->buffer, s->unit);\r\nerr_unlock:\r\nmutex_unlock(&s->mutex);\r\nreturn err;\r\n}\r\nunsigned long amdtp_stream_pcm_pointer(struct amdtp_stream *s)\r\n{\r\nif (s->pointer_flush && amdtp_stream_running(s))\r\nfw_iso_context_flush_completions(s->context);\r\nelse\r\ns->pointer_flush = true;\r\nreturn ACCESS_ONCE(s->pcm_buffer_pointer);\r\n}\r\nvoid amdtp_stream_update(struct amdtp_stream *s)\r\n{\r\nACCESS_ONCE(s->source_node_id_field) =\r\n(fw_parent_device(s->unit)->card->node_id & 0x3f) << 24;\r\n}\r\nvoid amdtp_stream_stop(struct amdtp_stream *s)\r\n{\r\nmutex_lock(&s->mutex);\r\nif (!amdtp_stream_running(s)) {\r\nmutex_unlock(&s->mutex);\r\nreturn;\r\n}\r\ntasklet_kill(&s->period_tasklet);\r\nfw_iso_context_stop(s->context);\r\nfw_iso_context_destroy(s->context);\r\ns->context = ERR_PTR(-1);\r\niso_packets_buffer_destroy(&s->buffer, s->unit);\r\ns->callbacked = false;\r\nmutex_unlock(&s->mutex);\r\n}\r\nvoid amdtp_stream_pcm_abort(struct amdtp_stream *s)\r\n{\r\nstruct snd_pcm_substream *pcm;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm) {\r\nsnd_pcm_stream_lock_irq(pcm);\r\nif (snd_pcm_running(pcm))\r\nsnd_pcm_stop(pcm, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irq(pcm);\r\n}\r\n}
