static int __init fas216_log_setup(char *str)\r\n{\r\nchar *s;\r\nlevel_mask = 0;\r\nwhile ((s = strsep(&str, ",")) != NULL) {\r\nswitch (s[0]) {\r\ncase 'a':\r\nif (strcmp(s, "all") == 0)\r\nlevel_mask |= -1;\r\nbreak;\r\ncase 'b':\r\nif (strncmp(s, "bus", 3) == 0)\r\nlevel_mask |= LOG_BUSSERVICE;\r\nif (strncmp(s, "buf", 3) == 0)\r\nlevel_mask |= LOG_BUFFER;\r\nbreak;\r\ncase 'c':\r\nlevel_mask |= LOG_CONNECT;\r\nbreak;\r\ncase 'e':\r\nlevel_mask |= LOG_ERROR;\r\nbreak;\r\ncase 'm':\r\nlevel_mask |= LOG_MESSAGES;\r\nbreak;\r\ncase 'n':\r\nif (strcmp(s, "none") == 0)\r\nlevel_mask = 0;\r\nbreak;\r\ncase 's':\r\nlevel_mask |= LOG_FUNCTIONDONE;\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic inline unsigned char fas216_readb(FAS216_Info *info, unsigned int reg)\r\n{\r\nunsigned int off = reg << info->scsi.io_shift;\r\nreturn readb(info->scsi.io_base + off);\r\n}\r\nstatic inline void fas216_writeb(FAS216_Info *info, unsigned int reg, unsigned int val)\r\n{\r\nunsigned int off = reg << info->scsi.io_shift;\r\nwriteb(val, info->scsi.io_base + off);\r\n}\r\nstatic void fas216_dumpstate(FAS216_Info *info)\r\n{\r\nunsigned char is, stat, inst;\r\nis = fas216_readb(info, REG_IS);\r\nstat = fas216_readb(info, REG_STAT);\r\ninst = fas216_readb(info, REG_INST);\r\nprintk("FAS216: CTCL=%02X CTCM=%02X CMD=%02X STAT=%02X"\r\n" INST=%02X IS=%02X CFIS=%02X",\r\nfas216_readb(info, REG_CTCL),\r\nfas216_readb(info, REG_CTCM),\r\nfas216_readb(info, REG_CMD), stat, inst, is,\r\nfas216_readb(info, REG_CFIS));\r\nprintk(" CNTL1=%02X CNTL2=%02X CNTL3=%02X CTCH=%02X\n",\r\nfas216_readb(info, REG_CNTL1),\r\nfas216_readb(info, REG_CNTL2),\r\nfas216_readb(info, REG_CNTL3),\r\nfas216_readb(info, REG_CTCH));\r\n}\r\nstatic void print_SCp(struct scsi_pointer *SCp, const char *prefix, const char *suffix)\r\n{\r\nprintk("%sptr %p this_residual 0x%x buffer %p buffers_residual 0x%x%s",\r\nprefix, SCp->ptr, SCp->this_residual, SCp->buffer,\r\nSCp->buffers_residual, suffix);\r\n}\r\nstatic void fas216_dumpinfo(FAS216_Info *info)\r\n{\r\nstatic int used = 0;\r\nint i;\r\nif (used++)\r\nreturn;\r\nprintk("FAS216_Info=\n");\r\nprintk(" { magic_start=%lX host=%p SCpnt=%p origSCpnt=%p\n",\r\ninfo->magic_start, info->host, info->SCpnt,\r\ninfo->origSCpnt);\r\nprintk(" scsi={ io_shift=%X irq=%X cfg={ %X %X %X %X }\n",\r\ninfo->scsi.io_shift, info->scsi.irq,\r\ninfo->scsi.cfg[0], info->scsi.cfg[1], info->scsi.cfg[2],\r\ninfo->scsi.cfg[3]);\r\nprintk(" type=%p phase=%X\n",\r\ninfo->scsi.type, info->scsi.phase);\r\nprint_SCp(&info->scsi.SCp, " SCp={ ", " }\n");\r\nprintk(" msgs async_stp=%X disconnectable=%d aborting=%d }\n",\r\ninfo->scsi.async_stp,\r\ninfo->scsi.disconnectable, info->scsi.aborting);\r\nprintk(" stats={ queues=%X removes=%X fins=%X reads=%X writes=%X miscs=%X\n"\r\n" disconnects=%X aborts=%X bus_resets=%X host_resets=%X}\n",\r\ninfo->stats.queues, info->stats.removes, info->stats.fins,\r\ninfo->stats.reads, info->stats.writes, info->stats.miscs,\r\ninfo->stats.disconnects, info->stats.aborts, info->stats.bus_resets,\r\ninfo->stats.host_resets);\r\nprintk(" ifcfg={ clockrate=%X select_timeout=%X asyncperiod=%X sync_max_depth=%X }\n",\r\ninfo->ifcfg.clockrate, info->ifcfg.select_timeout,\r\ninfo->ifcfg.asyncperiod, info->ifcfg.sync_max_depth);\r\nfor (i = 0; i < 8; i++) {\r\nprintk(" busyluns[%d]=%08lx dev[%d]={ disconnect_ok=%d stp=%X sof=%X sync_state=%X }\n",\r\ni, info->busyluns[i], i,\r\ninfo->device[i].disconnect_ok, info->device[i].stp,\r\ninfo->device[i].sof, info->device[i].sync_state);\r\n}\r\nprintk(" dma={ transfer_type=%X setup=%p pseudo=%p stop=%p }\n",\r\ninfo->dma.transfer_type, info->dma.setup,\r\ninfo->dma.pseudo, info->dma.stop);\r\nprintk(" internal_done=%X magic_end=%lX }\n",\r\ninfo->internal_done, info->magic_end);\r\n}\r\nstatic void __fas216_checkmagic(FAS216_Info *info, const char *func)\r\n{\r\nint corruption = 0;\r\nif (info->magic_start != MAGIC) {\r\nprintk(KERN_CRIT "FAS216 Error: magic at start corrupted\n");\r\ncorruption++;\r\n}\r\nif (info->magic_end != MAGIC) {\r\nprintk(KERN_CRIT "FAS216 Error: magic at end corrupted\n");\r\ncorruption++;\r\n}\r\nif (corruption) {\r\nfas216_dumpinfo(info);\r\npanic("scsi memory space corrupted in %s", func);\r\n}\r\n}\r\nstatic const char *fas216_bus_phase(int stat)\r\n{\r\nstatic const char *phases[] = {\r\n"DATA OUT", "DATA IN",\r\n"COMMAND", "STATUS",\r\n"MISC OUT", "MISC IN",\r\n"MESG OUT", "MESG IN"\r\n};\r\nreturn phases[stat & STAT_BUSMASK];\r\n}\r\nstatic const char *fas216_drv_phase(FAS216_Info *info)\r\n{\r\nstatic const char *phases[] = {\r\n[PHASE_IDLE] = "idle",\r\n[PHASE_SELECTION] = "selection",\r\n[PHASE_COMMAND] = "command",\r\n[PHASE_DATAOUT] = "data out",\r\n[PHASE_DATAIN] = "data in",\r\n[PHASE_MSGIN] = "message in",\r\n[PHASE_MSGIN_DISCONNECT]= "disconnect",\r\n[PHASE_MSGOUT_EXPECT] = "expect message out",\r\n[PHASE_MSGOUT] = "message out",\r\n[PHASE_STATUS] = "status",\r\n[PHASE_DONE] = "done",\r\n};\r\nif (info->scsi.phase < ARRAY_SIZE(phases) &&\r\nphases[info->scsi.phase])\r\nreturn phases[info->scsi.phase];\r\nreturn "???";\r\n}\r\nstatic char fas216_target(FAS216_Info *info)\r\n{\r\nif (info->SCpnt)\r\nreturn '0' + info->SCpnt->device->id;\r\nelse\r\nreturn 'H';\r\n}\r\nstatic void\r\nfas216_do_log(FAS216_Info *info, char target, char *fmt, va_list ap)\r\n{\r\nstatic char buf[1024];\r\nvsnprintf(buf, sizeof(buf), fmt, ap);\r\nprintk("scsi%d.%c: %s", info->host->host_no, target, buf);\r\n}\r\nstatic void fas216_log_command(FAS216_Info *info, int level,\r\nstruct scsi_cmnd *SCpnt, char *fmt, ...)\r\n{\r\nva_list args;\r\nif (level != 0 && !(level & level_mask))\r\nreturn;\r\nva_start(args, fmt);\r\nfas216_do_log(info, '0' + SCpnt->device->id, fmt, args);\r\nva_end(args);\r\nprintk(" CDB: ");\r\n__scsi_print_command(SCpnt->cmnd);\r\n}\r\nstatic void\r\nfas216_log_target(FAS216_Info *info, int level, int target, char *fmt, ...)\r\n{\r\nva_list args;\r\nif (level != 0 && !(level & level_mask))\r\nreturn;\r\nif (target < 0)\r\ntarget = 'H';\r\nelse\r\ntarget += '0';\r\nva_start(args, fmt);\r\nfas216_do_log(info, target, fmt, args);\r\nva_end(args);\r\nprintk("\n");\r\n}\r\nstatic void fas216_log(FAS216_Info *info, int level, char *fmt, ...)\r\n{\r\nva_list args;\r\nif (level != 0 && !(level & level_mask))\r\nreturn;\r\nva_start(args, fmt);\r\nfas216_do_log(info, fas216_target(info), fmt, args);\r\nva_end(args);\r\nprintk("\n");\r\n}\r\nstatic void add_debug_list(int stat, int ssr, int isr, int ph)\r\n{\r\nph_list[ph_ptr].stat = stat;\r\nph_list[ph_ptr].ssr = ssr;\r\nph_list[ph_ptr].isr = isr;\r\nph_list[ph_ptr].ph = ph;\r\nph_ptr = (ph_ptr + 1) & (PH_SIZE-1);\r\n}\r\nstatic void fas216_cmd(FAS216_Info *info, unsigned int command)\r\n{\r\ncmd_list[cmd_ptr].command = command;\r\ncmd_list[cmd_ptr].from = __builtin_return_address(0);\r\ncmd_ptr = (cmd_ptr + 1) & 7;\r\nfas216_writeb(info, REG_CMD, command);\r\n}\r\nstatic void print_debug_list(void)\r\n{\r\nint i;\r\ni = ph_ptr;\r\nprintk(KERN_ERR "SCSI IRQ trail\n");\r\ndo {\r\nprintk(" %02x:%02x:%02x:%1x",\r\nph_list[i].stat, ph_list[i].ssr,\r\nph_list[i].isr, ph_list[i].ph);\r\ni = (i + 1) & (PH_SIZE - 1);\r\nif (((i ^ ph_ptr) & 7) == 0)\r\nprintk("\n");\r\n} while (i != ph_ptr);\r\nif ((i ^ ph_ptr) & 7)\r\nprintk("\n");\r\ni = cmd_ptr;\r\nprintk(KERN_ERR "FAS216 commands: ");\r\ndo {\r\nprintk("%02x:%p ", cmd_list[i].command, cmd_list[i].from);\r\ni = (i + 1) & 7;\r\n} while (i != cmd_ptr);\r\nprintk("\n");\r\n}\r\nstatic inline unsigned short\r\nfas216_get_last_msg(FAS216_Info *info, int pos)\r\n{\r\nunsigned short packed_msg = NOP;\r\nstruct message *msg;\r\nint msgnr = 0;\r\nwhile ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {\r\nif (pos >= msg->fifo)\r\nbreak;\r\n}\r\nif (msg) {\r\nif (msg->msg[0] == EXTENDED_MESSAGE)\r\npacked_msg = EXTENDED_MESSAGE | msg->msg[2] << 8;\r\nelse\r\npacked_msg = msg->msg[0];\r\n}\r\nfas216_log(info, LOG_MESSAGES,\r\n"Message: %04x found at position %02x\n", packed_msg, pos);\r\nreturn packed_msg;\r\n}\r\nstatic int fas216_syncperiod(FAS216_Info *info, int ns)\r\n{\r\nint value = (info->ifcfg.clockrate * ns) / 1000;\r\nfas216_checkmagic(info);\r\nif (value < 4)\r\nvalue = 4;\r\nelse if (value > 35)\r\nvalue = 35;\r\nreturn value & 31;\r\n}\r\nstatic void fas216_set_sync(FAS216_Info *info, int target)\r\n{\r\nunsigned int cntl3;\r\nfas216_writeb(info, REG_SOF, info->device[target].sof);\r\nfas216_writeb(info, REG_STP, info->device[target].stp);\r\ncntl3 = info->scsi.cfg[2];\r\nif (info->device[target].period >= (200 / 4))\r\ncntl3 = cntl3 & ~CNTL3_FASTSCSI;\r\nfas216_writeb(info, REG_CNTL3, cntl3);\r\n}\r\nstatic void fas216_handlesync(FAS216_Info *info, char *msg)\r\n{\r\nstruct fas216_device *dev = &info->device[info->SCpnt->device->id];\r\nenum { sync, async, none, reject } res = none;\r\n#ifdef SCSI2_SYNC\r\nswitch (msg[0]) {\r\ncase MESSAGE_REJECT:\r\nif (dev->sync_state == neg_inprogress) {\r\ndev->sync_state = neg_invalid;\r\nres = async;\r\n}\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nswitch (dev->sync_state) {\r\ncase neg_invalid:\r\nres = reject;\r\nbreak;\r\ndefault:\r\nfas216_cmd(info, CMD_SETATN);\r\nif (msg[4] > info->ifcfg.sync_max_depth)\r\nmsg[4] = info->ifcfg.sync_max_depth;\r\nif (msg[3] < 1000 / info->ifcfg.clockrate)\r\nmsg[3] = 1000 / info->ifcfg.clockrate;\r\nmsgqueue_flush(&info->scsi.msgs);\r\nmsgqueue_addmsg(&info->scsi.msgs, 5,\r\nEXTENDED_MESSAGE, 3, EXTENDED_SDTR,\r\nmsg[3], msg[4]);\r\ninfo->scsi.phase = PHASE_MSGOUT_EXPECT;\r\ndev->sync_state = neg_targcomplete;\r\nres = sync;\r\nbreak;\r\ncase neg_inprogress:\r\nres = reject;\r\nif (msg[4] <= info->ifcfg.sync_max_depth &&\r\nmsg[3] >= 1000 / info->ifcfg.clockrate) {\r\ndev->sync_state = neg_complete;\r\nres = sync;\r\n}\r\nbreak;\r\n}\r\n}\r\n#else\r\nres = reject;\r\n#endif\r\nswitch (res) {\r\ncase sync:\r\ndev->period = msg[3];\r\ndev->sof = msg[4];\r\ndev->stp = fas216_syncperiod(info, msg[3] * 4);\r\nfas216_set_sync(info, info->SCpnt->device->id);\r\nbreak;\r\ncase reject:\r\nfas216_cmd(info, CMD_SETATN);\r\nmsgqueue_flush(&info->scsi.msgs);\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, MESSAGE_REJECT);\r\ninfo->scsi.phase = PHASE_MSGOUT_EXPECT;\r\ncase async:\r\ndev->period = info->ifcfg.asyncperiod / 4;\r\ndev->sof = 0;\r\ndev->stp = info->scsi.async_stp;\r\nfas216_set_sync(info, info->SCpnt->device->id);\r\nbreak;\r\ncase none:\r\nbreak;\r\n}\r\n}\r\nstatic void fas216_updateptrs(FAS216_Info *info, int bytes_transferred)\r\n{\r\nstruct scsi_pointer *SCp = &info->scsi.SCp;\r\nfas216_checkmagic(info);\r\nBUG_ON(bytes_transferred < 0);\r\nSCp->phase -= bytes_transferred;\r\nwhile (bytes_transferred != 0) {\r\nif (SCp->this_residual > bytes_transferred)\r\nbreak;\r\nbytes_transferred -= SCp->this_residual;\r\nif (!next_SCp(SCp) && bytes_transferred) {\r\nprintk(KERN_WARNING "scsi%d.%c: out of buffers\n",\r\ninfo->host->host_no, '0' + info->SCpnt->device->id);\r\nreturn;\r\n}\r\n}\r\nSCp->this_residual -= bytes_transferred;\r\nif (SCp->this_residual)\r\nSCp->ptr += bytes_transferred;\r\nelse\r\nSCp->ptr = NULL;\r\n}\r\nstatic void fas216_pio(FAS216_Info *info, fasdmadir_t direction)\r\n{\r\nstruct scsi_pointer *SCp = &info->scsi.SCp;\r\nfas216_checkmagic(info);\r\nif (direction == DMA_OUT)\r\nfas216_writeb(info, REG_FF, get_next_SCp_byte(SCp));\r\nelse\r\nput_next_SCp_byte(SCp, fas216_readb(info, REG_FF));\r\nif (SCp->this_residual == 0)\r\nnext_SCp(SCp);\r\n}\r\nstatic void fas216_set_stc(FAS216_Info *info, unsigned int length)\r\n{\r\nfas216_writeb(info, REG_STCL, length);\r\nfas216_writeb(info, REG_STCM, length >> 8);\r\nfas216_writeb(info, REG_STCH, length >> 16);\r\n}\r\nstatic unsigned int fas216_get_ctc(FAS216_Info *info)\r\n{\r\nreturn fas216_readb(info, REG_CTCL) +\r\n(fas216_readb(info, REG_CTCM) << 8) +\r\n(fas216_readb(info, REG_CTCH) << 16);\r\n}\r\nstatic void fas216_cleanuptransfer(FAS216_Info *info)\r\n{\r\nunsigned long total, residual, fifo;\r\nfasdmatype_t dmatype = info->dma.transfer_type;\r\ninfo->dma.transfer_type = fasdma_none;\r\nif (dmatype == fasdma_pio || dmatype == fasdma_none)\r\nreturn;\r\nif (dmatype == fasdma_real_all)\r\ntotal = info->scsi.SCp.phase;\r\nelse\r\ntotal = info->scsi.SCp.this_residual;\r\nresidual = fas216_get_ctc(info);\r\nfifo = fas216_readb(info, REG_CFIS) & CFIS_CF;\r\nfas216_log(info, LOG_BUFFER, "cleaning up from previous "\r\n"transfer: length 0x%06x, residual 0x%x, fifo %d",\r\ntotal, residual, fifo);\r\nif (info->scsi.phase == PHASE_DATAOUT)\r\nresidual += fifo;\r\nfas216_updateptrs(info, total - residual);\r\n}\r\nstatic void fas216_transfer(FAS216_Info *info)\r\n{\r\nfasdmadir_t direction;\r\nfasdmatype_t dmatype;\r\nfas216_log(info, LOG_BUFFER,\r\n"starttransfer: buffer %p length 0x%06x reqlen 0x%06x",\r\ninfo->scsi.SCp.ptr, info->scsi.SCp.this_residual,\r\ninfo->scsi.SCp.phase);\r\nif (!info->scsi.SCp.ptr) {\r\nfas216_log(info, LOG_ERROR, "null buffer passed to "\r\n"fas216_starttransfer");\r\nprint_SCp(&info->scsi.SCp, "SCp: ", "\n");\r\nprint_SCp(&info->SCpnt->SCp, "Cmnd SCp: ", "\n");\r\nreturn;\r\n}\r\nif (info->device[info->SCpnt->device->id].sof)\r\ndmatype = fasdma_real_all;\r\nelse\r\ndmatype = fasdma_pio;\r\nif (info->scsi.phase == PHASE_DATAOUT)\r\ndirection = DMA_OUT;\r\nelse\r\ndirection = DMA_IN;\r\nif (info->dma.setup)\r\ndmatype = info->dma.setup(info->host, &info->scsi.SCp,\r\ndirection, dmatype);\r\ninfo->dma.transfer_type = dmatype;\r\nif (dmatype == fasdma_real_all)\r\nfas216_set_stc(info, info->scsi.SCp.phase);\r\nelse\r\nfas216_set_stc(info, info->scsi.SCp.this_residual);\r\nswitch (dmatype) {\r\ncase fasdma_pio:\r\nfas216_log(info, LOG_BUFFER, "PIO transfer");\r\nfas216_writeb(info, REG_SOF, 0);\r\nfas216_writeb(info, REG_STP, info->scsi.async_stp);\r\nfas216_cmd(info, CMD_TRANSFERINFO);\r\nfas216_pio(info, direction);\r\nbreak;\r\ncase fasdma_pseudo:\r\nfas216_log(info, LOG_BUFFER, "pseudo transfer");\r\nfas216_cmd(info, CMD_TRANSFERINFO | CMD_WITHDMA);\r\ninfo->dma.pseudo(info->host, &info->scsi.SCp,\r\ndirection, info->SCpnt->transfersize);\r\nbreak;\r\ncase fasdma_real_block:\r\nfas216_log(info, LOG_BUFFER, "block dma transfer");\r\nfas216_cmd(info, CMD_TRANSFERINFO | CMD_WITHDMA);\r\nbreak;\r\ncase fasdma_real_all:\r\nfas216_log(info, LOG_BUFFER, "total dma transfer");\r\nfas216_cmd(info, CMD_TRANSFERINFO | CMD_WITHDMA);\r\nbreak;\r\ndefault:\r\nfas216_log(info, LOG_BUFFER | LOG_ERROR,\r\n"invalid FAS216 DMA type");\r\nbreak;\r\n}\r\n}\r\nstatic void fas216_stoptransfer(FAS216_Info *info)\r\n{\r\nfas216_checkmagic(info);\r\nif (info->dma.transfer_type == fasdma_real_all ||\r\ninfo->dma.transfer_type == fasdma_real_block)\r\ninfo->dma.stop(info->host, &info->scsi.SCp);\r\nfas216_cleanuptransfer(info);\r\nif (info->scsi.phase == PHASE_DATAIN) {\r\nunsigned int fifo;\r\nfifo = fas216_readb(info, REG_CFIS) & CFIS_CF;\r\nwhile (fifo && info->scsi.SCp.ptr) {\r\n*info->scsi.SCp.ptr = fas216_readb(info, REG_FF);\r\nfas216_updateptrs(info, 1);\r\nfifo--;\r\n}\r\n} else {\r\nfas216_cmd(info, CMD_FLUSHFIFO);\r\n}\r\n}\r\nstatic void fas216_aborttransfer(FAS216_Info *info)\r\n{\r\nfas216_checkmagic(info);\r\nif (info->dma.transfer_type == fasdma_real_all ||\r\ninfo->dma.transfer_type == fasdma_real_block)\r\ninfo->dma.stop(info->host, &info->scsi.SCp);\r\ninfo->dma.transfer_type = fasdma_none;\r\nfas216_cmd(info, CMD_FLUSHFIFO);\r\n}\r\nstatic void fas216_disconnect_intr(FAS216_Info *info)\r\n{\r\nunsigned long flags;\r\nfas216_checkmagic(info);\r\nfas216_log(info, LOG_CONNECT, "disconnect phase=%02x",\r\ninfo->scsi.phase);\r\nmsgqueue_flush(&info->scsi.msgs);\r\nswitch (info->scsi.phase) {\r\ncase PHASE_SELECTION:\r\ncase PHASE_SELSTEPS:\r\nfas216_done(info, DID_NO_CONNECT);\r\nbreak;\r\ncase PHASE_MSGIN_DISCONNECT:\r\ninfo->scsi.disconnectable = 1;\r\ninfo->scsi.phase = PHASE_IDLE;\r\ninfo->stats.disconnects += 1;\r\nspin_lock_irqsave(&info->host_lock, flags);\r\nif (info->scsi.phase == PHASE_IDLE)\r\nfas216_kick(info);\r\nspin_unlock_irqrestore(&info->host_lock, flags);\r\nbreak;\r\ncase PHASE_DONE:\r\nfas216_done(info, DID_OK);\r\nbreak;\r\ncase PHASE_MSGOUT:\r\nif (fas216_get_last_msg(info, info->scsi.msgin_fifo) == ABORT) {\r\ninfo->scsi.aborting = 0;\r\nfas216_done(info, DID_ABORT);\r\nbreak;\r\n}\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: unexpected disconnect in phase %s\n",\r\ninfo->host->host_no, fas216_target(info), fas216_drv_phase(info));\r\nprint_debug_list();\r\nfas216_stoptransfer(info);\r\nfas216_done(info, DID_ERROR);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nfas216_reselected_intr(FAS216_Info *info)\r\n{\r\nunsigned int cfis, i;\r\nunsigned char msg[4];\r\nunsigned char target, lun, tag;\r\nfas216_checkmagic(info);\r\nWARN_ON(info->scsi.phase == PHASE_SELECTION ||\r\ninfo->scsi.phase == PHASE_SELSTEPS);\r\ncfis = fas216_readb(info, REG_CFIS);\r\nfas216_log(info, LOG_CONNECT, "reconnect phase=%02x cfis=%02x",\r\ninfo->scsi.phase, cfis);\r\ncfis &= CFIS_CF;\r\nif (cfis < 2 || cfis > 4) {\r\nprintk(KERN_ERR "scsi%d.H: incorrect number of bytes after reselect\n",\r\ninfo->host->host_no);\r\ngoto bad_message;\r\n}\r\nfor (i = 0; i < cfis; i++)\r\nmsg[i] = fas216_readb(info, REG_FF);\r\nif (!(msg[0] & (1 << info->host->this_id)) ||\r\n!(msg[1] & 0x80))\r\ngoto initiator_error;\r\ntarget = msg[0] & ~(1 << info->host->this_id);\r\ntarget = ffs(target) - 1;\r\nlun = msg[1] & 7;\r\ntag = 0;\r\nif (cfis >= 3) {\r\nif (msg[2] != SIMPLE_QUEUE_TAG)\r\ngoto initiator_error;\r\ntag = msg[3];\r\n}\r\nfas216_writeb(info, REG_SDID, target);\r\nfas216_set_sync(info, target);\r\nmsgqueue_flush(&info->scsi.msgs);\r\nfas216_log(info, LOG_CONNECT, "Reconnected: target %1x lun %1x tag %02x",\r\ntarget, lun, tag);\r\nif (info->scsi.disconnectable && info->SCpnt) {\r\ninfo->scsi.disconnectable = 0;\r\nif (info->SCpnt->device->id == target &&\r\ninfo->SCpnt->device->lun == lun &&\r\ninfo->SCpnt->tag == tag) {\r\nfas216_log(info, LOG_CONNECT, "reconnected previously executing command");\r\n} else {\r\nqueue_add_cmd_tail(&info->queues.disconnected, info->SCpnt);\r\nfas216_log(info, LOG_CONNECT, "had to move command to disconnected queue");\r\ninfo->SCpnt = NULL;\r\n}\r\n}\r\nif (!info->SCpnt) {\r\ninfo->SCpnt = queue_remove_tgtluntag(&info->queues.disconnected,\r\ntarget, lun, tag);\r\nfas216_log(info, LOG_CONNECT, "had to get command");\r\n}\r\nif (info->SCpnt) {\r\ninfo->scsi.SCp = info->SCpnt->SCp;\r\nfas216_log(info, LOG_CONNECT, "data pointers: [%p, %X]",\r\ninfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\r\ninfo->scsi.phase = PHASE_MSGIN;\r\n} else {\r\nfas216_cmd(info, CMD_SETATN);\r\n#if 0\r\nif (tag)\r\nmsgqueue_addmsg(&info->scsi.msgs, 2, ABORT_TAG, tag);\r\nelse\r\n#endif\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, ABORT);\r\ninfo->scsi.phase = PHASE_MSGOUT_EXPECT;\r\ninfo->scsi.aborting = 1;\r\n}\r\nfas216_cmd(info, CMD_MSGACCEPTED);\r\nreturn;\r\ninitiator_error:\r\nprintk(KERN_ERR "scsi%d.H: error during reselection: bytes",\r\ninfo->host->host_no);\r\nfor (i = 0; i < cfis; i++)\r\nprintk(" %02x", msg[i]);\r\nprintk("\n");\r\nbad_message:\r\nfas216_cmd(info, CMD_SETATN);\r\nmsgqueue_flush(&info->scsi.msgs);\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, INITIATOR_ERROR);\r\ninfo->scsi.phase = PHASE_MSGOUT_EXPECT;\r\nfas216_cmd(info, CMD_MSGACCEPTED);\r\n}\r\nstatic void fas216_parse_message(FAS216_Info *info, unsigned char *message, int msglen)\r\n{\r\nint i;\r\nswitch (message[0]) {\r\ncase COMMAND_COMPLETE:\r\nif (msglen != 1)\r\ngoto unrecognised;\r\nprintk(KERN_ERR "scsi%d.%c: command complete with no "\r\n"status in MESSAGE_IN?\n",\r\ninfo->host->host_no, fas216_target(info));\r\nbreak;\r\ncase SAVE_POINTERS:\r\nif (msglen != 1)\r\ngoto unrecognised;\r\ninfo->SCpnt->SCp = info->scsi.SCp;\r\ninfo->SCpnt->SCp.sent_command = 0;\r\nfas216_log(info, LOG_CONNECT | LOG_MESSAGES | LOG_BUFFER,\r\n"save data pointers: [%p, %X]",\r\ninfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nif (msglen != 1)\r\ngoto unrecognised;\r\ninfo->scsi.SCp = info->SCpnt->SCp;\r\nfas216_log(info, LOG_CONNECT | LOG_MESSAGES | LOG_BUFFER,\r\n"restore data pointers: [%p, 0x%x]",\r\ninfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\r\nbreak;\r\ncase DISCONNECT:\r\nif (msglen != 1)\r\ngoto unrecognised;\r\ninfo->scsi.phase = PHASE_MSGIN_DISCONNECT;\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nif (msglen != 1)\r\ngoto unrecognised;\r\nswitch (fas216_get_last_msg(info, info->scsi.msgin_fifo)) {\r\ncase EXTENDED_MESSAGE | EXTENDED_SDTR << 8:\r\nfas216_handlesync(info, message);\r\nbreak;\r\ndefault:\r\nfas216_log(info, 0, "reject, last message 0x%04x",\r\nfas216_get_last_msg(info, info->scsi.msgin_fifo));\r\n}\r\nbreak;\r\ncase NOP:\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nif (msglen < 3)\r\ngoto unrecognised;\r\nswitch (message[2]) {\r\ncase EXTENDED_SDTR:\r\nfas216_handlesync(info, message);\r\nbreak;\r\ndefault:\r\ngoto unrecognised;\r\n}\r\nbreak;\r\ndefault:\r\ngoto unrecognised;\r\n}\r\nreturn;\r\nunrecognised:\r\nfas216_log(info, 0, "unrecognised message, rejecting");\r\nprintk("scsi%d.%c: message was", info->host->host_no, fas216_target(info));\r\nfor (i = 0; i < msglen; i++)\r\nprintk("%s%02X", i & 31 ? " " : "\n ", message[i]);\r\nprintk("\n");\r\nfas216_cmd(info, CMD_NOP);\r\nfas216_dumpstate(info);\r\nfas216_cmd(info, CMD_SETATN);\r\nmsgqueue_flush(&info->scsi.msgs);\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, MESSAGE_REJECT);\r\ninfo->scsi.phase = PHASE_MSGOUT_EXPECT;\r\nfas216_dumpstate(info);\r\n}\r\nstatic int fas216_wait_cmd(FAS216_Info *info, int cmd)\r\n{\r\nint tout;\r\nint stat;\r\nfas216_cmd(info, cmd);\r\nfor (tout = 1000; tout; tout -= 1) {\r\nstat = fas216_readb(info, REG_STAT);\r\nif (stat & (STAT_INT|STAT_PARITYERROR))\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn stat;\r\n}\r\nstatic int fas216_get_msg_byte(FAS216_Info *info)\r\n{\r\nunsigned int stat = fas216_wait_cmd(info, CMD_MSGACCEPTED);\r\nif ((stat & STAT_INT) == 0)\r\ngoto timedout;\r\nif ((stat & STAT_BUSMASK) != STAT_MESGIN)\r\ngoto unexpected_phase_change;\r\nfas216_readb(info, REG_INST);\r\nstat = fas216_wait_cmd(info, CMD_TRANSFERINFO);\r\nif ((stat & STAT_INT) == 0)\r\ngoto timedout;\r\nif (stat & STAT_PARITYERROR)\r\ngoto parity_error;\r\nif ((stat & STAT_BUSMASK) != STAT_MESGIN)\r\ngoto unexpected_phase_change;\r\nfas216_readb(info, REG_INST);\r\nreturn fas216_readb(info, REG_FF);\r\ntimedout:\r\nfas216_log(info, LOG_ERROR, "timed out waiting for message byte");\r\nreturn -1;\r\nunexpected_phase_change:\r\nfas216_log(info, LOG_ERROR, "unexpected phase change: status = %02x", stat);\r\nreturn -2;\r\nparity_error:\r\nfas216_log(info, LOG_ERROR, "parity error during message in phase");\r\nreturn -3;\r\n}\r\nstatic void fas216_message(FAS216_Info *info)\r\n{\r\nunsigned char *message = info->scsi.message;\r\nunsigned int msglen = 1;\r\nint msgbyte = 0;\r\nfas216_checkmagic(info);\r\nmessage[0] = fas216_readb(info, REG_FF);\r\nif (message[0] == EXTENDED_MESSAGE) {\r\nmsgbyte = fas216_get_msg_byte(info);\r\nif (msgbyte >= 0) {\r\nmessage[1] = msgbyte;\r\nfor (msglen = 2; msglen < message[1] + 2; msglen++) {\r\nmsgbyte = fas216_get_msg_byte(info);\r\nif (msgbyte >= 0)\r\nmessage[msglen] = msgbyte;\r\nelse\r\nbreak;\r\n}\r\n}\r\n}\r\nif (msgbyte == -3)\r\ngoto parity_error;\r\n#ifdef DEBUG_MESSAGES\r\n{\r\nint i;\r\nprintk("scsi%d.%c: message in: ",\r\ninfo->host->host_no, fas216_target(info));\r\nfor (i = 0; i < msglen; i++)\r\nprintk("%02X ", message[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\nfas216_parse_message(info, message, msglen);\r\nfas216_cmd(info, CMD_MSGACCEPTED);\r\nreturn;\r\nparity_error:\r\nfas216_cmd(info, CMD_SETATN);\r\nmsgqueue_flush(&info->scsi.msgs);\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, MSG_PARITY_ERROR);\r\ninfo->scsi.phase = PHASE_MSGOUT_EXPECT;\r\nfas216_cmd(info, CMD_MSGACCEPTED);\r\nreturn;\r\n}\r\nstatic void fas216_send_command(FAS216_Info *info)\r\n{\r\nint i;\r\nfas216_checkmagic(info);\r\nfas216_cmd(info, CMD_NOP|CMD_WITHDMA);\r\nfas216_cmd(info, CMD_FLUSHFIFO);\r\nfor (i = info->scsi.SCp.sent_command; i < info->SCpnt->cmd_len; i++)\r\nfas216_writeb(info, REG_FF, info->SCpnt->cmnd[i]);\r\nfas216_cmd(info, CMD_TRANSFERINFO);\r\ninfo->scsi.phase = PHASE_COMMAND;\r\n}\r\nstatic void fas216_send_messageout(FAS216_Info *info, int start)\r\n{\r\nunsigned int tot_msglen = msgqueue_msglength(&info->scsi.msgs);\r\nfas216_checkmagic(info);\r\nfas216_cmd(info, CMD_FLUSHFIFO);\r\nif (tot_msglen) {\r\nstruct message *msg;\r\nint msgnr = 0;\r\nwhile ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {\r\nint i;\r\nfor (i = start; i < msg->length; i++)\r\nfas216_writeb(info, REG_FF, msg->msg[i]);\r\nmsg->fifo = tot_msglen - (fas216_readb(info, REG_CFIS) & CFIS_CF);\r\nstart = 0;\r\n}\r\n} else\r\nfas216_writeb(info, REG_FF, NOP);\r\nfas216_cmd(info, CMD_TRANSFERINFO);\r\ninfo->scsi.phase = PHASE_MSGOUT;\r\n}\r\nstatic void fas216_busservice_intr(FAS216_Info *info, unsigned int stat, unsigned int is)\r\n{\r\nfas216_checkmagic(info);\r\nfas216_log(info, LOG_BUSSERVICE,\r\n"bus service: stat=%02x is=%02x phase=%02x",\r\nstat, is, info->scsi.phase);\r\nswitch (info->scsi.phase) {\r\ncase PHASE_SELECTION:\r\nif ((is & IS_BITS) != IS_MSGBYTESENT)\r\ngoto bad_is;\r\nbreak;\r\ncase PHASE_SELSTEPS:\r\nswitch (is & IS_BITS) {\r\ncase IS_SELARB:\r\ncase IS_MSGBYTESENT:\r\ngoto bad_is;\r\ncase IS_NOTCOMMAND:\r\ncase IS_EARLYPHASE:\r\nif ((stat & STAT_BUSMASK) == STAT_MESGIN)\r\nbreak;\r\ngoto bad_is;\r\ncase IS_COMPLETE:\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nfas216_cmd(info, CMD_NOP);\r\n#define STATE(st,ph) ((ph) << 3 | (st))\r\nswitch (STATE(stat & STAT_BUSMASK, info->scsi.phase)) {\r\ncase STATE(STAT_DATAIN, PHASE_SELSTEPS):\r\ncase STATE(STAT_DATAIN, PHASE_MSGOUT):\r\ncase STATE(STAT_DATAIN, PHASE_COMMAND):\r\ncase STATE(STAT_DATAIN, PHASE_MSGIN):\r\ninfo->scsi.phase = PHASE_DATAIN;\r\nfas216_transfer(info);\r\nreturn;\r\ncase STATE(STAT_DATAIN, PHASE_DATAIN):\r\ncase STATE(STAT_DATAOUT, PHASE_DATAOUT):\r\nfas216_cleanuptransfer(info);\r\nfas216_transfer(info);\r\nreturn;\r\ncase STATE(STAT_DATAOUT, PHASE_SELSTEPS):\r\ncase STATE(STAT_DATAOUT, PHASE_MSGOUT):\r\ncase STATE(STAT_DATAOUT, PHASE_COMMAND):\r\ncase STATE(STAT_DATAOUT, PHASE_MSGIN):\r\nfas216_cmd(info, CMD_FLUSHFIFO);\r\ninfo->scsi.phase = PHASE_DATAOUT;\r\nfas216_transfer(info);\r\nreturn;\r\ncase STATE(STAT_STATUS, PHASE_DATAOUT):\r\ncase STATE(STAT_STATUS, PHASE_DATAIN):\r\nfas216_stoptransfer(info);\r\ncase STATE(STAT_STATUS, PHASE_SELSTEPS):\r\ncase STATE(STAT_STATUS, PHASE_MSGOUT):\r\ncase STATE(STAT_STATUS, PHASE_COMMAND):\r\ncase STATE(STAT_STATUS, PHASE_MSGIN):\r\nfas216_cmd(info, CMD_INITCMDCOMPLETE);\r\ninfo->scsi.phase = PHASE_STATUS;\r\nreturn;\r\ncase STATE(STAT_MESGIN, PHASE_DATAOUT):\r\ncase STATE(STAT_MESGIN, PHASE_DATAIN):\r\nfas216_stoptransfer(info);\r\ncase STATE(STAT_MESGIN, PHASE_COMMAND):\r\ncase STATE(STAT_MESGIN, PHASE_SELSTEPS):\r\ncase STATE(STAT_MESGIN, PHASE_MSGOUT):\r\ninfo->scsi.msgin_fifo = fas216_readb(info, REG_CFIS) & CFIS_CF;\r\nfas216_cmd(info, CMD_FLUSHFIFO);\r\nfas216_cmd(info, CMD_TRANSFERINFO);\r\ninfo->scsi.phase = PHASE_MSGIN;\r\nreturn;\r\ncase STATE(STAT_MESGIN, PHASE_MSGIN):\r\ninfo->scsi.msgin_fifo = fas216_readb(info, REG_CFIS) & CFIS_CF;\r\nfas216_cmd(info, CMD_TRANSFERINFO);\r\nreturn;\r\ncase STATE(STAT_COMMAND, PHASE_MSGOUT):\r\ncase STATE(STAT_COMMAND, PHASE_MSGIN):\r\nfas216_send_command(info);\r\ninfo->scsi.phase = PHASE_COMMAND;\r\nreturn;\r\ncase STATE(STAT_MESGOUT, PHASE_SELECTION):\r\nfas216_send_messageout(info, 1);\r\nreturn;\r\ncase STATE(STAT_MESGOUT, PHASE_SELSTEPS):\r\ncase STATE(STAT_MESGOUT, PHASE_MSGOUT):\r\nif (info->device[info->SCpnt->device->id].parity_check) {\r\ninfo->device[info->SCpnt->device->id].parity_check = 0;\r\ninfo->device[info->SCpnt->device->id].parity_enabled = 1;\r\nfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\r\n}\r\nif (msgqueue_msglength(&info->scsi.msgs) > 1)\r\nfas216_cmd(info, CMD_SETATN);\r\ncase STATE(STAT_MESGOUT, PHASE_MSGOUT_EXPECT):\r\nfas216_send_messageout(info, 0);\r\nreturn;\r\ncase STATE(STAT_COMMAND, PHASE_COMMAND):\r\nprintk(KERN_ERR "scsi%d.%c: "\r\n"target trying to receive more command bytes\n",\r\ninfo->host->host_no, fas216_target(info));\r\nfas216_cmd(info, CMD_SETATN);\r\nfas216_set_stc(info, 15);\r\nfas216_cmd(info, CMD_PADBYTES | CMD_WITHDMA);\r\nmsgqueue_flush(&info->scsi.msgs);\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, INITIATOR_ERROR);\r\ninfo->scsi.phase = PHASE_MSGOUT_EXPECT;\r\nreturn;\r\n}\r\nif (info->scsi.phase == PHASE_MSGIN_DISCONNECT) {\r\nprintk(KERN_ERR "scsi%d.%c: disconnect message received, but bus service %s?\n",\r\ninfo->host->host_no, fas216_target(info),\r\nfas216_bus_phase(stat));\r\nmsgqueue_flush(&info->scsi.msgs);\r\nfas216_cmd(info, CMD_SETATN);\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, INITIATOR_ERROR);\r\ninfo->scsi.phase = PHASE_MSGOUT_EXPECT;\r\ninfo->scsi.aborting = 1;\r\nfas216_cmd(info, CMD_TRANSFERINFO);\r\nreturn;\r\n}\r\nprintk(KERN_ERR "scsi%d.%c: bus phase %s after %s?\n",\r\ninfo->host->host_no, fas216_target(info),\r\nfas216_bus_phase(stat),\r\nfas216_drv_phase(info));\r\nprint_debug_list();\r\nreturn;\r\nbad_is:\r\nfas216_log(info, 0, "bus service at step %d?", is & IS_BITS);\r\nfas216_dumpstate(info);\r\nprint_debug_list();\r\nfas216_done(info, DID_ERROR);\r\n}\r\nstatic void fas216_funcdone_intr(FAS216_Info *info, unsigned int stat, unsigned int is)\r\n{\r\nunsigned int fifo_len = fas216_readb(info, REG_CFIS) & CFIS_CF;\r\nfas216_checkmagic(info);\r\nfas216_log(info, LOG_FUNCTIONDONE,\r\n"function done: stat=%02x is=%02x phase=%02x",\r\nstat, is, info->scsi.phase);\r\nswitch (info->scsi.phase) {\r\ncase PHASE_STATUS:\r\nif (fifo_len != 2) {\r\nfas216_log(info, 0, "odd number of bytes in FIFO: %d", fifo_len);\r\n}\r\ninfo->scsi.SCp.Status = fas216_readb(info, REG_FF);\r\ninfo->scsi.SCp.Message = fas216_readb(info, REG_FF);\r\ninfo->scsi.phase = PHASE_DONE;\r\nfas216_cmd(info, CMD_MSGACCEPTED);\r\nbreak;\r\ncase PHASE_IDLE:\r\ncase PHASE_SELECTION:\r\ncase PHASE_SELSTEPS:\r\nbreak;\r\ncase PHASE_MSGIN:\r\nif ((stat & STAT_BUSMASK) == STAT_MESGIN) {\r\ninfo->scsi.msgin_fifo = fifo_len;\r\nfas216_message(info);\r\nbreak;\r\n}\r\ndefault:\r\nfas216_log(info, 0, "internal phase %s for function done?"\r\n" What do I do with this?",\r\nfas216_target(info), fas216_drv_phase(info));\r\n}\r\n}\r\nstatic void fas216_bus_reset(FAS216_Info *info)\r\n{\r\nneg_t sync_state;\r\nint i;\r\nmsgqueue_flush(&info->scsi.msgs);\r\nsync_state = neg_invalid;\r\n#ifdef SCSI2_SYNC\r\nif (info->ifcfg.capabilities & (FASCAP_DMA|FASCAP_PSEUDODMA))\r\nsync_state = neg_wait;\r\n#endif\r\ninfo->scsi.phase = PHASE_IDLE;\r\ninfo->SCpnt = NULL;\r\nmemset(&info->scsi.SCp, 0, sizeof(info->scsi.SCp));\r\nfor (i = 0; i < 8; i++) {\r\ninfo->device[i].disconnect_ok = info->ifcfg.disconnect_ok;\r\ninfo->device[i].sync_state = sync_state;\r\ninfo->device[i].period = info->ifcfg.asyncperiod / 4;\r\ninfo->device[i].stp = info->scsi.async_stp;\r\ninfo->device[i].sof = 0;\r\ninfo->device[i].wide_xfer = 0;\r\n}\r\ninfo->rst_bus_status = 1;\r\nwake_up(&info->eh_wait);\r\n}\r\nirqreturn_t fas216_intr(FAS216_Info *info)\r\n{\r\nunsigned char inst, is, stat;\r\nint handled = IRQ_NONE;\r\nfas216_checkmagic(info);\r\nstat = fas216_readb(info, REG_STAT);\r\nis = fas216_readb(info, REG_IS);\r\ninst = fas216_readb(info, REG_INST);\r\nadd_debug_list(stat, is, inst, info->scsi.phase);\r\nif (stat & STAT_INT) {\r\nif (inst & INST_BUSRESET) {\r\nfas216_log(info, 0, "bus reset detected");\r\nfas216_bus_reset(info);\r\nscsi_report_bus_reset(info->host, 0);\r\n} else if (inst & INST_ILLEGALCMD) {\r\nfas216_log(info, LOG_ERROR, "illegal command given\n");\r\nfas216_dumpstate(info);\r\nprint_debug_list();\r\n} else if (inst & INST_DISCONNECT)\r\nfas216_disconnect_intr(info);\r\nelse if (inst & INST_RESELECTED)\r\nfas216_reselected_intr(info);\r\nelse if (inst & INST_BUSSERVICE)\r\nfas216_busservice_intr(info, stat, is);\r\nelse if (inst & INST_FUNCDONE)\r\nfas216_funcdone_intr(info, stat, is);\r\nelse\r\nfas216_log(info, 0, "unknown interrupt received:"\r\n" phase %s inst %02X is %02X stat %02X",\r\nfas216_drv_phase(info), inst, is, stat);\r\nhandled = IRQ_HANDLED;\r\n}\r\nreturn handled;\r\n}\r\nstatic void __fas216_start_command(FAS216_Info *info, struct scsi_cmnd *SCpnt)\r\n{\r\nint tot_msglen;\r\nfas216_set_stc(info, 0);\r\nfas216_cmd(info, CMD_NOP | CMD_WITHDMA);\r\nfas216_cmd(info, CMD_FLUSHFIFO);\r\nfas216_writeb(info, REG_SDID, BUSID(SCpnt->device->id));\r\nfas216_writeb(info, REG_STIM, info->ifcfg.select_timeout);\r\nfas216_set_sync(info, SCpnt->device->id);\r\ntot_msglen = msgqueue_msglength(&info->scsi.msgs);\r\n#ifdef DEBUG_MESSAGES\r\n{\r\nstruct message *msg;\r\nint msgnr = 0, i;\r\nprintk("scsi%d.%c: message out: ",\r\ninfo->host->host_no, '0' + SCpnt->device->id);\r\nwhile ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {\r\nprintk("{ ");\r\nfor (i = 0; i < msg->length; i++)\r\nprintk("%02x ", msg->msg[i]);\r\nprintk("} ");\r\n}\r\nprintk("\n");\r\n}\r\n#endif\r\nif (tot_msglen == 1 || tot_msglen == 3) {\r\nstruct message *msg;\r\nint msgnr = 0, i;\r\ninfo->scsi.phase = PHASE_SELSTEPS;\r\nwhile ((msg = msgqueue_getmsg(&info->scsi.msgs, msgnr++)) != NULL) {\r\nfor (i = 0; i < msg->length; i++)\r\nfas216_writeb(info, REG_FF, msg->msg[i]);\r\nmsg->fifo = tot_msglen - (fas216_readb(info, REG_CFIS) & CFIS_CF);\r\n}\r\nfor (i = 0; i < SCpnt->cmd_len; i++)\r\nfas216_writeb(info, REG_FF, SCpnt->cmnd[i]);\r\nif (tot_msglen == 1)\r\nfas216_cmd(info, CMD_SELECTATN);\r\nelse\r\nfas216_cmd(info, CMD_SELECTATN3);\r\n} else {\r\nstruct message *msg = msgqueue_getmsg(&info->scsi.msgs, 0);\r\nfas216_writeb(info, REG_FF, msg->msg[0]);\r\nmsg->fifo = 1;\r\nfas216_cmd(info, CMD_SELECTATNSTOP);\r\n}\r\n}\r\nstatic int parity_test(FAS216_Info *info, int target)\r\n{\r\n#if 0\r\nif (target == 3) {\r\ninfo->device[target].parity_check = 0;\r\nreturn 1;\r\n}\r\n#endif\r\nreturn info->device[target].parity_check;\r\n}\r\nstatic void fas216_start_command(FAS216_Info *info, struct scsi_cmnd *SCpnt)\r\n{\r\nint disconnect_ok;\r\ninfo->scsi.phase = PHASE_SELECTION;\r\ninfo->scsi.SCp = SCpnt->SCp;\r\ninfo->SCpnt = SCpnt;\r\ninfo->dma.transfer_type = fasdma_none;\r\nif (parity_test(info, SCpnt->device->id))\r\nfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0] | CNTL1_PTE);\r\nelse\r\nfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\r\ndisconnect_ok = SCpnt->cmnd[0] != REQUEST_SENSE &&\r\ninfo->device[SCpnt->device->id].disconnect_ok;\r\nmsgqueue_flush(&info->scsi.msgs);\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, IDENTIFY(disconnect_ok, SCpnt->device->lun));\r\nif (SCpnt->tag)\r\nmsgqueue_addmsg(&info->scsi.msgs, 2, SIMPLE_QUEUE_TAG, SCpnt->tag);\r\ndo {\r\n#ifdef SCSI2_SYNC\r\nif ((info->device[SCpnt->device->id].sync_state == neg_wait ||\r\ninfo->device[SCpnt->device->id].sync_state == neg_complete) &&\r\n(SCpnt->cmnd[0] == REQUEST_SENSE ||\r\nSCpnt->cmnd[0] == INQUIRY)) {\r\ninfo->device[SCpnt->device->id].sync_state = neg_inprogress;\r\nmsgqueue_addmsg(&info->scsi.msgs, 5,\r\nEXTENDED_MESSAGE, 3, EXTENDED_SDTR,\r\n1000 / info->ifcfg.clockrate,\r\ninfo->ifcfg.sync_max_depth);\r\nbreak;\r\n}\r\n#endif\r\n} while (0);\r\n__fas216_start_command(info, SCpnt);\r\n}\r\nstatic void fas216_allocate_tag(FAS216_Info *info, struct scsi_cmnd *SCpnt)\r\n{\r\n#ifdef SCSI2_TAG\r\nif (SCpnt->device->simple_tags && SCpnt->cmnd[0] != REQUEST_SENSE &&\r\nSCpnt->cmnd[0] != INQUIRY) {\r\nSCpnt->device->current_tag += 1;\r\nif (SCpnt->device->current_tag == 0)\r\nSCpnt->device->current_tag = 1;\r\nSCpnt->tag = SCpnt->device->current_tag;\r\n} else\r\n#endif\r\nset_bit(SCpnt->device->id * 8 +\r\n(u8)(SCpnt->device->lun & 0x7), info->busyluns);\r\ninfo->stats.removes += 1;\r\nswitch (SCpnt->cmnd[0]) {\r\ncase WRITE_6:\r\ncase WRITE_10:\r\ncase WRITE_12:\r\ninfo->stats.writes += 1;\r\nbreak;\r\ncase READ_6:\r\ncase READ_10:\r\ncase READ_12:\r\ninfo->stats.reads += 1;\r\nbreak;\r\ndefault:\r\ninfo->stats.miscs += 1;\r\nbreak;\r\n}\r\n}\r\nstatic void fas216_do_bus_device_reset(FAS216_Info *info,\r\nstruct scsi_cmnd *SCpnt)\r\n{\r\nstruct message *msg;\r\ninfo->scsi.phase = PHASE_SELECTION;\r\ninfo->scsi.SCp = SCpnt->SCp;\r\ninfo->SCpnt = SCpnt;\r\ninfo->dma.transfer_type = fasdma_none;\r\nfas216_log(info, LOG_ERROR, "sending bus device reset");\r\nmsgqueue_flush(&info->scsi.msgs);\r\nmsgqueue_addmsg(&info->scsi.msgs, 1, BUS_DEVICE_RESET);\r\nfas216_set_stc(info, 0);\r\nfas216_cmd(info, CMD_NOP | CMD_WITHDMA);\r\nfas216_cmd(info, CMD_FLUSHFIFO);\r\nfas216_writeb(info, REG_SDID, BUSID(SCpnt->device->id));\r\nfas216_writeb(info, REG_STIM, info->ifcfg.select_timeout);\r\nfas216_set_sync(info, SCpnt->device->id);\r\nmsg = msgqueue_getmsg(&info->scsi.msgs, 0);\r\nfas216_writeb(info, REG_FF, BUS_DEVICE_RESET);\r\nmsg->fifo = 1;\r\nfas216_cmd(info, CMD_SELECTATNSTOP);\r\n}\r\nstatic void fas216_kick(FAS216_Info *info)\r\n{\r\nstruct scsi_cmnd *SCpnt = NULL;\r\n#define TYPE_OTHER 0\r\n#define TYPE_RESET 1\r\n#define TYPE_QUEUE 2\r\nint where_from = TYPE_OTHER;\r\nfas216_checkmagic(info);\r\ndo {\r\nif (info->rstSCpnt) {\r\nSCpnt = info->rstSCpnt;\r\nwhere_from = TYPE_RESET;\r\nbreak;\r\n}\r\nif (info->reqSCpnt) {\r\nSCpnt = info->reqSCpnt;\r\ninfo->reqSCpnt = NULL;\r\nbreak;\r\n}\r\nif (info->origSCpnt) {\r\nSCpnt = info->origSCpnt;\r\ninfo->origSCpnt = NULL;\r\nbreak;\r\n}\r\nif (!SCpnt) {\r\nSCpnt = queue_remove_exclude(&info->queues.issue,\r\ninfo->busyluns);\r\nwhere_from = TYPE_QUEUE;\r\nbreak;\r\n}\r\n} while (0);\r\nif (!SCpnt) {\r\nfas216_cmd(info, CMD_ENABLESEL);\r\nreturn;\r\n}\r\nfas216_cmd(info, CMD_DISABLESEL);\r\nif (info->scsi.disconnectable && info->SCpnt) {\r\nfas216_log(info, LOG_CONNECT,\r\n"moved command for %d to disconnected queue",\r\ninfo->SCpnt->device->id);\r\nqueue_add_cmd_tail(&info->queues.disconnected, info->SCpnt);\r\ninfo->scsi.disconnectable = 0;\r\ninfo->SCpnt = NULL;\r\n}\r\nfas216_log_command(info, LOG_CONNECT | LOG_MESSAGES, SCpnt,\r\n"starting");\r\nswitch (where_from) {\r\ncase TYPE_QUEUE:\r\nfas216_allocate_tag(info, SCpnt);\r\ncase TYPE_OTHER:\r\nfas216_start_command(info, SCpnt);\r\nbreak;\r\ncase TYPE_RESET:\r\nfas216_do_bus_device_reset(info, SCpnt);\r\nbreak;\r\n}\r\nfas216_log(info, LOG_CONNECT, "select: data pointers [%p, %X]",\r\ninfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\r\n}\r\nstatic void fas216_devicereset_done(FAS216_Info *info, struct scsi_cmnd *SCpnt,\r\nunsigned int result)\r\n{\r\nfas216_log(info, LOG_ERROR, "fas216 device reset complete");\r\ninfo->rstSCpnt = NULL;\r\ninfo->rst_dev_status = 1;\r\nwake_up(&info->eh_wait);\r\n}\r\nstatic void fas216_rq_sns_done(FAS216_Info *info, struct scsi_cmnd *SCpnt,\r\nunsigned int result)\r\n{\r\nfas216_log_target(info, LOG_CONNECT, SCpnt->device->id,\r\n"request sense complete, result=0x%04x%02x%02x",\r\nresult, SCpnt->SCp.Message, SCpnt->SCp.Status);\r\nif (result != DID_OK || SCpnt->SCp.Status != GOOD)\r\nmemset(SCpnt->sense_buffer, 0, sizeof(SCpnt->sense_buffer));\r\nscsi_eh_restore_cmnd(SCpnt, &info->ses);\r\nSCpnt->scsi_done(SCpnt);\r\n}\r\nstatic void\r\nfas216_std_done(FAS216_Info *info, struct scsi_cmnd *SCpnt, unsigned int result)\r\n{\r\ninfo->stats.fins += 1;\r\nSCpnt->result = result << 16 | info->scsi.SCp.Message << 8 |\r\ninfo->scsi.SCp.Status;\r\nfas216_log_command(info, LOG_CONNECT, SCpnt,\r\n"command complete, result=0x%08x", SCpnt->result);\r\nif (host_byte(SCpnt->result) != DID_OK ||\r\nmsg_byte(SCpnt->result) != COMMAND_COMPLETE)\r\ngoto done;\r\nif (status_byte(SCpnt->result) == CHECK_CONDITION ||\r\nstatus_byte(SCpnt->result) == COMMAND_TERMINATED)\r\ngoto request_sense;\r\nif (status_byte(SCpnt->result) != GOOD)\r\ngoto done;\r\nif (info->scsi.SCp.ptr) {\r\nswitch (SCpnt->cmnd[0]) {\r\ncase INQUIRY:\r\ncase START_STOP:\r\ncase MODE_SENSE:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "scsi%d.%c: incomplete data transfer "\r\n"detected: res=%08X ptr=%p len=%X CDB: ",\r\ninfo->host->host_no, '0' + SCpnt->device->id,\r\nSCpnt->result, info->scsi.SCp.ptr,\r\ninfo->scsi.SCp.this_residual);\r\n__scsi_print_command(SCpnt->cmnd);\r\nSCpnt->result &= ~(255 << 16);\r\nSCpnt->result |= DID_BAD_TARGET << 16;\r\ngoto request_sense;\r\n}\r\n}\r\ndone:\r\nif (SCpnt->scsi_done) {\r\nSCpnt->scsi_done(SCpnt);\r\nreturn;\r\n}\r\npanic("scsi%d.H: null scsi_done function in fas216_done",\r\ninfo->host->host_no);\r\nrequest_sense:\r\nif (SCpnt->cmnd[0] == REQUEST_SENSE)\r\ngoto done;\r\nscsi_eh_prep_cmnd(SCpnt, &info->ses, NULL, 0, ~0);\r\nfas216_log_target(info, LOG_CONNECT, SCpnt->device->id,\r\n"requesting sense");\r\ninit_SCp(SCpnt);\r\nSCpnt->SCp.Message = 0;\r\nSCpnt->SCp.Status = 0;\r\nSCpnt->tag = 0;\r\nSCpnt->host_scribble = (void *)fas216_rq_sns_done;\r\nif (info->reqSCpnt)\r\nprintk(KERN_WARNING "scsi%d.%c: losing request command\n",\r\ninfo->host->host_no, '0' + SCpnt->device->id);\r\ninfo->reqSCpnt = SCpnt;\r\n}\r\nstatic void fas216_done(FAS216_Info *info, unsigned int result)\r\n{\r\nvoid (*fn)(FAS216_Info *, struct scsi_cmnd *, unsigned int);\r\nstruct scsi_cmnd *SCpnt;\r\nunsigned long flags;\r\nfas216_checkmagic(info);\r\nif (!info->SCpnt)\r\ngoto no_command;\r\nSCpnt = info->SCpnt;\r\ninfo->SCpnt = NULL;\r\ninfo->scsi.phase = PHASE_IDLE;\r\nif (info->scsi.aborting) {\r\nfas216_log(info, 0, "uncaught abort - returning DID_ABORT");\r\nresult = DID_ABORT;\r\ninfo->scsi.aborting = 0;\r\n}\r\nif (info->scsi.SCp.ptr && info->scsi.SCp.this_residual == 0) {\r\nprintk("scsi%d.%c: zero bytes left to transfer, but "\r\n"buffer pointer still valid: ptr=%p len=%08x CDB: ",\r\ninfo->host->host_no, '0' + SCpnt->device->id,\r\ninfo->scsi.SCp.ptr, info->scsi.SCp.this_residual);\r\ninfo->scsi.SCp.ptr = NULL;\r\n__scsi_print_command(SCpnt->cmnd);\r\n}\r\ninfo->device[SCpnt->device->id].parity_check = 0;\r\nclear_bit(SCpnt->device->id * 8 +\r\n(u8)(SCpnt->device->lun & 0x7), info->busyluns);\r\nfn = (void (*)(FAS216_Info *, struct scsi_cmnd *, unsigned int))SCpnt->host_scribble;\r\nfn(info, SCpnt, result);\r\nif (info->scsi.irq) {\r\nspin_lock_irqsave(&info->host_lock, flags);\r\nif (info->scsi.phase == PHASE_IDLE)\r\nfas216_kick(info);\r\nspin_unlock_irqrestore(&info->host_lock, flags);\r\n}\r\nreturn;\r\nno_command:\r\npanic("scsi%d.H: null command in fas216_done",\r\ninfo->host->host_no);\r\n}\r\nstatic int fas216_queue_command_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\r\nint result;\r\nfas216_checkmagic(info);\r\nfas216_log_command(info, LOG_CONNECT, SCpnt,\r\n"received command (%p)", SCpnt);\r\nSCpnt->scsi_done = done;\r\nSCpnt->host_scribble = (void *)fas216_std_done;\r\nSCpnt->result = 0;\r\ninit_SCp(SCpnt);\r\ninfo->stats.queues += 1;\r\nSCpnt->tag = 0;\r\nspin_lock(&info->host_lock);\r\nresult = !queue_add_cmd_ordered(&info->queues.issue, SCpnt);\r\nif (result == 0 && info->scsi.phase == PHASE_IDLE)\r\nfas216_kick(info);\r\nspin_unlock(&info->host_lock);\r\nfas216_log_target(info, LOG_CONNECT, -1, "queue %s",\r\nresult ? "failure" : "success");\r\nreturn result;\r\n}\r\nstatic void fas216_internal_done(struct scsi_cmnd *SCpnt)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\r\nfas216_checkmagic(info);\r\ninfo->internal_done = 1;\r\n}\r\nstatic int fas216_noqueue_command_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\r\nfas216_checkmagic(info);\r\nBUG_ON(info->scsi.irq);\r\ninfo->internal_done = 0;\r\nfas216_queue_command_lck(SCpnt, fas216_internal_done);\r\nspin_unlock_irq(info->host->host_lock);\r\nwhile (!info->internal_done) {\r\nif (fas216_readb(info, REG_STAT) & STAT_INT) {\r\nspin_lock_irq(info->host->host_lock);\r\nfas216_intr(info);\r\nspin_unlock_irq(info->host->host_lock);\r\n}\r\n}\r\nspin_lock_irq(info->host->host_lock);\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\nstatic void fas216_eh_timer(unsigned long data)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)data;\r\nfas216_log(info, LOG_ERROR, "error handling timed out\n");\r\ndel_timer(&info->eh_timer);\r\nif (info->rst_bus_status == 0)\r\ninfo->rst_bus_status = -1;\r\nif (info->rst_dev_status == 0)\r\ninfo->rst_dev_status = -1;\r\nwake_up(&info->eh_wait);\r\n}\r\nstatic enum res_find fas216_find_command(FAS216_Info *info,\r\nstruct scsi_cmnd *SCpnt)\r\n{\r\nenum res_find res = res_failed;\r\nif (queue_remove_cmd(&info->queues.issue, SCpnt)) {\r\nprintk("on issue queue ");\r\nres = res_success;\r\n} else if (queue_remove_cmd(&info->queues.disconnected, SCpnt)) {\r\nprintk("on disconnected queue ");\r\nres = res_hw_abort;\r\n} else if (info->SCpnt == SCpnt) {\r\nprintk("executing ");\r\nswitch (info->scsi.phase) {\r\ncase PHASE_IDLE:\r\nif (info->scsi.disconnectable) {\r\ninfo->scsi.disconnectable = 0;\r\ninfo->SCpnt = NULL;\r\nres = res_hw_abort;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if (info->origSCpnt == SCpnt) {\r\ninfo->origSCpnt = NULL;\r\nclear_bit(SCpnt->device->id * 8 +\r\n(u8)(SCpnt->device->lun & 0x7), info->busyluns);\r\nprintk("waiting for execution ");\r\nres = res_success;\r\n} else\r\nprintk("unknown ");\r\nreturn res;\r\n}\r\nint fas216_eh_abort(struct scsi_cmnd *SCpnt)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\r\nint result = FAILED;\r\nfas216_checkmagic(info);\r\ninfo->stats.aborts += 1;\r\nprintk(KERN_WARNING "scsi%d: abort command ", info->host->host_no);\r\n__scsi_print_command(SCpnt->cmnd);\r\nprint_debug_list();\r\nfas216_dumpstate(info);\r\nprintk(KERN_WARNING "scsi%d: abort %p ", info->host->host_no, SCpnt);\r\nswitch (fas216_find_command(info, SCpnt)) {\r\ncase res_success:\r\nprintk("success\n");\r\nresult = SUCCESS;\r\nbreak;\r\ncase res_hw_abort:\r\ndefault:\r\ncase res_failed:\r\nprintk("failed\n");\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nint fas216_eh_device_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\r\nunsigned long flags;\r\nint i, res = FAILED, target = SCpnt->device->id;\r\nfas216_log(info, LOG_ERROR, "device reset for target %d", target);\r\nspin_lock_irqsave(&info->host_lock, flags);\r\ndo {\r\nif (info->SCpnt && !info->scsi.disconnectable &&\r\ninfo->SCpnt->device->id == SCpnt->device->id)\r\nbreak;\r\nqueue_remove_all_target(&info->queues.issue, target);\r\nqueue_remove_all_target(&info->queues.disconnected, target);\r\nif (info->origSCpnt && info->origSCpnt->device->id == target)\r\ninfo->origSCpnt = NULL;\r\nif (info->reqSCpnt && info->reqSCpnt->device->id == target)\r\ninfo->reqSCpnt = NULL;\r\nfor (i = 0; i < 8; i++)\r\nclear_bit(target * 8 + i, info->busyluns);\r\nSCpnt->host_scribble = (void *)fas216_devicereset_done;\r\ninfo->rst_dev_status = 0;\r\ninfo->rstSCpnt = SCpnt;\r\nif (info->scsi.phase == PHASE_IDLE)\r\nfas216_kick(info);\r\nmod_timer(&info->eh_timer, jiffies + 30 * HZ);\r\nspin_unlock_irqrestore(&info->host_lock, flags);\r\nwait_event(info->eh_wait, info->rst_dev_status);\r\ndel_timer_sync(&info->eh_timer);\r\nspin_lock_irqsave(&info->host_lock, flags);\r\ninfo->rstSCpnt = NULL;\r\nif (info->rst_dev_status == 1)\r\nres = SUCCESS;\r\n} while (0);\r\nSCpnt->host_scribble = NULL;\r\nspin_unlock_irqrestore(&info->host_lock, flags);\r\nfas216_log(info, LOG_ERROR, "device reset complete: %s\n",\r\nres == SUCCESS ? "success" : "failed");\r\nreturn res;\r\n}\r\nint fas216_eh_bus_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\r\nunsigned long flags;\r\nstruct scsi_device *SDpnt;\r\nfas216_checkmagic(info);\r\nfas216_log(info, LOG_ERROR, "resetting bus");\r\ninfo->stats.bus_resets += 1;\r\nspin_lock_irqsave(&info->host_lock, flags);\r\nfas216_aborttransfer(info);\r\nfas216_writeb(info, REG_CNTL3, info->scsi.cfg[2]);\r\nwhile (fas216_readb(info, REG_STAT) & STAT_INT)\r\nfas216_readb(info, REG_INST);\r\ninfo->rst_bus_status = 0;\r\nshost_for_each_device(SDpnt, info->host) {\r\nint i;\r\nif (SDpnt->soft_reset)\r\ncontinue;\r\nqueue_remove_all_target(&info->queues.issue, SDpnt->id);\r\nqueue_remove_all_target(&info->queues.disconnected, SDpnt->id);\r\nif (info->origSCpnt && info->origSCpnt->device->id == SDpnt->id)\r\ninfo->origSCpnt = NULL;\r\nif (info->reqSCpnt && info->reqSCpnt->device->id == SDpnt->id)\r\ninfo->reqSCpnt = NULL;\r\ninfo->SCpnt = NULL;\r\nfor (i = 0; i < 8; i++)\r\nclear_bit(SDpnt->id * 8 + i, info->busyluns);\r\n}\r\ninfo->scsi.phase = PHASE_IDLE;\r\nfas216_cmd(info, CMD_RESETSCSI);\r\nmod_timer(&info->eh_timer, jiffies + HZ);\r\nspin_unlock_irqrestore(&info->host_lock, flags);\r\nwait_event(info->eh_wait, info->rst_bus_status);\r\ndel_timer_sync(&info->eh_timer);\r\nfas216_log(info, LOG_ERROR, "bus reset complete: %s\n",\r\ninfo->rst_bus_status == 1 ? "success" : "failed");\r\nreturn info->rst_bus_status == 1 ? SUCCESS : FAILED;\r\n}\r\nstatic void fas216_init_chip(FAS216_Info *info)\r\n{\r\nunsigned int clock = ((info->ifcfg.clockrate - 1) / 5 + 1) & 7;\r\nfas216_writeb(info, REG_CLKF, clock);\r\nfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\r\nfas216_writeb(info, REG_CNTL2, info->scsi.cfg[1]);\r\nfas216_writeb(info, REG_CNTL3, info->scsi.cfg[2]);\r\nfas216_writeb(info, REG_STIM, info->ifcfg.select_timeout);\r\nfas216_writeb(info, REG_SOF, 0);\r\nfas216_writeb(info, REG_STP, info->scsi.async_stp);\r\nfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\r\n}\r\nint fas216_eh_host_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)SCpnt->device->host->hostdata;\r\nspin_lock_irq(info->host->host_lock);\r\nfas216_checkmagic(info);\r\nprintk("scsi%d.%c: %s: resetting host\n",\r\ninfo->host->host_no, '0' + SCpnt->device->id, __func__);\r\nfas216_cmd(info, CMD_RESETCHIP);\r\nspin_unlock_irq(info->host->host_lock);\r\nmsleep(50 * 1000/100);\r\nspin_lock_irq(info->host->host_lock);\r\nfas216_cmd(info, CMD_NOP);\r\nfas216_init_chip(info);\r\nspin_unlock_irq(info->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int fas216_detect_type(FAS216_Info *info)\r\n{\r\nint family, rev;\r\nfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\r\nudelay(50);\r\nfas216_writeb(info, REG_CMD, CMD_NOP);\r\nfas216_writeb(info, REG_CNTL3, 0);\r\nfas216_writeb(info, REG_CNTL2, CNTL2_S2FE);\r\nif ((fas216_readb(info, REG_CNTL2) & (~0xe0)) != CNTL2_S2FE)\r\nreturn TYPE_NCR53C90;\r\nfas216_writeb(info, REG_CNTL2, 0);\r\nfas216_writeb(info, REG_CNTL3, 0);\r\nfas216_writeb(info, REG_CNTL3, 5);\r\nif (fas216_readb(info, REG_CNTL3) != 5)\r\nreturn TYPE_NCR53C90A;\r\nfas216_writeb(info, REG_CNTL3, 0);\r\nfas216_writeb(info, REG_CNTL3, CNTL3_ADIDCHK);\r\nfas216_writeb(info, REG_CNTL3, 0);\r\nfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\r\nudelay(50);\r\nfas216_writeb(info, REG_CMD, CMD_WITHDMA | CMD_NOP);\r\nfas216_writeb(info, REG_CNTL2, CNTL2_ENF);\r\nfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\r\nudelay(50);\r\nfas216_writeb(info, REG_CMD, CMD_NOP);\r\nrev = fas216_readb(info, REG_ID);\r\nfamily = rev >> 3;\r\nrev &= 7;\r\nswitch (family) {\r\ncase 0x01:\r\nif (rev == 4)\r\nreturn TYPE_Am53CF94;\r\nbreak;\r\ncase 0x02:\r\nswitch (rev) {\r\ncase 2:\r\nreturn TYPE_EmFAS216;\r\ncase 3:\r\nreturn TYPE_QLFAS216;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nprintk("family %x rev %x\n", family, rev);\r\nreturn TYPE_NCR53C9x;\r\n}\r\nstatic void fas216_reset_state(FAS216_Info *info)\r\n{\r\nint i;\r\nfas216_checkmagic(info);\r\nfas216_bus_reset(info);\r\nmemset(info->busyluns, 0, sizeof(info->busyluns));\r\ninfo->scsi.disconnectable = 0;\r\ninfo->scsi.aborting = 0;\r\nfor (i = 0; i < 8; i++) {\r\ninfo->device[i].parity_enabled = 0;\r\ninfo->device[i].parity_check = 1;\r\n}\r\nwhile (queue_remove(&info->queues.disconnected) != NULL);\r\ninfo->SCpnt = NULL;\r\ninfo->reqSCpnt = NULL;\r\ninfo->rstSCpnt = NULL;\r\ninfo->origSCpnt = NULL;\r\n}\r\nint fas216_init(struct Scsi_Host *host)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)host->hostdata;\r\ninfo->magic_start = MAGIC;\r\ninfo->magic_end = MAGIC;\r\ninfo->host = host;\r\ninfo->scsi.cfg[0] = host->this_id | CNTL1_PERE;\r\ninfo->scsi.cfg[1] = CNTL2_ENF | CNTL2_S2FE;\r\ninfo->scsi.cfg[2] = info->ifcfg.cntl3 |\r\nCNTL3_ADIDCHK | CNTL3_QTAG | CNTL3_G2CB | CNTL3_LBTM;\r\ninfo->scsi.async_stp = fas216_syncperiod(info, info->ifcfg.asyncperiod);\r\ninfo->rst_dev_status = -1;\r\ninfo->rst_bus_status = -1;\r\ninit_waitqueue_head(&info->eh_wait);\r\ninit_timer(&info->eh_timer);\r\ninfo->eh_timer.data = (unsigned long)info;\r\ninfo->eh_timer.function = fas216_eh_timer;\r\nspin_lock_init(&info->host_lock);\r\nmemset(&info->stats, 0, sizeof(info->stats));\r\nmsgqueue_initialise(&info->scsi.msgs);\r\nif (!queue_initialise(&info->queues.issue))\r\nreturn -ENOMEM;\r\nif (!queue_initialise(&info->queues.disconnected)) {\r\nqueue_free(&info->queues.issue);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint fas216_add(struct Scsi_Host *host, struct device *dev)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)host->hostdata;\r\nint type, ret;\r\nif (info->ifcfg.clockrate <= 10 || info->ifcfg.clockrate > 40) {\r\nprintk(KERN_CRIT "fas216: invalid clock rate %u MHz\n",\r\ninfo->ifcfg.clockrate);\r\nreturn -EINVAL;\r\n}\r\nfas216_reset_state(info);\r\ntype = fas216_detect_type(info);\r\ninfo->scsi.type = chip_types[type];\r\nudelay(300);\r\nfas216_init_chip(info);\r\nfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0] | CNTL1_DISR);\r\nfas216_writeb(info, REG_CMD, CMD_RESETSCSI);\r\nspin_unlock_irq(info->host->host_lock);\r\nmsleep(100*1000/100);\r\nspin_lock_irq(info->host->host_lock);\r\nfas216_writeb(info, REG_CNTL1, info->scsi.cfg[0]);\r\nfas216_readb(info, REG_INST);\r\nfas216_checkmagic(info);\r\nret = scsi_add_host(host, dev);\r\nif (ret)\r\nfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\r\nelse\r\nscsi_scan_host(host);\r\nreturn ret;\r\n}\r\nvoid fas216_remove(struct Scsi_Host *host)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)host->hostdata;\r\nfas216_checkmagic(info);\r\nscsi_remove_host(host);\r\nfas216_writeb(info, REG_CMD, CMD_RESETCHIP);\r\nscsi_host_put(host);\r\n}\r\nvoid fas216_release(struct Scsi_Host *host)\r\n{\r\nFAS216_Info *info = (FAS216_Info *)host->hostdata;\r\nqueue_free(&info->queues.disconnected);\r\nqueue_free(&info->queues.issue);\r\n}\r\nvoid fas216_print_host(FAS216_Info *info, struct seq_file *m)\r\n{\r\nseq_printf(m,\r\n"\n"\r\n"Chip : %s\n"\r\n" Address: 0x%p\n"\r\n" IRQ : %d\n"\r\n" DMA : %d\n",\r\ninfo->scsi.type, info->scsi.io_base,\r\ninfo->scsi.irq, info->scsi.dma);\r\n}\r\nvoid fas216_print_stats(FAS216_Info *info, struct seq_file *m)\r\n{\r\nseq_printf(m, "\n"\r\n"Command Statistics:\n"\r\n" Queued : %u\n"\r\n" Issued : %u\n"\r\n" Completed : %u\n"\r\n" Reads : %u\n"\r\n" Writes : %u\n"\r\n" Others : %u\n"\r\n" Disconnects: %u\n"\r\n" Aborts : %u\n"\r\n" Bus resets : %u\n"\r\n" Host resets: %u\n",\r\ninfo->stats.queues, info->stats.removes,\r\ninfo->stats.fins, info->stats.reads,\r\ninfo->stats.writes, info->stats.miscs,\r\ninfo->stats.disconnects, info->stats.aborts,\r\ninfo->stats.bus_resets, info->stats.host_resets);\r\n}\r\nvoid fas216_print_devices(FAS216_Info *info, struct seq_file *m)\r\n{\r\nstruct fas216_device *dev;\r\nstruct scsi_device *scd;\r\nseq_printf(m, "Device/Lun TaggedQ Parity Sync\n");\r\nshost_for_each_device(scd, info->host) {\r\ndev = &info->device[scd->id];\r\nseq_printf(m, " %d/%llu ", scd->id, scd->lun);\r\nif (scd->tagged_supported)\r\nseq_printf(m, "%3sabled(%3d) ",\r\nscd->simple_tags ? "en" : "dis",\r\nscd->current_tag);\r\nelse\r\nseq_printf(m, "unsupported ");\r\nseq_printf(m, "%3sabled ", dev->parity_enabled ? "en" : "dis");\r\nif (dev->sof)\r\nseq_printf(m, "offset %d, %d ns\n",\r\ndev->sof, dev->period * 4);\r\nelse\r\nseq_printf(m, "async\n");\r\n}\r\n}
