static int\r\nxdr_nfsace_encode(struct xdr_array2_desc *desc, void *elem)\r\n{\r\nstruct nfsacl_encode_desc *nfsacl_desc =\r\n(struct nfsacl_encode_desc *) desc;\r\n__be32 *p = elem;\r\nstruct posix_acl_entry *entry =\r\n&nfsacl_desc->acl->a_entries[nfsacl_desc->count++];\r\n*p++ = htonl(entry->e_tag | nfsacl_desc->typeflag);\r\nswitch(entry->e_tag) {\r\ncase ACL_USER_OBJ:\r\n*p++ = htonl(from_kuid(&init_user_ns, nfsacl_desc->uid));\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\n*p++ = htonl(from_kgid(&init_user_ns, nfsacl_desc->gid));\r\nbreak;\r\ncase ACL_USER:\r\n*p++ = htonl(from_kuid(&init_user_ns, entry->e_uid));\r\nbreak;\r\ncase ACL_GROUP:\r\n*p++ = htonl(from_kgid(&init_user_ns, entry->e_gid));\r\nbreak;\r\ndefault:\r\n*p++ = 0;\r\nbreak;\r\n}\r\n*p++ = htonl(entry->e_perm & S_IRWXO);\r\nreturn 0;\r\n}\r\nint nfsacl_encode(struct xdr_buf *buf, unsigned int base, struct inode *inode,\r\nstruct posix_acl *acl, int encode_entries, int typeflag)\r\n{\r\nint entries = (acl && acl->a_count) ? max_t(int, acl->a_count, 4) : 0;\r\nstruct nfsacl_encode_desc nfsacl_desc = {\r\n.desc = {\r\n.elem_size = 12,\r\n.array_len = encode_entries ? entries : 0,\r\n.xcode = xdr_nfsace_encode,\r\n},\r\n.acl = acl,\r\n.typeflag = typeflag,\r\n.uid = inode->i_uid,\r\n.gid = inode->i_gid,\r\n};\r\nstruct nfsacl_simple_acl aclbuf;\r\nint err;\r\nif (entries > NFS_ACL_MAX_ENTRIES ||\r\nxdr_encode_word(buf, base, entries))\r\nreturn -EINVAL;\r\nif (encode_entries && acl && acl->a_count == 3) {\r\nstruct posix_acl *acl2 = &aclbuf.acl;\r\nposix_acl_init(acl2, 4);\r\nacl2->a_entries[0] = acl->a_entries[0];\r\nacl2->a_entries[1] = acl->a_entries[1];\r\nacl2->a_entries[2] = acl->a_entries[1];\r\nacl2->a_entries[2].e_tag = ACL_MASK;\r\nacl2->a_entries[3] = acl->a_entries[2];\r\nnfsacl_desc.acl = acl2;\r\n}\r\nerr = xdr_encode_array2(buf, base + 4, &nfsacl_desc.desc);\r\nif (!err)\r\nerr = 8 + nfsacl_desc.desc.elem_size *\r\nnfsacl_desc.desc.array_len;\r\nreturn err;\r\n}\r\nstatic int\r\nxdr_nfsace_decode(struct xdr_array2_desc *desc, void *elem)\r\n{\r\nstruct nfsacl_decode_desc *nfsacl_desc =\r\n(struct nfsacl_decode_desc *) desc;\r\n__be32 *p = elem;\r\nstruct posix_acl_entry *entry;\r\nunsigned int id;\r\nif (!nfsacl_desc->acl) {\r\nif (desc->array_len > NFS_ACL_MAX_ENTRIES)\r\nreturn -EINVAL;\r\nnfsacl_desc->acl = posix_acl_alloc(desc->array_len, GFP_KERNEL);\r\nif (!nfsacl_desc->acl)\r\nreturn -ENOMEM;\r\nnfsacl_desc->count = 0;\r\n}\r\nentry = &nfsacl_desc->acl->a_entries[nfsacl_desc->count++];\r\nentry->e_tag = ntohl(*p++) & ~NFS_ACL_DEFAULT;\r\nid = ntohl(*p++);\r\nentry->e_perm = ntohl(*p++);\r\nswitch(entry->e_tag) {\r\ncase ACL_USER:\r\nentry->e_uid = make_kuid(&init_user_ns, id);\r\nif (!uid_valid(entry->e_uid))\r\nreturn -EINVAL;\r\nbreak;\r\ncase ACL_GROUP:\r\nentry->e_gid = make_kgid(&init_user_ns, id);\r\nif (!gid_valid(entry->e_gid))\r\nreturn -EINVAL;\r\nbreak;\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_OTHER:\r\nif (entry->e_perm & ~S_IRWXO)\r\nreturn -EINVAL;\r\nbreak;\r\ncase ACL_MASK:\r\nentry->e_perm &= S_IRWXO;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncmp_acl_entry(const void *x, const void *y)\r\n{\r\nconst struct posix_acl_entry *a = x, *b = y;\r\nif (a->e_tag != b->e_tag)\r\nreturn a->e_tag - b->e_tag;\r\nelse if ((a->e_tag == ACL_USER) && uid_gt(a->e_uid, b->e_uid))\r\nreturn 1;\r\nelse if ((a->e_tag == ACL_USER) && uid_lt(a->e_uid, b->e_uid))\r\nreturn -1;\r\nelse if ((a->e_tag == ACL_GROUP) && gid_gt(a->e_gid, b->e_gid))\r\nreturn 1;\r\nelse if ((a->e_tag == ACL_GROUP) && gid_lt(a->e_gid, b->e_gid))\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\nposix_acl_from_nfsacl(struct posix_acl *acl)\r\n{\r\nstruct posix_acl_entry *pa, *pe,\r\n*group_obj = NULL, *mask = NULL;\r\nif (!acl)\r\nreturn 0;\r\nsort(acl->a_entries, acl->a_count, sizeof(struct posix_acl_entry),\r\ncmp_acl_entry, NULL);\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch(pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\ngroup_obj = pa;\r\nbreak;\r\ncase ACL_MASK:\r\nmask = pa;\r\ncase ACL_OTHER:\r\nbreak;\r\n}\r\n}\r\nif (acl->a_count == 4 && group_obj && mask &&\r\nmask->e_perm == group_obj->e_perm) {\r\nmemmove(mask, mask+1, (3 - (mask - acl->a_entries)) *\r\nsizeof(struct posix_acl_entry));\r\nacl->a_count = 3;\r\n}\r\nreturn 0;\r\n}\r\nint nfsacl_decode(struct xdr_buf *buf, unsigned int base, unsigned int *aclcnt,\r\nstruct posix_acl **pacl)\r\n{\r\nstruct nfsacl_decode_desc nfsacl_desc = {\r\n.desc = {\r\n.elem_size = 12,\r\n.xcode = pacl ? xdr_nfsace_decode : NULL,\r\n},\r\n};\r\nu32 entries;\r\nint err;\r\nif (xdr_decode_word(buf, base, &entries) ||\r\nentries > NFS_ACL_MAX_ENTRIES)\r\nreturn -EINVAL;\r\nnfsacl_desc.desc.array_maxlen = entries;\r\nerr = xdr_decode_array2(buf, base + 4, &nfsacl_desc.desc);\r\nif (err)\r\nreturn err;\r\nif (pacl) {\r\nif (entries != nfsacl_desc.desc.array_len ||\r\nposix_acl_from_nfsacl(nfsacl_desc.acl) != 0) {\r\nposix_acl_release(nfsacl_desc.acl);\r\nreturn -EINVAL;\r\n}\r\n*pacl = nfsacl_desc.acl;\r\n}\r\nif (aclcnt)\r\n*aclcnt = entries;\r\nreturn 8 + nfsacl_desc.desc.elem_size *\r\nnfsacl_desc.desc.array_len;\r\n}
