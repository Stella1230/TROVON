static int acpi_processor_errata_piix4(struct pci_dev *dev)\r\n{\r\nu8 value1 = 0;\r\nu8 value2 = 0;\r\nif (!dev)\r\nreturn -EINVAL;\r\nswitch (dev->revision) {\r\ncase 0:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 A-step\n"));\r\nbreak;\r\ncase 1:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 B-step\n"));\r\nbreak;\r\ncase 2:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4E\n"));\r\nbreak;\r\ncase 3:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4M\n"));\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unknown PIIX4\n"));\r\nbreak;\r\n}\r\nswitch (dev->revision) {\r\ncase 0:\r\ncase 1:\r\nerrata.piix4.throttle = 1;\r\ncase 2:\r\ncase 3:\r\ndev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB,\r\nPCI_ANY_ID, PCI_ANY_ID, NULL);\r\nif (dev) {\r\nerrata.piix4.bmisx = pci_resource_start(dev, 4);\r\npci_dev_put(dev);\r\n}\r\ndev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB_0,\r\nPCI_ANY_ID, PCI_ANY_ID, NULL);\r\nif (dev) {\r\npci_read_config_byte(dev, 0x76, &value1);\r\npci_read_config_byte(dev, 0x77, &value2);\r\nif ((value1 & 0x80) || (value2 & 0x80))\r\nerrata.piix4.fdma = 1;\r\npci_dev_put(dev);\r\n}\r\nbreak;\r\n}\r\nif (errata.piix4.bmisx)\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Bus master activity detection (BM-IDE) erratum enabled\n"));\r\nif (errata.piix4.fdma)\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Type-F DMA livelock erratum (C3 disabled)\n"));\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_errata(void)\r\n{\r\nint result = 0;\r\nstruct pci_dev *dev = NULL;\r\ndev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB_3, PCI_ANY_ID,\r\nPCI_ANY_ID, NULL);\r\nif (dev) {\r\nresult = acpi_processor_errata_piix4(dev);\r\npci_dev_put(dev);\r\n}\r\nreturn result;\r\n}\r\nstatic int acpi_processor_hotadd_init(struct acpi_processor *pr)\r\n{\r\nunsigned long long sta;\r\nacpi_status status;\r\nint ret;\r\nif (pr->apic_id == -1)\r\nreturn -ENODEV;\r\nstatus = acpi_evaluate_integer(pr->handle, "_STA", NULL, &sta);\r\nif (ACPI_FAILURE(status) || !(sta & ACPI_STA_DEVICE_PRESENT))\r\nreturn -ENODEV;\r\ncpu_maps_update_begin();\r\ncpu_hotplug_begin();\r\nret = acpi_map_lsapic(pr->handle, pr->apic_id, &pr->id);\r\nif (ret)\r\ngoto out;\r\nret = arch_register_cpu(pr->id);\r\nif (ret) {\r\nacpi_unmap_lsapic(pr->id);\r\ngoto out;\r\n}\r\npr_info("CPU%d has been hot-added\n", pr->id);\r\npr->flags.need_hotplug_init = 1;\r\nout:\r\ncpu_hotplug_done();\r\ncpu_maps_update_done();\r\nreturn ret;\r\n}\r\nstatic inline int acpi_processor_hotadd_init(struct acpi_processor *pr)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int acpi_processor_get_info(struct acpi_device *device)\r\n{\r\nunion acpi_object object = { 0 };\r\nstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\r\nstruct acpi_processor *pr = acpi_driver_data(device);\r\nint apic_id, cpu_index, device_declaration = 0;\r\nacpi_status status = AE_OK;\r\nstatic int cpu0_initialized;\r\nunsigned long long value;\r\nacpi_processor_errata();\r\nif (acpi_gbl_FADT.pm2_control_block && acpi_gbl_FADT.pm2_control_length) {\r\npr->flags.bm_control = 1;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Bus mastering arbitration control present\n"));\r\n} else\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"No bus mastering arbitration control\n"));\r\nif (!strcmp(acpi_device_hid(device), ACPI_PROCESSOR_OBJECT_HID)) {\r\nstatus = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(&device->dev,\r\n"Failed to evaluate processor object (0x%x)\n",\r\nstatus);\r\nreturn -ENODEV;\r\n}\r\npr->acpi_id = object.processor.proc_id;\r\n} else {\r\nstatus = acpi_evaluate_integer(pr->handle, METHOD_NAME__UID,\r\nNULL, &value);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(&device->dev,\r\n"Failed to evaluate processor _UID (0x%x)\n",\r\nstatus);\r\nreturn -ENODEV;\r\n}\r\ndevice_declaration = 1;\r\npr->acpi_id = value;\r\n}\r\napic_id = acpi_get_apicid(pr->handle, device_declaration, pr->acpi_id);\r\nif (apic_id < 0)\r\nacpi_handle_debug(pr->handle, "failed to get CPU APIC ID.\n");\r\npr->apic_id = apic_id;\r\ncpu_index = acpi_map_cpuid(pr->apic_id, pr->acpi_id);\r\nif (!cpu0_initialized && !acpi_has_cpu_in_madt()) {\r\ncpu0_initialized = 1;\r\nif ((cpu_index == -1) && (num_online_cpus() == 1))\r\ncpu_index = 0;\r\n}\r\npr->id = cpu_index;\r\nif (pr->id == -1) {\r\nint ret = acpi_processor_hotadd_init(pr);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsprintf(acpi_device_bid(device), "CPU%X", pr->id);\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d:%d]\n", pr->id,\r\npr->acpi_id));\r\nif (!object.processor.pblk_address)\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "No PBLK (NULL address)\n"));\r\nelse if (object.processor.pblk_length != 6)\r\ndev_err(&device->dev, "Invalid PBLK length [%d]\n",\r\nobject.processor.pblk_length);\r\nelse {\r\npr->throttling.address = object.processor.pblk_address;\r\npr->throttling.duty_offset = acpi_gbl_FADT.duty_offset;\r\npr->throttling.duty_width = acpi_gbl_FADT.duty_width;\r\npr->pblk = object.processor.pblk_address;\r\nrequest_region(pr->throttling.address, 6, "ACPI CPU throttle");\r\n}\r\nstatus = acpi_evaluate_integer(pr->handle, "_SUN", NULL, &value);\r\nif (ACPI_SUCCESS(status))\r\narch_fix_phys_package_id(pr->id, value);\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_add(struct acpi_device *device,\r\nconst struct acpi_device_id *id)\r\n{\r\nstruct acpi_processor *pr;\r\nstruct device *dev;\r\nint result = 0;\r\npr = kzalloc(sizeof(struct acpi_processor), GFP_KERNEL);\r\nif (!pr)\r\nreturn -ENOMEM;\r\nif (!zalloc_cpumask_var(&pr->throttling.shared_cpu_map, GFP_KERNEL)) {\r\nresult = -ENOMEM;\r\ngoto err_free_pr;\r\n}\r\npr->handle = device->handle;\r\nstrcpy(acpi_device_name(device), ACPI_PROCESSOR_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PROCESSOR_CLASS);\r\ndevice->driver_data = pr;\r\nresult = acpi_processor_get_info(device);\r\nif (result)\r\nreturn 0;\r\n#ifdef CONFIG_SMP\r\nif (pr->id >= setup_max_cpus && pr->id != 0)\r\nreturn 0;\r\n#endif\r\nBUG_ON(pr->id >= nr_cpu_ids);\r\nif (per_cpu(processor_device_array, pr->id) != NULL &&\r\nper_cpu(processor_device_array, pr->id) != device) {\r\ndev_warn(&device->dev,\r\n"BIOS reported wrong ACPI id %d for the processor\n",\r\npr->id);\r\ngoto err;\r\n}\r\nper_cpu(processor_device_array, pr->id) = device;\r\nper_cpu(processors, pr->id) = pr;\r\ndev = get_cpu_device(pr->id);\r\nif (!dev) {\r\nresult = -ENODEV;\r\ngoto err;\r\n}\r\nresult = acpi_bind_one(dev, device);\r\nif (result)\r\ngoto err;\r\npr->dev = dev;\r\nif (device_attach(dev) >= 0)\r\nreturn 1;\r\ndev_err(dev, "Processor driver could not be attached\n");\r\nacpi_unbind_one(dev);\r\nerr:\r\nfree_cpumask_var(pr->throttling.shared_cpu_map);\r\ndevice->driver_data = NULL;\r\nper_cpu(processors, pr->id) = NULL;\r\nerr_free_pr:\r\nkfree(pr);\r\nreturn result;\r\n}\r\nstatic void acpi_processor_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_processor *pr;\r\nif (!device || !acpi_driver_data(device))\r\nreturn;\r\npr = acpi_driver_data(device);\r\nif (pr->id >= nr_cpu_ids)\r\ngoto out;\r\ndevice_release_driver(pr->dev);\r\nacpi_unbind_one(pr->dev);\r\nper_cpu(processor_device_array, pr->id) = NULL;\r\nper_cpu(processors, pr->id) = NULL;\r\ncpu_maps_update_begin();\r\ncpu_hotplug_begin();\r\narch_unregister_cpu(pr->id);\r\nacpi_unmap_lsapic(pr->id);\r\ncpu_hotplug_done();\r\ncpu_maps_update_done();\r\ntry_offline_node(cpu_to_node(pr->id));\r\nout:\r\nfree_cpumask_var(pr->throttling.shared_cpu_map);\r\nkfree(pr);\r\n}\r\nvoid __init acpi_processor_init(void)\r\n{\r\nacpi_scan_add_handler_with_hotplug(&processor_handler, "processor");\r\n}
