static bool tomoyo_same_path_group(const struct tomoyo_acl_head *a,\r\nconst struct tomoyo_acl_head *b)\r\n{\r\nreturn container_of(a, struct tomoyo_path_group, head)->member_name ==\r\ncontainer_of(b, struct tomoyo_path_group, head)->member_name;\r\n}\r\nstatic bool tomoyo_same_number_group(const struct tomoyo_acl_head *a,\r\nconst struct tomoyo_acl_head *b)\r\n{\r\nreturn !memcmp(&container_of(a, struct tomoyo_number_group, head)\r\n->number,\r\n&container_of(b, struct tomoyo_number_group, head)\r\n->number,\r\nsizeof(container_of(a, struct tomoyo_number_group, head)\r\n->number));\r\n}\r\nstatic bool tomoyo_same_address_group(const struct tomoyo_acl_head *a,\r\nconst struct tomoyo_acl_head *b)\r\n{\r\nconst struct tomoyo_address_group *p1 = container_of(a, typeof(*p1),\r\nhead);\r\nconst struct tomoyo_address_group *p2 = container_of(b, typeof(*p2),\r\nhead);\r\nreturn tomoyo_same_ipaddr_union(&p1->address, &p2->address);\r\n}\r\nint tomoyo_write_group(struct tomoyo_acl_param *param, const u8 type)\r\n{\r\nstruct tomoyo_group *group = tomoyo_get_group(param, type);\r\nint error = -EINVAL;\r\nif (!group)\r\nreturn -ENOMEM;\r\nparam->list = &group->member_list;\r\nif (type == TOMOYO_PATH_GROUP) {\r\nstruct tomoyo_path_group e = { };\r\ne.member_name = tomoyo_get_name(tomoyo_read_token(param));\r\nif (!e.member_name) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nerror = tomoyo_update_policy(&e.head, sizeof(e), param,\r\ntomoyo_same_path_group);\r\ntomoyo_put_name(e.member_name);\r\n} else if (type == TOMOYO_NUMBER_GROUP) {\r\nstruct tomoyo_number_group e = { };\r\nif (param->data[0] == '@' ||\r\n!tomoyo_parse_number_union(param, &e.number))\r\ngoto out;\r\nerror = tomoyo_update_policy(&e.head, sizeof(e), param,\r\ntomoyo_same_number_group);\r\n} else {\r\nstruct tomoyo_address_group e = { };\r\nif (param->data[0] == '@' ||\r\n!tomoyo_parse_ipaddr_union(param, &e.address))\r\ngoto out;\r\nerror = tomoyo_update_policy(&e.head, sizeof(e), param,\r\ntomoyo_same_address_group);\r\n}\r\nout:\r\ntomoyo_put_group(group);\r\nreturn error;\r\n}\r\nconst struct tomoyo_path_info *\r\ntomoyo_path_matches_group(const struct tomoyo_path_info *pathname,\r\nconst struct tomoyo_group *group)\r\n{\r\nstruct tomoyo_path_group *member;\r\nlist_for_each_entry_rcu(member, &group->member_list, head.list) {\r\nif (member->head.is_deleted)\r\ncontinue;\r\nif (!tomoyo_path_matches_pattern(pathname, member->member_name))\r\ncontinue;\r\nreturn member->member_name;\r\n}\r\nreturn NULL;\r\n}\r\nbool tomoyo_number_matches_group(const unsigned long min,\r\nconst unsigned long max,\r\nconst struct tomoyo_group *group)\r\n{\r\nstruct tomoyo_number_group *member;\r\nbool matched = false;\r\nlist_for_each_entry_rcu(member, &group->member_list, head.list) {\r\nif (member->head.is_deleted)\r\ncontinue;\r\nif (min > member->number.values[1] ||\r\nmax < member->number.values[0])\r\ncontinue;\r\nmatched = true;\r\nbreak;\r\n}\r\nreturn matched;\r\n}\r\nbool tomoyo_address_matches_group(const bool is_ipv6, const __be32 *address,\r\nconst struct tomoyo_group *group)\r\n{\r\nstruct tomoyo_address_group *member;\r\nbool matched = false;\r\nconst u8 size = is_ipv6 ? 16 : 4;\r\nlist_for_each_entry_rcu(member, &group->member_list, head.list) {\r\nif (member->head.is_deleted)\r\ncontinue;\r\nif (member->address.is_ipv6 != is_ipv6)\r\ncontinue;\r\nif (memcmp(&member->address.ip[0], address, size) > 0 ||\r\nmemcmp(address, &member->address.ip[1], size) > 0)\r\ncontinue;\r\nmatched = true;\r\nbreak;\r\n}\r\nreturn matched;\r\n}
