char *brcmf_ifname(struct brcmf_pub *drvr, int ifidx)\r\n{\r\nif (ifidx < 0 || ifidx >= BRCMF_MAX_IFS) {\r\nbrcmf_err("ifidx %d out of range\n", ifidx);\r\nreturn "<if_bad>";\r\n}\r\nif (drvr->iflist[ifidx] == NULL) {\r\nbrcmf_err("null i/f %d\n", ifidx);\r\nreturn "<if_null>";\r\n}\r\nif (drvr->iflist[ifidx]->ndev)\r\nreturn drvr->iflist[ifidx]->ndev->name;\r\nreturn "<if_none>";\r\n}\r\nstatic void _brcmf_set_multicast_list(struct work_struct *work)\r\n{\r\nstruct brcmf_if *ifp;\r\nstruct net_device *ndev;\r\nstruct netdev_hw_addr *ha;\r\nu32 cmd_value, cnt;\r\n__le32 cnt_le;\r\nchar *buf, *bufp;\r\nu32 buflen;\r\ns32 err;\r\nifp = container_of(work, struct brcmf_if, multicast_work);\r\nbrcmf_dbg(TRACE, "Enter, idx=%d\n", ifp->bssidx);\r\nndev = ifp->ndev;\r\ncmd_value = (ndev->flags & IFF_ALLMULTI) ? true : false;\r\ncnt = netdev_mc_count(ndev);\r\nbuflen = sizeof(cnt) + (cnt * ETH_ALEN);\r\nbuf = kmalloc(buflen, GFP_ATOMIC);\r\nif (!buf)\r\nreturn;\r\nbufp = buf;\r\ncnt_le = cpu_to_le32(cnt);\r\nmemcpy(bufp, &cnt_le, sizeof(cnt_le));\r\nbufp += sizeof(cnt_le);\r\nnetdev_for_each_mc_addr(ha, ndev) {\r\nif (!cnt)\r\nbreak;\r\nmemcpy(bufp, ha->addr, ETH_ALEN);\r\nbufp += ETH_ALEN;\r\ncnt--;\r\n}\r\nerr = brcmf_fil_iovar_data_set(ifp, "mcast_list", buf, buflen);\r\nif (err < 0) {\r\nbrcmf_err("Setting mcast_list failed, %d\n", err);\r\ncmd_value = cnt ? true : cmd_value;\r\n}\r\nkfree(buf);\r\nerr = brcmf_fil_iovar_int_set(ifp, "allmulti", cmd_value);\r\nif (err < 0)\r\nbrcmf_err("Setting allmulti failed, %d\n", err);\r\ncmd_value = (ndev->flags & IFF_PROMISC) ? true : false;\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PROMISC, cmd_value);\r\nif (err < 0)\r\nbrcmf_err("Setting BRCMF_C_SET_PROMISC failed, %d\n",\r\nerr);\r\n}\r\nstatic void\r\n_brcmf_set_mac_address(struct work_struct *work)\r\n{\r\nstruct brcmf_if *ifp;\r\ns32 err;\r\nifp = container_of(work, struct brcmf_if, setmacaddr_work);\r\nbrcmf_dbg(TRACE, "Enter, idx=%d\n", ifp->bssidx);\r\nerr = brcmf_fil_iovar_data_set(ifp, "cur_etheraddr", ifp->mac_addr,\r\nETH_ALEN);\r\nif (err < 0) {\r\nbrcmf_err("Setting cur_etheraddr failed, %d\n", err);\r\n} else {\r\nbrcmf_dbg(TRACE, "MAC address updated to %pM\n",\r\nifp->mac_addr);\r\nmemcpy(ifp->ndev->dev_addr, ifp->mac_addr, ETH_ALEN);\r\n}\r\n}\r\nstatic int brcmf_netdev_set_mac_address(struct net_device *ndev, void *addr)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct sockaddr *sa = (struct sockaddr *)addr;\r\nmemcpy(&ifp->mac_addr, sa->sa_data, ETH_ALEN);\r\nschedule_work(&ifp->setmacaddr_work);\r\nreturn 0;\r\n}\r\nstatic void brcmf_netdev_set_multicast_list(struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nschedule_work(&ifp->multicast_work);\r\n}\r\nstatic netdev_tx_t brcmf_netdev_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nint ret;\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_pub *drvr = ifp->drvr;\r\nstruct ethhdr *eh = (struct ethhdr *)(skb->data);\r\nbrcmf_dbg(DATA, "Enter, idx=%d\n", ifp->bssidx);\r\nif (drvr->bus_if->state != BRCMF_BUS_DATA) {\r\nbrcmf_err("xmit rejected state=%d\n", drvr->bus_if->state);\r\nnetif_stop_queue(ndev);\r\ndev_kfree_skb(skb);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif (!drvr->iflist[ifp->bssidx]) {\r\nbrcmf_err("bad ifidx %d\n", ifp->bssidx);\r\nnetif_stop_queue(ndev);\r\ndev_kfree_skb(skb);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif (skb_headroom(skb) < drvr->hdrlen) {\r\nstruct sk_buff *skb2;\r\nbrcmf_dbg(INFO, "%s: insufficient headroom\n",\r\nbrcmf_ifname(drvr, ifp->bssidx));\r\ndrvr->bus_if->tx_realloc++;\r\nskb2 = skb_realloc_headroom(skb, drvr->hdrlen);\r\ndev_kfree_skb(skb);\r\nskb = skb2;\r\nif (skb == NULL) {\r\nbrcmf_err("%s: skb_realloc_headroom failed\n",\r\nbrcmf_ifname(drvr, ifp->bssidx));\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\n}\r\nif (skb->len < sizeof(*eh)) {\r\nret = -EINVAL;\r\ndev_kfree_skb(skb);\r\ngoto done;\r\n}\r\nif (eh->h_proto == htons(ETH_P_PAE))\r\natomic_inc(&ifp->pend_8021x_cnt);\r\nret = brcmf_fws_process_skb(ifp, skb);\r\ndone:\r\nif (ret) {\r\nifp->stats.tx_dropped++;\r\n} else {\r\nifp->stats.tx_packets++;\r\nifp->stats.tx_bytes += skb->len;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nvoid brcmf_txflowblock_if(struct brcmf_if *ifp,\r\nenum brcmf_netif_stop_reason reason, bool state)\r\n{\r\nunsigned long flags;\r\nif (!ifp || !ifp->ndev)\r\nreturn;\r\nbrcmf_dbg(TRACE, "enter: idx=%d stop=0x%X reason=%d state=%d\n",\r\nifp->bssidx, ifp->netif_stop, reason, state);\r\nspin_lock_irqsave(&ifp->netif_stop_lock, flags);\r\nif (state) {\r\nif (!ifp->netif_stop)\r\nnetif_stop_queue(ifp->ndev);\r\nifp->netif_stop |= reason;\r\n} else {\r\nifp->netif_stop &= ~reason;\r\nif (!ifp->netif_stop)\r\nnetif_wake_queue(ifp->ndev);\r\n}\r\nspin_unlock_irqrestore(&ifp->netif_stop_lock, flags);\r\n}\r\nvoid brcmf_txflowblock(struct device *dev, bool state)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbrcmf_fws_bus_blocked(drvr, state);\r\n}\r\nvoid brcmf_netif_rx(struct brcmf_if *ifp, struct sk_buff *skb)\r\n{\r\nskb->dev = ifp->ndev;\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nif (skb->pkt_type == PACKET_MULTICAST)\r\nifp->stats.multicast++;\r\nbrcmf_fweh_process_skb(ifp->drvr, skb);\r\nif (!(ifp->ndev->flags & IFF_UP)) {\r\nbrcmu_pkt_buf_free_skb(skb);\r\nreturn;\r\n}\r\nifp->stats.rx_bytes += skb->len;\r\nifp->stats.rx_packets++;\r\nbrcmf_dbg(DATA, "rx proto=0x%X\n", ntohs(skb->protocol));\r\nif (in_interrupt())\r\nnetif_rx(skb);\r\nelse\r\nnetif_rx_ni(skb);\r\n}\r\nstatic void brcmf_rxreorder_get_skb_list(struct brcmf_ampdu_rx_reorder *rfi,\r\nu8 start, u8 end,\r\nstruct sk_buff_head *skb_list)\r\n{\r\n__skb_queue_head_init(skb_list);\r\nif (rfi->pend_pkts == 0) {\r\nbrcmf_dbg(INFO, "no packets in reorder queue\n");\r\nreturn;\r\n}\r\ndo {\r\nif (rfi->pktslots[start]) {\r\n__skb_queue_tail(skb_list, rfi->pktslots[start]);\r\nrfi->pktslots[start] = NULL;\r\n}\r\nstart++;\r\nif (start > rfi->max_idx)\r\nstart = 0;\r\n} while (start != end);\r\nrfi->pend_pkts -= skb_queue_len(skb_list);\r\n}\r\nstatic void brcmf_rxreorder_process_info(struct brcmf_if *ifp, u8 *reorder_data,\r\nstruct sk_buff *pkt)\r\n{\r\nu8 flow_id, max_idx, cur_idx, exp_idx, end_idx;\r\nstruct brcmf_ampdu_rx_reorder *rfi;\r\nstruct sk_buff_head reorder_list;\r\nstruct sk_buff *pnext;\r\nu8 flags;\r\nu32 buf_size;\r\nflow_id = reorder_data[BRCMF_RXREORDER_FLOWID_OFFSET];\r\nflags = reorder_data[BRCMF_RXREORDER_FLAGS_OFFSET];\r\nif (flags == 0xFF) {\r\nbrcmf_err("invalid flags...so ignore this packet\n");\r\nbrcmf_netif_rx(ifp, pkt);\r\nreturn;\r\n}\r\nrfi = ifp->drvr->reorder_flows[flow_id];\r\nif (flags & BRCMF_RXREORDER_DEL_FLOW) {\r\nbrcmf_dbg(INFO, "flow-%d: delete\n",\r\nflow_id);\r\nif (rfi == NULL) {\r\nbrcmf_dbg(INFO, "received flags to cleanup, but no flow (%d) yet\n",\r\nflow_id);\r\nbrcmf_netif_rx(ifp, pkt);\r\nreturn;\r\n}\r\nbrcmf_rxreorder_get_skb_list(rfi, rfi->exp_idx, rfi->exp_idx,\r\n&reorder_list);\r\n__skb_queue_tail(&reorder_list, pkt);\r\nkfree(rfi);\r\nifp->drvr->reorder_flows[flow_id] = NULL;\r\ngoto netif_rx;\r\n}\r\nif (rfi == NULL) {\r\nbuf_size = sizeof(*rfi);\r\nmax_idx = reorder_data[BRCMF_RXREORDER_MAXIDX_OFFSET];\r\nbuf_size += (max_idx + 1) * sizeof(pkt);\r\nbrcmf_dbg(INFO, "flow-%d: start, maxidx %d\n",\r\nflow_id, max_idx);\r\nrfi = kzalloc(buf_size, GFP_ATOMIC);\r\nif (rfi == NULL) {\r\nbrcmf_err("failed to alloc buffer\n");\r\nbrcmf_netif_rx(ifp, pkt);\r\nreturn;\r\n}\r\nifp->drvr->reorder_flows[flow_id] = rfi;\r\nrfi->pktslots = (struct sk_buff **)(rfi+1);\r\nrfi->max_idx = max_idx;\r\n}\r\nif (flags & BRCMF_RXREORDER_NEW_HOLE) {\r\nif (rfi->pend_pkts) {\r\nbrcmf_rxreorder_get_skb_list(rfi, rfi->exp_idx,\r\nrfi->exp_idx,\r\n&reorder_list);\r\nWARN_ON(rfi->pend_pkts);\r\n} else {\r\n__skb_queue_head_init(&reorder_list);\r\n}\r\nrfi->cur_idx = reorder_data[BRCMF_RXREORDER_CURIDX_OFFSET];\r\nrfi->exp_idx = reorder_data[BRCMF_RXREORDER_EXPIDX_OFFSET];\r\nrfi->max_idx = reorder_data[BRCMF_RXREORDER_MAXIDX_OFFSET];\r\nrfi->pktslots[rfi->cur_idx] = pkt;\r\nrfi->pend_pkts++;\r\nbrcmf_dbg(DATA, "flow-%d: new hole %d (%d), pending %d\n",\r\nflow_id, rfi->cur_idx, rfi->exp_idx, rfi->pend_pkts);\r\n} else if (flags & BRCMF_RXREORDER_CURIDX_VALID) {\r\ncur_idx = reorder_data[BRCMF_RXREORDER_CURIDX_OFFSET];\r\nexp_idx = reorder_data[BRCMF_RXREORDER_EXPIDX_OFFSET];\r\nif ((exp_idx == rfi->exp_idx) && (cur_idx != rfi->exp_idx)) {\r\nif (rfi->pktslots[cur_idx] != NULL) {\r\nbrcmf_dbg(INFO, "HOLE: ERROR buffer pending..free it\n");\r\nbrcmu_pkt_buf_free_skb(rfi->pktslots[cur_idx]);\r\nrfi->pktslots[cur_idx] = NULL;\r\n}\r\nrfi->pktslots[cur_idx] = pkt;\r\nrfi->pend_pkts++;\r\nrfi->cur_idx = cur_idx;\r\nbrcmf_dbg(DATA, "flow-%d: store pkt %d (%d), pending %d\n",\r\nflow_id, cur_idx, exp_idx, rfi->pend_pkts);\r\nreturn;\r\n}\r\nif (rfi->exp_idx == cur_idx) {\r\nif (rfi->pktslots[cur_idx] != NULL) {\r\nbrcmf_dbg(INFO, "error buffer pending..free it\n");\r\nbrcmu_pkt_buf_free_skb(rfi->pktslots[cur_idx]);\r\nrfi->pktslots[cur_idx] = NULL;\r\n}\r\nrfi->pktslots[cur_idx] = pkt;\r\nrfi->pend_pkts++;\r\nbrcmf_dbg(DATA, "flow-%d: expected %d (%d), pending %d\n",\r\nflow_id, cur_idx, exp_idx, rfi->pend_pkts);\r\nrfi->cur_idx = cur_idx;\r\nrfi->exp_idx = exp_idx;\r\nbrcmf_rxreorder_get_skb_list(rfi, cur_idx, exp_idx,\r\n&reorder_list);\r\nbrcmf_dbg(DATA, "flow-%d: freeing buffers %d, pending %d\n",\r\nflow_id, skb_queue_len(&reorder_list),\r\nrfi->pend_pkts);\r\n} else {\r\nu8 end_idx;\r\nbrcmf_dbg(DATA, "flow-%d (0x%x): both moved, old %d/%d, new %d/%d\n",\r\nflow_id, flags, rfi->cur_idx, rfi->exp_idx,\r\ncur_idx, exp_idx);\r\nif (flags & BRCMF_RXREORDER_FLUSH_ALL)\r\nend_idx = rfi->exp_idx;\r\nelse\r\nend_idx = exp_idx;\r\nbrcmf_rxreorder_get_skb_list(rfi, rfi->exp_idx, end_idx,\r\n&reorder_list);\r\nif (exp_idx == ((cur_idx + 1) % (rfi->max_idx + 1))) {\r\n__skb_queue_tail(&reorder_list, pkt);\r\n} else {\r\nrfi->pktslots[cur_idx] = pkt;\r\nrfi->pend_pkts++;\r\n}\r\nrfi->exp_idx = exp_idx;\r\nrfi->cur_idx = cur_idx;\r\n}\r\n} else {\r\nexp_idx = reorder_data[BRCMF_RXREORDER_EXPIDX_OFFSET];\r\nbrcmf_dbg(DATA, "flow-%d (0x%x): change expected: %d -> %d\n",\r\nflow_id, flags, rfi->exp_idx, exp_idx);\r\nif (flags & BRCMF_RXREORDER_FLUSH_ALL)\r\nend_idx = rfi->exp_idx;\r\nelse\r\nend_idx = exp_idx;\r\nbrcmf_rxreorder_get_skb_list(rfi, rfi->exp_idx, end_idx,\r\n&reorder_list);\r\n__skb_queue_tail(&reorder_list, pkt);\r\nrfi->exp_idx = exp_idx;\r\n}\r\nnetif_rx:\r\nskb_queue_walk_safe(&reorder_list, pkt, pnext) {\r\n__skb_unlink(pkt, &reorder_list);\r\nbrcmf_netif_rx(ifp, pkt);\r\n}\r\n}\r\nvoid brcmf_rx_frame(struct device *dev, struct sk_buff *skb)\r\n{\r\nstruct brcmf_if *ifp;\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nstruct brcmf_skb_reorder_data *rd;\r\nu8 ifidx;\r\nint ret;\r\nbrcmf_dbg(DATA, "Enter: %s: rxp=%p\n", dev_name(dev), skb);\r\nret = brcmf_proto_hdrpull(drvr, true, &ifidx, skb);\r\nifp = drvr->iflist[ifidx];\r\nif (ret || !ifp || !ifp->ndev) {\r\nif ((ret != -ENODATA) && ifp)\r\nifp->stats.rx_errors++;\r\nbrcmu_pkt_buf_free_skb(skb);\r\nreturn;\r\n}\r\nrd = (struct brcmf_skb_reorder_data *)skb->cb;\r\nif (rd->reorder)\r\nbrcmf_rxreorder_process_info(ifp, rd->reorder, skb);\r\nelse\r\nbrcmf_netif_rx(ifp, skb);\r\n}\r\nvoid brcmf_txfinalize(struct brcmf_pub *drvr, struct sk_buff *txp, u8 ifidx,\r\nbool success)\r\n{\r\nstruct brcmf_if *ifp;\r\nstruct ethhdr *eh;\r\nu16 type;\r\nifp = drvr->iflist[ifidx];\r\nif (!ifp)\r\ngoto done;\r\neh = (struct ethhdr *)(txp->data);\r\ntype = ntohs(eh->h_proto);\r\nif (type == ETH_P_PAE) {\r\natomic_dec(&ifp->pend_8021x_cnt);\r\nif (waitqueue_active(&ifp->pend_8021x_wait))\r\nwake_up(&ifp->pend_8021x_wait);\r\n}\r\nif (!success)\r\nifp->stats.tx_errors++;\r\ndone:\r\nbrcmu_pkt_buf_free_skb(txp);\r\n}\r\nvoid brcmf_txcomplete(struct device *dev, struct sk_buff *txp, bool success)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nu8 ifidx;\r\nif (brcmf_fws_fc_active(drvr->fws)) {\r\nif (!success)\r\nbrcmf_fws_bustxfail(drvr->fws, txp);\r\n} else {\r\nif (brcmf_proto_hdrpull(drvr, false, &ifidx, txp))\r\nbrcmu_pkt_buf_free_skb(txp);\r\nelse\r\nbrcmf_txfinalize(drvr, txp, ifidx, success);\r\n}\r\n}\r\nstatic struct net_device_stats *brcmf_netdev_get_stats(struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nbrcmf_dbg(TRACE, "Enter, idx=%d\n", ifp->bssidx);\r\nreturn &ifp->stats;\r\n}\r\nstatic void brcmf_ethtool_get_drvinfo(struct net_device *ndev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_pub *drvr = ifp->drvr;\r\nstrlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\r\nsnprintf(info->version, sizeof(info->version), "n/a");\r\nstrlcpy(info->fw_version, drvr->fwver, sizeof(info->fw_version));\r\nstrlcpy(info->bus_info, dev_name(drvr->bus_if->dev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int brcmf_netdev_stop(struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nbrcmf_dbg(TRACE, "Enter, idx=%d\n", ifp->bssidx);\r\nbrcmf_cfg80211_down(ndev);\r\nnetif_stop_queue(ndev);\r\nreturn 0;\r\n}\r\nstatic int brcmf_netdev_open(struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_pub *drvr = ifp->drvr;\r\nstruct brcmf_bus *bus_if = drvr->bus_if;\r\nu32 toe_ol;\r\nbrcmf_dbg(TRACE, "Enter, idx=%d\n", ifp->bssidx);\r\nif (bus_if->state != BRCMF_BUS_DATA) {\r\nbrcmf_err("failed bus is not ready\n");\r\nreturn -EAGAIN;\r\n}\r\natomic_set(&ifp->pend_8021x_cnt, 0);\r\nif (brcmf_fil_iovar_int_get(ifp, "toe_ol", &toe_ol) >= 0\r\n&& (toe_ol & TOE_TX_CSUM_OL) != 0)\r\nndev->features |= NETIF_F_IP_CSUM;\r\nelse\r\nndev->features &= ~NETIF_F_IP_CSUM;\r\nif (brcmf_cfg80211_up(ndev)) {\r\nbrcmf_err("failed to bring up cfg80211\n");\r\nreturn -EIO;\r\n}\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\n}\r\nint brcmf_net_attach(struct brcmf_if *ifp, bool rtnl_locked)\r\n{\r\nstruct brcmf_pub *drvr = ifp->drvr;\r\nstruct net_device *ndev;\r\ns32 err;\r\nbrcmf_dbg(TRACE, "Enter, idx=%d mac=%pM\n", ifp->bssidx,\r\nifp->mac_addr);\r\nndev = ifp->ndev;\r\nndev->netdev_ops = &brcmf_netdev_ops_pri;\r\nndev->hard_header_len += drvr->hdrlen;\r\nndev->ethtool_ops = &brcmf_ethtool_ops;\r\ndrvr->rxsz = ndev->mtu + ndev->hard_header_len +\r\ndrvr->hdrlen;\r\nmemcpy(ndev->dev_addr, ifp->mac_addr, ETH_ALEN);\r\nINIT_WORK(&ifp->setmacaddr_work, _brcmf_set_mac_address);\r\nINIT_WORK(&ifp->multicast_work, _brcmf_set_multicast_list);\r\nif (rtnl_locked)\r\nerr = register_netdevice(ndev);\r\nelse\r\nerr = register_netdev(ndev);\r\nif (err != 0) {\r\nbrcmf_err("couldn't register the net device\n");\r\ngoto fail;\r\n}\r\nbrcmf_dbg(INFO, "%s: Broadcom Dongle Host Driver\n", ndev->name);\r\nndev->destructor = brcmf_cfg80211_free_netdev;\r\nreturn 0;\r\nfail:\r\ndrvr->iflist[ifp->bssidx] = NULL;\r\nndev->netdev_ops = NULL;\r\nfree_netdev(ndev);\r\nreturn -EBADE;\r\n}\r\nstatic int brcmf_net_p2p_open(struct net_device *ndev)\r\n{\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nreturn brcmf_cfg80211_up(ndev);\r\n}\r\nstatic int brcmf_net_p2p_stop(struct net_device *ndev)\r\n{\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nreturn brcmf_cfg80211_down(ndev);\r\n}\r\nstatic netdev_tx_t brcmf_net_p2p_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int brcmf_net_p2p_attach(struct brcmf_if *ifp)\r\n{\r\nstruct net_device *ndev;\r\nbrcmf_dbg(TRACE, "Enter, idx=%d mac=%pM\n", ifp->bssidx,\r\nifp->mac_addr);\r\nndev = ifp->ndev;\r\nndev->netdev_ops = &brcmf_netdev_ops_p2p;\r\nmemcpy(ndev->dev_addr, ifp->mac_addr, ETH_ALEN);\r\nif (register_netdev(ndev) != 0) {\r\nbrcmf_err("couldn't register the p2p net device\n");\r\ngoto fail;\r\n}\r\nbrcmf_dbg(INFO, "%s: Broadcom Dongle Host Driver\n", ndev->name);\r\nreturn 0;\r\nfail:\r\nifp->drvr->iflist[ifp->bssidx] = NULL;\r\nndev->netdev_ops = NULL;\r\nfree_netdev(ndev);\r\nreturn -EBADE;\r\n}\r\nstruct brcmf_if *brcmf_add_if(struct brcmf_pub *drvr, s32 bssidx, s32 ifidx,\r\nchar *name, u8 *mac_addr)\r\n{\r\nstruct brcmf_if *ifp;\r\nstruct net_device *ndev;\r\nbrcmf_dbg(TRACE, "Enter, idx=%d, ifidx=%d\n", bssidx, ifidx);\r\nifp = drvr->iflist[bssidx];\r\nif (ifp) {\r\nbrcmf_err("ERROR: netdev:%s already exists\n",\r\nifp->ndev->name);\r\nif (ifidx) {\r\nnetif_stop_queue(ifp->ndev);\r\nunregister_netdev(ifp->ndev);\r\nfree_netdev(ifp->ndev);\r\ndrvr->iflist[bssidx] = NULL;\r\n} else {\r\nbrcmf_err("ignore IF event\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nif (!brcmf_p2p_enable && bssidx == 1) {\r\nbrcmf_dbg(INFO, "allocate non-netdev interface\n");\r\nifp = kzalloc(sizeof(*ifp), GFP_KERNEL);\r\nif (!ifp)\r\nreturn ERR_PTR(-ENOMEM);\r\n} else {\r\nbrcmf_dbg(INFO, "allocate netdev interface\n");\r\nndev = alloc_netdev(sizeof(*ifp), name, NET_NAME_UNKNOWN,\r\nether_setup);\r\nif (!ndev)\r\nreturn ERR_PTR(-ENOMEM);\r\nifp = netdev_priv(ndev);\r\nifp->ndev = ndev;\r\n}\r\nifp->drvr = drvr;\r\ndrvr->iflist[bssidx] = ifp;\r\nifp->ifidx = ifidx;\r\nifp->bssidx = bssidx;\r\ninit_waitqueue_head(&ifp->pend_8021x_wait);\r\nspin_lock_init(&ifp->netif_stop_lock);\r\nif (mac_addr != NULL)\r\nmemcpy(ifp->mac_addr, mac_addr, ETH_ALEN);\r\nbrcmf_dbg(TRACE, " ==== pid:%x, if:%s (%pM) created ===\n",\r\ncurrent->pid, name, ifp->mac_addr);\r\nreturn ifp;\r\n}\r\nvoid brcmf_del_if(struct brcmf_pub *drvr, s32 bssidx)\r\n{\r\nstruct brcmf_if *ifp;\r\nifp = drvr->iflist[bssidx];\r\ndrvr->iflist[bssidx] = NULL;\r\nif (!ifp) {\r\nbrcmf_err("Null interface, idx=%d\n", bssidx);\r\nreturn;\r\n}\r\nbrcmf_dbg(TRACE, "Enter, idx=%d, ifidx=%d\n", bssidx, ifp->ifidx);\r\nif (ifp->ndev) {\r\nif (bssidx == 0) {\r\nif (ifp->ndev->netdev_ops == &brcmf_netdev_ops_pri) {\r\nrtnl_lock();\r\nbrcmf_netdev_stop(ifp->ndev);\r\nrtnl_unlock();\r\n}\r\n} else {\r\nnetif_stop_queue(ifp->ndev);\r\n}\r\nif (ifp->ndev->netdev_ops == &brcmf_netdev_ops_pri) {\r\ncancel_work_sync(&ifp->setmacaddr_work);\r\ncancel_work_sync(&ifp->multicast_work);\r\n}\r\nunregister_netdev(ifp->ndev);\r\n} else {\r\nkfree(ifp);\r\n}\r\n}\r\nint brcmf_attach(struct device *dev)\r\n{\r\nstruct brcmf_pub *drvr = NULL;\r\nint ret = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\ndrvr = kzalloc(sizeof(struct brcmf_pub), GFP_ATOMIC);\r\nif (!drvr)\r\nreturn -ENOMEM;\r\nmutex_init(&drvr->proto_block);\r\ndrvr->hdrlen = 0;\r\ndrvr->bus_if = dev_get_drvdata(dev);\r\ndrvr->bus_if->drvr = drvr;\r\nbrcmf_debugfs_attach(drvr);\r\nret = brcmf_proto_attach(drvr);\r\nif (ret != 0) {\r\nbrcmf_err("brcmf_prot_attach failed\n");\r\ngoto fail;\r\n}\r\nbrcmf_fweh_attach(drvr);\r\nreturn ret;\r\nfail:\r\nbrcmf_detach(dev);\r\nreturn ret;\r\n}\r\nint brcmf_bus_start(struct device *dev)\r\n{\r\nint ret = -1;\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nstruct brcmf_if *ifp;\r\nstruct brcmf_if *p2p_ifp;\r\nbrcmf_dbg(TRACE, "\n");\r\nifp = brcmf_add_if(drvr, 0, 0, "wlan%d", NULL);\r\nif (IS_ERR(ifp))\r\nreturn PTR_ERR(ifp);\r\nif (brcmf_p2p_enable)\r\np2p_ifp = brcmf_add_if(drvr, 1, 0, "p2p%d", NULL);\r\nelse\r\np2p_ifp = NULL;\r\nif (IS_ERR(p2p_ifp))\r\np2p_ifp = NULL;\r\nbrcmf_bus_change_state(bus_if, BRCMF_BUS_DATA);\r\nret = brcmf_c_preinit_dcmds(ifp);\r\nif (ret < 0)\r\ngoto fail;\r\nbrcmf_feat_attach(drvr);\r\nret = brcmf_fws_init(drvr);\r\nif (ret < 0)\r\ngoto fail;\r\nbrcmf_fws_add_interface(ifp);\r\ndrvr->config = brcmf_cfg80211_attach(drvr, bus_if->dev);\r\nif (drvr->config == NULL) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nret = brcmf_fweh_activate_events(ifp);\r\nif (ret < 0)\r\ngoto fail;\r\nret = brcmf_net_attach(ifp, false);\r\nfail:\r\nif (ret < 0) {\r\nbrcmf_err("failed: %d\n", ret);\r\nbrcmf_cfg80211_detach(drvr->config);\r\nif (drvr->fws) {\r\nbrcmf_fws_del_interface(ifp);\r\nbrcmf_fws_deinit(drvr);\r\n}\r\nif (drvr->iflist[0]) {\r\nfree_netdev(ifp->ndev);\r\ndrvr->iflist[0] = NULL;\r\n}\r\nif (p2p_ifp) {\r\nfree_netdev(p2p_ifp->ndev);\r\ndrvr->iflist[1] = NULL;\r\n}\r\nreturn ret;\r\n}\r\nif ((brcmf_p2p_enable) && (p2p_ifp))\r\nif (brcmf_net_p2p_attach(p2p_ifp) < 0)\r\nbrcmf_p2p_enable = 0;\r\nreturn 0;\r\n}\r\nvoid brcmf_bus_add_txhdrlen(struct device *dev, uint len)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nif (drvr) {\r\ndrvr->hdrlen += len;\r\n}\r\n}\r\nstatic void brcmf_bus_detach(struct brcmf_pub *drvr)\r\n{\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (drvr) {\r\nbrcmf_bus_stop(drvr->bus_if);\r\n}\r\n}\r\nvoid brcmf_dev_reset(struct device *dev)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nif (drvr == NULL)\r\nreturn;\r\nif (drvr->iflist[0])\r\nbrcmf_fil_cmd_int_set(drvr->iflist[0], BRCMF_C_TERMINATED, 1);\r\n}\r\nvoid brcmf_detach(struct device *dev)\r\n{\r\ns32 i;\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (drvr == NULL)\r\nreturn;\r\nbrcmf_fweh_detach(drvr);\r\nbrcmf_bus_change_state(bus_if, BRCMF_BUS_DOWN);\r\nfor (i = BRCMF_MAX_IFS-1; i > -1; i--)\r\nif (drvr->iflist[i]) {\r\nbrcmf_fws_del_interface(drvr->iflist[i]);\r\nbrcmf_del_if(drvr, i);\r\n}\r\nbrcmf_cfg80211_detach(drvr->config);\r\nbrcmf_fws_deinit(drvr);\r\nbrcmf_bus_detach(drvr);\r\nbrcmf_proto_detach(drvr);\r\nbrcmf_debugfs_detach(drvr);\r\nbus_if->drvr = NULL;\r\nkfree(drvr);\r\n}\r\ns32 brcmf_iovar_data_set(struct device *dev, char *name, void *data, u32 len)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_if *ifp = bus_if->drvr->iflist[0];\r\nreturn brcmf_fil_iovar_data_set(ifp, name, data, len);\r\n}\r\nstatic int brcmf_get_pend_8021x_cnt(struct brcmf_if *ifp)\r\n{\r\nreturn atomic_read(&ifp->pend_8021x_cnt);\r\n}\r\nint brcmf_netdev_wait_pend8021x(struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nint err;\r\nerr = wait_event_timeout(ifp->pend_8021x_wait,\r\n!brcmf_get_pend_8021x_cnt(ifp),\r\nmsecs_to_jiffies(MAX_WAIT_FOR_8021X_TX));\r\nWARN_ON(!err);\r\nreturn !err;\r\n}\r\nstatic void brcmf_driver_register(struct work_struct *work)\r\n{\r\n#ifdef CONFIG_BRCMFMAC_SDIO\r\nbrcmf_sdio_register();\r\n#endif\r\n#ifdef CONFIG_BRCMFMAC_USB\r\nbrcmf_usb_register();\r\n#endif\r\n#ifdef CONFIG_BRCMFMAC_PCIE\r\nbrcmf_pcie_register();\r\n#endif\r\n}\r\nstatic int __init brcmfmac_module_init(void)\r\n{\r\nbrcmf_debugfs_init();\r\n#ifdef CONFIG_BRCMFMAC_SDIO\r\nbrcmf_sdio_init();\r\n#endif\r\nif (!schedule_work(&brcmf_driver_work))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void __exit brcmfmac_module_exit(void)\r\n{\r\ncancel_work_sync(&brcmf_driver_work);\r\n#ifdef CONFIG_BRCMFMAC_SDIO\r\nbrcmf_sdio_exit();\r\n#endif\r\n#ifdef CONFIG_BRCMFMAC_USB\r\nbrcmf_usb_exit();\r\n#endif\r\n#ifdef CONFIG_BRCMFMAC_PCIE\r\nbrcmf_pcie_exit();\r\n#endif\r\nbrcmf_debugfs_exit();\r\n}
