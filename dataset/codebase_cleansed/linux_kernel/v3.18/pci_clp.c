static inline void zpci_err_clp(unsigned int rsp, int rc)\r\n{\r\nstruct {\r\nunsigned int rsp;\r\nint rc;\r\n} __packed data = {rsp, rc};\r\nzpci_err_hex(&data, sizeof(data));\r\n}\r\nstatic inline u8 clp_instr(void *data)\r\n{\r\nstruct { u8 _[CLP_BLK_SIZE]; } *req = data;\r\nu64 ignored;\r\nu8 cc;\r\nasm volatile (\r\n" .insn rrf,0xb9a00000,%[ign],%[req],0x0,0x2\n"\r\n" ipm %[cc]\n"\r\n" srl %[cc],28\n"\r\n: [cc] "=d" (cc), [ign] "=d" (ignored), "+m" (*req)\r\n: [req] "a" (req)\r\n: "cc");\r\nreturn cc;\r\n}\r\nstatic void *clp_alloc_block(gfp_t gfp_mask)\r\n{\r\nreturn (void *) __get_free_pages(gfp_mask, get_order(CLP_BLK_SIZE));\r\n}\r\nstatic void clp_free_block(void *ptr)\r\n{\r\nfree_pages((unsigned long) ptr, get_order(CLP_BLK_SIZE));\r\n}\r\nstatic void clp_store_query_pci_fngrp(struct zpci_dev *zdev,\r\nstruct clp_rsp_query_pci_grp *response)\r\n{\r\nzdev->tlb_refresh = response->refresh;\r\nzdev->dma_mask = response->dasm;\r\nzdev->msi_addr = response->msia;\r\nzdev->fmb_update = response->mui;\r\nswitch (response->version) {\r\ncase 1:\r\nzdev->max_bus_speed = PCIE_SPEED_5_0GT;\r\nbreak;\r\ndefault:\r\nzdev->max_bus_speed = PCI_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic int clp_query_pci_fngrp(struct zpci_dev *zdev, u8 pfgid)\r\n{\r\nstruct clp_req_rsp_query_pci_grp *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nmemset(rrb, 0, sizeof(*rrb));\r\nrrb->request.hdr.len = sizeof(rrb->request);\r\nrrb->request.hdr.cmd = CLP_QUERY_PCI_FNGRP;\r\nrrb->response.hdr.len = sizeof(rrb->response);\r\nrrb->request.pfgid = pfgid;\r\nrc = clp_instr(rrb);\r\nif (!rc && rrb->response.hdr.rsp == CLP_RC_OK)\r\nclp_store_query_pci_fngrp(zdev, &rrb->response);\r\nelse {\r\nzpci_err("Q PCI FGRP:\n");\r\nzpci_err_clp(rrb->response.hdr.rsp, rc);\r\nrc = -EIO;\r\n}\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nstatic int clp_store_query_pci_fn(struct zpci_dev *zdev,\r\nstruct clp_rsp_query_pci *response)\r\n{\r\nint i;\r\nfor (i = 0; i < PCI_BAR_COUNT; i++) {\r\nzdev->bars[i].val = le32_to_cpu(response->bar[i]);\r\nzdev->bars[i].size = response->bar_size[i];\r\n}\r\nzdev->start_dma = response->sdma;\r\nzdev->end_dma = response->edma;\r\nzdev->pchid = response->pchid;\r\nzdev->pfgid = response->pfgid;\r\nzdev->pft = response->pft;\r\nzdev->vfn = response->vfn;\r\nzdev->uid = response->uid;\r\nmemcpy(zdev->pfip, response->pfip, sizeof(zdev->pfip));\r\nif (response->util_str_avail) {\r\nmemcpy(zdev->util_str, response->util_str,\r\nsizeof(zdev->util_str));\r\n}\r\nreturn 0;\r\n}\r\nstatic int clp_query_pci_fn(struct zpci_dev *zdev, u32 fh)\r\n{\r\nstruct clp_req_rsp_query_pci *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nmemset(rrb, 0, sizeof(*rrb));\r\nrrb->request.hdr.len = sizeof(rrb->request);\r\nrrb->request.hdr.cmd = CLP_QUERY_PCI_FN;\r\nrrb->response.hdr.len = sizeof(rrb->response);\r\nrrb->request.fh = fh;\r\nrc = clp_instr(rrb);\r\nif (!rc && rrb->response.hdr.rsp == CLP_RC_OK) {\r\nrc = clp_store_query_pci_fn(zdev, &rrb->response);\r\nif (rc)\r\ngoto out;\r\nif (rrb->response.pfgid)\r\nrc = clp_query_pci_fngrp(zdev, rrb->response.pfgid);\r\n} else {\r\nzpci_err("Q PCI FN:\n");\r\nzpci_err_clp(rrb->response.hdr.rsp, rc);\r\nrc = -EIO;\r\n}\r\nout:\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nint clp_add_pci_device(u32 fid, u32 fh, int configured)\r\n{\r\nstruct zpci_dev *zdev;\r\nint rc;\r\nzpci_dbg(3, "add fid:%x, fh:%x, c:%d\n", fid, fh, configured);\r\nzdev = kzalloc(sizeof(*zdev), GFP_KERNEL);\r\nif (!zdev)\r\nreturn -ENOMEM;\r\nzdev->fh = fh;\r\nzdev->fid = fid;\r\nrc = clp_query_pci_fn(zdev, fh);\r\nif (rc)\r\ngoto error;\r\nif (configured)\r\nzdev->state = ZPCI_FN_STATE_CONFIGURED;\r\nelse\r\nzdev->state = ZPCI_FN_STATE_STANDBY;\r\nrc = zpci_create_device(zdev);\r\nif (rc)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nkfree(zdev);\r\nreturn rc;\r\n}\r\nstatic int clp_set_pci_fn(u32 *fh, u8 nr_dma_as, u8 command)\r\n{\r\nstruct clp_req_rsp_set_pci *rrb;\r\nint rc, retries = 100;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\ndo {\r\nmemset(rrb, 0, sizeof(*rrb));\r\nrrb->request.hdr.len = sizeof(rrb->request);\r\nrrb->request.hdr.cmd = CLP_SET_PCI_FN;\r\nrrb->response.hdr.len = sizeof(rrb->response);\r\nrrb->request.fh = *fh;\r\nrrb->request.oc = command;\r\nrrb->request.ndas = nr_dma_as;\r\nrc = clp_instr(rrb);\r\nif (rrb->response.hdr.rsp == CLP_RC_SETPCIFN_BUSY) {\r\nretries--;\r\nif (retries < 0)\r\nbreak;\r\nmsleep(20);\r\n}\r\n} while (rrb->response.hdr.rsp == CLP_RC_SETPCIFN_BUSY);\r\nif (!rc && rrb->response.hdr.rsp == CLP_RC_OK)\r\n*fh = rrb->response.fh;\r\nelse {\r\nzpci_err("Set PCI FN:\n");\r\nzpci_err_clp(rrb->response.hdr.rsp, rc);\r\nrc = -EIO;\r\n}\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nint clp_enable_fh(struct zpci_dev *zdev, u8 nr_dma_as)\r\n{\r\nu32 fh = zdev->fh;\r\nint rc;\r\nrc = clp_set_pci_fn(&fh, nr_dma_as, CLP_SET_ENABLE_PCI_FN);\r\nif (!rc)\r\nzdev->fh = fh;\r\nzpci_dbg(3, "ena fid:%x, fh:%x, rc:%d\n", zdev->fid, zdev->fh, rc);\r\nreturn rc;\r\n}\r\nint clp_disable_fh(struct zpci_dev *zdev)\r\n{\r\nu32 fh = zdev->fh;\r\nint rc;\r\nif (!zdev_enabled(zdev))\r\nreturn 0;\r\nrc = clp_set_pci_fn(&fh, 0, CLP_SET_DISABLE_PCI_FN);\r\nif (!rc)\r\nzdev->fh = fh;\r\nzpci_dbg(3, "dis fid:%x, fh:%x, rc:%d\n", zdev->fid, zdev->fh, rc);\r\nreturn rc;\r\n}\r\nstatic int clp_list_pci(struct clp_req_rsp_list_pci *rrb,\r\nvoid (*cb)(struct clp_fh_list_entry *entry))\r\n{\r\nu64 resume_token = 0;\r\nint entries, i, rc;\r\ndo {\r\nmemset(rrb, 0, sizeof(*rrb));\r\nrrb->request.hdr.len = sizeof(rrb->request);\r\nrrb->request.hdr.cmd = CLP_LIST_PCI;\r\nrrb->response.hdr.len = CLP_BLK_SIZE - LIST_PCI_HDR_LEN;\r\nrrb->request.resume_token = resume_token;\r\nrc = clp_instr(rrb);\r\nif (rc || rrb->response.hdr.rsp != CLP_RC_OK) {\r\nzpci_err("List PCI FN:\n");\r\nzpci_err_clp(rrb->response.hdr.rsp, rc);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nWARN_ON_ONCE(rrb->response.entry_size !=\r\nsizeof(struct clp_fh_list_entry));\r\nentries = (rrb->response.hdr.len - LIST_PCI_HDR_LEN) /\r\nrrb->response.entry_size;\r\nresume_token = rrb->response.resume_token;\r\nfor (i = 0; i < entries; i++)\r\ncb(&rrb->response.fh_list[i]);\r\n} while (resume_token);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __clp_add(struct clp_fh_list_entry *entry)\r\n{\r\nif (!entry->vendor_id)\r\nreturn;\r\nclp_add_pci_device(entry->fid, entry->fh, entry->config_state);\r\n}\r\nstatic void __clp_rescan(struct clp_fh_list_entry *entry)\r\n{\r\nstruct zpci_dev *zdev;\r\nif (!entry->vendor_id)\r\nreturn;\r\nzdev = get_zdev_by_fid(entry->fid);\r\nif (!zdev) {\r\nclp_add_pci_device(entry->fid, entry->fh, entry->config_state);\r\nreturn;\r\n}\r\nif (!entry->config_state) {\r\nzpci_stop_device(zdev);\r\n}\r\n}\r\nstatic void __clp_update(struct clp_fh_list_entry *entry)\r\n{\r\nstruct zpci_dev *zdev;\r\nif (!entry->vendor_id)\r\nreturn;\r\nzdev = get_zdev_by_fid(entry->fid);\r\nif (!zdev)\r\nreturn;\r\nzdev->fh = entry->fh;\r\n}\r\nint clp_scan_pci_devices(void)\r\n{\r\nstruct clp_req_rsp_list_pci *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nrc = clp_list_pci(rrb, __clp_add);\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nint clp_rescan_pci_devices(void)\r\n{\r\nstruct clp_req_rsp_list_pci *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_KERNEL);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nrc = clp_list_pci(rrb, __clp_rescan);\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}\r\nint clp_rescan_pci_devices_simple(void)\r\n{\r\nstruct clp_req_rsp_list_pci *rrb;\r\nint rc;\r\nrrb = clp_alloc_block(GFP_NOWAIT);\r\nif (!rrb)\r\nreturn -ENOMEM;\r\nrc = clp_list_pci(rrb, __clp_update);\r\nclp_free_block(rrb);\r\nreturn rc;\r\n}
