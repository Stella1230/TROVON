static int\r\nbrcmf_proto_bcdc_msg(struct brcmf_pub *drvr, int ifidx, uint cmd, void *buf,\r\nuint len, bool set)\r\n{\r\nstruct brcmf_bcdc *bcdc = (struct brcmf_bcdc *)drvr->proto->pd;\r\nstruct brcmf_proto_bcdc_dcmd *msg = &bcdc->msg;\r\nu32 flags;\r\nbrcmf_dbg(BCDC, "Enter\n");\r\nmemset(msg, 0, sizeof(struct brcmf_proto_bcdc_dcmd));\r\nmsg->cmd = cpu_to_le32(cmd);\r\nmsg->len = cpu_to_le32(len);\r\nflags = (++bcdc->reqid << BCDC_DCMD_ID_SHIFT);\r\nif (set)\r\nflags |= BCDC_DCMD_SET;\r\nflags = (flags & ~BCDC_DCMD_IF_MASK) |\r\n(ifidx << BCDC_DCMD_IF_SHIFT);\r\nmsg->flags = cpu_to_le32(flags);\r\nif (buf)\r\nmemcpy(bcdc->buf, buf, len);\r\nlen += sizeof(*msg);\r\nif (len > BRCMF_TX_IOCTL_MAX_MSG_SIZE)\r\nlen = BRCMF_TX_IOCTL_MAX_MSG_SIZE;\r\nreturn brcmf_bus_txctl(drvr->bus_if, (unsigned char *)&bcdc->msg, len);\r\n}\r\nstatic int brcmf_proto_bcdc_cmplt(struct brcmf_pub *drvr, u32 id, u32 len)\r\n{\r\nint ret;\r\nstruct brcmf_bcdc *bcdc = (struct brcmf_bcdc *)drvr->proto->pd;\r\nbrcmf_dbg(BCDC, "Enter\n");\r\nlen += sizeof(struct brcmf_proto_bcdc_dcmd);\r\ndo {\r\nret = brcmf_bus_rxctl(drvr->bus_if, (unsigned char *)&bcdc->msg,\r\nlen);\r\nif (ret < 0)\r\nbreak;\r\n} while (BCDC_DCMD_ID(le32_to_cpu(bcdc->msg.flags)) != id);\r\nreturn ret;\r\n}\r\nstatic int\r\nbrcmf_proto_bcdc_query_dcmd(struct brcmf_pub *drvr, int ifidx, uint cmd,\r\nvoid *buf, uint len)\r\n{\r\nstruct brcmf_bcdc *bcdc = (struct brcmf_bcdc *)drvr->proto->pd;\r\nstruct brcmf_proto_bcdc_dcmd *msg = &bcdc->msg;\r\nvoid *info;\r\nint ret = 0, retries = 0;\r\nu32 id, flags;\r\nbrcmf_dbg(BCDC, "Enter, cmd %d len %d\n", cmd, len);\r\nret = brcmf_proto_bcdc_msg(drvr, ifidx, cmd, buf, len, false);\r\nif (ret < 0) {\r\nbrcmf_err("brcmf_proto_bcdc_msg failed w/status %d\n",\r\nret);\r\ngoto done;\r\n}\r\nretry:\r\nret = brcmf_proto_bcdc_cmplt(drvr, bcdc->reqid, len);\r\nif (ret < 0)\r\ngoto done;\r\nflags = le32_to_cpu(msg->flags);\r\nid = (flags & BCDC_DCMD_ID_MASK) >> BCDC_DCMD_ID_SHIFT;\r\nif ((id < bcdc->reqid) && (++retries < RETRIES))\r\ngoto retry;\r\nif (id != bcdc->reqid) {\r\nbrcmf_err("%s: unexpected request id %d (expected %d)\n",\r\nbrcmf_ifname(drvr, ifidx), id, bcdc->reqid);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\ninfo = (void *)&msg[1];\r\nif (buf) {\r\nif (ret < (int)len)\r\nlen = ret;\r\nmemcpy(buf, info, len);\r\n}\r\nif (flags & BCDC_DCMD_ERROR)\r\nret = le32_to_cpu(msg->status);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int\r\nbrcmf_proto_bcdc_set_dcmd(struct brcmf_pub *drvr, int ifidx, uint cmd,\r\nvoid *buf, uint len)\r\n{\r\nstruct brcmf_bcdc *bcdc = (struct brcmf_bcdc *)drvr->proto->pd;\r\nstruct brcmf_proto_bcdc_dcmd *msg = &bcdc->msg;\r\nint ret = 0;\r\nu32 flags, id;\r\nbrcmf_dbg(BCDC, "Enter, cmd %d len %d\n", cmd, len);\r\nret = brcmf_proto_bcdc_msg(drvr, ifidx, cmd, buf, len, true);\r\nif (ret < 0)\r\ngoto done;\r\nret = brcmf_proto_bcdc_cmplt(drvr, bcdc->reqid, len);\r\nif (ret < 0)\r\ngoto done;\r\nflags = le32_to_cpu(msg->flags);\r\nid = (flags & BCDC_DCMD_ID_MASK) >> BCDC_DCMD_ID_SHIFT;\r\nif (id != bcdc->reqid) {\r\nbrcmf_err("%s: unexpected request id %d (expected %d)\n",\r\nbrcmf_ifname(drvr, ifidx), id, bcdc->reqid);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (flags & BCDC_DCMD_ERROR)\r\nret = le32_to_cpu(msg->status);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void\r\nbrcmf_proto_bcdc_hdrpush(struct brcmf_pub *drvr, int ifidx, u8 offset,\r\nstruct sk_buff *pktbuf)\r\n{\r\nstruct brcmf_proto_bcdc_header *h;\r\nbrcmf_dbg(BCDC, "Enter\n");\r\nskb_push(pktbuf, BCDC_HEADER_LEN);\r\nh = (struct brcmf_proto_bcdc_header *)(pktbuf->data);\r\nh->flags = (BCDC_PROTO_VER << BCDC_FLAG_VER_SHIFT);\r\nif (pktbuf->ip_summed == CHECKSUM_PARTIAL)\r\nh->flags |= BCDC_FLAG_SUM_NEEDED;\r\nh->priority = (pktbuf->priority & BCDC_PRIORITY_MASK);\r\nh->flags2 = 0;\r\nh->data_offset = offset;\r\nBCDC_SET_IF_IDX(h, ifidx);\r\ntrace_brcmf_bcdchdr(pktbuf->data);\r\n}\r\nstatic int\r\nbrcmf_proto_bcdc_hdrpull(struct brcmf_pub *drvr, bool do_fws, u8 *ifidx,\r\nstruct sk_buff *pktbuf)\r\n{\r\nstruct brcmf_proto_bcdc_header *h;\r\nbrcmf_dbg(BCDC, "Enter\n");\r\nif (pktbuf->len <= BCDC_HEADER_LEN) {\r\nbrcmf_dbg(INFO, "rx data too short (%d <= %d)\n",\r\npktbuf->len, BCDC_HEADER_LEN);\r\nreturn -EBADE;\r\n}\r\ntrace_brcmf_bcdchdr(pktbuf->data);\r\nh = (struct brcmf_proto_bcdc_header *)(pktbuf->data);\r\n*ifidx = BCDC_GET_IF_IDX(h);\r\nif (*ifidx >= BRCMF_MAX_IFS) {\r\nbrcmf_err("rx data ifnum out of range (%d)\n", *ifidx);\r\nreturn -EBADE;\r\n}\r\nif (*ifidx)\r\n(*ifidx)++;\r\nif (((h->flags & BCDC_FLAG_VER_MASK) >> BCDC_FLAG_VER_SHIFT) !=\r\nBCDC_PROTO_VER) {\r\nbrcmf_err("%s: non-BCDC packet received, flags 0x%x\n",\r\nbrcmf_ifname(drvr, *ifidx), h->flags);\r\nreturn -EBADE;\r\n}\r\nif (h->flags & BCDC_FLAG_SUM_GOOD) {\r\nbrcmf_dbg(BCDC, "%s: BDC rcv, good checksum, flags 0x%x\n",\r\nbrcmf_ifname(drvr, *ifidx), h->flags);\r\npktbuf->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\npktbuf->priority = h->priority & BCDC_PRIORITY_MASK;\r\nskb_pull(pktbuf, BCDC_HEADER_LEN);\r\nif (do_fws)\r\nbrcmf_fws_hdrpull(drvr, *ifidx, h->data_offset << 2, pktbuf);\r\nelse\r\nskb_pull(pktbuf, h->data_offset << 2);\r\nif (pktbuf->len == 0)\r\nreturn -ENODATA;\r\nreturn 0;\r\n}\r\nstatic int\r\nbrcmf_proto_bcdc_txdata(struct brcmf_pub *drvr, int ifidx, u8 offset,\r\nstruct sk_buff *pktbuf)\r\n{\r\nbrcmf_proto_bcdc_hdrpush(drvr, ifidx, offset, pktbuf);\r\nreturn brcmf_bus_txdata(drvr->bus_if, pktbuf);\r\n}\r\nstatic void\r\nbrcmf_proto_bcdc_configure_addr_mode(struct brcmf_pub *drvr, int ifidx,\r\nenum proto_addr_mode addr_mode)\r\n{\r\n}\r\nstatic void\r\nbrcmf_proto_bcdc_delete_peer(struct brcmf_pub *drvr, int ifidx,\r\nu8 peer[ETH_ALEN])\r\n{\r\n}\r\nstatic void\r\nbrcmf_proto_bcdc_add_tdls_peer(struct brcmf_pub *drvr, int ifidx,\r\nu8 peer[ETH_ALEN])\r\n{\r\n}\r\nint brcmf_proto_bcdc_attach(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_bcdc *bcdc;\r\nbcdc = kzalloc(sizeof(*bcdc), GFP_ATOMIC);\r\nif (!bcdc)\r\ngoto fail;\r\nif ((unsigned long)(&bcdc->msg + 1) != (unsigned long)bcdc->buf) {\r\nbrcmf_err("struct brcmf_proto_bcdc is not correctly defined\n");\r\ngoto fail;\r\n}\r\ndrvr->proto->hdrpull = brcmf_proto_bcdc_hdrpull;\r\ndrvr->proto->query_dcmd = brcmf_proto_bcdc_query_dcmd;\r\ndrvr->proto->set_dcmd = brcmf_proto_bcdc_set_dcmd;\r\ndrvr->proto->txdata = brcmf_proto_bcdc_txdata;\r\ndrvr->proto->configure_addr_mode = brcmf_proto_bcdc_configure_addr_mode;\r\ndrvr->proto->delete_peer = brcmf_proto_bcdc_delete_peer;\r\ndrvr->proto->add_tdls_peer = brcmf_proto_bcdc_add_tdls_peer;\r\ndrvr->proto->pd = bcdc;\r\ndrvr->hdrlen += BCDC_HEADER_LEN + BRCMF_PROT_FW_SIGNAL_MAX_TXBYTES;\r\ndrvr->bus_if->maxctl = BRCMF_DCMD_MAXLEN +\r\nsizeof(struct brcmf_proto_bcdc_dcmd);\r\nreturn 0;\r\nfail:\r\nkfree(bcdc);\r\nreturn -ENOMEM;\r\n}\r\nvoid brcmf_proto_bcdc_detach(struct brcmf_pub *drvr)\r\n{\r\nkfree(drvr->proto->pd);\r\ndrvr->proto->pd = NULL;\r\n}
