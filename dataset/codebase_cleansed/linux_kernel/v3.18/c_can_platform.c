static u16 c_can_plat_read_reg_aligned_to_16bit(const struct c_can_priv *priv,\r\nenum reg index)\r\n{\r\nreturn readw(priv->base + priv->regs[index]);\r\n}\r\nstatic void c_can_plat_write_reg_aligned_to_16bit(const struct c_can_priv *priv,\r\nenum reg index, u16 val)\r\n{\r\nwritew(val, priv->base + priv->regs[index]);\r\n}\r\nstatic u16 c_can_plat_read_reg_aligned_to_32bit(const struct c_can_priv *priv,\r\nenum reg index)\r\n{\r\nreturn readw(priv->base + 2 * priv->regs[index]);\r\n}\r\nstatic void c_can_plat_write_reg_aligned_to_32bit(const struct c_can_priv *priv,\r\nenum reg index, u16 val)\r\n{\r\nwritew(val, priv->base + 2 * priv->regs[index]);\r\n}\r\nstatic void c_can_hw_raminit_wait_ti(const struct c_can_priv *priv, u32 mask,\r\nu32 val)\r\n{\r\nval &= mask;\r\nwhile ((readl(priv->raminit_ctrlreg) & mask) != val)\r\nudelay(1);\r\n}\r\nstatic void c_can_hw_raminit_ti(const struct c_can_priv *priv, bool enable)\r\n{\r\nu32 mask = CAN_RAMINIT_ALL_MASK(priv->instance);\r\nu32 ctrl;\r\nspin_lock(&raminit_lock);\r\nctrl = readl(priv->raminit_ctrlreg);\r\nctrl &= ~CAN_RAMINIT_START_MASK(priv->instance);\r\nctrl |= CAN_RAMINIT_DONE_MASK(priv->instance);\r\nwritel(ctrl, priv->raminit_ctrlreg);\r\nctrl &= ~CAN_RAMINIT_DONE_MASK(priv->instance);\r\nc_can_hw_raminit_wait_ti(priv, mask, ctrl);\r\nif (enable) {\r\nctrl |= CAN_RAMINIT_START_MASK(priv->instance);\r\nwritel(ctrl, priv->raminit_ctrlreg);\r\nctrl |= CAN_RAMINIT_DONE_MASK(priv->instance);\r\nc_can_hw_raminit_wait_ti(priv, mask, ctrl);\r\n}\r\nspin_unlock(&raminit_lock);\r\n}\r\nstatic u32 c_can_plat_read_reg32(const struct c_can_priv *priv, enum reg index)\r\n{\r\nu32 val;\r\nval = priv->read_reg(priv, index);\r\nval |= ((u32) priv->read_reg(priv, index + 1)) << 16;\r\nreturn val;\r\n}\r\nstatic void c_can_plat_write_reg32(const struct c_can_priv *priv, enum reg index,\r\nu32 val)\r\n{\r\npriv->write_reg(priv, index + 1, val >> 16);\r\npriv->write_reg(priv, index, val);\r\n}\r\nstatic u32 d_can_plat_read_reg32(const struct c_can_priv *priv, enum reg index)\r\n{\r\nreturn readl(priv->base + priv->regs[index]);\r\n}\r\nstatic void d_can_plat_write_reg32(const struct c_can_priv *priv, enum reg index,\r\nu32 val)\r\n{\r\nwritel(val, priv->base + priv->regs[index]);\r\n}\r\nstatic void c_can_hw_raminit_wait(const struct c_can_priv *priv, u32 mask)\r\n{\r\nwhile (priv->read_reg32(priv, C_CAN_FUNCTION_REG) & mask)\r\nudelay(1);\r\n}\r\nstatic void c_can_hw_raminit(const struct c_can_priv *priv, bool enable)\r\n{\r\nu32 ctrl;\r\nctrl = priv->read_reg32(priv, C_CAN_FUNCTION_REG);\r\nctrl &= ~DCAN_RAM_INIT_BIT;\r\npriv->write_reg32(priv, C_CAN_FUNCTION_REG, ctrl);\r\nc_can_hw_raminit_wait(priv, ctrl);\r\nif (enable) {\r\nctrl |= DCAN_RAM_INIT_BIT;\r\npriv->write_reg32(priv, C_CAN_FUNCTION_REG, ctrl);\r\nc_can_hw_raminit_wait(priv, ctrl);\r\n}\r\n}\r\nstatic int c_can_plat_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nvoid __iomem *addr;\r\nstruct net_device *dev;\r\nstruct c_can_priv *priv;\r\nconst struct of_device_id *match;\r\nconst struct platform_device_id *id;\r\nstruct resource *mem, *res;\r\nint irq;\r\nstruct clk *clk;\r\nif (pdev->dev.of_node) {\r\nmatch = of_match_device(c_can_of_table, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Failed to find matching dt id\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nid = match->data;\r\n} else {\r\nid = platform_get_device_id(pdev);\r\n}\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto exit;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naddr = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(addr)) {\r\nret = PTR_ERR(addr);\r\ngoto exit;\r\n}\r\ndev = alloc_c_can_dev();\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\npriv = netdev_priv(dev);\r\nswitch (id->driver_data) {\r\ncase BOSCH_C_CAN:\r\npriv->regs = reg_map_c_can;\r\nswitch (mem->flags & IORESOURCE_MEM_TYPE_MASK) {\r\ncase IORESOURCE_MEM_32BIT:\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_32bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_32bit;\r\npriv->read_reg32 = c_can_plat_read_reg32;\r\npriv->write_reg32 = c_can_plat_write_reg32;\r\nbreak;\r\ncase IORESOURCE_MEM_16BIT:\r\ndefault:\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\r\npriv->read_reg32 = c_can_plat_read_reg32;\r\npriv->write_reg32 = c_can_plat_write_reg32;\r\nbreak;\r\n}\r\nbreak;\r\ncase BOSCH_D_CAN:\r\npriv->regs = reg_map_d_can;\r\npriv->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\r\npriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\r\npriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\r\npriv->read_reg32 = d_can_plat_read_reg32;\r\npriv->write_reg32 = d_can_plat_write_reg32;\r\nif (pdev->dev.of_node)\r\npriv->instance = of_alias_get_id(pdev->dev.of_node, "d_can");\r\nelse\r\npriv->instance = pdev->id;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\npriv->raminit = c_can_hw_raminit;\r\nbreak;\r\n}\r\npriv->raminit_ctrlreg = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!priv->raminit_ctrlreg || priv->instance < 0)\r\ndev_info(&pdev->dev, "control memory is not used for raminit\n");\r\nelse\r\npriv->raminit = c_can_hw_raminit_ti;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto exit_free_device;\r\n}\r\ndev->irq = irq;\r\npriv->base = addr;\r\npriv->device = &pdev->dev;\r\npriv->can.clock.freq = clk_get_rate(clk);\r\npriv->priv = clk;\r\npriv->type = id->driver_data;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nret = register_c_can_dev(dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nKBUILD_MODNAME, ret);\r\ngoto exit_free_device;\r\n}\r\ndev_info(&pdev->dev, "%s device registered (regs=%p, irq=%d)\n",\r\nKBUILD_MODNAME, priv->base, dev->irq);\r\nreturn 0;\r\nexit_free_device:\r\nfree_c_can_dev(dev);\r\nexit:\r\ndev_err(&pdev->dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int c_can_plat_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nunregister_c_can_dev(dev);\r\nfree_c_can_dev(dev);\r\nreturn 0;\r\n}\r\nstatic int c_can_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nint ret;\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct c_can_priv *priv = netdev_priv(ndev);\r\nif (priv->type != BOSCH_D_CAN) {\r\ndev_warn(&pdev->dev, "Not supported\n");\r\nreturn 0;\r\n}\r\nif (netif_running(ndev)) {\r\nnetif_stop_queue(ndev);\r\nnetif_device_detach(ndev);\r\n}\r\nret = c_can_power_down(ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "failed to enter power down mode\n");\r\nreturn ret;\r\n}\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nreturn 0;\r\n}\r\nstatic int c_can_resume(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct c_can_priv *priv = netdev_priv(ndev);\r\nif (priv->type != BOSCH_D_CAN) {\r\ndev_warn(&pdev->dev, "Not supported\n");\r\nreturn 0;\r\n}\r\nret = c_can_power_up(ndev);\r\nif (ret) {\r\nnetdev_err(ndev, "Still in power down mode\n");\r\nreturn ret;\r\n}\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_running(ndev)) {\r\nnetif_device_attach(ndev);\r\nnetif_start_queue(ndev);\r\n}\r\nreturn 0;\r\n}
