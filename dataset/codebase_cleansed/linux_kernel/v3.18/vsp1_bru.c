static inline u32 vsp1_bru_read(struct vsp1_bru *bru, u32 reg)\r\n{\r\nreturn vsp1_read(bru->entity.vsp1, reg);\r\n}\r\nstatic inline void vsp1_bru_write(struct vsp1_bru *bru, u32 reg, u32 data)\r\n{\r\nvsp1_write(bru->entity.vsp1, reg, data);\r\n}\r\nstatic int bru_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vsp1_bru *bru =\r\ncontainer_of(ctrl->handler, struct vsp1_bru, ctrls);\r\nif (!vsp1_entity_is_streaming(&bru->entity))\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BG_COLOR:\r\nvsp1_bru_write(bru, VI6_BRU_VIRRPF_COL, ctrl->val |\r\n(0xff << VI6_BRU_VIRRPF_COL_A_SHIFT));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bru_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nstruct vsp1_pipeline *pipe = to_vsp1_pipeline(&subdev->entity);\r\nstruct vsp1_bru *bru = to_bru(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nunsigned int flags;\r\nunsigned int i;\r\nint ret;\r\nret = vsp1_entity_set_streaming(&bru->entity, enable);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!enable)\r\nreturn 0;\r\nformat = &bru->entity.formats[BRU_PAD_SOURCE];\r\nflags = pipe->output ? pipe->output->video.format.flags : 0;\r\nvsp1_bru_write(bru, VI6_BRU_INCTRL,\r\nflags & V4L2_PIX_FMT_FLAG_PREMUL_ALPHA ?\r\n0 : VI6_BRU_INCTRL_NRM);\r\nvsp1_bru_write(bru, VI6_BRU_VIRRPF_SIZE,\r\n(format->width << VI6_BRU_VIRRPF_SIZE_HSIZE_SHIFT) |\r\n(format->height << VI6_BRU_VIRRPF_SIZE_VSIZE_SHIFT));\r\nvsp1_bru_write(bru, VI6_BRU_VIRRPF_LOC, 0);\r\nvsp1_bru_write(bru, VI6_BRU_ROP, VI6_BRU_ROP_DSTSEL_BRUIN(1) |\r\nVI6_BRU_ROP_CROP(VI6_ROP_NOP) |\r\nVI6_BRU_ROP_AROP(VI6_ROP_NOP));\r\nfor (i = 0; i < 4; ++i) {\r\nbool premultiplied = false;\r\nu32 ctrl = 0;\r\nif (bru->inputs[i].rpf) {\r\nctrl |= VI6_BRU_CTRL_RBC;\r\npremultiplied = bru->inputs[i].rpf->video.format.flags\r\n& V4L2_PIX_FMT_FLAG_PREMUL_ALPHA;\r\n} else {\r\nctrl |= VI6_BRU_CTRL_CROP(VI6_ROP_NOP)\r\n| VI6_BRU_CTRL_AROP(VI6_ROP_NOP);\r\n}\r\nif (i == 0)\r\nctrl |= VI6_BRU_CTRL_DSTSEL_VRPF;\r\nif (i != 1)\r\nctrl |= VI6_BRU_CTRL_SRCSEL_BRUIN(i);\r\nvsp1_bru_write(bru, VI6_BRU_CTRL(i), ctrl);\r\nvsp1_bru_write(bru, VI6_BRU_BLD(i),\r\nVI6_BRU_BLD_CCMDX_255_SRC_A |\r\n(premultiplied ? VI6_BRU_BLD_CCMDY_COEFY :\r\nVI6_BRU_BLD_CCMDY_SRC_A) |\r\nVI6_BRU_BLD_ACMDX_255_SRC_A |\r\nVI6_BRU_BLD_ACMDY_COEFY |\r\n(0xff << VI6_BRU_BLD_COEFY_SHIFT));\r\n}\r\nreturn 0;\r\n}\r\nstatic int bru_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstatic const unsigned int codes[] = {\r\nV4L2_MBUS_FMT_ARGB8888_1X32,\r\nV4L2_MBUS_FMT_AYUV8_1X32,\r\n};\r\nstruct v4l2_mbus_framefmt *format;\r\nif (code->pad == BRU_PAD_SINK(0)) {\r\nif (code->index >= ARRAY_SIZE(codes))\r\nreturn -EINVAL;\r\ncode->code = codes[code->index];\r\n} else {\r\nif (code->index)\r\nreturn -EINVAL;\r\nformat = v4l2_subdev_get_try_format(fh, BRU_PAD_SINK(0));\r\ncode->code = format->code;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bru_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nif (fse->index)\r\nreturn -EINVAL;\r\nif (fse->code != V4L2_MBUS_FMT_ARGB8888_1X32 &&\r\nfse->code != V4L2_MBUS_FMT_AYUV8_1X32)\r\nreturn -EINVAL;\r\nfse->min_width = BRU_MIN_SIZE;\r\nfse->max_width = BRU_MAX_SIZE;\r\nfse->min_height = BRU_MIN_SIZE;\r\nfse->max_height = BRU_MAX_SIZE;\r\nreturn 0;\r\n}\r\nstatic struct v4l2_rect *bru_get_compose(struct vsp1_bru *bru,\r\nstruct v4l2_subdev_fh *fh,\r\nunsigned int pad, u32 which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_crop(fh, pad);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &bru->inputs[pad].compose;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int bru_get_format(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_bru *bru = to_bru(subdev);\r\nfmt->format = *vsp1_entity_get_pad_format(&bru->entity, fh, fmt->pad,\r\nfmt->which);\r\nreturn 0;\r\n}\r\nstatic void bru_try_format(struct vsp1_bru *bru, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, struct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nswitch (pad) {\r\ncase BRU_PAD_SINK(0):\r\nif (fmt->code != V4L2_MBUS_FMT_ARGB8888_1X32 &&\r\nfmt->code != V4L2_MBUS_FMT_AYUV8_1X32)\r\nfmt->code = V4L2_MBUS_FMT_AYUV8_1X32;\r\nbreak;\r\ndefault:\r\nformat = vsp1_entity_get_pad_format(&bru->entity, fh,\r\nBRU_PAD_SINK(0), which);\r\nfmt->code = format->code;\r\nbreak;\r\n}\r\nfmt->width = clamp(fmt->width, BRU_MIN_SIZE, BRU_MAX_SIZE);\r\nfmt->height = clamp(fmt->height, BRU_MIN_SIZE, BRU_MAX_SIZE);\r\nfmt->field = V4L2_FIELD_NONE;\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\n}\r\nstatic int bru_set_format(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_bru *bru = to_bru(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nbru_try_format(bru, fh, fmt->pad, &fmt->format, fmt->which);\r\nformat = vsp1_entity_get_pad_format(&bru->entity, fh, fmt->pad,\r\nfmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad != BRU_PAD_SOURCE) {\r\nstruct v4l2_rect *compose;\r\ncompose = bru_get_compose(bru, fh, fmt->pad, fmt->which);\r\ncompose->left = 0;\r\ncompose->top = 0;\r\ncompose->width = format->width;\r\ncompose->height = format->height;\r\n}\r\nif (fmt->pad == BRU_PAD_SINK(0)) {\r\nunsigned int i;\r\nfor (i = 0; i <= BRU_PAD_SOURCE; ++i) {\r\nformat = vsp1_entity_get_pad_format(&bru->entity, fh,\r\ni, fmt->which);\r\nformat->code = fmt->format.code;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bru_get_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct vsp1_bru *bru = to_bru(subdev);\r\nif (sel->pad == BRU_PAD_SOURCE)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = BRU_MAX_SIZE;\r\nsel->r.height = BRU_MAX_SIZE;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nsel->r = *bru_get_compose(bru, fh, sel->pad, sel->which);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int bru_set_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct vsp1_bru *bru = to_bru(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *compose;\r\nif (sel->pad == BRU_PAD_SOURCE)\r\nreturn -EINVAL;\r\nif (sel->target != V4L2_SEL_TGT_COMPOSE)\r\nreturn -EINVAL;\r\nformat = vsp1_entity_get_pad_format(&bru->entity, fh, BRU_PAD_SOURCE,\r\nsel->which);\r\nsel->r.left = clamp_t(unsigned int, sel->r.left, 0, format->width - 1);\r\nsel->r.top = clamp_t(unsigned int, sel->r.top, 0, format->height - 1);\r\nformat = vsp1_entity_get_pad_format(&bru->entity, fh, sel->pad,\r\nsel->which);\r\nsel->r.width = format->width;\r\nsel->r.height = format->height;\r\ncompose = bru_get_compose(bru, fh, sel->pad, sel->which);\r\n*compose = sel->r;\r\nreturn 0;\r\n}\r\nstruct vsp1_bru *vsp1_bru_create(struct vsp1_device *vsp1)\r\n{\r\nstruct v4l2_subdev *subdev;\r\nstruct vsp1_bru *bru;\r\nint ret;\r\nbru = devm_kzalloc(vsp1->dev, sizeof(*bru), GFP_KERNEL);\r\nif (bru == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nbru->entity.type = VSP1_ENTITY_BRU;\r\nret = vsp1_entity_init(vsp1, &bru->entity, 5);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nsubdev = &bru->entity.subdev;\r\nv4l2_subdev_init(subdev, &bru_ops);\r\nsubdev->entity.ops = &vsp1_media_ops;\r\nsubdev->internal_ops = &vsp1_subdev_internal_ops;\r\nsnprintf(subdev->name, sizeof(subdev->name), "%s bru",\r\ndev_name(vsp1->dev));\r\nv4l2_set_subdevdata(subdev, bru);\r\nsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nvsp1_entity_init_formats(subdev, NULL);\r\nv4l2_ctrl_handler_init(&bru->ctrls, 1);\r\nv4l2_ctrl_new_std(&bru->ctrls, &bru_ctrl_ops, V4L2_CID_BG_COLOR,\r\n0, 0xffffff, 1, 0);\r\nbru->entity.subdev.ctrl_handler = &bru->ctrls;\r\nif (bru->ctrls.error) {\r\ndev_err(vsp1->dev, "bru: failed to initialize controls\n");\r\nret = bru->ctrls.error;\r\nvsp1_entity_destroy(&bru->entity);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn bru;\r\n}
