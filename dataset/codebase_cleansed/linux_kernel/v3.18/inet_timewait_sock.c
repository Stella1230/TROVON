int inet_twsk_unhash(struct inet_timewait_sock *tw)\r\n{\r\nif (hlist_nulls_unhashed(&tw->tw_node))\r\nreturn 0;\r\nhlist_nulls_del_rcu(&tw->tw_node);\r\nsk_nulls_node_init(&tw->tw_node);\r\nreturn 1;\r\n}\r\nint inet_twsk_bind_unhash(struct inet_timewait_sock *tw,\r\nstruct inet_hashinfo *hashinfo)\r\n{\r\nstruct inet_bind_bucket *tb = tw->tw_tb;\r\nif (!tb)\r\nreturn 0;\r\n__hlist_del(&tw->tw_bind_node);\r\ntw->tw_tb = NULL;\r\ninet_bind_bucket_destroy(hashinfo->bind_bucket_cachep, tb);\r\nreturn 1;\r\n}\r\nstatic void __inet_twsk_kill(struct inet_timewait_sock *tw,\r\nstruct inet_hashinfo *hashinfo)\r\n{\r\nstruct inet_bind_hashbucket *bhead;\r\nint refcnt;\r\nspinlock_t *lock = inet_ehash_lockp(hashinfo, tw->tw_hash);\r\nspin_lock(lock);\r\nrefcnt = inet_twsk_unhash(tw);\r\nspin_unlock(lock);\r\nbhead = &hashinfo->bhash[inet_bhashfn(twsk_net(tw), tw->tw_num,\r\nhashinfo->bhash_size)];\r\nspin_lock(&bhead->lock);\r\nrefcnt += inet_twsk_bind_unhash(tw, hashinfo);\r\nspin_unlock(&bhead->lock);\r\nBUG_ON(refcnt >= atomic_read(&tw->tw_refcnt));\r\natomic_sub(refcnt, &tw->tw_refcnt);\r\n}\r\nvoid inet_twsk_free(struct inet_timewait_sock *tw)\r\n{\r\nstruct module *owner = tw->tw_prot->owner;\r\ntwsk_destructor((struct sock *)tw);\r\n#ifdef SOCK_REFCNT_DEBUG\r\npr_debug("%s timewait_sock %p released\n", tw->tw_prot->name, tw);\r\n#endif\r\nrelease_net(twsk_net(tw));\r\nkmem_cache_free(tw->tw_prot->twsk_prot->twsk_slab, tw);\r\nmodule_put(owner);\r\n}\r\nvoid inet_twsk_put(struct inet_timewait_sock *tw)\r\n{\r\nif (atomic_dec_and_test(&tw->tw_refcnt))\r\ninet_twsk_free(tw);\r\n}\r\nstatic void inet_twsk_add_node_rcu(struct inet_timewait_sock *tw,\r\nstruct hlist_nulls_head *list)\r\n{\r\nhlist_nulls_add_head_rcu(&tw->tw_node, list);\r\n}\r\nstatic void inet_twsk_add_bind_node(struct inet_timewait_sock *tw,\r\nstruct hlist_head *list)\r\n{\r\nhlist_add_head(&tw->tw_bind_node, list);\r\n}\r\nvoid __inet_twsk_hashdance(struct inet_timewait_sock *tw, struct sock *sk,\r\nstruct inet_hashinfo *hashinfo)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nconst struct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct inet_ehash_bucket *ehead = inet_ehash_bucket(hashinfo, sk->sk_hash);\r\nspinlock_t *lock = inet_ehash_lockp(hashinfo, sk->sk_hash);\r\nstruct inet_bind_hashbucket *bhead;\r\nbhead = &hashinfo->bhash[inet_bhashfn(twsk_net(tw), inet->inet_num,\r\nhashinfo->bhash_size)];\r\nspin_lock(&bhead->lock);\r\ntw->tw_tb = icsk->icsk_bind_hash;\r\nWARN_ON(!icsk->icsk_bind_hash);\r\ninet_twsk_add_bind_node(tw, &tw->tw_tb->owners);\r\nspin_unlock(&bhead->lock);\r\nspin_lock(lock);\r\natomic_set(&tw->tw_refcnt, 1 + 1 + 1);\r\ninet_twsk_add_node_rcu(tw, &ehead->chain);\r\nif (__sk_nulls_del_node_init_rcu(sk))\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\r\nspin_unlock(lock);\r\n}\r\nstruct inet_timewait_sock *inet_twsk_alloc(const struct sock *sk, const int state)\r\n{\r\nstruct inet_timewait_sock *tw =\r\nkmem_cache_alloc(sk->sk_prot_creator->twsk_prot->twsk_slab,\r\nGFP_ATOMIC);\r\nif (tw != NULL) {\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nkmemcheck_annotate_bitfield(tw, flags);\r\ntw->tw_daddr = inet->inet_daddr;\r\ntw->tw_rcv_saddr = inet->inet_rcv_saddr;\r\ntw->tw_bound_dev_if = sk->sk_bound_dev_if;\r\ntw->tw_tos = inet->tos;\r\ntw->tw_num = inet->inet_num;\r\ntw->tw_state = TCP_TIME_WAIT;\r\ntw->tw_substate = state;\r\ntw->tw_sport = inet->inet_sport;\r\ntw->tw_dport = inet->inet_dport;\r\ntw->tw_family = sk->sk_family;\r\ntw->tw_reuse = sk->sk_reuse;\r\ntw->tw_hash = sk->sk_hash;\r\ntw->tw_ipv6only = 0;\r\ntw->tw_transparent = inet->transparent;\r\ntw->tw_prot = sk->sk_prot_creator;\r\ntwsk_net_set(tw, hold_net(sock_net(sk)));\r\natomic_set(&tw->tw_refcnt, 0);\r\ninet_twsk_dead_node_init(tw);\r\n__module_get(tw->tw_prot->owner);\r\n}\r\nreturn tw;\r\n}\r\nstatic int inet_twdr_do_twkill_work(struct inet_timewait_death_row *twdr,\r\nconst int slot)\r\n{\r\nstruct inet_timewait_sock *tw;\r\nunsigned int killed;\r\nint ret;\r\nkilled = 0;\r\nret = 0;\r\nrescan:\r\ninet_twsk_for_each_inmate(tw, &twdr->cells[slot]) {\r\n__inet_twsk_del_dead_node(tw);\r\nspin_unlock(&twdr->death_lock);\r\n__inet_twsk_kill(tw, twdr->hashinfo);\r\n#ifdef CONFIG_NET_NS\r\nNET_INC_STATS_BH(twsk_net(tw), LINUX_MIB_TIMEWAITED);\r\n#endif\r\ninet_twsk_put(tw);\r\nkilled++;\r\nspin_lock(&twdr->death_lock);\r\nif (killed > INET_TWDR_TWKILL_QUOTA) {\r\nret = 1;\r\nbreak;\r\n}\r\ngoto rescan;\r\n}\r\ntwdr->tw_count -= killed;\r\n#ifndef CONFIG_NET_NS\r\nNET_ADD_STATS_BH(&init_net, LINUX_MIB_TIMEWAITED, killed);\r\n#endif\r\nreturn ret;\r\n}\r\nvoid inet_twdr_hangman(unsigned long data)\r\n{\r\nstruct inet_timewait_death_row *twdr;\r\nunsigned int need_timer;\r\ntwdr = (struct inet_timewait_death_row *)data;\r\nspin_lock(&twdr->death_lock);\r\nif (twdr->tw_count == 0)\r\ngoto out;\r\nneed_timer = 0;\r\nif (inet_twdr_do_twkill_work(twdr, twdr->slot)) {\r\ntwdr->thread_slots |= (1 << twdr->slot);\r\nschedule_work(&twdr->twkill_work);\r\nneed_timer = 1;\r\n} else {\r\nif (twdr->tw_count)\r\nneed_timer = 1;\r\ntwdr->slot = ((twdr->slot + 1) & (INET_TWDR_TWKILL_SLOTS - 1));\r\n}\r\nif (need_timer)\r\nmod_timer(&twdr->tw_timer, jiffies + twdr->period);\r\nout:\r\nspin_unlock(&twdr->death_lock);\r\n}\r\nvoid inet_twdr_twkill_work(struct work_struct *work)\r\n{\r\nstruct inet_timewait_death_row *twdr =\r\ncontainer_of(work, struct inet_timewait_death_row, twkill_work);\r\nint i;\r\nBUILD_BUG_ON((INET_TWDR_TWKILL_SLOTS - 1) >\r\n(sizeof(twdr->thread_slots) * 8));\r\nwhile (twdr->thread_slots) {\r\nspin_lock_bh(&twdr->death_lock);\r\nfor (i = 0; i < INET_TWDR_TWKILL_SLOTS; i++) {\r\nif (!(twdr->thread_slots & (1 << i)))\r\ncontinue;\r\nwhile (inet_twdr_do_twkill_work(twdr, i) != 0) {\r\nif (need_resched()) {\r\nspin_unlock_bh(&twdr->death_lock);\r\nschedule();\r\nspin_lock_bh(&twdr->death_lock);\r\n}\r\n}\r\ntwdr->thread_slots &= ~(1 << i);\r\n}\r\nspin_unlock_bh(&twdr->death_lock);\r\n}\r\n}\r\nvoid inet_twsk_deschedule(struct inet_timewait_sock *tw,\r\nstruct inet_timewait_death_row *twdr)\r\n{\r\nspin_lock(&twdr->death_lock);\r\nif (inet_twsk_del_dead_node(tw)) {\r\ninet_twsk_put(tw);\r\nif (--twdr->tw_count == 0)\r\ndel_timer(&twdr->tw_timer);\r\n}\r\nspin_unlock(&twdr->death_lock);\r\n__inet_twsk_kill(tw, twdr->hashinfo);\r\n}\r\nvoid inet_twsk_schedule(struct inet_timewait_sock *tw,\r\nstruct inet_timewait_death_row *twdr,\r\nconst int timeo, const int timewait_len)\r\n{\r\nstruct hlist_head *list;\r\nint slot;\r\nslot = (timeo + (1 << INET_TWDR_RECYCLE_TICK) - 1) >> INET_TWDR_RECYCLE_TICK;\r\nspin_lock(&twdr->death_lock);\r\nif (inet_twsk_del_dead_node(tw))\r\ntwdr->tw_count--;\r\nelse\r\natomic_inc(&tw->tw_refcnt);\r\nif (slot >= INET_TWDR_RECYCLE_SLOTS) {\r\nif (timeo >= timewait_len) {\r\nslot = INET_TWDR_TWKILL_SLOTS - 1;\r\n} else {\r\nslot = DIV_ROUND_UP(timeo, twdr->period);\r\nif (slot >= INET_TWDR_TWKILL_SLOTS)\r\nslot = INET_TWDR_TWKILL_SLOTS - 1;\r\n}\r\ntw->tw_ttd = inet_tw_time_stamp() + timeo;\r\nslot = (twdr->slot + slot) & (INET_TWDR_TWKILL_SLOTS - 1);\r\nlist = &twdr->cells[slot];\r\n} else {\r\ntw->tw_ttd = inet_tw_time_stamp() + (slot << INET_TWDR_RECYCLE_TICK);\r\nif (twdr->twcal_hand < 0) {\r\ntwdr->twcal_hand = 0;\r\ntwdr->twcal_jiffie = jiffies;\r\ntwdr->twcal_timer.expires = twdr->twcal_jiffie +\r\n(slot << INET_TWDR_RECYCLE_TICK);\r\nadd_timer(&twdr->twcal_timer);\r\n} else {\r\nif (time_after(twdr->twcal_timer.expires,\r\njiffies + (slot << INET_TWDR_RECYCLE_TICK)))\r\nmod_timer(&twdr->twcal_timer,\r\njiffies + (slot << INET_TWDR_RECYCLE_TICK));\r\nslot = (twdr->twcal_hand + slot) & (INET_TWDR_RECYCLE_SLOTS - 1);\r\n}\r\nlist = &twdr->twcal_row[slot];\r\n}\r\nhlist_add_head(&tw->tw_death_node, list);\r\nif (twdr->tw_count++ == 0)\r\nmod_timer(&twdr->tw_timer, jiffies + twdr->period);\r\nspin_unlock(&twdr->death_lock);\r\n}\r\nvoid inet_twdr_twcal_tick(unsigned long data)\r\n{\r\nstruct inet_timewait_death_row *twdr;\r\nint n, slot;\r\nunsigned long j;\r\nunsigned long now = jiffies;\r\nint killed = 0;\r\nint adv = 0;\r\ntwdr = (struct inet_timewait_death_row *)data;\r\nspin_lock(&twdr->death_lock);\r\nif (twdr->twcal_hand < 0)\r\ngoto out;\r\nslot = twdr->twcal_hand;\r\nj = twdr->twcal_jiffie;\r\nfor (n = 0; n < INET_TWDR_RECYCLE_SLOTS; n++) {\r\nif (time_before_eq(j, now)) {\r\nstruct hlist_node *safe;\r\nstruct inet_timewait_sock *tw;\r\ninet_twsk_for_each_inmate_safe(tw, safe,\r\n&twdr->twcal_row[slot]) {\r\n__inet_twsk_del_dead_node(tw);\r\n__inet_twsk_kill(tw, twdr->hashinfo);\r\n#ifdef CONFIG_NET_NS\r\nNET_INC_STATS_BH(twsk_net(tw), LINUX_MIB_TIMEWAITKILLED);\r\n#endif\r\ninet_twsk_put(tw);\r\nkilled++;\r\n}\r\n} else {\r\nif (!adv) {\r\nadv = 1;\r\ntwdr->twcal_jiffie = j;\r\ntwdr->twcal_hand = slot;\r\n}\r\nif (!hlist_empty(&twdr->twcal_row[slot])) {\r\nmod_timer(&twdr->twcal_timer, j);\r\ngoto out;\r\n}\r\n}\r\nj += 1 << INET_TWDR_RECYCLE_TICK;\r\nslot = (slot + 1) & (INET_TWDR_RECYCLE_SLOTS - 1);\r\n}\r\ntwdr->twcal_hand = -1;\r\nout:\r\nif ((twdr->tw_count -= killed) == 0)\r\ndel_timer(&twdr->tw_timer);\r\n#ifndef CONFIG_NET_NS\r\nNET_ADD_STATS_BH(&init_net, LINUX_MIB_TIMEWAITKILLED, killed);\r\n#endif\r\nspin_unlock(&twdr->death_lock);\r\n}\r\nvoid inet_twsk_purge(struct inet_hashinfo *hashinfo,\r\nstruct inet_timewait_death_row *twdr, int family)\r\n{\r\nstruct inet_timewait_sock *tw;\r\nstruct sock *sk;\r\nstruct hlist_nulls_node *node;\r\nunsigned int slot;\r\nfor (slot = 0; slot <= hashinfo->ehash_mask; slot++) {\r\nstruct inet_ehash_bucket *head = &hashinfo->ehash[slot];\r\nrestart_rcu:\r\nrcu_read_lock();\r\nrestart:\r\nsk_nulls_for_each_rcu(sk, node, &head->chain) {\r\nif (sk->sk_state != TCP_TIME_WAIT)\r\ncontinue;\r\ntw = inet_twsk(sk);\r\nif ((tw->tw_family != family) ||\r\natomic_read(&twsk_net(tw)->count))\r\ncontinue;\r\nif (unlikely(!atomic_inc_not_zero(&tw->tw_refcnt)))\r\ncontinue;\r\nif (unlikely((tw->tw_family != family) ||\r\natomic_read(&twsk_net(tw)->count))) {\r\ninet_twsk_put(tw);\r\ngoto restart;\r\n}\r\nrcu_read_unlock();\r\nlocal_bh_disable();\r\ninet_twsk_deschedule(tw, twdr);\r\nlocal_bh_enable();\r\ninet_twsk_put(tw);\r\ngoto restart_rcu;\r\n}\r\nif (get_nulls_value(node) != slot)\r\ngoto restart;\r\nrcu_read_unlock();\r\n}\r\n}
