static int rxkad_init_connection_security(struct rxrpc_connection *conn)\r\n{\r\nstruct crypto_blkcipher *ci;\r\nstruct rxrpc_key_token *token;\r\nint ret;\r\n_enter("{%d},{%x}", conn->debug_id, key_serial(conn->key));\r\ntoken = conn->key->payload.data;\r\nconn->security_ix = token->security_index;\r\nci = crypto_alloc_blkcipher("pcbc(fcrypt)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(ci)) {\r\n_debug("no cipher");\r\nret = PTR_ERR(ci);\r\ngoto error;\r\n}\r\nif (crypto_blkcipher_setkey(ci, token->kad->session_key,\r\nsizeof(token->kad->session_key)) < 0)\r\nBUG();\r\nswitch (conn->security_level) {\r\ncase RXRPC_SECURITY_PLAIN:\r\nbreak;\r\ncase RXRPC_SECURITY_AUTH:\r\nconn->size_align = 8;\r\nconn->security_size = sizeof(struct rxkad_level1_hdr);\r\nconn->header_size += sizeof(struct rxkad_level1_hdr);\r\nbreak;\r\ncase RXRPC_SECURITY_ENCRYPT:\r\nconn->size_align = 8;\r\nconn->security_size = sizeof(struct rxkad_level2_hdr);\r\nconn->header_size += sizeof(struct rxkad_level2_hdr);\r\nbreak;\r\ndefault:\r\nret = -EKEYREJECTED;\r\ngoto error;\r\n}\r\nconn->cipher = ci;\r\nret = 0;\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic void rxkad_prime_packet_security(struct rxrpc_connection *conn)\r\n{\r\nstruct rxrpc_key_token *token;\r\nstruct blkcipher_desc desc;\r\nstruct scatterlist sg[2];\r\nstruct rxrpc_crypt iv;\r\nstruct {\r\n__be32 x[4];\r\n} tmpbuf __attribute__((aligned(16)));\r\n_enter("");\r\nif (!conn->key)\r\nreturn;\r\ntoken = conn->key->payload.data;\r\nmemcpy(&iv, token->kad->session_key, sizeof(iv));\r\ndesc.tfm = conn->cipher;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\ntmpbuf.x[0] = conn->epoch;\r\ntmpbuf.x[1] = conn->cid;\r\ntmpbuf.x[2] = 0;\r\ntmpbuf.x[3] = htonl(conn->security_ix);\r\nsg_init_one(&sg[0], &tmpbuf, sizeof(tmpbuf));\r\nsg_init_one(&sg[1], &tmpbuf, sizeof(tmpbuf));\r\ncrypto_blkcipher_encrypt_iv(&desc, &sg[0], &sg[1], sizeof(tmpbuf));\r\nmemcpy(&conn->csum_iv, &tmpbuf.x[2], sizeof(conn->csum_iv));\r\nASSERTCMP(conn->csum_iv.n[0], ==, tmpbuf.x[2]);\r\n_leave("");\r\n}\r\nstatic int rxkad_secure_packet_auth(const struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nu32 data_size,\r\nvoid *sechdr)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nstruct blkcipher_desc desc;\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[2];\r\nstruct {\r\nstruct rxkad_level1_hdr hdr;\r\n__be32 first;\r\n} tmpbuf __attribute__((aligned(8)));\r\nu16 check;\r\nsp = rxrpc_skb(skb);\r\n_enter("");\r\ncheck = ntohl(sp->hdr.seq ^ sp->hdr.callNumber);\r\ndata_size |= (u32) check << 16;\r\ntmpbuf.hdr.data_size = htonl(data_size);\r\nmemcpy(&tmpbuf.first, sechdr + 4, sizeof(tmpbuf.first));\r\nmemset(&iv, 0, sizeof(iv));\r\ndesc.tfm = call->conn->cipher;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\nsg_init_one(&sg[0], &tmpbuf, sizeof(tmpbuf));\r\nsg_init_one(&sg[1], &tmpbuf, sizeof(tmpbuf));\r\ncrypto_blkcipher_encrypt_iv(&desc, &sg[0], &sg[1], sizeof(tmpbuf));\r\nmemcpy(sechdr, &tmpbuf, sizeof(tmpbuf));\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxkad_secure_packet_encrypt(const struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nu32 data_size,\r\nvoid *sechdr)\r\n{\r\nconst struct rxrpc_key_token *token;\r\nstruct rxkad_level2_hdr rxkhdr\r\n__attribute__((aligned(8)));\r\nstruct rxrpc_skb_priv *sp;\r\nstruct blkcipher_desc desc;\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[16];\r\nstruct sk_buff *trailer;\r\nunsigned int len;\r\nu16 check;\r\nint nsg;\r\nsp = rxrpc_skb(skb);\r\n_enter("");\r\ncheck = ntohl(sp->hdr.seq ^ sp->hdr.callNumber);\r\nrxkhdr.data_size = htonl(data_size | (u32) check << 16);\r\nrxkhdr.checksum = 0;\r\ntoken = call->conn->key->payload.data;\r\nmemcpy(&iv, token->kad->session_key, sizeof(iv));\r\ndesc.tfm = call->conn->cipher;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\nsg_init_one(&sg[0], sechdr, sizeof(rxkhdr));\r\nsg_init_one(&sg[1], &rxkhdr, sizeof(rxkhdr));\r\ncrypto_blkcipher_encrypt_iv(&desc, &sg[0], &sg[1], sizeof(rxkhdr));\r\nnsg = skb_cow_data(skb, 0, &trailer);\r\nif (nsg < 0 || nsg > 16)\r\nreturn -ENOMEM;\r\nlen = data_size + call->conn->size_align - 1;\r\nlen &= ~(call->conn->size_align - 1);\r\nsg_init_table(sg, nsg);\r\nskb_to_sgvec(skb, sg, 0, len);\r\ncrypto_blkcipher_encrypt_iv(&desc, sg, sg, len);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxkad_secure_packet(const struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nsize_t data_size,\r\nvoid *sechdr)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nstruct blkcipher_desc desc;\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[2];\r\nstruct {\r\n__be32 x[2];\r\n} tmpbuf __attribute__((aligned(8)));\r\n__be32 x;\r\nu32 y;\r\nint ret;\r\nsp = rxrpc_skb(skb);\r\n_enter("{%d{%x}},{#%u},%zu,",\r\ncall->debug_id, key_serial(call->conn->key), ntohl(sp->hdr.seq),\r\ndata_size);\r\nif (!call->conn->cipher)\r\nreturn 0;\r\nret = key_validate(call->conn->key);\r\nif (ret < 0)\r\nreturn ret;\r\nmemcpy(&iv, call->conn->csum_iv.x, sizeof(iv));\r\ndesc.tfm = call->conn->cipher;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\nx = htonl(call->channel << (32 - RXRPC_CIDSHIFT));\r\nx |= sp->hdr.seq & cpu_to_be32(0x3fffffff);\r\ntmpbuf.x[0] = sp->hdr.callNumber;\r\ntmpbuf.x[1] = x;\r\nsg_init_one(&sg[0], &tmpbuf, sizeof(tmpbuf));\r\nsg_init_one(&sg[1], &tmpbuf, sizeof(tmpbuf));\r\ncrypto_blkcipher_encrypt_iv(&desc, &sg[0], &sg[1], sizeof(tmpbuf));\r\ny = ntohl(tmpbuf.x[1]);\r\ny = (y >> 16) & 0xffff;\r\nif (y == 0)\r\ny = 1;\r\nsp->hdr.cksum = htons(y);\r\nswitch (call->conn->security_level) {\r\ncase RXRPC_SECURITY_PLAIN:\r\nret = 0;\r\nbreak;\r\ncase RXRPC_SECURITY_AUTH:\r\nret = rxkad_secure_packet_auth(call, skb, data_size, sechdr);\r\nbreak;\r\ncase RXRPC_SECURITY_ENCRYPT:\r\nret = rxkad_secure_packet_encrypt(call, skb, data_size,\r\nsechdr);\r\nbreak;\r\ndefault:\r\nret = -EPERM;\r\nbreak;\r\n}\r\n_leave(" = %d [set %hx]", ret, y);\r\nreturn ret;\r\n}\r\nstatic int rxkad_verify_packet_auth(const struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nstruct rxkad_level1_hdr sechdr;\r\nstruct rxrpc_skb_priv *sp;\r\nstruct blkcipher_desc desc;\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[16];\r\nstruct sk_buff *trailer;\r\nu32 data_size, buf;\r\nu16 check;\r\nint nsg;\r\n_enter("");\r\nsp = rxrpc_skb(skb);\r\nnsg = skb_cow_data(skb, 0, &trailer);\r\nif (nsg < 0 || nsg > 16)\r\ngoto nomem;\r\nsg_init_table(sg, nsg);\r\nskb_to_sgvec(skb, sg, 0, 8);\r\nmemset(&iv, 0, sizeof(iv));\r\ndesc.tfm = call->conn->cipher;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\ncrypto_blkcipher_decrypt_iv(&desc, sg, sg, 8);\r\nif (skb_copy_bits(skb, 0, &sechdr, sizeof(sechdr)) < 0)\r\ngoto datalen_error;\r\nif (!skb_pull(skb, sizeof(sechdr)))\r\nBUG();\r\nbuf = ntohl(sechdr.data_size);\r\ndata_size = buf & 0xffff;\r\ncheck = buf >> 16;\r\ncheck ^= ntohl(sp->hdr.seq ^ sp->hdr.callNumber);\r\ncheck &= 0xffff;\r\nif (check != 0) {\r\n*_abort_code = RXKADSEALEDINCON;\r\ngoto protocol_error;\r\n}\r\nif (data_size > skb->len)\r\ngoto datalen_error;\r\nelse if (data_size < skb->len)\r\nskb->len = data_size;\r\n_leave(" = 0 [dlen=%x]", data_size);\r\nreturn 0;\r\ndatalen_error:\r\n*_abort_code = RXKADDATALEN;\r\nprotocol_error:\r\n_leave(" = -EPROTO");\r\nreturn -EPROTO;\r\nnomem:\r\n_leave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\nstatic int rxkad_verify_packet_encrypt(const struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nconst struct rxrpc_key_token *token;\r\nstruct rxkad_level2_hdr sechdr;\r\nstruct rxrpc_skb_priv *sp;\r\nstruct blkcipher_desc desc;\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist _sg[4], *sg;\r\nstruct sk_buff *trailer;\r\nu32 data_size, buf;\r\nu16 check;\r\nint nsg;\r\n_enter(",{%d}", skb->len);\r\nsp = rxrpc_skb(skb);\r\nnsg = skb_cow_data(skb, 0, &trailer);\r\nif (nsg < 0)\r\ngoto nomem;\r\nsg = _sg;\r\nif (unlikely(nsg > 4)) {\r\nsg = kmalloc(sizeof(*sg) * nsg, GFP_NOIO);\r\nif (!sg)\r\ngoto nomem;\r\n}\r\nsg_init_table(sg, nsg);\r\nskb_to_sgvec(skb, sg, 0, skb->len);\r\ntoken = call->conn->key->payload.data;\r\nmemcpy(&iv, token->kad->session_key, sizeof(iv));\r\ndesc.tfm = call->conn->cipher;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\ncrypto_blkcipher_decrypt_iv(&desc, sg, sg, skb->len);\r\nif (sg != _sg)\r\nkfree(sg);\r\nif (skb_copy_bits(skb, 0, &sechdr, sizeof(sechdr)) < 0)\r\ngoto datalen_error;\r\nif (!skb_pull(skb, sizeof(sechdr)))\r\nBUG();\r\nbuf = ntohl(sechdr.data_size);\r\ndata_size = buf & 0xffff;\r\ncheck = buf >> 16;\r\ncheck ^= ntohl(sp->hdr.seq ^ sp->hdr.callNumber);\r\ncheck &= 0xffff;\r\nif (check != 0) {\r\n*_abort_code = RXKADSEALEDINCON;\r\ngoto protocol_error;\r\n}\r\nif (data_size > skb->len)\r\ngoto datalen_error;\r\nelse if (data_size < skb->len)\r\nskb->len = data_size;\r\n_leave(" = 0 [dlen=%x]", data_size);\r\nreturn 0;\r\ndatalen_error:\r\n*_abort_code = RXKADDATALEN;\r\nprotocol_error:\r\n_leave(" = -EPROTO");\r\nreturn -EPROTO;\r\nnomem:\r\n_leave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\nstatic int rxkad_verify_packet(const struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nstruct blkcipher_desc desc;\r\nstruct rxrpc_skb_priv *sp;\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[2];\r\nstruct {\r\n__be32 x[2];\r\n} tmpbuf __attribute__((aligned(8)));\r\n__be32 x;\r\n__be16 cksum;\r\nu32 y;\r\nint ret;\r\nsp = rxrpc_skb(skb);\r\n_enter("{%d{%x}},{#%u}",\r\ncall->debug_id, key_serial(call->conn->key),\r\nntohl(sp->hdr.seq));\r\nif (!call->conn->cipher)\r\nreturn 0;\r\nif (sp->hdr.securityIndex != RXRPC_SECURITY_RXKAD) {\r\n*_abort_code = RXKADINCONSISTENCY;\r\n_leave(" = -EPROTO [not rxkad]");\r\nreturn -EPROTO;\r\n}\r\nmemcpy(&iv, call->conn->csum_iv.x, sizeof(iv));\r\ndesc.tfm = call->conn->cipher;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\nx = htonl(call->channel << (32 - RXRPC_CIDSHIFT));\r\nx |= sp->hdr.seq & cpu_to_be32(0x3fffffff);\r\ntmpbuf.x[0] = call->call_id;\r\ntmpbuf.x[1] = x;\r\nsg_init_one(&sg[0], &tmpbuf, sizeof(tmpbuf));\r\nsg_init_one(&sg[1], &tmpbuf, sizeof(tmpbuf));\r\ncrypto_blkcipher_encrypt_iv(&desc, &sg[0], &sg[1], sizeof(tmpbuf));\r\ny = ntohl(tmpbuf.x[1]);\r\ny = (y >> 16) & 0xffff;\r\nif (y == 0)\r\ny = 1;\r\ncksum = htons(y);\r\nif (sp->hdr.cksum != cksum) {\r\n*_abort_code = RXKADSEALEDINCON;\r\n_leave(" = -EPROTO [csum failed]");\r\nreturn -EPROTO;\r\n}\r\nswitch (call->conn->security_level) {\r\ncase RXRPC_SECURITY_PLAIN:\r\nret = 0;\r\nbreak;\r\ncase RXRPC_SECURITY_AUTH:\r\nret = rxkad_verify_packet_auth(call, skb, _abort_code);\r\nbreak;\r\ncase RXRPC_SECURITY_ENCRYPT:\r\nret = rxkad_verify_packet_encrypt(call, skb, _abort_code);\r\nbreak;\r\ndefault:\r\nret = -ENOANO;\r\nbreak;\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxkad_issue_challenge(struct rxrpc_connection *conn)\r\n{\r\nstruct rxkad_challenge challenge;\r\nstruct rxrpc_header hdr;\r\nstruct msghdr msg;\r\nstruct kvec iov[2];\r\nsize_t len;\r\nint ret;\r\n_enter("{%d,%x}", conn->debug_id, key_serial(conn->key));\r\nret = key_validate(conn->key);\r\nif (ret < 0)\r\nreturn ret;\r\nget_random_bytes(&conn->security_nonce, sizeof(conn->security_nonce));\r\nchallenge.version = htonl(2);\r\nchallenge.nonce = htonl(conn->security_nonce);\r\nchallenge.min_level = htonl(0);\r\nchallenge.__padding = 0;\r\nmsg.msg_name = &conn->trans->peer->srx.transport.sin;\r\nmsg.msg_namelen = sizeof(conn->trans->peer->srx.transport.sin);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nhdr.epoch = conn->epoch;\r\nhdr.cid = conn->cid;\r\nhdr.callNumber = 0;\r\nhdr.seq = 0;\r\nhdr.type = RXRPC_PACKET_TYPE_CHALLENGE;\r\nhdr.flags = conn->out_clientflag;\r\nhdr.userStatus = 0;\r\nhdr.securityIndex = conn->security_ix;\r\nhdr._rsvd = 0;\r\nhdr.serviceId = conn->service_id;\r\niov[0].iov_base = &hdr;\r\niov[0].iov_len = sizeof(hdr);\r\niov[1].iov_base = &challenge;\r\niov[1].iov_len = sizeof(challenge);\r\nlen = iov[0].iov_len + iov[1].iov_len;\r\nhdr.serial = htonl(atomic_inc_return(&conn->serial));\r\n_proto("Tx CHALLENGE %%%u", ntohl(hdr.serial));\r\nret = kernel_sendmsg(conn->trans->local->socket, &msg, iov, 2, len);\r\nif (ret < 0) {\r\n_debug("sendmsg failed: %d", ret);\r\nreturn -EAGAIN;\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxkad_send_response(struct rxrpc_connection *conn,\r\nstruct rxrpc_header *hdr,\r\nstruct rxkad_response *resp,\r\nconst struct rxkad_key *s2)\r\n{\r\nstruct msghdr msg;\r\nstruct kvec iov[3];\r\nsize_t len;\r\nint ret;\r\n_enter("");\r\nmsg.msg_name = &conn->trans->peer->srx.transport.sin;\r\nmsg.msg_namelen = sizeof(conn->trans->peer->srx.transport.sin);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nhdr->epoch = conn->epoch;\r\nhdr->seq = 0;\r\nhdr->type = RXRPC_PACKET_TYPE_RESPONSE;\r\nhdr->flags = conn->out_clientflag;\r\nhdr->userStatus = 0;\r\nhdr->_rsvd = 0;\r\niov[0].iov_base = hdr;\r\niov[0].iov_len = sizeof(*hdr);\r\niov[1].iov_base = resp;\r\niov[1].iov_len = sizeof(*resp);\r\niov[2].iov_base = (void *) s2->ticket;\r\niov[2].iov_len = s2->ticket_len;\r\nlen = iov[0].iov_len + iov[1].iov_len + iov[2].iov_len;\r\nhdr->serial = htonl(atomic_inc_return(&conn->serial));\r\n_proto("Tx RESPONSE %%%u", ntohl(hdr->serial));\r\nret = kernel_sendmsg(conn->trans->local->socket, &msg, iov, 3, len);\r\nif (ret < 0) {\r\n_debug("sendmsg failed: %d", ret);\r\nreturn -EAGAIN;\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void rxkad_calc_response_checksum(struct rxkad_response *response)\r\n{\r\nu32 csum = 1000003;\r\nint loop;\r\nu8 *p = (u8 *) response;\r\nfor (loop = sizeof(*response); loop > 0; loop--)\r\ncsum = csum * 0x10204081 + *p++;\r\nresponse->encrypted.checksum = htonl(csum);\r\n}\r\nstatic void rxkad_sg_set_buf2(struct scatterlist sg[2],\r\nvoid *buf, size_t buflen)\r\n{\r\nint nsg = 1;\r\nsg_init_table(sg, 2);\r\nsg_set_buf(&sg[0], buf, buflen);\r\nif (sg[0].offset + buflen > PAGE_SIZE) {\r\nsg[0].length = PAGE_SIZE - sg[0].offset;\r\nsg_set_buf(&sg[1], buf + sg[0].length, buflen - sg[0].length);\r\nnsg++;\r\n}\r\nsg_mark_end(&sg[nsg - 1]);\r\nASSERTCMP(sg[0].length + sg[1].length, ==, buflen);\r\n}\r\nstatic void rxkad_encrypt_response(struct rxrpc_connection *conn,\r\nstruct rxkad_response *resp,\r\nconst struct rxkad_key *s2)\r\n{\r\nstruct blkcipher_desc desc;\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[2];\r\nmemcpy(&iv, s2->session_key, sizeof(iv));\r\ndesc.tfm = conn->cipher;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\nrxkad_sg_set_buf2(sg, &resp->encrypted, sizeof(resp->encrypted));\r\ncrypto_blkcipher_encrypt_iv(&desc, sg, sg, sizeof(resp->encrypted));\r\n}\r\nstatic int rxkad_respond_to_challenge(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nconst struct rxrpc_key_token *token;\r\nstruct rxkad_challenge challenge;\r\nstruct rxkad_response resp\r\n__attribute__((aligned(8)));\r\nstruct rxrpc_skb_priv *sp;\r\nu32 version, nonce, min_level, abort_code;\r\nint ret;\r\n_enter("{%d,%x}", conn->debug_id, key_serial(conn->key));\r\nif (!conn->key) {\r\n_leave(" = -EPROTO [no key]");\r\nreturn -EPROTO;\r\n}\r\nret = key_validate(conn->key);\r\nif (ret < 0) {\r\n*_abort_code = RXKADEXPIRED;\r\nreturn ret;\r\n}\r\nabort_code = RXKADPACKETSHORT;\r\nsp = rxrpc_skb(skb);\r\nif (skb_copy_bits(skb, 0, &challenge, sizeof(challenge)) < 0)\r\ngoto protocol_error;\r\nversion = ntohl(challenge.version);\r\nnonce = ntohl(challenge.nonce);\r\nmin_level = ntohl(challenge.min_level);\r\n_proto("Rx CHALLENGE %%%u { v=%u n=%u ml=%u }",\r\nntohl(sp->hdr.serial), version, nonce, min_level);\r\nabort_code = RXKADINCONSISTENCY;\r\nif (version != RXKAD_VERSION)\r\ngoto protocol_error;\r\nabort_code = RXKADLEVELFAIL;\r\nif (conn->security_level < min_level)\r\ngoto protocol_error;\r\ntoken = conn->key->payload.data;\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.version = RXKAD_VERSION;\r\nresp.encrypted.epoch = conn->epoch;\r\nresp.encrypted.cid = conn->cid;\r\nresp.encrypted.securityIndex = htonl(conn->security_ix);\r\nresp.encrypted.call_id[0] =\r\n(conn->channels[0] ? conn->channels[0]->call_id : 0);\r\nresp.encrypted.call_id[1] =\r\n(conn->channels[1] ? conn->channels[1]->call_id : 0);\r\nresp.encrypted.call_id[2] =\r\n(conn->channels[2] ? conn->channels[2]->call_id : 0);\r\nresp.encrypted.call_id[3] =\r\n(conn->channels[3] ? conn->channels[3]->call_id : 0);\r\nresp.encrypted.inc_nonce = htonl(nonce + 1);\r\nresp.encrypted.level = htonl(conn->security_level);\r\nresp.kvno = htonl(token->kad->kvno);\r\nresp.ticket_len = htonl(token->kad->ticket_len);\r\nrxkad_calc_response_checksum(&resp);\r\nrxkad_encrypt_response(conn, &resp, token->kad);\r\nreturn rxkad_send_response(conn, &sp->hdr, &resp, token->kad);\r\nprotocol_error:\r\n*_abort_code = abort_code;\r\n_leave(" = -EPROTO [%d]", abort_code);\r\nreturn -EPROTO;\r\n}\r\nstatic int rxkad_decrypt_ticket(struct rxrpc_connection *conn,\r\nvoid *ticket, size_t ticket_len,\r\nstruct rxrpc_crypt *_session_key,\r\ntime_t *_expiry,\r\nu32 *_abort_code)\r\n{\r\nstruct blkcipher_desc desc;\r\nstruct rxrpc_crypt iv, key;\r\nstruct scatterlist sg[1];\r\nstruct in_addr addr;\r\nunsigned int life;\r\ntime_t issue, now;\r\nbool little_endian;\r\nint ret;\r\nu8 *p, *q, *name, *end;\r\n_enter("{%d},{%x}", conn->debug_id, key_serial(conn->server_key));\r\n*_expiry = 0;\r\nret = key_validate(conn->server_key);\r\nif (ret < 0) {\r\nswitch (ret) {\r\ncase -EKEYEXPIRED:\r\n*_abort_code = RXKADEXPIRED;\r\ngoto error;\r\ndefault:\r\n*_abort_code = RXKADNOAUTH;\r\ngoto error;\r\n}\r\n}\r\nASSERT(conn->server_key->payload.data != NULL);\r\nASSERTCMP((unsigned long) ticket & 7UL, ==, 0);\r\nmemcpy(&iv, &conn->server_key->type_data, sizeof(iv));\r\ndesc.tfm = conn->server_key->payload.data;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\nsg_init_one(&sg[0], ticket, ticket_len);\r\ncrypto_blkcipher_decrypt_iv(&desc, sg, sg, ticket_len);\r\np = ticket;\r\nend = p + ticket_len;\r\n#define Z(size) \\r\n({ \\r\nu8 *__str = p; \\r\nq = memchr(p, 0, end - p); \\r\nif (!q || q - p > (size)) \\r\ngoto bad_ticket; \\r\nfor (; p < q; p++) \\r\nif (!isprint(*p)) \\r\ngoto bad_ticket; \\r\np++; \\r\n__str; \\r\n})\r\n_debug("KIV FLAGS: %x", *p);\r\nlittle_endian = *p & 1;\r\np++;\r\nname = Z(ANAME_SZ);\r\n_debug("KIV ANAME: %s", name);\r\nname = Z(INST_SZ);\r\n_debug("KIV INST : %s", name);\r\nname = Z(REALM_SZ);\r\n_debug("KIV REALM: %s", name);\r\nif (end - p < 4 + 8 + 4 + 2)\r\ngoto bad_ticket;\r\nmemcpy(&addr, p, sizeof(addr));\r\np += 4;\r\n_debug("KIV ADDR : %pI4", &addr);\r\nmemcpy(&key, p, sizeof(key));\r\np += 8;\r\n_debug("KIV KEY : %08x %08x", ntohl(key.n[0]), ntohl(key.n[1]));\r\nmemcpy(_session_key, &key, sizeof(key));\r\nlife = *p++ * 5 * 60;\r\n_debug("KIV LIFE : %u", life);\r\nif (little_endian) {\r\n__le32 stamp;\r\nmemcpy(&stamp, p, 4);\r\nissue = le32_to_cpu(stamp);\r\n} else {\r\n__be32 stamp;\r\nmemcpy(&stamp, p, 4);\r\nissue = be32_to_cpu(stamp);\r\n}\r\np += 4;\r\nnow = get_seconds();\r\n_debug("KIV ISSUE: %lx [%lx]", issue, now);\r\nif (issue > now) {\r\n*_abort_code = RXKADNOAUTH;\r\nret = -EKEYREJECTED;\r\ngoto error;\r\n}\r\nif (issue < now - life) {\r\n*_abort_code = RXKADEXPIRED;\r\nret = -EKEYEXPIRED;\r\ngoto error;\r\n}\r\n*_expiry = issue + life;\r\nname = Z(SNAME_SZ);\r\n_debug("KIV SNAME: %s", name);\r\nname = Z(INST_SZ);\r\n_debug("KIV SINST: %s", name);\r\nret = 0;\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nbad_ticket:\r\n*_abort_code = RXKADBADTICKET;\r\nret = -EBADMSG;\r\ngoto error;\r\n}\r\nstatic void rxkad_decrypt_response(struct rxrpc_connection *conn,\r\nstruct rxkad_response *resp,\r\nconst struct rxrpc_crypt *session_key)\r\n{\r\nstruct blkcipher_desc desc;\r\nstruct scatterlist sg[2];\r\nstruct rxrpc_crypt iv;\r\n_enter(",,%08x%08x",\r\nntohl(session_key->n[0]), ntohl(session_key->n[1]));\r\nASSERT(rxkad_ci != NULL);\r\nmutex_lock(&rxkad_ci_mutex);\r\nif (crypto_blkcipher_setkey(rxkad_ci, session_key->x,\r\nsizeof(*session_key)) < 0)\r\nBUG();\r\nmemcpy(&iv, session_key, sizeof(iv));\r\ndesc.tfm = rxkad_ci;\r\ndesc.info = iv.x;\r\ndesc.flags = 0;\r\nrxkad_sg_set_buf2(sg, &resp->encrypted, sizeof(resp->encrypted));\r\ncrypto_blkcipher_decrypt_iv(&desc, sg, sg, sizeof(resp->encrypted));\r\nmutex_unlock(&rxkad_ci_mutex);\r\n_leave("");\r\n}\r\nstatic int rxkad_verify_response(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nstruct rxkad_response response\r\n__attribute__((aligned(8)));\r\nstruct rxrpc_skb_priv *sp;\r\nstruct rxrpc_crypt session_key;\r\ntime_t expiry;\r\nvoid *ticket;\r\nu32 abort_code, version, kvno, ticket_len, level;\r\n__be32 csum;\r\nint ret;\r\n_enter("{%d,%x}", conn->debug_id, key_serial(conn->server_key));\r\nabort_code = RXKADPACKETSHORT;\r\nif (skb_copy_bits(skb, 0, &response, sizeof(response)) < 0)\r\ngoto protocol_error;\r\nif (!pskb_pull(skb, sizeof(response)))\r\nBUG();\r\nversion = ntohl(response.version);\r\nticket_len = ntohl(response.ticket_len);\r\nkvno = ntohl(response.kvno);\r\nsp = rxrpc_skb(skb);\r\n_proto("Rx RESPONSE %%%u { v=%u kv=%u tl=%u }",\r\nntohl(sp->hdr.serial), version, kvno, ticket_len);\r\nabort_code = RXKADINCONSISTENCY;\r\nif (version != RXKAD_VERSION)\r\ngoto protocol_error;\r\nabort_code = RXKADTICKETLEN;\r\nif (ticket_len < 4 || ticket_len > MAXKRB5TICKETLEN)\r\ngoto protocol_error;\r\nabort_code = RXKADUNKNOWNKEY;\r\nif (kvno >= RXKAD_TKT_TYPE_KERBEROS_V5)\r\ngoto protocol_error;\r\nticket = kmalloc(ticket_len, GFP_NOFS);\r\nif (!ticket)\r\nreturn -ENOMEM;\r\nabort_code = RXKADPACKETSHORT;\r\nif (skb_copy_bits(skb, 0, ticket, ticket_len) < 0)\r\ngoto protocol_error_free;\r\nret = rxkad_decrypt_ticket(conn, ticket, ticket_len, &session_key,\r\n&expiry, &abort_code);\r\nif (ret < 0) {\r\n*_abort_code = abort_code;\r\nkfree(ticket);\r\nreturn ret;\r\n}\r\nrxkad_decrypt_response(conn, &response, &session_key);\r\nabort_code = RXKADSEALEDINCON;\r\nif (response.encrypted.epoch != conn->epoch)\r\ngoto protocol_error_free;\r\nif (response.encrypted.cid != conn->cid)\r\ngoto protocol_error_free;\r\nif (ntohl(response.encrypted.securityIndex) != conn->security_ix)\r\ngoto protocol_error_free;\r\ncsum = response.encrypted.checksum;\r\nresponse.encrypted.checksum = 0;\r\nrxkad_calc_response_checksum(&response);\r\nif (response.encrypted.checksum != csum)\r\ngoto protocol_error_free;\r\nif (ntohl(response.encrypted.call_id[0]) > INT_MAX ||\r\nntohl(response.encrypted.call_id[1]) > INT_MAX ||\r\nntohl(response.encrypted.call_id[2]) > INT_MAX ||\r\nntohl(response.encrypted.call_id[3]) > INT_MAX)\r\ngoto protocol_error_free;\r\nabort_code = RXKADOUTOFSEQUENCE;\r\nif (response.encrypted.inc_nonce != htonl(conn->security_nonce + 1))\r\ngoto protocol_error_free;\r\nabort_code = RXKADLEVELFAIL;\r\nlevel = ntohl(response.encrypted.level);\r\nif (level > RXRPC_SECURITY_ENCRYPT)\r\ngoto protocol_error_free;\r\nconn->security_level = level;\r\nret = rxrpc_get_server_data_key(conn, &session_key, expiry, kvno);\r\nif (ret < 0) {\r\nkfree(ticket);\r\nreturn ret;\r\n}\r\nkfree(ticket);\r\n_leave(" = 0");\r\nreturn 0;\r\nprotocol_error_free:\r\nkfree(ticket);\r\nprotocol_error:\r\n*_abort_code = abort_code;\r\n_leave(" = -EPROTO [%d]", abort_code);\r\nreturn -EPROTO;\r\n}\r\nstatic void rxkad_clear(struct rxrpc_connection *conn)\r\n{\r\n_enter("");\r\nif (conn->cipher)\r\ncrypto_free_blkcipher(conn->cipher);\r\n}\r\nstatic __init int rxkad_init(void)\r\n{\r\n_enter("");\r\nrxkad_ci = crypto_alloc_blkcipher("pcbc(fcrypt)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(rxkad_ci))\r\nreturn PTR_ERR(rxkad_ci);\r\nreturn rxrpc_register_security(&rxkad);\r\n}\r\nstatic __exit void rxkad_exit(void)\r\n{\r\n_enter("");\r\nrxrpc_unregister_security(&rxkad);\r\ncrypto_free_blkcipher(rxkad_ci);\r\n}
