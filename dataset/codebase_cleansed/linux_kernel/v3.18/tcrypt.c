static int test_cipher_jiffies(struct blkcipher_desc *desc, int enc,\r\nstruct scatterlist *sg, int blen, int secs)\r\n{\r\nunsigned long start, end;\r\nint bcount;\r\nint ret;\r\nfor (start = jiffies, end = start + secs * HZ, bcount = 0;\r\ntime_before(jiffies, end); bcount++) {\r\nif (enc)\r\nret = crypto_blkcipher_encrypt(desc, sg, sg, blen);\r\nelse\r\nret = crypto_blkcipher_decrypt(desc, sg, sg, blen);\r\nif (ret)\r\nreturn ret;\r\n}\r\nprintk("%d operations in %d seconds (%ld bytes)\n",\r\nbcount, secs, (long)bcount * blen);\r\nreturn 0;\r\n}\r\nstatic int test_cipher_cycles(struct blkcipher_desc *desc, int enc,\r\nstruct scatterlist *sg, int blen)\r\n{\r\nunsigned long cycles = 0;\r\nint ret = 0;\r\nint i;\r\nlocal_irq_disable();\r\nfor (i = 0; i < 4; i++) {\r\nif (enc)\r\nret = crypto_blkcipher_encrypt(desc, sg, sg, blen);\r\nelse\r\nret = crypto_blkcipher_decrypt(desc, sg, sg, blen);\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncycles_t start, end;\r\nstart = get_cycles();\r\nif (enc)\r\nret = crypto_blkcipher_encrypt(desc, sg, sg, blen);\r\nelse\r\nret = crypto_blkcipher_decrypt(desc, sg, sg, blen);\r\nend = get_cycles();\r\nif (ret)\r\ngoto out;\r\ncycles += end - start;\r\n}\r\nout:\r\nlocal_irq_enable();\r\nif (ret == 0)\r\nprintk("1 operation in %lu cycles (%d bytes)\n",\r\n(cycles + 4) / 8, blen);\r\nreturn ret;\r\n}\r\nstatic int test_aead_jiffies(struct aead_request *req, int enc,\r\nint blen, int secs)\r\n{\r\nunsigned long start, end;\r\nint bcount;\r\nint ret;\r\nfor (start = jiffies, end = start + secs * HZ, bcount = 0;\r\ntime_before(jiffies, end); bcount++) {\r\nif (enc)\r\nret = crypto_aead_encrypt(req);\r\nelse\r\nret = crypto_aead_decrypt(req);\r\nif (ret)\r\nreturn ret;\r\n}\r\nprintk("%d operations in %d seconds (%ld bytes)\n",\r\nbcount, secs, (long)bcount * blen);\r\nreturn 0;\r\n}\r\nstatic int test_aead_cycles(struct aead_request *req, int enc, int blen)\r\n{\r\nunsigned long cycles = 0;\r\nint ret = 0;\r\nint i;\r\nlocal_irq_disable();\r\nfor (i = 0; i < 4; i++) {\r\nif (enc)\r\nret = crypto_aead_encrypt(req);\r\nelse\r\nret = crypto_aead_decrypt(req);\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncycles_t start, end;\r\nstart = get_cycles();\r\nif (enc)\r\nret = crypto_aead_encrypt(req);\r\nelse\r\nret = crypto_aead_decrypt(req);\r\nend = get_cycles();\r\nif (ret)\r\ngoto out;\r\ncycles += end - start;\r\n}\r\nout:\r\nlocal_irq_enable();\r\nif (ret == 0)\r\nprintk("1 operation in %lu cycles (%d bytes)\n",\r\n(cycles + 4) / 8, blen);\r\nreturn ret;\r\n}\r\nstatic int testmgr_alloc_buf(char *buf[XBUFSIZE])\r\n{\r\nint i;\r\nfor (i = 0; i < XBUFSIZE; i++) {\r\nbuf[i] = (void *)__get_free_page(GFP_KERNEL);\r\nif (!buf[i])\r\ngoto err_free_buf;\r\n}\r\nreturn 0;\r\nerr_free_buf:\r\nwhile (i-- > 0)\r\nfree_page((unsigned long)buf[i]);\r\nreturn -ENOMEM;\r\n}\r\nstatic void testmgr_free_buf(char *buf[XBUFSIZE])\r\n{\r\nint i;\r\nfor (i = 0; i < XBUFSIZE; i++)\r\nfree_page((unsigned long)buf[i]);\r\n}\r\nstatic void sg_init_aead(struct scatterlist *sg, char *xbuf[XBUFSIZE],\r\nunsigned int buflen)\r\n{\r\nint np = (buflen + PAGE_SIZE - 1)/PAGE_SIZE;\r\nint k, rem;\r\nnp = (np > XBUFSIZE) ? XBUFSIZE : np;\r\nrem = buflen % PAGE_SIZE;\r\nif (np > XBUFSIZE) {\r\nrem = PAGE_SIZE;\r\nnp = XBUFSIZE;\r\n}\r\nsg_init_table(sg, np);\r\nfor (k = 0; k < np; ++k) {\r\nif (k == (np-1))\r\nsg_set_buf(&sg[k], xbuf[k], rem);\r\nelse\r\nsg_set_buf(&sg[k], xbuf[k], PAGE_SIZE);\r\n}\r\n}\r\nstatic void test_aead_speed(const char *algo, int enc, unsigned int secs,\r\nstruct aead_speed_template *template,\r\nunsigned int tcount, u8 authsize,\r\nunsigned int aad_size, u8 *keysize)\r\n{\r\nunsigned int i, j;\r\nstruct crypto_aead *tfm;\r\nint ret = -ENOMEM;\r\nconst char *key;\r\nstruct aead_request *req;\r\nstruct scatterlist *sg;\r\nstruct scatterlist *asg;\r\nstruct scatterlist *sgout;\r\nconst char *e;\r\nvoid *assoc;\r\nchar iv[MAX_IVLEN];\r\nchar *xbuf[XBUFSIZE];\r\nchar *xoutbuf[XBUFSIZE];\r\nchar *axbuf[XBUFSIZE];\r\nunsigned int *b_size;\r\nunsigned int iv_len;\r\nif (aad_size >= PAGE_SIZE) {\r\npr_err("associate data length (%u) too big\n", aad_size);\r\nreturn;\r\n}\r\nif (enc == ENCRYPT)\r\ne = "encryption";\r\nelse\r\ne = "decryption";\r\nif (testmgr_alloc_buf(xbuf))\r\ngoto out_noxbuf;\r\nif (testmgr_alloc_buf(axbuf))\r\ngoto out_noaxbuf;\r\nif (testmgr_alloc_buf(xoutbuf))\r\ngoto out_nooutbuf;\r\nsg = kmalloc(sizeof(*sg) * 8 * 3, GFP_KERNEL);\r\nif (!sg)\r\ngoto out_nosg;\r\nasg = &sg[8];\r\nsgout = &asg[8];\r\ntfm = crypto_alloc_aead(algo, 0, 0);\r\nif (IS_ERR(tfm)) {\r\npr_err("alg: aead: Failed to load transform for %s: %ld\n", algo,\r\nPTR_ERR(tfm));\r\ngoto out_notfm;\r\n}\r\nprintk(KERN_INFO "\ntesting speed of %s (%s) %s\n", algo,\r\nget_driver_name(crypto_aead, tfm), e);\r\nreq = aead_request_alloc(tfm, GFP_KERNEL);\r\nif (!req) {\r\npr_err("alg: aead: Failed to allocate request for %s\n",\r\nalgo);\r\ngoto out_noreq;\r\n}\r\ni = 0;\r\ndo {\r\nb_size = aead_sizes;\r\ndo {\r\nassoc = axbuf[0];\r\nmemset(assoc, 0xff, aad_size);\r\nsg_init_one(&asg[0], assoc, aad_size);\r\nif ((*keysize + *b_size) > TVMEMSIZE * PAGE_SIZE) {\r\npr_err("template (%u) too big for tvmem (%lu)\n",\r\n*keysize + *b_size,\r\nTVMEMSIZE * PAGE_SIZE);\r\ngoto out;\r\n}\r\nkey = tvmem[0];\r\nfor (j = 0; j < tcount; j++) {\r\nif (template[j].klen == *keysize) {\r\nkey = template[j].key;\r\nbreak;\r\n}\r\n}\r\nret = crypto_aead_setkey(tfm, key, *keysize);\r\nret = crypto_aead_setauthsize(tfm, authsize);\r\niv_len = crypto_aead_ivsize(tfm);\r\nif (iv_len)\r\nmemset(&iv, 0xff, iv_len);\r\ncrypto_aead_clear_flags(tfm, ~0);\r\nprintk(KERN_INFO "test %u (%d bit key, %d byte blocks): ",\r\ni, *keysize * 8, *b_size);\r\nmemset(tvmem[0], 0xff, PAGE_SIZE);\r\nif (ret) {\r\npr_err("setkey() failed flags=%x\n",\r\ncrypto_aead_get_flags(tfm));\r\ngoto out;\r\n}\r\nsg_init_aead(&sg[0], xbuf,\r\n*b_size + (enc ? authsize : 0));\r\nsg_init_aead(&sgout[0], xoutbuf,\r\n*b_size + (enc ? authsize : 0));\r\naead_request_set_crypt(req, sg, sgout, *b_size, iv);\r\naead_request_set_assoc(req, asg, aad_size);\r\nif (secs)\r\nret = test_aead_jiffies(req, enc, *b_size,\r\nsecs);\r\nelse\r\nret = test_aead_cycles(req, enc, *b_size);\r\nif (ret) {\r\npr_err("%s() failed return code=%d\n", e, ret);\r\nbreak;\r\n}\r\nb_size++;\r\ni++;\r\n} while (*b_size);\r\nkeysize++;\r\n} while (*keysize);\r\nout:\r\naead_request_free(req);\r\nout_noreq:\r\ncrypto_free_aead(tfm);\r\nout_notfm:\r\nkfree(sg);\r\nout_nosg:\r\ntestmgr_free_buf(xoutbuf);\r\nout_nooutbuf:\r\ntestmgr_free_buf(axbuf);\r\nout_noaxbuf:\r\ntestmgr_free_buf(xbuf);\r\nout_noxbuf:\r\nreturn;\r\n}\r\nstatic void test_cipher_speed(const char *algo, int enc, unsigned int secs,\r\nstruct cipher_speed_template *template,\r\nunsigned int tcount, u8 *keysize)\r\n{\r\nunsigned int ret, i, j, iv_len;\r\nconst char *key;\r\nchar iv[128];\r\nstruct crypto_blkcipher *tfm;\r\nstruct blkcipher_desc desc;\r\nconst char *e;\r\nu32 *b_size;\r\nif (enc == ENCRYPT)\r\ne = "encryption";\r\nelse\r\ne = "decryption";\r\ntfm = crypto_alloc_blkcipher(algo, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm)) {\r\nprintk("failed to load transform for %s: %ld\n", algo,\r\nPTR_ERR(tfm));\r\nreturn;\r\n}\r\ndesc.tfm = tfm;\r\ndesc.flags = 0;\r\nprintk(KERN_INFO "\ntesting speed of %s (%s) %s\n", algo,\r\nget_driver_name(crypto_blkcipher, tfm), e);\r\ni = 0;\r\ndo {\r\nb_size = block_sizes;\r\ndo {\r\nstruct scatterlist sg[TVMEMSIZE];\r\nif ((*keysize + *b_size) > TVMEMSIZE * PAGE_SIZE) {\r\nprintk("template (%u) too big for "\r\n"tvmem (%lu)\n", *keysize + *b_size,\r\nTVMEMSIZE * PAGE_SIZE);\r\ngoto out;\r\n}\r\nprintk("test %u (%d bit key, %d byte blocks): ", i,\r\n*keysize * 8, *b_size);\r\nmemset(tvmem[0], 0xff, PAGE_SIZE);\r\nkey = tvmem[0];\r\nfor (j = 0; j < tcount; j++) {\r\nif (template[j].klen == *keysize) {\r\nkey = template[j].key;\r\nbreak;\r\n}\r\n}\r\nret = crypto_blkcipher_setkey(tfm, key, *keysize);\r\nif (ret) {\r\nprintk("setkey() failed flags=%x\n",\r\ncrypto_blkcipher_get_flags(tfm));\r\ngoto out;\r\n}\r\nsg_init_table(sg, TVMEMSIZE);\r\nsg_set_buf(sg, tvmem[0] + *keysize,\r\nPAGE_SIZE - *keysize);\r\nfor (j = 1; j < TVMEMSIZE; j++) {\r\nsg_set_buf(sg + j, tvmem[j], PAGE_SIZE);\r\nmemset (tvmem[j], 0xff, PAGE_SIZE);\r\n}\r\niv_len = crypto_blkcipher_ivsize(tfm);\r\nif (iv_len) {\r\nmemset(&iv, 0xff, iv_len);\r\ncrypto_blkcipher_set_iv(tfm, iv, iv_len);\r\n}\r\nif (secs)\r\nret = test_cipher_jiffies(&desc, enc, sg,\r\n*b_size, secs);\r\nelse\r\nret = test_cipher_cycles(&desc, enc, sg,\r\n*b_size);\r\nif (ret) {\r\nprintk("%s() failed flags=%x\n", e, desc.flags);\r\nbreak;\r\n}\r\nb_size++;\r\ni++;\r\n} while (*b_size);\r\nkeysize++;\r\n} while (*keysize);\r\nout:\r\ncrypto_free_blkcipher(tfm);\r\n}\r\nstatic int test_hash_jiffies_digest(struct hash_desc *desc,\r\nstruct scatterlist *sg, int blen,\r\nchar *out, int secs)\r\n{\r\nunsigned long start, end;\r\nint bcount;\r\nint ret;\r\nfor (start = jiffies, end = start + secs * HZ, bcount = 0;\r\ntime_before(jiffies, end); bcount++) {\r\nret = crypto_hash_digest(desc, sg, blen, out);\r\nif (ret)\r\nreturn ret;\r\n}\r\nprintk("%6u opers/sec, %9lu bytes/sec\n",\r\nbcount / secs, ((long)bcount * blen) / secs);\r\nreturn 0;\r\n}\r\nstatic int test_hash_jiffies(struct hash_desc *desc, struct scatterlist *sg,\r\nint blen, int plen, char *out, int secs)\r\n{\r\nunsigned long start, end;\r\nint bcount, pcount;\r\nint ret;\r\nif (plen == blen)\r\nreturn test_hash_jiffies_digest(desc, sg, blen, out, secs);\r\nfor (start = jiffies, end = start + secs * HZ, bcount = 0;\r\ntime_before(jiffies, end); bcount++) {\r\nret = crypto_hash_init(desc);\r\nif (ret)\r\nreturn ret;\r\nfor (pcount = 0; pcount < blen; pcount += plen) {\r\nret = crypto_hash_update(desc, sg, plen);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = crypto_hash_final(desc, out);\r\nif (ret)\r\nreturn ret;\r\n}\r\nprintk("%6u opers/sec, %9lu bytes/sec\n",\r\nbcount / secs, ((long)bcount * blen) / secs);\r\nreturn 0;\r\n}\r\nstatic int test_hash_cycles_digest(struct hash_desc *desc,\r\nstruct scatterlist *sg, int blen, char *out)\r\n{\r\nunsigned long cycles = 0;\r\nint i;\r\nint ret;\r\nlocal_irq_disable();\r\nfor (i = 0; i < 4; i++) {\r\nret = crypto_hash_digest(desc, sg, blen, out);\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncycles_t start, end;\r\nstart = get_cycles();\r\nret = crypto_hash_digest(desc, sg, blen, out);\r\nif (ret)\r\ngoto out;\r\nend = get_cycles();\r\ncycles += end - start;\r\n}\r\nout:\r\nlocal_irq_enable();\r\nif (ret)\r\nreturn ret;\r\nprintk("%6lu cycles/operation, %4lu cycles/byte\n",\r\ncycles / 8, cycles / (8 * blen));\r\nreturn 0;\r\n}\r\nstatic int test_hash_cycles(struct hash_desc *desc, struct scatterlist *sg,\r\nint blen, int plen, char *out)\r\n{\r\nunsigned long cycles = 0;\r\nint i, pcount;\r\nint ret;\r\nif (plen == blen)\r\nreturn test_hash_cycles_digest(desc, sg, blen, out);\r\nlocal_irq_disable();\r\nfor (i = 0; i < 4; i++) {\r\nret = crypto_hash_init(desc);\r\nif (ret)\r\ngoto out;\r\nfor (pcount = 0; pcount < blen; pcount += plen) {\r\nret = crypto_hash_update(desc, sg, plen);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = crypto_hash_final(desc, out);\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncycles_t start, end;\r\nstart = get_cycles();\r\nret = crypto_hash_init(desc);\r\nif (ret)\r\ngoto out;\r\nfor (pcount = 0; pcount < blen; pcount += plen) {\r\nret = crypto_hash_update(desc, sg, plen);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = crypto_hash_final(desc, out);\r\nif (ret)\r\ngoto out;\r\nend = get_cycles();\r\ncycles += end - start;\r\n}\r\nout:\r\nlocal_irq_enable();\r\nif (ret)\r\nreturn ret;\r\nprintk("%6lu cycles/operation, %4lu cycles/byte\n",\r\ncycles / 8, cycles / (8 * blen));\r\nreturn 0;\r\n}\r\nstatic void test_hash_sg_init(struct scatterlist *sg)\r\n{\r\nint i;\r\nsg_init_table(sg, TVMEMSIZE);\r\nfor (i = 0; i < TVMEMSIZE; i++) {\r\nsg_set_buf(sg + i, tvmem[i], PAGE_SIZE);\r\nmemset(tvmem[i], 0xff, PAGE_SIZE);\r\n}\r\n}\r\nstatic void test_hash_speed(const char *algo, unsigned int secs,\r\nstruct hash_speed *speed)\r\n{\r\nstruct scatterlist sg[TVMEMSIZE];\r\nstruct crypto_hash *tfm;\r\nstruct hash_desc desc;\r\nstatic char output[1024];\r\nint i;\r\nint ret;\r\ntfm = crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm)) {\r\nprintk(KERN_ERR "failed to load transform for %s: %ld\n", algo,\r\nPTR_ERR(tfm));\r\nreturn;\r\n}\r\nprintk(KERN_INFO "\ntesting speed of %s (%s)\n", algo,\r\nget_driver_name(crypto_hash, tfm));\r\ndesc.tfm = tfm;\r\ndesc.flags = 0;\r\nif (crypto_hash_digestsize(tfm) > sizeof(output)) {\r\nprintk(KERN_ERR "digestsize(%u) > outputbuffer(%zu)\n",\r\ncrypto_hash_digestsize(tfm), sizeof(output));\r\ngoto out;\r\n}\r\ntest_hash_sg_init(sg);\r\nfor (i = 0; speed[i].blen != 0; i++) {\r\nif (speed[i].blen > TVMEMSIZE * PAGE_SIZE) {\r\nprintk(KERN_ERR\r\n"template (%u) too big for tvmem (%lu)\n",\r\nspeed[i].blen, TVMEMSIZE * PAGE_SIZE);\r\ngoto out;\r\n}\r\nif (speed[i].klen)\r\ncrypto_hash_setkey(tfm, tvmem[0], speed[i].klen);\r\nprintk(KERN_INFO "test%3u "\r\n"(%5u byte blocks,%5u bytes per update,%4u updates): ",\r\ni, speed[i].blen, speed[i].plen, speed[i].blen / speed[i].plen);\r\nif (secs)\r\nret = test_hash_jiffies(&desc, sg, speed[i].blen,\r\nspeed[i].plen, output, secs);\r\nelse\r\nret = test_hash_cycles(&desc, sg, speed[i].blen,\r\nspeed[i].plen, output);\r\nif (ret) {\r\nprintk(KERN_ERR "hashing failed ret=%d\n", ret);\r\nbreak;\r\n}\r\n}\r\nout:\r\ncrypto_free_hash(tfm);\r\n}\r\nstatic void tcrypt_complete(struct crypto_async_request *req, int err)\r\n{\r\nstruct tcrypt_result *res = req->data;\r\nif (err == -EINPROGRESS)\r\nreturn;\r\nres->err = err;\r\ncomplete(&res->completion);\r\n}\r\nstatic inline int do_one_ahash_op(struct ahash_request *req, int ret)\r\n{\r\nif (ret == -EINPROGRESS || ret == -EBUSY) {\r\nstruct tcrypt_result *tr = req->base.data;\r\nret = wait_for_completion_interruptible(&tr->completion);\r\nif (!ret)\r\nret = tr->err;\r\nreinit_completion(&tr->completion);\r\n}\r\nreturn ret;\r\n}\r\nstatic int test_ahash_jiffies_digest(struct ahash_request *req, int blen,\r\nchar *out, int secs)\r\n{\r\nunsigned long start, end;\r\nint bcount;\r\nint ret;\r\nfor (start = jiffies, end = start + secs * HZ, bcount = 0;\r\ntime_before(jiffies, end); bcount++) {\r\nret = do_one_ahash_op(req, crypto_ahash_digest(req));\r\nif (ret)\r\nreturn ret;\r\n}\r\nprintk("%6u opers/sec, %9lu bytes/sec\n",\r\nbcount / secs, ((long)bcount * blen) / secs);\r\nreturn 0;\r\n}\r\nstatic int test_ahash_jiffies(struct ahash_request *req, int blen,\r\nint plen, char *out, int secs)\r\n{\r\nunsigned long start, end;\r\nint bcount, pcount;\r\nint ret;\r\nif (plen == blen)\r\nreturn test_ahash_jiffies_digest(req, blen, out, secs);\r\nfor (start = jiffies, end = start + secs * HZ, bcount = 0;\r\ntime_before(jiffies, end); bcount++) {\r\nret = crypto_ahash_init(req);\r\nif (ret)\r\nreturn ret;\r\nfor (pcount = 0; pcount < blen; pcount += plen) {\r\nret = do_one_ahash_op(req, crypto_ahash_update(req));\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = do_one_ahash_op(req, crypto_ahash_final(req));\r\nif (ret)\r\nreturn ret;\r\n}\r\npr_cont("%6u opers/sec, %9lu bytes/sec\n",\r\nbcount / secs, ((long)bcount * blen) / secs);\r\nreturn 0;\r\n}\r\nstatic int test_ahash_cycles_digest(struct ahash_request *req, int blen,\r\nchar *out)\r\n{\r\nunsigned long cycles = 0;\r\nint ret, i;\r\nfor (i = 0; i < 4; i++) {\r\nret = do_one_ahash_op(req, crypto_ahash_digest(req));\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncycles_t start, end;\r\nstart = get_cycles();\r\nret = do_one_ahash_op(req, crypto_ahash_digest(req));\r\nif (ret)\r\ngoto out;\r\nend = get_cycles();\r\ncycles += end - start;\r\n}\r\nout:\r\nif (ret)\r\nreturn ret;\r\npr_cont("%6lu cycles/operation, %4lu cycles/byte\n",\r\ncycles / 8, cycles / (8 * blen));\r\nreturn 0;\r\n}\r\nstatic int test_ahash_cycles(struct ahash_request *req, int blen,\r\nint plen, char *out)\r\n{\r\nunsigned long cycles = 0;\r\nint i, pcount, ret;\r\nif (plen == blen)\r\nreturn test_ahash_cycles_digest(req, blen, out);\r\nfor (i = 0; i < 4; i++) {\r\nret = crypto_ahash_init(req);\r\nif (ret)\r\ngoto out;\r\nfor (pcount = 0; pcount < blen; pcount += plen) {\r\nret = do_one_ahash_op(req, crypto_ahash_update(req));\r\nif (ret)\r\ngoto out;\r\n}\r\nret = do_one_ahash_op(req, crypto_ahash_final(req));\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncycles_t start, end;\r\nstart = get_cycles();\r\nret = crypto_ahash_init(req);\r\nif (ret)\r\ngoto out;\r\nfor (pcount = 0; pcount < blen; pcount += plen) {\r\nret = do_one_ahash_op(req, crypto_ahash_update(req));\r\nif (ret)\r\ngoto out;\r\n}\r\nret = do_one_ahash_op(req, crypto_ahash_final(req));\r\nif (ret)\r\ngoto out;\r\nend = get_cycles();\r\ncycles += end - start;\r\n}\r\nout:\r\nif (ret)\r\nreturn ret;\r\npr_cont("%6lu cycles/operation, %4lu cycles/byte\n",\r\ncycles / 8, cycles / (8 * blen));\r\nreturn 0;\r\n}\r\nstatic void test_ahash_speed(const char *algo, unsigned int secs,\r\nstruct hash_speed *speed)\r\n{\r\nstruct scatterlist sg[TVMEMSIZE];\r\nstruct tcrypt_result tresult;\r\nstruct ahash_request *req;\r\nstruct crypto_ahash *tfm;\r\nstatic char output[1024];\r\nint i, ret;\r\ntfm = crypto_alloc_ahash(algo, 0, 0);\r\nif (IS_ERR(tfm)) {\r\npr_err("failed to load transform for %s: %ld\n",\r\nalgo, PTR_ERR(tfm));\r\nreturn;\r\n}\r\nprintk(KERN_INFO "\ntesting speed of async %s (%s)\n", algo,\r\nget_driver_name(crypto_ahash, tfm));\r\nif (crypto_ahash_digestsize(tfm) > sizeof(output)) {\r\npr_err("digestsize(%u) > outputbuffer(%zu)\n",\r\ncrypto_ahash_digestsize(tfm), sizeof(output));\r\ngoto out;\r\n}\r\ntest_hash_sg_init(sg);\r\nreq = ahash_request_alloc(tfm, GFP_KERNEL);\r\nif (!req) {\r\npr_err("ahash request allocation failure\n");\r\ngoto out;\r\n}\r\ninit_completion(&tresult.completion);\r\nahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\ntcrypt_complete, &tresult);\r\nfor (i = 0; speed[i].blen != 0; i++) {\r\nif (speed[i].blen > TVMEMSIZE * PAGE_SIZE) {\r\npr_err("template (%u) too big for tvmem (%lu)\n",\r\nspeed[i].blen, TVMEMSIZE * PAGE_SIZE);\r\nbreak;\r\n}\r\npr_info("test%3u "\r\n"(%5u byte blocks,%5u bytes per update,%4u updates): ",\r\ni, speed[i].blen, speed[i].plen, speed[i].blen / speed[i].plen);\r\nahash_request_set_crypt(req, sg, output, speed[i].plen);\r\nif (secs)\r\nret = test_ahash_jiffies(req, speed[i].blen,\r\nspeed[i].plen, output, secs);\r\nelse\r\nret = test_ahash_cycles(req, speed[i].blen,\r\nspeed[i].plen, output);\r\nif (ret) {\r\npr_err("hashing failed ret=%d\n", ret);\r\nbreak;\r\n}\r\n}\r\nahash_request_free(req);\r\nout:\r\ncrypto_free_ahash(tfm);\r\n}\r\nstatic inline int do_one_acipher_op(struct ablkcipher_request *req, int ret)\r\n{\r\nif (ret == -EINPROGRESS || ret == -EBUSY) {\r\nstruct tcrypt_result *tr = req->base.data;\r\nret = wait_for_completion_interruptible(&tr->completion);\r\nif (!ret)\r\nret = tr->err;\r\nreinit_completion(&tr->completion);\r\n}\r\nreturn ret;\r\n}\r\nstatic int test_acipher_jiffies(struct ablkcipher_request *req, int enc,\r\nint blen, int secs)\r\n{\r\nunsigned long start, end;\r\nint bcount;\r\nint ret;\r\nfor (start = jiffies, end = start + secs * HZ, bcount = 0;\r\ntime_before(jiffies, end); bcount++) {\r\nif (enc)\r\nret = do_one_acipher_op(req,\r\ncrypto_ablkcipher_encrypt(req));\r\nelse\r\nret = do_one_acipher_op(req,\r\ncrypto_ablkcipher_decrypt(req));\r\nif (ret)\r\nreturn ret;\r\n}\r\npr_cont("%d operations in %d seconds (%ld bytes)\n",\r\nbcount, secs, (long)bcount * blen);\r\nreturn 0;\r\n}\r\nstatic int test_acipher_cycles(struct ablkcipher_request *req, int enc,\r\nint blen)\r\n{\r\nunsigned long cycles = 0;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nif (enc)\r\nret = do_one_acipher_op(req,\r\ncrypto_ablkcipher_encrypt(req));\r\nelse\r\nret = do_one_acipher_op(req,\r\ncrypto_ablkcipher_decrypt(req));\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncycles_t start, end;\r\nstart = get_cycles();\r\nif (enc)\r\nret = do_one_acipher_op(req,\r\ncrypto_ablkcipher_encrypt(req));\r\nelse\r\nret = do_one_acipher_op(req,\r\ncrypto_ablkcipher_decrypt(req));\r\nend = get_cycles();\r\nif (ret)\r\ngoto out;\r\ncycles += end - start;\r\n}\r\nout:\r\nif (ret == 0)\r\npr_cont("1 operation in %lu cycles (%d bytes)\n",\r\n(cycles + 4) / 8, blen);\r\nreturn ret;\r\n}\r\nstatic void test_acipher_speed(const char *algo, int enc, unsigned int secs,\r\nstruct cipher_speed_template *template,\r\nunsigned int tcount, u8 *keysize)\r\n{\r\nunsigned int ret, i, j, k, iv_len;\r\nstruct tcrypt_result tresult;\r\nconst char *key;\r\nchar iv[128];\r\nstruct ablkcipher_request *req;\r\nstruct crypto_ablkcipher *tfm;\r\nconst char *e;\r\nu32 *b_size;\r\nif (enc == ENCRYPT)\r\ne = "encryption";\r\nelse\r\ne = "decryption";\r\ninit_completion(&tresult.completion);\r\ntfm = crypto_alloc_ablkcipher(algo, 0, 0);\r\nif (IS_ERR(tfm)) {\r\npr_err("failed to load transform for %s: %ld\n", algo,\r\nPTR_ERR(tfm));\r\nreturn;\r\n}\r\npr_info("\ntesting speed of async %s (%s) %s\n", algo,\r\nget_driver_name(crypto_ablkcipher, tfm), e);\r\nreq = ablkcipher_request_alloc(tfm, GFP_KERNEL);\r\nif (!req) {\r\npr_err("tcrypt: skcipher: Failed to allocate request for %s\n",\r\nalgo);\r\ngoto out;\r\n}\r\nablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\ntcrypt_complete, &tresult);\r\ni = 0;\r\ndo {\r\nb_size = block_sizes;\r\ndo {\r\nstruct scatterlist sg[TVMEMSIZE];\r\nif ((*keysize + *b_size) > TVMEMSIZE * PAGE_SIZE) {\r\npr_err("template (%u) too big for "\r\n"tvmem (%lu)\n", *keysize + *b_size,\r\nTVMEMSIZE * PAGE_SIZE);\r\ngoto out_free_req;\r\n}\r\npr_info("test %u (%d bit key, %d byte blocks): ", i,\r\n*keysize * 8, *b_size);\r\nmemset(tvmem[0], 0xff, PAGE_SIZE);\r\nkey = tvmem[0];\r\nfor (j = 0; j < tcount; j++) {\r\nif (template[j].klen == *keysize) {\r\nkey = template[j].key;\r\nbreak;\r\n}\r\n}\r\ncrypto_ablkcipher_clear_flags(tfm, ~0);\r\nret = crypto_ablkcipher_setkey(tfm, key, *keysize);\r\nif (ret) {\r\npr_err("setkey() failed flags=%x\n",\r\ncrypto_ablkcipher_get_flags(tfm));\r\ngoto out_free_req;\r\n}\r\nsg_init_table(sg, TVMEMSIZE);\r\nk = *keysize + *b_size;\r\nif (k > PAGE_SIZE) {\r\nsg_set_buf(sg, tvmem[0] + *keysize,\r\nPAGE_SIZE - *keysize);\r\nk -= PAGE_SIZE;\r\nj = 1;\r\nwhile (k > PAGE_SIZE) {\r\nsg_set_buf(sg + j, tvmem[j], PAGE_SIZE);\r\nmemset(tvmem[j], 0xff, PAGE_SIZE);\r\nj++;\r\nk -= PAGE_SIZE;\r\n}\r\nsg_set_buf(sg + j, tvmem[j], k);\r\nmemset(tvmem[j], 0xff, k);\r\n} else {\r\nsg_set_buf(sg, tvmem[0] + *keysize, *b_size);\r\n}\r\niv_len = crypto_ablkcipher_ivsize(tfm);\r\nif (iv_len)\r\nmemset(&iv, 0xff, iv_len);\r\nablkcipher_request_set_crypt(req, sg, sg, *b_size, iv);\r\nif (secs)\r\nret = test_acipher_jiffies(req, enc,\r\n*b_size, secs);\r\nelse\r\nret = test_acipher_cycles(req, enc,\r\n*b_size);\r\nif (ret) {\r\npr_err("%s() failed flags=%x\n", e,\r\ncrypto_ablkcipher_get_flags(tfm));\r\nbreak;\r\n}\r\nb_size++;\r\ni++;\r\n} while (*b_size);\r\nkeysize++;\r\n} while (*keysize);\r\nout_free_req:\r\nablkcipher_request_free(req);\r\nout:\r\ncrypto_free_ablkcipher(tfm);\r\n}\r\nstatic void test_available(void)\r\n{\r\nchar **name = check;\r\nwhile (*name) {\r\nprintk("alg %s ", *name);\r\nprintk(crypto_has_alg(*name, 0, 0) ?\r\n"found\n" : "not found\n");\r\nname++;\r\n}\r\n}\r\nstatic inline int tcrypt_test(const char *alg)\r\n{\r\nint ret;\r\nret = alg_test(alg, alg, 0, 0);\r\nif (fips_enabled && ret == -EINVAL)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int do_test(int m)\r\n{\r\nint i;\r\nint ret = 0;\r\nswitch (m) {\r\ncase 0:\r\nfor (i = 1; i < 200; i++)\r\nret += do_test(i);\r\nbreak;\r\ncase 1:\r\nret += tcrypt_test("md5");\r\nbreak;\r\ncase 2:\r\nret += tcrypt_test("sha1");\r\nbreak;\r\ncase 3:\r\nret += tcrypt_test("ecb(des)");\r\nret += tcrypt_test("cbc(des)");\r\nret += tcrypt_test("ctr(des)");\r\nbreak;\r\ncase 4:\r\nret += tcrypt_test("ecb(des3_ede)");\r\nret += tcrypt_test("cbc(des3_ede)");\r\nret += tcrypt_test("ctr(des3_ede)");\r\nbreak;\r\ncase 5:\r\nret += tcrypt_test("md4");\r\nbreak;\r\ncase 6:\r\nret += tcrypt_test("sha256");\r\nbreak;\r\ncase 7:\r\nret += tcrypt_test("ecb(blowfish)");\r\nret += tcrypt_test("cbc(blowfish)");\r\nret += tcrypt_test("ctr(blowfish)");\r\nbreak;\r\ncase 8:\r\nret += tcrypt_test("ecb(twofish)");\r\nret += tcrypt_test("cbc(twofish)");\r\nret += tcrypt_test("ctr(twofish)");\r\nret += tcrypt_test("lrw(twofish)");\r\nret += tcrypt_test("xts(twofish)");\r\nbreak;\r\ncase 9:\r\nret += tcrypt_test("ecb(serpent)");\r\nret += tcrypt_test("cbc(serpent)");\r\nret += tcrypt_test("ctr(serpent)");\r\nret += tcrypt_test("lrw(serpent)");\r\nret += tcrypt_test("xts(serpent)");\r\nbreak;\r\ncase 10:\r\nret += tcrypt_test("ecb(aes)");\r\nret += tcrypt_test("cbc(aes)");\r\nret += tcrypt_test("lrw(aes)");\r\nret += tcrypt_test("xts(aes)");\r\nret += tcrypt_test("ctr(aes)");\r\nret += tcrypt_test("rfc3686(ctr(aes))");\r\nbreak;\r\ncase 11:\r\nret += tcrypt_test("sha384");\r\nbreak;\r\ncase 12:\r\nret += tcrypt_test("sha512");\r\nbreak;\r\ncase 13:\r\nret += tcrypt_test("deflate");\r\nbreak;\r\ncase 14:\r\nret += tcrypt_test("ecb(cast5)");\r\nret += tcrypt_test("cbc(cast5)");\r\nret += tcrypt_test("ctr(cast5)");\r\nbreak;\r\ncase 15:\r\nret += tcrypt_test("ecb(cast6)");\r\nret += tcrypt_test("cbc(cast6)");\r\nret += tcrypt_test("ctr(cast6)");\r\nret += tcrypt_test("lrw(cast6)");\r\nret += tcrypt_test("xts(cast6)");\r\nbreak;\r\ncase 16:\r\nret += tcrypt_test("ecb(arc4)");\r\nbreak;\r\ncase 17:\r\nret += tcrypt_test("michael_mic");\r\nbreak;\r\ncase 18:\r\nret += tcrypt_test("crc32c");\r\nbreak;\r\ncase 19:\r\nret += tcrypt_test("ecb(tea)");\r\nbreak;\r\ncase 20:\r\nret += tcrypt_test("ecb(xtea)");\r\nbreak;\r\ncase 21:\r\nret += tcrypt_test("ecb(khazad)");\r\nbreak;\r\ncase 22:\r\nret += tcrypt_test("wp512");\r\nbreak;\r\ncase 23:\r\nret += tcrypt_test("wp384");\r\nbreak;\r\ncase 24:\r\nret += tcrypt_test("wp256");\r\nbreak;\r\ncase 25:\r\nret += tcrypt_test("ecb(tnepres)");\r\nbreak;\r\ncase 26:\r\nret += tcrypt_test("ecb(anubis)");\r\nret += tcrypt_test("cbc(anubis)");\r\nbreak;\r\ncase 27:\r\nret += tcrypt_test("tgr192");\r\nbreak;\r\ncase 28:\r\nret += tcrypt_test("tgr160");\r\nbreak;\r\ncase 29:\r\nret += tcrypt_test("tgr128");\r\nbreak;\r\ncase 30:\r\nret += tcrypt_test("ecb(xeta)");\r\nbreak;\r\ncase 31:\r\nret += tcrypt_test("pcbc(fcrypt)");\r\nbreak;\r\ncase 32:\r\nret += tcrypt_test("ecb(camellia)");\r\nret += tcrypt_test("cbc(camellia)");\r\nret += tcrypt_test("ctr(camellia)");\r\nret += tcrypt_test("lrw(camellia)");\r\nret += tcrypt_test("xts(camellia)");\r\nbreak;\r\ncase 33:\r\nret += tcrypt_test("sha224");\r\nbreak;\r\ncase 34:\r\nret += tcrypt_test("salsa20");\r\nbreak;\r\ncase 35:\r\nret += tcrypt_test("gcm(aes)");\r\nbreak;\r\ncase 36:\r\nret += tcrypt_test("lzo");\r\nbreak;\r\ncase 37:\r\nret += tcrypt_test("ccm(aes)");\r\nbreak;\r\ncase 38:\r\nret += tcrypt_test("cts(cbc(aes))");\r\nbreak;\r\ncase 39:\r\nret += tcrypt_test("rmd128");\r\nbreak;\r\ncase 40:\r\nret += tcrypt_test("rmd160");\r\nbreak;\r\ncase 41:\r\nret += tcrypt_test("rmd256");\r\nbreak;\r\ncase 42:\r\nret += tcrypt_test("rmd320");\r\nbreak;\r\ncase 43:\r\nret += tcrypt_test("ecb(seed)");\r\nbreak;\r\ncase 44:\r\nret += tcrypt_test("zlib");\r\nbreak;\r\ncase 45:\r\nret += tcrypt_test("rfc4309(ccm(aes))");\r\nbreak;\r\ncase 46:\r\nret += tcrypt_test("ghash");\r\nbreak;\r\ncase 47:\r\nret += tcrypt_test("crct10dif");\r\nbreak;\r\ncase 100:\r\nret += tcrypt_test("hmac(md5)");\r\nbreak;\r\ncase 101:\r\nret += tcrypt_test("hmac(sha1)");\r\nbreak;\r\ncase 102:\r\nret += tcrypt_test("hmac(sha256)");\r\nbreak;\r\ncase 103:\r\nret += tcrypt_test("hmac(sha384)");\r\nbreak;\r\ncase 104:\r\nret += tcrypt_test("hmac(sha512)");\r\nbreak;\r\ncase 105:\r\nret += tcrypt_test("hmac(sha224)");\r\nbreak;\r\ncase 106:\r\nret += tcrypt_test("xcbc(aes)");\r\nbreak;\r\ncase 107:\r\nret += tcrypt_test("hmac(rmd128)");\r\nbreak;\r\ncase 108:\r\nret += tcrypt_test("hmac(rmd160)");\r\nbreak;\r\ncase 109:\r\nret += tcrypt_test("vmac(aes)");\r\nbreak;\r\ncase 110:\r\nret += tcrypt_test("hmac(crc32)");\r\nbreak;\r\ncase 150:\r\nret += tcrypt_test("ansi_cprng");\r\nbreak;\r\ncase 151:\r\nret += tcrypt_test("rfc4106(gcm(aes))");\r\nbreak;\r\ncase 152:\r\nret += tcrypt_test("rfc4543(gcm(aes))");\r\nbreak;\r\ncase 153:\r\nret += tcrypt_test("cmac(aes)");\r\nbreak;\r\ncase 154:\r\nret += tcrypt_test("cmac(des3_ede)");\r\nbreak;\r\ncase 155:\r\nret += tcrypt_test("authenc(hmac(sha1),cbc(aes))");\r\nbreak;\r\ncase 156:\r\nret += tcrypt_test("authenc(hmac(md5),ecb(cipher_null))");\r\nbreak;\r\ncase 157:\r\nret += tcrypt_test("authenc(hmac(sha1),ecb(cipher_null))");\r\nbreak;\r\ncase 181:\r\nret += tcrypt_test("authenc(hmac(sha1),cbc(des))");\r\nbreak;\r\ncase 182:\r\nret += tcrypt_test("authenc(hmac(sha1),cbc(des3_ede))");\r\nbreak;\r\ncase 183:\r\nret += tcrypt_test("authenc(hmac(sha224),cbc(des))");\r\nbreak;\r\ncase 184:\r\nret += tcrypt_test("authenc(hmac(sha224),cbc(des3_ede))");\r\nbreak;\r\ncase 185:\r\nret += tcrypt_test("authenc(hmac(sha256),cbc(des))");\r\nbreak;\r\ncase 186:\r\nret += tcrypt_test("authenc(hmac(sha256),cbc(des3_ede))");\r\nbreak;\r\ncase 187:\r\nret += tcrypt_test("authenc(hmac(sha384),cbc(des))");\r\nbreak;\r\ncase 188:\r\nret += tcrypt_test("authenc(hmac(sha384),cbc(des3_ede))");\r\nbreak;\r\ncase 189:\r\nret += tcrypt_test("authenc(hmac(sha512),cbc(des))");\r\nbreak;\r\ncase 190:\r\nret += tcrypt_test("authenc(hmac(sha512),cbc(des3_ede))");\r\nbreak;\r\ncase 200:\r\ntest_cipher_speed("ecb(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("ecb(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("cbc(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("cbc(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("lrw(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_cipher_speed("lrw(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_cipher_speed("xts(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\ntest_cipher_speed("xts(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\ntest_cipher_speed("ctr(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("ctr(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\nbreak;\r\ncase 201:\r\ntest_cipher_speed("ecb(des3_ede)", ENCRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_cipher_speed("ecb(des3_ede)", DECRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_cipher_speed("cbc(des3_ede)", ENCRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_cipher_speed("cbc(des3_ede)", DECRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_cipher_speed("ctr(des3_ede)", ENCRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_cipher_speed("ctr(des3_ede)", DECRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\nbreak;\r\ncase 202:\r\ntest_cipher_speed("ecb(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("ecb(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("cbc(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("cbc(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("ctr(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("ctr(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("lrw(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_cipher_speed("lrw(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_cipher_speed("xts(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\ntest_cipher_speed("xts(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\nbreak;\r\ncase 203:\r\ntest_cipher_speed("ecb(blowfish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_cipher_speed("ecb(blowfish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_cipher_speed("cbc(blowfish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_cipher_speed("cbc(blowfish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_cipher_speed("ctr(blowfish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_cipher_speed("ctr(blowfish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\nbreak;\r\ncase 204:\r\ntest_cipher_speed("ecb(des)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_cipher_speed("ecb(des)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_cipher_speed("cbc(des)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_cipher_speed("cbc(des)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\nbreak;\r\ncase 205:\r\ntest_cipher_speed("ecb(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("ecb(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("cbc(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("cbc(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("ctr(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("ctr(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_cipher_speed("lrw(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_cipher_speed("lrw(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_cipher_speed("xts(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\ntest_cipher_speed("xts(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\nbreak;\r\ncase 206:\r\ntest_cipher_speed("salsa20", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\nbreak;\r\ncase 207:\r\ntest_cipher_speed("ecb(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("ecb(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("cbc(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("cbc(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("ctr(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("ctr(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("lrw(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_cipher_speed("lrw(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_cipher_speed("xts(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\ntest_cipher_speed("xts(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\nbreak;\r\ncase 208:\r\ntest_cipher_speed("ecb(arc4)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\nbreak;\r\ncase 209:\r\ntest_cipher_speed("ecb(cast5)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_cipher_speed("ecb(cast5)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_cipher_speed("cbc(cast5)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_cipher_speed("cbc(cast5)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_cipher_speed("ctr(cast5)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_cipher_speed("ctr(cast5)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\nbreak;\r\ncase 210:\r\ntest_cipher_speed("ecb(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("ecb(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("cbc(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("cbc(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("ctr(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("ctr(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_cipher_speed("lrw(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_cipher_speed("lrw(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_cipher_speed("xts(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\ntest_cipher_speed("xts(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\nbreak;\r\ncase 211:\r\ntest_aead_speed("rfc4106(gcm(aes))", ENCRYPT, sec,\r\nNULL, 0, 16, 8, aead_speed_template_20);\r\nbreak;\r\ncase 300:\r\ncase 301:\r\ntest_hash_speed("md4", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 302:\r\ntest_hash_speed("md5", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 303:\r\ntest_hash_speed("sha1", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 304:\r\ntest_hash_speed("sha256", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 305:\r\ntest_hash_speed("sha384", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 306:\r\ntest_hash_speed("sha512", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 307:\r\ntest_hash_speed("wp256", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 308:\r\ntest_hash_speed("wp384", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 309:\r\ntest_hash_speed("wp512", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 310:\r\ntest_hash_speed("tgr128", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 311:\r\ntest_hash_speed("tgr160", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 312:\r\ntest_hash_speed("tgr192", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 313:\r\ntest_hash_speed("sha224", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 314:\r\ntest_hash_speed("rmd128", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 315:\r\ntest_hash_speed("rmd160", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 316:\r\ntest_hash_speed("rmd256", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 317:\r\ntest_hash_speed("rmd320", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 318:\r\ntest_hash_speed("ghash-generic", sec, hash_speed_template_16);\r\nif (mode > 300 && mode < 400) break;\r\ncase 319:\r\ntest_hash_speed("crc32c", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 320:\r\ntest_hash_speed("crct10dif", sec, generic_hash_speed_template);\r\nif (mode > 300 && mode < 400) break;\r\ncase 399:\r\nbreak;\r\ncase 400:\r\ncase 401:\r\ntest_ahash_speed("md4", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 402:\r\ntest_ahash_speed("md5", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 403:\r\ntest_ahash_speed("sha1", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 404:\r\ntest_ahash_speed("sha256", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 405:\r\ntest_ahash_speed("sha384", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 406:\r\ntest_ahash_speed("sha512", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 407:\r\ntest_ahash_speed("wp256", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 408:\r\ntest_ahash_speed("wp384", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 409:\r\ntest_ahash_speed("wp512", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 410:\r\ntest_ahash_speed("tgr128", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 411:\r\ntest_ahash_speed("tgr160", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 412:\r\ntest_ahash_speed("tgr192", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 413:\r\ntest_ahash_speed("sha224", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 414:\r\ntest_ahash_speed("rmd128", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 415:\r\ntest_ahash_speed("rmd160", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 416:\r\ntest_ahash_speed("rmd256", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 417:\r\ntest_ahash_speed("rmd320", sec, generic_hash_speed_template);\r\nif (mode > 400 && mode < 500) break;\r\ncase 499:\r\nbreak;\r\ncase 500:\r\ntest_acipher_speed("ecb(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("ecb(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("cbc(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("cbc(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("lrw(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_acipher_speed("lrw(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_acipher_speed("xts(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\ntest_acipher_speed("xts(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\ntest_acipher_speed("ctr(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("ctr(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("cfb(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("cfb(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("ofb(aes)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("ofb(aes)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("rfc3686(ctr(aes))", ENCRYPT, sec, NULL, 0,\r\nspeed_template_20_28_36);\r\ntest_acipher_speed("rfc3686(ctr(aes))", DECRYPT, sec, NULL, 0,\r\nspeed_template_20_28_36);\r\nbreak;\r\ncase 501:\r\ntest_acipher_speed("ecb(des3_ede)", ENCRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_acipher_speed("ecb(des3_ede)", DECRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_acipher_speed("cbc(des3_ede)", ENCRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_acipher_speed("cbc(des3_ede)", DECRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_acipher_speed("cfb(des3_ede)", ENCRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_acipher_speed("cfb(des3_ede)", DECRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_acipher_speed("ofb(des3_ede)", ENCRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\ntest_acipher_speed("ofb(des3_ede)", DECRYPT, sec,\r\ndes3_speed_template, DES3_SPEED_VECTORS,\r\nspeed_template_24);\r\nbreak;\r\ncase 502:\r\ntest_acipher_speed("ecb(des)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_acipher_speed("ecb(des)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_acipher_speed("cbc(des)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_acipher_speed("cbc(des)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_acipher_speed("cfb(des)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_acipher_speed("cfb(des)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_acipher_speed("ofb(des)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\ntest_acipher_speed("ofb(des)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\nbreak;\r\ncase 503:\r\ntest_acipher_speed("ecb(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ecb(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("cbc(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("cbc(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ctr(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ctr(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("lrw(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_acipher_speed("lrw(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_acipher_speed("xts(serpent)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\ntest_acipher_speed("xts(serpent)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\nbreak;\r\ncase 504:\r\ntest_acipher_speed("ecb(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("ecb(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("cbc(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("cbc(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("ctr(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("ctr(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_24_32);\r\ntest_acipher_speed("lrw(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_acipher_speed("lrw(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_40_48);\r\ntest_acipher_speed("xts(twofish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\ntest_acipher_speed("xts(twofish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48_64);\r\nbreak;\r\ncase 505:\r\ntest_acipher_speed("ecb(arc4)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8);\r\nbreak;\r\ncase 506:\r\ntest_acipher_speed("ecb(cast5)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_acipher_speed("ecb(cast5)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_acipher_speed("cbc(cast5)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_acipher_speed("cbc(cast5)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_acipher_speed("ctr(cast5)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\ntest_acipher_speed("ctr(cast5)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_16);\r\nbreak;\r\ncase 507:\r\ntest_acipher_speed("ecb(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ecb(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("cbc(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("cbc(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ctr(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ctr(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("lrw(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_acipher_speed("lrw(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_acipher_speed("xts(cast6)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\ntest_acipher_speed("xts(cast6)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\nbreak;\r\ncase 508:\r\ntest_acipher_speed("ecb(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ecb(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("cbc(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("cbc(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ctr(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("ctr(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_16_32);\r\ntest_acipher_speed("lrw(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_acipher_speed("lrw(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_48);\r\ntest_acipher_speed("xts(camellia)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\ntest_acipher_speed("xts(camellia)", DECRYPT, sec, NULL, 0,\r\nspeed_template_32_64);\r\nbreak;\r\ncase 509:\r\ntest_acipher_speed("ecb(blowfish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_acipher_speed("ecb(blowfish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_acipher_speed("cbc(blowfish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_acipher_speed("cbc(blowfish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_acipher_speed("ctr(blowfish)", ENCRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\ntest_acipher_speed("ctr(blowfish)", DECRYPT, sec, NULL, 0,\r\nspeed_template_8_32);\r\nbreak;\r\ncase 1000:\r\ntest_available();\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int do_alg_test(const char *alg, u32 type, u32 mask)\r\n{\r\nreturn crypto_has_alg(alg, type, mask ?: CRYPTO_ALG_TYPE_MASK) ?\r\n0 : -ENOENT;\r\n}\r\nstatic int __init tcrypt_mod_init(void)\r\n{\r\nint err = -ENOMEM;\r\nint i;\r\nfor (i = 0; i < TVMEMSIZE; i++) {\r\ntvmem[i] = (void *)__get_free_page(GFP_KERNEL);\r\nif (!tvmem[i])\r\ngoto err_free_tv;\r\n}\r\nif (alg)\r\nerr = do_alg_test(alg, type, mask);\r\nelse\r\nerr = do_test(mode);\r\nif (err) {\r\nprintk(KERN_ERR "tcrypt: one or more tests failed!\n");\r\ngoto err_free_tv;\r\n}\r\nif (!fips_enabled)\r\nerr = -EAGAIN;\r\nerr_free_tv:\r\nfor (i = 0; i < TVMEMSIZE && tvmem[i]; i++)\r\nfree_page((unsigned long)tvmem[i]);\r\nreturn err;\r\n}\r\nstatic void __exit tcrypt_mod_fini(void) { }
