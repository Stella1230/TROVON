static void snd_midi_input_event(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct snd_rawmidi_runtime *runtime;\r\nstruct seq_midisynth *msynth;\r\nstruct snd_seq_event ev;\r\nchar buf[16], *pbuf;\r\nlong res, count;\r\nif (substream == NULL)\r\nreturn;\r\nruntime = substream->runtime;\r\nmsynth = runtime->private_data;\r\nif (msynth == NULL)\r\nreturn;\r\nmemset(&ev, 0, sizeof(ev));\r\nwhile (runtime->avail > 0) {\r\nres = snd_rawmidi_kernel_read(substream, buf, sizeof(buf));\r\nif (res <= 0)\r\ncontinue;\r\nif (msynth->parser == NULL)\r\ncontinue;\r\npbuf = buf;\r\nwhile (res > 0) {\r\ncount = snd_midi_event_encode(msynth->parser, pbuf, res, &ev);\r\nif (count < 0)\r\nbreak;\r\npbuf += count;\r\nres -= count;\r\nif (ev.type != SNDRV_SEQ_EVENT_NONE) {\r\nev.source.port = msynth->seq_port;\r\nev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\r\nsnd_seq_kernel_client_dispatch(msynth->seq_client, &ev, 1, 0);\r\nmemset(&ev, 0, sizeof(ev));\r\n}\r\n}\r\n}\r\n}\r\nstatic int dump_midi(struct snd_rawmidi_substream *substream, const char *buf, int count)\r\n{\r\nstruct snd_rawmidi_runtime *runtime;\r\nint tmp;\r\nif (snd_BUG_ON(!substream || !buf))\r\nreturn -EINVAL;\r\nruntime = substream->runtime;\r\nif ((tmp = runtime->avail) < count) {\r\nif (printk_ratelimit())\r\npr_err("ALSA: seq_midi: MIDI output buffer overrun\n");\r\nreturn -ENOMEM;\r\n}\r\nif (snd_rawmidi_kernel_write(substream, buf, count) < count)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int event_process_midi(struct snd_seq_event *ev, int direct,\r\nvoid *private_data, int atomic, int hop)\r\n{\r\nstruct seq_midisynth *msynth = private_data;\r\nunsigned char msg[10];\r\nstruct snd_rawmidi_substream *substream;\r\nint len;\r\nif (snd_BUG_ON(!msynth))\r\nreturn -EINVAL;\r\nsubstream = msynth->output_rfile.output;\r\nif (substream == NULL)\r\nreturn -ENODEV;\r\nif (ev->type == SNDRV_SEQ_EVENT_SYSEX) {\r\nif ((ev->flags & SNDRV_SEQ_EVENT_LENGTH_MASK) != SNDRV_SEQ_EVENT_LENGTH_VARIABLE) {\r\npr_debug("ALSA: seq_midi: invalid sysex event flags = 0x%x\n", ev->flags);\r\nreturn 0;\r\n}\r\nsnd_seq_dump_var_event(ev, (snd_seq_dump_func_t)dump_midi, substream);\r\nsnd_midi_event_reset_decode(msynth->parser);\r\n} else {\r\nif (msynth->parser == NULL)\r\nreturn -EIO;\r\nlen = snd_midi_event_decode(msynth->parser, msg, sizeof(msg), ev);\r\nif (len < 0)\r\nreturn 0;\r\nif (dump_midi(substream, msg, len) < 0)\r\nsnd_midi_event_reset_decode(msynth->parser);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_seq_midisynth_new(struct seq_midisynth *msynth,\r\nstruct snd_card *card,\r\nint device,\r\nint subdevice)\r\n{\r\nif (snd_midi_event_new(MAX_MIDI_EVENT_BUF, &msynth->parser) < 0)\r\nreturn -ENOMEM;\r\nmsynth->card = card;\r\nmsynth->device = device;\r\nmsynth->subdevice = subdevice;\r\nreturn 0;\r\n}\r\nstatic int midisynth_subscribe(void *private_data, struct snd_seq_port_subscribe *info)\r\n{\r\nint err;\r\nstruct seq_midisynth *msynth = private_data;\r\nstruct snd_rawmidi_runtime *runtime;\r\nstruct snd_rawmidi_params params;\r\nif ((err = snd_rawmidi_kernel_open(msynth->card, msynth->device,\r\nmsynth->subdevice,\r\nSNDRV_RAWMIDI_LFLG_INPUT,\r\n&msynth->input_rfile)) < 0) {\r\npr_debug("ALSA: seq_midi: midi input open failed!!!\n");\r\nreturn err;\r\n}\r\nruntime = msynth->input_rfile.input->runtime;\r\nmemset(&params, 0, sizeof(params));\r\nparams.avail_min = 1;\r\nparams.buffer_size = input_buffer_size;\r\nif ((err = snd_rawmidi_input_params(msynth->input_rfile.input, &params)) < 0) {\r\nsnd_rawmidi_kernel_release(&msynth->input_rfile);\r\nreturn err;\r\n}\r\nsnd_midi_event_reset_encode(msynth->parser);\r\nruntime->event = snd_midi_input_event;\r\nruntime->private_data = msynth;\r\nsnd_rawmidi_kernel_read(msynth->input_rfile.input, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic int midisynth_unsubscribe(void *private_data, struct snd_seq_port_subscribe *info)\r\n{\r\nint err;\r\nstruct seq_midisynth *msynth = private_data;\r\nif (snd_BUG_ON(!msynth->input_rfile.input))\r\nreturn -EINVAL;\r\nerr = snd_rawmidi_kernel_release(&msynth->input_rfile);\r\nreturn err;\r\n}\r\nstatic int midisynth_use(void *private_data, struct snd_seq_port_subscribe *info)\r\n{\r\nint err;\r\nstruct seq_midisynth *msynth = private_data;\r\nstruct snd_rawmidi_params params;\r\nif ((err = snd_rawmidi_kernel_open(msynth->card, msynth->device,\r\nmsynth->subdevice,\r\nSNDRV_RAWMIDI_LFLG_OUTPUT,\r\n&msynth->output_rfile)) < 0) {\r\npr_debug("ALSA: seq_midi: midi output open failed!!!\n");\r\nreturn err;\r\n}\r\nmemset(&params, 0, sizeof(params));\r\nparams.avail_min = 1;\r\nparams.buffer_size = output_buffer_size;\r\nparams.no_active_sensing = 1;\r\nif ((err = snd_rawmidi_output_params(msynth->output_rfile.output, &params)) < 0) {\r\nsnd_rawmidi_kernel_release(&msynth->output_rfile);\r\nreturn err;\r\n}\r\nsnd_midi_event_reset_decode(msynth->parser);\r\nreturn 0;\r\n}\r\nstatic int midisynth_unuse(void *private_data, struct snd_seq_port_subscribe *info)\r\n{\r\nstruct seq_midisynth *msynth = private_data;\r\nif (snd_BUG_ON(!msynth->output_rfile.output))\r\nreturn -EINVAL;\r\nsnd_rawmidi_drain_output(msynth->output_rfile.output);\r\nreturn snd_rawmidi_kernel_release(&msynth->output_rfile);\r\n}\r\nstatic void snd_seq_midisynth_delete(struct seq_midisynth *msynth)\r\n{\r\nif (msynth == NULL)\r\nreturn;\r\nif (msynth->seq_client > 0) {\r\nsnd_seq_event_port_detach(msynth->seq_client, msynth->seq_port);\r\n}\r\nif (msynth->parser)\r\nsnd_midi_event_free(msynth->parser);\r\n}\r\nstatic int\r\nsnd_seq_midisynth_register_port(struct snd_seq_device *dev)\r\n{\r\nstruct seq_midisynth_client *client;\r\nstruct seq_midisynth *msynth, *ms;\r\nstruct snd_seq_port_info *port;\r\nstruct snd_rawmidi_info *info;\r\nstruct snd_rawmidi *rmidi = dev->private_data;\r\nint newclient = 0;\r\nunsigned int p, ports;\r\nstruct snd_seq_port_callback pcallbacks;\r\nstruct snd_card *card = dev->card;\r\nint device = dev->device;\r\nunsigned int input_count = 0, output_count = 0;\r\nif (snd_BUG_ON(!card || device < 0 || device >= SNDRV_RAWMIDI_DEVICES))\r\nreturn -EINVAL;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (! info)\r\nreturn -ENOMEM;\r\ninfo->device = device;\r\ninfo->stream = SNDRV_RAWMIDI_STREAM_OUTPUT;\r\ninfo->subdevice = 0;\r\nif (snd_rawmidi_info_select(card, info) >= 0)\r\noutput_count = info->subdevices_count;\r\ninfo->stream = SNDRV_RAWMIDI_STREAM_INPUT;\r\nif (snd_rawmidi_info_select(card, info) >= 0) {\r\ninput_count = info->subdevices_count;\r\n}\r\nports = output_count;\r\nif (ports < input_count)\r\nports = input_count;\r\nif (ports == 0) {\r\nkfree(info);\r\nreturn -ENODEV;\r\n}\r\nif (ports > (256 / SNDRV_RAWMIDI_DEVICES))\r\nports = 256 / SNDRV_RAWMIDI_DEVICES;\r\nmutex_lock(&register_mutex);\r\nclient = synths[card->number];\r\nif (client == NULL) {\r\nnewclient = 1;\r\nclient = kzalloc(sizeof(*client), GFP_KERNEL);\r\nif (client == NULL) {\r\nmutex_unlock(&register_mutex);\r\nkfree(info);\r\nreturn -ENOMEM;\r\n}\r\nclient->seq_client =\r\nsnd_seq_create_kernel_client(\r\ncard, 0, "%s", card->shortname[0] ?\r\n(const char *)card->shortname : "External MIDI");\r\nif (client->seq_client < 0) {\r\nkfree(client);\r\nmutex_unlock(&register_mutex);\r\nkfree(info);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmsynth = kcalloc(ports, sizeof(struct seq_midisynth), GFP_KERNEL);\r\nport = kmalloc(sizeof(*port), GFP_KERNEL);\r\nif (msynth == NULL || port == NULL)\r\ngoto __nomem;\r\nfor (p = 0; p < ports; p++) {\r\nms = &msynth[p];\r\nif (snd_seq_midisynth_new(ms, card, device, p) < 0)\r\ngoto __nomem;\r\nmemset(port, 0, sizeof(*port));\r\nport->addr.client = client->seq_client;\r\nport->addr.port = device * (256 / SNDRV_RAWMIDI_DEVICES) + p;\r\nport->flags = SNDRV_SEQ_PORT_FLG_GIVEN_PORT;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->device = device;\r\nif (p < output_count)\r\ninfo->stream = SNDRV_RAWMIDI_STREAM_OUTPUT;\r\nelse\r\ninfo->stream = SNDRV_RAWMIDI_STREAM_INPUT;\r\ninfo->subdevice = p;\r\nif (snd_rawmidi_info_select(card, info) >= 0)\r\nstrcpy(port->name, info->subname);\r\nif (! port->name[0]) {\r\nif (info->name[0]) {\r\nif (ports > 1)\r\nsnprintf(port->name, sizeof(port->name), "%s-%u", info->name, p);\r\nelse\r\nsnprintf(port->name, sizeof(port->name), "%s", info->name);\r\n} else {\r\nif (ports > 1)\r\nsprintf(port->name, "MIDI %d-%d-%u", card->number, device, p);\r\nelse\r\nsprintf(port->name, "MIDI %d-%d", card->number, device);\r\n}\r\n}\r\nif ((info->flags & SNDRV_RAWMIDI_INFO_OUTPUT) && p < output_count)\r\nport->capability |= SNDRV_SEQ_PORT_CAP_WRITE | SNDRV_SEQ_PORT_CAP_SYNC_WRITE | SNDRV_SEQ_PORT_CAP_SUBS_WRITE;\r\nif ((info->flags & SNDRV_RAWMIDI_INFO_INPUT) && p < input_count)\r\nport->capability |= SNDRV_SEQ_PORT_CAP_READ | SNDRV_SEQ_PORT_CAP_SYNC_READ | SNDRV_SEQ_PORT_CAP_SUBS_READ;\r\nif ((port->capability & (SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_READ)) == (SNDRV_SEQ_PORT_CAP_WRITE|SNDRV_SEQ_PORT_CAP_READ) &&\r\ninfo->flags & SNDRV_RAWMIDI_INFO_DUPLEX)\r\nport->capability |= SNDRV_SEQ_PORT_CAP_DUPLEX;\r\nport->type = SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC\r\n| SNDRV_SEQ_PORT_TYPE_HARDWARE\r\n| SNDRV_SEQ_PORT_TYPE_PORT;\r\nport->midi_channels = 16;\r\nmemset(&pcallbacks, 0, sizeof(pcallbacks));\r\npcallbacks.owner = THIS_MODULE;\r\npcallbacks.private_data = ms;\r\npcallbacks.subscribe = midisynth_subscribe;\r\npcallbacks.unsubscribe = midisynth_unsubscribe;\r\npcallbacks.use = midisynth_use;\r\npcallbacks.unuse = midisynth_unuse;\r\npcallbacks.event_input = event_process_midi;\r\nport->kernel = &pcallbacks;\r\nif (rmidi->ops && rmidi->ops->get_port_info)\r\nrmidi->ops->get_port_info(rmidi, p, port);\r\nif (snd_seq_kernel_client_ctl(client->seq_client, SNDRV_SEQ_IOCTL_CREATE_PORT, port)<0)\r\ngoto __nomem;\r\nms->seq_client = client->seq_client;\r\nms->seq_port = port->addr.port;\r\n}\r\nclient->ports_per_device[device] = ports;\r\nclient->ports[device] = msynth;\r\nclient->num_ports++;\r\nif (newclient)\r\nsynths[card->number] = client;\r\nmutex_unlock(&register_mutex);\r\nkfree(info);\r\nkfree(port);\r\nreturn 0;\r\n__nomem:\r\nif (msynth != NULL) {\r\nfor (p = 0; p < ports; p++)\r\nsnd_seq_midisynth_delete(&msynth[p]);\r\nkfree(msynth);\r\n}\r\nif (newclient) {\r\nsnd_seq_delete_kernel_client(client->seq_client);\r\nkfree(client);\r\n}\r\nkfree(info);\r\nkfree(port);\r\nmutex_unlock(&register_mutex);\r\nreturn -ENOMEM;\r\n}\r\nstatic int\r\nsnd_seq_midisynth_unregister_port(struct snd_seq_device *dev)\r\n{\r\nstruct seq_midisynth_client *client;\r\nstruct seq_midisynth *msynth;\r\nstruct snd_card *card = dev->card;\r\nint device = dev->device, p, ports;\r\nmutex_lock(&register_mutex);\r\nclient = synths[card->number];\r\nif (client == NULL || client->ports[device] == NULL) {\r\nmutex_unlock(&register_mutex);\r\nreturn -ENODEV;\r\n}\r\nports = client->ports_per_device[device];\r\nclient->ports_per_device[device] = 0;\r\nmsynth = client->ports[device];\r\nclient->ports[device] = NULL;\r\nfor (p = 0; p < ports; p++)\r\nsnd_seq_midisynth_delete(&msynth[p]);\r\nkfree(msynth);\r\nclient->num_ports--;\r\nif (client->num_ports <= 0) {\r\nsnd_seq_delete_kernel_client(client->seq_client);\r\nsynths[card->number] = NULL;\r\nkfree(client);\r\n}\r\nmutex_unlock(&register_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_seq_midi_init(void)\r\n{\r\nstatic struct snd_seq_dev_ops ops = {\r\nsnd_seq_midisynth_register_port,\r\nsnd_seq_midisynth_unregister_port,\r\n};\r\nmemset(&synths, 0, sizeof(synths));\r\nsnd_seq_autoload_lock();\r\nsnd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_MIDISYNTH, &ops, 0);\r\nsnd_seq_autoload_unlock();\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_seq_midi_exit(void)\r\n{\r\nsnd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_MIDISYNTH);\r\n}
