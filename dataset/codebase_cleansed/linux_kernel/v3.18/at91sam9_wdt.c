static irqreturn_t wdt_interrupt(int irq, void *dev_id)\r\n{\r\nstruct at91wdt *wdt = (struct at91wdt *)dev_id;\r\nif (wdt_read(wdt, AT91_WDT_SR)) {\r\npr_crit("at91sam9 WDT software reset\n");\r\nemergency_restart();\r\npr_crit("Reboot didn't ?????\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void at91_wdt_reset(struct at91wdt *wdt)\r\n{\r\nwdt_write(wdt, AT91_WDT_CR, AT91_WDT_KEY | AT91_WDT_WDRSTT);\r\n}\r\nstatic void at91_ping(unsigned long data)\r\n{\r\nstruct at91wdt *wdt = (struct at91wdt *)data;\r\nif (time_before(jiffies, wdt->next_heartbeat) ||\r\n!watchdog_active(&wdt->wdd)) {\r\nat91_wdt_reset(wdt);\r\nmod_timer(&wdt->timer, jiffies + wdt->heartbeat);\r\n} else {\r\npr_crit("I will reset your machine !\n");\r\n}\r\n}\r\nstatic int at91_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct at91wdt *wdt = to_wdt(wdd);\r\nwdt->next_heartbeat = jiffies + wdd->timeout * HZ;\r\nreturn 0;\r\n}\r\nstatic int at91_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int at91_wdt_set_timeout(struct watchdog_device *wdd, unsigned int new_timeout)\r\n{\r\nwdd->timeout = new_timeout;\r\nreturn at91_wdt_start(wdd);\r\n}\r\nstatic int at91_wdt_init(struct platform_device *pdev, struct at91wdt *wdt)\r\n{\r\nu32 tmp;\r\nu32 delta;\r\nu32 value;\r\nint err;\r\nu32 mask = wdt->mr_mask;\r\nunsigned long min_heartbeat = 1;\r\nunsigned long max_heartbeat;\r\nstruct device *dev = &pdev->dev;\r\ntmp = wdt_read(wdt, AT91_WDT_MR);\r\nif ((tmp & mask) != (wdt->mr & mask)) {\r\nif (tmp == WDT_MR_RESET) {\r\nwdt_write(wdt, AT91_WDT_MR, wdt->mr);\r\ntmp = wdt_read(wdt, AT91_WDT_MR);\r\n}\r\n}\r\nif (tmp & AT91_WDT_WDDIS) {\r\nif (wdt->mr & AT91_WDT_WDDIS)\r\nreturn 0;\r\ndev_err(dev, "watchdog is disabled\n");\r\nreturn -EINVAL;\r\n}\r\nvalue = tmp & AT91_WDT_WDV;\r\ndelta = (tmp & AT91_WDT_WDD) >> 16;\r\nif (delta < value)\r\nmin_heartbeat = ticks_to_hz_roundup(value - delta);\r\nmax_heartbeat = ticks_to_hz_rounddown(value);\r\nif (!max_heartbeat) {\r\ndev_err(dev,\r\n"heartbeat is too small for the system to handle it correctly\n");\r\nreturn -EINVAL;\r\n}\r\nif ((max_heartbeat / 4) >= min_heartbeat)\r\nwdt->heartbeat = max_heartbeat / 4;\r\nelse if ((max_heartbeat / 2) >= min_heartbeat)\r\nwdt->heartbeat = max_heartbeat / 2;\r\nelse\r\nwdt->heartbeat = min_heartbeat;\r\nif (max_heartbeat < min_heartbeat + 4)\r\ndev_warn(dev,\r\n"min heartbeat and max heartbeat might be too close for the system to handle it correctly\n");\r\nif ((tmp & AT91_WDT_WDFIEN) && wdt->irq) {\r\nerr = request_irq(wdt->irq, wdt_interrupt,\r\nIRQF_SHARED | IRQF_IRQPOLL,\r\npdev->name, wdt);\r\nif (err)\r\nreturn err;\r\n}\r\nif ((tmp & wdt->mr_mask) != (wdt->mr & wdt->mr_mask))\r\ndev_warn(dev,\r\n"watchdog already configured differently (mr = %x expecting %x)\n",\r\ntmp & wdt->mr_mask, wdt->mr & wdt->mr_mask);\r\nsetup_timer(&wdt->timer, at91_ping, (unsigned long)wdt);\r\nmod_timer(&wdt->timer, jiffies + min_heartbeat);\r\nif (watchdog_init_timeout(&wdt->wdd, 0, dev))\r\nwatchdog_init_timeout(&wdt->wdd, heartbeat, dev);\r\nwatchdog_set_nowayout(&wdt->wdd, wdt->nowayout);\r\nerr = watchdog_register_device(&wdt->wdd);\r\nif (err)\r\ngoto out_stop_timer;\r\nwdt->next_heartbeat = jiffies + wdt->wdd.timeout * HZ;\r\nreturn 0;\r\nout_stop_timer:\r\ndel_timer(&wdt->timer);\r\nreturn err;\r\n}\r\nstatic int of_at91wdt_init(struct device_node *np, struct at91wdt *wdt)\r\n{\r\nu32 min = 0;\r\nu32 max = WDT_COUNTER_MAX_SECS;\r\nconst char *tmp;\r\nwdt->irq = irq_of_parse_and_map(np, 0);\r\nif (!wdt->irq)\r\ndev_warn(wdt->wdd.parent, "failed to get IRQ from DT\n");\r\nif (!of_property_read_u32_index(np, "atmel,max-heartbeat-sec", 0,\r\n&max)) {\r\nif (!max || max > WDT_COUNTER_MAX_SECS)\r\nmax = WDT_COUNTER_MAX_SECS;\r\nif (!of_property_read_u32_index(np, "atmel,min-heartbeat-sec",\r\n0, &min)) {\r\nif (min >= max)\r\nmin = max - 1;\r\n}\r\n}\r\nmin = secs_to_ticks(min);\r\nmax = secs_to_ticks(max);\r\nwdt->mr_mask = 0x3FFFFFFF;\r\nwdt->mr = 0;\r\nif (!of_property_read_string(np, "atmel,watchdog-type", &tmp) &&\r\n!strcmp(tmp, "software")) {\r\nwdt->mr |= AT91_WDT_WDFIEN;\r\nwdt->mr_mask &= ~AT91_WDT_WDRPROC;\r\n} else {\r\nwdt->mr |= AT91_WDT_WDRSTEN;\r\n}\r\nif (!of_property_read_string(np, "atmel,reset-type", &tmp) &&\r\n!strcmp(tmp, "proc"))\r\nwdt->mr |= AT91_WDT_WDRPROC;\r\nif (of_property_read_bool(np, "atmel,disable")) {\r\nwdt->mr |= AT91_WDT_WDDIS;\r\nwdt->mr_mask &= AT91_WDT_WDDIS;\r\n}\r\nif (of_property_read_bool(np, "atmel,idle-halt"))\r\nwdt->mr |= AT91_WDT_WDIDLEHLT;\r\nif (of_property_read_bool(np, "atmel,dbg-halt"))\r\nwdt->mr |= AT91_WDT_WDDBGHLT;\r\nwdt->mr |= max | ((max - min) << 16);\r\nreturn 0;\r\n}\r\nstatic inline int of_at91wdt_init(struct device_node *np, struct at91wdt *wdt)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init at91wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nint err;\r\nstruct at91wdt *wdt;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nwdt->mr = (WDT_HW_TIMEOUT * 256) | AT91_WDT_WDRSTEN | AT91_WDT_WDD |\r\nAT91_WDT_WDDBGHLT | AT91_WDT_WDIDLEHLT;\r\nwdt->mr_mask = 0x3FFFFFFF;\r\nwdt->nowayout = nowayout;\r\nwdt->wdd.parent = &pdev->dev;\r\nwdt->wdd.info = &at91_wdt_info;\r\nwdt->wdd.ops = &at91_wdt_ops;\r\nwdt->wdd.timeout = WDT_HEARTBEAT;\r\nwdt->wdd.min_timeout = 1;\r\nwdt->wdd.max_timeout = 0xFFFF;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(wdt->base))\r\nreturn PTR_ERR(wdt->base);\r\nif (pdev->dev.of_node) {\r\nerr = of_at91wdt_init(pdev->dev.of_node, wdt);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = at91_wdt_init(pdev, wdt);\r\nif (err)\r\nreturn err;\r\nplatform_set_drvdata(pdev, wdt);\r\npr_info("enabled (heartbeat=%d sec, nowayout=%d)\n",\r\nwdt->wdd.timeout, wdt->nowayout);\r\nreturn 0;\r\n}\r\nstatic int __exit at91wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct at91wdt *wdt = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&wdt->wdd);\r\npr_warn("I quit now, hardware will probably reboot!\n");\r\ndel_timer(&wdt->timer);\r\nreturn 0;\r\n}
