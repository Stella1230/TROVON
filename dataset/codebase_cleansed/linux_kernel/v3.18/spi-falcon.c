int falcon_sflash_xfer(struct spi_device *spi, struct spi_transfer *t,\r\nunsigned long flags)\r\n{\r\nstruct device *dev = &spi->dev;\r\nstruct falcon_sflash *priv = spi_master_get_devdata(spi->master);\r\nconst u8 *txp = t->tx_buf;\r\nu8 *rxp = t->rx_buf;\r\nunsigned int bytelen = ((8 * t->len + 7) / 8);\r\nunsigned int len, alen, dumlen;\r\nu32 val;\r\nenum {\r\nstate_init,\r\nstate_command_prepare,\r\nstate_write,\r\nstate_read,\r\nstate_disable_cs,\r\nstate_end\r\n} state = state_init;\r\ndo {\r\nswitch (state) {\r\ncase state_init:\r\n{\r\nif (flags & FALCON_SPI_XFER_BEGIN) {\r\nif (!txp) {\r\ndev_err(dev,\r\n"BEGIN without tx data!\n");\r\nreturn -ENODATA;\r\n}\r\npriv->sfcmd = ((spi->chip_select\r\n<< SFCMD_CS_OFFSET)\r\n& SFCMD_CS_MASK);\r\npriv->sfcmd |= SFCMD_KEEP_CS_KEEP_SELECTED;\r\npriv->sfcmd |= *txp;\r\ntxp++;\r\nbytelen--;\r\nif (bytelen) {\r\nstate = state_command_prepare;\r\nbreak;\r\n} else {\r\ndev_dbg(dev, "write cmd %02X\n",\r\npriv->sfcmd & SFCMD_OPC_MASK);\r\n}\r\n}\r\nif (txp && bytelen) {\r\nstate = state_write;\r\nbreak;\r\n}\r\nif (rxp && bytelen) {\r\nstate = state_read;\r\nbreak;\r\n}\r\nif (flags & FALCON_SPI_XFER_END)\r\nstate = state_disable_cs;\r\nelse\r\nstate = state_end;\r\nbreak;\r\n}\r\ncase state_command_prepare:\r\n{\r\nval = 0;\r\nalen = 0;\r\ndumlen = 0;\r\nwhile (bytelen > 0) {\r\nif (alen < 3) {\r\nval = (val << 8) | (*txp++);\r\nalen++;\r\n} else if ((dumlen < 15) && (*txp == 0)) {\r\ndumlen++;\r\ntxp++;\r\n} else {\r\nbreak;\r\n}\r\nbytelen--;\r\n}\r\npriv->sfcmd &= ~(SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK);\r\npriv->sfcmd |= (alen << SFCMD_ALEN_OFFSET) |\r\n(dumlen << SFCMD_DUMLEN_OFFSET);\r\nif (alen > 0)\r\nltq_ebu_w32(val, SFADDR);\r\ndev_dbg(dev, "wr %02X, alen=%d (addr=%06X) dlen=%d\n",\r\npriv->sfcmd & SFCMD_OPC_MASK,\r\nalen, val, dumlen);\r\nif (bytelen > 0) {\r\nstate = state_write;\r\n} else if (flags & FALCON_SPI_XFER_END) {\r\nstate = state_disable_cs;\r\n} else {\r\nstate = state_end;\r\n}\r\nbreak;\r\n}\r\ncase state_write:\r\n{\r\npriv->sfcmd |= SFCMD_DIR_WRITE;\r\nlen = 0;\r\nval = 0;\r\ndo {\r\nif (bytelen--)\r\nval |= (*txp++) << (8 * len++);\r\nif ((flags & FALCON_SPI_XFER_END)\r\n&& (bytelen == 0)) {\r\npriv->sfcmd &=\r\n~SFCMD_KEEP_CS_KEEP_SELECTED;\r\n}\r\nif ((len == 4) || (bytelen == 0)) {\r\nltq_ebu_w32(val, SFDATA);\r\nltq_ebu_w32(priv->sfcmd\r\n| (len<<SFCMD_DLEN_OFFSET),\r\nSFCMD);\r\nlen = 0;\r\nval = 0;\r\npriv->sfcmd &= ~(SFCMD_ALEN_MASK\r\n| SFCMD_DUMLEN_MASK);\r\n}\r\n} while (bytelen);\r\nstate = state_end;\r\nbreak;\r\n}\r\ncase state_read:\r\n{\r\npriv->sfcmd &= ~SFCMD_DIR_WRITE;\r\ndo {\r\nif ((flags & FALCON_SPI_XFER_END)\r\n&& (bytelen <= 4)) {\r\npriv->sfcmd &=\r\n~SFCMD_KEEP_CS_KEEP_SELECTED;\r\n}\r\nlen = (bytelen > 4) ? 4 : bytelen;\r\nbytelen -= len;\r\nltq_ebu_w32(priv->sfcmd\r\n| (len << SFCMD_DLEN_OFFSET), SFCMD);\r\npriv->sfcmd &= ~(SFCMD_ALEN_MASK\r\n| SFCMD_DUMLEN_MASK);\r\ndo {\r\nval = ltq_ebu_r32(SFSTAT);\r\nif (val & SFSTAT_CMD_ERR) {\r\ndev_err(dev, "SFSTAT: CMD_ERR");\r\ndev_err(dev, " (%x)\n", val);\r\nltq_ebu_w32(SFSTAT_CMD_ERR,\r\nSFSTAT);\r\nreturn -EBADE;\r\n}\r\n} while (val & SFSTAT_CMD_PEND);\r\nval = ltq_ebu_r32(SFDATA);\r\ndo {\r\n*rxp = (val & 0xFF);\r\nrxp++;\r\nval >>= 8;\r\nlen--;\r\n} while (len);\r\n} while (bytelen);\r\nstate = state_end;\r\nbreak;\r\n}\r\ncase state_disable_cs:\r\n{\r\npriv->sfcmd &= ~SFCMD_KEEP_CS_KEEP_SELECTED;\r\nltq_ebu_w32(priv->sfcmd | (0 << SFCMD_DLEN_OFFSET),\r\nSFCMD);\r\nval = ltq_ebu_r32(SFSTAT);\r\nif (val & SFSTAT_CMD_ERR) {\r\ndev_err(dev, "SFSTAT: CMD_ERR (%x)\n", val);\r\nltq_ebu_w32(SFSTAT_CMD_ERR, SFSTAT);\r\nreturn -EBADE;\r\n}\r\nstate = state_end;\r\nbreak;\r\n}\r\ncase state_end:\r\nbreak;\r\n}\r\n} while (state != state_end);\r\nreturn 0;\r\n}\r\nstatic int falcon_sflash_setup(struct spi_device *spi)\r\n{\r\nunsigned int i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ebu_lock, flags);\r\nif (spi->max_speed_hz >= CLOCK_100M) {\r\nltq_sys1_w32_mask(0, EBUCC_EBUDIV_SELF100, EBUCC);\r\ni = 1;\r\n} else {\r\nltq_sys1_w32_mask(EBUCC_EBUDIV_SELF100, 0, EBUCC);\r\nfor (i = 1; i < 7; i++) {\r\nif (CLOCK_50M / i <= spi->max_speed_hz)\r\nbreak;\r\n}\r\n}\r\nltq_ebu_w32_mask(SFTIME_SCKF_POS_MASK\r\n| SFTIME_SCKR_POS_MASK\r\n| SFTIME_SCK_PER_MASK,\r\n(i << SFTIME_SCKR_POS_OFFSET)\r\n| (i << (SFTIME_SCK_PER_OFFSET + 1)),\r\nSFTIME);\r\nltq_ebu_w32((SFIO_UNUSED_WD_MASK & (0x8 | 0x4)), SFIO);\r\nltq_ebu_w32(BUSRCON0_AGEN_SERIAL_FLASH | BUSRCON0_PORTW_8_BIT_MUX,\r\nBUSRCON0);\r\nltq_ebu_w32(BUSWCON0_AGEN_SERIAL_FLASH, BUSWCON0);\r\nltq_ebu_w32_mask(SFCON_DEV_SIZE_MASK, SFCON_DEV_SIZE_A23_0, SFCON);\r\nspin_unlock_irqrestore(&ebu_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int falcon_sflash_prepare_xfer(struct spi_master *master)\r\n{\r\nreturn 0;\r\n}\r\nstatic int falcon_sflash_unprepare_xfer(struct spi_master *master)\r\n{\r\nreturn 0;\r\n}\r\nstatic int falcon_sflash_xfer_one(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct falcon_sflash *priv = spi_master_get_devdata(master);\r\nstruct spi_transfer *t;\r\nunsigned long spi_flags;\r\nunsigned long flags;\r\nint ret = 0;\r\npriv->sfcmd = 0;\r\nm->actual_length = 0;\r\nspi_flags = FALCON_SPI_XFER_BEGIN;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (list_is_last(&t->transfer_list, &m->transfers))\r\nspi_flags |= FALCON_SPI_XFER_END;\r\nspin_lock_irqsave(&ebu_lock, flags);\r\nret = falcon_sflash_xfer(m->spi, t, spi_flags);\r\nspin_unlock_irqrestore(&ebu_lock, flags);\r\nif (ret)\r\nbreak;\r\nm->actual_length += t->len;\r\nWARN_ON(t->delay_usecs || t->cs_change);\r\nspi_flags = 0;\r\n}\r\nm->status = ret;\r\nspi_finalize_current_message(master);\r\nreturn 0;\r\n}\r\nstatic int falcon_sflash_probe(struct platform_device *pdev)\r\n{\r\nstruct falcon_sflash *priv;\r\nstruct spi_master *master;\r\nint ret;\r\nif (ltq_boot_select() != BS_SPI) {\r\ndev_err(&pdev->dev, "invalid bootstrap options\n");\r\nreturn -ENODEV;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*priv));\r\nif (!master)\r\nreturn -ENOMEM;\r\npriv = spi_master_get_devdata(master);\r\npriv->master = master;\r\nmaster->mode_bits = SPI_MODE_3;\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nmaster->setup = falcon_sflash_setup;\r\nmaster->prepare_transfer_hardware = falcon_sflash_prepare_xfer;\r\nmaster->transfer_one_message = falcon_sflash_xfer_one;\r\nmaster->unprepare_transfer_hardware = falcon_sflash_unprepare_xfer;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret)\r\nspi_master_put(master);\r\nreturn ret;\r\n}
