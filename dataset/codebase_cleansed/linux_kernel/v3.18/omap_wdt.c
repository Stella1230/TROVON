static void omap_wdt_reload(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\nwhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x08)\r\ncpu_relax();\r\nwdev->wdt_trgr_pattern = ~wdev->wdt_trgr_pattern;\r\nwritel_relaxed(wdev->wdt_trgr_pattern, (base + OMAP_WATCHDOG_TGR));\r\nwhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x08)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_enable(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\nwritel_relaxed(0xBBBB, base + OMAP_WATCHDOG_SPR);\r\nwhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x10)\r\ncpu_relax();\r\nwritel_relaxed(0x4444, base + OMAP_WATCHDOG_SPR);\r\nwhile ((readl_relaxed(base + OMAP_WATCHDOG_WPS)) & 0x10)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_disable(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\nwritel_relaxed(0xAAAA, base + OMAP_WATCHDOG_SPR);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x10)\r\ncpu_relax();\r\nwritel_relaxed(0x5555, base + OMAP_WATCHDOG_SPR);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x10)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_set_timer(struct omap_wdt_dev *wdev,\r\nunsigned int timeout)\r\n{\r\nu32 pre_margin = GET_WLDR_VAL(timeout);\r\nvoid __iomem *base = wdev->base;\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x04)\r\ncpu_relax();\r\nwritel_relaxed(pre_margin, base + OMAP_WATCHDOG_LDR);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x04)\r\ncpu_relax();\r\n}\r\nstatic int omap_wdt_start(struct watchdog_device *wdog)\r\n{\r\nstruct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);\r\nvoid __iomem *base = wdev->base;\r\nmutex_lock(&wdev->lock);\r\nwdev->omap_wdt_users = true;\r\npm_runtime_get_sync(wdev->dev);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x01)\r\ncpu_relax();\r\nwritel_relaxed((1 << 5) | (PTV << 2), base + OMAP_WATCHDOG_CNTRL);\r\nwhile (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x01)\r\ncpu_relax();\r\nomap_wdt_set_timer(wdev, wdog->timeout);\r\nomap_wdt_reload(wdev);\r\nomap_wdt_enable(wdev);\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_stop(struct watchdog_device *wdog)\r\n{\r\nstruct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);\r\nmutex_lock(&wdev->lock);\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\nwdev->omap_wdt_users = false;\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_ping(struct watchdog_device *wdog)\r\n{\r\nstruct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);\r\nmutex_lock(&wdev->lock);\r\nomap_wdt_reload(wdev);\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_set_timeout(struct watchdog_device *wdog,\r\nunsigned int timeout)\r\n{\r\nstruct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);\r\nmutex_lock(&wdev->lock);\r\nomap_wdt_disable(wdev);\r\nomap_wdt_set_timer(wdev, timeout);\r\nomap_wdt_enable(wdev);\r\nomap_wdt_reload(wdev);\r\nwdog->timeout = timeout;\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_wd_timer_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct watchdog_device *omap_wdt;\r\nstruct resource *res;\r\nstruct omap_wdt_dev *wdev;\r\nu32 rs;\r\nint ret;\r\nomap_wdt = devm_kzalloc(&pdev->dev, sizeof(*omap_wdt), GFP_KERNEL);\r\nif (!omap_wdt)\r\nreturn -ENOMEM;\r\nwdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);\r\nif (!wdev)\r\nreturn -ENOMEM;\r\nwdev->omap_wdt_users = false;\r\nwdev->dev = &pdev->dev;\r\nwdev->wdt_trgr_pattern = 0x1234;\r\nmutex_init(&wdev->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdev->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(wdev->base))\r\nreturn PTR_ERR(wdev->base);\r\nomap_wdt->info = &omap_wdt_info;\r\nomap_wdt->ops = &omap_wdt_ops;\r\nomap_wdt->min_timeout = TIMER_MARGIN_MIN;\r\nomap_wdt->max_timeout = TIMER_MARGIN_MAX;\r\nif (timer_margin >= TIMER_MARGIN_MIN &&\r\ntimer_margin <= TIMER_MARGIN_MAX)\r\nomap_wdt->timeout = timer_margin;\r\nelse\r\nomap_wdt->timeout = TIMER_MARGIN_DEFAULT;\r\nwatchdog_set_drvdata(omap_wdt, wdev);\r\nwatchdog_set_nowayout(omap_wdt, nowayout);\r\nplatform_set_drvdata(pdev, omap_wdt);\r\npm_runtime_enable(wdev->dev);\r\npm_runtime_get_sync(wdev->dev);\r\nif (pdata && pdata->read_reset_sources)\r\nrs = pdata->read_reset_sources();\r\nelse\r\nrs = 0;\r\nomap_wdt->bootstatus = (rs & (1 << OMAP_MPU_WD_RST_SRC_ID_SHIFT)) ?\r\nWDIOF_CARDRESET : 0;\r\nomap_wdt_disable(wdev);\r\nret = watchdog_register_device(omap_wdt);\r\nif (ret) {\r\npm_runtime_disable(wdev->dev);\r\nreturn ret;\r\n}\r\npr_info("OMAP Watchdog Timer Rev 0x%02x: initial timeout %d sec\n",\r\nreadl_relaxed(wdev->base + OMAP_WATCHDOG_REV) & 0xFF,\r\nomap_wdt->timeout);\r\npm_runtime_put_sync(wdev->dev);\r\nreturn 0;\r\n}\r\nstatic void omap_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct watchdog_device *wdog = platform_get_drvdata(pdev);\r\nstruct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);\r\nmutex_lock(&wdev->lock);\r\nif (wdev->omap_wdt_users) {\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\nmutex_unlock(&wdev->lock);\r\n}\r\nstatic int omap_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct watchdog_device *wdog = platform_get_drvdata(pdev);\r\nstruct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);\r\npm_runtime_disable(wdev->dev);\r\nwatchdog_unregister_device(wdog);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct watchdog_device *wdog = platform_get_drvdata(pdev);\r\nstruct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);\r\nmutex_lock(&wdev->lock);\r\nif (wdev->omap_wdt_users) {\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_resume(struct platform_device *pdev)\r\n{\r\nstruct watchdog_device *wdog = platform_get_drvdata(pdev);\r\nstruct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);\r\nmutex_lock(&wdev->lock);\r\nif (wdev->omap_wdt_users) {\r\npm_runtime_get_sync(wdev->dev);\r\nomap_wdt_enable(wdev);\r\nomap_wdt_reload(wdev);\r\n}\r\nmutex_unlock(&wdev->lock);\r\nreturn 0;\r\n}
