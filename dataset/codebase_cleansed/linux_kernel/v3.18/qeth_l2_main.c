static int qeth_l2_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nstruct mii_ioctl_data *mii_data;\r\nint rc = 0;\r\nif (!card)\r\nreturn -ENODEV;\r\nif ((card->state != CARD_STATE_UP) &&\r\n(card->state != CARD_STATE_SOFTSETUP))\r\nreturn -ENODEV;\r\nif (card->info.type == QETH_CARD_TYPE_OSN)\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase SIOC_QETH_ADP_SET_SNMP_CONTROL:\r\nrc = qeth_snmp_command(card, rq->ifr_ifru.ifru_data);\r\nbreak;\r\ncase SIOC_QETH_GET_CARD_TYPE:\r\nif ((card->info.type == QETH_CARD_TYPE_OSD ||\r\ncard->info.type == QETH_CARD_TYPE_OSM ||\r\ncard->info.type == QETH_CARD_TYPE_OSX) &&\r\n!card->info.guestlan)\r\nreturn 1;\r\nreturn 0;\r\nbreak;\r\ncase SIOCGMIIPHY:\r\nmii_data = if_mii(rq);\r\nmii_data->phy_id = 0;\r\nbreak;\r\ncase SIOCGMIIREG:\r\nmii_data = if_mii(rq);\r\nif (mii_data->phy_id != 0)\r\nrc = -EINVAL;\r\nelse\r\nmii_data->val_out = qeth_mdio_read(dev,\r\nmii_data->phy_id, mii_data->reg_num);\r\nbreak;\r\ncase SIOC_QETH_QUERY_OAT:\r\nrc = qeth_query_oat_command(card, rq->ifr_ifru.ifru_data);\r\nbreak;\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\n}\r\nif (rc)\r\nQETH_CARD_TEXT_(card, 2, "ioce%d", rc);\r\nreturn rc;\r\n}\r\nstatic int qeth_l2_verify_dev(struct net_device *dev)\r\n{\r\nstruct qeth_card *card;\r\nunsigned long flags;\r\nint rc = 0;\r\nread_lock_irqsave(&qeth_core_card_list.rwlock, flags);\r\nlist_for_each_entry(card, &qeth_core_card_list.list, list) {\r\nif (card->dev == dev) {\r\nrc = QETH_REAL_CARD;\r\nbreak;\r\n}\r\n}\r\nread_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\r\nreturn rc;\r\n}\r\nstatic struct net_device *qeth_l2_netdev_by_devno(unsigned char *read_dev_no)\r\n{\r\nstruct qeth_card *card;\r\nstruct net_device *ndev;\r\n__u16 temp_dev_no;\r\nunsigned long flags;\r\nstruct ccw_dev_id read_devid;\r\nndev = NULL;\r\nmemcpy(&temp_dev_no, read_dev_no, 2);\r\nread_lock_irqsave(&qeth_core_card_list.rwlock, flags);\r\nlist_for_each_entry(card, &qeth_core_card_list.list, list) {\r\nccw_device_get_id(CARD_RDEV(card), &read_devid);\r\nif (read_devid.devno == temp_dev_no) {\r\nndev = card->dev;\r\nbreak;\r\n}\r\n}\r\nread_unlock_irqrestore(&qeth_core_card_list.rwlock, flags);\r\nreturn ndev;\r\n}\r\nstatic int qeth_l2_send_setgroupmac_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\n__u8 *mac;\r\nQETH_CARD_TEXT(card, 2, "L2Sgmacb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nmac = &cmd->data.setdelmac.mac[0];\r\nif (cmd->hdr.return_code == IPA_RC_L2_DUP_MAC) {\r\nQETH_DBF_MESSAGE(2, "Group MAC %pM already existing on %s \n",\r\nmac, QETH_CARD_IFNAME(card));\r\ncmd->hdr.return_code = 0;\r\n}\r\nif (cmd->hdr.return_code)\r\nQETH_DBF_MESSAGE(2, "Could not set group MAC %pM on %s: %x\n",\r\nmac, QETH_CARD_IFNAME(card), cmd->hdr.return_code);\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_send_setgroupmac(struct qeth_card *card, __u8 *mac)\r\n{\r\nQETH_CARD_TEXT(card, 2, "L2Sgmac");\r\nreturn qeth_l2_send_setdelmac(card, mac, IPA_CMD_SETGMAC,\r\nqeth_l2_send_setgroupmac_cb);\r\n}\r\nstatic int qeth_l2_send_delgroupmac_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\n__u8 *mac;\r\nQETH_CARD_TEXT(card, 2, "L2Dgmacb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nmac = &cmd->data.setdelmac.mac[0];\r\nif (cmd->hdr.return_code)\r\nQETH_DBF_MESSAGE(2, "Could not delete group MAC %pM on %s: %x\n",\r\nmac, QETH_CARD_IFNAME(card), cmd->hdr.return_code);\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_send_delgroupmac(struct qeth_card *card, __u8 *mac)\r\n{\r\nQETH_CARD_TEXT(card, 2, "L2Dgmac");\r\nreturn qeth_l2_send_setdelmac(card, mac, IPA_CMD_DELGMAC,\r\nqeth_l2_send_delgroupmac_cb);\r\n}\r\nstatic void qeth_l2_add_mc(struct qeth_card *card, __u8 *mac, int vmac)\r\n{\r\nstruct qeth_mc_mac *mc;\r\nint rc;\r\nmc = kmalloc(sizeof(struct qeth_mc_mac), GFP_ATOMIC);\r\nif (!mc)\r\nreturn;\r\nmemcpy(mc->mc_addr, mac, OSA_ADDR_LEN);\r\nmc->mc_addrlen = OSA_ADDR_LEN;\r\nmc->is_vmac = vmac;\r\nif (vmac) {\r\nrc = qeth_l2_send_setdelmac(card, mac, IPA_CMD_SETVMAC,\r\nNULL);\r\n} else {\r\nrc = qeth_l2_send_setgroupmac(card, mac);\r\n}\r\nif (!rc)\r\nlist_add_tail(&mc->list, &card->mc_list);\r\nelse\r\nkfree(mc);\r\n}\r\nstatic void qeth_l2_del_all_mc(struct qeth_card *card, int del)\r\n{\r\nstruct qeth_mc_mac *mc, *tmp;\r\nspin_lock_bh(&card->mclock);\r\nlist_for_each_entry_safe(mc, tmp, &card->mc_list, list) {\r\nif (del) {\r\nif (mc->is_vmac)\r\nqeth_l2_send_setdelmac(card, mc->mc_addr,\r\nIPA_CMD_DELVMAC, NULL);\r\nelse\r\nqeth_l2_send_delgroupmac(card, mc->mc_addr);\r\n}\r\nlist_del(&mc->list);\r\nkfree(mc);\r\n}\r\nspin_unlock_bh(&card->mclock);\r\n}\r\nstatic inline int qeth_l2_get_cast_type(struct qeth_card *card,\r\nstruct sk_buff *skb)\r\n{\r\nif (card->info.type == QETH_CARD_TYPE_OSN)\r\nreturn RTN_UNSPEC;\r\nif (is_broadcast_ether_addr(skb->data))\r\nreturn RTN_BROADCAST;\r\nif (is_multicast_ether_addr(skb->data))\r\nreturn RTN_MULTICAST;\r\nreturn RTN_UNSPEC;\r\n}\r\nstatic void qeth_l2_fill_header(struct qeth_card *card, struct qeth_hdr *hdr,\r\nstruct sk_buff *skb, int cast_type)\r\n{\r\nstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)skb_mac_header(skb);\r\nmemset(hdr, 0, sizeof(struct qeth_hdr));\r\nhdr->hdr.l2.id = QETH_HEADER_TYPE_LAYER2;\r\nif (cast_type == RTN_MULTICAST)\r\nhdr->hdr.l2.flags[2] |= QETH_LAYER2_FLAG_MULTICAST;\r\nelse if (cast_type == RTN_BROADCAST)\r\nhdr->hdr.l2.flags[2] |= QETH_LAYER2_FLAG_BROADCAST;\r\nelse\r\nhdr->hdr.l2.flags[2] |= QETH_LAYER2_FLAG_UNICAST;\r\nhdr->hdr.l2.pkt_length = skb->len-QETH_HEADER_SIZE;\r\nif (veth->h_vlan_proto == __constant_htons(ETH_P_8021Q)) {\r\nhdr->hdr.l2.flags[2] |= QETH_LAYER2_FLAG_VLAN;\r\nhdr->hdr.l2.vlan_id = ntohs(veth->h_vlan_TCI);\r\n}\r\n}\r\nstatic int qeth_l2_send_setdelvlan_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 2, "L2sdvcb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nif (cmd->hdr.return_code) {\r\nQETH_DBF_MESSAGE(2, "Error in processing VLAN %i on %s: 0x%x. "\r\n"Continuing\n", cmd->data.setdelvlan.vlan_id,\r\nQETH_CARD_IFNAME(card), cmd->hdr.return_code);\r\nQETH_CARD_TEXT_(card, 2, "L2VL%4x", cmd->hdr.command);\r\nQETH_CARD_TEXT_(card, 2, "err%d", cmd->hdr.return_code);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_send_setdelvlan(struct qeth_card *card, __u16 i,\r\nenum qeth_ipa_cmds ipacmd)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_CARD_TEXT_(card, 4, "L2sdv%x", ipacmd);\r\niob = qeth_get_ipacmd_buffer(card, ipacmd, QETH_PROT_IPV4);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.setdelvlan.vlan_id = i;\r\nreturn qeth_send_ipa_cmd(card, iob,\r\nqeth_l2_send_setdelvlan_cb, NULL);\r\n}\r\nstatic void qeth_l2_process_vlans(struct qeth_card *card)\r\n{\r\nstruct qeth_vlan_vid *id;\r\nQETH_CARD_TEXT(card, 3, "L2prcvln");\r\nspin_lock_bh(&card->vlanlock);\r\nlist_for_each_entry(id, &card->vid_list, list) {\r\nqeth_l2_send_setdelvlan(card, id->vid, IPA_CMD_SETVLAN);\r\n}\r\nspin_unlock_bh(&card->vlanlock);\r\n}\r\nstatic int qeth_l2_vlan_rx_add_vid(struct net_device *dev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nstruct qeth_vlan_vid *id;\r\nQETH_CARD_TEXT_(card, 4, "aid:%d", vid);\r\nif (!vid)\r\nreturn 0;\r\nif (card->info.type == QETH_CARD_TYPE_OSM) {\r\nQETH_CARD_TEXT(card, 3, "aidOSM");\r\nreturn 0;\r\n}\r\nif (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {\r\nQETH_CARD_TEXT(card, 3, "aidREC");\r\nreturn 0;\r\n}\r\nid = kmalloc(sizeof(struct qeth_vlan_vid), GFP_ATOMIC);\r\nif (id) {\r\nid->vid = vid;\r\nqeth_l2_send_setdelvlan(card, vid, IPA_CMD_SETVLAN);\r\nspin_lock_bh(&card->vlanlock);\r\nlist_add_tail(&id->list, &card->vid_list);\r\nspin_unlock_bh(&card->vlanlock);\r\n} else {\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_vlan_rx_kill_vid(struct net_device *dev,\r\n__be16 proto, u16 vid)\r\n{\r\nstruct qeth_vlan_vid *id, *tmpid = NULL;\r\nstruct qeth_card *card = dev->ml_priv;\r\nQETH_CARD_TEXT_(card, 4, "kid:%d", vid);\r\nif (card->info.type == QETH_CARD_TYPE_OSM) {\r\nQETH_CARD_TEXT(card, 3, "kidOSM");\r\nreturn 0;\r\n}\r\nif (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {\r\nQETH_CARD_TEXT(card, 3, "kidREC");\r\nreturn 0;\r\n}\r\nspin_lock_bh(&card->vlanlock);\r\nlist_for_each_entry(id, &card->vid_list, list) {\r\nif (id->vid == vid) {\r\nlist_del(&id->list);\r\ntmpid = id;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&card->vlanlock);\r\nif (tmpid) {\r\nqeth_l2_send_setdelvlan(card, vid, IPA_CMD_DELVLAN);\r\nkfree(tmpid);\r\n}\r\nqeth_l2_set_multicast_list(card->dev);\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_stop_card(struct qeth_card *card, int recovery_mode)\r\n{\r\nint rc = 0;\r\nQETH_DBF_TEXT(SETUP , 2, "stopcard");\r\nQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\r\nqeth_set_allowed_threads(card, 0, 1);\r\nif (card->read.state == CH_STATE_UP &&\r\ncard->write.state == CH_STATE_UP &&\r\n(card->state == CARD_STATE_UP)) {\r\nif (recovery_mode &&\r\ncard->info.type != QETH_CARD_TYPE_OSN) {\r\nqeth_l2_stop(card->dev);\r\n} else {\r\nrtnl_lock();\r\ndev_close(card->dev);\r\nrtnl_unlock();\r\n}\r\ncard->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;\r\ncard->state = CARD_STATE_SOFTSETUP;\r\n}\r\nif (card->state == CARD_STATE_SOFTSETUP) {\r\nqeth_l2_del_all_mc(card, 0);\r\nqeth_clear_ipacmd_list(card);\r\ncard->state = CARD_STATE_HARDSETUP;\r\n}\r\nif (card->state == CARD_STATE_HARDSETUP) {\r\nqeth_qdio_clear_card(card, 0);\r\nqeth_clear_qdio_buffers(card);\r\nqeth_clear_working_pool_list(card);\r\ncard->state = CARD_STATE_DOWN;\r\n}\r\nif (card->state == CARD_STATE_DOWN) {\r\nqeth_clear_cmd_buffers(&card->read);\r\nqeth_clear_cmd_buffers(&card->write);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_l2_process_inbound_buffer(struct qeth_card *card,\r\nint budget, int *done)\r\n{\r\nint work_done = 0;\r\nstruct sk_buff *skb;\r\nstruct qeth_hdr *hdr;\r\nunsigned int len;\r\n*done = 0;\r\nWARN_ON_ONCE(!budget);\r\nwhile (budget) {\r\nskb = qeth_core_get_next_skb(card,\r\n&card->qdio.in_q->bufs[card->rx.b_index],\r\n&card->rx.b_element, &card->rx.e_offset, &hdr);\r\nif (!skb) {\r\n*done = 1;\r\nbreak;\r\n}\r\nskb->dev = card->dev;\r\nswitch (hdr->hdr.l2.id) {\r\ncase QETH_HEADER_TYPE_LAYER2:\r\nskb->pkt_type = PACKET_HOST;\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nif (skb->protocol == htons(ETH_P_802_2))\r\n*((__u32 *)skb->cb) = ++card->seqno.pkt_seqno;\r\nlen = skb->len;\r\nnetif_receive_skb(skb);\r\nbreak;\r\ncase QETH_HEADER_TYPE_OSN:\r\nif (card->info.type == QETH_CARD_TYPE_OSN) {\r\nskb_push(skb, sizeof(struct qeth_hdr));\r\nskb_copy_to_linear_data(skb, hdr,\r\nsizeof(struct qeth_hdr));\r\nlen = skb->len;\r\ncard->osn_info.data_cb(skb);\r\nbreak;\r\n}\r\ndefault:\r\ndev_kfree_skb_any(skb);\r\nQETH_CARD_TEXT(card, 3, "inbunkno");\r\nQETH_DBF_HEX(CTRL, 3, hdr, QETH_DBF_CTRL_LEN);\r\ncontinue;\r\n}\r\nwork_done++;\r\nbudget--;\r\ncard->stats.rx_packets++;\r\ncard->stats.rx_bytes += len;\r\n}\r\nreturn work_done;\r\n}\r\nstatic int qeth_l2_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct qeth_card *card = container_of(napi, struct qeth_card, napi);\r\nint work_done = 0;\r\nstruct qeth_qdio_buffer *buffer;\r\nint done;\r\nint new_budget = budget;\r\nif (card->options.performance_stats) {\r\ncard->perf_stats.inbound_cnt++;\r\ncard->perf_stats.inbound_start_time = qeth_get_micros();\r\n}\r\nwhile (1) {\r\nif (!card->rx.b_count) {\r\ncard->rx.qdio_err = 0;\r\ncard->rx.b_count = qdio_get_next_buffers(\r\ncard->data.ccwdev, 0, &card->rx.b_index,\r\n&card->rx.qdio_err);\r\nif (card->rx.b_count <= 0) {\r\ncard->rx.b_count = 0;\r\nbreak;\r\n}\r\ncard->rx.b_element =\r\n&card->qdio.in_q->bufs[card->rx.b_index]\r\n.buffer->element[0];\r\ncard->rx.e_offset = 0;\r\n}\r\nwhile (card->rx.b_count) {\r\nbuffer = &card->qdio.in_q->bufs[card->rx.b_index];\r\nif (!(card->rx.qdio_err &&\r\nqeth_check_qdio_errors(card, buffer->buffer,\r\ncard->rx.qdio_err, "qinerr")))\r\nwork_done += qeth_l2_process_inbound_buffer(\r\ncard, new_budget, &done);\r\nelse\r\ndone = 1;\r\nif (done) {\r\nif (card->options.performance_stats)\r\ncard->perf_stats.bufs_rec++;\r\nqeth_put_buffer_pool_entry(card,\r\nbuffer->pool_entry);\r\nqeth_queue_input_buffer(card, card->rx.b_index);\r\ncard->rx.b_count--;\r\nif (card->rx.b_count) {\r\ncard->rx.b_index =\r\n(card->rx.b_index + 1) %\r\nQDIO_MAX_BUFFERS_PER_Q;\r\ncard->rx.b_element =\r\n&card->qdio.in_q\r\n->bufs[card->rx.b_index]\r\n.buffer->element[0];\r\ncard->rx.e_offset = 0;\r\n}\r\n}\r\nif (work_done >= budget)\r\ngoto out;\r\nelse\r\nnew_budget = budget - work_done;\r\n}\r\n}\r\nnapi_complete(napi);\r\nif (qdio_start_irq(card->data.ccwdev, 0))\r\nnapi_schedule(&card->napi);\r\nout:\r\nif (card->options.performance_stats)\r\ncard->perf_stats.inbound_time += qeth_get_micros() -\r\ncard->perf_stats.inbound_start_time;\r\nreturn work_done;\r\n}\r\nstatic int qeth_l2_send_setdelmac(struct qeth_card *card, __u8 *mac,\r\nenum qeth_ipa_cmds ipacmd,\r\nint (*reply_cb) (struct qeth_card *,\r\nstruct qeth_reply*,\r\nunsigned long))\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct qeth_cmd_buffer *iob;\r\nQETH_CARD_TEXT(card, 2, "L2sdmac");\r\niob = qeth_get_ipacmd_buffer(card, ipacmd, QETH_PROT_IPV4);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.setdelmac.mac_length = OSA_ADDR_LEN;\r\nmemcpy(&cmd->data.setdelmac.mac, mac, OSA_ADDR_LEN);\r\nreturn qeth_send_ipa_cmd(card, iob, reply_cb, NULL);\r\n}\r\nstatic int qeth_l2_send_setmac_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 2, "L2Smaccb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nif (cmd->hdr.return_code) {\r\nQETH_CARD_TEXT_(card, 2, "L2er%x", cmd->hdr.return_code);\r\ncard->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;\r\nswitch (cmd->hdr.return_code) {\r\ncase IPA_RC_L2_DUP_MAC:\r\ncase IPA_RC_L2_DUP_LAYER3_MAC:\r\ndev_warn(&card->gdev->dev,\r\n"MAC address %pM already exists\n",\r\ncmd->data.setdelmac.mac);\r\nbreak;\r\ncase IPA_RC_L2_MAC_NOT_AUTH_BY_HYP:\r\ncase IPA_RC_L2_MAC_NOT_AUTH_BY_ADP:\r\ndev_warn(&card->gdev->dev,\r\n"MAC address %pM is not authorized\n",\r\ncmd->data.setdelmac.mac);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\ncard->info.mac_bits |= QETH_LAYER2_MAC_REGISTERED;\r\nmemcpy(card->dev->dev_addr, cmd->data.setdelmac.mac,\r\nOSA_ADDR_LEN);\r\ndev_info(&card->gdev->dev,\r\n"MAC address %pM successfully registered on device %s\n",\r\ncard->dev->dev_addr, card->dev->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_send_setmac(struct qeth_card *card, __u8 *mac)\r\n{\r\nQETH_CARD_TEXT(card, 2, "L2Setmac");\r\nreturn qeth_l2_send_setdelmac(card, mac, IPA_CMD_SETVMAC,\r\nqeth_l2_send_setmac_cb);\r\n}\r\nstatic int qeth_l2_send_delmac_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply,\r\nunsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd;\r\nQETH_CARD_TEXT(card, 2, "L2Dmaccb");\r\ncmd = (struct qeth_ipa_cmd *) data;\r\nif (cmd->hdr.return_code) {\r\nQETH_CARD_TEXT_(card, 2, "err%d", cmd->hdr.return_code);\r\nreturn 0;\r\n}\r\ncard->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_send_delmac(struct qeth_card *card, __u8 *mac)\r\n{\r\nQETH_CARD_TEXT(card, 2, "L2Delmac");\r\nif (!(card->info.mac_bits & QETH_LAYER2_MAC_REGISTERED))\r\nreturn 0;\r\nreturn qeth_l2_send_setdelmac(card, mac, IPA_CMD_DELVMAC,\r\nqeth_l2_send_delmac_cb);\r\n}\r\nstatic int qeth_l2_request_initial_mac(struct qeth_card *card)\r\n{\r\nint rc = 0;\r\nchar vendor_pre[] = {0x02, 0x00, 0x00};\r\nQETH_DBF_TEXT(SETUP, 2, "doL2init");\r\nQETH_DBF_TEXT_(SETUP, 2, "doL2%s", CARD_BUS_ID(card));\r\nif (qeth_is_supported(card, IPA_SETADAPTERPARMS)) {\r\nrc = qeth_query_setadapterparms(card);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "could not query adapter "\r\n"parameters on device %s: x%x\n",\r\nCARD_BUS_ID(card), rc);\r\n}\r\n}\r\nif (card->info.type == QETH_CARD_TYPE_IQD ||\r\ncard->info.type == QETH_CARD_TYPE_OSM ||\r\ncard->info.type == QETH_CARD_TYPE_OSX ||\r\ncard->info.guestlan) {\r\nrc = qeth_setadpparms_change_macaddr(card);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "couldn't get MAC address on "\r\n"device %s: x%x\n", CARD_BUS_ID(card), rc);\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\nreturn rc;\r\n}\r\nQETH_DBF_HEX(SETUP, 2, card->dev->dev_addr, OSA_ADDR_LEN);\r\n} else {\r\neth_random_addr(card->dev->dev_addr);\r\nmemcpy(card->dev->dev_addr, vendor_pre, 3);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct qeth_card *card = dev->ml_priv;\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 3, "setmac");\r\nif (qeth_l2_verify_dev(dev) != QETH_REAL_CARD) {\r\nQETH_CARD_TEXT(card, 3, "setmcINV");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (card->info.type == QETH_CARD_TYPE_OSN ||\r\ncard->info.type == QETH_CARD_TYPE_OSM ||\r\ncard->info.type == QETH_CARD_TYPE_OSX) {\r\nQETH_CARD_TEXT(card, 3, "setmcTYP");\r\nreturn -EOPNOTSUPP;\r\n}\r\nQETH_CARD_HEX(card, 3, addr->sa_data, OSA_ADDR_LEN);\r\nif (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {\r\nQETH_CARD_TEXT(card, 3, "setmcREC");\r\nreturn -ERESTARTSYS;\r\n}\r\nrc = qeth_l2_send_delmac(card, &card->dev->dev_addr[0]);\r\nif (!rc || (rc == IPA_RC_L2_MAC_NOT_FOUND))\r\nrc = qeth_l2_send_setmac(card, addr->sa_data);\r\nreturn rc ? -EINVAL : 0;\r\n}\r\nstatic void qeth_l2_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nstruct netdev_hw_addr *ha;\r\nif (card->info.type == QETH_CARD_TYPE_OSN)\r\nreturn ;\r\nQETH_CARD_TEXT(card, 3, "setmulti");\r\nif (qeth_threads_running(card, QETH_RECOVER_THREAD) &&\r\n(card->state != CARD_STATE_UP))\r\nreturn;\r\nqeth_l2_del_all_mc(card, 1);\r\nspin_lock_bh(&card->mclock);\r\nnetdev_for_each_mc_addr(ha, dev)\r\nqeth_l2_add_mc(card, ha->addr, 0);\r\nnetdev_for_each_uc_addr(ha, dev)\r\nqeth_l2_add_mc(card, ha->addr, 1);\r\nspin_unlock_bh(&card->mclock);\r\nif (!qeth_adp_supported(card, IPA_SETADP_SET_PROMISC_MODE))\r\nreturn;\r\nqeth_setadp_promisc_mode(card);\r\n}\r\nstatic int qeth_l2_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint rc;\r\nstruct qeth_hdr *hdr = NULL;\r\nint elements = 0;\r\nstruct qeth_card *card = dev->ml_priv;\r\nstruct sk_buff *new_skb = skb;\r\nint cast_type = qeth_l2_get_cast_type(card, skb);\r\nstruct qeth_qdio_out_q *queue;\r\nint tx_bytes = skb->len;\r\nint data_offset = -1;\r\nint elements_needed = 0;\r\nint hd_len = 0;\r\nif (card->qdio.do_prio_queueing || (cast_type &&\r\ncard->info.is_multicast_different))\r\nqueue = card->qdio.out_qs[qeth_get_priority_queue(card, skb,\r\nqeth_get_ip_version(skb), cast_type)];\r\nelse\r\nqueue = card->qdio.out_qs[card->qdio.default_out_queue];\r\nif ((card->state != CARD_STATE_UP) || !card->lan_online) {\r\ncard->stats.tx_carrier_errors++;\r\ngoto tx_drop;\r\n}\r\nif ((card->info.type == QETH_CARD_TYPE_OSN) &&\r\n(skb->protocol == htons(ETH_P_IPV6)))\r\ngoto tx_drop;\r\nif (card->options.performance_stats) {\r\ncard->perf_stats.outbound_cnt++;\r\ncard->perf_stats.outbound_start_time = qeth_get_micros();\r\n}\r\nnetif_stop_queue(dev);\r\nif (card->info.type == QETH_CARD_TYPE_OSN)\r\nhdr = (struct qeth_hdr *)skb->data;\r\nelse {\r\nif (card->info.type == QETH_CARD_TYPE_IQD) {\r\nnew_skb = skb;\r\ndata_offset = ETH_HLEN;\r\nhd_len = ETH_HLEN;\r\nhdr = kmem_cache_alloc(qeth_core_header_cache,\r\nGFP_ATOMIC);\r\nif (!hdr)\r\ngoto tx_drop;\r\nelements_needed++;\r\nskb_reset_mac_header(new_skb);\r\nqeth_l2_fill_header(card, hdr, new_skb, cast_type);\r\nhdr->hdr.l2.pkt_length = new_skb->len;\r\nmemcpy(((char *)hdr) + sizeof(struct qeth_hdr),\r\nskb_mac_header(new_skb), ETH_HLEN);\r\n} else {\r\nnew_skb = skb_realloc_headroom(skb,\r\nsizeof(struct qeth_hdr));\r\nif (!new_skb)\r\ngoto tx_drop;\r\nhdr = (struct qeth_hdr *)skb_push(new_skb,\r\nsizeof(struct qeth_hdr));\r\nskb_set_mac_header(new_skb, sizeof(struct qeth_hdr));\r\nqeth_l2_fill_header(card, hdr, new_skb, cast_type);\r\n}\r\n}\r\nelements = qeth_get_elements_no(card, new_skb, elements_needed);\r\nif (!elements) {\r\nif (data_offset >= 0)\r\nkmem_cache_free(qeth_core_header_cache, hdr);\r\ngoto tx_drop;\r\n}\r\nif (card->info.type != QETH_CARD_TYPE_IQD) {\r\nif (qeth_hdr_chk_and_bounce(new_skb, &hdr,\r\nsizeof(struct qeth_hdr_layer2)))\r\ngoto tx_drop;\r\nrc = qeth_do_send_packet(card, queue, new_skb, hdr,\r\nelements);\r\n} else\r\nrc = qeth_do_send_packet_fast(card, queue, new_skb, hdr,\r\nelements, data_offset, hd_len);\r\nif (!rc) {\r\ncard->stats.tx_packets++;\r\ncard->stats.tx_bytes += tx_bytes;\r\nif (new_skb != skb)\r\ndev_kfree_skb_any(skb);\r\nrc = NETDEV_TX_OK;\r\n} else {\r\nif (data_offset >= 0)\r\nkmem_cache_free(qeth_core_header_cache, hdr);\r\nif (rc == -EBUSY) {\r\nif (new_skb != skb)\r\ndev_kfree_skb_any(new_skb);\r\nreturn NETDEV_TX_BUSY;\r\n} else\r\ngoto tx_drop;\r\n}\r\nnetif_wake_queue(dev);\r\nif (card->options.performance_stats)\r\ncard->perf_stats.outbound_time += qeth_get_micros() -\r\ncard->perf_stats.outbound_start_time;\r\nreturn rc;\r\ntx_drop:\r\ncard->stats.tx_dropped++;\r\ncard->stats.tx_errors++;\r\nif ((new_skb != skb) && new_skb)\r\ndev_kfree_skb_any(new_skb);\r\ndev_kfree_skb_any(skb);\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int __qeth_l2_open(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 4, "qethopen");\r\nif (card->state == CARD_STATE_UP)\r\nreturn rc;\r\nif (card->state != CARD_STATE_SOFTSETUP)\r\nreturn -ENODEV;\r\nif ((card->info.type != QETH_CARD_TYPE_OSN) &&\r\n(!(card->info.mac_bits & QETH_LAYER2_MAC_REGISTERED))) {\r\nQETH_CARD_TEXT(card, 4, "nomacadr");\r\nreturn -EPERM;\r\n}\r\ncard->data.state = CH_STATE_UP;\r\ncard->state = CARD_STATE_UP;\r\nnetif_start_queue(dev);\r\nif (qdio_stop_irq(card->data.ccwdev, 0) >= 0) {\r\nnapi_enable(&card->napi);\r\nnapi_schedule(&card->napi);\r\n} else\r\nrc = -EIO;\r\nreturn rc;\r\n}\r\nstatic int qeth_l2_open(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nQETH_CARD_TEXT(card, 5, "qethope_");\r\nif (qeth_wait_for_threads(card, QETH_RECOVER_THREAD)) {\r\nQETH_CARD_TEXT(card, 3, "openREC");\r\nreturn -ERESTARTSYS;\r\n}\r\nreturn __qeth_l2_open(dev);\r\n}\r\nstatic int qeth_l2_stop(struct net_device *dev)\r\n{\r\nstruct qeth_card *card = dev->ml_priv;\r\nQETH_CARD_TEXT(card, 4, "qethstop");\r\nnetif_tx_disable(dev);\r\nif (card->state == CARD_STATE_UP) {\r\ncard->state = CARD_STATE_SOFTSETUP;\r\nnapi_disable(&card->napi);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_probe_device(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nqeth_l2_create_device_attributes(&gdev->dev);\r\nINIT_LIST_HEAD(&card->vid_list);\r\nINIT_LIST_HEAD(&card->mc_list);\r\ncard->options.layer2 = 1;\r\ncard->info.hwtrap = 0;\r\nreturn 0;\r\n}\r\nstatic void qeth_l2_remove_device(struct ccwgroup_device *cgdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&cgdev->dev);\r\nqeth_l2_remove_device_attributes(&cgdev->dev);\r\nqeth_set_allowed_threads(card, 0, 1);\r\nwait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);\r\nif (cgdev->state == CCWGROUP_ONLINE)\r\nqeth_l2_set_offline(cgdev);\r\nif (card->dev) {\r\nunregister_netdev(card->dev);\r\ncard->dev = NULL;\r\n}\r\nreturn;\r\n}\r\nstatic int qeth_l2_setup_netdev(struct qeth_card *card)\r\n{\r\nswitch (card->info.type) {\r\ncase QETH_CARD_TYPE_IQD:\r\ncard->dev = alloc_netdev(0, "hsi%d", NET_NAME_UNKNOWN,\r\nether_setup);\r\nbreak;\r\ncase QETH_CARD_TYPE_OSN:\r\ncard->dev = alloc_netdev(0, "osn%d", NET_NAME_UNKNOWN,\r\nether_setup);\r\ncard->dev->flags |= IFF_NOARP;\r\nbreak;\r\ndefault:\r\ncard->dev = alloc_etherdev(0);\r\n}\r\nif (!card->dev)\r\nreturn -ENODEV;\r\ncard->dev->ml_priv = card;\r\ncard->dev->watchdog_timeo = QETH_TX_TIMEOUT;\r\ncard->dev->mtu = card->info.initial_mtu;\r\ncard->dev->netdev_ops = &qeth_l2_netdev_ops;\r\ncard->dev->ethtool_ops =\r\n(card->info.type != QETH_CARD_TYPE_OSN) ?\r\n&qeth_l2_ethtool_ops : &qeth_l2_osn_ops;\r\ncard->dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\ncard->info.broadcast_capable = 1;\r\nqeth_l2_request_initial_mac(card);\r\nSET_NETDEV_DEV(card->dev, &card->gdev->dev);\r\nnetif_napi_add(card->dev, &card->napi, qeth_l2_poll, QETH_NAPI_WEIGHT);\r\nreturn register_netdev(card->dev);\r\n}\r\nstatic int __qeth_l2_set_online(struct ccwgroup_device *gdev, int recovery_mode)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nint rc = 0;\r\nenum qeth_card_states recover_flag;\r\nmutex_lock(&card->discipline_mutex);\r\nmutex_lock(&card->conf_mutex);\r\nQETH_DBF_TEXT(SETUP, 2, "setonlin");\r\nQETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));\r\nrecover_flag = card->state;\r\nrc = qeth_core_hardsetup_card(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "2err%d", rc);\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n}\r\nqeth_bridgeport_query_support(card);\r\nif (card->options.sbp.supported_funcs)\r\ndev_info(&card->gdev->dev,\r\n"The device represents a HiperSockets Bridge Capable Port\n");\r\nqeth_trace_features(card);\r\nif (!card->dev && qeth_l2_setup_netdev(card)) {\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n}\r\nif (card->info.type != QETH_CARD_TYPE_OSN)\r\nqeth_l2_send_setmac(card, &card->dev->dev_addr[0]);\r\nif (qeth_is_diagass_supported(card, QETH_DIAGS_CMD_TRAP)) {\r\nif (card->info.hwtrap &&\r\nqeth_hw_trap(card, QETH_DIAGS_TRAP_ARM))\r\ncard->info.hwtrap = 0;\r\n} else\r\ncard->info.hwtrap = 0;\r\nqeth_l2_setup_bridgeport_attrs(card);\r\ncard->state = CARD_STATE_HARDSETUP;\r\nmemset(&card->rx, 0, sizeof(struct qeth_rx));\r\nqeth_print_status_message(card);\r\nQETH_DBF_TEXT(SETUP, 2, "softsetp");\r\nrc = qeth_send_startlan(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\nif (rc == 0xe080) {\r\ndev_warn(&card->gdev->dev,\r\n"The LAN is offline\n");\r\ncard->lan_online = 0;\r\ngoto contin;\r\n}\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n} else\r\ncard->lan_online = 1;\r\ncontin:\r\nif ((card->info.type == QETH_CARD_TYPE_OSD) ||\r\n(card->info.type == QETH_CARD_TYPE_OSX)) {\r\nrc = qeth_set_access_ctrl_online(card, 0);\r\nif (rc) {\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n}\r\n}\r\nif (card->info.type != QETH_CARD_TYPE_OSN &&\r\ncard->info.type != QETH_CARD_TYPE_OSM)\r\nqeth_l2_process_vlans(card);\r\nnetif_tx_disable(card->dev);\r\nrc = qeth_init_qdio_queues(card);\r\nif (rc) {\r\nQETH_DBF_TEXT_(SETUP, 2, "6err%d", rc);\r\nrc = -ENODEV;\r\ngoto out_remove;\r\n}\r\ncard->state = CARD_STATE_SOFTSETUP;\r\nif (card->lan_online)\r\nnetif_carrier_on(card->dev);\r\nelse\r\nnetif_carrier_off(card->dev);\r\nqeth_set_allowed_threads(card, 0xffffffff, 0);\r\nif (recover_flag == CARD_STATE_RECOVER) {\r\nif (recovery_mode &&\r\ncard->info.type != QETH_CARD_TYPE_OSN) {\r\n__qeth_l2_open(card->dev);\r\n} else {\r\nrtnl_lock();\r\ndev_open(card->dev);\r\nrtnl_unlock();\r\n}\r\nqeth_l2_set_multicast_list(card->dev);\r\n}\r\nkobject_uevent(&gdev->dev.kobj, KOBJ_CHANGE);\r\nmutex_unlock(&card->conf_mutex);\r\nmutex_unlock(&card->discipline_mutex);\r\nreturn 0;\r\nout_remove:\r\nqeth_l2_stop_card(card, 0);\r\nccw_device_set_offline(CARD_DDEV(card));\r\nccw_device_set_offline(CARD_WDEV(card));\r\nccw_device_set_offline(CARD_RDEV(card));\r\nqdio_free(CARD_DDEV(card));\r\nif (recover_flag == CARD_STATE_RECOVER)\r\ncard->state = CARD_STATE_RECOVER;\r\nelse\r\ncard->state = CARD_STATE_DOWN;\r\nmutex_unlock(&card->conf_mutex);\r\nmutex_unlock(&card->discipline_mutex);\r\nreturn rc;\r\n}\r\nstatic int qeth_l2_set_online(struct ccwgroup_device *gdev)\r\n{\r\nreturn __qeth_l2_set_online(gdev, 0);\r\n}\r\nstatic int __qeth_l2_set_offline(struct ccwgroup_device *cgdev,\r\nint recovery_mode)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&cgdev->dev);\r\nint rc = 0, rc2 = 0, rc3 = 0;\r\nenum qeth_card_states recover_flag;\r\nmutex_lock(&card->discipline_mutex);\r\nmutex_lock(&card->conf_mutex);\r\nQETH_DBF_TEXT(SETUP, 3, "setoffl");\r\nQETH_DBF_HEX(SETUP, 3, &card, sizeof(void *));\r\nif (card->dev && netif_carrier_ok(card->dev))\r\nnetif_carrier_off(card->dev);\r\nrecover_flag = card->state;\r\nif ((!recovery_mode && card->info.hwtrap) || card->info.hwtrap == 2) {\r\nqeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\r\ncard->info.hwtrap = 1;\r\n}\r\nqeth_l2_stop_card(card, recovery_mode);\r\nrc = ccw_device_set_offline(CARD_DDEV(card));\r\nrc2 = ccw_device_set_offline(CARD_WDEV(card));\r\nrc3 = ccw_device_set_offline(CARD_RDEV(card));\r\nif (!rc)\r\nrc = (rc2) ? rc2 : rc3;\r\nif (rc)\r\nQETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);\r\nqdio_free(CARD_DDEV(card));\r\nif (recover_flag == CARD_STATE_UP)\r\ncard->state = CARD_STATE_RECOVER;\r\nkobject_uevent(&cgdev->dev.kobj, KOBJ_CHANGE);\r\nmutex_unlock(&card->conf_mutex);\r\nmutex_unlock(&card->discipline_mutex);\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_set_offline(struct ccwgroup_device *cgdev)\r\n{\r\nreturn __qeth_l2_set_offline(cgdev, 0);\r\n}\r\nstatic int qeth_l2_recover(void *ptr)\r\n{\r\nstruct qeth_card *card;\r\nint rc = 0;\r\ncard = (struct qeth_card *) ptr;\r\nQETH_CARD_TEXT(card, 2, "recover1");\r\nif (!qeth_do_run_thread(card, QETH_RECOVER_THREAD))\r\nreturn 0;\r\nQETH_CARD_TEXT(card, 2, "recover2");\r\ndev_warn(&card->gdev->dev,\r\n"A recovery process has been started for the device\n");\r\nqeth_set_recovery_task(card);\r\n__qeth_l2_set_offline(card->gdev, 1);\r\nrc = __qeth_l2_set_online(card->gdev, 1);\r\nif (!rc)\r\ndev_info(&card->gdev->dev,\r\n"Device successfully recovered!\n");\r\nelse {\r\nqeth_close_dev(card);\r\ndev_warn(&card->gdev->dev, "The qeth device driver "\r\n"failed to recover an error on the device\n");\r\n}\r\nqeth_clear_recovery_task(card);\r\nqeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);\r\nqeth_clear_thread_running_bit(card, QETH_RECOVER_THREAD);\r\nreturn 0;\r\n}\r\nstatic int __init qeth_l2_init(void)\r\n{\r\npr_info("register layer 2 discipline\n");\r\nreturn 0;\r\n}\r\nstatic void __exit qeth_l2_exit(void)\r\n{\r\npr_info("unregister layer 2 discipline\n");\r\n}\r\nstatic void qeth_l2_shutdown(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nqeth_set_allowed_threads(card, 0, 1);\r\nif ((gdev->state == CCWGROUP_ONLINE) && card->info.hwtrap)\r\nqeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\r\nqeth_qdio_clear_card(card, 0);\r\nqeth_clear_qdio_buffers(card);\r\nqdio_free(CARD_DDEV(card));\r\n}\r\nstatic int qeth_l2_pm_suspend(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nif (card->dev)\r\nnetif_device_detach(card->dev);\r\nqeth_set_allowed_threads(card, 0, 1);\r\nwait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);\r\nif (gdev->state == CCWGROUP_OFFLINE)\r\nreturn 0;\r\nif (card->state == CARD_STATE_UP) {\r\nif (card->info.hwtrap)\r\nqeth_hw_trap(card, QETH_DIAGS_TRAP_DISARM);\r\n__qeth_l2_set_offline(card->gdev, 1);\r\n} else\r\n__qeth_l2_set_offline(card->gdev, 0);\r\nreturn 0;\r\n}\r\nstatic int qeth_l2_pm_resume(struct ccwgroup_device *gdev)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\r\nint rc = 0;\r\nif (gdev->state == CCWGROUP_OFFLINE)\r\ngoto out;\r\nif (card->state == CARD_STATE_RECOVER) {\r\nrc = __qeth_l2_set_online(card->gdev, 1);\r\nif (rc) {\r\nrtnl_lock();\r\ndev_close(card->dev);\r\nrtnl_unlock();\r\n}\r\n} else\r\nrc = __qeth_l2_set_online(card->gdev, 0);\r\nout:\r\nqeth_set_allowed_threads(card, 0xffffffff, 0);\r\nif (card->dev)\r\nnetif_device_attach(card->dev);\r\nif (rc)\r\ndev_warn(&card->gdev->dev, "The qeth device driver "\r\n"failed to recover an error on the device\n");\r\nreturn rc;\r\n}\r\nstatic int qeth_l2_control_event(struct qeth_card *card,\r\nstruct qeth_ipa_cmd *cmd)\r\n{\r\nswitch (cmd->hdr.command) {\r\ncase IPA_CMD_SETBRIDGEPORT:\r\nif (cmd->data.sbp.hdr.command_code ==\r\nIPA_SBP_BRIDGE_PORT_STATE_CHANGE) {\r\nqeth_bridge_state_change(card, cmd);\r\nreturn 0;\r\n} else\r\nreturn 1;\r\ncase IPA_CMD_ADDRESS_CHANGE_NOTIF:\r\nqeth_bridge_host_event(card, cmd);\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int qeth_osn_send_control_data(struct qeth_card *card, int len,\r\nstruct qeth_cmd_buffer *iob)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\nQETH_CARD_TEXT(card, 5, "osndctrd");\r\nwait_event(card->wait_q,\r\natomic_cmpxchg(&card->write.irq_pending, 0, 1) == 0);\r\nqeth_prepare_control_data(card, len, iob);\r\nQETH_CARD_TEXT(card, 6, "osnoirqp");\r\nspin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);\r\nrc = ccw_device_start(card->write.ccwdev, &card->write.ccw,\r\n(addr_t) iob, 0, 0);\r\nspin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);\r\nif (rc) {\r\nQETH_DBF_MESSAGE(2, "qeth_osn_send_control_data: "\r\n"ccw_device_start rc = %i\n", rc);\r\nQETH_CARD_TEXT_(card, 2, " err%d", rc);\r\nqeth_release_buffer(iob->channel, iob);\r\natomic_set(&card->write.irq_pending, 0);\r\nwake_up(&card->wait_q);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_osn_send_ipa_cmd(struct qeth_card *card,\r\nstruct qeth_cmd_buffer *iob, int data_len)\r\n{\r\nu16 s1, s2;\r\nQETH_CARD_TEXT(card, 4, "osndipa");\r\nqeth_prepare_ipa_cmd(card, iob, QETH_PROT_OSN2);\r\ns1 = (u16)(IPA_PDU_HEADER_SIZE + data_len);\r\ns2 = (u16)data_len;\r\nmemcpy(QETH_IPA_PDU_LEN_TOTAL(iob->data), &s1, 2);\r\nmemcpy(QETH_IPA_PDU_LEN_PDU1(iob->data), &s2, 2);\r\nmemcpy(QETH_IPA_PDU_LEN_PDU2(iob->data), &s2, 2);\r\nmemcpy(QETH_IPA_PDU_LEN_PDU3(iob->data), &s2, 2);\r\nreturn qeth_osn_send_control_data(card, s1, iob);\r\n}\r\nint qeth_osn_assist(struct net_device *dev, void *data, int data_len)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_card *card;\r\nint rc;\r\nif (!dev)\r\nreturn -ENODEV;\r\ncard = dev->ml_priv;\r\nif (!card)\r\nreturn -ENODEV;\r\nQETH_CARD_TEXT(card, 2, "osnsdmc");\r\nif ((card->state != CARD_STATE_UP) &&\r\n(card->state != CARD_STATE_SOFTSETUP))\r\nreturn -ENODEV;\r\niob = qeth_wait_for_buffer(&card->write);\r\nmemcpy(iob->data+IPA_PDU_HEADER_SIZE, data, data_len);\r\nrc = qeth_osn_send_ipa_cmd(card, iob, data_len);\r\nreturn rc;\r\n}\r\nint qeth_osn_register(unsigned char *read_dev_no, struct net_device **dev,\r\nint (*assist_cb)(struct net_device *, void *),\r\nint (*data_cb)(struct sk_buff *))\r\n{\r\nstruct qeth_card *card;\r\n*dev = qeth_l2_netdev_by_devno(read_dev_no);\r\nif (*dev == NULL)\r\nreturn -ENODEV;\r\ncard = (*dev)->ml_priv;\r\nif (!card)\r\nreturn -ENODEV;\r\nQETH_CARD_TEXT(card, 2, "osnreg");\r\nif ((assist_cb == NULL) || (data_cb == NULL))\r\nreturn -EINVAL;\r\ncard->osn_info.assist_cb = assist_cb;\r\ncard->osn_info.data_cb = data_cb;\r\nreturn 0;\r\n}\r\nvoid qeth_osn_deregister(struct net_device *dev)\r\n{\r\nstruct qeth_card *card;\r\nif (!dev)\r\nreturn;\r\ncard = dev->ml_priv;\r\nif (!card)\r\nreturn;\r\nQETH_CARD_TEXT(card, 2, "osndereg");\r\ncard->osn_info.assist_cb = NULL;\r\ncard->osn_info.data_cb = NULL;\r\nreturn;\r\n}\r\nstatic void qeth_bridge_emit_host_event(struct qeth_card *card,\r\nenum qeth_an_event_type evtype,\r\nu8 code, struct net_if_token *token, struct mac_addr_lnid *addr_lnid)\r\n{\r\nchar str[7][32];\r\nchar *env[8];\r\nint i = 0;\r\nswitch (evtype) {\r\ncase anev_reg_unreg:\r\nsnprintf(str[i], sizeof(str[i]), "BRIDGEDHOST=%s",\r\n(code & IPA_ADDR_CHANGE_CODE_REMOVAL)\r\n? "deregister" : "register");\r\nenv[i] = str[i]; i++;\r\nif (code & IPA_ADDR_CHANGE_CODE_VLANID) {\r\nsnprintf(str[i], sizeof(str[i]), "VLAN=%d",\r\naddr_lnid->lnid);\r\nenv[i] = str[i]; i++;\r\n}\r\nif (code & IPA_ADDR_CHANGE_CODE_MACADDR) {\r\nsnprintf(str[i], sizeof(str[i]), "MAC=%pM6",\r\n&addr_lnid->mac);\r\nenv[i] = str[i]; i++;\r\n}\r\nsnprintf(str[i], sizeof(str[i]), "NTOK_BUSID=%x.%x.%04x",\r\ntoken->cssid, token->ssid, token->devnum);\r\nenv[i] = str[i]; i++;\r\nsnprintf(str[i], sizeof(str[i]), "NTOK_IID=%02x", token->iid);\r\nenv[i] = str[i]; i++;\r\nsnprintf(str[i], sizeof(str[i]), "NTOK_CHPID=%02x",\r\ntoken->chpid);\r\nenv[i] = str[i]; i++;\r\nsnprintf(str[i], sizeof(str[i]), "NTOK_CHID=%04x", token->chid);\r\nenv[i] = str[i]; i++;\r\nbreak;\r\ncase anev_abort:\r\nsnprintf(str[i], sizeof(str[i]), "BRIDGEDHOST=abort");\r\nenv[i] = str[i]; i++;\r\nbreak;\r\ncase anev_reset:\r\nsnprintf(str[i], sizeof(str[i]), "BRIDGEDHOST=reset");\r\nenv[i] = str[i]; i++;\r\nbreak;\r\n}\r\nenv[i] = NULL;\r\nkobject_uevent_env(&card->gdev->dev.kobj, KOBJ_CHANGE, env);\r\n}\r\nstatic void qeth_bridge_state_change_worker(struct work_struct *work)\r\n{\r\nstruct qeth_bridge_state_data *data =\r\ncontainer_of(work, struct qeth_bridge_state_data, worker);\r\nstruct qeth_sbp_port_entry *entry = &data->qports.entry[0];\r\nchar env_locrem[32];\r\nchar env_role[32];\r\nchar env_state[32];\r\nchar *env[] = {\r\nenv_locrem,\r\nenv_role,\r\nenv_state,\r\nNULL\r\n};\r\nmutex_lock(&data->card->conf_mutex);\r\ndata->card->options.sbp.role = entry->role;\r\nmutex_unlock(&data->card->conf_mutex);\r\nsnprintf(env_locrem, sizeof(env_locrem), "BRIDGEPORT=statechange");\r\nsnprintf(env_role, sizeof(env_role), "ROLE=%s",\r\n(entry->role == QETH_SBP_ROLE_NONE) ? "none" :\r\n(entry->role == QETH_SBP_ROLE_PRIMARY) ? "primary" :\r\n(entry->role == QETH_SBP_ROLE_SECONDARY) ? "secondary" :\r\n"<INVALID>");\r\nsnprintf(env_state, sizeof(env_state), "STATE=%s",\r\n(entry->state == QETH_SBP_STATE_INACTIVE) ? "inactive" :\r\n(entry->state == QETH_SBP_STATE_STANDBY) ? "standby" :\r\n(entry->state == QETH_SBP_STATE_ACTIVE) ? "active" :\r\n"<INVALID>");\r\nkobject_uevent_env(&data->card->gdev->dev.kobj,\r\nKOBJ_CHANGE, env);\r\nkfree(data);\r\n}\r\nstatic void qeth_bridge_state_change(struct qeth_card *card,\r\nstruct qeth_ipa_cmd *cmd)\r\n{\r\nstruct qeth_sbp_state_change *qports =\r\n&cmd->data.sbp.data.state_change;\r\nstruct qeth_bridge_state_data *data;\r\nint extrasize;\r\nQETH_CARD_TEXT(card, 2, "brstchng");\r\nif (qports->entry_length != sizeof(struct qeth_sbp_port_entry)) {\r\nQETH_CARD_TEXT_(card, 2, "BPsz%.8d", qports->entry_length);\r\nreturn;\r\n}\r\nextrasize = sizeof(struct qeth_sbp_port_entry) * qports->num_entries;\r\ndata = kzalloc(sizeof(struct qeth_bridge_state_data) + extrasize,\r\nGFP_ATOMIC);\r\nif (!data) {\r\nQETH_CARD_TEXT(card, 2, "BPSalloc");\r\nreturn;\r\n}\r\nINIT_WORK(&data->worker, qeth_bridge_state_change_worker);\r\ndata->card = card;\r\nmemcpy(&data->qports, qports,\r\nsizeof(struct qeth_sbp_state_change) + extrasize);\r\nqueue_work(qeth_wq, &data->worker);\r\n}\r\nstatic void qeth_bridge_host_event_worker(struct work_struct *work)\r\n{\r\nstruct qeth_bridge_host_data *data =\r\ncontainer_of(work, struct qeth_bridge_host_data, worker);\r\nint i;\r\nif (data->hostevs.lost_event_mask) {\r\ndev_info(&data->card->gdev->dev,\r\n"Address notification from the HiperSockets Bridge Port stopped %s (%s)\n",\r\ndata->card->dev->name,\r\n(data->hostevs.lost_event_mask == 0x01)\r\n? "Overflow"\r\n: (data->hostevs.lost_event_mask == 0x02)\r\n? "Bridge port state change"\r\n: "Unknown reason");\r\nmutex_lock(&data->card->conf_mutex);\r\ndata->card->options.sbp.hostnotification = 0;\r\nmutex_unlock(&data->card->conf_mutex);\r\nqeth_bridge_emit_host_event(data->card, anev_abort,\r\n0, NULL, NULL);\r\n} else\r\nfor (i = 0; i < data->hostevs.num_entries; i++) {\r\nstruct qeth_ipacmd_addr_change_entry *entry =\r\n&data->hostevs.entry[i];\r\nqeth_bridge_emit_host_event(data->card,\r\nanev_reg_unreg,\r\nentry->change_code,\r\n&entry->token, &entry->addr_lnid);\r\n}\r\nkfree(data);\r\n}\r\nstatic void qeth_bridge_host_event(struct qeth_card *card,\r\nstruct qeth_ipa_cmd *cmd)\r\n{\r\nstruct qeth_ipacmd_addr_change *hostevs =\r\n&cmd->data.addrchange;\r\nstruct qeth_bridge_host_data *data;\r\nint extrasize;\r\nQETH_CARD_TEXT(card, 2, "brhostev");\r\nif (cmd->hdr.return_code != 0x0000) {\r\nif (cmd->hdr.return_code == 0x0010) {\r\nif (hostevs->lost_event_mask == 0x00)\r\nhostevs->lost_event_mask = 0xff;\r\n} else {\r\nQETH_CARD_TEXT_(card, 2, "BPHe%04x",\r\ncmd->hdr.return_code);\r\nreturn;\r\n}\r\n}\r\nextrasize = sizeof(struct qeth_ipacmd_addr_change_entry) *\r\nhostevs->num_entries;\r\ndata = kzalloc(sizeof(struct qeth_bridge_host_data) + extrasize,\r\nGFP_ATOMIC);\r\nif (!data) {\r\nQETH_CARD_TEXT(card, 2, "BPHalloc");\r\nreturn;\r\n}\r\nINIT_WORK(&data->worker, qeth_bridge_host_event_worker);\r\ndata->card = card;\r\nmemcpy(&data->hostevs, hostevs,\r\nsizeof(struct qeth_ipacmd_addr_change) + extrasize);\r\nqueue_work(qeth_wq, &data->worker);\r\n}\r\nstatic int qeth_bridgeport_makerc(struct qeth_card *card,\r\nstruct _qeth_sbp_cbctl *cbctl, enum qeth_ipa_sbp_cmd setcmd)\r\n{\r\nint rc;\r\nswitch (cbctl->ipa_rc) {\r\ncase IPA_RC_SUCCESS:\r\nswitch (cbctl->cmd_rc) {\r\ncase 0x0000:\r\nrc = 0;\r\nbreak;\r\ncase 0x0004:\r\nrc = -ENOSYS;\r\nbreak;\r\ncase 0x000C:\r\nrc = -ENODEV;\r\ndev_err(&card->gdev->dev,\r\n"The HiperSockets device is not configured as a Bridge Port\n");\r\nbreak;\r\ncase 0x0014:\r\nswitch (setcmd) {\r\ncase IPA_SBP_SET_PRIMARY_BRIDGE_PORT:\r\nrc = -EEXIST;\r\ndev_err(&card->gdev->dev,\r\n"The HiperSockets LAN already has a primary Bridge Port\n");\r\nbreak;\r\ncase IPA_SBP_SET_SECONDARY_BRIDGE_PORT:\r\nrc = -EBUSY;\r\ndev_err(&card->gdev->dev,\r\n"The HiperSockets device is already a primary Bridge Port\n");\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\n}\r\nbreak;\r\ncase 0x0018:\r\nrc = -EBUSY;\r\ndev_err(&card->gdev->dev,\r\n"The HiperSockets device is already a secondary Bridge Port\n");\r\nbreak;\r\ncase 0x001C:\r\nrc = -EEXIST;\r\ndev_err(&card->gdev->dev,\r\n"The HiperSockets LAN cannot have more secondary Bridge Ports\n");\r\nbreak;\r\ncase 0x0024:\r\nrc = -EBUSY;\r\ndev_err(&card->gdev->dev,\r\n"The HiperSockets device is already a primary Bridge Port\n");\r\nbreak;\r\ncase 0x0020:\r\nrc = -EACCES;\r\ndev_err(&card->gdev->dev,\r\n"The HiperSockets device is not authorized to be a Bridge Port\n");\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\n}\r\nbreak;\r\ncase IPA_RC_NOTSUPP:\r\nrc = -ENOSYS;\r\nbreak;\r\ncase IPA_RC_UNSUPPORTED_COMMAND:\r\nrc = -ENOSYS;\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\n}\r\nif (rc) {\r\nQETH_CARD_TEXT_(card, 2, "SBPi%04x", cbctl->ipa_rc);\r\nQETH_CARD_TEXT_(card, 2, "SBPc%04x", cbctl->cmd_rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qeth_bridgeport_query_support_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\r\nstruct _qeth_sbp_cbctl *cbctl = (struct _qeth_sbp_cbctl *)reply->param;\r\nQETH_CARD_TEXT(card, 2, "brqsupcb");\r\ncbctl->ipa_rc = cmd->hdr.return_code;\r\ncbctl->cmd_rc = cmd->data.sbp.hdr.return_code;\r\nif ((cbctl->ipa_rc == 0) && (cbctl->cmd_rc == 0)) {\r\ncbctl->data.supported =\r\ncmd->data.sbp.data.query_cmds_supp.supported_cmds;\r\n} else {\r\ncbctl->data.supported = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qeth_bridgeport_query_support(struct qeth_card *card)\r\n{\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct _qeth_sbp_cbctl cbctl;\r\nQETH_CARD_TEXT(card, 2, "brqsuppo");\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETBRIDGEPORT, 0);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.sbp.hdr.cmdlength =\r\nsizeof(struct qeth_ipacmd_sbp_hdr) +\r\nsizeof(struct qeth_sbp_query_cmds_supp);\r\ncmd->data.sbp.hdr.command_code =\r\nIPA_SBP_QUERY_COMMANDS_SUPPORTED;\r\ncmd->data.sbp.hdr.used_total = 1;\r\ncmd->data.sbp.hdr.seq_no = 1;\r\nif (qeth_send_ipa_cmd(card, iob, qeth_bridgeport_query_support_cb,\r\n(void *)&cbctl) ||\r\nqeth_bridgeport_makerc(card, &cbctl,\r\nIPA_SBP_QUERY_COMMANDS_SUPPORTED)) {\r\ncard->options.sbp.role = QETH_SBP_ROLE_NONE;\r\nreturn;\r\n}\r\ncard->options.sbp.supported_funcs = cbctl.data.supported;\r\n}\r\nstatic int qeth_bridgeport_query_ports_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;\r\nstruct qeth_sbp_query_ports *qports = &cmd->data.sbp.data.query_ports;\r\nstruct _qeth_sbp_cbctl *cbctl = (struct _qeth_sbp_cbctl *)reply->param;\r\nQETH_CARD_TEXT(card, 2, "brqprtcb");\r\ncbctl->ipa_rc = cmd->hdr.return_code;\r\ncbctl->cmd_rc = cmd->data.sbp.hdr.return_code;\r\nif ((cbctl->ipa_rc != 0) || (cbctl->cmd_rc != 0))\r\nreturn 0;\r\nif (qports->entry_length != sizeof(struct qeth_sbp_port_entry)) {\r\ncbctl->cmd_rc = 0xffff;\r\nQETH_CARD_TEXT_(card, 2, "SBPs%04x", qports->entry_length);\r\nreturn 0;\r\n}\r\nif (qports->num_entries > 0) {\r\nif (cbctl->data.qports.role)\r\n*cbctl->data.qports.role = qports->entry[0].role;\r\nif (cbctl->data.qports.state)\r\n*cbctl->data.qports.state = qports->entry[0].state;\r\n}\r\nreturn 0;\r\n}\r\nint qeth_bridgeport_query_ports(struct qeth_card *card,\r\nenum qeth_sbp_roles *role, enum qeth_sbp_states *state)\r\n{\r\nint rc = 0;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct _qeth_sbp_cbctl cbctl = {\r\n.data = {\r\n.qports = {\r\n.role = role,\r\n.state = state,\r\n},\r\n},\r\n};\r\nQETH_CARD_TEXT(card, 2, "brqports");\r\nif (!(card->options.sbp.supported_funcs & IPA_SBP_QUERY_BRIDGE_PORTS))\r\nreturn -EOPNOTSUPP;\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETBRIDGEPORT, 0);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.sbp.hdr.cmdlength =\r\nsizeof(struct qeth_ipacmd_sbp_hdr);\r\ncmd->data.sbp.hdr.command_code =\r\nIPA_SBP_QUERY_BRIDGE_PORTS;\r\ncmd->data.sbp.hdr.used_total = 1;\r\ncmd->data.sbp.hdr.seq_no = 1;\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_bridgeport_query_ports_cb,\r\n(void *)&cbctl);\r\nif (rc)\r\nreturn rc;\r\nrc = qeth_bridgeport_makerc(card, &cbctl, IPA_SBP_QUERY_BRIDGE_PORTS);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int qeth_bridgeport_set_cb(struct qeth_card *card,\r\nstruct qeth_reply *reply, unsigned long data)\r\n{\r\nstruct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *)data;\r\nstruct _qeth_sbp_cbctl *cbctl = (struct _qeth_sbp_cbctl *)reply->param;\r\nQETH_CARD_TEXT(card, 2, "brsetrcb");\r\ncbctl->ipa_rc = cmd->hdr.return_code;\r\ncbctl->cmd_rc = cmd->data.sbp.hdr.return_code;\r\nreturn 0;\r\n}\r\nint qeth_bridgeport_setrole(struct qeth_card *card, enum qeth_sbp_roles role)\r\n{\r\nint rc = 0;\r\nint cmdlength;\r\nstruct qeth_cmd_buffer *iob;\r\nstruct qeth_ipa_cmd *cmd;\r\nstruct _qeth_sbp_cbctl cbctl;\r\nenum qeth_ipa_sbp_cmd setcmd;\r\nQETH_CARD_TEXT(card, 2, "brsetrol");\r\nswitch (role) {\r\ncase QETH_SBP_ROLE_NONE:\r\nsetcmd = IPA_SBP_RESET_BRIDGE_PORT_ROLE;\r\ncmdlength = sizeof(struct qeth_ipacmd_sbp_hdr) +\r\nsizeof(struct qeth_sbp_reset_role);\r\nbreak;\r\ncase QETH_SBP_ROLE_PRIMARY:\r\nsetcmd = IPA_SBP_SET_PRIMARY_BRIDGE_PORT;\r\ncmdlength = sizeof(struct qeth_ipacmd_sbp_hdr) +\r\nsizeof(struct qeth_sbp_set_primary);\r\nbreak;\r\ncase QETH_SBP_ROLE_SECONDARY:\r\nsetcmd = IPA_SBP_SET_SECONDARY_BRIDGE_PORT;\r\ncmdlength = sizeof(struct qeth_ipacmd_sbp_hdr) +\r\nsizeof(struct qeth_sbp_set_secondary);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!(card->options.sbp.supported_funcs & setcmd))\r\nreturn -EOPNOTSUPP;\r\niob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETBRIDGEPORT, 0);\r\ncmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\r\ncmd->data.sbp.hdr.cmdlength = cmdlength;\r\ncmd->data.sbp.hdr.command_code = setcmd;\r\ncmd->data.sbp.hdr.used_total = 1;\r\ncmd->data.sbp.hdr.seq_no = 1;\r\nrc = qeth_send_ipa_cmd(card, iob, qeth_bridgeport_set_cb,\r\n(void *)&cbctl);\r\nif (rc)\r\nreturn rc;\r\nrc = qeth_bridgeport_makerc(card, &cbctl, setcmd);\r\nreturn rc;\r\n}\r\nstatic int qeth_anset_makerc(struct qeth_card *card, int pnso_rc, u16 response)\r\n{\r\nint rc;\r\nif (pnso_rc == 0)\r\nswitch (response) {\r\ncase 0x0001:\r\nrc = 0;\r\nbreak;\r\ncase 0x0004:\r\ncase 0x0100:\r\ncase 0x0106:\r\nrc = -ENOSYS;\r\ndev_err(&card->gdev->dev,\r\n"Setting address notification failed\n");\r\nbreak;\r\ncase 0x0107:\r\nrc = -EAGAIN;\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\n}\r\nelse\r\nrc = -EIO;\r\nif (rc) {\r\nQETH_CARD_TEXT_(card, 2, "SBPp%04x", pnso_rc);\r\nQETH_CARD_TEXT_(card, 2, "SBPr%04x", response);\r\n}\r\nreturn rc;\r\n}\r\nstatic void qeth_bridgeport_an_set_cb(void *priv,\r\nenum qdio_brinfo_entry_type type, void *entry)\r\n{\r\nstruct qeth_card *card = (struct qeth_card *)priv;\r\nstruct qdio_brinfo_entry_l2 *l2entry;\r\nu8 code;\r\nif (type != l2_addr_lnid) {\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\nl2entry = (struct qdio_brinfo_entry_l2 *)entry;\r\ncode = IPA_ADDR_CHANGE_CODE_MACADDR;\r\nif (l2entry->addr_lnid.lnid)\r\ncode |= IPA_ADDR_CHANGE_CODE_VLANID;\r\nqeth_bridge_emit_host_event(card, anev_reg_unreg, code,\r\n(struct net_if_token *)&l2entry->nit,\r\n(struct mac_addr_lnid *)&l2entry->addr_lnid);\r\n}\r\nint qeth_bridgeport_an_set(struct qeth_card *card, int enable)\r\n{\r\nint rc;\r\nu16 response;\r\nstruct ccw_device *ddev;\r\nstruct subchannel_id schid;\r\nif (!card)\r\nreturn -EINVAL;\r\nif (!card->options.sbp.supported_funcs)\r\nreturn -EOPNOTSUPP;\r\nddev = CARD_DDEV(card);\r\nccw_device_get_schid(ddev, &schid);\r\nif (enable) {\r\nqeth_bridge_emit_host_event(card, anev_reset, 0, NULL, NULL);\r\nrc = qdio_pnso_brinfo(schid, 1, &response,\r\nqeth_bridgeport_an_set_cb, card);\r\n} else\r\nrc = qdio_pnso_brinfo(schid, 0, &response, NULL, NULL);\r\nreturn qeth_anset_makerc(card, rc, response);\r\n}
