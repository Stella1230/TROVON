static int tuner_read_status(struct dvb_frontend *fe)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nunsigned char byte;\r\nif (1 != tuner_i2c_xfer_recv(&priv->i2c_props, &byte, 1))\r\nreturn 0;\r\nreturn byte;\r\n}\r\nstatic inline int tuner_signal(const int status)\r\n{\r\nreturn (status & TUNER_SIGNAL) << 13;\r\n}\r\nstatic inline int tuner_stereo(const int type, const int status)\r\n{\r\nswitch (type) {\r\ncase TUNER_PHILIPS_FM1216ME_MK3:\r\ncase TUNER_PHILIPS_FM1236_MK3:\r\ncase TUNER_PHILIPS_FM1256_IH3:\r\ncase TUNER_LG_NTSC_TAPE:\r\ncase TUNER_TCL_MF02GIP_5N:\r\nreturn ((status & TUNER_SIGNAL) == TUNER_STEREO_MK3);\r\ncase TUNER_PHILIPS_FM1216MK5:\r\nreturn status | TUNER_STEREO;\r\ndefault:\r\nreturn status & TUNER_STEREO;\r\n}\r\n}\r\nstatic inline int tuner_islocked(const int status)\r\n{\r\nreturn (status & TUNER_FL);\r\n}\r\nstatic inline int tuner_afcstatus(const int status)\r\n{\r\nreturn (status & TUNER_AFC) - 2;\r\n}\r\nstatic int simple_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nint tuner_status;\r\nif (priv->i2c_props.adap == NULL)\r\nreturn -EINVAL;\r\ntuner_status = tuner_read_status(fe);\r\n*status = 0;\r\nif (tuner_islocked(tuner_status))\r\n*status = TUNER_STATUS_LOCKED;\r\nif (tuner_stereo(priv->type, tuner_status))\r\n*status |= TUNER_STATUS_STEREO;\r\ntuner_dbg("AFC Status: %d\n", tuner_afcstatus(tuner_status));\r\nreturn 0;\r\n}\r\nstatic int simple_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nint signal;\r\nif (priv->i2c_props.adap == NULL || !priv->radio_mode)\r\nreturn -EINVAL;\r\nsignal = tuner_signal(tuner_read_status(fe));\r\n*strength = signal;\r\ntuner_dbg("Signal strength: %d\n", signal);\r\nreturn 0;\r\n}\r\nstatic inline char *tuner_param_name(enum param_type type)\r\n{\r\nchar *name;\r\nswitch (type) {\r\ncase TUNER_PARAM_TYPE_RADIO:\r\nname = "radio";\r\nbreak;\r\ncase TUNER_PARAM_TYPE_PAL:\r\nname = "pal";\r\nbreak;\r\ncase TUNER_PARAM_TYPE_SECAM:\r\nname = "secam";\r\nbreak;\r\ncase TUNER_PARAM_TYPE_NTSC:\r\nname = "ntsc";\r\nbreak;\r\ncase TUNER_PARAM_TYPE_DIGITAL:\r\nname = "digital";\r\nbreak;\r\ndefault:\r\nname = "unknown";\r\nbreak;\r\n}\r\nreturn name;\r\n}\r\nstatic struct tuner_params *simple_tuner_params(struct dvb_frontend *fe,\r\nenum param_type desired_type)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nstruct tunertype *tun = priv->tun;\r\nint i;\r\nfor (i = 0; i < tun->count; i++)\r\nif (desired_type == tun->params[i].type)\r\nbreak;\r\nif (i == tun->count) {\r\ntuner_dbg("desired params (%s) undefined for tuner %d\n",\r\ntuner_param_name(desired_type), priv->type);\r\ni = 0;\r\n}\r\ntuner_dbg("using tuner params #%d (%s)\n", i,\r\ntuner_param_name(tun->params[i].type));\r\nreturn &tun->params[i];\r\n}\r\nstatic int simple_config_lookup(struct dvb_frontend *fe,\r\nstruct tuner_params *t_params,\r\nunsigned *frequency, u8 *config, u8 *cb)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nint i;\r\nfor (i = 0; i < t_params->count; i++) {\r\nif (*frequency > t_params->ranges[i].limit)\r\ncontinue;\r\nbreak;\r\n}\r\nif (i == t_params->count) {\r\ntuner_dbg("frequency out of range (%d > %d)\n",\r\n*frequency, t_params->ranges[i - 1].limit);\r\n*frequency = t_params->ranges[--i].limit;\r\n}\r\n*config = t_params->ranges[i].config;\r\n*cb = t_params->ranges[i].cb;\r\ntuner_dbg("freq = %d.%02d (%d), range = %d, "\r\n"config = 0x%02x, cb = 0x%02x\n",\r\n*frequency / 16, *frequency % 16 * 100 / 16, *frequency,\r\ni, *config, *cb);\r\nreturn i;\r\n}\r\nstatic void simple_set_rf_input(struct dvb_frontend *fe,\r\nu8 *config, u8 *cb, unsigned int rf)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nswitch (priv->type) {\r\ncase TUNER_PHILIPS_TUV1236D:\r\nswitch (rf) {\r\ncase 1:\r\n*cb |= 0x08;\r\nbreak;\r\ndefault:\r\n*cb &= ~0x08;\r\nbreak;\r\n}\r\nbreak;\r\ncase TUNER_PHILIPS_FCV1236D:\r\nswitch (rf) {\r\ncase 1:\r\n*cb |= 0x01;\r\nbreak;\r\ndefault:\r\n*cb &= ~0x01;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int simple_std_setup(struct dvb_frontend *fe,\r\nstruct analog_parameters *params,\r\nu8 *config, u8 *cb)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nint rc;\r\nswitch (priv->type) {\r\ncase TUNER_PHILIPS_SECAM:\r\n*cb &= ~0x03;\r\nif (params->std & V4L2_STD_SECAM_L)\r\n*cb |= PHILIPS_MF_SET_STD_L;\r\nelse if (params->std & V4L2_STD_SECAM_LC)\r\n*cb |= PHILIPS_MF_SET_STD_LC;\r\nelse\r\n*cb |= PHILIPS_MF_SET_STD_BG;\r\nbreak;\r\ncase TUNER_TEMIC_4046FM5:\r\n*cb &= ~0x0f;\r\nif (params->std & V4L2_STD_PAL_BG) {\r\n*cb |= TEMIC_SET_PAL_BG;\r\n} else if (params->std & V4L2_STD_PAL_I) {\r\n*cb |= TEMIC_SET_PAL_I;\r\n} else if (params->std & V4L2_STD_PAL_DK) {\r\n*cb |= TEMIC_SET_PAL_DK;\r\n} else if (params->std & V4L2_STD_SECAM_L) {\r\n*cb |= TEMIC_SET_PAL_L;\r\n}\r\nbreak;\r\ncase TUNER_PHILIPS_FQ1216ME:\r\n*cb &= ~0x0f;\r\nif (params->std & (V4L2_STD_PAL_BG|V4L2_STD_PAL_DK)) {\r\n*cb |= PHILIPS_SET_PAL_BGDK;\r\n} else if (params->std & V4L2_STD_PAL_I) {\r\n*cb |= PHILIPS_SET_PAL_I;\r\n} else if (params->std & V4L2_STD_SECAM_L) {\r\n*cb |= PHILIPS_SET_PAL_L;\r\n}\r\nbreak;\r\ncase TUNER_PHILIPS_FCV1236D:\r\n*cb &= ~0x03;\r\nif (!(params->std & V4L2_STD_ATSC))\r\n*cb |= 2;\r\nbreak;\r\ncase TUNER_MICROTUNE_4042FI5:\r\n*config |= TUNER_CHARGE_PUMP;\r\nbreak;\r\ncase TUNER_PHILIPS_TUV1236D:\r\n{\r\nstruct tuner_i2c_props i2c = priv->i2c_props;\r\nu8 buffer[4] = { 0x14, 0x00, 0x17, 0x00};\r\n*cb &= ~0x40;\r\nif (params->std & V4L2_STD_ATSC) {\r\n*cb |= 0x40;\r\nbuffer[1] = 0x04;\r\n}\r\ni2c.addr = 0x0a;\r\nrc = tuner_i2c_xfer_send(&i2c, &buffer[0], 2);\r\nif (2 != rc)\r\ntuner_warn("i2c i/o error: rc == %d "\r\n"(should be 2)\n", rc);\r\nrc = tuner_i2c_xfer_send(&i2c, &buffer[2], 2);\r\nif (2 != rc)\r\ntuner_warn("i2c i/o error: rc == %d "\r\n"(should be 2)\n", rc);\r\nbreak;\r\n}\r\n}\r\nif (atv_input[priv->nr])\r\nsimple_set_rf_input(fe, config, cb, atv_input[priv->nr]);\r\nreturn 0;\r\n}\r\nstatic int simple_set_aux_byte(struct dvb_frontend *fe, u8 config, u8 aux)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nint rc;\r\nu8 buffer[2];\r\nbuffer[0] = (config & ~0x38) | 0x18;\r\nbuffer[1] = aux;\r\ntuner_dbg("setting aux byte: 0x%02x 0x%02x\n", buffer[0], buffer[1]);\r\nrc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 2);\r\nif (2 != rc)\r\ntuner_warn("i2c i/o error: rc == %d (should be 2)\n", rc);\r\nreturn rc == 2 ? 0 : rc;\r\n}\r\nstatic int simple_post_tune(struct dvb_frontend *fe, u8 *buffer,\r\nu16 div, u8 config, u8 cb)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nint rc;\r\nswitch (priv->type) {\r\ncase TUNER_LG_TDVS_H06XF:\r\nsimple_set_aux_byte(fe, config, 0x20);\r\nbreak;\r\ncase TUNER_PHILIPS_FQ1216LME_MK3:\r\nsimple_set_aux_byte(fe, config, 0x60);\r\nbreak;\r\ncase TUNER_MICROTUNE_4042FI5:\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1);\r\nu8 status_byte = 0;\r\nfor (;;) {\r\nif (time_after(jiffies, timeout))\r\nreturn 0;\r\nrc = tuner_i2c_xfer_recv(&priv->i2c_props,\r\n&status_byte, 1);\r\nif (1 != rc) {\r\ntuner_warn("i2c i/o read error: rc == %d "\r\n"(should be 1)\n", rc);\r\nbreak;\r\n}\r\nif (status_byte & TUNER_PLL_LOCKED)\r\nbreak;\r\nudelay(10);\r\n}\r\nconfig &= ~TUNER_CHARGE_PUMP;\r\nbuffer[0] = (div>>8) & 0x7f;\r\nbuffer[1] = div & 0xff;\r\nbuffer[2] = config;\r\nbuffer[3] = cb;\r\ntuner_dbg("tv 0x%02x 0x%02x 0x%02x 0x%02x\n",\r\nbuffer[0], buffer[1], buffer[2], buffer[3]);\r\nrc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 4);\r\nif (4 != rc)\r\ntuner_warn("i2c i/o error: rc == %d "\r\n"(should be 4)\n", rc);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int simple_radio_bandswitch(struct dvb_frontend *fe, u8 *buffer)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nswitch (priv->type) {\r\ncase TUNER_TENA_9533_DI:\r\ncase TUNER_YMEC_TVF_5533MF:\r\ntuner_dbg("This tuner doesn't have FM. "\r\n"Most cards have a TEA5767 for FM\n");\r\nreturn 0;\r\ncase TUNER_PHILIPS_FM1216ME_MK3:\r\ncase TUNER_PHILIPS_FM1236_MK3:\r\ncase TUNER_PHILIPS_FMD1216ME_MK3:\r\ncase TUNER_PHILIPS_FMD1216MEX_MK3:\r\ncase TUNER_LG_NTSC_TAPE:\r\ncase TUNER_PHILIPS_FM1256_IH3:\r\ncase TUNER_TCL_MF02GIP_5N:\r\nbuffer[3] = 0x19;\r\nbreak;\r\ncase TUNER_PHILIPS_FM1216MK5:\r\nbuffer[2] = 0x88;\r\nbuffer[3] = 0x09;\r\nbreak;\r\ncase TUNER_TNF_5335MF:\r\nbuffer[3] = 0x11;\r\nbreak;\r\ncase TUNER_LG_PAL_FM:\r\nbuffer[3] = 0xa5;\r\nbreak;\r\ncase TUNER_THOMSON_DTT761X:\r\nbuffer[3] = 0x39;\r\nbreak;\r\ncase TUNER_PHILIPS_FQ1216LME_MK3:\r\ncase TUNER_PHILIPS_FQ1236_MK5:\r\ntuner_err("This tuner doesn't have FM\n");\r\nbuffer[3] = 0x01;\r\nbreak;\r\ncase TUNER_MICROTUNE_4049FM5:\r\ndefault:\r\nbuffer[3] = 0xa4;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int simple_set_tv_freq(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nu8 config, cb;\r\nu16 div;\r\nu8 buffer[4];\r\nint rc, IFPCoff, i;\r\nenum param_type desired_type;\r\nstruct tuner_params *t_params;\r\nif (params->std == V4L2_STD_NTSC_M_JP) {\r\nIFPCoff = 940;\r\ndesired_type = TUNER_PARAM_TYPE_NTSC;\r\n} else if ((params->std & V4L2_STD_MN) &&\r\n!(params->std & ~V4L2_STD_MN)) {\r\nIFPCoff = 732;\r\ndesired_type = TUNER_PARAM_TYPE_NTSC;\r\n} else if (params->std == V4L2_STD_SECAM_LC) {\r\nIFPCoff = 543;\r\ndesired_type = TUNER_PARAM_TYPE_SECAM;\r\n} else {\r\nIFPCoff = 623;\r\ndesired_type = TUNER_PARAM_TYPE_PAL;\r\n}\r\nt_params = simple_tuner_params(fe, desired_type);\r\ni = simple_config_lookup(fe, t_params, &params->frequency,\r\n&config, &cb);\r\ndiv = params->frequency + IFPCoff + offset;\r\ntuner_dbg("Freq= %d.%02d MHz, V_IF=%d.%02d MHz, "\r\n"Offset=%d.%02d MHz, div=%0d\n",\r\nparams->frequency / 16, params->frequency % 16 * 100 / 16,\r\nIFPCoff / 16, IFPCoff % 16 * 100 / 16,\r\noffset / 16, offset % 16 * 100 / 16, div);\r\nsimple_std_setup(fe, params, &config, &cb);\r\nif (t_params->cb_first_if_lower_freq && div < priv->last_div) {\r\nbuffer[0] = config;\r\nbuffer[1] = cb;\r\nbuffer[2] = (div>>8) & 0x7f;\r\nbuffer[3] = div & 0xff;\r\n} else {\r\nbuffer[0] = (div>>8) & 0x7f;\r\nbuffer[1] = div & 0xff;\r\nbuffer[2] = config;\r\nbuffer[3] = cb;\r\n}\r\npriv->last_div = div;\r\nif (t_params->has_tda9887) {\r\nstruct v4l2_priv_tun_config tda9887_cfg;\r\nint tda_config = 0;\r\nint is_secam_l = (params->std & (V4L2_STD_SECAM_L |\r\nV4L2_STD_SECAM_LC)) &&\r\n!(params->std & ~(V4L2_STD_SECAM_L |\r\nV4L2_STD_SECAM_LC));\r\ntda9887_cfg.tuner = TUNER_TDA9887;\r\ntda9887_cfg.priv = &tda_config;\r\nif (params->std == V4L2_STD_SECAM_LC) {\r\nif (t_params->port1_active ^ t_params->port1_invert_for_secam_lc)\r\ntda_config |= TDA9887_PORT1_ACTIVE;\r\nif (t_params->port2_active ^ t_params->port2_invert_for_secam_lc)\r\ntda_config |= TDA9887_PORT2_ACTIVE;\r\n} else {\r\nif (t_params->port1_active)\r\ntda_config |= TDA9887_PORT1_ACTIVE;\r\nif (t_params->port2_active)\r\ntda_config |= TDA9887_PORT2_ACTIVE;\r\n}\r\nif (t_params->intercarrier_mode)\r\ntda_config |= TDA9887_INTERCARRIER;\r\nif (is_secam_l) {\r\nif (i == 0 && t_params->default_top_secam_low)\r\ntda_config |= TDA9887_TOP(t_params->default_top_secam_low);\r\nelse if (i == 1 && t_params->default_top_secam_mid)\r\ntda_config |= TDA9887_TOP(t_params->default_top_secam_mid);\r\nelse if (t_params->default_top_secam_high)\r\ntda_config |= TDA9887_TOP(t_params->default_top_secam_high);\r\n} else {\r\nif (i == 0 && t_params->default_top_low)\r\ntda_config |= TDA9887_TOP(t_params->default_top_low);\r\nelse if (i == 1 && t_params->default_top_mid)\r\ntda_config |= TDA9887_TOP(t_params->default_top_mid);\r\nelse if (t_params->default_top_high)\r\ntda_config |= TDA9887_TOP(t_params->default_top_high);\r\n}\r\nif (t_params->default_pll_gating_18)\r\ntda_config |= TDA9887_GATING_18;\r\ni2c_clients_command(priv->i2c_props.adap, TUNER_SET_CONFIG,\r\n&tda9887_cfg);\r\n}\r\ntuner_dbg("tv 0x%02x 0x%02x 0x%02x 0x%02x\n",\r\nbuffer[0], buffer[1], buffer[2], buffer[3]);\r\nrc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 4);\r\nif (4 != rc)\r\ntuner_warn("i2c i/o error: rc == %d (should be 4)\n", rc);\r\nsimple_post_tune(fe, &buffer[0], div, config, cb);\r\nreturn 0;\r\n}\r\nstatic int simple_set_radio_freq(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct tunertype *tun;\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nu8 buffer[4];\r\nu16 div;\r\nint rc, j;\r\nstruct tuner_params *t_params;\r\nunsigned int freq = params->frequency;\r\ntun = priv->tun;\r\nfor (j = tun->count-1; j > 0; j--)\r\nif (tun->params[j].type == TUNER_PARAM_TYPE_RADIO)\r\nbreak;\r\nt_params = &tun->params[j];\r\nswitch (t_params->radio_if) {\r\ncase 0:\r\nfreq += (unsigned int)(10.7*16000);\r\nbreak;\r\ncase 1:\r\nfreq += (unsigned int)(33.3*16000);\r\nbreak;\r\ncase 2:\r\nfreq += (unsigned int)(41.3*16000);\r\nbreak;\r\ndefault:\r\ntuner_warn("Unsupported radio_if value %d\n",\r\nt_params->radio_if);\r\nreturn 0;\r\n}\r\nbuffer[2] = (t_params->ranges[0].config & ~TUNER_RATIO_MASK) |\r\nTUNER_RATIO_SELECT_50;\r\nsimple_radio_bandswitch(fe, &buffer[0]);\r\ndiv = (freq + 400) / 800;\r\nif (t_params->cb_first_if_lower_freq && div < priv->last_div) {\r\nbuffer[0] = buffer[2];\r\nbuffer[1] = buffer[3];\r\nbuffer[2] = (div>>8) & 0x7f;\r\nbuffer[3] = div & 0xff;\r\n} else {\r\nbuffer[0] = (div>>8) & 0x7f;\r\nbuffer[1] = div & 0xff;\r\n}\r\ntuner_dbg("radio 0x%02x 0x%02x 0x%02x 0x%02x\n",\r\nbuffer[0], buffer[1], buffer[2], buffer[3]);\r\npriv->last_div = div;\r\nif (t_params->has_tda9887) {\r\nint config = 0;\r\nstruct v4l2_priv_tun_config tda9887_cfg;\r\ntda9887_cfg.tuner = TUNER_TDA9887;\r\ntda9887_cfg.priv = &config;\r\nif (t_params->port1_active &&\r\n!t_params->port1_fm_high_sensitivity)\r\nconfig |= TDA9887_PORT1_ACTIVE;\r\nif (t_params->port2_active &&\r\n!t_params->port2_fm_high_sensitivity)\r\nconfig |= TDA9887_PORT2_ACTIVE;\r\nif (t_params->intercarrier_mode)\r\nconfig |= TDA9887_INTERCARRIER;\r\nif (t_params->fm_gain_normal)\r\nconfig |= TDA9887_GAIN_NORMAL;\r\nif (t_params->radio_if == 2)\r\nconfig |= TDA9887_RIF_41_3;\r\ni2c_clients_command(priv->i2c_props.adap, TUNER_SET_CONFIG,\r\n&tda9887_cfg);\r\n}\r\nrc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 4);\r\nif (4 != rc)\r\ntuner_warn("i2c i/o error: rc == %d (should be 4)\n", rc);\r\nswitch (priv->type) {\r\ncase TUNER_PHILIPS_FM1216ME_MK3:\r\nbuffer[2] = 0x98;\r\nbuffer[3] = 0x20;\r\nrc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 4);\r\nif (4 != rc)\r\ntuner_warn("i2c i/o error: rc == %d (should be 4)\n", rc);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int simple_set_params(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nint ret = -EINVAL;\r\nif (priv->i2c_props.adap == NULL)\r\nreturn -EINVAL;\r\nswitch (params->mode) {\r\ncase V4L2_TUNER_RADIO:\r\npriv->radio_mode = true;\r\nret = simple_set_radio_freq(fe, params);\r\npriv->frequency = params->frequency * 125 / 2;\r\nbreak;\r\ncase V4L2_TUNER_ANALOG_TV:\r\ncase V4L2_TUNER_DIGITAL_TV:\r\npriv->radio_mode = false;\r\nret = simple_set_tv_freq(fe, params);\r\npriv->frequency = params->frequency * 62500;\r\nbreak;\r\n}\r\npriv->bandwidth = 0;\r\nreturn ret;\r\n}\r\nstatic void simple_set_dvb(struct dvb_frontend *fe, u8 *buf,\r\nconst u32 delsys,\r\nconst u32 frequency,\r\nconst u32 bandwidth)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nswitch (priv->type) {\r\ncase TUNER_PHILIPS_FMD1216ME_MK3:\r\ncase TUNER_PHILIPS_FMD1216MEX_MK3:\r\nif (bandwidth == 8000000 &&\r\nfrequency >= 158870000)\r\nbuf[3] |= 0x08;\r\nbreak;\r\ncase TUNER_PHILIPS_TD1316:\r\nbuf[3] |= (frequency < 161000000) ? 1 :\r\n(frequency < 444000000) ? 2 : 4;\r\nif (bandwidth == 8000000)\r\nbuf[3] |= 1 << 3;\r\nbreak;\r\ncase TUNER_PHILIPS_TUV1236D:\r\ncase TUNER_PHILIPS_FCV1236D:\r\n{\r\nunsigned int new_rf;\r\nif (dtv_input[priv->nr])\r\nnew_rf = dtv_input[priv->nr];\r\nelse\r\nswitch (delsys) {\r\ncase SYS_DVBC_ANNEX_B:\r\nnew_rf = 1;\r\nbreak;\r\ncase SYS_ATSC:\r\ndefault:\r\nnew_rf = 0;\r\nbreak;\r\n}\r\nsimple_set_rf_input(fe, &buf[2], &buf[3], new_rf);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic u32 simple_dvb_configure(struct dvb_frontend *fe, u8 *buf,\r\nconst u32 delsys,\r\nconst u32 freq,\r\nconst u32 bw)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nstruct tunertype *tun = priv->tun;\r\nstatic struct tuner_params *t_params;\r\nu8 config, cb;\r\nu32 div;\r\nint ret;\r\nu32 frequency = freq / 62500;\r\nif (!tun->stepsize) {\r\ntuner_err("attempt to treat tuner %d (%s) as digital tuner "\r\n"without stepsize defined.\n",\r\npriv->type, priv->tun->name);\r\nreturn 0;\r\n}\r\nt_params = simple_tuner_params(fe, TUNER_PARAM_TYPE_DIGITAL);\r\nret = simple_config_lookup(fe, t_params, &frequency, &config, &cb);\r\nif (ret < 0)\r\nreturn 0;\r\ndiv = ((frequency + t_params->iffreq) * 62500 + offset +\r\ntun->stepsize/2) / tun->stepsize;\r\nbuf[0] = div >> 8;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = config;\r\nbuf[3] = cb;\r\nsimple_set_dvb(fe, buf, delsys, freq, bw);\r\ntuner_dbg("%s: div=%d | buf=0x%02x,0x%02x,0x%02x,0x%02x\n",\r\ntun->name, div, buf[0], buf[1], buf[2], buf[3]);\r\nreturn (div * tun->stepsize) - t_params->iffreq;\r\n}\r\nstatic int simple_dvb_calc_regs(struct dvb_frontend *fe,\r\nu8 *buf, int buf_len)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 delsys = c->delivery_system;\r\nu32 bw = c->bandwidth_hz;\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nu32 frequency;\r\nif (buf_len < 5)\r\nreturn -EINVAL;\r\nfrequency = simple_dvb_configure(fe, buf+1, delsys, c->frequency, bw);\r\nif (frequency == 0)\r\nreturn -EINVAL;\r\nbuf[0] = priv->i2c_props.addr;\r\npriv->frequency = frequency;\r\npriv->bandwidth = c->bandwidth_hz;\r\nreturn 5;\r\n}\r\nstatic int simple_dvb_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 delsys = c->delivery_system;\r\nu32 bw = c->bandwidth_hz;\r\nu32 freq = c->frequency;\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nu32 frequency;\r\nu32 prev_freq, prev_bw;\r\nint ret;\r\nu8 buf[5];\r\nif (priv->i2c_props.adap == NULL)\r\nreturn -EINVAL;\r\nprev_freq = priv->frequency;\r\nprev_bw = priv->bandwidth;\r\nfrequency = simple_dvb_configure(fe, buf+1, delsys, freq, bw);\r\nif (frequency == 0)\r\nreturn -EINVAL;\r\nbuf[0] = priv->i2c_props.addr;\r\npriv->frequency = frequency;\r\npriv->bandwidth = bw;\r\nif (fe->ops.analog_ops.standby)\r\nfe->ops.analog_ops.standby(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = tuner_i2c_xfer_send(&priv->i2c_props, buf+1, 4);\r\nif (ret != 4)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\npriv->frequency = prev_freq;\r\npriv->bandwidth = prev_bw;\r\nreturn ret;\r\n}\r\nstatic int simple_init(struct dvb_frontend *fe)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nif (priv->i2c_props.adap == NULL)\r\nreturn -EINVAL;\r\nif (priv->tun->initdata) {\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = tuner_i2c_xfer_send(&priv->i2c_props,\r\npriv->tun->initdata + 1,\r\npriv->tun->initdata[0]);\r\nif (ret != priv->tun->initdata[0])\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int simple_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nif (priv->i2c_props.adap == NULL)\r\nreturn -EINVAL;\r\nif (priv->tun->sleepdata) {\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = tuner_i2c_xfer_send(&priv->i2c_props,\r\npriv->tun->sleepdata + 1,\r\npriv->tun->sleepdata[0]);\r\nif (ret != priv->tun->sleepdata[0])\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int simple_release(struct dvb_frontend *fe)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\nmutex_lock(&tuner_simple_list_mutex);\r\nif (priv)\r\nhybrid_tuner_release_state(priv);\r\nmutex_unlock(&tuner_simple_list_mutex);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int simple_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int simple_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nstruct tuner_simple_priv *priv = fe->tuner_priv;\r\n*bandwidth = priv->bandwidth;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *simple_tuner_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c_adap,\r\nu8 i2c_addr,\r\nunsigned int type)\r\n{\r\nstruct tuner_simple_priv *priv = NULL;\r\nint instance;\r\nif (type >= tuner_count) {\r\nprintk(KERN_WARNING "%s: invalid tuner type: %d (max: %d)\n",\r\n__func__, type, tuner_count-1);\r\nreturn NULL;\r\n}\r\nif (i2c_adap != NULL) {\r\nu8 b[1];\r\nstruct i2c_msg msg = {\r\n.addr = i2c_addr, .flags = I2C_M_RD,\r\n.buf = b, .len = 1,\r\n};\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (1 != i2c_transfer(i2c_adap, &msg, 1))\r\nprintk(KERN_WARNING "tuner-simple %d-%04x: "\r\n"unable to probe %s, proceeding anyway.",\r\ni2c_adapter_id(i2c_adap), i2c_addr,\r\ntuners[type].name);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nmutex_lock(&tuner_simple_list_mutex);\r\ninstance = hybrid_tuner_request_state(struct tuner_simple_priv, priv,\r\nhybrid_tuner_instance_list,\r\ni2c_adap, i2c_addr,\r\n"tuner-simple");\r\nswitch (instance) {\r\ncase 0:\r\nmutex_unlock(&tuner_simple_list_mutex);\r\nreturn NULL;\r\ncase 1:\r\nfe->tuner_priv = priv;\r\npriv->type = type;\r\npriv->tun = &tuners[type];\r\npriv->nr = simple_devcount++;\r\nbreak;\r\ndefault:\r\nfe->tuner_priv = priv;\r\nbreak;\r\n}\r\nmutex_unlock(&tuner_simple_list_mutex);\r\nmemcpy(&fe->ops.tuner_ops, &simple_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nif (type != priv->type)\r\ntuner_warn("couldn't set type to %d. Using %d (%s) instead\n",\r\ntype, priv->type, priv->tun->name);\r\nelse\r\ntuner_info("type set to %d (%s)\n",\r\npriv->type, priv->tun->name);\r\nif ((debug) || ((atv_input[priv->nr] > 0) ||\r\n(dtv_input[priv->nr] > 0))) {\r\nif (0 == atv_input[priv->nr])\r\ntuner_info("tuner %d atv rf input will be "\r\n"autoselected\n", priv->nr);\r\nelse\r\ntuner_info("tuner %d atv rf input will be "\r\n"set to input %d (insmod option)\n",\r\npriv->nr, atv_input[priv->nr]);\r\nif (0 == dtv_input[priv->nr])\r\ntuner_info("tuner %d dtv rf input will be "\r\n"autoselected\n", priv->nr);\r\nelse\r\ntuner_info("tuner %d dtv rf input will be "\r\n"set to input %d (insmod option)\n",\r\npriv->nr, dtv_input[priv->nr]);\r\n}\r\nstrlcpy(fe->ops.tuner_ops.info.name, priv->tun->name,\r\nsizeof(fe->ops.tuner_ops.info.name));\r\nreturn fe;\r\n}
