static int proc_status_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "Emulated SWP:\t\t%lu\n", swpcounter);\r\nseq_printf(m, "Emulated SWPB:\t\t%lu\n", swpbcounter);\r\nseq_printf(m, "Aborted SWP{B}:\t\t%lu\n", abtcounter);\r\nif (previous_pid != 0)\r\nseq_printf(m, "Last process:\t\t%d\n", previous_pid);\r\nreturn 0;\r\n}\r\nstatic int proc_status_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_status_show, PDE_DATA(inode));\r\n}\r\nstatic void set_segfault(struct pt_regs *regs, unsigned long addr)\r\n{\r\nsiginfo_t info;\r\ndown_read(&current->mm->mmap_sem);\r\nif (find_vma(current->mm, addr) == NULL)\r\ninfo.si_code = SEGV_MAPERR;\r\nelse\r\ninfo.si_code = SEGV_ACCERR;\r\nup_read(&current->mm->mmap_sem);\r\ninfo.si_signo = SIGSEGV;\r\ninfo.si_errno = 0;\r\ninfo.si_addr = (void *) instruction_pointer(regs);\r\npr_debug("SWP{B} emulation: access caused memory abort!\n");\r\narm_notify_die("Illegal memory access", regs, &info, 0, 0);\r\nabtcounter++;\r\n}\r\nstatic int emulate_swpX(unsigned int address, unsigned int *data,\r\nunsigned int type)\r\n{\r\nunsigned int res = 0;\r\nif ((type != TYPE_SWPB) && (address & 0x3)) {\r\npr_debug("SWP instruction on unaligned pointer!\n");\r\nreturn -EFAULT;\r\n}\r\nwhile (1) {\r\nunsigned long temp;\r\nif (type == TYPE_SWPB)\r\n__user_swpb_asm(*data, address, res, temp);\r\nelse\r\n__user_swp_asm(*data, address, res, temp);\r\nif (likely(res != -EAGAIN) || signal_pending(current))\r\nbreak;\r\ncond_resched();\r\n}\r\nif (res == 0) {\r\nif (type == TYPE_SWPB)\r\nswpbcounter++;\r\nelse\r\nswpcounter++;\r\n}\r\nreturn res;\r\n}\r\nstatic int swp_handler(struct pt_regs *regs, unsigned int instr)\r\n{\r\nunsigned int address, destreg, data, type;\r\nunsigned int res = 0;\r\nperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, regs->ARM_pc);\r\nres = arm_check_condition(instr, regs->ARM_cpsr);\r\nswitch (res) {\r\ncase ARM_OPCODE_CONDTEST_PASS:\r\nbreak;\r\ncase ARM_OPCODE_CONDTEST_FAIL:\r\nregs->ARM_pc += 4;\r\nreturn 0;\r\ncase ARM_OPCODE_CONDTEST_UNCOND:\r\nreturn -EFAULT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (current->pid != previous_pid) {\r\npr_debug("\"%s\" (%ld) uses deprecated SWP{B} instruction\n",\r\ncurrent->comm, (unsigned long)current->pid);\r\nprevious_pid = current->pid;\r\n}\r\naddress = regs->uregs[EXTRACT_REG_NUM(instr, RN_OFFSET)];\r\ndata = regs->uregs[EXTRACT_REG_NUM(instr, RT2_OFFSET)];\r\ndestreg = EXTRACT_REG_NUM(instr, RT_OFFSET);\r\ntype = instr & TYPE_SWPB;\r\npr_debug("addr in r%d->0x%08x, dest is r%d, source in r%d->0x%08x)\n",\r\nEXTRACT_REG_NUM(instr, RN_OFFSET), address,\r\ndestreg, EXTRACT_REG_NUM(instr, RT2_OFFSET), data);\r\nif (!access_ok(VERIFY_WRITE, (address & ~3), 4)) {\r\npr_debug("SWP{B} emulation: access to %p not allowed!\n",\r\n(void *)address);\r\nres = -EFAULT;\r\n} else {\r\nres = emulate_swpX(address, &data, type);\r\n}\r\nif (res == 0) {\r\nregs->ARM_pc += 4;\r\nregs->uregs[destreg] = data;\r\n} else if (res == -EFAULT) {\r\nset_segfault(regs, address);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init swp_emulation_init(void)\r\n{\r\nif (cpu_architecture() < CPU_ARCH_ARMv7)\r\nreturn 0;\r\n#ifdef CONFIG_PROC_FS\r\nif (!proc_create("cpu/swp_emulation", S_IRUGO, NULL, &proc_status_fops))\r\nreturn -ENOMEM;\r\n#endif\r\nprintk(KERN_NOTICE "Registering SWP/SWPB emulation handler\n");\r\nregister_undef_hook(&swp_hook);\r\nreturn 0;\r\n}
