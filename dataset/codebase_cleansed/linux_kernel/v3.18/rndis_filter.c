static struct rndis_device *get_rndis_device(void)\r\n{\r\nstruct rndis_device *device;\r\ndevice = kzalloc(sizeof(struct rndis_device), GFP_KERNEL);\r\nif (!device)\r\nreturn NULL;\r\nspin_lock_init(&device->request_lock);\r\nINIT_LIST_HEAD(&device->req_list);\r\ndevice->state = RNDIS_DEV_UNINITIALIZED;\r\nreturn device;\r\n}\r\nstatic struct rndis_request *get_rndis_request(struct rndis_device *dev,\r\nu32 msg_type,\r\nu32 msg_len)\r\n{\r\nstruct rndis_request *request;\r\nstruct rndis_message *rndis_msg;\r\nstruct rndis_set_request *set;\r\nunsigned long flags;\r\nrequest = kzalloc(sizeof(struct rndis_request), GFP_KERNEL);\r\nif (!request)\r\nreturn NULL;\r\ninit_completion(&request->wait_event);\r\nrndis_msg = &request->request_msg;\r\nrndis_msg->ndis_msg_type = msg_type;\r\nrndis_msg->msg_len = msg_len;\r\nrequest->pkt.q_idx = 0;\r\nset = &rndis_msg->msg.set_req;\r\nset->req_id = atomic_inc_return(&dev->new_req_id);\r\nspin_lock_irqsave(&dev->request_lock, flags);\r\nlist_add_tail(&request->list_ent, &dev->req_list);\r\nspin_unlock_irqrestore(&dev->request_lock, flags);\r\nreturn request;\r\n}\r\nstatic void put_rndis_request(struct rndis_device *dev,\r\nstruct rndis_request *req)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->request_lock, flags);\r\nlist_del(&req->list_ent);\r\nspin_unlock_irqrestore(&dev->request_lock, flags);\r\nkfree(req);\r\n}\r\nstatic void dump_rndis_message(struct hv_device *hv_dev,\r\nstruct rndis_message *rndis_msg)\r\n{\r\nstruct net_device *netdev;\r\nstruct netvsc_device *net_device;\r\nnet_device = hv_get_drvdata(hv_dev);\r\nnetdev = net_device->ndev;\r\nswitch (rndis_msg->ndis_msg_type) {\r\ncase RNDIS_MSG_PACKET:\r\nnetdev_dbg(netdev, "RNDIS_MSG_PACKET (len %u, "\r\n"data offset %u data len %u, # oob %u, "\r\n"oob offset %u, oob len %u, pkt offset %u, "\r\n"pkt len %u\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.pkt.data_offset,\r\nrndis_msg->msg.pkt.data_len,\r\nrndis_msg->msg.pkt.num_oob_data_elements,\r\nrndis_msg->msg.pkt.oob_data_offset,\r\nrndis_msg->msg.pkt.oob_data_len,\r\nrndis_msg->msg.pkt.per_pkt_info_offset,\r\nrndis_msg->msg.pkt.per_pkt_info_len);\r\nbreak;\r\ncase RNDIS_MSG_INIT_C:\r\nnetdev_dbg(netdev, "RNDIS_MSG_INIT_C "\r\n"(len %u, id 0x%x, status 0x%x, major %d, minor %d, "\r\n"device flags %d, max xfer size 0x%x, max pkts %u, "\r\n"pkt aligned %u)\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.init_complete.req_id,\r\nrndis_msg->msg.init_complete.status,\r\nrndis_msg->msg.init_complete.major_ver,\r\nrndis_msg->msg.init_complete.minor_ver,\r\nrndis_msg->msg.init_complete.dev_flags,\r\nrndis_msg->msg.init_complete.max_xfer_size,\r\nrndis_msg->msg.init_complete.\r\nmax_pkt_per_msg,\r\nrndis_msg->msg.init_complete.\r\npkt_alignment_factor);\r\nbreak;\r\ncase RNDIS_MSG_QUERY_C:\r\nnetdev_dbg(netdev, "RNDIS_MSG_QUERY_C "\r\n"(len %u, id 0x%x, status 0x%x, buf len %u, "\r\n"buf offset %u)\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.query_complete.req_id,\r\nrndis_msg->msg.query_complete.status,\r\nrndis_msg->msg.query_complete.\r\ninfo_buflen,\r\nrndis_msg->msg.query_complete.\r\ninfo_buf_offset);\r\nbreak;\r\ncase RNDIS_MSG_SET_C:\r\nnetdev_dbg(netdev,\r\n"RNDIS_MSG_SET_C (len %u, id 0x%x, status 0x%x)\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.set_complete.req_id,\r\nrndis_msg->msg.set_complete.status);\r\nbreak;\r\ncase RNDIS_MSG_INDICATE:\r\nnetdev_dbg(netdev, "RNDIS_MSG_INDICATE "\r\n"(len %u, status 0x%x, buf len %u, buf offset %u)\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.indicate_status.status,\r\nrndis_msg->msg.indicate_status.status_buflen,\r\nrndis_msg->msg.indicate_status.status_buf_offset);\r\nbreak;\r\ndefault:\r\nnetdev_dbg(netdev, "0x%x (len %u)\n",\r\nrndis_msg->ndis_msg_type,\r\nrndis_msg->msg_len);\r\nbreak;\r\n}\r\n}\r\nstatic int rndis_filter_send_request(struct rndis_device *dev,\r\nstruct rndis_request *req)\r\n{\r\nint ret;\r\nstruct hv_netvsc_packet *packet;\r\npacket = &req->pkt;\r\npacket->is_data_pkt = false;\r\npacket->total_data_buflen = req->request_msg.msg_len;\r\npacket->page_buf_cnt = 1;\r\npacket->page_buf[0].pfn = virt_to_phys(&req->request_msg) >>\r\nPAGE_SHIFT;\r\npacket->page_buf[0].len = req->request_msg.msg_len;\r\npacket->page_buf[0].offset =\r\n(unsigned long)&req->request_msg & (PAGE_SIZE - 1);\r\nif (packet->page_buf[0].offset + packet->page_buf[0].len > PAGE_SIZE) {\r\npacket->page_buf_cnt++;\r\npacket->page_buf[0].len = PAGE_SIZE -\r\npacket->page_buf[0].offset;\r\npacket->page_buf[1].pfn = virt_to_phys((void *)&req->request_msg\r\n+ packet->page_buf[0].len) >> PAGE_SHIFT;\r\npacket->page_buf[1].offset = 0;\r\npacket->page_buf[1].len = req->request_msg.msg_len -\r\npacket->page_buf[0].len;\r\n}\r\npacket->send_completion = NULL;\r\nret = netvsc_send(dev->net_dev->dev, packet);\r\nreturn ret;\r\n}\r\nstatic void rndis_set_link_state(struct rndis_device *rdev,\r\nstruct rndis_request *request)\r\n{\r\nu32 link_status;\r\nstruct rndis_query_complete *query_complete;\r\nquery_complete = &request->response_msg.msg.query_complete;\r\nif (query_complete->status == RNDIS_STATUS_SUCCESS &&\r\nquery_complete->info_buflen == sizeof(u32)) {\r\nmemcpy(&link_status, (void *)((unsigned long)query_complete +\r\nquery_complete->info_buf_offset), sizeof(u32));\r\nrdev->link_state = link_status != 0;\r\n}\r\n}\r\nstatic void rndis_filter_receive_response(struct rndis_device *dev,\r\nstruct rndis_message *resp)\r\n{\r\nstruct rndis_request *request = NULL;\r\nbool found = false;\r\nunsigned long flags;\r\nstruct net_device *ndev;\r\nndev = dev->net_dev->ndev;\r\nspin_lock_irqsave(&dev->request_lock, flags);\r\nlist_for_each_entry(request, &dev->req_list, list_ent) {\r\nif (request->request_msg.msg.init_req.req_id\r\n== resp->msg.init_complete.req_id) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->request_lock, flags);\r\nif (found) {\r\nif (resp->msg_len <=\r\nsizeof(struct rndis_message) + RNDIS_EXT_LEN) {\r\nmemcpy(&request->response_msg, resp,\r\nresp->msg_len);\r\nif (request->request_msg.ndis_msg_type ==\r\nRNDIS_MSG_QUERY && request->request_msg.msg.\r\nquery_req.oid == RNDIS_OID_GEN_MEDIA_CONNECT_STATUS)\r\nrndis_set_link_state(dev, request);\r\n} else {\r\nnetdev_err(ndev,\r\n"rndis response buffer overflow "\r\n"detected (size %u max %zu)\n",\r\nresp->msg_len,\r\nsizeof(struct rndis_message));\r\nif (resp->ndis_msg_type ==\r\nRNDIS_MSG_RESET_C) {\r\nrequest->response_msg.msg.reset_complete.\r\nstatus = RNDIS_STATUS_BUFFER_OVERFLOW;\r\n} else {\r\nrequest->response_msg.msg.\r\ninit_complete.status =\r\nRNDIS_STATUS_BUFFER_OVERFLOW;\r\n}\r\n}\r\ncomplete(&request->wait_event);\r\n} else {\r\nnetdev_err(ndev,\r\n"no rndis request found for this response "\r\n"(id 0x%x res type 0x%x)\n",\r\nresp->msg.init_complete.req_id,\r\nresp->ndis_msg_type);\r\n}\r\n}\r\nstatic inline void *rndis_get_ppi(struct rndis_packet *rpkt, u32 type)\r\n{\r\nstruct rndis_per_packet_info *ppi;\r\nint len;\r\nif (rpkt->per_pkt_info_offset == 0)\r\nreturn NULL;\r\nppi = (struct rndis_per_packet_info *)((ulong)rpkt +\r\nrpkt->per_pkt_info_offset);\r\nlen = rpkt->per_pkt_info_len;\r\nwhile (len > 0) {\r\nif (ppi->type == type)\r\nreturn (void *)((ulong)ppi + ppi->ppi_offset);\r\nlen -= ppi->size;\r\nppi = (struct rndis_per_packet_info *)((ulong)ppi + ppi->size);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void rndis_filter_receive_data(struct rndis_device *dev,\r\nstruct rndis_message *msg,\r\nstruct hv_netvsc_packet *pkt)\r\n{\r\nstruct rndis_packet *rndis_pkt;\r\nu32 data_offset;\r\nstruct ndis_pkt_8021q_info *vlan;\r\nstruct ndis_tcp_ip_checksum_info *csum_info;\r\nrndis_pkt = &msg->msg.pkt;\r\ndata_offset = RNDIS_HEADER_SIZE + rndis_pkt->data_offset;\r\npkt->total_data_buflen -= data_offset;\r\nif (pkt->total_data_buflen < rndis_pkt->data_len) {\r\nnetdev_err(dev->net_dev->ndev, "rndis message buffer "\r\n"overflow detected (got %u, min %u)"\r\n"...dropping this message!\n",\r\npkt->total_data_buflen, rndis_pkt->data_len);\r\nreturn;\r\n}\r\npkt->total_data_buflen = rndis_pkt->data_len;\r\npkt->data = (void *)((unsigned long)pkt->data + data_offset);\r\nvlan = rndis_get_ppi(rndis_pkt, IEEE_8021Q_INFO);\r\nif (vlan) {\r\npkt->vlan_tci = VLAN_TAG_PRESENT | vlan->vlanid |\r\n(vlan->pri << VLAN_PRIO_SHIFT);\r\n} else {\r\npkt->vlan_tci = 0;\r\n}\r\ncsum_info = rndis_get_ppi(rndis_pkt, TCPIP_CHKSUM_PKTINFO);\r\nnetvsc_recv_callback(dev->net_dev->dev, pkt, csum_info);\r\n}\r\nint rndis_filter_receive(struct hv_device *dev,\r\nstruct hv_netvsc_packet *pkt)\r\n{\r\nstruct netvsc_device *net_dev = hv_get_drvdata(dev);\r\nstruct rndis_device *rndis_dev;\r\nstruct rndis_message *rndis_msg;\r\nstruct net_device *ndev;\r\nint ret = 0;\r\nif (!net_dev) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nndev = net_dev->ndev;\r\nif (!net_dev->extension) {\r\nnetdev_err(ndev, "got rndis message but no rndis device - "\r\n"dropping this message!\n");\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\nrndis_dev = (struct rndis_device *)net_dev->extension;\r\nif (rndis_dev->state == RNDIS_DEV_UNINITIALIZED) {\r\nnetdev_err(ndev, "got rndis message but rndis device "\r\n"uninitialized...dropping this message!\n");\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\nrndis_msg = pkt->data;\r\ndump_rndis_message(dev, rndis_msg);\r\nswitch (rndis_msg->ndis_msg_type) {\r\ncase RNDIS_MSG_PACKET:\r\nrndis_filter_receive_data(rndis_dev, rndis_msg, pkt);\r\nbreak;\r\ncase RNDIS_MSG_INIT_C:\r\ncase RNDIS_MSG_QUERY_C:\r\ncase RNDIS_MSG_SET_C:\r\nrndis_filter_receive_response(rndis_dev, rndis_msg);\r\nbreak;\r\ncase RNDIS_MSG_INDICATE:\r\nnetvsc_linkstatus_callback(dev, rndis_msg);\r\nbreak;\r\ndefault:\r\nnetdev_err(ndev,\r\n"unhandled rndis message (type %u len %u)\n",\r\nrndis_msg->ndis_msg_type,\r\nrndis_msg->msg_len);\r\nbreak;\r\n}\r\nexit:\r\nif (ret != 0)\r\npkt->status = NVSP_STAT_FAIL;\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_query_device(struct rndis_device *dev, u32 oid,\r\nvoid *result, u32 *result_size)\r\n{\r\nstruct rndis_request *request;\r\nu32 inresult_size = *result_size;\r\nstruct rndis_query_request *query;\r\nstruct rndis_query_complete *query_complete;\r\nint ret = 0;\r\nint t;\r\nif (!result)\r\nreturn -EINVAL;\r\n*result_size = 0;\r\nrequest = get_rndis_request(dev, RNDIS_MSG_QUERY,\r\nRNDIS_MESSAGE_SIZE(struct rndis_query_request));\r\nif (!request) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nquery = &request->request_msg.msg.query_req;\r\nquery->oid = oid;\r\nquery->info_buf_offset = sizeof(struct rndis_query_request);\r\nquery->info_buflen = 0;\r\nquery->dev_vc_handle = 0;\r\nif (oid == OID_GEN_RECEIVE_SCALE_CAPABILITIES) {\r\nstruct ndis_recv_scale_cap *cap;\r\nrequest->request_msg.msg_len +=\r\nsizeof(struct ndis_recv_scale_cap);\r\nquery->info_buflen = sizeof(struct ndis_recv_scale_cap);\r\ncap = (struct ndis_recv_scale_cap *)((unsigned long)query +\r\nquery->info_buf_offset);\r\ncap->hdr.type = NDIS_OBJECT_TYPE_RSS_CAPABILITIES;\r\ncap->hdr.rev = NDIS_RECEIVE_SCALE_CAPABILITIES_REVISION_2;\r\ncap->hdr.size = sizeof(struct ndis_recv_scale_cap);\r\n}\r\nret = rndis_filter_send_request(dev, request);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nquery_complete = &request->response_msg.msg.query_complete;\r\nif (query_complete->info_buflen > inresult_size) {\r\nret = -1;\r\ngoto cleanup;\r\n}\r\nmemcpy(result,\r\n(void *)((unsigned long)query_complete +\r\nquery_complete->info_buf_offset),\r\nquery_complete->info_buflen);\r\n*result_size = query_complete->info_buflen;\r\ncleanup:\r\nif (request)\r\nput_rndis_request(dev, request);\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_query_device_mac(struct rndis_device *dev)\r\n{\r\nu32 size = ETH_ALEN;\r\nreturn rndis_filter_query_device(dev,\r\nRNDIS_OID_802_3_PERMANENT_ADDRESS,\r\ndev->hw_mac_adr, &size);\r\n}\r\nint rndis_filter_set_device_mac(struct hv_device *hdev, char *mac)\r\n{\r\nstruct netvsc_device *nvdev = hv_get_drvdata(hdev);\r\nstruct rndis_device *rdev = nvdev->extension;\r\nstruct net_device *ndev = nvdev->ndev;\r\nstruct rndis_request *request;\r\nstruct rndis_set_request *set;\r\nstruct rndis_config_parameter_info *cpi;\r\nwchar_t *cfg_nwadr, *cfg_mac;\r\nstruct rndis_set_complete *set_complete;\r\nchar macstr[2*ETH_ALEN+1];\r\nu32 extlen = sizeof(struct rndis_config_parameter_info) +\r\n2*NWADR_STRLEN + 4*ETH_ALEN;\r\nint ret, t;\r\nrequest = get_rndis_request(rdev, RNDIS_MSG_SET,\r\nRNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);\r\nif (!request)\r\nreturn -ENOMEM;\r\nset = &request->request_msg.msg.set_req;\r\nset->oid = RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER;\r\nset->info_buflen = extlen;\r\nset->info_buf_offset = sizeof(struct rndis_set_request);\r\nset->dev_vc_handle = 0;\r\ncpi = (struct rndis_config_parameter_info *)((ulong)set +\r\nset->info_buf_offset);\r\ncpi->parameter_name_offset =\r\nsizeof(struct rndis_config_parameter_info);\r\ncpi->parameter_name_length = 2*NWADR_STRLEN;\r\ncpi->parameter_type = RNDIS_CONFIG_PARAM_TYPE_STRING;\r\ncpi->parameter_value_offset =\r\ncpi->parameter_name_offset + cpi->parameter_name_length;\r\ncpi->parameter_value_length = 4*ETH_ALEN;\r\ncfg_nwadr = (wchar_t *)((ulong)cpi + cpi->parameter_name_offset);\r\ncfg_mac = (wchar_t *)((ulong)cpi + cpi->parameter_value_offset);\r\nret = utf8s_to_utf16s(NWADR_STR, NWADR_STRLEN, UTF16_HOST_ENDIAN,\r\ncfg_nwadr, NWADR_STRLEN);\r\nif (ret < 0)\r\ngoto cleanup;\r\nsnprintf(macstr, 2*ETH_ALEN+1, "%pm", mac);\r\nret = utf8s_to_utf16s(macstr, 2*ETH_ALEN, UTF16_HOST_ENDIAN,\r\ncfg_mac, 2*ETH_ALEN);\r\nif (ret < 0)\r\ngoto cleanup;\r\nret = rndis_filter_send_request(rdev, request);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nnetdev_err(ndev, "timeout before we got a set response...\n");\r\nreturn -EBUSY;\r\n} else {\r\nset_complete = &request->response_msg.msg.set_complete;\r\nif (set_complete->status != RNDIS_STATUS_SUCCESS) {\r\nnetdev_err(ndev, "Fail to set MAC on host side:0x%x\n",\r\nset_complete->status);\r\nret = -EINVAL;\r\n}\r\n}\r\ncleanup:\r\nput_rndis_request(rdev, request);\r\nreturn ret;\r\n}\r\nint rndis_filter_set_offload_params(struct hv_device *hdev,\r\nstruct ndis_offload_params *req_offloads)\r\n{\r\nstruct netvsc_device *nvdev = hv_get_drvdata(hdev);\r\nstruct rndis_device *rdev = nvdev->extension;\r\nstruct net_device *ndev = nvdev->ndev;\r\nstruct rndis_request *request;\r\nstruct rndis_set_request *set;\r\nstruct ndis_offload_params *offload_params;\r\nstruct rndis_set_complete *set_complete;\r\nu32 extlen = sizeof(struct ndis_offload_params);\r\nint ret, t;\r\nu32 vsp_version = nvdev->nvsp_version;\r\nif (vsp_version <= NVSP_PROTOCOL_VERSION_4) {\r\nextlen = VERSION_4_OFFLOAD_SIZE;\r\nreq_offloads->udp_ip_v4_csum = 0;\r\nreq_offloads->udp_ip_v6_csum = 0;\r\n}\r\nrequest = get_rndis_request(rdev, RNDIS_MSG_SET,\r\nRNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);\r\nif (!request)\r\nreturn -ENOMEM;\r\nset = &request->request_msg.msg.set_req;\r\nset->oid = OID_TCP_OFFLOAD_PARAMETERS;\r\nset->info_buflen = extlen;\r\nset->info_buf_offset = sizeof(struct rndis_set_request);\r\nset->dev_vc_handle = 0;\r\noffload_params = (struct ndis_offload_params *)((ulong)set +\r\nset->info_buf_offset);\r\n*offload_params = *req_offloads;\r\noffload_params->header.type = NDIS_OBJECT_TYPE_DEFAULT;\r\noffload_params->header.revision = NDIS_OFFLOAD_PARAMETERS_REVISION_3;\r\noffload_params->header.size = extlen;\r\nret = rndis_filter_send_request(rdev, request);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nnetdev_err(ndev, "timeout before we got aOFFLOAD set response...\n");\r\nreturn -EBUSY;\r\n} else {\r\nset_complete = &request->response_msg.msg.set_complete;\r\nif (set_complete->status != RNDIS_STATUS_SUCCESS) {\r\nnetdev_err(ndev, "Fail to set offload on host side:0x%x\n",\r\nset_complete->status);\r\nret = -EINVAL;\r\n}\r\n}\r\ncleanup:\r\nput_rndis_request(rdev, request);\r\nreturn ret;\r\n}\r\nint rndis_filter_set_rss_param(struct rndis_device *rdev, int num_queue)\r\n{\r\nstruct net_device *ndev = rdev->net_dev->ndev;\r\nstruct rndis_request *request;\r\nstruct rndis_set_request *set;\r\nstruct rndis_set_complete *set_complete;\r\nu32 extlen = sizeof(struct ndis_recv_scale_param) +\r\n4*ITAB_NUM + HASH_KEYLEN;\r\nstruct ndis_recv_scale_param *rssp;\r\nu32 *itab;\r\nu8 *keyp;\r\nint i, t, ret;\r\nrequest = get_rndis_request(\r\nrdev, RNDIS_MSG_SET,\r\nRNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);\r\nif (!request)\r\nreturn -ENOMEM;\r\nset = &request->request_msg.msg.set_req;\r\nset->oid = OID_GEN_RECEIVE_SCALE_PARAMETERS;\r\nset->info_buflen = extlen;\r\nset->info_buf_offset = sizeof(struct rndis_set_request);\r\nset->dev_vc_handle = 0;\r\nrssp = (struct ndis_recv_scale_param *)(set + 1);\r\nrssp->hdr.type = NDIS_OBJECT_TYPE_RSS_PARAMETERS;\r\nrssp->hdr.rev = NDIS_RECEIVE_SCALE_PARAMETERS_REVISION_2;\r\nrssp->hdr.size = sizeof(struct ndis_recv_scale_param);\r\nrssp->flag = 0;\r\nrssp->hashinfo = NDIS_HASH_FUNC_TOEPLITZ | NDIS_HASH_IPV4 |\r\nNDIS_HASH_TCP_IPV4;\r\nrssp->indirect_tabsize = 4*ITAB_NUM;\r\nrssp->indirect_taboffset = sizeof(struct ndis_recv_scale_param);\r\nrssp->hashkey_size = HASH_KEYLEN;\r\nrssp->kashkey_offset = rssp->indirect_taboffset +\r\nrssp->indirect_tabsize;\r\nitab = (u32 *)(rssp + 1);\r\nfor (i = 0; i < ITAB_NUM; i++)\r\nitab[i] = i % num_queue;\r\nkeyp = (u8 *)((unsigned long)rssp + rssp->kashkey_offset);\r\nfor (i = 0; i < HASH_KEYLEN; i++)\r\nkeyp[i] = netvsc_hash_key[i];\r\nret = rndis_filter_send_request(rdev, request);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nnetdev_err(ndev, "timeout before we got a set response...\n");\r\nreturn -ETIMEDOUT;\r\n} else {\r\nset_complete = &request->response_msg.msg.set_complete;\r\nif (set_complete->status != RNDIS_STATUS_SUCCESS) {\r\nnetdev_err(ndev, "Fail to set RSS parameters:0x%x\n",\r\nset_complete->status);\r\nret = -EINVAL;\r\n}\r\n}\r\ncleanup:\r\nput_rndis_request(rdev, request);\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_query_device_link_status(struct rndis_device *dev)\r\n{\r\nu32 size = sizeof(u32);\r\nu32 link_status;\r\nint ret;\r\nret = rndis_filter_query_device(dev,\r\nRNDIS_OID_GEN_MEDIA_CONNECT_STATUS,\r\n&link_status, &size);\r\nreturn ret;\r\n}\r\nint rndis_filter_set_packet_filter(struct rndis_device *dev, u32 new_filter)\r\n{\r\nstruct rndis_request *request;\r\nstruct rndis_set_request *set;\r\nstruct rndis_set_complete *set_complete;\r\nu32 status;\r\nint ret, t;\r\nstruct net_device *ndev;\r\nndev = dev->net_dev->ndev;\r\nrequest = get_rndis_request(dev, RNDIS_MSG_SET,\r\nRNDIS_MESSAGE_SIZE(struct rndis_set_request) +\r\nsizeof(u32));\r\nif (!request) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nset = &request->request_msg.msg.set_req;\r\nset->oid = RNDIS_OID_GEN_CURRENT_PACKET_FILTER;\r\nset->info_buflen = sizeof(u32);\r\nset->info_buf_offset = sizeof(struct rndis_set_request);\r\nmemcpy((void *)(unsigned long)set + sizeof(struct rndis_set_request),\r\n&new_filter, sizeof(u32));\r\nret = rndis_filter_send_request(dev, request);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nnetdev_err(ndev,\r\n"timeout before we got a set response...\n");\r\nret = -ETIMEDOUT;\r\ngoto exit;\r\n} else {\r\nset_complete = &request->response_msg.msg.set_complete;\r\nstatus = set_complete->status;\r\n}\r\ncleanup:\r\nif (request)\r\nput_rndis_request(dev, request);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_init_device(struct rndis_device *dev)\r\n{\r\nstruct rndis_request *request;\r\nstruct rndis_initialize_request *init;\r\nstruct rndis_initialize_complete *init_complete;\r\nu32 status;\r\nint ret, t;\r\nrequest = get_rndis_request(dev, RNDIS_MSG_INIT,\r\nRNDIS_MESSAGE_SIZE(struct rndis_initialize_request));\r\nif (!request) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\ninit = &request->request_msg.msg.init_req;\r\ninit->major_ver = RNDIS_MAJOR_VERSION;\r\ninit->minor_ver = RNDIS_MINOR_VERSION;\r\ninit->max_xfer_size = 0x4000;\r\ndev->state = RNDIS_DEV_INITIALIZING;\r\nret = rndis_filter_send_request(dev, request);\r\nif (ret != 0) {\r\ndev->state = RNDIS_DEV_UNINITIALIZED;\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\ninit_complete = &request->response_msg.msg.init_complete;\r\nstatus = init_complete->status;\r\nif (status == RNDIS_STATUS_SUCCESS) {\r\ndev->state = RNDIS_DEV_INITIALIZED;\r\nret = 0;\r\n} else {\r\ndev->state = RNDIS_DEV_UNINITIALIZED;\r\nret = -EINVAL;\r\n}\r\ncleanup:\r\nif (request)\r\nput_rndis_request(dev, request);\r\nreturn ret;\r\n}\r\nstatic void rndis_filter_halt_device(struct rndis_device *dev)\r\n{\r\nstruct rndis_request *request;\r\nstruct rndis_halt_request *halt;\r\nstruct netvsc_device *nvdev = dev->net_dev;\r\nstruct hv_device *hdev = nvdev->dev;\r\nulong flags;\r\nrequest = get_rndis_request(dev, RNDIS_MSG_HALT,\r\nRNDIS_MESSAGE_SIZE(struct rndis_halt_request));\r\nif (!request)\r\ngoto cleanup;\r\nhalt = &request->request_msg.msg.halt_req;\r\nhalt->req_id = atomic_inc_return(&dev->new_req_id);\r\nrndis_filter_send_request(dev, request);\r\ndev->state = RNDIS_DEV_UNINITIALIZED;\r\ncleanup:\r\nspin_lock_irqsave(&hdev->channel->inbound_lock, flags);\r\nnvdev->destroy = true;\r\nspin_unlock_irqrestore(&hdev->channel->inbound_lock, flags);\r\nwait_event(nvdev->wait_drain,\r\natomic_read(&nvdev->num_outstanding_sends) == 0);\r\nif (request)\r\nput_rndis_request(dev, request);\r\nreturn;\r\n}\r\nstatic int rndis_filter_open_device(struct rndis_device *dev)\r\n{\r\nint ret;\r\nif (dev->state != RNDIS_DEV_INITIALIZED)\r\nreturn 0;\r\nret = rndis_filter_set_packet_filter(dev,\r\nNDIS_PACKET_TYPE_BROADCAST |\r\nNDIS_PACKET_TYPE_ALL_MULTICAST |\r\nNDIS_PACKET_TYPE_DIRECTED);\r\nif (ret == 0)\r\ndev->state = RNDIS_DEV_DATAINITIALIZED;\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_close_device(struct rndis_device *dev)\r\n{\r\nint ret;\r\nif (dev->state != RNDIS_DEV_DATAINITIALIZED)\r\nreturn 0;\r\nret = rndis_filter_set_packet_filter(dev, 0);\r\nif (ret == 0)\r\ndev->state = RNDIS_DEV_INITIALIZED;\r\nreturn ret;\r\n}\r\nstatic void netvsc_sc_open(struct vmbus_channel *new_sc)\r\n{\r\nstruct netvsc_device *nvscdev;\r\nu16 chn_index = new_sc->offermsg.offer.sub_channel_index;\r\nint ret;\r\nnvscdev = hv_get_drvdata(new_sc->primary_channel->device_obj);\r\nif (chn_index >= nvscdev->num_chn)\r\nreturn;\r\nset_per_channel_state(new_sc, nvscdev->sub_cb_buf + (chn_index - 1) *\r\nNETVSC_PACKET_SIZE);\r\nret = vmbus_open(new_sc, nvscdev->ring_size * PAGE_SIZE,\r\nnvscdev->ring_size * PAGE_SIZE, NULL, 0,\r\nnetvsc_channel_cb, new_sc);\r\nif (ret == 0)\r\nnvscdev->chn_table[chn_index] = new_sc;\r\n}\r\nint rndis_filter_device_add(struct hv_device *dev,\r\nvoid *additional_info)\r\n{\r\nint ret;\r\nstruct netvsc_device *net_device;\r\nstruct rndis_device *rndis_device;\r\nstruct netvsc_device_info *device_info = additional_info;\r\nstruct ndis_offload_params offloads;\r\nstruct nvsp_message *init_packet;\r\nint t;\r\nstruct ndis_recv_scale_cap rsscap;\r\nu32 rsscap_size = sizeof(struct ndis_recv_scale_cap);\r\nrndis_device = get_rndis_device();\r\nif (!rndis_device)\r\nreturn -ENODEV;\r\nret = netvsc_device_add(dev, additional_info);\r\nif (ret != 0) {\r\nkfree(rndis_device);\r\nreturn ret;\r\n}\r\nnet_device = hv_get_drvdata(dev);\r\nnet_device->num_chn = 1;\r\nnet_device->extension = rndis_device;\r\nrndis_device->net_dev = net_device;\r\nret = rndis_filter_init_device(rndis_device);\r\nif (ret != 0) {\r\nrndis_filter_device_remove(dev);\r\nreturn ret;\r\n}\r\nret = rndis_filter_query_device_mac(rndis_device);\r\nif (ret != 0) {\r\nrndis_filter_device_remove(dev);\r\nreturn ret;\r\n}\r\nmemcpy(device_info->mac_adr, rndis_device->hw_mac_adr, ETH_ALEN);\r\nmemset(&offloads, 0, sizeof(struct ndis_offload_params));\r\noffloads.ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\r\noffloads.tcp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\r\noffloads.udp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\r\noffloads.tcp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\r\noffloads.udp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\r\noffloads.lso_v2_ipv4 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;\r\nret = rndis_filter_set_offload_params(dev, &offloads);\r\nif (ret)\r\ngoto err_dev_remv;\r\nrndis_filter_query_device_link_status(rndis_device);\r\ndevice_info->link_state = rndis_device->link_state;\r\ndev_info(&dev->device, "Device MAC %pM link state %s\n",\r\nrndis_device->hw_mac_adr,\r\ndevice_info->link_state ? "down" : "up");\r\nif (net_device->nvsp_version < NVSP_PROTOCOL_VERSION_5)\r\nreturn 0;\r\nmemset(&rsscap, 0, rsscap_size);\r\nret = rndis_filter_query_device(rndis_device,\r\nOID_GEN_RECEIVE_SCALE_CAPABILITIES,\r\n&rsscap, &rsscap_size);\r\nif (ret || rsscap.num_recv_que < 2)\r\ngoto out;\r\nnet_device->num_chn = (num_online_cpus() < rsscap.num_recv_que) ?\r\nnum_online_cpus() : rsscap.num_recv_que;\r\nif (net_device->num_chn == 1)\r\ngoto out;\r\nnet_device->sub_cb_buf = vzalloc((net_device->num_chn - 1) *\r\nNETVSC_PACKET_SIZE);\r\nif (!net_device->sub_cb_buf) {\r\nnet_device->num_chn = 1;\r\ndev_info(&dev->device, "No memory for subchannels.\n");\r\ngoto out;\r\n}\r\nvmbus_set_sc_create_callback(dev->channel, netvsc_sc_open);\r\ninit_packet = &net_device->channel_init_pkt;\r\nmemset(init_packet, 0, sizeof(struct nvsp_message));\r\ninit_packet->hdr.msg_type = NVSP_MSG5_TYPE_SUBCHANNEL;\r\ninit_packet->msg.v5_msg.subchn_req.op = NVSP_SUBCHANNEL_ALLOCATE;\r\ninit_packet->msg.v5_msg.subchn_req.num_subchannels =\r\nnet_device->num_chn - 1;\r\nret = vmbus_sendpacket(dev->channel, init_packet,\r\nsizeof(struct nvsp_message),\r\n(unsigned long)init_packet,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret)\r\ngoto out;\r\nt = wait_for_completion_timeout(&net_device->channel_init_wait, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nif (init_packet->msg.v5_msg.subchn_comp.status !=\r\nNVSP_STAT_SUCCESS) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnet_device->num_chn = 1 +\r\ninit_packet->msg.v5_msg.subchn_comp.num_subchannels;\r\nvmbus_are_subchannels_present(dev->channel);\r\nret = rndis_filter_set_rss_param(rndis_device, net_device->num_chn);\r\nout:\r\nif (ret)\r\nnet_device->num_chn = 1;\r\nreturn 0;\r\nerr_dev_remv:\r\nrndis_filter_device_remove(dev);\r\nreturn ret;\r\n}\r\nvoid rndis_filter_device_remove(struct hv_device *dev)\r\n{\r\nstruct netvsc_device *net_dev = hv_get_drvdata(dev);\r\nstruct rndis_device *rndis_dev = net_dev->extension;\r\nrndis_filter_halt_device(rndis_dev);\r\nkfree(rndis_dev);\r\nnet_dev->extension = NULL;\r\nnetvsc_device_remove(dev);\r\n}\r\nint rndis_filter_open(struct hv_device *dev)\r\n{\r\nstruct netvsc_device *net_device = hv_get_drvdata(dev);\r\nif (!net_device)\r\nreturn -EINVAL;\r\nreturn rndis_filter_open_device(net_device->extension);\r\n}\r\nint rndis_filter_close(struct hv_device *dev)\r\n{\r\nstruct netvsc_device *nvdev = hv_get_drvdata(dev);\r\nif (!nvdev)\r\nreturn -EINVAL;\r\nreturn rndis_filter_close_device(nvdev->extension);\r\n}
