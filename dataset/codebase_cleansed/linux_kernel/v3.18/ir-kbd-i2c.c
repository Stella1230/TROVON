static int get_key_haup_common(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *ptoggle, int size, int offset)\r\n{\r\nunsigned char buf[6];\r\nint start, range, toggle, dev, code, ircode;\r\nif (size != i2c_master_recv(ir->c, buf, size))\r\nreturn -EIO;\r\nstart = (buf[offset] >> 7) & 1;\r\nrange = (buf[offset] >> 6) & 1;\r\ntoggle = (buf[offset] >> 5) & 1;\r\ndev = buf[offset] & 0x1f;\r\ncode = (buf[offset+1] >> 2) & 0x3f;\r\nif (!start)\r\nreturn 0;\r\nircode = (start << 12) | (toggle << 11) | (dev << 6) | code;\r\nif ((ircode & 0x1fff) == 0x1fff)\r\nreturn 0;\r\nif (!range)\r\ncode += 64;\r\ndprintk(1,"ir hauppauge (rc5): s%d r%d t%d dev=%d code=%d\n",\r\nstart, range, toggle, dev, code);\r\n*protocol = RC_TYPE_RC5;\r\n*scancode = RC_SCANCODE_RC5(dev, code);\r\n*ptoggle = toggle;\r\nreturn 1;\r\n}\r\nstatic int get_key_haup(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nreturn get_key_haup_common (ir, protocol, scancode, toggle, 3, 0);\r\n}\r\nstatic int get_key_haup_xvr(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nint ret;\r\nunsigned char buf[1] = { 0 };\r\nret = i2c_master_send(ir->c, buf, 1);\r\nif (ret != 1)\r\nreturn (ret < 0) ? ret : -EINVAL;\r\nreturn get_key_haup_common(ir, protocol, scancode, toggle, 6, 3);\r\n}\r\nstatic int get_key_pixelview(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char b;\r\nif (1 != i2c_master_recv(ir->c, &b, 1)) {\r\ndprintk(1,"read error\n");\r\nreturn -EIO;\r\n}\r\n*protocol = RC_TYPE_OTHER;\r\n*scancode = b;\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int get_key_fusionhdtv(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char buf[4];\r\nif (4 != i2c_master_recv(ir->c, buf, 4)) {\r\ndprintk(1,"read error\n");\r\nreturn -EIO;\r\n}\r\nif(buf[0] !=0 || buf[1] !=0 || buf[2] !=0 || buf[3] != 0)\r\ndprintk(2, "%s: 0x%2x 0x%2x 0x%2x 0x%2x\n", __func__,\r\nbuf[0], buf[1], buf[2], buf[3]);\r\nif(buf[0] != 0x1 || buf[1] != 0xfe)\r\nreturn 0;\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = buf[2];\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int get_key_knc1(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char b;\r\nif (1 != i2c_master_recv(ir->c, &b, 1)) {\r\ndprintk(1,"read error\n");\r\nreturn -EIO;\r\n}\r\ndprintk(2,"key %02x\n", b);\r\nif (b == 0xff)\r\nreturn 0;\r\nif (b == 0xfe)\r\nreturn 1;\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = b;\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int get_key_avermedia_cardbus(struct IR_i2c *ir, enum rc_type *protocol,\r\nu32 *scancode, u8 *toggle)\r\n{\r\nunsigned char subaddr, key, keygroup;\r\nstruct i2c_msg msg[] = { { .addr = ir->c->addr, .flags = 0,\r\n.buf = &subaddr, .len = 1},\r\n{ .addr = ir->c->addr, .flags = I2C_M_RD,\r\n.buf = &key, .len = 1} };\r\nsubaddr = 0x0d;\r\nif (2 != i2c_transfer(ir->c->adapter, msg, 2)) {\r\ndprintk(1, "read error\n");\r\nreturn -EIO;\r\n}\r\nif (key == 0xff)\r\nreturn 0;\r\nsubaddr = 0x0b;\r\nmsg[1].buf = &keygroup;\r\nif (2 != i2c_transfer(ir->c->adapter, msg, 2)) {\r\ndprintk(1, "read error\n");\r\nreturn -EIO;\r\n}\r\nif (keygroup == 0xff)\r\nreturn 0;\r\ndprintk(1, "read key 0x%02x/0x%02x\n", key, keygroup);\r\nif (keygroup < 2 || keygroup > 4) {\r\ndprintk(1, "warning: invalid key group 0x%02x for key 0x%02x\n",\r\nkeygroup, key);\r\n}\r\nkey |= (keygroup & 1) << 6;\r\n*protocol = RC_TYPE_UNKNOWN;\r\n*scancode = key;\r\nif (ir->c->addr == 0x41)\r\n*scancode |= keygroup << 8;\r\n*toggle = 0;\r\nreturn 1;\r\n}\r\nstatic int ir_key_poll(struct IR_i2c *ir)\r\n{\r\nenum rc_type protocol;\r\nu32 scancode;\r\nu8 toggle;\r\nint rc;\r\ndprintk(3, "%s\n", __func__);\r\nrc = ir->get_key(ir, &protocol, &scancode, &toggle);\r\nif (rc < 0) {\r\ndprintk(2,"error\n");\r\nreturn rc;\r\n}\r\nif (rc) {\r\ndprintk(1, "%s: proto = 0x%04x, scancode = 0x%08x\n",\r\n__func__, protocol, scancode);\r\nrc_keydown(ir->rc, protocol, scancode, toggle);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ir_work(struct work_struct *work)\r\n{\r\nint rc;\r\nstruct IR_i2c *ir = container_of(work, struct IR_i2c, work.work);\r\nrc = ir_key_poll(ir);\r\nif (rc == -ENODEV) {\r\nrc_unregister_device(ir->rc);\r\nir->rc = NULL;\r\nreturn;\r\n}\r\nschedule_delayed_work(&ir->work, msecs_to_jiffies(ir->polling_interval));\r\n}\r\nstatic int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nchar *ir_codes = NULL;\r\nconst char *name = NULL;\r\nu64 rc_type = RC_BIT_UNKNOWN;\r\nstruct IR_i2c *ir;\r\nstruct rc_dev *rc = NULL;\r\nstruct i2c_adapter *adap = client->adapter;\r\nunsigned short addr = client->addr;\r\nint err;\r\nir = devm_kzalloc(&client->dev, sizeof(*ir), GFP_KERNEL);\r\nif (!ir)\r\nreturn -ENOMEM;\r\nir->c = client;\r\nir->polling_interval = DEFAULT_POLLING_INTERVAL;\r\ni2c_set_clientdata(client, ir);\r\nswitch(addr) {\r\ncase 0x64:\r\nname = "Pixelview";\r\nir->get_key = get_key_pixelview;\r\nrc_type = RC_BIT_OTHER;\r\nir_codes = RC_MAP_EMPTY;\r\nbreak;\r\ncase 0x18:\r\ncase 0x1f:\r\ncase 0x1a:\r\nname = "Hauppauge";\r\nir->get_key = get_key_haup;\r\nrc_type = RC_BIT_RC5;\r\nir_codes = RC_MAP_HAUPPAUGE;\r\nbreak;\r\ncase 0x30:\r\nname = "KNC One";\r\nir->get_key = get_key_knc1;\r\nrc_type = RC_BIT_OTHER;\r\nir_codes = RC_MAP_EMPTY;\r\nbreak;\r\ncase 0x6b:\r\nname = "FusionHDTV";\r\nir->get_key = get_key_fusionhdtv;\r\nrc_type = RC_BIT_UNKNOWN;\r\nir_codes = RC_MAP_FUSIONHDTV_MCE;\r\nbreak;\r\ncase 0x40:\r\nname = "AVerMedia Cardbus remote";\r\nir->get_key = get_key_avermedia_cardbus;\r\nrc_type = RC_BIT_OTHER;\r\nir_codes = RC_MAP_AVERMEDIA_CARDBUS;\r\nbreak;\r\ncase 0x41:\r\nname = "AVerMedia EM78P153";\r\nir->get_key = get_key_avermedia_cardbus;\r\nrc_type = RC_BIT_OTHER;\r\nir_codes = RC_MAP_AVERMEDIA_M733A_RM_K6;\r\nbreak;\r\ncase 0x71:\r\nname = "Hauppauge/Zilog Z8";\r\nir->get_key = get_key_haup_xvr;\r\nrc_type = RC_BIT_RC5;\r\nir_codes = RC_MAP_HAUPPAUGE;\r\nbreak;\r\n}\r\nif (client->dev.platform_data) {\r\nconst struct IR_i2c_init_data *init_data =\r\nclient->dev.platform_data;\r\nir_codes = init_data->ir_codes;\r\nrc = init_data->rc_dev;\r\nname = init_data->name;\r\nif (init_data->type)\r\nrc_type = init_data->type;\r\nif (init_data->polling_interval)\r\nir->polling_interval = init_data->polling_interval;\r\nswitch (init_data->internal_get_key_func) {\r\ncase IR_KBD_GET_KEY_CUSTOM:\r\nir->get_key = init_data->get_key;\r\nbreak;\r\ncase IR_KBD_GET_KEY_PIXELVIEW:\r\nir->get_key = get_key_pixelview;\r\nbreak;\r\ncase IR_KBD_GET_KEY_HAUP:\r\nir->get_key = get_key_haup;\r\nbreak;\r\ncase IR_KBD_GET_KEY_KNC1:\r\nir->get_key = get_key_knc1;\r\nbreak;\r\ncase IR_KBD_GET_KEY_FUSIONHDTV:\r\nir->get_key = get_key_fusionhdtv;\r\nbreak;\r\ncase IR_KBD_GET_KEY_HAUP_XVR:\r\nir->get_key = get_key_haup_xvr;\r\nbreak;\r\ncase IR_KBD_GET_KEY_AVERMEDIA_CARDBUS:\r\nir->get_key = get_key_avermedia_cardbus;\r\nbreak;\r\n}\r\n}\r\nif (!rc) {\r\nrc = rc_allocate_device();\r\nif (!rc)\r\nreturn -ENOMEM;\r\n}\r\nir->rc = rc;\r\nif (!name || !ir->get_key || !rc_type || !ir_codes) {\r\ndprintk(1, ": Unsupported device at address 0x%02x\n",\r\naddr);\r\nerr = -ENODEV;\r\ngoto err_out_free;\r\n}\r\nsnprintf(ir->name, sizeof(ir->name), "i2c IR (%s)", name);\r\nir->ir_codes = ir_codes;\r\nsnprintf(ir->phys, sizeof(ir->phys), "%s/%s/ir0",\r\ndev_name(&adap->dev),\r\ndev_name(&client->dev));\r\nrc->input_id.bustype = BUS_I2C;\r\nrc->input_phys = ir->phys;\r\nrc->input_name = ir->name;\r\nrc->map_name = ir->ir_codes;\r\nrc->allowed_protocols = rc_type;\r\nrc->enabled_protocols = rc_type;\r\nif (!rc->driver_name)\r\nrc->driver_name = MODULE_NAME;\r\nerr = rc_register_device(rc);\r\nif (err)\r\ngoto err_out_free;\r\nprintk(MODULE_NAME ": %s detected at %s [%s]\n",\r\nir->name, ir->phys, adap->name);\r\nINIT_DELAYED_WORK(&ir->work, ir_work);\r\nschedule_delayed_work(&ir->work, 0);\r\nreturn 0;\r\nerr_out_free:\r\nrc_free_device(rc);\r\nreturn err;\r\n}\r\nstatic int ir_remove(struct i2c_client *client)\r\n{\r\nstruct IR_i2c *ir = i2c_get_clientdata(client);\r\ncancel_delayed_work_sync(&ir->work);\r\nif (ir->rc)\r\nrc_unregister_device(ir->rc);\r\nreturn 0;\r\n}
