static void isl12057_rtc_regs_to_tm(struct rtc_time *tm, u8 *regs)\r\n{\r\ntm->tm_sec = bcd2bin(regs[ISL12057_REG_RTC_SC]);\r\ntm->tm_min = bcd2bin(regs[ISL12057_REG_RTC_MN]);\r\nif (regs[ISL12057_REG_RTC_HR] & ISL12057_REG_RTC_HR_MIL) {\r\ntm->tm_hour = bcd2bin(regs[ISL12057_REG_RTC_HR] & 0x0f);\r\nif (regs[ISL12057_REG_RTC_HR] & ISL12057_REG_RTC_HR_PM)\r\ntm->tm_hour += 12;\r\n} else {\r\ntm->tm_hour = bcd2bin(regs[ISL12057_REG_RTC_HR] & 0x3f);\r\n}\r\ntm->tm_mday = bcd2bin(regs[ISL12057_REG_RTC_DT]);\r\ntm->tm_wday = bcd2bin(regs[ISL12057_REG_RTC_DW]) - 1;\r\ntm->tm_mon = bcd2bin(regs[ISL12057_REG_RTC_MO]) - 1;\r\ntm->tm_year = bcd2bin(regs[ISL12057_REG_RTC_YR]) + 100;\r\n}\r\nstatic int isl12057_rtc_tm_to_regs(u8 *regs, struct rtc_time *tm)\r\n{\r\nif (tm->tm_year < 100)\r\nreturn -EINVAL;\r\nregs[ISL12057_REG_RTC_SC] = bin2bcd(tm->tm_sec);\r\nregs[ISL12057_REG_RTC_MN] = bin2bcd(tm->tm_min);\r\nregs[ISL12057_REG_RTC_HR] = bin2bcd(tm->tm_hour);\r\nregs[ISL12057_REG_RTC_DT] = bin2bcd(tm->tm_mday);\r\nregs[ISL12057_REG_RTC_MO] = bin2bcd(tm->tm_mon + 1);\r\nregs[ISL12057_REG_RTC_YR] = bin2bcd(tm->tm_year - 100);\r\nregs[ISL12057_REG_RTC_DW] = bin2bcd(tm->tm_wday + 1);\r\nreturn 0;\r\n}\r\nstatic int isl12057_i2c_validate_chip(struct regmap *regmap)\r\n{\r\nu8 regs[ISL12057_MEM_MAP_LEN];\r\nstatic const u8 mask[ISL12057_MEM_MAP_LEN] = { 0x80, 0x80, 0x80, 0xf8,\r\n0xc0, 0x60, 0x00, 0x00,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x00, 0x00, 0x60, 0x7c };\r\nint ret, i;\r\nret = regmap_bulk_read(regmap, 0, regs, ISL12057_MEM_MAP_LEN);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ISL12057_MEM_MAP_LEN; ++i) {\r\nif (regs[i] & mask[i])\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isl12057_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct isl12057_rtc_data *data = dev_get_drvdata(dev);\r\nu8 regs[ISL12057_RTC_SEC_LEN];\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = regmap_bulk_read(data->regmap, ISL12057_REG_RTC_SC, regs,\r\nISL12057_RTC_SEC_LEN);\r\nmutex_unlock(&data->lock);\r\nif (ret) {\r\ndev_err(dev, "%s: RTC read failed\n", __func__);\r\nreturn ret;\r\n}\r\nisl12057_rtc_regs_to_tm(tm, regs);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int isl12057_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct isl12057_rtc_data *data = dev_get_drvdata(dev);\r\nu8 regs[ISL12057_RTC_SEC_LEN];\r\nint ret;\r\nret = isl12057_rtc_tm_to_regs(regs, tm);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&data->lock);\r\nret = regmap_bulk_write(data->regmap, ISL12057_REG_RTC_SC, regs,\r\nISL12057_RTC_SEC_LEN);\r\nmutex_unlock(&data->lock);\r\nif (ret)\r\ndev_err(dev, "%s: RTC write failed\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int isl12057_check_rtc_status(struct device *dev, struct regmap *regmap)\r\n{\r\nint ret;\r\nret = regmap_update_bits(regmap, ISL12057_REG_INT,\r\nISL12057_REG_INT_EOSC, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "Unable to enable oscillator\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(regmap, ISL12057_REG_SR,\r\nISL12057_REG_SR_OSF, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "Unable to clear oscillator failure bit\n");\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(regmap, ISL12057_REG_SR,\r\nISL12057_REG_SR_A1F, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "Unable to clear alarm bit\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isl12057_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct isl12057_rtc_data *data;\r\nstruct rtc_device *rtc;\r\nstruct regmap *regmap;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -ENODEV;\r\nregmap = devm_regmap_init_i2c(client, &isl12057_rtc_regmap_config);\r\nif (IS_ERR(regmap)) {\r\nret = PTR_ERR(regmap);\r\ndev_err(dev, "regmap allocation failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = isl12057_i2c_validate_chip(regmap);\r\nif (ret)\r\nreturn ret;\r\nret = isl12057_check_rtc_status(dev, regmap);\r\nif (ret)\r\nreturn ret;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmutex_init(&data->lock);\r\ndata->regmap = regmap;\r\ndev_set_drvdata(dev, data);\r\nrtc = devm_rtc_device_register(dev, DRV_NAME, &rtc_ops, THIS_MODULE);\r\nreturn PTR_ERR_OR_ZERO(rtc);\r\n}
