static u16 hpi_stream_host_buffer_attach(\r\nu32 h_stream,\r\nu32 size_in_bytes,\r\nu32 pci_address\r\n)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nunsigned int obj = hpi_handle_object(h_stream);\r\nif (!h_stream)\r\nreturn HPI_ERROR_INVALID_OBJ;\r\nhpi_init_message_response(&hm, &hr, obj,\r\nobj == HPI_OBJ_OSTREAM ?\r\nHPI_OSTREAM_HOSTBUFFER_ALLOC :\r\nHPI_ISTREAM_HOSTBUFFER_ALLOC);\r\nhpi_handle_to_indexes(h_stream, &hm.adapter_index,\r\n&hm.obj_index);\r\nhm.u.d.u.buffer.buffer_size = size_in_bytes;\r\nhm.u.d.u.buffer.pci_address = pci_address;\r\nhm.u.d.u.buffer.command = HPI_BUFFER_CMD_INTERNAL_GRANTADAPTER;\r\nhpi_send_recv(&hm, &hr);\r\nreturn hr.error;\r\n}\r\nstatic u16 hpi_stream_host_buffer_detach(u32 h_stream)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nunsigned int obj = hpi_handle_object(h_stream);\r\nif (!h_stream)\r\nreturn HPI_ERROR_INVALID_OBJ;\r\nhpi_init_message_response(&hm, &hr, obj,\r\nobj == HPI_OBJ_OSTREAM ?\r\nHPI_OSTREAM_HOSTBUFFER_FREE :\r\nHPI_ISTREAM_HOSTBUFFER_FREE);\r\nhpi_handle_to_indexes(h_stream, &hm.adapter_index,\r\n&hm.obj_index);\r\nhm.u.d.u.buffer.command = HPI_BUFFER_CMD_INTERNAL_REVOKEADAPTER;\r\nhpi_send_recv(&hm, &hr);\r\nreturn hr.error;\r\n}\r\nstatic inline u16 hpi_stream_start(u32 h_stream)\r\n{\r\nif (hpi_handle_object(h_stream) == HPI_OBJ_OSTREAM)\r\nreturn hpi_outstream_start(h_stream);\r\nelse\r\nreturn hpi_instream_start(h_stream);\r\n}\r\nstatic inline u16 hpi_stream_stop(u32 h_stream)\r\n{\r\nif (hpi_handle_object(h_stream) == HPI_OBJ_OSTREAM)\r\nreturn hpi_outstream_stop(h_stream);\r\nelse\r\nreturn hpi_instream_stop(h_stream);\r\n}\r\nstatic inline u16 hpi_stream_get_info_ex(\r\nu32 h_stream,\r\nu16 *pw_state,\r\nu32 *pbuffer_size,\r\nu32 *pdata_in_buffer,\r\nu32 *psample_count,\r\nu32 *pauxiliary_data\r\n)\r\n{\r\nu16 e;\r\nif (hpi_handle_object(h_stream) == HPI_OBJ_OSTREAM)\r\ne = hpi_outstream_get_info_ex(h_stream, pw_state,\r\npbuffer_size, pdata_in_buffer,\r\npsample_count, pauxiliary_data);\r\nelse\r\ne = hpi_instream_get_info_ex(h_stream, pw_state,\r\npbuffer_size, pdata_in_buffer,\r\npsample_count, pauxiliary_data);\r\nreturn e;\r\n}\r\nstatic inline u16 hpi_stream_group_add(\r\nu32 h_master,\r\nu32 h_stream)\r\n{\r\nif (hpi_handle_object(h_master) == HPI_OBJ_OSTREAM)\r\nreturn hpi_outstream_group_add(h_master, h_stream);\r\nelse\r\nreturn hpi_instream_group_add(h_master, h_stream);\r\n}\r\nstatic inline u16 hpi_stream_group_reset(u32 h_stream)\r\n{\r\nif (hpi_handle_object(h_stream) == HPI_OBJ_OSTREAM)\r\nreturn hpi_outstream_group_reset(h_stream);\r\nelse\r\nreturn hpi_instream_group_reset(h_stream);\r\n}\r\nstatic inline u16 hpi_stream_group_get_map(\r\nu32 h_stream, u32 *mo, u32 *mi)\r\n{\r\nif (hpi_handle_object(h_stream) == HPI_OBJ_OSTREAM)\r\nreturn hpi_outstream_group_get_map(h_stream, mo, mi);\r\nelse\r\nreturn hpi_instream_group_get_map(h_stream, mo, mi);\r\n}\r\nstatic u16 handle_error(u16 err, int line, char *filename)\r\n{\r\nif (err)\r\nprintk(KERN_WARNING\r\n"in file %s, line %d: HPI error %d\n",\r\nfilename, line, err);\r\nreturn err;\r\n}\r\nstatic void print_hwparams(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *p)\r\n{\r\nchar name[16];\r\nsnd_pcm_debug_name(substream, name, sizeof(name));\r\nsnd_printd("%s HWPARAMS\n", name);\r\nsnd_printd(" samplerate %d Hz\n", params_rate(p));\r\nsnd_printd(" channels %d\n", params_channels(p));\r\nsnd_printd(" format %d\n", params_format(p));\r\nsnd_printd(" subformat %d\n", params_subformat(p));\r\nsnd_printd(" buffer %d B\n", params_buffer_bytes(p));\r\nsnd_printd(" period %d B\n", params_period_bytes(p));\r\nsnd_printd(" access %d\n", params_access(p));\r\nsnd_printd(" period_size %d\n", params_period_size(p));\r\nsnd_printd(" periods %d\n", params_periods(p));\r\nsnd_printd(" buffer_size %d\n", params_buffer_size(p));\r\nsnd_printd(" %d B/s\n", params_rate(p) *\r\nparams_channels(p) *\r\nsnd_pcm_format_width(params_format(p)) / 8);\r\n}\r\nstatic int snd_card_asihpi_format_alsa2hpi(snd_pcm_format_t alsa_format,\r\nu16 *hpi_format)\r\n{\r\nu16 format;\r\nfor (format = HPI_FORMAT_PCM8_UNSIGNED;\r\nformat <= HPI_FORMAT_PCM24_SIGNED; format++) {\r\nif (hpi_to_alsa_formats[format] == alsa_format) {\r\n*hpi_format = format;\r\nreturn 0;\r\n}\r\n}\r\nsnd_printd(KERN_WARNING "failed match for alsa format %d\n",\r\nalsa_format);\r\n*hpi_format = 0;\r\nreturn -EINVAL;\r\n}\r\nstatic void snd_card_asihpi_pcm_samplerates(struct snd_card_asihpi *asihpi,\r\nstruct snd_pcm_hardware *pcmhw)\r\n{\r\nu16 err;\r\nu32 h_control;\r\nu32 sample_rate;\r\nint idx;\r\nunsigned int rate_min = 200000;\r\nunsigned int rate_max = 0;\r\nunsigned int rates = 0;\r\nif (asihpi->support_mrx) {\r\nrates |= SNDRV_PCM_RATE_CONTINUOUS;\r\nrates |= SNDRV_PCM_RATE_8000_96000;\r\nrate_min = 8000;\r\nrate_max = 100000;\r\n} else {\r\nerr = hpi_mixer_get_control(asihpi->h_mixer,\r\nHPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\r\nHPI_CONTROL_SAMPLECLOCK, &h_control);\r\nif (err) {\r\nsnd_printk(KERN_ERR\r\n"No local sampleclock, err %d\n", err);\r\n}\r\nfor (idx = -1; idx < 100; idx++) {\r\nif (idx == -1) {\r\nif (hpi_sample_clock_get_sample_rate(h_control,\r\n&sample_rate))\r\ncontinue;\r\n} else if (hpi_sample_clock_query_local_rate(h_control,\r\nidx, &sample_rate)) {\r\nbreak;\r\n}\r\nrate_min = min(rate_min, sample_rate);\r\nrate_max = max(rate_max, sample_rate);\r\nswitch (sample_rate) {\r\ncase 5512:\r\nrates |= SNDRV_PCM_RATE_5512;\r\nbreak;\r\ncase 8000:\r\nrates |= SNDRV_PCM_RATE_8000;\r\nbreak;\r\ncase 11025:\r\nrates |= SNDRV_PCM_RATE_11025;\r\nbreak;\r\ncase 16000:\r\nrates |= SNDRV_PCM_RATE_16000;\r\nbreak;\r\ncase 22050:\r\nrates |= SNDRV_PCM_RATE_22050;\r\nbreak;\r\ncase 32000:\r\nrates |= SNDRV_PCM_RATE_32000;\r\nbreak;\r\ncase 44100:\r\nrates |= SNDRV_PCM_RATE_44100;\r\nbreak;\r\ncase 48000:\r\nrates |= SNDRV_PCM_RATE_48000;\r\nbreak;\r\ncase 64000:\r\nrates |= SNDRV_PCM_RATE_64000;\r\nbreak;\r\ncase 88200:\r\nrates |= SNDRV_PCM_RATE_88200;\r\nbreak;\r\ncase 96000:\r\nrates |= SNDRV_PCM_RATE_96000;\r\nbreak;\r\ncase 176400:\r\nrates |= SNDRV_PCM_RATE_176400;\r\nbreak;\r\ncase 192000:\r\nrates |= SNDRV_PCM_RATE_192000;\r\nbreak;\r\ndefault:\r\nrates |= SNDRV_PCM_RATE_KNOT;\r\n}\r\n}\r\n}\r\npcmhw->rates = rates;\r\npcmhw->rate_min = rate_min;\r\npcmhw->rate_max = rate_max;\r\n}\r\nstatic int snd_card_asihpi_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\r\nint err;\r\nu16 format;\r\nint width;\r\nunsigned int bytes_per_sec;\r\nprint_hwparams(substream, params);\r\nerr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_card_asihpi_format_alsa2hpi(params_format(params), &format);\r\nif (err)\r\nreturn err;\r\nhpi_handle_error(hpi_format_create(&dpcm->format,\r\nparams_channels(params),\r\nformat, params_rate(params), 0, 0));\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nif (hpi_instream_reset(dpcm->h_stream) != 0)\r\nreturn -EINVAL;\r\nif (hpi_instream_set_format(\r\ndpcm->h_stream, &dpcm->format) != 0)\r\nreturn -EINVAL;\r\n}\r\ndpcm->hpi_buffer_attached = 0;\r\nif (card->can_dma) {\r\nerr = hpi_stream_host_buffer_attach(dpcm->h_stream,\r\nparams_buffer_bytes(params), runtime->dma_addr);\r\nif (err == 0) {\r\nsnd_printdd(\r\n"stream_host_buffer_attach succeeded %u %lu\n",\r\nparams_buffer_bytes(params),\r\n(unsigned long)runtime->dma_addr);\r\n} else {\r\nsnd_printd("stream_host_buffer_attach error %d\n",\r\nerr);\r\nreturn -ENOMEM;\r\n}\r\nerr = hpi_stream_get_info_ex(dpcm->h_stream, NULL,\r\n&dpcm->hpi_buffer_attached,\r\nNULL, NULL, NULL);\r\nsnd_printdd("stream_host_buffer_attach status 0x%x\n",\r\ndpcm->hpi_buffer_attached);\r\n}\r\nbytes_per_sec = params_rate(params) * params_channels(params);\r\nwidth = snd_pcm_format_width(params_format(params));\r\nbytes_per_sec *= width;\r\nbytes_per_sec /= 8;\r\nif (width < 0 || bytes_per_sec == 0)\r\nreturn -EINVAL;\r\ndpcm->bytes_per_sec = bytes_per_sec;\r\ndpcm->buffer_bytes = params_buffer_bytes(params);\r\ndpcm->period_bytes = params_period_bytes(params);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_card_asihpi_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nif (dpcm->hpi_buffer_attached)\r\nhpi_stream_host_buffer_detach(dpcm->h_stream);\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic void snd_card_asihpi_runtime_free(struct snd_pcm_runtime *runtime)\r\n{\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nkfree(dpcm);\r\n}\r\nstatic void snd_card_asihpi_pcm_timer_start(struct snd_pcm_substream *\r\nsubstream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nint expiry;\r\nexpiry = HZ / 200;\r\nexpiry = max(expiry, 1);\r\ndpcm->timer.expires = jiffies + expiry;\r\ndpcm->respawn_timer = 1;\r\nadd_timer(&dpcm->timer);\r\n}\r\nstatic void snd_card_asihpi_pcm_timer_stop(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\ndpcm->respawn_timer = 0;\r\ndel_timer(&dpcm->timer);\r\n}\r\nstatic int snd_card_asihpi_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_card_asihpi_pcm *dpcm = substream->runtime->private_data;\r\nstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *s;\r\nu16 e;\r\nchar name[16];\r\nsnd_pcm_debug_name(substream, name, sizeof(name));\r\nsnd_printdd("%s trigger\n", name);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nstruct snd_pcm_runtime *runtime = s->runtime;\r\nstruct snd_card_asihpi_pcm *ds = runtime->private_data;\r\nif (snd_pcm_substream_chip(s) != card)\r\ncontinue;\r\nif (substream->stream != s->stream)\r\ncontinue;\r\nds->drained_count = 0;\r\nif (s->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nunsigned int preload = ds->period_bytes * 1;\r\nsnd_printddd("%d preload x%x\n", s->number, preload);\r\nhpi_handle_error(hpi_outstream_write_buf(\r\nds->h_stream,\r\n&runtime->dma_area[0],\r\npreload,\r\n&ds->format));\r\nds->pcm_buf_host_rw_ofs = preload;\r\n}\r\nif (card->support_grouping) {\r\nsnd_printdd("%d group\n", s->number);\r\ne = hpi_stream_group_add(\r\ndpcm->h_stream,\r\nds->h_stream);\r\nif (!e) {\r\nsnd_pcm_trigger_done(s, substream);\r\n} else {\r\nhpi_handle_error(e);\r\nbreak;\r\n}\r\n} else\r\nbreak;\r\n}\r\nsnd_printdd("start\n");\r\nsnd_card_asihpi_pcm_timer_start(substream);\r\nif ((substream->stream == SNDRV_PCM_STREAM_CAPTURE) ||\r\n!card->can_dma)\r\nhpi_handle_error(hpi_stream_start(dpcm->h_stream));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsnd_card_asihpi_pcm_timer_stop(substream);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (snd_pcm_substream_chip(s) != card)\r\ncontinue;\r\nif (substream->stream != s->stream)\r\ncontinue;\r\ns->runtime->status->state = SNDRV_PCM_STATE_SETUP;\r\nif (card->support_grouping) {\r\nsnd_printdd("%d group\n", s->number);\r\nsnd_pcm_trigger_done(s, substream);\r\n} else\r\nbreak;\r\n}\r\nsnd_printdd("stop\n");\r\nhpi_handle_error(hpi_stream_stop(dpcm->h_stream));\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nhpi_handle_error(\r\nhpi_outstream_reset(dpcm->h_stream));\r\nif (card->support_grouping)\r\nhpi_handle_error(hpi_stream_group_reset(dpcm->h_stream));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nsnd_printdd("pause release\n");\r\nhpi_handle_error(hpi_stream_start(dpcm->h_stream));\r\nsnd_card_asihpi_pcm_timer_start(substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nsnd_printdd("pause\n");\r\nsnd_card_asihpi_pcm_timer_stop(substream);\r\nhpi_handle_error(hpi_stream_stop(dpcm->h_stream));\r\nbreak;\r\ndefault:\r\nsnd_printd(KERN_ERR "\tINVALID\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int modulo_min(unsigned int a, unsigned int b,\r\nunsigned long int modulus)\r\n{\r\nunsigned int result;\r\nif (((a-b) % modulus) < (modulus/2))\r\nresult = b;\r\nelse\r\nresult = a;\r\nreturn result;\r\n}\r\nstatic void snd_card_asihpi_timer_function(unsigned long data)\r\n{\r\nstruct snd_card_asihpi_pcm *dpcm = (struct snd_card_asihpi_pcm *)data;\r\nstruct snd_pcm_substream *substream = dpcm->substream;\r\nstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_pcm_substream *s;\r\nunsigned int newdata = 0;\r\nunsigned int pcm_buf_dma_ofs, min_buf_pos = 0;\r\nunsigned int remdata, xfercount, next_jiffies;\r\nint first = 1;\r\nint loops = 0;\r\nu16 state;\r\nu32 buffer_size, bytes_avail, samples_played, on_card_bytes;\r\nchar name[16];\r\nsnd_pcm_debug_name(substream, name, sizeof(name));\r\nsnd_printdd("%s snd_card_asihpi_timer_function\n", name);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nstruct snd_card_asihpi_pcm *ds = s->runtime->private_data;\r\nruntime = s->runtime;\r\nif (snd_pcm_substream_chip(s) != card)\r\ncontinue;\r\nif (substream->stream != s->stream)\r\ncontinue;\r\nhpi_handle_error(hpi_stream_get_info_ex(\r\nds->h_stream, &state,\r\n&buffer_size, &bytes_avail,\r\n&samples_played, &on_card_bytes));\r\nruntime->delay = on_card_bytes;\r\nif (!card->can_dma)\r\non_card_bytes = bytes_avail;\r\nif (s->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\npcm_buf_dma_ofs = ds->pcm_buf_host_rw_ofs - bytes_avail;\r\nif (state == HPI_STATE_STOPPED) {\r\nif (bytes_avail == 0) {\r\nhpi_handle_error(hpi_stream_start(ds->h_stream));\r\nsnd_printdd("P%d start\n", s->number);\r\nds->drained_count = 0;\r\n}\r\n} else if (state == HPI_STATE_DRAINED) {\r\nsnd_printd(KERN_WARNING "P%d drained\n",\r\ns->number);\r\nds->drained_count++;\r\nif (ds->drained_count > 20) {\r\nunsigned long flags;\r\nsnd_pcm_stream_lock_irqsave(s, flags);\r\nsnd_pcm_stop(s, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irqrestore(s, flags);\r\ncontinue;\r\n}\r\n} else {\r\nds->drained_count = 0;\r\n}\r\n} else\r\npcm_buf_dma_ofs = bytes_avail + ds->pcm_buf_host_rw_ofs;\r\nif (first) {\r\nmin_buf_pos = pcm_buf_dma_ofs;\r\nnewdata = (pcm_buf_dma_ofs - ds->pcm_buf_elapsed_dma_ofs) % ds->buffer_bytes;\r\nfirst = 0;\r\n} else {\r\nmin_buf_pos =\r\nmodulo_min(min_buf_pos, pcm_buf_dma_ofs, UINT_MAX+1L);\r\nnewdata = min(\r\n(pcm_buf_dma_ofs - ds->pcm_buf_elapsed_dma_ofs) % ds->buffer_bytes,\r\nnewdata);\r\n}\r\nsnd_printdd("hw_ptr 0x%04lX, appl_ptr 0x%04lX\n",\r\n(unsigned long)frames_to_bytes(runtime,\r\nruntime->status->hw_ptr),\r\n(unsigned long)frames_to_bytes(runtime,\r\nruntime->control->appl_ptr));\r\nsnd_printdd("%d S=%d, "\r\n"rw=0x%04X, dma=0x%04X, left=0x%04X, "\r\n"aux=0x%04X space=0x%04X\n",\r\ns->number, state,\r\nds->pcm_buf_host_rw_ofs, pcm_buf_dma_ofs,\r\n(int)bytes_avail,\r\n(int)on_card_bytes, buffer_size-bytes_avail);\r\nloops++;\r\n}\r\npcm_buf_dma_ofs = min_buf_pos;\r\nremdata = newdata % dpcm->period_bytes;\r\nxfercount = newdata - remdata;\r\nif (xfercount && (on_card_bytes > dpcm->period_bytes))\r\nnext_jiffies = ((on_card_bytes - dpcm->period_bytes) * HZ / dpcm->bytes_per_sec);\r\nelse\r\nnext_jiffies = ((dpcm->period_bytes - remdata) * HZ / dpcm->bytes_per_sec);\r\nnext_jiffies = max(next_jiffies, 1U);\r\ndpcm->timer.expires = jiffies + next_jiffies;\r\nsnd_printdd("jif %d buf pos 0x%04X newdata 0x%04X xfer 0x%04X\n",\r\nnext_jiffies, pcm_buf_dma_ofs, newdata, xfercount);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nstruct snd_card_asihpi_pcm *ds = s->runtime->private_data;\r\nif (substream->stream != s->stream)\r\ncontinue;\r\nds->pcm_buf_dma_ofs = pcm_buf_dma_ofs;\r\nif (xfercount &&\r\n((on_card_bytes <= ds->period_bytes) ||\r\n(s->stream == SNDRV_PCM_STREAM_CAPTURE)))\r\n{\r\nunsigned int buf_ofs = ds->pcm_buf_host_rw_ofs % ds->buffer_bytes;\r\nunsigned int xfer1, xfer2;\r\nchar *pd = &s->runtime->dma_area[buf_ofs];\r\nif (card->can_dma) {\r\nxfer1 = xfercount;\r\nxfer2 = 0;\r\n} else {\r\nxfer1 = min(xfercount, ds->buffer_bytes - buf_ofs);\r\nxfer2 = xfercount - xfer1;\r\n}\r\nif (s->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsnd_printddd("P%d write1 0x%04X 0x%04X\n",\r\ns->number, xfer1, buf_ofs);\r\nhpi_handle_error(\r\nhpi_outstream_write_buf(\r\nds->h_stream, pd, xfer1,\r\n&ds->format));\r\nif (xfer2) {\r\npd = s->runtime->dma_area;\r\nsnd_printddd("P%d write2 0x%04X 0x%04X\n",\r\ns->number,\r\nxfercount - xfer1, buf_ofs);\r\nhpi_handle_error(\r\nhpi_outstream_write_buf(\r\nds->h_stream, pd,\r\nxfercount - xfer1,\r\n&ds->format));\r\n}\r\n} else {\r\nsnd_printddd("C%d read1 0x%04x\n",\r\ns->number, xfer1);\r\nhpi_handle_error(\r\nhpi_instream_read_buf(\r\nds->h_stream,\r\npd, xfer1));\r\nif (xfer2) {\r\npd = s->runtime->dma_area;\r\nsnd_printddd("C%d read2 0x%04x\n",\r\ns->number, xfer2);\r\nhpi_handle_error(\r\nhpi_instream_read_buf(\r\nds->h_stream,\r\npd, xfer2));\r\n}\r\n}\r\nds->pcm_buf_host_rw_ofs += xfercount;\r\nds->pcm_buf_elapsed_dma_ofs += xfercount;\r\nsnd_pcm_period_elapsed(s);\r\n}\r\n}\r\nif (dpcm->respawn_timer)\r\nadd_timer(&dpcm->timer);\r\n}\r\nstatic int snd_card_asihpi_playback_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nchar name[16];\r\nsnd_pcm_debug_name(substream, name, sizeof(name));\r\nsnd_printddd(KERN_INFO "%s ioctl %d\n", name, cmd);\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int snd_card_asihpi_playback_prepare(struct snd_pcm_substream *\r\nsubstream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nsnd_printdd("P%d prepare\n", substream->number);\r\nhpi_handle_error(hpi_outstream_reset(dpcm->h_stream));\r\ndpcm->pcm_buf_host_rw_ofs = 0;\r\ndpcm->pcm_buf_dma_ofs = 0;\r\ndpcm->pcm_buf_elapsed_dma_ofs = 0;\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_card_asihpi_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nsnd_pcm_uframes_t ptr;\r\nchar name[16];\r\nsnd_pcm_debug_name(substream, name, sizeof(name));\r\nptr = bytes_to_frames(runtime, dpcm->pcm_buf_dma_ofs % dpcm->buffer_bytes);\r\nsnd_printddd("%s pointer = 0x%04lx\n", name, (unsigned long)ptr);\r\nreturn ptr;\r\n}\r\nstatic u64 snd_card_asihpi_playback_formats(struct snd_card_asihpi *asihpi,\r\nu32 h_stream)\r\n{\r\nstruct hpi_format hpi_format;\r\nu16 format;\r\nu16 err;\r\nu32 h_control;\r\nu32 sample_rate = 48000;\r\nu64 formats = 0;\r\nerr = hpi_mixer_get_control(asihpi->h_mixer,\r\nHPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\r\nHPI_CONTROL_SAMPLECLOCK, &h_control);\r\nif (!err)\r\nerr = hpi_sample_clock_get_sample_rate(h_control,\r\n&sample_rate);\r\nfor (format = HPI_FORMAT_PCM8_UNSIGNED;\r\nformat <= HPI_FORMAT_PCM24_SIGNED; format++) {\r\nerr = hpi_format_create(&hpi_format, asihpi->out_max_chans,\r\nformat, sample_rate, 128000, 0);\r\nif (!err)\r\nerr = hpi_outstream_query_format(h_stream, &hpi_format);\r\nif (!err && (hpi_to_alsa_formats[format] != -1))\r\nformats |= pcm_format_to_bits(hpi_to_alsa_formats[format]);\r\n}\r\nreturn formats;\r\n}\r\nstatic int snd_card_asihpi_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm;\r\nstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_hardware snd_card_asihpi_playback;\r\nint err;\r\ndpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\r\nif (dpcm == NULL)\r\nreturn -ENOMEM;\r\nerr = hpi_outstream_open(card->hpi->adapter->index,\r\nsubstream->number, &dpcm->h_stream);\r\nhpi_handle_error(err);\r\nif (err)\r\nkfree(dpcm);\r\nif (err == HPI_ERROR_OBJ_ALREADY_OPEN)\r\nreturn -EBUSY;\r\nif (err)\r\nreturn -EIO;\r\ninit_timer(&dpcm->timer);\r\ndpcm->timer.data = (unsigned long) dpcm;\r\ndpcm->timer.function = snd_card_asihpi_timer_function;\r\ndpcm->substream = substream;\r\nruntime->private_data = dpcm;\r\nruntime->private_free = snd_card_asihpi_runtime_free;\r\nmemset(&snd_card_asihpi_playback, 0, sizeof(snd_card_asihpi_playback));\r\nsnd_card_asihpi_playback.buffer_bytes_max = BUFFER_BYTES_MAX;\r\nsnd_card_asihpi_playback.period_bytes_min = PERIOD_BYTES_MIN;\r\nsnd_card_asihpi_playback.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN;\r\nsnd_card_asihpi_playback.periods_min = PERIODS_MIN;\r\nsnd_card_asihpi_playback.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN;\r\nsnd_card_asihpi_playback.channels_max = card->out_max_chans;\r\nsnd_card_asihpi_playback.channels_min = card->out_min_chans;\r\nsnd_card_asihpi_playback.formats =\r\nsnd_card_asihpi_playback_formats(card, dpcm->h_stream);\r\nsnd_card_asihpi_pcm_samplerates(card, &snd_card_asihpi_playback);\r\nsnd_card_asihpi_playback.info = SNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_DOUBLE |\r\nSNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER |\r\nSNDRV_PCM_INFO_PAUSE |\r\nSNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID;\r\nif (card->support_grouping) {\r\nsnd_card_asihpi_playback.info |= SNDRV_PCM_INFO_SYNC_START;\r\nsnd_pcm_set_sync(substream);\r\n}\r\nruntime->hw = snd_card_asihpi_playback;\r\nif (card->can_dma)\r\nerr = snd_pcm_hw_constraint_pow2(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\ncard->update_interval_frames);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\ncard->update_interval_frames * 2, UINT_MAX);\r\nsnd_printdd("playback open\n");\r\nreturn 0;\r\n}\r\nstatic int snd_card_asihpi_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nhpi_handle_error(hpi_outstream_close(dpcm->h_stream));\r\nsnd_printdd("playback close\n");\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_card_asihpi_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nsnd_printddd("capture pointer %d=%d\n",\r\nsubstream->number, dpcm->pcm_buf_dma_ofs);\r\nreturn bytes_to_frames(runtime, dpcm->pcm_buf_dma_ofs % dpcm->buffer_bytes);\r\n}\r\nstatic int snd_card_asihpi_capture_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int snd_card_asihpi_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi_pcm *dpcm = runtime->private_data;\r\nhpi_handle_error(hpi_instream_reset(dpcm->h_stream));\r\ndpcm->pcm_buf_host_rw_ofs = 0;\r\ndpcm->pcm_buf_dma_ofs = 0;\r\ndpcm->pcm_buf_elapsed_dma_ofs = 0;\r\nsnd_printdd("Capture Prepare %d\n", substream->number);\r\nreturn 0;\r\n}\r\nstatic u64 snd_card_asihpi_capture_formats(struct snd_card_asihpi *asihpi,\r\nu32 h_stream)\r\n{\r\nstruct hpi_format hpi_format;\r\nu16 format;\r\nu16 err;\r\nu32 h_control;\r\nu32 sample_rate = 48000;\r\nu64 formats = 0;\r\nerr = hpi_mixer_get_control(asihpi->h_mixer,\r\nHPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\r\nHPI_CONTROL_SAMPLECLOCK, &h_control);\r\nif (!err)\r\nerr = hpi_sample_clock_get_sample_rate(h_control,\r\n&sample_rate);\r\nfor (format = HPI_FORMAT_PCM8_UNSIGNED;\r\nformat <= HPI_FORMAT_PCM24_SIGNED; format++) {\r\nerr = hpi_format_create(&hpi_format, asihpi->in_max_chans,\r\nformat, sample_rate, 128000, 0);\r\nif (!err)\r\nerr = hpi_instream_query_format(h_stream, &hpi_format);\r\nif (!err && (hpi_to_alsa_formats[format] != -1))\r\nformats |= pcm_format_to_bits(hpi_to_alsa_formats[format]);\r\n}\r\nreturn formats;\r\n}\r\nstatic int snd_card_asihpi_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_card_asihpi *card = snd_pcm_substream_chip(substream);\r\nstruct snd_card_asihpi_pcm *dpcm;\r\nstruct snd_pcm_hardware snd_card_asihpi_capture;\r\nint err;\r\ndpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\r\nif (dpcm == NULL)\r\nreturn -ENOMEM;\r\nsnd_printdd("capture open adapter %d stream %d\n",\r\ncard->hpi->adapter->index, substream->number);\r\nerr = hpi_handle_error(\r\nhpi_instream_open(card->hpi->adapter->index,\r\nsubstream->number, &dpcm->h_stream));\r\nif (err)\r\nkfree(dpcm);\r\nif (err == HPI_ERROR_OBJ_ALREADY_OPEN)\r\nreturn -EBUSY;\r\nif (err)\r\nreturn -EIO;\r\ninit_timer(&dpcm->timer);\r\ndpcm->timer.data = (unsigned long) dpcm;\r\ndpcm->timer.function = snd_card_asihpi_timer_function;\r\ndpcm->substream = substream;\r\nruntime->private_data = dpcm;\r\nruntime->private_free = snd_card_asihpi_runtime_free;\r\nmemset(&snd_card_asihpi_capture, 0, sizeof(snd_card_asihpi_capture));\r\nsnd_card_asihpi_capture.buffer_bytes_max = BUFFER_BYTES_MAX;\r\nsnd_card_asihpi_capture.period_bytes_min = PERIOD_BYTES_MIN;\r\nsnd_card_asihpi_capture.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN;\r\nsnd_card_asihpi_capture.periods_min = PERIODS_MIN;\r\nsnd_card_asihpi_capture.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN;\r\nsnd_card_asihpi_capture.channels_max = card->in_max_chans;\r\nsnd_card_asihpi_capture.channels_min = card->in_min_chans;\r\nsnd_card_asihpi_capture.formats =\r\nsnd_card_asihpi_capture_formats(card, dpcm->h_stream);\r\nsnd_card_asihpi_pcm_samplerates(card, &snd_card_asihpi_capture);\r\nsnd_card_asihpi_capture.info = SNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID;\r\nif (card->support_grouping)\r\nsnd_card_asihpi_capture.info |= SNDRV_PCM_INFO_SYNC_START;\r\nruntime->hw = snd_card_asihpi_capture;\r\nif (card->can_dma)\r\nerr = snd_pcm_hw_constraint_pow2(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\ncard->update_interval_frames);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\ncard->update_interval_frames * 2, UINT_MAX);\r\nsnd_pcm_set_sync(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_card_asihpi_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_card_asihpi_pcm *dpcm = substream->runtime->private_data;\r\nhpi_handle_error(hpi_instream_close(dpcm->h_stream));\r\nreturn 0;\r\n}\r\nstatic int snd_card_asihpi_pcm_new(struct snd_card_asihpi *asihpi, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nu16 num_instreams, num_outstreams, x16;\r\nu32 x32;\r\nerr = hpi_adapter_get_info(asihpi->hpi->adapter->index,\r\n&num_outstreams, &num_instreams,\r\n&x16, &x32, &x16);\r\nerr = snd_pcm_new(asihpi->card, "Asihpi PCM", device,\r\nnum_outstreams, num_instreams, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_card_asihpi_playback_mmap_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_card_asihpi_capture_mmap_ops);\r\npcm->private_data = asihpi;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "Asihpi PCM");\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(asihpi->pci),\r\n64*1024, BUFFER_BYTES_MAX);\r\nreturn 0;\r\n}\r\nstatic inline int ctl_add(struct snd_card *card, struct snd_kcontrol_new *ctl,\r\nstruct snd_card_asihpi *asihpi)\r\n{\r\nint err;\r\nerr = snd_ctl_add(card, snd_ctl_new1(ctl, asihpi));\r\nif (err < 0)\r\nreturn err;\r\nelse if (mixer_dump)\r\nsnd_printk(KERN_INFO "added %s(%d)\n", ctl->name, ctl->index);\r\nreturn 0;\r\n}\r\nstatic void asihpi_ctl_init(struct snd_kcontrol_new *snd_control,\r\nstruct hpi_control *hpi_ctl,\r\nchar *name)\r\n{\r\nchar *dir;\r\nmemset(snd_control, 0, sizeof(*snd_control));\r\nsnd_control->name = hpi_ctl->name;\r\nsnd_control->private_value = hpi_ctl->h_control;\r\nsnd_control->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nsnd_control->index = 0;\r\nif (hpi_ctl->src_node_type + HPI_SOURCENODE_NONE == HPI_SOURCENODE_CLOCK_SOURCE)\r\ndir = "";\r\nelse if (hpi_ctl->dst_node_type + HPI_DESTNODE_NONE == HPI_DESTNODE_ISTREAM)\r\ndir = "Capture ";\r\nelse if ((hpi_ctl->src_node_type + HPI_SOURCENODE_NONE != HPI_SOURCENODE_OSTREAM) &&\r\n(!hpi_ctl->dst_node_type))\r\ndir = "Capture ";\r\nelse if (hpi_ctl->src_node_type &&\r\n(hpi_ctl->src_node_type + HPI_SOURCENODE_NONE != HPI_SOURCENODE_OSTREAM) &&\r\n(hpi_ctl->dst_node_type))\r\ndir = "Monitor Playback ";\r\nelse\r\ndir = "Playback ";\r\nif (hpi_ctl->src_node_type && hpi_ctl->dst_node_type)\r\nsprintf(hpi_ctl->name, "%s %d %s %d %s%s",\r\nasihpi_src_names[hpi_ctl->src_node_type],\r\nhpi_ctl->src_node_index,\r\nasihpi_dst_names[hpi_ctl->dst_node_type],\r\nhpi_ctl->dst_node_index,\r\ndir, name);\r\nelse if (hpi_ctl->dst_node_type) {\r\nsprintf(hpi_ctl->name, "%s %d %s%s",\r\nasihpi_dst_names[hpi_ctl->dst_node_type],\r\nhpi_ctl->dst_node_index,\r\ndir, name);\r\n} else {\r\nsprintf(hpi_ctl->name, "%s %d %s%s",\r\nasihpi_src_names[hpi_ctl->src_node_type],\r\nhpi_ctl->src_node_index,\r\ndir, name);\r\n}\r\n}\r\nstatic int snd_asihpi_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu32 count;\r\nu16 err;\r\nshort min_gain_mB;\r\nshort max_gain_mB;\r\nshort step_gain_mB;\r\nerr = hpi_volume_query_range(h_control,\r\n&min_gain_mB, &max_gain_mB, &step_gain_mB);\r\nif (err) {\r\nmax_gain_mB = 0;\r\nmin_gain_mB = -10000;\r\nstep_gain_mB = VOL_STEP_mB;\r\n}\r\nerr = hpi_meter_query_channels(h_control, &count);\r\nif (err)\r\ncount = HPI_MAX_CHANNELS;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = count;\r\nuinfo->value.integer.min = min_gain_mB / VOL_STEP_mB;\r\nuinfo->value.integer.max = max_gain_mB / VOL_STEP_mB;\r\nuinfo->value.integer.step = step_gain_mB / VOL_STEP_mB;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nshort an_gain_mB[HPI_MAX_CHANNELS];\r\nhpi_handle_error(hpi_volume_get_gain(h_control, an_gain_mB));\r\nucontrol->value.integer.value[0] = an_gain_mB[0] / VOL_STEP_mB;\r\nucontrol->value.integer.value[1] = an_gain_mB[1] / VOL_STEP_mB;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint change;\r\nu32 h_control = kcontrol->private_value;\r\nshort an_gain_mB[HPI_MAX_CHANNELS];\r\nan_gain_mB[0] =\r\n(ucontrol->value.integer.value[0]) * VOL_STEP_mB;\r\nan_gain_mB[1] =\r\n(ucontrol->value.integer.value[1]) * VOL_STEP_mB;\r\nchange = 1;\r\nhpi_handle_error(hpi_volume_set_gain(h_control, an_gain_mB));\r\nreturn change;\r\n}\r\nstatic int snd_asihpi_volume_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu32 mute;\r\nhpi_handle_error(hpi_volume_get_mute(h_control, &mute));\r\nucontrol->value.integer.value[0] = mute ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_volume_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nint change = 1;\r\nint mute = ucontrol->value.integer.value[0] ? 0 : HPI_BITMASK_ALL_CHANNELS;\r\nhpi_handle_error(hpi_volume_set_mute(h_control, mute));\r\nreturn change;\r\n}\r\nstatic int snd_asihpi_volume_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nint err;\r\nu32 mute;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Volume");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nsnd_control.info = snd_asihpi_volume_info;\r\nsnd_control.get = snd_asihpi_volume_get;\r\nsnd_control.put = snd_asihpi_volume_put;\r\nsnd_control.tlv.p = db_scale_100;\r\nerr = ctl_add(card, &snd_control, asihpi);\r\nif (err)\r\nreturn err;\r\nif (hpi_volume_get_mute(hpi_ctl->h_control, &mute) == 0) {\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Switch");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nsnd_control.info = snd_asihpi_volume_mute_info;\r\nsnd_control.get = snd_asihpi_volume_mute_get;\r\nsnd_control.put = snd_asihpi_volume_mute_put;\r\nerr = ctl_add(card, &snd_control, asihpi);\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_asihpi_level_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu16 err;\r\nshort min_gain_mB;\r\nshort max_gain_mB;\r\nshort step_gain_mB;\r\nerr =\r\nhpi_level_query_range(h_control, &min_gain_mB,\r\n&max_gain_mB, &step_gain_mB);\r\nif (err) {\r\nmax_gain_mB = 2400;\r\nmin_gain_mB = -1000;\r\nstep_gain_mB = 100;\r\n}\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = min_gain_mB / HPI_UNITS_PER_dB;\r\nuinfo->value.integer.max = max_gain_mB / HPI_UNITS_PER_dB;\r\nuinfo->value.integer.step = step_gain_mB / HPI_UNITS_PER_dB;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_level_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nshort an_gain_mB[HPI_MAX_CHANNELS];\r\nhpi_handle_error(hpi_level_get_gain(h_control, an_gain_mB));\r\nucontrol->value.integer.value[0] =\r\nan_gain_mB[0] / HPI_UNITS_PER_dB;\r\nucontrol->value.integer.value[1] =\r\nan_gain_mB[1] / HPI_UNITS_PER_dB;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_level_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint change;\r\nu32 h_control = kcontrol->private_value;\r\nshort an_gain_mB[HPI_MAX_CHANNELS];\r\nan_gain_mB[0] =\r\n(ucontrol->value.integer.value[0]) * HPI_UNITS_PER_dB;\r\nan_gain_mB[1] =\r\n(ucontrol->value.integer.value[1]) * HPI_UNITS_PER_dB;\r\nchange = 1;\r\nhpi_handle_error(hpi_level_set_gain(h_control, an_gain_mB));\r\nreturn change;\r\n}\r\nstatic int snd_asihpi_level_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Level");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nsnd_control.info = snd_asihpi_level_info;\r\nsnd_control.get = snd_asihpi_level_get;\r\nsnd_control.put = snd_asihpi_level_put;\r\nsnd_control.tlv.p = db_scale_level;\r\nreturn ctl_add(card, &snd_control, asihpi);\r\n}\r\nstatic int snd_asihpi_aesebu_format_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nasihpi_aesebu_format_names[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_aesebu_format_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nu16 (*func)(u32, u16 *))\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu16 source, err;\r\nerr = func(h_control, &source);\r\nucontrol->value.enumerated.item[0] = 0;\r\nif (err)\r\nreturn 0;\r\nif (source == HPI_AESEBU_FORMAT_SPDIF)\r\nucontrol->value.enumerated.item[0] = 1;\r\nif (source == HPI_AESEBU_FORMAT_AESEBU)\r\nucontrol->value.enumerated.item[0] = 2;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_aesebu_format_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nu16 (*func)(u32, u16))\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu16 source = HPI_AESEBU_FORMAT_SPDIF;\r\nif (ucontrol->value.enumerated.item[0] == 1)\r\nsource = HPI_AESEBU_FORMAT_SPDIF;\r\nif (ucontrol->value.enumerated.item[0] == 2)\r\nsource = HPI_AESEBU_FORMAT_AESEBU;\r\nif (func(h_control, source) != 0)\r\nreturn -EINVAL;\r\nreturn 1;\r\n}\r\nstatic int snd_asihpi_aesebu_rx_format_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol) {\r\nreturn snd_asihpi_aesebu_format_get(kcontrol, ucontrol,\r\nhpi_aesebu_receiver_get_format);\r\n}\r\nstatic int snd_asihpi_aesebu_rx_format_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol) {\r\nreturn snd_asihpi_aesebu_format_put(kcontrol, ucontrol,\r\nhpi_aesebu_receiver_set_format);\r\n}\r\nstatic int snd_asihpi_aesebu_rxstatus_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0X1F;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_aesebu_rxstatus_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol) {\r\nu32 h_control = kcontrol->private_value;\r\nu16 status;\r\nhpi_handle_error(hpi_aesebu_receiver_get_error_status(\r\nh_control, &status));\r\nucontrol->value.integer.value[0] = status;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_aesebu_rx_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Format");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nsnd_control.info = snd_asihpi_aesebu_format_info;\r\nsnd_control.get = snd_asihpi_aesebu_rx_format_get;\r\nsnd_control.put = snd_asihpi_aesebu_rx_format_put;\r\nif (ctl_add(card, &snd_control, asihpi) < 0)\r\nreturn -EINVAL;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Status");\r\nsnd_control.access =\r\nSNDRV_CTL_ELEM_ACCESS_VOLATILE | SNDRV_CTL_ELEM_ACCESS_READ;\r\nsnd_control.info = snd_asihpi_aesebu_rxstatus_info;\r\nsnd_control.get = snd_asihpi_aesebu_rxstatus_get;\r\nreturn ctl_add(card, &snd_control, asihpi);\r\n}\r\nstatic int snd_asihpi_aesebu_tx_format_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol) {\r\nreturn snd_asihpi_aesebu_format_get(kcontrol, ucontrol,\r\nhpi_aesebu_transmitter_get_format);\r\n}\r\nstatic int snd_asihpi_aesebu_tx_format_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol) {\r\nreturn snd_asihpi_aesebu_format_put(kcontrol, ucontrol,\r\nhpi_aesebu_transmitter_set_format);\r\n}\r\nstatic int snd_asihpi_aesebu_tx_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Format");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nsnd_control.info = snd_asihpi_aesebu_format_info;\r\nsnd_control.get = snd_asihpi_aesebu_tx_format_get;\r\nsnd_control.put = snd_asihpi_aesebu_tx_format_put;\r\nreturn ctl_add(card, &snd_control, asihpi);\r\n}\r\nstatic int snd_asihpi_tuner_gain_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu16 err;\r\nshort idx;\r\nu16 gain_range[3];\r\nfor (idx = 0; idx < 3; idx++) {\r\nerr = hpi_tuner_query_gain(h_control,\r\nidx, &gain_range[idx]);\r\nif (err != 0)\r\nreturn err;\r\n}\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = ((int)gain_range[0]) / HPI_UNITS_PER_dB;\r\nuinfo->value.integer.max = ((int)gain_range[1]) / HPI_UNITS_PER_dB;\r\nuinfo->value.integer.step = ((int) gain_range[2]) / HPI_UNITS_PER_dB;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_tuner_gain_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nshort gain;\r\nhpi_handle_error(hpi_tuner_get_gain(h_control, &gain));\r\nucontrol->value.integer.value[0] = gain / HPI_UNITS_PER_dB;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_tuner_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nshort gain;\r\ngain = (ucontrol->value.integer.value[0]) * HPI_UNITS_PER_dB;\r\nhpi_handle_error(hpi_tuner_set_gain(h_control, gain));\r\nreturn 1;\r\n}\r\nstatic int asihpi_tuner_band_query(struct snd_kcontrol *kcontrol,\r\nu16 *band_list, u32 len) {\r\nu32 h_control = kcontrol->private_value;\r\nu16 err = 0;\r\nu32 i;\r\nfor (i = 0; i < len; i++) {\r\nerr = hpi_tuner_query_band(\r\nh_control, i, &band_list[i]);\r\nif (err != 0)\r\nbreak;\r\n}\r\nif (err && (err != HPI_ERROR_INVALID_OBJ_INDEX))\r\nreturn -EIO;\r\nreturn i;\r\n}\r\nstatic int snd_asihpi_tuner_band_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nu16 tuner_bands[HPI_TUNER_BAND_LAST];\r\nint num_bands = 0;\r\nnum_bands = asihpi_tuner_band_query(kcontrol, tuner_bands,\r\nHPI_TUNER_BAND_LAST);\r\nif (num_bands < 0)\r\nreturn num_bands;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = num_bands;\r\nif (num_bands > 0) {\r\nif (uinfo->value.enumerated.item >=\r\nuinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nasihpi_tuner_band_names[\r\ntuner_bands[uinfo->value.enumerated.item]]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_tuner_band_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu16 band, idx;\r\nu16 tuner_bands[HPI_TUNER_BAND_LAST];\r\nu32 num_bands = 0;\r\nnum_bands = asihpi_tuner_band_query(kcontrol, tuner_bands,\r\nHPI_TUNER_BAND_LAST);\r\nhpi_handle_error(hpi_tuner_get_band(h_control, &band));\r\nucontrol->value.enumerated.item[0] = -1;\r\nfor (idx = 0; idx < HPI_TUNER_BAND_LAST; idx++)\r\nif (tuner_bands[idx] == band) {\r\nucontrol->value.enumerated.item[0] = idx;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_tuner_band_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nunsigned int idx;\r\nu16 band;\r\nu16 tuner_bands[HPI_TUNER_BAND_LAST];\r\nu32 num_bands = 0;\r\nnum_bands = asihpi_tuner_band_query(kcontrol, tuner_bands,\r\nHPI_TUNER_BAND_LAST);\r\nidx = ucontrol->value.enumerated.item[0];\r\nif (idx >= ARRAY_SIZE(tuner_bands))\r\nidx = ARRAY_SIZE(tuner_bands) - 1;\r\nband = tuner_bands[idx];\r\nhpi_handle_error(hpi_tuner_set_band(h_control, band));\r\nreturn 1;\r\n}\r\nstatic int snd_asihpi_tuner_freq_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu16 err;\r\nu16 tuner_bands[HPI_TUNER_BAND_LAST];\r\nu16 num_bands = 0, band_iter, idx;\r\nu32 freq_range[3], temp_freq_range[3];\r\nnum_bands = asihpi_tuner_band_query(kcontrol, tuner_bands,\r\nHPI_TUNER_BAND_LAST);\r\nfreq_range[0] = INT_MAX;\r\nfreq_range[1] = 0;\r\nfreq_range[2] = INT_MAX;\r\nfor (band_iter = 0; band_iter < num_bands; band_iter++) {\r\nfor (idx = 0; idx < 3; idx++) {\r\nerr = hpi_tuner_query_frequency(h_control,\r\nidx, tuner_bands[band_iter],\r\n&temp_freq_range[idx]);\r\nif (err != 0)\r\nreturn err;\r\n}\r\nif (temp_freq_range[2] <= 0)\r\ncontinue;\r\nif (temp_freq_range[0] < freq_range[0])\r\nfreq_range[0] = temp_freq_range[0];\r\nif (temp_freq_range[1] > freq_range[1])\r\nfreq_range[1] = temp_freq_range[1];\r\nif (temp_freq_range[2] < freq_range[2])\r\nfreq_range[2] = temp_freq_range[2];\r\n}\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = ((int)freq_range[0]);\r\nuinfo->value.integer.max = ((int)freq_range[1]);\r\nuinfo->value.integer.step = ((int)freq_range[2]);\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_tuner_freq_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu32 freq;\r\nhpi_handle_error(hpi_tuner_get_frequency(h_control, &freq));\r\nucontrol->value.integer.value[0] = freq;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_tuner_freq_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu32 freq;\r\nfreq = ucontrol->value.integer.value[0];\r\nhpi_handle_error(hpi_tuner_set_frequency(h_control, freq));\r\nreturn 1;\r\n}\r\nstatic int snd_asihpi_tuner_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nsnd_control.private_value = hpi_ctl->h_control;\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nif (!hpi_tuner_get_gain(hpi_ctl->h_control, NULL)) {\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Gain");\r\nsnd_control.info = snd_asihpi_tuner_gain_info;\r\nsnd_control.get = snd_asihpi_tuner_gain_get;\r\nsnd_control.put = snd_asihpi_tuner_gain_put;\r\nif (ctl_add(card, &snd_control, asihpi) < 0)\r\nreturn -EINVAL;\r\n}\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Band");\r\nsnd_control.info = snd_asihpi_tuner_band_info;\r\nsnd_control.get = snd_asihpi_tuner_band_get;\r\nsnd_control.put = snd_asihpi_tuner_band_put;\r\nif (ctl_add(card, &snd_control, asihpi) < 0)\r\nreturn -EINVAL;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Freq");\r\nsnd_control.info = snd_asihpi_tuner_freq_info;\r\nsnd_control.get = snd_asihpi_tuner_freq_get;\r\nsnd_control.put = snd_asihpi_tuner_freq_put;\r\nreturn ctl_add(card, &snd_control, asihpi);\r\n}\r\nstatic int snd_asihpi_meter_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu32 count;\r\nu16 err;\r\nerr = hpi_meter_query_channels(h_control, &count);\r\nif (err)\r\ncount = HPI_MAX_CHANNELS;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = count;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0x7FFFFFFF;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_meter_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nshort an_gain_mB[HPI_MAX_CHANNELS], i;\r\nu16 err;\r\nerr = hpi_meter_get_peak(h_control, an_gain_mB);\r\nfor (i = 0; i < HPI_MAX_CHANNELS; i++) {\r\nif (err) {\r\nucontrol->value.integer.value[i] = 0;\r\n} else if (an_gain_mB[i] >= 0) {\r\nucontrol->value.integer.value[i] =\r\nan_gain_mB[i] << 16;\r\n} else {\r\nucontrol->value.integer.value[i] =\r\nlog2lin[an_gain_mB[i] / -1000];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_meter_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl, int subidx)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Meter");\r\nsnd_control.access =\r\nSNDRV_CTL_ELEM_ACCESS_VOLATILE | SNDRV_CTL_ELEM_ACCESS_READ;\r\nsnd_control.info = snd_asihpi_meter_info;\r\nsnd_control.get = snd_asihpi_meter_get;\r\nsnd_control.index = subidx;\r\nreturn ctl_add(card, &snd_control, asihpi);\r\n}\r\nstatic int snd_card_asihpi_mux_count_sources(struct snd_kcontrol *snd_control)\r\n{\r\nu32 h_control = snd_control->private_value;\r\nstruct hpi_control hpi_ctl;\r\nint s, err;\r\nfor (s = 0; s < 32; s++) {\r\nerr = hpi_multiplexer_query_source(h_control, s,\r\n&hpi_ctl.\r\nsrc_node_type,\r\n&hpi_ctl.\r\nsrc_node_index);\r\nif (err)\r\nbreak;\r\n}\r\nreturn s;\r\n}\r\nstatic int snd_asihpi_mux_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint err;\r\nu16 src_node_type, src_node_index;\r\nu32 h_control = kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items =\r\nsnd_card_asihpi_mux_count_sources(kcontrol);\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nerr =\r\nhpi_multiplexer_query_source(h_control,\r\nuinfo->value.enumerated.item,\r\n&src_node_type, &src_node_index);\r\nsprintf(uinfo->value.enumerated.name, "%s %d",\r\nasihpi_src_names[src_node_type - HPI_SOURCENODE_NONE],\r\nsrc_node_index);\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_mux_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu16 source_type, source_index;\r\nu16 src_node_type, src_node_index;\r\nint s;\r\nhpi_handle_error(hpi_multiplexer_get_source(h_control,\r\n&source_type, &source_index));\r\nfor (s = 0; s < 256; s++) {\r\nif (hpi_multiplexer_query_source(h_control, s,\r\n&src_node_type, &src_node_index))\r\nbreak;\r\nif ((source_type == src_node_type)\r\n&& (source_index == src_node_index)) {\r\nucontrol->value.enumerated.item[0] = s;\r\nreturn 0;\r\n}\r\n}\r\nsnd_printd(KERN_WARNING\r\n"Control %x failed to match mux source %hu %hu\n",\r\nh_control, source_type, source_index);\r\nucontrol->value.enumerated.item[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_mux_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint change;\r\nu32 h_control = kcontrol->private_value;\r\nu16 source_type, source_index;\r\nu16 e;\r\nchange = 1;\r\ne = hpi_multiplexer_query_source(h_control,\r\nucontrol->value.enumerated.item[0],\r\n&source_type, &source_index);\r\nif (!e)\r\nhpi_handle_error(\r\nhpi_multiplexer_set_source(h_control,\r\nsource_type, source_index));\r\nreturn change;\r\n}\r\nstatic int snd_asihpi_mux_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Route");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nsnd_control.info = snd_asihpi_mux_info;\r\nsnd_control.get = snd_asihpi_mux_get;\r\nsnd_control.put = snd_asihpi_mux_put;\r\nreturn ctl_add(card, &snd_control, asihpi);\r\n}\r\nstatic int snd_asihpi_cmode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const mode_names[HPI_CHANNEL_MODE_LAST + 1] = {\r\n"invalid",\r\n"Normal", "Swap",\r\n"From Left", "From Right",\r\n"To Left", "To Right"\r\n};\r\nu32 h_control = kcontrol->private_value;\r\nu16 mode;\r\nint i;\r\nu16 mode_map[6];\r\nint valid_modes = 0;\r\nfor (i = 0; i < HPI_CHANNEL_MODE_LAST; i++)\r\nif (!hpi_channel_mode_query_mode(\r\nh_control, i, &mode)) {\r\nmode_map[valid_modes] = mode;\r\nvalid_modes++;\r\n}\r\nif (!valid_modes)\r\nreturn -EINVAL;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = valid_modes;\r\nif (uinfo->value.enumerated.item >= valid_modes)\r\nuinfo->value.enumerated.item = valid_modes - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nmode_names[mode_map[uinfo->value.enumerated.item]]);\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_cmode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu16 mode;\r\nif (hpi_channel_mode_get(h_control, &mode))\r\nmode = 1;\r\nucontrol->value.enumerated.item[0] = mode - 1;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_cmode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint change;\r\nu32 h_control = kcontrol->private_value;\r\nchange = 1;\r\nhpi_handle_error(hpi_channel_mode_set(h_control,\r\nucontrol->value.enumerated.item[0] + 1));\r\nreturn change;\r\n}\r\nstatic int snd_asihpi_cmode_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Mode");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nsnd_control.info = snd_asihpi_cmode_info;\r\nsnd_control.get = snd_asihpi_cmode_get;\r\nsnd_control.put = snd_asihpi_cmode_put;\r\nreturn ctl_add(card, &snd_control, asihpi);\r\n}\r\nstatic int snd_asihpi_clksrc_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_card_asihpi *asihpi =\r\n(struct snd_card_asihpi *)(kcontrol->private_data);\r\nstruct clk_cache *clkcache = &asihpi->cc;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = clkcache->count;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nclkcache->s[uinfo->value.enumerated.item].name);\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_clksrc_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_card_asihpi *asihpi =\r\n(struct snd_card_asihpi *)(kcontrol->private_data);\r\nstruct clk_cache *clkcache = &asihpi->cc;\r\nu32 h_control = kcontrol->private_value;\r\nu16 source, srcindex = 0;\r\nint i;\r\nucontrol->value.enumerated.item[0] = 0;\r\nif (hpi_sample_clock_get_source(h_control, &source))\r\nsource = 0;\r\nif (source == HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT)\r\nif (hpi_sample_clock_get_source_index(h_control, &srcindex))\r\nsrcindex = 0;\r\nfor (i = 0; i < clkcache->count; i++)\r\nif ((clkcache->s[i].source == source) &&\r\n(clkcache->s[i].index == srcindex))\r\nbreak;\r\nucontrol->value.enumerated.item[0] = i;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_clksrc_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_card_asihpi *asihpi =\r\n(struct snd_card_asihpi *)(kcontrol->private_data);\r\nstruct clk_cache *clkcache = &asihpi->cc;\r\nunsigned int item;\r\nint change;\r\nu32 h_control = kcontrol->private_value;\r\nchange = 1;\r\nitem = ucontrol->value.enumerated.item[0];\r\nif (item >= clkcache->count)\r\nitem = clkcache->count-1;\r\nhpi_handle_error(hpi_sample_clock_set_source(\r\nh_control, clkcache->s[item].source));\r\nif (clkcache->s[item].source == HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT)\r\nhpi_handle_error(hpi_sample_clock_set_source_index(\r\nh_control, clkcache->s[item].index));\r\nreturn change;\r\n}\r\nstatic int snd_asihpi_clklocal_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 8000;\r\nuinfo->value.integer.max = 192000;\r\nuinfo->value.integer.step = 100;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_clklocal_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu32 rate;\r\nu16 e;\r\ne = hpi_sample_clock_get_local_rate(h_control, &rate);\r\nif (!e)\r\nucontrol->value.integer.value[0] = rate;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_clklocal_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint change;\r\nu32 h_control = kcontrol->private_value;\r\nchange = 1;\r\nhpi_handle_error(hpi_sample_clock_set_local_rate(h_control,\r\nucontrol->value.integer.value[0]));\r\nreturn change;\r\n}\r\nstatic int snd_asihpi_clkrate_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 8000;\r\nuinfo->value.integer.max = 192000;\r\nuinfo->value.integer.step = 100;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_clkrate_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nu32 h_control = kcontrol->private_value;\r\nu32 rate;\r\nu16 e;\r\ne = hpi_sample_clock_get_sample_rate(h_control, &rate);\r\nif (!e)\r\nucontrol->value.integer.value[0] = rate;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_sampleclock_add(struct snd_card_asihpi *asihpi,\r\nstruct hpi_control *hpi_ctl)\r\n{\r\nstruct snd_card *card = asihpi->card;\r\nstruct snd_kcontrol_new snd_control;\r\nstruct clk_cache *clkcache = &asihpi->cc;\r\nu32 hSC = hpi_ctl->h_control;\r\nint has_aes_in = 0;\r\nint i, j;\r\nu16 source;\r\nsnd_control.private_value = hpi_ctl->h_control;\r\nclkcache->has_local = 0;\r\nfor (i = 0; i <= HPI_SAMPLECLOCK_SOURCE_LAST; i++) {\r\nif (hpi_sample_clock_query_source(hSC,\r\ni, &source))\r\nbreak;\r\nclkcache->s[i].source = source;\r\nclkcache->s[i].index = 0;\r\nclkcache->s[i].name = sampleclock_sources[source];\r\nif (source == HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT)\r\nhas_aes_in = 1;\r\nif (source == HPI_SAMPLECLOCK_SOURCE_LOCAL)\r\nclkcache->has_local = 1;\r\n}\r\nif (has_aes_in)\r\nfor (j = 1; j < 8; j++) {\r\nif (hpi_sample_clock_query_source_index(hSC,\r\nj, HPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT,\r\n&source))\r\nbreak;\r\nclkcache->s[i].source =\r\nHPI_SAMPLECLOCK_SOURCE_AESEBU_INPUT;\r\nclkcache->s[i].index = j;\r\nclkcache->s[i].name = sampleclock_sources[\r\nj+HPI_SAMPLECLOCK_SOURCE_LAST];\r\ni++;\r\n}\r\nclkcache->count = i;\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Source");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE ;\r\nsnd_control.info = snd_asihpi_clksrc_info;\r\nsnd_control.get = snd_asihpi_clksrc_get;\r\nsnd_control.put = snd_asihpi_clksrc_put;\r\nif (ctl_add(card, &snd_control, asihpi) < 0)\r\nreturn -EINVAL;\r\nif (clkcache->has_local) {\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Localrate");\r\nsnd_control.access = SNDRV_CTL_ELEM_ACCESS_READWRITE ;\r\nsnd_control.info = snd_asihpi_clklocal_info;\r\nsnd_control.get = snd_asihpi_clklocal_get;\r\nsnd_control.put = snd_asihpi_clklocal_put;\r\nif (ctl_add(card, &snd_control, asihpi) < 0)\r\nreturn -EINVAL;\r\n}\r\nasihpi_ctl_init(&snd_control, hpi_ctl, "Rate");\r\nsnd_control.access =\r\nSNDRV_CTL_ELEM_ACCESS_VOLATILE | SNDRV_CTL_ELEM_ACCESS_READ;\r\nsnd_control.info = snd_asihpi_clkrate_info;\r\nsnd_control.get = snd_asihpi_clkrate_get;\r\nreturn ctl_add(card, &snd_control, asihpi);\r\n}\r\nstatic int snd_card_asihpi_mixer_new(struct snd_card_asihpi *asihpi)\r\n{\r\nstruct snd_card *card;\r\nunsigned int idx = 0;\r\nunsigned int subindex = 0;\r\nint err;\r\nstruct hpi_control hpi_ctl, prev_ctl;\r\nif (snd_BUG_ON(!asihpi))\r\nreturn -EINVAL;\r\ncard = asihpi->card;\r\nstrcpy(card->mixername, "Asihpi Mixer");\r\nerr =\r\nhpi_mixer_open(asihpi->hpi->adapter->index,\r\n&asihpi->h_mixer);\r\nhpi_handle_error(err);\r\nif (err)\r\nreturn -err;\r\nmemset(&prev_ctl, 0, sizeof(prev_ctl));\r\nprev_ctl.control_type = -1;\r\nfor (idx = 0; idx < 2000; idx++) {\r\nerr = hpi_mixer_get_control_by_index(\r\nasihpi->h_mixer,\r\nidx,\r\n&hpi_ctl.src_node_type,\r\n&hpi_ctl.src_node_index,\r\n&hpi_ctl.dst_node_type,\r\n&hpi_ctl.dst_node_index,\r\n&hpi_ctl.control_type,\r\n&hpi_ctl.h_control);\r\nif (err) {\r\nif (err == HPI_ERROR_CONTROL_DISABLED) {\r\nif (mixer_dump)\r\nsnd_printk(KERN_INFO\r\n"Disabled HPI Control(%d)\n",\r\nidx);\r\ncontinue;\r\n} else\r\nbreak;\r\n}\r\nhpi_ctl.src_node_type -= HPI_SOURCENODE_NONE;\r\nhpi_ctl.dst_node_type -= HPI_DESTNODE_NONE;\r\nif ((hpi_ctl.control_type == prev_ctl.control_type) &&\r\n(hpi_ctl.src_node_type == prev_ctl.src_node_type) &&\r\n(hpi_ctl.src_node_index == prev_ctl.src_node_index) &&\r\n(hpi_ctl.dst_node_type == prev_ctl.dst_node_type) &&\r\n(hpi_ctl.dst_node_index == prev_ctl.dst_node_index))\r\nsubindex++;\r\nelse\r\nsubindex = 0;\r\nprev_ctl = hpi_ctl;\r\nswitch (hpi_ctl.control_type) {\r\ncase HPI_CONTROL_VOLUME:\r\nerr = snd_asihpi_volume_add(asihpi, &hpi_ctl);\r\nbreak;\r\ncase HPI_CONTROL_LEVEL:\r\nerr = snd_asihpi_level_add(asihpi, &hpi_ctl);\r\nbreak;\r\ncase HPI_CONTROL_MULTIPLEXER:\r\nerr = snd_asihpi_mux_add(asihpi, &hpi_ctl);\r\nbreak;\r\ncase HPI_CONTROL_CHANNEL_MODE:\r\nerr = snd_asihpi_cmode_add(asihpi, &hpi_ctl);\r\nbreak;\r\ncase HPI_CONTROL_METER:\r\nerr = snd_asihpi_meter_add(asihpi, &hpi_ctl, subindex);\r\nbreak;\r\ncase HPI_CONTROL_SAMPLECLOCK:\r\nerr = snd_asihpi_sampleclock_add(\r\nasihpi, &hpi_ctl);\r\nbreak;\r\ncase HPI_CONTROL_CONNECTION:\r\ncontinue;\r\ncase HPI_CONTROL_TUNER:\r\nerr = snd_asihpi_tuner_add(asihpi, &hpi_ctl);\r\nbreak;\r\ncase HPI_CONTROL_AESEBU_TRANSMITTER:\r\nerr = snd_asihpi_aesebu_tx_add(asihpi, &hpi_ctl);\r\nbreak;\r\ncase HPI_CONTROL_AESEBU_RECEIVER:\r\nerr = snd_asihpi_aesebu_rx_add(asihpi, &hpi_ctl);\r\nbreak;\r\ncase HPI_CONTROL_VOX:\r\ncase HPI_CONTROL_BITSTREAM:\r\ncase HPI_CONTROL_MICROPHONE:\r\ncase HPI_CONTROL_PARAMETRIC_EQ:\r\ncase HPI_CONTROL_COMPANDER:\r\ndefault:\r\nif (mixer_dump)\r\nsnd_printk(KERN_INFO\r\n"Untranslated HPI Control"\r\n"(%d) %d %d %d %d %d\n",\r\nidx,\r\nhpi_ctl.control_type,\r\nhpi_ctl.src_node_type,\r\nhpi_ctl.src_node_index,\r\nhpi_ctl.dst_node_type,\r\nhpi_ctl.dst_node_index);\r\ncontinue;\r\n}\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (HPI_ERROR_INVALID_OBJ_INDEX != err)\r\nhpi_handle_error(err);\r\nsnd_printk(KERN_INFO "%d mixer controls found\n", idx);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_asihpi_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_card_asihpi *asihpi = entry->private_data;\r\nu32 h_control;\r\nu32 rate = 0;\r\nu16 source = 0;\r\nu16 num_outstreams;\r\nu16 num_instreams;\r\nu16 version;\r\nu32 serial_number;\r\nu16 type;\r\nint err;\r\nsnd_iprintf(buffer, "ASIHPI driver proc file\n");\r\nhpi_handle_error(hpi_adapter_get_info(asihpi->hpi->adapter->index,\r\n&num_outstreams, &num_instreams,\r\n&version, &serial_number, &type));\r\nsnd_iprintf(buffer,\r\n"Adapter type ASI%4X\nHardware Index %d\n"\r\n"%d outstreams\n%d instreams\n",\r\ntype, asihpi->hpi->adapter->index,\r\nnum_outstreams, num_instreams);\r\nsnd_iprintf(buffer,\r\n"Serial#%d\nHardware version %c%d\nDSP code version %03d\n",\r\nserial_number, ((version >> 3) & 0xf) + 'A', version & 0x7,\r\n((version >> 13) * 100) + ((version >> 7) & 0x3f));\r\nerr = hpi_mixer_get_control(asihpi->h_mixer,\r\nHPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\r\nHPI_CONTROL_SAMPLECLOCK, &h_control);\r\nif (!err) {\r\nerr = hpi_sample_clock_get_sample_rate(h_control, &rate);\r\nerr += hpi_sample_clock_get_source(h_control, &source);\r\nif (!err)\r\nsnd_iprintf(buffer, "Sample Clock %dHz, source %s\n",\r\nrate, sampleclock_sources[source]);\r\n}\r\n}\r\nstatic void snd_asihpi_proc_init(struct snd_card_asihpi *asihpi)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(asihpi->card, "info", &entry))\r\nsnd_info_set_text_ops(entry, asihpi, snd_asihpi_proc_read);\r\n}\r\nstatic int snd_asihpi_hpi_open(struct snd_hwdep *hw, struct file *file)\r\n{\r\nif (enable_hpi_hwdep)\r\nreturn 0;\r\nelse\r\nreturn -ENODEV;\r\n}\r\nstatic int snd_asihpi_hpi_release(struct snd_hwdep *hw, struct file *file)\r\n{\r\nif (enable_hpi_hwdep)\r\nreturn asihpi_hpi_release(file);\r\nelse\r\nreturn -ENODEV;\r\n}\r\nstatic int snd_asihpi_hpi_ioctl(struct snd_hwdep *hw, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nif (enable_hpi_hwdep)\r\nreturn asihpi_hpi_ioctl(file, cmd, arg);\r\nelse\r\nreturn -ENODEV;\r\n}\r\nstatic int snd_asihpi_hpi_new(struct snd_card_asihpi *asihpi,\r\nint device, struct snd_hwdep **rhwdep)\r\n{\r\nstruct snd_hwdep *hw;\r\nint err;\r\nif (rhwdep)\r\n*rhwdep = NULL;\r\nerr = snd_hwdep_new(asihpi->card, "HPI", device, &hw);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(hw->name, "asihpi (HPI)");\r\nhw->iface = SNDRV_HWDEP_IFACE_LAST;\r\nhw->ops.open = snd_asihpi_hpi_open;\r\nhw->ops.ioctl = snd_asihpi_hpi_ioctl;\r\nhw->ops.release = snd_asihpi_hpi_release;\r\nhw->private_data = asihpi;\r\nif (rhwdep)\r\n*rhwdep = hw;\r\nreturn 0;\r\n}\r\nstatic int snd_asihpi_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nint err;\r\nstruct hpi_adapter *hpi;\r\nstruct snd_card *card;\r\nstruct snd_card_asihpi *asihpi;\r\nu32 h_control;\r\nu32 h_stream;\r\nu32 adapter_index;\r\nstatic int dev;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = asihpi_adapter_probe(pci_dev, pci_id);\r\nif (err < 0)\r\nreturn err;\r\nhpi = pci_get_drvdata(pci_dev);\r\nadapter_index = hpi->adapter->index;\r\nerr = snd_card_new(&pci_dev->dev, adapter_index, id[adapter_index],\r\nTHIS_MODULE, sizeof(struct snd_card_asihpi), &card);\r\nif (err < 0) {\r\nerr = snd_card_new(&pci_dev->dev, index[dev], id[dev],\r\nTHIS_MODULE, sizeof(struct snd_card_asihpi),\r\n&card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_printk(KERN_WARNING\r\n"**** WARNING **** Adapter index %d->ALSA index %d\n",\r\nadapter_index, card->number);\r\n}\r\nasihpi = card->private_data;\r\nasihpi->card = card;\r\nasihpi->pci = pci_dev;\r\nasihpi->hpi = hpi;\r\nsnd_printk(KERN_INFO "adapter ID=%4X index=%d\n",\r\nasihpi->hpi->adapter->type, adapter_index);\r\nerr = hpi_adapter_get_property(adapter_index,\r\nHPI_ADAPTER_PROPERTY_CAPS1,\r\nNULL, &asihpi->support_grouping);\r\nif (err)\r\nasihpi->support_grouping = 0;\r\nerr = hpi_adapter_get_property(adapter_index,\r\nHPI_ADAPTER_PROPERTY_CAPS2,\r\n&asihpi->support_mrx, NULL);\r\nif (err)\r\nasihpi->support_mrx = 0;\r\nerr = hpi_adapter_get_property(adapter_index,\r\nHPI_ADAPTER_PROPERTY_INTERVAL,\r\nNULL, &asihpi->update_interval_frames);\r\nif (err)\r\nasihpi->update_interval_frames = 512;\r\nif (!asihpi->can_dma)\r\nasihpi->update_interval_frames *= 2;\r\nhpi_handle_error(hpi_instream_open(adapter_index,\r\n0, &h_stream));\r\nerr = hpi_instream_host_buffer_free(h_stream);\r\nasihpi->can_dma = (!err);\r\nhpi_handle_error(hpi_instream_close(h_stream));\r\nerr = hpi_adapter_get_property(adapter_index,\r\nHPI_ADAPTER_PROPERTY_CURCHANNELS,\r\n&asihpi->in_max_chans, &asihpi->out_max_chans);\r\nif (err) {\r\nasihpi->in_max_chans = 2;\r\nasihpi->out_max_chans = 2;\r\n}\r\nif (asihpi->out_max_chans > 2) {\r\nasihpi->out_min_chans = asihpi->out_max_chans;\r\nasihpi->in_min_chans = asihpi->in_max_chans;\r\nasihpi->support_grouping = 0;\r\n} else {\r\nasihpi->out_min_chans = 1;\r\nasihpi->in_min_chans = 1;\r\n}\r\nsnd_printk(KERN_INFO "Has dma:%d, grouping:%d, mrx:%d\n",\r\nasihpi->can_dma,\r\nasihpi->support_grouping,\r\nasihpi->support_mrx\r\n);\r\nerr = snd_card_asihpi_pcm_new(asihpi, 0);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "pcm_new failed\n");\r\ngoto __nodev;\r\n}\r\nerr = snd_card_asihpi_mixer_new(asihpi);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "mixer_new failed\n");\r\ngoto __nodev;\r\n}\r\nerr = hpi_mixer_get_control(asihpi->h_mixer,\r\nHPI_SOURCENODE_CLOCK_SOURCE, 0, 0, 0,\r\nHPI_CONTROL_SAMPLECLOCK, &h_control);\r\nif (!err)\r\nerr = hpi_sample_clock_set_local_rate(\r\nh_control, adapter_fs);\r\nsnd_asihpi_proc_init(asihpi);\r\nsnd_asihpi_hpi_new(asihpi, 0, NULL);\r\nstrcpy(card->driver, "ASIHPI");\r\nsprintf(card->shortname, "AudioScience ASI%4X",\r\nasihpi->hpi->adapter->type);\r\nsprintf(card->longname, "%s %i",\r\ncard->shortname, adapter_index);\r\nerr = snd_card_register(card);\r\nif (!err) {\r\nhpi->snd_card = card;\r\ndev++;\r\nreturn 0;\r\n}\r\n__nodev:\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR "snd_asihpi_probe error %d\n", err);\r\nreturn err;\r\n}\r\nstatic void snd_asihpi_remove(struct pci_dev *pci_dev)\r\n{\r\nstruct hpi_adapter *hpi = pci_get_drvdata(pci_dev);\r\nsnd_card_free(hpi->snd_card);\r\nhpi->snd_card = NULL;\r\nasihpi_adapter_remove(pci_dev);\r\n}\r\nstatic int __init snd_asihpi_init(void)\r\n{\r\nasihpi_init();\r\nreturn pci_register_driver(&driver);\r\n}\r\nstatic void __exit snd_asihpi_exit(void)\r\n{\r\npci_unregister_driver(&driver);\r\nasihpi_exit();\r\n}
