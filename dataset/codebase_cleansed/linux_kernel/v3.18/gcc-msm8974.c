static void msm8974_pro_clock_override(void)\r\n{\r\nsdcc1_apps_clk_src_init.parent_names = gcc_xo_gpll0_gpll4;\r\nsdcc1_apps_clk_src_init.num_parents = 3;\r\nsdcc1_apps_clk_src.freq_tbl = ftbl_gcc_sdcc1_apps_clk_pro;\r\nsdcc1_apps_clk_src.parent_map = gcc_xo_gpll0_gpll4_map;\r\ngcc_msm8974_clocks[GPLL4] = &gpll4.clkr;\r\ngcc_msm8974_clocks[GPLL4_VOTE] = &gpll4_vote;\r\ngcc_msm8974_clocks[GCC_SDCC1_CDCCAL_SLEEP_CLK] =\r\n&gcc_sdcc1_cdccal_sleep_clk.clkr;\r\ngcc_msm8974_clocks[GCC_SDCC1_CDCCAL_FF_CLK] =\r\n&gcc_sdcc1_cdccal_ff_clk.clkr;\r\n}\r\nstatic int gcc_msm8974_probe(struct platform_device *pdev)\r\n{\r\nstruct clk *clk;\r\nstruct device *dev = &pdev->dev;\r\nbool pro;\r\nconst struct of_device_id *id;\r\nid = of_match_device(gcc_msm8974_match_table, dev);\r\nif (!id)\r\nreturn -ENODEV;\r\npro = !!(id->data);\r\nif (pro)\r\nmsm8974_pro_clock_override();\r\nclk = clk_register_fixed_rate(dev, "xo", NULL, CLK_IS_ROOT, 19200000);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nclk = clk_register_fixed_rate(dev, "sleep_clk_src", NULL,\r\nCLK_IS_ROOT, 32768);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nreturn qcom_cc_probe(pdev, &gcc_msm8974_desc);\r\n}\r\nstatic int gcc_msm8974_remove(struct platform_device *pdev)\r\n{\r\nqcom_cc_remove(pdev);\r\nreturn 0;\r\n}\r\nstatic int __init gcc_msm8974_init(void)\r\n{\r\nreturn platform_driver_register(&gcc_msm8974_driver);\r\n}\r\nstatic void __exit gcc_msm8974_exit(void)\r\n{\r\nplatform_driver_unregister(&gcc_msm8974_driver);\r\n}
