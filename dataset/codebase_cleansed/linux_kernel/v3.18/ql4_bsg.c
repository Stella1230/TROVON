static int\r\nqla4xxx_read_flash(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nuint32_t offset = 0;\r\nuint32_t length = 0;\r\ndma_addr_t flash_dma;\r\nuint8_t *flash = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nif (ha->flash_state != QLFLASH_WAITING) {\r\nql4_printk(KERN_ERR, ha, "%s: another flash operation "\r\n"active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nha->flash_state = QLFLASH_READING;\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nlength = bsg_job->reply_payload.payload_len;\r\nflash = dma_alloc_coherent(&ha->pdev->dev, length, &flash_dma,\r\nGFP_KERNEL);\r\nif (!flash) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for flash "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nrval = qla4xxx_get_flash(ha, flash_dma, offset, length);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: get flash failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else {\r\nbsg_reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt,\r\nflash, length);\r\nbsg_reply->result = DID_OK << 16;\r\n}\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, length, flash, flash_dma);\r\nleave:\r\nha->flash_state = QLFLASH_WAITING;\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_update_flash(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nuint32_t length = 0;\r\nuint32_t offset = 0;\r\nuint32_t options = 0;\r\ndma_addr_t flash_dma;\r\nuint8_t *flash = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nif (ha->flash_state != QLFLASH_WAITING) {\r\nql4_printk(KERN_ERR, ha, "%s: another flash operation "\r\n"active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nha->flash_state = QLFLASH_WRITING;\r\nlength = bsg_job->request_payload.payload_len;\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\noptions = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nflash = dma_alloc_coherent(&ha->pdev->dev, length, &flash_dma,\r\nGFP_KERNEL);\r\nif (!flash) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for flash "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, flash, length);\r\nrval = qla4xxx_set_flash(ha, flash_dma, offset, length, options);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: set flash failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else\r\nbsg_reply->result = DID_OK << 16;\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, length, flash, flash_dma);\r\nleave:\r\nha->flash_state = QLFLASH_WAITING;\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_get_acb_state(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t status[MBOX_REG_COUNT];\r\nuint32_t acb_idx;\r\nuint32_t ip_idx;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (is_qla4010(ha))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nif (bsg_job->reply_payload.payload_len < sizeof(status)) {\r\nql4_printk(KERN_ERR, ha, "%s: invalid payload len %d\n",\r\n__func__, bsg_job->reply_payload.payload_len);\r\nrval = -EINVAL;\r\ngoto leave;\r\n}\r\nacb_idx = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nip_idx = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nrval = qla4xxx_get_ip_state(ha, acb_idx, ip_idx, status);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: get ip state failed\n",\r\n__func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else {\r\nbsg_reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt,\r\nstatus, sizeof(status));\r\nbsg_reply->result = DID_OK << 16;\r\n}\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_read_nvram(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t offset = 0;\r\nuint32_t len = 0;\r\nuint32_t total_len = 0;\r\ndma_addr_t nvram_dma;\r\nuint8_t *nvram = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (!(is_qla4010(ha) || is_qla4022(ha) || is_qla4032(ha)))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nlen = bsg_job->reply_payload.payload_len;\r\ntotal_len = offset + len;\r\nif ((is_qla4010(ha) && total_len > QL4010_NVRAM_SIZE) ||\r\n((is_qla4022(ha) || is_qla4032(ha)) &&\r\ntotal_len > QL40X2_NVRAM_SIZE)) {\r\nql4_printk(KERN_ERR, ha, "%s: offset+len greater than max"\r\n" nvram size, offset=%d len=%d\n",\r\n__func__, offset, len);\r\ngoto leave;\r\n}\r\nnvram = dma_alloc_coherent(&ha->pdev->dev, len, &nvram_dma,\r\nGFP_KERNEL);\r\nif (!nvram) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for nvram "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nrval = qla4xxx_get_nvram(ha, nvram_dma, offset, len);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: get nvram failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else {\r\nbsg_reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt,\r\nnvram, len);\r\nbsg_reply->result = DID_OK << 16;\r\n}\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, len, nvram, nvram_dma);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_update_nvram(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t offset = 0;\r\nuint32_t len = 0;\r\nuint32_t total_len = 0;\r\ndma_addr_t nvram_dma;\r\nuint8_t *nvram = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (!(is_qla4010(ha) || is_qla4022(ha) || is_qla4032(ha)))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\noffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nlen = bsg_job->request_payload.payload_len;\r\ntotal_len = offset + len;\r\nif ((is_qla4010(ha) && total_len > QL4010_NVRAM_SIZE) ||\r\n((is_qla4022(ha) || is_qla4032(ha)) &&\r\ntotal_len > QL40X2_NVRAM_SIZE)) {\r\nql4_printk(KERN_ERR, ha, "%s: offset+len greater than max"\r\n" nvram size, offset=%d len=%d\n",\r\n__func__, offset, len);\r\ngoto leave;\r\n}\r\nnvram = dma_alloc_coherent(&ha->pdev->dev, len, &nvram_dma,\r\nGFP_KERNEL);\r\nif (!nvram) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for flash "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nsg_copy_to_buffer(bsg_job->request_payload.sg_list,\r\nbsg_job->request_payload.sg_cnt, nvram, len);\r\nrval = qla4xxx_set_nvram(ha, nvram_dma, offset, len);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: set nvram failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else\r\nbsg_reply->result = DID_OK << 16;\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, len, nvram, nvram_dma);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_restore_defaults(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t region = 0;\r\nuint32_t field0 = 0;\r\nuint32_t field1 = 0;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (is_qla4010(ha))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nregion = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nfield0 = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\r\nfield1 = bsg_req->rqst_data.h_vendor.vendor_cmd[3];\r\nrval = qla4xxx_restore_factory_defaults(ha, region, field0, field1);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: set nvram failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else\r\nbsg_reply->result = DID_OK << 16;\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla4xxx_bsg_get_acb(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint32_t acb_type = 0;\r\nuint32_t len = 0;\r\ndma_addr_t acb_dma;\r\nuint8_t *acb = NULL;\r\nint rval = -EINVAL;\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\ngoto leave;\r\nif (is_qla4010(ha))\r\ngoto leave;\r\nif (ql4xxx_reset_active(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: reset active\n", __func__);\r\nrval = -EBUSY;\r\ngoto leave;\r\n}\r\nacb_type = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nlen = bsg_job->reply_payload.payload_len;\r\nif (len < sizeof(struct addr_ctrl_blk)) {\r\nql4_printk(KERN_ERR, ha, "%s: invalid acb len %d\n",\r\n__func__, len);\r\nrval = -EINVAL;\r\ngoto leave;\r\n}\r\nacb = dma_alloc_coherent(&ha->pdev->dev, len, &acb_dma, GFP_KERNEL);\r\nif (!acb) {\r\nql4_printk(KERN_ERR, ha, "%s: dma alloc failed for acb "\r\n"data\n", __func__);\r\nrval = -ENOMEM;\r\ngoto leave;\r\n}\r\nrval = qla4xxx_get_acb(ha, acb_dma, acb_type, len);\r\nif (rval) {\r\nql4_printk(KERN_ERR, ha, "%s: get acb failed\n", __func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\nrval = -EIO;\r\n} else {\r\nbsg_reply->reply_payload_rcv_len =\r\nsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\r\nbsg_job->reply_payload.sg_cnt,\r\nacb, len);\r\nbsg_reply->result = DID_OK << 16;\r\n}\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\ndma_free_coherent(&ha->pdev->dev, len, acb, acb_dma);\r\nleave:\r\nreturn rval;\r\n}\r\nstatic void ql4xxx_execute_diag_cmd(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint8_t *rsp_ptr = NULL;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint status = QLA_ERROR;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: in\n", __func__));\r\nif (test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nql4_printk(KERN_INFO, ha, "%s: Adapter reset in progress. Invalid Request\n",\r\n__func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\ngoto exit_diag_mem_test;\r\n}\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nmemcpy(mbox_cmd, &bsg_req->rqst_data.h_vendor.vendor_cmd[1],\r\nsizeof(uint32_t) * MBOX_REG_COUNT);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: mbox_cmd: %08X %08X %08X %08X %08X %08X %08X %08X\n",\r\n__func__, mbox_cmd[0], mbox_cmd[1], mbox_cmd[2],\r\nmbox_cmd[3], mbox_cmd[4], mbox_cmd[5], mbox_cmd[6],\r\nmbox_cmd[7]));\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 8, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: mbox_sts: %08X %08X %08X %08X %08X %08X %08X %08X\n",\r\n__func__, mbox_sts[0], mbox_sts[1], mbox_sts[2],\r\nmbox_sts[3], mbox_sts[4], mbox_sts[5], mbox_sts[6],\r\nmbox_sts[7]));\r\nif (status == QLA_SUCCESS)\r\nbsg_reply->result = DID_OK << 16;\r\nelse\r\nbsg_reply->result = DID_ERROR << 16;\r\nbsg_job->reply_len = sizeof(struct iscsi_bsg_reply) + sizeof(mbox_sts);\r\nrsp_ptr = ((uint8_t *)bsg_reply) + sizeof(struct iscsi_bsg_reply);\r\nmemcpy(rsp_ptr, mbox_sts, sizeof(mbox_sts));\r\nexit_diag_mem_test:\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: bsg_reply->result = x%x, status = %s\n",\r\n__func__, bsg_reply->result, STATUS(status)));\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\n}\r\nstatic int qla4_83xx_wait_for_loopback_config_comp(struct scsi_qla_host *ha,\r\nint wait_for_link)\r\n{\r\nint status = QLA_SUCCESS;\r\nif (!wait_for_completion_timeout(&ha->idc_comp, (IDC_COMP_TOV * HZ))) {\r\nql4_printk(KERN_INFO, ha, "%s: IDC Complete notification not received, Waiting for another %d timeout",\r\n__func__, ha->idc_extend_tmo);\r\nif (ha->idc_extend_tmo) {\r\nif (!wait_for_completion_timeout(&ha->idc_comp,\r\n(ha->idc_extend_tmo * HZ))) {\r\nha->notify_idc_comp = 0;\r\nha->notify_link_up_comp = 0;\r\nql4_printk(KERN_WARNING, ha, "%s: Aborting: IDC Complete notification not received",\r\n__func__);\r\nstatus = QLA_ERROR;\r\ngoto exit_wait;\r\n} else {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: IDC Complete notification received\n",\r\n__func__));\r\n}\r\n}\r\n} else {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: IDC Complete notification received\n",\r\n__func__));\r\n}\r\nha->notify_idc_comp = 0;\r\nif (wait_for_link) {\r\nif (!wait_for_completion_timeout(&ha->link_up_comp,\r\n(IDC_COMP_TOV * HZ))) {\r\nha->notify_link_up_comp = 0;\r\nql4_printk(KERN_WARNING, ha, "%s: Aborting: LINK UP notification not received",\r\n__func__);\r\nstatus = QLA_ERROR;\r\ngoto exit_wait;\r\n} else {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: LINK UP notification received\n",\r\n__func__));\r\n}\r\nha->notify_link_up_comp = 0;\r\n}\r\nexit_wait:\r\nreturn status;\r\n}\r\nstatic int qla4_83xx_pre_loopback_config(struct scsi_qla_host *ha,\r\nuint32_t *mbox_cmd)\r\n{\r\nuint32_t config = 0;\r\nint status = QLA_SUCCESS;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: in\n", __func__));\r\nstatus = qla4_83xx_get_port_config(ha, &config);\r\nif (status != QLA_SUCCESS)\r\ngoto exit_pre_loopback_config;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Default port config=%08X\n",\r\n__func__, config));\r\nif ((config & ENABLE_INTERNAL_LOOPBACK) ||\r\n(config & ENABLE_EXTERNAL_LOOPBACK)) {\r\nql4_printk(KERN_INFO, ha, "%s: Loopback diagnostics already in progress. Invalid requiest\n",\r\n__func__);\r\ngoto exit_pre_loopback_config;\r\n}\r\nif (mbox_cmd[1] == QL_DIAG_CMD_TEST_INT_LOOPBACK)\r\nconfig |= ENABLE_INTERNAL_LOOPBACK;\r\nif (mbox_cmd[1] == QL_DIAG_CMD_TEST_EXT_LOOPBACK)\r\nconfig |= ENABLE_EXTERNAL_LOOPBACK;\r\nconfig &= ~ENABLE_DCBX;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: New port config=%08X\n",\r\n__func__, config));\r\nha->notify_idc_comp = 1;\r\nha->notify_link_up_comp = 1;\r\nqla4xxx_get_firmware_state(ha);\r\nstatus = qla4_83xx_set_port_config(ha, &config);\r\nif (status != QLA_SUCCESS) {\r\nha->notify_idc_comp = 0;\r\nha->notify_link_up_comp = 0;\r\ngoto exit_pre_loopback_config;\r\n}\r\nexit_pre_loopback_config:\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: status = %s\n", __func__,\r\nSTATUS(status)));\r\nreturn status;\r\n}\r\nstatic int qla4_83xx_post_loopback_config(struct scsi_qla_host *ha,\r\nuint32_t *mbox_cmd)\r\n{\r\nint status = QLA_SUCCESS;\r\nuint32_t config = 0;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: in\n", __func__));\r\nstatus = qla4_83xx_get_port_config(ha, &config);\r\nif (status != QLA_SUCCESS)\r\ngoto exit_post_loopback_config;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: port config=%08X\n", __func__,\r\nconfig));\r\nif (mbox_cmd[1] == QL_DIAG_CMD_TEST_INT_LOOPBACK)\r\nconfig &= ~ENABLE_INTERNAL_LOOPBACK;\r\nelse if (mbox_cmd[1] == QL_DIAG_CMD_TEST_EXT_LOOPBACK)\r\nconfig &= ~ENABLE_EXTERNAL_LOOPBACK;\r\nconfig |= ENABLE_DCBX;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Restore default port config=%08X\n", __func__,\r\nconfig));\r\nha->notify_idc_comp = 1;\r\nif (ha->addl_fw_state & FW_ADDSTATE_LINK_UP)\r\nha->notify_link_up_comp = 1;\r\nstatus = qla4_83xx_set_port_config(ha, &config);\r\nif (status != QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "%s: Scheduling adapter reset\n",\r\n__func__);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nclear_bit(AF_LOOPBACK, &ha->flags);\r\ngoto exit_post_loopback_config;\r\n}\r\nexit_post_loopback_config:\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: status = %s\n", __func__,\r\nSTATUS(status)));\r\nreturn status;\r\n}\r\nstatic void qla4xxx_execute_diag_loopback_cmd(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nuint8_t *rsp_ptr = NULL;\r\nuint32_t mbox_cmd[MBOX_REG_COUNT];\r\nuint32_t mbox_sts[MBOX_REG_COUNT];\r\nint wait_for_link = 1;\r\nint status = QLA_ERROR;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: in\n", __func__));\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nif (test_bit(AF_LOOPBACK, &ha->flags)) {\r\nql4_printk(KERN_INFO, ha, "%s: Loopback Diagnostics already in progress. Invalid Request\n",\r\n__func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\ngoto exit_loopback_cmd;\r\n}\r\nif (test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\r\nql4_printk(KERN_INFO, ha, "%s: Adapter reset in progress. Invalid Request\n",\r\n__func__);\r\nbsg_reply->result = DID_ERROR << 16;\r\ngoto exit_loopback_cmd;\r\n}\r\nmemcpy(mbox_cmd, &bsg_req->rqst_data.h_vendor.vendor_cmd[1],\r\nsizeof(uint32_t) * MBOX_REG_COUNT);\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nstatus = qla4_83xx_pre_loopback_config(ha, mbox_cmd);\r\nif (status != QLA_SUCCESS) {\r\nbsg_reply->result = DID_ERROR << 16;\r\ngoto exit_loopback_cmd;\r\n}\r\nstatus = qla4_83xx_wait_for_loopback_config_comp(ha,\r\nwait_for_link);\r\nif (status != QLA_SUCCESS) {\r\nbsg_reply->result = DID_TIME_OUT << 16;\r\ngoto restore;\r\n}\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: mbox_cmd: %08X %08X %08X %08X %08X %08X %08X %08X\n",\r\n__func__, mbox_cmd[0], mbox_cmd[1], mbox_cmd[2],\r\nmbox_cmd[3], mbox_cmd[4], mbox_cmd[5], mbox_cmd[6],\r\nmbox_cmd[7]));\r\nstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 8, &mbox_cmd[0],\r\n&mbox_sts[0]);\r\nif (status == QLA_SUCCESS)\r\nbsg_reply->result = DID_OK << 16;\r\nelse\r\nbsg_reply->result = DID_ERROR << 16;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: mbox_sts: %08X %08X %08X %08X %08X %08X %08X %08X\n",\r\n__func__, mbox_sts[0], mbox_sts[1], mbox_sts[2],\r\nmbox_sts[3], mbox_sts[4], mbox_sts[5], mbox_sts[6],\r\nmbox_sts[7]));\r\nbsg_job->reply_len = sizeof(struct iscsi_bsg_reply) + sizeof(mbox_sts);\r\nrsp_ptr = ((uint8_t *)bsg_reply) + sizeof(struct iscsi_bsg_reply);\r\nmemcpy(rsp_ptr, mbox_sts, sizeof(mbox_sts));\r\nrestore:\r\nif (is_qla8032(ha) || is_qla8042(ha)) {\r\nstatus = qla4_83xx_post_loopback_config(ha, mbox_cmd);\r\nif (status != QLA_SUCCESS) {\r\nbsg_reply->result = DID_ERROR << 16;\r\ngoto exit_loopback_cmd;\r\n}\r\nif (!(ha->addl_fw_state & FW_ADDSTATE_LINK_UP))\r\nwait_for_link = 0;\r\nstatus = qla4_83xx_wait_for_loopback_config_comp(ha,\r\nwait_for_link);\r\nif (status != QLA_SUCCESS) {\r\nbsg_reply->result = DID_TIME_OUT << 16;\r\ngoto exit_loopback_cmd;\r\n}\r\n}\r\nexit_loopback_cmd:\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: bsg_reply->result = x%x, status = %s\n",\r\n__func__, bsg_reply->result, STATUS(status)));\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\n}\r\nstatic int qla4xxx_execute_diag_test(struct bsg_job *bsg_job)\r\n{\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nuint32_t diag_cmd;\r\nint rval = -EINVAL;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: in\n", __func__));\r\ndiag_cmd = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\r\nif (diag_cmd == MBOX_CMD_DIAG_TEST) {\r\nswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[2]) {\r\ncase QL_DIAG_CMD_TEST_DDR_SIZE:\r\ncase QL_DIAG_CMD_TEST_DDR_RW:\r\ncase QL_DIAG_CMD_TEST_ONCHIP_MEM_RW:\r\ncase QL_DIAG_CMD_TEST_NVRAM:\r\ncase QL_DIAG_CMD_TEST_FLASH_ROM:\r\ncase QL_DIAG_CMD_TEST_DMA_XFER:\r\ncase QL_DIAG_CMD_SELF_DDR_RW:\r\ncase QL_DIAG_CMD_SELF_ONCHIP_MEM_RW:\r\nql4xxx_execute_diag_cmd(bsg_job);\r\nrval = QLA_SUCCESS;\r\nbreak;\r\ncase QL_DIAG_CMD_TEST_INT_LOOPBACK:\r\ncase QL_DIAG_CMD_TEST_EXT_LOOPBACK:\r\nqla4xxx_execute_diag_loopback_cmd(bsg_job);\r\nrval = QLA_SUCCESS;\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "%s: Invalid diag test: 0x%x\n",\r\n__func__,\r\nbsg_req->rqst_data.h_vendor.vendor_cmd[2]);\r\n}\r\n} else if ((diag_cmd == MBOX_CMD_SET_LED_CONFIG) ||\r\n(diag_cmd == MBOX_CMD_GET_LED_CONFIG)) {\r\nql4xxx_execute_diag_cmd(bsg_job);\r\nrval = QLA_SUCCESS;\r\n} else {\r\nql4_printk(KERN_ERR, ha, "%s: Invalid diag cmd: 0x%x\n",\r\n__func__, diag_cmd);\r\n}\r\nreturn rval;\r\n}\r\nint qla4xxx_process_vendor_specific(struct bsg_job *bsg_job)\r\n{\r\nstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[0]) {\r\ncase QLISCSI_VND_READ_FLASH:\r\nreturn qla4xxx_read_flash(bsg_job);\r\ncase QLISCSI_VND_UPDATE_FLASH:\r\nreturn qla4xxx_update_flash(bsg_job);\r\ncase QLISCSI_VND_GET_ACB_STATE:\r\nreturn qla4xxx_get_acb_state(bsg_job);\r\ncase QLISCSI_VND_READ_NVRAM:\r\nreturn qla4xxx_read_nvram(bsg_job);\r\ncase QLISCSI_VND_UPDATE_NVRAM:\r\nreturn qla4xxx_update_nvram(bsg_job);\r\ncase QLISCSI_VND_RESTORE_DEFAULTS:\r\nreturn qla4xxx_restore_defaults(bsg_job);\r\ncase QLISCSI_VND_GET_ACB:\r\nreturn qla4xxx_bsg_get_acb(bsg_job);\r\ncase QLISCSI_VND_DIAG_TEST:\r\nreturn qla4xxx_execute_diag_test(bsg_job);\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "%s: invalid BSG vendor command: "\r\n"0x%x\n", __func__, bsg_req->msgcode);\r\nbsg_reply->result = (DID_ERROR << 16);\r\nbsg_reply->reply_payload_rcv_len = 0;\r\nbsg_job_done(bsg_job, bsg_reply->result,\r\nbsg_reply->reply_payload_rcv_len);\r\nreturn -ENOSYS;\r\n}\r\n}\r\nint qla4xxx_bsg_request(struct bsg_job *bsg_job)\r\n{\r\nstruct iscsi_bsg_request *bsg_req = bsg_job->request;\r\nstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\r\nstruct scsi_qla_host *ha = to_qla_host(host);\r\nswitch (bsg_req->msgcode) {\r\ncase ISCSI_BSG_HST_VENDOR:\r\nreturn qla4xxx_process_vendor_specific(bsg_job);\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "%s: invalid BSG command: 0x%x\n",\r\n__func__, bsg_req->msgcode);\r\n}\r\nreturn -ENOSYS;\r\n}
