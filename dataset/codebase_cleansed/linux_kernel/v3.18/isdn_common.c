static inline void\r\nisdn_lock_driver(isdn_driver_t *drv)\r\n{\r\ntry_module_get(drv->interface->owner);\r\ndrv->locks++;\r\n}\r\nvoid\r\nisdn_lock_drivers(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++) {\r\nif (!dev->drv[i])\r\ncontinue;\r\nisdn_lock_driver(dev->drv[i]);\r\n}\r\n}\r\nstatic inline void\r\nisdn_unlock_driver(isdn_driver_t *drv)\r\n{\r\nif (drv->locks > 0) {\r\ndrv->locks--;\r\nmodule_put(drv->interface->owner);\r\n}\r\n}\r\nvoid\r\nisdn_unlock_drivers(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++) {\r\nif (!dev->drv[i])\r\ncontinue;\r\nisdn_unlock_driver(dev->drv[i]);\r\n}\r\n}\r\nvoid\r\nisdn_dumppkt(char *s, u_char *p, int len, int dumplen)\r\n{\r\nint dumpc;\r\nprintk(KERN_DEBUG "%s(%d) ", s, len);\r\nfor (dumpc = 0; (dumpc < dumplen) && (len); len--, dumpc++)\r\nprintk(" %02x", *p++);\r\nprintk("\n");\r\n}\r\nstatic int\r\nisdn_star(char *s, char *p)\r\n{\r\nwhile (isdn_wildmat(s, p)) {\r\nif (*++s == '\0')\r\nreturn (2);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nisdn_wildmat(char *s, char *p)\r\n{\r\nregister int last;\r\nregister int matched;\r\nregister int reverse;\r\nregister int nostar = 1;\r\nif (!(*s) && !(*p))\r\nreturn (1);\r\nfor (; *p; s++, p++)\r\nswitch (*p) {\r\ncase '\\':\r\np++;\r\ndefault:\r\nif (*s != *p)\r\nreturn (*s == '\0') ? 2 : 1;\r\ncontinue;\r\ncase '?':\r\nif (*s == '\0')\r\nreturn (2);\r\ncontinue;\r\ncase '*':\r\nnostar = 0;\r\nreturn (*++p ? isdn_star(s, p) : 0);\r\ncase '[':\r\nif ((reverse = (p[1] == '^')))\r\np++;\r\nfor (last = 0, matched = 0; *++p && (*p != ']'); last = *p)\r\nif (*p == '-' ? *s <= *++p && *s >= last : *s == *p)\r\nmatched = 1;\r\nif (matched == reverse)\r\nreturn (1);\r\ncontinue;\r\n}\r\nreturn (*s == '\0') ? 0 : nostar;\r\n}\r\nint isdn_msncmp(const char *msn1, const char *msn2)\r\n{\r\nchar TmpMsn1[ISDN_MSNLEN];\r\nchar TmpMsn2[ISDN_MSNLEN];\r\nchar *p;\r\nfor (p = TmpMsn1; *msn1 && *msn1 != ':';)\r\n*p++ = *msn1++;\r\n*p = '\0';\r\nfor (p = TmpMsn2; *msn2 && *msn2 != ':';)\r\n*p++ = *msn2++;\r\n*p = '\0';\r\nreturn isdn_wildmat(TmpMsn1, TmpMsn2);\r\n}\r\nint\r\nisdn_dc2minor(int di, int ch)\r\n{\r\nint i;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nif (dev->chanmap[i] == ch && dev->drvmap[i] == di)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic void\r\nisdn_timer_funct(ulong dummy)\r\n{\r\nint tf = dev->tflags;\r\nif (tf & ISDN_TIMER_FAST) {\r\nif (tf & ISDN_TIMER_MODEMREAD)\r\nisdn_tty_readmodem();\r\nif (tf & ISDN_TIMER_MODEMPLUS)\r\nisdn_tty_modem_escape();\r\nif (tf & ISDN_TIMER_MODEMXMIT)\r\nisdn_tty_modem_xmit();\r\n}\r\nif (tf & ISDN_TIMER_SLOW) {\r\nif (++isdn_timer_cnt1 >= ISDN_TIMER_02SEC) {\r\nisdn_timer_cnt1 = 0;\r\nif (tf & ISDN_TIMER_NETDIAL)\r\nisdn_net_dial();\r\n}\r\nif (++isdn_timer_cnt2 >= ISDN_TIMER_1SEC) {\r\nisdn_timer_cnt2 = 0;\r\nif (tf & ISDN_TIMER_NETHANGUP)\r\nisdn_net_autohup();\r\nif (++isdn_timer_cnt3 >= ISDN_TIMER_RINGING) {\r\nisdn_timer_cnt3 = 0;\r\nif (tf & ISDN_TIMER_MODEMRING)\r\nisdn_tty_modem_ring();\r\n}\r\nif (tf & ISDN_TIMER_CARRIER)\r\nisdn_tty_carrier_timeout();\r\n}\r\n}\r\nif (tf)\r\nmod_timer(&dev->timer, jiffies + ISDN_TIMER_RES);\r\n}\r\nvoid\r\nisdn_timer_ctrl(int tf, int onoff)\r\n{\r\nunsigned long flags;\r\nint old_tflags;\r\nspin_lock_irqsave(&dev->timerlock, flags);\r\nif ((tf & ISDN_TIMER_SLOW) && (!(dev->tflags & ISDN_TIMER_SLOW))) {\r\nisdn_timer_cnt1 = 0;\r\nisdn_timer_cnt2 = 0;\r\n}\r\nold_tflags = dev->tflags;\r\nif (onoff)\r\ndev->tflags |= tf;\r\nelse\r\ndev->tflags &= ~tf;\r\nif (dev->tflags && !old_tflags)\r\nmod_timer(&dev->timer, jiffies + ISDN_TIMER_RES);\r\nspin_unlock_irqrestore(&dev->timerlock, flags);\r\n}\r\nstatic void\r\nisdn_receive_skb_callback(int di, int channel, struct sk_buff *skb)\r\n{\r\nint i;\r\nif ((i = isdn_dc2minor(di, channel)) == -1) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\ndev->ibytes[i] += skb->len;\r\nif (isdn_net_rcv_skb(i, skb))\r\nreturn;\r\nif (dev->v110[i]) {\r\natomic_inc(&dev->v110use[i]);\r\nskb = isdn_v110_decode(dev->v110[i], skb);\r\natomic_dec(&dev->v110use[i]);\r\nif (!skb)\r\nreturn;\r\n}\r\nif (skb->len) {\r\nif (isdn_tty_rcv_skb(i, di, channel, skb))\r\nreturn;\r\nwake_up_interruptible(&dev->drv[di]->rcv_waitq[channel]);\r\n} else\r\ndev_kfree_skb(skb);\r\n}\r\nint\r\nisdn_command(isdn_ctrl *cmd)\r\n{\r\nif (cmd->driver == -1) {\r\nprintk(KERN_WARNING "isdn_command command(%x) driver -1\n", cmd->command);\r\nreturn (1);\r\n}\r\nif (!dev->drv[cmd->driver]) {\r\nprintk(KERN_WARNING "isdn_command command(%x) dev->drv[%d] NULL\n",\r\ncmd->command, cmd->driver);\r\nreturn (1);\r\n}\r\nif (!dev->drv[cmd->driver]->interface) {\r\nprintk(KERN_WARNING "isdn_command command(%x) dev->drv[%d]->interface NULL\n",\r\ncmd->command, cmd->driver);\r\nreturn (1);\r\n}\r\nif (cmd->command == ISDN_CMD_SETL2) {\r\nint idx = isdn_dc2minor(cmd->driver, cmd->arg & 255);\r\nunsigned long l2prot = (cmd->arg >> 8) & 255;\r\nunsigned long features = (dev->drv[cmd->driver]->interface->features\r\n>> ISDN_FEATURE_L2_SHIFT) &\r\nISDN_FEATURE_L2_MASK;\r\nunsigned long l2_feature = (1 << l2prot);\r\nswitch (l2prot) {\r\ncase ISDN_PROTO_L2_V11096:\r\ncase ISDN_PROTO_L2_V11019:\r\ncase ISDN_PROTO_L2_V11038:\r\nif (!(features & l2_feature)) {\r\ndev->v110emu[idx] = l2prot;\r\ncmd->arg = (cmd->arg & 255) |\r\n(ISDN_PROTO_L2_TRANS << 8);\r\n} else\r\ndev->v110emu[idx] = 0;\r\n}\r\n}\r\nreturn dev->drv[cmd->driver]->interface->command(cmd);\r\n}\r\nvoid\r\nisdn_all_eaz(int di, int ch)\r\n{\r\nisdn_ctrl cmd;\r\nif (di < 0)\r\nreturn;\r\ncmd.driver = di;\r\ncmd.arg = ch;\r\ncmd.command = ISDN_CMD_SETEAZ;\r\ncmd.parm.num[0] = '\0';\r\nisdn_command(&cmd);\r\n}\r\nstatic int\r\nisdn_capi_rec_hl_msg(capi_msg *cm)\r\n{\r\nswitch (cm->Command) {\r\ncase CAPI_FACILITY:\r\nreturn (isdn_tty_capi_facility(cm));\r\ndefault:\r\nreturn (-1);\r\n}\r\n}\r\nstatic int\r\nisdn_status_callback(isdn_ctrl *c)\r\n{\r\nint di;\r\nu_long flags;\r\nint i;\r\nint r;\r\nint retval = 0;\r\nisdn_ctrl cmd;\r\nisdn_net_dev *p;\r\ndi = c->driver;\r\ni = isdn_dc2minor(di, c->arg);\r\nswitch (c->command) {\r\ncase ISDN_STAT_BSENT:\r\nif (i < 0)\r\nreturn -1;\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED)\r\nreturn 0;\r\nif (isdn_net_stat_callback(i, c))\r\nreturn 0;\r\nif (isdn_v110_stat_callback(i, c))\r\nreturn 0;\r\nif (isdn_tty_stat_callback(i, c))\r\nreturn 0;\r\nwake_up_interruptible(&dev->drv[di]->snd_waitq[c->arg]);\r\nbreak;\r\ncase ISDN_STAT_STAVAIL:\r\ndev->drv[di]->stavail += c->arg;\r\nwake_up_interruptible(&dev->drv[di]->st_waitq);\r\nbreak;\r\ncase ISDN_STAT_RUN:\r\ndev->drv[di]->flags |= DRV_FLAG_RUNNING;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nif (dev->drvmap[i] == di)\r\nisdn_all_eaz(di, dev->chanmap[i]);\r\nset_global_features();\r\nbreak;\r\ncase ISDN_STAT_STOP:\r\ndev->drv[di]->flags &= ~DRV_FLAG_RUNNING;\r\nbreak;\r\ncase ISDN_STAT_ICALL:\r\nif (i < 0)\r\nreturn -1;\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "ICALL (net): %d %ld %s\n", di, c->arg, c->parm.num);\r\n#endif\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED) {\r\ncmd.driver = di;\r\ncmd.arg = c->arg;\r\ncmd.command = ISDN_CMD_HANGUP;\r\nisdn_command(&cmd);\r\nreturn 0;\r\n}\r\nr = ((c->command == ISDN_STAT_ICALLW) ? 0 : isdn_net_find_icall(di, c->arg, i, &c->parm.setup));\r\nswitch (r) {\r\ncase 0:\r\nif (c->command == ISDN_STAT_ICALL)\r\nif ((retval = isdn_tty_find_icall(di, c->arg, &c->parm.setup))) return (retval);\r\n#ifdef CONFIG_ISDN_DIVERSION\r\nif (divert_if)\r\nif ((retval = divert_if->stat_callback(c)))\r\nreturn (retval);\r\n#endif\r\nif ((!retval) && (dev->drv[di]->flags & DRV_FLAG_REJBUS)) {\r\ncmd.driver = di;\r\ncmd.arg = c->arg;\r\ncmd.command = ISDN_CMD_HANGUP;\r\nisdn_command(&cmd);\r\nretval = 2;\r\n}\r\nbreak;\r\ncase 1:\r\nisdn_net_dial();\r\ncmd.driver = di;\r\ncmd.arg = c->arg;\r\ncmd.command = ISDN_CMD_ACCEPTD;\r\nfor (p = dev->netdev; p; p = p->next)\r\nif (p->local->isdn_channel == cmd.arg)\r\n{\r\nstrcpy(cmd.parm.setup.eazmsn, p->local->msn);\r\nisdn_command(&cmd);\r\nretval = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nretval = 2;\r\nprintk(KERN_INFO "isdn: Rejecting Call\n");\r\ncmd.driver = di;\r\ncmd.arg = c->arg;\r\ncmd.command = ISDN_CMD_HANGUP;\r\nisdn_command(&cmd);\r\nif (r == 3)\r\nbreak;\r\ncase 4:\r\nisdn_net_dial();\r\nbreak;\r\ncase 5:\r\nretval = 3;\r\nbreak;\r\n}\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "ICALL: ret=%d\n", retval);\r\n#endif\r\nreturn retval;\r\nbreak;\r\ncase ISDN_STAT_CINF:\r\nif (i < 0)\r\nreturn -1;\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "CINF: %ld %s\n", c->arg, c->parm.num);\r\n#endif\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED)\r\nreturn 0;\r\nif (strcmp(c->parm.num, "0"))\r\nisdn_net_stat_callback(i, c);\r\nisdn_tty_stat_callback(i, c);\r\nbreak;\r\ncase ISDN_STAT_CAUSE:\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "CAUSE: %ld %s\n", c->arg, c->parm.num);\r\n#endif\r\nprintk(KERN_INFO "isdn: %s,ch%ld cause: %s\n",\r\ndev->drvid[di], c->arg, c->parm.num);\r\nisdn_tty_stat_callback(i, c);\r\n#ifdef CONFIG_ISDN_DIVERSION\r\nif (divert_if)\r\ndivert_if->stat_callback(c);\r\n#endif\r\nbreak;\r\ncase ISDN_STAT_DISPLAY:\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "DISPLAY: %ld %s\n", c->arg, c->parm.display);\r\n#endif\r\nisdn_tty_stat_callback(i, c);\r\n#ifdef CONFIG_ISDN_DIVERSION\r\nif (divert_if)\r\ndivert_if->stat_callback(c);\r\n#endif\r\nbreak;\r\ncase ISDN_STAT_DCONN:\r\nif (i < 0)\r\nreturn -1;\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "DCONN: %ld\n", c->arg);\r\n#endif\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED)\r\nreturn 0;\r\nif (isdn_net_stat_callback(i, c))\r\nbreak;\r\nisdn_v110_stat_callback(i, c);\r\nif (isdn_tty_stat_callback(i, c)) {\r\ncmd.driver = di;\r\ncmd.arg = c->arg;\r\ncmd.command = ISDN_CMD_ACCEPTB;\r\nisdn_command(&cmd);\r\nbreak;\r\n}\r\nbreak;\r\ncase ISDN_STAT_DHUP:\r\nif (i < 0)\r\nreturn -1;\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "DHUP: %ld\n", c->arg);\r\n#endif\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED)\r\nreturn 0;\r\ndev->drv[di]->online &= ~(1 << (c->arg));\r\nisdn_info_update();\r\nif (isdn_net_stat_callback(i, c))\r\nbreak;\r\nisdn_v110_stat_callback(i, c);\r\nif (isdn_tty_stat_callback(i, c))\r\nbreak;\r\n#ifdef CONFIG_ISDN_DIVERSION\r\nif (divert_if)\r\ndivert_if->stat_callback(c);\r\n#endif\r\nbreak;\r\nbreak;\r\ncase ISDN_STAT_BCONN:\r\nif (i < 0)\r\nreturn -1;\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "BCONN: %ld\n", c->arg);\r\n#endif\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED)\r\nreturn 0;\r\ndev->drv[di]->online |= (1 << (c->arg));\r\nisdn_info_update();\r\nif (isdn_net_stat_callback(i, c))\r\nbreak;\r\nisdn_v110_stat_callback(i, c);\r\nif (isdn_tty_stat_callback(i, c))\r\nbreak;\r\nbreak;\r\ncase ISDN_STAT_BHUP:\r\nif (i < 0)\r\nreturn -1;\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "BHUP: %ld\n", c->arg);\r\n#endif\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED)\r\nreturn 0;\r\ndev->drv[di]->online &= ~(1 << (c->arg));\r\nisdn_info_update();\r\n#ifdef CONFIG_ISDN_X25\r\nif (isdn_net_stat_callback(i, c))\r\nbreak;\r\n#endif\r\nisdn_v110_stat_callback(i, c);\r\nif (isdn_tty_stat_callback(i, c))\r\nbreak;\r\nbreak;\r\ncase ISDN_STAT_NODCH:\r\nif (i < 0)\r\nreturn -1;\r\n#ifdef ISDN_DEBUG_STATCALLB\r\nprintk(KERN_DEBUG "NODCH: %ld\n", c->arg);\r\n#endif\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED)\r\nreturn 0;\r\nif (isdn_net_stat_callback(i, c))\r\nbreak;\r\nif (isdn_tty_stat_callback(i, c))\r\nbreak;\r\nbreak;\r\ncase ISDN_STAT_ADDCH:\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (isdn_add_channels(dev->drv[di], di, c->arg, 1)) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn -1;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_info_update();\r\nbreak;\r\ncase ISDN_STAT_DISCH:\r\nspin_lock_irqsave(&dev->lock, flags);\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nif ((dev->drvmap[i] == di) &&\r\n(dev->chanmap[i] == c->arg)) {\r\nif (c->parm.num[0])\r\ndev->usage[i] &= ~ISDN_USAGE_DISABLED;\r\nelse\r\nif (USG_NONE(dev->usage[i])) {\r\ndev->usage[i] |= ISDN_USAGE_DISABLED;\r\n}\r\nelse\r\nretval = -1;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_info_update();\r\nbreak;\r\ncase ISDN_STAT_UNLOAD:\r\nwhile (dev->drv[di]->locks > 0) {\r\nisdn_unlock_driver(dev->drv[di]);\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\nisdn_tty_stat_callback(i, c);\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nif (dev->drvmap[i] == di) {\r\ndev->drvmap[i] = -1;\r\ndev->chanmap[i] = -1;\r\ndev->usage[i] &= ~ISDN_USAGE_DISABLED;\r\n}\r\ndev->drivers--;\r\ndev->channels -= dev->drv[di]->channels;\r\nkfree(dev->drv[di]->rcverr);\r\nkfree(dev->drv[di]->rcvcount);\r\nfor (i = 0; i < dev->drv[di]->channels; i++)\r\nskb_queue_purge(&dev->drv[di]->rpqueue[i]);\r\nkfree(dev->drv[di]->rpqueue);\r\nkfree(dev->drv[di]->rcv_waitq);\r\nkfree(dev->drv[di]);\r\ndev->drv[di] = NULL;\r\ndev->drvid[di][0] = '\0';\r\nisdn_info_update();\r\nset_global_features();\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\ncase ISDN_STAT_L1ERR:\r\nbreak;\r\ncase CAPI_PUT_MESSAGE:\r\nreturn (isdn_capi_rec_hl_msg(&c->parm.cmsg));\r\n#ifdef CONFIG_ISDN_TTY_FAX\r\ncase ISDN_STAT_FAXIND:\r\nisdn_tty_stat_callback(i, c);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ISDN_AUDIO\r\ncase ISDN_STAT_AUDIO:\r\nisdn_tty_stat_callback(i, c);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_ISDN_DIVERSION\r\ncase ISDN_STAT_PROT:\r\ncase ISDN_STAT_REDIR:\r\nif (divert_if)\r\nreturn (divert_if->stat_callback(c));\r\n#endif\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nisdn_getnum(char **p)\r\n{\r\nint v = -1;\r\nwhile (*p[0] >= '0' && *p[0] <= '9')\r\nv = ((v < 0) ? 0 : (v * 10)) + (int) ((*p[0]++) - '0');\r\nreturn v;\r\n}\r\nint\r\nisdn_readbchan(int di, int channel, u_char *buf, u_char *fp, int len, wait_queue_head_t *sleep)\r\n{\r\nint count;\r\nint count_pull;\r\nint count_put;\r\nint dflag;\r\nstruct sk_buff *skb;\r\nu_char *cp;\r\nif (!dev->drv[di])\r\nreturn 0;\r\nif (skb_queue_empty(&dev->drv[di]->rpqueue[channel])) {\r\nif (sleep)\r\nwait_event_interruptible(*sleep,\r\n!skb_queue_empty(&dev->drv[di]->rpqueue[channel]));\r\nelse\r\nreturn 0;\r\n}\r\nif (len > dev->drv[di]->rcvcount[channel])\r\nlen = dev->drv[di]->rcvcount[channel];\r\ncp = buf;\r\ncount = 0;\r\nwhile (len) {\r\nif (!(skb = skb_peek(&dev->drv[di]->rpqueue[channel])))\r\nbreak;\r\n#ifdef CONFIG_ISDN_AUDIO\r\nif (ISDN_AUDIO_SKB_LOCK(skb))\r\nbreak;\r\nISDN_AUDIO_SKB_LOCK(skb) = 1;\r\nif ((ISDN_AUDIO_SKB_DLECOUNT(skb)) || (dev->drv[di]->DLEflag & (1 << channel))) {\r\nchar *p = skb->data;\r\nunsigned long DLEmask = (1 << channel);\r\ndflag = 0;\r\ncount_pull = count_put = 0;\r\nwhile ((count_pull < skb->len) && (len > 0)) {\r\nlen--;\r\nif (dev->drv[di]->DLEflag & DLEmask) {\r\n*cp++ = DLE;\r\ndev->drv[di]->DLEflag &= ~DLEmask;\r\n} else {\r\n*cp++ = *p;\r\nif (*p == DLE) {\r\ndev->drv[di]->DLEflag |= DLEmask;\r\n(ISDN_AUDIO_SKB_DLECOUNT(skb))--;\r\n}\r\np++;\r\ncount_pull++;\r\n}\r\ncount_put++;\r\n}\r\nif (count_pull >= skb->len)\r\ndflag = 1;\r\n} else {\r\n#endif\r\ndflag = 1;\r\nif ((count_pull = skb->len) > len) {\r\ncount_pull = len;\r\ndflag = 0;\r\n}\r\ncount_put = count_pull;\r\nskb_copy_from_linear_data(skb, cp, count_put);\r\ncp += count_put;\r\nlen -= count_put;\r\n#ifdef CONFIG_ISDN_AUDIO\r\n}\r\n#endif\r\ncount += count_put;\r\nif (fp) {\r\nmemset(fp, 0, count_put);\r\nfp += count_put;\r\n}\r\nif (dflag) {\r\nif (fp)\r\n*(fp - 1) = 0xff;\r\n#ifdef CONFIG_ISDN_AUDIO\r\nISDN_AUDIO_SKB_LOCK(skb) = 0;\r\n#endif\r\nskb = skb_dequeue(&dev->drv[di]->rpqueue[channel]);\r\ndev_kfree_skb(skb);\r\n} else {\r\nskb_pull(skb, count_pull);\r\n#ifdef CONFIG_ISDN_AUDIO\r\nISDN_AUDIO_SKB_LOCK(skb) = 0;\r\n#endif\r\n}\r\ndev->drv[di]->rcvcount[channel] -= count_put;\r\n}\r\nreturn count;\r\n}\r\nint\r\nisdn_readbchan_tty(int di, int channel, struct tty_port *port, int cisco_hack)\r\n{\r\nint count;\r\nint count_pull;\r\nint count_put;\r\nint dflag;\r\nstruct sk_buff *skb;\r\nchar last = 0;\r\nint len;\r\nif (!dev->drv[di])\r\nreturn 0;\r\nif (skb_queue_empty(&dev->drv[di]->rpqueue[channel]))\r\nreturn 0;\r\nlen = tty_buffer_request_room(port, dev->drv[di]->rcvcount[channel]);\r\nif (len == 0)\r\nreturn len;\r\ncount = 0;\r\nwhile (len) {\r\nif (!(skb = skb_peek(&dev->drv[di]->rpqueue[channel])))\r\nbreak;\r\n#ifdef CONFIG_ISDN_AUDIO\r\nif (ISDN_AUDIO_SKB_LOCK(skb))\r\nbreak;\r\nISDN_AUDIO_SKB_LOCK(skb) = 1;\r\nif ((ISDN_AUDIO_SKB_DLECOUNT(skb)) || (dev->drv[di]->DLEflag & (1 << channel))) {\r\nchar *p = skb->data;\r\nunsigned long DLEmask = (1 << channel);\r\ndflag = 0;\r\ncount_pull = count_put = 0;\r\nwhile ((count_pull < skb->len) && (len > 0)) {\r\nif (count_put)\r\ntty_insert_flip_char(port, last, TTY_NORMAL);\r\nlen--;\r\nif (dev->drv[di]->DLEflag & DLEmask) {\r\nlast = DLE;\r\ndev->drv[di]->DLEflag &= ~DLEmask;\r\n} else {\r\nlast = *p;\r\nif (last == DLE) {\r\ndev->drv[di]->DLEflag |= DLEmask;\r\n(ISDN_AUDIO_SKB_DLECOUNT(skb))--;\r\n}\r\np++;\r\ncount_pull++;\r\n}\r\ncount_put++;\r\n}\r\nif (count_pull >= skb->len)\r\ndflag = 1;\r\n} else {\r\n#endif\r\ndflag = 1;\r\nif ((count_pull = skb->len) > len) {\r\ncount_pull = len;\r\ndflag = 0;\r\n}\r\ncount_put = count_pull;\r\nif (count_put > 1)\r\ntty_insert_flip_string(port, skb->data, count_put - 1);\r\nlast = skb->data[count_put - 1];\r\nlen -= count_put;\r\n#ifdef CONFIG_ISDN_AUDIO\r\n}\r\n#endif\r\ncount += count_put;\r\nif (dflag) {\r\nif (cisco_hack)\r\ntty_insert_flip_char(port, last, 0xFF);\r\nelse\r\ntty_insert_flip_char(port, last, TTY_NORMAL);\r\n#ifdef CONFIG_ISDN_AUDIO\r\nISDN_AUDIO_SKB_LOCK(skb) = 0;\r\n#endif\r\nskb = skb_dequeue(&dev->drv[di]->rpqueue[channel]);\r\ndev_kfree_skb(skb);\r\n} else {\r\ntty_insert_flip_char(port, last, TTY_NORMAL);\r\nskb_pull(skb, count_pull);\r\n#ifdef CONFIG_ISDN_AUDIO\r\nISDN_AUDIO_SKB_LOCK(skb) = 0;\r\n#endif\r\n}\r\ndev->drv[di]->rcvcount[channel] -= count_put;\r\n}\r\nreturn count;\r\n}\r\nstatic inline int\r\nisdn_minor2drv(int minor)\r\n{\r\nreturn (dev->drvmap[minor]);\r\n}\r\nstatic inline int\r\nisdn_minor2chan(int minor)\r\n{\r\nreturn (dev->chanmap[minor]);\r\n}\r\nstatic char *\r\nisdn_statstr(void)\r\n{\r\nstatic char istatbuf[2048];\r\nchar *p;\r\nint i;\r\nsprintf(istatbuf, "idmap:\t");\r\np = istatbuf + strlen(istatbuf);\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nsprintf(p, "%s ", (dev->drvmap[i] < 0) ? "-" : dev->drvid[dev->drvmap[i]]);\r\np = istatbuf + strlen(istatbuf);\r\n}\r\nsprintf(p, "\nchmap:\t");\r\np = istatbuf + strlen(istatbuf);\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nsprintf(p, "%d ", dev->chanmap[i]);\r\np = istatbuf + strlen(istatbuf);\r\n}\r\nsprintf(p, "\ndrmap:\t");\r\np = istatbuf + strlen(istatbuf);\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nsprintf(p, "%d ", dev->drvmap[i]);\r\np = istatbuf + strlen(istatbuf);\r\n}\r\nsprintf(p, "\nusage:\t");\r\np = istatbuf + strlen(istatbuf);\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nsprintf(p, "%d ", dev->usage[i]);\r\np = istatbuf + strlen(istatbuf);\r\n}\r\nsprintf(p, "\nflags:\t");\r\np = istatbuf + strlen(istatbuf);\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++) {\r\nif (dev->drv[i]) {\r\nsprintf(p, "%ld ", dev->drv[i]->online);\r\np = istatbuf + strlen(istatbuf);\r\n} else {\r\nsprintf(p, "? ");\r\np = istatbuf + strlen(istatbuf);\r\n}\r\n}\r\nsprintf(p, "\nphone:\t");\r\np = istatbuf + strlen(istatbuf);\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nsprintf(p, "%s ", dev->num[i]);\r\np = istatbuf + strlen(istatbuf);\r\n}\r\nsprintf(p, "\n");\r\nreturn istatbuf;\r\n}\r\nvoid\r\nisdn_info_update(void)\r\n{\r\ninfostruct *p = dev->infochain;\r\nwhile (p) {\r\n*(p->private) = 1;\r\np = (infostruct *) p->next;\r\n}\r\nwake_up_interruptible(&(dev->info_waitq));\r\n}\r\nstatic ssize_t\r\nisdn_read(struct file *file, char __user *buf, size_t count, loff_t *off)\r\n{\r\nuint minor = iminor(file_inode(file));\r\nint len = 0;\r\nint drvidx;\r\nint chidx;\r\nint retval;\r\nchar *p;\r\nmutex_lock(&isdn_mutex);\r\nif (minor == ISDN_MINOR_STATUS) {\r\nif (!file->private_data) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto out;\r\n}\r\nwait_event_interruptible(dev->info_waitq,\r\nfile->private_data);\r\n}\r\np = isdn_statstr();\r\nfile->private_data = NULL;\r\nif ((len = strlen(p)) <= count) {\r\nif (copy_to_user(buf, p, len)) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\n*off += len;\r\nretval = len;\r\ngoto out;\r\n}\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (!dev->drivers) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (minor <= ISDN_MINOR_BMAX) {\r\nprintk(KERN_WARNING "isdn_read minor %d obsolete!\n", minor);\r\ndrvidx = isdn_minor2drv(minor);\r\nif (drvidx < 0) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING)) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nchidx = isdn_minor2chan(minor);\r\nif (!(p = kmalloc(count, GFP_KERNEL))) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nlen = isdn_readbchan(drvidx, chidx, p, NULL, count,\r\n&dev->drv[drvidx]->rcv_waitq[chidx]);\r\n*off += len;\r\nif (copy_to_user(buf, p, len))\r\nlen = -EFAULT;\r\nkfree(p);\r\nretval = len;\r\ngoto out;\r\n}\r\nif (minor <= ISDN_MINOR_CTRLMAX) {\r\ndrvidx = isdn_minor2drv(minor - ISDN_MINOR_CTRL);\r\nif (drvidx < 0) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (!dev->drv[drvidx]->stavail) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto out;\r\n}\r\nwait_event_interruptible(dev->drv[drvidx]->st_waitq,\r\ndev->drv[drvidx]->stavail);\r\n}\r\nif (dev->drv[drvidx]->interface->readstat) {\r\nif (count > dev->drv[drvidx]->stavail)\r\ncount = dev->drv[drvidx]->stavail;\r\nlen = dev->drv[drvidx]->interface->readstat(buf, count,\r\ndrvidx, isdn_minor2chan(minor - ISDN_MINOR_CTRL));\r\nif (len < 0) {\r\nretval = len;\r\ngoto out;\r\n}\r\n} else {\r\nlen = 0;\r\n}\r\nif (len)\r\ndev->drv[drvidx]->stavail -= len;\r\nelse\r\ndev->drv[drvidx]->stavail = 0;\r\n*off += len;\r\nretval = len;\r\ngoto out;\r\n}\r\n#ifdef CONFIG_ISDN_PPP\r\nif (minor <= ISDN_MINOR_PPPMAX) {\r\nretval = isdn_ppp_read(minor - ISDN_MINOR_PPP, file, buf, count);\r\ngoto out;\r\n}\r\n#endif\r\nretval = -ENODEV;\r\nout:\r\nmutex_unlock(&isdn_mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t\r\nisdn_write(struct file *file, const char __user *buf, size_t count, loff_t *off)\r\n{\r\nuint minor = iminor(file_inode(file));\r\nint drvidx;\r\nint chidx;\r\nint retval;\r\nif (minor == ISDN_MINOR_STATUS)\r\nreturn -EPERM;\r\nif (!dev->drivers)\r\nreturn -ENODEV;\r\nmutex_lock(&isdn_mutex);\r\nif (minor <= ISDN_MINOR_BMAX) {\r\nprintk(KERN_WARNING "isdn_write minor %d obsolete!\n", minor);\r\ndrvidx = isdn_minor2drv(minor);\r\nif (drvidx < 0) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING)) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nchidx = isdn_minor2chan(minor);\r\nwait_event_interruptible(dev->drv[drvidx]->snd_waitq[chidx],\r\n(retval = isdn_writebuf_stub(drvidx, chidx, buf, count)));\r\ngoto out;\r\n}\r\nif (minor <= ISDN_MINOR_CTRLMAX) {\r\ndrvidx = isdn_minor2drv(minor - ISDN_MINOR_CTRL);\r\nif (drvidx < 0) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (dev->drv[drvidx]->interface->writecmd)\r\nretval = dev->drv[drvidx]->interface->\r\nwritecmd(buf, count, drvidx,\r\nisdn_minor2chan(minor - ISDN_MINOR_CTRL));\r\nelse\r\nretval = count;\r\ngoto out;\r\n}\r\n#ifdef CONFIG_ISDN_PPP\r\nif (minor <= ISDN_MINOR_PPPMAX) {\r\nretval = isdn_ppp_write(minor - ISDN_MINOR_PPP, file, buf, count);\r\ngoto out;\r\n}\r\n#endif\r\nretval = -ENODEV;\r\nout:\r\nmutex_unlock(&isdn_mutex);\r\nreturn retval;\r\n}\r\nstatic unsigned int\r\nisdn_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\nunsigned int minor = iminor(file_inode(file));\r\nint drvidx = isdn_minor2drv(minor - ISDN_MINOR_CTRL);\r\nmutex_lock(&isdn_mutex);\r\nif (minor == ISDN_MINOR_STATUS) {\r\npoll_wait(file, &(dev->info_waitq), wait);\r\nif (file->private_data) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\ngoto out;\r\n}\r\nif (minor >= ISDN_MINOR_CTRL && minor <= ISDN_MINOR_CTRLMAX) {\r\nif (drvidx < 0) {\r\nmask = POLLHUP;\r\ngoto out;\r\n}\r\npoll_wait(file, &(dev->drv[drvidx]->st_waitq), wait);\r\nmask = POLLOUT | POLLWRNORM;\r\nif (dev->drv[drvidx]->stavail) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\ngoto out;\r\n}\r\n#ifdef CONFIG_ISDN_PPP\r\nif (minor <= ISDN_MINOR_PPPMAX) {\r\nmask = isdn_ppp_poll(file, wait);\r\ngoto out;\r\n}\r\n#endif\r\nmask = POLLERR;\r\nout:\r\nmutex_unlock(&isdn_mutex);\r\nreturn mask;\r\n}\r\nstatic int\r\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\r\n{\r\nuint minor = iminor(file_inode(file));\r\nisdn_ctrl c;\r\nint drvidx;\r\nint ret;\r\nint i;\r\nchar __user *p;\r\nchar *s;\r\nunion iocpar {\r\nchar name[10];\r\nchar bname[22];\r\nisdn_ioctl_struct iocts;\r\nisdn_net_ioctl_phone phone;\r\nisdn_net_ioctl_cfg cfg;\r\n} iocpar;\r\nvoid __user *argp = (void __user *)arg;\r\n#define name iocpar.name\r\n#define bname iocpar.bname\r\n#define iocts iocpar.iocts\r\n#define phone iocpar.phone\r\n#define cfg iocpar.cfg\r\nif (minor == ISDN_MINOR_STATUS) {\r\nswitch (cmd) {\r\ncase IIOCGETDVR:\r\nreturn (TTY_DV +\r\n(NET_DV << 8) +\r\n(INF_DV << 16));\r\ncase IIOCGETCPS:\r\nif (arg) {\r\nulong __user *p = argp;\r\nint i;\r\nif (!access_ok(VERIFY_WRITE, p,\r\nsizeof(ulong) * ISDN_MAX_CHANNELS * 2))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nput_user(dev->ibytes[i], p++);\r\nput_user(dev->obytes[i], p++);\r\n}\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase IIOCNETGPN:\r\nif (arg) {\r\nif (copy_from_user(&phone, argp, sizeof(phone)))\r\nreturn -EFAULT;\r\nreturn isdn_net_getpeer(&phone, argp);\r\n} else\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!dev->drivers)\r\nreturn -ENODEV;\r\nif (minor <= ISDN_MINOR_BMAX) {\r\ndrvidx = isdn_minor2drv(minor);\r\nif (drvidx < 0)\r\nreturn -ENODEV;\r\nif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nif (minor <= ISDN_MINOR_CTRLMAX) {\r\nswitch (cmd) {\r\ncase IIOCNETDWRSET:\r\nprintk(KERN_INFO "INFO: ISDN_DW_ABC_EXTENSION not enabled\n");\r\nreturn (-EINVAL);\r\ncase IIOCNETLCR:\r\nprintk(KERN_INFO "INFO: ISDN_ABC_LCR_SUPPORT not enabled\n");\r\nreturn -ENODEV;\r\ncase IIOCNETAIF:\r\nif (arg) {\r\nif (copy_from_user(name, argp, sizeof(name)))\r\nreturn -EFAULT;\r\ns = name;\r\n} else {\r\ns = NULL;\r\n}\r\nret = mutex_lock_interruptible(&dev->mtx);\r\nif (ret) return ret;\r\nif ((s = isdn_net_new(s, NULL))) {\r\nif (copy_to_user(argp, s, strlen(s) + 1)) {\r\nret = -EFAULT;\r\n} else {\r\nret = 0;\r\n}\r\n} else\r\nret = -ENODEV;\r\nmutex_unlock(&dev->mtx);\r\nreturn ret;\r\ncase IIOCNETASL:\r\nif (arg) {\r\nif (copy_from_user(bname, argp, sizeof(bname) - 1))\r\nreturn -EFAULT;\r\n} else\r\nreturn -EINVAL;\r\nret = mutex_lock_interruptible(&dev->mtx);\r\nif (ret) return ret;\r\nif ((s = isdn_net_newslave(bname))) {\r\nif (copy_to_user(argp, s, strlen(s) + 1)) {\r\nret = -EFAULT;\r\n} else {\r\nret = 0;\r\n}\r\n} else\r\nret = -ENODEV;\r\nmutex_unlock(&dev->mtx);\r\nreturn ret;\r\ncase IIOCNETDIF:\r\nif (arg) {\r\nif (copy_from_user(name, argp, sizeof(name)))\r\nreturn -EFAULT;\r\nret = mutex_lock_interruptible(&dev->mtx);\r\nif (ret) return ret;\r\nret = isdn_net_rm(name);\r\nmutex_unlock(&dev->mtx);\r\nreturn ret;\r\n} else\r\nreturn -EINVAL;\r\ncase IIOCNETSCF:\r\nif (arg) {\r\nif (copy_from_user(&cfg, argp, sizeof(cfg)))\r\nreturn -EFAULT;\r\nreturn isdn_net_setcfg(&cfg);\r\n} else\r\nreturn -EINVAL;\r\ncase IIOCNETGCF:\r\nif (arg) {\r\nif (copy_from_user(&cfg, argp, sizeof(cfg)))\r\nreturn -EFAULT;\r\nif (!(ret = isdn_net_getcfg(&cfg))) {\r\nif (copy_to_user(argp, &cfg, sizeof(cfg)))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n} else\r\nreturn -EINVAL;\r\ncase IIOCNETANM:\r\nif (arg) {\r\nif (copy_from_user(&phone, argp, sizeof(phone)))\r\nreturn -EFAULT;\r\nret = mutex_lock_interruptible(&dev->mtx);\r\nif (ret) return ret;\r\nret = isdn_net_addphone(&phone);\r\nmutex_unlock(&dev->mtx);\r\nreturn ret;\r\n} else\r\nreturn -EINVAL;\r\ncase IIOCNETGNM:\r\nif (arg) {\r\nif (copy_from_user(&phone, argp, sizeof(phone)))\r\nreturn -EFAULT;\r\nret = mutex_lock_interruptible(&dev->mtx);\r\nif (ret) return ret;\r\nret = isdn_net_getphones(&phone, argp);\r\nmutex_unlock(&dev->mtx);\r\nreturn ret;\r\n} else\r\nreturn -EINVAL;\r\ncase IIOCNETDNM:\r\nif (arg) {\r\nif (copy_from_user(&phone, argp, sizeof(phone)))\r\nreturn -EFAULT;\r\nret = mutex_lock_interruptible(&dev->mtx);\r\nif (ret) return ret;\r\nret = isdn_net_delphone(&phone);\r\nmutex_unlock(&dev->mtx);\r\nreturn ret;\r\n} else\r\nreturn -EINVAL;\r\ncase IIOCNETDIL:\r\nif (arg) {\r\nif (copy_from_user(name, argp, sizeof(name)))\r\nreturn -EFAULT;\r\nreturn isdn_net_force_dial(name);\r\n} else\r\nreturn -EINVAL;\r\n#ifdef CONFIG_ISDN_PPP\r\ncase IIOCNETALN:\r\nif (!arg)\r\nreturn -EINVAL;\r\nif (copy_from_user(name, argp, sizeof(name)))\r\nreturn -EFAULT;\r\nreturn isdn_ppp_dial_slave(name);\r\ncase IIOCNETDLN:\r\nif (!arg)\r\nreturn -EINVAL;\r\nif (copy_from_user(name, argp, sizeof(name)))\r\nreturn -EFAULT;\r\nreturn isdn_ppp_hangup_slave(name);\r\n#endif\r\ncase IIOCNETHUP:\r\nif (!arg)\r\nreturn -EINVAL;\r\nif (copy_from_user(name, argp, sizeof(name)))\r\nreturn -EFAULT;\r\nreturn isdn_net_force_hangup(name);\r\nbreak;\r\ncase IIOCSETVER:\r\ndev->net_verbose = arg;\r\nprintk(KERN_INFO "isdn: Verbose-Level is %d\n", dev->net_verbose);\r\nreturn 0;\r\ncase IIOCSETGST:\r\nif (arg)\r\ndev->global_flags |= ISDN_GLOBAL_STOPPED;\r\nelse\r\ndev->global_flags &= ~ISDN_GLOBAL_STOPPED;\r\nprintk(KERN_INFO "isdn: Global Mode %s\n",\r\n(dev->global_flags & ISDN_GLOBAL_STOPPED) ? "stopped" : "running");\r\nreturn 0;\r\ncase IIOCSETBRJ:\r\ndrvidx = -1;\r\nif (arg) {\r\nint i;\r\nchar *p;\r\nif (copy_from_user(&iocts, argp,\r\nsizeof(isdn_ioctl_struct)))\r\nreturn -EFAULT;\r\niocts.drvid[sizeof(iocts.drvid) - 1] = 0;\r\nif (strlen(iocts.drvid)) {\r\nif ((p = strchr(iocts.drvid, ',')))\r\n*p = 0;\r\ndrvidx = -1;\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\r\nif (!(strcmp(dev->drvid[i], iocts.drvid))) {\r\ndrvidx = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (drvidx == -1)\r\nreturn -ENODEV;\r\nif (iocts.arg)\r\ndev->drv[drvidx]->flags |= DRV_FLAG_REJBUS;\r\nelse\r\ndev->drv[drvidx]->flags &= ~DRV_FLAG_REJBUS;\r\nreturn 0;\r\ncase IIOCSIGPRF:\r\ndev->profd = current;\r\nreturn 0;\r\nbreak;\r\ncase IIOCGETPRF:\r\nif (arg) {\r\nchar __user *p = argp;\r\nint i;\r\nif (!access_ok(VERIFY_WRITE, argp,\r\n(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\r\n* ISDN_MAX_CHANNELS))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nif (copy_to_user(p, dev->mdm.info[i].emu.profile,\r\nISDN_MODEM_NUMREG))\r\nreturn -EFAULT;\r\np += ISDN_MODEM_NUMREG;\r\nif (copy_to_user(p, dev->mdm.info[i].emu.pmsn, ISDN_MSNLEN))\r\nreturn -EFAULT;\r\np += ISDN_MSNLEN;\r\nif (copy_to_user(p, dev->mdm.info[i].emu.plmsn, ISDN_LMSNLEN))\r\nreturn -EFAULT;\r\np += ISDN_LMSNLEN;\r\n}\r\nreturn (ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN) * ISDN_MAX_CHANNELS;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase IIOCSETPRF:\r\nif (arg) {\r\nchar __user *p = argp;\r\nint i;\r\nif (!access_ok(VERIFY_READ, argp,\r\n(ISDN_MODEM_NUMREG + ISDN_MSNLEN + ISDN_LMSNLEN)\r\n* ISDN_MAX_CHANNELS))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\nif (copy_from_user(dev->mdm.info[i].emu.profile, p,\r\nISDN_MODEM_NUMREG))\r\nreturn -EFAULT;\r\np += ISDN_MODEM_NUMREG;\r\nif (copy_from_user(dev->mdm.info[i].emu.plmsn, p, ISDN_LMSNLEN))\r\nreturn -EFAULT;\r\np += ISDN_LMSNLEN;\r\nif (copy_from_user(dev->mdm.info[i].emu.pmsn, p, ISDN_MSNLEN))\r\nreturn -EFAULT;\r\np += ISDN_MSNLEN;\r\n}\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase IIOCSETMAP:\r\ncase IIOCGETMAP:\r\nif (arg) {\r\nif (copy_from_user(&iocts, argp,\r\nsizeof(isdn_ioctl_struct)))\r\nreturn -EFAULT;\r\niocts.drvid[sizeof(iocts.drvid) - 1] = 0;\r\nif (strlen(iocts.drvid)) {\r\ndrvidx = -1;\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\r\nif (!(strcmp(dev->drvid[i], iocts.drvid))) {\r\ndrvidx = i;\r\nbreak;\r\n}\r\n} else\r\ndrvidx = 0;\r\nif (drvidx == -1)\r\nreturn -ENODEV;\r\nif (cmd == IIOCSETMAP) {\r\nint loop = 1;\r\np = (char __user *) iocts.arg;\r\ni = 0;\r\nwhile (loop) {\r\nint j = 0;\r\nwhile (1) {\r\nif (!access_ok(VERIFY_READ, p, 1))\r\nreturn -EFAULT;\r\nget_user(bname[j], p++);\r\nswitch (bname[j]) {\r\ncase '\0':\r\nloop = 0;\r\ncase ',':\r\nbname[j] = '\0';\r\nstrcpy(dev->drv[drvidx]->msn2eaz[i], bname);\r\nj = ISDN_MSNLEN;\r\nbreak;\r\ndefault:\r\nj++;\r\n}\r\nif (j >= ISDN_MSNLEN)\r\nbreak;\r\n}\r\nif (++i > 9)\r\nbreak;\r\n}\r\n} else {\r\np = (char __user *) iocts.arg;\r\nfor (i = 0; i < 10; i++) {\r\nsnprintf(bname, sizeof(bname), "%s%s",\r\nstrlen(dev->drv[drvidx]->msn2eaz[i]) ?\r\ndev->drv[drvidx]->msn2eaz[i] : "_",\r\n(i < 9) ? "," : "\0");\r\nif (copy_to_user(p, bname, strlen(bname) + 1))\r\nreturn -EFAULT;\r\np += strlen(bname);\r\n}\r\n}\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\ncase IIOCDBGVAR:\r\nif (arg) {\r\nif (copy_to_user(argp, &dev, sizeof(ulong)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nif ((cmd & IIOCDRVCTL) == IIOCDRVCTL)\r\ncmd = ((cmd >> _IOC_NRSHIFT) & _IOC_NRMASK) & ISDN_DRVIOCTL_MASK;\r\nelse\r\nreturn -EINVAL;\r\nif (arg) {\r\nint i;\r\nchar *p;\r\nif (copy_from_user(&iocts, argp, sizeof(isdn_ioctl_struct)))\r\nreturn -EFAULT;\r\niocts.drvid[sizeof(iocts.drvid) - 1] = 0;\r\nif (strlen(iocts.drvid)) {\r\nif ((p = strchr(iocts.drvid, ',')))\r\n*p = 0;\r\ndrvidx = -1;\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\r\nif (!(strcmp(dev->drvid[i], iocts.drvid))) {\r\ndrvidx = i;\r\nbreak;\r\n}\r\n} else\r\ndrvidx = 0;\r\nif (drvidx == -1)\r\nreturn -ENODEV;\r\nif (!access_ok(VERIFY_WRITE, argp,\r\nsizeof(isdn_ioctl_struct)))\r\nreturn -EFAULT;\r\nc.driver = drvidx;\r\nc.command = ISDN_CMD_IOCTL;\r\nc.arg = cmd;\r\nmemcpy(c.parm.num, &iocts.arg, sizeof(ulong));\r\nret = isdn_command(&c);\r\nmemcpy(&iocts.arg, c.parm.num, sizeof(ulong));\r\nif (copy_to_user(argp, &iocts, sizeof(isdn_ioctl_struct)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n} else\r\nreturn -EINVAL;\r\n}\r\n}\r\n#ifdef CONFIG_ISDN_PPP\r\nif (minor <= ISDN_MINOR_PPPMAX)\r\nreturn (isdn_ppp_ioctl(minor - ISDN_MINOR_PPP, file, cmd, arg));\r\n#endif\r\nreturn -ENODEV;\r\n#undef name\r\n#undef bname\r\n#undef iocts\r\n#undef phone\r\n#undef cfg\r\n}\r\nstatic long\r\nisdn_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&isdn_mutex);\r\nret = isdn_ioctl(file, cmd, arg);\r\nmutex_unlock(&isdn_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nisdn_open(struct inode *ino, struct file *filep)\r\n{\r\nuint minor = iminor(ino);\r\nint drvidx;\r\nint chidx;\r\nint retval = -ENODEV;\r\nmutex_lock(&isdn_mutex);\r\nif (minor == ISDN_MINOR_STATUS) {\r\ninfostruct *p;\r\nif ((p = kmalloc(sizeof(infostruct), GFP_KERNEL))) {\r\np->next = (char *) dev->infochain;\r\np->private = (char *) &(filep->private_data);\r\ndev->infochain = p;\r\nfilep->private_data = (char *) 1;\r\nretval = 0;\r\ngoto out;\r\n} else {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nif (!dev->channels)\r\ngoto out;\r\nif (minor <= ISDN_MINOR_BMAX) {\r\nprintk(KERN_WARNING "isdn_open minor %d obsolete!\n", minor);\r\ndrvidx = isdn_minor2drv(minor);\r\nif (drvidx < 0)\r\ngoto out;\r\nchidx = isdn_minor2chan(minor);\r\nif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\r\ngoto out;\r\nif (!(dev->drv[drvidx]->online & (1 << chidx)))\r\ngoto out;\r\nisdn_lock_drivers();\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (minor <= ISDN_MINOR_CTRLMAX) {\r\ndrvidx = isdn_minor2drv(minor - ISDN_MINOR_CTRL);\r\nif (drvidx < 0)\r\ngoto out;\r\nisdn_lock_drivers();\r\nretval = 0;\r\ngoto out;\r\n}\r\n#ifdef CONFIG_ISDN_PPP\r\nif (minor <= ISDN_MINOR_PPPMAX) {\r\nretval = isdn_ppp_open(minor - ISDN_MINOR_PPP, filep);\r\nif (retval == 0)\r\nisdn_lock_drivers();\r\ngoto out;\r\n}\r\n#endif\r\nout:\r\nnonseekable_open(ino, filep);\r\nmutex_unlock(&isdn_mutex);\r\nreturn retval;\r\n}\r\nstatic int\r\nisdn_close(struct inode *ino, struct file *filep)\r\n{\r\nuint minor = iminor(ino);\r\nmutex_lock(&isdn_mutex);\r\nif (minor == ISDN_MINOR_STATUS) {\r\ninfostruct *p = dev->infochain;\r\ninfostruct *q = NULL;\r\nwhile (p) {\r\nif (p->private == (char *) &(filep->private_data)) {\r\nif (q)\r\nq->next = p->next;\r\nelse\r\ndev->infochain = (infostruct *) (p->next);\r\nkfree(p);\r\ngoto out;\r\n}\r\nq = p;\r\np = (infostruct *) (p->next);\r\n}\r\nprintk(KERN_WARNING "isdn: No private data while closing isdnctrl\n");\r\ngoto out;\r\n}\r\nisdn_unlock_drivers();\r\nif (minor <= ISDN_MINOR_BMAX)\r\ngoto out;\r\nif (minor <= ISDN_MINOR_CTRLMAX) {\r\nif (dev->profd == current)\r\ndev->profd = NULL;\r\ngoto out;\r\n}\r\n#ifdef CONFIG_ISDN_PPP\r\nif (minor <= ISDN_MINOR_PPPMAX)\r\nisdn_ppp_release(minor - ISDN_MINOR_PPP, filep);\r\n#endif\r\nout:\r\nmutex_unlock(&isdn_mutex);\r\nreturn 0;\r\n}\r\nchar *\r\nisdn_map_eaz2msn(char *msn, int di)\r\n{\r\nisdn_driver_t *this = dev->drv[di];\r\nint i;\r\nif (strlen(msn) == 1) {\r\ni = msn[0] - '0';\r\nif ((i >= 0) && (i <= 9))\r\nif (strlen(this->msn2eaz[i]))\r\nreturn (this->msn2eaz[i]);\r\n}\r\nreturn (msn);\r\n}\r\nint\r\nisdn_get_free_channel(int usage, int l2_proto, int l3_proto, int pre_dev\r\n, int pre_chan, char *msn)\r\n{\r\nint i;\r\nulong features;\r\nulong vfeatures;\r\nfeatures = ((1 << l2_proto) | (0x10000 << l3_proto));\r\nvfeatures = (((1 << l2_proto) | (0x10000 << l3_proto)) &\r\n~(ISDN_FEATURE_L2_V11096 | ISDN_FEATURE_L2_V11019 | ISDN_FEATURE_L2_V11038));\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nif (USG_NONE(dev->usage[i]) &&\r\n(dev->drvmap[i] != -1)) {\r\nint d = dev->drvmap[i];\r\nif ((dev->usage[i] & ISDN_USAGE_EXCLUSIVE) &&\r\n((pre_dev != d) || (pre_chan != dev->chanmap[i])))\r\ncontinue;\r\nif (!strcmp(isdn_map_eaz2msn(msn, d), "-"))\r\ncontinue;\r\nif (dev->usage[i] & ISDN_USAGE_DISABLED)\r\ncontinue;\r\nif (dev->drv[d]->flags & DRV_FLAG_RUNNING) {\r\nif (((dev->drv[d]->interface->features & features) == features) ||\r\n(((dev->drv[d]->interface->features & vfeatures) == vfeatures) &&\r\n(dev->drv[d]->interface->features & ISDN_FEATURE_L2_TRANS))) {\r\nif ((pre_dev < 0) || (pre_chan < 0)) {\r\ndev->usage[i] &= ISDN_USAGE_EXCLUSIVE;\r\ndev->usage[i] |= usage;\r\nisdn_info_update();\r\nreturn i;\r\n} else {\r\nif ((pre_dev == d) && (pre_chan == dev->chanmap[i])) {\r\ndev->usage[i] &= ISDN_USAGE_EXCLUSIVE;\r\ndev->usage[i] |= usage;\r\nisdn_info_update();\r\nreturn i;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn -1;\r\n}\r\nvoid\r\nisdn_free_channel(int di, int ch, int usage)\r\n{\r\nint i;\r\nif ((di < 0) || (ch < 0)) {\r\nprintk(KERN_WARNING "%s: called with invalid drv(%d) or channel(%d)\n",\r\n__func__, di, ch);\r\nreturn;\r\n}\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nif (((!usage) || ((dev->usage[i] & ISDN_USAGE_MASK) == usage)) &&\r\n(dev->drvmap[i] == di) &&\r\n(dev->chanmap[i] == ch)) {\r\ndev->usage[i] &= (ISDN_USAGE_NONE | ISDN_USAGE_EXCLUSIVE);\r\nstrcpy(dev->num[i], "???");\r\ndev->ibytes[i] = 0;\r\ndev->obytes[i] = 0;\r\ndev->v110emu[i] = 0;\r\natomic_set(&(dev->v110use[i]), 0);\r\nisdn_v110_close(dev->v110[i]);\r\ndev->v110[i] = NULL;\r\nisdn_info_update();\r\nif (dev->drv[di])\r\nskb_queue_purge(&dev->drv[di]->rpqueue[ch]);\r\n}\r\n}\r\nvoid\r\nisdn_unexclusive_channel(int di, int ch)\r\n{\r\nint i;\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\r\nif ((dev->drvmap[i] == di) &&\r\n(dev->chanmap[i] == ch)) {\r\ndev->usage[i] &= ~ISDN_USAGE_EXCLUSIVE;\r\nisdn_info_update();\r\nreturn;\r\n}\r\n}\r\nstatic int\r\nisdn_writebuf_stub(int drvidx, int chan, const u_char __user *buf, int len)\r\n{\r\nint ret;\r\nint hl = dev->drv[drvidx]->interface->hl_hdrlen;\r\nstruct sk_buff *skb = alloc_skb(hl + len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, hl);\r\nif (copy_from_user(skb_put(skb, len), buf, len)) {\r\ndev_kfree_skb(skb);\r\nreturn -EFAULT;\r\n}\r\nret = dev->drv[drvidx]->interface->writebuf_skb(drvidx, chan, 1, skb);\r\nif (ret <= 0)\r\ndev_kfree_skb(skb);\r\nif (ret > 0)\r\ndev->obytes[isdn_dc2minor(drvidx, chan)] += ret;\r\nreturn ret;\r\n}\r\nint\r\nisdn_writebuf_skb_stub(int drvidx, int chan, int ack, struct sk_buff *skb)\r\n{\r\nint ret;\r\nstruct sk_buff *nskb = NULL;\r\nint v110_ret = skb->len;\r\nint idx = isdn_dc2minor(drvidx, chan);\r\nif (dev->v110[idx]) {\r\natomic_inc(&dev->v110use[idx]);\r\nnskb = isdn_v110_encode(dev->v110[idx], skb);\r\natomic_dec(&dev->v110use[idx]);\r\nif (!nskb)\r\nreturn 0;\r\nv110_ret = *((int *)nskb->data);\r\nskb_pull(nskb, sizeof(int));\r\nif (!nskb->len) {\r\ndev_kfree_skb(nskb);\r\nreturn v110_ret;\r\n}\r\nack = 1;\r\nret = dev->drv[drvidx]->interface->writebuf_skb(drvidx, chan, ack, nskb);\r\n} else {\r\nint hl = dev->drv[drvidx]->interface->hl_hdrlen;\r\nif (skb_headroom(skb) < hl) {\r\nstruct sk_buff *skb_tmp;\r\nskb_tmp = skb_realloc_headroom(skb, hl);\r\nprintk(KERN_DEBUG "isdn_writebuf_skb_stub: reallocating headroom%s\n", skb_tmp ? "" : " failed");\r\nif (!skb_tmp) return -ENOMEM;\r\nret = dev->drv[drvidx]->interface->writebuf_skb(drvidx, chan, ack, skb_tmp);\r\nif (ret > 0) {\r\ndev_kfree_skb(skb);\r\n} else {\r\ndev_kfree_skb(skb_tmp);\r\n}\r\n} else {\r\nret = dev->drv[drvidx]->interface->writebuf_skb(drvidx, chan, ack, skb);\r\n}\r\n}\r\nif (ret > 0) {\r\ndev->obytes[idx] += ret;\r\nif (dev->v110[idx]) {\r\natomic_inc(&dev->v110use[idx]);\r\ndev->v110[idx]->skbuser++;\r\natomic_dec(&dev->v110use[idx]);\r\nret = v110_ret;\r\nif (ret == skb->len)\r\ndev_kfree_skb(skb);\r\n}\r\n} else\r\nif (dev->v110[idx])\r\ndev_kfree_skb(nskb);\r\nreturn ret;\r\n}\r\nstatic int\r\nisdn_add_channels(isdn_driver_t *d, int drvidx, int n, int adding)\r\n{\r\nint j, k, m;\r\ninit_waitqueue_head(&d->st_waitq);\r\nif (d->flags & DRV_FLAG_RUNNING)\r\nreturn -1;\r\nif (n < 1) return 0;\r\nm = (adding) ? d->channels + n : n;\r\nif (dev->channels + n > ISDN_MAX_CHANNELS) {\r\nprintk(KERN_WARNING "register_isdn: Max. %d channels supported\n",\r\nISDN_MAX_CHANNELS);\r\nreturn -1;\r\n}\r\nif ((adding) && (d->rcverr))\r\nkfree(d->rcverr);\r\nif (!(d->rcverr = kzalloc(sizeof(int) * m, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING "register_isdn: Could not alloc rcverr\n");\r\nreturn -1;\r\n}\r\nif ((adding) && (d->rcvcount))\r\nkfree(d->rcvcount);\r\nif (!(d->rcvcount = kzalloc(sizeof(int) * m, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING "register_isdn: Could not alloc rcvcount\n");\r\nif (!adding)\r\nkfree(d->rcverr);\r\nreturn -1;\r\n}\r\nif ((adding) && (d->rpqueue)) {\r\nfor (j = 0; j < d->channels; j++)\r\nskb_queue_purge(&d->rpqueue[j]);\r\nkfree(d->rpqueue);\r\n}\r\nif (!(d->rpqueue = kmalloc(sizeof(struct sk_buff_head) * m, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING "register_isdn: Could not alloc rpqueue\n");\r\nif (!adding) {\r\nkfree(d->rcvcount);\r\nkfree(d->rcverr);\r\n}\r\nreturn -1;\r\n}\r\nfor (j = 0; j < m; j++) {\r\nskb_queue_head_init(&d->rpqueue[j]);\r\n}\r\nif ((adding) && (d->rcv_waitq))\r\nkfree(d->rcv_waitq);\r\nd->rcv_waitq = kmalloc(sizeof(wait_queue_head_t) * 2 * m, GFP_ATOMIC);\r\nif (!d->rcv_waitq) {\r\nprintk(KERN_WARNING "register_isdn: Could not alloc rcv_waitq\n");\r\nif (!adding) {\r\nkfree(d->rpqueue);\r\nkfree(d->rcvcount);\r\nkfree(d->rcverr);\r\n}\r\nreturn -1;\r\n}\r\nd->snd_waitq = d->rcv_waitq + m;\r\nfor (j = 0; j < m; j++) {\r\ninit_waitqueue_head(&d->rcv_waitq[j]);\r\ninit_waitqueue_head(&d->snd_waitq[j]);\r\n}\r\ndev->channels += n;\r\nfor (j = d->channels; j < m; j++)\r\nfor (k = 0; k < ISDN_MAX_CHANNELS; k++)\r\nif (dev->chanmap[k] < 0) {\r\ndev->chanmap[k] = j;\r\ndev->drvmap[k] = drvidx;\r\nbreak;\r\n}\r\nd->channels = m;\r\nreturn 0;\r\n}\r\nstatic void\r\nset_global_features(void)\r\n{\r\nint drvidx;\r\ndev->global_features = 0;\r\nfor (drvidx = 0; drvidx < ISDN_MAX_DRIVERS; drvidx++) {\r\nif (!dev->drv[drvidx])\r\ncontinue;\r\nif (dev->drv[drvidx]->interface)\r\ndev->global_features |= dev->drv[drvidx]->interface->features;\r\n}\r\n}\r\nstatic char *map_drvname(int di)\r\n{\r\nif ((di < 0) || (di >= ISDN_MAX_DRIVERS))\r\nreturn (NULL);\r\nreturn (dev->drvid[di]);\r\n}\r\nstatic int map_namedrv(char *id)\r\n{ int i;\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\r\n{ if (!strcmp(dev->drvid[i], id))\r\nreturn (i);\r\n}\r\nreturn (-1);\r\n}\r\nint DIVERT_REG_NAME(isdn_divert_if *i_div)\r\n{\r\nif (i_div->if_magic != DIVERT_IF_MAGIC)\r\nreturn (DIVERT_VER_ERR);\r\nswitch (i_div->cmd)\r\n{\r\ncase DIVERT_CMD_REL:\r\nif (divert_if != i_div)\r\nreturn (DIVERT_REL_ERR);\r\ndivert_if = NULL;\r\nreturn (DIVERT_NO_ERR);\r\ncase DIVERT_CMD_REG:\r\nif (divert_if)\r\nreturn (DIVERT_REG_ERR);\r\ni_div->ll_cmd = isdn_command;\r\ni_div->drv_to_name = map_drvname;\r\ni_div->name_to_drv = map_namedrv;\r\ndivert_if = i_div;\r\nreturn (DIVERT_NO_ERR);\r\ndefault:\r\nreturn (DIVERT_CMD_ERR);\r\n}\r\n}\r\nint\r\nregister_isdn(isdn_if *i)\r\n{\r\nisdn_driver_t *d;\r\nint j;\r\nulong flags;\r\nint drvidx;\r\nif (dev->drivers >= ISDN_MAX_DRIVERS) {\r\nprintk(KERN_WARNING "register_isdn: Max. %d drivers supported\n",\r\nISDN_MAX_DRIVERS);\r\nreturn 0;\r\n}\r\nif (!i->writebuf_skb) {\r\nprintk(KERN_WARNING "register_isdn: No write routine given.\n");\r\nreturn 0;\r\n}\r\nif (!(d = kzalloc(sizeof(isdn_driver_t), GFP_KERNEL))) {\r\nprintk(KERN_WARNING "register_isdn: Could not alloc driver-struct\n");\r\nreturn 0;\r\n}\r\nd->maxbufsize = i->maxbufsize;\r\nd->pktcount = 0;\r\nd->stavail = 0;\r\nd->flags = DRV_FLAG_LOADED;\r\nd->online = 0;\r\nd->interface = i;\r\nd->channels = 0;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nfor (drvidx = 0; drvidx < ISDN_MAX_DRIVERS; drvidx++)\r\nif (!dev->drv[drvidx])\r\nbreak;\r\nif (isdn_add_channels(d, drvidx, i->channels, 0)) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nkfree(d);\r\nreturn 0;\r\n}\r\ni->channels = drvidx;\r\ni->rcvcallb_skb = isdn_receive_skb_callback;\r\ni->statcallb = isdn_status_callback;\r\nif (!strlen(i->id))\r\nsprintf(i->id, "line%d", drvidx);\r\nfor (j = 0; j < drvidx; j++)\r\nif (!strcmp(i->id, dev->drvid[j]))\r\nsprintf(i->id, "line%d", drvidx);\r\ndev->drv[drvidx] = d;\r\nstrcpy(dev->drvid[drvidx], i->id);\r\nisdn_info_update();\r\ndev->drivers++;\r\nset_global_features();\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 1;\r\n}\r\nstatic char *\r\nisdn_getrev(const char *revision)\r\n{\r\nchar *rev;\r\nchar *p;\r\nif ((p = strchr(revision, ':'))) {\r\nrev = p + 2;\r\np = strchr(rev, '$');\r\n*--p = 0;\r\n} else\r\nrev = "???";\r\nreturn rev;\r\n}\r\nstatic int __init isdn_init(void)\r\n{\r\nint i;\r\nchar tmprev[50];\r\ndev = vzalloc(sizeof(isdn_dev));\r\nif (!dev) {\r\nprintk(KERN_WARNING "isdn: Could not allocate device-struct.\n");\r\nreturn -EIO;\r\n}\r\ninit_timer(&dev->timer);\r\ndev->timer.function = isdn_timer_funct;\r\nspin_lock_init(&dev->lock);\r\nspin_lock_init(&dev->timerlock);\r\n#ifdef MODULE\r\ndev->owner = THIS_MODULE;\r\n#endif\r\nmutex_init(&dev->mtx);\r\ninit_waitqueue_head(&dev->info_waitq);\r\nfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\r\ndev->drvmap[i] = -1;\r\ndev->chanmap[i] = -1;\r\ndev->m_idx[i] = -1;\r\nstrcpy(dev->num[i], "???");\r\n}\r\nif (register_chrdev(ISDN_MAJOR, "isdn", &isdn_fops)) {\r\nprintk(KERN_WARNING "isdn: Could not register control devices\n");\r\nvfree(dev);\r\nreturn -EIO;\r\n}\r\nif ((isdn_tty_modem_init()) < 0) {\r\nprintk(KERN_WARNING "isdn: Could not register tty devices\n");\r\nvfree(dev);\r\nunregister_chrdev(ISDN_MAJOR, "isdn");\r\nreturn -EIO;\r\n}\r\n#ifdef CONFIG_ISDN_PPP\r\nif (isdn_ppp_init() < 0) {\r\nprintk(KERN_WARNING "isdn: Could not create PPP-device-structs\n");\r\nisdn_tty_exit();\r\nunregister_chrdev(ISDN_MAJOR, "isdn");\r\nvfree(dev);\r\nreturn -EIO;\r\n}\r\n#endif\r\nstrcpy(tmprev, isdn_revision);\r\nprintk(KERN_NOTICE "ISDN subsystem Rev: %s/", isdn_getrev(tmprev));\r\nstrcpy(tmprev, isdn_net_revision);\r\nprintk("%s/", isdn_getrev(tmprev));\r\nstrcpy(tmprev, isdn_ppp_revision);\r\nprintk("%s/", isdn_getrev(tmprev));\r\nstrcpy(tmprev, isdn_audio_revision);\r\nprintk("%s/", isdn_getrev(tmprev));\r\nstrcpy(tmprev, isdn_v110_revision);\r\nprintk("%s", isdn_getrev(tmprev));\r\n#ifdef MODULE\r\nprintk(" loaded\n");\r\n#else\r\nprintk("\n");\r\n#endif\r\nisdn_info_update();\r\nreturn 0;\r\n}\r\nstatic void __exit isdn_exit(void)\r\n{\r\n#ifdef CONFIG_ISDN_PPP\r\nisdn_ppp_cleanup();\r\n#endif\r\nif (isdn_net_rmall() < 0) {\r\nprintk(KERN_WARNING "isdn: net-device busy, remove cancelled\n");\r\nreturn;\r\n}\r\nisdn_tty_exit();\r\nunregister_chrdev(ISDN_MAJOR, "isdn");\r\ndel_timer_sync(&dev->timer);\r\nvfree(dev);\r\nprintk(KERN_NOTICE "ISDN-subsystem unloaded\n");\r\n}
