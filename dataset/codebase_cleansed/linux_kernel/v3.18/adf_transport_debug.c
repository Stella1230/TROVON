static void *adf_ring_start(struct seq_file *sfile, loff_t *pos)\r\n{\r\nstruct adf_etr_ring_data *ring = sfile->private;\r\nmutex_lock(&ring_read_lock);\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nif (*pos >= (ADF_SIZE_TO_RING_SIZE_IN_BYTES(ring->ring_size) /\r\nADF_MSG_SIZE_TO_BYTES(ring->msg_size)))\r\nreturn NULL;\r\nreturn ring->base_addr +\r\n(ADF_MSG_SIZE_TO_BYTES(ring->msg_size) * (*pos)++);\r\n}\r\nstatic void *adf_ring_next(struct seq_file *sfile, void *v, loff_t *pos)\r\n{\r\nstruct adf_etr_ring_data *ring = sfile->private;\r\nif (*pos >= (ADF_SIZE_TO_RING_SIZE_IN_BYTES(ring->ring_size) /\r\nADF_MSG_SIZE_TO_BYTES(ring->msg_size)))\r\nreturn NULL;\r\nreturn ring->base_addr +\r\n(ADF_MSG_SIZE_TO_BYTES(ring->msg_size) * (*pos)++);\r\n}\r\nstatic int adf_ring_show(struct seq_file *sfile, void *v)\r\n{\r\nstruct adf_etr_ring_data *ring = sfile->private;\r\nstruct adf_etr_bank_data *bank = ring->bank;\r\nuint32_t *msg = v;\r\nvoid __iomem *csr = ring->bank->csr_addr;\r\nint i, x;\r\nif (v == SEQ_START_TOKEN) {\r\nint head, tail, empty;\r\nhead = READ_CSR_RING_HEAD(csr, bank->bank_number,\r\nring->ring_number);\r\ntail = READ_CSR_RING_TAIL(csr, bank->bank_number,\r\nring->ring_number);\r\nempty = READ_CSR_E_STAT(csr, bank->bank_number);\r\nseq_puts(sfile, "------- Ring configuration -------\n");\r\nseq_printf(sfile, "ring num %d, bank num %d\n",\r\nring->ring_number, ring->bank->bank_number);\r\nseq_printf(sfile, "head %x, tail %x, empty: %d\n",\r\nhead, tail, (empty & 1 << ring->ring_number)\r\n>> ring->ring_number);\r\nseq_printf(sfile, "ring size %d, msg size %d\n",\r\nADF_SIZE_TO_RING_SIZE_IN_BYTES(ring->ring_size),\r\nADF_MSG_SIZE_TO_BYTES(ring->msg_size));\r\nseq_puts(sfile, "----------- Ring data ------------\n");\r\nreturn 0;\r\n}\r\nseq_printf(sfile, "%p:", msg);\r\nx = 0;\r\ni = 0;\r\nfor (; i < (ADF_MSG_SIZE_TO_BYTES(ring->msg_size) >> 2); i++) {\r\nseq_printf(sfile, " %08X", *(msg + i));\r\nif ((ADF_MSG_SIZE_TO_BYTES(ring->msg_size) >> 2) != i + 1 &&\r\n(++x == 8)) {\r\nseq_printf(sfile, "\n%p:", msg + i + 1);\r\nx = 0;\r\n}\r\n}\r\nseq_puts(sfile, "\n");\r\nreturn 0;\r\n}\r\nstatic void adf_ring_stop(struct seq_file *sfile, void *v)\r\n{\r\nmutex_unlock(&ring_read_lock);\r\n}\r\nstatic int adf_ring_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &adf_ring_sops);\r\nif (!ret) {\r\nstruct seq_file *seq_f = file->private_data;\r\nseq_f->private = inode->i_private;\r\n}\r\nreturn ret;\r\n}\r\nint adf_ring_debugfs_add(struct adf_etr_ring_data *ring, const char *name)\r\n{\r\nstruct adf_etr_ring_debug_entry *ring_debug;\r\nchar entry_name[8];\r\nring_debug = kzalloc(sizeof(*ring_debug), GFP_KERNEL);\r\nif (!ring_debug)\r\nreturn -ENOMEM;\r\nstrlcpy(ring_debug->ring_name, name, sizeof(ring_debug->ring_name));\r\nsnprintf(entry_name, sizeof(entry_name), "ring_%02d",\r\nring->ring_number);\r\nring_debug->debug = debugfs_create_file(entry_name, S_IRUSR,\r\nring->bank->bank_debug_dir,\r\nring, &adf_ring_debug_fops);\r\nif (!ring_debug->debug) {\r\npr_err("QAT: Failed to create ring debug entry.\n");\r\nkfree(ring_debug);\r\nreturn -EFAULT;\r\n}\r\nring->ring_debug = ring_debug;\r\nreturn 0;\r\n}\r\nvoid adf_ring_debugfs_rm(struct adf_etr_ring_data *ring)\r\n{\r\nif (ring->ring_debug) {\r\ndebugfs_remove(ring->ring_debug->debug);\r\nkfree(ring->ring_debug);\r\nring->ring_debug = NULL;\r\n}\r\n}\r\nstatic void *adf_bank_start(struct seq_file *sfile, loff_t *pos)\r\n{\r\nmutex_lock(&bank_read_lock);\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nif (*pos >= ADF_ETR_MAX_RINGS_PER_BANK)\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic void *adf_bank_next(struct seq_file *sfile, void *v, loff_t *pos)\r\n{\r\nif (++(*pos) >= ADF_ETR_MAX_RINGS_PER_BANK)\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic int adf_bank_show(struct seq_file *sfile, void *v)\r\n{\r\nstruct adf_etr_bank_data *bank = sfile->private;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(sfile, "------- Bank %d configuration -------\n",\r\nbank->bank_number);\r\n} else {\r\nint ring_id = *((int *)v) - 1;\r\nstruct adf_etr_ring_data *ring = &bank->rings[ring_id];\r\nvoid __iomem *csr = bank->csr_addr;\r\nint head, tail, empty;\r\nif (!(bank->ring_mask & 1 << ring_id))\r\nreturn 0;\r\nhead = READ_CSR_RING_HEAD(csr, bank->bank_number,\r\nring->ring_number);\r\ntail = READ_CSR_RING_TAIL(csr, bank->bank_number,\r\nring->ring_number);\r\nempty = READ_CSR_E_STAT(csr, bank->bank_number);\r\nseq_printf(sfile,\r\n"ring num %02d, head %04x, tail %04x, empty: %d\n",\r\nring->ring_number, head, tail,\r\n(empty & 1 << ring->ring_number) >>\r\nring->ring_number);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adf_bank_stop(struct seq_file *sfile, void *v)\r\n{\r\nmutex_unlock(&bank_read_lock);\r\n}\r\nstatic int adf_bank_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open(file, &adf_bank_sops);\r\nif (!ret) {\r\nstruct seq_file *seq_f = file->private_data;\r\nseq_f->private = inode->i_private;\r\n}\r\nreturn ret;\r\n}\r\nint adf_bank_debugfs_add(struct adf_etr_bank_data *bank)\r\n{\r\nstruct adf_accel_dev *accel_dev = bank->accel_dev;\r\nstruct dentry *parent = accel_dev->transport->debug;\r\nchar name[8];\r\nsnprintf(name, sizeof(name), "bank_%02d", bank->bank_number);\r\nbank->bank_debug_dir = debugfs_create_dir(name, parent);\r\nif (!bank->bank_debug_dir) {\r\npr_err("QAT: Failed to create bank debug dir.\n");\r\nreturn -EFAULT;\r\n}\r\nbank->bank_debug_cfg = debugfs_create_file("config", S_IRUSR,\r\nbank->bank_debug_dir, bank,\r\n&adf_bank_debug_fops);\r\nif (!bank->bank_debug_cfg) {\r\npr_err("QAT: Failed to create bank debug entry.\n");\r\ndebugfs_remove(bank->bank_debug_dir);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid adf_bank_debugfs_rm(struct adf_etr_bank_data *bank)\r\n{\r\ndebugfs_remove(bank->bank_debug_cfg);\r\ndebugfs_remove(bank->bank_debug_dir);\r\n}
