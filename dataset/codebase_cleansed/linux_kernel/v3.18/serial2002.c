static long serial2002_tty_ioctl(struct file *f, unsigned op,\r\nunsigned long param)\r\n{\r\nif (f->f_op->unlocked_ioctl)\r\nreturn f->f_op->unlocked_ioctl(f, op, param);\r\nreturn -ENOSYS;\r\n}\r\nstatic int serial2002_tty_write(struct file *f, unsigned char *buf, int count)\r\n{\r\nconst char __user *p = (__force const char __user *)buf;\r\nint result;\r\nmm_segment_t oldfs;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nf->f_pos = 0;\r\nresult = f->f_op->write(f, p, count, &f->f_pos);\r\nset_fs(oldfs);\r\nreturn result;\r\n}\r\nstatic int serial2002_tty_readb(struct file *f, unsigned char *buf)\r\n{\r\nchar __user *p = (__force char __user *)buf;\r\nf->f_pos = 0;\r\nreturn f->f_op->read(f, p, 1, &f->f_pos);\r\n}\r\nstatic void serial2002_tty_read_poll_wait(struct file *f, int timeout)\r\n{\r\nstruct poll_wqueues table;\r\nstruct timeval start, now;\r\ndo_gettimeofday(&start);\r\npoll_initwait(&table);\r\nwhile (1) {\r\nlong elapsed;\r\nint mask;\r\nmask = f->f_op->poll(f, &table.pt);\r\nif (mask & (POLLRDNORM | POLLRDBAND | POLLIN |\r\nPOLLHUP | POLLERR)) {\r\nbreak;\r\n}\r\ndo_gettimeofday(&now);\r\nelapsed = (1000000 * (now.tv_sec - start.tv_sec) +\r\nnow.tv_usec - start.tv_usec);\r\nif (elapsed > timeout)\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(((timeout - elapsed) * HZ) / 10000);\r\n}\r\npoll_freewait(&table);\r\n}\r\nstatic int serial2002_tty_read(struct file *f, int timeout)\r\n{\r\nunsigned char ch;\r\nint result;\r\nresult = -1;\r\nif (!IS_ERR(f)) {\r\nmm_segment_t oldfs;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nif (f->f_op->poll) {\r\nserial2002_tty_read_poll_wait(f, timeout);\r\nif (serial2002_tty_readb(f, &ch) == 1)\r\nresult = ch;\r\n} else {\r\nint retries = 0;\r\nwhile (1) {\r\nretries++;\r\nif (retries >= timeout)\r\nbreak;\r\nif (serial2002_tty_readb(f, &ch) == 1) {\r\nresult = ch;\r\nbreak;\r\n}\r\nudelay(100);\r\n}\r\n}\r\nset_fs(oldfs);\r\n}\r\nreturn result;\r\n}\r\nstatic void serial2002_tty_setspeed(struct file *f, int speed)\r\n{\r\nstruct termios termios;\r\nstruct serial_struct serial;\r\nmm_segment_t oldfs;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nserial2002_tty_ioctl(f, TCGETS, (unsigned long)&termios);\r\ntermios.c_iflag = 0;\r\ntermios.c_oflag = 0;\r\ntermios.c_lflag = 0;\r\ntermios.c_cflag = CLOCAL | CS8 | CREAD;\r\ntermios.c_cc[VMIN] = 0;\r\ntermios.c_cc[VTIME] = 0;\r\nswitch (speed) {\r\ncase 2400:\r\ntermios.c_cflag |= B2400;\r\nbreak;\r\ncase 4800:\r\ntermios.c_cflag |= B4800;\r\nbreak;\r\ncase 9600:\r\ntermios.c_cflag |= B9600;\r\nbreak;\r\ncase 19200:\r\ntermios.c_cflag |= B19200;\r\nbreak;\r\ncase 38400:\r\ntermios.c_cflag |= B38400;\r\nbreak;\r\ncase 57600:\r\ntermios.c_cflag |= B57600;\r\nbreak;\r\ncase 115200:\r\ntermios.c_cflag |= B115200;\r\nbreak;\r\ndefault:\r\ntermios.c_cflag |= B9600;\r\nbreak;\r\n}\r\nserial2002_tty_ioctl(f, TCSETS, (unsigned long)&termios);\r\nserial2002_tty_ioctl(f, TIOCGSERIAL, (unsigned long)&serial);\r\nserial.flags |= ASYNC_LOW_LATENCY;\r\nserial2002_tty_ioctl(f, TIOCSSERIAL, (unsigned long)&serial);\r\nset_fs(oldfs);\r\n}\r\nstatic void serial2002_poll_digital(struct file *f, int channel)\r\n{\r\nchar cmd;\r\ncmd = 0x40 | (channel & 0x1f);\r\nserial2002_tty_write(f, &cmd, 1);\r\n}\r\nstatic void serial2002_poll_channel(struct file *f, int channel)\r\n{\r\nchar cmd;\r\ncmd = 0x60 | (channel & 0x1f);\r\nserial2002_tty_write(f, &cmd, 1);\r\n}\r\nstatic struct serial_data serial2002_read(struct file *f, int timeout)\r\n{\r\nstruct serial_data result;\r\nint length;\r\nresult.kind = is_invalid;\r\nresult.index = 0;\r\nresult.value = 0;\r\nlength = 0;\r\nwhile (1) {\r\nint data = serial2002_tty_read(f, timeout);\r\nlength++;\r\nif (data < 0) {\r\nbreak;\r\n} else if (data & 0x80) {\r\nresult.value = (result.value << 7) | (data & 0x7f);\r\n} else {\r\nif (length == 1) {\r\nswitch ((data >> 5) & 0x03) {\r\ncase 0:\r\nresult.value = 0;\r\nresult.kind = is_digital;\r\nbreak;\r\ncase 1:\r\nresult.value = 1;\r\nresult.kind = is_digital;\r\nbreak;\r\n}\r\n} else {\r\nresult.value =\r\n(result.value << 2) | ((data & 0x60) >> 5);\r\nresult.kind = is_channel;\r\n}\r\nresult.index = data & 0x1f;\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void serial2002_write(struct file *f, struct serial_data data)\r\n{\r\nif (data.kind == is_digital) {\r\nunsigned char ch =\r\n((data.value << 5) & 0x20) | (data.index & 0x1f);\r\nserial2002_tty_write(f, &ch, 1);\r\n} else {\r\nunsigned char ch[6];\r\nint i = 0;\r\nif (data.value >= (1L << 30)) {\r\nch[i] = 0x80 | ((data.value >> 30) & 0x03);\r\ni++;\r\n}\r\nif (data.value >= (1L << 23)) {\r\nch[i] = 0x80 | ((data.value >> 23) & 0x7f);\r\ni++;\r\n}\r\nif (data.value >= (1L << 16)) {\r\nch[i] = 0x80 | ((data.value >> 16) & 0x7f);\r\ni++;\r\n}\r\nif (data.value >= (1L << 9)) {\r\nch[i] = 0x80 | ((data.value >> 9) & 0x7f);\r\ni++;\r\n}\r\nch[i] = 0x80 | ((data.value >> 2) & 0x7f);\r\ni++;\r\nch[i] = ((data.value << 5) & 0x60) | (data.index & 0x1f);\r\ni++;\r\nserial2002_tty_write(f, ch, i);\r\n}\r\n}\r\nstatic int serial2002_setup_subdevice(struct comedi_subdevice *s,\r\nstruct config_t *cfg,\r\nstruct serial2002_range_table_t *range,\r\nunsigned char *mapping,\r\nint kind)\r\n{\r\nconst struct comedi_lrange **range_table_list = NULL;\r\nunsigned int *maxdata_list;\r\nint j, chan;\r\nfor (chan = 0, j = 0; j < 32; j++) {\r\nif (cfg[j].kind == kind)\r\nchan++;\r\n}\r\ns->n_chan = chan;\r\ns->maxdata = 0;\r\nkfree(s->maxdata_list);\r\nmaxdata_list = kmalloc_array(s->n_chan, sizeof(unsigned int),\r\nGFP_KERNEL);\r\nif (!maxdata_list)\r\nreturn -ENOMEM;\r\ns->maxdata_list = maxdata_list;\r\nkfree(s->range_table_list);\r\ns->range_table = NULL;\r\ns->range_table_list = NULL;\r\nif (kind == 1 || kind == 2) {\r\ns->range_table = &range_digital;\r\n} else if (range) {\r\nrange_table_list = kmalloc_array(s->n_chan, sizeof(*range),\r\nGFP_KERNEL);\r\nif (!range_table_list)\r\nreturn -ENOMEM;\r\ns->range_table_list = range_table_list;\r\n}\r\nfor (chan = 0, j = 0; j < 32; j++) {\r\nif (cfg[j].kind == kind) {\r\nif (mapping)\r\nmapping[chan] = j;\r\nif (range) {\r\nrange[j].length = 1;\r\nrange[j].range.min = cfg[j].min;\r\nrange[j].range.max = cfg[j].max;\r\nrange_table_list[chan] =\r\n(const struct comedi_lrange *)&range[j];\r\n}\r\nmaxdata_list[chan] = ((long long)1 << cfg[j].bits) - 1;\r\nchan++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial2002_setup_subdevs(struct comedi_device *dev)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nstruct config_t *di_cfg;\r\nstruct config_t *do_cfg;\r\nstruct config_t *ai_cfg;\r\nstruct config_t *ao_cfg;\r\nstruct config_t *cfg;\r\nstruct comedi_subdevice *s;\r\nint result = 0;\r\nint i;\r\ndi_cfg = kcalloc(32, sizeof(*cfg), GFP_KERNEL);\r\ndo_cfg = kcalloc(32, sizeof(*cfg), GFP_KERNEL);\r\nai_cfg = kcalloc(32, sizeof(*cfg), GFP_KERNEL);\r\nao_cfg = kcalloc(32, sizeof(*cfg), GFP_KERNEL);\r\nif (!di_cfg || !do_cfg || !ai_cfg || !ao_cfg) {\r\nresult = -ENOMEM;\r\ngoto err_alloc_configs;\r\n}\r\nserial2002_tty_setspeed(devpriv->tty, devpriv->speed);\r\nserial2002_poll_channel(devpriv->tty, 31);\r\nwhile (1) {\r\nstruct serial_data data = serial2002_read(devpriv->tty, 1000);\r\nint kind = S2002_CFG_KIND(data.value);\r\nint channel = S2002_CFG_CHAN(data.value);\r\nint range = S2002_CFG_BASE(data.value);\r\nint cmd = S2002_CFG_CMD(data.value);\r\nif (data.kind != is_channel || data.index != 31 ||\r\nkind == S2002_CFG_KIND_INVALID)\r\nbreak;\r\nswitch (kind) {\r\ncase S2002_CFG_KIND_DIGITAL_IN:\r\ncfg = di_cfg;\r\nbreak;\r\ncase S2002_CFG_KIND_DIGITAL_OUT:\r\ncfg = do_cfg;\r\nbreak;\r\ncase S2002_CFG_KIND_ANALOG_IN:\r\ncfg = ai_cfg;\r\nbreak;\r\ncase S2002_CFG_KIND_ANALOG_OUT:\r\ncfg = ao_cfg;\r\nbreak;\r\ncase S2002_CFG_KIND_ENCODER_IN:\r\ncfg = ai_cfg;\r\nbreak;\r\ndefault:\r\ncfg = NULL;\r\nbreak;\r\n}\r\nif (!cfg)\r\ncontinue;\r\ncfg[channel].kind = kind;\r\nswitch (cmd) {\r\ncase S2002_CFG_CMD_BITS:\r\ncfg[channel].bits = S2002_CFG_BITS(data.value);\r\nbreak;\r\ncase S2002_CFG_CMD_MIN:\r\ncase S2002_CFG_CMD_MAX:\r\nswitch (S2002_CFG_UNITS(data.value)) {\r\ncase 0:\r\nrange *= 1000000;\r\nbreak;\r\ncase 1:\r\nrange *= 1000;\r\nbreak;\r\ncase 2:\r\nrange *= 1;\r\nbreak;\r\n}\r\nif (S2002_CFG_SIGN(data.value))\r\nrange = -range;\r\nif (cmd == S2002_CFG_CMD_MIN)\r\ncfg[channel].min = range;\r\nelse\r\ncfg[channel].max = range;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i <= 4; i++) {\r\nunsigned char *mapping = NULL;\r\nstruct serial2002_range_table_t *range = NULL;\r\nint kind = 0;\r\ns = &dev->subdevices[i];\r\nswitch (i) {\r\ncase 0:\r\ncfg = di_cfg;\r\nmapping = devpriv->digital_in_mapping;\r\nkind = S2002_CFG_KIND_DIGITAL_IN;\r\nbreak;\r\ncase 1:\r\ncfg = do_cfg;\r\nmapping = devpriv->digital_out_mapping;\r\nkind = S2002_CFG_KIND_DIGITAL_OUT;\r\nbreak;\r\ncase 2:\r\ncfg = ai_cfg;\r\nmapping = devpriv->analog_in_mapping;\r\nrange = devpriv->in_range;\r\nkind = S2002_CFG_KIND_ANALOG_IN;\r\nbreak;\r\ncase 3:\r\ncfg = ao_cfg;\r\nmapping = devpriv->analog_out_mapping;\r\nrange = devpriv->out_range;\r\nkind = S2002_CFG_KIND_ANALOG_OUT;\r\nbreak;\r\ncase 4:\r\ncfg = ai_cfg;\r\nmapping = devpriv->encoder_in_mapping;\r\nrange = devpriv->in_range;\r\nkind = S2002_CFG_KIND_ENCODER_IN;\r\nbreak;\r\n}\r\nif (serial2002_setup_subdevice(s, cfg, range, mapping, kind))\r\nbreak;\r\n}\r\nif (i <= 4) {\r\nresult = -ENOMEM;\r\nfor (i = 0; i <= 4; i++) {\r\ns = &dev->subdevices[i];\r\nkfree(s->maxdata_list);\r\ns->maxdata_list = NULL;\r\nkfree(s->range_table_list);\r\ns->range_table_list = NULL;\r\n}\r\n}\r\nerr_alloc_configs:\r\nkfree(di_cfg);\r\nkfree(do_cfg);\r\nkfree(ai_cfg);\r\nkfree(ao_cfg);\r\nif (result) {\r\nif (devpriv->tty) {\r\nfilp_close(devpriv->tty, NULL);\r\ndevpriv->tty = NULL;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int serial2002_open(struct comedi_device *dev)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nint result;\r\nchar port[20];\r\nsprintf(port, "/dev/ttyS%d", devpriv->port);\r\ndevpriv->tty = filp_open(port, O_RDWR, 0);\r\nif (IS_ERR(devpriv->tty)) {\r\nresult = (int)PTR_ERR(devpriv->tty);\r\ndev_err(dev->class_dev, "file open error = %d\n", result);\r\n} else {\r\nresult = serial2002_setup_subdevs(dev);\r\n}\r\nreturn result;\r\n}\r\nstatic void serial2002_close(struct comedi_device *dev)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nif (!IS_ERR(devpriv->tty) && devpriv->tty)\r\nfilp_close(devpriv->tty, NULL);\r\n}\r\nstatic int serial2002_di_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nint n;\r\nint chan;\r\nchan = devpriv->digital_in_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data read;\r\nserial2002_poll_digital(devpriv->tty, chan);\r\nwhile (1) {\r\nread = serial2002_read(devpriv->tty, 1000);\r\nif (read.kind != is_digital || read.index == chan)\r\nbreak;\r\n}\r\ndata[n] = read.value;\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_do_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nint n;\r\nint chan;\r\nchan = devpriv->digital_out_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data write;\r\nwrite.kind = is_digital;\r\nwrite.index = chan;\r\nwrite.value = data[n];\r\nserial2002_write(devpriv->tty, write);\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nint n;\r\nint chan;\r\nchan = devpriv->analog_in_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data read;\r\nserial2002_poll_channel(devpriv->tty, chan);\r\nwhile (1) {\r\nread = serial2002_read(devpriv->tty, 1000);\r\nif (read.kind != is_channel || read.index == chan)\r\nbreak;\r\n}\r\ndata[n] = read.value;\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nint n;\r\nint chan;\r\nchan = devpriv->analog_out_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data write;\r\nwrite.kind = is_channel;\r\nwrite.index = chan;\r\nwrite.value = data[n];\r\nserial2002_write(devpriv->tty, write);\r\ndevpriv->ao_readback[chan] = data[n];\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nint n;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = devpriv->ao_readback[chan];\r\nreturn n;\r\n}\r\nstatic int serial2002_encoder_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct serial2002_private *devpriv = dev->private;\r\nint n;\r\nint chan;\r\nchan = devpriv->encoder_in_mapping[CR_CHAN(insn->chanspec)];\r\nfor (n = 0; n < insn->n; n++) {\r\nstruct serial_data read;\r\nserial2002_poll_channel(devpriv->tty, chan);\r\nwhile (1) {\r\nread = serial2002_read(devpriv->tty, 1000);\r\nif (read.kind != is_channel || read.index == chan)\r\nbreak;\r\n}\r\ndata[n] = read.value;\r\n}\r\nreturn n;\r\n}\r\nstatic int serial2002_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct serial2002_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndevpriv->port = it->options[0];\r\ndevpriv->speed = it->options[1];\r\nret = comedi_alloc_subdevices(dev, 5);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_read = serial2002_di_insn_read;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITEABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_write = serial2002_do_insn_write;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = NULL;\r\ns->insn_read = serial2002_ai_insn_read;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITEABLE;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = NULL;\r\ns->insn_write = serial2002_ao_insn_write;\r\ns->insn_read = serial2002_ao_insn_read;\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_READABLE | SDF_LSAMPL;\r\ns->n_chan = 0;\r\ns->maxdata = 1;\r\ns->range_table = NULL;\r\ns->insn_read = serial2002_encoder_insn_read;\r\ndev->open = serial2002_open;\r\ndev->close = serial2002_close;\r\nreturn 0;\r\n}\r\nstatic void serial2002_detach(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nint i;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\nkfree(s->maxdata_list);\r\nkfree(s->range_table_list);\r\n}\r\n}
