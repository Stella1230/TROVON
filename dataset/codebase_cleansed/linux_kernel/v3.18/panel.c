static int set_data_bits(void)\r\n{\r\nint val, bit;\r\nval = r_dtr(pprt);\r\nfor (bit = 0; bit < LCD_BITS; bit++)\r\nval &= lcd_bits[LCD_PORT_D][bit][BIT_MSK];\r\nval |= lcd_bits[LCD_PORT_D][LCD_BIT_E][bits.e]\r\n| lcd_bits[LCD_PORT_D][LCD_BIT_RS][bits.rs]\r\n| lcd_bits[LCD_PORT_D][LCD_BIT_RW][bits.rw]\r\n| lcd_bits[LCD_PORT_D][LCD_BIT_BL][bits.bl]\r\n| lcd_bits[LCD_PORT_D][LCD_BIT_CL][bits.cl]\r\n| lcd_bits[LCD_PORT_D][LCD_BIT_DA][bits.da];\r\nw_dtr(pprt, val);\r\nreturn val;\r\n}\r\nstatic int set_ctrl_bits(void)\r\n{\r\nint val, bit;\r\nval = r_ctr(pprt);\r\nfor (bit = 0; bit < LCD_BITS; bit++)\r\nval &= lcd_bits[LCD_PORT_C][bit][BIT_MSK];\r\nval |= lcd_bits[LCD_PORT_C][LCD_BIT_E][bits.e]\r\n| lcd_bits[LCD_PORT_C][LCD_BIT_RS][bits.rs]\r\n| lcd_bits[LCD_PORT_C][LCD_BIT_RW][bits.rw]\r\n| lcd_bits[LCD_PORT_C][LCD_BIT_BL][bits.bl]\r\n| lcd_bits[LCD_PORT_C][LCD_BIT_CL][bits.cl]\r\n| lcd_bits[LCD_PORT_C][LCD_BIT_DA][bits.da];\r\nw_ctr(pprt, val);\r\nreturn val;\r\n}\r\nstatic void panel_set_bits(void)\r\n{\r\nset_data_bits();\r\nset_ctrl_bits();\r\n}\r\nstatic void pin_to_bits(int pin, unsigned char *d_val, unsigned char *c_val)\r\n{\r\nint d_bit, c_bit, inv;\r\nd_val[0] = 0;\r\nc_val[0] = 0;\r\nd_val[1] = 0;\r\nc_val[1] = 0;\r\nd_val[2] = 0xFF;\r\nc_val[2] = 0xFF;\r\nif (pin == 0)\r\nreturn;\r\ninv = (pin < 0);\r\nif (inv)\r\npin = -pin;\r\nd_bit = 0;\r\nc_bit = 0;\r\nswitch (pin) {\r\ncase PIN_STROBE:\r\nc_bit = PNL_PSTROBE;\r\ninv = !inv;\r\nbreak;\r\ncase PIN_D0...PIN_D7:\r\nd_bit = 1 << (pin - 2);\r\nbreak;\r\ncase PIN_AUTOLF:\r\nc_bit = PNL_PAUTOLF;\r\ninv = !inv;\r\nbreak;\r\ncase PIN_INITP:\r\nc_bit = PNL_PINITP;\r\nbreak;\r\ncase PIN_SELECP:\r\nc_bit = PNL_PSELECP;\r\ninv = !inv;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (c_bit) {\r\nc_val[2] &= ~c_bit;\r\nc_val[!inv] = c_bit;\r\n} else if (d_bit) {\r\nd_val[2] &= ~d_bit;\r\nd_val[!inv] = d_bit;\r\n}\r\n}\r\nstatic void long_sleep(int ms)\r\n{\r\nif (in_interrupt()) {\r\nmdelay(ms);\r\n} else {\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule_timeout((ms * HZ + 999) / 1000);\r\n}\r\n}\r\nstatic void lcd_send_serial(int byte)\r\n{\r\nint bit;\r\nfor (bit = 0; bit < 8; bit++) {\r\nbits.cl = BIT_CLR;\r\npanel_set_bits();\r\nbits.da = byte & 1;\r\npanel_set_bits();\r\nudelay(2);\r\nbits.cl = BIT_SET;\r\npanel_set_bits();\r\nudelay(1);\r\nbyte >>= 1;\r\n}\r\n}\r\nstatic void lcd_backlight(int on)\r\n{\r\nif (lcd_bl_pin == PIN_NONE)\r\nreturn;\r\nspin_lock_irq(&pprt_lock);\r\nbits.bl = on;\r\npanel_set_bits();\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_cmd_s(int cmd)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nlcd_send_serial(0x1F);\r\nlcd_send_serial(cmd & 0x0F);\r\nlcd_send_serial((cmd >> 4) & 0x0F);\r\nudelay(40);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_data_s(int data)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nlcd_send_serial(0x5F);\r\nlcd_send_serial(data & 0x0F);\r\nlcd_send_serial((data >> 4) & 0x0F);\r\nudelay(40);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_cmd_p8(int cmd)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nw_dtr(pprt, cmd);\r\nudelay(20);\r\nbits.e = BIT_SET;\r\nbits.rs = BIT_CLR;\r\nbits.rw = BIT_CLR;\r\nset_ctrl_bits();\r\nudelay(40);\r\nbits.e = BIT_CLR;\r\nset_ctrl_bits();\r\nudelay(120);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_data_p8(int data)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nw_dtr(pprt, data);\r\nudelay(20);\r\nbits.e = BIT_SET;\r\nbits.rs = BIT_SET;\r\nbits.rw = BIT_CLR;\r\nset_ctrl_bits();\r\nudelay(40);\r\nbits.e = BIT_CLR;\r\nset_ctrl_bits();\r\nudelay(45);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_cmd_tilcd(int cmd)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nw_ctr(pprt, cmd);\r\nudelay(60);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_write_data_tilcd(int data)\r\n{\r\nspin_lock_irq(&pprt_lock);\r\nw_dtr(pprt, data);\r\nudelay(60);\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nstatic void lcd_gotoxy(void)\r\n{\r\nlcd_write_cmd(0x80\r\n| (lcd_addr_y ? lcd_hwidth : 0)\r\n| ((lcd_addr_x < lcd_bwidth) ? lcd_addr_x &\r\n(lcd_hwidth - 1) : lcd_bwidth - 1));\r\n}\r\nstatic void lcd_print(char c)\r\n{\r\nif (lcd_addr_x < lcd_bwidth) {\r\nif (lcd_char_conv != NULL)\r\nc = lcd_char_conv[(unsigned char)c];\r\nlcd_write_data(c);\r\nlcd_addr_x++;\r\n}\r\nif (lcd_addr_x == lcd_bwidth)\r\nlcd_gotoxy();\r\n}\r\nstatic void lcd_clear_fast_s(void)\r\n{\r\nint pos;\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlcd_gotoxy();\r\nspin_lock_irq(&pprt_lock);\r\nfor (pos = 0; pos < lcd_height * lcd_hwidth; pos++) {\r\nlcd_send_serial(0x5F);\r\nlcd_send_serial(' ' & 0x0F);\r\nlcd_send_serial((' ' >> 4) & 0x0F);\r\nudelay(40);\r\n}\r\nspin_unlock_irq(&pprt_lock);\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlcd_gotoxy();\r\n}\r\nstatic void lcd_clear_fast_p8(void)\r\n{\r\nint pos;\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlcd_gotoxy();\r\nspin_lock_irq(&pprt_lock);\r\nfor (pos = 0; pos < lcd_height * lcd_hwidth; pos++) {\r\nw_dtr(pprt, ' ');\r\nudelay(20);\r\nbits.e = BIT_SET;\r\nbits.rs = BIT_SET;\r\nbits.rw = BIT_CLR;\r\nset_ctrl_bits();\r\nudelay(40);\r\nbits.e = BIT_CLR;\r\nset_ctrl_bits();\r\nudelay(45);\r\n}\r\nspin_unlock_irq(&pprt_lock);\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlcd_gotoxy();\r\n}\r\nstatic void lcd_clear_fast_tilcd(void)\r\n{\r\nint pos;\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlcd_gotoxy();\r\nspin_lock_irq(&pprt_lock);\r\nfor (pos = 0; pos < lcd_height * lcd_hwidth; pos++) {\r\nw_dtr(pprt, ' ');\r\nudelay(60);\r\n}\r\nspin_unlock_irq(&pprt_lock);\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlcd_gotoxy();\r\n}\r\nstatic void lcd_clear_display(void)\r\n{\r\nlcd_write_cmd(0x01);\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlong_sleep(15);\r\n}\r\nstatic void lcd_init_display(void)\r\n{\r\nlcd_flags = ((lcd_height > 1) ? LCD_FLAG_N : 0)\r\n| LCD_FLAG_D | LCD_FLAG_C | LCD_FLAG_B;\r\nlong_sleep(20);\r\nlcd_write_cmd(0x30);\r\nlong_sleep(10);\r\nlcd_write_cmd(0x30);\r\nlong_sleep(10);\r\nlcd_write_cmd(0x30);\r\nlong_sleep(10);\r\nlcd_write_cmd(0x30\r\n| ((lcd_flags & LCD_FLAG_F) ? 4 : 0)\r\n| ((lcd_flags & LCD_FLAG_N) ? 8 : 0)\r\n);\r\nlong_sleep(10);\r\nlcd_write_cmd(0x08);\r\nlong_sleep(10);\r\nlcd_write_cmd(0x08\r\n| ((lcd_flags & LCD_FLAG_D) ? 4 : 0)\r\n| ((lcd_flags & LCD_FLAG_C) ? 2 : 0)\r\n| ((lcd_flags & LCD_FLAG_B) ? 1 : 0)\r\n);\r\nlcd_backlight((lcd_flags & LCD_FLAG_L) ? 1 : 0);\r\nlong_sleep(10);\r\nlcd_write_cmd(0x06);\r\nlcd_clear_display();\r\n}\r\nstatic inline int handle_lcd_special_code(void)\r\n{\r\nint processed = 0;\r\nchar *esc = lcd_escape + 2;\r\nint oldflags = lcd_flags;\r\nswitch (*esc) {\r\ncase 'D':\r\nlcd_flags |= LCD_FLAG_D;\r\nprocessed = 1;\r\nbreak;\r\ncase 'd':\r\nlcd_flags &= ~LCD_FLAG_D;\r\nprocessed = 1;\r\nbreak;\r\ncase 'C':\r\nlcd_flags |= LCD_FLAG_C;\r\nprocessed = 1;\r\nbreak;\r\ncase 'c':\r\nlcd_flags &= ~LCD_FLAG_C;\r\nprocessed = 1;\r\nbreak;\r\ncase 'B':\r\nlcd_flags |= LCD_FLAG_B;\r\nprocessed = 1;\r\nbreak;\r\ncase 'b':\r\nlcd_flags &= ~LCD_FLAG_B;\r\nprocessed = 1;\r\nbreak;\r\ncase '+':\r\nlcd_flags |= LCD_FLAG_L;\r\nprocessed = 1;\r\nbreak;\r\ncase '-':\r\nlcd_flags &= ~LCD_FLAG_L;\r\nprocessed = 1;\r\nbreak;\r\ncase '*':\r\nif (scan_timer.function != NULL) {\r\nif (light_tempo == 0 && ((lcd_flags & LCD_FLAG_L) == 0))\r\nlcd_backlight(1);\r\nlight_tempo = FLASH_LIGHT_TEMPO;\r\n}\r\nprocessed = 1;\r\nbreak;\r\ncase 'f':\r\nlcd_flags &= ~LCD_FLAG_F;\r\nprocessed = 1;\r\nbreak;\r\ncase 'F':\r\nlcd_flags |= LCD_FLAG_F;\r\nprocessed = 1;\r\nbreak;\r\ncase 'n':\r\nlcd_flags &= ~LCD_FLAG_N;\r\nprocessed = 1;\r\nbreak;\r\ncase 'N':\r\nlcd_flags |= LCD_FLAG_N;\r\nbreak;\r\ncase 'l':\r\nif (lcd_addr_x > 0) {\r\nif (lcd_addr_x < lcd_bwidth)\r\nlcd_write_cmd(0x10);\r\nlcd_addr_x--;\r\n}\r\nprocessed = 1;\r\nbreak;\r\ncase 'r':\r\nif (lcd_addr_x < lcd_width) {\r\nif (lcd_addr_x <\r\n(lcd_bwidth - 1))\r\nlcd_write_cmd(0x14);\r\nlcd_addr_x++;\r\n}\r\nprocessed = 1;\r\nbreak;\r\ncase 'L':\r\nlcd_left_shift++;\r\nlcd_write_cmd(0x18);\r\nprocessed = 1;\r\nbreak;\r\ncase 'R':\r\nlcd_left_shift--;\r\nlcd_write_cmd(0x1C);\r\nprocessed = 1;\r\nbreak;\r\ncase 'k': {\r\nint x;\r\nfor (x = lcd_addr_x; x < lcd_bwidth; x++)\r\nlcd_write_data(' ');\r\nlcd_gotoxy();\r\nprocessed = 1;\r\nbreak;\r\n}\r\ncase 'I':\r\nlcd_init_display();\r\nlcd_left_shift = 0;\r\nprocessed = 1;\r\nbreak;\r\ncase 'G': {\r\nunsigned char cgbytes[8];\r\nunsigned char cgaddr;\r\nint cgoffset;\r\nint shift;\r\nchar value;\r\nint addr;\r\nif (strchr(esc, ';') == NULL)\r\nbreak;\r\nesc++;\r\ncgaddr = *(esc++) - '0';\r\nif (cgaddr > 7) {\r\nprocessed = 1;\r\nbreak;\r\n}\r\ncgoffset = 0;\r\nshift = 0;\r\nvalue = 0;\r\nwhile (*esc && cgoffset < 8) {\r\nshift ^= 4;\r\nif (*esc >= '0' && *esc <= '9') {\r\nvalue |= (*esc - '0') << shift;\r\n} else if (*esc >= 'A' && *esc <= 'Z') {\r\nvalue |= (*esc - 'A' + 10) << shift;\r\n} else if (*esc >= 'a' && *esc <= 'z') {\r\nvalue |= (*esc - 'a' + 10) << shift;\r\n} else {\r\nesc++;\r\ncontinue;\r\n}\r\nif (shift == 0) {\r\ncgbytes[cgoffset++] = value;\r\nvalue = 0;\r\n}\r\nesc++;\r\n}\r\nlcd_write_cmd(0x40 | (cgaddr * 8));\r\nfor (addr = 0; addr < cgoffset; addr++)\r\nlcd_write_data(cgbytes[addr]);\r\nlcd_gotoxy();\r\nprocessed = 1;\r\nbreak;\r\n}\r\ncase 'x':\r\ncase 'y':\r\nif (strchr(esc, ';') == NULL)\r\nbreak;\r\nwhile (*esc) {\r\nif (*esc == 'x') {\r\nesc++;\r\nif (kstrtoul(esc, 10, &lcd_addr_x) < 0)\r\nbreak;\r\n} else if (*esc == 'y') {\r\nesc++;\r\nif (kstrtoul(esc, 10, &lcd_addr_y) < 0)\r\nbreak;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nlcd_gotoxy();\r\nprocessed = 1;\r\nbreak;\r\n}\r\nif (oldflags != lcd_flags) {\r\nif ((oldflags ^ lcd_flags) &\r\n(LCD_FLAG_B | LCD_FLAG_C | LCD_FLAG_D))\r\nlcd_write_cmd(0x08\r\n| ((lcd_flags & LCD_FLAG_D) ? 4 : 0)\r\n| ((lcd_flags & LCD_FLAG_C) ? 2 : 0)\r\n| ((lcd_flags & LCD_FLAG_B) ? 1 : 0));\r\nelse if ((oldflags ^ lcd_flags) & (LCD_FLAG_F | LCD_FLAG_N))\r\nlcd_write_cmd(0x30\r\n| ((lcd_flags & LCD_FLAG_F) ? 4 : 0)\r\n| ((lcd_flags & LCD_FLAG_N) ? 8 : 0));\r\nelse if ((oldflags ^ lcd_flags) & (LCD_FLAG_L)) {\r\nif (lcd_flags & (LCD_FLAG_L))\r\nlcd_backlight(1);\r\nelse if (light_tempo == 0)\r\nlcd_backlight(0);\r\n}\r\n}\r\nreturn processed;\r\n}\r\nstatic void lcd_write_char(char c)\r\n{\r\nif ((c != '\n') && lcd_escape_len >= 0) {\r\nlcd_escape[lcd_escape_len++] = c;\r\nlcd_escape[lcd_escape_len] = 0;\r\n} else {\r\nlcd_escape_len = -1;\r\nswitch (c) {\r\ncase LCD_ESCAPE_CHAR:\r\nlcd_escape_len = 0;\r\nlcd_escape[lcd_escape_len] = 0;\r\nbreak;\r\ncase '\b':\r\nif (lcd_addr_x > 0) {\r\nif (lcd_addr_x < lcd_bwidth)\r\nlcd_write_cmd(0x10);\r\nlcd_addr_x--;\r\n}\r\nlcd_write_data(' ');\r\nlcd_write_cmd(0x10);\r\nbreak;\r\ncase '\014':\r\nlcd_clear_fast();\r\nbreak;\r\ncase '\n':\r\nfor (; lcd_addr_x < lcd_bwidth; lcd_addr_x++)\r\nlcd_write_data(' ');\r\nlcd_addr_x = 0;\r\nlcd_addr_y = (lcd_addr_y + 1) % lcd_height;\r\nlcd_gotoxy();\r\nbreak;\r\ncase '\r':\r\nlcd_addr_x = 0;\r\nlcd_gotoxy();\r\nbreak;\r\ncase '\t':\r\nlcd_print(' ');\r\nbreak;\r\ndefault:\r\nlcd_print(c);\r\nbreak;\r\n}\r\n}\r\nif (lcd_escape_len >= 2) {\r\nint processed = 0;\r\nif (!strcmp(lcd_escape, "[2J")) {\r\nlcd_clear_fast();\r\nprocessed = 1;\r\n} else if (!strcmp(lcd_escape, "[H")) {\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlcd_gotoxy();\r\nprocessed = 1;\r\n}\r\nelse if ((lcd_escape_len >= 3) &&\r\n(lcd_escape[0] == '[') &&\r\n(lcd_escape[1] == 'L')) {\r\nprocessed = handle_lcd_special_code();\r\n}\r\nif (processed || (lcd_escape_len >= LCD_ESCAPE_LEN))\r\nlcd_escape_len = -1;\r\n}\r\n}\r\nstatic ssize_t lcd_write(struct file *file,\r\nconst char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nconst char __user *tmp = buf;\r\nchar c;\r\nfor (; count-- > 0; (*ppos)++, tmp++) {\r\nif (!in_interrupt() && (((count + 1) & 0x1f) == 0))\r\nschedule();\r\nif (get_user(c, tmp))\r\nreturn -EFAULT;\r\nlcd_write_char(c);\r\n}\r\nreturn tmp - buf;\r\n}\r\nstatic int lcd_open(struct inode *inode, struct file *file)\r\n{\r\nif (lcd_open_cnt)\r\nreturn -EBUSY;\r\nif (file->f_mode & FMODE_READ)\r\nreturn -EPERM;\r\nif (lcd_must_clear) {\r\nlcd_clear_display();\r\nlcd_must_clear = 0;\r\n}\r\nlcd_open_cnt++;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int lcd_release(struct inode *inode, struct file *file)\r\n{\r\nlcd_open_cnt--;\r\nreturn 0;\r\n}\r\nstatic void panel_lcd_print(const char *s)\r\n{\r\nconst char *tmp = s;\r\nint count = strlen(s);\r\nif (lcd_enabled && lcd_initialized) {\r\nfor (; count-- > 0; tmp++) {\r\nif (!in_interrupt() && (((count + 1) & 0x1f) == 0))\r\nschedule();\r\nlcd_write_char(*tmp);\r\n}\r\n}\r\n}\r\nstatic void lcd_init(void)\r\n{\r\nswitch (lcd_type) {\r\ncase LCD_TYPE_OLD:\r\nif (lcd_proto < 0)\r\nlcd_proto = LCD_PROTO_PARALLEL;\r\nif (lcd_charset < 0)\r\nlcd_charset = LCD_CHARSET_NORMAL;\r\nif (lcd_e_pin == PIN_NOT_SET)\r\nlcd_e_pin = PIN_STROBE;\r\nif (lcd_rs_pin == PIN_NOT_SET)\r\nlcd_rs_pin = PIN_AUTOLF;\r\nif (lcd_width < 0)\r\nlcd_width = 40;\r\nif (lcd_bwidth < 0)\r\nlcd_bwidth = 40;\r\nif (lcd_hwidth < 0)\r\nlcd_hwidth = 64;\r\nif (lcd_height < 0)\r\nlcd_height = 2;\r\nbreak;\r\ncase LCD_TYPE_KS0074:\r\nif (lcd_proto < 0)\r\nlcd_proto = LCD_PROTO_SERIAL;\r\nif (lcd_charset < 0)\r\nlcd_charset = LCD_CHARSET_KS0074;\r\nif (lcd_bl_pin == PIN_NOT_SET)\r\nlcd_bl_pin = PIN_AUTOLF;\r\nif (lcd_cl_pin == PIN_NOT_SET)\r\nlcd_cl_pin = PIN_STROBE;\r\nif (lcd_da_pin == PIN_NOT_SET)\r\nlcd_da_pin = PIN_D0;\r\nif (lcd_width < 0)\r\nlcd_width = 16;\r\nif (lcd_bwidth < 0)\r\nlcd_bwidth = 40;\r\nif (lcd_hwidth < 0)\r\nlcd_hwidth = 16;\r\nif (lcd_height < 0)\r\nlcd_height = 2;\r\nbreak;\r\ncase LCD_TYPE_NEXCOM:\r\nif (lcd_proto < 0)\r\nlcd_proto = LCD_PROTO_PARALLEL;\r\nif (lcd_charset < 0)\r\nlcd_charset = LCD_CHARSET_NORMAL;\r\nif (lcd_e_pin == PIN_NOT_SET)\r\nlcd_e_pin = PIN_AUTOLF;\r\nif (lcd_rs_pin == PIN_NOT_SET)\r\nlcd_rs_pin = PIN_SELECP;\r\nif (lcd_rw_pin == PIN_NOT_SET)\r\nlcd_rw_pin = PIN_INITP;\r\nif (lcd_width < 0)\r\nlcd_width = 16;\r\nif (lcd_bwidth < 0)\r\nlcd_bwidth = 40;\r\nif (lcd_hwidth < 0)\r\nlcd_hwidth = 64;\r\nif (lcd_height < 0)\r\nlcd_height = 2;\r\nbreak;\r\ncase LCD_TYPE_CUSTOM:\r\nif (lcd_proto < 0)\r\nlcd_proto = DEFAULT_LCD_PROTO;\r\nif (lcd_charset < 0)\r\nlcd_charset = DEFAULT_LCD_CHARSET;\r\nbreak;\r\ncase LCD_TYPE_HANTRONIX:\r\ndefault:\r\nif (lcd_proto < 0)\r\nlcd_proto = LCD_PROTO_PARALLEL;\r\nif (lcd_charset < 0)\r\nlcd_charset = LCD_CHARSET_NORMAL;\r\nif (lcd_e_pin == PIN_NOT_SET)\r\nlcd_e_pin = PIN_STROBE;\r\nif (lcd_rs_pin == PIN_NOT_SET)\r\nlcd_rs_pin = PIN_SELECP;\r\nif (lcd_width < 0)\r\nlcd_width = 16;\r\nif (lcd_bwidth < 0)\r\nlcd_bwidth = 40;\r\nif (lcd_hwidth < 0)\r\nlcd_hwidth = 64;\r\nif (lcd_height < 0)\r\nlcd_height = 2;\r\nbreak;\r\n}\r\nif (lcd_width <= 0)\r\nlcd_width = DEFAULT_LCD_WIDTH;\r\nif (lcd_bwidth <= 0)\r\nlcd_bwidth = DEFAULT_LCD_BWIDTH;\r\nif (lcd_hwidth <= 0)\r\nlcd_hwidth = DEFAULT_LCD_HWIDTH;\r\nif (lcd_height <= 0)\r\nlcd_height = DEFAULT_LCD_HEIGHT;\r\nif (lcd_proto == LCD_PROTO_SERIAL) {\r\nlcd_write_cmd = lcd_write_cmd_s;\r\nlcd_write_data = lcd_write_data_s;\r\nlcd_clear_fast = lcd_clear_fast_s;\r\nif (lcd_cl_pin == PIN_NOT_SET)\r\nlcd_cl_pin = DEFAULT_LCD_PIN_SCL;\r\nif (lcd_da_pin == PIN_NOT_SET)\r\nlcd_da_pin = DEFAULT_LCD_PIN_SDA;\r\n} else if (lcd_proto == LCD_PROTO_PARALLEL) {\r\nlcd_write_cmd = lcd_write_cmd_p8;\r\nlcd_write_data = lcd_write_data_p8;\r\nlcd_clear_fast = lcd_clear_fast_p8;\r\nif (lcd_e_pin == PIN_NOT_SET)\r\nlcd_e_pin = DEFAULT_LCD_PIN_E;\r\nif (lcd_rs_pin == PIN_NOT_SET)\r\nlcd_rs_pin = DEFAULT_LCD_PIN_RS;\r\nif (lcd_rw_pin == PIN_NOT_SET)\r\nlcd_rw_pin = DEFAULT_LCD_PIN_RW;\r\n} else {\r\nlcd_write_cmd = lcd_write_cmd_tilcd;\r\nlcd_write_data = lcd_write_data_tilcd;\r\nlcd_clear_fast = lcd_clear_fast_tilcd;\r\n}\r\nif (lcd_bl_pin == PIN_NOT_SET)\r\nlcd_bl_pin = DEFAULT_LCD_PIN_BL;\r\nif (lcd_e_pin == PIN_NOT_SET)\r\nlcd_e_pin = PIN_NONE;\r\nif (lcd_rs_pin == PIN_NOT_SET)\r\nlcd_rs_pin = PIN_NONE;\r\nif (lcd_rw_pin == PIN_NOT_SET)\r\nlcd_rw_pin = PIN_NONE;\r\nif (lcd_bl_pin == PIN_NOT_SET)\r\nlcd_bl_pin = PIN_NONE;\r\nif (lcd_cl_pin == PIN_NOT_SET)\r\nlcd_cl_pin = PIN_NONE;\r\nif (lcd_da_pin == PIN_NOT_SET)\r\nlcd_da_pin = PIN_NONE;\r\nif (lcd_charset < 0)\r\nlcd_charset = DEFAULT_LCD_CHARSET;\r\nif (lcd_charset == LCD_CHARSET_KS0074)\r\nlcd_char_conv = lcd_char_conv_ks0074;\r\nelse\r\nlcd_char_conv = NULL;\r\nif (lcd_bl_pin != PIN_NONE)\r\ninit_scan_timer();\r\npin_to_bits(lcd_e_pin, lcd_bits[LCD_PORT_D][LCD_BIT_E],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_E]);\r\npin_to_bits(lcd_rs_pin, lcd_bits[LCD_PORT_D][LCD_BIT_RS],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_RS]);\r\npin_to_bits(lcd_rw_pin, lcd_bits[LCD_PORT_D][LCD_BIT_RW],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_RW]);\r\npin_to_bits(lcd_bl_pin, lcd_bits[LCD_PORT_D][LCD_BIT_BL],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_BL]);\r\npin_to_bits(lcd_cl_pin, lcd_bits[LCD_PORT_D][LCD_BIT_CL],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_CL]);\r\npin_to_bits(lcd_da_pin, lcd_bits[LCD_PORT_D][LCD_BIT_DA],\r\nlcd_bits[LCD_PORT_C][LCD_BIT_DA]);\r\nlcd_initialized = 1;\r\nlcd_init_display();\r\n#ifdef CONFIG_PANEL_CHANGE_MESSAGE\r\n#ifdef CONFIG_PANEL_BOOT_MESSAGE\r\npanel_lcd_print("\x1b[Lc\x1b[Lb\x1b[L*" CONFIG_PANEL_BOOT_MESSAGE);\r\n#endif\r\n#else\r\npanel_lcd_print("\x1b[Lc\x1b[Lb\x1b[L*Linux-" UTS_RELEASE "\nPanel-"\r\nPANEL_VERSION);\r\n#endif\r\nlcd_addr_x = 0;\r\nlcd_addr_y = 0;\r\nlcd_must_clear = 1;\r\nlcd_gotoxy();\r\n}\r\nstatic ssize_t keypad_read(struct file *file,\r\nchar __user *buf, size_t count, loff_t *ppos)\r\n{\r\nunsigned i = *ppos;\r\nchar __user *tmp = buf;\r\nif (keypad_buflen == 0) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(keypad_read_wait,\r\nkeypad_buflen != 0))\r\nreturn -EINTR;\r\n}\r\nfor (; count-- > 0 && (keypad_buflen > 0);\r\n++i, ++tmp, --keypad_buflen) {\r\nput_user(keypad_buffer[keypad_start], tmp);\r\nkeypad_start = (keypad_start + 1) % KEYPAD_BUFFER;\r\n}\r\n*ppos = i;\r\nreturn tmp - buf;\r\n}\r\nstatic int keypad_open(struct inode *inode, struct file *file)\r\n{\r\nif (keypad_open_cnt)\r\nreturn -EBUSY;\r\nif (file->f_mode & FMODE_WRITE)\r\nreturn -EPERM;\r\nkeypad_buflen = 0;\r\nkeypad_open_cnt++;\r\nreturn 0;\r\n}\r\nstatic int keypad_release(struct inode *inode, struct file *file)\r\n{\r\nkeypad_open_cnt--;\r\nreturn 0;\r\n}\r\nstatic void keypad_send_key(const char *string, int max_len)\r\n{\r\nif (init_in_progress)\r\nreturn;\r\nif (keypad_open_cnt > 0) {\r\nwhile (max_len-- && keypad_buflen < KEYPAD_BUFFER && *string) {\r\nkeypad_buffer[(keypad_start + keypad_buflen++) %\r\nKEYPAD_BUFFER] = *string++;\r\n}\r\nwake_up_interruptible(&keypad_read_wait);\r\n}\r\n}\r\nstatic void phys_scan_contacts(void)\r\n{\r\nint bit, bitval;\r\nchar oldval;\r\nchar bitmask;\r\nchar gndmask;\r\nphys_prev = phys_curr;\r\nphys_read_prev = phys_read;\r\nphys_read = 0;\r\noldval = r_dtr(pprt) | scan_mask_o;\r\nw_dtr(pprt, oldval & ~scan_mask_o);\r\nbitmask = PNL_PINPUT(r_str(pprt)) & scan_mask_i;\r\nw_dtr(pprt, oldval);\r\ngndmask = PNL_PINPUT(r_str(pprt)) & scan_mask_i;\r\nphys_read |= (pmask_t) gndmask << 40;\r\nif (bitmask != gndmask) {\r\nfor (bit = 0; bit < 8; bit++) {\r\nbitval = 1 << bit;\r\nif (!(scan_mask_o & bitval))\r\ncontinue;\r\nw_dtr(pprt, oldval & ~bitval);\r\nbitmask = PNL_PINPUT(r_str(pprt)) & ~gndmask;\r\nphys_read |= (pmask_t) bitmask << (5 * bit);\r\n}\r\nw_dtr(pprt, oldval);\r\n}\r\nphys_curr = (phys_prev & (phys_read ^ phys_read_prev)) |\r\n(phys_read & ~(phys_read ^ phys_read_prev));\r\n}\r\nstatic inline int input_state_high(struct logical_input *input)\r\n{\r\n#if 0\r\nif (((phys_prev & input->mask) == input->value) &&\r\n((phys_curr & input->mask) > input->value)) {\r\ninput->state = INPUT_ST_LOW;\r\nreturn 1;\r\n}\r\n#endif\r\nif ((phys_curr & input->mask) == input->value) {\r\nif ((input->type == INPUT_TYPE_STD) &&\r\n(input->high_timer == 0)) {\r\ninput->high_timer++;\r\nif (input->u.std.press_fct != NULL)\r\ninput->u.std.press_fct(input->u.std.press_data);\r\n} else if (input->type == INPUT_TYPE_KBD) {\r\nkeypressed = 1;\r\nif (input->high_timer == 0) {\r\nchar *press_str = input->u.kbd.press_str;\r\nif (press_str[0]) {\r\nint s = sizeof(input->u.kbd.press_str);\r\nkeypad_send_key(press_str, s);\r\n}\r\n}\r\nif (input->u.kbd.repeat_str[0]) {\r\nchar *repeat_str = input->u.kbd.repeat_str;\r\nif (input->high_timer >= KEYPAD_REP_START) {\r\nint s = sizeof(input->u.kbd.repeat_str);\r\ninput->high_timer -= KEYPAD_REP_DELAY;\r\nkeypad_send_key(repeat_str, s);\r\n}\r\ninputs_stable = 0;\r\n}\r\nif (input->high_timer < 255)\r\ninput->high_timer++;\r\n}\r\nreturn 1;\r\n}\r\ninput->state = INPUT_ST_FALLING;\r\ninput->fall_timer = 0;\r\nreturn 0;\r\n}\r\nstatic inline void input_state_falling(struct logical_input *input)\r\n{\r\n#if 0\r\nif (((phys_prev & input->mask) == input->value) &&\r\n((phys_curr & input->mask) > input->value)) {\r\ninput->state = INPUT_ST_LOW;\r\nreturn;\r\n}\r\n#endif\r\nif ((phys_curr & input->mask) == input->value) {\r\nif (input->type == INPUT_TYPE_KBD) {\r\nkeypressed = 1;\r\nif (input->u.kbd.repeat_str[0]) {\r\nchar *repeat_str = input->u.kbd.repeat_str;\r\nif (input->high_timer >= KEYPAD_REP_START) {\r\nint s = sizeof(input->u.kbd.repeat_str);\r\ninput->high_timer -= KEYPAD_REP_DELAY;\r\nkeypad_send_key(repeat_str, s);\r\n}\r\ninputs_stable = 0;\r\n}\r\nif (input->high_timer < 255)\r\ninput->high_timer++;\r\n}\r\ninput->state = INPUT_ST_HIGH;\r\n} else if (input->fall_timer >= input->fall_time) {\r\nif (input->type == INPUT_TYPE_STD) {\r\nvoid (*release_fct)(int) = input->u.std.release_fct;\r\nif (release_fct != NULL)\r\nrelease_fct(input->u.std.release_data);\r\n} else if (input->type == INPUT_TYPE_KBD) {\r\nchar *release_str = input->u.kbd.release_str;\r\nif (release_str[0]) {\r\nint s = sizeof(input->u.kbd.release_str);\r\nkeypad_send_key(release_str, s);\r\n}\r\n}\r\ninput->state = INPUT_ST_LOW;\r\n} else {\r\ninput->fall_timer++;\r\ninputs_stable = 0;\r\n}\r\n}\r\nstatic void panel_process_inputs(void)\r\n{\r\nstruct list_head *item;\r\nstruct logical_input *input;\r\nkeypressed = 0;\r\ninputs_stable = 1;\r\nlist_for_each(item, &logical_inputs) {\r\ninput = list_entry(item, struct logical_input, list);\r\nswitch (input->state) {\r\ncase INPUT_ST_LOW:\r\nif ((phys_curr & input->mask) != input->value)\r\nbreak;\r\nif ((phys_prev & input->mask) == input->value)\r\nbreak;\r\ninput->rise_timer = 0;\r\ninput->state = INPUT_ST_RISING;\r\ncase INPUT_ST_RISING:\r\nif ((phys_curr & input->mask) != input->value) {\r\ninput->state = INPUT_ST_LOW;\r\nbreak;\r\n}\r\nif (input->rise_timer < input->rise_time) {\r\ninputs_stable = 0;\r\ninput->rise_timer++;\r\nbreak;\r\n}\r\ninput->high_timer = 0;\r\ninput->state = INPUT_ST_HIGH;\r\ncase INPUT_ST_HIGH:\r\nif (input_state_high(input))\r\nbreak;\r\ncase INPUT_ST_FALLING:\r\ninput_state_falling(input);\r\n}\r\n}\r\n}\r\nstatic void panel_scan_timer(void)\r\n{\r\nif (keypad_enabled && keypad_initialized) {\r\nif (spin_trylock_irq(&pprt_lock)) {\r\nphys_scan_contacts();\r\nspin_unlock_irq(&pprt_lock);\r\n}\r\nif (!inputs_stable || phys_curr != phys_prev)\r\npanel_process_inputs();\r\n}\r\nif (lcd_enabled && lcd_initialized) {\r\nif (keypressed) {\r\nif (light_tempo == 0 && ((lcd_flags & LCD_FLAG_L) == 0))\r\nlcd_backlight(1);\r\nlight_tempo = FLASH_LIGHT_TEMPO;\r\n} else if (light_tempo > 0) {\r\nlight_tempo--;\r\nif (light_tempo == 0 && ((lcd_flags & LCD_FLAG_L) == 0))\r\nlcd_backlight(0);\r\n}\r\n}\r\nmod_timer(&scan_timer, jiffies + INPUT_POLL_TIME);\r\n}\r\nstatic void init_scan_timer(void)\r\n{\r\nif (scan_timer.function != NULL)\r\nreturn;\r\ninit_timer(&scan_timer);\r\nscan_timer.expires = jiffies + INPUT_POLL_TIME;\r\nscan_timer.data = 0;\r\nscan_timer.function = (void *)&panel_scan_timer;\r\nadd_timer(&scan_timer);\r\n}\r\nstatic int input_name2mask(const char *name, pmask_t *mask, pmask_t *value,\r\nchar *imask, char *omask)\r\n{\r\nstatic char sigtab[10] = "EeSsPpAaBb";\r\nchar im, om;\r\npmask_t m, v;\r\nom = 0ULL;\r\nim = 0ULL;\r\nm = 0ULL;\r\nv = 0ULL;\r\nwhile (*name) {\r\nint in, out, bit, neg;\r\nfor (in = 0; (in < sizeof(sigtab)) && (sigtab[in] != *name);\r\nin++)\r\n;\r\nif (in >= sizeof(sigtab))\r\nreturn 0;\r\nneg = (in & 1);\r\nin >>= 1;\r\nim |= (1 << in);\r\nname++;\r\nif (isdigit(*name)) {\r\nout = *name - '0';\r\nom |= (1 << out);\r\n} else if (*name == '-') {\r\nout = 8;\r\n} else {\r\nreturn 0;\r\n}\r\nbit = (out * 5) + in;\r\nm |= 1ULL << bit;\r\nif (!neg)\r\nv |= 1ULL << bit;\r\nname++;\r\n}\r\n*mask = m;\r\n*value = v;\r\nif (imask)\r\n*imask |= im;\r\nif (omask)\r\n*omask |= om;\r\nreturn 1;\r\n}\r\nstatic struct logical_input *panel_bind_key(const char *name, const char *press,\r\nconst char *repeat,\r\nconst char *release)\r\n{\r\nstruct logical_input *key;\r\nkey = kzalloc(sizeof(*key), GFP_KERNEL);\r\nif (!key)\r\nreturn NULL;\r\nif (!input_name2mask(name, &key->mask, &key->value, &scan_mask_i,\r\n&scan_mask_o)) {\r\nkfree(key);\r\nreturn NULL;\r\n}\r\nkey->type = INPUT_TYPE_KBD;\r\nkey->state = INPUT_ST_LOW;\r\nkey->rise_time = 1;\r\nkey->fall_time = 1;\r\nstrncpy(key->u.kbd.press_str, press, sizeof(key->u.kbd.press_str));\r\nstrncpy(key->u.kbd.repeat_str, repeat, sizeof(key->u.kbd.repeat_str));\r\nstrncpy(key->u.kbd.release_str, release,\r\nsizeof(key->u.kbd.release_str));\r\nlist_add(&key->list, &logical_inputs);\r\nreturn key;\r\n}\r\nstatic void keypad_init(void)\r\n{\r\nint keynum;\r\ninit_waitqueue_head(&keypad_read_wait);\r\nkeypad_buflen = 0;\r\nfor (keynum = 0; keypad_profile[keynum][0][0]; keynum++) {\r\npanel_bind_key(keypad_profile[keynum][0],\r\nkeypad_profile[keynum][1],\r\nkeypad_profile[keynum][2],\r\nkeypad_profile[keynum][3]);\r\n}\r\ninit_scan_timer();\r\nkeypad_initialized = 1;\r\n}\r\nstatic int panel_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (lcd_enabled && lcd_initialized) {\r\nswitch (code) {\r\ncase SYS_DOWN:\r\npanel_lcd_print\r\n("\x0cReloading\nSystem...\x1b[Lc\x1b[Lb\x1b[L+");\r\nbreak;\r\ncase SYS_HALT:\r\npanel_lcd_print\r\n("\x0cSystem Halted.\x1b[Lc\x1b[Lb\x1b[L+");\r\nbreak;\r\ncase SYS_POWER_OFF:\r\npanel_lcd_print("\x0cPower off.\x1b[Lc\x1b[Lb\x1b[L+");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void panel_attach(struct parport *port)\r\n{\r\nif (port->number != parport)\r\nreturn;\r\nif (pprt) {\r\npr_err("%s: port->number=%d parport=%d, already registered!\n",\r\n__func__, port->number, parport);\r\nreturn;\r\n}\r\npprt = parport_register_device(port, "panel", NULL, NULL,\r\nNULL,\r\n0, (void *)&pprt);\r\nif (pprt == NULL) {\r\npr_err("%s: port->number=%d parport=%d, parport_register_device() failed\n",\r\n__func__, port->number, parport);\r\nreturn;\r\n}\r\nif (parport_claim(pprt)) {\r\npr_err("could not claim access to parport%d. Aborting.\n",\r\nparport);\r\ngoto err_unreg_device;\r\n}\r\nif (lcd_enabled) {\r\nlcd_init();\r\nif (misc_register(&lcd_dev))\r\ngoto err_unreg_device;\r\n}\r\nif (keypad_enabled) {\r\nkeypad_init();\r\nif (misc_register(&keypad_dev))\r\ngoto err_lcd_unreg;\r\n}\r\nreturn;\r\nerr_lcd_unreg:\r\nif (lcd_enabled)\r\nmisc_deregister(&lcd_dev);\r\nerr_unreg_device:\r\nparport_unregister_device(pprt);\r\npprt = NULL;\r\n}\r\nstatic void panel_detach(struct parport *port)\r\n{\r\nif (port->number != parport)\r\nreturn;\r\nif (!pprt) {\r\npr_err("%s: port->number=%d parport=%d, nothing to unregister.\n",\r\n__func__, port->number, parport);\r\nreturn;\r\n}\r\nif (keypad_enabled && keypad_initialized) {\r\nmisc_deregister(&keypad_dev);\r\nkeypad_initialized = 0;\r\n}\r\nif (lcd_enabled && lcd_initialized) {\r\nmisc_deregister(&lcd_dev);\r\nlcd_initialized = 0;\r\n}\r\nparport_release(pprt);\r\nparport_unregister_device(pprt);\r\npprt = NULL;\r\n}\r\nstatic int panel_init(void)\r\n{\r\nif (keypad_type < 0)\r\nkeypad_type = keypad_enabled;\r\nif (lcd_type < 0)\r\nlcd_type = lcd_enabled;\r\nif (parport < 0)\r\nparport = DEFAULT_PARPORT;\r\nswitch (profile) {\r\ncase PANEL_PROFILE_CUSTOM:\r\nif (keypad_type < 0)\r\nkeypad_type = DEFAULT_KEYPAD;\r\nif (lcd_type < 0)\r\nlcd_type = DEFAULT_LCD;\r\nbreak;\r\ncase PANEL_PROFILE_OLD:\r\nif (keypad_type < 0)\r\nkeypad_type = KEYPAD_TYPE_OLD;\r\nif (lcd_type < 0)\r\nlcd_type = LCD_TYPE_OLD;\r\nif (lcd_width < 0)\r\nlcd_width = 16;\r\nif (lcd_hwidth < 0)\r\nlcd_hwidth = 16;\r\nbreak;\r\ncase PANEL_PROFILE_NEW:\r\nif (keypad_type < 0)\r\nkeypad_type = KEYPAD_TYPE_NEW;\r\nif (lcd_type < 0)\r\nlcd_type = LCD_TYPE_KS0074;\r\nbreak;\r\ncase PANEL_PROFILE_HANTRONIX:\r\nif (keypad_type < 0)\r\nkeypad_type = KEYPAD_TYPE_NONE;\r\nif (lcd_type < 0)\r\nlcd_type = LCD_TYPE_HANTRONIX;\r\nbreak;\r\ncase PANEL_PROFILE_NEXCOM:\r\nif (keypad_type < 0)\r\nkeypad_type = KEYPAD_TYPE_NEXCOM;\r\nif (lcd_type < 0)\r\nlcd_type = LCD_TYPE_NEXCOM;\r\nbreak;\r\ncase PANEL_PROFILE_LARGE:\r\nif (keypad_type < 0)\r\nkeypad_type = KEYPAD_TYPE_OLD;\r\nif (lcd_type < 0)\r\nlcd_type = LCD_TYPE_OLD;\r\nbreak;\r\n}\r\nlcd_enabled = (lcd_type > 0);\r\nkeypad_enabled = (keypad_type > 0);\r\nswitch (keypad_type) {\r\ncase KEYPAD_TYPE_OLD:\r\nkeypad_profile = old_keypad_profile;\r\nbreak;\r\ncase KEYPAD_TYPE_NEW:\r\nkeypad_profile = new_keypad_profile;\r\nbreak;\r\ncase KEYPAD_TYPE_NEXCOM:\r\nkeypad_profile = nexcom_keypad_profile;\r\nbreak;\r\ndefault:\r\nkeypad_profile = NULL;\r\nbreak;\r\n}\r\ninit_in_progress = 1;\r\nif (parport_register_driver(&panel_driver)) {\r\npr_err("could not register with parport. Aborting.\n");\r\nreturn -EIO;\r\n}\r\nif (!lcd_enabled && !keypad_enabled) {\r\nif (pprt) {\r\nparport_release(pprt);\r\nparport_unregister_device(pprt);\r\npprt = NULL;\r\n}\r\nparport_unregister_driver(&panel_driver);\r\npr_err("driver version " PANEL_VERSION " disabled.\n");\r\nreturn -ENODEV;\r\n}\r\nregister_reboot_notifier(&panel_notifier);\r\nif (pprt)\r\npr_info("driver version " PANEL_VERSION\r\n" registered on parport%d (io=0x%lx).\n", parport,\r\npprt->port->base);\r\nelse\r\npr_info("driver version " PANEL_VERSION\r\n" not yet registered\n");\r\ninit_in_progress = 0;\r\nreturn 0;\r\n}\r\nstatic int __init panel_init_module(void)\r\n{\r\nreturn panel_init();\r\n}\r\nstatic void __exit panel_cleanup_module(void)\r\n{\r\nunregister_reboot_notifier(&panel_notifier);\r\nif (scan_timer.function != NULL)\r\ndel_timer_sync(&scan_timer);\r\nif (pprt != NULL) {\r\nif (keypad_enabled) {\r\nmisc_deregister(&keypad_dev);\r\nkeypad_initialized = 0;\r\n}\r\nif (lcd_enabled) {\r\npanel_lcd_print("\x0cLCD driver " PANEL_VERSION\r\n"\nunloaded.\x1b[Lc\x1b[Lb\x1b[L-");\r\nmisc_deregister(&lcd_dev);\r\nlcd_initialized = 0;\r\n}\r\nparport_release(pprt);\r\nparport_unregister_device(pprt);\r\npprt = NULL;\r\n}\r\nparport_unregister_driver(&panel_driver);\r\n}
