static struct intel_sdvo *to_sdvo(struct intel_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct intel_sdvo, base);\r\n}\r\nstatic struct intel_sdvo *intel_attached_sdvo(struct drm_connector *connector)\r\n{\r\nreturn to_sdvo(intel_attached_encoder(connector));\r\n}\r\nstatic struct intel_sdvo_connector *to_intel_sdvo_connector(struct drm_connector *connector)\r\n{\r\nreturn container_of(to_intel_connector(connector), struct intel_sdvo_connector, base);\r\n}\r\nstatic void intel_sdvo_write_sdvox(struct intel_sdvo *intel_sdvo, u32 val)\r\n{\r\nstruct drm_device *dev = intel_sdvo->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 bval = val, cval = val;\r\nint i;\r\nif (intel_sdvo->sdvo_reg == PCH_SDVOB) {\r\nI915_WRITE(intel_sdvo->sdvo_reg, val);\r\nI915_READ(intel_sdvo->sdvo_reg);\r\nreturn;\r\n}\r\nif (intel_sdvo->sdvo_reg == GEN3_SDVOB)\r\ncval = I915_READ(GEN3_SDVOC);\r\nelse\r\nbval = I915_READ(GEN3_SDVOB);\r\nfor (i = 0; i < 2; i++)\r\n{\r\nI915_WRITE(GEN3_SDVOB, bval);\r\nI915_READ(GEN3_SDVOB);\r\nI915_WRITE(GEN3_SDVOC, cval);\r\nI915_READ(GEN3_SDVOC);\r\n}\r\n}\r\nstatic bool intel_sdvo_read_byte(struct intel_sdvo *intel_sdvo, u8 addr, u8 *ch)\r\n{\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = intel_sdvo->slave_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &addr,\r\n},\r\n{\r\n.addr = intel_sdvo->slave_addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = ch,\r\n}\r\n};\r\nint ret;\r\nif ((ret = i2c_transfer(intel_sdvo->i2c, msgs, 2)) == 2)\r\nreturn true;\r\nDRM_DEBUG_KMS("i2c transfer returned %d\n", ret);\r\nreturn false;\r\n}\r\nstatic void intel_sdvo_debug_write(struct intel_sdvo *intel_sdvo, u8 cmd,\r\nconst void *args, int args_len)\r\n{\r\nint i, pos = 0;\r\n#define BUF_LEN 256\r\nchar buffer[BUF_LEN];\r\n#define BUF_PRINT(args...) \\r\npos += snprintf(buffer + pos, max_t(int, BUF_LEN - pos, 0), args)\r\nfor (i = 0; i < args_len; i++) {\r\nBUF_PRINT("%02X ", ((u8 *)args)[i]);\r\n}\r\nfor (; i < 8; i++) {\r\nBUF_PRINT(" ");\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sdvo_cmd_names); i++) {\r\nif (cmd == sdvo_cmd_names[i].cmd) {\r\nBUF_PRINT("(%s)", sdvo_cmd_names[i].name);\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(sdvo_cmd_names)) {\r\nBUF_PRINT("(%02X)", cmd);\r\n}\r\nBUG_ON(pos >= BUF_LEN - 1);\r\n#undef BUF_PRINT\r\n#undef BUF_LEN\r\nDRM_DEBUG_KMS("%s: W: %02X %s\n", SDVO_NAME(intel_sdvo), cmd, buffer);\r\n}\r\nstatic bool intel_sdvo_write_cmd(struct intel_sdvo *intel_sdvo, u8 cmd,\r\nconst void *args, int args_len)\r\n{\r\nu8 *buf, status;\r\nstruct i2c_msg *msgs;\r\nint i, ret = true;\r\nbuf = kzalloc(args_len * 2 + 2, GFP_KERNEL);\r\nif (!buf)\r\nreturn false;\r\nmsgs = kcalloc(args_len + 3, sizeof(*msgs), GFP_KERNEL);\r\nif (!msgs) {\r\nkfree(buf);\r\nreturn false;\r\n}\r\nintel_sdvo_debug_write(intel_sdvo, cmd, args, args_len);\r\nfor (i = 0; i < args_len; i++) {\r\nmsgs[i].addr = intel_sdvo->slave_addr;\r\nmsgs[i].flags = 0;\r\nmsgs[i].len = 2;\r\nmsgs[i].buf = buf + 2 *i;\r\nbuf[2*i + 0] = SDVO_I2C_ARG_0 - i;\r\nbuf[2*i + 1] = ((u8*)args)[i];\r\n}\r\nmsgs[i].addr = intel_sdvo->slave_addr;\r\nmsgs[i].flags = 0;\r\nmsgs[i].len = 2;\r\nmsgs[i].buf = buf + 2*i;\r\nbuf[2*i + 0] = SDVO_I2C_OPCODE;\r\nbuf[2*i + 1] = cmd;\r\nstatus = SDVO_I2C_CMD_STATUS;\r\nmsgs[i+1].addr = intel_sdvo->slave_addr;\r\nmsgs[i+1].flags = 0;\r\nmsgs[i+1].len = 1;\r\nmsgs[i+1].buf = &status;\r\nmsgs[i+2].addr = intel_sdvo->slave_addr;\r\nmsgs[i+2].flags = I2C_M_RD;\r\nmsgs[i+2].len = 1;\r\nmsgs[i+2].buf = &status;\r\nret = i2c_transfer(intel_sdvo->i2c, msgs, i+3);\r\nif (ret < 0) {\r\nDRM_DEBUG_KMS("I2c transfer returned %d\n", ret);\r\nret = false;\r\ngoto out;\r\n}\r\nif (ret != i+3) {\r\nDRM_DEBUG_KMS("I2c transfer returned %d/%d\n", ret, i+3);\r\nret = false;\r\n}\r\nout:\r\nkfree(msgs);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic bool intel_sdvo_read_response(struct intel_sdvo *intel_sdvo,\r\nvoid *response, int response_len)\r\n{\r\nu8 retry = 15;\r\nu8 status;\r\nint i, pos = 0;\r\n#define BUF_LEN 256\r\nchar buffer[BUF_LEN];\r\nif (!intel_sdvo_read_byte(intel_sdvo,\r\nSDVO_I2C_CMD_STATUS,\r\n&status))\r\ngoto log_fail;\r\nwhile ((status == SDVO_CMD_STATUS_PENDING ||\r\nstatus == SDVO_CMD_STATUS_TARGET_NOT_SPECIFIED) && --retry) {\r\nif (retry < 10)\r\nmsleep(15);\r\nelse\r\nudelay(15);\r\nif (!intel_sdvo_read_byte(intel_sdvo,\r\nSDVO_I2C_CMD_STATUS,\r\n&status))\r\ngoto log_fail;\r\n}\r\n#define BUF_PRINT(args...) \\r\npos += snprintf(buffer + pos, max_t(int, BUF_LEN - pos, 0), args)\r\nif (status <= SDVO_CMD_STATUS_SCALING_NOT_SUPP)\r\nBUF_PRINT("(%s)", cmd_status_names[status]);\r\nelse\r\nBUF_PRINT("(??? %d)", status);\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\ngoto log_fail;\r\nfor (i = 0; i < response_len; i++) {\r\nif (!intel_sdvo_read_byte(intel_sdvo,\r\nSDVO_I2C_RETURN_0 + i,\r\n&((u8 *)response)[i]))\r\ngoto log_fail;\r\nBUF_PRINT(" %02X", ((u8 *)response)[i]);\r\n}\r\nBUG_ON(pos >= BUF_LEN - 1);\r\n#undef BUF_PRINT\r\n#undef BUF_LEN\r\nDRM_DEBUG_KMS("%s: R: %s\n", SDVO_NAME(intel_sdvo), buffer);\r\nreturn true;\r\nlog_fail:\r\nDRM_DEBUG_KMS("%s: R: ... failed\n", SDVO_NAME(intel_sdvo));\r\nreturn false;\r\n}\r\nstatic int intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode)\r\n{\r\nif (mode->clock >= 100000)\r\nreturn 1;\r\nelse if (mode->clock >= 50000)\r\nreturn 2;\r\nelse\r\nreturn 4;\r\n}\r\nstatic bool intel_sdvo_set_control_bus_switch(struct intel_sdvo *intel_sdvo,\r\nu8 ddc_bus)\r\n{\r\nreturn intel_sdvo_write_cmd(intel_sdvo,\r\nSDVO_CMD_SET_CONTROL_BUS_SWITCH,\r\n&ddc_bus, 1);\r\n}\r\nstatic bool intel_sdvo_set_value(struct intel_sdvo *intel_sdvo, u8 cmd, const void *data, int len)\r\n{\r\nif (!intel_sdvo_write_cmd(intel_sdvo, cmd, data, len))\r\nreturn false;\r\nreturn intel_sdvo_read_response(intel_sdvo, NULL, 0);\r\n}\r\nstatic bool\r\nintel_sdvo_get_value(struct intel_sdvo *intel_sdvo, u8 cmd, void *value, int len)\r\n{\r\nif (!intel_sdvo_write_cmd(intel_sdvo, cmd, NULL, 0))\r\nreturn false;\r\nreturn intel_sdvo_read_response(intel_sdvo, value, len);\r\n}\r\nstatic bool intel_sdvo_set_target_input(struct intel_sdvo *intel_sdvo)\r\n{\r\nstruct intel_sdvo_set_target_input_args targets = {0};\r\nreturn intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_TARGET_INPUT,\r\n&targets, sizeof(targets));\r\n}\r\nstatic bool intel_sdvo_get_trained_inputs(struct intel_sdvo *intel_sdvo, bool *input_1, bool *input_2)\r\n{\r\nstruct intel_sdvo_get_trained_inputs_response response;\r\nBUILD_BUG_ON(sizeof(response) != 1);\r\nif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_TRAINED_INPUTS,\r\n&response, sizeof(response)))\r\nreturn false;\r\n*input_1 = response.input0_trained;\r\n*input_2 = response.input1_trained;\r\nreturn true;\r\n}\r\nstatic bool intel_sdvo_set_active_outputs(struct intel_sdvo *intel_sdvo,\r\nu16 outputs)\r\n{\r\nreturn intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_ACTIVE_OUTPUTS,\r\n&outputs, sizeof(outputs));\r\n}\r\nstatic bool intel_sdvo_get_active_outputs(struct intel_sdvo *intel_sdvo,\r\nu16 *outputs)\r\n{\r\nreturn intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_ACTIVE_OUTPUTS,\r\noutputs, sizeof(*outputs));\r\n}\r\nstatic bool intel_sdvo_set_encoder_power_state(struct intel_sdvo *intel_sdvo,\r\nint mode)\r\n{\r\nu8 state = SDVO_ENCODER_STATE_ON;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nstate = SDVO_ENCODER_STATE_ON;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\nstate = SDVO_ENCODER_STATE_STANDBY;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nstate = SDVO_ENCODER_STATE_SUSPEND;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nstate = SDVO_ENCODER_STATE_OFF;\r\nbreak;\r\n}\r\nreturn intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_ENCODER_POWER_STATE, &state, sizeof(state));\r\n}\r\nstatic bool intel_sdvo_get_input_pixel_clock_range(struct intel_sdvo *intel_sdvo,\r\nint *clock_min,\r\nint *clock_max)\r\n{\r\nstruct intel_sdvo_pixel_clock_range clocks;\r\nBUILD_BUG_ON(sizeof(clocks) != 4);\r\nif (!intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE,\r\n&clocks, sizeof(clocks)))\r\nreturn false;\r\n*clock_min = clocks.min * 10;\r\n*clock_max = clocks.max * 10;\r\nreturn true;\r\n}\r\nstatic bool intel_sdvo_set_target_output(struct intel_sdvo *intel_sdvo,\r\nu16 outputs)\r\n{\r\nreturn intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_TARGET_OUTPUT,\r\n&outputs, sizeof(outputs));\r\n}\r\nstatic bool intel_sdvo_set_timing(struct intel_sdvo *intel_sdvo, u8 cmd,\r\nstruct intel_sdvo_dtd *dtd)\r\n{\r\nreturn intel_sdvo_set_value(intel_sdvo, cmd, &dtd->part1, sizeof(dtd->part1)) &&\r\nintel_sdvo_set_value(intel_sdvo, cmd + 1, &dtd->part2, sizeof(dtd->part2));\r\n}\r\nstatic bool intel_sdvo_get_timing(struct intel_sdvo *intel_sdvo, u8 cmd,\r\nstruct intel_sdvo_dtd *dtd)\r\n{\r\nreturn intel_sdvo_get_value(intel_sdvo, cmd, &dtd->part1, sizeof(dtd->part1)) &&\r\nintel_sdvo_get_value(intel_sdvo, cmd + 1, &dtd->part2, sizeof(dtd->part2));\r\n}\r\nstatic bool intel_sdvo_set_input_timing(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_dtd *dtd)\r\n{\r\nreturn intel_sdvo_set_timing(intel_sdvo,\r\nSDVO_CMD_SET_INPUT_TIMINGS_PART1, dtd);\r\n}\r\nstatic bool intel_sdvo_set_output_timing(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_dtd *dtd)\r\n{\r\nreturn intel_sdvo_set_timing(intel_sdvo,\r\nSDVO_CMD_SET_OUTPUT_TIMINGS_PART1, dtd);\r\n}\r\nstatic bool intel_sdvo_get_input_timing(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_dtd *dtd)\r\n{\r\nreturn intel_sdvo_get_timing(intel_sdvo,\r\nSDVO_CMD_GET_INPUT_TIMINGS_PART1, dtd);\r\n}\r\nstatic bool\r\nintel_sdvo_create_preferred_input_timing(struct intel_sdvo *intel_sdvo,\r\nuint16_t clock,\r\nuint16_t width,\r\nuint16_t height)\r\n{\r\nstruct intel_sdvo_preferred_input_timing_args args;\r\nmemset(&args, 0, sizeof(args));\r\nargs.clock = clock;\r\nargs.width = width;\r\nargs.height = height;\r\nargs.interlace = 0;\r\nif (intel_sdvo->is_lvds &&\r\n(intel_sdvo->sdvo_lvds_fixed_mode->hdisplay != width ||\r\nintel_sdvo->sdvo_lvds_fixed_mode->vdisplay != height))\r\nargs.scaled = 1;\r\nreturn intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_CREATE_PREFERRED_INPUT_TIMING,\r\n&args, sizeof(args));\r\n}\r\nstatic bool intel_sdvo_get_preferred_input_timing(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_dtd *dtd)\r\n{\r\nBUILD_BUG_ON(sizeof(dtd->part1) != 8);\r\nBUILD_BUG_ON(sizeof(dtd->part2) != 8);\r\nreturn intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1,\r\n&dtd->part1, sizeof(dtd->part1)) &&\r\nintel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2,\r\n&dtd->part2, sizeof(dtd->part2));\r\n}\r\nstatic bool intel_sdvo_set_clock_rate_mult(struct intel_sdvo *intel_sdvo, u8 val)\r\n{\r\nreturn intel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_CLOCK_RATE_MULT, &val, 1);\r\n}\r\nstatic void intel_sdvo_get_dtd_from_mode(struct intel_sdvo_dtd *dtd,\r\nconst struct drm_display_mode *mode)\r\n{\r\nuint16_t width, height;\r\nuint16_t h_blank_len, h_sync_len, v_blank_len, v_sync_len;\r\nuint16_t h_sync_offset, v_sync_offset;\r\nint mode_clock;\r\nmemset(dtd, 0, sizeof(*dtd));\r\nwidth = mode->hdisplay;\r\nheight = mode->vdisplay;\r\nh_blank_len = mode->htotal - mode->hdisplay;\r\nh_sync_len = mode->hsync_end - mode->hsync_start;\r\nv_blank_len = mode->vtotal - mode->vdisplay;\r\nv_sync_len = mode->vsync_end - mode->vsync_start;\r\nh_sync_offset = mode->hsync_start - mode->hdisplay;\r\nv_sync_offset = mode->vsync_start - mode->vdisplay;\r\nmode_clock = mode->clock;\r\nmode_clock /= 10;\r\ndtd->part1.clock = mode_clock;\r\ndtd->part1.h_active = width & 0xff;\r\ndtd->part1.h_blank = h_blank_len & 0xff;\r\ndtd->part1.h_high = (((width >> 8) & 0xf) << 4) |\r\n((h_blank_len >> 8) & 0xf);\r\ndtd->part1.v_active = height & 0xff;\r\ndtd->part1.v_blank = v_blank_len & 0xff;\r\ndtd->part1.v_high = (((height >> 8) & 0xf) << 4) |\r\n((v_blank_len >> 8) & 0xf);\r\ndtd->part2.h_sync_off = h_sync_offset & 0xff;\r\ndtd->part2.h_sync_width = h_sync_len & 0xff;\r\ndtd->part2.v_sync_off_width = (v_sync_offset & 0xf) << 4 |\r\n(v_sync_len & 0xf);\r\ndtd->part2.sync_off_width_high = ((h_sync_offset & 0x300) >> 2) |\r\n((h_sync_len & 0x300) >> 4) | ((v_sync_offset & 0x30) >> 2) |\r\n((v_sync_len & 0x30) >> 4);\r\ndtd->part2.dtd_flags = 0x18;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\ndtd->part2.dtd_flags |= DTD_FLAG_INTERLACE;\r\nif (mode->flags & DRM_MODE_FLAG_PHSYNC)\r\ndtd->part2.dtd_flags |= DTD_FLAG_HSYNC_POSITIVE;\r\nif (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\ndtd->part2.dtd_flags |= DTD_FLAG_VSYNC_POSITIVE;\r\ndtd->part2.v_sync_off_high = v_sync_offset & 0xc0;\r\n}\r\nstatic void intel_sdvo_get_mode_from_dtd(struct drm_display_mode *pmode,\r\nconst struct intel_sdvo_dtd *dtd)\r\n{\r\nstruct drm_display_mode mode = {};\r\nmode.hdisplay = dtd->part1.h_active;\r\nmode.hdisplay += ((dtd->part1.h_high >> 4) & 0x0f) << 8;\r\nmode.hsync_start = mode.hdisplay + dtd->part2.h_sync_off;\r\nmode.hsync_start += (dtd->part2.sync_off_width_high & 0xc0) << 2;\r\nmode.hsync_end = mode.hsync_start + dtd->part2.h_sync_width;\r\nmode.hsync_end += (dtd->part2.sync_off_width_high & 0x30) << 4;\r\nmode.htotal = mode.hdisplay + dtd->part1.h_blank;\r\nmode.htotal += (dtd->part1.h_high & 0xf) << 8;\r\nmode.vdisplay = dtd->part1.v_active;\r\nmode.vdisplay += ((dtd->part1.v_high >> 4) & 0x0f) << 8;\r\nmode.vsync_start = mode.vdisplay;\r\nmode.vsync_start += (dtd->part2.v_sync_off_width >> 4) & 0xf;\r\nmode.vsync_start += (dtd->part2.sync_off_width_high & 0x0c) << 2;\r\nmode.vsync_start += dtd->part2.v_sync_off_high & 0xc0;\r\nmode.vsync_end = mode.vsync_start +\r\n(dtd->part2.v_sync_off_width & 0xf);\r\nmode.vsync_end += (dtd->part2.sync_off_width_high & 0x3) << 4;\r\nmode.vtotal = mode.vdisplay + dtd->part1.v_blank;\r\nmode.vtotal += (dtd->part1.v_high & 0xf) << 8;\r\nmode.clock = dtd->part1.clock * 10;\r\nif (dtd->part2.dtd_flags & DTD_FLAG_INTERLACE)\r\nmode.flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (dtd->part2.dtd_flags & DTD_FLAG_HSYNC_POSITIVE)\r\nmode.flags |= DRM_MODE_FLAG_PHSYNC;\r\nelse\r\nmode.flags |= DRM_MODE_FLAG_NHSYNC;\r\nif (dtd->part2.dtd_flags & DTD_FLAG_VSYNC_POSITIVE)\r\nmode.flags |= DRM_MODE_FLAG_PVSYNC;\r\nelse\r\nmode.flags |= DRM_MODE_FLAG_NVSYNC;\r\ndrm_mode_set_crtcinfo(&mode, 0);\r\ndrm_mode_copy(pmode, &mode);\r\n}\r\nstatic bool intel_sdvo_check_supp_encode(struct intel_sdvo *intel_sdvo)\r\n{\r\nstruct intel_sdvo_encode encode;\r\nBUILD_BUG_ON(sizeof(encode) != 2);\r\nreturn intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_SUPP_ENCODE,\r\n&encode, sizeof(encode));\r\n}\r\nstatic bool intel_sdvo_set_encode(struct intel_sdvo *intel_sdvo,\r\nuint8_t mode)\r\n{\r\nreturn intel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_ENCODE, &mode, 1);\r\n}\r\nstatic bool intel_sdvo_set_colorimetry(struct intel_sdvo *intel_sdvo,\r\nuint8_t mode)\r\n{\r\nreturn intel_sdvo_set_value(intel_sdvo, SDVO_CMD_SET_COLORIMETRY, &mode, 1);\r\n}\r\nstatic bool intel_sdvo_write_infoframe(struct intel_sdvo *intel_sdvo,\r\nunsigned if_index, uint8_t tx_rate,\r\nconst uint8_t *data, unsigned length)\r\n{\r\nuint8_t set_buf_index[2] = { if_index, 0 };\r\nuint8_t hbuf_size, tmp[8];\r\nint i;\r\nif (!intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_HBUF_INDEX,\r\nset_buf_index, 2))\r\nreturn false;\r\nif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_HBUF_INFO,\r\n&hbuf_size, 1))\r\nreturn false;\r\nhbuf_size++;\r\nDRM_DEBUG_KMS("writing sdvo hbuf: %i, hbuf_size %i, hbuf_size: %i\n",\r\nif_index, length, hbuf_size);\r\nfor (i = 0; i < hbuf_size; i += 8) {\r\nmemset(tmp, 0, 8);\r\nif (i < length)\r\nmemcpy(tmp, data + i, min_t(unsigned, 8, length - i));\r\nif (!intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_HBUF_DATA,\r\ntmp, 8))\r\nreturn false;\r\n}\r\nreturn intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_HBUF_TXRATE,\r\n&tx_rate, 1);\r\n}\r\nstatic bool intel_sdvo_set_avi_infoframe(struct intel_sdvo *intel_sdvo,\r\nconst struct drm_display_mode *adjusted_mode)\r\n{\r\nuint8_t sdvo_data[HDMI_INFOFRAME_SIZE(AVI)];\r\nstruct drm_crtc *crtc = intel_sdvo->base.base.crtc;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(crtc);\r\nunion hdmi_infoframe frame;\r\nint ret;\r\nssize_t len;\r\nret = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi,\r\nadjusted_mode);\r\nif (ret < 0) {\r\nDRM_ERROR("couldn't fill AVI infoframe\n");\r\nreturn false;\r\n}\r\nif (intel_sdvo->rgb_quant_range_selectable) {\r\nif (intel_crtc->config.limited_color_range)\r\nframe.avi.quantization_range =\r\nHDMI_QUANTIZATION_RANGE_LIMITED;\r\nelse\r\nframe.avi.quantization_range =\r\nHDMI_QUANTIZATION_RANGE_FULL;\r\n}\r\nlen = hdmi_infoframe_pack(&frame, sdvo_data, sizeof(sdvo_data));\r\nif (len < 0)\r\nreturn false;\r\nreturn intel_sdvo_write_infoframe(intel_sdvo, SDVO_HBUF_INDEX_AVI_IF,\r\nSDVO_HBUF_TX_VSYNC,\r\nsdvo_data, sizeof(sdvo_data));\r\n}\r\nstatic bool intel_sdvo_set_tv_format(struct intel_sdvo *intel_sdvo)\r\n{\r\nstruct intel_sdvo_tv_format format;\r\nuint32_t format_map;\r\nformat_map = 1 << intel_sdvo->tv_format_index;\r\nmemset(&format, 0, sizeof(format));\r\nmemcpy(&format, &format_map, min(sizeof(format), sizeof(format_map)));\r\nBUILD_BUG_ON(sizeof(format) != 6);\r\nreturn intel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_TV_FORMAT,\r\n&format, sizeof(format));\r\n}\r\nstatic bool\r\nintel_sdvo_set_output_timings_from_mode(struct intel_sdvo *intel_sdvo,\r\nconst struct drm_display_mode *mode)\r\n{\r\nstruct intel_sdvo_dtd output_dtd;\r\nif (!intel_sdvo_set_target_output(intel_sdvo,\r\nintel_sdvo->attached_output))\r\nreturn false;\r\nintel_sdvo_get_dtd_from_mode(&output_dtd, mode);\r\nif (!intel_sdvo_set_output_timing(intel_sdvo, &output_dtd))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nintel_sdvo_get_preferred_input_mode(struct intel_sdvo *intel_sdvo,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct intel_sdvo_dtd input_dtd;\r\nif (!intel_sdvo_set_target_input(intel_sdvo))\r\nreturn false;\r\nif (!intel_sdvo_create_preferred_input_timing(intel_sdvo,\r\nmode->clock / 10,\r\nmode->hdisplay,\r\nmode->vdisplay))\r\nreturn false;\r\nif (!intel_sdvo_get_preferred_input_timing(intel_sdvo,\r\n&input_dtd))\r\nreturn false;\r\nintel_sdvo_get_mode_from_dtd(adjusted_mode, &input_dtd);\r\nintel_sdvo->dtd_sdvo_flags = input_dtd.part2.sdvo_flags;\r\nreturn true;\r\n}\r\nstatic void i9xx_adjust_sdvo_tv_clock(struct intel_crtc_config *pipe_config)\r\n{\r\nunsigned dotclock = pipe_config->port_clock;\r\nstruct dpll *clock = &pipe_config->dpll;\r\nif (dotclock >= 100000 && dotclock < 140500) {\r\nclock->p1 = 2;\r\nclock->p2 = 10;\r\nclock->n = 3;\r\nclock->m1 = 16;\r\nclock->m2 = 8;\r\n} else if (dotclock >= 140500 && dotclock <= 200000) {\r\nclock->p1 = 1;\r\nclock->p2 = 10;\r\nclock->n = 6;\r\nclock->m1 = 12;\r\nclock->m2 = 8;\r\n} else {\r\nWARN(1, "SDVO TV clock out of range: %i\n", dotclock);\r\n}\r\npipe_config->clock_set = true;\r\n}\r\nstatic bool intel_sdvo_compute_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\nstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\r\nstruct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;\r\nstruct drm_display_mode *mode = &pipe_config->requested_mode;\r\nDRM_DEBUG_KMS("forcing bpc to 8 for SDVO\n");\r\npipe_config->pipe_bpp = 8*3;\r\nif (HAS_PCH_SPLIT(encoder->base.dev))\r\npipe_config->has_pch_encoder = true;\r\nif (intel_sdvo->is_tv) {\r\nif (!intel_sdvo_set_output_timings_from_mode(intel_sdvo, mode))\r\nreturn false;\r\n(void) intel_sdvo_get_preferred_input_mode(intel_sdvo,\r\nmode,\r\nadjusted_mode);\r\npipe_config->sdvo_tv_clock = true;\r\n} else if (intel_sdvo->is_lvds) {\r\nif (!intel_sdvo_set_output_timings_from_mode(intel_sdvo,\r\nintel_sdvo->sdvo_lvds_fixed_mode))\r\nreturn false;\r\n(void) intel_sdvo_get_preferred_input_mode(intel_sdvo,\r\nmode,\r\nadjusted_mode);\r\n}\r\npipe_config->pixel_multiplier =\r\nintel_sdvo_get_pixel_multiplier(adjusted_mode);\r\npipe_config->has_hdmi_sink = intel_sdvo->has_hdmi_monitor;\r\nif (intel_sdvo->color_range_auto) {\r\nif (pipe_config->has_hdmi_sink &&\r\ndrm_match_cea_mode(adjusted_mode) > 1)\r\npipe_config->limited_color_range = true;\r\n} else {\r\nif (pipe_config->has_hdmi_sink &&\r\nintel_sdvo->color_range == HDMI_COLOR_RANGE_16_235)\r\npipe_config->limited_color_range = true;\r\n}\r\nif (intel_sdvo->is_tv)\r\ni9xx_adjust_sdvo_tv_clock(pipe_config);\r\nreturn true;\r\n}\r\nstatic void intel_sdvo_pre_enable(struct intel_encoder *intel_encoder)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *crtc = to_intel_crtc(intel_encoder->base.crtc);\r\nstruct drm_display_mode *adjusted_mode =\r\n&crtc->config.adjusted_mode;\r\nstruct drm_display_mode *mode = &crtc->config.requested_mode;\r\nstruct intel_sdvo *intel_sdvo = to_sdvo(intel_encoder);\r\nu32 sdvox;\r\nstruct intel_sdvo_in_out_map in_out;\r\nstruct intel_sdvo_dtd input_dtd, output_dtd;\r\nint rate;\r\nif (!mode)\r\nreturn;\r\nin_out.in0 = intel_sdvo->attached_output;\r\nin_out.in1 = 0;\r\nintel_sdvo_set_value(intel_sdvo,\r\nSDVO_CMD_SET_IN_OUT_MAP,\r\n&in_out, sizeof(in_out));\r\nif (!intel_sdvo_set_target_output(intel_sdvo,\r\nintel_sdvo->attached_output))\r\nreturn;\r\nif (intel_sdvo->is_lvds)\r\nintel_sdvo_get_dtd_from_mode(&output_dtd,\r\nintel_sdvo->sdvo_lvds_fixed_mode);\r\nelse\r\nintel_sdvo_get_dtd_from_mode(&output_dtd, mode);\r\nif (!intel_sdvo_set_output_timing(intel_sdvo, &output_dtd))\r\nDRM_INFO("Setting output timings on %s failed\n",\r\nSDVO_NAME(intel_sdvo));\r\nif (!intel_sdvo_set_target_input(intel_sdvo))\r\nreturn;\r\nif (crtc->config.has_hdmi_sink) {\r\nintel_sdvo_set_encode(intel_sdvo, SDVO_ENCODE_HDMI);\r\nintel_sdvo_set_colorimetry(intel_sdvo,\r\nSDVO_COLORIMETRY_RGB256);\r\nintel_sdvo_set_avi_infoframe(intel_sdvo, adjusted_mode);\r\n} else\r\nintel_sdvo_set_encode(intel_sdvo, SDVO_ENCODE_DVI);\r\nif (intel_sdvo->is_tv &&\r\n!intel_sdvo_set_tv_format(intel_sdvo))\r\nreturn;\r\nintel_sdvo_get_dtd_from_mode(&input_dtd, adjusted_mode);\r\nif (intel_sdvo->is_tv || intel_sdvo->is_lvds)\r\ninput_dtd.part2.sdvo_flags = intel_sdvo->dtd_sdvo_flags;\r\nif (!intel_sdvo_set_input_timing(intel_sdvo, &input_dtd))\r\nDRM_INFO("Setting input timings on %s failed\n",\r\nSDVO_NAME(intel_sdvo));\r\nswitch (crtc->config.pixel_multiplier) {\r\ndefault:\r\nWARN(1, "unknown pixel mutlipler specified\n");\r\ncase 1: rate = SDVO_CLOCK_RATE_MULT_1X; break;\r\ncase 2: rate = SDVO_CLOCK_RATE_MULT_2X; break;\r\ncase 4: rate = SDVO_CLOCK_RATE_MULT_4X; break;\r\n}\r\nif (!intel_sdvo_set_clock_rate_mult(intel_sdvo, rate))\r\nreturn;\r\nif (INTEL_INFO(dev)->gen >= 4) {\r\nsdvox = SDVO_VSYNC_ACTIVE_HIGH | SDVO_HSYNC_ACTIVE_HIGH;\r\nif (!HAS_PCH_SPLIT(dev) && crtc->config.limited_color_range)\r\nsdvox |= HDMI_COLOR_RANGE_16_235;\r\nif (INTEL_INFO(dev)->gen < 5)\r\nsdvox |= SDVO_BORDER_ENABLE;\r\n} else {\r\nsdvox = I915_READ(intel_sdvo->sdvo_reg);\r\nswitch (intel_sdvo->sdvo_reg) {\r\ncase GEN3_SDVOB:\r\nsdvox &= SDVOB_PRESERVE_MASK;\r\nbreak;\r\ncase GEN3_SDVOC:\r\nsdvox &= SDVOC_PRESERVE_MASK;\r\nbreak;\r\n}\r\nsdvox |= (9 << 19) | SDVO_BORDER_ENABLE;\r\n}\r\nif (INTEL_PCH_TYPE(dev) >= PCH_CPT)\r\nsdvox |= SDVO_PIPE_SEL_CPT(crtc->pipe);\r\nelse\r\nsdvox |= SDVO_PIPE_SEL(crtc->pipe);\r\nif (intel_sdvo->has_hdmi_audio)\r\nsdvox |= SDVO_AUDIO_ENABLE;\r\nif (INTEL_INFO(dev)->gen >= 4) {\r\n} else if (IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev)) {\r\n} else {\r\nsdvox |= (crtc->config.pixel_multiplier - 1)\r\n<< SDVO_PORT_MULTIPLY_SHIFT;\r\n}\r\nif (input_dtd.part2.sdvo_flags & SDVO_NEED_TO_STALL &&\r\nINTEL_INFO(dev)->gen < 5)\r\nsdvox |= SDVO_STALL_SELECT;\r\nintel_sdvo_write_sdvox(intel_sdvo, sdvox);\r\n}\r\nstatic bool intel_sdvo_connector_get_hw_state(struct intel_connector *connector)\r\n{\r\nstruct intel_sdvo_connector *intel_sdvo_connector =\r\nto_intel_sdvo_connector(&connector->base);\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(&connector->base);\r\nu16 active_outputs = 0;\r\nintel_sdvo_get_active_outputs(intel_sdvo, &active_outputs);\r\nif (active_outputs & intel_sdvo_connector->output_flag)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool intel_sdvo_get_hw_state(struct intel_encoder *encoder,\r\nenum pipe *pipe)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\r\nu16 active_outputs = 0;\r\nu32 tmp;\r\ntmp = I915_READ(intel_sdvo->sdvo_reg);\r\nintel_sdvo_get_active_outputs(intel_sdvo, &active_outputs);\r\nif (!(tmp & SDVO_ENABLE) && (active_outputs == 0))\r\nreturn false;\r\nif (HAS_PCH_CPT(dev))\r\n*pipe = PORT_TO_PIPE_CPT(tmp);\r\nelse\r\n*pipe = PORT_TO_PIPE(tmp);\r\nreturn true;\r\n}\r\nstatic void intel_sdvo_get_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\r\nstruct intel_sdvo_dtd dtd;\r\nint encoder_pixel_multiplier = 0;\r\nint dotclock;\r\nu32 flags = 0, sdvox;\r\nu8 val;\r\nbool ret;\r\nsdvox = I915_READ(intel_sdvo->sdvo_reg);\r\nret = intel_sdvo_get_input_timing(intel_sdvo, &dtd);\r\nif (!ret) {\r\nDRM_DEBUG_DRIVER("failed to retrieve SDVO DTD\n");\r\npipe_config->quirks |= PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS;\r\n} else {\r\nif (dtd.part2.dtd_flags & DTD_FLAG_HSYNC_POSITIVE)\r\nflags |= DRM_MODE_FLAG_PHSYNC;\r\nelse\r\nflags |= DRM_MODE_FLAG_NHSYNC;\r\nif (dtd.part2.dtd_flags & DTD_FLAG_VSYNC_POSITIVE)\r\nflags |= DRM_MODE_FLAG_PVSYNC;\r\nelse\r\nflags |= DRM_MODE_FLAG_NVSYNC;\r\n}\r\npipe_config->adjusted_mode.flags |= flags;\r\nif (IS_I915G(dev) || IS_I915GM(dev)) {\r\npipe_config->pixel_multiplier =\r\n((sdvox & SDVO_PORT_MULTIPLY_MASK)\r\n>> SDVO_PORT_MULTIPLY_SHIFT) + 1;\r\n}\r\ndotclock = pipe_config->port_clock;\r\nif (pipe_config->pixel_multiplier)\r\ndotclock /= pipe_config->pixel_multiplier;\r\nif (HAS_PCH_SPLIT(dev))\r\nironlake_check_encoder_dotclock(pipe_config, dotclock);\r\npipe_config->adjusted_mode.crtc_clock = dotclock;\r\nif (intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_CLOCK_RATE_MULT,\r\n&val, 1)) {\r\nswitch (val) {\r\ncase SDVO_CLOCK_RATE_MULT_1X:\r\nencoder_pixel_multiplier = 1;\r\nbreak;\r\ncase SDVO_CLOCK_RATE_MULT_2X:\r\nencoder_pixel_multiplier = 2;\r\nbreak;\r\ncase SDVO_CLOCK_RATE_MULT_4X:\r\nencoder_pixel_multiplier = 4;\r\nbreak;\r\n}\r\n}\r\nif (sdvox & HDMI_COLOR_RANGE_16_235)\r\npipe_config->limited_color_range = true;\r\nif (intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_ENCODE,\r\n&val, 1)) {\r\nif (val == SDVO_ENCODE_HDMI)\r\npipe_config->has_hdmi_sink = true;\r\n}\r\nWARN(encoder_pixel_multiplier != pipe_config->pixel_multiplier,\r\n"SDVO pixel multiplier mismatch, port: %i, encoder: %i\n",\r\npipe_config->pixel_multiplier, encoder_pixel_multiplier);\r\n}\r\nstatic void intel_disable_sdvo(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = encoder->base.dev->dev_private;\r\nstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\r\nu32 temp;\r\nintel_sdvo_set_active_outputs(intel_sdvo, 0);\r\nif (0)\r\nintel_sdvo_set_encoder_power_state(intel_sdvo,\r\nDRM_MODE_DPMS_OFF);\r\ntemp = I915_READ(intel_sdvo->sdvo_reg);\r\nif ((temp & SDVO_ENABLE) != 0) {\r\nif (HAS_PCH_IBX(encoder->base.dev)) {\r\nstruct drm_crtc *crtc = encoder->base.crtc;\r\nint pipe = crtc ? to_intel_crtc(crtc)->pipe : -1;\r\nif (temp & SDVO_PIPE_B_SELECT) {\r\ntemp &= ~SDVO_PIPE_B_SELECT;\r\nI915_WRITE(intel_sdvo->sdvo_reg, temp);\r\nPOSTING_READ(intel_sdvo->sdvo_reg);\r\nI915_WRITE(intel_sdvo->sdvo_reg, temp);\r\nPOSTING_READ(intel_sdvo->sdvo_reg);\r\nif (crtc)\r\nintel_wait_for_vblank(encoder->base.dev, pipe);\r\nelse\r\nmsleep(50);\r\n}\r\n}\r\nintel_sdvo_write_sdvox(intel_sdvo, temp & ~SDVO_ENABLE);\r\n}\r\n}\r\nstatic void intel_enable_sdvo(struct intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);\r\nu32 temp;\r\nbool input1, input2;\r\nint i;\r\nbool success;\r\ntemp = I915_READ(intel_sdvo->sdvo_reg);\r\nif ((temp & SDVO_ENABLE) == 0) {\r\nif (HAS_PCH_IBX(dev))\r\ntemp |= SDVO_PIPE_SEL(intel_crtc->pipe);\r\nintel_sdvo_write_sdvox(intel_sdvo, temp | SDVO_ENABLE);\r\n}\r\nfor (i = 0; i < 2; i++)\r\nintel_wait_for_vblank(dev, intel_crtc->pipe);\r\nsuccess = intel_sdvo_get_trained_inputs(intel_sdvo, &input1, &input2);\r\nif (success && !input1) {\r\nDRM_DEBUG_KMS("First %s output reported failure to "\r\n"sync\n", SDVO_NAME(intel_sdvo));\r\n}\r\nif (0)\r\nintel_sdvo_set_encoder_power_state(intel_sdvo,\r\nDRM_MODE_DPMS_ON);\r\nintel_sdvo_set_active_outputs(intel_sdvo, intel_sdvo->attached_output);\r\n}\r\nstatic void intel_sdvo_dpms(struct drm_connector *connector, int mode)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\r\nif (mode != DRM_MODE_DPMS_ON)\r\nmode = DRM_MODE_DPMS_OFF;\r\nif (mode == connector->dpms)\r\nreturn;\r\nconnector->dpms = mode;\r\ncrtc = intel_sdvo->base.base.crtc;\r\nif (!crtc) {\r\nintel_sdvo->base.connectors_active = false;\r\nreturn;\r\n}\r\nif (mode != DRM_MODE_DPMS_ON) {\r\nintel_sdvo_set_active_outputs(intel_sdvo, 0);\r\nif (0)\r\nintel_sdvo_set_encoder_power_state(intel_sdvo, mode);\r\nintel_sdvo->base.connectors_active = false;\r\nintel_crtc_update_dpms(crtc);\r\n} else {\r\nintel_sdvo->base.connectors_active = true;\r\nintel_crtc_update_dpms(crtc);\r\nif (0)\r\nintel_sdvo_set_encoder_power_state(intel_sdvo, mode);\r\nintel_sdvo_set_active_outputs(intel_sdvo, intel_sdvo->attached_output);\r\n}\r\nintel_modeset_check_state(connector->dev);\r\n}\r\nstatic enum drm_mode_status\r\nintel_sdvo_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (intel_sdvo->pixel_clock_min > mode->clock)\r\nreturn MODE_CLOCK_LOW;\r\nif (intel_sdvo->pixel_clock_max < mode->clock)\r\nreturn MODE_CLOCK_HIGH;\r\nif (intel_sdvo->is_lvds) {\r\nif (mode->hdisplay > intel_sdvo->sdvo_lvds_fixed_mode->hdisplay)\r\nreturn MODE_PANEL;\r\nif (mode->vdisplay > intel_sdvo->sdvo_lvds_fixed_mode->vdisplay)\r\nreturn MODE_PANEL;\r\n}\r\nreturn MODE_OK;\r\n}\r\nstatic bool intel_sdvo_get_capabilities(struct intel_sdvo *intel_sdvo, struct intel_sdvo_caps *caps)\r\n{\r\nBUILD_BUG_ON(sizeof(*caps) != 8);\r\nif (!intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_DEVICE_CAPS,\r\ncaps, sizeof(*caps)))\r\nreturn false;\r\nDRM_DEBUG_KMS("SDVO capabilities:\n"\r\n" vendor_id: %d\n"\r\n" device_id: %d\n"\r\n" device_rev_id: %d\n"\r\n" sdvo_version_major: %d\n"\r\n" sdvo_version_minor: %d\n"\r\n" sdvo_inputs_mask: %d\n"\r\n" smooth_scaling: %d\n"\r\n" sharp_scaling: %d\n"\r\n" up_scaling: %d\n"\r\n" down_scaling: %d\n"\r\n" stall_support: %d\n"\r\n" output_flags: %d\n",\r\ncaps->vendor_id,\r\ncaps->device_id,\r\ncaps->device_rev_id,\r\ncaps->sdvo_version_major,\r\ncaps->sdvo_version_minor,\r\ncaps->sdvo_inputs_mask,\r\ncaps->smooth_scaling,\r\ncaps->sharp_scaling,\r\ncaps->up_scaling,\r\ncaps->down_scaling,\r\ncaps->stall_support,\r\ncaps->output_flags);\r\nreturn true;\r\n}\r\nstatic uint16_t intel_sdvo_get_hotplug_support(struct intel_sdvo *intel_sdvo)\r\n{\r\nstruct drm_device *dev = intel_sdvo->base.base.dev;\r\nuint16_t hotplug;\r\nif (IS_I945G(dev) || IS_I945GM(dev))\r\nreturn 0;\r\nif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_HOT_PLUG_SUPPORT,\r\n&hotplug, sizeof(hotplug)))\r\nreturn 0;\r\nreturn hotplug;\r\n}\r\nstatic void intel_sdvo_enable_hotplug(struct intel_encoder *encoder)\r\n{\r\nstruct intel_sdvo *intel_sdvo = to_sdvo(encoder);\r\nintel_sdvo_write_cmd(intel_sdvo, SDVO_CMD_SET_ACTIVE_HOT_PLUG,\r\n&intel_sdvo->hotplug_active, 2);\r\n}\r\nstatic bool\r\nintel_sdvo_multifunc_encoder(struct intel_sdvo *intel_sdvo)\r\n{\r\nreturn hweight16(intel_sdvo->caps.output_flags) > 1;\r\n}\r\nstatic struct edid *\r\nintel_sdvo_get_edid(struct drm_connector *connector)\r\n{\r\nstruct intel_sdvo *sdvo = intel_attached_sdvo(connector);\r\nreturn drm_get_edid(connector, &sdvo->ddc);\r\n}\r\nstatic struct edid *\r\nintel_sdvo_get_analog_edid(struct drm_connector *connector)\r\n{\r\nstruct drm_i915_private *dev_priv = connector->dev->dev_private;\r\nreturn drm_get_edid(connector,\r\nintel_gmbus_get_adapter(dev_priv,\r\ndev_priv->vbt.crt_ddc_pin));\r\n}\r\nstatic enum drm_connector_status\r\nintel_sdvo_tmds_sink_detect(struct drm_connector *connector)\r\n{\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\r\nenum drm_connector_status status;\r\nstruct edid *edid;\r\nedid = intel_sdvo_get_edid(connector);\r\nif (edid == NULL && intel_sdvo_multifunc_encoder(intel_sdvo)) {\r\nu8 ddc, saved_ddc = intel_sdvo->ddc_bus;\r\nfor (ddc = intel_sdvo->ddc_bus >> 1; ddc > 1; ddc >>= 1) {\r\nintel_sdvo->ddc_bus = ddc;\r\nedid = intel_sdvo_get_edid(connector);\r\nif (edid)\r\nbreak;\r\n}\r\nif (edid == NULL)\r\nintel_sdvo->ddc_bus = saved_ddc;\r\n}\r\nif (edid == NULL)\r\nedid = intel_sdvo_get_analog_edid(connector);\r\nstatus = connector_status_unknown;\r\nif (edid != NULL) {\r\nif (edid->input & DRM_EDID_INPUT_DIGITAL) {\r\nstatus = connector_status_connected;\r\nif (intel_sdvo->is_hdmi) {\r\nintel_sdvo->has_hdmi_monitor = drm_detect_hdmi_monitor(edid);\r\nintel_sdvo->has_hdmi_audio = drm_detect_monitor_audio(edid);\r\nintel_sdvo->rgb_quant_range_selectable =\r\ndrm_rgb_quant_range_selectable(edid);\r\n}\r\n} else\r\nstatus = connector_status_disconnected;\r\nkfree(edid);\r\n}\r\nif (status == connector_status_connected) {\r\nstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\r\nif (intel_sdvo_connector->force_audio != HDMI_AUDIO_AUTO)\r\nintel_sdvo->has_hdmi_audio = (intel_sdvo_connector->force_audio == HDMI_AUDIO_ON);\r\n}\r\nreturn status;\r\n}\r\nstatic bool\r\nintel_sdvo_connector_matches_edid(struct intel_sdvo_connector *sdvo,\r\nstruct edid *edid)\r\n{\r\nbool monitor_is_digital = !!(edid->input & DRM_EDID_INPUT_DIGITAL);\r\nbool connector_is_digital = !!IS_DIGITAL(sdvo);\r\nDRM_DEBUG_KMS("connector_is_digital? %d, monitor_is_digital? %d\n",\r\nconnector_is_digital, monitor_is_digital);\r\nreturn connector_is_digital == monitor_is_digital;\r\n}\r\nstatic enum drm_connector_status\r\nintel_sdvo_detect(struct drm_connector *connector, bool force)\r\n{\r\nuint16_t response;\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\r\nstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\r\nenum drm_connector_status ret;\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",\r\nconnector->base.id, connector->name);\r\nif (!intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_ATTACHED_DISPLAYS,\r\n&response, 2))\r\nreturn connector_status_unknown;\r\nDRM_DEBUG_KMS("SDVO response %d %d [%x]\n",\r\nresponse & 0xff, response >> 8,\r\nintel_sdvo_connector->output_flag);\r\nif (response == 0)\r\nreturn connector_status_disconnected;\r\nintel_sdvo->attached_output = response;\r\nintel_sdvo->has_hdmi_monitor = false;\r\nintel_sdvo->has_hdmi_audio = false;\r\nintel_sdvo->rgb_quant_range_selectable = false;\r\nif ((intel_sdvo_connector->output_flag & response) == 0)\r\nret = connector_status_disconnected;\r\nelse if (IS_TMDS(intel_sdvo_connector))\r\nret = intel_sdvo_tmds_sink_detect(connector);\r\nelse {\r\nstruct edid *edid;\r\nedid = intel_sdvo_get_edid(connector);\r\nif (edid == NULL)\r\nedid = intel_sdvo_get_analog_edid(connector);\r\nif (edid != NULL) {\r\nif (intel_sdvo_connector_matches_edid(intel_sdvo_connector,\r\nedid))\r\nret = connector_status_connected;\r\nelse\r\nret = connector_status_disconnected;\r\nkfree(edid);\r\n} else\r\nret = connector_status_connected;\r\n}\r\nif (ret == connector_status_connected) {\r\nintel_sdvo->is_tv = false;\r\nintel_sdvo->is_lvds = false;\r\nif (response & SDVO_TV_MASK)\r\nintel_sdvo->is_tv = true;\r\nif (response & SDVO_LVDS_MASK)\r\nintel_sdvo->is_lvds = intel_sdvo->sdvo_lvds_fixed_mode != NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void intel_sdvo_get_ddc_modes(struct drm_connector *connector)\r\n{\r\nstruct edid *edid;\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",\r\nconnector->base.id, connector->name);\r\nedid = intel_sdvo_get_edid(connector);\r\nif (edid == NULL)\r\nedid = intel_sdvo_get_analog_edid(connector);\r\nif (edid != NULL) {\r\nif (intel_sdvo_connector_matches_edid(to_intel_sdvo_connector(connector),\r\nedid)) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\ndrm_add_edid_modes(connector, edid);\r\n}\r\nkfree(edid);\r\n}\r\n}\r\nstatic void intel_sdvo_get_tv_modes(struct drm_connector *connector)\r\n{\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\r\nstruct intel_sdvo_sdtv_resolution_request tv_res;\r\nuint32_t reply = 0, format_map = 0;\r\nint i;\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",\r\nconnector->base.id, connector->name);\r\nformat_map = 1 << intel_sdvo->tv_format_index;\r\nmemcpy(&tv_res, &format_map,\r\nmin(sizeof(format_map), sizeof(struct intel_sdvo_sdtv_resolution_request)));\r\nif (!intel_sdvo_set_target_output(intel_sdvo, intel_sdvo->attached_output))\r\nreturn;\r\nBUILD_BUG_ON(sizeof(tv_res) != 3);\r\nif (!intel_sdvo_write_cmd(intel_sdvo,\r\nSDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT,\r\n&tv_res, sizeof(tv_res)))\r\nreturn;\r\nif (!intel_sdvo_read_response(intel_sdvo, &reply, 3))\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(sdvo_tv_modes); i++)\r\nif (reply & (1 << i)) {\r\nstruct drm_display_mode *nmode;\r\nnmode = drm_mode_duplicate(connector->dev,\r\n&sdvo_tv_modes[i]);\r\nif (nmode)\r\ndrm_mode_probed_add(connector, nmode);\r\n}\r\n}\r\nstatic void intel_sdvo_get_lvds_modes(struct drm_connector *connector)\r\n{\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\r\nstruct drm_i915_private *dev_priv = connector->dev->dev_private;\r\nstruct drm_display_mode *newmode;\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",\r\nconnector->base.id, connector->name);\r\nif (dev_priv->vbt.sdvo_lvds_vbt_mode != NULL) {\r\nnewmode = drm_mode_duplicate(connector->dev,\r\ndev_priv->vbt.sdvo_lvds_vbt_mode);\r\nif (newmode != NULL) {\r\nnewmode->type = (DRM_MODE_TYPE_PREFERRED |\r\nDRM_MODE_TYPE_DRIVER);\r\ndrm_mode_probed_add(connector, newmode);\r\n}\r\n}\r\nintel_ddc_get_modes(connector, &intel_sdvo->ddc);\r\nlist_for_each_entry(newmode, &connector->probed_modes, head) {\r\nif (newmode->type & DRM_MODE_TYPE_PREFERRED) {\r\nintel_sdvo->sdvo_lvds_fixed_mode =\r\ndrm_mode_duplicate(connector->dev, newmode);\r\nintel_sdvo->is_lvds = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int intel_sdvo_get_modes(struct drm_connector *connector)\r\n{\r\nstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\r\nif (IS_TV(intel_sdvo_connector))\r\nintel_sdvo_get_tv_modes(connector);\r\nelse if (IS_LVDS(intel_sdvo_connector))\r\nintel_sdvo_get_lvds_modes(connector);\r\nelse\r\nintel_sdvo_get_ddc_modes(connector);\r\nreturn !list_empty(&connector->probed_modes);\r\n}\r\nstatic void\r\nintel_sdvo_destroy_enhance_property(struct drm_connector *connector)\r\n{\r\nstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\r\nstruct drm_device *dev = connector->dev;\r\nif (intel_sdvo_connector->left)\r\ndrm_property_destroy(dev, intel_sdvo_connector->left);\r\nif (intel_sdvo_connector->right)\r\ndrm_property_destroy(dev, intel_sdvo_connector->right);\r\nif (intel_sdvo_connector->top)\r\ndrm_property_destroy(dev, intel_sdvo_connector->top);\r\nif (intel_sdvo_connector->bottom)\r\ndrm_property_destroy(dev, intel_sdvo_connector->bottom);\r\nif (intel_sdvo_connector->hpos)\r\ndrm_property_destroy(dev, intel_sdvo_connector->hpos);\r\nif (intel_sdvo_connector->vpos)\r\ndrm_property_destroy(dev, intel_sdvo_connector->vpos);\r\nif (intel_sdvo_connector->saturation)\r\ndrm_property_destroy(dev, intel_sdvo_connector->saturation);\r\nif (intel_sdvo_connector->contrast)\r\ndrm_property_destroy(dev, intel_sdvo_connector->contrast);\r\nif (intel_sdvo_connector->hue)\r\ndrm_property_destroy(dev, intel_sdvo_connector->hue);\r\nif (intel_sdvo_connector->sharpness)\r\ndrm_property_destroy(dev, intel_sdvo_connector->sharpness);\r\nif (intel_sdvo_connector->flicker_filter)\r\ndrm_property_destroy(dev, intel_sdvo_connector->flicker_filter);\r\nif (intel_sdvo_connector->flicker_filter_2d)\r\ndrm_property_destroy(dev, intel_sdvo_connector->flicker_filter_2d);\r\nif (intel_sdvo_connector->flicker_filter_adaptive)\r\ndrm_property_destroy(dev, intel_sdvo_connector->flicker_filter_adaptive);\r\nif (intel_sdvo_connector->tv_luma_filter)\r\ndrm_property_destroy(dev, intel_sdvo_connector->tv_luma_filter);\r\nif (intel_sdvo_connector->tv_chroma_filter)\r\ndrm_property_destroy(dev, intel_sdvo_connector->tv_chroma_filter);\r\nif (intel_sdvo_connector->dot_crawl)\r\ndrm_property_destroy(dev, intel_sdvo_connector->dot_crawl);\r\nif (intel_sdvo_connector->brightness)\r\ndrm_property_destroy(dev, intel_sdvo_connector->brightness);\r\n}\r\nstatic void intel_sdvo_destroy(struct drm_connector *connector)\r\n{\r\nstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\r\nif (intel_sdvo_connector->tv_format)\r\ndrm_property_destroy(connector->dev,\r\nintel_sdvo_connector->tv_format);\r\nintel_sdvo_destroy_enhance_property(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(intel_sdvo_connector);\r\n}\r\nstatic bool intel_sdvo_detect_hdmi_audio(struct drm_connector *connector)\r\n{\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\r\nstruct edid *edid;\r\nbool has_audio = false;\r\nif (!intel_sdvo->is_hdmi)\r\nreturn false;\r\nedid = intel_sdvo_get_edid(connector);\r\nif (edid != NULL && edid->input & DRM_EDID_INPUT_DIGITAL)\r\nhas_audio = drm_detect_monitor_audio(edid);\r\nkfree(edid);\r\nreturn has_audio;\r\n}\r\nstatic int\r\nintel_sdvo_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct intel_sdvo *intel_sdvo = intel_attached_sdvo(connector);\r\nstruct intel_sdvo_connector *intel_sdvo_connector = to_intel_sdvo_connector(connector);\r\nstruct drm_i915_private *dev_priv = connector->dev->dev_private;\r\nuint16_t temp_value;\r\nuint8_t cmd;\r\nint ret;\r\nret = drm_object_property_set_value(&connector->base, property, val);\r\nif (ret)\r\nreturn ret;\r\nif (property == dev_priv->force_audio_property) {\r\nint i = val;\r\nbool has_audio;\r\nif (i == intel_sdvo_connector->force_audio)\r\nreturn 0;\r\nintel_sdvo_connector->force_audio = i;\r\nif (i == HDMI_AUDIO_AUTO)\r\nhas_audio = intel_sdvo_detect_hdmi_audio(connector);\r\nelse\r\nhas_audio = (i == HDMI_AUDIO_ON);\r\nif (has_audio == intel_sdvo->has_hdmi_audio)\r\nreturn 0;\r\nintel_sdvo->has_hdmi_audio = has_audio;\r\ngoto done;\r\n}\r\nif (property == dev_priv->broadcast_rgb_property) {\r\nbool old_auto = intel_sdvo->color_range_auto;\r\nuint32_t old_range = intel_sdvo->color_range;\r\nswitch (val) {\r\ncase INTEL_BROADCAST_RGB_AUTO:\r\nintel_sdvo->color_range_auto = true;\r\nbreak;\r\ncase INTEL_BROADCAST_RGB_FULL:\r\nintel_sdvo->color_range_auto = false;\r\nintel_sdvo->color_range = 0;\r\nbreak;\r\ncase INTEL_BROADCAST_RGB_LIMITED:\r\nintel_sdvo->color_range_auto = false;\r\nintel_sdvo->color_range = HDMI_COLOR_RANGE_16_235;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (old_auto == intel_sdvo->color_range_auto &&\r\nold_range == intel_sdvo->color_range)\r\nreturn 0;\r\ngoto done;\r\n}\r\n#define CHECK_PROPERTY(name, NAME) \\r\nif (intel_sdvo_connector->name == property) { \\r\nif (intel_sdvo_connector->cur_##name == temp_value) return 0; \\r\nif (intel_sdvo_connector->max_##name < temp_value) return -EINVAL; \\r\ncmd = SDVO_CMD_SET_##NAME; \\r\nintel_sdvo_connector->cur_##name = temp_value; \\r\ngoto set_value; \\r\n}\r\nif (property == intel_sdvo_connector->tv_format) {\r\nif (val >= TV_FORMAT_NUM)\r\nreturn -EINVAL;\r\nif (intel_sdvo->tv_format_index ==\r\nintel_sdvo_connector->tv_format_supported[val])\r\nreturn 0;\r\nintel_sdvo->tv_format_index = intel_sdvo_connector->tv_format_supported[val];\r\ngoto done;\r\n} else if (IS_TV_OR_LVDS(intel_sdvo_connector)) {\r\ntemp_value = val;\r\nif (intel_sdvo_connector->left == property) {\r\ndrm_object_property_set_value(&connector->base,\r\nintel_sdvo_connector->right, val);\r\nif (intel_sdvo_connector->left_margin == temp_value)\r\nreturn 0;\r\nintel_sdvo_connector->left_margin = temp_value;\r\nintel_sdvo_connector->right_margin = temp_value;\r\ntemp_value = intel_sdvo_connector->max_hscan -\r\nintel_sdvo_connector->left_margin;\r\ncmd = SDVO_CMD_SET_OVERSCAN_H;\r\ngoto set_value;\r\n} else if (intel_sdvo_connector->right == property) {\r\ndrm_object_property_set_value(&connector->base,\r\nintel_sdvo_connector->left, val);\r\nif (intel_sdvo_connector->right_margin == temp_value)\r\nreturn 0;\r\nintel_sdvo_connector->left_margin = temp_value;\r\nintel_sdvo_connector->right_margin = temp_value;\r\ntemp_value = intel_sdvo_connector->max_hscan -\r\nintel_sdvo_connector->left_margin;\r\ncmd = SDVO_CMD_SET_OVERSCAN_H;\r\ngoto set_value;\r\n} else if (intel_sdvo_connector->top == property) {\r\ndrm_object_property_set_value(&connector->base,\r\nintel_sdvo_connector->bottom, val);\r\nif (intel_sdvo_connector->top_margin == temp_value)\r\nreturn 0;\r\nintel_sdvo_connector->top_margin = temp_value;\r\nintel_sdvo_connector->bottom_margin = temp_value;\r\ntemp_value = intel_sdvo_connector->max_vscan -\r\nintel_sdvo_connector->top_margin;\r\ncmd = SDVO_CMD_SET_OVERSCAN_V;\r\ngoto set_value;\r\n} else if (intel_sdvo_connector->bottom == property) {\r\ndrm_object_property_set_value(&connector->base,\r\nintel_sdvo_connector->top, val);\r\nif (intel_sdvo_connector->bottom_margin == temp_value)\r\nreturn 0;\r\nintel_sdvo_connector->top_margin = temp_value;\r\nintel_sdvo_connector->bottom_margin = temp_value;\r\ntemp_value = intel_sdvo_connector->max_vscan -\r\nintel_sdvo_connector->top_margin;\r\ncmd = SDVO_CMD_SET_OVERSCAN_V;\r\ngoto set_value;\r\n}\r\nCHECK_PROPERTY(hpos, HPOS)\r\nCHECK_PROPERTY(vpos, VPOS)\r\nCHECK_PROPERTY(saturation, SATURATION)\r\nCHECK_PROPERTY(contrast, CONTRAST)\r\nCHECK_PROPERTY(hue, HUE)\r\nCHECK_PROPERTY(brightness, BRIGHTNESS)\r\nCHECK_PROPERTY(sharpness, SHARPNESS)\r\nCHECK_PROPERTY(flicker_filter, FLICKER_FILTER)\r\nCHECK_PROPERTY(flicker_filter_2d, FLICKER_FILTER_2D)\r\nCHECK_PROPERTY(flicker_filter_adaptive, FLICKER_FILTER_ADAPTIVE)\r\nCHECK_PROPERTY(tv_chroma_filter, TV_CHROMA_FILTER)\r\nCHECK_PROPERTY(tv_luma_filter, TV_LUMA_FILTER)\r\nCHECK_PROPERTY(dot_crawl, DOT_CRAWL)\r\n}\r\nreturn -EINVAL;\r\nset_value:\r\nif (!intel_sdvo_set_value(intel_sdvo, cmd, &temp_value, 2))\r\nreturn -EIO;\r\ndone:\r\nif (intel_sdvo->base.base.crtc)\r\nintel_crtc_restore_mode(intel_sdvo->base.base.crtc);\r\nreturn 0;\r\n#undef CHECK_PROPERTY\r\n}\r\nstatic void intel_sdvo_enc_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct intel_sdvo *intel_sdvo = to_sdvo(to_intel_encoder(encoder));\r\nif (intel_sdvo->sdvo_lvds_fixed_mode != NULL)\r\ndrm_mode_destroy(encoder->dev,\r\nintel_sdvo->sdvo_lvds_fixed_mode);\r\ni2c_del_adapter(&intel_sdvo->ddc);\r\nintel_encoder_destroy(encoder);\r\n}\r\nstatic void\r\nintel_sdvo_guess_ddc_bus(struct intel_sdvo *sdvo)\r\n{\r\nuint16_t mask = 0;\r\nunsigned int num_bits;\r\nswitch (sdvo->controlled_output) {\r\ncase SDVO_OUTPUT_LVDS1:\r\nmask |= SDVO_OUTPUT_LVDS1;\r\ncase SDVO_OUTPUT_LVDS0:\r\nmask |= SDVO_OUTPUT_LVDS0;\r\ncase SDVO_OUTPUT_TMDS1:\r\nmask |= SDVO_OUTPUT_TMDS1;\r\ncase SDVO_OUTPUT_TMDS0:\r\nmask |= SDVO_OUTPUT_TMDS0;\r\ncase SDVO_OUTPUT_RGB1:\r\nmask |= SDVO_OUTPUT_RGB1;\r\ncase SDVO_OUTPUT_RGB0:\r\nmask |= SDVO_OUTPUT_RGB0;\r\nbreak;\r\n}\r\nmask &= sdvo->caps.output_flags;\r\nnum_bits = hweight16(mask);\r\nif (num_bits > 3)\r\nnum_bits = 3;\r\nsdvo->ddc_bus = 1 << num_bits;\r\n}\r\nstatic void\r\nintel_sdvo_select_ddc_bus(struct drm_i915_private *dev_priv,\r\nstruct intel_sdvo *sdvo, u32 reg)\r\n{\r\nstruct sdvo_device_mapping *mapping;\r\nif (sdvo->is_sdvob)\r\nmapping = &(dev_priv->sdvo_mappings[0]);\r\nelse\r\nmapping = &(dev_priv->sdvo_mappings[1]);\r\nif (mapping->initialized)\r\nsdvo->ddc_bus = 1 << ((mapping->ddc_pin & 0xf0) >> 4);\r\nelse\r\nintel_sdvo_guess_ddc_bus(sdvo);\r\n}\r\nstatic void\r\nintel_sdvo_select_i2c_bus(struct drm_i915_private *dev_priv,\r\nstruct intel_sdvo *sdvo, u32 reg)\r\n{\r\nstruct sdvo_device_mapping *mapping;\r\nu8 pin;\r\nif (sdvo->is_sdvob)\r\nmapping = &dev_priv->sdvo_mappings[0];\r\nelse\r\nmapping = &dev_priv->sdvo_mappings[1];\r\nif (mapping->initialized && intel_gmbus_is_port_valid(mapping->i2c_pin))\r\npin = mapping->i2c_pin;\r\nelse\r\npin = GMBUS_PORT_DPB;\r\nsdvo->i2c = intel_gmbus_get_adapter(dev_priv, pin);\r\nintel_gmbus_force_bit(sdvo->i2c, true);\r\n}\r\nstatic void\r\nintel_sdvo_unselect_i2c_bus(struct intel_sdvo *sdvo)\r\n{\r\nintel_gmbus_force_bit(sdvo->i2c, false);\r\n}\r\nstatic bool\r\nintel_sdvo_is_hdmi_connector(struct intel_sdvo *intel_sdvo, int device)\r\n{\r\nreturn intel_sdvo_check_supp_encode(intel_sdvo);\r\n}\r\nstatic u8\r\nintel_sdvo_get_slave_addr(struct drm_device *dev, struct intel_sdvo *sdvo)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct sdvo_device_mapping *my_mapping, *other_mapping;\r\nif (sdvo->is_sdvob) {\r\nmy_mapping = &dev_priv->sdvo_mappings[0];\r\nother_mapping = &dev_priv->sdvo_mappings[1];\r\n} else {\r\nmy_mapping = &dev_priv->sdvo_mappings[1];\r\nother_mapping = &dev_priv->sdvo_mappings[0];\r\n}\r\nif (my_mapping->slave_addr)\r\nreturn my_mapping->slave_addr;\r\nif (other_mapping->slave_addr) {\r\nif (other_mapping->slave_addr == 0x70)\r\nreturn 0x72;\r\nelse\r\nreturn 0x70;\r\n}\r\nif (sdvo->is_sdvob)\r\nreturn 0x70;\r\nelse\r\nreturn 0x72;\r\n}\r\nstatic void\r\nintel_sdvo_connector_unregister(struct intel_connector *intel_connector)\r\n{\r\nstruct drm_connector *drm_connector;\r\nstruct intel_sdvo *sdvo_encoder;\r\ndrm_connector = &intel_connector->base;\r\nsdvo_encoder = intel_attached_sdvo(&intel_connector->base);\r\nsysfs_remove_link(&drm_connector->kdev->kobj,\r\nsdvo_encoder->ddc.dev.kobj.name);\r\nintel_connector_unregister(intel_connector);\r\n}\r\nstatic int\r\nintel_sdvo_connector_init(struct intel_sdvo_connector *connector,\r\nstruct intel_sdvo *encoder)\r\n{\r\nstruct drm_connector *drm_connector;\r\nint ret;\r\ndrm_connector = &connector->base.base;\r\nret = drm_connector_init(encoder->base.base.dev,\r\ndrm_connector,\r\n&intel_sdvo_connector_funcs,\r\nconnector->base.base.connector_type);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_connector_helper_add(drm_connector,\r\n&intel_sdvo_connector_helper_funcs);\r\nconnector->base.base.interlace_allowed = 1;\r\nconnector->base.base.doublescan_allowed = 0;\r\nconnector->base.base.display_info.subpixel_order = SubPixelHorizontalRGB;\r\nconnector->base.get_hw_state = intel_sdvo_connector_get_hw_state;\r\nconnector->base.unregister = intel_sdvo_connector_unregister;\r\nintel_connector_attach_encoder(&connector->base, &encoder->base);\r\nret = drm_connector_register(drm_connector);\r\nif (ret < 0)\r\ngoto err1;\r\nret = sysfs_create_link(&drm_connector->kdev->kobj,\r\n&encoder->ddc.dev.kobj,\r\nencoder->ddc.dev.kobj.name);\r\nif (ret < 0)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\ndrm_connector_unregister(drm_connector);\r\nerr1:\r\ndrm_connector_cleanup(drm_connector);\r\nreturn ret;\r\n}\r\nstatic void\r\nintel_sdvo_add_hdmi_properties(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->base.base.dev;\r\nintel_attach_force_audio_property(&connector->base.base);\r\nif (INTEL_INFO(dev)->gen >= 4 && IS_MOBILE(dev)) {\r\nintel_attach_broadcast_rgb_property(&connector->base.base);\r\nintel_sdvo->color_range_auto = true;\r\n}\r\n}\r\nstatic bool\r\nintel_sdvo_dvi_init(struct intel_sdvo *intel_sdvo, int device)\r\n{\r\nstruct drm_encoder *encoder = &intel_sdvo->base.base;\r\nstruct drm_connector *connector;\r\nstruct intel_encoder *intel_encoder = to_intel_encoder(encoder);\r\nstruct intel_connector *intel_connector;\r\nstruct intel_sdvo_connector *intel_sdvo_connector;\r\nDRM_DEBUG_KMS("initialising DVI device %d\n", device);\r\nintel_sdvo_connector = kzalloc(sizeof(*intel_sdvo_connector), GFP_KERNEL);\r\nif (!intel_sdvo_connector)\r\nreturn false;\r\nif (device == 0) {\r\nintel_sdvo->controlled_output |= SDVO_OUTPUT_TMDS0;\r\nintel_sdvo_connector->output_flag = SDVO_OUTPUT_TMDS0;\r\n} else if (device == 1) {\r\nintel_sdvo->controlled_output |= SDVO_OUTPUT_TMDS1;\r\nintel_sdvo_connector->output_flag = SDVO_OUTPUT_TMDS1;\r\n}\r\nintel_connector = &intel_sdvo_connector->base;\r\nconnector = &intel_connector->base;\r\nif (intel_sdvo_get_hotplug_support(intel_sdvo) &\r\nintel_sdvo_connector->output_flag) {\r\nintel_sdvo->hotplug_active |= intel_sdvo_connector->output_flag;\r\nintel_encoder->hot_plug = intel_sdvo_enable_hotplug;\r\nintel_sdvo_enable_hotplug(intel_encoder);\r\n} else {\r\nintel_connector->polled = DRM_CONNECTOR_POLL_CONNECT | DRM_CONNECTOR_POLL_DISCONNECT;\r\n}\r\nencoder->encoder_type = DRM_MODE_ENCODER_TMDS;\r\nconnector->connector_type = DRM_MODE_CONNECTOR_DVID;\r\nif (intel_sdvo_is_hdmi_connector(intel_sdvo, device)) {\r\nconnector->connector_type = DRM_MODE_CONNECTOR_HDMIA;\r\nintel_sdvo->is_hdmi = true;\r\n}\r\nif (intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo) < 0) {\r\nkfree(intel_sdvo_connector);\r\nreturn false;\r\n}\r\nif (intel_sdvo->is_hdmi)\r\nintel_sdvo_add_hdmi_properties(intel_sdvo, intel_sdvo_connector);\r\nreturn true;\r\n}\r\nstatic bool\r\nintel_sdvo_tv_init(struct intel_sdvo *intel_sdvo, int type)\r\n{\r\nstruct drm_encoder *encoder = &intel_sdvo->base.base;\r\nstruct drm_connector *connector;\r\nstruct intel_connector *intel_connector;\r\nstruct intel_sdvo_connector *intel_sdvo_connector;\r\nDRM_DEBUG_KMS("initialising TV type %d\n", type);\r\nintel_sdvo_connector = kzalloc(sizeof(*intel_sdvo_connector), GFP_KERNEL);\r\nif (!intel_sdvo_connector)\r\nreturn false;\r\nintel_connector = &intel_sdvo_connector->base;\r\nconnector = &intel_connector->base;\r\nencoder->encoder_type = DRM_MODE_ENCODER_TVDAC;\r\nconnector->connector_type = DRM_MODE_CONNECTOR_SVIDEO;\r\nintel_sdvo->controlled_output |= type;\r\nintel_sdvo_connector->output_flag = type;\r\nintel_sdvo->is_tv = true;\r\nif (intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo) < 0) {\r\nkfree(intel_sdvo_connector);\r\nreturn false;\r\n}\r\nif (!intel_sdvo_tv_create_property(intel_sdvo, intel_sdvo_connector, type))\r\ngoto err;\r\nif (!intel_sdvo_create_enhance_property(intel_sdvo, intel_sdvo_connector))\r\ngoto err;\r\nreturn true;\r\nerr:\r\ndrm_connector_unregister(connector);\r\nintel_sdvo_destroy(connector);\r\nreturn false;\r\n}\r\nstatic bool\r\nintel_sdvo_analog_init(struct intel_sdvo *intel_sdvo, int device)\r\n{\r\nstruct drm_encoder *encoder = &intel_sdvo->base.base;\r\nstruct drm_connector *connector;\r\nstruct intel_connector *intel_connector;\r\nstruct intel_sdvo_connector *intel_sdvo_connector;\r\nDRM_DEBUG_KMS("initialising analog device %d\n", device);\r\nintel_sdvo_connector = kzalloc(sizeof(*intel_sdvo_connector), GFP_KERNEL);\r\nif (!intel_sdvo_connector)\r\nreturn false;\r\nintel_connector = &intel_sdvo_connector->base;\r\nconnector = &intel_connector->base;\r\nintel_connector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\nencoder->encoder_type = DRM_MODE_ENCODER_DAC;\r\nconnector->connector_type = DRM_MODE_CONNECTOR_VGA;\r\nif (device == 0) {\r\nintel_sdvo->controlled_output |= SDVO_OUTPUT_RGB0;\r\nintel_sdvo_connector->output_flag = SDVO_OUTPUT_RGB0;\r\n} else if (device == 1) {\r\nintel_sdvo->controlled_output |= SDVO_OUTPUT_RGB1;\r\nintel_sdvo_connector->output_flag = SDVO_OUTPUT_RGB1;\r\n}\r\nif (intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo) < 0) {\r\nkfree(intel_sdvo_connector);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nintel_sdvo_lvds_init(struct intel_sdvo *intel_sdvo, int device)\r\n{\r\nstruct drm_encoder *encoder = &intel_sdvo->base.base;\r\nstruct drm_connector *connector;\r\nstruct intel_connector *intel_connector;\r\nstruct intel_sdvo_connector *intel_sdvo_connector;\r\nDRM_DEBUG_KMS("initialising LVDS device %d\n", device);\r\nintel_sdvo_connector = kzalloc(sizeof(*intel_sdvo_connector), GFP_KERNEL);\r\nif (!intel_sdvo_connector)\r\nreturn false;\r\nintel_connector = &intel_sdvo_connector->base;\r\nconnector = &intel_connector->base;\r\nencoder->encoder_type = DRM_MODE_ENCODER_LVDS;\r\nconnector->connector_type = DRM_MODE_CONNECTOR_LVDS;\r\nif (device == 0) {\r\nintel_sdvo->controlled_output |= SDVO_OUTPUT_LVDS0;\r\nintel_sdvo_connector->output_flag = SDVO_OUTPUT_LVDS0;\r\n} else if (device == 1) {\r\nintel_sdvo->controlled_output |= SDVO_OUTPUT_LVDS1;\r\nintel_sdvo_connector->output_flag = SDVO_OUTPUT_LVDS1;\r\n}\r\nif (intel_sdvo_connector_init(intel_sdvo_connector, intel_sdvo) < 0) {\r\nkfree(intel_sdvo_connector);\r\nreturn false;\r\n}\r\nif (!intel_sdvo_create_enhance_property(intel_sdvo, intel_sdvo_connector))\r\ngoto err;\r\nreturn true;\r\nerr:\r\ndrm_connector_unregister(connector);\r\nintel_sdvo_destroy(connector);\r\nreturn false;\r\n}\r\nstatic bool\r\nintel_sdvo_output_setup(struct intel_sdvo *intel_sdvo, uint16_t flags)\r\n{\r\nintel_sdvo->is_tv = false;\r\nintel_sdvo->is_lvds = false;\r\nif (flags & SDVO_OUTPUT_TMDS0)\r\nif (!intel_sdvo_dvi_init(intel_sdvo, 0))\r\nreturn false;\r\nif ((flags & SDVO_TMDS_MASK) == SDVO_TMDS_MASK)\r\nif (!intel_sdvo_dvi_init(intel_sdvo, 1))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_SVID0)\r\nif (!intel_sdvo_tv_init(intel_sdvo, SDVO_OUTPUT_SVID0))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_CVBS0)\r\nif (!intel_sdvo_tv_init(intel_sdvo, SDVO_OUTPUT_CVBS0))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_YPRPB0)\r\nif (!intel_sdvo_tv_init(intel_sdvo, SDVO_OUTPUT_YPRPB0))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_RGB0)\r\nif (!intel_sdvo_analog_init(intel_sdvo, 0))\r\nreturn false;\r\nif ((flags & SDVO_RGB_MASK) == SDVO_RGB_MASK)\r\nif (!intel_sdvo_analog_init(intel_sdvo, 1))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_LVDS0)\r\nif (!intel_sdvo_lvds_init(intel_sdvo, 0))\r\nreturn false;\r\nif ((flags & SDVO_LVDS_MASK) == SDVO_LVDS_MASK)\r\nif (!intel_sdvo_lvds_init(intel_sdvo, 1))\r\nreturn false;\r\nif ((flags & SDVO_OUTPUT_MASK) == 0) {\r\nunsigned char bytes[2];\r\nintel_sdvo->controlled_output = 0;\r\nmemcpy(bytes, &intel_sdvo->caps.output_flags, 2);\r\nDRM_DEBUG_KMS("%s: Unknown SDVO output type (0x%02x%02x)\n",\r\nSDVO_NAME(intel_sdvo),\r\nbytes[0], bytes[1]);\r\nreturn false;\r\n}\r\nintel_sdvo->base.crtc_mask = (1 << 0) | (1 << 1) | (1 << 2);\r\nreturn true;\r\n}\r\nstatic void intel_sdvo_output_cleanup(struct intel_sdvo *intel_sdvo)\r\n{\r\nstruct drm_device *dev = intel_sdvo->base.base.dev;\r\nstruct drm_connector *connector, *tmp;\r\nlist_for_each_entry_safe(connector, tmp,\r\n&dev->mode_config.connector_list, head) {\r\nif (intel_attached_encoder(connector) == &intel_sdvo->base) {\r\ndrm_connector_unregister(connector);\r\nintel_sdvo_destroy(connector);\r\n}\r\n}\r\n}\r\nstatic bool intel_sdvo_tv_create_property(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_connector *intel_sdvo_connector,\r\nint type)\r\n{\r\nstruct drm_device *dev = intel_sdvo->base.base.dev;\r\nstruct intel_sdvo_tv_format format;\r\nuint32_t format_map, i;\r\nif (!intel_sdvo_set_target_output(intel_sdvo, type))\r\nreturn false;\r\nBUILD_BUG_ON(sizeof(format) != 6);\r\nif (!intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_SUPPORTED_TV_FORMATS,\r\n&format, sizeof(format)))\r\nreturn false;\r\nmemcpy(&format_map, &format, min(sizeof(format_map), sizeof(format)));\r\nif (format_map == 0)\r\nreturn false;\r\nintel_sdvo_connector->format_supported_num = 0;\r\nfor (i = 0 ; i < TV_FORMAT_NUM; i++)\r\nif (format_map & (1 << i))\r\nintel_sdvo_connector->tv_format_supported[intel_sdvo_connector->format_supported_num++] = i;\r\nintel_sdvo_connector->tv_format =\r\ndrm_property_create(dev, DRM_MODE_PROP_ENUM,\r\n"mode", intel_sdvo_connector->format_supported_num);\r\nif (!intel_sdvo_connector->tv_format)\r\nreturn false;\r\nfor (i = 0; i < intel_sdvo_connector->format_supported_num; i++)\r\ndrm_property_add_enum(\r\nintel_sdvo_connector->tv_format, i,\r\ni, tv_format_names[intel_sdvo_connector->tv_format_supported[i]]);\r\nintel_sdvo->tv_format_index = intel_sdvo_connector->tv_format_supported[0];\r\ndrm_object_attach_property(&intel_sdvo_connector->base.base.base,\r\nintel_sdvo_connector->tv_format, 0);\r\nreturn true;\r\n}\r\nstatic bool\r\nintel_sdvo_create_enhance_property_tv(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_connector *intel_sdvo_connector,\r\nstruct intel_sdvo_enhancements_reply enhancements)\r\n{\r\nstruct drm_device *dev = intel_sdvo->base.base.dev;\r\nstruct drm_connector *connector = &intel_sdvo_connector->base.base;\r\nuint16_t response, data_value[2];\r\nif (enhancements.overscan_h) {\r\nif (!intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_MAX_OVERSCAN_H,\r\n&data_value, 4))\r\nreturn false;\r\nif (!intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_OVERSCAN_H,\r\n&response, 2))\r\nreturn false;\r\nintel_sdvo_connector->max_hscan = data_value[0];\r\nintel_sdvo_connector->left_margin = data_value[0] - response;\r\nintel_sdvo_connector->right_margin = intel_sdvo_connector->left_margin;\r\nintel_sdvo_connector->left =\r\ndrm_property_create_range(dev, 0, "left_margin", 0, data_value[0]);\r\nif (!intel_sdvo_connector->left)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\nintel_sdvo_connector->left,\r\nintel_sdvo_connector->left_margin);\r\nintel_sdvo_connector->right =\r\ndrm_property_create_range(dev, 0, "right_margin", 0, data_value[0]);\r\nif (!intel_sdvo_connector->right)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\nintel_sdvo_connector->right,\r\nintel_sdvo_connector->right_margin);\r\nDRM_DEBUG_KMS("h_overscan: max %d, "\r\n"default %d, current %d\n",\r\ndata_value[0], data_value[1], response);\r\n}\r\nif (enhancements.overscan_v) {\r\nif (!intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_MAX_OVERSCAN_V,\r\n&data_value, 4))\r\nreturn false;\r\nif (!intel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_OVERSCAN_V,\r\n&response, 2))\r\nreturn false;\r\nintel_sdvo_connector->max_vscan = data_value[0];\r\nintel_sdvo_connector->top_margin = data_value[0] - response;\r\nintel_sdvo_connector->bottom_margin = intel_sdvo_connector->top_margin;\r\nintel_sdvo_connector->top =\r\ndrm_property_create_range(dev, 0,\r\n"top_margin", 0, data_value[0]);\r\nif (!intel_sdvo_connector->top)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\nintel_sdvo_connector->top,\r\nintel_sdvo_connector->top_margin);\r\nintel_sdvo_connector->bottom =\r\ndrm_property_create_range(dev, 0,\r\n"bottom_margin", 0, data_value[0]);\r\nif (!intel_sdvo_connector->bottom)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\nintel_sdvo_connector->bottom,\r\nintel_sdvo_connector->bottom_margin);\r\nDRM_DEBUG_KMS("v_overscan: max %d, "\r\n"default %d, current %d\n",\r\ndata_value[0], data_value[1], response);\r\n}\r\nENHANCEMENT(hpos, HPOS);\r\nENHANCEMENT(vpos, VPOS);\r\nENHANCEMENT(saturation, SATURATION);\r\nENHANCEMENT(contrast, CONTRAST);\r\nENHANCEMENT(hue, HUE);\r\nENHANCEMENT(sharpness, SHARPNESS);\r\nENHANCEMENT(brightness, BRIGHTNESS);\r\nENHANCEMENT(flicker_filter, FLICKER_FILTER);\r\nENHANCEMENT(flicker_filter_adaptive, FLICKER_FILTER_ADAPTIVE);\r\nENHANCEMENT(flicker_filter_2d, FLICKER_FILTER_2D);\r\nENHANCEMENT(tv_chroma_filter, TV_CHROMA_FILTER);\r\nENHANCEMENT(tv_luma_filter, TV_LUMA_FILTER);\r\nif (enhancements.dot_crawl) {\r\nif (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_DOT_CRAWL, &response, 2))\r\nreturn false;\r\nintel_sdvo_connector->max_dot_crawl = 1;\r\nintel_sdvo_connector->cur_dot_crawl = response & 0x1;\r\nintel_sdvo_connector->dot_crawl =\r\ndrm_property_create_range(dev, 0, "dot_crawl", 0, 1);\r\nif (!intel_sdvo_connector->dot_crawl)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\nintel_sdvo_connector->dot_crawl,\r\nintel_sdvo_connector->cur_dot_crawl);\r\nDRM_DEBUG_KMS("dot crawl: current %d\n", response);\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nintel_sdvo_create_enhance_property_lvds(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_connector *intel_sdvo_connector,\r\nstruct intel_sdvo_enhancements_reply enhancements)\r\n{\r\nstruct drm_device *dev = intel_sdvo->base.base.dev;\r\nstruct drm_connector *connector = &intel_sdvo_connector->base.base;\r\nuint16_t response, data_value[2];\r\nENHANCEMENT(brightness, BRIGHTNESS);\r\nreturn true;\r\n}\r\nstatic bool intel_sdvo_create_enhance_property(struct intel_sdvo *intel_sdvo,\r\nstruct intel_sdvo_connector *intel_sdvo_connector)\r\n{\r\nunion {\r\nstruct intel_sdvo_enhancements_reply reply;\r\nuint16_t response;\r\n} enhancements;\r\nBUILD_BUG_ON(sizeof(enhancements) != 2);\r\nenhancements.response = 0;\r\nintel_sdvo_get_value(intel_sdvo,\r\nSDVO_CMD_GET_SUPPORTED_ENHANCEMENTS,\r\n&enhancements, sizeof(enhancements));\r\nif (enhancements.response == 0) {\r\nDRM_DEBUG_KMS("No enhancement is supported\n");\r\nreturn true;\r\n}\r\nif (IS_TV(intel_sdvo_connector))\r\nreturn intel_sdvo_create_enhance_property_tv(intel_sdvo, intel_sdvo_connector, enhancements.reply);\r\nelse if (IS_LVDS(intel_sdvo_connector))\r\nreturn intel_sdvo_create_enhance_property_lvds(intel_sdvo, intel_sdvo_connector, enhancements.reply);\r\nelse\r\nreturn true;\r\n}\r\nstatic int intel_sdvo_ddc_proxy_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct intel_sdvo *sdvo = adapter->algo_data;\r\nif (!intel_sdvo_set_control_bus_switch(sdvo, sdvo->ddc_bus))\r\nreturn -EIO;\r\nreturn sdvo->i2c->algo->master_xfer(sdvo->i2c, msgs, num);\r\n}\r\nstatic u32 intel_sdvo_ddc_proxy_func(struct i2c_adapter *adapter)\r\n{\r\nstruct intel_sdvo *sdvo = adapter->algo_data;\r\nreturn sdvo->i2c->algo->functionality(sdvo->i2c);\r\n}\r\nstatic bool\r\nintel_sdvo_init_ddc_proxy(struct intel_sdvo *sdvo,\r\nstruct drm_device *dev)\r\n{\r\nsdvo->ddc.owner = THIS_MODULE;\r\nsdvo->ddc.class = I2C_CLASS_DDC;\r\nsnprintf(sdvo->ddc.name, I2C_NAME_SIZE, "SDVO DDC proxy");\r\nsdvo->ddc.dev.parent = &dev->pdev->dev;\r\nsdvo->ddc.algo_data = sdvo;\r\nsdvo->ddc.algo = &intel_sdvo_ddc_proxy;\r\nreturn i2c_add_adapter(&sdvo->ddc) == 0;\r\n}\r\nbool intel_sdvo_init(struct drm_device *dev, uint32_t sdvo_reg, bool is_sdvob)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_encoder *intel_encoder;\r\nstruct intel_sdvo *intel_sdvo;\r\nint i;\r\nintel_sdvo = kzalloc(sizeof(*intel_sdvo), GFP_KERNEL);\r\nif (!intel_sdvo)\r\nreturn false;\r\nintel_sdvo->sdvo_reg = sdvo_reg;\r\nintel_sdvo->is_sdvob = is_sdvob;\r\nintel_sdvo->slave_addr = intel_sdvo_get_slave_addr(dev, intel_sdvo) >> 1;\r\nintel_sdvo_select_i2c_bus(dev_priv, intel_sdvo, sdvo_reg);\r\nif (!intel_sdvo_init_ddc_proxy(intel_sdvo, dev))\r\ngoto err_i2c_bus;\r\nintel_encoder = &intel_sdvo->base;\r\nintel_encoder->type = INTEL_OUTPUT_SDVO;\r\ndrm_encoder_init(dev, &intel_encoder->base, &intel_sdvo_enc_funcs, 0);\r\nfor (i = 0; i < 0x40; i++) {\r\nu8 byte;\r\nif (!intel_sdvo_read_byte(intel_sdvo, i, &byte)) {\r\nDRM_DEBUG_KMS("No SDVO device found on %s\n",\r\nSDVO_NAME(intel_sdvo));\r\ngoto err;\r\n}\r\n}\r\nintel_encoder->compute_config = intel_sdvo_compute_config;\r\nintel_encoder->disable = intel_disable_sdvo;\r\nintel_encoder->pre_enable = intel_sdvo_pre_enable;\r\nintel_encoder->enable = intel_enable_sdvo;\r\nintel_encoder->get_hw_state = intel_sdvo_get_hw_state;\r\nintel_encoder->get_config = intel_sdvo_get_config;\r\nif (!intel_sdvo_get_capabilities(intel_sdvo, &intel_sdvo->caps))\r\ngoto err;\r\nif (intel_sdvo_output_setup(intel_sdvo,\r\nintel_sdvo->caps.output_flags) != true) {\r\nDRM_DEBUG_KMS("SDVO output failed to setup on %s\n",\r\nSDVO_NAME(intel_sdvo));\r\ngoto err_output;\r\n}\r\nif (intel_sdvo->hotplug_active) {\r\nintel_encoder->hpd_pin =\r\nintel_sdvo->is_sdvob ? HPD_SDVO_B : HPD_SDVO_C;\r\n}\r\nintel_sdvo->base.cloneable = 0;\r\nintel_sdvo_select_ddc_bus(dev_priv, intel_sdvo, sdvo_reg);\r\nif (!intel_sdvo_set_target_input(intel_sdvo))\r\ngoto err_output;\r\nif (!intel_sdvo_get_input_pixel_clock_range(intel_sdvo,\r\n&intel_sdvo->pixel_clock_min,\r\n&intel_sdvo->pixel_clock_max))\r\ngoto err_output;\r\nDRM_DEBUG_KMS("%s device VID/DID: %02X:%02X.%02X, "\r\n"clock range %dMHz - %dMHz, "\r\n"input 1: %c, input 2: %c, "\r\n"output 1: %c, output 2: %c\n",\r\nSDVO_NAME(intel_sdvo),\r\nintel_sdvo->caps.vendor_id, intel_sdvo->caps.device_id,\r\nintel_sdvo->caps.device_rev_id,\r\nintel_sdvo->pixel_clock_min / 1000,\r\nintel_sdvo->pixel_clock_max / 1000,\r\n(intel_sdvo->caps.sdvo_inputs_mask & 0x1) ? 'Y' : 'N',\r\n(intel_sdvo->caps.sdvo_inputs_mask & 0x2) ? 'Y' : 'N',\r\nintel_sdvo->caps.output_flags &\r\n(SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_RGB0) ? 'Y' : 'N',\r\nintel_sdvo->caps.output_flags &\r\n(SDVO_OUTPUT_TMDS1 | SDVO_OUTPUT_RGB1) ? 'Y' : 'N');\r\nreturn true;\r\nerr_output:\r\nintel_sdvo_output_cleanup(intel_sdvo);\r\nerr:\r\ndrm_encoder_cleanup(&intel_encoder->base);\r\ni2c_del_adapter(&intel_sdvo->ddc);\r\nerr_i2c_bus:\r\nintel_sdvo_unselect_i2c_bus(intel_sdvo);\r\nkfree(intel_sdvo);\r\nreturn false;\r\n}
