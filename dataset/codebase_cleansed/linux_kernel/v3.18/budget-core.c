static int stop_ts_capture(struct budget *budget)\r\n{\r\ndprintk(2, "budget: %p\n", budget);\r\nsaa7146_write(budget->dev, MC1, MASK_20);\r\nSAA7146_IER_DISABLE(budget->dev, MASK_10);\r\nreturn 0;\r\n}\r\nstatic int start_ts_capture(struct budget *budget)\r\n{\r\nstruct saa7146_dev *dev = budget->dev;\r\ndprintk(2, "budget: %p\n", budget);\r\nif (!budget->feeding || !budget->fe_synced)\r\nreturn 0;\r\nsaa7146_write(dev, MC1, MASK_20);\r\nmemset(budget->grabbing, 0x00, budget->buffer_size);\r\nsaa7146_write(dev, PCI_BT_V1, 0x001c0000 | (saa7146_read(dev, PCI_BT_V1) & ~0x001f0000));\r\nbudget->ttbp = 0;\r\nswitch(budget->card->type) {\r\ncase BUDGET_FS_ACTIVY:\r\nsaa7146_write(dev, DD1_INIT, 0x04000000);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25));\r\nsaa7146_write(dev, BRS_CTRL, 0x00000000);\r\nbreak;\r\ncase BUDGET_PATCH:\r\nsaa7146_write(dev, DD1_INIT, 0x00000200);\r\nsaa7146_write(dev, MC2, (MASK_10 | MASK_26));\r\nsaa7146_write(dev, BRS_CTRL, 0x60000000);\r\nbreak;\r\ncase BUDGET_CIN1200C_MK3:\r\ncase BUDGET_KNC1C_MK3:\r\ncase BUDGET_KNC1C_TDA10024:\r\ncase BUDGET_KNC1CP_MK3:\r\nif (budget->video_port == BUDGET_VIDEO_PORTA) {\r\nsaa7146_write(dev, DD1_INIT, 0x06000200);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nsaa7146_write(dev, BRS_CTRL, 0x00000000);\r\n} else {\r\nsaa7146_write(dev, DD1_INIT, 0x00000600);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nsaa7146_write(dev, BRS_CTRL, 0x60000000);\r\n}\r\nbreak;\r\ndefault:\r\nif (budget->video_port == BUDGET_VIDEO_PORTA) {\r\nsaa7146_write(dev, DD1_INIT, 0x06000200);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nsaa7146_write(dev, BRS_CTRL, 0x00000000);\r\n} else {\r\nsaa7146_write(dev, DD1_INIT, 0x02000600);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nsaa7146_write(dev, BRS_CTRL, 0x60000000);\r\n}\r\n}\r\nsaa7146_write(dev, MC2, (MASK_08 | MASK_24));\r\nmdelay(10);\r\nsaa7146_write(dev, BASE_ODD3, 0);\r\nif (budget->buffer_size > budget->buffer_height * budget->buffer_width) {\r\nsaa7146_write(dev, BASE_EVEN3, budget->buffer_height * budget->buffer_width);\r\n} else {\r\nsaa7146_write(dev, BASE_EVEN3, 0);\r\n}\r\nsaa7146_write(dev, PROT_ADDR3, budget->buffer_size);\r\nsaa7146_write(dev, BASE_PAGE3, budget->pt.dma | ME1 | 0x90);\r\nsaa7146_write(dev, PITCH3, budget->buffer_width);\r\nsaa7146_write(dev, NUM_LINE_BYTE3,\r\n(budget->buffer_height << 16) | budget->buffer_width);\r\nsaa7146_write(dev, MC2, (MASK_04 | MASK_20));\r\nSAA7146_ISR_CLEAR(budget->dev, MASK_10);\r\nSAA7146_IER_ENABLE(budget->dev, MASK_10);\r\nsaa7146_write(dev, MC1, (MASK_04 | MASK_20));\r\nreturn 0;\r\n}\r\nstatic int budget_read_fe_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct budget *budget = (struct budget *) fe->dvb->priv;\r\nint synced;\r\nint ret;\r\nif (budget->read_fe_status)\r\nret = budget->read_fe_status(fe, status);\r\nelse\r\nret = -EINVAL;\r\nif (!ret) {\r\nsynced = (*status & FE_HAS_LOCK);\r\nif (synced != budget->fe_synced) {\r\nbudget->fe_synced = synced;\r\nspin_lock(&budget->feedlock);\r\nif (synced)\r\nstart_ts_capture(budget);\r\nelse\r\nstop_ts_capture(budget);\r\nspin_unlock(&budget->feedlock);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void vpeirq(unsigned long data)\r\n{\r\nstruct budget *budget = (struct budget *) data;\r\nu8 *mem = (u8 *) (budget->grabbing);\r\nu32 olddma = budget->ttbp;\r\nu32 newdma = saa7146_read(budget->dev, PCI_VDP3);\r\nu32 count;\r\npci_dma_sync_sg_for_cpu(budget->dev->pci, budget->pt.slist, budget->pt.nents, PCI_DMA_FROMDEVICE);\r\nnewdma -= newdma % 188;\r\nif (newdma >= budget->buffer_size)\r\nreturn;\r\nbudget->ttbp = newdma;\r\nif (budget->feeding == 0 || newdma == olddma)\r\nreturn;\r\nif (newdma > olddma) {\r\ncount = newdma - olddma;\r\ndvb_dmx_swfilter_packets(&budget->demux, mem + olddma, count / 188);\r\n} else {\r\ncount = budget->buffer_size - olddma;\r\ndvb_dmx_swfilter_packets(&budget->demux, mem + olddma, count / 188);\r\ncount += newdma;\r\ndvb_dmx_swfilter_packets(&budget->demux, mem, newdma / 188);\r\n}\r\nif (count > budget->buffer_warning_threshold)\r\nbudget->buffer_warnings++;\r\nif (budget->buffer_warnings && time_after(jiffies, budget->buffer_warning_time)) {\r\nprintk("%s %s: used %d times >80%% of buffer (%u bytes now)\n",\r\nbudget->dev->name, __func__, budget->buffer_warnings, count);\r\nbudget->buffer_warning_time = jiffies + BUFFER_WARNING_WAIT;\r\nbudget->buffer_warnings = 0;\r\n}\r\n}\r\nint ttpci_budget_debiread(struct budget *budget, u32 config, int addr, int count,\r\nint uselocks, int nobusyloop)\r\n{\r\nstruct saa7146_dev *saa = budget->dev;\r\nint result = 0;\r\nunsigned long flags = 0;\r\nif (count > 4 || count <= 0)\r\nreturn 0;\r\nif (uselocks)\r\nspin_lock_irqsave(&budget->debilock, flags);\r\nif ((result = saa7146_wait_for_debi_done(saa, nobusyloop)) < 0) {\r\nif (uselocks)\r\nspin_unlock_irqrestore(&budget->debilock, flags);\r\nreturn result;\r\n}\r\nsaa7146_write(saa, DEBI_COMMAND, (count << 17) | 0x10000 | (addr & 0xffff));\r\nsaa7146_write(saa, DEBI_CONFIG, config);\r\nsaa7146_write(saa, DEBI_PAGE, 0);\r\nsaa7146_write(saa, MC2, (2 << 16) | 2);\r\nif ((result = saa7146_wait_for_debi_done(saa, nobusyloop)) < 0) {\r\nif (uselocks)\r\nspin_unlock_irqrestore(&budget->debilock, flags);\r\nreturn result;\r\n}\r\nresult = saa7146_read(saa, DEBI_AD);\r\nresult &= (0xffffffffUL >> ((4 - count) * 8));\r\nif (uselocks)\r\nspin_unlock_irqrestore(&budget->debilock, flags);\r\nreturn result;\r\n}\r\nint ttpci_budget_debiwrite(struct budget *budget, u32 config, int addr,\r\nint count, u32 value, int uselocks, int nobusyloop)\r\n{\r\nstruct saa7146_dev *saa = budget->dev;\r\nunsigned long flags = 0;\r\nint result;\r\nif (count > 4 || count <= 0)\r\nreturn 0;\r\nif (uselocks)\r\nspin_lock_irqsave(&budget->debilock, flags);\r\nif ((result = saa7146_wait_for_debi_done(saa, nobusyloop)) < 0) {\r\nif (uselocks)\r\nspin_unlock_irqrestore(&budget->debilock, flags);\r\nreturn result;\r\n}\r\nsaa7146_write(saa, DEBI_COMMAND, (count << 17) | 0x00000 | (addr & 0xffff));\r\nsaa7146_write(saa, DEBI_CONFIG, config);\r\nsaa7146_write(saa, DEBI_PAGE, 0);\r\nsaa7146_write(saa, DEBI_AD, value);\r\nsaa7146_write(saa, MC2, (2 << 16) | 2);\r\nif ((result = saa7146_wait_for_debi_done(saa, nobusyloop)) < 0) {\r\nif (uselocks)\r\nspin_unlock_irqrestore(&budget->debilock, flags);\r\nreturn result;\r\n}\r\nif (uselocks)\r\nspin_unlock_irqrestore(&budget->debilock, flags);\r\nreturn 0;\r\n}\r\nstatic int budget_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct budget *budget = (struct budget *) demux->priv;\r\nint status = 0;\r\ndprintk(2, "budget: %p\n", budget);\r\nif (!demux->dmx.frontend)\r\nreturn -EINVAL;\r\nspin_lock(&budget->feedlock);\r\nfeed->pusi_seen = 0;\r\nif (budget->feeding++ == 0)\r\nstatus = start_ts_capture(budget);\r\nspin_unlock(&budget->feedlock);\r\nreturn status;\r\n}\r\nstatic int budget_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct budget *budget = (struct budget *) demux->priv;\r\nint status = 0;\r\ndprintk(2, "budget: %p\n", budget);\r\nspin_lock(&budget->feedlock);\r\nif (--budget->feeding == 0)\r\nstatus = stop_ts_capture(budget);\r\nspin_unlock(&budget->feedlock);\r\nreturn status;\r\n}\r\nstatic int budget_register(struct budget *budget)\r\n{\r\nstruct dvb_demux *dvbdemux = &budget->demux;\r\nint ret;\r\ndprintk(2, "budget: %p\n", budget);\r\ndvbdemux->priv = (void *) budget;\r\ndvbdemux->filternum = 256;\r\ndvbdemux->feednum = 256;\r\ndvbdemux->start_feed = budget_start_feed;\r\ndvbdemux->stop_feed = budget_stop_feed;\r\ndvbdemux->write_to_decoder = NULL;\r\ndvbdemux->dmx.capabilities = (DMX_TS_FILTERING | DMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING);\r\ndvb_dmx_init(&budget->demux);\r\nbudget->dmxdev.filternum = 256;\r\nbudget->dmxdev.demux = &dvbdemux->dmx;\r\nbudget->dmxdev.capabilities = 0;\r\ndvb_dmxdev_init(&budget->dmxdev, &budget->dvb_adapter);\r\nbudget->hw_frontend.source = DMX_FRONTEND_0;\r\nret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &budget->hw_frontend);\r\nif (ret < 0)\r\nreturn ret;\r\nbudget->mem_frontend.source = DMX_MEMORY_FE;\r\nret = dvbdemux->dmx.add_frontend(&dvbdemux->dmx, &budget->mem_frontend);\r\nif (ret < 0)\r\nreturn ret;\r\nret = dvbdemux->dmx.connect_frontend(&dvbdemux->dmx, &budget->hw_frontend);\r\nif (ret < 0)\r\nreturn ret;\r\ndvb_net_init(&budget->dvb_adapter, &budget->dvb_net, &dvbdemux->dmx);\r\nreturn 0;\r\n}\r\nstatic void budget_unregister(struct budget *budget)\r\n{\r\nstruct dvb_demux *dvbdemux = &budget->demux;\r\ndprintk(2, "budget: %p\n", budget);\r\ndvb_net_release(&budget->dvb_net);\r\ndvbdemux->dmx.close(&dvbdemux->dmx);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &budget->hw_frontend);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx, &budget->mem_frontend);\r\ndvb_dmxdev_release(&budget->dmxdev);\r\ndvb_dmx_release(&budget->demux);\r\n}\r\nint ttpci_budget_init(struct budget *budget, struct saa7146_dev *dev,\r\nstruct saa7146_pci_extension_data *info,\r\nstruct module *owner, short *adapter_nums)\r\n{\r\nint ret = 0;\r\nstruct budget_info *bi = info->ext_priv;\r\nint max_bufsize;\r\nint height_mask;\r\nmemset(budget, 0, sizeof(struct budget));\r\ndprintk(2, "dev: %p, budget: %p\n", dev, budget);\r\nbudget->card = bi;\r\nbudget->dev = (struct saa7146_dev *) dev;\r\nswitch(budget->card->type) {\r\ncase BUDGET_FS_ACTIVY:\r\nbudget->buffer_width = TS_WIDTH_ACTIVY;\r\nmax_bufsize = TS_MAX_BUFSIZE_K_ACTIVY;\r\nheight_mask = TS_HEIGHT_MASK_ACTIVY;\r\nbreak;\r\ncase BUDGET_KNC1C:\r\ncase BUDGET_KNC1CP:\r\ncase BUDGET_CIN1200C:\r\ncase BUDGET_KNC1C_MK3:\r\ncase BUDGET_KNC1C_TDA10024:\r\ncase BUDGET_KNC1CP_MK3:\r\ncase BUDGET_CIN1200C_MK3:\r\nbudget->buffer_width = TS_WIDTH_DVBC;\r\nmax_bufsize = TS_MAX_BUFSIZE_K_DVBC;\r\nheight_mask = TS_HEIGHT_MASK_DVBC;\r\nbreak;\r\ndefault:\r\nbudget->buffer_width = TS_WIDTH;\r\nmax_bufsize = TS_MAX_BUFSIZE_K;\r\nheight_mask = TS_HEIGHT_MASK;\r\n}\r\nif (dma_buffer_size < TS_MIN_BUFSIZE_K)\r\ndma_buffer_size = TS_MIN_BUFSIZE_K;\r\nelse if (dma_buffer_size > max_bufsize)\r\ndma_buffer_size = max_bufsize;\r\nbudget->buffer_height = dma_buffer_size * 1024 / budget->buffer_width;\r\nif (budget->buffer_height > 0xfff) {\r\nbudget->buffer_height /= 2;\r\nbudget->buffer_height &= height_mask;\r\nbudget->buffer_size = 2 * budget->buffer_height * budget->buffer_width;\r\n} else {\r\nbudget->buffer_height &= height_mask;\r\nbudget->buffer_size = budget->buffer_height * budget->buffer_width;\r\n}\r\nbudget->buffer_warning_threshold = budget->buffer_size * 80/100;\r\nbudget->buffer_warnings = 0;\r\nbudget->buffer_warning_time = jiffies;\r\ndprintk(2, "%s: buffer type = %s, width = %d, height = %d\n",\r\nbudget->dev->name,\r\nbudget->buffer_size > budget->buffer_width * budget->buffer_height ? "odd/even" : "single",\r\nbudget->buffer_width, budget->buffer_height);\r\nprintk("%s: dma buffer size %u\n", budget->dev->name, budget->buffer_size);\r\nret = dvb_register_adapter(&budget->dvb_adapter, budget->card->name,\r\nowner, &budget->dev->pci->dev, adapter_nums);\r\nif (ret < 0)\r\nreturn ret;\r\nsaa7146_write(dev, DD1_STREAM_B, 0x00000000);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25));\r\nsaa7146_write(dev, MC2, (MASK_10 | MASK_26));\r\nsaa7146_write(dev, DD1_INIT, 0x02000000);\r\nsaa7146_write(dev, MC2, (MASK_09 | MASK_25 | MASK_10 | MASK_26));\r\nif (bi->type != BUDGET_FS_ACTIVY)\r\nbudget->video_port = BUDGET_VIDEO_PORTB;\r\nelse\r\nbudget->video_port = BUDGET_VIDEO_PORTA;\r\nspin_lock_init(&budget->feedlock);\r\nspin_lock_init(&budget->debilock);\r\nif (bi->type != BUDGET_FS_ACTIVY)\r\nsaa7146_write(dev, GPIO_CTRL, 0x500000);\r\nstrlcpy(budget->i2c_adap.name, budget->card->name, sizeof(budget->i2c_adap.name));\r\nsaa7146_i2c_adapter_prepare(dev, &budget->i2c_adap, SAA7146_I2C_BUS_BIT_RATE_120);\r\nstrcpy(budget->i2c_adap.name, budget->card->name);\r\nif (i2c_add_adapter(&budget->i2c_adap) < 0) {\r\nret = -ENOMEM;\r\ngoto err_dvb_unregister;\r\n}\r\nttpci_eeprom_parse_mac(&budget->i2c_adap, budget->dvb_adapter.proposed_mac);\r\nbudget->grabbing = saa7146_vmalloc_build_pgtable(dev->pci, budget->buffer_size, &budget->pt);\r\nif (NULL == budget->grabbing) {\r\nret = -ENOMEM;\r\ngoto err_del_i2c;\r\n}\r\nsaa7146_write(dev, PCI_BT_V1, 0x001c0000);\r\nsaa7146_write(dev, GPIO_CTRL, 0x000000);\r\ntasklet_init(&budget->vpe_tasklet, vpeirq, (unsigned long) budget);\r\nif (bi->type != BUDGET_FS_ACTIVY)\r\nsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);\r\nif ((ret = budget_register(budget)) == 0)\r\nreturn 0;\r\nsaa7146_vfree_destroy_pgtable(dev->pci, budget->grabbing, &budget->pt);\r\nerr_del_i2c:\r\ni2c_del_adapter(&budget->i2c_adap);\r\nerr_dvb_unregister:\r\ndvb_unregister_adapter(&budget->dvb_adapter);\r\nreturn ret;\r\n}\r\nvoid ttpci_budget_init_hooks(struct budget *budget)\r\n{\r\nif (budget->dvb_frontend && !budget->read_fe_status) {\r\nbudget->read_fe_status = budget->dvb_frontend->ops.read_status;\r\nbudget->dvb_frontend->ops.read_status = budget_read_fe_status;\r\n}\r\n}\r\nint ttpci_budget_deinit(struct budget *budget)\r\n{\r\nstruct saa7146_dev *dev = budget->dev;\r\ndprintk(2, "budget: %p\n", budget);\r\nbudget_unregister(budget);\r\ntasklet_kill(&budget->vpe_tasklet);\r\nsaa7146_vfree_destroy_pgtable(dev->pci, budget->grabbing, &budget->pt);\r\ni2c_del_adapter(&budget->i2c_adap);\r\ndvb_unregister_adapter(&budget->dvb_adapter);\r\nreturn 0;\r\n}\r\nvoid ttpci_budget_irq10_handler(struct saa7146_dev *dev, u32 * isr)\r\n{\r\nstruct budget *budget = (struct budget *) dev->ext_priv;\r\ndprintk(8, "dev: %p, budget: %p\n", dev, budget);\r\nif (*isr & MASK_10)\r\ntasklet_schedule(&budget->vpe_tasklet);\r\n}\r\nvoid ttpci_budget_set_video_port(struct saa7146_dev *dev, int video_port)\r\n{\r\nstruct budget *budget = (struct budget *) dev->ext_priv;\r\nspin_lock(&budget->feedlock);\r\nbudget->video_port = video_port;\r\nif (budget->feeding) {\r\nstop_ts_capture(budget);\r\nstart_ts_capture(budget);\r\n}\r\nspin_unlock(&budget->feedlock);\r\n}
