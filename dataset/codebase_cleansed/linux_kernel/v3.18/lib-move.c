int\r\nlnet_fail_nid(lnet_nid_t nid, unsigned int threshold)\r\n{\r\nlnet_test_peer_t *tp;\r\nstruct list_head *el;\r\nstruct list_head *next;\r\nstruct list_head cull;\r\nLASSERT(the_lnet.ln_init);\r\nif (threshold != 0) {\r\nLIBCFS_ALLOC(tp, sizeof(*tp));\r\nif (tp == NULL)\r\nreturn -ENOMEM;\r\ntp->tp_nid = nid;\r\ntp->tp_threshold = threshold;\r\nlnet_net_lock(0);\r\nlist_add_tail(&tp->tp_list, &the_lnet.ln_test_peers);\r\nlnet_net_unlock(0);\r\nreturn 0;\r\n}\r\nINIT_LIST_HEAD(&cull);\r\nlnet_net_lock(0);\r\nlist_for_each_safe(el, next, &the_lnet.ln_test_peers) {\r\ntp = list_entry(el, lnet_test_peer_t, tp_list);\r\nif (tp->tp_threshold == 0 ||\r\nnid == LNET_NID_ANY ||\r\ntp->tp_nid == nid) {\r\nlist_del(&tp->tp_list);\r\nlist_add(&tp->tp_list, &cull);\r\n}\r\n}\r\nlnet_net_unlock(0);\r\nwhile (!list_empty(&cull)) {\r\ntp = list_entry(cull.next, lnet_test_peer_t, tp_list);\r\nlist_del(&tp->tp_list);\r\nLIBCFS_FREE(tp, sizeof(*tp));\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfail_peer(lnet_nid_t nid, int outgoing)\r\n{\r\nlnet_test_peer_t *tp;\r\nstruct list_head *el;\r\nstruct list_head *next;\r\nstruct list_head cull;\r\nint fail = 0;\r\nINIT_LIST_HEAD(&cull);\r\nlnet_net_lock(0);\r\nlist_for_each_safe(el, next, &the_lnet.ln_test_peers) {\r\ntp = list_entry(el, lnet_test_peer_t, tp_list);\r\nif (tp->tp_threshold == 0) {\r\nif (outgoing) {\r\nlist_del(&tp->tp_list);\r\nlist_add(&tp->tp_list, &cull);\r\n}\r\ncontinue;\r\n}\r\nif (tp->tp_nid == LNET_NID_ANY ||\r\nnid == tp->tp_nid) {\r\nfail = 1;\r\nif (tp->tp_threshold != LNET_MD_THRESH_INF) {\r\ntp->tp_threshold--;\r\nif (outgoing &&\r\ntp->tp_threshold == 0) {\r\nlist_del(&tp->tp_list);\r\nlist_add(&tp->tp_list, &cull);\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nlnet_net_unlock(0);\r\nwhile (!list_empty(&cull)) {\r\ntp = list_entry(cull.next, lnet_test_peer_t, tp_list);\r\nlist_del(&tp->tp_list);\r\nLIBCFS_FREE(tp, sizeof(*tp));\r\n}\r\nreturn fail;\r\n}\r\nunsigned int\r\nlnet_iov_nob(unsigned int niov, struct iovec *iov)\r\n{\r\nunsigned int nob = 0;\r\nwhile (niov-- > 0)\r\nnob += (iov++)->iov_len;\r\nreturn nob;\r\n}\r\nvoid\r\nlnet_copy_iov2iov(unsigned int ndiov, struct iovec *diov, unsigned int doffset,\r\nunsigned int nsiov, struct iovec *siov, unsigned int soffset,\r\nunsigned int nob)\r\n{\r\nunsigned int this_nob;\r\nif (nob == 0)\r\nreturn;\r\nLASSERT(ndiov > 0);\r\nwhile (doffset >= diov->iov_len) {\r\ndoffset -= diov->iov_len;\r\ndiov++;\r\nndiov--;\r\nLASSERT(ndiov > 0);\r\n}\r\nLASSERT(nsiov > 0);\r\nwhile (soffset >= siov->iov_len) {\r\nsoffset -= siov->iov_len;\r\nsiov++;\r\nnsiov--;\r\nLASSERT(nsiov > 0);\r\n}\r\ndo {\r\nLASSERT(ndiov > 0);\r\nLASSERT(nsiov > 0);\r\nthis_nob = MIN(diov->iov_len - doffset,\r\nsiov->iov_len - soffset);\r\nthis_nob = MIN(this_nob, nob);\r\nmemcpy((char *)diov->iov_base + doffset,\r\n(char *)siov->iov_base + soffset, this_nob);\r\nnob -= this_nob;\r\nif (diov->iov_len > doffset + this_nob) {\r\ndoffset += this_nob;\r\n} else {\r\ndiov++;\r\nndiov--;\r\ndoffset = 0;\r\n}\r\nif (siov->iov_len > soffset + this_nob) {\r\nsoffset += this_nob;\r\n} else {\r\nsiov++;\r\nnsiov--;\r\nsoffset = 0;\r\n}\r\n} while (nob > 0);\r\n}\r\nint\r\nlnet_extract_iov(int dst_niov, struct iovec *dst,\r\nint src_niov, struct iovec *src,\r\nunsigned int offset, unsigned int len)\r\n{\r\nunsigned int frag_len;\r\nunsigned int niov;\r\nif (len == 0)\r\nreturn 0;\r\nLASSERT(src_niov > 0);\r\nwhile (offset >= src->iov_len) {\r\noffset -= src->iov_len;\r\nsrc_niov--;\r\nsrc++;\r\nLASSERT(src_niov > 0);\r\n}\r\nniov = 1;\r\nfor (;;) {\r\nLASSERT(src_niov > 0);\r\nLASSERT((int)niov <= dst_niov);\r\nfrag_len = src->iov_len - offset;\r\ndst->iov_base = ((char *)src->iov_base) + offset;\r\nif (len <= frag_len) {\r\ndst->iov_len = len;\r\nreturn niov;\r\n}\r\ndst->iov_len = frag_len;\r\nlen -= frag_len;\r\ndst++;\r\nsrc++;\r\nniov++;\r\nsrc_niov--;\r\noffset = 0;\r\n}\r\n}\r\nunsigned int\r\nlnet_kiov_nob(unsigned int niov, lnet_kiov_t *kiov)\r\n{\r\nunsigned int nob = 0;\r\nwhile (niov-- > 0)\r\nnob += (kiov++)->kiov_len;\r\nreturn nob;\r\n}\r\nvoid\r\nlnet_copy_kiov2kiov(unsigned int ndiov, lnet_kiov_t *diov, unsigned int doffset,\r\nunsigned int nsiov, lnet_kiov_t *siov, unsigned int soffset,\r\nunsigned int nob)\r\n{\r\nunsigned int this_nob;\r\nchar *daddr = NULL;\r\nchar *saddr = NULL;\r\nif (nob == 0)\r\nreturn;\r\nLASSERT(!in_interrupt());\r\nLASSERT(ndiov > 0);\r\nwhile (doffset >= diov->kiov_len) {\r\ndoffset -= diov->kiov_len;\r\ndiov++;\r\nndiov--;\r\nLASSERT(ndiov > 0);\r\n}\r\nLASSERT(nsiov > 0);\r\nwhile (soffset >= siov->kiov_len) {\r\nsoffset -= siov->kiov_len;\r\nsiov++;\r\nnsiov--;\r\nLASSERT(nsiov > 0);\r\n}\r\ndo {\r\nLASSERT(ndiov > 0);\r\nLASSERT(nsiov > 0);\r\nthis_nob = MIN(diov->kiov_len - doffset,\r\nsiov->kiov_len - soffset);\r\nthis_nob = MIN(this_nob, nob);\r\nif (daddr == NULL)\r\ndaddr = ((char *)kmap(diov->kiov_page)) +\r\ndiov->kiov_offset + doffset;\r\nif (saddr == NULL)\r\nsaddr = ((char *)kmap(siov->kiov_page)) +\r\nsiov->kiov_offset + soffset;\r\nmemcpy(daddr, saddr, this_nob);\r\nnob -= this_nob;\r\nif (diov->kiov_len > doffset + this_nob) {\r\ndaddr += this_nob;\r\ndoffset += this_nob;\r\n} else {\r\nkunmap(diov->kiov_page);\r\ndaddr = NULL;\r\ndiov++;\r\nndiov--;\r\ndoffset = 0;\r\n}\r\nif (siov->kiov_len > soffset + this_nob) {\r\nsaddr += this_nob;\r\nsoffset += this_nob;\r\n} else {\r\nkunmap(siov->kiov_page);\r\nsaddr = NULL;\r\nsiov++;\r\nnsiov--;\r\nsoffset = 0;\r\n}\r\n} while (nob > 0);\r\nif (daddr != NULL)\r\nkunmap(diov->kiov_page);\r\nif (saddr != NULL)\r\nkunmap(siov->kiov_page);\r\n}\r\nvoid\r\nlnet_copy_kiov2iov(unsigned int niov, struct iovec *iov, unsigned int iovoffset,\r\nunsigned int nkiov, lnet_kiov_t *kiov,\r\nunsigned int kiovoffset, unsigned int nob)\r\n{\r\nunsigned int this_nob;\r\nchar *addr = NULL;\r\nif (nob == 0)\r\nreturn;\r\nLASSERT(!in_interrupt());\r\nLASSERT(niov > 0);\r\nwhile (iovoffset >= iov->iov_len) {\r\niovoffset -= iov->iov_len;\r\niov++;\r\nniov--;\r\nLASSERT(niov > 0);\r\n}\r\nLASSERT(nkiov > 0);\r\nwhile (kiovoffset >= kiov->kiov_len) {\r\nkiovoffset -= kiov->kiov_len;\r\nkiov++;\r\nnkiov--;\r\nLASSERT(nkiov > 0);\r\n}\r\ndo {\r\nLASSERT(niov > 0);\r\nLASSERT(nkiov > 0);\r\nthis_nob = MIN(iov->iov_len - iovoffset,\r\nkiov->kiov_len - kiovoffset);\r\nthis_nob = MIN(this_nob, nob);\r\nif (addr == NULL)\r\naddr = ((char *)kmap(kiov->kiov_page)) +\r\nkiov->kiov_offset + kiovoffset;\r\nmemcpy((char *)iov->iov_base + iovoffset, addr, this_nob);\r\nnob -= this_nob;\r\nif (iov->iov_len > iovoffset + this_nob) {\r\niovoffset += this_nob;\r\n} else {\r\niov++;\r\nniov--;\r\niovoffset = 0;\r\n}\r\nif (kiov->kiov_len > kiovoffset + this_nob) {\r\naddr += this_nob;\r\nkiovoffset += this_nob;\r\n} else {\r\nkunmap(kiov->kiov_page);\r\naddr = NULL;\r\nkiov++;\r\nnkiov--;\r\nkiovoffset = 0;\r\n}\r\n} while (nob > 0);\r\nif (addr != NULL)\r\nkunmap(kiov->kiov_page);\r\n}\r\nvoid\r\nlnet_copy_iov2kiov(unsigned int nkiov, lnet_kiov_t *kiov,\r\nunsigned int kiovoffset, unsigned int niov,\r\nstruct iovec *iov, unsigned int iovoffset,\r\nunsigned int nob)\r\n{\r\nunsigned int this_nob;\r\nchar *addr = NULL;\r\nif (nob == 0)\r\nreturn;\r\nLASSERT(!in_interrupt());\r\nLASSERT(nkiov > 0);\r\nwhile (kiovoffset >= kiov->kiov_len) {\r\nkiovoffset -= kiov->kiov_len;\r\nkiov++;\r\nnkiov--;\r\nLASSERT(nkiov > 0);\r\n}\r\nLASSERT(niov > 0);\r\nwhile (iovoffset >= iov->iov_len) {\r\niovoffset -= iov->iov_len;\r\niov++;\r\nniov--;\r\nLASSERT(niov > 0);\r\n}\r\ndo {\r\nLASSERT(nkiov > 0);\r\nLASSERT(niov > 0);\r\nthis_nob = MIN(kiov->kiov_len - kiovoffset,\r\niov->iov_len - iovoffset);\r\nthis_nob = MIN(this_nob, nob);\r\nif (addr == NULL)\r\naddr = ((char *)kmap(kiov->kiov_page)) +\r\nkiov->kiov_offset + kiovoffset;\r\nmemcpy(addr, (char *)iov->iov_base + iovoffset, this_nob);\r\nnob -= this_nob;\r\nif (kiov->kiov_len > kiovoffset + this_nob) {\r\naddr += this_nob;\r\nkiovoffset += this_nob;\r\n} else {\r\nkunmap(kiov->kiov_page);\r\naddr = NULL;\r\nkiov++;\r\nnkiov--;\r\nkiovoffset = 0;\r\n}\r\nif (iov->iov_len > iovoffset + this_nob) {\r\niovoffset += this_nob;\r\n} else {\r\niov++;\r\nniov--;\r\niovoffset = 0;\r\n}\r\n} while (nob > 0);\r\nif (addr != NULL)\r\nkunmap(kiov->kiov_page);\r\n}\r\nint\r\nlnet_extract_kiov(int dst_niov, lnet_kiov_t *dst,\r\nint src_niov, lnet_kiov_t *src,\r\nunsigned int offset, unsigned int len)\r\n{\r\nunsigned int frag_len;\r\nunsigned int niov;\r\nif (len == 0)\r\nreturn 0;\r\nLASSERT(src_niov > 0);\r\nwhile (offset >= src->kiov_len) {\r\noffset -= src->kiov_len;\r\nsrc_niov--;\r\nsrc++;\r\nLASSERT(src_niov > 0);\r\n}\r\nniov = 1;\r\nfor (;;) {\r\nLASSERT(src_niov > 0);\r\nLASSERT((int)niov <= dst_niov);\r\nfrag_len = src->kiov_len - offset;\r\ndst->kiov_page = src->kiov_page;\r\ndst->kiov_offset = src->kiov_offset + offset;\r\nif (len <= frag_len) {\r\ndst->kiov_len = len;\r\nLASSERT(dst->kiov_offset + dst->kiov_len\r\n<= PAGE_CACHE_SIZE);\r\nreturn niov;\r\n}\r\ndst->kiov_len = frag_len;\r\nLASSERT(dst->kiov_offset + dst->kiov_len <= PAGE_CACHE_SIZE);\r\nlen -= frag_len;\r\ndst++;\r\nsrc++;\r\nniov++;\r\nsrc_niov--;\r\noffset = 0;\r\n}\r\n}\r\nvoid\r\nlnet_ni_recv(lnet_ni_t *ni, void *private, lnet_msg_t *msg, int delayed,\r\nunsigned int offset, unsigned int mlen, unsigned int rlen)\r\n{\r\nunsigned int niov = 0;\r\nstruct iovec *iov = NULL;\r\nlnet_kiov_t *kiov = NULL;\r\nint rc;\r\nLASSERT(!in_interrupt());\r\nLASSERT(mlen == 0 || msg != NULL);\r\nif (msg != NULL) {\r\nLASSERT(msg->msg_receiving);\r\nLASSERT(!msg->msg_sending);\r\nLASSERT(rlen == msg->msg_len);\r\nLASSERT(mlen <= msg->msg_len);\r\nLASSERT(msg->msg_offset == offset);\r\nLASSERT(msg->msg_wanted == mlen);\r\nmsg->msg_receiving = 0;\r\nif (mlen != 0) {\r\nniov = msg->msg_niov;\r\niov = msg->msg_iov;\r\nkiov = msg->msg_kiov;\r\nLASSERT(niov > 0);\r\nLASSERT((iov == NULL) != (kiov == NULL));\r\n}\r\n}\r\nrc = (ni->ni_lnd->lnd_recv)(ni, private, msg, delayed,\r\nniov, iov, kiov, offset, mlen, rlen);\r\nif (rc < 0)\r\nlnet_finalize(ni, msg, rc);\r\n}\r\nvoid\r\nlnet_setpayloadbuffer(lnet_msg_t *msg)\r\n{\r\nlnet_libmd_t *md = msg->msg_md;\r\nLASSERT(msg->msg_len > 0);\r\nLASSERT(!msg->msg_routing);\r\nLASSERT(md != NULL);\r\nLASSERT(msg->msg_niov == 0);\r\nLASSERT(msg->msg_iov == NULL);\r\nLASSERT(msg->msg_kiov == NULL);\r\nmsg->msg_niov = md->md_niov;\r\nif ((md->md_options & LNET_MD_KIOV) != 0)\r\nmsg->msg_kiov = md->md_iov.kiov;\r\nelse\r\nmsg->msg_iov = md->md_iov.iov;\r\n}\r\nvoid\r\nlnet_prep_send(lnet_msg_t *msg, int type, lnet_process_id_t target,\r\nunsigned int offset, unsigned int len)\r\n{\r\nmsg->msg_type = type;\r\nmsg->msg_target = target;\r\nmsg->msg_len = len;\r\nmsg->msg_offset = offset;\r\nif (len != 0)\r\nlnet_setpayloadbuffer(msg);\r\nmemset(&msg->msg_hdr, 0, sizeof(msg->msg_hdr));\r\nmsg->msg_hdr.type = cpu_to_le32(type);\r\nmsg->msg_hdr.dest_nid = cpu_to_le64(target.nid);\r\nmsg->msg_hdr.dest_pid = cpu_to_le32(target.pid);\r\nmsg->msg_hdr.src_pid = cpu_to_le32(the_lnet.ln_pid);\r\nmsg->msg_hdr.payload_length = cpu_to_le32(len);\r\n}\r\nvoid\r\nlnet_ni_send(lnet_ni_t *ni, lnet_msg_t *msg)\r\n{\r\nvoid *priv = msg->msg_private;\r\nint rc;\r\nLASSERT(!in_interrupt());\r\nLASSERT(LNET_NETTYP(LNET_NIDNET(ni->ni_nid)) == LOLND ||\r\n(msg->msg_txcredit && msg->msg_peertxcredit));\r\nrc = (ni->ni_lnd->lnd_send)(ni, priv, msg);\r\nif (rc < 0)\r\nlnet_finalize(ni, msg, rc);\r\n}\r\nint\r\nlnet_ni_eager_recv(lnet_ni_t *ni, lnet_msg_t *msg)\r\n{\r\nint rc;\r\nLASSERT(!msg->msg_sending);\r\nLASSERT(msg->msg_receiving);\r\nLASSERT(!msg->msg_rx_ready_delay);\r\nLASSERT(ni->ni_lnd->lnd_eager_recv != NULL);\r\nmsg->msg_rx_ready_delay = 1;\r\nrc = (ni->ni_lnd->lnd_eager_recv)(ni, msg->msg_private, msg,\r\n&msg->msg_private);\r\nif (rc != 0) {\r\nCERROR("recv from %s / send to %s aborted: "\r\n"eager_recv failed %d\n",\r\nlibcfs_nid2str(msg->msg_rxpeer->lp_nid),\r\nlibcfs_id2str(msg->msg_target), rc);\r\nLASSERT(rc < 0);\r\n}\r\nreturn rc;\r\n}\r\nvoid\r\nlnet_ni_query_locked(lnet_ni_t *ni, lnet_peer_t *lp)\r\n{\r\nunsigned long last_alive = 0;\r\nLASSERT(lnet_peer_aliveness_enabled(lp));\r\nLASSERT(ni->ni_lnd->lnd_query != NULL);\r\nlnet_net_unlock(lp->lp_cpt);\r\n(ni->ni_lnd->lnd_query)(ni, lp->lp_nid, &last_alive);\r\nlnet_net_lock(lp->lp_cpt);\r\nlp->lp_last_query = cfs_time_current();\r\nif (last_alive != 0)\r\nlp->lp_last_alive = last_alive;\r\n}\r\nstatic inline int\r\nlnet_peer_is_alive(lnet_peer_t *lp, unsigned long now)\r\n{\r\nint alive;\r\nunsigned long deadline;\r\nLASSERT(lnet_peer_aliveness_enabled(lp));\r\nif (!lp->lp_alive && lp->lp_alive_count > 0 &&\r\ncfs_time_aftereq(lp->lp_timestamp, lp->lp_last_alive))\r\nreturn 0;\r\ndeadline = cfs_time_add(lp->lp_last_alive,\r\ncfs_time_seconds(lp->lp_ni->ni_peertimeout));\r\nalive = cfs_time_after(deadline, now);\r\nif (alive && !lp->lp_alive &&\r\n!(lnet_isrouter(lp) && lp->lp_alive_count == 0))\r\nlnet_notify_locked(lp, 0, 1, lp->lp_last_alive);\r\nreturn alive;\r\n}\r\nint\r\nlnet_peer_alive_locked(lnet_peer_t *lp)\r\n{\r\nunsigned long now = cfs_time_current();\r\nif (!lnet_peer_aliveness_enabled(lp))\r\nreturn -ENODEV;\r\nif (lnet_peer_is_alive(lp, now))\r\nreturn 1;\r\nif (lp->lp_last_query != 0) {\r\nstatic const int lnet_queryinterval = 1;\r\nunsigned long next_query =\r\ncfs_time_add(lp->lp_last_query,\r\ncfs_time_seconds(lnet_queryinterval));\r\nif (time_before(now, next_query)) {\r\nif (lp->lp_alive)\r\nCWARN("Unexpected aliveness of peer %s: "\r\n"%d < %d (%d/%d)\n",\r\nlibcfs_nid2str(lp->lp_nid),\r\n(int)now, (int)next_query,\r\nlnet_queryinterval,\r\nlp->lp_ni->ni_peertimeout);\r\nreturn 0;\r\n}\r\n}\r\nlnet_ni_query_locked(lp->lp_ni, lp);\r\nif (lnet_peer_is_alive(lp, now))\r\nreturn 1;\r\nlnet_notify_locked(lp, 0, 0, lp->lp_last_alive);\r\nreturn 0;\r\n}\r\nstatic int\r\nlnet_post_send_locked(lnet_msg_t *msg, int do_send)\r\n{\r\nlnet_peer_t *lp = msg->msg_txpeer;\r\nlnet_ni_t *ni = lp->lp_ni;\r\nint cpt = msg->msg_tx_cpt;\r\nstruct lnet_tx_queue *tq = ni->ni_tx_queues[cpt];\r\nLASSERT(!do_send || msg->msg_tx_delayed);\r\nLASSERT(!msg->msg_receiving);\r\nLASSERT(msg->msg_tx_committed);\r\nif ((msg->msg_target.pid & LNET_PID_USERFLAG) == 0 &&\r\nlnet_peer_alive_locked(lp) == 0) {\r\nthe_lnet.ln_counters[cpt]->drop_count++;\r\nthe_lnet.ln_counters[cpt]->drop_length += msg->msg_len;\r\nlnet_net_unlock(cpt);\r\nCNETERR("Dropping message for %s: peer not alive\n",\r\nlibcfs_id2str(msg->msg_target));\r\nif (do_send)\r\nlnet_finalize(ni, msg, -EHOSTUNREACH);\r\nlnet_net_lock(cpt);\r\nreturn EHOSTUNREACH;\r\n}\r\nif (msg->msg_md != NULL &&\r\n(msg->msg_md->md_flags & LNET_MD_FLAG_ABORTED) != 0) {\r\nlnet_net_unlock(cpt);\r\nCNETERR("Aborting message for %s: LNetM[DE]Unlink() already "\r\n"called on the MD/ME.\n",\r\nlibcfs_id2str(msg->msg_target));\r\nif (do_send)\r\nlnet_finalize(ni, msg, -ECANCELED);\r\nlnet_net_lock(cpt);\r\nreturn ECANCELED;\r\n}\r\nif (!msg->msg_peertxcredit) {\r\nLASSERT((lp->lp_txcredits < 0) ==\r\n!list_empty(&lp->lp_txq));\r\nmsg->msg_peertxcredit = 1;\r\nlp->lp_txqnob += msg->msg_len + sizeof(lnet_hdr_t);\r\nlp->lp_txcredits--;\r\nif (lp->lp_txcredits < lp->lp_mintxcredits)\r\nlp->lp_mintxcredits = lp->lp_txcredits;\r\nif (lp->lp_txcredits < 0) {\r\nmsg->msg_tx_delayed = 1;\r\nlist_add_tail(&msg->msg_list, &lp->lp_txq);\r\nreturn EAGAIN;\r\n}\r\n}\r\nif (!msg->msg_txcredit) {\r\nLASSERT((tq->tq_credits < 0) ==\r\n!list_empty(&tq->tq_delayed));\r\nmsg->msg_txcredit = 1;\r\ntq->tq_credits--;\r\nif (tq->tq_credits < tq->tq_credits_min)\r\ntq->tq_credits_min = tq->tq_credits;\r\nif (tq->tq_credits < 0) {\r\nmsg->msg_tx_delayed = 1;\r\nlist_add_tail(&msg->msg_list, &tq->tq_delayed);\r\nreturn EAGAIN;\r\n}\r\n}\r\nif (do_send) {\r\nlnet_net_unlock(cpt);\r\nlnet_ni_send(ni, msg);\r\nlnet_net_lock(cpt);\r\n}\r\nreturn 0;\r\n}\r\nlnet_rtrbufpool_t *\r\nlnet_msg2bufpool(lnet_msg_t *msg)\r\n{\r\nlnet_rtrbufpool_t *rbp;\r\nint cpt;\r\nLASSERT(msg->msg_rx_committed);\r\ncpt = msg->msg_rx_cpt;\r\nrbp = &the_lnet.ln_rtrpools[cpt][0];\r\nLASSERT(msg->msg_len <= LNET_MTU);\r\nwhile (msg->msg_len > (unsigned int)rbp->rbp_npages * PAGE_CACHE_SIZE) {\r\nrbp++;\r\nLASSERT(rbp < &the_lnet.ln_rtrpools[cpt][LNET_NRBPOOLS]);\r\n}\r\nreturn rbp;\r\n}\r\nint\r\nlnet_post_routed_recv_locked(lnet_msg_t *msg, int do_recv)\r\n{\r\nlnet_peer_t *lp = msg->msg_rxpeer;\r\nlnet_rtrbufpool_t *rbp;\r\nlnet_rtrbuf_t *rb;\r\nLASSERT(msg->msg_iov == NULL);\r\nLASSERT(msg->msg_kiov == NULL);\r\nLASSERT(msg->msg_niov == 0);\r\nLASSERT(msg->msg_routing);\r\nLASSERT(msg->msg_receiving);\r\nLASSERT(!msg->msg_sending);\r\nLASSERT(!do_recv || msg->msg_rx_delayed);\r\nif (!msg->msg_peerrtrcredit) {\r\nLASSERT((lp->lp_rtrcredits < 0) ==\r\n!list_empty(&lp->lp_rtrq));\r\nmsg->msg_peerrtrcredit = 1;\r\nlp->lp_rtrcredits--;\r\nif (lp->lp_rtrcredits < lp->lp_minrtrcredits)\r\nlp->lp_minrtrcredits = lp->lp_rtrcredits;\r\nif (lp->lp_rtrcredits < 0) {\r\nLASSERT(msg->msg_rx_ready_delay);\r\nmsg->msg_rx_delayed = 1;\r\nlist_add_tail(&msg->msg_list, &lp->lp_rtrq);\r\nreturn EAGAIN;\r\n}\r\n}\r\nrbp = lnet_msg2bufpool(msg);\r\nif (!msg->msg_rtrcredit) {\r\nLASSERT((rbp->rbp_credits < 0) ==\r\n!list_empty(&rbp->rbp_msgs));\r\nmsg->msg_rtrcredit = 1;\r\nrbp->rbp_credits--;\r\nif (rbp->rbp_credits < rbp->rbp_mincredits)\r\nrbp->rbp_mincredits = rbp->rbp_credits;\r\nif (rbp->rbp_credits < 0) {\r\nLASSERT(msg->msg_rx_ready_delay);\r\nmsg->msg_rx_delayed = 1;\r\nlist_add_tail(&msg->msg_list, &rbp->rbp_msgs);\r\nreturn EAGAIN;\r\n}\r\n}\r\nLASSERT(!list_empty(&rbp->rbp_bufs));\r\nrb = list_entry(rbp->rbp_bufs.next, lnet_rtrbuf_t, rb_list);\r\nlist_del(&rb->rb_list);\r\nmsg->msg_niov = rbp->rbp_npages;\r\nmsg->msg_kiov = &rb->rb_kiov[0];\r\nif (do_recv) {\r\nint cpt = msg->msg_rx_cpt;\r\nlnet_net_unlock(cpt);\r\nlnet_ni_recv(lp->lp_ni, msg->msg_private, msg, 1,\r\n0, msg->msg_len, msg->msg_len);\r\nlnet_net_lock(cpt);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_return_tx_credits_locked(lnet_msg_t *msg)\r\n{\r\nlnet_peer_t *txpeer = msg->msg_txpeer;\r\nlnet_msg_t *msg2;\r\nif (msg->msg_txcredit) {\r\nstruct lnet_ni *ni = txpeer->lp_ni;\r\nstruct lnet_tx_queue *tq = ni->ni_tx_queues[msg->msg_tx_cpt];\r\nmsg->msg_txcredit = 0;\r\nLASSERT((tq->tq_credits < 0) ==\r\n!list_empty(&tq->tq_delayed));\r\ntq->tq_credits++;\r\nif (tq->tq_credits <= 0) {\r\nmsg2 = list_entry(tq->tq_delayed.next,\r\nlnet_msg_t, msg_list);\r\nlist_del(&msg2->msg_list);\r\nLASSERT(msg2->msg_txpeer->lp_ni == ni);\r\nLASSERT(msg2->msg_tx_delayed);\r\n(void) lnet_post_send_locked(msg2, 1);\r\n}\r\n}\r\nif (msg->msg_peertxcredit) {\r\nmsg->msg_peertxcredit = 0;\r\nLASSERT((txpeer->lp_txcredits < 0) ==\r\n!list_empty(&txpeer->lp_txq));\r\ntxpeer->lp_txqnob -= msg->msg_len + sizeof(lnet_hdr_t);\r\nLASSERT(txpeer->lp_txqnob >= 0);\r\ntxpeer->lp_txcredits++;\r\nif (txpeer->lp_txcredits <= 0) {\r\nmsg2 = list_entry(txpeer->lp_txq.next,\r\nlnet_msg_t, msg_list);\r\nlist_del(&msg2->msg_list);\r\nLASSERT(msg2->msg_txpeer == txpeer);\r\nLASSERT(msg2->msg_tx_delayed);\r\n(void) lnet_post_send_locked(msg2, 1);\r\n}\r\n}\r\nif (txpeer != NULL) {\r\nmsg->msg_txpeer = NULL;\r\nlnet_peer_decref_locked(txpeer);\r\n}\r\n}\r\nvoid\r\nlnet_return_rx_credits_locked(lnet_msg_t *msg)\r\n{\r\nlnet_peer_t *rxpeer = msg->msg_rxpeer;\r\nlnet_msg_t *msg2;\r\nif (msg->msg_rtrcredit) {\r\nlnet_rtrbuf_t *rb;\r\nlnet_rtrbufpool_t *rbp;\r\nLASSERT(msg->msg_kiov != NULL);\r\nrb = list_entry(msg->msg_kiov, lnet_rtrbuf_t, rb_kiov[0]);\r\nrbp = rb->rb_pool;\r\nLASSERT(rbp == lnet_msg2bufpool(msg));\r\nmsg->msg_kiov = NULL;\r\nmsg->msg_rtrcredit = 0;\r\nLASSERT((rbp->rbp_credits < 0) ==\r\n!list_empty(&rbp->rbp_msgs));\r\nLASSERT((rbp->rbp_credits > 0) ==\r\n!list_empty(&rbp->rbp_bufs));\r\nlist_add(&rb->rb_list, &rbp->rbp_bufs);\r\nrbp->rbp_credits++;\r\nif (rbp->rbp_credits <= 0) {\r\nmsg2 = list_entry(rbp->rbp_msgs.next,\r\nlnet_msg_t, msg_list);\r\nlist_del(&msg2->msg_list);\r\n(void) lnet_post_routed_recv_locked(msg2, 1);\r\n}\r\n}\r\nif (msg->msg_peerrtrcredit) {\r\nmsg->msg_peerrtrcredit = 0;\r\nLASSERT((rxpeer->lp_rtrcredits < 0) ==\r\n!list_empty(&rxpeer->lp_rtrq));\r\nrxpeer->lp_rtrcredits++;\r\nif (rxpeer->lp_rtrcredits <= 0) {\r\nmsg2 = list_entry(rxpeer->lp_rtrq.next,\r\nlnet_msg_t, msg_list);\r\nlist_del(&msg2->msg_list);\r\n(void) lnet_post_routed_recv_locked(msg2, 1);\r\n}\r\n}\r\nif (rxpeer != NULL) {\r\nmsg->msg_rxpeer = NULL;\r\nlnet_peer_decref_locked(rxpeer);\r\n}\r\n}\r\nstatic int\r\nlnet_compare_routes(lnet_route_t *r1, lnet_route_t *r2)\r\n{\r\nlnet_peer_t *p1 = r1->lr_gateway;\r\nlnet_peer_t *p2 = r2->lr_gateway;\r\nif (r1->lr_priority < r2->lr_priority)\r\nreturn 1;\r\nif (r1->lr_priority > r2->lr_priority)\r\nreturn -1;\r\nif (r1->lr_hops < r2->lr_hops)\r\nreturn 1;\r\nif (r1->lr_hops > r2->lr_hops)\r\nreturn -1;\r\nif (p1->lp_txqnob < p2->lp_txqnob)\r\nreturn 1;\r\nif (p1->lp_txqnob > p2->lp_txqnob)\r\nreturn -1;\r\nif (p1->lp_txcredits > p2->lp_txcredits)\r\nreturn 1;\r\nif (p1->lp_txcredits < p2->lp_txcredits)\r\nreturn -1;\r\nif (r1->lr_seq - r2->lr_seq <= 0)\r\nreturn 1;\r\nreturn -1;\r\n}\r\nstatic lnet_peer_t *\r\nlnet_find_route_locked(lnet_ni_t *ni, lnet_nid_t target, lnet_nid_t rtr_nid)\r\n{\r\nlnet_remotenet_t *rnet;\r\nlnet_route_t *rtr;\r\nlnet_route_t *rtr_best;\r\nlnet_route_t *rtr_last;\r\nstruct lnet_peer *lp_best;\r\nstruct lnet_peer *lp;\r\nint rc;\r\nrnet = lnet_find_net_locked(LNET_NIDNET(target));\r\nif (rnet == NULL)\r\nreturn NULL;\r\nlp_best = NULL;\r\nrtr_best = rtr_last = NULL;\r\nlist_for_each_entry(rtr, &rnet->lrn_routes, lr_list) {\r\nlp = rtr->lr_gateway;\r\nif (!lp->lp_alive ||\r\n((lp->lp_ping_feats & LNET_PING_FEAT_NI_STATUS) != 0 &&\r\nrtr->lr_downis != 0))\r\ncontinue;\r\nif (ni != NULL && lp->lp_ni != ni)\r\ncontinue;\r\nif (lp->lp_nid == rtr_nid)\r\nreturn lp;\r\nif (lp_best == NULL) {\r\nrtr_best = rtr_last = rtr;\r\nlp_best = lp;\r\ncontinue;\r\n}\r\nif (rtr_last->lr_seq - rtr->lr_seq < 0)\r\nrtr_last = rtr;\r\nrc = lnet_compare_routes(rtr, rtr_best);\r\nif (rc < 0)\r\ncontinue;\r\nrtr_best = rtr;\r\nlp_best = lp;\r\n}\r\nif (rtr_best != NULL)\r\nrtr_best->lr_seq = rtr_last->lr_seq + 1;\r\nreturn lp_best;\r\n}\r\nint\r\nlnet_send(lnet_nid_t src_nid, lnet_msg_t *msg, lnet_nid_t rtr_nid)\r\n{\r\nlnet_nid_t dst_nid = msg->msg_target.nid;\r\nstruct lnet_ni *src_ni;\r\nstruct lnet_ni *local_ni;\r\nstruct lnet_peer *lp;\r\nint cpt;\r\nint cpt2;\r\nint rc;\r\nLASSERT(msg->msg_txpeer == NULL);\r\nLASSERT(!msg->msg_sending);\r\nLASSERT(!msg->msg_target_is_router);\r\nLASSERT(!msg->msg_receiving);\r\nmsg->msg_sending = 1;\r\nLASSERT(!msg->msg_tx_committed);\r\ncpt = lnet_cpt_of_nid(rtr_nid == LNET_NID_ANY ? dst_nid : rtr_nid);\r\nagain:\r\nlnet_net_lock(cpt);\r\nif (the_lnet.ln_shutdown) {\r\nlnet_net_unlock(cpt);\r\nreturn -ESHUTDOWN;\r\n}\r\nif (src_nid == LNET_NID_ANY) {\r\nsrc_ni = NULL;\r\n} else {\r\nsrc_ni = lnet_nid2ni_locked(src_nid, cpt);\r\nif (src_ni == NULL) {\r\nlnet_net_unlock(cpt);\r\nLCONSOLE_WARN("Can't send to %s: src %s is not a "\r\n"local nid\n", libcfs_nid2str(dst_nid),\r\nlibcfs_nid2str(src_nid));\r\nreturn -EINVAL;\r\n}\r\nLASSERT(!msg->msg_routing);\r\n}\r\nlocal_ni = lnet_net2ni_locked(LNET_NIDNET(dst_nid), cpt);\r\nif (local_ni != NULL) {\r\nif (src_ni == NULL) {\r\nsrc_ni = local_ni;\r\nsrc_nid = src_ni->ni_nid;\r\n} else if (src_ni == local_ni) {\r\nlnet_ni_decref_locked(local_ni, cpt);\r\n} else {\r\nlnet_ni_decref_locked(local_ni, cpt);\r\nlnet_ni_decref_locked(src_ni, cpt);\r\nlnet_net_unlock(cpt);\r\nLCONSOLE_WARN("No route to %s via from %s\n",\r\nlibcfs_nid2str(dst_nid),\r\nlibcfs_nid2str(src_nid));\r\nreturn -EINVAL;\r\n}\r\nLASSERT(src_nid != LNET_NID_ANY);\r\nlnet_msg_commit(msg, cpt);\r\nif (!msg->msg_routing)\r\nmsg->msg_hdr.src_nid = cpu_to_le64(src_nid);\r\nif (src_ni == the_lnet.ln_loni) {\r\nlnet_net_unlock(cpt);\r\nlnet_ni_send(src_ni, msg);\r\nlnet_net_lock(cpt);\r\nlnet_ni_decref_locked(src_ni, cpt);\r\nlnet_net_unlock(cpt);\r\nreturn 0;\r\n}\r\nrc = lnet_nid2peer_locked(&lp, dst_nid, cpt);\r\nlnet_ni_decref_locked(src_ni, cpt);\r\nif (rc != 0) {\r\nlnet_net_unlock(cpt);\r\nLCONSOLE_WARN("Error %d finding peer %s\n", rc,\r\nlibcfs_nid2str(dst_nid));\r\nreturn rc;\r\n}\r\nLASSERT(lp->lp_ni == src_ni);\r\n} else {\r\nlp = lnet_find_route_locked(src_ni, dst_nid, rtr_nid);\r\nif (lp == NULL) {\r\nif (src_ni != NULL)\r\nlnet_ni_decref_locked(src_ni, cpt);\r\nlnet_net_unlock(cpt);\r\nLCONSOLE_WARN("No route to %s via %s "\r\n"(all routers down)\n",\r\nlibcfs_id2str(msg->msg_target),\r\nlibcfs_nid2str(src_nid));\r\nreturn -EHOSTUNREACH;\r\n}\r\nif (rtr_nid != lp->lp_nid) {\r\ncpt2 = lnet_cpt_of_nid_locked(lp->lp_nid);\r\nif (cpt2 != cpt) {\r\nif (src_ni != NULL)\r\nlnet_ni_decref_locked(src_ni, cpt);\r\nlnet_net_unlock(cpt);\r\nrtr_nid = lp->lp_nid;\r\ncpt = cpt2;\r\ngoto again;\r\n}\r\n}\r\nCDEBUG(D_NET, "Best route to %s via %s for %s %d\n",\r\nlibcfs_nid2str(dst_nid), libcfs_nid2str(lp->lp_nid),\r\nlnet_msgtyp2str(msg->msg_type), msg->msg_len);\r\nif (src_ni == NULL) {\r\nsrc_ni = lp->lp_ni;\r\nsrc_nid = src_ni->ni_nid;\r\n} else {\r\nLASSERT(src_ni == lp->lp_ni);\r\nlnet_ni_decref_locked(src_ni, cpt);\r\n}\r\nlnet_peer_addref_locked(lp);\r\nLASSERT(src_nid != LNET_NID_ANY);\r\nlnet_msg_commit(msg, cpt);\r\nif (!msg->msg_routing) {\r\nmsg->msg_hdr.src_nid = cpu_to_le64(src_nid);\r\n}\r\nmsg->msg_target_is_router = 1;\r\nmsg->msg_target.nid = lp->lp_nid;\r\nmsg->msg_target.pid = LUSTRE_SRV_LNET_PID;\r\n}\r\nLASSERT(!msg->msg_peertxcredit);\r\nLASSERT(!msg->msg_txcredit);\r\nLASSERT(msg->msg_txpeer == NULL);\r\nmsg->msg_txpeer = lp;\r\nrc = lnet_post_send_locked(msg, 0);\r\nlnet_net_unlock(cpt);\r\nif (rc == EHOSTUNREACH || rc == ECANCELED)\r\nreturn -rc;\r\nif (rc == 0)\r\nlnet_ni_send(src_ni, msg);\r\nreturn 0;\r\n}\r\nstatic void\r\nlnet_drop_message(lnet_ni_t *ni, int cpt, void *private, unsigned int nob)\r\n{\r\nlnet_net_lock(cpt);\r\nthe_lnet.ln_counters[cpt]->drop_count++;\r\nthe_lnet.ln_counters[cpt]->drop_length += nob;\r\nlnet_net_unlock(cpt);\r\nlnet_ni_recv(ni, private, NULL, 0, 0, 0, nob);\r\n}\r\nstatic void\r\nlnet_recv_put(lnet_ni_t *ni, lnet_msg_t *msg)\r\n{\r\nlnet_hdr_t *hdr = &msg->msg_hdr;\r\nif (msg->msg_wanted != 0)\r\nlnet_setpayloadbuffer(msg);\r\nlnet_build_msg_event(msg, LNET_EVENT_PUT);\r\nmsg->msg_ack = (!lnet_is_wire_handle_none(&hdr->msg.put.ack_wmd) &&\r\n(msg->msg_md->md_options & LNET_MD_ACK_DISABLE) == 0);\r\nlnet_ni_recv(ni, msg->msg_private, msg, msg->msg_rx_delayed,\r\nmsg->msg_offset, msg->msg_wanted, hdr->payload_length);\r\n}\r\nstatic int\r\nlnet_parse_put(lnet_ni_t *ni, lnet_msg_t *msg)\r\n{\r\nlnet_hdr_t *hdr = &msg->msg_hdr;\r\nstruct lnet_match_info info;\r\nint rc;\r\nhdr->msg.put.match_bits = le64_to_cpu(hdr->msg.put.match_bits);\r\nhdr->msg.put.ptl_index = le32_to_cpu(hdr->msg.put.ptl_index);\r\nhdr->msg.put.offset = le32_to_cpu(hdr->msg.put.offset);\r\ninfo.mi_id.nid = hdr->src_nid;\r\ninfo.mi_id.pid = hdr->src_pid;\r\ninfo.mi_opc = LNET_MD_OP_PUT;\r\ninfo.mi_portal = hdr->msg.put.ptl_index;\r\ninfo.mi_rlength = hdr->payload_length;\r\ninfo.mi_roffset = hdr->msg.put.offset;\r\ninfo.mi_mbits = hdr->msg.put.match_bits;\r\nmsg->msg_rx_ready_delay = ni->ni_lnd->lnd_eager_recv == NULL;\r\nagain:\r\nrc = lnet_ptl_match_md(&info, msg);\r\nswitch (rc) {\r\ndefault:\r\nLBUG();\r\ncase LNET_MATCHMD_OK:\r\nlnet_recv_put(ni, msg);\r\nreturn 0;\r\ncase LNET_MATCHMD_NONE:\r\nif (msg->msg_rx_delayed)\r\nreturn 0;\r\nrc = lnet_ni_eager_recv(ni, msg);\r\nif (rc == 0)\r\ngoto again;\r\ncase LNET_MATCHMD_DROP:\r\nCNETERR("Dropping PUT from %s portal %d match %llu offset %d length %d: %d\n",\r\nlibcfs_id2str(info.mi_id), info.mi_portal,\r\ninfo.mi_mbits, info.mi_roffset, info.mi_rlength, rc);\r\nreturn ENOENT;\r\n}\r\n}\r\nstatic int\r\nlnet_parse_get(lnet_ni_t *ni, lnet_msg_t *msg, int rdma_get)\r\n{\r\nstruct lnet_match_info info;\r\nlnet_hdr_t *hdr = &msg->msg_hdr;\r\nlnet_handle_wire_t reply_wmd;\r\nint rc;\r\nhdr->msg.get.match_bits = le64_to_cpu(hdr->msg.get.match_bits);\r\nhdr->msg.get.ptl_index = le32_to_cpu(hdr->msg.get.ptl_index);\r\nhdr->msg.get.sink_length = le32_to_cpu(hdr->msg.get.sink_length);\r\nhdr->msg.get.src_offset = le32_to_cpu(hdr->msg.get.src_offset);\r\ninfo.mi_id.nid = hdr->src_nid;\r\ninfo.mi_id.pid = hdr->src_pid;\r\ninfo.mi_opc = LNET_MD_OP_GET;\r\ninfo.mi_portal = hdr->msg.get.ptl_index;\r\ninfo.mi_rlength = hdr->msg.get.sink_length;\r\ninfo.mi_roffset = hdr->msg.get.src_offset;\r\ninfo.mi_mbits = hdr->msg.get.match_bits;\r\nrc = lnet_ptl_match_md(&info, msg);\r\nif (rc == LNET_MATCHMD_DROP) {\r\nCNETERR("Dropping GET from %s portal %d match %llu offset %d length %d\n",\r\nlibcfs_id2str(info.mi_id), info.mi_portal,\r\ninfo.mi_mbits, info.mi_roffset, info.mi_rlength);\r\nreturn ENOENT;\r\n}\r\nLASSERT(rc == LNET_MATCHMD_OK);\r\nlnet_build_msg_event(msg, LNET_EVENT_GET);\r\nreply_wmd = hdr->msg.get.return_wmd;\r\nlnet_prep_send(msg, LNET_MSG_REPLY, info.mi_id,\r\nmsg->msg_offset, msg->msg_wanted);\r\nmsg->msg_hdr.msg.reply.dst_wmd = reply_wmd;\r\nif (rdma_get) {\r\nlnet_ni_recv(ni, msg->msg_private, msg, 0,\r\nmsg->msg_offset, msg->msg_len, msg->msg_len);\r\nreturn 0;\r\n}\r\nlnet_ni_recv(ni, msg->msg_private, NULL, 0, 0, 0, 0);\r\nmsg->msg_receiving = 0;\r\nrc = lnet_send(ni->ni_nid, msg, LNET_NID_ANY);\r\nif (rc < 0) {\r\nCERROR("%s: Unable to send REPLY for GET from %s: %d\n",\r\nlibcfs_nid2str(ni->ni_nid),\r\nlibcfs_id2str(info.mi_id), rc);\r\nlnet_finalize(ni, msg, rc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlnet_parse_reply(lnet_ni_t *ni, lnet_msg_t *msg)\r\n{\r\nvoid *private = msg->msg_private;\r\nlnet_hdr_t *hdr = &msg->msg_hdr;\r\nlnet_process_id_t src = {0};\r\nlnet_libmd_t *md;\r\nint rlength;\r\nint mlength;\r\nint cpt;\r\ncpt = lnet_cpt_of_cookie(hdr->msg.reply.dst_wmd.wh_object_cookie);\r\nlnet_res_lock(cpt);\r\nsrc.nid = hdr->src_nid;\r\nsrc.pid = hdr->src_pid;\r\nmd = lnet_wire_handle2md(&hdr->msg.reply.dst_wmd);\r\nif (md == NULL || md->md_threshold == 0 || md->md_me != NULL) {\r\nCNETERR("%s: Dropping REPLY from %s for %s MD %#llx.%#llx\n",\r\nlibcfs_nid2str(ni->ni_nid), libcfs_id2str(src),\r\n(md == NULL) ? "invalid" : "inactive",\r\nhdr->msg.reply.dst_wmd.wh_interface_cookie,\r\nhdr->msg.reply.dst_wmd.wh_object_cookie);\r\nif (md != NULL && md->md_me != NULL)\r\nCERROR("REPLY MD also attached to portal %d\n",\r\nmd->md_me->me_portal);\r\nlnet_res_unlock(cpt);\r\nreturn ENOENT;\r\n}\r\nLASSERT(md->md_offset == 0);\r\nrlength = hdr->payload_length;\r\nmlength = MIN(rlength, (int)md->md_length);\r\nif (mlength < rlength &&\r\n(md->md_options & LNET_MD_TRUNCATE) == 0) {\r\nCNETERR("%s: Dropping REPLY from %s length %d for MD %#llx would overflow (%d)\n",\r\nlibcfs_nid2str(ni->ni_nid), libcfs_id2str(src),\r\nrlength, hdr->msg.reply.dst_wmd.wh_object_cookie,\r\nmlength);\r\nlnet_res_unlock(cpt);\r\nreturn ENOENT;\r\n}\r\nCDEBUG(D_NET, "%s: Reply from %s of length %d/%d into md %#llx\n",\r\nlibcfs_nid2str(ni->ni_nid), libcfs_id2str(src),\r\nmlength, rlength, hdr->msg.reply.dst_wmd.wh_object_cookie);\r\nlnet_msg_attach_md(msg, md, 0, mlength);\r\nif (mlength != 0)\r\nlnet_setpayloadbuffer(msg);\r\nlnet_res_unlock(cpt);\r\nlnet_build_msg_event(msg, LNET_EVENT_REPLY);\r\nlnet_ni_recv(ni, private, msg, 0, 0, mlength, rlength);\r\nreturn 0;\r\n}\r\nstatic int\r\nlnet_parse_ack(lnet_ni_t *ni, lnet_msg_t *msg)\r\n{\r\nlnet_hdr_t *hdr = &msg->msg_hdr;\r\nlnet_process_id_t src = {0};\r\nlnet_libmd_t *md;\r\nint cpt;\r\nsrc.nid = hdr->src_nid;\r\nsrc.pid = hdr->src_pid;\r\nhdr->msg.ack.match_bits = le64_to_cpu(hdr->msg.ack.match_bits);\r\nhdr->msg.ack.mlength = le32_to_cpu(hdr->msg.ack.mlength);\r\ncpt = lnet_cpt_of_cookie(hdr->msg.ack.dst_wmd.wh_object_cookie);\r\nlnet_res_lock(cpt);\r\nmd = lnet_wire_handle2md(&hdr->msg.ack.dst_wmd);\r\nif (md == NULL || md->md_threshold == 0 || md->md_me != NULL) {\r\nCDEBUG(D_NET,\r\n"%s: Dropping ACK from %s to %s MD %#llx.%#llx\n",\r\nlibcfs_nid2str(ni->ni_nid), libcfs_id2str(src),\r\n(md == NULL) ? "invalid" : "inactive",\r\nhdr->msg.ack.dst_wmd.wh_interface_cookie,\r\nhdr->msg.ack.dst_wmd.wh_object_cookie);\r\nif (md != NULL && md->md_me != NULL)\r\nCERROR("Source MD also attached to portal %d\n",\r\nmd->md_me->me_portal);\r\nlnet_res_unlock(cpt);\r\nreturn ENOENT;\r\n}\r\nCDEBUG(D_NET, "%s: ACK from %s into md %#llx\n",\r\nlibcfs_nid2str(ni->ni_nid), libcfs_id2str(src),\r\nhdr->msg.ack.dst_wmd.wh_object_cookie);\r\nlnet_msg_attach_md(msg, md, 0, 0);\r\nlnet_res_unlock(cpt);\r\nlnet_build_msg_event(msg, LNET_EVENT_ACK);\r\nlnet_ni_recv(ni, msg->msg_private, msg, 0, 0, 0, msg->msg_len);\r\nreturn 0;\r\n}\r\nstatic int\r\nlnet_parse_forward_locked(lnet_ni_t *ni, lnet_msg_t *msg)\r\n{\r\nint rc = 0;\r\nif (msg->msg_rxpeer->lp_rtrcredits <= 0 ||\r\nlnet_msg2bufpool(msg)->rbp_credits <= 0) {\r\nif (ni->ni_lnd->lnd_eager_recv == NULL) {\r\nmsg->msg_rx_ready_delay = 1;\r\n} else {\r\nlnet_net_unlock(msg->msg_rx_cpt);\r\nrc = lnet_ni_eager_recv(ni, msg);\r\nlnet_net_lock(msg->msg_rx_cpt);\r\n}\r\n}\r\nif (rc == 0)\r\nrc = lnet_post_routed_recv_locked(msg, 0);\r\nreturn rc;\r\n}\r\nchar *\r\nlnet_msgtyp2str(int type)\r\n{\r\nswitch (type) {\r\ncase LNET_MSG_ACK:\r\nreturn "ACK";\r\ncase LNET_MSG_PUT:\r\nreturn "PUT";\r\ncase LNET_MSG_GET:\r\nreturn "GET";\r\ncase LNET_MSG_REPLY:\r\nreturn "REPLY";\r\ncase LNET_MSG_HELLO:\r\nreturn "HELLO";\r\ndefault:\r\nreturn "<UNKNOWN>";\r\n}\r\n}\r\nvoid\r\nlnet_print_hdr(lnet_hdr_t *hdr)\r\n{\r\nlnet_process_id_t src = {0};\r\nlnet_process_id_t dst = {0};\r\nchar *type_str = lnet_msgtyp2str(hdr->type);\r\nsrc.nid = hdr->src_nid;\r\nsrc.pid = hdr->src_pid;\r\ndst.nid = hdr->dest_nid;\r\ndst.pid = hdr->dest_pid;\r\nCWARN("P3 Header at %p of type %s\n", hdr, type_str);\r\nCWARN(" From %s\n", libcfs_id2str(src));\r\nCWARN(" To %s\n", libcfs_id2str(dst));\r\nswitch (hdr->type) {\r\ndefault:\r\nbreak;\r\ncase LNET_MSG_PUT:\r\nCWARN(" Ptl index %d, ack md %#llx.%#llx, "\r\n"match bits %llu\n",\r\nhdr->msg.put.ptl_index,\r\nhdr->msg.put.ack_wmd.wh_interface_cookie,\r\nhdr->msg.put.ack_wmd.wh_object_cookie,\r\nhdr->msg.put.match_bits);\r\nCWARN(" Length %d, offset %d, hdr data %#llx\n",\r\nhdr->payload_length, hdr->msg.put.offset,\r\nhdr->msg.put.hdr_data);\r\nbreak;\r\ncase LNET_MSG_GET:\r\nCWARN(" Ptl index %d, return md %#llx.%#llx, "\r\n"match bits %llu\n", hdr->msg.get.ptl_index,\r\nhdr->msg.get.return_wmd.wh_interface_cookie,\r\nhdr->msg.get.return_wmd.wh_object_cookie,\r\nhdr->msg.get.match_bits);\r\nCWARN(" Length %d, src offset %d\n",\r\nhdr->msg.get.sink_length,\r\nhdr->msg.get.src_offset);\r\nbreak;\r\ncase LNET_MSG_ACK:\r\nCWARN(" dst md %#llx.%#llx, "\r\n"manipulated length %d\n",\r\nhdr->msg.ack.dst_wmd.wh_interface_cookie,\r\nhdr->msg.ack.dst_wmd.wh_object_cookie,\r\nhdr->msg.ack.mlength);\r\nbreak;\r\ncase LNET_MSG_REPLY:\r\nCWARN(" dst md %#llx.%#llx, "\r\n"length %d\n",\r\nhdr->msg.reply.dst_wmd.wh_interface_cookie,\r\nhdr->msg.reply.dst_wmd.wh_object_cookie,\r\nhdr->payload_length);\r\n}\r\n}\r\nint\r\nlnet_parse(lnet_ni_t *ni, lnet_hdr_t *hdr, lnet_nid_t from_nid,\r\nvoid *private, int rdma_req)\r\n{\r\nint rc = 0;\r\nint cpt;\r\nint for_me;\r\nstruct lnet_msg *msg;\r\nlnet_pid_t dest_pid;\r\nlnet_nid_t dest_nid;\r\nlnet_nid_t src_nid;\r\n__u32 payload_length;\r\n__u32 type;\r\nLASSERT(!in_interrupt());\r\ntype = le32_to_cpu(hdr->type);\r\nsrc_nid = le64_to_cpu(hdr->src_nid);\r\ndest_nid = le64_to_cpu(hdr->dest_nid);\r\ndest_pid = le32_to_cpu(hdr->dest_pid);\r\npayload_length = le32_to_cpu(hdr->payload_length);\r\nfor_me = (ni->ni_nid == dest_nid);\r\ncpt = lnet_cpt_of_nid(from_nid);\r\nswitch (type) {\r\ncase LNET_MSG_ACK:\r\ncase LNET_MSG_GET:\r\nif (payload_length > 0) {\r\nCERROR("%s, src %s: bad %s payload %d (0 expected)\n",\r\nlibcfs_nid2str(from_nid),\r\nlibcfs_nid2str(src_nid),\r\nlnet_msgtyp2str(type), payload_length);\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ncase LNET_MSG_PUT:\r\ncase LNET_MSG_REPLY:\r\nif (payload_length >\r\n(__u32)(for_me ? LNET_MAX_PAYLOAD : LNET_MTU)) {\r\nCERROR("%s, src %s: bad %s payload %d "\r\n"(%d max expected)\n",\r\nlibcfs_nid2str(from_nid),\r\nlibcfs_nid2str(src_nid),\r\nlnet_msgtyp2str(type),\r\npayload_length,\r\nfor_me ? LNET_MAX_PAYLOAD : LNET_MTU);\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ndefault:\r\nCERROR("%s, src %s: Bad message type 0x%x\n",\r\nlibcfs_nid2str(from_nid),\r\nlibcfs_nid2str(src_nid), type);\r\nreturn -EPROTO;\r\n}\r\nif (the_lnet.ln_routing &&\r\nni->ni_last_alive != get_seconds()) {\r\nlnet_ni_lock(ni);\r\nni->ni_last_alive = get_seconds();\r\nif (ni->ni_status != NULL &&\r\nni->ni_status->ns_status == LNET_NI_STATUS_DOWN)\r\nni->ni_status->ns_status = LNET_NI_STATUS_UP;\r\nlnet_ni_unlock(ni);\r\n}\r\nif (!for_me) {\r\nif (LNET_NIDNET(dest_nid) == LNET_NIDNET(ni->ni_nid)) {\r\nCERROR("%s, src %s: Bad dest nid %s "\r\n"(should have been sent direct)\n",\r\nlibcfs_nid2str(from_nid),\r\nlibcfs_nid2str(src_nid),\r\nlibcfs_nid2str(dest_nid));\r\nreturn -EPROTO;\r\n}\r\nif (lnet_islocalnid(dest_nid)) {\r\nCERROR("%s, src %s: Bad dest nid %s "\r\n"(it's my nid but on a different network)\n",\r\nlibcfs_nid2str(from_nid),\r\nlibcfs_nid2str(src_nid),\r\nlibcfs_nid2str(dest_nid));\r\nreturn -EPROTO;\r\n}\r\nif (rdma_req && type == LNET_MSG_GET) {\r\nCERROR("%s, src %s: Bad optimized GET for %s "\r\n"(final destination must be me)\n",\r\nlibcfs_nid2str(from_nid),\r\nlibcfs_nid2str(src_nid),\r\nlibcfs_nid2str(dest_nid));\r\nreturn -EPROTO;\r\n}\r\nif (!the_lnet.ln_routing) {\r\nCERROR("%s, src %s: Dropping message for %s "\r\n"(routing not enabled)\n",\r\nlibcfs_nid2str(from_nid),\r\nlibcfs_nid2str(src_nid),\r\nlibcfs_nid2str(dest_nid));\r\ngoto drop;\r\n}\r\n}\r\nif (!list_empty(&the_lnet.ln_test_peers) &&\r\nfail_peer(src_nid, 0)) {\r\nCERROR("%s, src %s: Dropping %s to simulate failure\n",\r\nlibcfs_nid2str(from_nid), libcfs_nid2str(src_nid),\r\nlnet_msgtyp2str(type));\r\ngoto drop;\r\n}\r\nmsg = lnet_msg_alloc();\r\nif (msg == NULL) {\r\nCERROR("%s, src %s: Dropping %s (out of memory)\n",\r\nlibcfs_nid2str(from_nid), libcfs_nid2str(src_nid),\r\nlnet_msgtyp2str(type));\r\ngoto drop;\r\n}\r\nmsg->msg_type = type;\r\nmsg->msg_private = private;\r\nmsg->msg_receiving = 1;\r\nmsg->msg_len = msg->msg_wanted = payload_length;\r\nmsg->msg_offset = 0;\r\nmsg->msg_hdr = *hdr;\r\nmsg->msg_from = from_nid;\r\nif (!for_me) {\r\nmsg->msg_target.pid = dest_pid;\r\nmsg->msg_target.nid = dest_nid;\r\nmsg->msg_routing = 1;\r\n} else {\r\nmsg->msg_hdr.type = type;\r\nmsg->msg_hdr.src_nid = src_nid;\r\nmsg->msg_hdr.src_pid = le32_to_cpu(msg->msg_hdr.src_pid);\r\nmsg->msg_hdr.dest_nid = dest_nid;\r\nmsg->msg_hdr.dest_pid = dest_pid;\r\nmsg->msg_hdr.payload_length = payload_length;\r\n}\r\nlnet_net_lock(cpt);\r\nrc = lnet_nid2peer_locked(&msg->msg_rxpeer, from_nid, cpt);\r\nif (rc != 0) {\r\nlnet_net_unlock(cpt);\r\nCERROR("%s, src %s: Dropping %s "\r\n"(error %d looking up sender)\n",\r\nlibcfs_nid2str(from_nid), libcfs_nid2str(src_nid),\r\nlnet_msgtyp2str(type), rc);\r\nlnet_msg_free(msg);\r\ngoto drop;\r\n}\r\nlnet_msg_commit(msg, cpt);\r\nif (!for_me) {\r\nrc = lnet_parse_forward_locked(ni, msg);\r\nlnet_net_unlock(cpt);\r\nif (rc < 0)\r\ngoto free_drop;\r\nif (rc == 0) {\r\nlnet_ni_recv(ni, msg->msg_private, msg, 0,\r\n0, payload_length, payload_length);\r\n}\r\nreturn 0;\r\n}\r\nlnet_net_unlock(cpt);\r\nswitch (type) {\r\ncase LNET_MSG_ACK:\r\nrc = lnet_parse_ack(ni, msg);\r\nbreak;\r\ncase LNET_MSG_PUT:\r\nrc = lnet_parse_put(ni, msg);\r\nbreak;\r\ncase LNET_MSG_GET:\r\nrc = lnet_parse_get(ni, msg, rdma_req);\r\nbreak;\r\ncase LNET_MSG_REPLY:\r\nrc = lnet_parse_reply(ni, msg);\r\nbreak;\r\ndefault:\r\nLASSERT(0);\r\nrc = -EPROTO;\r\ngoto free_drop;\r\n}\r\nif (rc == 0)\r\nreturn 0;\r\nLASSERT(rc == ENOENT);\r\nfree_drop:\r\nLASSERT(msg->msg_md == NULL);\r\nlnet_finalize(ni, msg, rc);\r\ndrop:\r\nlnet_drop_message(ni, cpt, private, payload_length);\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_drop_delayed_msg_list(struct list_head *head, char *reason)\r\n{\r\nwhile (!list_empty(head)) {\r\nlnet_process_id_t id = {0};\r\nlnet_msg_t *msg;\r\nmsg = list_entry(head->next, lnet_msg_t, msg_list);\r\nlist_del(&msg->msg_list);\r\nid.nid = msg->msg_hdr.src_nid;\r\nid.pid = msg->msg_hdr.src_pid;\r\nLASSERT(msg->msg_md == NULL);\r\nLASSERT(msg->msg_rx_delayed);\r\nLASSERT(msg->msg_rxpeer != NULL);\r\nLASSERT(msg->msg_hdr.type == LNET_MSG_PUT);\r\nCWARN("Dropping delayed PUT from %s portal %d match %llu offset %d length %d: %s\n",\r\nlibcfs_id2str(id),\r\nmsg->msg_hdr.msg.put.ptl_index,\r\nmsg->msg_hdr.msg.put.match_bits,\r\nmsg->msg_hdr.msg.put.offset,\r\nmsg->msg_hdr.payload_length, reason);\r\nlnet_drop_message(msg->msg_rxpeer->lp_ni,\r\nmsg->msg_rxpeer->lp_cpt,\r\nmsg->msg_private, msg->msg_len);\r\nlnet_finalize(msg->msg_rxpeer->lp_ni, msg, -ENOENT);\r\n}\r\n}\r\nvoid\r\nlnet_recv_delayed_msg_list(struct list_head *head)\r\n{\r\nwhile (!list_empty(head)) {\r\nlnet_msg_t *msg;\r\nlnet_process_id_t id;\r\nmsg = list_entry(head->next, lnet_msg_t, msg_list);\r\nlist_del(&msg->msg_list);\r\nid.nid = msg->msg_hdr.src_nid;\r\nid.pid = msg->msg_hdr.src_pid;\r\nLASSERT(msg->msg_rx_delayed);\r\nLASSERT(msg->msg_md != NULL);\r\nLASSERT(msg->msg_rxpeer != NULL);\r\nLASSERT(msg->msg_hdr.type == LNET_MSG_PUT);\r\nCDEBUG(D_NET, "Resuming delayed PUT from %s portal %d "\r\n"match %llu offset %d length %d.\n",\r\nlibcfs_id2str(id), msg->msg_hdr.msg.put.ptl_index,\r\nmsg->msg_hdr.msg.put.match_bits,\r\nmsg->msg_hdr.msg.put.offset,\r\nmsg->msg_hdr.payload_length);\r\nlnet_recv_put(msg->msg_rxpeer->lp_ni, msg);\r\n}\r\n}\r\nint\r\nLNetPut(lnet_nid_t self, lnet_handle_md_t mdh, lnet_ack_req_t ack,\r\nlnet_process_id_t target, unsigned int portal,\r\n__u64 match_bits, unsigned int offset,\r\n__u64 hdr_data)\r\n{\r\nstruct lnet_msg *msg;\r\nstruct lnet_libmd *md;\r\nint cpt;\r\nint rc;\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount > 0);\r\nif (!list_empty(&the_lnet.ln_test_peers) &&\r\nfail_peer(target.nid, 1)) {\r\nCERROR("Dropping PUT to %s: simulated failure\n",\r\nlibcfs_id2str(target));\r\nreturn -EIO;\r\n}\r\nmsg = lnet_msg_alloc();\r\nif (msg == NULL) {\r\nCERROR("Dropping PUT to %s: ENOMEM on lnet_msg_t\n",\r\nlibcfs_id2str(target));\r\nreturn -ENOMEM;\r\n}\r\nmsg->msg_vmflush = !!memory_pressure_get();\r\ncpt = lnet_cpt_of_cookie(mdh.cookie);\r\nlnet_res_lock(cpt);\r\nmd = lnet_handle2md(&mdh);\r\nif (md == NULL || md->md_threshold == 0 || md->md_me != NULL) {\r\nCERROR("Dropping PUT (%llu:%d:%s): MD (%d) invalid\n",\r\nmatch_bits, portal, libcfs_id2str(target),\r\nmd == NULL ? -1 : md->md_threshold);\r\nif (md != NULL && md->md_me != NULL)\r\nCERROR("Source MD also attached to portal %d\n",\r\nmd->md_me->me_portal);\r\nlnet_res_unlock(cpt);\r\nlnet_msg_free(msg);\r\nreturn -ENOENT;\r\n}\r\nCDEBUG(D_NET, "LNetPut -> %s\n", libcfs_id2str(target));\r\nlnet_msg_attach_md(msg, md, 0, 0);\r\nlnet_prep_send(msg, LNET_MSG_PUT, target, 0, md->md_length);\r\nmsg->msg_hdr.msg.put.match_bits = cpu_to_le64(match_bits);\r\nmsg->msg_hdr.msg.put.ptl_index = cpu_to_le32(portal);\r\nmsg->msg_hdr.msg.put.offset = cpu_to_le32(offset);\r\nmsg->msg_hdr.msg.put.hdr_data = hdr_data;\r\nif (ack == LNET_ACK_REQ) {\r\nmsg->msg_hdr.msg.put.ack_wmd.wh_interface_cookie =\r\nthe_lnet.ln_interface_cookie;\r\nmsg->msg_hdr.msg.put.ack_wmd.wh_object_cookie =\r\nmd->md_lh.lh_cookie;\r\n} else {\r\nmsg->msg_hdr.msg.put.ack_wmd.wh_interface_cookie =\r\nLNET_WIRE_HANDLE_COOKIE_NONE;\r\nmsg->msg_hdr.msg.put.ack_wmd.wh_object_cookie =\r\nLNET_WIRE_HANDLE_COOKIE_NONE;\r\n}\r\nlnet_res_unlock(cpt);\r\nlnet_build_msg_event(msg, LNET_EVENT_SEND);\r\nrc = lnet_send(self, msg, LNET_NID_ANY);\r\nif (rc != 0) {\r\nCNETERR("Error sending PUT to %s: %d\n",\r\nlibcfs_id2str(target), rc);\r\nlnet_finalize(NULL, msg, rc);\r\n}\r\nreturn 0;\r\n}\r\nlnet_msg_t *\r\nlnet_create_reply_msg(lnet_ni_t *ni, lnet_msg_t *getmsg)\r\n{\r\nstruct lnet_msg *msg = lnet_msg_alloc();\r\nstruct lnet_libmd *getmd = getmsg->msg_md;\r\nlnet_process_id_t peer_id = getmsg->msg_target;\r\nint cpt;\r\nLASSERT(!getmsg->msg_target_is_router);\r\nLASSERT(!getmsg->msg_routing);\r\ncpt = lnet_cpt_of_cookie(getmd->md_lh.lh_cookie);\r\nlnet_res_lock(cpt);\r\nLASSERT(getmd->md_refcount > 0);\r\nif (msg == NULL) {\r\nCERROR("%s: Dropping REPLY from %s: can't allocate msg\n",\r\nlibcfs_nid2str(ni->ni_nid), libcfs_id2str(peer_id));\r\ngoto drop;\r\n}\r\nif (getmd->md_threshold == 0) {\r\nCERROR("%s: Dropping REPLY from %s for inactive MD %p\n",\r\nlibcfs_nid2str(ni->ni_nid), libcfs_id2str(peer_id),\r\ngetmd);\r\nlnet_res_unlock(cpt);\r\ngoto drop;\r\n}\r\nLASSERT(getmd->md_offset == 0);\r\nCDEBUG(D_NET, "%s: Reply from %s md %p\n",\r\nlibcfs_nid2str(ni->ni_nid), libcfs_id2str(peer_id), getmd);\r\nmsg->msg_from = peer_id.nid;\r\nmsg->msg_type = LNET_MSG_GET;\r\nmsg->msg_hdr.src_nid = peer_id.nid;\r\nmsg->msg_hdr.payload_length = getmd->md_length;\r\nmsg->msg_receiving = 1;\r\nlnet_msg_attach_md(msg, getmd, getmd->md_offset, getmd->md_length);\r\nlnet_res_unlock(cpt);\r\ncpt = lnet_cpt_of_nid(peer_id.nid);\r\nlnet_net_lock(cpt);\r\nlnet_msg_commit(msg, cpt);\r\nlnet_net_unlock(cpt);\r\nlnet_build_msg_event(msg, LNET_EVENT_REPLY);\r\nreturn msg;\r\ndrop:\r\ncpt = lnet_cpt_of_nid(peer_id.nid);\r\nlnet_net_lock(cpt);\r\nthe_lnet.ln_counters[cpt]->drop_count++;\r\nthe_lnet.ln_counters[cpt]->drop_length += getmd->md_length;\r\nlnet_net_unlock(cpt);\r\nif (msg != NULL)\r\nlnet_msg_free(msg);\r\nreturn NULL;\r\n}\r\nvoid\r\nlnet_set_reply_msg_len(lnet_ni_t *ni, lnet_msg_t *reply, unsigned int len)\r\n{\r\nLASSERT(reply != NULL);\r\nLASSERT(reply->msg_type == LNET_MSG_GET);\r\nLASSERT(reply->msg_ev.type == LNET_EVENT_REPLY);\r\nLASSERT(len <= reply->msg_ev.mlength);\r\nreply->msg_ev.mlength = len;\r\n}\r\nint\r\nLNetGet(lnet_nid_t self, lnet_handle_md_t mdh,\r\nlnet_process_id_t target, unsigned int portal,\r\n__u64 match_bits, unsigned int offset)\r\n{\r\nstruct lnet_msg *msg;\r\nstruct lnet_libmd *md;\r\nint cpt;\r\nint rc;\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount > 0);\r\nif (!list_empty(&the_lnet.ln_test_peers) &&\r\nfail_peer(target.nid, 1)) {\r\nCERROR("Dropping GET to %s: simulated failure\n",\r\nlibcfs_id2str(target));\r\nreturn -EIO;\r\n}\r\nmsg = lnet_msg_alloc();\r\nif (msg == NULL) {\r\nCERROR("Dropping GET to %s: ENOMEM on lnet_msg_t\n",\r\nlibcfs_id2str(target));\r\nreturn -ENOMEM;\r\n}\r\ncpt = lnet_cpt_of_cookie(mdh.cookie);\r\nlnet_res_lock(cpt);\r\nmd = lnet_handle2md(&mdh);\r\nif (md == NULL || md->md_threshold == 0 || md->md_me != NULL) {\r\nCERROR("Dropping GET (%llu:%d:%s): MD (%d) invalid\n",\r\nmatch_bits, portal, libcfs_id2str(target),\r\nmd == NULL ? -1 : md->md_threshold);\r\nif (md != NULL && md->md_me != NULL)\r\nCERROR("REPLY MD also attached to portal %d\n",\r\nmd->md_me->me_portal);\r\nlnet_res_unlock(cpt);\r\nlnet_msg_free(msg);\r\nreturn -ENOENT;\r\n}\r\nCDEBUG(D_NET, "LNetGet -> %s\n", libcfs_id2str(target));\r\nlnet_msg_attach_md(msg, md, 0, 0);\r\nlnet_prep_send(msg, LNET_MSG_GET, target, 0, 0);\r\nmsg->msg_hdr.msg.get.match_bits = cpu_to_le64(match_bits);\r\nmsg->msg_hdr.msg.get.ptl_index = cpu_to_le32(portal);\r\nmsg->msg_hdr.msg.get.src_offset = cpu_to_le32(offset);\r\nmsg->msg_hdr.msg.get.sink_length = cpu_to_le32(md->md_length);\r\nmsg->msg_hdr.msg.get.return_wmd.wh_interface_cookie =\r\nthe_lnet.ln_interface_cookie;\r\nmsg->msg_hdr.msg.get.return_wmd.wh_object_cookie =\r\nmd->md_lh.lh_cookie;\r\nlnet_res_unlock(cpt);\r\nlnet_build_msg_event(msg, LNET_EVENT_SEND);\r\nrc = lnet_send(self, msg, LNET_NID_ANY);\r\nif (rc < 0) {\r\nCNETERR("Error sending GET to %s: %d\n",\r\nlibcfs_id2str(target), rc);\r\nlnet_finalize(NULL, msg, rc);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nLNetDist(lnet_nid_t dstnid, lnet_nid_t *srcnidp, __u32 *orderp)\r\n{\r\nstruct list_head *e;\r\nstruct lnet_ni *ni;\r\nlnet_remotenet_t *rnet;\r\n__u32 dstnet = LNET_NIDNET(dstnid);\r\nint hops;\r\nint cpt;\r\n__u32 order = 2;\r\nstruct list_head *rn_list;\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount > 0);\r\ncpt = lnet_net_lock_current();\r\nlist_for_each(e, &the_lnet.ln_nis) {\r\nni = list_entry(e, lnet_ni_t, ni_list);\r\nif (ni->ni_nid == dstnid) {\r\nif (srcnidp != NULL)\r\n*srcnidp = dstnid;\r\nif (orderp != NULL) {\r\nif (LNET_NETTYP(LNET_NIDNET(dstnid)) == LOLND)\r\n*orderp = 0;\r\nelse\r\n*orderp = 1;\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn local_nid_dist_zero ? 0 : 1;\r\n}\r\nif (LNET_NIDNET(ni->ni_nid) == dstnet) {\r\nif (srcnidp != NULL)\r\n*srcnidp = ni->ni_nid;\r\nif (orderp != NULL)\r\n*orderp = order;\r\nlnet_net_unlock(cpt);\r\nreturn 1;\r\n}\r\norder++;\r\n}\r\nrn_list = lnet_net2rnethash(dstnet);\r\nlist_for_each(e, rn_list) {\r\nrnet = list_entry(e, lnet_remotenet_t, lrn_list);\r\nif (rnet->lrn_net == dstnet) {\r\nlnet_route_t *route;\r\nlnet_route_t *shortest = NULL;\r\nLASSERT(!list_empty(&rnet->lrn_routes));\r\nlist_for_each_entry(route, &rnet->lrn_routes,\r\nlr_list) {\r\nif (shortest == NULL ||\r\nroute->lr_hops < shortest->lr_hops)\r\nshortest = route;\r\n}\r\nLASSERT(shortest != NULL);\r\nhops = shortest->lr_hops;\r\nif (srcnidp != NULL)\r\n*srcnidp = shortest->lr_gateway->lp_ni->ni_nid;\r\nif (orderp != NULL)\r\n*orderp = order;\r\nlnet_net_unlock(cpt);\r\nreturn hops + 1;\r\n}\r\norder++;\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn -EHOSTUNREACH;\r\n}\r\nint\r\nLNetSetAsync(lnet_process_id_t id, int nasync)\r\n{\r\nreturn 0;\r\n}
