static int get_div(struct tegra_clk_frac_div *divider, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\ns64 divider_ux1 = parent_rate;\r\nu8 flags = divider->flags;\r\nint mul;\r\nif (!rate)\r\nreturn 0;\r\nmul = get_mul(divider);\r\nif (!(flags & TEGRA_DIVIDER_INT))\r\ndivider_ux1 *= mul;\r\nif (flags & TEGRA_DIVIDER_ROUND_UP)\r\ndivider_ux1 += rate - 1;\r\ndo_div(divider_ux1, rate);\r\nif (flags & TEGRA_DIVIDER_INT)\r\ndivider_ux1 *= mul;\r\ndivider_ux1 -= mul;\r\nif (divider_ux1 < 0)\r\nreturn 0;\r\nif (divider_ux1 > get_max_div(divider))\r\nreturn get_max_div(divider);\r\nreturn divider_ux1;\r\n}\r\nstatic unsigned long clk_frac_div_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct tegra_clk_frac_div *divider = to_clk_frac_div(hw);\r\nu32 reg;\r\nint div, mul;\r\nu64 rate = parent_rate;\r\nreg = readl_relaxed(divider->reg) >> divider->shift;\r\ndiv = reg & div_mask(divider);\r\nmul = get_mul(divider);\r\ndiv += mul;\r\nrate *= mul;\r\nrate += div - 1;\r\ndo_div(rate, div);\r\nreturn rate;\r\n}\r\nstatic long clk_frac_div_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct tegra_clk_frac_div *divider = to_clk_frac_div(hw);\r\nint div, mul;\r\nunsigned long output_rate = *prate;\r\nif (!rate)\r\nreturn output_rate;\r\ndiv = get_div(divider, rate, output_rate);\r\nif (div < 0)\r\nreturn *prate;\r\nmul = get_mul(divider);\r\nreturn DIV_ROUND_UP(output_rate * mul, div + mul);\r\n}\r\nstatic int clk_frac_div_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct tegra_clk_frac_div *divider = to_clk_frac_div(hw);\r\nint div;\r\nunsigned long flags = 0;\r\nu32 val;\r\ndiv = get_div(divider, rate, parent_rate);\r\nif (div < 0)\r\nreturn div;\r\nif (divider->lock)\r\nspin_lock_irqsave(divider->lock, flags);\r\nval = readl_relaxed(divider->reg);\r\nval &= ~(div_mask(divider) << divider->shift);\r\nval |= div << divider->shift;\r\nif (divider->flags & TEGRA_DIVIDER_UART) {\r\nif (div)\r\nval |= PERIPH_CLK_UART_DIV_ENB;\r\nelse\r\nval &= ~PERIPH_CLK_UART_DIV_ENB;\r\n}\r\nif (divider->flags & TEGRA_DIVIDER_FIXED)\r\nval |= pll_out_override(divider);\r\nwritel_relaxed(val, divider->reg);\r\nif (divider->lock)\r\nspin_unlock_irqrestore(divider->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *tegra_clk_register_divider(const char *name,\r\nconst char *parent_name, void __iomem *reg,\r\nunsigned long flags, u8 clk_divider_flags, u8 shift, u8 width,\r\nu8 frac_width, spinlock_t *lock)\r\n{\r\nstruct tegra_clk_frac_div *divider;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\ndivider = kzalloc(sizeof(*divider), GFP_KERNEL);\r\nif (!divider) {\r\npr_err("%s: could not allocate fractional divider clk\n",\r\n__func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &tegra_clk_frac_div_ops;\r\ninit.flags = flags;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\ndivider->reg = reg;\r\ndivider->shift = shift;\r\ndivider->width = width;\r\ndivider->frac_width = frac_width;\r\ndivider->lock = lock;\r\ndivider->flags = clk_divider_flags;\r\ndivider->hw.init = &init;\r\nclk = clk_register(NULL, &divider->hw);\r\nif (IS_ERR(clk))\r\nkfree(divider);\r\nreturn clk;\r\n}
