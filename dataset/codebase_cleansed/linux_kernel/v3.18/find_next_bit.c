unsigned long find_next_bit(const unsigned long *addr, unsigned long size,\r\nunsigned long offset)\r\n{\r\nconst unsigned long *p = addr + BITOP_WORD(offset);\r\nunsigned long result = offset & ~(BITS_PER_LONG-1);\r\nunsigned long tmp;\r\nif (offset >= size)\r\nreturn size;\r\nsize -= result;\r\noffset %= BITS_PER_LONG;\r\nif (offset) {\r\ntmp = *(p++);\r\ntmp &= (~0UL << offset);\r\nif (size < BITS_PER_LONG)\r\ngoto found_first;\r\nif (tmp)\r\ngoto found_middle;\r\nsize -= BITS_PER_LONG;\r\nresult += BITS_PER_LONG;\r\n}\r\nwhile (size & ~(BITS_PER_LONG-1)) {\r\nif ((tmp = *(p++)))\r\ngoto found_middle;\r\nresult += BITS_PER_LONG;\r\nsize -= BITS_PER_LONG;\r\n}\r\nif (!size)\r\nreturn result;\r\ntmp = *p;\r\nfound_first:\r\ntmp &= (~0UL >> (BITS_PER_LONG - size));\r\nif (tmp == 0UL)\r\nreturn result + size;\r\nfound_middle:\r\nreturn result + __ffs(tmp);\r\n}\r\nunsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\r\nunsigned long offset)\r\n{\r\nconst unsigned long *p = addr + BITOP_WORD(offset);\r\nunsigned long result = offset & ~(BITS_PER_LONG-1);\r\nunsigned long tmp;\r\nif (offset >= size)\r\nreturn size;\r\nsize -= result;\r\noffset %= BITS_PER_LONG;\r\nif (offset) {\r\ntmp = *(p++);\r\ntmp |= ~0UL >> (BITS_PER_LONG - offset);\r\nif (size < BITS_PER_LONG)\r\ngoto found_first;\r\nif (~tmp)\r\ngoto found_middle;\r\nsize -= BITS_PER_LONG;\r\nresult += BITS_PER_LONG;\r\n}\r\nwhile (size & ~(BITS_PER_LONG-1)) {\r\nif (~(tmp = *(p++)))\r\ngoto found_middle;\r\nresult += BITS_PER_LONG;\r\nsize -= BITS_PER_LONG;\r\n}\r\nif (!size)\r\nreturn result;\r\ntmp = *p;\r\nfound_first:\r\ntmp |= ~0UL << size;\r\nif (tmp == ~0UL)\r\nreturn result + size;\r\nfound_middle:\r\nreturn result + ffz(tmp);\r\n}\r\nunsigned long find_first_bit(const unsigned long *addr, unsigned long size)\r\n{\r\nconst unsigned long *p = addr;\r\nunsigned long result = 0;\r\nunsigned long tmp;\r\nwhile (size & ~(BITS_PER_LONG-1)) {\r\nif ((tmp = *(p++)))\r\ngoto found;\r\nresult += BITS_PER_LONG;\r\nsize -= BITS_PER_LONG;\r\n}\r\nif (!size)\r\nreturn result;\r\ntmp = (*p) & (~0UL >> (BITS_PER_LONG - size));\r\nif (tmp == 0UL)\r\nreturn result + size;\r\nfound:\r\nreturn result + __ffs(tmp);\r\n}\r\nunsigned long find_first_zero_bit(const unsigned long *addr, unsigned long size)\r\n{\r\nconst unsigned long *p = addr;\r\nunsigned long result = 0;\r\nunsigned long tmp;\r\nwhile (size & ~(BITS_PER_LONG-1)) {\r\nif (~(tmp = *(p++)))\r\ngoto found;\r\nresult += BITS_PER_LONG;\r\nsize -= BITS_PER_LONG;\r\n}\r\nif (!size)\r\nreturn result;\r\ntmp = (*p) | (~0UL << size);\r\nif (tmp == ~0UL)\r\nreturn result + size;\r\nfound:\r\nreturn result + ffz(tmp);\r\n}\r\nstatic inline unsigned long ext2_swabp(const unsigned long * x)\r\n{\r\n#if BITS_PER_LONG == 64\r\nreturn (unsigned long) __swab64p((u64 *) x);\r\n#elif BITS_PER_LONG == 32\r\nreturn (unsigned long) __swab32p((u32 *) x);\r\n#else\r\n#error BITS_PER_LONG not defined\r\n#endif\r\n}\r\nstatic inline unsigned long ext2_swab(const unsigned long y)\r\n{\r\n#if BITS_PER_LONG == 64\r\nreturn (unsigned long) __swab64((u64) y);\r\n#elif BITS_PER_LONG == 32\r\nreturn (unsigned long) __swab32((u32) y);\r\n#else\r\n#error BITS_PER_LONG not defined\r\n#endif\r\n}\r\nunsigned long find_next_zero_bit_le(const void *addr, unsigned\r\nlong size, unsigned long offset)\r\n{\r\nconst unsigned long *p = addr;\r\nunsigned long result = offset & ~(BITS_PER_LONG - 1);\r\nunsigned long tmp;\r\nif (offset >= size)\r\nreturn size;\r\np += BITOP_WORD(offset);\r\nsize -= result;\r\noffset &= (BITS_PER_LONG - 1UL);\r\nif (offset) {\r\ntmp = ext2_swabp(p++);\r\ntmp |= (~0UL >> (BITS_PER_LONG - offset));\r\nif (size < BITS_PER_LONG)\r\ngoto found_first;\r\nif (~tmp)\r\ngoto found_middle;\r\nsize -= BITS_PER_LONG;\r\nresult += BITS_PER_LONG;\r\n}\r\nwhile (size & ~(BITS_PER_LONG - 1)) {\r\nif (~(tmp = *(p++)))\r\ngoto found_middle_swap;\r\nresult += BITS_PER_LONG;\r\nsize -= BITS_PER_LONG;\r\n}\r\nif (!size)\r\nreturn result;\r\ntmp = ext2_swabp(p);\r\nfound_first:\r\ntmp |= ~0UL << size;\r\nif (tmp == ~0UL)\r\nreturn result + size;\r\nfound_middle:\r\nreturn result + ffz(tmp);\r\nfound_middle_swap:\r\nreturn result + ffz(ext2_swab(tmp));\r\n}\r\nunsigned long find_next_bit_le(const void *addr, unsigned\r\nlong size, unsigned long offset)\r\n{\r\nconst unsigned long *p = addr;\r\nunsigned long result = offset & ~(BITS_PER_LONG - 1);\r\nunsigned long tmp;\r\nif (offset >= size)\r\nreturn size;\r\np += BITOP_WORD(offset);\r\nsize -= result;\r\noffset &= (BITS_PER_LONG - 1UL);\r\nif (offset) {\r\ntmp = ext2_swabp(p++);\r\ntmp &= (~0UL << offset);\r\nif (size < BITS_PER_LONG)\r\ngoto found_first;\r\nif (tmp)\r\ngoto found_middle;\r\nsize -= BITS_PER_LONG;\r\nresult += BITS_PER_LONG;\r\n}\r\nwhile (size & ~(BITS_PER_LONG - 1)) {\r\ntmp = *(p++);\r\nif (tmp)\r\ngoto found_middle_swap;\r\nresult += BITS_PER_LONG;\r\nsize -= BITS_PER_LONG;\r\n}\r\nif (!size)\r\nreturn result;\r\ntmp = ext2_swabp(p);\r\nfound_first:\r\ntmp &= (~0UL >> (BITS_PER_LONG - size));\r\nif (tmp == 0UL)\r\nreturn result + size;\r\nfound_middle:\r\nreturn result + __ffs(tmp);\r\nfound_middle_swap:\r\nreturn result + __ffs(ext2_swab(tmp));\r\n}
