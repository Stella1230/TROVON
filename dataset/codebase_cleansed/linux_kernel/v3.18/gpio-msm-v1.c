static void msm_gpio_writel(struct msm_gpio_chip *chip, u32 val,\r\nenum msm_gpio_reg reg)\r\n{\r\nwritel(val, chip->base + chip->regs[reg]);\r\n}\r\nstatic u32 msm_gpio_readl(struct msm_gpio_chip *chip, enum msm_gpio_reg reg)\r\n{\r\nreturn readl(chip->base + chip->regs[reg]);\r\n}\r\nstatic int msm_gpio_write(struct msm_gpio_chip *msm_chip,\r\nunsigned offset, unsigned on)\r\n{\r\nunsigned mask = BIT(offset);\r\nunsigned val;\r\nval = msm_gpio_readl(msm_chip, MSM_GPIO_OUT);\r\nif (on)\r\nmsm_gpio_writel(msm_chip, val | mask, MSM_GPIO_OUT);\r\nelse\r\nmsm_gpio_writel(msm_chip, val & ~mask, MSM_GPIO_OUT);\r\nreturn 0;\r\n}\r\nstatic void msm_gpio_update_both_edge_detect(struct msm_gpio_chip *msm_chip)\r\n{\r\nint loop_limit = 100;\r\nunsigned pol, val, val2, intstat;\r\ndo {\r\nval = msm_gpio_readl(msm_chip, MSM_GPIO_IN);\r\npol = msm_gpio_readl(msm_chip, MSM_GPIO_INT_POS);\r\npol = (pol & ~msm_chip->both_edge_detect) |\r\n(~val & msm_chip->both_edge_detect);\r\nmsm_gpio_writel(msm_chip, pol, MSM_GPIO_INT_POS);\r\nintstat = msm_gpio_readl(msm_chip, MSM_GPIO_INT_STATUS);\r\nval2 = msm_gpio_readl(msm_chip, MSM_GPIO_IN);\r\nif (((val ^ val2) & msm_chip->both_edge_detect & ~intstat) == 0)\r\nreturn;\r\n} while (loop_limit-- > 0);\r\nprintk(KERN_ERR "msm_gpio_update_both_edge_detect, "\r\n"failed to reach stable state %x != %x\n", val, val2);\r\n}\r\nstatic int msm_gpio_clear_detect_status(struct msm_gpio_chip *msm_chip,\r\nunsigned offset)\r\n{\r\nunsigned bit = BIT(offset);\r\n#if MSM_GPIO_BROKEN_INT_CLEAR\r\nmsm_chip->int_status_copy |=\r\nmsm_gpio_readl(msm_chip, MSM_GPIO_INT_STATUS);\r\nmsm_chip->int_status_copy &= ~bit;\r\n#endif\r\nmsm_gpio_writel(msm_chip, bit, MSM_GPIO_INT_CLEAR);\r\nmsm_gpio_update_both_edge_detect(msm_chip);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct msm_gpio_chip *msm_chip;\r\nunsigned long irq_flags;\r\nu32 val;\r\nmsm_chip = container_of(chip, struct msm_gpio_chip, chip);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nval = msm_gpio_readl(msm_chip, MSM_GPIO_OE) & ~BIT(offset);\r\nmsm_gpio_writel(msm_chip, val, MSM_GPIO_OE);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nmsm_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct msm_gpio_chip *msm_chip;\r\nunsigned long irq_flags;\r\nu32 val;\r\nmsm_chip = container_of(chip, struct msm_gpio_chip, chip);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nmsm_gpio_write(msm_chip, offset, value);\r\nval = msm_gpio_readl(msm_chip, MSM_GPIO_OE) | BIT(offset);\r\nmsm_gpio_writel(msm_chip, val, MSM_GPIO_OE);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct msm_gpio_chip *msm_chip;\r\nmsm_chip = container_of(chip, struct msm_gpio_chip, chip);\r\nreturn (msm_gpio_readl(msm_chip, MSM_GPIO_IN) & (1U << offset)) ? 1 : 0;\r\n}\r\nstatic void msm_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct msm_gpio_chip *msm_chip;\r\nunsigned long irq_flags;\r\nmsm_chip = container_of(chip, struct msm_gpio_chip, chip);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nmsm_gpio_write(msm_chip, offset, value);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\n}\r\nstatic int msm_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn MSM_GPIO_TO_INT(chip->base + offset);\r\n}\r\nstatic int msm_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn msm_gpiomux_get(chip->base + offset);\r\n}\r\nstatic void msm_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nmsm_gpiomux_put(chip->base + offset);\r\n}\r\nstatic void msm_gpio_irq_ack(struct irq_data *d)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nmsm_gpio_clear_detect_status(msm_chip,\r\nd->irq - gpio_to_irq(msm_chip->chip.base));\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\n}\r\nstatic void msm_gpio_irq_mask(struct irq_data *d)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nunsigned offset = d->irq - gpio_to_irq(msm_chip->chip.base);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nif (!(msm_gpio_readl(msm_chip, MSM_GPIO_INT_EDGE) & BIT(offset)))\r\nmsm_gpio_clear_detect_status(msm_chip, offset);\r\nmsm_chip->int_enable[0] &= ~BIT(offset);\r\nmsm_gpio_writel(msm_chip, msm_chip->int_enable[0], MSM_GPIO_INT_EN);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\n}\r\nstatic void msm_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nunsigned offset = d->irq - gpio_to_irq(msm_chip->chip.base);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nif (!(msm_gpio_readl(msm_chip, MSM_GPIO_INT_EDGE) & BIT(offset)))\r\nmsm_gpio_clear_detect_status(msm_chip, offset);\r\nmsm_chip->int_enable[0] |= BIT(offset);\r\nmsm_gpio_writel(msm_chip, msm_chip->int_enable[0], MSM_GPIO_INT_EN);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\n}\r\nstatic int msm_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nunsigned offset = d->irq - gpio_to_irq(msm_chip->chip.base);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nif (on)\r\nmsm_chip->int_enable[1] |= BIT(offset);\r\nelse\r\nmsm_chip->int_enable[1] &= ~BIT(offset);\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nunsigned long irq_flags;\r\nstruct msm_gpio_chip *msm_chip = irq_data_get_irq_chip_data(d);\r\nunsigned offset = d->irq - gpio_to_irq(msm_chip->chip.base);\r\nunsigned val, mask = BIT(offset);\r\nspin_lock_irqsave(&msm_chip->lock, irq_flags);\r\nval = msm_gpio_readl(msm_chip, MSM_GPIO_INT_EDGE);\r\nif (flow_type & IRQ_TYPE_EDGE_BOTH) {\r\nmsm_gpio_writel(msm_chip, val | mask, MSM_GPIO_INT_EDGE);\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\n} else {\r\nmsm_gpio_writel(msm_chip, val & ~mask, MSM_GPIO_INT_EDGE);\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\n}\r\nif ((flow_type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\nmsm_chip->both_edge_detect |= mask;\r\nmsm_gpio_update_both_edge_detect(msm_chip);\r\n} else {\r\nmsm_chip->both_edge_detect &= ~mask;\r\nval = msm_gpio_readl(msm_chip, MSM_GPIO_INT_POS);\r\nif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_HIGH))\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\nmsm_gpio_writel(msm_chip, val, MSM_GPIO_INT_POS);\r\n}\r\nspin_unlock_irqrestore(&msm_chip->lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic void msm_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nint i, j, mask;\r\nunsigned val;\r\nfor (i = 0; i < msm_gpio_count; i++) {\r\nstruct msm_gpio_chip *msm_chip = &msm_gpio_chips[i];\r\nval = msm_gpio_readl(msm_chip, MSM_GPIO_INT_STATUS);\r\nval &= msm_chip->int_enable[0];\r\nwhile (val) {\r\nmask = val & -val;\r\nj = fls(mask) - 1;\r\nval &= ~mask;\r\ngeneric_handle_irq(FIRST_GPIO_IRQ +\r\nmsm_chip->chip.base + j);\r\n}\r\n}\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\n}\r\nstatic int gpio_msm_v1_probe(struct platform_device *pdev)\r\n{\r\nint i, j = 0;\r\nconst struct platform_device_id *dev_id = platform_get_device_id(pdev);\r\nstruct msm_gpio_initdata *data;\r\nint irq1, irq2;\r\nstruct resource *res;\r\nvoid __iomem *base1, __iomem *base2;\r\ndata = (struct msm_gpio_initdata *)dev_id->driver_data;\r\nmsm_gpio_chips = data->chips;\r\nmsm_gpio_count = data->count;\r\nirq1 = platform_get_irq(pdev, 0);\r\nif (irq1 < 0)\r\nreturn irq1;\r\nirq2 = platform_get_irq(pdev, 1);\r\nif (irq2 < 0)\r\nreturn irq2;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase1 = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base1))\r\nreturn PTR_ERR(base1);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nbase2 = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base2))\r\nreturn PTR_ERR(base2);\r\nfor (i = FIRST_GPIO_IRQ; i < FIRST_GPIO_IRQ + NR_GPIO_IRQS; i++) {\r\nif (i - FIRST_GPIO_IRQ >=\r\nmsm_gpio_chips[j].chip.base +\r\nmsm_gpio_chips[j].chip.ngpio)\r\nj++;\r\nirq_set_chip_data(i, &msm_gpio_chips[j]);\r\nirq_set_chip_and_handler(i, &msm_gpio_irq_chip,\r\nhandle_edge_irq);\r\nset_irq_flags(i, IRQF_VALID);\r\n}\r\nfor (i = 0; i < msm_gpio_count; i++) {\r\nif (i == 1)\r\nmsm_gpio_chips[i].base = base2;\r\nelse\r\nmsm_gpio_chips[i].base = base1;\r\nspin_lock_init(&msm_gpio_chips[i].lock);\r\nmsm_gpio_writel(&msm_gpio_chips[i], 0, MSM_GPIO_INT_EN);\r\ngpiochip_add(&msm_gpio_chips[i].chip);\r\n}\r\nirq_set_chained_handler(irq1, msm_gpio_irq_handler);\r\nirq_set_chained_handler(irq2, msm_gpio_irq_handler);\r\nirq_set_irq_wake(irq1, 1);\r\nirq_set_irq_wake(irq2, 2);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_msm_v1_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_msm_v1_driver);\r\n}
