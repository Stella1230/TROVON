static inline struct dvb_frontend *rtl2832_sdr_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, const struct rtl2832_config *cfg,\r\nstruct v4l2_subdev *sd)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int rtl28xxu_ctrl_msg(struct dvb_usb_device *d, struct rtl28xxu_req *req)\r\n{\r\nint ret;\r\nunsigned int pipe;\r\nu8 requesttype;\r\nu8 *buf;\r\nbuf = kmalloc(req->size, GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (req->index & CMD_WR_FLAG) {\r\nmemcpy(buf, req->data, req->size);\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\npipe = usb_sndctrlpipe(d->udev, 0);\r\n} else {\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\npipe = usb_rcvctrlpipe(d->udev, 0);\r\n}\r\nret = usb_control_msg(d->udev, pipe, 0, requesttype, req->value,\r\nreq->index, buf, req->size, 1000);\r\ndvb_usb_dbg_usb_control_msg(d->udev, 0, requesttype, req->value,\r\nreq->index, buf, req->size);\r\nif (ret > 0)\r\nret = 0;\r\nif (!ret && requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))\r\nmemcpy(req->data, buf, req->size);\r\nkfree(buf);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl28xx_wr_regs(struct dvb_usb_device *d, u16 reg, u8 *val, int len)\r\n{\r\nstruct rtl28xxu_req req;\r\nif (reg < 0x3000)\r\nreq.index = CMD_USB_WR;\r\nelse if (reg < 0x4000)\r\nreq.index = CMD_SYS_WR;\r\nelse\r\nreq.index = CMD_IR_WR;\r\nreq.value = reg;\r\nreq.size = len;\r\nreq.data = val;\r\nreturn rtl28xxu_ctrl_msg(d, &req);\r\n}\r\nstatic int rtl2831_rd_regs(struct dvb_usb_device *d, u16 reg, u8 *val, int len)\r\n{\r\nstruct rtl28xxu_req req;\r\nif (reg < 0x3000)\r\nreq.index = CMD_USB_RD;\r\nelse if (reg < 0x4000)\r\nreq.index = CMD_SYS_RD;\r\nelse\r\nreq.index = CMD_IR_RD;\r\nreq.value = reg;\r\nreq.size = len;\r\nreq.data = val;\r\nreturn rtl28xxu_ctrl_msg(d, &req);\r\n}\r\nstatic int rtl28xx_wr_reg(struct dvb_usb_device *d, u16 reg, u8 val)\r\n{\r\nreturn rtl28xx_wr_regs(d, reg, &val, 1);\r\n}\r\nstatic int rtl28xx_rd_reg(struct dvb_usb_device *d, u16 reg, u8 *val)\r\n{\r\nreturn rtl2831_rd_regs(d, reg, val, 1);\r\n}\r\nstatic int rtl28xx_wr_reg_mask(struct dvb_usb_device *d, u16 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = rtl28xx_rd_reg(d, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn rtl28xx_wr_reg(d, reg, val);\r\n}\r\nstatic int rtl28xxu_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct rtl28xxu_priv *priv = d->priv;\r\nstruct rtl28xxu_req req;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (num == 2 && !(msg[0].flags & I2C_M_RD) &&\r\n(msg[1].flags & I2C_M_RD)) {\r\nif (msg[0].len > 24 || msg[1].len > 24) {\r\nret = -EOPNOTSUPP;\r\ngoto err_mutex_unlock;\r\n} else if (msg[0].addr == 0x10) {\r\nreq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\r\nreq.index = CMD_DEMOD_RD | priv->page;\r\nreq.size = msg[1].len;\r\nreq.data = &msg[1].buf[0];\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n} else if (msg[0].len < 2) {\r\nreq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\r\nreq.index = CMD_I2C_RD;\r\nreq.size = msg[1].len;\r\nreq.data = &msg[1].buf[0];\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n} else {\r\nreq.value = (msg[0].addr << 1);\r\nreq.index = CMD_I2C_DA_WR;\r\nreq.size = msg[0].len;\r\nreq.data = msg[0].buf;\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto err_mutex_unlock;\r\nreq.value = (msg[0].addr << 1);\r\nreq.index = CMD_I2C_DA_RD;\r\nreq.size = msg[1].len;\r\nreq.data = msg[1].buf;\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n}\r\n} else if (num == 1 && !(msg[0].flags & I2C_M_RD)) {\r\nif (msg[0].len > 22) {\r\nret = -EOPNOTSUPP;\r\ngoto err_mutex_unlock;\r\n} else if (msg[0].addr == 0x10) {\r\nif (msg[0].buf[0] == 0x00) {\r\npriv->page = msg[0].buf[1];\r\nret = 0;\r\n} else {\r\nreq.value = (msg[0].buf[0] << 8) |\r\n(msg[0].addr << 1);\r\nreq.index = CMD_DEMOD_WR | priv->page;\r\nreq.size = msg[0].len-1;\r\nreq.data = &msg[0].buf[1];\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n}\r\n} else if (msg[0].len < 23) {\r\nreq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\r\nreq.index = CMD_I2C_WR;\r\nreq.size = msg[0].len-1;\r\nreq.data = &msg[0].buf[1];\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n} else {\r\nreq.value = (msg[0].addr << 1);\r\nreq.index = CMD_I2C_DA_WR;\r\nreq.size = msg[0].len;\r\nreq.data = msg[0].buf;\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nerr_mutex_unlock:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret ? ret : num;\r\n}\r\nstatic u32 rtl28xxu_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int rtl2831u_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct rtl28xxu_priv *priv = d_to_priv(d);\r\nint ret;\r\nu8 buf[1];\r\nstruct rtl28xxu_req req_gate_open = {0x0120, 0x0011, 0x0001, "\x08"};\r\nstruct rtl28xxu_req req_mt2060 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_qt1010 = {0x0fc4, CMD_I2C_RD, 1, buf};\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nret = rtl28xx_wr_reg(d, SYS_GPIO_DIR, 0x0a);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg(d, SYS_GPIO_OUT_EN, 0x15);\r\nif (ret)\r\ngoto err;\r\nmsleep(20);\r\npriv->tuner_name = "NONE";\r\nret = rtl28xxu_ctrl_msg(d, &req_gate_open);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_ctrl_msg(d, &req_qt1010);\r\nif (ret == 0 && buf[0] == 0x2c) {\r\npriv->tuner = TUNER_RTL2830_QT1010;\r\npriv->tuner_name = "QT1010";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_gate_open);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_ctrl_msg(d, &req_mt2060);\r\nif (ret == 0 && buf[0] == 0x63) {\r\npriv->tuner = TUNER_RTL2830_MT2060;\r\npriv->tuner_name = "MT2060";\r\ngoto found;\r\n}\r\npriv->tuner = TUNER_RTL2830_MXL5005S;\r\npriv->tuner_name = "MXL5005S";\r\ngoto found;\r\nfound:\r\ndev_dbg(&d->udev->dev, "%s: tuner=%s\n", __func__, priv->tuner_name);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct rtl28xxu_priv *priv = d_to_priv(d);\r\nint ret;\r\nu8 buf[2];\r\nstruct rtl28xxu_req req_gate_open = {0x0120, 0x0011, 0x0001, "\x18"};\r\nstruct rtl28xxu_req req_gate_close = {0x0120, 0x0011, 0x0001, "\x10"};\r\nstruct rtl28xxu_req req_fc0012 = {0x00c6, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_fc0013 = {0x00c6, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_mt2266 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_fc2580 = {0x01ac, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_mt2063 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_max3543 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_tua9001 = {0x7ec0, CMD_I2C_RD, 2, buf};\r\nstruct rtl28xxu_req req_mxl5007t = {0xd9c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_e4000 = {0x02c8, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_tda18272 = {0x00c0, CMD_I2C_RD, 2, buf};\r\nstruct rtl28xxu_req req_r820t = {0x0034, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_r828d = {0x0074, CMD_I2C_RD, 1, buf};\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x40);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x48, 0x48);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_ctrl_msg(d, &req_gate_open);\r\nif (ret)\r\ngoto err;\r\npriv->tuner_name = "NONE";\r\nret = rtl28xxu_ctrl_msg(d, &req_fc0012);\r\nif (ret == 0 && buf[0] == 0xa1) {\r\npriv->tuner = TUNER_RTL2832_FC0012;\r\npriv->tuner_name = "FC0012";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_fc0013);\r\nif (ret == 0 && buf[0] == 0xa3) {\r\npriv->tuner = TUNER_RTL2832_FC0013;\r\npriv->tuner_name = "FC0013";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_mt2266);\r\nif (ret == 0 && buf[0] == 0x85) {\r\npriv->tuner = TUNER_RTL2832_MT2266;\r\npriv->tuner_name = "MT2266";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_fc2580);\r\nif (ret == 0 && buf[0] == 0x56) {\r\npriv->tuner = TUNER_RTL2832_FC2580;\r\npriv->tuner_name = "FC2580";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_mt2063);\r\nif (ret == 0 && (buf[0] == 0x9e || buf[0] == 0x9c)) {\r\npriv->tuner = TUNER_RTL2832_MT2063;\r\npriv->tuner_name = "MT2063";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_max3543);\r\nif (ret == 0 && buf[0] == 0x38) {\r\npriv->tuner = TUNER_RTL2832_MAX3543;\r\npriv->tuner_name = "MAX3543";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_tua9001);\r\nif (ret == 0 && buf[0] == 0x23 && buf[1] == 0x28) {\r\npriv->tuner = TUNER_RTL2832_TUA9001;\r\npriv->tuner_name = "TUA9001";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_mxl5007t);\r\nif (ret == 0 && buf[0] == 0x14) {\r\npriv->tuner = TUNER_RTL2832_MXL5007T;\r\npriv->tuner_name = "MXL5007T";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_e4000);\r\nif (ret == 0 && buf[0] == 0x40) {\r\npriv->tuner = TUNER_RTL2832_E4000;\r\npriv->tuner_name = "E4000";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_tda18272);\r\nif (ret == 0 && (buf[0] == 0xc7 || buf[1] == 0x60)) {\r\npriv->tuner = TUNER_RTL2832_TDA18272;\r\npriv->tuner_name = "TDA18272";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_r820t);\r\nif (ret == 0 && buf[0] == 0x69) {\r\npriv->tuner = TUNER_RTL2832_R820T;\r\npriv->tuner_name = "R820T";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_r828d);\r\nif (ret == 0 && buf[0] == 0x69) {\r\npriv->tuner = TUNER_RTL2832_R828D;\r\npriv->tuner_name = "R828D";\r\ngoto found;\r\n}\r\nfound:\r\ndev_dbg(&d->udev->dev, "%s: tuner=%s\n", __func__, priv->tuner_name);\r\nret = rtl28xxu_ctrl_msg(d, &req_gate_close);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2831u_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_priv *priv = d_to_priv(d);\r\nconst struct rtl2830_config *rtl2830_config;\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nswitch (priv->tuner) {\r\ncase TUNER_RTL2830_QT1010:\r\nrtl2830_config = &rtl28xxu_rtl2830_qt1010_config;\r\nbreak;\r\ncase TUNER_RTL2830_MT2060:\r\nrtl2830_config = &rtl28xxu_rtl2830_mt2060_config;\r\nbreak;\r\ncase TUNER_RTL2830_MXL5005S:\r\nrtl2830_config = &rtl28xxu_rtl2830_mxl5005s_config;\r\nbreak;\r\ndefault:\r\ndev_err(&d->udev->dev, "%s: unknown tuner=%s\n",\r\nKBUILD_MODNAME, priv->tuner_name);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nadap->fe[0] = dvb_attach(rtl2830_attach, rtl2830_config, &d->i2c_adap);\r\nif (!adap->fe[0]) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_fc0012_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nint ret;\r\nu8 val;\r\ndev_dbg(&d->udev->dev, "%s: cmd=%d arg=%d\n", __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase FC_FE_CALLBACK_VHF_ENABLE:\r\nret = rtl28xx_rd_reg(d, SYS_GPIO_OUT_VAL, &val);\r\nif (ret)\r\ngoto err;\r\nif (arg)\r\nval &= 0xbf;\r\nelse\r\nval |= 0x40;\r\nret = rtl28xx_wr_reg(d, SYS_GPIO_OUT_VAL, val);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_tua9001_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nint ret;\r\nu8 val;\r\ndev_dbg(&d->udev->dev, "%s: cmd=%d arg=%d\n", __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase TUA9001_CMD_RESETN:\r\nif (arg)\r\nval = (1 << 4);\r\nelse\r\nval = (0 << 4);\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_OUT_VAL, val, 0x10);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase TUA9001_CMD_RXEN:\r\nif (arg)\r\nval = (1 << 1);\r\nelse\r\nval = (0 << 1);\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_OUT_VAL, val, 0x02);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_tuner_callback(struct dvb_usb_device *d, int cmd, int arg)\r\n{\r\nstruct rtl28xxu_priv *priv = d->priv;\r\nswitch (priv->tuner) {\r\ncase TUNER_RTL2832_FC0012:\r\nreturn rtl2832u_fc0012_tuner_callback(d, cmd, arg);\r\ncase TUNER_RTL2832_TUA9001:\r\nreturn rtl2832u_tua9001_tuner_callback(d, cmd, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2832u_frontend_callback(void *adapter_priv, int component,\r\nint cmd, int arg)\r\n{\r\nstruct i2c_adapter *adap = adapter_priv;\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\ndev_dbg(&d->udev->dev, "%s: component=%d cmd=%d arg=%d\n",\r\n__func__, component, cmd, arg);\r\nswitch (component) {\r\ncase DVB_FRONTEND_COMPONENT_TUNER:\r\nreturn rtl2832u_tuner_callback(d, cmd, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2832u_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_priv *priv = d_to_priv(d);\r\nconst struct rtl2832_config *rtl2832_config;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nswitch (priv->tuner) {\r\ncase TUNER_RTL2832_FC0012:\r\nrtl2832_config = &rtl28xxu_rtl2832_fc0012_config;\r\nbreak;\r\ncase TUNER_RTL2832_FC0013:\r\nrtl2832_config = &rtl28xxu_rtl2832_fc0013_config;\r\nbreak;\r\ncase TUNER_RTL2832_FC2580:\r\nrtl2832_config = &rtl28xxu_rtl2832_fc0012_config;\r\nbreak;\r\ncase TUNER_RTL2832_TUA9001:\r\nrtl2832_config = &rtl28xxu_rtl2832_tua9001_config;\r\nbreak;\r\ncase TUNER_RTL2832_E4000:\r\nrtl2832_config = &rtl28xxu_rtl2832_e4000_config;\r\nbreak;\r\ncase TUNER_RTL2832_R820T:\r\ncase TUNER_RTL2832_R828D:\r\nrtl2832_config = &rtl28xxu_rtl2832_r820t_config;\r\nbreak;\r\ndefault:\r\ndev_err(&d->udev->dev, "%s: unknown tuner=%s\n",\r\nKBUILD_MODNAME, priv->tuner_name);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nadap->fe[0] = dvb_attach(rtl2832_attach, rtl2832_config, &d->i2c_adap);\r\nif (!adap->fe[0]) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\npriv->demod_i2c_adapter = rtl2832_get_i2c_adapter(adap->fe[0]);\r\nadap->fe[0]->callback = rtl2832u_frontend_callback;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2831u_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_priv *priv = d_to_priv(d);\r\nstruct i2c_adapter *rtl2830_tuner_i2c;\r\nstruct dvb_frontend *fe;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nrtl2830_tuner_i2c = rtl2830_get_tuner_i2c_adapter(adap->fe[0]);\r\nswitch (priv->tuner) {\r\ncase TUNER_RTL2830_QT1010:\r\nfe = dvb_attach(qt1010_attach, adap->fe[0],\r\nrtl2830_tuner_i2c, &rtl28xxu_qt1010_config);\r\nbreak;\r\ncase TUNER_RTL2830_MT2060:\r\nfe = dvb_attach(mt2060_attach, adap->fe[0],\r\nrtl2830_tuner_i2c, &rtl28xxu_mt2060_config,\r\n1220);\r\nbreak;\r\ncase TUNER_RTL2830_MXL5005S:\r\nfe = dvb_attach(mxl5005s_attach, adap->fe[0],\r\nrtl2830_tuner_i2c, &rtl28xxu_mxl5005s_config);\r\nbreak;\r\ndefault:\r\nfe = NULL;\r\ndev_err(&d->udev->dev, "%s: unknown tuner=%d\n", KBUILD_MODNAME,\r\npriv->tuner);\r\n}\r\nif (fe == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_priv *priv = d_to_priv(d);\r\nstruct dvb_frontend *fe = NULL;\r\nstruct i2c_board_info info;\r\nstruct i2c_client *client;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nswitch (priv->tuner) {\r\ncase TUNER_RTL2832_FC0012:\r\nfe = dvb_attach(fc0012_attach, adap->fe[0],\r\n&d->i2c_adap, &rtl2832u_fc0012_config);\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\ndvb_attach_sdr(rtl2832_sdr_attach, adap->fe[0], &d->i2c_adap,\r\n&rtl28xxu_rtl2832_fc0012_config, NULL);\r\nbreak;\r\ncase TUNER_RTL2832_FC0013:\r\nfe = dvb_attach(fc0013_attach, adap->fe[0],\r\n&d->i2c_adap, 0xc6>>1, 0, FC_XTAL_28_8_MHZ);\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\ndvb_attach_sdr(rtl2832_sdr_attach, adap->fe[0], &d->i2c_adap,\r\n&rtl28xxu_rtl2832_fc0013_config, NULL);\r\nbreak;\r\ncase TUNER_RTL2832_E4000: {\r\nstruct v4l2_subdev *sd;\r\nstruct i2c_adapter *i2c_adap_internal =\r\nrtl2832_get_private_i2c_adapter(adap->fe[0]);\r\nstruct e4000_config e4000_config = {\r\n.fe = adap->fe[0],\r\n.clock = 28800000,\r\n};\r\nstrlcpy(info.type, "e4000", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &e4000_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(priv->demod_i2c_adapter, &info);\r\nif (client == NULL || client->dev.driver == NULL)\r\nbreak;\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nbreak;\r\n}\r\npriv->client = client;\r\nsd = i2c_get_clientdata(client);\r\ni2c_set_adapdata(i2c_adap_internal, d);\r\ndvb_attach_sdr(rtl2832_sdr_attach, adap->fe[0],\r\ni2c_adap_internal,\r\n&rtl28xxu_rtl2832_e4000_config, sd);\r\n}\r\nbreak;\r\ncase TUNER_RTL2832_FC2580:\r\nfe = dvb_attach(fc2580_attach, adap->fe[0], &d->i2c_adap,\r\n&rtl2832u_fc2580_config);\r\nbreak;\r\ncase TUNER_RTL2832_TUA9001:\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x12);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x12, 0x12);\r\nif (ret)\r\ngoto err;\r\nfe = dvb_attach(tua9001_attach, adap->fe[0], &d->i2c_adap,\r\n&rtl2832u_tua9001_config);\r\nbreak;\r\ncase TUNER_RTL2832_R820T:\r\nfe = dvb_attach(r820t_attach, adap->fe[0], &d->i2c_adap,\r\n&rtl2832u_r820t_config);\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\ndvb_attach_sdr(rtl2832_sdr_attach, adap->fe[0], &d->i2c_adap,\r\n&rtl28xxu_rtl2832_r820t_config, NULL);\r\nbreak;\r\ncase TUNER_RTL2832_R828D:\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nfe = dvb_attach(r820t_attach, adap->fe[0], &d->i2c_adap,\r\n&rtl2832u_r828d_config);\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\nbreak;\r\ndefault:\r\ndev_err(&d->udev->dev, "%s: unknown tuner=%d\n", KBUILD_MODNAME,\r\npriv->tuner);\r\n}\r\nif (fe == NULL && priv->client == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl28xxu_init(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nu8 val;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nret = rtl28xx_rd_reg(d, USB_SYSCTL_0, &val);\r\nif (ret)\r\ngoto err;\r\nval |= 0x09;\r\nret = rtl28xx_wr_reg(d, USB_SYSCTL_0, val);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_regs(d, USB_EPA_MAXPKT, "\x00\x02\x00\x00", 4);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_regs(d, USB_EPA_FIFO_CFG, "\x14\x00\x00\x00", 4);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void rtl28xxu_exit(struct dvb_usb_device *d)\r\n{\r\nstruct rtl28xxu_priv *priv = d->priv;\r\nstruct i2c_client *client = priv->client;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nreturn;\r\n}\r\nstatic int rtl2831u_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint ret;\r\nu8 gpio, sys0, epa_ctl[2];\r\ndev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);\r\nret = rtl28xx_rd_reg(d, SYS_SYS0, &sys0);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_rd_reg(d, SYS_GPIO_OUT_VAL, &gpio);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&d->udev->dev, "%s: RD SYS0=%02x GPIO_OUT_VAL=%02x\n", __func__,\r\nsys0, gpio);\r\nif (onoff) {\r\ngpio |= 0x01;\r\ngpio &= (~0x10);\r\ngpio |= 0x04;\r\nsys0 = sys0 & 0x0f;\r\nsys0 |= 0xe0;\r\nepa_ctl[0] = 0x00;\r\nepa_ctl[1] = 0x00;\r\n} else {\r\ngpio &= (~0x01);\r\ngpio |= 0x10;\r\ngpio &= (~0x04);\r\nsys0 = sys0 & (~0xc0);\r\nepa_ctl[0] = 0x10;\r\nepa_ctl[1] = 0x02;\r\n}\r\ndev_dbg(&d->udev->dev, "%s: WR SYS0=%02x GPIO_OUT_VAL=%02x\n", __func__,\r\nsys0, gpio);\r\nret = rtl28xx_wr_reg(d, SYS_SYS0, sys0);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg(d, SYS_GPIO_OUT_VAL, gpio);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_regs(d, USB_EPA_CTL, epa_ctl, 2);\r\nif (ret)\r\ngoto err;\r\nif (onoff)\r\nusb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, 0x81));\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);\r\nif (onoff) {\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x08, 0x18);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_DEMOD_CTL1, 0x00, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_DEMOD_CTL, 0x80, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_DEMOD_CTL, 0x20, 0x20);\r\nif (ret)\r\ngoto err;\r\nmdelay(5);\r\nret = rtl28xx_wr_reg_mask(d, SYS_DEMOD_CTL, 0x48, 0x48);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_regs(d, USB_EPA_CTL, "\x00\x00", 2);\r\nif (ret)\r\ngoto err;\r\nret = usb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, 0x81));\r\nif (ret)\r\ngoto err;\r\n} else {\r\nret = rtl28xx_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x10, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_DEMOD_CTL, 0x00, 0x48);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg_mask(d, SYS_DEMOD_CTL, 0x00, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_regs(d, USB_EPA_CTL, "\x10\x02", 2);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2831u_rc_query(struct dvb_usb_device *d)\r\n{\r\nint ret, i;\r\nstruct rtl28xxu_priv *priv = d->priv;\r\nu8 buf[5];\r\nu32 rc_code;\r\nstruct rtl28xxu_reg_val rc_nec_tab[] = {\r\n{ 0x3033, 0x80 },\r\n{ 0x3020, 0x43 },\r\n{ 0x3021, 0x16 },\r\n{ 0x3022, 0x16 },\r\n{ 0x3023, 0x5a },\r\n{ 0x3024, 0x2d },\r\n{ 0x3025, 0x16 },\r\n{ 0x3026, 0x01 },\r\n{ 0x3028, 0xb0 },\r\n{ 0x3029, 0x04 },\r\n{ 0x302c, 0x88 },\r\n{ 0x302e, 0x13 },\r\n{ 0x3030, 0xdf },\r\n{ 0x3031, 0x05 },\r\n};\r\nif (!priv->rc_active) {\r\nfor (i = 0; i < ARRAY_SIZE(rc_nec_tab); i++) {\r\nret = rtl28xx_wr_reg(d, rc_nec_tab[i].reg,\r\nrc_nec_tab[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\npriv->rc_active = true;\r\n}\r\nret = rtl2831_rd_regs(d, SYS_IRRC_RP, buf, 5);\r\nif (ret)\r\ngoto err;\r\nif (buf[4] & 0x01) {\r\nif (buf[2] == (u8) ~buf[3]) {\r\nif (buf[0] == (u8) ~buf[1]) {\r\nrc_code = RC_SCANCODE_NEC(buf[0], buf[2]);\r\n} else {\r\nrc_code = RC_SCANCODE_NECX(buf[0] << 8 | buf[1],\r\nbuf[2]);\r\n}\r\n} else {\r\nrc_code = RC_SCANCODE_NEC32(buf[0] << 24 | buf[1] << 16 |\r\nbuf[2] << 8 | buf[3]);\r\n}\r\nrc_keydown(d->rc_dev, RC_TYPE_NEC, rc_code, 0);\r\nret = rtl28xx_wr_reg(d, SYS_IRRC_SR, 1);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xx_wr_reg(d, SYS_IRRC_SR, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2831u_get_rc_config(struct dvb_usb_device *d,\r\nstruct dvb_usb_rc *rc)\r\n{\r\nrc->map_name = RC_MAP_EMPTY;\r\nrc->allowed_protos = RC_BIT_NEC;\r\nrc->query = rtl2831u_rc_query;\r\nrc->interval = 400;\r\nreturn 0;\r\n}\r\nstatic int rtl2832u_rc_query(struct dvb_usb_device *d)\r\n{\r\nint ret, i, len;\r\nstruct rtl28xxu_priv *priv = d->priv;\r\nstruct ir_raw_event ev;\r\nu8 buf[128];\r\nstatic const struct rtl28xxu_reg_val_mask refresh_tab[] = {\r\n{IR_RX_IF, 0x03, 0xff},\r\n{IR_RX_BUF_CTRL, 0x80, 0xff},\r\n{IR_RX_CTRL, 0x80, 0xff},\r\n};\r\nif (!priv->rc_active) {\r\nstatic const struct rtl28xxu_reg_val_mask init_tab[] = {\r\n{SYS_DEMOD_CTL1, 0x00, 0x04},\r\n{SYS_DEMOD_CTL1, 0x00, 0x08},\r\n{USB_CTRL, 0x20, 0x20},\r\n{SYS_GPIO_DIR, 0x00, 0x08},\r\n{SYS_GPIO_OUT_EN, 0x08, 0x08},\r\n{SYS_GPIO_OUT_VAL, 0x08, 0x08},\r\n{IR_MAX_DURATION0, 0xd0, 0xff},\r\n{IR_MAX_DURATION1, 0x07, 0xff},\r\n{IR_IDLE_LEN0, 0xc0, 0xff},\r\n{IR_IDLE_LEN1, 0x00, 0xff},\r\n{IR_GLITCH_LEN, 0x03, 0xff},\r\n{IR_RX_CLK, 0x09, 0xff},\r\n{IR_RX_CFG, 0x1c, 0xff},\r\n{IR_MAX_H_TOL_LEN, 0x1e, 0xff},\r\n{IR_MAX_L_TOL_LEN, 0x1e, 0xff},\r\n{IR_RX_CTRL, 0x80, 0xff},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(init_tab); i++) {\r\nret = rtl28xx_wr_reg_mask(d, init_tab[i].reg,\r\ninit_tab[i].val, init_tab[i].mask);\r\nif (ret)\r\ngoto err;\r\n}\r\npriv->rc_active = true;\r\n}\r\nret = rtl28xx_rd_reg(d, IR_RX_IF, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nif (buf[0] != 0x83)\r\ngoto exit;\r\nret = rtl28xx_rd_reg(d, IR_RX_BC, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nlen = buf[0];\r\nret = rtl2831_rd_regs(d, IR_RX_BUF, buf, len);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(refresh_tab); i++) {\r\nret = rtl28xx_wr_reg_mask(d, refresh_tab[i].reg,\r\nrefresh_tab[i].val, refresh_tab[i].mask);\r\nif (ret)\r\ngoto err;\r\n}\r\ninit_ir_raw_event(&ev);\r\nfor (i = 0; i < len; i++) {\r\nev.pulse = buf[i] >> 7;\r\nev.duration = 50800 * (buf[i] & 0x7f);\r\nir_raw_event_store_with_filter(d->rc_dev, &ev);\r\n}\r\nir_raw_event_set_idle(d->rc_dev, true);\r\nir_raw_event_handle(d->rc_dev);\r\nexit:\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_get_rc_config(struct dvb_usb_device *d,\r\nstruct dvb_usb_rc *rc)\r\n{\r\nif (rtl28xxu_disable_rc)\r\nreturn rtl28xx_wr_reg(d, IR_RX_IE, 0x00);\r\nif (!rc->map_name)\r\nrc->map_name = RC_MAP_EMPTY;\r\nrc->allowed_protos = RC_BIT_ALL;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->query = rtl2832u_rc_query;\r\nrc->interval = 400;\r\nreturn 0;\r\n}
