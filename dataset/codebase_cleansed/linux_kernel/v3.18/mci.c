static struct ath_mci_profile_info*\r\nath_mci_find_profile(struct ath_mci_profile *mci,\r\nstruct ath_mci_profile_info *info)\r\n{\r\nstruct ath_mci_profile_info *entry;\r\nif (list_empty(&mci->info))\r\nreturn NULL;\r\nlist_for_each_entry(entry, &mci->info, list) {\r\nif (entry->conn_handle == info->conn_handle)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool ath_mci_add_profile(struct ath_common *common,\r\nstruct ath_mci_profile *mci,\r\nstruct ath_mci_profile_info *info)\r\n{\r\nstruct ath_mci_profile_info *entry;\r\nu8 voice_priority[] = { 110, 110, 110, 112, 110, 110, 114, 116, 118 };\r\nif ((mci->num_sco == ATH_MCI_MAX_SCO_PROFILE) &&\r\n(info->type == MCI_GPM_COEX_PROFILE_VOICE))\r\nreturn false;\r\nif (((NUM_PROF(mci) - mci->num_sco) == ATH_MCI_MAX_ACL_PROFILE) &&\r\n(info->type != MCI_GPM_COEX_PROFILE_VOICE))\r\nreturn false;\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry)\r\nreturn false;\r\nmemcpy(entry, info, 10);\r\nINC_PROF(mci, info);\r\nlist_add_tail(&entry->list, &mci->info);\r\nif (info->type == MCI_GPM_COEX_PROFILE_VOICE) {\r\nif (info->voice_type < sizeof(voice_priority))\r\nmci->voice_priority = voice_priority[info->voice_type];\r\nelse\r\nmci->voice_priority = 110;\r\n}\r\nreturn true;\r\n}\r\nstatic void ath_mci_del_profile(struct ath_common *common,\r\nstruct ath_mci_profile *mci,\r\nstruct ath_mci_profile_info *entry)\r\n{\r\nif (!entry)\r\nreturn;\r\nDEC_PROF(mci, entry);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nvoid ath_mci_flush_profile(struct ath_mci_profile *mci)\r\n{\r\nstruct ath_mci_profile_info *info, *tinfo;\r\nmci->aggr_limit = 0;\r\nmci->num_mgmt = 0;\r\nif (list_empty(&mci->info))\r\nreturn;\r\nlist_for_each_entry_safe(info, tinfo, &mci->info, list) {\r\nlist_del(&info->list);\r\nDEC_PROF(mci, info);\r\nkfree(info);\r\n}\r\n}\r\nstatic void ath_mci_adjust_aggr_limit(struct ath_btcoex *btcoex)\r\n{\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nu32 wlan_airtime = btcoex->btcoex_period *\r\n(100 - btcoex->duty_cycle) / 100;\r\nif ((wlan_airtime <= 4) &&\r\n(!mci->aggr_limit || (mci->aggr_limit > (2 * wlan_airtime))))\r\nmci->aggr_limit = 2 * wlan_airtime;\r\n}\r\nstatic void ath_mci_update_scheme(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nstruct ath9k_hw_mci *mci_hw = &sc->sc_ah->btcoex_hw.mci;\r\nstruct ath_mci_profile_info *info;\r\nu32 num_profile = NUM_PROF(mci);\r\nif (mci_hw->config & ATH_MCI_CONFIG_DISABLE_TUNING)\r\ngoto skip_tuning;\r\nmci->aggr_limit = 0;\r\nbtcoex->duty_cycle = ath_mci_duty_cycle[num_profile];\r\nbtcoex->btcoex_period = ATH_MCI_DEF_BT_PERIOD;\r\nif (NUM_PROF(mci))\r\nbtcoex->bt_stomp_type = ATH_BTCOEX_STOMP_LOW;\r\nelse\r\nbtcoex->bt_stomp_type = mci->num_mgmt ? ATH_BTCOEX_STOMP_ALL :\r\nATH_BTCOEX_STOMP_LOW;\r\nif (num_profile == 1) {\r\ninfo = list_first_entry(&mci->info,\r\nstruct ath_mci_profile_info,\r\nlist);\r\nif (mci->num_sco) {\r\nif (info->T == 12)\r\nmci->aggr_limit = 8;\r\nelse if (info->T == 6) {\r\nmci->aggr_limit = 6;\r\nbtcoex->duty_cycle = 30;\r\n} else\r\nmci->aggr_limit = 6;\r\nath_dbg(common, MCI,\r\n"Single SCO, aggregation limit %d 1/4 ms\n",\r\nmci->aggr_limit);\r\n} else if (mci->num_pan || mci->num_other_acl) {\r\nbtcoex->duty_cycle = AR_SREV_9565(sc->sc_ah) ? 40 : 35;\r\nbtcoex->btcoex_period = 53;\r\nath_dbg(common, MCI,\r\n"Single PAN/FTP bt period %d ms dutycycle %d\n",\r\nbtcoex->duty_cycle, btcoex->btcoex_period);\r\n} else if (mci->num_hid) {\r\nbtcoex->duty_cycle = 30;\r\nmci->aggr_limit = 6;\r\nath_dbg(common, MCI,\r\n"Multiple attempt/timeout single HID "\r\n"aggregation limit 1.5 ms dutycycle 30%%\n");\r\n}\r\n} else if (num_profile == 2) {\r\nif (mci->num_hid == 2)\r\nbtcoex->duty_cycle = 30;\r\nmci->aggr_limit = 6;\r\nath_dbg(common, MCI,\r\n"Two BT profiles aggr limit 1.5 ms dutycycle %d%%\n",\r\nbtcoex->duty_cycle);\r\n} else if (num_profile >= 3) {\r\nmci->aggr_limit = 4;\r\nath_dbg(common, MCI,\r\n"Three or more profiles aggregation limit 1 ms\n");\r\n}\r\nskip_tuning:\r\nif (IS_CHAN_2GHZ(sc->sc_ah->curchan)) {\r\nif (IS_CHAN_HT(sc->sc_ah->curchan))\r\nath_mci_adjust_aggr_limit(btcoex);\r\nelse\r\nbtcoex->btcoex_period >>= 1;\r\n}\r\nath9k_btcoex_timer_pause(sc);\r\nath9k_hw_btcoex_disable(sc->sc_ah);\r\nif (IS_CHAN_5GHZ(sc->sc_ah->curchan))\r\nreturn;\r\nbtcoex->duty_cycle += (mci->num_bdr ? ATH_MCI_BDR_DUTY_CYCLE : 0);\r\nif (btcoex->duty_cycle > ATH_MCI_MAX_DUTY_CYCLE)\r\nbtcoex->duty_cycle = ATH_MCI_MAX_DUTY_CYCLE;\r\nbtcoex->btcoex_no_stomp = btcoex->btcoex_period *\r\n(100 - btcoex->duty_cycle) / 100;\r\nath9k_hw_btcoex_enable(sc->sc_ah);\r\nath9k_btcoex_timer_resume(sc);\r\n}\r\nstatic void ath_mci_cal_msg(struct ath_softc *sc, u8 opcode, u8 *rx_payload)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\r\nu32 payload[4] = {0, 0, 0, 0};\r\nswitch (opcode) {\r\ncase MCI_GPM_BT_CAL_REQ:\r\nif (mci_hw->bt_state == MCI_BT_AWAKE) {\r\nmci_hw->bt_state = MCI_BT_CAL_START;\r\nath9k_queue_reset(sc, RESET_TYPE_MCI);\r\n}\r\nath_dbg(common, MCI, "MCI State : %d\n", mci_hw->bt_state);\r\nbreak;\r\ncase MCI_GPM_BT_CAL_GRANT:\r\nMCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_DONE);\r\nar9003_mci_send_message(sc->sc_ah, MCI_GPM, 0, payload,\r\n16, false, true);\r\nbreak;\r\ndefault:\r\nath_dbg(common, MCI, "Unknown GPM CAL message\n");\r\nbreak;\r\n}\r\n}\r\nstatic void ath9k_mci_work(struct work_struct *work)\r\n{\r\nstruct ath_softc *sc = container_of(work, struct ath_softc, mci_work);\r\nath_mci_update_scheme(sc);\r\n}\r\nstatic void ath_mci_update_stomp_txprio(u8 cur_txprio, u8 *stomp_prio)\r\n{\r\nif (cur_txprio < stomp_prio[ATH_BTCOEX_STOMP_NONE])\r\nstomp_prio[ATH_BTCOEX_STOMP_NONE] = cur_txprio;\r\nif (cur_txprio > stomp_prio[ATH_BTCOEX_STOMP_ALL])\r\nstomp_prio[ATH_BTCOEX_STOMP_ALL] = cur_txprio;\r\nif ((cur_txprio > ATH_MCI_HI_PRIO) &&\r\n(cur_txprio < stomp_prio[ATH_BTCOEX_STOMP_LOW]))\r\nstomp_prio[ATH_BTCOEX_STOMP_LOW] = cur_txprio;\r\n}\r\nstatic void ath_mci_set_concur_txprio(struct ath_softc *sc)\r\n{\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nu8 stomp_txprio[ATH_BTCOEX_STOMP_MAX];\r\nmemset(stomp_txprio, 0, sizeof(stomp_txprio));\r\nif (mci->num_mgmt) {\r\nstomp_txprio[ATH_BTCOEX_STOMP_ALL] = ATH_MCI_INQUIRY_PRIO;\r\nif (!mci->num_pan && !mci->num_other_acl)\r\nstomp_txprio[ATH_BTCOEX_STOMP_NONE] =\r\nATH_MCI_INQUIRY_PRIO;\r\n} else {\r\nu8 prof_prio[] = { 50, 90, 94, 52 };\r\nstomp_txprio[ATH_BTCOEX_STOMP_LOW] =\r\nstomp_txprio[ATH_BTCOEX_STOMP_NONE] = 0xff;\r\nif (mci->num_sco)\r\nath_mci_update_stomp_txprio(mci->voice_priority,\r\nstomp_txprio);\r\nif (mci->num_other_acl)\r\nath_mci_update_stomp_txprio(prof_prio[0], stomp_txprio);\r\nif (mci->num_a2dp)\r\nath_mci_update_stomp_txprio(prof_prio[1], stomp_txprio);\r\nif (mci->num_hid)\r\nath_mci_update_stomp_txprio(prof_prio[2], stomp_txprio);\r\nif (mci->num_pan)\r\nath_mci_update_stomp_txprio(prof_prio[3], stomp_txprio);\r\nif (stomp_txprio[ATH_BTCOEX_STOMP_NONE] == 0xff)\r\nstomp_txprio[ATH_BTCOEX_STOMP_NONE] = 0;\r\nif (stomp_txprio[ATH_BTCOEX_STOMP_LOW] == 0xff)\r\nstomp_txprio[ATH_BTCOEX_STOMP_LOW] = 0;\r\n}\r\nath9k_hw_btcoex_set_concur_txprio(sc->sc_ah, stomp_txprio);\r\n}\r\nstatic u8 ath_mci_process_profile(struct ath_softc *sc,\r\nstruct ath_mci_profile_info *info)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nstruct ath_mci_profile_info *entry = NULL;\r\nentry = ath_mci_find_profile(mci, info);\r\nif (entry) {\r\nif (entry->type != info->type) {\r\nDEC_PROF(mci, entry);\r\nINC_PROF(mci, info);\r\n}\r\nmemcpy(entry, info, 10);\r\n}\r\nif (info->start) {\r\nif (!entry && !ath_mci_add_profile(common, mci, info))\r\nreturn 0;\r\n} else\r\nath_mci_del_profile(common, mci, entry);\r\nath_mci_set_concur_txprio(sc);\r\nreturn 1;\r\n}\r\nstatic u8 ath_mci_process_status(struct ath_softc *sc,\r\nstruct ath_mci_profile_status *status)\r\n{\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nstruct ath_mci_profile_info info;\r\nint i = 0, old_num_mgmt = mci->num_mgmt;\r\nif (status->is_link)\r\nreturn 0;\r\ninfo.conn_handle = status->conn_handle;\r\nif (ath_mci_find_profile(mci, &info))\r\nreturn 0;\r\nif (status->conn_handle >= ATH_MCI_MAX_PROFILE)\r\nreturn 0;\r\nif (status->is_critical)\r\n__set_bit(status->conn_handle, mci->status);\r\nelse\r\n__clear_bit(status->conn_handle, mci->status);\r\nmci->num_mgmt = 0;\r\ndo {\r\nif (test_bit(i, mci->status))\r\nmci->num_mgmt++;\r\n} while (++i < ATH_MCI_MAX_PROFILE);\r\nath_mci_set_concur_txprio(sc);\r\nif (old_num_mgmt != mci->num_mgmt)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ath_mci_msg(struct ath_softc *sc, u8 opcode, u8 *rx_payload)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_mci_profile_info profile_info;\r\nstruct ath_mci_profile_status profile_status;\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nu8 major, minor, update_scheme = 0;\r\nu32 seq_num;\r\nif (ar9003_mci_state(ah, MCI_STATE_NEED_FLUSH_BT_INFO) &&\r\nar9003_mci_state(ah, MCI_STATE_ENABLE)) {\r\nath_dbg(common, MCI, "(MCI) Need to flush BT profiles\n");\r\nath_mci_flush_profile(&sc->btcoex.mci);\r\nar9003_mci_state(ah, MCI_STATE_SEND_STATUS_QUERY);\r\n}\r\nswitch (opcode) {\r\ncase MCI_GPM_COEX_VERSION_QUERY:\r\nar9003_mci_state(ah, MCI_STATE_SEND_WLAN_COEX_VERSION);\r\nbreak;\r\ncase MCI_GPM_COEX_VERSION_RESPONSE:\r\nmajor = *(rx_payload + MCI_GPM_COEX_B_MAJOR_VERSION);\r\nminor = *(rx_payload + MCI_GPM_COEX_B_MINOR_VERSION);\r\nar9003_mci_set_bt_version(ah, major, minor);\r\nbreak;\r\ncase MCI_GPM_COEX_STATUS_QUERY:\r\nar9003_mci_send_wlan_channels(ah);\r\nbreak;\r\ncase MCI_GPM_COEX_BT_PROFILE_INFO:\r\nmemcpy(&profile_info,\r\n(rx_payload + MCI_GPM_COEX_B_PROFILE_TYPE), 10);\r\nif ((profile_info.type == MCI_GPM_COEX_PROFILE_UNKNOWN) ||\r\n(profile_info.type >= MCI_GPM_COEX_PROFILE_MAX)) {\r\nath_dbg(common, MCI,\r\n"Illegal profile type = %d, state = %d\n",\r\nprofile_info.type,\r\nprofile_info.start);\r\nbreak;\r\n}\r\nupdate_scheme += ath_mci_process_profile(sc, &profile_info);\r\nbreak;\r\ncase MCI_GPM_COEX_BT_STATUS_UPDATE:\r\nprofile_status.is_link = *(rx_payload +\r\nMCI_GPM_COEX_B_STATUS_TYPE);\r\nprofile_status.conn_handle = *(rx_payload +\r\nMCI_GPM_COEX_B_STATUS_LINKID);\r\nprofile_status.is_critical = *(rx_payload +\r\nMCI_GPM_COEX_B_STATUS_STATE);\r\nseq_num = *((u32 *)(rx_payload + 12));\r\nath_dbg(common, MCI,\r\n"BT_Status_Update: is_link=%d, linkId=%d, state=%d, SEQ=%u\n",\r\nprofile_status.is_link, profile_status.conn_handle,\r\nprofile_status.is_critical, seq_num);\r\nupdate_scheme += ath_mci_process_status(sc, &profile_status);\r\nbreak;\r\ndefault:\r\nath_dbg(common, MCI, "Unknown GPM COEX message = 0x%02x\n", opcode);\r\nbreak;\r\n}\r\nif (update_scheme)\r\nieee80211_queue_work(sc->hw, &sc->mci_work);\r\n}\r\nint ath_mci_setup(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_mci_coex *mci = &sc->mci_coex;\r\nstruct ath_mci_buf *buf = &mci->sched_buf;\r\nint ret;\r\nbuf->bf_addr = dmam_alloc_coherent(sc->dev,\r\nATH_MCI_SCHED_BUF_SIZE + ATH_MCI_GPM_BUF_SIZE,\r\n&buf->bf_paddr, GFP_KERNEL);\r\nif (buf->bf_addr == NULL) {\r\nath_dbg(common, FATAL, "MCI buffer alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(buf->bf_addr, MCI_GPM_RSVD_PATTERN,\r\nATH_MCI_SCHED_BUF_SIZE + ATH_MCI_GPM_BUF_SIZE);\r\nmci->sched_buf.bf_len = ATH_MCI_SCHED_BUF_SIZE;\r\nmci->gpm_buf.bf_len = ATH_MCI_GPM_BUF_SIZE;\r\nmci->gpm_buf.bf_addr = (u8 *)mci->sched_buf.bf_addr + mci->sched_buf.bf_len;\r\nmci->gpm_buf.bf_paddr = mci->sched_buf.bf_paddr + mci->sched_buf.bf_len;\r\nret = ar9003_mci_setup(sc->sc_ah, mci->gpm_buf.bf_paddr,\r\nmci->gpm_buf.bf_addr, (mci->gpm_buf.bf_len >> 4),\r\nmci->sched_buf.bf_paddr);\r\nif (ret) {\r\nath_err(common, "Failed to initialize MCI\n");\r\nreturn ret;\r\n}\r\nINIT_WORK(&sc->mci_work, ath9k_mci_work);\r\nath_dbg(common, MCI, "MCI Initialized\n");\r\nreturn 0;\r\n}\r\nvoid ath_mci_cleanup(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_hw *ah = sc->sc_ah;\r\nar9003_mci_cleanup(ah);\r\nath_dbg(common, MCI, "MCI De-Initialized\n");\r\n}\r\nvoid ath_mci_intr(struct ath_softc *sc)\r\n{\r\nstruct ath_mci_coex *mci = &sc->mci_coex;\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\r\nu32 mci_int, mci_int_rxmsg;\r\nu32 offset, subtype, opcode;\r\nu32 *pgpm;\r\nu32 more_data = MCI_GPM_MORE;\r\nbool skip_gpm = false;\r\nar9003_mci_get_interrupt(sc->sc_ah, &mci_int, &mci_int_rxmsg);\r\nif (ar9003_mci_state(ah, MCI_STATE_ENABLE) == 0) {\r\nar9003_mci_get_next_gpm_offset(ah, true, NULL);\r\nreturn;\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE) {\r\nu32 payload[4] = { 0xffffffff, 0xffffffff,\r\n0xffffffff, 0xffffff00};\r\nar9003_mci_send_message(ah, MCI_REMOTE_RESET, 0,\r\npayload, 16, true, false);\r\nar9003_mci_send_message(ah, MCI_SYS_WAKING, 0,\r\nNULL, 0, true, false);\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE;\r\nar9003_mci_state(ah, MCI_STATE_RESET_REQ_WAKE);\r\nar9003_mci_state(ah, MCI_STATE_SET_BT_AWAKE);\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING) {\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING;\r\nif ((mci_hw->bt_state == MCI_BT_SLEEP) &&\r\n(ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP) !=\r\nMCI_BT_SLEEP))\r\nar9003_mci_state(ah, MCI_STATE_SET_BT_AWAKE);\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING) {\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING;\r\nif ((mci_hw->bt_state == MCI_BT_AWAKE) &&\r\n(ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP) !=\r\nMCI_BT_AWAKE))\r\nmci_hw->bt_state = MCI_BT_SLEEP;\r\n}\r\nif ((mci_int & AR_MCI_INTERRUPT_RX_INVALID_HDR) ||\r\n(mci_int & AR_MCI_INTERRUPT_CONT_INFO_TIMEOUT)) {\r\nar9003_mci_state(ah, MCI_STATE_RECOVER_RX);\r\nskip_gpm = true;\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SCHD_INFO) {\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SCHD_INFO;\r\noffset = ar9003_mci_state(ah, MCI_STATE_LAST_SCHD_MSG_OFFSET);\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_GPM) {\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_GPM;\r\nwhile (more_data == MCI_GPM_MORE) {\r\nif (test_bit(ATH_OP_HW_RESET, &common->op_flags))\r\nreturn;\r\npgpm = mci->gpm_buf.bf_addr;\r\noffset = ar9003_mci_get_next_gpm_offset(ah, false,\r\n&more_data);\r\nif (offset == MCI_GPM_INVALID)\r\nbreak;\r\npgpm += (offset >> 2);\r\nsubtype = MCI_GPM_TYPE(pgpm);\r\nopcode = MCI_GPM_OPCODE(pgpm);\r\nif (skip_gpm)\r\ngoto recycle;\r\nif (MCI_GPM_IS_CAL_TYPE(subtype)) {\r\nath_mci_cal_msg(sc, subtype, (u8 *)pgpm);\r\n} else {\r\nswitch (subtype) {\r\ncase MCI_GPM_COEX_AGENT:\r\nath_mci_msg(sc, opcode, (u8 *)pgpm);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nrecycle:\r\nMCI_GPM_RECYCLE(pgpm);\r\n}\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_HW_MSG_MASK) {\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_LNA_CONTROL)\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_LNA_CONTROL;\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_LNA_INFO)\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_LNA_INFO;\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_INFO) {\r\nint value_dbm = MS(mci_hw->cont_status,\r\nAR_MCI_CONT_RSSI_POWER);\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_INFO;\r\nath_dbg(common, MCI,\r\n"MCI CONT_INFO: (%s) pri = %d pwr = %d dBm\n",\r\nMS(mci_hw->cont_status, AR_MCI_CONT_TXRX) ?\r\n"tx" : "rx",\r\nMS(mci_hw->cont_status, AR_MCI_CONT_PRIORITY),\r\nvalue_dbm);\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_NACK)\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_NACK;\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_RST)\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_RST;\r\n}\r\nif ((mci_int & AR_MCI_INTERRUPT_RX_INVALID_HDR) ||\r\n(mci_int & AR_MCI_INTERRUPT_CONT_INFO_TIMEOUT)) {\r\nmci_int &= ~(AR_MCI_INTERRUPT_RX_INVALID_HDR |\r\nAR_MCI_INTERRUPT_CONT_INFO_TIMEOUT);\r\nath_mci_msg(sc, MCI_GPM_COEX_NOOP, NULL);\r\n}\r\n}\r\nvoid ath_mci_enable(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nif (!common->btcoex_enabled)\r\nreturn;\r\nif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_MCI)\r\nsc->sc_ah->imask |= ATH9K_INT_MCI;\r\n}\r\nvoid ath9k_mci_update_wlan_channels(struct ath_softc *sc, bool allow_all)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\r\nstruct ath9k_channel *chan = ah->curchan;\r\nu32 channelmap[] = {0x00000000, 0xffff0000, 0xffffffff, 0x7fffffff};\r\nint i;\r\ns16 chan_start, chan_end;\r\nu16 wlan_chan;\r\nif (!chan || !IS_CHAN_2GHZ(chan))\r\nreturn;\r\nif (allow_all)\r\ngoto send_wlan_chan;\r\nwlan_chan = chan->channel - 2402;\r\nchan_start = wlan_chan - 10;\r\nchan_end = wlan_chan + 10;\r\nif (IS_CHAN_HT40PLUS(chan))\r\nchan_end += 20;\r\nelse if (IS_CHAN_HT40MINUS(chan))\r\nchan_start -= 20;\r\nchan_start -= 7;\r\nchan_end += 7;\r\nif (chan_start <= 0)\r\nchan_start = 0;\r\nif (chan_end >= ATH_MCI_NUM_BT_CHANNELS)\r\nchan_end = ATH_MCI_NUM_BT_CHANNELS - 1;\r\nath_dbg(ath9k_hw_common(ah), MCI,\r\n"WLAN current channel %d mask BT channel %d - %d\n",\r\nwlan_chan, chan_start, chan_end);\r\nfor (i = chan_start; i < chan_end; i++)\r\nMCI_GPM_CLR_CHANNEL_BIT(&channelmap, i);\r\nsend_wlan_chan:\r\nfor (i = 0; i < 4; i++)\r\nmci->wlan_channels[i] = channelmap[i];\r\nar9003_mci_send_wlan_channels(ah);\r\nar9003_mci_state(ah, MCI_STATE_SEND_VERSION_QUERY);\r\n}\r\nvoid ath9k_mci_set_txpower(struct ath_softc *sc, bool setchannel,\r\nbool concur_tx)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath9k_hw_mci *mci_hw = &sc->sc_ah->btcoex_hw.mci;\r\nbool old_concur_tx = mci_hw->concur_tx;\r\nif (!(mci_hw->config & ATH_MCI_CONFIG_CONCUR_TX)) {\r\nmci_hw->concur_tx = false;\r\nreturn;\r\n}\r\nif (!IS_CHAN_2GHZ(ah->curchan))\r\nreturn;\r\nif (setchannel) {\r\nstruct ath9k_hw_cal_data *caldata = &sc->cur_chan->caldata;\r\nif (IS_CHAN_HT40PLUS(ah->curchan) &&\r\n(ah->curchan->channel > caldata->channel) &&\r\n(ah->curchan->channel <= caldata->channel + 20))\r\nreturn;\r\nif (IS_CHAN_HT40MINUS(ah->curchan) &&\r\n(ah->curchan->channel < caldata->channel) &&\r\n(ah->curchan->channel >= caldata->channel - 20))\r\nreturn;\r\nmci_hw->concur_tx = false;\r\n} else\r\nmci_hw->concur_tx = concur_tx;\r\nif (old_concur_tx != mci_hw->concur_tx)\r\nath9k_hw_set_txpowerlimit(ah, sc->cur_chan->txpower, false);\r\n}\r\nstatic void ath9k_mci_stomp_audio(struct ath_softc *sc)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nif (!mci->num_sco && !mci->num_a2dp)\r\nreturn;\r\nif (ah->stats.avgbrssi > 25) {\r\nbtcoex->stomp_audio = 0;\r\nreturn;\r\n}\r\nbtcoex->stomp_audio++;\r\n}\r\nvoid ath9k_mci_update_rssi(struct ath_softc *sc)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath9k_hw_mci *mci_hw = &sc->sc_ah->btcoex_hw.mci;\r\nath9k_mci_stomp_audio(sc);\r\nif (!(mci_hw->config & ATH_MCI_CONFIG_CONCUR_TX))\r\nreturn;\r\nif (ah->stats.avgbrssi >= 40) {\r\nif (btcoex->rssi_count < 0)\r\nbtcoex->rssi_count = 0;\r\nif (++btcoex->rssi_count >= ATH_MCI_CONCUR_TX_SWITCH) {\r\nbtcoex->rssi_count = 0;\r\nath9k_mci_set_txpower(sc, false, true);\r\n}\r\n} else {\r\nif (btcoex->rssi_count > 0)\r\nbtcoex->rssi_count = 0;\r\nif (--btcoex->rssi_count <= -ATH_MCI_CONCUR_TX_SWITCH) {\r\nbtcoex->rssi_count = 0;\r\nath9k_mci_set_txpower(sc, false, false);\r\n}\r\n}\r\n}
