static inline void buffer_info_init_left(struct tree_balance *tb,\r\nstruct buffer_info *bi)\r\n{\r\nbi->tb = tb;\r\nbi->bi_bh = tb->L[0];\r\nbi->bi_parent = tb->FL[0];\r\nbi->bi_position = get_left_neighbor_position(tb, 0);\r\n}\r\nstatic inline void buffer_info_init_right(struct tree_balance *tb,\r\nstruct buffer_info *bi)\r\n{\r\nbi->tb = tb;\r\nbi->bi_bh = tb->R[0];\r\nbi->bi_parent = tb->FR[0];\r\nbi->bi_position = get_right_neighbor_position(tb, 0);\r\n}\r\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\r\nstruct buffer_info *bi)\r\n{\r\nbi->tb = tb;\r\nbi->bi_bh = PATH_PLAST_BUFFER(tb->tb_path);\r\nbi->bi_parent = PATH_H_PPARENT(tb->tb_path, 0);\r\nbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\r\n}\r\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\r\nstruct buffer_info *bi,\r\nstruct buffer_head *bh)\r\n{\r\nbi->tb = tb;\r\nbi->bi_bh = bh;\r\nbi->bi_parent = NULL;\r\nbi->bi_position = 0;\r\n}\r\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\r\nstruct buffer_head *bh, int flag)\r\n{\r\njournal_mark_dirty(tb->transaction_handle, bh);\r\n}\r\nstatic void balance_leaf_when_delete_del(struct tree_balance *tb)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint item_pos = PATH_LAST_POSITION(tb->tb_path);\r\nstruct buffer_info bi;\r\n#ifdef CONFIG_REISERFS_CHECK\r\nstruct item_head *ih = item_head(tbS0, item_pos);\r\n#endif\r\nRFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],\r\n"vs-12013: mode Delete, insert size %d, ih to be deleted %h",\r\n-tb->insert_size[0], ih);\r\nbuffer_info_init_tbS0(tb, &bi);\r\nleaf_delete_items(&bi, 0, item_pos, 1, -1);\r\nif (!item_pos && tb->CFL[0]) {\r\nif (B_NR_ITEMS(tbS0)) {\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\r\n} else {\r\nif (!PATH_H_POSITION(tb->tb_path, 1))\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0],\r\nPATH_H_PPARENT(tb->tb_path, 0), 0);\r\n}\r\n}\r\nRFALSE(!item_pos && !tb->CFL[0],\r\n"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0],\r\ntb->L[0]);\r\n}\r\nstatic void balance_leaf_when_delete_cut(struct tree_balance *tb)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint item_pos = PATH_LAST_POSITION(tb->tb_path);\r\nstruct item_head *ih = item_head(tbS0, item_pos);\r\nint pos_in_item = tb->tb_path->pos_in_item;\r\nstruct buffer_info bi;\r\nbuffer_info_init_tbS0(tb, &bi);\r\nif (is_direntry_le_ih(ih)) {\r\ntb->insert_size[0] = -1;\r\nleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\r\n-tb->insert_size[0]);\r\nRFALSE(!item_pos && !pos_in_item && !tb->CFL[0],\r\n"PAP-12030: can not change delimiting key. CFL[0]=%p",\r\ntb->CFL[0]);\r\nif (!item_pos && !pos_in_item && tb->CFL[0])\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\r\n} else {\r\nleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\r\n-tb->insert_size[0]);\r\nRFALSE(!ih_item_len(ih),\r\n"PAP-12035: cut must leave non-zero dynamic "\r\n"length of item");\r\n}\r\n}\r\nstatic int balance_leaf_when_delete_left(struct tree_balance *tb)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tbS0);\r\nif (tb->lnum[0] == -1) {\r\nif (tb->rnum[0] == -1) {\r\nif (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {\r\nif (PATH_H_POSITION(tb->tb_path, 1) == 0 &&\r\n1 < B_NR_ITEMS(tb->FR[0]))\r\nreplace_key(tb, tb->CFL[0],\r\ntb->lkey[0], tb->FR[0], 1);\r\nleaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1,\r\nNULL);\r\nleaf_move_items(LEAF_FROM_R_TO_L, tb,\r\nB_NR_ITEMS(tb->R[0]), -1,\r\nNULL);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreiserfs_invalidate_buffer(tb, tb->R[0]);\r\nreturn 0;\r\n}\r\nleaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);\r\nleaf_move_items(LEAF_FROM_L_TO_R, tb,\r\nB_NR_ITEMS(tb->L[0]), -1, NULL);\r\nreplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreiserfs_invalidate_buffer(tb, tb->L[0]);\r\nreturn -1;\r\n}\r\nRFALSE(tb->rnum[0] != 0,\r\n"PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);\r\nleaf_shift_left(tb, n, -1);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreturn 0;\r\n}\r\nRFALSE((tb->lnum[0] + tb->rnum[0] < n) ||\r\n(tb->lnum[0] + tb->rnum[0] > n + 1),\r\n"PAP-12050: rnum(%d) and lnum(%d) and item "\r\n"number(%d) in S[0] are not consistent",\r\ntb->rnum[0], tb->lnum[0], n);\r\nRFALSE((tb->lnum[0] + tb->rnum[0] == n) &&\r\n(tb->lbytes != -1 || tb->rbytes != -1),\r\n"PAP-12055: bad rbytes (%d)/lbytes (%d) "\r\n"parameters when items are not split",\r\ntb->rbytes, tb->lbytes);\r\nRFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&\r\n(tb->lbytes < 1 || tb->rbytes != -1),\r\n"PAP-12060: bad rbytes (%d)/lbytes (%d) "\r\n"parameters when items are split",\r\ntb->rbytes, tb->lbytes);\r\nleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreturn 0;\r\n}\r\nstatic int balance_leaf_when_delete(struct tree_balance *tb, int flag)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint item_pos = PATH_LAST_POSITION(tb->tb_path);\r\nstruct buffer_info bi;\r\nint n;\r\nstruct item_head *ih;\r\nRFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,\r\n"vs- 12000: level: wrong FR %z", tb->FR[0]);\r\nRFALSE(tb->blknum[0] > 1,\r\n"PAP-12005: tb->blknum == %d, can not be > 1", tb->blknum[0]);\r\nRFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),\r\n"PAP-12010: tree can not be empty");\r\nih = item_head(tbS0, item_pos);\r\nbuffer_info_init_tbS0(tb, &bi);\r\nBUG_ON(flag != M_DELETE && flag != M_CUT);\r\nif (flag == M_DELETE)\r\nbalance_leaf_when_delete_del(tb);\r\nelse\r\nbalance_leaf_when_delete_cut(tb);\r\nn = B_NR_ITEMS(tbS0);\r\nif (tb->lnum[0])\r\nreturn balance_leaf_when_delete_left(tb);\r\nif (tb->rnum[0] == -1) {\r\nleaf_shift_right(tb, n, -1);\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreturn 0;\r\n}\r\nRFALSE(tb->rnum[0],\r\n"PAP-12065: bad rnum parameter must be 0 (%d)", tb->rnum[0]);\r\nreturn 0;\r\n}\r\nstatic unsigned int balance_leaf_insert_left(struct tree_balance *tb,\r\nstruct item_head *const ih,\r\nconst char * const body)\r\n{\r\nint ret;\r\nstruct buffer_info bi;\r\nint n = B_NR_ITEMS(tb->L[0]);\r\nunsigned body_shift_bytes = 0;\r\nif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {\r\nint new_item_len, shift;\r\nint version;\r\nret = leaf_shift_left(tb, tb->lnum[0] - 1, -1);\r\nnew_item_len = ih_item_len(ih) - tb->lbytes;\r\nput_ih_item_len(ih, ih_item_len(ih) - new_item_len);\r\nRFALSE(ih_item_len(ih) <= 0,\r\n"PAP-12080: there is nothing to insert into L[0]: "\r\n"ih_item_len=%d", ih_item_len(ih));\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\r\nmin_t(int, tb->zeroes_num, ih_item_len(ih)));\r\nversion = ih_version(ih);\r\nshift = 0;\r\nif (is_indirect_le_ih(ih))\r\nshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\r\nadd_le_ih_k_offset(ih, tb->lbytes << shift);\r\nput_ih_item_len(ih, new_item_len);\r\nif (tb->lbytes > tb->zeroes_num) {\r\nbody_shift_bytes = tb->lbytes - tb->zeroes_num;\r\ntb->zeroes_num = 0;\r\n} else\r\ntb->zeroes_num -= tb->lbytes;\r\nRFALSE(ih_item_len(ih) <= 0,\r\n"PAP-12085: there is nothing to insert into S[0]: "\r\n"ih_item_len=%d", ih_item_len(ih));\r\n} else {\r\nret = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\r\ntb->zeroes_num);\r\ntb->insert_size[0] = 0;\r\ntb->zeroes_num = 0;\r\n}\r\nreturn body_shift_bytes;\r\n}\r\nstatic void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nint n = B_NR_ITEMS(tb->L[0]);\r\nstruct buffer_info bi;\r\nRFALSE(tb->zeroes_num,\r\n"PAP-12090: invalid parameter in case of a directory");\r\nif (tb->lbytes > tb->pos_in_item) {\r\nstruct item_head *pasted;\r\nint ret, l_pos_in_item = tb->pos_in_item;\r\nret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);\r\nif (ret && !tb->item_pos) {\r\npasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);\r\nl_pos_in_item += ih_entry_count(pasted) -\r\n(tb->lbytes - 1);\r\n}\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\r\nl_pos_in_item, tb->insert_size[0],\r\nbody, tb->zeroes_num);\r\nleaf_paste_entries(&bi, n + tb->item_pos - ret,\r\nl_pos_in_item, 1,\r\n(struct reiserfs_de_head *) body,\r\nbody + DEH_SIZE, tb->insert_size[0]);\r\ntb->insert_size[0] = 0;\r\n} else {\r\nleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\r\n}\r\ntb->pos_in_item -= tb->lbytes;\r\n}\r\nstatic unsigned int balance_leaf_paste_left_shift(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tb->L[0]);\r\nstruct buffer_info bi;\r\nint body_shift_bytes = 0;\r\nif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\r\nbalance_leaf_paste_left_shift_dirent(tb, ih, body);\r\nreturn 0;\r\n}\r\nRFALSE(tb->lbytes <= 0,\r\n"PAP-12095: there is nothing to shift to L[0]. "\r\n"lbytes=%d", tb->lbytes);\r\nRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\r\n"PAP-12100: incorrect position to paste: "\r\n"item_len=%d, pos_in_item=%d",\r\nih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);\r\nif (tb->lbytes >= tb->pos_in_item) {\r\nstruct item_head *tbS0_pos_ih, *tbL0_ih;\r\nstruct item_head *tbS0_0_ih;\r\nstruct reiserfs_key *left_delim_key;\r\nint ret, l_n, version, temp_l;\r\ntbS0_pos_ih = item_head(tbS0, tb->item_pos);\r\ntbS0_0_ih = item_head(tbS0, 0);\r\nl_n = tb->lbytes - tb->pos_in_item;\r\ntb->insert_size[0] -= l_n;\r\nRFALSE(tb->insert_size[0] <= 0,\r\n"PAP-12105: there is nothing to paste into "\r\n"L[0]. insert_size=%d", tb->insert_size[0]);\r\nret = leaf_shift_left(tb, tb->lnum[0],\r\nih_item_len(tbS0_pos_ih));\r\ntbL0_ih = item_head(tb->L[0], n + tb->item_pos - ret);\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\r\nih_item_len(tbL0_ih), l_n, body,\r\nmin_t(int, l_n, tb->zeroes_num));\r\ntemp_l = l_n;\r\nRFALSE(ih_item_len(tbS0_0_ih),\r\n"PAP-12106: item length must be 0");\r\nRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\r\nleaf_key(tb->L[0], n + tb->item_pos - ret)),\r\n"PAP-12107: items must be of the same file");\r\nif (is_indirect_le_ih(tbL0_ih)) {\r\nint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\r\ntemp_l = l_n << shift;\r\n}\r\nversion = ih_version(tbS0_0_ih);\r\nadd_le_key_k_offset(version, &tbS0_0_ih->ih_key, temp_l);\r\nleft_delim_key = internal_key(tb->CFL[0], tb->lkey[0]);\r\nadd_le_key_k_offset(version, left_delim_key, temp_l);\r\nif (l_n > tb->zeroes_num) {\r\nbody_shift_bytes = l_n - tb->zeroes_num;\r\ntb->zeroes_num = 0;\r\n} else\r\ntb->zeroes_num -= l_n;\r\ntb->pos_in_item = 0;\r\nRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\r\nleaf_key(tb->L[0],\r\nB_NR_ITEMS(tb->L[0]) - 1)) ||\r\n!op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size) ||\r\n!op_is_left_mergeable(left_delim_key, tbS0->b_size),\r\n"PAP-12120: item must be merge-able with left "\r\n"neighboring item");\r\n} else {\r\ntb->pos_in_item -= tb->lbytes;\r\nRFALSE(tb->pos_in_item <= 0,\r\n"PAP-12125: no place for paste. pos_in_item=%d",\r\ntb->pos_in_item);\r\nleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\r\n}\r\nreturn body_shift_bytes;\r\n}\r\nstatic void balance_leaf_paste_left_whole(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tb->L[0]);\r\nstruct buffer_info bi;\r\nstruct item_head *pasted;\r\nint ret;\r\nif (!tb->item_pos &&\r\nop_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {\r\npasted = item_head(tb->L[0], n - 1);\r\nif (is_direntry_le_ih(pasted))\r\ntb->pos_in_item += ih_entry_count(pasted);\r\nelse\r\ntb->pos_in_item += ih_item_len(pasted);\r\n}\r\nret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);\r\nbuffer_info_init_left(tb, &bi);\r\nleaf_paste_in_buffer(&bi, n + tb->item_pos - ret, tb->pos_in_item,\r\ntb->insert_size[0], body, tb->zeroes_num);\r\npasted = item_head(tb->L[0], n + tb->item_pos - ret);\r\nif (is_direntry_le_ih(pasted))\r\nleaf_paste_entries(&bi, n + tb->item_pos - ret,\r\ntb->pos_in_item, 1,\r\n(struct reiserfs_de_head *)body,\r\nbody + DEH_SIZE, tb->insert_size[0]);\r\nif (is_indirect_le_ih(pasted))\r\nset_ih_free_space(pasted, 0);\r\ntb->insert_size[0] = 0;\r\ntb->zeroes_num = 0;\r\n}\r\nstatic unsigned int balance_leaf_paste_left(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)\r\nreturn balance_leaf_paste_left_shift(tb, ih, body);\r\nelse\r\nbalance_leaf_paste_left_whole(tb, ih, body);\r\nreturn 0;\r\n}\r\nstatic unsigned int balance_leaf_left(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body, int flag)\r\n{\r\nif (tb->lnum[0] <= 0)\r\nreturn 0;\r\nif (tb->item_pos < tb->lnum[0]) {\r\nBUG_ON(flag != M_INSERT && flag != M_PASTE);\r\nif (flag == M_INSERT)\r\nreturn balance_leaf_insert_left(tb, ih, body);\r\nelse\r\nreturn balance_leaf_paste_left(tb, ih, body);\r\n} else\r\nleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\r\nreturn 0;\r\n}\r\nstatic void balance_leaf_insert_right(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tbS0);\r\nstruct buffer_info bi;\r\nint ret;\r\nif (n - tb->rnum[0] >= tb->item_pos) {\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\r\nreturn;\r\n}\r\nif (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {\r\nloff_t old_key_comp, old_len, r_zeroes_number;\r\nconst char *r_body;\r\nint version, shift;\r\nloff_t offset;\r\nleaf_shift_right(tb, tb->rnum[0] - 1, -1);\r\nversion = ih_version(ih);\r\nold_key_comp = le_ih_k_offset(ih);\r\nold_len = ih_item_len(ih);\r\nshift = 0;\r\nif (is_indirect_le_ih(ih))\r\nshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\r\noffset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << shift);\r\nset_le_ih_k_offset(ih, offset);\r\nput_ih_item_len(ih, tb->rbytes);\r\nbuffer_info_init_right(tb, &bi);\r\nif ((old_len - tb->rbytes) > tb->zeroes_num) {\r\nr_zeroes_number = 0;\r\nr_body = body + (old_len - tb->rbytes) - tb->zeroes_num;\r\n} else {\r\nr_body = body;\r\nr_zeroes_number = tb->zeroes_num -\r\n(old_len - tb->rbytes);\r\ntb->zeroes_num -= r_zeroes_number;\r\n}\r\nleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\r\nreplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\r\nset_le_ih_k_offset(ih, old_key_comp);\r\nput_ih_item_len(ih, old_len - tb->rbytes);\r\ntb->insert_size[0] -= tb->rbytes;\r\n} else {\r\nret = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);\r\nbuffer_info_init_right(tb, &bi);\r\nleaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,\r\nih, body, tb->zeroes_num);\r\nif (tb->item_pos - n + tb->rnum[0] - 1 == 0)\r\nreplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\r\ntb->zeroes_num = tb->insert_size[0] = 0;\r\n}\r\n}\r\nstatic void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nstruct buffer_info bi;\r\nint entry_count;\r\nRFALSE(tb->zeroes_num,\r\n"PAP-12145: invalid parameter in case of a directory");\r\nentry_count = ih_entry_count(item_head(tbS0, tb->item_pos));\r\nif (entry_count - tb->rbytes < tb->pos_in_item) {\r\nint paste_entry_position;\r\nRFALSE(tb->rbytes - 1 >= entry_count || !tb->insert_size[0],\r\n"PAP-12150: no enough of entries to shift to R[0]: "\r\n"rbytes=%d, entry_count=%d", tb->rbytes, entry_count);\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);\r\npaste_entry_position = tb->pos_in_item - entry_count +\r\ntb->rbytes - 1;\r\nbuffer_info_init_right(tb, &bi);\r\nleaf_paste_in_buffer(&bi, 0, paste_entry_position,\r\ntb->insert_size[0], body, tb->zeroes_num);\r\nleaf_paste_entries(&bi, 0, paste_entry_position, 1,\r\n(struct reiserfs_de_head *) body,\r\nbody + DEH_SIZE, tb->insert_size[0]);\r\nif (paste_entry_position == 0)\r\nreplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\r\ntb->insert_size[0] = 0;\r\ntb->pos_in_item++;\r\n} else {\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\r\n}\r\n}\r\nstatic void balance_leaf_paste_right_shift(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n_shift, n_rem, r_zeroes_number, version;\r\nunsigned long temp_rem;\r\nconst char *r_body;\r\nstruct buffer_info bi;\r\nif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\r\nbalance_leaf_paste_right_shift_dirent(tb, ih, body);\r\nreturn;\r\n}\r\nn_shift = tb->rbytes - tb->insert_size[0];\r\nif (n_shift < 0)\r\nn_shift = 0;\r\nRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\r\n"PAP-12155: invalid position to paste. ih_item_len=%d, "\r\n"pos_in_item=%d", tb->pos_in_item,\r\nih_item_len(item_head(tbS0, tb->item_pos)));\r\nleaf_shift_right(tb, tb->rnum[0], n_shift);\r\nn_rem = tb->insert_size[0] - tb->rbytes;\r\nif (n_rem < 0)\r\nn_rem = 0;\r\ntemp_rem = n_rem;\r\nversion = ih_version(item_head(tb->R[0], 0));\r\nif (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {\r\nint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\r\ntemp_rem = n_rem << shift;\r\n}\r\nadd_le_key_k_offset(version, leaf_key(tb->R[0], 0), temp_rem);\r\nadd_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),\r\ntemp_rem);\r\ndo_balance_mark_internal_dirty(tb, tb->CFR[0], 0);\r\nbuffer_info_init_right(tb, &bi);\r\nif (n_rem > tb->zeroes_num) {\r\nr_zeroes_number = 0;\r\nr_body = body + n_rem - tb->zeroes_num;\r\n} else {\r\nr_body = body;\r\nr_zeroes_number = tb->zeroes_num - n_rem;\r\ntb->zeroes_num -= r_zeroes_number;\r\n}\r\nleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\r\nr_body, r_zeroes_number);\r\nif (is_indirect_le_ih(item_head(tb->R[0], 0)))\r\nset_ih_free_space(item_head(tb->R[0], 0), 0);\r\ntb->insert_size[0] = n_rem;\r\nif (!n_rem)\r\ntb->pos_in_item++;\r\n}\r\nstatic void balance_leaf_paste_right_whole(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tbS0);\r\nstruct item_head *pasted;\r\nstruct buffer_info bi;\r\nbuffer_info_init_right(tb, &bi);\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\r\nif (tb->pos_in_item >= 0) {\r\nbuffer_info_init_right(tb, &bi);\r\nleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0],\r\ntb->pos_in_item, tb->insert_size[0], body,\r\ntb->zeroes_num);\r\n}\r\npasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);\r\nif (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {\r\nleaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],\r\ntb->pos_in_item, 1,\r\n(struct reiserfs_de_head *)body,\r\nbody + DEH_SIZE, tb->insert_size[0]);\r\nif (!tb->pos_in_item) {\r\nRFALSE(tb->item_pos - n + tb->rnum[0],\r\n"PAP-12165: directory item must be first "\r\n"item of node when pasting is in 0th position");\r\nreplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\r\n}\r\n}\r\nif (is_indirect_le_ih(pasted))\r\nset_ih_free_space(pasted, 0);\r\ntb->zeroes_num = tb->insert_size[0] = 0;\r\n}\r\nstatic void balance_leaf_paste_right(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tbS0);\r\nif (n - tb->rnum[0] > tb->item_pos) {\r\nleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\r\nreturn;\r\n}\r\nif (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1)\r\nbalance_leaf_paste_right_shift(tb, ih, body);\r\nelse\r\nbalance_leaf_paste_right_whole(tb, ih, body);\r\n}\r\nstatic void balance_leaf_right(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body, int flag)\r\n{\r\nif (tb->rnum[0] <= 0)\r\nreturn;\r\nBUG_ON(flag != M_INSERT && flag != M_PASTE);\r\nif (flag == M_INSERT)\r\nbalance_leaf_insert_right(tb, ih, body);\r\nelse\r\nbalance_leaf_paste_right(tb, ih, body);\r\n}\r\nstatic void balance_leaf_new_nodes_insert(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr,\r\nint i)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tbS0);\r\nstruct buffer_info bi;\r\nint shift;\r\nif (n - tb->snum[i] >= tb->item_pos) {\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\r\ntb->snum[i], tb->sbytes[i], tb->S_new[i]);\r\nreturn;\r\n}\r\nif (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {\r\nint old_key_comp, old_len, r_zeroes_number;\r\nconst char *r_body;\r\nint version;\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i] - 1, -1,\r\ntb->S_new[i]);\r\nversion = ih_version(ih);\r\nold_key_comp = le_ih_k_offset(ih);\r\nold_len = ih_item_len(ih);\r\nshift = 0;\r\nif (is_indirect_le_ih(ih))\r\nshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\r\nset_le_ih_k_offset(ih,\r\nle_ih_k_offset(ih) +\r\n((old_len - tb->sbytes[i]) << shift));\r\nput_ih_item_len(ih, tb->sbytes[i]);\r\nbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\r\nif ((old_len - tb->sbytes[i]) > tb->zeroes_num) {\r\nr_zeroes_number = 0;\r\nr_body = body + (old_len - tb->sbytes[i]) -\r\ntb->zeroes_num;\r\n} else {\r\nr_body = body;\r\nr_zeroes_number = tb->zeroes_num - (old_len -\r\ntb->sbytes[i]);\r\ntb->zeroes_num -= r_zeroes_number;\r\n}\r\nleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\r\nset_le_ih_k_offset(ih, old_key_comp);\r\nput_ih_item_len(ih, old_len - tb->sbytes[i]);\r\ntb->insert_size[0] -= tb->sbytes[i];\r\n} else {\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\r\ntb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);\r\nbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\r\nleaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,\r\nih, body, tb->zeroes_num);\r\ntb->zeroes_num = tb->insert_size[0] = 0;\r\n}\r\n}\r\nstatic void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr,\r\nint i)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\r\nint entry_count = ih_entry_count(aux_ih);\r\nstruct buffer_info bi;\r\nif (entry_count - tb->sbytes[i] < tb->pos_in_item &&\r\ntb->pos_in_item <= entry_count) {\r\nRFALSE(!tb->insert_size[0],\r\n"PAP-12215: insert_size is already 0");\r\nRFALSE(tb->sbytes[i] - 1 >= entry_count,\r\n"PAP-12220: there are no so much entries (%d), only %d",\r\ntb->sbytes[i] - 1, entry_count);\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\r\ntb->sbytes[i] - 1, tb->S_new[i]);\r\nbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\r\nleaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count +\r\ntb->sbytes[i] - 1, tb->insert_size[0],\r\nbody, tb->zeroes_num);\r\nleaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count +\r\ntb->sbytes[i] - 1, 1,\r\n(struct reiserfs_de_head *) body,\r\nbody + DEH_SIZE, tb->insert_size[0]);\r\ntb->insert_size[0] = 0;\r\ntb->pos_in_item++;\r\n} else {\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\r\ntb->sbytes[i], tb->S_new[i]);\r\n}\r\n}\r\nstatic void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr,\r\nint i)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\r\nint n_shift, n_rem, r_zeroes_number, shift;\r\nconst char *r_body;\r\nstruct item_head *tmp;\r\nstruct buffer_info bi;\r\nRFALSE(ih, "PAP-12210: ih must be 0");\r\nif (is_direntry_le_ih(aux_ih)) {\r\nbalance_leaf_new_nodes_paste_dirent(tb, ih, body, insert_key,\r\ninsert_ptr, i);\r\nreturn;\r\n}\r\nRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) ||\r\ntb->insert_size[0] <= 0,\r\n"PAP-12225: item too short or insert_size <= 0");\r\nn_shift = tb->sbytes[i] - tb->insert_size[0];\r\nif (n_shift < 0)\r\nn_shift = 0;\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift,\r\ntb->S_new[i]);\r\nn_rem = tb->insert_size[0] - tb->sbytes[i];\r\nif (n_rem < 0)\r\nn_rem = 0;\r\nbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\r\nif (n_rem > tb->zeroes_num) {\r\nr_zeroes_number = 0;\r\nr_body = body + n_rem - tb->zeroes_num;\r\n} else {\r\nr_body = body;\r\nr_zeroes_number = tb->zeroes_num - n_rem;\r\ntb->zeroes_num -= r_zeroes_number;\r\n}\r\nleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\r\nr_body, r_zeroes_number);\r\ntmp = item_head(tb->S_new[i], 0);\r\nshift = 0;\r\nif (is_indirect_le_ih(tmp)) {\r\nset_ih_free_space(tmp, 0);\r\nshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\r\n}\r\nadd_le_ih_k_offset(tmp, n_rem << shift);\r\ntb->insert_size[0] = n_rem;\r\nif (!n_rem)\r\ntb->pos_in_item++;\r\n}\r\nstatic void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr,\r\nint i)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tbS0);\r\nint leaf_mi;\r\nstruct item_head *pasted;\r\nstruct buffer_info bi;\r\n#ifdef CONFIG_REISERFS_CHECK\r\nstruct item_head *ih_check = item_head(tbS0, tb->item_pos);\r\nif (!is_direntry_le_ih(ih_check) &&\r\n(tb->pos_in_item != ih_item_len(ih_check) ||\r\ntb->insert_size[0] <= 0))\r\nreiserfs_panic(tb->tb_sb,\r\n"PAP-12235",\r\n"pos_in_item must be equal to ih_item_len");\r\n#endif\r\nleaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\r\ntb->sbytes[i], tb->S_new[i]);\r\nRFALSE(leaf_mi,\r\n"PAP-12240: unexpected value returned by leaf_move_items (%d)",\r\nleaf_mi);\r\nbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\r\nleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->snum[i],\r\ntb->pos_in_item, tb->insert_size[0],\r\nbody, tb->zeroes_num);\r\npasted = item_head(tb->S_new[i], tb->item_pos - n +\r\ntb->snum[i]);\r\nif (is_direntry_le_ih(pasted))\r\nleaf_paste_entries(&bi, tb->item_pos - n + tb->snum[i],\r\ntb->pos_in_item, 1,\r\n(struct reiserfs_de_head *)body,\r\nbody + DEH_SIZE, tb->insert_size[0]);\r\nif (is_indirect_le_ih(pasted))\r\nset_ih_free_space(pasted, 0);\r\ntb->zeroes_num = tb->insert_size[0] = 0;\r\n}\r\nstatic void balance_leaf_new_nodes_paste(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr,\r\nint i)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nint n = B_NR_ITEMS(tbS0);\r\nif (n - tb->snum[i] > tb->item_pos) {\r\nleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\r\ntb->snum[i], tb->sbytes[i], tb->S_new[i]);\r\nreturn;\r\n}\r\nif (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1)\r\nbalance_leaf_new_nodes_paste_shift(tb, ih, body, insert_key,\r\ninsert_ptr, i);\r\nelse\r\nbalance_leaf_new_nodes_paste_whole(tb, ih, body, insert_key,\r\ninsert_ptr, i);\r\n}\r\nstatic void balance_leaf_new_nodes(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr,\r\nint flag)\r\n{\r\nint i;\r\nfor (i = tb->blknum[0] - 2; i >= 0; i--) {\r\nBUG_ON(flag != M_INSERT && flag != M_PASTE);\r\nRFALSE(!tb->snum[i],\r\n"PAP-12200: snum[%d] == %d. Must be > 0", i,\r\ntb->snum[i]);\r\ntb->S_new[i] = get_FEB(tb);\r\nset_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);\r\nif (flag == M_INSERT)\r\nbalance_leaf_new_nodes_insert(tb, ih, body, insert_key,\r\ninsert_ptr, i);\r\nelse\r\nbalance_leaf_new_nodes_paste(tb, ih, body, insert_key,\r\ninsert_ptr, i);\r\nmemcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);\r\ninsert_ptr[i] = tb->S_new[i];\r\nRFALSE(!buffer_journaled(tb->S_new[i])\r\n|| buffer_journal_dirty(tb->S_new[i])\r\n|| buffer_dirty(tb->S_new[i]),\r\n"PAP-12247: S_new[%d] : (%b)",\r\ni, tb->S_new[i]);\r\n}\r\n}\r\nstatic void balance_leaf_finish_node_insert(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nstruct buffer_info bi;\r\nbuffer_info_init_tbS0(tb, &bi);\r\nleaf_insert_into_buf(&bi, tb->item_pos, ih, body, tb->zeroes_num);\r\nif (tb->item_pos == 0) {\r\nif (tb->CFL[0])\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\r\n}\r\n}\r\nstatic void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nstruct item_head *pasted = item_head(tbS0, tb->item_pos);\r\nstruct buffer_info bi;\r\nif (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {\r\nRFALSE(!tb->insert_size[0],\r\n"PAP-12260: insert_size is 0 already");\r\nbuffer_info_init_tbS0(tb, &bi);\r\nleaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,\r\ntb->insert_size[0], body, tb->zeroes_num);\r\nleaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,\r\n(struct reiserfs_de_head *)body,\r\nbody + DEH_SIZE, tb->insert_size[0]);\r\nif (!tb->item_pos && !tb->pos_in_item) {\r\nRFALSE(!tb->CFL[0] || !tb->L[0],\r\n"PAP-12270: CFL[0]/L[0] must be specified");\r\nif (tb->CFL[0])\r\nreplace_key(tb, tb->CFL[0], tb->lkey[0],\r\ntbS0, 0);\r\n}\r\ntb->insert_size[0] = 0;\r\n}\r\n}\r\nstatic void balance_leaf_finish_node_paste(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nstruct buffer_info bi;\r\nstruct item_head *pasted = item_head(tbS0, tb->item_pos);\r\nif (is_direntry_le_ih(pasted)) {\r\nbalance_leaf_finish_node_paste_dirent(tb, ih, body);\r\nreturn;\r\n}\r\nif (tb->pos_in_item == ih_item_len(pasted)) {\r\nRFALSE(tb->insert_size[0] <= 0,\r\n"PAP-12275: insert size must not be %d",\r\ntb->insert_size[0]);\r\nbuffer_info_init_tbS0(tb, &bi);\r\nleaf_paste_in_buffer(&bi, tb->item_pos,\r\ntb->pos_in_item, tb->insert_size[0], body,\r\ntb->zeroes_num);\r\nif (is_indirect_le_ih(pasted))\r\nset_ih_free_space(pasted, 0);\r\ntb->insert_size[0] = 0;\r\n}\r\n#ifdef CONFIG_REISERFS_CHECK\r\nelse if (tb->insert_size[0]) {\r\nprint_cur_tb("12285");\r\nreiserfs_panic(tb->tb_sb, "PAP-12285",\r\n"insert_size must be 0 (%d)", tb->insert_size[0]);\r\n}\r\n#endif\r\n}\r\nstatic void balance_leaf_finish_node(struct tree_balance *tb,\r\nstruct item_head * const ih,\r\nconst char * const body, int flag)\r\n{\r\nif (0 <= tb->item_pos && tb->item_pos < tb->s0num) {\r\nif (flag == M_INSERT)\r\nbalance_leaf_finish_node_insert(tb, ih, body);\r\nelse\r\nbalance_leaf_finish_node_paste(tb, ih, body);\r\n}\r\n}\r\nstatic int balance_leaf(struct tree_balance *tb, struct item_head *ih,\r\nconst char *body, int flag,\r\nstruct item_head *insert_key,\r\nstruct buffer_head **insert_ptr)\r\n{\r\nstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\r\nPROC_INFO_INC(tb->tb_sb, balance_at[0]);\r\nif (tb->insert_size[0] < 0)\r\nreturn balance_leaf_when_delete(tb, flag);\r\ntb->item_pos = PATH_LAST_POSITION(tb->tb_path),\r\ntb->pos_in_item = tb->tb_path->pos_in_item,\r\ntb->zeroes_num = 0;\r\nif (flag == M_INSERT && !body)\r\ntb->zeroes_num = ih_item_len(ih);\r\nif (flag != M_INSERT\r\n&& is_indirect_le_ih(item_head(tbS0, tb->item_pos)))\r\ntb->pos_in_item *= UNFM_P_SIZE;\r\nbody += balance_leaf_left(tb, ih, body, flag);\r\ntb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));\r\nbalance_leaf_right(tb, ih, body, flag);\r\nRFALSE(tb->blknum[0] > 3,\r\n"PAP-12180: blknum can not be %d. It must be <= 3", tb->blknum[0]);\r\nRFALSE(tb->blknum[0] < 0,\r\n"PAP-12185: blknum can not be %d. It must be >= 0", tb->blknum[0]);\r\nif (tb->blknum[0] == 0) {\r\nRFALSE(!tb->lnum[0] || !tb->rnum[0],\r\n"PAP-12190: lnum and rnum must not be zero");\r\nif (tb->CFL[0]) {\r\nif (!tb->CFR[0])\r\nreiserfs_panic(tb->tb_sb, "vs-12195",\r\n"CFR not initialized");\r\ncopy_key(internal_key(tb->CFL[0], tb->lkey[0]),\r\ninternal_key(tb->CFR[0], tb->rkey[0]));\r\ndo_balance_mark_internal_dirty(tb, tb->CFL[0], 0);\r\n}\r\nreiserfs_invalidate_buffer(tb, tbS0);\r\nreturn 0;\r\n}\r\nbalance_leaf_new_nodes(tb, ih, body, insert_key, insert_ptr, flag);\r\nbalance_leaf_finish_node(tb, ih, body, flag);\r\n#ifdef CONFIG_REISERFS_CHECK\r\nif (flag == M_PASTE && tb->insert_size[0]) {\r\nprint_cur_tb("12290");\r\nreiserfs_panic(tb->tb_sb,\r\n"PAP-12290", "insert_size is still not 0 (%d)",\r\ntb->insert_size[0]);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid make_empty_node(struct buffer_info *bi)\r\n{\r\nstruct block_head *blkh;\r\nRFALSE(bi->bi_bh == NULL, "PAP-12295: pointer to the buffer is NULL");\r\nblkh = B_BLK_HEAD(bi->bi_bh);\r\nset_blkh_nr_item(blkh, 0);\r\nset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\r\nif (bi->bi_parent)\r\nB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\r\n}\r\nstruct buffer_head *get_FEB(struct tree_balance *tb)\r\n{\r\nint i;\r\nstruct buffer_info bi;\r\nfor (i = 0; i < MAX_FEB_SIZE; i++)\r\nif (tb->FEB[i] != NULL)\r\nbreak;\r\nif (i == MAX_FEB_SIZE)\r\nreiserfs_panic(tb->tb_sb, "vs-12300", "FEB list is empty");\r\nbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\r\nmake_empty_node(&bi);\r\nset_buffer_uptodate(tb->FEB[i]);\r\ntb->used[i] = tb->FEB[i];\r\ntb->FEB[i] = NULL;\r\nreturn tb->used[i];\r\n}\r\nstatic void store_thrown(struct tree_balance *tb, struct buffer_head *bh)\r\n{\r\nint i;\r\nif (buffer_dirty(bh))\r\nreiserfs_warning(tb->tb_sb, "reiserfs-12320",\r\n"called with dirty buffer");\r\nfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++)\r\nif (!tb->thrown[i]) {\r\ntb->thrown[i] = bh;\r\nget_bh(bh);\r\nreturn;\r\n}\r\nreiserfs_warning(tb->tb_sb, "reiserfs-12321",\r\n"too many thrown buffers");\r\n}\r\nstatic void free_thrown(struct tree_balance *tb)\r\n{\r\nint i;\r\nb_blocknr_t blocknr;\r\nfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++) {\r\nif (tb->thrown[i]) {\r\nblocknr = tb->thrown[i]->b_blocknr;\r\nif (buffer_dirty(tb->thrown[i]))\r\nreiserfs_warning(tb->tb_sb, "reiserfs-12322",\r\n"called with dirty buffer %d",\r\nblocknr);\r\nbrelse(tb->thrown[i]);\r\nreiserfs_free_block(tb->transaction_handle, NULL,\r\nblocknr, 0);\r\n}\r\n}\r\n}\r\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\r\n{\r\nstruct block_head *blkh;\r\nblkh = B_BLK_HEAD(bh);\r\nset_blkh_level(blkh, FREE_LEVEL);\r\nset_blkh_nr_item(blkh, 0);\r\nclear_buffer_dirty(bh);\r\nstore_thrown(tb, bh);\r\n}\r\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\r\nstruct buffer_head *src, int n_src)\r\n{\r\nRFALSE(dest == NULL || src == NULL,\r\n"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)",\r\nsrc, dest);\r\nRFALSE(!B_IS_KEYS_LEVEL(dest),\r\n"vs-12310: invalid level (%z) for destination buffer. dest must be leaf",\r\ndest);\r\nRFALSE(n_dest < 0 || n_src < 0,\r\n"vs-12315: src(%d) or dest(%d) key number < 0", n_src, n_dest);\r\nRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\r\n"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big",\r\nn_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\r\nif (B_IS_ITEMS_LEVEL(src))\r\nmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\r\nKEY_SIZE);\r\nelse\r\nmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\r\nKEY_SIZE);\r\ndo_balance_mark_internal_dirty(tb, dest, 0);\r\n}\r\nint get_left_neighbor_position(struct tree_balance *tb, int h)\r\n{\r\nint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\nRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\r\n"vs-12325: FL[%d](%p) or F[%d](%p) does not exist",\r\nh, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\r\nif (Sh_position == 0)\r\nreturn B_NR_ITEMS(tb->FL[h]);\r\nelse\r\nreturn Sh_position - 1;\r\n}\r\nint get_right_neighbor_position(struct tree_balance *tb, int h)\r\n{\r\nint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\r\nRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\r\n"vs-12330: F[%d](%p) or FR[%d](%p) does not exist",\r\nh, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\r\nif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\r\nreturn 0;\r\nelse\r\nreturn Sh_position + 1;\r\n}\r\nstatic void check_internal_node(struct super_block *s, struct buffer_head *bh,\r\nchar *mes)\r\n{\r\nstruct disk_child *dc;\r\nint i;\r\nRFALSE(!bh, "PAP-12336: bh == 0");\r\nif (!bh || !B_IS_IN_TREE(bh))\r\nreturn;\r\nRFALSE(!buffer_dirty(bh) &&\r\n!(buffer_journaled(bh) || buffer_journal_dirty(bh)),\r\n"PAP-12337: buffer (%b) must be dirty", bh);\r\ndc = B_N_CHILD(bh, 0);\r\nfor (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {\r\nif (!is_reusable(s, dc_block_number(dc), 1)) {\r\nprint_cur_tb(mes);\r\nreiserfs_panic(s, "PAP-12338",\r\n"invalid child pointer %y in %b",\r\ndc, bh);\r\n}\r\n}\r\n}\r\nstatic int locked_or_not_in_tree(struct tree_balance *tb,\r\nstruct buffer_head *bh, char *which)\r\n{\r\nif ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||\r\n!B_IS_IN_TREE(bh)) {\r\nreiserfs_warning(tb->tb_sb, "vs-12339", "%s (%b)", which, bh);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_before_balancing(struct tree_balance *tb)\r\n{\r\nint retval = 0;\r\nif (REISERFS_SB(tb->tb_sb)->cur_tb) {\r\nreiserfs_panic(tb->tb_sb, "vs-12335", "suspect that schedule "\r\n"occurred based on cur_tb not being null at "\r\n"this point in code. do_balance cannot properly "\r\n"handle concurrent tree accesses on a same "\r\n"mount point.");\r\n}\r\nif (tb->lnum[0]) {\r\nretval |= locked_or_not_in_tree(tb, tb->L[0], "L[0]");\r\nretval |= locked_or_not_in_tree(tb, tb->FL[0], "FL[0]");\r\nretval |= locked_or_not_in_tree(tb, tb->CFL[0], "CFL[0]");\r\ncheck_leaf(tb->L[0]);\r\n}\r\nif (tb->rnum[0]) {\r\nretval |= locked_or_not_in_tree(tb, tb->R[0], "R[0]");\r\nretval |= locked_or_not_in_tree(tb, tb->FR[0], "FR[0]");\r\nretval |= locked_or_not_in_tree(tb, tb->CFR[0], "CFR[0]");\r\ncheck_leaf(tb->R[0]);\r\n}\r\nretval |= locked_or_not_in_tree(tb, PATH_PLAST_BUFFER(tb->tb_path),\r\n"S[0]");\r\ncheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\r\nreturn retval;\r\n}\r\nstatic void check_after_balance_leaf(struct tree_balance *tb)\r\n{\r\nif (tb->lnum[0]) {\r\nif (B_FREE_SPACE(tb->L[0]) !=\r\nMAX_CHILD_SIZE(tb->L[0]) -\r\ndc_size(B_N_CHILD\r\n(tb->FL[0], get_left_neighbor_position(tb, 0)))) {\r\nprint_cur_tb("12221");\r\nreiserfs_panic(tb->tb_sb, "PAP-12355",\r\n"shift to left was incorrect");\r\n}\r\n}\r\nif (tb->rnum[0]) {\r\nif (B_FREE_SPACE(tb->R[0]) !=\r\nMAX_CHILD_SIZE(tb->R[0]) -\r\ndc_size(B_N_CHILD\r\n(tb->FR[0], get_right_neighbor_position(tb, 0)))) {\r\nprint_cur_tb("12222");\r\nreiserfs_panic(tb->tb_sb, "PAP-12360",\r\n"shift to right was incorrect");\r\n}\r\n}\r\nif (PATH_H_PBUFFER(tb->tb_path, 1) &&\r\n(B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0)) !=\r\n(MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\r\ndc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\r\nPATH_H_POSITION(tb->tb_path, 1)))))) {\r\nint left = B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0));\r\nint right = (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\r\ndc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\r\nPATH_H_POSITION(tb->tb_path,\r\n1))));\r\nprint_cur_tb("12223");\r\nreiserfs_warning(tb->tb_sb, "reiserfs-12363",\r\n"B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "\r\n"MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",\r\nleft,\r\nMAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)),\r\nPATH_H_PBUFFER(tb->tb_path, 1),\r\nPATH_H_POSITION(tb->tb_path, 1),\r\ndc_size(B_N_CHILD\r\n(PATH_H_PBUFFER(tb->tb_path, 1),\r\nPATH_H_POSITION(tb->tb_path, 1))),\r\nright);\r\nreiserfs_panic(tb->tb_sb, "PAP-12365", "S is incorrect");\r\n}\r\n}\r\nstatic void check_leaf_level(struct tree_balance *tb)\r\n{\r\ncheck_leaf(tb->L[0]);\r\ncheck_leaf(tb->R[0]);\r\ncheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\r\n}\r\nstatic void check_internal_levels(struct tree_balance *tb)\r\n{\r\nint h;\r\nfor (h = 1; tb->insert_size[h]; h++) {\r\ncheck_internal_node(tb->tb_sb, PATH_H_PBUFFER(tb->tb_path, h),\r\n"BAD BUFFER ON PATH");\r\nif (tb->lnum[h])\r\ncheck_internal_node(tb->tb_sb, tb->L[h], "BAD L");\r\nif (tb->rnum[h])\r\ncheck_internal_node(tb->tb_sb, tb->R[h], "BAD R");\r\n}\r\n}\r\nstatic inline void do_balance_starts(struct tree_balance *tb)\r\n{\r\nRFALSE(check_before_balancing(tb), "PAP-12340: locked buffers in TB");\r\n#ifdef CONFIG_REISERFS_CHECK\r\nREISERFS_SB(tb->tb_sb)->cur_tb = tb;\r\n#endif\r\n}\r\nstatic inline void do_balance_completed(struct tree_balance *tb)\r\n{\r\n#ifdef CONFIG_REISERFS_CHECK\r\ncheck_leaf_level(tb);\r\ncheck_internal_levels(tb);\r\nREISERFS_SB(tb->tb_sb)->cur_tb = NULL;\r\n#endif\r\nREISERFS_SB(tb->tb_sb)->s_do_balance++;\r\nunfix_nodes(tb);\r\nfree_thrown(tb);\r\n}\r\nvoid do_balance(struct tree_balance *tb, struct item_head *ih,\r\nconst char *body, int flag)\r\n{\r\nint child_pos;\r\nint h;\r\nstruct item_head insert_key[2];\r\nstruct buffer_head *insert_ptr[2];\r\ntb->tb_mode = flag;\r\ntb->need_balance_dirty = 0;\r\nif (FILESYSTEM_CHANGED_TB(tb)) {\r\nreiserfs_panic(tb->tb_sb, "clm-6000", "fs generation has "\r\n"changed");\r\n}\r\nif (!tb->insert_size[0]) {\r\nreiserfs_warning(tb->tb_sb, "PAP-12350",\r\n"insert_size == 0, mode == %c", flag);\r\nunfix_nodes(tb);\r\nreturn;\r\n}\r\natomic_inc(&fs_generation(tb->tb_sb));\r\ndo_balance_starts(tb);\r\nchild_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +\r\nbalance_leaf(tb, ih, body, flag, insert_key, insert_ptr);\r\n#ifdef CONFIG_REISERFS_CHECK\r\ncheck_after_balance_leaf(tb);\r\n#endif\r\nfor (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)\r\nchild_pos = balance_internal(tb, h, child_pos, insert_key,\r\ninsert_ptr);\r\ndo_balance_completed(tb);\r\n}
