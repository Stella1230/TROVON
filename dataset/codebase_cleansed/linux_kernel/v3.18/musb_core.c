static inline struct musb *dev_to_musb(struct device *dev)\r\n{\r\nreturn dev_get_drvdata(dev);\r\n}\r\nstatic int musb_ulpi_read(struct usb_phy *phy, u32 offset)\r\n{\r\nvoid __iomem *addr = phy->io_priv;\r\nint i = 0;\r\nu8 r;\r\nu8 power;\r\nint ret;\r\npm_runtime_get_sync(phy->io_dev);\r\npower = musb_readb(addr, MUSB_POWER);\r\npower &= ~MUSB_POWER_SUSPENDM;\r\nmusb_writeb(addr, MUSB_POWER, power);\r\nmusb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);\r\nmusb_writeb(addr, MUSB_ULPI_REG_CONTROL,\r\nMUSB_ULPI_REG_REQ | MUSB_ULPI_RDN_WR);\r\nwhile (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)\r\n& MUSB_ULPI_REG_CMPLT)) {\r\ni++;\r\nif (i == 10000) {\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\n}\r\nr = musb_readb(addr, MUSB_ULPI_REG_CONTROL);\r\nr &= ~MUSB_ULPI_REG_CMPLT;\r\nmusb_writeb(addr, MUSB_ULPI_REG_CONTROL, r);\r\nret = musb_readb(addr, MUSB_ULPI_REG_DATA);\r\nout:\r\npm_runtime_put(phy->io_dev);\r\nreturn ret;\r\n}\r\nstatic int musb_ulpi_write(struct usb_phy *phy, u32 offset, u32 data)\r\n{\r\nvoid __iomem *addr = phy->io_priv;\r\nint i = 0;\r\nu8 r = 0;\r\nu8 power;\r\nint ret = 0;\r\npm_runtime_get_sync(phy->io_dev);\r\npower = musb_readb(addr, MUSB_POWER);\r\npower &= ~MUSB_POWER_SUSPENDM;\r\nmusb_writeb(addr, MUSB_POWER, power);\r\nmusb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);\r\nmusb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)data);\r\nmusb_writeb(addr, MUSB_ULPI_REG_CONTROL, MUSB_ULPI_REG_REQ);\r\nwhile (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)\r\n& MUSB_ULPI_REG_CMPLT)) {\r\ni++;\r\nif (i == 10000) {\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\n}\r\nr = musb_readb(addr, MUSB_ULPI_REG_CONTROL);\r\nr &= ~MUSB_ULPI_REG_CMPLT;\r\nmusb_writeb(addr, MUSB_ULPI_REG_CONTROL, r);\r\nout:\r\npm_runtime_put(phy->io_dev);\r\nreturn ret;\r\n}\r\nvoid musb_write_fifo(struct musb_hw_ep *hw_ep, u16 len, const u8 *src)\r\n{\r\nstruct musb *musb = hw_ep->musb;\r\nvoid __iomem *fifo = hw_ep->fifo;\r\nif (unlikely(len == 0))\r\nreturn;\r\nprefetch((u8 *)src);\r\ndev_dbg(musb->controller, "%cX ep%d fifo %p count %d buf %p\n",\r\n'T', hw_ep->epnum, fifo, len, src);\r\nif (likely((0x01 & (unsigned long) src) == 0)) {\r\nu16 index = 0;\r\nif ((0x02 & (unsigned long) src) == 0) {\r\nif (len >= 4) {\r\niowrite32_rep(fifo, src + index, len >> 2);\r\nindex += len & ~0x03;\r\n}\r\nif (len & 0x02) {\r\nmusb_writew(fifo, 0, *(u16 *)&src[index]);\r\nindex += 2;\r\n}\r\n} else {\r\nif (len >= 2) {\r\niowrite16_rep(fifo, src + index, len >> 1);\r\nindex += len & ~0x01;\r\n}\r\n}\r\nif (len & 0x01)\r\nmusb_writeb(fifo, 0, src[index]);\r\n} else {\r\niowrite8_rep(fifo, src, len);\r\n}\r\n}\r\nvoid musb_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)\r\n{\r\nstruct musb *musb = hw_ep->musb;\r\nvoid __iomem *fifo = hw_ep->fifo;\r\nif (unlikely(len == 0))\r\nreturn;\r\ndev_dbg(musb->controller, "%cX ep%d fifo %p count %d buf %p\n",\r\n'R', hw_ep->epnum, fifo, len, dst);\r\nif (likely((0x01 & (unsigned long) dst) == 0)) {\r\nu16 index = 0;\r\nif ((0x02 & (unsigned long) dst) == 0) {\r\nif (len >= 4) {\r\nioread32_rep(fifo, dst, len >> 2);\r\nindex = len & ~0x03;\r\n}\r\nif (len & 0x02) {\r\n*(u16 *)&dst[index] = musb_readw(fifo, 0);\r\nindex += 2;\r\n}\r\n} else {\r\nif (len >= 2) {\r\nioread16_rep(fifo, dst, len >> 1);\r\nindex = len & ~0x01;\r\n}\r\n}\r\nif (len & 0x01)\r\ndst[index] = musb_readb(fifo, 0);\r\n} else {\r\nioread8_rep(fifo, dst, len);\r\n}\r\n}\r\nvoid musb_load_testpacket(struct musb *musb)\r\n{\r\nvoid __iomem *regs = musb->endpoints[0].regs;\r\nmusb_ep_select(musb->mregs, 0);\r\nmusb_write_fifo(musb->control_ep,\r\nsizeof(musb_test_packet), musb_test_packet);\r\nmusb_writew(regs, MUSB_CSR0, MUSB_CSR0_TXPKTRDY);\r\n}\r\nstatic void musb_otg_timer_func(unsigned long data)\r\n{\r\nstruct musb *musb = (struct musb *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_B_WAIT_ACON:\r\ndev_dbg(musb->controller, "HNP: b_wait_acon timeout; back to b_peripheral\n");\r\nmusb_g_disconnect(musb);\r\nmusb->xceiv->state = OTG_STATE_B_PERIPHERAL;\r\nmusb->is_active = 0;\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndev_dbg(musb->controller, "HNP: %s timeout\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\nmusb_platform_set_vbus(musb, 0);\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_VFALL;\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "HNP: Unhandled mode %s\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nvoid musb_hnp_stop(struct musb *musb)\r\n{\r\nstruct usb_hcd *hcd = musb->hcd;\r\nvoid __iomem *mbase = musb->mregs;\r\nu8 reg;\r\ndev_dbg(musb->controller, "HNP: stop from %s\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_PERIPHERAL:\r\nmusb_g_disconnect(musb);\r\ndev_dbg(musb->controller, "HNP: back to %s\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\ndev_dbg(musb->controller, "HNP: Disabling HR\n");\r\nif (hcd)\r\nhcd->self.is_b_host = 0;\r\nmusb->xceiv->state = OTG_STATE_B_PERIPHERAL;\r\nMUSB_DEV_MODE(musb);\r\nreg = musb_readb(mbase, MUSB_POWER);\r\nreg |= MUSB_POWER_SUSPENDM;\r\nmusb_writeb(mbase, MUSB_POWER, reg);\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "HNP: Stopping in unknown state %s\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\n}\r\nmusb->port1_status &= ~(USB_PORT_STAT_C_CONNECTION << 16);\r\n}\r\nstatic irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,\r\nu8 devctl)\r\n{\r\nirqreturn_t handled = IRQ_NONE;\r\ndev_dbg(musb->controller, "<== DevCtl=%02x, int_usb=0x%x\n", devctl,\r\nint_usb);\r\nif (int_usb & MUSB_INTR_RESUME) {\r\nhandled = IRQ_HANDLED;\r\ndev_dbg(musb->controller, "RESUME (%s)\n", usb_otg_state_string(musb->xceiv->state));\r\nif (devctl & MUSB_DEVCTL_HM) {\r\nvoid __iomem *mbase = musb->mregs;\r\nu8 power;\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_SUSPEND:\r\npower = musb_readb(musb->mregs, MUSB_POWER);\r\nif (power & MUSB_POWER_SUSPENDM) {\r\nmusb->int_usb &= ~MUSB_INTR_SUSPEND;\r\ndev_dbg(musb->controller, "Spurious SUSPENDM\n");\r\nbreak;\r\n}\r\npower &= ~MUSB_POWER_SUSPENDM;\r\nmusb_writeb(mbase, MUSB_POWER,\r\npower | MUSB_POWER_RESUME);\r\nmusb->port1_status |=\r\n(USB_PORT_STAT_C_SUSPEND << 16)\r\n| MUSB_PORT_STAT_RESUME;\r\nmusb->rh_timer = jiffies\r\n+ msecs_to_jiffies(20);\r\nschedule_delayed_work(\r\n&musb->finish_resume_work,\r\nmsecs_to_jiffies(20));\r\nmusb->xceiv->state = OTG_STATE_A_HOST;\r\nmusb->is_active = 1;\r\nmusb_host_resume_root_hub(musb);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\nmusb->xceiv->state = OTG_STATE_B_PERIPHERAL;\r\nmusb->is_active = 1;\r\nMUSB_DEV_MODE(musb);\r\nbreak;\r\ndefault:\r\nWARNING("bogus %s RESUME (%s)\n",\r\n"host",\r\nusb_otg_state_string(musb->xceiv->state));\r\n}\r\n} else {\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_SUSPEND:\r\nmusb->xceiv->state = OTG_STATE_A_HOST;\r\nmusb_host_resume_root_hub(musb);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif ((devctl & MUSB_DEVCTL_VBUS)\r\n!= (3 << MUSB_DEVCTL_VBUS_SHIFT)\r\n) {\r\nmusb->int_usb |= MUSB_INTR_DISCONNECT;\r\nmusb->int_usb &= ~MUSB_INTR_SUSPEND;\r\nbreak;\r\n}\r\nmusb_g_resume(musb);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nmusb->int_usb &= ~MUSB_INTR_SUSPEND;\r\nbreak;\r\ndefault:\r\nWARNING("bogus %s RESUME (%s)\n",\r\n"peripheral",\r\nusb_otg_state_string(musb->xceiv->state));\r\n}\r\n}\r\n}\r\nif (int_usb & MUSB_INTR_SESSREQ) {\r\nvoid __iomem *mbase = musb->mregs;\r\nif ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS\r\n&& (devctl & MUSB_DEVCTL_BDEVICE)) {\r\ndev_dbg(musb->controller, "SessReq while on B state\n");\r\nreturn IRQ_HANDLED;\r\n}\r\ndev_dbg(musb->controller, "SESSION_REQUEST (%s)\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\nmusb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);\r\nmusb->ep0_stage = MUSB_EP0_START;\r\nmusb->xceiv->state = OTG_STATE_A_IDLE;\r\nMUSB_HST_MODE(musb);\r\nmusb_platform_set_vbus(musb, 1);\r\nhandled = IRQ_HANDLED;\r\n}\r\nif (int_usb & MUSB_INTR_VBUSERROR) {\r\nint ignore = 0;\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_HOST:\r\ncase OTG_STATE_A_WAIT_BCON:\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nif (musb->vbuserr_retry) {\r\nvoid __iomem *mbase = musb->mregs;\r\nmusb->vbuserr_retry--;\r\nignore = 1;\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(mbase, MUSB_DEVCTL, devctl);\r\n} else {\r\nmusb->port1_status |=\r\nUSB_PORT_STAT_OVERCURRENT\r\n| (USB_PORT_STAT_C_OVERCURRENT << 16);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_printk(ignore ? KERN_DEBUG : KERN_ERR, musb->controller,\r\n"VBUS_ERROR in %s (%02x, %s), retry #%d, port1 %08x\n",\r\nusb_otg_state_string(musb->xceiv->state),\r\ndevctl,\r\n({ char *s;\r\nswitch (devctl & MUSB_DEVCTL_VBUS) {\r\ncase 0 << MUSB_DEVCTL_VBUS_SHIFT:\r\ns = "<SessEnd"; break;\r\ncase 1 << MUSB_DEVCTL_VBUS_SHIFT:\r\ns = "<AValid"; break;\r\ncase 2 << MUSB_DEVCTL_VBUS_SHIFT:\r\ns = "<VBusValid"; break;\r\ndefault:\r\ns = "VALID"; break;\r\n} s; }),\r\nVBUSERR_RETRY_COUNT - musb->vbuserr_retry,\r\nmusb->port1_status);\r\nif (!ignore)\r\nmusb_platform_set_vbus(musb, 0);\r\nhandled = IRQ_HANDLED;\r\n}\r\nif (int_usb & MUSB_INTR_SUSPEND) {\r\ndev_dbg(musb->controller, "SUSPEND (%s) devctl %02x\n",\r\nusb_otg_state_string(musb->xceiv->state), devctl);\r\nhandled = IRQ_HANDLED;\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_PERIPHERAL:\r\nmusb_hnp_stop(musb);\r\nmusb_host_resume_root_hub(musb);\r\nmusb_root_disconnect(musb);\r\nmusb_platform_try_idle(musb, jiffies\r\n+ msecs_to_jiffies(musb->a_wait_bcon\r\n? : OTG_TIME_A_WAIT_BCON));\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nif (!musb->is_active)\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nmusb_g_suspend(musb);\r\nmusb->is_active = musb->g.b_hnp_enable;\r\nif (musb->is_active) {\r\nmusb->xceiv->state = OTG_STATE_B_WAIT_ACON;\r\ndev_dbg(musb->controller, "HNP: Setting timer for b_ase0_brst\n");\r\nmod_timer(&musb->otg_timer, jiffies\r\n+ msecs_to_jiffies(\r\nOTG_TIME_B_ASE0_BRST));\r\n}\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (musb->a_wait_bcon != 0)\r\nmusb_platform_try_idle(musb, jiffies\r\n+ msecs_to_jiffies(musb->a_wait_bcon));\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nmusb->xceiv->state = OTG_STATE_A_SUSPEND;\r\nmusb->is_active = musb->hcd->self.b_hnp_enable;\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\ndev_dbg(musb->controller, "REVISIT: SUSPEND as B_HOST\n");\r\nbreak;\r\ndefault:\r\nmusb->is_active = 0;\r\nbreak;\r\n}\r\n}\r\nif (int_usb & MUSB_INTR_CONNECT) {\r\nstruct usb_hcd *hcd = musb->hcd;\r\nhandled = IRQ_HANDLED;\r\nmusb->is_active = 1;\r\nmusb->ep0_stage = MUSB_EP0_START;\r\nif (is_peripheral_active(musb)) {\r\n}\r\nmusb->intrtxe = musb->epmask;\r\nmusb_writew(musb->mregs, MUSB_INTRTXE, musb->intrtxe);\r\nmusb->intrrxe = musb->epmask & 0xfffe;\r\nmusb_writew(musb->mregs, MUSB_INTRRXE, musb->intrrxe);\r\nmusb_writeb(musb->mregs, MUSB_INTRUSBE, 0xf7);\r\nmusb->port1_status &= ~(USB_PORT_STAT_LOW_SPEED\r\n|USB_PORT_STAT_HIGH_SPEED\r\n|USB_PORT_STAT_ENABLE\r\n);\r\nmusb->port1_status |= USB_PORT_STAT_CONNECTION\r\n|(USB_PORT_STAT_C_CONNECTION << 16);\r\nif (devctl & MUSB_DEVCTL_LSDEV)\r\nmusb->port1_status |= USB_PORT_STAT_LOW_SPEED;\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (int_usb & MUSB_INTR_SUSPEND) {\r\ndev_dbg(musb->controller, "HNP: SUSPEND+CONNECT, now b_host\n");\r\nint_usb &= ~MUSB_INTR_SUSPEND;\r\ngoto b_host;\r\n} else\r\ndev_dbg(musb->controller, "CONNECT as b_peripheral???\n");\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\ndev_dbg(musb->controller, "HNP: CONNECT, now b_host\n");\r\nb_host:\r\nmusb->xceiv->state = OTG_STATE_B_HOST;\r\nif (musb->hcd)\r\nmusb->hcd->self.is_b_host = 1;\r\ndel_timer(&musb->otg_timer);\r\nbreak;\r\ndefault:\r\nif ((devctl & MUSB_DEVCTL_VBUS)\r\n== (3 << MUSB_DEVCTL_VBUS_SHIFT)) {\r\nmusb->xceiv->state = OTG_STATE_A_HOST;\r\nif (hcd)\r\nhcd->self.is_b_host = 0;\r\n}\r\nbreak;\r\n}\r\nmusb_host_poke_root_hub(musb);\r\ndev_dbg(musb->controller, "CONNECT (%s) devctl %02x\n",\r\nusb_otg_state_string(musb->xceiv->state), devctl);\r\n}\r\nif (int_usb & MUSB_INTR_DISCONNECT) {\r\ndev_dbg(musb->controller, "DISCONNECT (%s) as %s, devctl %02x\n",\r\nusb_otg_state_string(musb->xceiv->state),\r\nMUSB_MODE(musb), devctl);\r\nhandled = IRQ_HANDLED;\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_HOST:\r\ncase OTG_STATE_A_SUSPEND:\r\nmusb_host_resume_root_hub(musb);\r\nmusb_root_disconnect(musb);\r\nif (musb->a_wait_bcon != 0)\r\nmusb_platform_try_idle(musb, jiffies\r\n+ msecs_to_jiffies(musb->a_wait_bcon));\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nmusb_root_disconnect(musb);\r\nif (musb->hcd)\r\nmusb->hcd->self.is_b_host = 0;\r\nmusb->xceiv->state = OTG_STATE_B_PERIPHERAL;\r\nMUSB_DEV_MODE(musb);\r\nmusb_g_disconnect(musb);\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nmusb_hnp_stop(musb);\r\nmusb_root_disconnect(musb);\r\ncase OTG_STATE_B_WAIT_ACON:\r\ncase OTG_STATE_B_PERIPHERAL:\r\ncase OTG_STATE_B_IDLE:\r\nmusb_g_disconnect(musb);\r\nbreak;\r\ndefault:\r\nWARNING("unhandled DISCONNECT transition (%s)\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\nbreak;\r\n}\r\n}\r\nif (int_usb & MUSB_INTR_RESET) {\r\nhandled = IRQ_HANDLED;\r\nif ((devctl & MUSB_DEVCTL_HM) != 0) {\r\nif (devctl & (MUSB_DEVCTL_FSDEV | MUSB_DEVCTL_LSDEV))\r\ndev_dbg(musb->controller, "BABBLE devctl: %02x\n", devctl);\r\nelse {\r\nERR("Stopping host session -- babble\n");\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\r\n}\r\n} else {\r\ndev_dbg(musb->controller, "BUS RESET as %s\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_SUSPEND:\r\nmusb_g_reset(musb);\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndev_dbg(musb->controller, "HNP: in %s, %d msec timeout\n",\r\nusb_otg_state_string(musb->xceiv->state),\r\nTA_WAIT_BCON(musb));\r\nmod_timer(&musb->otg_timer, jiffies\r\n+ msecs_to_jiffies(TA_WAIT_BCON(musb)));\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\ndel_timer(&musb->otg_timer);\r\nmusb_g_reset(musb);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\ndev_dbg(musb->controller, "HNP: RESET (%s), to b_peripheral\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\nmusb->xceiv->state = OTG_STATE_B_PERIPHERAL;\r\nmusb_g_reset(musb);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nmusb->xceiv->state = OTG_STATE_B_PERIPHERAL;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nmusb_g_reset(musb);\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "Unhandled BUS RESET as %s\n",\r\nusb_otg_state_string(musb->xceiv->state));\r\n}\r\n}\r\n}\r\nif (int_usb & MUSB_INTR_BABBLE && is_host_active(musb))\r\nschedule_delayed_work(&musb->recover_work,\r\nmsecs_to_jiffies(100));\r\n#if 0\r\nif (int_usb & MUSB_INTR_SOF) {\r\nvoid __iomem *mbase = musb->mregs;\r\nstruct musb_hw_ep *ep;\r\nu8 epnum;\r\nu16 frame;\r\ndev_dbg(musb->controller, "START_OF_FRAME\n");\r\nhandled = IRQ_HANDLED;\r\nframe = musb_readw(mbase, MUSB_FRAME);\r\nep = musb->endpoints;\r\nfor (epnum = 1; (epnum < musb->nr_endpoints)\r\n&& (musb->epmask >= (1 << epnum));\r\nepnum++, ep++) {\r\nif (ep->dwWaitFrame >= frame) {\r\nep->dwWaitFrame = 0;\r\npr_debug("SOF --> periodic TX%s on %d\n",\r\nep->tx_channel ? " DMA" : "",\r\nepnum);\r\nif (!ep->tx_channel)\r\nmusb_h_tx_start(musb, epnum);\r\nelse\r\ncppi_hostdma_start(musb, epnum);\r\n}\r\n}\r\n}\r\n#endif\r\nschedule_work(&musb->irq_work);\r\nreturn handled;\r\n}\r\nstatic void musb_generic_disable(struct musb *musb)\r\n{\r\nvoid __iomem *mbase = musb->mregs;\r\nu16 temp;\r\nmusb_writeb(mbase, MUSB_INTRUSBE, 0);\r\nmusb->intrtxe = 0;\r\nmusb_writew(mbase, MUSB_INTRTXE, 0);\r\nmusb->intrrxe = 0;\r\nmusb_writew(mbase, MUSB_INTRRXE, 0);\r\nmusb_writeb(mbase, MUSB_DEVCTL, 0);\r\ntemp = musb_readb(mbase, MUSB_INTRUSB);\r\ntemp = musb_readw(mbase, MUSB_INTRTX);\r\ntemp = musb_readw(mbase, MUSB_INTRRX);\r\n}\r\nvoid musb_start(struct musb *musb)\r\n{\r\nvoid __iomem *regs = musb->mregs;\r\nu8 devctl = musb_readb(regs, MUSB_DEVCTL);\r\ndev_dbg(musb->controller, "<== devctl %02x\n", devctl);\r\nmusb->intrtxe = musb->epmask;\r\nmusb_writew(regs, MUSB_INTRTXE, musb->intrtxe);\r\nmusb->intrrxe = musb->epmask & 0xfffe;\r\nmusb_writew(regs, MUSB_INTRRXE, musb->intrrxe);\r\nmusb_writeb(regs, MUSB_INTRUSBE, 0xf7);\r\nmusb_writeb(regs, MUSB_TESTMODE, 0);\r\nmusb_writeb(regs, MUSB_POWER, MUSB_POWER_ISOUPDATE\r\n| MUSB_POWER_HSENAB\r\n);\r\nmusb->is_active = 0;\r\ndevctl = musb_readb(regs, MUSB_DEVCTL);\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\nif (musb->port_mode != MUSB_PORT_MODE_HOST &&\r\n(devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS) {\r\nmusb->is_active = 1;\r\n} else {\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\n}\r\nmusb_platform_enable(musb);\r\nmusb_writeb(regs, MUSB_DEVCTL, devctl);\r\n}\r\nvoid musb_stop(struct musb *musb)\r\n{\r\nmusb_platform_disable(musb);\r\nmusb_generic_disable(musb);\r\ndev_dbg(musb->controller, "HDRC disabled\n");\r\nmusb_platform_try_idle(musb, 0);\r\n}\r\nstatic void musb_shutdown(struct platform_device *pdev)\r\n{\r\nstruct musb *musb = dev_to_musb(&pdev->dev);\r\nunsigned long flags;\r\npm_runtime_get_sync(musb->controller);\r\nmusb_host_cleanup(musb);\r\nmusb_gadget_cleanup(musb);\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb_platform_disable(musb);\r\nmusb_generic_disable(musb);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\r\nmusb_platform_exit(musb);\r\npm_runtime_put(musb->controller);\r\n}\r\nstatic int\r\nfifo_setup(struct musb *musb, struct musb_hw_ep *hw_ep,\r\nconst struct musb_fifo_cfg *cfg, u16 offset)\r\n{\r\nvoid __iomem *mbase = musb->mregs;\r\nint size = 0;\r\nu16 maxpacket = cfg->maxpacket;\r\nu16 c_off = offset >> 3;\r\nu8 c_size;\r\nsize = ffs(max(maxpacket, (u16) 8)) - 1;\r\nmaxpacket = 1 << size;\r\nc_size = size - 3;\r\nif (cfg->mode == BUF_DOUBLE) {\r\nif ((offset + (maxpacket << 1)) >\r\n(1 << (musb->config->ram_bits + 2)))\r\nreturn -EMSGSIZE;\r\nc_size |= MUSB_FIFOSZ_DPB;\r\n} else {\r\nif ((offset + maxpacket) > (1 << (musb->config->ram_bits + 2)))\r\nreturn -EMSGSIZE;\r\n}\r\nmusb_writeb(mbase, MUSB_INDEX, hw_ep->epnum);\r\nif (hw_ep->epnum == 1)\r\nmusb->bulk_ep = hw_ep;\r\nswitch (cfg->style) {\r\ncase FIFO_TX:\r\nmusb_write_txfifosz(mbase, c_size);\r\nmusb_write_txfifoadd(mbase, c_off);\r\nhw_ep->tx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);\r\nhw_ep->max_packet_sz_tx = maxpacket;\r\nbreak;\r\ncase FIFO_RX:\r\nmusb_write_rxfifosz(mbase, c_size);\r\nmusb_write_rxfifoadd(mbase, c_off);\r\nhw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);\r\nhw_ep->max_packet_sz_rx = maxpacket;\r\nbreak;\r\ncase FIFO_RXTX:\r\nmusb_write_txfifosz(mbase, c_size);\r\nmusb_write_txfifoadd(mbase, c_off);\r\nhw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);\r\nhw_ep->max_packet_sz_rx = maxpacket;\r\nmusb_write_rxfifosz(mbase, c_size);\r\nmusb_write_rxfifoadd(mbase, c_off);\r\nhw_ep->tx_double_buffered = hw_ep->rx_double_buffered;\r\nhw_ep->max_packet_sz_tx = maxpacket;\r\nhw_ep->is_shared_fifo = true;\r\nbreak;\r\n}\r\nmusb->epmask |= (1 << hw_ep->epnum);\r\nreturn offset + (maxpacket << ((c_size & MUSB_FIFOSZ_DPB) ? 1 : 0));\r\n}\r\nstatic int ep_config_from_table(struct musb *musb)\r\n{\r\nconst struct musb_fifo_cfg *cfg;\r\nunsigned i, n;\r\nint offset;\r\nstruct musb_hw_ep *hw_ep = musb->endpoints;\r\nif (musb->config->fifo_cfg) {\r\ncfg = musb->config->fifo_cfg;\r\nn = musb->config->fifo_cfg_size;\r\ngoto done;\r\n}\r\nswitch (fifo_mode) {\r\ndefault:\r\nfifo_mode = 0;\r\ncase 0:\r\ncfg = mode_0_cfg;\r\nn = ARRAY_SIZE(mode_0_cfg);\r\nbreak;\r\ncase 1:\r\ncfg = mode_1_cfg;\r\nn = ARRAY_SIZE(mode_1_cfg);\r\nbreak;\r\ncase 2:\r\ncfg = mode_2_cfg;\r\nn = ARRAY_SIZE(mode_2_cfg);\r\nbreak;\r\ncase 3:\r\ncfg = mode_3_cfg;\r\nn = ARRAY_SIZE(mode_3_cfg);\r\nbreak;\r\ncase 4:\r\ncfg = mode_4_cfg;\r\nn = ARRAY_SIZE(mode_4_cfg);\r\nbreak;\r\ncase 5:\r\ncfg = mode_5_cfg;\r\nn = ARRAY_SIZE(mode_5_cfg);\r\nbreak;\r\n}\r\nprintk(KERN_DEBUG "%s: setup fifo_mode %d\n",\r\nmusb_driver_name, fifo_mode);\r\ndone:\r\noffset = fifo_setup(musb, hw_ep, &ep0_cfg, 0);\r\nfor (i = 0; i < n; i++) {\r\nu8 epn = cfg->hw_ep_num;\r\nif (epn >= musb->config->num_eps) {\r\npr_debug("%s: invalid ep %d\n",\r\nmusb_driver_name, epn);\r\nreturn -EINVAL;\r\n}\r\noffset = fifo_setup(musb, hw_ep + epn, cfg++, offset);\r\nif (offset < 0) {\r\npr_debug("%s: mem overrun, ep %d\n",\r\nmusb_driver_name, epn);\r\nreturn offset;\r\n}\r\nepn++;\r\nmusb->nr_endpoints = max(epn, musb->nr_endpoints);\r\n}\r\nprintk(KERN_DEBUG "%s: %d/%d max ep, %d/%d memory\n",\r\nmusb_driver_name,\r\nn + 1, musb->config->num_eps * 2 - 1,\r\noffset, (1 << (musb->config->ram_bits + 2)));\r\nif (!musb->bulk_ep) {\r\npr_debug("%s: missing bulk\n", musb_driver_name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ep_config_from_hw(struct musb *musb)\r\n{\r\nu8 epnum = 0;\r\nstruct musb_hw_ep *hw_ep;\r\nvoid __iomem *mbase = musb->mregs;\r\nint ret = 0;\r\ndev_dbg(musb->controller, "<== static silicon ep config\n");\r\nfor (epnum = 1; epnum < musb->config->num_eps; epnum++) {\r\nmusb_ep_select(mbase, epnum);\r\nhw_ep = musb->endpoints + epnum;\r\nret = musb_read_fifosize(musb, hw_ep, epnum);\r\nif (ret < 0)\r\nbreak;\r\nif (hw_ep->max_packet_sz_tx < 512\r\n|| hw_ep->max_packet_sz_rx < 512)\r\ncontinue;\r\nif (musb->bulk_ep)\r\ncontinue;\r\nmusb->bulk_ep = hw_ep;\r\n}\r\nif (!musb->bulk_ep) {\r\npr_debug("%s: missing bulk\n", musb_driver_name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int musb_core_init(u16 musb_type, struct musb *musb)\r\n{\r\nu8 reg;\r\nchar *type;\r\nchar aInfo[90], aRevision[32], aDate[12];\r\nvoid __iomem *mbase = musb->mregs;\r\nint status = 0;\r\nint i;\r\nreg = musb_read_configdata(mbase);\r\nstrcpy(aInfo, (reg & MUSB_CONFIGDATA_UTMIDW) ? "UTMI-16" : "UTMI-8");\r\nif (reg & MUSB_CONFIGDATA_DYNFIFO) {\r\nstrcat(aInfo, ", dyn FIFOs");\r\nmusb->dyn_fifo = true;\r\n}\r\nif (reg & MUSB_CONFIGDATA_MPRXE) {\r\nstrcat(aInfo, ", bulk combine");\r\nmusb->bulk_combine = true;\r\n}\r\nif (reg & MUSB_CONFIGDATA_MPTXE) {\r\nstrcat(aInfo, ", bulk split");\r\nmusb->bulk_split = true;\r\n}\r\nif (reg & MUSB_CONFIGDATA_HBRXE) {\r\nstrcat(aInfo, ", HB-ISO Rx");\r\nmusb->hb_iso_rx = true;\r\n}\r\nif (reg & MUSB_CONFIGDATA_HBTXE) {\r\nstrcat(aInfo, ", HB-ISO Tx");\r\nmusb->hb_iso_tx = true;\r\n}\r\nif (reg & MUSB_CONFIGDATA_SOFTCONE)\r\nstrcat(aInfo, ", SoftConn");\r\nprintk(KERN_DEBUG "%s: ConfigData=0x%02x (%s)\n",\r\nmusb_driver_name, reg, aInfo);\r\naDate[0] = 0;\r\nif (MUSB_CONTROLLER_MHDRC == musb_type) {\r\nmusb->is_multipoint = 1;\r\ntype = "M";\r\n} else {\r\nmusb->is_multipoint = 0;\r\ntype = "";\r\n#ifndef CONFIG_USB_OTG_BLACKLIST_HUB\r\nprintk(KERN_ERR\r\n"%s: kernel must blacklist external hubs\n",\r\nmusb_driver_name);\r\n#endif\r\n}\r\nmusb->hwvers = musb_read_hwvers(mbase);\r\nsnprintf(aRevision, 32, "%d.%d%s", MUSB_HWVERS_MAJOR(musb->hwvers),\r\nMUSB_HWVERS_MINOR(musb->hwvers),\r\n(musb->hwvers & MUSB_HWVERS_RC) ? "RC" : "");\r\nprintk(KERN_DEBUG "%s: %sHDRC RTL version %s %s\n",\r\nmusb_driver_name, type, aRevision, aDate);\r\nmusb_configure_ep0(musb);\r\nmusb->nr_endpoints = 1;\r\nmusb->epmask = 1;\r\nif (musb->dyn_fifo)\r\nstatus = ep_config_from_table(musb);\r\nelse\r\nstatus = ep_config_from_hw(musb);\r\nif (status < 0)\r\nreturn status;\r\nfor (i = 0; i < musb->nr_endpoints; i++) {\r\nstruct musb_hw_ep *hw_ep = musb->endpoints + i;\r\nhw_ep->fifo = MUSB_FIFO_OFFSET(i) + mbase;\r\n#if defined(CONFIG_USB_MUSB_TUSB6010) || defined (CONFIG_USB_MUSB_TUSB6010_MODULE)\r\nhw_ep->fifo_async = musb->async + 0x400 + MUSB_FIFO_OFFSET(i);\r\nhw_ep->fifo_sync = musb->sync + 0x400 + MUSB_FIFO_OFFSET(i);\r\nhw_ep->fifo_sync_va =\r\nmusb->sync_va + 0x400 + MUSB_FIFO_OFFSET(i);\r\nif (i == 0)\r\nhw_ep->conf = mbase - 0x400 + TUSB_EP0_CONF;\r\nelse\r\nhw_ep->conf = mbase + 0x400 + (((i - 1) & 0xf) << 2);\r\n#endif\r\nhw_ep->regs = MUSB_EP_OFFSET(i, 0) + mbase;\r\nhw_ep->target_regs = musb_read_target_reg_base(i, mbase);\r\nhw_ep->rx_reinit = 1;\r\nhw_ep->tx_reinit = 1;\r\nif (hw_ep->max_packet_sz_tx) {\r\ndev_dbg(musb->controller,\r\n"%s: hw_ep %d%s, %smax %d\n",\r\nmusb_driver_name, i,\r\nhw_ep->is_shared_fifo ? "shared" : "tx",\r\nhw_ep->tx_double_buffered\r\n? "doublebuffer, " : "",\r\nhw_ep->max_packet_sz_tx);\r\n}\r\nif (hw_ep->max_packet_sz_rx && !hw_ep->is_shared_fifo) {\r\ndev_dbg(musb->controller,\r\n"%s: hw_ep %d%s, %smax %d\n",\r\nmusb_driver_name, i,\r\n"rx",\r\nhw_ep->rx_double_buffered\r\n? "doublebuffer, " : "",\r\nhw_ep->max_packet_sz_rx);\r\n}\r\nif (!(hw_ep->max_packet_sz_tx || hw_ep->max_packet_sz_rx))\r\ndev_dbg(musb->controller, "hw_ep %d not configured\n", i);\r\n}\r\nreturn 0;\r\n}\r\nirqreturn_t musb_interrupt(struct musb *musb)\r\n{\r\nirqreturn_t retval = IRQ_NONE;\r\nu8 devctl;\r\nint ep_num;\r\nu32 reg;\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\ndev_dbg(musb->controller, "** IRQ %s usb%04x tx%04x rx%04x\n",\r\nis_host_active(musb) ? "host" : "peripheral",\r\nmusb->int_usb, musb->int_tx, musb->int_rx);\r\nif (musb->int_usb)\r\nretval |= musb_stage0_irq(musb, musb->int_usb,\r\ndevctl);\r\nif (musb->int_tx & 1) {\r\nif (is_host_active(musb))\r\nretval |= musb_h_ep0_irq(musb);\r\nelse\r\nretval |= musb_g_ep0_irq(musb);\r\n}\r\nreg = musb->int_rx >> 1;\r\nep_num = 1;\r\nwhile (reg) {\r\nif (reg & 1) {\r\nretval = IRQ_HANDLED;\r\nif (is_host_active(musb))\r\nmusb_host_rx(musb, ep_num);\r\nelse\r\nmusb_g_rx(musb, ep_num);\r\n}\r\nreg >>= 1;\r\nep_num++;\r\n}\r\nreg = musb->int_tx >> 1;\r\nep_num = 1;\r\nwhile (reg) {\r\nif (reg & 1) {\r\nretval = IRQ_HANDLED;\r\nif (is_host_active(musb))\r\nmusb_host_tx(musb, ep_num);\r\nelse\r\nmusb_g_tx(musb, ep_num);\r\n}\r\nreg >>= 1;\r\nep_num++;\r\n}\r\nreturn retval;\r\n}\r\nvoid musb_dma_completion(struct musb *musb, u8 epnum, u8 transmit)\r\n{\r\nif (!epnum) {\r\n#ifndef CONFIG_USB_TUSB_OMAP_DMA\r\nif (!is_cppi_enabled()) {\r\nif (is_host_active(musb))\r\nmusb_h_ep0_irq(musb);\r\nelse\r\nmusb_g_ep0_irq(musb);\r\n}\r\n#endif\r\n} else {\r\nif (transmit) {\r\nif (is_host_active(musb))\r\nmusb_host_tx(musb, epnum);\r\nelse\r\nmusb_g_tx(musb, epnum);\r\n} else {\r\nif (is_host_active(musb))\r\nmusb_host_rx(musb, epnum);\r\nelse\r\nmusb_g_rx(musb, epnum);\r\n}\r\n}\r\n}\r\nstatic ssize_t\r\nmusb_mode_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nret = sprintf(buf, "%s\n", usb_otg_state_string(musb->xceiv->state));\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nmusb_mode_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nunsigned long flags;\r\nint status;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (sysfs_streq(buf, "host"))\r\nstatus = musb_platform_set_mode(musb, MUSB_HOST);\r\nelse if (sysfs_streq(buf, "peripheral"))\r\nstatus = musb_platform_set_mode(musb, MUSB_PERIPHERAL);\r\nelse if (sysfs_streq(buf, "otg"))\r\nstatus = musb_platform_set_mode(musb, MUSB_OTG);\r\nelse\r\nstatus = -EINVAL;\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn (status == 0) ? n : status;\r\n}\r\nstatic ssize_t\r\nmusb_vbus_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nunsigned long flags;\r\nunsigned long val;\r\nif (sscanf(buf, "%lu", &val) < 1) {\r\ndev_err(dev, "Invalid VBUS timeout ms value\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb->a_wait_bcon = val ? max_t(int, val, OTG_TIME_A_WAIT_BCON) : 0 ;\r\nif (musb->xceiv->state == OTG_STATE_A_WAIT_BCON)\r\nmusb->is_active = 0;\r\nmusb_platform_try_idle(musb, jiffies + msecs_to_jiffies(val));\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn n;\r\n}\r\nstatic ssize_t\r\nmusb_vbus_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nunsigned long flags;\r\nunsigned long val;\r\nint vbus;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nval = musb->a_wait_bcon;\r\nvbus = musb_platform_get_vbus_status(musb);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn sprintf(buf, "Vbus %s, timeout %lu msec\n",\r\nvbus ? "on" : "off", val);\r\n}\r\nstatic ssize_t\r\nmusb_srp_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nunsigned short srp;\r\nif (sscanf(buf, "%hu", &srp) != 1\r\n|| (srp != 1)) {\r\ndev_err(dev, "SRP: Value must be 1\n");\r\nreturn -EINVAL;\r\n}\r\nif (srp == 1)\r\nmusb_g_wakeup(musb);\r\nreturn n;\r\n}\r\nstatic void musb_irq_work(struct work_struct *data)\r\n{\r\nstruct musb *musb = container_of(data, struct musb, irq_work);\r\nif (musb->xceiv->state != musb->xceiv_old_state) {\r\nmusb->xceiv_old_state = musb->xceiv->state;\r\nsysfs_notify(&musb->controller->kobj, NULL, "mode");\r\n}\r\n}\r\nstatic void musb_recover_work(struct work_struct *data)\r\n{\r\nstruct musb *musb = container_of(data, struct musb, recover_work.work);\r\nint status, ret;\r\nret = musb_platform_reset(musb);\r\nif (ret)\r\nreturn;\r\nusb_phy_vbus_off(musb->xceiv);\r\nusleep_range(100, 200);\r\nusb_phy_vbus_on(musb->xceiv);\r\nusleep_range(100, 200);\r\nif (musb->dyn_fifo)\r\nstatus = ep_config_from_table(musb);\r\nelse\r\nstatus = ep_config_from_hw(musb);\r\nif (status == 0)\r\nmusb_start(musb);\r\n}\r\nstatic struct musb *allocate_instance(struct device *dev,\r\nstruct musb_hdrc_config *config, void __iomem *mbase)\r\n{\r\nstruct musb *musb;\r\nstruct musb_hw_ep *ep;\r\nint epnum;\r\nint ret;\r\nmusb = devm_kzalloc(dev, sizeof(*musb), GFP_KERNEL);\r\nif (!musb)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&musb->control);\r\nINIT_LIST_HEAD(&musb->in_bulk);\r\nINIT_LIST_HEAD(&musb->out_bulk);\r\nmusb->vbuserr_retry = VBUSERR_RETRY_COUNT;\r\nmusb->a_wait_bcon = OTG_TIME_A_WAIT_BCON;\r\nmusb->mregs = mbase;\r\nmusb->ctrl_base = mbase;\r\nmusb->nIrq = -ENODEV;\r\nmusb->config = config;\r\nBUG_ON(musb->config->num_eps > MUSB_C_NUM_EPS);\r\nfor (epnum = 0, ep = musb->endpoints;\r\nepnum < musb->config->num_eps;\r\nepnum++, ep++) {\r\nep->musb = musb;\r\nep->epnum = epnum;\r\n}\r\nmusb->controller = dev;\r\nret = musb_host_alloc(musb);\r\nif (ret < 0)\r\ngoto err_free;\r\ndev_set_drvdata(dev, musb);\r\nreturn musb;\r\nerr_free:\r\nreturn NULL;\r\n}\r\nstatic void musb_free(struct musb *musb)\r\n{\r\n#ifdef CONFIG_SYSFS\r\nsysfs_remove_group(&musb->controller->kobj, &musb_attr_group);\r\n#endif\r\nif (musb->nIrq >= 0) {\r\nif (musb->irq_wake)\r\ndisable_irq_wake(musb->nIrq);\r\nfree_irq(musb->nIrq, musb);\r\n}\r\nmusb_host_free(musb);\r\n}\r\nstatic void musb_deassert_reset(struct work_struct *work)\r\n{\r\nstruct musb *musb;\r\nunsigned long flags;\r\nmusb = container_of(work, struct musb, deassert_reset_work.work);\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (musb->port1_status & USB_PORT_STAT_RESET)\r\nmusb_port_reset(musb, false);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic int\r\nmusb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)\r\n{\r\nint status;\r\nstruct musb *musb;\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nif (!plat) {\r\ndev_dbg(dev, "no platform_data?\n");\r\nstatus = -ENODEV;\r\ngoto fail0;\r\n}\r\nmusb = allocate_instance(dev, plat->config, ctrl);\r\nif (!musb) {\r\nstatus = -ENOMEM;\r\ngoto fail0;\r\n}\r\npm_runtime_use_autosuspend(musb->controller);\r\npm_runtime_set_autosuspend_delay(musb->controller, 200);\r\npm_runtime_enable(musb->controller);\r\nspin_lock_init(&musb->lock);\r\nmusb->board_set_power = plat->set_power;\r\nmusb->min_power = plat->min_power;\r\nmusb->ops = plat->platform_ops;\r\nmusb->port_mode = plat->mode;\r\nstatus = musb_platform_init(musb);\r\nif (status < 0)\r\ngoto fail1;\r\nif (!musb->isr) {\r\nstatus = -ENODEV;\r\ngoto fail2;\r\n}\r\nif (!musb->xceiv->io_ops) {\r\nmusb->xceiv->io_dev = musb->controller;\r\nmusb->xceiv->io_priv = musb->mregs;\r\nmusb->xceiv->io_ops = &musb_ulpi_access;\r\n}\r\npm_runtime_get_sync(musb->controller);\r\nif (use_dma && dev->dma_mask) {\r\nmusb->dma_controller = dma_controller_create(musb, musb->mregs);\r\nif (IS_ERR(musb->dma_controller)) {\r\nstatus = PTR_ERR(musb->dma_controller);\r\ngoto fail2_5;\r\n}\r\n}\r\nmusb_platform_disable(musb);\r\nmusb_generic_disable(musb);\r\nINIT_WORK(&musb->irq_work, musb_irq_work);\r\nINIT_DELAYED_WORK(&musb->recover_work, musb_recover_work);\r\nINIT_DELAYED_WORK(&musb->deassert_reset_work, musb_deassert_reset);\r\nINIT_DELAYED_WORK(&musb->finish_resume_work, musb_host_finish_resume);\r\nstatus = musb_core_init(plat->config->multipoint\r\n? MUSB_CONTROLLER_MHDRC\r\n: MUSB_CONTROLLER_HDRC, musb);\r\nif (status < 0)\r\ngoto fail3;\r\nsetup_timer(&musb->otg_timer, musb_otg_timer_func, (unsigned long) musb);\r\nif (request_irq(nIrq, musb->isr, 0, dev_name(dev), musb)) {\r\ndev_err(dev, "request_irq %d failed!\n", nIrq);\r\nstatus = -ENODEV;\r\ngoto fail3;\r\n}\r\nmusb->nIrq = nIrq;\r\nif (enable_irq_wake(nIrq) == 0) {\r\nmusb->irq_wake = 1;\r\ndevice_init_wakeup(dev, 1);\r\n} else {\r\nmusb->irq_wake = 0;\r\n}\r\nif (plat->extvbus) {\r\nu8 busctl = musb_read_ulpi_buscontrol(musb->mregs);\r\nbusctl |= MUSB_ULPI_USE_EXTVBUS;\r\nmusb_write_ulpi_buscontrol(musb->mregs, busctl);\r\n}\r\nif (musb->xceiv->otg->default_a) {\r\nMUSB_HST_MODE(musb);\r\nmusb->xceiv->state = OTG_STATE_A_IDLE;\r\n} else {\r\nMUSB_DEV_MODE(musb);\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\n}\r\nswitch (musb->port_mode) {\r\ncase MUSB_PORT_MODE_HOST:\r\nstatus = musb_host_setup(musb, plat->power);\r\nif (status < 0)\r\ngoto fail3;\r\nstatus = musb_platform_set_mode(musb, MUSB_HOST);\r\nbreak;\r\ncase MUSB_PORT_MODE_GADGET:\r\nstatus = musb_gadget_setup(musb);\r\nif (status < 0)\r\ngoto fail3;\r\nstatus = musb_platform_set_mode(musb, MUSB_PERIPHERAL);\r\nbreak;\r\ncase MUSB_PORT_MODE_DUAL_ROLE:\r\nstatus = musb_host_setup(musb, plat->power);\r\nif (status < 0)\r\ngoto fail3;\r\nstatus = musb_gadget_setup(musb);\r\nif (status) {\r\nmusb_host_cleanup(musb);\r\ngoto fail3;\r\n}\r\nstatus = musb_platform_set_mode(musb, MUSB_OTG);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported port mode %d\n", musb->port_mode);\r\nbreak;\r\n}\r\nif (status < 0)\r\ngoto fail3;\r\nstatus = musb_init_debugfs(musb);\r\nif (status < 0)\r\ngoto fail4;\r\nstatus = sysfs_create_group(&musb->controller->kobj, &musb_attr_group);\r\nif (status)\r\ngoto fail5;\r\npm_runtime_put(musb->controller);\r\nreturn 0;\r\nfail5:\r\nmusb_exit_debugfs(musb);\r\nfail4:\r\nmusb_gadget_cleanup(musb);\r\nmusb_host_cleanup(musb);\r\nfail3:\r\ncancel_work_sync(&musb->irq_work);\r\ncancel_delayed_work_sync(&musb->recover_work);\r\ncancel_delayed_work_sync(&musb->finish_resume_work);\r\ncancel_delayed_work_sync(&musb->deassert_reset_work);\r\nif (musb->dma_controller)\r\ndma_controller_destroy(musb->dma_controller);\r\nfail2_5:\r\npm_runtime_put_sync(musb->controller);\r\nfail2:\r\nif (musb->irq_wake)\r\ndevice_init_wakeup(dev, 0);\r\nmusb_platform_exit(musb);\r\nfail1:\r\npm_runtime_disable(musb->controller);\r\ndev_err(musb->controller,\r\n"musb_init_controller failed with status %d\n", status);\r\nmusb_free(musb);\r\nfail0:\r\nreturn status;\r\n}\r\nstatic int musb_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint irq = platform_get_irq_byname(pdev, "mc");\r\nstruct resource *iomem;\r\nvoid __iomem *base;\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iomem || irq <= 0)\r\nreturn -ENODEV;\r\nbase = devm_ioremap_resource(dev, iomem);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nreturn musb_init_controller(dev, irq, base);\r\n}\r\nstatic int musb_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct musb *musb = dev_to_musb(dev);\r\nmusb_exit_debugfs(musb);\r\nmusb_shutdown(pdev);\r\nif (musb->dma_controller)\r\ndma_controller_destroy(musb->dma_controller);\r\ncancel_work_sync(&musb->irq_work);\r\ncancel_delayed_work_sync(&musb->recover_work);\r\ncancel_delayed_work_sync(&musb->finish_resume_work);\r\ncancel_delayed_work_sync(&musb->deassert_reset_work);\r\nmusb_free(musb);\r\ndevice_init_wakeup(dev, 0);\r\nreturn 0;\r\n}\r\nstatic void musb_save_context(struct musb *musb)\r\n{\r\nint i;\r\nvoid __iomem *musb_base = musb->mregs;\r\nvoid __iomem *epio;\r\nmusb->context.frame = musb_readw(musb_base, MUSB_FRAME);\r\nmusb->context.testmode = musb_readb(musb_base, MUSB_TESTMODE);\r\nmusb->context.busctl = musb_read_ulpi_buscontrol(musb->mregs);\r\nmusb->context.power = musb_readb(musb_base, MUSB_POWER);\r\nmusb->context.intrusbe = musb_readb(musb_base, MUSB_INTRUSBE);\r\nmusb->context.index = musb_readb(musb_base, MUSB_INDEX);\r\nmusb->context.devctl = musb_readb(musb_base, MUSB_DEVCTL);\r\nfor (i = 0; i < musb->config->num_eps; ++i) {\r\nstruct musb_hw_ep *hw_ep;\r\nhw_ep = &musb->endpoints[i];\r\nif (!hw_ep)\r\ncontinue;\r\nepio = hw_ep->regs;\r\nif (!epio)\r\ncontinue;\r\nmusb_writeb(musb_base, MUSB_INDEX, i);\r\nmusb->context.index_regs[i].txmaxp =\r\nmusb_readw(epio, MUSB_TXMAXP);\r\nmusb->context.index_regs[i].txcsr =\r\nmusb_readw(epio, MUSB_TXCSR);\r\nmusb->context.index_regs[i].rxmaxp =\r\nmusb_readw(epio, MUSB_RXMAXP);\r\nmusb->context.index_regs[i].rxcsr =\r\nmusb_readw(epio, MUSB_RXCSR);\r\nif (musb->dyn_fifo) {\r\nmusb->context.index_regs[i].txfifoadd =\r\nmusb_read_txfifoadd(musb_base);\r\nmusb->context.index_regs[i].rxfifoadd =\r\nmusb_read_rxfifoadd(musb_base);\r\nmusb->context.index_regs[i].txfifosz =\r\nmusb_read_txfifosz(musb_base);\r\nmusb->context.index_regs[i].rxfifosz =\r\nmusb_read_rxfifosz(musb_base);\r\n}\r\nmusb->context.index_regs[i].txtype =\r\nmusb_readb(epio, MUSB_TXTYPE);\r\nmusb->context.index_regs[i].txinterval =\r\nmusb_readb(epio, MUSB_TXINTERVAL);\r\nmusb->context.index_regs[i].rxtype =\r\nmusb_readb(epio, MUSB_RXTYPE);\r\nmusb->context.index_regs[i].rxinterval =\r\nmusb_readb(epio, MUSB_RXINTERVAL);\r\nmusb->context.index_regs[i].txfunaddr =\r\nmusb_read_txfunaddr(musb_base, i);\r\nmusb->context.index_regs[i].txhubaddr =\r\nmusb_read_txhubaddr(musb_base, i);\r\nmusb->context.index_regs[i].txhubport =\r\nmusb_read_txhubport(musb_base, i);\r\nmusb->context.index_regs[i].rxfunaddr =\r\nmusb_read_rxfunaddr(musb_base, i);\r\nmusb->context.index_regs[i].rxhubaddr =\r\nmusb_read_rxhubaddr(musb_base, i);\r\nmusb->context.index_regs[i].rxhubport =\r\nmusb_read_rxhubport(musb_base, i);\r\n}\r\n}\r\nstatic void musb_restore_context(struct musb *musb)\r\n{\r\nint i;\r\nvoid __iomem *musb_base = musb->mregs;\r\nvoid __iomem *ep_target_regs;\r\nvoid __iomem *epio;\r\nu8 power;\r\nmusb_writew(musb_base, MUSB_FRAME, musb->context.frame);\r\nmusb_writeb(musb_base, MUSB_TESTMODE, musb->context.testmode);\r\nmusb_write_ulpi_buscontrol(musb->mregs, musb->context.busctl);\r\npower = musb_readb(musb_base, MUSB_POWER);\r\npower &= MUSB_POWER_SUSPENDM | MUSB_POWER_RESUME;\r\nmusb->context.power &= ~(MUSB_POWER_SUSPENDM | MUSB_POWER_RESUME);\r\npower |= musb->context.power;\r\nmusb_writeb(musb_base, MUSB_POWER, power);\r\nmusb_writew(musb_base, MUSB_INTRTXE, musb->intrtxe);\r\nmusb_writew(musb_base, MUSB_INTRRXE, musb->intrrxe);\r\nmusb_writeb(musb_base, MUSB_INTRUSBE, musb->context.intrusbe);\r\nmusb_writeb(musb_base, MUSB_DEVCTL, musb->context.devctl);\r\nfor (i = 0; i < musb->config->num_eps; ++i) {\r\nstruct musb_hw_ep *hw_ep;\r\nhw_ep = &musb->endpoints[i];\r\nif (!hw_ep)\r\ncontinue;\r\nepio = hw_ep->regs;\r\nif (!epio)\r\ncontinue;\r\nmusb_writeb(musb_base, MUSB_INDEX, i);\r\nmusb_writew(epio, MUSB_TXMAXP,\r\nmusb->context.index_regs[i].txmaxp);\r\nmusb_writew(epio, MUSB_TXCSR,\r\nmusb->context.index_regs[i].txcsr);\r\nmusb_writew(epio, MUSB_RXMAXP,\r\nmusb->context.index_regs[i].rxmaxp);\r\nmusb_writew(epio, MUSB_RXCSR,\r\nmusb->context.index_regs[i].rxcsr);\r\nif (musb->dyn_fifo) {\r\nmusb_write_txfifosz(musb_base,\r\nmusb->context.index_regs[i].txfifosz);\r\nmusb_write_rxfifosz(musb_base,\r\nmusb->context.index_regs[i].rxfifosz);\r\nmusb_write_txfifoadd(musb_base,\r\nmusb->context.index_regs[i].txfifoadd);\r\nmusb_write_rxfifoadd(musb_base,\r\nmusb->context.index_regs[i].rxfifoadd);\r\n}\r\nmusb_writeb(epio, MUSB_TXTYPE,\r\nmusb->context.index_regs[i].txtype);\r\nmusb_writeb(epio, MUSB_TXINTERVAL,\r\nmusb->context.index_regs[i].txinterval);\r\nmusb_writeb(epio, MUSB_RXTYPE,\r\nmusb->context.index_regs[i].rxtype);\r\nmusb_writeb(epio, MUSB_RXINTERVAL,\r\nmusb->context.index_regs[i].rxinterval);\r\nmusb_write_txfunaddr(musb_base, i,\r\nmusb->context.index_regs[i].txfunaddr);\r\nmusb_write_txhubaddr(musb_base, i,\r\nmusb->context.index_regs[i].txhubaddr);\r\nmusb_write_txhubport(musb_base, i,\r\nmusb->context.index_regs[i].txhubport);\r\nep_target_regs =\r\nmusb_read_target_reg_base(i, musb_base);\r\nmusb_write_rxfunaddr(ep_target_regs,\r\nmusb->context.index_regs[i].rxfunaddr);\r\nmusb_write_rxhubaddr(ep_target_regs,\r\nmusb->context.index_regs[i].rxhubaddr);\r\nmusb_write_rxhubport(ep_target_regs,\r\nmusb->context.index_regs[i].rxhubport);\r\n}\r\nmusb_writeb(musb_base, MUSB_INDEX, musb->context.index);\r\n}\r\nstatic int musb_suspend(struct device *dev)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (is_peripheral_active(musb)) {\r\n} else if (is_host_active(musb)) {\r\n}\r\nmusb_save_context(musb);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int musb_resume_noirq(struct device *dev)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nmusb_restore_context(musb);\r\nreturn 0;\r\n}\r\nstatic int musb_runtime_suspend(struct device *dev)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nmusb_save_context(musb);\r\nreturn 0;\r\n}\r\nstatic int musb_runtime_resume(struct device *dev)\r\n{\r\nstruct musb *musb = dev_to_musb(dev);\r\nstatic int first = 1;\r\nif (!first)\r\nmusb_restore_context(musb);\r\nfirst = 0;\r\nreturn 0;\r\n}
