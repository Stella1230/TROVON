static void fcopy_work_func(struct work_struct *dummy)\r\n{\r\nfcopy_respond_to_host(HV_E_FAIL);\r\n}\r\nstatic int fcopy_handle_handshake(u32 version)\r\n{\r\nswitch (version) {\r\ncase FCOPY_CURRENT_VERSION:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npr_info("FCP: user-mode registering done. Daemon version: %d\n",\r\nversion);\r\nfcopy_transaction.active = false;\r\nif (fcopy_transaction.fcopy_context)\r\nhv_fcopy_onchannelcallback(fcopy_transaction.fcopy_context);\r\nin_hand_shake = false;\r\nreturn 0;\r\n}\r\nstatic void fcopy_send_data(void)\r\n{\r\nstruct hv_start_fcopy *smsg_out = &fcopy_transaction.message;\r\nint operation = fcopy_transaction.fcopy_msg->operation;\r\nstruct hv_start_fcopy *smsg_in;\r\nswitch (operation) {\r\ncase START_FILE_COPY:\r\nmemset(smsg_out, 0, sizeof(struct hv_start_fcopy));\r\nsmsg_out->hdr.operation = operation;\r\nsmsg_in = (struct hv_start_fcopy *)fcopy_transaction.fcopy_msg;\r\nutf16s_to_utf8s((wchar_t *)smsg_in->file_name, W_MAX_PATH,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)smsg_out->file_name, W_MAX_PATH - 1);\r\nutf16s_to_utf8s((wchar_t *)smsg_in->path_name, W_MAX_PATH,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)smsg_out->path_name, W_MAX_PATH - 1);\r\nsmsg_out->copy_flags = smsg_in->copy_flags;\r\nsmsg_out->file_size = smsg_in->file_size;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nup(&fcopy_transaction.read_sema);\r\nreturn;\r\n}\r\nstatic void\r\nfcopy_respond_to_host(int error)\r\n{\r\nstruct icmsg_hdr *icmsghdr;\r\nu32 buf_len;\r\nstruct vmbus_channel *channel;\r\nu64 req_id;\r\nbuf_len = fcopy_transaction.recv_len;\r\nchannel = fcopy_transaction.recv_channel;\r\nreq_id = fcopy_transaction.recv_req_id;\r\nfcopy_transaction.active = false;\r\nicmsghdr = (struct icmsg_hdr *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr)];\r\nif (channel->onchannel_callback == NULL)\r\nreturn;\r\nicmsghdr->status = error;\r\nicmsghdr->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nvoid hv_fcopy_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct hv_fcopy_hdr *fcopy_msg;\r\nstruct icmsg_hdr *icmsghdr;\r\nstruct icmsg_negotiate *negop = NULL;\r\nint util_fw_version;\r\nint fcopy_srv_version;\r\nif (fcopy_transaction.active) {\r\nfcopy_transaction.fcopy_context = context;\r\nreturn;\r\n}\r\nvmbus_recvpacket(channel, recv_buffer, PAGE_SIZE * 2, &recvlen,\r\n&requestid);\r\nif (recvlen <= 0)\r\nreturn;\r\nicmsghdr = (struct icmsg_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdr->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nutil_fw_version = UTIL_FW_VERSION;\r\nfcopy_srv_version = WIN8_SRV_VERSION;\r\nvmbus_prep_negotiate_resp(icmsghdr, negop, recv_buffer,\r\nutil_fw_version, fcopy_srv_version);\r\n} else {\r\nfcopy_msg = (struct hv_fcopy_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nfcopy_transaction.active = true;\r\nfcopy_transaction.recv_len = recvlen;\r\nfcopy_transaction.recv_channel = channel;\r\nfcopy_transaction.recv_req_id = requestid;\r\nfcopy_transaction.fcopy_msg = fcopy_msg;\r\nschedule_delayed_work(&fcopy_work, 5*HZ);\r\nfcopy_send_data();\r\nreturn;\r\n}\r\nicmsghdr->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, recvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nstatic ssize_t fcopy_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nvoid *src;\r\nsize_t copy_size;\r\nint operation;\r\nif (down_interruptible(&fcopy_transaction.read_sema))\r\nreturn -EINTR;\r\nif (!opened)\r\nreturn -ENODEV;\r\noperation = fcopy_transaction.fcopy_msg->operation;\r\nif (operation == START_FILE_COPY) {\r\nsrc = &fcopy_transaction.message;\r\ncopy_size = sizeof(struct hv_start_fcopy);\r\nif (count < copy_size)\r\nreturn 0;\r\n} else {\r\nsrc = fcopy_transaction.fcopy_msg;\r\ncopy_size = sizeof(struct hv_do_fcopy);\r\nif (count < copy_size)\r\nreturn 0;\r\n}\r\nif (copy_to_user(buf, src, copy_size))\r\nreturn -EFAULT;\r\nreturn copy_size;\r\n}\r\nstatic ssize_t fcopy_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint response = 0;\r\nif (count != sizeof(int))\r\nreturn -EINVAL;\r\nif (copy_from_user(&response, buf, sizeof(int)))\r\nreturn -EFAULT;\r\nif (in_hand_shake) {\r\nif (fcopy_handle_handshake(response))\r\nreturn -EINVAL;\r\nreturn sizeof(int);\r\n}\r\nif (cancel_delayed_work_sync(&fcopy_work))\r\nfcopy_respond_to_host(response);\r\nreturn sizeof(int);\r\n}\r\nstatic int fcopy_open(struct inode *inode, struct file *f)\r\n{\r\nif (opened)\r\nreturn -EBUSY;\r\nopened = true;\r\nreturn 0;\r\n}\r\nstatic int fcopy_release(struct inode *inode, struct file *f)\r\n{\r\nin_hand_shake = true;\r\nopened = false;\r\nreturn 0;\r\n}\r\nstatic int fcopy_dev_init(void)\r\n{\r\nreturn misc_register(&fcopy_misc);\r\n}\r\nstatic void fcopy_dev_deinit(void)\r\n{\r\nopened = false;\r\nup(&fcopy_transaction.read_sema);\r\nmisc_deregister(&fcopy_misc);\r\n}\r\nint hv_fcopy_init(struct hv_util_service *srv)\r\n{\r\nrecv_buffer = srv->recv_buffer;\r\nfcopy_transaction.active = true;\r\nsema_init(&fcopy_transaction.read_sema, 0);\r\nreturn fcopy_dev_init();\r\n}\r\nvoid hv_fcopy_deinit(void)\r\n{\r\ncancel_delayed_work_sync(&fcopy_work);\r\nfcopy_dev_deinit();\r\n}
