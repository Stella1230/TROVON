static int act8865_pdata_from_dt(struct device *dev,\r\nstruct device_node **of_node,\r\nstruct act8865_platform_data *pdata,\r\nunsigned long type)\r\n{\r\nint matched, i, num_matches;\r\nstruct device_node *np;\r\nstruct act8865_regulator_data *regulator;\r\nstruct of_regulator_match *matches;\r\nnp = of_get_child_by_name(dev->of_node, "regulators");\r\nif (!np) {\r\ndev_err(dev, "missing 'regulators' subnode in DT\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (type) {\r\ncase ACT8846:\r\nmatches = act8846_matches;\r\nnum_matches = ARRAY_SIZE(act8846_matches);\r\nbreak;\r\ncase ACT8865:\r\nmatches = act8865_matches;\r\nnum_matches = ARRAY_SIZE(act8865_matches);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "invalid device id %lu\n", type);\r\nreturn -EINVAL;\r\n}\r\nmatched = of_regulator_match(dev, np, matches, num_matches);\r\nof_node_put(np);\r\nif (matched <= 0)\r\nreturn matched;\r\npdata->regulators = devm_kzalloc(dev,\r\nsizeof(struct act8865_regulator_data) *\r\nnum_matches, GFP_KERNEL);\r\nif (!pdata->regulators)\r\nreturn -ENOMEM;\r\npdata->num_regulators = num_matches;\r\nregulator = pdata->regulators;\r\nfor (i = 0; i < num_matches; i++) {\r\nregulator->id = i;\r\nregulator->name = matches[i].name;\r\nregulator->platform_data = matches[i].init_data;\r\nof_node[i] = matches[i].of_node;\r\nregulator++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int act8865_pdata_from_dt(struct device *dev,\r\nstruct device_node **of_node,\r\nstruct act8865_platform_data *pdata,\r\nunsigned long type)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct regulator_init_data\r\n*act8865_get_init_data(int id, struct act8865_platform_data *pdata)\r\n{\r\nint i;\r\nif (!pdata)\r\nreturn NULL;\r\nfor (i = 0; i < pdata->num_regulators; i++) {\r\nif (pdata->regulators[i].id == id)\r\nreturn pdata->regulators[i].platform_data;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int act8865_pmic_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstatic const struct regulator_desc *regulators;\r\nstruct act8865_platform_data pdata_of, *pdata;\r\nstruct device *dev = &client->dev;\r\nstruct device_node **of_node;\r\nint i, ret, num_regulators;\r\nstruct act8865 *act8865;\r\nunsigned long type;\r\npdata = dev_get_platdata(dev);\r\nif (dev->of_node && !pdata) {\r\nconst struct of_device_id *id;\r\nid = of_match_device(of_match_ptr(act8865_dt_ids), dev);\r\nif (!id)\r\nreturn -ENODEV;\r\ntype = (unsigned long) id->data;\r\n} else {\r\ntype = i2c_id->driver_data;\r\n}\r\nswitch (type) {\r\ncase ACT8846:\r\nregulators = act8846_regulators;\r\nnum_regulators = ARRAY_SIZE(act8846_regulators);\r\nbreak;\r\ncase ACT8865:\r\nregulators = act8865_regulators;\r\nnum_regulators = ARRAY_SIZE(act8865_regulators);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "invalid device id %lu\n", type);\r\nreturn -EINVAL;\r\n}\r\nof_node = devm_kzalloc(dev, sizeof(struct device_node *) *\r\nnum_regulators, GFP_KERNEL);\r\nif (!of_node)\r\nreturn -ENOMEM;\r\nif (dev->of_node && !pdata) {\r\nret = act8865_pdata_from_dt(dev, of_node, &pdata_of, type);\r\nif (ret < 0)\r\nreturn ret;\r\npdata = &pdata_of;\r\n}\r\nif (pdata->num_regulators > num_regulators) {\r\ndev_err(dev, "too many regulators: %d\n",\r\npdata->num_regulators);\r\nreturn -EINVAL;\r\n}\r\nact8865 = devm_kzalloc(dev, sizeof(struct act8865), GFP_KERNEL);\r\nif (!act8865)\r\nreturn -ENOMEM;\r\nact8865->regmap = devm_regmap_init_i2c(client, &act8865_regmap_config);\r\nif (IS_ERR(act8865->regmap)) {\r\nret = PTR_ERR(act8865->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < num_regulators; i++) {\r\nconst struct regulator_desc *desc = &regulators[i];\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\nconfig.dev = dev;\r\nconfig.init_data = act8865_get_init_data(desc->id, pdata);\r\nconfig.of_node = of_node[i];\r\nconfig.driver_data = act8865;\r\nconfig.regmap = act8865->regmap;\r\nrdev = devm_regulator_register(&client->dev, desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(dev, "failed to register %s\n", desc->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\ni2c_set_clientdata(client, act8865);\r\ndevm_kfree(dev, of_node);\r\nreturn 0;\r\n}
