static inline struct clk_fixup_mux *to_clk_fixup_mux(struct clk_hw *hw)\r\n{\r\nstruct clk_mux *mux = to_clk_mux(hw);\r\nreturn container_of(mux, struct clk_fixup_mux, mux);\r\n}\r\nstatic u8 clk_fixup_mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_fixup_mux *fixup_mux = to_clk_fixup_mux(hw);\r\nreturn fixup_mux->ops->get_parent(&fixup_mux->mux.hw);\r\n}\r\nstatic int clk_fixup_mux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_fixup_mux *fixup_mux = to_clk_fixup_mux(hw);\r\nstruct clk_mux *mux = to_clk_mux(hw);\r\nunsigned long flags = 0;\r\nu32 val;\r\nspin_lock_irqsave(mux->lock, flags);\r\nval = readl(mux->reg);\r\nval &= ~(mux->mask << mux->shift);\r\nval |= index << mux->shift;\r\nfixup_mux->fixup(&val);\r\nwritel(val, mux->reg);\r\nspin_unlock_irqrestore(mux->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *imx_clk_fixup_mux(const char *name, void __iomem *reg,\r\nu8 shift, u8 width, const char **parents,\r\nint num_parents, void (*fixup)(u32 *val))\r\n{\r\nstruct clk_fixup_mux *fixup_mux;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nif (!fixup)\r\nreturn ERR_PTR(-EINVAL);\r\nfixup_mux = kzalloc(sizeof(*fixup_mux), GFP_KERNEL);\r\nif (!fixup_mux)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &clk_fixup_mux_ops;\r\ninit.parent_names = parents;\r\ninit.num_parents = num_parents;\r\ninit.flags = 0;\r\nfixup_mux->mux.reg = reg;\r\nfixup_mux->mux.shift = shift;\r\nfixup_mux->mux.mask = BIT(width) - 1;\r\nfixup_mux->mux.lock = &imx_ccm_lock;\r\nfixup_mux->mux.hw.init = &init;\r\nfixup_mux->ops = &clk_mux_ops;\r\nfixup_mux->fixup = fixup;\r\nclk = clk_register(NULL, &fixup_mux->mux.hw);\r\nif (IS_ERR(clk))\r\nkfree(fixup_mux);\r\nreturn clk;\r\n}
