static inline int srmmu_pmd_none(pmd_t pmd)\r\n{ return !(pmd_val(pmd) & 0xFFFFFFF); }\r\nstatic inline void srmmu_ctxd_set(ctxd_t *ctxp, pgd_t *pgdp)\r\n{ set_pte((pte_t *)ctxp, (SRMMU_ET_PTD | (__nocache_pa((unsigned long) pgdp) >> 4))); }\r\nvoid pmd_set(pmd_t *pmdp, pte_t *ptep)\r\n{\r\nunsigned long ptp;\r\nint i;\r\nptp = __nocache_pa((unsigned long) ptep) >> 4;\r\nfor (i = 0; i < PTRS_PER_PTE/SRMMU_REAL_PTRS_PER_PTE; i++) {\r\nset_pte((pte_t *)&pmdp->pmdv[i], SRMMU_ET_PTD | ptp);\r\nptp += (SRMMU_REAL_PTRS_PER_PTE*sizeof(pte_t) >> 4);\r\n}\r\n}\r\nvoid pmd_populate(struct mm_struct *mm, pmd_t *pmdp, struct page *ptep)\r\n{\r\nunsigned long ptp;\r\nint i;\r\nptp = page_to_pfn(ptep) << (PAGE_SHIFT-4);\r\nfor (i = 0; i < PTRS_PER_PTE/SRMMU_REAL_PTRS_PER_PTE; i++) {\r\nset_pte((pte_t *)&pmdp->pmdv[i], SRMMU_ET_PTD | ptp);\r\nptp += (SRMMU_REAL_PTRS_PER_PTE*sizeof(pte_t) >> 4);\r\n}\r\n}\r\npte_t *pte_offset_kernel(pmd_t *dir, unsigned long address)\r\n{\r\nvoid *pte;\r\npte = __nocache_va((dir->pmdv[0] & SRMMU_PTD_PMASK) << 4);\r\nreturn (pte_t *) pte +\r\n((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));\r\n}\r\nstatic void *__srmmu_get_nocache(int size, int align)\r\n{\r\nint offset;\r\nunsigned long addr;\r\nif (size < SRMMU_NOCACHE_BITMAP_SHIFT) {\r\nprintk(KERN_ERR "Size 0x%x too small for nocache request\n",\r\nsize);\r\nsize = SRMMU_NOCACHE_BITMAP_SHIFT;\r\n}\r\nif (size & (SRMMU_NOCACHE_BITMAP_SHIFT - 1)) {\r\nprintk(KERN_ERR "Size 0x%x unaligned int nocache request\n",\r\nsize);\r\nsize += SRMMU_NOCACHE_BITMAP_SHIFT - 1;\r\n}\r\nBUG_ON(align > SRMMU_NOCACHE_ALIGN_MAX);\r\noffset = bit_map_string_get(&srmmu_nocache_map,\r\nsize >> SRMMU_NOCACHE_BITMAP_SHIFT,\r\nalign >> SRMMU_NOCACHE_BITMAP_SHIFT);\r\nif (offset == -1) {\r\nprintk(KERN_ERR "srmmu: out of nocache %d: %d/%d\n",\r\nsize, (int) srmmu_nocache_size,\r\nsrmmu_nocache_map.used << SRMMU_NOCACHE_BITMAP_SHIFT);\r\nreturn NULL;\r\n}\r\naddr = SRMMU_NOCACHE_VADDR + (offset << SRMMU_NOCACHE_BITMAP_SHIFT);\r\nreturn (void *)addr;\r\n}\r\nvoid *srmmu_get_nocache(int size, int align)\r\n{\r\nvoid *tmp;\r\ntmp = __srmmu_get_nocache(size, align);\r\nif (tmp)\r\nmemset(tmp, 0, size);\r\nreturn tmp;\r\n}\r\nvoid srmmu_free_nocache(void *addr, int size)\r\n{\r\nunsigned long vaddr;\r\nint offset;\r\nvaddr = (unsigned long)addr;\r\nif (vaddr < SRMMU_NOCACHE_VADDR) {\r\nprintk("Vaddr %lx is smaller than nocache base 0x%lx\n",\r\nvaddr, (unsigned long)SRMMU_NOCACHE_VADDR);\r\nBUG();\r\n}\r\nif (vaddr + size > srmmu_nocache_end) {\r\nprintk("Vaddr %lx is bigger than nocache end 0x%lx\n",\r\nvaddr, srmmu_nocache_end);\r\nBUG();\r\n}\r\nif (!is_power_of_2(size)) {\r\nprintk("Size 0x%x is not a power of 2\n", size);\r\nBUG();\r\n}\r\nif (size < SRMMU_NOCACHE_BITMAP_SHIFT) {\r\nprintk("Size 0x%x is too small\n", size);\r\nBUG();\r\n}\r\nif (vaddr & (size - 1)) {\r\nprintk("Vaddr %lx is not aligned to size 0x%x\n", vaddr, size);\r\nBUG();\r\n}\r\noffset = (vaddr - SRMMU_NOCACHE_VADDR) >> SRMMU_NOCACHE_BITMAP_SHIFT;\r\nsize = size >> SRMMU_NOCACHE_BITMAP_SHIFT;\r\nbit_map_clear(&srmmu_nocache_map, offset, size);\r\n}\r\nstatic unsigned long __init probe_memory(void)\r\n{\r\nunsigned long total = 0;\r\nint i;\r\nfor (i = 0; sp_banks[i].num_bytes; i++)\r\ntotal += sp_banks[i].num_bytes;\r\nreturn total;\r\n}\r\nstatic void __init srmmu_nocache_calcsize(void)\r\n{\r\nunsigned long sysmemavail = probe_memory() / 1024;\r\nint srmmu_nocache_npages;\r\nsrmmu_nocache_npages =\r\nsysmemavail / SRMMU_NOCACHE_ALCRATIO / 1024 * 256;\r\nif (srmmu_nocache_npages < SRMMU_MIN_NOCACHE_PAGES)\r\nsrmmu_nocache_npages = SRMMU_MIN_NOCACHE_PAGES;\r\nif (srmmu_nocache_npages > SRMMU_MAX_NOCACHE_PAGES)\r\nsrmmu_nocache_npages = SRMMU_MAX_NOCACHE_PAGES;\r\nsrmmu_nocache_size = srmmu_nocache_npages * PAGE_SIZE;\r\nsrmmu_nocache_end = SRMMU_NOCACHE_VADDR + srmmu_nocache_size;\r\n}\r\nstatic void __init srmmu_nocache_init(void)\r\n{\r\nvoid *srmmu_nocache_bitmap;\r\nunsigned int bitmap_bits;\r\npgd_t *pgd;\r\npmd_t *pmd;\r\npte_t *pte;\r\nunsigned long paddr, vaddr;\r\nunsigned long pteval;\r\nbitmap_bits = srmmu_nocache_size >> SRMMU_NOCACHE_BITMAP_SHIFT;\r\nsrmmu_nocache_pool = __alloc_bootmem(srmmu_nocache_size,\r\nSRMMU_NOCACHE_ALIGN_MAX, 0UL);\r\nmemset(srmmu_nocache_pool, 0, srmmu_nocache_size);\r\nsrmmu_nocache_bitmap =\r\n__alloc_bootmem(BITS_TO_LONGS(bitmap_bits) * sizeof(long),\r\nSMP_CACHE_BYTES, 0UL);\r\nbit_map_init(&srmmu_nocache_map, srmmu_nocache_bitmap, bitmap_bits);\r\nsrmmu_swapper_pg_dir = __srmmu_get_nocache(SRMMU_PGD_TABLE_SIZE, SRMMU_PGD_TABLE_SIZE);\r\nmemset(__nocache_fix(srmmu_swapper_pg_dir), 0, SRMMU_PGD_TABLE_SIZE);\r\ninit_mm.pgd = srmmu_swapper_pg_dir;\r\nsrmmu_early_allocate_ptable_skeleton(SRMMU_NOCACHE_VADDR, srmmu_nocache_end);\r\npaddr = __pa((unsigned long)srmmu_nocache_pool);\r\nvaddr = SRMMU_NOCACHE_VADDR;\r\nwhile (vaddr < srmmu_nocache_end) {\r\npgd = pgd_offset_k(vaddr);\r\npmd = pmd_offset(__nocache_fix(pgd), vaddr);\r\npte = pte_offset_kernel(__nocache_fix(pmd), vaddr);\r\npteval = ((paddr >> 4) | SRMMU_ET_PTE | SRMMU_PRIV);\r\nif (srmmu_cache_pagetables)\r\npteval |= SRMMU_CACHE;\r\nset_pte(__nocache_fix(pte), __pte(pteval));\r\nvaddr += PAGE_SIZE;\r\npaddr += PAGE_SIZE;\r\n}\r\nflush_cache_all();\r\nflush_tlb_all();\r\n}\r\npgd_t *get_pgd_fast(void)\r\n{\r\npgd_t *pgd = NULL;\r\npgd = __srmmu_get_nocache(SRMMU_PGD_TABLE_SIZE, SRMMU_PGD_TABLE_SIZE);\r\nif (pgd) {\r\npgd_t *init = pgd_offset_k(0);\r\nmemset(pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));\r\nmemcpy(pgd + USER_PTRS_PER_PGD, init + USER_PTRS_PER_PGD,\r\n(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));\r\n}\r\nreturn pgd;\r\n}\r\npgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long address)\r\n{\r\nunsigned long pte;\r\nstruct page *page;\r\nif ((pte = (unsigned long)pte_alloc_one_kernel(mm, address)) == 0)\r\nreturn NULL;\r\npage = pfn_to_page(__nocache_pa(pte) >> PAGE_SHIFT);\r\nif (!pgtable_page_ctor(page)) {\r\n__free_page(page);\r\nreturn NULL;\r\n}\r\nreturn page;\r\n}\r\nvoid pte_free(struct mm_struct *mm, pgtable_t pte)\r\n{\r\nunsigned long p;\r\npgtable_page_dtor(pte);\r\np = (unsigned long)page_address(pte);\r\nif (p == 0)\r\nBUG();\r\np = page_to_pfn(pte) << PAGE_SHIFT;\r\nsrmmu_free_nocache(__nocache_va(p), PTE_SIZE);\r\n}\r\nstatic inline void remove_from_ctx_list(struct ctx_list *entry)\r\n{\r\nentry->next->prev = entry->prev;\r\nentry->prev->next = entry->next;\r\n}\r\nstatic inline void add_to_ctx_list(struct ctx_list *head, struct ctx_list *entry)\r\n{\r\nentry->next = head;\r\n(entry->prev = head->prev)->next = entry;\r\nhead->prev = entry;\r\n}\r\nstatic inline void alloc_context(struct mm_struct *old_mm, struct mm_struct *mm)\r\n{\r\nstruct ctx_list *ctxp;\r\nctxp = ctx_free.next;\r\nif (ctxp != &ctx_free) {\r\nremove_from_ctx_list(ctxp);\r\nadd_to_used_ctxlist(ctxp);\r\nmm->context = ctxp->ctx_number;\r\nctxp->ctx_mm = mm;\r\nreturn;\r\n}\r\nctxp = ctx_used.next;\r\nif (ctxp->ctx_mm == old_mm)\r\nctxp = ctxp->next;\r\nif (ctxp == &ctx_used)\r\npanic("out of mmu contexts");\r\nflush_cache_mm(ctxp->ctx_mm);\r\nflush_tlb_mm(ctxp->ctx_mm);\r\nremove_from_ctx_list(ctxp);\r\nadd_to_used_ctxlist(ctxp);\r\nctxp->ctx_mm->context = NO_CONTEXT;\r\nctxp->ctx_mm = mm;\r\nmm->context = ctxp->ctx_number;\r\n}\r\nstatic inline void free_context(int context)\r\n{\r\nstruct ctx_list *ctx_old;\r\nctx_old = ctx_list_pool + context;\r\nremove_from_ctx_list(ctx_old);\r\nadd_to_free_ctxlist(ctx_old);\r\n}\r\nstatic void __init sparc_context_init(int numctx)\r\n{\r\nint ctx;\r\nunsigned long size;\r\nsize = numctx * sizeof(struct ctx_list);\r\nctx_list_pool = __alloc_bootmem(size, SMP_CACHE_BYTES, 0UL);\r\nfor (ctx = 0; ctx < numctx; ctx++) {\r\nstruct ctx_list *clist;\r\nclist = (ctx_list_pool + ctx);\r\nclist->ctx_number = ctx;\r\nclist->ctx_mm = NULL;\r\n}\r\nctx_free.next = ctx_free.prev = &ctx_free;\r\nctx_used.next = ctx_used.prev = &ctx_used;\r\nfor (ctx = 0; ctx < numctx; ctx++)\r\nadd_to_free_ctxlist(ctx_list_pool + ctx);\r\n}\r\nvoid switch_mm(struct mm_struct *old_mm, struct mm_struct *mm,\r\nstruct task_struct *tsk)\r\n{\r\nif (mm->context == NO_CONTEXT) {\r\nspin_lock(&srmmu_context_spinlock);\r\nalloc_context(old_mm, mm);\r\nspin_unlock(&srmmu_context_spinlock);\r\nsrmmu_ctxd_set(&srmmu_context_table[mm->context], mm->pgd);\r\n}\r\nif (sparc_cpu_model == sparc_leon)\r\nleon_switch_mm();\r\nif (is_hypersparc)\r\nhyper_flush_whole_icache();\r\nsrmmu_set_context(mm->context);\r\n}\r\nstatic inline void srmmu_mapioaddr(unsigned long physaddr,\r\nunsigned long virt_addr, int bus_type)\r\n{\r\npgd_t *pgdp;\r\npmd_t *pmdp;\r\npte_t *ptep;\r\nunsigned long tmp;\r\nphysaddr &= PAGE_MASK;\r\npgdp = pgd_offset_k(virt_addr);\r\npmdp = pmd_offset(pgdp, virt_addr);\r\nptep = pte_offset_kernel(pmdp, virt_addr);\r\ntmp = (physaddr >> 4) | SRMMU_ET_PTE;\r\ntmp |= (bus_type << 28);\r\ntmp |= SRMMU_PRIV;\r\n__flush_page_to_ram(virt_addr);\r\nset_pte(ptep, __pte(tmp));\r\n}\r\nvoid srmmu_mapiorange(unsigned int bus, unsigned long xpa,\r\nunsigned long xva, unsigned int len)\r\n{\r\nwhile (len != 0) {\r\nlen -= PAGE_SIZE;\r\nsrmmu_mapioaddr(xpa, xva, bus);\r\nxva += PAGE_SIZE;\r\nxpa += PAGE_SIZE;\r\n}\r\nflush_tlb_all();\r\n}\r\nstatic inline void srmmu_unmapioaddr(unsigned long virt_addr)\r\n{\r\npgd_t *pgdp;\r\npmd_t *pmdp;\r\npte_t *ptep;\r\npgdp = pgd_offset_k(virt_addr);\r\npmdp = pmd_offset(pgdp, virt_addr);\r\nptep = pte_offset_kernel(pmdp, virt_addr);\r\n__pte_clear(ptep);\r\n}\r\nvoid srmmu_unmapiorange(unsigned long virt_addr, unsigned int len)\r\n{\r\nwhile (len != 0) {\r\nlen -= PAGE_SIZE;\r\nsrmmu_unmapioaddr(virt_addr);\r\nvirt_addr += PAGE_SIZE;\r\n}\r\nflush_tlb_all();\r\n}\r\nstatic void __init early_pgtable_allocfail(char *type)\r\n{\r\nprom_printf("inherit_prom_mappings: Cannot alloc kernel %s.\n", type);\r\nprom_halt();\r\n}\r\nstatic void __init srmmu_early_allocate_ptable_skeleton(unsigned long start,\r\nunsigned long end)\r\n{\r\npgd_t *pgdp;\r\npmd_t *pmdp;\r\npte_t *ptep;\r\nwhile (start < end) {\r\npgdp = pgd_offset_k(start);\r\nif (pgd_none(*(pgd_t *)__nocache_fix(pgdp))) {\r\npmdp = __srmmu_get_nocache(\r\nSRMMU_PMD_TABLE_SIZE, SRMMU_PMD_TABLE_SIZE);\r\nif (pmdp == NULL)\r\nearly_pgtable_allocfail("pmd");\r\nmemset(__nocache_fix(pmdp), 0, SRMMU_PMD_TABLE_SIZE);\r\npgd_set(__nocache_fix(pgdp), pmdp);\r\n}\r\npmdp = pmd_offset(__nocache_fix(pgdp), start);\r\nif (srmmu_pmd_none(*(pmd_t *)__nocache_fix(pmdp))) {\r\nptep = __srmmu_get_nocache(PTE_SIZE, PTE_SIZE);\r\nif (ptep == NULL)\r\nearly_pgtable_allocfail("pte");\r\nmemset(__nocache_fix(ptep), 0, PTE_SIZE);\r\npmd_set(__nocache_fix(pmdp), ptep);\r\n}\r\nif (start > (0xffffffffUL - PMD_SIZE))\r\nbreak;\r\nstart = (start + PMD_SIZE) & PMD_MASK;\r\n}\r\n}\r\nstatic void __init srmmu_allocate_ptable_skeleton(unsigned long start,\r\nunsigned long end)\r\n{\r\npgd_t *pgdp;\r\npmd_t *pmdp;\r\npte_t *ptep;\r\nwhile (start < end) {\r\npgdp = pgd_offset_k(start);\r\nif (pgd_none(*pgdp)) {\r\npmdp = __srmmu_get_nocache(SRMMU_PMD_TABLE_SIZE, SRMMU_PMD_TABLE_SIZE);\r\nif (pmdp == NULL)\r\nearly_pgtable_allocfail("pmd");\r\nmemset(pmdp, 0, SRMMU_PMD_TABLE_SIZE);\r\npgd_set(pgdp, pmdp);\r\n}\r\npmdp = pmd_offset(pgdp, start);\r\nif (srmmu_pmd_none(*pmdp)) {\r\nptep = __srmmu_get_nocache(PTE_SIZE,\r\nPTE_SIZE);\r\nif (ptep == NULL)\r\nearly_pgtable_allocfail("pte");\r\nmemset(ptep, 0, PTE_SIZE);\r\npmd_set(pmdp, ptep);\r\n}\r\nif (start > (0xffffffffUL - PMD_SIZE))\r\nbreak;\r\nstart = (start + PMD_SIZE) & PMD_MASK;\r\n}\r\n}\r\nstatic inline unsigned long srmmu_probe(unsigned long vaddr)\r\n{\r\nunsigned long retval;\r\nif (sparc_cpu_model != sparc_leon) {\r\nvaddr &= PAGE_MASK;\r\n__asm__ __volatile__("lda [%1] %2, %0\n\t" :\r\n"=r" (retval) :\r\n"r" (vaddr | 0x400), "i" (ASI_M_FLUSH_PROBE));\r\n} else {\r\nretval = leon_swprobe(vaddr, NULL);\r\n}\r\nreturn retval;\r\n}\r\nstatic void __init srmmu_inherit_prom_mappings(unsigned long start,\r\nunsigned long end)\r\n{\r\nunsigned long probed;\r\nunsigned long addr;\r\npgd_t *pgdp;\r\npmd_t *pmdp;\r\npte_t *ptep;\r\nint what;\r\nwhile (start <= end) {\r\nif (start == 0)\r\nbreak;\r\nif (start == 0xfef00000)\r\nstart = KADB_DEBUGGER_BEGVM;\r\nprobed = srmmu_probe(start);\r\nif (!probed) {\r\nstart += PAGE_SIZE;\r\ncontinue;\r\n}\r\nwhat = 0;\r\naddr = start - PAGE_SIZE;\r\nif (!(start & ~(SRMMU_REAL_PMD_MASK))) {\r\nif (srmmu_probe(addr + SRMMU_REAL_PMD_SIZE) == probed)\r\nwhat = 1;\r\n}\r\nif (!(start & ~(SRMMU_PGDIR_MASK))) {\r\nif (srmmu_probe(addr + SRMMU_PGDIR_SIZE) == probed)\r\nwhat = 2;\r\n}\r\npgdp = pgd_offset_k(start);\r\nif (what == 2) {\r\n*(pgd_t *)__nocache_fix(pgdp) = __pgd(probed);\r\nstart += SRMMU_PGDIR_SIZE;\r\ncontinue;\r\n}\r\nif (pgd_none(*(pgd_t *)__nocache_fix(pgdp))) {\r\npmdp = __srmmu_get_nocache(SRMMU_PMD_TABLE_SIZE,\r\nSRMMU_PMD_TABLE_SIZE);\r\nif (pmdp == NULL)\r\nearly_pgtable_allocfail("pmd");\r\nmemset(__nocache_fix(pmdp), 0, SRMMU_PMD_TABLE_SIZE);\r\npgd_set(__nocache_fix(pgdp), pmdp);\r\n}\r\npmdp = pmd_offset(__nocache_fix(pgdp), start);\r\nif (srmmu_pmd_none(*(pmd_t *)__nocache_fix(pmdp))) {\r\nptep = __srmmu_get_nocache(PTE_SIZE, PTE_SIZE);\r\nif (ptep == NULL)\r\nearly_pgtable_allocfail("pte");\r\nmemset(__nocache_fix(ptep), 0, PTE_SIZE);\r\npmd_set(__nocache_fix(pmdp), ptep);\r\n}\r\nif (what == 1) {\r\nunsigned int x;\r\nunsigned long *val;\r\nx = (start >> PMD_SHIFT) & 15;\r\nval = &pmdp->pmdv[x];\r\n*(unsigned long *)__nocache_fix(val) = probed;\r\nstart += SRMMU_REAL_PMD_SIZE;\r\ncontinue;\r\n}\r\nptep = pte_offset_kernel(__nocache_fix(pmdp), start);\r\n*(pte_t *)__nocache_fix(ptep) = __pte(probed);\r\nstart += PAGE_SIZE;\r\n}\r\n}\r\nstatic void __init do_large_mapping(unsigned long vaddr, unsigned long phys_base)\r\n{\r\npgd_t *pgdp = pgd_offset_k(vaddr);\r\nunsigned long big_pte;\r\nbig_pte = KERNEL_PTE(phys_base >> 4);\r\n*(pgd_t *)__nocache_fix(pgdp) = __pgd(big_pte);\r\n}\r\nstatic unsigned long __init map_spbank(unsigned long vbase, int sp_entry)\r\n{\r\nunsigned long pstart = (sp_banks[sp_entry].base_addr & SRMMU_PGDIR_MASK);\r\nunsigned long vstart = (vbase & SRMMU_PGDIR_MASK);\r\nunsigned long vend = SRMMU_PGDIR_ALIGN(vbase + sp_banks[sp_entry].num_bytes);\r\nconst unsigned long min_vaddr = PAGE_OFFSET;\r\nconst unsigned long max_vaddr = PAGE_OFFSET + SRMMU_MAXMEM;\r\nif (vstart < min_vaddr || vstart >= max_vaddr)\r\nreturn vstart;\r\nif (vend > max_vaddr || vend < min_vaddr)\r\nvend = max_vaddr;\r\nwhile (vstart < vend) {\r\ndo_large_mapping(vstart, pstart);\r\nvstart += SRMMU_PGDIR_SIZE; pstart += SRMMU_PGDIR_SIZE;\r\n}\r\nreturn vstart;\r\n}\r\nstatic void __init map_kernel(void)\r\n{\r\nint i;\r\nif (phys_base > 0) {\r\ndo_large_mapping(PAGE_OFFSET, phys_base);\r\n}\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nmap_spbank((unsigned long)__va(sp_banks[i].base_addr), i);\r\n}\r\n}\r\nvoid __init srmmu_paging_init(void)\r\n{\r\nint i;\r\nphandle cpunode;\r\nchar node_str[128];\r\npgd_t *pgd;\r\npmd_t *pmd;\r\npte_t *pte;\r\nunsigned long pages_avail;\r\ninit_mm.context = (unsigned long) NO_CONTEXT;\r\nsparc_iomap.start = SUN4M_IOBASE_VADDR;\r\nif (sparc_cpu_model == sun4d)\r\nnum_contexts = 65536;\r\nelse {\r\ncpunode = prom_getchild(prom_root_node);\r\nnum_contexts = 0;\r\nwhile (cpunode != 0) {\r\nprom_getstring(cpunode, "device_type", node_str, sizeof(node_str));\r\nif (!strcmp(node_str, "cpu")) {\r\nnum_contexts = prom_getintdefault(cpunode, "mmu-nctx", 0x8);\r\nbreak;\r\n}\r\ncpunode = prom_getsibling(cpunode);\r\n}\r\n}\r\nif (!num_contexts) {\r\nprom_printf("Something wrong, can't find cpu node in paging_init.\n");\r\nprom_halt();\r\n}\r\npages_avail = 0;\r\nlast_valid_pfn = bootmem_init(&pages_avail);\r\nsrmmu_nocache_calcsize();\r\nsrmmu_nocache_init();\r\nsrmmu_inherit_prom_mappings(0xfe400000, (LINUX_OPPROM_ENDVM - PAGE_SIZE));\r\nmap_kernel();\r\nsrmmu_context_table = __srmmu_get_nocache(num_contexts * sizeof(ctxd_t), num_contexts * sizeof(ctxd_t));\r\nsrmmu_ctx_table_phys = (ctxd_t *)__nocache_pa((unsigned long)srmmu_context_table);\r\nfor (i = 0; i < num_contexts; i++)\r\nsrmmu_ctxd_set((ctxd_t *)__nocache_fix(&srmmu_context_table[i]), srmmu_swapper_pg_dir);\r\nflush_cache_all();\r\nsrmmu_set_ctable_ptr((unsigned long)srmmu_ctx_table_phys);\r\n#ifdef CONFIG_SMP\r\nlocal_ops->tlb_all();\r\n#else\r\nflush_tlb_all();\r\n#endif\r\npoke_srmmu();\r\nsrmmu_allocate_ptable_skeleton(sparc_iomap.start, IOBASE_END);\r\nsrmmu_allocate_ptable_skeleton(DVMA_VADDR, DVMA_END);\r\nsrmmu_allocate_ptable_skeleton(\r\n__fix_to_virt(__end_of_fixed_addresses - 1), FIXADDR_TOP);\r\nsrmmu_allocate_ptable_skeleton(PKMAP_BASE, PKMAP_END);\r\npgd = pgd_offset_k(PKMAP_BASE);\r\npmd = pmd_offset(pgd, PKMAP_BASE);\r\npte = pte_offset_kernel(pmd, PKMAP_BASE);\r\npkmap_page_table = pte;\r\nflush_cache_all();\r\nflush_tlb_all();\r\nsparc_context_init(num_contexts);\r\nkmap_init();\r\n{\r\nunsigned long zones_size[MAX_NR_ZONES];\r\nunsigned long zholes_size[MAX_NR_ZONES];\r\nunsigned long npages;\r\nint znum;\r\nfor (znum = 0; znum < MAX_NR_ZONES; znum++)\r\nzones_size[znum] = zholes_size[znum] = 0;\r\nnpages = max_low_pfn - pfn_base;\r\nzones_size[ZONE_DMA] = npages;\r\nzholes_size[ZONE_DMA] = npages - pages_avail;\r\nnpages = highend_pfn - max_low_pfn;\r\nzones_size[ZONE_HIGHMEM] = npages;\r\nzholes_size[ZONE_HIGHMEM] = npages - calc_highpages();\r\nfree_area_init_node(0, zones_size, pfn_base, zholes_size);\r\n}\r\n}\r\nvoid mmu_info(struct seq_file *m)\r\n{\r\nseq_printf(m,\r\n"MMU type\t: %s\n"\r\n"contexts\t: %d\n"\r\n"nocache total\t: %ld\n"\r\n"nocache used\t: %d\n",\r\nsrmmu_name,\r\nnum_contexts,\r\nsrmmu_nocache_size,\r\nsrmmu_nocache_map.used << SRMMU_NOCACHE_BITMAP_SHIFT);\r\n}\r\nint init_new_context(struct task_struct *tsk, struct mm_struct *mm)\r\n{\r\nmm->context = NO_CONTEXT;\r\nreturn 0;\r\n}\r\nvoid destroy_context(struct mm_struct *mm)\r\n{\r\nif (mm->context != NO_CONTEXT) {\r\nflush_cache_mm(mm);\r\nsrmmu_ctxd_set(&srmmu_context_table[mm->context], srmmu_swapper_pg_dir);\r\nflush_tlb_mm(mm);\r\nspin_lock(&srmmu_context_spinlock);\r\nfree_context(mm->context);\r\nspin_unlock(&srmmu_context_spinlock);\r\nmm->context = NO_CONTEXT;\r\n}\r\n}\r\nstatic void __init srmmu_is_bad(void)\r\n{\r\nprom_printf("Could not determine SRMMU chip type.\n");\r\nprom_halt();\r\n}\r\nstatic void __init init_vac_layout(void)\r\n{\r\nphandle nd;\r\nint cache_lines;\r\nchar node_str[128];\r\n#ifdef CONFIG_SMP\r\nint cpu = 0;\r\nunsigned long max_size = 0;\r\nunsigned long min_line_size = 0x10000000;\r\n#endif\r\nnd = prom_getchild(prom_root_node);\r\nwhile ((nd = prom_getsibling(nd)) != 0) {\r\nprom_getstring(nd, "device_type", node_str, sizeof(node_str));\r\nif (!strcmp(node_str, "cpu")) {\r\nvac_line_size = prom_getint(nd, "cache-line-size");\r\nif (vac_line_size == -1) {\r\nprom_printf("can't determine cache-line-size, halting.\n");\r\nprom_halt();\r\n}\r\ncache_lines = prom_getint(nd, "cache-nlines");\r\nif (cache_lines == -1) {\r\nprom_printf("can't determine cache-nlines, halting.\n");\r\nprom_halt();\r\n}\r\nvac_cache_size = cache_lines * vac_line_size;\r\n#ifdef CONFIG_SMP\r\nif (vac_cache_size > max_size)\r\nmax_size = vac_cache_size;\r\nif (vac_line_size < min_line_size)\r\nmin_line_size = vac_line_size;\r\ncpu++;\r\nif (cpu >= nr_cpu_ids || !cpu_online(cpu))\r\nbreak;\r\n#else\r\nbreak;\r\n#endif\r\n}\r\n}\r\nif (nd == 0) {\r\nprom_printf("No CPU nodes found, halting.\n");\r\nprom_halt();\r\n}\r\n#ifdef CONFIG_SMP\r\nvac_cache_size = max_size;\r\nvac_line_size = min_line_size;\r\n#endif\r\nprintk("SRMMU: Using VAC size of %d bytes, line size %d bytes.\n",\r\n(int)vac_cache_size, (int)vac_line_size);\r\n}\r\nstatic void poke_hypersparc(void)\r\n{\r\nvolatile unsigned long clear;\r\nunsigned long mreg = srmmu_get_mmureg();\r\nhyper_flush_unconditional_combined();\r\nmreg &= ~(HYPERSPARC_CWENABLE);\r\nmreg |= (HYPERSPARC_CENABLE | HYPERSPARC_WBENABLE);\r\nmreg |= (HYPERSPARC_CMODE);\r\nsrmmu_set_mmureg(mreg);\r\n#if 0\r\nhyper_clear_all_tags();\r\n#endif\r\nput_ross_icr(HYPERSPARC_ICCR_FTD | HYPERSPARC_ICCR_ICE);\r\nhyper_flush_whole_icache();\r\nclear = srmmu_get_faddr();\r\nclear = srmmu_get_fstatus();\r\n}\r\nstatic void __init init_hypersparc(void)\r\n{\r\nsrmmu_name = "ROSS HyperSparc";\r\nsrmmu_modtype = HyperSparc;\r\ninit_vac_layout();\r\nis_hypersparc = 1;\r\nsparc32_cachetlb_ops = &hypersparc_ops;\r\npoke_srmmu = poke_hypersparc;\r\nhypersparc_setup_blockops();\r\n}\r\nstatic void poke_swift(void)\r\n{\r\nunsigned long mreg;\r\nswift_flush_cache_all();\r\nmreg = srmmu_get_mmureg();\r\nmreg |= (SWIFT_IE | SWIFT_DE);\r\nmreg &= ~(SWIFT_BF);\r\nsrmmu_set_mmureg(mreg);\r\n}\r\nstatic void __init init_swift(void)\r\n{\r\nunsigned long swift_rev;\r\n__asm__ __volatile__("lda [%1] %2, %0\n\t"\r\n"srl %0, 0x18, %0\n\t" :\r\n"=r" (swift_rev) :\r\n"r" (SWIFT_MASKID_ADDR), "i" (ASI_M_BYPASS));\r\nsrmmu_name = "Fujitsu Swift";\r\nswitch (swift_rev) {\r\ncase 0x11:\r\ncase 0x20:\r\ncase 0x23:\r\ncase 0x30:\r\nsrmmu_modtype = Swift_lots_o_bugs;\r\nhwbug_bitmask |= (HWBUG_KERN_ACCBROKEN | HWBUG_KERN_CBITBROKEN);\r\nbreak;\r\ncase 0x25:\r\ncase 0x31:\r\nsrmmu_modtype = Swift_bad_c;\r\nhwbug_bitmask |= HWBUG_KERN_CBITBROKEN;\r\nbreak;\r\ndefault:\r\nsrmmu_modtype = Swift_ok;\r\nbreak;\r\n}\r\nsparc32_cachetlb_ops = &swift_ops;\r\nflush_page_for_dma_global = 0;\r\npoke_srmmu = poke_swift;\r\n}\r\nstatic void turbosparc_flush_cache_all(void)\r\n{\r\nflush_user_windows();\r\nturbosparc_idflash_clear();\r\n}\r\nstatic void turbosparc_flush_cache_mm(struct mm_struct *mm)\r\n{\r\nFLUSH_BEGIN(mm)\r\nflush_user_windows();\r\nturbosparc_idflash_clear();\r\nFLUSH_END\r\n}\r\nstatic void turbosparc_flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)\r\n{\r\nFLUSH_BEGIN(vma->vm_mm)\r\nflush_user_windows();\r\nturbosparc_idflash_clear();\r\nFLUSH_END\r\n}\r\nstatic void turbosparc_flush_cache_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nFLUSH_BEGIN(vma->vm_mm)\r\nflush_user_windows();\r\nif (vma->vm_flags & VM_EXEC)\r\nturbosparc_flush_icache();\r\nturbosparc_flush_dcache();\r\nFLUSH_END\r\n}\r\nstatic void turbosparc_flush_page_to_ram(unsigned long page)\r\n{\r\n#ifdef TURBOSPARC_WRITEBACK\r\nvolatile unsigned long clear;\r\nif (srmmu_probe(page))\r\nturbosparc_flush_page_cache(page);\r\nclear = srmmu_get_fstatus();\r\n#endif\r\n}\r\nstatic void turbosparc_flush_sig_insns(struct mm_struct *mm, unsigned long insn_addr)\r\n{\r\n}\r\nstatic void turbosparc_flush_page_for_dma(unsigned long page)\r\n{\r\nturbosparc_flush_dcache();\r\n}\r\nstatic void turbosparc_flush_tlb_all(void)\r\n{\r\nsrmmu_flush_whole_tlb();\r\n}\r\nstatic void turbosparc_flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nFLUSH_BEGIN(mm)\r\nsrmmu_flush_whole_tlb();\r\nFLUSH_END\r\n}\r\nstatic void turbosparc_flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)\r\n{\r\nFLUSH_BEGIN(vma->vm_mm)\r\nsrmmu_flush_whole_tlb();\r\nFLUSH_END\r\n}\r\nstatic void turbosparc_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nFLUSH_BEGIN(vma->vm_mm)\r\nsrmmu_flush_whole_tlb();\r\nFLUSH_END\r\n}\r\nstatic void poke_turbosparc(void)\r\n{\r\nunsigned long mreg = srmmu_get_mmureg();\r\nunsigned long ccreg;\r\nturbosparc_flush_cache_all();\r\nmreg &= ~(TURBOSPARC_ICENABLE | TURBOSPARC_DCENABLE);\r\nmreg &= ~(TURBOSPARC_PCENABLE);\r\nsrmmu_set_mmureg(mreg);\r\nccreg = turbosparc_get_ccreg();\r\n#ifdef TURBOSPARC_WRITEBACK\r\nccreg |= (TURBOSPARC_SNENABLE);\r\nccreg &= ~(TURBOSPARC_uS2 | TURBOSPARC_WTENABLE);\r\n#else\r\nccreg |= (TURBOSPARC_SNENABLE | TURBOSPARC_WTENABLE);\r\nccreg &= ~(TURBOSPARC_uS2);\r\n#endif\r\nswitch (ccreg & 7) {\r\ncase 0:\r\ncase 7:\r\nbreak;\r\ndefault:\r\nccreg |= (TURBOSPARC_SCENABLE);\r\n}\r\nturbosparc_set_ccreg(ccreg);\r\nmreg |= (TURBOSPARC_ICENABLE | TURBOSPARC_DCENABLE);\r\nmreg |= (TURBOSPARC_ICSNOOP);\r\nsrmmu_set_mmureg(mreg);\r\n}\r\nstatic void __init init_turbosparc(void)\r\n{\r\nsrmmu_name = "Fujitsu TurboSparc";\r\nsrmmu_modtype = TurboSparc;\r\nsparc32_cachetlb_ops = &turbosparc_ops;\r\npoke_srmmu = poke_turbosparc;\r\n}\r\nstatic void poke_tsunami(void)\r\n{\r\nunsigned long mreg = srmmu_get_mmureg();\r\ntsunami_flush_icache();\r\ntsunami_flush_dcache();\r\nmreg &= ~TSUNAMI_ITD;\r\nmreg |= (TSUNAMI_IENAB | TSUNAMI_DENAB);\r\nsrmmu_set_mmureg(mreg);\r\n}\r\nstatic void __init init_tsunami(void)\r\n{\r\nsrmmu_name = "TI Tsunami";\r\nsrmmu_modtype = Tsunami;\r\nsparc32_cachetlb_ops = &tsunami_ops;\r\npoke_srmmu = poke_tsunami;\r\ntsunami_setup_blockops();\r\n}\r\nstatic void poke_viking(void)\r\n{\r\nunsigned long mreg = srmmu_get_mmureg();\r\nstatic int smp_catch;\r\nif (viking_mxcc_present) {\r\nunsigned long mxcc_control = mxcc_get_creg();\r\nmxcc_control |= (MXCC_CTL_ECE | MXCC_CTL_PRE | MXCC_CTL_MCE);\r\nmxcc_control &= ~(MXCC_CTL_RRC);\r\nmxcc_set_creg(mxcc_control);\r\nmreg |= VIKING_TCENABLE;\r\n} else {\r\nunsigned long bpreg;\r\nmreg &= ~(VIKING_TCENABLE);\r\nif (smp_catch++) {\r\nbpreg = viking_get_bpreg();\r\nbpreg &= ~(VIKING_ACTION_MIX);\r\nviking_set_bpreg(bpreg);\r\nmsi_set_sync();\r\n}\r\n}\r\nmreg |= VIKING_SPENABLE;\r\nmreg |= (VIKING_ICENABLE | VIKING_DCENABLE);\r\nmreg |= VIKING_SBENABLE;\r\nmreg &= ~(VIKING_ACENABLE);\r\nsrmmu_set_mmureg(mreg);\r\n}\r\nstatic void __init init_viking(void)\r\n{\r\nunsigned long mreg = srmmu_get_mmureg();\r\nif (mreg & VIKING_MMODE) {\r\nsrmmu_name = "TI Viking";\r\nviking_mxcc_present = 0;\r\nmsi_set_sync();\r\nviking_ops.page_for_dma = viking_flush_page;\r\n#ifdef CONFIG_SMP\r\nviking_sun4d_smp_ops.page_for_dma = viking_flush_page;\r\n#endif\r\nflush_page_for_dma_global = 0;\r\n} else {\r\nsrmmu_name = "TI Viking/MXCC";\r\nviking_mxcc_present = 1;\r\nsrmmu_cache_pagetables = 1;\r\n}\r\nsparc32_cachetlb_ops = (const struct sparc32_cachetlb_ops *)\r\n&viking_ops;\r\n#ifdef CONFIG_SMP\r\nif (sparc_cpu_model == sun4d)\r\nsparc32_cachetlb_ops = (const struct sparc32_cachetlb_ops *)\r\n&viking_sun4d_smp_ops;\r\n#endif\r\npoke_srmmu = poke_viking;\r\n}\r\nstatic void __init get_srmmu_type(void)\r\n{\r\nunsigned long mreg, psr;\r\nunsigned long mod_typ, mod_rev, psr_typ, psr_vers;\r\nsrmmu_modtype = SRMMU_INVAL_MOD;\r\nhwbug_bitmask = 0;\r\nmreg = srmmu_get_mmureg(); psr = get_psr();\r\nmod_typ = (mreg & 0xf0000000) >> 28;\r\nmod_rev = (mreg & 0x0f000000) >> 24;\r\npsr_typ = (psr >> 28) & 0xf;\r\npsr_vers = (psr >> 24) & 0xf;\r\nif (sparc_cpu_model == sparc_leon) {\r\ninit_leon();\r\nreturn;\r\n}\r\nif (mod_typ == 1) {\r\nswitch (mod_rev) {\r\ncase 7:\r\ninit_hypersparc();\r\nbreak;\r\ncase 0:\r\ncase 2:\r\ncase 10:\r\ncase 11:\r\ncase 12:\r\ncase 13:\r\ncase 14:\r\ncase 15:\r\ndefault:\r\nprom_printf("Sparc-Linux Cypress support does not longer exit.\n");\r\nprom_halt();\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nif (psr_typ == 0 && psr_vers == 5) {\r\ninit_turbosparc();\r\nreturn;\r\n}\r\nif (psr_typ == 0 && psr_vers == 4) {\r\nphandle cpunode;\r\nchar node_str[128];\r\ncpunode = prom_getchild(prom_root_node);\r\nwhile ((cpunode = prom_getsibling(cpunode)) != 0) {\r\nprom_getstring(cpunode, "device_type", node_str, sizeof(node_str));\r\nif (!strcmp(node_str, "cpu")) {\r\nif (!prom_getintdefault(cpunode, "psr-implementation", 1) &&\r\nprom_getintdefault(cpunode, "psr-version", 1) == 5) {\r\ninit_turbosparc();\r\nreturn;\r\n}\r\nbreak;\r\n}\r\n}\r\ninit_swift();\r\nreturn;\r\n}\r\nif (psr_typ == 4 &&\r\n((psr_vers == 0) ||\r\n((psr_vers == 1) && (mod_typ == 0) && (mod_rev == 0)))) {\r\ninit_viking();\r\nreturn;\r\n}\r\nif (psr_typ == 4 && psr_vers == 1 && (mod_typ || mod_rev)) {\r\ninit_tsunami();\r\nreturn;\r\n}\r\nsrmmu_is_bad();\r\n}\r\nstatic void smp_flush_page_for_dma(unsigned long page)\r\n{\r\nxc1((smpfunc_t) local_ops->page_for_dma, page);\r\nlocal_ops->page_for_dma(page);\r\n}\r\nstatic void smp_flush_cache_all(void)\r\n{\r\nxc0((smpfunc_t) local_ops->cache_all);\r\nlocal_ops->cache_all();\r\n}\r\nstatic void smp_flush_tlb_all(void)\r\n{\r\nxc0((smpfunc_t) local_ops->tlb_all);\r\nlocal_ops->tlb_all();\r\n}\r\nstatic void smp_flush_cache_mm(struct mm_struct *mm)\r\n{\r\nif (mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc1((smpfunc_t) local_ops->cache_mm, (unsigned long) mm);\r\nlocal_ops->cache_mm(mm);\r\n}\r\n}\r\nstatic void smp_flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nif (mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask)) {\r\nxc1((smpfunc_t) local_ops->tlb_mm, (unsigned long) mm);\r\nif (atomic_read(&mm->mm_users) == 1 && current->active_mm == mm)\r\ncpumask_copy(mm_cpumask(mm),\r\ncpumask_of(smp_processor_id()));\r\n}\r\nlocal_ops->tlb_mm(mm);\r\n}\r\n}\r\nstatic void smp_flush_cache_range(struct vm_area_struct *vma,\r\nunsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nif (mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc3((smpfunc_t) local_ops->cache_range,\r\n(unsigned long) vma, start, end);\r\nlocal_ops->cache_range(vma, start, end);\r\n}\r\n}\r\nstatic void smp_flush_tlb_range(struct vm_area_struct *vma,\r\nunsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nif (mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc3((smpfunc_t) local_ops->tlb_range,\r\n(unsigned long) vma, start, end);\r\nlocal_ops->tlb_range(vma, start, end);\r\n}\r\n}\r\nstatic void smp_flush_cache_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nif (mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc2((smpfunc_t) local_ops->cache_page,\r\n(unsigned long) vma, page);\r\nlocal_ops->cache_page(vma, page);\r\n}\r\n}\r\nstatic void smp_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nif (mm->context != NO_CONTEXT) {\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc2((smpfunc_t) local_ops->tlb_page,\r\n(unsigned long) vma, page);\r\nlocal_ops->tlb_page(vma, page);\r\n}\r\n}\r\nstatic void smp_flush_page_to_ram(unsigned long page)\r\n{\r\n#if 1\r\nxc1((smpfunc_t) local_ops->page_to_ram, page);\r\n#endif\r\nlocal_ops->page_to_ram(page);\r\n}\r\nstatic void smp_flush_sig_insns(struct mm_struct *mm, unsigned long insn_addr)\r\n{\r\ncpumask_t cpu_mask;\r\ncpumask_copy(&cpu_mask, mm_cpumask(mm));\r\ncpumask_clear_cpu(smp_processor_id(), &cpu_mask);\r\nif (!cpumask_empty(&cpu_mask))\r\nxc2((smpfunc_t) local_ops->sig_insns,\r\n(unsigned long) mm, insn_addr);\r\nlocal_ops->sig_insns(mm, insn_addr);\r\n}\r\nvoid __init load_mmu(void)\r\n{\r\nget_srmmu_type();\r\n#ifdef CONFIG_SMP\r\nlocal_ops = sparc32_cachetlb_ops;\r\nif (sparc_cpu_model == sun4d || sparc_cpu_model == sparc_leon) {\r\nsmp_cachetlb_ops.tlb_all = local_ops->tlb_all;\r\nsmp_cachetlb_ops.tlb_mm = local_ops->tlb_mm;\r\nsmp_cachetlb_ops.tlb_range = local_ops->tlb_range;\r\nsmp_cachetlb_ops.tlb_page = local_ops->tlb_page;\r\n}\r\nif (poke_srmmu == poke_viking) {\r\nsmp_cachetlb_ops.cache_all = local_ops->cache_all;\r\nsmp_cachetlb_ops.cache_mm = local_ops->cache_mm;\r\nsmp_cachetlb_ops.cache_range = local_ops->cache_range;\r\nsmp_cachetlb_ops.cache_page = local_ops->cache_page;\r\nsmp_cachetlb_ops.page_to_ram = local_ops->page_to_ram;\r\nsmp_cachetlb_ops.sig_insns = local_ops->sig_insns;\r\nsmp_cachetlb_ops.page_for_dma = local_ops->page_for_dma;\r\n}\r\nsparc32_cachetlb_ops = (const struct sparc32_cachetlb_ops *)\r\n&smp_cachetlb_ops;\r\n#endif\r\nif (sparc_cpu_model == sun4d)\r\nld_mmu_iounit();\r\nelse\r\nld_mmu_iommu();\r\n#ifdef CONFIG_SMP\r\nif (sparc_cpu_model == sun4d)\r\nsun4d_init_smp();\r\nelse if (sparc_cpu_model == sparc_leon)\r\nleon_init_smp();\r\nelse\r\nsun4m_init_smp();\r\n#endif\r\n}
