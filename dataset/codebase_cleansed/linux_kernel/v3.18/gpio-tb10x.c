static inline u32 tb10x_reg_read(struct tb10x_gpio *gpio, unsigned int offs)\r\n{\r\nreturn ioread32(gpio->base + offs);\r\n}\r\nstatic inline void tb10x_reg_write(struct tb10x_gpio *gpio, unsigned int offs,\r\nu32 val)\r\n{\r\niowrite32(val, gpio->base + offs);\r\n}\r\nstatic inline void tb10x_set_bits(struct tb10x_gpio *gpio, unsigned int offs,\r\nu32 mask, u32 val)\r\n{\r\nu32 r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio->spinlock, flags);\r\nr = tb10x_reg_read(gpio, offs);\r\nr = (r & ~mask) | (val & mask);\r\ntb10x_reg_write(gpio, offs, r);\r\nspin_unlock_irqrestore(&gpio->spinlock, flags);\r\n}\r\nstatic inline struct tb10x_gpio *to_tb10x_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct tb10x_gpio, gc);\r\n}\r\nstatic int tb10x_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct tb10x_gpio *tb10x_gpio = to_tb10x_gpio(chip);\r\nint mask = BIT(offset);\r\nint val = TB10X_GPIO_DIR_IN << offset;\r\ntb10x_set_bits(tb10x_gpio, OFFSET_TO_REG_DDR, mask, val);\r\nreturn 0;\r\n}\r\nstatic int tb10x_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct tb10x_gpio *tb10x_gpio = to_tb10x_gpio(chip);\r\nint val;\r\nval = tb10x_reg_read(tb10x_gpio, OFFSET_TO_REG_DATA);\r\nif (val & BIT(offset))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void tb10x_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct tb10x_gpio *tb10x_gpio = to_tb10x_gpio(chip);\r\nint mask = BIT(offset);\r\nint val = value << offset;\r\ntb10x_set_bits(tb10x_gpio, OFFSET_TO_REG_DATA, mask, val);\r\n}\r\nstatic int tb10x_gpio_direction_out(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct tb10x_gpio *tb10x_gpio = to_tb10x_gpio(chip);\r\nint mask = BIT(offset);\r\nint val = TB10X_GPIO_DIR_OUT << offset;\r\ntb10x_gpio_set(chip, offset, value);\r\ntb10x_set_bits(tb10x_gpio, OFFSET_TO_REG_DDR, mask, val);\r\nreturn 0;\r\n}\r\nstatic int tb10x_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(chip->base + offset);\r\n}\r\nstatic void tb10x_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_free_gpio(chip->base + offset);\r\n}\r\nstatic int tb10x_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct tb10x_gpio *tb10x_gpio = to_tb10x_gpio(chip);\r\nreturn irq_create_mapping(tb10x_gpio->domain, offset);\r\n}\r\nstatic int tb10x_gpio_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nif ((type & IRQF_TRIGGER_MASK) != IRQ_TYPE_EDGE_BOTH) {\r\npr_err("Only (both) edge triggered interrupts supported.\n");\r\nreturn -EINVAL;\r\n}\r\nirqd_set_trigger_type(data, type);\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic irqreturn_t tb10x_gpio_irq_cascade(int irq, void *data)\r\n{\r\nstruct tb10x_gpio *tb10x_gpio = data;\r\nu32 r = tb10x_reg_read(tb10x_gpio, OFFSET_TO_REG_CHANGE);\r\nu32 m = tb10x_reg_read(tb10x_gpio, OFFSET_TO_REG_INT_EN);\r\nconst unsigned long bits = r & m;\r\nint i;\r\nfor_each_set_bit(i, &bits, 32)\r\ngeneric_handle_irq(irq_find_mapping(tb10x_gpio->domain, i));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tb10x_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct tb10x_gpio *tb10x_gpio;\r\nstruct resource *mem;\r\nstruct device_node *dn = pdev->dev.of_node;\r\nint ret = -EBUSY;\r\nu32 ngpio;\r\nif (!dn)\r\nreturn -EINVAL;\r\nif (of_property_read_u32(dn, "abilis,ngpio", &ngpio))\r\nreturn -EINVAL;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "No memory resource defined.\n");\r\nreturn -EINVAL;\r\n}\r\ntb10x_gpio = devm_kzalloc(&pdev->dev, sizeof(*tb10x_gpio), GFP_KERNEL);\r\nif (tb10x_gpio == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&tb10x_gpio->spinlock);\r\ntb10x_gpio->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(tb10x_gpio->base))\r\nreturn PTR_ERR(tb10x_gpio->base);\r\ntb10x_gpio->gc.label = of_node_full_name(dn);\r\ntb10x_gpio->gc.dev = &pdev->dev;\r\ntb10x_gpio->gc.owner = THIS_MODULE;\r\ntb10x_gpio->gc.direction_input = tb10x_gpio_direction_in;\r\ntb10x_gpio->gc.get = tb10x_gpio_get;\r\ntb10x_gpio->gc.direction_output = tb10x_gpio_direction_out;\r\ntb10x_gpio->gc.set = tb10x_gpio_set;\r\ntb10x_gpio->gc.request = tb10x_gpio_request;\r\ntb10x_gpio->gc.free = tb10x_gpio_free;\r\ntb10x_gpio->gc.base = -1;\r\ntb10x_gpio->gc.ngpio = ngpio;\r\ntb10x_gpio->gc.can_sleep = false;\r\nret = gpiochip_add(&tb10x_gpio->gc);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Could not add gpiochip.\n");\r\ngoto fail_gpiochip_registration;\r\n}\r\nplatform_set_drvdata(pdev, tb10x_gpio);\r\nif (of_find_property(dn, "interrupt-controller", NULL)) {\r\nstruct irq_chip_generic *gc;\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "No interrupt specified.\n");\r\ngoto fail_get_irq;\r\n}\r\ntb10x_gpio->gc.to_irq = tb10x_gpio_to_irq;\r\ntb10x_gpio->irq = ret;\r\nret = devm_request_irq(&pdev->dev, ret, tb10x_gpio_irq_cascade,\r\nIRQF_TRIGGER_NONE | IRQF_SHARED,\r\ndev_name(&pdev->dev), tb10x_gpio);\r\nif (ret != 0)\r\ngoto fail_request_irq;\r\ntb10x_gpio->domain = irq_domain_add_linear(dn,\r\ntb10x_gpio->gc.ngpio,\r\n&irq_generic_chip_ops, NULL);\r\nif (!tb10x_gpio->domain) {\r\nret = -ENOMEM;\r\ngoto fail_irq_domain;\r\n}\r\nret = irq_alloc_domain_generic_chips(tb10x_gpio->domain,\r\ntb10x_gpio->gc.ngpio, 1, tb10x_gpio->gc.label,\r\nhandle_edge_irq, IRQ_NOREQUEST, IRQ_NOPROBE,\r\nIRQ_GC_INIT_MASK_CACHE);\r\nif (ret)\r\ngoto fail_irq_domain;\r\ngc = tb10x_gpio->domain->gc->gc[0];\r\ngc->reg_base = tb10x_gpio->base;\r\ngc->chip_types[0].type = IRQ_TYPE_EDGE_BOTH;\r\ngc->chip_types[0].chip.irq_ack = irq_gc_ack_set_bit;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit;\r\ngc->chip_types[0].chip.irq_set_type = tb10x_gpio_irq_set_type;\r\ngc->chip_types[0].regs.ack = OFFSET_TO_REG_CHANGE;\r\ngc->chip_types[0].regs.mask = OFFSET_TO_REG_INT_EN;\r\n}\r\nreturn 0;\r\nfail_irq_domain:\r\nfail_request_irq:\r\nfail_get_irq:\r\ngpiochip_remove(&tb10x_gpio->gc);\r\nfail_gpiochip_registration:\r\nfail_ioremap:\r\nreturn ret;\r\n}\r\nstatic int __exit tb10x_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct tb10x_gpio *tb10x_gpio = platform_get_drvdata(pdev);\r\nif (tb10x_gpio->gc.to_irq) {\r\nirq_remove_generic_chip(tb10x_gpio->domain->gc->gc[0],\r\nBIT(tb10x_gpio->gc.ngpio) - 1, 0, 0);\r\nkfree(tb10x_gpio->domain->gc);\r\nirq_domain_remove(tb10x_gpio->domain);\r\nfree_irq(tb10x_gpio->irq, tb10x_gpio);\r\n}\r\ngpiochip_remove(&tb10x_gpio->gc);\r\nreturn 0;\r\n}
