static void writeset_free(struct writeset *ws)\r\n{\r\nvfree(ws->bits);\r\n}\r\nstatic int setup_on_disk_bitset(struct dm_disk_bitset *info,\r\nunsigned nr_bits, dm_block_t *root)\r\n{\r\nint r;\r\nr = dm_bitset_empty(info, root);\r\nif (r)\r\nreturn r;\r\nreturn dm_bitset_resize(info, *root, 0, nr_bits, false, root);\r\n}\r\nstatic size_t bitset_size(unsigned nr_bits)\r\n{\r\nreturn sizeof(unsigned long) * dm_div_up(nr_bits, BITS_PER_LONG);\r\n}\r\nstatic int writeset_alloc(struct writeset *ws, dm_block_t nr_blocks)\r\n{\r\nws->md.nr_bits = nr_blocks;\r\nws->md.root = INVALID_WRITESET_ROOT;\r\nws->bits = vzalloc(bitset_size(nr_blocks));\r\nif (!ws->bits) {\r\nDMERR("%s: couldn't allocate in memory bitset", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int writeset_init(struct dm_disk_bitset *info, struct writeset *ws)\r\n{\r\nint r;\r\nmemset(ws->bits, 0, bitset_size(ws->md.nr_bits));\r\nr = setup_on_disk_bitset(info, ws->md.nr_bits, &ws->md.root);\r\nif (r) {\r\nDMERR("%s: setup_on_disk_bitset failed", __func__);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool writeset_marked(struct writeset *ws, dm_block_t block)\r\n{\r\nreturn test_bit(block, ws->bits);\r\n}\r\nstatic int writeset_marked_on_disk(struct dm_disk_bitset *info,\r\nstruct writeset_metadata *m, dm_block_t block,\r\nbool *result)\r\n{\r\ndm_block_t old = m->root;\r\nint r = dm_bitset_test_bit(info, m->root, block, &m->root, result);\r\nif (r) {\r\nDMERR("%s: dm_bitset_test_bit failed", __func__);\r\nreturn r;\r\n}\r\nBUG_ON(m->root != old);\r\nreturn r;\r\n}\r\nstatic int writeset_test_and_set(struct dm_disk_bitset *info,\r\nstruct writeset *ws, uint32_t block)\r\n{\r\nint r;\r\nif (!test_and_set_bit(block, ws->bits)) {\r\nr = dm_bitset_set_bit(info, ws->md.root, block, &ws->md.root);\r\nif (r) {\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void sb_prepare_for_write(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t sb_block_size)\r\n{\r\nstruct superblock_disk *disk = dm_block_data(b);\r\ndisk->blocknr = cpu_to_le64(dm_block_location(b));\r\ndisk->csum = cpu_to_le32(dm_bm_checksum(&disk->flags,\r\nsb_block_size - sizeof(__le32),\r\nSUPERBLOCK_CSUM_XOR));\r\n}\r\nstatic int check_metadata_version(struct superblock_disk *disk)\r\n{\r\nuint32_t metadata_version = le32_to_cpu(disk->version);\r\nif (metadata_version < MIN_ERA_VERSION || metadata_version > MAX_ERA_VERSION) {\r\nDMERR("Era metadata version %u found, but only versions between %u and %u supported.",\r\nmetadata_version, MIN_ERA_VERSION, MAX_ERA_VERSION);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sb_check(struct dm_block_validator *v,\r\nstruct dm_block *b,\r\nsize_t sb_block_size)\r\n{\r\nstruct superblock_disk *disk = dm_block_data(b);\r\n__le32 csum_le;\r\nif (dm_block_location(b) != le64_to_cpu(disk->blocknr)) {\r\nDMERR("sb_check failed: blocknr %llu: wanted %llu",\r\nle64_to_cpu(disk->blocknr),\r\n(unsigned long long)dm_block_location(b));\r\nreturn -ENOTBLK;\r\n}\r\nif (le64_to_cpu(disk->magic) != SUPERBLOCK_MAGIC) {\r\nDMERR("sb_check failed: magic %llu: wanted %llu",\r\nle64_to_cpu(disk->magic),\r\n(unsigned long long) SUPERBLOCK_MAGIC);\r\nreturn -EILSEQ;\r\n}\r\ncsum_le = cpu_to_le32(dm_bm_checksum(&disk->flags,\r\nsb_block_size - sizeof(__le32),\r\nSUPERBLOCK_CSUM_XOR));\r\nif (csum_le != disk->csum) {\r\nDMERR("sb_check failed: csum %u: wanted %u",\r\nle32_to_cpu(csum_le), le32_to_cpu(disk->csum));\r\nreturn -EILSEQ;\r\n}\r\nreturn check_metadata_version(disk);\r\n}\r\nstatic int superblock_read_lock(struct era_metadata *md,\r\nstruct dm_block **sblock)\r\n{\r\nreturn dm_bm_read_lock(md->bm, SUPERBLOCK_LOCATION,\r\n&sb_validator, sblock);\r\n}\r\nstatic int superblock_lock_zero(struct era_metadata *md,\r\nstruct dm_block **sblock)\r\n{\r\nreturn dm_bm_write_lock_zero(md->bm, SUPERBLOCK_LOCATION,\r\n&sb_validator, sblock);\r\n}\r\nstatic int superblock_lock(struct era_metadata *md,\r\nstruct dm_block **sblock)\r\n{\r\nreturn dm_bm_write_lock(md->bm, SUPERBLOCK_LOCATION,\r\n&sb_validator, sblock);\r\n}\r\nstatic int superblock_all_zeroes(struct dm_block_manager *bm, bool *result)\r\n{\r\nint r;\r\nunsigned i;\r\nstruct dm_block *b;\r\n__le64 *data_le, zero = cpu_to_le64(0);\r\nunsigned sb_block_size = dm_bm_block_size(bm) / sizeof(__le64);\r\nr = dm_bm_read_lock(bm, SUPERBLOCK_LOCATION, NULL, &b);\r\nif (r)\r\nreturn r;\r\ndata_le = dm_block_data(b);\r\n*result = true;\r\nfor (i = 0; i < sb_block_size; i++) {\r\nif (data_le[i] != zero) {\r\n*result = false;\r\nbreak;\r\n}\r\n}\r\nreturn dm_bm_unlock(b);\r\n}\r\nstatic void ws_pack(const struct writeset_metadata *core, struct writeset_disk *disk)\r\n{\r\ndisk->nr_bits = cpu_to_le32(core->nr_bits);\r\ndisk->root = cpu_to_le64(core->root);\r\n}\r\nstatic void ws_unpack(const struct writeset_disk *disk, struct writeset_metadata *core)\r\n{\r\ncore->nr_bits = le32_to_cpu(disk->nr_bits);\r\ncore->root = le64_to_cpu(disk->root);\r\n}\r\nstatic void ws_inc(void *context, const void *value)\r\n{\r\nstruct era_metadata *md = context;\r\nstruct writeset_disk ws_d;\r\ndm_block_t b;\r\nmemcpy(&ws_d, value, sizeof(ws_d));\r\nb = le64_to_cpu(ws_d.root);\r\ndm_tm_inc(md->tm, b);\r\n}\r\nstatic void ws_dec(void *context, const void *value)\r\n{\r\nstruct era_metadata *md = context;\r\nstruct writeset_disk ws_d;\r\ndm_block_t b;\r\nmemcpy(&ws_d, value, sizeof(ws_d));\r\nb = le64_to_cpu(ws_d.root);\r\ndm_bitset_del(&md->bitset_info, b);\r\n}\r\nstatic int ws_eq(void *context, const void *value1, const void *value2)\r\n{\r\nreturn !memcmp(value1, value2, sizeof(struct writeset_metadata));\r\n}\r\nstatic void setup_writeset_tree_info(struct era_metadata *md)\r\n{\r\nstruct dm_btree_value_type *vt = &md->writeset_tree_info.value_type;\r\nmd->writeset_tree_info.tm = md->tm;\r\nmd->writeset_tree_info.levels = 1;\r\nvt->context = md;\r\nvt->size = sizeof(struct writeset_disk);\r\nvt->inc = ws_inc;\r\nvt->dec = ws_dec;\r\nvt->equal = ws_eq;\r\n}\r\nstatic void setup_era_array_info(struct era_metadata *md)\r\n{\r\nstruct dm_btree_value_type vt;\r\nvt.context = NULL;\r\nvt.size = sizeof(__le32);\r\nvt.inc = NULL;\r\nvt.dec = NULL;\r\nvt.equal = NULL;\r\ndm_array_info_init(&md->era_array_info, md->tm, &vt);\r\n}\r\nstatic void setup_infos(struct era_metadata *md)\r\n{\r\ndm_disk_bitset_init(md->tm, &md->bitset_info);\r\nsetup_writeset_tree_info(md);\r\nsetup_era_array_info(md);\r\n}\r\nstatic int create_fresh_metadata(struct era_metadata *md)\r\n{\r\nint r;\r\nr = dm_tm_create_with_sm(md->bm, SUPERBLOCK_LOCATION,\r\n&md->tm, &md->sm);\r\nif (r < 0) {\r\nDMERR("dm_tm_create_with_sm failed");\r\nreturn r;\r\n}\r\nsetup_infos(md);\r\nr = dm_btree_empty(&md->writeset_tree_info, &md->writeset_tree_root);\r\nif (r) {\r\nDMERR("couldn't create new writeset tree");\r\ngoto bad;\r\n}\r\nr = dm_array_empty(&md->era_array_info, &md->era_array_root);\r\nif (r) {\r\nDMERR("couldn't create era array");\r\ngoto bad;\r\n}\r\nreturn 0;\r\nbad:\r\ndm_sm_destroy(md->sm);\r\ndm_tm_destroy(md->tm);\r\nreturn r;\r\n}\r\nstatic int save_sm_root(struct era_metadata *md)\r\n{\r\nint r;\r\nsize_t metadata_len;\r\nr = dm_sm_root_size(md->sm, &metadata_len);\r\nif (r < 0)\r\nreturn r;\r\nreturn dm_sm_copy_root(md->sm, &md->metadata_space_map_root,\r\nmetadata_len);\r\n}\r\nstatic void copy_sm_root(struct era_metadata *md, struct superblock_disk *disk)\r\n{\r\nmemcpy(&disk->metadata_space_map_root,\r\n&md->metadata_space_map_root,\r\nsizeof(md->metadata_space_map_root));\r\n}\r\nstatic void prepare_superblock(struct era_metadata *md, struct superblock_disk *disk)\r\n{\r\ndisk->magic = cpu_to_le64(SUPERBLOCK_MAGIC);\r\ndisk->flags = cpu_to_le32(0ul);\r\nmemset(disk->uuid, 0, sizeof(disk->uuid));\r\ndisk->version = cpu_to_le32(MAX_ERA_VERSION);\r\ncopy_sm_root(md, disk);\r\ndisk->data_block_size = cpu_to_le32(md->block_size);\r\ndisk->metadata_block_size = cpu_to_le32(DM_ERA_METADATA_BLOCK_SIZE >> SECTOR_SHIFT);\r\ndisk->nr_blocks = cpu_to_le32(md->nr_blocks);\r\ndisk->current_era = cpu_to_le32(md->current_era);\r\nws_pack(&md->current_writeset->md, &disk->current_writeset);\r\ndisk->writeset_tree_root = cpu_to_le64(md->writeset_tree_root);\r\ndisk->era_array_root = cpu_to_le64(md->era_array_root);\r\ndisk->metadata_snap = cpu_to_le64(md->metadata_snap);\r\n}\r\nstatic int write_superblock(struct era_metadata *md)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nstruct superblock_disk *disk;\r\nr = save_sm_root(md);\r\nif (r) {\r\nDMERR("%s: save_sm_root failed", __func__);\r\nreturn r;\r\n}\r\nr = superblock_lock_zero(md, &sblock);\r\nif (r)\r\nreturn r;\r\ndisk = dm_block_data(sblock);\r\nprepare_superblock(md, disk);\r\nreturn dm_tm_commit(md->tm, sblock);\r\n}\r\nstatic int format_metadata(struct era_metadata *md)\r\n{\r\nint r;\r\nr = create_fresh_metadata(md);\r\nif (r)\r\nreturn r;\r\nr = write_superblock(md);\r\nif (r) {\r\ndm_sm_destroy(md->sm);\r\ndm_tm_destroy(md->tm);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int open_metadata(struct era_metadata *md)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nstruct superblock_disk *disk;\r\nr = superblock_read_lock(md, &sblock);\r\nif (r) {\r\nDMERR("couldn't read_lock superblock");\r\nreturn r;\r\n}\r\ndisk = dm_block_data(sblock);\r\nr = dm_tm_open_with_sm(md->bm, SUPERBLOCK_LOCATION,\r\ndisk->metadata_space_map_root,\r\nsizeof(disk->metadata_space_map_root),\r\n&md->tm, &md->sm);\r\nif (r) {\r\nDMERR("dm_tm_open_with_sm failed");\r\ngoto bad;\r\n}\r\nsetup_infos(md);\r\nmd->block_size = le32_to_cpu(disk->data_block_size);\r\nmd->nr_blocks = le32_to_cpu(disk->nr_blocks);\r\nmd->current_era = le32_to_cpu(disk->current_era);\r\nmd->writeset_tree_root = le64_to_cpu(disk->writeset_tree_root);\r\nmd->era_array_root = le64_to_cpu(disk->era_array_root);\r\nmd->metadata_snap = le64_to_cpu(disk->metadata_snap);\r\nmd->archived_writesets = true;\r\nreturn dm_bm_unlock(sblock);\r\nbad:\r\ndm_bm_unlock(sblock);\r\nreturn r;\r\n}\r\nstatic int open_or_format_metadata(struct era_metadata *md,\r\nbool may_format)\r\n{\r\nint r;\r\nbool unformatted = false;\r\nr = superblock_all_zeroes(md->bm, &unformatted);\r\nif (r)\r\nreturn r;\r\nif (unformatted)\r\nreturn may_format ? format_metadata(md) : -EPERM;\r\nreturn open_metadata(md);\r\n}\r\nstatic int create_persistent_data_objects(struct era_metadata *md,\r\nbool may_format)\r\n{\r\nint r;\r\nmd->bm = dm_block_manager_create(md->bdev, DM_ERA_METADATA_BLOCK_SIZE,\r\nDM_ERA_METADATA_CACHE_SIZE,\r\nERA_MAX_CONCURRENT_LOCKS);\r\nif (IS_ERR(md->bm)) {\r\nDMERR("could not create block manager");\r\nreturn PTR_ERR(md->bm);\r\n}\r\nr = open_or_format_metadata(md, may_format);\r\nif (r)\r\ndm_block_manager_destroy(md->bm);\r\nreturn r;\r\n}\r\nstatic void destroy_persistent_data_objects(struct era_metadata *md)\r\n{\r\ndm_sm_destroy(md->sm);\r\ndm_tm_destroy(md->tm);\r\ndm_block_manager_destroy(md->bm);\r\n}\r\nstatic void swap_writeset(struct era_metadata *md, struct writeset *new_writeset)\r\n{\r\nrcu_assign_pointer(md->current_writeset, new_writeset);\r\nsynchronize_rcu();\r\n}\r\nstatic int metadata_digest_remove_writeset(struct era_metadata *md,\r\nstruct digest *d)\r\n{\r\nint r;\r\nuint64_t key = d->era;\r\nr = dm_btree_remove(&md->writeset_tree_info, md->writeset_tree_root,\r\n&key, &md->writeset_tree_root);\r\nif (r) {\r\nDMERR("%s: dm_btree_remove failed", __func__);\r\nreturn r;\r\n}\r\nd->step = metadata_digest_lookup_writeset;\r\nreturn 0;\r\n}\r\nstatic int metadata_digest_transcribe_writeset(struct era_metadata *md,\r\nstruct digest *d)\r\n{\r\nint r;\r\nbool marked;\r\nunsigned b, e = min(d->current_bit + INSERTS_PER_STEP, d->nr_bits);\r\nfor (b = d->current_bit; b < e; b++) {\r\nr = writeset_marked_on_disk(&d->info, &d->writeset, b, &marked);\r\nif (r) {\r\nDMERR("%s: writeset_marked_on_disk failed", __func__);\r\nreturn r;\r\n}\r\nif (!marked)\r\ncontinue;\r\n__dm_bless_for_disk(&d->value);\r\nr = dm_array_set_value(&md->era_array_info, md->era_array_root,\r\nb, &d->value, &md->era_array_root);\r\nif (r) {\r\nDMERR("%s: dm_array_set_value failed", __func__);\r\nreturn r;\r\n}\r\n}\r\nif (b == d->nr_bits)\r\nd->step = metadata_digest_remove_writeset;\r\nelse\r\nd->current_bit = b;\r\nreturn 0;\r\n}\r\nstatic int metadata_digest_lookup_writeset(struct era_metadata *md,\r\nstruct digest *d)\r\n{\r\nint r;\r\nuint64_t key;\r\nstruct writeset_disk disk;\r\nr = dm_btree_find_lowest_key(&md->writeset_tree_info,\r\nmd->writeset_tree_root, &key);\r\nif (r < 0)\r\nreturn r;\r\nd->era = key;\r\nr = dm_btree_lookup(&md->writeset_tree_info,\r\nmd->writeset_tree_root, &key, &disk);\r\nif (r) {\r\nif (r == -ENODATA) {\r\nd->step = NULL;\r\nreturn 0;\r\n}\r\nDMERR("%s: dm_btree_lookup failed", __func__);\r\nreturn r;\r\n}\r\nws_unpack(&disk, &d->writeset);\r\nd->value = cpu_to_le32(key);\r\nd->nr_bits = min(d->writeset.nr_bits, md->nr_blocks);\r\nd->current_bit = 0;\r\nd->step = metadata_digest_transcribe_writeset;\r\nreturn 0;\r\n}\r\nstatic int metadata_digest_start(struct era_metadata *md, struct digest *d)\r\n{\r\nif (d->step)\r\nreturn 0;\r\nmemset(d, 0, sizeof(*d));\r\ndm_disk_bitset_init(md->tm, &d->info);\r\nd->step = metadata_digest_lookup_writeset;\r\nreturn 0;\r\n}\r\nstatic struct era_metadata *metadata_open(struct block_device *bdev,\r\nsector_t block_size,\r\nbool may_format)\r\n{\r\nint r;\r\nstruct era_metadata *md = kzalloc(sizeof(*md), GFP_KERNEL);\r\nif (!md)\r\nreturn NULL;\r\nmd->bdev = bdev;\r\nmd->block_size = block_size;\r\nmd->writesets[0].md.root = INVALID_WRITESET_ROOT;\r\nmd->writesets[1].md.root = INVALID_WRITESET_ROOT;\r\nmd->current_writeset = &md->writesets[0];\r\nr = create_persistent_data_objects(md, may_format);\r\nif (r) {\r\nkfree(md);\r\nreturn ERR_PTR(r);\r\n}\r\nreturn md;\r\n}\r\nstatic void metadata_close(struct era_metadata *md)\r\n{\r\ndestroy_persistent_data_objects(md);\r\nkfree(md);\r\n}\r\nstatic bool valid_nr_blocks(dm_block_t n)\r\n{\r\nreturn n < (1ull << 31);\r\n}\r\nstatic int metadata_resize(struct era_metadata *md, void *arg)\r\n{\r\nint r;\r\ndm_block_t *new_size = arg;\r\n__le32 value;\r\nif (!valid_nr_blocks(*new_size)) {\r\nDMERR("Invalid number of origin blocks %llu",\r\n(unsigned long long) *new_size);\r\nreturn -EINVAL;\r\n}\r\nwriteset_free(&md->writesets[0]);\r\nwriteset_free(&md->writesets[1]);\r\nr = writeset_alloc(&md->writesets[0], *new_size);\r\nif (r) {\r\nDMERR("%s: writeset_alloc failed for writeset 0", __func__);\r\nreturn r;\r\n}\r\nr = writeset_alloc(&md->writesets[1], *new_size);\r\nif (r) {\r\nDMERR("%s: writeset_alloc failed for writeset 1", __func__);\r\nreturn r;\r\n}\r\nvalue = cpu_to_le32(0u);\r\n__dm_bless_for_disk(&value);\r\nr = dm_array_resize(&md->era_array_info, md->era_array_root,\r\nmd->nr_blocks, *new_size,\r\n&value, &md->era_array_root);\r\nif (r) {\r\nDMERR("%s: dm_array_resize failed", __func__);\r\nreturn r;\r\n}\r\nmd->nr_blocks = *new_size;\r\nreturn 0;\r\n}\r\nstatic int metadata_era_archive(struct era_metadata *md)\r\n{\r\nint r;\r\nuint64_t keys[1];\r\nstruct writeset_disk value;\r\nr = dm_bitset_flush(&md->bitset_info, md->current_writeset->md.root,\r\n&md->current_writeset->md.root);\r\nif (r) {\r\nDMERR("%s: dm_bitset_flush failed", __func__);\r\nreturn r;\r\n}\r\nws_pack(&md->current_writeset->md, &value);\r\nmd->current_writeset->md.root = INVALID_WRITESET_ROOT;\r\nkeys[0] = md->current_era;\r\n__dm_bless_for_disk(&value);\r\nr = dm_btree_insert(&md->writeset_tree_info, md->writeset_tree_root,\r\nkeys, &value, &md->writeset_tree_root);\r\nif (r) {\r\nDMERR("%s: couldn't insert writeset into btree", __func__);\r\nreturn r;\r\n}\r\nmd->archived_writesets = true;\r\nreturn 0;\r\n}\r\nstatic struct writeset *next_writeset(struct era_metadata *md)\r\n{\r\nreturn (md->current_writeset == &md->writesets[0]) ?\r\n&md->writesets[1] : &md->writesets[0];\r\n}\r\nstatic int metadata_new_era(struct era_metadata *md)\r\n{\r\nint r;\r\nstruct writeset *new_writeset = next_writeset(md);\r\nr = writeset_init(&md->bitset_info, new_writeset);\r\nif (r) {\r\nDMERR("%s: writeset_init failed", __func__);\r\nreturn r;\r\n}\r\nswap_writeset(md, new_writeset);\r\nmd->current_era++;\r\nreturn 0;\r\n}\r\nstatic int metadata_era_rollover(struct era_metadata *md)\r\n{\r\nint r;\r\nif (md->current_writeset->md.root != INVALID_WRITESET_ROOT) {\r\nr = metadata_era_archive(md);\r\nif (r) {\r\nDMERR("%s: metadata_archive_era failed", __func__);\r\nreturn r;\r\n}\r\n}\r\nr = metadata_new_era(md);\r\nif (r) {\r\nDMERR("%s: new era failed", __func__);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool metadata_current_marked(struct era_metadata *md, dm_block_t block)\r\n{\r\nbool r;\r\nstruct writeset *ws;\r\nrcu_read_lock();\r\nws = rcu_dereference(md->current_writeset);\r\nr = writeset_marked(ws, block);\r\nrcu_read_unlock();\r\nreturn r;\r\n}\r\nstatic int metadata_commit(struct era_metadata *md)\r\n{\r\nint r;\r\nstruct dm_block *sblock;\r\nif (md->current_writeset->md.root != SUPERBLOCK_LOCATION) {\r\nr = dm_bitset_flush(&md->bitset_info, md->current_writeset->md.root,\r\n&md->current_writeset->md.root);\r\nif (r) {\r\nDMERR("%s: bitset flush failed", __func__);\r\nreturn r;\r\n}\r\n}\r\nr = save_sm_root(md);\r\nif (r) {\r\nDMERR("%s: save_sm_root failed", __func__);\r\nreturn r;\r\n}\r\nr = dm_tm_pre_commit(md->tm);\r\nif (r) {\r\nDMERR("%s: pre commit failed", __func__);\r\nreturn r;\r\n}\r\nr = superblock_lock(md, &sblock);\r\nif (r) {\r\nDMERR("%s: superblock lock failed", __func__);\r\nreturn r;\r\n}\r\nprepare_superblock(md, dm_block_data(sblock));\r\nreturn dm_tm_commit(md->tm, sblock);\r\n}\r\nstatic int metadata_checkpoint(struct era_metadata *md)\r\n{\r\nreturn metadata_era_rollover(md);\r\n}\r\nstatic int metadata_take_snap(struct era_metadata *md)\r\n{\r\nint r, inc;\r\nstruct dm_block *clone;\r\nif (md->metadata_snap != SUPERBLOCK_LOCATION) {\r\nDMERR("%s: metadata snapshot already exists", __func__);\r\nreturn -EINVAL;\r\n}\r\nr = metadata_era_rollover(md);\r\nif (r) {\r\nDMERR("%s: era rollover failed", __func__);\r\nreturn r;\r\n}\r\nr = metadata_commit(md);\r\nif (r) {\r\nDMERR("%s: pre commit failed", __func__);\r\nreturn r;\r\n}\r\nr = dm_sm_inc_block(md->sm, SUPERBLOCK_LOCATION);\r\nif (r) {\r\nDMERR("%s: couldn't increment superblock", __func__);\r\nreturn r;\r\n}\r\nr = dm_tm_shadow_block(md->tm, SUPERBLOCK_LOCATION,\r\n&sb_validator, &clone, &inc);\r\nif (r) {\r\nDMERR("%s: couldn't shadow superblock", __func__);\r\ndm_sm_dec_block(md->sm, SUPERBLOCK_LOCATION);\r\nreturn r;\r\n}\r\nBUG_ON(!inc);\r\nr = dm_sm_inc_block(md->sm, md->writeset_tree_root);\r\nif (r) {\r\nDMERR("%s: couldn't inc writeset tree root", __func__);\r\ndm_tm_unlock(md->tm, clone);\r\nreturn r;\r\n}\r\nr = dm_sm_inc_block(md->sm, md->era_array_root);\r\nif (r) {\r\nDMERR("%s: couldn't inc era tree root", __func__);\r\ndm_sm_dec_block(md->sm, md->writeset_tree_root);\r\ndm_tm_unlock(md->tm, clone);\r\nreturn r;\r\n}\r\nmd->metadata_snap = dm_block_location(clone);\r\nr = dm_tm_unlock(md->tm, clone);\r\nif (r) {\r\nDMERR("%s: couldn't unlock clone", __func__);\r\nmd->metadata_snap = SUPERBLOCK_LOCATION;\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int metadata_drop_snap(struct era_metadata *md)\r\n{\r\nint r;\r\ndm_block_t location;\r\nstruct dm_block *clone;\r\nstruct superblock_disk *disk;\r\nif (md->metadata_snap == SUPERBLOCK_LOCATION) {\r\nDMERR("%s: no snap to drop", __func__);\r\nreturn -EINVAL;\r\n}\r\nr = dm_tm_read_lock(md->tm, md->metadata_snap, &sb_validator, &clone);\r\nif (r) {\r\nDMERR("%s: couldn't read lock superblock clone", __func__);\r\nreturn r;\r\n}\r\nmd->metadata_snap = SUPERBLOCK_LOCATION;\r\ndisk = dm_block_data(clone);\r\nr = dm_btree_del(&md->writeset_tree_info,\r\nle64_to_cpu(disk->writeset_tree_root));\r\nif (r) {\r\nDMERR("%s: error deleting writeset tree clone", __func__);\r\ndm_tm_unlock(md->tm, clone);\r\nreturn r;\r\n}\r\nr = dm_array_del(&md->era_array_info, le64_to_cpu(disk->era_array_root));\r\nif (r) {\r\nDMERR("%s: error deleting era array clone", __func__);\r\ndm_tm_unlock(md->tm, clone);\r\nreturn r;\r\n}\r\nlocation = dm_block_location(clone);\r\ndm_tm_unlock(md->tm, clone);\r\nreturn dm_sm_dec_block(md->sm, location);\r\n}\r\nstatic int metadata_get_stats(struct era_metadata *md, void *ptr)\r\n{\r\nint r;\r\nstruct metadata_stats *s = ptr;\r\ndm_block_t nr_free, nr_total;\r\nr = dm_sm_get_nr_free(md->sm, &nr_free);\r\nif (r) {\r\nDMERR("dm_sm_get_nr_free returned %d", r);\r\nreturn r;\r\n}\r\nr = dm_sm_get_nr_blocks(md->sm, &nr_total);\r\nif (r) {\r\nDMERR("dm_pool_get_metadata_dev_size returned %d", r);\r\nreturn r;\r\n}\r\ns->used = nr_total - nr_free;\r\ns->total = nr_total;\r\ns->snap = md->metadata_snap;\r\ns->era = md->current_era;\r\nreturn 0;\r\n}\r\nstatic bool block_size_is_power_of_two(struct era *era)\r\n{\r\nreturn era->sectors_per_block_shift >= 0;\r\n}\r\nstatic dm_block_t get_block(struct era *era, struct bio *bio)\r\n{\r\nsector_t block_nr = bio->bi_iter.bi_sector;\r\nif (!block_size_is_power_of_two(era))\r\n(void) sector_div(block_nr, era->sectors_per_block);\r\nelse\r\nblock_nr >>= era->sectors_per_block_shift;\r\nreturn block_nr;\r\n}\r\nstatic void remap_to_origin(struct era *era, struct bio *bio)\r\n{\r\nbio->bi_bdev = era->origin_dev->bdev;\r\n}\r\nstatic void wake_worker(struct era *era)\r\n{\r\nif (!atomic_read(&era->suspended))\r\nqueue_work(era->wq, &era->worker);\r\n}\r\nstatic void process_old_eras(struct era *era)\r\n{\r\nint r;\r\nif (!era->digest.step)\r\nreturn;\r\nr = era->digest.step(era->md, &era->digest);\r\nif (r < 0) {\r\nDMERR("%s: digest step failed, stopping digestion", __func__);\r\nera->digest.step = NULL;\r\n} else if (era->digest.step)\r\nwake_worker(era);\r\n}\r\nstatic void process_deferred_bios(struct era *era)\r\n{\r\nint r;\r\nstruct bio_list deferred_bios, marked_bios;\r\nstruct bio *bio;\r\nbool commit_needed = false;\r\nbool failed = false;\r\nbio_list_init(&deferred_bios);\r\nbio_list_init(&marked_bios);\r\nspin_lock(&era->deferred_lock);\r\nbio_list_merge(&deferred_bios, &era->deferred_bios);\r\nbio_list_init(&era->deferred_bios);\r\nspin_unlock(&era->deferred_lock);\r\nwhile ((bio = bio_list_pop(&deferred_bios))) {\r\nr = writeset_test_and_set(&era->md->bitset_info,\r\nera->md->current_writeset,\r\nget_block(era, bio));\r\nif (r < 0) {\r\nfailed = true;\r\n} else if (r == 0)\r\ncommit_needed = true;\r\nbio_list_add(&marked_bios, bio);\r\n}\r\nif (commit_needed) {\r\nr = metadata_commit(era->md);\r\nif (r)\r\nfailed = true;\r\n}\r\nif (failed)\r\nwhile ((bio = bio_list_pop(&marked_bios)))\r\nbio_io_error(bio);\r\nelse\r\nwhile ((bio = bio_list_pop(&marked_bios)))\r\ngeneric_make_request(bio);\r\n}\r\nstatic void process_rpc_calls(struct era *era)\r\n{\r\nint r;\r\nbool need_commit = false;\r\nstruct list_head calls;\r\nstruct rpc *rpc, *tmp;\r\nINIT_LIST_HEAD(&calls);\r\nspin_lock(&era->rpc_lock);\r\nlist_splice_init(&era->rpc_calls, &calls);\r\nspin_unlock(&era->rpc_lock);\r\nlist_for_each_entry_safe(rpc, tmp, &calls, list) {\r\nrpc->result = rpc->fn0 ? rpc->fn0(era->md) : rpc->fn1(era->md, rpc->arg);\r\nneed_commit = true;\r\n}\r\nif (need_commit) {\r\nr = metadata_commit(era->md);\r\nif (r)\r\nlist_for_each_entry_safe(rpc, tmp, &calls, list)\r\nrpc->result = r;\r\n}\r\nlist_for_each_entry_safe(rpc, tmp, &calls, list)\r\ncomplete(&rpc->complete);\r\n}\r\nstatic void kick_off_digest(struct era *era)\r\n{\r\nif (era->md->archived_writesets) {\r\nera->md->archived_writesets = false;\r\nmetadata_digest_start(era->md, &era->digest);\r\n}\r\n}\r\nstatic void do_work(struct work_struct *ws)\r\n{\r\nstruct era *era = container_of(ws, struct era, worker);\r\nkick_off_digest(era);\r\nprocess_old_eras(era);\r\nprocess_deferred_bios(era);\r\nprocess_rpc_calls(era);\r\n}\r\nstatic void defer_bio(struct era *era, struct bio *bio)\r\n{\r\nspin_lock(&era->deferred_lock);\r\nbio_list_add(&era->deferred_bios, bio);\r\nspin_unlock(&era->deferred_lock);\r\nwake_worker(era);\r\n}\r\nstatic int perform_rpc(struct era *era, struct rpc *rpc)\r\n{\r\nrpc->result = 0;\r\ninit_completion(&rpc->complete);\r\nspin_lock(&era->rpc_lock);\r\nlist_add(&rpc->list, &era->rpc_calls);\r\nspin_unlock(&era->rpc_lock);\r\nwake_worker(era);\r\nwait_for_completion(&rpc->complete);\r\nreturn rpc->result;\r\n}\r\nstatic int in_worker0(struct era *era, int (*fn)(struct era_metadata *))\r\n{\r\nstruct rpc rpc;\r\nrpc.fn0 = fn;\r\nrpc.fn1 = NULL;\r\nreturn perform_rpc(era, &rpc);\r\n}\r\nstatic int in_worker1(struct era *era,\r\nint (*fn)(struct era_metadata *, void *), void *arg)\r\n{\r\nstruct rpc rpc;\r\nrpc.fn0 = NULL;\r\nrpc.fn1 = fn;\r\nrpc.arg = arg;\r\nreturn perform_rpc(era, &rpc);\r\n}\r\nstatic void start_worker(struct era *era)\r\n{\r\natomic_set(&era->suspended, 0);\r\n}\r\nstatic void stop_worker(struct era *era)\r\n{\r\natomic_set(&era->suspended, 1);\r\nflush_workqueue(era->wq);\r\n}\r\nstatic int dev_is_congested(struct dm_dev *dev, int bdi_bits)\r\n{\r\nstruct request_queue *q = bdev_get_queue(dev->bdev);\r\nreturn bdi_congested(&q->backing_dev_info, bdi_bits);\r\n}\r\nstatic int era_is_congested(struct dm_target_callbacks *cb, int bdi_bits)\r\n{\r\nstruct era *era = container_of(cb, struct era, callbacks);\r\nreturn dev_is_congested(era->origin_dev, bdi_bits);\r\n}\r\nstatic void era_destroy(struct era *era)\r\n{\r\nif (era->md)\r\nmetadata_close(era->md);\r\nif (era->wq)\r\ndestroy_workqueue(era->wq);\r\nif (era->origin_dev)\r\ndm_put_device(era->ti, era->origin_dev);\r\nif (era->metadata_dev)\r\ndm_put_device(era->ti, era->metadata_dev);\r\nkfree(era);\r\n}\r\nstatic dm_block_t calc_nr_blocks(struct era *era)\r\n{\r\nreturn dm_sector_div_up(era->ti->len, era->sectors_per_block);\r\n}\r\nstatic bool valid_block_size(dm_block_t block_size)\r\n{\r\nbool greater_than_zero = block_size > 0;\r\nbool multiple_of_min_block_size = (block_size & (MIN_BLOCK_SIZE - 1)) == 0;\r\nreturn greater_than_zero && multiple_of_min_block_size;\r\n}\r\nstatic int era_ctr(struct dm_target *ti, unsigned argc, char **argv)\r\n{\r\nint r;\r\nchar dummy;\r\nstruct era *era;\r\nstruct era_metadata *md;\r\nif (argc != 3) {\r\nti->error = "Invalid argument count";\r\nreturn -EINVAL;\r\n}\r\nera = kzalloc(sizeof(*era), GFP_KERNEL);\r\nif (!era) {\r\nti->error = "Error allocating era structure";\r\nreturn -ENOMEM;\r\n}\r\nera->ti = ti;\r\nr = dm_get_device(ti, argv[0], FMODE_READ | FMODE_WRITE, &era->metadata_dev);\r\nif (r) {\r\nti->error = "Error opening metadata device";\r\nera_destroy(era);\r\nreturn -EINVAL;\r\n}\r\nr = dm_get_device(ti, argv[1], FMODE_READ | FMODE_WRITE, &era->origin_dev);\r\nif (r) {\r\nti->error = "Error opening data device";\r\nera_destroy(era);\r\nreturn -EINVAL;\r\n}\r\nr = sscanf(argv[2], "%u%c", &era->sectors_per_block, &dummy);\r\nif (r != 1) {\r\nti->error = "Error parsing block size";\r\nera_destroy(era);\r\nreturn -EINVAL;\r\n}\r\nr = dm_set_target_max_io_len(ti, era->sectors_per_block);\r\nif (r) {\r\nti->error = "could not set max io len";\r\nera_destroy(era);\r\nreturn -EINVAL;\r\n}\r\nif (!valid_block_size(era->sectors_per_block)) {\r\nti->error = "Invalid block size";\r\nera_destroy(era);\r\nreturn -EINVAL;\r\n}\r\nif (era->sectors_per_block & (era->sectors_per_block - 1))\r\nera->sectors_per_block_shift = -1;\r\nelse\r\nera->sectors_per_block_shift = __ffs(era->sectors_per_block);\r\nmd = metadata_open(era->metadata_dev->bdev, era->sectors_per_block, true);\r\nif (IS_ERR(md)) {\r\nti->error = "Error reading metadata";\r\nera_destroy(era);\r\nreturn PTR_ERR(md);\r\n}\r\nera->md = md;\r\nera->nr_blocks = calc_nr_blocks(era);\r\nr = metadata_resize(era->md, &era->nr_blocks);\r\nif (r) {\r\nti->error = "couldn't resize metadata";\r\nera_destroy(era);\r\nreturn -ENOMEM;\r\n}\r\nera->wq = alloc_ordered_workqueue("dm-" DM_MSG_PREFIX, WQ_MEM_RECLAIM);\r\nif (!era->wq) {\r\nti->error = "could not create workqueue for metadata object";\r\nera_destroy(era);\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&era->worker, do_work);\r\nspin_lock_init(&era->deferred_lock);\r\nbio_list_init(&era->deferred_bios);\r\nspin_lock_init(&era->rpc_lock);\r\nINIT_LIST_HEAD(&era->rpc_calls);\r\nti->private = era;\r\nti->num_flush_bios = 1;\r\nti->flush_supported = true;\r\nti->num_discard_bios = 1;\r\nti->discards_supported = true;\r\nera->callbacks.congested_fn = era_is_congested;\r\ndm_table_add_target_callbacks(ti->table, &era->callbacks);\r\nreturn 0;\r\n}\r\nstatic void era_dtr(struct dm_target *ti)\r\n{\r\nera_destroy(ti->private);\r\n}\r\nstatic int era_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct era *era = ti->private;\r\ndm_block_t block = get_block(era, bio);\r\nremap_to_origin(era, bio);\r\nif (!(bio->bi_rw & REQ_FLUSH) &&\r\n(bio_data_dir(bio) == WRITE) &&\r\n!metadata_current_marked(era->md, block)) {\r\ndefer_bio(era, bio);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nstatic void era_postsuspend(struct dm_target *ti)\r\n{\r\nint r;\r\nstruct era *era = ti->private;\r\nr = in_worker0(era, metadata_era_archive);\r\nif (r) {\r\nDMERR("%s: couldn't archive current era", __func__);\r\n}\r\nstop_worker(era);\r\n}\r\nstatic int era_preresume(struct dm_target *ti)\r\n{\r\nint r;\r\nstruct era *era = ti->private;\r\ndm_block_t new_size = calc_nr_blocks(era);\r\nif (era->nr_blocks != new_size) {\r\nr = in_worker1(era, metadata_resize, &new_size);\r\nif (r)\r\nreturn r;\r\nera->nr_blocks = new_size;\r\n}\r\nstart_worker(era);\r\nr = in_worker0(era, metadata_new_era);\r\nif (r) {\r\nDMERR("%s: metadata_era_rollover failed", __func__);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void era_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nint r;\r\nstruct era *era = ti->private;\r\nssize_t sz = 0;\r\nstruct metadata_stats stats;\r\nchar buf[BDEVNAME_SIZE];\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nr = in_worker1(era, metadata_get_stats, &stats);\r\nif (r)\r\ngoto err;\r\nDMEMIT("%u %llu/%llu %u",\r\n(unsigned) (DM_ERA_METADATA_BLOCK_SIZE >> SECTOR_SHIFT),\r\n(unsigned long long) stats.used,\r\n(unsigned long long) stats.total,\r\n(unsigned) stats.era);\r\nif (stats.snap != SUPERBLOCK_LOCATION)\r\nDMEMIT(" %llu", stats.snap);\r\nelse\r\nDMEMIT(" -");\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nformat_dev_t(buf, era->metadata_dev->bdev->bd_dev);\r\nDMEMIT("%s ", buf);\r\nformat_dev_t(buf, era->origin_dev->bdev->bd_dev);\r\nDMEMIT("%s %u", buf, era->sectors_per_block);\r\nbreak;\r\n}\r\nreturn;\r\nerr:\r\nDMEMIT("Error");\r\n}\r\nstatic int era_message(struct dm_target *ti, unsigned argc, char **argv)\r\n{\r\nstruct era *era = ti->private;\r\nif (argc != 1) {\r\nDMERR("incorrect number of message arguments");\r\nreturn -EINVAL;\r\n}\r\nif (!strcasecmp(argv[0], "checkpoint"))\r\nreturn in_worker0(era, metadata_checkpoint);\r\nif (!strcasecmp(argv[0], "take_metadata_snap"))\r\nreturn in_worker0(era, metadata_take_snap);\r\nif (!strcasecmp(argv[0], "drop_metadata_snap"))\r\nreturn in_worker0(era, metadata_drop_snap);\r\nDMERR("unsupported message '%s'", argv[0]);\r\nreturn -EINVAL;\r\n}\r\nstatic sector_t get_dev_size(struct dm_dev *dev)\r\n{\r\nreturn i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT;\r\n}\r\nstatic int era_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct era *era = ti->private;\r\nreturn fn(ti, era->origin_dev, 0, get_dev_size(era->origin_dev), data);\r\n}\r\nstatic int era_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\r\nstruct bio_vec *biovec, int max_size)\r\n{\r\nstruct era *era = ti->private;\r\nstruct request_queue *q = bdev_get_queue(era->origin_dev->bdev);\r\nif (!q->merge_bvec_fn)\r\nreturn max_size;\r\nbvm->bi_bdev = era->origin_dev->bdev;\r\nreturn min(max_size, q->merge_bvec_fn(q, bvm, biovec));\r\n}\r\nstatic void era_io_hints(struct dm_target *ti, struct queue_limits *limits)\r\n{\r\nstruct era *era = ti->private;\r\nuint64_t io_opt_sectors = limits->io_opt >> SECTOR_SHIFT;\r\nif (io_opt_sectors < era->sectors_per_block ||\r\ndo_div(io_opt_sectors, era->sectors_per_block)) {\r\nblk_limits_io_min(limits, 0);\r\nblk_limits_io_opt(limits, era->sectors_per_block << SECTOR_SHIFT);\r\n}\r\n}\r\nstatic int __init dm_era_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&era_target);\r\nif (r) {\r\nDMERR("era target registration failed: %d", r);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit dm_era_exit(void)\r\n{\r\ndm_unregister_target(&era_target);\r\n}
