struct hashtab *hashtab_create(u32 (*hash_value)(struct hashtab *h, const void *key),\r\nint (*keycmp)(struct hashtab *h, const void *key1, const void *key2),\r\nu32 size)\r\n{\r\nstruct hashtab *p;\r\nu32 i;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == NULL)\r\nreturn p;\r\np->size = size;\r\np->nel = 0;\r\np->hash_value = hash_value;\r\np->keycmp = keycmp;\r\np->htable = kmalloc(sizeof(*(p->htable)) * size, GFP_KERNEL);\r\nif (p->htable == NULL) {\r\nkfree(p);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < size; i++)\r\np->htable[i] = NULL;\r\nreturn p;\r\n}\r\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\r\n{\r\nu32 hvalue;\r\nstruct hashtab_node *prev, *cur, *newnode;\r\ncond_resched();\r\nif (!h || h->nel == HASHTAB_MAX_NODES)\r\nreturn -EINVAL;\r\nhvalue = h->hash_value(h, key);\r\nprev = NULL;\r\ncur = h->htable[hvalue];\r\nwhile (cur && h->keycmp(h, key, cur->key) > 0) {\r\nprev = cur;\r\ncur = cur->next;\r\n}\r\nif (cur && (h->keycmp(h, key, cur->key) == 0))\r\nreturn -EEXIST;\r\nnewnode = kzalloc(sizeof(*newnode), GFP_KERNEL);\r\nif (newnode == NULL)\r\nreturn -ENOMEM;\r\nnewnode->key = key;\r\nnewnode->datum = datum;\r\nif (prev) {\r\nnewnode->next = prev->next;\r\nprev->next = newnode;\r\n} else {\r\nnewnode->next = h->htable[hvalue];\r\nh->htable[hvalue] = newnode;\r\n}\r\nh->nel++;\r\nreturn 0;\r\n}\r\nvoid *hashtab_search(struct hashtab *h, const void *key)\r\n{\r\nu32 hvalue;\r\nstruct hashtab_node *cur;\r\nif (!h)\r\nreturn NULL;\r\nhvalue = h->hash_value(h, key);\r\ncur = h->htable[hvalue];\r\nwhile (cur && h->keycmp(h, key, cur->key) > 0)\r\ncur = cur->next;\r\nif (cur == NULL || (h->keycmp(h, key, cur->key) != 0))\r\nreturn NULL;\r\nreturn cur->datum;\r\n}\r\nvoid hashtab_destroy(struct hashtab *h)\r\n{\r\nu32 i;\r\nstruct hashtab_node *cur, *temp;\r\nif (!h)\r\nreturn;\r\nfor (i = 0; i < h->size; i++) {\r\ncur = h->htable[i];\r\nwhile (cur) {\r\ntemp = cur;\r\ncur = cur->next;\r\nkfree(temp);\r\n}\r\nh->htable[i] = NULL;\r\n}\r\nkfree(h->htable);\r\nh->htable = NULL;\r\nkfree(h);\r\n}\r\nint hashtab_map(struct hashtab *h,\r\nint (*apply)(void *k, void *d, void *args),\r\nvoid *args)\r\n{\r\nu32 i;\r\nint ret;\r\nstruct hashtab_node *cur;\r\nif (!h)\r\nreturn 0;\r\nfor (i = 0; i < h->size; i++) {\r\ncur = h->htable[i];\r\nwhile (cur) {\r\nret = apply(cur->key, cur->datum, args);\r\nif (ret)\r\nreturn ret;\r\ncur = cur->next;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid hashtab_stat(struct hashtab *h, struct hashtab_info *info)\r\n{\r\nu32 i, chain_len, slots_used, max_chain_len;\r\nstruct hashtab_node *cur;\r\nslots_used = 0;\r\nmax_chain_len = 0;\r\nfor (slots_used = max_chain_len = i = 0; i < h->size; i++) {\r\ncur = h->htable[i];\r\nif (cur) {\r\nslots_used++;\r\nchain_len = 0;\r\nwhile (cur) {\r\nchain_len++;\r\ncur = cur->next;\r\n}\r\nif (chain_len > max_chain_len)\r\nmax_chain_len = chain_len;\r\n}\r\n}\r\ninfo->slots_used = slots_used;\r\ninfo->max_chain_len = max_chain_len;\r\n}
