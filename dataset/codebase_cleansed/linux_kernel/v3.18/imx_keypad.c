static void imx_keypad_scan_matrix(struct imx_keypad *keypad,\r\nunsigned short *matrix_volatile_state)\r\n{\r\nint col;\r\nunsigned short reg_val;\r\nfor (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {\r\nif ((keypad->cols_en_mask & (1 << col)) == 0)\r\ncontinue;\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nreg_val |= 0xff00;\r\nwritew(reg_val, keypad->mmio_base + KPDR);\r\nreg_val = readw(keypad->mmio_base + KPCR);\r\nreg_val &= ~((keypad->cols_en_mask & 0xff) << 8);\r\nwritew(reg_val, keypad->mmio_base + KPCR);\r\nudelay(2);\r\nreg_val = readw(keypad->mmio_base + KPCR);\r\nreg_val |= (keypad->cols_en_mask & 0xff) << 8;\r\nwritew(reg_val, keypad->mmio_base + KPCR);\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nreg_val &= ~(1 << (8 + col));\r\nwritew(reg_val, keypad->mmio_base + KPDR);\r\nudelay(5);\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nmatrix_volatile_state[col] = (~reg_val) & keypad->rows_en_mask;\r\n}\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nreg_val &= 0x00ff;\r\nwritew(reg_val, keypad->mmio_base + KPDR);\r\n}\r\nstatic void imx_keypad_fire_events(struct imx_keypad *keypad,\r\nunsigned short *matrix_volatile_state)\r\n{\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nint row, col;\r\nfor (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {\r\nunsigned short bits_changed;\r\nint code;\r\nif ((keypad->cols_en_mask & (1 << col)) == 0)\r\ncontinue;\r\nbits_changed = keypad->matrix_stable_state[col] ^\r\nmatrix_volatile_state[col];\r\nif (bits_changed == 0)\r\ncontinue;\r\nfor (row = 0; row < MAX_MATRIX_KEY_ROWS; row++) {\r\nif ((keypad->rows_en_mask & (1 << row)) == 0)\r\ncontinue;\r\nif ((bits_changed & (1 << row)) == 0)\r\ncontinue;\r\ncode = MATRIX_SCAN_CODE(row, col, MATRIX_ROW_SHIFT);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev, keypad->keycodes[code],\r\nmatrix_volatile_state[col] & (1 << row));\r\ndev_dbg(&input_dev->dev, "Event code: %d, val: %d",\r\nkeypad->keycodes[code],\r\nmatrix_volatile_state[col] & (1 << row));\r\n}\r\n}\r\ninput_sync(input_dev);\r\n}\r\nstatic void imx_keypad_check_for_events(unsigned long data)\r\n{\r\nstruct imx_keypad *keypad = (struct imx_keypad *) data;\r\nunsigned short matrix_volatile_state[MAX_MATRIX_KEY_COLS];\r\nunsigned short reg_val;\r\nbool state_changed, is_zero_matrix;\r\nint i;\r\nmemset(matrix_volatile_state, 0, sizeof(matrix_volatile_state));\r\nimx_keypad_scan_matrix(keypad, matrix_volatile_state);\r\nstate_changed = false;\r\nfor (i = 0; i < MAX_MATRIX_KEY_COLS; i++) {\r\nif ((keypad->cols_en_mask & (1 << i)) == 0)\r\ncontinue;\r\nif (keypad->matrix_unstable_state[i] ^ matrix_volatile_state[i]) {\r\nstate_changed = true;\r\nbreak;\r\n}\r\n}\r\nif (state_changed) {\r\nmemcpy(keypad->matrix_unstable_state, matrix_volatile_state,\r\nsizeof(matrix_volatile_state));\r\nkeypad->stable_count = 0;\r\n} else\r\nkeypad->stable_count++;\r\nif (keypad->stable_count < IMX_KEYPAD_SCANS_FOR_STABILITY) {\r\nmod_timer(&keypad->check_matrix_timer,\r\njiffies + msecs_to_jiffies(10));\r\nreturn;\r\n}\r\nif (keypad->stable_count == IMX_KEYPAD_SCANS_FOR_STABILITY) {\r\nimx_keypad_fire_events(keypad, matrix_volatile_state);\r\nmemcpy(keypad->matrix_stable_state, matrix_volatile_state,\r\nsizeof(matrix_volatile_state));\r\n}\r\nis_zero_matrix = true;\r\nfor (i = 0; i < MAX_MATRIX_KEY_COLS; i++) {\r\nif (matrix_volatile_state[i] != 0) {\r\nis_zero_matrix = false;\r\nbreak;\r\n}\r\n}\r\nif (is_zero_matrix) {\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KPKD | KBD_STAT_KDSC;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KDIE;\r\nreg_val &= ~KBD_STAT_KRIE;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\n} else {\r\nmod_timer(&keypad->check_matrix_timer,\r\njiffies + msecs_to_jiffies(60));\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KPKR | KBD_STAT_KRSS;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KRIE;\r\nreg_val &= ~KBD_STAT_KDIE;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\n}\r\n}\r\nstatic irqreturn_t imx_keypad_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct imx_keypad *keypad = dev_id;\r\nunsigned short reg_val;\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val &= ~(KBD_STAT_KRIE | KBD_STAT_KDIE);\r\nreg_val |= KBD_STAT_KPKR | KBD_STAT_KPKD;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nif (keypad->enabled) {\r\nkeypad->stable_count = 0;\r\nmod_timer(&keypad->check_matrix_timer,\r\njiffies + msecs_to_jiffies(2));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void imx_keypad_config(struct imx_keypad *keypad)\r\n{\r\nunsigned short reg_val;\r\nreg_val = readw(keypad->mmio_base + KPCR);\r\nreg_val |= keypad->rows_en_mask & 0xff;\r\nreg_val |= (keypad->cols_en_mask & 0xff) << 8;\r\nwritew(reg_val, keypad->mmio_base + KPCR);\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nreg_val &= 0x00ff;\r\nwritew(reg_val, keypad->mmio_base + KPDR);\r\nwritew(0xff00, keypad->mmio_base + KDDR);\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KPKR | KBD_STAT_KPKD |\r\nKBD_STAT_KDSC | KBD_STAT_KRSS;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KDIE;\r\nreg_val &= ~KBD_STAT_KRIE;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\n}\r\nstatic void imx_keypad_inhibit(struct imx_keypad *keypad)\r\n{\r\nunsigned short reg_val;\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val &= ~(KBD_STAT_KRIE | KBD_STAT_KDIE);\r\nreg_val |= KBD_STAT_KPKR | KBD_STAT_KPKD;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nreg_val = (keypad->cols_en_mask & 0xff) << 8;\r\nwritew(reg_val, keypad->mmio_base + KPCR);\r\n}\r\nstatic void imx_keypad_close(struct input_dev *dev)\r\n{\r\nstruct imx_keypad *keypad = input_get_drvdata(dev);\r\ndev_dbg(&dev->dev, ">%s\n", __func__);\r\nkeypad->enabled = false;\r\nsynchronize_irq(keypad->irq);\r\ndel_timer_sync(&keypad->check_matrix_timer);\r\nimx_keypad_inhibit(keypad);\r\nclk_disable_unprepare(keypad->clk);\r\n}\r\nstatic int imx_keypad_open(struct input_dev *dev)\r\n{\r\nstruct imx_keypad *keypad = input_get_drvdata(dev);\r\nint error;\r\ndev_dbg(&dev->dev, ">%s\n", __func__);\r\nerror = clk_prepare_enable(keypad->clk);\r\nif (error)\r\nreturn error;\r\nkeypad->enabled = true;\r\nimx_keypad_config(keypad);\r\nif ((readw(keypad->mmio_base + KPDR) & keypad->rows_en_mask) == 0) {\r\ndev_err(&dev->dev,\r\n"too many keys pressed, control pins initialisation\n");\r\ngoto open_err;\r\n}\r\nreturn 0;\r\nopen_err:\r\nimx_keypad_close(dev);\r\nreturn -EIO;\r\n}\r\nstatic int imx_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct matrix_keymap_data *keymap_data =\r\ndev_get_platdata(&pdev->dev);\r\nstruct imx_keypad *keypad;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint irq, error, i, row, col;\r\nif (!keymap_data && !pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "no keymap defined\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq defined in platform data\n");\r\nreturn irq;\r\n}\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate the input device\n");\r\nreturn -ENOMEM;\r\n}\r\nkeypad = devm_kzalloc(&pdev->dev, sizeof(struct imx_keypad),\r\nGFP_KERNEL);\r\nif (!keypad) {\r\ndev_err(&pdev->dev, "not enough memory for driver data\n");\r\nreturn -ENOMEM;\r\n}\r\nkeypad->input_dev = input_dev;\r\nkeypad->irq = irq;\r\nkeypad->stable_count = 0;\r\nsetup_timer(&keypad->check_matrix_timer,\r\nimx_keypad_check_for_events, (unsigned long) keypad);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nkeypad->mmio_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(keypad->mmio_base))\r\nreturn PTR_ERR(keypad->mmio_base);\r\nkeypad->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(keypad->clk)) {\r\ndev_err(&pdev->dev, "failed to get keypad clock\n");\r\nreturn PTR_ERR(keypad->clk);\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = imx_keypad_open;\r\ninput_dev->close = imx_keypad_close;\r\nerror = matrix_keypad_build_keymap(keymap_data, NULL,\r\nMAX_MATRIX_KEY_ROWS,\r\nMAX_MATRIX_KEY_COLS,\r\nkeypad->keycodes, input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to build keymap\n");\r\nreturn error;\r\n}\r\nfor (row = 0; row < MAX_MATRIX_KEY_ROWS; row++) {\r\nfor (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {\r\ni = MATRIX_SCAN_CODE(row, col, MATRIX_ROW_SHIFT);\r\nif (keypad->keycodes[i] != KEY_RESERVED) {\r\nkeypad->rows_en_mask |= 1 << row;\r\nkeypad->cols_en_mask |= 1 << col;\r\n}\r\n}\r\n}\r\ndev_dbg(&pdev->dev, "enabled rows mask: %x\n", keypad->rows_en_mask);\r\ndev_dbg(&pdev->dev, "enabled cols mask: %x\n", keypad->cols_en_mask);\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(input_dev, keypad);\r\nclk_prepare_enable(keypad->clk);\r\nimx_keypad_inhibit(keypad);\r\nclk_disable_unprepare(keypad->clk);\r\nerror = devm_request_irq(&pdev->dev, irq, imx_keypad_irq_handler, 0,\r\npdev->name, keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, keypad);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused imx_kbd_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx_keypad *kbd = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kbd->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nclk_disable_unprepare(kbd->clk);\r\nmutex_unlock(&input_dev->mutex);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(kbd->irq);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused imx_kbd_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx_keypad *kbd = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kbd->input_dev;\r\nint ret = 0;\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(kbd->irq);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users) {\r\nret = clk_prepare_enable(kbd->clk);\r\nif (ret)\r\ngoto err_clk;\r\n}\r\nerr_clk:\r\nmutex_unlock(&input_dev->mutex);\r\nreturn ret;\r\n}
