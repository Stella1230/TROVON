int si470x_get_register(struct si470x_device *radio, int regnr)\r\n{\r\nu16 buf[READ_REG_NUM];\r\nstruct i2c_msg msgs[1] = {\r\n{\r\n.addr = radio->client->addr,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(u16) * READ_REG_NUM,\r\n.buf = (void *)buf\r\n},\r\n};\r\nif (i2c_transfer(radio->client->adapter, msgs, 1) != 1)\r\nreturn -EIO;\r\nradio->registers[regnr] = __be16_to_cpu(buf[READ_INDEX(regnr)]);\r\nreturn 0;\r\n}\r\nint si470x_set_register(struct si470x_device *radio, int regnr)\r\n{\r\nint i;\r\nu16 buf[WRITE_REG_NUM];\r\nstruct i2c_msg msgs[1] = {\r\n{\r\n.addr = radio->client->addr,\r\n.len = sizeof(u16) * WRITE_REG_NUM,\r\n.buf = (void *)buf\r\n},\r\n};\r\nfor (i = 0; i < WRITE_REG_NUM; i++)\r\nbuf[i] = __cpu_to_be16(radio->registers[WRITE_INDEX(i)]);\r\nif (i2c_transfer(radio->client->adapter, msgs, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int si470x_get_all_registers(struct si470x_device *radio)\r\n{\r\nint i;\r\nu16 buf[READ_REG_NUM];\r\nstruct i2c_msg msgs[1] = {\r\n{\r\n.addr = radio->client->addr,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(u16) * READ_REG_NUM,\r\n.buf = (void *)buf\r\n},\r\n};\r\nif (i2c_transfer(radio->client->adapter, msgs, 1) != 1)\r\nreturn -EIO;\r\nfor (i = 0; i < READ_REG_NUM; i++)\r\nradio->registers[i] = __be16_to_cpu(buf[READ_INDEX(i)]);\r\nreturn 0;\r\n}\r\nint si470x_fops_open(struct file *file)\r\n{\r\nstruct si470x_device *radio = video_drvdata(file);\r\nint retval = v4l2_fh_open(file);\r\nif (retval)\r\nreturn retval;\r\nif (v4l2_fh_is_singular_file(file)) {\r\nretval = si470x_start(radio);\r\nif (retval < 0)\r\ngoto done;\r\nradio->registers[SYSCONFIG1] |= SYSCONFIG1_RDSIEN;\r\nradio->registers[SYSCONFIG1] |= SYSCONFIG1_STCIEN;\r\nradio->registers[SYSCONFIG1] &= ~SYSCONFIG1_GPIO2;\r\nradio->registers[SYSCONFIG1] |= 0x1 << 2;\r\nretval = si470x_set_register(radio, SYSCONFIG1);\r\n}\r\ndone:\r\nif (retval)\r\nv4l2_fh_release(file);\r\nreturn retval;\r\n}\r\nint si470x_fops_release(struct file *file)\r\n{\r\nstruct si470x_device *radio = video_drvdata(file);\r\nif (v4l2_fh_is_singular_file(file))\r\nsi470x_stop(radio);\r\nreturn v4l2_fh_release(file);\r\n}\r\nint si470x_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *capability)\r\n{\r\nstrlcpy(capability->driver, DRIVER_NAME, sizeof(capability->driver));\r\nstrlcpy(capability->card, DRIVER_CARD, sizeof(capability->card));\r\ncapability->device_caps = V4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_READWRITE |\r\nV4L2_CAP_TUNER | V4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE;\r\ncapability->capabilities = capability->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t si470x_i2c_interrupt(int irq, void *dev_id)\r\n{\r\nstruct si470x_device *radio = dev_id;\r\nunsigned char regnr;\r\nunsigned char blocknum;\r\nunsigned short bler;\r\nunsigned short rds;\r\nunsigned char tmpbuf[3];\r\nint retval = 0;\r\nretval = si470x_get_register(radio, STATUSRSSI);\r\nif (retval < 0)\r\ngoto end;\r\nif (radio->registers[STATUSRSSI] & STATUSRSSI_STC)\r\ncomplete(&radio->completion);\r\nif ((radio->registers[SYSCONFIG1] & SYSCONFIG1_RDS) == 0)\r\ngoto end;\r\nfor (regnr = 1; regnr < RDS_REGISTER_NUM; regnr++) {\r\nretval = si470x_get_register(radio, STATUSRSSI + regnr);\r\nif (retval < 0)\r\ngoto end;\r\n}\r\nif ((radio->registers[STATUSRSSI] & STATUSRSSI_RDSR) == 0)\r\ngoto end;\r\nfor (blocknum = 0; blocknum < 4; blocknum++) {\r\nswitch (blocknum) {\r\ndefault:\r\nbler = (radio->registers[STATUSRSSI] &\r\nSTATUSRSSI_BLERA) >> 9;\r\nrds = radio->registers[RDSA];\r\nbreak;\r\ncase 1:\r\nbler = (radio->registers[READCHAN] &\r\nREADCHAN_BLERB) >> 14;\r\nrds = radio->registers[RDSB];\r\nbreak;\r\ncase 2:\r\nbler = (radio->registers[READCHAN] &\r\nREADCHAN_BLERC) >> 12;\r\nrds = radio->registers[RDSC];\r\nbreak;\r\ncase 3:\r\nbler = (radio->registers[READCHAN] &\r\nREADCHAN_BLERD) >> 10;\r\nrds = radio->registers[RDSD];\r\nbreak;\r\n}\r\nput_unaligned_le16(rds, &tmpbuf);\r\ntmpbuf[2] = blocknum;\r\ntmpbuf[2] |= blocknum << 3;\r\nif (bler > max_rds_errors)\r\ntmpbuf[2] |= 0x80;\r\nelse if (bler > 0)\r\ntmpbuf[2] |= 0x40;\r\nmemcpy(&radio->buffer[radio->wr_index], &tmpbuf, 3);\r\nradio->wr_index += 3;\r\nif (radio->wr_index >= radio->buf_size)\r\nradio->wr_index = 0;\r\nif (radio->wr_index == radio->rd_index) {\r\nradio->rd_index += 3;\r\nif (radio->rd_index >= radio->buf_size)\r\nradio->rd_index = 0;\r\n}\r\n}\r\nif (radio->wr_index != radio->rd_index)\r\nwake_up_interruptible(&radio->read_queue);\r\nend:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int si470x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct si470x_device *radio;\r\nint retval = 0;\r\nunsigned char version_warning = 0;\r\nradio = kzalloc(sizeof(struct si470x_device), GFP_KERNEL);\r\nif (!radio) {\r\nretval = -ENOMEM;\r\ngoto err_initial;\r\n}\r\nradio->client = client;\r\nradio->band = 1;\r\nmutex_init(&radio->lock);\r\ninit_completion(&radio->completion);\r\nradio->videodev = si470x_viddev_template;\r\nvideo_set_drvdata(&radio->videodev, radio);\r\nradio->registers[POWERCFG] = POWERCFG_ENABLE;\r\nif (si470x_set_register(radio, POWERCFG) < 0) {\r\nretval = -EIO;\r\ngoto err_radio;\r\n}\r\nmsleep(110);\r\nif (si470x_get_all_registers(radio) < 0) {\r\nretval = -EIO;\r\ngoto err_radio;\r\n}\r\ndev_info(&client->dev, "DeviceID=0x%4.4hx ChipID=0x%4.4hx\n",\r\nradio->registers[DEVICEID], radio->registers[CHIPID]);\r\nif ((radio->registers[CHIPID] & CHIPID_FIRMWARE) < RADIO_FW_VERSION) {\r\ndev_warn(&client->dev,\r\n"This driver is known to work with "\r\n"firmware version %hu,\n", RADIO_FW_VERSION);\r\ndev_warn(&client->dev,\r\n"but the device has firmware version %hu.\n",\r\nradio->registers[CHIPID] & CHIPID_FIRMWARE);\r\nversion_warning = 1;\r\n}\r\nif (version_warning == 1) {\r\ndev_warn(&client->dev,\r\n"If you have some trouble using this driver,\n");\r\ndev_warn(&client->dev,\r\n"please report to V4L ML at "\r\n"linux-media@vger.kernel.org\n");\r\n}\r\nsi470x_set_freq(radio, 87.5 * FREQ_MUL);\r\nradio->buf_size = rds_buf * 3;\r\nradio->buffer = kmalloc(radio->buf_size, GFP_KERNEL);\r\nif (!radio->buffer) {\r\nretval = -EIO;\r\ngoto err_radio;\r\n}\r\nradio->wr_index = 0;\r\nradio->rd_index = 0;\r\ninit_waitqueue_head(&radio->read_queue);\r\nretval = request_threaded_irq(client->irq, NULL, si470x_i2c_interrupt,\r\nIRQF_TRIGGER_FALLING, DRIVER_NAME, radio);\r\nif (retval) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\ngoto err_rds;\r\n}\r\nretval = video_register_device(&radio->videodev, VFL_TYPE_RADIO,\r\nradio_nr);\r\nif (retval) {\r\ndev_warn(&client->dev, "Could not register video device\n");\r\ngoto err_all;\r\n}\r\ni2c_set_clientdata(client, radio);\r\nreturn 0;\r\nerr_all:\r\nfree_irq(client->irq, radio);\r\nerr_rds:\r\nkfree(radio->buffer);\r\nerr_radio:\r\nkfree(radio);\r\nerr_initial:\r\nreturn retval;\r\n}\r\nstatic int si470x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct si470x_device *radio = i2c_get_clientdata(client);\r\nfree_irq(client->irq, radio);\r\nvideo_unregister_device(&radio->videodev);\r\nkfree(radio);\r\nreturn 0;\r\n}\r\nstatic int si470x_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct si470x_device *radio = i2c_get_clientdata(client);\r\nradio->registers[POWERCFG] |= POWERCFG_DISABLE;\r\nif (si470x_set_register(radio, POWERCFG) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int si470x_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct si470x_device *radio = i2c_get_clientdata(client);\r\nradio->registers[POWERCFG] |= POWERCFG_ENABLE;\r\nif (si470x_set_register(radio, POWERCFG) < 0)\r\nreturn -EIO;\r\nmsleep(110);\r\nreturn 0;\r\n}
