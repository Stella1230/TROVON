static enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw)\r\n{\r\nreturn ixgbe_media_type_copper;\r\n}\r\nstatic s32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mac_info *mac = &hw->mac;\r\nixgbe_identify_phy_generic(hw);\r\nmac->mcft_size = IXGBE_X540_MC_TBL_SIZE;\r\nmac->vft_size = IXGBE_X540_VFT_TBL_SIZE;\r\nmac->num_rar_entries = IXGBE_X540_RAR_ENTRIES;\r\nmac->rx_pb_size = IXGBE_X540_RX_PB_SIZE;\r\nmac->max_rx_queues = IXGBE_X540_MAX_RX_QUEUES;\r\nmac->max_tx_queues = IXGBE_X540_MAX_TX_QUEUES;\r\nmac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\nreturn hw->phy.ops.setup_link_speed(hw, speed,\r\nautoneg_wait_to_complete);\r\n}\r\nstatic s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nu32 ctrl, i;\r\nstatus = hw->mac.ops.stop_adapter(hw);\r\nif (status)\r\nreturn status;\r\nixgbe_clear_tx_pending(hw);\r\nmac_reset_top:\r\nctrl = IXGBE_CTRL_RST;\r\nctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);\r\nIXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nfor (i = 0; i < 10; i++) {\r\nudelay(1);\r\nctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);\r\nif (!(ctrl & IXGBE_CTRL_RST_MASK))\r\nbreak;\r\n}\r\nif (ctrl & IXGBE_CTRL_RST_MASK) {\r\nstatus = IXGBE_ERR_RESET_FAILED;\r\nhw_dbg(hw, "Reset polling failed to complete.\n");\r\n}\r\nmsleep(100);\r\nif (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {\r\nhw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\r\ngoto mac_reset_top;\r\n}\r\nIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(0), 384 << IXGBE_RXPBSIZE_SHIFT);\r\nhw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);\r\nhw->mac.num_rar_entries = IXGBE_X540_MAX_TX_QUEUES;\r\nhw->mac.ops.init_rx_addrs(hw);\r\nhw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);\r\nif (is_valid_ether_addr(hw->mac.san_addr)) {\r\nhw->mac.ops.set_rar(hw, hw->mac.num_rar_entries - 1,\r\nhw->mac.san_addr, 0, IXGBE_RAH_AV);\r\nhw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;\r\nhw->mac.num_rar_entries--;\r\n}\r\nhw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,\r\n&hw->mac.wwpn_prefix);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val;\r\nret_val = ixgbe_start_hw_generic(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn ixgbe_start_hw_gen2(hw);\r\n}\r\nstatic s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_eeprom_info *eeprom = &hw->eeprom;\r\nu32 eec;\r\nu16 eeprom_size;\r\nif (eeprom->type == ixgbe_eeprom_uninitialized) {\r\neeprom->semaphore_delay = 10;\r\neeprom->type = ixgbe_flash;\r\neec = IXGBE_READ_REG(hw, IXGBE_EEC);\r\neeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>\r\nIXGBE_EEC_SIZE_SHIFT);\r\neeprom->word_size = 1 << (eeprom_size +\r\nIXGBE_EEPROM_WORD_SIZE_SHIFT);\r\nhw_dbg(hw, "Eeprom params: type = %d, size = %d\n",\r\neeprom->type, eeprom->word_size);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data)\r\n{\r\ns32 status;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = ixgbe_read_eerd_generic(hw, offset, data);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw,\r\nu16 offset, u16 words, u16 *data)\r\n{\r\ns32 status;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = ixgbe_read_eerd_buffer_generic(hw, offset, words, data);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data)\r\n{\r\ns32 status;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = ixgbe_write_eewr_generic(hw, offset, data);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw,\r\nu16 offset, u16 words, u16 *data)\r\n{\r\ns32 status;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nstatus = ixgbe_write_eewr_buffer_generic(hw, offset, words, data);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic u16 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)\r\n{\r\nu16 i;\r\nu16 j;\r\nu16 checksum = 0;\r\nu16 length = 0;\r\nu16 pointer = 0;\r\nu16 word = 0;\r\nfor (i = 0; i < IXGBE_EEPROM_CHECKSUM; i++) {\r\nif (ixgbe_read_eerd_generic(hw, i, &word) != 0) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nbreak;\r\n}\r\nchecksum += word;\r\n}\r\nfor (i = IXGBE_PCIE_ANALOG_PTR; i < IXGBE_FW_PTR; i++) {\r\nif (i == IXGBE_PHY_PTR || i == IXGBE_OPTION_ROM_PTR)\r\ncontinue;\r\nif (ixgbe_read_eerd_generic(hw, i, &pointer) != 0) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nbreak;\r\n}\r\nif (pointer == 0xFFFF || pointer == 0 ||\r\npointer >= hw->eeprom.word_size)\r\ncontinue;\r\nif (ixgbe_read_eerd_generic(hw, pointer, &length) != 0) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nbreak;\r\n}\r\nif (length == 0xFFFF || length == 0 ||\r\n(pointer + length) >= hw->eeprom.word_size)\r\ncontinue;\r\nfor (j = pointer+1; j <= pointer+length; j++) {\r\nif (ixgbe_read_eerd_generic(hw, j, &word) != 0) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nbreak;\r\n}\r\nchecksum += word;\r\n}\r\n}\r\nchecksum = (u16)IXGBE_EEPROM_SUM - checksum;\r\nreturn checksum;\r\n}\r\nstatic s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw,\r\nu16 *checksum_val)\r\n{\r\ns32 status;\r\nu16 checksum;\r\nu16 read_checksum = 0;\r\nstatus = hw->eeprom.ops.read(hw, 0, &checksum);\r\nif (status) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn status;\r\n}\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nchecksum = hw->eeprom.ops.calc_checksum(hw);\r\nstatus = ixgbe_read_eerd_generic(hw, IXGBE_EEPROM_CHECKSUM,\r\n&read_checksum);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nif (checksum_val)\r\n*checksum_val = checksum;\r\nif (read_checksum != checksum)\r\nreturn IXGBE_ERR_EEPROM_CHECKSUM;\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)\r\n{\r\ns32 status;\r\nu16 checksum;\r\nstatus = hw->eeprom.ops.read(hw, 0, &checksum);\r\nif (status) {\r\nhw_dbg(hw, "EEPROM read failed\n");\r\nreturn status;\r\n}\r\nif (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nchecksum = hw->eeprom.ops.calc_checksum(hw);\r\nstatus = ixgbe_write_eewr_generic(hw, IXGBE_EEPROM_CHECKSUM, checksum);\r\nif (!status)\r\nstatus = ixgbe_update_flash_X540(hw);\r\nhw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)\r\n{\r\nu32 flup;\r\ns32 status;\r\nstatus = ixgbe_poll_flash_update_done_X540(hw);\r\nif (status == IXGBE_ERR_EEPROM) {\r\nhw_dbg(hw, "Flash update time out\n");\r\nreturn status;\r\n}\r\nflup = IXGBE_READ_REG(hw, IXGBE_EEC) | IXGBE_EEC_FLUP;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC, flup);\r\nstatus = ixgbe_poll_flash_update_done_X540(hw);\r\nif (status == 0)\r\nhw_dbg(hw, "Flash update complete\n");\r\nelse\r\nhw_dbg(hw, "Flash update time out\n");\r\nif (hw->revision_id == 0) {\r\nflup = IXGBE_READ_REG(hw, IXGBE_EEC);\r\nif (flup & IXGBE_EEC_SEC1VAL) {\r\nflup |= IXGBE_EEC_FLUP;\r\nIXGBE_WRITE_REG(hw, IXGBE_EEC, flup);\r\n}\r\nstatus = ixgbe_poll_flash_update_done_X540(hw);\r\nif (status == 0)\r\nhw_dbg(hw, "Flash update complete\n");\r\nelse\r\nhw_dbg(hw, "Flash update time out\n");\r\n}\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)\r\n{\r\nu32 i;\r\nu32 reg;\r\nfor (i = 0; i < IXGBE_FLUDONE_ATTEMPTS; i++) {\r\nreg = IXGBE_READ_REG(hw, IXGBE_EEC);\r\nif (reg & IXGBE_EEC_FLUDONE)\r\nreturn 0;\r\nudelay(5);\r\n}\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nstatic s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u16 mask)\r\n{\r\nu32 swfw_sync;\r\nu32 swmask = mask;\r\nu32 fwmask = mask << 5;\r\nu32 hwmask = 0;\r\nu32 timeout = 200;\r\nu32 i;\r\nif (swmask == IXGBE_GSSR_EEP_SM)\r\nhwmask = IXGBE_GSSR_FLASH_SM;\r\nfor (i = 0; i < timeout; i++) {\r\nif (ixgbe_get_swfw_sync_semaphore(hw))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC);\r\nif (!(swfw_sync & (fwmask | swmask | hwmask))) {\r\nswfw_sync |= swmask;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC, swfw_sync);\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nbreak;\r\n} else {\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nusleep_range(5000, 10000);\r\n}\r\n}\r\nif (i >= timeout) {\r\nswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC);\r\nif (swfw_sync & (fwmask | hwmask)) {\r\nif (ixgbe_get_swfw_sync_semaphore(hw))\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nswfw_sync |= swmask;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC, swfw_sync);\r\nixgbe_release_swfw_sync_semaphore(hw);\r\n}\r\n}\r\nusleep_range(5000, 10000);\r\nreturn 0;\r\n}\r\nstatic void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u16 mask)\r\n{\r\nu32 swfw_sync;\r\nu32 swmask = mask;\r\nixgbe_get_swfw_sync_semaphore(hw);\r\nswfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC);\r\nswfw_sync &= ~swmask;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC, swfw_sync);\r\nixgbe_release_swfw_sync_semaphore(hw);\r\nusleep_range(5000, 10000);\r\n}\r\nstatic s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)\r\n{\r\nu32 timeout = 2000;\r\nu32 i;\r\nu32 swsm;\r\nfor (i = 0; i < timeout; i++) {\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM);\r\nif (!(swsm & IXGBE_SWSM_SMBI))\r\nbreak;\r\nusleep_range(50, 100);\r\n}\r\nif (i == timeout) {\r\nhw_dbg(hw,\r\n"Software semaphore SMBI between device drivers not granted.\n");\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nfor (i = 0; i < timeout; i++) {\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC);\r\nif (!(swsm & IXGBE_SWFW_REGSMP))\r\nreturn 0;\r\nusleep_range(50, 100);\r\n}\r\nreturn IXGBE_ERR_EEPROM;\r\n}\r\nstatic void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)\r\n{\r\nu32 swsm;\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWSM);\r\nswsm &= ~IXGBE_SWSM_SMBI;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWSM, swsm);\r\nswsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC);\r\nswsm &= ~IXGBE_SWFW_REGSMP;\r\nIXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC, swsm);\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nstatic s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)\r\n{\r\nu32 macc_reg;\r\nu32 ledctl_reg;\r\nixgbe_link_speed speed;\r\nbool link_up;\r\nhw->mac.ops.check_link(hw, &speed, &link_up, false);\r\nif (!link_up) {\r\nmacc_reg = IXGBE_READ_REG(hw, IXGBE_MACC);\r\nmacc_reg |= IXGBE_MACC_FLU | IXGBE_MACC_FSV_10G | IXGBE_MACC_FS;\r\nIXGBE_WRITE_REG(hw, IXGBE_MACC, macc_reg);\r\n}\r\nledctl_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nledctl_reg &= ~IXGBE_LED_MODE_MASK(index);\r\nledctl_reg |= IXGBE_LED_BLINK(index);\r\nIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, ledctl_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index)\r\n{\r\nu32 macc_reg;\r\nu32 ledctl_reg;\r\nledctl_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nledctl_reg &= ~IXGBE_LED_MODE_MASK(index);\r\nledctl_reg |= IXGBE_LED_LINK_ACTIVE << IXGBE_LED_MODE_SHIFT(index);\r\nledctl_reg &= ~IXGBE_LED_BLINK(index);\r\nIXGBE_WRITE_REG(hw, IXGBE_LEDCTL, ledctl_reg);\r\nmacc_reg = IXGBE_READ_REG(hw, IXGBE_MACC);\r\nmacc_reg &= ~(IXGBE_MACC_FLU | IXGBE_MACC_FSV_10G | IXGBE_MACC_FS);\r\nIXGBE_WRITE_REG(hw, IXGBE_MACC, macc_reg);\r\nIXGBE_WRITE_FLUSH(hw);\r\nreturn 0;\r\n}
