static struct ci_otg_fsm_timer *otg_timer_initializer\r\n(struct ci_hdrc *ci, void (*function)(void *, unsigned long),\r\nunsigned long expires, unsigned long data)\r\n{\r\nstruct ci_otg_fsm_timer *timer;\r\ntimer = devm_kzalloc(ci->dev, sizeof(struct ci_otg_fsm_timer),\r\nGFP_KERNEL);\r\nif (!timer)\r\nreturn NULL;\r\ntimer->function = function;\r\ntimer->expires = expires;\r\ntimer->data = data;\r\nreturn timer;\r\n}\r\nstatic ssize_t\r\nget_a_bus_req(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nchar *next;\r\nunsigned size, t;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d\n", ci->fsm.a_bus_req);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_a_bus_req(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nmutex_lock(&ci->fsm.lock);\r\nif (buf[0] == '0') {\r\nci->fsm.a_bus_req = 0;\r\n} else if (buf[0] == '1') {\r\nif (ci->fsm.a_bus_drop) {\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nci->fsm.a_bus_req = 1;\r\n}\r\nci_otg_queue_work(ci);\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nget_a_bus_drop(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nchar *next;\r\nunsigned size, t;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d\n", ci->fsm.a_bus_drop);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_a_bus_drop(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nmutex_lock(&ci->fsm.lock);\r\nif (buf[0] == '0') {\r\nci->fsm.a_bus_drop = 0;\r\n} else if (buf[0] == '1') {\r\nci->fsm.a_bus_drop = 1;\r\nci->fsm.a_bus_req = 0;\r\n}\r\nci_otg_queue_work(ci);\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nget_b_bus_req(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nchar *next;\r\nunsigned size, t;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nnext = buf;\r\nsize = PAGE_SIZE;\r\nt = scnprintf(next, size, "%d\n", ci->fsm.b_bus_req);\r\nsize -= t;\r\nnext += t;\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t\r\nset_b_bus_req(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nmutex_lock(&ci->fsm.lock);\r\nif (buf[0] == '0')\r\nci->fsm.b_bus_req = 0;\r\nelse if (buf[0] == '1')\r\nci->fsm.b_bus_req = 1;\r\nci_otg_queue_work(ci);\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nset_a_clr_err(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nmutex_lock(&ci->fsm.lock);\r\nif (buf[0] == '1')\r\nci->fsm.a_clr_err = 1;\r\nci_otg_queue_work(ci);\r\nmutex_unlock(&ci->fsm.lock);\r\nreturn count;\r\n}\r\nstatic void ci_otg_add_timer(struct ci_hdrc *ci, enum ci_otg_fsm_timer_index t)\r\n{\r\nstruct ci_otg_fsm_timer *tmp_timer;\r\nstruct ci_otg_fsm_timer *timer = ci->fsm_timer->timer_list[t];\r\nstruct list_head *active_timers = &ci->fsm_timer->active_timers;\r\nif (t >= NUM_CI_OTG_FSM_TIMERS)\r\nreturn;\r\nlist_for_each_entry(tmp_timer, active_timers, list)\r\nif (tmp_timer == timer) {\r\ntimer->count = timer->expires;\r\nreturn;\r\n}\r\ntimer->count = timer->expires;\r\nlist_add_tail(&timer->list, active_timers);\r\nif (!(hw_read_otgsc(ci, OTGSC_1MSIE)))\r\nhw_write_otgsc(ci, OTGSC_1MSIE, OTGSC_1MSIE);\r\n}\r\nstatic void ci_otg_del_timer(struct ci_hdrc *ci, enum ci_otg_fsm_timer_index t)\r\n{\r\nstruct ci_otg_fsm_timer *tmp_timer, *del_tmp;\r\nstruct ci_otg_fsm_timer *timer = ci->fsm_timer->timer_list[t];\r\nstruct list_head *active_timers = &ci->fsm_timer->active_timers;\r\nif (t >= NUM_CI_OTG_FSM_TIMERS)\r\nreturn;\r\nlist_for_each_entry_safe(tmp_timer, del_tmp, active_timers, list)\r\nif (tmp_timer == timer)\r\nlist_del(&timer->list);\r\nif (list_empty(active_timers))\r\nhw_write_otgsc(ci, OTGSC_1MSIE, 0);\r\n}\r\nstatic inline int ci_otg_tick_timer(struct ci_hdrc *ci)\r\n{\r\nstruct ci_otg_fsm_timer *tmp_timer, *del_tmp;\r\nstruct list_head *active_timers = &ci->fsm_timer->active_timers;\r\nint expired = 0;\r\nlist_for_each_entry_safe(tmp_timer, del_tmp, active_timers, list) {\r\ntmp_timer->count--;\r\nif (!tmp_timer->count) {\r\nlist_del(&tmp_timer->list);\r\ntmp_timer->function(ci, tmp_timer->data);\r\nexpired = 1;\r\n}\r\n}\r\nif ((expired == 1) && list_empty(active_timers))\r\nhw_write_otgsc(ci, OTGSC_1MSIE, 0);\r\nreturn expired;\r\n}\r\nstatic void set_tmout(void *ptr, unsigned long indicator)\r\n{\r\n*(int *)indicator = 1;\r\n}\r\nstatic void set_tmout_and_fsm(void *ptr, unsigned long indicator)\r\n{\r\nstruct ci_hdrc *ci = (struct ci_hdrc *)ptr;\r\nset_tmout(ci, indicator);\r\nci_otg_queue_work(ci);\r\n}\r\nstatic void a_wait_vfall_tmout_func(void *ptr, unsigned long indicator)\r\n{\r\nstruct ci_hdrc *ci = (struct ci_hdrc *)ptr;\r\nset_tmout(ci, indicator);\r\nhw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_PP, 0);\r\nhw_write_otgsc(ci, OTGSC_DPIS, OTGSC_DPIS);\r\nhw_write_otgsc(ci, OTGSC_DPIE, OTGSC_DPIE);\r\nci_otg_queue_work(ci);\r\n}\r\nstatic void b_ase0_brst_tmout_func(void *ptr, unsigned long indicator)\r\n{\r\nstruct ci_hdrc *ci = (struct ci_hdrc *)ptr;\r\nset_tmout(ci, indicator);\r\nif (!hw_read_otgsc(ci, OTGSC_BSV))\r\nci->fsm.b_sess_vld = 0;\r\nci_otg_queue_work(ci);\r\n}\r\nstatic void b_ssend_srp_tmout_func(void *ptr, unsigned long indicator)\r\n{\r\nstruct ci_hdrc *ci = (struct ci_hdrc *)ptr;\r\nset_tmout(ci, indicator);\r\nif (ci->transceiver->state == OTG_STATE_B_IDLE)\r\nci_otg_queue_work(ci);\r\n}\r\nstatic void b_sess_vld_tmout_func(void *ptr, unsigned long indicator)\r\n{\r\nstruct ci_hdrc *ci = (struct ci_hdrc *)ptr;\r\nif (!(hw_read_otgsc(ci, OTGSC_BSV))) {\r\nci->fsm.b_sess_vld = 0;\r\nci_otg_add_timer(ci, B_SSEND_SRP);\r\nci_otg_queue_work(ci);\r\n}\r\n}\r\nstatic void b_data_pulse_end(void *ptr, unsigned long indicator)\r\n{\r\nstruct ci_hdrc *ci = (struct ci_hdrc *)ptr;\r\nci->fsm.b_srp_done = 1;\r\nci->fsm.b_bus_req = 0;\r\nif (ci->fsm.power_up)\r\nci->fsm.power_up = 0;\r\nhw_write_otgsc(ci, OTGSC_HABA, 0);\r\nci_otg_queue_work(ci);\r\n}\r\nstatic int ci_otg_init_timers(struct ci_hdrc *ci)\r\n{\r\nstruct otg_fsm *fsm = &ci->fsm;\r\nci->fsm_timer->timer_list[A_WAIT_VRISE] =\r\notg_timer_initializer(ci, &set_tmout_and_fsm, TA_WAIT_VRISE,\r\n(unsigned long)&fsm->a_wait_vrise_tmout);\r\nif (ci->fsm_timer->timer_list[A_WAIT_VRISE] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[A_WAIT_VFALL] =\r\notg_timer_initializer(ci, &a_wait_vfall_tmout_func,\r\nTA_WAIT_VFALL, (unsigned long)&fsm->a_wait_vfall_tmout);\r\nif (ci->fsm_timer->timer_list[A_WAIT_VFALL] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[A_WAIT_BCON] =\r\notg_timer_initializer(ci, &set_tmout_and_fsm, TA_WAIT_BCON,\r\n(unsigned long)&fsm->a_wait_bcon_tmout);\r\nif (ci->fsm_timer->timer_list[A_WAIT_BCON] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[A_AIDL_BDIS] =\r\notg_timer_initializer(ci, &set_tmout_and_fsm, TA_AIDL_BDIS,\r\n(unsigned long)&fsm->a_aidl_bdis_tmout);\r\nif (ci->fsm_timer->timer_list[A_AIDL_BDIS] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[A_BIDL_ADIS] =\r\notg_timer_initializer(ci, &set_tmout_and_fsm, TA_BIDL_ADIS,\r\n(unsigned long)&fsm->a_bidl_adis_tmout);\r\nif (ci->fsm_timer->timer_list[A_BIDL_ADIS] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[B_ASE0_BRST] =\r\notg_timer_initializer(ci, &b_ase0_brst_tmout_func, TB_ASE0_BRST,\r\n(unsigned long)&fsm->b_ase0_brst_tmout);\r\nif (ci->fsm_timer->timer_list[B_ASE0_BRST] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[B_SE0_SRP] =\r\notg_timer_initializer(ci, &set_tmout_and_fsm, TB_SE0_SRP,\r\n(unsigned long)&fsm->b_se0_srp);\r\nif (ci->fsm_timer->timer_list[B_SE0_SRP] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[B_SSEND_SRP] =\r\notg_timer_initializer(ci, &b_ssend_srp_tmout_func, TB_SSEND_SRP,\r\n(unsigned long)&fsm->b_ssend_srp);\r\nif (ci->fsm_timer->timer_list[B_SSEND_SRP] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[B_SRP_FAIL] =\r\notg_timer_initializer(ci, &set_tmout, TB_SRP_FAIL,\r\n(unsigned long)&fsm->b_srp_done);\r\nif (ci->fsm_timer->timer_list[B_SRP_FAIL] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[B_DATA_PLS] =\r\notg_timer_initializer(ci, &b_data_pulse_end, TB_DATA_PLS, 0);\r\nif (ci->fsm_timer->timer_list[B_DATA_PLS] == NULL)\r\nreturn -ENOMEM;\r\nci->fsm_timer->timer_list[B_SESS_VLD] = otg_timer_initializer(ci,\r\n&b_sess_vld_tmout_func, TB_SESS_VLD, 0);\r\nif (ci->fsm_timer->timer_list[B_SESS_VLD] == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void ci_otg_fsm_add_timer(struct otg_fsm *fsm, enum otg_fsm_timer t)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (t < NUM_OTG_FSM_TIMERS)\r\nci_otg_add_timer(ci, t);\r\nreturn;\r\n}\r\nstatic void ci_otg_fsm_del_timer(struct otg_fsm *fsm, enum otg_fsm_timer t)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (t < NUM_OTG_FSM_TIMERS)\r\nci_otg_del_timer(ci, t);\r\nreturn;\r\n}\r\nstatic void ci_otg_drv_vbus(struct otg_fsm *fsm, int on)\r\n{\r\nint ret;\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (on) {\r\nhw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_PP,\r\nPORTSC_PP);\r\nif (ci->platdata->reg_vbus) {\r\nret = regulator_enable(ci->platdata->reg_vbus);\r\nif (ret) {\r\ndev_err(ci->dev,\r\n"Failed to enable vbus regulator, ret=%d\n",\r\nret);\r\nreturn;\r\n}\r\n}\r\nhw_write_otgsc(ci, OTGSC_DPIE, 0);\r\nfsm->a_srp_det = 0;\r\nfsm->power_up = 0;\r\n} else {\r\nif (ci->platdata->reg_vbus)\r\nregulator_disable(ci->platdata->reg_vbus);\r\nfsm->a_bus_drop = 1;\r\nfsm->a_bus_req = 0;\r\n}\r\n}\r\nstatic void ci_otg_loc_conn(struct otg_fsm *fsm, int on)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (on)\r\nhw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);\r\nelse\r\nhw_write(ci, OP_USBCMD, USBCMD_RS, 0);\r\n}\r\nstatic void ci_otg_loc_sof(struct otg_fsm *fsm, int on)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nif (on)\r\nhw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_FPR,\r\nPORTSC_FPR);\r\nelse\r\nhw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_SUSP,\r\nPORTSC_SUSP);\r\n}\r\nstatic void ci_otg_start_pulse(struct otg_fsm *fsm)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nhw_write_otgsc(ci, OTGSC_HADP, OTGSC_HADP);\r\nci_otg_add_timer(ci, B_DATA_PLS);\r\n}\r\nstatic int ci_otg_start_host(struct otg_fsm *fsm, int on)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nmutex_unlock(&fsm->lock);\r\nif (on) {\r\nci_role_stop(ci);\r\nci_role_start(ci, CI_ROLE_HOST);\r\n} else {\r\nci_role_stop(ci);\r\nhw_device_reset(ci, USBMODE_CM_DC);\r\nci_role_start(ci, CI_ROLE_GADGET);\r\n}\r\nmutex_lock(&fsm->lock);\r\nreturn 0;\r\n}\r\nstatic int ci_otg_start_gadget(struct otg_fsm *fsm, int on)\r\n{\r\nstruct ci_hdrc *ci = container_of(fsm, struct ci_hdrc, fsm);\r\nmutex_unlock(&fsm->lock);\r\nif (on)\r\nusb_gadget_vbus_connect(&ci->gadget);\r\nelse\r\nusb_gadget_vbus_disconnect(&ci->gadget);\r\nmutex_lock(&fsm->lock);\r\nreturn 0;\r\n}\r\nint ci_otg_fsm_work(struct ci_hdrc *ci)\r\n{\r\nif (ci->fsm.id && !(ci->driver) &&\r\nci->transceiver->state < OTG_STATE_A_IDLE)\r\nreturn 0;\r\nif (otg_statemachine(&ci->fsm)) {\r\nif (ci->transceiver->state == OTG_STATE_A_IDLE) {\r\nif ((ci->fsm.id) || (ci->id_event) ||\r\n(ci->fsm.power_up))\r\nci_otg_queue_work(ci);\r\nif (ci->id_event)\r\nci->id_event = false;\r\n} else if (ci->transceiver->state == OTG_STATE_B_IDLE) {\r\nif (ci->fsm.b_sess_vld) {\r\nci->fsm.power_up = 0;\r\nci_otg_queue_work(ci);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_otg_fsm_event(struct ci_hdrc *ci)\r\n{\r\nu32 intr_sts, otg_bsess_vld, port_conn;\r\nstruct otg_fsm *fsm = &ci->fsm;\r\nintr_sts = hw_read_intr_status(ci);\r\notg_bsess_vld = hw_read_otgsc(ci, OTGSC_BSV);\r\nport_conn = hw_read(ci, OP_PORTSC, PORTSC_CCS);\r\nswitch (ci->transceiver->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (port_conn) {\r\nfsm->b_conn = 1;\r\nfsm->a_bus_req = 1;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nif (otg_bsess_vld && (intr_sts & USBi_PCI) && port_conn) {\r\nfsm->b_sess_vld = 1;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif ((intr_sts & USBi_SLI) && port_conn && otg_bsess_vld) {\r\nfsm->a_bus_suspend = 1;\r\nci_otg_queue_work(ci);\r\n} else if (intr_sts & USBi_PCI) {\r\nif (fsm->a_bus_suspend == 1)\r\nfsm->a_bus_suspend = 0;\r\n}\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nif ((intr_sts & USBi_PCI) && !port_conn) {\r\nfsm->a_conn = 0;\r\nfsm->b_bus_req = 0;\r\nci_otg_queue_work(ci);\r\nci_otg_add_timer(ci, B_SESS_VLD);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nif (intr_sts & USBi_SLI) {\r\nfsm->b_bus_suspend = 1;\r\nci_otg_add_timer(ci, A_BIDL_ADIS);\r\n}\r\nif (intr_sts & USBi_URI)\r\nci_otg_del_timer(ci, A_BIDL_ADIS);\r\nif (intr_sts & USBi_PCI) {\r\nif (fsm->b_bus_suspend == 1) {\r\nci_otg_del_timer(ci, A_BIDL_ADIS);\r\nfsm->b_bus_suspend = 0;\r\n}\r\n}\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nif ((intr_sts & USBi_PCI) && !port_conn) {\r\nfsm->b_conn = 0;\r\nif (ci->driver) {\r\nci->gadget.is_a_peripheral = 1;\r\n}\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nif ((intr_sts & USBi_PCI) && !port_conn) {\r\nfsm->b_conn = 0;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\nif ((intr_sts & USBi_PCI) && port_conn) {\r\nfsm->a_conn = 1;\r\nci_otg_queue_work(ci);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nirqreturn_t ci_otg_fsm_irq(struct ci_hdrc *ci)\r\n{\r\nirqreturn_t retval = IRQ_NONE;\r\nu32 otgsc, otg_int_src = 0;\r\nstruct otg_fsm *fsm = &ci->fsm;\r\notgsc = hw_read_otgsc(ci, ~0);\r\notg_int_src = otgsc & OTGSC_INT_STATUS_BITS & (otgsc >> 8);\r\nfsm->id = (otgsc & OTGSC_ID) ? 1 : 0;\r\nif (otg_int_src) {\r\nif (otg_int_src & OTGSC_1MSIS) {\r\nhw_write_otgsc(ci, OTGSC_1MSIS, OTGSC_1MSIS);\r\nretval = ci_otg_tick_timer(ci);\r\nreturn IRQ_HANDLED;\r\n} else if (otg_int_src & OTGSC_DPIS) {\r\nhw_write_otgsc(ci, OTGSC_DPIS, OTGSC_DPIS);\r\nfsm->a_srp_det = 1;\r\nfsm->a_bus_drop = 0;\r\n} else if (otg_int_src & OTGSC_IDIS) {\r\nhw_write_otgsc(ci, OTGSC_IDIS, OTGSC_IDIS);\r\nif (fsm->id == 0) {\r\nfsm->a_bus_drop = 0;\r\nfsm->a_bus_req = 1;\r\nci->id_event = true;\r\n}\r\n} else if (otg_int_src & OTGSC_BSVIS) {\r\nhw_write_otgsc(ci, OTGSC_BSVIS, OTGSC_BSVIS);\r\nif (otgsc & OTGSC_BSV) {\r\nfsm->b_sess_vld = 1;\r\nci_otg_del_timer(ci, B_SSEND_SRP);\r\nci_otg_del_timer(ci, B_SRP_FAIL);\r\nfsm->b_ssend_srp = 0;\r\n} else {\r\nfsm->b_sess_vld = 0;\r\nif (fsm->id)\r\nci_otg_add_timer(ci, B_SSEND_SRP);\r\n}\r\n} else if (otg_int_src & OTGSC_AVVIS) {\r\nhw_write_otgsc(ci, OTGSC_AVVIS, OTGSC_AVVIS);\r\nif (otgsc & OTGSC_AVV) {\r\nfsm->a_vbus_vld = 1;\r\n} else {\r\nfsm->a_vbus_vld = 0;\r\nfsm->b_conn = 0;\r\n}\r\n}\r\nci_otg_queue_work(ci);\r\nreturn IRQ_HANDLED;\r\n}\r\nci_otg_fsm_event(ci);\r\nreturn retval;\r\n}\r\nvoid ci_hdrc_otg_fsm_start(struct ci_hdrc *ci)\r\n{\r\nci_otg_queue_work(ci);\r\n}\r\nint ci_hdrc_otg_fsm_init(struct ci_hdrc *ci)\r\n{\r\nint retval = 0;\r\nstruct usb_otg *otg;\r\notg = devm_kzalloc(ci->dev,\r\nsizeof(struct usb_otg), GFP_KERNEL);\r\nif (!otg) {\r\ndev_err(ci->dev,\r\n"Failed to allocate usb_otg structure for ci hdrc otg!\n");\r\nreturn -ENOMEM;\r\n}\r\notg->phy = ci->transceiver;\r\notg->gadget = &ci->gadget;\r\nci->fsm.otg = otg;\r\nci->transceiver->otg = ci->fsm.otg;\r\nci->fsm.power_up = 1;\r\nci->fsm.id = hw_read_otgsc(ci, OTGSC_ID) ? 1 : 0;\r\nci->transceiver->state = OTG_STATE_UNDEFINED;\r\nci->fsm.ops = &ci_otg_ops;\r\nmutex_init(&ci->fsm.lock);\r\nci->fsm_timer = devm_kzalloc(ci->dev,\r\nsizeof(struct ci_otg_fsm_timer_list), GFP_KERNEL);\r\nif (!ci->fsm_timer) {\r\ndev_err(ci->dev,\r\n"Failed to allocate timer structure for ci hdrc otg!\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&ci->fsm_timer->active_timers);\r\nretval = ci_otg_init_timers(ci);\r\nif (retval) {\r\ndev_err(ci->dev, "Couldn't init OTG timers\n");\r\nreturn retval;\r\n}\r\nretval = sysfs_create_group(&ci->dev->kobj, &inputs_attr_group);\r\nif (retval < 0) {\r\ndev_dbg(ci->dev,\r\n"Can't register sysfs attr group: %d\n", retval);\r\nreturn retval;\r\n}\r\nhw_write_otgsc(ci, OTGSC_AVVIE, OTGSC_AVVIE);\r\nif (ci->fsm.id) {\r\nci->fsm.b_ssend_srp =\r\nhw_read_otgsc(ci, OTGSC_BSV) ? 0 : 1;\r\nci->fsm.b_sess_vld =\r\nhw_read_otgsc(ci, OTGSC_BSV) ? 1 : 0;\r\nhw_write_otgsc(ci, OTGSC_BSVIE, OTGSC_BSVIE);\r\n}\r\nreturn 0;\r\n}\r\nvoid ci_hdrc_otg_fsm_remove(struct ci_hdrc *ci)\r\n{\r\nsysfs_remove_group(&ci->dev->kobj, &inputs_attr_group);\r\n}
