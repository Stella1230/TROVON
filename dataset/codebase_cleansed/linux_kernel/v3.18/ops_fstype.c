static void gfs2_tune_init(struct gfs2_tune *gt)\r\n{\r\nspin_lock_init(&gt->gt_spin);\r\ngt->gt_quota_warn_period = 10;\r\ngt->gt_quota_scale_num = 1;\r\ngt->gt_quota_scale_den = 1;\r\ngt->gt_new_files_jdata = 0;\r\ngt->gt_max_readahead = 1 << 18;\r\ngt->gt_complain_secs = 10;\r\n}\r\nstatic struct gfs2_sbd *init_sbd(struct super_block *sb)\r\n{\r\nstruct gfs2_sbd *sdp;\r\nstruct address_space *mapping;\r\nsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);\r\nif (!sdp)\r\nreturn NULL;\r\nsb->s_fs_info = sdp;\r\nsdp->sd_vfs = sb;\r\nsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);\r\nif (!sdp->sd_lkstats) {\r\nkfree(sdp);\r\nreturn NULL;\r\n}\r\nset_bit(SDF_NOJOURNALID, &sdp->sd_flags);\r\ngfs2_tune_init(&sdp->sd_tune);\r\ninit_waitqueue_head(&sdp->sd_glock_wait);\r\natomic_set(&sdp->sd_glock_disposal, 0);\r\ninit_completion(&sdp->sd_locking_init);\r\ninit_completion(&sdp->sd_wdack);\r\nspin_lock_init(&sdp->sd_statfs_spin);\r\nspin_lock_init(&sdp->sd_rindex_spin);\r\nsdp->sd_rindex_tree.rb_node = NULL;\r\nINIT_LIST_HEAD(&sdp->sd_jindex_list);\r\nspin_lock_init(&sdp->sd_jindex_spin);\r\nmutex_init(&sdp->sd_jindex_mutex);\r\ninit_completion(&sdp->sd_journal_ready);\r\nINIT_LIST_HEAD(&sdp->sd_quota_list);\r\nmutex_init(&sdp->sd_quota_mutex);\r\nmutex_init(&sdp->sd_quota_sync_mutex);\r\ninit_waitqueue_head(&sdp->sd_quota_wait);\r\nINIT_LIST_HEAD(&sdp->sd_trunc_list);\r\nspin_lock_init(&sdp->sd_trunc_lock);\r\nspin_lock_init(&sdp->sd_bitmap_lock);\r\nmapping = &sdp->sd_aspace;\r\naddress_space_init_once(mapping);\r\nmapping->a_ops = &gfs2_rgrp_aops;\r\nmapping->host = sb->s_bdev->bd_inode;\r\nmapping->flags = 0;\r\nmapping_set_gfp_mask(mapping, GFP_NOFS);\r\nmapping->private_data = NULL;\r\nmapping->backing_dev_info = sb->s_bdi;\r\nmapping->writeback_index = 0;\r\nspin_lock_init(&sdp->sd_log_lock);\r\natomic_set(&sdp->sd_log_pinned, 0);\r\nINIT_LIST_HEAD(&sdp->sd_log_le_revoke);\r\nINIT_LIST_HEAD(&sdp->sd_log_le_ordered);\r\nspin_lock_init(&sdp->sd_ordered_lock);\r\ninit_waitqueue_head(&sdp->sd_log_waitq);\r\ninit_waitqueue_head(&sdp->sd_logd_waitq);\r\nspin_lock_init(&sdp->sd_ail_lock);\r\nINIT_LIST_HEAD(&sdp->sd_ail1_list);\r\nINIT_LIST_HEAD(&sdp->sd_ail2_list);\r\ninit_rwsem(&sdp->sd_log_flush_lock);\r\natomic_set(&sdp->sd_log_in_flight, 0);\r\ninit_waitqueue_head(&sdp->sd_log_flush_wait);\r\ninit_waitqueue_head(&sdp->sd_log_frozen_wait);\r\natomic_set(&sdp->sd_log_freeze, 0);\r\natomic_set(&sdp->sd_frozen_root, 0);\r\ninit_waitqueue_head(&sdp->sd_frozen_root_wait);\r\nreturn sdp;\r\n}\r\nstatic int gfs2_check_sb(struct gfs2_sbd *sdp, int silent)\r\n{\r\nstruct gfs2_sb_host *sb = &sdp->sd_sb;\r\nif (sb->sb_magic != GFS2_MAGIC ||\r\nsb->sb_type != GFS2_METATYPE_SB) {\r\nif (!silent)\r\npr_warn("not a GFS2 filesystem\n");\r\nreturn -EINVAL;\r\n}\r\nif (sb->sb_fs_format == GFS2_FORMAT_FS &&\r\nsb->sb_multihost_format == GFS2_FORMAT_MULTI)\r\nreturn 0;\r\nfs_warn(sdp, "Unknown on-disk format, unable to mount\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void end_bio_io_page(struct bio *bio, int error)\r\n{\r\nstruct page *page = bio->bi_private;\r\nif (!error)\r\nSetPageUptodate(page);\r\nelse\r\npr_warn("error %d reading superblock\n", error);\r\nunlock_page(page);\r\n}\r\nstatic void gfs2_sb_in(struct gfs2_sbd *sdp, const void *buf)\r\n{\r\nstruct gfs2_sb_host *sb = &sdp->sd_sb;\r\nstruct super_block *s = sdp->sd_vfs;\r\nconst struct gfs2_sb *str = buf;\r\nsb->sb_magic = be32_to_cpu(str->sb_header.mh_magic);\r\nsb->sb_type = be32_to_cpu(str->sb_header.mh_type);\r\nsb->sb_format = be32_to_cpu(str->sb_header.mh_format);\r\nsb->sb_fs_format = be32_to_cpu(str->sb_fs_format);\r\nsb->sb_multihost_format = be32_to_cpu(str->sb_multihost_format);\r\nsb->sb_bsize = be32_to_cpu(str->sb_bsize);\r\nsb->sb_bsize_shift = be32_to_cpu(str->sb_bsize_shift);\r\nsb->sb_master_dir.no_addr = be64_to_cpu(str->sb_master_dir.no_addr);\r\nsb->sb_master_dir.no_formal_ino = be64_to_cpu(str->sb_master_dir.no_formal_ino);\r\nsb->sb_root_dir.no_addr = be64_to_cpu(str->sb_root_dir.no_addr);\r\nsb->sb_root_dir.no_formal_ino = be64_to_cpu(str->sb_root_dir.no_formal_ino);\r\nmemcpy(sb->sb_lockproto, str->sb_lockproto, GFS2_LOCKNAME_LEN);\r\nmemcpy(sb->sb_locktable, str->sb_locktable, GFS2_LOCKNAME_LEN);\r\nmemcpy(s->s_uuid, str->sb_uuid, 16);\r\n}\r\nstatic int gfs2_read_super(struct gfs2_sbd *sdp, sector_t sector, int silent)\r\n{\r\nstruct super_block *sb = sdp->sd_vfs;\r\nstruct gfs2_sb *p;\r\nstruct page *page;\r\nstruct bio *bio;\r\npage = alloc_page(GFP_NOFS);\r\nif (unlikely(!page))\r\nreturn -ENOMEM;\r\nClearPageUptodate(page);\r\nClearPageDirty(page);\r\nlock_page(page);\r\nbio = bio_alloc(GFP_NOFS, 1);\r\nbio->bi_iter.bi_sector = sector * (sb->s_blocksize >> 9);\r\nbio->bi_bdev = sb->s_bdev;\r\nbio_add_page(bio, page, PAGE_SIZE, 0);\r\nbio->bi_end_io = end_bio_io_page;\r\nbio->bi_private = page;\r\nsubmit_bio(READ_SYNC | REQ_META, bio);\r\nwait_on_page_locked(page);\r\nbio_put(bio);\r\nif (!PageUptodate(page)) {\r\n__free_page(page);\r\nreturn -EIO;\r\n}\r\np = kmap(page);\r\ngfs2_sb_in(sdp, p);\r\nkunmap(page);\r\n__free_page(page);\r\nreturn gfs2_check_sb(sdp, silent);\r\n}\r\nstatic int gfs2_read_sb(struct gfs2_sbd *sdp, int silent)\r\n{\r\nu32 hash_blocks, ind_blocks, leaf_blocks;\r\nu32 tmp_blocks;\r\nunsigned int x;\r\nint error;\r\nerror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\r\nif (error) {\r\nif (!silent)\r\nfs_err(sdp, "can't read superblock\n");\r\nreturn error;\r\n}\r\nsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\r\nGFS2_BASIC_BLOCK_SHIFT;\r\nsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\r\nsdp->sd_diptrs = (sdp->sd_sb.sb_bsize -\r\nsizeof(struct gfs2_dinode)) / sizeof(u64);\r\nsdp->sd_inptrs = (sdp->sd_sb.sb_bsize -\r\nsizeof(struct gfs2_meta_header)) / sizeof(u64);\r\nsdp->sd_jbsize = sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header);\r\nsdp->sd_hash_bsize = sdp->sd_sb.sb_bsize / 2;\r\nsdp->sd_hash_bsize_shift = sdp->sd_sb.sb_bsize_shift - 1;\r\nsdp->sd_hash_ptrs = sdp->sd_hash_bsize / sizeof(u64);\r\nsdp->sd_qc_per_block = (sdp->sd_sb.sb_bsize -\r\nsizeof(struct gfs2_meta_header)) /\r\nsizeof(struct gfs2_quota_change);\r\nsdp->sd_blocks_per_bitmap = (sdp->sd_sb.sb_bsize -\r\nsizeof(struct gfs2_meta_header))\r\n* GFS2_NBBY;\r\nhash_blocks = DIV_ROUND_UP(sizeof(u64) * (1 << GFS2_DIR_MAX_DEPTH),\r\nsdp->sd_jbsize);\r\nind_blocks = 0;\r\nfor (tmp_blocks = hash_blocks; tmp_blocks > sdp->sd_diptrs;) {\r\ntmp_blocks = DIV_ROUND_UP(tmp_blocks, sdp->sd_inptrs);\r\nind_blocks += tmp_blocks;\r\n}\r\nleaf_blocks = 2 + GFS2_DIR_MAX_DEPTH;\r\nsdp->sd_max_dirres = hash_blocks + ind_blocks + leaf_blocks;\r\nsdp->sd_heightsize[0] = sdp->sd_sb.sb_bsize -\r\nsizeof(struct gfs2_dinode);\r\nsdp->sd_heightsize[1] = sdp->sd_sb.sb_bsize * sdp->sd_diptrs;\r\nfor (x = 2;; x++) {\r\nu64 space, d;\r\nu32 m;\r\nspace = sdp->sd_heightsize[x - 1] * sdp->sd_inptrs;\r\nd = space;\r\nm = do_div(d, sdp->sd_inptrs);\r\nif (d != sdp->sd_heightsize[x - 1] || m)\r\nbreak;\r\nsdp->sd_heightsize[x] = space;\r\n}\r\nsdp->sd_max_height = x;\r\nsdp->sd_heightsize[x] = ~0;\r\ngfs2_assert(sdp, sdp->sd_max_height <= GFS2_MAX_META_HEIGHT);\r\nsdp->sd_jheightsize[0] = sdp->sd_sb.sb_bsize -\r\nsizeof(struct gfs2_dinode);\r\nsdp->sd_jheightsize[1] = sdp->sd_jbsize * sdp->sd_diptrs;\r\nfor (x = 2;; x++) {\r\nu64 space, d;\r\nu32 m;\r\nspace = sdp->sd_jheightsize[x - 1] * sdp->sd_inptrs;\r\nd = space;\r\nm = do_div(d, sdp->sd_inptrs);\r\nif (d != sdp->sd_jheightsize[x - 1] || m)\r\nbreak;\r\nsdp->sd_jheightsize[x] = space;\r\n}\r\nsdp->sd_max_jheight = x;\r\nsdp->sd_jheightsize[x] = ~0;\r\ngfs2_assert(sdp, sdp->sd_max_jheight <= GFS2_MAX_META_HEIGHT);\r\nreturn 0;\r\n}\r\nstatic int init_names(struct gfs2_sbd *sdp, int silent)\r\n{\r\nchar *proto, *table;\r\nint error = 0;\r\nproto = sdp->sd_args.ar_lockproto;\r\ntable = sdp->sd_args.ar_locktable;\r\nif (!proto[0] || !table[0]) {\r\nerror = gfs2_read_super(sdp, GFS2_SB_ADDR >> sdp->sd_fsb2bb_shift, silent);\r\nif (error)\r\nreturn error;\r\nif (!proto[0])\r\nproto = sdp->sd_sb.sb_lockproto;\r\nif (!table[0])\r\ntable = sdp->sd_sb.sb_locktable;\r\n}\r\nif (!table[0])\r\ntable = sdp->sd_vfs->s_id;\r\nstrlcpy(sdp->sd_proto_name, proto, GFS2_FSNAME_LEN);\r\nstrlcpy(sdp->sd_table_name, table, GFS2_FSNAME_LEN);\r\ntable = sdp->sd_table_name;\r\nwhile ((table = strchr(table, '/')))\r\n*table = '_';\r\nreturn error;\r\n}\r\nstatic int init_locking(struct gfs2_sbd *sdp, struct gfs2_holder *mount_gh,\r\nint undo)\r\n{\r\nint error = 0;\r\nif (undo)\r\ngoto fail_trans;\r\nerror = gfs2_glock_nq_num(sdp,\r\nGFS2_MOUNT_LOCK, &gfs2_nondisk_glops,\r\nLM_ST_EXCLUSIVE, LM_FLAG_NOEXP | GL_NOCACHE,\r\nmount_gh);\r\nif (error) {\r\nfs_err(sdp, "can't acquire mount glock: %d\n", error);\r\ngoto fail;\r\n}\r\nerror = gfs2_glock_nq_num(sdp,\r\nGFS2_LIVE_LOCK, &gfs2_nondisk_glops,\r\nLM_ST_SHARED,\r\nLM_FLAG_NOEXP | GL_EXACT,\r\n&sdp->sd_live_gh);\r\nif (error) {\r\nfs_err(sdp, "can't acquire live glock: %d\n", error);\r\ngoto fail_mount;\r\n}\r\nerror = gfs2_glock_get(sdp, GFS2_RENAME_LOCK, &gfs2_nondisk_glops,\r\nCREATE, &sdp->sd_rename_gl);\r\nif (error) {\r\nfs_err(sdp, "can't create rename glock: %d\n", error);\r\ngoto fail_live;\r\n}\r\nerror = gfs2_glock_get(sdp, GFS2_FREEZE_LOCK, &gfs2_freeze_glops,\r\nCREATE, &sdp->sd_freeze_gl);\r\nif (error) {\r\nfs_err(sdp, "can't create transaction glock: %d\n", error);\r\ngoto fail_rename;\r\n}\r\nreturn 0;\r\nfail_trans:\r\ngfs2_glock_put(sdp->sd_freeze_gl);\r\nfail_rename:\r\ngfs2_glock_put(sdp->sd_rename_gl);\r\nfail_live:\r\ngfs2_glock_dq_uninit(&sdp->sd_live_gh);\r\nfail_mount:\r\ngfs2_glock_dq_uninit(mount_gh);\r\nfail:\r\nreturn error;\r\n}\r\nstatic int gfs2_lookup_root(struct super_block *sb, struct dentry **dptr,\r\nu64 no_addr, const char *name)\r\n{\r\nstruct gfs2_sbd *sdp = sb->s_fs_info;\r\nstruct dentry *dentry;\r\nstruct inode *inode;\r\ninode = gfs2_inode_lookup(sb, DT_DIR, no_addr, 0, 0);\r\nif (IS_ERR(inode)) {\r\nfs_err(sdp, "can't read in %s inode: %ld\n", name, PTR_ERR(inode));\r\nreturn PTR_ERR(inode);\r\n}\r\ndentry = d_make_root(inode);\r\nif (!dentry) {\r\nfs_err(sdp, "can't alloc %s dentry\n", name);\r\nreturn -ENOMEM;\r\n}\r\n*dptr = dentry;\r\nreturn 0;\r\n}\r\nstatic int init_sb(struct gfs2_sbd *sdp, int silent)\r\n{\r\nstruct super_block *sb = sdp->sd_vfs;\r\nstruct gfs2_holder sb_gh;\r\nu64 no_addr;\r\nint ret;\r\nret = gfs2_glock_nq_num(sdp, GFS2_SB_LOCK, &gfs2_meta_glops,\r\nLM_ST_SHARED, 0, &sb_gh);\r\nif (ret) {\r\nfs_err(sdp, "can't acquire superblock glock: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = gfs2_read_sb(sdp, silent);\r\nif (ret) {\r\nfs_err(sdp, "can't read superblock: %d\n", ret);\r\ngoto out;\r\n}\r\nif (sdp->sd_sb.sb_bsize < bdev_logical_block_size(sb->s_bdev)) {\r\nret = -EINVAL;\r\nfs_err(sdp, "FS block size (%u) is too small for device "\r\n"block size (%u)\n",\r\nsdp->sd_sb.sb_bsize, bdev_logical_block_size(sb->s_bdev));\r\ngoto out;\r\n}\r\nif (sdp->sd_sb.sb_bsize > PAGE_SIZE) {\r\nret = -EINVAL;\r\nfs_err(sdp, "FS block size (%u) is too big for machine "\r\n"page size (%u)\n",\r\nsdp->sd_sb.sb_bsize, (unsigned int)PAGE_SIZE);\r\ngoto out;\r\n}\r\nsb_set_blocksize(sb, sdp->sd_sb.sb_bsize);\r\nno_addr = sdp->sd_sb.sb_root_dir.no_addr;\r\nret = gfs2_lookup_root(sb, &sdp->sd_root_dir, no_addr, "root");\r\nif (ret)\r\ngoto out;\r\nno_addr = sdp->sd_sb.sb_master_dir.no_addr;\r\nret = gfs2_lookup_root(sb, &sdp->sd_master_dir, no_addr, "master");\r\nif (ret) {\r\ndput(sdp->sd_root_dir);\r\ngoto out;\r\n}\r\nsb->s_root = dget(sdp->sd_args.ar_meta ? sdp->sd_master_dir : sdp->sd_root_dir);\r\nout:\r\ngfs2_glock_dq_uninit(&sb_gh);\r\nreturn ret;\r\n}\r\nstatic void gfs2_others_may_mount(struct gfs2_sbd *sdp)\r\n{\r\nchar *message = "FIRSTMOUNT=Done";\r\nchar *envp[] = { message, NULL };\r\nfs_info(sdp, "first mount done, others may mount\n");\r\nif (sdp->sd_lockstruct.ls_ops->lm_first_done)\r\nsdp->sd_lockstruct.ls_ops->lm_first_done(sdp);\r\nkobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\r\n}\r\nstatic int gfs2_jindex_hold(struct gfs2_sbd *sdp, struct gfs2_holder *ji_gh)\r\n{\r\nstruct gfs2_inode *dip = GFS2_I(sdp->sd_jindex);\r\nstruct qstr name;\r\nchar buf[20];\r\nstruct gfs2_jdesc *jd;\r\nint error;\r\nname.name = buf;\r\nmutex_lock(&sdp->sd_jindex_mutex);\r\nfor (;;) {\r\nerror = gfs2_glock_nq_init(dip->i_gl, LM_ST_SHARED, 0, ji_gh);\r\nif (error)\r\nbreak;\r\nname.len = sprintf(buf, "journal%u", sdp->sd_journals);\r\nname.hash = gfs2_disk_hash(name.name, name.len);\r\nerror = gfs2_dir_check(sdp->sd_jindex, &name, NULL);\r\nif (error == -ENOENT) {\r\nerror = 0;\r\nbreak;\r\n}\r\ngfs2_glock_dq_uninit(ji_gh);\r\nif (error)\r\nbreak;\r\nerror = -ENOMEM;\r\njd = kzalloc(sizeof(struct gfs2_jdesc), GFP_KERNEL);\r\nif (!jd)\r\nbreak;\r\nINIT_LIST_HEAD(&jd->extent_list);\r\nINIT_LIST_HEAD(&jd->jd_revoke_list);\r\nINIT_WORK(&jd->jd_work, gfs2_recover_func);\r\njd->jd_inode = gfs2_lookupi(sdp->sd_jindex, &name, 1);\r\nif (!jd->jd_inode || IS_ERR(jd->jd_inode)) {\r\nif (!jd->jd_inode)\r\nerror = -ENOENT;\r\nelse\r\nerror = PTR_ERR(jd->jd_inode);\r\nkfree(jd);\r\nbreak;\r\n}\r\nspin_lock(&sdp->sd_jindex_spin);\r\njd->jd_jid = sdp->sd_journals++;\r\nlist_add_tail(&jd->jd_list, &sdp->sd_jindex_list);\r\nspin_unlock(&sdp->sd_jindex_spin);\r\n}\r\nmutex_unlock(&sdp->sd_jindex_mutex);\r\nreturn error;\r\n}\r\nstatic int check_journal_clean(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)\r\n{\r\nint error;\r\nstruct gfs2_holder j_gh;\r\nstruct gfs2_log_header_host head;\r\nstruct gfs2_inode *ip;\r\nip = GFS2_I(jd->jd_inode);\r\nerror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_NOEXP |\r\nGL_EXACT | GL_NOCACHE, &j_gh);\r\nif (error) {\r\nfs_err(sdp, "Error locking journal for spectator mount.\n");\r\nreturn -EPERM;\r\n}\r\nerror = gfs2_jdesc_check(jd);\r\nif (error) {\r\nfs_err(sdp, "Error checking journal for spectator mount.\n");\r\ngoto out_unlock;\r\n}\r\nerror = gfs2_find_jhead(jd, &head);\r\nif (error) {\r\nfs_err(sdp, "Error parsing journal for spectator mount.\n");\r\ngoto out_unlock;\r\n}\r\nif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\r\nerror = -EPERM;\r\nfs_err(sdp, "jid=%u: Journal is dirty, so the first mounter "\r\n"must not be a spectator.\n", jd->jd_jid);\r\n}\r\nout_unlock:\r\ngfs2_glock_dq_uninit(&j_gh);\r\nreturn error;\r\n}\r\nstatic int init_journal(struct gfs2_sbd *sdp, int undo)\r\n{\r\nstruct inode *master = sdp->sd_master_dir->d_inode;\r\nstruct gfs2_holder ji_gh;\r\nstruct gfs2_inode *ip;\r\nint jindex = 1;\r\nint error = 0;\r\nif (undo) {\r\njindex = 0;\r\ngoto fail_jinode_gh;\r\n}\r\nsdp->sd_jindex = gfs2_lookup_simple(master, "jindex");\r\nif (IS_ERR(sdp->sd_jindex)) {\r\nfs_err(sdp, "can't lookup journal index: %d\n", error);\r\nreturn PTR_ERR(sdp->sd_jindex);\r\n}\r\nerror = gfs2_jindex_hold(sdp, &ji_gh);\r\nif (error) {\r\nfs_err(sdp, "can't read journal index: %d\n", error);\r\ngoto fail;\r\n}\r\nerror = -EUSERS;\r\nif (!gfs2_jindex_size(sdp)) {\r\nfs_err(sdp, "no journals!\n");\r\ngoto fail_jindex;\r\n}\r\nif (sdp->sd_args.ar_spectator) {\r\nsdp->sd_jdesc = gfs2_jdesc_find(sdp, 0);\r\natomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\r\natomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\r\natomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\r\n} else {\r\nif (sdp->sd_lockstruct.ls_jid >= gfs2_jindex_size(sdp)) {\r\nfs_err(sdp, "can't mount journal #%u\n",\r\nsdp->sd_lockstruct.ls_jid);\r\nfs_err(sdp, "there are only %u journals (0 - %u)\n",\r\ngfs2_jindex_size(sdp),\r\ngfs2_jindex_size(sdp) - 1);\r\ngoto fail_jindex;\r\n}\r\nsdp->sd_jdesc = gfs2_jdesc_find(sdp, sdp->sd_lockstruct.ls_jid);\r\nerror = gfs2_glock_nq_num(sdp, sdp->sd_lockstruct.ls_jid,\r\n&gfs2_journal_glops,\r\nLM_ST_EXCLUSIVE, LM_FLAG_NOEXP,\r\n&sdp->sd_journal_gh);\r\nif (error) {\r\nfs_err(sdp, "can't acquire journal glock: %d\n", error);\r\ngoto fail_jindex;\r\n}\r\nip = GFS2_I(sdp->sd_jdesc->jd_inode);\r\nerror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\r\nLM_FLAG_NOEXP | GL_EXACT | GL_NOCACHE,\r\n&sdp->sd_jinode_gh);\r\nif (error) {\r\nfs_err(sdp, "can't acquire journal inode glock: %d\n",\r\nerror);\r\ngoto fail_journal_gh;\r\n}\r\nerror = gfs2_jdesc_check(sdp->sd_jdesc);\r\nif (error) {\r\nfs_err(sdp, "my journal (%u) is bad: %d\n",\r\nsdp->sd_jdesc->jd_jid, error);\r\ngoto fail_jinode_gh;\r\n}\r\natomic_set(&sdp->sd_log_blks_free, sdp->sd_jdesc->jd_blocks);\r\natomic_set(&sdp->sd_log_thresh1, 2*sdp->sd_jdesc->jd_blocks/5);\r\natomic_set(&sdp->sd_log_thresh2, 4*sdp->sd_jdesc->jd_blocks/5);\r\ngfs2_map_journal_extents(sdp, sdp->sd_jdesc);\r\n}\r\ntrace_gfs2_log_blocks(sdp, atomic_read(&sdp->sd_log_blks_free));\r\nif (sdp->sd_lockstruct.ls_first) {\r\nunsigned int x;\r\nfor (x = 0; x < sdp->sd_journals; x++) {\r\nstruct gfs2_jdesc *jd = gfs2_jdesc_find(sdp, x);\r\nif (sdp->sd_args.ar_spectator) {\r\nerror = check_journal_clean(sdp, jd);\r\nif (error)\r\ngoto fail_jinode_gh;\r\ncontinue;\r\n}\r\nerror = gfs2_recover_journal(jd, true);\r\nif (error) {\r\nfs_err(sdp, "error recovering journal %u: %d\n",\r\nx, error);\r\ngoto fail_jinode_gh;\r\n}\r\n}\r\ngfs2_others_may_mount(sdp);\r\n} else if (!sdp->sd_args.ar_spectator) {\r\nerror = gfs2_recover_journal(sdp->sd_jdesc, true);\r\nif (error) {\r\nfs_err(sdp, "error recovering my journal: %d\n", error);\r\ngoto fail_jinode_gh;\r\n}\r\n}\r\nset_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags);\r\ngfs2_glock_dq_uninit(&ji_gh);\r\njindex = 0;\r\nif (!sdp->sd_args.ar_spectator) {\r\nerror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED, 0,\r\n&sdp->sd_thaw_gh);\r\nif (error) {\r\nfs_err(sdp, "can't acquire freeze glock: %d\n", error);\r\ngoto fail_jinode_gh;\r\n}\r\n}\r\ngfs2_glock_dq_uninit(&sdp->sd_thaw_gh);\r\nreturn 0;\r\nfail_jinode_gh:\r\nif (!sdp->sd_args.ar_spectator)\r\ngfs2_glock_dq_uninit(&sdp->sd_jinode_gh);\r\nfail_journal_gh:\r\nif (!sdp->sd_args.ar_spectator)\r\ngfs2_glock_dq_uninit(&sdp->sd_journal_gh);\r\nfail_jindex:\r\ngfs2_jindex_free(sdp);\r\nif (jindex)\r\ngfs2_glock_dq_uninit(&ji_gh);\r\nfail:\r\niput(sdp->sd_jindex);\r\nreturn error;\r\n}\r\nstatic int init_inodes(struct gfs2_sbd *sdp, int undo)\r\n{\r\nint error = 0;\r\nstruct inode *master = sdp->sd_master_dir->d_inode;\r\nif (undo)\r\ngoto fail_qinode;\r\nerror = init_journal(sdp, undo);\r\ncomplete_all(&sdp->sd_journal_ready);\r\nif (error)\r\ngoto fail;\r\nsdp->sd_statfs_inode = gfs2_lookup_simple(master, "statfs");\r\nif (IS_ERR(sdp->sd_statfs_inode)) {\r\nerror = PTR_ERR(sdp->sd_statfs_inode);\r\nfs_err(sdp, "can't read in statfs inode: %d\n", error);\r\ngoto fail_journal;\r\n}\r\nsdp->sd_rindex = gfs2_lookup_simple(master, "rindex");\r\nif (IS_ERR(sdp->sd_rindex)) {\r\nerror = PTR_ERR(sdp->sd_rindex);\r\nfs_err(sdp, "can't get resource index inode: %d\n", error);\r\ngoto fail_statfs;\r\n}\r\nsdp->sd_rindex_uptodate = 0;\r\nsdp->sd_quota_inode = gfs2_lookup_simple(master, "quota");\r\nif (IS_ERR(sdp->sd_quota_inode)) {\r\nerror = PTR_ERR(sdp->sd_quota_inode);\r\nfs_err(sdp, "can't get quota file inode: %d\n", error);\r\ngoto fail_rindex;\r\n}\r\nlockdep_set_class(&sdp->sd_quota_inode->i_mutex,\r\n&gfs2_quota_imutex_key);\r\nerror = gfs2_rindex_update(sdp);\r\nif (error)\r\ngoto fail_qinode;\r\nreturn 0;\r\nfail_qinode:\r\niput(sdp->sd_quota_inode);\r\nfail_rindex:\r\ngfs2_clear_rgrpd(sdp);\r\niput(sdp->sd_rindex);\r\nfail_statfs:\r\niput(sdp->sd_statfs_inode);\r\nfail_journal:\r\ninit_journal(sdp, UNDO);\r\nfail:\r\nreturn error;\r\n}\r\nstatic int init_per_node(struct gfs2_sbd *sdp, int undo)\r\n{\r\nstruct inode *pn = NULL;\r\nchar buf[30];\r\nint error = 0;\r\nstruct gfs2_inode *ip;\r\nstruct inode *master = sdp->sd_master_dir->d_inode;\r\nif (sdp->sd_args.ar_spectator)\r\nreturn 0;\r\nif (undo)\r\ngoto fail_qc_gh;\r\npn = gfs2_lookup_simple(master, "per_node");\r\nif (IS_ERR(pn)) {\r\nerror = PTR_ERR(pn);\r\nfs_err(sdp, "can't find per_node directory: %d\n", error);\r\nreturn error;\r\n}\r\nsprintf(buf, "statfs_change%u", sdp->sd_jdesc->jd_jid);\r\nsdp->sd_sc_inode = gfs2_lookup_simple(pn, buf);\r\nif (IS_ERR(sdp->sd_sc_inode)) {\r\nerror = PTR_ERR(sdp->sd_sc_inode);\r\nfs_err(sdp, "can't find local \"sc\" file: %d\n", error);\r\ngoto fail;\r\n}\r\nsprintf(buf, "quota_change%u", sdp->sd_jdesc->jd_jid);\r\nsdp->sd_qc_inode = gfs2_lookup_simple(pn, buf);\r\nif (IS_ERR(sdp->sd_qc_inode)) {\r\nerror = PTR_ERR(sdp->sd_qc_inode);\r\nfs_err(sdp, "can't find local \"qc\" file: %d\n", error);\r\ngoto fail_ut_i;\r\n}\r\niput(pn);\r\npn = NULL;\r\nip = GFS2_I(sdp->sd_sc_inode);\r\nerror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\r\n&sdp->sd_sc_gh);\r\nif (error) {\r\nfs_err(sdp, "can't lock local \"sc\" file: %d\n", error);\r\ngoto fail_qc_i;\r\n}\r\nip = GFS2_I(sdp->sd_qc_inode);\r\nerror = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0,\r\n&sdp->sd_qc_gh);\r\nif (error) {\r\nfs_err(sdp, "can't lock local \"qc\" file: %d\n", error);\r\ngoto fail_ut_gh;\r\n}\r\nreturn 0;\r\nfail_qc_gh:\r\ngfs2_glock_dq_uninit(&sdp->sd_qc_gh);\r\nfail_ut_gh:\r\ngfs2_glock_dq_uninit(&sdp->sd_sc_gh);\r\nfail_qc_i:\r\niput(sdp->sd_qc_inode);\r\nfail_ut_i:\r\niput(sdp->sd_sc_inode);\r\nfail:\r\nif (pn)\r\niput(pn);\r\nreturn error;\r\n}\r\nstatic int gfs2_lm_mount(struct gfs2_sbd *sdp, int silent)\r\n{\r\nconst struct lm_lockops *lm;\r\nstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\r\nstruct gfs2_args *args = &sdp->sd_args;\r\nconst char *proto = sdp->sd_proto_name;\r\nconst char *table = sdp->sd_table_name;\r\nchar *o, *options;\r\nint ret;\r\nif (!strcmp("lock_nolock", proto)) {\r\nlm = &nolock_ops;\r\nsdp->sd_args.ar_localflocks = 1;\r\n#ifdef CONFIG_GFS2_FS_LOCKING_DLM\r\n} else if (!strcmp("lock_dlm", proto)) {\r\nlm = &gfs2_dlm_ops;\r\n#endif\r\n} else {\r\npr_info("can't find protocol %s\n", proto);\r\nreturn -ENOENT;\r\n}\r\nfs_info(sdp, "Trying to join cluster \"%s\", \"%s\"\n", proto, table);\r\nls->ls_ops = lm;\r\nls->ls_first = 1;\r\nfor (options = args->ar_hostdata; (o = strsep(&options, ":")); ) {\r\nsubstring_t tmp[MAX_OPT_ARGS];\r\nint token, option;\r\nif (!o || !*o)\r\ncontinue;\r\ntoken = match_token(o, *lm->lm_tokens, tmp);\r\nswitch (token) {\r\ncase Opt_jid:\r\nret = match_int(&tmp[0], &option);\r\nif (ret || option < 0)\r\ngoto hostdata_error;\r\nif (test_and_clear_bit(SDF_NOJOURNALID, &sdp->sd_flags))\r\nls->ls_jid = option;\r\nbreak;\r\ncase Opt_id:\r\ncase Opt_nodir:\r\nbreak;\r\ncase Opt_first:\r\nret = match_int(&tmp[0], &option);\r\nif (ret || (option != 0 && option != 1))\r\ngoto hostdata_error;\r\nls->ls_first = option;\r\nbreak;\r\ncase Opt_err:\r\ndefault:\r\nhostdata_error:\r\nfs_info(sdp, "unknown hostdata (%s)\n", o);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (lm->lm_mount == NULL) {\r\nfs_info(sdp, "Now mounting FS...\n");\r\ncomplete_all(&sdp->sd_locking_init);\r\nreturn 0;\r\n}\r\nret = lm->lm_mount(sdp, table);\r\nif (ret == 0)\r\nfs_info(sdp, "Joined cluster. Now mounting FS...\n");\r\ncomplete_all(&sdp->sd_locking_init);\r\nreturn ret;\r\n}\r\nvoid gfs2_lm_unmount(struct gfs2_sbd *sdp)\r\n{\r\nconst struct lm_lockops *lm = sdp->sd_lockstruct.ls_ops;\r\nif (likely(!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) &&\r\nlm->lm_unmount)\r\nlm->lm_unmount(sdp);\r\n}\r\nstatic int wait_on_journal(struct gfs2_sbd *sdp)\r\n{\r\nif (sdp->sd_lockstruct.ls_ops->lm_mount == NULL)\r\nreturn 0;\r\nreturn wait_on_bit(&sdp->sd_flags, SDF_NOJOURNALID, TASK_INTERRUPTIBLE)\r\n? -EINTR : 0;\r\n}\r\nvoid gfs2_online_uevent(struct gfs2_sbd *sdp)\r\n{\r\nstruct super_block *sb = sdp->sd_vfs;\r\nchar ro[20];\r\nchar spectator[20];\r\nchar *envp[] = { ro, spectator, NULL };\r\nsprintf(ro, "RDONLY=%d", (sb->s_flags & MS_RDONLY) ? 1 : 0);\r\nsprintf(spectator, "SPECTATOR=%d", sdp->sd_args.ar_spectator ? 1 : 0);\r\nkobject_uevent_env(&sdp->sd_kobj, KOBJ_ONLINE, envp);\r\n}\r\nstatic int fill_super(struct super_block *sb, struct gfs2_args *args, int silent)\r\n{\r\nstruct gfs2_sbd *sdp;\r\nstruct gfs2_holder mount_gh;\r\nint error;\r\nsdp = init_sbd(sb);\r\nif (!sdp) {\r\npr_warn("can't alloc struct gfs2_sbd\n");\r\nreturn -ENOMEM;\r\n}\r\nsdp->sd_args = *args;\r\nif (sdp->sd_args.ar_spectator) {\r\nsb->s_flags |= MS_RDONLY;\r\nset_bit(SDF_RORECOVERY, &sdp->sd_flags);\r\n}\r\nif (sdp->sd_args.ar_posix_acl)\r\nsb->s_flags |= MS_POSIXACL;\r\nif (sdp->sd_args.ar_nobarrier)\r\nset_bit(SDF_NOBARRIERS, &sdp->sd_flags);\r\nsb->s_flags |= MS_NOSEC;\r\nsb->s_magic = GFS2_MAGIC;\r\nsb->s_op = &gfs2_super_ops;\r\nsb->s_d_op = &gfs2_dops;\r\nsb->s_export_op = &gfs2_export_ops;\r\nsb->s_xattr = gfs2_xattr_handlers;\r\nsb->s_qcop = &gfs2_quotactl_ops;\r\nsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\r\nsb->s_time_gran = 1;\r\nsb->s_maxbytes = MAX_LFS_FILESIZE;\r\nsdp->sd_sb.sb_bsize = sb_min_blocksize(sb, GFS2_BASIC_BLOCK);\r\nsdp->sd_sb.sb_bsize_shift = sb->s_blocksize_bits;\r\nsdp->sd_fsb2bb_shift = sdp->sd_sb.sb_bsize_shift -\r\nGFS2_BASIC_BLOCK_SHIFT;\r\nsdp->sd_fsb2bb = 1 << sdp->sd_fsb2bb_shift;\r\nsdp->sd_tune.gt_logd_secs = sdp->sd_args.ar_commit;\r\nsdp->sd_tune.gt_quota_quantum = sdp->sd_args.ar_quota_quantum;\r\nif (sdp->sd_args.ar_statfs_quantum) {\r\nsdp->sd_tune.gt_statfs_slow = 0;\r\nsdp->sd_tune.gt_statfs_quantum = sdp->sd_args.ar_statfs_quantum;\r\n} else {\r\nsdp->sd_tune.gt_statfs_slow = 1;\r\nsdp->sd_tune.gt_statfs_quantum = 30;\r\n}\r\nerror = init_names(sdp, silent);\r\nif (error) {\r\nfree_percpu(sdp->sd_lkstats);\r\nkfree(sdp);\r\nsb->s_fs_info = NULL;\r\nreturn error;\r\n}\r\nsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, "%s", sdp->sd_table_name);\r\nerror = gfs2_sys_fs_add(sdp);\r\nif (error)\r\nreturn error;\r\ngfs2_create_debugfs_file(sdp);\r\nerror = gfs2_lm_mount(sdp, silent);\r\nif (error)\r\ngoto fail_debug;\r\nerror = init_locking(sdp, &mount_gh, DO);\r\nif (error)\r\ngoto fail_lm;\r\nerror = init_sb(sdp, silent);\r\nif (error)\r\ngoto fail_locking;\r\nerror = wait_on_journal(sdp);\r\nif (error)\r\ngoto fail_sb;\r\nif (sdp->sd_lockstruct.ls_jid < 0) {\r\nerror = sdp->sd_lockstruct.ls_jid;\r\nsdp->sd_lockstruct.ls_jid = 0;\r\ngoto fail_sb;\r\n}\r\nif (sdp->sd_args.ar_spectator)\r\nsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, "%s.s",\r\nsdp->sd_table_name);\r\nelse\r\nsnprintf(sdp->sd_fsname, GFS2_FSNAME_LEN, "%s.%u",\r\nsdp->sd_table_name, sdp->sd_lockstruct.ls_jid);\r\nerror = init_inodes(sdp, DO);\r\nif (error)\r\ngoto fail_sb;\r\nerror = init_per_node(sdp, DO);\r\nif (error)\r\ngoto fail_inodes;\r\nerror = gfs2_statfs_init(sdp);\r\nif (error) {\r\nfs_err(sdp, "can't initialize statfs subsystem: %d\n", error);\r\ngoto fail_per_node;\r\n}\r\nif (!(sb->s_flags & MS_RDONLY)) {\r\nerror = gfs2_make_fs_rw(sdp);\r\nif (error) {\r\nfs_err(sdp, "can't make FS RW: %d\n", error);\r\ngoto fail_per_node;\r\n}\r\n}\r\ngfs2_glock_dq_uninit(&mount_gh);\r\ngfs2_online_uevent(sdp);\r\nreturn 0;\r\nfail_per_node:\r\ninit_per_node(sdp, UNDO);\r\nfail_inodes:\r\ninit_inodes(sdp, UNDO);\r\nfail_sb:\r\nif (sdp->sd_root_dir)\r\ndput(sdp->sd_root_dir);\r\nif (sdp->sd_master_dir)\r\ndput(sdp->sd_master_dir);\r\nif (sb->s_root)\r\ndput(sb->s_root);\r\nsb->s_root = NULL;\r\nfail_locking:\r\ninit_locking(sdp, &mount_gh, UNDO);\r\nfail_lm:\r\ncomplete_all(&sdp->sd_journal_ready);\r\ngfs2_gl_hash_clear(sdp);\r\ngfs2_lm_unmount(sdp);\r\nfail_debug:\r\ngfs2_delete_debugfs_file(sdp);\r\nfree_percpu(sdp->sd_lkstats);\r\ngfs2_sys_fs_del(sdp);\r\nsb->s_fs_info = NULL;\r\nreturn error;\r\n}\r\nstatic int set_gfs2_super(struct super_block *s, void *data)\r\n{\r\ns->s_bdev = data;\r\ns->s_dev = s->s_bdev->bd_dev;\r\ns->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;\r\nreturn 0;\r\n}\r\nstatic int test_gfs2_super(struct super_block *s, void *ptr)\r\n{\r\nstruct block_device *bdev = ptr;\r\nreturn (bdev == s->s_bdev);\r\n}\r\nstatic struct dentry *gfs2_mount(struct file_system_type *fs_type, int flags,\r\nconst char *dev_name, void *data)\r\n{\r\nstruct block_device *bdev;\r\nstruct super_block *s;\r\nfmode_t mode = FMODE_READ | FMODE_EXCL;\r\nint error;\r\nstruct gfs2_args args;\r\nstruct gfs2_sbd *sdp;\r\nif (!(flags & MS_RDONLY))\r\nmode |= FMODE_WRITE;\r\nbdev = blkdev_get_by_path(dev_name, mode, fs_type);\r\nif (IS_ERR(bdev))\r\nreturn ERR_CAST(bdev);\r\nmutex_lock(&bdev->bd_fsfreeze_mutex);\r\nif (bdev->bd_fsfreeze_count > 0) {\r\nmutex_unlock(&bdev->bd_fsfreeze_mutex);\r\nerror = -EBUSY;\r\ngoto error_bdev;\r\n}\r\ns = sget(fs_type, test_gfs2_super, set_gfs2_super, flags, bdev);\r\nmutex_unlock(&bdev->bd_fsfreeze_mutex);\r\nerror = PTR_ERR(s);\r\nif (IS_ERR(s))\r\ngoto error_bdev;\r\nif (s->s_root) {\r\nup_write(&s->s_umount);\r\nblkdev_put(bdev, mode);\r\ndown_write(&s->s_umount);\r\n}\r\nmemset(&args, 0, sizeof(args));\r\nargs.ar_quota = GFS2_QUOTA_DEFAULT;\r\nargs.ar_data = GFS2_DATA_DEFAULT;\r\nargs.ar_commit = 30;\r\nargs.ar_statfs_quantum = 30;\r\nargs.ar_quota_quantum = 60;\r\nargs.ar_errors = GFS2_ERRORS_DEFAULT;\r\nerror = gfs2_mount_args(&args, data);\r\nif (error) {\r\npr_warn("can't parse mount arguments\n");\r\ngoto error_super;\r\n}\r\nif (s->s_root) {\r\nerror = -EBUSY;\r\nif ((flags ^ s->s_flags) & MS_RDONLY)\r\ngoto error_super;\r\n} else {\r\nchar b[BDEVNAME_SIZE];\r\ns->s_mode = mode;\r\nstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\r\nsb_set_blocksize(s, block_size(bdev));\r\nerror = fill_super(s, &args, flags & MS_SILENT ? 1 : 0);\r\nif (error)\r\ngoto error_super;\r\ns->s_flags |= MS_ACTIVE;\r\nbdev->bd_super = s;\r\n}\r\nsdp = s->s_fs_info;\r\nif (args.ar_meta)\r\nreturn dget(sdp->sd_master_dir);\r\nelse\r\nreturn dget(sdp->sd_root_dir);\r\nerror_super:\r\ndeactivate_locked_super(s);\r\nreturn ERR_PTR(error);\r\nerror_bdev:\r\nblkdev_put(bdev, mode);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic int set_meta_super(struct super_block *s, void *ptr)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic struct dentry *gfs2_mount_meta(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nstruct super_block *s;\r\nstruct gfs2_sbd *sdp;\r\nstruct path path;\r\nint error;\r\nerror = kern_path(dev_name, LOOKUP_FOLLOW, &path);\r\nif (error) {\r\npr_warn("path_lookup on %s returned error %d\n",\r\ndev_name, error);\r\nreturn ERR_PTR(error);\r\n}\r\ns = sget(&gfs2_fs_type, test_gfs2_super, set_meta_super, flags,\r\npath.dentry->d_inode->i_sb->s_bdev);\r\npath_put(&path);\r\nif (IS_ERR(s)) {\r\npr_warn("gfs2 mount does not exist\n");\r\nreturn ERR_CAST(s);\r\n}\r\nif ((flags ^ s->s_flags) & MS_RDONLY) {\r\ndeactivate_locked_super(s);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nsdp = s->s_fs_info;\r\nreturn dget(sdp->sd_master_dir);\r\n}\r\nstatic void gfs2_kill_sb(struct super_block *sb)\r\n{\r\nstruct gfs2_sbd *sdp = sb->s_fs_info;\r\nif (sdp == NULL) {\r\nkill_block_super(sb);\r\nreturn;\r\n}\r\ngfs2_log_flush(sdp, NULL, SYNC_FLUSH);\r\ndput(sdp->sd_root_dir);\r\ndput(sdp->sd_master_dir);\r\nsdp->sd_root_dir = NULL;\r\nsdp->sd_master_dir = NULL;\r\nshrink_dcache_sb(sb);\r\ngfs2_delete_debugfs_file(sdp);\r\nfree_percpu(sdp->sd_lkstats);\r\nkill_block_super(sb);\r\n}
