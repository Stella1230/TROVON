static struct uts_namespace *create_uts_ns(void)\r\n{\r\nstruct uts_namespace *uts_ns;\r\nuts_ns = kmalloc(sizeof(struct uts_namespace), GFP_KERNEL);\r\nif (uts_ns)\r\nkref_init(&uts_ns->kref);\r\nreturn uts_ns;\r\n}\r\nstatic struct uts_namespace *clone_uts_ns(struct user_namespace *user_ns,\r\nstruct uts_namespace *old_ns)\r\n{\r\nstruct uts_namespace *ns;\r\nint err;\r\nns = create_uts_ns();\r\nif (!ns)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = proc_alloc_inum(&ns->proc_inum);\r\nif (err) {\r\nkfree(ns);\r\nreturn ERR_PTR(err);\r\n}\r\ndown_read(&uts_sem);\r\nmemcpy(&ns->name, &old_ns->name, sizeof(ns->name));\r\nns->user_ns = get_user_ns(user_ns);\r\nup_read(&uts_sem);\r\nreturn ns;\r\n}\r\nstruct uts_namespace *copy_utsname(unsigned long flags,\r\nstruct user_namespace *user_ns, struct uts_namespace *old_ns)\r\n{\r\nstruct uts_namespace *new_ns;\r\nBUG_ON(!old_ns);\r\nget_uts_ns(old_ns);\r\nif (!(flags & CLONE_NEWUTS))\r\nreturn old_ns;\r\nnew_ns = clone_uts_ns(user_ns, old_ns);\r\nput_uts_ns(old_ns);\r\nreturn new_ns;\r\n}\r\nvoid free_uts_ns(struct kref *kref)\r\n{\r\nstruct uts_namespace *ns;\r\nns = container_of(kref, struct uts_namespace, kref);\r\nput_user_ns(ns->user_ns);\r\nproc_free_inum(ns->proc_inum);\r\nkfree(ns);\r\n}\r\nstatic void *utsns_get(struct task_struct *task)\r\n{\r\nstruct uts_namespace *ns = NULL;\r\nstruct nsproxy *nsproxy;\r\ntask_lock(task);\r\nnsproxy = task->nsproxy;\r\nif (nsproxy) {\r\nns = nsproxy->uts_ns;\r\nget_uts_ns(ns);\r\n}\r\ntask_unlock(task);\r\nreturn ns;\r\n}\r\nstatic void utsns_put(void *ns)\r\n{\r\nput_uts_ns(ns);\r\n}\r\nstatic int utsns_install(struct nsproxy *nsproxy, void *new)\r\n{\r\nstruct uts_namespace *ns = new;\r\nif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||\r\n!ns_capable(current_user_ns(), CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nget_uts_ns(ns);\r\nput_uts_ns(nsproxy->uts_ns);\r\nnsproxy->uts_ns = ns;\r\nreturn 0;\r\n}\r\nstatic unsigned int utsns_inum(void *vp)\r\n{\r\nstruct uts_namespace *ns = vp;\r\nreturn ns->proc_inum;\r\n}
