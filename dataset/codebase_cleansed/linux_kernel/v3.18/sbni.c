static inline int __init\r\nsbni_isa_probe( struct net_device *dev )\r\n{\r\nif( dev->base_addr > 0x1ff &&\r\nrequest_region( dev->base_addr, SBNI_IO_EXTENT, dev->name ) &&\r\nsbni_probe1( dev, dev->base_addr, dev->irq ) )\r\nreturn 0;\r\nelse {\r\npr_err("base address 0x%lx is busy, or adapter is malfunctional!\n",\r\ndev->base_addr);\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic void __init sbni_devsetup(struct net_device *dev)\r\n{\r\nether_setup( dev );\r\ndev->netdev_ops = &sbni_netdev_ops;\r\n}\r\nint __init sbni_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\nint err;\r\ndev = alloc_netdev(sizeof(struct net_local), "sbni",\r\nNET_NAME_UNKNOWN, sbni_devsetup);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->netdev_ops = &sbni_netdev_ops;\r\nsprintf(dev->name, "sbni%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = sbni_init(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nerr = register_netdev(dev);\r\nif (err) {\r\nrelease_region( dev->base_addr, SBNI_IO_EXTENT );\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\npr_info_once("%s", version);\r\nreturn 0;\r\n}\r\nstatic int __init sbni_init(struct net_device *dev)\r\n{\r\nint i;\r\nif( dev->base_addr )\r\nreturn sbni_isa_probe( dev );\r\nif( io[ num ] != -1 )\r\ndev->base_addr = io[ num ],\r\ndev->irq = irq[ num ];\r\nelse if( scandone || io[ 0 ] != -1 )\r\nreturn -ENODEV;\r\nif( dev->base_addr )\r\nreturn sbni_isa_probe( dev );\r\nif( !skip_pci_probe && !sbni_pci_probe( dev ) )\r\nreturn 0;\r\nif( io[ num ] == -1 ) {\r\nscandone = 1;\r\nif( num > 0 )\r\nreturn -ENODEV;\r\n}\r\nfor( i = 0; netcard_portlist[ i ]; ++i ) {\r\nint ioaddr = netcard_portlist[ i ];\r\nif( request_region( ioaddr, SBNI_IO_EXTENT, dev->name ) &&\r\nsbni_probe1( dev, ioaddr, 0 ))\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init\r\nsbni_pci_probe( struct net_device *dev )\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nwhile( (pdev = pci_get_class( PCI_CLASS_NETWORK_OTHER << 8, pdev ))\r\n!= NULL ) {\r\nint pci_irq_line;\r\nunsigned long pci_ioaddr;\r\nif( pdev->vendor != SBNI_PCI_VENDOR &&\r\npdev->device != SBNI_PCI_DEVICE )\r\ncontinue;\r\npci_ioaddr = pci_resource_start( pdev, 0 );\r\npci_irq_line = pdev->irq;\r\nif( !request_region( pci_ioaddr, SBNI_IO_EXTENT, dev->name ) ) {\r\nif (pdev->subsystem_device != 2)\r\ncontinue;\r\nif (!request_region(pci_ioaddr += 4, SBNI_IO_EXTENT,\r\ndev->name ) )\r\ncontinue;\r\n}\r\nif (pci_irq_line <= 0 || pci_irq_line >= nr_irqs)\r\npr_warn(\r\n"WARNING: The PCI BIOS assigned this PCI card to IRQ %d, which is unlikely to work!.\n"\r\n"You should use the PCI BIOS setup to assign a valid IRQ line.\n",\r\npci_irq_line );\r\nif( (pci_ioaddr & 7) == 0 && pci_enable_device( pdev ) ) {\r\nrelease_region( pci_ioaddr, SBNI_IO_EXTENT );\r\npci_dev_put( pdev );\r\nreturn -EIO;\r\n}\r\nif( sbni_probe1( dev, pci_ioaddr, pci_irq_line ) ) {\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npci_dev_put( pdev );\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic struct net_device * __init\r\nsbni_probe1( struct net_device *dev, unsigned long ioaddr, int irq )\r\n{\r\nstruct net_local *nl;\r\nif( sbni_card_probe( ioaddr ) ) {\r\nrelease_region( ioaddr, SBNI_IO_EXTENT );\r\nreturn NULL;\r\n}\r\noutb( 0, ioaddr + CSR0 );\r\nif( irq < 2 ) {\r\nunsigned long irq_mask;\r\nirq_mask = probe_irq_on();\r\noutb( EN_INT | TR_REQ, ioaddr + CSR0 );\r\noutb( PR_RES, ioaddr + CSR1 );\r\nmdelay(50);\r\nirq = probe_irq_off(irq_mask);\r\noutb( 0, ioaddr + CSR0 );\r\nif( !irq ) {\r\npr_err("%s: can't detect device irq!\n", dev->name);\r\nrelease_region( ioaddr, SBNI_IO_EXTENT );\r\nreturn NULL;\r\n}\r\n} else if( irq == 2 )\r\nirq = 9;\r\ndev->irq = irq;\r\ndev->base_addr = ioaddr;\r\nnl = netdev_priv(dev);\r\nif( !nl ) {\r\npr_err("%s: unable to get memory!\n", dev->name);\r\nrelease_region( ioaddr, SBNI_IO_EXTENT );\r\nreturn NULL;\r\n}\r\nmemset( nl, 0, sizeof(struct net_local) );\r\nspin_lock_init( &nl->lock );\r\n*(__be16 *)dev->dev_addr = htons( 0x00ff );\r\n*(__be32 *)(dev->dev_addr + 2) = htonl( 0x01000000 |\r\n((mac[num] ?\r\nmac[num] :\r\n(u32)((long)netdev_priv(dev))) & 0x00ffffff));\r\nnl->maxframe = DEFAULT_FRAME_LEN;\r\nnl->csr1.rate = baud[ num ];\r\nif( (nl->cur_rxl_index = rxl[ num ]) == -1 )\r\nnl->cur_rxl_index = DEF_RXL,\r\nnl->delta_rxl = DEF_RXL_DELTA;\r\nelse\r\nnl->delta_rxl = 0;\r\nnl->csr1.rxl = rxl_tab[ nl->cur_rxl_index ];\r\nif( inb( ioaddr + CSR0 ) & 0x01 )\r\nnl->state |= FL_SLOW_MODE;\r\npr_notice("%s: ioaddr %#lx, irq %d, MAC: 00:ff:01:%02x:%02x:%02x\n",\r\ndev->name, dev->base_addr, dev->irq,\r\n((u8 *)dev->dev_addr)[3],\r\n((u8 *)dev->dev_addr)[4],\r\n((u8 *)dev->dev_addr)[5]);\r\npr_notice("%s: speed %d",\r\ndev->name,\r\n((nl->state & FL_SLOW_MODE) ? 500000 : 2000000)\r\n/ (1 << nl->csr1.rate));\r\nif( nl->delta_rxl == 0 )\r\npr_cont(", receive level 0x%x (fixed)\n", nl->cur_rxl_index);\r\nelse\r\npr_cont(", receive level (auto)\n");\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nnl->master = dev;\r\nnl->link = NULL;\r\n#endif\r\nsbni_cards[ num++ ] = dev;\r\nreturn dev;\r\n}\r\nstatic netdev_tx_t\r\nsbni_start_xmit( struct sk_buff *skb, struct net_device *dev )\r\n{\r\nstruct net_device *p;\r\nnetif_stop_queue( dev );\r\nfor( p = dev; p; ) {\r\nstruct net_local *nl = netdev_priv(p);\r\nspin_lock( &nl->lock );\r\nif( nl->tx_buf_p || (nl->state & FL_LINE_DOWN) ) {\r\np = nl->link;\r\nspin_unlock( &nl->lock );\r\n} else {\r\nprepare_to_send( skb, p );\r\nspin_unlock( &nl->lock );\r\nnetif_start_queue( dev );\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nstatic netdev_tx_t\r\nsbni_start_xmit( struct sk_buff *skb, struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nnetif_stop_queue( dev );\r\nspin_lock( &nl->lock );\r\nprepare_to_send( skb, dev );\r\nspin_unlock( &nl->lock );\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\nsbni_interrupt( int irq, void *dev_id )\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *nl = netdev_priv(dev);\r\nint repeat;\r\nspin_lock( &nl->lock );\r\nif( nl->second )\r\nspin_lock(&NET_LOCAL_LOCK(nl->second));\r\ndo {\r\nrepeat = 0;\r\nif( inb( dev->base_addr + CSR0 ) & (RC_RDY | TR_RDY) )\r\nhandle_channel( dev ),\r\nrepeat = 1;\r\nif( nl->second &&\r\n(inb( nl->second->base_addr+CSR0 ) & (RC_RDY | TR_RDY)) )\r\nhandle_channel( nl->second ),\r\nrepeat = 1;\r\n} while( repeat );\r\nif( nl->second )\r\nspin_unlock(&NET_LOCAL_LOCK(nl->second));\r\nspin_unlock( &nl->lock );\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nhandle_channel( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nunsigned long ioaddr = dev->base_addr;\r\nint req_ans;\r\nunsigned char csr0;\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nif( nl->state & FL_SLAVE )\r\nspin_lock(&NET_LOCAL_LOCK(nl->master));\r\n#endif\r\noutb( (inb( ioaddr + CSR0 ) & ~EN_INT) | TR_REQ, ioaddr + CSR0 );\r\nnl->timer_ticks = CHANGE_LEVEL_START_TICKS;\r\nfor(;;) {\r\ncsr0 = inb( ioaddr + CSR0 );\r\nif( ( csr0 & (RC_RDY | TR_RDY) ) == 0 )\r\nbreak;\r\nreq_ans = !(nl->state & FL_PREV_OK);\r\nif( csr0 & RC_RDY )\r\nreq_ans = recv_frame( dev );\r\ncsr0 = inb( ioaddr + CSR0 );\r\nif( !(csr0 & TR_RDY) || (csr0 & RC_RDY) )\r\nnetdev_err(dev, "internal error!\n");\r\nif( req_ans || nl->tx_frameno != 0 )\r\nsend_frame( dev );\r\nelse\r\noutb( inb( ioaddr + CSR0 ) & ~TR_REQ, ioaddr + CSR0 );\r\n}\r\noutb( inb( ioaddr + CSR0 ) | EN_INT, ioaddr + CSR0 );\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nif( nl->state & FL_SLAVE )\r\nspin_unlock(&NET_LOCAL_LOCK(nl->master));\r\n#endif\r\n}\r\nstatic int\r\nrecv_frame( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nunsigned long ioaddr = dev->base_addr;\r\nu32 crc = CRC32_INITIAL;\r\nunsigned framelen = 0, frameno, ack;\r\nunsigned is_first, frame_ok = 0;\r\nif( check_fhdr( ioaddr, &framelen, &frameno, &ack, &is_first, &crc ) ) {\r\nframe_ok = framelen > 4\r\n? upload_data( dev, framelen, frameno, is_first, crc )\r\n: skip_tail( ioaddr, framelen, crc );\r\nif( frame_ok )\r\ninterpret_ack( dev, ack );\r\n}\r\noutb( inb( ioaddr + CSR0 ) ^ CT_ZER, ioaddr + CSR0 );\r\nif( frame_ok ) {\r\nnl->state |= FL_PREV_OK;\r\nif( framelen > 4 )\r\nnl->in_stats.all_rx_number++;\r\n} else\r\nnl->state &= ~FL_PREV_OK,\r\nchange_level( dev ),\r\nnl->in_stats.all_rx_number++,\r\nnl->in_stats.bad_rx_number++;\r\nreturn !frame_ok || framelen > 4;\r\n}\r\nstatic void\r\nsend_frame( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nu32 crc = CRC32_INITIAL;\r\nif( nl->state & FL_NEED_RESEND ) {\r\nif( nl->trans_errors ) {\r\n--nl->trans_errors;\r\nif( nl->framelen != 0 )\r\nnl->in_stats.resend_tx_number++;\r\n} else {\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nif( (nl->state & FL_SLAVE) || nl->link )\r\n#endif\r\nnl->state |= FL_LINE_DOWN;\r\ndrop_xmit_queue( dev );\r\ngoto do_send;\r\n}\r\n} else\r\nnl->trans_errors = TR_ERROR_COUNT;\r\nsend_frame_header( dev, &crc );\r\nnl->state |= FL_NEED_RESEND;\r\nif( nl->framelen ) {\r\ndownload_data( dev, &crc );\r\nnl->in_stats.all_tx_number++;\r\nnl->state |= FL_WAIT_ACK;\r\n}\r\noutsb( dev->base_addr + DAT, (u8 *)&crc, sizeof crc );\r\ndo_send:\r\noutb( inb( dev->base_addr + CSR0 ) & ~TR_REQ, dev->base_addr + CSR0 );\r\nif( nl->tx_frameno )\r\noutb( inb( dev->base_addr + CSR0 ) | TR_REQ,\r\ndev->base_addr + CSR0 );\r\n}\r\nstatic void\r\ndownload_data( struct net_device *dev, u32 *crc_p )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct sk_buff *skb = nl->tx_buf_p;\r\nunsigned len = min_t(unsigned int, skb->len - nl->outpos, nl->framelen);\r\noutsb( dev->base_addr + DAT, skb->data + nl->outpos, len );\r\n*crc_p = calc_crc32( *crc_p, skb->data + nl->outpos, len );\r\nfor( len = nl->framelen - len; len--; )\r\noutb( 0, dev->base_addr + DAT ),\r\n*crc_p = CRC32( 0, *crc_p );\r\n}\r\nstatic int\r\nupload_data( struct net_device *dev, unsigned framelen, unsigned frameno,\r\nunsigned is_first, u32 crc )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nint frame_ok;\r\nif( is_first )\r\nnl->wait_frameno = frameno,\r\nnl->inppos = 0;\r\nif( nl->wait_frameno == frameno ) {\r\nif( nl->inppos + framelen <= ETHER_MAX_LEN )\r\nframe_ok = append_frame_to_pkt( dev, framelen, crc );\r\nelse if( (frame_ok = skip_tail( dev->base_addr, framelen, crc ))\r\n!= 0 )\r\nnl->wait_frameno = 0,\r\nnl->inppos = 0,\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nnl->master->stats.rx_errors++,\r\nnl->master->stats.rx_missed_errors++;\r\n#else\r\ndev->stats.rx_errors++,\r\ndev->stats.rx_missed_errors++;\r\n#endif\r\n} else\r\nframe_ok = skip_tail( dev->base_addr, framelen, crc );\r\nif( is_first && !frame_ok )\r\nnl->wait_frameno = 0,\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nnl->master->stats.rx_errors++,\r\nnl->master->stats.rx_crc_errors++;\r\n#else\r\ndev->stats.rx_errors++,\r\ndev->stats.rx_crc_errors++;\r\n#endif\r\nreturn frame_ok;\r\n}\r\nstatic inline void\r\nsend_complete( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nnl->master->stats.tx_packets++;\r\nnl->master->stats.tx_bytes += nl->tx_buf_p->len;\r\n#else\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += nl->tx_buf_p->len;\r\n#endif\r\ndev_kfree_skb_irq( nl->tx_buf_p );\r\nnl->tx_buf_p = NULL;\r\nnl->outpos = 0;\r\nnl->state &= ~(FL_WAIT_ACK | FL_NEED_RESEND);\r\nnl->framelen = 0;\r\n}\r\nstatic void\r\ninterpret_ack( struct net_device *dev, unsigned ack )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nif( ack == FRAME_SENT_OK ) {\r\nnl->state &= ~FL_NEED_RESEND;\r\nif( nl->state & FL_WAIT_ACK ) {\r\nnl->outpos += nl->framelen;\r\nif( --nl->tx_frameno )\r\nnl->framelen = min_t(unsigned int,\r\nnl->maxframe,\r\nnl->tx_buf_p->len - nl->outpos);\r\nelse\r\nsend_complete( dev ),\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nnetif_wake_queue( nl->master );\r\n#else\r\nnetif_wake_queue( dev );\r\n#endif\r\n}\r\n}\r\nnl->state &= ~FL_WAIT_ACK;\r\n}\r\nstatic int\r\nappend_frame_to_pkt( struct net_device *dev, unsigned framelen, u32 crc )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nu8 *p;\r\nif( nl->inppos + framelen > ETHER_MAX_LEN )\r\nreturn 0;\r\nif( !nl->rx_buf_p && !(nl->rx_buf_p = get_rx_buf( dev )) )\r\nreturn 0;\r\np = nl->rx_buf_p->data + nl->inppos;\r\ninsb( dev->base_addr + DAT, p, framelen );\r\nif( calc_crc32( crc, p, framelen ) != CRC32_REMAINDER )\r\nreturn 0;\r\nnl->inppos += framelen - 4;\r\nif( --nl->wait_frameno == 0 )\r\nindicate_pkt( dev );\r\nreturn 1;\r\n}\r\nstatic void\r\nprepare_to_send( struct sk_buff *skb, struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nunsigned int len;\r\nif( nl->tx_buf_p )\r\nnetdev_err(dev, "memory leak!\n");\r\nnl->outpos = 0;\r\nnl->state &= ~(FL_WAIT_ACK | FL_NEED_RESEND);\r\nlen = skb->len;\r\nif( len < SBNI_MIN_LEN )\r\nlen = SBNI_MIN_LEN;\r\nnl->tx_buf_p = skb;\r\nnl->tx_frameno = DIV_ROUND_UP(len, nl->maxframe);\r\nnl->framelen = len < nl->maxframe ? len : nl->maxframe;\r\noutb( inb( dev->base_addr + CSR0 ) | TR_REQ, dev->base_addr + CSR0 );\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nnl->master->trans_start = jiffies;\r\n#else\r\ndev->trans_start = jiffies;\r\n#endif\r\n}\r\nstatic void\r\ndrop_xmit_queue( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nif( nl->tx_buf_p )\r\ndev_kfree_skb_any( nl->tx_buf_p ),\r\nnl->tx_buf_p = NULL,\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nnl->master->stats.tx_errors++,\r\nnl->master->stats.tx_carrier_errors++;\r\n#else\r\ndev->stats.tx_errors++,\r\ndev->stats.tx_carrier_errors++;\r\n#endif\r\nnl->tx_frameno = 0;\r\nnl->framelen = 0;\r\nnl->outpos = 0;\r\nnl->state &= ~(FL_WAIT_ACK | FL_NEED_RESEND);\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nnetif_start_queue( nl->master );\r\nnl->master->trans_start = jiffies;\r\n#else\r\nnetif_start_queue( dev );\r\ndev->trans_start = jiffies;\r\n#endif\r\n}\r\nstatic void\r\nsend_frame_header( struct net_device *dev, u32 *crc_p )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nu32 crc = *crc_p;\r\nu32 len_field = nl->framelen + 6;\r\nu8 value;\r\nif( nl->state & FL_NEED_RESEND )\r\nlen_field |= FRAME_RETRY;\r\nif( nl->outpos == 0 )\r\nlen_field |= FRAME_FIRST;\r\nlen_field |= (nl->state & FL_PREV_OK) ? FRAME_SENT_OK : FRAME_SENT_BAD;\r\noutb( SBNI_SIG, dev->base_addr + DAT );\r\nvalue = (u8) len_field;\r\noutb( value, dev->base_addr + DAT );\r\ncrc = CRC32( value, crc );\r\nvalue = (u8) (len_field >> 8);\r\noutb( value, dev->base_addr + DAT );\r\ncrc = CRC32( value, crc );\r\noutb( nl->tx_frameno, dev->base_addr + DAT );\r\ncrc = CRC32( nl->tx_frameno, crc );\r\noutb( 0, dev->base_addr + DAT );\r\ncrc = CRC32( 0, crc );\r\n*crc_p = crc;\r\n}\r\nstatic int\r\nskip_tail( unsigned int ioaddr, unsigned int tail_len, u32 crc )\r\n{\r\nwhile( tail_len-- )\r\ncrc = CRC32( inb( ioaddr + DAT ), crc );\r\nreturn crc == CRC32_REMAINDER;\r\n}\r\nstatic int\r\ncheck_fhdr( u32 ioaddr, u32 *framelen, u32 *frameno, u32 *ack,\r\nu32 *is_first, u32 *crc_p )\r\n{\r\nu32 crc = *crc_p;\r\nu8 value;\r\nif( inb( ioaddr + DAT ) != SBNI_SIG )\r\nreturn 0;\r\nvalue = inb( ioaddr + DAT );\r\n*framelen = (u32)value;\r\ncrc = CRC32( value, crc );\r\nvalue = inb( ioaddr + DAT );\r\n*framelen |= ((u32)value) << 8;\r\ncrc = CRC32( value, crc );\r\n*ack = *framelen & FRAME_ACK_MASK;\r\n*is_first = (*framelen & FRAME_FIRST) != 0;\r\nif( (*framelen &= FRAME_LEN_MASK) < 6 ||\r\n*framelen > SBNI_MAX_FRAME - 3 )\r\nreturn 0;\r\nvalue = inb( ioaddr + DAT );\r\n*frameno = (u32)value;\r\ncrc = CRC32( value, crc );\r\ncrc = CRC32( inb( ioaddr + DAT ), crc );\r\n*framelen -= 2;\r\n*crc_p = crc;\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *\r\nget_rx_buf( struct net_device *dev )\r\n{\r\nstruct sk_buff *skb = dev_alloc_skb( ETHER_MAX_LEN + 2 );\r\nif( !skb )\r\nreturn NULL;\r\nskb_reserve( skb, 2 );\r\nreturn skb;\r\n}\r\nstatic void\r\nindicate_pkt( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct sk_buff *skb = nl->rx_buf_p;\r\nskb_put( skb, nl->inppos );\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nskb->protocol = eth_type_trans( skb, nl->master );\r\nnetif_rx( skb );\r\n++nl->master->stats.rx_packets;\r\nnl->master->stats.rx_bytes += nl->inppos;\r\n#else\r\nskb->protocol = eth_type_trans( skb, dev );\r\nnetif_rx( skb );\r\n++dev->stats.rx_packets;\r\ndev->stats.rx_bytes += nl->inppos;\r\n#endif\r\nnl->rx_buf_p = NULL;\r\n}\r\nstatic void\r\nsbni_watchdog( unsigned long arg )\r\n{\r\nstruct net_device *dev = (struct net_device *) arg;\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct timer_list *w = &nl->watchdog;\r\nunsigned long flags;\r\nunsigned char csr0;\r\nspin_lock_irqsave( &nl->lock, flags );\r\ncsr0 = inb( dev->base_addr + CSR0 );\r\nif( csr0 & RC_CHK ) {\r\nif( nl->timer_ticks ) {\r\nif( csr0 & (RC_RDY | BU_EMP) )\r\nnl->timer_ticks--;\r\n} else {\r\nnl->in_stats.timeout_number++;\r\nif( nl->delta_rxl )\r\ntimeout_change_level( dev );\r\noutb( *(u_char *)&nl->csr1 | PR_RES,\r\ndev->base_addr + CSR1 );\r\ncsr0 = inb( dev->base_addr + CSR0 );\r\n}\r\n} else\r\nnl->state &= ~FL_LINE_DOWN;\r\noutb( csr0 | RC_CHK, dev->base_addr + CSR0 );\r\ninit_timer( w );\r\nw->expires = jiffies + SBNI_TIMEOUT;\r\nw->data = arg;\r\nw->function = sbni_watchdog;\r\nadd_timer( w );\r\nspin_unlock_irqrestore( &nl->lock, flags );\r\n}\r\nstatic void\r\ncard_start( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nnl->timer_ticks = CHANGE_LEVEL_START_TICKS;\r\nnl->state &= ~(FL_WAIT_ACK | FL_NEED_RESEND);\r\nnl->state |= FL_PREV_OK;\r\nnl->inppos = nl->outpos = 0;\r\nnl->wait_frameno = 0;\r\nnl->tx_frameno = 0;\r\nnl->framelen = 0;\r\noutb( *(u_char *)&nl->csr1 | PR_RES, dev->base_addr + CSR1 );\r\noutb( EN_INT, dev->base_addr + CSR0 );\r\n}\r\nstatic void\r\nchange_level( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nif( nl->delta_rxl == 0 )\r\nreturn;\r\nif( nl->cur_rxl_index == 0 )\r\nnl->delta_rxl = 1;\r\nelse if( nl->cur_rxl_index == 15 )\r\nnl->delta_rxl = -1;\r\nelse if( nl->cur_rxl_rcvd < nl->prev_rxl_rcvd )\r\nnl->delta_rxl = -nl->delta_rxl;\r\nnl->csr1.rxl = rxl_tab[ nl->cur_rxl_index += nl->delta_rxl ];\r\ninb( dev->base_addr + CSR0 );\r\noutb( *(u8 *)&nl->csr1, dev->base_addr + CSR1 );\r\nnl->prev_rxl_rcvd = nl->cur_rxl_rcvd;\r\nnl->cur_rxl_rcvd = 0;\r\n}\r\nstatic void\r\ntimeout_change_level( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nnl->cur_rxl_index = timeout_rxl_tab[ nl->timeout_rxl ];\r\nif( ++nl->timeout_rxl >= 4 )\r\nnl->timeout_rxl = 0;\r\nnl->csr1.rxl = rxl_tab[ nl->cur_rxl_index ];\r\ninb( dev->base_addr + CSR0 );\r\noutb( *(unsigned char *)&nl->csr1, dev->base_addr + CSR1 );\r\nnl->prev_rxl_rcvd = nl->cur_rxl_rcvd;\r\nnl->cur_rxl_rcvd = 0;\r\n}\r\nstatic int\r\nsbni_open( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct timer_list *w = &nl->watchdog;\r\nif( dev->base_addr < 0x400 ) {\r\nstruct net_device **p = sbni_cards;\r\nfor( ; *p && p < sbni_cards + SBNI_MAX_NUM_CARDS; ++p )\r\nif( (*p)->irq == dev->irq &&\r\n((*p)->base_addr == dev->base_addr + 4 ||\r\n(*p)->base_addr == dev->base_addr - 4) &&\r\n(*p)->flags & IFF_UP ) {\r\n((struct net_local *) (netdev_priv(*p)))\r\n->second = dev;\r\nnetdev_notice(dev, "using shared irq with %s\n",\r\n(*p)->name);\r\nnl->state |= FL_SECONDARY;\r\ngoto handler_attached;\r\n}\r\n}\r\nif( request_irq(dev->irq, sbni_interrupt, IRQF_SHARED, dev->name, dev) ) {\r\nnetdev_err(dev, "unable to get IRQ %d\n", dev->irq);\r\nreturn -EAGAIN;\r\n}\r\nhandler_attached:\r\nspin_lock( &nl->lock );\r\nmemset( &dev->stats, 0, sizeof(struct net_device_stats) );\r\nmemset( &nl->in_stats, 0, sizeof(struct sbni_in_stats) );\r\ncard_start( dev );\r\nnetif_start_queue( dev );\r\ninit_timer( w );\r\nw->expires = jiffies + SBNI_TIMEOUT;\r\nw->data = (unsigned long) dev;\r\nw->function = sbni_watchdog;\r\nadd_timer( w );\r\nspin_unlock( &nl->lock );\r\nreturn 0;\r\n}\r\nstatic int\r\nsbni_close( struct net_device *dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nif( nl->second && nl->second->flags & IFF_UP ) {\r\nnetdev_notice(dev, "Secondary channel (%s) is active!\n",\r\nnl->second->name);\r\nreturn -EBUSY;\r\n}\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nif( nl->state & FL_SLAVE )\r\nemancipate( dev );\r\nelse\r\nwhile( nl->link )\r\nemancipate( nl->link );\r\n#endif\r\nspin_lock( &nl->lock );\r\nnl->second = NULL;\r\ndrop_xmit_queue( dev );\r\nnetif_stop_queue( dev );\r\ndel_timer( &nl->watchdog );\r\noutb( 0, dev->base_addr + CSR0 );\r\nif( !(nl->state & FL_SECONDARY) )\r\nfree_irq( dev->irq, dev );\r\nnl->state &= FL_SECONDARY;\r\nspin_unlock( &nl->lock );\r\nreturn 0;\r\n}\r\nstatic int\r\nsbni_card_probe( unsigned long ioaddr )\r\n{\r\nunsigned char csr0;\r\ncsr0 = inb( ioaddr + CSR0 );\r\nif( csr0 != 0xff && csr0 != 0x00 ) {\r\ncsr0 &= ~EN_INT;\r\nif( csr0 & BU_EMP )\r\ncsr0 |= EN_INT;\r\nif( VALID_DECODER & (1 << (csr0 >> 4)) )\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nsbni_ioctl( struct net_device *dev, struct ifreq *ifr, int cmd )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct sbni_flags flags;\r\nint error = 0;\r\n#ifdef CONFIG_SBNI_MULTILINE\r\nstruct net_device *slave_dev;\r\nchar slave_name[ 8 ];\r\n#endif\r\nswitch( cmd ) {\r\ncase SIOCDEVGETINSTATS :\r\nif (copy_to_user( ifr->ifr_data, &nl->in_stats,\r\nsizeof(struct sbni_in_stats) ))\r\nerror = -EFAULT;\r\nbreak;\r\ncase SIOCDEVRESINSTATS :\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nmemset( &nl->in_stats, 0, sizeof(struct sbni_in_stats) );\r\nbreak;\r\ncase SIOCDEVGHWSTATE :\r\nflags.mac_addr = *(u32 *)(dev->dev_addr + 3);\r\nflags.rate = nl->csr1.rate;\r\nflags.slow_mode = (nl->state & FL_SLOW_MODE) != 0;\r\nflags.rxl = nl->cur_rxl_index;\r\nflags.fixed_rxl = nl->delta_rxl == 0;\r\nif (copy_to_user( ifr->ifr_data, &flags, sizeof flags ))\r\nerror = -EFAULT;\r\nbreak;\r\ncase SIOCDEVSHWSTATE :\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nspin_lock( &nl->lock );\r\nflags = *(struct sbni_flags*) &ifr->ifr_ifru;\r\nif( flags.fixed_rxl )\r\nnl->delta_rxl = 0,\r\nnl->cur_rxl_index = flags.rxl;\r\nelse\r\nnl->delta_rxl = DEF_RXL_DELTA,\r\nnl->cur_rxl_index = DEF_RXL;\r\nnl->csr1.rxl = rxl_tab[ nl->cur_rxl_index ];\r\nnl->csr1.rate = flags.rate;\r\noutb( *(u8 *)&nl->csr1 | PR_RES, dev->base_addr + CSR1 );\r\nspin_unlock( &nl->lock );\r\nbreak;\r\n#ifdef CONFIG_SBNI_MULTILINE\r\ncase SIOCDEVENSLAVE :\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user( slave_name, ifr->ifr_data, sizeof slave_name ))\r\nreturn -EFAULT;\r\nslave_dev = dev_get_by_name(&init_net, slave_name );\r\nif( !slave_dev || !(slave_dev->flags & IFF_UP) ) {\r\nnetdev_err(dev, "trying to enslave non-active device %s\n",\r\nslave_name);\r\nreturn -EPERM;\r\n}\r\nreturn enslave( dev, slave_dev );\r\ncase SIOCDEVEMANSIPATE :\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn emancipate( dev );\r\n#endif\r\ndefault :\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn error;\r\n}\r\nstatic int\r\nenslave( struct net_device *dev, struct net_device *slave_dev )\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct net_local *snl = netdev_priv(slave_dev);\r\nif( nl->state & FL_SLAVE )\r\nreturn -EBUSY;\r\nif( snl->state & FL_SLAVE )\r\nreturn -EBUSY;\r\nspin_lock( &nl->lock );\r\nspin_lock( &snl->lock );\r\nsnl->link = nl->link;\r\nnl->link = slave_dev;\r\nsnl->master = dev;\r\nsnl->state |= FL_SLAVE;\r\nmemset( &slave_dev->stats, 0, sizeof(struct net_device_stats) );\r\nnetif_stop_queue( slave_dev );\r\nnetif_wake_queue( dev );\r\nspin_unlock( &snl->lock );\r\nspin_unlock( &nl->lock );\r\nnetdev_notice(dev, "slave device (%s) attached\n", slave_dev->name);\r\nreturn 0;\r\n}\r\nstatic int\r\nemancipate( struct net_device *dev )\r\n{\r\nstruct net_local *snl = netdev_priv(dev);\r\nstruct net_device *p = snl->master;\r\nstruct net_local *nl = netdev_priv(p);\r\nif( !(snl->state & FL_SLAVE) )\r\nreturn -EINVAL;\r\nspin_lock( &nl->lock );\r\nspin_lock( &snl->lock );\r\ndrop_xmit_queue( dev );\r\nfor(;;) {\r\nstruct net_local *t = netdev_priv(p);\r\nif( t->link == dev ) {\r\nt->link = snl->link;\r\nbreak;\r\n}\r\np = t->link;\r\n}\r\nsnl->link = NULL;\r\nsnl->master = dev;\r\nsnl->state &= ~FL_SLAVE;\r\nnetif_start_queue( dev );\r\nspin_unlock( &snl->lock );\r\nspin_unlock( &nl->lock );\r\ndev_put( dev );\r\nreturn 0;\r\n}\r\nstatic void\r\nset_multicast_list( struct net_device *dev )\r\n{\r\nreturn;\r\n}\r\nint __init init_module( void )\r\n{\r\nstruct net_device *dev;\r\nint err;\r\nwhile( num < SBNI_MAX_NUM_CARDS ) {\r\ndev = alloc_netdev(sizeof(struct net_local), "sbni%d",\r\nNET_NAME_UNKNOWN, sbni_devsetup);\r\nif( !dev)\r\nbreak;\r\nsprintf( dev->name, "sbni%d", num );\r\nerr = sbni_init(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\nif( register_netdev( dev ) ) {\r\nrelease_region( dev->base_addr, SBNI_IO_EXTENT );\r\nfree_netdev( dev );\r\nbreak;\r\n}\r\n}\r\nreturn *sbni_cards ? 0 : -ENODEV;\r\n}\r\nvoid\r\ncleanup_module(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SBNI_MAX_NUM_CARDS; ++i) {\r\nstruct net_device *dev = sbni_cards[i];\r\nif (dev != NULL) {\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, SBNI_IO_EXTENT);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}\r\nstatic int __init\r\nsbni_setup( char *p )\r\n{\r\nint n, parm;\r\nif( *p++ != '(' )\r\ngoto bad_param;\r\nfor( n = 0, parm = 0; *p && n < 8; ) {\r\n(*dest[ parm ])[ n ] = simple_strtol( p, &p, 0 );\r\nif( !*p || *p == ')' )\r\nreturn 1;\r\nif( *p == ';' )\r\n++p, ++n, parm = 0;\r\nelse if( *p++ != ',' )\r\nbreak;\r\nelse\r\nif( ++parm >= 5 )\r\nbreak;\r\n}\r\nbad_param:\r\npr_err("Error in sbni kernel parameter!\n");\r\nreturn 0;\r\n}\r\nstatic u32\r\ncalc_crc32( u32 crc, u8 *p, u32 len )\r\n{\r\nwhile( len-- )\r\ncrc = CRC32( *p++, crc );\r\nreturn crc;\r\n}
