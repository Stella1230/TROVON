static int st_press_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *ch,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nint err;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (val2)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nerr = st_sensors_set_odr(indio_dev, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn err;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int st_press_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *ch, int *val,\r\nint *val2, long mask)\r\n{\r\nint err;\r\nstruct st_sensor_data *pdata = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nerr = st_sensors_read_info_raw(indio_dev, ch, val);\r\nif (err < 0)\r\ngoto read_error;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\nswitch (ch->type) {\r\ncase IIO_PRESSURE:\r\n*val2 = pdata->current_fullscale->gain;\r\nbreak;\r\ncase IIO_TEMP:\r\n*val2 = pdata->current_fullscale->gain2;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto read_error;\r\n}\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nswitch (ch->type) {\r\ncase IIO_TEMP:\r\n*val = 425;\r\n*val2 = 10;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto read_error;\r\n}\r\nreturn IIO_VAL_FRACTIONAL;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = pdata->odr;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nread_error:\r\nreturn err;\r\n}\r\nint st_press_common_probe(struct iio_dev *indio_dev,\r\nstruct st_sensors_platform_data *plat_data)\r\n{\r\nstruct st_sensor_data *pdata = iio_priv(indio_dev);\r\nint irq = pdata->get_irq_data_ready(indio_dev);\r\nint err;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &press_info;\r\nst_sensors_power_enable(indio_dev);\r\nerr = st_sensors_check_device_support(indio_dev,\r\nARRAY_SIZE(st_press_sensors),\r\nst_press_sensors);\r\nif (err < 0)\r\nreturn err;\r\npdata->num_data_channels = ST_PRESS_NUMBER_DATA_CHANNELS;\r\npdata->multiread_bit = pdata->sensor->multi_read_bit;\r\nindio_dev->channels = pdata->sensor->ch;\r\nindio_dev->num_channels = pdata->sensor->num_ch;\r\nif (pdata->sensor->fs.addr != 0)\r\npdata->current_fullscale = (struct st_sensor_fullscale_avl *)\r\n&pdata->sensor->fs.fs_avl[0];\r\npdata->odr = pdata->sensor->odr.odr_avl[0].hz;\r\nif (!plat_data && pdata->sensor->drdy_irq.addr)\r\nplat_data =\r\n(struct st_sensors_platform_data *)&default_press_pdata;\r\nerr = st_sensors_init_sensor(indio_dev, plat_data);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_press_allocate_ring(indio_dev);\r\nif (err < 0)\r\nreturn err;\r\nif (irq > 0) {\r\nerr = st_sensors_allocate_trigger(indio_dev,\r\nST_PRESS_TRIGGER_OPS);\r\nif (err < 0)\r\ngoto st_press_probe_trigger_error;\r\n}\r\nerr = iio_device_register(indio_dev);\r\nif (err)\r\ngoto st_press_device_register_error;\r\ndev_info(&indio_dev->dev, "registered pressure sensor %s\n",\r\nindio_dev->name);\r\nreturn err;\r\nst_press_device_register_error:\r\nif (irq > 0)\r\nst_sensors_deallocate_trigger(indio_dev);\r\nst_press_probe_trigger_error:\r\nst_press_deallocate_ring(indio_dev);\r\nreturn err;\r\n}\r\nvoid st_press_common_remove(struct iio_dev *indio_dev)\r\n{\r\nstruct st_sensor_data *pdata = iio_priv(indio_dev);\r\nst_sensors_power_disable(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (pdata->get_irq_data_ready(indio_dev) > 0)\r\nst_sensors_deallocate_trigger(indio_dev);\r\nst_press_deallocate_ring(indio_dev);\r\n}
