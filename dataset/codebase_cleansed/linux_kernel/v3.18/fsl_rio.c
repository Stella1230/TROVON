int fsl_rio_mcheck_exception(struct pt_regs *regs)\r\n{\r\nconst struct exception_table_entry *entry;\r\nunsigned long reason;\r\nif (!rio_regs_win)\r\nreturn 0;\r\nreason = in_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR));\r\nif (reason & (RIO_LTLEDCSR_IER | RIO_LTLEDCSR_PRT)) {\r\nentry = search_exception_tables(regs->nip);\r\nif (entry) {\r\npr_debug("RIO: %s - MC Exception handled\n",\r\n__func__);\r\nout_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR),\r\n0);\r\nregs->msr |= MSR_RI;\r\nregs->nip = entry->fixup;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_local_config_read(struct rio_mport *mport,\r\nint index, u32 offset, int len, u32 *data)\r\n{\r\nstruct rio_priv *priv = mport->priv;\r\npr_debug("fsl_local_config_read: index %d offset %8.8x\n", index,\r\noffset);\r\n*data = in_be32(priv->regs_win + offset);\r\nreturn 0;\r\n}\r\nstatic int fsl_local_config_write(struct rio_mport *mport,\r\nint index, u32 offset, int len, u32 data)\r\n{\r\nstruct rio_priv *priv = mport->priv;\r\npr_debug\r\n("fsl_local_config_write: index %d offset %8.8x data %8.8x\n",\r\nindex, offset, data);\r\nout_be32(priv->regs_win + offset, data);\r\nreturn 0;\r\n}\r\nstatic int\r\nfsl_rio_config_read(struct rio_mport *mport, int index, u16 destid,\r\nu8 hopcount, u32 offset, int len, u32 *val)\r\n{\r\nstruct rio_priv *priv = mport->priv;\r\nu8 *data;\r\nu32 rval, err = 0;\r\npr_debug\r\n("fsl_rio_config_read:"\r\n" index %d destid %d hopcount %d offset %8.8x len %d\n",\r\nindex, destid, hopcount, offset, len);\r\nif (offset > (0x1000000 - len) || !IS_ALIGNED(offset, len))\r\nreturn -EINVAL;\r\nout_be32(&priv->maint_atmu_regs->rowtar,\r\n(destid << 22) | (hopcount << 12) | (offset >> 12));\r\nout_be32(&priv->maint_atmu_regs->rowtear, (destid >> 10));\r\ndata = (u8 *) priv->maint_win + (offset & (RIO_MAINT_WIN_SIZE - 1));\r\nswitch (len) {\r\ncase 1:\r\n__fsl_read_rio_config(rval, data, err, "lbz");\r\nbreak;\r\ncase 2:\r\n__fsl_read_rio_config(rval, data, err, "lhz");\r\nbreak;\r\ncase 4:\r\n__fsl_read_rio_config(rval, data, err, "lwz");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (err) {\r\npr_debug("RIO: cfg_read error %d for %x:%x:%x\n",\r\nerr, destid, hopcount, offset);\r\n}\r\n*val = rval;\r\nreturn err;\r\n}\r\nstatic int\r\nfsl_rio_config_write(struct rio_mport *mport, int index, u16 destid,\r\nu8 hopcount, u32 offset, int len, u32 val)\r\n{\r\nstruct rio_priv *priv = mport->priv;\r\nu8 *data;\r\npr_debug\r\n("fsl_rio_config_write:"\r\n" index %d destid %d hopcount %d offset %8.8x len %d val %8.8x\n",\r\nindex, destid, hopcount, offset, len, val);\r\nif (offset > (0x1000000 - len) || !IS_ALIGNED(offset, len))\r\nreturn -EINVAL;\r\nout_be32(&priv->maint_atmu_regs->rowtar,\r\n(destid << 22) | (hopcount << 12) | (offset >> 12));\r\nout_be32(&priv->maint_atmu_regs->rowtear, (destid >> 10));\r\ndata = (u8 *) priv->maint_win + (offset & (RIO_MAINT_WIN_SIZE - 1));\r\nswitch (len) {\r\ncase 1:\r\nout_8((u8 *) data, val);\r\nbreak;\r\ncase 2:\r\nout_be16((u16 *) data, val);\r\nbreak;\r\ncase 4:\r\nout_be32((u32 *) data, val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid fsl_rio_port_error_handler(int offset)\r\n{\r\nout_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR), 0);\r\nif (offset == 0) {\r\nout_be32((u32 *)(rio_regs_win + RIO_PORT1_EDCSR), 0);\r\nout_be32((u32 *)(rio_regs_win + RIO_PORT1_IECSR), IECSR_CLEAR);\r\nout_be32((u32 *)(rio_regs_win + RIO_ESCSR), ESCSR_CLEAR);\r\n} else {\r\nout_be32((u32 *)(rio_regs_win + RIO_PORT2_EDCSR), 0);\r\nout_be32((u32 *)(rio_regs_win + RIO_PORT2_IECSR), IECSR_CLEAR);\r\nout_be32((u32 *)(rio_regs_win + RIO_PORT2_ESCSR), ESCSR_CLEAR);\r\n}\r\n}\r\nstatic inline void fsl_rio_info(struct device *dev, u32 ccsr)\r\n{\r\nconst char *str;\r\nif (ccsr & 1) {\r\nswitch (ccsr >> 30) {\r\ncase 0:\r\nstr = "1";\r\nbreak;\r\ncase 1:\r\nstr = "4";\r\nbreak;\r\ndefault:\r\nstr = "Unknown";\r\nbreak;\r\n}\r\ndev_info(dev, "Hardware port width: %s\n", str);\r\nswitch ((ccsr >> 27) & 7) {\r\ncase 0:\r\nstr = "Single-lane 0";\r\nbreak;\r\ncase 1:\r\nstr = "Single-lane 2";\r\nbreak;\r\ncase 2:\r\nstr = "Four-lane";\r\nbreak;\r\ndefault:\r\nstr = "Unknown";\r\nbreak;\r\n}\r\ndev_info(dev, "Training connection status: %s\n", str);\r\n} else {\r\nif (!(ccsr & 0x80000000))\r\ndev_info(dev, "Output port operating in 8-bit mode\n");\r\nif (!(ccsr & 0x08000000))\r\ndev_info(dev, "Input port operating in 8-bit mode\n");\r\n}\r\n}\r\nint fsl_rio_setup(struct platform_device *dev)\r\n{\r\nstruct rio_ops *ops;\r\nstruct rio_mport *port;\r\nstruct rio_priv *priv;\r\nint rc = 0;\r\nconst u32 *dt_range, *cell, *port_index;\r\nu32 active_ports = 0;\r\nstruct resource regs, rmu_regs;\r\nstruct device_node *np, *rmu_node;\r\nint rlen;\r\nu32 ccsr;\r\nu64 range_start, range_size;\r\nint paw, aw, sw;\r\nu32 i;\r\nstatic int tmp;\r\nstruct device_node *rmu_np[MAX_MSG_UNIT_NUM] = {NULL};\r\nif (!dev->dev.of_node) {\r\ndev_err(&dev->dev, "Device OF-Node is NULL");\r\nreturn -ENODEV;\r\n}\r\nrc = of_address_to_resource(dev->dev.of_node, 0, &regs);\r\nif (rc) {\r\ndev_err(&dev->dev, "Can't get %s property 'reg'\n",\r\ndev->dev.of_node->full_name);\r\nreturn -EFAULT;\r\n}\r\ndev_info(&dev->dev, "Of-device full name %s\n",\r\ndev->dev.of_node->full_name);\r\ndev_info(&dev->dev, "Regs: %pR\n", &regs);\r\nrio_regs_win = ioremap(regs.start, resource_size(&regs));\r\nif (!rio_regs_win) {\r\ndev_err(&dev->dev, "Unable to map rio register window\n");\r\nrc = -ENOMEM;\r\ngoto err_rio_regs;\r\n}\r\nops = kzalloc(sizeof(struct rio_ops), GFP_KERNEL);\r\nif (!ops) {\r\nrc = -ENOMEM;\r\ngoto err_ops;\r\n}\r\nops->lcread = fsl_local_config_read;\r\nops->lcwrite = fsl_local_config_write;\r\nops->cread = fsl_rio_config_read;\r\nops->cwrite = fsl_rio_config_write;\r\nops->dsend = fsl_rio_doorbell_send;\r\nops->pwenable = fsl_rio_pw_enable;\r\nops->open_outb_mbox = fsl_open_outb_mbox;\r\nops->open_inb_mbox = fsl_open_inb_mbox;\r\nops->close_outb_mbox = fsl_close_outb_mbox;\r\nops->close_inb_mbox = fsl_close_inb_mbox;\r\nops->add_outb_message = fsl_add_outb_message;\r\nops->add_inb_buffer = fsl_add_inb_buffer;\r\nops->get_inb_message = fsl_get_inb_message;\r\nrmu_node = of_parse_phandle(dev->dev.of_node, "fsl,srio-rmu-handle", 0);\r\nif (!rmu_node) {\r\ndev_err(&dev->dev, "No valid fsl,srio-rmu-handle property\n");\r\ngoto err_rmu;\r\n}\r\nrc = of_address_to_resource(rmu_node, 0, &rmu_regs);\r\nif (rc) {\r\ndev_err(&dev->dev, "Can't get %s property 'reg'\n",\r\nrmu_node->full_name);\r\ngoto err_rmu;\r\n}\r\nrmu_regs_win = ioremap(rmu_regs.start, resource_size(&rmu_regs));\r\nif (!rmu_regs_win) {\r\ndev_err(&dev->dev, "Unable to map rmu register window\n");\r\nrc = -ENOMEM;\r\ngoto err_rmu;\r\n}\r\nfor_each_compatible_node(np, NULL, "fsl,srio-msg-unit") {\r\nrmu_np[tmp] = np;\r\ntmp++;\r\n}\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,srio-dbell-unit");\r\nif (!np) {\r\ndev_err(&dev->dev, "No fsl,srio-dbell-unit node\n");\r\nrc = -ENODEV;\r\ngoto err_dbell;\r\n}\r\ndbell = kzalloc(sizeof(struct fsl_rio_dbell), GFP_KERNEL);\r\nif (!(dbell)) {\r\ndev_err(&dev->dev, "Can't alloc memory for 'fsl_rio_dbell'\n");\r\nrc = -ENOMEM;\r\ngoto err_dbell;\r\n}\r\ndbell->dev = &dev->dev;\r\ndbell->bellirq = irq_of_parse_and_map(np, 1);\r\ndev_info(&dev->dev, "bellirq: %d\n", dbell->bellirq);\r\naw = of_n_addr_cells(np);\r\ndt_range = of_get_property(np, "reg", &rlen);\r\nif (!dt_range) {\r\npr_err("%s: unable to find 'reg' property\n",\r\nnp->full_name);\r\nrc = -ENOMEM;\r\ngoto err_pw;\r\n}\r\nrange_start = of_read_number(dt_range, aw);\r\ndbell->dbell_regs = (struct rio_dbell_regs *)(rmu_regs_win +\r\n(u32)range_start);\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,srio-port-write-unit");\r\nif (!np) {\r\ndev_err(&dev->dev, "No fsl,srio-port-write-unit node\n");\r\nrc = -ENODEV;\r\ngoto err_pw;\r\n}\r\npw = kzalloc(sizeof(struct fsl_rio_pw), GFP_KERNEL);\r\nif (!(pw)) {\r\ndev_err(&dev->dev, "Can't alloc memory for 'fsl_rio_pw'\n");\r\nrc = -ENOMEM;\r\ngoto err_pw;\r\n}\r\npw->dev = &dev->dev;\r\npw->pwirq = irq_of_parse_and_map(np, 0);\r\ndev_info(&dev->dev, "pwirq: %d\n", pw->pwirq);\r\naw = of_n_addr_cells(np);\r\ndt_range = of_get_property(np, "reg", &rlen);\r\nif (!dt_range) {\r\npr_err("%s: unable to find 'reg' property\n",\r\nnp->full_name);\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nrange_start = of_read_number(dt_range, aw);\r\npw->pw_regs = (struct rio_pw_regs *)(rmu_regs_win + (u32)range_start);\r\nfor_each_child_of_node(dev->dev.of_node, np) {\r\nport_index = of_get_property(np, "cell-index", NULL);\r\nif (!port_index) {\r\ndev_err(&dev->dev, "Can't get %s property 'cell-index'\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\ndt_range = of_get_property(np, "ranges", &rlen);\r\nif (!dt_range) {\r\ndev_err(&dev->dev, "Can't get %s property 'ranges'\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\ncell = of_get_property(np, "#address-cells", NULL);\r\nif (cell)\r\naw = *cell;\r\nelse\r\naw = of_n_addr_cells(np);\r\ncell = of_get_property(np, "#size-cells", NULL);\r\nif (cell)\r\nsw = *cell;\r\nelse\r\nsw = of_n_size_cells(np);\r\npaw = of_n_addr_cells(np);\r\nrange_start = of_read_number(dt_range + aw, paw);\r\nrange_size = of_read_number(dt_range + aw + paw, sw);\r\ndev_info(&dev->dev, "%s: LAW start 0x%016llx, size 0x%016llx.\n",\r\nnp->full_name, range_start, range_size);\r\nport = kzalloc(sizeof(struct rio_mport), GFP_KERNEL);\r\nif (!port)\r\ncontinue;\r\ni = *port_index - 1;\r\nport->index = (unsigned char)i;\r\npriv = kzalloc(sizeof(struct rio_priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&dev->dev, "Can't alloc memory for 'priv'\n");\r\nkfree(port);\r\ncontinue;\r\n}\r\nINIT_LIST_HEAD(&port->dbells);\r\nport->iores.start = range_start;\r\nport->iores.end = port->iores.start + range_size - 1;\r\nport->iores.flags = IORESOURCE_MEM;\r\nport->iores.name = "rio_io_win";\r\nif (request_resource(&iomem_resource, &port->iores) < 0) {\r\ndev_err(&dev->dev, "RIO: Error requesting master port region"\r\n" 0x%016llx-0x%016llx\n",\r\n(u64)port->iores.start, (u64)port->iores.end);\r\nkfree(priv);\r\nkfree(port);\r\ncontinue;\r\n}\r\nsprintf(port->name, "RIO mport %d", i);\r\npriv->dev = &dev->dev;\r\nport->dev.parent = &dev->dev;\r\nport->ops = ops;\r\nport->priv = priv;\r\nport->phys_efptr = 0x100;\r\npriv->regs_win = rio_regs_win;\r\nccsr = in_be32(priv->regs_win + RIO_CCSR + i*0x20);\r\nport->phy_type = (ccsr & 1) ? RIO_PHY_SERIAL : RIO_PHY_PARALLEL;\r\nif (port->phy_type == RIO_PHY_PARALLEL) {\r\ndev_err(&dev->dev, "RIO: Parallel PHY type, unsupported port type!\n");\r\nrelease_resource(&port->iores);\r\nkfree(priv);\r\nkfree(port);\r\ncontinue;\r\n}\r\ndev_info(&dev->dev, "RapidIO PHY type: Serial\n");\r\nif (in_be32((priv->regs_win + RIO_ESCSR + i*0x20)) & 1) {\r\ndev_err(&dev->dev, "Port %d is not ready. "\r\n"Try to restart connection...\n", i);\r\nout_be32(priv->regs_win\r\n+ RIO_CCSR + i*0x20, 0);\r\nsetbits32(priv->regs_win\r\n+ RIO_CCSR + i*0x20, 0x02000000);\r\nsetbits32(priv->regs_win\r\n+ RIO_CCSR + i*0x20, 0x00600000);\r\nmsleep(100);\r\nif (in_be32((priv->regs_win\r\n+ RIO_ESCSR + i*0x20)) & 1) {\r\ndev_err(&dev->dev,\r\n"Port %d restart failed.\n", i);\r\nrelease_resource(&port->iores);\r\nkfree(priv);\r\nkfree(port);\r\ncontinue;\r\n}\r\ndev_info(&dev->dev, "Port %d restart success!\n", i);\r\n}\r\nfsl_rio_info(&dev->dev, ccsr);\r\nport->sys_size = (in_be32((priv->regs_win + RIO_PEF_CAR))\r\n& RIO_PEF_CTLS) >> 4;\r\ndev_info(&dev->dev, "RapidIO Common Transport System size: %d\n",\r\nport->sys_size ? 65536 : 256);\r\nif (rio_register_mport(port)) {\r\nrelease_resource(&port->iores);\r\nkfree(priv);\r\nkfree(port);\r\ncontinue;\r\n}\r\nif (port->host_deviceid >= 0)\r\nout_be32(priv->regs_win + RIO_GCCSR, RIO_PORT_GEN_HOST |\r\nRIO_PORT_GEN_MASTER | RIO_PORT_GEN_DISCOVERED);\r\nelse\r\nout_be32(priv->regs_win + RIO_GCCSR,\r\nRIO_PORT_GEN_MASTER);\r\npriv->atmu_regs = (struct rio_atmu_regs *)(priv->regs_win\r\n+ ((i == 0) ? RIO_ATMU_REGS_PORT1_OFFSET :\r\nRIO_ATMU_REGS_PORT2_OFFSET));\r\npriv->maint_atmu_regs = priv->atmu_regs + 1;\r\nif (port->phy_type == RIO_PHY_SERIAL)\r\nout_be32((priv->regs_win\r\n+ RIO_ISR_AACR + i*0x80), RIO_ISR_AACR_AA);\r\nout_be32(&priv->maint_atmu_regs->rowbar,\r\nport->iores.start >> 12);\r\nout_be32(&priv->maint_atmu_regs->rowar,\r\n0x80077000 | (ilog2(RIO_MAINT_WIN_SIZE) - 1));\r\npriv->maint_win = ioremap(port->iores.start,\r\nRIO_MAINT_WIN_SIZE);\r\nrio_law_start = range_start;\r\nfsl_rio_setup_rmu(port, rmu_np[i]);\r\ndbell->mport[i] = port;\r\nactive_ports++;\r\n}\r\nif (!active_ports) {\r\nrc = -ENOLINK;\r\ngoto err;\r\n}\r\nfsl_rio_doorbell_init(dbell);\r\nfsl_rio_port_write_init(pw);\r\nreturn 0;\r\nerr:\r\nkfree(pw);\r\npw = NULL;\r\nerr_pw:\r\nkfree(dbell);\r\ndbell = NULL;\r\nerr_dbell:\r\niounmap(rmu_regs_win);\r\nrmu_regs_win = NULL;\r\nerr_rmu:\r\nkfree(ops);\r\nerr_ops:\r\niounmap(rio_regs_win);\r\nrio_regs_win = NULL;\r\nerr_rio_regs:\r\nreturn rc;\r\n}\r\nstatic int fsl_of_rio_rpn_probe(struct platform_device *dev)\r\n{\r\nprintk(KERN_INFO "Setting up RapidIO peer-to-peer network %s\n",\r\ndev->dev.of_node->full_name);\r\nreturn fsl_rio_setup(dev);\r\n}\r\nstatic __init int fsl_of_rio_rpn_init(void)\r\n{\r\nreturn platform_driver_register(&fsl_of_rio_rpn_driver);\r\n}
