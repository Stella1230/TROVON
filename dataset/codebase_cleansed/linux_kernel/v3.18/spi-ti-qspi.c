static inline unsigned long ti_qspi_read(struct ti_qspi *qspi,\r\nunsigned long reg)\r\n{\r\nreturn readl(qspi->base + reg);\r\n}\r\nstatic inline void ti_qspi_write(struct ti_qspi *qspi,\r\nunsigned long val, unsigned long reg)\r\n{\r\nwritel(val, qspi->base + reg);\r\n}\r\nstatic int ti_qspi_setup(struct spi_device *spi)\r\n{\r\nstruct ti_qspi *qspi = spi_master_get_devdata(spi->master);\r\nstruct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;\r\nint clk_div = 0, ret;\r\nu32 clk_ctrl_reg, clk_rate, clk_mask;\r\nif (spi->master->busy) {\r\ndev_dbg(qspi->dev, "master busy doing other trasnfers\n");\r\nreturn -EBUSY;\r\n}\r\nif (!qspi->spi_max_frequency) {\r\ndev_err(qspi->dev, "spi max frequency not defined\n");\r\nreturn -EINVAL;\r\n}\r\nclk_rate = clk_get_rate(qspi->fclk);\r\nclk_div = DIV_ROUND_UP(clk_rate, qspi->spi_max_frequency) - 1;\r\nif (clk_div < 0) {\r\ndev_dbg(qspi->dev, "clock divider < 0, using /1 divider\n");\r\nreturn -EINVAL;\r\n}\r\nif (clk_div > QSPI_CLK_DIV_MAX) {\r\ndev_dbg(qspi->dev, "clock divider >%d , using /%d divider\n",\r\nQSPI_CLK_DIV_MAX, QSPI_CLK_DIV_MAX + 1);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(qspi->dev, "hz: %d, clock divider %d\n",\r\nqspi->spi_max_frequency, clk_div);\r\nret = pm_runtime_get_sync(qspi->dev);\r\nif (ret < 0) {\r\ndev_err(qspi->dev, "pm_runtime_get_sync() failed\n");\r\nreturn ret;\r\n}\r\nclk_ctrl_reg = ti_qspi_read(qspi, QSPI_SPI_CLOCK_CNTRL_REG);\r\nclk_ctrl_reg &= ~QSPI_CLK_EN;\r\nti_qspi_write(qspi, clk_ctrl_reg, QSPI_SPI_CLOCK_CNTRL_REG);\r\nclk_mask = QSPI_CLK_EN | clk_div;\r\nti_qspi_write(qspi, clk_mask, QSPI_SPI_CLOCK_CNTRL_REG);\r\nctx_reg->clkctrl = clk_mask;\r\npm_runtime_mark_last_busy(qspi->dev);\r\nret = pm_runtime_put_autosuspend(qspi->dev);\r\nif (ret < 0) {\r\ndev_err(qspi->dev, "pm_runtime_put_autosuspend() failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ti_qspi_restore_ctx(struct ti_qspi *qspi)\r\n{\r\nstruct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;\r\nti_qspi_write(qspi, ctx_reg->clkctrl, QSPI_SPI_CLOCK_CNTRL_REG);\r\n}\r\nstatic int qspi_write_msg(struct ti_qspi *qspi, struct spi_transfer *t)\r\n{\r\nint wlen, count, ret;\r\nunsigned int cmd;\r\nconst u8 *txbuf;\r\ntxbuf = t->tx_buf;\r\ncmd = qspi->cmd | QSPI_WR_SNGL;\r\ncount = t->len;\r\nwlen = t->bits_per_word >> 3;\r\nwhile (count) {\r\nswitch (wlen) {\r\ncase 1:\r\ndev_dbg(qspi->dev, "tx cmd %08x dc %08x data %02x\n",\r\ncmd, qspi->dc, *txbuf);\r\nwriteb(*txbuf, qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\ncase 2:\r\ndev_dbg(qspi->dev, "tx cmd %08x dc %08x data %04x\n",\r\ncmd, qspi->dc, *txbuf);\r\nwritew(*((u16 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\ncase 4:\r\ndev_dbg(qspi->dev, "tx cmd %08x dc %08x data %08x\n",\r\ncmd, qspi->dc, *txbuf);\r\nwritel(*((u32 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\n}\r\nti_qspi_write(qspi, cmd, QSPI_SPI_CMD_REG);\r\nret = wait_for_completion_timeout(&qspi->transfer_complete,\r\nQSPI_COMPLETION_TIMEOUT);\r\nif (ret == 0) {\r\ndev_err(qspi->dev, "write timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ntxbuf += wlen;\r\ncount -= wlen;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qspi_read_msg(struct ti_qspi *qspi, struct spi_transfer *t)\r\n{\r\nint wlen, count, ret;\r\nunsigned int cmd;\r\nu8 *rxbuf;\r\nrxbuf = t->rx_buf;\r\ncmd = qspi->cmd;\r\nswitch (t->rx_nbits) {\r\ncase SPI_NBITS_DUAL:\r\ncmd |= QSPI_RD_DUAL;\r\nbreak;\r\ncase SPI_NBITS_QUAD:\r\ncmd |= QSPI_RD_QUAD;\r\nbreak;\r\ndefault:\r\ncmd |= QSPI_RD_SNGL;\r\nbreak;\r\n}\r\ncount = t->len;\r\nwlen = t->bits_per_word >> 3;\r\nwhile (count) {\r\ndev_dbg(qspi->dev, "rx cmd %08x dc %08x\n", cmd, qspi->dc);\r\nti_qspi_write(qspi, cmd, QSPI_SPI_CMD_REG);\r\nret = wait_for_completion_timeout(&qspi->transfer_complete,\r\nQSPI_COMPLETION_TIMEOUT);\r\nif (ret == 0) {\r\ndev_err(qspi->dev, "read timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nswitch (wlen) {\r\ncase 1:\r\n*rxbuf = readb(qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\ncase 2:\r\n*((u16 *)rxbuf) = readw(qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\ncase 4:\r\n*((u32 *)rxbuf) = readl(qspi->base + QSPI_SPI_DATA_REG);\r\nbreak;\r\n}\r\nrxbuf += wlen;\r\ncount -= wlen;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qspi_transfer_msg(struct ti_qspi *qspi, struct spi_transfer *t)\r\n{\r\nint ret;\r\nif (t->tx_buf) {\r\nret = qspi_write_msg(qspi, t);\r\nif (ret) {\r\ndev_dbg(qspi->dev, "Error while writing\n");\r\nreturn ret;\r\n}\r\n}\r\nif (t->rx_buf) {\r\nret = qspi_read_msg(qspi, t);\r\nif (ret) {\r\ndev_dbg(qspi->dev, "Error while reading\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_qspi_start_transfer_one(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct ti_qspi *qspi = spi_master_get_devdata(master);\r\nstruct spi_device *spi = m->spi;\r\nstruct spi_transfer *t;\r\nint status = 0, ret;\r\nint frame_length;\r\nqspi->dc = 0;\r\nif (spi->mode & SPI_CPHA)\r\nqspi->dc |= QSPI_CKPHA(spi->chip_select);\r\nif (spi->mode & SPI_CPOL)\r\nqspi->dc |= QSPI_CKPOL(spi->chip_select);\r\nif (spi->mode & SPI_CS_HIGH)\r\nqspi->dc |= QSPI_CSPOL(spi->chip_select);\r\nframe_length = (m->frame_length << 3) / spi->bits_per_word;\r\nframe_length = clamp(frame_length, 0, QSPI_FRAME);\r\nqspi->cmd = 0;\r\nqspi->cmd |= QSPI_EN_CS(spi->chip_select);\r\nqspi->cmd |= QSPI_FLEN(frame_length);\r\nqspi->cmd |= QSPI_WC_CMD_INT_EN;\r\nti_qspi_write(qspi, QSPI_WC_INT_EN, QSPI_INTR_ENABLE_SET_REG);\r\nti_qspi_write(qspi, qspi->dc, QSPI_SPI_DC_REG);\r\nmutex_lock(&qspi->list_lock);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nqspi->cmd |= QSPI_WLEN(t->bits_per_word);\r\nret = qspi_transfer_msg(qspi, t);\r\nif (ret) {\r\ndev_dbg(qspi->dev, "transfer message failed\n");\r\nmutex_unlock(&qspi->list_lock);\r\nreturn -EINVAL;\r\n}\r\nm->actual_length += t->len;\r\n}\r\nmutex_unlock(&qspi->list_lock);\r\nm->status = status;\r\nspi_finalize_current_message(master);\r\nti_qspi_write(qspi, qspi->cmd | QSPI_INVAL, QSPI_SPI_CMD_REG);\r\nreturn status;\r\n}\r\nstatic irqreturn_t ti_qspi_isr(int irq, void *dev_id)\r\n{\r\nstruct ti_qspi *qspi = dev_id;\r\nu16 int_stat;\r\nu32 stat;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nint_stat = ti_qspi_read(qspi, QSPI_INTR_STATUS_ENABLED_CLEAR);\r\nstat = ti_qspi_read(qspi, QSPI_SPI_STATUS_REG);\r\nif (!int_stat) {\r\ndev_dbg(qspi->dev, "No IRQ triggered\n");\r\nret = IRQ_NONE;\r\ngoto out;\r\n}\r\nti_qspi_write(qspi, QSPI_WC_INT_DISABLE,\r\nQSPI_INTR_STATUS_ENABLED_CLEAR);\r\nif (stat & WC)\r\ncomplete(&qspi->transfer_complete);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ti_qspi_runtime_resume(struct device *dev)\r\n{\r\nstruct ti_qspi *qspi;\r\nqspi = dev_get_drvdata(dev);\r\nti_qspi_restore_ctx(qspi);\r\nreturn 0;\r\n}\r\nstatic int ti_qspi_probe(struct platform_device *pdev)\r\n{\r\nstruct ti_qspi *qspi;\r\nstruct spi_master *master;\r\nstruct resource *r, *res_ctrl, *res_mmap;\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 max_freq;\r\nint ret = 0, num_cs, irq;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*qspi));\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_RX_DUAL | SPI_RX_QUAD;\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nmaster->setup = ti_qspi_setup;\r\nmaster->auto_runtime_pm = true;\r\nmaster->transfer_one_message = ti_qspi_start_transfer_one;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |\r\nSPI_BPW_MASK(8);\r\nif (!of_property_read_u32(np, "num-cs", &num_cs))\r\nmaster->num_chipselect = num_cs;\r\nqspi = spi_master_get_devdata(master);\r\nqspi->master = master;\r\nqspi->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, qspi);\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qspi_base");\r\nif (r == NULL) {\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nres_mmap = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM, "qspi_mmap");\r\nif (res_mmap == NULL) {\r\nres_mmap = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res_mmap == NULL) {\r\ndev_err(&pdev->dev,\r\n"memory mapped resource not required\n");\r\n}\r\n}\r\nres_ctrl = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM, "qspi_ctrlmod");\r\nif (res_ctrl == NULL) {\r\nres_ctrl = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (res_ctrl == NULL) {\r\ndev_dbg(&pdev->dev,\r\n"control module resources not required\n");\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\nmutex_init(&qspi->list_lock);\r\nqspi->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(qspi->base)) {\r\nret = PTR_ERR(qspi->base);\r\ngoto free_master;\r\n}\r\nif (res_ctrl) {\r\nqspi->ctrl_mod = true;\r\nqspi->ctrl_base = devm_ioremap_resource(&pdev->dev, res_ctrl);\r\nif (IS_ERR(qspi->ctrl_base)) {\r\nret = PTR_ERR(qspi->ctrl_base);\r\ngoto free_master;\r\n}\r\n}\r\nif (res_mmap) {\r\nqspi->mmap_base = devm_ioremap_resource(&pdev->dev, res_mmap);\r\nif (IS_ERR(qspi->mmap_base)) {\r\nret = PTR_ERR(qspi->mmap_base);\r\ngoto free_master;\r\n}\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, ti_qspi_isr, 0,\r\ndev_name(&pdev->dev), qspi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",\r\nirq);\r\ngoto free_master;\r\n}\r\nqspi->fclk = devm_clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(qspi->fclk)) {\r\nret = PTR_ERR(qspi->fclk);\r\ndev_err(&pdev->dev, "could not get clk: %d\n", ret);\r\n}\r\ninit_completion(&qspi->transfer_complete);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, QSPI_AUTOSUSPEND_TIMEOUT);\r\npm_runtime_enable(&pdev->dev);\r\nif (!of_property_read_u32(np, "spi-max-frequency", &max_freq))\r\nqspi->spi_max_frequency = max_freq;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret)\r\ngoto free_master;\r\nreturn 0;\r\nfree_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int ti_qspi_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_qspi *qspi = platform_get_drvdata(pdev);\r\nint ret;\r\nret = pm_runtime_get_sync(qspi->dev);\r\nif (ret < 0) {\r\ndev_err(qspi->dev, "pm_runtime_get_sync() failed\n");\r\nreturn ret;\r\n}\r\nti_qspi_write(qspi, QSPI_WC_INT_DISABLE, QSPI_INTR_ENABLE_CLEAR_REG);\r\npm_runtime_put(qspi->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
