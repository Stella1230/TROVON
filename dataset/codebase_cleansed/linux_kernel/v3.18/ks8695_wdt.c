static inline void ks8695_wdt_stop(void)\r\n{\r\nunsigned long tmcon;\r\nspin_lock(&ks8695_lock);\r\ntmcon = __raw_readl(KS8695_TMR_VA + KS8695_TMCON);\r\n__raw_writel(tmcon & ~TMCON_T0EN, KS8695_TMR_VA + KS8695_TMCON);\r\nspin_unlock(&ks8695_lock);\r\n}\r\nstatic inline void ks8695_wdt_start(void)\r\n{\r\nunsigned long tmcon;\r\nunsigned long tval = wdt_time * KS8695_CLOCK_RATE;\r\nspin_lock(&ks8695_lock);\r\ntmcon = __raw_readl(KS8695_TMR_VA + KS8695_TMCON);\r\n__raw_writel(tmcon & ~TMCON_T0EN, KS8695_TMR_VA + KS8695_TMCON);\r\n__raw_writel(tval | T0TC_WATCHDOG, KS8695_TMR_VA + KS8695_T0TC);\r\ntmcon = __raw_readl(KS8695_TMR_VA + KS8695_TMCON);\r\n__raw_writel(tmcon | TMCON_T0EN, KS8695_TMR_VA + KS8695_TMCON);\r\nspin_unlock(&ks8695_lock);\r\n}\r\nstatic inline void ks8695_wdt_reload(void)\r\n{\r\nunsigned long tmcon;\r\nspin_lock(&ks8695_lock);\r\ntmcon = __raw_readl(KS8695_TMR_VA + KS8695_TMCON);\r\n__raw_writel(tmcon & ~TMCON_T0EN, KS8695_TMR_VA + KS8695_TMCON);\r\n__raw_writel(tmcon | TMCON_T0EN, KS8695_TMR_VA + KS8695_TMCON);\r\nspin_unlock(&ks8695_lock);\r\n}\r\nstatic int ks8695_wdt_settimeout(int new_time)\r\n{\r\nif ((new_time <= 0) || (new_time > WDT_MAX_TIME))\r\nreturn -EINVAL;\r\nwdt_time = new_time;\r\nreturn 0;\r\n}\r\nstatic int ks8695_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &ks8695wdt_busy))\r\nreturn -EBUSY;\r\nks8695_wdt_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int ks8695_wdt_close(struct inode *inode, struct file *file)\r\n{\r\nif (!nowayout)\r\nks8695_wdt_stop();\r\nclear_bit(0, &ks8695wdt_busy);\r\nreturn 0;\r\n}\r\nstatic long ks8695_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint new_value;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ks8695_wdt_info,\r\nsizeof(ks8695_wdt_info)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(new_value, p))\r\nreturn -EFAULT;\r\nif (new_value & WDIOS_DISABLECARD)\r\nks8695_wdt_stop();\r\nif (new_value & WDIOS_ENABLECARD)\r\nks8695_wdt_start();\r\nreturn 0;\r\ncase WDIOC_KEEPALIVE:\r\nks8695_wdt_reload();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_value, p))\r\nreturn -EFAULT;\r\nif (ks8695_wdt_settimeout(new_value))\r\nreturn -EINVAL;\r\nks8695_wdt_start();\r\nreturn put_user(wdt_time, p);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(wdt_time, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic ssize_t ks8695_wdt_write(struct file *file, const char *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nks8695_wdt_reload();\r\nreturn len;\r\n}\r\nstatic int ks8695wdt_probe(struct platform_device *pdev)\r\n{\r\nint res;\r\nif (ks8695wdt_miscdev.parent)\r\nreturn -EBUSY;\r\nks8695wdt_miscdev.parent = &pdev->dev;\r\nres = misc_register(&ks8695wdt_miscdev);\r\nif (res)\r\nreturn res;\r\npr_info("KS8695 Watchdog Timer enabled (%d seconds%s)\n",\r\nwdt_time, nowayout ? ", nowayout" : "");\r\nreturn 0;\r\n}\r\nstatic int ks8695wdt_remove(struct platform_device *pdev)\r\n{\r\nint res;\r\nres = misc_deregister(&ks8695wdt_miscdev);\r\nif (!res)\r\nks8695wdt_miscdev.parent = NULL;\r\nreturn res;\r\n}\r\nstatic void ks8695wdt_shutdown(struct platform_device *pdev)\r\n{\r\nks8695_wdt_stop();\r\n}\r\nstatic int ks8695wdt_suspend(struct platform_device *pdev, pm_message_t message)\r\n{\r\nks8695_wdt_stop();\r\nreturn 0;\r\n}\r\nstatic int ks8695wdt_resume(struct platform_device *pdev)\r\n{\r\nif (ks8695wdt_busy)\r\nks8695_wdt_start();\r\nreturn 0;\r\n}\r\nstatic int __init ks8695_wdt_init(void)\r\n{\r\nif (ks8695_wdt_settimeout(wdt_time)) {\r\nks8695_wdt_settimeout(WDT_DEFAULT_TIME);\r\npr_info("ks8695_wdt: wdt_time value must be 1 <= wdt_time <= %i"\r\n", using %d\n", wdt_time, WDT_MAX_TIME);\r\n}\r\nreturn platform_driver_register(&ks8695wdt_driver);\r\n}\r\nstatic void __exit ks8695_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&ks8695wdt_driver);\r\n}
