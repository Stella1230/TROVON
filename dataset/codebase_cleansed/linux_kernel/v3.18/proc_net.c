static inline struct net *PDE_NET(struct proc_dir_entry *pde)\r\n{\r\nreturn pde->parent->data;\r\n}\r\nstatic struct net *get_proc_net(const struct inode *inode)\r\n{\r\nreturn maybe_get_net(PDE_NET(PDE(inode)));\r\n}\r\nint seq_open_net(struct inode *ino, struct file *f,\r\nconst struct seq_operations *ops, int size)\r\n{\r\nstruct net *net;\r\nstruct seq_net_private *p;\r\nBUG_ON(size < sizeof(*p));\r\nnet = get_proc_net(ino);\r\nif (net == NULL)\r\nreturn -ENXIO;\r\np = __seq_open_private(f, ops, size);\r\nif (p == NULL) {\r\nput_net(net);\r\nreturn -ENOMEM;\r\n}\r\n#ifdef CONFIG_NET_NS\r\np->net = net;\r\n#endif\r\nreturn 0;\r\n}\r\nint single_open_net(struct inode *inode, struct file *file,\r\nint (*show)(struct seq_file *, void *))\r\n{\r\nint err;\r\nstruct net *net;\r\nerr = -ENXIO;\r\nnet = get_proc_net(inode);\r\nif (net == NULL)\r\ngoto err_net;\r\nerr = single_open(file, show, net);\r\nif (err < 0)\r\ngoto err_open;\r\nreturn 0;\r\nerr_open:\r\nput_net(net);\r\nerr_net:\r\nreturn err;\r\n}\r\nint seq_release_net(struct inode *ino, struct file *f)\r\n{\r\nstruct seq_file *seq;\r\nseq = f->private_data;\r\nput_net(seq_file_net(seq));\r\nseq_release_private(ino, f);\r\nreturn 0;\r\n}\r\nint single_release_net(struct inode *ino, struct file *f)\r\n{\r\nstruct seq_file *seq = f->private_data;\r\nput_net(seq->private);\r\nreturn single_release(ino, f);\r\n}\r\nstatic struct net *get_proc_task_net(struct inode *dir)\r\n{\r\nstruct task_struct *task;\r\nstruct nsproxy *ns;\r\nstruct net *net = NULL;\r\nrcu_read_lock();\r\ntask = pid_task(proc_pid(dir), PIDTYPE_PID);\r\nif (task != NULL) {\r\ntask_lock(task);\r\nns = task->nsproxy;\r\nif (ns != NULL)\r\nnet = get_net(ns->net_ns);\r\ntask_unlock(task);\r\n}\r\nrcu_read_unlock();\r\nreturn net;\r\n}\r\nstatic struct dentry *proc_tgid_net_lookup(struct inode *dir,\r\nstruct dentry *dentry, unsigned int flags)\r\n{\r\nstruct dentry *de;\r\nstruct net *net;\r\nde = ERR_PTR(-ENOENT);\r\nnet = get_proc_task_net(dir);\r\nif (net != NULL) {\r\nde = proc_lookup_de(net->proc_net, dir, dentry);\r\nput_net(net);\r\n}\r\nreturn de;\r\n}\r\nstatic int proc_tgid_net_getattr(struct vfsmount *mnt, struct dentry *dentry,\r\nstruct kstat *stat)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct net *net;\r\nnet = get_proc_task_net(inode);\r\ngeneric_fillattr(inode, stat);\r\nif (net != NULL) {\r\nstat->nlink = net->proc_net->nlink;\r\nput_net(net);\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_tgid_net_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nint ret;\r\nstruct net *net;\r\nret = -EINVAL;\r\nnet = get_proc_task_net(file_inode(file));\r\nif (net != NULL) {\r\nret = proc_readdir_de(net->proc_net, file, ctx);\r\nput_net(net);\r\n}\r\nreturn ret;\r\n}\r\nstatic __net_init int proc_net_ns_init(struct net *net)\r\n{\r\nstruct proc_dir_entry *netd, *net_statd;\r\nint err;\r\nerr = -ENOMEM;\r\nnetd = kzalloc(sizeof(*netd) + 4, GFP_KERNEL);\r\nif (!netd)\r\ngoto out;\r\nnetd->data = net;\r\nnetd->nlink = 2;\r\nnetd->namelen = 3;\r\nnetd->parent = &proc_root;\r\nmemcpy(netd->name, "net", 4);\r\nerr = -EEXIST;\r\nnet_statd = proc_net_mkdir(net, "stat", netd);\r\nif (!net_statd)\r\ngoto free_net;\r\nnet->proc_net = netd;\r\nnet->proc_net_stat = net_statd;\r\nreturn 0;\r\nfree_net:\r\nkfree(netd);\r\nout:\r\nreturn err;\r\n}\r\nstatic __net_exit void proc_net_ns_exit(struct net *net)\r\n{\r\nremove_proc_entry("stat", net->proc_net);\r\nkfree(net->proc_net);\r\n}\r\nint __init proc_net_init(void)\r\n{\r\nproc_symlink("net", NULL, "self/net");\r\nreturn register_pernet_subsys(&proc_net_ns_ops);\r\n}
