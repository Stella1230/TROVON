static const uint32_t *sti_gdp_get_formats(struct sti_layer *layer)\r\n{\r\nreturn gdp_supported_formats;\r\n}\r\nstatic unsigned int sti_gdp_get_nb_formats(struct sti_layer *layer)\r\n{\r\nreturn ARRAY_SIZE(gdp_supported_formats);\r\n}\r\nstatic int sti_gdp_fourcc2format(int fourcc)\r\n{\r\nswitch (fourcc) {\r\ncase DRM_FORMAT_XRGB8888:\r\nreturn GDP_RGB888_32;\r\ncase DRM_FORMAT_ARGB8888:\r\nreturn GDP_ARGB8888;\r\ncase DRM_FORMAT_ARGB4444:\r\nreturn GDP_ARGB4444;\r\ncase DRM_FORMAT_ARGB1555:\r\nreturn GDP_ARGB1555;\r\ncase DRM_FORMAT_RGB565:\r\nreturn GDP_RGB565;\r\ncase DRM_FORMAT_RGB888:\r\nreturn GDP_RGB888;\r\ncase DRM_FORMAT_AYUV:\r\nreturn GDP_AYCBR8888;\r\ncase DRM_FORMAT_YUV444:\r\nreturn GDP_YCBR888;\r\ncase DRM_FORMAT_VYUY:\r\nreturn GDP_YCBR422R;\r\ncase DRM_FORMAT_C8:\r\nreturn GDP_CLUT8;\r\n}\r\nreturn -1;\r\n}\r\nstatic int sti_gdp_get_alpharange(int format)\r\n{\r\nswitch (format) {\r\ncase GDP_ARGB8565:\r\ncase GDP_ARGB8888:\r\ncase GDP_AYCBR8888:\r\nreturn GAM_GDP_ALPHARANGE_255;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sti_gdp_node_list *sti_gdp_get_free_nodes(struct sti_layer *layer)\r\n{\r\nint hw_nvn;\r\nvoid *virt_nvn;\r\nstruct sti_gdp *gdp = to_sti_gdp(layer);\r\nunsigned int i;\r\nhw_nvn = readl(layer->regs + GAM_GDP_NVN_OFFSET);\r\nif (!hw_nvn)\r\ngoto end;\r\nvirt_nvn = dma_to_virt(layer->dev, (dma_addr_t) hw_nvn);\r\nfor (i = 0; i < GDP_NODE_NB_BANK; i++)\r\nif ((virt_nvn != gdp->node_list[i].btm_field) &&\r\n(virt_nvn != gdp->node_list[i].top_field))\r\nreturn &gdp->node_list[i];\r\nDRM_ERROR("inconsistent NVN for %s: 0x%08X\n",\r\nsti_layer_to_str(layer), hw_nvn);\r\nend:\r\nreturn &gdp->node_list[0];\r\n}\r\nstatic\r\nstruct sti_gdp_node_list *sti_gdp_get_current_nodes(struct sti_layer *layer)\r\n{\r\nint hw_nvn;\r\nvoid *virt_nvn;\r\nstruct sti_gdp *gdp = to_sti_gdp(layer);\r\nunsigned int i;\r\nhw_nvn = readl(layer->regs + GAM_GDP_NVN_OFFSET);\r\nif (!hw_nvn)\r\ngoto end;\r\nvirt_nvn = dma_to_virt(layer->dev, (dma_addr_t) hw_nvn);\r\nfor (i = 0; i < GDP_NODE_NB_BANK; i++)\r\nif ((virt_nvn == gdp->node_list[i].btm_field) ||\r\n(virt_nvn == gdp->node_list[i].top_field))\r\nreturn &gdp->node_list[i];\r\nend:\r\nDRM_DEBUG_DRIVER("Warning, NVN 0x%08X for %s does not match any node\n",\r\nhw_nvn, sti_layer_to_str(layer));\r\nreturn NULL;\r\n}\r\nstatic int sti_gdp_prepare_layer(struct sti_layer *layer, bool first_prepare)\r\n{\r\nstruct sti_gdp_node_list *list;\r\nstruct sti_gdp_node *top_field, *btm_field;\r\nstruct drm_display_mode *mode = layer->mode;\r\nstruct device *dev = layer->dev;\r\nstruct sti_gdp *gdp = to_sti_gdp(layer);\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nint format;\r\nunsigned int depth, bpp;\r\nint rate = mode->clock * 1000;\r\nint res;\r\nu32 ydo, xdo, yds, xds;\r\nlist = sti_gdp_get_free_nodes(layer);\r\ntop_field = list->top_field;\r\nbtm_field = list->btm_field;\r\ndev_dbg(dev, "%s %s top_node:0x%p btm_node:0x%p\n", __func__,\r\nsti_layer_to_str(layer), top_field, btm_field);\r\ntop_field->gam_gdp_agc = GAM_GDP_AGC_FULL_RANGE;\r\ntop_field->gam_gdp_ctl = WAIT_NEXT_VSYNC;\r\nformat = sti_gdp_fourcc2format(layer->format);\r\nif (format == -1) {\r\nDRM_ERROR("Format not supported by GDP %.4s\n",\r\n(char *)&layer->format);\r\nreturn 1;\r\n}\r\ntop_field->gam_gdp_ctl |= format;\r\ntop_field->gam_gdp_ctl |= sti_gdp_get_alpharange(format);\r\ntop_field->gam_gdp_ppt &= ~GAM_GDP_PPT_IGNORE;\r\ndrm_fb_get_bpp_depth(layer->format, &depth, &bpp);\r\ntop_field->gam_gdp_pml = (u32) layer->paddr + layer->offsets[0];\r\ntop_field->gam_gdp_pml += layer->src_x * (bpp >> 3);\r\ntop_field->gam_gdp_pml += layer->src_y * layer->pitches[0];\r\ntop_field->gam_gdp_pmp = layer->pitches[0];\r\ntop_field->gam_gdp_size =\r\nclamp_val(layer->src_h, 0, GAM_GDP_SIZE_MAX) << 16 |\r\nclamp_val(layer->src_w, 0, GAM_GDP_SIZE_MAX);\r\nydo = sti_vtg_get_line_number(*mode, layer->dst_y);\r\nyds = sti_vtg_get_line_number(*mode, layer->dst_y + layer->dst_h - 1);\r\nxdo = sti_vtg_get_pixel_number(*mode, layer->dst_x);\r\nxds = sti_vtg_get_pixel_number(*mode, layer->dst_x + layer->dst_w - 1);\r\ntop_field->gam_gdp_vpo = (ydo << 16) | xdo;\r\ntop_field->gam_gdp_vps = (yds << 16) | xds;\r\nmemcpy(btm_field, top_field, sizeof(*btm_field));\r\ntop_field->gam_gdp_nvn = virt_to_dma(dev, btm_field);\r\nbtm_field->gam_gdp_nvn = virt_to_dma(dev, top_field);\r\nif (layer->mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nbtm_field->gam_gdp_pml = top_field->gam_gdp_pml +\r\nlayer->pitches[0];\r\nif (first_prepare) {\r\nif (sti_vtg_register_client(layer->mixer_id == STI_MIXER_MAIN ?\r\ncompo->vtg_main : compo->vtg_aux,\r\n&gdp->vtg_field_nb, layer->mixer_id)) {\r\nDRM_ERROR("Cannot register VTG notifier\n");\r\nreturn 1;\r\n}\r\nif (gdp->clk_pix) {\r\nres = clk_set_rate(gdp->clk_pix, rate);\r\nif (res < 0) {\r\nDRM_ERROR("Cannot set rate (%dHz) for gdp\n",\r\nrate);\r\nreturn 1;\r\n}\r\nif (clk_prepare_enable(gdp->clk_pix)) {\r\nDRM_ERROR("Failed to prepare/enable gdp\n");\r\nreturn 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_gdp_commit_layer(struct sti_layer *layer)\r\n{\r\nstruct sti_gdp_node_list *updated_list = sti_gdp_get_free_nodes(layer);\r\nstruct sti_gdp_node *updated_top_node = updated_list->top_field;\r\nstruct sti_gdp_node *updated_btm_node = updated_list->btm_field;\r\nstruct sti_gdp *gdp = to_sti_gdp(layer);\r\nu32 dma_updated_top = virt_to_dma(layer->dev, updated_top_node);\r\nu32 dma_updated_btm = virt_to_dma(layer->dev, updated_btm_node);\r\nstruct sti_gdp_node_list *curr_list = sti_gdp_get_current_nodes(layer);\r\ndev_dbg(layer->dev, "%s %s top/btm_node:0x%p/0x%p\n", __func__,\r\nsti_layer_to_str(layer),\r\nupdated_top_node, updated_btm_node);\r\ndev_dbg(layer->dev, "Current NVN:0x%X\n",\r\nreadl(layer->regs + GAM_GDP_NVN_OFFSET));\r\ndev_dbg(layer->dev, "Posted buff: %lx current buff: %x\n",\r\n(unsigned long)layer->paddr,\r\nreadl(layer->regs + GAM_GDP_PML_OFFSET));\r\nif (curr_list == NULL) {\r\nDRM_DEBUG_DRIVER("%s first update (or invalid node)",\r\nsti_layer_to_str(layer));\r\nwritel(gdp->is_curr_top == true ?\r\ndma_updated_btm : dma_updated_top,\r\nlayer->regs + GAM_GDP_NVN_OFFSET);\r\nreturn 0;\r\n}\r\nif (layer->mode->flags & DRM_MODE_FLAG_INTERLACE) {\r\nif (gdp->is_curr_top == true) {\r\ncurr_list->btm_field->gam_gdp_nvn = dma_updated_top;\r\n} else {\r\nwritel(dma_updated_top,\r\nlayer->regs + GAM_GDP_NVN_OFFSET);\r\n}\r\n} else {\r\nwritel(dma_updated_top, layer->regs + GAM_GDP_NVN_OFFSET);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_gdp_disable_layer(struct sti_layer *layer)\r\n{\r\nunsigned int i;\r\nstruct sti_gdp *gdp = to_sti_gdp(layer);\r\nstruct sti_compositor *compo = dev_get_drvdata(layer->dev);\r\nDRM_DEBUG_DRIVER("%s\n", sti_layer_to_str(layer));\r\nfor (i = 0; i < GDP_NODE_NB_BANK; i++) {\r\ngdp->node_list[i].top_field->gam_gdp_ppt |= GAM_GDP_PPT_IGNORE;\r\ngdp->node_list[i].btm_field->gam_gdp_ppt |= GAM_GDP_PPT_IGNORE;\r\n}\r\nif (sti_vtg_unregister_client(layer->mixer_id == STI_MIXER_MAIN ?\r\ncompo->vtg_main : compo->vtg_aux, &gdp->vtg_field_nb))\r\nDRM_DEBUG_DRIVER("Warning: cannot unregister VTG notifier\n");\r\nif (gdp->clk_pix)\r\nclk_disable_unprepare(gdp->clk_pix);\r\nreturn 0;\r\n}\r\nint sti_gdp_field_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct sti_gdp *gdp = container_of(nb, struct sti_gdp, vtg_field_nb);\r\nswitch (event) {\r\ncase VTG_TOP_FIELD_EVENT:\r\ngdp->is_curr_top = true;\r\nbreak;\r\ncase VTG_BOTTOM_FIELD_EVENT:\r\ngdp->is_curr_top = false;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unsupported event: %lu\n", event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sti_gdp_init(struct sti_layer *layer)\r\n{\r\nstruct sti_gdp *gdp = to_sti_gdp(layer);\r\nstruct device_node *np = layer->dev->of_node;\r\ndma_addr_t dma;\r\nvoid *base;\r\nunsigned int i, size;\r\nsize = sizeof(struct sti_gdp_node) *\r\nGDP_NODE_PER_FIELD * GDP_NODE_NB_BANK;\r\nbase = dma_alloc_writecombine(layer->dev,\r\nsize, &dma, GFP_KERNEL | GFP_DMA);\r\nif (!base) {\r\nDRM_ERROR("Failed to allocate memory for GDP node\n");\r\nreturn;\r\n}\r\nmemset(base, 0, size);\r\nfor (i = 0; i < GDP_NODE_NB_BANK; i++) {\r\nif (virt_to_dma(layer->dev, base) & 0xF) {\r\nDRM_ERROR("Mem alignment failed\n");\r\nreturn;\r\n}\r\ngdp->node_list[i].top_field = base;\r\nDRM_DEBUG_DRIVER("node[%d].top_field=%p\n", i, base);\r\nbase += sizeof(struct sti_gdp_node);\r\nif (virt_to_dma(layer->dev, base) & 0xF) {\r\nDRM_ERROR("Mem alignment failed\n");\r\nreturn;\r\n}\r\ngdp->node_list[i].btm_field = base;\r\nDRM_DEBUG_DRIVER("node[%d].btm_field=%p\n", i, base);\r\nbase += sizeof(struct sti_gdp_node);\r\n}\r\nif (of_device_is_compatible(np, "st,stih407-compositor")) {\r\nchar *clk_name;\r\nswitch (layer->desc) {\r\ncase STI_GDP_0:\r\nclk_name = "pix_gdp1";\r\nbreak;\r\ncase STI_GDP_1:\r\nclk_name = "pix_gdp2";\r\nbreak;\r\ncase STI_GDP_2:\r\nclk_name = "pix_gdp3";\r\nbreak;\r\ncase STI_GDP_3:\r\nclk_name = "pix_gdp4";\r\nbreak;\r\ndefault:\r\nDRM_ERROR("GDP id not recognized\n");\r\nreturn;\r\n}\r\ngdp->clk_pix = devm_clk_get(layer->dev, clk_name);\r\nif (IS_ERR(gdp->clk_pix))\r\nDRM_ERROR("Cannot get %s clock\n", clk_name);\r\n}\r\n}\r\nstruct sti_layer *sti_gdp_create(struct device *dev, int id)\r\n{\r\nstruct sti_gdp *gdp;\r\ngdp = devm_kzalloc(dev, sizeof(*gdp), GFP_KERNEL);\r\nif (!gdp) {\r\nDRM_ERROR("Failed to allocate memory for GDP\n");\r\nreturn NULL;\r\n}\r\ngdp->layer.ops = &gdp_ops;\r\ngdp->vtg_field_nb.notifier_call = sti_gdp_field_cb;\r\nreturn (struct sti_layer *)gdp;\r\n}
