static void cleanup_card(struct net_device *dev)\r\n{\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, COPS_IO_EXTENT);\r\n}\r\nstruct net_device * __init cops_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\nunsigned *port;\r\nint base_addr;\r\nint err = 0;\r\ndev = alloc_ltalkdev(sizeof(struct cops_local));\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "lt%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nirq = dev->irq;\r\nbase_addr = dev->base_addr;\r\n} else {\r\nbase_addr = dev->base_addr = io;\r\n}\r\nif (base_addr > 0x1ff) {\r\nerr = cops_probe1(dev, base_addr);\r\n} else if (base_addr != 0) {\r\nerr = -ENXIO;\r\n} else {\r\nfor (port = ports; *port && cops_probe1(dev, *port) < 0; port++)\r\n;\r\nif (!*port)\r\nerr = -ENODEV;\r\n}\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\ncleanup_card(dev);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init cops_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nstruct cops_local *lp;\r\nstatic unsigned version_printed;\r\nint board = board_type;\r\nint retval;\r\nif(cops_debug && version_printed++ == 0)\r\nprintk("%s", version);\r\nif (!request_region(ioaddr, COPS_IO_EXTENT, dev->name))\r\nreturn -EBUSY;\r\ndev->irq = irq;\r\nswitch (dev->irq)\r\n{\r\ncase 0:\r\ndev->irq = cops_irq(ioaddr, board);\r\nif (dev->irq)\r\nbreak;\r\ncase 1:\r\nretval = -EINVAL;\r\ngoto err_out;\r\ncase 2:\r\ndev->irq = 9;\r\nbreak;\r\ncase 0xff:\r\ndev->irq = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (dev->irq) {\r\nretval = request_irq(dev->irq, cops_interrupt, 0, dev->name, dev);\r\nif (retval)\r\ngoto err_out;\r\n}\r\ndev->base_addr = ioaddr;\r\nlp = netdev_priv(dev);\r\nspin_lock_init(&lp->lock);\r\nlp->board = board;\r\ndev->netdev_ops = &cops_netdev_ops;\r\ndev->watchdog_timeo = HZ * 2;\r\nif(board==DAYNA)\r\nprintk("%s: %s at %#3x, using IRQ %d, in Dayna mode.\n",\r\ndev->name, cardname, ioaddr, dev->irq);\r\nif(board==TANGENT) {\r\nif(dev->irq)\r\nprintk("%s: %s at %#3x, IRQ %d, in Tangent mode\n",\r\ndev->name, cardname, ioaddr, dev->irq);\r\nelse\r\nprintk("%s: %s at %#3x, using polled IO, in Tangent mode.\n",\r\ndev->name, cardname, ioaddr);\r\n}\r\nreturn 0;\r\nerr_out:\r\nrelease_region(ioaddr, COPS_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic int __init cops_irq (int ioaddr, int board)\r\n{\r\nint irqaddr=0;\r\nint i, x, status;\r\nif(board==DAYNA)\r\n{\r\noutb(0, ioaddr+DAYNA_RESET);\r\ninb(ioaddr+DAYNA_RESET);\r\nmdelay(333);\r\n}\r\nif(board==TANGENT)\r\n{\r\ninb(ioaddr);\r\noutb(0, ioaddr);\r\noutb(0, ioaddr+TANG_RESET);\r\n}\r\nfor(i=0; cops_irqlist[i] !=0; i++)\r\n{\r\nirqaddr = cops_irqlist[i];\r\nfor(x = 0xFFFF; x>0; x --)\r\n{\r\nif(board==DAYNA)\r\n{\r\nstatus = (inb(ioaddr+DAYNA_CARD_STATUS)&3);\r\nif(status == 1)\r\nreturn irqaddr;\r\n}\r\nif(board==TANGENT)\r\n{\r\nif((inb(ioaddr+TANG_CARD_STATUS)& TANG_TX_READY) !=0)\r\nreturn irqaddr;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cops_open(struct net_device *dev)\r\n{\r\nstruct cops_local *lp = netdev_priv(dev);\r\nif(dev->irq==0)\r\n{\r\nif(lp->board==TANGENT)\r\n{\r\ninit_timer(&cops_timer);\r\ncops_timer.function = cops_poll;\r\ncops_timer.data = (unsigned long)dev;\r\ncops_timer.expires = jiffies + HZ/20;\r\nadd_timer(&cops_timer);\r\n}\r\nelse\r\n{\r\nprintk(KERN_WARNING "%s: No irq line set\n", dev->name);\r\nreturn -EAGAIN;\r\n}\r\n}\r\ncops_jumpstart(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int cops_jumpstart(struct net_device *dev)\r\n{\r\nstruct cops_local *lp = netdev_priv(dev);\r\ncops_reset(dev,1);\r\ncops_load(dev);\r\nif(lp->nodeid == 1)\r\ncops_nodeid(dev,lp->node_acquire);\r\nreturn 0;\r\n}\r\nstatic void tangent_wait_reset(int ioaddr)\r\n{\r\nint timeout=0;\r\nwhile(timeout++ < 5 && (inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)\r\nmdelay(1);\r\n}\r\nstatic void cops_reset(struct net_device *dev, int sleep)\r\n{\r\nstruct cops_local *lp = netdev_priv(dev);\r\nint ioaddr=dev->base_addr;\r\nif(lp->board==TANGENT)\r\n{\r\ninb(ioaddr);\r\noutb(0,ioaddr);\r\noutb(0, ioaddr+TANG_RESET);\r\ntangent_wait_reset(ioaddr);\r\noutb(0, ioaddr+TANG_CLEAR_INT);\r\n}\r\nif(lp->board==DAYNA)\r\n{\r\noutb(0, ioaddr+DAYNA_RESET);\r\ninb(ioaddr+DAYNA_RESET);\r\nif (sleep)\r\nmsleep(333);\r\nelse\r\nmdelay(333);\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void cops_load (struct net_device *dev)\r\n{\r\nstruct ifreq ifr;\r\nstruct ltfirmware *ltf= (struct ltfirmware *)&ifr.ifr_ifru;\r\nstruct cops_local *lp = netdev_priv(dev);\r\nint ioaddr=dev->base_addr;\r\nint length, i = 0;\r\nstrcpy(ifr.ifr_name,"lt0");\r\n#ifdef CONFIG_COPS_DAYNA\r\nif(lp->board==DAYNA)\r\n{\r\nltf->length=sizeof(ffdrv_code);\r\nltf->data=ffdrv_code;\r\n}\r\nelse\r\n#endif\r\n#ifdef CONFIG_COPS_TANGENT\r\nif(lp->board==TANGENT)\r\n{\r\nltf->length=sizeof(ltdrv_code);\r\nltf->data=ltdrv_code;\r\n}\r\nelse\r\n#endif\r\n{\r\nprintk(KERN_INFO "%s; unsupported board type.\n", dev->name);\r\nreturn;\r\n}\r\nif(lp->board==DAYNA && ltf->length!=5983)\r\n{\r\nprintk(KERN_WARNING "%s: Firmware is not length of FFDRV.BIN.\n", dev->name);\r\nreturn;\r\n}\r\nif(lp->board==TANGENT && ltf->length!=2501)\r\n{\r\nprintk(KERN_WARNING "%s: Firmware is not length of DRVCODE.BIN.\n", dev->name);\r\nreturn;\r\n}\r\nif(lp->board==DAYNA)\r\n{\r\nwhile(++i<65536)\r\n{\r\nif((inb(ioaddr+DAYNA_CARD_STATUS)&3)==1)\r\nbreak;\r\n}\r\nif(i==65536)\r\nreturn;\r\n}\r\ni=0;\r\nlength = ltf->length;\r\nwhile(length--)\r\n{\r\noutb(ltf->data[i], ioaddr);\r\ni++;\r\n}\r\nif(cops_debug > 1)\r\nprintk("%s: Uploaded firmware - %d bytes of %d bytes.\n",\r\ndev->name, i, ltf->length);\r\nif(lp->board==DAYNA)\r\noutb(1, ioaddr+DAYNA_INT_CARD);\r\nelse\r\ninb(ioaddr);\r\nif(lp->board==TANGENT)\r\n{\r\ntangent_wait_reset(ioaddr);\r\ninb(ioaddr);\r\n}\r\n}\r\nstatic int cops_nodeid (struct net_device *dev, int nodeid)\r\n{\r\nstruct cops_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nif(lp->board == DAYNA)\r\n{\r\nwhile((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0)\r\n{\r\noutb(0, ioaddr+COPS_CLEAR_INT);\r\nif((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_REQUEST)\r\ncops_rx(dev);\r\nschedule();\r\n}\r\noutb(2, ioaddr);\r\noutb(0, ioaddr);\r\noutb(LAP_INIT, ioaddr);\r\noutb(nodeid, ioaddr);\r\n}\r\nif(lp->board == TANGENT)\r\n{\r\nwhile(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)\r\n{\r\noutb(0, ioaddr+COPS_CLEAR_INT);\r\ncops_rx(dev);\r\nschedule();\r\n}\r\nif(nodeid == 0)\r\nnodeid = jiffies&0xFF;\r\noutb(2, ioaddr);\r\noutb(0, ioaddr);\r\noutb(LAP_INIT, ioaddr);\r\noutb(nodeid, ioaddr);\r\noutb(0xFF, ioaddr);\r\n}\r\nlp->node_acquire=0;\r\nwhile(lp->node_acquire==0)\r\n{\r\noutb(0, ioaddr+COPS_CLEAR_INT);\r\nif(lp->board == DAYNA)\r\n{\r\nif((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_REQUEST)\r\ncops_rx(dev);\r\n}\r\nif(lp->board == TANGENT)\r\n{\r\nif(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)\r\ncops_rx(dev);\r\n}\r\nschedule();\r\n}\r\nif(cops_debug > 1)\r\nprintk(KERN_DEBUG "%s: Node ID %d has been acquired.\n",\r\ndev->name, lp->node_acquire);\r\nlp->nodeid=1;\r\nreturn 0;\r\n}\r\nstatic void cops_poll(unsigned long ltdev)\r\n{\r\nint ioaddr, status;\r\nint boguscount = 0;\r\nstruct net_device *dev = (struct net_device *)ltdev;\r\ndel_timer(&cops_timer);\r\nif(dev == NULL)\r\nreturn;\r\nioaddr = dev->base_addr;\r\ndo {\r\nstatus=inb(ioaddr+TANG_CARD_STATUS);\r\nif(status & TANG_RX_READY)\r\ncops_rx(dev);\r\nif(status & TANG_TX_READY)\r\nnetif_wake_queue(dev);\r\nstatus = inb(ioaddr+TANG_CARD_STATUS);\r\n} while((++boguscount < 20) && (status&(TANG_RX_READY|TANG_TX_READY)));\r\ncops_timer.expires = jiffies + HZ/20;\r\nadd_timer(&cops_timer);\r\n}\r\nstatic irqreturn_t cops_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct cops_local *lp;\r\nint ioaddr, status;\r\nint boguscount = 0;\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nif(lp->board==DAYNA)\r\n{\r\ndo {\r\noutb(0, ioaddr + COPS_CLEAR_INT);\r\nstatus=inb(ioaddr+DAYNA_CARD_STATUS);\r\nif((status&0x03)==DAYNA_RX_REQUEST)\r\ncops_rx(dev);\r\nnetif_wake_queue(dev);\r\n} while(++boguscount < 20);\r\n}\r\nelse\r\n{\r\ndo {\r\nstatus=inb(ioaddr+TANG_CARD_STATUS);\r\nif(status & TANG_RX_READY)\r\ncops_rx(dev);\r\nif(status & TANG_TX_READY)\r\nnetif_wake_queue(dev);\r\nstatus=inb(ioaddr+TANG_CARD_STATUS);\r\n} while((++boguscount < 20) && (status&(TANG_RX_READY|TANG_TX_READY)));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cops_rx(struct net_device *dev)\r\n{\r\nint pkt_len = 0;\r\nint rsp_type = 0;\r\nstruct sk_buff *skb = NULL;\r\nstruct cops_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nint boguscount = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif(lp->board==DAYNA)\r\n{\r\noutb(0, ioaddr);\r\noutb(0, ioaddr);\r\noutb(DATA_READ, ioaddr);\r\nwhile(++boguscount<1000000)\r\n{\r\nbarrier();\r\nif((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_READY)\r\nbreak;\r\n}\r\nif(boguscount==1000000)\r\n{\r\nprintk(KERN_WARNING "%s: DMA timed out.\n",dev->name);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn;\r\n}\r\n}\r\nif(lp->board==DAYNA)\r\npkt_len = inb(ioaddr) & 0xFF;\r\nelse\r\npkt_len = inb(ioaddr) & 0x00FF;\r\npkt_len |= (inb(ioaddr) << 8);\r\nrsp_type=inb(ioaddr);\r\nskb = dev_alloc_skb(pkt_len);\r\nif(skb == NULL)\r\n{\r\nprintk(KERN_WARNING "%s: Memory squeeze, dropping packet.\n",\r\ndev->name);\r\ndev->stats.rx_dropped++;\r\nwhile(pkt_len--)\r\ninb(ioaddr);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn;\r\n}\r\nskb->dev = dev;\r\nskb_put(skb, pkt_len);\r\nskb->protocol = htons(ETH_P_LOCALTALK);\r\ninsb(ioaddr, skb->data, pkt_len);\r\nif(lp->board==DAYNA)\r\noutb(1, ioaddr+DAYNA_INT_CARD);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nif(pkt_len < 0 || pkt_len > MAX_LLAP_SIZE)\r\n{\r\nprintk(KERN_WARNING "%s: Bad packet length of %d bytes.\n",\r\ndev->name, pkt_len);\r\ndev->stats.tx_errors++;\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif(rsp_type == LAP_INIT_RSP)\r\n{\r\nlp->node_acquire = skb->data[0];\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif(rsp_type != LAP_RESPONSE)\r\n{\r\nprintk(KERN_WARNING "%s: Bad packet type %d.\n", dev->name, rsp_type);\r\ndev->stats.tx_errors++;\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb,3);\r\nskb_reset_transport_header(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\n}\r\nstatic void cops_timeout(struct net_device *dev)\r\n{\r\nstruct cops_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\ndev->stats.tx_errors++;\r\nif(lp->board==TANGENT)\r\n{\r\nif((inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)\r\nprintk(KERN_WARNING "%s: No TX complete interrupt.\n", dev->name);\r\n}\r\nprintk(KERN_WARNING "%s: Transmit timed out.\n", dev->name);\r\ncops_jumpstart(dev);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t cops_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct cops_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif(lp->board == DAYNA)\r\nwhile((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0)\r\ncpu_relax();\r\nif(lp->board == TANGENT)\r\nwhile((inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)\r\ncpu_relax();\r\noutb(skb->len, ioaddr);\r\nif(lp->board == DAYNA)\r\noutb(skb->len >> 8, ioaddr);\r\nelse\r\noutb((skb->len >> 8)&0x0FF, ioaddr);\r\noutb(LAP_WRITE, ioaddr);\r\nif(lp->board == DAYNA)\r\nwhile((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0);\r\noutsb(ioaddr, skb->data, skb->len);\r\nif(lp->board==DAYNA)\r\noutb(1, ioaddr+DAYNA_INT_CARD);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nif(cops_debug >= 3)\r\nprintk("%s: set_multicast_list executed\n", dev->name);\r\n}\r\nstatic int cops_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct cops_local *lp = netdev_priv(dev);\r\nstruct sockaddr_at *sa = (struct sockaddr_at *)&ifr->ifr_addr;\r\nstruct atalk_addr *aa = &lp->node_addr;\r\nswitch(cmd)\r\n{\r\ncase SIOCSIFADDR:\r\ncops_nodeid(dev, sa->sat_addr.s_node);\r\naa->s_net = sa->sat_addr.s_net;\r\naa->s_node = lp->node_acquire;\r\ndev->broadcast[0] = 0xFF;\r\ndev->dev_addr[0] = aa->s_node;\r\ndev->addr_len = 1;\r\nreturn 0;\r\ncase SIOCGIFADDR:\r\nsa->sat_addr.s_net = aa->s_net;\r\nsa->sat_addr.s_node = aa->s_node;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int cops_close(struct net_device *dev)\r\n{\r\nstruct cops_local *lp = netdev_priv(dev);\r\nif(lp->board==TANGENT && dev->irq==0)\r\ndel_timer(&cops_timer);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int __init cops_module_init(void)\r\n{\r\nif (io == 0)\r\nprintk(KERN_WARNING "%s: You shouldn't autoprobe with insmod\n",\r\ncardname);\r\ncops_dev = cops_probe(-1);\r\nreturn PTR_ERR_OR_ZERO(cops_dev);\r\n}\r\nstatic void __exit cops_module_exit(void)\r\n{\r\nunregister_netdev(cops_dev);\r\ncleanup_card(cops_dev);\r\nfree_netdev(cops_dev);\r\n}
