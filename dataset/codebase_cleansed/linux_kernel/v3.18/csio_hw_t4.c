static uint32_t\r\ncsio_t4_read_pcie_cfg4(struct csio_hw *hw, int reg)\r\n{\r\nu32 val = 0;\r\nstruct csio_mb *mbp;\r\nint rv;\r\nstruct fw_ldst_cmd *ldst_cmd;\r\nmbp = mempool_alloc(hw->mb_mempool, GFP_ATOMIC);\r\nif (!mbp) {\r\nCSIO_INC_STATS(hw, n_err_nomem);\r\npci_read_config_dword(hw->pdev, reg, &val);\r\nreturn val;\r\n}\r\ncsio_mb_ldst(hw, mbp, CSIO_MB_DEFAULT_TMO, reg);\r\nrv = csio_mb_issue(hw, mbp);\r\nif (rv == 0) {\r\nldst_cmd = (struct fw_ldst_cmd *)(mbp->mb);\r\nval = ntohl(ldst_cmd->u.pcie.data[0]);\r\n} else\r\npci_read_config_dword(hw->pdev, reg, &val);\r\nmempool_free(mbp, hw->mb_mempool);\r\nreturn val;\r\n}\r\nstatic int\r\ncsio_t4_set_mem_win(struct csio_hw *hw, uint32_t win)\r\n{\r\nu32 bar0;\r\nu32 mem_win_base;\r\nbar0 = csio_t4_read_pcie_cfg4(hw, PCI_BASE_ADDRESS_0);\r\nbar0 &= PCI_BASE_ADDRESS_MEM_MASK;\r\nmem_win_base = bar0 + MEMWIN_BASE;\r\ncsio_wr_reg32(hw, mem_win_base | BIR(0) |\r\nWINDOW(ilog2(MEMWIN_APERTURE) - 10),\r\nPCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN, win));\r\ncsio_rd_reg32(hw,\r\nPCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN, win));\r\nreturn 0;\r\n}\r\nstatic void\r\ncsio_t4_pcie_intr_handler(struct csio_hw *hw)\r\n{\r\nstatic struct intr_info sysbus_intr_info[] = {\r\n{ RNPP, "RXNP array parity error", -1, 1 },\r\n{ RPCP, "RXPC array parity error", -1, 1 },\r\n{ RCIP, "RXCIF array parity error", -1, 1 },\r\n{ RCCP, "Rx completions control array parity error", -1, 1 },\r\n{ RFTP, "RXFT array parity error", -1, 1 },\r\n{ 0, NULL, 0, 0 }\r\n};\r\nstatic struct intr_info pcie_port_intr_info[] = {\r\n{ TPCP, "TXPC array parity error", -1, 1 },\r\n{ TNPP, "TXNP array parity error", -1, 1 },\r\n{ TFTP, "TXFT array parity error", -1, 1 },\r\n{ TCAP, "TXCA array parity error", -1, 1 },\r\n{ TCIP, "TXCIF array parity error", -1, 1 },\r\n{ RCAP, "RXCA array parity error", -1, 1 },\r\n{ OTDD, "outbound request TLP discarded", -1, 1 },\r\n{ RDPE, "Rx data parity error", -1, 1 },\r\n{ TDUE, "Tx uncorrectable data error", -1, 1 },\r\n{ 0, NULL, 0, 0 }\r\n};\r\nstatic struct intr_info pcie_intr_info[] = {\r\n{ MSIADDRLPERR, "MSI AddrL parity error", -1, 1 },\r\n{ MSIADDRHPERR, "MSI AddrH parity error", -1, 1 },\r\n{ MSIDATAPERR, "MSI data parity error", -1, 1 },\r\n{ MSIXADDRLPERR, "MSI-X AddrL parity error", -1, 1 },\r\n{ MSIXADDRHPERR, "MSI-X AddrH parity error", -1, 1 },\r\n{ MSIXDATAPERR, "MSI-X data parity error", -1, 1 },\r\n{ MSIXDIPERR, "MSI-X DI parity error", -1, 1 },\r\n{ PIOCPLPERR, "PCI PIO completion FIFO parity error", -1, 1 },\r\n{ PIOREQPERR, "PCI PIO request FIFO parity error", -1, 1 },\r\n{ TARTAGPERR, "PCI PCI target tag FIFO parity error", -1, 1 },\r\n{ CCNTPERR, "PCI CMD channel count parity error", -1, 1 },\r\n{ CREQPERR, "PCI CMD channel request parity error", -1, 1 },\r\n{ CRSPPERR, "PCI CMD channel response parity error", -1, 1 },\r\n{ DCNTPERR, "PCI DMA channel count parity error", -1, 1 },\r\n{ DREQPERR, "PCI DMA channel request parity error", -1, 1 },\r\n{ DRSPPERR, "PCI DMA channel response parity error", -1, 1 },\r\n{ HCNTPERR, "PCI HMA channel count parity error", -1, 1 },\r\n{ HREQPERR, "PCI HMA channel request parity error", -1, 1 },\r\n{ HRSPPERR, "PCI HMA channel response parity error", -1, 1 },\r\n{ CFGSNPPERR, "PCI config snoop FIFO parity error", -1, 1 },\r\n{ FIDPERR, "PCI FID parity error", -1, 1 },\r\n{ INTXCLRPERR, "PCI INTx clear parity error", -1, 1 },\r\n{ MATAGPERR, "PCI MA tag parity error", -1, 1 },\r\n{ PIOTAGPERR, "PCI PIO tag parity error", -1, 1 },\r\n{ RXCPLPERR, "PCI Rx completion parity error", -1, 1 },\r\n{ RXWRPERR, "PCI Rx write parity error", -1, 1 },\r\n{ RPLPERR, "PCI replay buffer parity error", -1, 1 },\r\n{ PCIESINT, "PCI core secondary fault", -1, 1 },\r\n{ PCIEPINT, "PCI core primary fault", -1, 1 },\r\n{ UNXSPLCPLERR, "PCI unexpected split completion error", -1,\r\n0 },\r\n{ 0, NULL, 0, 0 }\r\n};\r\nint fat;\r\nfat = csio_handle_intr_status(hw,\r\nPCIE_CORE_UTL_SYSTEM_BUS_AGENT_STATUS,\r\nsysbus_intr_info) +\r\ncsio_handle_intr_status(hw,\r\nPCIE_CORE_UTL_PCI_EXPRESS_PORT_STATUS,\r\npcie_port_intr_info) +\r\ncsio_handle_intr_status(hw, PCIE_INT_CAUSE, pcie_intr_info);\r\nif (fat)\r\ncsio_hw_fatal_err(hw);\r\n}\r\nstatic unsigned int\r\ncsio_t4_flash_cfg_addr(struct csio_hw *hw)\r\n{\r\nreturn FLASH_CFG_OFFSET;\r\n}\r\nstatic int\r\ncsio_t4_mc_read(struct csio_hw *hw, int idx, uint32_t addr, __be32 *data,\r\nuint64_t *ecc)\r\n{\r\nint i;\r\nif (csio_rd_reg32(hw, MC_BIST_CMD) & START_BIST)\r\nreturn -EBUSY;\r\ncsio_wr_reg32(hw, addr & ~0x3fU, MC_BIST_CMD_ADDR);\r\ncsio_wr_reg32(hw, 64, MC_BIST_CMD_LEN);\r\ncsio_wr_reg32(hw, 0xc, MC_BIST_DATA_PATTERN);\r\ncsio_wr_reg32(hw, BIST_OPCODE(1) | START_BIST | BIST_CMD_GAP(1),\r\nMC_BIST_CMD);\r\ni = csio_hw_wait_op_done_val(hw, MC_BIST_CMD, START_BIST,\r\n0, 10, 1, NULL);\r\nif (i)\r\nreturn i;\r\n#define MC_DATA(i) MC_BIST_STATUS_REG(MC_BIST_STATUS_RDATA, i)\r\nfor (i = 15; i >= 0; i--)\r\n*data++ = htonl(csio_rd_reg32(hw, MC_DATA(i)));\r\nif (ecc)\r\n*ecc = csio_rd_reg64(hw, MC_DATA(16));\r\n#undef MC_DATA\r\nreturn 0;\r\n}\r\nstatic int\r\ncsio_t4_edc_read(struct csio_hw *hw, int idx, uint32_t addr, __be32 *data,\r\nuint64_t *ecc)\r\n{\r\nint i;\r\nidx *= EDC_STRIDE;\r\nif (csio_rd_reg32(hw, EDC_BIST_CMD + idx) & START_BIST)\r\nreturn -EBUSY;\r\ncsio_wr_reg32(hw, addr & ~0x3fU, EDC_BIST_CMD_ADDR + idx);\r\ncsio_wr_reg32(hw, 64, EDC_BIST_CMD_LEN + idx);\r\ncsio_wr_reg32(hw, 0xc, EDC_BIST_DATA_PATTERN + idx);\r\ncsio_wr_reg32(hw, BIST_OPCODE(1) | BIST_CMD_GAP(1) | START_BIST,\r\nEDC_BIST_CMD + idx);\r\ni = csio_hw_wait_op_done_val(hw, EDC_BIST_CMD + idx, START_BIST,\r\n0, 10, 1, NULL);\r\nif (i)\r\nreturn i;\r\n#define EDC_DATA(i) (EDC_BIST_STATUS_REG(EDC_BIST_STATUS_RDATA, i) + idx)\r\nfor (i = 15; i >= 0; i--)\r\n*data++ = htonl(csio_rd_reg32(hw, EDC_DATA(i)));\r\nif (ecc)\r\n*ecc = csio_rd_reg64(hw, EDC_DATA(16));\r\n#undef EDC_DATA\r\nreturn 0;\r\n}\r\nstatic int\r\ncsio_t4_memory_rw(struct csio_hw *hw, u32 win, int mtype, u32 addr,\r\nu32 len, uint32_t *buf, int dir)\r\n{\r\nu32 pos, start, offset, memoffset, bar0;\r\nu32 edc_size, mc_size, mem_reg, mem_aperture, mem_base;\r\nif ((addr & 0x3) || (len & 0x3))\r\nreturn -EINVAL;\r\nedc_size = EDRAM_SIZE_GET(csio_rd_reg32(hw, MA_EDRAM0_BAR));\r\nif (mtype != MEM_MC1)\r\nmemoffset = (mtype * (edc_size * 1024 * 1024));\r\nelse {\r\nmc_size = EXT_MEM_SIZE_GET(csio_rd_reg32(hw,\r\nMA_EXT_MEMORY_BAR));\r\nmemoffset = (MEM_MC0 * edc_size + mc_size) * 1024 * 1024;\r\n}\r\naddr = addr + memoffset;\r\nmem_reg = csio_rd_reg32(hw,\r\nPCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN, win));\r\nmem_aperture = 1 << (WINDOW(mem_reg) + 10);\r\nmem_base = GET_PCIEOFST(mem_reg) << 10;\r\nbar0 = csio_t4_read_pcie_cfg4(hw, PCI_BASE_ADDRESS_0);\r\nbar0 &= PCI_BASE_ADDRESS_MEM_MASK;\r\nmem_base -= bar0;\r\nstart = addr & ~(mem_aperture-1);\r\noffset = addr - start;\r\ncsio_dbg(hw, "csio_t4_memory_rw: mem_reg: 0x%x, mem_aperture: 0x%x\n",\r\nmem_reg, mem_aperture);\r\ncsio_dbg(hw, "csio_t4_memory_rw: mem_base: 0x%x, mem_offset: 0x%x\n",\r\nmem_base, memoffset);\r\ncsio_dbg(hw, "csio_t4_memory_rw: bar0: 0x%x, start:0x%x, offset:0x%x\n",\r\nbar0, start, offset);\r\ncsio_dbg(hw, "csio_t4_memory_rw: mtype: %d, addr: 0x%x, len: %d\n",\r\nmtype, addr, len);\r\nfor (pos = start; len > 0; pos += mem_aperture, offset = 0) {\r\ncsio_wr_reg32(hw, pos,\r\nPCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_OFFSET, win));\r\ncsio_rd_reg32(hw,\r\nPCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_OFFSET, win));\r\nwhile (offset < mem_aperture && len > 0) {\r\nif (dir)\r\n*buf++ = csio_rd_reg32(hw, mem_base + offset);\r\nelse\r\ncsio_wr_reg32(hw, *buf++, mem_base + offset);\r\noffset += sizeof(__be32);\r\nlen -= sizeof(__be32);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncsio_t4_dfs_create_ext_mem(struct csio_hw *hw)\r\n{\r\nu32 size;\r\nint i = csio_rd_reg32(hw, MA_TARGET_MEM_ENABLE);\r\nif (i & EXT_MEM_ENABLE) {\r\nsize = csio_rd_reg32(hw, MA_EXT_MEMORY_BAR);\r\ncsio_add_debugfs_mem(hw, "mc", MEM_MC,\r\nEXT_MEM_SIZE_GET(size));\r\n}\r\n}
