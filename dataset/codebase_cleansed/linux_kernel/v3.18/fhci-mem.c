static void init_td(struct td *td)\r\n{\r\nmemset(td, 0, sizeof(*td));\r\nINIT_LIST_HEAD(&td->node);\r\nINIT_LIST_HEAD(&td->frame_lh);\r\n}\r\nstatic void init_ed(struct ed *ed)\r\n{\r\nmemset(ed, 0, sizeof(*ed));\r\nINIT_LIST_HEAD(&ed->td_list);\r\nINIT_LIST_HEAD(&ed->node);\r\n}\r\nstatic struct td *get_empty_td(struct fhci_hcd *fhci)\r\n{\r\nstruct td *td;\r\nif (!list_empty(&fhci->empty_tds)) {\r\ntd = list_entry(fhci->empty_tds.next, struct td, node);\r\nlist_del(fhci->empty_tds.next);\r\n} else {\r\ntd = kmalloc(sizeof(*td), GFP_ATOMIC);\r\nif (!td)\r\nfhci_err(fhci, "No memory to allocate to TD\n");\r\nelse\r\ninit_td(td);\r\n}\r\nreturn td;\r\n}\r\nvoid fhci_recycle_empty_td(struct fhci_hcd *fhci, struct td *td)\r\n{\r\ninit_td(td);\r\nlist_add(&td->node, &fhci->empty_tds);\r\n}\r\nstruct ed *fhci_get_empty_ed(struct fhci_hcd *fhci)\r\n{\r\nstruct ed *ed;\r\nif (!list_empty(&fhci->empty_eds)) {\r\ned = list_entry(fhci->empty_eds.next, struct ed, node);\r\nlist_del(fhci->empty_eds.next);\r\n} else {\r\ned = kmalloc(sizeof(*ed), GFP_ATOMIC);\r\nif (!ed)\r\nfhci_err(fhci, "No memory to allocate to ED\n");\r\nelse\r\ninit_ed(ed);\r\n}\r\nreturn ed;\r\n}\r\nvoid fhci_recycle_empty_ed(struct fhci_hcd *fhci, struct ed *ed)\r\n{\r\ninit_ed(ed);\r\nlist_add(&ed->node, &fhci->empty_eds);\r\n}\r\nstruct td *fhci_td_fill(struct fhci_hcd *fhci, struct urb *urb,\r\nstruct urb_priv *urb_priv, struct ed *ed, u16 index,\r\nenum fhci_ta_type type, int toggle, u8 *data, u32 len,\r\nu16 interval, u16 start_frame, bool ioc)\r\n{\r\nstruct td *td = get_empty_td(fhci);\r\nif (!td)\r\nreturn NULL;\r\ntd->urb = urb;\r\ntd->ed = ed;\r\ntd->type = type;\r\ntd->toggle = toggle;\r\ntd->data = data;\r\ntd->len = len;\r\ntd->iso_index = index;\r\ntd->interval = interval;\r\ntd->start_frame = start_frame;\r\ntd->ioc = ioc;\r\ntd->status = USB_TD_OK;\r\nurb_priv->tds[index] = td;\r\nreturn td;\r\n}
