static int vss_do_freeze(char *dir, unsigned int cmd, char *fs_op)\r\n{\r\nint ret, fd = open(dir, O_RDONLY);\r\nif (fd < 0)\r\nreturn 1;\r\nret = ioctl(fd, cmd, 0);\r\nsyslog(LOG_INFO, "VSS: %s of %s: %s\n", fs_op, dir, strerror(errno));\r\nclose(fd);\r\nreturn !!ret;\r\n}\r\nstatic int vss_operate(int operation)\r\n{\r\nchar *fs_op;\r\nchar match[] = "/dev/";\r\nFILE *mounts;\r\nstruct mntent *ent;\r\nunsigned int cmd;\r\nint error = 0, root_seen = 0;\r\nswitch (operation) {\r\ncase VSS_OP_FREEZE:\r\ncmd = FIFREEZE;\r\nfs_op = "freeze";\r\nbreak;\r\ncase VSS_OP_THAW:\r\ncmd = FITHAW;\r\nfs_op = "thaw";\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nmounts = setmntent("/proc/mounts", "r");\r\nif (mounts == NULL)\r\nreturn -1;\r\nwhile ((ent = getmntent(mounts))) {\r\nif (strncmp(ent->mnt_fsname, match, strlen(match)))\r\ncontinue;\r\nif (strcmp(ent->mnt_type, "iso9660") == 0)\r\ncontinue;\r\nif (strcmp(ent->mnt_type, "vfat") == 0)\r\ncontinue;\r\nif (strcmp(ent->mnt_dir, "/") == 0) {\r\nroot_seen = 1;\r\ncontinue;\r\n}\r\nerror |= vss_do_freeze(ent->mnt_dir, cmd, fs_op);\r\n}\r\nendmntent(mounts);\r\nif (root_seen) {\r\nerror |= vss_do_freeze("/", cmd, fs_op);\r\n}\r\nreturn error;\r\n}\r\nstatic int netlink_send(int fd, struct cn_msg *msg)\r\n{\r\nstruct nlmsghdr nlh = { .nlmsg_type = NLMSG_DONE };\r\nunsigned int size;\r\nstruct msghdr message;\r\nstruct iovec iov[2];\r\nsize = sizeof(struct cn_msg) + msg->len;\r\nnlh.nlmsg_pid = getpid();\r\nnlh.nlmsg_len = NLMSG_LENGTH(size);\r\niov[0].iov_base = &nlh;\r\niov[0].iov_len = sizeof(nlh);\r\niov[1].iov_base = msg;\r\niov[1].iov_len = size;\r\nmemset(&message, 0, sizeof(message));\r\nmessage.msg_name = &addr;\r\nmessage.msg_namelen = sizeof(addr);\r\nmessage.msg_iov = iov;\r\nmessage.msg_iovlen = 2;\r\nreturn sendmsg(fd, &message, 0);\r\n}\r\nint main(void)\r\n{\r\nint fd, len, nl_group;\r\nint error;\r\nstruct cn_msg *message;\r\nstruct pollfd pfd;\r\nstruct nlmsghdr *incoming_msg;\r\nstruct cn_msg *incoming_cn_msg;\r\nint op;\r\nstruct hv_vss_msg *vss_msg;\r\nchar *vss_recv_buffer;\r\nsize_t vss_recv_buffer_len;\r\nif (daemon(1, 0))\r\nreturn 1;\r\nopenlog("Hyper-V VSS", 0, LOG_USER);\r\nsyslog(LOG_INFO, "VSS starting; pid is:%d", getpid());\r\nvss_recv_buffer_len = NLMSG_LENGTH(0) + sizeof(struct cn_msg) + sizeof(struct hv_vss_msg);\r\nvss_recv_buffer = calloc(1, vss_recv_buffer_len);\r\nif (!vss_recv_buffer) {\r\nsyslog(LOG_ERR, "Failed to allocate netlink buffers");\r\nexit(EXIT_FAILURE);\r\n}\r\nfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\r\nif (fd < 0) {\r\nsyslog(LOG_ERR, "netlink socket creation failed; error:%d %s",\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\naddr.nl_family = AF_NETLINK;\r\naddr.nl_pad = 0;\r\naddr.nl_pid = 0;\r\naddr.nl_groups = 0;\r\nerror = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\r\nif (error < 0) {\r\nsyslog(LOG_ERR, "bind failed; error:%d %s", errno, strerror(errno));\r\nclose(fd);\r\nexit(EXIT_FAILURE);\r\n}\r\nnl_group = CN_VSS_IDX;\r\nif (setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &nl_group, sizeof(nl_group)) < 0) {\r\nsyslog(LOG_ERR, "setsockopt failed; error:%d %s", errno, strerror(errno));\r\nclose(fd);\r\nexit(EXIT_FAILURE);\r\n}\r\nmessage = (struct cn_msg *)vss_recv_buffer;\r\nmessage->id.idx = CN_VSS_IDX;\r\nmessage->id.val = CN_VSS_VAL;\r\nmessage->ack = 0;\r\nvss_msg = (struct hv_vss_msg *)message->data;\r\nvss_msg->vss_hdr.operation = VSS_OP_REGISTER;\r\nmessage->len = sizeof(struct hv_vss_msg);\r\nlen = netlink_send(fd, message);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "netlink_send failed; error:%d %s", errno, strerror(errno));\r\nclose(fd);\r\nexit(EXIT_FAILURE);\r\n}\r\npfd.fd = fd;\r\nwhile (1) {\r\nstruct sockaddr *addr_p = (struct sockaddr *) &addr;\r\nsocklen_t addr_l = sizeof(addr);\r\npfd.events = POLLIN;\r\npfd.revents = 0;\r\nif (poll(&pfd, 1, -1) < 0) {\r\nsyslog(LOG_ERR, "poll failed; error:%d %s", errno, strerror(errno));\r\nif (errno == EINVAL) {\r\nclose(fd);\r\nexit(EXIT_FAILURE);\r\n}\r\nelse\r\ncontinue;\r\n}\r\nlen = recvfrom(fd, vss_recv_buffer, vss_recv_buffer_len, 0,\r\naddr_p, &addr_l);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "recvfrom failed; pid:%u error:%d %s",\r\naddr.nl_pid, errno, strerror(errno));\r\nclose(fd);\r\nreturn -1;\r\n}\r\nif (addr.nl_pid) {\r\nsyslog(LOG_WARNING,\r\n"Received packet from untrusted pid:%u",\r\naddr.nl_pid);\r\ncontinue;\r\n}\r\nincoming_msg = (struct nlmsghdr *)vss_recv_buffer;\r\nif (incoming_msg->nlmsg_type != NLMSG_DONE)\r\ncontinue;\r\nincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\r\nvss_msg = (struct hv_vss_msg *)incoming_cn_msg->data;\r\nop = vss_msg->vss_hdr.operation;\r\nerror = HV_S_OK;\r\nswitch (op) {\r\ncase VSS_OP_FREEZE:\r\ncase VSS_OP_THAW:\r\nerror = vss_operate(op);\r\nif (error)\r\nerror = HV_E_FAIL;\r\nbreak;\r\ndefault:\r\nsyslog(LOG_ERR, "Illegal op:%d\n", op);\r\n}\r\nvss_msg->error = error;\r\nlen = netlink_send(fd, incoming_cn_msg);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "net_link send failed; error:%d %s",\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\n}
