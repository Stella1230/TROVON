void print_pte (pte_t pte)\r\n{\r\n#if 0\r\nunsigned long val = pte_val (pte);\r\nprintk (" pte=%lx [addr=%lx",\r\nval, (val & SUN3_PAGE_PGNUM_MASK) << PAGE_SHIFT);\r\nif (val & SUN3_PAGE_VALID) printk (" valid");\r\nif (val & SUN3_PAGE_WRITEABLE) printk (" write");\r\nif (val & SUN3_PAGE_SYSTEM) printk (" sys");\r\nif (val & SUN3_PAGE_NOCACHE) printk (" nocache");\r\nif (val & SUN3_PAGE_ACCESSED) printk (" accessed");\r\nif (val & SUN3_PAGE_MODIFIED) printk (" modified");\r\nswitch (val & SUN3_PAGE_TYPE_MASK) {\r\ncase SUN3_PAGE_TYPE_MEMORY: printk (" memory"); break;\r\ncase SUN3_PAGE_TYPE_IO: printk (" io"); break;\r\ncase SUN3_PAGE_TYPE_VME16: printk (" vme16"); break;\r\ncase SUN3_PAGE_TYPE_VME32: printk (" vme32"); break;\r\n}\r\nprintk ("]\n");\r\n#else\r\nunsigned long val = pte_val (pte);\r\nchar flags[7], *type;\r\nflags[0] = (val & SUN3_PAGE_VALID) ? 'v' : '-';\r\nflags[1] = (val & SUN3_PAGE_WRITEABLE) ? 'w' : '-';\r\nflags[2] = (val & SUN3_PAGE_SYSTEM) ? 's' : '-';\r\nflags[3] = (val & SUN3_PAGE_NOCACHE) ? 'x' : '-';\r\nflags[4] = (val & SUN3_PAGE_ACCESSED) ? 'a' : '-';\r\nflags[5] = (val & SUN3_PAGE_MODIFIED) ? 'm' : '-';\r\nflags[6] = '\0';\r\nswitch (val & SUN3_PAGE_TYPE_MASK) {\r\ncase SUN3_PAGE_TYPE_MEMORY: type = "memory"; break;\r\ncase SUN3_PAGE_TYPE_IO: type = "io" ; break;\r\ncase SUN3_PAGE_TYPE_VME16: type = "vme16" ; break;\r\ncase SUN3_PAGE_TYPE_VME32: type = "vme32" ; break;\r\ndefault: type = "unknown?"; break;\r\n}\r\nprintk (" pte=%08lx [%07lx %s %s]\n",\r\nval, (val & SUN3_PAGE_PGNUM_MASK) << PAGE_SHIFT, flags, type);\r\n#endif\r\n}\r\nvoid print_pte_vaddr (unsigned long vaddr)\r\n{\r\nprintk (" vaddr=%lx [%02lx]", vaddr, sun3_get_segmap (vaddr));\r\nprint_pte (__pte (sun3_get_pte (vaddr)));\r\n}\r\nvoid __init mmu_emu_init(unsigned long bootmem_end)\r\n{\r\nunsigned long seg, num;\r\nint i,j;\r\nmemset(rom_pages, 0, sizeof(rom_pages));\r\nmemset(pmeg_vaddr, 0, sizeof(pmeg_vaddr));\r\nmemset(pmeg_alloc, 0, sizeof(pmeg_alloc));\r\nmemset(pmeg_ctx, 0, sizeof(pmeg_ctx));\r\nbootmem_end = (bootmem_end + (2 * SUN3_PMEG_SIZE)) & ~SUN3_PMEG_MASK;\r\nfor (i=0; i < __pa(bootmem_end) / SUN3_PMEG_SIZE ; ++i)\r\npmeg_alloc[i] = 2;\r\nfor(num = 0xf0; num <= 0xff; num++)\r\npmeg_alloc[num] = 2;\r\nfor(seg = bootmem_end; seg < 0x0f800000; seg += SUN3_PMEG_SIZE) {\r\ni = sun3_get_segmap(seg);\r\nif(!pmeg_alloc[i]) {\r\n#ifdef DEBUG_MMU_EMU\r\nprintk("freed: ");\r\nprint_pte_vaddr (seg);\r\n#endif\r\nsun3_put_segmap(seg, SUN3_INVALID_PMEG);\r\n}\r\n}\r\nj = 0;\r\nfor (num=0, seg=0x0F800000; seg<0x10000000; seg+=16*PAGE_SIZE) {\r\nif (sun3_get_segmap (seg) != SUN3_INVALID_PMEG) {\r\n#ifdef DEBUG_PROM_MAPS\r\nfor(i = 0; i < 16; i++) {\r\nprintk ("mapped:");\r\nprint_pte_vaddr (seg + (i*PAGE_SIZE));\r\nbreak;\r\n}\r\n#endif\r\nif (!m68k_vmalloc_end)\r\nm68k_vmalloc_end = seg;\r\npmeg_alloc[sun3_get_segmap(seg)] = 2;\r\n}\r\n}\r\ndvma_init();\r\nfor(seg = 0; seg < PAGE_OFFSET; seg += SUN3_PMEG_SIZE)\r\nsun3_put_segmap(seg, SUN3_INVALID_PMEG);\r\nset_fs(MAKE_MM_SEG(3));\r\nfor(seg = 0; seg < 0x10000000; seg += SUN3_PMEG_SIZE) {\r\ni = sun3_get_segmap(seg);\r\nfor(j = 1; j < CONTEXTS_NUM; j++)\r\n(*(romvec->pv_setctxt))(j, (void *)seg, i);\r\n}\r\nset_fs(KERNEL_DS);\r\n}\r\nvoid clear_context(unsigned long context)\r\n{\r\nunsigned char oldctx;\r\nunsigned long i;\r\nif(context) {\r\nif(!ctx_alloc[context])\r\npanic("clear_context: context not allocated\n");\r\nctx_alloc[context]->context = SUN3_INVALID_CONTEXT;\r\nctx_alloc[context] = (struct mm_struct *)0;\r\nctx_avail++;\r\n}\r\noldctx = sun3_get_context();\r\nsun3_put_context(context);\r\nfor(i = 0; i < SUN3_INVALID_PMEG; i++) {\r\nif((pmeg_ctx[i] == context) && (pmeg_alloc[i] == 1)) {\r\nsun3_put_segmap(pmeg_vaddr[i], SUN3_INVALID_PMEG);\r\npmeg_ctx[i] = 0;\r\npmeg_alloc[i] = 0;\r\npmeg_vaddr[i] = 0;\r\n}\r\n}\r\nsun3_put_context(oldctx);\r\n}\r\nunsigned long get_free_context(struct mm_struct *mm)\r\n{\r\nunsigned long new = 1;\r\nstatic unsigned char next_to_die = 1;\r\nif(!ctx_avail) {\r\nnew = next_to_die;\r\nclear_context(new);\r\nnext_to_die = (next_to_die + 1) & 0x7;\r\nif(!next_to_die)\r\nnext_to_die++;\r\n} else {\r\nwhile(new < CONTEXTS_NUM) {\r\nif(ctx_alloc[new])\r\nnew++;\r\nelse\r\nbreak;\r\n}\r\nif(new == CONTEXTS_NUM)\r\npanic("get_free_context: failed to find free context");\r\n}\r\nctx_alloc[new] = mm;\r\nctx_avail--;\r\nreturn new;\r\n}\r\ninline void mmu_emu_map_pmeg (int context, int vaddr)\r\n{\r\nstatic unsigned char curr_pmeg = 128;\r\nint i;\r\nvaddr &= ~SUN3_PMEG_MASK;\r\nwhile (pmeg_alloc[curr_pmeg] == 2)\r\n++curr_pmeg;\r\n#ifdef DEBUG_MMU_EMU\r\nprintk("mmu_emu_map_pmeg: pmeg %x to context %d vaddr %x\n",\r\ncurr_pmeg, context, vaddr);\r\n#endif\r\nif (pmeg_alloc[curr_pmeg] == 1) {\r\nsun3_put_context(pmeg_ctx[curr_pmeg]);\r\nsun3_put_segmap (pmeg_vaddr[curr_pmeg], SUN3_INVALID_PMEG);\r\nsun3_put_context(context);\r\n}\r\nif(vaddr >= PAGE_OFFSET) {\r\nunsigned char i;\r\nfor(i = 0; i < CONTEXTS_NUM; i++) {\r\nsun3_put_context(i);\r\nsun3_put_segmap (vaddr, curr_pmeg);\r\n}\r\nsun3_put_context(context);\r\npmeg_alloc[curr_pmeg] = 2;\r\npmeg_ctx[curr_pmeg] = 0;\r\n}\r\nelse {\r\npmeg_alloc[curr_pmeg] = 1;\r\npmeg_ctx[curr_pmeg] = context;\r\nsun3_put_segmap (vaddr, curr_pmeg);\r\n}\r\npmeg_vaddr[curr_pmeg] = vaddr;\r\nfor (i=0; i<SUN3_PMEG_SIZE; i+=SUN3_PTE_SIZE)\r\nsun3_put_pte (vaddr + i, SUN3_PAGE_SYSTEM);\r\n++curr_pmeg;\r\n}\r\nint mmu_emu_handle_fault (unsigned long vaddr, int read_flag, int kernel_fault)\r\n{\r\nunsigned long segment, offset;\r\nunsigned char context;\r\npte_t *pte;\r\npgd_t * crp;\r\nif(current->mm == NULL) {\r\ncrp = swapper_pg_dir;\r\ncontext = 0;\r\n} else {\r\ncontext = current->mm->context;\r\nif(kernel_fault)\r\ncrp = swapper_pg_dir;\r\nelse\r\ncrp = current->mm->pgd;\r\n}\r\n#ifdef DEBUG_MMU_EMU\r\nprintk ("mmu_emu_handle_fault: vaddr=%lx type=%s crp=%p\n",\r\nvaddr, read_flag ? "read" : "write", crp);\r\n#endif\r\nsegment = (vaddr >> SUN3_PMEG_SIZE_BITS) & 0x7FF;\r\noffset = (vaddr >> SUN3_PTE_SIZE_BITS) & 0xF;\r\n#ifdef DEBUG_MMU_EMU\r\nprintk ("mmu_emu_handle_fault: segment=%lx offset=%lx\n", segment, offset);\r\n#endif\r\npte = (pte_t *) pgd_val (*(crp + segment));\r\nif (!pte) {\r\nreturn 0;\r\n}\r\npte = (pte_t *) __va ((unsigned long)(pte + offset));\r\nif (!(pte_val (*pte) & SUN3_PAGE_VALID))\r\nreturn 0;\r\nif (sun3_get_segmap (vaddr&~SUN3_PMEG_MASK) == SUN3_INVALID_PMEG)\r\nmmu_emu_map_pmeg (context, vaddr);\r\nsun3_put_pte (vaddr&PAGE_MASK, pte_val (*pte));\r\nif (!read_flag) {\r\nif (pte_val (*pte) & SUN3_PAGE_WRITEABLE)\r\npte_val (*pte) |= (SUN3_PAGE_ACCESSED\r\n| SUN3_PAGE_MODIFIED);\r\nelse\r\nreturn 0;\r\n} else\r\npte_val (*pte) |= SUN3_PAGE_ACCESSED;\r\n#ifdef DEBUG_MMU_EMU\r\nprintk ("seg:%d crp:%p ->", get_fs().seg, crp);\r\nprint_pte_vaddr (vaddr);\r\nprintk ("\n");\r\n#endif\r\nreturn 1;\r\n}
