static bool nft_hash_lookup(const struct nft_set *set,\r\nconst struct nft_data *key,\r\nstruct nft_data *data)\r\n{\r\nconst struct rhashtable *priv = nft_set_priv(set);\r\nconst struct nft_hash_elem *he;\r\nhe = rhashtable_lookup(priv, key);\r\nif (he && set->flags & NFT_SET_MAP)\r\nnft_data_copy(data, he->data);\r\nreturn !!he;\r\n}\r\nstatic int nft_hash_insert(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct rhashtable *priv = nft_set_priv(set);\r\nstruct nft_hash_elem *he;\r\nunsigned int size;\r\nif (elem->flags != 0)\r\nreturn -EINVAL;\r\nsize = sizeof(*he);\r\nif (set->flags & NFT_SET_MAP)\r\nsize += sizeof(he->data[0]);\r\nhe = kzalloc(size, GFP_KERNEL);\r\nif (he == NULL)\r\nreturn -ENOMEM;\r\nnft_data_copy(&he->key, &elem->key);\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_copy(he->data, &elem->data);\r\nrhashtable_insert(priv, &he->node, GFP_KERNEL);\r\nreturn 0;\r\n}\r\nstatic void nft_hash_elem_destroy(const struct nft_set *set,\r\nstruct nft_hash_elem *he)\r\n{\r\nnft_data_uninit(&he->key, NFT_DATA_VALUE);\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_uninit(he->data, set->dtype);\r\nkfree(he);\r\n}\r\nstatic void nft_hash_remove(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct rhashtable *priv = nft_set_priv(set);\r\nstruct rhash_head *he, __rcu **pprev;\r\npprev = elem->cookie;\r\nhe = rht_dereference((*pprev), priv);\r\nrhashtable_remove_pprev(priv, he, pprev, GFP_KERNEL);\r\nsynchronize_rcu();\r\nkfree(he);\r\n}\r\nstatic int nft_hash_get(const struct nft_set *set, struct nft_set_elem *elem)\r\n{\r\nconst struct rhashtable *priv = nft_set_priv(set);\r\nconst struct bucket_table *tbl = rht_dereference_rcu(priv->tbl, priv);\r\nstruct rhash_head __rcu * const *pprev;\r\nstruct nft_hash_elem *he;\r\nu32 h;\r\nh = rhashtable_hashfn(priv, &elem->key, set->klen);\r\npprev = &tbl->buckets[h];\r\nrht_for_each_entry_rcu(he, tbl->buckets[h], node) {\r\nif (nft_data_cmp(&he->key, &elem->key, set->klen)) {\r\npprev = &he->node.next;\r\ncontinue;\r\n}\r\nelem->cookie = (void *)pprev;\r\nelem->flags = 0;\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_copy(&elem->data, he->data);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,\r\nstruct nft_set_iter *iter)\r\n{\r\nconst struct rhashtable *priv = nft_set_priv(set);\r\nconst struct bucket_table *tbl;\r\nconst struct nft_hash_elem *he;\r\nstruct nft_set_elem elem;\r\nunsigned int i;\r\ntbl = rht_dereference_rcu(priv->tbl, priv);\r\nfor (i = 0; i < tbl->size; i++) {\r\nrht_for_each_entry_rcu(he, tbl->buckets[i], node) {\r\nif (iter->count < iter->skip)\r\ngoto cont;\r\nmemcpy(&elem.key, &he->key, sizeof(elem.key));\r\nif (set->flags & NFT_SET_MAP)\r\nmemcpy(&elem.data, he->data, sizeof(elem.data));\r\nelem.flags = 0;\r\niter->err = iter->fn(ctx, set, iter, &elem);\r\nif (iter->err < 0)\r\nreturn;\r\ncont:\r\niter->count++;\r\n}\r\n}\r\n}\r\nstatic unsigned int nft_hash_privsize(const struct nlattr * const nla[])\r\n{\r\nreturn sizeof(struct rhashtable);\r\n}\r\nstatic int lockdep_nfnl_lock_is_held(void)\r\n{\r\nreturn lockdep_nfnl_is_held(NFNL_SUBSYS_NFTABLES);\r\n}\r\nstatic int nft_hash_init(const struct nft_set *set,\r\nconst struct nft_set_desc *desc,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct rhashtable *priv = nft_set_priv(set);\r\nstruct rhashtable_params params = {\r\n.nelem_hint = desc->size ? : NFT_HASH_ELEMENT_HINT,\r\n.head_offset = offsetof(struct nft_hash_elem, node),\r\n.key_offset = offsetof(struct nft_hash_elem, key),\r\n.key_len = set->klen,\r\n.hashfn = jhash,\r\n.grow_decision = rht_grow_above_75,\r\n.shrink_decision = rht_shrink_below_30,\r\n.mutex_is_held = lockdep_nfnl_lock_is_held,\r\n};\r\nreturn rhashtable_init(priv, &params);\r\n}\r\nstatic void nft_hash_destroy(const struct nft_set *set)\r\n{\r\nconst struct rhashtable *priv = nft_set_priv(set);\r\nconst struct bucket_table *tbl = priv->tbl;\r\nstruct nft_hash_elem *he, *next;\r\nunsigned int i;\r\nfor (i = 0; i < tbl->size; i++) {\r\nfor (he = rht_entry(tbl->buckets[i], struct nft_hash_elem, node);\r\nhe != NULL; he = next) {\r\nnext = rht_entry(he->node.next, struct nft_hash_elem, node);\r\nnft_hash_elem_destroy(set, he);\r\n}\r\n}\r\nrhashtable_destroy(priv);\r\n}\r\nstatic bool nft_hash_estimate(const struct nft_set_desc *desc, u32 features,\r\nstruct nft_set_estimate *est)\r\n{\r\nunsigned int esize;\r\nesize = sizeof(struct nft_hash_elem);\r\nif (features & NFT_SET_MAP)\r\nesize += FIELD_SIZEOF(struct nft_hash_elem, data[0]);\r\nif (desc->size) {\r\nest->size = sizeof(struct rhashtable) +\r\nroundup_pow_of_two(desc->size * 4 / 3) *\r\nsizeof(struct nft_hash_elem *) +\r\ndesc->size * esize;\r\n} else {\r\nest->size = esize + 2 * sizeof(struct nft_hash_elem *);\r\n}\r\nest->class = NFT_SET_CLASS_O_1;\r\nreturn true;\r\n}\r\nstatic int __init nft_hash_module_init(void)\r\n{\r\nreturn nft_register_set(&nft_hash_ops);\r\n}\r\nstatic void __exit nft_hash_module_exit(void)\r\n{\r\nnft_unregister_set(&nft_hash_ops);\r\n}
