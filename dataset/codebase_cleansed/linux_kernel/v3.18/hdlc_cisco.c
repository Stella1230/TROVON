static inline struct cisco_state* state(hdlc_device *hdlc)\r\n{\r\nreturn (struct cisco_state *)hdlc->state;\r\n}\r\nstatic int cisco_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nu16 type, const void *daddr, const void *saddr,\r\nunsigned int len)\r\n{\r\nstruct hdlc_header *data;\r\n#ifdef DEBUG_HARD_HEADER\r\nprintk(KERN_DEBUG "%s: cisco_hard_header called\n", dev->name);\r\n#endif\r\nskb_push(skb, sizeof(struct hdlc_header));\r\ndata = (struct hdlc_header*)skb->data;\r\nif (type == CISCO_KEEPALIVE)\r\ndata->address = CISCO_MULTICAST;\r\nelse\r\ndata->address = CISCO_UNICAST;\r\ndata->control = 0;\r\ndata->protocol = htons(type);\r\nreturn sizeof(struct hdlc_header);\r\n}\r\nstatic void cisco_keepalive_send(struct net_device *dev, u32 type,\r\n__be32 par1, __be32 par2)\r\n{\r\nstruct sk_buff *skb;\r\nstruct cisco_packet *data;\r\nskb = dev_alloc_skb(sizeof(struct hdlc_header) +\r\nsizeof(struct cisco_packet));\r\nif (!skb) {\r\nnetdev_warn(dev, "Memory squeeze on cisco_keepalive_send()\n");\r\nreturn;\r\n}\r\nskb_reserve(skb, 4);\r\ncisco_hard_header(skb, dev, CISCO_KEEPALIVE, NULL, NULL, 0);\r\ndata = (struct cisco_packet*)(skb->data + 4);\r\ndata->type = htonl(type);\r\ndata->par1 = par1;\r\ndata->par2 = par2;\r\ndata->rel = cpu_to_be16(0xFFFF);\r\ndata->time = htonl((jiffies - INITIAL_JIFFIES) * (1000 / HZ));\r\nskb_put(skb, sizeof(struct cisco_packet));\r\nskb->priority = TC_PRIO_CONTROL;\r\nskb->dev = dev;\r\nskb_reset_network_header(skb);\r\ndev_queue_xmit(skb);\r\n}\r\nstatic __be16 cisco_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct hdlc_header *data = (struct hdlc_header*)skb->data;\r\nif (skb->len < sizeof(struct hdlc_header))\r\nreturn cpu_to_be16(ETH_P_HDLC);\r\nif (data->address != CISCO_MULTICAST &&\r\ndata->address != CISCO_UNICAST)\r\nreturn cpu_to_be16(ETH_P_HDLC);\r\nswitch (data->protocol) {\r\ncase cpu_to_be16(ETH_P_IP):\r\ncase cpu_to_be16(ETH_P_IPX):\r\ncase cpu_to_be16(ETH_P_IPV6):\r\nskb_pull(skb, sizeof(struct hdlc_header));\r\nreturn data->protocol;\r\ndefault:\r\nreturn cpu_to_be16(ETH_P_HDLC);\r\n}\r\n}\r\nstatic int cisco_rx(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct cisco_state *st = state(hdlc);\r\nstruct hdlc_header *data = (struct hdlc_header*)skb->data;\r\nstruct cisco_packet *cisco_data;\r\nstruct in_device *in_dev;\r\n__be32 addr, mask;\r\nu32 ack;\r\nif (skb->len < sizeof(struct hdlc_header))\r\ngoto rx_error;\r\nif (data->address != CISCO_MULTICAST &&\r\ndata->address != CISCO_UNICAST)\r\ngoto rx_error;\r\nswitch (ntohs(data->protocol)) {\r\ncase CISCO_SYS_INFO:\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_SUCCESS;\r\ncase CISCO_KEEPALIVE:\r\nif ((skb->len != sizeof(struct hdlc_header) +\r\nCISCO_PACKET_LEN) &&\r\n(skb->len != sizeof(struct hdlc_header) +\r\nCISCO_BIG_PACKET_LEN)) {\r\nnetdev_info(dev, "Invalid length of Cisco control packet (%d bytes)\n",\r\nskb->len);\r\ngoto rx_error;\r\n}\r\ncisco_data = (struct cisco_packet*)(skb->data + sizeof\r\n(struct hdlc_header));\r\nswitch (ntohl (cisco_data->type)) {\r\ncase CISCO_ADDR_REQ:\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(dev);\r\naddr = 0;\r\nmask = ~cpu_to_be32(0);\r\nif (in_dev != NULL) {\r\nstruct in_ifaddr **ifap = &in_dev->ifa_list;\r\nwhile (*ifap != NULL) {\r\nif (strcmp(dev->name,\r\n(*ifap)->ifa_label) == 0) {\r\naddr = (*ifap)->ifa_local;\r\nmask = (*ifap)->ifa_mask;\r\nbreak;\r\n}\r\nifap = &(*ifap)->ifa_next;\r\n}\r\ncisco_keepalive_send(dev, CISCO_ADDR_REPLY,\r\naddr, mask);\r\n}\r\nrcu_read_unlock();\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_SUCCESS;\r\ncase CISCO_ADDR_REPLY:\r\nnetdev_info(dev, "Unexpected Cisco IP address reply\n");\r\ngoto rx_error;\r\ncase CISCO_KEEPALIVE_REQ:\r\nspin_lock(&st->lock);\r\nst->rxseq = ntohl(cisco_data->par1);\r\nack = ntohl(cisco_data->par2);\r\nif (ack && (ack == st->txseq ||\r\nack == st->txseq - 1)) {\r\nst->last_poll = jiffies;\r\nif (!st->up) {\r\nu32 sec, min, hrs, days;\r\nsec = ntohl(cisco_data->time) / 1000;\r\nmin = sec / 60; sec -= min * 60;\r\nhrs = min / 60; min -= hrs * 60;\r\ndays = hrs / 24; hrs -= days * 24;\r\nnetdev_info(dev, "Link up (peer uptime %ud%uh%um%us)\n",\r\ndays, hrs, min, sec);\r\nnetif_dormant_off(dev);\r\nst->up = 1;\r\n}\r\n}\r\nspin_unlock(&st->lock);\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\n}\r\nnetdev_info(dev, "Unsupported protocol %x\n", ntohs(data->protocol));\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_DROP;\r\nrx_error:\r\ndev->stats.rx_errors++;\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic void cisco_timer(unsigned long arg)\r\n{\r\nstruct net_device *dev = (struct net_device *)arg;\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct cisco_state *st = state(hdlc);\r\nspin_lock(&st->lock);\r\nif (st->up &&\r\ntime_after(jiffies, st->last_poll + st->settings.timeout * HZ)) {\r\nst->up = 0;\r\nnetdev_info(dev, "Link down\n");\r\nnetif_dormant_on(dev);\r\n}\r\ncisco_keepalive_send(dev, CISCO_KEEPALIVE_REQ, htonl(++st->txseq),\r\nhtonl(st->rxseq));\r\nspin_unlock(&st->lock);\r\nst->timer.expires = jiffies + st->settings.interval * HZ;\r\nst->timer.function = cisco_timer;\r\nst->timer.data = arg;\r\nadd_timer(&st->timer);\r\n}\r\nstatic void cisco_start(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct cisco_state *st = state(hdlc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&st->lock, flags);\r\nst->up = st->txseq = st->rxseq = 0;\r\nspin_unlock_irqrestore(&st->lock, flags);\r\ninit_timer(&st->timer);\r\nst->timer.expires = jiffies + HZ;\r\nst->timer.function = cisco_timer;\r\nst->timer.data = (unsigned long)dev;\r\nadd_timer(&st->timer);\r\n}\r\nstatic void cisco_stop(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nstruct cisco_state *st = state(hdlc);\r\nunsigned long flags;\r\ndel_timer_sync(&st->timer);\r\nspin_lock_irqsave(&st->lock, flags);\r\nnetif_dormant_on(dev);\r\nst->up = st->txseq = 0;\r\nspin_unlock_irqrestore(&st->lock, flags);\r\n}\r\nstatic int cisco_ioctl(struct net_device *dev, struct ifreq *ifr)\r\n{\r\ncisco_proto __user *cisco_s = ifr->ifr_settings.ifs_ifsu.cisco;\r\nconst size_t size = sizeof(cisco_proto);\r\ncisco_proto new_settings;\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nint result;\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_GET_PROTO:\r\nif (dev_to_hdlc(dev)->proto != &proto)\r\nreturn -EINVAL;\r\nifr->ifr_settings.type = IF_PROTO_CISCO;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_to_user(cisco_s, &state(hdlc)->settings, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_PROTO_CISCO:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nif (copy_from_user(&new_settings, cisco_s, size))\r\nreturn -EFAULT;\r\nif (new_settings.interval < 1 ||\r\nnew_settings.timeout < 2)\r\nreturn -EINVAL;\r\nresult = hdlc->attach(dev, ENCODING_NRZ,PARITY_CRC16_PR1_CCITT);\r\nif (result)\r\nreturn result;\r\nresult = attach_hdlc_protocol(dev, &proto,\r\nsizeof(struct cisco_state));\r\nif (result)\r\nreturn result;\r\nmemcpy(&state(hdlc)->settings, &new_settings, size);\r\nspin_lock_init(&state(hdlc)->lock);\r\ndev->header_ops = &cisco_header_ops;\r\ndev->type = ARPHRD_CISCO;\r\nnetif_dormant_on(dev);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init mod_init(void)\r\n{\r\nregister_hdlc_protocol(&proto);\r\nreturn 0;\r\n}\r\nstatic void __exit mod_exit(void)\r\n{\r\nunregister_hdlc_protocol(&proto);\r\n}
