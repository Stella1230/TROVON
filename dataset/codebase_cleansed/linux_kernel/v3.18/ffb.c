static void FFBFifo(struct ffb_par *par, int n)\r\n{\r\nstruct ffb_fbc __iomem *fbc;\r\nint cache = par->fifo_cache;\r\nif (cache - n < 0) {\r\nfbc = par->fbc;\r\ndo {\r\ncache = (upa_readl(&fbc->ucsr) & FFB_UCSR_FIFO_MASK);\r\ncache -= 8;\r\n} while (cache - n < 0);\r\n}\r\npar->fifo_cache = cache - n;\r\n}\r\nstatic void FFBWait(struct ffb_par *par)\r\n{\r\nstruct ffb_fbc __iomem *fbc;\r\nint limit = 10000;\r\nfbc = par->fbc;\r\ndo {\r\nif ((upa_readl(&fbc->ucsr) & FFB_UCSR_ALL_BUSY) == 0)\r\nbreak;\r\nif ((upa_readl(&fbc->ucsr) & FFB_UCSR_ALL_ERRORS) != 0) {\r\nupa_writel(FFB_UCSR_ALL_ERRORS, &fbc->ucsr);\r\n}\r\nudelay(10);\r\n} while (--limit > 0);\r\n}\r\nstatic int ffb_sync(struct fb_info *p)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)p->par;\r\nFFBWait(par);\r\nreturn 0;\r\n}\r\nstatic __inline__ void ffb_rop(struct ffb_par *par, u32 rop)\r\n{\r\nif (par->rop_cache != rop) {\r\nFFBFifo(par, 1);\r\nupa_writel(rop, &par->fbc->rop);\r\npar->rop_cache = rop;\r\n}\r\n}\r\nstatic void ffb_switch_from_graph(struct ffb_par *par)\r\n{\r\nstruct ffb_fbc __iomem *fbc = par->fbc;\r\nstruct ffb_dac __iomem *dac = par->dac;\r\nunsigned long flags;\r\nspin_lock_irqsave(&par->lock, flags);\r\nFFBWait(par);\r\npar->fifo_cache = 0;\r\nFFBFifo(par, 7);\r\nupa_writel(FFB_PPC_VCE_DISABLE | FFB_PPC_TBE_OPAQUE |\r\nFFB_PPC_APE_DISABLE | FFB_PPC_CS_CONST,\r\n&fbc->ppc);\r\nupa_writel(0x2000707f, &fbc->fbc);\r\nupa_writel(par->rop_cache, &fbc->rop);\r\nupa_writel(0xffffffff, &fbc->pmask);\r\nupa_writel((1 << 16) | (0 << 0), &fbc->fontinc);\r\nupa_writel(par->fg_cache, &fbc->fg);\r\nupa_writel(par->bg_cache, &fbc->bg);\r\nFFBWait(par);\r\nupa_writel(FFB_DAC_CUR_CTRL, &dac->type2);\r\nif (par->flags & FFB_FLAG_INVCURSOR)\r\nupa_writel(0, &dac->value2);\r\nelse\r\nupa_writel((FFB_DAC_CUR_CTRL_P0 |\r\nFFB_DAC_CUR_CTRL_P1), &dac->value2);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic int ffb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)info->par;\r\nffb_switch_from_graph(par);\r\nif (var->xoffset || var->yoffset || var->vmode)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void ffb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)info->par;\r\nstruct ffb_fbc __iomem *fbc = par->fbc;\r\nunsigned long flags;\r\nu32 fg;\r\nBUG_ON(rect->rop != ROP_COPY && rect->rop != ROP_XOR);\r\nfg = ((u32 *)info->pseudo_palette)[rect->color];\r\nspin_lock_irqsave(&par->lock, flags);\r\nif (fg != par->fg_cache) {\r\nFFBFifo(par, 1);\r\nupa_writel(fg, &fbc->fg);\r\npar->fg_cache = fg;\r\n}\r\nffb_rop(par, rect->rop == ROP_COPY ?\r\nFFB_ROP_NEW :\r\nFFB_ROP_NEW_XOR_OLD);\r\nFFBFifo(par, 5);\r\nupa_writel(FFB_DRAWOP_RECTANGLE, &fbc->drawop);\r\nupa_writel(rect->dy, &fbc->by);\r\nupa_writel(rect->dx, &fbc->bx);\r\nupa_writel(rect->height, &fbc->bh);\r\nupa_writel(rect->width, &fbc->bw);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic void ffb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)info->par;\r\nstruct ffb_fbc __iomem *fbc = par->fbc;\r\nunsigned long flags;\r\nif (area->dx != area->sx ||\r\narea->dy == area->sy) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&par->lock, flags);\r\nffb_rop(par, FFB_ROP_OLD);\r\nFFBFifo(par, 7);\r\nupa_writel(FFB_DRAWOP_VSCROLL, &fbc->drawop);\r\nupa_writel(area->sy, &fbc->by);\r\nupa_writel(area->sx, &fbc->bx);\r\nupa_writel(area->dy, &fbc->dy);\r\nupa_writel(area->dx, &fbc->dx);\r\nupa_writel(area->height, &fbc->bh);\r\nupa_writel(area->width, &fbc->bw);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic void ffb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)info->par;\r\nstruct ffb_fbc __iomem *fbc = par->fbc;\r\nconst u8 *data = image->data;\r\nunsigned long flags;\r\nu32 fg, bg, xy;\r\nu64 fgbg;\r\nint i, width, stride;\r\nif (image->depth > 1) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nfg = ((u32 *)info->pseudo_palette)[image->fg_color];\r\nbg = ((u32 *)info->pseudo_palette)[image->bg_color];\r\nfgbg = ((u64) fg << 32) | (u64) bg;\r\nxy = (image->dy << 16) | image->dx;\r\nwidth = image->width;\r\nstride = ((width + 7) >> 3);\r\nspin_lock_irqsave(&par->lock, flags);\r\nif (fgbg != *(u64 *)&par->fg_cache) {\r\nFFBFifo(par, 2);\r\nupa_writeq(fgbg, &fbc->fg);\r\n*(u64 *)&par->fg_cache = fgbg;\r\n}\r\nif (width >= 32) {\r\nFFBFifo(par, 1);\r\nupa_writel(32, &fbc->fontw);\r\n}\r\nwhile (width >= 32) {\r\nconst u8 *next_data = data + 4;\r\nFFBFifo(par, 1);\r\nupa_writel(xy, &fbc->fontxy);\r\nxy += (32 << 0);\r\nfor (i = 0; i < image->height; i++) {\r\nu32 val = (((u32)data[0] << 24) |\r\n((u32)data[1] << 16) |\r\n((u32)data[2] << 8) |\r\n((u32)data[3] << 0));\r\nFFBFifo(par, 1);\r\nupa_writel(val, &fbc->font);\r\ndata += stride;\r\n}\r\ndata = next_data;\r\nwidth -= 32;\r\n}\r\nif (width) {\r\nFFBFifo(par, 2);\r\nupa_writel(width, &fbc->fontw);\r\nupa_writel(xy, &fbc->fontxy);\r\nfor (i = 0; i < image->height; i++) {\r\nu32 val = (((u32)data[0] << 24) |\r\n((u32)data[1] << 16) |\r\n((u32)data[2] << 8) |\r\n((u32)data[3] << 0));\r\nFFBFifo(par, 1);\r\nupa_writel(val, &fbc->font);\r\ndata += stride;\r\n}\r\n}\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic void ffb_fixup_var_rgb(struct fb_var_screeninfo *var)\r\n{\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\n}\r\nstatic int ffb_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nu32 value;\r\nif (regno >= 16)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nvalue = (blue << 16) | (green << 8) | red;\r\n((u32 *)info->pseudo_palette)[regno] = value;\r\nreturn 0;\r\n}\r\nstatic int ffb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)info->par;\r\nstruct ffb_dac __iomem *dac = par->dac;\r\nunsigned long flags;\r\nu32 val;\r\nint i;\r\nspin_lock_irqsave(&par->lock, flags);\r\nFFBWait(par);\r\nupa_writel(FFB_DAC_TGEN, &dac->type);\r\nval = upa_readl(&dac->value);\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nval |= FFB_DAC_TGEN_VIDE;\r\npar->flags &= ~FFB_FLAG_BLANKED;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nval &= ~FFB_DAC_TGEN_VIDE;\r\npar->flags |= FFB_FLAG_BLANKED;\r\nbreak;\r\n}\r\nupa_writel(FFB_DAC_TGEN, &dac->type);\r\nupa_writel(val, &dac->value);\r\nfor (i = 0; i < 10; i++) {\r\nupa_writel(FFB_DAC_TGEN, &dac->type);\r\nupa_readl(&dac->value);\r\n}\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ffb_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)info->par;\r\nreturn sbusfb_mmap_helper(ffb_mmap_map,\r\npar->physbase, par->fbsize,\r\n0, vma);\r\n}\r\nstatic int ffb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)info->par;\r\nreturn sbusfb_ioctl_helper(cmd, arg, info,\r\nFBTYPE_CREATOR, 24, par->fbsize);\r\n}\r\nstatic void ffb_init_fix(struct fb_info *info)\r\n{\r\nstruct ffb_par *par = (struct ffb_par *)info->par;\r\nconst char *ffb_type_name;\r\nif (!(par->flags & FFB_FLAG_AFB)) {\r\nif ((par->board_type & 0x7) == 0x3)\r\nffb_type_name = "Creator 3D";\r\nelse\r\nffb_type_name = "Creator";\r\n} else\r\nffb_type_name = "Elite 3D";\r\nstrlcpy(info->fix.id, ffb_type_name, sizeof(info->fix.id));\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = 8192;\r\ninfo->fix.accel = FB_ACCEL_SUN_CREATOR;\r\n}\r\nstatic int ffb_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct ffb_fbc __iomem *fbc;\r\nstruct ffb_dac __iomem *dac;\r\nstruct fb_info *info;\r\nstruct ffb_par *par;\r\nu32 dac_pnum, dac_rev, dac_mrev;\r\nint err;\r\ninfo = framebuffer_alloc(sizeof(struct ffb_par), &op->dev);\r\nerr = -ENOMEM;\r\nif (!info)\r\ngoto out_err;\r\npar = info->par;\r\nspin_lock_init(&par->lock);\r\npar->fbc = of_ioremap(&op->resource[2], 0,\r\nsizeof(struct ffb_fbc), "ffb fbc");\r\nif (!par->fbc)\r\ngoto out_release_fb;\r\npar->dac = of_ioremap(&op->resource[1], 0,\r\nsizeof(struct ffb_dac), "ffb dac");\r\nif (!par->dac)\r\ngoto out_unmap_fbc;\r\npar->rop_cache = FFB_ROP_NEW;\r\npar->physbase = op->resource[0].start;\r\ninfo->flags = (FBINFO_DEFAULT |\r\nFBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_IMAGEBLIT);\r\ninfo->fbops = &ffb_ops;\r\ninfo->screen_base = (char *) par->physbase + FFB_DFB24_POFF;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\nsbusfb_fill_var(&info->var, dp, 32);\r\npar->fbsize = PAGE_ALIGN(info->var.xres * info->var.yres * 4);\r\nffb_fixup_var_rgb(&info->var);\r\ninfo->var.accel_flags = FB_ACCELF_TEXT;\r\nif (!strcmp(dp->name, "SUNW,afb"))\r\npar->flags |= FFB_FLAG_AFB;\r\npar->board_type = of_getintprop_default(dp, "board_type", 0);\r\nfbc = par->fbc;\r\nif ((upa_readl(&fbc->ucsr) & FFB_UCSR_ALL_ERRORS) != 0)\r\nupa_writel(FFB_UCSR_ALL_ERRORS, &fbc->ucsr);\r\ndac = par->dac;\r\nupa_writel(FFB_DAC_DID, &dac->type);\r\ndac_pnum = upa_readl(&dac->value);\r\ndac_rev = (dac_pnum & FFB_DAC_DID_REV) >> FFB_DAC_DID_REV_SHIFT;\r\ndac_pnum = (dac_pnum & FFB_DAC_DID_PNUM) >> FFB_DAC_DID_PNUM_SHIFT;\r\nupa_writel(FFB_DAC_UCTRL, &dac->type);\r\ndac_mrev = upa_readl(&dac->value);\r\ndac_mrev = (dac_mrev & FFB_DAC_UCTRL_MANREV) >>\r\nFFB_DAC_UCTRL_MANREV_SHIFT;\r\nif ((par->flags & FFB_FLAG_AFB) || dac_pnum == 0x236e) {\r\npar->flags &= ~FFB_FLAG_INVCURSOR;\r\n} else {\r\nif (dac_mrev < 3)\r\npar->flags |= FFB_FLAG_INVCURSOR;\r\n}\r\nffb_switch_from_graph(par);\r\nffb_blank(FB_BLANK_UNBLANK, info);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0))\r\ngoto out_unmap_dac;\r\nffb_init_fix(info);\r\nerr = register_framebuffer(info);\r\nif (err < 0)\r\ngoto out_dealloc_cmap;\r\ndev_set_drvdata(&op->dev, info);\r\nprintk(KERN_INFO "%s: %s at %016lx, type %d, "\r\n"DAC pnum[%x] rev[%d] manuf_rev[%d]\n",\r\ndp->full_name,\r\n((par->flags & FFB_FLAG_AFB) ? "AFB" : "FFB"),\r\npar->physbase, par->board_type,\r\ndac_pnum, dac_rev, dac_mrev);\r\nreturn 0;\r\nout_dealloc_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nout_unmap_dac:\r\nof_iounmap(&op->resource[1], par->dac, sizeof(struct ffb_dac));\r\nout_unmap_fbc:\r\nof_iounmap(&op->resource[2], par->fbc, sizeof(struct ffb_fbc));\r\nout_release_fb:\r\nframebuffer_release(info);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int ffb_remove(struct platform_device *op)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&op->dev);\r\nstruct ffb_par *par = info->par;\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nof_iounmap(&op->resource[2], par->fbc, sizeof(struct ffb_fbc));\r\nof_iounmap(&op->resource[1], par->dac, sizeof(struct ffb_dac));\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int __init ffb_init(void)\r\n{\r\nif (fb_get_options("ffb", NULL))\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&ffb_driver);\r\n}\r\nstatic void __exit ffb_exit(void)\r\n{\r\nplatform_driver_unregister(&ffb_driver);\r\n}
