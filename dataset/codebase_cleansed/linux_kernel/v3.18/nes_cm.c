int nes_add_ref_cm_node(struct nes_cm_node *cm_node)\r\n{\r\nreturn add_ref_cm_node(cm_node);\r\n}\r\nint nes_rem_ref_cm_node(struct nes_cm_node *cm_node)\r\n{\r\nreturn rem_ref_cm_node(cm_node->cm_core, cm_node);\r\n}\r\nstatic struct nes_cm_event *create_event(struct nes_cm_node * cm_node,\r\nenum nes_cm_event_type type)\r\n{\r\nstruct nes_cm_event *event;\r\nif (!cm_node->cm_id)\r\nreturn NULL;\r\nevent = kzalloc(sizeof(*event), GFP_ATOMIC);\r\nif (!event)\r\nreturn NULL;\r\nevent->type = type;\r\nevent->cm_node = cm_node;\r\nevent->cm_info.rem_addr = cm_node->rem_addr;\r\nevent->cm_info.loc_addr = cm_node->loc_addr;\r\nevent->cm_info.rem_port = cm_node->rem_port;\r\nevent->cm_info.loc_port = cm_node->loc_port;\r\nevent->cm_info.cm_id = cm_node->cm_id;\r\nnes_debug(NES_DBG_CM, "cm_node=%p Created event=%p, type=%u, "\r\n"dst_addr=%08x[%x], src_addr=%08x[%x]\n",\r\ncm_node, event, type, event->cm_info.loc_addr,\r\nevent->cm_info.loc_port, event->cm_info.rem_addr,\r\nevent->cm_info.rem_port);\r\nnes_cm_post_event(event);\r\nreturn event;\r\n}\r\nstatic int send_mpa_request(struct nes_cm_node *cm_node, struct sk_buff *skb)\r\n{\r\nu8 start_addr = 0;\r\nu8 *start_ptr = &start_addr;\r\nu8 **start_buff = &start_ptr;\r\nu16 buff_len = 0;\r\nif (!skb) {\r\nnes_debug(NES_DBG_CM, "skb set to NULL\n");\r\nreturn -1;\r\n}\r\ncm_build_mpa_frame(cm_node, start_buff, &buff_len, NULL, MPA_KEY_REQUEST);\r\nform_cm_frame(skb, cm_node, NULL, 0, *start_buff, buff_len, SET_ACK);\r\nreturn schedule_nes_timer(cm_node, skb, NES_TIMER_TYPE_SEND, 1, 0);\r\n}\r\nstatic int send_mpa_reject(struct nes_cm_node *cm_node)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nu8 start_addr = 0;\r\nu8 *start_ptr = &start_addr;\r\nu8 **start_buff = &start_ptr;\r\nu16 buff_len = 0;\r\nstruct ietf_mpa_v1 *mpa_frame;\r\nskb = dev_alloc_skb(MAX_CM_BUFFER);\r\nif (!skb) {\r\nnes_debug(NES_DBG_CM, "Failed to get a Free pkt\n");\r\nreturn -ENOMEM;\r\n}\r\ncm_build_mpa_frame(cm_node, start_buff, &buff_len, NULL, MPA_KEY_REPLY);\r\nmpa_frame = (struct ietf_mpa_v1 *)*start_buff;\r\nmpa_frame->flags |= IETF_MPA_FLAGS_REJECT;\r\nform_cm_frame(skb, cm_node, NULL, 0, *start_buff, buff_len, SET_ACK | SET_FIN);\r\ncm_node->state = NES_CM_STATE_FIN_WAIT1;\r\nreturn schedule_nes_timer(cm_node, skb, NES_TIMER_TYPE_SEND, 1, 0);\r\n}\r\nstatic int parse_mpa(struct nes_cm_node *cm_node, u8 *buffer, u32 *type,\r\nu32 len)\r\n{\r\nstruct ietf_mpa_v1 *mpa_frame;\r\nstruct ietf_mpa_v2 *mpa_v2_frame;\r\nstruct ietf_rtr_msg *rtr_msg;\r\nint mpa_hdr_len;\r\nint priv_data_len;\r\n*type = NES_MPA_REQUEST_ACCEPT;\r\nif (len < sizeof(struct ietf_mpa_v1)) {\r\nnes_debug(NES_DBG_CM, "The received ietf buffer was too small (%x)\n", len);\r\nreturn -EINVAL;\r\n}\r\nmpa_frame = (struct ietf_mpa_v1 *)buffer;\r\nmpa_hdr_len = sizeof(struct ietf_mpa_v1);\r\npriv_data_len = ntohs(mpa_frame->priv_data_len);\r\nif (priv_data_len > IETF_MAX_PRIV_DATA_LEN) {\r\nnes_debug(NES_DBG_CM, "The received Length of Private"\r\n" Data field exceeds 512 octets\n");\r\nreturn -EINVAL;\r\n}\r\nif (mpa_frame->rev != IETF_MPA_V1 && mpa_frame->rev != IETF_MPA_V2) {\r\nnes_debug(NES_DBG_CM, "The received mpa version"\r\n" is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (mpa_frame->rev > cm_node->mpa_frame_rev) {\r\nnes_debug(NES_DBG_CM, "The received mpa version"\r\n" can not be interoperated\n");\r\nreturn -EINVAL;\r\n} else {\r\ncm_node->mpa_frame_rev = mpa_frame->rev;\r\n}\r\nif (cm_node->state != NES_CM_STATE_MPAREQ_SENT) {\r\nif (memcmp(mpa_frame->key, IEFT_MPA_KEY_REQ, IETF_MPA_KEY_SIZE)) {\r\nnes_debug(NES_DBG_CM, "Unexpected MPA Key received \n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (memcmp(mpa_frame->key, IEFT_MPA_KEY_REP, IETF_MPA_KEY_SIZE)) {\r\nnes_debug(NES_DBG_CM, "Unexpected MPA Key received \n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (priv_data_len + mpa_hdr_len != len) {\r\nnes_debug(NES_DBG_CM, "The received ietf buffer was not right"\r\n" complete (%x + %x != %x)\n",\r\npriv_data_len, mpa_hdr_len, len);\r\nreturn -EINVAL;\r\n}\r\nif (len > MAX_CM_BUFFER) {\r\nnes_debug(NES_DBG_CM, "The received ietf buffer was too large"\r\n" (%x + %x != %x)\n",\r\npriv_data_len, mpa_hdr_len, len);\r\nreturn -EINVAL;\r\n}\r\ncm_node->mpa_frame_size = priv_data_len;\r\nswitch (mpa_frame->rev) {\r\ncase IETF_MPA_V2: {\r\nu16 ird_size;\r\nu16 ord_size;\r\nu16 rtr_ctrl_ird;\r\nu16 rtr_ctrl_ord;\r\nmpa_v2_frame = (struct ietf_mpa_v2 *)buffer;\r\nmpa_hdr_len += IETF_RTR_MSG_SIZE;\r\ncm_node->mpa_frame_size -= IETF_RTR_MSG_SIZE;\r\nrtr_msg = &mpa_v2_frame->rtr_msg;\r\nrtr_ctrl_ird = ntohs(rtr_msg->ctrl_ird);\r\nrtr_ctrl_ord = ntohs(rtr_msg->ctrl_ord);\r\nird_size = rtr_ctrl_ird & IETF_NO_IRD_ORD;\r\nord_size = rtr_ctrl_ord & IETF_NO_IRD_ORD;\r\nif (!(rtr_ctrl_ird & IETF_PEER_TO_PEER)) {\r\nreturn -EINVAL;\r\n}\r\nif (ird_size == IETF_NO_IRD_ORD || ord_size == IETF_NO_IRD_ORD)\r\ncm_node->mpav2_ird_ord = IETF_NO_IRD_ORD;\r\nif (cm_node->mpav2_ird_ord != IETF_NO_IRD_ORD) {\r\nif (cm_node->state != NES_CM_STATE_MPAREQ_SENT) {\r\nif (ord_size > NES_MAX_IRD) {\r\ncm_node->ird_size = NES_MAX_IRD;\r\n} else {\r\ncm_node->ird_size = ord_size;\r\nif (ord_size == 0 &&\r\n(rtr_ctrl_ord & IETF_RDMA0_READ)) {\r\ncm_node->ird_size = 1;\r\nnes_debug(NES_DBG_CM,\r\n"%s: Remote peer doesn't support RDMA0_READ (ord=%u)\n",\r\n__func__, ord_size);\r\n}\r\n}\r\nif (ird_size > NES_MAX_ORD)\r\ncm_node->ord_size = NES_MAX_ORD;\r\nelse\r\ncm_node->ord_size = ird_size;\r\n} else {\r\nif (ord_size > NES_MAX_IRD) {\r\nnes_debug(NES_DBG_CM,\r\n"%s: Unable to support the requested (ord =%u)\n",\r\n__func__, ord_size);\r\nreturn -EINVAL;\r\n}\r\ncm_node->ird_size = ord_size;\r\nif (ird_size > NES_MAX_ORD) {\r\ncm_node->ord_size = NES_MAX_ORD;\r\n} else {\r\nif (ird_size == 0 &&\r\n(rtr_ctrl_ord & IETF_RDMA0_READ)) {\r\nnes_debug(NES_DBG_CM,\r\n"%s: Remote peer doesn't support RDMA0_READ (ird=%u)\n",\r\n__func__, ird_size);\r\nreturn -EINVAL;\r\n} else {\r\ncm_node->ord_size = ird_size;\r\n}\r\n}\r\n}\r\n}\r\nif (rtr_ctrl_ord & IETF_RDMA0_READ) {\r\ncm_node->send_rdma0_op = SEND_RDMA_READ_ZERO;\r\n} else if (rtr_ctrl_ord & IETF_RDMA0_WRITE) {\r\ncm_node->send_rdma0_op = SEND_RDMA_WRITE_ZERO;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\ncase IETF_MPA_V1:\r\ndefault:\r\nbreak;\r\n}\r\nmemcpy(cm_node->mpa_frame_buf, buffer + mpa_hdr_len, cm_node->mpa_frame_size);\r\nif (mpa_frame->flags & IETF_MPA_FLAGS_REJECT)\r\n*type = NES_MPA_REQUEST_REJECT;\r\nreturn 0;\r\n}\r\nstatic void form_cm_frame(struct sk_buff *skb,\r\nstruct nes_cm_node *cm_node, void *options, u32 optionsize,\r\nvoid *data, u32 datasize, u8 flags)\r\n{\r\nstruct tcphdr *tcph;\r\nstruct iphdr *iph;\r\nstruct ethhdr *ethh;\r\nu8 *buf;\r\nu16 packetsize = sizeof(*iph);\r\npacketsize += sizeof(*tcph);\r\npacketsize += optionsize + datasize;\r\nskb_trim(skb, 0);\r\nmemset(skb->data, 0x00, ETH_HLEN + sizeof(*iph) + sizeof(*tcph));\r\nbuf = skb_put(skb, packetsize + ETH_HLEN);\r\nethh = (struct ethhdr *)buf;\r\nbuf += ETH_HLEN;\r\niph = (struct iphdr *)buf;\r\nbuf += sizeof(*iph);\r\ntcph = (struct tcphdr *)buf;\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, ETH_HLEN);\r\nskb_set_transport_header(skb, ETH_HLEN + sizeof(*iph));\r\nbuf += sizeof(*tcph);\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nif (!(cm_node->netdev->features & NETIF_F_IP_CSUM))\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb->protocol = htons(0x800);\r\nskb->data_len = 0;\r\nskb->mac_len = ETH_HLEN;\r\nmemcpy(ethh->h_dest, cm_node->rem_mac, ETH_ALEN);\r\nmemcpy(ethh->h_source, cm_node->loc_mac, ETH_ALEN);\r\nethh->h_proto = htons(0x0800);\r\niph->version = IPVERSION;\r\niph->ihl = 5;\r\niph->tos = 0;\r\niph->tot_len = htons(packetsize);\r\niph->id = htons(++cm_node->tcp_cntxt.loc_id);\r\niph->frag_off = htons(0x4000);\r\niph->ttl = 0x40;\r\niph->protocol = 0x06;\r\niph->saddr = htonl(cm_node->mapped_loc_addr);\r\niph->daddr = htonl(cm_node->mapped_rem_addr);\r\ntcph->source = htons(cm_node->mapped_loc_port);\r\ntcph->dest = htons(cm_node->mapped_rem_port);\r\ntcph->seq = htonl(cm_node->tcp_cntxt.loc_seq_num);\r\nif (flags & SET_ACK) {\r\ncm_node->tcp_cntxt.loc_ack_num = cm_node->tcp_cntxt.rcv_nxt;\r\ntcph->ack_seq = htonl(cm_node->tcp_cntxt.loc_ack_num);\r\ntcph->ack = 1;\r\n} else {\r\ntcph->ack_seq = 0;\r\n}\r\nif (flags & SET_SYN) {\r\ncm_node->tcp_cntxt.loc_seq_num++;\r\ntcph->syn = 1;\r\n} else {\r\ncm_node->tcp_cntxt.loc_seq_num += datasize;\r\n}\r\nif (flags & SET_FIN) {\r\ncm_node->tcp_cntxt.loc_seq_num++;\r\ntcph->fin = 1;\r\n}\r\nif (flags & SET_RST)\r\ntcph->rst = 1;\r\ntcph->doff = (u16)((sizeof(*tcph) + optionsize + 3) >> 2);\r\ntcph->window = htons(cm_node->tcp_cntxt.rcv_wnd);\r\ntcph->urg_ptr = 0;\r\nif (optionsize)\r\nmemcpy(buf, options, optionsize);\r\nbuf += optionsize;\r\nif (datasize)\r\nmemcpy(buf, data, datasize);\r\nskb_shinfo(skb)->nr_frags = 0;\r\ncm_packets_created++;\r\n}\r\nstatic void nes_create_sockaddr(__be32 ip_addr, __be16 port,\r\nstruct sockaddr_storage *addr)\r\n{\r\nstruct sockaddr_in *nes_sockaddr = (struct sockaddr_in *)addr;\r\nnes_sockaddr->sin_family = AF_INET;\r\nmemcpy(&nes_sockaddr->sin_addr.s_addr, &ip_addr, sizeof(__be32));\r\nnes_sockaddr->sin_port = port;\r\n}\r\nstatic int nes_create_mapinfo(struct nes_cm_info *cm_info)\r\n{\r\nstruct sockaddr_storage local_sockaddr;\r\nstruct sockaddr_storage mapped_sockaddr;\r\nnes_create_sockaddr(htonl(cm_info->loc_addr), htons(cm_info->loc_port),\r\n&local_sockaddr);\r\nnes_create_sockaddr(htonl(cm_info->mapped_loc_addr),\r\nhtons(cm_info->mapped_loc_port), &mapped_sockaddr);\r\nreturn iwpm_create_mapinfo(&local_sockaddr,\r\n&mapped_sockaddr, RDMA_NL_NES);\r\n}\r\nstatic int nes_remove_mapinfo(u32 loc_addr, u16 loc_port,\r\nu32 mapped_loc_addr, u16 mapped_loc_port)\r\n{\r\nstruct sockaddr_storage local_sockaddr;\r\nstruct sockaddr_storage mapped_sockaddr;\r\nnes_create_sockaddr(htonl(loc_addr), htons(loc_port), &local_sockaddr);\r\nnes_create_sockaddr(htonl(mapped_loc_addr), htons(mapped_loc_port),\r\n&mapped_sockaddr);\r\niwpm_remove_mapinfo(&local_sockaddr, &mapped_sockaddr);\r\nreturn iwpm_remove_mapping(&local_sockaddr, RDMA_NL_NES);\r\n}\r\nstatic void nes_form_pm_msg(struct nes_cm_info *cm_info,\r\nstruct iwpm_sa_data *pm_msg)\r\n{\r\nnes_create_sockaddr(htonl(cm_info->loc_addr), htons(cm_info->loc_port),\r\n&pm_msg->loc_addr);\r\nnes_create_sockaddr(htonl(cm_info->rem_addr), htons(cm_info->rem_port),\r\n&pm_msg->rem_addr);\r\n}\r\nstatic void nes_form_reg_msg(struct nes_vnic *nesvnic,\r\nstruct iwpm_dev_data *pm_msg)\r\n{\r\nmemcpy(pm_msg->dev_name, nesvnic->nesibdev->ibdev.name,\r\nIWPM_DEVNAME_SIZE);\r\nmemcpy(pm_msg->if_name, nesvnic->netdev->name, IWPM_IFNAME_SIZE);\r\n}\r\nstatic void nes_record_pm_msg(struct nes_cm_info *cm_info,\r\nstruct iwpm_sa_data *pm_msg)\r\n{\r\nstruct sockaddr_in *mapped_loc_addr =\r\n(struct sockaddr_in *)&pm_msg->mapped_loc_addr;\r\nstruct sockaddr_in *mapped_rem_addr =\r\n(struct sockaddr_in *)&pm_msg->mapped_rem_addr;\r\nif (mapped_loc_addr->sin_family == AF_INET) {\r\ncm_info->mapped_loc_addr =\r\nntohl(mapped_loc_addr->sin_addr.s_addr);\r\ncm_info->mapped_loc_port = ntohs(mapped_loc_addr->sin_port);\r\n}\r\nif (mapped_rem_addr->sin_family == AF_INET) {\r\ncm_info->mapped_rem_addr =\r\nntohl(mapped_rem_addr->sin_addr.s_addr);\r\ncm_info->mapped_rem_port = ntohs(mapped_rem_addr->sin_port);\r\n}\r\n}\r\nstatic void print_core(struct nes_cm_core *core)\r\n{\r\nnes_debug(NES_DBG_CM, "---------------------------------------------\n");\r\nnes_debug(NES_DBG_CM, "CM Core -- (core = %p )\n", core);\r\nif (!core)\r\nreturn;\r\nnes_debug(NES_DBG_CM, "---------------------------------------------\n");\r\nnes_debug(NES_DBG_CM, "State : %u \n", core->state);\r\nnes_debug(NES_DBG_CM, "Listen Nodes : %u \n", atomic_read(&core->listen_node_cnt));\r\nnes_debug(NES_DBG_CM, "Active Nodes : %u \n", atomic_read(&core->node_cnt));\r\nnes_debug(NES_DBG_CM, "core : %p \n", core);\r\nnes_debug(NES_DBG_CM, "-------------- end core ---------------\n");\r\n}\r\nstatic void record_ird_ord(struct nes_cm_node *cm_node,\r\nu16 conn_ird, u16 conn_ord)\r\n{\r\nif (conn_ird > NES_MAX_IRD)\r\nconn_ird = NES_MAX_IRD;\r\nif (conn_ord > NES_MAX_ORD)\r\nconn_ord = NES_MAX_ORD;\r\ncm_node->ird_size = conn_ird;\r\ncm_node->ord_size = conn_ord;\r\n}\r\nstatic int cm_build_mpa_frame(struct nes_cm_node *cm_node, u8 **start_buff,\r\nu16 *buff_len, u8 *pci_mem, u8 mpa_key)\r\n{\r\nint ret = 0;\r\n*start_buff = (pci_mem) ? pci_mem : &cm_node->mpa_frame_buf[0];\r\nswitch (cm_node->mpa_frame_rev) {\r\ncase IETF_MPA_V1:\r\n*start_buff = (u8 *)*start_buff + sizeof(struct ietf_rtr_msg);\r\n*buff_len = sizeof(struct ietf_mpa_v1) + cm_node->mpa_frame_size;\r\nbuild_mpa_v1(cm_node, *start_buff, mpa_key);\r\nbreak;\r\ncase IETF_MPA_V2:\r\n*buff_len = sizeof(struct ietf_mpa_v2) + cm_node->mpa_frame_size;\r\nbuild_mpa_v2(cm_node, *start_buff, mpa_key);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void build_mpa_v2(struct nes_cm_node *cm_node,\r\nvoid *start_addr, u8 mpa_key)\r\n{\r\nstruct ietf_mpa_v2 *mpa_frame = (struct ietf_mpa_v2 *)start_addr;\r\nstruct ietf_rtr_msg *rtr_msg = &mpa_frame->rtr_msg;\r\nu16 ctrl_ird;\r\nu16 ctrl_ord;\r\nbuild_mpa_v1(cm_node, start_addr, mpa_key);\r\nmpa_frame->flags |= IETF_MPA_V2_FLAG;\r\nmpa_frame->priv_data_len += htons(IETF_RTR_MSG_SIZE);\r\nif (cm_node->mpav2_ird_ord == IETF_NO_IRD_ORD) {\r\nctrl_ird = IETF_NO_IRD_ORD;\r\nctrl_ord = IETF_NO_IRD_ORD;\r\n} else {\r\nctrl_ird = cm_node->ird_size & IETF_NO_IRD_ORD;\r\nctrl_ord = cm_node->ord_size & IETF_NO_IRD_ORD;\r\n}\r\nctrl_ird |= IETF_PEER_TO_PEER;\r\nctrl_ird |= IETF_FLPDU_ZERO_LEN;\r\nswitch (mpa_key) {\r\ncase MPA_KEY_REQUEST:\r\nctrl_ord |= IETF_RDMA0_WRITE;\r\nctrl_ord |= IETF_RDMA0_READ;\r\nbreak;\r\ncase MPA_KEY_REPLY:\r\nswitch (cm_node->send_rdma0_op) {\r\ncase SEND_RDMA_WRITE_ZERO:\r\nctrl_ord |= IETF_RDMA0_WRITE;\r\nbreak;\r\ncase SEND_RDMA_READ_ZERO:\r\nctrl_ord |= IETF_RDMA0_READ;\r\nbreak;\r\n}\r\n}\r\nrtr_msg->ctrl_ird = htons(ctrl_ird);\r\nrtr_msg->ctrl_ord = htons(ctrl_ord);\r\n}\r\nstatic void build_mpa_v1(struct nes_cm_node *cm_node, void *start_addr, u8 mpa_key)\r\n{\r\nstruct ietf_mpa_v1 *mpa_frame = (struct ietf_mpa_v1 *)start_addr;\r\nswitch (mpa_key) {\r\ncase MPA_KEY_REQUEST:\r\nmemcpy(mpa_frame->key, IEFT_MPA_KEY_REQ, IETF_MPA_KEY_SIZE);\r\nbreak;\r\ncase MPA_KEY_REPLY:\r\nmemcpy(mpa_frame->key, IEFT_MPA_KEY_REP, IETF_MPA_KEY_SIZE);\r\nbreak;\r\n}\r\nmpa_frame->flags = IETF_MPA_FLAGS_CRC;\r\nmpa_frame->rev = cm_node->mpa_frame_rev;\r\nmpa_frame->priv_data_len = htons(cm_node->mpa_frame_size);\r\n}\r\nstatic void build_rdma0_msg(struct nes_cm_node *cm_node, struct nes_qp **nesqp_addr)\r\n{\r\nu64 u64temp;\r\nstruct nes_qp *nesqp = *nesqp_addr;\r\nstruct nes_hw_qp_wqe *wqe = &nesqp->hwqp.sq_vbase[0];\r\nu64temp = (unsigned long)nesqp->nesuqp_addr;\r\nu64temp |= NES_SW_CONTEXT_ALIGN >> 1;\r\nset_wqe_64bit_value(wqe->wqe_words, NES_IWARP_SQ_WQE_COMP_CTX_LOW_IDX, u64temp);\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_FRAG0_LOW_IDX] = 0;\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_FRAG0_HIGH_IDX] = 0;\r\nswitch (cm_node->send_rdma0_op) {\r\ncase SEND_RDMA_WRITE_ZERO:\r\nnes_debug(NES_DBG_CM, "Sending first write.\n");\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_MISC_IDX] =\r\ncpu_to_le32(NES_IWARP_SQ_OP_RDMAW);\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_TOTAL_PAYLOAD_IDX] = 0;\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_LENGTH0_IDX] = 0;\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_STAG0_IDX] = 0;\r\nbreak;\r\ncase SEND_RDMA_READ_ZERO:\r\ndefault:\r\nif (cm_node->send_rdma0_op != SEND_RDMA_READ_ZERO)\r\nWARN(1, "Unsupported RDMA0 len operation=%u\n",\r\ncm_node->send_rdma0_op);\r\nnes_debug(NES_DBG_CM, "Sending first rdma operation.\n");\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_MISC_IDX] =\r\ncpu_to_le32(NES_IWARP_SQ_OP_RDMAR);\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_RDMA_TO_LOW_IDX] = 1;\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_RDMA_TO_HIGH_IDX] = 0;\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_RDMA_LENGTH_IDX] = 0;\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_RDMA_STAG_IDX] = 1;\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_STAG0_IDX] = 1;\r\nbreak;\r\n}\r\nif (nesqp->sq_kmapped) {\r\nnesqp->sq_kmapped = 0;\r\nkunmap(nesqp->page);\r\n}\r\nnesqp->nesqp_context->ird_ord_sizes &= cpu_to_le32(~(NES_QPCONTEXT_ORDIRD_LSMM_PRESENT |\r\nNES_QPCONTEXT_ORDIRD_WRPDU |\r\nNES_QPCONTEXT_ORDIRD_ALSMM));\r\nnesqp->skip_lsmm = 1;\r\nnesqp->hwqp.sq_tail = 0;\r\n}\r\nint schedule_nes_timer(struct nes_cm_node *cm_node, struct sk_buff *skb,\r\nenum nes_timer_type type, int send_retrans,\r\nint close_when_complete)\r\n{\r\nunsigned long flags;\r\nstruct nes_cm_core *cm_core = cm_node->cm_core;\r\nstruct nes_timer_entry *new_send;\r\nint ret = 0;\r\nnew_send = kzalloc(sizeof(*new_send), GFP_ATOMIC);\r\nif (!new_send)\r\nreturn -ENOMEM;\r\nnew_send->retrycount = NES_DEFAULT_RETRYS;\r\nnew_send->retranscount = NES_DEFAULT_RETRANS;\r\nnew_send->skb = skb;\r\nnew_send->timetosend = jiffies;\r\nnew_send->type = type;\r\nnew_send->netdev = cm_node->netdev;\r\nnew_send->send_retrans = send_retrans;\r\nnew_send->close_when_complete = close_when_complete;\r\nif (type == NES_TIMER_TYPE_CLOSE) {\r\nnew_send->timetosend += (HZ / 10);\r\nif (cm_node->recv_entry) {\r\nkfree(new_send);\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\ncm_node->recv_entry = new_send;\r\n}\r\nif (type == NES_TIMER_TYPE_SEND) {\r\nnew_send->seq_num = ntohl(tcp_hdr(skb)->seq);\r\natomic_inc(&new_send->skb->users);\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\ncm_node->send_entry = new_send;\r\nadd_ref_cm_node(cm_node);\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\r\nnew_send->timetosend = jiffies + NES_RETRY_TIMEOUT;\r\nret = nes_nic_cm_xmit(new_send->skb, cm_node->netdev);\r\nif (ret != NETDEV_TX_OK) {\r\nnes_debug(NES_DBG_CM, "Error sending packet %p "\r\n"(jiffies = %lu)\n", new_send, jiffies);\r\nnew_send->timetosend = jiffies;\r\nret = NETDEV_TX_OK;\r\n} else {\r\ncm_packets_sent++;\r\nif (!send_retrans) {\r\ncleanup_retrans_entry(cm_node);\r\nif (close_when_complete)\r\nrem_ref_cm_node(cm_core, cm_node);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nif (!timer_pending(&cm_core->tcp_timer))\r\nmod_timer(&cm_core->tcp_timer, new_send->timetosend);\r\nreturn ret;\r\n}\r\nstatic void nes_retrans_expired(struct nes_cm_node *cm_node)\r\n{\r\nstruct iw_cm_id *cm_id = cm_node->cm_id;\r\nenum nes_cm_node_state state = cm_node->state;\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nswitch (state) {\r\ncase NES_CM_STATE_SYN_RCVD:\r\ncase NES_CM_STATE_CLOSING:\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\nbreak;\r\ncase NES_CM_STATE_LAST_ACK:\r\ncase NES_CM_STATE_FIN_WAIT1:\r\nif (cm_node->cm_id)\r\ncm_id->rem_ref(cm_id);\r\nsend_reset(cm_node, NULL);\r\nbreak;\r\ndefault:\r\nadd_ref_cm_node(cm_node);\r\nsend_reset(cm_node, NULL);\r\ncreate_event(cm_node, NES_CM_EVENT_ABORTED);\r\n}\r\n}\r\nstatic void handle_recv_entry(struct nes_cm_node *cm_node, u32 rem_node)\r\n{\r\nstruct nes_timer_entry *recv_entry = cm_node->recv_entry;\r\nstruct iw_cm_id *cm_id = cm_node->cm_id;\r\nstruct nes_qp *nesqp;\r\nunsigned long qplockflags;\r\nif (!recv_entry)\r\nreturn;\r\nnesqp = (struct nes_qp *)recv_entry->skb;\r\nif (nesqp) {\r\nspin_lock_irqsave(&nesqp->lock, qplockflags);\r\nif (nesqp->cm_id) {\r\nnes_debug(NES_DBG_CM, "QP%u: cm_id = %p, "\r\n"refcount = %d: HIT A "\r\n"NES_TIMER_TYPE_CLOSE with something "\r\n"to do!!!\n", nesqp->hwqp.qp_id, cm_id,\r\natomic_read(&nesqp->refcount));\r\nnesqp->hw_tcp_state = NES_AEQE_TCP_STATE_CLOSED;\r\nnesqp->last_aeq = NES_AEQE_AEID_RESET_SENT;\r\nnesqp->ibqp_state = IB_QPS_ERR;\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nnes_cm_disconn(nesqp);\r\n} else {\r\nspin_unlock_irqrestore(&nesqp->lock, qplockflags);\r\nnes_debug(NES_DBG_CM, "QP%u: cm_id = %p, "\r\n"refcount = %d: HIT A "\r\n"NES_TIMER_TYPE_CLOSE with nothing "\r\n"to do!!!\n", nesqp->hwqp.qp_id, cm_id,\r\natomic_read(&nesqp->refcount));\r\n}\r\n} else if (rem_node) {\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\n}\r\nif (cm_node->cm_id)\r\ncm_id->rem_ref(cm_id);\r\nkfree(recv_entry);\r\ncm_node->recv_entry = NULL;\r\n}\r\nstatic void nes_cm_timer_tick(unsigned long pass)\r\n{\r\nunsigned long flags;\r\nunsigned long nexttimeout = jiffies + NES_LONG_TIME;\r\nstruct nes_cm_node *cm_node;\r\nstruct nes_timer_entry *send_entry, *recv_entry;\r\nstruct list_head *list_core_temp;\r\nstruct list_head *list_node;\r\nstruct nes_cm_core *cm_core = g_cm_core;\r\nu32 settimer = 0;\r\nunsigned long timetosend;\r\nint ret = NETDEV_TX_OK;\r\nstruct list_head timer_list;\r\nINIT_LIST_HEAD(&timer_list);\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nlist_for_each_safe(list_node, list_core_temp,\r\n&cm_core->connected_nodes) {\r\ncm_node = container_of(list_node, struct nes_cm_node, list);\r\nif ((cm_node->recv_entry) || (cm_node->send_entry)) {\r\nadd_ref_cm_node(cm_node);\r\nlist_add(&cm_node->timer_entry, &timer_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nlist_for_each_safe(list_node, list_core_temp, &timer_list) {\r\ncm_node = container_of(list_node, struct nes_cm_node,\r\ntimer_entry);\r\nrecv_entry = cm_node->recv_entry;\r\nif (recv_entry) {\r\nif (time_after(recv_entry->timetosend, jiffies)) {\r\nif (nexttimeout > recv_entry->timetosend ||\r\n!settimer) {\r\nnexttimeout = recv_entry->timetosend;\r\nsettimer = 1;\r\n}\r\n} else {\r\nhandle_recv_entry(cm_node, 1);\r\n}\r\n}\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\ndo {\r\nsend_entry = cm_node->send_entry;\r\nif (!send_entry)\r\nbreak;\r\nif (time_after(send_entry->timetosend, jiffies)) {\r\nif (cm_node->state != NES_CM_STATE_TSA) {\r\nif ((nexttimeout >\r\nsend_entry->timetosend) ||\r\n!settimer) {\r\nnexttimeout =\r\nsend_entry->timetosend;\r\nsettimer = 1;\r\n}\r\n} else {\r\nfree_retrans_entry(cm_node);\r\n}\r\nbreak;\r\n}\r\nif ((cm_node->state == NES_CM_STATE_TSA) ||\r\n(cm_node->state == NES_CM_STATE_CLOSED)) {\r\nfree_retrans_entry(cm_node);\r\nbreak;\r\n}\r\nif (!send_entry->retranscount ||\r\n!send_entry->retrycount) {\r\ncm_packets_dropped++;\r\nfree_retrans_entry(cm_node);\r\nspin_unlock_irqrestore(\r\n&cm_node->retrans_list_lock, flags);\r\nnes_retrans_expired(cm_node);\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nspin_lock_irqsave(&cm_node->retrans_list_lock,\r\nflags);\r\nbreak;\r\n}\r\natomic_inc(&send_entry->skb->users);\r\ncm_packets_retrans++;\r\nnes_debug(NES_DBG_CM, "Retransmitting send_entry %p "\r\n"for node %p, jiffies = %lu, time to send = "\r\n"%lu, retranscount = %u, send_entry->seq_num = "\r\n"0x%08X, cm_node->tcp_cntxt.rem_ack_num = "\r\n"0x%08X\n", send_entry, cm_node, jiffies,\r\nsend_entry->timetosend,\r\nsend_entry->retranscount,\r\nsend_entry->seq_num,\r\ncm_node->tcp_cntxt.rem_ack_num);\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock,\r\nflags);\r\nret = nes_nic_cm_xmit(send_entry->skb, cm_node->netdev);\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\nif (ret != NETDEV_TX_OK) {\r\nnes_debug(NES_DBG_CM, "rexmit failed for "\r\n"node=%p\n", cm_node);\r\ncm_packets_bounced++;\r\nsend_entry->retrycount--;\r\nnexttimeout = jiffies + NES_SHORT_TIME;\r\nsettimer = 1;\r\nbreak;\r\n} else {\r\ncm_packets_sent++;\r\n}\r\nnes_debug(NES_DBG_CM, "Packet Sent: retrans count = "\r\n"%u, retry count = %u.\n",\r\nsend_entry->retranscount,\r\nsend_entry->retrycount);\r\nif (send_entry->send_retrans) {\r\nsend_entry->retranscount--;\r\ntimetosend = (NES_RETRY_TIMEOUT <<\r\n(NES_DEFAULT_RETRANS - send_entry->retranscount));\r\nsend_entry->timetosend = jiffies +\r\nmin(timetosend, NES_MAX_TIMEOUT);\r\nif (nexttimeout > send_entry->timetosend ||\r\n!settimer) {\r\nnexttimeout = send_entry->timetosend;\r\nsettimer = 1;\r\n}\r\n} else {\r\nint close_when_complete;\r\nclose_when_complete =\r\nsend_entry->close_when_complete;\r\nnes_debug(NES_DBG_CM, "cm_node=%p state=%d\n",\r\ncm_node, cm_node->state);\r\nfree_retrans_entry(cm_node);\r\nif (close_when_complete)\r\nrem_ref_cm_node(cm_node->cm_core,\r\ncm_node);\r\n}\r\n} while (0);\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\n}\r\nif (settimer) {\r\nif (!timer_pending(&cm_core->tcp_timer))\r\nmod_timer(&cm_core->tcp_timer, nexttimeout);\r\n}\r\n}\r\nstatic int send_syn(struct nes_cm_node *cm_node, u32 sendack,\r\nstruct sk_buff *skb)\r\n{\r\nint ret;\r\nint flags = SET_SYN;\r\nchar optionsbuffer[sizeof(struct option_mss) +\r\nsizeof(struct option_windowscale) + sizeof(struct option_base) +\r\nTCP_OPTIONS_PADDING];\r\nint optionssize = 0;\r\nunion all_known_options *options;\r\nif (!cm_node)\r\nreturn -EINVAL;\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_mss.optionnum = OPTION_NUMBER_MSS;\r\noptions->as_mss.length = sizeof(struct option_mss);\r\noptions->as_mss.mss = htons(cm_node->tcp_cntxt.mss);\r\noptionssize += sizeof(struct option_mss);\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_windowscale.optionnum = OPTION_NUMBER_WINDOW_SCALE;\r\noptions->as_windowscale.length = sizeof(struct option_windowscale);\r\noptions->as_windowscale.shiftcount = cm_node->tcp_cntxt.rcv_wscale;\r\noptionssize += sizeof(struct option_windowscale);\r\nif (sendack && !(NES_DRV_OPT_SUPRESS_OPTION_BC & nes_drv_opt)) {\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_base.optionnum = OPTION_NUMBER_WRITE0;\r\noptions->as_base.length = sizeof(struct option_base);\r\noptionssize += sizeof(struct option_base);\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_end = 1;\r\noptionssize += 1;\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_end = 1;\r\noptionssize += 1;\r\n}\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_end = OPTION_NUMBER_END;\r\noptionssize += 1;\r\nif (!skb)\r\nskb = dev_alloc_skb(MAX_CM_BUFFER);\r\nif (!skb) {\r\nnes_debug(NES_DBG_CM, "Failed to get a Free pkt\n");\r\nreturn -1;\r\n}\r\nif (sendack)\r\nflags |= SET_ACK;\r\nform_cm_frame(skb, cm_node, optionsbuffer, optionssize, NULL, 0, flags);\r\nret = schedule_nes_timer(cm_node, skb, NES_TIMER_TYPE_SEND, 1, 0);\r\nreturn ret;\r\n}\r\nstatic int send_reset(struct nes_cm_node *cm_node, struct sk_buff *skb)\r\n{\r\nint ret;\r\nint flags = SET_RST | SET_ACK;\r\nif (!skb)\r\nskb = dev_alloc_skb(MAX_CM_BUFFER);\r\nif (!skb) {\r\nnes_debug(NES_DBG_CM, "Failed to get a Free pkt\n");\r\nreturn -ENOMEM;\r\n}\r\nform_cm_frame(skb, cm_node, NULL, 0, NULL, 0, flags);\r\nret = schedule_nes_timer(cm_node, skb, NES_TIMER_TYPE_SEND, 0, 1);\r\nreturn ret;\r\n}\r\nstatic int send_ack(struct nes_cm_node *cm_node, struct sk_buff *skb)\r\n{\r\nint ret;\r\nif (!skb)\r\nskb = dev_alloc_skb(MAX_CM_BUFFER);\r\nif (!skb) {\r\nnes_debug(NES_DBG_CM, "Failed to get a Free pkt\n");\r\nreturn -1;\r\n}\r\nform_cm_frame(skb, cm_node, NULL, 0, NULL, 0, SET_ACK);\r\nret = schedule_nes_timer(cm_node, skb, NES_TIMER_TYPE_SEND, 0, 0);\r\nreturn ret;\r\n}\r\nstatic int send_fin(struct nes_cm_node *cm_node, struct sk_buff *skb)\r\n{\r\nint ret;\r\nif (!skb)\r\nskb = dev_alloc_skb(MAX_CM_BUFFER);\r\nif (!skb) {\r\nnes_debug(NES_DBG_CM, "Failed to get a Free pkt\n");\r\nreturn -1;\r\n}\r\nform_cm_frame(skb, cm_node, NULL, 0, NULL, 0, SET_ACK | SET_FIN);\r\nret = schedule_nes_timer(cm_node, skb, NES_TIMER_TYPE_SEND, 1, 0);\r\nreturn ret;\r\n}\r\nstatic struct nes_cm_node *find_node(struct nes_cm_core *cm_core,\r\nu16 rem_port, nes_addr_t rem_addr, u16 loc_port, nes_addr_t loc_addr)\r\n{\r\nunsigned long flags;\r\nstruct list_head *hte;\r\nstruct nes_cm_node *cm_node;\r\nhte = &cm_core->connected_nodes;\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nlist_for_each_entry(cm_node, hte, list) {\r\nnes_debug(NES_DBG_CM, "finding node %x:%x =? %x:%x ^ %x:%x =? %x:%x\n",\r\ncm_node->loc_addr, cm_node->loc_port,\r\nloc_addr, loc_port,\r\ncm_node->rem_addr, cm_node->rem_port,\r\nrem_addr, rem_port);\r\nif ((cm_node->mapped_loc_addr == loc_addr) &&\r\n(cm_node->mapped_loc_port == loc_port) &&\r\n(cm_node->mapped_rem_addr == rem_addr) &&\r\n(cm_node->mapped_rem_port == rem_port)) {\r\nadd_ref_cm_node(cm_node);\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nreturn cm_node;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic struct nes_cm_listener *find_listener(struct nes_cm_core *cm_core,\r\nnes_addr_t dst_addr, u16 dst_port,\r\nenum nes_cm_listener_state listener_state, int local)\r\n{\r\nunsigned long flags;\r\nstruct nes_cm_listener *listen_node;\r\nnes_addr_t listen_addr;\r\nu16 listen_port;\r\nspin_lock_irqsave(&cm_core->listen_list_lock, flags);\r\nlist_for_each_entry(listen_node, &cm_core->listen_list.list, list) {\r\nif (local) {\r\nlisten_addr = listen_node->loc_addr;\r\nlisten_port = listen_node->loc_port;\r\n} else {\r\nlisten_addr = listen_node->mapped_loc_addr;\r\nlisten_port = listen_node->mapped_loc_port;\r\n}\r\nif (((listen_addr == dst_addr) ||\r\nlisten_addr == 0x00000000) &&\r\n(listen_port == dst_port) &&\r\n(listener_state & listen_node->listener_state)) {\r\natomic_inc(&listen_node->ref_count);\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\nreturn listen_node;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic int add_hte_node(struct nes_cm_core *cm_core, struct nes_cm_node *cm_node)\r\n{\r\nunsigned long flags;\r\nstruct list_head *hte;\r\nif (!cm_node || !cm_core)\r\nreturn -EINVAL;\r\nnes_debug(NES_DBG_CM, "Adding Node %p to Active Connection HT\n",\r\ncm_node);\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nhte = &cm_core->connected_nodes;\r\nlist_add_tail(&cm_node->list, hte);\r\natomic_inc(&cm_core->ht_node_cnt);\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mini_cm_dec_refcnt_listen(struct nes_cm_core *cm_core,\r\nstruct nes_cm_listener *listener, int free_hanging_nodes)\r\n{\r\nint ret = -EINVAL;\r\nint err = 0;\r\nunsigned long flags;\r\nstruct list_head *list_pos = NULL;\r\nstruct list_head *list_temp = NULL;\r\nstruct nes_cm_node *cm_node = NULL;\r\nstruct list_head reset_list;\r\nnes_debug(NES_DBG_CM, "attempting listener= %p free_nodes= %d, "\r\n"refcnt=%d\n", listener, free_hanging_nodes,\r\natomic_read(&listener->ref_count));\r\nINIT_LIST_HEAD(&reset_list);\r\nif (free_hanging_nodes) {\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nlist_for_each_safe(list_pos, list_temp,\r\n&g_cm_core->connected_nodes) {\r\ncm_node = container_of(list_pos, struct nes_cm_node,\r\nlist);\r\nif ((cm_node->listener == listener) &&\r\n(!cm_node->accelerated)) {\r\nadd_ref_cm_node(cm_node);\r\nlist_add(&cm_node->reset_entry, &reset_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\n}\r\nlist_for_each_safe(list_pos, list_temp, &reset_list) {\r\ncm_node = container_of(list_pos, struct nes_cm_node,\r\nreset_entry);\r\n{\r\nstruct nes_cm_node *loopback = cm_node->loopbackpartner;\r\nenum nes_cm_node_state old_state;\r\nif (NES_CM_STATE_FIN_WAIT1 <= cm_node->state) {\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\n} else {\r\nif (!loopback) {\r\ncleanup_retrans_entry(cm_node);\r\nerr = send_reset(cm_node, NULL);\r\nif (err) {\r\ncm_node->state =\r\nNES_CM_STATE_CLOSED;\r\nWARN_ON(1);\r\n} else {\r\nold_state = cm_node->state;\r\ncm_node->state = NES_CM_STATE_LISTENER_DESTROYED;\r\nif (old_state != NES_CM_STATE_MPAREQ_RCVD)\r\nrem_ref_cm_node(\r\ncm_node->cm_core,\r\ncm_node);\r\n}\r\n} else {\r\nstruct nes_cm_event event;\r\nevent.cm_node = loopback;\r\nevent.cm_info.rem_addr =\r\nloopback->rem_addr;\r\nevent.cm_info.loc_addr =\r\nloopback->loc_addr;\r\nevent.cm_info.rem_port =\r\nloopback->rem_port;\r\nevent.cm_info.loc_port =\r\nloopback->loc_port;\r\nevent.cm_info.cm_id = loopback->cm_id;\r\nadd_ref_cm_node(loopback);\r\nloopback->state = NES_CM_STATE_CLOSED;\r\ncm_event_connect_error(&event);\r\ncm_node->state = NES_CM_STATE_LISTENER_DESTROYED;\r\nrem_ref_cm_node(cm_node->cm_core,\r\ncm_node);\r\n}\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&cm_core->listen_list_lock, flags);\r\nif (!atomic_dec_return(&listener->ref_count)) {\r\nlist_del(&listener->list);\r\natomic_dec(&cm_core->listen_node_cnt);\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\nif (listener->nesvnic) {\r\nnes_manage_apbvt(listener->nesvnic,\r\nlistener->mapped_loc_port,\r\nPCI_FUNC(listener->nesvnic->nesdev->pcidev->devfn),\r\nNES_MANAGE_APBVT_DEL);\r\nnes_remove_mapinfo(listener->loc_addr,\r\nlistener->loc_port,\r\nlistener->mapped_loc_addr,\r\nlistener->mapped_loc_port);\r\nnes_debug(NES_DBG_NLMSG,\r\n"Delete APBVT mapped_loc_port = %04X\n",\r\nlistener->mapped_loc_port);\r\n}\r\nnes_debug(NES_DBG_CM, "destroying listener (%p)\n", listener);\r\nkfree(listener);\r\nlistener = NULL;\r\nret = 0;\r\natomic_inc(&cm_listens_destroyed);\r\n} else {\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\n}\r\nif (listener) {\r\nif (atomic_read(&listener->pend_accepts_cnt) > 0)\r\nnes_debug(NES_DBG_CM, "destroying listener (%p)"\r\n" with non-zero pending accepts=%u\n",\r\nlistener, atomic_read(&listener->pend_accepts_cnt));\r\n}\r\nreturn ret;\r\n}\r\nstatic int mini_cm_del_listen(struct nes_cm_core *cm_core,\r\nstruct nes_cm_listener *listener)\r\n{\r\nlistener->listener_state = NES_CM_LISTENER_PASSIVE_STATE;\r\nlistener->cm_id = NULL;\r\nreturn mini_cm_dec_refcnt_listen(cm_core, listener, 1);\r\n}\r\nstatic inline int mini_cm_accelerated(struct nes_cm_core *cm_core,\r\nstruct nes_cm_node *cm_node)\r\n{\r\ncm_node->accelerated = 1;\r\nif (cm_node->accept_pend) {\r\nBUG_ON(!cm_node->listener);\r\natomic_dec(&cm_node->listener->pend_accepts_cnt);\r\ncm_node->accept_pend = 0;\r\nBUG_ON(atomic_read(&cm_node->listener->pend_accepts_cnt) < 0);\r\n}\r\nif (!timer_pending(&cm_core->tcp_timer))\r\nmod_timer(&cm_core->tcp_timer, (jiffies + NES_SHORT_TIME));\r\nreturn 0;\r\n}\r\nstatic int nes_addr_resolve_neigh(struct nes_vnic *nesvnic, u32 dst_ip, int arpindex)\r\n{\r\nstruct rtable *rt;\r\nstruct neighbour *neigh;\r\nint rc = arpindex;\r\nstruct net_device *netdev;\r\nstruct nes_adapter *nesadapter = nesvnic->nesdev->nesadapter;\r\nrt = ip_route_output(&init_net, htonl(dst_ip), 0, 0, 0);\r\nif (IS_ERR(rt)) {\r\nprintk(KERN_ERR "%s: ip_route_output_key failed for 0x%08X\n",\r\n__func__, dst_ip);\r\nreturn rc;\r\n}\r\nif (netif_is_bond_slave(nesvnic->netdev))\r\nnetdev = netdev_master_upper_dev_get(nesvnic->netdev);\r\nelse\r\nnetdev = nesvnic->netdev;\r\nneigh = neigh_lookup(&arp_tbl, &rt->rt_gateway, netdev);\r\nrcu_read_lock();\r\nif (neigh) {\r\nif (neigh->nud_state & NUD_VALID) {\r\nnes_debug(NES_DBG_CM, "Neighbor MAC address for 0x%08X"\r\n" is %pM, Gateway is 0x%08X \n", dst_ip,\r\nneigh->ha, ntohl(rt->rt_gateway));\r\nif (arpindex >= 0) {\r\nif (ether_addr_equal(nesadapter->arp_table[arpindex].mac_addr, neigh->ha)) {\r\ngoto out;\r\n}\r\nnes_manage_arp_cache(nesvnic->netdev,\r\nnesadapter->arp_table[arpindex].mac_addr,\r\ndst_ip, NES_ARP_DELETE);\r\n}\r\nnes_manage_arp_cache(nesvnic->netdev, neigh->ha,\r\ndst_ip, NES_ARP_ADD);\r\nrc = nes_arp_table(nesvnic->nesdev, dst_ip, NULL,\r\nNES_ARP_RESOLVE);\r\n} else {\r\nneigh_event_send(neigh, NULL);\r\n}\r\n}\r\nout:\r\nrcu_read_unlock();\r\nif (neigh)\r\nneigh_release(neigh);\r\nip_rt_put(rt);\r\nreturn rc;\r\n}\r\nstatic struct nes_cm_node *make_cm_node(struct nes_cm_core *cm_core,\r\nstruct nes_vnic *nesvnic, struct nes_cm_info *cm_info,\r\nstruct nes_cm_listener *listener)\r\n{\r\nstruct nes_cm_node *cm_node;\r\nstruct timespec ts;\r\nint oldarpindex = 0;\r\nint arpindex = 0;\r\nstruct nes_device *nesdev;\r\nstruct nes_adapter *nesadapter;\r\ncm_node = kzalloc(sizeof(*cm_node), GFP_ATOMIC);\r\nif (!cm_node)\r\nreturn NULL;\r\ncm_node->loc_addr = cm_info->loc_addr;\r\ncm_node->rem_addr = cm_info->rem_addr;\r\ncm_node->loc_port = cm_info->loc_port;\r\ncm_node->rem_port = cm_info->rem_port;\r\ncm_node->mapped_loc_addr = cm_info->mapped_loc_addr;\r\ncm_node->mapped_rem_addr = cm_info->mapped_rem_addr;\r\ncm_node->mapped_loc_port = cm_info->mapped_loc_port;\r\ncm_node->mapped_rem_port = cm_info->mapped_rem_port;\r\ncm_node->mpa_frame_rev = mpa_version;\r\ncm_node->send_rdma0_op = SEND_RDMA_READ_ZERO;\r\ncm_node->mpav2_ird_ord = 0;\r\ncm_node->ird_size = 0;\r\ncm_node->ord_size = 0;\r\nnes_debug(NES_DBG_CM, "Make node addresses : loc = %pI4:%x, rem = %pI4:%x\n",\r\n&cm_node->loc_addr, cm_node->loc_port,\r\n&cm_node->rem_addr, cm_node->rem_port);\r\ncm_node->listener = listener;\r\ncm_node->netdev = nesvnic->netdev;\r\ncm_node->cm_id = cm_info->cm_id;\r\nmemcpy(cm_node->loc_mac, nesvnic->netdev->dev_addr, ETH_ALEN);\r\nnes_debug(NES_DBG_CM, "listener=%p, cm_id=%p\n", cm_node->listener,\r\ncm_node->cm_id);\r\nspin_lock_init(&cm_node->retrans_list_lock);\r\ncm_node->loopbackpartner = NULL;\r\natomic_set(&cm_node->ref_count, 1);\r\ncm_node->cm_core = cm_core;\r\ncm_node->tcp_cntxt.loc_id = NES_CM_DEF_LOCAL_ID;\r\ncm_node->tcp_cntxt.rcv_wscale = NES_CM_DEFAULT_RCV_WND_SCALE;\r\ncm_node->tcp_cntxt.rcv_wnd = NES_CM_DEFAULT_RCV_WND_SCALED >>\r\nNES_CM_DEFAULT_RCV_WND_SCALE;\r\nts = current_kernel_time();\r\ncm_node->tcp_cntxt.loc_seq_num = htonl(ts.tv_nsec);\r\ncm_node->tcp_cntxt.mss = nesvnic->max_frame_size - sizeof(struct iphdr) -\r\nsizeof(struct tcphdr) - ETH_HLEN - VLAN_HLEN;\r\ncm_node->tcp_cntxt.rcv_nxt = 0;\r\natomic_inc(&cm_core->node_cnt);\r\ncm_node->conn_type = cm_info->conn_type;\r\ncm_node->apbvt_set = 0;\r\ncm_node->accept_pend = 0;\r\ncm_node->nesvnic = nesvnic;\r\nnesdev = nesvnic->nesdev;\r\nnesadapter = nesdev->nesadapter;\r\ncm_node->loopbackpartner = NULL;\r\noldarpindex = nes_arp_table(nesdev, cm_node->mapped_rem_addr,\r\nNULL, NES_ARP_RESOLVE);\r\narpindex = nes_addr_resolve_neigh(nesvnic,\r\ncm_node->mapped_rem_addr, oldarpindex);\r\nif (arpindex < 0) {\r\nkfree(cm_node);\r\nreturn NULL;\r\n}\r\nmemcpy(cm_node->rem_mac, nesadapter->arp_table[arpindex].mac_addr, ETH_ALEN);\r\nnes_debug(NES_DBG_CM, "Remote mac addr from arp table: %pM\n",\r\ncm_node->rem_mac);\r\nadd_hte_node(cm_core, cm_node);\r\natomic_inc(&cm_nodes_created);\r\nreturn cm_node;\r\n}\r\nstatic int add_ref_cm_node(struct nes_cm_node *cm_node)\r\n{\r\natomic_inc(&cm_node->ref_count);\r\nreturn 0;\r\n}\r\nstatic int rem_ref_cm_node(struct nes_cm_core *cm_core,\r\nstruct nes_cm_node *cm_node)\r\n{\r\nunsigned long flags;\r\nstruct nes_qp *nesqp;\r\nif (!cm_node)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&cm_node->cm_core->ht_lock, flags);\r\nif (atomic_dec_return(&cm_node->ref_count)) {\r\nspin_unlock_irqrestore(&cm_node->cm_core->ht_lock, flags);\r\nreturn 0;\r\n}\r\nlist_del(&cm_node->list);\r\natomic_dec(&cm_core->ht_node_cnt);\r\nspin_unlock_irqrestore(&cm_node->cm_core->ht_lock, flags);\r\nif (!cm_node->accelerated && cm_node->accept_pend) {\r\nBUG_ON(!cm_node->listener);\r\natomic_dec(&cm_node->listener->pend_accepts_cnt);\r\nBUG_ON(atomic_read(&cm_node->listener->pend_accepts_cnt) < 0);\r\n}\r\nWARN_ON(cm_node->send_entry);\r\nif (cm_node->recv_entry)\r\nhandle_recv_entry(cm_node, 0);\r\nif (cm_node->listener) {\r\nmini_cm_dec_refcnt_listen(cm_core, cm_node->listener, 0);\r\n} else {\r\nif (cm_node->apbvt_set && cm_node->nesvnic) {\r\nnes_manage_apbvt(cm_node->nesvnic, cm_node->mapped_loc_port,\r\nPCI_FUNC(cm_node->nesvnic->nesdev->pcidev->devfn),\r\nNES_MANAGE_APBVT_DEL);\r\n}\r\nnes_debug(NES_DBG_NLMSG, "Delete APBVT mapped_loc_port = %04X\n",\r\ncm_node->mapped_loc_port);\r\nnes_remove_mapinfo(cm_node->loc_addr, cm_node->loc_port,\r\ncm_node->mapped_loc_addr, cm_node->mapped_loc_port);\r\n}\r\natomic_dec(&cm_core->node_cnt);\r\natomic_inc(&cm_nodes_destroyed);\r\nnesqp = cm_node->nesqp;\r\nif (nesqp) {\r\nnesqp->cm_node = NULL;\r\nnes_rem_ref(&nesqp->ibqp);\r\ncm_node->nesqp = NULL;\r\n}\r\nkfree(cm_node);\r\nreturn 0;\r\n}\r\nstatic int process_options(struct nes_cm_node *cm_node, u8 *optionsloc,\r\nu32 optionsize, u32 syn_packet)\r\n{\r\nu32 tmp;\r\nu32 offset = 0;\r\nunion all_known_options *all_options;\r\nchar got_mss_option = 0;\r\nwhile (offset < optionsize) {\r\nall_options = (union all_known_options *)(optionsloc + offset);\r\nswitch (all_options->as_base.optionnum) {\r\ncase OPTION_NUMBER_END:\r\noffset = optionsize;\r\nbreak;\r\ncase OPTION_NUMBER_NONE:\r\noffset += 1;\r\ncontinue;\r\ncase OPTION_NUMBER_MSS:\r\nnes_debug(NES_DBG_CM, "%s: MSS Length: %d Offset: %d "\r\n"Size: %d\n", __func__,\r\nall_options->as_mss.length, offset, optionsize);\r\ngot_mss_option = 1;\r\nif (all_options->as_mss.length != 4) {\r\nreturn 1;\r\n} else {\r\ntmp = ntohs(all_options->as_mss.mss);\r\nif (tmp > 0 && tmp <\r\ncm_node->tcp_cntxt.mss)\r\ncm_node->tcp_cntxt.mss = tmp;\r\n}\r\nbreak;\r\ncase OPTION_NUMBER_WINDOW_SCALE:\r\ncm_node->tcp_cntxt.snd_wscale =\r\nall_options->as_windowscale.shiftcount;\r\nbreak;\r\ndefault:\r\nnes_debug(NES_DBG_CM, "TCP Option not understood: %x\n",\r\nall_options->as_base.optionnum);\r\nbreak;\r\n}\r\noffset += all_options->as_base.length;\r\n}\r\nif ((!got_mss_option) && (syn_packet))\r\ncm_node->tcp_cntxt.mss = NES_CM_DEFAULT_MSS;\r\nreturn 0;\r\n}\r\nstatic void drop_packet(struct sk_buff *skb)\r\n{\r\natomic_inc(&cm_accel_dropped_pkts);\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void handle_fin_pkt(struct nes_cm_node *cm_node)\r\n{\r\nnes_debug(NES_DBG_CM, "Received FIN, cm_node = %p, state = %u. "\r\n"refcnt=%d\n", cm_node, cm_node->state,\r\natomic_read(&cm_node->ref_count));\r\nswitch (cm_node->state) {\r\ncase NES_CM_STATE_SYN_RCVD:\r\ncase NES_CM_STATE_SYN_SENT:\r\ncase NES_CM_STATE_ESTABLISHED:\r\ncase NES_CM_STATE_MPAREJ_RCVD:\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_LAST_ACK;\r\nsend_fin(cm_node, NULL);\r\nbreak;\r\ncase NES_CM_STATE_MPAREQ_SENT:\r\ncreate_event(cm_node, NES_CM_EVENT_ABORTED);\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nadd_ref_cm_node(cm_node);\r\nsend_reset(cm_node, NULL);\r\nbreak;\r\ncase NES_CM_STATE_FIN_WAIT1:\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_CLOSING;\r\nsend_ack(cm_node, NULL);\r\nbreak;\r\ncase NES_CM_STATE_FIN_WAIT2:\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_TIME_WAIT;\r\nsend_ack(cm_node, NULL);\r\nschedule_nes_timer(cm_node, NULL, NES_TIMER_TYPE_CLOSE, 1, 0);\r\nbreak;\r\ncase NES_CM_STATE_TIME_WAIT:\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\nbreak;\r\ncase NES_CM_STATE_TSA:\r\ndefault:\r\nnes_debug(NES_DBG_CM, "Error Rcvd FIN for node-%p state = %d\n",\r\ncm_node, cm_node->state);\r\nbreak;\r\n}\r\n}\r\nstatic void handle_rst_pkt(struct nes_cm_node *cm_node, struct sk_buff *skb,\r\nstruct tcphdr *tcph)\r\n{\r\nint reset = 0;\r\natomic_inc(&cm_resets_recvd);\r\nnes_debug(NES_DBG_CM, "Received Reset, cm_node = %p, state = %u."\r\n" refcnt=%d\n", cm_node, cm_node->state,\r\natomic_read(&cm_node->ref_count));\r\ncleanup_retrans_entry(cm_node);\r\nswitch (cm_node->state) {\r\ncase NES_CM_STATE_SYN_SENT:\r\ncase NES_CM_STATE_MPAREQ_SENT:\r\nnes_debug(NES_DBG_CM, "%s[%u] create abort for cm_node=%p "\r\n"listener=%p state=%d\n", __func__, __LINE__, cm_node,\r\ncm_node->listener, cm_node->state);\r\nswitch (cm_node->mpa_frame_rev) {\r\ncase IETF_MPA_V2:\r\ncm_node->mpa_frame_rev = IETF_MPA_V1;\r\ncm_node->state = NES_CM_STATE_SYN_SENT;\r\nif (send_syn(cm_node, 0, NULL)) {\r\nactive_open_err(cm_node, skb, reset);\r\n}\r\nbreak;\r\ncase IETF_MPA_V1:\r\ndefault:\r\nactive_open_err(cm_node, skb, reset);\r\nbreak;\r\n}\r\nbreak;\r\ncase NES_CM_STATE_MPAREQ_RCVD:\r\natomic_inc(&cm_node->passive_state);\r\ndev_kfree_skb_any(skb);\r\nbreak;\r\ncase NES_CM_STATE_ESTABLISHED:\r\ncase NES_CM_STATE_SYN_RCVD:\r\ncase NES_CM_STATE_LISTENING:\r\nnes_debug(NES_DBG_CM, "Bad state %s[%u]\n", __func__, __LINE__);\r\npassive_open_err(cm_node, skb, reset);\r\nbreak;\r\ncase NES_CM_STATE_TSA:\r\nactive_open_err(cm_node, skb, reset);\r\nbreak;\r\ncase NES_CM_STATE_CLOSED:\r\ndrop_packet(skb);\r\nbreak;\r\ncase NES_CM_STATE_FIN_WAIT2:\r\ncase NES_CM_STATE_FIN_WAIT1:\r\ncase NES_CM_STATE_LAST_ACK:\r\ncm_node->cm_id->rem_ref(cm_node->cm_id);\r\ncase NES_CM_STATE_TIME_WAIT:\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\ndrop_packet(skb);\r\nbreak;\r\ndefault:\r\ndrop_packet(skb);\r\nbreak;\r\n}\r\n}\r\nstatic void handle_rcv_mpa(struct nes_cm_node *cm_node, struct sk_buff *skb)\r\n{\r\nint ret = 0;\r\nint datasize = skb->len;\r\nu8 *dataloc = skb->data;\r\nenum nes_cm_event_type type = NES_CM_EVENT_UNKNOWN;\r\nu32 res_type;\r\nret = parse_mpa(cm_node, dataloc, &res_type, datasize);\r\nif (ret) {\r\nnes_debug(NES_DBG_CM, "didn't like MPA Request\n");\r\nif (cm_node->state == NES_CM_STATE_MPAREQ_SENT) {\r\nnes_debug(NES_DBG_CM, "%s[%u] create abort for "\r\n"cm_node=%p listener=%p state=%d\n", __func__,\r\n__LINE__, cm_node, cm_node->listener,\r\ncm_node->state);\r\nactive_open_err(cm_node, skb, 1);\r\n} else {\r\npassive_open_err(cm_node, skb, 1);\r\n}\r\nreturn;\r\n}\r\nswitch (cm_node->state) {\r\ncase NES_CM_STATE_ESTABLISHED:\r\nif (res_type == NES_MPA_REQUEST_REJECT)\r\nWARN_ON(1);\r\ncm_node->state = NES_CM_STATE_MPAREQ_RCVD;\r\ntype = NES_CM_EVENT_MPA_REQ;\r\natomic_set(&cm_node->passive_state,\r\nNES_PASSIVE_STATE_INDICATED);\r\nbreak;\r\ncase NES_CM_STATE_MPAREQ_SENT:\r\ncleanup_retrans_entry(cm_node);\r\nif (res_type == NES_MPA_REQUEST_REJECT) {\r\ntype = NES_CM_EVENT_MPA_REJECT;\r\ncm_node->state = NES_CM_STATE_MPAREJ_RCVD;\r\n} else {\r\ntype = NES_CM_EVENT_CONNECTED;\r\ncm_node->state = NES_CM_STATE_TSA;\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\ndev_kfree_skb_any(skb);\r\ncreate_event(cm_node, type);\r\n}\r\nstatic void indicate_pkt_err(struct nes_cm_node *cm_node, struct sk_buff *skb)\r\n{\r\nswitch (cm_node->state) {\r\ncase NES_CM_STATE_SYN_SENT:\r\ncase NES_CM_STATE_MPAREQ_SENT:\r\nnes_debug(NES_DBG_CM, "%s[%u] create abort for cm_node=%p "\r\n"listener=%p state=%d\n", __func__, __LINE__, cm_node,\r\ncm_node->listener, cm_node->state);\r\nactive_open_err(cm_node, skb, 1);\r\nbreak;\r\ncase NES_CM_STATE_ESTABLISHED:\r\ncase NES_CM_STATE_SYN_RCVD:\r\npassive_open_err(cm_node, skb, 1);\r\nbreak;\r\ncase NES_CM_STATE_TSA:\r\ndefault:\r\ndrop_packet(skb);\r\n}\r\n}\r\nstatic int check_syn(struct nes_cm_node *cm_node, struct tcphdr *tcph,\r\nstruct sk_buff *skb)\r\n{\r\nint err;\r\nerr = ((ntohl(tcph->ack_seq) == cm_node->tcp_cntxt.loc_seq_num)) ? 0 : 1;\r\nif (err)\r\nactive_open_err(cm_node, skb, 1);\r\nreturn err;\r\n}\r\nstatic int check_seq(struct nes_cm_node *cm_node, struct tcphdr *tcph,\r\nstruct sk_buff *skb)\r\n{\r\nint err = 0;\r\nu32 seq;\r\nu32 ack_seq;\r\nu32 loc_seq_num = cm_node->tcp_cntxt.loc_seq_num;\r\nu32 rcv_nxt = cm_node->tcp_cntxt.rcv_nxt;\r\nu32 rcv_wnd;\r\nseq = ntohl(tcph->seq);\r\nack_seq = ntohl(tcph->ack_seq);\r\nrcv_wnd = cm_node->tcp_cntxt.rcv_wnd;\r\nif (ack_seq != loc_seq_num)\r\nerr = 1;\r\nelse if (!between(seq, rcv_nxt, (rcv_nxt + rcv_wnd)))\r\nerr = 1;\r\nif (err) {\r\nnes_debug(NES_DBG_CM, "%s[%u] create abort for cm_node=%p "\r\n"listener=%p state=%d\n", __func__, __LINE__, cm_node,\r\ncm_node->listener, cm_node->state);\r\nindicate_pkt_err(cm_node, skb);\r\nnes_debug(NES_DBG_CM, "seq ERROR cm_node =%p seq=0x%08X "\r\n"rcv_nxt=0x%08X rcv_wnd=0x%x\n", cm_node, seq, rcv_nxt,\r\nrcv_wnd);\r\n}\r\nreturn err;\r\n}\r\nstatic void handle_syn_pkt(struct nes_cm_node *cm_node, struct sk_buff *skb,\r\nstruct tcphdr *tcph)\r\n{\r\nint ret;\r\nu32 inc_sequence;\r\nint optionsize;\r\noptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\r\nskb_trim(skb, 0);\r\ninc_sequence = ntohl(tcph->seq);\r\nswitch (cm_node->state) {\r\ncase NES_CM_STATE_SYN_SENT:\r\ncase NES_CM_STATE_MPAREQ_SENT:\r\nactive_open_err(cm_node, skb, 1);\r\nbreak;\r\ncase NES_CM_STATE_LISTENING:\r\nif (atomic_read(&cm_node->listener->pend_accepts_cnt) >\r\ncm_node->listener->backlog) {\r\nnes_debug(NES_DBG_CM, "drop syn due to backlog "\r\n"pressure \n");\r\ncm_backlog_drops++;\r\npassive_open_err(cm_node, skb, 0);\r\nbreak;\r\n}\r\nret = handle_tcp_options(cm_node, tcph, skb, optionsize,\r\n1);\r\nif (ret) {\r\npassive_open_err(cm_node, skb, 0);\r\nbreak;\r\n}\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + 1;\r\nBUG_ON(cm_node->send_entry);\r\ncm_node->accept_pend = 1;\r\natomic_inc(&cm_node->listener->pend_accepts_cnt);\r\ncm_node->state = NES_CM_STATE_SYN_RCVD;\r\nsend_syn(cm_node, 1, skb);\r\nbreak;\r\ncase NES_CM_STATE_CLOSED:\r\ncleanup_retrans_entry(cm_node);\r\nadd_ref_cm_node(cm_node);\r\nsend_reset(cm_node, skb);\r\nbreak;\r\ncase NES_CM_STATE_TSA:\r\ncase NES_CM_STATE_ESTABLISHED:\r\ncase NES_CM_STATE_FIN_WAIT1:\r\ncase NES_CM_STATE_FIN_WAIT2:\r\ncase NES_CM_STATE_MPAREQ_RCVD:\r\ncase NES_CM_STATE_LAST_ACK:\r\ncase NES_CM_STATE_CLOSING:\r\ncase NES_CM_STATE_UNKNOWN:\r\ndefault:\r\ndrop_packet(skb);\r\nbreak;\r\n}\r\n}\r\nstatic void handle_synack_pkt(struct nes_cm_node *cm_node, struct sk_buff *skb,\r\nstruct tcphdr *tcph)\r\n{\r\nint ret;\r\nu32 inc_sequence;\r\nint optionsize;\r\noptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\r\nskb_trim(skb, 0);\r\ninc_sequence = ntohl(tcph->seq);\r\nswitch (cm_node->state) {\r\ncase NES_CM_STATE_SYN_SENT:\r\ncleanup_retrans_entry(cm_node);\r\nif (check_syn(cm_node, tcph, skb))\r\nreturn;\r\ncm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\r\nret = handle_tcp_options(cm_node, tcph, skb, optionsize, 0);\r\nif (ret) {\r\nnes_debug(NES_DBG_CM, "cm_node=%p tcp_options failed\n",\r\ncm_node);\r\nbreak;\r\n}\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + 1;\r\nsend_mpa_request(cm_node, skb);\r\ncm_node->state = NES_CM_STATE_MPAREQ_SENT;\r\nbreak;\r\ncase NES_CM_STATE_MPAREQ_RCVD:\r\npassive_open_err(cm_node, skb, 1);\r\nbreak;\r\ncase NES_CM_STATE_LISTENING:\r\ncm_node->tcp_cntxt.loc_seq_num = ntohl(tcph->ack_seq);\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nsend_reset(cm_node, skb);\r\nbreak;\r\ncase NES_CM_STATE_CLOSED:\r\ncm_node->tcp_cntxt.loc_seq_num = ntohl(tcph->ack_seq);\r\ncleanup_retrans_entry(cm_node);\r\nadd_ref_cm_node(cm_node);\r\nsend_reset(cm_node, skb);\r\nbreak;\r\ncase NES_CM_STATE_ESTABLISHED:\r\ncase NES_CM_STATE_FIN_WAIT1:\r\ncase NES_CM_STATE_FIN_WAIT2:\r\ncase NES_CM_STATE_LAST_ACK:\r\ncase NES_CM_STATE_TSA:\r\ncase NES_CM_STATE_CLOSING:\r\ncase NES_CM_STATE_UNKNOWN:\r\ncase NES_CM_STATE_MPAREQ_SENT:\r\ndefault:\r\ndrop_packet(skb);\r\nbreak;\r\n}\r\n}\r\nstatic int handle_ack_pkt(struct nes_cm_node *cm_node, struct sk_buff *skb,\r\nstruct tcphdr *tcph)\r\n{\r\nint datasize = 0;\r\nu32 inc_sequence;\r\nint ret = 0;\r\nint optionsize;\r\noptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\r\nif (check_seq(cm_node, tcph, skb))\r\nreturn -EINVAL;\r\nskb_pull(skb, tcph->doff << 2);\r\ninc_sequence = ntohl(tcph->seq);\r\ndatasize = skb->len;\r\nswitch (cm_node->state) {\r\ncase NES_CM_STATE_SYN_RCVD:\r\ncleanup_retrans_entry(cm_node);\r\nret = handle_tcp_options(cm_node, tcph, skb, optionsize, 1);\r\nif (ret)\r\nbreak;\r\ncm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\r\ncm_node->state = NES_CM_STATE_ESTABLISHED;\r\nif (datasize) {\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\r\nhandle_rcv_mpa(cm_node, skb);\r\n} else {\r\ndev_kfree_skb_any(skb);\r\n}\r\nbreak;\r\ncase NES_CM_STATE_ESTABLISHED:\r\ncleanup_retrans_entry(cm_node);\r\nif (datasize) {\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\r\nhandle_rcv_mpa(cm_node, skb);\r\n} else {\r\ndrop_packet(skb);\r\n}\r\nbreak;\r\ncase NES_CM_STATE_MPAREQ_SENT:\r\ncm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\r\nif (datasize) {\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\r\nhandle_rcv_mpa(cm_node, skb);\r\n} else {\r\ndev_kfree_skb_any(skb);\r\n}\r\nbreak;\r\ncase NES_CM_STATE_LISTENING:\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nsend_reset(cm_node, skb);\r\nbreak;\r\ncase NES_CM_STATE_CLOSED:\r\ncleanup_retrans_entry(cm_node);\r\nadd_ref_cm_node(cm_node);\r\nsend_reset(cm_node, skb);\r\nbreak;\r\ncase NES_CM_STATE_LAST_ACK:\r\ncase NES_CM_STATE_CLOSING:\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\ncm_node->cm_id->rem_ref(cm_node->cm_id);\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\ndrop_packet(skb);\r\nbreak;\r\ncase NES_CM_STATE_FIN_WAIT1:\r\ncleanup_retrans_entry(cm_node);\r\ndrop_packet(skb);\r\ncm_node->state = NES_CM_STATE_FIN_WAIT2;\r\nbreak;\r\ncase NES_CM_STATE_SYN_SENT:\r\ncase NES_CM_STATE_FIN_WAIT2:\r\ncase NES_CM_STATE_TSA:\r\ncase NES_CM_STATE_MPAREQ_RCVD:\r\ncase NES_CM_STATE_UNKNOWN:\r\ndefault:\r\ncleanup_retrans_entry(cm_node);\r\ndrop_packet(skb);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int handle_tcp_options(struct nes_cm_node *cm_node, struct tcphdr *tcph,\r\nstruct sk_buff *skb, int optionsize, int passive)\r\n{\r\nu8 *optionsloc = (u8 *)&tcph[1];\r\nif (optionsize) {\r\nif (process_options(cm_node, optionsloc, optionsize,\r\n(u32)tcph->syn)) {\r\nnes_debug(NES_DBG_CM, "%s: Node %p, Sending RESET\n",\r\n__func__, cm_node);\r\nif (passive)\r\npassive_open_err(cm_node, skb, 1);\r\nelse\r\nactive_open_err(cm_node, skb, 1);\r\nreturn 1;\r\n}\r\n}\r\ncm_node->tcp_cntxt.snd_wnd = ntohs(tcph->window) <<\r\ncm_node->tcp_cntxt.snd_wscale;\r\nif (cm_node->tcp_cntxt.snd_wnd > cm_node->tcp_cntxt.max_snd_wnd)\r\ncm_node->tcp_cntxt.max_snd_wnd = cm_node->tcp_cntxt.snd_wnd;\r\nreturn 0;\r\n}\r\nstatic void active_open_err(struct nes_cm_node *cm_node, struct sk_buff *skb,\r\nint reset)\r\n{\r\ncleanup_retrans_entry(cm_node);\r\nif (reset) {\r\nnes_debug(NES_DBG_CM, "ERROR active err called for cm_node=%p, "\r\n"state=%d\n", cm_node, cm_node->state);\r\nadd_ref_cm_node(cm_node);\r\nsend_reset(cm_node, skb);\r\n} else {\r\ndev_kfree_skb_any(skb);\r\n}\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\ncreate_event(cm_node, NES_CM_EVENT_ABORTED);\r\n}\r\nstatic void passive_open_err(struct nes_cm_node *cm_node, struct sk_buff *skb,\r\nint reset)\r\n{\r\ncleanup_retrans_entry(cm_node);\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nif (reset) {\r\nnes_debug(NES_DBG_CM, "passive_open_err sending RST for "\r\n"cm_node=%p state =%d\n", cm_node, cm_node->state);\r\nsend_reset(cm_node, skb);\r\n} else {\r\ndev_kfree_skb_any(skb);\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\n}\r\n}\r\nstatic void free_retrans_entry(struct nes_cm_node *cm_node)\r\n{\r\nstruct nes_timer_entry *send_entry;\r\nsend_entry = cm_node->send_entry;\r\nif (send_entry) {\r\ncm_node->send_entry = NULL;\r\ndev_kfree_skb_any(send_entry->skb);\r\nkfree(send_entry);\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\n}\r\n}\r\nstatic void cleanup_retrans_entry(struct nes_cm_node *cm_node)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\nfree_retrans_entry(cm_node);\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\r\n}\r\nstatic void process_packet(struct nes_cm_node *cm_node, struct sk_buff *skb,\r\nstruct nes_cm_core *cm_core)\r\n{\r\nenum nes_tcpip_pkt_type pkt_type = NES_PKT_TYPE_UNKNOWN;\r\nstruct tcphdr *tcph = tcp_hdr(skb);\r\nu32 fin_set = 0;\r\nint ret = 0;\r\nskb_pull(skb, ip_hdr(skb)->ihl << 2);\r\nnes_debug(NES_DBG_CM, "process_packet: cm_node=%p state =%d syn=%d "\r\n"ack=%d rst=%d fin=%d\n", cm_node, cm_node->state, tcph->syn,\r\ntcph->ack, tcph->rst, tcph->fin);\r\nif (tcph->rst) {\r\npkt_type = NES_PKT_TYPE_RST;\r\n} else if (tcph->syn) {\r\npkt_type = NES_PKT_TYPE_SYN;\r\nif (tcph->ack)\r\npkt_type = NES_PKT_TYPE_SYNACK;\r\n} else if (tcph->ack) {\r\npkt_type = NES_PKT_TYPE_ACK;\r\n}\r\nif (tcph->fin)\r\nfin_set = 1;\r\nswitch (pkt_type) {\r\ncase NES_PKT_TYPE_SYN:\r\nhandle_syn_pkt(cm_node, skb, tcph);\r\nbreak;\r\ncase NES_PKT_TYPE_SYNACK:\r\nhandle_synack_pkt(cm_node, skb, tcph);\r\nbreak;\r\ncase NES_PKT_TYPE_ACK:\r\nret = handle_ack_pkt(cm_node, skb, tcph);\r\nif (fin_set && !ret)\r\nhandle_fin_pkt(cm_node);\r\nbreak;\r\ncase NES_PKT_TYPE_RST:\r\nhandle_rst_pkt(cm_node, skb, tcph);\r\nbreak;\r\ndefault:\r\nif ((fin_set) && (!check_seq(cm_node, tcph, skb)))\r\nhandle_fin_pkt(cm_node);\r\ndrop_packet(skb);\r\nbreak;\r\n}\r\n}\r\nstatic struct nes_cm_listener *mini_cm_listen(struct nes_cm_core *cm_core,\r\nstruct nes_vnic *nesvnic, struct nes_cm_info *cm_info)\r\n{\r\nstruct nes_cm_listener *listener;\r\nstruct iwpm_dev_data pm_reg_msg;\r\nstruct iwpm_sa_data pm_msg;\r\nunsigned long flags;\r\nint iwpm_err = 0;\r\nnes_debug(NES_DBG_CM, "Search for 0x%08x : 0x%04x\n",\r\ncm_info->loc_addr, cm_info->loc_port);\r\nlistener = find_listener(cm_core, cm_info->loc_addr, cm_info->loc_port,\r\nNES_CM_LISTENER_EITHER_STATE, 1);\r\nif (listener && listener->listener_state == NES_CM_LISTENER_ACTIVE_STATE) {\r\natomic_dec(&listener->ref_count);\r\nnes_debug(NES_DBG_CM, "Not creating listener since it already exists\n");\r\nreturn NULL;\r\n}\r\nif (!listener) {\r\nnes_form_reg_msg(nesvnic, &pm_reg_msg);\r\niwpm_err = iwpm_register_pid(&pm_reg_msg, RDMA_NL_NES);\r\nif (iwpm_err) {\r\nnes_debug(NES_DBG_NLMSG,\r\n"Port Mapper reg pid fail (err = %d).\n", iwpm_err);\r\n}\r\nif (iwpm_valid_pid() && !iwpm_err) {\r\nnes_form_pm_msg(cm_info, &pm_msg);\r\niwpm_err = iwpm_add_mapping(&pm_msg, RDMA_NL_NES);\r\nif (iwpm_err)\r\nnes_debug(NES_DBG_NLMSG,\r\n"Port Mapper query fail (err = %d).\n", iwpm_err);\r\nelse\r\nnes_record_pm_msg(cm_info, &pm_msg);\r\n}\r\nlistener = kzalloc(sizeof(*listener), GFP_ATOMIC);\r\nif (!listener) {\r\nnes_debug(NES_DBG_CM, "Not creating listener memory allocation failed\n");\r\nreturn NULL;\r\n}\r\nlistener->loc_addr = cm_info->loc_addr;\r\nlistener->loc_port = cm_info->loc_port;\r\nlistener->mapped_loc_addr = cm_info->mapped_loc_addr;\r\nlistener->mapped_loc_port = cm_info->mapped_loc_port;\r\nlistener->reused_node = 0;\r\natomic_set(&listener->ref_count, 1);\r\n}\r\nelse {\r\nlistener->reused_node = 1;\r\n}\r\nlistener->cm_id = cm_info->cm_id;\r\natomic_set(&listener->pend_accepts_cnt, 0);\r\nlistener->cm_core = cm_core;\r\nlistener->nesvnic = nesvnic;\r\natomic_inc(&cm_core->node_cnt);\r\nlistener->conn_type = cm_info->conn_type;\r\nlistener->backlog = cm_info->backlog;\r\nlistener->listener_state = NES_CM_LISTENER_ACTIVE_STATE;\r\nif (!listener->reused_node) {\r\nspin_lock_irqsave(&cm_core->listen_list_lock, flags);\r\nlist_add(&listener->list, &cm_core->listen_list.list);\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\natomic_inc(&cm_core->listen_node_cnt);\r\n}\r\nnes_debug(NES_DBG_CM, "Api - listen(): addr=0x%08X, port=0x%04x,"\r\n" listener = %p, backlog = %d, cm_id = %p.\n",\r\ncm_info->loc_addr, cm_info->loc_port,\r\nlistener, listener->backlog, listener->cm_id);\r\nreturn listener;\r\n}\r\nstatic struct nes_cm_node *mini_cm_connect(struct nes_cm_core *cm_core,\r\nstruct nes_vnic *nesvnic, u16 private_data_len,\r\nvoid *private_data, struct nes_cm_info *cm_info)\r\n{\r\nint ret = 0;\r\nstruct nes_cm_node *cm_node;\r\nstruct nes_cm_listener *loopbackremotelistener;\r\nstruct nes_cm_node *loopbackremotenode;\r\nstruct nes_cm_info loopback_cm_info;\r\nu8 *start_buff;\r\ncm_node = make_cm_node(cm_core, nesvnic, cm_info, NULL);\r\nif (!cm_node)\r\nreturn NULL;\r\ncm_node->tcp_cntxt.client = 1;\r\ncm_node->tcp_cntxt.rcv_wscale = NES_CM_DEFAULT_RCV_WND_SCALE;\r\nif (cm_info->loc_addr == cm_info->rem_addr) {\r\nloopbackremotelistener = find_listener(cm_core,\r\ncm_node->mapped_loc_addr, cm_node->mapped_rem_port,\r\nNES_CM_LISTENER_ACTIVE_STATE, 0);\r\nif (loopbackremotelistener == NULL) {\r\ncreate_event(cm_node, NES_CM_EVENT_ABORTED);\r\n} else {\r\nloopback_cm_info = *cm_info;\r\nloopback_cm_info.loc_port = cm_info->rem_port;\r\nloopback_cm_info.rem_port = cm_info->loc_port;\r\nloopback_cm_info.mapped_loc_port =\r\ncm_info->mapped_rem_port;\r\nloopback_cm_info.mapped_rem_port =\r\ncm_info->mapped_loc_port;\r\nloopback_cm_info.cm_id = loopbackremotelistener->cm_id;\r\nloopbackremotenode = make_cm_node(cm_core, nesvnic,\r\n&loopback_cm_info, loopbackremotelistener);\r\nif (!loopbackremotenode) {\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\nreturn NULL;\r\n}\r\natomic_inc(&cm_loopbacks);\r\nloopbackremotenode->loopbackpartner = cm_node;\r\nloopbackremotenode->tcp_cntxt.rcv_wscale =\r\nNES_CM_DEFAULT_RCV_WND_SCALE;\r\ncm_node->loopbackpartner = loopbackremotenode;\r\nmemcpy(loopbackremotenode->mpa_frame_buf, private_data,\r\nprivate_data_len);\r\nloopbackremotenode->mpa_frame_size = private_data_len;\r\ncm_node->state = NES_CM_STATE_TSA;\r\ncm_node->tcp_cntxt.rcv_nxt =\r\nloopbackremotenode->tcp_cntxt.loc_seq_num;\r\nloopbackremotenode->tcp_cntxt.rcv_nxt =\r\ncm_node->tcp_cntxt.loc_seq_num;\r\ncm_node->tcp_cntxt.max_snd_wnd =\r\nloopbackremotenode->tcp_cntxt.rcv_wnd;\r\nloopbackremotenode->tcp_cntxt.max_snd_wnd =\r\ncm_node->tcp_cntxt.rcv_wnd;\r\ncm_node->tcp_cntxt.snd_wnd =\r\nloopbackremotenode->tcp_cntxt.rcv_wnd;\r\nloopbackremotenode->tcp_cntxt.snd_wnd =\r\ncm_node->tcp_cntxt.rcv_wnd;\r\ncm_node->tcp_cntxt.snd_wscale =\r\nloopbackremotenode->tcp_cntxt.rcv_wscale;\r\nloopbackremotenode->tcp_cntxt.snd_wscale =\r\ncm_node->tcp_cntxt.rcv_wscale;\r\nloopbackremotenode->state = NES_CM_STATE_MPAREQ_RCVD;\r\ncreate_event(loopbackremotenode, NES_CM_EVENT_MPA_REQ);\r\n}\r\nreturn cm_node;\r\n}\r\nstart_buff = &cm_node->mpa_frame_buf[0] + sizeof(struct ietf_mpa_v2);\r\ncm_node->mpa_frame_size = private_data_len;\r\nmemcpy(start_buff, private_data, private_data_len);\r\ncm_node->state = NES_CM_STATE_SYN_SENT;\r\nret = send_syn(cm_node, 0, NULL);\r\nif (ret) {\r\nnes_debug(NES_DBG_CM, "Api - connect() FAILED: dest "\r\n"addr=0x%08X, port=0x%04x, cm_node=%p, cm_id = %p.\n",\r\ncm_node->rem_addr, cm_node->rem_port, cm_node,\r\ncm_node->cm_id);\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\ncm_node = NULL;\r\n}\r\nif (cm_node) {\r\nnes_debug(NES_DBG_CM, "Api - connect(): dest addr=0x%08X,"\r\n"port=0x%04x, cm_node=%p, cm_id = %p.\n",\r\ncm_node->rem_addr, cm_node->rem_port, cm_node,\r\ncm_node->cm_id);\r\n}\r\nreturn cm_node;\r\n}\r\nstatic int mini_cm_accept(struct nes_cm_core *cm_core, struct nes_cm_node *cm_node)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mini_cm_reject(struct nes_cm_core *cm_core, struct nes_cm_node *cm_node)\r\n{\r\nint ret = 0;\r\nint err = 0;\r\nint passive_state;\r\nstruct nes_cm_event event;\r\nstruct iw_cm_id *cm_id = cm_node->cm_id;\r\nstruct nes_cm_node *loopback = cm_node->loopbackpartner;\r\nnes_debug(NES_DBG_CM, "%s cm_node=%p type=%d state=%d\n",\r\n__func__, cm_node, cm_node->tcp_cntxt.client, cm_node->state);\r\nif (cm_node->tcp_cntxt.client)\r\nreturn ret;\r\ncleanup_retrans_entry(cm_node);\r\nif (!loopback) {\r\npassive_state = atomic_add_return(1, &cm_node->passive_state);\r\nif (passive_state == NES_SEND_RESET_EVENT) {\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nrem_ref_cm_node(cm_core, cm_node);\r\n} else {\r\nif (cm_node->state == NES_CM_STATE_LISTENER_DESTROYED) {\r\nrem_ref_cm_node(cm_core, cm_node);\r\n} else {\r\nret = send_mpa_reject(cm_node);\r\nif (ret) {\r\ncm_node->state = NES_CM_STATE_CLOSED;\r\nerr = send_reset(cm_node, NULL);\r\nif (err)\r\nWARN_ON(1);\r\n} else {\r\ncm_id->add_ref(cm_id);\r\n}\r\n}\r\n}\r\n} else {\r\ncm_node->cm_id = NULL;\r\nif (cm_node->state == NES_CM_STATE_LISTENER_DESTROYED) {\r\nrem_ref_cm_node(cm_core, cm_node);\r\nrem_ref_cm_node(cm_core, loopback);\r\n} else {\r\nevent.cm_node = loopback;\r\nevent.cm_info.rem_addr = loopback->rem_addr;\r\nevent.cm_info.loc_addr = loopback->loc_addr;\r\nevent.cm_info.rem_port = loopback->rem_port;\r\nevent.cm_info.loc_port = loopback->loc_port;\r\nevent.cm_info.cm_id = loopback->cm_id;\r\ncm_event_mpa_reject(&event);\r\nrem_ref_cm_node(cm_core, cm_node);\r\nloopback->state = NES_CM_STATE_CLOSING;\r\ncm_id = loopback->cm_id;\r\nrem_ref_cm_node(cm_core, loopback);\r\ncm_id->rem_ref(cm_id);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int mini_cm_close(struct nes_cm_core *cm_core, struct nes_cm_node *cm_node)\r\n{\r\nint ret = 0;\r\nif (!cm_core || !cm_node)\r\nreturn -EINVAL;\r\nswitch (cm_node->state) {\r\ncase NES_CM_STATE_SYN_RCVD:\r\ncase NES_CM_STATE_SYN_SENT:\r\ncase NES_CM_STATE_ONE_SIDE_ESTABLISHED:\r\ncase NES_CM_STATE_ESTABLISHED:\r\ncase NES_CM_STATE_ACCEPTING:\r\ncase NES_CM_STATE_MPAREQ_SENT:\r\ncase NES_CM_STATE_MPAREQ_RCVD:\r\ncleanup_retrans_entry(cm_node);\r\nsend_reset(cm_node, NULL);\r\nbreak;\r\ncase NES_CM_STATE_CLOSE_WAIT:\r\ncm_node->state = NES_CM_STATE_LAST_ACK;\r\nsend_fin(cm_node, NULL);\r\nbreak;\r\ncase NES_CM_STATE_FIN_WAIT1:\r\ncase NES_CM_STATE_FIN_WAIT2:\r\ncase NES_CM_STATE_LAST_ACK:\r\ncase NES_CM_STATE_TIME_WAIT:\r\ncase NES_CM_STATE_CLOSING:\r\nret = -1;\r\nbreak;\r\ncase NES_CM_STATE_LISTENING:\r\ncleanup_retrans_entry(cm_node);\r\nsend_reset(cm_node, NULL);\r\nbreak;\r\ncase NES_CM_STATE_MPAREJ_RCVD:\r\ncase NES_CM_STATE_UNKNOWN:\r\ncase NES_CM_STATE_INITED:\r\ncase NES_CM_STATE_CLOSED:\r\ncase NES_CM_STATE_LISTENER_DESTROYED:\r\nret = rem_ref_cm_node(cm_core, cm_node);\r\nbreak;\r\ncase NES_CM_STATE_TSA:\r\nif (cm_node->send_entry)\r\nprintk(KERN_ERR "ERROR Close got called from STATE_TSA "\r\n"send_entry=%p\n", cm_node->send_entry);\r\nret = rem_ref_cm_node(cm_core, cm_node);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mini_cm_recv_pkt(struct nes_cm_core *cm_core,\r\nstruct nes_vnic *nesvnic, struct sk_buff *skb)\r\n{\r\nstruct nes_cm_node *cm_node = NULL;\r\nstruct nes_cm_listener *listener = NULL;\r\nstruct iphdr *iph;\r\nstruct tcphdr *tcph;\r\nstruct nes_cm_info nfo;\r\nint skb_handled = 1;\r\n__be32 tmp_daddr, tmp_saddr;\r\nif (!skb)\r\nreturn 0;\r\nif (skb->len < sizeof(struct iphdr) + sizeof(struct tcphdr))\r\nreturn 0;\r\niph = (struct iphdr *)skb->data;\r\ntcph = (struct tcphdr *)(skb->data + sizeof(struct iphdr));\r\nnfo.loc_addr = ntohl(iph->daddr);\r\nnfo.loc_port = ntohs(tcph->dest);\r\nnfo.rem_addr = ntohl(iph->saddr);\r\nnfo.rem_port = ntohs(tcph->source);\r\nnfo.mapped_loc_addr = ntohl(iph->daddr);\r\nnfo.mapped_loc_port = ntohs(tcph->dest);\r\nnfo.mapped_rem_addr = ntohl(iph->saddr);\r\nnfo.mapped_rem_port = ntohs(tcph->source);\r\ntmp_daddr = cpu_to_be32(iph->daddr);\r\ntmp_saddr = cpu_to_be32(iph->saddr);\r\nnes_debug(NES_DBG_CM, "Received packet: dest=%pI4:0x%04X src=%pI4:0x%04X\n",\r\n&tmp_daddr, tcph->dest, &tmp_saddr, tcph->source);\r\ndo {\r\ncm_node = find_node(cm_core,\r\nnfo.mapped_rem_port, nfo.mapped_rem_addr,\r\nnfo.mapped_loc_port, nfo.mapped_loc_addr);\r\nif (!cm_node) {\r\nif ((!tcph->syn) || (tcph->ack)) {\r\nskb_handled = 0;\r\nbreak;\r\n}\r\nlistener = find_listener(cm_core, nfo.mapped_loc_addr,\r\nnfo.mapped_loc_port,\r\nNES_CM_LISTENER_ACTIVE_STATE, 0);\r\nif (!listener) {\r\nnfo.cm_id = NULL;\r\nnfo.conn_type = 0;\r\nnes_debug(NES_DBG_CM, "Unable to find listener for the pkt\n");\r\nskb_handled = 0;\r\nbreak;\r\n}\r\nnfo.cm_id = listener->cm_id;\r\nnfo.conn_type = listener->conn_type;\r\ncm_node = make_cm_node(cm_core, nesvnic, &nfo,\r\nlistener);\r\nif (!cm_node) {\r\nnes_debug(NES_DBG_CM, "Unable to allocate "\r\n"node\n");\r\ncm_packets_dropped++;\r\natomic_dec(&listener->ref_count);\r\ndev_kfree_skb_any(skb);\r\nbreak;\r\n}\r\nif (!tcph->rst && !tcph->fin) {\r\ncm_node->state = NES_CM_STATE_LISTENING;\r\n} else {\r\ncm_packets_dropped++;\r\nrem_ref_cm_node(cm_core, cm_node);\r\ndev_kfree_skb_any(skb);\r\nbreak;\r\n}\r\nadd_ref_cm_node(cm_node);\r\n} else if (cm_node->state == NES_CM_STATE_TSA) {\r\nif (cm_node->nesqp->pau_mode)\r\nnes_queue_mgt_skbs(skb, nesvnic, cm_node->nesqp);\r\nelse {\r\nrem_ref_cm_node(cm_core, cm_node);\r\natomic_inc(&cm_accel_dropped_pkts);\r\ndev_kfree_skb_any(skb);\r\n}\r\nbreak;\r\n}\r\nskb_reset_network_header(skb);\r\nskb_set_transport_header(skb, sizeof(*tcph));\r\nskb->len = ntohs(iph->tot_len);\r\nprocess_packet(cm_node, skb, cm_core);\r\nrem_ref_cm_node(cm_core, cm_node);\r\n} while (0);\r\nreturn skb_handled;\r\n}\r\nstatic struct nes_cm_core *nes_cm_alloc_core(void)\r\n{\r\nstruct nes_cm_core *cm_core;\r\ncm_core = kzalloc(sizeof(*cm_core), GFP_KERNEL);\r\nif (!cm_core)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&cm_core->connected_nodes);\r\ninit_timer(&cm_core->tcp_timer);\r\ncm_core->tcp_timer.function = nes_cm_timer_tick;\r\ncm_core->mtu = NES_CM_DEFAULT_MTU;\r\ncm_core->state = NES_CM_STATE_INITED;\r\ncm_core->free_tx_pkt_max = NES_CM_DEFAULT_FREE_PKTS;\r\natomic_set(&cm_core->events_posted, 0);\r\ncm_core->api = &nes_cm_api;\r\nspin_lock_init(&cm_core->ht_lock);\r\nspin_lock_init(&cm_core->listen_list_lock);\r\nINIT_LIST_HEAD(&cm_core->listen_list.list);\r\nnes_debug(NES_DBG_CM, "Init CM Core completed -- cm_core=%p\n", cm_core);\r\nnes_debug(NES_DBG_CM, "Enable QUEUE EVENTS\n");\r\ncm_core->event_wq = create_singlethread_workqueue("nesewq");\r\ncm_core->post_event = nes_cm_post_event;\r\nnes_debug(NES_DBG_CM, "Enable QUEUE DISCONNECTS\n");\r\ncm_core->disconn_wq = create_singlethread_workqueue("nesdwq");\r\nprint_core(cm_core);\r\nreturn cm_core;\r\n}\r\nstatic int mini_cm_dealloc_core(struct nes_cm_core *cm_core)\r\n{\r\nnes_debug(NES_DBG_CM, "De-Alloc CM Core (%p)\n", cm_core);\r\nif (!cm_core)\r\nreturn -EINVAL;\r\nbarrier();\r\nif (timer_pending(&cm_core->tcp_timer))\r\ndel_timer(&cm_core->tcp_timer);\r\ndestroy_workqueue(cm_core->event_wq);\r\ndestroy_workqueue(cm_core->disconn_wq);\r\nnes_debug(NES_DBG_CM, "\n");\r\nkfree(cm_core);\r\nreturn 0;\r\n}\r\nstatic int mini_cm_get(struct nes_cm_core *cm_core)\r\n{\r\nreturn cm_core->state;\r\n}\r\nstatic int mini_cm_set(struct nes_cm_core *cm_core, u32 type, u32 value)\r\n{\r\nint ret = 0;\r\nswitch (type) {\r\ncase NES_CM_SET_PKT_SIZE:\r\ncm_core->mtu = value;\r\nbreak;\r\ncase NES_CM_SET_FREE_PKT_Q_SIZE:\r\ncm_core->free_tx_pkt_max = value;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int nes_cm_init_tsa_conn(struct nes_qp *nesqp, struct nes_cm_node *cm_node)\r\n{\r\nint ret = 0;\r\nif (!nesqp)\r\nreturn -EINVAL;\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_IPV4 |\r\nNES_QPCONTEXT_MISC_NO_NAGLE | NES_QPCONTEXT_MISC_DO_NOT_FRAG |\r\nNES_QPCONTEXT_MISC_DROS);\r\nif (cm_node->tcp_cntxt.snd_wscale || cm_node->tcp_cntxt.rcv_wscale)\r\nnesqp->nesqp_context->misc |= cpu_to_le32(NES_QPCONTEXT_MISC_WSCALE);\r\nnesqp->nesqp_context->misc2 |= cpu_to_le32(64 << NES_QPCONTEXT_MISC2_TTL_SHIFT);\r\nnesqp->nesqp_context->mss |= cpu_to_le32(((u32)cm_node->tcp_cntxt.mss) << 16);\r\nnesqp->nesqp_context->tcp_state_flow_label |= cpu_to_le32(\r\n(u32)NES_QPCONTEXT_TCPSTATE_EST << NES_QPCONTEXT_TCPFLOW_TCP_STATE_SHIFT);\r\nnesqp->nesqp_context->pd_index_wscale |= cpu_to_le32(\r\n(cm_node->tcp_cntxt.snd_wscale << NES_QPCONTEXT_PDWSCALE_SND_WSCALE_SHIFT) &\r\nNES_QPCONTEXT_PDWSCALE_SND_WSCALE_MASK);\r\nnesqp->nesqp_context->pd_index_wscale |= cpu_to_le32(\r\n(cm_node->tcp_cntxt.rcv_wscale << NES_QPCONTEXT_PDWSCALE_RCV_WSCALE_SHIFT) &\r\nNES_QPCONTEXT_PDWSCALE_RCV_WSCALE_MASK);\r\nnesqp->nesqp_context->keepalive = cpu_to_le32(0x80);\r\nnesqp->nesqp_context->ts_recent = 0;\r\nnesqp->nesqp_context->ts_age = 0;\r\nnesqp->nesqp_context->snd_nxt = cpu_to_le32(cm_node->tcp_cntxt.loc_seq_num);\r\nnesqp->nesqp_context->snd_wnd = cpu_to_le32(cm_node->tcp_cntxt.snd_wnd);\r\nnesqp->nesqp_context->rcv_nxt = cpu_to_le32(cm_node->tcp_cntxt.rcv_nxt);\r\nnesqp->nesqp_context->rcv_wnd = cpu_to_le32(cm_node->tcp_cntxt.rcv_wnd <<\r\ncm_node->tcp_cntxt.rcv_wscale);\r\nnesqp->nesqp_context->snd_max = cpu_to_le32(cm_node->tcp_cntxt.loc_seq_num);\r\nnesqp->nesqp_context->snd_una = cpu_to_le32(cm_node->tcp_cntxt.loc_seq_num);\r\nnesqp->nesqp_context->srtt = 0;\r\nnesqp->nesqp_context->rttvar = cpu_to_le32(0x6);\r\nnesqp->nesqp_context->ssthresh = cpu_to_le32(0x3FFFC000);\r\nnesqp->nesqp_context->cwnd = cpu_to_le32(2 * cm_node->tcp_cntxt.mss);\r\nnesqp->nesqp_context->snd_wl1 = cpu_to_le32(cm_node->tcp_cntxt.rcv_nxt);\r\nnesqp->nesqp_context->snd_wl2 = cpu_to_le32(cm_node->tcp_cntxt.loc_seq_num);\r\nnesqp->nesqp_context->max_snd_wnd = cpu_to_le32(cm_node->tcp_cntxt.max_snd_wnd);\r\nnes_debug(NES_DBG_CM, "QP%u: rcv_nxt = 0x%08X, snd_nxt = 0x%08X,"\r\n" Setting MSS to %u, PDWscale = 0x%08X, rcv_wnd = %u, context misc = 0x%08X.\n",\r\nnesqp->hwqp.qp_id, le32_to_cpu(nesqp->nesqp_context->rcv_nxt),\r\nle32_to_cpu(nesqp->nesqp_context->snd_nxt),\r\ncm_node->tcp_cntxt.mss, le32_to_cpu(nesqp->nesqp_context->pd_index_wscale),\r\nle32_to_cpu(nesqp->nesqp_context->rcv_wnd),\r\nle32_to_cpu(nesqp->nesqp_context->misc));\r\nnes_debug(NES_DBG_CM, " snd_wnd = 0x%08X.\n", le32_to_cpu(nesqp->nesqp_context->snd_wnd));\r\nnes_debug(NES_DBG_CM, " snd_cwnd = 0x%08X.\n", le32_to_cpu(nesqp->nesqp_context->cwnd));\r\nnes_debug(NES_DBG_CM, " max_swnd = 0x%08X.\n", le32_to_cpu(nesqp->nesqp_context->max_snd_wnd));\r\nnes_debug(NES_DBG_CM, "Change cm_node state to TSA\n");\r\ncm_node->state = NES_CM_STATE_TSA;\r\nreturn ret;\r\n}\r\nint nes_cm_disconn(struct nes_qp *nesqp)\r\n{\r\nstruct disconn_work *work;\r\nwork = kzalloc(sizeof *work, GFP_ATOMIC);\r\nif (!work)\r\nreturn -ENOMEM;\r\nnes_add_ref(&nesqp->ibqp);\r\nwork->nesqp = nesqp;\r\nINIT_WORK(&work->work, nes_disconnect_worker);\r\nqueue_work(g_cm_core->disconn_wq, &work->work);\r\nreturn 0;\r\n}\r\nstatic void nes_disconnect_worker(struct work_struct *work)\r\n{\r\nstruct disconn_work *dwork = container_of(work, struct disconn_work, work);\r\nstruct nes_qp *nesqp = dwork->nesqp;\r\nkfree(dwork);\r\nnes_debug(NES_DBG_CM, "processing AEQE id 0x%04X for QP%u.\n",\r\nnesqp->last_aeq, nesqp->hwqp.qp_id);\r\nnes_cm_disconn_true(nesqp);\r\nnes_rem_ref(&nesqp->ibqp);\r\n}\r\nstatic int nes_cm_disconn_true(struct nes_qp *nesqp)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nstruct iw_cm_id *cm_id;\r\nstruct iw_cm_event cm_event;\r\nstruct nes_vnic *nesvnic;\r\nu16 last_ae;\r\nu8 original_hw_tcp_state;\r\nu8 original_ibqp_state;\r\nint disconn_status = 0;\r\nint issue_disconn = 0;\r\nint issue_close = 0;\r\nint issue_flush = 0;\r\nu32 flush_q = NES_CQP_FLUSH_RQ;\r\nstruct ib_event ibevent;\r\nif (!nesqp) {\r\nnes_debug(NES_DBG_CM, "disconnect_worker nesqp is NULL\n");\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\ncm_id = nesqp->cm_id;\r\nif (!cm_id) {\r\nnes_debug(NES_DBG_CM, "QP%u disconnect_worker cmid is NULL\n",\r\nnesqp->hwqp.qp_id);\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nreturn -1;\r\n}\r\nnesvnic = to_nesvnic(nesqp->ibqp.device);\r\nnes_debug(NES_DBG_CM, "Disconnecting QP%u\n", nesqp->hwqp.qp_id);\r\noriginal_hw_tcp_state = nesqp->hw_tcp_state;\r\noriginal_ibqp_state = nesqp->ibqp_state;\r\nlast_ae = nesqp->last_aeq;\r\nif (nesqp->term_flags) {\r\nissue_disconn = 1;\r\nissue_close = 1;\r\nnesqp->cm_id = NULL;\r\ndel_timer(&nesqp->terminate_timer);\r\nif (nesqp->flush_issued == 0) {\r\nnesqp->flush_issued = 1;\r\nissue_flush = 1;\r\n}\r\n} else if ((original_hw_tcp_state == NES_AEQE_TCP_STATE_CLOSE_WAIT) ||\r\n((original_ibqp_state == IB_QPS_RTS) &&\r\n(last_ae == NES_AEQE_AEID_LLP_CONNECTION_RESET))) {\r\nissue_disconn = 1;\r\nif (last_ae == NES_AEQE_AEID_LLP_CONNECTION_RESET)\r\ndisconn_status = -ECONNRESET;\r\n}\r\nif (((original_hw_tcp_state == NES_AEQE_TCP_STATE_CLOSED) ||\r\n(original_hw_tcp_state == NES_AEQE_TCP_STATE_TIME_WAIT) ||\r\n(last_ae == NES_AEQE_AEID_RDMAP_ROE_BAD_LLP_CLOSE) ||\r\n(last_ae == NES_AEQE_AEID_LLP_CONNECTION_RESET))) {\r\nissue_close = 1;\r\nnesqp->cm_id = NULL;\r\nif (nesqp->flush_issued == 0) {\r\nnesqp->flush_issued = 1;\r\nissue_flush = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nif ((issue_flush) && (nesqp->destroyed == 0)) {\r\nif (nesqp->hw_iwarp_state >= NES_AEQE_IWARP_STATE_TERMINATE)\r\nflush_q |= NES_CQP_FLUSH_SQ;\r\nflush_wqes(nesvnic->nesdev, nesqp, flush_q, 1);\r\nif (nesqp->term_flags) {\r\nibevent.device = nesqp->ibqp.device;\r\nibevent.event = nesqp->terminate_eventtype;\r\nibevent.element.qp = &nesqp->ibqp;\r\nif (nesqp->ibqp.event_handler)\r\nnesqp->ibqp.event_handler(&ibevent, nesqp->ibqp.qp_context);\r\n}\r\n}\r\nif ((cm_id) && (cm_id->event_handler)) {\r\nif (issue_disconn) {\r\natomic_inc(&cm_disconnects);\r\ncm_event.event = IW_CM_EVENT_DISCONNECT;\r\ncm_event.status = disconn_status;\r\ncm_event.local_addr = cm_id->local_addr;\r\ncm_event.remote_addr = cm_id->remote_addr;\r\ncm_event.private_data = NULL;\r\ncm_event.private_data_len = 0;\r\nnes_debug(NES_DBG_CM, "Generating a CM Disconnect Event"\r\n" for QP%u, SQ Head = %u, SQ Tail = %u. "\r\n"cm_id = %p, refcount = %u.\n",\r\nnesqp->hwqp.qp_id, nesqp->hwqp.sq_head,\r\nnesqp->hwqp.sq_tail, cm_id,\r\natomic_read(&nesqp->refcount));\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nif (ret)\r\nnes_debug(NES_DBG_CM, "OFA CM event_handler "\r\n"returned, ret=%d\n", ret);\r\n}\r\nif (issue_close) {\r\natomic_inc(&cm_closes);\r\nnes_disconnect(nesqp, 1);\r\ncm_id->provider_data = nesqp;\r\ncm_event.event = IW_CM_EVENT_CLOSE;\r\ncm_event.status = 0;\r\ncm_event.provider_data = cm_id->provider_data;\r\ncm_event.local_addr = cm_id->local_addr;\r\ncm_event.remote_addr = cm_id->remote_addr;\r\ncm_event.private_data = NULL;\r\ncm_event.private_data_len = 0;\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nif (ret)\r\nnes_debug(NES_DBG_CM, "OFA CM event_handler returned, ret=%d\n", ret);\r\ncm_id->rem_ref(cm_id);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int nes_disconnect(struct nes_qp *nesqp, int abrupt)\r\n{\r\nint ret = 0;\r\nstruct nes_vnic *nesvnic;\r\nstruct nes_device *nesdev;\r\nstruct nes_ib_device *nesibdev;\r\nnesvnic = to_nesvnic(nesqp->ibqp.device);\r\nif (!nesvnic)\r\nreturn -EINVAL;\r\nnesdev = nesvnic->nesdev;\r\nnesibdev = nesvnic->nesibdev;\r\nnes_debug(NES_DBG_CM, "netdev refcnt = %u.\n",\r\nnetdev_refcnt_read(nesvnic->netdev));\r\nif (nesqp->active_conn) {\r\nnesqp->active_conn = 0;\r\n} else {\r\nif (nesqp->ietf_frame) {\r\nif (nesqp->lsmm_mr)\r\nnesibdev->ibdev.dereg_mr(nesqp->lsmm_mr);\r\npci_free_consistent(nesdev->pcidev,\r\nnesqp->private_data_len + nesqp->ietf_frame_size,\r\nnesqp->ietf_frame, nesqp->ietf_frame_pbase);\r\n}\r\n}\r\nif (nesqp->cm_node) {\r\nnes_debug(NES_DBG_CM, "Call close API\n");\r\ng_cm_core->api->close(g_cm_core, nesqp->cm_node);\r\n}\r\nreturn ret;\r\n}\r\nint nes_accept(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\r\n{\r\nu64 u64temp;\r\nstruct ib_qp *ibqp;\r\nstruct nes_qp *nesqp;\r\nstruct nes_vnic *nesvnic;\r\nstruct nes_device *nesdev;\r\nstruct nes_cm_node *cm_node;\r\nstruct nes_adapter *adapter;\r\nstruct ib_qp_attr attr;\r\nstruct iw_cm_event cm_event;\r\nstruct nes_hw_qp_wqe *wqe;\r\nstruct nes_v4_quad nes_quad;\r\nu32 crc_value;\r\nint ret;\r\nint passive_state;\r\nstruct nes_ib_device *nesibdev;\r\nstruct ib_mr *ibmr = NULL;\r\nstruct ib_phys_buf ibphysbuf;\r\nstruct nes_pd *nespd;\r\nu64 tagged_offset;\r\nu8 mpa_frame_offset = 0;\r\nstruct ietf_mpa_v2 *mpa_v2_frame;\r\nu8 start_addr = 0;\r\nu8 *start_ptr = &start_addr;\r\nu8 **start_buff = &start_ptr;\r\nu16 buff_len = 0;\r\nstruct sockaddr_in *laddr = (struct sockaddr_in *)&cm_id->local_addr;\r\nstruct sockaddr_in *raddr = (struct sockaddr_in *)&cm_id->remote_addr;\r\nibqp = nes_get_qp(cm_id->device, conn_param->qpn);\r\nif (!ibqp)\r\nreturn -EINVAL;\r\nnesqp = to_nesqp(ibqp);\r\nnesvnic = to_nesvnic(nesqp->ibqp.device);\r\nnesdev = nesvnic->nesdev;\r\nadapter = nesdev->nesadapter;\r\ncm_node = (struct nes_cm_node *)cm_id->provider_data;\r\nnes_debug(NES_DBG_CM, "nes_accept: cm_node= %p nesvnic=%p, netdev=%p,"\r\n"%s\n", cm_node, nesvnic, nesvnic->netdev,\r\nnesvnic->netdev->name);\r\nif (NES_CM_STATE_LISTENER_DESTROYED == cm_node->state) {\r\nif (cm_node->loopbackpartner)\r\nrem_ref_cm_node(cm_node->cm_core, cm_node->loopbackpartner);\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\nreturn -EINVAL;\r\n}\r\npassive_state = atomic_add_return(1, &cm_node->passive_state);\r\nif (passive_state == NES_SEND_RESET_EVENT) {\r\nrem_ref_cm_node(cm_node->cm_core, cm_node);\r\nreturn -ECONNRESET;\r\n}\r\nnesqp->cm_node = (void *)cm_node;\r\ncm_node->nesqp = nesqp;\r\nnes_debug(NES_DBG_CM, "QP%u, cm_node=%p, jiffies = %lu listener = %p\n",\r\nnesqp->hwqp.qp_id, cm_node, jiffies, cm_node->listener);\r\natomic_inc(&cm_accepts);\r\nnes_debug(NES_DBG_CM, "netdev refcnt = %u.\n",\r\nnetdev_refcnt_read(nesvnic->netdev));\r\nnesqp->ietf_frame_size = sizeof(struct ietf_mpa_v2);\r\nnesqp->ietf_frame = pci_alloc_consistent(nesdev->pcidev,\r\nnesqp->ietf_frame_size + conn_param->private_data_len,\r\n&nesqp->ietf_frame_pbase);\r\nif (!nesqp->ietf_frame) {\r\nnes_debug(NES_DBG_CM, "Unable to allocate memory for private data\n");\r\nreturn -ENOMEM;\r\n}\r\nmpa_v2_frame = (struct ietf_mpa_v2 *)nesqp->ietf_frame;\r\nif (cm_node->mpa_frame_rev == IETF_MPA_V1)\r\nmpa_frame_offset = 4;\r\nif (cm_node->mpa_frame_rev == IETF_MPA_V1 ||\r\ncm_node->mpav2_ird_ord == IETF_NO_IRD_ORD) {\r\nrecord_ird_ord(cm_node, (u16)conn_param->ird, (u16)conn_param->ord);\r\n}\r\nmemcpy(mpa_v2_frame->priv_data, conn_param->private_data,\r\nconn_param->private_data_len);\r\ncm_build_mpa_frame(cm_node, start_buff, &buff_len, nesqp->ietf_frame, MPA_KEY_REPLY);\r\nnesqp->private_data_len = conn_param->private_data_len;\r\nwqe = &nesqp->hwqp.sq_vbase[0];\r\nif (raddr->sin_addr.s_addr != laddr->sin_addr.s_addr) {\r\nu64temp = (unsigned long)nesqp;\r\nnesibdev = nesvnic->nesibdev;\r\nnespd = nesqp->nespd;\r\nibphysbuf.addr = nesqp->ietf_frame_pbase + mpa_frame_offset;\r\nibphysbuf.size = buff_len;\r\ntagged_offset = (u64)(unsigned long)*start_buff;\r\nibmr = nesibdev->ibdev.reg_phys_mr((struct ib_pd *)nespd,\r\n&ibphysbuf, 1,\r\nIB_ACCESS_LOCAL_WRITE,\r\n&tagged_offset);\r\nif (!ibmr) {\r\nnes_debug(NES_DBG_CM, "Unable to register memory region"\r\n"for lSMM for cm_node = %p \n",\r\ncm_node);\r\npci_free_consistent(nesdev->pcidev,\r\nnesqp->private_data_len + nesqp->ietf_frame_size,\r\nnesqp->ietf_frame, nesqp->ietf_frame_pbase);\r\nreturn -ENOMEM;\r\n}\r\nibmr->pd = &nespd->ibpd;\r\nibmr->device = nespd->ibpd.device;\r\nnesqp->lsmm_mr = ibmr;\r\nu64temp |= NES_SW_CONTEXT_ALIGN >> 1;\r\nset_wqe_64bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_WQE_COMP_CTX_LOW_IDX,\r\nu64temp);\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_MISC_IDX] =\r\ncpu_to_le32(NES_IWARP_SQ_WQE_STREAMING |\r\nNES_IWARP_SQ_WQE_WRPDU);\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_TOTAL_PAYLOAD_IDX] =\r\ncpu_to_le32(buff_len);\r\nset_wqe_64bit_value(wqe->wqe_words,\r\nNES_IWARP_SQ_WQE_FRAG0_LOW_IDX,\r\n(u64)(unsigned long)(*start_buff));\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_LENGTH0_IDX] =\r\ncpu_to_le32(buff_len);\r\nwqe->wqe_words[NES_IWARP_SQ_WQE_STAG0_IDX] = ibmr->lkey;\r\nif (nesqp->sq_kmapped) {\r\nnesqp->sq_kmapped = 0;\r\nkunmap(nesqp->page);\r\n}\r\nnesqp->nesqp_context->ird_ord_sizes |=\r\ncpu_to_le32(NES_QPCONTEXT_ORDIRD_LSMM_PRESENT |\r\nNES_QPCONTEXT_ORDIRD_WRPDU);\r\n} else {\r\nnesqp->nesqp_context->ird_ord_sizes |=\r\ncpu_to_le32(NES_QPCONTEXT_ORDIRD_WRPDU);\r\n}\r\nnesqp->skip_lsmm = 1;\r\nnesqp->cm_id = cm_id;\r\ncm_node->cm_id = cm_id;\r\ncm_id->provider_data = nesqp;\r\nnesqp->active_conn = 0;\r\nif (cm_node->state == NES_CM_STATE_TSA)\r\nnes_debug(NES_DBG_CM, "Already state = TSA for cm_node=%p\n",\r\ncm_node);\r\nnes_cm_init_tsa_conn(nesqp, cm_node);\r\nnesqp->nesqp_context->tcpPorts[0] =\r\ncpu_to_le16(cm_node->mapped_loc_port);\r\nnesqp->nesqp_context->tcpPorts[1] =\r\ncpu_to_le16(cm_node->mapped_rem_port);\r\nnesqp->nesqp_context->ip0 = cpu_to_le32(cm_node->mapped_rem_addr);\r\nnesqp->nesqp_context->misc2 |= cpu_to_le32(\r\n(u32)PCI_FUNC(nesdev->pcidev->devfn) <<\r\nNES_QPCONTEXT_MISC2_SRC_IP_SHIFT);\r\nnesqp->nesqp_context->arp_index_vlan |=\r\ncpu_to_le32(nes_arp_table(nesdev,\r\nle32_to_cpu(nesqp->nesqp_context->ip0), NULL,\r\nNES_ARP_RESOLVE) << 16);\r\nnesqp->nesqp_context->ts_val_delta = cpu_to_le32(\r\njiffies - nes_read_indexed(nesdev, NES_IDX_TCP_NOW));\r\nnesqp->nesqp_context->ird_index = cpu_to_le32(nesqp->hwqp.qp_id);\r\nnesqp->nesqp_context->ird_ord_sizes |= cpu_to_le32(\r\n((u32)1 << NES_QPCONTEXT_ORDIRD_IWARP_MODE_SHIFT));\r\nnesqp->nesqp_context->ird_ord_sizes |=\r\ncpu_to_le32((u32)cm_node->ord_size);\r\nmemset(&nes_quad, 0, sizeof(nes_quad));\r\nnes_quad.DstIpAdrIndex =\r\ncpu_to_le32((u32)PCI_FUNC(nesdev->pcidev->devfn) << 24);\r\nnes_quad.SrcIpadr = htonl(cm_node->mapped_rem_addr);\r\nnes_quad.TcpPorts[0] = htons(cm_node->mapped_rem_port);\r\nnes_quad.TcpPorts[1] = htons(cm_node->mapped_loc_port);\r\ncrc_value = get_crc_value(&nes_quad);\r\nnesqp->hte_index = cpu_to_be32(crc_value ^ 0xffffffff);\r\nnes_debug(NES_DBG_CM, "HTE Index = 0x%08X, CRC = 0x%08X\n",\r\nnesqp->hte_index, nesqp->hte_index & adapter->hte_index_mask);\r\nnesqp->hte_index &= adapter->hte_index_mask;\r\nnesqp->nesqp_context->hte_index = cpu_to_le32(nesqp->hte_index);\r\ncm_node->cm_core->api->accelerated(cm_node->cm_core, cm_node);\r\nnes_debug(NES_DBG_CM, "QP%u, Destination IP = 0x%08X:0x%04X, local = "\r\n"0x%08X:0x%04X, rcv_nxt=0x%08X, snd_nxt=0x%08X, mpa + "\r\n"private data length=%u.\n", nesqp->hwqp.qp_id,\r\nntohl(raddr->sin_addr.s_addr), ntohs(raddr->sin_port),\r\nntohl(laddr->sin_addr.s_addr), ntohs(laddr->sin_port),\r\nle32_to_cpu(nesqp->nesqp_context->rcv_nxt),\r\nle32_to_cpu(nesqp->nesqp_context->snd_nxt),\r\nbuff_len);\r\ncm_id->add_ref(cm_id);\r\nnes_add_ref(&nesqp->ibqp);\r\ncm_event.event = IW_CM_EVENT_ESTABLISHED;\r\ncm_event.status = 0;\r\ncm_event.provider_data = (void *)nesqp;\r\ncm_event.local_addr = cm_id->local_addr;\r\ncm_event.remote_addr = cm_id->remote_addr;\r\ncm_event.private_data = NULL;\r\ncm_event.private_data_len = 0;\r\ncm_event.ird = cm_node->ird_size;\r\ncm_event.ord = cm_node->ord_size;\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nattr.qp_state = IB_QPS_RTS;\r\nnes_modify_qp(&nesqp->ibqp, &attr, IB_QP_STATE, NULL);\r\nif (cm_node->loopbackpartner) {\r\ncm_node->loopbackpartner->mpa_frame_size =\r\nnesqp->private_data_len;\r\nmemcpy(cm_node->loopbackpartner->mpa_frame_buf,\r\nconn_param->private_data, conn_param->private_data_len);\r\ncreate_event(cm_node->loopbackpartner, NES_CM_EVENT_CONNECTED);\r\n}\r\nif (ret)\r\nprintk(KERN_ERR "%s[%u] OFA CM event_handler returned, "\r\n"ret=%d\n", __func__, __LINE__, ret);\r\nreturn 0;\r\n}\r\nint nes_reject(struct iw_cm_id *cm_id, const void *pdata, u8 pdata_len)\r\n{\r\nstruct nes_cm_node *cm_node;\r\nstruct nes_cm_node *loopback;\r\nstruct nes_cm_core *cm_core;\r\nu8 *start_buff;\r\natomic_inc(&cm_rejects);\r\ncm_node = (struct nes_cm_node *)cm_id->provider_data;\r\nloopback = cm_node->loopbackpartner;\r\ncm_core = cm_node->cm_core;\r\ncm_node->cm_id = cm_id;\r\nif (pdata_len + sizeof(struct ietf_mpa_v2) > MAX_CM_BUFFER)\r\nreturn -EINVAL;\r\nif (loopback) {\r\nmemcpy(&loopback->mpa_frame.priv_data, pdata, pdata_len);\r\nloopback->mpa_frame.priv_data_len = pdata_len;\r\nloopback->mpa_frame_size = pdata_len;\r\n} else {\r\nstart_buff = &cm_node->mpa_frame_buf[0] + sizeof(struct ietf_mpa_v2);\r\ncm_node->mpa_frame_size = pdata_len;\r\nmemcpy(start_buff, pdata, pdata_len);\r\n}\r\nreturn cm_core->api->reject(cm_core, cm_node);\r\n}\r\nint nes_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\r\n{\r\nstruct ib_qp *ibqp;\r\nstruct nes_qp *nesqp;\r\nstruct nes_vnic *nesvnic;\r\nstruct nes_device *nesdev;\r\nstruct nes_cm_node *cm_node;\r\nstruct nes_cm_info cm_info;\r\nint apbvt_set = 0;\r\nstruct sockaddr_in *laddr = (struct sockaddr_in *)&cm_id->local_addr;\r\nstruct sockaddr_in *raddr = (struct sockaddr_in *)&cm_id->remote_addr;\r\nstruct iwpm_dev_data pm_reg_msg;\r\nstruct iwpm_sa_data pm_msg;\r\nint iwpm_err = 0;\r\nif (cm_id->remote_addr.ss_family != AF_INET)\r\nreturn -ENOSYS;\r\nibqp = nes_get_qp(cm_id->device, conn_param->qpn);\r\nif (!ibqp)\r\nreturn -EINVAL;\r\nnesqp = to_nesqp(ibqp);\r\nif (!nesqp)\r\nreturn -EINVAL;\r\nnesvnic = to_nesvnic(nesqp->ibqp.device);\r\nif (!nesvnic)\r\nreturn -EINVAL;\r\nnesdev = nesvnic->nesdev;\r\nif (!nesdev)\r\nreturn -EINVAL;\r\nif (!laddr->sin_port || !raddr->sin_port)\r\nreturn -EINVAL;\r\nnes_debug(NES_DBG_CM, "QP%u, current IP = 0x%08X, Destination IP = "\r\n"0x%08X:0x%04X, local = 0x%08X:0x%04X.\n", nesqp->hwqp.qp_id,\r\nntohl(nesvnic->local_ipaddr), ntohl(raddr->sin_addr.s_addr),\r\nntohs(raddr->sin_port), ntohl(laddr->sin_addr.s_addr),\r\nntohs(laddr->sin_port));\r\natomic_inc(&cm_connects);\r\nnesqp->active_conn = 1;\r\nnesqp->cm_id = cm_id;\r\ncm_id->provider_data = nesqp;\r\nnesqp->private_data_len = conn_param->private_data_len;\r\nnes_debug(NES_DBG_CM, "requested ord = 0x%08X.\n", (u32)conn_param->ord);\r\nnes_debug(NES_DBG_CM, "mpa private data len =%u\n",\r\nconn_param->private_data_len);\r\ncm_info.loc_addr = ntohl(laddr->sin_addr.s_addr);\r\ncm_info.loc_port = ntohs(laddr->sin_port);\r\ncm_info.rem_addr = ntohl(raddr->sin_addr.s_addr);\r\ncm_info.rem_port = ntohs(raddr->sin_port);\r\ncm_info.cm_id = cm_id;\r\ncm_info.conn_type = NES_CM_IWARP_CONN_TYPE;\r\ncm_info.mapped_loc_addr = cm_info.loc_addr;\r\ncm_info.mapped_loc_port = cm_info.loc_port;\r\ncm_info.mapped_rem_addr = cm_info.rem_addr;\r\ncm_info.mapped_rem_port = cm_info.rem_port;\r\nnes_form_reg_msg(nesvnic, &pm_reg_msg);\r\niwpm_err = iwpm_register_pid(&pm_reg_msg, RDMA_NL_NES);\r\nif (iwpm_err) {\r\nnes_debug(NES_DBG_NLMSG,\r\n"Port Mapper reg pid fail (err = %d).\n", iwpm_err);\r\n}\r\nif (iwpm_valid_pid() && !iwpm_err) {\r\nnes_form_pm_msg(&cm_info, &pm_msg);\r\niwpm_err = iwpm_add_and_query_mapping(&pm_msg, RDMA_NL_NES);\r\nif (iwpm_err)\r\nnes_debug(NES_DBG_NLMSG,\r\n"Port Mapper query fail (err = %d).\n", iwpm_err);\r\nelse\r\nnes_record_pm_msg(&cm_info, &pm_msg);\r\n}\r\nif (laddr->sin_addr.s_addr != raddr->sin_addr.s_addr) {\r\nnes_manage_apbvt(nesvnic, cm_info.mapped_loc_port,\r\nPCI_FUNC(nesdev->pcidev->devfn), NES_MANAGE_APBVT_ADD);\r\napbvt_set = 1;\r\n}\r\nif (nes_create_mapinfo(&cm_info))\r\nreturn -ENOMEM;\r\ncm_id->add_ref(cm_id);\r\ncm_node = g_cm_core->api->connect(g_cm_core, nesvnic,\r\nconn_param->private_data_len, (void *)conn_param->private_data,\r\n&cm_info);\r\nif (!cm_node) {\r\nif (apbvt_set)\r\nnes_manage_apbvt(nesvnic, cm_info.mapped_loc_port,\r\nPCI_FUNC(nesdev->pcidev->devfn),\r\nNES_MANAGE_APBVT_DEL);\r\nnes_debug(NES_DBG_NLMSG, "Delete mapped_loc_port = %04X\n",\r\ncm_info.mapped_loc_port);\r\nnes_remove_mapinfo(cm_info.loc_addr, cm_info.loc_port,\r\ncm_info.mapped_loc_addr, cm_info.mapped_loc_port);\r\ncm_id->rem_ref(cm_id);\r\nreturn -ENOMEM;\r\n}\r\nrecord_ird_ord(cm_node, (u16)conn_param->ird, (u16)conn_param->ord);\r\nif (cm_node->send_rdma0_op == SEND_RDMA_READ_ZERO &&\r\ncm_node->ord_size == 0)\r\ncm_node->ord_size = 1;\r\ncm_node->apbvt_set = apbvt_set;\r\nnesqp->cm_node = cm_node;\r\ncm_node->nesqp = nesqp;\r\nnes_add_ref(&nesqp->ibqp);\r\nreturn 0;\r\n}\r\nint nes_create_listen(struct iw_cm_id *cm_id, int backlog)\r\n{\r\nstruct nes_vnic *nesvnic;\r\nstruct nes_cm_listener *cm_node;\r\nstruct nes_cm_info cm_info;\r\nint err;\r\nstruct sockaddr_in *laddr = (struct sockaddr_in *)&cm_id->local_addr;\r\nnes_debug(NES_DBG_CM, "cm_id = %p, local port = 0x%04X.\n",\r\ncm_id, ntohs(laddr->sin_port));\r\nif (cm_id->local_addr.ss_family != AF_INET)\r\nreturn -ENOSYS;\r\nnesvnic = to_nesvnic(cm_id->device);\r\nif (!nesvnic)\r\nreturn -EINVAL;\r\nnes_debug(NES_DBG_CM, "nesvnic=%p, netdev=%p, %s\n",\r\nnesvnic, nesvnic->netdev, nesvnic->netdev->name);\r\nnes_debug(NES_DBG_CM, "nesvnic->local_ipaddr=0x%08x, sin_addr.s_addr=0x%08x\n",\r\nnesvnic->local_ipaddr, laddr->sin_addr.s_addr);\r\ncm_info.loc_addr = ntohl(nesvnic->local_ipaddr);\r\ncm_info.loc_port = ntohs(laddr->sin_port);\r\ncm_info.backlog = backlog;\r\ncm_info.cm_id = cm_id;\r\ncm_info.conn_type = NES_CM_IWARP_CONN_TYPE;\r\ncm_info.mapped_loc_addr = cm_info.loc_addr;\r\ncm_info.mapped_loc_port = cm_info.loc_port;\r\ncm_node = g_cm_core->api->listen(g_cm_core, nesvnic, &cm_info);\r\nif (!cm_node) {\r\nprintk(KERN_ERR "%s[%u] Error returned from listen API call\n",\r\n__func__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\ncm_id->provider_data = cm_node;\r\nif (!cm_node->reused_node) {\r\nif (nes_create_mapinfo(&cm_info))\r\nreturn -ENOMEM;\r\nerr = nes_manage_apbvt(nesvnic, cm_node->mapped_loc_port,\r\nPCI_FUNC(nesvnic->nesdev->pcidev->devfn),\r\nNES_MANAGE_APBVT_ADD);\r\nif (err) {\r\nprintk(KERN_ERR "nes_manage_apbvt call returned %d.\n",\r\nerr);\r\ng_cm_core->api->stop_listener(g_cm_core, (void *)cm_node);\r\nreturn err;\r\n}\r\natomic_inc(&cm_listens_created);\r\n}\r\ncm_id->add_ref(cm_id);\r\ncm_id->provider_data = (void *)cm_node;\r\nreturn 0;\r\n}\r\nint nes_destroy_listen(struct iw_cm_id *cm_id)\r\n{\r\nif (cm_id->provider_data)\r\ng_cm_core->api->stop_listener(g_cm_core, cm_id->provider_data);\r\nelse\r\nnes_debug(NES_DBG_CM, "cm_id->provider_data was NULL\n");\r\ncm_id->rem_ref(cm_id);\r\nreturn 0;\r\n}\r\nint nes_cm_recv(struct sk_buff *skb, struct net_device *netdevice)\r\n{\r\nint rc = 0;\r\ncm_packets_received++;\r\nif ((g_cm_core) && (g_cm_core->api))\r\nrc = g_cm_core->api->recv_pkt(g_cm_core, netdev_priv(netdevice), skb);\r\nelse\r\nnes_debug(NES_DBG_CM, "Unable to process packet for CM,"\r\n" cm is not setup properly.\n");\r\nreturn rc;\r\n}\r\nint nes_cm_start(void)\r\n{\r\nnes_debug(NES_DBG_CM, "\n");\r\ng_cm_core = nes_cm_alloc_core();\r\nif (g_cm_core)\r\nreturn 0;\r\nelse\r\nreturn -ENOMEM;\r\n}\r\nint nes_cm_stop(void)\r\n{\r\ng_cm_core->api->destroy_cm_core(g_cm_core);\r\nreturn 0;\r\n}\r\nstatic void cm_event_connected(struct nes_cm_event *event)\r\n{\r\nstruct nes_qp *nesqp;\r\nstruct nes_vnic *nesvnic;\r\nstruct nes_device *nesdev;\r\nstruct nes_cm_node *cm_node;\r\nstruct nes_adapter *nesadapter;\r\nstruct ib_qp_attr attr;\r\nstruct iw_cm_id *cm_id;\r\nstruct iw_cm_event cm_event;\r\nstruct nes_v4_quad nes_quad;\r\nu32 crc_value;\r\nint ret;\r\nstruct sockaddr_in *laddr;\r\nstruct sockaddr_in *raddr;\r\nstruct sockaddr_in *cm_event_laddr;\r\ncm_node = event->cm_node;\r\ncm_id = cm_node->cm_id;\r\nnes_debug(NES_DBG_CM, "cm_event_connected - %p - cm_id = %p\n", cm_node, cm_id);\r\nnesqp = (struct nes_qp *)cm_id->provider_data;\r\nnesvnic = to_nesvnic(nesqp->ibqp.device);\r\nnesdev = nesvnic->nesdev;\r\nnesadapter = nesdev->nesadapter;\r\nladdr = (struct sockaddr_in *)&cm_id->local_addr;\r\nraddr = (struct sockaddr_in *)&cm_id->remote_addr;\r\ncm_event_laddr = (struct sockaddr_in *)&cm_event.local_addr;\r\nif (nesqp->destroyed)\r\nreturn;\r\natomic_inc(&cm_connecteds);\r\nnes_debug(NES_DBG_CM, "QP%u attempting to connect to 0x%08X:0x%04X on"\r\n" local port 0x%04X. jiffies = %lu.\n",\r\nnesqp->hwqp.qp_id, ntohl(raddr->sin_addr.s_addr),\r\nntohs(raddr->sin_port), ntohs(laddr->sin_port), jiffies);\r\nnes_cm_init_tsa_conn(nesqp, cm_node);\r\nnesqp->nesqp_context->tcpPorts[0] =\r\ncpu_to_le16(cm_node->mapped_loc_port);\r\nnesqp->nesqp_context->tcpPorts[1] =\r\ncpu_to_le16(cm_node->mapped_rem_port);\r\nnesqp->nesqp_context->ip0 = cpu_to_le32(cm_node->mapped_rem_addr);\r\nnesqp->nesqp_context->misc2 |= cpu_to_le32(\r\n(u32)PCI_FUNC(nesdev->pcidev->devfn) <<\r\nNES_QPCONTEXT_MISC2_SRC_IP_SHIFT);\r\nnesqp->nesqp_context->arp_index_vlan |= cpu_to_le32(\r\nnes_arp_table(nesdev,\r\nle32_to_cpu(nesqp->nesqp_context->ip0),\r\nNULL, NES_ARP_RESOLVE) << 16);\r\nnesqp->nesqp_context->ts_val_delta = cpu_to_le32(\r\njiffies - nes_read_indexed(nesdev, NES_IDX_TCP_NOW));\r\nnesqp->nesqp_context->ird_index = cpu_to_le32(nesqp->hwqp.qp_id);\r\nnesqp->nesqp_context->ird_ord_sizes |=\r\ncpu_to_le32((u32)1 <<\r\nNES_QPCONTEXT_ORDIRD_IWARP_MODE_SHIFT);\r\nnesqp->nesqp_context->ird_ord_sizes |=\r\ncpu_to_le32((u32)cm_node->ord_size);\r\nbuild_rdma0_msg(cm_node, &nesqp);\r\nnes_write32(nesdev->regs + NES_WQE_ALLOC,\r\n(1 << 24) | 0x00800000 | nesqp->hwqp.qp_id);\r\nmemset(&nes_quad, 0, sizeof(nes_quad));\r\nnes_quad.DstIpAdrIndex =\r\ncpu_to_le32((u32)PCI_FUNC(nesdev->pcidev->devfn) << 24);\r\nnes_quad.SrcIpadr = htonl(cm_node->mapped_rem_addr);\r\nnes_quad.TcpPorts[0] = htons(cm_node->mapped_rem_port);\r\nnes_quad.TcpPorts[1] = htons(cm_node->mapped_loc_port);\r\ncrc_value = get_crc_value(&nes_quad);\r\nnesqp->hte_index = cpu_to_be32(crc_value ^ 0xffffffff);\r\nnes_debug(NES_DBG_CM, "HTE Index = 0x%08X, After CRC = 0x%08X\n",\r\nnesqp->hte_index, nesqp->hte_index & nesadapter->hte_index_mask);\r\nnesqp->hte_index &= nesadapter->hte_index_mask;\r\nnesqp->nesqp_context->hte_index = cpu_to_le32(nesqp->hte_index);\r\nnesqp->ietf_frame = &cm_node->mpa_frame;\r\nnesqp->private_data_len = (u8)cm_node->mpa_frame_size;\r\ncm_node->cm_core->api->accelerated(cm_node->cm_core, cm_node);\r\ncm_event.event = IW_CM_EVENT_CONNECT_REPLY;\r\ncm_event.status = 0;\r\ncm_event.provider_data = cm_id->provider_data;\r\ncm_event_laddr->sin_family = AF_INET;\r\ncm_event_laddr->sin_port = laddr->sin_port;\r\ncm_event.remote_addr = cm_id->remote_addr;\r\ncm_event.private_data = (void *)event->cm_node->mpa_frame_buf;\r\ncm_event.private_data_len = (u8)event->cm_node->mpa_frame_size;\r\ncm_event.ird = cm_node->ird_size;\r\ncm_event.ord = cm_node->ord_size;\r\ncm_event_laddr->sin_addr.s_addr = htonl(event->cm_info.rem_addr);\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nnes_debug(NES_DBG_CM, "OFA CM event_handler returned, ret=%d\n", ret);\r\nif (ret)\r\nprintk(KERN_ERR "%s[%u] OFA CM event_handler returned, "\r\n"ret=%d\n", __func__, __LINE__, ret);\r\nattr.qp_state = IB_QPS_RTS;\r\nnes_modify_qp(&nesqp->ibqp, &attr, IB_QP_STATE, NULL);\r\nnes_debug(NES_DBG_CM, "Exiting connect thread for QP%u. jiffies = "\r\n"%lu\n", nesqp->hwqp.qp_id, jiffies);\r\nreturn;\r\n}\r\nstatic void cm_event_connect_error(struct nes_cm_event *event)\r\n{\r\nstruct nes_qp *nesqp;\r\nstruct iw_cm_id *cm_id;\r\nstruct iw_cm_event cm_event;\r\nint ret;\r\nif (!event->cm_node)\r\nreturn;\r\ncm_id = event->cm_node->cm_id;\r\nif (!cm_id)\r\nreturn;\r\nnes_debug(NES_DBG_CM, "cm_node=%p, cm_id=%p\n", event->cm_node, cm_id);\r\nnesqp = cm_id->provider_data;\r\nif (!nesqp)\r\nreturn;\r\nnesqp->cm_id = NULL;\r\ncm_id->provider_data = NULL;\r\ncm_event.event = IW_CM_EVENT_CONNECT_REPLY;\r\ncm_event.status = -ECONNRESET;\r\ncm_event.provider_data = cm_id->provider_data;\r\ncm_event.local_addr = cm_id->local_addr;\r\ncm_event.remote_addr = cm_id->remote_addr;\r\ncm_event.private_data = NULL;\r\ncm_event.private_data_len = 0;\r\n#ifdef CONFIG_INFINIBAND_NES_DEBUG\r\n{\r\nstruct sockaddr_in *cm_event_laddr = (struct sockaddr_in *)\r\n&cm_event.local_addr;\r\nstruct sockaddr_in *cm_event_raddr = (struct sockaddr_in *)\r\n&cm_event.remote_addr;\r\nnes_debug(NES_DBG_CM, "call CM_EVENT REJECTED, local_addr=%08x, remote_addr=%08x\n",\r\ncm_event_laddr->sin_addr.s_addr, cm_event_raddr->sin_addr.s_addr);\r\n}\r\n#endif\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nnes_debug(NES_DBG_CM, "OFA CM event_handler returned, ret=%d\n", ret);\r\nif (ret)\r\nprintk(KERN_ERR "%s[%u] OFA CM event_handler returned, "\r\n"ret=%d\n", __func__, __LINE__, ret);\r\ncm_id->rem_ref(cm_id);\r\nrem_ref_cm_node(event->cm_node->cm_core, event->cm_node);\r\nreturn;\r\n}\r\nstatic void cm_event_reset(struct nes_cm_event *event)\r\n{\r\nstruct nes_qp *nesqp;\r\nstruct iw_cm_id *cm_id;\r\nstruct iw_cm_event cm_event;\r\nint ret;\r\nif (!event->cm_node)\r\nreturn;\r\nif (!event->cm_node->cm_id)\r\nreturn;\r\ncm_id = event->cm_node->cm_id;\r\nnes_debug(NES_DBG_CM, "%p - cm_id = %p\n", event->cm_node, cm_id);\r\nnesqp = cm_id->provider_data;\r\nif (!nesqp)\r\nreturn;\r\nnesqp->cm_id = NULL;\r\ncm_event.event = IW_CM_EVENT_DISCONNECT;\r\ncm_event.status = -ECONNRESET;\r\ncm_event.provider_data = cm_id->provider_data;\r\ncm_event.local_addr = cm_id->local_addr;\r\ncm_event.remote_addr = cm_id->remote_addr;\r\ncm_event.private_data = NULL;\r\ncm_event.private_data_len = 0;\r\ncm_id->add_ref(cm_id);\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\natomic_inc(&cm_closes);\r\ncm_event.event = IW_CM_EVENT_CLOSE;\r\ncm_event.status = 0;\r\ncm_event.provider_data = cm_id->provider_data;\r\ncm_event.local_addr = cm_id->local_addr;\r\ncm_event.remote_addr = cm_id->remote_addr;\r\ncm_event.private_data = NULL;\r\ncm_event.private_data_len = 0;\r\nnes_debug(NES_DBG_CM, "NODE %p Generating CLOSE\n", event->cm_node);\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nnes_debug(NES_DBG_CM, "OFA CM event_handler returned, ret=%d\n", ret);\r\ncm_id->rem_ref(cm_id);\r\nreturn;\r\n}\r\nstatic void cm_event_mpa_req(struct nes_cm_event *event)\r\n{\r\nstruct iw_cm_id *cm_id;\r\nstruct iw_cm_event cm_event;\r\nint ret;\r\nstruct nes_cm_node *cm_node;\r\nstruct sockaddr_in *cm_event_laddr = (struct sockaddr_in *)\r\n&cm_event.local_addr;\r\nstruct sockaddr_in *cm_event_raddr = (struct sockaddr_in *)\r\n&cm_event.remote_addr;\r\ncm_node = event->cm_node;\r\nif (!cm_node)\r\nreturn;\r\ncm_id = cm_node->cm_id;\r\natomic_inc(&cm_connect_reqs);\r\nnes_debug(NES_DBG_CM, "cm_node = %p - cm_id = %p, jiffies = %lu\n",\r\ncm_node, cm_id, jiffies);\r\ncm_event.event = IW_CM_EVENT_CONNECT_REQUEST;\r\ncm_event.status = 0;\r\ncm_event.provider_data = (void *)cm_node;\r\ncm_event_laddr->sin_family = AF_INET;\r\ncm_event_laddr->sin_port = htons(event->cm_info.loc_port);\r\ncm_event_laddr->sin_addr.s_addr = htonl(event->cm_info.loc_addr);\r\ncm_event_raddr->sin_family = AF_INET;\r\ncm_event_raddr->sin_port = htons(event->cm_info.rem_port);\r\ncm_event_raddr->sin_addr.s_addr = htonl(event->cm_info.rem_addr);\r\ncm_event.private_data = cm_node->mpa_frame_buf;\r\ncm_event.private_data_len = (u8)cm_node->mpa_frame_size;\r\nif (cm_node->mpa_frame_rev == IETF_MPA_V1) {\r\ncm_event.ird = NES_MAX_IRD;\r\ncm_event.ord = NES_MAX_ORD;\r\n} else {\r\ncm_event.ird = cm_node->ird_size;\r\ncm_event.ord = cm_node->ord_size;\r\n}\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nif (ret)\r\nprintk(KERN_ERR "%s[%u] OFA CM event_handler returned, ret=%d\n",\r\n__func__, __LINE__, ret);\r\nreturn;\r\n}\r\nstatic void cm_event_mpa_reject(struct nes_cm_event *event)\r\n{\r\nstruct iw_cm_id *cm_id;\r\nstruct iw_cm_event cm_event;\r\nstruct nes_cm_node *cm_node;\r\nint ret;\r\nstruct sockaddr_in *cm_event_laddr = (struct sockaddr_in *)\r\n&cm_event.local_addr;\r\nstruct sockaddr_in *cm_event_raddr = (struct sockaddr_in *)\r\n&cm_event.remote_addr;\r\ncm_node = event->cm_node;\r\nif (!cm_node)\r\nreturn;\r\ncm_id = cm_node->cm_id;\r\natomic_inc(&cm_connect_reqs);\r\nnes_debug(NES_DBG_CM, "cm_node = %p - cm_id = %p, jiffies = %lu\n",\r\ncm_node, cm_id, jiffies);\r\ncm_event.event = IW_CM_EVENT_CONNECT_REPLY;\r\ncm_event.status = -ECONNREFUSED;\r\ncm_event.provider_data = cm_id->provider_data;\r\ncm_event_laddr->sin_family = AF_INET;\r\ncm_event_laddr->sin_port = htons(event->cm_info.loc_port);\r\ncm_event_laddr->sin_addr.s_addr = htonl(event->cm_info.loc_addr);\r\ncm_event_raddr->sin_family = AF_INET;\r\ncm_event_raddr->sin_port = htons(event->cm_info.rem_port);\r\ncm_event_raddr->sin_addr.s_addr = htonl(event->cm_info.rem_addr);\r\ncm_event.private_data = cm_node->mpa_frame_buf;\r\ncm_event.private_data_len = (u8)cm_node->mpa_frame_size;\r\nnes_debug(NES_DBG_CM, "call CM_EVENT_MPA_REJECTED, local_addr=%08x, "\r\n"remove_addr=%08x\n",\r\ncm_event_laddr->sin_addr.s_addr,\r\ncm_event_raddr->sin_addr.s_addr);\r\nret = cm_id->event_handler(cm_id, &cm_event);\r\nif (ret)\r\nprintk(KERN_ERR "%s[%u] OFA CM event_handler returned, ret=%d\n",\r\n__func__, __LINE__, ret);\r\nreturn;\r\n}\r\nstatic int nes_cm_post_event(struct nes_cm_event *event)\r\n{\r\natomic_inc(&event->cm_node->cm_core->events_posted);\r\nadd_ref_cm_node(event->cm_node);\r\nevent->cm_info.cm_id->add_ref(event->cm_info.cm_id);\r\nINIT_WORK(&event->event_work, nes_cm_event_handler);\r\nnes_debug(NES_DBG_CM, "cm_node=%p queue_work, event=%p\n",\r\nevent->cm_node, event);\r\nqueue_work(event->cm_node->cm_core->event_wq, &event->event_work);\r\nnes_debug(NES_DBG_CM, "Exit\n");\r\nreturn 0;\r\n}\r\nstatic void nes_cm_event_handler(struct work_struct *work)\r\n{\r\nstruct nes_cm_event *event = container_of(work, struct nes_cm_event,\r\nevent_work);\r\nstruct nes_cm_core *cm_core;\r\nif ((!event) || (!event->cm_node) || (!event->cm_node->cm_core))\r\nreturn;\r\ncm_core = event->cm_node->cm_core;\r\nnes_debug(NES_DBG_CM, "event=%p, event->type=%u, events posted=%u\n",\r\nevent, event->type, atomic_read(&cm_core->events_posted));\r\nswitch (event->type) {\r\ncase NES_CM_EVENT_MPA_REQ:\r\ncm_event_mpa_req(event);\r\nnes_debug(NES_DBG_CM, "cm_node=%p CM Event: MPA REQUEST\n",\r\nevent->cm_node);\r\nbreak;\r\ncase NES_CM_EVENT_RESET:\r\nnes_debug(NES_DBG_CM, "cm_node = %p CM Event: RESET\n",\r\nevent->cm_node);\r\ncm_event_reset(event);\r\nbreak;\r\ncase NES_CM_EVENT_CONNECTED:\r\nif ((!event->cm_node->cm_id) ||\r\n(event->cm_node->state != NES_CM_STATE_TSA))\r\nbreak;\r\ncm_event_connected(event);\r\nnes_debug(NES_DBG_CM, "CM Event: CONNECTED\n");\r\nbreak;\r\ncase NES_CM_EVENT_MPA_REJECT:\r\nif ((!event->cm_node->cm_id) ||\r\n(event->cm_node->state == NES_CM_STATE_TSA))\r\nbreak;\r\ncm_event_mpa_reject(event);\r\nnes_debug(NES_DBG_CM, "CM Event: REJECT\n");\r\nbreak;\r\ncase NES_CM_EVENT_ABORTED:\r\nif ((!event->cm_node->cm_id) ||\r\n(event->cm_node->state == NES_CM_STATE_TSA))\r\nbreak;\r\ncm_event_connect_error(event);\r\nnes_debug(NES_DBG_CM, "CM Event: ABORTED\n");\r\nbreak;\r\ncase NES_CM_EVENT_DROPPED_PKT:\r\nnes_debug(NES_DBG_CM, "CM Event: DROPPED PKT\n");\r\nbreak;\r\ndefault:\r\nnes_debug(NES_DBG_CM, "CM Event: UNKNOWN EVENT TYPE\n");\r\nbreak;\r\n}\r\natomic_dec(&cm_core->events_posted);\r\nevent->cm_info.cm_id->rem_ref(event->cm_info.cm_id);\r\nrem_ref_cm_node(cm_core, event->cm_node);\r\nkfree(event);\r\nreturn;\r\n}
