void matroxfb_DAC_out(const struct matrox_fb_info *minfo, int reg, int val)\r\n{\r\nDBG_REG(__func__)\r\nmga_outb(M_RAMDAC_BASE+M_X_INDEX, reg);\r\nmga_outb(M_RAMDAC_BASE+M_X_DATAREG, val);\r\n}\r\nint matroxfb_DAC_in(const struct matrox_fb_info *minfo, int reg)\r\n{\r\nDBG_REG(__func__)\r\nmga_outb(M_RAMDAC_BASE+M_X_INDEX, reg);\r\nreturn mga_inb(M_RAMDAC_BASE+M_X_DATAREG);\r\n}\r\nvoid matroxfb_var2my(struct fb_var_screeninfo* var, struct my_timming* mt) {\r\nunsigned int pixclock = var->pixclock;\r\nDBG(__func__)\r\nif (!pixclock) pixclock = 10000;\r\nmt->pixclock = 1000000000 / pixclock;\r\nif (mt->pixclock < 1) mt->pixclock = 1;\r\nmt->mnp = -1;\r\nmt->dblscan = var->vmode & FB_VMODE_DOUBLE;\r\nmt->interlaced = var->vmode & FB_VMODE_INTERLACED;\r\nmt->HDisplay = var->xres;\r\nmt->HSyncStart = mt->HDisplay + var->right_margin;\r\nmt->HSyncEnd = mt->HSyncStart + var->hsync_len;\r\nmt->HTotal = mt->HSyncEnd + var->left_margin;\r\nmt->VDisplay = var->yres;\r\nmt->VSyncStart = mt->VDisplay + var->lower_margin;\r\nmt->VSyncEnd = mt->VSyncStart + var->vsync_len;\r\nmt->VTotal = mt->VSyncEnd + var->upper_margin;\r\nmt->sync = var->sync;\r\n}\r\nint matroxfb_PLL_calcclock(const struct matrox_pll_features* pll, unsigned int freq, unsigned int fmax,\r\nunsigned int* in, unsigned int* feed, unsigned int* post) {\r\nunsigned int bestdiff = ~0;\r\nunsigned int bestvco = 0;\r\nunsigned int fxtal = pll->ref_freq;\r\nunsigned int fwant;\r\nunsigned int p;\r\nDBG(__func__)\r\nfwant = freq;\r\n#ifdef DEBUG\r\nprintk(KERN_ERR "post_shift_max: %d\n", pll->post_shift_max);\r\nprintk(KERN_ERR "ref_freq: %d\n", pll->ref_freq);\r\nprintk(KERN_ERR "freq: %d\n", freq);\r\nprintk(KERN_ERR "vco_freq_min: %d\n", pll->vco_freq_min);\r\nprintk(KERN_ERR "in_div_min: %d\n", pll->in_div_min);\r\nprintk(KERN_ERR "in_div_max: %d\n", pll->in_div_max);\r\nprintk(KERN_ERR "feed_div_min: %d\n", pll->feed_div_min);\r\nprintk(KERN_ERR "feed_div_max: %d\n", pll->feed_div_max);\r\nprintk(KERN_ERR "fmax: %d\n", fmax);\r\n#endif\r\nfor (p = 1; p <= pll->post_shift_max; p++) {\r\nif (fwant * 2 > fmax)\r\nbreak;\r\nfwant *= 2;\r\n}\r\nif (fwant < pll->vco_freq_min) fwant = pll->vco_freq_min;\r\nif (fwant > fmax) fwant = fmax;\r\nfor (; p-- > 0; fwant >>= 1, bestdiff >>= 1) {\r\nunsigned int m;\r\nif (fwant < pll->vco_freq_min) break;\r\nfor (m = pll->in_div_min; m <= pll->in_div_max; m++) {\r\nunsigned int diff, fvco;\r\nunsigned int n;\r\nn = (fwant * (m + 1) + (fxtal >> 1)) / fxtal - 1;\r\nif (n > pll->feed_div_max)\r\nbreak;\r\nif (n < pll->feed_div_min)\r\nn = pll->feed_div_min;\r\nfvco = (fxtal * (n + 1)) / (m + 1);\r\nif (fvco < fwant)\r\ndiff = fwant - fvco;\r\nelse\r\ndiff = fvco - fwant;\r\nif (diff < bestdiff) {\r\nbestdiff = diff;\r\n*post = p;\r\n*in = m;\r\n*feed = n;\r\nbestvco = fvco;\r\n}\r\n}\r\n}\r\ndprintk(KERN_ERR "clk: %02X %02X %02X %d %d %d\n", *in, *feed, *post, fxtal, bestvco, fwant);\r\nreturn bestvco;\r\n}\r\nint matroxfb_vgaHWinit(struct matrox_fb_info *minfo, struct my_timming *m)\r\n{\r\nunsigned int hd, hs, he, hbe, ht;\r\nunsigned int vd, vs, ve, vt, lc;\r\nunsigned int wd;\r\nunsigned int divider;\r\nint i;\r\nstruct matrox_hw_state * const hw = &minfo->hw;\r\nDBG(__func__)\r\nhw->SEQ[0] = 0x00;\r\nhw->SEQ[1] = 0x01;\r\nhw->SEQ[2] = 0x0F;\r\nhw->SEQ[3] = 0x00;\r\nhw->SEQ[4] = 0x0E;\r\nif (m->dblscan) {\r\nm->VTotal <<= 1;\r\nm->VDisplay <<= 1;\r\nm->VSyncStart <<= 1;\r\nm->VSyncEnd <<= 1;\r\n}\r\nif (m->interlaced) {\r\nm->VTotal >>= 1;\r\nm->VDisplay >>= 1;\r\nm->VSyncStart >>= 1;\r\nm->VSyncEnd >>= 1;\r\n}\r\nhw->GCTL[0] = 0x00;\r\nhw->GCTL[1] = 0x00;\r\nhw->GCTL[2] = 0x00;\r\nhw->GCTL[3] = 0x00;\r\nhw->GCTL[4] = 0x00;\r\nhw->GCTL[5] = 0x40;\r\nhw->GCTL[6] = 0x05;\r\nhw->GCTL[7] = 0x0F;\r\nhw->GCTL[8] = 0xFF;\r\nfor (i = 0; i < 16; i++)\r\nhw->ATTR[i] = i;\r\nhw->ATTR[16] = 0x41;\r\nhw->ATTR[17] = 0xFF;\r\nhw->ATTR[18] = 0x0F;\r\nhw->ATTR[19] = 0x00;\r\nhw->ATTR[20] = 0x00;\r\nhd = m->HDisplay >> 3;\r\nhs = m->HSyncStart >> 3;\r\nhe = m->HSyncEnd >> 3;\r\nht = m->HTotal >> 3;\r\ndivider = minfo->curr.final_bppShift;\r\nwhile (divider & 3) {\r\nhd >>= 1;\r\nhs >>= 1;\r\nhe >>= 1;\r\nht >>= 1;\r\ndivider <<= 1;\r\n}\r\ndivider = divider / 4;\r\nwhile (divider > 8) {\r\nhd <<= 1;\r\nhs <<= 1;\r\nhe <<= 1;\r\nht <<= 1;\r\ndivider >>= 1;\r\n}\r\nhd = hd - 1;\r\nhs = hs - 1;\r\nhe = he - 1;\r\nht = ht - 1;\r\nvd = m->VDisplay - 1;\r\nvs = m->VSyncStart - 1;\r\nve = m->VSyncEnd - 1;\r\nvt = m->VTotal - 2;\r\nlc = vd;\r\nif (((ht & 0x07) == 0x06) || ((ht & 0x0F) == 0x04))\r\nht++;\r\nhbe = ht;\r\nwd = minfo->fbcon.var.xres_virtual * minfo->curr.final_bppShift / 64;\r\nhw->CRTCEXT[0] = 0;\r\nhw->CRTCEXT[5] = 0;\r\nif (m->interlaced) {\r\nhw->CRTCEXT[0] = 0x80;\r\nhw->CRTCEXT[5] = (hs + he - ht) >> 1;\r\nif (!m->dblscan)\r\nwd <<= 1;\r\nvt &= ~1;\r\n}\r\nhw->CRTCEXT[0] |= (wd & 0x300) >> 4;\r\nhw->CRTCEXT[1] = (((ht - 4) & 0x100) >> 8) |\r\n((hd & 0x100) >> 7) |\r\n((hs & 0x100) >> 6) |\r\n(hbe & 0x040);\r\nif (minfo->outputs[1].src == MATROXFB_SRC_CRTC1)\r\nhw->CRTCEXT[1] |= 0x88;\r\nhw->CRTCEXT[2] = ((vt & 0xC00) >> 10) |\r\n((vd & 0x400) >> 8) |\r\n((vd & 0xC00) >> 7) |\r\n((vs & 0xC00) >> 5) |\r\n((lc & 0x400) >> 3);\r\nhw->CRTCEXT[3] = (divider - 1) | 0x80;\r\nhw->CRTCEXT[4] = 0;\r\nhw->CRTC[0] = ht-4;\r\nhw->CRTC[1] = hd;\r\nhw->CRTC[2] = hd;\r\nhw->CRTC[3] = (hbe & 0x1F) | 0x80;\r\nhw->CRTC[4] = hs;\r\nhw->CRTC[5] = ((hbe & 0x20) << 2) | (he & 0x1F);\r\nhw->CRTC[6] = vt & 0xFF;\r\nhw->CRTC[7] = ((vt & 0x100) >> 8) |\r\n((vd & 0x100) >> 7) |\r\n((vs & 0x100) >> 6) |\r\n((vd & 0x100) >> 5) |\r\n((lc & 0x100) >> 4) |\r\n((vt & 0x200) >> 4) |\r\n((vd & 0x200) >> 3) |\r\n((vs & 0x200) >> 2);\r\nhw->CRTC[8] = 0x00;\r\nhw->CRTC[9] = ((vd & 0x200) >> 4) |\r\n((lc & 0x200) >> 3);\r\nif (m->dblscan && !m->interlaced)\r\nhw->CRTC[9] |= 0x80;\r\nfor (i = 10; i < 16; i++)\r\nhw->CRTC[i] = 0x00;\r\nhw->CRTC[16] = vs ;\r\nhw->CRTC[17] = (ve & 0x0F) | 0x20;\r\nhw->CRTC[18] = vd ;\r\nhw->CRTC[19] = wd ;\r\nhw->CRTC[20] = 0x00;\r\nhw->CRTC[21] = vd ;\r\nhw->CRTC[22] = (vt + 1) ;\r\nhw->CRTC[23] = 0xC3;\r\nhw->CRTC[24] = lc;\r\nreturn 0;\r\n}\r\nvoid matroxfb_vgaHWrestore(struct matrox_fb_info *minfo)\r\n{\r\nint i;\r\nstruct matrox_hw_state * const hw = &minfo->hw;\r\nCRITFLAGS\r\nDBG(__func__)\r\ndprintk(KERN_INFO "MiscOutReg: %02X\n", hw->MiscOutReg);\r\ndprintk(KERN_INFO "SEQ regs: ");\r\nfor (i = 0; i < 5; i++)\r\ndprintk("%02X:", hw->SEQ[i]);\r\ndprintk("\n");\r\ndprintk(KERN_INFO "GDC regs: ");\r\nfor (i = 0; i < 9; i++)\r\ndprintk("%02X:", hw->GCTL[i]);\r\ndprintk("\n");\r\ndprintk(KERN_INFO "CRTC regs: ");\r\nfor (i = 0; i < 25; i++)\r\ndprintk("%02X:", hw->CRTC[i]);\r\ndprintk("\n");\r\ndprintk(KERN_INFO "ATTR regs: ");\r\nfor (i = 0; i < 21; i++)\r\ndprintk("%02X:", hw->ATTR[i]);\r\ndprintk("\n");\r\nCRITBEGIN\r\nmga_inb(M_ATTR_RESET);\r\nmga_outb(M_ATTR_INDEX, 0);\r\nmga_outb(M_MISC_REG, hw->MiscOutReg);\r\nfor (i = 1; i < 5; i++)\r\nmga_setr(M_SEQ_INDEX, i, hw->SEQ[i]);\r\nmga_setr(M_CRTC_INDEX, 17, hw->CRTC[17] & 0x7F);\r\nfor (i = 0; i < 25; i++)\r\nmga_setr(M_CRTC_INDEX, i, hw->CRTC[i]);\r\nfor (i = 0; i < 9; i++)\r\nmga_setr(M_GRAPHICS_INDEX, i, hw->GCTL[i]);\r\nfor (i = 0; i < 21; i++) {\r\nmga_inb(M_ATTR_RESET);\r\nmga_outb(M_ATTR_INDEX, i);\r\nmga_outb(M_ATTR_INDEX, hw->ATTR[i]);\r\n}\r\nmga_outb(M_PALETTE_MASK, 0xFF);\r\nmga_outb(M_DAC_REG, 0x00);\r\nfor (i = 0; i < 768; i++)\r\nmga_outb(M_DAC_VAL, hw->DACpal[i]);\r\nmga_inb(M_ATTR_RESET);\r\nmga_outb(M_ATTR_INDEX, 0x20);\r\nCRITEND\r\n}\r\nstatic void get_pins(unsigned char __iomem* pins, struct matrox_bios* bd) {\r\nunsigned int b0 = readb(pins);\r\nif (b0 == 0x2E && readb(pins+1) == 0x41) {\r\nunsigned int pins_len = readb(pins+2);\r\nunsigned int i;\r\nunsigned char cksum;\r\nunsigned char* dst = bd->pins;\r\nif (pins_len < 3 || pins_len > 128) {\r\nreturn;\r\n}\r\n*dst++ = 0x2E;\r\n*dst++ = 0x41;\r\n*dst++ = pins_len;\r\ncksum = 0x2E + 0x41 + pins_len;\r\nfor (i = 3; i < pins_len; i++) {\r\ncksum += *dst++ = readb(pins+i);\r\n}\r\nif (cksum) {\r\nreturn;\r\n}\r\nbd->pins_len = pins_len;\r\n} else if (b0 == 0x40 && readb(pins+1) == 0x00) {\r\nunsigned int i;\r\nunsigned char* dst = bd->pins;\r\n*dst++ = 0x40;\r\n*dst++ = 0;\r\nfor (i = 2; i < 0x40; i++) {\r\n*dst++ = readb(pins+i);\r\n}\r\nbd->pins_len = 0x40;\r\n}\r\n}\r\nstatic void get_bios_version(unsigned char __iomem * vbios, struct matrox_bios* bd) {\r\nunsigned int pcir_offset;\r\npcir_offset = readb(vbios + 24) | (readb(vbios + 25) << 8);\r\nif (pcir_offset >= 26 && pcir_offset < 0xFFE0 &&\r\nreadb(vbios + pcir_offset ) == 'P' &&\r\nreadb(vbios + pcir_offset + 1) == 'C' &&\r\nreadb(vbios + pcir_offset + 2) == 'I' &&\r\nreadb(vbios + pcir_offset + 3) == 'R') {\r\nunsigned char h;\r\nh = readb(vbios + pcir_offset + 0x12);\r\nbd->version.vMaj = (h >> 4) & 0xF;\r\nbd->version.vMin = h & 0xF;\r\nbd->version.vRev = readb(vbios + pcir_offset + 0x13);\r\n} else {\r\nunsigned char h;\r\nh = readb(vbios + 5);\r\nbd->version.vMaj = (h >> 4) & 0xF;\r\nbd->version.vMin = h & 0xF;\r\nbd->version.vRev = 0;\r\n}\r\n}\r\nstatic void get_bios_output(unsigned char __iomem* vbios, struct matrox_bios* bd) {\r\nunsigned char b;\r\nb = readb(vbios + 0x7FF1);\r\nif (b == 0xFF) {\r\nb = 0;\r\n}\r\nbd->output.state = b;\r\n}\r\nstatic void get_bios_tvout(unsigned char __iomem* vbios, struct matrox_bios* bd) {\r\nunsigned int i;\r\nbd->output.tvout = 0;\r\nif (readb(vbios + 0x1D) != 'I' ||\r\nreadb(vbios + 0x1E) != 'B' ||\r\nreadb(vbios + 0x1F) != 'M' ||\r\nreadb(vbios + 0x20) != ' ') {\r\nreturn;\r\n}\r\nfor (i = 0x2D; i < 0x2D + 128; i++) {\r\nunsigned char b = readb(vbios + i);\r\nif (b == '(' && readb(vbios + i + 1) == 'V') {\r\nif (readb(vbios + i + 6) == 'T' &&\r\nreadb(vbios + i + 7) == 'V' &&\r\nreadb(vbios + i + 8) == 'O') {\r\nbd->output.tvout = 1;\r\n}\r\nreturn;\r\n}\r\nif (b == 0)\r\nbreak;\r\n}\r\n}\r\nstatic void parse_bios(unsigned char __iomem* vbios, struct matrox_bios* bd) {\r\nunsigned int pins_offset;\r\nif (readb(vbios) != 0x55 || readb(vbios + 1) != 0xAA) {\r\nreturn;\r\n}\r\nbd->bios_valid = 1;\r\nget_bios_version(vbios, bd);\r\nget_bios_output(vbios, bd);\r\nget_bios_tvout(vbios, bd);\r\n#if defined(__powerpc__)\r\nfor ( pins_offset = 0 ; pins_offset <= 0xFF80 ; pins_offset++ ) {\r\nunsigned char header[3];\r\nheader[0] = readb(vbios + pins_offset);\r\nheader[1] = readb(vbios + pins_offset + 1);\r\nheader[2] = readb(vbios + pins_offset + 2);\r\nif ( (header[0] == 0x2E) && (header[1] == 0x41)\r\n&& ((header[2] == 0x40) || (header[2] == 0x80)) ) {\r\nprintk(KERN_INFO "PInS data found at offset %u\n",\r\npins_offset);\r\nget_pins(vbios + pins_offset, bd);\r\nbreak;\r\n}\r\n}\r\n#else\r\npins_offset = readb(vbios + 0x7FFC) | (readb(vbios + 0x7FFD) << 8);\r\nif (pins_offset <= 0xFF80) {\r\nget_pins(vbios + pins_offset, bd);\r\n}\r\n#endif\r\n}\r\nstatic int parse_pins1(struct matrox_fb_info *minfo,\r\nconst struct matrox_bios *bd)\r\n{\r\nunsigned int maxdac;\r\nswitch (bd->pins[22]) {\r\ncase 0: maxdac = 175000; break;\r\ncase 1: maxdac = 220000; break;\r\ndefault: maxdac = 240000; break;\r\n}\r\nif (get_unaligned_le16(bd->pins + 24)) {\r\nmaxdac = get_unaligned_le16(bd->pins + 24) * 10;\r\n}\r\nminfo->limits.pixel.vcomax = maxdac;\r\nminfo->values.pll.system = get_unaligned_le16(bd->pins + 28) ?\r\nget_unaligned_le16(bd->pins + 28) * 10 : 50000;\r\nminfo->features.pll.ref_freq = 14318;\r\nminfo->values.reg.mctlwtst = 0x00030101;\r\nreturn 0;\r\n}\r\nstatic void default_pins1(struct matrox_fb_info *minfo)\r\n{\r\nminfo->limits.pixel.vcomax = 220000;\r\nminfo->values.pll.system = 50000;\r\nminfo->features.pll.ref_freq = 14318;\r\nminfo->values.reg.mctlwtst = 0x00030101;\r\n}\r\nstatic int parse_pins2(struct matrox_fb_info *minfo,\r\nconst struct matrox_bios *bd)\r\n{\r\nminfo->limits.pixel.vcomax =\r\nminfo->limits.system.vcomax = (bd->pins[41] == 0xFF) ? 230000 : ((bd->pins[41] + 100) * 1000);\r\nminfo->values.reg.mctlwtst = ((bd->pins[51] & 0x01) ? 0x00000001 : 0) |\r\n((bd->pins[51] & 0x02) ? 0x00000100 : 0) |\r\n((bd->pins[51] & 0x04) ? 0x00010000 : 0) |\r\n((bd->pins[51] & 0x08) ? 0x00020000 : 0);\r\nminfo->values.pll.system = (bd->pins[43] == 0xFF) ? 50000 : ((bd->pins[43] + 100) * 1000);\r\nminfo->features.pll.ref_freq = 14318;\r\nreturn 0;\r\n}\r\nstatic void default_pins2(struct matrox_fb_info *minfo)\r\n{\r\nminfo->limits.pixel.vcomax =\r\nminfo->limits.system.vcomax = 230000;\r\nminfo->values.reg.mctlwtst = 0x00030101;\r\nminfo->values.pll.system = 50000;\r\nminfo->features.pll.ref_freq = 14318;\r\n}\r\nstatic int parse_pins3(struct matrox_fb_info *minfo,\r\nconst struct matrox_bios *bd)\r\n{\r\nminfo->limits.pixel.vcomax =\r\nminfo->limits.system.vcomax = (bd->pins[36] == 0xFF) ? 230000 : ((bd->pins[36] + 100) * 1000);\r\nminfo->values.reg.mctlwtst = get_unaligned_le32(bd->pins + 48) == 0xFFFFFFFF ?\r\n0x01250A21 : get_unaligned_le32(bd->pins + 48);\r\nminfo->values.reg.memrdbk = ((bd->pins[57] << 21) & 0x1E000000) |\r\n((bd->pins[57] << 22) & 0x00C00000) |\r\n((bd->pins[56] << 1) & 0x000001E0) |\r\n( bd->pins[56] & 0x0000000F);\r\nminfo->values.reg.opt = (bd->pins[54] & 7) << 10;\r\nminfo->values.reg.opt2 = bd->pins[58] << 12;\r\nminfo->features.pll.ref_freq = (bd->pins[52] & 0x20) ? 14318 : 27000;\r\nreturn 0;\r\n}\r\nstatic void default_pins3(struct matrox_fb_info *minfo)\r\n{\r\nminfo->limits.pixel.vcomax =\r\nminfo->limits.system.vcomax = 230000;\r\nminfo->values.reg.mctlwtst = 0x01250A21;\r\nminfo->values.reg.memrdbk = 0x00000000;\r\nminfo->values.reg.opt = 0x00000C00;\r\nminfo->values.reg.opt2 = 0x00000000;\r\nminfo->features.pll.ref_freq = 27000;\r\n}\r\nstatic int parse_pins4(struct matrox_fb_info *minfo,\r\nconst struct matrox_bios *bd)\r\n{\r\nminfo->limits.pixel.vcomax = (bd->pins[ 39] == 0xFF) ? 230000 : bd->pins[ 39] * 4000;\r\nminfo->limits.system.vcomax = (bd->pins[ 38] == 0xFF) ? minfo->limits.pixel.vcomax : bd->pins[ 38] * 4000;\r\nminfo->values.reg.mctlwtst = get_unaligned_le32(bd->pins + 71);\r\nminfo->values.reg.memrdbk = ((bd->pins[87] << 21) & 0x1E000000) |\r\n((bd->pins[87] << 22) & 0x00C00000) |\r\n((bd->pins[86] << 1) & 0x000001E0) |\r\n( bd->pins[86] & 0x0000000F);\r\nminfo->values.reg.opt = ((bd->pins[53] << 15) & 0x00400000) |\r\n((bd->pins[53] << 22) & 0x10000000) |\r\n((bd->pins[53] << 7) & 0x00001C00);\r\nminfo->values.reg.opt3 = get_unaligned_le32(bd->pins + 67);\r\nminfo->values.pll.system = (bd->pins[ 65] == 0xFF) ? 200000 : bd->pins[ 65] * 4000;\r\nminfo->features.pll.ref_freq = (bd->pins[ 92] & 0x01) ? 14318 : 27000;\r\nreturn 0;\r\n}\r\nstatic void default_pins4(struct matrox_fb_info *minfo)\r\n{\r\nminfo->limits.pixel.vcomax =\r\nminfo->limits.system.vcomax = 252000;\r\nminfo->values.reg.mctlwtst = 0x04A450A1;\r\nminfo->values.reg.memrdbk = 0x000000E7;\r\nminfo->values.reg.opt = 0x10000400;\r\nminfo->values.reg.opt3 = 0x0190A419;\r\nminfo->values.pll.system = 200000;\r\nminfo->features.pll.ref_freq = 27000;\r\n}\r\nstatic int parse_pins5(struct matrox_fb_info *minfo,\r\nconst struct matrox_bios *bd)\r\n{\r\nunsigned int mult;\r\nmult = bd->pins[4]?8000:6000;\r\nminfo->limits.pixel.vcomax = (bd->pins[ 38] == 0xFF) ? 600000 : bd->pins[ 38] * mult;\r\nminfo->limits.system.vcomax = (bd->pins[ 36] == 0xFF) ? minfo->limits.pixel.vcomax : bd->pins[ 36] * mult;\r\nminfo->limits.video.vcomax = (bd->pins[ 37] == 0xFF) ? minfo->limits.system.vcomax : bd->pins[ 37] * mult;\r\nminfo->limits.pixel.vcomin = (bd->pins[123] == 0xFF) ? 256000 : bd->pins[123] * mult;\r\nminfo->limits.system.vcomin = (bd->pins[121] == 0xFF) ? minfo->limits.pixel.vcomin : bd->pins[121] * mult;\r\nminfo->limits.video.vcomin = (bd->pins[122] == 0xFF) ? minfo->limits.system.vcomin : bd->pins[122] * mult;\r\nminfo->values.pll.system =\r\nminfo->values.pll.video = (bd->pins[ 92] == 0xFF) ? 284000 : bd->pins[ 92] * 4000;\r\nminfo->values.reg.opt = get_unaligned_le32(bd->pins + 48);\r\nminfo->values.reg.opt2 = get_unaligned_le32(bd->pins + 52);\r\nminfo->values.reg.opt3 = get_unaligned_le32(bd->pins + 94);\r\nminfo->values.reg.mctlwtst = get_unaligned_le32(bd->pins + 98);\r\nminfo->values.reg.memmisc = get_unaligned_le32(bd->pins + 102);\r\nminfo->values.reg.memrdbk = get_unaligned_le32(bd->pins + 106);\r\nminfo->features.pll.ref_freq = (bd->pins[110] & 0x01) ? 14318 : 27000;\r\nminfo->values.memory.ddr = (bd->pins[114] & 0x60) == 0x20;\r\nminfo->values.memory.dll = (bd->pins[115] & 0x02) != 0;\r\nminfo->values.memory.emrswen = (bd->pins[115] & 0x01) != 0;\r\nminfo->values.reg.maccess = minfo->values.memory.emrswen ? 0x00004000 : 0x00000000;\r\nif (bd->pins[115] & 4) {\r\nminfo->values.reg.mctlwtst_core = minfo->values.reg.mctlwtst;\r\n} else {\r\nu_int32_t wtst_xlat[] = { 0, 1, 5, 6, 7, 5, 2, 3 };\r\nminfo->values.reg.mctlwtst_core = (minfo->values.reg.mctlwtst & ~7) |\r\nwtst_xlat[minfo->values.reg.mctlwtst & 7];\r\n}\r\nminfo->max_pixel_clock_panellink = bd->pins[47] * 4000;\r\nreturn 0;\r\n}\r\nstatic void default_pins5(struct matrox_fb_info *minfo)\r\n{\r\nminfo->limits.pixel.vcomax =\r\nminfo->limits.system.vcomax =\r\nminfo->limits.video.vcomax = 600000;\r\nminfo->limits.pixel.vcomin =\r\nminfo->limits.system.vcomin =\r\nminfo->limits.video.vcomin = 256000;\r\nminfo->values.pll.system =\r\nminfo->values.pll.video = 284000;\r\nminfo->values.reg.opt = 0x404A1160;\r\nminfo->values.reg.opt2 = 0x0000AC00;\r\nminfo->values.reg.opt3 = 0x0090A409;\r\nminfo->values.reg.mctlwtst_core =\r\nminfo->values.reg.mctlwtst = 0x0C81462B;\r\nminfo->values.reg.memmisc = 0x80000004;\r\nminfo->values.reg.memrdbk = 0x01001103;\r\nminfo->features.pll.ref_freq = 27000;\r\nminfo->values.memory.ddr = 1;\r\nminfo->values.memory.dll = 1;\r\nminfo->values.memory.emrswen = 1;\r\nminfo->values.reg.maccess = 0x00004000;\r\n}\r\nstatic int matroxfb_set_limits(struct matrox_fb_info *minfo,\r\nconst struct matrox_bios *bd)\r\n{\r\nunsigned int pins_version;\r\nstatic const unsigned int pinslen[] = { 64, 64, 64, 128, 128 };\r\nswitch (minfo->chip) {\r\ncase MGA_2064: default_pins1(minfo); break;\r\ncase MGA_2164:\r\ncase MGA_1064:\r\ncase MGA_1164: default_pins2(minfo); break;\r\ncase MGA_G100:\r\ncase MGA_G200: default_pins3(minfo); break;\r\ncase MGA_G400: default_pins4(minfo); break;\r\ncase MGA_G450:\r\ncase MGA_G550: default_pins5(minfo); break;\r\n}\r\nif (!bd->bios_valid) {\r\nprintk(KERN_INFO "matroxfb: Your Matrox device does not have BIOS\n");\r\nreturn -1;\r\n}\r\nif (bd->pins_len < 64) {\r\nprintk(KERN_INFO "matroxfb: BIOS on your Matrox device does not contain powerup info\n");\r\nreturn -1;\r\n}\r\nif (bd->pins[0] == 0x2E && bd->pins[1] == 0x41) {\r\npins_version = bd->pins[5];\r\nif (pins_version < 2 || pins_version > 5) {\r\nprintk(KERN_INFO "matroxfb: Unknown version (%u) of powerup info\n", pins_version);\r\nreturn -1;\r\n}\r\n} else {\r\npins_version = 1;\r\n}\r\nif (bd->pins_len != pinslen[pins_version - 1]) {\r\nprintk(KERN_INFO "matroxfb: Invalid powerup info\n");\r\nreturn -1;\r\n}\r\nswitch (pins_version) {\r\ncase 1:\r\nreturn parse_pins1(minfo, bd);\r\ncase 2:\r\nreturn parse_pins2(minfo, bd);\r\ncase 3:\r\nreturn parse_pins3(minfo, bd);\r\ncase 4:\r\nreturn parse_pins4(minfo, bd);\r\ncase 5:\r\nreturn parse_pins5(minfo, bd);\r\ndefault:\r\nprintk(KERN_DEBUG "matroxfb: Powerup info version %u is not yet supported\n", pins_version);\r\nreturn -1;\r\n}\r\n}\r\nvoid matroxfb_read_pins(struct matrox_fb_info *minfo)\r\n{\r\nu32 opt;\r\nu32 biosbase;\r\nu32 fbbase;\r\nstruct pci_dev *pdev = minfo->pcidev;\r\nmemset(&minfo->bios, 0, sizeof(minfo->bios));\r\npci_read_config_dword(pdev, PCI_OPTION_REG, &opt);\r\npci_write_config_dword(pdev, PCI_OPTION_REG, opt | PCI_OPTION_ENABLE_ROM);\r\npci_read_config_dword(pdev, PCI_ROM_ADDRESS, &biosbase);\r\npci_read_config_dword(pdev, minfo->devflags.fbResource, &fbbase);\r\npci_write_config_dword(pdev, PCI_ROM_ADDRESS, (fbbase & PCI_ROM_ADDRESS_MASK) | PCI_ROM_ADDRESS_ENABLE);\r\nparse_bios(vaddr_va(minfo->video.vbase), &minfo->bios);\r\npci_write_config_dword(pdev, PCI_ROM_ADDRESS, biosbase);\r\npci_write_config_dword(pdev, PCI_OPTION_REG, opt);\r\n#ifdef CONFIG_X86\r\nif (!minfo->bios.bios_valid) {\r\nunsigned char __iomem* b;\r\nb = ioremap(0x000C0000, 65536);\r\nif (!b) {\r\nprintk(KERN_INFO "matroxfb: Unable to map legacy BIOS\n");\r\n} else {\r\nunsigned int ven = readb(b+0x64+0) | (readb(b+0x64+1) << 8);\r\nunsigned int dev = readb(b+0x64+2) | (readb(b+0x64+3) << 8);\r\nif (ven != pdev->vendor || dev != pdev->device) {\r\nprintk(KERN_INFO "matroxfb: Legacy BIOS is for %04X:%04X, while this device is %04X:%04X\n",\r\nven, dev, pdev->vendor, pdev->device);\r\n} else {\r\nparse_bios(b, &minfo->bios);\r\n}\r\niounmap(b);\r\n}\r\n}\r\n#endif\r\nmatroxfb_set_limits(minfo, &minfo->bios);\r\nprintk(KERN_INFO "PInS memtype = %u\n",\r\n(minfo->values.reg.opt & 0x1C00) >> 10);\r\n}
