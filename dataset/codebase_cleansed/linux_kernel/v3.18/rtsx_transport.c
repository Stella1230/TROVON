unsigned int rtsx_stor_access_xfer_buf(unsigned char *buffer,\r\nunsigned int buflen, struct scsi_cmnd *srb, unsigned int *index,\r\nunsigned int *offset, enum xfer_buf_dir dir)\r\n{\r\nunsigned int cnt;\r\nif (scsi_sg_count(srb) == 0) {\r\nif (*offset >= scsi_bufflen(srb))\r\nreturn 0;\r\ncnt = min(buflen, scsi_bufflen(srb) - *offset);\r\nif (dir == TO_XFER_BUF)\r\nmemcpy((unsigned char *) scsi_sglist(srb) + *offset,\r\nbuffer, cnt);\r\nelse\r\nmemcpy(buffer, (unsigned char *) scsi_sglist(srb) +\r\n*offset, cnt);\r\n*offset += cnt;\r\n} else {\r\nstruct scatterlist *sg =\r\n(struct scatterlist *) scsi_sglist(srb)\r\n+ *index;\r\ncnt = 0;\r\nwhile (cnt < buflen && *index < scsi_sg_count(srb)) {\r\nstruct page *page = sg_page(sg) +\r\n((sg->offset + *offset) >> PAGE_SHIFT);\r\nunsigned int poff =\r\n(sg->offset + *offset) & (PAGE_SIZE-1);\r\nunsigned int sglen = sg->length - *offset;\r\nif (sglen > buflen - cnt) {\r\nsglen = buflen - cnt;\r\n*offset += sglen;\r\n} else {\r\n*offset = 0;\r\n++*index;\r\n++sg;\r\n}\r\nwhile (sglen > 0) {\r\nunsigned int plen = min(sglen, (unsigned int)\r\nPAGE_SIZE - poff);\r\nunsigned char *ptr = kmap(page);\r\nif (dir == TO_XFER_BUF)\r\nmemcpy(ptr + poff, buffer + cnt, plen);\r\nelse\r\nmemcpy(buffer + cnt, ptr + poff, plen);\r\nkunmap(page);\r\npoff = 0;\r\n++page;\r\ncnt += plen;\r\nsglen -= plen;\r\n}\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nvoid rtsx_stor_set_xfer_buf(unsigned char *buffer,\r\nunsigned int buflen, struct scsi_cmnd *srb)\r\n{\r\nunsigned int index = 0, offset = 0;\r\nrtsx_stor_access_xfer_buf(buffer, buflen, srb, &index, &offset,\r\nTO_XFER_BUF);\r\nif (buflen < scsi_bufflen(srb))\r\nscsi_set_resid(srb, scsi_bufflen(srb) - buflen);\r\n}\r\nvoid rtsx_stor_get_xfer_buf(unsigned char *buffer,\r\nunsigned int buflen, struct scsi_cmnd *srb)\r\n{\r\nunsigned int index = 0, offset = 0;\r\nrtsx_stor_access_xfer_buf(buffer, buflen, srb, &index, &offset,\r\nFROM_XFER_BUF);\r\nif (buflen < scsi_bufflen(srb))\r\nscsi_set_resid(srb, scsi_bufflen(srb) - buflen);\r\n}\r\nvoid rtsx_invoke_transport(struct scsi_cmnd *srb, struct rtsx_chip *chip)\r\n{\r\nint result;\r\nresult = rtsx_scsi_handler(srb, chip);\r\nif (rtsx_chk_stat(chip, RTSX_STAT_ABORT)) {\r\ndev_dbg(rtsx_dev(chip), "-- command was aborted\n");\r\nsrb->result = DID_ABORT << 16;\r\ngoto Handle_Errors;\r\n}\r\nif (result == TRANSPORT_ERROR) {\r\ndev_dbg(rtsx_dev(chip), "-- transport indicates error, resetting\n");\r\nsrb->result = DID_ERROR << 16;\r\ngoto Handle_Errors;\r\n}\r\nsrb->result = SAM_STAT_GOOD;\r\nif (result == TRANSPORT_FAILED) {\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\nmemcpy(srb->sense_buffer,\r\n(unsigned char *)&(chip->sense_buffer[SCSI_LUN(srb)]),\r\nsizeof(struct sense_data_t));\r\n}\r\nreturn;\r\nHandle_Errors:\r\nreturn;\r\n}\r\nvoid rtsx_add_cmd(struct rtsx_chip *chip,\r\nu8 cmd_type, u16 reg_addr, u8 mask, u8 data)\r\n{\r\nu32 *cb = (u32 *)(chip->host_cmds_ptr);\r\nu32 val = 0;\r\nval |= (u32)(cmd_type & 0x03) << 30;\r\nval |= (u32)(reg_addr & 0x3FFF) << 16;\r\nval |= (u32)mask << 8;\r\nval |= (u32)data;\r\nspin_lock_irq(&chip->rtsx->reg_lock);\r\nif (chip->ci < (HOST_CMDS_BUF_LEN / 4))\r\ncb[(chip->ci)++] = cpu_to_le32(val);\r\nspin_unlock_irq(&chip->rtsx->reg_lock);\r\n}\r\nvoid rtsx_send_cmd_no_wait(struct rtsx_chip *chip)\r\n{\r\nu32 val = 1 << 31;\r\nrtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);\r\nval |= (u32)(chip->ci * 4) & 0x00FFFFFF;\r\nval |= 0x40000000;\r\nrtsx_writel(chip, RTSX_HCBCTLR, val);\r\n}\r\nint rtsx_send_cmd(struct rtsx_chip *chip, u8 card, int timeout)\r\n{\r\nstruct rtsx_dev *rtsx = chip->rtsx;\r\nstruct completion trans_done;\r\nu32 val = 1 << 31;\r\nlong timeleft;\r\nint err = 0;\r\nif (card == SD_CARD)\r\nrtsx->check_card_cd = SD_EXIST;\r\nelse if (card == MS_CARD)\r\nrtsx->check_card_cd = MS_EXIST;\r\nelse if (card == XD_CARD)\r\nrtsx->check_card_cd = XD_EXIST;\r\nelse\r\nrtsx->check_card_cd = 0;\r\nspin_lock_irq(&rtsx->reg_lock);\r\nrtsx->done = &trans_done;\r\nrtsx->trans_result = TRANS_NOT_READY;\r\ninit_completion(&trans_done);\r\nrtsx->trans_state = STATE_TRANS_CMD;\r\nrtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);\r\nval |= (u32)(chip->ci * 4) & 0x00FFFFFF;\r\nval |= 0x40000000;\r\nrtsx_writel(chip, RTSX_HCBCTLR, val);\r\nspin_unlock_irq(&rtsx->reg_lock);\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&trans_done, timeout * HZ / 1000);\r\nif (timeleft <= 0) {\r\ndev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",\r\nchip->int_reg);\r\nerr = -ETIMEDOUT;\r\nTRACE_GOTO(chip, finish_send_cmd);\r\n}\r\nspin_lock_irq(&rtsx->reg_lock);\r\nif (rtsx->trans_result == TRANS_RESULT_FAIL)\r\nerr = -EIO;\r\nelse if (rtsx->trans_result == TRANS_RESULT_OK)\r\nerr = 0;\r\nspin_unlock_irq(&rtsx->reg_lock);\r\nfinish_send_cmd:\r\nrtsx->done = NULL;\r\nrtsx->trans_state = STATE_TRANS_NONE;\r\nif (err < 0)\r\nrtsx_stop_cmd(chip, card);\r\nreturn err;\r\n}\r\nstatic inline void rtsx_add_sg_tbl(\r\nstruct rtsx_chip *chip, u32 addr, u32 len, u8 option)\r\n{\r\nu64 *sgb = (u64 *)(chip->host_sg_tbl_ptr);\r\nu64 val = 0;\r\nu32 temp_len = 0;\r\nu8 temp_opt = 0;\r\ndo {\r\nif (len > 0x80000) {\r\ntemp_len = 0x80000;\r\ntemp_opt = option & (~SG_END);\r\n} else {\r\ntemp_len = len;\r\ntemp_opt = option;\r\n}\r\nval = ((u64)addr << 32) | ((u64)temp_len << 12) | temp_opt;\r\nif (chip->sgi < (HOST_SG_TBL_BUF_LEN / 8))\r\nsgb[(chip->sgi)++] = cpu_to_le64(val);\r\nlen -= temp_len;\r\naddr += temp_len;\r\n} while (len);\r\n}\r\nstatic int rtsx_transfer_sglist_adma_partial(struct rtsx_chip *chip, u8 card,\r\nstruct scatterlist *sg, int num_sg, unsigned int *index,\r\nunsigned int *offset, int size,\r\nenum dma_data_direction dma_dir, int timeout)\r\n{\r\nstruct rtsx_dev *rtsx = chip->rtsx;\r\nstruct completion trans_done;\r\nu8 dir;\r\nint sg_cnt, i, resid;\r\nint err = 0;\r\nlong timeleft;\r\nstruct scatterlist *sg_ptr;\r\nu32 val = TRIG_DMA;\r\nif ((sg == NULL) || (num_sg <= 0) || !offset || !index)\r\nreturn -EIO;\r\nif (dma_dir == DMA_TO_DEVICE)\r\ndir = HOST_TO_DEVICE;\r\nelse if (dma_dir == DMA_FROM_DEVICE)\r\ndir = DEVICE_TO_HOST;\r\nelse\r\nreturn -ENXIO;\r\nif (card == SD_CARD)\r\nrtsx->check_card_cd = SD_EXIST;\r\nelse if (card == MS_CARD)\r\nrtsx->check_card_cd = MS_EXIST;\r\nelse if (card == XD_CARD)\r\nrtsx->check_card_cd = XD_EXIST;\r\nelse\r\nrtsx->check_card_cd = 0;\r\nspin_lock_irq(&rtsx->reg_lock);\r\nrtsx->done = &trans_done;\r\nrtsx->trans_state = STATE_TRANS_SG;\r\nrtsx->trans_result = TRANS_NOT_READY;\r\nspin_unlock_irq(&rtsx->reg_lock);\r\nsg_cnt = dma_map_sg(&(rtsx->pci->dev), sg, num_sg, dma_dir);\r\nresid = size;\r\nsg_ptr = sg;\r\nchip->sgi = 0;\r\nfor (i = 0; i < *index; i++)\r\nsg_ptr = sg_next(sg_ptr);\r\nfor (i = *index; i < sg_cnt; i++) {\r\ndma_addr_t addr;\r\nunsigned int len;\r\nu8 option;\r\naddr = sg_dma_address(sg_ptr);\r\nlen = sg_dma_len(sg_ptr);\r\ndev_dbg(rtsx_dev(chip), "DMA addr: 0x%x, Len: 0x%x\n",\r\n(unsigned int)addr, len);\r\ndev_dbg(rtsx_dev(chip), "*index = %d, *offset = %d\n",\r\n*index, *offset);\r\naddr += *offset;\r\nif ((len - *offset) > resid) {\r\n*offset += resid;\r\nlen = resid;\r\nresid = 0;\r\n} else {\r\nresid -= (len - *offset);\r\nlen -= *offset;\r\n*offset = 0;\r\n*index = *index + 1;\r\n}\r\nif ((i == (sg_cnt - 1)) || !resid)\r\noption = SG_VALID | SG_END | SG_TRANS_DATA;\r\nelse\r\noption = SG_VALID | SG_TRANS_DATA;\r\nrtsx_add_sg_tbl(chip, (u32)addr, (u32)len, option);\r\nif (!resid)\r\nbreak;\r\nsg_ptr = sg_next(sg_ptr);\r\n}\r\ndev_dbg(rtsx_dev(chip), "SG table count = %d\n", chip->sgi);\r\nval |= (u32)(dir & 0x01) << 29;\r\nval |= ADMA_MODE;\r\nspin_lock_irq(&rtsx->reg_lock);\r\ninit_completion(&trans_done);\r\nrtsx_writel(chip, RTSX_HDBAR, chip->host_sg_tbl_addr);\r\nrtsx_writel(chip, RTSX_HDBCTLR, val);\r\nspin_unlock_irq(&rtsx->reg_lock);\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&trans_done, timeout * HZ / 1000);\r\nif (timeleft <= 0) {\r\ndev_dbg(rtsx_dev(chip), "Timeout (%s %d)\n",\r\n__func__, __LINE__);\r\ndev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",\r\nchip->int_reg);\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nspin_lock_irq(&rtsx->reg_lock);\r\nif (rtsx->trans_result == TRANS_RESULT_FAIL) {\r\nerr = -EIO;\r\nspin_unlock_irq(&rtsx->reg_lock);\r\ngoto out;\r\n}\r\nspin_unlock_irq(&rtsx->reg_lock);\r\nspin_lock_irq(&rtsx->reg_lock);\r\nif (rtsx->trans_result == TRANS_NOT_READY) {\r\ninit_completion(&trans_done);\r\nspin_unlock_irq(&rtsx->reg_lock);\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&trans_done, timeout * HZ / 1000);\r\nif (timeleft <= 0) {\r\ndev_dbg(rtsx_dev(chip), "Timeout (%s %d)\n",\r\n__func__, __LINE__);\r\ndev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",\r\nchip->int_reg);\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\n} else {\r\nspin_unlock_irq(&rtsx->reg_lock);\r\n}\r\nspin_lock_irq(&rtsx->reg_lock);\r\nif (rtsx->trans_result == TRANS_RESULT_FAIL)\r\nerr = -EIO;\r\nelse if (rtsx->trans_result == TRANS_RESULT_OK)\r\nerr = 0;\r\nspin_unlock_irq(&rtsx->reg_lock);\r\nout:\r\nrtsx->done = NULL;\r\nrtsx->trans_state = STATE_TRANS_NONE;\r\ndma_unmap_sg(&(rtsx->pci->dev), sg, num_sg, dma_dir);\r\nif (err < 0)\r\nrtsx_stop_cmd(chip, card);\r\nreturn err;\r\n}\r\nstatic int rtsx_transfer_sglist_adma(struct rtsx_chip *chip, u8 card,\r\nstruct scatterlist *sg, int num_sg,\r\nenum dma_data_direction dma_dir, int timeout)\r\n{\r\nstruct rtsx_dev *rtsx = chip->rtsx;\r\nstruct completion trans_done;\r\nu8 dir;\r\nint buf_cnt, i;\r\nint err = 0;\r\nlong timeleft;\r\nstruct scatterlist *sg_ptr;\r\nif ((sg == NULL) || (num_sg <= 0))\r\nreturn -EIO;\r\nif (dma_dir == DMA_TO_DEVICE)\r\ndir = HOST_TO_DEVICE;\r\nelse if (dma_dir == DMA_FROM_DEVICE)\r\ndir = DEVICE_TO_HOST;\r\nelse\r\nreturn -ENXIO;\r\nif (card == SD_CARD)\r\nrtsx->check_card_cd = SD_EXIST;\r\nelse if (card == MS_CARD)\r\nrtsx->check_card_cd = MS_EXIST;\r\nelse if (card == XD_CARD)\r\nrtsx->check_card_cd = XD_EXIST;\r\nelse\r\nrtsx->check_card_cd = 0;\r\nspin_lock_irq(&rtsx->reg_lock);\r\nrtsx->done = &trans_done;\r\nrtsx->trans_state = STATE_TRANS_SG;\r\nrtsx->trans_result = TRANS_NOT_READY;\r\nspin_unlock_irq(&rtsx->reg_lock);\r\nbuf_cnt = dma_map_sg(&(rtsx->pci->dev), sg, num_sg, dma_dir);\r\nsg_ptr = sg;\r\nfor (i = 0; i <= buf_cnt / (HOST_SG_TBL_BUF_LEN / 8); i++) {\r\nu32 val = TRIG_DMA;\r\nint sg_cnt, j;\r\nif (i == buf_cnt / (HOST_SG_TBL_BUF_LEN / 8))\r\nsg_cnt = buf_cnt % (HOST_SG_TBL_BUF_LEN / 8);\r\nelse\r\nsg_cnt = (HOST_SG_TBL_BUF_LEN / 8);\r\nchip->sgi = 0;\r\nfor (j = 0; j < sg_cnt; j++) {\r\ndma_addr_t addr = sg_dma_address(sg_ptr);\r\nunsigned int len = sg_dma_len(sg_ptr);\r\nu8 option;\r\ndev_dbg(rtsx_dev(chip), "DMA addr: 0x%x, Len: 0x%x\n",\r\n(unsigned int)addr, len);\r\nif (j == (sg_cnt - 1))\r\noption = SG_VALID | SG_END | SG_TRANS_DATA;\r\nelse\r\noption = SG_VALID | SG_TRANS_DATA;\r\nrtsx_add_sg_tbl(chip, (u32)addr, (u32)len, option);\r\nsg_ptr = sg_next(sg_ptr);\r\n}\r\ndev_dbg(rtsx_dev(chip), "SG table count = %d\n", chip->sgi);\r\nval |= (u32)(dir & 0x01) << 29;\r\nval |= ADMA_MODE;\r\nspin_lock_irq(&rtsx->reg_lock);\r\ninit_completion(&trans_done);\r\nrtsx_writel(chip, RTSX_HDBAR, chip->host_sg_tbl_addr);\r\nrtsx_writel(chip, RTSX_HDBCTLR, val);\r\nspin_unlock_irq(&rtsx->reg_lock);\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&trans_done, timeout * HZ / 1000);\r\nif (timeleft <= 0) {\r\ndev_dbg(rtsx_dev(chip), "Timeout (%s %d)\n",\r\n__func__, __LINE__);\r\ndev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",\r\nchip->int_reg);\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nspin_lock_irq(&rtsx->reg_lock);\r\nif (rtsx->trans_result == TRANS_RESULT_FAIL) {\r\nerr = -EIO;\r\nspin_unlock_irq(&rtsx->reg_lock);\r\ngoto out;\r\n}\r\nspin_unlock_irq(&rtsx->reg_lock);\r\nsg_ptr += sg_cnt;\r\n}\r\nspin_lock_irq(&rtsx->reg_lock);\r\nif (rtsx->trans_result == TRANS_NOT_READY) {\r\ninit_completion(&trans_done);\r\nspin_unlock_irq(&rtsx->reg_lock);\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&trans_done, timeout * HZ / 1000);\r\nif (timeleft <= 0) {\r\ndev_dbg(rtsx_dev(chip), "Timeout (%s %d)\n",\r\n__func__, __LINE__);\r\ndev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",\r\nchip->int_reg);\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\n} else {\r\nspin_unlock_irq(&rtsx->reg_lock);\r\n}\r\nspin_lock_irq(&rtsx->reg_lock);\r\nif (rtsx->trans_result == TRANS_RESULT_FAIL)\r\nerr = -EIO;\r\nelse if (rtsx->trans_result == TRANS_RESULT_OK)\r\nerr = 0;\r\nspin_unlock_irq(&rtsx->reg_lock);\r\nout:\r\nrtsx->done = NULL;\r\nrtsx->trans_state = STATE_TRANS_NONE;\r\ndma_unmap_sg(&(rtsx->pci->dev), sg, num_sg, dma_dir);\r\nif (err < 0)\r\nrtsx_stop_cmd(chip, card);\r\nreturn err;\r\n}\r\nstatic int rtsx_transfer_buf(struct rtsx_chip *chip, u8 card, void *buf,\r\nsize_t len, enum dma_data_direction dma_dir, int timeout)\r\n{\r\nstruct rtsx_dev *rtsx = chip->rtsx;\r\nstruct completion trans_done;\r\ndma_addr_t addr;\r\nu8 dir;\r\nint err = 0;\r\nu32 val = (1 << 31);\r\nlong timeleft;\r\nif ((buf == NULL) || (len <= 0))\r\nreturn -EIO;\r\nif (dma_dir == DMA_TO_DEVICE)\r\ndir = HOST_TO_DEVICE;\r\nelse if (dma_dir == DMA_FROM_DEVICE)\r\ndir = DEVICE_TO_HOST;\r\nelse\r\nreturn -ENXIO;\r\naddr = dma_map_single(&(rtsx->pci->dev), buf, len, dma_dir);\r\nif (!addr)\r\nreturn -ENOMEM;\r\nif (card == SD_CARD)\r\nrtsx->check_card_cd = SD_EXIST;\r\nelse if (card == MS_CARD)\r\nrtsx->check_card_cd = MS_EXIST;\r\nelse if (card == XD_CARD)\r\nrtsx->check_card_cd = XD_EXIST;\r\nelse\r\nrtsx->check_card_cd = 0;\r\nval |= (u32)(dir & 0x01) << 29;\r\nval |= (u32)(len & 0x00FFFFFF);\r\nspin_lock_irq(&rtsx->reg_lock);\r\nrtsx->done = &trans_done;\r\ninit_completion(&trans_done);\r\nrtsx->trans_state = STATE_TRANS_BUF;\r\nrtsx->trans_result = TRANS_NOT_READY;\r\nrtsx_writel(chip, RTSX_HDBAR, addr);\r\nrtsx_writel(chip, RTSX_HDBCTLR, val);\r\nspin_unlock_irq(&rtsx->reg_lock);\r\ntimeleft = wait_for_completion_interruptible_timeout(\r\n&trans_done, timeout * HZ / 1000);\r\nif (timeleft <= 0) {\r\ndev_dbg(rtsx_dev(chip), "Timeout (%s %d)\n",\r\n__func__, __LINE__);\r\ndev_dbg(rtsx_dev(chip), "chip->int_reg = 0x%x\n",\r\nchip->int_reg);\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nspin_lock_irq(&rtsx->reg_lock);\r\nif (rtsx->trans_result == TRANS_RESULT_FAIL)\r\nerr = -EIO;\r\nelse if (rtsx->trans_result == TRANS_RESULT_OK)\r\nerr = 0;\r\nspin_unlock_irq(&rtsx->reg_lock);\r\nout:\r\nrtsx->done = NULL;\r\nrtsx->trans_state = STATE_TRANS_NONE;\r\ndma_unmap_single(&(rtsx->pci->dev), addr, len, dma_dir);\r\nif (err < 0)\r\nrtsx_stop_cmd(chip, card);\r\nreturn err;\r\n}\r\nint rtsx_transfer_data_partial(struct rtsx_chip *chip, u8 card,\r\nvoid *buf, size_t len, int use_sg, unsigned int *index,\r\nunsigned int *offset, enum dma_data_direction dma_dir,\r\nint timeout)\r\n{\r\nint err = 0;\r\nif (rtsx_chk_stat(chip, RTSX_STAT_ABORT))\r\nreturn -EIO;\r\nif (use_sg) {\r\nerr = rtsx_transfer_sglist_adma_partial(chip, card,\r\n(struct scatterlist *)buf, use_sg,\r\nindex, offset, (int)len, dma_dir, timeout);\r\n} else {\r\nerr = rtsx_transfer_buf(chip, card,\r\nbuf, len, dma_dir, timeout);\r\n}\r\nif (err < 0) {\r\nif (RTSX_TST_DELINK(chip)) {\r\nRTSX_CLR_DELINK(chip);\r\nchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\r\nrtsx_reinit_cards(chip, 1);\r\n}\r\n}\r\nreturn err;\r\n}\r\nint rtsx_transfer_data(struct rtsx_chip *chip, u8 card, void *buf, size_t len,\r\nint use_sg, enum dma_data_direction dma_dir, int timeout)\r\n{\r\nint err = 0;\r\ndev_dbg(rtsx_dev(chip), "use_sg = %d\n", use_sg);\r\nif (rtsx_chk_stat(chip, RTSX_STAT_ABORT))\r\nreturn -EIO;\r\nif (use_sg) {\r\nerr = rtsx_transfer_sglist_adma(chip, card,\r\n(struct scatterlist *)buf,\r\nuse_sg, dma_dir, timeout);\r\n} else {\r\nerr = rtsx_transfer_buf(chip, card, buf, len, dma_dir, timeout);\r\n}\r\nif (err < 0) {\r\nif (RTSX_TST_DELINK(chip)) {\r\nRTSX_CLR_DELINK(chip);\r\nchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\r\nrtsx_reinit_cards(chip, 1);\r\n}\r\n}\r\nreturn err;\r\n}
