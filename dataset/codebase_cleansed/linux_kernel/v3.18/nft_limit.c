static void nft_limit_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_limit *priv = nft_expr_priv(expr);\r\nspin_lock_bh(&limit_lock);\r\nif (time_after_eq(jiffies, priv->stamp)) {\r\npriv->tokens = priv->rate;\r\npriv->stamp = jiffies + priv->unit * HZ;\r\n}\r\nif (priv->tokens >= 1) {\r\npriv->tokens--;\r\nspin_unlock_bh(&limit_lock);\r\nreturn;\r\n}\r\nspin_unlock_bh(&limit_lock);\r\ndata[NFT_REG_VERDICT].verdict = NFT_BREAK;\r\n}\r\nstatic int nft_limit_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_limit *priv = nft_expr_priv(expr);\r\nif (tb[NFTA_LIMIT_RATE] == NULL ||\r\ntb[NFTA_LIMIT_UNIT] == NULL)\r\nreturn -EINVAL;\r\npriv->rate = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_RATE]));\r\npriv->unit = be64_to_cpu(nla_get_be64(tb[NFTA_LIMIT_UNIT]));\r\npriv->stamp = jiffies + priv->unit * HZ;\r\npriv->tokens = priv->rate;\r\nreturn 0;\r\n}\r\nstatic int nft_limit_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_limit *priv = nft_expr_priv(expr);\r\nif (nla_put_be64(skb, NFTA_LIMIT_RATE, cpu_to_be64(priv->rate)))\r\ngoto nla_put_failure;\r\nif (nla_put_be64(skb, NFTA_LIMIT_UNIT, cpu_to_be64(priv->unit)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int __init nft_limit_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_limit_type);\r\n}\r\nstatic void __exit nft_limit_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_limit_type);\r\n}
