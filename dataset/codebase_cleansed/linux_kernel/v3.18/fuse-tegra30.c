u32 tegra30_fuse_readl(const unsigned int offset)\r\n{\r\nu32 val;\r\nif (fuse_clk)\r\nclk_prepare_enable(fuse_clk);\r\nval = readl_relaxed(fuse_base + FUSE_BEGIN + offset);\r\nif (fuse_clk)\r\nclk_disable_unprepare(fuse_clk);\r\nreturn val;\r\n}\r\nstatic int tegra30_fuse_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_dev_id;\r\nof_dev_id = of_match_device(tegra30_fuse_of_match, &pdev->dev);\r\nif (!of_dev_id)\r\nreturn -ENODEV;\r\nfuse_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(fuse_clk)) {\r\ndev_err(&pdev->dev, "missing clock");\r\nreturn PTR_ERR(fuse_clk);\r\n}\r\nplatform_set_drvdata(pdev, NULL);\r\nif (tegra_fuse_create_sysfs(&pdev->dev, fuse_info->size,\r\ntegra30_fuse_readl))\r\nreturn -ENODEV;\r\ndev_dbg(&pdev->dev, "loaded\n");\r\nreturn 0;\r\n}\r\nstatic int __init tegra30_fuse_init(void)\r\n{\r\nreturn platform_driver_register(&tegra30_fuse_driver);\r\n}\r\nstatic void __init tegra30_fuse_add_randomness(void)\r\n{\r\nu32 randomness[12];\r\nrandomness[0] = tegra_sku_info.sku_id;\r\nrandomness[1] = tegra_read_straps();\r\nrandomness[2] = tegra_read_chipid();\r\nrandomness[3] = tegra_sku_info.cpu_process_id << 16;\r\nrandomness[3] |= tegra_sku_info.core_process_id;\r\nrandomness[4] = tegra_sku_info.cpu_speedo_id << 16;\r\nrandomness[4] |= tegra_sku_info.soc_speedo_id;\r\nrandomness[5] = tegra30_fuse_readl(FUSE_VENDOR_CODE);\r\nrandomness[6] = tegra30_fuse_readl(FUSE_FAB_CODE);\r\nrandomness[7] = tegra30_fuse_readl(FUSE_LOT_CODE_0);\r\nrandomness[8] = tegra30_fuse_readl(FUSE_LOT_CODE_1);\r\nrandomness[9] = tegra30_fuse_readl(FUSE_WAFER_ID);\r\nrandomness[10] = tegra30_fuse_readl(FUSE_X_COORDINATE);\r\nrandomness[11] = tegra30_fuse_readl(FUSE_Y_COORDINATE);\r\nadd_device_randomness(randomness, sizeof(randomness));\r\n}\r\nstatic void __init legacy_fuse_init(void)\r\n{\r\nswitch (tegra_get_chip_id()) {\r\ncase TEGRA30:\r\nfuse_info = &tegra30_info;\r\nbreak;\r\ncase TEGRA114:\r\nfuse_info = &tegra114_info;\r\nbreak;\r\ncase TEGRA124:\r\nfuse_info = &tegra124_info;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nfuse_base = ioremap(TEGRA_FUSE_BASE, TEGRA_FUSE_SIZE);\r\n}\r\nbool __init tegra30_spare_fuse(int spare_bit)\r\n{\r\nu32 offset = fuse_info->spare_bit + spare_bit * 4;\r\nreturn tegra30_fuse_readl(offset) & 1;\r\n}\r\nvoid __init tegra30_init_fuse_early(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id *of_match;\r\nnp = of_find_matching_node_and_match(NULL, tegra30_fuse_of_match,\r\n&of_match);\r\nif (np) {\r\nfuse_base = of_iomap(np, 0);\r\nfuse_info = (struct tegra_fuse_info *)of_match->data;\r\n} else\r\nlegacy_fuse_init();\r\nif (!fuse_base) {\r\npr_warn("fuse DT node missing and unknown chip id: 0x%02x\n",\r\ntegra_get_chip_id());\r\nreturn;\r\n}\r\ntegra_init_revision();\r\nspeedo_tbl[fuse_info->speedo_idx](&tegra_sku_info);\r\ntegra30_fuse_add_randomness();\r\n}
