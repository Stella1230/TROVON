static int of_gpiochip_find_and_xlate(struct gpio_chip *gc, void *data)\r\n{\r\nstruct gg_data *gg_data = data;\r\nint ret;\r\nif ((gc->of_node != gg_data->gpiospec.np) ||\r\n(gc->of_gpio_n_cells != gg_data->gpiospec.args_count) ||\r\n(!gc->of_xlate))\r\nreturn false;\r\nret = gc->of_xlate(gc, &gg_data->gpiospec, gg_data->flags);\r\nif (ret < 0)\r\nreturn false;\r\ngg_data->out_gpio = gpiochip_get_desc(gc, ret);\r\nreturn true;\r\n}\r\nstruct gpio_desc *of_get_named_gpiod_flags(struct device_node *np,\r\nconst char *propname, int index, enum of_gpio_flags *flags)\r\n{\r\nstruct gg_data gg_data = {\r\n.flags = flags,\r\n.out_gpio = ERR_PTR(-EPROBE_DEFER)\r\n};\r\nint ret;\r\nif (flags)\r\n*flags = 0;\r\nret = of_parse_phandle_with_args(np, propname, "#gpio-cells", index,\r\n&gg_data.gpiospec);\r\nif (ret) {\r\npr_debug("%s: can't parse '%s' property of node '%s[%d]'\n",\r\n__func__, propname, np->full_name, index);\r\nreturn ERR_PTR(ret);\r\n}\r\ngpiochip_find(&gg_data, of_gpiochip_find_and_xlate);\r\nof_node_put(gg_data.gpiospec.np);\r\npr_debug("%s: parsed '%s' property of node '%s[%d]' - status (%d)\n",\r\n__func__, propname, np->full_name, index,\r\nPTR_ERR_OR_ZERO(gg_data.out_gpio));\r\nreturn gg_data.out_gpio;\r\n}\r\nint of_get_named_gpio_flags(struct device_node *np, const char *list_name,\r\nint index, enum of_gpio_flags *flags)\r\n{\r\nstruct gpio_desc *desc;\r\ndesc = of_get_named_gpiod_flags(np, list_name, index, flags);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nelse\r\nreturn desc_to_gpio(desc);\r\n}\r\nint of_gpio_simple_xlate(struct gpio_chip *gc,\r\nconst struct of_phandle_args *gpiospec, u32 *flags)\r\n{\r\nif (gc->of_gpio_n_cells < 2) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(gpiospec->args_count < gc->of_gpio_n_cells))\r\nreturn -EINVAL;\r\nif (gpiospec->args[0] >= gc->ngpio)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpiospec->args[1];\r\nreturn gpiospec->args[0];\r\n}\r\nint of_mm_gpiochip_add(struct device_node *np,\r\nstruct of_mm_gpio_chip *mm_gc)\r\n{\r\nint ret = -ENOMEM;\r\nstruct gpio_chip *gc = &mm_gc->gc;\r\ngc->label = kstrdup(np->full_name, GFP_KERNEL);\r\nif (!gc->label)\r\ngoto err0;\r\nmm_gc->regs = of_iomap(np, 0);\r\nif (!mm_gc->regs)\r\ngoto err1;\r\ngc->base = -1;\r\nif (mm_gc->save_regs)\r\nmm_gc->save_regs(mm_gc);\r\nmm_gc->gc.of_node = np;\r\nret = gpiochip_add(gc);\r\nif (ret)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\niounmap(mm_gc->regs);\r\nerr1:\r\nkfree(gc->label);\r\nerr0:\r\npr_err("%s: GPIO chip registration failed with status %d\n",\r\nnp->full_name, ret);\r\nreturn ret;\r\n}\r\nstatic void of_gpiochip_add_pin_range(struct gpio_chip *chip)\r\n{\r\nstruct device_node *np = chip->of_node;\r\nstruct of_phandle_args pinspec;\r\nstruct pinctrl_dev *pctldev;\r\nint index = 0, ret;\r\nconst char *name;\r\nstatic const char group_names_propname[] = "gpio-ranges-group-names";\r\nstruct property *group_names;\r\nif (!np)\r\nreturn;\r\ngroup_names = of_find_property(np, group_names_propname, NULL);\r\nfor (;; index++) {\r\nret = of_parse_phandle_with_fixed_args(np, "gpio-ranges", 3,\r\nindex, &pinspec);\r\nif (ret)\r\nbreak;\r\npctldev = of_pinctrl_get(pinspec.np);\r\nif (!pctldev)\r\nbreak;\r\nif (pinspec.args[2]) {\r\nif (group_names) {\r\nret = of_property_read_string_index(np,\r\ngroup_names_propname,\r\nindex, &name);\r\nif (strlen(name)) {\r\npr_err("%s: Group name of numeric GPIO ranges must be the empty string.\n",\r\nnp->full_name);\r\nbreak;\r\n}\r\n}\r\nret = gpiochip_add_pin_range(chip,\r\npinctrl_dev_get_devname(pctldev),\r\npinspec.args[0],\r\npinspec.args[1],\r\npinspec.args[2]);\r\nif (ret)\r\nbreak;\r\n} else {\r\nif (pinspec.args[1]) {\r\npr_err("%s: Illegal gpio-range format.\n",\r\nnp->full_name);\r\nbreak;\r\n}\r\nif (!group_names) {\r\npr_err("%s: GPIO group range requested but no %s property.\n",\r\nnp->full_name, group_names_propname);\r\nbreak;\r\n}\r\nret = of_property_read_string_index(np,\r\ngroup_names_propname,\r\nindex, &name);\r\nif (ret)\r\nbreak;\r\nif (!strlen(name)) {\r\npr_err("%s: Group name of GPIO group range cannot be the empty string.\n",\r\nnp->full_name);\r\nbreak;\r\n}\r\nret = gpiochip_add_pingroup_range(chip, pctldev,\r\npinspec.args[0], name);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void of_gpiochip_add_pin_range(struct gpio_chip *chip) {}\r\nvoid of_gpiochip_add(struct gpio_chip *chip)\r\n{\r\nif ((!chip->of_node) && (chip->dev))\r\nchip->of_node = chip->dev->of_node;\r\nif (!chip->of_node)\r\nreturn;\r\nif (!chip->of_xlate) {\r\nchip->of_gpio_n_cells = 2;\r\nchip->of_xlate = of_gpio_simple_xlate;\r\n}\r\nof_gpiochip_add_pin_range(chip);\r\nof_node_get(chip->of_node);\r\n}\r\nvoid of_gpiochip_remove(struct gpio_chip *chip)\r\n{\r\ngpiochip_remove_pin_ranges(chip);\r\nof_node_put(chip->of_node);\r\n}
