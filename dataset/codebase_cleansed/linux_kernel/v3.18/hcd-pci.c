static inline int is_ohci_or_uhci(struct pci_dev *pdev)\r\n{\r\nreturn pdev->class == CL_OHCI || pdev->class == CL_UHCI;\r\n}\r\nstatic void for_each_companion(struct pci_dev *pdev, struct usb_hcd *hcd,\r\ncompanion_fn fn)\r\n{\r\nstruct pci_dev *companion;\r\nstruct usb_hcd *companion_hcd;\r\nunsigned int slot = PCI_SLOT(pdev->devfn);\r\ncompanion = NULL;\r\nfor_each_pci_dev(companion) {\r\nif (companion->bus != pdev->bus ||\r\nPCI_SLOT(companion->devfn) != slot)\r\ncontinue;\r\ncompanion_hcd = pci_get_drvdata(companion);\r\nif (!companion_hcd || !companion_hcd->self.root_hub)\r\ncontinue;\r\nfn(pdev, hcd, companion, companion_hcd);\r\n}\r\n}\r\nstatic void ehci_pre_add(struct pci_dev *pdev, struct usb_hcd *hcd,\r\nstruct pci_dev *companion, struct usb_hcd *companion_hcd)\r\n{\r\nstruct usb_device *udev;\r\nif (is_ohci_or_uhci(companion)) {\r\nudev = companion_hcd->self.root_hub;\r\nusb_lock_device(udev);\r\nusb_set_configuration(udev, 0);\r\n}\r\n}\r\nstatic void ehci_post_add(struct pci_dev *pdev, struct usb_hcd *hcd,\r\nstruct pci_dev *companion, struct usb_hcd *companion_hcd)\r\n{\r\nstruct usb_device *udev;\r\nif (is_ohci_or_uhci(companion)) {\r\nif (dev_get_drvdata(&pdev->dev)) {\r\ndev_dbg(&pdev->dev, "HS companion for %s\n",\r\ndev_name(&companion->dev));\r\ncompanion_hcd->self.hs_companion = &hcd->self;\r\n}\r\nudev = companion_hcd->self.root_hub;\r\nusb_set_configuration(udev, 1);\r\nusb_unlock_device(udev);\r\n}\r\n}\r\nstatic void non_ehci_add(struct pci_dev *pdev, struct usb_hcd *hcd,\r\nstruct pci_dev *companion, struct usb_hcd *companion_hcd)\r\n{\r\nif (is_ohci_or_uhci(pdev) && companion->class == CL_EHCI) {\r\ndev_dbg(&pdev->dev, "FS/LS companion for %s\n",\r\ndev_name(&companion->dev));\r\nhcd->self.hs_companion = &companion_hcd->self;\r\n}\r\n}\r\nstatic void ehci_remove(struct pci_dev *pdev, struct usb_hcd *hcd,\r\nstruct pci_dev *companion, struct usb_hcd *companion_hcd)\r\n{\r\nif (is_ohci_or_uhci(companion))\r\ncompanion_hcd->self.hs_companion = NULL;\r\n}\r\nstatic void ehci_wait_for_companions(struct pci_dev *pdev, struct usb_hcd *hcd,\r\nstruct pci_dev *companion, struct usb_hcd *companion_hcd)\r\n{\r\nif (is_ohci_or_uhci(companion))\r\ndevice_pm_wait_for_dev(&pdev->dev, &companion->dev);\r\n}\r\nint usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct hc_driver *driver;\r\nstruct usb_hcd *hcd;\r\nint retval;\r\nint hcd_irq = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (!id)\r\nreturn -EINVAL;\r\ndriver = (struct hc_driver *)id->driver_data;\r\nif (!driver)\r\nreturn -EINVAL;\r\nif (pci_enable_device(dev) < 0)\r\nreturn -ENODEV;\r\nif ((driver->flags & HCD_MASK) != HCD_USB3) {\r\nif (!dev->irq) {\r\ndev_err(&dev->dev,\r\n"Found HC with no IRQ. Check BIOS/PCI %s setup!\n",\r\npci_name(dev));\r\nretval = -ENODEV;\r\ngoto disable_pci;\r\n}\r\nhcd_irq = dev->irq;\r\n}\r\nhcd = usb_create_hcd(driver, &dev->dev, pci_name(dev));\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto disable_pci;\r\n}\r\nhcd->amd_resume_bug = (usb_hcd_amd_remote_wakeup_quirk(dev) &&\r\ndriver->flags & (HCD_USB11 | HCD_USB3)) ? 1 : 0;\r\nif (driver->flags & HCD_MEMORY) {\r\nhcd->rsrc_start = pci_resource_start(dev, 0);\r\nhcd->rsrc_len = pci_resource_len(dev, 0);\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,\r\ndriver->description)) {\r\ndev_dbg(&dev->dev, "controller already in use\n");\r\nretval = -EBUSY;\r\ngoto put_hcd;\r\n}\r\nhcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);\r\nif (hcd->regs == NULL) {\r\ndev_dbg(&dev->dev, "error mapping memory\n");\r\nretval = -EFAULT;\r\ngoto release_mem_region;\r\n}\r\n} else {\r\nint region;\r\nfor (region = 0; region < PCI_ROM_RESOURCE; region++) {\r\nif (!(pci_resource_flags(dev, region) &\r\nIORESOURCE_IO))\r\ncontinue;\r\nhcd->rsrc_start = pci_resource_start(dev, region);\r\nhcd->rsrc_len = pci_resource_len(dev, region);\r\nif (request_region(hcd->rsrc_start, hcd->rsrc_len,\r\ndriver->description))\r\nbreak;\r\n}\r\nif (region == PCI_ROM_RESOURCE) {\r\ndev_dbg(&dev->dev, "no i/o regions available\n");\r\nretval = -EBUSY;\r\ngoto put_hcd;\r\n}\r\n}\r\npci_set_master(dev);\r\nif (dev->class == CL_EHCI) {\r\ndown_write(&companions_rwsem);\r\ndev_set_drvdata(&dev->dev, hcd);\r\nfor_each_companion(dev, hcd, ehci_pre_add);\r\nretval = usb_add_hcd(hcd, hcd_irq, IRQF_SHARED);\r\nif (retval != 0)\r\ndev_set_drvdata(&dev->dev, NULL);\r\nfor_each_companion(dev, hcd, ehci_post_add);\r\nup_write(&companions_rwsem);\r\n} else {\r\ndown_read(&companions_rwsem);\r\ndev_set_drvdata(&dev->dev, hcd);\r\nretval = usb_add_hcd(hcd, hcd_irq, IRQF_SHARED);\r\nif (retval != 0)\r\ndev_set_drvdata(&dev->dev, NULL);\r\nelse\r\nfor_each_companion(dev, hcd, non_ehci_add);\r\nup_read(&companions_rwsem);\r\n}\r\nif (retval != 0)\r\ngoto unmap_registers;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nif (pci_dev_run_wake(dev))\r\npm_runtime_put_noidle(&dev->dev);\r\nreturn retval;\r\nunmap_registers:\r\nif (driver->flags & HCD_MEMORY) {\r\niounmap(hcd->regs);\r\nrelease_mem_region:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\n} else\r\nrelease_region(hcd->rsrc_start, hcd->rsrc_len);\r\nput_hcd:\r\nusb_put_hcd(hcd);\r\ndisable_pci:\r\npci_disable_device(dev);\r\ndev_err(&dev->dev, "init %s fail, %d\n", pci_name(dev), retval);\r\nreturn retval;\r\n}\r\nvoid usb_hcd_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct usb_hcd *hcd;\r\nhcd = pci_get_drvdata(dev);\r\nif (!hcd)\r\nreturn;\r\nif (pci_dev_run_wake(dev))\r\npm_runtime_get_noresume(&dev->dev);\r\nlocal_irq_disable();\r\nusb_hcd_irq(0, hcd);\r\nlocal_irq_enable();\r\nif (dev->class == CL_EHCI) {\r\ndown_write(&companions_rwsem);\r\nfor_each_companion(dev, hcd, ehci_remove);\r\nusb_remove_hcd(hcd);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nup_write(&companions_rwsem);\r\n} else {\r\ndown_read(&companions_rwsem);\r\nhcd->self.hs_companion = NULL;\r\nusb_remove_hcd(hcd);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nup_read(&companions_rwsem);\r\n}\r\nif (hcd->driver->flags & HCD_MEMORY) {\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\n} else {\r\nrelease_region(hcd->rsrc_start, hcd->rsrc_len);\r\n}\r\nusb_put_hcd(hcd);\r\npci_disable_device(dev);\r\n}\r\nvoid usb_hcd_pci_shutdown(struct pci_dev *dev)\r\n{\r\nstruct usb_hcd *hcd;\r\nhcd = pci_get_drvdata(dev);\r\nif (!hcd)\r\nreturn;\r\nif (test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) &&\r\nhcd->driver->shutdown) {\r\nhcd->driver->shutdown(hcd);\r\nif (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)\r\nfree_irq(hcd->irq, hcd);\r\npci_disable_device(dev);\r\n}\r\n}\r\nstatic void powermac_set_asic(struct pci_dev *pci_dev, int enable)\r\n{\r\nif (machine_is(powermac)) {\r\nstruct device_node *of_node;\r\nof_node = pci_device_to_OF_node(pci_dev);\r\nif (of_node)\r\npmac_call_feature(PMAC_FTR_USB_ENABLE,\r\nof_node, 0, enable);\r\n}\r\n}\r\nstatic inline void powermac_set_asic(struct pci_dev *pci_dev, int enable)\r\n{}\r\nstatic int check_root_hub_suspended(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct usb_hcd *hcd = pci_get_drvdata(pci_dev);\r\nif (HCD_RH_RUNNING(hcd)) {\r\ndev_warn(dev, "Root hub is not suspended\n");\r\nreturn -EBUSY;\r\n}\r\nif (hcd->shared_hcd) {\r\nhcd = hcd->shared_hcd;\r\nif (HCD_RH_RUNNING(hcd)) {\r\ndev_warn(dev, "Secondary root hub is not suspended\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int suspend_common(struct device *dev, bool do_wakeup)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct usb_hcd *hcd = pci_get_drvdata(pci_dev);\r\nint retval;\r\nretval = check_root_hub_suspended(dev);\r\nif (retval)\r\nreturn retval;\r\nif (hcd->driver->pci_suspend && !HCD_DEAD(hcd)) {\r\nif (do_wakeup && HCD_WAKEUP_PENDING(hcd))\r\nreturn -EBUSY;\r\nif (do_wakeup && hcd->shared_hcd &&\r\nHCD_WAKEUP_PENDING(hcd->shared_hcd))\r\nreturn -EBUSY;\r\nretval = hcd->driver->pci_suspend(hcd, do_wakeup);\r\nsuspend_report_result(hcd->driver->pci_suspend, retval);\r\nif ((retval == 0 && do_wakeup && HCD_WAKEUP_PENDING(hcd)) ||\r\n(retval == 0 && do_wakeup && hcd->shared_hcd &&\r\nHCD_WAKEUP_PENDING(hcd->shared_hcd))) {\r\nif (hcd->driver->pci_resume)\r\nhcd->driver->pci_resume(hcd, false);\r\nretval = -EBUSY;\r\n}\r\nif (retval)\r\nreturn retval;\r\n}\r\nif (!hcd->msix_enabled)\r\nsynchronize_irq(pci_dev->irq);\r\npci_disable_device(pci_dev);\r\nreturn retval;\r\n}\r\nstatic int resume_common(struct device *dev, int event)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct usb_hcd *hcd = pci_get_drvdata(pci_dev);\r\nint retval;\r\nif (HCD_RH_RUNNING(hcd) ||\r\n(hcd->shared_hcd &&\r\nHCD_RH_RUNNING(hcd->shared_hcd))) {\r\ndev_dbg(dev, "can't resume, not suspended!\n");\r\nreturn 0;\r\n}\r\nretval = pci_enable_device(pci_dev);\r\nif (retval < 0) {\r\ndev_err(dev, "can't re-enable after resume, %d!\n", retval);\r\nreturn retval;\r\n}\r\npci_set_master(pci_dev);\r\nif (hcd->driver->pci_resume && !HCD_DEAD(hcd)) {\r\nif (pci_dev->class == CL_EHCI && event != PM_EVENT_AUTO_RESUME)\r\nfor_each_companion(pci_dev, hcd,\r\nehci_wait_for_companions);\r\nretval = hcd->driver->pci_resume(hcd,\r\nevent == PM_EVENT_RESTORE);\r\nif (retval) {\r\ndev_err(dev, "PCI post-resume error %d!\n", retval);\r\nif (hcd->shared_hcd)\r\nusb_hc_died(hcd->shared_hcd);\r\nusb_hc_died(hcd);\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int hcd_pci_suspend(struct device *dev)\r\n{\r\nreturn suspend_common(dev, device_may_wakeup(dev));\r\n}\r\nstatic int hcd_pci_suspend_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct usb_hcd *hcd = pci_get_drvdata(pci_dev);\r\nint retval;\r\nretval = check_root_hub_suspended(dev);\r\nif (retval)\r\nreturn retval;\r\npci_save_state(pci_dev);\r\nif (HCD_DEAD(hcd))\r\ndevice_set_wakeup_enable(dev, 0);\r\ndev_dbg(dev, "wakeup: %d\n", device_may_wakeup(dev));\r\nretval = pci_prepare_to_sleep(pci_dev);\r\nif (retval == -EIO) {\r\ndev_dbg(dev, "--> PCI D0 legacy\n");\r\nretval = 0;\r\n} else if (retval == 0) {\r\ndev_dbg(dev, "--> PCI %s\n",\r\npci_power_name(pci_dev->current_state));\r\n} else {\r\nsuspend_report_result(pci_prepare_to_sleep, retval);\r\nreturn retval;\r\n}\r\npowermac_set_asic(pci_dev, 0);\r\nreturn retval;\r\n}\r\nstatic int hcd_pci_resume_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\npowermac_set_asic(pci_dev, 1);\r\npci_back_from_sleep(pci_dev);\r\nreturn 0;\r\n}\r\nstatic int hcd_pci_resume(struct device *dev)\r\n{\r\nreturn resume_common(dev, PM_EVENT_RESUME);\r\n}\r\nstatic int hcd_pci_restore(struct device *dev)\r\n{\r\nreturn resume_common(dev, PM_EVENT_RESTORE);\r\n}\r\nstatic int hcd_pci_runtime_suspend(struct device *dev)\r\n{\r\nint retval;\r\nretval = suspend_common(dev, true);\r\nif (retval == 0)\r\npowermac_set_asic(to_pci_dev(dev), 0);\r\ndev_dbg(dev, "hcd_pci_runtime_suspend: %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int hcd_pci_runtime_resume(struct device *dev)\r\n{\r\nint retval;\r\npowermac_set_asic(to_pci_dev(dev), 1);\r\nretval = resume_common(dev, PM_EVENT_AUTO_RESUME);\r\ndev_dbg(dev, "hcd_pci_runtime_resume: %d\n", retval);\r\nreturn retval;\r\n}
