static int qib_ibsd_ucode_loaded(struct qib_pportdata *ppd,\r\nconst struct firmware *fw)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nif (!dd->cspec->serdes_first_init_done &&\r\nqib_sd7220_ib_vfy(dd, fw) > 0)\r\ndd->cspec->serdes_first_init_done = 1;\r\nreturn dd->cspec->serdes_first_init_done;\r\n}\r\nvoid qib_sd7220_clr_ibpar(struct qib_devdata *dd)\r\n{\r\nint ret;\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6,\r\nUC_PAR_CLR_D, UC_PAR_CLR_M);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed clearing IBSerDes Parity err\n");\r\ngoto bail;\r\n}\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0,\r\nUC_PAR_CLR_M);\r\nqib_read_kreg32(dd, kr_scratch);\r\nudelay(4);\r\nqib_write_kreg(dd, kr_hwerrclear,\r\nQLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR);\r\nqib_read_kreg32(dd, kr_scratch);\r\nbail:\r\nreturn;\r\n}\r\nstatic int qib_resync_ibepb(struct qib_devdata *dd)\r\n{\r\nint ret, pat, tries, chn;\r\nu32 loc;\r\nret = -1;\r\nchn = 0;\r\nfor (tries = 0; tries < (4 * IBSD_RESYNC_TRIES); ++tries) {\r\nloc = IB_PGUDP(chn);\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed read in resync\n");\r\ncontinue;\r\n}\r\nif (ret != 0xF0 && ret != 0x55 && tries == 0)\r\nqib_dev_err(dd, "unexpected pattern in resync\n");\r\npat = ret ^ 0xA5;\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, pat, 0xFF);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed write in resync\n");\r\ncontinue;\r\n}\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed re-read in resync\n");\r\ncontinue;\r\n}\r\nif (ret != pat) {\r\nqib_dev_err(dd, "Failed compare1 in resync\n");\r\ncontinue;\r\n}\r\nloc = IB_CMUDONE(chn);\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed CMUDONE rd in resync\n");\r\ncontinue;\r\n}\r\nif ((ret & 0x70) != ((chn << 4) | 0x40)) {\r\nqib_dev_err(dd, "Bad CMUDONE value %02X, chn %d\n",\r\nret, chn);\r\ncontinue;\r\n}\r\nif (++chn == 4)\r\nbreak;\r\n}\r\nreturn (ret > 0) ? 0 : ret;\r\n}\r\nstatic int qib_ibsd_reset(struct qib_devdata *dd, int assert_rst)\r\n{\r\nu64 rst_val;\r\nint ret = 0;\r\nunsigned long flags;\r\nrst_val = qib_read_kreg64(dd, kr_ibserdesctrl);\r\nif (assert_rst) {\r\nspin_lock_irqsave(&dd->cspec->sdepb_lock, flags);\r\nepb_access(dd, IB_7220_SERDES, 1);\r\nrst_val |= 1ULL;\r\nqib_write_kreg(dd, kr_hwerrmask,\r\ndd->cspec->hwerrmask &\r\n~QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR);\r\nqib_write_kreg(dd, kr_ibserdesctrl, rst_val);\r\nqib_read_kreg32(dd, kr_scratch);\r\nudelay(2);\r\nepb_access(dd, IB_7220_SERDES, -1);\r\nspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\r\n} else {\r\nu64 val;\r\nrst_val &= ~(1ULL);\r\nqib_write_kreg(dd, kr_hwerrmask,\r\ndd->cspec->hwerrmask &\r\n~QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR);\r\nret = qib_resync_ibepb(dd);\r\nif (ret < 0)\r\nqib_dev_err(dd, "unable to re-sync IB EPB\n");\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG5, 1, 1);\r\nif (ret < 0)\r\ngoto bail;\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0x80,\r\n0x80);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed to set WDOG disable\n");\r\ngoto bail;\r\n}\r\nqib_write_kreg(dd, kr_ibserdesctrl, rst_val);\r\nqib_read_kreg32(dd, kr_scratch);\r\nudelay(1);\r\nqib_sd7220_clr_ibpar(dd);\r\nval = qib_read_kreg64(dd, kr_hwerrstatus);\r\nif (val & QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR) {\r\nqib_dev_err(dd, "IBUC Parity still set after RST\n");\r\ndd->cspec->hwerrmask &=\r\n~QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR;\r\n}\r\nqib_write_kreg(dd, kr_hwerrmask,\r\ndd->cspec->hwerrmask);\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void qib_sd_trimdone_monitor(struct qib_devdata *dd,\r\nconst char *where)\r\n{\r\nint ret, chn, baduns;\r\nu64 val;\r\nif (!where)\r\nwhere = "?";\r\nudelay(2);\r\nret = qib_resync_ibepb(dd);\r\nif (ret < 0)\r\nqib_dev_err(dd, "not able to re-sync IB EPB (%s)\n", where);\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_CTRL2(0), 0, 0);\r\nif (ret < 0)\r\nqib_dev_err(dd, "Failed TRIMDONE 1st read, (%s)\n", where);\r\nval = qib_read_kreg64(dd, kr_ibcstatus);\r\nif (!(val & (1ULL << 11)))\r\nqib_dev_err(dd, "IBCS TRIMDONE clear (%s)\n", where);\r\nudelay(2);\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0x80, 0x80);\r\nif (ret < 0)\r\nqib_dev_err(dd, "Failed Dummy RMW, (%s)\n", where);\r\nudelay(10);\r\nbaduns = 0;\r\nfor (chn = 3; chn >= 0; --chn) {\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\r\nIB_CTRL2(chn), 0, 0);\r\nif (ret < 0)\r\nqib_dev_err(dd,\r\n"Failed checking TRIMDONE, chn %d (%s)\n",\r\nchn, where);\r\nif (!(ret & 0x10)) {\r\nint probe;\r\nbaduns |= (1 << chn);\r\nqib_dev_err(dd,\r\n"TRIMDONE cleared on chn %d (%02X). (%s)\n",\r\nchn, ret, where);\r\nprobe = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\r\nIB_PGUDP(0), 0, 0);\r\nqib_dev_err(dd, "probe is %d (%02X)\n",\r\nprobe, probe);\r\nprobe = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\r\nIB_CTRL2(chn), 0, 0);\r\nqib_dev_err(dd, "re-read: %d (%02X)\n",\r\nprobe, probe);\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\r\nIB_CTRL2(chn), 0x10, 0x10);\r\nif (ret < 0)\r\nqib_dev_err(dd,\r\n"Err on TRIMDONE rewrite1\n");\r\n}\r\n}\r\nfor (chn = 3; chn >= 0; --chn) {\r\nif (baduns & (1 << chn)) {\r\nqib_dev_err(dd,\r\n"Resetting TRIMDONE on chn %d (%s)\n",\r\nchn, where);\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\r\nIB_CTRL2(chn), 0x10, 0x10);\r\nif (ret < 0)\r\nqib_dev_err(dd,\r\n"Failed re-setting TRIMDONE, chn %d (%s)\n",\r\nchn, where);\r\n}\r\n}\r\n}\r\nint qib_sd7220_init(struct qib_devdata *dd)\r\n{\r\nconst struct firmware *fw;\r\nint ret = 1;\r\nint first_reset, was_reset;\r\nwas_reset = (qib_read_kreg64(dd, kr_ibserdesctrl) & 1);\r\nif (!was_reset) {\r\nqib_ibsd_reset(dd, 1);\r\nqib_sd_trimdone_monitor(dd, "Driver-reload");\r\n}\r\nret = request_firmware(&fw, SD7220_FW_NAME, &dd->pcidev->dev);\r\nif (ret) {\r\nqib_dev_err(dd, "Failed to load IB SERDES image\n");\r\ngoto done;\r\n}\r\nret = qib_ibsd_ucode_loaded(dd->pport, fw);\r\nif (ret < 0)\r\ngoto bail;\r\nfirst_reset = !ret;\r\nret = qib_sd_early(dd);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed to set IB SERDES early defaults\n");\r\ngoto bail;\r\n}\r\nif (first_reset) {\r\nret = qib_sd_dactrim(dd);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed IB SERDES DAC trim\n");\r\ngoto bail;\r\n}\r\n}\r\nret = qib_internal_presets(dd);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed to set IB SERDES presets\n");\r\ngoto bail;\r\n}\r\nret = qib_sd_trimself(dd, 0x80);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed to set IB SERDES TRIMSELF\n");\r\ngoto bail;\r\n}\r\nret = 0;\r\nif (first_reset) {\r\nint vfy;\r\nint trim_done;\r\nret = qib_sd7220_ib_load(dd, fw);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed to load IB SERDES image\n");\r\ngoto bail;\r\n} else {\r\nvfy = qib_sd7220_ib_vfy(dd, fw);\r\nif (vfy != ret) {\r\nqib_dev_err(dd, "SERDES PRAM VFY failed\n");\r\ngoto bail;\r\n}\r\n}\r\nret = 0;\r\nret = ibsd_mod_allchnls(dd, START_EQ1(0), 0, 0x38);\r\nif (ret < 0) {\r\nqib_dev_err(dd, "Failed clearing START_EQ1\n");\r\ngoto bail;\r\n}\r\nqib_ibsd_reset(dd, 0);\r\ntrim_done = qib_sd_trimdone_poll(dd);\r\nqib_ibsd_reset(dd, 1);\r\nif (!trim_done) {\r\nqib_dev_err(dd, "No TRIMDONE seen\n");\r\ngoto bail;\r\n}\r\nqib_sd_trimdone_monitor(dd, "First-reset");\r\ndd->cspec->serdes_first_init_done = 1;\r\n}\r\nret = 0;\r\nif (qib_sd_setvals(dd) >= 0)\r\ngoto done;\r\nbail:\r\nret = 1;\r\ndone:\r\nset_7220_relock_poll(dd, -1);\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int epb_access(struct qib_devdata *dd, int sdnum, int claim)\r\n{\r\nu16 acc;\r\nu64 accval;\r\nint owned = 0;\r\nu64 oct_sel = 0;\r\nswitch (sdnum) {\r\ncase IB_7220_SERDES:\r\nacc = kr_ibsd_epb_access_ctrl;\r\nbreak;\r\ncase PCIE_SERDES0:\r\ncase PCIE_SERDES1:\r\nacc = kr_pciesd_epb_access_ctrl;\r\noct_sel = (2 << (sdnum - PCIE_SERDES0));\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nqib_read_kreg32(dd, kr_scratch);\r\nudelay(15);\r\naccval = qib_read_kreg32(dd, acc);\r\nowned = !!(accval & EPB_ACC_GNT);\r\nif (claim < 0) {\r\nu64 pollval;\r\nu64 newval = 0;\r\nqib_write_kreg(dd, acc, newval);\r\npollval = qib_read_kreg32(dd, acc);\r\nudelay(5);\r\npollval = qib_read_kreg32(dd, acc);\r\nif (pollval & EPB_ACC_GNT)\r\nowned = -1;\r\n} else if (claim > 0) {\r\nu64 pollval;\r\nu64 newval = EPB_ACC_REQ | oct_sel;\r\nqib_write_kreg(dd, acc, newval);\r\npollval = qib_read_kreg32(dd, acc);\r\nudelay(5);\r\npollval = qib_read_kreg32(dd, acc);\r\nif (!(pollval & EPB_ACC_GNT))\r\nowned = -1;\r\n}\r\nreturn owned;\r\n}\r\nstatic int epb_trans(struct qib_devdata *dd, u16 reg, u64 i_val, u64 *o_vp)\r\n{\r\nint tries;\r\nu64 transval;\r\nqib_write_kreg(dd, reg, i_val);\r\ntransval = qib_read_kreg64(dd, reg);\r\nfor (tries = EPB_TRANS_TRIES; tries; --tries) {\r\ntransval = qib_read_kreg32(dd, reg);\r\nif (transval & EPB_TRANS_RDY)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (transval & EPB_TRANS_ERR)\r\nreturn -1;\r\nif (tries > 0 && o_vp)\r\n*o_vp = transval;\r\nreturn tries;\r\n}\r\nstatic int qib_sd7220_reg_mod(struct qib_devdata *dd, int sdnum, u32 loc,\r\nu32 wd, u32 mask)\r\n{\r\nu16 trans;\r\nu64 transval;\r\nint owned;\r\nint tries, ret;\r\nunsigned long flags;\r\nswitch (sdnum) {\r\ncase IB_7220_SERDES:\r\ntrans = kr_ibsd_epb_transaction_reg;\r\nbreak;\r\ncase PCIE_SERDES0:\r\ncase PCIE_SERDES1:\r\ntrans = kr_pciesd_epb_transaction_reg;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&dd->cspec->sdepb_lock, flags);\r\nowned = epb_access(dd, sdnum, 1);\r\nif (owned < 0) {\r\nspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\r\nreturn -1;\r\n}\r\nret = 0;\r\nfor (tries = EPB_TRANS_TRIES; tries; --tries) {\r\ntransval = qib_read_kreg32(dd, trans);\r\nif (transval & EPB_TRANS_RDY)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (tries > 0) {\r\ntries = 1;\r\nif (mask != 0xFF) {\r\ntransval = loc | EPB_RD;\r\ntries = epb_trans(dd, trans, transval, &transval);\r\n}\r\nif (tries > 0 && mask != 0) {\r\nwd = (wd & mask) | (transval & ~mask);\r\ntransval = loc | (wd & EPB_DATA_MASK);\r\ntries = epb_trans(dd, trans, transval, &transval);\r\n}\r\n}\r\nif (epb_access(dd, sdnum, -1) < 0)\r\nret = -1;\r\nelse\r\nret = transval & EPB_DATA_MASK;\r\nspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\r\nif (tries <= 0)\r\nret = -1;\r\nreturn ret;\r\n}\r\nstatic int qib_sd7220_ram_xfer(struct qib_devdata *dd, int sdnum, u32 loc,\r\nu8 *buf, int cnt, int rd_notwr)\r\n{\r\nu16 trans;\r\nu64 transval;\r\nu64 csbit;\r\nint owned;\r\nint tries;\r\nint sofar;\r\nint addr;\r\nint ret;\r\nunsigned long flags;\r\nconst char *op;\r\nswitch (sdnum) {\r\ncase IB_7220_SERDES:\r\ncsbit = 1ULL << EPB_IB_UC_CS_SHF;\r\ntrans = kr_ibsd_epb_transaction_reg;\r\nbreak;\r\ncase PCIE_SERDES0:\r\ncase PCIE_SERDES1:\r\ncsbit = 1ULL << EPB_PCIE_UC_CS_SHF;\r\ntrans = kr_pciesd_epb_transaction_reg;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nop = rd_notwr ? "Rd" : "Wr";\r\nspin_lock_irqsave(&dd->cspec->sdepb_lock, flags);\r\nowned = epb_access(dd, sdnum, 1);\r\nif (owned < 0) {\r\nspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\r\nreturn -1;\r\n}\r\naddr = loc & 0x1FFF;\r\nfor (tries = EPB_TRANS_TRIES; tries; --tries) {\r\ntransval = qib_read_kreg32(dd, trans);\r\nif (transval & EPB_TRANS_RDY)\r\nbreak;\r\nudelay(5);\r\n}\r\nsofar = 0;\r\nif (tries > 0) {\r\ntransval = csbit | EPB_UC_CTL |\r\n(rd_notwr ? EPB_ROM_R : EPB_ROM_W);\r\ntries = epb_trans(dd, trans, transval, &transval);\r\nwhile (tries > 0 && sofar < cnt) {\r\nif (!sofar) {\r\nint addrbyte = (addr + sofar) >> 8;\r\ntransval = csbit | EPB_MADDRH | addrbyte;\r\ntries = epb_trans(dd, trans, transval,\r\n&transval);\r\nif (tries <= 0)\r\nbreak;\r\naddrbyte = (addr + sofar) & 0xFF;\r\ntransval = csbit | EPB_MADDRL | addrbyte;\r\ntries = epb_trans(dd, trans, transval,\r\n&transval);\r\nif (tries <= 0)\r\nbreak;\r\n}\r\nif (rd_notwr)\r\ntransval = csbit | EPB_ROMDATA | EPB_RD;\r\nelse\r\ntransval = csbit | EPB_ROMDATA | buf[sofar];\r\ntries = epb_trans(dd, trans, transval, &transval);\r\nif (tries <= 0)\r\nbreak;\r\nif (rd_notwr)\r\nbuf[sofar] = transval & EPB_DATA_MASK;\r\n++sofar;\r\n}\r\ntransval = csbit | EPB_UC_CTL;\r\ntries = epb_trans(dd, trans, transval, &transval);\r\n}\r\nret = sofar;\r\nif (epb_access(dd, sdnum, -1) < 0)\r\nret = -1;\r\nspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\r\nif (tries <= 0)\r\nret = -1;\r\nreturn ret;\r\n}\r\nstatic int qib_sd7220_prog_ld(struct qib_devdata *dd, int sdnum,\r\nconst u8 *img, int len, int offset)\r\n{\r\nint cnt, sofar, req;\r\nsofar = 0;\r\nwhile (sofar < len) {\r\nreq = len - sofar;\r\nif (req > PROG_CHUNK)\r\nreq = PROG_CHUNK;\r\ncnt = qib_sd7220_ram_xfer(dd, sdnum, offset + sofar,\r\n(u8 *)img + sofar, req, 0);\r\nif (cnt < req) {\r\nsofar = -1;\r\nbreak;\r\n}\r\nsofar += req;\r\n}\r\nreturn sofar;\r\n}\r\nstatic int qib_sd7220_prog_vfy(struct qib_devdata *dd, int sdnum,\r\nconst u8 *img, int len, int offset)\r\n{\r\nint cnt, sofar, req, idx, errors;\r\nunsigned char readback[VFY_CHUNK];\r\nerrors = 0;\r\nsofar = 0;\r\nwhile (sofar < len) {\r\nreq = len - sofar;\r\nif (req > VFY_CHUNK)\r\nreq = VFY_CHUNK;\r\ncnt = qib_sd7220_ram_xfer(dd, sdnum, sofar + offset,\r\nreadback, req, 1);\r\nif (cnt < req) {\r\nsofar = -1;\r\nbreak;\r\n}\r\nfor (idx = 0; idx < cnt; ++idx) {\r\nif (readback[idx] != img[idx+sofar])\r\n++errors;\r\n}\r\nsofar += cnt;\r\n}\r\nreturn errors ? -errors : sofar;\r\n}\r\nstatic int\r\nqib_sd7220_ib_load(struct qib_devdata *dd, const struct firmware *fw)\r\n{\r\nreturn qib_sd7220_prog_ld(dd, IB_7220_SERDES, fw->data, fw->size, 0);\r\n}\r\nstatic int\r\nqib_sd7220_ib_vfy(struct qib_devdata *dd, const struct firmware *fw)\r\n{\r\nreturn qib_sd7220_prog_vfy(dd, IB_7220_SERDES, fw->data, fw->size, 0);\r\n}\r\nstatic int qib_sd_trimdone_poll(struct qib_devdata *dd)\r\n{\r\nint trim_tmo, ret;\r\nuint64_t val;\r\nret = 0;\r\nfor (trim_tmo = 0; trim_tmo < TRIM_TMO; ++trim_tmo) {\r\nval = qib_read_kreg64(dd, kr_ibcstatus);\r\nif (val & IB_SERDES_TRIM_DONE) {\r\nret = 1;\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\nif (trim_tmo >= TRIM_TMO) {\r\nqib_dev_err(dd, "No TRIMDONE in %d tries\n", trim_tmo);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int qib_sd_setvals(struct qib_devdata *dd)\r\n{\r\nint idx, midx;\r\nint min_idx;\r\nuint32_t dds_reg_map;\r\nu64 __iomem *taddr, *iaddr;\r\nuint64_t data;\r\nuint64_t sdctl;\r\ntaddr = dd->kregbase + kr_serdes_maptable;\r\niaddr = dd->kregbase + kr_serdes_ddsrxeq0;\r\nsdctl = qib_read_kreg64(dd, kr_ibserdesctrl);\r\nsdctl = (sdctl & ~(0x1f << 8)) | (NUM_DDS_REGS << 8);\r\nsdctl = (sdctl & ~(0x1f << 13)) | (RXEQ_ROWS << 13);\r\nqib_write_kreg(dd, kr_ibserdesctrl, sdctl);\r\ndds_reg_map = DDS_REG_MAP;\r\nfor (idx = 0; idx < NUM_DDS_REGS; ++idx) {\r\ndata = ((dds_reg_map & 0xF) << 4) | TX_FAST_ELT;\r\nwriteq(data, iaddr + idx);\r\nmmiowb();\r\nqib_read_kreg32(dd, kr_scratch);\r\ndds_reg_map >>= 4;\r\nfor (midx = 0; midx < DDS_ROWS; ++midx) {\r\nu64 __iomem *daddr = taddr + ((midx << 4) + idx);\r\ndata = dds_init_vals[midx].reg_vals[idx];\r\nwriteq(data, daddr);\r\nmmiowb();\r\nqib_read_kreg32(dd, kr_scratch);\r\n}\r\n}\r\nmin_idx = idx;\r\ntaddr += 0x100;\r\nfor (idx = 0; idx < RXEQ_ROWS; ++idx) {\r\nint didx;\r\nint vidx;\r\ndidx = idx + min_idx;\r\nwriteq(rxeq_init_vals[idx].rdesc, iaddr + didx);\r\nmmiowb();\r\nqib_read_kreg32(dd, kr_scratch);\r\nfor (vidx = 0; vidx < 4; vidx++) {\r\ndata = rxeq_init_vals[idx].rdata[vidx];\r\nwriteq(data, taddr + (vidx << 6) + idx);\r\nmmiowb();\r\nqib_read_kreg32(dd, kr_scratch);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ibsd_mod_allchnls(struct qib_devdata *dd, int loc, int val,\r\nint mask)\r\n{\r\nint ret = -1;\r\nint chnl;\r\nif (loc & EPB_GLOBAL_WR) {\r\nloc |= (1U << EPB_IB_QUAD0_CS_SHF);\r\nchnl = (loc >> (4 + EPB_ADDR_SHF)) & 7;\r\nif (mask != 0xFF) {\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\r\nloc & ~EPB_GLOBAL_WR, 0, 0);\r\nif (ret < 0) {\r\nint sloc = loc >> EPB_ADDR_SHF;\r\nqib_dev_err(dd,\r\n"pre-read failed: elt %d, addr 0x%X, chnl %d\n",\r\n(sloc & 0xF),\r\n(sloc >> 9) & 0x3f, chnl);\r\nreturn ret;\r\n}\r\nval = (ret & ~mask) | (val & mask);\r\n}\r\nloc &= ~(7 << (4+EPB_ADDR_SHF));\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, val, 0xFF);\r\nif (ret < 0) {\r\nint sloc = loc >> EPB_ADDR_SHF;\r\nqib_dev_err(dd,\r\n"Global WR failed: elt %d, addr 0x%X, val %02X\n",\r\n(sloc & 0xF), (sloc >> 9) & 0x3f, val);\r\n}\r\nreturn ret;\r\n}\r\nloc &= ~(7 << (4+EPB_ADDR_SHF));\r\nloc |= (1U << EPB_IB_QUAD0_CS_SHF);\r\nfor (chnl = 0; chnl < 4; ++chnl) {\r\nint cloc = loc | (chnl << (4+EPB_ADDR_SHF));\r\nret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, cloc, val, mask);\r\nif (ret < 0) {\r\nint sloc = loc >> EPB_ADDR_SHF;\r\nqib_dev_err(dd,\r\n"Write failed: elt %d, addr 0x%X, chnl %d, val 0x%02X, mask 0x%02X\n",\r\n(sloc & 0xF), (sloc >> 9) & 0x3f, chnl,\r\nval & 0xFF, mask & 0xFF);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int set_dds_vals(struct qib_devdata *dd, struct dds_init *ddi)\r\n{\r\nint ret;\r\nint idx, reg, data;\r\nuint32_t regmap;\r\nregmap = DDS_REG_MAP;\r\nfor (idx = 0; idx < NUM_DDS_REGS; ++idx) {\r\nreg = (regmap & 0xF);\r\nregmap >>= 4;\r\ndata = ddi->reg_vals[idx];\r\nret = ibsd_mod_allchnls(dd, EPB_LOC(0, 9, reg), data, 0xFF);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int set_rxeq_vals(struct qib_devdata *dd, int vsel)\r\n{\r\nint ret;\r\nint ridx;\r\nint cnt = ARRAY_SIZE(rxeq_init_vals);\r\nfor (ridx = 0; ridx < cnt; ++ridx) {\r\nint elt, reg, val, loc;\r\nelt = rxeq_init_vals[ridx].rdesc & 0xF;\r\nreg = rxeq_init_vals[ridx].rdesc >> 4;\r\nloc = EPB_LOC(0, elt, reg);\r\nval = rxeq_init_vals[ridx].rdata[vsel];\r\nret = ibsd_mod_allchnls(dd, loc, val, 0xFF);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int qib_internal_presets(struct qib_devdata *dd)\r\n{\r\nint ret = 0;\r\nret = set_dds_vals(dd, dds_init_vals + DDS_3M);\r\nif (ret < 0)\r\nqib_dev_err(dd, "Failed to set default DDS values\n");\r\nret = set_rxeq_vals(dd, qib_rxeq_set & 3);\r\nif (ret < 0)\r\nqib_dev_err(dd, "Failed to set default RXEQ values\n");\r\nreturn ret;\r\n}\r\nint qib_sd7220_presets(struct qib_devdata *dd)\r\n{\r\nint ret = 0;\r\nif (!dd->cspec->presets_needed)\r\nreturn ret;\r\ndd->cspec->presets_needed = 0;\r\nqib_ibsd_reset(dd, 1);\r\nudelay(2);\r\nqib_sd_trimdone_monitor(dd, "link-down");\r\nret = qib_internal_presets(dd);\r\nreturn ret;\r\n}\r\nstatic int qib_sd_trimself(struct qib_devdata *dd, int val)\r\n{\r\nint loc = CMUCTRL5 | (1U << EPB_IB_QUAD0_CS_SHF);\r\nreturn qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, val, 0xFF);\r\n}\r\nstatic int qib_sd_early(struct qib_devdata *dd)\r\n{\r\nint ret;\r\nret = ibsd_mod_allchnls(dd, RXHSCTRL0(0) | EPB_GLOBAL_WR, 0xD4, 0xFF);\r\nif (ret < 0)\r\ngoto bail;\r\nret = ibsd_mod_allchnls(dd, START_EQ1(0) | EPB_GLOBAL_WR, 0x10, 0xFF);\r\nif (ret < 0)\r\ngoto bail;\r\nret = ibsd_mod_allchnls(dd, START_EQ2(0) | EPB_GLOBAL_WR, 0x30, 0xFF);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int qib_sd_dactrim(struct qib_devdata *dd)\r\n{\r\nint ret;\r\nret = ibsd_mod_allchnls(dd, VCDL_DAC2(0) | EPB_GLOBAL_WR, 0x2D, 0xFF);\r\nif (ret < 0)\r\ngoto bail;\r\nret = ibsd_mod_allchnls(dd, VCDL_CTRL2(0), 3, 0xF);\r\nif (ret < 0)\r\ngoto bail;\r\nret = ibsd_mod_allchnls(dd, BACTRL(0) | EPB_GLOBAL_WR, 0x40, 0xFF);\r\nif (ret < 0)\r\ngoto bail;\r\nret = ibsd_mod_allchnls(dd, LDOUTCTRL1(0) | EPB_GLOBAL_WR, 0x04, 0xFF);\r\nif (ret < 0)\r\ngoto bail;\r\nret = ibsd_mod_allchnls(dd, RXHSSTATUS(0) | EPB_GLOBAL_WR, 0x04, 0xFF);\r\nif (ret < 0)\r\ngoto bail;\r\nudelay(415);\r\nret = ibsd_mod_allchnls(dd, LDOUTCTRL1(0) | EPB_GLOBAL_WR, 0x00, 0xFF);\r\nbail:\r\nreturn ret;\r\n}\r\nvoid toggle_7220_rclkrls(struct qib_devdata *dd)\r\n{\r\nint loc = RXLSPPM(0) | EPB_GLOBAL_WR;\r\nint ret;\r\nret = ibsd_mod_allchnls(dd, loc, 0, 0x80);\r\nif (ret < 0)\r\nqib_dev_err(dd, "RCLKRLS failed to clear D7\n");\r\nelse {\r\nudelay(1);\r\nibsd_mod_allchnls(dd, loc, 0x80, 0x80);\r\n}\r\nudelay(1);\r\nret = ibsd_mod_allchnls(dd, loc, 0, 0x80);\r\nif (ret < 0)\r\nqib_dev_err(dd, "RCLKRLS failed to clear D7\n");\r\nelse {\r\nudelay(1);\r\nibsd_mod_allchnls(dd, loc, 0x80, 0x80);\r\n}\r\ndd->f_xgxs_reset(dd->pport);\r\n}\r\nvoid shutdown_7220_relock_poll(struct qib_devdata *dd)\r\n{\r\nif (dd->cspec->relock_timer_active)\r\ndel_timer_sync(&dd->cspec->relock_timer);\r\n}\r\nstatic void qib_run_relock(unsigned long opaque)\r\n{\r\nstruct qib_devdata *dd = (struct qib_devdata *)opaque;\r\nstruct qib_pportdata *ppd = dd->pport;\r\nstruct qib_chip_specific *cs = dd->cspec;\r\nint timeoff;\r\nif ((dd->flags & QIB_INITTED) && !(ppd->lflags &\r\n(QIBL_IB_AUTONEG_INPROG | QIBL_LINKINIT | QIBL_LINKARMED |\r\nQIBL_LINKACTIVE))) {\r\nif (qib_relock_by_timer) {\r\nif (!(ppd->lflags & QIBL_IB_LINK_DISABLED))\r\ntoggle_7220_rclkrls(dd);\r\n}\r\ntimeoff = cs->relock_interval << 1;\r\nif (timeoff > HZ)\r\ntimeoff = HZ;\r\ncs->relock_interval = timeoff;\r\n} else\r\ntimeoff = HZ;\r\nmod_timer(&cs->relock_timer, jiffies + timeoff);\r\n}\r\nvoid set_7220_relock_poll(struct qib_devdata *dd, int ibup)\r\n{\r\nstruct qib_chip_specific *cs = dd->cspec;\r\nif (ibup) {\r\nif (cs->relock_timer_active) {\r\ncs->relock_interval = HZ;\r\nmod_timer(&cs->relock_timer, jiffies + HZ);\r\n}\r\n} else {\r\nunsigned int timeout;\r\ntimeout = msecs_to_jiffies(RELOCK_FIRST_MS);\r\nif (timeout == 0)\r\ntimeout = 1;\r\nif (!cs->relock_timer_active) {\r\ncs->relock_timer_active = 1;\r\ninit_timer(&cs->relock_timer);\r\ncs->relock_timer.function = qib_run_relock;\r\ncs->relock_timer.data = (unsigned long) dd;\r\ncs->relock_interval = timeout;\r\ncs->relock_timer.expires = jiffies + timeout;\r\nadd_timer(&cs->relock_timer);\r\n} else {\r\ncs->relock_interval = timeout;\r\nmod_timer(&cs->relock_timer, jiffies + timeout);\r\n}\r\n}\r\n}
