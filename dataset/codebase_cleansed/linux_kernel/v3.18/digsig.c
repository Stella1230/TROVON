int integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,\r\nconst char *digest, int digestlen)\r\n{\r\nif (id >= INTEGRITY_KEYRING_MAX)\r\nreturn -EINVAL;\r\nif (!keyring[id]) {\r\nkeyring[id] =\r\nrequest_key(&key_type_keyring, keyring_name[id], NULL);\r\nif (IS_ERR(keyring[id])) {\r\nint err = PTR_ERR(keyring[id]);\r\npr_err("no %s keyring: %d\n", keyring_name[id], err);\r\nkeyring[id] = NULL;\r\nreturn err;\r\n}\r\n}\r\nswitch (sig[1]) {\r\ncase 1:\r\nreturn digsig_verify(keyring[id], sig + 1, siglen - 1,\r\ndigest, digestlen);\r\ncase 2:\r\nreturn asymmetric_verify(keyring[id], sig, siglen,\r\ndigest, digestlen);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nint integrity_init_keyring(const unsigned int id)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint err = 0;\r\nkeyring[id] = keyring_alloc(keyring_name[id], KUIDT_INIT(0),\r\nKGIDT_INIT(0), cred,\r\n((KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ |\r\nKEY_USR_WRITE | KEY_USR_SEARCH),\r\nKEY_ALLOC_NOT_IN_QUOTA, NULL);\r\nif (!IS_ERR(keyring[id]))\r\nset_bit(KEY_FLAG_TRUSTED_ONLY, &keyring[id]->flags);\r\nelse {\r\nerr = PTR_ERR(keyring[id]);\r\npr_info("Can't allocate %s keyring (%d)\n",\r\nkeyring_name[id], err);\r\nkeyring[id] = NULL;\r\n}\r\nreturn err;\r\n}
