static void prepare_low_power_mode(struct urb *urb,\r\nstruct bcm_interface_adapter *interface,\r\nstruct bcm_mini_adapter *ps_adapter,\r\nstruct bcm_mini_adapter *ad,\r\nstruct bcm_link_request *p_control_msg,\r\nbool *b_power_down_msg)\r\n{\r\nif (((p_control_msg->szData[0] == GO_TO_IDLE_MODE_PAYLOAD) &&\r\n(p_control_msg->szData[1] == TARGET_CAN_GO_TO_IDLE_MODE))) {\r\n*b_power_down_msg = TRUE;\r\nif (urb->status != STATUS_SUCCESS) {\r\nps_adapter->bPreparingForLowPowerMode = false;\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_TX, NEXT_SEND,\r\nDBG_LVL_ALL,\r\n"Idle Mode Request msg failed to reach to Modem");\r\nwake_up(&ps_adapter->lowpower_mode_wait_queue);\r\nStartInterruptUrb(interface);\r\nreturn;\r\n}\r\nif (ps_adapter->bDoSuspend == false) {\r\nps_adapter->IdleMode = TRUE;\r\nps_adapter->bPreparingForLowPowerMode = false;\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_TX, NEXT_SEND,\r\nDBG_LVL_ALL,\r\n"Host Entered in Idle Mode State...");\r\nwake_up(&ps_adapter->lowpower_mode_wait_queue);\r\n}\r\n} else if ((p_control_msg->Leader.Status == LINK_UP_CONTROL_REQ) &&\r\n(p_control_msg->szData[0] == LINK_UP_ACK) &&\r\n(p_control_msg->szData[1] == LINK_SHUTDOWN_REQ_FROM_FIRMWARE) &&\r\n(p_control_msg->szData[2] == SHUTDOWN_ACK_FROM_DRIVER)) {\r\nif (urb->status != STATUS_SUCCESS) {\r\nps_adapter->bPreparingForLowPowerMode = false;\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_TX, NEXT_SEND,\r\nDBG_LVL_ALL,\r\n"Shutdown Request Msg failed to reach to Modem");\r\nwake_up(&ps_adapter->lowpower_mode_wait_queue);\r\nStartInterruptUrb(interface);\r\nreturn;\r\n}\r\n*b_power_down_msg = TRUE;\r\nif (ps_adapter->bDoSuspend == false) {\r\nps_adapter->bShutStatus = TRUE;\r\nps_adapter->bPreparingForLowPowerMode = false;\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_TX, NEXT_SEND,\r\nDBG_LVL_ALL,\r\n"Host Entered in shutdown Mode State...");\r\nwake_up(&ps_adapter->lowpower_mode_wait_queue);\r\n}\r\n}\r\nif (ps_adapter->bDoSuspend && *b_power_down_msg) {\r\nBCM_DEBUG_PRINT(ad, DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,\r\n"Issuing the Bus suspend request to USB stack");\r\ninterface->bPreparingForBusSuspend = TRUE;\r\nschedule_work(&interface->usbSuspendWork);\r\n}\r\n}\r\nstatic void write_bulk_callback(struct urb *urb)\r\n{\r\nstruct bcm_usb_tcb *pTcb = (struct bcm_usb_tcb *)urb->context;\r\nstruct bcm_interface_adapter *psIntfAdapter = pTcb->psIntfAdapter;\r\nstruct bcm_link_request *pControlMsg =\r\n(struct bcm_link_request *)urb->transfer_buffer;\r\nstruct bcm_mini_adapter *psAdapter = psIntfAdapter->psAdapter;\r\nbool bpowerDownMsg = false;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif (unlikely(netif_msg_tx_done(Adapter)))\r\npr_info(PFX "%s: transmit status %d\n", Adapter->dev->name,\r\nurb->status);\r\nif (urb->status != STATUS_SUCCESS) {\r\nif (urb->status == -EPIPE) {\r\npsIntfAdapter->psAdapter->bEndPointHalted = TRUE;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, NEXT_SEND,\r\nDBG_LVL_ALL,\r\n"Tx URB has got cancelled. status :%d",\r\nurb->status);\r\n}\r\n}\r\npTcb->bUsed = false;\r\natomic_dec(&psIntfAdapter->uNumTcbUsed);\r\nif (TRUE == psAdapter->bPreparingForLowPowerMode) {\r\nprepare_low_power_mode(urb, psIntfAdapter, psAdapter, Adapter,\r\npControlMsg, &bpowerDownMsg);\r\n}\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\n}\r\nstatic struct bcm_usb_tcb *GetBulkOutTcb(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nstruct bcm_usb_tcb *pTcb = NULL;\r\nUINT index = 0;\r\nif ((atomic_read(&psIntfAdapter->uNumTcbUsed) < MAXIMUM_USB_TCB) &&\r\n(psIntfAdapter->psAdapter->StopAllXaction == false)) {\r\nindex = atomic_read(&psIntfAdapter->uCurrTcb);\r\npTcb = &psIntfAdapter->asUsbTcb[index];\r\npTcb->bUsed = TRUE;\r\npTcb->psIntfAdapter = psIntfAdapter;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_TX,\r\nNEXT_SEND, DBG_LVL_ALL,\r\n"Got Tx desc %d used %d",\r\nindex,\r\natomic_read(&psIntfAdapter->uNumTcbUsed));\r\nindex = (index + 1) % MAXIMUM_USB_TCB;\r\natomic_set(&psIntfAdapter->uCurrTcb, index);\r\natomic_inc(&psIntfAdapter->uNumTcbUsed);\r\n}\r\nreturn pTcb;\r\n}\r\nstatic int TransmitTcb(struct bcm_interface_adapter *psIntfAdapter,\r\nstruct bcm_usb_tcb *pTcb, PVOID data, int len)\r\n{\r\nstruct urb *urb = pTcb->urb;\r\nint retval = 0;\r\nurb->transfer_buffer = usb_alloc_coherent(psIntfAdapter->udev, len,\r\nGFP_ATOMIC, &urb->transfer_dma);\r\nif (!urb->transfer_buffer) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"Error allocating memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(urb->transfer_buffer, data, len);\r\nurb->transfer_buffer_length = len;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_TX, NEXT_SEND,\r\nDBG_LVL_ALL, "Sending Bulk out packet\n");\r\nif ((psIntfAdapter->psAdapter->chip_id == T3B) &&\r\n(psIntfAdapter->bHighSpeedDevice == TRUE)) {\r\nusb_fill_int_urb(urb, psIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut.bulk_out_pipe,\r\nurb->transfer_buffer, len, write_bulk_callback, pTcb,\r\npsIntfAdapter->sBulkOut.int_out_interval);\r\n} else {\r\nusb_fill_bulk_urb(urb, psIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut.bulk_out_pipe,\r\nurb->transfer_buffer, len, write_bulk_callback, pTcb);\r\n}\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif (false == psIntfAdapter->psAdapter->device_removed &&\r\nfalse == psIntfAdapter->psAdapter->bEndPointHalted &&\r\nfalse == psIntfAdapter->bSuspended &&\r\nfalse == psIntfAdapter->bPreparingForBusSuspend) {\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_TX,\r\nNEXT_SEND, DBG_LVL_ALL,\r\n"failed submitting write urb, error %d",\r\nretval);\r\nif (retval == -EPIPE) {\r\npsIntfAdapter->psAdapter->bEndPointHalted = TRUE;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nint InterfaceTransmitPacket(PVOID arg, PVOID data, UINT len)\r\n{\r\nstruct bcm_usb_tcb *pTcb = NULL;\r\nstruct bcm_interface_adapter *psIntfAdapter = arg;\r\npTcb = GetBulkOutTcb(psIntfAdapter);\r\nif (pTcb == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"No URB to transmit packet, dropping packet");\r\nreturn -EFAULT;\r\n}\r\nreturn TransmitTcb(psIntfAdapter, pTcb, data, len);\r\n}
