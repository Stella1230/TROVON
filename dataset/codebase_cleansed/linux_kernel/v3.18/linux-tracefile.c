int cfs_tracefile_init_arch(void)\r\n{\r\nint i;\r\nint j;\r\nstruct cfs_trace_cpu_data *tcd;\r\ninit_rwsem(&cfs_tracefile_sem);\r\nmemset(cfs_trace_data, 0, sizeof(cfs_trace_data));\r\nfor (i = 0; i < CFS_TCD_TYPE_MAX; i++) {\r\ncfs_trace_data[i] =\r\nkmalloc(sizeof(union cfs_trace_data_union) *\r\nnum_possible_cpus(), GFP_KERNEL);\r\nif (cfs_trace_data[i] == NULL)\r\ngoto out;\r\n}\r\ncfs_tcd_for_each(tcd, i, j) {\r\nspin_lock_init(&tcd->tcd_lock);\r\ntcd->tcd_pages_factor = pages_factor[i];\r\ntcd->tcd_type = i;\r\ntcd->tcd_cpu = j;\r\n}\r\nfor (i = 0; i < num_possible_cpus(); i++)\r\nfor (j = 0; j < 3; j++) {\r\ncfs_trace_console_buffers[i][j] =\r\nkmalloc(CFS_TRACE_CONSOLE_BUFFER_SIZE,\r\nGFP_KERNEL);\r\nif (cfs_trace_console_buffers[i][j] == NULL)\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\ncfs_tracefile_fini_arch();\r\nprintk(KERN_ERR "lnet: Not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nvoid cfs_tracefile_fini_arch(void)\r\n{\r\nint i;\r\nint j;\r\nfor (i = 0; i < num_possible_cpus(); i++)\r\nfor (j = 0; j < 3; j++)\r\nif (cfs_trace_console_buffers[i][j] != NULL) {\r\nkfree(cfs_trace_console_buffers[i][j]);\r\ncfs_trace_console_buffers[i][j] = NULL;\r\n}\r\nfor (i = 0; cfs_trace_data[i] != NULL; i++) {\r\nkfree(cfs_trace_data[i]);\r\ncfs_trace_data[i] = NULL;\r\n}\r\n}\r\nvoid cfs_tracefile_read_lock(void)\r\n{\r\ndown_read(&cfs_tracefile_sem);\r\n}\r\nvoid cfs_tracefile_read_unlock(void)\r\n{\r\nup_read(&cfs_tracefile_sem);\r\n}\r\nvoid cfs_tracefile_write_lock(void)\r\n{\r\ndown_write(&cfs_tracefile_sem);\r\n}\r\nvoid cfs_tracefile_write_unlock(void)\r\n{\r\nup_write(&cfs_tracefile_sem);\r\n}\r\ncfs_trace_buf_type_t cfs_trace_buf_idx_get(void)\r\n{\r\nif (in_irq())\r\nreturn CFS_TCD_TYPE_IRQ;\r\nelse if (in_softirq())\r\nreturn CFS_TCD_TYPE_SOFTIRQ;\r\nelse\r\nreturn CFS_TCD_TYPE_PROC;\r\n}\r\nint cfs_trace_lock_tcd(struct cfs_trace_cpu_data *tcd, int walking)\r\n{\r\n__LASSERT(tcd->tcd_type < CFS_TCD_TYPE_MAX);\r\nif (tcd->tcd_type == CFS_TCD_TYPE_IRQ)\r\nspin_lock_irqsave(&tcd->tcd_lock, tcd->tcd_lock_flags);\r\nelse if (tcd->tcd_type == CFS_TCD_TYPE_SOFTIRQ)\r\nspin_lock_bh(&tcd->tcd_lock);\r\nelse if (unlikely(walking))\r\nspin_lock_irq(&tcd->tcd_lock);\r\nelse\r\nspin_lock(&tcd->tcd_lock);\r\nreturn 1;\r\n}\r\nvoid cfs_trace_unlock_tcd(struct cfs_trace_cpu_data *tcd, int walking)\r\n{\r\n__LASSERT(tcd->tcd_type < CFS_TCD_TYPE_MAX);\r\nif (tcd->tcd_type == CFS_TCD_TYPE_IRQ)\r\nspin_unlock_irqrestore(&tcd->tcd_lock, tcd->tcd_lock_flags);\r\nelse if (tcd->tcd_type == CFS_TCD_TYPE_SOFTIRQ)\r\nspin_unlock_bh(&tcd->tcd_lock);\r\nelse if (unlikely(walking))\r\nspin_unlock_irq(&tcd->tcd_lock);\r\nelse\r\nspin_unlock(&tcd->tcd_lock);\r\n}\r\nint cfs_tcd_owns_tage(struct cfs_trace_cpu_data *tcd,\r\nstruct cfs_trace_page *tage)\r\n{\r\nreturn tcd->tcd_cpu == tage->cpu;\r\n}\r\nvoid\r\ncfs_set_ptldebug_header(struct ptldebug_header *header,\r\nstruct libcfs_debug_msg_data *msgdata,\r\nunsigned long stack)\r\n{\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nheader->ph_subsys = msgdata->msg_subsys;\r\nheader->ph_mask = msgdata->msg_mask;\r\nheader->ph_cpu_id = smp_processor_id();\r\nheader->ph_type = cfs_trace_buf_idx_get();\r\nheader->ph_sec = (__u32)tv.tv_sec;\r\nheader->ph_usec = tv.tv_usec;\r\nheader->ph_stack = stack;\r\nheader->ph_pid = current->pid;\r\nheader->ph_line_num = msgdata->msg_line;\r\nheader->ph_extern_pid = 0;\r\nreturn;\r\n}\r\nstatic char *\r\ndbghdr_to_err_string(struct ptldebug_header *hdr)\r\n{\r\nswitch (hdr->ph_subsys) {\r\ncase S_LND:\r\ncase S_LNET:\r\nreturn "LNetError";\r\ndefault:\r\nreturn "LustreError";\r\n}\r\n}\r\nstatic char *\r\ndbghdr_to_info_string(struct ptldebug_header *hdr)\r\n{\r\nswitch (hdr->ph_subsys) {\r\ncase S_LND:\r\ncase S_LNET:\r\nreturn "LNet";\r\ndefault:\r\nreturn "Lustre";\r\n}\r\n}\r\nvoid cfs_print_to_console(struct ptldebug_header *hdr, int mask,\r\nconst char *buf, int len, const char *file,\r\nconst char *fn)\r\n{\r\nchar *prefix = "Lustre", *ptype = NULL;\r\nif ((mask & D_EMERG) != 0) {\r\nprefix = dbghdr_to_err_string(hdr);\r\nptype = KERN_EMERG;\r\n} else if ((mask & D_ERROR) != 0) {\r\nprefix = dbghdr_to_err_string(hdr);\r\nptype = KERN_ERR;\r\n} else if ((mask & D_WARNING) != 0) {\r\nprefix = dbghdr_to_info_string(hdr);\r\nptype = KERN_WARNING;\r\n} else if ((mask & (D_CONSOLE | libcfs_printk)) != 0) {\r\nprefix = dbghdr_to_info_string(hdr);\r\nptype = KERN_INFO;\r\n}\r\nif ((mask & D_CONSOLE) != 0) {\r\nprintk("%s%s: %.*s", ptype, prefix, len, buf);\r\n} else {\r\nprintk("%s%s: %d:%d:(%s:%d:%s()) %.*s", ptype, prefix,\r\nhdr->ph_pid, hdr->ph_extern_pid, file, hdr->ph_line_num,\r\nfn, len, buf);\r\n}\r\nreturn;\r\n}\r\nint cfs_trace_max_debug_mb(void)\r\n{\r\nint total_mb = (totalram_pages >> (20 - PAGE_SHIFT));\r\nreturn MAX(512, (total_mb * 80)/100);\r\n}
