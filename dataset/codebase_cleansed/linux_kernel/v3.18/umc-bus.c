static int umc_bus_pre_reset_helper(struct device *dev, void *data)\r\n{\r\nint ret = 0;\r\nif (dev->driver) {\r\nstruct umc_dev *umc = to_umc_dev(dev);\r\nstruct umc_driver *umc_drv = to_umc_driver(dev->driver);\r\nif (umc_drv->pre_reset)\r\nret = umc_drv->pre_reset(umc);\r\nelse\r\ndevice_release_driver(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int umc_bus_post_reset_helper(struct device *dev, void *data)\r\n{\r\nint ret = 0;\r\nif (dev->driver) {\r\nstruct umc_dev *umc = to_umc_dev(dev);\r\nstruct umc_driver *umc_drv = to_umc_driver(dev->driver);\r\nif (umc_drv->post_reset)\r\nret = umc_drv->post_reset(umc);\r\n} else\r\nret = device_attach(dev);\r\nreturn ret;\r\n}\r\nint umc_controller_reset(struct umc_dev *umc)\r\n{\r\nstruct device *parent = umc->dev.parent;\r\nint ret = 0;\r\nif (!device_trylock(parent))\r\nreturn -EAGAIN;\r\nret = device_for_each_child(parent, parent, umc_bus_pre_reset_helper);\r\nif (ret >= 0)\r\nret = device_for_each_child(parent, parent, umc_bus_post_reset_helper);\r\ndevice_unlock(parent);\r\nreturn ret;\r\n}\r\nint umc_match_pci_id(struct umc_driver *umc_drv, struct umc_dev *umc)\r\n{\r\nconst struct pci_device_id *id_table = umc_drv->match_data;\r\nstruct pci_dev *pci;\r\nif (!dev_is_pci(umc->dev.parent))\r\nreturn 0;\r\npci = to_pci_dev(umc->dev.parent);\r\nreturn pci_match_id(id_table, pci) != NULL;\r\n}\r\nstatic int umc_bus_rescan_helper(struct device *dev, void *data)\r\n{\r\nint ret = 0;\r\nif (!dev->driver)\r\nret = device_attach(dev);\r\nreturn ret;\r\n}\r\nstatic void umc_bus_rescan(struct device *parent)\r\n{\r\nint err;\r\nerr = device_for_each_child(parent, NULL, umc_bus_rescan_helper);\r\nif (err < 0)\r\nprintk(KERN_WARNING "%s: rescan of bus failed: %d\n",\r\nKBUILD_MODNAME, err);\r\n}\r\nstatic int umc_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct umc_dev *umc = to_umc_dev(dev);\r\nstruct umc_driver *umc_driver = to_umc_driver(drv);\r\nif (umc->cap_id == umc_driver->cap_id) {\r\nif (umc_driver->match)\r\nreturn umc_driver->match(umc_driver, umc);\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int umc_device_probe(struct device *dev)\r\n{\r\nstruct umc_dev *umc;\r\nstruct umc_driver *umc_driver;\r\nint err;\r\numc_driver = to_umc_driver(dev->driver);\r\numc = to_umc_dev(dev);\r\nget_device(dev);\r\nerr = umc_driver->probe(umc);\r\nif (err)\r\nput_device(dev);\r\nelse\r\numc_bus_rescan(dev->parent);\r\nreturn err;\r\n}\r\nstatic int umc_device_remove(struct device *dev)\r\n{\r\nstruct umc_dev *umc;\r\nstruct umc_driver *umc_driver;\r\numc_driver = to_umc_driver(dev->driver);\r\numc = to_umc_dev(dev);\r\numc_driver->remove(umc);\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic int umc_device_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct umc_dev *umc;\r\nstruct umc_driver *umc_driver;\r\nint err = 0;\r\numc = to_umc_dev(dev);\r\nif (dev->driver) {\r\numc_driver = to_umc_driver(dev->driver);\r\nif (umc_driver->suspend)\r\nerr = umc_driver->suspend(umc, state);\r\n}\r\nreturn err;\r\n}\r\nstatic int umc_device_resume(struct device *dev)\r\n{\r\nstruct umc_dev *umc;\r\nstruct umc_driver *umc_driver;\r\nint err = 0;\r\numc = to_umc_dev(dev);\r\nif (dev->driver) {\r\numc_driver = to_umc_driver(dev->driver);\r\nif (umc_driver->resume)\r\nerr = umc_driver->resume(umc);\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t capability_id_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct umc_dev *umc = to_umc_dev(dev);\r\nreturn sprintf(buf, "0x%02x\n", umc->cap_id);\r\n}\r\nstatic ssize_t version_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct umc_dev *umc = to_umc_dev(dev);\r\nreturn sprintf(buf, "0x%04x\n", umc->version);\r\n}\r\nstatic int __init umc_bus_init(void)\r\n{\r\nreturn bus_register(&umc_bus_type);\r\n}\r\nstatic void __exit umc_bus_exit(void)\r\n{\r\nbus_unregister(&umc_bus_type);\r\n}
