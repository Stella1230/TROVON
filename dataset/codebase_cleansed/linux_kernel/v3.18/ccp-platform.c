static int ccp_get_irq(struct ccp_device *ccp)\r\n{\r\nstruct device *dev = ccp->dev;\r\nstruct platform_device *pdev = container_of(dev,\r\nstruct platform_device, dev);\r\nint ret;\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nccp->irq = ret;\r\nret = request_irq(ccp->irq, ccp_irq_handler, 0, "ccp", dev);\r\nif (ret) {\r\ndev_notice(dev, "unable to allocate IRQ (%d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ccp_get_irqs(struct ccp_device *ccp)\r\n{\r\nstruct device *dev = ccp->dev;\r\nint ret;\r\nret = ccp_get_irq(ccp);\r\nif (!ret)\r\nreturn 0;\r\ndev_notice(dev, "could not enable interrupts (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic void ccp_free_irqs(struct ccp_device *ccp)\r\n{\r\nstruct device *dev = ccp->dev;\r\nfree_irq(ccp->irq, dev);\r\n}\r\nstatic struct resource *ccp_find_mmio_area(struct ccp_device *ccp)\r\n{\r\nstruct device *dev = ccp->dev;\r\nstruct platform_device *pdev = container_of(dev,\r\nstruct platform_device, dev);\r\nstruct resource *ior;\r\nior = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (ior && (resource_size(ior) >= 0x800))\r\nreturn ior;\r\nreturn NULL;\r\n}\r\nstatic int ccp_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct ccp_device *ccp;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *ior;\r\nint ret;\r\nret = -ENOMEM;\r\nccp = ccp_alloc_struct(dev);\r\nif (!ccp)\r\ngoto e_err;\r\nccp->dev_specific = NULL;\r\nccp->get_irq = ccp_get_irqs;\r\nccp->free_irq = ccp_free_irqs;\r\nior = ccp_find_mmio_area(ccp);\r\nccp->io_map = devm_ioremap_resource(dev, ior);\r\nif (IS_ERR(ccp->io_map)) {\r\nret = PTR_ERR(ccp->io_map);\r\ngoto e_free;\r\n}\r\nccp->io_regs = ccp->io_map;\r\nif (!dev->dma_mask)\r\ndev->dma_mask = &dev->coherent_dma_mask;\r\n*(dev->dma_mask) = DMA_BIT_MASK(48);\r\ndev->coherent_dma_mask = DMA_BIT_MASK(48);\r\nif (of_property_read_bool(dev->of_node, "dma-coherent"))\r\nccp->axcache = CACHE_WB_NO_ALLOC;\r\nelse\r\nccp->axcache = CACHE_NONE;\r\ndev_set_drvdata(dev, ccp);\r\nret = ccp_init(ccp);\r\nif (ret)\r\ngoto e_free;\r\ndev_notice(dev, "enabled\n");\r\nreturn 0;\r\ne_free:\r\nkfree(ccp);\r\ne_err:\r\ndev_notice(dev, "initialization failed\n");\r\nreturn ret;\r\n}\r\nstatic int ccp_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ccp_device *ccp = dev_get_drvdata(dev);\r\nccp_destroy(ccp);\r\nkfree(ccp);\r\ndev_notice(dev, "disabled\n");\r\nreturn 0;\r\n}\r\nstatic int ccp_platform_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ccp_device *ccp = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&ccp->cmd_lock, flags);\r\nccp->suspending = 1;\r\nfor (i = 0; i < ccp->cmd_q_count; i++)\r\nwake_up_process(ccp->cmd_q[i].kthread);\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nwhile (!ccp_queues_suspended(ccp))\r\nwait_event_interruptible(ccp->suspend_queue,\r\nccp_queues_suspended(ccp));\r\nreturn 0;\r\n}\r\nstatic int ccp_platform_resume(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ccp_device *ccp = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&ccp->cmd_lock, flags);\r\nccp->suspending = 0;\r\nfor (i = 0; i < ccp->cmd_q_count; i++) {\r\nccp->cmd_q[i].suspended = 0;\r\nwake_up_process(ccp->cmd_q[i].kthread);\r\n}\r\nspin_unlock_irqrestore(&ccp->cmd_lock, flags);\r\nreturn 0;\r\n}\r\nint ccp_platform_init(void)\r\n{\r\nreturn platform_driver_register(&ccp_platform_driver);\r\n}\r\nvoid ccp_platform_exit(void)\r\n{\r\nplatform_driver_unregister(&ccp_platform_driver);\r\n}
