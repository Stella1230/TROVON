static void ads7846_stop(struct ads7846 *ts)\r\n{\r\nif (!ts->disabled && !ts->suspended) {\r\nts->stopped = true;\r\nmb();\r\nwake_up(&ts->wait);\r\ndisable_irq(ts->spi->irq);\r\n}\r\n}\r\nstatic void ads7846_restart(struct ads7846 *ts)\r\n{\r\nif (!ts->disabled && !ts->suspended) {\r\nts->stopped = false;\r\nmb();\r\nenable_irq(ts->spi->irq);\r\n}\r\n}\r\nstatic void __ads7846_disable(struct ads7846 *ts)\r\n{\r\nads7846_stop(ts);\r\nregulator_disable(ts->reg);\r\n}\r\nstatic void __ads7846_enable(struct ads7846 *ts)\r\n{\r\nint error;\r\nerror = regulator_enable(ts->reg);\r\nif (error != 0)\r\ndev_err(&ts->spi->dev, "Failed to enable supply: %d\n", error);\r\nads7846_restart(ts);\r\n}\r\nstatic void ads7846_disable(struct ads7846 *ts)\r\n{\r\nmutex_lock(&ts->lock);\r\nif (!ts->disabled) {\r\nif (!ts->suspended)\r\n__ads7846_disable(ts);\r\nts->disabled = true;\r\n}\r\nmutex_unlock(&ts->lock);\r\n}\r\nstatic void ads7846_enable(struct ads7846 *ts)\r\n{\r\nmutex_lock(&ts->lock);\r\nif (ts->disabled) {\r\nts->disabled = false;\r\nif (!ts->suspended)\r\n__ads7846_enable(ts);\r\n}\r\nmutex_unlock(&ts->lock);\r\n}\r\nstatic int ads7846_read12_ser(struct device *dev, unsigned command)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct ads7846 *ts = dev_get_drvdata(dev);\r\nstruct ser_req *req;\r\nint status;\r\nreq = kzalloc(sizeof *req, GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nspi_message_init(&req->msg);\r\nif (ts->use_internal) {\r\nreq->ref_on = REF_ON;\r\nreq->xfer[0].tx_buf = &req->ref_on;\r\nreq->xfer[0].len = 1;\r\nspi_message_add_tail(&req->xfer[0], &req->msg);\r\nreq->xfer[1].rx_buf = &req->scratch;\r\nreq->xfer[1].len = 2;\r\nreq->xfer[1].delay_usecs = ts->vref_delay_usecs;\r\nspi_message_add_tail(&req->xfer[1], &req->msg);\r\ncommand |= ADS_PD10_REF_ON;\r\n}\r\ncommand |= ADS_PD10_ADC_ON;\r\nreq->command = (u8) command;\r\nreq->xfer[2].tx_buf = &req->command;\r\nreq->xfer[2].len = 1;\r\nspi_message_add_tail(&req->xfer[2], &req->msg);\r\nreq->xfer[3].rx_buf = &req->sample;\r\nreq->xfer[3].len = 2;\r\nspi_message_add_tail(&req->xfer[3], &req->msg);\r\nreq->ref_off = PWRDOWN;\r\nreq->xfer[4].tx_buf = &req->ref_off;\r\nreq->xfer[4].len = 1;\r\nspi_message_add_tail(&req->xfer[4], &req->msg);\r\nreq->xfer[5].rx_buf = &req->scratch;\r\nreq->xfer[5].len = 2;\r\nCS_CHANGE(req->xfer[5]);\r\nspi_message_add_tail(&req->xfer[5], &req->msg);\r\nmutex_lock(&ts->lock);\r\nads7846_stop(ts);\r\nstatus = spi_sync(spi, &req->msg);\r\nads7846_restart(ts);\r\nmutex_unlock(&ts->lock);\r\nif (status == 0) {\r\nstatus = be16_to_cpu(req->sample);\r\nstatus = status >> 3;\r\nstatus &= 0x0fff;\r\n}\r\nkfree(req);\r\nreturn status;\r\n}\r\nstatic int ads7845_read12_ser(struct device *dev, unsigned command)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct ads7846 *ts = dev_get_drvdata(dev);\r\nstruct ads7845_ser_req *req;\r\nint status;\r\nreq = kzalloc(sizeof *req, GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nspi_message_init(&req->msg);\r\nreq->command[0] = (u8) command;\r\nreq->xfer[0].tx_buf = req->command;\r\nreq->xfer[0].rx_buf = req->sample;\r\nreq->xfer[0].len = 3;\r\nspi_message_add_tail(&req->xfer[0], &req->msg);\r\nmutex_lock(&ts->lock);\r\nads7846_stop(ts);\r\nstatus = spi_sync(spi, &req->msg);\r\nads7846_restart(ts);\r\nmutex_unlock(&ts->lock);\r\nif (status == 0) {\r\nstatus = be16_to_cpu(*((u16 *)&req->sample[1]));\r\nstatus = status >> 3;\r\nstatus &= 0x0fff;\r\n}\r\nkfree(req);\r\nreturn status;\r\n}\r\nstatic inline unsigned null_adjust(struct ads7846 *ts, ssize_t v)\r\n{\r\nreturn v;\r\n}\r\nstatic inline unsigned vaux_adjust(struct ads7846 *ts, ssize_t v)\r\n{\r\nunsigned retval = v;\r\nretval *= ts->vref_mv;\r\nretval = retval >> 12;\r\nreturn retval;\r\n}\r\nstatic inline unsigned vbatt_adjust(struct ads7846 *ts, ssize_t v)\r\n{\r\nunsigned retval = vaux_adjust(ts, v);\r\nif (ts->model == 7846)\r\nretval *= 4;\r\nreturn retval;\r\n}\r\nstatic umode_t ads7846_is_visible(struct kobject *kobj, struct attribute *attr,\r\nint index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct ads7846 *ts = dev_get_drvdata(dev);\r\nif (ts->model == 7843 && index < 2)\r\nreturn 0;\r\nif (ts->model == 7845 && index != 2)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic int ads784x_hwmon_register(struct spi_device *spi, struct ads7846 *ts)\r\n{\r\nswitch (ts->model) {\r\ncase 7846:\r\nif (!ts->vref_mv) {\r\ndev_dbg(&spi->dev, "assuming 2.5V internal vREF\n");\r\nts->vref_mv = 2500;\r\nts->use_internal = true;\r\n}\r\nbreak;\r\ncase 7845:\r\ncase 7843:\r\nif (!ts->vref_mv) {\r\ndev_warn(&spi->dev,\r\n"external vREF for ADS%d not specified\n",\r\nts->model);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nts->hwmon = hwmon_device_register_with_groups(&spi->dev, spi->modalias,\r\nts, ads7846_attr_groups);\r\nif (IS_ERR(ts->hwmon))\r\nreturn PTR_ERR(ts->hwmon);\r\nreturn 0;\r\n}\r\nstatic void ads784x_hwmon_unregister(struct spi_device *spi,\r\nstruct ads7846 *ts)\r\n{\r\nif (ts->hwmon)\r\nhwmon_device_unregister(ts->hwmon);\r\n}\r\nstatic inline int ads784x_hwmon_register(struct spi_device *spi,\r\nstruct ads7846 *ts)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void ads784x_hwmon_unregister(struct spi_device *spi,\r\nstruct ads7846 *ts)\r\n{\r\n}\r\nstatic ssize_t ads7846_pen_down_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ads7846 *ts = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", ts->pendown);\r\n}\r\nstatic ssize_t ads7846_disable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ads7846 *ts = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", ts->disabled);\r\n}\r\nstatic ssize_t ads7846_disable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ads7846 *ts = dev_get_drvdata(dev);\r\nunsigned int i;\r\nint err;\r\nerr = kstrtouint(buf, 10, &i);\r\nif (err)\r\nreturn err;\r\nif (i)\r\nads7846_disable(ts);\r\nelse\r\nads7846_enable(ts);\r\nreturn count;\r\n}\r\nstatic int get_pendown_state(struct ads7846 *ts)\r\n{\r\nif (ts->get_pendown_state)\r\nreturn ts->get_pendown_state();\r\nreturn !gpio_get_value(ts->gpio_pendown);\r\n}\r\nstatic void null_wait_for_sync(void)\r\n{\r\n}\r\nstatic int ads7846_debounce_filter(void *ads, int data_idx, int *val)\r\n{\r\nstruct ads7846 *ts = ads;\r\nif (!ts->read_cnt || (abs(ts->last_read - *val) > ts->debounce_tol)) {\r\nts->read_rep = 0;\r\nif (ts->read_cnt < ts->debounce_max) {\r\nts->last_read = *val;\r\nts->read_cnt++;\r\nreturn ADS7846_FILTER_REPEAT;\r\n} else {\r\nts->read_cnt = 0;\r\nreturn ADS7846_FILTER_IGNORE;\r\n}\r\n} else {\r\nif (++ts->read_rep > ts->debounce_rep) {\r\nts->read_cnt = 0;\r\nts->read_rep = 0;\r\nreturn ADS7846_FILTER_OK;\r\n} else {\r\nts->read_cnt++;\r\nreturn ADS7846_FILTER_REPEAT;\r\n}\r\n}\r\n}\r\nstatic int ads7846_no_filter(void *ads, int data_idx, int *val)\r\n{\r\nreturn ADS7846_FILTER_OK;\r\n}\r\nstatic int ads7846_get_value(struct ads7846 *ts, struct spi_message *m)\r\n{\r\nstruct spi_transfer *t =\r\nlist_entry(m->transfers.prev, struct spi_transfer, transfer_list);\r\nif (ts->model == 7845) {\r\nreturn be16_to_cpup((__be16 *)&(((char*)t->rx_buf)[1])) >> 3;\r\n} else {\r\nreturn be16_to_cpup((__be16 *)t->rx_buf) >> 3;\r\n}\r\n}\r\nstatic void ads7846_update_value(struct spi_message *m, int val)\r\n{\r\nstruct spi_transfer *t =\r\nlist_entry(m->transfers.prev, struct spi_transfer, transfer_list);\r\n*(u16 *)t->rx_buf = val;\r\n}\r\nstatic void ads7846_read_state(struct ads7846 *ts)\r\n{\r\nstruct ads7846_packet *packet = ts->packet;\r\nstruct spi_message *m;\r\nint msg_idx = 0;\r\nint val;\r\nint action;\r\nint error;\r\nwhile (msg_idx < ts->msg_count) {\r\nts->wait_for_sync();\r\nm = &ts->msg[msg_idx];\r\nerror = spi_sync(ts->spi, m);\r\nif (error) {\r\ndev_err(&ts->spi->dev, "spi_sync --> %d\n", error);\r\npacket->tc.ignore = true;\r\nreturn;\r\n}\r\nif (msg_idx < ts->msg_count - 1) {\r\nval = ads7846_get_value(ts, m);\r\naction = ts->filter(ts->filter_data, msg_idx, &val);\r\nswitch (action) {\r\ncase ADS7846_FILTER_REPEAT:\r\ncontinue;\r\ncase ADS7846_FILTER_IGNORE:\r\npacket->tc.ignore = true;\r\nmsg_idx = ts->msg_count - 1;\r\ncontinue;\r\ncase ADS7846_FILTER_OK:\r\nads7846_update_value(m, val);\r\npacket->tc.ignore = false;\r\nmsg_idx++;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n} else {\r\nmsg_idx++;\r\n}\r\n}\r\n}\r\nstatic void ads7846_report_state(struct ads7846 *ts)\r\n{\r\nstruct ads7846_packet *packet = ts->packet;\r\nunsigned int Rt;\r\nu16 x, y, z1, z2;\r\nif (ts->model == 7845) {\r\nx = *(u16 *)packet->tc.x_buf;\r\ny = *(u16 *)packet->tc.y_buf;\r\nz1 = 0;\r\nz2 = 0;\r\n} else {\r\nx = packet->tc.x;\r\ny = packet->tc.y;\r\nz1 = packet->tc.z1;\r\nz2 = packet->tc.z2;\r\n}\r\nif (x == MAX_12BIT)\r\nx = 0;\r\nif (ts->model == 7843) {\r\nRt = ts->pressure_max / 2;\r\n} else if (ts->model == 7845) {\r\nif (get_pendown_state(ts))\r\nRt = ts->pressure_max / 2;\r\nelse\r\nRt = 0;\r\ndev_vdbg(&ts->spi->dev, "x/y: %d/%d, PD %d\n", x, y, Rt);\r\n} else if (likely(x && z1)) {\r\nRt = z2;\r\nRt -= z1;\r\nRt *= x;\r\nRt *= ts->x_plate_ohms;\r\nRt /= z1;\r\nRt = (Rt + 2047) >> 12;\r\n} else {\r\nRt = 0;\r\n}\r\nif (packet->tc.ignore || Rt > ts->pressure_max) {\r\ndev_vdbg(&ts->spi->dev, "ignored %d pressure %d\n",\r\npacket->tc.ignore, Rt);\r\nreturn;\r\n}\r\nif (ts->penirq_recheck_delay_usecs) {\r\nudelay(ts->penirq_recheck_delay_usecs);\r\nif (!get_pendown_state(ts))\r\nRt = 0;\r\n}\r\nif (Rt) {\r\nstruct input_dev *input = ts->input;\r\nif (ts->swap_xy)\r\nswap(x, y);\r\nif (!ts->pendown) {\r\ninput_report_key(input, BTN_TOUCH, 1);\r\nts->pendown = true;\r\ndev_vdbg(&ts->spi->dev, "DOWN\n");\r\n}\r\ninput_report_abs(input, ABS_X, x);\r\ninput_report_abs(input, ABS_Y, y);\r\ninput_report_abs(input, ABS_PRESSURE, ts->pressure_max - Rt);\r\ninput_sync(input);\r\ndev_vdbg(&ts->spi->dev, "%4d/%4d/%4d\n", x, y, Rt);\r\n}\r\n}\r\nstatic irqreturn_t ads7846_hard_irq(int irq, void *handle)\r\n{\r\nstruct ads7846 *ts = handle;\r\nreturn get_pendown_state(ts) ? IRQ_WAKE_THREAD : IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ads7846_irq(int irq, void *handle)\r\n{\r\nstruct ads7846 *ts = handle;\r\nmsleep(TS_POLL_DELAY);\r\nwhile (!ts->stopped && get_pendown_state(ts)) {\r\nads7846_read_state(ts);\r\nif (!ts->stopped)\r\nads7846_report_state(ts);\r\nwait_event_timeout(ts->wait, ts->stopped,\r\nmsecs_to_jiffies(TS_POLL_PERIOD));\r\n}\r\nif (ts->pendown) {\r\nstruct input_dev *input = ts->input;\r\ninput_report_key(input, BTN_TOUCH, 0);\r\ninput_report_abs(input, ABS_PRESSURE, 0);\r\ninput_sync(input);\r\nts->pendown = false;\r\ndev_vdbg(&ts->spi->dev, "UP\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ads7846_suspend(struct device *dev)\r\n{\r\nstruct ads7846 *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->lock);\r\nif (!ts->suspended) {\r\nif (!ts->disabled)\r\n__ads7846_disable(ts);\r\nif (device_may_wakeup(&ts->spi->dev))\r\nenable_irq_wake(ts->spi->irq);\r\nts->suspended = true;\r\n}\r\nmutex_unlock(&ts->lock);\r\nreturn 0;\r\n}\r\nstatic int ads7846_resume(struct device *dev)\r\n{\r\nstruct ads7846 *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->lock);\r\nif (ts->suspended) {\r\nts->suspended = false;\r\nif (device_may_wakeup(&ts->spi->dev))\r\ndisable_irq_wake(ts->spi->irq);\r\nif (!ts->disabled)\r\n__ads7846_enable(ts);\r\n}\r\nmutex_unlock(&ts->lock);\r\nreturn 0;\r\n}\r\nstatic int ads7846_setup_pendown(struct spi_device *spi,\r\nstruct ads7846 *ts,\r\nconst struct ads7846_platform_data *pdata)\r\n{\r\nint err;\r\nif (pdata->get_pendown_state) {\r\nts->get_pendown_state = pdata->get_pendown_state;\r\n} else if (gpio_is_valid(pdata->gpio_pendown)) {\r\nerr = gpio_request_one(pdata->gpio_pendown, GPIOF_IN,\r\n"ads7846_pendown");\r\nif (err) {\r\ndev_err(&spi->dev,\r\n"failed to request/setup pendown GPIO%d: %d\n",\r\npdata->gpio_pendown, err);\r\nreturn err;\r\n}\r\nts->gpio_pendown = pdata->gpio_pendown;\r\nif (pdata->gpio_pendown_debounce)\r\ngpio_set_debounce(pdata->gpio_pendown,\r\npdata->gpio_pendown_debounce);\r\n} else {\r\ndev_err(&spi->dev, "no get_pendown_state nor gpio_pendown?\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ads7846_setup_spi_msg(struct ads7846 *ts,\r\nconst struct ads7846_platform_data *pdata)\r\n{\r\nstruct spi_message *m = &ts->msg[0];\r\nstruct spi_transfer *x = ts->xfer;\r\nstruct ads7846_packet *packet = ts->packet;\r\nint vref = pdata->keep_vref_on;\r\nif (ts->model == 7873) {\r\nts->model = 7846;\r\nvref = 0;\r\n}\r\nts->msg_count = 1;\r\nspi_message_init(m);\r\nm->context = ts;\r\nif (ts->model == 7845) {\r\npacket->read_y_cmd[0] = READ_Y(vref);\r\npacket->read_y_cmd[1] = 0;\r\npacket->read_y_cmd[2] = 0;\r\nx->tx_buf = &packet->read_y_cmd[0];\r\nx->rx_buf = &packet->tc.y_buf[0];\r\nx->len = 3;\r\nspi_message_add_tail(x, m);\r\n} else {\r\npacket->read_y = READ_Y(vref);\r\nx->tx_buf = &packet->read_y;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->tc.y;\r\nx->len = 2;\r\nspi_message_add_tail(x, m);\r\n}\r\nif (pdata->settle_delay_usecs) {\r\nx->delay_usecs = pdata->settle_delay_usecs;\r\nx++;\r\nx->tx_buf = &packet->read_y;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->tc.y;\r\nx->len = 2;\r\nspi_message_add_tail(x, m);\r\n}\r\nts->msg_count++;\r\nm++;\r\nspi_message_init(m);\r\nm->context = ts;\r\nif (ts->model == 7845) {\r\nx++;\r\npacket->read_x_cmd[0] = READ_X(vref);\r\npacket->read_x_cmd[1] = 0;\r\npacket->read_x_cmd[2] = 0;\r\nx->tx_buf = &packet->read_x_cmd[0];\r\nx->rx_buf = &packet->tc.x_buf[0];\r\nx->len = 3;\r\nspi_message_add_tail(x, m);\r\n} else {\r\nx++;\r\npacket->read_x = READ_X(vref);\r\nx->tx_buf = &packet->read_x;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->tc.x;\r\nx->len = 2;\r\nspi_message_add_tail(x, m);\r\n}\r\nif (pdata->settle_delay_usecs) {\r\nx->delay_usecs = pdata->settle_delay_usecs;\r\nx++;\r\nx->tx_buf = &packet->read_x;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->tc.x;\r\nx->len = 2;\r\nspi_message_add_tail(x, m);\r\n}\r\nif (ts->model == 7846) {\r\nts->msg_count++;\r\nm++;\r\nspi_message_init(m);\r\nm->context = ts;\r\nx++;\r\npacket->read_z1 = READ_Z1(vref);\r\nx->tx_buf = &packet->read_z1;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->tc.z1;\r\nx->len = 2;\r\nspi_message_add_tail(x, m);\r\nif (pdata->settle_delay_usecs) {\r\nx->delay_usecs = pdata->settle_delay_usecs;\r\nx++;\r\nx->tx_buf = &packet->read_z1;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->tc.z1;\r\nx->len = 2;\r\nspi_message_add_tail(x, m);\r\n}\r\nts->msg_count++;\r\nm++;\r\nspi_message_init(m);\r\nm->context = ts;\r\nx++;\r\npacket->read_z2 = READ_Z2(vref);\r\nx->tx_buf = &packet->read_z2;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->tc.z2;\r\nx->len = 2;\r\nspi_message_add_tail(x, m);\r\nif (pdata->settle_delay_usecs) {\r\nx->delay_usecs = pdata->settle_delay_usecs;\r\nx++;\r\nx->tx_buf = &packet->read_z2;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->tc.z2;\r\nx->len = 2;\r\nspi_message_add_tail(x, m);\r\n}\r\n}\r\nts->msg_count++;\r\nm++;\r\nspi_message_init(m);\r\nm->context = ts;\r\nif (ts->model == 7845) {\r\nx++;\r\npacket->pwrdown_cmd[0] = PWRDOWN;\r\npacket->pwrdown_cmd[1] = 0;\r\npacket->pwrdown_cmd[2] = 0;\r\nx->tx_buf = &packet->pwrdown_cmd[0];\r\nx->len = 3;\r\n} else {\r\nx++;\r\npacket->pwrdown = PWRDOWN;\r\nx->tx_buf = &packet->pwrdown;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->rx_buf = &packet->dummy;\r\nx->len = 2;\r\n}\r\nCS_CHANGE(*x);\r\nspi_message_add_tail(x, m);\r\n}\r\nstatic const struct ads7846_platform_data *ads7846_probe_dt(struct device *dev)\r\n{\r\nstruct ads7846_platform_data *pdata;\r\nstruct device_node *node = dev->of_node;\r\nconst struct of_device_id *match;\r\nif (!node) {\r\ndev_err(dev, "Device does not have associated DT data\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmatch = of_match_device(ads7846_dt_ids, dev);\r\nif (!match) {\r\ndev_err(dev, "Unknown device model\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->model = (unsigned long)match->data;\r\nof_property_read_u16(node, "ti,vref-delay-usecs",\r\n&pdata->vref_delay_usecs);\r\nof_property_read_u16(node, "ti,vref-mv", &pdata->vref_mv);\r\npdata->keep_vref_on = of_property_read_bool(node, "ti,keep-vref-on");\r\npdata->swap_xy = of_property_read_bool(node, "ti,swap-xy");\r\nof_property_read_u16(node, "ti,settle-delay-usec",\r\n&pdata->settle_delay_usecs);\r\nof_property_read_u16(node, "ti,penirq-recheck-delay-usecs",\r\n&pdata->penirq_recheck_delay_usecs);\r\nof_property_read_u16(node, "ti,x-plate-ohms", &pdata->x_plate_ohms);\r\nof_property_read_u16(node, "ti,y-plate-ohms", &pdata->y_plate_ohms);\r\nof_property_read_u16(node, "ti,x-min", &pdata->x_min);\r\nof_property_read_u16(node, "ti,y-min", &pdata->y_min);\r\nof_property_read_u16(node, "ti,x-max", &pdata->x_max);\r\nof_property_read_u16(node, "ti,y-max", &pdata->y_max);\r\nof_property_read_u16(node, "ti,pressure-min", &pdata->pressure_min);\r\nof_property_read_u16(node, "ti,pressure-max", &pdata->pressure_max);\r\nof_property_read_u16(node, "ti,debounce-max", &pdata->debounce_max);\r\nof_property_read_u16(node, "ti,debounce-tol", &pdata->debounce_tol);\r\nof_property_read_u16(node, "ti,debounce-rep", &pdata->debounce_rep);\r\nof_property_read_u32(node, "ti,pendown-gpio-debounce",\r\n&pdata->gpio_pendown_debounce);\r\npdata->wakeup = of_property_read_bool(node, "linux,wakeup");\r\npdata->gpio_pendown = of_get_named_gpio(dev->of_node, "pendown-gpio", 0);\r\nreturn pdata;\r\n}\r\nstatic const struct ads7846_platform_data *ads7846_probe_dt(struct device *dev)\r\n{\r\ndev_err(dev, "no platform data defined\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int ads7846_probe(struct spi_device *spi)\r\n{\r\nconst struct ads7846_platform_data *pdata;\r\nstruct ads7846 *ts;\r\nstruct ads7846_packet *packet;\r\nstruct input_dev *input_dev;\r\nunsigned long irq_flags;\r\nint err;\r\nif (!spi->irq) {\r\ndev_dbg(&spi->dev, "no IRQ?\n");\r\nreturn -EINVAL;\r\n}\r\nif (spi->max_speed_hz > (125000 * SAMPLE_BITS)) {\r\ndev_err(&spi->dev, "f(sample) %d KHz?\n",\r\n(spi->max_speed_hz/SAMPLE_BITS)/1000);\r\nreturn -EINVAL;\r\n}\r\nspi->bits_per_word = 8;\r\nspi->mode = SPI_MODE_0;\r\nerr = spi_setup(spi);\r\nif (err < 0)\r\nreturn err;\r\nts = kzalloc(sizeof(struct ads7846), GFP_KERNEL);\r\npacket = kzalloc(sizeof(struct ads7846_packet), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts || !packet || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nspi_set_drvdata(spi, ts);\r\nts->packet = packet;\r\nts->spi = spi;\r\nts->input = input_dev;\r\nmutex_init(&ts->lock);\r\ninit_waitqueue_head(&ts->wait);\r\npdata = dev_get_platdata(&spi->dev);\r\nif (!pdata) {\r\npdata = ads7846_probe_dt(&spi->dev);\r\nif (IS_ERR(pdata)) {\r\nerr = PTR_ERR(pdata);\r\ngoto err_free_mem;\r\n}\r\n}\r\nts->model = pdata->model ? : 7846;\r\nts->vref_delay_usecs = pdata->vref_delay_usecs ? : 100;\r\nts->x_plate_ohms = pdata->x_plate_ohms ? : 400;\r\nts->pressure_max = pdata->pressure_max ? : ~0;\r\nts->vref_mv = pdata->vref_mv;\r\nts->swap_xy = pdata->swap_xy;\r\nif (pdata->filter != NULL) {\r\nif (pdata->filter_init != NULL) {\r\nerr = pdata->filter_init(pdata, &ts->filter_data);\r\nif (err < 0)\r\ngoto err_free_mem;\r\n}\r\nts->filter = pdata->filter;\r\nts->filter_cleanup = pdata->filter_cleanup;\r\n} else if (pdata->debounce_max) {\r\nts->debounce_max = pdata->debounce_max;\r\nif (ts->debounce_max < 2)\r\nts->debounce_max = 2;\r\nts->debounce_tol = pdata->debounce_tol;\r\nts->debounce_rep = pdata->debounce_rep;\r\nts->filter = ads7846_debounce_filter;\r\nts->filter_data = ts;\r\n} else {\r\nts->filter = ads7846_no_filter;\r\n}\r\nerr = ads7846_setup_pendown(spi, ts, pdata);\r\nif (err)\r\ngoto err_cleanup_filter;\r\nif (pdata->penirq_recheck_delay_usecs)\r\nts->penirq_recheck_delay_usecs =\r\npdata->penirq_recheck_delay_usecs;\r\nts->wait_for_sync = pdata->wait_for_sync ? : null_wait_for_sync;\r\nsnprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(&spi->dev));\r\nsnprintf(ts->name, sizeof(ts->name), "ADS%d Touchscreen", ts->model);\r\ninput_dev->name = ts->name;\r\ninput_dev->phys = ts->phys;\r\ninput_dev->dev.parent = &spi->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X,\r\npdata->x_min ? : 0,\r\npdata->x_max ? : MAX_12BIT,\r\n0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\npdata->y_min ? : 0,\r\npdata->y_max ? : MAX_12BIT,\r\n0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\npdata->pressure_min, pdata->pressure_max, 0, 0);\r\nads7846_setup_spi_msg(ts, pdata);\r\nts->reg = regulator_get(&spi->dev, "vcc");\r\nif (IS_ERR(ts->reg)) {\r\nerr = PTR_ERR(ts->reg);\r\ndev_err(&spi->dev, "unable to get regulator: %d\n", err);\r\ngoto err_free_gpio;\r\n}\r\nerr = regulator_enable(ts->reg);\r\nif (err) {\r\ndev_err(&spi->dev, "unable to enable regulator: %d\n", err);\r\ngoto err_put_regulator;\r\n}\r\nirq_flags = pdata->irq_flags ? : IRQF_TRIGGER_FALLING;\r\nirq_flags |= IRQF_ONESHOT;\r\nerr = request_threaded_irq(spi->irq, ads7846_hard_irq, ads7846_irq,\r\nirq_flags, spi->dev.driver->name, ts);\r\nif (err && !pdata->irq_flags) {\r\ndev_info(&spi->dev,\r\n"trying pin change workaround on irq %d\n", spi->irq);\r\nirq_flags |= IRQF_TRIGGER_RISING;\r\nerr = request_threaded_irq(spi->irq,\r\nads7846_hard_irq, ads7846_irq,\r\nirq_flags, spi->dev.driver->name, ts);\r\n}\r\nif (err) {\r\ndev_dbg(&spi->dev, "irq %d busy?\n", spi->irq);\r\ngoto err_disable_regulator;\r\n}\r\nerr = ads784x_hwmon_register(spi, ts);\r\nif (err)\r\ngoto err_free_irq;\r\ndev_info(&spi->dev, "touchscreen, irq %d\n", spi->irq);\r\nif (ts->model == 7845)\r\nads7845_read12_ser(&spi->dev, PWRDOWN);\r\nelse\r\n(void) ads7846_read12_ser(&spi->dev, READ_12BIT_SER(vaux));\r\nerr = sysfs_create_group(&spi->dev.kobj, &ads784x_attr_group);\r\nif (err)\r\ngoto err_remove_hwmon;\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_remove_attr_group;\r\ndevice_init_wakeup(&spi->dev, pdata->wakeup);\r\nif (!dev_get_platdata(&spi->dev))\r\ndevm_kfree(&spi->dev, (void *)pdata);\r\nreturn 0;\r\nerr_remove_attr_group:\r\nsysfs_remove_group(&spi->dev.kobj, &ads784x_attr_group);\r\nerr_remove_hwmon:\r\nads784x_hwmon_unregister(spi, ts);\r\nerr_free_irq:\r\nfree_irq(spi->irq, ts);\r\nerr_disable_regulator:\r\nregulator_disable(ts->reg);\r\nerr_put_regulator:\r\nregulator_put(ts->reg);\r\nerr_free_gpio:\r\nif (!ts->get_pendown_state)\r\ngpio_free(ts->gpio_pendown);\r\nerr_cleanup_filter:\r\nif (ts->filter_cleanup)\r\nts->filter_cleanup(ts->filter_data);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(packet);\r\nkfree(ts);\r\nreturn err;\r\n}\r\nstatic int ads7846_remove(struct spi_device *spi)\r\n{\r\nstruct ads7846 *ts = spi_get_drvdata(spi);\r\ndevice_init_wakeup(&spi->dev, false);\r\nsysfs_remove_group(&spi->dev.kobj, &ads784x_attr_group);\r\nads7846_disable(ts);\r\nfree_irq(ts->spi->irq, ts);\r\ninput_unregister_device(ts->input);\r\nads784x_hwmon_unregister(spi, ts);\r\nregulator_disable(ts->reg);\r\nregulator_put(ts->reg);\r\nif (!ts->get_pendown_state) {\r\ngpio_free(ts->gpio_pendown);\r\n}\r\nif (ts->filter_cleanup)\r\nts->filter_cleanup(ts->filter_data);\r\nkfree(ts->packet);\r\nkfree(ts);\r\ndev_dbg(&spi->dev, "unregistered touchscreen\n");\r\nreturn 0;\r\n}
