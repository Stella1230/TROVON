static inline void men_z135_reg_set(struct men_z135_port *uart,\r\nu32 addr, u32 val)\r\n{\r\nstruct uart_port *port = &uart->port;\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&uart->lock, flags);\r\nreg = ioread32(port->membase + addr);\r\nreg |= val;\r\niowrite32(reg, port->membase + addr);\r\nspin_unlock_irqrestore(&uart->lock, flags);\r\n}\r\nstatic inline void men_z135_reg_clr(struct men_z135_port *uart,\r\nu32 addr, u32 val)\r\n{\r\nstruct uart_port *port = &uart->port;\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&uart->lock, flags);\r\nreg = ioread32(port->membase + addr);\r\nreg &= ~val;\r\niowrite32(reg, port->membase + addr);\r\nspin_unlock_irqrestore(&uart->lock, flags);\r\n}\r\nstatic void men_z135_handle_modem_status(struct men_z135_port *uart)\r\n{\r\nif (uart->stat_reg & MEN_Z135_MSR_DDCD)\r\nuart_handle_dcd_change(&uart->port,\r\nuart->stat_reg & ~MEN_Z135_MSR_DCD);\r\nif (uart->stat_reg & MEN_Z135_MSR_DCTS)\r\nuart_handle_cts_change(&uart->port,\r\nuart->stat_reg & ~MEN_Z135_MSR_CTS);\r\n}\r\nstatic void men_z135_handle_lsr(struct men_z135_port *uart)\r\n{\r\nstruct uart_port *port = &uart->port;\r\nu8 lsr;\r\nlsr = (uart->stat_reg >> 16) & 0xff;\r\nif (lsr & MEN_Z135_LSR_OE)\r\nport->icount.overrun++;\r\nif (lsr & MEN_Z135_LSR_PE)\r\nport->icount.parity++;\r\nif (lsr & MEN_Z135_LSR_FE)\r\nport->icount.frame++;\r\nif (lsr & MEN_Z135_LSR_BI) {\r\nport->icount.brk++;\r\nuart_handle_break(port);\r\n}\r\n}\r\nstatic u16 get_rx_fifo_content(struct men_z135_port *uart)\r\n{\r\nstruct uart_port *port = &uart->port;\r\nu32 stat_reg;\r\nu16 rxc;\r\nu8 rxc_lo;\r\nu8 rxc_hi;\r\nstat_reg = ioread32(port->membase + MEN_Z135_STAT_REG);\r\nrxc_lo = stat_reg >> 24;\r\nrxc_hi = (stat_reg & 0xC0) >> 6;\r\nrxc = rxc_lo | (rxc_hi << 8);\r\nreturn rxc;\r\n}\r\nstatic void men_z135_handle_rx(struct men_z135_port *uart)\r\n{\r\nstruct uart_port *port = &uart->port;\r\nstruct tty_port *tport = &port->state->port;\r\nint copied;\r\nu16 size;\r\nint room;\r\nsize = get_rx_fifo_content(uart);\r\nif (size == 0)\r\nreturn;\r\nif (size > MEN_Z135_FIFO_WATERMARK)\r\nsize = MEN_Z135_FIFO_WATERMARK;\r\nroom = tty_buffer_request_room(tport, size);\r\nif (room != size)\r\ndev_warn(&uart->mdev->dev,\r\n"Not enough room in flip buffer, truncating to %d\n",\r\nroom);\r\nif (room == 0)\r\nreturn;\r\nmemcpy_fromio(uart->rxbuf, port->membase + MEN_Z135_RX_RAM, room);\r\nmb();\r\niowrite32(room, port->membase + MEN_Z135_RX_CTRL);\r\ncopied = tty_insert_flip_string(tport, uart->rxbuf, room);\r\nif (copied != room)\r\ndev_warn(&uart->mdev->dev,\r\n"Only copied %d instead of %d bytes\n",\r\ncopied, room);\r\nport->icount.rx += copied;\r\ntty_flip_buffer_push(tport);\r\n}\r\nstatic void men_z135_handle_tx(struct men_z135_port *uart)\r\n{\r\nstruct uart_port *port = &uart->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nu32 txc;\r\nu32 wptr;\r\nint qlen;\r\nint n;\r\nint txfree;\r\nint head;\r\nint tail;\r\nint s;\r\nif (uart_circ_empty(xmit))\r\ngoto out;\r\nif (uart_tx_stopped(port))\r\ngoto out;\r\nif (port->x_char)\r\ngoto out;\r\nqlen = uart_circ_chars_pending(xmit);\r\nif (qlen <= 0)\r\ngoto out;\r\nwptr = ioread32(port->membase + MEN_Z135_TX_CTRL);\r\ntxc = (wptr >> 16) & 0x3ff;\r\nwptr &= 0x3ff;\r\nif (txc > MEN_Z135_FIFO_WATERMARK)\r\ntxc = MEN_Z135_FIFO_WATERMARK;\r\ntxfree = MEN_Z135_FIFO_WATERMARK - txc;\r\nif (txfree <= 0) {\r\npr_err("Not enough room in TX FIFO have %d, need %d\n",\r\ntxfree, qlen);\r\ngoto irq_en;\r\n}\r\nif (align && qlen >= 3 && BYTES_TO_ALIGN(wptr))\r\nn = 4 - BYTES_TO_ALIGN(wptr);\r\nelse if (qlen > txfree)\r\nn = txfree;\r\nelse\r\nn = qlen;\r\nif (n <= 0)\r\ngoto irq_en;\r\nhead = xmit->head & (UART_XMIT_SIZE - 1);\r\ntail = xmit->tail & (UART_XMIT_SIZE - 1);\r\ns = ((head >= tail) ? head : UART_XMIT_SIZE) - tail;\r\nn = min(n, s);\r\nmemcpy_toio(port->membase + MEN_Z135_TX_RAM, &xmit->buf[xmit->tail], n);\r\nxmit->tail = (xmit->tail + n) & (UART_XMIT_SIZE - 1);\r\nmmiowb();\r\niowrite32(n & 0x3ff, port->membase + MEN_Z135_TX_CTRL);\r\nport->icount.tx += n;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nirq_en:\r\nif (!uart_circ_empty(xmit))\r\nmen_z135_reg_set(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_TXCIEN);\r\nelse\r\nmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_TXCIEN);\r\nout:\r\nreturn;\r\n}\r\nstatic irqreturn_t men_z135_intr(int irq, void *data)\r\n{\r\nstruct men_z135_port *uart = (struct men_z135_port *)data;\r\nstruct uart_port *port = &uart->port;\r\nint irq_id;\r\nuart->stat_reg = ioread32(port->membase + MEN_Z135_STAT_REG);\r\nif (IS_IRQ(uart->stat_reg))\r\nreturn IRQ_NONE;\r\nirq_id = IRQ_ID(uart->stat_reg);\r\nswitch (irq_id) {\r\ncase MEN_Z135_IRQ_ID_MST:\r\nmen_z135_handle_modem_status(uart);\r\nbreak;\r\ncase MEN_Z135_IRQ_ID_TSA:\r\nmen_z135_handle_tx(uart);\r\nbreak;\r\ncase MEN_Z135_IRQ_ID_CTI:\r\ndev_dbg(&uart->mdev->dev, "Character Timeout Indication\n");\r\ncase MEN_Z135_IRQ_ID_RDA:\r\nmen_z135_handle_rx(uart);\r\nbreak;\r\ncase MEN_Z135_IRQ_ID_RLS:\r\nmen_z135_handle_lsr(uart);\r\nbreak;\r\ndefault:\r\ndev_warn(&uart->mdev->dev, "Unknown IRQ id %d\n", irq_id);\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int men_z135_request_irq(struct men_z135_port *uart)\r\n{\r\nstruct device *dev = &uart->mdev->dev;\r\nstruct uart_port *port = &uart->port;\r\nint err = 0;\r\nerr = request_irq(port->irq, men_z135_intr, IRQF_SHARED,\r\n"men_z135_intr", uart);\r\nif (err)\r\ndev_err(dev, "Error %d getting interrupt\n", err);\r\nreturn err;\r\n}\r\nstatic unsigned int men_z135_tx_empty(struct uart_port *port)\r\n{\r\nu32 wptr;\r\nu16 txc;\r\nwptr = ioread32(port->membase + MEN_Z135_TX_CTRL);\r\ntxc = (wptr >> 16) & 0x3ff;\r\nif (txc == 0)\r\nreturn TIOCSER_TEMT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void men_z135_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct men_z135_port *uart = to_men_z135(port);\r\nu32 conf_reg = 0;\r\nif (mctrl & TIOCM_RTS)\r\nconf_reg |= MEN_Z135_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nconf_reg |= MEN_Z135_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nconf_reg |= MEN_Z135_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nconf_reg |= MEN_Z135_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nconf_reg |= MEN_Z135_MCR_LOOP;\r\nmen_z135_reg_set(uart, MEN_Z135_CONF_REG, conf_reg);\r\n}\r\nstatic unsigned int men_z135_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int mctrl = 0;\r\nu32 stat_reg;\r\nu8 msr;\r\nstat_reg = ioread32(port->membase + MEN_Z135_STAT_REG);\r\nmsr = ~((stat_reg >> 8) & 0xff);\r\nif (msr & MEN_Z135_MSR_CTS)\r\nmctrl |= TIOCM_CTS;\r\nif (msr & MEN_Z135_MSR_DSR)\r\nmctrl |= TIOCM_DSR;\r\nif (msr & MEN_Z135_MSR_RI)\r\nmctrl |= TIOCM_RI;\r\nif (msr & MEN_Z135_MSR_DCD)\r\nmctrl |= TIOCM_CAR;\r\nreturn mctrl;\r\n}\r\nstatic void men_z135_stop_tx(struct uart_port *port)\r\n{\r\nstruct men_z135_port *uart = to_men_z135(port);\r\nmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_TXCIEN);\r\n}\r\nstatic void men_z135_start_tx(struct uart_port *port)\r\n{\r\nstruct men_z135_port *uart = to_men_z135(port);\r\nmen_z135_handle_tx(uart);\r\n}\r\nstatic void men_z135_stop_rx(struct uart_port *port)\r\n{\r\nstruct men_z135_port *uart = to_men_z135(port);\r\nmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_RXCIEN);\r\n}\r\nstatic void men_z135_enable_ms(struct uart_port *port)\r\n{\r\nstruct men_z135_port *uart = to_men_z135(port);\r\nmen_z135_reg_set(uart, MEN_Z135_CONF_REG, MEN_Z135_IER_MSIEN);\r\n}\r\nstatic int men_z135_startup(struct uart_port *port)\r\n{\r\nstruct men_z135_port *uart = to_men_z135(port);\r\nint err;\r\nu32 conf_reg = 0;\r\nerr = men_z135_request_irq(uart);\r\nif (err)\r\nreturn -ENODEV;\r\nconf_reg = ioread32(port->membase + MEN_Z135_CONF_REG);\r\nconf_reg |= MEN_Z135_ALL_IRQS & ~MEN_Z135_IER_TXCIEN;\r\nconf_reg &= ~(0xff << 16);\r\nconf_reg |= (txlvl << 16);\r\nconf_reg |= (rxlvl << 20);\r\niowrite32(conf_reg, port->membase + MEN_Z135_CONF_REG);\r\nreturn 0;\r\n}\r\nstatic void men_z135_shutdown(struct uart_port *port)\r\n{\r\nstruct men_z135_port *uart = to_men_z135(port);\r\nu32 conf_reg = 0;\r\nconf_reg |= MEN_Z135_ALL_IRQS;\r\nmen_z135_reg_clr(uart, MEN_Z135_CONF_REG, conf_reg);\r\nfree_irq(uart->port.irq, uart);\r\n}\r\nstatic void men_z135_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud;\r\nu32 conf_reg;\r\nu32 bd_reg;\r\nu32 uart_freq;\r\nu8 lcr;\r\nconf_reg = ioread32(port->membase + MEN_Z135_CONF_REG);\r\nlcr = LCR(conf_reg);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr |= MEN_Z135_WL5;\r\nbreak;\r\ncase CS6:\r\nlcr |= MEN_Z135_WL6;\r\nbreak;\r\ncase CS7:\r\nlcr |= MEN_Z135_WL7;\r\nbreak;\r\ncase CS8:\r\nlcr |= MEN_Z135_WL8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nlcr |= MEN_Z135_NSTB2 << MEN_Z135_STB_SHIFT;\r\nif (termios->c_cflag & PARENB) {\r\nlcr |= MEN_Z135_PAR_ENA << MEN_Z135_PEN_SHIFT;\r\nif (termios->c_cflag & PARODD)\r\nlcr |= MEN_Z135_PTY_ODD << MEN_Z135_PTY_SHIFT;\r\nelse\r\nlcr |= MEN_Z135_PTY_EVN << MEN_Z135_PTY_SHIFT;\r\n} else\r\nlcr |= MEN_Z135_PAR_DIS << MEN_Z135_PEN_SHIFT;\r\ntermios->c_cflag &= ~CMSPAR;\r\nconf_reg |= lcr << MEN_Z135_LCR_SHIFT;\r\niowrite32(conf_reg, port->membase + MEN_Z135_CONF_REG);\r\nuart_freq = ioread32(port->membase + MEN_Z135_UART_FREQ);\r\nif (uart_freq == 0)\r\nuart_freq = MEN_Z135_BASECLK;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, uart_freq / 16);\r\nspin_lock(&port->lock);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nbd_reg = uart_freq / (4 * baud);\r\niowrite32(bd_reg, port->membase + MEN_Z135_BAUD_REG);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock(&port->lock);\r\n}\r\nstatic const char *men_z135_type(struct uart_port *port)\r\n{\r\nreturn KBUILD_MODNAME;\r\n}\r\nstatic void men_z135_release_port(struct uart_port *port)\r\n{\r\niounmap(port->membase);\r\nport->membase = NULL;\r\nrelease_mem_region(port->mapbase, MEN_Z135_MEM_SIZE);\r\n}\r\nstatic int men_z135_request_port(struct uart_port *port)\r\n{\r\nint size = MEN_Z135_MEM_SIZE;\r\nif (!request_mem_region(port->mapbase, size, "men_z135_port"))\r\nreturn -EBUSY;\r\nport->membase = ioremap(port->mapbase, MEN_Z135_MEM_SIZE);\r\nif (port->membase == NULL) {\r\nrelease_mem_region(port->mapbase, MEN_Z135_MEM_SIZE);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void men_z135_config_port(struct uart_port *port, int type)\r\n{\r\nport->type = PORT_MEN_Z135;\r\nmen_z135_request_port(port);\r\n}\r\nstatic int men_z135_verify_port(struct uart_port *port,\r\nstruct serial_struct *serinfo)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int men_z135_probe(struct mcb_device *mdev,\r\nconst struct mcb_device_id *id)\r\n{\r\nstruct men_z135_port *uart;\r\nstruct resource *mem;\r\nstruct device *dev;\r\nint err;\r\ndev = &mdev->dev;\r\nuart = devm_kzalloc(dev, sizeof(struct men_z135_port), GFP_KERNEL);\r\nif (!uart)\r\nreturn -ENOMEM;\r\nuart->rxbuf = (unsigned char *)__get_free_page(GFP_KERNEL);\r\nif (!uart->rxbuf)\r\nreturn -ENOMEM;\r\nmem = &mdev->mem;\r\nmcb_set_drvdata(mdev, uart);\r\nuart->port.uartclk = MEN_Z135_BASECLK * 16;\r\nuart->port.fifosize = MEN_Z135_FIFO_SIZE;\r\nuart->port.iotype = UPIO_MEM;\r\nuart->port.ops = &men_z135_ops;\r\nuart->port.irq = mcb_get_irq(mdev);\r\nuart->port.iotype = UPIO_MEM;\r\nuart->port.flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP;\r\nuart->port.line = line++;\r\nuart->port.dev = dev;\r\nuart->port.type = PORT_MEN_Z135;\r\nuart->port.mapbase = mem->start;\r\nuart->port.membase = NULL;\r\nuart->mdev = mdev;\r\nspin_lock_init(&uart->port.lock);\r\nspin_lock_init(&uart->lock);\r\nerr = uart_add_one_port(&men_z135_driver, &uart->port);\r\nif (err)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nfree_page((unsigned long) uart->rxbuf);\r\ndev_err(dev, "Failed to add UART: %d\n", err);\r\nreturn err;\r\n}\r\nstatic void men_z135_remove(struct mcb_device *mdev)\r\n{\r\nstruct men_z135_port *uart = mcb_get_drvdata(mdev);\r\nline--;\r\nuart_remove_one_port(&men_z135_driver, &uart->port);\r\nfree_page((unsigned long) uart->rxbuf);\r\n}\r\nstatic int __init men_z135_init(void)\r\n{\r\nint err;\r\nerr = uart_register_driver(&men_z135_driver);\r\nif (err) {\r\npr_err("Failed to register UART: %d\n", err);\r\nreturn err;\r\n}\r\nerr = mcb_register_driver(&mcb_driver);\r\nif (err) {\r\npr_err("Failed to register MCB driver: %d\n", err);\r\nuart_unregister_driver(&men_z135_driver);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit men_z135_exit(void)\r\n{\r\nmcb_unregister_driver(&mcb_driver);\r\nuart_unregister_driver(&men_z135_driver);\r\n}
