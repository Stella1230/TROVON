i40e_status i40e_init_nvm(struct i40e_hw *hw)\r\n{\r\nstruct i40e_nvm_info *nvm = &hw->nvm;\r\ni40e_status ret_code = 0;\r\nu32 fla, gens;\r\nu8 sr_size;\r\ngens = rd32(hw, I40E_GLNVM_GENS);\r\nsr_size = ((gens & I40E_GLNVM_GENS_SR_SIZE_MASK) >>\r\nI40E_GLNVM_GENS_SR_SIZE_SHIFT);\r\nnvm->sr_size = (1 << sr_size) * I40E_SR_WORDS_IN_1KB;\r\nfla = rd32(hw, I40E_GLNVM_FLA);\r\nif (fla & I40E_GLNVM_FLA_LOCKED_MASK) {\r\nnvm->timeout = I40E_MAX_NVM_TIMEOUT;\r\nnvm->blank_nvm_mode = false;\r\n} else {\r\nnvm->blank_nvm_mode = true;\r\nret_code = I40E_ERR_NVM_BLANK_MODE;\r\nhw_dbg(hw, "NVM init error: unsupported blank mode.\n");\r\n}\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_acquire_nvm(struct i40e_hw *hw,\r\nenum i40e_aq_resource_access_type access)\r\n{\r\ni40e_status ret_code = 0;\r\nu64 gtime, timeout;\r\nu64 time = 0;\r\nif (hw->nvm.blank_nvm_mode)\r\ngoto i40e_i40e_acquire_nvm_exit;\r\nret_code = i40e_aq_request_resource(hw, I40E_NVM_RESOURCE_ID, access,\r\n0, &time, NULL);\r\ngtime = rd32(hw, I40E_GLVFGEN_TIMER);\r\nhw->nvm.hw_semaphore_timeout = I40E_MS_TO_GTIME(time) + gtime;\r\nif (ret_code) {\r\nif (time > I40E_MAX_NVM_TIMEOUT)\r\ntimeout = I40E_MS_TO_GTIME(I40E_MAX_NVM_TIMEOUT)\r\n+ gtime;\r\nelse\r\ntimeout = hw->nvm.hw_semaphore_timeout;\r\nwhile (gtime < timeout) {\r\nusleep_range(10000, 20000);\r\nret_code = i40e_aq_request_resource(hw,\r\nI40E_NVM_RESOURCE_ID,\r\naccess, 0, &time,\r\nNULL);\r\nif (!ret_code) {\r\nhw->nvm.hw_semaphore_timeout =\r\nI40E_MS_TO_GTIME(time) + gtime;\r\nbreak;\r\n}\r\ngtime = rd32(hw, I40E_GLVFGEN_TIMER);\r\n}\r\nif (ret_code) {\r\nhw->nvm.hw_semaphore_timeout = 0;\r\nhw->nvm.hw_semaphore_wait =\r\nI40E_MS_TO_GTIME(time) + gtime;\r\nhw_dbg(hw, "NVM acquire timed out, wait %llu ms before trying again.\n",\r\ntime);\r\n}\r\n}\r\ni40e_i40e_acquire_nvm_exit:\r\nreturn ret_code;\r\n}\r\nvoid i40e_release_nvm(struct i40e_hw *hw)\r\n{\r\nif (!hw->nvm.blank_nvm_mode)\r\ni40e_aq_release_resource(hw, I40E_NVM_RESOURCE_ID, 0, NULL);\r\n}\r\nstatic i40e_status i40e_poll_sr_srctl_done_bit(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = I40E_ERR_TIMEOUT;\r\nu32 srctl, wait_cnt;\r\nfor (wait_cnt = 0; wait_cnt < I40E_SRRD_SRCTL_ATTEMPTS; wait_cnt++) {\r\nsrctl = rd32(hw, I40E_GLNVM_SRCTL);\r\nif (srctl & I40E_GLNVM_SRCTL_DONE_MASK) {\r\nret_code = 0;\r\nbreak;\r\n}\r\nudelay(5);\r\n}\r\nif (ret_code == I40E_ERR_TIMEOUT)\r\nhw_dbg(hw, "Done bit in GLNVM_SRCTL not set\n");\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_read_nvm_word(struct i40e_hw *hw, u16 offset,\r\nu16 *data)\r\n{\r\ni40e_status ret_code = I40E_ERR_TIMEOUT;\r\nu32 sr_reg;\r\nif (offset >= hw->nvm.sr_size) {\r\nhw_dbg(hw, "NVM read error: Offset beyond Shadow RAM limit.\n");\r\nret_code = I40E_ERR_PARAM;\r\ngoto read_nvm_exit;\r\n}\r\nret_code = i40e_poll_sr_srctl_done_bit(hw);\r\nif (!ret_code) {\r\nsr_reg = (u32)(offset << I40E_GLNVM_SRCTL_ADDR_SHIFT) |\r\n(1 << I40E_GLNVM_SRCTL_START_SHIFT);\r\nwr32(hw, I40E_GLNVM_SRCTL, sr_reg);\r\nret_code = i40e_poll_sr_srctl_done_bit(hw);\r\nif (!ret_code) {\r\nsr_reg = rd32(hw, I40E_GLNVM_SRDATA);\r\n*data = (u16)((sr_reg &\r\nI40E_GLNVM_SRDATA_RDDATA_MASK)\r\n>> I40E_GLNVM_SRDATA_RDDATA_SHIFT);\r\n}\r\n}\r\nif (ret_code)\r\nhw_dbg(hw, "NVM read error: Couldn't access Shadow RAM address: 0x%x\n",\r\noffset);\r\nread_nvm_exit:\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset,\r\nu16 *words, u16 *data)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 index, word;\r\nfor (word = 0; word < *words; word++) {\r\nindex = offset + word;\r\nret_code = i40e_read_nvm_word(hw, index, &data[word]);\r\nif (ret_code)\r\nbreak;\r\n}\r\n*words = word;\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_write_nvm_aq(struct i40e_hw *hw, u8 module_pointer,\r\nu32 offset, u16 words, void *data,\r\nbool last_command)\r\n{\r\ni40e_status ret_code = I40E_ERR_NVM;\r\nif ((offset + words) > hw->nvm.sr_size)\r\nhw_dbg(hw, "NVM write error: offset beyond Shadow RAM limit.\n");\r\nelse if (words > I40E_SR_SECTOR_SIZE_IN_WORDS)\r\nhw_dbg(hw, "NVM write fail error: cannot write more than 4KB in a single write.\n");\r\nelse if (((offset + (words - 1)) / I40E_SR_SECTOR_SIZE_IN_WORDS)\r\n!= (offset / I40E_SR_SECTOR_SIZE_IN_WORDS))\r\nhw_dbg(hw, "NVM write error: cannot spread over two sectors in a single write.\n");\r\nelse\r\nret_code = i40e_aq_update_nvm(hw, module_pointer,\r\n2 * offset,\r\n2 * words,\r\ndata, last_command, NULL);\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_calc_nvm_checksum(struct i40e_hw *hw,\r\nu16 *checksum)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 pcie_alt_module = 0;\r\nu16 checksum_local = 0;\r\nu16 vpd_module = 0;\r\nu16 word = 0;\r\nu32 i = 0;\r\nret_code = i40e_read_nvm_word(hw, I40E_SR_VPD_PTR, &vpd_module);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\nret_code = i40e_read_nvm_word(hw, I40E_SR_PCIE_ALT_AUTO_LOAD_PTR,\r\n&pcie_alt_module);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\nfor (i = 0; i < hw->nvm.sr_size; i++) {\r\nif (i == I40E_SR_SW_CHECKSUM_WORD)\r\ni++;\r\nif (i == (u32)vpd_module) {\r\ni += (I40E_SR_VPD_MODULE_MAX_SIZE / 2);\r\nif (i >= hw->nvm.sr_size)\r\nbreak;\r\n}\r\nif (i == (u32)pcie_alt_module) {\r\ni += (I40E_SR_PCIE_ALT_MODULE_MAX_SIZE / 2);\r\nif (i >= hw->nvm.sr_size)\r\nbreak;\r\n}\r\nret_code = i40e_read_nvm_word(hw, (u16)i, &word);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\nchecksum_local += word;\r\n}\r\n*checksum = (u16)I40E_SR_SW_CHECKSUM_BASE - checksum_local;\r\ni40e_calc_nvm_checksum_exit:\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_update_nvm_checksum(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 checksum;\r\nret_code = i40e_calc_nvm_checksum(hw, &checksum);\r\nif (!ret_code)\r\nret_code = i40e_write_nvm_aq(hw, 0x00, I40E_SR_SW_CHECKSUM_WORD,\r\n1, &checksum, true);\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_validate_nvm_checksum(struct i40e_hw *hw,\r\nu16 *checksum)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 checksum_sr = 0;\r\nu16 checksum_local = 0;\r\nret_code = i40e_calc_nvm_checksum(hw, &checksum_local);\r\nif (ret_code)\r\ngoto i40e_validate_nvm_checksum_exit;\r\ni40e_read_nvm_word(hw, I40E_SR_SW_CHECKSUM_WORD, &checksum_sr);\r\nif (checksum_local != checksum_sr)\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\nif (checksum)\r\n*checksum = checksum_local;\r\ni40e_validate_nvm_checksum_exit:\r\nreturn ret_code;\r\n}\r\nstatic inline u8 i40e_nvmupd_get_module(u32 val)\r\n{\r\nreturn (u8)(val & I40E_NVM_MOD_PNT_MASK);\r\n}\r\nstatic inline u8 i40e_nvmupd_get_transaction(u32 val)\r\n{\r\nreturn (u8)((val & I40E_NVM_TRANS_MASK) >> I40E_NVM_TRANS_SHIFT);\r\n}\r\ni40e_status i40e_nvmupd_command(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *errno)\r\n{\r\ni40e_status status;\r\n*errno = 0;\r\nswitch (hw->nvmupd_state) {\r\ncase I40E_NVMUPD_STATE_INIT:\r\nstatus = i40e_nvmupd_state_init(hw, cmd, bytes, errno);\r\nbreak;\r\ncase I40E_NVMUPD_STATE_READING:\r\nstatus = i40e_nvmupd_state_reading(hw, cmd, bytes, errno);\r\nbreak;\r\ncase I40E_NVMUPD_STATE_WRITING:\r\nstatus = i40e_nvmupd_state_writing(hw, cmd, bytes, errno);\r\nbreak;\r\ndefault:\r\nstatus = I40E_NOT_SUPPORTED;\r\n*errno = -ESRCH;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_state_init(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *errno)\r\n{\r\ni40e_status status = 0;\r\nenum i40e_nvmupd_cmd upd_cmd;\r\nupd_cmd = i40e_nvmupd_validate_command(hw, cmd, errno);\r\nswitch (upd_cmd) {\r\ncase I40E_NVMUPD_READ_SA:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\r\nif (status) {\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, errno);\r\ni40e_release_nvm(hw);\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_READ_SNT:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\r\nif (status) {\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, errno);\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_READING;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_WRITE_ERA:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_erase(hw, cmd, errno);\r\nif (status)\r\ni40e_release_nvm(hw);\r\nelse\r\nhw->aq.nvm_release_on_done = true;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_WRITE_SA:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, errno);\r\nif (status)\r\ni40e_release_nvm(hw);\r\nelse\r\nhw->aq.nvm_release_on_done = true;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_WRITE_SNT:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, errno);\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_WRITING;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_CSUM_SA:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_update_nvm_checksum(hw);\r\nif (status) {\r\n*errno = hw->aq.asq_last_status ?\r\ni40e_aq_rc_to_posix(hw->aq.asq_last_status) :\r\n-EIO;\r\ni40e_release_nvm(hw);\r\n} else {\r\nhw->aq.nvm_release_on_done = true;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nstatus = I40E_ERR_NVM;\r\n*errno = -ESRCH;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_state_reading(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *errno)\r\n{\r\ni40e_status status;\r\nenum i40e_nvmupd_cmd upd_cmd;\r\nupd_cmd = i40e_nvmupd_validate_command(hw, cmd, errno);\r\nswitch (upd_cmd) {\r\ncase I40E_NVMUPD_READ_SA:\r\ncase I40E_NVMUPD_READ_CON:\r\nstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, errno);\r\nbreak;\r\ncase I40E_NVMUPD_READ_LCB:\r\nstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, errno);\r\ni40e_release_nvm(hw);\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\nbreak;\r\ndefault:\r\nstatus = I40E_NOT_SUPPORTED;\r\n*errno = -ESRCH;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_state_writing(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *errno)\r\n{\r\ni40e_status status;\r\nenum i40e_nvmupd_cmd upd_cmd;\r\nupd_cmd = i40e_nvmupd_validate_command(hw, cmd, errno);\r\nswitch (upd_cmd) {\r\ncase I40E_NVMUPD_WRITE_CON:\r\nstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, errno);\r\nbreak;\r\ncase I40E_NVMUPD_WRITE_LCB:\r\nstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, errno);\r\nif (!status) {\r\nhw->aq.nvm_release_on_done = true;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_CSUM_CON:\r\nstatus = i40e_update_nvm_checksum(hw);\r\nif (status)\r\n*errno = hw->aq.asq_last_status ?\r\ni40e_aq_rc_to_posix(hw->aq.asq_last_status) :\r\n-EIO;\r\nbreak;\r\ncase I40E_NVMUPD_CSUM_LCB:\r\nstatus = i40e_update_nvm_checksum(hw);\r\nif (status) {\r\n*errno = hw->aq.asq_last_status ?\r\ni40e_aq_rc_to_posix(hw->aq.asq_last_status) :\r\n-EIO;\r\n} else {\r\nhw->aq.nvm_release_on_done = true;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = I40E_NOT_SUPPORTED;\r\n*errno = -ESRCH;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nint *errno)\r\n{\r\nenum i40e_nvmupd_cmd upd_cmd;\r\nu8 transaction, module;\r\nupd_cmd = I40E_NVMUPD_INVALID;\r\ntransaction = i40e_nvmupd_get_transaction(cmd->config);\r\nmodule = i40e_nvmupd_get_module(cmd->config);\r\nif ((cmd->data_size < 1) ||\r\n(cmd->data_size > I40E_NVMUPD_MAX_DATA)) {\r\nhw_dbg(hw, "i40e_nvmupd_validate_command data_size %d\n",\r\ncmd->data_size);\r\n*errno = -EFAULT;\r\nreturn I40E_NVMUPD_INVALID;\r\n}\r\nswitch (cmd->command) {\r\ncase I40E_NVM_READ:\r\nswitch (transaction) {\r\ncase I40E_NVM_CON:\r\nupd_cmd = I40E_NVMUPD_READ_CON;\r\nbreak;\r\ncase I40E_NVM_SNT:\r\nupd_cmd = I40E_NVMUPD_READ_SNT;\r\nbreak;\r\ncase I40E_NVM_LCB:\r\nupd_cmd = I40E_NVMUPD_READ_LCB;\r\nbreak;\r\ncase I40E_NVM_SA:\r\nupd_cmd = I40E_NVMUPD_READ_SA;\r\nbreak;\r\n}\r\nbreak;\r\ncase I40E_NVM_WRITE:\r\nswitch (transaction) {\r\ncase I40E_NVM_CON:\r\nupd_cmd = I40E_NVMUPD_WRITE_CON;\r\nbreak;\r\ncase I40E_NVM_SNT:\r\nupd_cmd = I40E_NVMUPD_WRITE_SNT;\r\nbreak;\r\ncase I40E_NVM_LCB:\r\nupd_cmd = I40E_NVMUPD_WRITE_LCB;\r\nbreak;\r\ncase I40E_NVM_SA:\r\nupd_cmd = I40E_NVMUPD_WRITE_SA;\r\nbreak;\r\ncase I40E_NVM_ERA:\r\nupd_cmd = I40E_NVMUPD_WRITE_ERA;\r\nbreak;\r\ncase I40E_NVM_CSUM:\r\nupd_cmd = I40E_NVMUPD_CSUM_CON;\r\nbreak;\r\ncase (I40E_NVM_CSUM|I40E_NVM_SA):\r\nupd_cmd = I40E_NVMUPD_CSUM_SA;\r\nbreak;\r\ncase (I40E_NVM_CSUM|I40E_NVM_LCB):\r\nupd_cmd = I40E_NVMUPD_CSUM_LCB;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (upd_cmd == I40E_NVMUPD_INVALID) {\r\n*errno = -EFAULT;\r\nhw_dbg(hw,\r\n"i40e_nvmupd_validate_command returns %d errno: %d\n",\r\nupd_cmd, *errno);\r\n}\r\nreturn upd_cmd;\r\n}\r\nstatic i40e_status i40e_nvmupd_nvm_read(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *errno)\r\n{\r\ni40e_status status;\r\nu8 module, transaction;\r\nbool last;\r\ntransaction = i40e_nvmupd_get_transaction(cmd->config);\r\nmodule = i40e_nvmupd_get_module(cmd->config);\r\nlast = (transaction == I40E_NVM_LCB) || (transaction == I40E_NVM_SA);\r\nhw_dbg(hw, "i40e_nvmupd_nvm_read mod 0x%x off 0x%x len 0x%x\n",\r\nmodule, cmd->offset, cmd->data_size);\r\nstatus = i40e_aq_read_nvm(hw, module, cmd->offset, (u16)cmd->data_size,\r\nbytes, last, NULL);\r\nhw_dbg(hw, "i40e_nvmupd_nvm_read status %d\n", status);\r\nif (status)\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_nvm_erase(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nint *errno)\r\n{\r\ni40e_status status = 0;\r\nu8 module, transaction;\r\nbool last;\r\ntransaction = i40e_nvmupd_get_transaction(cmd->config);\r\nmodule = i40e_nvmupd_get_module(cmd->config);\r\nlast = (transaction & I40E_NVM_LCB);\r\nhw_dbg(hw, "i40e_nvmupd_nvm_erase mod 0x%x off 0x%x len 0x%x\n",\r\nmodule, cmd->offset, cmd->data_size);\r\nstatus = i40e_aq_erase_nvm(hw, module, cmd->offset, (u16)cmd->data_size,\r\nlast, NULL);\r\nhw_dbg(hw, "i40e_nvmupd_nvm_erase status %d\n", status);\r\nif (status)\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_nvm_write(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *errno)\r\n{\r\ni40e_status status = 0;\r\nu8 module, transaction;\r\nbool last;\r\ntransaction = i40e_nvmupd_get_transaction(cmd->config);\r\nmodule = i40e_nvmupd_get_module(cmd->config);\r\nlast = (transaction & I40E_NVM_LCB);\r\nhw_dbg(hw, "i40e_nvmupd_nvm_write mod 0x%x off 0x%x len 0x%x\n",\r\nmodule, cmd->offset, cmd->data_size);\r\nstatus = i40e_aq_update_nvm(hw, module, cmd->offset,\r\n(u16)cmd->data_size, bytes, last, NULL);\r\nhw_dbg(hw, "i40e_nvmupd_nvm_write status %d\n", status);\r\nif (status)\r\n*errno = i40e_aq_rc_to_posix(hw->aq.asq_last_status);\r\nreturn status;\r\n}
