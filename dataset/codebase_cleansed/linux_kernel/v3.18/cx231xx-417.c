static int set_itvc_reg(struct cx231xx *dev, u32 gpio_direction, u32 value)\r\n{\r\nint status = 0;\r\nu32 _gpio_direction = 0;\r\n_gpio_direction = _gpio_direction & CX23417_GPIO_MASK;\r\n_gpio_direction = _gpio_direction | gpio_direction;\r\nstatus = cx231xx_send_gpio_cmd(dev, _gpio_direction,\r\n(u8 *)&value, 4, 0, 0);\r\nreturn status;\r\n}\r\nstatic int get_itvc_reg(struct cx231xx *dev, u32 gpio_direction, u32 *val_ptr)\r\n{\r\nint status = 0;\r\nu32 _gpio_direction = 0;\r\n_gpio_direction = _gpio_direction & CX23417_GPIO_MASK;\r\n_gpio_direction = _gpio_direction | gpio_direction;\r\nstatus = cx231xx_send_gpio_cmd(dev, _gpio_direction,\r\n(u8 *)val_ptr, 4, 0, 1);\r\nreturn status;\r\n}\r\nstatic int wait_for_mci_complete(struct cx231xx *dev)\r\n{\r\nu32 gpio;\r\nu32 gpio_direction = 0;\r\nu8 count = 0;\r\nget_itvc_reg(dev, gpio_direction, &gpio);\r\nwhile (!(gpio&0x020000)) {\r\nmsleep(10);\r\nget_itvc_reg(dev, gpio_direction, &gpio);\r\nif (count++ > 100) {\r\ndprintk(3, "ERROR: Timeout - gpio=%x\n", gpio);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mc417_register_write(struct cx231xx *dev, u16 address, u32 value)\r\n{\r\nu32 temp;\r\nint status = 0;\r\ntemp = 0x82 | MCI_REGISTER_DATA_BYTE0 | ((value & 0x000000FF) << 8);\r\ntemp = temp << 10;\r\nstatus = set_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\nif (status < 0)\r\nreturn status;\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_REGISTER_DATA_BYTE1 | (value & 0x0000FF00);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_REGISTER_DATA_BYTE2 | ((value & 0x00FF0000) >> 8);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_REGISTER_DATA_BYTE3 | ((value & 0xFF000000) >> 16);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_REGISTER_ADDRESS_BYTE0 | ((address & 0x000000FF) << 8);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_REGISTER_ADDRESS_BYTE1 | (address & 0x0000FF00);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_REGISTER_MODE | MCI_MODE_REGISTER_WRITE;\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\nreturn wait_for_mci_complete(dev);\r\n}\r\nstatic int mc417_register_read(struct cx231xx *dev, u16 address, u32 *value)\r\n{\r\nu32 temp;\r\nu32 return_value = 0;\r\nint ret = 0;\r\ntemp = 0x82 | MCI_REGISTER_ADDRESS_BYTE0 | ((address & 0x00FF) << 8);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | ((0x05) << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_REGISTER_ADDRESS_BYTE1 | (address & 0xFF00);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | ((0x05) << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_REGISTER_MODE | MCI_MODE_REGISTER_READ;\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | ((0x05) << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\nret = wait_for_mci_complete(dev);\r\ntemp = (0x82 | MCI_REGISTER_DATA_BYTE0) << 10;\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\ntemp = ((0x81 | MCI_REGISTER_DATA_BYTE0) << 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\nget_itvc_reg(dev, ITVC_READ_DIR, &temp);\r\nreturn_value |= ((temp & 0x03FC0000) >> 18);\r\nset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\r\ntemp = (0x82 | MCI_REGISTER_DATA_BYTE1) << 10;\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\ntemp = ((0x81 | MCI_REGISTER_DATA_BYTE1) << 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\nget_itvc_reg(dev, ITVC_READ_DIR, &temp);\r\nreturn_value |= ((temp & 0x03FC0000) >> 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\r\ntemp = (0x82 | MCI_REGISTER_DATA_BYTE2) << 10;\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\ntemp = ((0x81 | MCI_REGISTER_DATA_BYTE2) << 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\nget_itvc_reg(dev, ITVC_READ_DIR, &temp);\r\nreturn_value |= ((temp & 0x03FC0000) >> 2);\r\nset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\r\ntemp = (0x82 | MCI_REGISTER_DATA_BYTE3) << 10;\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\ntemp = ((0x81 | MCI_REGISTER_DATA_BYTE3) << 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\nget_itvc_reg(dev, ITVC_READ_DIR, &temp);\r\nreturn_value |= ((temp & 0x03FC0000) << 6);\r\nset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\r\n*value = return_value;\r\nreturn ret;\r\n}\r\nstatic int mc417_memory_write(struct cx231xx *dev, u32 address, u32 value)\r\n{\r\nu32 temp;\r\nint ret = 0;\r\ntemp = 0x82 | MCI_MEMORY_DATA_BYTE0 | ((value & 0x000000FF) << 8);\r\ntemp = temp << 10;\r\nret = set_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\nif (ret < 0)\r\nreturn ret;\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_MEMORY_DATA_BYTE1 | (value & 0x0000FF00);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_MEMORY_DATA_BYTE2 | ((value & 0x00FF0000) >> 8);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_MEMORY_DATA_BYTE3 | ((value & 0xFF000000) >> 16);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE2 | MCI_MODE_MEMORY_WRITE |\r\n((address & 0x003F0000) >> 8);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE1 | (address & 0xFF00);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE0 | ((address & 0x00FF) << 8);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\nwait_for_mci_complete(dev);\r\nreturn 0;\r\n}\r\nstatic int mc417_memory_read(struct cx231xx *dev, u32 address, u32 *value)\r\n{\r\nu32 temp = 0;\r\nu32 return_value = 0;\r\nint ret = 0;\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE2 | MCI_MODE_MEMORY_READ |\r\n((address & 0x003F0000) >> 8);\r\ntemp = temp << 10;\r\nret = set_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\nif (ret < 0)\r\nreturn ret;\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE1 | (address & 0xFF00);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE0 | ((address & 0x00FF) << 8);\r\ntemp = temp << 10;\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\ntemp = temp | (0x05 << 10);\r\nset_itvc_reg(dev, ITVC_WRITE_DIR, temp);\r\nret = wait_for_mci_complete(dev);\r\ntemp = (0x82 | MCI_MEMORY_DATA_BYTE3) << 10;\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\ntemp = ((0x81 | MCI_MEMORY_DATA_BYTE3) << 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\nget_itvc_reg(dev, ITVC_READ_DIR, &temp);\r\nreturn_value |= ((temp & 0x03FC0000) << 6);\r\nset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\r\ntemp = (0x82 | MCI_MEMORY_DATA_BYTE2) << 10;\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\ntemp = ((0x81 | MCI_MEMORY_DATA_BYTE2) << 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\nget_itvc_reg(dev, ITVC_READ_DIR, &temp);\r\nreturn_value |= ((temp & 0x03FC0000) >> 2);\r\nset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\r\ntemp = (0x82 | MCI_MEMORY_DATA_BYTE1) << 10;\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\ntemp = ((0x81 | MCI_MEMORY_DATA_BYTE1) << 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\nget_itvc_reg(dev, ITVC_READ_DIR, &temp);\r\nreturn_value |= ((temp & 0x03FC0000) >> 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\r\ntemp = (0x82 | MCI_MEMORY_DATA_BYTE0) << 10;\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\ntemp = ((0x81 | MCI_MEMORY_DATA_BYTE0) << 10);\r\nset_itvc_reg(dev, ITVC_READ_DIR, temp);\r\nget_itvc_reg(dev, ITVC_READ_DIR, &temp);\r\nreturn_value |= ((temp & 0x03FC0000) >> 18);\r\nset_itvc_reg(dev, ITVC_READ_DIR, (0x87 << 10));\r\n*value = return_value;\r\nreturn ret;\r\n}\r\nstatic char *cmd_to_str(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase CX2341X_ENC_PING_FW:\r\nreturn "PING_FW";\r\ncase CX2341X_ENC_START_CAPTURE:\r\nreturn "START_CAPTURE";\r\ncase CX2341X_ENC_STOP_CAPTURE:\r\nreturn "STOP_CAPTURE";\r\ncase CX2341X_ENC_SET_AUDIO_ID:\r\nreturn "SET_AUDIO_ID";\r\ncase CX2341X_ENC_SET_VIDEO_ID:\r\nreturn "SET_VIDEO_ID";\r\ncase CX2341X_ENC_SET_PCR_ID:\r\nreturn "SET_PCR_PID";\r\ncase CX2341X_ENC_SET_FRAME_RATE:\r\nreturn "SET_FRAME_RATE";\r\ncase CX2341X_ENC_SET_FRAME_SIZE:\r\nreturn "SET_FRAME_SIZE";\r\ncase CX2341X_ENC_SET_BIT_RATE:\r\nreturn "SET_BIT_RATE";\r\ncase CX2341X_ENC_SET_GOP_PROPERTIES:\r\nreturn "SET_GOP_PROPERTIES";\r\ncase CX2341X_ENC_SET_ASPECT_RATIO:\r\nreturn "SET_ASPECT_RATIO";\r\ncase CX2341X_ENC_SET_DNR_FILTER_MODE:\r\nreturn "SET_DNR_FILTER_PROPS";\r\ncase CX2341X_ENC_SET_DNR_FILTER_PROPS:\r\nreturn "SET_DNR_FILTER_PROPS";\r\ncase CX2341X_ENC_SET_CORING_LEVELS:\r\nreturn "SET_CORING_LEVELS";\r\ncase CX2341X_ENC_SET_SPATIAL_FILTER_TYPE:\r\nreturn "SET_SPATIAL_FILTER_TYPE";\r\ncase CX2341X_ENC_SET_VBI_LINE:\r\nreturn "SET_VBI_LINE";\r\ncase CX2341X_ENC_SET_STREAM_TYPE:\r\nreturn "SET_STREAM_TYPE";\r\ncase CX2341X_ENC_SET_OUTPUT_PORT:\r\nreturn "SET_OUTPUT_PORT";\r\ncase CX2341X_ENC_SET_AUDIO_PROPERTIES:\r\nreturn "SET_AUDIO_PROPERTIES";\r\ncase CX2341X_ENC_HALT_FW:\r\nreturn "HALT_FW";\r\ncase CX2341X_ENC_GET_VERSION:\r\nreturn "GET_VERSION";\r\ncase CX2341X_ENC_SET_GOP_CLOSURE:\r\nreturn "SET_GOP_CLOSURE";\r\ncase CX2341X_ENC_GET_SEQ_END:\r\nreturn "GET_SEQ_END";\r\ncase CX2341X_ENC_SET_PGM_INDEX_INFO:\r\nreturn "SET_PGM_INDEX_INFO";\r\ncase CX2341X_ENC_SET_VBI_CONFIG:\r\nreturn "SET_VBI_CONFIG";\r\ncase CX2341X_ENC_SET_DMA_BLOCK_SIZE:\r\nreturn "SET_DMA_BLOCK_SIZE";\r\ncase CX2341X_ENC_GET_PREV_DMA_INFO_MB_10:\r\nreturn "GET_PREV_DMA_INFO_MB_10";\r\ncase CX2341X_ENC_GET_PREV_DMA_INFO_MB_9:\r\nreturn "GET_PREV_DMA_INFO_MB_9";\r\ncase CX2341X_ENC_SCHED_DMA_TO_HOST:\r\nreturn "SCHED_DMA_TO_HOST";\r\ncase CX2341X_ENC_INITIALIZE_INPUT:\r\nreturn "INITIALIZE_INPUT";\r\ncase CX2341X_ENC_SET_FRAME_DROP_RATE:\r\nreturn "SET_FRAME_DROP_RATE";\r\ncase CX2341X_ENC_PAUSE_ENCODER:\r\nreturn "PAUSE_ENCODER";\r\ncase CX2341X_ENC_REFRESH_INPUT:\r\nreturn "REFRESH_INPUT";\r\ncase CX2341X_ENC_SET_COPYRIGHT:\r\nreturn "SET_COPYRIGHT";\r\ncase CX2341X_ENC_SET_EVENT_NOTIFICATION:\r\nreturn "SET_EVENT_NOTIFICATION";\r\ncase CX2341X_ENC_SET_NUM_VSYNC_LINES:\r\nreturn "SET_NUM_VSYNC_LINES";\r\ncase CX2341X_ENC_SET_PLACEHOLDER:\r\nreturn "SET_PLACEHOLDER";\r\ncase CX2341X_ENC_MUTE_VIDEO:\r\nreturn "MUTE_VIDEO";\r\ncase CX2341X_ENC_MUTE_AUDIO:\r\nreturn "MUTE_AUDIO";\r\ncase CX2341X_ENC_MISC:\r\nreturn "MISC";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic int cx231xx_mbox_func(void *priv, u32 command, int in, int out,\r\nu32 data[CX2341X_MBOX_MAX_DATA])\r\n{\r\nstruct cx231xx *dev = priv;\r\nunsigned long timeout;\r\nu32 value, flag, retval = 0;\r\nint i;\r\ndprintk(3, "%s: command(0x%X) = %s\n", __func__, command,\r\ncmd_to_str(command));\r\nmc417_memory_read(dev, dev->cx23417_mailbox - 4, &value);\r\nif (value != 0x12345678) {\r\ndprintk(3, "Firmware and/or mailbox pointer not initialized or corrupted, signature = 0x%x, cmd = %s\n",\r\nvalue, cmd_to_str(command));\r\nreturn -EIO;\r\n}\r\nmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\r\nif (flag) {\r\ndprintk(3, "ERROR: Mailbox appears to be in use (%x), cmd = %s\n",\r\nflag, cmd_to_str(command));\r\nreturn -EBUSY;\r\n}\r\nflag |= 1;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 1, command);\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 3,\r\nIVTV_API_STD_TIMEOUT);\r\nfor (i = 0; i < in; i++) {\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, data[i]);\r\ndprintk(3, "API Input %d = %d\n", i, data[i]);\r\n}\r\nfor (; i < CX2341X_MBOX_MAX_DATA; i++)\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, 0);\r\nflag |= 3;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\ntimeout = jiffies + msecs_to_jiffies(10);\r\nfor (;;) {\r\nmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\r\nif (0 != (flag & 4))\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\ndprintk(3, "ERROR: API Mailbox timeout\n");\r\nreturn -EIO;\r\n}\r\nudelay(10);\r\n}\r\nfor (i = 0; i < out; i++) {\r\nmc417_memory_read(dev, dev->cx23417_mailbox + 4 + i, data + i);\r\ndprintk(3, "API Output %d = %d\n", i, data[i]);\r\n}\r\nmc417_memory_read(dev, dev->cx23417_mailbox + 2, &retval);\r\ndprintk(3, "API result = %d\n", retval);\r\nflag = 0;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\nreturn 0;\r\n}\r\nstatic int cx231xx_api_cmd(struct cx231xx *dev, u32 command,\r\nu32 inputcnt, u32 outputcnt, ...)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nva_list vargs;\r\nint i, err;\r\ndprintk(3, "%s() cmds = 0x%08x\n", __func__, command);\r\nva_start(vargs, outputcnt);\r\nfor (i = 0; i < inputcnt; i++)\r\ndata[i] = va_arg(vargs, int);\r\nerr = cx231xx_mbox_func(dev, command, inputcnt, outputcnt, data);\r\nfor (i = 0; i < outputcnt; i++) {\r\nint *vptr = va_arg(vargs, int *);\r\n*vptr = data[i];\r\n}\r\nva_end(vargs);\r\nreturn err;\r\n}\r\nstatic int cx231xx_find_mailbox(struct cx231xx *dev)\r\n{\r\nu32 signature[4] = {\r\n0x12345678, 0x34567812, 0x56781234, 0x78123456\r\n};\r\nint signaturecnt = 0;\r\nu32 value;\r\nint i;\r\nint ret = 0;\r\ndprintk(2, "%s()\n", __func__);\r\nfor (i = 0; i < 0x100; i++) {\r\nret = mc417_memory_read(dev, i, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nif (value == signature[signaturecnt])\r\nsignaturecnt++;\r\nelse\r\nsignaturecnt = 0;\r\nif (4 == signaturecnt) {\r\ndprintk(1, "Mailbox signature found at 0x%x\n", i + 1);\r\nreturn i + 1;\r\n}\r\n}\r\ndprintk(3, "Mailbox signature values not found!\n");\r\nreturn -1;\r\n}\r\nstatic void mci_write_memory_to_gpio(struct cx231xx *dev, u32 address, u32 value,\r\nu32 *p_fw_image)\r\n{\r\nu32 temp = 0;\r\nint i = 0;\r\ntemp = 0x82 | MCI_MEMORY_DATA_BYTE0 | ((value & 0x000000FF) << 8);\r\ntemp = temp << 10;\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = temp | (0x05 << 10);\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = 0x82 | MCI_MEMORY_DATA_BYTE1 | (value & 0x0000FF00);\r\ntemp = temp << 10;\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = temp | (0x05 << 10);\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = 0x82 | MCI_MEMORY_DATA_BYTE2 | ((value & 0x00FF0000) >> 8);\r\ntemp = temp << 10;\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = temp | (0x05 << 10);\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = 0x82 | MCI_MEMORY_DATA_BYTE3 | ((value & 0xFF000000) >> 16);\r\ntemp = temp << 10;\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = temp | (0x05 << 10);\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE2 | MCI_MODE_MEMORY_WRITE |\r\n((address & 0x003F0000) >> 8);\r\ntemp = temp << 10;\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = temp | (0x05 << 10);\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE1 | (address & 0xFF00);\r\ntemp = temp << 10;\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = temp | (0x05 << 10);\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = 0x82 | MCI_MEMORY_ADDRESS_BYTE0 | ((address & 0x00FF) << 8);\r\ntemp = temp << 10;\r\n*p_fw_image = temp;\r\np_fw_image++;\r\ntemp = temp | (0x05 << 10);\r\n*p_fw_image = temp;\r\np_fw_image++;\r\nfor (i = 0; i < 6; i++) {\r\n*p_fw_image = 0xFFFFFFFF;\r\np_fw_image++;\r\n}\r\n}\r\nstatic int cx231xx_load_firmware(struct cx231xx *dev)\r\n{\r\nstatic const unsigned char magic[8] = {\r\n0xa7, 0x0d, 0x00, 0x00, 0x66, 0xbb, 0x55, 0xaa\r\n};\r\nconst struct firmware *firmware;\r\nint i, retval = 0;\r\nu32 value = 0;\r\nu32 gpio_output = 0;\r\nu32 transfer_size = 0;\r\nu32 fw_data = 0;\r\nu32 address = 0;\r\nu32 *p_current_fw, *p_fw;\r\nu32 *p_fw_data;\r\nint frame = 0;\r\nu16 _buffer_size = 4096;\r\nu8 *p_buffer;\r\np_current_fw = vmalloc(1884180 * 4);\r\np_fw = p_current_fw;\r\nif (p_current_fw == NULL) {\r\ndprintk(2, "FAIL!!!\n");\r\nreturn -1;\r\n}\r\np_buffer = vmalloc(4096);\r\nif (p_buffer == NULL) {\r\ndprintk(2, "FAIL!!!\n");\r\nreturn -1;\r\n}\r\ndprintk(2, "%s()\n", __func__);\r\nretval |= mc417_memory_read(dev, 0x9020, &gpio_output);\r\nretval |= mc417_memory_read(dev, 0x900C, &value);\r\nretval = mc417_register_write(dev,\r\nIVTV_REG_VPU, 0xFFFFFFED);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_ENC_SDRAM_REFRESH, 0x80000800);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_ENC_SDRAM_PRECHARGE, 0x1A);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_APU, 0);\r\nif (retval != 0) {\r\npr_err("%s: Error with mc417_register_write\n", __func__);\r\nreturn -1;\r\n}\r\nretval = request_firmware(&firmware, CX231xx_FIRM_IMAGE_NAME,\r\n&dev->udev->dev);\r\nif (retval != 0) {\r\npr_err("ERROR: Hotplug firmware request failed (%s).\n",\r\nCX231xx_FIRM_IMAGE_NAME);\r\npr_err("Please fix your hotplug setup, the board will not work without firmware loaded!\n");\r\nreturn -1;\r\n}\r\nif (firmware->size != CX231xx_FIRM_IMAGE_SIZE) {\r\npr_err("ERROR: Firmware size mismatch (have %zd, expected %d)\n",\r\nfirmware->size, CX231xx_FIRM_IMAGE_SIZE);\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nif (0 != memcmp(firmware->data, magic, 8)) {\r\npr_err("ERROR: Firmware magic mismatch, wrong file?\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\ninitGPIO(dev);\r\ndprintk(2, "Loading firmware to GPIO...\n");\r\np_fw_data = (u32 *)firmware->data;\r\ndprintk(2, "firmware->size=%zd\n", firmware->size);\r\nfor (transfer_size = 0; transfer_size < firmware->size;\r\ntransfer_size += 4) {\r\nfw_data = *p_fw_data;\r\nmci_write_memory_to_gpio(dev, address, fw_data, p_current_fw);\r\naddress = address + 1;\r\np_current_fw += 20;\r\np_fw_data += 1;\r\n}\r\nfor (frame = 0; frame < (int)(CX231xx_FIRM_IMAGE_SIZE*20/_buffer_size);\r\nframe++) {\r\nfor (i = 0; i < _buffer_size; i++) {\r\n*(p_buffer + i) = (u8)(*(p_fw + (frame * 128 * 8 + (i / 4))) & 0x000000FF);\r\ni++;\r\n*(p_buffer + i) = (u8)((*(p_fw + (frame * 128 * 8 + (i / 4))) & 0x0000FF00) >> 8);\r\ni++;\r\n*(p_buffer + i) = (u8)((*(p_fw + (frame * 128 * 8 + (i / 4))) & 0x00FF0000) >> 16);\r\ni++;\r\n*(p_buffer + i) = (u8)((*(p_fw + (frame * 128 * 8 + (i / 4))) & 0xFF000000) >> 24);\r\n}\r\ncx231xx_ep5_bulkout(dev, p_buffer, _buffer_size);\r\n}\r\np_current_fw = p_fw;\r\nvfree(p_current_fw);\r\np_current_fw = NULL;\r\nuninitGPIO(dev);\r\nrelease_firmware(firmware);\r\ndprintk(1, "Firmware upload successful.\n");\r\nretval |= mc417_register_write(dev, IVTV_REG_HW_BLOCKS,\r\nIVTV_CMD_HW_BLOCKS_RST);\r\nif (retval < 0) {\r\npr_err("%s: Error with mc417_register_write\n",\r\n__func__);\r\nreturn retval;\r\n}\r\nretval |= mc417_register_write(dev, 0x9020, gpio_output);\r\nretval |= mc417_register_write(dev, 0x900C, value);\r\nretval |= mc417_register_read(dev, IVTV_REG_VPU, &value);\r\nretval |= mc417_register_write(dev, IVTV_REG_VPU, value & 0xFFFFFFE8);\r\nif (retval < 0) {\r\npr_err("%s: Error with mc417_register_write\n",\r\n__func__);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cx231xx_417_check_encoder(struct cx231xx *dev)\r\n{\r\nu32 status, seq;\r\nstatus = 0;\r\nseq = 0;\r\ncx231xx_api_cmd(dev, CX2341X_ENC_GET_SEQ_END, 0, 2, &status, &seq);\r\ndprintk(1, "%s() status = %d, seq = %d\n", __func__, status, seq);\r\n}\r\nstatic void cx231xx_codec_settings(struct cx231xx *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\ncx231xx_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\r\ndev->ts1.height, dev->ts1.width);\r\ndev->mpeg_ctrl_handler.width = dev->ts1.width;\r\ndev->mpeg_ctrl_handler.height = dev->ts1.height;\r\ncx2341x_handler_setup(&dev->mpeg_ctrl_handler);\r\ncx231xx_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 3, 1);\r\ncx231xx_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 4, 1);\r\n}\r\nstatic int cx231xx_initialize_codec(struct cx231xx *dev)\r\n{\r\nint version;\r\nint retval;\r\nu32 i;\r\nu32 val = 0;\r\ndprintk(1, "%s()\n", __func__);\r\ncx231xx_disable656(dev);\r\nretval = cx231xx_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\ndprintk(2, "%s() PING OK\n", __func__);\r\nretval = cx231xx_load_firmware(dev);\r\nif (retval < 0) {\r\npr_err("%s() f/w load failed\n", __func__);\r\nreturn retval;\r\n}\r\nretval = cx231xx_find_mailbox(dev);\r\nif (retval < 0) {\r\npr_err("%s() mailbox < 0, error\n",\r\n__func__);\r\nreturn -1;\r\n}\r\ndev->cx23417_mailbox = retval;\r\nretval = cx231xx_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\npr_err("ERROR: cx23417 firmware ping failed!\n");\r\nreturn -1;\r\n}\r\nretval = cx231xx_api_cmd(dev, CX2341X_ENC_GET_VERSION, 0, 1,\r\n&version);\r\nif (retval < 0) {\r\npr_err("ERROR: cx23417 firmware get encoder: version failed!\n");\r\nreturn -1;\r\n}\r\ndprintk(1, "cx23417 firmware version is 0x%08x\n", version);\r\nmsleep(200);\r\n}\r\nfor (i = 0; i < 1; i++) {\r\nretval = mc417_register_read(dev, 0x20f8, &val);\r\ndprintk(3, "***before enable656() VIM Capture Lines = %d ***\n",\r\nval);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\ncx231xx_enable656(dev);\r\ncx231xx_api_cmd(dev, CX2341X_ENC_STOP_CAPTURE,\r\n3, 0, 1, 3, 4);\r\ncx231xx_codec_settings(dev);\r\nmsleep(60);\r\n#if 0\r\nu32 data[7];\r\ndata[0] = 0x0001BD00;\r\ndata[1] = 1;\r\ndata[2] = 4;\r\ndata[3] = 0x91559155;\r\ndata[4] = 0x206080C0;\r\ndata[5] = 6;\r\ndata[6] = 64;\r\ncx231xx_api_cmd(dev, CX2341X_ENC_SET_VBI_CONFIG, 7, 0, data[0], data[1],\r\ndata[2], data[3], data[4], data[5], data[6]);\r\nfor (i = 2; i <= 24; i++) {\r\nint valid;\r\nvalid = ((i >= 19) && (i <= 21));\r\ncx231xx_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0, i,\r\nvalid, 0 , 0, 0);\r\ncx231xx_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0,\r\ni | 0x80000000, valid, 0, 0, 0);\r\n}\r\n#endif\r\nretval = cx231xx_api_cmd(dev, CX2341X_ENC_INITIALIZE_INPUT, 0, 0);\r\nif (retval < 0)\r\nreturn retval;\r\nmsleep(60);\r\nmc417_memory_write(dev, 2120, 0x00000080);\r\nretval = cx231xx_api_cmd(dev, CX2341X_ENC_START_CAPTURE, 2, 0,\r\nCX231xx_MPEG_CAPTURE, CX231xx_RAW_BITS_NONE);\r\nif (retval < 0)\r\nreturn retval;\r\nmsleep(10);\r\nfor (i = 0; i < 1; i++) {\r\nmc417_register_read(dev, 0x20f8, &val);\r\ndprintk(3, "***VIM Capture Lines =%d ***\n", val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bb_buf_setup(struct videobuf_queue *q,\r\nunsigned int *count, unsigned int *size)\r\n{\r\nstruct cx231xx_fh *fh = q->priv_data;\r\nfh->dev->ts1.ts_packet_size = mpeglinesize;\r\nfh->dev->ts1.ts_packet_count = mpeglines;\r\n*size = fh->dev->ts1.ts_packet_size * fh->dev->ts1.ts_packet_count;\r\n*count = mpegbufs;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct cx231xx_buffer *buf)\r\n{\r\nstruct cx231xx_fh *fh = vq->priv_data;\r\nstruct cx231xx *dev = fh->dev;\r\nunsigned long flags = 0;\r\nif (in_interrupt())\r\nBUG();\r\nspin_lock_irqsave(&dev->video_mode.slock, flags);\r\nif (dev->USE_ISO) {\r\nif (dev->video_mode.isoc_ctl.buf == buf)\r\ndev->video_mode.isoc_ctl.buf = NULL;\r\n} else {\r\nif (dev->video_mode.bulk_ctl.buf == buf)\r\ndev->video_mode.bulk_ctl.buf = NULL;\r\n}\r\nspin_unlock_irqrestore(&dev->video_mode.slock, flags);\r\nvideobuf_waiton(vq, &buf->vb, 0, 0);\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic void buffer_copy(struct cx231xx *dev, char *data, int len, struct urb *urb,\r\nstruct cx231xx_dmaqueue *dma_q)\r\n{\r\nvoid *vbuf;\r\nstruct cx231xx_buffer *buf;\r\nu32 tail_data = 0;\r\nchar *p_data;\r\nif (dma_q->mpeg_buffer_done == 0) {\r\nif (list_empty(&dma_q->active))\r\nreturn;\r\nbuf = list_entry(dma_q->active.next,\r\nstruct cx231xx_buffer, vb.queue);\r\ndev->video_mode.isoc_ctl.buf = buf;\r\ndma_q->mpeg_buffer_done = 1;\r\n}\r\nbuf = dev->video_mode.isoc_ctl.buf;\r\nvbuf = videobuf_to_vmalloc(&buf->vb);\r\nif ((dma_q->mpeg_buffer_completed+len) <\r\nmpeglines*mpeglinesize) {\r\nif (dma_q->add_ps_package_head ==\r\nCX231XX_NEED_ADD_PS_PACKAGE_HEAD) {\r\nmemcpy(vbuf+dma_q->mpeg_buffer_completed,\r\ndma_q->ps_head, 3);\r\ndma_q->mpeg_buffer_completed =\r\ndma_q->mpeg_buffer_completed + 3;\r\ndma_q->add_ps_package_head =\r\nCX231XX_NONEED_PS_PACKAGE_HEAD;\r\n}\r\nmemcpy(vbuf+dma_q->mpeg_buffer_completed, data, len);\r\ndma_q->mpeg_buffer_completed =\r\ndma_q->mpeg_buffer_completed + len;\r\n} else {\r\ndma_q->mpeg_buffer_done = 0;\r\ntail_data =\r\nmpeglines*mpeglinesize - dma_q->mpeg_buffer_completed;\r\nmemcpy(vbuf+dma_q->mpeg_buffer_completed,\r\ndata, tail_data);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\nv4l2_get_timestamp(&buf->vb.ts);\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\ndma_q->mpeg_buffer_completed = 0;\r\nif (len - tail_data > 0) {\r\np_data = data + tail_data;\r\ndma_q->left_data_count = len - tail_data;\r\nmemcpy(dma_q->p_left_data,\r\np_data, len - tail_data);\r\n}\r\n}\r\n}\r\nstatic void buffer_filled(char *data, int len, struct urb *urb,\r\nstruct cx231xx_dmaqueue *dma_q)\r\n{\r\nvoid *vbuf;\r\nstruct cx231xx_buffer *buf;\r\nif (list_empty(&dma_q->active))\r\nreturn;\r\nbuf = list_entry(dma_q->active.next,\r\nstruct cx231xx_buffer, vb.queue);\r\nvbuf = videobuf_to_vmalloc(&buf->vb);\r\nmemcpy(vbuf, data, len);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\nv4l2_get_timestamp(&buf->vb.ts);\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nstatic int cx231xx_isoc_copy(struct cx231xx *dev, struct urb *urb)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = urb->context;\r\nunsigned char *p_buffer;\r\nu32 buffer_size = 0;\r\nu32 i = 0;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (dma_q->left_data_count > 0) {\r\nbuffer_copy(dev, dma_q->p_left_data,\r\ndma_q->left_data_count, urb, dma_q);\r\ndma_q->mpeg_buffer_completed = dma_q->left_data_count;\r\ndma_q->left_data_count = 0;\r\n}\r\np_buffer = urb->transfer_buffer +\r\nurb->iso_frame_desc[i].offset;\r\nbuffer_size = urb->iso_frame_desc[i].actual_length;\r\nif (buffer_size > 0)\r\nbuffer_copy(dev, p_buffer, buffer_size, urb, dma_q);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx231xx_bulk_copy(struct cx231xx *dev, struct urb *urb)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = urb->context;\r\nunsigned char *p_buffer, *buffer;\r\nu32 buffer_size = 0;\r\np_buffer = urb->transfer_buffer;\r\nbuffer_size = urb->actual_length;\r\nbuffer = kmalloc(buffer_size, GFP_ATOMIC);\r\nmemcpy(buffer, dma_q->ps_head, 3);\r\nmemcpy(buffer+3, p_buffer, buffer_size-3);\r\nmemcpy(dma_q->ps_head, p_buffer+buffer_size-3, 3);\r\np_buffer = buffer;\r\nbuffer_filled(p_buffer, buffer_size, urb, dma_q);\r\nkfree(buffer);\r\nreturn 0;\r\n}\r\nstatic int bb_buf_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct cx231xx_fh *fh = q->priv_data;\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nstruct cx231xx *dev = fh->dev;\r\nint rc = 0, urb_init = 0;\r\nint size = fh->dev->ts1.ts_packet_size * fh->dev->ts1.ts_packet_count;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < size)\r\nreturn -EINVAL;\r\nbuf->vb.width = fh->dev->ts1.ts_packet_size;\r\nbuf->vb.height = fh->dev->ts1.ts_packet_count;\r\nbuf->vb.size = size;\r\nbuf->vb.field = field;\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nrc = videobuf_iolock(q, &buf->vb, NULL);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nif (dev->USE_ISO) {\r\nif (!dev->video_mode.isoc_ctl.num_bufs)\r\nurb_init = 1;\r\n} else {\r\nif (!dev->video_mode.bulk_ctl.num_bufs)\r\nurb_init = 1;\r\n}\r\ndev->mode_tv = 1;\r\nif (urb_init) {\r\nrc = cx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\r\nrc = cx231xx_unmute_audio(dev);\r\nif (dev->USE_ISO) {\r\ncx231xx_set_alt_setting(dev, INDEX_TS1, 4);\r\nrc = cx231xx_init_isoc(dev, mpeglines,\r\nmpegbufs,\r\ndev->ts1_mode.max_pkt_size,\r\ncx231xx_isoc_copy);\r\n} else {\r\ncx231xx_set_alt_setting(dev, INDEX_TS1, 0);\r\nrc = cx231xx_init_bulk(dev, mpeglines,\r\nmpegbufs,\r\ndev->ts1_mode.max_pkt_size,\r\ncx231xx_bulk_copy);\r\n}\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(q, buf);\r\nreturn rc;\r\n}\r\nstatic void bb_buf_queue(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx231xx_fh *fh = q->priv_data;\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nstruct cx231xx *dev = fh->dev;\r\nstruct cx231xx_dmaqueue *vidq = &dev->video_mode.vidq;\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\n}\r\nstatic void bb_buf_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx231xx_buffer *buf =\r\ncontainer_of(vb, struct cx231xx_buffer, vb);\r\nfree_buffer(q, buf);\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *fh0, v4l2_std_id *norm)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\n*norm = dev->encodernorm.id;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(cx231xx_tvnorms); i++)\r\nif (id & cx231xx_tvnorms[i].id)\r\nbreak;\r\nif (i == ARRAY_SIZE(cx231xx_tvnorms))\r\nreturn -EINVAL;\r\ndev->encodernorm = cx231xx_tvnorms[i];\r\nif (dev->encodernorm.id & 0xb000) {\r\ndprintk(3, "encodernorm set to NTSC\n");\r\ndev->norm = V4L2_STD_NTSC;\r\ndev->ts1.height = 480;\r\ncx2341x_handler_set_50hz(&dev->mpeg_ctrl_handler, false);\r\n} else {\r\ndprintk(3, "encodernorm set to PAL\n");\r\ndev->norm = V4L2_STD_PAL_B;\r\ndev->ts1.height = 576;\r\ncx2341x_handler_set_50hz(&dev->mpeg_ctrl_handler, true);\r\n}\r\ncall_all(dev, video, s_std, dev->norm);\r\ncx231xx_do_mode_ctrl_overrides(dev);\r\ndprintk(3, "exit vidioc_s_std() i=0x%x\n", i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\ndprintk(3, "enter vidioc_s_ctrl()\n");\r\ncall_all(dev, core, s_ctrl, ctl);\r\ndprintk(3, "exit vidioc_s_ctrl()\n");\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "MPEG", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\ndprintk(3, "enter vidioc_g_fmt_vid_cap()\n");\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = mpeglines * mpeglinesize;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.width = dev->ts1.width;\r\nf->fmt.pix.height = dev->ts1.height;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\ndprintk(1, "VIDIOC_G_FMT: w: %d, h: %d\n",\r\ndev->ts1.width, dev->ts1.height);\r\ndprintk(3, "exit vidioc_g_fmt_vid_cap()\n");\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\ndprintk(3, "enter vidioc_try_fmt_vid_cap()\n");\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage = mpeglines * mpeglinesize;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\ndprintk(1, "VIDIOC_TRY_FMT: w: %d, h: %d\n",\r\ndev->ts1.width, dev->ts1.height);\r\ndprintk(3, "exit vidioc_try_fmt_vid_cap()\n");\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nreturn videobuf_reqbufs(&fh->vidq, p);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nreturn videobuf_querybuf(&fh->vidq, p);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nreturn videobuf_qbuf(&fh->vidq, p);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nreturn videobuf_dqbuf(&fh->vidq, b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\ndprintk(3, "enter vidioc_streamon()\n");\r\ncx231xx_set_alt_setting(dev, INDEX_TS1, 0);\r\ncx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\r\nif (dev->USE_ISO)\r\ncx231xx_init_isoc(dev, CX231XX_NUM_PACKETS,\r\nCX231XX_NUM_BUFS,\r\ndev->video_mode.max_pkt_size,\r\ncx231xx_isoc_copy);\r\nelse {\r\ncx231xx_init_bulk(dev, 320,\r\n5,\r\ndev->ts1_mode.max_pkt_size,\r\ncx231xx_bulk_copy);\r\n}\r\ndprintk(3, "exit vidioc_streamon()\n");\r\nreturn videobuf_streamon(&fh->vidq);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nreturn videobuf_streamoff(&fh->vidq);\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct cx231xx_fh *fh = priv;\r\nstruct cx231xx *dev = fh->dev;\r\ncall_all(dev, core, log_status);\r\nreturn v4l2_ctrl_log_status(file, priv);\r\n}\r\nstatic int mpeg_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct cx231xx *dev = video_drvdata(file);\r\nstruct cx231xx_fh *fh;\r\ndprintk(2, "%s()\n", __func__);\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (NULL == fh) {\r\nmutex_unlock(&dev->lock);\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = fh;\r\nv4l2_fh_init(&fh->fh, vdev);\r\nfh->dev = dev;\r\nvideobuf_queue_vmalloc_init(&fh->vidq, &cx231xx_qops,\r\nNULL, &dev->video_mode.slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_INTERLACED,\r\nsizeof(struct cx231xx_buffer), fh, &dev->lock);\r\ncx231xx_set_alt_setting(dev, INDEX_VANC, 1);\r\ncx231xx_set_gpio_value(dev, 2, 0);\r\ncx231xx_initialize_codec(dev);\r\nmutex_unlock(&dev->lock);\r\nv4l2_fh_add(&fh->fh);\r\ncx231xx_start_TS1(dev);\r\nreturn 0;\r\n}\r\nstatic int mpeg_release(struct file *file)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\ndprintk(3, "mpeg_release()! dev=0x%p\n", dev);\r\nmutex_lock(&dev->lock);\r\ncx231xx_stop_TS1(dev);\r\nif (dev->USE_ISO)\r\ncx231xx_uninit_isoc(dev);\r\nelse\r\ncx231xx_uninit_bulk(dev);\r\ncx231xx_set_mode(dev, CX231XX_SUSPEND);\r\ncx231xx_api_cmd(fh->dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\r\nCX231xx_END_NOW, CX231xx_MPEG_CAPTURE,\r\nCX231xx_RAW_BITS_NONE);\r\nif (atomic_cmpxchg(&fh->v4l_reading, 1, 0) == 1) {\r\nif (atomic_dec_return(&dev->v4l_reader_count) == 0) {\r\nmsleep(500);\r\ncx231xx_417_check_encoder(dev);\r\n}\r\n}\r\nif (fh->vidq.streaming)\r\nvideobuf_streamoff(&fh->vidq);\r\nif (fh->vidq.reading)\r\nvideobuf_read_stop(&fh->vidq);\r\nvideobuf_mmap_free(&fh->vidq);\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nkfree(fh);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t mpeg_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nif (atomic_cmpxchg(&fh->v4l_reading, 0, 1) == 0) {\r\nif (atomic_inc_return(&dev->v4l_reader_count) == 1) {\r\nif (cx231xx_initialize_codec(dev) < 0)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn videobuf_read_stream(&fh->vidq, data, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic unsigned int mpeg_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\nunsigned int res = 0;\r\nif (v4l2_event_pending(&fh->fh))\r\nres |= POLLPRI;\r\nelse\r\npoll_wait(file, &fh->fh.wait, wait);\r\nif (!(req_events & (POLLIN | POLLRDNORM)))\r\nreturn res;\r\nmutex_lock(&dev->lock);\r\nres |= videobuf_poll_stream(file, &fh->vidq, wait);\r\nmutex_unlock(&dev->lock);\r\nreturn res;\r\n}\r\nstatic int mpeg_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct cx231xx_fh *fh = file->private_data;\r\nstruct cx231xx *dev = fh->dev;\r\ndprintk(2, "%s()\n", __func__);\r\nreturn videobuf_mmap_mapper(&fh->vidq, vma);\r\n}\r\nvoid cx231xx_417_unregister(struct cx231xx *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\ndprintk(3, "%s()\n", __func__);\r\nif (dev->v4l_device) {\r\nif (-1 != dev->v4l_device->minor)\r\nvideo_unregister_device(dev->v4l_device);\r\nelse\r\nvideo_device_release(dev->v4l_device);\r\nv4l2_ctrl_handler_free(&dev->mpeg_ctrl_handler.hdl);\r\ndev->v4l_device = NULL;\r\n}\r\n}\r\nstatic int cx231xx_s_video_encoding(struct cx2341x_handler *cxhdl, u32 val)\r\n{\r\nstruct cx231xx *dev = container_of(cxhdl, struct cx231xx, mpeg_ctrl_handler);\r\nint is_mpeg1 = val == V4L2_MPEG_VIDEO_ENCODING_MPEG_1;\r\nstruct v4l2_mbus_framefmt fmt;\r\nfmt.width = cxhdl->width / (is_mpeg1 ? 2 : 1);\r\nfmt.height = cxhdl->height;\r\nfmt.code = V4L2_MBUS_FMT_FIXED;\r\nv4l2_subdev_call(dev->sd_cx25840, video, s_mbus_fmt, &fmt);\r\nreturn 0;\r\n}\r\nstatic int cx231xx_s_audio_sampling_freq(struct cx2341x_handler *cxhdl, u32 idx)\r\n{\r\nstatic const u32 freqs[3] = { 44100, 48000, 32000 };\r\nstruct cx231xx *dev = container_of(cxhdl, struct cx231xx, mpeg_ctrl_handler);\r\nif (idx < ARRAY_SIZE(freqs))\r\ncall_all(dev, audio, s_clock_freq, freqs[idx]);\r\nreturn 0;\r\n}\r\nstatic struct video_device *cx231xx_video_dev_alloc(\r\nstruct cx231xx *dev,\r\nstruct usb_device *usbdev,\r\nstruct video_device *template,\r\nchar *type)\r\n{\r\nstruct video_device *vfd;\r\ndprintk(1, "%s()\n", __func__);\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s (%s)", dev->name,\r\ntype, cx231xx_boards[dev->model].name);\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->lock = &dev->lock;\r\nvfd->release = video_device_release;\r\nvfd->ctrl_handler = &dev->mpeg_ctrl_handler.hdl;\r\nvideo_set_drvdata(vfd, dev);\r\nif (dev->tuner_type == TUNER_ABSENT) {\r\nv4l2_disable_ioctl(vfd, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(vfd, VIDIOC_S_FREQUENCY);\r\nv4l2_disable_ioctl(vfd, VIDIOC_G_TUNER);\r\nv4l2_disable_ioctl(vfd, VIDIOC_S_TUNER);\r\n}\r\nreturn vfd;\r\n}\r\nint cx231xx_417_register(struct cx231xx *dev)\r\n{\r\nint err = -ENODEV;\r\nstruct cx231xx_tsport *tsport = &dev->ts1;\r\ndprintk(1, "%s()\n", __func__);\r\ndev->encodernorm = cx231xx_tvnorms[0];\r\nif (dev->encodernorm.id & V4L2_STD_525_60)\r\ntsport->height = 480;\r\nelse\r\ntsport->height = 576;\r\ntsport->width = 720;\r\nerr = cx2341x_handler_init(&dev->mpeg_ctrl_handler, 50);\r\nif (err) {\r\ndprintk(3, "%s: can't init cx2341x controls\n", dev->name);\r\nreturn err;\r\n}\r\ndev->mpeg_ctrl_handler.func = cx231xx_mbox_func;\r\ndev->mpeg_ctrl_handler.priv = dev;\r\ndev->mpeg_ctrl_handler.ops = &cx231xx_ops;\r\nif (dev->sd_cx25840)\r\nv4l2_ctrl_add_handler(&dev->mpeg_ctrl_handler.hdl,\r\ndev->sd_cx25840->ctrl_handler, NULL);\r\nif (dev->mpeg_ctrl_handler.hdl.error) {\r\nerr = dev->mpeg_ctrl_handler.hdl.error;\r\ndprintk(3, "%s: can't add cx25840 controls\n", dev->name);\r\nv4l2_ctrl_handler_free(&dev->mpeg_ctrl_handler.hdl);\r\nreturn err;\r\n}\r\ndev->norm = V4L2_STD_NTSC;\r\ndev->mpeg_ctrl_handler.port = CX2341X_PORT_SERIAL;\r\ncx2341x_handler_set_50hz(&dev->mpeg_ctrl_handler, false);\r\ndev->v4l_device = cx231xx_video_dev_alloc(dev,\r\ndev->udev, &cx231xx_mpeg_template, "mpeg");\r\nerr = video_register_device(dev->v4l_device,\r\nVFL_TYPE_GRABBER, -1);\r\nif (err < 0) {\r\ndprintk(3, "%s: can't register mpeg device\n", dev->name);\r\nv4l2_ctrl_handler_free(&dev->mpeg_ctrl_handler.hdl);\r\nreturn err;\r\n}\r\ndprintk(3, "%s: registered device video%d [mpeg]\n",\r\ndev->name, dev->v4l_device->num);\r\nreturn 0;\r\n}
