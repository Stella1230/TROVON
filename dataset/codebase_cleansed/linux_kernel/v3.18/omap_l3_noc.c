static int l3_handle_target(struct omap_l3 *l3, void __iomem *base,\r\nstruct l3_flagmux_data *flag_mux, int err_src)\r\n{\r\nint k;\r\nu32 std_err_main, clear, masterid;\r\nu8 op_code, m_req_info;\r\nvoid __iomem *l3_targ_base;\r\nvoid __iomem *l3_targ_stderr, *l3_targ_slvofslsb, *l3_targ_mstaddr;\r\nvoid __iomem *l3_targ_hdr, *l3_targ_info;\r\nstruct l3_target_data *l3_targ_inst;\r\nstruct l3_masters_data *master;\r\nchar *target_name, *master_name = "UN IDENTIFIED";\r\nchar *err_description;\r\nchar err_string[30] = { 0 };\r\nchar info_string[60] = { 0 };\r\nBUG_ON(err_src > MAX_CLKDM_TARGETS);\r\nif (err_src < flag_mux->num_targ_data) {\r\nl3_targ_inst = &flag_mux->l3_targ[err_src];\r\ntarget_name = l3_targ_inst->name;\r\nl3_targ_base = base + l3_targ_inst->offset;\r\n} else {\r\ntarget_name = L3_TARGET_NOT_SUPPORTED;\r\n}\r\nif (target_name == L3_TARGET_NOT_SUPPORTED)\r\nreturn -ENODEV;\r\nl3_targ_stderr = l3_targ_base + L3_TARG_STDERRLOG_MAIN;\r\nl3_targ_slvofslsb = l3_targ_base + L3_TARG_STDERRLOG_SLVOFSLSB;\r\nstd_err_main = readl_relaxed(l3_targ_stderr);\r\nswitch (std_err_main & CUSTOM_ERROR) {\r\ncase STANDARD_ERROR:\r\nerr_description = "Standard";\r\nsnprintf(err_string, sizeof(err_string),\r\n": At Address: 0x%08X ",\r\nreadl_relaxed(l3_targ_slvofslsb));\r\nl3_targ_mstaddr = l3_targ_base + L3_TARG_STDERRLOG_MSTADDR;\r\nl3_targ_hdr = l3_targ_base + L3_TARG_STDERRLOG_HDR;\r\nl3_targ_info = l3_targ_base + L3_TARG_STDERRLOG_INFO;\r\nbreak;\r\ncase CUSTOM_ERROR:\r\nerr_description = "Custom";\r\nl3_targ_mstaddr = l3_targ_base +\r\nL3_TARG_STDERRLOG_CINFO_MSTADDR;\r\nl3_targ_hdr = l3_targ_base + L3_TARG_STDERRLOG_CINFO_OPCODE;\r\nl3_targ_info = l3_targ_base + L3_TARG_STDERRLOG_CINFO_INFO;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nmasterid = (readl_relaxed(l3_targ_mstaddr) &\r\nl3->mst_addr_mask) >> __ffs(l3->mst_addr_mask);\r\nfor (k = 0, master = l3->l3_masters; k < l3->num_masters;\r\nk++, master++) {\r\nif (masterid == master->id) {\r\nmaster_name = master->name;\r\nbreak;\r\n}\r\n}\r\nop_code = readl_relaxed(l3_targ_hdr) & 0x7;\r\nm_req_info = readl_relaxed(l3_targ_info) & 0xF;\r\nsnprintf(info_string, sizeof(info_string),\r\n": %s in %s mode during %s access",\r\n(m_req_info & BIT(0)) ? "Opcode Fetch" : "Data Access",\r\n(m_req_info & BIT(1)) ? "Supervisor" : "User",\r\n(m_req_info & BIT(3)) ? "Debug" : "Functional");\r\nWARN(true,\r\n"%s:L3 %s Error: MASTER %s TARGET %s (%s)%s%s\n",\r\ndev_name(l3->dev),\r\nerr_description,\r\nmaster_name, target_name,\r\nl3_transaction_type[op_code],\r\nerr_string, info_string);\r\nclear = std_err_main | CLEAR_STDERR_LOG;\r\nwritel_relaxed(clear, l3_targ_stderr);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t l3_interrupt_handler(int irq, void *_l3)\r\n{\r\nstruct omap_l3 *l3 = _l3;\r\nint inttype, i, ret;\r\nint err_src = 0;\r\nu32 err_reg, mask_val;\r\nvoid __iomem *base, *mask_reg;\r\nstruct l3_flagmux_data *flag_mux;\r\ninttype = irq == l3->app_irq ? L3_APPLICATION_ERROR : L3_DEBUG_ERROR;\r\nfor (i = 0; i < l3->num_modules; i++) {\r\nbase = l3->l3_base[i];\r\nflag_mux = l3->l3_flagmux[i];\r\nerr_reg = readl_relaxed(base + flag_mux->offset +\r\nL3_FLAGMUX_REGERR0 + (inttype << 3));\r\nerr_reg &= ~(inttype ? flag_mux->mask_app_bits :\r\nflag_mux->mask_dbg_bits);\r\nif (err_reg) {\r\nerr_src = __ffs(err_reg);\r\nret = l3_handle_target(l3, base, flag_mux, err_src);\r\nif (ret) {\r\ndev_err(l3->dev,\r\n"L3 %s error: target %d mod:%d %s\n",\r\ninttype ? "debug" : "application",\r\nerr_src, i, "(unclearable)");\r\nmask_reg = base + flag_mux->offset +\r\nL3_FLAGMUX_MASK0 + (inttype << 3);\r\nmask_val = readl_relaxed(mask_reg);\r\nmask_val &= ~(1 << err_src);\r\nwritel_relaxed(mask_val, mask_reg);\r\nif (inttype)\r\nflag_mux->mask_app_bits |= 1 << err_src;\r\nelse\r\nflag_mux->mask_dbg_bits |= 1 << err_src;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap_l3_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id;\r\nstatic struct omap_l3 *l3;\r\nint ret, i, res_idx;\r\nof_id = of_match_device(l3_noc_match, &pdev->dev);\r\nif (!of_id) {\r\ndev_err(&pdev->dev, "OF data missing\n");\r\nreturn -EINVAL;\r\n}\r\nl3 = devm_kzalloc(&pdev->dev, sizeof(*l3), GFP_KERNEL);\r\nif (!l3)\r\nreturn -ENOMEM;\r\nmemcpy(l3, of_id->data, sizeof(*l3));\r\nl3->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, l3);\r\nfor (i = 0, res_idx = 0; i < l3->num_modules; i++) {\r\nstruct resource *res;\r\nif (l3->l3_base[i] == L3_BASE_IS_SUBMODULE) {\r\nBUG_ON(i == 0);\r\nl3->l3_base[i] = l3->l3_base[i - 1];\r\ncontinue;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, res_idx);\r\nl3->l3_base[i] = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(l3->l3_base[i])) {\r\ndev_err(l3->dev, "ioremap %d failed\n", i);\r\nreturn PTR_ERR(l3->l3_base[i]);\r\n}\r\nres_idx++;\r\n}\r\nl3->debug_irq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(l3->dev, l3->debug_irq, l3_interrupt_handler,\r\nIRQF_DISABLED, "l3-dbg-irq", l3);\r\nif (ret) {\r\ndev_err(l3->dev, "request_irq failed for %d\n",\r\nl3->debug_irq);\r\nreturn ret;\r\n}\r\nl3->app_irq = platform_get_irq(pdev, 1);\r\nret = devm_request_irq(l3->dev, l3->app_irq, l3_interrupt_handler,\r\nIRQF_DISABLED, "l3-app-irq", l3);\r\nif (ret)\r\ndev_err(l3->dev, "request_irq failed for %d\n", l3->app_irq);\r\nreturn ret;\r\n}\r\nstatic int __init omap_l3_init(void)\r\n{\r\nreturn platform_driver_register(&omap_l3_driver);\r\n}\r\nstatic void __exit omap_l3_exit(void)\r\n{\r\nplatform_driver_unregister(&omap_l3_driver);\r\n}
