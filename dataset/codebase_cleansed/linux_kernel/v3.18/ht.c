static void __check_htcap_disable(struct ieee80211_ht_cap *ht_capa,\r\nstruct ieee80211_ht_cap *ht_capa_mask,\r\nstruct ieee80211_sta_ht_cap *ht_cap,\r\nu16 flag)\r\n{\r\n__le16 le_flag = cpu_to_le16(flag);\r\nif (ht_capa_mask->cap_info & le_flag) {\r\nif (!(ht_capa->cap_info & le_flag))\r\nht_cap->cap &= ~flag;\r\n}\r\n}\r\nstatic void __check_htcap_enable(struct ieee80211_ht_cap *ht_capa,\r\nstruct ieee80211_ht_cap *ht_capa_mask,\r\nstruct ieee80211_sta_ht_cap *ht_cap,\r\nu16 flag)\r\n{\r\n__le16 le_flag = cpu_to_le16(flag);\r\nif ((ht_capa_mask->cap_info & le_flag) &&\r\n(ht_capa->cap_info & le_flag))\r\nht_cap->cap |= flag;\r\n}\r\nvoid ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_sta_ht_cap *ht_cap)\r\n{\r\nstruct ieee80211_ht_cap *ht_capa, *ht_capa_mask;\r\nu8 *scaps, *smask;\r\nint i;\r\nif (!ht_cap->ht_supported)\r\nreturn;\r\nswitch (sdata->vif.type) {\r\ncase NL80211_IFTYPE_STATION:\r\nht_capa = &sdata->u.mgd.ht_capa;\r\nht_capa_mask = &sdata->u.mgd.ht_capa_mask;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nht_capa = &sdata->u.ibss.ht_capa;\r\nht_capa_mask = &sdata->u.ibss.ht_capa_mask;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\nscaps = (u8 *)(&ht_capa->mcs.rx_mask);\r\nsmask = (u8 *)(&ht_capa_mask->mcs.rx_mask);\r\nfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\r\nu8 m = smask[i];\r\nht_cap->mcs.rx_mask[i] &= ~m;\r\nht_cap->mcs.rx_mask[i] |= (m & scaps[i]);\r\n}\r\n__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\r\nIEEE80211_HT_CAP_SUP_WIDTH_20_40);\r\n__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\r\nIEEE80211_HT_CAP_SGI_40);\r\n__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\r\nIEEE80211_HT_CAP_SGI_20);\r\n__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\r\nIEEE80211_HT_CAP_MAX_AMSDU);\r\n__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\r\nIEEE80211_HT_CAP_LDPC_CODING);\r\n__check_htcap_enable(ht_capa, ht_capa_mask, ht_cap,\r\nIEEE80211_HT_CAP_40MHZ_INTOLERANT);\r\nif (ht_capa_mask->ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR) {\r\nu8 n = ht_capa->ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR;\r\nif (n < ht_cap->ampdu_factor)\r\nht_cap->ampdu_factor = n;\r\n}\r\nif (ht_capa_mask->ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY) {\r\nu8 n = (ht_capa->ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY)\r\n>> IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT;\r\nif (n > ht_cap->ampdu_density)\r\nht_cap->ampdu_density = n;\r\n}\r\n}\r\nbool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_supported_band *sband,\r\nconst struct ieee80211_ht_cap *ht_cap_ie,\r\nstruct sta_info *sta)\r\n{\r\nstruct ieee80211_sta_ht_cap ht_cap, own_cap;\r\nu8 ampdu_info, tx_mcs_set_cap;\r\nint i, max_tx_streams;\r\nbool changed;\r\nenum ieee80211_sta_rx_bandwidth bw;\r\nenum ieee80211_smps_mode smps_mode;\r\nmemset(&ht_cap, 0, sizeof(ht_cap));\r\nif (!ht_cap_ie || !sband->ht_cap.ht_supported)\r\ngoto apply;\r\nht_cap.ht_supported = true;\r\nown_cap = sband->ht_cap;\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION ||\r\nsdata->vif.type == NL80211_IFTYPE_ADHOC)\r\nieee80211_apply_htcap_overrides(sdata, &own_cap);\r\nht_cap.cap = le16_to_cpu(ht_cap_ie->cap_info) &\r\n(own_cap.cap | ~(IEEE80211_HT_CAP_LDPC_CODING |\r\nIEEE80211_HT_CAP_SUP_WIDTH_20_40 |\r\nIEEE80211_HT_CAP_GRN_FLD |\r\nIEEE80211_HT_CAP_SGI_20 |\r\nIEEE80211_HT_CAP_SGI_40 |\r\nIEEE80211_HT_CAP_DSSSCCK40));\r\nif (!(own_cap.cap & IEEE80211_HT_CAP_TX_STBC))\r\nht_cap.cap &= ~IEEE80211_HT_CAP_RX_STBC;\r\nif (!(own_cap.cap & IEEE80211_HT_CAP_RX_STBC))\r\nht_cap.cap &= ~IEEE80211_HT_CAP_TX_STBC;\r\nampdu_info = ht_cap_ie->ampdu_params_info;\r\nht_cap.ampdu_factor =\r\nampdu_info & IEEE80211_HT_AMPDU_PARM_FACTOR;\r\nht_cap.ampdu_density =\r\n(ampdu_info & IEEE80211_HT_AMPDU_PARM_DENSITY) >> 2;\r\ntx_mcs_set_cap = own_cap.mcs.tx_params;\r\nht_cap.mcs.tx_params = ht_cap_ie->mcs.tx_params;\r\nif (!(tx_mcs_set_cap & IEEE80211_HT_MCS_TX_DEFINED))\r\ngoto apply;\r\nif (tx_mcs_set_cap & IEEE80211_HT_MCS_TX_RX_DIFF)\r\nmax_tx_streams =\r\n((tx_mcs_set_cap & IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK)\r\n>> IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT) + 1;\r\nelse\r\nmax_tx_streams = IEEE80211_HT_MCS_TX_MAX_STREAMS;\r\nfor (i = 0; i < max_tx_streams; i++)\r\nht_cap.mcs.rx_mask[i] =\r\nown_cap.mcs.rx_mask[i] & ht_cap_ie->mcs.rx_mask[i];\r\nif (tx_mcs_set_cap & IEEE80211_HT_MCS_TX_UNEQUAL_MODULATION)\r\nfor (i = IEEE80211_HT_MCS_UNEQUAL_MODULATION_START_BYTE;\r\ni < IEEE80211_HT_MCS_MASK_LEN; i++)\r\nht_cap.mcs.rx_mask[i] =\r\nown_cap.mcs.rx_mask[i] &\r\nht_cap_ie->mcs.rx_mask[i];\r\nif (own_cap.mcs.rx_mask[32/8] & ht_cap_ie->mcs.rx_mask[32/8] & 1)\r\nht_cap.mcs.rx_mask[32/8] |= 1;\r\nht_cap.mcs.rx_highest = ht_cap_ie->mcs.rx_highest;\r\napply:\r\nchanged = memcmp(&sta->sta.ht_cap, &ht_cap, sizeof(ht_cap));\r\nmemcpy(&sta->sta.ht_cap, &ht_cap, sizeof(ht_cap));\r\nswitch (sdata->vif.bss_conf.chandef.width) {\r\ndefault:\r\nWARN_ON_ONCE(1);\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\ncase NL80211_CHAN_WIDTH_20:\r\nbw = IEEE80211_STA_RX_BW_20;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\ncase NL80211_CHAN_WIDTH_80:\r\ncase NL80211_CHAN_WIDTH_80P80:\r\ncase NL80211_CHAN_WIDTH_160:\r\nbw = ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?\r\nIEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;\r\nbreak;\r\n}\r\nif (bw != sta->sta.bandwidth)\r\nchanged = true;\r\nsta->sta.bandwidth = bw;\r\nsta->cur_max_bandwidth =\r\nht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?\r\nIEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;\r\nswitch ((ht_cap.cap & IEEE80211_HT_CAP_SM_PS)\r\n>> IEEE80211_HT_CAP_SM_PS_SHIFT) {\r\ncase WLAN_HT_CAP_SM_PS_INVALID:\r\ncase WLAN_HT_CAP_SM_PS_STATIC:\r\nsmps_mode = IEEE80211_SMPS_STATIC;\r\nbreak;\r\ncase WLAN_HT_CAP_SM_PS_DYNAMIC:\r\nsmps_mode = IEEE80211_SMPS_DYNAMIC;\r\nbreak;\r\ncase WLAN_HT_CAP_SM_PS_DISABLED:\r\nsmps_mode = IEEE80211_SMPS_OFF;\r\nbreak;\r\n}\r\nif (smps_mode != sta->sta.smps_mode)\r\nchanged = true;\r\nsta->sta.smps_mode = smps_mode;\r\nreturn changed;\r\n}\r\nvoid ieee80211_sta_tear_down_BA_sessions(struct sta_info *sta,\r\nenum ieee80211_agg_stop_reason reason)\r\n{\r\nint i;\r\ncancel_work_sync(&sta->ampdu_mlme.work);\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\r\n__ieee80211_stop_tx_ba_session(sta, i, reason);\r\n__ieee80211_stop_rx_ba_session(sta, i, WLAN_BACK_RECIPIENT,\r\nWLAN_REASON_QSTA_LEAVE_QBSS,\r\nreason != AGG_STOP_DESTROY_STA &&\r\nreason != AGG_STOP_PEER_REQUEST);\r\n}\r\n}\r\nvoid ieee80211_ba_session_work(struct work_struct *work)\r\n{\r\nstruct sta_info *sta =\r\ncontainer_of(work, struct sta_info, ampdu_mlme.work);\r\nstruct tid_ampdu_tx *tid_tx;\r\nint tid;\r\nif (test_sta_flag(sta, WLAN_STA_BLOCK_BA))\r\nreturn;\r\nmutex_lock(&sta->ampdu_mlme.mtx);\r\nfor (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {\r\nif (test_and_clear_bit(tid, sta->ampdu_mlme.tid_rx_timer_expired))\r\n___ieee80211_stop_rx_ba_session(\r\nsta, tid, WLAN_BACK_RECIPIENT,\r\nWLAN_REASON_QSTA_TIMEOUT, true);\r\nif (test_and_clear_bit(tid,\r\nsta->ampdu_mlme.tid_rx_stop_requested))\r\n___ieee80211_stop_rx_ba_session(\r\nsta, tid, WLAN_BACK_RECIPIENT,\r\nWLAN_REASON_UNSPECIFIED, true);\r\nspin_lock_bh(&sta->lock);\r\ntid_tx = sta->ampdu_mlme.tid_start_tx[tid];\r\nif (tid_tx) {\r\nsta->ampdu_mlme.tid_start_tx[tid] = NULL;\r\nif (sta->ampdu_mlme.tid_tx[tid])\r\nkfree(tid_tx);\r\nelse\r\nieee80211_assign_tid_tx(sta, tid, tid_tx);\r\nspin_unlock_bh(&sta->lock);\r\nieee80211_tx_ba_session_handle_start(sta, tid);\r\ncontinue;\r\n}\r\nspin_unlock_bh(&sta->lock);\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nif (tid_tx && test_and_clear_bit(HT_AGG_STATE_WANT_STOP,\r\n&tid_tx->state))\r\n___ieee80211_stop_tx_ba_session(sta, tid,\r\nAGG_STOP_LOCAL_REQUEST);\r\n}\r\nmutex_unlock(&sta->ampdu_mlme.mtx);\r\n}\r\nvoid ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *da, u16 tid,\r\nu16 initiator, u16 reason_code)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_mgmt *mgmt;\r\nu16 params;\r\nskb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nmgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);\r\nmemset(mgmt, 0, 24);\r\nmemcpy(mgmt->da, da, ETH_ALEN);\r\nmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\r\nif (sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\r\nsdata->vif.type == NL80211_IFTYPE_MESH_POINT)\r\nmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\r\nelse if (sdata->vif.type == NL80211_IFTYPE_STATION)\r\nmemcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);\r\nelse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\r\nmemcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\nskb_put(skb, 1 + sizeof(mgmt->u.action.u.delba));\r\nmgmt->u.action.category = WLAN_CATEGORY_BACK;\r\nmgmt->u.action.u.delba.action_code = WLAN_ACTION_DELBA;\r\nparams = (u16)(initiator << 11);\r\nparams |= (u16)(tid << 12);\r\nmgmt->u.action.u.delba.params = cpu_to_le16(params);\r\nmgmt->u.action.u.delba.reason_code = cpu_to_le16(reason_code);\r\nieee80211_tx_skb(sdata, skb);\r\n}\r\nvoid ieee80211_process_delba(struct ieee80211_sub_if_data *sdata,\r\nstruct sta_info *sta,\r\nstruct ieee80211_mgmt *mgmt, size_t len)\r\n{\r\nu16 tid, params;\r\nu16 initiator;\r\nparams = le16_to_cpu(mgmt->u.action.u.delba.params);\r\ntid = (params & IEEE80211_DELBA_PARAM_TID_MASK) >> 12;\r\ninitiator = (params & IEEE80211_DELBA_PARAM_INITIATOR_MASK) >> 11;\r\nht_dbg_ratelimited(sdata, "delba from %pM (%s) tid %d reason code %d\n",\r\nmgmt->sa, initiator ? "initiator" : "recipient",\r\ntid,\r\nle16_to_cpu(mgmt->u.action.u.delba.reason_code));\r\nif (initiator == WLAN_BACK_INITIATOR)\r\n__ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_INITIATOR, 0,\r\ntrue);\r\nelse\r\n__ieee80211_stop_tx_ba_session(sta, tid, AGG_STOP_PEER_REQUEST);\r\n}\r\nint ieee80211_send_smps_action(struct ieee80211_sub_if_data *sdata,\r\nenum ieee80211_smps_mode smps, const u8 *da,\r\nconst u8 *bssid)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_mgmt *action_frame;\r\nskb = dev_alloc_skb(27 + local->hw.extra_tx_headroom);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\naction_frame = (void *)skb_put(skb, 27);\r\nmemcpy(action_frame->da, da, ETH_ALEN);\r\nmemcpy(action_frame->sa, sdata->dev->dev_addr, ETH_ALEN);\r\nmemcpy(action_frame->bssid, bssid, ETH_ALEN);\r\naction_frame->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\naction_frame->u.action.category = WLAN_CATEGORY_HT;\r\naction_frame->u.action.u.ht_smps.action = WLAN_HT_ACTION_SMPS;\r\nswitch (smps) {\r\ncase IEEE80211_SMPS_AUTOMATIC:\r\ncase IEEE80211_SMPS_NUM_MODES:\r\nWARN_ON(1);\r\ncase IEEE80211_SMPS_OFF:\r\naction_frame->u.action.u.ht_smps.smps_control =\r\nWLAN_HT_SMPS_CONTROL_DISABLED;\r\nbreak;\r\ncase IEEE80211_SMPS_STATIC:\r\naction_frame->u.action.u.ht_smps.smps_control =\r\nWLAN_HT_SMPS_CONTROL_STATIC;\r\nbreak;\r\ncase IEEE80211_SMPS_DYNAMIC:\r\naction_frame->u.action.u.ht_smps.smps_control =\r\nWLAN_HT_SMPS_CONTROL_DYNAMIC;\r\nbreak;\r\n}\r\nIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\r\nieee80211_tx_skb(sdata, skb);\r\nreturn 0;\r\n}\r\nvoid ieee80211_request_smps_mgd_work(struct work_struct *work)\r\n{\r\nstruct ieee80211_sub_if_data *sdata =\r\ncontainer_of(work, struct ieee80211_sub_if_data,\r\nu.mgd.request_smps_work);\r\nsdata_lock(sdata);\r\n__ieee80211_request_smps_mgd(sdata, sdata->u.mgd.driver_smps_mode);\r\nsdata_unlock(sdata);\r\n}\r\nvoid ieee80211_request_smps_ap_work(struct work_struct *work)\r\n{\r\nstruct ieee80211_sub_if_data *sdata =\r\ncontainer_of(work, struct ieee80211_sub_if_data,\r\nu.ap.request_smps_work);\r\nsdata_lock(sdata);\r\nif (sdata_dereference(sdata->u.ap.beacon, sdata))\r\n__ieee80211_request_smps_ap(sdata,\r\nsdata->u.ap.driver_smps_mode);\r\nsdata_unlock(sdata);\r\n}\r\nvoid ieee80211_request_smps(struct ieee80211_vif *vif,\r\nenum ieee80211_smps_mode smps_mode)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nif (WARN_ON_ONCE(vif->type != NL80211_IFTYPE_STATION &&\r\nvif->type != NL80211_IFTYPE_AP))\r\nreturn;\r\nif (vif->type == NL80211_IFTYPE_STATION) {\r\nif (sdata->u.mgd.driver_smps_mode == smps_mode)\r\nreturn;\r\nsdata->u.mgd.driver_smps_mode = smps_mode;\r\nieee80211_queue_work(&sdata->local->hw,\r\n&sdata->u.mgd.request_smps_work);\r\n} else {\r\nif (WARN_ON_ONCE(smps_mode == IEEE80211_SMPS_AUTOMATIC))\r\nreturn;\r\nif (sdata->u.ap.driver_smps_mode == smps_mode)\r\nreturn;\r\nsdata->u.ap.driver_smps_mode = smps_mode;\r\nieee80211_queue_work(&sdata->local->hw,\r\n&sdata->u.ap.request_smps_work);\r\n}\r\n}
