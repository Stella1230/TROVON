static void ixgbe_ptp_setup_sdp(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint shift = adapter->cc.shift;\r\nu32 esdp, tsauxc, clktiml, clktimh, trgttiml, trgttimh, rem;\r\nu64 ns = 0, clock_edge = 0;\r\nif ((adapter->flags2 & IXGBE_FLAG2_PTP_PPS_ENABLED) &&\r\n(hw->mac.type == ixgbe_mac_X540)) {\r\nIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, 0x0);\r\nIXGBE_WRITE_FLUSH(hw);\r\nesdp = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nesdp |= (IXGBE_ESDP_SDP0_DIR |\r\nIXGBE_ESDP_SDP0_NATIVE);\r\ntsauxc = (IXGBE_TSAUXC_EN_CLK |\r\nIXGBE_TSAUXC_SYNCLK |\r\nIXGBE_TSAUXC_SDP0_INT);\r\nclktiml = (u32)(IXGBE_PTP_PPS_HALF_SECOND << shift);\r\nclktimh = (u32)((IXGBE_PTP_PPS_HALF_SECOND << shift) >> 32);\r\nclock_edge |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIML);\r\nclock_edge |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIMH) << 32;\r\nns = timecounter_cyc2time(&adapter->tc, clock_edge);\r\ndiv_u64_rem(ns, IXGBE_PTP_PPS_HALF_SECOND, &rem);\r\nclock_edge += ((IXGBE_PTP_PPS_HALF_SECOND - (u64)rem) << shift);\r\ntrgttiml = (u32)clock_edge;\r\ntrgttimh = (u32)(clock_edge >> 32);\r\nIXGBE_WRITE_REG(hw, IXGBE_CLKTIML, clktiml);\r\nIXGBE_WRITE_REG(hw, IXGBE_CLKTIMH, clktimh);\r\nIXGBE_WRITE_REG(hw, IXGBE_TRGTTIML0, trgttiml);\r\nIXGBE_WRITE_REG(hw, IXGBE_TRGTTIMH0, trgttimh);\r\nIXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);\r\nIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, tsauxc);\r\n} else {\r\nIXGBE_WRITE_REG(hw, IXGBE_TSAUXC, 0x0);\r\n}\r\nIXGBE_WRITE_FLUSH(hw);\r\n}\r\nstatic cycle_t ixgbe_ptp_read(const struct cyclecounter *cc)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(cc, struct ixgbe_adapter, cc);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu64 stamp = 0;\r\nstamp |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIML);\r\nstamp |= (u64)IXGBE_READ_REG(hw, IXGBE_SYSTIMH) << 32;\r\nreturn stamp;\r\n}\r\nstatic int ixgbe_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu64 freq;\r\nu32 diff, incval;\r\nint neg_adj = 0;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nsmp_mb();\r\nincval = ACCESS_ONCE(adapter->base_incval);\r\nfreq = incval;\r\nfreq *= ppb;\r\ndiff = div_u64(freq, 1000000000ULL);\r\nincval = neg_adj ? (incval - diff) : (incval + diff);\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X540:\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA, incval);\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA,\r\n(1 << IXGBE_INCPER_SHIFT_82599) |\r\nincval);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nunsigned long flags;\r\nu64 now;\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nnow = timecounter_read(&adapter->tc);\r\nnow += delta;\r\ntimecounter_init(&adapter->tc,\r\n&adapter->cc,\r\nnow);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nixgbe_ptp_setup_sdp(adapter);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nu64 ns;\r\nu32 remainder;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nns = timecounter_read(&adapter->tc);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nts->tv_sec = div_u64_rem(ns, 1000000000ULL, &remainder);\r\nts->tv_nsec = remainder;\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec *ts)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nu64 ns;\r\nunsigned long flags;\r\nns = ts->tv_sec * 1000000000ULL;\r\nns += ts->tv_nsec;\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\ntimecounter_init(&adapter->tc, &adapter->cc, ns);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nixgbe_ptp_setup_sdp(adapter);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_ptp_feature_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct ixgbe_adapter *adapter =\r\ncontainer_of(ptp, struct ixgbe_adapter, ptp_caps);\r\nif (rq->type == PTP_CLK_REQ_PPS) {\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_X540:\r\nif (on)\r\nadapter->flags2 |= IXGBE_FLAG2_PTP_PPS_ENABLED;\r\nelse\r\nadapter->flags2 &= ~IXGBE_FLAG2_PTP_PPS_ENABLED;\r\nixgbe_ptp_setup_sdp(adapter);\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nvoid ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter, u32 eicr)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct ptp_clock_event event;\r\nevent.type = PTP_CLOCK_PPS;\r\nif (!adapter->ptp_clock)\r\nreturn;\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X540:\r\nptp_clock_event(adapter->ptp_clock, &event);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter)\r\n{\r\nbool timeout = time_is_before_jiffies(adapter->last_overflow_check +\r\nIXGBE_OVERFLOW_PERIOD);\r\nstruct timespec ts;\r\nif (timeout) {\r\nixgbe_ptp_gettime(&adapter->ptp_caps, &ts);\r\nadapter->last_overflow_check = jiffies;\r\n}\r\n}\r\nvoid ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 tsyncrxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\r\nunsigned long rx_event;\r\nif (!(tsyncrxctl & IXGBE_TSYNCRXCTL_VALID)) {\r\nadapter->last_rx_ptp_check = jiffies;\r\nreturn;\r\n}\r\nrx_event = adapter->last_rx_ptp_check;\r\nif (time_after(adapter->last_rx_timestamp, rx_event))\r\nrx_event = adapter->last_rx_timestamp;\r\nif (time_is_before_jiffies(rx_event + 5*HZ)) {\r\nIXGBE_READ_REG(hw, IXGBE_RXSTMPH);\r\nadapter->last_rx_ptp_check = jiffies;\r\ne_warn(drv, "clearing RX Timestamp hang\n");\r\n}\r\n}\r\nstatic void ixgbe_ptp_tx_hwtstamp(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nu64 regval = 0, ns;\r\nunsigned long flags;\r\nregval |= (u64)IXGBE_READ_REG(hw, IXGBE_TXSTMPL);\r\nregval |= (u64)IXGBE_READ_REG(hw, IXGBE_TXSTMPH) << 32;\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nns = timecounter_cyc2time(&adapter->tc, regval);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\r\nshhwtstamps.hwtstamp = ns_to_ktime(ns);\r\nskb_tstamp_tx(adapter->ptp_tx_skb, &shhwtstamps);\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\nclear_bit_unlock(__IXGBE_PTP_TX_IN_PROGRESS, &adapter->state);\r\n}\r\nstatic void ixgbe_ptp_tx_hwtstamp_work(struct work_struct *work)\r\n{\r\nstruct ixgbe_adapter *adapter = container_of(work, struct ixgbe_adapter,\r\nptp_tx_work);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nbool timeout = time_is_before_jiffies(adapter->ptp_tx_start +\r\nIXGBE_PTP_TX_TIMEOUT);\r\nu32 tsynctxctl;\r\nif (timeout) {\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\nclear_bit_unlock(__IXGBE_PTP_TX_IN_PROGRESS, &adapter->state);\r\ne_warn(drv, "clearing Tx Timestamp hang\n");\r\nreturn;\r\n}\r\ntsynctxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCTXCTL);\r\nif (tsynctxctl & IXGBE_TSYNCTXCTL_VALID)\r\nixgbe_ptp_tx_hwtstamp(adapter);\r\nelse\r\nschedule_work(&adapter->ptp_tx_work);\r\n}\r\nvoid ixgbe_ptp_rx_hwtstamp(struct ixgbe_adapter *adapter, struct sk_buff *skb)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct skb_shared_hwtstamps *shhwtstamps;\r\nu64 regval = 0, ns;\r\nu32 tsyncrxctl;\r\nunsigned long flags;\r\ntsyncrxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\r\nif (!(tsyncrxctl & IXGBE_TSYNCRXCTL_VALID))\r\nreturn;\r\nregval |= (u64)IXGBE_READ_REG(hw, IXGBE_RXSTMPL);\r\nregval |= (u64)IXGBE_READ_REG(hw, IXGBE_RXSTMPH) << 32;\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nns = timecounter_cyc2time(&adapter->tc, regval);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nshhwtstamps = skb_hwtstamps(skb);\r\nshhwtstamps->hwtstamp = ns_to_ktime(ns);\r\nadapter->last_rx_timestamp = jiffies;\r\n}\r\nint ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config *config = &adapter->tstamp_config;\r\nreturn copy_to_user(ifr->ifr_data, config,\r\nsizeof(*config)) ? -EFAULT : 0;\r\n}\r\nstatic int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter,\r\nstruct hwtstamp_config *config)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 tsync_tx_ctl = IXGBE_TSYNCTXCTL_ENABLED;\r\nu32 tsync_rx_ctl = IXGBE_TSYNCRXCTL_ENABLED;\r\nu32 tsync_rx_mtrl = PTP_EV_PORT << 16;\r\nbool is_l2 = false;\r\nu32 regval;\r\nif (config->flags)\r\nreturn -EINVAL;\r\nswitch (config->tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\ntsync_tx_ctl = 0;\r\ncase HWTSTAMP_TX_ON:\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (config->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ntsync_rx_ctl = 0;\r\ntsync_rx_mtrl = 0;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ntsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_L4_V1;\r\ntsync_rx_mtrl |= IXGBE_RXMTRL_V1_SYNC_MSG;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ntsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_L4_V1;\r\ntsync_rx_mtrl |= IXGBE_RXMTRL_V1_DELAY_REQ_MSG;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ntsync_rx_ctl |= IXGBE_TSYNCRXCTL_TYPE_EVENT_V2;\r\nis_l2 = true;\r\nconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_ALL:\r\ndefault:\r\nconfig->rx_filter = HWTSTAMP_FILTER_NONE;\r\nreturn -ERANGE;\r\n}\r\nif (hw->mac.type == ixgbe_mac_82598EB) {\r\nif (tsync_rx_ctl | tsync_tx_ctl)\r\nreturn -ERANGE;\r\nreturn 0;\r\n}\r\nif (is_l2)\r\nIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_1588),\r\n(IXGBE_ETQF_FILTER_EN |\r\nIXGBE_ETQF_1588 |\r\nETH_P_1588));\r\nelse\r\nIXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_1588), 0);\r\nregval = IXGBE_READ_REG(hw, IXGBE_TSYNCTXCTL);\r\nregval &= ~IXGBE_TSYNCTXCTL_ENABLED;\r\nregval |= tsync_tx_ctl;\r\nIXGBE_WRITE_REG(hw, IXGBE_TSYNCTXCTL, regval);\r\nregval = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);\r\nregval &= ~(IXGBE_TSYNCRXCTL_ENABLED | IXGBE_TSYNCRXCTL_TYPE_MASK);\r\nregval |= tsync_rx_ctl;\r\nIXGBE_WRITE_REG(hw, IXGBE_TSYNCRXCTL, regval);\r\nIXGBE_WRITE_REG(hw, IXGBE_RXMTRL, tsync_rx_mtrl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nregval = IXGBE_READ_REG(hw, IXGBE_TXSTMPH);\r\nregval = IXGBE_READ_REG(hw, IXGBE_RXSTMPH);\r\nreturn 0;\r\n}\r\nint ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config config;\r\nint err;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nerr = ixgbe_ptp_set_timestamp_mode(adapter, &config);\r\nif (err)\r\nreturn err;\r\nmemcpy(&adapter->tstamp_config, &config,\r\nsizeof(adapter->tstamp_config));\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nvoid ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 incval = 0;\r\nu32 shift = 0;\r\nunsigned long flags;\r\nswitch (adapter->link_speed) {\r\ncase IXGBE_LINK_SPEED_100_FULL:\r\nincval = IXGBE_INCVAL_100;\r\nshift = IXGBE_INCVAL_SHIFT_100;\r\nbreak;\r\ncase IXGBE_LINK_SPEED_1GB_FULL:\r\nincval = IXGBE_INCVAL_1GB;\r\nshift = IXGBE_INCVAL_SHIFT_1GB;\r\nbreak;\r\ncase IXGBE_LINK_SPEED_10GB_FULL:\r\ndefault:\r\nincval = IXGBE_INCVAL_10GB;\r\nshift = IXGBE_INCVAL_SHIFT_10GB;\r\nbreak;\r\n}\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_X540:\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA, incval);\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\nincval >>= IXGBE_INCVAL_SHIFT_82599;\r\nshift -= IXGBE_INCVAL_SHIFT_82599;\r\nIXGBE_WRITE_REG(hw, IXGBE_TIMINCA,\r\n(1 << IXGBE_INCPER_SHIFT_82599) |\r\nincval);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nACCESS_ONCE(adapter->base_incval) = incval;\r\nsmp_mb();\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nmemset(&adapter->cc, 0, sizeof(adapter->cc));\r\nadapter->cc.read = ixgbe_ptp_read;\r\nadapter->cc.mask = CLOCKSOURCE_MASK(64);\r\nadapter->cc.shift = shift;\r\nadapter->cc.mult = 1;\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\n}\r\nvoid ixgbe_ptp_reset(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nIXGBE_WRITE_REG(hw, IXGBE_SYSTIML, 0x00000000);\r\nIXGBE_WRITE_REG(hw, IXGBE_SYSTIMH, 0x00000000);\r\nIXGBE_WRITE_FLUSH(hw);\r\nixgbe_ptp_set_timestamp_mode(adapter, &adapter->tstamp_config);\r\nixgbe_ptp_start_cyclecounter(adapter);\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\ntimecounter_init(&adapter->tc, &adapter->cc,\r\nktime_to_ns(ktime_get_real()));\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nixgbe_ptp_setup_sdp(adapter);\r\n}\r\nstatic int ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nlong err;\r\nif (!IS_ERR_OR_NULL(adapter->ptp_clock))\r\nreturn 0;\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_X540:\r\nsnprintf(adapter->ptp_caps.name,\r\nsizeof(adapter->ptp_caps.name),\r\n"%s", netdev->name);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 250000000;\r\nadapter->ptp_caps.n_alarm = 0;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.n_per_out = 0;\r\nadapter->ptp_caps.pps = 1;\r\nadapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq;\r\nadapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;\r\nadapter->ptp_caps.gettime = ixgbe_ptp_gettime;\r\nadapter->ptp_caps.settime = ixgbe_ptp_settime;\r\nadapter->ptp_caps.enable = ixgbe_ptp_feature_enable;\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\nsnprintf(adapter->ptp_caps.name,\r\nsizeof(adapter->ptp_caps.name),\r\n"%s", netdev->name);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 250000000;\r\nadapter->ptp_caps.n_alarm = 0;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.n_per_out = 0;\r\nadapter->ptp_caps.pps = 0;\r\nadapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq;\r\nadapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;\r\nadapter->ptp_caps.gettime = ixgbe_ptp_gettime;\r\nadapter->ptp_caps.settime = ixgbe_ptp_settime;\r\nadapter->ptp_caps.enable = ixgbe_ptp_feature_enable;\r\nbreak;\r\ndefault:\r\nadapter->ptp_clock = NULL;\r\nreturn -EOPNOTSUPP;\r\n}\r\nadapter->ptp_clock = ptp_clock_register(&adapter->ptp_caps,\r\n&adapter->pdev->dev);\r\nif (IS_ERR(adapter->ptp_clock)) {\r\nerr = PTR_ERR(adapter->ptp_clock);\r\nadapter->ptp_clock = NULL;\r\ne_dev_err("ptp_clock_register failed\n");\r\nreturn err;\r\n} else\r\ne_dev_info("registered PHC device on %s\n", netdev->name);\r\nadapter->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\r\nadapter->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\r\nreturn 0;\r\n}\r\nvoid ixgbe_ptp_init(struct ixgbe_adapter *adapter)\r\n{\r\nspin_lock_init(&adapter->tmreg_lock);\r\nif (ixgbe_ptp_create_clock(adapter))\r\nreturn;\r\nINIT_WORK(&adapter->ptp_tx_work, ixgbe_ptp_tx_hwtstamp_work);\r\nixgbe_ptp_reset(adapter);\r\nset_bit(__IXGBE_PTP_RUNNING, &adapter->state);\r\nreturn;\r\n}\r\nvoid ixgbe_ptp_suspend(struct ixgbe_adapter *adapter)\r\n{\r\nif (!test_and_clear_bit(__IXGBE_PTP_RUNNING, &adapter->state))\r\nreturn;\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_TSAUXC, 0x0);\r\ncancel_work_sync(&adapter->ptp_tx_work);\r\nif (adapter->ptp_tx_skb) {\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\nclear_bit_unlock(__IXGBE_PTP_TX_IN_PROGRESS, &adapter->state);\r\n}\r\n}\r\nvoid ixgbe_ptp_stop(struct ixgbe_adapter *adapter)\r\n{\r\nixgbe_ptp_suspend(adapter);\r\nif (adapter->ptp_clock) {\r\nptp_clock_unregister(adapter->ptp_clock);\r\nadapter->ptp_clock = NULL;\r\ne_dev_info("removed PHC on %s\n",\r\nadapter->netdev->name);\r\n}\r\n}
