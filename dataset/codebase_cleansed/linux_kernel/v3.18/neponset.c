void neponset_ncr_frob(unsigned int mask, unsigned int val)\r\n{\r\nvoid __iomem *base = nep_base;\r\nif (base) {\r\nunsigned long flags;\r\nunsigned v;\r\nlocal_irq_save(flags);\r\nv = readb_relaxed(base + NCR_0);\r\nwriteb_relaxed((v & ~mask) | val, base + NCR_0);\r\nlocal_irq_restore(flags);\r\n} else {\r\nWARN(1, "nep_base unset\n");\r\n}\r\n}\r\nstatic void neponset_set_mctrl(struct uart_port *port, u_int mctrl)\r\n{\r\nvoid __iomem *base = nep_base;\r\nu_int mdm_ctl0;\r\nif (!base)\r\nreturn;\r\nmdm_ctl0 = readb_relaxed(base + MDM_CTL_0);\r\nif (port->mapbase == _Ser1UTCR0) {\r\nif (mctrl & TIOCM_RTS)\r\nmdm_ctl0 &= ~MDM_CTL0_RTS2;\r\nelse\r\nmdm_ctl0 |= MDM_CTL0_RTS2;\r\nif (mctrl & TIOCM_DTR)\r\nmdm_ctl0 &= ~MDM_CTL0_DTR2;\r\nelse\r\nmdm_ctl0 |= MDM_CTL0_DTR2;\r\n} else if (port->mapbase == _Ser3UTCR0) {\r\nif (mctrl & TIOCM_RTS)\r\nmdm_ctl0 &= ~MDM_CTL0_RTS1;\r\nelse\r\nmdm_ctl0 |= MDM_CTL0_RTS1;\r\nif (mctrl & TIOCM_DTR)\r\nmdm_ctl0 &= ~MDM_CTL0_DTR1;\r\nelse\r\nmdm_ctl0 |= MDM_CTL0_DTR1;\r\n}\r\nwriteb_relaxed(mdm_ctl0, base + MDM_CTL_0);\r\n}\r\nstatic u_int neponset_get_mctrl(struct uart_port *port)\r\n{\r\nvoid __iomem *base = nep_base;\r\nu_int ret = TIOCM_CD | TIOCM_CTS | TIOCM_DSR;\r\nu_int mdm_ctl1;\r\nif (!base)\r\nreturn ret;\r\nmdm_ctl1 = readb_relaxed(base + MDM_CTL_1);\r\nif (port->mapbase == _Ser1UTCR0) {\r\nif (mdm_ctl1 & MDM_CTL1_DCD2)\r\nret &= ~TIOCM_CD;\r\nif (mdm_ctl1 & MDM_CTL1_CTS2)\r\nret &= ~TIOCM_CTS;\r\nif (mdm_ctl1 & MDM_CTL1_DSR2)\r\nret &= ~TIOCM_DSR;\r\n} else if (port->mapbase == _Ser3UTCR0) {\r\nif (mdm_ctl1 & MDM_CTL1_DCD1)\r\nret &= ~TIOCM_CD;\r\nif (mdm_ctl1 & MDM_CTL1_CTS1)\r\nret &= ~TIOCM_CTS;\r\nif (mdm_ctl1 & MDM_CTL1_DSR1)\r\nret &= ~TIOCM_DSR;\r\n}\r\nreturn ret;\r\n}\r\nstatic void neponset_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct neponset_drvdata *d = irq_desc_get_handler_data(desc);\r\nunsigned int irr;\r\nwhile (1) {\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nirr = readb_relaxed(d->base + IRR);\r\nirr ^= IRR_ETHERNET | IRR_USAR;\r\nif ((irr & (IRR_ETHERNET | IRR_USAR | IRR_SA1111)) == 0)\r\nbreak;\r\nif (irr & (IRR_ETHERNET | IRR_USAR)) {\r\ndesc->irq_data.chip->irq_mask(&desc->irq_data);\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nif (irr & IRR_ETHERNET)\r\ngeneric_handle_irq(d->irq_base + NEP_IRQ_SMC91X);\r\nif (irr & IRR_USAR)\r\ngeneric_handle_irq(d->irq_base + NEP_IRQ_USAR);\r\ndesc->irq_data.chip->irq_unmask(&desc->irq_data);\r\n}\r\nif (irr & IRR_SA1111)\r\ngeneric_handle_irq(d->irq_base + NEP_IRQ_SA1111);\r\n}\r\n}\r\nstatic void nochip_noop(struct irq_data *irq)\r\n{\r\n}\r\nstatic int neponset_probe(struct platform_device *dev)\r\n{\r\nstruct neponset_drvdata *d;\r\nstruct resource *nep_res, *sa1111_res, *smc91x_res;\r\nstruct resource sa1111_resources[] = {\r\nDEFINE_RES_MEM(0x40000000, SZ_8K),\r\n{ .flags = IORESOURCE_IRQ },\r\n};\r\nstruct platform_device_info sa1111_devinfo = {\r\n.parent = &dev->dev,\r\n.name = "sa1111",\r\n.id = 0,\r\n.res = sa1111_resources,\r\n.num_res = ARRAY_SIZE(sa1111_resources),\r\n.data = &sa1111_info,\r\n.size_data = sizeof(sa1111_info),\r\n.dma_mask = 0xffffffffUL,\r\n};\r\nstruct resource smc91x_resources[] = {\r\nDEFINE_RES_MEM_NAMED(SA1100_CS3_PHYS,\r\n0x02000000, "smc91x-regs"),\r\nDEFINE_RES_MEM_NAMED(SA1100_CS3_PHYS + 0x02000000,\r\n0x02000000, "smc91x-attrib"),\r\n{ .flags = IORESOURCE_IRQ },\r\n};\r\nstruct platform_device_info smc91x_devinfo = {\r\n.parent = &dev->dev,\r\n.name = "smc91x",\r\n.id = 0,\r\n.res = smc91x_resources,\r\n.num_res = ARRAY_SIZE(smc91x_resources),\r\n};\r\nint ret, irq;\r\nif (nep_base)\r\nreturn -EBUSY;\r\nirq = ret = platform_get_irq(dev, 0);\r\nif (ret < 0)\r\ngoto err_alloc;\r\nnep_res = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nsmc91x_res = platform_get_resource(dev, IORESOURCE_MEM, 1);\r\nsa1111_res = platform_get_resource(dev, IORESOURCE_MEM, 2);\r\nif (!nep_res || !smc91x_res || !sa1111_res) {\r\nret = -ENXIO;\r\ngoto err_alloc;\r\n}\r\nd = kzalloc(sizeof(*d), GFP_KERNEL);\r\nif (!d) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nd->base = ioremap(nep_res->start, SZ_4K);\r\nif (!d->base) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nif (readb_relaxed(d->base + WHOAMI) != 0x11) {\r\ndev_warn(&dev->dev, "Neponset board detected, but wrong ID: %02x\n",\r\nreadb_relaxed(d->base + WHOAMI));\r\nret = -ENODEV;\r\ngoto err_id;\r\n}\r\nret = irq_alloc_descs(-1, IRQ_BOARD_START, NEP_IRQ_NR, -1);\r\nif (ret <= 0) {\r\ndev_err(&dev->dev, "unable to allocate %u irqs: %d\n",\r\nNEP_IRQ_NR, ret);\r\nif (ret == 0)\r\nret = -ENOMEM;\r\ngoto err_irq_alloc;\r\n}\r\nd->irq_base = ret;\r\nirq_set_chip_and_handler(d->irq_base + NEP_IRQ_SMC91X, &nochip,\r\nhandle_simple_irq);\r\nset_irq_flags(d->irq_base + NEP_IRQ_SMC91X, IRQF_VALID | IRQF_PROBE);\r\nirq_set_chip_and_handler(d->irq_base + NEP_IRQ_USAR, &nochip,\r\nhandle_simple_irq);\r\nset_irq_flags(d->irq_base + NEP_IRQ_USAR, IRQF_VALID | IRQF_PROBE);\r\nirq_set_chip(d->irq_base + NEP_IRQ_SA1111, &nochip);\r\nirq_set_irq_type(irq, IRQ_TYPE_EDGE_RISING);\r\nirq_set_handler_data(irq, d);\r\nirq_set_chained_handler(irq, neponset_irq_handler);\r\n#if 0\r\nenable_irq_wake(irq);\r\n#endif\r\ndev_info(&dev->dev, "Neponset daughter board, providing IRQ%u-%u\n",\r\nd->irq_base, d->irq_base + NEP_IRQ_NR - 1);\r\nnep_base = d->base;\r\nsa1100_register_uart_fns(&neponset_port_fns);\r\nsa1110_mb_disable();\r\nwriteb_relaxed(NCR_GP01_OFF, d->base + NCR_0);\r\nsa1111_resources[0].parent = sa1111_res;\r\nsa1111_resources[1].start = d->irq_base + NEP_IRQ_SA1111;\r\nsa1111_resources[1].end = d->irq_base + NEP_IRQ_SA1111;\r\nd->sa1111 = platform_device_register_full(&sa1111_devinfo);\r\nsmc91x_resources[0].parent = smc91x_res;\r\nsmc91x_resources[1].parent = smc91x_res;\r\nsmc91x_resources[2].start = d->irq_base + NEP_IRQ_SMC91X;\r\nsmc91x_resources[2].end = d->irq_base + NEP_IRQ_SMC91X;\r\nd->smc91x = platform_device_register_full(&smc91x_devinfo);\r\nplatform_set_drvdata(dev, d);\r\nreturn 0;\r\nerr_irq_alloc:\r\nerr_id:\r\niounmap(d->base);\r\nerr_ioremap:\r\nkfree(d);\r\nerr_alloc:\r\nreturn ret;\r\n}\r\nstatic int neponset_remove(struct platform_device *dev)\r\n{\r\nstruct neponset_drvdata *d = platform_get_drvdata(dev);\r\nint irq = platform_get_irq(dev, 0);\r\nif (!IS_ERR(d->sa1111))\r\nplatform_device_unregister(d->sa1111);\r\nif (!IS_ERR(d->smc91x))\r\nplatform_device_unregister(d->smc91x);\r\nirq_set_chained_handler(irq, NULL);\r\nirq_free_descs(d->irq_base, NEP_IRQ_NR);\r\nnep_base = NULL;\r\niounmap(d->base);\r\nkfree(d);\r\nreturn 0;\r\n}\r\nstatic int neponset_suspend(struct device *dev)\r\n{\r\nstruct neponset_drvdata *d = dev_get_drvdata(dev);\r\nd->ncr0 = readb_relaxed(d->base + NCR_0);\r\nd->mdm_ctl_0 = readb_relaxed(d->base + MDM_CTL_0);\r\nreturn 0;\r\n}\r\nstatic int neponset_resume(struct device *dev)\r\n{\r\nstruct neponset_drvdata *d = dev_get_drvdata(dev);\r\nwriteb_relaxed(d->ncr0, d->base + NCR_0);\r\nwriteb_relaxed(d->mdm_ctl_0, d->base + MDM_CTL_0);\r\nreturn 0;\r\n}\r\nstatic int __init neponset_init(void)\r\n{\r\nreturn platform_driver_register(&neponset_device_driver);\r\n}
