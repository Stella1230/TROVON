static struct pci_root_info __init *find_pci_root_info(int node, int link)\r\n{\r\nstruct pci_root_info *info;\r\nlist_for_each_entry(info, &pci_root_infos, list)\r\nif (info->node == node && info->link == link)\r\nreturn info;\r\nreturn NULL;\r\n}\r\nstatic int __init early_root_info_init(void)\r\n{\r\nint i;\r\nunsigned bus;\r\nunsigned slot;\r\nint node;\r\nint link;\r\nint def_node;\r\nint def_link;\r\nstruct pci_root_info *info;\r\nu32 reg;\r\nu64 start;\r\nu64 end;\r\nstruct range range[RANGE_NUM];\r\nu64 val;\r\nu32 address;\r\nbool found;\r\nstruct resource fam10h_mmconf_res, *fam10h_mmconf;\r\nu64 fam10h_mmconf_start;\r\nu64 fam10h_mmconf_end;\r\nif (!early_pci_allowed())\r\nreturn -1;\r\nfound = false;\r\nfor (i = 0; i < ARRAY_SIZE(hb_probes); i++) {\r\nu32 id;\r\nu16 device;\r\nu16 vendor;\r\nbus = hb_probes[i].bus;\r\nslot = hb_probes[i].slot;\r\nid = read_pci_config(bus, slot, 0, PCI_VENDOR_ID);\r\nvendor = id & 0xffff;\r\ndevice = (id>>16) & 0xffff;\r\nif (vendor != PCI_VENDOR_ID_AMD)\r\ncontinue;\r\nif (hb_probes[i].device == device) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn 0;\r\nfor (i = 0; i < AMD_NB_F1_CONFIG_MAP_RANGES; i++) {\r\nint min_bus;\r\nint max_bus;\r\nreg = read_pci_config(bus, slot, 1,\r\nAMD_NB_F1_CONFIG_MAP_REG + (i << 2));\r\nif ((reg & 7) != 3)\r\ncontinue;\r\nmin_bus = (reg >> 16) & 0xff;\r\nmax_bus = (reg >> 24) & 0xff;\r\nnode = (reg >> 4) & 0x07;\r\nlink = (reg >> 8) & 0x03;\r\ninfo = alloc_pci_root_info(min_bus, max_bus, node, link);\r\n}\r\nif (boot_cpu_data.x86 > 0x11)\r\nreturn 0;\r\nreg = read_pci_config(bus, slot, 0, AMD_NB_F0_NODE_ID);\r\ndef_node = (reg >> 8) & 0x07;\r\nreg = read_pci_config(bus, slot, 0, AMD_NB_F0_UNIT_ID);\r\ndef_link = (reg >> 8) & 0x03;\r\nmemset(range, 0, sizeof(range));\r\nadd_range(range, RANGE_NUM, 0, 0, 0xffff + 1);\r\nfor (i = 0; i < 4; i++) {\r\nreg = read_pci_config(bus, slot, 1, 0xc0 + (i << 3));\r\nif (!(reg & 3))\r\ncontinue;\r\nstart = reg & 0xfff000;\r\nreg = read_pci_config(bus, slot, 1, 0xc4 + (i << 3));\r\nnode = reg & 0x07;\r\nlink = (reg >> 4) & 0x03;\r\nend = (reg & 0xfff000) | 0xfff;\r\ninfo = find_pci_root_info(node, link);\r\nif (!info)\r\ncontinue;\r\nprintk(KERN_DEBUG "node %d link %d: io port [%llx, %llx]\n",\r\nnode, link, start, end);\r\nif (end > 0xffff)\r\nend = 0xffff;\r\nupdate_res(info, start, end, IORESOURCE_IO, 1);\r\nsubtract_range(range, RANGE_NUM, start, end + 1);\r\n}\r\ninfo = find_pci_root_info(def_node, def_link);\r\nif (info) {\r\nfor (i = 0; i < RANGE_NUM; i++) {\r\nif (!range[i].end)\r\ncontinue;\r\nupdate_res(info, range[i].start, range[i].end - 1,\r\nIORESOURCE_IO, 1);\r\n}\r\n}\r\nmemset(range, 0, sizeof(range));\r\nend = cap_resource((0xfdULL<<32) - 1);\r\nend++;\r\nadd_range(range, RANGE_NUM, 0, 0, end);\r\naddress = MSR_K8_TOP_MEM1;\r\nrdmsrl(address, val);\r\nend = (val & 0xffffff800000ULL);\r\nprintk(KERN_INFO "TOM: %016llx aka %lldM\n", end, end>>20);\r\nif (end < (1ULL<<32))\r\nsubtract_range(range, RANGE_NUM, 0, end);\r\nfam10h_mmconf = amd_get_mmconfig_range(&fam10h_mmconf_res);\r\nif (fam10h_mmconf) {\r\nprintk(KERN_DEBUG "Fam 10h mmconf %pR\n", fam10h_mmconf);\r\nfam10h_mmconf_start = fam10h_mmconf->start;\r\nfam10h_mmconf_end = fam10h_mmconf->end;\r\nsubtract_range(range, RANGE_NUM, fam10h_mmconf_start,\r\nfam10h_mmconf_end + 1);\r\n} else {\r\nfam10h_mmconf_start = 0;\r\nfam10h_mmconf_end = 0;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nreg = read_pci_config(bus, slot, 1, 0x80 + (i << 3));\r\nif (!(reg & 3))\r\ncontinue;\r\nstart = reg & 0xffffff00;\r\nstart <<= 8;\r\nreg = read_pci_config(bus, slot, 1, 0x84 + (i << 3));\r\nnode = reg & 0x07;\r\nlink = (reg >> 4) & 0x03;\r\nend = (reg & 0xffffff00);\r\nend <<= 8;\r\nend |= 0xffff;\r\ninfo = find_pci_root_info(node, link);\r\nif (!info)\r\ncontinue;\r\nprintk(KERN_DEBUG "node %d link %d: mmio [%llx, %llx]",\r\nnode, link, start, end);\r\nif (fam10h_mmconf_end) {\r\nint changed = 0;\r\nu64 endx = 0;\r\nif (start >= fam10h_mmconf_start &&\r\nstart <= fam10h_mmconf_end) {\r\nstart = fam10h_mmconf_end + 1;\r\nchanged = 1;\r\n}\r\nif (end >= fam10h_mmconf_start &&\r\nend <= fam10h_mmconf_end) {\r\nend = fam10h_mmconf_start - 1;\r\nchanged = 1;\r\n}\r\nif (start < fam10h_mmconf_start &&\r\nend > fam10h_mmconf_end) {\r\nendx = fam10h_mmconf_start - 1;\r\nupdate_res(info, start, endx, IORESOURCE_MEM, 0);\r\nsubtract_range(range, RANGE_NUM, start,\r\nendx + 1);\r\nprintk(KERN_CONT " ==> [%llx, %llx]", start, endx);\r\nstart = fam10h_mmconf_end + 1;\r\nchanged = 1;\r\n}\r\nif (changed) {\r\nif (start <= end) {\r\nprintk(KERN_CONT " %s [%llx, %llx]", endx ? "and" : "==>", start, end);\r\n} else {\r\nprintk(KERN_CONT "%s\n", endx?"":" ==> none");\r\ncontinue;\r\n}\r\n}\r\n}\r\nupdate_res(info, cap_resource(start), cap_resource(end),\r\nIORESOURCE_MEM, 1);\r\nsubtract_range(range, RANGE_NUM, start, end + 1);\r\nprintk(KERN_CONT "\n");\r\n}\r\naddress = MSR_K8_SYSCFG;\r\nrdmsrl(address, val);\r\nif (val & (1<<21)) {\r\naddress = MSR_K8_TOP_MEM2;\r\nrdmsrl(address, val);\r\nend = (val & 0xffffff800000ULL);\r\nprintk(KERN_INFO "TOM2: %016llx aka %lldM\n", end, end>>20);\r\nsubtract_range(range, RANGE_NUM, 1ULL<<32, end);\r\n}\r\ninfo = find_pci_root_info(def_node, def_link);\r\nif (info) {\r\nfor (i = 0; i < RANGE_NUM; i++) {\r\nif (!range[i].end)\r\ncontinue;\r\nupdate_res(info, cap_resource(range[i].start),\r\ncap_resource(range[i].end - 1),\r\nIORESOURCE_MEM, 1);\r\n}\r\n}\r\nlist_for_each_entry(info, &pci_root_infos, list) {\r\nint busnum;\r\nstruct pci_root_res *root_res;\r\nbusnum = info->busn.start;\r\nprintk(KERN_DEBUG "bus: %pR on node %x link %x\n",\r\n&info->busn, info->node, info->link);\r\nlist_for_each_entry(root_res, &info->resources, list)\r\nprintk(KERN_DEBUG "bus: %02x %pR\n",\r\nbusnum, &root_res->res);\r\n}\r\nreturn 0;\r\n}\r\nstatic void enable_pci_io_ecs(void *unused)\r\n{\r\nu64 reg;\r\nrdmsrl(MSR_AMD64_NB_CFG, reg);\r\nif (!(reg & ENABLE_CF8_EXT_CFG)) {\r\nreg |= ENABLE_CF8_EXT_CFG;\r\nwrmsrl(MSR_AMD64_NB_CFG, reg);\r\n}\r\n}\r\nstatic int amd_cpu_notify(struct notifier_block *self, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nint cpu = (long)hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nsmp_call_function_single(cpu, enable_pci_io_ecs, NULL, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init pci_enable_pci_io_ecs(void)\r\n{\r\n#ifdef CONFIG_AMD_NB\r\nunsigned int i, n;\r\nfor (n = i = 0; !n && amd_nb_bus_dev_ranges[i].dev_limit; ++i) {\r\nu8 bus = amd_nb_bus_dev_ranges[i].bus;\r\nu8 slot = amd_nb_bus_dev_ranges[i].dev_base;\r\nu8 limit = amd_nb_bus_dev_ranges[i].dev_limit;\r\nfor (; slot < limit; ++slot) {\r\nu32 val = read_pci_config(bus, slot, 3, 0);\r\nif (!early_is_amd_nb(val))\r\ncontinue;\r\nval = read_pci_config(bus, slot, 3, 0x8c);\r\nif (!(val & (ENABLE_CF8_EXT_CFG >> 32))) {\r\nval |= ENABLE_CF8_EXT_CFG >> 32;\r\nwrite_pci_config(bus, slot, 3, 0x8c, val);\r\n}\r\n++n;\r\n}\r\n}\r\n#endif\r\n}\r\nstatic int __init pci_io_ecs_init(void)\r\n{\r\nint cpu;\r\nif (boot_cpu_data.x86 < 0x10)\r\nreturn 0;\r\nif (early_pci_allowed())\r\npci_enable_pci_io_ecs();\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(cpu)\r\namd_cpu_notify(&amd_cpu_notifier, (unsigned long)CPU_ONLINE,\r\n(void *)(long)cpu);\r\n__register_cpu_notifier(&amd_cpu_notifier);\r\ncpu_notifier_register_done();\r\npci_probe |= PCI_HAS_IO_ECS;\r\nreturn 0;\r\n}\r\nstatic int __init amd_postcore_init(void)\r\n{\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\r\nreturn 0;\r\nearly_root_info_init();\r\npci_io_ecs_init();\r\nreturn 0;\r\n}
