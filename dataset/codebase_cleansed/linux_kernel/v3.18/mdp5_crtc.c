static struct mdp5_kms *get_kms(struct drm_crtc *crtc)\r\n{\r\nstruct msm_drm_private *priv = crtc->dev->dev_private;\r\nreturn to_mdp5_kms(to_mdp_kms(priv->kms));\r\n}\r\nstatic void request_pending(struct drm_crtc *crtc, uint32_t pending)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\natomic_or(pending, &mdp5_crtc->pending);\r\nmdp_irq_register(&get_kms(crtc)->base, &mdp5_crtc->vblank);\r\n}\r\nstatic void crtc_flush(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nint id = mdp5_crtc->id;\r\nuint32_t i, flush = 0;\r\nfor (i = 0; i < ARRAY_SIZE(mdp5_crtc->planes); i++) {\r\nstruct drm_plane *plane = mdp5_crtc->planes[i];\r\nif (plane) {\r\nenum mdp5_pipe pipe = mdp5_plane_pipe(plane);\r\nflush |= pipe2flush(pipe);\r\n}\r\n}\r\nflush |= mixer2flush(mdp5_crtc->id);\r\nflush |= MDP5_CTL_FLUSH_CTL;\r\nDBG("%s: flush=%08x", mdp5_crtc->name, flush);\r\nmdp5_write(mdp5_kms, REG_MDP5_CTL_FLUSH(id), flush);\r\n}\r\nstatic void update_fb(struct drm_crtc *crtc, struct drm_framebuffer *new_fb)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct drm_framebuffer *old_fb = mdp5_crtc->fb;\r\ndrm_framebuffer_reference(new_fb);\r\nmdp5_crtc->base.primary->fb = new_fb;\r\nmdp5_crtc->fb = new_fb;\r\nif (old_fb)\r\ndrm_flip_work_queue(&mdp5_crtc->unref_fb_work, old_fb);\r\n}\r\nstatic void update_scanout(struct drm_crtc *crtc, struct drm_framebuffer *fb)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\ncrtc_flush(crtc);\r\nif (mdp5_crtc->scanout_fb)\r\ndrm_flip_work_queue(&mdp5_crtc->unref_fb_work,\r\nmdp5_crtc->scanout_fb);\r\nmdp5_crtc->scanout_fb = fb;\r\nrequest_pending(crtc, PENDING_FLIP);\r\n}\r\nstatic void complete_flip(struct drm_crtc *crtc, struct drm_file *file)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_pending_vblank_event *event;\r\nunsigned long flags, i;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = mdp5_crtc->event;\r\nif (event) {\r\nif (!file || (event->base.file_priv == file)) {\r\nmdp5_crtc->event = NULL;\r\ndrm_send_vblank_event(dev, mdp5_crtc->id, event);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(mdp5_crtc->planes); i++) {\r\nstruct drm_plane *plane = mdp5_crtc->planes[i];\r\nif (plane)\r\nmdp5_plane_complete_flip(plane);\r\n}\r\n}\r\nstatic void pageflip_cb(struct msm_fence_cb *cb)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc =\r\ncontainer_of(cb, struct mdp5_crtc, pageflip_cb);\r\nstruct drm_crtc *crtc = &mdp5_crtc->base;\r\nstruct drm_framebuffer *fb = mdp5_crtc->fb;\r\nif (!fb)\r\nreturn;\r\ndrm_framebuffer_reference(fb);\r\nmdp5_plane_set_scanout(mdp5_crtc->plane, fb);\r\nupdate_scanout(crtc, fb);\r\n}\r\nstatic void unref_fb_worker(struct drm_flip_work *work, void *val)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc =\r\ncontainer_of(work, struct mdp5_crtc, unref_fb_work);\r\nstruct drm_device *dev = mdp5_crtc->base.dev;\r\nmutex_lock(&dev->mode_config.mutex);\r\ndrm_framebuffer_unreference(val);\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}\r\nstatic void mdp5_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\ndrm_crtc_cleanup(crtc);\r\ndrm_flip_work_cleanup(&mdp5_crtc->unref_fb_work);\r\nkfree(mdp5_crtc);\r\n}\r\nstatic void mdp5_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nbool enabled = (mode == DRM_MODE_DPMS_ON);\r\nDBG("%s: mode=%d", mdp5_crtc->name, mode);\r\nif (enabled != mdp5_crtc->enabled) {\r\nif (enabled) {\r\nmdp5_enable(mdp5_kms);\r\nmdp_irq_register(&mdp5_kms->base, &mdp5_crtc->err);\r\n} else {\r\nmdp_irq_unregister(&mdp5_kms->base, &mdp5_crtc->err);\r\nmdp5_disable(mdp5_kms);\r\n}\r\nmdp5_crtc->enabled = enabled;\r\n}\r\n}\r\nstatic bool mdp5_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void blend_setup(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nint id = mdp5_crtc->id;\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_COLOR_OUT(id),\r\nMDP5_LM_BLEND_COLOR_OUT_STAGE0_FG_ALPHA);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_OP_MODE(id, 0),\r\nMDP5_LM_BLEND_OP_MODE_FG_ALPHA(FG_CONST) |\r\nMDP5_LM_BLEND_OP_MODE_BG_ALPHA(FG_PIXEL) |\r\nMDP5_LM_BLEND_OP_MODE_BG_INV_ALPHA);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_FG_ALPHA(id, 0), 0xff);\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_BLEND_BG_ALPHA(id, 0), 0x00);\r\nmdp5_write(mdp5_kms, REG_MDP5_CTL_LAYER_REG(id, 0),\r\nMDP5_CTL_LAYER_REG_RGB0(STAGE0) |\r\nMDP5_CTL_LAYER_REG_BORDER_COLOR);\r\nmdp5_write(mdp5_kms, REG_MDP5_CTL_LAYER_REG(id, 1), 0);\r\nmdp5_write(mdp5_kms, REG_MDP5_CTL_LAYER_REG(id, 2), 0);\r\nmdp5_write(mdp5_kms, REG_MDP5_CTL_LAYER_REG(id, 3), 0);\r\nmdp5_write(mdp5_kms, REG_MDP5_CTL_LAYER_REG(id, 4), 0);\r\n}\r\nstatic int mdp5_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nint ret;\r\nmode = adjusted_mode;\r\nDBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\nmdp5_crtc->name, mode->base.id, mode->name,\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal,\r\nmode->type, mode->flags);\r\ndrm_framebuffer_reference(crtc->primary->fb);\r\nret = mdp5_plane_mode_set(mdp5_crtc->plane, crtc, crtc->primary->fb,\r\n0, 0, mode->hdisplay, mode->vdisplay,\r\nx << 16, y << 16,\r\nmode->hdisplay << 16, mode->vdisplay << 16);\r\nif (ret) {\r\ndrm_framebuffer_unreference(crtc->primary->fb);\r\ndev_err(crtc->dev->dev, "%s: failed to set mode on plane: %d\n",\r\nmdp5_crtc->name, ret);\r\nreturn ret;\r\n}\r\nmdp5_write(mdp5_kms, REG_MDP5_LM_OUT_SIZE(mdp5_crtc->id),\r\nMDP5_LM_OUT_SIZE_WIDTH(mode->hdisplay) |\r\nMDP5_LM_OUT_SIZE_HEIGHT(mode->vdisplay));\r\nupdate_fb(crtc, crtc->primary->fb);\r\nupdate_scanout(crtc, crtc->primary->fb);\r\nreturn 0;\r\n}\r\nstatic void mdp5_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nDBG("%s", mdp5_crtc->name);\r\nmdp5_enable(get_kms(crtc));\r\nmdp5_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void mdp5_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nmdp5_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\ncrtc_flush(crtc);\r\nmdp5_disable(get_kms(crtc));\r\n}\r\nstatic int mdp5_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct drm_plane *plane = mdp5_crtc->plane;\r\nstruct drm_display_mode *mode = &crtc->mode;\r\nint ret;\r\ndrm_framebuffer_reference(crtc->primary->fb);\r\nret = mdp5_plane_mode_set(plane, crtc, crtc->primary->fb,\r\n0, 0, mode->hdisplay, mode->vdisplay,\r\nx << 16, y << 16,\r\nmode->hdisplay << 16, mode->vdisplay << 16);\r\nif (ret) {\r\ndrm_framebuffer_unreference(crtc->primary->fb);\r\nreturn ret;\r\n}\r\nupdate_fb(crtc, crtc->primary->fb);\r\nupdate_scanout(crtc, crtc->primary->fb);\r\nreturn 0;\r\n}\r\nstatic void mdp5_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic int mdp5_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *new_fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_gem_object *obj;\r\nunsigned long flags;\r\nif (mdp5_crtc->event) {\r\ndev_err(dev->dev, "already pending flip!\n");\r\nreturn -EBUSY;\r\n}\r\nobj = msm_framebuffer_bo(new_fb, 0);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nmdp5_crtc->event = event;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nupdate_fb(crtc, new_fb);\r\nreturn msm_gem_queue_inactive_cb(obj, &mdp5_crtc->pageflip_cb);\r\n}\r\nstatic int mdp5_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property, uint64_t val)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void mdp5_crtc_vblank_irq(struct mdp_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = container_of(irq, struct mdp5_crtc, vblank);\r\nstruct drm_crtc *crtc = &mdp5_crtc->base;\r\nstruct msm_drm_private *priv = crtc->dev->dev_private;\r\nunsigned pending;\r\nmdp_irq_unregister(&get_kms(crtc)->base, &mdp5_crtc->vblank);\r\npending = atomic_xchg(&mdp5_crtc->pending, 0);\r\nif (pending & PENDING_FLIP) {\r\ncomplete_flip(crtc, NULL);\r\ndrm_flip_work_commit(&mdp5_crtc->unref_fb_work, priv->wq);\r\n}\r\n}\r\nstatic void mdp5_crtc_err_irq(struct mdp_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = container_of(irq, struct mdp5_crtc, err);\r\nstruct drm_crtc *crtc = &mdp5_crtc->base;\r\nDBG("%s: error: %08x", mdp5_crtc->name, irqstatus);\r\ncrtc_flush(crtc);\r\n}\r\nuint32_t mdp5_crtc_vblank(struct drm_crtc *crtc)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nreturn mdp5_crtc->vblank.irqmask;\r\n}\r\nvoid mdp5_crtc_cancel_pending_flip(struct drm_crtc *crtc, struct drm_file *file)\r\n{\r\nDBG("cancel: %p", file);\r\ncomplete_flip(crtc, file);\r\n}\r\nvoid mdp5_crtc_set_intf(struct drm_crtc *crtc, int intf,\r\nenum mdp5_intf intf_id)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nstruct mdp5_kms *mdp5_kms = get_kms(crtc);\r\nstatic const enum mdp5_intfnum intfnum[] = {\r\nINTF0, INTF1, INTF2, INTF3,\r\n};\r\nuint32_t intf_sel;\r\nmdp5_crtc->err.irqmask = intf2err(intf);\r\nmdp5_crtc->vblank.irqmask = intf2vblank(intf);\r\nif (!mdp5_kms)\r\nreturn;\r\nintf_sel = mdp5_read(mdp5_kms, REG_MDP5_DISP_INTF_SEL);\r\nswitch (intf) {\r\ncase 0:\r\nintf_sel &= ~MDP5_DISP_INTF_SEL_INTF0__MASK;\r\nintf_sel |= MDP5_DISP_INTF_SEL_INTF0(intf_id);\r\nbreak;\r\ncase 1:\r\nintf_sel &= ~MDP5_DISP_INTF_SEL_INTF1__MASK;\r\nintf_sel |= MDP5_DISP_INTF_SEL_INTF1(intf_id);\r\nbreak;\r\ncase 2:\r\nintf_sel &= ~MDP5_DISP_INTF_SEL_INTF2__MASK;\r\nintf_sel |= MDP5_DISP_INTF_SEL_INTF2(intf_id);\r\nbreak;\r\ncase 3:\r\nintf_sel &= ~MDP5_DISP_INTF_SEL_INTF3__MASK;\r\nintf_sel |= MDP5_DISP_INTF_SEL_INTF3(intf_id);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nblend_setup(crtc);\r\nDBG("%s: intf_sel=%08x", mdp5_crtc->name, intf_sel);\r\nmdp5_write(mdp5_kms, REG_MDP5_DISP_INTF_SEL, intf_sel);\r\nmdp5_write(mdp5_kms, REG_MDP5_CTL_OP(mdp5_crtc->id),\r\nMDP5_CTL_OP_MODE(MODE_NONE) |\r\nMDP5_CTL_OP_INTF_NUM(intfnum[intf]));\r\ncrtc_flush(crtc);\r\n}\r\nstatic void set_attach(struct drm_crtc *crtc, enum mdp5_pipe pipe_id,\r\nstruct drm_plane *plane)\r\n{\r\nstruct mdp5_crtc *mdp5_crtc = to_mdp5_crtc(crtc);\r\nBUG_ON(pipe_id >= ARRAY_SIZE(mdp5_crtc->planes));\r\nif (mdp5_crtc->planes[pipe_id] == plane)\r\nreturn;\r\nmdp5_crtc->planes[pipe_id] = plane;\r\nblend_setup(crtc);\r\nif (mdp5_crtc->enabled && (plane != mdp5_crtc->plane))\r\ncrtc_flush(crtc);\r\n}\r\nvoid mdp5_crtc_attach(struct drm_crtc *crtc, struct drm_plane *plane)\r\n{\r\nset_attach(crtc, mdp5_plane_pipe(plane), plane);\r\n}\r\nvoid mdp5_crtc_detach(struct drm_crtc *crtc, struct drm_plane *plane)\r\n{\r\nif (to_mdp5_crtc(crtc)->plane == plane)\r\nreturn;\r\nset_attach(crtc, mdp5_plane_pipe(plane), NULL);\r\n}\r\nstruct drm_crtc *mdp5_crtc_init(struct drm_device *dev,\r\nstruct drm_plane *plane, int id)\r\n{\r\nstruct drm_crtc *crtc = NULL;\r\nstruct mdp5_crtc *mdp5_crtc;\r\nint ret;\r\nmdp5_crtc = kzalloc(sizeof(*mdp5_crtc), GFP_KERNEL);\r\nif (!mdp5_crtc) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\ncrtc = &mdp5_crtc->base;\r\nmdp5_crtc->plane = plane;\r\nmdp5_crtc->id = id;\r\nmdp5_crtc->vblank.irq = mdp5_crtc_vblank_irq;\r\nmdp5_crtc->err.irq = mdp5_crtc_err_irq;\r\nsnprintf(mdp5_crtc->name, sizeof(mdp5_crtc->name), "%s:%d",\r\npipe2name(mdp5_plane_pipe(plane)), id);\r\nret = drm_flip_work_init(&mdp5_crtc->unref_fb_work, 16,\r\n"unref fb", unref_fb_worker);\r\nif (ret)\r\ngoto fail;\r\nINIT_FENCE_CB(&mdp5_crtc->pageflip_cb, pageflip_cb);\r\ndrm_crtc_init_with_planes(dev, crtc, plane, NULL, &mdp5_crtc_funcs);\r\ndrm_crtc_helper_add(crtc, &mdp5_crtc_helper_funcs);\r\nmdp5_plane_install_properties(mdp5_crtc->plane, &crtc->base);\r\nreturn crtc;\r\nfail:\r\nif (crtc)\r\nmdp5_crtc_destroy(crtc);\r\nreturn ERR_PTR(ret);\r\n}
