static void\r\nresizer_calculate_line_length(enum v4l2_mbus_pixelcode pix, int width,\r\nint height, int *line_len, int *line_len_c)\r\n{\r\n*line_len = 0;\r\n*line_len_c = 0;\r\nif (pix == V4L2_MBUS_FMT_UYVY8_2X8 ||\r\npix == V4L2_MBUS_FMT_SGRBG12_1X12) {\r\n*line_len = width << 1;\r\n} else if (pix == V4L2_MBUS_FMT_Y8_1X8 ||\r\npix == V4L2_MBUS_FMT_UV8_1X8) {\r\n*line_len = width;\r\n*line_len_c = width;\r\n} else {\r\n*line_len = width;\r\n*line_len_c = width;\r\n}\r\n*line_len += 31;\r\n*line_len &= ~0x1f;\r\n*line_len_c += 31;\r\n*line_len_c &= ~0x1f;\r\n}\r\nstatic inline int\r\nresizer_validate_output_image_format(struct device *dev,\r\nstruct v4l2_mbus_framefmt *format,\r\nint *in_line_len, int *in_line_len_c)\r\n{\r\nif (format->code != V4L2_MBUS_FMT_UYVY8_2X8 &&\r\nformat->code != V4L2_MBUS_FMT_Y8_1X8 &&\r\nformat->code != V4L2_MBUS_FMT_UV8_1X8 &&\r\nformat->code != V4L2_MBUS_FMT_YDYUYDYV8_1X16 &&\r\nformat->code != V4L2_MBUS_FMT_SGRBG12_1X12) {\r\ndev_err(dev, "Invalid Mbus format, %d\n", format->code);\r\nreturn -EINVAL;\r\n}\r\nif (!format->width || !format->height) {\r\ndev_err(dev, "invalid width or height\n");\r\nreturn -EINVAL;\r\n}\r\nresizer_calculate_line_length(format->code, format->width,\r\nformat->height, in_line_len, in_line_len_c);\r\nreturn 0;\r\n}\r\nstatic void\r\nresizer_configure_passthru(struct vpfe_resizer_device *resizer, int bypass)\r\n{\r\nstruct resizer_params *param = &resizer->config;\r\nparam->rsz_rsc_param[RSZ_A].cen = DISABLE;\r\nparam->rsz_rsc_param[RSZ_A].yen = DISABLE;\r\nparam->rsz_rsc_param[RSZ_A].v_phs_y = 0;\r\nparam->rsz_rsc_param[RSZ_A].v_phs_c = 0;\r\nparam->rsz_rsc_param[RSZ_A].v_dif = 256;\r\nparam->rsz_rsc_param[RSZ_A].v_lpf_int_y = 0;\r\nparam->rsz_rsc_param[RSZ_A].v_lpf_int_c = 0;\r\nparam->rsz_rsc_param[RSZ_A].h_phs = 0;\r\nparam->rsz_rsc_param[RSZ_A].h_dif = 256;\r\nparam->rsz_rsc_param[RSZ_A].h_lpf_int_y = 0;\r\nparam->rsz_rsc_param[RSZ_A].h_lpf_int_c = 0;\r\nparam->rsz_rsc_param[RSZ_A].dscale_en = DISABLE;\r\nparam->rsz2rgb[RSZ_A].rgb_en = DISABLE;\r\nparam->rsz_en[RSZ_A] = ENABLE;\r\nparam->rsz_en[RSZ_B] = DISABLE;\r\nif (bypass) {\r\nparam->rsz_rsc_param[RSZ_A].i_vps = 0;\r\nparam->rsz_rsc_param[RSZ_A].i_hps = 0;\r\nparam->rsz_common.passthrough = BYPASS_ON;\r\n}\r\n}\r\nstatic void\r\nconfigure_resizer_out_params(struct vpfe_resizer_device *resizer, int index,\r\nvoid *output_spec, unsigned char partial,\r\nunsigned flag)\r\n{\r\nstruct resizer_params *param = &resizer->config;\r\nstruct v4l2_mbus_framefmt *outformat;\r\nstruct vpfe_rsz_output_spec *output;\r\nif (index == RSZ_A &&\r\nresizer->resizer_a.output == RESIZER_OUTPUT_NONE) {\r\nparam->rsz_en[index] = DISABLE;\r\nreturn;\r\n}\r\nif (index == RSZ_B &&\r\nresizer->resizer_b.output == RESIZER_OUTPUT_NONE) {\r\nparam->rsz_en[index] = DISABLE;\r\nreturn;\r\n}\r\noutput = (struct vpfe_rsz_output_spec *)output_spec;\r\nparam->rsz_en[index] = ENABLE;\r\nif (partial) {\r\nparam->rsz_rsc_param[index].h_flip = output->h_flip;\r\nparam->rsz_rsc_param[index].v_flip = output->v_flip;\r\nparam->rsz_rsc_param[index].v_typ_y = output->v_typ_y;\r\nparam->rsz_rsc_param[index].v_typ_c = output->v_typ_c;\r\nparam->rsz_rsc_param[index].v_lpf_int_y =\r\noutput->v_lpf_int_y;\r\nparam->rsz_rsc_param[index].v_lpf_int_c =\r\noutput->v_lpf_int_c;\r\nparam->rsz_rsc_param[index].h_typ_y = output->h_typ_y;\r\nparam->rsz_rsc_param[index].h_typ_c = output->h_typ_c;\r\nparam->rsz_rsc_param[index].h_lpf_int_y =\r\noutput->h_lpf_int_y;\r\nparam->rsz_rsc_param[index].h_lpf_int_c =\r\noutput->h_lpf_int_c;\r\nparam->rsz_rsc_param[index].dscale_en =\r\noutput->en_down_scale;\r\nparam->rsz_rsc_param[index].h_dscale_ave_sz =\r\noutput->h_dscale_ave_sz;\r\nparam->rsz_rsc_param[index].v_dscale_ave_sz =\r\noutput->v_dscale_ave_sz;\r\nparam->ext_mem_param[index].user_y_ofst =\r\n(output->user_y_ofst + 31) & ~0x1f;\r\nparam->ext_mem_param[index].user_c_ofst =\r\n(output->user_c_ofst + 31) & ~0x1f;\r\nreturn;\r\n}\r\nif (index == RSZ_A)\r\noutformat = &resizer->resizer_a.formats[RESIZER_PAD_SOURCE];\r\nelse\r\noutformat = &resizer->resizer_b.formats[RESIZER_PAD_SOURCE];\r\nparam->rsz_rsc_param[index].o_vsz = outformat->height - 1;\r\nparam->rsz_rsc_param[index].o_hsz = outformat->width - 1;\r\nparam->ext_mem_param[index].rsz_sdr_ptr_s_y = output->vst_y;\r\nparam->ext_mem_param[index].rsz_sdr_ptr_e_y = outformat->height;\r\nparam->ext_mem_param[index].rsz_sdr_ptr_s_c = output->vst_c;\r\nparam->ext_mem_param[index].rsz_sdr_ptr_e_c = outformat->height;\r\nif (!flag)\r\nreturn;\r\nparam->rsz_rsc_param[index].h_flip = output->h_flip;\r\nparam->rsz_rsc_param[index].v_flip = output->v_flip;\r\nparam->rsz_rsc_param[index].v_typ_y = output->v_typ_y;\r\nparam->rsz_rsc_param[index].v_typ_c = output->v_typ_c;\r\nparam->rsz_rsc_param[index].v_lpf_int_y = output->v_lpf_int_y;\r\nparam->rsz_rsc_param[index].v_lpf_int_c = output->v_lpf_int_c;\r\nparam->rsz_rsc_param[index].h_typ_y = output->h_typ_y;\r\nparam->rsz_rsc_param[index].h_typ_c = output->h_typ_c;\r\nparam->rsz_rsc_param[index].h_lpf_int_y = output->h_lpf_int_y;\r\nparam->rsz_rsc_param[index].h_lpf_int_c = output->h_lpf_int_c;\r\nparam->rsz_rsc_param[index].dscale_en = output->en_down_scale;\r\nparam->rsz_rsc_param[index].h_dscale_ave_sz = output->h_dscale_ave_sz;\r\nparam->rsz_rsc_param[index].v_dscale_ave_sz = output->h_dscale_ave_sz;\r\nparam->ext_mem_param[index].user_y_ofst =\r\n(output->user_y_ofst + 31) & ~0x1f;\r\nparam->ext_mem_param[index].user_c_ofst =\r\n(output->user_c_ofst + 31) & ~0x1f;\r\n}\r\nstatic void\r\nresizer_calculate_resize_ratios(struct vpfe_resizer_device *resizer, int index)\r\n{\r\nstruct resizer_params *param = &resizer->config;\r\nstruct v4l2_mbus_framefmt *informat, *outformat;\r\ninformat = &resizer->crop_resizer.formats[RESIZER_CROP_PAD_SINK];\r\nif (index == RSZ_A)\r\noutformat = &resizer->resizer_a.formats[RESIZER_PAD_SOURCE];\r\nelse\r\noutformat = &resizer->resizer_b.formats[RESIZER_PAD_SOURCE];\r\nif (outformat->field != V4L2_FIELD_INTERLACED)\r\nparam->rsz_rsc_param[index].v_dif =\r\n((informat->height) * 256) / (outformat->height);\r\nelse\r\nparam->rsz_rsc_param[index].v_dif =\r\n((informat->height >> 1) * 256) / (outformat->height);\r\nparam->rsz_rsc_param[index].h_dif =\r\n((informat->width) * 256) / (outformat->width);\r\n}\r\nvoid\r\nstatic resizer_enable_422_420_conversion(struct resizer_params *param,\r\nint index, bool en)\r\n{\r\nparam->rsz_rsc_param[index].cen = en;\r\nparam->rsz_rsc_param[index].yen = en;\r\n}\r\nstatic int\r\nresizer_calculate_sdram_offsets(struct vpfe_resizer_device *resizer, int index)\r\n{\r\nstruct resizer_params *param = &resizer->config;\r\nstruct v4l2_mbus_framefmt *outformat;\r\nint bytesperpixel = 2;\r\nint image_height;\r\nint image_width;\r\nint yuv_420 = 0;\r\nint offset = 0;\r\nif (index == RSZ_A)\r\noutformat = &resizer->resizer_a.formats[RESIZER_PAD_SOURCE];\r\nelse\r\noutformat = &resizer->resizer_b.formats[RESIZER_PAD_SOURCE];\r\nimage_height = outformat->height + 1;\r\nimage_width = outformat->width + 1;\r\nparam->ext_mem_param[index].c_offset = 0;\r\nparam->ext_mem_param[index].flip_ofst_y = 0;\r\nparam->ext_mem_param[index].flip_ofst_c = 0;\r\nif (outformat->code == V4L2_MBUS_FMT_YDYUYDYV8_1X16) {\r\nyuv_420 = 1;\r\nbytesperpixel = 1;\r\n}\r\nif (param->rsz_rsc_param[index].h_flip)\r\noffset = (image_width * bytesperpixel) - 1;\r\nif (param->rsz_rsc_param[index].v_flip)\r\noffset += (image_height - 1) *\r\nparam->ext_mem_param[index].rsz_sdr_oft_y;\r\nparam->ext_mem_param[index].flip_ofst_y = offset;\r\nif (!yuv_420)\r\nreturn 0;\r\noffset = 0;\r\nif (param->rsz_rsc_param[index].h_flip)\r\noffset = image_width - 1;\r\nif (param->rsz_rsc_param[index].v_flip)\r\noffset += (((image_height >> 1) - 1) *\r\nparam->ext_mem_param[index].rsz_sdr_oft_c);\r\nparam->ext_mem_param[index].flip_ofst_c = offset;\r\nparam->ext_mem_param[index].c_offset =\r\nparam->ext_mem_param[index].rsz_sdr_oft_y * image_height;\r\nreturn 0;\r\n}\r\nstatic int resizer_configure_output_win(struct vpfe_resizer_device *resizer)\r\n{\r\nstruct resizer_params *param = &resizer->config;\r\nstruct vpfe_rsz_output_spec output_specs;\r\nstruct v4l2_mbus_framefmt *outformat;\r\nint line_len_c;\r\nint line_len;\r\nint ret;\r\noutformat = &resizer->resizer_a.formats[RESIZER_PAD_SOURCE];\r\noutput_specs.vst_y = param->user_config.vst;\r\nif (outformat->code == V4L2_MBUS_FMT_YDYUYDYV8_1X16)\r\noutput_specs.vst_c = param->user_config.vst;\r\nconfigure_resizer_out_params(resizer, RSZ_A, &output_specs, 0, 0);\r\nresizer_calculate_line_length(outformat->code,\r\nparam->rsz_rsc_param[0].o_hsz + 1,\r\nparam->rsz_rsc_param[0].o_vsz + 1,\r\n&line_len, &line_len_c);\r\nparam->ext_mem_param[0].rsz_sdr_oft_y = line_len;\r\nparam->ext_mem_param[0].rsz_sdr_oft_c = line_len_c;\r\nresizer_calculate_resize_ratios(resizer, RSZ_A);\r\nif (param->rsz_en[RSZ_B])\r\nresizer_calculate_resize_ratios(resizer, RSZ_B);\r\nif (outformat->code == V4L2_MBUS_FMT_YDYUYDYV8_1X16)\r\nresizer_enable_422_420_conversion(param, RSZ_A, ENABLE);\r\nelse\r\nresizer_enable_422_420_conversion(param, RSZ_A, DISABLE);\r\nret = resizer_calculate_sdram_offsets(resizer, RSZ_A);\r\nif (!ret && param->rsz_en[RSZ_B])\r\nret = resizer_calculate_sdram_offsets(resizer, RSZ_B);\r\nif (ret)\r\npr_err("Error in calculating sdram offsets\n");\r\nreturn ret;\r\n}\r\nstatic int\r\nresizer_calculate_down_scale_f_div_param(struct device *dev,\r\nint input_width, int output_width,\r\nstruct resizer_scale_param *param)\r\n{\r\nunsigned int two_power;\r\nunsigned int upper_h1;\r\nunsigned int upper_h2;\r\nunsigned int val1;\r\nunsigned int val;\r\nunsigned int rsz;\r\nunsigned int h1;\r\nunsigned int h2;\r\nunsigned int o;\r\nunsigned int n;\r\nupper_h1 = input_width >> 1;\r\nn = param->h_dscale_ave_sz;\r\ntwo_power = 1 << (n + 1);\r\nupper_h1 = (upper_h1 >> (n + 1)) << (n + 1);\r\nupper_h2 = input_width - upper_h1;\r\nif (upper_h2 % two_power) {\r\ndev_err(dev, "frame halves to be a multiple of 2 power n+1\n");\r\nreturn -EINVAL;\r\n}\r\ntwo_power = 1 << n;\r\nrsz = (input_width << 8) / output_width;\r\nval = rsz * two_power;\r\nval = ((upper_h1 << 8) / val) + 1;\r\nif (!(val % 2)) {\r\nh1 = val;\r\n} else {\r\nval = upper_h1 << 8;\r\nval >>= n + 1;\r\nval -= rsz >> 1;\r\nval /= rsz << 1;\r\nval <<= 1;\r\nval += 2;\r\nh1 = val;\r\n}\r\no = 10 + (two_power << 2);\r\nif (((input_width << 7) / rsz) % 2)\r\no += (((CEIL(rsz, 1024)) << 1) << n);\r\nh2 = output_width - h1;\r\nval = (h1 * rsz) - (((upper_h1 - (o - 10)) / two_power) << 8);\r\nval1 = ((val - 1024) >> 9) << 1;\r\nparam->f_div.num_passes = MAX_PASSES;\r\nparam->f_div.pass[0].o_hsz = h1 - 1;\r\nparam->f_div.pass[0].i_hps = 0;\r\nparam->f_div.pass[0].h_phs = 0;\r\nparam->f_div.pass[0].src_hps = 0;\r\nparam->f_div.pass[0].src_hsz = upper_h1 + o;\r\nparam->f_div.pass[1].o_hsz = h2 - 1;\r\nparam->f_div.pass[1].i_hps = 10 + (val1 * two_power);\r\nparam->f_div.pass[1].h_phs = (val - (val1 << 8));\r\nparam->f_div.pass[1].src_hps = upper_h1 - o;\r\nparam->f_div.pass[1].src_hsz = upper_h2 + o;\r\nreturn 0;\r\n}\r\nstatic int\r\nresizer_configure_common_in_params(struct vpfe_resizer_device *resizer)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nstruct resizer_params *param = &resizer->config;\r\nstruct vpfe_rsz_config_params *user_config;\r\nstruct v4l2_mbus_framefmt *informat;\r\ninformat = &resizer->crop_resizer.formats[RESIZER_CROP_PAD_SINK];\r\nuser_config = &resizer->config.user_config;\r\nparam->rsz_common.vps = param->user_config.vst;\r\nparam->rsz_common.hps = param->user_config.hst;\r\nif (vpfe_ipipeif_decimation_enabled(vpfe_dev))\r\nparam->rsz_common.hsz = (((informat->width - 1) *\r\nIPIPEIF_RSZ_CONST) / vpfe_ipipeif_get_rsz(vpfe_dev));\r\nelse\r\nparam->rsz_common.hsz = informat->width - 1;\r\nif (informat->field == V4L2_FIELD_INTERLACED)\r\nparam->rsz_common.vsz = (informat->height - 1) >> 1;\r\nelse\r\nparam->rsz_common.vsz = informat->height - 1;\r\nparam->rsz_common.raw_flip = 0;\r\nif (resizer->crop_resizer.input == RESIZER_CROP_INPUT_IPIPEIF)\r\nparam->rsz_common.source = IPIPEIF_DATA;\r\nelse\r\nparam->rsz_common.source = IPIPE_DATA;\r\nswitch (informat->code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nparam->rsz_common.src_img_fmt = RSZ_IMG_422;\r\nparam->rsz_common.raw_flip = 0;\r\nbreak;\r\ncase V4L2_MBUS_FMT_Y8_1X8:\r\nparam->rsz_common.src_img_fmt = RSZ_IMG_420;\r\nparam->rsz_common.y_c = 0;\r\nparam->rsz_common.raw_flip = 0;\r\nbreak;\r\ncase V4L2_MBUS_FMT_UV8_1X8:\r\nparam->rsz_common.src_img_fmt = RSZ_IMG_420;\r\nparam->rsz_common.y_c = 1;\r\nparam->rsz_common.raw_flip = 0;\r\nbreak;\r\ncase V4L2_MBUS_FMT_SGRBG12_1X12:\r\nparam->rsz_common.raw_flip = 1;\r\nbreak;\r\ndefault:\r\nparam->rsz_common.src_img_fmt = RSZ_IMG_422;\r\nparam->rsz_common.source = IPIPE_DATA;\r\n}\r\nparam->rsz_common.yuv_y_min = user_config->yuv_y_min;\r\nparam->rsz_common.yuv_y_max = user_config->yuv_y_max;\r\nparam->rsz_common.yuv_c_min = user_config->yuv_c_min;\r\nparam->rsz_common.yuv_c_max = user_config->yuv_c_max;\r\nparam->rsz_common.out_chr_pos = user_config->out_chr_pos;\r\nparam->rsz_common.rsz_seq_crv = user_config->chroma_sample_even;\r\nreturn 0;\r\n}\r\nstatic int\r\nresizer_configure_in_continious_mode(struct vpfe_resizer_device *resizer)\r\n{\r\nstruct device *dev = resizer->crop_resizer.subdev.v4l2_dev->dev;\r\nstruct resizer_params *param = &resizer->config;\r\nstruct vpfe_rsz_config_params *cont_config;\r\nint line_len_c;\r\nint line_len;\r\nint ret;\r\nif (resizer->resizer_a.output != RESIZER_OUPUT_MEMORY) {\r\ndev_err(dev, "enable resizer - Resizer-A\n");\r\nreturn -EINVAL;\r\n}\r\ncont_config = &resizer->config.user_config;\r\nparam->rsz_en[RSZ_A] = ENABLE;\r\nconfigure_resizer_out_params(resizer, RSZ_A,\r\n&cont_config->output1, 1, 0);\r\nparam->rsz_en[RSZ_B] = DISABLE;\r\nparam->oper_mode = RESIZER_MODE_CONTINIOUS;\r\nif (resizer->resizer_b.output == RESIZER_OUPUT_MEMORY) {\r\nstruct v4l2_mbus_framefmt *outformat2;\r\nparam->rsz_en[RSZ_B] = ENABLE;\r\noutformat2 = &resizer->resizer_b.formats[RESIZER_PAD_SOURCE];\r\nret = resizer_validate_output_image_format(dev, outformat2,\r\n&line_len, &line_len_c);\r\nif (ret)\r\nreturn ret;\r\nparam->ext_mem_param[RSZ_B].rsz_sdr_oft_y = line_len;\r\nparam->ext_mem_param[RSZ_B].rsz_sdr_oft_c = line_len_c;\r\nconfigure_resizer_out_params(resizer, RSZ_B,\r\n&cont_config->output2, 0, 1);\r\nif (outformat2->code == V4L2_MBUS_FMT_YDYUYDYV8_1X16)\r\nresizer_enable_422_420_conversion(param,\r\nRSZ_B, ENABLE);\r\nelse\r\nresizer_enable_422_420_conversion(param,\r\nRSZ_B, DISABLE);\r\n}\r\nresizer_configure_common_in_params(resizer);\r\nret = resizer_configure_output_win(resizer);\r\nif (ret)\r\nreturn ret;\r\nparam->rsz_common.passthrough = cont_config->bypass;\r\nif (cont_config->bypass)\r\nresizer_configure_passthru(resizer, 1);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nresizer_validate_input_image_format(struct device *dev,\r\nenum v4l2_mbus_pixelcode pix,\r\nint width, int height, int *line_len)\r\n{\r\nint val;\r\nif (pix != V4L2_MBUS_FMT_UYVY8_2X8 &&\r\npix != V4L2_MBUS_FMT_Y8_1X8 &&\r\npix != V4L2_MBUS_FMT_UV8_1X8 &&\r\npix != V4L2_MBUS_FMT_SGRBG12_1X12) {\r\ndev_err(dev,\r\n"resizer validate output: pix format not supported, %d\n", pix);\r\nreturn -EINVAL;\r\n}\r\nif (!width || !height) {\r\ndev_err(dev,\r\n"resizer validate input: invalid width or height\n");\r\nreturn -EINVAL;\r\n}\r\nif (pix == V4L2_MBUS_FMT_UV8_1X8)\r\nresizer_calculate_line_length(pix, width,\r\nheight, &val, line_len);\r\nelse\r\nresizer_calculate_line_length(pix, width,\r\nheight, line_len, &val);\r\nreturn 0;\r\n}\r\nstatic int\r\nresizer_validate_decimation(struct device *dev, enum ipipeif_decimation dec_en,\r\nunsigned char rsz, unsigned char frame_div_mode_en,\r\nint width)\r\n{\r\nif (dec_en && frame_div_mode_en) {\r\ndev_err(dev,\r\n"dec_en & frame_div_mode_en can not enabled simultaneously\n");\r\nreturn -EINVAL;\r\n}\r\nif (frame_div_mode_en) {\r\ndev_err(dev, "frame_div_mode mode not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!dec_en)\r\nreturn 0;\r\nif (width <= VPFE_IPIPE_MAX_INPUT_WIDTH) {\r\ndev_err(dev,\r\n"image width to be more than %d for decimation\n",\r\nVPFE_IPIPE_MAX_INPUT_WIDTH);\r\nreturn -EINVAL;\r\n}\r\nif (rsz < IPIPEIF_RSZ_MIN || rsz > IPIPEIF_RSZ_MAX) {\r\ndev_err(dev, "rsz range is %d to %d\n",\r\nIPIPEIF_RSZ_MIN, IPIPEIF_RSZ_MAX);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nresizer_calculate_normal_f_div_param(struct device *dev, int input_width,\r\nint output_width, struct resizer_scale_param *param)\r\n{\r\nunsigned int val1;\r\nunsigned int rsz;\r\nunsigned int val;\r\nunsigned int h1;\r\nunsigned int h2;\r\nunsigned int o;\r\nif (output_width > input_width) {\r\ndev_err(dev, "frame div mode is used for scale down only\n");\r\nreturn -EINVAL;\r\n}\r\nrsz = (input_width << 8) / output_width;\r\nval = rsz << 1;\r\nval = ((input_width << 8) / val) + 1;\r\no = 14;\r\nif (!(val % 2)) {\r\nh1 = val;\r\n} else {\r\nval = (input_width << 7);\r\nval -= rsz >> 1;\r\nval /= rsz << 1;\r\nval <<= 1;\r\nval += 2;\r\no += ((CEIL(rsz, 1024)) << 1);\r\nh1 = val;\r\n}\r\nh2 = output_width - h1;\r\nval = (h1 * rsz) - (((input_width >> 1) - o) << 8);\r\nval1 = ((val - 1024) >> 9) << 1;\r\nparam->f_div.num_passes = MAX_PASSES;\r\nparam->f_div.pass[0].o_hsz = h1 - 1;\r\nparam->f_div.pass[0].i_hps = 0;\r\nparam->f_div.pass[0].h_phs = 0;\r\nparam->f_div.pass[0].src_hps = 0;\r\nparam->f_div.pass[0].src_hsz = (input_width >> 2) + o;\r\nparam->f_div.pass[1].o_hsz = h2 - 1;\r\nparam->f_div.pass[1].i_hps = val1;\r\nparam->f_div.pass[1].h_phs = (val - (val1 << 8));\r\nparam->f_div.pass[1].src_hps = (input_width >> 2) - o;\r\nparam->f_div.pass[1].src_hsz = (input_width >> 2) + o;\r\nreturn 0;\r\n}\r\nstatic int\r\nresizer_configure_in_single_shot_mode(struct vpfe_resizer_device *resizer)\r\n{\r\nstruct vpfe_rsz_config_params *config = &resizer->config.user_config;\r\nstruct device *dev = resizer->crop_resizer.subdev.v4l2_dev->dev;\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nstruct v4l2_mbus_framefmt *outformat1, *outformat2;\r\nstruct resizer_params *param = &resizer->config;\r\nstruct v4l2_mbus_framefmt *informat;\r\nint decimation;\r\nint line_len_c;\r\nint line_len;\r\nint rsz;\r\nint ret;\r\ninformat = &resizer->crop_resizer.formats[RESIZER_CROP_PAD_SINK];\r\noutformat1 = &resizer->resizer_a.formats[RESIZER_PAD_SOURCE];\r\noutformat2 = &resizer->resizer_b.formats[RESIZER_PAD_SOURCE];\r\ndecimation = vpfe_ipipeif_decimation_enabled(vpfe_dev);\r\nrsz = vpfe_ipipeif_get_rsz(vpfe_dev);\r\nif (decimation && param->user_config.frame_div_mode_en) {\r\ndev_err(dev,\r\n"dec_en & frame_div_mode_en cannot enabled simultaneously\n");\r\nreturn -EINVAL;\r\n}\r\nret = resizer_validate_decimation(dev, decimation, rsz,\r\nparam->user_config.frame_div_mode_en, informat->width);\r\nif (ret)\r\nreturn -EINVAL;\r\nret = resizer_validate_input_image_format(dev, informat->code,\r\ninformat->width, informat->height, &line_len);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (resizer->resizer_a.output != RESIZER_OUTPUT_NONE) {\r\nparam->rsz_en[RSZ_A] = ENABLE;\r\nret = resizer_validate_output_image_format(dev, outformat1,\r\n&line_len, &line_len_c);\r\nif (ret)\r\nreturn ret;\r\nparam->ext_mem_param[RSZ_A].rsz_sdr_oft_y = line_len;\r\nparam->ext_mem_param[RSZ_A].rsz_sdr_oft_c = line_len_c;\r\nconfigure_resizer_out_params(resizer, RSZ_A,\r\n&param->user_config.output1, 0, 1);\r\nif (outformat1->code == V4L2_MBUS_FMT_SGRBG12_1X12)\r\nparam->rsz_common.raw_flip = 1;\r\nelse\r\nparam->rsz_common.raw_flip = 0;\r\nif (outformat1->code == V4L2_MBUS_FMT_YDYUYDYV8_1X16)\r\nresizer_enable_422_420_conversion(param,\r\nRSZ_A, ENABLE);\r\nelse\r\nresizer_enable_422_420_conversion(param,\r\nRSZ_A, DISABLE);\r\n}\r\nif (resizer->resizer_b.output != RESIZER_OUTPUT_NONE) {\r\nparam->rsz_en[RSZ_B] = ENABLE;\r\nret = resizer_validate_output_image_format(dev, outformat2,\r\n&line_len, &line_len_c);\r\nif (ret)\r\nreturn ret;\r\nparam->ext_mem_param[RSZ_B].rsz_sdr_oft_y = line_len;\r\nparam->ext_mem_param[RSZ_B].rsz_sdr_oft_c = line_len_c;\r\nconfigure_resizer_out_params(resizer, RSZ_B,\r\n&param->user_config.output2, 0, 1);\r\nif (outformat2->code == V4L2_MBUS_FMT_YDYUYDYV8_1X16)\r\nresizer_enable_422_420_conversion(param,\r\nRSZ_B, ENABLE);\r\nelse\r\nresizer_enable_422_420_conversion(param,\r\nRSZ_B, DISABLE);\r\n}\r\nresizer_configure_common_in_params(resizer);\r\nif (resizer->resizer_a.output != RESIZER_OUTPUT_NONE) {\r\nresizer_calculate_resize_ratios(resizer, RSZ_A);\r\nresizer_calculate_sdram_offsets(resizer, RSZ_A);\r\nif (informat->code == V4L2_MBUS_FMT_UV8_1X8) {\r\nparam->rsz_rsc_param[RSZ_A].v_dif =\r\n(((informat->height + 1) * 2) * 256) /\r\n(param->rsz_rsc_param[RSZ_A].o_vsz + 1);\r\n}\r\n}\r\nif (resizer->resizer_b.output != RESIZER_OUTPUT_NONE) {\r\nresizer_calculate_resize_ratios(resizer, RSZ_B);\r\nresizer_calculate_sdram_offsets(resizer, RSZ_B);\r\nif (informat->code == V4L2_MBUS_FMT_UV8_1X8) {\r\nparam->rsz_rsc_param[RSZ_B].v_dif =\r\n(((informat->height + 1) * 2) * 256) /\r\n(param->rsz_rsc_param[RSZ_B].o_vsz + 1);\r\n}\r\n}\r\nif (param->user_config.frame_div_mode_en &&\r\nparam->rsz_en[RSZ_A]) {\r\nif (!param->rsz_rsc_param[RSZ_A].dscale_en)\r\nret = resizer_calculate_normal_f_div_param(dev,\r\ninformat->width,\r\nparam->rsz_rsc_param[RSZ_A].o_vsz + 1,\r\n&param->rsz_rsc_param[RSZ_A]);\r\nelse\r\nret = resizer_calculate_down_scale_f_div_param(dev,\r\ninformat->width,\r\nparam->rsz_rsc_param[RSZ_A].o_vsz + 1,\r\n&param->rsz_rsc_param[RSZ_A]);\r\nif (ret)\r\nreturn -EINVAL;\r\n}\r\nif (param->user_config.frame_div_mode_en &&\r\nparam->rsz_en[RSZ_B]) {\r\nif (!param->rsz_rsc_param[RSZ_B].dscale_en)\r\nret = resizer_calculate_normal_f_div_param(dev,\r\ninformat->width,\r\nparam->rsz_rsc_param[RSZ_B].o_vsz + 1,\r\n&param->rsz_rsc_param[RSZ_B]);\r\nelse\r\nret = resizer_calculate_down_scale_f_div_param(dev,\r\ninformat->width,\r\nparam->rsz_rsc_param[RSZ_B].o_vsz + 1,\r\n&param->rsz_rsc_param[RSZ_B]);\r\nif (ret)\r\nreturn -EINVAL;\r\n}\r\nparam->rsz_common.passthrough = config->bypass;\r\nif (config->bypass)\r\nresizer_configure_passthru(resizer, 1);\r\nreturn 0;\r\n}\r\nstatic void\r\nresizer_set_defualt_configuration(struct vpfe_resizer_device *resizer)\r\n{\r\n#define WIDTH_I 640\r\n#define HEIGHT_I 480\r\n#define WIDTH_O 640\r\n#define HEIGHT_O 480\r\nconst struct resizer_params rsz_default_config = {\r\n.oper_mode = RESIZER_MODE_ONE_SHOT,\r\n.rsz_common = {\r\n.vsz = HEIGHT_I - 1,\r\n.hsz = WIDTH_I - 1,\r\n.src_img_fmt = RSZ_IMG_422,\r\n.raw_flip = 1,\r\n.source = IPIPE_DATA,\r\n.passthrough = BYPASS_OFF,\r\n.yuv_y_max = 255,\r\n.yuv_c_max = 255,\r\n.rsz_seq_crv = DISABLE,\r\n.out_chr_pos = VPFE_IPIPE_YUV422_CHR_POS_COSITE,\r\n},\r\n.rsz_rsc_param = {\r\n{\r\n.h_flip = DISABLE,\r\n.v_flip = DISABLE,\r\n.cen = DISABLE,\r\n.yen = DISABLE,\r\n.o_vsz = HEIGHT_O - 1,\r\n.o_hsz = WIDTH_O - 1,\r\n.v_dif = 256,\r\n.v_typ_y = VPFE_RSZ_INTP_CUBIC,\r\n.h_typ_c = VPFE_RSZ_INTP_CUBIC,\r\n.h_dif = 256,\r\n.h_typ_y = VPFE_RSZ_INTP_CUBIC,\r\n.h_typ_c = VPFE_RSZ_INTP_CUBIC,\r\n.h_dscale_ave_sz =\r\nVPFE_IPIPE_DWN_SCALE_1_OVER_2,\r\n.v_dscale_ave_sz =\r\nVPFE_IPIPE_DWN_SCALE_1_OVER_2,\r\n},\r\n{\r\n.h_flip = DISABLE,\r\n.v_flip = DISABLE,\r\n.cen = DISABLE,\r\n.yen = DISABLE,\r\n.o_vsz = HEIGHT_O - 1,\r\n.o_hsz = WIDTH_O - 1,\r\n.v_dif = 256,\r\n.v_typ_y = VPFE_RSZ_INTP_CUBIC,\r\n.h_typ_c = VPFE_RSZ_INTP_CUBIC,\r\n.h_dif = 256,\r\n.h_typ_y = VPFE_RSZ_INTP_CUBIC,\r\n.h_typ_c = VPFE_RSZ_INTP_CUBIC,\r\n.h_dscale_ave_sz =\r\nVPFE_IPIPE_DWN_SCALE_1_OVER_2,\r\n.v_dscale_ave_sz =\r\nVPFE_IPIPE_DWN_SCALE_1_OVER_2,\r\n},\r\n},\r\n.rsz2rgb = {\r\n{\r\n.rgb_en = DISABLE\r\n},\r\n{\r\n.rgb_en = DISABLE\r\n}\r\n},\r\n.ext_mem_param = {\r\n{\r\n.rsz_sdr_oft_y = WIDTH_O << 1,\r\n.rsz_sdr_ptr_e_y = HEIGHT_O,\r\n.rsz_sdr_oft_c = WIDTH_O,\r\n.rsz_sdr_ptr_e_c = HEIGHT_O >> 1,\r\n},\r\n{\r\n.rsz_sdr_oft_y = WIDTH_O << 1,\r\n.rsz_sdr_ptr_e_y = HEIGHT_O,\r\n.rsz_sdr_oft_c = WIDTH_O,\r\n.rsz_sdr_ptr_e_c = HEIGHT_O,\r\n},\r\n},\r\n.rsz_en[0] = ENABLE,\r\n.rsz_en[1] = DISABLE,\r\n.user_config = {\r\n.output1 = {\r\n.v_typ_y = VPFE_RSZ_INTP_CUBIC,\r\n.v_typ_c = VPFE_RSZ_INTP_CUBIC,\r\n.h_typ_y = VPFE_RSZ_INTP_CUBIC,\r\n.h_typ_c = VPFE_RSZ_INTP_CUBIC,\r\n.h_dscale_ave_sz =\r\nVPFE_IPIPE_DWN_SCALE_1_OVER_2,\r\n.v_dscale_ave_sz =\r\nVPFE_IPIPE_DWN_SCALE_1_OVER_2,\r\n},\r\n.output2 = {\r\n.v_typ_y = VPFE_RSZ_INTP_CUBIC,\r\n.v_typ_c = VPFE_RSZ_INTP_CUBIC,\r\n.h_typ_y = VPFE_RSZ_INTP_CUBIC,\r\n.h_typ_c = VPFE_RSZ_INTP_CUBIC,\r\n.h_dscale_ave_sz =\r\nVPFE_IPIPE_DWN_SCALE_1_OVER_2,\r\n.v_dscale_ave_sz =\r\nVPFE_IPIPE_DWN_SCALE_1_OVER_2,\r\n},\r\n.yuv_y_max = 255,\r\n.yuv_c_max = 255,\r\n.out_chr_pos = VPFE_IPIPE_YUV422_CHR_POS_COSITE,\r\n},\r\n};\r\nmemset(&resizer->config, 0, sizeof(struct resizer_params));\r\nmemcpy(&resizer->config, &rsz_default_config,\r\nsizeof(struct resizer_params));\r\n}\r\nstatic int\r\nresizer_set_configuration(struct vpfe_resizer_device *resizer,\r\nstruct vpfe_rsz_config *chan_config)\r\n{\r\nif (!chan_config->config)\r\nresizer_set_defualt_configuration(resizer);\r\nelse\r\nif (copy_from_user(&resizer->config.user_config,\r\nchan_config->config, sizeof(struct vpfe_rsz_config_params)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nresizer_get_configuration(struct vpfe_resizer_device *resizer,\r\nstruct vpfe_rsz_config *chan_config)\r\n{\r\nstruct device *dev = resizer->crop_resizer.subdev.v4l2_dev->dev;\r\nif (!chan_config->config) {\r\ndev_err(dev, "Resizer channel invalid pointer\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_to_user((void *)chan_config->config,\r\n(void *)&resizer->config.user_config,\r\nsizeof(struct vpfe_rsz_config_params))) {\r\ndev_err(dev, "resizer_get_configuration: Error in copy to user\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int resizer_a_video_out_queue(struct vpfe_device *vpfe_dev,\r\nunsigned long addr)\r\n{\r\nstruct vpfe_resizer_device *resizer = &vpfe_dev->vpfe_resizer;\r\nreturn resizer_set_outaddr(resizer->base_addr,\r\n&resizer->config, RSZ_A, addr);\r\n}\r\nstatic int resizer_b_video_out_queue(struct vpfe_device *vpfe_dev,\r\nunsigned long addr)\r\n{\r\nstruct vpfe_resizer_device *resizer = &vpfe_dev->vpfe_resizer;\r\nreturn resizer_set_outaddr(resizer->base_addr,\r\n&resizer->config, RSZ_B, addr);\r\n}\r\nstatic void resizer_enable(struct vpfe_resizer_device *resizer, int en)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nu16 ipipeif_sink = vpfe_dev->vpfe_ipipeif.input;\r\nunsigned char val;\r\nif (resizer->crop_resizer.input == RESIZER_CROP_INPUT_NONE)\r\nreturn;\r\nif (resizer->crop_resizer.input == RESIZER_CROP_INPUT_IPIPEIF &&\r\nipipeif_sink == IPIPEIF_INPUT_MEMORY) {\r\ndo {\r\nval = regr_rsz(resizer->base_addr, RSZ_SRC_EN);\r\n} while (val);\r\nif (resizer->resizer_a.output != RESIZER_OUTPUT_NONE) {\r\ndo {\r\nval = regr_rsz(resizer->base_addr, RSZ_A);\r\n} while (val);\r\n}\r\nif (resizer->resizer_b.output != RESIZER_OUTPUT_NONE) {\r\ndo {\r\nval = regr_rsz(resizer->base_addr, RSZ_B);\r\n} while (val);\r\n}\r\n}\r\nif (resizer->resizer_a.output != RESIZER_OUTPUT_NONE)\r\nrsz_enable(resizer->base_addr, RSZ_A, en);\r\nif (resizer->resizer_b.output != RESIZER_OUTPUT_NONE)\r\nrsz_enable(resizer->base_addr, RSZ_B, en);\r\n}\r\nstatic void resizer_ss_isr(struct vpfe_resizer_device *resizer)\r\n{\r\nstruct vpfe_video_device *video_out = &resizer->resizer_a.video_out;\r\nstruct vpfe_video_device *video_out2 = &resizer->resizer_b.video_out;\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nstruct vpfe_pipeline *pipe = &video_out->pipe;\r\nu16 ipipeif_sink = vpfe_dev->vpfe_ipipeif.input;\r\nu32 val;\r\nif (ipipeif_sink != IPIPEIF_INPUT_MEMORY)\r\nreturn;\r\nif (resizer->resizer_a.output == RESIZER_OUPUT_MEMORY) {\r\nval = vpss_dma_complete_interrupt();\r\nif (val != 0 && val != 2)\r\nreturn;\r\n}\r\nif (resizer->resizer_a.output == RESIZER_OUPUT_MEMORY) {\r\nspin_lock(&video_out->dma_queue_lock);\r\nvpfe_video_process_buffer_complete(video_out);\r\nvideo_out->state = VPFE_VIDEO_BUFFER_NOT_QUEUED;\r\nvpfe_video_schedule_next_buffer(video_out);\r\nspin_unlock(&video_out->dma_queue_lock);\r\n}\r\nif (pipe->output_num > 1 && resizer->resizer_b.output ==\r\nRESIZER_OUPUT_MEMORY) {\r\nspin_lock(&video_out->dma_queue_lock);\r\nvpfe_video_process_buffer_complete(video_out2);\r\nvideo_out2->state = VPFE_VIDEO_BUFFER_NOT_QUEUED;\r\nvpfe_video_schedule_next_buffer(video_out2);\r\nspin_unlock(&video_out2->dma_queue_lock);\r\n}\r\nif (vpfe_video_is_pipe_ready(pipe) &&\r\nresizer->resizer_a.output == RESIZER_OUPUT_MEMORY) {\r\nresizer_enable(resizer, 1);\r\nvpfe_ipipe_enable(vpfe_dev, 1);\r\nvpfe_ipipeif_enable(vpfe_dev);\r\n}\r\n}\r\nvoid vpfe_resizer_buffer_isr(struct vpfe_resizer_device *resizer)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nstruct vpfe_video_device *video_out = &resizer->resizer_a.video_out;\r\nstruct vpfe_video_device *video_out2 = &resizer->resizer_b.video_out;\r\nstruct vpfe_pipeline *pipe = &resizer->resizer_a.video_out.pipe;\r\nenum v4l2_field field;\r\nint fid;\r\nif (!video_out->started)\r\nreturn;\r\nif (resizer->crop_resizer.input == RESIZER_CROP_INPUT_NONE)\r\nreturn;\r\nfield = video_out->fmt.fmt.pix.field;\r\nif (field == V4L2_FIELD_NONE) {\r\nif (video_out->cur_frm != video_out->next_frm) {\r\nvpfe_video_process_buffer_complete(video_out);\r\nif (pipe->output_num > 1)\r\nvpfe_video_process_buffer_complete(video_out2);\r\n}\r\nvideo_out->skip_frame_count--;\r\nif (!video_out->skip_frame_count) {\r\nvideo_out->skip_frame_count =\r\nvideo_out->skip_frame_count_init;\r\nrsz_src_enable(resizer->base_addr, 1);\r\n} else {\r\nrsz_src_enable(resizer->base_addr, 0);\r\n}\r\nreturn;\r\n}\r\nfid = vpfe_isif_get_fid(vpfe_dev);\r\nvideo_out->field_id ^= 1;\r\nif (fid == video_out->field_id) {\r\nif (fid == 0 && video_out->cur_frm != video_out->next_frm) {\r\nvpfe_video_process_buffer_complete(video_out);\r\nif (pipe->output_num > 1)\r\nvpfe_video_process_buffer_complete(video_out2);\r\n}\r\n} else if (fid == 0) {\r\nvideo_out->field_id = fid;\r\n}\r\n}\r\nvoid vpfe_resizer_dma_isr(struct vpfe_resizer_device *resizer)\r\n{\r\nstruct vpfe_video_device *video_out2 = &resizer->resizer_b.video_out;\r\nstruct vpfe_video_device *video_out = &resizer->resizer_a.video_out;\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nstruct vpfe_pipeline *pipe = &video_out->pipe;\r\nint schedule_capture = 0;\r\nenum v4l2_field field;\r\nint fid;\r\nif (!video_out->started)\r\nreturn;\r\nif (pipe->state == VPFE_PIPELINE_STREAM_SINGLESHOT) {\r\nresizer_ss_isr(resizer);\r\nreturn;\r\n}\r\nfield = video_out->fmt.fmt.pix.field;\r\nif (field == V4L2_FIELD_NONE) {\r\nif (!list_empty(&video_out->dma_queue) &&\r\nvideo_out->cur_frm == video_out->next_frm)\r\nschedule_capture = 1;\r\n} else {\r\nfid = vpfe_isif_get_fid(vpfe_dev);\r\nif (fid == video_out->field_id) {\r\nif (fid == 1 && !list_empty(&video_out->dma_queue) &&\r\nvideo_out->cur_frm == video_out->next_frm)\r\nschedule_capture = 1;\r\n}\r\n}\r\nif (!schedule_capture)\r\nreturn;\r\nspin_lock(&video_out->dma_queue_lock);\r\nvpfe_video_schedule_next_buffer(video_out);\r\nspin_unlock(&video_out->dma_queue_lock);\r\nif (pipe->output_num > 1) {\r\nspin_lock(&video_out2->dma_queue_lock);\r\nvpfe_video_schedule_next_buffer(video_out2);\r\nspin_unlock(&video_out2->dma_queue_lock);\r\n}\r\n}\r\nstatic long resizer_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct vpfe_resizer_device *resizer = v4l2_get_subdevdata(sd);\r\nstruct device *dev = resizer->crop_resizer.subdev.v4l2_dev->dev;\r\nstruct vpfe_rsz_config *user_config;\r\nint ret = -ENOIOCTLCMD;\r\nif (&resizer->crop_resizer.subdev != sd)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase VIDIOC_VPFE_RSZ_S_CONFIG:\r\nuser_config = (struct vpfe_rsz_config *)arg;\r\nret = resizer_set_configuration(resizer, user_config);\r\nbreak;\r\ncase VIDIOC_VPFE_RSZ_G_CONFIG:\r\nuser_config = (struct vpfe_rsz_config *)arg;\r\nif (!user_config->config) {\r\ndev_err(dev, "error in VIDIOC_VPFE_RSZ_G_CONFIG\n");\r\nreturn -EINVAL;\r\n}\r\nret = resizer_get_configuration(resizer, user_config);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int resizer_do_hw_setup(struct vpfe_resizer_device *resizer)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nu16 ipipeif_sink = vpfe_dev->vpfe_ipipeif.input;\r\nu16 ipipeif_source = vpfe_dev->vpfe_ipipeif.output;\r\nstruct resizer_params *param = &resizer->config;\r\nint ret = 0;\r\nif (resizer->resizer_a.output == RESIZER_OUPUT_MEMORY ||\r\nresizer->resizer_b.output == RESIZER_OUPUT_MEMORY) {\r\nif (ipipeif_sink == IPIPEIF_INPUT_MEMORY &&\r\nipipeif_source == IPIPEIF_OUTPUT_RESIZER)\r\nret = resizer_configure_in_single_shot_mode(resizer);\r\nelse\r\nret = resizer_configure_in_continious_mode(resizer);\r\nif (ret)\r\nreturn ret;\r\nret = config_rsz_hw(resizer, param);\r\n}\r\nreturn ret;\r\n}\r\nstatic int resizer_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct vpfe_resizer_device *resizer = v4l2_get_subdevdata(sd);\r\nif (&resizer->crop_resizer.subdev != sd)\r\nreturn 0;\r\nif (resizer->resizer_a.output != RESIZER_OUPUT_MEMORY)\r\nreturn 0;\r\nswitch (enable) {\r\ncase 1:\r\nif (resizer_do_hw_setup(resizer) < 0)\r\nreturn -EINVAL;\r\nresizer_enable(resizer, enable);\r\nbreak;\r\ncase 0:\r\nresizer_enable(resizer, enable);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__resizer_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nstruct vpfe_resizer_device *resizer = v4l2_get_subdevdata(sd);\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\nif (&resizer->crop_resizer.subdev == sd)\r\nreturn &resizer->crop_resizer.formats[pad];\r\nif (&resizer->resizer_a.subdev == sd)\r\nreturn &resizer->resizer_a.formats[pad];\r\nif (&resizer->resizer_b.subdev == sd)\r\nreturn &resizer->resizer_b.formats[pad];\r\nreturn NULL;\r\n}\r\nstatic void\r\nresizer_try_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, struct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nstruct vpfe_resizer_device *resizer = v4l2_get_subdevdata(sd);\r\nunsigned int max_out_height;\r\nunsigned int max_out_width;\r\nunsigned int i;\r\nif ((&resizer->resizer_a.subdev == sd && pad == RESIZER_PAD_SINK) ||\r\n(&resizer->resizer_b.subdev == sd && pad == RESIZER_PAD_SINK) ||\r\n(&resizer->crop_resizer.subdev == sd &&\r\n(pad == RESIZER_CROP_PAD_SOURCE ||\r\npad == RESIZER_CROP_PAD_SOURCE2 || pad == RESIZER_CROP_PAD_SINK))) {\r\nfor (i = 0; i < ARRAY_SIZE(resizer_input_formats); i++) {\r\nif (fmt->code == resizer_input_formats[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(resizer_input_formats))\r\nfmt->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nfmt->width = clamp_t(u32, fmt->width, MIN_IN_WIDTH,\r\nMAX_IN_WIDTH);\r\nfmt->height = clamp_t(u32, fmt->height, MIN_IN_HEIGHT,\r\nMAX_IN_HEIGHT);\r\n} else if (&resizer->resizer_a.subdev == sd &&\r\npad == RESIZER_PAD_SOURCE) {\r\nmax_out_width = IPIPE_MAX_OUTPUT_WIDTH_A;\r\nmax_out_height = IPIPE_MAX_OUTPUT_HEIGHT_A;\r\nfor (i = 0; i < ARRAY_SIZE(resizer_output_formats); i++) {\r\nif (fmt->code == resizer_output_formats[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(resizer_output_formats))\r\nfmt->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nfmt->width = clamp_t(u32, fmt->width, MIN_OUT_WIDTH,\r\nmax_out_width);\r\nfmt->width &= ~15;\r\nfmt->height = clamp_t(u32, fmt->height, MIN_OUT_HEIGHT,\r\nmax_out_height);\r\n} else if (&resizer->resizer_b.subdev == sd &&\r\npad == RESIZER_PAD_SOURCE) {\r\nmax_out_width = IPIPE_MAX_OUTPUT_WIDTH_B;\r\nmax_out_height = IPIPE_MAX_OUTPUT_HEIGHT_B;\r\nfor (i = 0; i < ARRAY_SIZE(resizer_output_formats); i++) {\r\nif (fmt->code == resizer_output_formats[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(resizer_output_formats))\r\nfmt->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nfmt->width = clamp_t(u32, fmt->width, MIN_OUT_WIDTH,\r\nmax_out_width);\r\nfmt->width &= ~15;\r\nfmt->height = clamp_t(u32, fmt->height, MIN_OUT_HEIGHT,\r\nmax_out_height);\r\n}\r\n}\r\nstatic int resizer_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vpfe_resizer_device *resizer = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __resizer_get_format(sd, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nresizer_try_format(sd, fh, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nif (&resizer->crop_resizer.subdev == sd) {\r\nif (fmt->pad == RESIZER_CROP_PAD_SINK) {\r\nresizer->crop_resizer.formats[fmt->pad] = fmt->format;\r\n} else if (fmt->pad == RESIZER_CROP_PAD_SOURCE &&\r\nresizer->crop_resizer.output == RESIZER_A) {\r\nresizer->crop_resizer.formats[fmt->pad] = fmt->format;\r\nresizer->crop_resizer.\r\nformats[RESIZER_CROP_PAD_SOURCE2] = fmt->format;\r\n} else if (fmt->pad == RESIZER_CROP_PAD_SOURCE2 &&\r\nresizer->crop_resizer.output2 == RESIZER_B) {\r\nresizer->crop_resizer.formats[fmt->pad] = fmt->format;\r\nresizer->crop_resizer.\r\nformats[RESIZER_CROP_PAD_SOURCE] = fmt->format;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n} else if (&resizer->resizer_a.subdev == sd) {\r\nif (fmt->pad == RESIZER_PAD_SINK)\r\nresizer->resizer_a.formats[fmt->pad] = fmt->format;\r\nelse if (fmt->pad == RESIZER_PAD_SOURCE)\r\nresizer->resizer_a.formats[fmt->pad] = fmt->format;\r\nelse\r\nreturn -EINVAL;\r\n} else if (&resizer->resizer_b.subdev == sd) {\r\nif (fmt->pad == RESIZER_PAD_SINK)\r\nresizer->resizer_b.formats[fmt->pad] = fmt->format;\r\nelse if (fmt->pad == RESIZER_PAD_SOURCE)\r\nresizer->resizer_b.formats[fmt->pad] = fmt->format;\r\nelse\r\nreturn -EINVAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int resizer_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __resizer_get_format(sd, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int resizer_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\nresizer_try_format(sd, fh, fse->pad, &format,\r\nV4L2_SUBDEV_FORMAT_TRY);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\nresizer_try_format(sd, fh, fse->pad, &format,\r\nV4L2_SUBDEV_FORMAT_TRY);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int resizer_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad == RESIZER_PAD_SINK) {\r\nif (code->index >= ARRAY_SIZE(resizer_input_formats))\r\nreturn -EINVAL;\r\ncode->code = resizer_input_formats[code->index];\r\n} else if (code->pad == RESIZER_PAD_SOURCE) {\r\nif (code->index >= ARRAY_SIZE(resizer_output_formats))\r\nreturn -EINVAL;\r\ncode->code = resizer_output_formats[code->index];\r\n}\r\nreturn 0;\r\n}\r\nstatic int resizer_init_formats(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh)\r\n{\r\n__u32 which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nstruct vpfe_resizer_device *resizer = v4l2_get_subdevdata(sd);\r\nstruct v4l2_subdev_format format;\r\nif (&resizer->crop_resizer.subdev == sd) {\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = RESIZER_CROP_PAD_SINK;\r\nformat.which = which;\r\nformat.format.code = V4L2_MBUS_FMT_YUYV8_2X8;\r\nformat.format.width = MAX_IN_WIDTH;\r\nformat.format.height = MAX_IN_HEIGHT;\r\nresizer_set_format(sd, fh, &format);\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = RESIZER_CROP_PAD_SOURCE;\r\nformat.which = which;\r\nformat.format.code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nformat.format.width = MAX_IN_WIDTH;\r\nformat.format.height = MAX_IN_WIDTH;\r\nresizer_set_format(sd, fh, &format);\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = RESIZER_CROP_PAD_SOURCE2;\r\nformat.which = which;\r\nformat.format.code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nformat.format.width = MAX_IN_WIDTH;\r\nformat.format.height = MAX_IN_WIDTH;\r\nresizer_set_format(sd, fh, &format);\r\n} else if (&resizer->resizer_a.subdev == sd) {\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = RESIZER_PAD_SINK;\r\nformat.which = which;\r\nformat.format.code = V4L2_MBUS_FMT_YUYV8_2X8;\r\nformat.format.width = MAX_IN_WIDTH;\r\nformat.format.height = MAX_IN_HEIGHT;\r\nresizer_set_format(sd, fh, &format);\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = RESIZER_PAD_SOURCE;\r\nformat.which = which;\r\nformat.format.code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nformat.format.width = IPIPE_MAX_OUTPUT_WIDTH_A;\r\nformat.format.height = IPIPE_MAX_OUTPUT_HEIGHT_A;\r\nresizer_set_format(sd, fh, &format);\r\n} else if (&resizer->resizer_b.subdev == sd) {\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = RESIZER_PAD_SINK;\r\nformat.which = which;\r\nformat.format.code = V4L2_MBUS_FMT_YUYV8_2X8;\r\nformat.format.width = MAX_IN_WIDTH;\r\nformat.format.height = MAX_IN_HEIGHT;\r\nresizer_set_format(sd, fh, &format);\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = RESIZER_PAD_SOURCE;\r\nformat.which = which;\r\nformat.format.code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nformat.format.width = IPIPE_MAX_OUTPUT_WIDTH_B;\r\nformat.format.height = IPIPE_MAX_OUTPUT_HEIGHT_B;\r\nresizer_set_format(sd, fh, &format);\r\n}\r\nreturn 0;\r\n}\r\nstatic int resizer_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct vpfe_resizer_device *resizer = v4l2_get_subdevdata(sd);\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nu16 ipipeif_source = vpfe_dev->vpfe_ipipeif.output;\r\nu16 ipipe_source = vpfe_dev->vpfe_ipipe.output;\r\nif (&resizer->crop_resizer.subdev == sd) {\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase RESIZER_CROP_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nresizer->crop_resizer.input =\r\nRESIZER_CROP_INPUT_NONE;\r\nbreak;\r\n}\r\nif (resizer->crop_resizer.input !=\r\nRESIZER_CROP_INPUT_NONE)\r\nreturn -EBUSY;\r\nif (ipipeif_source == IPIPEIF_OUTPUT_RESIZER)\r\nresizer->crop_resizer.input =\r\nRESIZER_CROP_INPUT_IPIPEIF;\r\nelse if (ipipe_source == IPIPE_OUTPUT_RESIZER)\r\nresizer->crop_resizer.input =\r\nRESIZER_CROP_INPUT_IPIPE;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase RESIZER_CROP_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nresizer->crop_resizer.output =\r\nRESIZER_CROP_OUTPUT_NONE;\r\nbreak;\r\n}\r\nif (resizer->crop_resizer.output !=\r\nRESIZER_CROP_OUTPUT_NONE)\r\nreturn -EBUSY;\r\nresizer->crop_resizer.output = RESIZER_A;\r\nbreak;\r\ncase RESIZER_CROP_PAD_SOURCE2 | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nresizer->crop_resizer.output2 =\r\nRESIZER_CROP_OUTPUT_NONE;\r\nbreak;\r\n}\r\nif (resizer->crop_resizer.output2 !=\r\nRESIZER_CROP_OUTPUT_NONE)\r\nreturn -EBUSY;\r\nresizer->crop_resizer.output2 = RESIZER_B;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else if (&resizer->resizer_a.subdev == sd) {\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase RESIZER_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nresizer->resizer_a.input = RESIZER_INPUT_NONE;\r\nbreak;\r\n}\r\nif (resizer->resizer_a.input != RESIZER_INPUT_NONE)\r\nreturn -EBUSY;\r\nresizer->resizer_a.input = RESIZER_INPUT_CROP_RESIZER;\r\nbreak;\r\ncase RESIZER_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nresizer->resizer_a.output = RESIZER_OUTPUT_NONE;\r\nbreak;\r\n}\r\nif (resizer->resizer_a.output != RESIZER_OUTPUT_NONE)\r\nreturn -EBUSY;\r\nresizer->resizer_a.output = RESIZER_OUPUT_MEMORY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else if (&resizer->resizer_b.subdev == sd) {\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase RESIZER_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nresizer->resizer_b.input = RESIZER_INPUT_NONE;\r\nbreak;\r\n}\r\nif (resizer->resizer_b.input != RESIZER_INPUT_NONE)\r\nreturn -EBUSY;\r\nresizer->resizer_b.input = RESIZER_INPUT_CROP_RESIZER;\r\nbreak;\r\ncase RESIZER_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nresizer->resizer_b.output = RESIZER_OUTPUT_NONE;\r\nbreak;\r\n}\r\nif (resizer->resizer_b.output != RESIZER_OUTPUT_NONE)\r\nreturn -EBUSY;\r\nresizer->resizer_b.output = RESIZER_OUPUT_MEMORY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid vpfe_resizer_unregister_entities(struct vpfe_resizer_device *vpfe_rsz)\r\n{\r\nvpfe_video_unregister(&vpfe_rsz->resizer_a.video_out);\r\nvpfe_video_unregister(&vpfe_rsz->resizer_b.video_out);\r\nv4l2_device_unregister_subdev(&vpfe_rsz->crop_resizer.subdev);\r\nv4l2_device_unregister_subdev(&vpfe_rsz->resizer_a.subdev);\r\nv4l2_device_unregister_subdev(&vpfe_rsz->resizer_b.subdev);\r\nmedia_entity_cleanup(&vpfe_rsz->crop_resizer.subdev.entity);\r\nmedia_entity_cleanup(&vpfe_rsz->resizer_a.subdev.entity);\r\nmedia_entity_cleanup(&vpfe_rsz->resizer_b.subdev.entity);\r\n}\r\nint vpfe_resizer_register_entities(struct vpfe_resizer_device *resizer,\r\nstruct v4l2_device *vdev)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nunsigned int flags = 0;\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &resizer->crop_resizer.subdev);\r\nif (ret < 0) {\r\npr_err("Failed to register crop resizer as v4l2-subdev\n");\r\nreturn ret;\r\n}\r\nret = v4l2_device_register_subdev(vdev, &resizer->resizer_a.subdev);\r\nif (ret < 0) {\r\npr_err("Failed to register resizer-a as v4l2-subdev\n");\r\nreturn ret;\r\n}\r\nret = v4l2_device_register_subdev(vdev, &resizer->resizer_b.subdev);\r\nif (ret < 0) {\r\npr_err("Failed to register resizer-b as v4l2-subdev\n");\r\nreturn ret;\r\n}\r\nret = vpfe_video_register(&resizer->resizer_a.video_out, vdev);\r\nif (ret) {\r\npr_err("Failed to register RSZ-A video-out device\n");\r\ngoto out_video_out2_register;\r\n}\r\nresizer->resizer_a.video_out.vpfe_dev = vpfe_dev;\r\nret = vpfe_video_register(&resizer->resizer_b.video_out, vdev);\r\nif (ret) {\r\npr_err("Failed to register RSZ-B video-out device\n");\r\ngoto out_video_out2_register;\r\n}\r\nresizer->resizer_b.video_out.vpfe_dev = vpfe_dev;\r\nret = media_entity_create_link(&resizer->crop_resizer.subdev.entity, 1,\r\n&resizer->resizer_a.subdev.entity,\r\n0, flags);\r\nif (ret < 0)\r\ngoto out_create_link;\r\nret = media_entity_create_link(&resizer->crop_resizer.subdev.entity, 2,\r\n&resizer->resizer_b.subdev.entity,\r\n0, flags);\r\nif (ret < 0)\r\ngoto out_create_link;\r\nret = media_entity_create_link(&resizer->resizer_a.subdev.entity, 1,\r\n&resizer->resizer_a.video_out.video_dev.entity, 0, flags);\r\nif (ret < 0)\r\ngoto out_create_link;\r\nret = media_entity_create_link(&resizer->resizer_b.subdev.entity, 1,\r\n&resizer->resizer_b.video_out.video_dev.entity, 0, flags);\r\nif (ret < 0)\r\ngoto out_create_link;\r\nreturn 0;\r\nout_create_link:\r\nvpfe_video_unregister(&resizer->resizer_b.video_out);\r\nout_video_out2_register:\r\nvpfe_video_unregister(&resizer->resizer_a.video_out);\r\nv4l2_device_unregister_subdev(&resizer->crop_resizer.subdev);\r\nv4l2_device_unregister_subdev(&resizer->resizer_a.subdev);\r\nv4l2_device_unregister_subdev(&resizer->resizer_b.subdev);\r\nmedia_entity_cleanup(&resizer->crop_resizer.subdev.entity);\r\nmedia_entity_cleanup(&resizer->resizer_a.subdev.entity);\r\nmedia_entity_cleanup(&resizer->resizer_b.subdev.entity);\r\nreturn ret;\r\n}\r\nint vpfe_resizer_init(struct vpfe_resizer_device *vpfe_rsz,\r\nstruct platform_device *pdev)\r\n{\r\nstruct v4l2_subdev *sd = &vpfe_rsz->crop_resizer.subdev;\r\nstruct media_pad *pads = &vpfe_rsz->crop_resizer.pads[0];\r\nstruct media_entity *me = &sd->entity;\r\nstatic resource_size_t res_len;\r\nstruct resource *res;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 5);\r\nif (!res)\r\nreturn -ENOENT;\r\nres_len = resource_size(res);\r\nres = request_mem_region(res->start, res_len, res->name);\r\nif (!res)\r\nreturn -EBUSY;\r\nvpfe_rsz->base_addr = ioremap_nocache(res->start, res_len);\r\nif (!vpfe_rsz->base_addr)\r\nreturn -EBUSY;\r\nv4l2_subdev_init(sd, &resizer_v4l2_ops);\r\nsd->internal_ops = &resizer_v4l2_internal_ops;\r\nstrlcpy(sd->name, "DAVINCI RESIZER CROP", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, vpfe_rsz);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[RESIZER_CROP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[RESIZER_CROP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\npads[RESIZER_CROP_PAD_SOURCE2].flags = MEDIA_PAD_FL_SOURCE;\r\nvpfe_rsz->crop_resizer.input = RESIZER_CROP_INPUT_NONE;\r\nvpfe_rsz->crop_resizer.output = RESIZER_CROP_OUTPUT_NONE;\r\nvpfe_rsz->crop_resizer.output2 = RESIZER_CROP_OUTPUT_NONE;\r\nvpfe_rsz->crop_resizer.rsz_device = vpfe_rsz;\r\nme->ops = &resizer_media_ops;\r\nret = media_entity_init(me, RESIZER_CROP_PADS_NUM, pads, 0);\r\nif (ret)\r\nreturn ret;\r\nsd = &vpfe_rsz->resizer_a.subdev;\r\npads = &vpfe_rsz->resizer_a.pads[0];\r\nme = &sd->entity;\r\nv4l2_subdev_init(sd, &resizer_v4l2_ops);\r\nsd->internal_ops = &resizer_v4l2_internal_ops;\r\nstrlcpy(sd->name, "DAVINCI RESIZER A", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, vpfe_rsz);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[RESIZER_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[RESIZER_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nvpfe_rsz->resizer_a.input = RESIZER_INPUT_NONE;\r\nvpfe_rsz->resizer_a.output = RESIZER_OUTPUT_NONE;\r\nvpfe_rsz->resizer_a.rsz_device = vpfe_rsz;\r\nme->ops = &resizer_media_ops;\r\nret = media_entity_init(me, RESIZER_PADS_NUM, pads, 0);\r\nif (ret)\r\nreturn ret;\r\nsd = &vpfe_rsz->resizer_b.subdev;\r\npads = &vpfe_rsz->resizer_b.pads[0];\r\nme = &sd->entity;\r\nv4l2_subdev_init(sd, &resizer_v4l2_ops);\r\nsd->internal_ops = &resizer_v4l2_internal_ops;\r\nstrlcpy(sd->name, "DAVINCI RESIZER B", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, vpfe_rsz);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[RESIZER_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[RESIZER_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nvpfe_rsz->resizer_b.input = RESIZER_INPUT_NONE;\r\nvpfe_rsz->resizer_b.output = RESIZER_OUTPUT_NONE;\r\nvpfe_rsz->resizer_b.rsz_device = vpfe_rsz;\r\nme->ops = &resizer_media_ops;\r\nret = media_entity_init(me, RESIZER_PADS_NUM, pads, 0);\r\nif (ret)\r\nreturn ret;\r\nvpfe_rsz->resizer_a.video_out.ops = &resizer_a_video_ops;\r\nvpfe_rsz->resizer_a.video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = vpfe_video_init(&vpfe_rsz->resizer_a.video_out, "RSZ-A");\r\nif (ret) {\r\npr_err("Failed to init RSZ video-out device\n");\r\nreturn ret;\r\n}\r\nvpfe_rsz->resizer_b.video_out.ops = &resizer_b_video_ops;\r\nvpfe_rsz->resizer_b.video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = vpfe_video_init(&vpfe_rsz->resizer_b.video_out, "RSZ-B");\r\nif (ret) {\r\npr_err("Failed to init RSZ video-out2 device\n");\r\nreturn ret;\r\n}\r\nmemset(&vpfe_rsz->config, 0, sizeof(struct resizer_params));\r\nreturn 0;\r\n}\r\nvoid\r\nvpfe_resizer_cleanup(struct vpfe_resizer_device *vpfe_rsz,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\niounmap(vpfe_rsz->base_addr);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 5);\r\nif (res)\r\nrelease_mem_region(res->start,\r\nresource_size(res));\r\n}
