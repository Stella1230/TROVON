static struct master *__master_find(struct device *dev,\r\nconst struct component_master_ops *ops)\r\n{\r\nstruct master *m;\r\nlist_for_each_entry(m, &masters, node)\r\nif (m->dev == dev && (!ops || m->ops == ops))\r\nreturn m;\r\nreturn NULL;\r\n}\r\nstatic void component_attach_master(struct master *master, struct component *c)\r\n{\r\nc->master = master;\r\nlist_add_tail(&c->master_node, &master->components);\r\n}\r\nstatic void component_detach_master(struct master *master, struct component *c)\r\n{\r\nlist_del(&c->master_node);\r\nc->master = NULL;\r\n}\r\nint component_master_add_child(struct master *master,\r\nint (*compare)(struct device *, void *), void *compare_data)\r\n{\r\nstruct component *c;\r\nint ret = -ENXIO;\r\nlist_for_each_entry(c, &component_list, node) {\r\nif (c->master && c->master != master)\r\ncontinue;\r\nif (compare(c->dev, compare_data)) {\r\nif (!c->master)\r\ncomponent_attach_master(master, c);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int find_components(struct master *master)\r\n{\r\nstruct component_match *match = master->match;\r\nsize_t i;\r\nint ret = 0;\r\nif (!match) {\r\nreturn master->ops->add_components(master->dev, master);\r\n}\r\nfor (i = 0; i < match->num; i++) {\r\nret = component_master_add_child(master,\r\nmatch->compare[i].fn,\r\nmatch->compare[i].data);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void master_remove_components(struct master *master)\r\n{\r\nwhile (!list_empty(&master->components)) {\r\nstruct component *c = list_first_entry(&master->components,\r\nstruct component, master_node);\r\nWARN_ON(c->master != master);\r\ncomponent_detach_master(master, c);\r\n}\r\n}\r\nstatic int try_to_bring_up_master(struct master *master,\r\nstruct component *component)\r\n{\r\nint ret;\r\nif (master->bound)\r\nreturn 0;\r\nif (find_components(master)) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (component && component->master != master) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (!devres_open_group(master->dev, NULL, GFP_KERNEL)) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = master->ops->bind(master->dev);\r\nif (ret < 0) {\r\ndevres_release_group(master->dev, NULL);\r\ndev_info(master->dev, "master bind failed: %d\n", ret);\r\ngoto out;\r\n}\r\nmaster->bound = true;\r\nreturn 1;\r\nout:\r\nmaster_remove_components(master);\r\nreturn ret;\r\n}\r\nstatic int try_to_bring_up_masters(struct component *component)\r\n{\r\nstruct master *m;\r\nint ret = 0;\r\nlist_for_each_entry(m, &masters, node) {\r\nret = try_to_bring_up_master(m, component);\r\nif (ret != 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void take_down_master(struct master *master)\r\n{\r\nif (master->bound) {\r\nmaster->ops->unbind(master->dev);\r\ndevres_release_group(master->dev, NULL);\r\nmaster->bound = false;\r\n}\r\nmaster_remove_components(master);\r\n}\r\nstatic size_t component_match_size(size_t num)\r\n{\r\nreturn offsetof(struct component_match, compare[num]);\r\n}\r\nstatic struct component_match *component_match_realloc(struct device *dev,\r\nstruct component_match *match, size_t num)\r\n{\r\nstruct component_match *new;\r\nif (match && match->alloc == num)\r\nreturn match;\r\nnew = devm_kmalloc(dev, component_match_size(num), GFP_KERNEL);\r\nif (!new)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (match) {\r\nmemcpy(new, match, component_match_size(min(match->num, num)));\r\ndevm_kfree(dev, match);\r\n} else {\r\nnew->num = 0;\r\n}\r\nnew->alloc = num;\r\nreturn new;\r\n}\r\nvoid component_match_add(struct device *dev, struct component_match **matchptr,\r\nint (*compare)(struct device *, void *), void *compare_data)\r\n{\r\nstruct component_match *match = *matchptr;\r\nif (IS_ERR(match))\r\nreturn;\r\nif (!match || match->num == match->alloc) {\r\nsize_t new_size = match ? match->alloc + 16 : 15;\r\nmatch = component_match_realloc(dev, match, new_size);\r\n*matchptr = match;\r\nif (IS_ERR(match))\r\nreturn;\r\n}\r\nmatch->compare[match->num].fn = compare;\r\nmatch->compare[match->num].data = compare_data;\r\nmatch->num++;\r\n}\r\nint component_master_add_with_match(struct device *dev,\r\nconst struct component_master_ops *ops,\r\nstruct component_match *match)\r\n{\r\nstruct master *master;\r\nint ret;\r\nif (ops->add_components && match)\r\nreturn -EINVAL;\r\nif (match) {\r\nmatch = component_match_realloc(dev, match, match->num);\r\nif (IS_ERR(match))\r\nreturn PTR_ERR(match);\r\n}\r\nmaster = kzalloc(sizeof(*master), GFP_KERNEL);\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->dev = dev;\r\nmaster->ops = ops;\r\nmaster->match = match;\r\nINIT_LIST_HEAD(&master->components);\r\nmutex_lock(&component_mutex);\r\nlist_add(&master->node, &masters);\r\nret = try_to_bring_up_master(master, NULL);\r\nif (ret < 0) {\r\nlist_del(&master->node);\r\nkfree(master);\r\n}\r\nmutex_unlock(&component_mutex);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nint component_master_add(struct device *dev,\r\nconst struct component_master_ops *ops)\r\n{\r\nreturn component_master_add_with_match(dev, ops, NULL);\r\n}\r\nvoid component_master_del(struct device *dev,\r\nconst struct component_master_ops *ops)\r\n{\r\nstruct master *master;\r\nmutex_lock(&component_mutex);\r\nmaster = __master_find(dev, ops);\r\nif (master) {\r\ntake_down_master(master);\r\nlist_del(&master->node);\r\nkfree(master);\r\n}\r\nmutex_unlock(&component_mutex);\r\n}\r\nstatic void component_unbind(struct component *component,\r\nstruct master *master, void *data)\r\n{\r\nWARN_ON(!component->bound);\r\ncomponent->ops->unbind(component->dev, master->dev, data);\r\ncomponent->bound = false;\r\ndevres_release_group(component->dev, component);\r\n}\r\nvoid component_unbind_all(struct device *master_dev, void *data)\r\n{\r\nstruct master *master;\r\nstruct component *c;\r\nWARN_ON(!mutex_is_locked(&component_mutex));\r\nmaster = __master_find(master_dev, NULL);\r\nif (!master)\r\nreturn;\r\nlist_for_each_entry_reverse(c, &master->components, master_node)\r\ncomponent_unbind(c, master, data);\r\n}\r\nstatic int component_bind(struct component *component, struct master *master,\r\nvoid *data)\r\n{\r\nint ret;\r\nif (!devres_open_group(master->dev, NULL, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nif (!devres_open_group(component->dev, component, GFP_KERNEL)) {\r\ndevres_release_group(master->dev, NULL);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(master->dev, "binding %s (ops %ps)\n",\r\ndev_name(component->dev), component->ops);\r\nret = component->ops->bind(component->dev, master->dev, data);\r\nif (!ret) {\r\ncomponent->bound = true;\r\ndevres_close_group(component->dev, NULL);\r\ndevres_remove_group(master->dev, NULL);\r\ndev_info(master->dev, "bound %s (ops %ps)\n",\r\ndev_name(component->dev), component->ops);\r\n} else {\r\ndevres_release_group(component->dev, NULL);\r\ndevres_release_group(master->dev, NULL);\r\ndev_err(master->dev, "failed to bind %s (ops %ps): %d\n",\r\ndev_name(component->dev), component->ops, ret);\r\n}\r\nreturn ret;\r\n}\r\nint component_bind_all(struct device *master_dev, void *data)\r\n{\r\nstruct master *master;\r\nstruct component *c;\r\nint ret = 0;\r\nWARN_ON(!mutex_is_locked(&component_mutex));\r\nmaster = __master_find(master_dev, NULL);\r\nif (!master)\r\nreturn -EINVAL;\r\nlist_for_each_entry(c, &master->components, master_node) {\r\nret = component_bind(c, master, data);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret != 0) {\r\nlist_for_each_entry_continue_reverse(c, &master->components,\r\nmaster_node)\r\ncomponent_unbind(c, master, data);\r\n}\r\nreturn ret;\r\n}\r\nint component_add(struct device *dev, const struct component_ops *ops)\r\n{\r\nstruct component *component;\r\nint ret;\r\ncomponent = kzalloc(sizeof(*component), GFP_KERNEL);\r\nif (!component)\r\nreturn -ENOMEM;\r\ncomponent->ops = ops;\r\ncomponent->dev = dev;\r\ndev_dbg(dev, "adding component (ops %ps)\n", ops);\r\nmutex_lock(&component_mutex);\r\nlist_add_tail(&component->node, &component_list);\r\nret = try_to_bring_up_masters(component);\r\nif (ret < 0) {\r\nlist_del(&component->node);\r\nkfree(component);\r\n}\r\nmutex_unlock(&component_mutex);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nvoid component_del(struct device *dev, const struct component_ops *ops)\r\n{\r\nstruct component *c, *component = NULL;\r\nmutex_lock(&component_mutex);\r\nlist_for_each_entry(c, &component_list, node)\r\nif (c->dev == dev && c->ops == ops) {\r\nlist_del(&c->node);\r\ncomponent = c;\r\nbreak;\r\n}\r\nif (component && component->master)\r\ntake_down_master(component->master);\r\nmutex_unlock(&component_mutex);\r\nWARN_ON(!component);\r\nkfree(component);\r\n}
