static bool\r\nconnlabel_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_connlabel_mtinfo *info = par->matchinfo;\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct;\r\nbool invert = info->options & XT_CONNLABEL_OP_INVERT;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL || nf_ct_is_untracked(ct))\r\nreturn invert;\r\nif (info->options & XT_CONNLABEL_OP_SET)\r\nreturn (nf_connlabel_set(ct, info->bit) == 0) ^ invert;\r\nreturn nf_connlabel_match(ct, info->bit) ^ invert;\r\n}\r\nstatic int connlabel_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst int options = XT_CONNLABEL_OP_INVERT |\r\nXT_CONNLABEL_OP_SET;\r\nstruct xt_connlabel_mtinfo *info = par->matchinfo;\r\nint ret;\r\nsize_t words;\r\nif (info->bit > XT_CONNLABEL_MAXBIT)\r\nreturn -ERANGE;\r\nif (info->options & ~options) {\r\npr_err("Unknown options in mask %x\n", info->options);\r\nreturn -EINVAL;\r\n}\r\nret = nf_ct_l3proto_try_module_get(par->family);\r\nif (ret < 0) {\r\npr_info("cannot load conntrack support for proto=%u\n",\r\npar->family);\r\nreturn ret;\r\n}\r\npar->net->ct.labels_used++;\r\nwords = BITS_TO_LONGS(info->bit+1);\r\nif (words > par->net->ct.label_words)\r\npar->net->ct.label_words = words;\r\nreturn ret;\r\n}\r\nstatic void connlabel_mt_destroy(const struct xt_mtdtor_param *par)\r\n{\r\npar->net->ct.labels_used--;\r\nif (par->net->ct.labels_used == 0)\r\npar->net->ct.label_words = 0;\r\nnf_ct_l3proto_module_put(par->family);\r\n}\r\nstatic int __init connlabel_mt_init(void)\r\n{\r\nreturn xt_register_match(&connlabels_mt_reg);\r\n}\r\nstatic void __exit connlabel_mt_exit(void)\r\n{\r\nxt_unregister_match(&connlabels_mt_reg);\r\n}
