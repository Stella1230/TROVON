static int ad8366_write(struct iio_dev *indio_dev,\r\nunsigned char ch_a, char unsigned ch_b)\r\n{\r\nstruct ad8366_state *st = iio_priv(indio_dev);\r\nint ret;\r\nch_a = bitrev8(ch_a & 0x3F);\r\nch_b = bitrev8(ch_b & 0x3F);\r\nst->data[0] = ch_b >> 4;\r\nst->data[1] = (ch_b << 4) | (ch_a >> 2);\r\nret = spi_write(st->spi, st->data, ARRAY_SIZE(st->data));\r\nif (ret < 0)\r\ndev_err(&indio_dev->dev, "write failed (%d)", ret);\r\nreturn ret;\r\n}\r\nstatic int ad8366_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct ad8366_state *st = iio_priv(indio_dev);\r\nint ret;\r\nunsigned code;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_HARDWAREGAIN:\r\ncode = st->ch[chan->channel];\r\ncode = code * 253 + 4500;\r\n*val = code / 1000;\r\n*val2 = (code % 1000) * 1000;\r\nret = IIO_VAL_INT_PLUS_MICRO_DB;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad8366_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct ad8366_state *st = iio_priv(indio_dev);\r\nunsigned code;\r\nint ret;\r\nif (val < 0 || val2 < 0)\r\nreturn -EINVAL;\r\ncode = (((u8)val * 1000) + ((u32)val2 / 1000));\r\nif (code > 20500 || code < 4500)\r\nreturn -EINVAL;\r\ncode = (code - 4500) / 253;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_HARDWAREGAIN:\r\nst->ch[chan->channel] = code;\r\nret = ad8366_write(indio_dev, st->ch[0], st->ch[1]);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad8366_probe(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct ad8366_state *st;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nst->reg = devm_regulator_get(&spi->dev, "vcc");\r\nif (!IS_ERR(st->reg)) {\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\nspi_set_drvdata(spi, indio_dev);\r\nst->spi = spi;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->info = &ad8366_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = ad8366_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ad8366_channels);\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_disable_reg;\r\nad8366_write(indio_dev, 0 , 0);\r\nreturn 0;\r\nerror_disable_reg:\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nreturn ret;\r\n}\r\nstatic int ad8366_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ad8366_state *st = iio_priv(indio_dev);\r\nstruct regulator *reg = st->reg;\r\niio_device_unregister(indio_dev);\r\nif (!IS_ERR(reg))\r\nregulator_disable(reg);\r\nreturn 0;\r\n}
