static int ns2_led_get_mode(struct ns2_led_data *led_dat,\r\nenum ns2_led_modes *mode)\r\n{\r\nint i;\r\nint ret = -EINVAL;\r\nint cmd_level;\r\nint slow_level;\r\nread_lock_irq(&led_dat->rw_lock);\r\ncmd_level = gpio_get_value(led_dat->cmd);\r\nslow_level = gpio_get_value(led_dat->slow);\r\nfor (i = 0; i < ARRAY_SIZE(ns2_led_modval); i++) {\r\nif (cmd_level == ns2_led_modval[i].cmd_level &&\r\nslow_level == ns2_led_modval[i].slow_level) {\r\n*mode = ns2_led_modval[i].mode;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nread_unlock_irq(&led_dat->rw_lock);\r\nreturn ret;\r\n}\r\nstatic void ns2_led_set_mode(struct ns2_led_data *led_dat,\r\nenum ns2_led_modes mode)\r\n{\r\nint i;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&led_dat->rw_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(ns2_led_modval); i++) {\r\nif (mode == ns2_led_modval[i].mode) {\r\ngpio_set_value(led_dat->cmd,\r\nns2_led_modval[i].cmd_level);\r\ngpio_set_value(led_dat->slow,\r\nns2_led_modval[i].slow_level);\r\n}\r\n}\r\nwrite_unlock_irqrestore(&led_dat->rw_lock, flags);\r\n}\r\nstatic void ns2_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nenum ns2_led_modes mode;\r\nif (value == LED_OFF)\r\nmode = NS_V2_LED_OFF;\r\nelse if (led_dat->sata)\r\nmode = NS_V2_LED_SATA;\r\nelse\r\nmode = NS_V2_LED_ON;\r\nns2_led_set_mode(led_dat, mode);\r\n}\r\nstatic ssize_t ns2_led_sata_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buff, size_t count)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nint ret;\r\nunsigned long enable;\r\nenum ns2_led_modes mode;\r\nret = kstrtoul(buff, 10, &enable);\r\nif (ret < 0)\r\nreturn ret;\r\nenable = !!enable;\r\nif (led_dat->sata == enable)\r\nreturn count;\r\nret = ns2_led_get_mode(led_dat, &mode);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enable && mode == NS_V2_LED_ON)\r\nns2_led_set_mode(led_dat, NS_V2_LED_SATA);\r\nif (!enable && mode == NS_V2_LED_SATA)\r\nns2_led_set_mode(led_dat, NS_V2_LED_ON);\r\nled_dat->sata = enable;\r\nreturn count;\r\n}\r\nstatic ssize_t ns2_led_sata_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nreturn sprintf(buf, "%d\n", led_dat->sata);\r\n}\r\nstatic int\r\ncreate_ns2_led(struct platform_device *pdev, struct ns2_led_data *led_dat,\r\nconst struct ns2_led *template)\r\n{\r\nint ret;\r\nenum ns2_led_modes mode;\r\nret = devm_gpio_request_one(&pdev->dev, template->cmd,\r\ngpio_get_value(template->cmd) ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,\r\ntemplate->name);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: failed to setup command GPIO\n",\r\ntemplate->name);\r\nreturn ret;\r\n}\r\nret = devm_gpio_request_one(&pdev->dev, template->slow,\r\ngpio_get_value(template->slow) ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,\r\ntemplate->name);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: failed to setup slow GPIO\n",\r\ntemplate->name);\r\nreturn ret;\r\n}\r\nrwlock_init(&led_dat->rw_lock);\r\nled_dat->cdev.name = template->name;\r\nled_dat->cdev.default_trigger = template->default_trigger;\r\nled_dat->cdev.blink_set = NULL;\r\nled_dat->cdev.brightness_set = ns2_led_set;\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled_dat->cdev.groups = ns2_led_groups;\r\nled_dat->cmd = template->cmd;\r\nled_dat->slow = template->slow;\r\nret = ns2_led_get_mode(led_dat, &mode);\r\nif (ret < 0)\r\nreturn ret;\r\nled_dat->sata = (mode == NS_V2_LED_SATA) ? 1 : 0;\r\nled_dat->cdev.brightness =\r\n(mode == NS_V2_LED_OFF) ? LED_OFF : LED_FULL;\r\nret = led_classdev_register(&pdev->dev, &led_dat->cdev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void delete_ns2_led(struct ns2_led_data *led_dat)\r\n{\r\nled_classdev_unregister(&led_dat->cdev);\r\n}\r\nstatic int\r\nns2_leds_get_of_pdata(struct device *dev, struct ns2_led_platform_data *pdata)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *child;\r\nstruct ns2_led *leds;\r\nint num_leds = 0;\r\nint i = 0;\r\nnum_leds = of_get_child_count(np);\r\nif (!num_leds)\r\nreturn -ENODEV;\r\nleds = devm_kzalloc(dev, num_leds * sizeof(struct ns2_led),\r\nGFP_KERNEL);\r\nif (!leds)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(np, child) {\r\nconst char *string;\r\nint ret;\r\nret = of_get_named_gpio(child, "cmd-gpio", 0);\r\nif (ret < 0)\r\nreturn ret;\r\nleds[i].cmd = ret;\r\nret = of_get_named_gpio(child, "slow-gpio", 0);\r\nif (ret < 0)\r\nreturn ret;\r\nleds[i].slow = ret;\r\nret = of_property_read_string(child, "label", &string);\r\nleds[i].name = (ret == 0) ? string : child->name;\r\nret = of_property_read_string(child, "linux,default-trigger",\r\n&string);\r\nif (ret == 0)\r\nleds[i].default_trigger = string;\r\ni++;\r\n}\r\npdata->leds = leds;\r\npdata->num_leds = num_leds;\r\nreturn 0;\r\n}\r\nstatic inline int sizeof_ns2_led_priv(int num_leds)\r\n{\r\nreturn sizeof(struct ns2_led_priv) +\r\n(sizeof(struct ns2_led_data) * num_leds);\r\n}\r\nstatic int ns2_led_probe(struct platform_device *pdev)\r\n{\r\nstruct ns2_led_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct ns2_led_priv *priv;\r\nint i;\r\nint ret;\r\n#ifdef CONFIG_OF_GPIO\r\nif (!pdata) {\r\npdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct ns2_led_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nret = ns2_leds_get_of_pdata(&pdev->dev, pdata);\r\nif (ret)\r\nreturn ret;\r\n}\r\n#else\r\nif (!pdata)\r\nreturn -EINVAL;\r\n#endif\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof_ns2_led_priv(pdata->num_leds), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->num_leds = pdata->num_leds;\r\nfor (i = 0; i < priv->num_leds; i++) {\r\nret = create_ns2_led(pdev, &priv->leds_data[i],\r\n&pdata->leds[i]);\r\nif (ret < 0) {\r\nfor (i = i - 1; i >= 0; i--)\r\ndelete_ns2_led(&priv->leds_data[i]);\r\nreturn ret;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int ns2_led_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct ns2_led_priv *priv;\r\npriv = platform_get_drvdata(pdev);\r\nfor (i = 0; i < priv->num_leds; i++)\r\ndelete_ns2_led(&priv->leds_data[i]);\r\nreturn 0;\r\n}
