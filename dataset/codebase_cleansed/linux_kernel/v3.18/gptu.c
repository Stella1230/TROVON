static irqreturn_t timer_irq_handler(int irq, void *priv)\r\n{\r\nint timer = irq - irqres[0].start;\r\ngptu_w32(1 << timer, GPTU_IRNCR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gptu_hwinit(void)\r\n{\r\ngptu_w32(0x00, GPTU_IRNEN);\r\ngptu_w32(0xff, GPTU_IRNCR);\r\ngptu_w32(CLC_RMC | CLC_SUSPEND, GPTU_CLC);\r\n}\r\nstatic void gptu_hwexit(void)\r\n{\r\ngptu_w32(0x00, GPTU_IRNEN);\r\ngptu_w32(0xff, GPTU_IRNCR);\r\ngptu_w32(CLC_DISABLE, GPTU_CLC);\r\n}\r\nstatic int gptu_enable(struct clk *clk)\r\n{\r\nint ret = request_irq(irqres[clk->bits].start, timer_irq_handler,\r\nIRQF_TIMER, "gtpu", NULL);\r\nif (ret) {\r\npr_err("gptu: failed to request irq\n");\r\nreturn ret;\r\n}\r\ngptu_w32(CON_CNT | CON_EDGE_ANY | CON_SYNC | CON_CLK_INT,\r\nGPTU_CON(clk->bits));\r\ngptu_w32(1, GPTU_RLD(clk->bits));\r\ngptu_w32(gptu_r32(GPTU_IRNEN) | BIT(clk->bits), GPTU_IRNEN);\r\ngptu_w32(RUN_SEN | RUN_RL, GPTU_RUN(clk->bits));\r\nreturn 0;\r\n}\r\nstatic void gptu_disable(struct clk *clk)\r\n{\r\ngptu_w32(0, GPTU_RUN(clk->bits));\r\ngptu_w32(0, GPTU_CON(clk->bits));\r\ngptu_w32(0, GPTU_RLD(clk->bits));\r\ngptu_w32(gptu_r32(GPTU_IRNEN) & ~BIT(clk->bits), GPTU_IRNEN);\r\nfree_irq(irqres[clk->bits].start, NULL);\r\n}\r\nstatic inline void clkdev_add_gptu(struct device *dev, const char *con,\r\nunsigned int timer)\r\n{\r\nstruct clk *clk = kzalloc(sizeof(struct clk), GFP_KERNEL);\r\nclk->cl.dev_id = dev_name(dev);\r\nclk->cl.con_id = con;\r\nclk->cl.clk = clk;\r\nclk->enable = gptu_enable;\r\nclk->disable = gptu_disable;\r\nclk->bits = timer;\r\nclkdev_add(&clk->cl);\r\n}\r\nstatic int gptu_probe(struct platform_device *pdev)\r\n{\r\nstruct clk *clk;\r\nstruct resource *res;\r\nif (of_irq_to_resource_table(pdev->dev.of_node, irqres, 6) != 6) {\r\ndev_err(&pdev->dev, "Failed to get IRQ list\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngptu_membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(gptu_membase))\r\nreturn PTR_ERR(gptu_membase);\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\nreturn -ENOENT;\r\n}\r\nclk_enable(clk);\r\ngptu_hwinit();\r\nif (((gptu_r32(GPTU_ID) >> 8) & 0xff) != GPTU_MAGIC) {\r\ndev_err(&pdev->dev, "Failed to find magic\n");\r\ngptu_hwexit();\r\nclk_disable(clk);\r\nclk_put(clk);\r\nreturn -ENAVAIL;\r\n}\r\nclkdev_add_gptu(&pdev->dev, "timer1a", TIMER1A);\r\nclkdev_add_gptu(&pdev->dev, "timer1b", TIMER1B);\r\nclkdev_add_gptu(&pdev->dev, "timer2a", TIMER2A);\r\nclkdev_add_gptu(&pdev->dev, "timer2b", TIMER2B);\r\nclkdev_add_gptu(&pdev->dev, "timer3a", TIMER3A);\r\nclkdev_add_gptu(&pdev->dev, "timer3b", TIMER3B);\r\ndev_info(&pdev->dev, "gptu: 6 timers loaded\n");\r\nreturn 0;\r\n}\r\nint __init gptu_init(void)\r\n{\r\nint ret = platform_driver_register(&dma_driver);\r\nif (ret)\r\npr_info("gptu: Error registering platform driver\n");\r\nreturn ret;\r\n}
