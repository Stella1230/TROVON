static int omap_cf_ss_init(struct pcmcia_socket *s)\r\n{\r\nreturn 0;\r\n}\r\nstatic void omap_cf_timer(unsigned long _cf)\r\n{\r\nstruct omap_cf_socket *cf = (void *) _cf;\r\nunsigned present = omap_cf_present();\r\nif (present != cf->present) {\r\ncf->present = present;\r\npr_debug("%s: card %s\n", driver_name,\r\npresent ? "present" : "gone");\r\npcmcia_parse_events(&cf->socket, SS_DETECT);\r\n}\r\nif (cf->active)\r\nmod_timer(&cf->timer, jiffies + POLL_INTERVAL);\r\n}\r\nstatic irqreturn_t omap_cf_irq(int irq, void *_cf)\r\n{\r\nomap_cf_timer((unsigned long)_cf);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap_cf_get_status(struct pcmcia_socket *s, u_int *sp)\r\n{\r\nif (!sp)\r\nreturn -EINVAL;\r\nif (omap_cf_present()) {\r\nstruct omap_cf_socket *cf;\r\n*sp = SS_READY | SS_DETECT | SS_POWERON | SS_3VCARD;\r\ncf = container_of(s, struct omap_cf_socket, socket);\r\ns->pcmcia_irq = 0;\r\ns->pci_irq = cf->irq;\r\n} else\r\n*sp = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nomap_cf_set_socket(struct pcmcia_socket *sock, struct socket_state_t *s)\r\n{\r\nu16 control;\r\nswitch (s->Vcc) {\r\ncase 0:\r\ncase 33:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncontrol = omap_readw(CF_CONTROL);\r\nif (s->flags & SS_RESET)\r\nomap_writew(CF_CONTROL_RESET, CF_CONTROL);\r\nelse\r\nomap_writew(0, CF_CONTROL);\r\npr_debug("%s: Vcc %d, io_irq %d, flags %04x csc %04x\n",\r\ndriver_name, s->Vcc, s->io_irq, s->flags, s->csc_mask);\r\nreturn 0;\r\n}\r\nstatic int omap_cf_ss_suspend(struct pcmcia_socket *s)\r\n{\r\npr_debug("%s: %s\n", driver_name, __func__);\r\nreturn omap_cf_set_socket(s, &dead_socket);\r\n}\r\nstatic int\r\nomap_cf_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)\r\n{\r\nstruct omap_cf_socket *cf;\r\ncf = container_of(s, struct omap_cf_socket, socket);\r\nio->flags &= MAP_ACTIVE|MAP_ATTRIB|MAP_16BIT;\r\nio->start = cf->phys_cf + SZ_4K;\r\nio->stop = io->start + SZ_2K - 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nomap_cf_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *map)\r\n{\r\nstruct omap_cf_socket *cf;\r\nif (map->card_start)\r\nreturn -EINVAL;\r\ncf = container_of(s, struct omap_cf_socket, socket);\r\nmap->static_start = cf->phys_cf;\r\nmap->flags &= MAP_ACTIVE|MAP_ATTRIB|MAP_16BIT;\r\nif (map->flags & MAP_ATTRIB)\r\nmap->static_start += SZ_2K;\r\nreturn 0;\r\n}\r\nstatic int __init omap_cf_probe(struct platform_device *pdev)\r\n{\r\nunsigned seg;\r\nstruct omap_cf_socket *cf;\r\nint irq;\r\nint status;\r\nseg = (int) pdev->dev.platform_data;\r\nif (seg == 0 || seg > 3)\r\nreturn -ENODEV;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -EINVAL;\r\ncf = kzalloc(sizeof *cf, GFP_KERNEL);\r\nif (!cf)\r\nreturn -ENOMEM;\r\ninit_timer(&cf->timer);\r\ncf->timer.function = omap_cf_timer;\r\ncf->timer.data = (unsigned long) cf;\r\ncf->pdev = pdev;\r\nplatform_set_drvdata(pdev, cf);\r\nstatus = request_irq(irq, omap_cf_irq, IRQF_SHARED,\r\ndriver_name, cf);\r\nif (status < 0)\r\ngoto fail0;\r\ncf->irq = irq;\r\ncf->socket.pci_irq = irq;\r\nswitch (seg) {\r\ncase 1:\r\ncf->phys_cf = OMAP_CS1_PHYS;\r\nbreak;\r\ncase 2:\r\ncf->phys_cf = OMAP_CS2_PHYS;\r\nbreak;\r\ncase 3:\r\ncf->phys_cf = omap_cs3_phys();\r\nbreak;\r\ndefault:\r\ngoto fail1;\r\n}\r\ncf->iomem.start = cf->phys_cf;\r\ncf->iomem.end = cf->iomem.end + SZ_8K - 1;\r\ncf->iomem.flags = IORESOURCE_MEM;\r\ncf->socket.io_offset = (unsigned long)\r\nioremap(cf->phys_cf + SZ_4K, SZ_2K);\r\nif (!cf->socket.io_offset)\r\ngoto fail1;\r\nif (!request_mem_region(cf->phys_cf, SZ_8K, driver_name))\r\ngoto fail1;\r\nomap_cfg_reg(W11_1610_CF_CD1);\r\nomap_cfg_reg(P11_1610_CF_CD2);\r\nomap_cfg_reg(R11_1610_CF_IOIS16);\r\nomap_cfg_reg(V10_1610_CF_IREQ);\r\nomap_cfg_reg(W10_1610_CF_RESET);\r\nomap_writew(~(1 << seg), CF_CFG);\r\npr_info("%s: cs%d on irq %d\n", driver_name, seg, irq);\r\npr_debug("%s: cs%d, previous ccs %08x acs %08x\n", driver_name,\r\nseg, omap_readl(EMIFS_CCS(seg)), omap_readl(EMIFS_ACS(seg)));\r\nomap_writel(0x0004a1b3, EMIFS_CCS(seg));\r\nomap_writel(0x00000000, EMIFS_ACS(seg));\r\npr_debug("%s: sts %04x cfg %04x control %04x %s\n", driver_name,\r\nomap_readw(CF_STATUS), omap_readw(CF_CFG),\r\nomap_readw(CF_CONTROL),\r\nomap_cf_present() ? "present" : "(not present)");\r\ncf->socket.owner = THIS_MODULE;\r\ncf->socket.dev.parent = &pdev->dev;\r\ncf->socket.ops = &omap_cf_ops;\r\ncf->socket.resource_ops = &pccard_static_ops;\r\ncf->socket.features = SS_CAP_PCCARD | SS_CAP_STATIC_MAP\r\n| SS_CAP_MEM_ALIGN;\r\ncf->socket.map_size = SZ_2K;\r\ncf->socket.io[0].res = &cf->iomem;\r\nstatus = pcmcia_register_socket(&cf->socket);\r\nif (status < 0)\r\ngoto fail2;\r\ncf->active = 1;\r\nmod_timer(&cf->timer, jiffies + POLL_INTERVAL);\r\nreturn 0;\r\nfail2:\r\nrelease_mem_region(cf->phys_cf, SZ_8K);\r\nfail1:\r\nif (cf->socket.io_offset)\r\niounmap((void __iomem *) cf->socket.io_offset);\r\nfree_irq(irq, cf);\r\nfail0:\r\nkfree(cf);\r\nreturn status;\r\n}\r\nstatic int __exit omap_cf_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_cf_socket *cf = platform_get_drvdata(pdev);\r\ncf->active = 0;\r\npcmcia_unregister_socket(&cf->socket);\r\ndel_timer_sync(&cf->timer);\r\niounmap((void __iomem *) cf->socket.io_offset);\r\nrelease_mem_region(cf->phys_cf, SZ_8K);\r\nfree_irq(cf->irq, cf);\r\nkfree(cf);\r\nreturn 0;\r\n}\r\nstatic int __init omap_cf_init(void)\r\n{\r\nif (cpu_is_omap16xx())\r\nreturn platform_driver_probe(&omap_cf_driver, omap_cf_probe);\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit omap_cf_exit(void)\r\n{\r\nif (cpu_is_omap16xx())\r\nplatform_driver_unregister(&omap_cf_driver);\r\n}
