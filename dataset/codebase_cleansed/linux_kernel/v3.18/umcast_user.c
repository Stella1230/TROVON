static struct sockaddr_in *new_addr(char *addr, unsigned short port)\r\n{\r\nstruct sockaddr_in *sin;\r\nsin = uml_kmalloc(sizeof(struct sockaddr_in), UM_GFP_KERNEL);\r\nif (sin == NULL) {\r\nprintk(UM_KERN_ERR "new_addr: allocation of sockaddr_in "\r\n"failed\n");\r\nreturn NULL;\r\n}\r\nsin->sin_family = AF_INET;\r\nif (addr)\r\nsin->sin_addr.s_addr = in_aton(addr);\r\nelse\r\nsin->sin_addr.s_addr = INADDR_ANY;\r\nsin->sin_port = htons(port);\r\nreturn sin;\r\n}\r\nstatic int umcast_user_init(void *data, void *dev)\r\n{\r\nstruct umcast_data *pri = data;\r\npri->remote_addr = new_addr(pri->addr, pri->rport);\r\nif (pri->unicast)\r\npri->listen_addr = new_addr(NULL, pri->lport);\r\nelse\r\npri->listen_addr = pri->remote_addr;\r\npri->dev = dev;\r\nreturn 0;\r\n}\r\nstatic void umcast_remove(void *data)\r\n{\r\nstruct umcast_data *pri = data;\r\nkfree(pri->listen_addr);\r\nif (pri->unicast)\r\nkfree(pri->remote_addr);\r\npri->listen_addr = pri->remote_addr = NULL;\r\n}\r\nstatic int umcast_open(void *data)\r\n{\r\nstruct umcast_data *pri = data;\r\nstruct sockaddr_in *lsin = pri->listen_addr;\r\nstruct sockaddr_in *rsin = pri->remote_addr;\r\nstruct ip_mreq mreq;\r\nint fd, yes = 1, err = -EINVAL;\r\nif ((!pri->unicast && lsin->sin_addr.s_addr == 0) ||\r\n(rsin->sin_addr.s_addr == 0) ||\r\n(lsin->sin_port == 0) || (rsin->sin_port == 0))\r\ngoto out;\r\nfd = socket(AF_INET, SOCK_DGRAM, 0);\r\nif (fd < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "umcast_open : data socket failed, "\r\n"errno = %d\n", errno);\r\ngoto out;\r\n}\r\nif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "umcast_open: SO_REUSEADDR failed, "\r\n"errno = %d\n", errno);\r\ngoto out_close;\r\n}\r\nif (!pri->unicast) {\r\nif (setsockopt(fd, SOL_IP, IP_MULTICAST_TTL, &pri->ttl,\r\nsizeof(pri->ttl)) < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "umcast_open: IP_MULTICAST_TTL "\r\n"failed, error = %d\n", errno);\r\ngoto out_close;\r\n}\r\nif (setsockopt(fd, SOL_IP, IP_MULTICAST_LOOP,\r\n&yes, sizeof(yes)) < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "umcast_open: IP_MULTICAST_LOOP "\r\n"failed, error = %d\n", errno);\r\ngoto out_close;\r\n}\r\n}\r\nif (bind(fd, (struct sockaddr *) lsin, sizeof(*lsin)) < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "umcast_open : data bind failed, "\r\n"errno = %d\n", errno);\r\ngoto out_close;\r\n}\r\nif (!pri->unicast) {\r\nmreq.imr_multiaddr.s_addr = lsin->sin_addr.s_addr;\r\nmreq.imr_interface.s_addr = 0;\r\nif (setsockopt(fd, SOL_IP, IP_ADD_MEMBERSHIP,\r\n&mreq, sizeof(mreq)) < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "umcast_open: IP_ADD_MEMBERSHIP "\r\n"failed, error = %d\n", errno);\r\nprintk(UM_KERN_ERR "There appears not to be a "\r\n"multicast-capable network interface on the "\r\n"host.\n");\r\nprintk(UM_KERN_ERR "eth0 should be configured in order "\r\n"to use the multicast transport.\n");\r\ngoto out_close;\r\n}\r\n}\r\nreturn fd;\r\nout_close:\r\nclose(fd);\r\nout:\r\nreturn err;\r\n}\r\nstatic void umcast_close(int fd, void *data)\r\n{\r\nstruct umcast_data *pri = data;\r\nif (!pri->unicast) {\r\nstruct ip_mreq mreq;\r\nstruct sockaddr_in *lsin = pri->listen_addr;\r\nmreq.imr_multiaddr.s_addr = lsin->sin_addr.s_addr;\r\nmreq.imr_interface.s_addr = 0;\r\nif (setsockopt(fd, SOL_IP, IP_DROP_MEMBERSHIP,\r\n&mreq, sizeof(mreq)) < 0) {\r\nprintk(UM_KERN_ERR "umcast_close: IP_DROP_MEMBERSHIP "\r\n"failed, error = %d\n", errno);\r\n}\r\n}\r\nclose(fd);\r\n}\r\nint umcast_user_write(int fd, void *buf, int len, struct umcast_data *pri)\r\n{\r\nstruct sockaddr_in *data_addr = pri->remote_addr;\r\nreturn net_sendto(fd, buf, len, data_addr, sizeof(*data_addr));\r\n}
