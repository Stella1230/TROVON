static int tps65090_reg_set_overcurrent_wait(struct tps65090_regulator *ri,\r\nstruct regulator_dev *rdev)\r\n{\r\nint ret;\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nMAX_OVERCURRENT_WAIT << CTRL_WT_BIT,\r\nri->overcurrent_wait << CTRL_WT_BIT);\r\nif (ret) {\r\ndev_err(&rdev->dev, "Error updating overcurrent wait %#x\n",\r\nrdev->desc->enable_reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tps65090_try_enable_fet(struct regulator_dev *rdev)\r\n{\r\nunsigned int control;\r\nint ret, i;\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask,\r\nrdev->desc->enable_mask);\r\nif (ret < 0) {\r\ndev_err(&rdev->dev, "Error in updating reg %#x\n",\r\nrdev->desc->enable_reg);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < MAX_CTRL_READ_TRIES; i++) {\r\nret = regmap_read(rdev->regmap, rdev->desc->enable_reg,\r\n&control);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(control & BIT(CTRL_TO_BIT)))\r\nbreak;\r\nusleep_range(1000, 1500);\r\n}\r\nif (!(control & BIT(CTRL_PG_BIT)))\r\nreturn -ENOTRECOVERABLE;\r\nreturn 0;\r\n}\r\nstatic int tps65090_fet_enable(struct regulator_dev *rdev)\r\n{\r\nint ret, tries;\r\ntries = 0;\r\nwhile (true) {\r\nret = tps65090_try_enable_fet(rdev);\r\nif (!ret)\r\nbreak;\r\nif (ret != -ENOTRECOVERABLE || tries == MAX_FET_ENABLE_TRIES)\r\ngoto err;\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, 0);\r\nif (ret)\r\ngoto err;\r\ntries++;\r\n}\r\nif (tries)\r\ndev_warn(&rdev->dev, "reg %#x enable ok after %d tries\n",\r\nrdev->desc->enable_reg, tries);\r\nreturn 0;\r\nerr:\r\ndev_warn(&rdev->dev, "reg %#x enable failed\n", rdev->desc->enable_reg);\r\nWARN_ON(1);\r\nreturn ret;\r\n}\r\nstatic inline bool is_dcdc(int id)\r\n{\r\nswitch (id) {\r\ncase TPS65090_REGULATOR_DCDC1:\r\ncase TPS65090_REGULATOR_DCDC2:\r\ncase TPS65090_REGULATOR_DCDC3:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int tps65090_config_ext_control(\r\nstruct tps65090_regulator *ri, bool enable)\r\n{\r\nint ret;\r\nstruct device *parent = ri->dev->parent;\r\nunsigned int reg_en_reg = ri->desc->enable_reg;\r\nif (enable)\r\nret = tps65090_set_bits(parent, reg_en_reg, 1);\r\nelse\r\nret = tps65090_clr_bits(parent, reg_en_reg, 1);\r\nif (ret < 0)\r\ndev_err(ri->dev, "Error in updating reg 0x%x\n", reg_en_reg);\r\nreturn ret;\r\n}\r\nstatic int tps65090_regulator_disable_ext_control(\r\nstruct tps65090_regulator *ri,\r\nstruct tps65090_regulator_plat_data *tps_pdata)\r\n{\r\nint ret = 0;\r\nstruct device *parent = ri->dev->parent;\r\nunsigned int reg_en_reg = ri->desc->enable_reg;\r\nif (tps_pdata->reg_init_data->constraints.always_on ||\r\ntps_pdata->reg_init_data->constraints.boot_on) {\r\nret = tps65090_set_bits(parent, reg_en_reg, 0);\r\nif (ret < 0) {\r\ndev_err(ri->dev, "Error in set reg 0x%x\n", reg_en_reg);\r\nreturn ret;\r\n}\r\n}\r\nreturn tps65090_config_ext_control(ri, false);\r\n}\r\nstatic void tps65090_configure_regulator_config(\r\nstruct tps65090_regulator_plat_data *tps_pdata,\r\nstruct regulator_config *config)\r\n{\r\nif (gpio_is_valid(tps_pdata->gpio)) {\r\nint gpio_flag = GPIOF_OUT_INIT_LOW;\r\nif (tps_pdata->reg_init_data->constraints.always_on ||\r\ntps_pdata->reg_init_data->constraints.boot_on)\r\ngpio_flag = GPIOF_OUT_INIT_HIGH;\r\nconfig->ena_gpio = tps_pdata->gpio;\r\nconfig->ena_gpio_flags = gpio_flag;\r\n}\r\n}\r\nstatic struct tps65090_platform_data *tps65090_parse_dt_reg_data(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **tps65090_reg_matches)\r\n{\r\nstruct tps65090_platform_data *tps65090_pdata;\r\nstruct device_node *np = pdev->dev.parent->of_node;\r\nstruct device_node *regulators;\r\nint idx = 0, ret;\r\nstruct tps65090_regulator_plat_data *reg_pdata;\r\ntps65090_pdata = devm_kzalloc(&pdev->dev, sizeof(*tps65090_pdata),\r\nGFP_KERNEL);\r\nif (!tps65090_pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nreg_pdata = devm_kzalloc(&pdev->dev, TPS65090_REGULATOR_MAX *\r\nsizeof(*reg_pdata), GFP_KERNEL);\r\nif (!reg_pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nregulators = of_get_child_by_name(np, "regulators");\r\nif (!regulators) {\r\ndev_err(&pdev->dev, "regulator node not found\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nret = of_regulator_match(&pdev->dev, regulators, tps65090_matches,\r\nARRAY_SIZE(tps65090_matches));\r\nof_node_put(regulators);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Error parsing regulator init data: %d\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\n*tps65090_reg_matches = tps65090_matches;\r\nfor (idx = 0; idx < ARRAY_SIZE(tps65090_matches); idx++) {\r\nstruct regulator_init_data *ri_data;\r\nstruct tps65090_regulator_plat_data *rpdata;\r\nrpdata = &reg_pdata[idx];\r\nri_data = tps65090_matches[idx].init_data;\r\nif (!ri_data || !tps65090_matches[idx].of_node)\r\ncontinue;\r\nrpdata->reg_init_data = ri_data;\r\nrpdata->enable_ext_control = of_property_read_bool(\r\ntps65090_matches[idx].of_node,\r\n"ti,enable-ext-control");\r\nif (rpdata->enable_ext_control)\r\nrpdata->gpio = of_get_named_gpio(np,\r\n"dcdc-ext-control-gpios", 0);\r\nif (of_property_read_u32(tps65090_matches[idx].of_node,\r\n"ti,overcurrent-wait",\r\n&rpdata->overcurrent_wait) == 0)\r\nrpdata->overcurrent_wait_valid = true;\r\ntps65090_pdata->reg_pdata[idx] = rpdata;\r\n}\r\nreturn tps65090_pdata;\r\n}\r\nstatic inline struct tps65090_platform_data *tps65090_parse_dt_reg_data(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **tps65090_reg_matches)\r\n{\r\n*tps65090_reg_matches = NULL;\r\nreturn NULL;\r\n}\r\nstatic int tps65090_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct tps65090 *tps65090_mfd = dev_get_drvdata(pdev->dev.parent);\r\nstruct tps65090_regulator *ri = NULL;\r\nstruct regulator_config config = { };\r\nstruct regulator_dev *rdev;\r\nstruct tps65090_regulator_plat_data *tps_pdata;\r\nstruct tps65090_regulator *pmic;\r\nstruct tps65090_platform_data *tps65090_pdata;\r\nstruct of_regulator_match *tps65090_reg_matches = NULL;\r\nint num;\r\nint ret;\r\ndev_dbg(&pdev->dev, "Probing regulator\n");\r\ntps65090_pdata = dev_get_platdata(pdev->dev.parent);\r\nif (!tps65090_pdata && tps65090_mfd->dev->of_node)\r\ntps65090_pdata = tps65090_parse_dt_reg_data(pdev,\r\n&tps65090_reg_matches);\r\nif (IS_ERR_OR_NULL(tps65090_pdata)) {\r\ndev_err(&pdev->dev, "Platform data missing\n");\r\nreturn tps65090_pdata ? PTR_ERR(tps65090_pdata) : -EINVAL;\r\n}\r\npmic = devm_kzalloc(&pdev->dev, TPS65090_REGULATOR_MAX * sizeof(*pmic),\r\nGFP_KERNEL);\r\nif (!pmic)\r\nreturn -ENOMEM;\r\nfor (num = 0; num < TPS65090_REGULATOR_MAX; num++) {\r\ntps_pdata = tps65090_pdata->reg_pdata[num];\r\nri = &pmic[num];\r\nri->dev = &pdev->dev;\r\nri->desc = &tps65090_regulator_desc[num];\r\nif (tps_pdata) {\r\nri->overcurrent_wait_valid =\r\ntps_pdata->overcurrent_wait_valid;\r\nri->overcurrent_wait = tps_pdata->overcurrent_wait;\r\n}\r\nif (tps_pdata && is_dcdc(num) && tps_pdata->reg_init_data) {\r\nif (tps_pdata->enable_ext_control) {\r\ntps65090_configure_regulator_config(\r\ntps_pdata, &config);\r\nri->desc->ops = &tps65090_ext_control_ops;\r\n} else {\r\nret = tps65090_regulator_disable_ext_control(\r\nri, tps_pdata);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"failed disable ext control\n");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nconfig.dev = pdev->dev.parent;\r\nconfig.driver_data = ri;\r\nconfig.regmap = tps65090_mfd->rmap;\r\nif (tps_pdata)\r\nconfig.init_data = tps_pdata->reg_init_data;\r\nelse\r\nconfig.init_data = NULL;\r\nif (tps65090_reg_matches)\r\nconfig.of_node = tps65090_reg_matches[num].of_node;\r\nelse\r\nconfig.of_node = NULL;\r\nrdev = devm_regulator_register(&pdev->dev, ri->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "failed to register regulator %s\n",\r\nri->desc->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\nri->rdev = rdev;\r\nif (ri->overcurrent_wait_valid) {\r\nret = tps65090_reg_set_overcurrent_wait(ri, rdev);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (tps_pdata && is_dcdc(num) && tps_pdata->reg_init_data &&\r\ntps_pdata->enable_ext_control) {\r\nret = tps65090_config_ext_control(ri, true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, pmic);\r\nreturn 0;\r\n}\r\nstatic int __init tps65090_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&tps65090_regulator_driver);\r\n}\r\nstatic void __exit tps65090_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&tps65090_regulator_driver);\r\n}
