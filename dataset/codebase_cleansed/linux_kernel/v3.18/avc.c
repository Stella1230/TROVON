static inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\r\n{\r\nreturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\r\n}\r\nstatic void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)\r\n{\r\nconst char **perms;\r\nint i, perm;\r\nif (av == 0) {\r\naudit_log_format(ab, " null");\r\nreturn;\r\n}\r\nperms = secclass_map[tclass-1].perms;\r\naudit_log_format(ab, " {");\r\ni = 0;\r\nperm = 1;\r\nwhile (i < (sizeof(av) * 8)) {\r\nif ((perm & av) && perms[i]) {\r\naudit_log_format(ab, " %s", perms[i]);\r\nav &= ~perm;\r\n}\r\ni++;\r\nperm <<= 1;\r\n}\r\nif (av)\r\naudit_log_format(ab, " 0x%x", av);\r\naudit_log_format(ab, " }");\r\n}\r\nstatic void avc_dump_query(struct audit_buffer *ab, u32 ssid, u32 tsid, u16 tclass)\r\n{\r\nint rc;\r\nchar *scontext;\r\nu32 scontext_len;\r\nrc = security_sid_to_context(ssid, &scontext, &scontext_len);\r\nif (rc)\r\naudit_log_format(ab, "ssid=%d", ssid);\r\nelse {\r\naudit_log_format(ab, "scontext=%s", scontext);\r\nkfree(scontext);\r\n}\r\nrc = security_sid_to_context(tsid, &scontext, &scontext_len);\r\nif (rc)\r\naudit_log_format(ab, " tsid=%d", tsid);\r\nelse {\r\naudit_log_format(ab, " tcontext=%s", scontext);\r\nkfree(scontext);\r\n}\r\nBUG_ON(tclass >= ARRAY_SIZE(secclass_map));\r\naudit_log_format(ab, " tclass=%s", secclass_map[tclass-1].name);\r\n}\r\nvoid __init avc_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\r\nINIT_HLIST_HEAD(&avc_cache.slots[i]);\r\nspin_lock_init(&avc_cache.slots_lock[i]);\r\n}\r\natomic_set(&avc_cache.active_nodes, 0);\r\natomic_set(&avc_cache.lru_hint, 0);\r\navc_node_cachep = kmem_cache_create("avc_node", sizeof(struct avc_node),\r\n0, SLAB_PANIC, NULL);\r\naudit_log(current->audit_context, GFP_KERNEL, AUDIT_KERNEL, "AVC INITIALIZED\n");\r\n}\r\nint avc_get_hash_stats(char *page)\r\n{\r\nint i, chain_len, max_chain_len, slots_used;\r\nstruct avc_node *node;\r\nstruct hlist_head *head;\r\nrcu_read_lock();\r\nslots_used = 0;\r\nmax_chain_len = 0;\r\nfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\r\nhead = &avc_cache.slots[i];\r\nif (!hlist_empty(head)) {\r\nslots_used++;\r\nchain_len = 0;\r\nhlist_for_each_entry_rcu(node, head, list)\r\nchain_len++;\r\nif (chain_len > max_chain_len)\r\nmax_chain_len = chain_len;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn scnprintf(page, PAGE_SIZE, "entries: %d\nbuckets used: %d/%d\n"\r\n"longest chain: %d\n",\r\natomic_read(&avc_cache.active_nodes),\r\nslots_used, AVC_CACHE_SLOTS, max_chain_len);\r\n}\r\nstatic void avc_node_free(struct rcu_head *rhead)\r\n{\r\nstruct avc_node *node = container_of(rhead, struct avc_node, rhead);\r\nkmem_cache_free(avc_node_cachep, node);\r\navc_cache_stats_incr(frees);\r\n}\r\nstatic void avc_node_delete(struct avc_node *node)\r\n{\r\nhlist_del_rcu(&node->list);\r\ncall_rcu(&node->rhead, avc_node_free);\r\natomic_dec(&avc_cache.active_nodes);\r\n}\r\nstatic void avc_node_kill(struct avc_node *node)\r\n{\r\nkmem_cache_free(avc_node_cachep, node);\r\navc_cache_stats_incr(frees);\r\natomic_dec(&avc_cache.active_nodes);\r\n}\r\nstatic void avc_node_replace(struct avc_node *new, struct avc_node *old)\r\n{\r\nhlist_replace_rcu(&old->list, &new->list);\r\ncall_rcu(&old->rhead, avc_node_free);\r\natomic_dec(&avc_cache.active_nodes);\r\n}\r\nstatic inline int avc_reclaim_node(void)\r\n{\r\nstruct avc_node *node;\r\nint hvalue, try, ecx;\r\nunsigned long flags;\r\nstruct hlist_head *head;\r\nspinlock_t *lock;\r\nfor (try = 0, ecx = 0; try < AVC_CACHE_SLOTS; try++) {\r\nhvalue = atomic_inc_return(&avc_cache.lru_hint) & (AVC_CACHE_SLOTS - 1);\r\nhead = &avc_cache.slots[hvalue];\r\nlock = &avc_cache.slots_lock[hvalue];\r\nif (!spin_trylock_irqsave(lock, flags))\r\ncontinue;\r\nrcu_read_lock();\r\nhlist_for_each_entry(node, head, list) {\r\navc_node_delete(node);\r\navc_cache_stats_incr(reclaims);\r\necx++;\r\nif (ecx >= AVC_CACHE_RECLAIM) {\r\nrcu_read_unlock();\r\nspin_unlock_irqrestore(lock, flags);\r\ngoto out;\r\n}\r\n}\r\nrcu_read_unlock();\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nout:\r\nreturn ecx;\r\n}\r\nstatic struct avc_node *avc_alloc_node(void)\r\n{\r\nstruct avc_node *node;\r\nnode = kmem_cache_zalloc(avc_node_cachep, GFP_ATOMIC|__GFP_NOMEMALLOC);\r\nif (!node)\r\ngoto out;\r\nINIT_HLIST_NODE(&node->list);\r\navc_cache_stats_incr(allocations);\r\nif (atomic_inc_return(&avc_cache.active_nodes) > avc_cache_threshold)\r\navc_reclaim_node();\r\nout:\r\nreturn node;\r\n}\r\nstatic void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\r\n{\r\nnode->ae.ssid = ssid;\r\nnode->ae.tsid = tsid;\r\nnode->ae.tclass = tclass;\r\nmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\r\n}\r\nstatic inline struct avc_node *avc_search_node(u32 ssid, u32 tsid, u16 tclass)\r\n{\r\nstruct avc_node *node, *ret = NULL;\r\nint hvalue;\r\nstruct hlist_head *head;\r\nhvalue = avc_hash(ssid, tsid, tclass);\r\nhead = &avc_cache.slots[hvalue];\r\nhlist_for_each_entry_rcu(node, head, list) {\r\nif (ssid == node->ae.ssid &&\r\ntclass == node->ae.tclass &&\r\ntsid == node->ae.tsid) {\r\nret = node;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\r\n{\r\nstruct avc_node *node;\r\navc_cache_stats_incr(lookups);\r\nnode = avc_search_node(ssid, tsid, tclass);\r\nif (node)\r\nreturn node;\r\navc_cache_stats_incr(misses);\r\nreturn NULL;\r\n}\r\nstatic int avc_latest_notif_update(int seqno, int is_insert)\r\n{\r\nint ret = 0;\r\nstatic DEFINE_SPINLOCK(notif_lock);\r\nunsigned long flag;\r\nspin_lock_irqsave(&notif_lock, flag);\r\nif (is_insert) {\r\nif (seqno < avc_cache.latest_notif) {\r\nprintk(KERN_WARNING "SELinux: avc: seqno %d < latest_notif %d\n",\r\nseqno, avc_cache.latest_notif);\r\nret = -EAGAIN;\r\n}\r\n} else {\r\nif (seqno > avc_cache.latest_notif)\r\navc_cache.latest_notif = seqno;\r\n}\r\nspin_unlock_irqrestore(&notif_lock, flag);\r\nreturn ret;\r\n}\r\nstatic struct avc_node *avc_insert(u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\r\n{\r\nstruct avc_node *pos, *node = NULL;\r\nint hvalue;\r\nunsigned long flag;\r\nif (avc_latest_notif_update(avd->seqno, 1))\r\ngoto out;\r\nnode = avc_alloc_node();\r\nif (node) {\r\nstruct hlist_head *head;\r\nspinlock_t *lock;\r\nhvalue = avc_hash(ssid, tsid, tclass);\r\navc_node_populate(node, ssid, tsid, tclass, avd);\r\nhead = &avc_cache.slots[hvalue];\r\nlock = &avc_cache.slots_lock[hvalue];\r\nspin_lock_irqsave(lock, flag);\r\nhlist_for_each_entry(pos, head, list) {\r\nif (pos->ae.ssid == ssid &&\r\npos->ae.tsid == tsid &&\r\npos->ae.tclass == tclass) {\r\navc_node_replace(node, pos);\r\ngoto found;\r\n}\r\n}\r\nhlist_add_head_rcu(&node->list, head);\r\nfound:\r\nspin_unlock_irqrestore(lock, flag);\r\n}\r\nout:\r\nreturn node;\r\n}\r\nstatic void avc_audit_pre_callback(struct audit_buffer *ab, void *a)\r\n{\r\nstruct common_audit_data *ad = a;\r\naudit_log_format(ab, "avc: %s ",\r\nad->selinux_audit_data->denied ? "denied" : "granted");\r\navc_dump_av(ab, ad->selinux_audit_data->tclass,\r\nad->selinux_audit_data->audited);\r\naudit_log_format(ab, " for ");\r\n}\r\nstatic void avc_audit_post_callback(struct audit_buffer *ab, void *a)\r\n{\r\nstruct common_audit_data *ad = a;\r\naudit_log_format(ab, " ");\r\navc_dump_query(ab, ad->selinux_audit_data->ssid,\r\nad->selinux_audit_data->tsid,\r\nad->selinux_audit_data->tclass);\r\nif (ad->selinux_audit_data->denied) {\r\naudit_log_format(ab, " permissive=%u",\r\nad->selinux_audit_data->result ? 0 : 1);\r\n}\r\n}\r\nnoinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\r\nu32 requested, u32 audited, u32 denied, int result,\r\nstruct common_audit_data *a,\r\nunsigned flags)\r\n{\r\nstruct common_audit_data stack_data;\r\nstruct selinux_audit_data sad;\r\nif (!a) {\r\na = &stack_data;\r\na->type = LSM_AUDIT_DATA_NONE;\r\n}\r\nif ((a->type == LSM_AUDIT_DATA_INODE) &&\r\n(flags & MAY_NOT_BLOCK))\r\nreturn -ECHILD;\r\nsad.tclass = tclass;\r\nsad.requested = requested;\r\nsad.ssid = ssid;\r\nsad.tsid = tsid;\r\nsad.audited = audited;\r\nsad.denied = denied;\r\nsad.result = result;\r\na->selinux_audit_data = &sad;\r\ncommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\r\nreturn 0;\r\n}\r\nint __init avc_add_callback(int (*callback)(u32 event), u32 events)\r\n{\r\nstruct avc_callback_node *c;\r\nint rc = 0;\r\nc = kmalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nc->callback = callback;\r\nc->events = events;\r\nc->next = avc_callbacks;\r\navc_callbacks = c;\r\nout:\r\nreturn rc;\r\n}\r\nstatic inline int avc_sidcmp(u32 x, u32 y)\r\n{\r\nreturn (x == y || x == SECSID_WILD || y == SECSID_WILD);\r\n}\r\nstatic int avc_update_node(u32 event, u32 perms, u32 ssid, u32 tsid, u16 tclass,\r\nu32 seqno)\r\n{\r\nint hvalue, rc = 0;\r\nunsigned long flag;\r\nstruct avc_node *pos, *node, *orig = NULL;\r\nstruct hlist_head *head;\r\nspinlock_t *lock;\r\nnode = avc_alloc_node();\r\nif (!node) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nhvalue = avc_hash(ssid, tsid, tclass);\r\nhead = &avc_cache.slots[hvalue];\r\nlock = &avc_cache.slots_lock[hvalue];\r\nspin_lock_irqsave(lock, flag);\r\nhlist_for_each_entry(pos, head, list) {\r\nif (ssid == pos->ae.ssid &&\r\ntsid == pos->ae.tsid &&\r\ntclass == pos->ae.tclass &&\r\nseqno == pos->ae.avd.seqno){\r\norig = pos;\r\nbreak;\r\n}\r\n}\r\nif (!orig) {\r\nrc = -ENOENT;\r\navc_node_kill(node);\r\ngoto out_unlock;\r\n}\r\navc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\r\nswitch (event) {\r\ncase AVC_CALLBACK_GRANT:\r\nnode->ae.avd.allowed |= perms;\r\nbreak;\r\ncase AVC_CALLBACK_TRY_REVOKE:\r\ncase AVC_CALLBACK_REVOKE:\r\nnode->ae.avd.allowed &= ~perms;\r\nbreak;\r\ncase AVC_CALLBACK_AUDITALLOW_ENABLE:\r\nnode->ae.avd.auditallow |= perms;\r\nbreak;\r\ncase AVC_CALLBACK_AUDITALLOW_DISABLE:\r\nnode->ae.avd.auditallow &= ~perms;\r\nbreak;\r\ncase AVC_CALLBACK_AUDITDENY_ENABLE:\r\nnode->ae.avd.auditdeny |= perms;\r\nbreak;\r\ncase AVC_CALLBACK_AUDITDENY_DISABLE:\r\nnode->ae.avd.auditdeny &= ~perms;\r\nbreak;\r\n}\r\navc_node_replace(node, orig);\r\nout_unlock:\r\nspin_unlock_irqrestore(lock, flag);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void avc_flush(void)\r\n{\r\nstruct hlist_head *head;\r\nstruct avc_node *node;\r\nspinlock_t *lock;\r\nunsigned long flag;\r\nint i;\r\nfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\r\nhead = &avc_cache.slots[i];\r\nlock = &avc_cache.slots_lock[i];\r\nspin_lock_irqsave(lock, flag);\r\nrcu_read_lock();\r\nhlist_for_each_entry(node, head, list)\r\navc_node_delete(node);\r\nrcu_read_unlock();\r\nspin_unlock_irqrestore(lock, flag);\r\n}\r\n}\r\nint avc_ss_reset(u32 seqno)\r\n{\r\nstruct avc_callback_node *c;\r\nint rc = 0, tmprc;\r\navc_flush();\r\nfor (c = avc_callbacks; c; c = c->next) {\r\nif (c->events & AVC_CALLBACK_RESET) {\r\ntmprc = c->callback(AVC_CALLBACK_RESET);\r\nif (!rc)\r\nrc = tmprc;\r\n}\r\n}\r\navc_latest_notif_update(seqno, 0);\r\nreturn rc;\r\n}\r\nstatic noinline int avc_denied(u32 ssid, u32 tsid,\r\nu16 tclass, u32 requested,\r\nunsigned flags,\r\nstruct av_decision *avd)\r\n{\r\nif (flags & AVC_STRICT)\r\nreturn -EACCES;\r\nif (selinux_enforcing && !(avd->flags & AVD_FLAGS_PERMISSIVE))\r\nreturn -EACCES;\r\navc_update_node(AVC_CALLBACK_GRANT, requested, ssid,\r\ntsid, tclass, avd->seqno);\r\nreturn 0;\r\n}\r\ninline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\r\nu16 tclass, u32 requested,\r\nunsigned flags,\r\nstruct av_decision *avd)\r\n{\r\nstruct avc_node *node;\r\nint rc = 0;\r\nu32 denied;\r\nBUG_ON(!requested);\r\nrcu_read_lock();\r\nnode = avc_lookup(ssid, tsid, tclass);\r\nif (unlikely(!node)) {\r\nnode = avc_compute_av(ssid, tsid, tclass, avd);\r\n} else {\r\nmemcpy(avd, &node->ae.avd, sizeof(*avd));\r\navd = &node->ae.avd;\r\n}\r\ndenied = requested & ~(avd->allowed);\r\nif (unlikely(denied))\r\nrc = avc_denied(ssid, tsid, tclass, requested, flags, avd);\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\r\nu32 requested, struct common_audit_data *auditdata)\r\n{\r\nstruct av_decision avd;\r\nint rc, rc2;\r\nrc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\r\nrc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata);\r\nif (rc2)\r\nreturn rc2;\r\nreturn rc;\r\n}\r\nu32 avc_policy_seqno(void)\r\n{\r\nreturn avc_cache.latest_notif;\r\n}\r\nvoid avc_disable(void)\r\n{\r\nif (avc_node_cachep) {\r\navc_flush();\r\n}\r\n}
