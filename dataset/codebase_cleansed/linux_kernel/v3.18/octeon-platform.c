static int __init octeon_rng_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nstruct resource rng_resources[] = {\r\n{\r\n.flags = IORESOURCE_MEM,\r\n.start = XKPHYS_TO_PHYS(CVMX_RNM_CTL_STATUS),\r\n.end = XKPHYS_TO_PHYS(CVMX_RNM_CTL_STATUS) + 0xf\r\n}, {\r\n.flags = IORESOURCE_MEM,\r\n.start = cvmx_build_io_address(8, 0),\r\n.end = cvmx_build_io_address(8, 0) + 0x7\r\n}\r\n};\r\npd = platform_device_alloc("octeon_rng", -1);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = platform_device_add_resources(pd, rng_resources,\r\nARRAY_SIZE(rng_resources));\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init octeon_ehci_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nstruct resource usb_resources[] = {\r\n{\r\n.flags = IORESOURCE_MEM,\r\n}, {\r\n.flags = IORESOURCE_IRQ,\r\n}\r\n};\r\nif (!OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nreturn 0;\r\nif (octeon_is_simulation() || usb_disabled())\r\nreturn 0;\r\npd = platform_device_alloc("octeon-ehci", 0);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nusb_resources[0].start = 0x00016F0000000000ULL;\r\nusb_resources[0].end = usb_resources[0].start + 0x100;\r\nusb_resources[1].start = OCTEON_IRQ_USB0;\r\nusb_resources[1].end = OCTEON_IRQ_USB0;\r\nret = platform_device_add_resources(pd, usb_resources,\r\nARRAY_SIZE(usb_resources));\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init octeon_ohci_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nstruct resource usb_resources[] = {\r\n{\r\n.flags = IORESOURCE_MEM,\r\n}, {\r\n.flags = IORESOURCE_IRQ,\r\n}\r\n};\r\nif (!OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nreturn 0;\r\nif (octeon_is_simulation() || usb_disabled())\r\nreturn 0;\r\npd = platform_device_alloc("octeon-ohci", 0);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nusb_resources[0].start = 0x00016F0000000400ULL;\r\nusb_resources[0].end = usb_resources[0].start + 0x100;\r\nusb_resources[1].start = OCTEON_IRQ_USB0;\r\nusb_resources[1].end = OCTEON_IRQ_USB0;\r\nret = platform_device_add_resources(pd, usb_resources,\r\nARRAY_SIZE(usb_resources));\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic bool __init octeon_has_88e1145(void)\r\n{\r\nreturn !OCTEON_IS_MODEL(OCTEON_CN52XX) &&\r\n!OCTEON_IS_MODEL(OCTEON_CN6XXX) &&\r\n!OCTEON_IS_MODEL(OCTEON_CN56XX);\r\n}\r\nstatic void __init octeon_fdt_set_phy(int eth, int phy_addr)\r\n{\r\nconst __be32 *phy_handle;\r\nconst __be32 *alt_phy_handle;\r\nconst __be32 *reg;\r\nu32 phandle;\r\nint phy;\r\nint alt_phy;\r\nconst char *p;\r\nint current_len;\r\nchar new_name[20];\r\nphy_handle = fdt_getprop(initial_boot_params, eth, "phy-handle", NULL);\r\nif (!phy_handle)\r\nreturn;\r\nphandle = be32_to_cpup(phy_handle);\r\nphy = fdt_node_offset_by_phandle(initial_boot_params, phandle);\r\nalt_phy_handle = fdt_getprop(initial_boot_params, eth, "cavium,alt-phy-handle", NULL);\r\nif (alt_phy_handle) {\r\nu32 alt_phandle = be32_to_cpup(alt_phy_handle);\r\nalt_phy = fdt_node_offset_by_phandle(initial_boot_params, alt_phandle);\r\n} else {\r\nalt_phy = -1;\r\n}\r\nif (phy_addr < 0 || phy < 0) {\r\nfdt_nop_property(initial_boot_params, eth, "phy-handle");\r\nfdt_nop_property(initial_boot_params, eth, "cavium,alt-phy-handle");\r\nif (phy >= 0)\r\nfdt_nop_node(initial_boot_params, phy);\r\nif (alt_phy >= 0)\r\nfdt_nop_node(initial_boot_params, alt_phy);\r\nreturn;\r\n}\r\nif (phy_addr >= 256 && alt_phy > 0) {\r\nconst struct fdt_property *phy_prop;\r\nstruct fdt_property *alt_prop;\r\nu32 phy_handle_name;\r\nphy_prop = fdt_get_property(initial_boot_params, eth, "phy-handle", NULL);\r\nphy_handle_name = phy_prop->nameoff;\r\nfdt_nop_node(initial_boot_params, phy);\r\nfdt_nop_property(initial_boot_params, eth, "phy-handle");\r\nalt_prop = fdt_get_property_w(initial_boot_params, eth, "cavium,alt-phy-handle", NULL);\r\nalt_prop->nameoff = phy_handle_name;\r\nphy = alt_phy;\r\n}\r\nphy_addr &= 0xff;\r\nif (octeon_has_88e1145()) {\r\nfdt_nop_property(initial_boot_params, phy, "marvell,reg-init");\r\nmemset(new_name, 0, sizeof(new_name));\r\nstrcpy(new_name, "marvell,88e1145");\r\np = fdt_getprop(initial_boot_params, phy, "compatible",\r\n&current_len);\r\nif (p && current_len >= strlen(new_name))\r\nfdt_setprop_inplace(initial_boot_params, phy,\r\n"compatible", new_name, current_len);\r\n}\r\nreg = fdt_getprop(initial_boot_params, phy, "reg", NULL);\r\nif (phy_addr == be32_to_cpup(reg))\r\nreturn;\r\nfdt_setprop_inplace_cell(initial_boot_params, phy, "reg", phy_addr);\r\nsnprintf(new_name, sizeof(new_name), "ethernet-phy@%x", phy_addr);\r\np = fdt_get_name(initial_boot_params, phy, &current_len);\r\nif (p && current_len == strlen(new_name))\r\nfdt_set_name(initial_boot_params, phy, new_name);\r\nelse\r\npr_err("Error: could not rename ethernet phy: <%s>", p);\r\n}\r\nstatic void __init octeon_fdt_set_mac_addr(int n, u64 *pmac)\r\n{\r\nu8 new_mac[6];\r\nu64 mac = *pmac;\r\nint r;\r\nnew_mac[0] = (mac >> 40) & 0xff;\r\nnew_mac[1] = (mac >> 32) & 0xff;\r\nnew_mac[2] = (mac >> 24) & 0xff;\r\nnew_mac[3] = (mac >> 16) & 0xff;\r\nnew_mac[4] = (mac >> 8) & 0xff;\r\nnew_mac[5] = mac & 0xff;\r\nr = fdt_setprop_inplace(initial_boot_params, n, "local-mac-address",\r\nnew_mac, sizeof(new_mac));\r\nif (r) {\r\npr_err("Setting \"local-mac-address\" failed %d", r);\r\nreturn;\r\n}\r\n*pmac = mac + 1;\r\n}\r\nstatic void __init octeon_fdt_rm_ethernet(int node)\r\n{\r\nconst __be32 *phy_handle;\r\nphy_handle = fdt_getprop(initial_boot_params, node, "phy-handle", NULL);\r\nif (phy_handle) {\r\nu32 ph = be32_to_cpup(phy_handle);\r\nint p = fdt_node_offset_by_phandle(initial_boot_params, ph);\r\nif (p >= 0)\r\nfdt_nop_node(initial_boot_params, p);\r\n}\r\nfdt_nop_node(initial_boot_params, node);\r\n}\r\nstatic void __init octeon_fdt_pip_port(int iface, int i, int p, int max, u64 *pmac)\r\n{\r\nchar name_buffer[20];\r\nint eth;\r\nint phy_addr;\r\nint ipd_port;\r\nsnprintf(name_buffer, sizeof(name_buffer), "ethernet@%x", p);\r\neth = fdt_subnode_offset(initial_boot_params, iface, name_buffer);\r\nif (eth < 0)\r\nreturn;\r\nif (p > max) {\r\npr_debug("Deleting port %x:%x\n", i, p);\r\nocteon_fdt_rm_ethernet(eth);\r\nreturn;\r\n}\r\nif (OCTEON_IS_MODEL(OCTEON_CN68XX))\r\nipd_port = (0x100 * i) + (0x10 * p) + 0x800;\r\nelse\r\nipd_port = 16 * i + p;\r\nphy_addr = cvmx_helper_board_get_mii_address(ipd_port);\r\nocteon_fdt_set_phy(eth, phy_addr);\r\nocteon_fdt_set_mac_addr(eth, pmac);\r\n}\r\nstatic void __init octeon_fdt_pip_iface(int pip, int idx, u64 *pmac)\r\n{\r\nchar name_buffer[20];\r\nint iface;\r\nint p;\r\nint count = 0;\r\nsnprintf(name_buffer, sizeof(name_buffer), "interface@%d", idx);\r\niface = fdt_subnode_offset(initial_boot_params, pip, name_buffer);\r\nif (iface < 0)\r\nreturn;\r\nif (cvmx_helper_interface_enumerate(idx) == 0)\r\ncount = cvmx_helper_ports_on_interface(idx);\r\nfor (p = 0; p < 16; p++)\r\nocteon_fdt_pip_port(iface, idx, p, count - 1, pmac);\r\n}\r\nint __init octeon_prune_device_tree(void)\r\n{\r\nint i, max_port, uart_mask;\r\nconst char *pip_path;\r\nconst char *alias_prop;\r\nchar name_buffer[20];\r\nint aliases;\r\nu64 mac_addr_base;\r\nif (fdt_check_header(initial_boot_params))\r\npanic("Corrupt Device Tree.");\r\naliases = fdt_path_offset(initial_boot_params, "/aliases");\r\nif (aliases < 0) {\r\npr_err("Error: No /aliases node in device tree.");\r\nreturn -EINVAL;\r\n}\r\nmac_addr_base =\r\n((octeon_bootinfo->mac_addr_base[0] & 0xffull)) << 40 |\r\n((octeon_bootinfo->mac_addr_base[1] & 0xffull)) << 32 |\r\n((octeon_bootinfo->mac_addr_base[2] & 0xffull)) << 24 |\r\n((octeon_bootinfo->mac_addr_base[3] & 0xffull)) << 16 |\r\n((octeon_bootinfo->mac_addr_base[4] & 0xffull)) << 8 |\r\n(octeon_bootinfo->mac_addr_base[5] & 0xffull);\r\nif (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nmax_port = 2;\r\nelse if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN68XX))\r\nmax_port = 1;\r\nelse\r\nmax_port = 0;\r\nif (octeon_bootinfo->board_type == CVMX_BOARD_TYPE_NIC10E)\r\nmax_port = 0;\r\nfor (i = 0; i < 2; i++) {\r\nint mgmt;\r\nsnprintf(name_buffer, sizeof(name_buffer),\r\n"mix%d", i);\r\nalias_prop = fdt_getprop(initial_boot_params, aliases,\r\nname_buffer, NULL);\r\nif (alias_prop) {\r\nmgmt = fdt_path_offset(initial_boot_params, alias_prop);\r\nif (mgmt < 0)\r\ncontinue;\r\nif (i >= max_port) {\r\npr_debug("Deleting mix%d\n", i);\r\nocteon_fdt_rm_ethernet(mgmt);\r\nfdt_nop_property(initial_boot_params, aliases,\r\nname_buffer);\r\n} else {\r\nint phy_addr = cvmx_helper_board_get_mii_address(CVMX_HELPER_BOARD_MGMT_IPD_PORT + i);\r\nocteon_fdt_set_phy(mgmt, phy_addr);\r\nocteon_fdt_set_mac_addr(mgmt, &mac_addr_base);\r\n}\r\n}\r\n}\r\npip_path = fdt_getprop(initial_boot_params, aliases, "pip", NULL);\r\nif (pip_path) {\r\nint pip = fdt_path_offset(initial_boot_params, pip_path);\r\nif (pip >= 0)\r\nfor (i = 0; i <= 4; i++)\r\nocteon_fdt_pip_iface(pip, i, &mac_addr_base);\r\n}\r\nif (OCTEON_IS_MODEL(OCTEON_CN52XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN63XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN68XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN56XX))\r\nmax_port = 2;\r\nelse\r\nmax_port = 1;\r\nfor (i = 0; i < 2; i++) {\r\nint i2c;\r\nsnprintf(name_buffer, sizeof(name_buffer),\r\n"twsi%d", i);\r\nalias_prop = fdt_getprop(initial_boot_params, aliases,\r\nname_buffer, NULL);\r\nif (alias_prop) {\r\ni2c = fdt_path_offset(initial_boot_params, alias_prop);\r\nif (i2c < 0)\r\ncontinue;\r\nif (i >= max_port) {\r\npr_debug("Deleting twsi%d\n", i);\r\nfdt_nop_node(initial_boot_params, i2c);\r\nfdt_nop_property(initial_boot_params, aliases,\r\nname_buffer);\r\n}\r\n}\r\n}\r\nif (OCTEON_IS_MODEL(OCTEON_CN68XX))\r\nmax_port = 4;\r\nelse if (OCTEON_IS_MODEL(OCTEON_CN52XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN63XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN56XX))\r\nmax_port = 2;\r\nelse\r\nmax_port = 1;\r\nfor (i = 0; i < 2; i++) {\r\nint i2c;\r\nsnprintf(name_buffer, sizeof(name_buffer),\r\n"smi%d", i);\r\nalias_prop = fdt_getprop(initial_boot_params, aliases,\r\nname_buffer, NULL);\r\nif (alias_prop) {\r\ni2c = fdt_path_offset(initial_boot_params, alias_prop);\r\nif (i2c < 0)\r\ncontinue;\r\nif (i >= max_port) {\r\npr_debug("Deleting smi%d\n", i);\r\nfdt_nop_node(initial_boot_params, i2c);\r\nfdt_nop_property(initial_boot_params, aliases,\r\nname_buffer);\r\n}\r\n}\r\n}\r\nuart_mask = 3;\r\nif (OCTEON_IS_MODEL(OCTEON_CN52XX))\r\nuart_mask |= 4;\r\nfor (i = 0; i < 3; i++) {\r\nint uart;\r\nsnprintf(name_buffer, sizeof(name_buffer),\r\n"uart%d", i);\r\nalias_prop = fdt_getprop(initial_boot_params, aliases,\r\nname_buffer, NULL);\r\nif (alias_prop) {\r\nuart = fdt_path_offset(initial_boot_params, alias_prop);\r\nif (uart_mask & (1 << i)) {\r\n__be32 f;\r\nf = cpu_to_be32(octeon_get_io_clock_rate());\r\nfdt_setprop_inplace(initial_boot_params,\r\nuart, "clock-frequency",\r\n&f, sizeof(f));\r\ncontinue;\r\n}\r\npr_debug("Deleting uart%d\n", i);\r\nfdt_nop_node(initial_boot_params, uart);\r\nfdt_nop_property(initial_boot_params, aliases,\r\nname_buffer);\r\n}\r\n}\r\nalias_prop = fdt_getprop(initial_boot_params, aliases,\r\n"cf0", NULL);\r\nif (alias_prop) {\r\nunion cvmx_mio_boot_reg_cfgx mio_boot_reg_cfg;\r\nunsigned long base_ptr, region_base, region_size;\r\nunsigned long region1_base = 0;\r\nunsigned long region1_size = 0;\r\nint cs, bootbus;\r\nbool is_16bit = false;\r\nbool is_true_ide = false;\r\n__be32 new_reg[6];\r\n__be32 *ranges;\r\nint len;\r\nint cf = fdt_path_offset(initial_boot_params, alias_prop);\r\nbase_ptr = 0;\r\nif (octeon_bootinfo->major_version == 1\r\n&& octeon_bootinfo->minor_version >= 1) {\r\nif (octeon_bootinfo->compact_flash_common_base_addr)\r\nbase_ptr = octeon_bootinfo->compact_flash_common_base_addr;\r\n} else {\r\nbase_ptr = 0x1d000800;\r\n}\r\nif (!base_ptr)\r\ngoto no_cf;\r\nfor (cs = 0; cs < 8; cs++) {\r\nmio_boot_reg_cfg.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_CFGX(cs));\r\nregion_base = mio_boot_reg_cfg.s.base << 16;\r\nregion_size = (mio_boot_reg_cfg.s.size + 1) << 16;\r\nif (mio_boot_reg_cfg.s.en && base_ptr >= region_base\r\n&& base_ptr < region_base + region_size) {\r\nis_16bit = mio_boot_reg_cfg.s.width;\r\nbreak;\r\n}\r\n}\r\nif (cs >= 7) {\r\ngoto no_cf;\r\n}\r\nif (!(base_ptr & 0xfffful)) {\r\nmio_boot_reg_cfg.u64 =\r\ncvmx_read_csr(CVMX_MIO_BOOT_REG_CFGX(cs + 1));\r\nregion1_base = mio_boot_reg_cfg.s.base << 16;\r\nregion1_size = (mio_boot_reg_cfg.s.size + 1) << 16;\r\nif (!mio_boot_reg_cfg.s.en)\r\ngoto no_cf;\r\nis_true_ide = true;\r\n} else {\r\nfdt_nop_property(initial_boot_params, cf, "cavium,true-ide");\r\nfdt_nop_property(initial_boot_params, cf, "cavium,dma-engine-handle");\r\nif (!is_16bit) {\r\n__be32 width = cpu_to_be32(8);\r\nfdt_setprop_inplace(initial_boot_params, cf,\r\n"cavium,bus-width", &width, sizeof(width));\r\n}\r\n}\r\nnew_reg[0] = cpu_to_be32(cs);\r\nnew_reg[1] = cpu_to_be32(0);\r\nnew_reg[2] = cpu_to_be32(0x10000);\r\nnew_reg[3] = cpu_to_be32(cs + 1);\r\nnew_reg[4] = cpu_to_be32(0);\r\nnew_reg[5] = cpu_to_be32(0x10000);\r\nfdt_setprop_inplace(initial_boot_params, cf,\r\n"reg", new_reg, sizeof(new_reg));\r\nbootbus = fdt_parent_offset(initial_boot_params, cf);\r\nif (bootbus < 0)\r\ngoto no_cf;\r\nranges = fdt_getprop_w(initial_boot_params, bootbus, "ranges", &len);\r\nif (!ranges || len < (5 * 8 * sizeof(__be32)))\r\ngoto no_cf;\r\nranges[(cs * 5) + 2] = cpu_to_be32(region_base >> 32);\r\nranges[(cs * 5) + 3] = cpu_to_be32(region_base & 0xffffffff);\r\nranges[(cs * 5) + 4] = cpu_to_be32(region_size);\r\nif (is_true_ide) {\r\ncs++;\r\nranges[(cs * 5) + 2] = cpu_to_be32(region1_base >> 32);\r\nranges[(cs * 5) + 3] = cpu_to_be32(region1_base & 0xffffffff);\r\nranges[(cs * 5) + 4] = cpu_to_be32(region1_size);\r\n}\r\ngoto end_cf;\r\nno_cf:\r\nfdt_nop_node(initial_boot_params, cf);\r\nend_cf:\r\n;\r\n}\r\nalias_prop = fdt_getprop(initial_boot_params, aliases,\r\n"led0", NULL);\r\nif (alias_prop) {\r\nunion cvmx_mio_boot_reg_cfgx mio_boot_reg_cfg;\r\nunsigned long base_ptr, region_base, region_size;\r\nint cs, bootbus;\r\n__be32 new_reg[6];\r\n__be32 *ranges;\r\nint len;\r\nint led = fdt_path_offset(initial_boot_params, alias_prop);\r\nbase_ptr = octeon_bootinfo->led_display_base_addr;\r\nif (base_ptr == 0)\r\ngoto no_led;\r\nfor (cs = 0; cs < 8; cs++) {\r\nmio_boot_reg_cfg.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_CFGX(cs));\r\nregion_base = mio_boot_reg_cfg.s.base << 16;\r\nregion_size = (mio_boot_reg_cfg.s.size + 1) << 16;\r\nif (mio_boot_reg_cfg.s.en && base_ptr >= region_base\r\n&& base_ptr < region_base + region_size)\r\nbreak;\r\n}\r\nif (cs > 7)\r\ngoto no_led;\r\nnew_reg[0] = cpu_to_be32(cs);\r\nnew_reg[1] = cpu_to_be32(0x20);\r\nnew_reg[2] = cpu_to_be32(0x20);\r\nnew_reg[3] = cpu_to_be32(cs);\r\nnew_reg[4] = cpu_to_be32(0);\r\nnew_reg[5] = cpu_to_be32(0x20);\r\nfdt_setprop_inplace(initial_boot_params, led,\r\n"reg", new_reg, sizeof(new_reg));\r\nbootbus = fdt_parent_offset(initial_boot_params, led);\r\nif (bootbus < 0)\r\ngoto no_led;\r\nranges = fdt_getprop_w(initial_boot_params, bootbus, "ranges", &len);\r\nif (!ranges || len < (5 * 8 * sizeof(__be32)))\r\ngoto no_led;\r\nranges[(cs * 5) + 2] = cpu_to_be32(region_base >> 32);\r\nranges[(cs * 5) + 3] = cpu_to_be32(region_base & 0xffffffff);\r\nranges[(cs * 5) + 4] = cpu_to_be32(region_size);\r\ngoto end_led;\r\nno_led:\r\nfdt_nop_node(initial_boot_params, led);\r\nend_led:\r\n;\r\n}\r\nalias_prop = fdt_getprop(initial_boot_params, aliases,\r\n"uctl", NULL);\r\nif (alias_prop) {\r\nint uctl = fdt_path_offset(initial_boot_params, alias_prop);\r\nif (uctl >= 0 && (!OCTEON_IS_MODEL(OCTEON_CN6XXX) ||\r\nocteon_bootinfo->board_type == CVMX_BOARD_TYPE_NIC2E)) {\r\npr_debug("Deleting uctl\n");\r\nfdt_nop_node(initial_boot_params, uctl);\r\nfdt_nop_property(initial_boot_params, aliases, "uctl");\r\n} else if (octeon_bootinfo->board_type == CVMX_BOARD_TYPE_NIC10E ||\r\nocteon_bootinfo->board_type == CVMX_BOARD_TYPE_NIC4E) {\r\nfdt_nop_property(initial_boot_params, uctl, "refclk-type");\r\n}\r\n}\r\nalias_prop = fdt_getprop(initial_boot_params, aliases,\r\n"usbn", NULL);\r\nif (alias_prop) {\r\nint usbn = fdt_path_offset(initial_boot_params, alias_prop);\r\nif (usbn >= 0 && (current_cpu_type() == CPU_CAVIUM_OCTEON2 ||\r\n!octeon_has_feature(OCTEON_FEATURE_USB))) {\r\npr_debug("Deleting usbn\n");\r\nfdt_nop_node(initial_boot_params, usbn);\r\nfdt_nop_property(initial_boot_params, aliases, "usbn");\r\n} else {\r\n__be32 new_f[1];\r\nenum cvmx_helper_board_usb_clock_types c;\r\nc = __cvmx_helper_board_usb_get_clock_type();\r\nswitch (c) {\r\ncase USB_CLOCK_TYPE_REF_48:\r\nnew_f[0] = cpu_to_be32(48000000);\r\nfdt_setprop_inplace(initial_boot_params, usbn,\r\n"refclk-frequency", new_f, sizeof(new_f));\r\ncase USB_CLOCK_TYPE_REF_12:\r\nfdt_nop_property(initial_boot_params, usbn, "refclk-type");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init octeon_publish_devices(void)\r\n{\r\nreturn of_platform_bus_probe(NULL, octeon_ids, NULL);\r\n}
