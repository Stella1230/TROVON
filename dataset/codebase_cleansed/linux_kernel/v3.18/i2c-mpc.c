static inline void writeccr(struct mpc_i2c *i2c, u32 x)\r\n{\r\nwriteb(x, i2c->base + MPC_I2C_CR);\r\n}\r\nstatic irqreturn_t mpc_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct mpc_i2c *i2c = dev_id;\r\nif (readb(i2c->base + MPC_I2C_SR) & CSR_MIF) {\r\ni2c->interrupt = readb(i2c->base + MPC_I2C_SR);\r\nwriteb(0, i2c->base + MPC_I2C_SR);\r\nwake_up(&i2c->queue);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mpc_i2c_fixup(struct mpc_i2c *i2c)\r\n{\r\nint k;\r\nu32 delay_val = 1000000 / i2c->real_clk + 1;\r\nif (delay_val < 2)\r\ndelay_val = 2;\r\nfor (k = 9; k; k--) {\r\nwriteccr(i2c, 0);\r\nwriteccr(i2c, CCR_MSTA | CCR_MTX | CCR_MEN);\r\nreadb(i2c->base + MPC_I2C_DR);\r\nwriteccr(i2c, CCR_MEN);\r\nudelay(delay_val << 1);\r\n}\r\n}\r\nstatic int i2c_wait(struct mpc_i2c *i2c, unsigned timeout, int writing)\r\n{\r\nunsigned long orig_jiffies = jiffies;\r\nu32 x;\r\nint result = 0;\r\nif (!i2c->irq) {\r\nwhile (!(readb(i2c->base + MPC_I2C_SR) & CSR_MIF)) {\r\nschedule();\r\nif (time_after(jiffies, orig_jiffies + timeout)) {\r\ndev_dbg(i2c->dev, "timeout\n");\r\nwriteccr(i2c, 0);\r\nresult = -EIO;\r\nbreak;\r\n}\r\n}\r\nx = readb(i2c->base + MPC_I2C_SR);\r\nwriteb(0, i2c->base + MPC_I2C_SR);\r\n} else {\r\nresult = wait_event_timeout(i2c->queue,\r\n(i2c->interrupt & CSR_MIF), timeout);\r\nif (unlikely(!(i2c->interrupt & CSR_MIF))) {\r\ndev_dbg(i2c->dev, "wait timeout\n");\r\nwriteccr(i2c, 0);\r\nresult = -ETIMEDOUT;\r\n}\r\nx = i2c->interrupt;\r\ni2c->interrupt = 0;\r\n}\r\nif (result < 0)\r\nreturn result;\r\nif (!(x & CSR_MCF)) {\r\ndev_dbg(i2c->dev, "unfinished\n");\r\nreturn -EIO;\r\n}\r\nif (x & CSR_MAL) {\r\ndev_dbg(i2c->dev, "MAL\n");\r\nreturn -EIO;\r\n}\r\nif (writing && (x & CSR_RXAK)) {\r\ndev_dbg(i2c->dev, "No RXAK\n");\r\nwriteccr(i2c, CCR_MEN);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc_i2c_get_fdr_52xx(struct device_node *node, u32 clock,\r\nint prescaler, u32 *real_clk)\r\n{\r\nconst struct mpc_i2c_divider *div = NULL;\r\nunsigned int pvr = mfspr(SPRN_PVR);\r\nu32 divider;\r\nint i;\r\nif (clock == MPC_I2C_CLOCK_LEGACY) {\r\n*real_clk = mpc5xxx_get_bus_frequency(node) / 2048;\r\nreturn -EINVAL;\r\n}\r\ndivider = mpc5xxx_get_bus_frequency(node) / clock;\r\nfor (i = 0; i < ARRAY_SIZE(mpc_i2c_dividers_52xx); i++) {\r\ndiv = &mpc_i2c_dividers_52xx[i];\r\nif (div->fdr & 0xc0 && pvr == 0x80822011)\r\ncontinue;\r\nif (div->divider >= divider)\r\nbreak;\r\n}\r\n*real_clk = mpc5xxx_get_bus_frequency(node) / div->divider;\r\nreturn (int)div->fdr;\r\n}\r\nstatic void mpc_i2c_setup_52xx(struct device_node *node,\r\nstruct mpc_i2c *i2c,\r\nu32 clock, u32 prescaler)\r\n{\r\nint ret, fdr;\r\nif (clock == MPC_I2C_CLOCK_PRESERVE) {\r\ndev_dbg(i2c->dev, "using fdr %d\n",\r\nreadb(i2c->base + MPC_I2C_FDR));\r\nreturn;\r\n}\r\nret = mpc_i2c_get_fdr_52xx(node, clock, prescaler, &i2c->real_clk);\r\nfdr = (ret >= 0) ? ret : 0x3f;\r\nwriteb(fdr & 0xff, i2c->base + MPC_I2C_FDR);\r\nif (ret >= 0)\r\ndev_info(i2c->dev, "clock %u Hz (fdr=%d)\n", i2c->real_clk,\r\nfdr);\r\n}\r\nstatic void mpc_i2c_setup_52xx(struct device_node *node,\r\nstruct mpc_i2c *i2c,\r\nu32 clock, u32 prescaler)\r\n{\r\n}\r\nstatic void mpc_i2c_setup_512x(struct device_node *node,\r\nstruct mpc_i2c *i2c,\r\nu32 clock, u32 prescaler)\r\n{\r\nstruct device_node *node_ctrl;\r\nvoid __iomem *ctrl;\r\nconst u32 *pval;\r\nu32 idx;\r\nnode_ctrl = of_find_compatible_node(NULL, NULL,\r\n"fsl,mpc5121-i2c-ctrl");\r\nif (node_ctrl) {\r\nctrl = of_iomap(node_ctrl, 0);\r\nif (ctrl) {\r\npval = of_get_property(node, "reg", NULL);\r\nidx = (*pval & 0xff) / 0x20;\r\nsetbits32(ctrl, 1 << (24 + idx * 2));\r\niounmap(ctrl);\r\n}\r\nof_node_put(node_ctrl);\r\n}\r\nmpc_i2c_setup_52xx(node, i2c, clock, prescaler);\r\n}\r\nstatic void mpc_i2c_setup_512x(struct device_node *node,\r\nstruct mpc_i2c *i2c,\r\nu32 clock, u32 prescaler)\r\n{\r\n}\r\nstatic u32 mpc_i2c_get_sec_cfg_8xxx(void)\r\n{\r\nstruct device_node *node = NULL;\r\nu32 __iomem *reg;\r\nu32 val = 0;\r\nnode = of_find_node_by_name(NULL, "global-utilities");\r\nif (node) {\r\nconst u32 *prop = of_get_property(node, "reg", NULL);\r\nif (prop) {\r\nreg = ioremap(get_immrbase() + *prop + 0x14, 0x4);\r\nif (!reg)\r\nprintk(KERN_ERR\r\n"Error: couldn't map PORDEVSR2\n");\r\nelse\r\nval = in_be32(reg) & 0x00000080;\r\niounmap(reg);\r\n}\r\n}\r\nof_node_put(node);\r\nreturn val;\r\n}\r\nstatic int mpc_i2c_get_fdr_8xxx(struct device_node *node, u32 clock,\r\nu32 prescaler, u32 *real_clk)\r\n{\r\nconst struct mpc_i2c_divider *div = NULL;\r\nu32 divider;\r\nint i;\r\nif (clock == MPC_I2C_CLOCK_LEGACY) {\r\n*real_clk = fsl_get_sys_freq() / prescaler / (16 * 3072);\r\nreturn -EINVAL;\r\n}\r\nif (of_device_is_compatible(node, "fsl,mpc8544-i2c"))\r\nprescaler = mpc_i2c_get_sec_cfg_8xxx() ? 3 : 2;\r\nif (!prescaler)\r\nprescaler = 1;\r\ndivider = fsl_get_sys_freq() / clock / prescaler;\r\npr_debug("I2C: src_clock=%d clock=%d divider=%d\n",\r\nfsl_get_sys_freq(), clock, divider);\r\nfor (i = 0; i < ARRAY_SIZE(mpc_i2c_dividers_8xxx); i++) {\r\ndiv = &mpc_i2c_dividers_8xxx[i];\r\nif (div->divider >= divider)\r\nbreak;\r\n}\r\n*real_clk = fsl_get_sys_freq() / prescaler / div->divider;\r\nreturn div ? (int)div->fdr : -EINVAL;\r\n}\r\nstatic void mpc_i2c_setup_8xxx(struct device_node *node,\r\nstruct mpc_i2c *i2c,\r\nu32 clock, u32 prescaler)\r\n{\r\nint ret, fdr;\r\nif (clock == MPC_I2C_CLOCK_PRESERVE) {\r\ndev_dbg(i2c->dev, "using dfsrr %d, fdr %d\n",\r\nreadb(i2c->base + MPC_I2C_DFSRR),\r\nreadb(i2c->base + MPC_I2C_FDR));\r\nreturn;\r\n}\r\nret = mpc_i2c_get_fdr_8xxx(node, clock, prescaler, &i2c->real_clk);\r\nfdr = (ret >= 0) ? ret : 0x1031;\r\nwriteb(fdr & 0xff, i2c->base + MPC_I2C_FDR);\r\nwriteb((fdr >> 8) & 0xff, i2c->base + MPC_I2C_DFSRR);\r\nif (ret >= 0)\r\ndev_info(i2c->dev, "clock %d Hz (dfsrr=%d fdr=%d)\n",\r\ni2c->real_clk, fdr >> 8, fdr & 0xff);\r\n}\r\nstatic void mpc_i2c_setup_8xxx(struct device_node *node,\r\nstruct mpc_i2c *i2c,\r\nu32 clock, u32 prescaler)\r\n{\r\n}\r\nstatic void mpc_i2c_start(struct mpc_i2c *i2c)\r\n{\r\nwriteb(0, i2c->base + MPC_I2C_SR);\r\nwriteccr(i2c, CCR_MEN);\r\n}\r\nstatic void mpc_i2c_stop(struct mpc_i2c *i2c)\r\n{\r\nwriteccr(i2c, CCR_MEN);\r\n}\r\nstatic int mpc_write(struct mpc_i2c *i2c, int target,\r\nconst u8 *data, int length, int restart)\r\n{\r\nint i, result;\r\nunsigned timeout = i2c->adap.timeout;\r\nu32 flags = restart ? CCR_RSTA : 0;\r\nwriteccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA | CCR_MTX | flags);\r\nwriteb((target << 1), i2c->base + MPC_I2C_DR);\r\nresult = i2c_wait(i2c, timeout, 1);\r\nif (result < 0)\r\nreturn result;\r\nfor (i = 0; i < length; i++) {\r\nwriteb(data[i], i2c->base + MPC_I2C_DR);\r\nresult = i2c_wait(i2c, timeout, 1);\r\nif (result < 0)\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc_read(struct mpc_i2c *i2c, int target,\r\nu8 *data, int length, int restart, bool recv_len)\r\n{\r\nunsigned timeout = i2c->adap.timeout;\r\nint i, result;\r\nu32 flags = restart ? CCR_RSTA : 0;\r\nwriteccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA | CCR_MTX | flags);\r\nwriteb((target << 1) | 1, i2c->base + MPC_I2C_DR);\r\nresult = i2c_wait(i2c, timeout, 1);\r\nif (result < 0)\r\nreturn result;\r\nif (length) {\r\nif (length == 1 && !recv_len)\r\nwriteccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA | CCR_TXAK);\r\nelse\r\nwriteccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA);\r\nreadb(i2c->base + MPC_I2C_DR);\r\n}\r\nfor (i = 0; i < length; i++) {\r\nu8 byte;\r\nresult = i2c_wait(i2c, timeout, 0);\r\nif (result < 0)\r\nreturn result;\r\nif (i || !recv_len) {\r\nif (i == length - 2)\r\nwriteccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA\r\n| CCR_TXAK);\r\nif (i == length - 1)\r\nwriteccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA\r\n| CCR_MTX);\r\n}\r\nbyte = readb(i2c->base + MPC_I2C_DR);\r\nif (i == 0 && recv_len) {\r\nif (byte == 0 || byte > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EPROTO;\r\nlength += byte;\r\nif (length == 2)\r\nwriteccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA\r\n| CCR_TXAK);\r\n}\r\ndata[i] = byte;\r\n}\r\nreturn length;\r\n}\r\nstatic int mpc_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct i2c_msg *pmsg;\r\nint i;\r\nint ret = 0;\r\nunsigned long orig_jiffies = jiffies;\r\nstruct mpc_i2c *i2c = i2c_get_adapdata(adap);\r\nmpc_i2c_start(i2c);\r\nwhile (readb(i2c->base + MPC_I2C_SR) & CSR_MBB) {\r\nif (signal_pending(current)) {\r\ndev_dbg(i2c->dev, "Interrupted\n");\r\nwriteccr(i2c, 0);\r\nreturn -EINTR;\r\n}\r\nif (time_after(jiffies, orig_jiffies + HZ)) {\r\nu8 status = readb(i2c->base + MPC_I2C_SR);\r\ndev_dbg(i2c->dev, "timeout\n");\r\nif ((status & (CSR_MCF | CSR_MBB | CSR_RXAK)) != 0) {\r\nwriteb(status & ~CSR_MAL,\r\ni2c->base + MPC_I2C_SR);\r\nmpc_i2c_fixup(i2c);\r\n}\r\nreturn -EIO;\r\n}\r\nschedule();\r\n}\r\nfor (i = 0; ret >= 0 && i < num; i++) {\r\npmsg = &msgs[i];\r\ndev_dbg(i2c->dev,\r\n"Doing %s %d bytes to 0x%02x - %d of %d messages\n",\r\npmsg->flags & I2C_M_RD ? "read" : "write",\r\npmsg->len, pmsg->addr, i + 1, num);\r\nif (pmsg->flags & I2C_M_RD) {\r\nbool recv_len = pmsg->flags & I2C_M_RECV_LEN;\r\nret = mpc_read(i2c, pmsg->addr, pmsg->buf, pmsg->len, i,\r\nrecv_len);\r\nif (recv_len && ret > 0)\r\npmsg->len = ret;\r\n} else {\r\nret =\r\nmpc_write(i2c, pmsg->addr, pmsg->buf, pmsg->len, i);\r\n}\r\n}\r\nmpc_i2c_stop(i2c);\r\norig_jiffies = jiffies;\r\nwhile (readb(i2c->base + MPC_I2C_SR) & CSR_MBB) {\r\nif (time_after(jiffies, orig_jiffies + HZ)) {\r\nu8 status = readb(i2c->base + MPC_I2C_SR);\r\ndev_dbg(i2c->dev, "timeout\n");\r\nif ((status & (CSR_MCF | CSR_MBB | CSR_RXAK)) != 0) {\r\nwriteb(status & ~CSR_MAL,\r\ni2c->base + MPC_I2C_SR);\r\nmpc_i2c_fixup(i2c);\r\n}\r\nreturn -EIO;\r\n}\r\ncond_resched();\r\n}\r\nreturn (ret < 0) ? ret : num;\r\n}\r\nstatic u32 mpc_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL\r\n| I2C_FUNC_SMBUS_READ_BLOCK_DATA | I2C_FUNC_SMBUS_BLOCK_PROC_CALL;\r\n}\r\nstatic int fsl_i2c_probe(struct platform_device *op)\r\n{\r\nconst struct of_device_id *match;\r\nstruct mpc_i2c *i2c;\r\nconst u32 *prop;\r\nu32 clock = MPC_I2C_CLOCK_LEGACY;\r\nint result = 0;\r\nint plen;\r\nstruct resource res;\r\nstruct clk *clk;\r\nint err;\r\nmatch = of_match_device(mpc_i2c_of_match, &op->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\ni2c = kzalloc(sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\ni2c->dev = &op->dev;\r\ninit_waitqueue_head(&i2c->queue);\r\ni2c->base = of_iomap(op->dev.of_node, 0);\r\nif (!i2c->base) {\r\ndev_err(i2c->dev, "failed to map controller\n");\r\nresult = -ENOMEM;\r\ngoto fail_map;\r\n}\r\ni2c->irq = irq_of_parse_and_map(op->dev.of_node, 0);\r\nif (i2c->irq) {\r\nresult = request_irq(i2c->irq, mpc_i2c_isr,\r\nIRQF_SHARED, "i2c-mpc", i2c);\r\nif (result < 0) {\r\ndev_err(i2c->dev, "failed to attach interrupt\n");\r\ngoto fail_request;\r\n}\r\n}\r\nclk = devm_clk_get(&op->dev, NULL);\r\nif (!IS_ERR(clk)) {\r\nerr = clk_prepare_enable(clk);\r\nif (err) {\r\ndev_err(&op->dev, "failed to enable clock\n");\r\ngoto fail_request;\r\n} else {\r\ni2c->clk_per = clk;\r\n}\r\n}\r\nif (of_get_property(op->dev.of_node, "fsl,preserve-clocking", NULL)) {\r\nclock = MPC_I2C_CLOCK_PRESERVE;\r\n} else {\r\nprop = of_get_property(op->dev.of_node, "clock-frequency",\r\n&plen);\r\nif (prop && plen == sizeof(u32))\r\nclock = *prop;\r\n}\r\nif (match->data) {\r\nconst struct mpc_i2c_data *data = match->data;\r\ndata->setup(op->dev.of_node, i2c, clock, data->prescaler);\r\n} else {\r\nif (of_get_property(op->dev.of_node, "dfsrr", NULL))\r\nmpc_i2c_setup_8xxx(op->dev.of_node, i2c, clock, 0);\r\n}\r\nprop = of_get_property(op->dev.of_node, "fsl,timeout", &plen);\r\nif (prop && plen == sizeof(u32)) {\r\nmpc_ops.timeout = *prop * HZ / 1000000;\r\nif (mpc_ops.timeout < 5)\r\nmpc_ops.timeout = 5;\r\n}\r\ndev_info(i2c->dev, "timeout %u us\n", mpc_ops.timeout * 1000000 / HZ);\r\nplatform_set_drvdata(op, i2c);\r\ni2c->adap = mpc_ops;\r\nof_address_to_resource(op->dev.of_node, 0, &res);\r\nscnprintf(i2c->adap.name, sizeof(i2c->adap.name),\r\n"MPC adapter at 0x%llx", (unsigned long long)res.start);\r\ni2c_set_adapdata(&i2c->adap, i2c);\r\ni2c->adap.dev.parent = &op->dev;\r\ni2c->adap.dev.of_node = of_node_get(op->dev.of_node);\r\nresult = i2c_add_adapter(&i2c->adap);\r\nif (result < 0) {\r\ndev_err(i2c->dev, "failed to add adapter\n");\r\ngoto fail_add;\r\n}\r\nreturn result;\r\nfail_add:\r\nif (i2c->clk_per)\r\nclk_disable_unprepare(i2c->clk_per);\r\nfree_irq(i2c->irq, i2c);\r\nfail_request:\r\nirq_dispose_mapping(i2c->irq);\r\niounmap(i2c->base);\r\nfail_map:\r\nkfree(i2c);\r\nreturn result;\r\n}\r\nstatic int fsl_i2c_remove(struct platform_device *op)\r\n{\r\nstruct mpc_i2c *i2c = platform_get_drvdata(op);\r\ni2c_del_adapter(&i2c->adap);\r\nif (i2c->clk_per)\r\nclk_disable_unprepare(i2c->clk_per);\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, i2c);\r\nirq_dispose_mapping(i2c->irq);\r\niounmap(i2c->base);\r\nkfree(i2c);\r\nreturn 0;\r\n}\r\nstatic int mpc_i2c_suspend(struct device *dev)\r\n{\r\nstruct mpc_i2c *i2c = dev_get_drvdata(dev);\r\ni2c->fdr = readb(i2c->base + MPC_I2C_FDR);\r\ni2c->dfsrr = readb(i2c->base + MPC_I2C_DFSRR);\r\nreturn 0;\r\n}\r\nstatic int mpc_i2c_resume(struct device *dev)\r\n{\r\nstruct mpc_i2c *i2c = dev_get_drvdata(dev);\r\nwriteb(i2c->fdr, i2c->base + MPC_I2C_FDR);\r\nwriteb(i2c->dfsrr, i2c->base + MPC_I2C_DFSRR);\r\nreturn 0;\r\n}
