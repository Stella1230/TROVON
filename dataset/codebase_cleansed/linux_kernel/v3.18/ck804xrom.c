static void ck804xrom_cleanup(struct ck804xrom_window *window)\r\n{\r\nstruct ck804xrom_map_info *map, *scratch;\r\nu8 byte;\r\nif (window->pdev) {\r\npci_read_config_byte(window->pdev, 0x6d, &byte);\r\npci_write_config_byte(window->pdev, 0x6d, byte & ~1);\r\n}\r\nlist_for_each_entry_safe(map, scratch, &window->maps, list) {\r\nif (map->rsrc.parent)\r\nrelease_resource(&map->rsrc);\r\nmtd_device_unregister(map->mtd);\r\nmap_destroy(map->mtd);\r\nlist_del(&map->list);\r\nkfree(map);\r\n}\r\nif (window->rsrc.parent)\r\nrelease_resource(&window->rsrc);\r\nif (window->virt) {\r\niounmap(window->virt);\r\nwindow->virt = NULL;\r\nwindow->phys = 0;\r\nwindow->size = 0;\r\n}\r\npci_dev_put(window->pdev);\r\n}\r\nstatic int ck804xrom_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstatic char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };\r\nu8 byte;\r\nu16 word;\r\nstruct ck804xrom_window *window = &ck804xrom_window;\r\nstruct ck804xrom_map_info *map = NULL;\r\nunsigned long map_top;\r\nwindow->pdev = pci_dev_get(pdev);\r\nswitch (ent->driver_data) {\r\ncase DEV_CK804:\r\npci_read_config_byte(pdev, 0x88, &byte);\r\npci_write_config_byte(pdev, 0x88, byte | win_size_bits );\r\npci_read_config_byte(pdev, 0x88, &byte);\r\nif ((byte & ((1<<7)|(1<<6))) == ((1<<7)|(1<<6)))\r\nwindow->phys = 0xffb00000;\r\nelse if ((byte & (1<<7)) == (1<<7))\r\nwindow->phys = 0xffc00000;\r\nelse\r\nwindow->phys = 0xffff0000;\r\nbreak;\r\ncase DEV_MCP55:\r\npci_read_config_byte(pdev, 0x88, &byte);\r\npci_write_config_byte(pdev, 0x88, byte | (win_size_bits & 0xff));\r\npci_read_config_byte(pdev, 0x8c, &byte);\r\npci_write_config_byte(pdev, 0x8c, byte | ((win_size_bits & 0xff00) >> 8));\r\npci_read_config_word(pdev, 0x90, &word);\r\npci_write_config_word(pdev, 0x90, word | ((win_size_bits & 0x7fff0000) >> 16));\r\nwindow->phys = 0xff000000;\r\nbreak;\r\n}\r\nwindow->size = 0xffffffffUL - window->phys + 1UL;\r\nwindow->rsrc.name = MOD_NAME;\r\nwindow->rsrc.start = window->phys;\r\nwindow->rsrc.end = window->phys + window->size - 1;\r\nwindow->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&iomem_resource, &window->rsrc)) {\r\nwindow->rsrc.parent = NULL;\r\nprintk(KERN_ERR MOD_NAME\r\n" %s(): Unable to register resource %pR - kernel bug?\n",\r\n__func__, &window->rsrc);\r\n}\r\npci_read_config_byte(pdev, 0x6d, &byte);\r\npci_write_config_byte(pdev, 0x6d, byte | 1);\r\nwindow->virt = ioremap_nocache(window->phys, window->size);\r\nif (!window->virt) {\r\nprintk(KERN_ERR MOD_NAME ": ioremap(%08lx, %08lx) failed\n",\r\nwindow->phys, window->size);\r\ngoto out;\r\n}\r\nmap_top = window->phys;\r\n#if 1\r\nif (map_top < 0xffc00000)\r\nmap_top = 0xffc00000;\r\n#endif\r\nwhile((map_top - 1) < 0xffffffffUL) {\r\nstruct cfi_private *cfi;\r\nunsigned long offset;\r\nint i;\r\nif (!map)\r\nmap = kmalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map) {\r\nprintk(KERN_ERR MOD_NAME ": kmalloc failed");\r\ngoto out;\r\n}\r\nmemset(map, 0, sizeof(*map));\r\nINIT_LIST_HEAD(&map->list);\r\nmap->map.name = map->map_name;\r\nmap->map.phys = map_top;\r\noffset = map_top - window->phys;\r\nmap->map.virt = (void __iomem *)\r\n(((unsigned long)(window->virt)) + offset);\r\nmap->map.size = 0xffffffffUL - map_top + 1UL;\r\nsprintf(map->map_name, "%s @%08Lx",\r\nMOD_NAME, (unsigned long long)map->map.phys);\r\nfor(map->map.bankwidth = 32; map->map.bankwidth;\r\nmap->map.bankwidth >>= 1)\r\n{\r\nchar **probe_type;\r\nif (!map_bankwidth_supported(map->map.bankwidth))\r\ncontinue;\r\nsimple_map_init(&map->map);\r\nprobe_type = rom_probe_types;\r\nfor(; *probe_type; probe_type++) {\r\nmap->mtd = do_map_probe(*probe_type, &map->map);\r\nif (map->mtd)\r\ngoto found;\r\n}\r\n}\r\nmap_top += ROM_PROBE_STEP_SIZE;\r\ncontinue;\r\nfound:\r\nif (map->mtd->size > map->map.size) {\r\nprintk(KERN_WARNING MOD_NAME\r\n" rom(%llu) larger than window(%lu). fixing...\n",\r\n(unsigned long long)map->mtd->size, map->map.size);\r\nmap->mtd->size = map->map.size;\r\n}\r\nif (window->rsrc.parent) {\r\nmap->rsrc.name = map->map_name;\r\nmap->rsrc.start = map->map.phys;\r\nmap->rsrc.end = map->map.phys + map->mtd->size - 1;\r\nmap->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&window->rsrc, &map->rsrc)) {\r\nprintk(KERN_ERR MOD_NAME\r\n": cannot reserve MTD resource\n");\r\nmap->rsrc.parent = NULL;\r\n}\r\n}\r\nmap->map.virt = window->virt;\r\nmap->map.phys = window->phys;\r\ncfi = map->map.fldrv_priv;\r\nfor(i = 0; i < cfi->numchips; i++)\r\ncfi->chips[i].start += offset;\r\nmap->mtd->owner = THIS_MODULE;\r\nif (mtd_device_register(map->mtd, NULL, 0)) {\r\nmap_destroy(map->mtd);\r\nmap->mtd = NULL;\r\ngoto out;\r\n}\r\nmap_top += map->mtd->size;\r\nlist_add(&map->list, &window->maps);\r\nmap = NULL;\r\n}\r\nout:\r\nkfree(map);\r\nif (list_empty(&window->maps)) {\r\nck804xrom_cleanup(window);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ck804xrom_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct ck804xrom_window *window = &ck804xrom_window;\r\nck804xrom_cleanup(window);\r\n}\r\nstatic int __init init_ck804xrom(void)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct pci_device_id *id;\r\nint retVal;\r\npdev = NULL;\r\nfor(id = ck804xrom_pci_tbl; id->vendor; id++) {\r\npdev = pci_get_device(id->vendor, id->device, NULL);\r\nif (pdev)\r\nbreak;\r\n}\r\nif (pdev) {\r\nretVal = ck804xrom_init_one(pdev, id);\r\npci_dev_put(pdev);\r\nreturn retVal;\r\n}\r\nreturn -ENXIO;\r\n#if 0\r\nreturn pci_register_driver(&ck804xrom_driver);\r\n#endif\r\n}\r\nstatic void __exit cleanup_ck804xrom(void)\r\n{\r\nck804xrom_remove_one(ck804xrom_window.pdev);\r\n}
