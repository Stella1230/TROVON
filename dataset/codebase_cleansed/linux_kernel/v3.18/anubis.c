static int anubis_setkey(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct anubis_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __be32 *key = (const __be32 *)in_key;\r\nu32 *flags = &tfm->crt_flags;\r\nint N, R, i, r;\r\nu32 kappa[ANUBIS_MAX_N];\r\nu32 inter[ANUBIS_MAX_N];\r\nswitch (key_len) {\r\ncase 16: case 20: case 24: case 28:\r\ncase 32: case 36: case 40:\r\nbreak;\r\ndefault:\r\n*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nctx->key_len = key_len * 8;\r\nN = ctx->key_len >> 5;\r\nctx->R = R = 8 + N;\r\nfor (i = 0; i < N; i++)\r\nkappa[i] = be32_to_cpu(key[i]);\r\nfor (r = 0; r <= R; r++) {\r\nu32 K0, K1, K2, K3;\r\nK0 = T4[(kappa[N - 1] >> 24) ];\r\nK1 = T4[(kappa[N - 1] >> 16) & 0xff];\r\nK2 = T4[(kappa[N - 1] >> 8) & 0xff];\r\nK3 = T4[(kappa[N - 1] ) & 0xff];\r\nfor (i = N - 2; i >= 0; i--) {\r\nK0 = T4[(kappa[i] >> 24) ] ^\r\n(T5[(K0 >> 24) ] & 0xff000000U) ^\r\n(T5[(K0 >> 16) & 0xff] & 0x00ff0000U) ^\r\n(T5[(K0 >> 8) & 0xff] & 0x0000ff00U) ^\r\n(T5[(K0 ) & 0xff] & 0x000000ffU);\r\nK1 = T4[(kappa[i] >> 16) & 0xff] ^\r\n(T5[(K1 >> 24) ] & 0xff000000U) ^\r\n(T5[(K1 >> 16) & 0xff] & 0x00ff0000U) ^\r\n(T5[(K1 >> 8) & 0xff] & 0x0000ff00U) ^\r\n(T5[(K1 ) & 0xff] & 0x000000ffU);\r\nK2 = T4[(kappa[i] >> 8) & 0xff] ^\r\n(T5[(K2 >> 24) ] & 0xff000000U) ^\r\n(T5[(K2 >> 16) & 0xff] & 0x00ff0000U) ^\r\n(T5[(K2 >> 8) & 0xff] & 0x0000ff00U) ^\r\n(T5[(K2 ) & 0xff] & 0x000000ffU);\r\nK3 = T4[(kappa[i] ) & 0xff] ^\r\n(T5[(K3 >> 24) ] & 0xff000000U) ^\r\n(T5[(K3 >> 16) & 0xff] & 0x00ff0000U) ^\r\n(T5[(K3 >> 8) & 0xff] & 0x0000ff00U) ^\r\n(T5[(K3 ) & 0xff] & 0x000000ffU);\r\n}\r\nctx->E[r][0] = K0;\r\nctx->E[r][1] = K1;\r\nctx->E[r][2] = K2;\r\nctx->E[r][3] = K3;\r\nif (r == R)\r\nbreak;\r\nfor (i = 0; i < N; i++) {\r\nint j = i;\r\ninter[i] = T0[(kappa[j--] >> 24) ];\r\nif (j < 0)\r\nj = N - 1;\r\ninter[i] ^= T1[(kappa[j--] >> 16) & 0xff];\r\nif (j < 0)\r\nj = N - 1;\r\ninter[i] ^= T2[(kappa[j--] >> 8) & 0xff];\r\nif (j < 0)\r\nj = N - 1;\r\ninter[i] ^= T3[(kappa[j ] ) & 0xff];\r\n}\r\nkappa[0] = inter[0] ^ rc[r];\r\nfor (i = 1; i < N; i++)\r\nkappa[i] = inter[i];\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nctx->D[0][i] = ctx->E[R][i];\r\nctx->D[R][i] = ctx->E[0][i];\r\n}\r\nfor (r = 1; r < R; r++) {\r\nfor (i = 0; i < 4; i++) {\r\nu32 v = ctx->E[R - r][i];\r\nctx->D[r][i] =\r\nT0[T4[(v >> 24) ] & 0xff] ^\r\nT1[T4[(v >> 16) & 0xff] & 0xff] ^\r\nT2[T4[(v >> 8) & 0xff] & 0xff] ^\r\nT3[T4[(v ) & 0xff] & 0xff];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void anubis_crypt(u32 roundKey[ANUBIS_MAX_ROUNDS + 1][4],\r\nu8 *ciphertext, const u8 *plaintext, const int R)\r\n{\r\nconst __be32 *src = (const __be32 *)plaintext;\r\n__be32 *dst = (__be32 *)ciphertext;\r\nint i, r;\r\nu32 state[4];\r\nu32 inter[4];\r\nfor (i = 0; i < 4; i++)\r\nstate[i] = be32_to_cpu(src[i]) ^ roundKey[0][i];\r\nfor (r = 1; r < R; r++) {\r\ninter[0] =\r\nT0[(state[0] >> 24) ] ^\r\nT1[(state[1] >> 24) ] ^\r\nT2[(state[2] >> 24) ] ^\r\nT3[(state[3] >> 24) ] ^\r\nroundKey[r][0];\r\ninter[1] =\r\nT0[(state[0] >> 16) & 0xff] ^\r\nT1[(state[1] >> 16) & 0xff] ^\r\nT2[(state[2] >> 16) & 0xff] ^\r\nT3[(state[3] >> 16) & 0xff] ^\r\nroundKey[r][1];\r\ninter[2] =\r\nT0[(state[0] >> 8) & 0xff] ^\r\nT1[(state[1] >> 8) & 0xff] ^\r\nT2[(state[2] >> 8) & 0xff] ^\r\nT3[(state[3] >> 8) & 0xff] ^\r\nroundKey[r][2];\r\ninter[3] =\r\nT0[(state[0] ) & 0xff] ^\r\nT1[(state[1] ) & 0xff] ^\r\nT2[(state[2] ) & 0xff] ^\r\nT3[(state[3] ) & 0xff] ^\r\nroundKey[r][3];\r\nstate[0] = inter[0];\r\nstate[1] = inter[1];\r\nstate[2] = inter[2];\r\nstate[3] = inter[3];\r\n}\r\ninter[0] =\r\n(T0[(state[0] >> 24) ] & 0xff000000U) ^\r\n(T1[(state[1] >> 24) ] & 0x00ff0000U) ^\r\n(T2[(state[2] >> 24) ] & 0x0000ff00U) ^\r\n(T3[(state[3] >> 24) ] & 0x000000ffU) ^\r\nroundKey[R][0];\r\ninter[1] =\r\n(T0[(state[0] >> 16) & 0xff] & 0xff000000U) ^\r\n(T1[(state[1] >> 16) & 0xff] & 0x00ff0000U) ^\r\n(T2[(state[2] >> 16) & 0xff] & 0x0000ff00U) ^\r\n(T3[(state[3] >> 16) & 0xff] & 0x000000ffU) ^\r\nroundKey[R][1];\r\ninter[2] =\r\n(T0[(state[0] >> 8) & 0xff] & 0xff000000U) ^\r\n(T1[(state[1] >> 8) & 0xff] & 0x00ff0000U) ^\r\n(T2[(state[2] >> 8) & 0xff] & 0x0000ff00U) ^\r\n(T3[(state[3] >> 8) & 0xff] & 0x000000ffU) ^\r\nroundKey[R][2];\r\ninter[3] =\r\n(T0[(state[0] ) & 0xff] & 0xff000000U) ^\r\n(T1[(state[1] ) & 0xff] & 0x00ff0000U) ^\r\n(T2[(state[2] ) & 0xff] & 0x0000ff00U) ^\r\n(T3[(state[3] ) & 0xff] & 0x000000ffU) ^\r\nroundKey[R][3];\r\nfor (i = 0; i < 4; i++)\r\ndst[i] = cpu_to_be32(inter[i]);\r\n}\r\nstatic void anubis_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct anubis_ctx *ctx = crypto_tfm_ctx(tfm);\r\nanubis_crypt(ctx->E, dst, src, ctx->R);\r\n}\r\nstatic void anubis_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nstruct anubis_ctx *ctx = crypto_tfm_ctx(tfm);\r\nanubis_crypt(ctx->D, dst, src, ctx->R);\r\n}\r\nstatic int __init anubis_mod_init(void)\r\n{\r\nint ret = 0;\r\nret = crypto_register_alg(&anubis_alg);\r\nreturn ret;\r\n}\r\nstatic void __exit anubis_mod_fini(void)\r\n{\r\ncrypto_unregister_alg(&anubis_alg);\r\n}
