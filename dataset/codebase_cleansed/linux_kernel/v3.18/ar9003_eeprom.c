static const struct ar9300_eeprom *ar9003_eeprom_struct_find_by_id(int id)\r\n{\r\n#define N_LOOP (sizeof(ar9300_eep_templates) / sizeof(ar9300_eep_templates[0]))\r\nint it;\r\nfor (it = 0; it < N_LOOP; it++)\r\nif (ar9300_eep_templates[it]->templateVersion == id)\r\nreturn ar9300_eep_templates[it];\r\nreturn NULL;\r\n#undef N_LOOP\r\n}\r\nstatic int ath9k_hw_ar9300_check_eeprom(struct ath_hw *ah)\r\n{\r\nreturn 0;\r\n}\r\nstatic int interpolate(int x, int xa, int xb, int ya, int yb)\r\n{\r\nint bf, factor, plus;\r\nbf = 2 * (yb - ya) * (x - xa) / (xb - xa);\r\nfactor = bf / 2;\r\nplus = bf % 2;\r\nreturn ya + factor + plus;\r\n}\r\nstatic u32 ath9k_hw_ar9300_get_eeprom(struct ath_hw *ah,\r\nenum eeprom_param param)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;\r\nswitch (param) {\r\ncase EEP_MAC_LSW:\r\nreturn get_unaligned_be16(eep->macAddr);\r\ncase EEP_MAC_MID:\r\nreturn get_unaligned_be16(eep->macAddr + 2);\r\ncase EEP_MAC_MSW:\r\nreturn get_unaligned_be16(eep->macAddr + 4);\r\ncase EEP_REG_0:\r\nreturn le16_to_cpu(pBase->regDmn[0]);\r\ncase EEP_OP_CAP:\r\nreturn pBase->deviceCap;\r\ncase EEP_OP_MODE:\r\nreturn pBase->opCapFlags.opFlags;\r\ncase EEP_RF_SILENT:\r\nreturn pBase->rfSilent;\r\ncase EEP_TX_MASK:\r\nreturn (pBase->txrxMask >> 4) & 0xf;\r\ncase EEP_RX_MASK:\r\nreturn pBase->txrxMask & 0xf;\r\ncase EEP_PAPRD:\r\nreturn !!(pBase->featureEnable & BIT(5));\r\ncase EEP_CHAIN_MASK_REDUCE:\r\nreturn (pBase->miscConfiguration >> 0x3) & 0x1;\r\ncase EEP_ANT_DIV_CTL1:\r\nif (AR_SREV_9565(ah))\r\nreturn AR9300_EEP_ANTDIV_CONTROL_DEFAULT_VALUE;\r\nelse\r\nreturn eep->base_ext1.ant_div_control;\r\ncase EEP_ANTENNA_GAIN_5G:\r\nreturn eep->modalHeader5G.antennaGain;\r\ncase EEP_ANTENNA_GAIN_2G:\r\nreturn eep->modalHeader2G.antennaGain;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic bool ar9300_eeprom_read_byte(struct ath_hw *ah, int address,\r\nu8 *buffer)\r\n{\r\nu16 val;\r\nif (unlikely(!ath9k_hw_nvram_read(ah, address / 2, &val)))\r\nreturn false;\r\n*buffer = (val >> (8 * (address % 2))) & 0xff;\r\nreturn true;\r\n}\r\nstatic bool ar9300_eeprom_read_word(struct ath_hw *ah, int address,\r\nu8 *buffer)\r\n{\r\nu16 val;\r\nif (unlikely(!ath9k_hw_nvram_read(ah, address / 2, &val)))\r\nreturn false;\r\nbuffer[0] = val >> 8;\r\nbuffer[1] = val & 0xff;\r\nreturn true;\r\n}\r\nstatic bool ar9300_read_eeprom(struct ath_hw *ah, int address, u8 *buffer,\r\nint count)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint i;\r\nif ((address < 0) || ((address + count) / 2 > AR9300_EEPROM_SIZE - 1)) {\r\nath_dbg(common, EEPROM, "eeprom address not in range\n");\r\nreturn false;\r\n}\r\nif (address % 2 == 0) {\r\nif (!ar9300_eeprom_read_byte(ah, address--, buffer++))\r\ngoto error;\r\ncount--;\r\n}\r\nfor (i = 0; i < count / 2; i++) {\r\nif (!ar9300_eeprom_read_word(ah, address, buffer))\r\ngoto error;\r\naddress -= 2;\r\nbuffer += 2;\r\n}\r\nif (count % 2)\r\nif (!ar9300_eeprom_read_byte(ah, address, buffer))\r\ngoto error;\r\nreturn true;\r\nerror:\r\nath_dbg(common, EEPROM, "unable to read eeprom region at offset %d\n",\r\naddress);\r\nreturn false;\r\n}\r\nstatic bool ar9300_otp_read_word(struct ath_hw *ah, int addr, u32 *data)\r\n{\r\nREG_READ(ah, AR9300_OTP_BASE + (4 * addr));\r\nif (!ath9k_hw_wait(ah, AR9300_OTP_STATUS, AR9300_OTP_STATUS_TYPE,\r\nAR9300_OTP_STATUS_VALID, 1000))\r\nreturn false;\r\n*data = REG_READ(ah, AR9300_OTP_READ_DATA);\r\nreturn true;\r\n}\r\nstatic bool ar9300_read_otp(struct ath_hw *ah, int address, u8 *buffer,\r\nint count)\r\n{\r\nu32 data;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nint offset = 8 * ((address - i) % 4);\r\nif (!ar9300_otp_read_word(ah, (address - i) / 4, &data))\r\nreturn false;\r\nbuffer[i] = (data >> offset) & 0xff;\r\n}\r\nreturn true;\r\n}\r\nstatic void ar9300_comp_hdr_unpack(u8 *best, int *code, int *reference,\r\nint *length, int *major, int *minor)\r\n{\r\nunsigned long value[4];\r\nvalue[0] = best[0];\r\nvalue[1] = best[1];\r\nvalue[2] = best[2];\r\nvalue[3] = best[3];\r\n*code = ((value[0] >> 5) & 0x0007);\r\n*reference = (value[0] & 0x001f) | ((value[1] >> 2) & 0x0020);\r\n*length = ((value[1] << 4) & 0x07f0) | ((value[2] >> 4) & 0x000f);\r\n*major = (value[2] & 0x000f);\r\n*minor = (value[3] & 0x00ff);\r\n}\r\nstatic u16 ar9300_comp_cksum(u8 *data, int dsize)\r\n{\r\nint it, checksum = 0;\r\nfor (it = 0; it < dsize; it++) {\r\nchecksum += data[it];\r\nchecksum &= 0xffff;\r\n}\r\nreturn checksum;\r\n}\r\nstatic bool ar9300_uncompress_block(struct ath_hw *ah,\r\nu8 *mptr,\r\nint mdataSize,\r\nu8 *block,\r\nint size)\r\n{\r\nint it;\r\nint spot;\r\nint offset;\r\nint length;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nspot = 0;\r\nfor (it = 0; it < size; it += (length+2)) {\r\noffset = block[it];\r\noffset &= 0xff;\r\nspot += offset;\r\nlength = block[it+1];\r\nlength &= 0xff;\r\nif (length > 0 && spot >= 0 && spot+length <= mdataSize) {\r\nath_dbg(common, EEPROM,\r\n"Restore at %d: spot=%d offset=%d length=%d\n",\r\nit, spot, offset, length);\r\nmemcpy(&mptr[spot], &block[it+2], length);\r\nspot += length;\r\n} else if (length > 0) {\r\nath_dbg(common, EEPROM,\r\n"Bad restore at %d: spot=%d offset=%d length=%d\n",\r\nit, spot, offset, length);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int ar9300_compress_decision(struct ath_hw *ah,\r\nint it,\r\nint code,\r\nint reference,\r\nu8 *mptr,\r\nu8 *word, int length, int mdata_size)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nconst struct ar9300_eeprom *eep = NULL;\r\nswitch (code) {\r\ncase _CompressNone:\r\nif (length != mdata_size) {\r\nath_dbg(common, EEPROM,\r\n"EEPROM structure size mismatch memory=%d eeprom=%d\n",\r\nmdata_size, length);\r\nreturn -1;\r\n}\r\nmemcpy(mptr, word + COMP_HDR_LEN, length);\r\nath_dbg(common, EEPROM,\r\n"restored eeprom %d: uncompressed, length %d\n",\r\nit, length);\r\nbreak;\r\ncase _CompressBlock:\r\nif (reference == 0) {\r\n} else {\r\neep = ar9003_eeprom_struct_find_by_id(reference);\r\nif (eep == NULL) {\r\nath_dbg(common, EEPROM,\r\n"can't find reference eeprom struct %d\n",\r\nreference);\r\nreturn -1;\r\n}\r\nmemcpy(mptr, eep, mdata_size);\r\n}\r\nath_dbg(common, EEPROM,\r\n"restore eeprom %d: block, reference %d, length %d\n",\r\nit, reference, length);\r\nar9300_uncompress_block(ah, mptr, mdata_size,\r\n(word + COMP_HDR_LEN), length);\r\nbreak;\r\ndefault:\r\nath_dbg(common, EEPROM, "unknown compression code %d\n", code);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ar9300_check_header(void *data)\r\n{\r\nu32 *word = data;\r\nreturn !(*word == 0 || *word == ~0);\r\n}\r\nstatic bool ar9300_check_eeprom_header(struct ath_hw *ah, eeprom_read_op read,\r\nint base_addr)\r\n{\r\nu8 header[4];\r\nif (!read(ah, base_addr, header, 4))\r\nreturn false;\r\nreturn ar9300_check_header(header);\r\n}\r\nstatic int ar9300_eeprom_restore_flash(struct ath_hw *ah, u8 *mptr,\r\nint mdata_size)\r\n{\r\nu16 *data = (u16 *) mptr;\r\nint i;\r\nfor (i = 0; i < mdata_size / 2; i++, data++)\r\nath9k_hw_nvram_read(ah, i, data);\r\nreturn 0;\r\n}\r\nstatic int ar9300_eeprom_restore_internal(struct ath_hw *ah,\r\nu8 *mptr, int mdata_size)\r\n{\r\n#define MDEFAULT 15\r\n#define MSTATE 100\r\nint cptr;\r\nu8 *word;\r\nint code;\r\nint reference, length, major, minor;\r\nint osize;\r\nint it;\r\nu16 checksum, mchecksum;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ar9300_eeprom *eep;\r\neeprom_read_op read;\r\nif (ath9k_hw_use_flash(ah)) {\r\nu8 txrx;\r\nar9300_eeprom_restore_flash(ah, mptr, mdata_size);\r\neep = (struct ar9300_eeprom *) mptr;\r\ntxrx = eep->baseEepHeader.txrxMask;\r\nif (txrx != 0 && txrx != 0xff)\r\nreturn 0;\r\n}\r\nword = kzalloc(2048, GFP_KERNEL);\r\nif (!word)\r\nreturn -ENOMEM;\r\nmemcpy(mptr, &ar9300_default, mdata_size);\r\nread = ar9300_read_eeprom;\r\nif (AR_SREV_9485(ah))\r\ncptr = AR9300_BASE_ADDR_4K;\r\nelse if (AR_SREV_9330(ah))\r\ncptr = AR9300_BASE_ADDR_512;\r\nelse\r\ncptr = AR9300_BASE_ADDR;\r\nath_dbg(common, EEPROM, "Trying EEPROM access at Address 0x%04x\n",\r\ncptr);\r\nif (ar9300_check_eeprom_header(ah, read, cptr))\r\ngoto found;\r\ncptr = AR9300_BASE_ADDR_512;\r\nath_dbg(common, EEPROM, "Trying EEPROM access at Address 0x%04x\n",\r\ncptr);\r\nif (ar9300_check_eeprom_header(ah, read, cptr))\r\ngoto found;\r\nread = ar9300_read_otp;\r\ncptr = AR9300_BASE_ADDR;\r\nath_dbg(common, EEPROM, "Trying OTP access at Address 0x%04x\n", cptr);\r\nif (ar9300_check_eeprom_header(ah, read, cptr))\r\ngoto found;\r\ncptr = AR9300_BASE_ADDR_512;\r\nath_dbg(common, EEPROM, "Trying OTP access at Address 0x%04x\n", cptr);\r\nif (ar9300_check_eeprom_header(ah, read, cptr))\r\ngoto found;\r\ngoto fail;\r\nfound:\r\nath_dbg(common, EEPROM, "Found valid EEPROM data\n");\r\nfor (it = 0; it < MSTATE; it++) {\r\nif (!read(ah, cptr, word, COMP_HDR_LEN))\r\ngoto fail;\r\nif (!ar9300_check_header(word))\r\nbreak;\r\nar9300_comp_hdr_unpack(word, &code, &reference,\r\n&length, &major, &minor);\r\nath_dbg(common, EEPROM,\r\n"Found block at %x: code=%d ref=%d length=%d major=%d minor=%d\n",\r\ncptr, code, reference, length, major, minor);\r\nif ((!AR_SREV_9485(ah) && length >= 1024) ||\r\n(AR_SREV_9485(ah) && length > EEPROM_DATA_LEN_9485)) {\r\nath_dbg(common, EEPROM, "Skipping bad header\n");\r\ncptr -= COMP_HDR_LEN;\r\ncontinue;\r\n}\r\nosize = length;\r\nread(ah, cptr, word, COMP_HDR_LEN + osize + COMP_CKSUM_LEN);\r\nchecksum = ar9300_comp_cksum(&word[COMP_HDR_LEN], length);\r\nmchecksum = get_unaligned_le16(&word[COMP_HDR_LEN + osize]);\r\nath_dbg(common, EEPROM, "checksum %x %x\n",\r\nchecksum, mchecksum);\r\nif (checksum == mchecksum) {\r\nar9300_compress_decision(ah, it, code, reference, mptr,\r\nword, length, mdata_size);\r\n} else {\r\nath_dbg(common, EEPROM,\r\n"skipping block with bad checksum\n");\r\n}\r\ncptr -= (COMP_HDR_LEN + osize + COMP_CKSUM_LEN);\r\n}\r\nkfree(word);\r\nreturn cptr;\r\nfail:\r\nkfree(word);\r\nreturn -1;\r\n}\r\nstatic bool ath9k_hw_ar9300_fill_eeprom(struct ath_hw *ah)\r\n{\r\nu8 *mptr = (u8 *) &ah->eeprom.ar9300_eep;\r\nif (ar9300_eeprom_restore_internal(ah, mptr,\r\nsizeof(struct ar9300_eeprom)) < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic u32 ar9003_dump_modal_eeprom(char *buf, u32 len, u32 size,\r\nstruct ar9300_modal_eep_header *modal_hdr)\r\n{\r\nPR_EEP("Chain0 Ant. Control", le16_to_cpu(modal_hdr->antCtrlChain[0]));\r\nPR_EEP("Chain1 Ant. Control", le16_to_cpu(modal_hdr->antCtrlChain[1]));\r\nPR_EEP("Chain2 Ant. Control", le16_to_cpu(modal_hdr->antCtrlChain[2]));\r\nPR_EEP("Ant. Common Control", le32_to_cpu(modal_hdr->antCtrlCommon));\r\nPR_EEP("Ant. Common Control2", le32_to_cpu(modal_hdr->antCtrlCommon2));\r\nPR_EEP("Ant. Gain", modal_hdr->antennaGain);\r\nPR_EEP("Switch Settle", modal_hdr->switchSettling);\r\nPR_EEP("Chain0 xatten1DB", modal_hdr->xatten1DB[0]);\r\nPR_EEP("Chain1 xatten1DB", modal_hdr->xatten1DB[1]);\r\nPR_EEP("Chain2 xatten1DB", modal_hdr->xatten1DB[2]);\r\nPR_EEP("Chain0 xatten1Margin", modal_hdr->xatten1Margin[0]);\r\nPR_EEP("Chain1 xatten1Margin", modal_hdr->xatten1Margin[1]);\r\nPR_EEP("Chain2 xatten1Margin", modal_hdr->xatten1Margin[2]);\r\nPR_EEP("Temp Slope", modal_hdr->tempSlope);\r\nPR_EEP("Volt Slope", modal_hdr->voltSlope);\r\nPR_EEP("spur Channels0", modal_hdr->spurChans[0]);\r\nPR_EEP("spur Channels1", modal_hdr->spurChans[1]);\r\nPR_EEP("spur Channels2", modal_hdr->spurChans[2]);\r\nPR_EEP("spur Channels3", modal_hdr->spurChans[3]);\r\nPR_EEP("spur Channels4", modal_hdr->spurChans[4]);\r\nPR_EEP("Chain0 NF Threshold", modal_hdr->noiseFloorThreshCh[0]);\r\nPR_EEP("Chain1 NF Threshold", modal_hdr->noiseFloorThreshCh[1]);\r\nPR_EEP("Chain2 NF Threshold", modal_hdr->noiseFloorThreshCh[2]);\r\nPR_EEP("Quick Drop", modal_hdr->quick_drop);\r\nPR_EEP("txEndToXpaOff", modal_hdr->txEndToXpaOff);\r\nPR_EEP("xPA Bias Level", modal_hdr->xpaBiasLvl);\r\nPR_EEP("txFrameToDataStart", modal_hdr->txFrameToDataStart);\r\nPR_EEP("txFrameToPaOn", modal_hdr->txFrameToPaOn);\r\nPR_EEP("txFrameToXpaOn", modal_hdr->txFrameToXpaOn);\r\nPR_EEP("txClip", modal_hdr->txClip);\r\nPR_EEP("ADC Desired size", modal_hdr->adcDesiredSize);\r\nreturn len;\r\n}\r\nstatic u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\r\nu8 *buf, u32 len, u32 size)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct ar9300_base_eep_hdr *pBase;\r\nif (!dump_base_hdr) {\r\nlen += scnprintf(buf + len, size - len,\r\n"%20s :\n", "2GHz modal Header");\r\nlen = ar9003_dump_modal_eeprom(buf, len, size,\r\n&eep->modalHeader2G);\r\nlen += scnprintf(buf + len, size - len,\r\n"%20s :\n", "5GHz modal Header");\r\nlen = ar9003_dump_modal_eeprom(buf, len, size,\r\n&eep->modalHeader5G);\r\ngoto out;\r\n}\r\npBase = &eep->baseEepHeader;\r\nPR_EEP("EEPROM Version", ah->eeprom.ar9300_eep.eepromVersion);\r\nPR_EEP("RegDomain1", le16_to_cpu(pBase->regDmn[0]));\r\nPR_EEP("RegDomain2", le16_to_cpu(pBase->regDmn[1]));\r\nPR_EEP("TX Mask", (pBase->txrxMask >> 4));\r\nPR_EEP("RX Mask", (pBase->txrxMask & 0x0f));\r\nPR_EEP("Allow 5GHz", !!(pBase->opCapFlags.opFlags &\r\nAR5416_OPFLAGS_11A));\r\nPR_EEP("Allow 2GHz", !!(pBase->opCapFlags.opFlags &\r\nAR5416_OPFLAGS_11G));\r\nPR_EEP("Disable 2GHz HT20", !!(pBase->opCapFlags.opFlags &\r\nAR5416_OPFLAGS_N_2G_HT20));\r\nPR_EEP("Disable 2GHz HT40", !!(pBase->opCapFlags.opFlags &\r\nAR5416_OPFLAGS_N_2G_HT40));\r\nPR_EEP("Disable 5Ghz HT20", !!(pBase->opCapFlags.opFlags &\r\nAR5416_OPFLAGS_N_5G_HT20));\r\nPR_EEP("Disable 5Ghz HT40", !!(pBase->opCapFlags.opFlags &\r\nAR5416_OPFLAGS_N_5G_HT40));\r\nPR_EEP("Big Endian", !!(pBase->opCapFlags.eepMisc & 0x01));\r\nPR_EEP("RF Silent", pBase->rfSilent);\r\nPR_EEP("BT option", pBase->blueToothOptions);\r\nPR_EEP("Device Cap", pBase->deviceCap);\r\nPR_EEP("Device Type", pBase->deviceType);\r\nPR_EEP("Power Table Offset", pBase->pwrTableOffset);\r\nPR_EEP("Tuning Caps1", pBase->params_for_tuning_caps[0]);\r\nPR_EEP("Tuning Caps2", pBase->params_for_tuning_caps[1]);\r\nPR_EEP("Enable Tx Temp Comp", !!(pBase->featureEnable & BIT(0)));\r\nPR_EEP("Enable Tx Volt Comp", !!(pBase->featureEnable & BIT(1)));\r\nPR_EEP("Enable fast clock", !!(pBase->featureEnable & BIT(2)));\r\nPR_EEP("Enable doubling", !!(pBase->featureEnable & BIT(3)));\r\nPR_EEP("Internal regulator", !!(pBase->featureEnable & BIT(4)));\r\nPR_EEP("Enable Paprd", !!(pBase->featureEnable & BIT(5)));\r\nPR_EEP("Driver Strength", !!(pBase->miscConfiguration & BIT(0)));\r\nPR_EEP("Quick Drop", !!(pBase->miscConfiguration & BIT(1)));\r\nPR_EEP("Chain mask Reduce", (pBase->miscConfiguration >> 0x3) & 0x1);\r\nPR_EEP("Write enable Gpio", pBase->eepromWriteEnableGpio);\r\nPR_EEP("WLAN Disable Gpio", pBase->wlanDisableGpio);\r\nPR_EEP("WLAN LED Gpio", pBase->wlanLedGpio);\r\nPR_EEP("Rx Band Select Gpio", pBase->rxBandSelectGpio);\r\nPR_EEP("Tx Gain", pBase->txrxgain >> 4);\r\nPR_EEP("Rx Gain", pBase->txrxgain & 0xf);\r\nPR_EEP("SW Reg", le32_to_cpu(pBase->swreg));\r\nlen += scnprintf(buf + len, size - len, "%20s : %pM\n", "MacAddress",\r\nah->eeprom.ar9300_eep.macAddr);\r\nout:\r\nif (len > size)\r\nlen = size;\r\nreturn len;\r\n}\r\nstatic u32 ath9k_hw_ar9003_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\r\nu8 *buf, u32 len, u32 size)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ath9k_hw_ar9300_get_eeprom_ver(struct ath_hw *ah)\r\n{\r\nreturn ah->eeprom.ar9300_eep.eepromVersion;\r\n}\r\nstatic int ath9k_hw_ar9300_get_eeprom_rev(struct ath_hw *ah)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct ar9300_modal_eep_header *ar9003_modal_header(struct ath_hw *ah,\r\nbool is2ghz)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nif (is2ghz)\r\nreturn &eep->modalHeader2G;\r\nelse\r\nreturn &eep->modalHeader5G;\r\n}\r\nstatic void ar9003_hw_xpa_bias_level_apply(struct ath_hw *ah, bool is2ghz)\r\n{\r\nint bias = ar9003_modal_header(ah, is2ghz)->xpaBiasLvl;\r\nif (AR_SREV_9485(ah) || AR_SREV_9330(ah) || AR_SREV_9340(ah) ||\r\nAR_SREV_9531(ah))\r\nREG_RMW_FIELD(ah, AR_CH0_TOP2, AR_CH0_TOP2_XPABIASLVL, bias);\r\nelse if (AR_SREV_9462(ah) || AR_SREV_9550(ah) || AR_SREV_9565(ah))\r\nREG_RMW_FIELD(ah, AR_CH0_TOP, AR_CH0_TOP_XPABIASLVL, bias);\r\nelse {\r\nREG_RMW_FIELD(ah, AR_CH0_TOP, AR_CH0_TOP_XPABIASLVL, bias);\r\nREG_RMW_FIELD(ah, AR_CH0_THERM,\r\nAR_CH0_THERM_XPABIASLVL_MSB,\r\nbias >> 2);\r\nREG_RMW_FIELD(ah, AR_CH0_THERM,\r\nAR_CH0_THERM_XPASHORT2GND, 1);\r\n}\r\n}\r\nstatic u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is2ghz)\r\n{\r\nreturn le16_to_cpu(ar9003_modal_header(ah, is2ghz)->switchcomspdt);\r\n}\r\nu32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz)\r\n{\r\nreturn le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon);\r\n}\r\nu32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz)\r\n{\r\nreturn le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon2);\r\n}\r\nstatic u16 ar9003_hw_ant_ctrl_chain_get(struct ath_hw *ah, int chain,\r\nbool is2ghz)\r\n{\r\n__le16 val = ar9003_modal_header(ah, is2ghz)->antCtrlChain[chain];\r\nreturn le16_to_cpu(val);\r\n}\r\nstatic void ar9003_hw_ant_ctrl_apply(struct ath_hw *ah, bool is2ghz)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_hw_capabilities *pCap = &ah->caps;\r\nint chain;\r\nu32 regval, value, gpio;\r\nstatic const u32 switch_chain_reg[AR9300_MAX_CHAINS] = {\r\nAR_PHY_SWITCH_CHAIN_0,\r\nAR_PHY_SWITCH_CHAIN_1,\r\nAR_PHY_SWITCH_CHAIN_2,\r\n};\r\nif (AR_SREV_9485(ah) && (ar9003_hw_get_rx_gain_idx(ah) == 0)) {\r\nif (ah->config.xlna_gpio)\r\ngpio = ah->config.xlna_gpio;\r\nelse\r\ngpio = AR9300_EXT_LNA_CTL_GPIO_AR9485;\r\nath9k_hw_cfg_output(ah, gpio,\r\nAR_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED);\r\n}\r\nvalue = ar9003_hw_ant_ctrl_common_get(ah, is2ghz);\r\nif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\r\nREG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,\r\nAR_SWITCH_TABLE_COM_AR9462_ALL, value);\r\n} else if (AR_SREV_9550(ah) || AR_SREV_9531(ah)) {\r\nREG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,\r\nAR_SWITCH_TABLE_COM_AR9550_ALL, value);\r\n} else\r\nREG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,\r\nAR_SWITCH_TABLE_COM_ALL, value);\r\nif (AR_SREV_9462_20_OR_LATER(ah) || AR_SREV_9565(ah)) {\r\nvalue = ar9003_switch_com_spdt_get(ah, is2ghz);\r\nREG_RMW_FIELD(ah, AR_PHY_GLB_CONTROL,\r\nAR_SWITCH_TABLE_COM_SPDT_ALL, value);\r\nREG_SET_BIT(ah, AR_PHY_GLB_CONTROL, AR_BTCOEX_CTRL_SPDT_ENABLE);\r\n}\r\nvalue = ar9003_hw_ant_ctrl_common_2_get(ah, is2ghz);\r\nif (AR_SREV_9485(ah) && common->bt_ant_diversity) {\r\nvalue &= ~AR_SWITCH_TABLE_COM2_ALL;\r\nvalue |= ah->config.ant_ctrl_comm2g_switch_enable;\r\n}\r\nREG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2, AR_SWITCH_TABLE_COM2_ALL, value);\r\nif ((AR_SREV_9462(ah)) && (ah->rxchainmask == 0x2)) {\r\nvalue = ar9003_hw_ant_ctrl_chain_get(ah, 1, is2ghz);\r\nREG_RMW_FIELD(ah, switch_chain_reg[0],\r\nAR_SWITCH_TABLE_ALL, value);\r\n}\r\nfor (chain = 0; chain < AR9300_MAX_CHAINS; chain++) {\r\nif ((ah->rxchainmask & BIT(chain)) ||\r\n(ah->txchainmask & BIT(chain))) {\r\nvalue = ar9003_hw_ant_ctrl_chain_get(ah, chain,\r\nis2ghz);\r\nREG_RMW_FIELD(ah, switch_chain_reg[chain],\r\nAR_SWITCH_TABLE_ALL, value);\r\n}\r\n}\r\nif (AR_SREV_9330(ah) || AR_SREV_9485(ah) || AR_SREV_9565(ah)) {\r\nvalue = ath9k_hw_ar9300_get_eeprom(ah, EEP_ANT_DIV_CTL1);\r\nregval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);\r\nregval &= (~AR_ANT_DIV_CTRL_ALL);\r\nregval |= (value & 0x3f) << AR_ANT_DIV_CTRL_ALL_S;\r\nregval &= (~AR_PHY_ANT_DIV_LNADIV);\r\nregval |= ((value >> 6) & 0x1) << AR_PHY_ANT_DIV_LNADIV_S;\r\nif (AR_SREV_9485(ah) && common->bt_ant_diversity)\r\nregval |= AR_ANT_DIV_ENABLE;\r\nif (AR_SREV_9565(ah)) {\r\nif (common->bt_ant_diversity) {\r\nregval |= (1 << AR_PHY_ANT_SW_RX_PROT_S);\r\nREG_SET_BIT(ah, AR_PHY_RESTART,\r\nAR_PHY_RESTART_ENABLE_DIV_M2FLAG);\r\nREG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV,\r\nAR_BTCOEX_WL_LNADIV_FORCE_ON);\r\n} else {\r\nregval &= ~(1 << AR_PHY_ANT_DIV_LNADIV_S);\r\nregval &= ~(1 << AR_PHY_ANT_SW_RX_PROT_S);\r\nREG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,\r\n(1 << AR_PHY_ANT_SW_RX_PROT_S));\r\nREG_CLR_BIT(ah, AR_BTCOEX_WL_LNADIV,\r\nAR_BTCOEX_WL_LNADIV_FORCE_ON);\r\n}\r\n}\r\nREG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);\r\nregval = REG_READ(ah, AR_PHY_CCK_DETECT);\r\nregval &= (~AR_FAST_DIV_ENABLE);\r\nregval |= ((value >> 7) & 0x1) << AR_FAST_DIV_ENABLE_S;\r\nif ((AR_SREV_9485(ah) || AR_SREV_9565(ah))\r\n&& common->bt_ant_diversity)\r\nregval |= AR_FAST_DIV_ENABLE;\r\nREG_WRITE(ah, AR_PHY_CCK_DETECT, regval);\r\nif (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {\r\nregval = REG_READ(ah, AR_PHY_MC_GAIN_CTRL);\r\nregval &= (~(AR_PHY_ANT_DIV_MAIN_LNACONF |\r\nAR_PHY_ANT_DIV_ALT_LNACONF |\r\nAR_PHY_ANT_DIV_ALT_GAINTB |\r\nAR_PHY_ANT_DIV_MAIN_GAINTB));\r\nregval |= (ATH_ANT_DIV_COMB_LNA1 <<\r\nAR_PHY_ANT_DIV_MAIN_LNACONF_S);\r\nregval |= (ATH_ANT_DIV_COMB_LNA2 <<\r\nAR_PHY_ANT_DIV_ALT_LNACONF_S);\r\nREG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);\r\n}\r\n}\r\n}\r\nstatic void ar9003_hw_drive_strength_apply(struct ath_hw *ah)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;\r\nint drive_strength;\r\nunsigned long reg;\r\ndrive_strength = pBase->miscConfiguration & BIT(0);\r\nif (!drive_strength)\r\nreturn;\r\nreg = REG_READ(ah, AR_PHY_65NM_CH0_BIAS1);\r\nreg &= ~0x00ffffc0;\r\nreg |= 0x5 << 21;\r\nreg |= 0x5 << 18;\r\nreg |= 0x5 << 15;\r\nreg |= 0x5 << 12;\r\nreg |= 0x5 << 9;\r\nreg |= 0x5 << 6;\r\nREG_WRITE(ah, AR_PHY_65NM_CH0_BIAS1, reg);\r\nreg = REG_READ(ah, AR_PHY_65NM_CH0_BIAS2);\r\nreg &= ~0xffffffe0;\r\nreg |= 0x5 << 29;\r\nreg |= 0x5 << 26;\r\nreg |= 0x5 << 23;\r\nreg |= 0x5 << 20;\r\nreg |= 0x5 << 17;\r\nreg |= 0x5 << 14;\r\nreg |= 0x5 << 11;\r\nreg |= 0x5 << 8;\r\nreg |= 0x5 << 5;\r\nREG_WRITE(ah, AR_PHY_65NM_CH0_BIAS2, reg);\r\nreg = REG_READ(ah, AR_PHY_65NM_CH0_BIAS4);\r\nreg &= ~0xff800000;\r\nreg |= 0x5 << 29;\r\nreg |= 0x5 << 26;\r\nreg |= 0x5 << 23;\r\nREG_WRITE(ah, AR_PHY_65NM_CH0_BIAS4, reg);\r\n}\r\nstatic u16 ar9003_hw_atten_chain_get(struct ath_hw *ah, int chain,\r\nstruct ath9k_channel *chan)\r\n{\r\nint f[3], t[3];\r\nu16 value;\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nif (chain >= 0 && chain < 3) {\r\nif (IS_CHAN_2GHZ(chan))\r\nreturn eep->modalHeader2G.xatten1DB[chain];\r\nelse if (eep->base_ext2.xatten1DBLow[chain] != 0) {\r\nt[0] = eep->base_ext2.xatten1DBLow[chain];\r\nf[0] = 5180;\r\nt[1] = eep->modalHeader5G.xatten1DB[chain];\r\nf[1] = 5500;\r\nt[2] = eep->base_ext2.xatten1DBHigh[chain];\r\nf[2] = 5785;\r\nvalue = ar9003_hw_power_interpolate((s32) chan->channel,\r\nf, t, 3);\r\nreturn value;\r\n} else\r\nreturn eep->modalHeader5G.xatten1DB[chain];\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 ar9003_hw_atten_chain_get_margin(struct ath_hw *ah, int chain,\r\nstruct ath9k_channel *chan)\r\n{\r\nint f[3], t[3];\r\nu16 value;\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nif (chain >= 0 && chain < 3) {\r\nif (IS_CHAN_2GHZ(chan))\r\nreturn eep->modalHeader2G.xatten1Margin[chain];\r\nelse if (eep->base_ext2.xatten1MarginLow[chain] != 0) {\r\nt[0] = eep->base_ext2.xatten1MarginLow[chain];\r\nf[0] = 5180;\r\nt[1] = eep->modalHeader5G.xatten1Margin[chain];\r\nf[1] = 5500;\r\nt[2] = eep->base_ext2.xatten1MarginHigh[chain];\r\nf[2] = 5785;\r\nvalue = ar9003_hw_power_interpolate((s32) chan->channel,\r\nf, t, 3);\r\nreturn value;\r\n} else\r\nreturn eep->modalHeader5G.xatten1Margin[chain];\r\n}\r\nreturn 0;\r\n}\r\nstatic void ar9003_hw_atten_apply(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nint i;\r\nu16 value;\r\nunsigned long ext_atten_reg[3] = {AR_PHY_EXT_ATTEN_CTL_0,\r\nAR_PHY_EXT_ATTEN_CTL_1,\r\nAR_PHY_EXT_ATTEN_CTL_2,\r\n};\r\nif ((AR_SREV_9462(ah)) && (ah->rxchainmask == 0x2)) {\r\nvalue = ar9003_hw_atten_chain_get(ah, 1, chan);\r\nREG_RMW_FIELD(ah, ext_atten_reg[0],\r\nAR_PHY_EXT_ATTEN_CTL_XATTEN1_DB, value);\r\nvalue = ar9003_hw_atten_chain_get_margin(ah, 1, chan);\r\nREG_RMW_FIELD(ah, ext_atten_reg[0],\r\nAR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,\r\nvalue);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nif (ah->txchainmask & BIT(i)) {\r\nvalue = ar9003_hw_atten_chain_get(ah, i, chan);\r\nREG_RMW_FIELD(ah, ext_atten_reg[i],\r\nAR_PHY_EXT_ATTEN_CTL_XATTEN1_DB, value);\r\nif (AR_SREV_9485(ah) &&\r\n(ar9003_hw_get_rx_gain_idx(ah) == 0) &&\r\nah->config.xatten_margin_cfg)\r\nvalue = 5;\r\nelse\r\nvalue = ar9003_hw_atten_chain_get_margin(ah, i, chan);\r\nif (ah->config.alt_mingainidx)\r\nREG_RMW_FIELD(ah, AR_PHY_EXT_ATTEN_CTL_0,\r\nAR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,\r\nvalue);\r\nREG_RMW_FIELD(ah, ext_atten_reg[i],\r\nAR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,\r\nvalue);\r\n}\r\n}\r\n}\r\nstatic bool is_pmu_set(struct ath_hw *ah, u32 pmu_reg, int pmu_set)\r\n{\r\nint timeout = 100;\r\nwhile (pmu_set != REG_READ(ah, pmu_reg)) {\r\nif (timeout-- == 0)\r\nreturn false;\r\nREG_WRITE(ah, pmu_reg, pmu_set);\r\nudelay(10);\r\n}\r\nreturn true;\r\n}\r\nvoid ar9003_hw_internal_regulator_apply(struct ath_hw *ah)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;\r\nu32 reg_val;\r\nif (pBase->featureEnable & BIT(4)) {\r\nif (AR_SREV_9330(ah) || AR_SREV_9485(ah)) {\r\nint reg_pmu_set;\r\nreg_pmu_set = REG_READ(ah, AR_PHY_PMU2) & ~AR_PHY_PMU2_PGM;\r\nREG_WRITE(ah, AR_PHY_PMU2, reg_pmu_set);\r\nif (!is_pmu_set(ah, AR_PHY_PMU2, reg_pmu_set))\r\nreturn;\r\nif (AR_SREV_9330(ah)) {\r\nif (ah->is_clk_25mhz) {\r\nreg_pmu_set = (3 << 1) | (8 << 4) |\r\n(3 << 8) | (1 << 14) |\r\n(6 << 17) | (1 << 20) |\r\n(3 << 24);\r\n} else {\r\nreg_pmu_set = (4 << 1) | (7 << 4) |\r\n(3 << 8) | (1 << 14) |\r\n(6 << 17) | (1 << 20) |\r\n(3 << 24);\r\n}\r\n} else {\r\nreg_pmu_set = (5 << 1) | (7 << 4) |\r\n(2 << 8) | (2 << 14) |\r\n(6 << 17) | (1 << 20) |\r\n(3 << 24) | (1 << 28);\r\n}\r\nREG_WRITE(ah, AR_PHY_PMU1, reg_pmu_set);\r\nif (!is_pmu_set(ah, AR_PHY_PMU1, reg_pmu_set))\r\nreturn;\r\nreg_pmu_set = (REG_READ(ah, AR_PHY_PMU2) & ~0xFFC00000)\r\n| (4 << 26);\r\nREG_WRITE(ah, AR_PHY_PMU2, reg_pmu_set);\r\nif (!is_pmu_set(ah, AR_PHY_PMU2, reg_pmu_set))\r\nreturn;\r\nreg_pmu_set = (REG_READ(ah, AR_PHY_PMU2) & ~0x00200000)\r\n| (1 << 21);\r\nREG_WRITE(ah, AR_PHY_PMU2, reg_pmu_set);\r\nif (!is_pmu_set(ah, AR_PHY_PMU2, reg_pmu_set))\r\nreturn;\r\n} else if (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\r\nreg_val = le32_to_cpu(pBase->swreg);\r\nREG_WRITE(ah, AR_PHY_PMU1, reg_val);\r\n} else {\r\nreg_val = le32_to_cpu(pBase->swreg);\r\nREG_WRITE(ah, AR_RTC_REG_CONTROL1,\r\nREG_READ(ah, AR_RTC_REG_CONTROL1) &\r\n(~AR_RTC_REG_CONTROL1_SWREG_PROGRAM));\r\nREG_WRITE(ah, AR_RTC_REG_CONTROL0, reg_val);\r\nREG_WRITE(ah, AR_RTC_REG_CONTROL1,\r\nREG_READ(ah,\r\nAR_RTC_REG_CONTROL1) |\r\nAR_RTC_REG_CONTROL1_SWREG_PROGRAM);\r\n}\r\n} else {\r\nif (AR_SREV_9330(ah) || AR_SREV_9485(ah)) {\r\nREG_RMW_FIELD(ah, AR_PHY_PMU2, AR_PHY_PMU2_PGM, 0);\r\nwhile (REG_READ_FIELD(ah, AR_PHY_PMU2,\r\nAR_PHY_PMU2_PGM))\r\nudelay(10);\r\nREG_RMW_FIELD(ah, AR_PHY_PMU1, AR_PHY_PMU1_PWD, 0x1);\r\nwhile (!REG_READ_FIELD(ah, AR_PHY_PMU1,\r\nAR_PHY_PMU1_PWD))\r\nudelay(10);\r\nREG_RMW_FIELD(ah, AR_PHY_PMU2, AR_PHY_PMU2_PGM, 0x1);\r\nwhile (!REG_READ_FIELD(ah, AR_PHY_PMU2,\r\nAR_PHY_PMU2_PGM))\r\nudelay(10);\r\n} else if (AR_SREV_9462(ah) || AR_SREV_9565(ah))\r\nREG_RMW_FIELD(ah, AR_PHY_PMU1, AR_PHY_PMU1_PWD, 0x1);\r\nelse {\r\nreg_val = REG_READ(ah, AR_RTC_SLEEP_CLK) |\r\nAR_RTC_FORCE_SWREG_PRD;\r\nREG_WRITE(ah, AR_RTC_SLEEP_CLK, reg_val);\r\n}\r\n}\r\n}\r\nstatic void ar9003_hw_apply_tuning_caps(struct ath_hw *ah)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nu8 tuning_caps_param = eep->baseEepHeader.params_for_tuning_caps[0];\r\nif (AR_SREV_9340(ah) || AR_SREV_9531(ah))\r\nreturn;\r\nif (eep->baseEepHeader.featureEnable & 0x40) {\r\ntuning_caps_param &= 0x7f;\r\nREG_RMW_FIELD(ah, AR_CH0_XTAL, AR_CH0_XTAL_CAPINDAC,\r\ntuning_caps_param);\r\nREG_RMW_FIELD(ah, AR_CH0_XTAL, AR_CH0_XTAL_CAPOUTDAC,\r\ntuning_caps_param);\r\n}\r\n}\r\nstatic void ar9003_hw_quick_drop_apply(struct ath_hw *ah, u16 freq)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;\r\nint quick_drop;\r\ns32 t[3], f[3] = {5180, 5500, 5785};\r\nif (!(pBase->miscConfiguration & BIT(4)))\r\nreturn;\r\nif (AR_SREV_9300(ah) || AR_SREV_9580(ah) || AR_SREV_9340(ah)) {\r\nif (freq < 4000) {\r\nquick_drop = eep->modalHeader2G.quick_drop;\r\n} else {\r\nt[0] = eep->base_ext1.quick_drop_low;\r\nt[1] = eep->modalHeader5G.quick_drop;\r\nt[2] = eep->base_ext1.quick_drop_high;\r\nquick_drop = ar9003_hw_power_interpolate(freq, f, t, 3);\r\n}\r\nREG_RMW_FIELD(ah, AR_PHY_AGC, AR_PHY_AGC_QUICK_DROP, quick_drop);\r\n}\r\n}\r\nstatic void ar9003_hw_txend_to_xpa_off_apply(struct ath_hw *ah, bool is2ghz)\r\n{\r\nu32 value;\r\nvalue = ar9003_modal_header(ah, is2ghz)->txEndToXpaOff;\r\nREG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,\r\nAR_PHY_XPA_TIMING_CTL_TX_END_XPAB_OFF, value);\r\nREG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,\r\nAR_PHY_XPA_TIMING_CTL_TX_END_XPAA_OFF, value);\r\n}\r\nstatic void ar9003_hw_xpa_timing_control_apply(struct ath_hw *ah, bool is2ghz)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nu8 xpa_ctl;\r\nif (!(eep->baseEepHeader.featureEnable & 0x80))\r\nreturn;\r\nif (!AR_SREV_9300(ah) &&\r\n!AR_SREV_9340(ah) &&\r\n!AR_SREV_9580(ah) &&\r\n!AR_SREV_9531(ah))\r\nreturn;\r\nxpa_ctl = ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;\r\nif (is2ghz)\r\nREG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,\r\nAR_PHY_XPA_TIMING_CTL_FRAME_XPAB_ON, xpa_ctl);\r\nelse\r\nREG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,\r\nAR_PHY_XPA_TIMING_CTL_FRAME_XPAA_ON, xpa_ctl);\r\n}\r\nstatic void ar9003_hw_xlna_bias_strength_apply(struct ath_hw *ah, bool is2ghz)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nu8 bias;\r\nif (!(eep->baseEepHeader.miscConfiguration & 0x40))\r\nreturn;\r\nif (!AR_SREV_9300(ah))\r\nreturn;\r\nbias = ar9003_modal_header(ah, is2ghz)->xlna_bias_strength;\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS,\r\nbias & 0x3);\r\nbias >>= 2;\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS,\r\nbias & 0x3);\r\nbias >>= 2;\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS,\r\nbias & 0x3);\r\n}\r\nstatic int ar9003_hw_get_thermometer(struct ath_hw *ah)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;\r\nint thermometer = (pBase->miscConfiguration >> 1) & 0x3;\r\nreturn --thermometer;\r\n}\r\nstatic void ar9003_hw_thermometer_apply(struct ath_hw *ah)\r\n{\r\nint thermometer = ar9003_hw_get_thermometer(ah);\r\nu8 therm_on = (thermometer < 0) ? 0 : 1;\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH0_RXTX4,\r\nAR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, therm_on);\r\nif (ah->caps.tx_chainmask & BIT(1))\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH1_RXTX4,\r\nAR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, therm_on);\r\nif (ah->caps.tx_chainmask & BIT(2))\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4,\r\nAR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, therm_on);\r\ntherm_on = (thermometer < 0) ? 0 : (thermometer == 0);\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH0_RXTX4,\r\nAR_PHY_65NM_CH0_RXTX4_THERM_ON, therm_on);\r\nif (ah->caps.tx_chainmask & BIT(1)) {\r\ntherm_on = (thermometer < 0) ? 0 : (thermometer == 1);\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH1_RXTX4,\r\nAR_PHY_65NM_CH0_RXTX4_THERM_ON, therm_on);\r\n}\r\nif (ah->caps.tx_chainmask & BIT(2)) {\r\ntherm_on = (thermometer < 0) ? 0 : (thermometer == 2);\r\nREG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4,\r\nAR_PHY_65NM_CH0_RXTX4_THERM_ON, therm_on);\r\n}\r\n}\r\nstatic void ar9003_hw_thermo_cal_apply(struct ath_hw *ah)\r\n{\r\nu32 data, ko, kg;\r\nif (!AR_SREV_9462_20_OR_LATER(ah))\r\nreturn;\r\nar9300_otp_read_word(ah, 1, &data);\r\nko = data & 0xff;\r\nkg = (data >> 8) & 0xff;\r\nif (ko || kg) {\r\nREG_RMW_FIELD(ah, AR_PHY_BB_THERM_ADC_3,\r\nAR_PHY_BB_THERM_ADC_3_THERM_ADC_OFFSET, ko);\r\nREG_RMW_FIELD(ah, AR_PHY_BB_THERM_ADC_3,\r\nAR_PHY_BB_THERM_ADC_3_THERM_ADC_SCALE_GAIN,\r\nkg + 256);\r\n}\r\n}\r\nstatic void ar9003_hw_apply_minccapwr_thresh(struct ath_hw *ah,\r\nbool is2ghz)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nconst u_int32_t cca_ctrl[AR9300_MAX_CHAINS] = {\r\nAR_PHY_CCA_CTRL_0,\r\nAR_PHY_CCA_CTRL_1,\r\nAR_PHY_CCA_CTRL_2,\r\n};\r\nint chain;\r\nu32 val;\r\nif (is2ghz) {\r\nif (!(eep->base_ext1.misc_enable & BIT(2)))\r\nreturn;\r\n} else {\r\nif (!(eep->base_ext1.misc_enable & BIT(3)))\r\nreturn;\r\n}\r\nfor (chain = 0; chain < AR9300_MAX_CHAINS; chain++) {\r\nif (!(ah->caps.tx_chainmask & BIT(chain)))\r\ncontinue;\r\nval = ar9003_modal_header(ah, is2ghz)->noiseFloorThreshCh[chain];\r\nREG_RMW_FIELD(ah, cca_ctrl[chain],\r\nAR_PHY_EXT_CCA0_THRESH62_1, val);\r\n}\r\n}\r\nstatic void ath9k_hw_ar9300_set_board_values(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nbool is2ghz = IS_CHAN_2GHZ(chan);\r\nar9003_hw_xpa_timing_control_apply(ah, is2ghz);\r\nar9003_hw_xpa_bias_level_apply(ah, is2ghz);\r\nar9003_hw_ant_ctrl_apply(ah, is2ghz);\r\nar9003_hw_drive_strength_apply(ah);\r\nar9003_hw_xlna_bias_strength_apply(ah, is2ghz);\r\nar9003_hw_atten_apply(ah, chan);\r\nar9003_hw_quick_drop_apply(ah, chan->channel);\r\nif (!AR_SREV_9330(ah) && !AR_SREV_9340(ah) && !AR_SREV_9531(ah))\r\nar9003_hw_internal_regulator_apply(ah);\r\nar9003_hw_apply_tuning_caps(ah);\r\nar9003_hw_apply_minccapwr_thresh(ah, chan);\r\nar9003_hw_txend_to_xpa_off_apply(ah, is2ghz);\r\nar9003_hw_thermometer_apply(ah);\r\nar9003_hw_thermo_cal_apply(ah);\r\n}\r\nstatic void ath9k_hw_ar9300_set_addac(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\n}\r\nstatic int ar9003_hw_power_interpolate(int32_t x,\r\nint32_t *px, int32_t *py, u_int16_t np)\r\n{\r\nint ip = 0;\r\nint lx = 0, ly = 0, lhave = 0;\r\nint hx = 0, hy = 0, hhave = 0;\r\nint dx = 0;\r\nint y = 0;\r\nlhave = 0;\r\nhhave = 0;\r\nfor (ip = 0; ip < np; ip++) {\r\ndx = x - px[ip];\r\nif (dx <= 0) {\r\nif (!hhave || dx > (x - hx)) {\r\nhx = px[ip];\r\nhy = py[ip];\r\nhhave = 1;\r\n}\r\n}\r\nif (dx >= 0) {\r\nif (!lhave || dx < (x - lx)) {\r\nlx = px[ip];\r\nly = py[ip];\r\nlhave = 1;\r\n}\r\n}\r\n}\r\nif (lhave) {\r\nif (hhave) {\r\nif (hx == lx)\r\ny = ly;\r\nelse\r\ny = interpolate(x, lx, hx, ly, hy);\r\n} else\r\ny = ly;\r\n} else if (hhave)\r\ny = hy;\r\nelse\r\ny = -(1 << 30);\r\nreturn y;\r\n}\r\nstatic u8 ar9003_hw_eeprom_get_tgt_pwr(struct ath_hw *ah,\r\nu16 rateIndex, u16 freq, bool is2GHz)\r\n{\r\nu16 numPiers, i;\r\ns32 targetPowerArray[AR9300_NUM_5G_20_TARGET_POWERS];\r\ns32 freqArray[AR9300_NUM_5G_20_TARGET_POWERS];\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct cal_tgt_pow_legacy *pEepromTargetPwr;\r\nu8 *pFreqBin;\r\nif (is2GHz) {\r\nnumPiers = AR9300_NUM_2G_20_TARGET_POWERS;\r\npEepromTargetPwr = eep->calTargetPower2G;\r\npFreqBin = eep->calTarget_freqbin_2G;\r\n} else {\r\nnumPiers = AR9300_NUM_5G_20_TARGET_POWERS;\r\npEepromTargetPwr = eep->calTargetPower5G;\r\npFreqBin = eep->calTarget_freqbin_5G;\r\n}\r\nfor (i = 0; i < numPiers; i++) {\r\nfreqArray[i] = ath9k_hw_fbin2freq(pFreqBin[i], is2GHz);\r\ntargetPowerArray[i] = pEepromTargetPwr[i].tPow2x[rateIndex];\r\n}\r\nreturn (u8) ar9003_hw_power_interpolate((s32) freq,\r\nfreqArray,\r\ntargetPowerArray, numPiers);\r\n}\r\nstatic u8 ar9003_hw_eeprom_get_ht20_tgt_pwr(struct ath_hw *ah,\r\nu16 rateIndex,\r\nu16 freq, bool is2GHz)\r\n{\r\nu16 numPiers, i;\r\ns32 targetPowerArray[AR9300_NUM_5G_20_TARGET_POWERS];\r\ns32 freqArray[AR9300_NUM_5G_20_TARGET_POWERS];\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct cal_tgt_pow_ht *pEepromTargetPwr;\r\nu8 *pFreqBin;\r\nif (is2GHz) {\r\nnumPiers = AR9300_NUM_2G_20_TARGET_POWERS;\r\npEepromTargetPwr = eep->calTargetPower2GHT20;\r\npFreqBin = eep->calTarget_freqbin_2GHT20;\r\n} else {\r\nnumPiers = AR9300_NUM_5G_20_TARGET_POWERS;\r\npEepromTargetPwr = eep->calTargetPower5GHT20;\r\npFreqBin = eep->calTarget_freqbin_5GHT20;\r\n}\r\nfor (i = 0; i < numPiers; i++) {\r\nfreqArray[i] = ath9k_hw_fbin2freq(pFreqBin[i], is2GHz);\r\ntargetPowerArray[i] = pEepromTargetPwr[i].tPow2x[rateIndex];\r\n}\r\nreturn (u8) ar9003_hw_power_interpolate((s32) freq,\r\nfreqArray,\r\ntargetPowerArray, numPiers);\r\n}\r\nstatic u8 ar9003_hw_eeprom_get_ht40_tgt_pwr(struct ath_hw *ah,\r\nu16 rateIndex,\r\nu16 freq, bool is2GHz)\r\n{\r\nu16 numPiers, i;\r\ns32 targetPowerArray[AR9300_NUM_5G_40_TARGET_POWERS];\r\ns32 freqArray[AR9300_NUM_5G_40_TARGET_POWERS];\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct cal_tgt_pow_ht *pEepromTargetPwr;\r\nu8 *pFreqBin;\r\nif (is2GHz) {\r\nnumPiers = AR9300_NUM_2G_40_TARGET_POWERS;\r\npEepromTargetPwr = eep->calTargetPower2GHT40;\r\npFreqBin = eep->calTarget_freqbin_2GHT40;\r\n} else {\r\nnumPiers = AR9300_NUM_5G_40_TARGET_POWERS;\r\npEepromTargetPwr = eep->calTargetPower5GHT40;\r\npFreqBin = eep->calTarget_freqbin_5GHT40;\r\n}\r\nfor (i = 0; i < numPiers; i++) {\r\nfreqArray[i] = ath9k_hw_fbin2freq(pFreqBin[i], is2GHz);\r\ntargetPowerArray[i] = pEepromTargetPwr[i].tPow2x[rateIndex];\r\n}\r\nreturn (u8) ar9003_hw_power_interpolate((s32) freq,\r\nfreqArray,\r\ntargetPowerArray, numPiers);\r\n}\r\nstatic u8 ar9003_hw_eeprom_get_cck_tgt_pwr(struct ath_hw *ah,\r\nu16 rateIndex, u16 freq)\r\n{\r\nu16 numPiers = AR9300_NUM_2G_CCK_TARGET_POWERS, i;\r\ns32 targetPowerArray[AR9300_NUM_2G_CCK_TARGET_POWERS];\r\ns32 freqArray[AR9300_NUM_2G_CCK_TARGET_POWERS];\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct cal_tgt_pow_legacy *pEepromTargetPwr = eep->calTargetPowerCck;\r\nu8 *pFreqBin = eep->calTarget_freqbin_Cck;\r\nfor (i = 0; i < numPiers; i++) {\r\nfreqArray[i] = ath9k_hw_fbin2freq(pFreqBin[i], 1);\r\ntargetPowerArray[i] = pEepromTargetPwr[i].tPow2x[rateIndex];\r\n}\r\nreturn (u8) ar9003_hw_power_interpolate((s32) freq,\r\nfreqArray,\r\ntargetPowerArray, numPiers);\r\n}\r\nstatic int ar9003_hw_tx_power_regwrite(struct ath_hw *ah, u8 * pPwrArray)\r\n{\r\n#define POW_SM(_r, _s) (((_r) & 0x3f) << (_s))\r\nREG_WRITE(ah, AR_PHY_TX_FORCED_GAIN, 0);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(0),\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(1),\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_54], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_48], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_36], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(2),\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 0));\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(3),\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_11S], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_11L], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_5S], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 0)\r\n);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(8),\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_6_24], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_LEGACY_1L_5L], 0)\r\n);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(4),\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_5], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_4], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_1_3_9_11_17_19], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_0_8_16], 0)\r\n);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(5),\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_13], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_12], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_7], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_6], 0)\r\n);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(9),\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_21], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_20], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_15], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_14], 0)\r\n);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(10),\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_23], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_22], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_23], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT20_22], 0)\r\n);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(6),\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_5], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_4], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_1_3_9_11_17_19], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_0_8_16], 0)\r\n);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(7),\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_13], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_12], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_7], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_6], 0)\r\n);\r\nREG_WRITE(ah, AR_PHY_POWER_TX_RATE(11),\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_21], 24) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_20], 16) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_15], 8) |\r\nPOW_SM(pPwrArray[ALL_TARGET_HT40_14], 0)\r\n);\r\nreturn 0;\r\n#undef POW_SM\r\n}\r\nstatic void ar9003_hw_get_legacy_target_powers(struct ath_hw *ah, u16 freq,\r\nu8 *targetPowerValT2,\r\nbool is2GHz)\r\n{\r\ntargetPowerValT2[ALL_TARGET_LEGACY_6_24] =\r\nar9003_hw_eeprom_get_tgt_pwr(ah, LEGACY_TARGET_RATE_6_24, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_LEGACY_36] =\r\nar9003_hw_eeprom_get_tgt_pwr(ah, LEGACY_TARGET_RATE_36, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_LEGACY_48] =\r\nar9003_hw_eeprom_get_tgt_pwr(ah, LEGACY_TARGET_RATE_48, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_LEGACY_54] =\r\nar9003_hw_eeprom_get_tgt_pwr(ah, LEGACY_TARGET_RATE_54, freq,\r\nis2GHz);\r\n}\r\nstatic void ar9003_hw_get_cck_target_powers(struct ath_hw *ah, u16 freq,\r\nu8 *targetPowerValT2)\r\n{\r\ntargetPowerValT2[ALL_TARGET_LEGACY_1L_5L] =\r\nar9003_hw_eeprom_get_cck_tgt_pwr(ah, LEGACY_TARGET_RATE_1L_5L,\r\nfreq);\r\ntargetPowerValT2[ALL_TARGET_LEGACY_5S] =\r\nar9003_hw_eeprom_get_cck_tgt_pwr(ah, LEGACY_TARGET_RATE_5S, freq);\r\ntargetPowerValT2[ALL_TARGET_LEGACY_11L] =\r\nar9003_hw_eeprom_get_cck_tgt_pwr(ah, LEGACY_TARGET_RATE_11L, freq);\r\ntargetPowerValT2[ALL_TARGET_LEGACY_11S] =\r\nar9003_hw_eeprom_get_cck_tgt_pwr(ah, LEGACY_TARGET_RATE_11S, freq);\r\n}\r\nstatic void ar9003_hw_get_ht20_target_powers(struct ath_hw *ah, u16 freq,\r\nu8 *targetPowerValT2, bool is2GHz)\r\n{\r\ntargetPowerValT2[ALL_TARGET_HT20_0_8_16] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_0_8_16, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_1_3_9_11_17_19] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_1_3_9_11_17_19,\r\nfreq, is2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_4] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_4, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_5] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_5, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_6] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_6, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_7] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_7, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_12] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_12, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_13] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_13, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_14] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_14, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_15] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_15, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_20] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_20, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_21] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_21, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_22] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_22, freq,\r\nis2GHz);\r\ntargetPowerValT2[ALL_TARGET_HT20_23] =\r\nar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_23, freq,\r\nis2GHz);\r\n}\r\nstatic void ar9003_hw_get_ht40_target_powers(struct ath_hw *ah,\r\nu16 freq,\r\nu8 *targetPowerValT2,\r\nbool is2GHz)\r\n{\r\nu8 ht40PowerIncForPdadc = 0;\r\ntargetPowerValT2[ALL_TARGET_HT40_0_8_16] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_0_8_16, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_1_3_9_11_17_19] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_1_3_9_11_17_19,\r\nfreq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_4] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_4, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_5] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_5, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_6] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_6, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_7] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_7, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_12] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_12, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_13] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_13, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_14] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_14, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_15] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_15, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_20] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_20, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_21] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_21, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_22] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_22, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\ntargetPowerValT2[ALL_TARGET_HT40_23] =\r\nar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_23, freq,\r\nis2GHz) + ht40PowerIncForPdadc;\r\n}\r\nstatic void ar9003_hw_get_target_power_eeprom(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nu8 *targetPowerValT2)\r\n{\r\nbool is2GHz = IS_CHAN_2GHZ(chan);\r\nunsigned int i = 0;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu16 freq = chan->channel;\r\nif (is2GHz)\r\nar9003_hw_get_cck_target_powers(ah, freq, targetPowerValT2);\r\nar9003_hw_get_legacy_target_powers(ah, freq, targetPowerValT2, is2GHz);\r\nar9003_hw_get_ht20_target_powers(ah, freq, targetPowerValT2, is2GHz);\r\nif (IS_CHAN_HT40(chan))\r\nar9003_hw_get_ht40_target_powers(ah, freq, targetPowerValT2,\r\nis2GHz);\r\nfor (i = 0; i < ar9300RateSize; i++) {\r\nath_dbg(common, REGULATORY, "TPC[%02d] 0x%08x\n",\r\ni, targetPowerValT2[i]);\r\n}\r\n}\r\nstatic int ar9003_hw_cal_pier_get(struct ath_hw *ah,\r\nint mode,\r\nint ipier,\r\nint ichain,\r\nint *pfrequency,\r\nint *pcorrection,\r\nint *ptemperature, int *pvoltage)\r\n{\r\nu8 *pCalPier;\r\nstruct ar9300_cal_data_per_freq_op_loop *pCalPierStruct;\r\nint is2GHz;\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (ichain >= AR9300_MAX_CHAINS) {\r\nath_dbg(common, EEPROM,\r\n"Invalid chain index, must be less than %d\n",\r\nAR9300_MAX_CHAINS);\r\nreturn -1;\r\n}\r\nif (mode) {\r\nif (ipier >= AR9300_NUM_5G_CAL_PIERS) {\r\nath_dbg(common, EEPROM,\r\n"Invalid 5GHz cal pier index, must be less than %d\n",\r\nAR9300_NUM_5G_CAL_PIERS);\r\nreturn -1;\r\n}\r\npCalPier = &(eep->calFreqPier5G[ipier]);\r\npCalPierStruct = &(eep->calPierData5G[ichain][ipier]);\r\nis2GHz = 0;\r\n} else {\r\nif (ipier >= AR9300_NUM_2G_CAL_PIERS) {\r\nath_dbg(common, EEPROM,\r\n"Invalid 2GHz cal pier index, must be less than %d\n",\r\nAR9300_NUM_2G_CAL_PIERS);\r\nreturn -1;\r\n}\r\npCalPier = &(eep->calFreqPier2G[ipier]);\r\npCalPierStruct = &(eep->calPierData2G[ichain][ipier]);\r\nis2GHz = 1;\r\n}\r\n*pfrequency = ath9k_hw_fbin2freq(*pCalPier, is2GHz);\r\n*pcorrection = pCalPierStruct->refPower;\r\n*ptemperature = pCalPierStruct->tempMeas;\r\n*pvoltage = pCalPierStruct->voltMeas;\r\nreturn 0;\r\n}\r\nstatic void ar9003_hw_power_control_override(struct ath_hw *ah,\r\nint frequency,\r\nint *correction,\r\nint *voltage, int *temperature)\r\n{\r\nint temp_slope = 0, temp_slope1 = 0, temp_slope2 = 0;\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nint f[8], t[8], t1[3], t2[3], i;\r\nREG_RMW(ah, AR_PHY_TPC_11_B0,\r\n(correction[0] << AR_PHY_TPC_OLPC_GAIN_DELTA_S),\r\nAR_PHY_TPC_OLPC_GAIN_DELTA);\r\nif (ah->caps.tx_chainmask & BIT(1))\r\nREG_RMW(ah, AR_PHY_TPC_11_B1,\r\n(correction[1] << AR_PHY_TPC_OLPC_GAIN_DELTA_S),\r\nAR_PHY_TPC_OLPC_GAIN_DELTA);\r\nif (ah->caps.tx_chainmask & BIT(2))\r\nREG_RMW(ah, AR_PHY_TPC_11_B2,\r\n(correction[2] << AR_PHY_TPC_OLPC_GAIN_DELTA_S),\r\nAR_PHY_TPC_OLPC_GAIN_DELTA);\r\nREG_RMW(ah, AR_PHY_TPC_6_B0,\r\n(3 << AR_PHY_TPC_6_ERROR_EST_MODE_S),\r\nAR_PHY_TPC_6_ERROR_EST_MODE);\r\nif (ah->caps.tx_chainmask & BIT(1))\r\nREG_RMW(ah, AR_PHY_TPC_6_B1,\r\n(3 << AR_PHY_TPC_6_ERROR_EST_MODE_S),\r\nAR_PHY_TPC_6_ERROR_EST_MODE);\r\nif (ah->caps.tx_chainmask & BIT(2))\r\nREG_RMW(ah, AR_PHY_TPC_6_B2,\r\n(3 << AR_PHY_TPC_6_ERROR_EST_MODE_S),\r\nAR_PHY_TPC_6_ERROR_EST_MODE);\r\nif (frequency < 4000) {\r\ntemp_slope = eep->modalHeader2G.tempSlope;\r\n} else {\r\nif (AR_SREV_9550(ah)) {\r\nt[0] = eep->base_ext1.tempslopextension[2];\r\nt1[0] = eep->base_ext1.tempslopextension[3];\r\nt2[0] = eep->base_ext1.tempslopextension[4];\r\nf[0] = 5180;\r\nt[1] = eep->modalHeader5G.tempSlope;\r\nt1[1] = eep->base_ext1.tempslopextension[0];\r\nt2[1] = eep->base_ext1.tempslopextension[1];\r\nf[1] = 5500;\r\nt[2] = eep->base_ext1.tempslopextension[5];\r\nt1[2] = eep->base_ext1.tempslopextension[6];\r\nt2[2] = eep->base_ext1.tempslopextension[7];\r\nf[2] = 5785;\r\ntemp_slope = ar9003_hw_power_interpolate(frequency,\r\nf, t, 3);\r\ntemp_slope1 = ar9003_hw_power_interpolate(frequency,\r\nf, t1, 3);\r\ntemp_slope2 = ar9003_hw_power_interpolate(frequency,\r\nf, t2, 3);\r\ngoto tempslope;\r\n}\r\nif ((eep->baseEepHeader.miscConfiguration & 0x20) != 0) {\r\nfor (i = 0; i < 8; i++) {\r\nt[i] = eep->base_ext1.tempslopextension[i];\r\nf[i] = FBIN2FREQ(eep->calFreqPier5G[i], 0);\r\n}\r\ntemp_slope = ar9003_hw_power_interpolate((s32) frequency,\r\nf, t, 8);\r\n} else if (eep->base_ext2.tempSlopeLow != 0) {\r\nt[0] = eep->base_ext2.tempSlopeLow;\r\nf[0] = 5180;\r\nt[1] = eep->modalHeader5G.tempSlope;\r\nf[1] = 5500;\r\nt[2] = eep->base_ext2.tempSlopeHigh;\r\nf[2] = 5785;\r\ntemp_slope = ar9003_hw_power_interpolate((s32) frequency,\r\nf, t, 3);\r\n} else {\r\ntemp_slope = eep->modalHeader5G.tempSlope;\r\n}\r\n}\r\ntempslope:\r\nif (AR_SREV_9550(ah) || AR_SREV_9531(ah)) {\r\nu8 txmask = (eep->baseEepHeader.txrxMask & 0xf0) >> 4;\r\nif (eep->baseEepHeader.featureEnable & 0x1) {\r\nif (frequency < 4000) {\r\nif (txmask & BIT(0))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19,\r\nAR_PHY_TPC_19_ALPHA_THERM,\r\neep->base_ext2.tempSlopeLow);\r\nif (txmask & BIT(1))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,\r\nAR_PHY_TPC_19_ALPHA_THERM,\r\ntemp_slope);\r\nif (txmask & BIT(2))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,\r\nAR_PHY_TPC_19_ALPHA_THERM,\r\neep->base_ext2.tempSlopeHigh);\r\n} else {\r\nif (txmask & BIT(0))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19,\r\nAR_PHY_TPC_19_ALPHA_THERM,\r\ntemp_slope);\r\nif (txmask & BIT(1))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,\r\nAR_PHY_TPC_19_ALPHA_THERM,\r\ntemp_slope1);\r\nif (txmask & BIT(2))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,\r\nAR_PHY_TPC_19_ALPHA_THERM,\r\ntemp_slope2);\r\n}\r\n} else {\r\nif (txmask & BIT(0))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19,\r\nAR_PHY_TPC_19_ALPHA_THERM, 0);\r\nif (txmask & BIT(1))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,\r\nAR_PHY_TPC_19_ALPHA_THERM, 0);\r\nif (txmask & BIT(2))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19_B2,\r\nAR_PHY_TPC_19_ALPHA_THERM, 0);\r\n}\r\n} else {\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19,\r\nAR_PHY_TPC_19_ALPHA_THERM, temp_slope);\r\n}\r\nif (AR_SREV_9462_20_OR_LATER(ah))\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_19_B1,\r\nAR_PHY_TPC_19_B1_ALPHA_THERM, temp_slope);\r\nREG_RMW_FIELD(ah, AR_PHY_TPC_18, AR_PHY_TPC_18_THERM_CAL_VALUE,\r\ntemperature[0]);\r\n}\r\nstatic int ar9003_hw_calibration_apply(struct ath_hw *ah, int frequency)\r\n{\r\nint ichain, ipier, npier;\r\nint mode;\r\nint lfrequency[AR9300_MAX_CHAINS],\r\nlcorrection[AR9300_MAX_CHAINS],\r\nltemperature[AR9300_MAX_CHAINS], lvoltage[AR9300_MAX_CHAINS];\r\nint hfrequency[AR9300_MAX_CHAINS],\r\nhcorrection[AR9300_MAX_CHAINS],\r\nhtemperature[AR9300_MAX_CHAINS], hvoltage[AR9300_MAX_CHAINS];\r\nint fdiff;\r\nint correction[AR9300_MAX_CHAINS],\r\nvoltage[AR9300_MAX_CHAINS], temperature[AR9300_MAX_CHAINS];\r\nint pfrequency, pcorrection, ptemperature, pvoltage;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nmode = (frequency >= 4000);\r\nif (mode)\r\nnpier = AR9300_NUM_5G_CAL_PIERS;\r\nelse\r\nnpier = AR9300_NUM_2G_CAL_PIERS;\r\nfor (ichain = 0; ichain < AR9300_MAX_CHAINS; ichain++) {\r\nlfrequency[ichain] = 0;\r\nhfrequency[ichain] = 100000;\r\n}\r\nfor (ichain = 0; ichain < AR9300_MAX_CHAINS; ichain++) {\r\nfor (ipier = 0; ipier < npier; ipier++) {\r\nif (!ar9003_hw_cal_pier_get(ah, mode, ipier, ichain,\r\n&pfrequency, &pcorrection,\r\n&ptemperature, &pvoltage)) {\r\nfdiff = frequency - pfrequency;\r\nif (fdiff <= 0) {\r\nif (hfrequency[ichain] <= 0 ||\r\nhfrequency[ichain] >= 100000 ||\r\nfdiff >\r\n(frequency - hfrequency[ichain])) {\r\nhfrequency[ichain] = pfrequency;\r\nhcorrection[ichain] =\r\npcorrection;\r\nhtemperature[ichain] =\r\nptemperature;\r\nhvoltage[ichain] = pvoltage;\r\n}\r\n}\r\nif (fdiff >= 0) {\r\nif (lfrequency[ichain] <= 0\r\n|| fdiff <\r\n(frequency - lfrequency[ichain])) {\r\nlfrequency[ichain] = pfrequency;\r\nlcorrection[ichain] =\r\npcorrection;\r\nltemperature[ichain] =\r\nptemperature;\r\nlvoltage[ichain] = pvoltage;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nfor (ichain = 0; ichain < AR9300_MAX_CHAINS; ichain++) {\r\nath_dbg(common, EEPROM, "ch=%d f=%d low=%d %d h=%d %d\n",\r\nichain, frequency, lfrequency[ichain],\r\nlcorrection[ichain], hfrequency[ichain],\r\nhcorrection[ichain]);\r\nif (hfrequency[ichain] == lfrequency[ichain]) {\r\ncorrection[ichain] = lcorrection[ichain];\r\nvoltage[ichain] = lvoltage[ichain];\r\ntemperature[ichain] = ltemperature[ichain];\r\n}\r\nelse if (frequency - lfrequency[ichain] < 1000) {\r\nif (hfrequency[ichain] - frequency < 1000) {\r\ncorrection[ichain] = interpolate(frequency,\r\nlfrequency[ichain],\r\nhfrequency[ichain],\r\nlcorrection[ichain],\r\nhcorrection[ichain]);\r\ntemperature[ichain] = interpolate(frequency,\r\nlfrequency[ichain],\r\nhfrequency[ichain],\r\nltemperature[ichain],\r\nhtemperature[ichain]);\r\nvoltage[ichain] = interpolate(frequency,\r\nlfrequency[ichain],\r\nhfrequency[ichain],\r\nlvoltage[ichain],\r\nhvoltage[ichain]);\r\n}\r\nelse {\r\ncorrection[ichain] = lcorrection[ichain];\r\ntemperature[ichain] = ltemperature[ichain];\r\nvoltage[ichain] = lvoltage[ichain];\r\n}\r\n}\r\nelse if (hfrequency[ichain] - frequency < 1000) {\r\ncorrection[ichain] = hcorrection[ichain];\r\ntemperature[ichain] = htemperature[ichain];\r\nvoltage[ichain] = hvoltage[ichain];\r\n} else {\r\ncorrection[ichain] = 0;\r\ntemperature[ichain] = 0;\r\nvoltage[ichain] = 0;\r\n}\r\n}\r\nar9003_hw_power_control_override(ah, frequency, correction, voltage,\r\ntemperature);\r\nath_dbg(common, EEPROM,\r\n"for frequency=%d, calibration correction = %d %d %d\n",\r\nfrequency, correction[0], correction[1], correction[2]);\r\nreturn 0;\r\n}\r\nstatic u16 ar9003_hw_get_direct_edge_power(struct ar9300_eeprom *eep,\r\nint idx,\r\nint edge,\r\nbool is2GHz)\r\n{\r\nstruct cal_ctl_data_2g *ctl_2g = eep->ctlPowerData_2G;\r\nstruct cal_ctl_data_5g *ctl_5g = eep->ctlPowerData_5G;\r\nif (is2GHz)\r\nreturn CTL_EDGE_TPOWER(ctl_2g[idx].ctlEdges[edge]);\r\nelse\r\nreturn CTL_EDGE_TPOWER(ctl_5g[idx].ctlEdges[edge]);\r\n}\r\nstatic u16 ar9003_hw_get_indirect_edge_power(struct ar9300_eeprom *eep,\r\nint idx,\r\nunsigned int edge,\r\nu16 freq,\r\nbool is2GHz)\r\n{\r\nstruct cal_ctl_data_2g *ctl_2g = eep->ctlPowerData_2G;\r\nstruct cal_ctl_data_5g *ctl_5g = eep->ctlPowerData_5G;\r\nu8 *ctl_freqbin = is2GHz ?\r\n&eep->ctl_freqbin_2G[idx][0] :\r\n&eep->ctl_freqbin_5G[idx][0];\r\nif (is2GHz) {\r\nif (ath9k_hw_fbin2freq(ctl_freqbin[edge - 1], 1) < freq &&\r\nCTL_EDGE_FLAGS(ctl_2g[idx].ctlEdges[edge - 1]))\r\nreturn CTL_EDGE_TPOWER(ctl_2g[idx].ctlEdges[edge - 1]);\r\n} else {\r\nif (ath9k_hw_fbin2freq(ctl_freqbin[edge - 1], 0) < freq &&\r\nCTL_EDGE_FLAGS(ctl_5g[idx].ctlEdges[edge - 1]))\r\nreturn CTL_EDGE_TPOWER(ctl_5g[idx].ctlEdges[edge - 1]);\r\n}\r\nreturn MAX_RATE_POWER;\r\n}\r\nstatic u16 ar9003_hw_get_max_edge_power(struct ar9300_eeprom *eep,\r\nu16 freq, int idx, bool is2GHz)\r\n{\r\nu16 twiceMaxEdgePower = MAX_RATE_POWER;\r\nu8 *ctl_freqbin = is2GHz ?\r\n&eep->ctl_freqbin_2G[idx][0] :\r\n&eep->ctl_freqbin_5G[idx][0];\r\nu16 num_edges = is2GHz ?\r\nAR9300_NUM_BAND_EDGES_2G : AR9300_NUM_BAND_EDGES_5G;\r\nunsigned int edge;\r\nfor (edge = 0;\r\n(edge < num_edges) && (ctl_freqbin[edge] != AR5416_BCHAN_UNUSED);\r\nedge++) {\r\nif (freq == ath9k_hw_fbin2freq(ctl_freqbin[edge], is2GHz)) {\r\ntwiceMaxEdgePower =\r\nar9003_hw_get_direct_edge_power(eep, idx,\r\nedge, is2GHz);\r\nbreak;\r\n} else if ((edge > 0) &&\r\n(freq < ath9k_hw_fbin2freq(ctl_freqbin[edge],\r\nis2GHz))) {\r\ntwiceMaxEdgePower =\r\nar9003_hw_get_indirect_edge_power(eep, idx,\r\nedge, freq,\r\nis2GHz);\r\nbreak;\r\n}\r\n}\r\nif (is2GHz && !twiceMaxEdgePower)\r\ntwiceMaxEdgePower = 60;\r\nreturn twiceMaxEdgePower;\r\n}\r\nstatic void ar9003_hw_set_power_per_rate_table(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nu8 *pPwrArray, u16 cfgCtl,\r\nu8 antenna_reduction,\r\nu16 powerLimit)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ar9300_eeprom *pEepData = &ah->eeprom.ar9300_eep;\r\nu16 twiceMaxEdgePower;\r\nint i;\r\nu16 scaledPower = 0, minCtlPower;\r\nstatic const u16 ctlModesFor11a[] = {\r\nCTL_11A, CTL_5GHT20, CTL_11A_EXT, CTL_5GHT40\r\n};\r\nstatic const u16 ctlModesFor11g[] = {\r\nCTL_11B, CTL_11G, CTL_2GHT20, CTL_11B_EXT,\r\nCTL_11G_EXT, CTL_2GHT40\r\n};\r\nu16 numCtlModes;\r\nconst u16 *pCtlMode;\r\nu16 ctlMode, freq;\r\nstruct chan_centers centers;\r\nu8 *ctlIndex;\r\nu8 ctlNum;\r\nu16 twiceMinEdgePower;\r\nbool is2ghz = IS_CHAN_2GHZ(chan);\r\nath9k_hw_get_channel_centers(ah, chan, &centers);\r\nscaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,\r\nantenna_reduction);\r\nif (is2ghz) {\r\nnumCtlModes =\r\nARRAY_SIZE(ctlModesFor11g) -\r\nSUB_NUM_CTL_MODES_AT_2G_40;\r\npCtlMode = ctlModesFor11g;\r\nif (IS_CHAN_HT40(chan))\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11g);\r\n} else {\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11a) -\r\nSUB_NUM_CTL_MODES_AT_5G_40;\r\npCtlMode = ctlModesFor11a;\r\nif (IS_CHAN_HT40(chan))\r\nnumCtlModes = ARRAY_SIZE(ctlModesFor11a);\r\n}\r\nfor (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {\r\nbool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||\r\n(pCtlMode[ctlMode] == CTL_2GHT40);\r\nif (isHt40CtlMode)\r\nfreq = centers.synth_center;\r\nelse if (pCtlMode[ctlMode] & EXT_ADDITIVE)\r\nfreq = centers.ext_center;\r\nelse\r\nfreq = centers.ctl_center;\r\nath_dbg(common, REGULATORY,\r\n"LOOP-Mode ctlMode %d < %d, isHt40CtlMode %d, EXT_ADDITIVE %d\n",\r\nctlMode, numCtlModes, isHt40CtlMode,\r\n(pCtlMode[ctlMode] & EXT_ADDITIVE));\r\nif (is2ghz) {\r\nctlIndex = pEepData->ctlIndex_2G;\r\nctlNum = AR9300_NUM_CTLS_2G;\r\n} else {\r\nctlIndex = pEepData->ctlIndex_5G;\r\nctlNum = AR9300_NUM_CTLS_5G;\r\n}\r\ntwiceMaxEdgePower = MAX_RATE_POWER;\r\nfor (i = 0; (i < ctlNum) && ctlIndex[i]; i++) {\r\nath_dbg(common, REGULATORY,\r\n"LOOP-Ctlidx %d: cfgCtl 0x%2.2x pCtlMode 0x%2.2x ctlIndex 0x%2.2x chan %d\n",\r\ni, cfgCtl, pCtlMode[ctlMode], ctlIndex[i],\r\nchan->channel);\r\nif ((((cfgCtl & ~CTL_MODE_M) |\r\n(pCtlMode[ctlMode] & CTL_MODE_M)) ==\r\nctlIndex[i]) ||\r\n(((cfgCtl & ~CTL_MODE_M) |\r\n(pCtlMode[ctlMode] & CTL_MODE_M)) ==\r\n((ctlIndex[i] & CTL_MODE_M) |\r\nSD_NO_CTL))) {\r\ntwiceMinEdgePower =\r\nar9003_hw_get_max_edge_power(pEepData,\r\nfreq, i,\r\nis2ghz);\r\nif ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL)\r\ntwiceMaxEdgePower =\r\nmin(twiceMaxEdgePower,\r\ntwiceMinEdgePower);\r\nelse {\r\ntwiceMaxEdgePower = twiceMinEdgePower;\r\nbreak;\r\n}\r\n}\r\n}\r\nminCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);\r\nath_dbg(common, REGULATORY,\r\n"SEL-Min ctlMode %d pCtlMode %d 2xMaxEdge %d sP %d minCtlPwr %d\n",\r\nctlMode, pCtlMode[ctlMode], twiceMaxEdgePower,\r\nscaledPower, minCtlPower);\r\nswitch (pCtlMode[ctlMode]) {\r\ncase CTL_11B:\r\nfor (i = ALL_TARGET_LEGACY_1L_5L;\r\ni <= ALL_TARGET_LEGACY_11S; i++)\r\npPwrArray[i] = (u8)min((u16)pPwrArray[i],\r\nminCtlPower);\r\nbreak;\r\ncase CTL_11A:\r\ncase CTL_11G:\r\nfor (i = ALL_TARGET_LEGACY_6_24;\r\ni <= ALL_TARGET_LEGACY_54; i++)\r\npPwrArray[i] = (u8)min((u16)pPwrArray[i],\r\nminCtlPower);\r\nbreak;\r\ncase CTL_5GHT20:\r\ncase CTL_2GHT20:\r\nfor (i = ALL_TARGET_HT20_0_8_16;\r\ni <= ALL_TARGET_HT20_23; i++) {\r\npPwrArray[i] = (u8)min((u16)pPwrArray[i],\r\nminCtlPower);\r\nif (ath9k_hw_mci_is_enabled(ah))\r\npPwrArray[i] =\r\n(u8)min((u16)pPwrArray[i],\r\nar9003_mci_get_max_txpower(ah,\r\npCtlMode[ctlMode]));\r\n}\r\nbreak;\r\ncase CTL_5GHT40:\r\ncase CTL_2GHT40:\r\nfor (i = ALL_TARGET_HT40_0_8_16;\r\ni <= ALL_TARGET_HT40_23; i++) {\r\npPwrArray[i] = (u8)min((u16)pPwrArray[i],\r\nminCtlPower);\r\nif (ath9k_hw_mci_is_enabled(ah))\r\npPwrArray[i] =\r\n(u8)min((u16)pPwrArray[i],\r\nar9003_mci_get_max_txpower(ah,\r\npCtlMode[ctlMode]));\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic inline u8 mcsidx_to_tgtpwridx(unsigned int mcs_idx, u8 base_pwridx)\r\n{\r\nu8 mod_idx = mcs_idx % 8;\r\nif (mod_idx <= 3)\r\nreturn mod_idx ? (base_pwridx + 1) : base_pwridx;\r\nelse\r\nreturn base_pwridx + 4 * (mcs_idx / 8) + mod_idx - 2;\r\n}\r\nstatic void ar9003_paprd_set_txpower(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nu8 *targetPowerValT2)\r\n{\r\nint i;\r\nif (!ar9003_is_paprd_enabled(ah))\r\nreturn;\r\nif (IS_CHAN_HT40(chan))\r\ni = ALL_TARGET_HT40_7;\r\nelse\r\ni = ALL_TARGET_HT20_7;\r\nif (IS_CHAN_2GHZ(chan)) {\r\nif (!AR_SREV_9330(ah) && !AR_SREV_9340(ah) &&\r\n!AR_SREV_9462(ah) && !AR_SREV_9565(ah)) {\r\nif (IS_CHAN_HT40(chan))\r\ni = ALL_TARGET_HT40_0_8_16;\r\nelse\r\ni = ALL_TARGET_HT20_0_8_16;\r\n}\r\n}\r\nah->paprd_target_power = targetPowerValT2[i];\r\n}\r\nstatic void ath9k_hw_ar9300_set_txpower(struct ath_hw *ah,\r\nstruct ath9k_channel *chan, u16 cfgCtl,\r\nu8 twiceAntennaReduction,\r\nu8 powerLimit, bool test)\r\n{\r\nstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nstruct ar9300_modal_eep_header *modal_hdr;\r\nu8 targetPowerValT2[ar9300RateSize];\r\nu8 target_power_val_t2_eep[ar9300RateSize];\r\nunsigned int i = 0, paprd_scale_factor = 0;\r\nu8 pwr_idx, min_pwridx = 0;\r\nmemset(targetPowerValT2, 0 , sizeof(targetPowerValT2));\r\nar9003_hw_get_target_power_eeprom(ah, chan, targetPowerValT2);\r\nif (ar9003_is_paprd_enabled(ah)) {\r\nif (IS_CHAN_2GHZ(chan))\r\nmodal_hdr = &eep->modalHeader2G;\r\nelse\r\nmodal_hdr = &eep->modalHeader5G;\r\nah->paprd_ratemask =\r\nle32_to_cpu(modal_hdr->papdRateMaskHt20) &\r\nAR9300_PAPRD_RATE_MASK;\r\nah->paprd_ratemask_ht40 =\r\nle32_to_cpu(modal_hdr->papdRateMaskHt40) &\r\nAR9300_PAPRD_RATE_MASK;\r\npaprd_scale_factor = ar9003_get_paprd_scale_factor(ah, chan);\r\nmin_pwridx = IS_CHAN_HT40(chan) ? ALL_TARGET_HT40_0_8_16 :\r\nALL_TARGET_HT20_0_8_16;\r\nif (!ah->paprd_table_write_done) {\r\nmemcpy(target_power_val_t2_eep, targetPowerValT2,\r\nsizeof(targetPowerValT2));\r\nfor (i = 0; i < 24; i++) {\r\npwr_idx = mcsidx_to_tgtpwridx(i, min_pwridx);\r\nif (ah->paprd_ratemask & (1 << i)) {\r\nif (targetPowerValT2[pwr_idx] &&\r\ntargetPowerValT2[pwr_idx] ==\r\ntarget_power_val_t2_eep[pwr_idx])\r\ntargetPowerValT2[pwr_idx] -=\r\npaprd_scale_factor;\r\n}\r\n}\r\n}\r\nmemcpy(target_power_val_t2_eep, targetPowerValT2,\r\nsizeof(targetPowerValT2));\r\n}\r\nar9003_hw_set_power_per_rate_table(ah, chan,\r\ntargetPowerValT2, cfgCtl,\r\ntwiceAntennaReduction,\r\npowerLimit);\r\nif (ar9003_is_paprd_enabled(ah)) {\r\nfor (i = 0; i < ar9300RateSize; i++) {\r\nif ((ah->paprd_ratemask & (1 << i)) &&\r\n(abs(targetPowerValT2[i] -\r\ntarget_power_val_t2_eep[i]) >\r\npaprd_scale_factor)) {\r\nah->paprd_ratemask &= ~(1 << i);\r\nath_dbg(common, EEPROM,\r\n"paprd disabled for mcs %d\n", i);\r\n}\r\n}\r\n}\r\nregulatory->max_power_level = 0;\r\nfor (i = 0; i < ar9300RateSize; i++) {\r\nif (targetPowerValT2[i] > regulatory->max_power_level)\r\nregulatory->max_power_level = targetPowerValT2[i];\r\n}\r\nath9k_hw_update_regulatory_maxpower(ah);\r\nif (test)\r\nreturn;\r\nfor (i = 0; i < ar9300RateSize; i++) {\r\nath_dbg(common, REGULATORY, "TPC[%02d] 0x%08x\n",\r\ni, targetPowerValT2[i]);\r\n}\r\nar9003_hw_tx_power_regwrite(ah, targetPowerValT2);\r\nar9003_hw_calibration_apply(ah, chan->channel);\r\nar9003_paprd_set_txpower(ah, chan, targetPowerValT2);\r\n}\r\nstatic u16 ath9k_hw_ar9300_get_spur_channel(struct ath_hw *ah,\r\nu16 i, bool is2GHz)\r\n{\r\nreturn AR_NO_SPUR;\r\n}\r\ns32 ar9003_hw_get_tx_gain_idx(struct ath_hw *ah)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nreturn (eep->baseEepHeader.txrxgain >> 4) & 0xf;\r\n}\r\ns32 ar9003_hw_get_rx_gain_idx(struct ath_hw *ah)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nreturn (eep->baseEepHeader.txrxgain) & 0xf;\r\n}\r\nu8 *ar9003_get_spur_chan_ptr(struct ath_hw *ah, bool is2ghz)\r\n{\r\nreturn ar9003_modal_header(ah, is2ghz)->spurChans;\r\n}\r\nunsigned int ar9003_get_paprd_scale_factor(struct ath_hw *ah,\r\nstruct ath9k_channel *chan)\r\n{\r\nstruct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;\r\nif (IS_CHAN_2GHZ(chan))\r\nreturn MS(le32_to_cpu(eep->modalHeader2G.papdRateMaskHt20),\r\nAR9300_PAPRD_SCALE_1);\r\nelse {\r\nif (chan->channel >= 5700)\r\nreturn MS(le32_to_cpu(eep->modalHeader5G.papdRateMaskHt20),\r\nAR9300_PAPRD_SCALE_1);\r\nelse if (chan->channel >= 5400)\r\nreturn MS(le32_to_cpu(eep->modalHeader5G.papdRateMaskHt40),\r\nAR9300_PAPRD_SCALE_2);\r\nelse\r\nreturn MS(le32_to_cpu(eep->modalHeader5G.papdRateMaskHt40),\r\nAR9300_PAPRD_SCALE_1);\r\n}\r\n}
