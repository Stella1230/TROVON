static void __init octeon_wdt_build_stage1(void)\r\n{\r\nint i;\r\nint len;\r\nu32 *p = nmi_stage1_insns;\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nstruct uasm_label *l = labels;\r\nstruct uasm_reloc *r = relocs;\r\n#endif\r\nuasm_i_dmtc0(&p, K0, C0_DESAVE);\r\nuasm_i_mfc0(&p, K0, C0_STATUS);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nif (octeon_bootloader_entry_addr)\r\nuasm_il_bbit0(&p, &r, K0, ilog2(ST0_NMI),\r\nlabel_enter_bootloader);\r\n#endif\r\nuasm_i_ori(&p, K0, K0, ST0_UX | ST0_SX | ST0_KX);\r\nuasm_i_mtc0(&p, K0, C0_STATUS);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nif (octeon_bootloader_entry_addr) {\r\nuasm_i_mfc0(&p, K0, C0_EBASE);\r\nuasm_i_andi(&p, K0, K0, 0xf);\r\nuasm_i_dsll_safe(&p, K0, K0, 3 + 16);\r\nuasm_i_ori(&p, K0, K0, 0x8001);\r\nuasm_i_dsll_safe(&p, K0, K0, 16);\r\nuasm_i_ori(&p, K0, K0, 0x0700);\r\nuasm_i_drotr_safe(&p, K0, K0, 32);\r\nuasm_i_ld(&p, K0, 0x500, K0);\r\nuasm_il_bbit0(&p, &r, K0, 1, label_enter_bootloader);\r\nuasm_i_nop(&p);\r\n}\r\n#endif\r\nuasm_i_cache(&p, 1, 0, 0);\r\nuasm_i_dmfc0(&p, K0, C0_CVMMEMCTL);\r\nuasm_i_dins(&p, K0, 0, 0, 6);\r\nuasm_i_ori(&p, K0, K0, 0x1c0 | 54);\r\nuasm_i_dmtc0(&p, K0, C0_CVMMEMCTL);\r\nUASM_i_LA(&p, K0, (long)octeon_wdt_nmi_stage2);\r\nuasm_i_jr(&p, K0);\r\nuasm_i_dmfc0(&p, K0, C0_DESAVE);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nif (octeon_bootloader_entry_addr) {\r\nuasm_build_label(&l, p, label_enter_bootloader);\r\nUASM_i_LA(&p, K0, (long)octeon_bootloader_entry_addr);\r\nuasm_i_jr(&p, K0);\r\nuasm_i_dmfc0(&p, K0, C0_DESAVE);\r\n}\r\n#endif\r\nuasm_resolve_relocs(relocs, labels);\r\nlen = (int)(p - nmi_stage1_insns);\r\npr_debug("Synthesized NMI stage 1 handler (%d instructions)\n", len);\r\npr_debug("\t.set push\n");\r\npr_debug("\t.set noreorder\n");\r\nfor (i = 0; i < len; i++)\r\npr_debug("\t.word 0x%08x\n", nmi_stage1_insns[i]);\r\npr_debug("\t.set pop\n");\r\nif (len > 32)\r\npanic("NMI stage 1 handler exceeds 32 instructions, was %d\n", len);\r\n}\r\nstatic int cpu2core(int cpu)\r\n{\r\n#ifdef CONFIG_SMP\r\nreturn cpu_logical_map(cpu);\r\n#else\r\nreturn cvmx_get_core_num();\r\n#endif\r\n}\r\nstatic int core2cpu(int coreid)\r\n{\r\n#ifdef CONFIG_SMP\r\nreturn cpu_number_map(coreid);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic irqreturn_t octeon_wdt_poke_irq(int cpl, void *dev_id)\r\n{\r\nunsigned int core = cvmx_get_core_num();\r\nint cpu = core2cpu(core);\r\nif (do_coundown) {\r\nif (per_cpu_countdown[cpu] > 0) {\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);\r\nper_cpu_countdown[cpu]--;\r\n} else {\r\ndisable_irq_nosync(cpl);\r\ncpumask_clear_cpu(cpu, &irq_enabled_cpus);\r\n}\r\n} else {\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void octeon_wdt_write_string(const char *str)\r\n{\r\nwhile (*str)\r\nprom_putchar(*str++);\r\n}\r\nstatic void octeon_wdt_write_hex(u64 value, int digits)\r\n{\r\nint d;\r\nint v;\r\nfor (d = 0; d < digits; d++) {\r\nv = (value >> ((digits - d - 1) * 4)) & 0xf;\r\nif (v >= 10)\r\nprom_putchar('a' + v - 10);\r\nelse\r\nprom_putchar('0' + v);\r\n}\r\n}\r\nvoid octeon_wdt_nmi_stage3(u64 reg[32])\r\n{\r\nu64 i;\r\nunsigned int coreid = cvmx_get_core_num();\r\nu64 cp0_cause = read_c0_cause();\r\nu64 cp0_status = read_c0_status();\r\nu64 cp0_error_epc = read_c0_errorepc();\r\nu64 cp0_epc = read_c0_epc();\r\n__delay(100000000ull * coreid);\r\nocteon_wdt_write_string("\r\n*** NMI Watchdog interrupt on Core 0x");\r\nocteon_wdt_write_hex(coreid, 1);\r\nocteon_wdt_write_string(" ***\r\n");\r\nfor (i = 0; i < 32; i++) {\r\nocteon_wdt_write_string("\t");\r\nocteon_wdt_write_string(reg_name[i]);\r\nocteon_wdt_write_string("\t0x");\r\nocteon_wdt_write_hex(reg[i], 16);\r\nif (i & 1)\r\nocteon_wdt_write_string("\r\n");\r\n}\r\nocteon_wdt_write_string("\terr_epc\t0x");\r\nocteon_wdt_write_hex(cp0_error_epc, 16);\r\nocteon_wdt_write_string("\tepc\t0x");\r\nocteon_wdt_write_hex(cp0_epc, 16);\r\nocteon_wdt_write_string("\r\n");\r\nocteon_wdt_write_string("\tstatus\t0x");\r\nocteon_wdt_write_hex(cp0_status, 16);\r\nocteon_wdt_write_string("\tcause\t0x");\r\nocteon_wdt_write_hex(cp0_cause, 16);\r\nocteon_wdt_write_string("\r\n");\r\nocteon_wdt_write_string("\tsum0\t0x");\r\nocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU_INTX_SUM0(coreid * 2)), 16);\r\nocteon_wdt_write_string("\ten0\t0x");\r\nocteon_wdt_write_hex(cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2)), 16);\r\nocteon_wdt_write_string("\r\n");\r\nocteon_wdt_write_string("*** Chip soft reset soon ***\r\n");\r\n}\r\nstatic void octeon_wdt_disable_interrupt(int cpu)\r\n{\r\nunsigned int core;\r\nunsigned int irq;\r\nunion cvmx_ciu_wdogx ciu_wdog;\r\ncore = cpu2core(cpu);\r\nirq = OCTEON_IRQ_WDOG0 + core;\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);\r\nciu_wdog.u64 = 0;\r\ncvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);\r\nfree_irq(irq, octeon_wdt_poke_irq);\r\n}\r\nstatic void octeon_wdt_setup_interrupt(int cpu)\r\n{\r\nunsigned int core;\r\nunsigned int irq;\r\nunion cvmx_ciu_wdogx ciu_wdog;\r\ncore = cpu2core(cpu);\r\nciu_wdog.u64 = 0;\r\ncvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);\r\nper_cpu_countdown[cpu] = countdown_reset;\r\nirq = OCTEON_IRQ_WDOG0 + core;\r\nif (request_irq(irq, octeon_wdt_poke_irq,\r\nIRQF_NO_THREAD, "octeon_wdt", octeon_wdt_poke_irq))\r\npanic("octeon_wdt: Couldn't obtain irq %d", irq);\r\ncpumask_set_cpu(cpu, &irq_enabled_cpus);\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(core), 1);\r\nciu_wdog.u64 = 0;\r\nciu_wdog.s.len = timeout_cnt;\r\nciu_wdog.s.mode = 3;\r\ncvmx_write_csr(CVMX_CIU_WDOGX(core), ciu_wdog.u64);\r\n}\r\nstatic int octeon_wdt_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nswitch (action) {\r\ncase CPU_DOWN_PREPARE:\r\nocteon_wdt_disable_interrupt(cpu);\r\nbreak;\r\ncase CPU_ONLINE:\r\ncase CPU_DOWN_FAILED:\r\nocteon_wdt_setup_interrupt(cpu);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void octeon_wdt_ping(void)\r\n{\r\nint cpu;\r\nint coreid;\r\nfor_each_online_cpu(cpu) {\r\ncoreid = cpu2core(cpu);\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);\r\nper_cpu_countdown[cpu] = countdown_reset;\r\nif ((countdown_reset || !do_coundown) &&\r\n!cpumask_test_cpu(cpu, &irq_enabled_cpus)) {\r\nint irq = OCTEON_IRQ_WDOG0 + coreid;\r\nenable_irq(irq);\r\ncpumask_set_cpu(cpu, &irq_enabled_cpus);\r\n}\r\n}\r\n}\r\nstatic void octeon_wdt_calc_parameters(int t)\r\n{\r\nunsigned int periods;\r\ntimeout_sec = max_timeout_sec;\r\nwhile ((t % timeout_sec) != 0)\r\ntimeout_sec--;\r\nperiods = t / timeout_sec;\r\ncountdown_reset = periods > 2 ? periods - 2 : 0;\r\nheartbeat = t;\r\ntimeout_cnt = ((octeon_get_io_clock_rate() >> 8) * timeout_sec) >> 8;\r\n}\r\nstatic int octeon_wdt_set_heartbeat(int t)\r\n{\r\nint cpu;\r\nint coreid;\r\nunion cvmx_ciu_wdogx ciu_wdog;\r\nif (t <= 0)\r\nreturn -1;\r\nocteon_wdt_calc_parameters(t);\r\nfor_each_online_cpu(cpu) {\r\ncoreid = cpu2core(cpu);\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);\r\nciu_wdog.u64 = 0;\r\nciu_wdog.s.len = timeout_cnt;\r\nciu_wdog.s.mode = 3;\r\ncvmx_write_csr(CVMX_CIU_WDOGX(coreid), ciu_wdog.u64);\r\ncvmx_write_csr(CVMX_CIU_PP_POKEX(coreid), 1);\r\n}\r\nocteon_wdt_ping();\r\nreturn 0;\r\n}\r\nstatic ssize_t octeon_wdt_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 1;\r\n}\r\n}\r\nocteon_wdt_ping();\r\n}\r\nreturn count;\r\n}\r\nstatic long octeon_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint new_heartbeat;\r\nstatic struct watchdog_info ident = {\r\n.options = WDIOF_SETTIMEOUT|\r\nWDIOF_MAGICCLOSE|\r\nWDIOF_KEEPALIVEPING,\r\n.firmware_version = 1,\r\n.identity = "OCTEON",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nocteon_wdt_ping();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_heartbeat, p))\r\nreturn -EFAULT;\r\nif (octeon_wdt_set_heartbeat(new_heartbeat))\r\nreturn -EINVAL;\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int octeon_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &octeon_wdt_is_open))\r\nreturn -EBUSY;\r\nocteon_wdt_ping();\r\ndo_coundown = 1;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int octeon_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close) {\r\ndo_coundown = 0;\r\nocteon_wdt_ping();\r\n} else {\r\npr_crit("WDT device closed unexpectedly. WDT will not stop!\n");\r\n}\r\nclear_bit(0, &octeon_wdt_is_open);\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int __init octeon_wdt_init(void)\r\n{\r\nint i;\r\nint ret;\r\nint cpu;\r\nu64 *ptr;\r\nmax_timeout_sec = 6;\r\ndo {\r\nmax_timeout_sec--;\r\ntimeout_cnt = ((octeon_get_io_clock_rate() >> 8) * max_timeout_sec) >> 8;\r\n} while (timeout_cnt > 65535);\r\nBUG_ON(timeout_cnt == 0);\r\nocteon_wdt_calc_parameters(heartbeat);\r\npr_info("Initial granularity %d Sec\n", timeout_sec);\r\nret = misc_register(&octeon_wdt_miscdev);\r\nif (ret) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto out;\r\n}\r\nocteon_wdt_build_stage1();\r\nptr = (u64 *) nmi_stage1_insns;\r\nfor (i = 0; i < 16; i++) {\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_ADR, i * 8);\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_DAT, ptr[i]);\r\n}\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_CFGX(0), 0x81fc0000);\r\ncpumask_clear(&irq_enabled_cpus);\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(cpu)\r\nocteon_wdt_setup_interrupt(cpu);\r\n__register_hotcpu_notifier(&octeon_wdt_cpu_notifier);\r\ncpu_notifier_register_done();\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit octeon_wdt_cleanup(void)\r\n{\r\nint cpu;\r\nmisc_deregister(&octeon_wdt_miscdev);\r\ncpu_notifier_register_begin();\r\n__unregister_hotcpu_notifier(&octeon_wdt_cpu_notifier);\r\nfor_each_online_cpu(cpu) {\r\nint core = cpu2core(cpu);\r\ncvmx_write_csr(CVMX_CIU_WDOGX(core), 0);\r\nfree_irq(OCTEON_IRQ_WDOG0 + core, octeon_wdt_poke_irq);\r\n}\r\ncpu_notifier_register_done();\r\ncvmx_write_csr(CVMX_MIO_BOOT_LOC_CFGX(0), 0);\r\n}
