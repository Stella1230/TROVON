struct dccp_ackvec *dccp_ackvec_alloc(const gfp_t priority)\r\n{\r\nstruct dccp_ackvec *av = kmem_cache_zalloc(dccp_ackvec_slab, priority);\r\nif (av != NULL) {\r\nav->av_buf_head = av->av_buf_tail = DCCPAV_MAX_ACKVEC_LEN - 1;\r\nINIT_LIST_HEAD(&av->av_records);\r\n}\r\nreturn av;\r\n}\r\nstatic void dccp_ackvec_purge_records(struct dccp_ackvec *av)\r\n{\r\nstruct dccp_ackvec_record *cur, *next;\r\nlist_for_each_entry_safe(cur, next, &av->av_records, avr_node)\r\nkmem_cache_free(dccp_ackvec_record_slab, cur);\r\nINIT_LIST_HEAD(&av->av_records);\r\n}\r\nvoid dccp_ackvec_free(struct dccp_ackvec *av)\r\n{\r\nif (likely(av != NULL)) {\r\ndccp_ackvec_purge_records(av);\r\nkmem_cache_free(dccp_ackvec_slab, av);\r\n}\r\n}\r\nint dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seqno, u8 nonce_sum)\r\n{\r\nstruct dccp_ackvec_record *avr;\r\navr = kmem_cache_alloc(dccp_ackvec_record_slab, GFP_ATOMIC);\r\nif (avr == NULL)\r\nreturn -ENOBUFS;\r\navr->avr_ack_seqno = seqno;\r\navr->avr_ack_ptr = av->av_buf_head;\r\navr->avr_ack_ackno = av->av_buf_ackno;\r\navr->avr_ack_nonce = nonce_sum;\r\navr->avr_ack_runlen = dccp_ackvec_runlen(av->av_buf + av->av_buf_head);\r\nif (av->av_overflow)\r\ndccp_ackvec_purge_records(av);\r\nlist_add(&avr->avr_node, &av->av_records);\r\ndccp_pr_debug("Added Vector, ack_seqno=%llu, ack_ackno=%llu (rl=%u)\n",\r\n(unsigned long long)avr->avr_ack_seqno,\r\n(unsigned long long)avr->avr_ack_ackno,\r\navr->avr_ack_runlen);\r\nreturn 0;\r\n}\r\nstatic struct dccp_ackvec_record *dccp_ackvec_lookup(struct list_head *av_list,\r\nconst u64 ackno)\r\n{\r\nstruct dccp_ackvec_record *avr;\r\nlist_for_each_entry_reverse(avr, av_list, avr_node) {\r\nif (avr->avr_ack_seqno == ackno)\r\nreturn avr;\r\nif (before48(ackno, avr->avr_ack_seqno))\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline u16 __ackvec_idx_add(const u16 a, const u16 b)\r\n{\r\nreturn (a + b) % DCCPAV_MAX_ACKVEC_LEN;\r\n}\r\nstatic inline u16 __ackvec_idx_sub(const u16 a, const u16 b)\r\n{\r\nreturn __ackvec_idx_add(a, DCCPAV_MAX_ACKVEC_LEN - b);\r\n}\r\nu16 dccp_ackvec_buflen(const struct dccp_ackvec *av)\r\n{\r\nif (unlikely(av->av_overflow))\r\nreturn DCCPAV_MAX_ACKVEC_LEN;\r\nreturn __ackvec_idx_sub(av->av_buf_tail, av->av_buf_head);\r\n}\r\nstatic void dccp_ackvec_update_old(struct dccp_ackvec *av, s64 distance,\r\nu64 seqno, enum dccp_ackvec_states state)\r\n{\r\nu16 ptr = av->av_buf_head;\r\nBUG_ON(distance > 0);\r\nif (unlikely(dccp_ackvec_is_empty(av)))\r\nreturn;\r\ndo {\r\nu8 runlen = dccp_ackvec_runlen(av->av_buf + ptr);\r\nif (distance + runlen >= 0) {\r\nif (av->av_buf[ptr] == DCCPAV_NOT_RECEIVED)\r\nav->av_buf[ptr] = state;\r\nelse\r\ndccp_pr_debug("Not changing %llu state to %u\n",\r\n(unsigned long long)seqno, state);\r\nbreak;\r\n}\r\ndistance += runlen + 1;\r\nptr = __ackvec_idx_add(ptr, 1);\r\n} while (ptr != av->av_buf_tail);\r\n}\r\nstatic void dccp_ackvec_reserve_seats(struct dccp_ackvec *av, u16 num)\r\n{\r\nu16 start = __ackvec_idx_add(av->av_buf_head, 1),\r\nlen = DCCPAV_MAX_ACKVEC_LEN - start;\r\nif (num > len) {\r\nmemset(av->av_buf + start, DCCPAV_NOT_RECEIVED, len);\r\nstart = 0;\r\nnum -= len;\r\n}\r\nif (num)\r\nmemset(av->av_buf + start, DCCPAV_NOT_RECEIVED, num);\r\n}\r\nstatic void dccp_ackvec_add_new(struct dccp_ackvec *av, u32 num_packets,\r\nu64 seqno, enum dccp_ackvec_states state)\r\n{\r\nu32 num_cells = num_packets;\r\nif (num_packets > DCCPAV_BURST_THRESH) {\r\nu32 lost_packets = num_packets - 1;\r\nDCCP_WARN("Warning: large burst loss (%u)\n", lost_packets);\r\nfor (num_packets = num_cells = 1; lost_packets; ++num_cells) {\r\nu8 len = min(lost_packets, (u32)DCCPAV_MAX_RUNLEN);\r\nav->av_buf_head = __ackvec_idx_sub(av->av_buf_head, 1);\r\nav->av_buf[av->av_buf_head] = DCCPAV_NOT_RECEIVED | len;\r\nlost_packets -= len;\r\n}\r\n}\r\nif (num_cells + dccp_ackvec_buflen(av) >= DCCPAV_MAX_ACKVEC_LEN) {\r\nDCCP_CRIT("Ack Vector buffer overflow: dropping old entries\n");\r\nav->av_overflow = true;\r\n}\r\nav->av_buf_head = __ackvec_idx_sub(av->av_buf_head, num_packets);\r\nif (av->av_overflow)\r\nav->av_buf_tail = av->av_buf_head;\r\nav->av_buf[av->av_buf_head] = state;\r\nav->av_buf_ackno = seqno;\r\nif (num_packets > 1)\r\ndccp_ackvec_reserve_seats(av, num_packets - 1);\r\n}\r\nvoid dccp_ackvec_input(struct dccp_ackvec *av, struct sk_buff *skb)\r\n{\r\nu64 seqno = DCCP_SKB_CB(skb)->dccpd_seq;\r\nenum dccp_ackvec_states state = DCCPAV_RECEIVED;\r\nif (dccp_ackvec_is_empty(av)) {\r\ndccp_ackvec_add_new(av, 1, seqno, state);\r\nav->av_tail_ackno = seqno;\r\n} else {\r\ns64 num_packets = dccp_delta_seqno(av->av_buf_ackno, seqno);\r\nu8 *current_head = av->av_buf + av->av_buf_head;\r\nif (num_packets == 1 &&\r\ndccp_ackvec_state(current_head) == state &&\r\ndccp_ackvec_runlen(current_head) < DCCPAV_MAX_RUNLEN) {\r\n*current_head += 1;\r\nav->av_buf_ackno = seqno;\r\n} else if (num_packets > 0) {\r\ndccp_ackvec_add_new(av, num_packets, seqno, state);\r\n} else {\r\ndccp_ackvec_update_old(av, num_packets, seqno, state);\r\n}\r\n}\r\n}\r\nvoid dccp_ackvec_clear_state(struct dccp_ackvec *av, const u64 ackno)\r\n{\r\nstruct dccp_ackvec_record *avr, *next;\r\nu8 runlen_now, eff_runlen;\r\ns64 delta;\r\navr = dccp_ackvec_lookup(&av->av_records, ackno);\r\nif (avr == NULL)\r\nreturn;\r\ndelta = dccp_delta_seqno(av->av_tail_ackno, avr->avr_ack_ackno);\r\nif (delta < 0)\r\ngoto free_records;\r\neff_runlen = delta < avr->avr_ack_runlen ? delta : avr->avr_ack_runlen;\r\nrunlen_now = dccp_ackvec_runlen(av->av_buf + avr->avr_ack_ptr);\r\nif (runlen_now > eff_runlen) {\r\nav->av_buf[avr->avr_ack_ptr] -= eff_runlen + 1;\r\nav->av_buf_tail = __ackvec_idx_add(avr->avr_ack_ptr, 1);\r\nif (av->av_overflow)\r\nav->av_overflow = (av->av_buf_head == av->av_buf_tail);\r\n} else {\r\nav->av_buf_tail = avr->avr_ack_ptr;\r\nav->av_overflow = 0;\r\n}\r\nav->av_tail_ackno = ADD48(avr->avr_ack_ackno, 1);\r\nfree_records:\r\nlist_for_each_entry_safe_from(avr, next, &av->av_records, avr_node) {\r\nlist_del(&avr->avr_node);\r\nkmem_cache_free(dccp_ackvec_record_slab, avr);\r\n}\r\n}\r\nint dccp_ackvec_parsed_add(struct list_head *head, u8 *vec, u8 len, u8 nonce)\r\n{\r\nstruct dccp_ackvec_parsed *new = kmalloc(sizeof(*new), GFP_ATOMIC);\r\nif (new == NULL)\r\nreturn -ENOBUFS;\r\nnew->vec = vec;\r\nnew->len = len;\r\nnew->nonce = nonce;\r\nlist_add_tail(&new->node, head);\r\nreturn 0;\r\n}\r\nvoid dccp_ackvec_parsed_cleanup(struct list_head *parsed_chunks)\r\n{\r\nstruct dccp_ackvec_parsed *cur, *next;\r\nlist_for_each_entry_safe(cur, next, parsed_chunks, node)\r\nkfree(cur);\r\nINIT_LIST_HEAD(parsed_chunks);\r\n}\r\nint __init dccp_ackvec_init(void)\r\n{\r\ndccp_ackvec_slab = kmem_cache_create("dccp_ackvec",\r\nsizeof(struct dccp_ackvec), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (dccp_ackvec_slab == NULL)\r\ngoto out_err;\r\ndccp_ackvec_record_slab = kmem_cache_create("dccp_ackvec_record",\r\nsizeof(struct dccp_ackvec_record),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (dccp_ackvec_record_slab == NULL)\r\ngoto out_destroy_slab;\r\nreturn 0;\r\nout_destroy_slab:\r\nkmem_cache_destroy(dccp_ackvec_slab);\r\ndccp_ackvec_slab = NULL;\r\nout_err:\r\nDCCP_CRIT("Unable to create Ack Vector slab cache");\r\nreturn -ENOBUFS;\r\n}\r\nvoid dccp_ackvec_exit(void)\r\n{\r\nif (dccp_ackvec_slab != NULL) {\r\nkmem_cache_destroy(dccp_ackvec_slab);\r\ndccp_ackvec_slab = NULL;\r\n}\r\nif (dccp_ackvec_record_slab != NULL) {\r\nkmem_cache_destroy(dccp_ackvec_record_slab);\r\ndccp_ackvec_record_slab = NULL;\r\n}\r\n}
