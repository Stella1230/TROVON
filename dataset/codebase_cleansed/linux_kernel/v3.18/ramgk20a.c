static void\r\ngk20a_ram_put(struct nouveau_fb *pfb, struct nouveau_mem **pmem)\r\n{\r\nstruct device *dev = nv_device_base(nv_device(pfb));\r\nstruct gk20a_mem *mem = to_gk20a_mem(*pmem);\r\n*pmem = NULL;\r\nif (unlikely(mem == NULL))\r\nreturn;\r\nif (likely(mem->cpuaddr))\r\ndma_free_coherent(dev, mem->base.size << PAGE_SHIFT,\r\nmem->cpuaddr, mem->handle);\r\nkfree(mem->base.pages);\r\nkfree(mem);\r\n}\r\nstatic int\r\ngk20a_ram_get(struct nouveau_fb *pfb, u64 size, u32 align, u32 ncmin,\r\nu32 memtype, struct nouveau_mem **pmem)\r\n{\r\nstruct device *dev = nv_device_base(nv_device(pfb));\r\nstruct gk20a_mem *mem;\r\nu32 type = memtype & 0xff;\r\nu32 npages, order;\r\nint i;\r\nnv_debug(pfb, "%s: size: %llx align: %x, ncmin: %x\n", __func__, size,\r\nalign, ncmin);\r\nnpages = size >> PAGE_SHIFT;\r\nif (npages == 0)\r\nnpages = 1;\r\nif (align == 0)\r\nalign = PAGE_SIZE;\r\nalign >>= PAGE_SHIFT;\r\norder = fls(align);\r\nif ((align & (align - 1)) == 0)\r\norder--;\r\nalign = BIT(order);\r\nnpages = max(align, npages);\r\nmem = kzalloc(sizeof(*mem), GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nmem->base.size = npages;\r\nmem->base.memtype = type;\r\nmem->base.pages = kzalloc(sizeof(dma_addr_t) * npages, GFP_KERNEL);\r\nif (!mem->base.pages) {\r\nkfree(mem);\r\nreturn -ENOMEM;\r\n}\r\n*pmem = &mem->base;\r\nmem->cpuaddr = dma_alloc_coherent(dev, npages << PAGE_SHIFT,\r\n&mem->handle, GFP_KERNEL);\r\nif (!mem->cpuaddr) {\r\nnv_error(pfb, "%s: cannot allocate memory!\n", __func__);\r\ngk20a_ram_put(pfb, pmem);\r\nreturn -ENOMEM;\r\n}\r\nalign <<= PAGE_SHIFT;\r\nif (unlikely(mem->handle & (align - 1)))\r\nnv_warn(pfb, "memory not aligned as requested: %pad (0x%x)\n",\r\n&mem->handle, align);\r\nnv_debug(pfb, "alloc size: 0x%x, align: 0x%x, paddr: %pad, vaddr: %p\n",\r\nnpages << PAGE_SHIFT, align, &mem->handle, mem->cpuaddr);\r\nfor (i = 0; i < npages; i++)\r\nmem->base.pages[i] = mem->handle + (PAGE_SIZE * i);\r\nmem->base.offset = (u64)mem->base.pages[0];\r\nreturn 0;\r\n}\r\nstatic int\r\ngk20a_ram_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 datasize,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_ram *ram;\r\nint ret;\r\nret = nouveau_ram_create(parent, engine, oclass, &ram);\r\n*pobject = nv_object(ram);\r\nif (ret)\r\nreturn ret;\r\nram->type = NV_MEM_TYPE_STOLEN;\r\nram->size = get_num_physpages() << PAGE_SHIFT;\r\nram->get = gk20a_ram_get;\r\nram->put = gk20a_ram_put;\r\nreturn 0;\r\n}
