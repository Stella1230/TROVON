static inline void snd_cmipci_write(struct cmipci *cm, unsigned int cmd, unsigned int data)\r\n{\r\noutl(data, cm->iobase + cmd);\r\n}\r\nstatic inline unsigned int snd_cmipci_read(struct cmipci *cm, unsigned int cmd)\r\n{\r\nreturn inl(cm->iobase + cmd);\r\n}\r\nstatic inline void snd_cmipci_write_w(struct cmipci *cm, unsigned int cmd, unsigned short data)\r\n{\r\noutw(data, cm->iobase + cmd);\r\n}\r\nstatic inline unsigned short snd_cmipci_read_w(struct cmipci *cm, unsigned int cmd)\r\n{\r\nreturn inw(cm->iobase + cmd);\r\n}\r\nstatic inline void snd_cmipci_write_b(struct cmipci *cm, unsigned int cmd, unsigned char data)\r\n{\r\noutb(data, cm->iobase + cmd);\r\n}\r\nstatic inline unsigned char snd_cmipci_read_b(struct cmipci *cm, unsigned int cmd)\r\n{\r\nreturn inb(cm->iobase + cmd);\r\n}\r\nstatic int snd_cmipci_set_bit(struct cmipci *cm, unsigned int cmd, unsigned int flag)\r\n{\r\nunsigned int val, oval;\r\nval = oval = inl(cm->iobase + cmd);\r\nval |= flag;\r\nif (val == oval)\r\nreturn 0;\r\noutl(val, cm->iobase + cmd);\r\nreturn 1;\r\n}\r\nstatic int snd_cmipci_clear_bit(struct cmipci *cm, unsigned int cmd, unsigned int flag)\r\n{\r\nunsigned int val, oval;\r\nval = oval = inl(cm->iobase + cmd);\r\nval &= ~flag;\r\nif (val == oval)\r\nreturn 0;\r\noutl(val, cm->iobase + cmd);\r\nreturn 1;\r\n}\r\nstatic int snd_cmipci_set_bit_b(struct cmipci *cm, unsigned int cmd, unsigned char flag)\r\n{\r\nunsigned char val, oval;\r\nval = oval = inb(cm->iobase + cmd);\r\nval |= flag;\r\nif (val == oval)\r\nreturn 0;\r\noutb(val, cm->iobase + cmd);\r\nreturn 1;\r\n}\r\nstatic int snd_cmipci_clear_bit_b(struct cmipci *cm, unsigned int cmd, unsigned char flag)\r\n{\r\nunsigned char val, oval;\r\nval = oval = inb(cm->iobase + cmd);\r\nval &= ~flag;\r\nif (val == oval)\r\nreturn 0;\r\noutb(val, cm->iobase + cmd);\r\nreturn 1;\r\n}\r\nstatic unsigned int snd_cmipci_rate_freq(unsigned int rate)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(rates); i++) {\r\nif (rates[i] == rate)\r\nreturn i;\r\n}\r\nsnd_BUG();\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_pll_rmn(unsigned int rate, unsigned int adcmult, int *r, int *m, int *n)\r\n{\r\nunsigned int delta, tolerance;\r\nint xm, xn, xr;\r\nfor (*r = 0; rate < CM_MAXIMUM_RATE/adcmult; *r += (1<<5))\r\nrate <<= 1;\r\n*n = -1;\r\nif (*r > 0xff)\r\ngoto out;\r\ntolerance = rate*CM_TOLERANCE_RATE;\r\nfor (xn = (1+2); xn < (0x1f+2); xn++) {\r\nfor (xm = (1+2); xm < (0xff+2); xm++) {\r\nxr = ((CM_REFFREQ_XIN/adcmult) * xm) / xn;\r\nif (xr < rate)\r\ndelta = rate - xr;\r\nelse\r\ndelta = xr - rate;\r\nif (delta < tolerance) {\r\ntolerance = delta;\r\n*m = xm - 2;\r\n*n = xn - 2;\r\n}\r\n}\r\n}\r\nout:\r\nreturn (*n > -1);\r\n}\r\nstatic void snd_cmipci_set_pll(struct cmipci *cm, unsigned int rate, unsigned int slot)\r\n{\r\nunsigned int reg = CM_REG_PLL + slot;\r\nsnd_cmipci_write_b(cm, reg, rate>>8);\r\nsnd_cmipci_write_b(cm, reg, rate&0xff);\r\n}\r\nstatic int snd_cmipci_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_cmipci_playback2_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nif (params_channels(hw_params) > 2) {\r\nmutex_lock(&cm->open_mutex);\r\nif (cm->opened[CM_CH_PLAY]) {\r\nmutex_unlock(&cm->open_mutex);\r\nreturn -EBUSY;\r\n}\r\ncm->opened[CM_CH_PLAY] = CM_OPEN_PLAYBACK_MULTI;\r\nmutex_unlock(&cm->open_mutex);\r\n}\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic void snd_cmipci_ch_reset(struct cmipci *cm, int ch)\r\n{\r\nint reset = CM_RST_CH0 << (cm->channel[ch].ch);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | reset);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~reset);\r\nudelay(10);\r\n}\r\nstatic int snd_cmipci_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int set_dac_channels(struct cmipci *cm, struct cmipci_pcm *rec, int channels)\r\n{\r\nif (channels > 2) {\r\nif (!cm->can_multi_ch || !rec->ch)\r\nreturn -EINVAL;\r\nif (rec->fmt != 0x03)\r\nreturn -EINVAL;\r\n}\r\nif (cm->can_multi_ch) {\r\nspin_lock_irq(&cm->reg_lock);\r\nif (channels > 2) {\r\nsnd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);\r\n} else {\r\nsnd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_NXCHG);\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);\r\n}\r\nif (channels == 8)\r\nsnd_cmipci_set_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);\r\nelse\r\nsnd_cmipci_clear_bit(cm, CM_REG_EXT_MISC, CM_CHB3D8C);\r\nif (channels == 6) {\r\nsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);\r\nsnd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);\r\n} else {\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D5C);\r\nsnd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CHB3D6C);\r\n}\r\nif (channels == 4)\r\nsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);\r\nelse\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_CHB3D);\r\nspin_unlock_irq(&cm->reg_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_pcm_prepare(struct cmipci *cm, struct cmipci_pcm *rec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nunsigned int reg, freq, freq_ext, val;\r\nunsigned int period_size;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nrec->fmt = 0;\r\nrec->shift = 0;\r\nif (snd_pcm_format_width(runtime->format) >= 16) {\r\nrec->fmt |= 0x02;\r\nif (snd_pcm_format_width(runtime->format) > 16)\r\nrec->shift++;\r\n}\r\nif (runtime->channels > 1)\r\nrec->fmt |= 0x01;\r\nif (rec->is_dac && set_dac_channels(cm, rec, runtime->channels) < 0) {\r\ndev_dbg(cm->card->dev, "cannot set dac channels\n");\r\nreturn -EINVAL;\r\n}\r\nrec->offset = runtime->dma_addr;\r\nrec->dma_size = runtime->buffer_size << rec->shift;\r\nperiod_size = runtime->period_size << rec->shift;\r\nif (runtime->channels > 2) {\r\nrec->dma_size = (rec->dma_size * runtime->channels) / 2;\r\nperiod_size = (period_size * runtime->channels) / 2;\r\n}\r\nspin_lock_irq(&cm->reg_lock);\r\nreg = rec->ch ? CM_REG_CH1_FRAME1 : CM_REG_CH0_FRAME1;\r\nsnd_cmipci_write(cm, reg, rec->offset);\r\nreg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;\r\nsnd_cmipci_write_w(cm, reg, rec->dma_size - 1);\r\nsnd_cmipci_write_w(cm, reg + 2, period_size - 1);\r\nval = rec->ch ? CM_CHADC1 : CM_CHADC0;\r\nif (rec->is_dac)\r\ncm->ctrl &= ~val;\r\nelse\r\ncm->ctrl |= val;\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\r\nfreq = 0;\r\nfreq_ext = 0;\r\nif (runtime->rate > 48000)\r\nswitch (runtime->rate) {\r\ncase 88200: freq_ext = CM_CH0_SRATE_88K; break;\r\ncase 96000: freq_ext = CM_CH0_SRATE_96K; break;\r\ncase 128000: freq_ext = CM_CH0_SRATE_128K; break;\r\ndefault: snd_BUG(); break;\r\n}\r\nelse\r\nfreq = snd_cmipci_rate_freq(runtime->rate);\r\nval = snd_cmipci_read(cm, CM_REG_FUNCTRL1);\r\nif (rec->ch) {\r\nval &= ~CM_DSFC_MASK;\r\nval |= (freq << CM_DSFC_SHIFT) & CM_DSFC_MASK;\r\n} else {\r\nval &= ~CM_ASFC_MASK;\r\nval |= (freq << CM_ASFC_SHIFT) & CM_ASFC_MASK;\r\n}\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL1, val);\r\ndev_dbg(cm->card->dev, "functrl1 = %08x\n", val);\r\nval = snd_cmipci_read(cm, CM_REG_CHFORMAT);\r\nif (rec->ch) {\r\nval &= ~CM_CH1FMT_MASK;\r\nval |= rec->fmt << CM_CH1FMT_SHIFT;\r\n} else {\r\nval &= ~CM_CH0FMT_MASK;\r\nval |= rec->fmt << CM_CH0FMT_SHIFT;\r\n}\r\nif (cm->can_96k) {\r\nval &= ~(CM_CH0_SRATE_MASK << (rec->ch * 2));\r\nval |= freq_ext << (rec->ch * 2);\r\n}\r\nsnd_cmipci_write(cm, CM_REG_CHFORMAT, val);\r\ndev_dbg(cm->card->dev, "chformat = %08x\n", val);\r\nif (!rec->is_dac && cm->chip_version) {\r\nif (runtime->rate > 44100)\r\nsnd_cmipci_set_bit(cm, CM_REG_EXT_MISC, CM_ADC48K44K);\r\nelse\r\nsnd_cmipci_clear_bit(cm, CM_REG_EXT_MISC, CM_ADC48K44K);\r\n}\r\nrec->running = 0;\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_pcm_trigger(struct cmipci *cm, struct cmipci_pcm *rec,\r\nint cmd)\r\n{\r\nunsigned int inthld, chen, reset, pause;\r\nint result = 0;\r\ninthld = CM_CH0_INT_EN << rec->ch;\r\nchen = CM_CHEN0 << rec->ch;\r\nreset = CM_RST_CH0 << rec->ch;\r\npause = CM_PAUSE0 << rec->ch;\r\nspin_lock(&cm->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nrec->running = 1;\r\nsnd_cmipci_set_bit(cm, CM_REG_INT_HLDCLR, inthld);\r\ncm->ctrl |= chen;\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\r\ndev_dbg(cm->card->dev, "functrl0 = %08x\n", cm->ctrl);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nrec->running = 0;\r\nsnd_cmipci_clear_bit(cm, CM_REG_INT_HLDCLR, inthld);\r\ncm->ctrl &= ~chen;\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | reset);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~reset);\r\nrec->needs_silencing = rec->is_dac;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncm->ctrl |= pause;\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncm->ctrl &= ~pause;\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&cm->reg_lock);\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t snd_cmipci_pcm_pointer(struct cmipci *cm, struct cmipci_pcm *rec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsize_t ptr;\r\nunsigned int reg, rem, tries;\r\nif (!rec->running)\r\nreturn 0;\r\n#if 1\r\nreg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;\r\nfor (tries = 0; tries < 3; tries++) {\r\nrem = snd_cmipci_read_w(cm, reg);\r\nif (rem < rec->dma_size)\r\ngoto ok;\r\n}\r\ndev_err(cm->card->dev, "invalid PCM pointer: %#x\n", rem);\r\nreturn SNDRV_PCM_POS_XRUN;\r\nok:\r\nptr = (rec->dma_size - (rem + 1)) >> rec->shift;\r\n#else\r\nreg = rec->ch ? CM_REG_CH1_FRAME1 : CM_REG_CH0_FRAME1;\r\nptr = snd_cmipci_read(cm, reg) - rec->offset;\r\nptr = bytes_to_frames(substream->runtime, ptr);\r\n#endif\r\nif (substream->runtime->channels > 2)\r\nptr = (ptr * 2) / substream->runtime->channels;\r\nreturn ptr;\r\n}\r\nstatic int snd_cmipci_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nreturn snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_PLAY], cmd);\r\n}\r\nstatic snd_pcm_uframes_t snd_cmipci_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nreturn snd_cmipci_pcm_pointer(cm, &cm->channel[CM_CH_PLAY], substream);\r\n}\r\nstatic int snd_cmipci_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nreturn snd_cmipci_pcm_trigger(cm, &cm->channel[CM_CH_CAPT], cmd);\r\n}\r\nstatic snd_pcm_uframes_t snd_cmipci_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nreturn snd_cmipci_pcm_pointer(cm, &cm->channel[CM_CH_CAPT], substream);\r\n}\r\nstatic int snd_cmipci_spdif_default_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\r\nint i;\r\nspin_lock_irq(&chip->reg_lock);\r\nfor (i = 0; i < 4; i++)\r\nucontrol->value.iec958.status[i] = (chip->dig_status >> (i * 8)) & 0xff;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\r\nint i, change;\r\nunsigned int val;\r\nval = 0;\r\nspin_lock_irq(&chip->reg_lock);\r\nfor (i = 0; i < 4; i++)\r\nval |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);\r\nchange = val != chip->dig_status;\r\nchip->dig_status = val;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_cmipci_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_spdif_stream_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_spdif_stream_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\r\nint i;\r\nspin_lock_irq(&chip->reg_lock);\r\nfor (i = 0; i < 4; i++)\r\nucontrol->value.iec958.status[i] = (chip->dig_pcm_status >> (i * 8)) & 0xff;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_spdif_stream_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\r\nint i, change;\r\nunsigned int val;\r\nval = 0;\r\nspin_lock_irq(&chip->reg_lock);\r\nfor (i = 0; i < 4; i++)\r\nval |= (unsigned int)ucontrol->value.iec958.status[i] << (i * 8);\r\nchange = val != chip->dig_pcm_status;\r\nchip->dig_pcm_status = val;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn change;\r\n}\r\nstatic int save_mixer_state(struct cmipci *cm)\r\n{\r\nif (! cm->mixer_insensitive) {\r\nstruct snd_ctl_elem_value *val;\r\nunsigned int i;\r\nval = kmalloc(sizeof(*val), GFP_ATOMIC);\r\nif (!val)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < CM_SAVED_MIXERS; i++) {\r\nstruct snd_kcontrol *ctl = cm->mixer_res_ctl[i];\r\nif (ctl) {\r\nint event;\r\nmemset(val, 0, sizeof(*val));\r\nctl->get(ctl, val);\r\ncm->mixer_res_status[i] = val->value.integer.value[0];\r\nval->value.integer.value[0] = cm_saved_mixer[i].toggle_on;\r\nevent = SNDRV_CTL_EVENT_MASK_INFO;\r\nif (cm->mixer_res_status[i] != val->value.integer.value[0]) {\r\nctl->put(ctl, val);\r\nevent |= SNDRV_CTL_EVENT_MASK_VALUE;\r\n}\r\nctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(cm->card, event, &ctl->id);\r\n}\r\n}\r\nkfree(val);\r\ncm->mixer_insensitive = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void restore_mixer_state(struct cmipci *cm)\r\n{\r\nif (cm->mixer_insensitive) {\r\nstruct snd_ctl_elem_value *val;\r\nunsigned int i;\r\nval = kmalloc(sizeof(*val), GFP_KERNEL);\r\nif (!val)\r\nreturn;\r\ncm->mixer_insensitive = 0;\r\nfor (i = 0; i < CM_SAVED_MIXERS; i++) {\r\nstruct snd_kcontrol *ctl = cm->mixer_res_ctl[i];\r\nif (ctl) {\r\nint event;\r\nmemset(val, 0, sizeof(*val));\r\nctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nctl->get(ctl, val);\r\nevent = SNDRV_CTL_EVENT_MASK_INFO;\r\nif (val->value.integer.value[0] != cm->mixer_res_status[i]) {\r\nval->value.integer.value[0] = cm->mixer_res_status[i];\r\nctl->put(ctl, val);\r\nevent |= SNDRV_CTL_EVENT_MASK_VALUE;\r\n}\r\nsnd_ctl_notify(cm->card, event, &ctl->id);\r\n}\r\n}\r\nkfree(val);\r\n}\r\n}\r\nstatic void setup_ac3(struct cmipci *cm, struct snd_pcm_substream *subs, int do_ac3, int rate)\r\n{\r\nif (do_ac3) {\r\nsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_AC3EN1);\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_AC3EN2);\r\nif (cm->can_ac3_hw) {\r\nsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\r\n} else {\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\r\nif (cm->chip_version == 33) {\r\nif (rate >= 48000) {\r\nsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);\r\n} else {\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);\r\n}\r\n}\r\n}\r\n} else {\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_AC3EN1);\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_AC3EN2);\r\nif (cm->can_ac3_hw) {\r\nif (snd_pcm_format_width(subs->runtime->format) > 16) {\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\r\nsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);\r\n} else {\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);\r\n}\r\n} else {\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_SPD24SEL);\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_PLAYBACK_SRATE_176K);\r\n}\r\n}\r\n}\r\nstatic int setup_spdif_playback(struct cmipci *cm, struct snd_pcm_substream *subs, int up, int do_ac3)\r\n{\r\nint rate, err;\r\nrate = subs->runtime->rate;\r\nif (up && do_ac3)\r\nif ((err = save_mixer_state(cm)) < 0)\r\nreturn err;\r\nspin_lock_irq(&cm->reg_lock);\r\ncm->spdif_playback_avail = up;\r\nif (up) {\r\nif (cm->spdif_playback_enabled)\r\nsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);\r\nsetup_ac3(cm, subs, do_ac3, rate);\r\nif (rate == 48000 || rate == 96000)\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K | CM_SPDF_AC97);\r\nelse\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K | CM_SPDF_AC97);\r\nif (rate > 48000)\r\nsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\r\nelse\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\r\n} else {\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\r\nsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);\r\nsetup_ac3(cm, subs, 0, 0);\r\n}\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nint rate = substream->runtime->rate;\r\nint err, do_spdif, do_ac3 = 0;\r\ndo_spdif = (rate >= 44100 && rate <= 96000 &&\r\nsubstream->runtime->format == SNDRV_PCM_FORMAT_S16_LE &&\r\nsubstream->runtime->channels == 2);\r\nif (do_spdif && cm->can_ac3_hw)\r\ndo_ac3 = cm->dig_pcm_status & IEC958_AES0_NONAUDIO;\r\nif ((err = setup_spdif_playback(cm, substream, do_spdif, do_ac3)) < 0)\r\nreturn err;\r\nreturn snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_PLAY], substream);\r\n}\r\nstatic int snd_cmipci_playback_spdif_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nint err, do_ac3;\r\nif (cm->can_ac3_hw)\r\ndo_ac3 = cm->dig_pcm_status & IEC958_AES0_NONAUDIO;\r\nelse\r\ndo_ac3 = 1;\r\nif ((err = setup_spdif_playback(cm, substream, 1, do_ac3)) < 0)\r\nreturn err;\r\nreturn snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_PLAY], substream);\r\n}\r\nstatic void snd_cmipci_silence_hack(struct cmipci *cm, struct cmipci_pcm *rec)\r\n{\r\nstruct snd_pcm_runtime *runtime = rec->substream->runtime;\r\nunsigned int reg, val;\r\nif (rec->needs_silencing && runtime && runtime->dma_area) {\r\nmemset(runtime->dma_area, 0, PAGE_SIZE);\r\nreg = rec->ch ? CM_REG_CH1_FRAME2 : CM_REG_CH0_FRAME2;\r\nval = ((PAGE_SIZE / 4) - 1) | (((PAGE_SIZE / 4) / 2 - 1) << 16);\r\nsnd_cmipci_write(cm, reg, val);\r\nif (runtime->channels > 2)\r\nset_dac_channels(cm, rec, 2);\r\nspin_lock_irq(&cm->reg_lock);\r\nval = snd_cmipci_read(cm, CM_REG_FUNCTRL1);\r\nval &= ~(CM_ASFC_MASK << (rec->ch * 3));\r\nval |= (4 << CM_ASFC_SHIFT) << (rec->ch * 3);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL1, val);\r\nval = snd_cmipci_read(cm, CM_REG_CHFORMAT);\r\nval &= ~(CM_CH0FMT_MASK << (rec->ch * 2));\r\nval |= (3 << CM_CH0FMT_SHIFT) << (rec->ch * 2);\r\nif (cm->can_96k)\r\nval &= ~(CM_CH0_SRATE_MASK << (rec->ch * 2));\r\nsnd_cmipci_write(cm, CM_REG_CHFORMAT, val);\r\ncm->ctrl |= CM_CHEN0 << rec->ch;\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl);\r\nspin_unlock_irq(&cm->reg_lock);\r\nmsleep(1);\r\nspin_lock_irq(&cm->reg_lock);\r\ncm->ctrl &= ~(CM_CHEN0 << rec->ch);\r\nval = CM_RST_CH0 << rec->ch;\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl | val);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, cm->ctrl & ~val);\r\nspin_unlock_irq(&cm->reg_lock);\r\nrec->needs_silencing = 0;\r\n}\r\n}\r\nstatic int snd_cmipci_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nsetup_spdif_playback(cm, substream, 0, 0);\r\nrestore_mixer_state(cm);\r\nsnd_cmipci_silence_hack(cm, &cm->channel[0]);\r\nreturn snd_cmipci_hw_free(substream);\r\n}\r\nstatic int snd_cmipci_playback2_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nsnd_cmipci_silence_hack(cm, &cm->channel[1]);\r\nreturn snd_cmipci_hw_free(substream);\r\n}\r\nstatic int snd_cmipci_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nreturn snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);\r\n}\r\nstatic int snd_cmipci_capture_spdif_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&cm->reg_lock);\r\nsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);\r\nif (cm->can_96k) {\r\nif (substream->runtime->rate > 48000)\r\nsnd_cmipci_set_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\r\nelse\r\nsnd_cmipci_clear_bit(cm, CM_REG_CHFORMAT, CM_DBLSPDS);\r\n}\r\nif (snd_pcm_format_width(substream->runtime->format) > 16)\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\r\nelse\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn snd_cmipci_pcm_prepare(cm, &cm->channel[CM_CH_CAPT], substream);\r\n}\r\nstatic int snd_cmipci_capture_spdif_hw_free(struct snd_pcm_substream *subs)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(subs);\r\nspin_lock_irq(&cm->reg_lock);\r\nsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_CAPTURE_SPDF);\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_SPD32SEL);\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn snd_cmipci_hw_free(subs);\r\n}\r\nstatic irqreturn_t snd_cmipci_interrupt(int irq, void *dev_id)\r\n{\r\nstruct cmipci *cm = dev_id;\r\nunsigned int status, mask = 0;\r\nstatus = snd_cmipci_read(cm, CM_REG_INT_STATUS);\r\nif (!(status & CM_INTR))\r\nreturn IRQ_NONE;\r\nspin_lock(&cm->reg_lock);\r\nif (status & CM_CHINT0)\r\nmask |= CM_CH0_INT_EN;\r\nif (status & CM_CHINT1)\r\nmask |= CM_CH1_INT_EN;\r\nsnd_cmipci_clear_bit(cm, CM_REG_INT_HLDCLR, mask);\r\nsnd_cmipci_set_bit(cm, CM_REG_INT_HLDCLR, mask);\r\nspin_unlock(&cm->reg_lock);\r\nif (cm->rmidi && (status & CM_UARTINT))\r\nsnd_mpu401_uart_interrupt(irq, cm->rmidi->private_data);\r\nif (cm->pcm) {\r\nif ((status & CM_CHINT0) && cm->channel[0].running)\r\nsnd_pcm_period_elapsed(cm->channel[0].substream);\r\nif ((status & CM_CHINT1) && cm->channel[1].running)\r\nsnd_pcm_period_elapsed(cm->channel[1].substream);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int open_device_check(struct cmipci *cm, int mode, struct snd_pcm_substream *subs)\r\n{\r\nint ch = mode & CM_OPEN_CH_MASK;\r\nmutex_lock(&cm->open_mutex);\r\nif (cm->opened[ch]) {\r\nmutex_unlock(&cm->open_mutex);\r\nreturn -EBUSY;\r\n}\r\ncm->opened[ch] = mode;\r\ncm->channel[ch].substream = subs;\r\nif (! (mode & CM_OPEN_DAC)) {\r\ncm->channel[ch].is_dac = 0;\r\nspin_lock_irq(&cm->reg_lock);\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC);\r\nspin_unlock_irq(&cm->reg_lock);\r\n}\r\nmutex_unlock(&cm->open_mutex);\r\nreturn 0;\r\n}\r\nstatic void close_device_check(struct cmipci *cm, int mode)\r\n{\r\nint ch = mode & CM_OPEN_CH_MASK;\r\nmutex_lock(&cm->open_mutex);\r\nif (cm->opened[ch] == mode) {\r\nif (cm->channel[ch].substream) {\r\nsnd_cmipci_ch_reset(cm, ch);\r\ncm->channel[ch].running = 0;\r\ncm->channel[ch].substream = NULL;\r\n}\r\ncm->opened[ch] = 0;\r\nif (! cm->channel[ch].is_dac) {\r\ncm->channel[ch].is_dac = 1;\r\nspin_lock_irq(&cm->reg_lock);\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC);\r\nspin_unlock_irq(&cm->reg_lock);\r\n}\r\n}\r\nmutex_unlock(&cm->open_mutex);\r\n}\r\nstatic int snd_cmipci_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif ((err = open_device_check(cm, CM_OPEN_PLAYBACK, substream)) < 0)\r\nreturn err;\r\nruntime->hw = snd_cmipci_playback;\r\nif (cm->chip_version == 68) {\r\nruntime->hw.rates |= SNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000;\r\nruntime->hw.rate_max = 96000;\r\n} else if (cm->chip_version == 55) {\r\nerr = snd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\r\nruntime->hw.rate_max = 128000;\r\n}\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);\r\ncm->dig_pcm_status = cm->dig_status;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif ((err = open_device_check(cm, CM_OPEN_CAPTURE, substream)) < 0)\r\nreturn err;\r\nruntime->hw = snd_cmipci_capture;\r\nif (cm->chip_version == 68) {\r\nruntime->hw.rate_min = 41000;\r\nruntime->hw.rates = SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000;\r\n} else if (cm->chip_version == 55) {\r\nerr = snd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\r\nruntime->hw.rate_max = 128000;\r\n}\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_playback2_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif ((err = open_device_check(cm, CM_OPEN_PLAYBACK2, substream)) < 0)\r\nreturn err;\r\nruntime->hw = snd_cmipci_playback2;\r\nmutex_lock(&cm->open_mutex);\r\nif (! cm->opened[CM_CH_PLAY]) {\r\nif (cm->can_multi_ch) {\r\nruntime->hw.channels_max = cm->max_channels;\r\nif (cm->max_channels == 4)\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_4);\r\nelse if (cm->max_channels == 6)\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_6);\r\nelse if (cm->max_channels == 8)\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS, &hw_constraints_channels_8);\r\n}\r\n}\r\nmutex_unlock(&cm->open_mutex);\r\nif (cm->chip_version == 68) {\r\nruntime->hw.rates |= SNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000;\r\nruntime->hw.rate_max = 96000;\r\n} else if (cm->chip_version == 55) {\r\nerr = snd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\r\nruntime->hw.rate_max = 128000;\r\n}\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x10000);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_playback_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif ((err = open_device_check(cm, CM_OPEN_SPDIF_PLAYBACK, substream)) < 0)\r\nreturn err;\r\nif (cm->can_ac3_hw) {\r\nruntime->hw = snd_cmipci_playback_spdif;\r\nif (cm->chip_version >= 37) {\r\nruntime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\n}\r\nif (cm->can_96k) {\r\nruntime->hw.rates |= SNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000;\r\nruntime->hw.rate_max = 96000;\r\n}\r\n} else {\r\nruntime->hw = snd_cmipci_playback_iec958_subframe;\r\n}\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x40000);\r\ncm->dig_pcm_status = cm->dig_status;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_capture_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif ((err = open_device_check(cm, CM_OPEN_SPDIF_CAPTURE, substream)) < 0)\r\nreturn err;\r\nruntime->hw = snd_cmipci_capture_spdif;\r\nif (cm->can_96k && !(cm->chip_version == 68)) {\r\nruntime->hw.rates |= SNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000;\r\nruntime->hw.rate_max = 96000;\r\n}\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 0x40000);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nclose_device_check(cm, CM_OPEN_PLAYBACK);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nclose_device_check(cm, CM_OPEN_CAPTURE);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_playback2_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nclose_device_check(cm, CM_OPEN_PLAYBACK2);\r\nclose_device_check(cm, CM_OPEN_PLAYBACK_MULTI);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_playback_spdif_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nclose_device_check(cm, CM_OPEN_SPDIF_PLAYBACK);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_capture_spdif_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct cmipci *cm = snd_pcm_substream_chip(substream);\r\nclose_device_check(cm, CM_OPEN_SPDIF_CAPTURE);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_pcm_new(struct cmipci *cm, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cmipci_capture_ops);\r\npcm->private_data = cm;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "C-Media PCI DAC/ADC");\r\ncm->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(cm->pci), 64*1024, 128*1024);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_pcm2_new(struct cmipci *cm, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(cm->card, cm->card->driver, device, 1, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback2_ops);\r\npcm->private_data = cm;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "C-Media PCI 2nd DAC");\r\ncm->pcm2 = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(cm->pci), 64*1024, 128*1024);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_pcm_spdif_new(struct cmipci *cm, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_cmipci_playback_spdif_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cmipci_capture_spdif_ops);\r\npcm->private_data = cm;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "C-Media PCI IEC958");\r\ncm->pcm_spdif = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(cm->pci), 64*1024, 128*1024);\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_alt_chmaps, cm->max_channels, 0,\r\nNULL);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void snd_cmipci_mixer_write(struct cmipci *s, unsigned char idx, unsigned char data)\r\n{\r\noutb(idx, s->iobase + CM_REG_SB16_ADDR);\r\noutb(data, s->iobase + CM_REG_SB16_DATA);\r\n}\r\nstatic unsigned char snd_cmipci_mixer_read(struct cmipci *s, unsigned char idx)\r\n{\r\nunsigned char v;\r\noutb(idx, s->iobase + CM_REG_SB16_ADDR);\r\nv = inb(s->iobase + CM_REG_SB16_DATA);\r\nreturn v;\r\n}\r\nstatic void cmipci_sb_reg_decode(struct cmipci_sb_reg *r, unsigned long val)\r\n{\r\nr->left_reg = val & 0xff;\r\nr->right_reg = (val >> 8) & 0xff;\r\nr->left_shift = (val >> 16) & 0x07;\r\nr->right_shift = (val >> 19) & 0x07;\r\nr->invert = (val >> 22) & 1;\r\nr->stereo = (val >> 23) & 1;\r\nr->mask = (val >> 24) & 0xff;\r\n}\r\nstatic int snd_cmipci_info_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct cmipci_sb_reg reg;\r\ncmipci_sb_reg_decode(&reg, kcontrol->private_value);\r\nuinfo->type = reg.mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = reg.stereo + 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = reg.mask;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_get_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nstruct cmipci_sb_reg reg;\r\nint val;\r\ncmipci_sb_reg_decode(&reg, kcontrol->private_value);\r\nspin_lock_irq(&cm->reg_lock);\r\nval = (snd_cmipci_mixer_read(cm, reg.left_reg) >> reg.left_shift) & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nucontrol->value.integer.value[0] = val;\r\nif (reg.stereo) {\r\nval = (snd_cmipci_mixer_read(cm, reg.right_reg) >> reg.right_shift) & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nucontrol->value.integer.value[1] = val;\r\n}\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_put_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nstruct cmipci_sb_reg reg;\r\nint change;\r\nint left, right, oleft, oright;\r\ncmipci_sb_reg_decode(&reg, kcontrol->private_value);\r\nleft = ucontrol->value.integer.value[0] & reg.mask;\r\nif (reg.invert)\r\nleft = reg.mask - left;\r\nleft <<= reg.left_shift;\r\nif (reg.stereo) {\r\nright = ucontrol->value.integer.value[1] & reg.mask;\r\nif (reg.invert)\r\nright = reg.mask - right;\r\nright <<= reg.right_shift;\r\n} else\r\nright = 0;\r\nspin_lock_irq(&cm->reg_lock);\r\noleft = snd_cmipci_mixer_read(cm, reg.left_reg);\r\nleft |= oleft & ~(reg.mask << reg.left_shift);\r\nchange = left != oleft;\r\nif (reg.stereo) {\r\nif (reg.left_reg != reg.right_reg) {\r\nsnd_cmipci_mixer_write(cm, reg.left_reg, left);\r\noright = snd_cmipci_mixer_read(cm, reg.right_reg);\r\n} else\r\noright = left;\r\nright |= oright & ~(reg.mask << reg.right_shift);\r\nchange |= right != oright;\r\nsnd_cmipci_mixer_write(cm, reg.right_reg, right);\r\n} else\r\nsnd_cmipci_mixer_write(cm, reg.left_reg, left);\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_cmipci_info_input_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 4;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_get_input_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nstruct cmipci_sb_reg reg;\r\nint val1, val2;\r\ncmipci_sb_reg_decode(&reg, kcontrol->private_value);\r\nspin_lock_irq(&cm->reg_lock);\r\nval1 = snd_cmipci_mixer_read(cm, reg.left_reg);\r\nval2 = snd_cmipci_mixer_read(cm, reg.right_reg);\r\nspin_unlock_irq(&cm->reg_lock);\r\nucontrol->value.integer.value[0] = (val1 >> reg.left_shift) & 1;\r\nucontrol->value.integer.value[1] = (val2 >> reg.left_shift) & 1;\r\nucontrol->value.integer.value[2] = (val1 >> reg.right_shift) & 1;\r\nucontrol->value.integer.value[3] = (val2 >> reg.right_shift) & 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_put_input_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nstruct cmipci_sb_reg reg;\r\nint change;\r\nint val1, val2, oval1, oval2;\r\ncmipci_sb_reg_decode(&reg, kcontrol->private_value);\r\nspin_lock_irq(&cm->reg_lock);\r\noval1 = snd_cmipci_mixer_read(cm, reg.left_reg);\r\noval2 = snd_cmipci_mixer_read(cm, reg.right_reg);\r\nval1 = oval1 & ~((1 << reg.left_shift) | (1 << reg.right_shift));\r\nval2 = oval2 & ~((1 << reg.left_shift) | (1 << reg.right_shift));\r\nval1 |= (ucontrol->value.integer.value[0] & 1) << reg.left_shift;\r\nval2 |= (ucontrol->value.integer.value[1] & 1) << reg.left_shift;\r\nval1 |= (ucontrol->value.integer.value[2] & 1) << reg.right_shift;\r\nval2 |= (ucontrol->value.integer.value[3] & 1) << reg.right_shift;\r\nchange = val1 != oval1 || val2 != oval2;\r\nsnd_cmipci_mixer_write(cm, reg.left_reg, val1);\r\nsnd_cmipci_mixer_write(cm, reg.right_reg, val2);\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_cmipci_info_native_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct cmipci_sb_reg reg;\r\ncmipci_sb_reg_decode(&reg, kcontrol->private_value);\r\nuinfo->type = reg.mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = reg.stereo + 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = reg.mask;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_get_native_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nstruct cmipci_sb_reg reg;\r\nunsigned char oreg, val;\r\ncmipci_sb_reg_decode(&reg, kcontrol->private_value);\r\nspin_lock_irq(&cm->reg_lock);\r\noreg = inb(cm->iobase + reg.left_reg);\r\nval = (oreg >> reg.left_shift) & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nucontrol->value.integer.value[0] = val;\r\nif (reg.stereo) {\r\nval = (oreg >> reg.right_shift) & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nucontrol->value.integer.value[1] = val;\r\n}\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_put_native_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nstruct cmipci_sb_reg reg;\r\nunsigned char oreg, nreg, val;\r\ncmipci_sb_reg_decode(&reg, kcontrol->private_value);\r\nspin_lock_irq(&cm->reg_lock);\r\noreg = inb(cm->iobase + reg.left_reg);\r\nval = ucontrol->value.integer.value[0] & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nnreg = oreg & ~(reg.mask << reg.left_shift);\r\nnreg |= (val << reg.left_shift);\r\nif (reg.stereo) {\r\nval = ucontrol->value.integer.value[1] & reg.mask;\r\nif (reg.invert)\r\nval = reg.mask - val;\r\nnreg &= ~(reg.mask << reg.right_shift);\r\nnreg |= (val << reg.right_shift);\r\n}\r\noutb(nreg, cm->iobase + reg.left_reg);\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn (nreg != oreg);\r\n}\r\nstatic int snd_cmipci_get_native_mixer_sensitive(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nreturn snd_cmipci_get_native_mixer(kcontrol, ucontrol);\r\n}\r\nstatic int snd_cmipci_put_native_mixer_sensitive(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nif (cm->mixer_insensitive) {\r\nreturn 0;\r\n}\r\nreturn snd_cmipci_put_native_mixer(kcontrol, ucontrol);\r\n}\r\nstatic int _snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nstruct cmipci_switch_args *args)\r\n{\r\nunsigned int val;\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&cm->reg_lock);\r\nif (args->ac3_sensitive && cm->mixer_insensitive) {\r\nucontrol->value.integer.value[0] = 0;\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nif (args->is_byte)\r\nval = inb(cm->iobase + args->reg);\r\nelse\r\nval = snd_cmipci_read(cm, args->reg);\r\nucontrol->value.integer.value[0] = ((val & args->mask) == args->mask_on) ? 1 : 0;\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci_switch_args *args;\r\nargs = (struct cmipci_switch_args *)kcontrol->private_value;\r\nif (snd_BUG_ON(!args))\r\nreturn -EINVAL;\r\nreturn _snd_cmipci_uswitch_get(kcontrol, ucontrol, args);\r\n}\r\nstatic int _snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nstruct cmipci_switch_args *args)\r\n{\r\nunsigned int val;\r\nint change;\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&cm->reg_lock);\r\nif (args->ac3_sensitive && cm->mixer_insensitive) {\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nif (args->is_byte)\r\nval = inb(cm->iobase + args->reg);\r\nelse\r\nval = snd_cmipci_read(cm, args->reg);\r\nchange = (val & args->mask) != (ucontrol->value.integer.value[0] ?\r\nargs->mask_on : (args->mask & ~args->mask_on));\r\nif (change) {\r\nval &= ~args->mask;\r\nif (ucontrol->value.integer.value[0])\r\nval |= args->mask_on;\r\nelse\r\nval |= (args->mask & ~args->mask_on);\r\nif (args->is_byte)\r\noutb((unsigned char)val, cm->iobase + args->reg);\r\nelse\r\nsnd_cmipci_write(cm, args->reg, val);\r\n}\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci_switch_args *args;\r\nargs = (struct cmipci_switch_args *)kcontrol->private_value;\r\nif (snd_BUG_ON(!args))\r\nreturn -EINVAL;\r\nreturn _snd_cmipci_uswitch_put(kcontrol, ucontrol, args);\r\n}\r\nstatic int snd_cmipci_spdout_enable_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint changed;\r\nchanged = _snd_cmipci_uswitch_get(kcontrol, ucontrol, &cmipci_switch_arg_spdif_enable);\r\nchanged |= _snd_cmipci_uswitch_get(kcontrol, ucontrol, &cmipci_switch_arg_spdo2dac);\r\nreturn changed;\r\n}\r\nstatic int snd_cmipci_spdout_enable_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *chip = snd_kcontrol_chip(kcontrol);\r\nint changed;\r\nchanged = _snd_cmipci_uswitch_put(kcontrol, ucontrol, &cmipci_switch_arg_spdif_enable);\r\nchanged |= _snd_cmipci_uswitch_put(kcontrol, ucontrol, &cmipci_switch_arg_spdo2dac);\r\nif (changed) {\r\nif (ucontrol->value.integer.value[0]) {\r\nif (chip->spdif_playback_avail)\r\nsnd_cmipci_set_bit(chip, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);\r\n} else {\r\nif (chip->spdif_playback_avail)\r\nsnd_cmipci_clear_bit(chip, CM_REG_FUNCTRL1, CM_PLAYBACK_SPDF);\r\n}\r\n}\r\nchip->spdif_playback_enabled = ucontrol->value.integer.value[0];\r\nreturn changed;\r\n}\r\nstatic int snd_cmipci_line_in_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nstatic const char *const texts[3] = {\r\n"Line-In", "Rear Output", "Bass Output"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1,\r\ncm->chip_version >= 39 ? 3 : 2, texts);\r\n}\r\nstatic inline unsigned int get_line_in_mode(struct cmipci *cm)\r\n{\r\nunsigned int val;\r\nif (cm->chip_version >= 39) {\r\nval = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL);\r\nif (val & (CM_CENTR2LIN | CM_BASE2LIN))\r\nreturn 2;\r\n}\r\nval = snd_cmipci_read_b(cm, CM_REG_MIXER1);\r\nif (val & CM_REAR2LIN)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_line_in_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&cm->reg_lock);\r\nucontrol->value.enumerated.item[0] = get_line_in_mode(cm);\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_line_in_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nspin_lock_irq(&cm->reg_lock);\r\nif (ucontrol->value.enumerated.item[0] == 2)\r\nchange = snd_cmipci_set_bit(cm, CM_REG_LEGACY_CTRL, CM_CENTR2LIN | CM_BASE2LIN);\r\nelse\r\nchange = snd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_CENTR2LIN | CM_BASE2LIN);\r\nif (ucontrol->value.enumerated.item[0] == 1)\r\nchange |= snd_cmipci_set_bit_b(cm, CM_REG_MIXER1, CM_REAR2LIN);\r\nelse\r\nchange |= snd_cmipci_clear_bit_b(cm, CM_REG_MIXER1, CM_REAR2LIN);\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_cmipci_mic_in_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char *const texts[2] = { "Mic-In", "Center/LFE Output" };\r\nreturn snd_ctl_enum_info(uinfo, 1, 2, texts);\r\n}\r\nstatic int snd_cmipci_mic_in_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&cm->reg_lock);\r\nucontrol->value.enumerated.item[0] =\r\n(snd_cmipci_read_b(cm, CM_REG_MISC) & CM_SPDIF_INVERSE) ? 1 : 0;\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_mic_in_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct cmipci *cm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nspin_lock_irq(&cm->reg_lock);\r\nif (ucontrol->value.enumerated.item[0])\r\nchange = snd_cmipci_set_bit_b(cm, CM_REG_MISC, CM_SPDIF_INVERSE);\r\nelse\r\nchange = snd_cmipci_clear_bit_b(cm, CM_REG_MISC, CM_SPDIF_INVERSE);\r\nspin_unlock_irq(&cm->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_cmipci_mixer_new(struct cmipci *cm, int pcm_spdif_device)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_kcontrol_new *sw;\r\nstruct snd_kcontrol *kctl;\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!cm || !cm->card))\r\nreturn -EINVAL;\r\ncard = cm->card;\r\nstrcpy(card->mixername, "CMedia PCI");\r\nspin_lock_irq(&cm->reg_lock);\r\nsnd_cmipci_mixer_write(cm, 0x00, 0x00);\r\nspin_unlock_irq(&cm->reg_lock);\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_mixers); idx++) {\r\nif (cm->chip_version == 68) {\r\nif (!strcmp(snd_cmipci_mixers[idx].name,\r\n"PCM Playback Volume"))\r\ncontinue;\r\n}\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_cmipci_mixers[idx], cm))) < 0)\r\nreturn err;\r\n}\r\nsw = snd_cmipci_mixer_switches;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_mixer_switches); idx++, sw++) {\r\nerr = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (! cm->can_multi_ch) {\r\nerr = snd_ctl_add(cm->card, snd_ctl_new1(&snd_cmipci_nomulti_switch, cm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cm->device == PCI_DEVICE_ID_CMEDIA_CM8738 ||\r\ncm->device == PCI_DEVICE_ID_CMEDIA_CM8738B) {\r\nsw = snd_cmipci_8738_mixer_switches;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_8738_mixer_switches); idx++, sw++) {\r\nerr = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cm->can_ac3_hw) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_cmipci_spdif_default, cm))) < 0)\r\nreturn err;\r\nkctl->id.device = pcm_spdif_device;\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_cmipci_spdif_mask, cm))) < 0)\r\nreturn err;\r\nkctl->id.device = pcm_spdif_device;\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_cmipci_spdif_stream, cm))) < 0)\r\nreturn err;\r\nkctl->id.device = pcm_spdif_device;\r\n}\r\nif (cm->chip_version <= 37) {\r\nsw = snd_cmipci_old_mixer_switches;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_old_mixer_switches); idx++, sw++) {\r\nerr = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\n}\r\nif (cm->chip_version >= 39) {\r\nsw = snd_cmipci_extra_mixer_switches;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_cmipci_extra_mixer_switches); idx++, sw++) {\r\nerr = snd_ctl_add(cm->card, snd_ctl_new1(sw, cm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (cm->chip_version < 39) {\r\nerr = snd_ctl_add(cm->card,\r\nsnd_ctl_new1(&snd_cmipci_modem_switch, cm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (idx = 0; idx < CM_SAVED_MIXERS; idx++) {\r\nstruct snd_ctl_elem_id elem_id;\r\nstruct snd_kcontrol *ctl;\r\nmemset(&elem_id, 0, sizeof(elem_id));\r\nelem_id.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(elem_id.name, cm_saved_mixer[idx].name);\r\nctl = snd_ctl_find_id(cm->card, &elem_id);\r\nif (ctl)\r\ncm->mixer_res_ctl[idx] = ctl;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_cmipci_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct cmipci *cm = entry->private_data;\r\nint i, v;\r\nsnd_iprintf(buffer, "%s\n", cm->card->longname);\r\nfor (i = 0; i < 0x94; i++) {\r\nif (i == 0x28)\r\ni = 0x90;\r\nv = inb(cm->iobase + i);\r\nif (i % 4 == 0)\r\nsnd_iprintf(buffer, "\n%02x:", i);\r\nsnd_iprintf(buffer, " %02x", v);\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void snd_cmipci_proc_init(struct cmipci *cm)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(cm->card, "cmipci", &entry))\r\nsnd_info_set_text_ops(entry, cm, snd_cmipci_proc_read);\r\n}\r\nstatic inline void snd_cmipci_proc_init(struct cmipci *cm) {}\r\nstatic void query_chip(struct cmipci *cm)\r\n{\r\nunsigned int detect;\r\ndetect = snd_cmipci_read(cm, CM_REG_INT_HLDCLR) & CM_CHIP_MASK2;\r\nif (! detect) {\r\ndetect = snd_cmipci_read(cm, CM_REG_CHFORMAT) & CM_CHIP_MASK1;\r\nswitch (detect) {\r\ncase 0:\r\ncm->chip_version = 33;\r\nif (cm->do_soft_ac3)\r\ncm->can_ac3_sw = 1;\r\nelse\r\ncm->can_ac3_hw = 1;\r\nbreak;\r\ncase CM_CHIP_037:\r\ncm->chip_version = 37;\r\ncm->can_ac3_hw = 1;\r\nbreak;\r\ndefault:\r\ncm->chip_version = 39;\r\ncm->can_ac3_hw = 1;\r\nbreak;\r\n}\r\ncm->max_channels = 2;\r\n} else {\r\nif (detect & CM_CHIP_039) {\r\ncm->chip_version = 39;\r\nif (detect & CM_CHIP_039_6CH)\r\ncm->max_channels = 6;\r\nelse\r\ncm->max_channels = 4;\r\n} else if (detect & CM_CHIP_8768) {\r\ncm->chip_version = 68;\r\ncm->max_channels = 8;\r\ncm->can_96k = 1;\r\n} else {\r\ncm->chip_version = 55;\r\ncm->max_channels = 6;\r\ncm->can_96k = 1;\r\n}\r\ncm->can_ac3_hw = 1;\r\ncm->can_multi_ch = 1;\r\n}\r\n}\r\nstatic int snd_cmipci_create_gameport(struct cmipci *cm, int dev)\r\n{\r\nstatic int ports[] = { 0x201, 0x200, 0 };\r\nstruct gameport *gp;\r\nstruct resource *r = NULL;\r\nint i, io_port = 0;\r\nif (joystick_port[dev] == 0)\r\nreturn -ENODEV;\r\nif (joystick_port[dev] == 1) {\r\nfor (i = 0; ports[i]; i++) {\r\nio_port = ports[i];\r\nr = request_region(io_port, 1, "CMIPCI gameport");\r\nif (r)\r\nbreak;\r\n}\r\n} else {\r\nio_port = joystick_port[dev];\r\nr = request_region(io_port, 1, "CMIPCI gameport");\r\n}\r\nif (!r) {\r\ndev_warn(cm->card->dev, "cannot reserve joystick ports\n");\r\nreturn -EBUSY;\r\n}\r\ncm->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\ndev_err(cm->card->dev, "cannot allocate memory for gameport\n");\r\nrelease_and_free_resource(r);\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "C-Media Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(cm->pci));\r\ngameport_set_dev_parent(gp, &cm->pci->dev);\r\ngp->io = io_port;\r\ngameport_set_port_data(gp, r);\r\nsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);\r\ngameport_register_port(cm->gameport);\r\nreturn 0;\r\n}\r\nstatic void snd_cmipci_free_gameport(struct cmipci *cm)\r\n{\r\nif (cm->gameport) {\r\nstruct resource *r = gameport_get_port_data(cm->gameport);\r\ngameport_unregister_port(cm->gameport);\r\ncm->gameport = NULL;\r\nsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);\r\nrelease_and_free_resource(r);\r\n}\r\n}\r\nstatic inline int snd_cmipci_create_gameport(struct cmipci *cm, int dev) { return -ENOSYS; }\r\nstatic inline void snd_cmipci_free_gameport(struct cmipci *cm) { }\r\nstatic int snd_cmipci_free(struct cmipci *cm)\r\n{\r\nif (cm->irq >= 0) {\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);\r\nsnd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_ENSPDOUT);\r\nsnd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);\r\nsnd_cmipci_ch_reset(cm, CM_CH_PLAY);\r\nsnd_cmipci_ch_reset(cm, CM_CH_CAPT);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, 0);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL1, 0);\r\nsnd_cmipci_mixer_write(cm, 0, 0);\r\nfree_irq(cm->irq, cm);\r\n}\r\nsnd_cmipci_free_gameport(cm);\r\npci_release_regions(cm->pci);\r\npci_disable_device(cm->pci);\r\nkfree(cm);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_dev_free(struct snd_device *device)\r\n{\r\nstruct cmipci *cm = device->device_data;\r\nreturn snd_cmipci_free(cm);\r\n}\r\nstatic int snd_cmipci_create_fm(struct cmipci *cm, long fm_port)\r\n{\r\nlong iosynth;\r\nunsigned int val;\r\nstruct snd_opl3 *opl3;\r\nint err;\r\nif (!fm_port)\r\ngoto disable_fm;\r\nif (cm->chip_version >= 39) {\r\niosynth = cm->iobase + CM_REG_FM_PCI;\r\nerr = snd_opl3_create(cm->card, iosynth, iosynth + 2,\r\nOPL3_HW_OPL3, 1, &opl3);\r\n} else {\r\nerr = -EIO;\r\n}\r\nif (err < 0) {\r\nval = snd_cmipci_read(cm, CM_REG_LEGACY_CTRL) & ~CM_FMSEL_MASK;\r\niosynth = fm_port;\r\nswitch (iosynth) {\r\ncase 0x3E8: val |= CM_FMSEL_3E8; break;\r\ncase 0x3E0: val |= CM_FMSEL_3E0; break;\r\ncase 0x3C8: val |= CM_FMSEL_3C8; break;\r\ncase 0x388: val |= CM_FMSEL_388; break;\r\ndefault:\r\ngoto disable_fm;\r\n}\r\nsnd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);\r\nif (snd_opl3_create(cm->card, iosynth, iosynth + 2,\r\nOPL3_HW_OPL3, 0, &opl3) < 0) {\r\ndev_err(cm->card->dev,\r\n"no OPL device at %#lx, skipping...\n",\r\niosynth);\r\ngoto disable_fm;\r\n}\r\n}\r\nif ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {\r\ndev_err(cm->card->dev, "cannot create OPL3 hwdep\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\ndisable_fm:\r\nsnd_cmipci_clear_bit(cm, CM_REG_LEGACY_CTRL, CM_FMSEL_MASK);\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_FM_EN);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_create(struct snd_card *card, struct pci_dev *pci,\r\nint dev, struct cmipci **rcmipci)\r\n{\r\nstruct cmipci *cm;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_cmipci_dev_free,\r\n};\r\nunsigned int val;\r\nlong iomidi = 0;\r\nint integrated_midi = 0;\r\nchar modelstr[16];\r\nint pcm_index, pcm_spdif_index;\r\nstatic const struct pci_device_id intel_82437vx[] = {\r\n{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82437VX) },\r\n{ },\r\n};\r\n*rcmipci = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\ncm = kzalloc(sizeof(*cm), GFP_KERNEL);\r\nif (cm == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&cm->reg_lock);\r\nmutex_init(&cm->open_mutex);\r\ncm->device = pci->device;\r\ncm->card = card;\r\ncm->pci = pci;\r\ncm->irq = -1;\r\ncm->channel[0].ch = 0;\r\ncm->channel[1].ch = 1;\r\ncm->channel[0].is_dac = cm->channel[1].is_dac = 1;\r\nif ((err = pci_request_regions(pci, card->driver)) < 0) {\r\nkfree(cm);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\ncm->iobase = pci_resource_start(pci, 0);\r\nif (request_irq(pci->irq, snd_cmipci_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, cm)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_cmipci_free(cm);\r\nreturn -EBUSY;\r\n}\r\ncm->irq = pci->irq;\r\npci_set_master(cm->pci);\r\ncm->chip_version = 0;\r\ncm->max_channels = 2;\r\ncm->do_soft_ac3 = soft_ac3[dev];\r\nif (pci->device != PCI_DEVICE_ID_CMEDIA_CM8338A &&\r\npci->device != PCI_DEVICE_ID_CMEDIA_CM8338B)\r\nquery_chip(cm);\r\nif (cm->can_multi_ch)\r\nsprintf(cm->card->driver + strlen(cm->card->driver),\r\n"-MC%d", cm->max_channels);\r\nelse if (cm->can_ac3_sw)\r\nstrcpy(cm->card->driver + strlen(cm->card->driver), "-SWIEC");\r\ncm->dig_status = SNDRV_PCM_DEFAULT_CON_SPDIF;\r\ncm->dig_pcm_status = SNDRV_PCM_DEFAULT_CON_SPDIF;\r\n#if CM_CH_PLAY == 1\r\ncm->ctrl = CM_CHADC0;\r\n#else\r\ncm->ctrl = CM_CHADC1;\r\n#endif\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_RESET);\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_RESET);\r\nsnd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);\r\nsnd_cmipci_ch_reset(cm, CM_CH_PLAY);\r\nsnd_cmipci_ch_reset(cm, CM_CH_CAPT);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL0, 0);\r\nsnd_cmipci_write(cm, CM_REG_FUNCTRL1, 0);\r\nsnd_cmipci_write(cm, CM_REG_CHFORMAT, 0);\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_ENDBDAC|CM_N4SPK3D);\r\n#if CM_CH_PLAY == 1\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);\r\n#else\r\nsnd_cmipci_clear_bit(cm, CM_REG_MISC_CTRL, CM_XCHGDAC);\r\n#endif\r\nif (cm->chip_version) {\r\nsnd_cmipci_write_b(cm, CM_REG_EXT_MISC, 0x20);\r\nsnd_cmipci_write_b(cm, CM_REG_EXT_MISC + 1, 0x09);\r\n}\r\nsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_BREQ);\r\nswitch (pci->device) {\r\ncase PCI_DEVICE_ID_CMEDIA_CM8738:\r\ncase PCI_DEVICE_ID_CMEDIA_CM8738B:\r\nif (!pci_dev_present(intel_82437vx))\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_TXVX);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cm->chip_version < 68) {\r\nval = pci->device < 0x110 ? 8338 : 8738;\r\n} else {\r\nswitch (snd_cmipci_read_b(cm, CM_REG_INT_HLDCLR + 3) & 0x03) {\r\ncase 0:\r\nval = 8769;\r\nbreak;\r\ncase 2:\r\nval = 8762;\r\nbreak;\r\ndefault:\r\nswitch ((pci->subsystem_vendor << 16) |\r\npci->subsystem_device) {\r\ncase 0x13f69761:\r\ncase 0x584d3741:\r\ncase 0x584d3751:\r\ncase 0x584d3761:\r\ncase 0x584d3771:\r\ncase 0x72848384:\r\nval = 8770;\r\nbreak;\r\ndefault:\r\nval = 8768;\r\nbreak;\r\n}\r\n}\r\n}\r\nsprintf(card->shortname, "C-Media CMI%d", val);\r\nif (cm->chip_version < 68)\r\nsprintf(modelstr, " (model %d)", cm->chip_version);\r\nelse\r\nmodelstr[0] = '\0';\r\nsprintf(card->longname, "%s%s at %#lx, irq %i",\r\ncard->shortname, modelstr, cm->iobase, cm->irq);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, cm, &ops)) < 0) {\r\nsnd_cmipci_free(cm);\r\nreturn err;\r\n}\r\nif (cm->chip_version >= 39) {\r\nval = snd_cmipci_read_b(cm, CM_REG_MPU_PCI + 1);\r\nif (val != 0x00 && val != 0xff) {\r\niomidi = cm->iobase + CM_REG_MPU_PCI;\r\nintegrated_midi = 1;\r\n}\r\n}\r\nif (!integrated_midi) {\r\nval = 0;\r\niomidi = mpu_port[dev];\r\nswitch (iomidi) {\r\ncase 0x320: val = CM_VMPU_320; break;\r\ncase 0x310: val = CM_VMPU_310; break;\r\ncase 0x300: val = CM_VMPU_300; break;\r\ncase 0x330: val = CM_VMPU_330; break;\r\ndefault:\r\niomidi = 0; break;\r\n}\r\nif (iomidi > 0) {\r\nsnd_cmipci_write(cm, CM_REG_LEGACY_CTRL, val);\r\nsnd_cmipci_set_bit(cm, CM_REG_FUNCTRL1, CM_UART_EN);\r\nif (inb(iomidi + 1) == 0xff) {\r\ndev_err(cm->card->dev,\r\n"cannot enable MPU-401 port at %#lx\n",\r\niomidi);\r\nsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1,\r\nCM_UART_EN);\r\niomidi = 0;\r\n}\r\n}\r\n}\r\nif (cm->chip_version < 68) {\r\nerr = snd_cmipci_create_fm(cm, fm_port[dev]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nsnd_cmipci_mixer_write(cm, 0, 0);\r\nsnd_cmipci_proc_init(cm);\r\npcm_index = pcm_spdif_index = 0;\r\nif ((err = snd_cmipci_pcm_new(cm, pcm_index)) < 0)\r\nreturn err;\r\npcm_index++;\r\nif ((err = snd_cmipci_pcm2_new(cm, pcm_index)) < 0)\r\nreturn err;\r\npcm_index++;\r\nif (cm->can_ac3_hw || cm->can_ac3_sw) {\r\npcm_spdif_index = pcm_index;\r\nif ((err = snd_cmipci_pcm_spdif_new(cm, pcm_index)) < 0)\r\nreturn err;\r\n}\r\nif ((err = snd_cmipci_mixer_new(cm, pcm_spdif_index)) < 0)\r\nreturn err;\r\nif (iomidi > 0) {\r\nif ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,\r\niomidi,\r\n(integrated_midi ?\r\nMPU401_INFO_INTEGRATED : 0) |\r\nMPU401_INFO_IRQ_HOOK,\r\n-1, &cm->rmidi)) < 0) {\r\ndev_err(cm->card->dev,\r\n"no UART401 device at 0x%lx\n", iomidi);\r\n}\r\n}\r\n#ifdef USE_VAR48KRATE\r\nfor (val = 0; val < ARRAY_SIZE(rates); val++)\r\nsnd_cmipci_set_pll(cm, rates[val], val);\r\nsnd_cmipci_set_bit(cm, CM_REG_MISC_CTRL, CM_SPDIF48K|CM_SPDF_AC97);\r\n#endif\r\nif (snd_cmipci_create_gameport(cm, dev) < 0)\r\nsnd_cmipci_clear_bit(cm, CM_REG_FUNCTRL1, CM_JYSTK_EN);\r\n*rcmipci = cm;\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct cmipci *cm;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (! enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nswitch (pci->device) {\r\ncase PCI_DEVICE_ID_CMEDIA_CM8738:\r\ncase PCI_DEVICE_ID_CMEDIA_CM8738B:\r\nstrcpy(card->driver, "CMI8738");\r\nbreak;\r\ncase PCI_DEVICE_ID_CMEDIA_CM8338A:\r\ncase PCI_DEVICE_ID_CMEDIA_CM8338B:\r\nstrcpy(card->driver, "CMI8338");\r\nbreak;\r\ndefault:\r\nstrcpy(card->driver, "CMIPCI");\r\nbreak;\r\n}\r\nif ((err = snd_cmipci_create(card, pci, dev, &cm)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = cm;\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_cmipci_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}\r\nstatic int snd_cmipci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct cmipci *cm = card->private_data;\r\nint i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(cm->pcm);\r\nsnd_pcm_suspend_all(cm->pcm2);\r\nsnd_pcm_suspend_all(cm->pcm_spdif);\r\nfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\r\ncm->saved_regs[i] = snd_cmipci_read(cm, saved_regs[i]);\r\nfor (i = 0; i < ARRAY_SIZE(saved_mixers); i++)\r\ncm->saved_mixers[i] = snd_cmipci_mixer_read(cm, saved_mixers[i]);\r\nsnd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_cmipci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct cmipci *cm = card->private_data;\r\nint i;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\ndev_err(dev, "pci_enable_device failed, disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_cmipci_write(cm, CM_REG_INT_HLDCLR, 0);\r\nsnd_cmipci_ch_reset(cm, CM_CH_PLAY);\r\nsnd_cmipci_ch_reset(cm, CM_CH_CAPT);\r\nsnd_cmipci_mixer_write(cm, 0, 0);\r\nfor (i = 0; i < ARRAY_SIZE(saved_regs); i++)\r\nsnd_cmipci_write(cm, saved_regs[i], cm->saved_regs[i]);\r\nfor (i = 0; i < ARRAY_SIZE(saved_mixers); i++)\r\nsnd_cmipci_mixer_write(cm, saved_mixers[i], cm->saved_mixers[i]);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
