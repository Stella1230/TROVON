static u16 range_n_bytes(const struct sw_flow_key_range *range)\r\n{\r\nreturn range->end - range->start;\r\n}\r\nvoid ovs_flow_mask_key(struct sw_flow_key *dst, const struct sw_flow_key *src,\r\nconst struct sw_flow_mask *mask)\r\n{\r\nconst long *m = (const long *)((const u8 *)&mask->key +\r\nmask->range.start);\r\nconst long *s = (const long *)((const u8 *)src +\r\nmask->range.start);\r\nlong *d = (long *)((u8 *)dst + mask->range.start);\r\nint i;\r\nfor (i = 0; i < range_n_bytes(&mask->range); i += sizeof(long))\r\n*d++ = *s++ & *m++;\r\n}\r\nstruct sw_flow *ovs_flow_alloc(void)\r\n{\r\nstruct sw_flow *flow;\r\nstruct flow_stats *stats;\r\nint node;\r\nflow = kmem_cache_alloc(flow_cache, GFP_KERNEL);\r\nif (!flow)\r\nreturn ERR_PTR(-ENOMEM);\r\nflow->sf_acts = NULL;\r\nflow->mask = NULL;\r\nflow->stats_last_writer = NUMA_NO_NODE;\r\nstats = kmem_cache_alloc_node(flow_stats_cache,\r\nGFP_KERNEL | __GFP_ZERO, 0);\r\nif (!stats)\r\ngoto err;\r\nspin_lock_init(&stats->lock);\r\nRCU_INIT_POINTER(flow->stats[0], stats);\r\nfor_each_node(node)\r\nif (node != 0)\r\nRCU_INIT_POINTER(flow->stats[node], NULL);\r\nreturn flow;\r\nerr:\r\nkmem_cache_free(flow_cache, flow);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nint ovs_flow_tbl_count(struct flow_table *table)\r\n{\r\nreturn table->count;\r\n}\r\nstatic struct flex_array *alloc_buckets(unsigned int n_buckets)\r\n{\r\nstruct flex_array *buckets;\r\nint i, err;\r\nbuckets = flex_array_alloc(sizeof(struct hlist_head),\r\nn_buckets, GFP_KERNEL);\r\nif (!buckets)\r\nreturn NULL;\r\nerr = flex_array_prealloc(buckets, 0, n_buckets, GFP_KERNEL);\r\nif (err) {\r\nflex_array_free(buckets);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < n_buckets; i++)\r\nINIT_HLIST_HEAD((struct hlist_head *)\r\nflex_array_get(buckets, i));\r\nreturn buckets;\r\n}\r\nstatic void flow_free(struct sw_flow *flow)\r\n{\r\nint node;\r\nkfree((struct sw_flow_actions __force *)flow->sf_acts);\r\nfor_each_node(node)\r\nif (flow->stats[node])\r\nkmem_cache_free(flow_stats_cache,\r\n(struct flow_stats __force *)flow->stats[node]);\r\nkmem_cache_free(flow_cache, flow);\r\n}\r\nstatic void rcu_free_flow_callback(struct rcu_head *rcu)\r\n{\r\nstruct sw_flow *flow = container_of(rcu, struct sw_flow, rcu);\r\nflow_free(flow);\r\n}\r\nvoid ovs_flow_free(struct sw_flow *flow, bool deferred)\r\n{\r\nif (!flow)\r\nreturn;\r\nif (deferred)\r\ncall_rcu(&flow->rcu, rcu_free_flow_callback);\r\nelse\r\nflow_free(flow);\r\n}\r\nstatic void free_buckets(struct flex_array *buckets)\r\n{\r\nflex_array_free(buckets);\r\n}\r\nstatic void __table_instance_destroy(struct table_instance *ti)\r\n{\r\nfree_buckets(ti->buckets);\r\nkfree(ti);\r\n}\r\nstatic struct table_instance *table_instance_alloc(int new_size)\r\n{\r\nstruct table_instance *ti = kmalloc(sizeof(*ti), GFP_KERNEL);\r\nif (!ti)\r\nreturn NULL;\r\nti->buckets = alloc_buckets(new_size);\r\nif (!ti->buckets) {\r\nkfree(ti);\r\nreturn NULL;\r\n}\r\nti->n_buckets = new_size;\r\nti->node_ver = 0;\r\nti->keep_flows = false;\r\nget_random_bytes(&ti->hash_seed, sizeof(u32));\r\nreturn ti;\r\n}\r\nint ovs_flow_tbl_init(struct flow_table *table)\r\n{\r\nstruct table_instance *ti;\r\nti = table_instance_alloc(TBL_MIN_BUCKETS);\r\nif (!ti)\r\nreturn -ENOMEM;\r\nrcu_assign_pointer(table->ti, ti);\r\nINIT_LIST_HEAD(&table->mask_list);\r\ntable->last_rehash = jiffies;\r\ntable->count = 0;\r\nreturn 0;\r\n}\r\nstatic void flow_tbl_destroy_rcu_cb(struct rcu_head *rcu)\r\n{\r\nstruct table_instance *ti = container_of(rcu, struct table_instance, rcu);\r\n__table_instance_destroy(ti);\r\n}\r\nstatic void table_instance_destroy(struct table_instance *ti, bool deferred)\r\n{\r\nint i;\r\nif (!ti)\r\nreturn;\r\nif (ti->keep_flows)\r\ngoto skip_flows;\r\nfor (i = 0; i < ti->n_buckets; i++) {\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head = flex_array_get(ti->buckets, i);\r\nstruct hlist_node *n;\r\nint ver = ti->node_ver;\r\nhlist_for_each_entry_safe(flow, n, head, hash_node[ver]) {\r\nhlist_del_rcu(&flow->hash_node[ver]);\r\novs_flow_free(flow, deferred);\r\n}\r\n}\r\nskip_flows:\r\nif (deferred)\r\ncall_rcu(&ti->rcu, flow_tbl_destroy_rcu_cb);\r\nelse\r\n__table_instance_destroy(ti);\r\n}\r\nvoid ovs_flow_tbl_destroy(struct flow_table *table, bool deferred)\r\n{\r\nstruct table_instance *ti = ovsl_dereference(table->ti);\r\ntable_instance_destroy(ti, deferred);\r\n}\r\nstruct sw_flow *ovs_flow_tbl_dump_next(struct table_instance *ti,\r\nu32 *bucket, u32 *last)\r\n{\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head;\r\nint ver;\r\nint i;\r\nver = ti->node_ver;\r\nwhile (*bucket < ti->n_buckets) {\r\ni = 0;\r\nhead = flex_array_get(ti->buckets, *bucket);\r\nhlist_for_each_entry_rcu(flow, head, hash_node[ver]) {\r\nif (i < *last) {\r\ni++;\r\ncontinue;\r\n}\r\n*last = i + 1;\r\nreturn flow;\r\n}\r\n(*bucket)++;\r\n*last = 0;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_head *find_bucket(struct table_instance *ti, u32 hash)\r\n{\r\nhash = jhash_1word(hash, ti->hash_seed);\r\nreturn flex_array_get(ti->buckets,\r\n(hash & (ti->n_buckets - 1)));\r\n}\r\nstatic void table_instance_insert(struct table_instance *ti, struct sw_flow *flow)\r\n{\r\nstruct hlist_head *head;\r\nhead = find_bucket(ti, flow->hash);\r\nhlist_add_head_rcu(&flow->hash_node[ti->node_ver], head);\r\n}\r\nstatic void flow_table_copy_flows(struct table_instance *old,\r\nstruct table_instance *new)\r\n{\r\nint old_ver;\r\nint i;\r\nold_ver = old->node_ver;\r\nnew->node_ver = !old_ver;\r\nfor (i = 0; i < old->n_buckets; i++) {\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head;\r\nhead = flex_array_get(old->buckets, i);\r\nhlist_for_each_entry(flow, head, hash_node[old_ver])\r\ntable_instance_insert(new, flow);\r\n}\r\nold->keep_flows = true;\r\n}\r\nstatic struct table_instance *table_instance_rehash(struct table_instance *ti,\r\nint n_buckets)\r\n{\r\nstruct table_instance *new_ti;\r\nnew_ti = table_instance_alloc(n_buckets);\r\nif (!new_ti)\r\nreturn NULL;\r\nflow_table_copy_flows(ti, new_ti);\r\nreturn new_ti;\r\n}\r\nint ovs_flow_tbl_flush(struct flow_table *flow_table)\r\n{\r\nstruct table_instance *old_ti;\r\nstruct table_instance *new_ti;\r\nold_ti = ovsl_dereference(flow_table->ti);\r\nnew_ti = table_instance_alloc(TBL_MIN_BUCKETS);\r\nif (!new_ti)\r\nreturn -ENOMEM;\r\nrcu_assign_pointer(flow_table->ti, new_ti);\r\nflow_table->last_rehash = jiffies;\r\nflow_table->count = 0;\r\ntable_instance_destroy(old_ti, true);\r\nreturn 0;\r\n}\r\nstatic u32 flow_hash(const struct sw_flow_key *key, int key_start,\r\nint key_end)\r\n{\r\nconst u32 *hash_key = (const u32 *)((const u8 *)key + key_start);\r\nint hash_u32s = (key_end - key_start) >> 2;\r\nBUILD_BUG_ON(sizeof(long) % sizeof(u32));\r\nreturn arch_fast_hash2(hash_key, hash_u32s, 0);\r\n}\r\nstatic int flow_key_start(const struct sw_flow_key *key)\r\n{\r\nif (key->tun_key.ipv4_dst)\r\nreturn 0;\r\nelse\r\nreturn rounddown(offsetof(struct sw_flow_key, phy),\r\nsizeof(long));\r\n}\r\nstatic bool cmp_key(const struct sw_flow_key *key1,\r\nconst struct sw_flow_key *key2,\r\nint key_start, int key_end)\r\n{\r\nconst long *cp1 = (const long *)((const u8 *)key1 + key_start);\r\nconst long *cp2 = (const long *)((const u8 *)key2 + key_start);\r\nlong diffs = 0;\r\nint i;\r\nfor (i = key_start; i < key_end; i += sizeof(long))\r\ndiffs |= *cp1++ ^ *cp2++;\r\nreturn diffs == 0;\r\n}\r\nstatic bool flow_cmp_masked_key(const struct sw_flow *flow,\r\nconst struct sw_flow_key *key,\r\nint key_start, int key_end)\r\n{\r\nreturn cmp_key(&flow->key, key, key_start, key_end);\r\n}\r\nbool ovs_flow_cmp_unmasked_key(const struct sw_flow *flow,\r\nstruct sw_flow_match *match)\r\n{\r\nstruct sw_flow_key *key = match->key;\r\nint key_start = flow_key_start(key);\r\nint key_end = match->range.end;\r\nreturn cmp_key(&flow->unmasked_key, key, key_start, key_end);\r\n}\r\nstatic struct sw_flow *masked_flow_lookup(struct table_instance *ti,\r\nconst struct sw_flow_key *unmasked,\r\nstruct sw_flow_mask *mask)\r\n{\r\nstruct sw_flow *flow;\r\nstruct hlist_head *head;\r\nint key_start = mask->range.start;\r\nint key_end = mask->range.end;\r\nu32 hash;\r\nstruct sw_flow_key masked_key;\r\novs_flow_mask_key(&masked_key, unmasked, mask);\r\nhash = flow_hash(&masked_key, key_start, key_end);\r\nhead = find_bucket(ti, hash);\r\nhlist_for_each_entry_rcu(flow, head, hash_node[ti->node_ver]) {\r\nif (flow->mask == mask && flow->hash == hash &&\r\nflow_cmp_masked_key(flow, &masked_key,\r\nkey_start, key_end))\r\nreturn flow;\r\n}\r\nreturn NULL;\r\n}\r\nstruct sw_flow *ovs_flow_tbl_lookup_stats(struct flow_table *tbl,\r\nconst struct sw_flow_key *key,\r\nu32 *n_mask_hit)\r\n{\r\nstruct table_instance *ti = rcu_dereference_ovsl(tbl->ti);\r\nstruct sw_flow_mask *mask;\r\nstruct sw_flow *flow;\r\n*n_mask_hit = 0;\r\nlist_for_each_entry_rcu(mask, &tbl->mask_list, list) {\r\n(*n_mask_hit)++;\r\nflow = masked_flow_lookup(ti, key, mask);\r\nif (flow)\r\nreturn flow;\r\n}\r\nreturn NULL;\r\n}\r\nstruct sw_flow *ovs_flow_tbl_lookup(struct flow_table *tbl,\r\nconst struct sw_flow_key *key)\r\n{\r\nu32 __always_unused n_mask_hit;\r\nreturn ovs_flow_tbl_lookup_stats(tbl, key, &n_mask_hit);\r\n}\r\nstruct sw_flow *ovs_flow_tbl_lookup_exact(struct flow_table *tbl,\r\nstruct sw_flow_match *match)\r\n{\r\nstruct table_instance *ti = rcu_dereference_ovsl(tbl->ti);\r\nstruct sw_flow_mask *mask;\r\nstruct sw_flow *flow;\r\nlist_for_each_entry(mask, &tbl->mask_list, list) {\r\nflow = masked_flow_lookup(ti, match->key, mask);\r\nif (flow && ovs_flow_cmp_unmasked_key(flow, match))\r\nreturn flow;\r\n}\r\nreturn NULL;\r\n}\r\nint ovs_flow_tbl_num_masks(const struct flow_table *table)\r\n{\r\nstruct sw_flow_mask *mask;\r\nint num = 0;\r\nlist_for_each_entry(mask, &table->mask_list, list)\r\nnum++;\r\nreturn num;\r\n}\r\nstatic struct table_instance *table_instance_expand(struct table_instance *ti)\r\n{\r\nreturn table_instance_rehash(ti, ti->n_buckets * 2);\r\n}\r\nstatic void flow_mask_remove(struct flow_table *tbl, struct sw_flow_mask *mask)\r\n{\r\nif (mask) {\r\nASSERT_OVSL();\r\nBUG_ON(!mask->ref_count);\r\nmask->ref_count--;\r\nif (!mask->ref_count) {\r\nlist_del_rcu(&mask->list);\r\nkfree_rcu(mask, rcu);\r\n}\r\n}\r\n}\r\nvoid ovs_flow_tbl_remove(struct flow_table *table, struct sw_flow *flow)\r\n{\r\nstruct table_instance *ti = ovsl_dereference(table->ti);\r\nBUG_ON(table->count == 0);\r\nhlist_del_rcu(&flow->hash_node[ti->node_ver]);\r\ntable->count--;\r\nflow_mask_remove(table, flow->mask);\r\n}\r\nstatic struct sw_flow_mask *mask_alloc(void)\r\n{\r\nstruct sw_flow_mask *mask;\r\nmask = kmalloc(sizeof(*mask), GFP_KERNEL);\r\nif (mask)\r\nmask->ref_count = 1;\r\nreturn mask;\r\n}\r\nstatic bool mask_equal(const struct sw_flow_mask *a,\r\nconst struct sw_flow_mask *b)\r\n{\r\nconst u8 *a_ = (const u8 *)&a->key + a->range.start;\r\nconst u8 *b_ = (const u8 *)&b->key + b->range.start;\r\nreturn (a->range.end == b->range.end)\r\n&& (a->range.start == b->range.start)\r\n&& (memcmp(a_, b_, range_n_bytes(&a->range)) == 0);\r\n}\r\nstatic struct sw_flow_mask *flow_mask_find(const struct flow_table *tbl,\r\nconst struct sw_flow_mask *mask)\r\n{\r\nstruct list_head *ml;\r\nlist_for_each(ml, &tbl->mask_list) {\r\nstruct sw_flow_mask *m;\r\nm = container_of(ml, struct sw_flow_mask, list);\r\nif (mask_equal(mask, m))\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int flow_mask_insert(struct flow_table *tbl, struct sw_flow *flow,\r\nstruct sw_flow_mask *new)\r\n{\r\nstruct sw_flow_mask *mask;\r\nmask = flow_mask_find(tbl, new);\r\nif (!mask) {\r\nmask = mask_alloc();\r\nif (!mask)\r\nreturn -ENOMEM;\r\nmask->key = new->key;\r\nmask->range = new->range;\r\nlist_add_rcu(&mask->list, &tbl->mask_list);\r\n} else {\r\nBUG_ON(!mask->ref_count);\r\nmask->ref_count++;\r\n}\r\nflow->mask = mask;\r\nreturn 0;\r\n}\r\nint ovs_flow_tbl_insert(struct flow_table *table, struct sw_flow *flow,\r\nstruct sw_flow_mask *mask)\r\n{\r\nstruct table_instance *new_ti = NULL;\r\nstruct table_instance *ti;\r\nint err;\r\nerr = flow_mask_insert(table, flow, mask);\r\nif (err)\r\nreturn err;\r\nflow->hash = flow_hash(&flow->key, flow->mask->range.start,\r\nflow->mask->range.end);\r\nti = ovsl_dereference(table->ti);\r\ntable_instance_insert(ti, flow);\r\ntable->count++;\r\nif (table->count > ti->n_buckets)\r\nnew_ti = table_instance_expand(ti);\r\nelse if (time_after(jiffies, table->last_rehash + REHASH_INTERVAL))\r\nnew_ti = table_instance_rehash(ti, ti->n_buckets);\r\nif (new_ti) {\r\nrcu_assign_pointer(table->ti, new_ti);\r\ntable_instance_destroy(ti, true);\r\ntable->last_rehash = jiffies;\r\n}\r\nreturn 0;\r\n}\r\nint ovs_flow_init(void)\r\n{\r\nBUILD_BUG_ON(__alignof__(struct sw_flow_key) % __alignof__(long));\r\nBUILD_BUG_ON(sizeof(struct sw_flow_key) % sizeof(long));\r\nflow_cache = kmem_cache_create("sw_flow", sizeof(struct sw_flow)\r\n+ (num_possible_nodes()\r\n* sizeof(struct flow_stats *)),\r\n0, 0, NULL);\r\nif (flow_cache == NULL)\r\nreturn -ENOMEM;\r\nflow_stats_cache\r\n= kmem_cache_create("sw_flow_stats", sizeof(struct flow_stats),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (flow_stats_cache == NULL) {\r\nkmem_cache_destroy(flow_cache);\r\nflow_cache = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid ovs_flow_exit(void)\r\n{\r\nkmem_cache_destroy(flow_stats_cache);\r\nkmem_cache_destroy(flow_cache);\r\n}
