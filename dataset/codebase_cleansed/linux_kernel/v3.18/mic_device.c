static void mic_notify_host(u8 state)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nstruct mic_bootparam __iomem *bootparam = mdrv->dp;\r\niowrite8(state, &bootparam->shutdown_status);\r\ndev_dbg(mdrv->dev, "%s %d system_state %d\n",\r\n__func__, __LINE__, state);\r\nmic_send_intr(&mdrv->mdev, ioread8(&bootparam->c2h_shutdown_db));\r\n}\r\nstatic int mic_panic_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nstruct mic_bootparam __iomem *bootparam = mdrv->dp;\r\niowrite8(-1, &bootparam->h2c_config_db);\r\niowrite8(-1, &bootparam->h2c_shutdown_db);\r\nmic_notify_host(MIC_CRASHED);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic irqreturn_t mic_shutdown_isr(int irq, void *data)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nstruct mic_bootparam __iomem *bootparam = mdrv->dp;\r\nmic_ack_interrupt(&g_drv->mdev);\r\nif (ioread8(&bootparam->shutdown_card))\r\norderly_poweroff(true);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mic_shutdown_init(void)\r\n{\r\nint rc = 0;\r\nstruct mic_driver *mdrv = g_drv;\r\nstruct mic_bootparam __iomem *bootparam = mdrv->dp;\r\nint shutdown_db;\r\nshutdown_db = mic_next_card_db();\r\nshutdown_cookie = mic_request_card_irq(mic_shutdown_isr, NULL,\r\n"Shutdown", mdrv, shutdown_db);\r\nif (IS_ERR(shutdown_cookie))\r\nrc = PTR_ERR(shutdown_cookie);\r\nelse\r\niowrite8(shutdown_db, &bootparam->h2c_shutdown_db);\r\nreturn rc;\r\n}\r\nstatic void mic_shutdown_uninit(void)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nstruct mic_bootparam __iomem *bootparam = mdrv->dp;\r\niowrite8(-1, &bootparam->h2c_shutdown_db);\r\nmic_free_card_irq(shutdown_cookie, mdrv);\r\n}\r\nstatic int __init mic_dp_init(void)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nstruct mic_device *mdev = &mdrv->mdev;\r\nstruct mic_bootparam __iomem *bootparam;\r\nu64 lo, hi, dp_dma_addr;\r\nu32 magic;\r\nlo = mic_read_spad(&mdrv->mdev, MIC_DPLO_SPAD);\r\nhi = mic_read_spad(&mdrv->mdev, MIC_DPHI_SPAD);\r\ndp_dma_addr = lo | (hi << 32);\r\nmdrv->dp = mic_card_map(mdev, dp_dma_addr, MIC_DP_SIZE);\r\nif (!mdrv->dp) {\r\ndev_err(mdrv->dev, "Cannot remap Aperture BAR\n");\r\nreturn -ENOMEM;\r\n}\r\nbootparam = mdrv->dp;\r\nmagic = ioread32(&bootparam->magic);\r\nif (MIC_MAGIC != magic) {\r\ndev_err(mdrv->dev, "bootparam magic mismatch 0x%x\n", magic);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mic_dp_uninit(void)\r\n{\r\nmic_card_unmap(&g_drv->mdev, g_drv->dp);\r\n}\r\nstruct mic_irq *\r\nmic_request_card_irq(irq_handler_t handler,\r\nirq_handler_t thread_fn, const char *name,\r\nvoid *data, int index)\r\n{\r\nint rc = 0;\r\nunsigned long cookie;\r\nstruct mic_driver *mdrv = g_drv;\r\nrc = request_threaded_irq(mic_db_to_irq(mdrv, index), handler,\r\nthread_fn, 0, name, data);\r\nif (rc) {\r\ndev_err(mdrv->dev, "request_threaded_irq failed rc = %d\n", rc);\r\ngoto err;\r\n}\r\nmdrv->irq_info.irq_usage_count[index]++;\r\ncookie = index;\r\nreturn (struct mic_irq *)cookie;\r\nerr:\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid mic_free_card_irq(struct mic_irq *cookie, void *data)\r\n{\r\nint index;\r\nstruct mic_driver *mdrv = g_drv;\r\nindex = (unsigned long)cookie & 0xFFFFU;\r\nfree_irq(mic_db_to_irq(mdrv, index), data);\r\nmdrv->irq_info.irq_usage_count[index]--;\r\n}\r\nint mic_next_card_db(void)\r\n{\r\nint i;\r\nint index = 0;\r\nstruct mic_driver *mdrv = g_drv;\r\nfor (i = 0; i < mdrv->intr_info.num_intr; i++) {\r\nif (mdrv->irq_info.irq_usage_count[i] <\r\nmdrv->irq_info.irq_usage_count[index])\r\nindex = i;\r\n}\r\nreturn index;\r\n}\r\nstatic int mic_init_irq(void)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nmdrv->irq_info.irq_usage_count = kzalloc((sizeof(u32) *\r\nmdrv->intr_info.num_intr),\r\nGFP_KERNEL);\r\nif (!mdrv->irq_info.irq_usage_count)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void mic_uninit_irq(void)\r\n{\r\nstruct mic_driver *mdrv = g_drv;\r\nkfree(mdrv->irq_info.irq_usage_count);\r\n}\r\nint __init mic_driver_init(struct mic_driver *mdrv)\r\n{\r\nint rc;\r\ng_drv = mdrv;\r\nif (!try_module_get(mdrv->dev->driver->owner)) {\r\nrc = -ENODEV;\r\ngoto done;\r\n}\r\nrc = mic_dp_init();\r\nif (rc)\r\ngoto put;\r\nrc = mic_init_irq();\r\nif (rc)\r\ngoto dp_uninit;\r\nrc = mic_shutdown_init();\r\nif (rc)\r\ngoto irq_uninit;\r\nrc = mic_devices_init(mdrv);\r\nif (rc)\r\ngoto shutdown_uninit;\r\nmic_create_card_debug_dir(mdrv);\r\natomic_notifier_chain_register(&panic_notifier_list, &mic_panic);\r\ndone:\r\nreturn rc;\r\nshutdown_uninit:\r\nmic_shutdown_uninit();\r\nirq_uninit:\r\nmic_uninit_irq();\r\ndp_uninit:\r\nmic_dp_uninit();\r\nput:\r\nmodule_put(mdrv->dev->driver->owner);\r\nreturn rc;\r\n}\r\nvoid mic_driver_uninit(struct mic_driver *mdrv)\r\n{\r\nmic_delete_card_debug_dir(mdrv);\r\nmic_devices_uninit(mdrv);\r\nmic_notify_host(system_state);\r\nmic_shutdown_uninit();\r\nmic_uninit_irq();\r\nmic_dp_uninit();\r\nmodule_put(mdrv->dev->driver->owner);\r\n}
