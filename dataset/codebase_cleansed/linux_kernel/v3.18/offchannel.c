static void ieee80211_offchannel_ps_enable(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\r\nlocal->offchannel_ps_enabled = false;\r\ndel_timer_sync(&local->dynamic_ps_timer);\r\ndel_timer_sync(&ifmgd->bcn_mon_timer);\r\ndel_timer_sync(&ifmgd->conn_mon_timer);\r\ncancel_work_sync(&local->dynamic_ps_enable_work);\r\nif (local->hw.conf.flags & IEEE80211_CONF_PS) {\r\nlocal->offchannel_ps_enabled = true;\r\nlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\r\nieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\r\n}\r\nif (!local->offchannel_ps_enabled ||\r\n!(local->hw.flags & IEEE80211_HW_PS_NULLFUNC_STACK))\r\nieee80211_send_nullfunc(local, sdata, 1);\r\n}\r\nstatic void ieee80211_offchannel_ps_disable(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nif (!local->ps_sdata)\r\nieee80211_send_nullfunc(local, sdata, 0);\r\nelse if (local->offchannel_ps_enabled) {\r\nlocal->hw.conf.flags |= IEEE80211_CONF_PS;\r\nieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\r\n} else if (local->hw.conf.dynamic_ps_timeout > 0) {\r\nieee80211_send_nullfunc(local, sdata, 0);\r\nmod_timer(&local->dynamic_ps_timer, jiffies +\r\nmsecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\r\n}\r\nieee80211_sta_reset_beacon_monitor(sdata);\r\nieee80211_sta_reset_conn_monitor(sdata);\r\n}\r\nvoid ieee80211_offchannel_stop_vifs(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nif (WARN_ON(local->use_chanctx))\r\nreturn;\r\nieee80211_stop_queues_by_reason(&local->hw, IEEE80211_MAX_QUEUE_MAP,\r\nIEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,\r\nfalse);\r\nieee80211_flush_queues(local, NULL);\r\nmutex_lock(&local->iflist_mtx);\r\nlist_for_each_entry(sdata, &local->interfaces, list) {\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)\r\ncontinue;\r\nif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\r\nset_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\r\nif (sdata->vif.bss_conf.enable_beacon) {\r\nset_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED,\r\n&sdata->state);\r\nsdata->vif.bss_conf.enable_beacon = false;\r\nieee80211_bss_info_change_notify(\r\nsdata, BSS_CHANGED_BEACON_ENABLED);\r\n}\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION &&\r\nsdata->u.mgd.associated)\r\nieee80211_offchannel_ps_enable(sdata);\r\n}\r\nmutex_unlock(&local->iflist_mtx);\r\n}\r\nvoid ieee80211_offchannel_return(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nif (WARN_ON(local->use_chanctx))\r\nreturn;\r\nmutex_lock(&local->iflist_mtx);\r\nlist_for_each_entry(sdata, &local->interfaces, list) {\r\nif (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)\r\ncontinue;\r\nif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\r\nclear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION &&\r\nsdata->u.mgd.associated)\r\nieee80211_offchannel_ps_disable(sdata);\r\nif (test_and_clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED,\r\n&sdata->state)) {\r\nsdata->vif.bss_conf.enable_beacon = true;\r\nieee80211_bss_info_change_notify(\r\nsdata, BSS_CHANGED_BEACON_ENABLED);\r\n}\r\n}\r\nmutex_unlock(&local->iflist_mtx);\r\nieee80211_wake_queues_by_reason(&local->hw, IEEE80211_MAX_QUEUE_MAP,\r\nIEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,\r\nfalse);\r\n}\r\nvoid ieee80211_handle_roc_started(struct ieee80211_roc_work *roc)\r\n{\r\nif (roc->notified)\r\nreturn;\r\nif (roc->mgmt_tx_cookie) {\r\nif (!WARN_ON(!roc->frame)) {\r\nieee80211_tx_skb_tid_band(roc->sdata, roc->frame, 7,\r\nroc->chan->band);\r\nroc->frame = NULL;\r\n}\r\n} else {\r\ncfg80211_ready_on_channel(&roc->sdata->wdev, roc->cookie,\r\nroc->chan, roc->req_duration,\r\nGFP_KERNEL);\r\n}\r\nroc->notified = true;\r\n}\r\nstatic void ieee80211_hw_roc_start(struct work_struct *work)\r\n{\r\nstruct ieee80211_local *local =\r\ncontainer_of(work, struct ieee80211_local, hw_roc_start);\r\nstruct ieee80211_roc_work *roc, *dep, *tmp;\r\nmutex_lock(&local->mtx);\r\nif (list_empty(&local->roc_list))\r\ngoto out_unlock;\r\nroc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,\r\nlist);\r\nif (!roc->started)\r\ngoto out_unlock;\r\nroc->hw_begun = true;\r\nroc->hw_start_time = local->hw_roc_start_time;\r\nieee80211_handle_roc_started(roc);\r\nlist_for_each_entry_safe(dep, tmp, &roc->dependents, list) {\r\nieee80211_handle_roc_started(dep);\r\nif (dep->duration > roc->duration) {\r\nu32 dur = dep->duration;\r\ndep->duration = dur - roc->duration;\r\nroc->duration = dur;\r\nlist_move(&dep->list, &roc->list);\r\n}\r\n}\r\nout_unlock:\r\nmutex_unlock(&local->mtx);\r\n}\r\nvoid ieee80211_ready_on_channel(struct ieee80211_hw *hw)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nlocal->hw_roc_start_time = jiffies;\r\ntrace_api_ready_on_channel(local);\r\nieee80211_queue_work(hw, &local->hw_roc_start);\r\n}\r\nvoid ieee80211_start_next_roc(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_roc_work *roc;\r\nlockdep_assert_held(&local->mtx);\r\nif (list_empty(&local->roc_list)) {\r\nieee80211_run_deferred_scan(local);\r\nreturn;\r\n}\r\nroc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,\r\nlist);\r\nif (WARN_ON_ONCE(roc->started))\r\nreturn;\r\nif (local->ops->remain_on_channel) {\r\nint ret, duration = roc->duration;\r\nif (!duration)\r\nduration = 10;\r\nret = drv_remain_on_channel(local, roc->sdata, roc->chan,\r\nduration, roc->type);\r\nroc->started = true;\r\nif (ret) {\r\nwiphy_warn(local->hw.wiphy,\r\n"failed to start next HW ROC (%d)\n", ret);\r\nieee80211_remain_on_channel_expired(&local->hw);\r\n}\r\n} else {\r\nieee80211_queue_delayed_work(&local->hw, &roc->work,\r\nround_jiffies_relative(HZ/2));\r\n}\r\n}\r\nvoid ieee80211_roc_notify_destroy(struct ieee80211_roc_work *roc, bool free)\r\n{\r\nstruct ieee80211_roc_work *dep, *tmp;\r\nif (WARN_ON(roc->to_be_freed))\r\nreturn;\r\nif (roc->frame) {\r\ncfg80211_mgmt_tx_status(&roc->sdata->wdev,\r\n(unsigned long)roc->frame,\r\nroc->frame->data, roc->frame->len,\r\nfalse, GFP_KERNEL);\r\nkfree_skb(roc->frame);\r\n}\r\nif (!roc->mgmt_tx_cookie)\r\ncfg80211_remain_on_channel_expired(&roc->sdata->wdev,\r\nroc->cookie, roc->chan,\r\nGFP_KERNEL);\r\nlist_for_each_entry_safe(dep, tmp, &roc->dependents, list)\r\nieee80211_roc_notify_destroy(dep, true);\r\nif (free)\r\nkfree(roc);\r\nelse\r\nroc->to_be_freed = true;\r\n}\r\nvoid ieee80211_sw_roc_work(struct work_struct *work)\r\n{\r\nstruct ieee80211_roc_work *roc =\r\ncontainer_of(work, struct ieee80211_roc_work, work.work);\r\nstruct ieee80211_sub_if_data *sdata = roc->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nbool started, on_channel;\r\nmutex_lock(&local->mtx);\r\nif (roc->to_be_freed)\r\ngoto out_unlock;\r\nif (roc->abort)\r\ngoto finish;\r\nif (WARN_ON(list_empty(&local->roc_list)))\r\ngoto out_unlock;\r\nif (WARN_ON(roc != list_first_entry(&local->roc_list,\r\nstruct ieee80211_roc_work,\r\nlist)))\r\ngoto out_unlock;\r\nif (!roc->started) {\r\nstruct ieee80211_roc_work *dep;\r\nWARN_ON(local->use_chanctx);\r\nroc->on_channel = roc->chan == local->_oper_chandef.chan &&\r\nlocal->_oper_chandef.width != NL80211_CHAN_WIDTH_5 &&\r\nlocal->_oper_chandef.width != NL80211_CHAN_WIDTH_10;\r\nieee80211_recalc_idle(local);\r\nif (!roc->on_channel) {\r\nieee80211_offchannel_stop_vifs(local);\r\nlocal->tmp_channel = roc->chan;\r\nieee80211_hw_config(local, 0);\r\n}\r\nieee80211_handle_roc_started(roc);\r\nlist_for_each_entry(dep, &roc->dependents, list)\r\nieee80211_handle_roc_started(dep);\r\nif (!roc->duration)\r\ngoto finish;\r\nroc->started = true;\r\nieee80211_queue_delayed_work(&local->hw, &roc->work,\r\nmsecs_to_jiffies(roc->duration));\r\n} else {\r\nfinish:\r\nlist_del(&roc->list);\r\nstarted = roc->started;\r\non_channel = roc->on_channel;\r\nieee80211_roc_notify_destroy(roc, !roc->abort);\r\nif (started && !on_channel) {\r\nieee80211_flush_queues(local, NULL);\r\nlocal->tmp_channel = NULL;\r\nieee80211_hw_config(local, 0);\r\nieee80211_offchannel_return(local);\r\n}\r\nieee80211_recalc_idle(local);\r\nif (started)\r\nieee80211_start_next_roc(local);\r\nelse if (list_empty(&local->roc_list))\r\nieee80211_run_deferred_scan(local);\r\n}\r\nout_unlock:\r\nmutex_unlock(&local->mtx);\r\n}\r\nstatic void ieee80211_hw_roc_done(struct work_struct *work)\r\n{\r\nstruct ieee80211_local *local =\r\ncontainer_of(work, struct ieee80211_local, hw_roc_done);\r\nstruct ieee80211_roc_work *roc;\r\nmutex_lock(&local->mtx);\r\nif (list_empty(&local->roc_list))\r\ngoto out_unlock;\r\nroc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,\r\nlist);\r\nif (!roc->started)\r\ngoto out_unlock;\r\nlist_del(&roc->list);\r\nieee80211_roc_notify_destroy(roc, true);\r\nieee80211_start_next_roc(local);\r\nout_unlock:\r\nmutex_unlock(&local->mtx);\r\n}\r\nvoid ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\ntrace_api_remain_on_channel_expired(local);\r\nieee80211_queue_work(hw, &local->hw_roc_done);\r\n}\r\nvoid ieee80211_roc_setup(struct ieee80211_local *local)\r\n{\r\nINIT_WORK(&local->hw_roc_start, ieee80211_hw_roc_start);\r\nINIT_WORK(&local->hw_roc_done, ieee80211_hw_roc_done);\r\nINIT_LIST_HEAD(&local->roc_list);\r\n}\r\nvoid ieee80211_roc_purge(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_roc_work *roc, *tmp;\r\nLIST_HEAD(tmp_list);\r\nmutex_lock(&local->mtx);\r\nlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\r\nif (sdata && roc->sdata != sdata)\r\ncontinue;\r\nif (roc->started && local->ops->remain_on_channel) {\r\ndrv_cancel_remain_on_channel(local);\r\n}\r\nlist_move_tail(&roc->list, &tmp_list);\r\nroc->abort = true;\r\n}\r\nmutex_unlock(&local->mtx);\r\nlist_for_each_entry_safe(roc, tmp, &tmp_list, list) {\r\nif (local->ops->remain_on_channel) {\r\nlist_del(&roc->list);\r\nieee80211_roc_notify_destroy(roc, true);\r\n} else {\r\nieee80211_queue_delayed_work(&local->hw, &roc->work, 0);\r\nflush_delayed_work(&roc->work);\r\nWARN_ON(!roc->to_be_freed);\r\nkfree(roc);\r\n}\r\n}\r\nWARN_ON_ONCE(!list_empty(&tmp_list));\r\n}
