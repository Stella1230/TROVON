int snd_efw_transaction_cmd(struct fw_unit *unit,\r\nconst void *cmd, unsigned int size)\r\n{\r\nreturn snd_fw_transaction(unit, TCODE_WRITE_BLOCK_REQUEST,\r\nMEMORY_SPACE_EFW_COMMAND,\r\n(void *)cmd, size, 0);\r\n}\r\nint snd_efw_transaction_run(struct fw_unit *unit,\r\nconst void *cmd, unsigned int cmd_size,\r\nvoid *resp, unsigned int resp_size)\r\n{\r\nstruct transaction_queue t;\r\nunsigned int tries;\r\nint ret;\r\nt.unit = unit;\r\nt.buf = resp;\r\nt.size = resp_size;\r\nt.seqnum = be32_to_cpu(((struct snd_efw_transaction *)cmd)->seqnum) + 1;\r\nt.state = STATE_PENDING;\r\ninit_waitqueue_head(&t.wait);\r\nspin_lock_irq(&transaction_queues_lock);\r\nlist_add_tail(&t.list, &transaction_queues);\r\nspin_unlock_irq(&transaction_queues_lock);\r\ntries = 0;\r\ndo {\r\nret = snd_efw_transaction_cmd(t.unit, (void *)cmd, cmd_size);\r\nif (ret < 0)\r\nbreak;\r\nwait_event_timeout(t.wait, t.state != STATE_PENDING,\r\nmsecs_to_jiffies(EFC_TIMEOUT_MS));\r\nif (t.state == STATE_COMPLETE) {\r\nret = t.size;\r\nbreak;\r\n} else if (t.state == STATE_BUS_RESET) {\r\nmsleep(ERROR_DELAY_MS);\r\n} else if (++tries >= ERROR_RETRIES) {\r\ndev_err(&t.unit->device, "EFW transaction timed out\n");\r\nret = -EIO;\r\nbreak;\r\n}\r\n} while (1);\r\nspin_lock_irq(&transaction_queues_lock);\r\nlist_del(&t.list);\r\nspin_unlock_irq(&transaction_queues_lock);\r\nreturn ret;\r\n}\r\nstatic void\r\ncopy_resp_to_buf(struct snd_efw *efw, void *data, size_t length, int *rcode)\r\n{\r\nsize_t capacity, till_end;\r\nstruct snd_efw_transaction *t;\r\nspin_lock_irq(&efw->lock);\r\nt = (struct snd_efw_transaction *)data;\r\nlength = min_t(size_t, t->length * sizeof(t->length), length);\r\nif (efw->push_ptr < efw->pull_ptr)\r\ncapacity = (unsigned int)(efw->pull_ptr - efw->push_ptr);\r\nelse\r\ncapacity = snd_efw_resp_buf_size -\r\n(unsigned int)(efw->push_ptr - efw->pull_ptr);\r\nif (capacity < length) {\r\n*rcode = RCODE_CONFLICT_ERROR;\r\ngoto end;\r\n}\r\nwhile (length > 0) {\r\ntill_end = snd_efw_resp_buf_size -\r\n(unsigned int)(efw->push_ptr - efw->resp_buf);\r\ntill_end = min_t(unsigned int, length, till_end);\r\nmemcpy(efw->push_ptr, data, till_end);\r\nefw->push_ptr += till_end;\r\nif (efw->push_ptr >= efw->resp_buf + snd_efw_resp_buf_size)\r\nefw->push_ptr -= snd_efw_resp_buf_size;\r\nlength -= till_end;\r\ndata += till_end;\r\n}\r\nefw->resp_queues++;\r\nwake_up(&efw->hwdep_wait);\r\n*rcode = RCODE_COMPLETE;\r\nend:\r\nspin_unlock_irq(&efw->lock);\r\n}\r\nstatic void\r\nhandle_resp_for_user(struct fw_card *card, int generation, int source,\r\nvoid *data, size_t length, int *rcode)\r\n{\r\nstruct fw_device *device;\r\nstruct snd_efw *efw;\r\nunsigned int i;\r\nspin_lock_irq(&instances_lock);\r\nfor (i = 0; i < SNDRV_CARDS; i++) {\r\nefw = instances[i];\r\nif (efw == NULL)\r\ncontinue;\r\ndevice = fw_parent_device(efw->unit);\r\nif ((device->card != card) ||\r\n(device->generation != generation))\r\ncontinue;\r\nsmp_rmb();\r\nif (device->node_id != source)\r\ncontinue;\r\nbreak;\r\n}\r\nif (i == SNDRV_CARDS)\r\ngoto end;\r\ncopy_resp_to_buf(efw, data, length, rcode);\r\nend:\r\nspin_unlock_irq(&instances_lock);\r\n}\r\nstatic void\r\nhandle_resp_for_kernel(struct fw_card *card, int generation, int source,\r\nvoid *data, size_t length, int *rcode, u32 seqnum)\r\n{\r\nstruct fw_device *device;\r\nstruct transaction_queue *t;\r\nunsigned long flags;\r\nspin_lock_irqsave(&transaction_queues_lock, flags);\r\nlist_for_each_entry(t, &transaction_queues, list) {\r\ndevice = fw_parent_device(t->unit);\r\nif ((device->card != card) ||\r\n(device->generation != generation))\r\ncontinue;\r\nsmp_rmb();\r\nif (device->node_id != source)\r\ncontinue;\r\nif ((t->state == STATE_PENDING) && (t->seqnum == seqnum)) {\r\nt->state = STATE_COMPLETE;\r\nt->size = min_t(unsigned int, length, t->size);\r\nmemcpy(t->buf, data, t->size);\r\nwake_up(&t->wait);\r\n*rcode = RCODE_COMPLETE;\r\n}\r\n}\r\nspin_unlock_irqrestore(&transaction_queues_lock, flags);\r\n}\r\nstatic void\r\nefw_response(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nint rcode, dummy;\r\nu32 seqnum;\r\nrcode = RCODE_TYPE_ERROR;\r\nif (length < sizeof(struct snd_efw_transaction)) {\r\nrcode = RCODE_DATA_ERROR;\r\ngoto end;\r\n} else if (offset != MEMORY_SPACE_EFW_RESPONSE) {\r\nrcode = RCODE_ADDRESS_ERROR;\r\ngoto end;\r\n}\r\nseqnum = be32_to_cpu(((struct snd_efw_transaction *)data)->seqnum);\r\nif (seqnum > SND_EFW_TRANSACTION_USER_SEQNUM_MAX + 1) {\r\nhandle_resp_for_kernel(card, generation, source,\r\ndata, length, &rcode, seqnum);\r\nif (snd_efw_resp_buf_debug)\r\nhandle_resp_for_user(card, generation, source,\r\ndata, length, &dummy);\r\n} else {\r\nhandle_resp_for_user(card, generation, source,\r\ndata, length, &rcode);\r\n}\r\nend:\r\nfw_send_response(card, request, rcode);\r\n}\r\nvoid snd_efw_transaction_add_instance(struct snd_efw *efw)\r\n{\r\nunsigned int i;\r\nspin_lock_irq(&instances_lock);\r\nfor (i = 0; i < SNDRV_CARDS; i++) {\r\nif (instances[i] != NULL)\r\ncontinue;\r\ninstances[i] = efw;\r\nbreak;\r\n}\r\nspin_unlock_irq(&instances_lock);\r\n}\r\nvoid snd_efw_transaction_remove_instance(struct snd_efw *efw)\r\n{\r\nunsigned int i;\r\nspin_lock_irq(&instances_lock);\r\nfor (i = 0; i < SNDRV_CARDS; i++) {\r\nif (instances[i] != efw)\r\ncontinue;\r\ninstances[i] = NULL;\r\n}\r\nspin_unlock_irq(&instances_lock);\r\n}\r\nvoid snd_efw_transaction_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct transaction_queue *t;\r\nspin_lock_irq(&transaction_queues_lock);\r\nlist_for_each_entry(t, &transaction_queues, list) {\r\nif ((t->unit == unit) &&\r\n(t->state == STATE_PENDING)) {\r\nt->state = STATE_BUS_RESET;\r\nwake_up(&t->wait);\r\n}\r\n}\r\nspin_unlock_irq(&transaction_queues_lock);\r\n}\r\nint snd_efw_transaction_register(void)\r\n{\r\nstatic const struct fw_address_region resp_register_region = {\r\n.start = MEMORY_SPACE_EFW_RESPONSE,\r\n.end = MEMORY_SPACE_EFW_RESPONSE +\r\nSND_EFW_RESPONSE_MAXIMUM_BYTES\r\n};\r\nreturn fw_core_add_address_handler(&resp_register_handler,\r\n&resp_register_region);\r\n}\r\nvoid snd_efw_transaction_unregister(void)\r\n{\r\nWARN_ON(!list_empty(&transaction_queues));\r\nfw_core_remove_address_handler(&resp_register_handler);\r\n}
