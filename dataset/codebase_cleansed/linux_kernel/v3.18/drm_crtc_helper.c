void drm_helper_move_panel_connectors_to_head(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector, *tmp;\r\nstruct list_head panel_list;\r\nINIT_LIST_HEAD(&panel_list);\r\nlist_for_each_entry_safe(connector, tmp,\r\n&dev->mode_config.connector_list, head) {\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS ||\r\nconnector->connector_type == DRM_MODE_CONNECTOR_eDP)\r\nlist_move_tail(&connector->head, &panel_list);\r\n}\r\nlist_splice(&panel_list, &dev->mode_config.connector_list);\r\n}\r\nbool drm_helper_encoder_in_use(struct drm_encoder *encoder)\r\n{\r\nstruct drm_connector *connector;\r\nstruct drm_device *dev = encoder->dev;\r\nif (!oops_in_progress) {\r\nWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\nWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\r\n}\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->encoder == encoder)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool drm_helper_crtc_in_use(struct drm_crtc *crtc)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_device *dev = crtc->dev;\r\nif (!oops_in_progress)\r\nWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head)\r\nif (encoder->crtc == crtc && drm_helper_encoder_in_use(encoder))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void\r\ndrm_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\r\nif (encoder->bridge)\r\nencoder->bridge->funcs->disable(encoder->bridge);\r\nif (encoder_funcs->disable)\r\n(*encoder_funcs->disable)(encoder);\r\nelse\r\n(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);\r\nif (encoder->bridge)\r\nencoder->bridge->funcs->post_disable(encoder->bridge);\r\n}\r\nstatic void __drm_helper_disable_unused_functions(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\ndrm_warn_on_modeset_not_all_locked(dev);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (!drm_helper_encoder_in_use(encoder)) {\r\ndrm_encoder_disable(encoder);\r\nencoder->crtc = NULL;\r\n}\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc->enabled = drm_helper_crtc_in_use(crtc);\r\nif (!crtc->enabled) {\r\nif (crtc_funcs->disable)\r\n(*crtc_funcs->disable)(crtc);\r\nelse\r\n(*crtc_funcs->dpms)(crtc, DRM_MODE_DPMS_OFF);\r\ncrtc->primary->fb = NULL;\r\n}\r\n}\r\n}\r\nvoid drm_helper_disable_unused_functions(struct drm_device *dev)\r\n{\r\ndrm_modeset_lock_all(dev);\r\n__drm_helper_disable_unused_functions(dev);\r\ndrm_modeset_unlock_all(dev);\r\n}\r\nstatic void\r\ndrm_crtc_prepare_encoders(struct drm_device *dev)\r\n{\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nencoder_funcs = encoder->helper_private;\r\nif (encoder->crtc == NULL)\r\ndrm_encoder_disable(encoder);\r\nif (encoder_funcs->get_crtc &&\r\nencoder->crtc != (*encoder_funcs->get_crtc)(encoder))\r\ndrm_encoder_disable(encoder);\r\n}\r\n}\r\nbool drm_crtc_helper_set_mode(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_display_mode *adjusted_mode, saved_mode;\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nint saved_x, saved_y;\r\nbool saved_enabled;\r\nstruct drm_encoder *encoder;\r\nbool ret = true;\r\ndrm_warn_on_modeset_not_all_locked(dev);\r\nsaved_enabled = crtc->enabled;\r\ncrtc->enabled = drm_helper_crtc_in_use(crtc);\r\nif (!crtc->enabled)\r\nreturn true;\r\nadjusted_mode = drm_mode_duplicate(dev, mode);\r\nif (!adjusted_mode) {\r\ncrtc->enabled = saved_enabled;\r\nreturn false;\r\n}\r\nsaved_mode = crtc->mode;\r\nsaved_x = crtc->x;\r\nsaved_y = crtc->y;\r\ncrtc->mode = *mode;\r\ncrtc->x = x;\r\ncrtc->y = y;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nif (encoder->bridge && encoder->bridge->funcs->mode_fixup) {\r\nret = encoder->bridge->funcs->mode_fixup(\r\nencoder->bridge, mode, adjusted_mode);\r\nif (!ret) {\r\nDRM_DEBUG_KMS("Bridge fixup failed\n");\r\ngoto done;\r\n}\r\n}\r\nencoder_funcs = encoder->helper_private;\r\nif (!(ret = encoder_funcs->mode_fixup(encoder, mode,\r\nadjusted_mode))) {\r\nDRM_DEBUG_KMS("Encoder fixup failed\n");\r\ngoto done;\r\n}\r\n}\r\nif (!(ret = crtc_funcs->mode_fixup(crtc, mode, adjusted_mode))) {\r\nDRM_DEBUG_KMS("CRTC fixup failed\n");\r\ngoto done;\r\n}\r\nDRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nif (encoder->bridge)\r\nencoder->bridge->funcs->disable(encoder->bridge);\r\nencoder_funcs = encoder->helper_private;\r\nencoder_funcs->prepare(encoder);\r\nif (encoder->bridge)\r\nencoder->bridge->funcs->post_disable(encoder->bridge);\r\n}\r\ndrm_crtc_prepare_encoders(dev);\r\ncrtc_funcs->prepare(crtc);\r\nret = !crtc_funcs->mode_set(crtc, mode, adjusted_mode, x, y, old_fb);\r\nif (!ret)\r\ngoto done;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nDRM_DEBUG_KMS("[ENCODER:%d:%s] set [MODE:%d:%s]\n",\r\nencoder->base.id, encoder->name,\r\nmode->base.id, mode->name);\r\nencoder_funcs = encoder->helper_private;\r\nencoder_funcs->mode_set(encoder, mode, adjusted_mode);\r\nif (encoder->bridge && encoder->bridge->funcs->mode_set)\r\nencoder->bridge->funcs->mode_set(encoder->bridge, mode,\r\nadjusted_mode);\r\n}\r\ncrtc_funcs->commit(crtc);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nif (encoder->bridge)\r\nencoder->bridge->funcs->pre_enable(encoder->bridge);\r\nencoder_funcs = encoder->helper_private;\r\nencoder_funcs->commit(encoder);\r\nif (encoder->bridge)\r\nencoder->bridge->funcs->enable(encoder->bridge);\r\n}\r\ncrtc->hwmode = *adjusted_mode;\r\ndrm_calc_timestamping_constants(crtc, &crtc->hwmode);\r\ndone:\r\ndrm_mode_destroy(dev, adjusted_mode);\r\nif (!ret) {\r\ncrtc->enabled = saved_enabled;\r\ncrtc->mode = saved_mode;\r\ncrtc->x = saved_x;\r\ncrtc->y = saved_y;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\ndrm_crtc_helper_disable(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->encoder != encoder)\r\ncontinue;\r\nconnector->encoder = NULL;\r\nconnector->dpms = DRM_MODE_DPMS_OFF;\r\n}\r\n}\r\n__drm_helper_disable_unused_functions(dev);\r\n}\r\nint drm_crtc_helper_set_config(struct drm_mode_set *set)\r\n{\r\nstruct drm_device *dev;\r\nstruct drm_crtc *new_crtc;\r\nstruct drm_encoder *save_encoders, *new_encoder, *encoder;\r\nbool mode_changed = false;\r\nbool fb_changed = false;\r\nstruct drm_connector *save_connectors, *connector;\r\nint count = 0, ro, fail = 0;\r\nstruct drm_crtc_helper_funcs *crtc_funcs;\r\nstruct drm_mode_set save_set;\r\nint ret;\r\nint i;\r\nDRM_DEBUG_KMS("\n");\r\nBUG_ON(!set);\r\nBUG_ON(!set->crtc);\r\nBUG_ON(!set->crtc->helper_private);\r\nBUG_ON(!set->mode && set->fb);\r\nBUG_ON(set->fb && set->num_connectors == 0);\r\ncrtc_funcs = set->crtc->helper_private;\r\nif (!set->mode)\r\nset->fb = NULL;\r\nif (set->fb) {\r\nDRM_DEBUG_KMS("[CRTC:%d] [FB:%d] #connectors=%d (x y) (%i %i)\n",\r\nset->crtc->base.id, set->fb->base.id,\r\n(int)set->num_connectors, set->x, set->y);\r\n} else {\r\nDRM_DEBUG_KMS("[CRTC:%d] [NOFB]\n", set->crtc->base.id);\r\ndrm_crtc_helper_disable(set->crtc);\r\nreturn 0;\r\n}\r\ndev = set->crtc->dev;\r\ndrm_warn_on_modeset_not_all_locked(dev);\r\nsave_encoders = kzalloc(dev->mode_config.num_encoder *\r\nsizeof(struct drm_encoder), GFP_KERNEL);\r\nif (!save_encoders)\r\nreturn -ENOMEM;\r\nsave_connectors = kzalloc(dev->mode_config.num_connector *\r\nsizeof(struct drm_connector), GFP_KERNEL);\r\nif (!save_connectors) {\r\nkfree(save_encoders);\r\nreturn -ENOMEM;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nsave_encoders[count++] = *encoder;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nsave_connectors[count++] = *connector;\r\n}\r\nsave_set.crtc = set->crtc;\r\nsave_set.mode = &set->crtc->mode;\r\nsave_set.x = set->crtc->x;\r\nsave_set.y = set->crtc->y;\r\nsave_set.fb = set->crtc->primary->fb;\r\nif (set->crtc->primary->fb != set->fb) {\r\nif (set->crtc->primary->fb == NULL) {\r\nDRM_DEBUG_KMS("crtc has no fb, full mode set\n");\r\nmode_changed = true;\r\n} else if (set->fb == NULL) {\r\nmode_changed = true;\r\n} else if (set->fb->pixel_format !=\r\nset->crtc->primary->fb->pixel_format) {\r\nmode_changed = true;\r\n} else\r\nfb_changed = true;\r\n}\r\nif (set->x != set->crtc->x || set->y != set->crtc->y)\r\nfb_changed = true;\r\nif (set->mode && !drm_mode_equal(set->mode, &set->crtc->mode)) {\r\nDRM_DEBUG_KMS("modes are different, full mode set\n");\r\ndrm_mode_debug_printmodeline(&set->crtc->mode);\r\ndrm_mode_debug_printmodeline(set->mode);\r\nmode_changed = true;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct drm_connector_helper_funcs *connector_funcs =\r\nconnector->helper_private;\r\nnew_encoder = connector->encoder;\r\nfor (ro = 0; ro < set->num_connectors; ro++) {\r\nif (set->connectors[ro] == connector) {\r\nnew_encoder = connector_funcs->best_encoder(connector);\r\nif (new_encoder == NULL)\r\nfail = 1;\r\nif (connector->dpms != DRM_MODE_DPMS_ON) {\r\nDRM_DEBUG_KMS("connector dpms not on, full mode switch\n");\r\nmode_changed = true;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (new_encoder != connector->encoder) {\r\nDRM_DEBUG_KMS("encoder changed, full mode switch\n");\r\nmode_changed = true;\r\nif (connector->encoder)\r\nconnector->encoder->crtc = NULL;\r\nconnector->encoder = new_encoder;\r\n}\r\n}\r\nif (fail) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (!connector->encoder)\r\ncontinue;\r\nif (connector->encoder->crtc == set->crtc)\r\nnew_crtc = NULL;\r\nelse\r\nnew_crtc = connector->encoder->crtc;\r\nfor (ro = 0; ro < set->num_connectors; ro++) {\r\nif (set->connectors[ro] == connector)\r\nnew_crtc = set->crtc;\r\n}\r\nif (new_crtc &&\r\n!drm_encoder_crtc_ok(connector->encoder, new_crtc)) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nif (new_crtc != connector->encoder->crtc) {\r\nDRM_DEBUG_KMS("crtc changed, full mode switch\n");\r\nmode_changed = true;\r\nconnector->encoder->crtc = new_crtc;\r\n}\r\nif (new_crtc) {\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [CRTC:%d]\n",\r\nconnector->base.id, connector->name,\r\nnew_crtc->base.id);\r\n} else {\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [NOCRTC]\n",\r\nconnector->base.id, connector->name);\r\n}\r\n}\r\nif (fb_changed && !crtc_funcs->mode_set_base)\r\nmode_changed = true;\r\nif (mode_changed) {\r\nif (drm_helper_crtc_in_use(set->crtc)) {\r\nDRM_DEBUG_KMS("attempting to set mode from"\r\n" userspace\n");\r\ndrm_mode_debug_printmodeline(set->mode);\r\nset->crtc->primary->fb = set->fb;\r\nif (!drm_crtc_helper_set_mode(set->crtc, set->mode,\r\nset->x, set->y,\r\nsave_set.fb)) {\r\nDRM_ERROR("failed to set mode on [CRTC:%d]\n",\r\nset->crtc->base.id);\r\nset->crtc->primary->fb = save_set.fb;\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nDRM_DEBUG_KMS("Setting connector DPMS state to on\n");\r\nfor (i = 0; i < set->num_connectors; i++) {\r\nDRM_DEBUG_KMS("\t[CONNECTOR:%d:%s] set DPMS on\n", set->connectors[i]->base.id,\r\nset->connectors[i]->name);\r\nset->connectors[i]->funcs->dpms(set->connectors[i], DRM_MODE_DPMS_ON);\r\n}\r\n}\r\n__drm_helper_disable_unused_functions(dev);\r\n} else if (fb_changed) {\r\nset->crtc->x = set->x;\r\nset->crtc->y = set->y;\r\nset->crtc->primary->fb = set->fb;\r\nret = crtc_funcs->mode_set_base(set->crtc,\r\nset->x, set->y, save_set.fb);\r\nif (ret != 0) {\r\nset->crtc->x = save_set.x;\r\nset->crtc->y = save_set.y;\r\nset->crtc->primary->fb = save_set.fb;\r\ngoto fail;\r\n}\r\n}\r\nkfree(save_connectors);\r\nkfree(save_encoders);\r\nreturn 0;\r\nfail:\r\ncount = 0;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\n*encoder = save_encoders[count++];\r\n}\r\ncount = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\n*connector = save_connectors[count++];\r\n}\r\nif (mode_changed &&\r\n!drm_crtc_helper_set_mode(save_set.crtc, save_set.mode, save_set.x,\r\nsave_set.y, save_set.fb))\r\nDRM_ERROR("failed to restore config after modeset failure\n");\r\nkfree(save_connectors);\r\nkfree(save_encoders);\r\nreturn ret;\r\n}\r\nstatic int drm_helper_choose_encoder_dpms(struct drm_encoder *encoder)\r\n{\r\nint dpms = DRM_MODE_DPMS_OFF;\r\nstruct drm_connector *connector;\r\nstruct drm_device *dev = encoder->dev;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->encoder == encoder)\r\nif (connector->dpms < dpms)\r\ndpms = connector->dpms;\r\nreturn dpms;\r\n}\r\nstatic void drm_helper_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_bridge *bridge = encoder->bridge;\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nif (bridge) {\r\nif (mode == DRM_MODE_DPMS_ON)\r\nbridge->funcs->pre_enable(bridge);\r\nelse\r\nbridge->funcs->disable(bridge);\r\n}\r\nencoder_funcs = encoder->helper_private;\r\nif (encoder_funcs->dpms)\r\nencoder_funcs->dpms(encoder, mode);\r\nif (bridge) {\r\nif (mode == DRM_MODE_DPMS_ON)\r\nbridge->funcs->enable(bridge);\r\nelse\r\nbridge->funcs->post_disable(bridge);\r\n}\r\n}\r\nstatic int drm_helper_choose_crtc_dpms(struct drm_crtc *crtc)\r\n{\r\nint dpms = DRM_MODE_DPMS_OFF;\r\nstruct drm_connector *connector;\r\nstruct drm_device *dev = crtc->dev;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->encoder && connector->encoder->crtc == crtc)\r\nif (connector->dpms < dpms)\r\ndpms = connector->dpms;\r\nreturn dpms;\r\n}\r\nvoid drm_helper_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\nstruct drm_encoder *encoder = connector->encoder;\r\nstruct drm_crtc *crtc = encoder ? encoder->crtc : NULL;\r\nint old_dpms, encoder_dpms = DRM_MODE_DPMS_OFF;\r\nif (mode == connector->dpms)\r\nreturn;\r\nold_dpms = connector->dpms;\r\nconnector->dpms = mode;\r\nif (encoder)\r\nencoder_dpms = drm_helper_choose_encoder_dpms(encoder);\r\nif (mode < old_dpms) {\r\nif (crtc) {\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nif (crtc_funcs->dpms)\r\n(*crtc_funcs->dpms) (crtc,\r\ndrm_helper_choose_crtc_dpms(crtc));\r\n}\r\nif (encoder)\r\ndrm_helper_encoder_dpms(encoder, encoder_dpms);\r\n}\r\nif (mode > old_dpms) {\r\nif (encoder)\r\ndrm_helper_encoder_dpms(encoder, encoder_dpms);\r\nif (crtc) {\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nif (crtc_funcs->dpms)\r\n(*crtc_funcs->dpms) (crtc,\r\ndrm_helper_choose_crtc_dpms(crtc));\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nint i;\r\nfb->width = mode_cmd->width;\r\nfb->height = mode_cmd->height;\r\nfor (i = 0; i < 4; i++) {\r\nfb->pitches[i] = mode_cmd->pitches[i];\r\nfb->offsets[i] = mode_cmd->offsets[i];\r\n}\r\ndrm_fb_get_bpp_depth(mode_cmd->pixel_format, &fb->depth,\r\n&fb->bits_per_pixel);\r\nfb->pixel_format = mode_cmd->pixel_format;\r\nfb->flags = mode_cmd->flags;\r\n}\r\nvoid drm_helper_resume_force_mode(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc_helper_funcs *crtc_funcs;\r\nint encoder_dpms;\r\nbool ret;\r\ndrm_modeset_lock_all(dev);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nif (!crtc->enabled)\r\ncontinue;\r\nret = drm_crtc_helper_set_mode(crtc, &crtc->mode,\r\ncrtc->x, crtc->y, crtc->primary->fb);\r\nif (ret == false)\r\nDRM_ERROR("failed to set mode on crtc %p\n", crtc);\r\nif (drm_helper_choose_crtc_dpms(crtc)) {\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif(encoder->crtc != crtc)\r\ncontinue;\r\nencoder_dpms = drm_helper_choose_encoder_dpms(\r\nencoder);\r\ndrm_helper_encoder_dpms(encoder, encoder_dpms);\r\n}\r\ncrtc_funcs = crtc->helper_private;\r\nif (crtc_funcs->dpms)\r\n(*crtc_funcs->dpms) (crtc,\r\ndrm_helper_choose_crtc_dpms(crtc));\r\n}\r\n}\r\n__drm_helper_disable_unused_functions(dev);\r\ndrm_modeset_unlock_all(dev);\r\n}
