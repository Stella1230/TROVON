void qat_hal_set_live_ctx(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int ctx_mask)\r\n{\r\nAE(handle, ae).live_ctx_mask = ctx_mask;\r\n}\r\nstatic int qat_hal_rd_ae_csr(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int csr,\r\nunsigned int *value)\r\n{\r\nunsigned int iterations = CSR_RETRY_TIMES;\r\ndo {\r\n*value = GET_AE_CSR(handle, ae, csr);\r\nif (!(GET_AE_CSR(handle, ae, LOCAL_CSR_STATUS) & LCS_STATUS))\r\nreturn 0;\r\n} while (iterations--);\r\npr_err("QAT: Read CSR timeout\n");\r\nreturn -EFAULT;\r\n}\r\nstatic int qat_hal_wr_ae_csr(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int csr,\r\nunsigned int value)\r\n{\r\nunsigned int iterations = CSR_RETRY_TIMES;\r\ndo {\r\nSET_AE_CSR(handle, ae, csr, value);\r\nif (!(GET_AE_CSR(handle, ae, LOCAL_CSR_STATUS) & LCS_STATUS))\r\nreturn 0;\r\n} while (iterations--);\r\npr_err("QAT: Write CSR Timeout\n");\r\nreturn -EFAULT;\r\n}\r\nstatic void qat_hal_get_wakeup_event(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nunsigned int *events)\r\n{\r\nunsigned int cur_ctx;\r\nqat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER, &cur_ctx);\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\r\nqat_hal_rd_ae_csr(handle, ae, CTX_WAKEUP_EVENTS_INDIRECT, events);\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\r\n}\r\nstatic int qat_hal_wait_cycles(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int cycles,\r\nint chk_inactive)\r\n{\r\nunsigned int base_cnt = 0, cur_cnt = 0;\r\nunsigned int csr = (1 << ACS_ABO_BITPOS);\r\nint times = MAX_RETRY_TIMES;\r\nint elapsed_cycles = 0;\r\nqat_hal_rd_ae_csr(handle, ae, PROFILE_COUNT, &base_cnt);\r\nbase_cnt &= 0xffff;\r\nwhile ((int)cycles > elapsed_cycles && times--) {\r\nif (chk_inactive)\r\nqat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS, &csr);\r\nqat_hal_rd_ae_csr(handle, ae, PROFILE_COUNT, &cur_cnt);\r\ncur_cnt &= 0xffff;\r\nelapsed_cycles = cur_cnt - base_cnt;\r\nif (elapsed_cycles < 0)\r\nelapsed_cycles += 0x10000;\r\nif (elapsed_cycles >= 8 && !(csr & (1 << ACS_ABO_BITPOS)))\r\nreturn 0;\r\n}\r\nif (!times) {\r\npr_err("QAT: wait_num_cycles time out\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint qat_hal_set_ae_ctx_mode(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char mode)\r\n{\r\nunsigned int csr, new_csr;\r\nif ((mode != 4) && (mode != 8)) {\r\npr_err("QAT: bad ctx mode=%d\n", mode);\r\nreturn -EINVAL;\r\n}\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &csr);\r\ncsr = IGNORE_W1C_MASK & csr;\r\nnew_csr = (mode == 4) ?\r\nSET_BIT(csr, CE_INUSE_CONTEXTS_BITPOS) :\r\nCLR_BIT(csr, CE_INUSE_CONTEXTS_BITPOS);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, new_csr);\r\nreturn 0;\r\n}\r\nint qat_hal_set_ae_nn_mode(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char mode)\r\n{\r\nunsigned int csr, new_csr;\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &csr);\r\ncsr &= IGNORE_W1C_MASK;\r\nnew_csr = (mode) ?\r\nSET_BIT(csr, CE_NN_MODE_BITPOS) :\r\nCLR_BIT(csr, CE_NN_MODE_BITPOS);\r\nif (new_csr != csr)\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, new_csr);\r\nreturn 0;\r\n}\r\nint qat_hal_set_ae_lm_mode(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, enum icp_qat_uof_regtype lm_type,\r\nunsigned char mode)\r\n{\r\nunsigned int csr, new_csr;\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &csr);\r\ncsr &= IGNORE_W1C_MASK;\r\nswitch (lm_type) {\r\ncase ICP_LMEM0:\r\nnew_csr = (mode) ?\r\nSET_BIT(csr, CE_LMADDR_0_GLOBAL_BITPOS) :\r\nCLR_BIT(csr, CE_LMADDR_0_GLOBAL_BITPOS);\r\nbreak;\r\ncase ICP_LMEM1:\r\nnew_csr = (mode) ?\r\nSET_BIT(csr, CE_LMADDR_1_GLOBAL_BITPOS) :\r\nCLR_BIT(csr, CE_LMADDR_1_GLOBAL_BITPOS);\r\nbreak;\r\ndefault:\r\npr_err("QAT: lmType = 0x%x\n", lm_type);\r\nreturn -EINVAL;\r\n}\r\nif (new_csr != csr)\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, new_csr);\r\nreturn 0;\r\n}\r\nstatic unsigned short qat_hal_get_reg_addr(unsigned int type,\r\nunsigned short reg_num)\r\n{\r\nunsigned short reg_addr;\r\nswitch (type) {\r\ncase ICP_GPA_ABS:\r\ncase ICP_GPB_ABS:\r\nreg_addr = 0x80 | (reg_num & 0x7f);\r\nbreak;\r\ncase ICP_GPA_REL:\r\ncase ICP_GPB_REL:\r\nreg_addr = reg_num & 0x1f;\r\nbreak;\r\ncase ICP_SR_RD_REL:\r\ncase ICP_SR_WR_REL:\r\ncase ICP_SR_REL:\r\nreg_addr = 0x180 | (reg_num & 0x1f);\r\nbreak;\r\ncase ICP_SR_ABS:\r\nreg_addr = 0x140 | ((reg_num & 0x3) << 1);\r\nbreak;\r\ncase ICP_DR_RD_REL:\r\ncase ICP_DR_WR_REL:\r\ncase ICP_DR_REL:\r\nreg_addr = 0x1c0 | (reg_num & 0x1f);\r\nbreak;\r\ncase ICP_DR_ABS:\r\nreg_addr = 0x100 | ((reg_num & 0x3) << 1);\r\nbreak;\r\ncase ICP_NEIGH_REL:\r\nreg_addr = 0x280 | (reg_num & 0x1f);\r\nbreak;\r\ncase ICP_LMEM0:\r\nreg_addr = 0x200;\r\nbreak;\r\ncase ICP_LMEM1:\r\nreg_addr = 0x220;\r\nbreak;\r\ncase ICP_NO_DEST:\r\nreg_addr = 0x300 | (reg_num & 0xff);\r\nbreak;\r\ndefault:\r\nreg_addr = BAD_REGADDR;\r\nbreak;\r\n}\r\nreturn reg_addr;\r\n}\r\nvoid qat_hal_reset(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nunsigned int ae_reset_csr;\r\nae_reset_csr = GET_GLB_CSR(handle, ICP_RESET);\r\nae_reset_csr |= handle->hal_handle->ae_mask << RST_CSR_AE_LSB;\r\nae_reset_csr |= handle->hal_handle->slice_mask << RST_CSR_QAT_LSB;\r\nSET_GLB_CSR(handle, ICP_RESET, ae_reset_csr);\r\n}\r\nstatic void qat_hal_wr_indr_csr(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int ctx_mask,\r\nunsigned int ae_csr, unsigned int csr_val)\r\n{\r\nunsigned int ctx, cur_ctx;\r\nqat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER, &cur_ctx);\r\nfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++) {\r\nif (!(ctx_mask & (1 << ctx)))\r\ncontinue;\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\r\nqat_hal_wr_ae_csr(handle, ae, ae_csr, csr_val);\r\n}\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\r\n}\r\nstatic void qat_hal_rd_indr_csr(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nunsigned int ae_csr, unsigned int *csr_val)\r\n{\r\nunsigned int cur_ctx;\r\nqat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER, &cur_ctx);\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\r\nqat_hal_rd_ae_csr(handle, ae, ae_csr, csr_val);\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\r\n}\r\nstatic void qat_hal_put_sig_event(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int ctx_mask,\r\nunsigned int events)\r\n{\r\nunsigned int ctx, cur_ctx;\r\nqat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER, &cur_ctx);\r\nfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++) {\r\nif (!(ctx_mask & (1 << ctx)))\r\ncontinue;\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_SIG_EVENTS_INDIRECT, events);\r\n}\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\r\n}\r\nstatic void qat_hal_put_wakeup_event(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int ctx_mask,\r\nunsigned int events)\r\n{\r\nunsigned int ctx, cur_ctx;\r\nqat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER, &cur_ctx);\r\nfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++) {\r\nif (!(ctx_mask & (1 << ctx)))\r\ncontinue;\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_WAKEUP_EVENTS_INDIRECT,\r\nevents);\r\n}\r\nqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\r\n}\r\nstatic int qat_hal_check_ae_alive(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nunsigned int base_cnt, cur_cnt;\r\nunsigned char ae;\r\nunsigned int times = MAX_RETRY_TIMES;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!(handle->hal_handle->ae_mask & (1 << ae)))\r\ncontinue;\r\nqat_hal_rd_ae_csr(handle, ae, PROFILE_COUNT,\r\n(unsigned int *)&base_cnt);\r\nbase_cnt &= 0xffff;\r\ndo {\r\nqat_hal_rd_ae_csr(handle, ae, PROFILE_COUNT,\r\n(unsigned int *)&cur_cnt);\r\ncur_cnt &= 0xffff;\r\n} while (times-- && (cur_cnt == base_cnt));\r\nif (!times) {\r\npr_err("QAT: AE%d is inactive!!\n", ae);\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void qat_hal_reset_timestamp(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nunsigned int misc_ctl;\r\nunsigned char ae;\r\nmisc_ctl = GET_GLB_CSR(handle, MISC_CONTROL);\r\nif (misc_ctl & MC_TIMESTAMP_ENABLE)\r\nSET_GLB_CSR(handle, MISC_CONTROL, misc_ctl &\r\n(~MC_TIMESTAMP_ENABLE));\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!(handle->hal_handle->ae_mask & (1 << ae)))\r\ncontinue;\r\nqat_hal_wr_ae_csr(handle, ae, TIMESTAMP_LOW, 0);\r\nqat_hal_wr_ae_csr(handle, ae, TIMESTAMP_HIGH, 0);\r\n}\r\nSET_GLB_CSR(handle, MISC_CONTROL, misc_ctl | MC_TIMESTAMP_ENABLE);\r\n}\r\nstatic int qat_hal_init_esram(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nvoid __iomem *csr_addr = handle->hal_ep_csr_addr_v +\r\nESRAM_AUTO_INIT_CSR_OFFSET;\r\nunsigned int csr_val, times = 30;\r\ncsr_val = ADF_CSR_RD(csr_addr, 0);\r\nif ((csr_val & ESRAM_AUTO_TINIT) && (csr_val & ESRAM_AUTO_TINIT_DONE))\r\nreturn 0;\r\ncsr_val = ADF_CSR_RD(csr_addr, 0);\r\ncsr_val |= ESRAM_AUTO_TINIT;\r\nADF_CSR_WR(csr_addr, 0, csr_val);\r\ndo {\r\nqat_hal_wait_cycles(handle, 0, ESRAM_AUTO_INIT_USED_CYCLES, 0);\r\ncsr_val = ADF_CSR_RD(csr_addr, 0);\r\n} while (!(csr_val & ESRAM_AUTO_TINIT_DONE) && times--);\r\nif ((!times)) {\r\npr_err("QAT: Fail to init eSram!\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint qat_hal_clr_reset(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nunsigned int ae_reset_csr;\r\nunsigned char ae;\r\nunsigned int clk_csr;\r\nunsigned int times = 100;\r\nunsigned int csr;\r\nae_reset_csr = GET_GLB_CSR(handle, ICP_RESET);\r\nae_reset_csr &= ~(handle->hal_handle->ae_mask << RST_CSR_AE_LSB);\r\nae_reset_csr &= ~(handle->hal_handle->slice_mask << RST_CSR_QAT_LSB);\r\ndo {\r\nSET_GLB_CSR(handle, ICP_RESET, ae_reset_csr);\r\nif (!(times--))\r\ngoto out_err;\r\ncsr = GET_GLB_CSR(handle, ICP_RESET);\r\n} while ((handle->hal_handle->ae_mask |\r\n(handle->hal_handle->slice_mask << RST_CSR_QAT_LSB)) & csr);\r\nclk_csr = GET_GLB_CSR(handle, ICP_GLOBAL_CLK_ENABLE);\r\nclk_csr |= handle->hal_handle->ae_mask << 0;\r\nclk_csr |= handle->hal_handle->slice_mask << 20;\r\nSET_GLB_CSR(handle, ICP_GLOBAL_CLK_ENABLE, clk_csr);\r\nif (qat_hal_check_ae_alive(handle))\r\ngoto out_err;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!(handle->hal_handle->ae_mask & (1 << ae)))\r\ncontinue;\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES,\r\nINIT_CTX_ENABLE_VALUE);\r\nqat_hal_wr_indr_csr(handle, ae, ICP_QAT_UCLO_AE_ALL_CTX,\r\nCTX_STS_INDIRECT,\r\nhandle->hal_handle->upc_mask &\r\nINIT_PC_VALUE);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ARB_CNTL, INIT_CTX_ARB_VALUE);\r\nqat_hal_wr_ae_csr(handle, ae, CC_ENABLE, INIT_CCENABLE_VALUE);\r\nqat_hal_put_wakeup_event(handle, ae,\r\nICP_QAT_UCLO_AE_ALL_CTX,\r\nINIT_WAKEUP_EVENTS_VALUE);\r\nqat_hal_put_sig_event(handle, ae,\r\nICP_QAT_UCLO_AE_ALL_CTX,\r\nINIT_SIG_EVENTS_VALUE);\r\n}\r\nif (qat_hal_init_esram(handle))\r\ngoto out_err;\r\nif (qat_hal_wait_cycles(handle, 0, SHRAM_INIT_CYCLES, 0))\r\ngoto out_err;\r\nqat_hal_reset_timestamp(handle);\r\nreturn 0;\r\nout_err:\r\npr_err("QAT: failed to get device out of reset\n");\r\nreturn -EFAULT;\r\n}\r\nstatic void qat_hal_disable_ctx(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int ctx_mask)\r\n{\r\nunsigned int ctx;\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &ctx);\r\nctx &= IGNORE_W1C_MASK &\r\n(~((ctx_mask & ICP_QAT_UCLO_AE_ALL_CTX) << CE_ENABLE_BITPOS));\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx);\r\n}\r\nstatic uint64_t qat_hal_parity_64bit(uint64_t word)\r\n{\r\nword ^= word >> 1;\r\nword ^= word >> 2;\r\nword ^= word >> 4;\r\nword ^= word >> 8;\r\nword ^= word >> 16;\r\nword ^= word >> 32;\r\nreturn word & 1;\r\n}\r\nstatic uint64_t qat_hal_set_uword_ecc(uint64_t uword)\r\n{\r\nuint64_t bit0_mask = 0xff800007fffULL, bit1_mask = 0x1f801ff801fULL,\r\nbit2_mask = 0xe387e0781e1ULL, bit3_mask = 0x7cb8e388e22ULL,\r\nbit4_mask = 0xaf5b2c93244ULL, bit5_mask = 0xf56d5525488ULL,\r\nbit6_mask = 0xdaf69a46910ULL;\r\nuword &= ~(0x7fULL << 0x2C);\r\nuword |= qat_hal_parity_64bit(bit0_mask & uword) << 0x2C;\r\nuword |= qat_hal_parity_64bit(bit1_mask & uword) << 0x2D;\r\nuword |= qat_hal_parity_64bit(bit2_mask & uword) << 0x2E;\r\nuword |= qat_hal_parity_64bit(bit3_mask & uword) << 0x2F;\r\nuword |= qat_hal_parity_64bit(bit4_mask & uword) << 0x30;\r\nuword |= qat_hal_parity_64bit(bit5_mask & uword) << 0x31;\r\nuword |= qat_hal_parity_64bit(bit6_mask & uword) << 0x32;\r\nreturn uword;\r\n}\r\nvoid qat_hal_wr_uwords(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int uaddr,\r\nunsigned int words_num, uint64_t *uword)\r\n{\r\nunsigned int ustore_addr;\r\nunsigned int i;\r\nqat_hal_rd_ae_csr(handle, ae, USTORE_ADDRESS, &ustore_addr);\r\nuaddr |= UA_ECS;\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\r\nfor (i = 0; i < words_num; i++) {\r\nunsigned int uwrd_lo, uwrd_hi;\r\nuint64_t tmp;\r\ntmp = qat_hal_set_uword_ecc(uword[i]);\r\nuwrd_lo = (unsigned int)(tmp & 0xffffffff);\r\nuwrd_hi = (unsigned int)(tmp >> 0x20);\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_LOWER, uwrd_lo);\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_UPPER, uwrd_hi);\r\n}\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, ustore_addr);\r\n}\r\nstatic void qat_hal_enable_ctx(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int ctx_mask)\r\n{\r\nunsigned int ctx;\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &ctx);\r\nctx &= IGNORE_W1C_MASK;\r\nctx_mask &= (ctx & CE_INUSE_CONTEXTS) ? 0x55 : 0xFF;\r\nctx |= (ctx_mask << CE_ENABLE_BITPOS);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx);\r\n}\r\nstatic int qat_hal_clear_gpr(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nunsigned char ae;\r\nunsigned int ctx_mask = ICP_QAT_UCLO_AE_ALL_CTX;\r\nint times = MAX_RETRY_TIMES;\r\nunsigned int csr_val = 0;\r\nunsigned short reg;\r\nunsigned int savctx = 0;\r\nint ret = 0;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!(handle->hal_handle->ae_mask & (1 << ae)))\r\ncontinue;\r\nfor (reg = 0; reg < ICP_QAT_UCLO_MAX_GPR_REG; reg++) {\r\nqat_hal_init_rd_xfer(handle, ae, 0, ICP_SR_RD_ABS,\r\nreg, 0);\r\nqat_hal_init_rd_xfer(handle, ae, 0, ICP_DR_RD_ABS,\r\nreg, 0);\r\n}\r\nqat_hal_rd_ae_csr(handle, ae, AE_MISC_CONTROL, &csr_val);\r\ncsr_val &= ~(1 << MMC_SHARE_CS_BITPOS);\r\nqat_hal_wr_ae_csr(handle, ae, AE_MISC_CONTROL, csr_val);\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &csr_val);\r\ncsr_val &= IGNORE_W1C_MASK;\r\ncsr_val |= CE_NN_MODE;\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, csr_val);\r\nqat_hal_wr_uwords(handle, ae, 0, ARRAY_SIZE(inst),\r\n(uint64_t *)inst);\r\nqat_hal_wr_indr_csr(handle, ae, ctx_mask, CTX_STS_INDIRECT,\r\nhandle->hal_handle->upc_mask &\r\nINIT_PC_VALUE);\r\nqat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS, &savctx);\r\nqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS, 0);\r\nqat_hal_put_wakeup_event(handle, ae, ctx_mask, XCWE_VOLUNTARY);\r\nqat_hal_wr_indr_csr(handle, ae, ctx_mask,\r\nCTX_SIG_EVENTS_INDIRECT, 0);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_SIG_EVENTS_ACTIVE, 0);\r\nqat_hal_enable_ctx(handle, ae, ctx_mask);\r\n}\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nif (!(handle->hal_handle->ae_mask & (1 << ae)))\r\ncontinue;\r\ndo {\r\nret = qat_hal_wait_cycles(handle, ae, 20, 1);\r\n} while (ret && times--);\r\nif (!times) {\r\npr_err("QAT: clear GPR of AE %d failed", ae);\r\nreturn -EINVAL;\r\n}\r\nqat_hal_disable_ctx(handle, ae, ctx_mask);\r\nqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS,\r\nsavctx & ACS_ACNO);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES,\r\nINIT_CTX_ENABLE_VALUE);\r\nqat_hal_wr_indr_csr(handle, ae, ctx_mask, CTX_STS_INDIRECT,\r\nhandle->hal_handle->upc_mask &\r\nINIT_PC_VALUE);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ARB_CNTL, INIT_CTX_ARB_VALUE);\r\nqat_hal_wr_ae_csr(handle, ae, CC_ENABLE, INIT_CCENABLE_VALUE);\r\nqat_hal_put_wakeup_event(handle, ae, ctx_mask,\r\nINIT_WAKEUP_EVENTS_VALUE);\r\nqat_hal_put_sig_event(handle, ae, ctx_mask,\r\nINIT_SIG_EVENTS_VALUE);\r\n}\r\nreturn 0;\r\n}\r\nint qat_hal_init(struct adf_accel_dev *accel_dev)\r\n{\r\nunsigned char ae;\r\nunsigned int max_en_ae_id = 0;\r\nstruct icp_qat_fw_loader_handle *handle;\r\nstruct adf_accel_pci *pci_info = &accel_dev->accel_pci_dev;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct adf_bar *bar = &pci_info->pci_bars[ADF_DH895XCC_PMISC_BAR];\r\nhandle = kzalloc(sizeof(*handle), GFP_KERNEL);\r\nif (!handle)\r\nreturn -ENOMEM;\r\nhandle->hal_cap_g_ctl_csr_addr_v = bar->virt_addr +\r\nICP_DH895XCC_CAP_OFFSET;\r\nhandle->hal_cap_ae_xfer_csr_addr_v = bar->virt_addr +\r\nICP_DH895XCC_AE_OFFSET;\r\nhandle->hal_ep_csr_addr_v = bar->virt_addr + ICP_DH895XCC_EP_OFFSET;\r\nhandle->hal_cap_ae_local_csr_addr_v =\r\nhandle->hal_cap_ae_xfer_csr_addr_v + LOCAL_TO_XFER_REG_OFFSET;\r\nhandle->hal_handle = kzalloc(sizeof(*handle->hal_handle), GFP_KERNEL);\r\nif (!handle->hal_handle)\r\ngoto out_hal_handle;\r\nhandle->hal_handle->revision_id = accel_dev->accel_pci_dev.revid;\r\nhandle->hal_handle->ae_mask = hw_data->ae_mask;\r\nhandle->hal_handle->slice_mask = hw_data->accel_mask;\r\nhandle->hal_handle->upc_mask = 0x1ffff;\r\nhandle->hal_handle->max_ustore = 0x4000;\r\nfor (ae = 0; ae < ICP_QAT_UCLO_MAX_AE; ae++) {\r\nif (!(hw_data->ae_mask & (1 << ae)))\r\ncontinue;\r\nhandle->hal_handle->aes[ae].free_addr = 0;\r\nhandle->hal_handle->aes[ae].free_size =\r\nhandle->hal_handle->max_ustore;\r\nhandle->hal_handle->aes[ae].ustore_size =\r\nhandle->hal_handle->max_ustore;\r\nhandle->hal_handle->aes[ae].live_ctx_mask =\r\nICP_QAT_UCLO_AE_ALL_CTX;\r\nmax_en_ae_id = ae;\r\n}\r\nhandle->hal_handle->ae_max_num = max_en_ae_id + 1;\r\nif (qat_hal_clr_reset(handle)) {\r\npr_err("QAT: qat_hal_clr_reset error\n");\r\ngoto out_err;\r\n}\r\nif (qat_hal_clear_gpr(handle))\r\ngoto out_err;\r\nfor (ae = 0; ae < handle->hal_handle->ae_max_num; ae++) {\r\nunsigned int csr_val = 0;\r\nif (!(hw_data->ae_mask & (1 << ae)))\r\ncontinue;\r\nqat_hal_rd_ae_csr(handle, ae, SIGNATURE_ENABLE, &csr_val);\r\ncsr_val |= 0x1;\r\nqat_hal_wr_ae_csr(handle, ae, SIGNATURE_ENABLE, csr_val);\r\n}\r\naccel_dev->fw_loader->fw_loader = handle;\r\nreturn 0;\r\nout_err:\r\nkfree(handle->hal_handle);\r\nout_hal_handle:\r\nkfree(handle);\r\nreturn -EFAULT;\r\n}\r\nvoid qat_hal_deinit(struct icp_qat_fw_loader_handle *handle)\r\n{\r\nif (!handle)\r\nreturn;\r\nkfree(handle->hal_handle);\r\nkfree(handle);\r\n}\r\nvoid qat_hal_start(struct icp_qat_fw_loader_handle *handle, unsigned char ae,\r\nunsigned int ctx_mask)\r\n{\r\nqat_hal_put_wakeup_event(handle, ae, (~ctx_mask) &\r\nICP_QAT_UCLO_AE_ALL_CTX, 0x10000);\r\nqat_hal_enable_ctx(handle, ae, ctx_mask);\r\n}\r\nvoid qat_hal_stop(struct icp_qat_fw_loader_handle *handle, unsigned char ae,\r\nunsigned int ctx_mask)\r\n{\r\nqat_hal_disable_ctx(handle, ae, ctx_mask);\r\n}\r\nvoid qat_hal_set_pc(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int ctx_mask, unsigned int upc)\r\n{\r\nqat_hal_wr_indr_csr(handle, ae, ctx_mask, CTX_STS_INDIRECT,\r\nhandle->hal_handle->upc_mask & upc);\r\n}\r\nstatic void qat_hal_get_uwords(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int uaddr,\r\nunsigned int words_num, uint64_t *uword)\r\n{\r\nunsigned int i, uwrd_lo, uwrd_hi;\r\nunsigned int ustore_addr, misc_control;\r\nqat_hal_rd_ae_csr(handle, ae, AE_MISC_CONTROL, &misc_control);\r\nqat_hal_wr_ae_csr(handle, ae, AE_MISC_CONTROL,\r\nmisc_control & 0xfffffffb);\r\nqat_hal_rd_ae_csr(handle, ae, USTORE_ADDRESS, &ustore_addr);\r\nuaddr |= UA_ECS;\r\nfor (i = 0; i < words_num; i++) {\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\r\nuaddr++;\r\nqat_hal_rd_ae_csr(handle, ae, USTORE_DATA_LOWER, &uwrd_lo);\r\nqat_hal_rd_ae_csr(handle, ae, USTORE_DATA_UPPER, &uwrd_hi);\r\nuword[i] = uwrd_hi;\r\nuword[i] = (uword[i] << 0x20) | uwrd_lo;\r\n}\r\nqat_hal_wr_ae_csr(handle, ae, AE_MISC_CONTROL, misc_control);\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, ustore_addr);\r\n}\r\nvoid qat_hal_wr_umem(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned int uaddr,\r\nunsigned int words_num, unsigned int *data)\r\n{\r\nunsigned int i, ustore_addr;\r\nqat_hal_rd_ae_csr(handle, ae, USTORE_ADDRESS, &ustore_addr);\r\nuaddr |= UA_ECS;\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\r\nfor (i = 0; i < words_num; i++) {\r\nunsigned int uwrd_lo, uwrd_hi, tmp;\r\nuwrd_lo = ((data[i] & 0xfff0000) << 4) | (0x3 << 18) |\r\n((data[i] & 0xff00) << 2) |\r\n(0x3 << 8) | (data[i] & 0xff);\r\nuwrd_hi = (0xf << 4) | ((data[i] & 0xf0000000) >> 28);\r\nuwrd_hi |= (hweight32(data[i] & 0xffff) & 0x1) << 8;\r\ntmp = ((data[i] >> 0x10) & 0xffff);\r\nuwrd_hi |= (hweight32(tmp) & 0x1) << 9;\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_LOWER, uwrd_lo);\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_UPPER, uwrd_hi);\r\n}\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, ustore_addr);\r\n}\r\nstatic int qat_hal_exec_micro_inst(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nuint64_t *micro_inst, unsigned int inst_num,\r\nint code_off, unsigned int max_cycle,\r\nunsigned int *endpc)\r\n{\r\nuint64_t savuwords[MAX_EXEC_INST];\r\nunsigned int ind_lm_addr0, ind_lm_addr1;\r\nunsigned int ind_lm_addr_byte0, ind_lm_addr_byte1;\r\nunsigned int ind_cnt_sig;\r\nunsigned int ind_sig, act_sig;\r\nunsigned int csr_val = 0, newcsr_val;\r\nunsigned int savctx;\r\nunsigned int savcc, wakeup_events, savpc;\r\nunsigned int ctxarb_ctl, ctx_enables;\r\nif ((inst_num > handle->hal_handle->max_ustore) || !micro_inst) {\r\npr_err("QAT: invalid instruction num %d\n", inst_num);\r\nreturn -EINVAL;\r\n}\r\nqat_hal_rd_indr_csr(handle, ae, ctx, LM_ADDR_0_INDIRECT, &ind_lm_addr0);\r\nqat_hal_rd_indr_csr(handle, ae, ctx, LM_ADDR_1_INDIRECT, &ind_lm_addr1);\r\nqat_hal_rd_indr_csr(handle, ae, ctx, INDIRECT_LM_ADDR_0_BYTE_INDEX,\r\n&ind_lm_addr_byte0);\r\nqat_hal_rd_indr_csr(handle, ae, ctx, INDIRECT_LM_ADDR_1_BYTE_INDEX,\r\n&ind_lm_addr_byte1);\r\nif (inst_num <= MAX_EXEC_INST)\r\nqat_hal_get_uwords(handle, ae, 0, inst_num, savuwords);\r\nqat_hal_get_wakeup_event(handle, ae, ctx, &wakeup_events);\r\nqat_hal_rd_indr_csr(handle, ae, ctx, CTX_STS_INDIRECT, &savpc);\r\nsavpc = (savpc & handle->hal_handle->upc_mask) >> 0;\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &ctx_enables);\r\nctx_enables &= IGNORE_W1C_MASK;\r\nqat_hal_rd_ae_csr(handle, ae, CC_ENABLE, &savcc);\r\nqat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS, &savctx);\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ARB_CNTL, &ctxarb_ctl);\r\nqat_hal_rd_indr_csr(handle, ae, ctx, FUTURE_COUNT_SIGNAL_INDIRECT,\r\n&ind_cnt_sig);\r\nqat_hal_rd_indr_csr(handle, ae, ctx, CTX_SIG_EVENTS_INDIRECT, &ind_sig);\r\nqat_hal_rd_ae_csr(handle, ae, CTX_SIG_EVENTS_ACTIVE, &act_sig);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\r\nqat_hal_wr_uwords(handle, ae, 0, inst_num, micro_inst);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx), CTX_STS_INDIRECT, 0);\r\nqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS, ctx & ACS_ACNO);\r\nif (code_off)\r\nqat_hal_wr_ae_csr(handle, ae, CC_ENABLE, savcc & 0xffffdfff);\r\nqat_hal_put_wakeup_event(handle, ae, (1 << ctx), XCWE_VOLUNTARY);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx), CTX_SIG_EVENTS_INDIRECT, 0);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_SIG_EVENTS_ACTIVE, 0);\r\nqat_hal_enable_ctx(handle, ae, (1 << ctx));\r\nif (qat_hal_wait_cycles(handle, ae, max_cycle, 1) != 0)\r\nreturn -EFAULT;\r\nif (endpc) {\r\nunsigned int ctx_status;\r\nqat_hal_rd_indr_csr(handle, ae, ctx, CTX_STS_INDIRECT,\r\n&ctx_status);\r\n*endpc = ctx_status & handle->hal_handle->upc_mask;\r\n}\r\nqat_hal_disable_ctx(handle, ae, (1 << ctx));\r\nif (inst_num <= MAX_EXEC_INST)\r\nqat_hal_wr_uwords(handle, ae, 0, inst_num, savuwords);\r\nqat_hal_put_wakeup_event(handle, ae, (1 << ctx), wakeup_events);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx), CTX_STS_INDIRECT,\r\nhandle->hal_handle->upc_mask & savpc);\r\nqat_hal_rd_ae_csr(handle, ae, AE_MISC_CONTROL, &csr_val);\r\nnewcsr_val = CLR_BIT(csr_val, MMC_SHARE_CS_BITPOS);\r\nqat_hal_wr_ae_csr(handle, ae, AE_MISC_CONTROL, newcsr_val);\r\nqat_hal_wr_ae_csr(handle, ae, CC_ENABLE, savcc);\r\nqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS, savctx & ACS_ACNO);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ARB_CNTL, ctxarb_ctl);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\r\nLM_ADDR_0_INDIRECT, ind_lm_addr0);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\r\nLM_ADDR_1_INDIRECT, ind_lm_addr1);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\r\nINDIRECT_LM_ADDR_0_BYTE_INDEX, ind_lm_addr_byte0);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\r\nINDIRECT_LM_ADDR_1_BYTE_INDEX, ind_lm_addr_byte1);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\r\nFUTURE_COUNT_SIGNAL_INDIRECT, ind_cnt_sig);\r\nqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\r\nCTX_SIG_EVENTS_INDIRECT, ind_sig);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_SIG_EVENTS_ACTIVE, act_sig);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\r\nreturn 0;\r\n}\r\nstatic int qat_hal_rd_rel_reg(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_num, unsigned int *data)\r\n{\r\nunsigned int savctx, uaddr, uwrd_lo, uwrd_hi;\r\nunsigned int ctxarb_cntl, ustore_addr, ctx_enables;\r\nunsigned short reg_addr;\r\nint status = 0;\r\nuint64_t insts, savuword;\r\nreg_addr = qat_hal_get_reg_addr(reg_type, reg_num);\r\nif (reg_addr == BAD_REGADDR) {\r\npr_err("QAT: bad regaddr=0x%x\n", reg_addr);\r\nreturn -EINVAL;\r\n}\r\nswitch (reg_type) {\r\ncase ICP_GPA_REL:\r\ninsts = 0xA070000000ull | (reg_addr & 0x3ff);\r\nbreak;\r\ndefault:\r\ninsts = (uint64_t)0xA030000000ull | ((reg_addr & 0x3ff) << 10);\r\nbreak;\r\n}\r\nqat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS, &savctx);\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ARB_CNTL, &ctxarb_cntl);\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &ctx_enables);\r\nctx_enables &= IGNORE_W1C_MASK;\r\nif (ctx != (savctx & ACS_ACNO))\r\nqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS,\r\nctx & ACS_ACNO);\r\nqat_hal_get_uwords(handle, ae, 0, 1, &savuword);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\r\nqat_hal_rd_ae_csr(handle, ae, USTORE_ADDRESS, &ustore_addr);\r\nuaddr = UA_ECS;\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\r\ninsts = qat_hal_set_uword_ecc(insts);\r\nuwrd_lo = (unsigned int)(insts & 0xffffffff);\r\nuwrd_hi = (unsigned int)(insts >> 0x20);\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_LOWER, uwrd_lo);\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_UPPER, uwrd_hi);\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\r\nqat_hal_wait_cycles(handle, ae, 0x8, 0);\r\nqat_hal_rd_ae_csr(handle, ae, ALU_OUT, data);\r\nqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, ustore_addr);\r\nqat_hal_wr_uwords(handle, ae, 0, 1, &savuword);\r\nif (ctx != (savctx & ACS_ACNO))\r\nqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS,\r\nsavctx & ACS_ACNO);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ARB_CNTL, ctxarb_cntl);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\r\nreturn status;\r\n}\r\nstatic int qat_hal_wr_rel_reg(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_num, unsigned int data)\r\n{\r\nunsigned short src_hiaddr, src_lowaddr, dest_addr, data16hi, data16lo;\r\nuint64_t insts[] = {\r\n0x0F440000000ull,\r\n0x0F040000000ull,\r\n0x0F0000C0300ull,\r\n0x0E000010000ull\r\n};\r\nconst int num_inst = ARRAY_SIZE(insts), code_off = 1;\r\nconst int imm_w1 = 0, imm_w0 = 1;\r\ndest_addr = qat_hal_get_reg_addr(reg_type, reg_num);\r\nif (dest_addr == BAD_REGADDR) {\r\npr_err("QAT: bad destAddr=0x%x\n", dest_addr);\r\nreturn -EINVAL;\r\n}\r\ndata16lo = 0xffff & data;\r\ndata16hi = 0xffff & (data >> 0x10);\r\nsrc_hiaddr = qat_hal_get_reg_addr(ICP_NO_DEST, (unsigned short)\r\n(0xff & data16hi));\r\nsrc_lowaddr = qat_hal_get_reg_addr(ICP_NO_DEST, (unsigned short)\r\n(0xff & data16lo));\r\nswitch (reg_type) {\r\ncase ICP_GPA_REL:\r\ninsts[imm_w1] = insts[imm_w1] | ((data16hi >> 8) << 20) |\r\n((src_hiaddr & 0x3ff) << 10) | (dest_addr & 0x3ff);\r\ninsts[imm_w0] = insts[imm_w0] | ((data16lo >> 8) << 20) |\r\n((src_lowaddr & 0x3ff) << 10) | (dest_addr & 0x3ff);\r\nbreak;\r\ndefault:\r\ninsts[imm_w1] = insts[imm_w1] | ((data16hi >> 8) << 20) |\r\n((dest_addr & 0x3ff) << 10) | (src_hiaddr & 0x3ff);\r\ninsts[imm_w0] = insts[imm_w0] | ((data16lo >> 8) << 20) |\r\n((dest_addr & 0x3ff) << 10) | (src_lowaddr & 0x3ff);\r\nbreak;\r\n}\r\nreturn qat_hal_exec_micro_inst(handle, ae, ctx, insts, num_inst,\r\ncode_off, num_inst * 0x5, NULL);\r\n}\r\nint qat_hal_get_ins_num(void)\r\n{\r\nreturn ARRAY_SIZE(inst_4b);\r\n}\r\nstatic int qat_hal_concat_micro_code(uint64_t *micro_inst,\r\nunsigned int inst_num, unsigned int size,\r\nunsigned int addr, unsigned int *value)\r\n{\r\nint i, val_indx;\r\nunsigned int cur_value;\r\nconst uint64_t *inst_arr;\r\nint fixup_offset;\r\nint usize = 0;\r\nint orig_num;\r\norig_num = inst_num;\r\nval_indx = 0;\r\ncur_value = value[val_indx++];\r\ninst_arr = inst_4b;\r\nusize = ARRAY_SIZE(inst_4b);\r\nfixup_offset = inst_num;\r\nfor (i = 0; i < usize; i++)\r\nmicro_inst[inst_num++] = inst_arr[i];\r\nINSERT_IMMED_GPRA_CONST(micro_inst[fixup_offset], (addr));\r\nfixup_offset++;\r\nINSERT_IMMED_GPRA_CONST(micro_inst[fixup_offset], 0);\r\nfixup_offset++;\r\nINSERT_IMMED_GPRB_CONST(micro_inst[fixup_offset], (cur_value >> 0));\r\nfixup_offset++;\r\nINSERT_IMMED_GPRB_CONST(micro_inst[fixup_offset], (cur_value >> 0x10));\r\nreturn inst_num - orig_num;\r\n}\r\nstatic int qat_hal_exec_micro_init_lm(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nint *pfirst_exec, uint64_t *micro_inst,\r\nunsigned int inst_num)\r\n{\r\nint stat = 0;\r\nunsigned int gpra0 = 0, gpra1 = 0, gpra2 = 0;\r\nunsigned int gprb0 = 0, gprb1 = 0;\r\nif (*pfirst_exec) {\r\nqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0, &gpra0);\r\nqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0x1, &gpra1);\r\nqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0x2, &gpra2);\r\nqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPB_REL, 0, &gprb0);\r\nqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPB_REL, 0x1, &gprb1);\r\n*pfirst_exec = 0;\r\n}\r\nstat = qat_hal_exec_micro_inst(handle, ae, ctx, micro_inst, inst_num, 1,\r\ninst_num * 0x5, NULL);\r\nif (stat != 0)\r\nreturn -EFAULT;\r\nqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0, gpra0);\r\nqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0x1, gpra1);\r\nqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0x2, gpra2);\r\nqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPB_REL, 0, gprb0);\r\nqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPB_REL, 0x1, gprb1);\r\nreturn 0;\r\n}\r\nint qat_hal_batch_wr_lm(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae,\r\nstruct icp_qat_uof_batch_init *lm_init_header)\r\n{\r\nstruct icp_qat_uof_batch_init *plm_init;\r\nuint64_t *micro_inst_arry;\r\nint micro_inst_num;\r\nint alloc_inst_size;\r\nint first_exec = 1;\r\nint stat = 0;\r\nplm_init = lm_init_header->next;\r\nalloc_inst_size = lm_init_header->size;\r\nif ((unsigned int)alloc_inst_size > handle->hal_handle->max_ustore)\r\nalloc_inst_size = handle->hal_handle->max_ustore;\r\nmicro_inst_arry = kmalloc_array(alloc_inst_size, sizeof(uint64_t),\r\nGFP_KERNEL);\r\nif (!micro_inst_arry)\r\nreturn -ENOMEM;\r\nmicro_inst_num = 0;\r\nwhile (plm_init) {\r\nunsigned int addr, *value, size;\r\nae = plm_init->ae;\r\naddr = plm_init->addr;\r\nvalue = plm_init->value;\r\nsize = plm_init->size;\r\nmicro_inst_num += qat_hal_concat_micro_code(micro_inst_arry,\r\nmicro_inst_num,\r\nsize, addr, value);\r\nplm_init = plm_init->next;\r\n}\r\nif (micro_inst_arry && (micro_inst_num > 0)) {\r\nmicro_inst_arry[micro_inst_num++] = 0x0E000010000ull;\r\nstat = qat_hal_exec_micro_init_lm(handle, ae, 0, &first_exec,\r\nmicro_inst_arry,\r\nmicro_inst_num);\r\n}\r\nkfree(micro_inst_arry);\r\nreturn stat;\r\n}\r\nstatic int qat_hal_put_rel_rd_xfer(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_num, unsigned int val)\r\n{\r\nint status = 0;\r\nunsigned int reg_addr;\r\nunsigned int ctx_enables;\r\nunsigned short mask;\r\nunsigned short dr_offset = 0x10;\r\nstatus = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &ctx_enables);\r\nif (CE_INUSE_CONTEXTS & ctx_enables) {\r\nif (ctx & 0x1) {\r\npr_err("QAT: bad 4-ctx mode,ctx=0x%x\n", ctx);\r\nreturn -EINVAL;\r\n}\r\nmask = 0x1f;\r\ndr_offset = 0x20;\r\n} else {\r\nmask = 0x0f;\r\n}\r\nif (reg_num & ~mask)\r\nreturn -EINVAL;\r\nreg_addr = reg_num + (ctx << 0x5);\r\nswitch (reg_type) {\r\ncase ICP_SR_RD_REL:\r\ncase ICP_SR_REL:\r\nSET_AE_XFER(handle, ae, reg_addr, val);\r\nbreak;\r\ncase ICP_DR_RD_REL:\r\ncase ICP_DR_REL:\r\nSET_AE_XFER(handle, ae, (reg_addr + dr_offset), val);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic int qat_hal_put_rel_wr_xfer(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_num, unsigned int data)\r\n{\r\nunsigned int gprval, ctx_enables;\r\nunsigned short src_hiaddr, src_lowaddr, gpr_addr, xfr_addr, data16hi,\r\ndata16low;\r\nunsigned short reg_mask;\r\nint status = 0;\r\nuint64_t micro_inst[] = {\r\n0x0F440000000ull,\r\n0x0F040000000ull,\r\n0x0A000000000ull,\r\n0x0F0000C0300ull,\r\n0x0E000010000ull\r\n};\r\nconst int num_inst = ARRAY_SIZE(micro_inst), code_off = 1;\r\nconst unsigned short gprnum = 0, dly = num_inst * 0x5;\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &ctx_enables);\r\nif (CE_INUSE_CONTEXTS & ctx_enables) {\r\nif (ctx & 0x1) {\r\npr_err("QAT: 4-ctx mode,ctx=0x%x\n", ctx);\r\nreturn -EINVAL;\r\n}\r\nreg_mask = (unsigned short)~0x1f;\r\n} else {\r\nreg_mask = (unsigned short)~0xf;\r\n}\r\nif (reg_num & reg_mask)\r\nreturn -EINVAL;\r\nxfr_addr = qat_hal_get_reg_addr(reg_type, reg_num);\r\nif (xfr_addr == BAD_REGADDR) {\r\npr_err("QAT: bad xfrAddr=0x%x\n", xfr_addr);\r\nreturn -EINVAL;\r\n}\r\nqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPB_REL, gprnum, &gprval);\r\ngpr_addr = qat_hal_get_reg_addr(ICP_GPB_REL, gprnum);\r\ndata16low = 0xffff & data;\r\ndata16hi = 0xffff & (data >> 0x10);\r\nsrc_hiaddr = qat_hal_get_reg_addr(ICP_NO_DEST,\r\n(unsigned short)(0xff & data16hi));\r\nsrc_lowaddr = qat_hal_get_reg_addr(ICP_NO_DEST,\r\n(unsigned short)(0xff & data16low));\r\nmicro_inst[0] = micro_inst[0x0] | ((data16hi >> 8) << 20) |\r\n((gpr_addr & 0x3ff) << 10) | (src_hiaddr & 0x3ff);\r\nmicro_inst[1] = micro_inst[0x1] | ((data16low >> 8) << 20) |\r\n((gpr_addr & 0x3ff) << 10) | (src_lowaddr & 0x3ff);\r\nmicro_inst[0x2] = micro_inst[0x2] |\r\n((xfr_addr & 0x3ff) << 20) | ((gpr_addr & 0x3ff) << 10);\r\nstatus = qat_hal_exec_micro_inst(handle, ae, ctx, micro_inst, num_inst,\r\ncode_off, dly, NULL);\r\nqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPB_REL, gprnum, gprval);\r\nreturn status;\r\n}\r\nstatic int qat_hal_put_rel_nn(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx,\r\nunsigned short nn, unsigned int val)\r\n{\r\nunsigned int ctx_enables;\r\nint stat = 0;\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &ctx_enables);\r\nctx_enables &= IGNORE_W1C_MASK;\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables | CE_NN_MODE);\r\nstat = qat_hal_put_rel_wr_xfer(handle, ae, ctx, ICP_NEIGH_REL, nn, val);\r\nqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\r\nreturn stat;\r\n}\r\nstatic int qat_hal_convert_abs_to_rel(struct icp_qat_fw_loader_handle\r\n*handle, unsigned char ae,\r\nunsigned short absreg_num,\r\nunsigned short *relreg,\r\nunsigned char *ctx)\r\n{\r\nunsigned int ctx_enables;\r\nqat_hal_rd_ae_csr(handle, ae, CTX_ENABLES, &ctx_enables);\r\nif (ctx_enables & CE_INUSE_CONTEXTS) {\r\n*relreg = absreg_num & 0x1F;\r\n*ctx = (absreg_num >> 0x4) & 0x6;\r\n} else {\r\n*relreg = absreg_num & 0x0F;\r\n*ctx = (absreg_num >> 0x4) & 0x7;\r\n}\r\nreturn 0;\r\n}\r\nint qat_hal_init_gpr(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx_mask,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_num, unsigned int regdata)\r\n{\r\nint stat = 0;\r\nunsigned short reg;\r\nunsigned char ctx = 0;\r\nenum icp_qat_uof_regtype type;\r\nif (reg_num >= ICP_QAT_UCLO_MAX_GPR_REG)\r\nreturn -EINVAL;\r\ndo {\r\nif (ctx_mask == 0) {\r\nqat_hal_convert_abs_to_rel(handle, ae, reg_num, &reg,\r\n&ctx);\r\ntype = reg_type - 1;\r\n} else {\r\nreg = reg_num;\r\ntype = reg_type;\r\nif (!test_bit(ctx, (unsigned long *)&ctx_mask))\r\ncontinue;\r\n}\r\nstat = qat_hal_wr_rel_reg(handle, ae, ctx, type, reg, regdata);\r\nif (stat) {\r\npr_err("QAT: write gpr fail\n");\r\nreturn -EINVAL;\r\n}\r\n} while (ctx_mask && (ctx++ < ICP_QAT_UCLO_MAX_CTX));\r\nreturn 0;\r\n}\r\nint qat_hal_init_wr_xfer(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx_mask,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_num, unsigned int regdata)\r\n{\r\nint stat = 0;\r\nunsigned short reg;\r\nunsigned char ctx = 0;\r\nenum icp_qat_uof_regtype type;\r\nif (reg_num >= ICP_QAT_UCLO_MAX_XFER_REG)\r\nreturn -EINVAL;\r\ndo {\r\nif (ctx_mask == 0) {\r\nqat_hal_convert_abs_to_rel(handle, ae, reg_num, &reg,\r\n&ctx);\r\ntype = reg_type - 3;\r\n} else {\r\nreg = reg_num;\r\ntype = reg_type;\r\nif (!test_bit(ctx, (unsigned long *)&ctx_mask))\r\ncontinue;\r\n}\r\nstat = qat_hal_put_rel_wr_xfer(handle, ae, ctx, type, reg,\r\nregdata);\r\nif (stat) {\r\npr_err("QAT: write wr xfer fail\n");\r\nreturn -EINVAL;\r\n}\r\n} while (ctx_mask && (ctx++ < ICP_QAT_UCLO_MAX_CTX));\r\nreturn 0;\r\n}\r\nint qat_hal_init_rd_xfer(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx_mask,\r\nenum icp_qat_uof_regtype reg_type,\r\nunsigned short reg_num, unsigned int regdata)\r\n{\r\nint stat = 0;\r\nunsigned short reg;\r\nunsigned char ctx = 0;\r\nenum icp_qat_uof_regtype type;\r\nif (reg_num >= ICP_QAT_UCLO_MAX_XFER_REG)\r\nreturn -EINVAL;\r\ndo {\r\nif (ctx_mask == 0) {\r\nqat_hal_convert_abs_to_rel(handle, ae, reg_num, &reg,\r\n&ctx);\r\ntype = reg_type - 3;\r\n} else {\r\nreg = reg_num;\r\ntype = reg_type;\r\nif (!test_bit(ctx, (unsigned long *)&ctx_mask))\r\ncontinue;\r\n}\r\nstat = qat_hal_put_rel_rd_xfer(handle, ae, ctx, type, reg,\r\nregdata);\r\nif (stat) {\r\npr_err("QAT: write rd xfer fail\n");\r\nreturn -EINVAL;\r\n}\r\n} while (ctx_mask && (ctx++ < ICP_QAT_UCLO_MAX_CTX));\r\nreturn 0;\r\n}\r\nint qat_hal_init_nn(struct icp_qat_fw_loader_handle *handle,\r\nunsigned char ae, unsigned char ctx_mask,\r\nunsigned short reg_num, unsigned int regdata)\r\n{\r\nint stat = 0;\r\nunsigned char ctx;\r\nif (ctx_mask == 0)\r\nreturn -EINVAL;\r\nfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++) {\r\nif (!test_bit(ctx, (unsigned long *)&ctx_mask))\r\ncontinue;\r\nstat = qat_hal_put_rel_nn(handle, ae, ctx, reg_num, regdata);\r\nif (stat) {\r\npr_err("QAT: write neigh error\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}
