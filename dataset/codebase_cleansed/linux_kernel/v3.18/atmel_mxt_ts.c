static size_t mxt_obj_size(const struct mxt_object *obj)\r\n{\r\nreturn obj->size_minus_one + 1;\r\n}\r\nstatic size_t mxt_obj_instances(const struct mxt_object *obj)\r\n{\r\nreturn obj->instances_minus_one + 1;\r\n}\r\nstatic bool mxt_object_readable(unsigned int type)\r\n{\r\nswitch (type) {\r\ncase MXT_GEN_COMMAND_T6:\r\ncase MXT_GEN_POWER_T7:\r\ncase MXT_GEN_ACQUIRE_T8:\r\ncase MXT_GEN_DATASOURCE_T53:\r\ncase MXT_TOUCH_MULTI_T9:\r\ncase MXT_TOUCH_KEYARRAY_T15:\r\ncase MXT_TOUCH_PROXIMITY_T23:\r\ncase MXT_TOUCH_PROXKEY_T52:\r\ncase MXT_PROCI_GRIPFACE_T20:\r\ncase MXT_PROCG_NOISE_T22:\r\ncase MXT_PROCI_ONETOUCH_T24:\r\ncase MXT_PROCI_TWOTOUCH_T27:\r\ncase MXT_PROCI_GRIP_T40:\r\ncase MXT_PROCI_PALM_T41:\r\ncase MXT_PROCI_TOUCHSUPPRESSION_T42:\r\ncase MXT_PROCI_STYLUS_T47:\r\ncase MXT_PROCG_NOISESUPPRESSION_T48:\r\ncase MXT_SPT_COMMSCONFIG_T18:\r\ncase MXT_SPT_GPIOPWM_T19:\r\ncase MXT_SPT_SELFTEST_T25:\r\ncase MXT_SPT_CTECONFIG_T28:\r\ncase MXT_SPT_USERDATA_T38:\r\ncase MXT_SPT_DIGITIZER_T43:\r\ncase MXT_SPT_CTECONFIG_T46:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void mxt_dump_message(struct mxt_data *data, u8 *message)\r\n{\r\ndev_dbg(&data->client->dev, "message: %*ph\n",\r\ndata->T5_msg_size, message);\r\n}\r\nstatic int mxt_wait_for_completion(struct mxt_data *data,\r\nstruct completion *comp,\r\nunsigned int timeout_ms)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nunsigned long timeout = msecs_to_jiffies(timeout_ms);\r\nlong ret;\r\nret = wait_for_completion_interruptible_timeout(comp, timeout);\r\nif (ret < 0) {\r\nreturn ret;\r\n} else if (ret == 0) {\r\ndev_err(dev, "Wait for completion timed out.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_bootloader_read(struct mxt_data *data,\r\nu8 *val, unsigned int count)\r\n{\r\nint ret;\r\nstruct i2c_msg msg;\r\nmsg.addr = data->bootloader_addr;\r\nmsg.flags = data->client->flags & I2C_M_TEN;\r\nmsg.flags |= I2C_M_RD;\r\nmsg.len = count;\r\nmsg.buf = val;\r\nret = i2c_transfer(data->client->adapter, &msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\nret = ret < 0 ? ret : -EIO;\r\ndev_err(&data->client->dev, "%s: i2c recv failed (%d)\n",\r\n__func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxt_bootloader_write(struct mxt_data *data,\r\nconst u8 * const val, unsigned int count)\r\n{\r\nint ret;\r\nstruct i2c_msg msg;\r\nmsg.addr = data->bootloader_addr;\r\nmsg.flags = data->client->flags & I2C_M_TEN;\r\nmsg.len = count;\r\nmsg.buf = (u8 *)val;\r\nret = i2c_transfer(data->client->adapter, &msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\nret = ret < 0 ? ret : -EIO;\r\ndev_err(&data->client->dev, "%s: i2c send failed (%d)\n",\r\n__func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxt_lookup_bootloader_address(struct mxt_data *data, bool retry)\r\n{\r\nu8 appmode = data->client->addr;\r\nu8 bootloader;\r\nswitch (appmode) {\r\ncase 0x4a:\r\ncase 0x4b:\r\nif (retry || data->info.family_id >= 0xa2) {\r\nbootloader = appmode - 0x24;\r\nbreak;\r\n}\r\ncase 0x4c:\r\ncase 0x4d:\r\ncase 0x5a:\r\ncase 0x5b:\r\nbootloader = appmode - 0x26;\r\nbreak;\r\ndefault:\r\ndev_err(&data->client->dev,\r\n"Appmode i2c address 0x%02x not found\n",\r\nappmode);\r\nreturn -EINVAL;\r\n}\r\ndata->bootloader_addr = bootloader;\r\nreturn 0;\r\n}\r\nstatic int mxt_probe_bootloader(struct mxt_data *data, bool alt_address)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nint error;\r\nu8 val;\r\nbool crc_failure;\r\nerror = mxt_lookup_bootloader_address(data, alt_address);\r\nif (error)\r\nreturn error;\r\nerror = mxt_bootloader_read(data, &val, 1);\r\nif (error)\r\nreturn error;\r\ncrc_failure = (val & ~MXT_BOOT_STATUS_MASK) == MXT_APP_CRC_FAIL;\r\ndev_err(dev, "Detected bootloader, status:%02X%s\n",\r\nval, crc_failure ? ", APP_CRC_FAIL" : "");\r\nreturn 0;\r\n}\r\nstatic u8 mxt_get_bootloader_version(struct mxt_data *data, u8 val)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nu8 buf[3];\r\nif (val & MXT_BOOT_EXTENDED_ID) {\r\nif (mxt_bootloader_read(data, &buf[0], 3) != 0) {\r\ndev_err(dev, "%s: i2c failure\n", __func__);\r\nreturn val;\r\n}\r\ndev_dbg(dev, "Bootloader ID:%d Version:%d\n", buf[1], buf[2]);\r\nreturn buf[0];\r\n} else {\r\ndev_dbg(dev, "Bootloader ID:%d\n", val & MXT_BOOT_ID_MASK);\r\nreturn val;\r\n}\r\n}\r\nstatic int mxt_check_bootloader(struct mxt_data *data, unsigned int state,\r\nbool wait)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nu8 val;\r\nint ret;\r\nrecheck:\r\nif (wait) {\r\nret = mxt_wait_for_completion(data, &data->bl_completion,\r\nMXT_FW_CHG_TIMEOUT);\r\nif (ret) {\r\ndev_err(dev, "Update wait error %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = mxt_bootloader_read(data, &val, 1);\r\nif (ret)\r\nreturn ret;\r\nif (state == MXT_WAITING_BOOTLOAD_CMD)\r\nval = mxt_get_bootloader_version(data, val);\r\nswitch (state) {\r\ncase MXT_WAITING_BOOTLOAD_CMD:\r\ncase MXT_WAITING_FRAME_DATA:\r\ncase MXT_APP_CRC_FAIL:\r\nval &= ~MXT_BOOT_STATUS_MASK;\r\nbreak;\r\ncase MXT_FRAME_CRC_PASS:\r\nif (val == MXT_FRAME_CRC_CHECK) {\r\ngoto recheck;\r\n} else if (val == MXT_FRAME_CRC_FAIL) {\r\ndev_err(dev, "Bootloader CRC fail\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (val != state) {\r\ndev_err(dev, "Invalid bootloader state %02X != %02X\n",\r\nval, state);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_send_bootloader_cmd(struct mxt_data *data, bool unlock)\r\n{\r\nint ret;\r\nu8 buf[2];\r\nif (unlock) {\r\nbuf[0] = MXT_UNLOCK_CMD_LSB;\r\nbuf[1] = MXT_UNLOCK_CMD_MSB;\r\n} else {\r\nbuf[0] = 0x01;\r\nbuf[1] = 0x01;\r\n}\r\nret = mxt_bootloader_write(data, buf, 2);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int __mxt_read_reg(struct i2c_client *client,\r\nu16 reg, u16 len, void *val)\r\n{\r\nstruct i2c_msg xfer[2];\r\nu8 buf[2];\r\nint ret;\r\nbuf[0] = reg & 0xff;\r\nbuf[1] = (reg >> 8) & 0xff;\r\nxfer[0].addr = client->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].len = 2;\r\nxfer[0].buf = buf;\r\nxfer[1].addr = client->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = len;\r\nxfer[1].buf = val;\r\nret = i2c_transfer(client->adapter, xfer, 2);\r\nif (ret == 2) {\r\nret = 0;\r\n} else {\r\nif (ret >= 0)\r\nret = -EIO;\r\ndev_err(&client->dev, "%s: i2c transfer failed (%d)\n",\r\n__func__, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __mxt_write_reg(struct i2c_client *client, u16 reg, u16 len,\r\nconst void *val)\r\n{\r\nu8 *buf;\r\nsize_t count;\r\nint ret;\r\ncount = len + 2;\r\nbuf = kmalloc(count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = reg & 0xff;\r\nbuf[1] = (reg >> 8) & 0xff;\r\nmemcpy(&buf[2], val, len);\r\nret = i2c_master_send(client, buf, count);\r\nif (ret == count) {\r\nret = 0;\r\n} else {\r\nif (ret >= 0)\r\nret = -EIO;\r\ndev_err(&client->dev, "%s: i2c send failed (%d)\n",\r\n__func__, ret);\r\n}\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int mxt_write_reg(struct i2c_client *client, u16 reg, u8 val)\r\n{\r\nreturn __mxt_write_reg(client, reg, 1, &val);\r\n}\r\nstatic struct mxt_object *\r\nmxt_get_object(struct mxt_data *data, u8 type)\r\n{\r\nstruct mxt_object *object;\r\nint i;\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nobject = data->object_table + i;\r\nif (object->type == type)\r\nreturn object;\r\n}\r\ndev_warn(&data->client->dev, "Invalid object type T%u\n", type);\r\nreturn NULL;\r\n}\r\nstatic void mxt_proc_t6_messages(struct mxt_data *data, u8 *msg)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nu8 status = msg[1];\r\nu32 crc = msg[2] | (msg[3] << 8) | (msg[4] << 16);\r\ncomplete(&data->crc_completion);\r\nif (crc != data->config_crc) {\r\ndata->config_crc = crc;\r\ndev_dbg(dev, "T6 Config Checksum: 0x%06X\n", crc);\r\n}\r\nif (status & MXT_T6_STATUS_RESET)\r\ncomplete(&data->reset_completion);\r\nif (status != data->t6_status)\r\ndev_dbg(dev, "T6 Status 0x%02X%s%s%s%s%s%s%s\n",\r\nstatus,\r\nstatus == 0 ? " OK" : "",\r\nstatus & MXT_T6_STATUS_RESET ? " RESET" : "",\r\nstatus & MXT_T6_STATUS_OFL ? " OFL" : "",\r\nstatus & MXT_T6_STATUS_SIGERR ? " SIGERR" : "",\r\nstatus & MXT_T6_STATUS_CAL ? " CAL" : "",\r\nstatus & MXT_T6_STATUS_CFGERR ? " CFGERR" : "",\r\nstatus & MXT_T6_STATUS_COMSERR ? " COMSERR" : "");\r\ndata->t6_status = status;\r\n}\r\nstatic void mxt_input_button(struct mxt_data *data, u8 *message)\r\n{\r\nstruct input_dev *input = data->input_dev;\r\nconst struct mxt_platform_data *pdata = data->pdata;\r\nbool button;\r\nint i;\r\nfor (i = 0; i < pdata->t19_num_keys; i++) {\r\nif (pdata->t19_keymap[i] == KEY_RESERVED)\r\ncontinue;\r\nbutton = !(message[1] & (1 << i));\r\ninput_report_key(input, pdata->t19_keymap[i], button);\r\n}\r\n}\r\nstatic void mxt_input_sync(struct mxt_data *data)\r\n{\r\ninput_mt_report_pointer_emulation(data->input_dev,\r\ndata->pdata->t19_num_keys);\r\ninput_sync(data->input_dev);\r\n}\r\nstatic void mxt_proc_t9_message(struct mxt_data *data, u8 *message)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nstruct input_dev *input_dev = data->input_dev;\r\nint id;\r\nu8 status;\r\nint x;\r\nint y;\r\nint area;\r\nint amplitude;\r\nid = message[0] - data->T9_reportid_min;\r\nstatus = message[1];\r\nx = (message[2] << 4) | ((message[4] >> 4) & 0xf);\r\ny = (message[3] << 4) | ((message[4] & 0xf));\r\nif (data->max_x < 1024)\r\nx >>= 2;\r\nif (data->max_y < 1024)\r\ny >>= 2;\r\narea = message[5];\r\namplitude = message[6];\r\ndev_dbg(dev,\r\n"[%u] %c%c%c%c%c%c%c%c x: %5u y: %5u area: %3u amp: %3u\n",\r\nid,\r\n(status & MXT_T9_DETECT) ? 'D' : '.',\r\n(status & MXT_T9_PRESS) ? 'P' : '.',\r\n(status & MXT_T9_RELEASE) ? 'R' : '.',\r\n(status & MXT_T9_MOVE) ? 'M' : '.',\r\n(status & MXT_T9_VECTOR) ? 'V' : '.',\r\n(status & MXT_T9_AMP) ? 'A' : '.',\r\n(status & MXT_T9_SUPPRESS) ? 'S' : '.',\r\n(status & MXT_T9_UNGRIP) ? 'U' : '.',\r\nx, y, area, amplitude);\r\ninput_mt_slot(input_dev, id);\r\nif (status & MXT_T9_DETECT) {\r\nif (status & MXT_T9_RELEASE) {\r\ninput_mt_report_slot_state(input_dev,\r\nMT_TOOL_FINGER, 0);\r\nmxt_input_sync(data);\r\n}\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER, 1);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_Y, y);\r\ninput_report_abs(input_dev, ABS_MT_PRESSURE, amplitude);\r\ninput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, area);\r\n} else {\r\ninput_mt_report_slot_state(input_dev, MT_TOOL_FINGER, 0);\r\n}\r\ndata->update_input = true;\r\n}\r\nstatic int mxt_proc_message(struct mxt_data *data, u8 *message)\r\n{\r\nu8 report_id = message[0];\r\nif (report_id == MXT_RPTID_NOMSG)\r\nreturn 0;\r\nif (report_id == data->T6_reportid) {\r\nmxt_proc_t6_messages(data, message);\r\n} else if (!data->input_dev) {\r\nmxt_dump_message(data, message);\r\n} else if (report_id >= data->T9_reportid_min\r\n&& report_id <= data->T9_reportid_max) {\r\nmxt_proc_t9_message(data, message);\r\n} else if (report_id == data->T19_reportid) {\r\nmxt_input_button(data, message);\r\ndata->update_input = true;\r\n} else {\r\nmxt_dump_message(data, message);\r\n}\r\nreturn 1;\r\n}\r\nstatic int mxt_read_and_process_messages(struct mxt_data *data, u8 count)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nint ret;\r\nint i;\r\nu8 num_valid = 0;\r\nif (count > data->max_reportid)\r\nreturn -EINVAL;\r\nret = __mxt_read_reg(data->client, data->T5_address,\r\ndata->T5_msg_size * count, data->msg_buf);\r\nif (ret) {\r\ndev_err(dev, "Failed to read %u messages (%d)\n", count, ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nret = mxt_proc_message(data,\r\ndata->msg_buf + data->T5_msg_size * i);\r\nif (ret == 1)\r\nnum_valid++;\r\n}\r\nreturn num_valid;\r\n}\r\nstatic irqreturn_t mxt_process_messages_t44(struct mxt_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nint ret;\r\nu8 count, num_left;\r\nret = __mxt_read_reg(data->client, data->T44_address,\r\ndata->T5_msg_size + 1, data->msg_buf);\r\nif (ret) {\r\ndev_err(dev, "Failed to read T44 and T5 (%d)\n", ret);\r\nreturn IRQ_NONE;\r\n}\r\ncount = data->msg_buf[0];\r\nif (count == 0) {\r\ndev_dbg(dev, "Interrupt triggered but zero messages\n");\r\nreturn IRQ_NONE;\r\n} else if (count > data->max_reportid) {\r\ndev_err(dev, "T44 count %d exceeded max report id\n", count);\r\ncount = data->max_reportid;\r\n}\r\nret = mxt_proc_message(data, data->msg_buf + 1);\r\nif (ret < 0) {\r\ndev_warn(dev, "Unexpected invalid message\n");\r\nreturn IRQ_NONE;\r\n}\r\nnum_left = count - 1;\r\nif (num_left) {\r\nret = mxt_read_and_process_messages(data, num_left);\r\nif (ret < 0)\r\ngoto end;\r\nelse if (ret != num_left)\r\ndev_warn(dev, "Unexpected invalid message\n");\r\n}\r\nend:\r\nif (data->update_input) {\r\nmxt_input_sync(data);\r\ndata->update_input = false;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxt_process_messages_until_invalid(struct mxt_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nint count, read;\r\nu8 tries = 2;\r\ncount = data->max_reportid;\r\ndo {\r\nread = mxt_read_and_process_messages(data, count);\r\nif (read < count)\r\nreturn 0;\r\n} while (--tries);\r\nif (data->update_input) {\r\nmxt_input_sync(data);\r\ndata->update_input = false;\r\n}\r\ndev_err(dev, "CHG pin isn't cleared\n");\r\nreturn -EBUSY;\r\n}\r\nstatic irqreturn_t mxt_process_messages(struct mxt_data *data)\r\n{\r\nint total_handled, num_handled;\r\nu8 count = data->last_message_count;\r\nif (count < 1 || count > data->max_reportid)\r\ncount = 1;\r\ntotal_handled = mxt_read_and_process_messages(data, count + 1);\r\nif (total_handled < 0)\r\nreturn IRQ_NONE;\r\nelse if (total_handled <= count)\r\ngoto update_count;\r\ndo {\r\nnum_handled = mxt_read_and_process_messages(data, 2);\r\nif (num_handled < 0)\r\nreturn IRQ_NONE;\r\ntotal_handled += num_handled;\r\nif (num_handled < 2)\r\nbreak;\r\n} while (total_handled < data->num_touchids);\r\nupdate_count:\r\ndata->last_message_count = total_handled;\r\nif (data->update_input) {\r\nmxt_input_sync(data);\r\ndata->update_input = false;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mxt_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mxt_data *data = dev_id;\r\nif (data->in_bootloader) {\r\ncomplete(&data->bl_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!data->object_table)\r\nreturn IRQ_HANDLED;\r\nif (data->T44_address) {\r\nreturn mxt_process_messages_t44(data);\r\n} else {\r\nreturn mxt_process_messages(data);\r\n}\r\n}\r\nstatic int mxt_t6_command(struct mxt_data *data, u16 cmd_offset,\r\nu8 value, bool wait)\r\n{\r\nu16 reg;\r\nu8 command_register;\r\nint timeout_counter = 0;\r\nint ret;\r\nreg = data->T6_address + cmd_offset;\r\nret = mxt_write_reg(data->client, reg, value);\r\nif (ret)\r\nreturn ret;\r\nif (!wait)\r\nreturn 0;\r\ndo {\r\nmsleep(20);\r\nret = __mxt_read_reg(data->client, reg, 1, &command_register);\r\nif (ret)\r\nreturn ret;\r\n} while (command_register != 0 && timeout_counter++ <= 100);\r\nif (timeout_counter > 100) {\r\ndev_err(&data->client->dev, "Command failed!\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_soft_reset(struct mxt_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nint ret = 0;\r\ndev_info(dev, "Resetting chip\n");\r\nreinit_completion(&data->reset_completion);\r\nret = mxt_t6_command(data, MXT_COMMAND_RESET, MXT_RESET_VALUE, false);\r\nif (ret)\r\nreturn ret;\r\nret = mxt_wait_for_completion(data, &data->reset_completion,\r\nMXT_RESET_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void mxt_update_crc(struct mxt_data *data, u8 cmd, u8 value)\r\n{\r\ndata->config_crc = 0;\r\nreinit_completion(&data->crc_completion);\r\nmxt_t6_command(data, cmd, value, true);\r\nmxt_wait_for_completion(data, &data->crc_completion, MXT_CRC_TIMEOUT);\r\n}\r\nstatic void mxt_calc_crc24(u32 *crc, u8 firstbyte, u8 secondbyte)\r\n{\r\nstatic const unsigned int crcpoly = 0x80001B;\r\nu32 result;\r\nu32 data_word;\r\ndata_word = (secondbyte << 8) | firstbyte;\r\nresult = ((*crc << 1) ^ data_word);\r\nif (result & 0x1000000)\r\nresult ^= crcpoly;\r\n*crc = result;\r\n}\r\nstatic u32 mxt_calculate_crc(u8 *base, off_t start_off, off_t end_off)\r\n{\r\nu32 crc = 0;\r\nu8 *ptr = base + start_off;\r\nu8 *last_val = base + end_off - 1;\r\nif (end_off < start_off)\r\nreturn -EINVAL;\r\nwhile (ptr < last_val) {\r\nmxt_calc_crc24(&crc, *ptr, *(ptr + 1));\r\nptr += 2;\r\n}\r\nif (ptr == last_val)\r\nmxt_calc_crc24(&crc, *ptr, 0);\r\ncrc &= 0x00FFFFFF;\r\nreturn crc;\r\n}\r\nstatic int mxt_prepare_cfg_mem(struct mxt_data *data,\r\nconst struct firmware *cfg,\r\nunsigned int data_pos,\r\nunsigned int cfg_start_ofs,\r\nu8 *config_mem,\r\nsize_t config_mem_size)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nstruct mxt_object *object;\r\nunsigned int type, instance, size, byte_offset;\r\nint offset;\r\nint ret;\r\nint i;\r\nu16 reg;\r\nu8 val;\r\nwhile (data_pos < cfg->size) {\r\nret = sscanf(cfg->data + data_pos, "%x %x %x%n",\r\n&type, &instance, &size, &offset);\r\nif (ret == 0) {\r\nbreak;\r\n} else if (ret != 3) {\r\ndev_err(dev, "Bad format: failed to parse object\n");\r\nreturn -EINVAL;\r\n}\r\ndata_pos += offset;\r\nobject = mxt_get_object(data, type);\r\nif (!object) {\r\nfor (i = 0; i < size; i++) {\r\nret = sscanf(cfg->data + data_pos, "%hhx%n",\r\n&val, &offset);\r\nif (ret != 1) {\r\ndev_err(dev, "Bad format in T%d at %d\n",\r\ntype, i);\r\nreturn -EINVAL;\r\n}\r\ndata_pos += offset;\r\n}\r\ncontinue;\r\n}\r\nif (size > mxt_obj_size(object)) {\r\ndev_warn(dev, "Discarding %zu byte(s) in T%u\n",\r\nsize - mxt_obj_size(object), type);\r\n} else if (mxt_obj_size(object) > size) {\r\ndev_warn(dev, "Zeroing %zu byte(s) in T%d\n",\r\nmxt_obj_size(object) - size, type);\r\n}\r\nif (instance >= mxt_obj_instances(object)) {\r\ndev_err(dev, "Object instances exceeded!\n");\r\nreturn -EINVAL;\r\n}\r\nreg = object->start_address + mxt_obj_size(object) * instance;\r\nfor (i = 0; i < size; i++) {\r\nret = sscanf(cfg->data + data_pos, "%hhx%n",\r\n&val,\r\n&offset);\r\nif (ret != 1) {\r\ndev_err(dev, "Bad format in T%d at %d\n",\r\ntype, i);\r\nreturn -EINVAL;\r\n}\r\ndata_pos += offset;\r\nif (i > mxt_obj_size(object))\r\ncontinue;\r\nbyte_offset = reg + i - cfg_start_ofs;\r\nif (byte_offset >= 0 && byte_offset < config_mem_size) {\r\n*(config_mem + byte_offset) = val;\r\n} else {\r\ndev_err(dev, "Bad object: reg:%d, T%d, ofs=%d\n",\r\nreg, object->type, byte_offset);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_upload_cfg_mem(struct mxt_data *data, unsigned int cfg_start,\r\nu8 *config_mem, size_t config_mem_size)\r\n{\r\nunsigned int byte_offset = 0;\r\nint error;\r\nwhile (byte_offset < config_mem_size) {\r\nunsigned int size = config_mem_size - byte_offset;\r\nif (size > MXT_MAX_BLOCK_WRITE)\r\nsize = MXT_MAX_BLOCK_WRITE;\r\nerror = __mxt_write_reg(data->client,\r\ncfg_start + byte_offset,\r\nsize, config_mem + byte_offset);\r\nif (error) {\r\ndev_err(&data->client->dev,\r\n"Config write error, ret=%d\n", error);\r\nreturn error;\r\n}\r\nbyte_offset += size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxt_update_cfg(struct mxt_data *data, const struct firmware *cfg)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nstruct mxt_info cfg_info;\r\nint ret;\r\nint offset;\r\nint data_pos;\r\nint i;\r\nint cfg_start_ofs;\r\nu32 info_crc, config_crc, calculated_crc;\r\nu8 *config_mem;\r\nsize_t config_mem_size;\r\nmxt_update_crc(data, MXT_COMMAND_REPORTALL, 1);\r\nif (strncmp(cfg->data, MXT_CFG_MAGIC, strlen(MXT_CFG_MAGIC))) {\r\ndev_err(dev, "Unrecognised config file\n");\r\nreturn -EINVAL;\r\n}\r\ndata_pos = strlen(MXT_CFG_MAGIC);\r\nfor (i = 0; i < sizeof(struct mxt_info); i++) {\r\nret = sscanf(cfg->data + data_pos, "%hhx%n",\r\n(unsigned char *)&cfg_info + i,\r\n&offset);\r\nif (ret != 1) {\r\ndev_err(dev, "Bad format\n");\r\nreturn -EINVAL;\r\n}\r\ndata_pos += offset;\r\n}\r\nif (cfg_info.family_id != data->info.family_id) {\r\ndev_err(dev, "Family ID mismatch!\n");\r\nreturn -EINVAL;\r\n}\r\nif (cfg_info.variant_id != data->info.variant_id) {\r\ndev_err(dev, "Variant ID mismatch!\n");\r\nreturn -EINVAL;\r\n}\r\nret = sscanf(cfg->data + data_pos, "%x%n", &info_crc, &offset);\r\nif (ret != 1) {\r\ndev_err(dev, "Bad format: failed to parse Info CRC\n");\r\nreturn -EINVAL;\r\n}\r\ndata_pos += offset;\r\nret = sscanf(cfg->data + data_pos, "%x%n", &config_crc, &offset);\r\nif (ret != 1) {\r\ndev_err(dev, "Bad format: failed to parse Config CRC\n");\r\nreturn -EINVAL;\r\n}\r\ndata_pos += offset;\r\nif (info_crc == data->info_crc) {\r\nif (config_crc == 0 || data->config_crc == 0) {\r\ndev_info(dev, "CRC zero, attempting to apply config\n");\r\n} else if (config_crc == data->config_crc) {\r\ndev_dbg(dev, "Config CRC 0x%06X: OK\n",\r\ndata->config_crc);\r\nreturn 0;\r\n} else {\r\ndev_info(dev, "Config CRC 0x%06X: does not match file 0x%06X\n",\r\ndata->config_crc, config_crc);\r\n}\r\n} else {\r\ndev_warn(dev,\r\n"Warning: Info CRC error - device=0x%06X file=0x%06X\n",\r\ndata->info_crc, info_crc);\r\n}\r\ncfg_start_ofs = MXT_OBJECT_START +\r\ndata->info.object_num * sizeof(struct mxt_object) +\r\nMXT_INFO_CHECKSUM_SIZE;\r\nconfig_mem_size = data->mem_size - cfg_start_ofs;\r\nconfig_mem = kzalloc(config_mem_size, GFP_KERNEL);\r\nif (!config_mem) {\r\ndev_err(dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nret = mxt_prepare_cfg_mem(data, cfg, data_pos, cfg_start_ofs,\r\nconfig_mem, config_mem_size);\r\nif (ret)\r\ngoto release_mem;\r\nif (data->T7_address < cfg_start_ofs) {\r\ndev_err(dev, "Bad T7 address, T7addr = %x, config offset %x\n",\r\ndata->T7_address, cfg_start_ofs);\r\nret = 0;\r\ngoto release_mem;\r\n}\r\ncalculated_crc = mxt_calculate_crc(config_mem,\r\ndata->T7_address - cfg_start_ofs,\r\nconfig_mem_size);\r\nif (config_crc > 0 && config_crc != calculated_crc)\r\ndev_warn(dev, "Config CRC error, calculated=%06X, file=%06X\n",\r\ncalculated_crc, config_crc);\r\nret = mxt_upload_cfg_mem(data, cfg_start_ofs,\r\nconfig_mem, config_mem_size);\r\nif (ret)\r\ngoto release_mem;\r\nmxt_update_crc(data, MXT_COMMAND_BACKUPNV, MXT_BACKUP_VALUE);\r\nret = mxt_soft_reset(data);\r\nif (ret)\r\ngoto release_mem;\r\ndev_info(dev, "Config successfully updated\n");\r\nrelease_mem:\r\nkfree(config_mem);\r\nreturn ret;\r\n}\r\nstatic int mxt_acquire_irq(struct mxt_data *data)\r\n{\r\nint error;\r\nenable_irq(data->irq);\r\nerror = mxt_process_messages_until_invalid(data);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int mxt_get_info(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nstruct mxt_info *info = &data->info;\r\nint error;\r\nerror = __mxt_read_reg(client, MXT_INFO, sizeof(*info), info);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic void mxt_free_input_device(struct mxt_data *data)\r\n{\r\nif (data->input_dev) {\r\ninput_unregister_device(data->input_dev);\r\ndata->input_dev = NULL;\r\n}\r\n}\r\nstatic void mxt_free_object_table(struct mxt_data *data)\r\n{\r\nkfree(data->object_table);\r\ndata->object_table = NULL;\r\nkfree(data->msg_buf);\r\ndata->msg_buf = NULL;\r\ndata->T5_address = 0;\r\ndata->T5_msg_size = 0;\r\ndata->T6_reportid = 0;\r\ndata->T7_address = 0;\r\ndata->T9_reportid_min = 0;\r\ndata->T9_reportid_max = 0;\r\ndata->T19_reportid = 0;\r\ndata->T44_address = 0;\r\ndata->max_reportid = 0;\r\n}\r\nstatic int mxt_get_object_table(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nsize_t table_size;\r\nstruct mxt_object *object_table;\r\nint error;\r\nint i;\r\nu8 reportid;\r\nu16 end_address;\r\ntable_size = data->info.object_num * sizeof(struct mxt_object);\r\nobject_table = kzalloc(table_size, GFP_KERNEL);\r\nif (!object_table) {\r\ndev_err(&data->client->dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nerror = __mxt_read_reg(client, MXT_OBJECT_START, table_size,\r\nobject_table);\r\nif (error) {\r\nkfree(object_table);\r\nreturn error;\r\n}\r\nreportid = 1;\r\ndata->mem_size = 0;\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nstruct mxt_object *object = object_table + i;\r\nu8 min_id, max_id;\r\nle16_to_cpus(&object->start_address);\r\nif (object->num_report_ids) {\r\nmin_id = reportid;\r\nreportid += object->num_report_ids *\r\nmxt_obj_instances(object);\r\nmax_id = reportid - 1;\r\n} else {\r\nmin_id = 0;\r\nmax_id = 0;\r\n}\r\ndev_dbg(&data->client->dev,\r\n"T%u Start:%u Size:%zu Instances:%zu Report IDs:%u-%u\n",\r\nobject->type, object->start_address,\r\nmxt_obj_size(object), mxt_obj_instances(object),\r\nmin_id, max_id);\r\nswitch (object->type) {\r\ncase MXT_GEN_MESSAGE_T5:\r\nif (data->info.family_id == 0x80 &&\r\ndata->info.version < 0x20) {\r\ndata->T5_msg_size = mxt_obj_size(object);\r\n} else {\r\ndata->T5_msg_size = mxt_obj_size(object) - 1;\r\n}\r\ndata->T5_address = object->start_address;\r\nbreak;\r\ncase MXT_GEN_COMMAND_T6:\r\ndata->T6_reportid = min_id;\r\ndata->T6_address = object->start_address;\r\nbreak;\r\ncase MXT_GEN_POWER_T7:\r\ndata->T7_address = object->start_address;\r\nbreak;\r\ncase MXT_TOUCH_MULTI_T9:\r\ndata->T9_reportid_min = min_id;\r\ndata->T9_reportid_max = max_id;\r\ndata->num_touchids = object->num_report_ids\r\n* mxt_obj_instances(object);\r\nbreak;\r\ncase MXT_SPT_MESSAGECOUNT_T44:\r\ndata->T44_address = object->start_address;\r\nbreak;\r\ncase MXT_SPT_GPIOPWM_T19:\r\ndata->T19_reportid = min_id;\r\nbreak;\r\n}\r\nend_address = object->start_address\r\n+ mxt_obj_size(object) * mxt_obj_instances(object) - 1;\r\nif (end_address >= data->mem_size)\r\ndata->mem_size = end_address + 1;\r\n}\r\ndata->max_reportid = reportid;\r\nif (data->T44_address && (data->T5_address != data->T44_address + 1)) {\r\ndev_err(&client->dev, "Invalid T44 position\n");\r\nerror = -EINVAL;\r\ngoto free_object_table;\r\n}\r\ndata->msg_buf = kcalloc(data->max_reportid,\r\ndata->T5_msg_size, GFP_KERNEL);\r\nif (!data->msg_buf) {\r\ndev_err(&client->dev, "Failed to allocate message buffer\n");\r\nerror = -ENOMEM;\r\ngoto free_object_table;\r\n}\r\ndata->object_table = object_table;\r\nreturn 0;\r\nfree_object_table:\r\nmxt_free_object_table(data);\r\nreturn error;\r\n}\r\nstatic int mxt_read_t9_resolution(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint error;\r\nstruct t9_range range;\r\nunsigned char orient;\r\nstruct mxt_object *object;\r\nobject = mxt_get_object(data, MXT_TOUCH_MULTI_T9);\r\nif (!object)\r\nreturn -EINVAL;\r\nerror = __mxt_read_reg(client,\r\nobject->start_address + MXT_T9_RANGE,\r\nsizeof(range), &range);\r\nif (error)\r\nreturn error;\r\nle16_to_cpus(&range.x);\r\nle16_to_cpus(&range.y);\r\nerror = __mxt_read_reg(client,\r\nobject->start_address + MXT_T9_ORIENT,\r\n1, &orient);\r\nif (error)\r\nreturn error;\r\nif (range.x == 0)\r\nrange.x = 1023;\r\nif (range.y == 0)\r\nrange.y = 1023;\r\nif (orient & MXT_T9_ORIENT_SWITCH) {\r\ndata->max_x = range.y;\r\ndata->max_y = range.x;\r\n} else {\r\ndata->max_x = range.x;\r\ndata->max_y = range.y;\r\n}\r\ndev_dbg(&client->dev,\r\n"Touchscreen size X%uY%u\n", data->max_x, data->max_y);\r\nreturn 0;\r\n}\r\nstatic int mxt_initialize_t9_input_device(struct mxt_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nconst struct mxt_platform_data *pdata = data->pdata;\r\nstruct input_dev *input_dev;\r\nint error;\r\nunsigned int num_mt_slots;\r\nunsigned int mt_flags = 0;\r\nint i;\r\nerror = mxt_read_t9_resolution(data);\r\nif (error)\r\ndev_warn(dev, "Failed to initialize T9 resolution\n");\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\ndev_err(dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_dev->name = "Atmel maXTouch Touchscreen";\r\ninput_dev->phys = data->phys;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = dev;\r\ninput_dev->open = mxt_input_open;\r\ninput_dev->close = mxt_input_close;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\nif (pdata->t19_num_keys) {\r\n__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);\r\nfor (i = 0; i < pdata->t19_num_keys; i++)\r\nif (pdata->t19_keymap[i] != KEY_RESERVED)\r\ninput_set_capability(input_dev, EV_KEY,\r\npdata->t19_keymap[i]);\r\nmt_flags |= INPUT_MT_POINTER;\r\ninput_abs_set_res(input_dev, ABS_X, MXT_PIXELS_PER_MM);\r\ninput_abs_set_res(input_dev, ABS_Y, MXT_PIXELS_PER_MM);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_X,\r\nMXT_PIXELS_PER_MM);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_Y,\r\nMXT_PIXELS_PER_MM);\r\ninput_dev->name = "Atmel maXTouch Touchpad";\r\n}\r\ninput_set_abs_params(input_dev, ABS_X,\r\n0, data->max_x, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\n0, data->max_y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\n0, 255, 0, 0);\r\nnum_mt_slots = data->T9_reportid_max - data->T9_reportid_min + 1;\r\nerror = input_mt_init_slots(input_dev, num_mt_slots, mt_flags);\r\nif (error) {\r\ndev_err(dev, "Error %d initialising slots\n", error);\r\ngoto err_free_mem;\r\n}\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\r\n0, MXT_MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X,\r\n0, data->max_x, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\r\n0, data->max_y, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_PRESSURE,\r\n0, 255, 0, 0);\r\ninput_set_drvdata(input_dev, data);\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(dev, "Error %d registering input device\n", error);\r\ngoto err_free_mem;\r\n}\r\ndata->input_dev = input_dev;\r\nreturn 0;\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nreturn error;\r\n}\r\nstatic void mxt_config_cb(const struct firmware *cfg, void *ctx)\r\n{\r\nmxt_configure_objects(ctx, cfg);\r\nrelease_firmware(cfg);\r\n}\r\nstatic int mxt_initialize(struct mxt_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint recovery_attempts = 0;\r\nint error;\r\nwhile (1) {\r\nerror = mxt_get_info(data);\r\nif (!error)\r\nbreak;\r\nerror = mxt_probe_bootloader(data, false);\r\nif (error) {\r\ndev_info(&client->dev, "Trying alternate bootloader address\n");\r\nerror = mxt_probe_bootloader(data, true);\r\nif (error) {\r\nreturn error;\r\n}\r\n}\r\nif (++recovery_attempts > 1) {\r\ndev_err(&client->dev, "Could not recover from bootloader mode\n");\r\ndata->in_bootloader = true;\r\nreturn 0;\r\n}\r\nmxt_send_bootloader_cmd(data, false);\r\nmsleep(MXT_FW_RESET_TIME);\r\n}\r\nerror = mxt_get_object_table(data);\r\nif (error) {\r\ndev_err(&client->dev, "Error %d reading object table\n", error);\r\nreturn error;\r\n}\r\nerror = mxt_acquire_irq(data);\r\nif (error)\r\ngoto err_free_object_table;\r\nerror = request_firmware_nowait(THIS_MODULE, true, MXT_CFG_NAME,\r\n&client->dev, GFP_KERNEL, data,\r\nmxt_config_cb);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to invoke firmware loader: %d\n",\r\nerror);\r\ngoto err_free_object_table;\r\n}\r\nreturn 0;\r\nerr_free_object_table:\r\nmxt_free_object_table(data);\r\nreturn error;\r\n}\r\nstatic int mxt_set_t7_power_cfg(struct mxt_data *data, u8 sleep)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nint error;\r\nstruct t7_config *new_config;\r\nstruct t7_config deepsleep = { .active = 0, .idle = 0 };\r\nif (sleep == MXT_POWER_CFG_DEEPSLEEP)\r\nnew_config = &deepsleep;\r\nelse\r\nnew_config = &data->t7_cfg;\r\nerror = __mxt_write_reg(data->client, data->T7_address,\r\nsizeof(data->t7_cfg), new_config);\r\nif (error)\r\nreturn error;\r\ndev_dbg(dev, "Set T7 ACTV:%d IDLE:%d\n",\r\nnew_config->active, new_config->idle);\r\nreturn 0;\r\n}\r\nstatic int mxt_init_t7_power_cfg(struct mxt_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nint error;\r\nbool retry = false;\r\nrecheck:\r\nerror = __mxt_read_reg(data->client, data->T7_address,\r\nsizeof(data->t7_cfg), &data->t7_cfg);\r\nif (error)\r\nreturn error;\r\nif (data->t7_cfg.active == 0 || data->t7_cfg.idle == 0) {\r\nif (!retry) {\r\ndev_dbg(dev, "T7 cfg zero, resetting\n");\r\nmxt_soft_reset(data);\r\nretry = true;\r\ngoto recheck;\r\n} else {\r\ndev_dbg(dev, "T7 cfg zero after reset, overriding\n");\r\ndata->t7_cfg.active = 20;\r\ndata->t7_cfg.idle = 100;\r\nreturn mxt_set_t7_power_cfg(data, MXT_POWER_CFG_RUN);\r\n}\r\n}\r\ndev_dbg(dev, "Initialized power cfg: ACTV %d, IDLE %d\n",\r\ndata->t7_cfg.active, data->t7_cfg.idle);\r\nreturn 0;\r\n}\r\nstatic int mxt_configure_objects(struct mxt_data *data,\r\nconst struct firmware *cfg)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nstruct mxt_info *info = &data->info;\r\nint error;\r\nif (cfg) {\r\nerror = mxt_update_cfg(data, cfg);\r\nif (error)\r\ndev_warn(dev, "Error %d updating config\n", error);\r\n}\r\nerror = mxt_init_t7_power_cfg(data);\r\nif (error) {\r\ndev_err(dev, "Failed to initialize power cfg\n");\r\nreturn error;\r\n}\r\nerror = mxt_initialize_t9_input_device(data);\r\nif (error)\r\nreturn error;\r\ndev_info(dev,\r\n"Family: %u Variant: %u Firmware V%u.%u.%02X Objects: %u\n",\r\ninfo->family_id, info->variant_id, info->version >> 4,\r\ninfo->version & 0xf, info->build, info->object_num);\r\nreturn 0;\r\n}\r\nstatic ssize_t mxt_fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct mxt_info *info = &data->info;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u.%u.%02X\n",\r\ninfo->version >> 4, info->version & 0xf, info->build);\r\n}\r\nstatic ssize_t mxt_hw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct mxt_info *info = &data->info;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u.%u\n",\r\ninfo->family_id, info->variant_id);\r\n}\r\nstatic ssize_t mxt_show_instance(char *buf, int count,\r\nstruct mxt_object *object, int instance,\r\nconst u8 *val)\r\n{\r\nint i;\r\nif (mxt_obj_instances(object) > 1)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"Instance %u\n", instance);\r\nfor (i = 0; i < mxt_obj_size(object); i++)\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"\t[%2u]: %02x (%d)\n", i, val[i], val[i]);\r\ncount += scnprintf(buf + count, PAGE_SIZE - count, "\n");\r\nreturn count;\r\n}\r\nstatic ssize_t mxt_object_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nstruct mxt_object *object;\r\nint count = 0;\r\nint i, j;\r\nint error;\r\nu8 *obuf;\r\nobuf = kmalloc(256, GFP_KERNEL);\r\nif (!obuf)\r\nreturn -ENOMEM;\r\nerror = 0;\r\nfor (i = 0; i < data->info.object_num; i++) {\r\nobject = data->object_table + i;\r\nif (!mxt_object_readable(object->type))\r\ncontinue;\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"T%u:\n", object->type);\r\nfor (j = 0; j < mxt_obj_instances(object); j++) {\r\nu16 size = mxt_obj_size(object);\r\nu16 addr = object->start_address + j * size;\r\nerror = __mxt_read_reg(data->client, addr, size, obuf);\r\nif (error)\r\ngoto done;\r\ncount = mxt_show_instance(buf, count, object, j, obuf);\r\n}\r\n}\r\ndone:\r\nkfree(obuf);\r\nreturn error ?: count;\r\n}\r\nstatic int mxt_check_firmware_format(struct device *dev,\r\nconst struct firmware *fw)\r\n{\r\nunsigned int pos = 0;\r\nchar c;\r\nwhile (pos < fw->size) {\r\nc = *(fw->data + pos);\r\nif (c < '0' || (c > '9' && c < 'A') || c > 'F')\r\nreturn 0;\r\npos++;\r\n}\r\ndev_err(dev, "Aborting: firmware file must be in binary format\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int mxt_load_fw(struct device *dev, const char *fn)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nconst struct firmware *fw = NULL;\r\nunsigned int frame_size;\r\nunsigned int pos = 0;\r\nunsigned int retry = 0;\r\nunsigned int frame = 0;\r\nint ret;\r\nret = request_firmware(&fw, fn, dev);\r\nif (ret) {\r\ndev_err(dev, "Unable to open firmware %s\n", fn);\r\nreturn ret;\r\n}\r\nret = mxt_check_firmware_format(dev, fw);\r\nif (ret)\r\ngoto release_firmware;\r\nif (!data->in_bootloader) {\r\ndata->in_bootloader = true;\r\nret = mxt_t6_command(data, MXT_COMMAND_RESET,\r\nMXT_BOOT_VALUE, false);\r\nif (ret)\r\ngoto release_firmware;\r\nmsleep(MXT_RESET_TIME);\r\nret = mxt_lookup_bootloader_address(data, 0);\r\nif (ret)\r\ngoto release_firmware;\r\nmxt_free_input_device(data);\r\nmxt_free_object_table(data);\r\n} else {\r\nenable_irq(data->irq);\r\n}\r\nreinit_completion(&data->bl_completion);\r\nret = mxt_check_bootloader(data, MXT_WAITING_BOOTLOAD_CMD, false);\r\nif (ret) {\r\nret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA, false);\r\nif (ret)\r\ngoto disable_irq;\r\n} else {\r\ndev_info(dev, "Unlocking bootloader\n");\r\nret = mxt_send_bootloader_cmd(data, true);\r\nif (ret)\r\ngoto disable_irq;\r\n}\r\nwhile (pos < fw->size) {\r\nret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA, true);\r\nif (ret)\r\ngoto disable_irq;\r\nframe_size = ((*(fw->data + pos) << 8) | *(fw->data + pos + 1));\r\nframe_size += 2;\r\nret = mxt_bootloader_write(data, fw->data + pos, frame_size);\r\nif (ret)\r\ngoto disable_irq;\r\nret = mxt_check_bootloader(data, MXT_FRAME_CRC_PASS, true);\r\nif (ret) {\r\nretry++;\r\nmsleep(retry * 20);\r\nif (retry > 20) {\r\ndev_err(dev, "Retry count exceeded\n");\r\ngoto disable_irq;\r\n}\r\n} else {\r\nretry = 0;\r\npos += frame_size;\r\nframe++;\r\n}\r\nif (frame % 50 == 0)\r\ndev_dbg(dev, "Sent %d frames, %d/%zd bytes\n",\r\nframe, pos, fw->size);\r\n}\r\nret = mxt_wait_for_completion(data, &data->bl_completion,\r\nMXT_FW_RESET_TIME);\r\nif (ret)\r\ngoto disable_irq;\r\ndev_dbg(dev, "Sent %d frames, %d bytes\n", frame, pos);\r\nmxt_wait_for_completion(data, &data->bl_completion, MXT_FW_RESET_TIME);\r\ndata->in_bootloader = false;\r\ndisable_irq:\r\ndisable_irq(data->irq);\r\nrelease_firmware:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic ssize_t mxt_update_fw_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct mxt_data *data = dev_get_drvdata(dev);\r\nint error;\r\nerror = mxt_load_fw(dev, MXT_FW_NAME);\r\nif (error) {\r\ndev_err(dev, "The firmware update failed(%d)\n", error);\r\ncount = error;\r\n} else {\r\ndev_info(dev, "The firmware update succeeded\n");\r\nerror = mxt_initialize(data);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn count;\r\n}\r\nstatic void mxt_start(struct mxt_data *data)\r\n{\r\nmxt_set_t7_power_cfg(data, MXT_POWER_CFG_RUN);\r\nmxt_t6_command(data, MXT_COMMAND_CALIBRATE, 1, false);\r\n}\r\nstatic void mxt_stop(struct mxt_data *data)\r\n{\r\nmxt_set_t7_power_cfg(data, MXT_POWER_CFG_DEEPSLEEP);\r\n}\r\nstatic int mxt_input_open(struct input_dev *dev)\r\n{\r\nstruct mxt_data *data = input_get_drvdata(dev);\r\nmxt_start(data);\r\nreturn 0;\r\n}\r\nstatic void mxt_input_close(struct input_dev *dev)\r\n{\r\nstruct mxt_data *data = input_get_drvdata(dev);\r\nmxt_stop(data);\r\n}\r\nstatic struct mxt_platform_data *mxt_parse_dt(struct i2c_client *client)\r\n{\r\nstruct mxt_platform_data *pdata;\r\nu32 *keymap;\r\nu32 keycode;\r\nint proplen, i, ret;\r\nif (!client->dev.of_node)\r\nreturn ERR_PTR(-ENODEV);\r\npdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (of_find_property(client->dev.of_node, "linux,gpio-keymap",\r\n&proplen)) {\r\npdata->t19_num_keys = proplen / sizeof(u32);\r\nkeymap = devm_kzalloc(&client->dev,\r\npdata->t19_num_keys * sizeof(keymap[0]),\r\nGFP_KERNEL);\r\nif (!keymap)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < pdata->t19_num_keys; i++) {\r\nret = of_property_read_u32_index(client->dev.of_node,\r\n"linux,gpio-keymap", i, &keycode);\r\nif (ret)\r\nkeycode = KEY_RESERVED;\r\nkeymap[i] = keycode;\r\n}\r\npdata->t19_keymap = keymap;\r\n}\r\nreturn pdata;\r\n}\r\nstatic struct mxt_platform_data *mxt_parse_dt(struct i2c_client *client)\r\n{\r\ndev_dbg(&client->dev, "No platform data specified\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct mxt_data *data;\r\nconst struct mxt_platform_data *pdata;\r\nint error;\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata) {\r\npdata = mxt_parse_dt(client);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\ndata = kzalloc(sizeof(struct mxt_data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(data->phys, sizeof(data->phys), "i2c-%u-%04x/input0",\r\nclient->adapter->nr, client->addr);\r\ndata->client = client;\r\ndata->pdata = pdata;\r\ndata->irq = client->irq;\r\ni2c_set_clientdata(client, data);\r\ninit_completion(&data->bl_completion);\r\ninit_completion(&data->reset_completion);\r\ninit_completion(&data->crc_completion);\r\nerror = request_threaded_irq(client->irq, NULL, mxt_interrupt,\r\npdata->irqflags | IRQF_ONESHOT,\r\nclient->name, data);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\ngoto err_free_mem;\r\n}\r\ndisable_irq(client->irq);\r\nerror = mxt_initialize(data);\r\nif (error)\r\ngoto err_free_irq;\r\nerror = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);\r\nif (error) {\r\ndev_err(&client->dev, "Failure %d creating sysfs group\n",\r\nerror);\r\ngoto err_free_object;\r\n}\r\nreturn 0;\r\nerr_free_object:\r\nmxt_free_input_device(data);\r\nmxt_free_object_table(data);\r\nerr_free_irq:\r\nfree_irq(client->irq, data);\r\nerr_free_mem:\r\nkfree(data);\r\nreturn error;\r\n}\r\nstatic int mxt_remove(struct i2c_client *client)\r\n{\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nsysfs_remove_group(&client->dev.kobj, &mxt_attr_group);\r\nfree_irq(data->irq, data);\r\nmxt_free_input_device(data);\r\nmxt_free_object_table(data);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int mxt_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = data->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nmxt_stop(data);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int mxt_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mxt_data *data = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = data->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nmxt_start(data);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}
