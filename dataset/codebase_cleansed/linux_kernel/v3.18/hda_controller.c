static void azx_stream_start(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nazx_dev->insufficient = 1;\r\nazx_writel(chip, INTCTL,\r\nazx_readl(chip, INTCTL) | (1 << azx_dev->index));\r\nazx_sd_writeb(chip, azx_dev, SD_CTL,\r\nazx_sd_readb(chip, azx_dev, SD_CTL) |\r\nSD_CTL_DMA_START | SD_INT_MASK);\r\n}\r\nstatic void azx_stream_clear(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nazx_sd_writeb(chip, azx_dev, SD_CTL,\r\nazx_sd_readb(chip, azx_dev, SD_CTL) &\r\n~(SD_CTL_DMA_START | SD_INT_MASK));\r\nazx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK);\r\n}\r\nvoid azx_stream_stop(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nazx_stream_clear(chip, azx_dev);\r\nazx_writel(chip, INTCTL,\r\nazx_readl(chip, INTCTL) & ~(1 << azx_dev->index));\r\n}\r\nstatic void azx_stream_reset(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nunsigned char val;\r\nint timeout;\r\nazx_stream_clear(chip, azx_dev);\r\nazx_sd_writeb(chip, azx_dev, SD_CTL,\r\nazx_sd_readb(chip, azx_dev, SD_CTL) |\r\nSD_CTL_STREAM_RESET);\r\nudelay(3);\r\ntimeout = 300;\r\nwhile (!((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &\r\nSD_CTL_STREAM_RESET) && --timeout)\r\n;\r\nval &= ~SD_CTL_STREAM_RESET;\r\nazx_sd_writeb(chip, azx_dev, SD_CTL, val);\r\nudelay(3);\r\ntimeout = 300;\r\nwhile (((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &\r\nSD_CTL_STREAM_RESET) && --timeout)\r\n;\r\n*azx_dev->posbuf = 0;\r\n}\r\nstatic int azx_setup_controller(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nunsigned int val;\r\nazx_stream_clear(chip, azx_dev);\r\nval = azx_sd_readl(chip, azx_dev, SD_CTL);\r\nval = (val & ~SD_CTL_STREAM_TAG_MASK) |\r\n(azx_dev->stream_tag << SD_CTL_STREAM_TAG_SHIFT);\r\nif (!azx_snoop(chip))\r\nval |= SD_CTL_TRAFFIC_PRIO;\r\nazx_sd_writel(chip, azx_dev, SD_CTL, val);\r\nazx_sd_writel(chip, azx_dev, SD_CBL, azx_dev->bufsize);\r\nazx_sd_writew(chip, azx_dev, SD_FORMAT, azx_dev->format_val);\r\nazx_sd_writew(chip, azx_dev, SD_LVI, azx_dev->frags - 1);\r\nazx_sd_writel(chip, azx_dev, SD_BDLPL, (u32)azx_dev->bdl.addr);\r\nazx_sd_writel(chip, azx_dev, SD_BDLPU,\r\nupper_32_bits(azx_dev->bdl.addr));\r\nif (chip->get_position[0] != azx_get_pos_lpib ||\r\nchip->get_position[1] != azx_get_pos_lpib) {\r\nif (!(azx_readl(chip, DPLBASE) & AZX_DPLBASE_ENABLE))\r\nazx_writel(chip, DPLBASE,\r\n(u32)chip->posbuf.addr | AZX_DPLBASE_ENABLE);\r\n}\r\nazx_sd_writel(chip, azx_dev, SD_CTL,\r\nazx_sd_readl(chip, azx_dev, SD_CTL) | SD_INT_MASK);\r\nreturn 0;\r\n}\r\nstatic inline struct azx_dev *\r\nazx_assign_device(struct azx *chip, struct snd_pcm_substream *substream)\r\n{\r\nint dev, i, nums;\r\nstruct azx_dev *res = NULL;\r\nint key = (substream->pcm->device << 16) | (substream->number << 2) |\r\n(substream->stream + 1);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndev = chip->playback_index_offset;\r\nnums = chip->playback_streams;\r\n} else {\r\ndev = chip->capture_index_offset;\r\nnums = chip->capture_streams;\r\n}\r\nfor (i = 0; i < nums; i++, dev++) {\r\nstruct azx_dev *azx_dev = &chip->azx_dev[dev];\r\ndsp_lock(azx_dev);\r\nif (!azx_dev->opened && !dsp_is_locked(azx_dev)) {\r\nif (azx_dev->assigned_key == key) {\r\nazx_dev->opened = 1;\r\nazx_dev->assigned_key = key;\r\ndsp_unlock(azx_dev);\r\nreturn azx_dev;\r\n}\r\nif (!res ||\r\n(chip->driver_caps & AZX_DCAPS_REVERSE_ASSIGN))\r\nres = azx_dev;\r\n}\r\ndsp_unlock(azx_dev);\r\n}\r\nif (res) {\r\ndsp_lock(res);\r\nres->opened = 1;\r\nres->assigned_key = key;\r\ndsp_unlock(res);\r\n}\r\nreturn res;\r\n}\r\nstatic inline void azx_release_device(struct azx_dev *azx_dev)\r\n{\r\nazx_dev->opened = 0;\r\n}\r\nstatic cycle_t azx_cc_read(const struct cyclecounter *cc)\r\n{\r\nstruct azx_dev *azx_dev = container_of(cc, struct azx_dev, azx_cc);\r\nstruct snd_pcm_substream *substream = azx_dev->substream;\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nreturn azx_readl(chip, WALLCLK);\r\n}\r\nstatic void azx_timecounter_init(struct snd_pcm_substream *substream,\r\nbool force, cycle_t last)\r\n{\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nstruct timecounter *tc = &azx_dev->azx_tc;\r\nstruct cyclecounter *cc = &azx_dev->azx_cc;\r\nu64 nsec;\r\ncc->read = azx_cc_read;\r\ncc->mask = CLOCKSOURCE_MASK(32);\r\ncc->mult = 125;\r\ncc->shift = 0;\r\nnsec = 0;\r\ntimecounter_init(tc, cc, nsec);\r\nif (force)\r\ntc->cycle_last = last;\r\n}\r\nstatic u64 azx_adjust_codec_delay(struct snd_pcm_substream *substream,\r\nu64 nsec)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];\r\nu64 codec_frames, codec_nsecs;\r\nif (!hinfo->ops.get_delay)\r\nreturn nsec;\r\ncodec_frames = hinfo->ops.get_delay(hinfo, apcm->codec, substream);\r\ncodec_nsecs = div_u64(codec_frames * 1000000000LL,\r\nsubstream->runtime->rate);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nreturn nsec + codec_nsecs;\r\nreturn (nsec > codec_nsecs) ? nsec - codec_nsecs : 0;\r\n}\r\nstatic int setup_bdle(struct azx *chip,\r\nstruct snd_dma_buffer *dmab,\r\nstruct azx_dev *azx_dev, u32 **bdlp,\r\nint ofs, int size, int with_ioc)\r\n{\r\nu32 *bdl = *bdlp;\r\nwhile (size > 0) {\r\ndma_addr_t addr;\r\nint chunk;\r\nif (azx_dev->frags >= AZX_MAX_BDL_ENTRIES)\r\nreturn -EINVAL;\r\naddr = snd_sgbuf_get_addr(dmab, ofs);\r\nbdl[0] = cpu_to_le32((u32)addr);\r\nbdl[1] = cpu_to_le32(upper_32_bits(addr));\r\nchunk = snd_sgbuf_get_chunk_size(dmab, ofs, size);\r\nif (chip->driver_caps & AZX_DCAPS_4K_BDLE_BOUNDARY) {\r\nu32 remain = 0x1000 - (ofs & 0xfff);\r\nif (chunk > remain)\r\nchunk = remain;\r\n}\r\nbdl[2] = cpu_to_le32(chunk);\r\nsize -= chunk;\r\nbdl[3] = (size || !with_ioc) ? 0 : cpu_to_le32(0x01);\r\nbdl += 4;\r\nazx_dev->frags++;\r\nofs += chunk;\r\n}\r\n*bdlp = bdl;\r\nreturn ofs;\r\n}\r\nstatic int azx_setup_periods(struct azx *chip,\r\nstruct snd_pcm_substream *substream,\r\nstruct azx_dev *azx_dev)\r\n{\r\nu32 *bdl;\r\nint i, ofs, periods, period_bytes;\r\nint pos_adj = 0;\r\nazx_sd_writel(chip, azx_dev, SD_BDLPL, 0);\r\nazx_sd_writel(chip, azx_dev, SD_BDLPU, 0);\r\nperiod_bytes = azx_dev->period_bytes;\r\nperiods = azx_dev->bufsize / period_bytes;\r\nbdl = (u32 *)azx_dev->bdl.area;\r\nofs = 0;\r\nazx_dev->frags = 0;\r\nif (chip->bdl_pos_adj)\r\npos_adj = chip->bdl_pos_adj[chip->dev_index];\r\nif (!azx_dev->no_period_wakeup && pos_adj > 0) {\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint pos_align = pos_adj;\r\npos_adj = (pos_adj * runtime->rate + 47999) / 48000;\r\nif (!pos_adj)\r\npos_adj = pos_align;\r\nelse\r\npos_adj = ((pos_adj + pos_align - 1) / pos_align) *\r\npos_align;\r\npos_adj = frames_to_bytes(runtime, pos_adj);\r\nif (pos_adj >= period_bytes) {\r\ndev_warn(chip->card->dev,"Too big adjustment %d\n",\r\npos_adj);\r\npos_adj = 0;\r\n} else {\r\nofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),\r\nazx_dev,\r\n&bdl, ofs, pos_adj, true);\r\nif (ofs < 0)\r\ngoto error;\r\n}\r\n} else\r\npos_adj = 0;\r\nfor (i = 0; i < periods; i++) {\r\nif (i == periods - 1 && pos_adj)\r\nofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),\r\nazx_dev, &bdl, ofs,\r\nperiod_bytes - pos_adj, 0);\r\nelse\r\nofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),\r\nazx_dev, &bdl, ofs,\r\nperiod_bytes,\r\n!azx_dev->no_period_wakeup);\r\nif (ofs < 0)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\ndev_err(chip->card->dev, "Too many BDL entries: buffer=%d, period=%d\n",\r\nazx_dev->bufsize, period_bytes);\r\nreturn -EINVAL;\r\n}\r\nstatic int azx_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nunsigned long flags;\r\nmutex_lock(&chip->open_mutex);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nazx_dev->substream = NULL;\r\nazx_dev->running = 0;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nazx_release_device(azx_dev);\r\nhinfo->ops.close(hinfo, apcm->codec, substream);\r\nsnd_hda_power_down(apcm->codec);\r\nmutex_unlock(&chip->open_mutex);\r\nreturn 0;\r\n}\r\nstatic int azx_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nint ret;\r\ndsp_lock(get_azx_dev(substream));\r\nif (dsp_is_locked(get_azx_dev(substream))) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nret = chip->ops->substream_alloc_pages(chip, substream,\r\nparams_buffer_bytes(hw_params));\r\nunlock:\r\ndsp_unlock(get_azx_dev(substream));\r\nreturn ret;\r\n}\r\nstatic int azx_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];\r\nint err;\r\ndsp_lock(azx_dev);\r\nif (!dsp_is_locked(azx_dev)) {\r\nazx_sd_writel(chip, azx_dev, SD_BDLPL, 0);\r\nazx_sd_writel(chip, azx_dev, SD_BDLPU, 0);\r\nazx_sd_writel(chip, azx_dev, SD_CTL, 0);\r\nazx_dev->bufsize = 0;\r\nazx_dev->period_bytes = 0;\r\nazx_dev->format_val = 0;\r\n}\r\nsnd_hda_codec_cleanup(apcm->codec, hinfo, substream);\r\nerr = chip->ops->substream_free_pages(chip, substream);\r\nazx_dev->prepared = 0;\r\ndsp_unlock(azx_dev);\r\nreturn err;\r\n}\r\nstatic int azx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nstruct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int bufsize, period_bytes, format_val, stream_tag;\r\nint err;\r\nstruct hda_spdif_out *spdif =\r\nsnd_hda_spdif_out_of_nid(apcm->codec, hinfo->nid);\r\nunsigned short ctls = spdif ? spdif->ctls : 0;\r\ndsp_lock(azx_dev);\r\nif (dsp_is_locked(azx_dev)) {\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nazx_stream_reset(chip, azx_dev);\r\nformat_val = snd_hda_calc_stream_format(apcm->codec,\r\nruntime->rate,\r\nruntime->channels,\r\nruntime->format,\r\nhinfo->maxbps,\r\nctls);\r\nif (!format_val) {\r\ndev_err(chip->card->dev,\r\n"invalid format_val, rate=%d, ch=%d, format=%d\n",\r\nruntime->rate, runtime->channels, runtime->format);\r\nerr = -EINVAL;\r\ngoto unlock;\r\n}\r\nbufsize = snd_pcm_lib_buffer_bytes(substream);\r\nperiod_bytes = snd_pcm_lib_period_bytes(substream);\r\ndev_dbg(chip->card->dev, "azx_pcm_prepare: bufsize=0x%x, format=0x%x\n",\r\nbufsize, format_val);\r\nif (bufsize != azx_dev->bufsize ||\r\nperiod_bytes != azx_dev->period_bytes ||\r\nformat_val != azx_dev->format_val ||\r\nruntime->no_period_wakeup != azx_dev->no_period_wakeup) {\r\nazx_dev->bufsize = bufsize;\r\nazx_dev->period_bytes = period_bytes;\r\nazx_dev->format_val = format_val;\r\nazx_dev->no_period_wakeup = runtime->no_period_wakeup;\r\nerr = azx_setup_periods(chip, substream, azx_dev);\r\nif (err < 0)\r\ngoto unlock;\r\n}\r\nif (runtime->period_size > 64)\r\nazx_dev->delay_negative_threshold = -frames_to_bytes(runtime, 64);\r\nelse\r\nazx_dev->delay_negative_threshold = 0;\r\nazx_dev->period_wallclk = (((runtime->period_size * 24000) /\r\nruntime->rate) * 1000);\r\nazx_setup_controller(chip, azx_dev);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nazx_dev->fifo_size =\r\nazx_sd_readw(chip, azx_dev, SD_FIFOSIZE) + 1;\r\nelse\r\nazx_dev->fifo_size = 0;\r\nstream_tag = azx_dev->stream_tag;\r\nif ((chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND) &&\r\nstream_tag > chip->capture_streams)\r\nstream_tag -= chip->capture_streams;\r\nerr = snd_hda_codec_prepare(apcm->codec, hinfo, stream_tag,\r\nazx_dev->format_val, substream);\r\nunlock:\r\nif (!err)\r\nazx_dev->prepared = 1;\r\ndsp_unlock(azx_dev);\r\nreturn err;\r\n}\r\nstatic int azx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev;\r\nstruct snd_pcm_substream *s;\r\nint rstart = 0, start, nsync = 0, sbits = 0;\r\nint nwait, timeout;\r\nazx_dev = get_azx_dev(substream);\r\ntrace_azx_pcm_trigger(chip, azx_dev, cmd);\r\nif (dsp_is_locked(azx_dev) || !azx_dev->prepared)\r\nreturn -EPIPE;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nrstart = 1;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nstart = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nstart = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nazx_dev = get_azx_dev(s);\r\nsbits |= 1 << azx_dev->index;\r\nnsync++;\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\nspin_lock(&chip->reg_lock);\r\nif (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)\r\nazx_writel(chip, OLD_SSYNC,\r\nazx_readl(chip, OLD_SSYNC) | sbits);\r\nelse\r\nazx_writel(chip, SSYNC, azx_readl(chip, SSYNC) | sbits);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nazx_dev = get_azx_dev(s);\r\nif (start) {\r\nazx_dev->start_wallclk = azx_readl(chip, WALLCLK);\r\nif (!rstart)\r\nazx_dev->start_wallclk -=\r\nazx_dev->period_wallclk;\r\nazx_stream_start(chip, azx_dev);\r\n} else {\r\nazx_stream_stop(chip, azx_dev);\r\n}\r\nazx_dev->running = start;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nif (start) {\r\nfor (timeout = 5000; timeout; timeout--) {\r\nnwait = 0;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nazx_dev = get_azx_dev(s);\r\nif (!(azx_sd_readb(chip, azx_dev, SD_STS) &\r\nSD_STS_FIFO_READY))\r\nnwait++;\r\n}\r\nif (!nwait)\r\nbreak;\r\ncpu_relax();\r\n}\r\n} else {\r\nfor (timeout = 5000; timeout; timeout--) {\r\nnwait = 0;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nazx_dev = get_azx_dev(s);\r\nif (azx_sd_readb(chip, azx_dev, SD_CTL) &\r\nSD_CTL_DMA_START)\r\nnwait++;\r\n}\r\nif (!nwait)\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nspin_lock(&chip->reg_lock);\r\nif (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)\r\nazx_writel(chip, OLD_SSYNC,\r\nazx_readl(chip, OLD_SSYNC) & ~sbits);\r\nelse\r\nazx_writel(chip, SSYNC, azx_readl(chip, SSYNC) & ~sbits);\r\nif (start) {\r\nazx_timecounter_init(substream, 0, 0);\r\nif (nsync > 1) {\r\ncycle_t cycle_last;\r\nazx_dev = get_azx_dev(substream);\r\ncycle_last = azx_dev->azx_tc.cycle_last;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->pcm->card != substream->pcm->card)\r\ncontinue;\r\nazx_timecounter_init(s, 1, cycle_last);\r\n}\r\n}\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nunsigned int azx_get_pos_lpib(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nreturn azx_sd_readl(chip, azx_dev, SD_LPIB);\r\n}\r\nunsigned int azx_get_pos_posbuf(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nreturn le32_to_cpu(*azx_dev->posbuf);\r\n}\r\nunsigned int azx_get_position(struct azx *chip,\r\nstruct azx_dev *azx_dev)\r\n{\r\nstruct snd_pcm_substream *substream = azx_dev->substream;\r\nunsigned int pos;\r\nint stream = substream->stream;\r\nint delay = 0;\r\nif (chip->get_position[stream])\r\npos = chip->get_position[stream](chip, azx_dev);\r\nelse\r\npos = azx_get_pos_posbuf(chip, azx_dev);\r\nif (pos >= azx_dev->bufsize)\r\npos = 0;\r\nif (substream->runtime) {\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct hda_pcm_stream *hinfo = apcm->hinfo[stream];\r\nif (chip->get_delay[stream])\r\ndelay += chip->get_delay[stream](chip, azx_dev, pos);\r\nif (hinfo->ops.get_delay)\r\ndelay += hinfo->ops.get_delay(hinfo, apcm->codec,\r\nsubstream);\r\nsubstream->runtime->delay = delay;\r\n}\r\ntrace_azx_get_position(chip, azx_dev, pos, delay);\r\nreturn pos;\r\n}\r\nstatic snd_pcm_uframes_t azx_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nreturn bytes_to_frames(substream->runtime,\r\nazx_get_position(chip, azx_dev));\r\n}\r\nstatic int azx_get_wallclock_tstamp(struct snd_pcm_substream *substream,\r\nstruct timespec *ts)\r\n{\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nu64 nsec;\r\nnsec = timecounter_read(&azx_dev->azx_tc);\r\nnsec = div_u64(nsec, 3);\r\nnsec = azx_adjust_codec_delay(substream, nsec);\r\n*ts = ns_to_timespec(nsec);\r\nreturn 0;\r\n}\r\nstatic int azx_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];\r\nstruct azx *chip = apcm->chip;\r\nstruct azx_dev *azx_dev;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long flags;\r\nint err;\r\nint buff_step;\r\nmutex_lock(&chip->open_mutex);\r\nazx_dev = azx_assign_device(chip, substream);\r\nif (azx_dev == NULL) {\r\nmutex_unlock(&chip->open_mutex);\r\nreturn -EBUSY;\r\n}\r\nruntime->hw = azx_pcm_hw;\r\nruntime->hw.channels_min = hinfo->channels_min;\r\nruntime->hw.channels_max = hinfo->channels_max;\r\nruntime->hw.formats = hinfo->formats;\r\nruntime->hw.rates = hinfo->rates;\r\nsnd_pcm_limit_hw_rates(runtime);\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_TIME,\r\n20,\r\n178000000);\r\nif (chip->align_buffer_size)\r\nbuff_step = 128;\r\nelse\r\nbuff_step = 4;\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nbuff_step);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nbuff_step);\r\nsnd_hda_power_up_d3wait(apcm->codec);\r\nerr = hinfo->ops.open(hinfo, apcm->codec, substream);\r\nif (err < 0) {\r\nazx_release_device(azx_dev);\r\nsnd_hda_power_down(apcm->codec);\r\nmutex_unlock(&chip->open_mutex);\r\nreturn err;\r\n}\r\nsnd_pcm_limit_hw_rates(runtime);\r\nif (snd_BUG_ON(!runtime->hw.channels_min) ||\r\nsnd_BUG_ON(!runtime->hw.channels_max) ||\r\nsnd_BUG_ON(!runtime->hw.formats) ||\r\nsnd_BUG_ON(!runtime->hw.rates)) {\r\nazx_release_device(azx_dev);\r\nhinfo->ops.close(hinfo, apcm->codec, substream);\r\nsnd_hda_power_down(apcm->codec);\r\nmutex_unlock(&chip->open_mutex);\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nruntime->hw.info &= ~SNDRV_PCM_INFO_HAS_WALL_CLOCK;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nazx_dev->substream = substream;\r\nazx_dev->running = 0;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nruntime->private_data = azx_dev;\r\nsnd_pcm_set_sync(substream);\r\nmutex_unlock(&chip->open_mutex);\r\nreturn 0;\r\n}\r\nstatic int azx_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *area)\r\n{\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nif (chip->ops->pcm_mmap_prepare)\r\nchip->ops->pcm_mmap_prepare(substream, area);\r\nreturn snd_pcm_lib_default_mmap(substream, area);\r\n}\r\nstatic void azx_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct azx_pcm *apcm = pcm->private_data;\r\nif (apcm) {\r\nlist_del(&apcm->list);\r\nkfree(apcm);\r\n}\r\n}\r\nstatic int azx_attach_pcm_stream(struct hda_bus *bus, struct hda_codec *codec,\r\nstruct hda_pcm *cpcm)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nstruct snd_pcm *pcm;\r\nstruct azx_pcm *apcm;\r\nint pcm_dev = cpcm->device;\r\nunsigned int size;\r\nint s, err;\r\nlist_for_each_entry(apcm, &chip->pcm_list, list) {\r\nif (apcm->pcm->device == pcm_dev) {\r\ndev_err(chip->card->dev, "PCM %d already exists\n",\r\npcm_dev);\r\nreturn -EBUSY;\r\n}\r\n}\r\nerr = snd_pcm_new(chip->card, cpcm->name, pcm_dev,\r\ncpcm->stream[SNDRV_PCM_STREAM_PLAYBACK].substreams,\r\ncpcm->stream[SNDRV_PCM_STREAM_CAPTURE].substreams,\r\n&pcm);\r\nif (err < 0)\r\nreturn err;\r\nstrlcpy(pcm->name, cpcm->name, sizeof(pcm->name));\r\napcm = kzalloc(sizeof(*apcm), GFP_KERNEL);\r\nif (apcm == NULL)\r\nreturn -ENOMEM;\r\napcm->chip = chip;\r\napcm->pcm = pcm;\r\napcm->codec = codec;\r\npcm->private_data = apcm;\r\npcm->private_free = azx_pcm_free;\r\nif (cpcm->pcm_type == HDA_PCM_TYPE_MODEM)\r\npcm->dev_class = SNDRV_PCM_CLASS_MODEM;\r\nlist_add_tail(&apcm->list, &chip->pcm_list);\r\ncpcm->pcm = pcm;\r\nfor (s = 0; s < 2; s++) {\r\napcm->hinfo[s] = &cpcm->stream[s];\r\nif (cpcm->stream[s].substreams)\r\nsnd_pcm_set_ops(pcm, s, &azx_pcm_ops);\r\n}\r\nsize = CONFIG_SND_HDA_PREALLOC_SIZE * 1024;\r\nif (size > MAX_PREALLOC_SIZE)\r\nsize = MAX_PREALLOC_SIZE;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nchip->card->dev,\r\nsize, MAX_PREALLOC_SIZE);\r\npcm->dev = &codec->dev;\r\nreturn 0;\r\n}\r\nstatic int azx_alloc_cmd_io(struct azx *chip)\r\n{\r\nint err;\r\nerr = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,\r\nPAGE_SIZE, &chip->rb);\r\nif (err < 0)\r\ndev_err(chip->card->dev, "cannot allocate CORB/RIRB\n");\r\nreturn err;\r\n}\r\nstatic void azx_init_cmd_io(struct azx *chip)\r\n{\r\nint timeout;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->corb.addr = chip->rb.addr;\r\nchip->corb.buf = (u32 *)chip->rb.area;\r\nazx_writel(chip, CORBLBASE, (u32)chip->corb.addr);\r\nazx_writel(chip, CORBUBASE, upper_32_bits(chip->corb.addr));\r\nazx_writeb(chip, CORBSIZE, 0x02);\r\nazx_writew(chip, CORBWP, 0);\r\nazx_writew(chip, CORBRP, AZX_CORBRP_RST);\r\nif (!(chip->driver_caps & AZX_DCAPS_CORBRP_SELF_CLEAR)) {\r\nfor (timeout = 1000; timeout > 0; timeout--) {\r\nif ((azx_readw(chip, CORBRP) & AZX_CORBRP_RST) == AZX_CORBRP_RST)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout <= 0)\r\ndev_err(chip->card->dev, "CORB reset timeout#1, CORBRP = %d\n",\r\nazx_readw(chip, CORBRP));\r\nazx_writew(chip, CORBRP, 0);\r\nfor (timeout = 1000; timeout > 0; timeout--) {\r\nif (azx_readw(chip, CORBRP) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout <= 0)\r\ndev_err(chip->card->dev, "CORB reset timeout#2, CORBRP = %d\n",\r\nazx_readw(chip, CORBRP));\r\n}\r\nazx_writeb(chip, CORBCTL, AZX_CORBCTL_RUN);\r\nchip->rirb.addr = chip->rb.addr + 2048;\r\nchip->rirb.buf = (u32 *)(chip->rb.area + 2048);\r\nchip->rirb.wp = chip->rirb.rp = 0;\r\nmemset(chip->rirb.cmds, 0, sizeof(chip->rirb.cmds));\r\nazx_writel(chip, RIRBLBASE, (u32)chip->rirb.addr);\r\nazx_writel(chip, RIRBUBASE, upper_32_bits(chip->rirb.addr));\r\nazx_writeb(chip, RIRBSIZE, 0x02);\r\nazx_writew(chip, RIRBWP, AZX_RIRBWP_RST);\r\nif (chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND)\r\nazx_writew(chip, RINTCNT, 0xc0);\r\nelse\r\nazx_writew(chip, RINTCNT, 1);\r\nazx_writeb(chip, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nstatic void azx_free_cmd_io(struct azx *chip)\r\n{\r\nspin_lock_irq(&chip->reg_lock);\r\nazx_writeb(chip, RIRBCTL, 0);\r\nazx_writeb(chip, CORBCTL, 0);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nstatic unsigned int azx_command_addr(u32 cmd)\r\n{\r\nunsigned int addr = cmd >> 28;\r\nif (addr >= AZX_MAX_CODECS) {\r\nsnd_BUG();\r\naddr = 0;\r\n}\r\nreturn addr;\r\n}\r\nstatic int azx_corb_send_cmd(struct hda_bus *bus, u32 val)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nunsigned int addr = azx_command_addr(val);\r\nunsigned int wp, rp;\r\nspin_lock_irq(&chip->reg_lock);\r\nwp = azx_readw(chip, CORBWP);\r\nif (wp == 0xffff) {\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn -EIO;\r\n}\r\nwp++;\r\nwp %= AZX_MAX_CORB_ENTRIES;\r\nrp = azx_readw(chip, CORBRP);\r\nif (wp == rp) {\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn -EAGAIN;\r\n}\r\nchip->rirb.cmds[addr]++;\r\nchip->corb.buf[wp] = cpu_to_le32(val);\r\nazx_writew(chip, CORBWP, wp);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic void azx_update_rirb(struct azx *chip)\r\n{\r\nunsigned int rp, wp;\r\nunsigned int addr;\r\nu32 res, res_ex;\r\nwp = azx_readw(chip, RIRBWP);\r\nif (wp == 0xffff) {\r\nreturn;\r\n}\r\nif (wp == chip->rirb.wp)\r\nreturn;\r\nchip->rirb.wp = wp;\r\nwhile (chip->rirb.rp != wp) {\r\nchip->rirb.rp++;\r\nchip->rirb.rp %= AZX_MAX_RIRB_ENTRIES;\r\nrp = chip->rirb.rp << 1;\r\nres_ex = le32_to_cpu(chip->rirb.buf[rp + 1]);\r\nres = le32_to_cpu(chip->rirb.buf[rp]);\r\naddr = res_ex & 0xf;\r\nif ((addr >= AZX_MAX_CODECS) || !(chip->codec_mask & (1 << addr))) {\r\ndev_err(chip->card->dev, "spurious response %#x:%#x, rp = %d, wp = %d",\r\nres, res_ex,\r\nchip->rirb.rp, wp);\r\nsnd_BUG();\r\n} else if (res_ex & AZX_RIRB_EX_UNSOL_EV)\r\nsnd_hda_queue_unsol_event(chip->bus, res, res_ex);\r\nelse if (chip->rirb.cmds[addr]) {\r\nchip->rirb.res[addr] = res;\r\nsmp_wmb();\r\nchip->rirb.cmds[addr]--;\r\n} else if (printk_ratelimit()) {\r\ndev_err(chip->card->dev, "spurious response %#x:%#x, last cmd=%#08x\n",\r\nres, res_ex,\r\nchip->last_cmd[addr]);\r\n}\r\n}\r\n}\r\nstatic unsigned int azx_rirb_get_response(struct hda_bus *bus,\r\nunsigned int addr)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nunsigned long timeout;\r\nunsigned long loopcounter;\r\nint do_poll = 0;\r\nagain:\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nfor (loopcounter = 0;; loopcounter++) {\r\nif (chip->polling_mode || do_poll) {\r\nspin_lock_irq(&chip->reg_lock);\r\nazx_update_rirb(chip);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nif (!chip->rirb.cmds[addr]) {\r\nsmp_rmb();\r\nbus->rirb_error = 0;\r\nif (!do_poll)\r\nchip->poll_count = 0;\r\nreturn chip->rirb.res[addr];\r\n}\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nif (bus->needs_damn_long_delay || loopcounter > 3000)\r\nmsleep(2);\r\nelse {\r\nudelay(10);\r\ncond_resched();\r\n}\r\n}\r\nif (!bus->no_response_fallback)\r\nreturn -1;\r\nif (!chip->polling_mode && chip->poll_count < 2) {\r\ndev_dbg(chip->card->dev,\r\n"azx_get_response timeout, polling the codec once: last cmd=0x%08x\n",\r\nchip->last_cmd[addr]);\r\ndo_poll = 1;\r\nchip->poll_count++;\r\ngoto again;\r\n}\r\nif (!chip->polling_mode) {\r\ndev_warn(chip->card->dev,\r\n"azx_get_response timeout, switching to polling mode: last cmd=0x%08x\n",\r\nchip->last_cmd[addr]);\r\nchip->polling_mode = 1;\r\ngoto again;\r\n}\r\nif (chip->msi) {\r\ndev_warn(chip->card->dev,\r\n"No response from codec, disabling MSI: last cmd=0x%08x\n",\r\nchip->last_cmd[addr]);\r\nif (chip->ops->disable_msi_reset_irq(chip) &&\r\nchip->ops->disable_msi_reset_irq(chip) < 0) {\r\nbus->rirb_error = 1;\r\nreturn -1;\r\n}\r\ngoto again;\r\n}\r\nif (chip->probing) {\r\nreturn -1;\r\n}\r\nbus->rirb_error = 1;\r\nif (bus->allow_bus_reset && !bus->response_reset && !bus->in_reset) {\r\nbus->response_reset = 1;\r\nreturn -1;\r\n}\r\ndev_err(chip->card->dev,\r\n"azx_get_response timeout, switching to single_cmd mode: last cmd=0x%08x\n",\r\nchip->last_cmd[addr]);\r\nchip->single_cmd = 1;\r\nbus->response_reset = 0;\r\nazx_free_cmd_io(chip);\r\nazx_writel(chip, GCTL, azx_readl(chip, GCTL) & ~AZX_GCTL_UNSOL);\r\nreturn -1;\r\n}\r\nstatic int azx_single_wait_for_response(struct azx *chip, unsigned int addr)\r\n{\r\nint timeout = 50;\r\nwhile (timeout--) {\r\nif (azx_readw(chip, IRS) & AZX_IRS_VALID) {\r\nchip->rirb.res[addr] = azx_readl(chip, IR);\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\nif (printk_ratelimit())\r\ndev_dbg(chip->card->dev, "get_response timeout: IRS=0x%x\n",\r\nazx_readw(chip, IRS));\r\nchip->rirb.res[addr] = -1;\r\nreturn -EIO;\r\n}\r\nstatic int azx_single_send_cmd(struct hda_bus *bus, u32 val)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nunsigned int addr = azx_command_addr(val);\r\nint timeout = 50;\r\nbus->rirb_error = 0;\r\nwhile (timeout--) {\r\nif (!((azx_readw(chip, IRS) & AZX_IRS_BUSY))) {\r\nazx_writew(chip, IRS, azx_readw(chip, IRS) |\r\nAZX_IRS_VALID);\r\nazx_writel(chip, IC, val);\r\nazx_writew(chip, IRS, azx_readw(chip, IRS) |\r\nAZX_IRS_BUSY);\r\nreturn azx_single_wait_for_response(chip, addr);\r\n}\r\nudelay(1);\r\n}\r\nif (printk_ratelimit())\r\ndev_dbg(chip->card->dev,\r\n"send_cmd timeout: IRS=0x%x, val=0x%x\n",\r\nazx_readw(chip, IRS), val);\r\nreturn -EIO;\r\n}\r\nstatic unsigned int azx_single_get_response(struct hda_bus *bus,\r\nunsigned int addr)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nreturn chip->rirb.res[addr];\r\n}\r\nstatic int azx_send_cmd(struct hda_bus *bus, unsigned int val)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nif (chip->disabled)\r\nreturn 0;\r\nchip->last_cmd[azx_command_addr(val)] = val;\r\nif (chip->single_cmd)\r\nreturn azx_single_send_cmd(bus, val);\r\nelse\r\nreturn azx_corb_send_cmd(bus, val);\r\n}\r\nstatic unsigned int azx_get_response(struct hda_bus *bus,\r\nunsigned int addr)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nif (chip->disabled)\r\nreturn 0;\r\nif (chip->single_cmd)\r\nreturn azx_single_get_response(bus, addr);\r\nelse\r\nreturn azx_rirb_get_response(bus, addr);\r\n}\r\nstatic struct azx_dev *\r\nazx_get_dsp_loader_dev(struct azx *chip)\r\n{\r\nreturn &chip->azx_dev[chip->playback_index_offset];\r\n}\r\nstatic int azx_load_dsp_prepare(struct hda_bus *bus, unsigned int format,\r\nunsigned int byte_size,\r\nstruct snd_dma_buffer *bufp)\r\n{\r\nu32 *bdl;\r\nstruct azx *chip = bus->private_data;\r\nstruct azx_dev *azx_dev;\r\nint err;\r\nazx_dev = azx_get_dsp_loader_dev(chip);\r\ndsp_lock(azx_dev);\r\nspin_lock_irq(&chip->reg_lock);\r\nif (azx_dev->running || azx_dev->locked) {\r\nspin_unlock_irq(&chip->reg_lock);\r\nerr = -EBUSY;\r\ngoto unlock;\r\n}\r\nazx_dev->prepared = 0;\r\nchip->saved_azx_dev = *azx_dev;\r\nazx_dev->locked = 1;\r\nspin_unlock_irq(&chip->reg_lock);\r\nerr = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV_SG,\r\nbyte_size, bufp);\r\nif (err < 0)\r\ngoto err_alloc;\r\nazx_dev->bufsize = byte_size;\r\nazx_dev->period_bytes = byte_size;\r\nazx_dev->format_val = format;\r\nazx_stream_reset(chip, azx_dev);\r\nazx_sd_writel(chip, azx_dev, SD_BDLPL, 0);\r\nazx_sd_writel(chip, azx_dev, SD_BDLPU, 0);\r\nazx_dev->frags = 0;\r\nbdl = (u32 *)azx_dev->bdl.area;\r\nerr = setup_bdle(chip, bufp, azx_dev, &bdl, 0, byte_size, 0);\r\nif (err < 0)\r\ngoto error;\r\nazx_setup_controller(chip, azx_dev);\r\ndsp_unlock(azx_dev);\r\nreturn azx_dev->stream_tag;\r\nerror:\r\nchip->ops->dma_free_pages(chip, bufp);\r\nerr_alloc:\r\nspin_lock_irq(&chip->reg_lock);\r\nif (azx_dev->opened)\r\n*azx_dev = chip->saved_azx_dev;\r\nazx_dev->locked = 0;\r\nspin_unlock_irq(&chip->reg_lock);\r\nunlock:\r\ndsp_unlock(azx_dev);\r\nreturn err;\r\n}\r\nstatic void azx_load_dsp_trigger(struct hda_bus *bus, bool start)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nstruct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);\r\nif (start)\r\nazx_stream_start(chip, azx_dev);\r\nelse\r\nazx_stream_stop(chip, azx_dev);\r\nazx_dev->running = start;\r\n}\r\nstatic void azx_load_dsp_cleanup(struct hda_bus *bus,\r\nstruct snd_dma_buffer *dmab)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nstruct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);\r\nif (!dmab->area || !azx_dev->locked)\r\nreturn;\r\ndsp_lock(azx_dev);\r\nazx_sd_writel(chip, azx_dev, SD_BDLPL, 0);\r\nazx_sd_writel(chip, azx_dev, SD_BDLPU, 0);\r\nazx_sd_writel(chip, azx_dev, SD_CTL, 0);\r\nazx_dev->bufsize = 0;\r\nazx_dev->period_bytes = 0;\r\nazx_dev->format_val = 0;\r\nchip->ops->dma_free_pages(chip, dmab);\r\ndmab->area = NULL;\r\nspin_lock_irq(&chip->reg_lock);\r\nif (azx_dev->opened)\r\n*azx_dev = chip->saved_azx_dev;\r\nazx_dev->locked = 0;\r\nspin_unlock_irq(&chip->reg_lock);\r\ndsp_unlock(azx_dev);\r\n}\r\nint azx_alloc_stream_pages(struct azx *chip)\r\n{\r\nint i, err;\r\nstruct snd_card *card = chip->card;\r\nfor (i = 0; i < chip->num_streams; i++) {\r\ndsp_lock_init(&chip->azx_dev[i]);\r\nerr = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,\r\nBDL_SIZE,\r\n&chip->azx_dev[i].bdl);\r\nif (err < 0) {\r\ndev_err(card->dev, "cannot allocate BDL\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nerr = chip->ops->dma_alloc_pages(chip, SNDRV_DMA_TYPE_DEV,\r\nchip->num_streams * 8, &chip->posbuf);\r\nif (err < 0) {\r\ndev_err(card->dev, "cannot allocate posbuf\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = azx_alloc_cmd_io(chip);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nvoid azx_free_stream_pages(struct azx *chip)\r\n{\r\nint i;\r\nif (chip->azx_dev) {\r\nfor (i = 0; i < chip->num_streams; i++)\r\nif (chip->azx_dev[i].bdl.area)\r\nchip->ops->dma_free_pages(\r\nchip, &chip->azx_dev[i].bdl);\r\n}\r\nif (chip->rb.area)\r\nchip->ops->dma_free_pages(chip, &chip->rb);\r\nif (chip->posbuf.area)\r\nchip->ops->dma_free_pages(chip, &chip->posbuf);\r\n}\r\nvoid azx_enter_link_reset(struct azx *chip)\r\n{\r\nunsigned long timeout;\r\nazx_writel(chip, GCTL, azx_readl(chip, GCTL) & ~AZX_GCTL_RESET);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile ((azx_readb(chip, GCTL) & AZX_GCTL_RESET) &&\r\ntime_before(jiffies, timeout))\r\nusleep_range(500, 1000);\r\n}\r\nstatic void azx_exit_link_reset(struct azx *chip)\r\n{\r\nunsigned long timeout;\r\nazx_writeb(chip, GCTL, azx_readb(chip, GCTL) | AZX_GCTL_RESET);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (!azx_readb(chip, GCTL) &&\r\ntime_before(jiffies, timeout))\r\nusleep_range(500, 1000);\r\n}\r\nstatic int azx_reset(struct azx *chip, bool full_reset)\r\n{\r\nif (!full_reset)\r\ngoto __skip;\r\nazx_writew(chip, STATESTS, STATESTS_INT_MASK);\r\nazx_enter_link_reset(chip);\r\nusleep_range(500, 1000);\r\nazx_exit_link_reset(chip);\r\nusleep_range(1000, 1200);\r\n__skip:\r\nif (!azx_readb(chip, GCTL)) {\r\ndev_dbg(chip->card->dev, "azx_reset: controller not ready!\n");\r\nreturn -EBUSY;\r\n}\r\nif (!chip->single_cmd)\r\nazx_writel(chip, GCTL, azx_readl(chip, GCTL) |\r\nAZX_GCTL_UNSOL);\r\nif (!chip->codec_mask) {\r\nchip->codec_mask = azx_readw(chip, STATESTS);\r\ndev_dbg(chip->card->dev, "codec_mask = 0x%x\n",\r\nchip->codec_mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic void azx_int_enable(struct azx *chip)\r\n{\r\nazx_writel(chip, INTCTL, azx_readl(chip, INTCTL) |\r\nAZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN);\r\n}\r\nstatic void azx_int_disable(struct azx *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < chip->num_streams; i++) {\r\nstruct azx_dev *azx_dev = &chip->azx_dev[i];\r\nazx_sd_writeb(chip, azx_dev, SD_CTL,\r\nazx_sd_readb(chip, azx_dev, SD_CTL) &\r\n~SD_INT_MASK);\r\n}\r\nazx_writeb(chip, INTCTL, 0);\r\nazx_writel(chip, INTCTL, azx_readl(chip, INTCTL) &\r\n~(AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN));\r\n}\r\nstatic void azx_int_clear(struct azx *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < chip->num_streams; i++) {\r\nstruct azx_dev *azx_dev = &chip->azx_dev[i];\r\nazx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK);\r\n}\r\nazx_writew(chip, STATESTS, STATESTS_INT_MASK);\r\nazx_writeb(chip, RIRBSTS, RIRB_INT_MASK);\r\nazx_writel(chip, INTSTS, AZX_INT_CTRL_EN | AZX_INT_ALL_STREAM);\r\n}\r\nvoid azx_init_chip(struct azx *chip, bool full_reset)\r\n{\r\nif (chip->initialized)\r\nreturn;\r\nazx_reset(chip, full_reset);\r\nazx_int_clear(chip);\r\nazx_int_enable(chip);\r\nif (!chip->single_cmd)\r\nazx_init_cmd_io(chip);\r\nazx_writel(chip, DPLBASE, (u32)chip->posbuf.addr);\r\nazx_writel(chip, DPUBASE, upper_32_bits(chip->posbuf.addr));\r\nchip->initialized = 1;\r\n}\r\nvoid azx_stop_chip(struct azx *chip)\r\n{\r\nif (!chip->initialized)\r\nreturn;\r\nazx_int_disable(chip);\r\nazx_int_clear(chip);\r\nazx_free_cmd_io(chip);\r\nazx_writel(chip, DPLBASE, 0);\r\nazx_writel(chip, DPUBASE, 0);\r\nchip->initialized = 0;\r\n}\r\nirqreturn_t azx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct azx *chip = dev_id;\r\nstruct azx_dev *azx_dev;\r\nu32 status;\r\nu8 sd_status;\r\nint i;\r\n#ifdef CONFIG_PM_RUNTIME\r\nif (chip->driver_caps & AZX_DCAPS_PM_RUNTIME)\r\nif (!pm_runtime_active(chip->card->dev))\r\nreturn IRQ_NONE;\r\n#endif\r\nspin_lock(&chip->reg_lock);\r\nif (chip->disabled) {\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_NONE;\r\n}\r\nstatus = azx_readl(chip, INTSTS);\r\nif (status == 0 || status == 0xffffffff) {\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_NONE;\r\n}\r\nfor (i = 0; i < chip->num_streams; i++) {\r\nazx_dev = &chip->azx_dev[i];\r\nif (status & azx_dev->sd_int_sta_mask) {\r\nsd_status = azx_sd_readb(chip, azx_dev, SD_STS);\r\nazx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK);\r\nif (!azx_dev->substream || !azx_dev->running ||\r\n!(sd_status & SD_INT_COMPLETE))\r\ncontinue;\r\nif (!chip->ops->position_check ||\r\nchip->ops->position_check(chip, azx_dev)) {\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(azx_dev->substream);\r\nspin_lock(&chip->reg_lock);\r\n}\r\n}\r\n}\r\nstatus = azx_readb(chip, RIRBSTS);\r\nif (status & RIRB_INT_MASK) {\r\nif (status & RIRB_INT_RESPONSE) {\r\nif (chip->driver_caps & AZX_DCAPS_RIRB_PRE_DELAY)\r\nudelay(80);\r\nazx_update_rirb(chip);\r\n}\r\nazx_writeb(chip, RIRBSTS, RIRB_INT_MASK);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int probe_codec(struct azx *chip, int addr)\r\n{\r\nunsigned int cmd = (addr << 28) | (AC_NODE_ROOT << 20) |\r\n(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;\r\nunsigned int res;\r\nmutex_lock(&chip->bus->cmd_mutex);\r\nchip->probing = 1;\r\nazx_send_cmd(chip->bus, cmd);\r\nres = azx_get_response(chip->bus, addr);\r\nchip->probing = 0;\r\nmutex_unlock(&chip->bus->cmd_mutex);\r\nif (res == -1)\r\nreturn -EIO;\r\ndev_dbg(chip->card->dev, "codec #%d probed OK\n", addr);\r\nreturn 0;\r\n}\r\nstatic void azx_bus_reset(struct hda_bus *bus)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nbus->in_reset = 1;\r\nazx_stop_chip(chip);\r\nazx_init_chip(chip, true);\r\n#ifdef CONFIG_PM\r\nif (chip->initialized) {\r\nstruct azx_pcm *p;\r\nlist_for_each_entry(p, &chip->pcm_list, list)\r\nsnd_pcm_suspend_all(p->pcm);\r\nsnd_hda_suspend(chip->bus);\r\nsnd_hda_resume(chip->bus);\r\n}\r\n#endif\r\nbus->in_reset = 0;\r\n}\r\nstatic void azx_power_notify(struct hda_bus *bus, bool power_up)\r\n{\r\nstruct azx *chip = bus->private_data;\r\nif (!(chip->driver_caps & AZX_DCAPS_PM_RUNTIME))\r\nreturn;\r\nif (power_up)\r\npm_runtime_get_sync(chip->card->dev);\r\nelse\r\npm_runtime_put_sync(chip->card->dev);\r\n}\r\nstatic int get_jackpoll_interval(struct azx *chip)\r\n{\r\nint i;\r\nunsigned int j;\r\nif (!chip->jackpoll_ms)\r\nreturn 0;\r\ni = chip->jackpoll_ms[chip->dev_index];\r\nif (i == 0)\r\nreturn 0;\r\nif (i < 50 || i > 60000)\r\nj = 0;\r\nelse\r\nj = msecs_to_jiffies(i);\r\nif (j == 0)\r\ndev_warn(chip->card->dev,\r\n"jackpoll_ms value out of range: %d\n", i);\r\nreturn j;\r\n}\r\nint azx_codec_create(struct azx *chip, const char *model,\r\nunsigned int max_slots,\r\nint *power_save_to)\r\n{\r\nstruct hda_bus_template bus_temp;\r\nint c, codecs, err;\r\nmemset(&bus_temp, 0, sizeof(bus_temp));\r\nbus_temp.private_data = chip;\r\nbus_temp.modelname = model;\r\nbus_temp.pci = chip->pci;\r\nbus_temp.ops.command = azx_send_cmd;\r\nbus_temp.ops.get_response = azx_get_response;\r\nbus_temp.ops.attach_pcm = azx_attach_pcm_stream;\r\nbus_temp.ops.bus_reset = azx_bus_reset;\r\n#ifdef CONFIG_PM\r\nbus_temp.power_save = power_save_to;\r\nbus_temp.ops.pm_notify = azx_power_notify;\r\n#endif\r\n#ifdef CONFIG_SND_HDA_DSP_LOADER\r\nbus_temp.ops.load_dsp_prepare = azx_load_dsp_prepare;\r\nbus_temp.ops.load_dsp_trigger = azx_load_dsp_trigger;\r\nbus_temp.ops.load_dsp_cleanup = azx_load_dsp_cleanup;\r\n#endif\r\nerr = snd_hda_bus_new(chip->card, &bus_temp, &chip->bus);\r\nif (err < 0)\r\nreturn err;\r\nif (chip->driver_caps & AZX_DCAPS_RIRB_DELAY) {\r\ndev_dbg(chip->card->dev, "Enable delay in RIRB handling\n");\r\nchip->bus->needs_damn_long_delay = 1;\r\n}\r\ncodecs = 0;\r\nif (!max_slots)\r\nmax_slots = AZX_DEFAULT_CODECS;\r\nfor (c = 0; c < max_slots; c++) {\r\nif ((chip->codec_mask & (1 << c)) & chip->codec_probe_mask) {\r\nif (probe_codec(chip, c) < 0) {\r\ndev_warn(chip->card->dev,\r\n"Codec #%d probe error; disabling it...\n", c);\r\nchip->codec_mask &= ~(1 << c);\r\nazx_stop_chip(chip);\r\nazx_init_chip(chip, true);\r\n}\r\n}\r\n}\r\nif (chip->driver_caps & AZX_DCAPS_SYNC_WRITE) {\r\ndev_dbg(chip->card->dev, "Enable sync_write for stable communication\n");\r\nchip->bus->sync_write = 1;\r\nchip->bus->allow_bus_reset = 1;\r\n}\r\nfor (c = 0; c < max_slots; c++) {\r\nif ((chip->codec_mask & (1 << c)) & chip->codec_probe_mask) {\r\nstruct hda_codec *codec;\r\nerr = snd_hda_codec_new(chip->bus, c, &codec);\r\nif (err < 0)\r\ncontinue;\r\ncodec->jackpoll_interval = get_jackpoll_interval(chip);\r\ncodec->beep_mode = chip->beep_mode;\r\ncodecs++;\r\n}\r\n}\r\nif (!codecs) {\r\ndev_err(chip->card->dev, "no codecs initialized\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nint azx_codec_configure(struct azx *chip)\r\n{\r\nstruct hda_codec *codec;\r\nlist_for_each_entry(codec, &chip->bus->codec_list, list) {\r\nsnd_hda_codec_configure(codec);\r\n}\r\nreturn 0;\r\n}\r\nint azx_mixer_create(struct azx *chip)\r\n{\r\nreturn snd_hda_build_controls(chip->bus);\r\n}\r\nint azx_init_stream(struct azx *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < chip->num_streams; i++) {\r\nstruct azx_dev *azx_dev = &chip->azx_dev[i];\r\nazx_dev->posbuf = (u32 __iomem *)(chip->posbuf.area + i * 8);\r\nazx_dev->sd_addr = chip->remap_addr + (0x20 * i + 0x80);\r\nazx_dev->sd_int_sta_mask = 1 << i;\r\nazx_dev->index = i;\r\nazx_dev->stream_tag = i + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int azx_halt(struct notifier_block *nb, unsigned long event, void *buf)\r\n{\r\nstruct azx *chip = container_of(nb, struct azx, reboot_notifier);\r\nsnd_hda_bus_reboot_notify(chip->bus);\r\nazx_stop_chip(chip);\r\nreturn NOTIFY_OK;\r\n}\r\nvoid azx_notifier_register(struct azx *chip)\r\n{\r\nchip->reboot_notifier.notifier_call = azx_halt;\r\nregister_reboot_notifier(&chip->reboot_notifier);\r\n}\r\nvoid azx_notifier_unregister(struct azx *chip)\r\n{\r\nif (chip->reboot_notifier.notifier_call)\r\nunregister_reboot_notifier(&chip->reboot_notifier);\r\n}
