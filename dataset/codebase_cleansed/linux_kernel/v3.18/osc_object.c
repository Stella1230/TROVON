static struct lu_object *osc2lu(struct osc_object *osc)\r\n{\r\nreturn &osc->oo_cl.co_lu;\r\n}\r\nstatic struct osc_object *lu2osc(const struct lu_object *obj)\r\n{\r\nLINVRNT(osc_is_object(obj));\r\nreturn container_of0(obj, struct osc_object, oo_cl.co_lu);\r\n}\r\nstatic int osc_object_init(const struct lu_env *env, struct lu_object *obj,\r\nconst struct lu_object_conf *conf)\r\n{\r\nstruct osc_object *osc = lu2osc(obj);\r\nconst struct cl_object_conf *cconf = lu2cl_conf(conf);\r\nint i;\r\nosc->oo_oinfo = cconf->u.coc_oinfo;\r\nspin_lock_init(&osc->oo_seatbelt);\r\nfor (i = 0; i < CRT_NR; ++i)\r\nINIT_LIST_HEAD(&osc->oo_inflight[i]);\r\nINIT_LIST_HEAD(&osc->oo_ready_item);\r\nINIT_LIST_HEAD(&osc->oo_hp_ready_item);\r\nINIT_LIST_HEAD(&osc->oo_write_item);\r\nINIT_LIST_HEAD(&osc->oo_read_item);\r\nosc->oo_root.rb_node = NULL;\r\nINIT_LIST_HEAD(&osc->oo_hp_exts);\r\nINIT_LIST_HEAD(&osc->oo_urgent_exts);\r\nINIT_LIST_HEAD(&osc->oo_rpc_exts);\r\nINIT_LIST_HEAD(&osc->oo_reading_exts);\r\natomic_set(&osc->oo_nr_reads, 0);\r\natomic_set(&osc->oo_nr_writes, 0);\r\nspin_lock_init(&osc->oo_lock);\r\ncl_object_page_init(lu2cl(obj), sizeof(struct osc_page));\r\nreturn 0;\r\n}\r\nstatic void osc_object_free(const struct lu_env *env, struct lu_object *obj)\r\n{\r\nstruct osc_object *osc = lu2osc(obj);\r\nint i;\r\nfor (i = 0; i < CRT_NR; ++i)\r\nLASSERT(list_empty(&osc->oo_inflight[i]));\r\nLASSERT(list_empty(&osc->oo_ready_item));\r\nLASSERT(list_empty(&osc->oo_hp_ready_item));\r\nLASSERT(list_empty(&osc->oo_write_item));\r\nLASSERT(list_empty(&osc->oo_read_item));\r\nLASSERT(osc->oo_root.rb_node == NULL);\r\nLASSERT(list_empty(&osc->oo_hp_exts));\r\nLASSERT(list_empty(&osc->oo_urgent_exts));\r\nLASSERT(list_empty(&osc->oo_rpc_exts));\r\nLASSERT(list_empty(&osc->oo_reading_exts));\r\nLASSERT(atomic_read(&osc->oo_nr_reads) == 0);\r\nLASSERT(atomic_read(&osc->oo_nr_writes) == 0);\r\nlu_object_fini(obj);\r\nOBD_SLAB_FREE_PTR(osc, osc_object_kmem);\r\n}\r\nint osc_lvb_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct ost_lvb *lvb)\r\n{\r\nreturn (*p)(env, cookie, "size: %llu mtime: %llu atime: %llu ctime: %llu blocks: %llu",\r\nlvb->lvb_size, lvb->lvb_mtime, lvb->lvb_atime,\r\nlvb->lvb_ctime, lvb->lvb_blocks);\r\n}\r\nstatic int osc_object_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *obj)\r\n{\r\nstruct osc_object *osc = lu2osc(obj);\r\nstruct lov_oinfo *oinfo = osc->oo_oinfo;\r\nstruct osc_async_rc *ar = &oinfo->loi_ar;\r\n(*p)(env, cookie, "id: "DOSTID" "\r\n"idx: %d gen: %d kms_valid: %u kms %llu rc: %d force_sync: %d min_xid: %llu ",\r\nPOSTID(&oinfo->loi_oi), oinfo->loi_ost_idx,\r\noinfo->loi_ost_gen, oinfo->loi_kms_valid, oinfo->loi_kms,\r\nar->ar_rc, ar->ar_force_sync, ar->ar_min_xid);\r\nosc_lvb_print(env, cookie, p, &oinfo->loi_lvb);\r\nreturn 0;\r\n}\r\nstatic int osc_attr_get(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_attr *attr)\r\n{\r\nstruct lov_oinfo *oinfo = cl2osc(obj)->oo_oinfo;\r\ncl_lvb2attr(attr, &oinfo->loi_lvb);\r\nattr->cat_kms = oinfo->loi_kms_valid ? oinfo->loi_kms : 0;\r\nreturn 0;\r\n}\r\nint osc_attr_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_attr *attr, unsigned valid)\r\n{\r\nstruct lov_oinfo *oinfo = cl2osc(obj)->oo_oinfo;\r\nstruct ost_lvb *lvb = &oinfo->loi_lvb;\r\nif (valid & CAT_SIZE)\r\nlvb->lvb_size = attr->cat_size;\r\nif (valid & CAT_MTIME)\r\nlvb->lvb_mtime = attr->cat_mtime;\r\nif (valid & CAT_ATIME)\r\nlvb->lvb_atime = attr->cat_atime;\r\nif (valid & CAT_CTIME)\r\nlvb->lvb_ctime = attr->cat_ctime;\r\nif (valid & CAT_BLOCKS)\r\nlvb->lvb_blocks = attr->cat_blocks;\r\nif (valid & CAT_KMS) {\r\nCDEBUG(D_CACHE, "set kms from %llu to %llu\n",\r\noinfo->loi_kms, (__u64)attr->cat_kms);\r\nloi_kms_set(oinfo, attr->cat_kms);\r\n}\r\nreturn 0;\r\n}\r\nstatic int osc_object_glimpse(const struct lu_env *env,\r\nconst struct cl_object *obj, struct ost_lvb *lvb)\r\n{\r\nstruct lov_oinfo *oinfo = cl2osc(obj)->oo_oinfo;\r\nlvb->lvb_size = oinfo->loi_kms;\r\nlvb->lvb_blocks = oinfo->loi_lvb.lvb_blocks;\r\nreturn 0;\r\n}\r\nvoid osc_object_set_contended(struct osc_object *obj)\r\n{\r\nobj->oo_contention_time = cfs_time_current();\r\nobj->oo_contended = 1;\r\n}\r\nvoid osc_object_clear_contended(struct osc_object *obj)\r\n{\r\nobj->oo_contended = 0;\r\n}\r\nint osc_object_is_contended(struct osc_object *obj)\r\n{\r\nstruct osc_device *dev = lu2osc_dev(obj->oo_cl.co_lu.lo_dev);\r\nint osc_contention_time = dev->od_contention_time;\r\nunsigned long cur_time = cfs_time_current();\r\nunsigned long retry_time;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OSC_OBJECT_CONTENTION))\r\nreturn 1;\r\nif (!obj->oo_contended)\r\nreturn 0;\r\nretry_time = cfs_time_add(obj->oo_contention_time,\r\ncfs_time_seconds(osc_contention_time));\r\nif (cfs_time_after(cur_time, retry_time)) {\r\nosc_object_clear_contended(obj);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstruct lu_object *osc_object_alloc(const struct lu_env *env,\r\nconst struct lu_object_header *unused,\r\nstruct lu_device *dev)\r\n{\r\nstruct osc_object *osc;\r\nstruct lu_object *obj;\r\nOBD_SLAB_ALLOC_PTR_GFP(osc, osc_object_kmem, GFP_NOFS);\r\nif (osc != NULL) {\r\nobj = osc2lu(osc);\r\nlu_object_init(obj, NULL, dev);\r\nosc->oo_cl.co_ops = &osc_ops;\r\nobj->lo_ops = &osc_lu_obj_ops;\r\n} else\r\nobj = NULL;\r\nreturn obj;\r\n}
