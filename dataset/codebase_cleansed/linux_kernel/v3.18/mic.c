int orinoco_mic_init(struct orinoco_private *priv)\r\n{\r\npriv->tx_tfm_mic = crypto_alloc_hash("michael_mic", 0, 0);\r\nif (IS_ERR(priv->tx_tfm_mic)) {\r\nprintk(KERN_DEBUG "orinoco_mic_init: could not allocate "\r\n"crypto API michael_mic\n");\r\npriv->tx_tfm_mic = NULL;\r\nreturn -ENOMEM;\r\n}\r\npriv->rx_tfm_mic = crypto_alloc_hash("michael_mic", 0, 0);\r\nif (IS_ERR(priv->rx_tfm_mic)) {\r\nprintk(KERN_DEBUG "orinoco_mic_init: could not allocate "\r\n"crypto API michael_mic\n");\r\npriv->rx_tfm_mic = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid orinoco_mic_free(struct orinoco_private *priv)\r\n{\r\nif (priv->tx_tfm_mic)\r\ncrypto_free_hash(priv->tx_tfm_mic);\r\nif (priv->rx_tfm_mic)\r\ncrypto_free_hash(priv->rx_tfm_mic);\r\n}\r\nint orinoco_mic(struct crypto_hash *tfm_michael, u8 *key,\r\nu8 *da, u8 *sa, u8 priority,\r\nu8 *data, size_t data_len, u8 *mic)\r\n{\r\nstruct hash_desc desc;\r\nstruct scatterlist sg[2];\r\nu8 hdr[ETH_HLEN + 2];\r\nif (tfm_michael == NULL) {\r\nprintk(KERN_WARNING "orinoco_mic: tfm_michael == NULL\n");\r\nreturn -1;\r\n}\r\nmemcpy(&hdr[0], da, ETH_ALEN);\r\nmemcpy(&hdr[ETH_ALEN], sa, ETH_ALEN);\r\nhdr[ETH_ALEN * 2] = priority;\r\nhdr[ETH_ALEN * 2 + 1] = 0;\r\nhdr[ETH_ALEN * 2 + 2] = 0;\r\nhdr[ETH_ALEN * 2 + 3] = 0;\r\nsg_init_table(sg, 2);\r\nsg_set_buf(&sg[0], hdr, sizeof(hdr));\r\nsg_set_buf(&sg[1], data, data_len);\r\nif (crypto_hash_setkey(tfm_michael, key, MIC_KEYLEN))\r\nreturn -1;\r\ndesc.tfm = tfm_michael;\r\ndesc.flags = 0;\r\nreturn crypto_hash_digest(&desc, sg, data_len + sizeof(hdr),\r\nmic);\r\n}
