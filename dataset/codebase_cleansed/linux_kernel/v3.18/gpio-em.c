static inline unsigned long em_gio_read(struct em_gio_priv *p, int offs)\r\n{\r\nif (offs < GIO_IDT0)\r\nreturn ioread32(p->base0 + offs);\r\nelse\r\nreturn ioread32(p->base1 + (offs - GIO_IDT0));\r\n}\r\nstatic inline void em_gio_write(struct em_gio_priv *p, int offs,\r\nunsigned long value)\r\n{\r\nif (offs < GIO_IDT0)\r\niowrite32(value, p->base0 + offs);\r\nelse\r\niowrite32(value, p->base1 + (offs - GIO_IDT0));\r\n}\r\nstatic void em_gio_irq_disable(struct irq_data *d)\r\n{\r\nstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\r\nem_gio_write(p, GIO_IDS, BIT(irqd_to_hwirq(d)));\r\n}\r\nstatic void em_gio_irq_enable(struct irq_data *d)\r\n{\r\nstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\r\nem_gio_write(p, GIO_IEN, BIT(irqd_to_hwirq(d)));\r\n}\r\nstatic int em_gio_irq_reqres(struct irq_data *d)\r\n{\r\nstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\r\nif (gpio_lock_as_irq(&p->gpio_chip, irqd_to_hwirq(d))) {\r\ndev_err(p->gpio_chip.dev,\r\n"unable to lock HW IRQ %lu for IRQ\n",\r\nirqd_to_hwirq(d));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void em_gio_irq_relres(struct irq_data *d)\r\n{\r\nstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\r\ngpio_unlock_as_irq(&p->gpio_chip, irqd_to_hwirq(d));\r\n}\r\nstatic int em_gio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nunsigned char value = em_gio_sense_table[type & IRQ_TYPE_SENSE_MASK];\r\nstruct em_gio_priv *p = irq_data_get_irq_chip_data(d);\r\nunsigned int reg, offset, shift;\r\nunsigned long flags;\r\nunsigned long tmp;\r\nif (!value)\r\nreturn -EINVAL;\r\noffset = irqd_to_hwirq(d);\r\npr_debug("gio: sense irq = %d, mode = %d\n", offset, value);\r\nreg = GIO_IDT(offset >> 3);\r\nshift = (offset & 0x07) << 4;\r\nspin_lock_irqsave(&p->sense_lock, flags);\r\ntmp = em_gio_read(p, GIO_IIA);\r\ntmp &= ~BIT(offset);\r\nem_gio_write(p, GIO_IIA, tmp);\r\ntmp = em_gio_read(p, reg);\r\ntmp &= ~(0xf << shift);\r\ntmp |= value << shift;\r\nem_gio_write(p, reg, tmp);\r\nem_gio_write(p, GIO_IIR, BIT(offset));\r\ntmp = em_gio_read(p, GIO_IIA);\r\ntmp |= BIT(offset);\r\nem_gio_write(p, GIO_IIA, tmp);\r\nspin_unlock_irqrestore(&p->sense_lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t em_gio_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct em_gio_priv *p = dev_id;\r\nunsigned long pending;\r\nunsigned int offset, irqs_handled = 0;\r\nwhile ((pending = em_gio_read(p, GIO_MST))) {\r\noffset = __ffs(pending);\r\nem_gio_write(p, GIO_IIR, BIT(offset));\r\ngeneric_handle_irq(irq_find_mapping(p->irq_domain, offset));\r\nirqs_handled++;\r\n}\r\nreturn irqs_handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic inline struct em_gio_priv *gpio_to_priv(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct em_gio_priv, gpio_chip);\r\n}\r\nstatic int em_gio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nem_gio_write(gpio_to_priv(chip), GIO_E0, BIT(offset));\r\nreturn 0;\r\n}\r\nstatic int em_gio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn (int)(em_gio_read(gpio_to_priv(chip), GIO_I) & BIT(offset));\r\n}\r\nstatic void __em_gio_set(struct gpio_chip *chip, unsigned int reg,\r\nunsigned shift, int value)\r\n{\r\nem_gio_write(gpio_to_priv(chip), reg,\r\n(BIT(shift + 16)) | (value << shift));\r\n}\r\nstatic void em_gio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nif (offset < 16)\r\n__em_gio_set(chip, GIO_OL, offset, value);\r\nelse\r\n__em_gio_set(chip, GIO_OH, offset - 16, value);\r\n}\r\nstatic int em_gio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nem_gio_set(chip, offset, value);\r\nem_gio_write(gpio_to_priv(chip), GIO_E1, BIT(offset));\r\nreturn 0;\r\n}\r\nstatic int em_gio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn irq_create_mapping(gpio_to_priv(chip)->irq_domain, offset);\r\n}\r\nstatic int em_gio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(chip->base + offset);\r\n}\r\nstatic void em_gio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_free_gpio(chip->base + offset);\r\nem_gio_direction_input(chip, offset);\r\n}\r\nstatic int em_gio_irq_domain_map(struct irq_domain *h, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct em_gio_priv *p = h->host_data;\r\npr_debug("gio: map hw irq = %d, irq = %d\n", (int)hwirq, irq);\r\nirq_set_chip_data(irq, h->host_data);\r\nirq_set_chip_and_handler(irq, &p->irq_chip, handle_level_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int em_gio_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_em_config pdata_dt;\r\nstruct gpio_em_config *pdata = dev_get_platdata(&pdev->dev);\r\nstruct em_gio_priv *p;\r\nstruct resource *io[2], *irq[2];\r\nstruct gpio_chip *gpio_chip;\r\nstruct irq_chip *irq_chip;\r\nconst char *name = dev_name(&pdev->dev);\r\nint ret;\r\np = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\r\nif (!p) {\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\np->pdev = pdev;\r\nplatform_set_drvdata(pdev, p);\r\nspin_lock_init(&p->sense_lock);\r\nio[0] = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nio[1] = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nirq[0] = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nirq[1] = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\r\nif (!io[0] || !io[1] || !irq[0] || !irq[1]) {\r\ndev_err(&pdev->dev, "missing IRQ or IOMEM\n");\r\nret = -EINVAL;\r\ngoto err0;\r\n}\r\np->base0 = devm_ioremap_nocache(&pdev->dev, io[0]->start,\r\nresource_size(io[0]));\r\nif (!p->base0) {\r\ndev_err(&pdev->dev, "failed to remap low I/O memory\n");\r\nret = -ENXIO;\r\ngoto err0;\r\n}\r\np->base1 = devm_ioremap_nocache(&pdev->dev, io[1]->start,\r\nresource_size(io[1]));\r\nif (!p->base1) {\r\ndev_err(&pdev->dev, "failed to remap high I/O memory\n");\r\nret = -ENXIO;\r\ngoto err0;\r\n}\r\nif (!pdata) {\r\nmemset(&pdata_dt, 0, sizeof(pdata_dt));\r\npdata = &pdata_dt;\r\nif (of_property_read_u32(pdev->dev.of_node, "ngpios",\r\n&pdata->number_of_pins)) {\r\ndev_err(&pdev->dev, "Missing ngpios OF property\n");\r\nret = -EINVAL;\r\ngoto err0;\r\n}\r\nret = of_alias_get_id(pdev->dev.of_node, "gpio");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Couldn't get OF id\n");\r\ngoto err0;\r\n}\r\npdata->gpio_base = ret * 32;\r\n}\r\ngpio_chip = &p->gpio_chip;\r\ngpio_chip->of_node = pdev->dev.of_node;\r\ngpio_chip->direction_input = em_gio_direction_input;\r\ngpio_chip->get = em_gio_get;\r\ngpio_chip->direction_output = em_gio_direction_output;\r\ngpio_chip->set = em_gio_set;\r\ngpio_chip->to_irq = em_gio_to_irq;\r\ngpio_chip->request = em_gio_request;\r\ngpio_chip->free = em_gio_free;\r\ngpio_chip->label = name;\r\ngpio_chip->dev = &pdev->dev;\r\ngpio_chip->owner = THIS_MODULE;\r\ngpio_chip->base = pdata->gpio_base;\r\ngpio_chip->ngpio = pdata->number_of_pins;\r\nirq_chip = &p->irq_chip;\r\nirq_chip->name = name;\r\nirq_chip->irq_mask = em_gio_irq_disable;\r\nirq_chip->irq_unmask = em_gio_irq_enable;\r\nirq_chip->irq_set_type = em_gio_irq_set_type;\r\nirq_chip->irq_request_resources = em_gio_irq_reqres;\r\nirq_chip->irq_release_resources = em_gio_irq_relres;\r\nirq_chip->flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_MASK_ON_SUSPEND;\r\np->irq_domain = irq_domain_add_simple(pdev->dev.of_node,\r\npdata->number_of_pins,\r\npdata->irq_base,\r\n&em_gio_irq_domain_ops, p);\r\nif (!p->irq_domain) {\r\nret = -ENXIO;\r\ndev_err(&pdev->dev, "cannot initialize irq domain\n");\r\ngoto err0;\r\n}\r\nif (devm_request_irq(&pdev->dev, irq[0]->start,\r\nem_gio_irq_handler, 0, name, p)) {\r\ndev_err(&pdev->dev, "failed to request low IRQ\n");\r\nret = -ENOENT;\r\ngoto err1;\r\n}\r\nif (devm_request_irq(&pdev->dev, irq[1]->start,\r\nem_gio_irq_handler, 0, name, p)) {\r\ndev_err(&pdev->dev, "failed to request high IRQ\n");\r\nret = -ENOENT;\r\ngoto err1;\r\n}\r\nret = gpiochip_add(gpio_chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add GPIO controller\n");\r\ngoto err1;\r\n}\r\nif (pdata->pctl_name) {\r\nret = gpiochip_add_pin_range(gpio_chip, pdata->pctl_name, 0,\r\ngpio_chip->base, gpio_chip->ngpio);\r\nif (ret < 0)\r\ndev_warn(&pdev->dev, "failed to add pin range\n");\r\n}\r\nreturn 0;\r\nerr1:\r\nirq_domain_remove(p->irq_domain);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int em_gio_remove(struct platform_device *pdev)\r\n{\r\nstruct em_gio_priv *p = platform_get_drvdata(pdev);\r\ngpiochip_remove(&p->gpio_chip);\r\nirq_domain_remove(p->irq_domain);\r\nreturn 0;\r\n}\r\nstatic int __init em_gio_init(void)\r\n{\r\nreturn platform_driver_register(&em_gio_device_driver);\r\n}\r\nstatic void __exit em_gio_exit(void)\r\n{\r\nplatform_driver_unregister(&em_gio_device_driver);\r\n}
