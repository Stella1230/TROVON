void usage(char progname[], int exit_status)\r\n{\r\nprintf("Usage:\n");\r\nprintf("1) %s -r [-s sleep]\n", basename(progname));\r\nprintf("2) %s -b byte_offset\n", basename(progname));\r\nprintf("3) %s -w byte_offset -v value\n\n", basename(progname));\r\nputs("\t-r [-s sleep] : Dump EC registers");\r\nputs("\t If sleep is given, sleep x seconds,");\r\nputs("\t re-read EC registers and show changes");\r\nputs("\t-b offset : Read value at byte_offset (in hex)");\r\nputs("\t-w offset -v value : Write value at byte_offset");\r\nputs("\t-h : Print this help\n\n");\r\nputs("Offsets and values are in hexadecimal number sytem.");\r\nputs("The offset and value must be between 0 and 0xff.");\r\nexit(exit_status);\r\n}\r\nvoid parse_opts(int argc, char *argv[])\r\n{\r\nint c;\r\nwhile ((c = getopt(argc, argv, "rs:b:w:v:h")) != -1) {\r\nswitch (c) {\r\ncase 'r':\r\nif (read_mode != -1)\r\nusage(argv[0], EXIT_FAILURE);\r\nread_mode = 1;\r\nbreak;\r\ncase 's':\r\nif (read_mode != -1 && read_mode != 1)\r\nusage(argv[0], EXIT_FAILURE);\r\nsleep_time = atoi(optarg);\r\nif (sleep_time <= 0) {\r\nsleep_time = 0;\r\nusage(argv[0], EXIT_FAILURE);\r\nprintf("Bad sleep time: %s\n", optarg);\r\n}\r\nbreak;\r\ncase 'b':\r\nif (read_mode != -1)\r\nusage(argv[0], EXIT_FAILURE);\r\nread_mode = 1;\r\nread_byte_offset = strtoul(optarg, NULL, 16);\r\nbreak;\r\ncase 'w':\r\nif (read_mode != -1)\r\nusage(argv[0], EXIT_FAILURE);\r\nread_mode = 0;\r\nwrite_byte_offset = strtoul(optarg, NULL, 16);\r\nbreak;\r\ncase 'v':\r\nwrite_value = strtoul(optarg, NULL, 16);\r\nbreak;\r\ncase 'h':\r\nusage(argv[0], EXIT_SUCCESS);\r\ndefault:\r\nfprintf(stderr, "Unknown option!\n");\r\nusage(argv[0], EXIT_FAILURE);\r\n}\r\n}\r\nif (read_mode == 0) {\r\nif (write_byte_offset < 0 ||\r\nwrite_byte_offset >= EC_SPACE_SIZE) {\r\nfprintf(stderr, "Wrong byte offset 0x%.2x, valid: "\r\n"[0-0x%.2x]\n",\r\nwrite_byte_offset, EC_SPACE_SIZE - 1);\r\nusage(argv[0], EXIT_FAILURE);\r\n}\r\nif (write_value < 0 ||\r\nwrite_value >= 255) {\r\nfprintf(stderr, "Wrong byte offset 0x%.2x, valid:"\r\n"[0-0xff]\n", write_byte_offset);\r\nusage(argv[0], EXIT_FAILURE);\r\n}\r\n}\r\nif (read_mode == 1 && read_byte_offset != -1) {\r\nif (read_byte_offset < -1 ||\r\nread_byte_offset >= EC_SPACE_SIZE) {\r\nfprintf(stderr, "Wrong byte offset 0x%.2x, valid: "\r\n"[0-0x%.2x]\n",\r\nread_byte_offset, EC_SPACE_SIZE - 1);\r\nusage(argv[0], EXIT_FAILURE);\r\n}\r\n}\r\n}\r\nvoid dump_ec(int fd)\r\n{\r\nchar buf[EC_SPACE_SIZE];\r\nchar buf2[EC_SPACE_SIZE];\r\nint byte_off, bytes_read;\r\nbytes_read = read(fd, buf, EC_SPACE_SIZE);\r\nif (bytes_read == -1)\r\nerr(EXIT_FAILURE, "Could not read from %s\n", SYSFS_PATH);\r\nif (bytes_read != EC_SPACE_SIZE)\r\nfprintf(stderr, "Could only read %d bytes\n", bytes_read);\r\nprintf(" 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");\r\nfor (byte_off = 0; byte_off < bytes_read; byte_off++) {\r\nif ((byte_off % 16) == 0)\r\nprintf("\n%.2X: ", byte_off);\r\nprintf(" %.2x ", (uint8_t)buf[byte_off]);\r\n}\r\nprintf("\n");\r\nif (!sleep_time)\r\nreturn;\r\nprintf("\n");\r\nlseek(fd, 0, SEEK_SET);\r\nsleep(sleep_time);\r\nbytes_read = read(fd, buf2, EC_SPACE_SIZE);\r\nif (bytes_read == -1)\r\nerr(EXIT_FAILURE, "Could not read from %s\n", SYSFS_PATH);\r\nif (bytes_read != EC_SPACE_SIZE)\r\nfprintf(stderr, "Could only read %d bytes\n", bytes_read);\r\nprintf(" 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F");\r\nfor (byte_off = 0; byte_off < bytes_read; byte_off++) {\r\nif ((byte_off % 16) == 0)\r\nprintf("\n%.2X: ", byte_off);\r\nif (buf[byte_off] == buf2[byte_off])\r\nprintf(" %.2x ", (uint8_t)buf2[byte_off]);\r\nelse\r\nprintf("*%.2x ", (uint8_t)buf2[byte_off]);\r\n}\r\nprintf("\n");\r\n}\r\nvoid read_ec_val(int fd, int byte_offset)\r\n{\r\nuint8_t buf;\r\nint error;\r\nerror = lseek(fd, byte_offset, SEEK_SET);\r\nif (error != byte_offset)\r\nerr(EXIT_FAILURE, "Cannot set offset to 0x%.2x", byte_offset);\r\nerror = read(fd, &buf, 1);\r\nif (error != 1)\r\nerr(EXIT_FAILURE, "Could not read byte 0x%.2x from %s\n",\r\nbyte_offset, SYSFS_PATH);\r\nprintf("0x%.2x\n", buf);\r\nreturn;\r\n}\r\nvoid write_ec_val(int fd, int byte_offset, uint8_t value)\r\n{\r\nint error;\r\nerror = lseek(fd, byte_offset, SEEK_SET);\r\nif (error != byte_offset)\r\nerr(EXIT_FAILURE, "Cannot set offset to 0x%.2x", byte_offset);\r\nerror = write(fd, &value, 1);\r\nif (error != 1)\r\nerr(EXIT_FAILURE, "Cannot write value 0x%.2x to offset 0x%.2x",\r\nvalue, byte_offset);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint file_mode = O_RDONLY;\r\nint fd;\r\nparse_opts(argc, argv);\r\nif (read_mode == 0)\r\nfile_mode = O_WRONLY;\r\nelse if (read_mode == 1)\r\nfile_mode = O_RDONLY;\r\nelse\r\nusage(argv[0], EXIT_FAILURE);\r\nfd = open(SYSFS_PATH, file_mode);\r\nif (fd == -1)\r\nerr(EXIT_FAILURE, "%s", SYSFS_PATH);\r\nif (read_mode)\r\nif (read_byte_offset == -1)\r\ndump_ec(fd);\r\nelse if (read_byte_offset < 0 ||\r\nread_byte_offset >= EC_SPACE_SIZE)\r\nusage(argv[0], EXIT_FAILURE);\r\nelse\r\nread_ec_val(fd, read_byte_offset);\r\nelse\r\nwrite_ec_val(fd, write_byte_offset, write_value);\r\nclose(fd);\r\nexit(EXIT_SUCCESS);\r\n}
