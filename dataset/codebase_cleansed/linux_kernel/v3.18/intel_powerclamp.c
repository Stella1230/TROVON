static int duration_set(const char *arg, const struct kernel_param *kp)\r\n{\r\nint ret = 0;\r\nunsigned long new_duration;\r\nret = kstrtoul(arg, 10, &new_duration);\r\nif (ret)\r\ngoto exit;\r\nif (new_duration > 25 || new_duration < 6) {\r\npr_err("Out of recommended range %lu, between 6-25ms\n",\r\nnew_duration);\r\nret = -EINVAL;\r\n}\r\nduration = clamp(new_duration, 6ul, 25ul);\r\nsmp_mb();\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int window_size_set(const char *arg, const struct kernel_param *kp)\r\n{\r\nint ret = 0;\r\nunsigned long new_window_size;\r\nret = kstrtoul(arg, 10, &new_window_size);\r\nif (ret)\r\ngoto exit_win;\r\nif (new_window_size > 10 || new_window_size < 2) {\r\npr_err("Out of recommended window size %lu, between 2-10\n",\r\nnew_window_size);\r\nret = -EINVAL;\r\n}\r\nwindow_size = clamp(new_window_size, 2ul, 10ul);\r\nsmp_mb();\r\nexit_win:\r\nreturn ret;\r\n}\r\nstatic void find_target_mwait(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx;\r\nunsigned int highest_cstate = 0;\r\nunsigned int highest_subcstate = 0;\r\nint i;\r\nif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\r\nreturn;\r\ncpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &edx);\r\nif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\r\n!(ecx & CPUID5_ECX_INTERRUPT_BREAK))\r\nreturn;\r\nedx >>= MWAIT_SUBSTATE_SIZE;\r\nfor (i = 0; i < 7 && edx; i++, edx >>= MWAIT_SUBSTATE_SIZE) {\r\nif (edx & MWAIT_SUBSTATE_MASK) {\r\nhighest_cstate = i;\r\nhighest_subcstate = edx & MWAIT_SUBSTATE_MASK;\r\n}\r\n}\r\ntarget_mwait = (highest_cstate << MWAIT_SUBSTATE_SIZE) |\r\n(highest_subcstate - 1);\r\n}\r\nstatic bool has_pkg_state_counter(void)\r\n{\r\nu64 tmp;\r\nreturn !rdmsrl_safe(MSR_PKG_C2_RESIDENCY, &tmp) ||\r\n!rdmsrl_safe(MSR_PKG_C3_RESIDENCY, &tmp) ||\r\n!rdmsrl_safe(MSR_PKG_C6_RESIDENCY, &tmp) ||\r\n!rdmsrl_safe(MSR_PKG_C7_RESIDENCY, &tmp);\r\n}\r\nstatic u64 pkg_state_counter(void)\r\n{\r\nu64 val;\r\nu64 count = 0;\r\nstatic bool skip_c2;\r\nstatic bool skip_c3;\r\nstatic bool skip_c6;\r\nstatic bool skip_c7;\r\nif (!skip_c2) {\r\nif (!rdmsrl_safe(MSR_PKG_C2_RESIDENCY, &val))\r\ncount += val;\r\nelse\r\nskip_c2 = true;\r\n}\r\nif (!skip_c3) {\r\nif (!rdmsrl_safe(MSR_PKG_C3_RESIDENCY, &val))\r\ncount += val;\r\nelse\r\nskip_c3 = true;\r\n}\r\nif (!skip_c6) {\r\nif (!rdmsrl_safe(MSR_PKG_C6_RESIDENCY, &val))\r\ncount += val;\r\nelse\r\nskip_c6 = true;\r\n}\r\nif (!skip_c7) {\r\nif (!rdmsrl_safe(MSR_PKG_C7_RESIDENCY, &val))\r\ncount += val;\r\nelse\r\nskip_c7 = true;\r\n}\r\nreturn count;\r\n}\r\nstatic void noop_timer(unsigned long foo)\r\n{\r\n}\r\nstatic unsigned int get_compensation(int ratio)\r\n{\r\nunsigned int comp = 0;\r\nif (ratio == 1 &&\r\ncal_data[ratio].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio + 1].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio + 2].confidence >= CONFIDENCE_OK) {\r\ncomp = (cal_data[ratio].steady_comp +\r\ncal_data[ratio + 1].steady_comp +\r\ncal_data[ratio + 2].steady_comp) / 3;\r\n} else if (ratio == MAX_TARGET_RATIO - 1 &&\r\ncal_data[ratio].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio - 1].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio - 2].confidence >= CONFIDENCE_OK) {\r\ncomp = (cal_data[ratio].steady_comp +\r\ncal_data[ratio - 1].steady_comp +\r\ncal_data[ratio - 2].steady_comp) / 3;\r\n} else if (cal_data[ratio].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio - 1].confidence >= CONFIDENCE_OK &&\r\ncal_data[ratio + 1].confidence >= CONFIDENCE_OK) {\r\ncomp = (cal_data[ratio].steady_comp +\r\ncal_data[ratio - 1].steady_comp +\r\ncal_data[ratio + 1].steady_comp) / 3;\r\n}\r\nif (reduce_irq)\r\ncomp = ratio;\r\nif (comp + ratio >= MAX_TARGET_RATIO)\r\ncomp = MAX_TARGET_RATIO - ratio - 1;\r\nreturn comp;\r\n}\r\nstatic void adjust_compensation(int target_ratio, unsigned int win)\r\n{\r\nint delta;\r\nstruct powerclamp_calibration_data *d = &cal_data[target_ratio];\r\nif (d->confidence >= CONFIDENCE_OK ||\r\natomic_read(&idle_wakeup_counter) >\r\nwin * num_online_cpus())\r\nreturn;\r\ndelta = set_target_ratio - current_ratio;\r\nif (delta >= 0 && delta <= (1+target_ratio/10)) {\r\nif (d->steady_comp)\r\nd->steady_comp =\r\nroundup(delta+d->steady_comp, 2)/2;\r\nelse\r\nd->steady_comp = delta;\r\nd->confidence++;\r\n}\r\n}\r\nstatic bool powerclamp_adjust_controls(unsigned int target_ratio,\r\nunsigned int guard, unsigned int win)\r\n{\r\nstatic u64 msr_last, tsc_last;\r\nu64 msr_now, tsc_now;\r\nu64 val64;\r\nmsr_now = pkg_state_counter();\r\nrdtscll(tsc_now);\r\nif (!msr_last || !tsc_last)\r\ncurrent_ratio = 1;\r\nelse if (tsc_now-tsc_last) {\r\nval64 = 100*(msr_now-msr_last);\r\ndo_div(val64, (tsc_now-tsc_last));\r\ncurrent_ratio = val64;\r\n}\r\nmsr_last = msr_now;\r\ntsc_last = tsc_now;\r\nadjust_compensation(target_ratio, win);\r\nreduce_irq = atomic_read(&idle_wakeup_counter) >=\r\n2 * win * num_online_cpus();\r\natomic_set(&idle_wakeup_counter, 0);\r\nreturn set_target_ratio + guard <= current_ratio;\r\n}\r\nstatic int clamp_thread(void *arg)\r\n{\r\nint cpunr = (unsigned long)arg;\r\nDEFINE_TIMER(wakeup_timer, noop_timer, 0, 0);\r\nstatic const struct sched_param param = {\r\n.sched_priority = MAX_USER_RT_PRIO/2,\r\n};\r\nunsigned int count = 0;\r\nunsigned int target_ratio;\r\nset_bit(cpunr, cpu_clamping_mask);\r\nset_freezable();\r\ninit_timer_on_stack(&wakeup_timer);\r\nsched_setscheduler(current, SCHED_FIFO, &param);\r\nwhile (true == clamping && !kthread_should_stop() &&\r\ncpu_online(cpunr)) {\r\nint sleeptime;\r\nunsigned long target_jiffies;\r\nunsigned int guard;\r\nunsigned int compensation = 0;\r\nint interval;\r\nunsigned int duration_jiffies = msecs_to_jiffies(duration);\r\nunsigned int window_size_now;\r\ntry_to_freeze();\r\ntarget_ratio = set_target_ratio;\r\nguard = 1 + target_ratio/20;\r\nwindow_size_now = window_size;\r\ncount++;\r\ncompensation = get_compensation(target_ratio);\r\ninterval = duration_jiffies*100/(target_ratio+compensation);\r\ntarget_jiffies = roundup(jiffies, interval);\r\nsleeptime = target_jiffies - jiffies;\r\nif (sleeptime <= 0)\r\nsleeptime = 1;\r\nschedule_timeout_interruptible(sleeptime);\r\nif (cpunr == control_cpu && !(count%window_size_now)) {\r\nshould_skip =\r\npowerclamp_adjust_controls(target_ratio,\r\nguard, window_size_now);\r\nsmp_mb();\r\n}\r\nif (should_skip)\r\ncontinue;\r\ntarget_jiffies = jiffies + duration_jiffies;\r\nmod_timer(&wakeup_timer, target_jiffies);\r\nif (unlikely(local_softirq_pending()))\r\ncontinue;\r\npreempt_disable();\r\ntick_nohz_idle_enter();\r\nwhile (time_before(jiffies, target_jiffies)) {\r\nunsigned long ecx = 1;\r\nunsigned long eax = target_mwait;\r\nlocal_touch_nmi();\r\nstop_critical_timings();\r\nmwait_idle_with_hints(eax, ecx);\r\nstart_critical_timings();\r\natomic_inc(&idle_wakeup_counter);\r\n}\r\ntick_nohz_idle_exit();\r\npreempt_enable();\r\n}\r\ndel_timer_sync(&wakeup_timer);\r\nclear_bit(cpunr, cpu_clamping_mask);\r\nreturn 0;\r\n}\r\nstatic void poll_pkg_cstate(struct work_struct *dummy)\r\n{\r\nstatic u64 msr_last;\r\nstatic u64 tsc_last;\r\nstatic unsigned long jiffies_last;\r\nu64 msr_now;\r\nunsigned long jiffies_now;\r\nu64 tsc_now;\r\nu64 val64;\r\nmsr_now = pkg_state_counter();\r\nrdtscll(tsc_now);\r\njiffies_now = jiffies;\r\nif (!msr_last || !tsc_last)\r\npkg_cstate_ratio_cur = 1;\r\nelse {\r\nif (tsc_now - tsc_last) {\r\nval64 = 100 * (msr_now - msr_last);\r\ndo_div(val64, (tsc_now - tsc_last));\r\npkg_cstate_ratio_cur = val64;\r\n}\r\n}\r\nmsr_last = msr_now;\r\njiffies_last = jiffies_now;\r\ntsc_last = tsc_now;\r\nif (true == clamping)\r\nschedule_delayed_work(&poll_pkg_cstate_work, HZ);\r\n}\r\nstatic int start_power_clamp(void)\r\n{\r\nunsigned long cpu;\r\nstruct task_struct *thread;\r\nif (!has_pkg_state_counter()) {\r\npr_err("pkg cstate counter not functional, abort\n");\r\nreturn -EINVAL;\r\n}\r\nset_target_ratio = clamp(set_target_ratio, 0U, MAX_TARGET_RATIO - 1);\r\nget_online_cpus();\r\ncontrol_cpu = 0;\r\nif (!cpu_online(control_cpu))\r\ncontrol_cpu = smp_processor_id();\r\nclamping = true;\r\nschedule_delayed_work(&poll_pkg_cstate_work, 0);\r\nfor_each_online_cpu(cpu) {\r\nstruct task_struct **p =\r\nper_cpu_ptr(powerclamp_thread, cpu);\r\nthread = kthread_create_on_node(clamp_thread,\r\n(void *) cpu,\r\ncpu_to_node(cpu),\r\n"kidle_inject/%ld", cpu);\r\nif (likely(!IS_ERR(thread))) {\r\nkthread_bind(thread, cpu);\r\nwake_up_process(thread);\r\n*p = thread;\r\n}\r\n}\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic void end_power_clamp(void)\r\n{\r\nint i;\r\nstruct task_struct *thread;\r\nclamping = false;\r\nsmp_mb();\r\nmsleep(20);\r\nif (bitmap_weight(cpu_clamping_mask, num_possible_cpus())) {\r\nfor_each_set_bit(i, cpu_clamping_mask, num_possible_cpus()) {\r\npr_debug("clamping thread for cpu %d alive, kill\n", i);\r\nthread = *per_cpu_ptr(powerclamp_thread, i);\r\nkthread_stop(thread);\r\n}\r\n}\r\n}\r\nstatic int powerclamp_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned long cpu = (unsigned long)hcpu;\r\nstruct task_struct *thread;\r\nstruct task_struct **percpu_thread =\r\nper_cpu_ptr(powerclamp_thread, cpu);\r\nif (false == clamping)\r\ngoto exit_ok;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\nthread = kthread_create_on_node(clamp_thread,\r\n(void *) cpu,\r\ncpu_to_node(cpu),\r\n"kidle_inject/%lu", cpu);\r\nif (likely(!IS_ERR(thread))) {\r\nkthread_bind(thread, cpu);\r\nwake_up_process(thread);\r\n*percpu_thread = thread;\r\n}\r\nif (cpu == 0) {\r\ncontrol_cpu = 0;\r\nsmp_mb();\r\n}\r\nbreak;\r\ncase CPU_DEAD:\r\nif (test_bit(cpu, cpu_clamping_mask)) {\r\npr_err("cpu %lu dead but powerclamping thread is not\n",\r\ncpu);\r\nkthread_stop(*percpu_thread);\r\n}\r\nif (cpu == control_cpu) {\r\ncontrol_cpu = smp_processor_id();\r\nsmp_mb();\r\n}\r\n}\r\nexit_ok:\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int powerclamp_get_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\n*state = MAX_TARGET_RATIO;\r\nreturn 0;\r\n}\r\nstatic int powerclamp_get_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nif (true == clamping)\r\n*state = pkg_cstate_ratio_cur;\r\nelse\r\n*state = -1;\r\nreturn 0;\r\n}\r\nstatic int powerclamp_set_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long new_target_ratio)\r\n{\r\nint ret = 0;\r\nnew_target_ratio = clamp(new_target_ratio, 0UL,\r\n(unsigned long) (MAX_TARGET_RATIO-1));\r\nif (set_target_ratio == 0 && new_target_ratio > 0) {\r\npr_info("Start idle injection to reduce power\n");\r\nset_target_ratio = new_target_ratio;\r\nret = start_power_clamp();\r\ngoto exit_set;\r\n} else if (set_target_ratio > 0 && new_target_ratio == 0) {\r\npr_info("Stop forced idle injection\n");\r\nset_target_ratio = 0;\r\nend_power_clamp();\r\n} else {\r\nset_target_ratio = new_target_ratio;\r\nsmp_mb();\r\n}\r\nexit_set:\r\nreturn ret;\r\n}\r\nstatic int powerclamp_probe(void)\r\n{\r\nif (!x86_match_cpu(intel_powerclamp_ids)) {\r\npr_err("Intel powerclamp does not run on family %d model %d\n",\r\nboot_cpu_data.x86, boot_cpu_data.x86_model);\r\nreturn -ENODEV;\r\n}\r\nif (!boot_cpu_has(X86_FEATURE_NONSTOP_TSC) ||\r\n!boot_cpu_has(X86_FEATURE_CONSTANT_TSC) ||\r\n!boot_cpu_has(X86_FEATURE_MWAIT) ||\r\n!boot_cpu_has(X86_FEATURE_ARAT))\r\nreturn -ENODEV;\r\nfind_target_mwait();\r\nreturn 0;\r\n}\r\nstatic int powerclamp_debug_show(struct seq_file *m, void *unused)\r\n{\r\nint i = 0;\r\nseq_printf(m, "controlling cpu: %d\n", control_cpu);\r\nseq_printf(m, "pct confidence steady dynamic (compensation)\n");\r\nfor (i = 0; i < MAX_TARGET_RATIO; i++) {\r\nseq_printf(m, "%d\t%lu\t%lu\t%lu\n",\r\ni,\r\ncal_data[i].confidence,\r\ncal_data[i].steady_comp,\r\ncal_data[i].dynamic_comp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int powerclamp_debug_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, powerclamp_debug_show, inode->i_private);\r\n}\r\nstatic inline void powerclamp_create_debug_files(void)\r\n{\r\ndebug_dir = debugfs_create_dir("intel_powerclamp", NULL);\r\nif (!debug_dir)\r\nreturn;\r\nif (!debugfs_create_file("powerclamp_calib", S_IRUGO, debug_dir,\r\ncal_data, &powerclamp_debug_fops))\r\ngoto file_error;\r\nreturn;\r\nfile_error:\r\ndebugfs_remove_recursive(debug_dir);\r\n}\r\nstatic int powerclamp_init(void)\r\n{\r\nint retval;\r\nint bitmap_size;\r\nbitmap_size = BITS_TO_LONGS(num_possible_cpus()) * sizeof(long);\r\ncpu_clamping_mask = kzalloc(bitmap_size, GFP_KERNEL);\r\nif (!cpu_clamping_mask)\r\nreturn -ENOMEM;\r\nretval = powerclamp_probe();\r\nif (retval)\r\ngoto exit_free;\r\nwindow_size = 2;\r\nregister_hotcpu_notifier(&powerclamp_cpu_notifier);\r\npowerclamp_thread = alloc_percpu(struct task_struct *);\r\nif (!powerclamp_thread) {\r\nretval = -ENOMEM;\r\ngoto exit_unregister;\r\n}\r\ncooling_dev = thermal_cooling_device_register("intel_powerclamp", NULL,\r\n&powerclamp_cooling_ops);\r\nif (IS_ERR(cooling_dev)) {\r\nretval = -ENODEV;\r\ngoto exit_free_thread;\r\n}\r\nif (!duration)\r\nduration = jiffies_to_msecs(DEFAULT_DURATION_JIFFIES);\r\npowerclamp_create_debug_files();\r\nreturn 0;\r\nexit_free_thread:\r\nfree_percpu(powerclamp_thread);\r\nexit_unregister:\r\nunregister_hotcpu_notifier(&powerclamp_cpu_notifier);\r\nexit_free:\r\nkfree(cpu_clamping_mask);\r\nreturn retval;\r\n}\r\nstatic void powerclamp_exit(void)\r\n{\r\nunregister_hotcpu_notifier(&powerclamp_cpu_notifier);\r\nend_power_clamp();\r\nfree_percpu(powerclamp_thread);\r\nthermal_cooling_device_unregister(cooling_dev);\r\nkfree(cpu_clamping_mask);\r\ncancel_delayed_work_sync(&poll_pkg_cstate_work);\r\ndebugfs_remove_recursive(debug_dir);\r\n}
