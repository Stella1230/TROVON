static void destroy_priv(struct kref *kref)\r\n{\r\nstruct parport_uss720_private *priv = container_of(kref, struct parport_uss720_private, ref_count);\r\ndev_dbg(&priv->usbdev->dev, "destroying priv datastructure\n");\r\nusb_put_dev(priv->usbdev);\r\nkfree(priv);\r\n}\r\nstatic void destroy_async(struct kref *kref)\r\n{\r\nstruct uss720_async_request *rq = container_of(kref, struct uss720_async_request, ref_count);\r\nstruct parport_uss720_private *priv = rq->priv;\r\nunsigned long flags;\r\nif (likely(rq->urb))\r\nusb_free_urb(rq->urb);\r\nkfree(rq->dr);\r\nspin_lock_irqsave(&priv->asynclock, flags);\r\nlist_del_init(&rq->asynclist);\r\nspin_unlock_irqrestore(&priv->asynclock, flags);\r\nkfree(rq);\r\nkref_put(&priv->ref_count, destroy_priv);\r\n}\r\nstatic void async_complete(struct urb *urb)\r\n{\r\nstruct uss720_async_request *rq;\r\nstruct parport *pp;\r\nstruct parport_uss720_private *priv;\r\nint status = urb->status;\r\nrq = urb->context;\r\npriv = rq->priv;\r\npp = priv->pp;\r\nif (status) {\r\ndev_err(&urb->dev->dev, "async_complete: urb error %d\n",\r\nstatus);\r\n} else if (rq->dr->bRequest == 3) {\r\nmemcpy(priv->reg, rq->reg, sizeof(priv->reg));\r\n#if 0\r\ndev_dbg(&priv->usbdev->dev,\r\n"async_complete regs %02x %02x %02x %02x %02x %02x %02x\n",\r\n(unsigned int)priv->reg[0], (unsigned int)priv->reg[1],\r\n(unsigned int)priv->reg[2], (unsigned int)priv->reg[3],\r\n(unsigned int)priv->reg[4], (unsigned int)priv->reg[5],\r\n(unsigned int)priv->reg[6]);\r\n#endif\r\nif (rq->reg[2] & rq->reg[1] & 0x10 && pp)\r\nparport_generic_irq(pp);\r\n}\r\ncomplete(&rq->compl);\r\nkref_put(&rq->ref_count, destroy_async);\r\n}\r\nstatic struct uss720_async_request *submit_async_request(struct parport_uss720_private *priv,\r\n__u8 request, __u8 requesttype, __u16 value, __u16 index,\r\ngfp_t mem_flags)\r\n{\r\nstruct usb_device *usbdev;\r\nstruct uss720_async_request *rq;\r\nunsigned long flags;\r\nint ret;\r\nif (!priv)\r\nreturn NULL;\r\nusbdev = priv->usbdev;\r\nif (!usbdev)\r\nreturn NULL;\r\nrq = kzalloc(sizeof(struct uss720_async_request), mem_flags);\r\nif (!rq) {\r\ndev_err(&usbdev->dev, "submit_async_request out of memory\n");\r\nreturn NULL;\r\n}\r\nkref_init(&rq->ref_count);\r\nINIT_LIST_HEAD(&rq->asynclist);\r\ninit_completion(&rq->compl);\r\nkref_get(&priv->ref_count);\r\nrq->priv = priv;\r\nrq->urb = usb_alloc_urb(0, mem_flags);\r\nif (!rq->urb) {\r\nkref_put(&rq->ref_count, destroy_async);\r\ndev_err(&usbdev->dev, "submit_async_request out of memory\n");\r\nreturn NULL;\r\n}\r\nrq->dr = kmalloc(sizeof(*rq->dr), mem_flags);\r\nif (!rq->dr) {\r\nkref_put(&rq->ref_count, destroy_async);\r\nreturn NULL;\r\n}\r\nrq->dr->bRequestType = requesttype;\r\nrq->dr->bRequest = request;\r\nrq->dr->wValue = cpu_to_le16(value);\r\nrq->dr->wIndex = cpu_to_le16(index);\r\nrq->dr->wLength = cpu_to_le16((request == 3) ? sizeof(rq->reg) : 0);\r\nusb_fill_control_urb(rq->urb, usbdev, (requesttype & 0x80) ? usb_rcvctrlpipe(usbdev, 0) : usb_sndctrlpipe(usbdev, 0),\r\n(unsigned char *)rq->dr,\r\n(request == 3) ? rq->reg : NULL, (request == 3) ? sizeof(rq->reg) : 0, async_complete, rq);\r\nspin_lock_irqsave(&priv->asynclock, flags);\r\nlist_add_tail(&rq->asynclist, &priv->asynclist);\r\nspin_unlock_irqrestore(&priv->asynclock, flags);\r\nkref_get(&rq->ref_count);\r\nret = usb_submit_urb(rq->urb, mem_flags);\r\nif (!ret)\r\nreturn rq;\r\ndestroy_async(&rq->ref_count);\r\ndev_err(&usbdev->dev, "submit_async_request submit_urb failed with %d\n", ret);\r\nreturn NULL;\r\n}\r\nstatic unsigned int kill_all_async_requests_priv(struct parport_uss720_private *priv)\r\n{\r\nstruct uss720_async_request *rq;\r\nunsigned long flags;\r\nunsigned int ret = 0;\r\nspin_lock_irqsave(&priv->asynclock, flags);\r\nlist_for_each_entry(rq, &priv->asynclist, asynclist) {\r\nusb_unlink_urb(rq->urb);\r\nret++;\r\n}\r\nspin_unlock_irqrestore(&priv->asynclock, flags);\r\nreturn ret;\r\n}\r\nstatic int get_1284_register(struct parport *pp, unsigned char reg, unsigned char *val, gfp_t mem_flags)\r\n{\r\nstruct parport_uss720_private *priv;\r\nstruct uss720_async_request *rq;\r\nstatic const unsigned char regindex[9] = {\r\n4, 0, 1, 5, 5, 0, 2, 3, 6\r\n};\r\nint ret;\r\nif (!pp)\r\nreturn -EIO;\r\npriv = pp->private_data;\r\nrq = submit_async_request(priv, 3, 0xc0, ((unsigned int)reg) << 8, 0, mem_flags);\r\nif (!rq) {\r\ndev_err(&priv->usbdev->dev, "get_1284_register(%u) failed",\r\n(unsigned int)reg);\r\nreturn -EIO;\r\n}\r\nif (!val) {\r\nkref_put(&rq->ref_count, destroy_async);\r\nreturn 0;\r\n}\r\nif (wait_for_completion_timeout(&rq->compl, HZ)) {\r\nret = rq->urb->status;\r\n*val = priv->reg[(reg >= 9) ? 0 : regindex[reg]];\r\nif (ret)\r\nprintk(KERN_WARNING "get_1284_register: "\r\n"usb error %d\n", ret);\r\nkref_put(&rq->ref_count, destroy_async);\r\nreturn ret;\r\n}\r\nprintk(KERN_WARNING "get_1284_register timeout\n");\r\nkill_all_async_requests_priv(priv);\r\nreturn -EIO;\r\n}\r\nstatic int set_1284_register(struct parport *pp, unsigned char reg, unsigned char val, gfp_t mem_flags)\r\n{\r\nstruct parport_uss720_private *priv;\r\nstruct uss720_async_request *rq;\r\nif (!pp)\r\nreturn -EIO;\r\npriv = pp->private_data;\r\nrq = submit_async_request(priv, 4, 0x40, (((unsigned int)reg) << 8) | val, 0, mem_flags);\r\nif (!rq) {\r\ndev_err(&priv->usbdev->dev, "set_1284_register(%u,%u) failed",\r\n(unsigned int)reg, (unsigned int)val);\r\nreturn -EIO;\r\n}\r\nkref_put(&rq->ref_count, destroy_async);\r\nreturn 0;\r\n}\r\nstatic int change_mode(struct parport *pp, int m)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nint mode;\r\n__u8 reg;\r\nif (get_1284_register(pp, 6, &reg, GFP_KERNEL))\r\nreturn -EIO;\r\nmode = (priv->reg[2] >> 5) & 0x7;\r\nif (mode == m)\r\nreturn 0;\r\nif (mode > ECR_PS2 && m > ECR_PS2)\r\nif (change_mode(pp, ECR_PS2))\r\nreturn -EIO;\r\nif (m <= ECR_PS2 && !(priv->reg[1] & 0x20)) {\r\nunsigned long expire = jiffies + pp->physport->cad->timeout;\r\nswitch (mode) {\r\ncase ECR_PPF:\r\ncase ECR_ECP:\r\nfor (;;) {\r\nif (get_1284_register(pp, 6, &reg, GFP_KERNEL))\r\nreturn -EIO;\r\nif (priv->reg[2] & 0x01)\r\nbreak;\r\nif (time_after_eq (jiffies, expire))\r\nreturn -EBUSY;\r\nmsleep_interruptible(10);\r\nif (signal_pending (current))\r\nbreak;\r\n}\r\n}\r\n}\r\nif (set_1284_register(pp, 6, m << 5, GFP_KERNEL))\r\nreturn -EIO;\r\nif (get_1284_register(pp, 6, &reg, GFP_KERNEL))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int clear_epp_timeout(struct parport *pp)\r\n{\r\nunsigned char stat;\r\nif (get_1284_register(pp, 1, &stat, GFP_KERNEL))\r\nreturn 1;\r\nreturn stat & 1;\r\n}\r\nstatic void parport_uss720_write_data(struct parport *pp, unsigned char d)\r\n{\r\nset_1284_register(pp, 0, d, GFP_KERNEL);\r\n}\r\nstatic unsigned char parport_uss720_read_data(struct parport *pp)\r\n{\r\nunsigned char ret;\r\nif (get_1284_register(pp, 0, &ret, GFP_KERNEL))\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic void parport_uss720_write_control(struct parport *pp, unsigned char d)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nd = (d & 0xf) | (priv->reg[1] & 0xf0);\r\nif (set_1284_register(pp, 2, d, GFP_KERNEL))\r\nreturn;\r\npriv->reg[1] = d;\r\n}\r\nstatic unsigned char parport_uss720_read_control(struct parport *pp)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nreturn priv->reg[1] & 0xf;\r\n}\r\nstatic unsigned char parport_uss720_frob_control(struct parport *pp, unsigned char mask, unsigned char val)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nunsigned char d;\r\nmask &= 0x0f;\r\nval &= 0x0f;\r\nd = (priv->reg[1] & (~mask)) ^ val;\r\nif (set_1284_register(pp, 2, d, GFP_KERNEL))\r\nreturn 0;\r\npriv->reg[1] = d;\r\nreturn d & 0xf;\r\n}\r\nstatic unsigned char parport_uss720_read_status(struct parport *pp)\r\n{\r\nunsigned char ret;\r\nif (get_1284_register(pp, 1, &ret, GFP_KERNEL))\r\nreturn 0;\r\nreturn ret & 0xf8;\r\n}\r\nstatic void parport_uss720_disable_irq(struct parport *pp)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nunsigned char d;\r\nd = priv->reg[1] & ~0x10;\r\nif (set_1284_register(pp, 2, d, GFP_KERNEL))\r\nreturn;\r\npriv->reg[1] = d;\r\n}\r\nstatic void parport_uss720_enable_irq(struct parport *pp)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nunsigned char d;\r\nd = priv->reg[1] | 0x10;\r\nif (set_1284_register(pp, 2, d, GFP_KERNEL))\r\nreturn;\r\npriv->reg[1] = d;\r\n}\r\nstatic void parport_uss720_data_forward (struct parport *pp)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nunsigned char d;\r\nd = priv->reg[1] & ~0x20;\r\nif (set_1284_register(pp, 2, d, GFP_KERNEL))\r\nreturn;\r\npriv->reg[1] = d;\r\n}\r\nstatic void parport_uss720_data_reverse (struct parport *pp)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nunsigned char d;\r\nd = priv->reg[1] | 0x20;\r\nif (set_1284_register(pp, 2, d, GFP_KERNEL))\r\nreturn;\r\npriv->reg[1] = d;\r\n}\r\nstatic void parport_uss720_init_state(struct pardevice *dev, struct parport_state *s)\r\n{\r\ns->u.pc.ctr = 0xc | (dev->irq_func ? 0x10 : 0x0);\r\ns->u.pc.ecr = 0x24;\r\n}\r\nstatic void parport_uss720_save_state(struct parport *pp, struct parport_state *s)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\n#if 0\r\nif (get_1284_register(pp, 2, NULL, GFP_ATOMIC))\r\nreturn;\r\n#endif\r\ns->u.pc.ctr = priv->reg[1];\r\ns->u.pc.ecr = priv->reg[2];\r\n}\r\nstatic void parport_uss720_restore_state(struct parport *pp, struct parport_state *s)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nset_1284_register(pp, 2, s->u.pc.ctr, GFP_ATOMIC);\r\nset_1284_register(pp, 6, s->u.pc.ecr, GFP_ATOMIC);\r\nget_1284_register(pp, 2, NULL, GFP_ATOMIC);\r\npriv->reg[1] = s->u.pc.ctr;\r\npriv->reg[2] = s->u.pc.ecr;\r\n}\r\nstatic size_t parport_uss720_epp_read_data(struct parport *pp, void *buf, size_t length, int flags)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nsize_t got = 0;\r\nif (change_mode(pp, ECR_EPP))\r\nreturn 0;\r\nfor (; got < length; got++) {\r\nif (get_1284_register(pp, 4, (char *)buf, GFP_KERNEL))\r\nbreak;\r\nbuf++;\r\nif (priv->reg[0] & 0x01) {\r\nclear_epp_timeout(pp);\r\nbreak;\r\n}\r\n}\r\nchange_mode(pp, ECR_PS2);\r\nreturn got;\r\n}\r\nstatic size_t parport_uss720_epp_write_data(struct parport *pp, const void *buf, size_t length, int flags)\r\n{\r\n#if 0\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nsize_t written = 0;\r\nif (change_mode(pp, ECR_EPP))\r\nreturn 0;\r\nfor (; written < length; written++) {\r\nif (set_1284_register(pp, 4, (char *)buf, GFP_KERNEL))\r\nbreak;\r\n((char*)buf)++;\r\nif (get_1284_register(pp, 1, NULL, GFP_KERNEL))\r\nbreak;\r\nif (priv->reg[0] & 0x01) {\r\nclear_epp_timeout(pp);\r\nbreak;\r\n}\r\n}\r\nchange_mode(pp, ECR_PS2);\r\nreturn written;\r\n#else\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nstruct usb_device *usbdev = priv->usbdev;\r\nint rlen;\r\nint i;\r\nif (!usbdev)\r\nreturn 0;\r\nif (change_mode(pp, ECR_EPP))\r\nreturn 0;\r\ni = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 1), (void *)buf, length, &rlen, 20000);\r\nif (i)\r\nprintk(KERN_ERR "uss720: sendbulk ep 1 buf %p len %Zu rlen %u\n", buf, length, rlen);\r\nchange_mode(pp, ECR_PS2);\r\nreturn rlen;\r\n#endif\r\n}\r\nstatic size_t parport_uss720_epp_read_addr(struct parport *pp, void *buf, size_t length, int flags)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nsize_t got = 0;\r\nif (change_mode(pp, ECR_EPP))\r\nreturn 0;\r\nfor (; got < length; got++) {\r\nif (get_1284_register(pp, 3, (char *)buf, GFP_KERNEL))\r\nbreak;\r\nbuf++;\r\nif (priv->reg[0] & 0x01) {\r\nclear_epp_timeout(pp);\r\nbreak;\r\n}\r\n}\r\nchange_mode(pp, ECR_PS2);\r\nreturn got;\r\n}\r\nstatic size_t parport_uss720_epp_write_addr(struct parport *pp, const void *buf, size_t length, int flags)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nsize_t written = 0;\r\nif (change_mode(pp, ECR_EPP))\r\nreturn 0;\r\nfor (; written < length; written++) {\r\nif (set_1284_register(pp, 3, *(char *)buf, GFP_KERNEL))\r\nbreak;\r\nbuf++;\r\nif (get_1284_register(pp, 1, NULL, GFP_KERNEL))\r\nbreak;\r\nif (priv->reg[0] & 0x01) {\r\nclear_epp_timeout(pp);\r\nbreak;\r\n}\r\n}\r\nchange_mode(pp, ECR_PS2);\r\nreturn written;\r\n}\r\nstatic size_t parport_uss720_ecp_write_data(struct parport *pp, const void *buffer, size_t len, int flags)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nstruct usb_device *usbdev = priv->usbdev;\r\nint rlen;\r\nint i;\r\nif (!usbdev)\r\nreturn 0;\r\nif (change_mode(pp, ECR_ECP))\r\nreturn 0;\r\ni = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 1), (void *)buffer, len, &rlen, 20000);\r\nif (i)\r\nprintk(KERN_ERR "uss720: sendbulk ep 1 buf %p len %Zu rlen %u\n", buffer, len, rlen);\r\nchange_mode(pp, ECR_PS2);\r\nreturn rlen;\r\n}\r\nstatic size_t parport_uss720_ecp_read_data(struct parport *pp, void *buffer, size_t len, int flags)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nstruct usb_device *usbdev = priv->usbdev;\r\nint rlen;\r\nint i;\r\nif (!usbdev)\r\nreturn 0;\r\nif (change_mode(pp, ECR_ECP))\r\nreturn 0;\r\ni = usb_bulk_msg(usbdev, usb_rcvbulkpipe(usbdev, 2), buffer, len, &rlen, 20000);\r\nif (i)\r\nprintk(KERN_ERR "uss720: recvbulk ep 2 buf %p len %Zu rlen %u\n", buffer, len, rlen);\r\nchange_mode(pp, ECR_PS2);\r\nreturn rlen;\r\n}\r\nstatic size_t parport_uss720_ecp_write_addr(struct parport *pp, const void *buffer, size_t len, int flags)\r\n{\r\nsize_t written = 0;\r\nif (change_mode(pp, ECR_ECP))\r\nreturn 0;\r\nfor (; written < len; written++) {\r\nif (set_1284_register(pp, 5, *(char *)buffer, GFP_KERNEL))\r\nbreak;\r\nbuffer++;\r\n}\r\nchange_mode(pp, ECR_PS2);\r\nreturn written;\r\n}\r\nstatic size_t parport_uss720_write_compat(struct parport *pp, const void *buffer, size_t len, int flags)\r\n{\r\nstruct parport_uss720_private *priv = pp->private_data;\r\nstruct usb_device *usbdev = priv->usbdev;\r\nint rlen;\r\nint i;\r\nif (!usbdev)\r\nreturn 0;\r\nif (change_mode(pp, ECR_PPF))\r\nreturn 0;\r\ni = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 1), (void *)buffer, len, &rlen, 20000);\r\nif (i)\r\nprintk(KERN_ERR "uss720: sendbulk ep 1 buf %p len %Zu rlen %u\n", buffer, len, rlen);\r\nchange_mode(pp, ECR_PS2);\r\nreturn rlen;\r\n}\r\nstatic int uss720_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev = usb_get_dev(interface_to_usbdev(intf));\r\nstruct usb_host_interface *interface;\r\nstruct usb_host_endpoint *endpoint;\r\nstruct parport_uss720_private *priv;\r\nstruct parport *pp;\r\nunsigned char reg;\r\nint i;\r\ndev_dbg(&intf->dev, "probe: vendor id 0x%x, device id 0x%x\n",\r\nle16_to_cpu(usbdev->descriptor.idVendor),\r\nle16_to_cpu(usbdev->descriptor.idProduct));\r\nif (intf->num_altsetting != 3) {\r\nusb_put_dev(usbdev);\r\nreturn -ENODEV;\r\n}\r\ni = usb_set_interface(usbdev, intf->altsetting->desc.bInterfaceNumber, 2);\r\ndev_dbg(&intf->dev, "set interface result %d\n", i);\r\ninterface = intf->cur_altsetting;\r\nif (!(priv = kzalloc(sizeof(struct parport_uss720_private), GFP_KERNEL))) {\r\nusb_put_dev(usbdev);\r\nreturn -ENOMEM;\r\n}\r\npriv->pp = NULL;\r\npriv->usbdev = usbdev;\r\nkref_init(&priv->ref_count);\r\nspin_lock_init(&priv->asynclock);\r\nINIT_LIST_HEAD(&priv->asynclist);\r\nif (!(pp = parport_register_port(0, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, &parport_uss720_ops))) {\r\nprintk(KERN_WARNING "uss720: could not register parport\n");\r\ngoto probe_abort;\r\n}\r\npriv->pp = pp;\r\npp->private_data = priv;\r\npp->modes = PARPORT_MODE_PCSPP | PARPORT_MODE_TRISTATE | PARPORT_MODE_EPP | PARPORT_MODE_ECP | PARPORT_MODE_COMPAT;\r\nset_1284_register(pp, 7, 0x00, GFP_KERNEL);\r\nset_1284_register(pp, 6, 0x30, GFP_KERNEL);\r\nset_1284_register(pp, 2, 0x0c, GFP_KERNEL);\r\nget_1284_register(pp, 0, &reg, GFP_KERNEL);\r\ndev_dbg(&intf->dev, "reg: %02x %02x %02x %02x %02x %02x %02x\n",\r\npriv->reg[0], priv->reg[1], priv->reg[2], priv->reg[3],\r\npriv->reg[4], priv->reg[5], priv->reg[6]);\r\nendpoint = &interface->endpoint[2];\r\ndev_dbg(&intf->dev, "epaddr %d interval %d\n",\r\nendpoint->desc.bEndpointAddress, endpoint->desc.bInterval);\r\nparport_announce_port(pp);\r\nusb_set_intfdata(intf, pp);\r\nreturn 0;\r\nprobe_abort:\r\nkill_all_async_requests_priv(priv);\r\nkref_put(&priv->ref_count, destroy_priv);\r\nreturn -ENODEV;\r\n}\r\nstatic void uss720_disconnect(struct usb_interface *intf)\r\n{\r\nstruct parport *pp = usb_get_intfdata(intf);\r\nstruct parport_uss720_private *priv;\r\nstruct usb_device *usbdev;\r\ndev_dbg(&intf->dev, "disconnect\n");\r\nusb_set_intfdata(intf, NULL);\r\nif (pp) {\r\npriv = pp->private_data;\r\nusbdev = priv->usbdev;\r\npriv->usbdev = NULL;\r\npriv->pp = NULL;\r\ndev_dbg(&intf->dev, "parport_remove_port\n");\r\nparport_remove_port(pp);\r\nparport_put_port(pp);\r\nkill_all_async_requests_priv(priv);\r\nkref_put(&priv->ref_count, destroy_priv);\r\n}\r\ndev_dbg(&intf->dev, "disconnect done\n");\r\n}\r\nstatic int __init uss720_init(void)\r\n{\r\nint retval;\r\nretval = usb_register(&uss720_driver);\r\nif (retval)\r\ngoto out;\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"\r\nDRIVER_DESC "\n");\r\nprintk(KERN_INFO KBUILD_MODNAME ": NOTE: this is a special purpose "\r\n"driver to allow nonstandard\n");\r\nprintk(KERN_INFO KBUILD_MODNAME ": protocols (eg. bitbang) over "\r\n"USS720 usb to parallel cables\n");\r\nprintk(KERN_INFO KBUILD_MODNAME ": If you just want to connect to a "\r\n"printer, use usblp instead\n");\r\nout:\r\nreturn retval;\r\n}\r\nstatic void __exit uss720_cleanup(void)\r\n{\r\nusb_deregister(&uss720_driver);\r\n}
