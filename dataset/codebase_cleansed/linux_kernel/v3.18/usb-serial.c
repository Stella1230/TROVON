struct usb_serial_port *usb_serial_port_get_by_minor(unsigned minor)\r\n{\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nmutex_lock(&table_lock);\r\nport = idr_find(&serial_minors, minor);\r\nif (!port)\r\ngoto exit;\r\nserial = port->serial;\r\nmutex_lock(&serial->disc_mutex);\r\nif (serial->disconnected) {\r\nmutex_unlock(&serial->disc_mutex);\r\nport = NULL;\r\n} else {\r\nkref_get(&serial->kref);\r\n}\r\nexit:\r\nmutex_unlock(&table_lock);\r\nreturn port;\r\n}\r\nstatic int allocate_minors(struct usb_serial *serial, int num_ports)\r\n{\r\nstruct usb_serial_port *port;\r\nunsigned int i, j;\r\nint minor;\r\ndev_dbg(&serial->interface->dev, "%s %d\n", __func__, num_ports);\r\nmutex_lock(&table_lock);\r\nfor (i = 0; i < num_ports; ++i) {\r\nport = serial->port[i];\r\nminor = idr_alloc(&serial_minors, port, 0, 0, GFP_KERNEL);\r\nif (minor < 0)\r\ngoto error;\r\nport->minor = minor;\r\nport->port_number = i;\r\n}\r\nserial->minors_reserved = 1;\r\nmutex_unlock(&table_lock);\r\nreturn 0;\r\nerror:\r\nfor (j = 0; j < i; ++j)\r\nidr_remove(&serial_minors, serial->port[j]->minor);\r\nmutex_unlock(&table_lock);\r\nreturn minor;\r\n}\r\nstatic void release_minors(struct usb_serial *serial)\r\n{\r\nint i;\r\nmutex_lock(&table_lock);\r\nfor (i = 0; i < serial->num_ports; ++i)\r\nidr_remove(&serial_minors, serial->port[i]->minor);\r\nmutex_unlock(&table_lock);\r\nserial->minors_reserved = 0;\r\n}\r\nstatic void destroy_serial(struct kref *kref)\r\n{\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nint i;\r\nserial = to_usb_serial(kref);\r\nif (serial->minors_reserved)\r\nrelease_minors(serial);\r\nif (serial->attached && serial->type->release)\r\nserial->type->release(serial);\r\nfor (i = 0; i < serial->num_port_pointers; ++i) {\r\nport = serial->port[i];\r\nif (port) {\r\nport->serial = NULL;\r\nput_device(&port->dev);\r\n}\r\n}\r\nusb_put_intf(serial->interface);\r\nusb_put_dev(serial->dev);\r\nkfree(serial);\r\n}\r\nvoid usb_serial_put(struct usb_serial *serial)\r\n{\r\nkref_put(&serial->kref, destroy_serial);\r\n}\r\nstatic int serial_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nint idx = tty->index;\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nint retval = -ENODEV;\r\nport = usb_serial_port_get_by_minor(idx);\r\nif (!port)\r\nreturn retval;\r\nserial = port->serial;\r\nif (!try_module_get(serial->type->driver.owner))\r\ngoto error_module_get;\r\nretval = usb_autopm_get_interface(serial->interface);\r\nif (retval)\r\ngoto error_get_interface;\r\nretval = tty_port_install(&port->port, driver, tty);\r\nif (retval)\r\ngoto error_init_termios;\r\nmutex_unlock(&serial->disc_mutex);\r\nif (serial->type->init_termios)\r\nserial->type->init_termios(tty);\r\ntty->driver_data = port;\r\nreturn retval;\r\nerror_init_termios:\r\nusb_autopm_put_interface(serial->interface);\r\nerror_get_interface:\r\nmodule_put(serial->type->driver.owner);\r\nerror_module_get:\r\nusb_serial_put(serial);\r\nmutex_unlock(&serial->disc_mutex);\r\nreturn retval;\r\n}\r\nstatic int serial_port_activate(struct tty_port *tport, struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port =\r\ncontainer_of(tport, struct usb_serial_port, port);\r\nstruct usb_serial *serial = port->serial;\r\nint retval;\r\nmutex_lock(&serial->disc_mutex);\r\nif (serial->disconnected)\r\nretval = -ENODEV;\r\nelse\r\nretval = port->serial->type->open(tty, port);\r\nmutex_unlock(&serial->disc_mutex);\r\nif (retval < 0)\r\nretval = usb_translate_errors(retval);\r\nreturn retval;\r\n}\r\nstatic int serial_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nreturn tty_port_open(&port->port, tty, filp);\r\n}\r\nstatic void serial_port_shutdown(struct tty_port *tport)\r\n{\r\nstruct usb_serial_port *port =\r\ncontainer_of(tport, struct usb_serial_port, port);\r\nstruct usb_serial_driver *drv = port->serial->type;\r\nif (drv->close)\r\ndrv->close(port);\r\n}\r\nstatic void serial_hangup(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\ntty_port_hangup(&port->port);\r\n}\r\nstatic void serial_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\ntty_port_close(&port->port, tty, filp);\r\n}\r\nstatic void serial_cleanup(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial;\r\nstruct module *owner;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (port->port.console)\r\nreturn;\r\ntty->driver_data = NULL;\r\nserial = port->serial;\r\nowner = serial->type->driver.owner;\r\nmutex_lock(&serial->disc_mutex);\r\nif (!serial->disconnected)\r\nusb_autopm_put_interface(serial->interface);\r\nmutex_unlock(&serial->disc_mutex);\r\nusb_serial_put(serial);\r\nmodule_put(owner);\r\n}\r\nstatic int serial_write(struct tty_struct *tty, const unsigned char *buf,\r\nint count)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint retval = -ENODEV;\r\nif (port->serial->dev->state == USB_STATE_NOTATTACHED)\r\ngoto exit;\r\ndev_dbg(tty->dev, "%s - %d byte(s)\n", __func__, count);\r\nretval = port->serial->type->write(tty, port, buf, count);\r\nif (retval < 0)\r\nretval = usb_translate_errors(retval);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int serial_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nreturn port->serial->type->write_room(tty);\r\n}\r\nstatic int serial_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (serial->disconnected)\r\nreturn 0;\r\nreturn serial->type->chars_in_buffer(tty);\r\n}\r\nstatic void serial_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (!port->serial->type->wait_until_sent)\r\nreturn;\r\nmutex_lock(&serial->disc_mutex);\r\nif (!serial->disconnected)\r\nport->serial->type->wait_until_sent(tty, timeout);\r\nmutex_unlock(&serial->disc_mutex);\r\n}\r\nstatic void serial_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (port->serial->type->throttle)\r\nport->serial->type->throttle(tty);\r\n}\r\nstatic void serial_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (port->serial->type->unthrottle)\r\nport->serial->type->unthrottle(tty);\r\n}\r\nstatic int serial_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint retval = -ENOIOCTLCMD;\r\ndev_dbg(tty->dev, "%s - cmd 0x%04x\n", __func__, cmd);\r\nswitch (cmd) {\r\ncase TIOCMIWAIT:\r\nif (port->serial->type->tiocmiwait)\r\nretval = port->serial->type->tiocmiwait(tty, arg);\r\nbreak;\r\ndefault:\r\nif (port->serial->type->ioctl)\r\nretval = port->serial->type->ioctl(tty, cmd, arg);\r\n}\r\nreturn retval;\r\n}\r\nstatic void serial_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (port->serial->type->set_termios)\r\nport->serial->type->set_termios(tty, port, old);\r\nelse\r\ntty_termios_copy_hw(&tty->termios, old);\r\n}\r\nstatic int serial_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (port->serial->type->break_ctl)\r\nport->serial->type->break_ctl(tty, break_state);\r\nreturn 0;\r\n}\r\nstatic int serial_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct usb_serial *serial;\r\nstruct usb_serial_port *port;\r\nint i;\r\nchar tmp[40];\r\nseq_puts(m, "usbserinfo:1.0 driver:2.0\n");\r\nfor (i = 0; i < USB_SERIAL_TTY_MINORS; ++i) {\r\nport = usb_serial_port_get_by_minor(i);\r\nif (port == NULL)\r\ncontinue;\r\nserial = port->serial;\r\nseq_printf(m, "%d:", i);\r\nif (serial->type->driver.owner)\r\nseq_printf(m, " module:%s",\r\nmodule_name(serial->type->driver.owner));\r\nseq_printf(m, " name:\"%s\"",\r\nserial->type->description);\r\nseq_printf(m, " vendor:%04x product:%04x",\r\nle16_to_cpu(serial->dev->descriptor.idVendor),\r\nle16_to_cpu(serial->dev->descriptor.idProduct));\r\nseq_printf(m, " num_ports:%d", serial->num_ports);\r\nseq_printf(m, " port:%d", port->port_number);\r\nusb_make_path(serial->dev, tmp, sizeof(tmp));\r\nseq_printf(m, " path:%s", tmp);\r\nseq_putc(m, '\n');\r\nusb_serial_put(serial);\r\nmutex_unlock(&serial->disc_mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, serial_proc_show, NULL);\r\n}\r\nstatic int serial_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (port->serial->type->tiocmget)\r\nreturn port->serial->type->tiocmget(tty);\r\nreturn -EINVAL;\r\n}\r\nstatic int serial_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (port->serial->type->tiocmset)\r\nreturn port->serial->type->tiocmset(tty, set, clear);\r\nreturn -EINVAL;\r\n}\r\nstatic int serial_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nif (port->serial->type->get_icount)\r\nreturn port->serial->type->get_icount(tty, icount);\r\nreturn -EINVAL;\r\n}\r\nvoid usb_serial_port_softint(struct usb_serial_port *port)\r\n{\r\nschedule_work(&port->work);\r\n}\r\nstatic void usb_serial_port_work(struct work_struct *work)\r\n{\r\nstruct usb_serial_port *port =\r\ncontainer_of(work, struct usb_serial_port, work);\r\ntty_port_tty_wakeup(&port->port);\r\n}\r\nstatic void usb_serial_port_poison_urbs(struct usb_serial_port *port)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i)\r\nusb_poison_urb(port->read_urbs[i]);\r\nfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i)\r\nusb_poison_urb(port->write_urbs[i]);\r\nusb_poison_urb(port->interrupt_in_urb);\r\nusb_poison_urb(port->interrupt_out_urb);\r\n}\r\nstatic void usb_serial_port_unpoison_urbs(struct usb_serial_port *port)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i)\r\nusb_unpoison_urb(port->read_urbs[i]);\r\nfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i)\r\nusb_unpoison_urb(port->write_urbs[i]);\r\nusb_unpoison_urb(port->interrupt_in_urb);\r\nusb_unpoison_urb(port->interrupt_out_urb);\r\n}\r\nstatic void usb_serial_port_release(struct device *dev)\r\n{\r\nstruct usb_serial_port *port = to_usb_serial_port(dev);\r\nint i;\r\ndev_dbg(dev, "%s\n", __func__);\r\nusb_free_urb(port->interrupt_in_urb);\r\nusb_free_urb(port->interrupt_out_urb);\r\nfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i) {\r\nusb_free_urb(port->read_urbs[i]);\r\nkfree(port->bulk_in_buffers[i]);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i) {\r\nusb_free_urb(port->write_urbs[i]);\r\nkfree(port->bulk_out_buffers[i]);\r\n}\r\nkfifo_free(&port->write_fifo);\r\nkfree(port->interrupt_in_buffer);\r\nkfree(port->interrupt_out_buffer);\r\ntty_port_destroy(&port->port);\r\nkfree(port);\r\n}\r\nstatic struct usb_serial *create_serial(struct usb_device *dev,\r\nstruct usb_interface *interface,\r\nstruct usb_serial_driver *driver)\r\n{\r\nstruct usb_serial *serial;\r\nserial = kzalloc(sizeof(*serial), GFP_KERNEL);\r\nif (!serial)\r\nreturn NULL;\r\nserial->dev = usb_get_dev(dev);\r\nserial->type = driver;\r\nserial->interface = usb_get_intf(interface);\r\nkref_init(&serial->kref);\r\nmutex_init(&serial->disc_mutex);\r\nserial->minors_reserved = 0;\r\nreturn serial;\r\n}\r\nstatic const struct usb_device_id *match_dynamic_id(struct usb_interface *intf,\r\nstruct usb_serial_driver *drv)\r\n{\r\nstruct usb_dynid *dynid;\r\nspin_lock(&drv->dynids.lock);\r\nlist_for_each_entry(dynid, &drv->dynids.list, node) {\r\nif (usb_match_one_id(intf, &dynid->id)) {\r\nspin_unlock(&drv->dynids.lock);\r\nreturn &dynid->id;\r\n}\r\n}\r\nspin_unlock(&drv->dynids.lock);\r\nreturn NULL;\r\n}\r\nstatic const struct usb_device_id *get_iface_id(struct usb_serial_driver *drv,\r\nstruct usb_interface *intf)\r\n{\r\nconst struct usb_device_id *id;\r\nid = usb_match_id(intf, drv->id_table);\r\nif (id) {\r\ndev_dbg(&intf->dev, "static descriptor matches\n");\r\ngoto exit;\r\n}\r\nid = match_dynamic_id(intf, drv);\r\nif (id)\r\ndev_dbg(&intf->dev, "dynamic descriptor matches\n");\r\nexit:\r\nreturn id;\r\n}\r\nstatic struct usb_serial_driver *search_serial_device(\r\nstruct usb_interface *iface)\r\n{\r\nconst struct usb_device_id *id = NULL;\r\nstruct usb_serial_driver *drv;\r\nstruct usb_driver *driver = to_usb_driver(iface->dev.driver);\r\nlist_for_each_entry(drv, &usb_serial_driver_list, driver_list) {\r\nif (drv->usb_driver == driver)\r\nid = get_iface_id(drv, iface);\r\nif (id)\r\nreturn drv;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int serial_port_carrier_raised(struct tty_port *port)\r\n{\r\nstruct usb_serial_port *p = container_of(port, struct usb_serial_port, port);\r\nstruct usb_serial_driver *drv = p->serial->type;\r\nif (drv->carrier_raised)\r\nreturn drv->carrier_raised(p);\r\nreturn 1;\r\n}\r\nstatic void serial_port_dtr_rts(struct tty_port *port, int on)\r\n{\r\nstruct usb_serial_port *p = container_of(port, struct usb_serial_port, port);\r\nstruct usb_serial_driver *drv = p->serial->type;\r\nif (drv->dtr_rts)\r\ndrv->dtr_rts(p, on);\r\n}\r\nstatic int usb_serial_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct device *ddev = &interface->dev;\r\nstruct usb_device *dev = interface_to_usbdev(interface);\r\nstruct usb_serial *serial = NULL;\r\nstruct usb_serial_port *port;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_endpoint_descriptor *interrupt_in_endpoint[MAX_NUM_PORTS];\r\nstruct usb_endpoint_descriptor *interrupt_out_endpoint[MAX_NUM_PORTS];\r\nstruct usb_endpoint_descriptor *bulk_in_endpoint[MAX_NUM_PORTS];\r\nstruct usb_endpoint_descriptor *bulk_out_endpoint[MAX_NUM_PORTS];\r\nstruct usb_serial_driver *type = NULL;\r\nint retval;\r\nint buffer_size;\r\nint i;\r\nint j;\r\nint num_interrupt_in = 0;\r\nint num_interrupt_out = 0;\r\nint num_bulk_in = 0;\r\nint num_bulk_out = 0;\r\nint num_ports = 0;\r\nint max_endpoints;\r\nmutex_lock(&table_lock);\r\ntype = search_serial_device(interface);\r\nif (!type) {\r\nmutex_unlock(&table_lock);\r\ndev_dbg(ddev, "none matched\n");\r\nreturn -ENODEV;\r\n}\r\nif (!try_module_get(type->driver.owner)) {\r\nmutex_unlock(&table_lock);\r\ndev_err(ddev, "module get failed, exiting\n");\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&table_lock);\r\nserial = create_serial(dev, interface, type);\r\nif (!serial) {\r\nmodule_put(type->driver.owner);\r\nreturn -ENOMEM;\r\n}\r\nif (type->probe) {\r\nconst struct usb_device_id *id;\r\nid = get_iface_id(type, interface);\r\nretval = type->probe(serial, id);\r\nif (retval) {\r\ndev_dbg(ddev, "sub driver rejected device\n");\r\nusb_serial_put(serial);\r\nmodule_put(type->driver.owner);\r\nreturn retval;\r\n}\r\n}\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_bulk_in(endpoint)) {\r\ndev_dbg(ddev, "found bulk in on endpoint %d\n", i);\r\nif (num_bulk_in < MAX_NUM_PORTS) {\r\nbulk_in_endpoint[num_bulk_in] = endpoint;\r\n++num_bulk_in;\r\n}\r\n}\r\nif (usb_endpoint_is_bulk_out(endpoint)) {\r\ndev_dbg(ddev, "found bulk out on endpoint %d\n", i);\r\nif (num_bulk_out < MAX_NUM_PORTS) {\r\nbulk_out_endpoint[num_bulk_out] = endpoint;\r\n++num_bulk_out;\r\n}\r\n}\r\nif (usb_endpoint_is_int_in(endpoint)) {\r\ndev_dbg(ddev, "found interrupt in on endpoint %d\n", i);\r\nif (num_interrupt_in < MAX_NUM_PORTS) {\r\ninterrupt_in_endpoint[num_interrupt_in] =\r\nendpoint;\r\n++num_interrupt_in;\r\n}\r\n}\r\nif (usb_endpoint_is_int_out(endpoint)) {\r\ndev_dbg(ddev, "found interrupt out on endpoint %d\n", i);\r\nif (num_interrupt_out < MAX_NUM_PORTS) {\r\ninterrupt_out_endpoint[num_interrupt_out] =\r\nendpoint;\r\n++num_interrupt_out;\r\n}\r\n}\r\n}\r\n#if defined(CONFIG_USB_SERIAL_PL2303) || defined(CONFIG_USB_SERIAL_PL2303_MODULE)\r\nif (((le16_to_cpu(dev->descriptor.idVendor) == PL2303_VENDOR_ID) &&\r\n(le16_to_cpu(dev->descriptor.idProduct) == PL2303_PRODUCT_ID)) ||\r\n((le16_to_cpu(dev->descriptor.idVendor) == ATEN_VENDOR_ID) &&\r\n(le16_to_cpu(dev->descriptor.idProduct) == ATEN_PRODUCT_ID)) ||\r\n((le16_to_cpu(dev->descriptor.idVendor) == ALCOR_VENDOR_ID) &&\r\n(le16_to_cpu(dev->descriptor.idProduct) == ALCOR_PRODUCT_ID)) ||\r\n((le16_to_cpu(dev->descriptor.idVendor) == SIEMENS_VENDOR_ID) &&\r\n(le16_to_cpu(dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_EF81))) {\r\nif (interface != dev->actconfig->interface[0]) {\r\niface_desc = dev->actconfig->interface[0]->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint)) {\r\ndev_dbg(ddev, "found interrupt in for Prolific device on separate interface\n");\r\nif (num_interrupt_in < MAX_NUM_PORTS) {\r\ninterrupt_in_endpoint[num_interrupt_in] = endpoint;\r\n++num_interrupt_in;\r\n}\r\n}\r\n}\r\n}\r\nif (num_bulk_in == 0 || num_bulk_out == 0) {\r\ndev_info(ddev, "PL-2303 hack: descriptors matched but endpoints did not\n");\r\nusb_serial_put(serial);\r\nmodule_put(type->driver.owner);\r\nreturn -ENODEV;\r\n}\r\n}\r\n#endif\r\n#ifdef CONFIG_USB_SERIAL_GENERIC\r\nif (type == &usb_serial_generic_device) {\r\nnum_ports = num_bulk_out;\r\nif (num_ports == 0) {\r\ndev_err(ddev, "Generic device with no bulk out, not allowed.\n");\r\nusb_serial_put(serial);\r\nmodule_put(type->driver.owner);\r\nreturn -EIO;\r\n}\r\ndev_info(ddev, "The \"generic\" usb-serial driver is only for testing and one-off prototypes.\n");\r\ndev_info(ddev, "Tell linux-usb@vger.kernel.org to add your device to a proper driver.\n");\r\n}\r\n#endif\r\nif (!num_ports) {\r\nif (type->calc_num_ports)\r\nnum_ports = type->calc_num_ports(serial);\r\nif (!num_ports)\r\nnum_ports = type->num_ports;\r\n}\r\nif (num_ports > MAX_NUM_PORTS) {\r\ndev_warn(ddev, "too many ports requested: %d\n", num_ports);\r\nnum_ports = MAX_NUM_PORTS;\r\n}\r\nserial->num_ports = num_ports;\r\nserial->num_bulk_in = num_bulk_in;\r\nserial->num_bulk_out = num_bulk_out;\r\nserial->num_interrupt_in = num_interrupt_in;\r\nserial->num_interrupt_out = num_interrupt_out;\r\ndev_info(ddev, "%s converter detected\n", type->description);\r\nmax_endpoints = max(num_bulk_in, num_bulk_out);\r\nmax_endpoints = max(max_endpoints, num_interrupt_in);\r\nmax_endpoints = max(max_endpoints, num_interrupt_out);\r\nmax_endpoints = max(max_endpoints, (int)serial->num_ports);\r\nserial->num_port_pointers = max_endpoints;\r\ndev_dbg(ddev, "setting up %d port structure(s)\n", max_endpoints);\r\nfor (i = 0; i < max_endpoints; ++i) {\r\nport = kzalloc(sizeof(struct usb_serial_port), GFP_KERNEL);\r\nif (!port)\r\ngoto probe_error;\r\ntty_port_init(&port->port);\r\nport->port.ops = &serial_port_ops;\r\nport->serial = serial;\r\nspin_lock_init(&port->lock);\r\nINIT_WORK(&port->work, usb_serial_port_work);\r\nserial->port[i] = port;\r\nport->dev.parent = &interface->dev;\r\nport->dev.driver = NULL;\r\nport->dev.bus = &usb_serial_bus_type;\r\nport->dev.release = &usb_serial_port_release;\r\ndevice_initialize(&port->dev);\r\n}\r\nfor (i = 0; i < num_bulk_in; ++i) {\r\nendpoint = bulk_in_endpoint[i];\r\nport = serial->port[i];\r\nbuffer_size = max_t(int, serial->type->bulk_in_size,\r\nusb_endpoint_maxp(endpoint));\r\nport->bulk_in_size = buffer_size;\r\nport->bulk_in_endpointAddress = endpoint->bEndpointAddress;\r\nfor (j = 0; j < ARRAY_SIZE(port->read_urbs); ++j) {\r\nset_bit(j, &port->read_urbs_free);\r\nport->read_urbs[j] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!port->read_urbs[j])\r\ngoto probe_error;\r\nport->bulk_in_buffers[j] = kmalloc(buffer_size,\r\nGFP_KERNEL);\r\nif (!port->bulk_in_buffers[j])\r\ngoto probe_error;\r\nusb_fill_bulk_urb(port->read_urbs[j], dev,\r\nusb_rcvbulkpipe(dev,\r\nendpoint->bEndpointAddress),\r\nport->bulk_in_buffers[j], buffer_size,\r\nserial->type->read_bulk_callback,\r\nport);\r\n}\r\nport->read_urb = port->read_urbs[0];\r\nport->bulk_in_buffer = port->bulk_in_buffers[0];\r\n}\r\nfor (i = 0; i < num_bulk_out; ++i) {\r\nendpoint = bulk_out_endpoint[i];\r\nport = serial->port[i];\r\nif (kfifo_alloc(&port->write_fifo, PAGE_SIZE, GFP_KERNEL))\r\ngoto probe_error;\r\nbuffer_size = max_t(int, serial->type->bulk_out_size,\r\nusb_endpoint_maxp(endpoint));\r\nport->bulk_out_size = buffer_size;\r\nport->bulk_out_endpointAddress = endpoint->bEndpointAddress;\r\nfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j) {\r\nset_bit(j, &port->write_urbs_free);\r\nport->write_urbs[j] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!port->write_urbs[j])\r\ngoto probe_error;\r\nport->bulk_out_buffers[j] = kmalloc(buffer_size,\r\nGFP_KERNEL);\r\nif (!port->bulk_out_buffers[j])\r\ngoto probe_error;\r\nusb_fill_bulk_urb(port->write_urbs[j], dev,\r\nusb_sndbulkpipe(dev,\r\nendpoint->bEndpointAddress),\r\nport->bulk_out_buffers[j], buffer_size,\r\nserial->type->write_bulk_callback,\r\nport);\r\n}\r\nport->write_urb = port->write_urbs[0];\r\nport->bulk_out_buffer = port->bulk_out_buffers[0];\r\n}\r\nif (serial->type->read_int_callback) {\r\nfor (i = 0; i < num_interrupt_in; ++i) {\r\nendpoint = interrupt_in_endpoint[i];\r\nport = serial->port[i];\r\nport->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!port->interrupt_in_urb)\r\ngoto probe_error;\r\nbuffer_size = usb_endpoint_maxp(endpoint);\r\nport->interrupt_in_endpointAddress =\r\nendpoint->bEndpointAddress;\r\nport->interrupt_in_buffer = kmalloc(buffer_size,\r\nGFP_KERNEL);\r\nif (!port->interrupt_in_buffer)\r\ngoto probe_error;\r\nusb_fill_int_urb(port->interrupt_in_urb, dev,\r\nusb_rcvintpipe(dev,\r\nendpoint->bEndpointAddress),\r\nport->interrupt_in_buffer, buffer_size,\r\nserial->type->read_int_callback, port,\r\nendpoint->bInterval);\r\n}\r\n} else if (num_interrupt_in) {\r\ndev_dbg(ddev, "The device claims to support interrupt in transfers, but read_int_callback is not defined\n");\r\n}\r\nif (serial->type->write_int_callback) {\r\nfor (i = 0; i < num_interrupt_out; ++i) {\r\nendpoint = interrupt_out_endpoint[i];\r\nport = serial->port[i];\r\nport->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!port->interrupt_out_urb)\r\ngoto probe_error;\r\nbuffer_size = usb_endpoint_maxp(endpoint);\r\nport->interrupt_out_size = buffer_size;\r\nport->interrupt_out_endpointAddress =\r\nendpoint->bEndpointAddress;\r\nport->interrupt_out_buffer = kmalloc(buffer_size,\r\nGFP_KERNEL);\r\nif (!port->interrupt_out_buffer)\r\ngoto probe_error;\r\nusb_fill_int_urb(port->interrupt_out_urb, dev,\r\nusb_sndintpipe(dev,\r\nendpoint->bEndpointAddress),\r\nport->interrupt_out_buffer, buffer_size,\r\nserial->type->write_int_callback, port,\r\nendpoint->bInterval);\r\n}\r\n} else if (num_interrupt_out) {\r\ndev_dbg(ddev, "The device claims to support interrupt out transfers, but write_int_callback is not defined\n");\r\n}\r\nusb_set_intfdata(interface, serial);\r\nif (type->attach) {\r\nretval = type->attach(serial);\r\nif (retval < 0)\r\ngoto probe_error;\r\nserial->attached = 1;\r\nif (retval > 0) {\r\nserial->num_ports = 0;\r\ngoto exit;\r\n}\r\n} else {\r\nserial->attached = 1;\r\n}\r\nserial->disconnected = 1;\r\nif (allocate_minors(serial, num_ports)) {\r\ndev_err(ddev, "No more free serial minor numbers\n");\r\ngoto probe_error;\r\n}\r\nfor (i = 0; i < num_ports; ++i) {\r\nport = serial->port[i];\r\ndev_set_name(&port->dev, "ttyUSB%d", port->minor);\r\ndev_dbg(ddev, "registering %s\n", dev_name(&port->dev));\r\ndevice_enable_async_suspend(&port->dev);\r\nretval = device_add(&port->dev);\r\nif (retval)\r\ndev_err(ddev, "Error registering port device, continuing\n");\r\n}\r\nserial->disconnected = 0;\r\nusb_serial_console_init(serial->port[0]->minor);\r\nexit:\r\nmodule_put(type->driver.owner);\r\nreturn 0;\r\nprobe_error:\r\nusb_serial_put(serial);\r\nmodule_put(type->driver.owner);\r\nreturn -EIO;\r\n}\r\nstatic void usb_serial_disconnect(struct usb_interface *interface)\r\n{\r\nint i;\r\nstruct usb_serial *serial = usb_get_intfdata(interface);\r\nstruct device *dev = &interface->dev;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nusb_serial_console_disconnect(serial);\r\nmutex_lock(&serial->disc_mutex);\r\nserial->disconnected = 1;\r\nmutex_unlock(&serial->disc_mutex);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nusb_serial_port_poison_urbs(port);\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\ncancel_work_sync(&port->work);\r\nif (device_is_registered(&port->dev))\r\ndevice_del(&port->dev);\r\n}\r\nif (serial->type->disconnect)\r\nserial->type->disconnect(serial);\r\nusb_serial_put(serial);\r\ndev_info(dev, "device disconnected\n");\r\n}\r\nint usb_serial_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usb_serial *serial = usb_get_intfdata(intf);\r\nint i, r = 0;\r\nserial->suspending = 1;\r\nif (serial->type->suspend) {\r\nr = serial->type->suspend(serial, message);\r\nif (r < 0) {\r\nserial->suspending = 0;\r\ngoto err_out;\r\n}\r\n}\r\nfor (i = 0; i < serial->num_ports; ++i)\r\nusb_serial_port_poison_urbs(serial->port[i]);\r\nerr_out:\r\nreturn r;\r\n}\r\nstatic void usb_serial_unpoison_port_urbs(struct usb_serial *serial)\r\n{\r\nint i;\r\nfor (i = 0; i < serial->num_ports; ++i)\r\nusb_serial_port_unpoison_urbs(serial->port[i]);\r\n}\r\nint usb_serial_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_serial *serial = usb_get_intfdata(intf);\r\nint rv;\r\nusb_serial_unpoison_port_urbs(serial);\r\nserial->suspending = 0;\r\nif (serial->type->resume)\r\nrv = serial->type->resume(serial);\r\nelse\r\nrv = usb_serial_generic_resume(serial);\r\nreturn rv;\r\n}\r\nstatic int usb_serial_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct usb_serial *serial = usb_get_intfdata(intf);\r\nint rv;\r\nusb_serial_unpoison_port_urbs(serial);\r\nserial->suspending = 0;\r\nif (serial->type->reset_resume) {\r\nrv = serial->type->reset_resume(serial);\r\n} else {\r\nrv = -EOPNOTSUPP;\r\nintf->needs_binding = 1;\r\n}\r\nreturn rv;\r\n}\r\nstatic int __init usb_serial_init(void)\r\n{\r\nint result;\r\nusb_serial_tty_driver = alloc_tty_driver(USB_SERIAL_TTY_MINORS);\r\nif (!usb_serial_tty_driver)\r\nreturn -ENOMEM;\r\nresult = bus_register(&usb_serial_bus_type);\r\nif (result) {\r\npr_err("%s - registering bus driver failed\n", __func__);\r\ngoto exit_bus;\r\n}\r\nusb_serial_tty_driver->driver_name = "usbserial";\r\nusb_serial_tty_driver->name = "ttyUSB";\r\nusb_serial_tty_driver->major = USB_SERIAL_TTY_MAJOR;\r\nusb_serial_tty_driver->minor_start = 0;\r\nusb_serial_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nusb_serial_tty_driver->subtype = SERIAL_TYPE_NORMAL;\r\nusb_serial_tty_driver->flags = TTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV;\r\nusb_serial_tty_driver->init_termios = tty_std_termios;\r\nusb_serial_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD\r\n| HUPCL | CLOCAL;\r\nusb_serial_tty_driver->init_termios.c_ispeed = 9600;\r\nusb_serial_tty_driver->init_termios.c_ospeed = 9600;\r\ntty_set_operations(usb_serial_tty_driver, &serial_ops);\r\nresult = tty_register_driver(usb_serial_tty_driver);\r\nif (result) {\r\npr_err("%s - tty_register_driver failed\n", __func__);\r\ngoto exit_reg_driver;\r\n}\r\nresult = usb_register(&usb_serial_driver);\r\nif (result < 0) {\r\npr_err("%s - usb_register failed\n", __func__);\r\ngoto exit_tty;\r\n}\r\nresult = usb_serial_generic_register();\r\nif (result < 0) {\r\npr_err("%s - registering generic driver failed\n", __func__);\r\ngoto exit_generic;\r\n}\r\nreturn result;\r\nexit_generic:\r\nusb_deregister(&usb_serial_driver);\r\nexit_tty:\r\ntty_unregister_driver(usb_serial_tty_driver);\r\nexit_reg_driver:\r\nbus_unregister(&usb_serial_bus_type);\r\nexit_bus:\r\npr_err("%s - returning with error %d\n", __func__, result);\r\nput_tty_driver(usb_serial_tty_driver);\r\nreturn result;\r\n}\r\nstatic void __exit usb_serial_exit(void)\r\n{\r\nusb_serial_console_exit();\r\nusb_serial_generic_deregister();\r\nusb_deregister(&usb_serial_driver);\r\ntty_unregister_driver(usb_serial_tty_driver);\r\nput_tty_driver(usb_serial_tty_driver);\r\nbus_unregister(&usb_serial_bus_type);\r\n}\r\nstatic void usb_serial_operations_init(struct usb_serial_driver *device)\r\n{\r\nset_to_generic_if_null(device, open);\r\nset_to_generic_if_null(device, write);\r\nset_to_generic_if_null(device, close);\r\nset_to_generic_if_null(device, write_room);\r\nset_to_generic_if_null(device, chars_in_buffer);\r\nif (device->tx_empty)\r\nset_to_generic_if_null(device, wait_until_sent);\r\nset_to_generic_if_null(device, read_bulk_callback);\r\nset_to_generic_if_null(device, write_bulk_callback);\r\nset_to_generic_if_null(device, process_read_urb);\r\nset_to_generic_if_null(device, prepare_write_buffer);\r\n}\r\nstatic int usb_serial_register(struct usb_serial_driver *driver)\r\n{\r\nint retval;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (!driver->description)\r\ndriver->description = driver->driver.name;\r\nif (!driver->usb_driver) {\r\nWARN(1, "Serial driver %s has no usb_driver\n",\r\ndriver->description);\r\nreturn -EINVAL;\r\n}\r\nusb_serial_operations_init(driver);\r\nmutex_lock(&table_lock);\r\nlist_add(&driver->driver_list, &usb_serial_driver_list);\r\nretval = usb_serial_bus_register(driver);\r\nif (retval) {\r\npr_err("problem %d when registering driver %s\n", retval, driver->description);\r\nlist_del(&driver->driver_list);\r\n} else {\r\npr_info("USB Serial support registered for %s\n", driver->description);\r\n}\r\nmutex_unlock(&table_lock);\r\nreturn retval;\r\n}\r\nstatic void usb_serial_deregister(struct usb_serial_driver *device)\r\n{\r\npr_info("USB Serial deregistering driver %s\n", device->description);\r\nmutex_lock(&table_lock);\r\nlist_del(&device->driver_list);\r\nmutex_unlock(&table_lock);\r\nusb_serial_bus_deregister(device);\r\n}\r\nint usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[],\r\nconst char *name,\r\nconst struct usb_device_id *id_table)\r\n{\r\nint rc;\r\nstruct usb_driver *udriver;\r\nstruct usb_serial_driver * const *sd;\r\nudriver = kzalloc(sizeof(*udriver), GFP_KERNEL);\r\nif (!udriver)\r\nreturn -ENOMEM;\r\nudriver->name = name;\r\nudriver->no_dynamic_id = 1;\r\nudriver->supports_autosuspend = 1;\r\nudriver->suspend = usb_serial_suspend;\r\nudriver->resume = usb_serial_resume;\r\nudriver->probe = usb_serial_probe;\r\nudriver->disconnect = usb_serial_disconnect;\r\nfor (sd = serial_drivers; *sd; ++sd) {\r\nif ((*sd)->reset_resume) {\r\nudriver->reset_resume = usb_serial_reset_resume;\r\nbreak;\r\n}\r\n}\r\nrc = usb_register(udriver);\r\nif (rc)\r\nreturn rc;\r\nfor (sd = serial_drivers; *sd; ++sd) {\r\n(*sd)->usb_driver = udriver;\r\nrc = usb_serial_register(*sd);\r\nif (rc)\r\ngoto failed;\r\n}\r\nudriver->id_table = id_table;\r\nrc = driver_attach(&udriver->drvwrap.driver);\r\nreturn 0;\r\nfailed:\r\nwhile (sd-- > serial_drivers)\r\nusb_serial_deregister(*sd);\r\nusb_deregister(udriver);\r\nreturn rc;\r\n}\r\nvoid usb_serial_deregister_drivers(struct usb_serial_driver *const serial_drivers[])\r\n{\r\nstruct usb_driver *udriver = (*serial_drivers)->usb_driver;\r\nfor (; *serial_drivers; ++serial_drivers)\r\nusb_serial_deregister(*serial_drivers);\r\nusb_deregister(udriver);\r\nkfree(udriver);\r\n}
