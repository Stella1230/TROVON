static int u14_34f_slave_configure(struct scsi_device *dev) {\r\nint j, tqd, utqd;\r\nchar *tag_suffix, *link_suffix;\r\nstruct Scsi_Host *host = dev->host;\r\nj = ((struct hostdata *) host->hostdata)->board_number;\r\nutqd = MAX_CMD_PER_LUN;\r\ntqd = max_queue_depth;\r\nif (TLDEV(dev->type) && dev->tagged_supported)\r\nif (tag_mode == TAG_SIMPLE) {\r\nscsi_adjust_queue_depth(dev, MSG_SIMPLE_TAG, tqd);\r\ntag_suffix = ", simple tags";\r\n}\r\nelse if (tag_mode == TAG_ORDERED) {\r\nscsi_adjust_queue_depth(dev, MSG_ORDERED_TAG, tqd);\r\ntag_suffix = ", ordered tags";\r\n}\r\nelse {\r\nscsi_adjust_queue_depth(dev, 0, tqd);\r\ntag_suffix = ", no tags";\r\n}\r\nelse if (TLDEV(dev->type) && linked_comm) {\r\nscsi_adjust_queue_depth(dev, 0, tqd);\r\ntag_suffix = ", untagged";\r\n}\r\nelse {\r\nscsi_adjust_queue_depth(dev, 0, utqd);\r\ntag_suffix = "";\r\n}\r\nif (TLDEV(dev->type) && linked_comm && dev->queue_depth > 2)\r\nlink_suffix = ", sorted";\r\nelse if (TLDEV(dev->type))\r\nlink_suffix = ", unsorted";\r\nelse\r\nlink_suffix = "";\r\nsdev_printk(KERN_INFO, dev, "cmds/lun %d%s%s.\n",\r\ndev->queue_depth, link_suffix, tag_suffix);\r\nreturn FALSE;\r\n}\r\nstatic int wait_on_busy(unsigned long iobase, unsigned int loop) {\r\nwhile (inb(iobase + REG_LCL_INTR) & BSY_ASSERTED) {\r\nudelay(1L);\r\nif (--loop == 0) return TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic int board_inquiry(unsigned int j) {\r\nstruct mscp *cpp;\r\ndma_addr_t id_dma_addr;\r\nunsigned int limit = 0;\r\nunsigned long time;\r\nid_dma_addr = pci_map_single(HD(j)->pdev, HD(j)->board_id,\r\nsizeof(HD(j)->board_id), PCI_DMA_BIDIRECTIONAL);\r\ncpp = &HD(j)->cp[0];\r\ncpp->cp_dma_addr = pci_map_single(HD(j)->pdev, cpp, sizeof(struct mscp),\r\nPCI_DMA_BIDIRECTIONAL);\r\nmemset(cpp, 0, sizeof(struct mscp) - CP_TAIL_SIZE);\r\ncpp->opcode = OP_HOST_ADAPTER;\r\ncpp->xdir = DTD_IN;\r\ncpp->data_address = H2DEV(id_dma_addr);\r\ncpp->data_len = H2DEV(sizeof(HD(j)->board_id));\r\ncpp->cdb_len = 6;\r\ncpp->cdb[0] = HA_CMD_INQUIRY;\r\nif (wait_on_busy(sh[j]->io_port, MAXLOOP)) {\r\nprintk("%s: board_inquiry, adapter busy.\n", BN(j));\r\nreturn TRUE;\r\n}\r\nHD(j)->cp_stat[0] = IGNORE;\r\noutb(CMD_CLR_INTR, sh[j]->io_port + REG_SYS_INTR);\r\noutl(H2DEV(cpp->cp_dma_addr), sh[j]->io_port + REG_OGM);\r\noutb(CMD_OGM_INTR, sh[j]->io_port + REG_LCL_INTR);\r\nspin_unlock_irq(&driver_lock);\r\ntime = jiffies;\r\nwhile ((jiffies - time) < HZ && limit++ < 20000) udelay(100L);\r\nspin_lock_irq(&driver_lock);\r\nif (cpp->adapter_status || HD(j)->cp_stat[0] != FREE) {\r\nHD(j)->cp_stat[0] = FREE;\r\nprintk("%s: board_inquiry, err 0x%x.\n", BN(j), cpp->adapter_status);\r\nreturn TRUE;\r\n}\r\npci_unmap_single(HD(j)->pdev, cpp->cp_dma_addr, sizeof(struct mscp),\r\nPCI_DMA_BIDIRECTIONAL);\r\npci_unmap_single(HD(j)->pdev, id_dma_addr, sizeof(HD(j)->board_id),\r\nPCI_DMA_BIDIRECTIONAL);\r\nreturn FALSE;\r\n}\r\nstatic int port_detect \\r\n(unsigned long port_base, unsigned int j, struct scsi_host_template *tpnt) {\r\nunsigned char irq, dma_channel, subversion, i;\r\nunsigned char in_byte;\r\nchar *bus_type, dma_name[16];\r\nunsigned long bios_segment_table[8] = {\r\n0,\r\n0xc4000, 0xc8000, 0xcc000, 0xd0000,\r\n0xd4000, 0xd8000, 0xdc000\r\n};\r\nunsigned char interrupt_table[4] = { 15, 14, 11, 10 };\r\nunsigned char dma_channel_table[4] = { 5, 6, 7, 0 };\r\nstruct {\r\nunsigned char heads;\r\nunsigned char sectors;\r\n} mapping_table[4] = {\r\n{ 16, 63 }, { 64, 32 }, { 64, 63 }, { 64, 32 }\r\n};\r\nstruct config_1 {\r\n#if defined(__BIG_ENDIAN_BITFIELD)\r\nunsigned char dma_channel: 2, interrupt:2,\r\nremovable_disks_as_fixed:1, bios_segment: 3;\r\n#else\r\nunsigned char bios_segment: 3, removable_disks_as_fixed: 1,\r\ninterrupt: 2, dma_channel: 2;\r\n#endif\r\n} config_1;\r\nstruct config_2 {\r\n#if defined(__BIG_ENDIAN_BITFIELD)\r\nunsigned char tfr_port: 2, bios_drive_number: 1,\r\nmapping_mode: 2, ha_scsi_id: 3;\r\n#else\r\nunsigned char ha_scsi_id: 3, mapping_mode: 2,\r\nbios_drive_number: 1, tfr_port: 2;\r\n#endif\r\n} config_2;\r\nchar name[16];\r\nsprintf(name, "%s%d", driver_name, j);\r\nif (!request_region(port_base, REGION_SIZE, driver_name)) {\r\n#if defined(DEBUG_DETECT)\r\nprintk("%s: address 0x%03lx in use, skipping probe.\n", name, port_base);\r\n#endif\r\ngoto fail;\r\n}\r\nspin_lock_irq(&driver_lock);\r\nif (inb(port_base + REG_PRODUCT_ID1) != PRODUCT_ID1) goto freelock;\r\nin_byte = inb(port_base + REG_PRODUCT_ID2);\r\nif ((in_byte & 0xf0) != PRODUCT_ID2) goto freelock;\r\n*(char *)&config_1 = inb(port_base + REG_CONFIG1);\r\n*(char *)&config_2 = inb(port_base + REG_CONFIG2);\r\nirq = interrupt_table[config_1.interrupt];\r\ndma_channel = dma_channel_table[config_1.dma_channel];\r\nsubversion = (in_byte & 0x0f);\r\nif (request_irq(irq, do_interrupt_handler,\r\n(subversion == ESA) ? IRQF_SHARED : 0,\r\ndriver_name, (void *) &sha[j])) {\r\nprintk("%s: unable to allocate IRQ %u, detaching.\n", name, irq);\r\ngoto freelock;\r\n}\r\nif (subversion == ISA && request_dma(dma_channel, driver_name)) {\r\nprintk("%s: unable to allocate DMA channel %u, detaching.\n",\r\nname, dma_channel);\r\ngoto freeirq;\r\n}\r\nif (have_old_firmware) tpnt->use_clustering = DISABLE_CLUSTERING;\r\nspin_unlock_irq(&driver_lock);\r\nsh[j] = scsi_register(tpnt, sizeof(struct hostdata));\r\nspin_lock_irq(&driver_lock);\r\nif (sh[j] == NULL) {\r\nprintk("%s: unable to register host, detaching.\n", name);\r\ngoto freedma;\r\n}\r\nsh[j]->io_port = port_base;\r\nsh[j]->unique_id = port_base;\r\nsh[j]->n_io_port = REGION_SIZE;\r\nsh[j]->base = bios_segment_table[config_1.bios_segment];\r\nsh[j]->irq = irq;\r\nsh[j]->sg_tablesize = MAX_SGLIST;\r\nsh[j]->this_id = config_2.ha_scsi_id;\r\nsh[j]->can_queue = MAX_MAILBOXES;\r\nsh[j]->cmd_per_lun = MAX_CMD_PER_LUN;\r\n#if defined(DEBUG_DETECT)\r\n{\r\nunsigned char sys_mask, lcl_mask;\r\nsys_mask = inb(sh[j]->io_port + REG_SYS_MASK);\r\nlcl_mask = inb(sh[j]->io_port + REG_LCL_MASK);\r\nprintk("SYS_MASK 0x%x, LCL_MASK 0x%x.\n", sys_mask, lcl_mask);\r\n}\r\n#endif\r\nif (sh[j]->this_id == 0) sh[j]->this_id = -1;\r\nif (sh[j]->base == 0) outb(CMD_ENA_INTR, sh[j]->io_port + REG_SYS_MASK);\r\nmemset(HD(j), 0, sizeof(struct hostdata));\r\nHD(j)->heads = mapping_table[config_2.mapping_mode].heads;\r\nHD(j)->sectors = mapping_table[config_2.mapping_mode].sectors;\r\nHD(j)->subversion = subversion;\r\nHD(j)->pdev = NULL;\r\nHD(j)->board_number = j;\r\nif (have_old_firmware) sh[j]->sg_tablesize = MAX_SAFE_SGLIST;\r\nif (HD(j)->subversion == ESA) {\r\nsh[j]->unchecked_isa_dma = FALSE;\r\nsh[j]->dma_channel = NO_DMA;\r\nsprintf(BN(j), "U34F%d", j);\r\nbus_type = "VESA";\r\n}\r\nelse {\r\nunsigned long flags;\r\nsh[j]->unchecked_isa_dma = TRUE;\r\nflags=claim_dma_lock();\r\ndisable_dma(dma_channel);\r\nclear_dma_ff(dma_channel);\r\nset_dma_mode(dma_channel, DMA_MODE_CASCADE);\r\nenable_dma(dma_channel);\r\nrelease_dma_lock(flags);\r\nsh[j]->dma_channel = dma_channel;\r\nsprintf(BN(j), "U14F%d", j);\r\nbus_type = "ISA";\r\n}\r\nsh[j]->max_channel = MAX_CHANNEL - 1;\r\nsh[j]->max_id = MAX_TARGET;\r\nsh[j]->max_lun = MAX_LUN;\r\nif (HD(j)->subversion == ISA && !board_inquiry(j)) {\r\nHD(j)->board_id[40] = 0;\r\nif (strcmp(&HD(j)->board_id[32], "06000600")) {\r\nprintk("%s: %s.\n", BN(j), &HD(j)->board_id[8]);\r\nprintk("%s: firmware %s is outdated, FW PROM should be 28004-006.\n",\r\nBN(j), &HD(j)->board_id[32]);\r\nsh[j]->hostt->use_clustering = DISABLE_CLUSTERING;\r\nsh[j]->sg_tablesize = MAX_SAFE_SGLIST;\r\n}\r\n}\r\nif (dma_channel == NO_DMA) sprintf(dma_name, "%s", "BMST");\r\nelse sprintf(dma_name, "DMA %u", dma_channel);\r\nspin_unlock_irq(&driver_lock);\r\nfor (i = 0; i < sh[j]->can_queue; i++)\r\nHD(j)->cp[i].cp_dma_addr = pci_map_single(HD(j)->pdev,\r\n&HD(j)->cp[i], sizeof(struct mscp), PCI_DMA_BIDIRECTIONAL);\r\nfor (i = 0; i < sh[j]->can_queue; i++)\r\nif (! ((&HD(j)->cp[i])->sglist = kmalloc(\r\nsh[j]->sg_tablesize * sizeof(struct sg_list),\r\n(sh[j]->unchecked_isa_dma ? GFP_DMA : 0) | GFP_ATOMIC))) {\r\nprintk("%s: kmalloc SGlist failed, mbox %d, detaching.\n", BN(j), i);\r\ngoto release;\r\n}\r\nif (max_queue_depth > MAX_TAGGED_CMD_PER_LUN)\r\nmax_queue_depth = MAX_TAGGED_CMD_PER_LUN;\r\nif (max_queue_depth < MAX_CMD_PER_LUN) max_queue_depth = MAX_CMD_PER_LUN;\r\nif (tag_mode != TAG_DISABLED && tag_mode != TAG_SIMPLE)\r\ntag_mode = TAG_ORDERED;\r\nif (j == 0) {\r\nprintk("UltraStor 14F/34F: Copyright (C) 1994-2003 Dario Ballabio.\n");\r\nprintk("%s config options -> of:%c, tm:%d, lc:%c, mq:%d, et:%c.\n",\r\ndriver_name, YESNO(have_old_firmware), tag_mode,\r\nYESNO(linked_comm), max_queue_depth, YESNO(ext_tran));\r\n}\r\nprintk("%s: %s 0x%03lx, BIOS 0x%05x, IRQ %u, %s, SG %d, MB %d.\n",\r\nBN(j), bus_type, (unsigned long)sh[j]->io_port, (int)sh[j]->base,\r\nsh[j]->irq, dma_name, sh[j]->sg_tablesize, sh[j]->can_queue);\r\nif (sh[j]->max_id > 8 || sh[j]->max_lun > 8)\r\nprintk("%s: wide SCSI support enabled, max_id %u, max_lun %llu.\n",\r\nBN(j), sh[j]->max_id, sh[j]->max_lun);\r\nfor (i = 0; i <= sh[j]->max_channel; i++)\r\nprintk("%s: SCSI channel %u enabled, host target ID %d.\n",\r\nBN(j), i, sh[j]->this_id);\r\nreturn TRUE;\r\nfreedma:\r\nif (subversion == ISA) free_dma(dma_channel);\r\nfreeirq:\r\nfree_irq(irq, &sha[j]);\r\nfreelock:\r\nspin_unlock_irq(&driver_lock);\r\nrelease_region(port_base, REGION_SIZE);\r\nfail:\r\nreturn FALSE;\r\nrelease:\r\nu14_34f_release(sh[j]);\r\nreturn FALSE;\r\n}\r\nstatic void internal_setup(char *str, int *ints) {\r\nint i, argc = ints[0];\r\nchar *cur = str, *pc;\r\nif (argc > 0) {\r\nif (argc > MAX_INT_PARAM) argc = MAX_INT_PARAM;\r\nfor (i = 0; i < argc; i++) io_port[i] = ints[i + 1];\r\nio_port[i] = 0;\r\nsetup_done = TRUE;\r\n}\r\nwhile (cur && (pc = strchr(cur, ':'))) {\r\nint val = 0, c = *++pc;\r\nif (c == 'n' || c == 'N') val = FALSE;\r\nelse if (c == 'y' || c == 'Y') val = TRUE;\r\nelse val = (int) simple_strtoul(pc, NULL, 0);\r\nif (!strncmp(cur, "lc:", 3)) linked_comm = val;\r\nelse if (!strncmp(cur, "of:", 3)) have_old_firmware = val;\r\nelse if (!strncmp(cur, "tm:", 3)) tag_mode = val;\r\nelse if (!strncmp(cur, "tc:", 3)) tag_mode = val;\r\nelse if (!strncmp(cur, "mq:", 3)) max_queue_depth = val;\r\nelse if (!strncmp(cur, "ls:", 3)) link_statistics = val;\r\nelse if (!strncmp(cur, "et:", 3)) ext_tran = val;\r\nif ((cur = strchr(cur, ','))) ++cur;\r\n}\r\nreturn;\r\n}\r\nstatic int option_setup(char *str) {\r\nint ints[MAX_INT_PARAM];\r\nchar *cur = str;\r\nint i = 1;\r\nwhile (cur && isdigit(*cur) && i < MAX_INT_PARAM) {\r\nints[i++] = simple_strtoul(cur, NULL, 0);\r\nif ((cur = strchr(cur, ',')) != NULL) cur++;\r\n}\r\nints[0] = i - 1;\r\ninternal_setup(cur, ints);\r\nreturn 1;\r\n}\r\nstatic int u14_34f_detect(struct scsi_host_template *tpnt) {\r\nunsigned int j = 0, k;\r\ntpnt->proc_name = "u14-34f";\r\nif(strlen(boot_options)) option_setup(boot_options);\r\n#if defined(MODULE)\r\nif(io_port[0] != SKIP) {\r\nsetup_done = TRUE;\r\nio_port[MAX_INT_PARAM] = 0;\r\n}\r\n#endif\r\nfor (k = 0; k < MAX_BOARDS + 1; k++) sh[k] = NULL;\r\nfor (k = 0; io_port[k]; k++) {\r\nif (io_port[k] == SKIP) continue;\r\nif (j < MAX_BOARDS && port_detect(io_port[k], j, tpnt)) j++;\r\n}\r\nnum_boards = j;\r\nreturn j;\r\n}\r\nstatic void map_dma(unsigned int i, unsigned int j) {\r\nunsigned int data_len = 0;\r\nunsigned int k, pci_dir;\r\nint count;\r\nstruct scatterlist *sg;\r\nstruct mscp *cpp;\r\nstruct scsi_cmnd *SCpnt;\r\ncpp = &HD(j)->cp[i]; SCpnt = cpp->SCpnt;\r\npci_dir = SCpnt->sc_data_direction;\r\nif (SCpnt->sense_buffer)\r\ncpp->sense_addr = H2DEV(pci_map_single(HD(j)->pdev, SCpnt->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, PCI_DMA_FROMDEVICE));\r\ncpp->sense_len = SCSI_SENSE_BUFFERSIZE;\r\nif (scsi_bufflen(SCpnt)) {\r\ncount = scsi_dma_map(SCpnt);\r\nBUG_ON(count < 0);\r\nscsi_for_each_sg(SCpnt, sg, count, k) {\r\ncpp->sglist[k].address = H2DEV(sg_dma_address(sg));\r\ncpp->sglist[k].num_bytes = H2DEV(sg_dma_len(sg));\r\ndata_len += sg->length;\r\n}\r\ncpp->sg = TRUE;\r\ncpp->use_sg = scsi_sg_count(SCpnt);\r\ncpp->data_address =\r\nH2DEV(pci_map_single(HD(j)->pdev, cpp->sglist,\r\ncpp->use_sg * sizeof(struct sg_list),\r\npci_dir));\r\ncpp->data_len = H2DEV(data_len);\r\n} else {\r\npci_dir = PCI_DMA_BIDIRECTIONAL;\r\ncpp->data_len = H2DEV(scsi_bufflen(SCpnt));\r\n}\r\n}\r\nstatic void unmap_dma(unsigned int i, unsigned int j) {\r\nunsigned int pci_dir;\r\nstruct mscp *cpp;\r\nstruct scsi_cmnd *SCpnt;\r\ncpp = &HD(j)->cp[i]; SCpnt = cpp->SCpnt;\r\npci_dir = SCpnt->sc_data_direction;\r\nif (DEV2H(cpp->sense_addr))\r\npci_unmap_single(HD(j)->pdev, DEV2H(cpp->sense_addr),\r\nDEV2H(cpp->sense_len), PCI_DMA_FROMDEVICE);\r\nscsi_dma_unmap(SCpnt);\r\nif (!DEV2H(cpp->data_len)) pci_dir = PCI_DMA_BIDIRECTIONAL;\r\nif (DEV2H(cpp->data_address))\r\npci_unmap_single(HD(j)->pdev, DEV2H(cpp->data_address),\r\nDEV2H(cpp->data_len), pci_dir);\r\n}\r\nstatic void sync_dma(unsigned int i, unsigned int j) {\r\nunsigned int pci_dir;\r\nstruct mscp *cpp;\r\nstruct scsi_cmnd *SCpnt;\r\ncpp = &HD(j)->cp[i]; SCpnt = cpp->SCpnt;\r\npci_dir = SCpnt->sc_data_direction;\r\nif (DEV2H(cpp->sense_addr))\r\npci_dma_sync_single_for_cpu(HD(j)->pdev, DEV2H(cpp->sense_addr),\r\nDEV2H(cpp->sense_len), PCI_DMA_FROMDEVICE);\r\nif (scsi_sg_count(SCpnt))\r\npci_dma_sync_sg_for_cpu(HD(j)->pdev, scsi_sglist(SCpnt),\r\nscsi_sg_count(SCpnt), pci_dir);\r\nif (!DEV2H(cpp->data_len)) pci_dir = PCI_DMA_BIDIRECTIONAL;\r\nif (DEV2H(cpp->data_address))\r\npci_dma_sync_single_for_cpu(HD(j)->pdev, DEV2H(cpp->data_address),\r\nDEV2H(cpp->data_len), pci_dir);\r\n}\r\nstatic void scsi_to_dev_dir(unsigned int i, unsigned int j) {\r\nunsigned int k;\r\nstatic const unsigned char data_out_cmds[] = {\r\n0x0a, 0x2a, 0x15, 0x55, 0x04, 0x07, 0x18, 0x1d, 0x24, 0x2e,\r\n0x30, 0x31, 0x32, 0x38, 0x39, 0x3a, 0x3b, 0x3d, 0x3f, 0x40,\r\n0x41, 0x4c, 0xaa, 0xae, 0xb0, 0xb1, 0xb2, 0xb6, 0xea, 0x1b, 0x5d\r\n};\r\nstatic const unsigned char data_none_cmds[] = {\r\n0x01, 0x0b, 0x10, 0x11, 0x13, 0x16, 0x17, 0x19, 0x2b, 0x1e,\r\n0x2c, 0xac, 0x2f, 0xaf, 0x33, 0xb3, 0x35, 0x36, 0x45, 0x47,\r\n0x48, 0x49, 0xa9, 0x4b, 0xa5, 0xa6, 0xb5, 0x00\r\n};\r\nstruct mscp *cpp;\r\nstruct scsi_cmnd *SCpnt;\r\ncpp = &HD(j)->cp[i]; SCpnt = cpp->SCpnt;\r\nif (SCpnt->sc_data_direction == DMA_FROM_DEVICE) {\r\ncpp->xdir = DTD_IN;\r\nreturn;\r\n}\r\nelse if (SCpnt->sc_data_direction == DMA_TO_DEVICE) {\r\ncpp->xdir = DTD_OUT;\r\nreturn;\r\n}\r\nelse if (SCpnt->sc_data_direction == DMA_NONE) {\r\ncpp->xdir = DTD_NONE;\r\nreturn;\r\n}\r\nif (SCpnt->sc_data_direction != DMA_BIDIRECTIONAL)\r\npanic("%s: qcomm, invalid SCpnt->sc_data_direction.\n", BN(j));\r\ncpp->xdir = DTD_IN;\r\nfor (k = 0; k < ARRAY_SIZE(data_out_cmds); k++)\r\nif (SCpnt->cmnd[0] == data_out_cmds[k]) {\r\ncpp->xdir = DTD_OUT;\r\nbreak;\r\n}\r\nif (cpp->xdir == DTD_IN)\r\nfor (k = 0; k < ARRAY_SIZE(data_none_cmds); k++)\r\nif (SCpnt->cmnd[0] == data_none_cmds[k]) {\r\ncpp->xdir = DTD_NONE;\r\nbreak;\r\n}\r\n}\r\nstatic int u14_34f_queuecommand_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *)) {\r\nunsigned int i, j, k;\r\nstruct mscp *cpp;\r\nj = ((struct hostdata *) SCpnt->device->host->hostdata)->board_number;\r\nif (SCpnt->host_scribble)\r\npanic("%s: qcomm, SCpnt %p already active.\n",\r\nBN(j), SCpnt);\r\ni = HD(j)->last_cp_used + 1;\r\nfor (k = 0; k < sh[j]->can_queue; k++, i++) {\r\nif (i >= sh[j]->can_queue) i = 0;\r\nif (HD(j)->cp_stat[i] == FREE) {\r\nHD(j)->last_cp_used = i;\r\nbreak;\r\n}\r\n}\r\nif (k == sh[j]->can_queue) {\r\nprintk("%s: qcomm, no free mailbox.\n", BN(j));\r\nreturn 1;\r\n}\r\ncpp = &HD(j)->cp[i];\r\nmemset(cpp, 0, sizeof(struct mscp) - CP_TAIL_SIZE);\r\nSCpnt->scsi_done = done;\r\ncpp->cpp_index = i;\r\nSCpnt->host_scribble = (unsigned char *) &cpp->cpp_index;\r\nif (do_trace) printk("%s: qcomm, mbox %d, target %d.%d:%u.\n",\r\nBN(j), i, SCpnt->device->channel, SCpnt->device->id,\r\n(u8)SCpnt->device->lun);\r\ncpp->opcode = OP_SCSI;\r\ncpp->channel = SCpnt->device->channel;\r\ncpp->target = SCpnt->device->id;\r\ncpp->lun = (u8)SCpnt->device->lun;\r\ncpp->SCpnt = SCpnt;\r\ncpp->cdb_len = SCpnt->cmd_len;\r\nmemcpy(cpp->cdb, SCpnt->cmnd, SCpnt->cmd_len);\r\nscsi_to_dev_dir(i, j);\r\nmap_dma(i, j);\r\nif (linked_comm && SCpnt->device->queue_depth > 2\r\n&& TLDEV(SCpnt->device->type)) {\r\nHD(j)->cp_stat[i] = READY;\r\nflush_dev(SCpnt->device, blk_rq_pos(SCpnt->request), j, FALSE);\r\nreturn 0;\r\n}\r\nif (wait_on_busy(sh[j]->io_port, MAXLOOP)) {\r\nunmap_dma(i, j);\r\nSCpnt->host_scribble = NULL;\r\nscmd_printk(KERN_INFO, SCpnt,\r\n"qcomm, adapter busy.\n");\r\nreturn 1;\r\n}\r\noutl(H2DEV(cpp->cp_dma_addr), sh[j]->io_port + REG_OGM);\r\noutb(CMD_OGM_INTR, sh[j]->io_port + REG_LCL_INTR);\r\nHD(j)->cp_stat[i] = IN_USE;\r\nreturn 0;\r\n}\r\nint u14_34f_eh_host_reset(struct scsi_cmnd *SCarg) {\r\nunsigned int i, j, k, c, limit = 0;\r\nunsigned long time;\r\nint arg_done = FALSE;\r\nstruct scsi_cmnd *SCpnt;\r\nj = ((struct hostdata *) SCarg->device->host->hostdata)->board_number;\r\nscmd_printk(KERN_INFO, SCarg, "reset, enter.\n");\r\nspin_lock_irq(sh[j]->host_lock);\r\nif (SCarg->host_scribble == NULL)\r\nprintk("%s: reset, inactive.\n", BN(j));\r\nif (HD(j)->in_reset) {\r\nprintk("%s: reset, exit, already in reset.\n", BN(j));\r\nspin_unlock_irq(sh[j]->host_lock);\r\nreturn FAILED;\r\n}\r\nif (wait_on_busy(sh[j]->io_port, MAXLOOP)) {\r\nprintk("%s: reset, exit, timeout error.\n", BN(j));\r\nspin_unlock_irq(sh[j]->host_lock);\r\nreturn FAILED;\r\n}\r\nHD(j)->retries = 0;\r\nfor (c = 0; c <= sh[j]->max_channel; c++)\r\nfor (k = 0; k < sh[j]->max_id; k++) {\r\nHD(j)->target_redo[k][c] = TRUE;\r\nHD(j)->target_to[k][c] = 0;\r\n}\r\nfor (i = 0; i < sh[j]->can_queue; i++) {\r\nif (HD(j)->cp_stat[i] == FREE) continue;\r\nif (HD(j)->cp_stat[i] == LOCKED) {\r\nHD(j)->cp_stat[i] = FREE;\r\nprintk("%s: reset, locked mbox %d forced free.\n", BN(j), i);\r\ncontinue;\r\n}\r\nif (!(SCpnt = HD(j)->cp[i].SCpnt))\r\npanic("%s: reset, mbox %d, SCpnt == NULL.\n", BN(j), i);\r\nif (HD(j)->cp_stat[i] == READY || HD(j)->cp_stat[i] == ABORTING) {\r\nHD(j)->cp_stat[i] = ABORTING;\r\nprintk("%s: reset, mbox %d aborting.\n", BN(j), i);\r\n}\r\nelse {\r\nHD(j)->cp_stat[i] = IN_RESET;\r\nprintk("%s: reset, mbox %d in reset.\n", BN(j), i);\r\n}\r\nif (SCpnt->host_scribble == NULL)\r\npanic("%s: reset, mbox %d, garbled SCpnt.\n", BN(j), i);\r\nif (*(unsigned int *)SCpnt->host_scribble != i)\r\npanic("%s: reset, mbox %d, index mismatch.\n", BN(j), i);\r\nif (SCpnt->scsi_done == NULL)\r\npanic("%s: reset, mbox %d, SCpnt->scsi_done == NULL.\n", BN(j), i);\r\nif (SCpnt == SCarg) arg_done = TRUE;\r\n}\r\nif (wait_on_busy(sh[j]->io_port, MAXLOOP)) {\r\nprintk("%s: reset, cannot reset, timeout error.\n", BN(j));\r\nspin_unlock_irq(sh[j]->host_lock);\r\nreturn FAILED;\r\n}\r\noutb(CMD_RESET, sh[j]->io_port + REG_LCL_INTR);\r\nprintk("%s: reset, board reset done, enabling interrupts.\n", BN(j));\r\n#if defined(DEBUG_RESET)\r\ndo_trace = TRUE;\r\n#endif\r\nHD(j)->in_reset = TRUE;\r\nspin_unlock_irq(sh[j]->host_lock);\r\ntime = jiffies;\r\nwhile ((jiffies - time) < (10 * HZ) && limit++ < 200000) udelay(100L);\r\nspin_lock_irq(sh[j]->host_lock);\r\nprintk("%s: reset, interrupts disabled, loops %d.\n", BN(j), limit);\r\nfor (i = 0; i < sh[j]->can_queue; i++) {\r\nif (HD(j)->cp_stat[i] == IN_RESET) {\r\nSCpnt = HD(j)->cp[i].SCpnt;\r\nunmap_dma(i, j);\r\nSCpnt->result = DID_RESET << 16;\r\nSCpnt->host_scribble = NULL;\r\nHD(j)->cp_stat[i] = LOCKED;\r\nprintk("%s, reset, mbox %d locked, DID_RESET, done.\n", BN(j), i);\r\n}\r\nelse if (HD(j)->cp_stat[i] == ABORTING) {\r\nSCpnt = HD(j)->cp[i].SCpnt;\r\nunmap_dma(i, j);\r\nSCpnt->result = DID_RESET << 16;\r\nSCpnt->host_scribble = NULL;\r\nHD(j)->cp_stat[i] = FREE;\r\nprintk("%s, reset, mbox %d aborting, DID_RESET, done.\n", BN(j), i);\r\n}\r\nelse\r\ncontinue;\r\nSCpnt->scsi_done(SCpnt);\r\n}\r\nHD(j)->in_reset = FALSE;\r\ndo_trace = FALSE;\r\nif (arg_done) printk("%s: reset, exit, done.\n", BN(j));\r\nelse printk("%s: reset, exit.\n", BN(j));\r\nspin_unlock_irq(sh[j]->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int u14_34f_bios_param(struct scsi_device *disk,\r\nstruct block_device *bdev, sector_t capacity, int *dkinfo) {\r\nunsigned int j = 0;\r\nunsigned int size = capacity;\r\ndkinfo[0] = HD(j)->heads;\r\ndkinfo[1] = HD(j)->sectors;\r\ndkinfo[2] = size / (HD(j)->heads * HD(j)->sectors);\r\nif (ext_tran && (scsicam_bios_param(bdev, capacity, dkinfo) < 0)) {\r\ndkinfo[0] = 255;\r\ndkinfo[1] = 63;\r\ndkinfo[2] = size / (dkinfo[0] * dkinfo[1]);\r\n}\r\n#if defined (DEBUG_GEOMETRY)\r\nprintk ("%s: bios_param, head=%d, sec=%d, cyl=%d.\n", driver_name,\r\ndkinfo[0], dkinfo[1], dkinfo[2]);\r\n#endif\r\nreturn FALSE;\r\n}\r\nstatic void sort(unsigned long sk[], unsigned int da[], unsigned int n,\r\nunsigned int rev) {\r\nunsigned int i, j, k, y;\r\nunsigned long x;\r\nfor (i = 0; i < n - 1; i++) {\r\nk = i;\r\nfor (j = k + 1; j < n; j++)\r\nif (rev) {\r\nif (sk[j] > sk[k]) k = j;\r\n}\r\nelse {\r\nif (sk[j] < sk[k]) k = j;\r\n}\r\nif (k != i) {\r\nx = sk[k]; sk[k] = sk[i]; sk[i] = x;\r\ny = da[k]; da[k] = da[i]; da[i] = y;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int reorder(unsigned int j, unsigned long cursec,\r\nunsigned int ihdlr, unsigned int il[], unsigned int n_ready) {\r\nstruct scsi_cmnd *SCpnt;\r\nstruct mscp *cpp;\r\nunsigned int k, n;\r\nunsigned int rev = FALSE, s = TRUE, r = TRUE;\r\nunsigned int input_only = TRUE, overlap = FALSE;\r\nunsigned long sl[n_ready], pl[n_ready], ll[n_ready];\r\nunsigned long maxsec = 0, minsec = ULONG_MAX, seek = 0, iseek = 0;\r\nunsigned long ioseek = 0;\r\nstatic unsigned int flushcount = 0, batchcount = 0, sortcount = 0;\r\nstatic unsigned int readycount = 0, ovlcount = 0, inputcount = 0;\r\nstatic unsigned int readysorted = 0, revcount = 0;\r\nstatic unsigned long seeksorted = 0, seeknosort = 0;\r\nif (link_statistics && !(++flushcount % link_statistics))\r\nprintk("fc %d bc %d ic %d oc %d rc %d rs %d sc %d re %d"\\r\n" av %ldK as %ldK.\n", flushcount, batchcount, inputcount,\r\novlcount, readycount, readysorted, sortcount, revcount,\r\nseeknosort / (readycount + 1),\r\nseeksorted / (readycount + 1));\r\nif (n_ready <= 1) return FALSE;\r\nfor (n = 0; n < n_ready; n++) {\r\nk = il[n]; cpp = &HD(j)->cp[k]; SCpnt = cpp->SCpnt;\r\nif (!(cpp->xdir == DTD_IN)) input_only = FALSE;\r\nif (blk_rq_pos(SCpnt->request) < minsec)\r\nminsec = blk_rq_pos(SCpnt->request);\r\nif (blk_rq_pos(SCpnt->request) > maxsec)\r\nmaxsec = blk_rq_pos(SCpnt->request);\r\nsl[n] = blk_rq_pos(SCpnt->request);\r\nioseek += blk_rq_sectors(SCpnt->request);\r\nif (!n) continue;\r\nif (sl[n] < sl[n - 1]) s = FALSE;\r\nif (sl[n] > sl[n - 1]) r = FALSE;\r\nif (link_statistics) {\r\nif (sl[n] > sl[n - 1])\r\nseek += sl[n] - sl[n - 1];\r\nelse\r\nseek += sl[n - 1] - sl[n];\r\n}\r\n}\r\nif (link_statistics) {\r\nif (cursec > sl[0]) seek += cursec - sl[0]; else seek += sl[0] - cursec;\r\n}\r\nif (cursec > ((maxsec + minsec) / 2)) rev = TRUE;\r\nif (ioseek > ((maxsec - minsec) / 2)) rev = FALSE;\r\nif (!((rev && r) || (!rev && s))) sort(sl, il, n_ready, rev);\r\nif (!input_only) for (n = 0; n < n_ready; n++) {\r\nk = il[n]; cpp = &HD(j)->cp[k]; SCpnt = cpp->SCpnt;\r\nll[n] = blk_rq_sectors(SCpnt->request); pl[n] = SCpnt->serial_number;\r\nif (!n) continue;\r\nif ((sl[n] == sl[n - 1]) || (!rev && ((sl[n - 1] + ll[n - 1]) > sl[n]))\r\n|| (rev && ((sl[n] + ll[n]) > sl[n - 1]))) overlap = TRUE;\r\n}\r\nif (overlap) sort(pl, il, n_ready, FALSE);\r\nif (link_statistics) {\r\nif (cursec > sl[0]) iseek = cursec - sl[0]; else iseek = sl[0] - cursec;\r\nbatchcount++; readycount += n_ready; seeknosort += seek / 1024;\r\nif (input_only) inputcount++;\r\nif (overlap) { ovlcount++; seeksorted += iseek / 1024; }\r\nelse seeksorted += (iseek + maxsec - minsec) / 1024;\r\nif (rev && !r) { revcount++; readysorted += n_ready; }\r\nif (!rev && !s) { sortcount++; readysorted += n_ready; }\r\n}\r\n#if defined(DEBUG_LINKED_COMMANDS)\r\nif (link_statistics && (overlap || !(flushcount % link_statistics)))\r\nfor (n = 0; n < n_ready; n++) {\r\nk = il[n]; cpp = &HD(j)->cp[k]; SCpnt = cpp->SCpnt;\r\nprintk("%s %d.%d:%llu mb %d fc %d nr %d sec %ld ns %u"\\r\n" cur %ld s:%c r:%c rev:%c in:%c ov:%c xd %d.\n",\r\n(ihdlr ? "ihdlr" : "qcomm"), SCpnt->channel, SCpnt->target,\r\n(u8)SCpnt->lun, k, flushcount, n_ready,\r\nblk_rq_pos(SCpnt->request), blk_rq_sectors(SCpnt->request),\r\ncursec, YESNO(s), YESNO(r), YESNO(rev), YESNO(input_only),\r\nYESNO(overlap), cpp->xdir);\r\n}\r\n#endif\r\nreturn overlap;\r\n}\r\nstatic void flush_dev(struct scsi_device *dev, unsigned long cursec, unsigned int j,\r\nunsigned int ihdlr) {\r\nstruct scsi_cmnd *SCpnt;\r\nstruct mscp *cpp;\r\nunsigned int k, n, n_ready = 0, il[MAX_MAILBOXES];\r\nfor (k = 0; k < sh[j]->can_queue; k++) {\r\nif (HD(j)->cp_stat[k] != READY && HD(j)->cp_stat[k] != IN_USE) continue;\r\ncpp = &HD(j)->cp[k]; SCpnt = cpp->SCpnt;\r\nif (SCpnt->device != dev) continue;\r\nif (HD(j)->cp_stat[k] == IN_USE) return;\r\nil[n_ready++] = k;\r\n}\r\nif (reorder(j, cursec, ihdlr, il, n_ready)) n_ready = 1;\r\nfor (n = 0; n < n_ready; n++) {\r\nk = il[n]; cpp = &HD(j)->cp[k]; SCpnt = cpp->SCpnt;\r\nif (wait_on_busy(sh[j]->io_port, MAXLOOP)) {\r\nscmd_printk(KERN_INFO, SCpnt,\r\n"%s, mbox %d, adapter"\r\n" busy, will abort.\n", (ihdlr ? "ihdlr" : "qcomm"),\r\nk);\r\nHD(j)->cp_stat[k] = ABORTING;\r\ncontinue;\r\n}\r\noutl(H2DEV(cpp->cp_dma_addr), sh[j]->io_port + REG_OGM);\r\noutb(CMD_OGM_INTR, sh[j]->io_port + REG_LCL_INTR);\r\nHD(j)->cp_stat[k] = IN_USE;\r\n}\r\n}\r\nstatic irqreturn_t ihdlr(unsigned int j)\r\n{\r\nstruct scsi_cmnd *SCpnt;\r\nunsigned int i, k, c, status, tstatus, reg, ret;\r\nstruct mscp *spp, *cpp;\r\nint irq = sh[j]->irq;\r\nif (!((reg = inb(sh[j]->io_port + REG_SYS_INTR)) & IRQ_ASSERTED)) goto none;\r\nHD(j)->iocount++;\r\nif (do_trace) printk("%s: ihdlr, enter, irq %d, count %d.\n", BN(j), irq,\r\nHD(j)->iocount);\r\nif (wait_on_busy(sh[j]->io_port, 20 * MAXLOOP)) {\r\noutb(CMD_CLR_INTR, sh[j]->io_port + REG_SYS_INTR);\r\nprintk("%s: ihdlr, busy timeout error, irq %d, reg 0x%x, count %d.\n",\r\nBN(j), irq, reg, HD(j)->iocount);\r\ngoto none;\r\n}\r\nret = inl(sh[j]->io_port + REG_ICM);\r\noutb(CMD_CLR_INTR, sh[j]->io_port + REG_SYS_INTR);\r\nfor (i = 0; i < sh[j]->can_queue; i++)\r\nif (H2DEV(HD(j)->cp[i].cp_dma_addr) == ret) break;\r\nif (i >= sh[j]->can_queue)\r\npanic("%s: ihdlr, invalid mscp bus address %p, cp0 %p.\n", BN(j),\r\n(void *)ret, (void *)H2DEV(HD(j)->cp[0].cp_dma_addr));\r\ncpp = &(HD(j)->cp[i]);\r\nspp = cpp;\r\n#if defined(DEBUG_GENERATE_ABORTS)\r\nif ((HD(j)->iocount > 500) && ((HD(j)->iocount % 500) < 3)) goto handled;\r\n#endif\r\nif (HD(j)->cp_stat[i] == IGNORE) {\r\nHD(j)->cp_stat[i] = FREE;\r\ngoto handled;\r\n}\r\nelse if (HD(j)->cp_stat[i] == LOCKED) {\r\nHD(j)->cp_stat[i] = FREE;\r\nprintk("%s: ihdlr, mbox %d unlocked, count %d.\n", BN(j), i,\r\nHD(j)->iocount);\r\ngoto handled;\r\n}\r\nelse if (HD(j)->cp_stat[i] == FREE) {\r\nprintk("%s: ihdlr, mbox %d is free, count %d.\n", BN(j), i,\r\nHD(j)->iocount);\r\ngoto handled;\r\n}\r\nelse if (HD(j)->cp_stat[i] == IN_RESET)\r\nprintk("%s: ihdlr, mbox %d is in reset.\n", BN(j), i);\r\nelse if (HD(j)->cp_stat[i] != IN_USE)\r\npanic("%s: ihdlr, mbox %d, invalid cp_stat: %d.\n",\r\nBN(j), i, HD(j)->cp_stat[i]);\r\nHD(j)->cp_stat[i] = FREE;\r\nSCpnt = cpp->SCpnt;\r\nif (SCpnt == NULL) panic("%s: ihdlr, mbox %d, SCpnt == NULL.\n", BN(j), i);\r\nif (SCpnt->host_scribble == NULL)\r\npanic("%s: ihdlr, mbox %d, SCpnt %p garbled.\n", BN(j), i,\r\nSCpnt);\r\nif (*(unsigned int *)SCpnt->host_scribble != i)\r\npanic("%s: ihdlr, mbox %d, index mismatch %d.\n",\r\nBN(j), i, *(unsigned int *)SCpnt->host_scribble);\r\nsync_dma(i, j);\r\nif (linked_comm && SCpnt->device->queue_depth > 2\r\n&& TLDEV(SCpnt->device->type))\r\nflush_dev(SCpnt->device, blk_rq_pos(SCpnt->request), j, TRUE);\r\ntstatus = status_byte(spp->target_status);\r\n#if defined(DEBUG_GENERATE_ERRORS)\r\nif ((HD(j)->iocount > 500) && ((HD(j)->iocount % 200) < 2))\r\nspp->adapter_status = 0x01;\r\n#endif\r\nswitch (spp->adapter_status) {\r\ncase ASOK:\r\nif (tstatus == BUSY && SCpnt->device->type != TYPE_TAPE)\r\nstatus = DID_ERROR << 16;\r\nelse if (tstatus != GOOD && SCpnt->device->type == TYPE_DISK\r\n&& HD(j)->target_redo[scmd_id(SCpnt)][scmd_channel(SCpnt)])\r\nstatus = DID_BUS_BUSY << 16;\r\nelse if (tstatus == CHECK_CONDITION\r\n&& SCpnt->device->type == TYPE_DISK\r\n&& (SCpnt->sense_buffer[2] & 0xf) == RECOVERED_ERROR)\r\nstatus = DID_BUS_BUSY << 16;\r\nelse\r\nstatus = DID_OK << 16;\r\nif (tstatus == GOOD)\r\nHD(j)->target_redo[scmd_id(SCpnt)][scmd_channel(SCpnt)] = FALSE;\r\nif (spp->target_status && SCpnt->device->type == TYPE_DISK &&\r\n(!(tstatus == CHECK_CONDITION && HD(j)->iocount <= 1000 &&\r\n(SCpnt->sense_buffer[2] & 0xf) == NOT_READY)))\r\nscmd_printk(KERN_INFO, SCpnt,\r\n"ihdlr, target_status 0x%x, sense key 0x%x.\n",\r\nspp->target_status,\r\nSCpnt->sense_buffer[2]);\r\nHD(j)->target_to[scmd_id(SCpnt)][scmd_channel(SCpnt)] = 0;\r\nif (HD(j)->last_retried_pid == SCpnt->serial_number) HD(j)->retries = 0;\r\nbreak;\r\ncase ASST:\r\nif (HD(j)->target_to[scmd_id(SCpnt)][scmd_channel(SCpnt)] > 1)\r\nstatus = DID_ERROR << 16;\r\nelse {\r\nstatus = DID_TIME_OUT << 16;\r\nHD(j)->target_to[scmd_id(SCpnt)][scmd_channel(SCpnt)]++;\r\n}\r\nbreak;\r\ncase 0x93:\r\ncase 0x94:\r\ncase 0x96:\r\ncase 0xa3:\r\nfor (c = 0; c <= sh[j]->max_channel; c++)\r\nfor (k = 0; k < sh[j]->max_id; k++)\r\nHD(j)->target_redo[k][c] = TRUE;\r\ncase 0x92:\r\nif (SCpnt->device->type != TYPE_TAPE\r\n&& HD(j)->retries < MAX_INTERNAL_RETRIES) {\r\n#if defined(DID_SOFT_ERROR)\r\nstatus = DID_SOFT_ERROR << 16;\r\n#else\r\nstatus = DID_BUS_BUSY << 16;\r\n#endif\r\nHD(j)->retries++;\r\nHD(j)->last_retried_pid = SCpnt->serial_number;\r\n}\r\nelse\r\nstatus = DID_ERROR << 16;\r\nbreak;\r\ncase 0x01:\r\ncase 0x02:\r\ncase 0x03:\r\ncase 0x84:\r\ncase 0x9b:\r\ncase 0x9f:\r\ncase 0xff:\r\ndefault:\r\nstatus = DID_ERROR << 16;\r\nbreak;\r\n}\r\nSCpnt->result = status | spp->target_status;\r\n#if defined(DEBUG_INTERRUPT)\r\nif (SCpnt->result || do_trace)\r\n#else\r\nif ((spp->adapter_status != ASOK && HD(j)->iocount > 1000) ||\r\n(spp->adapter_status != ASOK &&\r\nspp->adapter_status != ASST && HD(j)->iocount <= 1000) ||\r\ndo_trace || msg_byte(spp->target_status))\r\n#endif\r\nscmd_printk(KERN_INFO, SCpnt, "ihdlr, mbox %2d, err 0x%x:%x,"\\r\n" reg 0x%x, count %d.\n",\r\ni, spp->adapter_status, spp->target_status,\r\nreg, HD(j)->iocount);\r\nunmap_dma(i, j);\r\nSCpnt->host_scribble = NULL;\r\nSCpnt->scsi_done(SCpnt);\r\nif (do_trace) printk("%s: ihdlr, exit, irq %d, count %d.\n", BN(j), irq,\r\nHD(j)->iocount);\r\nhandled:\r\nreturn IRQ_HANDLED;\r\nnone:\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t do_interrupt_handler(int irq, void *shap) {\r\nunsigned int j;\r\nunsigned long spin_flags;\r\nirqreturn_t ret;\r\nif ((j = (unsigned int)((char *)shap - sha)) >= num_boards) return IRQ_NONE;\r\nspin_lock_irqsave(sh[j]->host_lock, spin_flags);\r\nret = ihdlr(j);\r\nspin_unlock_irqrestore(sh[j]->host_lock, spin_flags);\r\nreturn ret;\r\n}\r\nstatic int u14_34f_release(struct Scsi_Host *shpnt) {\r\nunsigned int i, j;\r\nfor (j = 0; sh[j] != NULL && sh[j] != shpnt; j++);\r\nif (sh[j] == NULL)\r\npanic("%s: release, invalid Scsi_Host pointer.\n", driver_name);\r\nfor (i = 0; i < sh[j]->can_queue; i++)\r\nkfree((&HD(j)->cp[i])->sglist);\r\nfor (i = 0; i < sh[j]->can_queue; i++)\r\npci_unmap_single(HD(j)->pdev, HD(j)->cp[i].cp_dma_addr,\r\nsizeof(struct mscp), PCI_DMA_BIDIRECTIONAL);\r\nfree_irq(sh[j]->irq, &sha[j]);\r\nif (sh[j]->dma_channel != NO_DMA)\r\nfree_dma(sh[j]->dma_channel);\r\nrelease_region(sh[j]->io_port, sh[j]->n_io_port);\r\nscsi_unregister(sh[j]);\r\nreturn FALSE;\r\n}
