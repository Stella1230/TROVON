static int do_unlink_socket(struct notifier_block *notifier,\r\nunsigned long what, void *data)\r\n{\r\nreturn mconsole_unlink_socket();\r\n}\r\nstatic void mc_work_proc(struct work_struct *unused)\r\n{\r\nstruct mconsole_entry *req;\r\nunsigned long flags;\r\nwhile (!list_empty(&mc_requests)) {\r\nlocal_irq_save(flags);\r\nreq = list_entry(mc_requests.next, struct mconsole_entry, list);\r\nlist_del(&req->list);\r\nlocal_irq_restore(flags);\r\nreq->request.cmd->handler(&req->request);\r\nkfree(req);\r\n}\r\n}\r\nstatic irqreturn_t mconsole_interrupt(int irq, void *dev_id)\r\n{\r\nlong fd;\r\nstruct mconsole_entry *new;\r\nstatic struct mc_request req;\r\nfd = (long) dev_id;\r\nwhile (mconsole_get_request(fd, &req)) {\r\nif (req.cmd->context == MCONSOLE_INTR)\r\n(*req.cmd->handler)(&req);\r\nelse {\r\nnew = kmalloc(sizeof(*new), GFP_NOWAIT);\r\nif (new == NULL)\r\nmconsole_reply(&req, "Out of memory", 1, 0);\r\nelse {\r\nnew->request = req;\r\nnew->request.regs = get_irq_regs()->regs;\r\nlist_add(&new->list, &mc_requests);\r\n}\r\n}\r\n}\r\nif (!list_empty(&mc_requests))\r\nschedule_work(&mconsole_work);\r\nreactivate_fd(fd, MCONSOLE_IRQ);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid mconsole_version(struct mc_request *req)\r\n{\r\nchar version[256];\r\nsprintf(version, "%s %s %s %s %s", utsname()->sysname,\r\nutsname()->nodename, utsname()->release, utsname()->version,\r\nutsname()->machine);\r\nmconsole_reply(req, version, 0, 0);\r\n}\r\nvoid mconsole_log(struct mc_request *req)\r\n{\r\nint len;\r\nchar *ptr = req->request.data;\r\nptr += strlen("log ");\r\nlen = req->len - (ptr - req->request.data);\r\nprintk(KERN_WARNING "%.*s", len, ptr);\r\nmconsole_reply(req, "", 0, 0);\r\n}\r\nvoid mconsole_proc(struct mc_request *req)\r\n{\r\nstruct vfsmount *mnt = task_active_pid_ns(current)->proc_mnt;\r\nchar *buf;\r\nint len;\r\nstruct file *file;\r\nint first_chunk = 1;\r\nchar *ptr = req->request.data;\r\nptr += strlen("proc");\r\nptr = skip_spaces(ptr);\r\nfile = file_open_root(mnt->mnt_root, mnt, ptr, O_RDONLY);\r\nif (IS_ERR(file)) {\r\nmconsole_reply(req, "Failed to open file", 1, 0);\r\nprintk(KERN_ERR "open /proc/%s: %ld\n", ptr, PTR_ERR(file));\r\ngoto out;\r\n}\r\nbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (buf == NULL) {\r\nmconsole_reply(req, "Failed to allocate buffer", 1, 0);\r\ngoto out_fput;\r\n}\r\ndo {\r\nloff_t pos = file->f_pos;\r\nmm_segment_t old_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nlen = vfs_read(file, buf, PAGE_SIZE - 1, &pos);\r\nset_fs(old_fs);\r\nfile->f_pos = pos;\r\nif (len < 0) {\r\nmconsole_reply(req, "Read of file failed", 1, 0);\r\ngoto out_free;\r\n}\r\nif (first_chunk) {\r\nmconsole_reply(req, "\n", 0, 1);\r\nfirst_chunk = 0;\r\n}\r\nbuf[len] = '\0';\r\nmconsole_reply(req, buf, 0, (len > 0));\r\n} while (len > 0);\r\nout_free:\r\nkfree(buf);\r\nout_fput:\r\nfput(file);\r\nout: ;\r\n}\r\nvoid mconsole_help(struct mc_request *req)\r\n{\r\nmconsole_reply(req, UML_MCONSOLE_HELPTEXT, 0, 0);\r\n}\r\nvoid mconsole_halt(struct mc_request *req)\r\n{\r\nmconsole_reply(req, "", 0, 0);\r\nmachine_halt();\r\n}\r\nvoid mconsole_reboot(struct mc_request *req)\r\n{\r\nmconsole_reply(req, "", 0, 0);\r\nmachine_restart(NULL);\r\n}\r\nvoid mconsole_cad(struct mc_request *req)\r\n{\r\nmconsole_reply(req, "", 0, 0);\r\nctrl_alt_del();\r\n}\r\nvoid mconsole_go(struct mc_request *req)\r\n{\r\nmconsole_reply(req, "Not stopped", 1, 0);\r\n}\r\nvoid mconsole_stop(struct mc_request *req)\r\n{\r\ndeactivate_fd(req->originating_fd, MCONSOLE_IRQ);\r\nos_set_fd_block(req->originating_fd, 1);\r\nmconsole_reply(req, "stopped", 0, 0);\r\nfor (;;) {\r\nif (!mconsole_get_request(req->originating_fd, req))\r\ncontinue;\r\nif (req->cmd->handler == mconsole_go)\r\nbreak;\r\nif (req->cmd->handler == mconsole_stop) {\r\nmconsole_reply(req, "Already stopped", 1, 0);\r\ncontinue;\r\n}\r\nif (req->cmd->handler == mconsole_sysrq) {\r\nstruct pt_regs *old_regs;\r\nold_regs = set_irq_regs((struct pt_regs *)&req->regs);\r\nmconsole_sysrq(req);\r\nset_irq_regs(old_regs);\r\ncontinue;\r\n}\r\n(*req->cmd->handler)(req);\r\n}\r\nos_set_fd_block(req->originating_fd, 0);\r\nreactivate_fd(req->originating_fd, MCONSOLE_IRQ);\r\nmconsole_reply(req, "", 0, 0);\r\n}\r\nvoid mconsole_register_dev(struct mc_device *new)\r\n{\r\nspin_lock(&mc_devices_lock);\r\nBUG_ON(!list_empty(&new->list));\r\nlist_add(&new->list, &mconsole_devices);\r\nspin_unlock(&mc_devices_lock);\r\n}\r\nstatic struct mc_device *mconsole_find_dev(char *name)\r\n{\r\nstruct list_head *ele;\r\nstruct mc_device *dev;\r\nlist_for_each(ele, &mconsole_devices) {\r\ndev = list_entry(ele, struct mc_device, list);\r\nif (!strncmp(name, dev->name, strlen(dev->name)))\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mem_config(char *str, char **error_out)\r\n{\r\nunsigned long long diff;\r\nint err = -EINVAL, i, add;\r\nchar *ret;\r\nif (str[0] != '=') {\r\n*error_out = "Expected '=' after 'mem'";\r\ngoto out;\r\n}\r\nstr++;\r\nif (str[0] == '-')\r\nadd = 0;\r\nelse if (str[0] == '+') {\r\nadd = 1;\r\n}\r\nelse {\r\n*error_out = "Expected increment to start with '-' or '+'";\r\ngoto out;\r\n}\r\nstr++;\r\ndiff = memparse(str, &ret);\r\nif (*ret != '\0') {\r\n*error_out = "Failed to parse memory increment";\r\ngoto out;\r\n}\r\ndiff /= PAGE_SIZE;\r\nmutex_lock(&plug_mem_mutex);\r\nfor (i = 0; i < diff; i++) {\r\nstruct unplugged_pages *unplugged;\r\nvoid *addr;\r\nif (add) {\r\nif (list_empty(&unplugged_pages))\r\nbreak;\r\nunplugged = list_entry(unplugged_pages.next,\r\nstruct unplugged_pages, list);\r\nif (unplug_index > 0)\r\naddr = unplugged->pages[--unplug_index];\r\nelse {\r\nlist_del(&unplugged->list);\r\naddr = unplugged;\r\nunplug_index = UNPLUGGED_PER_PAGE;\r\n}\r\nfree_page((unsigned long) addr);\r\nunplugged_pages_count--;\r\n}\r\nelse {\r\nstruct page *page;\r\npage = alloc_page(GFP_ATOMIC);\r\nif (page == NULL)\r\nbreak;\r\nunplugged = page_address(page);\r\nif (unplug_index == UNPLUGGED_PER_PAGE) {\r\nlist_add(&unplugged->list, &unplugged_pages);\r\nunplug_index = 0;\r\n}\r\nelse {\r\nstruct list_head *entry = unplugged_pages.next;\r\naddr = unplugged;\r\nunplugged = list_entry(entry,\r\nstruct unplugged_pages,\r\nlist);\r\nerr = os_drop_memory(addr, PAGE_SIZE);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to release "\r\n"memory - errno = %d\n", err);\r\n*error_out = "Failed to release memory";\r\ngoto out_unlock;\r\n}\r\nunplugged->pages[unplug_index++] = addr;\r\n}\r\nunplugged_pages_count++;\r\n}\r\n}\r\nerr = 0;\r\nout_unlock:\r\nmutex_unlock(&plug_mem_mutex);\r\nout:\r\nreturn err;\r\n}\r\nstatic int mem_get_config(char *name, char *str, int size, char **error_out)\r\n{\r\nchar buf[sizeof("18446744073709551615")];\r\nint len = 0;\r\nsprintf(buf, "%ld", uml_physmem);\r\nCONFIG_CHUNK(str, size, len, buf, 1);\r\nreturn len;\r\n}\r\nstatic int mem_id(char **str, int *start_out, int *end_out)\r\n{\r\n*start_out = 0;\r\n*end_out = 0;\r\nreturn 0;\r\n}\r\nstatic int mem_remove(int n, char **error_out)\r\n{\r\n*error_out = "Memory doesn't support the remove operation";\r\nreturn -EBUSY;\r\n}\r\nstatic int __init mem_mc_init(void)\r\n{\r\nif (can_drop_memory())\r\nmconsole_register_dev(&mem_mc);\r\nelse printk(KERN_ERR "Can't release memory to the host - memory "\r\n"hotplug won't be supported\n");\r\nreturn 0;\r\n}\r\nstatic void mconsole_get_config(int (*get_config)(char *, char *, int,\r\nchar **),\r\nstruct mc_request *req, char *name)\r\n{\r\nchar default_buf[CONFIG_BUF_SIZE], *error, *buf;\r\nint n, size;\r\nif (get_config == NULL) {\r\nmconsole_reply(req, "No get_config routine defined", 1, 0);\r\nreturn;\r\n}\r\nerror = NULL;\r\nsize = ARRAY_SIZE(default_buf);\r\nbuf = default_buf;\r\nwhile (1) {\r\nn = (*get_config)(name, buf, size, &error);\r\nif (error != NULL) {\r\nmconsole_reply(req, error, 1, 0);\r\ngoto out;\r\n}\r\nif (n <= size) {\r\nmconsole_reply(req, buf, 0, 0);\r\ngoto out;\r\n}\r\nif (buf != default_buf)\r\nkfree(buf);\r\nsize = n;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (buf == NULL) {\r\nmconsole_reply(req, "Failed to allocate buffer", 1, 0);\r\nreturn;\r\n}\r\n}\r\nout:\r\nif (buf != default_buf)\r\nkfree(buf);\r\n}\r\nvoid mconsole_config(struct mc_request *req)\r\n{\r\nstruct mc_device *dev;\r\nchar *ptr = req->request.data, *name, *error_string = "";\r\nint err;\r\nptr += strlen("config");\r\nptr = skip_spaces(ptr);\r\ndev = mconsole_find_dev(ptr);\r\nif (dev == NULL) {\r\nmconsole_reply(req, "Bad configuration option", 1, 0);\r\nreturn;\r\n}\r\nname = &ptr[strlen(dev->name)];\r\nptr = name;\r\nwhile ((*ptr != '=') && (*ptr != '\0'))\r\nptr++;\r\nif (*ptr == '=') {\r\nerr = (*dev->config)(name, &error_string);\r\nmconsole_reply(req, error_string, err, 0);\r\n}\r\nelse mconsole_get_config(dev->get_config, req, name);\r\n}\r\nvoid mconsole_remove(struct mc_request *req)\r\n{\r\nstruct mc_device *dev;\r\nchar *ptr = req->request.data, *err_msg = "";\r\nchar error[256];\r\nint err, start, end, n;\r\nptr += strlen("remove");\r\nptr = skip_spaces(ptr);\r\ndev = mconsole_find_dev(ptr);\r\nif (dev == NULL) {\r\nmconsole_reply(req, "Bad remove option", 1, 0);\r\nreturn;\r\n}\r\nptr = &ptr[strlen(dev->name)];\r\nerr = 1;\r\nn = (*dev->id)(&ptr, &start, &end);\r\nif (n < 0) {\r\nerr_msg = "Couldn't parse device number";\r\ngoto out;\r\n}\r\nelse if ((n < start) || (n > end)) {\r\nsprintf(error, "Invalid device number - must be between "\r\n"%d and %d", start, end);\r\nerr_msg = error;\r\ngoto out;\r\n}\r\nerr_msg = NULL;\r\nerr = (*dev->remove)(n, &err_msg);\r\nswitch(err) {\r\ncase 0:\r\nerr_msg = "";\r\nbreak;\r\ncase -ENODEV:\r\nif (err_msg == NULL)\r\nerr_msg = "Device doesn't exist";\r\nbreak;\r\ncase -EBUSY:\r\nif (err_msg == NULL)\r\nerr_msg = "Device is currently open";\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nmconsole_reply(req, err_msg, err, 0);\r\n}\r\nstatic void console_write(struct console *console, const char *string,\r\nunsigned int len)\r\n{\r\nstruct list_head *ele;\r\nint n;\r\nif (list_empty(&clients))\r\nreturn;\r\nwhile (len > 0) {\r\nn = min((size_t) len, ARRAY_SIZE(console_buf));\r\nstrncpy(console_buf, string, n);\r\nstring += n;\r\nlen -= n;\r\nlist_for_each(ele, &clients) {\r\nstruct mconsole_output *entry;\r\nentry = list_entry(ele, struct mconsole_output, list);\r\nmconsole_reply_len(entry->req, console_buf, n, 0, 1);\r\n}\r\n}\r\n}\r\nstatic int mc_add_console(void)\r\n{\r\nregister_console(&mc_console);\r\nreturn 0;\r\n}\r\nstatic void with_console(struct mc_request *req, void (*proc)(void *),\r\nvoid *arg)\r\n{\r\nstruct mconsole_output entry;\r\nunsigned long flags;\r\nentry.req = req;\r\nspin_lock_irqsave(&client_lock, flags);\r\nlist_add(&entry.list, &clients);\r\nspin_unlock_irqrestore(&client_lock, flags);\r\n(*proc)(arg);\r\nmconsole_reply_len(req, "", 0, 0, 0);\r\nspin_lock_irqsave(&client_lock, flags);\r\nlist_del(&entry.list);\r\nspin_unlock_irqrestore(&client_lock, flags);\r\n}\r\nstatic void sysrq_proc(void *arg)\r\n{\r\nchar *op = arg;\r\nhandle_sysrq(*op);\r\n}\r\nvoid mconsole_sysrq(struct mc_request *req)\r\n{\r\nchar *ptr = req->request.data;\r\nptr += strlen("sysrq");\r\nptr = skip_spaces(ptr);\r\nif (*ptr == 'b')\r\nmconsole_reply(req, "", 0, 0);\r\nwith_console(req, sysrq_proc, ptr);\r\n}\r\nvoid mconsole_sysrq(struct mc_request *req)\r\n{\r\nmconsole_reply(req, "Sysrq not compiled in", 1, 0);\r\n}\r\nstatic void stack_proc(void *arg)\r\n{\r\nstruct task_struct *task = arg;\r\nshow_stack(task, NULL);\r\n}\r\nvoid mconsole_stack(struct mc_request *req)\r\n{\r\nchar *ptr = req->request.data;\r\nint pid_requested= -1;\r\nstruct task_struct *to = NULL;\r\nptr += strlen("stack");\r\nptr = skip_spaces(ptr);\r\nif (sscanf(ptr, "%d", &pid_requested) == 0) {\r\nmconsole_reply(req, "Please specify a pid", 1, 0);\r\nreturn;\r\n}\r\nto = find_task_by_pid_ns(pid_requested, &init_pid_ns);\r\nif ((to == NULL) || (pid_requested == 0)) {\r\nmconsole_reply(req, "Couldn't find that pid", 1, 0);\r\nreturn;\r\n}\r\nwith_console(req, stack_proc, to);\r\n}\r\nstatic int __init mconsole_init(void)\r\n{\r\nlong sock;\r\nint err;\r\nchar file[UNIX_PATH_MAX];\r\nif (umid_file_name("mconsole", file, sizeof(file)))\r\nreturn -1;\r\nsnprintf(mconsole_socket_name, sizeof(file), "%s", file);\r\nsock = os_create_unix_socket(file, sizeof(file), 1);\r\nif (sock < 0) {\r\nprintk(KERN_ERR "Failed to initialize management console\n");\r\nreturn 1;\r\n}\r\nif (os_set_fd_block(sock, 0))\r\ngoto out;\r\nregister_reboot_notifier(&reboot_notifier);\r\nerr = um_request_irq(MCONSOLE_IRQ, sock, IRQ_READ, mconsole_interrupt,\r\nIRQF_SHARED, "mconsole", (void *)sock);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to get IRQ for management console\n");\r\ngoto out;\r\n}\r\nif (notify_socket != NULL) {\r\nnotify_socket = kstrdup(notify_socket, GFP_KERNEL);\r\nif (notify_socket != NULL)\r\nmconsole_notify(notify_socket, MCONSOLE_SOCKET,\r\nmconsole_socket_name,\r\nstrlen(mconsole_socket_name) + 1);\r\nelse printk(KERN_ERR "mconsole_setup failed to strdup "\r\n"string\n");\r\n}\r\nprintk(KERN_INFO "mconsole (version %d) initialized on %s\n",\r\nMCONSOLE_VERSION, mconsole_socket_name);\r\nreturn 0;\r\nout:\r\nos_close_file(sock);\r\nreturn 1;\r\n}\r\nstatic ssize_t mconsole_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nchar *buf;\r\nbuf = kmalloc(count + 1, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, buffer, count)) {\r\ncount = -EFAULT;\r\ngoto out;\r\n}\r\nbuf[count] = '\0';\r\nmconsole_notify(notify_socket, MCONSOLE_USER_NOTIFY, buf, count);\r\nout:\r\nkfree(buf);\r\nreturn count;\r\n}\r\nstatic int create_proc_mconsole(void)\r\n{\r\nstruct proc_dir_entry *ent;\r\nif (notify_socket == NULL)\r\nreturn 0;\r\nent = proc_create("mconsole", 0200, NULL, &mconsole_proc_fops);\r\nif (ent == NULL) {\r\nprintk(KERN_INFO "create_proc_mconsole : proc_create failed\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid lock_notify(void)\r\n{\r\nspin_lock(&notify_spinlock);\r\n}\r\nvoid unlock_notify(void)\r\n{\r\nspin_unlock(&notify_spinlock);\r\n}\r\nstatic int mconsole_setup(char *str)\r\n{\r\nif (!strncmp(str, NOTIFY, strlen(NOTIFY))) {\r\nstr += strlen(NOTIFY);\r\nnotify_socket = str;\r\n}\r\nelse printk(KERN_ERR "mconsole_setup : Unknown option - '%s'\n", str);\r\nreturn 1;\r\n}\r\nstatic int notify_panic(struct notifier_block *self, unsigned long unused1,\r\nvoid *ptr)\r\n{\r\nchar *message = ptr;\r\nif (notify_socket == NULL)\r\nreturn 0;\r\nmconsole_notify(notify_socket, MCONSOLE_PANIC, message,\r\nstrlen(message) + 1);\r\nreturn 0;\r\n}\r\nstatic int add_notifier(void)\r\n{\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&panic_exit_notifier);\r\nreturn 0;\r\n}\r\nchar *mconsole_notify_socket(void)\r\n{\r\nreturn notify_socket;\r\n}
