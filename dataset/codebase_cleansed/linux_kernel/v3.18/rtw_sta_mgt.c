static void _rtw_init_stainfo(struct sta_info *psta)\r\n{\r\nmemset((u8 *)psta, 0, sizeof (struct sta_info));\r\nspin_lock_init(&psta->lock);\r\nINIT_LIST_HEAD(&psta->list);\r\nINIT_LIST_HEAD(&psta->hash_list);\r\n_rtw_init_queue(&psta->sleep_q);\r\npsta->sleepq_len = 0;\r\n_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);\r\n_rtw_init_sta_recv_priv(&psta->sta_recvpriv);\r\n#ifdef CONFIG_88EU_AP_MODE\r\nINIT_LIST_HEAD(&psta->asoc_list);\r\nINIT_LIST_HEAD(&psta->auth_list);\r\npsta->expire_to = 0;\r\npsta->flags = 0;\r\npsta->capability = 0;\r\npsta->bpairwise_key_installed = false;\r\n#ifdef CONFIG_88EU_AP_MODE\r\npsta->nonerp_set = 0;\r\npsta->no_short_slot_time_set = 0;\r\npsta->no_short_preamble_set = 0;\r\npsta->no_ht_gf_set = 0;\r\npsta->no_ht_set = 0;\r\npsta->ht_20mhz_set = 0;\r\n#endif\r\npsta->under_exist_checking = 0;\r\npsta->keep_alive_trycnt = 0;\r\n#endif\r\n}\r\nu32 _rtw_init_sta_priv(struct sta_priv *pstapriv)\r\n{\r\nstruct sta_info *psta;\r\ns32 i;\r\npstapriv->pallocated_stainfo_buf = vzalloc(sizeof(struct sta_info) * NUM_STA + 4);\r\nif (!pstapriv->pallocated_stainfo_buf)\r\nreturn _FAIL;\r\npstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -\r\n((size_t)(pstapriv->pallocated_stainfo_buf) & 3);\r\n_rtw_init_queue(&pstapriv->free_sta_queue);\r\nspin_lock_init(&pstapriv->sta_hash_lock);\r\npstapriv->asoc_sta_count = 0;\r\n_rtw_init_queue(&pstapriv->sleep_q);\r\n_rtw_init_queue(&pstapriv->wakeup_q);\r\npsta = (struct sta_info *)(pstapriv->pstainfo_buf);\r\nfor (i = 0; i < NUM_STA; i++) {\r\n_rtw_init_stainfo(psta);\r\nINIT_LIST_HEAD(&(pstapriv->sta_hash[i]));\r\nlist_add_tail(&psta->list, get_list_head(&pstapriv->free_sta_queue));\r\npsta++;\r\n}\r\n#ifdef CONFIG_88EU_AP_MODE\r\npstapriv->sta_dz_bitmap = 0;\r\npstapriv->tim_bitmap = 0;\r\nINIT_LIST_HEAD(&pstapriv->asoc_list);\r\nINIT_LIST_HEAD(&pstapriv->auth_list);\r\nspin_lock_init(&pstapriv->asoc_list_lock);\r\nspin_lock_init(&pstapriv->auth_list_lock);\r\npstapriv->asoc_list_cnt = 0;\r\npstapriv->auth_list_cnt = 0;\r\npstapriv->auth_to = 3;\r\npstapriv->assoc_to = 3;\r\npstapriv->expire_to = 3;\r\npstapriv->max_num_sta = NUM_STA;\r\n#endif\r\nreturn _SUCCESS;\r\n}\r\ninline int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta)\r\n{\r\nint offset = (((u8 *)sta) - stapriv->pstainfo_buf)/sizeof(struct sta_info);\r\nif (!stainfo_offset_valid(offset))\r\nDBG_88E("%s invalid offset(%d), out of range!!!", __func__, offset);\r\nreturn offset;\r\n}\r\ninline struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv, int offset)\r\n{\r\nif (!stainfo_offset_valid(offset))\r\nDBG_88E("%s invalid offset(%d), out of range!!!", __func__, offset);\r\nreturn (struct sta_info *)(stapriv->pstainfo_buf + offset * sizeof(struct sta_info));\r\n}\r\nstatic void rtw_mfree_all_stainfo(struct sta_priv *pstapriv)\r\n{\r\nstruct list_head *plist, *phead;\r\nstruct sta_info *psta = NULL;\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nphead = get_list_head(&pstapriv->free_sta_queue);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npsta = container_of(plist, struct sta_info , list);\r\nplist = plist->next;\r\n}\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\n}\r\nstatic void rtw_mfree_sta_priv_lock(struct sta_priv *pstapriv)\r\n{\r\nrtw_mfree_all_stainfo(pstapriv);\r\n}\r\nu32 _rtw_free_sta_priv(struct sta_priv *pstapriv)\r\n{\r\nstruct list_head *phead, *plist;\r\nstruct sta_info *psta = NULL;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nint index;\r\nif (pstapriv) {\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nfor (index = 0; index < NUM_STA; index++) {\r\nphead = &(pstapriv->sta_hash[index]);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\nint i;\r\npsta = container_of(plist, struct sta_info , hash_list);\r\nplist = plist->next;\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\ndel_timer_sync(&preorder_ctrl->reordering_ctrl_timer);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nrtw_mfree_sta_priv_lock(pstapriv);\r\nif (pstapriv->pallocated_stainfo_buf)\r\nvfree(pstapriv->pallocated_stainfo_buf);\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstruct sta_info *rtw_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\r\n{\r\ns32 index;\r\nstruct list_head *phash_list;\r\nstruct sta_info *psta;\r\nstruct __queue *pfree_sta_queue;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nint i = 0;\r\nu16 wRxSeqInitialValue = 0xffff;\r\npfree_sta_queue = &pstapriv->free_sta_queue;\r\nspin_lock_bh(&(pfree_sta_queue->lock));\r\nif (list_empty(&pfree_sta_queue->queue)) {\r\nspin_unlock_bh(&pfree_sta_queue->lock);\r\npsta = NULL;\r\n} else {\r\npsta = container_of((&pfree_sta_queue->queue)->next, struct sta_info, list);\r\nlist_del_init(&(psta->list));\r\nspin_unlock_bh(&pfree_sta_queue->lock);\r\n_rtw_init_stainfo(psta);\r\nmemcpy(psta->hwaddr, hwaddr, ETH_ALEN);\r\nindex = wifi_mac_hash(hwaddr);\r\nRT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_info_, ("rtw_alloc_stainfo: index=%x", index));\r\nif (index >= NUM_STA) {\r\nRT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_err_, ("ERROR => rtw_alloc_stainfo: index >= NUM_STA"));\r\npsta = NULL;\r\ngoto exit;\r\n}\r\nphash_list = &(pstapriv->sta_hash[index]);\r\nspin_lock_bh(&(pstapriv->sta_hash_lock));\r\nlist_add_tail(&psta->hash_list, phash_list);\r\npstapriv->asoc_sta_count++;\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nfor (i = 0; i < 16; i++)\r\nmemcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i], &wRxSeqInitialValue, 2);\r\nRT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_info_,\r\n("alloc number_%d stainfo with hwaddr = %pM\n",\r\npstapriv->asoc_sta_count , hwaddr));\r\ninit_addba_retry_timer(pstapriv->padapter, psta);\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\npreorder_ctrl->padapter = pstapriv->padapter;\r\npreorder_ctrl->enable = false;\r\npreorder_ctrl->indicate_seq = 0xffff;\r\npreorder_ctrl->wend_b = 0xffff;\r\npreorder_ctrl->wsize_b = 64;\r\n_rtw_init_queue(&preorder_ctrl->pending_recvframe_queue);\r\nrtw_init_recv_timer(preorder_ctrl);\r\n}\r\npsta->rssi_stat.UndecoratedSmoothedPWDB = (-1);\r\npsta->rssi_stat.UndecoratedSmoothedCCK = (-1);\r\npsta->RxMgmtFrameSeqNum = 0xffff;\r\n}\r\nexit:\r\nreturn psta;\r\n}\r\nu32 rtw_free_stainfo(struct adapter *padapter , struct sta_info *psta)\r\n{\r\nint i;\r\nstruct __queue *pfree_sta_queue;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct sta_xmit_priv *pstaxmitpriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (psta == NULL)\r\ngoto exit;\r\npfree_sta_queue = &pstapriv->free_sta_queue;\r\npstaxmitpriv = &psta->sta_xmitpriv;\r\nspin_lock_bh(&pxmitpriv->lock);\r\nrtw_free_xmitframe_queue(pxmitpriv, &psta->sleep_q);\r\npsta->sleepq_len = 0;\r\nrtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->vo_q.tx_pending));\r\nrtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->vi_q.tx_pending));\r\nrtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->bk_q.tx_pending));\r\nrtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);\r\nlist_del_init(&(pstaxmitpriv->be_q.tx_pending));\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nlist_del_init(&psta->hash_list);\r\nRT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_err_, ("\n free number_%d stainfo with hwaddr=0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n", pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2], psta->hwaddr[3], psta->hwaddr[4], psta->hwaddr[5]));\r\npstapriv->asoc_sta_count--;\r\n_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);\r\n_rtw_init_sta_recv_priv(&psta->sta_recvpriv);\r\ndel_timer_sync(&psta->addba_retry_timer);\r\nfor (i = 0; i < 16; i++) {\r\nstruct list_head *phead, *plist;\r\nstruct recv_frame *prhdr;\r\nstruct recv_frame *prframe;\r\nstruct __queue *ppending_recvframe_queue;\r\nstruct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\ndel_timer_sync(&preorder_ctrl->reordering_ctrl_timer);\r\nppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;\r\nspin_lock_bh(&ppending_recvframe_queue->lock);\r\nphead = get_list_head(ppending_recvframe_queue);\r\nplist = phead->next;\r\nwhile (!list_empty(phead)) {\r\nprhdr = container_of(plist, struct recv_frame, list);\r\nprframe = (struct recv_frame *)prhdr;\r\nplist = plist->next;\r\nlist_del_init(&(prframe->list));\r\nrtw_free_recvframe(prframe, pfree_recv_queue);\r\n}\r\nspin_unlock_bh(&ppending_recvframe_queue->lock);\r\n}\r\nif (!(psta->state & WIFI_AP_STATE))\r\nrtw_hal_set_odm_var(padapter, HAL_ODM_STA_INFO, psta, false);\r\n#ifdef CONFIG_88EU_AP_MODE\r\nspin_lock_bh(&pstapriv->auth_list_lock);\r\nif (!list_empty(&psta->auth_list)) {\r\nlist_del_init(&psta->auth_list);\r\npstapriv->auth_list_cnt--;\r\n}\r\nspin_unlock_bh(&pstapriv->auth_list_lock);\r\npsta->expire_to = 0;\r\npsta->sleepq_ac_len = 0;\r\npsta->qos_info = 0;\r\npsta->max_sp_len = 0;\r\npsta->uapsd_bk = 0;\r\npsta->uapsd_be = 0;\r\npsta->uapsd_vi = 0;\r\npsta->uapsd_vo = 0;\r\npsta->has_legacy_ac = 0;\r\npstapriv->sta_dz_bitmap &= ~BIT(psta->aid);\r\npstapriv->tim_bitmap &= ~BIT(psta->aid);\r\nif ((psta->aid > 0) && (pstapriv->sta_aid[psta->aid - 1] == psta)) {\r\npstapriv->sta_aid[psta->aid - 1] = NULL;\r\npsta->aid = 0;\r\n}\r\npsta->under_exist_checking = 0;\r\n#endif\r\nspin_lock_bh(&(pfree_sta_queue->lock));\r\nlist_add_tail(&psta->list, get_list_head(pfree_sta_queue));\r\nspin_unlock_bh(&pfree_sta_queue->lock);\r\nexit:\r\nreturn _SUCCESS;\r\n}\r\nvoid rtw_free_all_stainfo(struct adapter *padapter)\r\n{\r\nstruct list_head *plist, *phead;\r\ns32 index;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *pbcmc_stainfo = rtw_get_bcmc_stainfo(padapter);\r\nif (pstapriv->asoc_sta_count == 1)\r\nreturn;\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nfor (index = 0; index < NUM_STA; index++) {\r\nphead = &(pstapriv->sta_hash[index]);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npsta = container_of(plist, struct sta_info , hash_list);\r\nplist = plist->next;\r\nif (pbcmc_stainfo != psta)\r\nrtw_free_stainfo(padapter , psta);\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\n}\r\nstruct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)\r\n{\r\nstruct list_head *plist, *phead;\r\nstruct sta_info *psta = NULL;\r\nu32 index;\r\nu8 *addr;\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nif (hwaddr == NULL)\r\nreturn NULL;\r\nif (IS_MCAST(hwaddr))\r\naddr = bc_addr;\r\nelse\r\naddr = hwaddr;\r\nindex = wifi_mac_hash(addr);\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nphead = &(pstapriv->sta_hash[index]);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npsta = container_of(plist, struct sta_info, hash_list);\r\nif ((!memcmp(psta->hwaddr, addr, ETH_ALEN)) == true) {\r\nbreak;\r\n}\r\npsta = NULL;\r\nplist = plist->next;\r\n}\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nreturn psta;\r\n}\r\nu32 rtw_init_bcmc_stainfo(struct adapter *padapter)\r\n{\r\nstruct sta_info *psta;\r\nu32 res = _SUCCESS;\r\nunsigned char bcast_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\npsta = rtw_alloc_stainfo(pstapriv, bcast_addr);\r\nif (psta == NULL) {\r\nres = _FAIL;\r\nRT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_err_, ("rtw_alloc_stainfo fail"));\r\ngoto exit;\r\n}\r\npsta->mac_id = 1;\r\nexit:\r\nreturn res;\r\n}\r\nstruct sta_info *rtw_get_bcmc_stainfo(struct adapter *padapter)\r\n{\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\npsta = rtw_get_stainfo(pstapriv, bc_addr);\r\nreturn psta;\r\n}\r\nu8 rtw_access_ctrl(struct adapter *padapter, u8 *mac_addr)\r\n{\r\nu8 res = true;\r\n#ifdef CONFIG_88EU_AP_MODE\r\nstruct list_head *plist, *phead;\r\nstruct rtw_wlan_acl_node *paclnode;\r\nu8 match = false;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nstruct __queue *pacl_node_q = &pacl_list->acl_node_q;\r\nspin_lock_bh(&(pacl_node_q->lock));\r\nphead = get_list_head(pacl_node_q);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npaclnode = container_of(plist, struct rtw_wlan_acl_node, list);\r\nplist = plist->next;\r\nif (!memcmp(paclnode->addr, mac_addr, ETH_ALEN)) {\r\nif (paclnode->valid) {\r\nmatch = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pacl_node_q->lock);\r\nif (pacl_list->mode == 1)\r\nres = (match) ? false : true;\r\nelse if (pacl_list->mode == 2)\r\nres = (match) ? true : false;\r\nelse\r\nres = true;\r\n#endif\r\nreturn res;\r\n}
