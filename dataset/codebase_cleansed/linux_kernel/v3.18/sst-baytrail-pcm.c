static int sst_byt_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct sst_byt_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct sst_byt_pcm_data *pcm_data = &pdata->pcm[substream->stream];\r\nstruct sst_byt *byt = pdata->byt;\r\nu32 rate, bits;\r\nu8 channels;\r\nint ret, playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\r\ndev_dbg(rtd->dev, "PCM: hw_params, pcm_data %p\n", pcm_data);\r\nret = sst_byt_stream_type(byt, pcm_data->stream,\r\n1, 1, !playback);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "failed to set stream format %d\n", ret);\r\nreturn ret;\r\n}\r\nrate = params_rate(params);\r\nret = sst_byt_stream_set_rate(byt, pcm_data->stream, rate);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "could not set rate %d\n", rate);\r\nreturn ret;\r\n}\r\nbits = snd_pcm_format_width(params_format(params));\r\nret = sst_byt_stream_set_bits(byt, pcm_data->stream, bits);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "could not set formats %d\n",\r\nparams_rate(params));\r\nreturn ret;\r\n}\r\nchannels = (u8)(params_channels(params) & 0xF);\r\nret = sst_byt_stream_set_channels(byt, pcm_data->stream, channels);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "could not set channels %d\n",\r\nparams_rate(params));\r\nreturn ret;\r\n}\r\nsnd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nret = sst_byt_stream_buffer(byt, pcm_data->stream,\r\nsubstream->dma_buffer.addr,\r\nparams_buffer_bytes(params));\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "PCM: failed to set DMA buffer %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sst_byt_stream_commit(byt, pcm_data->stream);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "PCM: failed stream commit %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_byt_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\ndev_dbg(rtd->dev, "PCM: hw_free\n");\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int sst_byt_pcm_restore_stream_context(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct sst_byt_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct sst_byt_pcm_data *pcm_data = &pdata->pcm[substream->stream];\r\nstruct sst_byt *byt = pdata->byt;\r\nint ret;\r\nret = sst_byt_stream_commit(byt, pcm_data->stream);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "PCM: failed stream commit %d\n", ret);\r\nreturn ret;\r\n}\r\nsst_byt_stream_start(byt, pcm_data->stream, pcm_data->hw_ptr);\r\ndev_dbg(rtd->dev, "stream context restored at offset %d\n",\r\npcm_data->hw_ptr);\r\nreturn 0;\r\n}\r\nstatic void sst_byt_pcm_work(struct work_struct *work)\r\n{\r\nstruct sst_byt_pcm_data *pcm_data =\r\ncontainer_of(work, struct sst_byt_pcm_data, work);\r\nif (snd_pcm_running(pcm_data->substream))\r\nsst_byt_pcm_restore_stream_context(pcm_data->substream);\r\n}\r\nstatic int sst_byt_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct sst_byt_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct sst_byt_pcm_data *pcm_data = &pdata->pcm[substream->stream];\r\nstruct sst_byt *byt = pdata->byt;\r\ndev_dbg(rtd->dev, "PCM: trigger %d\n", cmd);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\npcm_data->hw_ptr = 0;\r\nsst_byt_stream_start(byt, pcm_data->stream, 0);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (pdata->restore_stream == true)\r\nschedule_work(&pcm_data->work);\r\nelse\r\nsst_byt_stream_resume(byt, pcm_data->stream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nsst_byt_stream_resume(byt, pcm_data->stream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nsst_byt_stream_stop(byt, pcm_data->stream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\npdata->restore_stream = false;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nsst_byt_stream_pause(byt, pcm_data->stream);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 byt_notify_pointer(struct sst_byt_stream *stream, void *data)\r\n{\r\nstruct sst_byt_pcm_data *pcm_data = data;\r\nstruct snd_pcm_substream *substream = pcm_data->substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct sst_byt_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct sst_byt *byt = pdata->byt;\r\nu32 pos, hw_pos;\r\nhw_pos = sst_byt_get_dsp_position(byt, pcm_data->stream,\r\nsnd_pcm_lib_buffer_bytes(substream));\r\npcm_data->hw_ptr = hw_pos;\r\npos = frames_to_bytes(runtime,\r\n(runtime->control->appl_ptr %\r\nruntime->buffer_size));\r\ndev_dbg(rtd->dev, "PCM: App/DMA pointer %u/%u bytes\n", pos, hw_pos);\r\nsnd_pcm_period_elapsed(substream);\r\nreturn pos;\r\n}\r\nstatic snd_pcm_uframes_t sst_byt_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sst_byt_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct sst_byt_pcm_data *pcm_data = &pdata->pcm[substream->stream];\r\ndev_dbg(rtd->dev, "PCM: DMA pointer %u bytes\n", pcm_data->hw_ptr);\r\nreturn bytes_to_frames(runtime, pcm_data->hw_ptr);\r\n}\r\nstatic int sst_byt_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct sst_byt_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct sst_byt_pcm_data *pcm_data = &pdata->pcm[substream->stream];\r\nstruct sst_byt *byt = pdata->byt;\r\ndev_dbg(rtd->dev, "PCM: open\n");\r\nmutex_lock(&pcm_data->mutex);\r\npcm_data->substream = substream;\r\nsnd_soc_set_runtime_hwparams(substream, &sst_byt_pcm_hardware);\r\npcm_data->stream = sst_byt_stream_new(byt, substream->stream + 1,\r\nbyt_notify_pointer, pcm_data);\r\nif (pcm_data->stream == NULL) {\r\ndev_err(rtd->dev, "failed to create stream\n");\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn 0;\r\n}\r\nstatic int sst_byt_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct sst_byt_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct sst_byt_pcm_data *pcm_data = &pdata->pcm[substream->stream];\r\nstruct sst_byt *byt = pdata->byt;\r\nint ret;\r\ndev_dbg(rtd->dev, "PCM: close\n");\r\ncancel_work_sync(&pcm_data->work);\r\nmutex_lock(&pcm_data->mutex);\r\nret = sst_byt_stream_free(byt, pcm_data->stream);\r\nif (ret < 0) {\r\ndev_dbg(rtd->dev, "Free stream fail\n");\r\ngoto out;\r\n}\r\npcm_data->stream = NULL;\r\nout:\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn ret;\r\n}\r\nstatic int sst_byt_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\ndev_dbg(rtd->dev, "PCM: mmap\n");\r\nreturn snd_pcm_lib_default_mmap(substream, vma);\r\n}\r\nstatic void sst_byt_pcm_free(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic int sst_byt_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nsize_t size;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct sst_pdata *pdata = dev_get_platdata(platform->dev);\r\nint ret = 0;\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream ||\r\npcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nsize = sst_byt_pcm_hardware.buffer_bytes_max;\r\nret = snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_DEV,\r\npdata->dma_dev,\r\nsize, size);\r\nif (ret) {\r\ndev_err(rtd->dev, "dma buffer allocation failed %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sst_byt_pcm_probe(struct snd_soc_platform *platform)\r\n{\r\nstruct sst_pdata *plat_data = dev_get_platdata(platform->dev);\r\nstruct sst_byt_priv_data *priv_data;\r\nint i;\r\nif (!plat_data)\r\nreturn -ENODEV;\r\npriv_data = devm_kzalloc(platform->dev, sizeof(*priv_data),\r\nGFP_KERNEL);\r\npriv_data->byt = plat_data->dsp;\r\nsnd_soc_platform_set_drvdata(platform, priv_data);\r\nfor (i = 0; i < BYT_PCM_COUNT; i++) {\r\nmutex_init(&priv_data->pcm[i].mutex);\r\nINIT_WORK(&priv_data->pcm[i].work, sst_byt_pcm_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_byt_pcm_remove(struct snd_soc_platform *platform)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sst_byt_pcm_dev_suspend_late(struct device *dev)\r\n{\r\nstruct sst_pdata *sst_pdata = dev_get_platdata(dev);\r\nstruct sst_byt_priv_data *priv_data = dev_get_drvdata(dev);\r\nint ret;\r\ndev_dbg(dev, "suspending late\n");\r\nret = sst_byt_dsp_suspend_late(dev, sst_pdata);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to suspend %d\n", ret);\r\nreturn ret;\r\n}\r\npriv_data->restore_stream = true;\r\nreturn ret;\r\n}\r\nstatic int sst_byt_pcm_dev_resume_early(struct device *dev)\r\n{\r\nstruct sst_pdata *sst_pdata = dev_get_platdata(dev);\r\nint ret;\r\ndev_dbg(dev, "resume early\n");\r\nret = sst_byt_dsp_boot(dev, sst_pdata);\r\nif (ret)\r\nreturn ret;\r\nreturn sst_byt_dsp_wait_for_ready(dev, sst_pdata);\r\n}\r\nstatic int sst_byt_pcm_dev_probe(struct platform_device *pdev)\r\n{\r\nstruct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);\r\nint ret;\r\nret = sst_byt_dsp_init(&pdev->dev, sst_pdata);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = snd_soc_register_platform(&pdev->dev, &byt_soc_platform);\r\nif (ret < 0)\r\ngoto err_plat;\r\nret = snd_soc_register_component(&pdev->dev, &byt_dai_component,\r\nbyt_dais, ARRAY_SIZE(byt_dais));\r\nif (ret < 0)\r\ngoto err_comp;\r\nreturn 0;\r\nerr_comp:\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nerr_plat:\r\nsst_byt_dsp_free(&pdev->dev, sst_pdata);\r\nreturn ret;\r\n}\r\nstatic int sst_byt_pcm_dev_remove(struct platform_device *pdev)\r\n{\r\nstruct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nsst_byt_dsp_free(&pdev->dev, sst_pdata);\r\nreturn 0;\r\n}
