static int ivtv_s_stream_vbi_fmt(struct cx2341x_handler *cxhdl, u32 fmt)\r\n{\r\nstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\r\nif (fmt && itv->vbi.sliced_mpeg_data[0] == NULL) {\r\nint i;\r\nfor (i = 0; i < IVTV_VBI_FRAMES; i++) {\r\nitv->vbi.sliced_mpeg_data[i] = kmalloc(2049, GFP_KERNEL);\r\nif (itv->vbi.sliced_mpeg_data[i] == NULL) {\r\nwhile (--i >= 0) {\r\nkfree(itv->vbi.sliced_mpeg_data[i]);\r\nitv->vbi.sliced_mpeg_data[i] = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\n}\r\n}\r\nitv->vbi.insert_mpeg = fmt;\r\nif (itv->vbi.insert_mpeg == 0) {\r\nreturn 0;\r\n}\r\nif (ivtv_get_service_set(itv->vbi.sliced_in) == 0) {\r\nif (itv->is_60hz)\r\nitv->vbi.sliced_in->service_set = V4L2_SLICED_CAPTION_525;\r\nelse\r\nitv->vbi.sliced_in->service_set = V4L2_SLICED_WSS_625;\r\nivtv_expand_service_set(itv->vbi.sliced_in, itv->is_50hz);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_video_encoding(struct cx2341x_handler *cxhdl, u32 val)\r\n{\r\nstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\r\nint is_mpeg1 = val == V4L2_MPEG_VIDEO_ENCODING_MPEG_1;\r\nstruct v4l2_mbus_framefmt fmt;\r\nfmt.width = cxhdl->width / (is_mpeg1 ? 2 : 1);\r\nfmt.height = cxhdl->height;\r\nfmt.code = V4L2_MBUS_FMT_FIXED;\r\nv4l2_subdev_call(itv->sd_video, video, s_mbus_fmt, &fmt);\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_audio_sampling_freq(struct cx2341x_handler *cxhdl, u32 idx)\r\n{\r\nstatic const u32 freqs[3] = { 44100, 48000, 32000 };\r\nstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\r\nif (idx < ARRAY_SIZE(freqs))\r\nivtv_call_all(itv, audio, s_clock_freq, freqs[idx]);\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_audio_mode(struct cx2341x_handler *cxhdl, u32 val)\r\n{\r\nstruct ivtv *itv = container_of(cxhdl, struct ivtv, cxhdl);\r\nitv->dualwatch_stereo_mode = val;\r\nreturn 0;\r\n}\r\nint ivtv_g_pts_frame(struct ivtv *itv, s64 *pts, s64 *frame)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nif (test_bit(IVTV_F_I_VALID_DEC_TIMINGS, &itv->i_flags)) {\r\n*pts = (s64)((u64)itv->last_dec_timing[2] << 32) |\r\n(u64)itv->last_dec_timing[1];\r\n*frame = itv->last_dec_timing[0];\r\nreturn 0;\r\n}\r\n*pts = 0;\r\n*frame = 0;\r\nif (atomic_read(&itv->decoding)) {\r\nif (ivtv_api(itv, CX2341X_DEC_GET_TIMING_INFO, 5, data)) {\r\nIVTV_DEBUG_WARN("GET_TIMING: couldn't read clock\n");\r\nreturn -EIO;\r\n}\r\nmemcpy(itv->last_dec_timing, data, sizeof(itv->last_dec_timing));\r\nset_bit(IVTV_F_I_VALID_DEC_TIMINGS, &itv->i_flags);\r\n*pts = (s64)((u64) data[2] << 32) | (u64) data[1];\r\n*frame = data[0];\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ivtv *itv = container_of(ctrl->handler, struct ivtv, cxhdl.hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_VIDEO_DEC_PTS:\r\nreturn ivtv_g_pts_frame(itv, itv->ctrl_pts->p_new.p_s64,\r\nitv->ctrl_frame->p_new.p_s64);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ivtv *itv = container_of(ctrl->handler, struct ivtv, cxhdl.hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK:\r\nitv->audio_stereo_mode = itv->ctrl_audio_playback->val - 1;\r\nitv->audio_bilingual_mode = itv->ctrl_audio_multilingual_playback->val - 1;\r\nivtv_vapi(itv, CX2341X_DEC_SET_AUDIO_MODE, 2, itv->audio_bilingual_mode, itv->audio_stereo_mode);\r\nbreak;\r\n}\r\nreturn 0;\r\n}
