static inline bool spi_qup_is_valid_state(struct spi_qup *controller)\r\n{\r\nu32 opstate = readl_relaxed(controller->base + QUP_STATE);\r\nreturn opstate & QUP_STATE_VALID;\r\n}\r\nstatic int spi_qup_set_state(struct spi_qup *controller, u32 state)\r\n{\r\nunsigned long loop;\r\nu32 cur_state;\r\nloop = 0;\r\nwhile (!spi_qup_is_valid_state(controller)) {\r\nusleep_range(SPI_DELAY_THRESHOLD, SPI_DELAY_THRESHOLD * 2);\r\nif (++loop > SPI_DELAY_RETRY)\r\nreturn -EIO;\r\n}\r\nif (loop)\r\ndev_dbg(controller->dev, "invalid state for %ld,us %d\n",\r\nloop, state);\r\ncur_state = readl_relaxed(controller->base + QUP_STATE);\r\nif (((cur_state & QUP_STATE_MASK) == QUP_STATE_PAUSE) &&\r\n(state == QUP_STATE_RESET)) {\r\nwritel_relaxed(QUP_STATE_CLEAR, controller->base + QUP_STATE);\r\nwritel_relaxed(QUP_STATE_CLEAR, controller->base + QUP_STATE);\r\n} else {\r\ncur_state &= ~QUP_STATE_MASK;\r\ncur_state |= state;\r\nwritel_relaxed(cur_state, controller->base + QUP_STATE);\r\n}\r\nloop = 0;\r\nwhile (!spi_qup_is_valid_state(controller)) {\r\nusleep_range(SPI_DELAY_THRESHOLD, SPI_DELAY_THRESHOLD * 2);\r\nif (++loop > SPI_DELAY_RETRY)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void spi_qup_fifo_read(struct spi_qup *controller,\r\nstruct spi_transfer *xfer)\r\n{\r\nu8 *rx_buf = xfer->rx_buf;\r\nu32 word, state;\r\nint idx, shift, w_size;\r\nw_size = controller->w_size;\r\nwhile (controller->rx_bytes < xfer->len) {\r\nstate = readl_relaxed(controller->base + QUP_OPERATIONAL);\r\nif (0 == (state & QUP_OP_IN_FIFO_NOT_EMPTY))\r\nbreak;\r\nword = readl_relaxed(controller->base + QUP_INPUT_FIFO);\r\nif (!rx_buf) {\r\ncontroller->rx_bytes += w_size;\r\ncontinue;\r\n}\r\nfor (idx = 0; idx < w_size; idx++, controller->rx_bytes++) {\r\nshift = BITS_PER_BYTE;\r\nshift *= (w_size - idx - 1);\r\nrx_buf[controller->rx_bytes] = word >> shift;\r\n}\r\n}\r\n}\r\nstatic void spi_qup_fifo_write(struct spi_qup *controller,\r\nstruct spi_transfer *xfer)\r\n{\r\nconst u8 *tx_buf = xfer->tx_buf;\r\nu32 word, state, data;\r\nint idx, w_size;\r\nw_size = controller->w_size;\r\nwhile (controller->tx_bytes < xfer->len) {\r\nstate = readl_relaxed(controller->base + QUP_OPERATIONAL);\r\nif (state & QUP_OP_OUT_FIFO_FULL)\r\nbreak;\r\nword = 0;\r\nfor (idx = 0; idx < w_size; idx++, controller->tx_bytes++) {\r\nif (!tx_buf) {\r\ncontroller->tx_bytes += w_size;\r\nbreak;\r\n}\r\ndata = tx_buf[controller->tx_bytes];\r\nword |= data << (BITS_PER_BYTE * (3 - idx));\r\n}\r\nwritel_relaxed(word, controller->base + QUP_OUTPUT_FIFO);\r\n}\r\n}\r\nstatic irqreturn_t spi_qup_qup_irq(int irq, void *dev_id)\r\n{\r\nstruct spi_qup *controller = dev_id;\r\nstruct spi_transfer *xfer;\r\nu32 opflags, qup_err, spi_err;\r\nunsigned long flags;\r\nint error = 0;\r\nspin_lock_irqsave(&controller->lock, flags);\r\nxfer = controller->xfer;\r\ncontroller->xfer = NULL;\r\nspin_unlock_irqrestore(&controller->lock, flags);\r\nqup_err = readl_relaxed(controller->base + QUP_ERROR_FLAGS);\r\nspi_err = readl_relaxed(controller->base + SPI_ERROR_FLAGS);\r\nopflags = readl_relaxed(controller->base + QUP_OPERATIONAL);\r\nwritel_relaxed(qup_err, controller->base + QUP_ERROR_FLAGS);\r\nwritel_relaxed(spi_err, controller->base + SPI_ERROR_FLAGS);\r\nwritel_relaxed(opflags, controller->base + QUP_OPERATIONAL);\r\nif (!xfer) {\r\ndev_err_ratelimited(controller->dev, "unexpected irq %08x %08x %08x\n",\r\nqup_err, spi_err, opflags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (qup_err) {\r\nif (qup_err & QUP_ERROR_OUTPUT_OVER_RUN)\r\ndev_warn(controller->dev, "OUTPUT_OVER_RUN\n");\r\nif (qup_err & QUP_ERROR_INPUT_UNDER_RUN)\r\ndev_warn(controller->dev, "INPUT_UNDER_RUN\n");\r\nif (qup_err & QUP_ERROR_OUTPUT_UNDER_RUN)\r\ndev_warn(controller->dev, "OUTPUT_UNDER_RUN\n");\r\nif (qup_err & QUP_ERROR_INPUT_OVER_RUN)\r\ndev_warn(controller->dev, "INPUT_OVER_RUN\n");\r\nerror = -EIO;\r\n}\r\nif (spi_err) {\r\nif (spi_err & SPI_ERROR_CLK_OVER_RUN)\r\ndev_warn(controller->dev, "CLK_OVER_RUN\n");\r\nif (spi_err & SPI_ERROR_CLK_UNDER_RUN)\r\ndev_warn(controller->dev, "CLK_UNDER_RUN\n");\r\nerror = -EIO;\r\n}\r\nif (opflags & QUP_OP_IN_SERVICE_FLAG)\r\nspi_qup_fifo_read(controller, xfer);\r\nif (opflags & QUP_OP_OUT_SERVICE_FLAG)\r\nspi_qup_fifo_write(controller, xfer);\r\nspin_lock_irqsave(&controller->lock, flags);\r\ncontroller->error = error;\r\ncontroller->xfer = xfer;\r\nspin_unlock_irqrestore(&controller->lock, flags);\r\nif (controller->rx_bytes == xfer->len || error)\r\ncomplete(&controller->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spi_qup_io_config(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nstruct spi_qup *controller = spi_master_get_devdata(spi->master);\r\nu32 config, iomode, mode;\r\nint ret, n_words, w_size;\r\nif (spi->mode & SPI_LOOP && xfer->len > controller->in_fifo_sz) {\r\ndev_err(controller->dev, "too big size for loopback %d > %d\n",\r\nxfer->len, controller->in_fifo_sz);\r\nreturn -EIO;\r\n}\r\nret = clk_set_rate(controller->cclk, xfer->speed_hz);\r\nif (ret) {\r\ndev_err(controller->dev, "fail to set frequency %d",\r\nxfer->speed_hz);\r\nreturn -EIO;\r\n}\r\nif (spi_qup_set_state(controller, QUP_STATE_RESET)) {\r\ndev_err(controller->dev, "cannot set RESET state\n");\r\nreturn -EIO;\r\n}\r\nw_size = 4;\r\nif (xfer->bits_per_word <= 8)\r\nw_size = 1;\r\nelse if (xfer->bits_per_word <= 16)\r\nw_size = 2;\r\nn_words = xfer->len / w_size;\r\ncontroller->w_size = w_size;\r\nif (n_words <= (controller->in_fifo_sz / sizeof(u32))) {\r\nmode = QUP_IO_M_MODE_FIFO;\r\nwritel_relaxed(n_words, controller->base + QUP_MX_READ_CNT);\r\nwritel_relaxed(n_words, controller->base + QUP_MX_WRITE_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_INPUT_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_OUTPUT_CNT);\r\n} else {\r\nmode = QUP_IO_M_MODE_BLOCK;\r\nwritel_relaxed(n_words, controller->base + QUP_MX_INPUT_CNT);\r\nwritel_relaxed(n_words, controller->base + QUP_MX_OUTPUT_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_READ_CNT);\r\nwritel_relaxed(0, controller->base + QUP_MX_WRITE_CNT);\r\n}\r\niomode = readl_relaxed(controller->base + QUP_IO_M_MODES);\r\niomode &= ~(QUP_IO_M_INPUT_MODE_MASK | QUP_IO_M_OUTPUT_MODE_MASK);\r\niomode &= ~(QUP_IO_M_PACK_EN | QUP_IO_M_UNPACK_EN);\r\niomode |= (mode << QUP_IO_M_OUTPUT_MODE_MASK_SHIFT);\r\niomode |= (mode << QUP_IO_M_INPUT_MODE_MASK_SHIFT);\r\nwritel_relaxed(iomode, controller->base + QUP_IO_M_MODES);\r\nconfig = readl_relaxed(controller->base + SPI_CONFIG);\r\nif (spi->mode & SPI_LOOP)\r\nconfig |= SPI_CONFIG_LOOPBACK;\r\nelse\r\nconfig &= ~SPI_CONFIG_LOOPBACK;\r\nif (spi->mode & SPI_CPHA)\r\nconfig &= ~SPI_CONFIG_INPUT_FIRST;\r\nelse\r\nconfig |= SPI_CONFIG_INPUT_FIRST;\r\nif ((xfer->speed_hz >= SPI_HS_MIN_RATE) && !(spi->mode & SPI_LOOP))\r\nconfig |= SPI_CONFIG_HS_MODE;\r\nelse\r\nconfig &= ~SPI_CONFIG_HS_MODE;\r\nwritel_relaxed(config, controller->base + SPI_CONFIG);\r\nconfig = readl_relaxed(controller->base + QUP_CONFIG);\r\nconfig &= ~(QUP_CONFIG_NO_INPUT | QUP_CONFIG_NO_OUTPUT | QUP_CONFIG_N);\r\nconfig |= xfer->bits_per_word - 1;\r\nconfig |= QUP_CONFIG_SPI_MODE;\r\nwritel_relaxed(config, controller->base + QUP_CONFIG);\r\nif (!controller->qup_v1)\r\nwritel_relaxed(0, controller->base + QUP_OPERATIONAL_MASK);\r\nreturn 0;\r\n}\r\nstatic int spi_qup_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nunsigned long timeout, flags;\r\nint ret = -EIO;\r\nret = spi_qup_io_config(spi, xfer);\r\nif (ret)\r\nreturn ret;\r\ntimeout = DIV_ROUND_UP(xfer->speed_hz, MSEC_PER_SEC);\r\ntimeout = DIV_ROUND_UP(xfer->len * 8, timeout);\r\ntimeout = 100 * msecs_to_jiffies(timeout);\r\nreinit_completion(&controller->done);\r\nspin_lock_irqsave(&controller->lock, flags);\r\ncontroller->xfer = xfer;\r\ncontroller->error = 0;\r\ncontroller->rx_bytes = 0;\r\ncontroller->tx_bytes = 0;\r\nspin_unlock_irqrestore(&controller->lock, flags);\r\nif (spi_qup_set_state(controller, QUP_STATE_RUN)) {\r\ndev_warn(controller->dev, "cannot set RUN state\n");\r\ngoto exit;\r\n}\r\nif (spi_qup_set_state(controller, QUP_STATE_PAUSE)) {\r\ndev_warn(controller->dev, "cannot set PAUSE state\n");\r\ngoto exit;\r\n}\r\nspi_qup_fifo_write(controller, xfer);\r\nif (spi_qup_set_state(controller, QUP_STATE_RUN)) {\r\ndev_warn(controller->dev, "cannot set EXECUTE state\n");\r\ngoto exit;\r\n}\r\nif (!wait_for_completion_timeout(&controller->done, timeout))\r\nret = -ETIMEDOUT;\r\nexit:\r\nspi_qup_set_state(controller, QUP_STATE_RESET);\r\nspin_lock_irqsave(&controller->lock, flags);\r\ncontroller->xfer = NULL;\r\nif (!ret)\r\nret = controller->error;\r\nspin_unlock_irqrestore(&controller->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int spi_qup_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct clk *iclk, *cclk;\r\nstruct spi_qup *controller;\r\nstruct resource *res;\r\nstruct device *dev;\r\nvoid __iomem *base;\r\nu32 max_freq, iomode;\r\nint ret, irq, size;\r\ndev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ncclk = devm_clk_get(dev, "core");\r\nif (IS_ERR(cclk))\r\nreturn PTR_ERR(cclk);\r\niclk = devm_clk_get(dev, "iface");\r\nif (IS_ERR(iclk))\r\nreturn PTR_ERR(iclk);\r\nif (of_property_read_u32(dev->of_node, "spi-max-frequency", &max_freq))\r\nmax_freq = SPI_MAX_RATE;\r\nif (!max_freq || max_freq > SPI_MAX_RATE) {\r\ndev_err(dev, "invalid clock frequency %d\n", max_freq);\r\nreturn -ENXIO;\r\n}\r\nret = clk_prepare_enable(cclk);\r\nif (ret) {\r\ndev_err(dev, "cannot enable core clock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(iclk);\r\nif (ret) {\r\nclk_disable_unprepare(cclk);\r\ndev_err(dev, "cannot enable iface clock\n");\r\nreturn ret;\r\n}\r\nmaster = spi_alloc_master(dev, sizeof(struct spi_qup));\r\nif (!master) {\r\nclk_disable_unprepare(cclk);\r\nclk_disable_unprepare(iclk);\r\ndev_err(dev, "cannot allocate master\n");\r\nreturn -ENOMEM;\r\n}\r\nif (of_property_read_u16(dev->of_node, "num-cs",\r\n&master->num_chipselect) ||\r\n(master->num_chipselect > SPI_NUM_CHIPSELECTS))\r\nmaster->num_chipselect = SPI_NUM_CHIPSELECTS;\r\nmaster->bus_num = pdev->id;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\r\nmaster->max_speed_hz = max_freq;\r\nmaster->transfer_one = spi_qup_transfer_one;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->auto_runtime_pm = true;\r\nplatform_set_drvdata(pdev, master);\r\ncontroller = spi_master_get_devdata(master);\r\ncontroller->dev = dev;\r\ncontroller->base = base;\r\ncontroller->iclk = iclk;\r\ncontroller->cclk = cclk;\r\ncontroller->irq = irq;\r\nif (of_device_is_compatible(dev->of_node, "qcom,spi-qup-v1.1.1"))\r\ncontroller->qup_v1 = 1;\r\nspin_lock_init(&controller->lock);\r\ninit_completion(&controller->done);\r\niomode = readl_relaxed(base + QUP_IO_M_MODES);\r\nsize = QUP_IO_M_OUTPUT_BLOCK_SIZE(iomode);\r\nif (size)\r\ncontroller->out_blk_sz = size * 16;\r\nelse\r\ncontroller->out_blk_sz = 4;\r\nsize = QUP_IO_M_INPUT_BLOCK_SIZE(iomode);\r\nif (size)\r\ncontroller->in_blk_sz = size * 16;\r\nelse\r\ncontroller->in_blk_sz = 4;\r\nsize = QUP_IO_M_OUTPUT_FIFO_SIZE(iomode);\r\ncontroller->out_fifo_sz = controller->out_blk_sz * (2 << size);\r\nsize = QUP_IO_M_INPUT_FIFO_SIZE(iomode);\r\ncontroller->in_fifo_sz = controller->in_blk_sz * (2 << size);\r\ndev_info(dev, "IN:block:%d, fifo:%d, OUT:block:%d, fifo:%d\n",\r\ncontroller->in_blk_sz, controller->in_fifo_sz,\r\ncontroller->out_blk_sz, controller->out_fifo_sz);\r\nwritel_relaxed(1, base + QUP_SW_RESET);\r\nret = spi_qup_set_state(controller, QUP_STATE_RESET);\r\nif (ret) {\r\ndev_err(dev, "cannot set RESET state\n");\r\ngoto error;\r\n}\r\nwritel_relaxed(0, base + QUP_OPERATIONAL);\r\nwritel_relaxed(0, base + QUP_IO_M_MODES);\r\nif (!controller->qup_v1)\r\nwritel_relaxed(0, base + QUP_OPERATIONAL_MASK);\r\nwritel_relaxed(SPI_ERROR_CLK_UNDER_RUN | SPI_ERROR_CLK_OVER_RUN,\r\nbase + SPI_ERROR_FLAGS_EN);\r\nif (controller->qup_v1)\r\nwritel_relaxed(QUP_ERROR_OUTPUT_OVER_RUN |\r\nQUP_ERROR_INPUT_UNDER_RUN | QUP_ERROR_OUTPUT_UNDER_RUN,\r\nbase + QUP_ERROR_FLAGS_EN);\r\nwritel_relaxed(0, base + SPI_CONFIG);\r\nwritel_relaxed(SPI_IO_C_NO_TRI_STATE, base + SPI_IO_CONTROL);\r\nret = devm_request_irq(dev, irq, spi_qup_qup_irq,\r\nIRQF_TRIGGER_HIGH, pdev->name, controller);\r\nif (ret)\r\ngoto error;\r\npm_runtime_set_autosuspend_delay(dev, MSEC_PER_SEC);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nret = devm_spi_register_master(dev, master);\r\nif (ret)\r\ngoto disable_pm;\r\nreturn 0;\r\ndisable_pm:\r\npm_runtime_disable(&pdev->dev);\r\nerror:\r\nclk_disable_unprepare(cclk);\r\nclk_disable_unprepare(iclk);\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int spi_qup_pm_suspend_runtime(struct device *device)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(device);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nu32 config;\r\nconfig = readl(controller->base + QUP_CONFIG);\r\nconfig |= QUP_CONFIG_CLOCK_AUTO_GATE;\r\nwritel_relaxed(config, controller->base + QUP_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int spi_qup_pm_resume_runtime(struct device *device)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(device);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nu32 config;\r\nconfig = readl_relaxed(controller->base + QUP_CONFIG);\r\nconfig &= ~QUP_CONFIG_CLOCK_AUTO_GATE;\r\nwritel_relaxed(config, controller->base + QUP_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int spi_qup_suspend(struct device *device)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(device);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nint ret;\r\nret = spi_master_suspend(master);\r\nif (ret)\r\nreturn ret;\r\nret = spi_qup_set_state(controller, QUP_STATE_RESET);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(controller->cclk);\r\nclk_disable_unprepare(controller->iclk);\r\nreturn 0;\r\n}\r\nstatic int spi_qup_resume(struct device *device)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(device);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(controller->iclk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(controller->cclk);\r\nif (ret)\r\nreturn ret;\r\nret = spi_qup_set_state(controller, QUP_STATE_RESET);\r\nif (ret)\r\nreturn ret;\r\nreturn spi_master_resume(master);\r\n}\r\nstatic int spi_qup_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(&pdev->dev);\r\nstruct spi_qup *controller = spi_master_get_devdata(master);\r\nint ret;\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = spi_qup_set_state(controller, QUP_STATE_RESET);\r\nif (ret)\r\nreturn ret;\r\nclk_disable_unprepare(controller->cclk);\r\nclk_disable_unprepare(controller->iclk);\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
