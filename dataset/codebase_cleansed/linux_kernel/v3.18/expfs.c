static int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\r\nchar *name, struct dentry *child)\r\n{\r\nconst struct export_operations *nop = dir->d_sb->s_export_op;\r\nstruct path path = {.mnt = mnt, .dentry = dir};\r\nif (nop->get_name)\r\nreturn nop->get_name(dir, name, child);\r\nelse\r\nreturn get_name(&path, name, child);\r\n}\r\nstatic struct dentry *\r\nfind_acceptable_alias(struct dentry *result,\r\nint (*acceptable)(void *context, struct dentry *dentry),\r\nvoid *context)\r\n{\r\nstruct dentry *dentry, *toput = NULL;\r\nstruct inode *inode;\r\nif (acceptable(context, result))\r\nreturn result;\r\ninode = result->d_inode;\r\nspin_lock(&inode->i_lock);\r\nhlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {\r\ndget(dentry);\r\nspin_unlock(&inode->i_lock);\r\nif (toput)\r\ndput(toput);\r\nif (dentry != result && acceptable(context, dentry)) {\r\ndput(result);\r\nreturn dentry;\r\n}\r\nspin_lock(&inode->i_lock);\r\ntoput = dentry;\r\n}\r\nspin_unlock(&inode->i_lock);\r\nif (toput)\r\ndput(toput);\r\nreturn NULL;\r\n}\r\nstatic bool dentry_connected(struct dentry *dentry)\r\n{\r\ndget(dentry);\r\nwhile (dentry->d_flags & DCACHE_DISCONNECTED) {\r\nstruct dentry *parent = dget_parent(dentry);\r\ndput(dentry);\r\nif (IS_ROOT(dentry)) {\r\ndput(parent);\r\nreturn false;\r\n}\r\ndentry = parent;\r\n}\r\ndput(dentry);\r\nreturn true;\r\n}\r\nstatic void clear_disconnected(struct dentry *dentry)\r\n{\r\ndget(dentry);\r\nwhile (dentry->d_flags & DCACHE_DISCONNECTED) {\r\nstruct dentry *parent = dget_parent(dentry);\r\nWARN_ON_ONCE(IS_ROOT(dentry));\r\nspin_lock(&dentry->d_lock);\r\ndentry->d_flags &= ~DCACHE_DISCONNECTED;\r\nspin_unlock(&dentry->d_lock);\r\ndput(dentry);\r\ndentry = parent;\r\n}\r\ndput(dentry);\r\n}\r\nstatic struct dentry *reconnect_one(struct vfsmount *mnt,\r\nstruct dentry *dentry, char *nbuf)\r\n{\r\nstruct dentry *parent;\r\nstruct dentry *tmp;\r\nint err;\r\nparent = ERR_PTR(-EACCES);\r\nmutex_lock(&dentry->d_inode->i_mutex);\r\nif (mnt->mnt_sb->s_export_op->get_parent)\r\nparent = mnt->mnt_sb->s_export_op->get_parent(dentry);\r\nmutex_unlock(&dentry->d_inode->i_mutex);\r\nif (IS_ERR(parent)) {\r\ndprintk("%s: get_parent of %ld failed, err %d\n",\r\n__func__, dentry->d_inode->i_ino, PTR_ERR(parent));\r\nreturn parent;\r\n}\r\ndprintk("%s: find name of %lu in %lu\n", __func__,\r\ndentry->d_inode->i_ino, parent->d_inode->i_ino);\r\nerr = exportfs_get_name(mnt, parent, nbuf, dentry);\r\nif (err == -ENOENT)\r\ngoto out_reconnected;\r\nif (err)\r\ngoto out_err;\r\ndprintk("%s: found name: %s\n", __func__, nbuf);\r\nmutex_lock(&parent->d_inode->i_mutex);\r\ntmp = lookup_one_len(nbuf, parent, strlen(nbuf));\r\nmutex_unlock(&parent->d_inode->i_mutex);\r\nif (IS_ERR(tmp)) {\r\ndprintk("%s: lookup failed: %d\n", __func__, PTR_ERR(tmp));\r\ngoto out_err;\r\n}\r\nif (tmp != dentry) {\r\ndput(tmp);\r\ngoto out_reconnected;\r\n}\r\ndput(tmp);\r\nif (IS_ROOT(dentry)) {\r\nerr = -ESTALE;\r\ngoto out_err;\r\n}\r\nreturn parent;\r\nout_err:\r\ndput(parent);\r\nreturn ERR_PTR(err);\r\nout_reconnected:\r\ndput(parent);\r\nif (!dentry_connected(dentry))\r\nreturn ERR_PTR(-ESTALE);\r\nreturn NULL;\r\n}\r\nstatic int\r\nreconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)\r\n{\r\nstruct dentry *dentry, *parent;\r\ndentry = dget(target_dir);\r\nwhile (dentry->d_flags & DCACHE_DISCONNECTED) {\r\nBUG_ON(dentry == mnt->mnt_sb->s_root);\r\nif (IS_ROOT(dentry))\r\nparent = reconnect_one(mnt, dentry, nbuf);\r\nelse\r\nparent = dget_parent(dentry);\r\nif (!parent)\r\nbreak;\r\ndput(dentry);\r\nif (IS_ERR(parent))\r\nreturn PTR_ERR(parent);\r\ndentry = parent;\r\n}\r\ndput(dentry);\r\nclear_disconnected(target_dir);\r\nreturn 0;\r\n}\r\nstatic int filldir_one(void * __buf, const char * name, int len,\r\nloff_t pos, u64 ino, unsigned int d_type)\r\n{\r\nstruct getdents_callback *buf = __buf;\r\nint result = 0;\r\nbuf->sequence++;\r\nif (buf->ino == ino && len <= NAME_MAX) {\r\nmemcpy(buf->name, name, len);\r\nbuf->name[len] = '\0';\r\nbuf->found = 1;\r\nresult = -1;\r\n}\r\nreturn result;\r\n}\r\nstatic int get_name(const struct path *path, char *name, struct dentry *child)\r\n{\r\nconst struct cred *cred = current_cred();\r\nstruct inode *dir = path->dentry->d_inode;\r\nint error;\r\nstruct file *file;\r\nstruct kstat stat;\r\nstruct path child_path = {\r\n.mnt = path->mnt,\r\n.dentry = child,\r\n};\r\nstruct getdents_callback buffer = {\r\n.ctx.actor = filldir_one,\r\n.name = name,\r\n};\r\nerror = -ENOTDIR;\r\nif (!dir || !S_ISDIR(dir->i_mode))\r\ngoto out;\r\nerror = -EINVAL;\r\nif (!dir->i_fop)\r\ngoto out;\r\nerror = vfs_getattr_nosec(&child_path, &stat);\r\nif (error)\r\nreturn error;\r\nbuffer.ino = stat.ino;\r\nfile = dentry_open(path, O_RDONLY, cred);\r\nerror = PTR_ERR(file);\r\nif (IS_ERR(file))\r\ngoto out;\r\nerror = -EINVAL;\r\nif (!file->f_op->iterate)\r\ngoto out_close;\r\nbuffer.sequence = 0;\r\nwhile (1) {\r\nint old_seq = buffer.sequence;\r\nerror = iterate_dir(file, &buffer.ctx);\r\nif (buffer.found) {\r\nerror = 0;\r\nbreak;\r\n}\r\nif (error < 0)\r\nbreak;\r\nerror = -ENOENT;\r\nif (old_seq == buffer.sequence)\r\nbreak;\r\n}\r\nout_close:\r\nfput(file);\r\nout:\r\nreturn error;\r\n}\r\nstatic int export_encode_fh(struct inode *inode, struct fid *fid,\r\nint *max_len, struct inode *parent)\r\n{\r\nint len = *max_len;\r\nint type = FILEID_INO32_GEN;\r\nif (parent && (len < 4)) {\r\n*max_len = 4;\r\nreturn FILEID_INVALID;\r\n} else if (len < 2) {\r\n*max_len = 2;\r\nreturn FILEID_INVALID;\r\n}\r\nlen = 2;\r\nfid->i32.ino = inode->i_ino;\r\nfid->i32.gen = inode->i_generation;\r\nif (parent) {\r\nfid->i32.parent_ino = parent->i_ino;\r\nfid->i32.parent_gen = parent->i_generation;\r\nlen = 4;\r\ntype = FILEID_INO32_GEN_PARENT;\r\n}\r\n*max_len = len;\r\nreturn type;\r\n}\r\nint exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\r\nint *max_len, struct inode *parent)\r\n{\r\nconst struct export_operations *nop = inode->i_sb->s_export_op;\r\nif (nop && nop->encode_fh)\r\nreturn nop->encode_fh(inode, fid->raw, max_len, parent);\r\nreturn export_encode_fh(inode, fid, max_len, parent);\r\n}\r\nint exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\r\nint connectable)\r\n{\r\nint error;\r\nstruct dentry *p = NULL;\r\nstruct inode *inode = dentry->d_inode, *parent = NULL;\r\nif (connectable && !S_ISDIR(inode->i_mode)) {\r\np = dget_parent(dentry);\r\nparent = p->d_inode;\r\n}\r\nerror = exportfs_encode_inode_fh(inode, fid, max_len, parent);\r\ndput(p);\r\nreturn error;\r\n}\r\nstruct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\r\nint fh_len, int fileid_type,\r\nint (*acceptable)(void *, struct dentry *), void *context)\r\n{\r\nconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\r\nstruct dentry *result, *alias;\r\nchar nbuf[NAME_MAX+1];\r\nint err;\r\nif (!nop || !nop->fh_to_dentry)\r\nreturn ERR_PTR(-ESTALE);\r\nresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\r\nif (!result)\r\nresult = ERR_PTR(-ESTALE);\r\nif (IS_ERR(result))\r\nreturn result;\r\nif (S_ISDIR(result->d_inode->i_mode)) {\r\nif (result->d_flags & DCACHE_DISCONNECTED) {\r\nerr = reconnect_path(mnt, result, nbuf);\r\nif (err)\r\ngoto err_result;\r\n}\r\nif (!acceptable(context, result)) {\r\nerr = -EACCES;\r\ngoto err_result;\r\n}\r\nreturn result;\r\n} else {\r\nstruct dentry *target_dir, *nresult;\r\nalias = find_acceptable_alias(result, acceptable, context);\r\nif (alias)\r\nreturn alias;\r\nerr = -ESTALE;\r\nif (!nop->fh_to_parent)\r\ngoto err_result;\r\ntarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\r\nfh_len, fileid_type);\r\nif (!target_dir)\r\ngoto err_result;\r\nerr = PTR_ERR(target_dir);\r\nif (IS_ERR(target_dir))\r\ngoto err_result;\r\nerr = reconnect_path(mnt, target_dir, nbuf);\r\nif (err) {\r\ndput(target_dir);\r\ngoto err_result;\r\n}\r\nerr = exportfs_get_name(mnt, target_dir, nbuf, result);\r\nif (!err) {\r\nmutex_lock(&target_dir->d_inode->i_mutex);\r\nnresult = lookup_one_len(nbuf, target_dir,\r\nstrlen(nbuf));\r\nmutex_unlock(&target_dir->d_inode->i_mutex);\r\nif (!IS_ERR(nresult)) {\r\nif (nresult->d_inode) {\r\ndput(result);\r\nresult = nresult;\r\n} else\r\ndput(nresult);\r\n}\r\n}\r\ndput(target_dir);\r\nalias = find_acceptable_alias(result, acceptable, context);\r\nif (!alias) {\r\nerr = -EACCES;\r\ngoto err_result;\r\n}\r\nreturn alias;\r\n}\r\nerr_result:\r\ndput(result);\r\nreturn ERR_PTR(err);\r\n}
