s32 __ew32_prepare(struct e1000_hw *hw)\r\n{\r\ns32 i = E1000_ICH_FWSM_PCIM2PCI_COUNT;\r\nwhile ((er32(FWSM) & E1000_ICH_FWSM_PCIM2PCI) && --i)\r\nudelay(50);\r\nreturn i;\r\n}\r\nvoid __ew32(struct e1000_hw *hw, unsigned long reg, u32 val)\r\n{\r\nif (hw->adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\r\n__ew32_prepare(hw);\r\nwritel(val, hw->hw_addr + reg);\r\n}\r\nstatic void e1000_regdump(struct e1000_hw *hw, struct e1000_reg_info *reginfo)\r\n{\r\nint n = 0;\r\nchar rname[16];\r\nu32 regs[8];\r\nswitch (reginfo->ofs) {\r\ncase E1000_RXDCTL(0):\r\nfor (n = 0; n < 2; n++)\r\nregs[n] = __er32(hw, E1000_RXDCTL(n));\r\nbreak;\r\ncase E1000_TXDCTL(0):\r\nfor (n = 0; n < 2; n++)\r\nregs[n] = __er32(hw, E1000_TXDCTL(n));\r\nbreak;\r\ncase E1000_TARC(0):\r\nfor (n = 0; n < 2; n++)\r\nregs[n] = __er32(hw, E1000_TARC(n));\r\nbreak;\r\ndefault:\r\npr_info("%-15s %08x\n",\r\nreginfo->name, __er32(hw, reginfo->ofs));\r\nreturn;\r\n}\r\nsnprintf(rname, 16, "%s%s", reginfo->name, "[0-1]");\r\npr_info("%-15s %08x %08x\n", rname, regs[0], regs[1]);\r\n}\r\nstatic void e1000e_dump_ps_pages(struct e1000_adapter *adapter,\r\nstruct e1000_buffer *bi)\r\n{\r\nint i;\r\nstruct e1000_ps_page *ps_page;\r\nfor (i = 0; i < adapter->rx_ps_pages; i++) {\r\nps_page = &bi->ps_pages[i];\r\nif (ps_page->page) {\r\npr_info("packet dump for ps_page %d:\n", i);\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_ADDRESS,\r\n16, 1, page_address(ps_page->page),\r\nPAGE_SIZE, true);\r\n}\r\n}\r\n}\r\nstatic void e1000e_dump(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_reg_info *reginfo;\r\nstruct e1000_ring *tx_ring = adapter->tx_ring;\r\nstruct e1000_tx_desc *tx_desc;\r\nstruct my_u0 {\r\n__le64 a;\r\n__le64 b;\r\n} *u0;\r\nstruct e1000_buffer *buffer_info;\r\nstruct e1000_ring *rx_ring = adapter->rx_ring;\r\nunion e1000_rx_desc_packet_split *rx_desc_ps;\r\nunion e1000_rx_desc_extended *rx_desc;\r\nstruct my_u1 {\r\n__le64 a;\r\n__le64 b;\r\n__le64 c;\r\n__le64 d;\r\n} *u1;\r\nu32 staterr;\r\nint i = 0;\r\nif (!netif_msg_hw(adapter))\r\nreturn;\r\nif (netdev) {\r\ndev_info(&adapter->pdev->dev, "Net device Info\n");\r\npr_info("Device Name state trans_start last_rx\n");\r\npr_info("%-15s %016lX %016lX %016lX\n", netdev->name,\r\nnetdev->state, netdev->trans_start, netdev->last_rx);\r\n}\r\ndev_info(&adapter->pdev->dev, "Register Dump\n");\r\npr_info(" Register Name Value\n");\r\nfor (reginfo = (struct e1000_reg_info *)e1000_reg_info_tbl;\r\nreginfo->name; reginfo++) {\r\ne1000_regdump(hw, reginfo);\r\n}\r\nif (!netdev || !netif_running(netdev))\r\nreturn;\r\ndev_info(&adapter->pdev->dev, "Tx Ring Summary\n");\r\npr_info("Queue [NTU] [NTC] [bi(ntc)->dma ] leng ntw timestamp\n");\r\nbuffer_info = &tx_ring->buffer_info[tx_ring->next_to_clean];\r\npr_info(" %5d %5X %5X %016llX %04X %3X %016llX\n",\r\n0, tx_ring->next_to_use, tx_ring->next_to_clean,\r\n(unsigned long long)buffer_info->dma,\r\nbuffer_info->length,\r\nbuffer_info->next_to_watch,\r\n(unsigned long long)buffer_info->time_stamp);\r\nif (!netif_msg_tx_done(adapter))\r\ngoto rx_ring_summary;\r\ndev_info(&adapter->pdev->dev, "Tx Ring Dump\n");\r\npr_info("Tl[desc] [address 63:0 ] [SpeCssSCmCsLen] [bi->dma ] leng ntw timestamp bi->skb <-- Legacy format\n");\r\npr_info("Tc[desc] [Ce CoCsIpceCoS] [MssHlRSCm0Plen] [bi->dma ] leng ntw timestamp bi->skb <-- Ext Context format\n");\r\npr_info("Td[desc] [address 63:0 ] [VlaPoRSCm1Dlen] [bi->dma ] leng ntw timestamp bi->skb <-- Ext Data format\n");\r\nfor (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {\r\nconst char *next_desc;\r\ntx_desc = E1000_TX_DESC(*tx_ring, i);\r\nbuffer_info = &tx_ring->buffer_info[i];\r\nu0 = (struct my_u0 *)tx_desc;\r\nif (i == tx_ring->next_to_use && i == tx_ring->next_to_clean)\r\nnext_desc = " NTC/U";\r\nelse if (i == tx_ring->next_to_use)\r\nnext_desc = " NTU";\r\nelse if (i == tx_ring->next_to_clean)\r\nnext_desc = " NTC";\r\nelse\r\nnext_desc = "";\r\npr_info("T%c[0x%03X] %016llX %016llX %016llX %04X %3X %016llX %p%s\n",\r\n(!(le64_to_cpu(u0->b) & (1 << 29)) ? 'l' :\r\n((le64_to_cpu(u0->b) & (1 << 20)) ? 'd' : 'c')),\r\ni,\r\n(unsigned long long)le64_to_cpu(u0->a),\r\n(unsigned long long)le64_to_cpu(u0->b),\r\n(unsigned long long)buffer_info->dma,\r\nbuffer_info->length, buffer_info->next_to_watch,\r\n(unsigned long long)buffer_info->time_stamp,\r\nbuffer_info->skb, next_desc);\r\nif (netif_msg_pktdata(adapter) && buffer_info->skb)\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_ADDRESS,\r\n16, 1, buffer_info->skb->data,\r\nbuffer_info->skb->len, true);\r\n}\r\nrx_ring_summary:\r\ndev_info(&adapter->pdev->dev, "Rx Ring Summary\n");\r\npr_info("Queue [NTU] [NTC]\n");\r\npr_info(" %5d %5X %5X\n",\r\n0, rx_ring->next_to_use, rx_ring->next_to_clean);\r\nif (!netif_msg_rx_status(adapter))\r\nreturn;\r\ndev_info(&adapter->pdev->dev, "Rx Ring Dump\n");\r\nswitch (adapter->rx_ps_pages) {\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\npr_info("R [desc] [buffer 0 63:0 ] [buffer 1 63:0 ] [buffer 2 63:0 ] [buffer 3 63:0 ] [bi->dma ] [bi->skb] <-- Ext Pkt Split format\n");\r\npr_info("RWB[desc] [ck ipid mrqhsh] [vl l0 ee es] [ l3 l2 l1 hs] [reserved ] ---------------- [bi->skb] <-- Ext Rx Write-Back format\n");\r\nfor (i = 0; i < rx_ring->count; i++) {\r\nconst char *next_desc;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nrx_desc_ps = E1000_RX_DESC_PS(*rx_ring, i);\r\nu1 = (struct my_u1 *)rx_desc_ps;\r\nstaterr =\r\nle32_to_cpu(rx_desc_ps->wb.middle.status_error);\r\nif (i == rx_ring->next_to_use)\r\nnext_desc = " NTU";\r\nelse if (i == rx_ring->next_to_clean)\r\nnext_desc = " NTC";\r\nelse\r\nnext_desc = "";\r\nif (staterr & E1000_RXD_STAT_DD) {\r\npr_info("%s[0x%03X] %016llX %016llX %016llX %016llX ---------------- %p%s\n",\r\n"RWB", i,\r\n(unsigned long long)le64_to_cpu(u1->a),\r\n(unsigned long long)le64_to_cpu(u1->b),\r\n(unsigned long long)le64_to_cpu(u1->c),\r\n(unsigned long long)le64_to_cpu(u1->d),\r\nbuffer_info->skb, next_desc);\r\n} else {\r\npr_info("%s[0x%03X] %016llX %016llX %016llX %016llX %016llX %p%s\n",\r\n"R ", i,\r\n(unsigned long long)le64_to_cpu(u1->a),\r\n(unsigned long long)le64_to_cpu(u1->b),\r\n(unsigned long long)le64_to_cpu(u1->c),\r\n(unsigned long long)le64_to_cpu(u1->d),\r\n(unsigned long long)buffer_info->dma,\r\nbuffer_info->skb, next_desc);\r\nif (netif_msg_pktdata(adapter))\r\ne1000e_dump_ps_pages(adapter,\r\nbuffer_info);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ncase 0:\r\npr_info("R [desc] [buf addr 63:0 ] [reserved 63:0 ] [bi->dma ] [bi->skb] <-- Ext (Read) format\n");\r\npr_info("RWB[desc] [cs ipid mrq] [vt ln xe xs] [bi->skb] <-- Ext (Write-Back) format\n");\r\nfor (i = 0; i < rx_ring->count; i++) {\r\nconst char *next_desc;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nrx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\r\nu1 = (struct my_u1 *)rx_desc;\r\nstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\r\nif (i == rx_ring->next_to_use)\r\nnext_desc = " NTU";\r\nelse if (i == rx_ring->next_to_clean)\r\nnext_desc = " NTC";\r\nelse\r\nnext_desc = "";\r\nif (staterr & E1000_RXD_STAT_DD) {\r\npr_info("%s[0x%03X] %016llX %016llX ---------------- %p%s\n",\r\n"RWB", i,\r\n(unsigned long long)le64_to_cpu(u1->a),\r\n(unsigned long long)le64_to_cpu(u1->b),\r\nbuffer_info->skb, next_desc);\r\n} else {\r\npr_info("%s[0x%03X] %016llX %016llX %016llX %p%s\n",\r\n"R ", i,\r\n(unsigned long long)le64_to_cpu(u1->a),\r\n(unsigned long long)le64_to_cpu(u1->b),\r\n(unsigned long long)buffer_info->dma,\r\nbuffer_info->skb, next_desc);\r\nif (netif_msg_pktdata(adapter) &&\r\nbuffer_info->skb)\r\nprint_hex_dump(KERN_INFO, "",\r\nDUMP_PREFIX_ADDRESS, 16,\r\n1,\r\nbuffer_info->skb->data,\r\nadapter->rx_buffer_len,\r\ntrue);\r\n}\r\n}\r\n}\r\n}\r\nstatic int e1000_desc_unused(struct e1000_ring *ring)\r\n{\r\nif (ring->next_to_clean > ring->next_to_use)\r\nreturn ring->next_to_clean - ring->next_to_use - 1;\r\nreturn ring->count + ring->next_to_clean - ring->next_to_use - 1;\r\n}\r\nstatic void e1000e_systim_to_hwtstamp(struct e1000_adapter *adapter,\r\nstruct skb_shared_hwtstamps *hwtstamps,\r\nu64 systim)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->systim_lock, flags);\r\nns = timecounter_cyc2time(&adapter->tc, systim);\r\nspin_unlock_irqrestore(&adapter->systim_lock, flags);\r\nmemset(hwtstamps, 0, sizeof(*hwtstamps));\r\nhwtstamps->hwtstamp = ns_to_ktime(ns);\r\n}\r\nstatic void e1000e_rx_hwtstamp(struct e1000_adapter *adapter, u32 status,\r\nstruct sk_buff *skb)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu64 rxstmp;\r\nif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP) ||\r\n!(status & E1000_RXDEXT_STATERR_TST) ||\r\n!(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID))\r\nreturn;\r\nrxstmp = (u64)er32(RXSTMPL);\r\nrxstmp |= (u64)er32(RXSTMPH) << 32;\r\ne1000e_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), rxstmp);\r\nadapter->flags2 &= ~FLAG2_CHECK_RX_HWTSTAMP;\r\n}\r\nstatic void e1000_receive_skb(struct e1000_adapter *adapter,\r\nstruct net_device *netdev, struct sk_buff *skb,\r\nu32 staterr, __le16 vlan)\r\n{\r\nu16 tag = le16_to_cpu(vlan);\r\ne1000e_rx_hwtstamp(adapter, staterr, skb);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nif (staterr & E1000_RXD_STAT_VP)\r\n__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), tag);\r\nnapi_gro_receive(&adapter->napi, skb);\r\n}\r\nstatic void e1000_rx_checksum(struct e1000_adapter *adapter, u32 status_err,\r\nstruct sk_buff *skb)\r\n{\r\nu16 status = (u16)status_err;\r\nu8 errors = (u8)(status_err >> 24);\r\nskb_checksum_none_assert(skb);\r\nif (!(adapter->netdev->features & NETIF_F_RXCSUM))\r\nreturn;\r\nif (status & E1000_RXD_STAT_IXSM)\r\nreturn;\r\nif (errors & (E1000_RXD_ERR_TCPE | E1000_RXD_ERR_IPE)) {\r\nadapter->hw_csum_err++;\r\nreturn;\r\n}\r\nif (!(status & (E1000_RXD_STAT_TCPCS | E1000_RXD_STAT_UDPCS)))\r\nreturn;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nadapter->hw_csum_good++;\r\n}\r\nstatic void e1000e_update_rdt_wa(struct e1000_ring *rx_ring, unsigned int i)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct e1000_hw *hw = &adapter->hw;\r\ns32 ret_val = __ew32_prepare(hw);\r\nwritel(i, rx_ring->tail);\r\nif (unlikely(!ret_val && (i != readl(rx_ring->tail)))) {\r\nu32 rctl = er32(RCTL);\r\new32(RCTL, rctl & ~E1000_RCTL_EN);\r\ne_err("ME firmware caused invalid RDT - resetting\n");\r\nschedule_work(&adapter->reset_task);\r\n}\r\n}\r\nstatic void e1000e_update_tdt_wa(struct e1000_ring *tx_ring, unsigned int i)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nstruct e1000_hw *hw = &adapter->hw;\r\ns32 ret_val = __ew32_prepare(hw);\r\nwritel(i, tx_ring->tail);\r\nif (unlikely(!ret_val && (i != readl(tx_ring->tail)))) {\r\nu32 tctl = er32(TCTL);\r\new32(TCTL, tctl & ~E1000_TCTL_EN);\r\ne_err("ME firmware caused invalid TDT - resetting\n");\r\nschedule_work(&adapter->reset_task);\r\n}\r\n}\r\nstatic void e1000_alloc_rx_buffers(struct e1000_ring *rx_ring,\r\nint cleaned_count, gfp_t gfp)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nunion e1000_rx_desc_extended *rx_desc;\r\nstruct e1000_buffer *buffer_info;\r\nstruct sk_buff *skb;\r\nunsigned int i;\r\nunsigned int bufsz = adapter->rx_buffer_len;\r\ni = rx_ring->next_to_use;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nwhile (cleaned_count--) {\r\nskb = buffer_info->skb;\r\nif (skb) {\r\nskb_trim(skb, 0);\r\ngoto map_skb;\r\n}\r\nskb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);\r\nif (!skb) {\r\nadapter->alloc_rx_buff_failed++;\r\nbreak;\r\n}\r\nbuffer_info->skb = skb;\r\nmap_skb:\r\nbuffer_info->dma = dma_map_single(&pdev->dev, skb->data,\r\nadapter->rx_buffer_len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\r\ndev_err(&pdev->dev, "Rx DMA map failed\n");\r\nadapter->rx_dma_failed++;\r\nbreak;\r\n}\r\nrx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\r\nrx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);\r\nif (unlikely(!(i & (E1000_RX_BUFFER_WRITE - 1)))) {\r\nwmb();\r\nif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\r\ne1000e_update_rdt_wa(rx_ring, i);\r\nelse\r\nwritel(i, rx_ring->tail);\r\n}\r\ni++;\r\nif (i == rx_ring->count)\r\ni = 0;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\n}\r\nrx_ring->next_to_use = i;\r\n}\r\nstatic void e1000_alloc_rx_buffers_ps(struct e1000_ring *rx_ring,\r\nint cleaned_count, gfp_t gfp)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nunion e1000_rx_desc_packet_split *rx_desc;\r\nstruct e1000_buffer *buffer_info;\r\nstruct e1000_ps_page *ps_page;\r\nstruct sk_buff *skb;\r\nunsigned int i, j;\r\ni = rx_ring->next_to_use;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nwhile (cleaned_count--) {\r\nrx_desc = E1000_RX_DESC_PS(*rx_ring, i);\r\nfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\r\nps_page = &buffer_info->ps_pages[j];\r\nif (j >= adapter->rx_ps_pages) {\r\nrx_desc->read.buffer_addr[j + 1] =\r\n~cpu_to_le64(0);\r\ncontinue;\r\n}\r\nif (!ps_page->page) {\r\nps_page->page = alloc_page(gfp);\r\nif (!ps_page->page) {\r\nadapter->alloc_rx_buff_failed++;\r\ngoto no_buffers;\r\n}\r\nps_page->dma = dma_map_page(&pdev->dev,\r\nps_page->page,\r\n0, PAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&pdev->dev,\r\nps_page->dma)) {\r\ndev_err(&adapter->pdev->dev,\r\n"Rx DMA page map failed\n");\r\nadapter->rx_dma_failed++;\r\ngoto no_buffers;\r\n}\r\n}\r\nrx_desc->read.buffer_addr[j + 1] =\r\ncpu_to_le64(ps_page->dma);\r\n}\r\nskb = __netdev_alloc_skb_ip_align(netdev, adapter->rx_ps_bsize0,\r\ngfp);\r\nif (!skb) {\r\nadapter->alloc_rx_buff_failed++;\r\nbreak;\r\n}\r\nbuffer_info->skb = skb;\r\nbuffer_info->dma = dma_map_single(&pdev->dev, skb->data,\r\nadapter->rx_ps_bsize0,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\r\ndev_err(&pdev->dev, "Rx DMA map failed\n");\r\nadapter->rx_dma_failed++;\r\ndev_kfree_skb_any(skb);\r\nbuffer_info->skb = NULL;\r\nbreak;\r\n}\r\nrx_desc->read.buffer_addr[0] = cpu_to_le64(buffer_info->dma);\r\nif (unlikely(!(i & (E1000_RX_BUFFER_WRITE - 1)))) {\r\nwmb();\r\nif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\r\ne1000e_update_rdt_wa(rx_ring, i << 1);\r\nelse\r\nwritel(i << 1, rx_ring->tail);\r\n}\r\ni++;\r\nif (i == rx_ring->count)\r\ni = 0;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\n}\r\nno_buffers:\r\nrx_ring->next_to_use = i;\r\n}\r\nstatic void e1000_alloc_jumbo_rx_buffers(struct e1000_ring *rx_ring,\r\nint cleaned_count, gfp_t gfp)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nunion e1000_rx_desc_extended *rx_desc;\r\nstruct e1000_buffer *buffer_info;\r\nstruct sk_buff *skb;\r\nunsigned int i;\r\nunsigned int bufsz = 256 - 16;\r\ni = rx_ring->next_to_use;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nwhile (cleaned_count--) {\r\nskb = buffer_info->skb;\r\nif (skb) {\r\nskb_trim(skb, 0);\r\ngoto check_page;\r\n}\r\nskb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);\r\nif (unlikely(!skb)) {\r\nadapter->alloc_rx_buff_failed++;\r\nbreak;\r\n}\r\nbuffer_info->skb = skb;\r\ncheck_page:\r\nif (!buffer_info->page) {\r\nbuffer_info->page = alloc_page(gfp);\r\nif (unlikely(!buffer_info->page)) {\r\nadapter->alloc_rx_buff_failed++;\r\nbreak;\r\n}\r\n}\r\nif (!buffer_info->dma) {\r\nbuffer_info->dma = dma_map_page(&pdev->dev,\r\nbuffer_info->page, 0,\r\nPAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\r\nadapter->alloc_rx_buff_failed++;\r\nbreak;\r\n}\r\n}\r\nrx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\r\nrx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);\r\nif (unlikely(++i == rx_ring->count))\r\ni = 0;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\n}\r\nif (likely(rx_ring->next_to_use != i)) {\r\nrx_ring->next_to_use = i;\r\nif (unlikely(i-- == 0))\r\ni = (rx_ring->count - 1);\r\nwmb();\r\nif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\r\ne1000e_update_rdt_wa(rx_ring, i);\r\nelse\r\nwritel(i, rx_ring->tail);\r\n}\r\n}\r\nstatic inline void e1000_rx_hash(struct net_device *netdev, __le32 rss,\r\nstruct sk_buff *skb)\r\n{\r\nif (netdev->features & NETIF_F_RXHASH)\r\nskb_set_hash(skb, le32_to_cpu(rss), PKT_HASH_TYPE_L3);\r\n}\r\nstatic bool e1000_clean_rx_irq(struct e1000_ring *rx_ring, int *work_done,\r\nint work_to_do)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nunion e1000_rx_desc_extended *rx_desc, *next_rxd;\r\nstruct e1000_buffer *buffer_info, *next_buffer;\r\nu32 length, staterr;\r\nunsigned int i;\r\nint cleaned_count = 0;\r\nbool cleaned = false;\r\nunsigned int total_rx_bytes = 0, total_rx_packets = 0;\r\ni = rx_ring->next_to_clean;\r\nrx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\r\nstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nwhile (staterr & E1000_RXD_STAT_DD) {\r\nstruct sk_buff *skb;\r\nif (*work_done >= work_to_do)\r\nbreak;\r\n(*work_done)++;\r\nrmb();\r\nskb = buffer_info->skb;\r\nbuffer_info->skb = NULL;\r\nprefetch(skb->data - NET_IP_ALIGN);\r\ni++;\r\nif (i == rx_ring->count)\r\ni = 0;\r\nnext_rxd = E1000_RX_DESC_EXT(*rx_ring, i);\r\nprefetch(next_rxd);\r\nnext_buffer = &rx_ring->buffer_info[i];\r\ncleaned = true;\r\ncleaned_count++;\r\ndma_unmap_single(&pdev->dev, buffer_info->dma,\r\nadapter->rx_buffer_len, DMA_FROM_DEVICE);\r\nbuffer_info->dma = 0;\r\nlength = le16_to_cpu(rx_desc->wb.upper.length);\r\nif (unlikely(!(staterr & E1000_RXD_STAT_EOP)))\r\nadapter->flags2 |= FLAG2_IS_DISCARDING;\r\nif (adapter->flags2 & FLAG2_IS_DISCARDING) {\r\ne_dbg("Receive packet consumed multiple buffers\n");\r\nbuffer_info->skb = skb;\r\nif (staterr & E1000_RXD_STAT_EOP)\r\nadapter->flags2 &= ~FLAG2_IS_DISCARDING;\r\ngoto next_desc;\r\n}\r\nif (unlikely((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\r\n!(netdev->features & NETIF_F_RXALL))) {\r\nbuffer_info->skb = skb;\r\ngoto next_desc;\r\n}\r\nif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\r\nif (netdev->features & NETIF_F_RXFCS)\r\ntotal_rx_bytes -= 4;\r\nelse\r\nlength -= 4;\r\n}\r\ntotal_rx_bytes += length;\r\ntotal_rx_packets++;\r\nif (length < copybreak) {\r\nstruct sk_buff *new_skb =\r\nnetdev_alloc_skb_ip_align(netdev, length);\r\nif (new_skb) {\r\nskb_copy_to_linear_data_offset(new_skb,\r\n-NET_IP_ALIGN,\r\n(skb->data -\r\nNET_IP_ALIGN),\r\n(length +\r\nNET_IP_ALIGN));\r\nbuffer_info->skb = skb;\r\nskb = new_skb;\r\n}\r\n}\r\nskb_put(skb, length);\r\ne1000_rx_checksum(adapter, staterr, skb);\r\ne1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\r\ne1000_receive_skb(adapter, netdev, skb, staterr,\r\nrx_desc->wb.upper.vlan);\r\nnext_desc:\r\nrx_desc->wb.upper.status_error &= cpu_to_le32(~0xFF);\r\nif (cleaned_count >= E1000_RX_BUFFER_WRITE) {\r\nadapter->alloc_rx_buf(rx_ring, cleaned_count,\r\nGFP_ATOMIC);\r\ncleaned_count = 0;\r\n}\r\nrx_desc = next_rxd;\r\nbuffer_info = next_buffer;\r\nstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\r\n}\r\nrx_ring->next_to_clean = i;\r\ncleaned_count = e1000_desc_unused(rx_ring);\r\nif (cleaned_count)\r\nadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\r\nadapter->total_rx_bytes += total_rx_bytes;\r\nadapter->total_rx_packets += total_rx_packets;\r\nreturn cleaned;\r\n}\r\nstatic void e1000_put_txbuf(struct e1000_ring *tx_ring,\r\nstruct e1000_buffer *buffer_info)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nif (buffer_info->dma) {\r\nif (buffer_info->mapped_as_page)\r\ndma_unmap_page(&adapter->pdev->dev, buffer_info->dma,\r\nbuffer_info->length, DMA_TO_DEVICE);\r\nelse\r\ndma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\r\nbuffer_info->length, DMA_TO_DEVICE);\r\nbuffer_info->dma = 0;\r\n}\r\nif (buffer_info->skb) {\r\ndev_kfree_skb_any(buffer_info->skb);\r\nbuffer_info->skb = NULL;\r\n}\r\nbuffer_info->time_stamp = 0;\r\n}\r\nstatic void e1000_print_hw_hang(struct work_struct *work)\r\n{\r\nstruct e1000_adapter *adapter = container_of(work,\r\nstruct e1000_adapter,\r\nprint_hang_task);\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct e1000_ring *tx_ring = adapter->tx_ring;\r\nunsigned int i = tx_ring->next_to_clean;\r\nunsigned int eop = tx_ring->buffer_info[i].next_to_watch;\r\nstruct e1000_tx_desc *eop_desc = E1000_TX_DESC(*tx_ring, eop);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 phy_status, phy_1000t_status, phy_ext_status;\r\nu16 pci_status;\r\nif (test_bit(__E1000_DOWN, &adapter->state))\r\nreturn;\r\nif (!adapter->tx_hang_recheck && (adapter->flags2 & FLAG2_DMA_BURST)) {\r\new32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\r\ne1e_flush();\r\new32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\r\ne1e_flush();\r\nadapter->tx_hang_recheck = true;\r\nreturn;\r\n}\r\nadapter->tx_hang_recheck = false;\r\nif (er32(TDH(0)) == er32(TDT(0))) {\r\ne_dbg("false hang detected, ignoring\n");\r\nreturn;\r\n}\r\nnetif_stop_queue(netdev);\r\ne1e_rphy(hw, MII_BMSR, &phy_status);\r\ne1e_rphy(hw, MII_STAT1000, &phy_1000t_status);\r\ne1e_rphy(hw, MII_ESTATUS, &phy_ext_status);\r\npci_read_config_word(adapter->pdev, PCI_STATUS, &pci_status);\r\ne_err("Detected Hardware Unit Hang:\n"\r\n" TDH <%x>\n"\r\n" TDT <%x>\n"\r\n" next_to_use <%x>\n"\r\n" next_to_clean <%x>\n"\r\n"buffer_info[next_to_clean]:\n"\r\n" time_stamp <%lx>\n"\r\n" next_to_watch <%x>\n"\r\n" jiffies <%lx>\n"\r\n" next_to_watch.status <%x>\n"\r\n"MAC Status <%x>\n"\r\n"PHY Status <%x>\n"\r\n"PHY 1000BASE-T Status <%x>\n"\r\n"PHY Extended Status <%x>\n"\r\n"PCI Status <%x>\n",\r\nreadl(tx_ring->head), readl(tx_ring->tail), tx_ring->next_to_use,\r\ntx_ring->next_to_clean, tx_ring->buffer_info[eop].time_stamp,\r\neop, jiffies, eop_desc->upper.fields.status, er32(STATUS),\r\nphy_status, phy_1000t_status, phy_ext_status, pci_status);\r\ne1000e_dump(adapter);\r\nif ((hw->mac.type == e1000_pchlan) && (er32(CTRL) & E1000_CTRL_TFCE))\r\ne_err("Try turning off Tx pause (flow control) via ethtool\n");\r\n}\r\nstatic void e1000e_tx_hwtstamp_work(struct work_struct *work)\r\n{\r\nstruct e1000_adapter *adapter = container_of(work, struct e1000_adapter,\r\ntx_hwtstamp_work);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_VALID) {\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nu64 txstmp;\r\ntxstmp = er32(TXSTMPL);\r\ntxstmp |= (u64)er32(TXSTMPH) << 32;\r\ne1000e_systim_to_hwtstamp(adapter, &shhwtstamps, txstmp);\r\nskb_tstamp_tx(adapter->tx_hwtstamp_skb, &shhwtstamps);\r\ndev_kfree_skb_any(adapter->tx_hwtstamp_skb);\r\nadapter->tx_hwtstamp_skb = NULL;\r\n} else if (time_after(jiffies, adapter->tx_hwtstamp_start\r\n+ adapter->tx_timeout_factor * HZ)) {\r\ndev_kfree_skb_any(adapter->tx_hwtstamp_skb);\r\nadapter->tx_hwtstamp_skb = NULL;\r\nadapter->tx_hwtstamp_timeouts++;\r\ne_warn("clearing Tx timestamp hang\n");\r\n} else {\r\nschedule_work(&adapter->tx_hwtstamp_work);\r\n}\r\n}\r\nstatic bool e1000_clean_tx_irq(struct e1000_ring *tx_ring)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_tx_desc *tx_desc, *eop_desc;\r\nstruct e1000_buffer *buffer_info;\r\nunsigned int i, eop;\r\nunsigned int count = 0;\r\nunsigned int total_tx_bytes = 0, total_tx_packets = 0;\r\nunsigned int bytes_compl = 0, pkts_compl = 0;\r\ni = tx_ring->next_to_clean;\r\neop = tx_ring->buffer_info[i].next_to_watch;\r\neop_desc = E1000_TX_DESC(*tx_ring, eop);\r\nwhile ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&\r\n(count < tx_ring->count)) {\r\nbool cleaned = false;\r\nrmb();\r\nfor (; !cleaned; count++) {\r\ntx_desc = E1000_TX_DESC(*tx_ring, i);\r\nbuffer_info = &tx_ring->buffer_info[i];\r\ncleaned = (i == eop);\r\nif (cleaned) {\r\ntotal_tx_packets += buffer_info->segs;\r\ntotal_tx_bytes += buffer_info->bytecount;\r\nif (buffer_info->skb) {\r\nbytes_compl += buffer_info->skb->len;\r\npkts_compl++;\r\n}\r\n}\r\ne1000_put_txbuf(tx_ring, buffer_info);\r\ntx_desc->upper.data = 0;\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\n}\r\nif (i == tx_ring->next_to_use)\r\nbreak;\r\neop = tx_ring->buffer_info[i].next_to_watch;\r\neop_desc = E1000_TX_DESC(*tx_ring, eop);\r\n}\r\ntx_ring->next_to_clean = i;\r\nnetdev_completed_queue(netdev, pkts_compl, bytes_compl);\r\n#define TX_WAKE_THRESHOLD 32\r\nif (count && netif_carrier_ok(netdev) &&\r\ne1000_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD) {\r\nsmp_mb();\r\nif (netif_queue_stopped(netdev) &&\r\n!(test_bit(__E1000_DOWN, &adapter->state))) {\r\nnetif_wake_queue(netdev);\r\n++adapter->restart_queue;\r\n}\r\n}\r\nif (adapter->detect_tx_hung) {\r\nadapter->detect_tx_hung = false;\r\nif (tx_ring->buffer_info[i].time_stamp &&\r\ntime_after(jiffies, tx_ring->buffer_info[i].time_stamp\r\n+ (adapter->tx_timeout_factor * HZ)) &&\r\n!(er32(STATUS) & E1000_STATUS_TXOFF))\r\nschedule_work(&adapter->print_hang_task);\r\nelse\r\nadapter->tx_hang_recheck = false;\r\n}\r\nadapter->total_tx_bytes += total_tx_bytes;\r\nadapter->total_tx_packets += total_tx_packets;\r\nreturn count < tx_ring->count;\r\n}\r\nstatic bool e1000_clean_rx_irq_ps(struct e1000_ring *rx_ring, int *work_done,\r\nint work_to_do)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nunion e1000_rx_desc_packet_split *rx_desc, *next_rxd;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct e1000_buffer *buffer_info, *next_buffer;\r\nstruct e1000_ps_page *ps_page;\r\nstruct sk_buff *skb;\r\nunsigned int i, j;\r\nu32 length, staterr;\r\nint cleaned_count = 0;\r\nbool cleaned = false;\r\nunsigned int total_rx_bytes = 0, total_rx_packets = 0;\r\ni = rx_ring->next_to_clean;\r\nrx_desc = E1000_RX_DESC_PS(*rx_ring, i);\r\nstaterr = le32_to_cpu(rx_desc->wb.middle.status_error);\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nwhile (staterr & E1000_RXD_STAT_DD) {\r\nif (*work_done >= work_to_do)\r\nbreak;\r\n(*work_done)++;\r\nskb = buffer_info->skb;\r\nrmb();\r\nprefetch(skb->data - NET_IP_ALIGN);\r\ni++;\r\nif (i == rx_ring->count)\r\ni = 0;\r\nnext_rxd = E1000_RX_DESC_PS(*rx_ring, i);\r\nprefetch(next_rxd);\r\nnext_buffer = &rx_ring->buffer_info[i];\r\ncleaned = true;\r\ncleaned_count++;\r\ndma_unmap_single(&pdev->dev, buffer_info->dma,\r\nadapter->rx_ps_bsize0, DMA_FROM_DEVICE);\r\nbuffer_info->dma = 0;\r\nif (!(staterr & E1000_RXD_STAT_EOP))\r\nadapter->flags2 |= FLAG2_IS_DISCARDING;\r\nif (adapter->flags2 & FLAG2_IS_DISCARDING) {\r\ne_dbg("Packet Split buffers didn't pick up the full packet\n");\r\ndev_kfree_skb_irq(skb);\r\nif (staterr & E1000_RXD_STAT_EOP)\r\nadapter->flags2 &= ~FLAG2_IS_DISCARDING;\r\ngoto next_desc;\r\n}\r\nif (unlikely((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\r\n!(netdev->features & NETIF_F_RXALL))) {\r\ndev_kfree_skb_irq(skb);\r\ngoto next_desc;\r\n}\r\nlength = le16_to_cpu(rx_desc->wb.middle.length0);\r\nif (!length) {\r\ne_dbg("Last part of the packet spanning multiple descriptors\n");\r\ndev_kfree_skb_irq(skb);\r\ngoto next_desc;\r\n}\r\nskb_put(skb, length);\r\n{\r\nint l1 = le16_to_cpu(rx_desc->wb.upper.length[0]);\r\nif (l1 && (l1 <= copybreak) &&\r\n((length + l1) <= adapter->rx_ps_bsize0)) {\r\nu8 *vaddr;\r\nps_page = &buffer_info->ps_pages[0];\r\ndma_sync_single_for_cpu(&pdev->dev,\r\nps_page->dma,\r\nPAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\nvaddr = kmap_atomic(ps_page->page);\r\nmemcpy(skb_tail_pointer(skb), vaddr, l1);\r\nkunmap_atomic(vaddr);\r\ndma_sync_single_for_device(&pdev->dev,\r\nps_page->dma,\r\nPAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\r\nif (!(netdev->features & NETIF_F_RXFCS))\r\nl1 -= 4;\r\n}\r\nskb_put(skb, l1);\r\ngoto copydone;\r\n}\r\n}\r\nfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\r\nlength = le16_to_cpu(rx_desc->wb.upper.length[j]);\r\nif (!length)\r\nbreak;\r\nps_page = &buffer_info->ps_pages[j];\r\ndma_unmap_page(&pdev->dev, ps_page->dma, PAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\nps_page->dma = 0;\r\nskb_fill_page_desc(skb, j, ps_page->page, 0, length);\r\nps_page->page = NULL;\r\nskb->len += length;\r\nskb->data_len += length;\r\nskb->truesize += PAGE_SIZE;\r\n}\r\nif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\r\nif (!(netdev->features & NETIF_F_RXFCS))\r\npskb_trim(skb, skb->len - 4);\r\n}\r\ncopydone:\r\ntotal_rx_bytes += skb->len;\r\ntotal_rx_packets++;\r\ne1000_rx_checksum(adapter, staterr, skb);\r\ne1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\r\nif (rx_desc->wb.upper.header_status &\r\ncpu_to_le16(E1000_RXDPS_HDRSTAT_HDRSP))\r\nadapter->rx_hdr_split++;\r\ne1000_receive_skb(adapter, netdev, skb, staterr,\r\nrx_desc->wb.middle.vlan);\r\nnext_desc:\r\nrx_desc->wb.middle.status_error &= cpu_to_le32(~0xFF);\r\nbuffer_info->skb = NULL;\r\nif (cleaned_count >= E1000_RX_BUFFER_WRITE) {\r\nadapter->alloc_rx_buf(rx_ring, cleaned_count,\r\nGFP_ATOMIC);\r\ncleaned_count = 0;\r\n}\r\nrx_desc = next_rxd;\r\nbuffer_info = next_buffer;\r\nstaterr = le32_to_cpu(rx_desc->wb.middle.status_error);\r\n}\r\nrx_ring->next_to_clean = i;\r\ncleaned_count = e1000_desc_unused(rx_ring);\r\nif (cleaned_count)\r\nadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\r\nadapter->total_rx_bytes += total_rx_bytes;\r\nadapter->total_rx_packets += total_rx_packets;\r\nreturn cleaned;\r\n}\r\nstatic void e1000_consume_page(struct e1000_buffer *bi, struct sk_buff *skb,\r\nu16 length)\r\n{\r\nbi->page = NULL;\r\nskb->len += length;\r\nskb->data_len += length;\r\nskb->truesize += PAGE_SIZE;\r\n}\r\nstatic bool e1000_clean_jumbo_rx_irq(struct e1000_ring *rx_ring, int *work_done,\r\nint work_to_do)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nunion e1000_rx_desc_extended *rx_desc, *next_rxd;\r\nstruct e1000_buffer *buffer_info, *next_buffer;\r\nu32 length, staterr;\r\nunsigned int i;\r\nint cleaned_count = 0;\r\nbool cleaned = false;\r\nunsigned int total_rx_bytes = 0, total_rx_packets = 0;\r\nstruct skb_shared_info *shinfo;\r\ni = rx_ring->next_to_clean;\r\nrx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\r\nstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nwhile (staterr & E1000_RXD_STAT_DD) {\r\nstruct sk_buff *skb;\r\nif (*work_done >= work_to_do)\r\nbreak;\r\n(*work_done)++;\r\nrmb();\r\nskb = buffer_info->skb;\r\nbuffer_info->skb = NULL;\r\n++i;\r\nif (i == rx_ring->count)\r\ni = 0;\r\nnext_rxd = E1000_RX_DESC_EXT(*rx_ring, i);\r\nprefetch(next_rxd);\r\nnext_buffer = &rx_ring->buffer_info[i];\r\ncleaned = true;\r\ncleaned_count++;\r\ndma_unmap_page(&pdev->dev, buffer_info->dma, PAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\nbuffer_info->dma = 0;\r\nlength = le16_to_cpu(rx_desc->wb.upper.length);\r\nif (unlikely((staterr & E1000_RXD_STAT_EOP) &&\r\n((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\r\n!(netdev->features & NETIF_F_RXALL)))) {\r\nbuffer_info->skb = skb;\r\nif (rx_ring->rx_skb_top)\r\ndev_kfree_skb_irq(rx_ring->rx_skb_top);\r\nrx_ring->rx_skb_top = NULL;\r\ngoto next_desc;\r\n}\r\n#define rxtop (rx_ring->rx_skb_top)\r\nif (!(staterr & E1000_RXD_STAT_EOP)) {\r\nif (!rxtop) {\r\nrxtop = skb;\r\nskb_fill_page_desc(rxtop, 0, buffer_info->page,\r\n0, length);\r\n} else {\r\nshinfo = skb_shinfo(rxtop);\r\nskb_fill_page_desc(rxtop, shinfo->nr_frags,\r\nbuffer_info->page, 0,\r\nlength);\r\nbuffer_info->skb = skb;\r\n}\r\ne1000_consume_page(buffer_info, rxtop, length);\r\ngoto next_desc;\r\n} else {\r\nif (rxtop) {\r\nshinfo = skb_shinfo(rxtop);\r\nskb_fill_page_desc(rxtop, shinfo->nr_frags,\r\nbuffer_info->page, 0,\r\nlength);\r\nbuffer_info->skb = skb;\r\nskb = rxtop;\r\nrxtop = NULL;\r\ne1000_consume_page(buffer_info, skb, length);\r\n} else {\r\nif (length <= copybreak &&\r\nskb_tailroom(skb) >= length) {\r\nu8 *vaddr;\r\nvaddr = kmap_atomic(buffer_info->page);\r\nmemcpy(skb_tail_pointer(skb), vaddr,\r\nlength);\r\nkunmap_atomic(vaddr);\r\nskb_put(skb, length);\r\n} else {\r\nskb_fill_page_desc(skb, 0,\r\nbuffer_info->page, 0,\r\nlength);\r\ne1000_consume_page(buffer_info, skb,\r\nlength);\r\n}\r\n}\r\n}\r\ne1000_rx_checksum(adapter, staterr, skb);\r\ne1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\r\ntotal_rx_bytes += skb->len;\r\ntotal_rx_packets++;\r\nif (!pskb_may_pull(skb, ETH_HLEN)) {\r\ne_err("pskb_may_pull failed.\n");\r\ndev_kfree_skb_irq(skb);\r\ngoto next_desc;\r\n}\r\ne1000_receive_skb(adapter, netdev, skb, staterr,\r\nrx_desc->wb.upper.vlan);\r\nnext_desc:\r\nrx_desc->wb.upper.status_error &= cpu_to_le32(~0xFF);\r\nif (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {\r\nadapter->alloc_rx_buf(rx_ring, cleaned_count,\r\nGFP_ATOMIC);\r\ncleaned_count = 0;\r\n}\r\nrx_desc = next_rxd;\r\nbuffer_info = next_buffer;\r\nstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\r\n}\r\nrx_ring->next_to_clean = i;\r\ncleaned_count = e1000_desc_unused(rx_ring);\r\nif (cleaned_count)\r\nadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\r\nadapter->total_rx_bytes += total_rx_bytes;\r\nadapter->total_rx_packets += total_rx_packets;\r\nreturn cleaned;\r\n}\r\nstatic void e1000_clean_rx_ring(struct e1000_ring *rx_ring)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct e1000_buffer *buffer_info;\r\nstruct e1000_ps_page *ps_page;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nunsigned int i, j;\r\nfor (i = 0; i < rx_ring->count; i++) {\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nif (buffer_info->dma) {\r\nif (adapter->clean_rx == e1000_clean_rx_irq)\r\ndma_unmap_single(&pdev->dev, buffer_info->dma,\r\nadapter->rx_buffer_len,\r\nDMA_FROM_DEVICE);\r\nelse if (adapter->clean_rx == e1000_clean_jumbo_rx_irq)\r\ndma_unmap_page(&pdev->dev, buffer_info->dma,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\nelse if (adapter->clean_rx == e1000_clean_rx_irq_ps)\r\ndma_unmap_single(&pdev->dev, buffer_info->dma,\r\nadapter->rx_ps_bsize0,\r\nDMA_FROM_DEVICE);\r\nbuffer_info->dma = 0;\r\n}\r\nif (buffer_info->page) {\r\nput_page(buffer_info->page);\r\nbuffer_info->page = NULL;\r\n}\r\nif (buffer_info->skb) {\r\ndev_kfree_skb(buffer_info->skb);\r\nbuffer_info->skb = NULL;\r\n}\r\nfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\r\nps_page = &buffer_info->ps_pages[j];\r\nif (!ps_page->page)\r\nbreak;\r\ndma_unmap_page(&pdev->dev, ps_page->dma, PAGE_SIZE,\r\nDMA_FROM_DEVICE);\r\nps_page->dma = 0;\r\nput_page(ps_page->page);\r\nps_page->page = NULL;\r\n}\r\n}\r\nif (rx_ring->rx_skb_top) {\r\ndev_kfree_skb(rx_ring->rx_skb_top);\r\nrx_ring->rx_skb_top = NULL;\r\n}\r\nmemset(rx_ring->desc, 0, rx_ring->size);\r\nrx_ring->next_to_clean = 0;\r\nrx_ring->next_to_use = 0;\r\nadapter->flags2 &= ~FLAG2_IS_DISCARDING;\r\nwritel(0, rx_ring->head);\r\nif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\r\ne1000e_update_rdt_wa(rx_ring, 0);\r\nelse\r\nwritel(0, rx_ring->tail);\r\n}\r\nstatic void e1000e_downshift_workaround(struct work_struct *work)\r\n{\r\nstruct e1000_adapter *adapter = container_of(work,\r\nstruct e1000_adapter,\r\ndownshift_task);\r\nif (test_bit(__E1000_DOWN, &adapter->state))\r\nreturn;\r\ne1000e_gig_downshift_workaround_ich8lan(&adapter->hw);\r\n}\r\nstatic irqreturn_t e1000_intr_msi(int __always_unused irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 icr = er32(ICR);\r\nif (icr & E1000_ICR_LSC) {\r\nhw->mac.get_link_status = true;\r\nif ((adapter->flags & FLAG_LSC_GIG_SPEED_DROP) &&\r\n(!(er32(STATUS) & E1000_STATUS_LU)))\r\nschedule_work(&adapter->downshift_task);\r\nif (netif_carrier_ok(netdev) &&\r\nadapter->flags & FLAG_RX_NEEDS_RESTART) {\r\nu32 rctl = er32(RCTL);\r\new32(RCTL, rctl & ~E1000_RCTL_EN);\r\nadapter->flags |= FLAG_RESTART_NOW;\r\n}\r\nif (!test_bit(__E1000_DOWN, &adapter->state))\r\nmod_timer(&adapter->watchdog_timer, jiffies + 1);\r\n}\r\nif ((icr & E1000_ICR_ECCER) && (hw->mac.type == e1000_pch_lpt)) {\r\nu32 pbeccsts = er32(PBECCSTS);\r\nadapter->corr_errors +=\r\npbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\r\nadapter->uncorr_errors +=\r\n(pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\r\nE1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\r\nschedule_work(&adapter->reset_task);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (napi_schedule_prep(&adapter->napi)) {\r\nadapter->total_tx_bytes = 0;\r\nadapter->total_tx_packets = 0;\r\nadapter->total_rx_bytes = 0;\r\nadapter->total_rx_packets = 0;\r\n__napi_schedule(&adapter->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t e1000_intr(int __always_unused irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl, icr = er32(ICR);\r\nif (!icr || test_bit(__E1000_DOWN, &adapter->state))\r\nreturn IRQ_NONE;\r\nif (!(icr & E1000_ICR_INT_ASSERTED))\r\nreturn IRQ_NONE;\r\nif (icr & E1000_ICR_LSC) {\r\nhw->mac.get_link_status = true;\r\nif ((adapter->flags & FLAG_LSC_GIG_SPEED_DROP) &&\r\n(!(er32(STATUS) & E1000_STATUS_LU)))\r\nschedule_work(&adapter->downshift_task);\r\nif (netif_carrier_ok(netdev) &&\r\n(adapter->flags & FLAG_RX_NEEDS_RESTART)) {\r\nrctl = er32(RCTL);\r\new32(RCTL, rctl & ~E1000_RCTL_EN);\r\nadapter->flags |= FLAG_RESTART_NOW;\r\n}\r\nif (!test_bit(__E1000_DOWN, &adapter->state))\r\nmod_timer(&adapter->watchdog_timer, jiffies + 1);\r\n}\r\nif ((icr & E1000_ICR_ECCER) && (hw->mac.type == e1000_pch_lpt)) {\r\nu32 pbeccsts = er32(PBECCSTS);\r\nadapter->corr_errors +=\r\npbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\r\nadapter->uncorr_errors +=\r\n(pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\r\nE1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\r\nschedule_work(&adapter->reset_task);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (napi_schedule_prep(&adapter->napi)) {\r\nadapter->total_tx_bytes = 0;\r\nadapter->total_tx_packets = 0;\r\nadapter->total_rx_bytes = 0;\r\nadapter->total_rx_packets = 0;\r\n__napi_schedule(&adapter->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t e1000_msix_other(int __always_unused irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 icr = er32(ICR);\r\nif (!(icr & E1000_ICR_INT_ASSERTED)) {\r\nif (!test_bit(__E1000_DOWN, &adapter->state))\r\new32(IMS, E1000_IMS_OTHER);\r\nreturn IRQ_NONE;\r\n}\r\nif (icr & adapter->eiac_mask)\r\new32(ICS, (icr & adapter->eiac_mask));\r\nif (icr & E1000_ICR_OTHER) {\r\nif (!(icr & E1000_ICR_LSC))\r\ngoto no_link_interrupt;\r\nhw->mac.get_link_status = true;\r\nif (!test_bit(__E1000_DOWN, &adapter->state))\r\nmod_timer(&adapter->watchdog_timer, jiffies + 1);\r\n}\r\nno_link_interrupt:\r\nif (!test_bit(__E1000_DOWN, &adapter->state))\r\new32(IMS, E1000_IMS_LSC | E1000_IMS_OTHER);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t e1000_intr_msix_tx(int __always_unused irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_ring *tx_ring = adapter->tx_ring;\r\nadapter->total_tx_bytes = 0;\r\nadapter->total_tx_packets = 0;\r\nif (!e1000_clean_tx_irq(tx_ring))\r\new32(ICS, tx_ring->ims_val);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t e1000_intr_msix_rx(int __always_unused irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_ring *rx_ring = adapter->rx_ring;\r\nif (rx_ring->set_itr) {\r\nwritel(1000000000 / (rx_ring->itr_val * 256),\r\nrx_ring->itr_register);\r\nrx_ring->set_itr = 0;\r\n}\r\nif (napi_schedule_prep(&adapter->napi)) {\r\nadapter->total_rx_bytes = 0;\r\nadapter->total_rx_packets = 0;\r\n__napi_schedule(&adapter->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void e1000_configure_msix(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_ring *rx_ring = adapter->rx_ring;\r\nstruct e1000_ring *tx_ring = adapter->tx_ring;\r\nint vector = 0;\r\nu32 ctrl_ext, ivar = 0;\r\nadapter->eiac_mask = 0;\r\nif (hw->mac.type == e1000_82574) {\r\nu32 rfctl = er32(RFCTL);\r\nrfctl |= E1000_RFCTL_ACK_DIS;\r\new32(RFCTL, rfctl);\r\n}\r\nrx_ring->ims_val = E1000_IMS_RXQ0;\r\nadapter->eiac_mask |= rx_ring->ims_val;\r\nif (rx_ring->itr_val)\r\nwritel(1000000000 / (rx_ring->itr_val * 256),\r\nrx_ring->itr_register);\r\nelse\r\nwritel(1, rx_ring->itr_register);\r\nivar = E1000_IVAR_INT_ALLOC_VALID | vector;\r\ntx_ring->ims_val = E1000_IMS_TXQ0;\r\nvector++;\r\nif (tx_ring->itr_val)\r\nwritel(1000000000 / (tx_ring->itr_val * 256),\r\ntx_ring->itr_register);\r\nelse\r\nwritel(1, tx_ring->itr_register);\r\nadapter->eiac_mask |= tx_ring->ims_val;\r\nivar |= ((E1000_IVAR_INT_ALLOC_VALID | vector) << 8);\r\nvector++;\r\nivar |= ((E1000_IVAR_INT_ALLOC_VALID | vector) << 16);\r\nif (rx_ring->itr_val)\r\nwritel(1000000000 / (rx_ring->itr_val * 256),\r\nhw->hw_addr + E1000_EITR_82574(vector));\r\nelse\r\nwritel(1, hw->hw_addr + E1000_EITR_82574(vector));\r\nivar |= (1 << 31);\r\new32(IVAR, ivar);\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_PBA_CLR;\r\new32(IAM, ~E1000_EIAC_MASK_82574 | E1000_IMS_OTHER);\r\nctrl_ext |= E1000_CTRL_EXT_EIAME;\r\new32(CTRL_EXT, ctrl_ext);\r\ne1e_flush();\r\n}\r\nvoid e1000e_reset_interrupt_capability(struct e1000_adapter *adapter)\r\n{\r\nif (adapter->msix_entries) {\r\npci_disable_msix(adapter->pdev);\r\nkfree(adapter->msix_entries);\r\nadapter->msix_entries = NULL;\r\n} else if (adapter->flags & FLAG_MSI_ENABLED) {\r\npci_disable_msi(adapter->pdev);\r\nadapter->flags &= ~FLAG_MSI_ENABLED;\r\n}\r\n}\r\nvoid e1000e_set_interrupt_capability(struct e1000_adapter *adapter)\r\n{\r\nint err;\r\nint i;\r\nswitch (adapter->int_mode) {\r\ncase E1000E_INT_MODE_MSIX:\r\nif (adapter->flags & FLAG_HAS_MSIX) {\r\nadapter->num_vectors = 3;\r\nadapter->msix_entries = kcalloc(adapter->num_vectors,\r\nsizeof(struct\r\nmsix_entry),\r\nGFP_KERNEL);\r\nif (adapter->msix_entries) {\r\nstruct e1000_adapter *a = adapter;\r\nfor (i = 0; i < adapter->num_vectors; i++)\r\nadapter->msix_entries[i].entry = i;\r\nerr = pci_enable_msix_range(a->pdev,\r\na->msix_entries,\r\na->num_vectors,\r\na->num_vectors);\r\nif (err > 0)\r\nreturn;\r\n}\r\ne_err("Failed to initialize MSI-X interrupts. Falling back to MSI interrupts.\n");\r\ne1000e_reset_interrupt_capability(adapter);\r\n}\r\nadapter->int_mode = E1000E_INT_MODE_MSI;\r\ncase E1000E_INT_MODE_MSI:\r\nif (!pci_enable_msi(adapter->pdev)) {\r\nadapter->flags |= FLAG_MSI_ENABLED;\r\n} else {\r\nadapter->int_mode = E1000E_INT_MODE_LEGACY;\r\ne_err("Failed to initialize MSI interrupts. Falling back to legacy interrupts.\n");\r\n}\r\ncase E1000E_INT_MODE_LEGACY:\r\nbreak;\r\n}\r\nadapter->num_vectors = 1;\r\n}\r\nstatic int e1000_request_msix(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint err = 0, vector = 0;\r\nif (strlen(netdev->name) < (IFNAMSIZ - 5))\r\nsnprintf(adapter->rx_ring->name,\r\nsizeof(adapter->rx_ring->name) - 1,\r\n"%s-rx-0", netdev->name);\r\nelse\r\nmemcpy(adapter->rx_ring->name, netdev->name, IFNAMSIZ);\r\nerr = request_irq(adapter->msix_entries[vector].vector,\r\ne1000_intr_msix_rx, 0, adapter->rx_ring->name,\r\nnetdev);\r\nif (err)\r\nreturn err;\r\nadapter->rx_ring->itr_register = adapter->hw.hw_addr +\r\nE1000_EITR_82574(vector);\r\nadapter->rx_ring->itr_val = adapter->itr;\r\nvector++;\r\nif (strlen(netdev->name) < (IFNAMSIZ - 5))\r\nsnprintf(adapter->tx_ring->name,\r\nsizeof(adapter->tx_ring->name) - 1,\r\n"%s-tx-0", netdev->name);\r\nelse\r\nmemcpy(adapter->tx_ring->name, netdev->name, IFNAMSIZ);\r\nerr = request_irq(adapter->msix_entries[vector].vector,\r\ne1000_intr_msix_tx, 0, adapter->tx_ring->name,\r\nnetdev);\r\nif (err)\r\nreturn err;\r\nadapter->tx_ring->itr_register = adapter->hw.hw_addr +\r\nE1000_EITR_82574(vector);\r\nadapter->tx_ring->itr_val = adapter->itr;\r\nvector++;\r\nerr = request_irq(adapter->msix_entries[vector].vector,\r\ne1000_msix_other, 0, netdev->name, netdev);\r\nif (err)\r\nreturn err;\r\ne1000_configure_msix(adapter);\r\nreturn 0;\r\n}\r\nstatic int e1000_request_irq(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint err;\r\nif (adapter->msix_entries) {\r\nerr = e1000_request_msix(adapter);\r\nif (!err)\r\nreturn err;\r\ne1000e_reset_interrupt_capability(adapter);\r\nadapter->int_mode = E1000E_INT_MODE_MSI;\r\ne1000e_set_interrupt_capability(adapter);\r\n}\r\nif (adapter->flags & FLAG_MSI_ENABLED) {\r\nerr = request_irq(adapter->pdev->irq, e1000_intr_msi, 0,\r\nnetdev->name, netdev);\r\nif (!err)\r\nreturn err;\r\ne1000e_reset_interrupt_capability(adapter);\r\nadapter->int_mode = E1000E_INT_MODE_LEGACY;\r\n}\r\nerr = request_irq(adapter->pdev->irq, e1000_intr, IRQF_SHARED,\r\nnetdev->name, netdev);\r\nif (err)\r\ne_err("Unable to allocate interrupt, Error: %d\n", err);\r\nreturn err;\r\n}\r\nstatic void e1000_free_irq(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (adapter->msix_entries) {\r\nint vector = 0;\r\nfree_irq(adapter->msix_entries[vector].vector, netdev);\r\nvector++;\r\nfree_irq(adapter->msix_entries[vector].vector, netdev);\r\nvector++;\r\nfree_irq(adapter->msix_entries[vector].vector, netdev);\r\nreturn;\r\n}\r\nfree_irq(adapter->pdev->irq, netdev);\r\n}\r\nstatic void e1000_irq_disable(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\new32(IMC, ~0);\r\nif (adapter->msix_entries)\r\new32(EIAC_82574, 0);\r\ne1e_flush();\r\nif (adapter->msix_entries) {\r\nint i;\r\nfor (i = 0; i < adapter->num_vectors; i++)\r\nsynchronize_irq(adapter->msix_entries[i].vector);\r\n} else {\r\nsynchronize_irq(adapter->pdev->irq);\r\n}\r\n}\r\nstatic void e1000_irq_enable(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (adapter->msix_entries) {\r\new32(EIAC_82574, adapter->eiac_mask & E1000_EIAC_MASK_82574);\r\new32(IMS, adapter->eiac_mask | E1000_IMS_OTHER | E1000_IMS_LSC);\r\n} else if (hw->mac.type == e1000_pch_lpt) {\r\new32(IMS, IMS_ENABLE_MASK | E1000_IMS_ECCER);\r\n} else {\r\new32(IMS, IMS_ENABLE_MASK);\r\n}\r\ne1e_flush();\r\n}\r\nvoid e1000e_get_hw_control(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl_ext;\r\nu32 swsm;\r\nif (adapter->flags & FLAG_HAS_SWSM_ON_LOAD) {\r\nswsm = er32(SWSM);\r\new32(SWSM, swsm | E1000_SWSM_DRV_LOAD);\r\n} else if (adapter->flags & FLAG_HAS_CTRLEXT_ON_LOAD) {\r\nctrl_ext = er32(CTRL_EXT);\r\new32(CTRL_EXT, ctrl_ext | E1000_CTRL_EXT_DRV_LOAD);\r\n}\r\n}\r\nvoid e1000e_release_hw_control(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl_ext;\r\nu32 swsm;\r\nif (adapter->flags & FLAG_HAS_SWSM_ON_LOAD) {\r\nswsm = er32(SWSM);\r\new32(SWSM, swsm & ~E1000_SWSM_DRV_LOAD);\r\n} else if (adapter->flags & FLAG_HAS_CTRLEXT_ON_LOAD) {\r\nctrl_ext = er32(CTRL_EXT);\r\new32(CTRL_EXT, ctrl_ext & ~E1000_CTRL_EXT_DRV_LOAD);\r\n}\r\n}\r\nstatic int e1000_alloc_ring_dma(struct e1000_adapter *adapter,\r\nstruct e1000_ring *ring)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nring->desc = dma_alloc_coherent(&pdev->dev, ring->size, &ring->dma,\r\nGFP_KERNEL);\r\nif (!ring->desc)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint e1000e_setup_tx_resources(struct e1000_ring *tx_ring)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nint err = -ENOMEM, size;\r\nsize = sizeof(struct e1000_buffer) * tx_ring->count;\r\ntx_ring->buffer_info = vzalloc(size);\r\nif (!tx_ring->buffer_info)\r\ngoto err;\r\ntx_ring->size = tx_ring->count * sizeof(struct e1000_tx_desc);\r\ntx_ring->size = ALIGN(tx_ring->size, 4096);\r\nerr = e1000_alloc_ring_dma(adapter, tx_ring);\r\nif (err)\r\ngoto err;\r\ntx_ring->next_to_use = 0;\r\ntx_ring->next_to_clean = 0;\r\nreturn 0;\r\nerr:\r\nvfree(tx_ring->buffer_info);\r\ne_err("Unable to allocate memory for the transmit descriptor ring\n");\r\nreturn err;\r\n}\r\nint e1000e_setup_rx_resources(struct e1000_ring *rx_ring)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct e1000_buffer *buffer_info;\r\nint i, size, desc_len, err = -ENOMEM;\r\nsize = sizeof(struct e1000_buffer) * rx_ring->count;\r\nrx_ring->buffer_info = vzalloc(size);\r\nif (!rx_ring->buffer_info)\r\ngoto err;\r\nfor (i = 0; i < rx_ring->count; i++) {\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nbuffer_info->ps_pages = kcalloc(PS_PAGE_BUFFERS,\r\nsizeof(struct e1000_ps_page),\r\nGFP_KERNEL);\r\nif (!buffer_info->ps_pages)\r\ngoto err_pages;\r\n}\r\ndesc_len = sizeof(union e1000_rx_desc_packet_split);\r\nrx_ring->size = rx_ring->count * desc_len;\r\nrx_ring->size = ALIGN(rx_ring->size, 4096);\r\nerr = e1000_alloc_ring_dma(adapter, rx_ring);\r\nif (err)\r\ngoto err_pages;\r\nrx_ring->next_to_clean = 0;\r\nrx_ring->next_to_use = 0;\r\nrx_ring->rx_skb_top = NULL;\r\nreturn 0;\r\nerr_pages:\r\nfor (i = 0; i < rx_ring->count; i++) {\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nkfree(buffer_info->ps_pages);\r\n}\r\nerr:\r\nvfree(rx_ring->buffer_info);\r\ne_err("Unable to allocate memory for the receive descriptor ring\n");\r\nreturn err;\r\n}\r\nstatic void e1000_clean_tx_ring(struct e1000_ring *tx_ring)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nstruct e1000_buffer *buffer_info;\r\nunsigned long size;\r\nunsigned int i;\r\nfor (i = 0; i < tx_ring->count; i++) {\r\nbuffer_info = &tx_ring->buffer_info[i];\r\ne1000_put_txbuf(tx_ring, buffer_info);\r\n}\r\nnetdev_reset_queue(adapter->netdev);\r\nsize = sizeof(struct e1000_buffer) * tx_ring->count;\r\nmemset(tx_ring->buffer_info, 0, size);\r\nmemset(tx_ring->desc, 0, tx_ring->size);\r\ntx_ring->next_to_use = 0;\r\ntx_ring->next_to_clean = 0;\r\nwritel(0, tx_ring->head);\r\nif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\r\ne1000e_update_tdt_wa(tx_ring, 0);\r\nelse\r\nwritel(0, tx_ring->tail);\r\n}\r\nvoid e1000e_free_tx_resources(struct e1000_ring *tx_ring)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nstruct pci_dev *pdev = adapter->pdev;\r\ne1000_clean_tx_ring(tx_ring);\r\nvfree(tx_ring->buffer_info);\r\ntx_ring->buffer_info = NULL;\r\ndma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,\r\ntx_ring->dma);\r\ntx_ring->desc = NULL;\r\n}\r\nvoid e1000e_free_rx_resources(struct e1000_ring *rx_ring)\r\n{\r\nstruct e1000_adapter *adapter = rx_ring->adapter;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint i;\r\ne1000_clean_rx_ring(rx_ring);\r\nfor (i = 0; i < rx_ring->count; i++)\r\nkfree(rx_ring->buffer_info[i].ps_pages);\r\nvfree(rx_ring->buffer_info);\r\nrx_ring->buffer_info = NULL;\r\ndma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,\r\nrx_ring->dma);\r\nrx_ring->desc = NULL;\r\n}\r\nstatic unsigned int e1000_update_itr(u16 itr_setting, int packets, int bytes)\r\n{\r\nunsigned int retval = itr_setting;\r\nif (packets == 0)\r\nreturn itr_setting;\r\nswitch (itr_setting) {\r\ncase lowest_latency:\r\nif (bytes / packets > 8000)\r\nretval = bulk_latency;\r\nelse if ((packets < 5) && (bytes > 512))\r\nretval = low_latency;\r\nbreak;\r\ncase low_latency:\r\nif (bytes > 10000) {\r\nif (bytes / packets > 8000)\r\nretval = bulk_latency;\r\nelse if ((packets < 10) || ((bytes / packets) > 1200))\r\nretval = bulk_latency;\r\nelse if ((packets > 35))\r\nretval = lowest_latency;\r\n} else if (bytes / packets > 2000) {\r\nretval = bulk_latency;\r\n} else if (packets <= 2 && bytes < 512) {\r\nretval = lowest_latency;\r\n}\r\nbreak;\r\ncase bulk_latency:\r\nif (bytes > 25000) {\r\nif (packets > 35)\r\nretval = low_latency;\r\n} else if (bytes < 6000) {\r\nretval = low_latency;\r\n}\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void e1000_set_itr(struct e1000_adapter *adapter)\r\n{\r\nu16 current_itr;\r\nu32 new_itr = adapter->itr;\r\nif (adapter->link_speed != SPEED_1000) {\r\ncurrent_itr = 0;\r\nnew_itr = 4000;\r\ngoto set_itr_now;\r\n}\r\nif (adapter->flags2 & FLAG2_DISABLE_AIM) {\r\nnew_itr = 0;\r\ngoto set_itr_now;\r\n}\r\nadapter->tx_itr = e1000_update_itr(adapter->tx_itr,\r\nadapter->total_tx_packets,\r\nadapter->total_tx_bytes);\r\nif (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)\r\nadapter->tx_itr = low_latency;\r\nadapter->rx_itr = e1000_update_itr(adapter->rx_itr,\r\nadapter->total_rx_packets,\r\nadapter->total_rx_bytes);\r\nif (adapter->itr_setting == 3 && adapter->rx_itr == lowest_latency)\r\nadapter->rx_itr = low_latency;\r\ncurrent_itr = max(adapter->rx_itr, adapter->tx_itr);\r\nswitch (current_itr) {\r\ncase lowest_latency:\r\nnew_itr = 70000;\r\nbreak;\r\ncase low_latency:\r\nnew_itr = 20000;\r\nbreak;\r\ncase bulk_latency:\r\nnew_itr = 4000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nset_itr_now:\r\nif (new_itr != adapter->itr) {\r\nnew_itr = new_itr > adapter->itr ?\r\nmin(adapter->itr + (new_itr >> 2), new_itr) : new_itr;\r\nadapter->itr = new_itr;\r\nadapter->rx_ring->itr_val = new_itr;\r\nif (adapter->msix_entries)\r\nadapter->rx_ring->set_itr = 1;\r\nelse\r\ne1000e_write_itr(adapter, new_itr);\r\n}\r\n}\r\nvoid e1000e_write_itr(struct e1000_adapter *adapter, u32 itr)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 new_itr = itr ? 1000000000 / (itr * 256) : 0;\r\nif (adapter->msix_entries) {\r\nint vector;\r\nfor (vector = 0; vector < adapter->num_vectors; vector++)\r\nwritel(new_itr, hw->hw_addr + E1000_EITR_82574(vector));\r\n} else {\r\new32(ITR, new_itr);\r\n}\r\n}\r\nstatic int e1000_alloc_queues(struct e1000_adapter *adapter)\r\n{\r\nint size = sizeof(struct e1000_ring);\r\nadapter->tx_ring = kzalloc(size, GFP_KERNEL);\r\nif (!adapter->tx_ring)\r\ngoto err;\r\nadapter->tx_ring->count = adapter->tx_ring_count;\r\nadapter->tx_ring->adapter = adapter;\r\nadapter->rx_ring = kzalloc(size, GFP_KERNEL);\r\nif (!adapter->rx_ring)\r\ngoto err;\r\nadapter->rx_ring->count = adapter->rx_ring_count;\r\nadapter->rx_ring->adapter = adapter;\r\nreturn 0;\r\nerr:\r\ne_err("Unable to allocate memory for queues\n");\r\nkfree(adapter->rx_ring);\r\nkfree(adapter->tx_ring);\r\nreturn -ENOMEM;\r\n}\r\nstatic int e1000e_poll(struct napi_struct *napi, int weight)\r\n{\r\nstruct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,\r\nnapi);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct net_device *poll_dev = adapter->netdev;\r\nint tx_cleaned = 1, work_done = 0;\r\nadapter = netdev_priv(poll_dev);\r\nif (!adapter->msix_entries ||\r\n(adapter->rx_ring->ims_val & adapter->tx_ring->ims_val))\r\ntx_cleaned = e1000_clean_tx_irq(adapter->tx_ring);\r\nadapter->clean_rx(adapter->rx_ring, &work_done, weight);\r\nif (!tx_cleaned)\r\nwork_done = weight;\r\nif (work_done < weight) {\r\nif (adapter->itr_setting & 3)\r\ne1000_set_itr(adapter);\r\nnapi_complete(napi);\r\nif (!test_bit(__E1000_DOWN, &adapter->state)) {\r\nif (adapter->msix_entries)\r\new32(IMS, adapter->rx_ring->ims_val);\r\nelse\r\ne1000_irq_enable(adapter);\r\n}\r\n}\r\nreturn work_done;\r\n}\r\nstatic int e1000_vlan_rx_add_vid(struct net_device *netdev,\r\n__always_unused __be16 proto, u16 vid)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 vfta, index;\r\nif ((adapter->hw.mng_cookie.status &\r\nE1000_MNG_DHCP_COOKIE_STATUS_VLAN) &&\r\n(vid == adapter->mng_vlan_id))\r\nreturn 0;\r\nif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\r\nindex = (vid >> 5) & 0x7F;\r\nvfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);\r\nvfta |= (1 << (vid & 0x1F));\r\nhw->mac.ops.write_vfta(hw, index, vfta);\r\n}\r\nset_bit(vid, adapter->active_vlans);\r\nreturn 0;\r\n}\r\nstatic int e1000_vlan_rx_kill_vid(struct net_device *netdev,\r\n__always_unused __be16 proto, u16 vid)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 vfta, index;\r\nif ((adapter->hw.mng_cookie.status &\r\nE1000_MNG_DHCP_COOKIE_STATUS_VLAN) &&\r\n(vid == adapter->mng_vlan_id)) {\r\ne1000e_release_hw_control(adapter);\r\nreturn 0;\r\n}\r\nif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\r\nindex = (vid >> 5) & 0x7F;\r\nvfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);\r\nvfta &= ~(1 << (vid & 0x1F));\r\nhw->mac.ops.write_vfta(hw, index, vfta);\r\n}\r\nclear_bit(vid, adapter->active_vlans);\r\nreturn 0;\r\n}\r\nstatic void e1000e_vlan_filter_disable(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl;\r\nif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\r\nrctl = er32(RCTL);\r\nrctl &= ~(E1000_RCTL_VFE | E1000_RCTL_CFIEN);\r\new32(RCTL, rctl);\r\nif (adapter->mng_vlan_id != (u16)E1000_MNG_VLAN_NONE) {\r\ne1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),\r\nadapter->mng_vlan_id);\r\nadapter->mng_vlan_id = E1000_MNG_VLAN_NONE;\r\n}\r\n}\r\n}\r\nstatic void e1000e_vlan_filter_enable(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl;\r\nif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\r\nrctl = er32(RCTL);\r\nrctl |= E1000_RCTL_VFE;\r\nrctl &= ~E1000_RCTL_CFIEN;\r\new32(RCTL, rctl);\r\n}\r\n}\r\nstatic void e1000e_vlan_strip_disable(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl;\r\nctrl = er32(CTRL);\r\nctrl &= ~E1000_CTRL_VME;\r\new32(CTRL, ctrl);\r\n}\r\nstatic void e1000e_vlan_strip_enable(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl;\r\nctrl = er32(CTRL);\r\nctrl |= E1000_CTRL_VME;\r\new32(CTRL, ctrl);\r\n}\r\nstatic void e1000_update_mng_vlan(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu16 vid = adapter->hw.mng_cookie.vlan_id;\r\nu16 old_vid = adapter->mng_vlan_id;\r\nif (adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN) {\r\ne1000_vlan_rx_add_vid(netdev, htons(ETH_P_8021Q), vid);\r\nadapter->mng_vlan_id = vid;\r\n}\r\nif ((old_vid != (u16)E1000_MNG_VLAN_NONE) && (vid != old_vid))\r\ne1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q), old_vid);\r\n}\r\nstatic void e1000_restore_vlan(struct e1000_adapter *adapter)\r\n{\r\nu16 vid;\r\ne1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), 0);\r\nfor_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)\r\ne1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);\r\n}\r\nstatic void e1000_init_manageability_pt(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 manc, manc2h, mdef, i, j;\r\nif (!(adapter->flags & FLAG_MNG_PT_ENABLED))\r\nreturn;\r\nmanc = er32(MANC);\r\nmanc |= E1000_MANC_EN_MNG2HOST;\r\nmanc2h = er32(MANC2H);\r\nswitch (hw->mac.type) {\r\ndefault:\r\nmanc2h |= (E1000_MANC2H_PORT_623 | E1000_MANC2H_PORT_664);\r\nbreak;\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nfor (i = 0, j = 0; i < 8; i++) {\r\nmdef = er32(MDEF(i));\r\nif (mdef & ~(E1000_MDEF_PORT_623 | E1000_MDEF_PORT_664))\r\ncontinue;\r\nif (mdef)\r\nmanc2h |= (1 << i);\r\nj |= mdef;\r\n}\r\nif (j == (E1000_MDEF_PORT_623 | E1000_MDEF_PORT_664))\r\nbreak;\r\nfor (i = 0, j = 0; i < 8; i++)\r\nif (er32(MDEF(i)) == 0) {\r\new32(MDEF(i), (E1000_MDEF_PORT_623 |\r\nE1000_MDEF_PORT_664));\r\nmanc2h |= (1 << 1);\r\nj++;\r\nbreak;\r\n}\r\nif (!j)\r\ne_warn("Unable to create IPMI pass-through filter\n");\r\nbreak;\r\n}\r\new32(MANC2H, manc2h);\r\new32(MANC, manc);\r\n}\r\nstatic void e1000_configure_tx(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_ring *tx_ring = adapter->tx_ring;\r\nu64 tdba;\r\nu32 tdlen, tctl, tarc;\r\ntdba = tx_ring->dma;\r\ntdlen = tx_ring->count * sizeof(struct e1000_tx_desc);\r\new32(TDBAL(0), (tdba & DMA_BIT_MASK(32)));\r\new32(TDBAH(0), (tdba >> 32));\r\new32(TDLEN(0), tdlen);\r\new32(TDH(0), 0);\r\new32(TDT(0), 0);\r\ntx_ring->head = adapter->hw.hw_addr + E1000_TDH(0);\r\ntx_ring->tail = adapter->hw.hw_addr + E1000_TDT(0);\r\new32(TIDV, adapter->tx_int_delay);\r\new32(TADV, adapter->tx_abs_int_delay);\r\nif (adapter->flags2 & FLAG2_DMA_BURST) {\r\nu32 txdctl = er32(TXDCTL(0));\r\ntxdctl &= ~(E1000_TXDCTL_PTHRESH | E1000_TXDCTL_HTHRESH |\r\nE1000_TXDCTL_WTHRESH);\r\ntxdctl |= E1000_TXDCTL_DMA_BURST_ENABLE;\r\new32(TXDCTL(0), txdctl);\r\n}\r\new32(TXDCTL(1), er32(TXDCTL(0)));\r\ntctl = er32(TCTL);\r\ntctl &= ~E1000_TCTL_CT;\r\ntctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |\r\n(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);\r\nif (adapter->flags & FLAG_TARC_SPEED_MODE_BIT) {\r\ntarc = er32(TARC(0));\r\n#define SPEED_MODE_BIT (1 << 21)\r\ntarc |= SPEED_MODE_BIT;\r\new32(TARC(0), tarc);\r\n}\r\nif (adapter->flags & FLAG_TARC_SET_BIT_ZERO) {\r\ntarc = er32(TARC(0));\r\ntarc |= 1;\r\new32(TARC(0), tarc);\r\ntarc = er32(TARC(1));\r\ntarc |= 1;\r\new32(TARC(1), tarc);\r\n}\r\nadapter->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;\r\nif (adapter->tx_int_delay)\r\nadapter->txd_cmd |= E1000_TXD_CMD_IDE;\r\nadapter->txd_cmd |= E1000_TXD_CMD_RS;\r\new32(TCTL, tctl);\r\nhw->mac.ops.config_collision_dist(hw);\r\n}\r\nstatic void e1000_setup_rctl(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl, rfctl;\r\nu32 pages = 0;\r\nif (hw->mac.type >= e1000_pch2lan) {\r\ns32 ret_val;\r\nif (adapter->netdev->mtu > ETH_DATA_LEN)\r\nret_val = e1000_lv_jumbo_workaround_ich8lan(hw, true);\r\nelse\r\nret_val = e1000_lv_jumbo_workaround_ich8lan(hw, false);\r\nif (ret_val)\r\ne_dbg("failed to enable|disable jumbo frame workaround mode\n");\r\n}\r\nrctl = er32(RCTL);\r\nrctl &= ~(3 << E1000_RCTL_MO_SHIFT);\r\nrctl |= E1000_RCTL_EN | E1000_RCTL_BAM |\r\nE1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |\r\n(adapter->hw.mac.mc_filter_type << E1000_RCTL_MO_SHIFT);\r\nrctl &= ~E1000_RCTL_SBP;\r\nif (adapter->netdev->mtu <= ETH_DATA_LEN)\r\nrctl &= ~E1000_RCTL_LPE;\r\nelse\r\nrctl |= E1000_RCTL_LPE;\r\nif (adapter->flags2 & FLAG2_CRC_STRIPPING)\r\nrctl |= E1000_RCTL_SECRC;\r\nif ((hw->phy.type == e1000_phy_82577) && (rctl & E1000_RCTL_LPE)) {\r\nu16 phy_data;\r\ne1e_rphy(hw, PHY_REG(770, 26), &phy_data);\r\nphy_data &= 0xfff8;\r\nphy_data |= (1 << 2);\r\ne1e_wphy(hw, PHY_REG(770, 26), phy_data);\r\ne1e_rphy(hw, 22, &phy_data);\r\nphy_data &= 0x0fff;\r\nphy_data |= (1 << 14);\r\ne1e_wphy(hw, 0x10, 0x2823);\r\ne1e_wphy(hw, 0x11, 0x0003);\r\ne1e_wphy(hw, 22, phy_data);\r\n}\r\nrctl &= ~E1000_RCTL_SZ_4096;\r\nrctl |= E1000_RCTL_BSEX;\r\nswitch (adapter->rx_buffer_len) {\r\ncase 2048:\r\ndefault:\r\nrctl |= E1000_RCTL_SZ_2048;\r\nrctl &= ~E1000_RCTL_BSEX;\r\nbreak;\r\ncase 4096:\r\nrctl |= E1000_RCTL_SZ_4096;\r\nbreak;\r\ncase 8192:\r\nrctl |= E1000_RCTL_SZ_8192;\r\nbreak;\r\ncase 16384:\r\nrctl |= E1000_RCTL_SZ_16384;\r\nbreak;\r\n}\r\nrfctl = er32(RFCTL);\r\nrfctl |= E1000_RFCTL_EXTEN;\r\new32(RFCTL, rfctl);\r\npages = PAGE_USE_COUNT(adapter->netdev->mtu);\r\nif ((pages <= 3) && (PAGE_SIZE <= 16384) && (rctl & E1000_RCTL_LPE))\r\nadapter->rx_ps_pages = pages;\r\nelse\r\nadapter->rx_ps_pages = 0;\r\nif (adapter->rx_ps_pages) {\r\nu32 psrctl = 0;\r\nrctl |= E1000_RCTL_DTYP_PS;\r\npsrctl |= adapter->rx_ps_bsize0 >> E1000_PSRCTL_BSIZE0_SHIFT;\r\nswitch (adapter->rx_ps_pages) {\r\ncase 3:\r\npsrctl |= PAGE_SIZE << E1000_PSRCTL_BSIZE3_SHIFT;\r\ncase 2:\r\npsrctl |= PAGE_SIZE << E1000_PSRCTL_BSIZE2_SHIFT;\r\ncase 1:\r\npsrctl |= PAGE_SIZE >> E1000_PSRCTL_BSIZE1_SHIFT;\r\nbreak;\r\n}\r\new32(PSRCTL, psrctl);\r\n}\r\nif (adapter->netdev->features & NETIF_F_RXALL) {\r\nrctl |= (E1000_RCTL_SBP |\r\nE1000_RCTL_BAM |\r\nE1000_RCTL_PMCF);\r\nrctl &= ~(E1000_RCTL_VFE |\r\nE1000_RCTL_DPF |\r\nE1000_RCTL_CFIEN);\r\n}\r\new32(RCTL, rctl);\r\nadapter->flags &= ~FLAG_RESTART_NOW;\r\n}\r\nstatic void e1000_configure_rx(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_ring *rx_ring = adapter->rx_ring;\r\nu64 rdba;\r\nu32 rdlen, rctl, rxcsum, ctrl_ext;\r\nif (adapter->rx_ps_pages) {\r\nrdlen = rx_ring->count *\r\nsizeof(union e1000_rx_desc_packet_split);\r\nadapter->clean_rx = e1000_clean_rx_irq_ps;\r\nadapter->alloc_rx_buf = e1000_alloc_rx_buffers_ps;\r\n} else if (adapter->netdev->mtu > ETH_FRAME_LEN + ETH_FCS_LEN) {\r\nrdlen = rx_ring->count * sizeof(union e1000_rx_desc_extended);\r\nadapter->clean_rx = e1000_clean_jumbo_rx_irq;\r\nadapter->alloc_rx_buf = e1000_alloc_jumbo_rx_buffers;\r\n} else {\r\nrdlen = rx_ring->count * sizeof(union e1000_rx_desc_extended);\r\nadapter->clean_rx = e1000_clean_rx_irq;\r\nadapter->alloc_rx_buf = e1000_alloc_rx_buffers;\r\n}\r\nrctl = er32(RCTL);\r\nif (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))\r\new32(RCTL, rctl & ~E1000_RCTL_EN);\r\ne1e_flush();\r\nusleep_range(10000, 20000);\r\nif (adapter->flags2 & FLAG2_DMA_BURST) {\r\new32(RXDCTL(0), E1000_RXDCTL_DMA_BURST_ENABLE);\r\new32(RXDCTL(1), E1000_RXDCTL_DMA_BURST_ENABLE);\r\nif (adapter->rx_int_delay == DEFAULT_RDTR)\r\nadapter->rx_int_delay = BURST_RDTR;\r\nif (adapter->rx_abs_int_delay == DEFAULT_RADV)\r\nadapter->rx_abs_int_delay = BURST_RADV;\r\n}\r\new32(RDTR, adapter->rx_int_delay);\r\new32(RADV, adapter->rx_abs_int_delay);\r\nif ((adapter->itr_setting != 0) && (adapter->itr != 0))\r\ne1000e_write_itr(adapter, adapter->itr);\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_IAME;\r\new32(IAM, 0xffffffff);\r\new32(CTRL_EXT, ctrl_ext);\r\ne1e_flush();\r\nrdba = rx_ring->dma;\r\new32(RDBAL(0), (rdba & DMA_BIT_MASK(32)));\r\new32(RDBAH(0), (rdba >> 32));\r\new32(RDLEN(0), rdlen);\r\new32(RDH(0), 0);\r\new32(RDT(0), 0);\r\nrx_ring->head = adapter->hw.hw_addr + E1000_RDH(0);\r\nrx_ring->tail = adapter->hw.hw_addr + E1000_RDT(0);\r\nrxcsum = er32(RXCSUM);\r\nif (adapter->netdev->features & NETIF_F_RXCSUM)\r\nrxcsum |= E1000_RXCSUM_TUOFL;\r\nelse\r\nrxcsum &= ~E1000_RXCSUM_TUOFL;\r\new32(RXCSUM, rxcsum);\r\nif (adapter->netdev->mtu > ETH_DATA_LEN) {\r\nu32 lat =\r\n((er32(PBA) & E1000_PBA_RXA_MASK) * 1024 -\r\nadapter->max_frame_size) * 8 / 1000;\r\nif (adapter->flags & FLAG_IS_ICH) {\r\nu32 rxdctl = er32(RXDCTL(0));\r\new32(RXDCTL(0), rxdctl | 0x3);\r\n}\r\npm_qos_update_request(&adapter->netdev->pm_qos_req, lat);\r\n} else {\r\npm_qos_update_request(&adapter->netdev->pm_qos_req,\r\nPM_QOS_DEFAULT_VALUE);\r\n}\r\new32(RCTL, rctl);\r\n}\r\nstatic int e1000e_write_mc_addr_list(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct netdev_hw_addr *ha;\r\nu8 *mta_list;\r\nint i;\r\nif (netdev_mc_empty(netdev)) {\r\nhw->mac.ops.update_mc_addr_list(hw, NULL, 0);\r\nreturn 0;\r\n}\r\nmta_list = kzalloc(netdev_mc_count(netdev) * ETH_ALEN, GFP_ATOMIC);\r\nif (!mta_list)\r\nreturn -ENOMEM;\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nmemcpy(mta_list + (i++ * ETH_ALEN), ha->addr, ETH_ALEN);\r\nhw->mac.ops.update_mc_addr_list(hw, mta_list, i);\r\nkfree(mta_list);\r\nreturn netdev_mc_count(netdev);\r\n}\r\nstatic int e1000e_write_uc_addr_list(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nunsigned int rar_entries;\r\nint count = 0;\r\nrar_entries = hw->mac.ops.rar_get_count(hw);\r\nrar_entries--;\r\nif (adapter->flags & FLAG_RESET_OVERWRITES_LAA)\r\nrar_entries--;\r\nif (netdev_uc_count(netdev) > rar_entries)\r\nreturn -ENOMEM;\r\nif (!netdev_uc_empty(netdev) && rar_entries) {\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_uc_addr(ha, netdev) {\r\nint rval;\r\nif (!rar_entries)\r\nbreak;\r\nrval = hw->mac.ops.rar_set(hw, ha->addr, rar_entries--);\r\nif (rval < 0)\r\nreturn -ENOMEM;\r\ncount++;\r\n}\r\n}\r\nfor (; rar_entries > 0; rar_entries--) {\r\new32(RAH(rar_entries), 0);\r\new32(RAL(rar_entries), 0);\r\n}\r\ne1e_flush();\r\nreturn count;\r\n}\r\nstatic void e1000e_set_rx_mode(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl;\r\nif (pm_runtime_suspended(netdev->dev.parent))\r\nreturn;\r\nrctl = er32(RCTL);\r\nrctl &= ~(E1000_RCTL_UPE | E1000_RCTL_MPE);\r\nif (netdev->flags & IFF_PROMISC) {\r\nrctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);\r\ne1000e_vlan_filter_disable(adapter);\r\n} else {\r\nint count;\r\nif (netdev->flags & IFF_ALLMULTI) {\r\nrctl |= E1000_RCTL_MPE;\r\n} else {\r\ncount = e1000e_write_mc_addr_list(netdev);\r\nif (count < 0)\r\nrctl |= E1000_RCTL_MPE;\r\n}\r\ne1000e_vlan_filter_enable(adapter);\r\ncount = e1000e_write_uc_addr_list(netdev);\r\nif (count < 0)\r\nrctl |= E1000_RCTL_UPE;\r\n}\r\new32(RCTL, rctl);\r\nif (netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\r\ne1000e_vlan_strip_enable(adapter);\r\nelse\r\ne1000e_vlan_strip_disable(adapter);\r\n}\r\nstatic void e1000e_setup_rss_hash(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 mrqc, rxcsum;\r\nint i;\r\nstatic const u32 rsskey[10] = {\r\n0xda565a6d, 0xc20e5b25, 0x3d256741, 0xb08fa343, 0xcb2bcad0,\r\n0xb4307bae, 0xa32dcb77, 0x0cf23080, 0x3bb7426a, 0xfa01acbe\r\n};\r\nfor (i = 0; i < 10; i++)\r\new32(RSSRK(i), rsskey[i]);\r\nfor (i = 0; i < 32; i++)\r\new32(RETA(i), 0);\r\nrxcsum = er32(RXCSUM);\r\nrxcsum |= E1000_RXCSUM_PCSD;\r\new32(RXCSUM, rxcsum);\r\nmrqc = (E1000_MRQC_RSS_FIELD_IPV4 |\r\nE1000_MRQC_RSS_FIELD_IPV4_TCP |\r\nE1000_MRQC_RSS_FIELD_IPV6 |\r\nE1000_MRQC_RSS_FIELD_IPV6_TCP |\r\nE1000_MRQC_RSS_FIELD_IPV6_TCP_EX);\r\new32(MRQC, mrqc);\r\n}\r\ns32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 incvalue, incperiod, shift;\r\nif ((hw->mac.type == e1000_pch_lpt) &&\r\n!(er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_ENABLED) &&\r\n!(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_ENABLED)) {\r\nu32 fextnvm7 = er32(FEXTNVM7);\r\nif (!(fextnvm7 & (1 << 0))) {\r\new32(FEXTNVM7, fextnvm7 | (1 << 0));\r\ne1e_flush();\r\n}\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_pch2lan:\r\ncase e1000_pch_lpt:\r\nif ((hw->mac.type != e1000_pch_lpt) ||\r\n(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI)) {\r\nincperiod = INCPERIOD_96MHz;\r\nincvalue = INCVALUE_96MHz;\r\nshift = INCVALUE_SHIFT_96MHz;\r\nadapter->cc.shift = shift + INCPERIOD_SHIFT_96MHz;\r\nbreak;\r\n}\r\ncase e1000_82574:\r\ncase e1000_82583:\r\nincperiod = INCPERIOD_25MHz;\r\nincvalue = INCVALUE_25MHz;\r\nshift = INCVALUE_SHIFT_25MHz;\r\nadapter->cc.shift = shift;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*timinca = ((incperiod << E1000_TIMINCA_INCPERIOD_SHIFT) |\r\n((incvalue << shift) & E1000_TIMINCA_INCVALUE_MASK));\r\nreturn 0;\r\n}\r\nstatic int e1000e_config_hwtstamp(struct e1000_adapter *adapter,\r\nstruct hwtstamp_config *config)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 tsync_tx_ctl = E1000_TSYNCTXCTL_ENABLED;\r\nu32 tsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\r\nu32 rxmtrl = 0;\r\nu16 rxudp = 0;\r\nbool is_l4 = false;\r\nbool is_l2 = false;\r\nu32 regval;\r\ns32 ret_val;\r\nif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\r\nreturn -EINVAL;\r\nif (config->flags)\r\nreturn -EINVAL;\r\nswitch (config->tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\ntsync_tx_ctl = 0;\r\nbreak;\r\ncase HWTSTAMP_TX_ON:\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (config->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ntsync_rx_ctl = 0;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\r\nrxmtrl = E1000_RXMTRL_PTP_V1_SYNC_MESSAGE;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\r\nrxmtrl = E1000_RXMTRL_PTP_V1_DELAY_REQ_MESSAGE;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_V2;\r\nrxmtrl = E1000_RXMTRL_PTP_V2_SYNC_MESSAGE;\r\nis_l2 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_V2;\r\nrxmtrl = E1000_RXMTRL_PTP_V2_DELAY_REQ_MESSAGE;\r\nis_l2 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_L4_V2;\r\nrxmtrl = E1000_RXMTRL_PTP_V2_SYNC_MESSAGE;\r\nis_l2 = true;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_L4_V2;\r\nrxmtrl = E1000_RXMTRL_PTP_V2_DELAY_REQ_MESSAGE;\r\nis_l2 = true;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_EVENT_V2;\r\nconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nis_l2 = true;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_ALL:\r\nis_l2 = true;\r\nis_l4 = true;\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\r\nconfig->rx_filter = HWTSTAMP_FILTER_ALL;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nadapter->hwtstamp_config = *config;\r\nregval = er32(TSYNCTXCTL);\r\nregval &= ~E1000_TSYNCTXCTL_ENABLED;\r\nregval |= tsync_tx_ctl;\r\new32(TSYNCTXCTL, regval);\r\nif ((er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_ENABLED) !=\r\n(regval & E1000_TSYNCTXCTL_ENABLED)) {\r\ne_err("Timesync Tx Control register not set as expected\n");\r\nreturn -EAGAIN;\r\n}\r\nregval = er32(TSYNCRXCTL);\r\nregval &= ~(E1000_TSYNCRXCTL_ENABLED | E1000_TSYNCRXCTL_TYPE_MASK);\r\nregval |= tsync_rx_ctl;\r\new32(TSYNCRXCTL, regval);\r\nif ((er32(TSYNCRXCTL) & (E1000_TSYNCRXCTL_ENABLED |\r\nE1000_TSYNCRXCTL_TYPE_MASK)) !=\r\n(regval & (E1000_TSYNCRXCTL_ENABLED |\r\nE1000_TSYNCRXCTL_TYPE_MASK))) {\r\ne_err("Timesync Rx Control register not set as expected\n");\r\nreturn -EAGAIN;\r\n}\r\nif (is_l2)\r\nrxmtrl |= ETH_P_1588;\r\new32(RXMTRL, rxmtrl);\r\nif (is_l4) {\r\nrxudp = PTP_EV_PORT;\r\ncpu_to_be16s(&rxudp);\r\n}\r\new32(RXUDP, rxudp);\r\ne1e_flush();\r\ner32(RXSTMPH);\r\ner32(TXSTMPH);\r\nret_val = e1000e_get_base_timinca(adapter, &regval);\r\nif (ret_val)\r\nreturn ret_val;\r\new32(TIMINCA, regval);\r\ntimecounter_init(&adapter->tc, &adapter->cc,\r\nktime_to_ns(ktime_get_real()));\r\nreturn 0;\r\n}\r\nstatic void e1000_configure(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_ring *rx_ring = adapter->rx_ring;\r\ne1000e_set_rx_mode(adapter->netdev);\r\ne1000_restore_vlan(adapter);\r\ne1000_init_manageability_pt(adapter);\r\ne1000_configure_tx(adapter);\r\nif (adapter->netdev->features & NETIF_F_RXHASH)\r\ne1000e_setup_rss_hash(adapter);\r\ne1000_setup_rctl(adapter);\r\ne1000_configure_rx(adapter);\r\nadapter->alloc_rx_buf(rx_ring, e1000_desc_unused(rx_ring), GFP_KERNEL);\r\n}\r\nvoid e1000e_power_up_phy(struct e1000_adapter *adapter)\r\n{\r\nif (adapter->hw.phy.ops.power_up)\r\nadapter->hw.phy.ops.power_up(&adapter->hw);\r\nadapter->hw.mac.ops.setup_link(&adapter->hw);\r\n}\r\nstatic void e1000_power_down_phy(struct e1000_adapter *adapter)\r\n{\r\nif (adapter->hw.phy.ops.power_down)\r\nadapter->hw.phy.ops.power_down(&adapter->hw);\r\n}\r\nvoid e1000e_reset(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_mac_info *mac = &adapter->hw.mac;\r\nstruct e1000_fc_info *fc = &adapter->hw.fc;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 tx_space, min_tx_space, min_rx_space;\r\nu32 pba = adapter->pba;\r\nu16 hwm;\r\new32(PBA, pba);\r\nif (adapter->max_frame_size > ETH_FRAME_LEN + ETH_FCS_LEN) {\r\npba = er32(PBA);\r\ntx_space = pba >> 16;\r\npba &= 0xffff;\r\nmin_tx_space = (adapter->max_frame_size +\r\nsizeof(struct e1000_tx_desc) - ETH_FCS_LEN) * 2;\r\nmin_tx_space = ALIGN(min_tx_space, 1024);\r\nmin_tx_space >>= 10;\r\nmin_rx_space = adapter->max_frame_size;\r\nmin_rx_space = ALIGN(min_rx_space, 1024);\r\nmin_rx_space >>= 10;\r\nif ((tx_space < min_tx_space) &&\r\n((min_tx_space - tx_space) < pba)) {\r\npba -= min_tx_space - tx_space;\r\nif (pba < min_rx_space)\r\npba = min_rx_space;\r\n}\r\new32(PBA, pba);\r\n}\r\nif (adapter->flags & FLAG_DISABLE_FC_PAUSE_TIME)\r\nfc->pause_time = 0xFFFF;\r\nelse\r\nfc->pause_time = E1000_FC_PAUSE_TIME;\r\nfc->send_xon = true;\r\nfc->current_mode = fc->requested_mode;\r\nswitch (hw->mac.type) {\r\ncase e1000_ich9lan:\r\ncase e1000_ich10lan:\r\nif (adapter->netdev->mtu > ETH_DATA_LEN) {\r\npba = 14;\r\new32(PBA, pba);\r\nfc->high_water = 0x2800;\r\nfc->low_water = fc->high_water - 8;\r\nbreak;\r\n}\r\ndefault:\r\nhwm = min(((pba << 10) * 9 / 10),\r\n((pba << 10) - adapter->max_frame_size));\r\nfc->high_water = hwm & E1000_FCRTH_RTH;\r\nfc->low_water = fc->high_water - 8;\r\nbreak;\r\ncase e1000_pchlan:\r\nif (adapter->netdev->mtu > ETH_DATA_LEN) {\r\nfc->high_water = 0x3500;\r\nfc->low_water = 0x1500;\r\n} else {\r\nfc->high_water = 0x5000;\r\nfc->low_water = 0x3000;\r\n}\r\nfc->refresh_time = 0x1000;\r\nbreak;\r\ncase e1000_pch2lan:\r\ncase e1000_pch_lpt:\r\nfc->refresh_time = 0x0400;\r\nif (adapter->netdev->mtu <= ETH_DATA_LEN) {\r\nfc->high_water = 0x05C20;\r\nfc->low_water = 0x05048;\r\nfc->pause_time = 0x0650;\r\nbreak;\r\n}\r\npba = 14;\r\new32(PBA, pba);\r\nfc->high_water = ((pba << 10) * 9 / 10) & E1000_FCRTH_RTH;\r\nfc->low_water = ((pba << 10) * 8 / 10) & E1000_FCRTL_RTL;\r\nbreak;\r\n}\r\nadapter->tx_fifo_limit = min_t(u32, ((er32(PBA) >> 16) << 10) - 96,\r\n24 << 10);\r\nif (adapter->itr_setting & 0x3) {\r\nif ((adapter->max_frame_size * 2) > (pba << 10)) {\r\nif (!(adapter->flags2 & FLAG2_DISABLE_AIM)) {\r\ndev_info(&adapter->pdev->dev,\r\n"Interrupt Throttle Rate off\n");\r\nadapter->flags2 |= FLAG2_DISABLE_AIM;\r\ne1000e_write_itr(adapter, 0);\r\n}\r\n} else if (adapter->flags2 & FLAG2_DISABLE_AIM) {\r\ndev_info(&adapter->pdev->dev,\r\n"Interrupt Throttle Rate on\n");\r\nadapter->flags2 &= ~FLAG2_DISABLE_AIM;\r\nadapter->itr = 20000;\r\ne1000e_write_itr(adapter, adapter->itr);\r\n}\r\n}\r\nmac->ops.reset_hw(hw);\r\nif (adapter->flags & FLAG_HAS_AMT)\r\ne1000e_get_hw_control(adapter);\r\new32(WUC, 0);\r\nif (mac->ops.init_hw(hw))\r\ne_err("Hardware Error\n");\r\ne1000_update_mng_vlan(adapter);\r\new32(VET, ETH_P_8021Q);\r\ne1000e_reset_adaptive(hw);\r\ne1000e_config_hwtstamp(adapter, &adapter->hwtstamp_config);\r\nif (adapter->flags2 & FLAG2_HAS_EEE) {\r\ns32 ret_val;\r\nu16 adv_addr;\r\nswitch (hw->phy.type) {\r\ncase e1000_phy_82579:\r\nadv_addr = I82579_EEE_ADVERTISEMENT;\r\nbreak;\r\ncase e1000_phy_i217:\r\nadv_addr = I217_EEE_ADVERTISEMENT;\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->pdev->dev,\r\n"Invalid PHY type setting EEE advertisement\n");\r\nreturn;\r\n}\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val) {\r\ndev_err(&adapter->pdev->dev,\r\n"EEE advertisement - unable to acquire PHY\n");\r\nreturn;\r\n}\r\ne1000_write_emi_reg_locked(hw, adv_addr,\r\nhw->dev_spec.ich8lan.eee_disable ?\r\n0 : adapter->eee_advert);\r\nhw->phy.ops.release(hw);\r\n}\r\nif (!netif_running(adapter->netdev) &&\r\n!test_bit(__E1000_TESTING, &adapter->state))\r\ne1000_power_down_phy(adapter);\r\ne1000_get_phy_info(hw);\r\nif ((adapter->flags & FLAG_HAS_SMART_POWER_DOWN) &&\r\n!(adapter->flags & FLAG_SMART_POWER_DOWN)) {\r\nu16 phy_data = 0;\r\ne1e_rphy(hw, IGP02E1000_PHY_POWER_MGMT, &phy_data);\r\nphy_data &= ~IGP02E1000_PM_SPD;\r\ne1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, phy_data);\r\n}\r\n}\r\nint e1000e_up(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\ne1000_configure(adapter);\r\nclear_bit(__E1000_DOWN, &adapter->state);\r\nif (adapter->msix_entries)\r\ne1000_configure_msix(adapter);\r\ne1000_irq_enable(adapter);\r\nnetif_start_queue(adapter->netdev);\r\nif (adapter->msix_entries)\r\new32(ICS, E1000_ICS_LSC | E1000_ICR_OTHER);\r\nelse\r\new32(ICS, E1000_ICS_LSC);\r\nreturn 0;\r\n}\r\nstatic void e1000e_flush_descriptors(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (!(adapter->flags2 & FLAG2_DMA_BURST))\r\nreturn;\r\new32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\r\new32(RDTR, adapter->rx_int_delay | E1000_RDTR_FPD);\r\ne1e_flush();\r\new32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\r\new32(RDTR, adapter->rx_int_delay | E1000_RDTR_FPD);\r\ne1e_flush();\r\n}\r\nvoid e1000e_down(struct e1000_adapter *adapter, bool reset)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 tctl, rctl;\r\nset_bit(__E1000_DOWN, &adapter->state);\r\nrctl = er32(RCTL);\r\nif (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))\r\new32(RCTL, rctl & ~E1000_RCTL_EN);\r\nnetif_stop_queue(netdev);\r\ntctl = er32(TCTL);\r\ntctl &= ~E1000_TCTL_EN;\r\new32(TCTL, tctl);\r\ne1e_flush();\r\nusleep_range(10000, 20000);\r\ne1000_irq_disable(adapter);\r\nnapi_synchronize(&adapter->napi);\r\ndel_timer_sync(&adapter->watchdog_timer);\r\ndel_timer_sync(&adapter->phy_info_timer);\r\nnetif_carrier_off(netdev);\r\nspin_lock(&adapter->stats64_lock);\r\ne1000e_update_stats(adapter);\r\nspin_unlock(&adapter->stats64_lock);\r\ne1000e_flush_descriptors(adapter);\r\ne1000_clean_tx_ring(adapter->tx_ring);\r\ne1000_clean_rx_ring(adapter->rx_ring);\r\nadapter->link_speed = 0;\r\nadapter->link_duplex = 0;\r\nif ((hw->mac.type >= e1000_pch2lan) &&\r\n(adapter->netdev->mtu > ETH_DATA_LEN) &&\r\ne1000_lv_jumbo_workaround_ich8lan(hw, false))\r\ne_dbg("failed to disable jumbo frame workaround mode\n");\r\nif (reset && !pci_channel_offline(adapter->pdev))\r\ne1000e_reset(adapter);\r\n}\r\nvoid e1000e_reinit_locked(struct e1000_adapter *adapter)\r\n{\r\nmight_sleep();\r\nwhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\r\nusleep_range(1000, 2000);\r\ne1000e_down(adapter, true);\r\ne1000e_up(adapter);\r\nclear_bit(__E1000_RESETTING, &adapter->state);\r\n}\r\nstatic cycle_t e1000e_cyclecounter_read(const struct cyclecounter *cc)\r\n{\r\nstruct e1000_adapter *adapter = container_of(cc, struct e1000_adapter,\r\ncc);\r\nstruct e1000_hw *hw = &adapter->hw;\r\ncycle_t systim, systim_next;\r\nsystim = (cycle_t)er32(SYSTIML);\r\nsystim |= (cycle_t)er32(SYSTIMH) << 32;\r\nif ((hw->mac.type == e1000_82574) || (hw->mac.type == e1000_82583)) {\r\nu64 incvalue, time_delta, rem, temp;\r\nint i;\r\nincvalue = er32(TIMINCA) & E1000_TIMINCA_INCVALUE_MASK;\r\nfor (i = 0; i < E1000_MAX_82574_SYSTIM_REREADS; i++) {\r\nsystim_next = (cycle_t)er32(SYSTIML);\r\nsystim_next |= (cycle_t)er32(SYSTIMH) << 32;\r\ntime_delta = systim_next - systim;\r\ntemp = time_delta;\r\nrem = do_div(temp, incvalue);\r\nsystim = systim_next;\r\nif ((time_delta < E1000_82574_SYSTIM_EPSILON) &&\r\n(rem == 0))\r\nbreak;\r\n}\r\n}\r\nreturn systim;\r\n}\r\nstatic int e1000_sw_init(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nadapter->rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN;\r\nadapter->rx_ps_bsize0 = 128;\r\nadapter->max_frame_size = netdev->mtu + ETH_HLEN + ETH_FCS_LEN;\r\nadapter->min_frame_size = ETH_ZLEN + ETH_FCS_LEN;\r\nadapter->tx_ring_count = E1000_DEFAULT_TXD;\r\nadapter->rx_ring_count = E1000_DEFAULT_RXD;\r\nspin_lock_init(&adapter->stats64_lock);\r\ne1000e_set_interrupt_capability(adapter);\r\nif (e1000_alloc_queues(adapter))\r\nreturn -ENOMEM;\r\nif (adapter->flags & FLAG_HAS_HW_TIMESTAMP) {\r\nadapter->cc.read = e1000e_cyclecounter_read;\r\nadapter->cc.mask = CLOCKSOURCE_MASK(64);\r\nadapter->cc.mult = 1;\r\nspin_lock_init(&adapter->systim_lock);\r\nINIT_WORK(&adapter->tx_hwtstamp_work, e1000e_tx_hwtstamp_work);\r\n}\r\ne1000_irq_disable(adapter);\r\nset_bit(__E1000_DOWN, &adapter->state);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t e1000_intr_msi_test(int __always_unused irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 icr = er32(ICR);\r\ne_dbg("icr is %08X\n", icr);\r\nif (icr & E1000_ICR_RXSEQ) {\r\nadapter->flags &= ~FLAG_MSI_TEST_FAILED;\r\nwmb();\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int e1000_test_msi_interrupt(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nint err;\r\ner32(ICR);\r\ne1000_free_irq(adapter);\r\ne1000e_reset_interrupt_capability(adapter);\r\nadapter->flags |= FLAG_MSI_TEST_FAILED;\r\nerr = pci_enable_msi(adapter->pdev);\r\nif (err)\r\ngoto msi_test_failed;\r\nerr = request_irq(adapter->pdev->irq, e1000_intr_msi_test, 0,\r\nnetdev->name, netdev);\r\nif (err) {\r\npci_disable_msi(adapter->pdev);\r\ngoto msi_test_failed;\r\n}\r\nwmb();\r\ne1000_irq_enable(adapter);\r\new32(ICS, E1000_ICS_RXSEQ);\r\ne1e_flush();\r\nmsleep(100);\r\ne1000_irq_disable(adapter);\r\nrmb();\r\nif (adapter->flags & FLAG_MSI_TEST_FAILED) {\r\nadapter->int_mode = E1000E_INT_MODE_LEGACY;\r\ne_info("MSI interrupt test failed, using legacy interrupt.\n");\r\n} else {\r\ne_dbg("MSI interrupt test succeeded!\n");\r\n}\r\nfree_irq(adapter->pdev->irq, netdev);\r\npci_disable_msi(adapter->pdev);\r\nmsi_test_failed:\r\ne1000e_set_interrupt_capability(adapter);\r\nreturn e1000_request_irq(adapter);\r\n}\r\nstatic int e1000_test_msi(struct e1000_adapter *adapter)\r\n{\r\nint err;\r\nu16 pci_cmd;\r\nif (!(adapter->flags & FLAG_MSI_ENABLED))\r\nreturn 0;\r\npci_read_config_word(adapter->pdev, PCI_COMMAND, &pci_cmd);\r\nif (pci_cmd & PCI_COMMAND_SERR)\r\npci_write_config_word(adapter->pdev, PCI_COMMAND,\r\npci_cmd & ~PCI_COMMAND_SERR);\r\nerr = e1000_test_msi_interrupt(adapter);\r\nif (pci_cmd & PCI_COMMAND_SERR) {\r\npci_read_config_word(adapter->pdev, PCI_COMMAND, &pci_cmd);\r\npci_cmd |= PCI_COMMAND_SERR;\r\npci_write_config_word(adapter->pdev, PCI_COMMAND, pci_cmd);\r\n}\r\nreturn err;\r\n}\r\nstatic int e1000_open(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint err;\r\nif (test_bit(__E1000_TESTING, &adapter->state))\r\nreturn -EBUSY;\r\npm_runtime_get_sync(&pdev->dev);\r\nnetif_carrier_off(netdev);\r\nerr = e1000e_setup_tx_resources(adapter->tx_ring);\r\nif (err)\r\ngoto err_setup_tx;\r\nerr = e1000e_setup_rx_resources(adapter->rx_ring);\r\nif (err)\r\ngoto err_setup_rx;\r\nif (adapter->flags & FLAG_HAS_AMT) {\r\ne1000e_get_hw_control(adapter);\r\ne1000e_reset(adapter);\r\n}\r\ne1000e_power_up_phy(adapter);\r\nadapter->mng_vlan_id = E1000_MNG_VLAN_NONE;\r\nif ((adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN))\r\ne1000_update_mng_vlan(adapter);\r\npm_qos_add_request(&adapter->netdev->pm_qos_req, PM_QOS_CPU_DMA_LATENCY,\r\nPM_QOS_DEFAULT_VALUE);\r\ne1000_configure(adapter);\r\nerr = e1000_request_irq(adapter);\r\nif (err)\r\ngoto err_req_irq;\r\nif (adapter->int_mode != E1000E_INT_MODE_LEGACY) {\r\nerr = e1000_test_msi(adapter);\r\nif (err) {\r\ne_err("Interrupt allocation failed\n");\r\ngoto err_req_irq;\r\n}\r\n}\r\nclear_bit(__E1000_DOWN, &adapter->state);\r\nnapi_enable(&adapter->napi);\r\ne1000_irq_enable(adapter);\r\nadapter->tx_hang_recheck = false;\r\nnetif_start_queue(netdev);\r\nhw->mac.get_link_status = true;\r\npm_runtime_put(&pdev->dev);\r\nif (adapter->msix_entries)\r\new32(ICS, E1000_ICS_LSC | E1000_ICR_OTHER);\r\nelse\r\new32(ICS, E1000_ICS_LSC);\r\nreturn 0;\r\nerr_req_irq:\r\ne1000e_release_hw_control(adapter);\r\ne1000_power_down_phy(adapter);\r\ne1000e_free_rx_resources(adapter->rx_ring);\r\nerr_setup_rx:\r\ne1000e_free_tx_resources(adapter->tx_ring);\r\nerr_setup_tx:\r\ne1000e_reset(adapter);\r\npm_runtime_put_sync(&pdev->dev);\r\nreturn err;\r\n}\r\nstatic int e1000_close(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct pci_dev *pdev = adapter->pdev;\r\nint count = E1000_CHECK_RESET_COUNT;\r\nwhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\r\nusleep_range(10000, 20000);\r\nWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\r\npm_runtime_get_sync(&pdev->dev);\r\nif (!test_bit(__E1000_DOWN, &adapter->state)) {\r\ne1000e_down(adapter, true);\r\ne1000_free_irq(adapter);\r\npr_info("%s NIC Link is Down\n", adapter->netdev->name);\r\n}\r\nnapi_disable(&adapter->napi);\r\ne1000e_free_tx_resources(adapter->tx_ring);\r\ne1000e_free_rx_resources(adapter->rx_ring);\r\nif (adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN)\r\ne1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),\r\nadapter->mng_vlan_id);\r\nif ((adapter->flags & FLAG_HAS_AMT) &&\r\n!test_bit(__E1000_TESTING, &adapter->state))\r\ne1000e_release_hw_control(adapter);\r\npm_qos_remove_request(&adapter->netdev->pm_qos_req);\r\npm_runtime_put_sync(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int e1000_set_mac(struct net_device *netdev, void *p)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\r\nmemcpy(adapter->hw.mac.addr, addr->sa_data, netdev->addr_len);\r\nhw->mac.ops.rar_set(&adapter->hw, adapter->hw.mac.addr, 0);\r\nif (adapter->flags & FLAG_RESET_OVERWRITES_LAA) {\r\ne1000e_set_laa_state_82571(&adapter->hw, 1);\r\nhw->mac.ops.rar_set(&adapter->hw, adapter->hw.mac.addr,\r\nadapter->hw.mac.rar_entry_count - 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void e1000e_update_phy_task(struct work_struct *work)\r\n{\r\nstruct e1000_adapter *adapter = container_of(work,\r\nstruct e1000_adapter,\r\nupdate_phy_task);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (test_bit(__E1000_DOWN, &adapter->state))\r\nreturn;\r\ne1000_get_phy_info(hw);\r\nif (hw->phy.type >= e1000_phy_82579)\r\ne1000_set_eee_pchlan(hw);\r\n}\r\nstatic void e1000_update_phy_info(unsigned long data)\r\n{\r\nstruct e1000_adapter *adapter = (struct e1000_adapter *)data;\r\nif (test_bit(__E1000_DOWN, &adapter->state))\r\nreturn;\r\nschedule_work(&adapter->update_phy_task);\r\n}\r\nstatic void e1000e_update_phy_stats(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\ns32 ret_val;\r\nu16 phy_data;\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\nreturn;\r\nhw->phy.addr = 1;\r\nret_val = e1000e_read_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT,\r\n&phy_data);\r\nif (ret_val)\r\ngoto release;\r\nif (phy_data != (HV_STATS_PAGE << IGP_PAGE_SHIFT)) {\r\nret_val = hw->phy.ops.set_page(hw,\r\nHV_STATS_PAGE << IGP_PAGE_SHIFT);\r\nif (ret_val)\r\ngoto release;\r\n}\r\nhw->phy.ops.read_reg_page(hw, HV_SCC_UPPER, &phy_data);\r\nret_val = hw->phy.ops.read_reg_page(hw, HV_SCC_LOWER, &phy_data);\r\nif (!ret_val)\r\nadapter->stats.scc += phy_data;\r\nhw->phy.ops.read_reg_page(hw, HV_ECOL_UPPER, &phy_data);\r\nret_val = hw->phy.ops.read_reg_page(hw, HV_ECOL_LOWER, &phy_data);\r\nif (!ret_val)\r\nadapter->stats.ecol += phy_data;\r\nhw->phy.ops.read_reg_page(hw, HV_MCC_UPPER, &phy_data);\r\nret_val = hw->phy.ops.read_reg_page(hw, HV_MCC_LOWER, &phy_data);\r\nif (!ret_val)\r\nadapter->stats.mcc += phy_data;\r\nhw->phy.ops.read_reg_page(hw, HV_LATECOL_UPPER, &phy_data);\r\nret_val = hw->phy.ops.read_reg_page(hw, HV_LATECOL_LOWER, &phy_data);\r\nif (!ret_val)\r\nadapter->stats.latecol += phy_data;\r\nhw->phy.ops.read_reg_page(hw, HV_COLC_UPPER, &phy_data);\r\nret_val = hw->phy.ops.read_reg_page(hw, HV_COLC_LOWER, &phy_data);\r\nif (!ret_val)\r\nhw->mac.collision_delta = phy_data;\r\nhw->phy.ops.read_reg_page(hw, HV_DC_UPPER, &phy_data);\r\nret_val = hw->phy.ops.read_reg_page(hw, HV_DC_LOWER, &phy_data);\r\nif (!ret_val)\r\nadapter->stats.dc += phy_data;\r\nhw->phy.ops.read_reg_page(hw, HV_TNCRS_UPPER, &phy_data);\r\nret_val = hw->phy.ops.read_reg_page(hw, HV_TNCRS_LOWER, &phy_data);\r\nif (!ret_val)\r\nadapter->stats.tncrs += phy_data;\r\nrelease:\r\nhw->phy.ops.release(hw);\r\n}\r\nstatic void e1000e_update_stats(struct e1000_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nif (adapter->link_speed == 0)\r\nreturn;\r\nif (pci_channel_offline(pdev))\r\nreturn;\r\nadapter->stats.crcerrs += er32(CRCERRS);\r\nadapter->stats.gprc += er32(GPRC);\r\nadapter->stats.gorc += er32(GORCL);\r\ner32(GORCH);\r\nadapter->stats.bprc += er32(BPRC);\r\nadapter->stats.mprc += er32(MPRC);\r\nadapter->stats.roc += er32(ROC);\r\nadapter->stats.mpc += er32(MPC);\r\nif (adapter->link_duplex == HALF_DUPLEX) {\r\nif (adapter->flags2 & FLAG2_HAS_PHY_STATS) {\r\ne1000e_update_phy_stats(adapter);\r\n} else {\r\nadapter->stats.scc += er32(SCC);\r\nadapter->stats.ecol += er32(ECOL);\r\nadapter->stats.mcc += er32(MCC);\r\nadapter->stats.latecol += er32(LATECOL);\r\nadapter->stats.dc += er32(DC);\r\nhw->mac.collision_delta = er32(COLC);\r\nif ((hw->mac.type != e1000_82574) &&\r\n(hw->mac.type != e1000_82583))\r\nadapter->stats.tncrs += er32(TNCRS);\r\n}\r\nadapter->stats.colc += hw->mac.collision_delta;\r\n}\r\nadapter->stats.xonrxc += er32(XONRXC);\r\nadapter->stats.xontxc += er32(XONTXC);\r\nadapter->stats.xoffrxc += er32(XOFFRXC);\r\nadapter->stats.xofftxc += er32(XOFFTXC);\r\nadapter->stats.gptc += er32(GPTC);\r\nadapter->stats.gotc += er32(GOTCL);\r\ner32(GOTCH);\r\nadapter->stats.rnbc += er32(RNBC);\r\nadapter->stats.ruc += er32(RUC);\r\nadapter->stats.mptc += er32(MPTC);\r\nadapter->stats.bptc += er32(BPTC);\r\nhw->mac.tx_packet_delta = er32(TPT);\r\nadapter->stats.tpt += hw->mac.tx_packet_delta;\r\nadapter->stats.algnerrc += er32(ALGNERRC);\r\nadapter->stats.rxerrc += er32(RXERRC);\r\nadapter->stats.cexterr += er32(CEXTERR);\r\nadapter->stats.tsctc += er32(TSCTC);\r\nadapter->stats.tsctfc += er32(TSCTFC);\r\nnetdev->stats.multicast = adapter->stats.mprc;\r\nnetdev->stats.collisions = adapter->stats.colc;\r\nnetdev->stats.rx_errors = adapter->stats.rxerrc +\r\nadapter->stats.crcerrs + adapter->stats.algnerrc +\r\nadapter->stats.ruc + adapter->stats.roc + adapter->stats.cexterr;\r\nnetdev->stats.rx_length_errors = adapter->stats.ruc +\r\nadapter->stats.roc;\r\nnetdev->stats.rx_crc_errors = adapter->stats.crcerrs;\r\nnetdev->stats.rx_frame_errors = adapter->stats.algnerrc;\r\nnetdev->stats.rx_missed_errors = adapter->stats.mpc;\r\nnetdev->stats.tx_errors = adapter->stats.ecol + adapter->stats.latecol;\r\nnetdev->stats.tx_aborted_errors = adapter->stats.ecol;\r\nnetdev->stats.tx_window_errors = adapter->stats.latecol;\r\nnetdev->stats.tx_carrier_errors = adapter->stats.tncrs;\r\nadapter->stats.mgptc += er32(MGTPTC);\r\nadapter->stats.mgprc += er32(MGTPRC);\r\nadapter->stats.mgpdc += er32(MGTPDC);\r\nif (hw->mac.type == e1000_pch_lpt) {\r\nu32 pbeccsts = er32(PBECCSTS);\r\nadapter->corr_errors +=\r\npbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\r\nadapter->uncorr_errors +=\r\n(pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\r\nE1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\r\n}\r\n}\r\nstatic void e1000_phy_read_status(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_phy_regs *phy = &adapter->phy_regs;\r\nif (!pm_runtime_suspended((&adapter->pdev->dev)->parent) &&\r\n(er32(STATUS) & E1000_STATUS_LU) &&\r\n(adapter->hw.phy.media_type == e1000_media_type_copper)) {\r\nint ret_val;\r\nret_val = e1e_rphy(hw, MII_BMCR, &phy->bmcr);\r\nret_val |= e1e_rphy(hw, MII_BMSR, &phy->bmsr);\r\nret_val |= e1e_rphy(hw, MII_ADVERTISE, &phy->advertise);\r\nret_val |= e1e_rphy(hw, MII_LPA, &phy->lpa);\r\nret_val |= e1e_rphy(hw, MII_EXPANSION, &phy->expansion);\r\nret_val |= e1e_rphy(hw, MII_CTRL1000, &phy->ctrl1000);\r\nret_val |= e1e_rphy(hw, MII_STAT1000, &phy->stat1000);\r\nret_val |= e1e_rphy(hw, MII_ESTATUS, &phy->estatus);\r\nif (ret_val)\r\ne_warn("Error reading PHY register\n");\r\n} else {\r\nphy->bmcr = (BMCR_SPEED1000 | BMCR_ANENABLE | BMCR_FULLDPLX);\r\nphy->bmsr = (BMSR_100FULL | BMSR_100HALF | BMSR_10FULL |\r\nBMSR_10HALF | BMSR_ESTATEN | BMSR_ANEGCAPABLE |\r\nBMSR_ERCAP);\r\nphy->advertise = (ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP |\r\nADVERTISE_ALL | ADVERTISE_CSMA);\r\nphy->lpa = 0;\r\nphy->expansion = EXPANSION_ENABLENPAGE;\r\nphy->ctrl1000 = ADVERTISE_1000FULL;\r\nphy->stat1000 = 0;\r\nphy->estatus = (ESTATUS_1000_TFULL | ESTATUS_1000_THALF);\r\n}\r\n}\r\nstatic void e1000_print_link_info(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl = er32(CTRL);\r\npr_info("%s NIC Link is Up %d Mbps %s Duplex, Flow Control: %s\n",\r\nadapter->netdev->name, adapter->link_speed,\r\nadapter->link_duplex == FULL_DUPLEX ? "Full" : "Half",\r\n(ctrl & E1000_CTRL_TFCE) && (ctrl & E1000_CTRL_RFCE) ? "Rx/Tx" :\r\n(ctrl & E1000_CTRL_RFCE) ? "Rx" :\r\n(ctrl & E1000_CTRL_TFCE) ? "Tx" : "None");\r\n}\r\nstatic bool e1000e_has_link(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nbool link_active = false;\r\ns32 ret_val = 0;\r\nswitch (hw->phy.media_type) {\r\ncase e1000_media_type_copper:\r\nif (hw->mac.get_link_status) {\r\nret_val = hw->mac.ops.check_for_link(hw);\r\nlink_active = !hw->mac.get_link_status;\r\n} else {\r\nlink_active = true;\r\n}\r\nbreak;\r\ncase e1000_media_type_fiber:\r\nret_val = hw->mac.ops.check_for_link(hw);\r\nlink_active = !!(er32(STATUS) & E1000_STATUS_LU);\r\nbreak;\r\ncase e1000_media_type_internal_serdes:\r\nret_val = hw->mac.ops.check_for_link(hw);\r\nlink_active = adapter->hw.mac.serdes_has_link;\r\nbreak;\r\ndefault:\r\ncase e1000_media_type_unknown:\r\nbreak;\r\n}\r\nif ((ret_val == E1000_ERR_PHY) && (hw->phy.type == e1000_phy_igp_3) &&\r\n(er32(CTRL) & E1000_PHY_CTRL_GBE_DISABLE)) {\r\ne_info("Gigabit has been disabled, downgrading speed\n");\r\n}\r\nreturn link_active;\r\n}\r\nstatic void e1000e_enable_receives(struct e1000_adapter *adapter)\r\n{\r\nif ((adapter->flags & FLAG_RX_NEEDS_RESTART) &&\r\n(adapter->flags & FLAG_RESTART_NOW)) {\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl = er32(RCTL);\r\new32(RCTL, rctl | E1000_RCTL_EN);\r\nadapter->flags &= ~FLAG_RESTART_NOW;\r\n}\r\n}\r\nstatic void e1000e_check_82574_phy_workaround(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (e1000_check_phy_82574(hw))\r\nadapter->phy_hang_count++;\r\nelse\r\nadapter->phy_hang_count = 0;\r\nif (adapter->phy_hang_count > 1) {\r\nadapter->phy_hang_count = 0;\r\ne_dbg("PHY appears hung - resetting\n");\r\nschedule_work(&adapter->reset_task);\r\n}\r\n}\r\nstatic void e1000_watchdog(unsigned long data)\r\n{\r\nstruct e1000_adapter *adapter = (struct e1000_adapter *)data;\r\nschedule_work(&adapter->watchdog_task);\r\n}\r\nstatic void e1000_watchdog_task(struct work_struct *work)\r\n{\r\nstruct e1000_adapter *adapter = container_of(work,\r\nstruct e1000_adapter,\r\nwatchdog_task);\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct e1000_mac_info *mac = &adapter->hw.mac;\r\nstruct e1000_phy_info *phy = &adapter->hw.phy;\r\nstruct e1000_ring *tx_ring = adapter->tx_ring;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 link, tctl;\r\nif (test_bit(__E1000_DOWN, &adapter->state))\r\nreturn;\r\nlink = e1000e_has_link(adapter);\r\nif ((netif_carrier_ok(netdev)) && link) {\r\npm_runtime_resume(netdev->dev.parent);\r\ne1000e_enable_receives(adapter);\r\ngoto link_up;\r\n}\r\nif ((e1000e_enable_tx_pkt_filtering(hw)) &&\r\n(adapter->mng_vlan_id != adapter->hw.mng_cookie.vlan_id))\r\ne1000_update_mng_vlan(adapter);\r\nif (link) {\r\nif (!netif_carrier_ok(netdev)) {\r\nbool txb2b = true;\r\npm_runtime_resume(netdev->dev.parent);\r\ne1000_phy_read_status(adapter);\r\nmac->ops.get_link_up_info(&adapter->hw,\r\n&adapter->link_speed,\r\n&adapter->link_duplex);\r\ne1000_print_link_info(adapter);\r\ne1000e_check_downshift(hw);\r\nif (phy->speed_downgraded)\r\nnetdev_warn(netdev,\r\n"Link Speed was downgraded by SmartSpeed\n");\r\nif ((hw->phy.type == e1000_phy_igp_3 ||\r\nhw->phy.type == e1000_phy_bm) &&\r\nhw->mac.autoneg &&\r\n(adapter->link_speed == SPEED_10 ||\r\nadapter->link_speed == SPEED_100) &&\r\n(adapter->link_duplex == HALF_DUPLEX)) {\r\nu16 autoneg_exp;\r\ne1e_rphy(hw, MII_EXPANSION, &autoneg_exp);\r\nif (!(autoneg_exp & EXPANSION_NWAY))\r\ne_info("Autonegotiated half duplex but link partner cannot autoneg. Try forcing full duplex if link gets many collisions.\n");\r\n}\r\nadapter->tx_timeout_factor = 1;\r\nswitch (adapter->link_speed) {\r\ncase SPEED_10:\r\ntxb2b = false;\r\nadapter->tx_timeout_factor = 16;\r\nbreak;\r\ncase SPEED_100:\r\ntxb2b = false;\r\nadapter->tx_timeout_factor = 10;\r\nbreak;\r\n}\r\nif ((adapter->flags & FLAG_TARC_SPEED_MODE_BIT) &&\r\n!txb2b) {\r\nu32 tarc0;\r\ntarc0 = er32(TARC(0));\r\ntarc0 &= ~SPEED_MODE_BIT;\r\new32(TARC(0), tarc0);\r\n}\r\nif (!(adapter->flags & FLAG_TSO_FORCE)) {\r\nswitch (adapter->link_speed) {\r\ncase SPEED_10:\r\ncase SPEED_100:\r\ne_info("10/100 speed: disabling TSO\n");\r\nnetdev->features &= ~NETIF_F_TSO;\r\nnetdev->features &= ~NETIF_F_TSO6;\r\nbreak;\r\ncase SPEED_1000:\r\nnetdev->features |= NETIF_F_TSO;\r\nnetdev->features |= NETIF_F_TSO6;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ntctl = er32(TCTL);\r\ntctl |= E1000_TCTL_EN;\r\new32(TCTL, tctl);\r\nif (phy->ops.cfg_on_link_up)\r\nphy->ops.cfg_on_link_up(hw);\r\nnetif_carrier_on(netdev);\r\nif (!test_bit(__E1000_DOWN, &adapter->state))\r\nmod_timer(&adapter->phy_info_timer,\r\nround_jiffies(jiffies + 2 * HZ));\r\n}\r\n} else {\r\nif (netif_carrier_ok(netdev)) {\r\nadapter->link_speed = 0;\r\nadapter->link_duplex = 0;\r\npr_info("%s NIC Link is Down\n", adapter->netdev->name);\r\nnetif_carrier_off(netdev);\r\nif (!test_bit(__E1000_DOWN, &adapter->state))\r\nmod_timer(&adapter->phy_info_timer,\r\nround_jiffies(jiffies + 2 * HZ));\r\nif (adapter->flags & FLAG_RX_NEEDS_RESTART)\r\nadapter->flags |= FLAG_RESTART_NOW;\r\nelse\r\npm_schedule_suspend(netdev->dev.parent,\r\nLINK_TIMEOUT);\r\n}\r\n}\r\nlink_up:\r\nspin_lock(&adapter->stats64_lock);\r\ne1000e_update_stats(adapter);\r\nmac->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;\r\nadapter->tpt_old = adapter->stats.tpt;\r\nmac->collision_delta = adapter->stats.colc - adapter->colc_old;\r\nadapter->colc_old = adapter->stats.colc;\r\nadapter->gorc = adapter->stats.gorc - adapter->gorc_old;\r\nadapter->gorc_old = adapter->stats.gorc;\r\nadapter->gotc = adapter->stats.gotc - adapter->gotc_old;\r\nadapter->gotc_old = adapter->stats.gotc;\r\nspin_unlock(&adapter->stats64_lock);\r\nif (!netif_carrier_ok(netdev) &&\r\n(e1000_desc_unused(tx_ring) + 1 < tx_ring->count))\r\nadapter->flags |= FLAG_RESTART_NOW;\r\nif (adapter->flags & FLAG_RESTART_NOW) {\r\nschedule_work(&adapter->reset_task);\r\nreturn;\r\n}\r\ne1000e_update_adaptive(&adapter->hw);\r\nif (adapter->itr_setting == 4) {\r\nu32 goc = (adapter->gotc + adapter->gorc) / 10000;\r\nu32 dif = (adapter->gotc > adapter->gorc ?\r\nadapter->gotc - adapter->gorc :\r\nadapter->gorc - adapter->gotc) / 10000;\r\nu32 itr = goc > 0 ? (dif * 6000 / goc + 2000) : 8000;\r\ne1000e_write_itr(adapter, itr);\r\n}\r\nif (adapter->msix_entries)\r\new32(ICS, adapter->rx_ring->ims_val);\r\nelse\r\new32(ICS, E1000_ICS_RXDMT0);\r\ne1000e_flush_descriptors(adapter);\r\nadapter->detect_tx_hung = true;\r\nif (e1000e_get_laa_state_82571(hw))\r\nhw->mac.ops.rar_set(hw, adapter->hw.mac.addr, 0);\r\nif (adapter->flags2 & FLAG2_CHECK_PHY_HANG)\r\ne1000e_check_82574_phy_workaround(adapter);\r\nif (adapter->hwtstamp_config.rx_filter != HWTSTAMP_FILTER_NONE) {\r\nif ((adapter->flags2 & FLAG2_CHECK_RX_HWTSTAMP) &&\r\n(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID)) {\r\ner32(RXSTMPH);\r\nadapter->rx_hwtstamp_cleared++;\r\n} else {\r\nadapter->flags2 |= FLAG2_CHECK_RX_HWTSTAMP;\r\n}\r\n}\r\nif (!test_bit(__E1000_DOWN, &adapter->state))\r\nmod_timer(&adapter->watchdog_timer,\r\nround_jiffies(jiffies + 2 * HZ));\r\n}\r\nstatic int e1000_tso(struct e1000_ring *tx_ring, struct sk_buff *skb,\r\n__be16 protocol)\r\n{\r\nstruct e1000_context_desc *context_desc;\r\nstruct e1000_buffer *buffer_info;\r\nunsigned int i;\r\nu32 cmd_length = 0;\r\nu16 ipcse = 0, mss;\r\nu8 ipcss, ipcso, tucss, tucso, hdr_len;\r\nint err;\r\nif (!skb_is_gso(skb))\r\nreturn 0;\r\nerr = skb_cow_head(skb, 0);\r\nif (err < 0)\r\nreturn err;\r\nhdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\r\nmss = skb_shinfo(skb)->gso_size;\r\nif (protocol == htons(ETH_P_IP)) {\r\nstruct iphdr *iph = ip_hdr(skb);\r\niph->tot_len = 0;\r\niph->check = 0;\r\ntcp_hdr(skb)->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\r\n0, IPPROTO_TCP, 0);\r\ncmd_length = E1000_TXD_CMD_IP;\r\nipcse = skb_transport_offset(skb) - 1;\r\n} else if (skb_is_gso_v6(skb)) {\r\nipv6_hdr(skb)->payload_len = 0;\r\ntcp_hdr(skb)->check = ~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\r\n&ipv6_hdr(skb)->daddr,\r\n0, IPPROTO_TCP, 0);\r\nipcse = 0;\r\n}\r\nipcss = skb_network_offset(skb);\r\nipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;\r\ntucss = skb_transport_offset(skb);\r\ntucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;\r\ncmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |\r\nE1000_TXD_CMD_TCP | (skb->len - (hdr_len)));\r\ni = tx_ring->next_to_use;\r\ncontext_desc = E1000_CONTEXT_DESC(*tx_ring, i);\r\nbuffer_info = &tx_ring->buffer_info[i];\r\ncontext_desc->lower_setup.ip_fields.ipcss = ipcss;\r\ncontext_desc->lower_setup.ip_fields.ipcso = ipcso;\r\ncontext_desc->lower_setup.ip_fields.ipcse = cpu_to_le16(ipcse);\r\ncontext_desc->upper_setup.tcp_fields.tucss = tucss;\r\ncontext_desc->upper_setup.tcp_fields.tucso = tucso;\r\ncontext_desc->upper_setup.tcp_fields.tucse = 0;\r\ncontext_desc->tcp_seg_setup.fields.mss = cpu_to_le16(mss);\r\ncontext_desc->tcp_seg_setup.fields.hdr_len = hdr_len;\r\ncontext_desc->cmd_and_length = cpu_to_le32(cmd_length);\r\nbuffer_info->time_stamp = jiffies;\r\nbuffer_info->next_to_watch = i;\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\ntx_ring->next_to_use = i;\r\nreturn 1;\r\n}\r\nstatic bool e1000_tx_csum(struct e1000_ring *tx_ring, struct sk_buff *skb,\r\n__be16 protocol)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nstruct e1000_context_desc *context_desc;\r\nstruct e1000_buffer *buffer_info;\r\nunsigned int i;\r\nu8 css;\r\nu32 cmd_len = E1000_TXD_CMD_DEXT;\r\nif (skb->ip_summed != CHECKSUM_PARTIAL)\r\nreturn false;\r\nswitch (protocol) {\r\ncase cpu_to_be16(ETH_P_IP):\r\nif (ip_hdr(skb)->protocol == IPPROTO_TCP)\r\ncmd_len |= E1000_TXD_CMD_TCP;\r\nbreak;\r\ncase cpu_to_be16(ETH_P_IPV6):\r\nif (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)\r\ncmd_len |= E1000_TXD_CMD_TCP;\r\nbreak;\r\ndefault:\r\nif (unlikely(net_ratelimit()))\r\ne_warn("checksum_partial proto=%x!\n",\r\nbe16_to_cpu(protocol));\r\nbreak;\r\n}\r\ncss = skb_checksum_start_offset(skb);\r\ni = tx_ring->next_to_use;\r\nbuffer_info = &tx_ring->buffer_info[i];\r\ncontext_desc = E1000_CONTEXT_DESC(*tx_ring, i);\r\ncontext_desc->lower_setup.ip_config = 0;\r\ncontext_desc->upper_setup.tcp_fields.tucss = css;\r\ncontext_desc->upper_setup.tcp_fields.tucso = css + skb->csum_offset;\r\ncontext_desc->upper_setup.tcp_fields.tucse = 0;\r\ncontext_desc->tcp_seg_setup.data = 0;\r\ncontext_desc->cmd_and_length = cpu_to_le32(cmd_len);\r\nbuffer_info->time_stamp = jiffies;\r\nbuffer_info->next_to_watch = i;\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\ntx_ring->next_to_use = i;\r\nreturn true;\r\n}\r\nstatic int e1000_tx_map(struct e1000_ring *tx_ring, struct sk_buff *skb,\r\nunsigned int first, unsigned int max_per_txd,\r\nunsigned int nr_frags)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct e1000_buffer *buffer_info;\r\nunsigned int len = skb_headlen(skb);\r\nunsigned int offset = 0, size, count = 0, i;\r\nunsigned int f, bytecount, segs;\r\ni = tx_ring->next_to_use;\r\nwhile (len) {\r\nbuffer_info = &tx_ring->buffer_info[i];\r\nsize = min(len, max_per_txd);\r\nbuffer_info->length = size;\r\nbuffer_info->time_stamp = jiffies;\r\nbuffer_info->next_to_watch = i;\r\nbuffer_info->dma = dma_map_single(&pdev->dev,\r\nskb->data + offset,\r\nsize, DMA_TO_DEVICE);\r\nbuffer_info->mapped_as_page = false;\r\nif (dma_mapping_error(&pdev->dev, buffer_info->dma))\r\ngoto dma_error;\r\nlen -= size;\r\noffset += size;\r\ncount++;\r\nif (len) {\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\n}\r\n}\r\nfor (f = 0; f < nr_frags; f++) {\r\nconst struct skb_frag_struct *frag;\r\nfrag = &skb_shinfo(skb)->frags[f];\r\nlen = skb_frag_size(frag);\r\noffset = 0;\r\nwhile (len) {\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\nbuffer_info = &tx_ring->buffer_info[i];\r\nsize = min(len, max_per_txd);\r\nbuffer_info->length = size;\r\nbuffer_info->time_stamp = jiffies;\r\nbuffer_info->next_to_watch = i;\r\nbuffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,\r\noffset, size,\r\nDMA_TO_DEVICE);\r\nbuffer_info->mapped_as_page = true;\r\nif (dma_mapping_error(&pdev->dev, buffer_info->dma))\r\ngoto dma_error;\r\nlen -= size;\r\noffset += size;\r\ncount++;\r\n}\r\n}\r\nsegs = skb_shinfo(skb)->gso_segs ? : 1;\r\nbytecount = ((segs - 1) * skb_headlen(skb)) + skb->len;\r\ntx_ring->buffer_info[i].skb = skb;\r\ntx_ring->buffer_info[i].segs = segs;\r\ntx_ring->buffer_info[i].bytecount = bytecount;\r\ntx_ring->buffer_info[first].next_to_watch = i;\r\nreturn count;\r\ndma_error:\r\ndev_err(&pdev->dev, "Tx DMA map failed\n");\r\nbuffer_info->dma = 0;\r\nif (count)\r\ncount--;\r\nwhile (count--) {\r\nif (i == 0)\r\ni += tx_ring->count;\r\ni--;\r\nbuffer_info = &tx_ring->buffer_info[i];\r\ne1000_put_txbuf(tx_ring, buffer_info);\r\n}\r\nreturn 0;\r\n}\r\nstatic void e1000_tx_queue(struct e1000_ring *tx_ring, int tx_flags, int count)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nstruct e1000_tx_desc *tx_desc = NULL;\r\nstruct e1000_buffer *buffer_info;\r\nu32 txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;\r\nunsigned int i;\r\nif (tx_flags & E1000_TX_FLAGS_TSO) {\r\ntxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D |\r\nE1000_TXD_CMD_TSE;\r\ntxd_upper |= E1000_TXD_POPTS_TXSM << 8;\r\nif (tx_flags & E1000_TX_FLAGS_IPV4)\r\ntxd_upper |= E1000_TXD_POPTS_IXSM << 8;\r\n}\r\nif (tx_flags & E1000_TX_FLAGS_CSUM) {\r\ntxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;\r\ntxd_upper |= E1000_TXD_POPTS_TXSM << 8;\r\n}\r\nif (tx_flags & E1000_TX_FLAGS_VLAN) {\r\ntxd_lower |= E1000_TXD_CMD_VLE;\r\ntxd_upper |= (tx_flags & E1000_TX_FLAGS_VLAN_MASK);\r\n}\r\nif (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))\r\ntxd_lower &= ~(E1000_TXD_CMD_IFCS);\r\nif (unlikely(tx_flags & E1000_TX_FLAGS_HWTSTAMP)) {\r\ntxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;\r\ntxd_upper |= E1000_TXD_EXTCMD_TSTAMP;\r\n}\r\ni = tx_ring->next_to_use;\r\ndo {\r\nbuffer_info = &tx_ring->buffer_info[i];\r\ntx_desc = E1000_TX_DESC(*tx_ring, i);\r\ntx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);\r\ntx_desc->lower.data = cpu_to_le32(txd_lower |\r\nbuffer_info->length);\r\ntx_desc->upper.data = cpu_to_le32(txd_upper);\r\ni++;\r\nif (i == tx_ring->count)\r\ni = 0;\r\n} while (--count > 0);\r\ntx_desc->lower.data |= cpu_to_le32(adapter->txd_cmd);\r\nif (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))\r\ntx_desc->lower.data &= ~(cpu_to_le32(E1000_TXD_CMD_IFCS));\r\nwmb();\r\ntx_ring->next_to_use = i;\r\nif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\r\ne1000e_update_tdt_wa(tx_ring, i);\r\nelse\r\nwritel(i, tx_ring->tail);\r\nmmiowb();\r\n}\r\nstatic int e1000_transfer_dhcp_info(struct e1000_adapter *adapter,\r\nstruct sk_buff *skb)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 length, offset;\r\nif (vlan_tx_tag_present(skb) &&\r\n!((vlan_tx_tag_get(skb) == adapter->hw.mng_cookie.vlan_id) &&\r\n(adapter->hw.mng_cookie.status &\r\nE1000_MNG_DHCP_COOKIE_STATUS_VLAN)))\r\nreturn 0;\r\nif (skb->len <= MINIMUM_DHCP_PACKET_SIZE)\r\nreturn 0;\r\nif (((struct ethhdr *)skb->data)->h_proto != htons(ETH_P_IP))\r\nreturn 0;\r\n{\r\nconst struct iphdr *ip = (struct iphdr *)((u8 *)skb->data + 14);\r\nstruct udphdr *udp;\r\nif (ip->protocol != IPPROTO_UDP)\r\nreturn 0;\r\nudp = (struct udphdr *)((u8 *)ip + (ip->ihl << 2));\r\nif (ntohs(udp->dest) != 67)\r\nreturn 0;\r\noffset = (u8 *)udp + 8 - skb->data;\r\nlength = skb->len - offset;\r\nreturn e1000e_mng_write_dhcp_info(hw, (u8 *)udp + 8, length);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __e1000_maybe_stop_tx(struct e1000_ring *tx_ring, int size)\r\n{\r\nstruct e1000_adapter *adapter = tx_ring->adapter;\r\nnetif_stop_queue(adapter->netdev);\r\nsmp_mb();\r\nif (e1000_desc_unused(tx_ring) < size)\r\nreturn -EBUSY;\r\nnetif_start_queue(adapter->netdev);\r\n++adapter->restart_queue;\r\nreturn 0;\r\n}\r\nstatic int e1000_maybe_stop_tx(struct e1000_ring *tx_ring, int size)\r\n{\r\nBUG_ON(size > tx_ring->count);\r\nif (e1000_desc_unused(tx_ring) >= size)\r\nreturn 0;\r\nreturn __e1000_maybe_stop_tx(tx_ring, size);\r\n}\r\nstatic netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_ring *tx_ring = adapter->tx_ring;\r\nunsigned int first;\r\nunsigned int tx_flags = 0;\r\nunsigned int len = skb_headlen(skb);\r\nunsigned int nr_frags;\r\nunsigned int mss;\r\nint count = 0;\r\nint tso;\r\nunsigned int f;\r\n__be16 protocol = vlan_get_protocol(skb);\r\nif (test_bit(__E1000_DOWN, &adapter->state)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb->len <= 0) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (unlikely(skb->len < 17)) {\r\nif (skb_pad(skb, 17 - skb->len))\r\nreturn NETDEV_TX_OK;\r\nskb->len = 17;\r\nskb_set_tail_pointer(skb, 17);\r\n}\r\nmss = skb_shinfo(skb)->gso_size;\r\nif (mss) {\r\nu8 hdr_len;\r\nhdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\r\nif (skb->data_len && (hdr_len == len)) {\r\nunsigned int pull_size;\r\npull_size = min_t(unsigned int, 4, skb->data_len);\r\nif (!__pskb_pull_tail(skb, pull_size)) {\r\ne_err("__pskb_pull_tail failed.\n");\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nlen = skb_headlen(skb);\r\n}\r\n}\r\nif ((mss) || (skb->ip_summed == CHECKSUM_PARTIAL))\r\ncount++;\r\ncount++;\r\ncount += DIV_ROUND_UP(len, adapter->tx_fifo_limit);\r\nnr_frags = skb_shinfo(skb)->nr_frags;\r\nfor (f = 0; f < nr_frags; f++)\r\ncount += DIV_ROUND_UP(skb_frag_size(&skb_shinfo(skb)->frags[f]),\r\nadapter->tx_fifo_limit);\r\nif (adapter->hw.mac.tx_pkt_filtering)\r\ne1000_transfer_dhcp_info(adapter, skb);\r\nif (e1000_maybe_stop_tx(tx_ring, count + 2))\r\nreturn NETDEV_TX_BUSY;\r\nif (vlan_tx_tag_present(skb)) {\r\ntx_flags |= E1000_TX_FLAGS_VLAN;\r\ntx_flags |= (vlan_tx_tag_get(skb) << E1000_TX_FLAGS_VLAN_SHIFT);\r\n}\r\nfirst = tx_ring->next_to_use;\r\ntso = e1000_tso(tx_ring, skb, protocol);\r\nif (tso < 0) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (tso)\r\ntx_flags |= E1000_TX_FLAGS_TSO;\r\nelse if (e1000_tx_csum(tx_ring, skb, protocol))\r\ntx_flags |= E1000_TX_FLAGS_CSUM;\r\nif (protocol == htons(ETH_P_IP))\r\ntx_flags |= E1000_TX_FLAGS_IPV4;\r\nif (unlikely(skb->no_fcs))\r\ntx_flags |= E1000_TX_FLAGS_NO_FCS;\r\ncount = e1000_tx_map(tx_ring, skb, first, adapter->tx_fifo_limit,\r\nnr_frags);\r\nif (count) {\r\nif (unlikely((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&\r\n!adapter->tx_hwtstamp_skb)) {\r\nskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\r\ntx_flags |= E1000_TX_FLAGS_HWTSTAMP;\r\nadapter->tx_hwtstamp_skb = skb_get(skb);\r\nadapter->tx_hwtstamp_start = jiffies;\r\nschedule_work(&adapter->tx_hwtstamp_work);\r\n} else {\r\nskb_tx_timestamp(skb);\r\n}\r\nnetdev_sent_queue(netdev, skb->len);\r\ne1000_tx_queue(tx_ring, tx_flags, count);\r\ne1000_maybe_stop_tx(tx_ring,\r\n(MAX_SKB_FRAGS *\r\nDIV_ROUND_UP(PAGE_SIZE,\r\nadapter->tx_fifo_limit) + 2));\r\n} else {\r\ndev_kfree_skb_any(skb);\r\ntx_ring->buffer_info[first].time_stamp = 0;\r\ntx_ring->next_to_use = first;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void e1000_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nadapter->tx_timeout_count++;\r\nschedule_work(&adapter->reset_task);\r\n}\r\nstatic void e1000_reset_task(struct work_struct *work)\r\n{\r\nstruct e1000_adapter *adapter;\r\nadapter = container_of(work, struct e1000_adapter, reset_task);\r\nif (test_bit(__E1000_DOWN, &adapter->state))\r\nreturn;\r\nif (!(adapter->flags & FLAG_RESTART_NOW)) {\r\ne1000e_dump(adapter);\r\ne_err("Reset adapter unexpectedly\n");\r\n}\r\ne1000e_reinit_locked(adapter);\r\n}\r\nstruct rtnl_link_stats64 *e1000e_get_stats64(struct net_device *netdev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nmemset(stats, 0, sizeof(struct rtnl_link_stats64));\r\nspin_lock(&adapter->stats64_lock);\r\ne1000e_update_stats(adapter);\r\nstats->rx_bytes = adapter->stats.gorc;\r\nstats->rx_packets = adapter->stats.gprc;\r\nstats->tx_bytes = adapter->stats.gotc;\r\nstats->tx_packets = adapter->stats.gptc;\r\nstats->multicast = adapter->stats.mprc;\r\nstats->collisions = adapter->stats.colc;\r\nstats->rx_errors = adapter->stats.rxerrc +\r\nadapter->stats.crcerrs + adapter->stats.algnerrc +\r\nadapter->stats.ruc + adapter->stats.roc + adapter->stats.cexterr;\r\nstats->rx_length_errors = adapter->stats.ruc + adapter->stats.roc;\r\nstats->rx_crc_errors = adapter->stats.crcerrs;\r\nstats->rx_frame_errors = adapter->stats.algnerrc;\r\nstats->rx_missed_errors = adapter->stats.mpc;\r\nstats->tx_errors = adapter->stats.ecol + adapter->stats.latecol;\r\nstats->tx_aborted_errors = adapter->stats.ecol;\r\nstats->tx_window_errors = adapter->stats.latecol;\r\nstats->tx_carrier_errors = adapter->stats.tncrs;\r\nspin_unlock(&adapter->stats64_lock);\r\nreturn stats;\r\n}\r\nstatic int e1000_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nint max_frame = new_mtu + VLAN_HLEN + ETH_HLEN + ETH_FCS_LEN;\r\nif ((max_frame > ETH_FRAME_LEN + ETH_FCS_LEN) &&\r\n!(adapter->flags & FLAG_HAS_JUMBO_FRAMES)) {\r\ne_err("Jumbo Frames not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((new_mtu < ETH_ZLEN + ETH_FCS_LEN + VLAN_HLEN) ||\r\n(max_frame > adapter->max_hw_frame_size)) {\r\ne_err("Unsupported MTU setting\n");\r\nreturn -EINVAL;\r\n}\r\nif ((adapter->hw.mac.type >= e1000_pch2lan) &&\r\n!(adapter->flags2 & FLAG2_CRC_STRIPPING) &&\r\n(new_mtu > ETH_DATA_LEN)) {\r\ne_err("Jumbo Frames not supported on this device when CRC stripping is disabled.\n");\r\nreturn -EINVAL;\r\n}\r\nwhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\r\nusleep_range(1000, 2000);\r\nadapter->max_frame_size = max_frame;\r\ne_info("changing MTU from %d to %d\n", netdev->mtu, new_mtu);\r\nnetdev->mtu = new_mtu;\r\npm_runtime_get_sync(netdev->dev.parent);\r\nif (netif_running(netdev))\r\ne1000e_down(adapter, true);\r\nif (max_frame <= 2048)\r\nadapter->rx_buffer_len = 2048;\r\nelse\r\nadapter->rx_buffer_len = 4096;\r\nif ((max_frame == ETH_FRAME_LEN + ETH_FCS_LEN) ||\r\n(max_frame == ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN))\r\nadapter->rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN\r\n+ ETH_FCS_LEN;\r\nif (netif_running(netdev))\r\ne1000e_up(adapter);\r\nelse\r\ne1000e_reset(adapter);\r\npm_runtime_put_sync(netdev->dev.parent);\r\nclear_bit(__E1000_RESETTING, &adapter->state);\r\nreturn 0;\r\n}\r\nstatic int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,\r\nint cmd)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nif (adapter->hw.phy.media_type != e1000_media_type_copper)\r\nreturn -EOPNOTSUPP;\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = adapter->hw.phy.addr;\r\nbreak;\r\ncase SIOCGMIIREG:\r\ne1000_phy_read_status(adapter);\r\nswitch (data->reg_num & 0x1F) {\r\ncase MII_BMCR:\r\ndata->val_out = adapter->phy_regs.bmcr;\r\nbreak;\r\ncase MII_BMSR:\r\ndata->val_out = adapter->phy_regs.bmsr;\r\nbreak;\r\ncase MII_PHYSID1:\r\ndata->val_out = (adapter->hw.phy.id >> 16);\r\nbreak;\r\ncase MII_PHYSID2:\r\ndata->val_out = (adapter->hw.phy.id & 0xFFFF);\r\nbreak;\r\ncase MII_ADVERTISE:\r\ndata->val_out = adapter->phy_regs.advertise;\r\nbreak;\r\ncase MII_LPA:\r\ndata->val_out = adapter->phy_regs.lpa;\r\nbreak;\r\ncase MII_EXPANSION:\r\ndata->val_out = adapter->phy_regs.expansion;\r\nbreak;\r\ncase MII_CTRL1000:\r\ndata->val_out = adapter->phy_regs.ctrl1000;\r\nbreak;\r\ncase MII_STAT1000:\r\ndata->val_out = adapter->phy_regs.stat1000;\r\nbreak;\r\ncase MII_ESTATUS:\r\ndata->val_out = adapter->phy_regs.estatus;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nbreak;\r\ncase SIOCSMIIREG:\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int e1000e_hwtstamp_set(struct net_device *netdev, struct ifreq *ifr)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct hwtstamp_config config;\r\nint ret_val;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nret_val = e1000e_config_hwtstamp(adapter, &config);\r\nif (ret_val)\r\nreturn ret_val;\r\nswitch (config.rx_filter) {\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\nconfig.rx_filter = HWTSTAMP_FILTER_SOME;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn copy_to_user(ifr->ifr_data, &config,\r\nsizeof(config)) ? -EFAULT : 0;\r\n}\r\nstatic int e1000e_hwtstamp_get(struct net_device *netdev, struct ifreq *ifr)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nreturn copy_to_user(ifr->ifr_data, &adapter->hwtstamp_config,\r\nsizeof(adapter->hwtstamp_config)) ? -EFAULT : 0;\r\n}\r\nstatic int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGMIIPHY:\r\ncase SIOCGMIIREG:\r\ncase SIOCSMIIREG:\r\nreturn e1000_mii_ioctl(netdev, ifr, cmd);\r\ncase SIOCSHWTSTAMP:\r\nreturn e1000e_hwtstamp_set(netdev, ifr);\r\ncase SIOCGHWTSTAMP:\r\nreturn e1000e_hwtstamp_get(netdev, ifr);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int e1000_init_phy_wakeup(struct e1000_adapter *adapter, u32 wufc)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 i, mac_reg, wuc;\r\nu16 phy_reg, wuc_enable;\r\nint retval;\r\ne1000_copy_rx_addrs_to_phy_ich8lan(hw);\r\nretval = hw->phy.ops.acquire(hw);\r\nif (retval) {\r\ne_err("Could not acquire PHY\n");\r\nreturn retval;\r\n}\r\nretval = e1000_enable_phy_wakeup_reg_access_bm(hw, &wuc_enable);\r\nif (retval)\r\ngoto release;\r\nfor (i = 0; i < adapter->hw.mac.mta_reg_count; i++) {\r\nmac_reg = E1000_READ_REG_ARRAY(hw, E1000_MTA, i);\r\nhw->phy.ops.write_reg_page(hw, BM_MTA(i),\r\n(u16)(mac_reg & 0xFFFF));\r\nhw->phy.ops.write_reg_page(hw, BM_MTA(i) + 1,\r\n(u16)((mac_reg >> 16) & 0xFFFF));\r\n}\r\nhw->phy.ops.read_reg_page(&adapter->hw, BM_RCTL, &phy_reg);\r\nmac_reg = er32(RCTL);\r\nif (mac_reg & E1000_RCTL_UPE)\r\nphy_reg |= BM_RCTL_UPE;\r\nif (mac_reg & E1000_RCTL_MPE)\r\nphy_reg |= BM_RCTL_MPE;\r\nphy_reg &= ~(BM_RCTL_MO_MASK);\r\nif (mac_reg & E1000_RCTL_MO_3)\r\nphy_reg |= (((mac_reg & E1000_RCTL_MO_3) >> E1000_RCTL_MO_SHIFT)\r\n<< BM_RCTL_MO_SHIFT);\r\nif (mac_reg & E1000_RCTL_BAM)\r\nphy_reg |= BM_RCTL_BAM;\r\nif (mac_reg & E1000_RCTL_PMCF)\r\nphy_reg |= BM_RCTL_PMCF;\r\nmac_reg = er32(CTRL);\r\nif (mac_reg & E1000_CTRL_RFCE)\r\nphy_reg |= BM_RCTL_RFCE;\r\nhw->phy.ops.write_reg_page(&adapter->hw, BM_RCTL, phy_reg);\r\nwuc = E1000_WUC_PME_EN;\r\nif (wufc & (E1000_WUFC_MAG | E1000_WUFC_LNKC))\r\nwuc |= E1000_WUC_APME;\r\new32(WUFC, wufc);\r\new32(WUC, (E1000_WUC_PHY_WAKE | E1000_WUC_APMPME |\r\nE1000_WUC_PME_STATUS | wuc));\r\nhw->phy.ops.write_reg_page(&adapter->hw, BM_WUFC, wufc);\r\nhw->phy.ops.write_reg_page(&adapter->hw, BM_WUC, wuc);\r\nwuc_enable |= BM_WUC_ENABLE_BIT | BM_WUC_HOST_WU_BIT;\r\nretval = e1000_disable_phy_wakeup_reg_access_bm(hw, &wuc_enable);\r\nif (retval)\r\ne_err("Could not set PHY Host Wakeup bit\n");\r\nrelease:\r\nhw->phy.ops.release(hw);\r\nreturn retval;\r\n}\r\nstatic void e1000e_flush_lpic(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ret_val;\r\npm_runtime_get_sync(netdev->dev.parent);\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\ngoto fl_out;\r\npr_info("EEE TX LPI TIMER: %08X\n",\r\ner32(LPIC) >> E1000_LPIC_LPIET_SHIFT);\r\nhw->phy.ops.release(hw);\r\nfl_out:\r\npm_runtime_put_sync(netdev->dev.parent);\r\n}\r\nstatic int e1000e_pm_freeze(struct device *dev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(to_pci_dev(dev));\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev)) {\r\nint count = E1000_CHECK_RESET_COUNT;\r\nwhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\r\nusleep_range(10000, 20000);\r\nWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\r\ne1000e_down(adapter, false);\r\ne1000_free_irq(adapter);\r\n}\r\ne1000e_reset_interrupt_capability(adapter);\r\ne1000e_disable_pcie_master(&adapter->hw);\r\nreturn 0;\r\n}\r\nstatic int __e1000_shutdown(struct pci_dev *pdev, bool runtime)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl, ctrl_ext, rctl, status;\r\nu32 wufc = runtime ? E1000_WUFC_LNKC : adapter->wol;\r\nint retval = 0;\r\nstatus = er32(STATUS);\r\nif (status & E1000_STATUS_LU)\r\nwufc &= ~E1000_WUFC_LNKC;\r\nif (wufc) {\r\ne1000_setup_rctl(adapter);\r\ne1000e_set_rx_mode(netdev);\r\nif (wufc & E1000_WUFC_MC) {\r\nrctl = er32(RCTL);\r\nrctl |= E1000_RCTL_MPE;\r\new32(RCTL, rctl);\r\n}\r\nctrl = er32(CTRL);\r\nctrl |= E1000_CTRL_ADVD3WUC;\r\nif (!(adapter->flags2 & FLAG2_HAS_PHY_WAKEUP))\r\nctrl |= E1000_CTRL_EN_PHY_PWR_MGMT;\r\new32(CTRL, ctrl);\r\nif (adapter->hw.phy.media_type == e1000_media_type_fiber ||\r\nadapter->hw.phy.media_type ==\r\ne1000_media_type_internal_serdes) {\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_SDP3_DATA;\r\new32(CTRL_EXT, ctrl_ext);\r\n}\r\nif (!runtime)\r\ne1000e_power_up_phy(adapter);\r\nif (adapter->flags & FLAG_IS_ICH)\r\ne1000_suspend_workarounds_ich8lan(&adapter->hw);\r\nif (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {\r\nretval = e1000_init_phy_wakeup(adapter, wufc);\r\nif (retval)\r\nreturn retval;\r\n} else {\r\new32(WUFC, wufc);\r\new32(WUC, E1000_WUC_PME_EN);\r\n}\r\n} else {\r\new32(WUC, 0);\r\new32(WUFC, 0);\r\ne1000_power_down_phy(adapter);\r\n}\r\nif (adapter->hw.phy.type == e1000_phy_igp_3) {\r\ne1000e_igp3_phy_powerdown_workaround_ich8lan(&adapter->hw);\r\n} else if (hw->mac.type == e1000_pch_lpt) {\r\nif (!(wufc & (E1000_WUFC_EX | E1000_WUFC_MC | E1000_WUFC_BC)))\r\nretval = e1000_enable_ulp_lpt_lp(hw, !runtime);\r\nif (retval)\r\nreturn retval;\r\n}\r\ne1000e_release_hw_control(adapter);\r\npci_clear_master(pdev);\r\nif (adapter->flags & FLAG_IS_QUAD_PORT) {\r\nstruct pci_dev *us_dev = pdev->bus->self;\r\nu16 devctl;\r\nif (!us_dev)\r\nreturn 0;\r\npcie_capability_read_word(us_dev, PCI_EXP_DEVCTL, &devctl);\r\npcie_capability_write_word(us_dev, PCI_EXP_DEVCTL,\r\n(devctl & ~PCI_EXP_DEVCTL_CERE));\r\npci_save_state(pdev);\r\npci_prepare_to_sleep(pdev);\r\npcie_capability_write_word(us_dev, PCI_EXP_DEVCTL, devctl);\r\n}\r\nreturn 0;\r\n}\r\nstatic void e1000e_disable_aspm(struct pci_dev *pdev, u16 state)\r\n{\r\nstruct pci_dev *parent = pdev->bus->self;\r\nu16 aspm_dis_mask = 0;\r\nu16 pdev_aspmc, parent_aspmc;\r\nswitch (state) {\r\ncase PCIE_LINK_STATE_L0S:\r\ncase PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1:\r\naspm_dis_mask |= PCI_EXP_LNKCTL_ASPM_L0S;\r\ncase PCIE_LINK_STATE_L1:\r\naspm_dis_mask |= PCI_EXP_LNKCTL_ASPM_L1;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\npcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &pdev_aspmc);\r\npdev_aspmc &= PCI_EXP_LNKCTL_ASPMC;\r\nif (parent) {\r\npcie_capability_read_word(parent, PCI_EXP_LNKCTL,\r\n&parent_aspmc);\r\nparent_aspmc &= PCI_EXP_LNKCTL_ASPMC;\r\n}\r\nif (!(pdev_aspmc & aspm_dis_mask) &&\r\n(!parent || !(parent_aspmc & aspm_dis_mask)))\r\nreturn;\r\ndev_info(&pdev->dev, "Disabling ASPM %s %s\n",\r\n(aspm_dis_mask & pdev_aspmc & PCI_EXP_LNKCTL_ASPM_L0S) ?\r\n"L0s" : "",\r\n(aspm_dis_mask & pdev_aspmc & PCI_EXP_LNKCTL_ASPM_L1) ?\r\n"L1" : "");\r\n#ifdef CONFIG_PCIEASPM\r\npci_disable_link_state_locked(pdev, state);\r\npcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &pdev_aspmc);\r\npdev_aspmc &= PCI_EXP_LNKCTL_ASPMC;\r\nif (!(aspm_dis_mask & pdev_aspmc))\r\nreturn;\r\n#endif\r\npcie_capability_clear_word(pdev, PCI_EXP_LNKCTL, aspm_dis_mask);\r\nif (parent)\r\npcie_capability_clear_word(parent, PCI_EXP_LNKCTL,\r\naspm_dis_mask);\r\n}\r\nstatic int __e1000_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 aspm_disable_flag = 0;\r\nif (adapter->flags2 & FLAG2_DISABLE_ASPM_L0S)\r\naspm_disable_flag = PCIE_LINK_STATE_L0S;\r\nif (adapter->flags2 & FLAG2_DISABLE_ASPM_L1)\r\naspm_disable_flag |= PCIE_LINK_STATE_L1;\r\nif (aspm_disable_flag)\r\ne1000e_disable_aspm(pdev, aspm_disable_flag);\r\npci_set_master(pdev);\r\nif (hw->mac.type >= e1000_pch2lan)\r\ne1000_resume_workarounds_pchlan(&adapter->hw);\r\ne1000e_power_up_phy(adapter);\r\nif (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {\r\nu16 phy_data;\r\ne1e_rphy(&adapter->hw, BM_WUS, &phy_data);\r\nif (phy_data) {\r\ne_info("PHY Wakeup cause - %s\n",\r\nphy_data & E1000_WUS_EX ? "Unicast Packet" :\r\nphy_data & E1000_WUS_MC ? "Multicast Packet" :\r\nphy_data & E1000_WUS_BC ? "Broadcast Packet" :\r\nphy_data & E1000_WUS_MAG ? "Magic Packet" :\r\nphy_data & E1000_WUS_LNKC ?\r\n"Link Status Change" : "other");\r\n}\r\ne1e_wphy(&adapter->hw, BM_WUS, ~0);\r\n} else {\r\nu32 wus = er32(WUS);\r\nif (wus) {\r\ne_info("MAC Wakeup cause - %s\n",\r\nwus & E1000_WUS_EX ? "Unicast Packet" :\r\nwus & E1000_WUS_MC ? "Multicast Packet" :\r\nwus & E1000_WUS_BC ? "Broadcast Packet" :\r\nwus & E1000_WUS_MAG ? "Magic Packet" :\r\nwus & E1000_WUS_LNKC ? "Link Status Change" :\r\n"other");\r\n}\r\new32(WUS, ~0);\r\n}\r\ne1000e_reset(adapter);\r\ne1000_init_manageability_pt(adapter);\r\nif (!(adapter->flags & FLAG_HAS_AMT))\r\ne1000e_get_hw_control(adapter);\r\nreturn 0;\r\n}\r\nstatic int e1000e_pm_thaw(struct device *dev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(to_pci_dev(dev));\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\ne1000e_set_interrupt_capability(adapter);\r\nif (netif_running(netdev)) {\r\nu32 err = e1000_request_irq(adapter);\r\nif (err)\r\nreturn err;\r\ne1000e_up(adapter);\r\n}\r\nnetif_device_attach(netdev);\r\nreturn 0;\r\n}\r\nstatic int e1000e_pm_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\ne1000e_flush_lpic(pdev);\r\ne1000e_pm_freeze(dev);\r\nreturn __e1000_shutdown(pdev, false);\r\n}\r\nstatic int e1000e_pm_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nint rc;\r\nrc = __e1000_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nreturn e1000e_pm_thaw(dev);\r\n}\r\nstatic int e1000e_pm_runtime_idle(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nu16 eee_lp;\r\neee_lp = adapter->hw.dev_spec.ich8lan.eee_lp_ability;\r\nif (!e1000e_has_link(adapter)) {\r\nadapter->hw.dev_spec.ich8lan.eee_lp_ability = eee_lp;\r\npm_schedule_suspend(dev, 5 * MSEC_PER_SEC);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int e1000e_pm_runtime_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nint rc;\r\nrc = __e1000_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (netdev->flags & IFF_UP)\r\nrc = e1000e_up(adapter);\r\nreturn rc;\r\n}\r\nstatic int e1000e_pm_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nif (netdev->flags & IFF_UP) {\r\nint count = E1000_CHECK_RESET_COUNT;\r\nwhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\r\nusleep_range(10000, 20000);\r\nWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\r\ne1000e_down(adapter, false);\r\n}\r\nif (__e1000_shutdown(pdev, true)) {\r\ne1000e_pm_runtime_resume(dev);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void e1000_shutdown(struct pci_dev *pdev)\r\n{\r\ne1000e_flush_lpic(pdev);\r\ne1000e_pm_freeze(&pdev->dev);\r\n__e1000_shutdown(pdev, false);\r\n}\r\nstatic irqreturn_t e1000_intr_msix(int __always_unused irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->msix_entries) {\r\nint vector, msix_irq;\r\nvector = 0;\r\nmsix_irq = adapter->msix_entries[vector].vector;\r\ndisable_irq(msix_irq);\r\ne1000_intr_msix_rx(msix_irq, netdev);\r\nenable_irq(msix_irq);\r\nvector++;\r\nmsix_irq = adapter->msix_entries[vector].vector;\r\ndisable_irq(msix_irq);\r\ne1000_intr_msix_tx(msix_irq, netdev);\r\nenable_irq(msix_irq);\r\nvector++;\r\nmsix_irq = adapter->msix_entries[vector].vector;\r\ndisable_irq(msix_irq);\r\ne1000_msix_other(msix_irq, netdev);\r\nenable_irq(msix_irq);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void e1000_netpoll(struct net_device *netdev)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nswitch (adapter->int_mode) {\r\ncase E1000E_INT_MODE_MSIX:\r\ne1000_intr_msix(adapter->pdev->irq, netdev);\r\nbreak;\r\ncase E1000E_INT_MODE_MSI:\r\ndisable_irq(adapter->pdev->irq);\r\ne1000_intr_msi(adapter->pdev->irq, netdev);\r\nenable_irq(adapter->pdev->irq);\r\nbreak;\r\ndefault:\r\ndisable_irq(adapter->pdev->irq);\r\ne1000_intr(adapter->pdev->irq, netdev);\r\nenable_irq(adapter->pdev->irq);\r\nbreak;\r\n}\r\n}\r\nstatic pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nnetif_device_detach(netdev);\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (netif_running(netdev))\r\ne1000e_down(adapter, true);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 aspm_disable_flag = 0;\r\nint err;\r\npci_ers_result_t result;\r\nif (adapter->flags2 & FLAG2_DISABLE_ASPM_L0S)\r\naspm_disable_flag = PCIE_LINK_STATE_L0S;\r\nif (adapter->flags2 & FLAG2_DISABLE_ASPM_L1)\r\naspm_disable_flag |= PCIE_LINK_STATE_L1;\r\nif (aspm_disable_flag)\r\ne1000e_disable_aspm(pdev, aspm_disable_flag);\r\nerr = pci_enable_device_mem(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Cannot re-enable PCI device after reset.\n");\r\nresult = PCI_ERS_RESULT_DISCONNECT;\r\n} else {\r\npdev->state_saved = true;\r\npci_restore_state(pdev);\r\npci_set_master(pdev);\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_enable_wake(pdev, PCI_D3cold, 0);\r\ne1000e_reset(adapter);\r\new32(WUS, ~0);\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\n}\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\nreturn result;\r\n}\r\nstatic void e1000_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\ne1000_init_manageability_pt(adapter);\r\nif (netif_running(netdev)) {\r\nif (e1000e_up(adapter)) {\r\ndev_err(&pdev->dev,\r\n"can't bring device back up after reset\n");\r\nreturn;\r\n}\r\n}\r\nnetif_device_attach(netdev);\r\nif (!(adapter->flags & FLAG_HAS_AMT))\r\ne1000e_get_hw_control(adapter);\r\n}\r\nstatic void e1000_print_device_info(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 ret_val;\r\nu8 pba_str[E1000_PBANUM_LENGTH];\r\ne_info("(PCI Express:2.5GT/s:%s) %pM\n",\r\n((hw->bus.width == e1000_bus_width_pcie_x4) ? "Width x4" :\r\n"Width x1"),\r\nnetdev->dev_addr);\r\ne_info("Intel(R) PRO/%s Network Connection\n",\r\n(hw->phy.type == e1000_phy_ife) ? "10/100" : "1000");\r\nret_val = e1000_read_pba_string_generic(hw, pba_str,\r\nE1000_PBANUM_LENGTH);\r\nif (ret_val)\r\nstrlcpy((char *)pba_str, "Unknown", sizeof(pba_str));\r\ne_info("MAC: %d, PHY: %d, PBA No: %s\n",\r\nhw->mac.type, hw->phy.type, pba_str);\r\n}\r\nstatic void e1000_eeprom_checks(struct e1000_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nint ret_val;\r\nu16 buf = 0;\r\nif (hw->mac.type != e1000_82573)\r\nreturn;\r\nret_val = e1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &buf);\r\nle16_to_cpus(&buf);\r\nif (!ret_val && (!(buf & (1 << 0)))) {\r\ndev_warn(&adapter->pdev->dev,\r\n"Warning: detected DSPD enabled in EEPROM\n");\r\n}\r\n}\r\nstatic int e1000_set_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nnetdev_features_t changed = features ^ netdev->features;\r\nif (changed & (NETIF_F_TSO | NETIF_F_TSO6))\r\nadapter->flags |= FLAG_TSO_FORCE;\r\nif (!(changed & (NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_RXCSUM | NETIF_F_RXHASH | NETIF_F_RXFCS |\r\nNETIF_F_RXALL)))\r\nreturn 0;\r\nif (changed & NETIF_F_RXFCS) {\r\nif (features & NETIF_F_RXFCS) {\r\nadapter->flags2 &= ~FLAG2_CRC_STRIPPING;\r\n} else {\r\nif (adapter->flags2 & FLAG2_DFLT_CRC_STRIPPING)\r\nadapter->flags2 |= FLAG2_CRC_STRIPPING;\r\nelse\r\nadapter->flags2 &= ~FLAG2_CRC_STRIPPING;\r\n}\r\n}\r\nnetdev->features = features;\r\nif (netif_running(netdev))\r\ne1000e_reinit_locked(adapter);\r\nelse\r\ne1000e_reset(adapter);\r\nreturn 0;\r\n}\r\nstatic int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev;\r\nstruct e1000_adapter *adapter;\r\nstruct e1000_hw *hw;\r\nconst struct e1000_info *ei = e1000_info_tbl[ent->driver_data];\r\nresource_size_t mmio_start, mmio_len;\r\nresource_size_t flash_start, flash_len;\r\nstatic int cards_found;\r\nu16 aspm_disable_flag = 0;\r\nint bars, i, err, pci_using_dac;\r\nu16 eeprom_data = 0;\r\nu16 eeprom_apme_mask = E1000_EEPROM_APME;\r\ns32 rval = 0;\r\nif (ei->flags2 & FLAG2_DISABLE_ASPM_L0S)\r\naspm_disable_flag = PCIE_LINK_STATE_L0S;\r\nif (ei->flags2 & FLAG2_DISABLE_ASPM_L1)\r\naspm_disable_flag |= PCIE_LINK_STATE_L1;\r\nif (aspm_disable_flag)\r\ne1000e_disable_aspm(pdev, aspm_disable_flag);\r\nerr = pci_enable_device_mem(pdev);\r\nif (err)\r\nreturn err;\r\npci_using_dac = 0;\r\nerr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\r\nif (!err) {\r\npci_using_dac = 1;\r\n} else {\r\nerr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"No usable DMA configuration, aborting\n");\r\ngoto err_dma;\r\n}\r\n}\r\nbars = pci_select_bars(pdev, IORESOURCE_MEM);\r\nerr = pci_request_selected_regions_exclusive(pdev, bars,\r\ne1000e_driver_name);\r\nif (err)\r\ngoto err_pci_reg;\r\npci_enable_pcie_error_reporting(pdev);\r\npci_set_master(pdev);\r\nerr = pci_save_state(pdev);\r\nif (err)\r\ngoto err_alloc_etherdev;\r\nerr = -ENOMEM;\r\nnetdev = alloc_etherdev(sizeof(struct e1000_adapter));\r\nif (!netdev)\r\ngoto err_alloc_etherdev;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\nnetdev->irq = pdev->irq;\r\npci_set_drvdata(pdev, netdev);\r\nadapter = netdev_priv(netdev);\r\nhw = &adapter->hw;\r\nadapter->netdev = netdev;\r\nadapter->pdev = pdev;\r\nadapter->ei = ei;\r\nadapter->pba = ei->pba;\r\nadapter->flags = ei->flags;\r\nadapter->flags2 = ei->flags2;\r\nadapter->hw.adapter = adapter;\r\nadapter->hw.mac.type = ei->mac;\r\nadapter->max_hw_frame_size = ei->max_hw_frame_size;\r\nadapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\r\nmmio_start = pci_resource_start(pdev, 0);\r\nmmio_len = pci_resource_len(pdev, 0);\r\nerr = -EIO;\r\nadapter->hw.hw_addr = ioremap(mmio_start, mmio_len);\r\nif (!adapter->hw.hw_addr)\r\ngoto err_ioremap;\r\nif ((adapter->flags & FLAG_HAS_FLASH) &&\r\n(pci_resource_flags(pdev, 1) & IORESOURCE_MEM)) {\r\nflash_start = pci_resource_start(pdev, 1);\r\nflash_len = pci_resource_len(pdev, 1);\r\nadapter->hw.flash_address = ioremap(flash_start, flash_len);\r\nif (!adapter->hw.flash_address)\r\ngoto err_flashmap;\r\n}\r\nif (adapter->flags2 & FLAG2_HAS_EEE)\r\nadapter->eee_advert = MDIO_EEE_100TX | MDIO_EEE_1000T;\r\nnetdev->netdev_ops = &e1000e_netdev_ops;\r\ne1000e_set_ethtool_ops(netdev);\r\nnetdev->watchdog_timeo = 5 * HZ;\r\nnetif_napi_add(netdev, &adapter->napi, e1000e_poll, 64);\r\nstrlcpy(netdev->name, pci_name(pdev), sizeof(netdev->name));\r\nnetdev->mem_start = mmio_start;\r\nnetdev->mem_end = mmio_start + mmio_len;\r\nadapter->bd_number = cards_found++;\r\ne1000e_check_options(adapter);\r\nerr = e1000_sw_init(adapter);\r\nif (err)\r\ngoto err_sw_init;\r\nmemcpy(&hw->mac.ops, ei->mac_ops, sizeof(hw->mac.ops));\r\nmemcpy(&hw->nvm.ops, ei->nvm_ops, sizeof(hw->nvm.ops));\r\nmemcpy(&hw->phy.ops, ei->phy_ops, sizeof(hw->phy.ops));\r\nerr = ei->get_variants(adapter);\r\nif (err)\r\ngoto err_hw_init;\r\nif ((adapter->flags & FLAG_IS_ICH) &&\r\n(adapter->flags & FLAG_READ_ONLY_NVM))\r\ne1000e_write_protect_nvm_ich8lan(&adapter->hw);\r\nhw->mac.ops.get_bus_info(&adapter->hw);\r\nadapter->hw.phy.autoneg_wait_to_complete = 0;\r\nif (adapter->hw.phy.media_type == e1000_media_type_copper) {\r\nadapter->hw.phy.mdix = AUTO_ALL_MODES;\r\nadapter->hw.phy.disable_polarity_correction = 0;\r\nadapter->hw.phy.ms_type = e1000_ms_hw_default;\r\n}\r\nif (hw->phy.ops.check_reset_block && hw->phy.ops.check_reset_block(hw))\r\ndev_info(&pdev->dev,\r\n"PHY reset is blocked due to SOL/IDER session.\n");\r\nnetdev->features = (NETIF_F_SG |\r\nNETIF_F_HW_VLAN_CTAG_RX |\r\nNETIF_F_HW_VLAN_CTAG_TX |\r\nNETIF_F_TSO |\r\nNETIF_F_TSO6 |\r\nNETIF_F_RXHASH |\r\nNETIF_F_RXCSUM |\r\nNETIF_F_HW_CSUM);\r\nnetdev->hw_features = netdev->features;\r\nnetdev->hw_features |= NETIF_F_RXFCS;\r\nnetdev->priv_flags |= IFF_SUPP_NOFCS;\r\nnetdev->hw_features |= NETIF_F_RXALL;\r\nif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER)\r\nnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\nnetdev->vlan_features |= (NETIF_F_SG |\r\nNETIF_F_TSO |\r\nNETIF_F_TSO6 |\r\nNETIF_F_HW_CSUM);\r\nnetdev->priv_flags |= IFF_UNICAST_FLT;\r\nif (pci_using_dac) {\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nnetdev->vlan_features |= NETIF_F_HIGHDMA;\r\n}\r\nif (e1000e_enable_mng_pass_thru(&adapter->hw))\r\nadapter->flags |= FLAG_MNG_PT_ENABLED;\r\nadapter->hw.mac.ops.reset_hw(&adapter->hw);\r\nfor (i = 0;; i++) {\r\nif (e1000_validate_nvm_checksum(&adapter->hw) >= 0)\r\nbreak;\r\nif (i == 2) {\r\ndev_err(&pdev->dev, "The NVM Checksum Is Not Valid\n");\r\nerr = -EIO;\r\ngoto err_eeprom;\r\n}\r\n}\r\ne1000_eeprom_checks(adapter);\r\nif (e1000e_read_mac_addr(&adapter->hw))\r\ndev_err(&pdev->dev,\r\n"NVM Read Error while reading MAC address\n");\r\nmemcpy(netdev->dev_addr, adapter->hw.mac.addr, netdev->addr_len);\r\nif (!is_valid_ether_addr(netdev->dev_addr)) {\r\ndev_err(&pdev->dev, "Invalid MAC Address: %pM\n",\r\nnetdev->dev_addr);\r\nerr = -EIO;\r\ngoto err_eeprom;\r\n}\r\ninit_timer(&adapter->watchdog_timer);\r\nadapter->watchdog_timer.function = e1000_watchdog;\r\nadapter->watchdog_timer.data = (unsigned long)adapter;\r\ninit_timer(&adapter->phy_info_timer);\r\nadapter->phy_info_timer.function = e1000_update_phy_info;\r\nadapter->phy_info_timer.data = (unsigned long)adapter;\r\nINIT_WORK(&adapter->reset_task, e1000_reset_task);\r\nINIT_WORK(&adapter->watchdog_task, e1000_watchdog_task);\r\nINIT_WORK(&adapter->downshift_task, e1000e_downshift_workaround);\r\nINIT_WORK(&adapter->update_phy_task, e1000e_update_phy_task);\r\nINIT_WORK(&adapter->print_hang_task, e1000_print_hw_hang);\r\nadapter->hw.mac.autoneg = 1;\r\nadapter->fc_autoneg = true;\r\nadapter->hw.fc.requested_mode = e1000_fc_default;\r\nadapter->hw.fc.current_mode = e1000_fc_default;\r\nadapter->hw.phy.autoneg_advertised = 0x2f;\r\nif (adapter->flags & FLAG_APME_IN_WUC) {\r\neeprom_data = er32(WUC);\r\neeprom_apme_mask = E1000_WUC_APME;\r\nif ((hw->mac.type > e1000_ich10lan) &&\r\n(eeprom_data & E1000_WUC_PHY_WAKE))\r\nadapter->flags2 |= FLAG2_HAS_PHY_WAKEUP;\r\n} else if (adapter->flags & FLAG_APME_IN_CTRL3) {\r\nif (adapter->flags & FLAG_APME_CHECK_PORT_B &&\r\n(adapter->hw.bus.func == 1))\r\nrval = e1000_read_nvm(&adapter->hw,\r\nNVM_INIT_CONTROL3_PORT_B,\r\n1, &eeprom_data);\r\nelse\r\nrval = e1000_read_nvm(&adapter->hw,\r\nNVM_INIT_CONTROL3_PORT_A,\r\n1, &eeprom_data);\r\n}\r\nif (rval)\r\ne_dbg("NVM read error getting WoL initial values: %d\n", rval);\r\nelse if (eeprom_data & eeprom_apme_mask)\r\nadapter->eeprom_wol |= E1000_WUFC_MAG;\r\nif (!(adapter->flags & FLAG_HAS_WOL))\r\nadapter->eeprom_wol = 0;\r\nadapter->wol = adapter->eeprom_wol;\r\nif (adapter->wol || (adapter->flags & FLAG_MNG_PT_ENABLED) ||\r\n(hw->mac.ops.check_mng_mode(hw)))\r\ndevice_wakeup_enable(&pdev->dev);\r\nrval = e1000_read_nvm(&adapter->hw, 5, 1, &adapter->eeprom_vers);\r\nif (rval) {\r\ne_dbg("NVM read error getting EEPROM version: %d\n", rval);\r\nadapter->eeprom_vers = 0;\r\n}\r\ne1000e_reset(adapter);\r\nif (!(adapter->flags & FLAG_HAS_AMT))\r\ne1000e_get_hw_control(adapter);\r\nstrlcpy(netdev->name, "eth%d", sizeof(netdev->name));\r\nerr = register_netdev(netdev);\r\nif (err)\r\ngoto err_register;\r\nnetif_carrier_off(netdev);\r\ne1000e_ptp_init(adapter);\r\ne1000_print_device_info(adapter);\r\nif (pci_dev_run_wake(pdev))\r\npm_runtime_put_noidle(&pdev->dev);\r\nreturn 0;\r\nerr_register:\r\nif (!(adapter->flags & FLAG_HAS_AMT))\r\ne1000e_release_hw_control(adapter);\r\nerr_eeprom:\r\nif (hw->phy.ops.check_reset_block && !hw->phy.ops.check_reset_block(hw))\r\ne1000_phy_hw_reset(&adapter->hw);\r\nerr_hw_init:\r\nkfree(adapter->tx_ring);\r\nkfree(adapter->rx_ring);\r\nerr_sw_init:\r\nif (adapter->hw.flash_address)\r\niounmap(adapter->hw.flash_address);\r\ne1000e_reset_interrupt_capability(adapter);\r\nerr_flashmap:\r\niounmap(adapter->hw.hw_addr);\r\nerr_ioremap:\r\nfree_netdev(netdev);\r\nerr_alloc_etherdev:\r\npci_release_selected_regions(pdev,\r\npci_select_bars(pdev, IORESOURCE_MEM));\r\nerr_pci_reg:\r\nerr_dma:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void e1000_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct e1000_adapter *adapter = netdev_priv(netdev);\r\nbool down = test_bit(__E1000_DOWN, &adapter->state);\r\ne1000e_ptp_remove(adapter);\r\nif (!down)\r\nset_bit(__E1000_DOWN, &adapter->state);\r\ndel_timer_sync(&adapter->watchdog_timer);\r\ndel_timer_sync(&adapter->phy_info_timer);\r\ncancel_work_sync(&adapter->reset_task);\r\ncancel_work_sync(&adapter->watchdog_task);\r\ncancel_work_sync(&adapter->downshift_task);\r\ncancel_work_sync(&adapter->update_phy_task);\r\ncancel_work_sync(&adapter->print_hang_task);\r\nif (adapter->flags & FLAG_HAS_HW_TIMESTAMP) {\r\ncancel_work_sync(&adapter->tx_hwtstamp_work);\r\nif (adapter->tx_hwtstamp_skb) {\r\ndev_kfree_skb_any(adapter->tx_hwtstamp_skb);\r\nadapter->tx_hwtstamp_skb = NULL;\r\n}\r\n}\r\nif (!down)\r\nclear_bit(__E1000_DOWN, &adapter->state);\r\nunregister_netdev(netdev);\r\nif (pci_dev_run_wake(pdev))\r\npm_runtime_get_noresume(&pdev->dev);\r\ne1000e_release_hw_control(adapter);\r\ne1000e_reset_interrupt_capability(adapter);\r\nkfree(adapter->tx_ring);\r\nkfree(adapter->rx_ring);\r\niounmap(adapter->hw.hw_addr);\r\nif (adapter->hw.flash_address)\r\niounmap(adapter->hw.flash_address);\r\npci_release_selected_regions(pdev,\r\npci_select_bars(pdev, IORESOURCE_MEM));\r\nfree_netdev(netdev);\r\npci_disable_pcie_error_reporting(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __init e1000_init_module(void)\r\n{\r\nint ret;\r\npr_info("Intel(R) PRO/1000 Network Driver - %s\n",\r\ne1000e_driver_version);\r\npr_info("Copyright(c) 1999 - 2014 Intel Corporation.\n");\r\nret = pci_register_driver(&e1000_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit e1000_exit_module(void)\r\n{\r\npci_unregister_driver(&e1000_driver);\r\n}
