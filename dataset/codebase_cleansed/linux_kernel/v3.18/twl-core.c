static bool twl4030_49_nop_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0x00:\r\ncase 0x03:\r\ncase 0x40:\r\ncase 0x41:\r\ncase 0x42:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic inline int twl_get_num_slaves(void)\r\n{\r\nif (twl_class_is_4030())\r\nreturn 4;\r\nelse\r\nreturn 3;\r\n}\r\nstatic inline int twl_get_last_module(void)\r\n{\r\nif (twl_class_is_4030())\r\nreturn TWL4030_MODULE_LAST;\r\nelse\r\nreturn TWL6030_MODULE_LAST;\r\n}\r\nunsigned int twl_rev(void)\r\n{\r\nreturn twl_priv ? twl_priv->twl_id : 0;\r\n}\r\nstatic struct regmap *twl_get_regmap(u8 mod_no)\r\n{\r\nint sid;\r\nstruct twl_client *twl;\r\nif (unlikely(!twl_priv || !twl_priv->ready)) {\r\npr_err("%s: not initialized\n", DRIVER_NAME);\r\nreturn NULL;\r\n}\r\nif (unlikely(mod_no >= twl_get_last_module())) {\r\npr_err("%s: invalid module number %d\n", DRIVER_NAME, mod_no);\r\nreturn NULL;\r\n}\r\nsid = twl_priv->twl_map[mod_no].sid;\r\ntwl = &twl_priv->twl_modules[sid];\r\nreturn twl->regmap;\r\n}\r\nint twl_i2c_write(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)\r\n{\r\nstruct regmap *regmap = twl_get_regmap(mod_no);\r\nint ret;\r\nif (!regmap)\r\nreturn -EPERM;\r\nret = regmap_bulk_write(regmap, twl_priv->twl_map[mod_no].base + reg,\r\nvalue, num_bytes);\r\nif (ret)\r\npr_err("%s: Write failed (mod %d, reg 0x%02x count %d)\n",\r\nDRIVER_NAME, mod_no, reg, num_bytes);\r\nreturn ret;\r\n}\r\nint twl_i2c_read(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)\r\n{\r\nstruct regmap *regmap = twl_get_regmap(mod_no);\r\nint ret;\r\nif (!regmap)\r\nreturn -EPERM;\r\nret = regmap_bulk_read(regmap, twl_priv->twl_map[mod_no].base + reg,\r\nvalue, num_bytes);\r\nif (ret)\r\npr_err("%s: Read failed (mod %d, reg 0x%02x count %d)\n",\r\nDRIVER_NAME, mod_no, reg, num_bytes);\r\nreturn ret;\r\n}\r\nint twl_set_regcache_bypass(u8 mod_no, bool enable)\r\n{\r\nstruct regmap *regmap = twl_get_regmap(mod_no);\r\nif (!regmap)\r\nreturn -EPERM;\r\nregcache_cache_bypass(regmap, enable);\r\nreturn 0;\r\n}\r\nstatic int twl_read_idcode_register(void)\r\n{\r\nint err;\r\nerr = twl_i2c_write_u8(TWL4030_MODULE_INTBR, TWL_EEPROM_R_UNLOCK,\r\nREG_UNLOCK_TEST_REG);\r\nif (err) {\r\npr_err("TWL4030 Unable to unlock IDCODE registers -%d\n", err);\r\ngoto fail;\r\n}\r\nerr = twl_i2c_read(TWL4030_MODULE_INTBR, (u8 *)(&twl_priv->twl_idcode),\r\nREG_IDCODE_7_0, 4);\r\nif (err) {\r\npr_err("TWL4030: unable to read IDCODE -%d\n", err);\r\ngoto fail;\r\n}\r\nerr = twl_i2c_write_u8(TWL4030_MODULE_INTBR, 0x0, REG_UNLOCK_TEST_REG);\r\nif (err)\r\npr_err("TWL4030 Unable to relock IDCODE registers -%d\n", err);\r\nfail:\r\nreturn err;\r\n}\r\nint twl_get_type(void)\r\n{\r\nreturn TWL_SIL_TYPE(twl_priv->twl_idcode);\r\n}\r\nint twl_get_version(void)\r\n{\r\nreturn TWL_SIL_REV(twl_priv->twl_idcode);\r\n}\r\nint twl_get_hfclk_rate(void)\r\n{\r\nu8 ctrl;\r\nint rate;\r\ntwl_i2c_read_u8(TWL_MODULE_PM_MASTER, &ctrl, R_CFG_BOOT);\r\nswitch (ctrl & 0x3) {\r\ncase HFCLK_FREQ_19p2_MHZ:\r\nrate = 19200000;\r\nbreak;\r\ncase HFCLK_FREQ_26_MHZ:\r\nrate = 26000000;\r\nbreak;\r\ncase HFCLK_FREQ_38p4_MHZ:\r\nrate = 38400000;\r\nbreak;\r\ndefault:\r\npr_err("TWL4030: HFCLK is not configured\n");\r\nrate = -EINVAL;\r\nbreak;\r\n}\r\nreturn rate;\r\n}\r\nstatic struct device *\r\nadd_numbered_child(unsigned mod_no, const char *name, int num,\r\nvoid *pdata, unsigned pdata_len,\r\nbool can_wakeup, int irq0, int irq1)\r\n{\r\nstruct platform_device *pdev;\r\nstruct twl_client *twl;\r\nint status, sid;\r\nif (unlikely(mod_no >= twl_get_last_module())) {\r\npr_err("%s: invalid module number %d\n", DRIVER_NAME, mod_no);\r\nreturn ERR_PTR(-EPERM);\r\n}\r\nsid = twl_priv->twl_map[mod_no].sid;\r\ntwl = &twl_priv->twl_modules[sid];\r\npdev = platform_device_alloc(name, num);\r\nif (!pdev) {\r\ndev_dbg(&twl->client->dev, "can't alloc dev\n");\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\npdev->dev.parent = &twl->client->dev;\r\nif (pdata) {\r\nstatus = platform_device_add_data(pdev, pdata, pdata_len);\r\nif (status < 0) {\r\ndev_dbg(&pdev->dev, "can't add platform_data\n");\r\ngoto err;\r\n}\r\n}\r\nif (irq0) {\r\nstruct resource r[2] = {\r\n{ .start = irq0, .flags = IORESOURCE_IRQ, },\r\n{ .start = irq1, .flags = IORESOURCE_IRQ, },\r\n};\r\nstatus = platform_device_add_resources(pdev, r, irq1 ? 2 : 1);\r\nif (status < 0) {\r\ndev_dbg(&pdev->dev, "can't add irqs\n");\r\ngoto err;\r\n}\r\n}\r\nstatus = platform_device_add(pdev);\r\nif (status == 0)\r\ndevice_init_wakeup(&pdev->dev, can_wakeup);\r\nerr:\r\nif (status < 0) {\r\nplatform_device_put(pdev);\r\ndev_err(&twl->client->dev, "can't add %s dev\n", name);\r\nreturn ERR_PTR(status);\r\n}\r\nreturn &pdev->dev;\r\n}\r\nstatic inline struct device *add_child(unsigned mod_no, const char *name,\r\nvoid *pdata, unsigned pdata_len,\r\nbool can_wakeup, int irq0, int irq1)\r\n{\r\nreturn add_numbered_child(mod_no, name, -1, pdata, pdata_len,\r\ncan_wakeup, irq0, irq1);\r\n}\r\nstatic struct device *\r\nadd_regulator_linked(int num, struct regulator_init_data *pdata,\r\nstruct regulator_consumer_supply *consumers,\r\nunsigned num_consumers, unsigned long features)\r\n{\r\nstruct twl_regulator_driver_data drv_data;\r\nif (!pdata)\r\nreturn NULL;\r\nif (consumers) {\r\npdata->consumer_supplies = consumers;\r\npdata->num_consumer_supplies = num_consumers;\r\n}\r\nif (pdata->driver_data) {\r\nstruct twl_regulator_driver_data *tmp;\r\ntmp = pdata->driver_data;\r\ntmp->features |= features;\r\n} else {\r\ndrv_data.features = features;\r\ndrv_data.set_voltage = NULL;\r\ndrv_data.get_voltage = NULL;\r\ndrv_data.data = NULL;\r\npdata->driver_data = &drv_data;\r\n}\r\nreturn add_numbered_child(TWL_MODULE_PM_MASTER, "twl_reg", num,\r\npdata, sizeof(*pdata), false, 0, 0);\r\n}\r\nstatic struct device *\r\nadd_regulator(int num, struct regulator_init_data *pdata,\r\nunsigned long features)\r\n{\r\nreturn add_regulator_linked(num, pdata, NULL, 0, features);\r\n}\r\nstatic int\r\nadd_children(struct twl4030_platform_data *pdata, unsigned irq_base,\r\nunsigned long features)\r\n{\r\nstruct device *child;\r\nif (IS_ENABLED(CONFIG_GPIO_TWL4030) && pdata->gpio) {\r\nchild = add_child(TWL4030_MODULE_GPIO, "twl4030_gpio",\r\npdata->gpio, sizeof(*pdata->gpio),\r\nfalse, irq_base + GPIO_INTR_OFFSET, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_KEYBOARD_TWL4030) && pdata->keypad) {\r\nchild = add_child(TWL4030_MODULE_KEYPAD, "twl4030_keypad",\r\npdata->keypad, sizeof(*pdata->keypad),\r\ntrue, irq_base + KEYPAD_INTR_OFFSET, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_TWL4030_MADC) && pdata->madc &&\r\ntwl_class_is_4030()) {\r\nchild = add_child(TWL4030_MODULE_MADC, "twl4030_madc",\r\npdata->madc, sizeof(*pdata->madc),\r\ntrue, irq_base + MADC_INTR_OFFSET, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_RTC_DRV_TWL4030)) {\r\nchild = add_child(TWL_MODULE_RTC, "twl_rtc", NULL, 0,\r\ntrue, irq_base + RTC_INTR_OFFSET, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_PWM_TWL)) {\r\nchild = add_child(TWL_MODULE_PWM, "twl-pwm", NULL, 0,\r\nfalse, 0, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_PWM_TWL_LED)) {\r\nchild = add_child(TWL_MODULE_LED, "twl-pwmled", NULL, 0,\r\nfalse, 0, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_TWL4030_USB) && pdata->usb &&\r\ntwl_class_is_4030()) {\r\nstatic struct regulator_consumer_supply usb1v5 = {\r\n.supply = "usb1v5",\r\n};\r\nstatic struct regulator_consumer_supply usb1v8 = {\r\n.supply = "usb1v8",\r\n};\r\nstatic struct regulator_consumer_supply usb3v1[] = {\r\n{ .supply = "usb3v1" },\r\n{ .supply = "bci3v1" },\r\n};\r\nif (IS_ENABLED(CONFIG_REGULATOR_TWL4030)) {\r\nstruct regulator_init_data usb_fixed = {\r\n.constraints.valid_modes_mask =\r\nREGULATOR_MODE_NORMAL\r\n| REGULATOR_MODE_STANDBY,\r\n.constraints.valid_ops_mask =\r\nREGULATOR_CHANGE_MODE\r\n| REGULATOR_CHANGE_STATUS,\r\n};\r\nchild = add_regulator_linked(TWL4030_REG_VUSB1V5,\r\n&usb_fixed, &usb1v5, 1,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator_linked(TWL4030_REG_VUSB1V8,\r\n&usb_fixed, &usb1v8, 1,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator_linked(TWL4030_REG_VUSB3V1,\r\n&usb_fixed, usb3v1, 2,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nchild = add_child(TWL_MODULE_USB, "twl4030_usb",\r\npdata->usb, sizeof(*pdata->usb), true,\r\nirq_base + USB_PRES_INTR_OFFSET,\r\nirq_base + USB_INTR_OFFSET);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nif (IS_ENABLED(CONFIG_REGULATOR_TWL4030) && child) {\r\nusb1v5.dev_name = dev_name(child);\r\nusb1v8.dev_name = dev_name(child);\r\nusb3v1[0].dev_name = dev_name(child);\r\n}\r\n}\r\nif (IS_ENABLED(CONFIG_TWL4030_WATCHDOG) && twl_class_is_4030()) {\r\nchild = add_child(TWL_MODULE_PM_RECEIVER, "twl4030_wdt", NULL,\r\n0, false, 0, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_INPUT_TWL4030_PWRBUTTON) && twl_class_is_4030()) {\r\nchild = add_child(TWL_MODULE_PM_MASTER, "twl4030_pwrbutton",\r\nNULL, 0, true, irq_base + 8 + 0, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_MFD_TWL4030_AUDIO) && pdata->audio &&\r\ntwl_class_is_4030()) {\r\nchild = add_child(TWL4030_MODULE_AUDIO_VOICE, "twl4030-audio",\r\npdata->audio, sizeof(*pdata->audio),\r\nfalse, 0, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_REGULATOR_TWL4030) && twl_class_is_4030()) {\r\nchild = add_regulator(TWL4030_REG_VPLL1, pdata->vpll1,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VIO, pdata->vio,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VDD1, pdata->vdd1,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VDD2, pdata->vdd2,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VMMC1, pdata->vmmc1,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VDAC, pdata->vdac,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator((features & TWL4030_VAUX2)\r\n? TWL4030_REG_VAUX2_4030\r\n: TWL4030_REG_VAUX2,\r\npdata->vaux2, features);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VINTANA1, pdata->vintana1,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VINTANA2, pdata->vintana2,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VINTDIG, pdata->vintdig,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_REGULATOR_TWL4030) && !(features & TPS_SUBSET)\r\n&& twl_class_is_4030()) {\r\nchild = add_regulator(TWL4030_REG_VPLL2, pdata->vpll2,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VMMC2, pdata->vmmc2,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VSIM, pdata->vsim,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VAUX1, pdata->vaux1,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VAUX3, pdata->vaux3,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\nchild = add_regulator(TWL4030_REG_VAUX4, pdata->vaux4,\r\nfeatures);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_CHARGER_TWL4030) && pdata->bci &&\r\n!(features & (TPS_SUBSET | TWL5031))) {\r\nchild = add_child(TWL_MODULE_MAIN_CHARGE, "twl4030_bci",\r\npdata->bci, sizeof(*pdata->bci), false,\r\nirq_base + BCI_PRES_INTR_OFFSET,\r\nirq_base + BCI_INTR_OFFSET);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nif (IS_ENABLED(CONFIG_TWL4030_POWER) && pdata->power) {\r\nchild = add_child(TWL_MODULE_PM_MASTER, "twl4030_power",\r\npdata->power, sizeof(*pdata->power), false,\r\n0, 0);\r\nif (IS_ERR(child))\r\nreturn PTR_ERR(child);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int __init protect_pm_master(void)\r\n{\r\nint e = 0;\r\ne = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, 0,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\nreturn e;\r\n}\r\nstatic inline int __init unprotect_pm_master(void)\r\n{\r\nint e = 0;\r\ne |= twl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG1,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\ne |= twl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG2,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\nreturn e;\r\n}\r\nstatic void clocks_init(struct device *dev,\r\nstruct twl4030_clock_init_data *clock)\r\n{\r\nint e = 0;\r\nstruct clk *osc;\r\nu32 rate;\r\nu8 ctrl = HFCLK_FREQ_26_MHZ;\r\nosc = clk_get(dev, "fck");\r\nif (IS_ERR(osc)) {\r\nprintk(KERN_WARNING "Skipping twl internal clock init and "\r\n"using bootloader value (unknown osc rate)\n");\r\nreturn;\r\n}\r\nrate = clk_get_rate(osc);\r\nclk_put(osc);\r\nswitch (rate) {\r\ncase 19200000:\r\nctrl = HFCLK_FREQ_19p2_MHZ;\r\nbreak;\r\ncase 26000000:\r\nctrl = HFCLK_FREQ_26_MHZ;\r\nbreak;\r\ncase 38400000:\r\nctrl = HFCLK_FREQ_38p4_MHZ;\r\nbreak;\r\n}\r\nctrl |= HIGH_PERF_SQ;\r\nif (clock && clock->ck32k_lowpwr_enable)\r\nctrl |= CK32K_LOWPWR_EN;\r\ne |= unprotect_pm_master();\r\ne |= twl_i2c_write_u8(TWL_MODULE_PM_MASTER, ctrl, R_CFG_BOOT);\r\ne |= protect_pm_master();\r\nif (e < 0)\r\npr_err("%s: clock init err [%d]\n", DRIVER_NAME, e);\r\n}\r\nstatic int twl_remove(struct i2c_client *client)\r\n{\r\nunsigned i, num_slaves;\r\nint status;\r\nif (twl_class_is_4030())\r\nstatus = twl4030_exit_irq();\r\nelse\r\nstatus = twl6030_exit_irq();\r\nif (status < 0)\r\nreturn status;\r\nnum_slaves = twl_get_num_slaves();\r\nfor (i = 0; i < num_slaves; i++) {\r\nstruct twl_client *twl = &twl_priv->twl_modules[i];\r\nif (twl->client && twl->client != client)\r\ni2c_unregister_device(twl->client);\r\ntwl->client = NULL;\r\n}\r\ntwl_priv->ready = false;\r\nreturn 0;\r\n}\r\nstatic int\r\ntwl_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct twl4030_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct device_node *node = client->dev.of_node;\r\nstruct platform_device *pdev;\r\nstruct regmap_config *twl_regmap_config;\r\nint irq_base = 0;\r\nint status;\r\nunsigned i, num_slaves;\r\nif (!node && !pdata) {\r\ndev_err(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (twl_priv) {\r\ndev_dbg(&client->dev, "only one instance of %s allowed\n",\r\nDRIVER_NAME);\r\nreturn -EBUSY;\r\n}\r\npdev = platform_device_alloc(DRIVER_NAME, -1);\r\nif (!pdev) {\r\ndev_err(&client->dev, "can't alloc pdev\n");\r\nreturn -ENOMEM;\r\n}\r\nstatus = platform_device_add(pdev);\r\nif (status) {\r\nplatform_device_put(pdev);\r\nreturn status;\r\n}\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C) == 0) {\r\ndev_dbg(&client->dev, "can't talk I2C?\n");\r\nstatus = -EIO;\r\ngoto free;\r\n}\r\ntwl_priv = devm_kzalloc(&client->dev, sizeof(struct twl_private),\r\nGFP_KERNEL);\r\nif (!twl_priv) {\r\nstatus = -ENOMEM;\r\ngoto free;\r\n}\r\nif ((id->driver_data) & TWL6030_CLASS) {\r\ntwl_priv->twl_id = TWL6030_CLASS_ID;\r\ntwl_priv->twl_map = &twl6030_map[0];\r\nif ((id->driver_data) & TWL6032_SUBCLASS)\r\ntwl_priv->twl_map[TWL_MODULE_MAIN_CHARGE].base =\r\nTWL6032_BASEADD_CHARGER;\r\ntwl_regmap_config = twl6030_regmap_config;\r\n} else {\r\ntwl_priv->twl_id = TWL4030_CLASS_ID;\r\ntwl_priv->twl_map = &twl4030_map[0];\r\ntwl_regmap_config = twl4030_regmap_config;\r\n}\r\nnum_slaves = twl_get_num_slaves();\r\ntwl_priv->twl_modules = devm_kzalloc(&client->dev,\r\nsizeof(struct twl_client) * num_slaves,\r\nGFP_KERNEL);\r\nif (!twl_priv->twl_modules) {\r\nstatus = -ENOMEM;\r\ngoto free;\r\n}\r\nfor (i = 0; i < num_slaves; i++) {\r\nstruct twl_client *twl = &twl_priv->twl_modules[i];\r\nif (i == 0) {\r\ntwl->client = client;\r\n} else {\r\ntwl->client = i2c_new_dummy(client->adapter,\r\nclient->addr + i);\r\nif (!twl->client) {\r\ndev_err(&client->dev,\r\n"can't attach client %d\n", i);\r\nstatus = -ENOMEM;\r\ngoto fail;\r\n}\r\n}\r\ntwl->regmap = devm_regmap_init_i2c(twl->client,\r\n&twl_regmap_config[i]);\r\nif (IS_ERR(twl->regmap)) {\r\nstatus = PTR_ERR(twl->regmap);\r\ndev_err(&client->dev,\r\n"Failed to allocate regmap %d, err: %d\n", i,\r\nstatus);\r\ngoto fail;\r\n}\r\n}\r\ntwl_priv->ready = true;\r\nclocks_init(&pdev->dev, pdata ? pdata->clock : NULL);\r\nif (twl_class_is_4030()) {\r\nstatus = twl_read_idcode_register();\r\nWARN(status < 0, "Error: reading twl_idcode register value\n");\r\n}\r\nif (client->irq) {\r\nif (twl_class_is_4030()) {\r\ntwl4030_init_chip_irq(id->name);\r\nirq_base = twl4030_init_irq(&client->dev, client->irq);\r\n} else {\r\nirq_base = twl6030_init_irq(&client->dev, client->irq);\r\n}\r\nif (irq_base < 0) {\r\nstatus = irq_base;\r\ngoto fail;\r\n}\r\n}\r\nif (twl_class_is_4030()) {\r\nu8 temp;\r\ntwl_i2c_read_u8(TWL4030_MODULE_INTBR, &temp, REG_GPPUPDCTR1);\r\ntemp &= ~(SR_I2C_SDA_CTRL_PU | SR_I2C_SCL_CTRL_PU | \\r\nI2C_SDA_CTRL_PU | I2C_SCL_CTRL_PU);\r\ntwl_i2c_write_u8(TWL4030_MODULE_INTBR, temp, REG_GPPUPDCTR1);\r\ntwl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &temp,\r\nTWL4030_DCDC_GLOBAL_CFG);\r\ntemp |= SMARTREFLEX_ENABLE;\r\ntwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, temp,\r\nTWL4030_DCDC_GLOBAL_CFG);\r\n}\r\nif (node) {\r\nif (pdata)\r\ntwl_auxdata_lookup[0].platform_data = pdata->gpio;\r\nstatus = of_platform_populate(node, NULL, twl_auxdata_lookup,\r\n&client->dev);\r\n} else {\r\nstatus = add_children(pdata, irq_base, id->driver_data);\r\n}\r\nfail:\r\nif (status < 0)\r\ntwl_remove(client);\r\nfree:\r\nif (status < 0)\r\nplatform_device_unregister(pdev);\r\nreturn status;\r\n}
