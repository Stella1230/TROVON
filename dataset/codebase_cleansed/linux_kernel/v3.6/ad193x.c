static int ad193x_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct ad193x_priv *ad193x = snd_soc_codec_get_drvdata(dai->codec);\r\nif (mute)\r\nregmap_update_bits(ad193x->regmap, AD193X_DAC_CTRL2,\r\nAD193X_DAC_MASTER_MUTE,\r\nAD193X_DAC_MASTER_MUTE);\r\nelse\r\nregmap_update_bits(ad193x->regmap, AD193X_DAC_CTRL2,\r\nAD193X_DAC_MASTER_MUTE, 0);\r\nreturn 0;\r\n}\r\nstatic int ad193x_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int width)\r\n{\r\nstruct ad193x_priv *ad193x = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int channels;\r\nswitch (slots) {\r\ncase 2:\r\nchannels = AD193X_2_CHANNELS;\r\nbreak;\r\ncase 4:\r\nchannels = AD193X_4_CHANNELS;\r\nbreak;\r\ncase 8:\r\nchannels = AD193X_8_CHANNELS;\r\nbreak;\r\ncase 16:\r\nchannels = AD193X_16_CHANNELS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(ad193x->regmap, AD193X_DAC_CTRL1,\r\nAD193X_DAC_CHAN_MASK, channels << AD193X_DAC_CHAN_SHFT);\r\nregmap_update_bits(ad193x->regmap, AD193X_ADC_CTRL2,\r\nAD193X_ADC_CHAN_MASK, channels << AD193X_ADC_CHAN_SHFT);\r\nreturn 0;\r\n}\r\nstatic int ad193x_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct ad193x_priv *ad193x = snd_soc_codec_get_drvdata(codec_dai->codec);\r\nunsigned int adc_serfmt = 0;\r\nunsigned int adc_fmt = 0;\r\nunsigned int dac_fmt = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nadc_serfmt |= AD193X_ADC_SERFMT_TDM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nadc_serfmt |= AD193X_ADC_SERFMT_AUX;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nadc_fmt |= AD193X_ADC_LEFT_HIGH;\r\ndac_fmt |= AD193X_DAC_LEFT_HIGH;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nadc_fmt |= AD193X_ADC_BCLK_INV;\r\ndac_fmt |= AD193X_DAC_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nadc_fmt |= AD193X_ADC_LEFT_HIGH;\r\nadc_fmt |= AD193X_ADC_BCLK_INV;\r\ndac_fmt |= AD193X_DAC_LEFT_HIGH;\r\ndac_fmt |= AD193X_DAC_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nadc_fmt |= AD193X_ADC_LCR_MASTER;\r\nadc_fmt |= AD193X_ADC_BCLK_MASTER;\r\ndac_fmt |= AD193X_DAC_LCR_MASTER;\r\ndac_fmt |= AD193X_DAC_BCLK_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nadc_fmt |= AD193X_ADC_LCR_MASTER;\r\ndac_fmt |= AD193X_DAC_LCR_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nadc_fmt |= AD193X_ADC_BCLK_MASTER;\r\ndac_fmt |= AD193X_DAC_BCLK_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(ad193x->regmap, AD193X_ADC_CTRL1,\r\nAD193X_ADC_SERFMT_MASK, adc_serfmt);\r\nregmap_update_bits(ad193x->regmap, AD193X_ADC_CTRL2,\r\nAD193X_ADC_FMT_MASK, adc_fmt);\r\nregmap_update_bits(ad193x->regmap, AD193X_DAC_CTRL1,\r\nAD193X_DAC_FMT_MASK, dac_fmt);\r\nreturn 0;\r\n}\r\nstatic int ad193x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct ad193x_priv *ad193x = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase 12288000:\r\ncase 18432000:\r\ncase 24576000:\r\ncase 36864000:\r\nad193x->sysclk = freq;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad193x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint word_len = 0, master_rate = 0;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ad193x_priv *ad193x = snd_soc_codec_get_drvdata(codec);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nword_len = 3;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nword_len = 1;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nword_len = 0;\r\nbreak;\r\n}\r\nswitch (ad193x->sysclk) {\r\ncase 12288000:\r\nmaster_rate = AD193X_PLL_INPUT_256;\r\nbreak;\r\ncase 18432000:\r\nmaster_rate = AD193X_PLL_INPUT_384;\r\nbreak;\r\ncase 24576000:\r\nmaster_rate = AD193X_PLL_INPUT_512;\r\nbreak;\r\ncase 36864000:\r\nmaster_rate = AD193X_PLL_INPUT_768;\r\nbreak;\r\n}\r\nregmap_update_bits(ad193x->regmap, AD193X_PLL_CLK_CTRL0,\r\nAD193X_PLL_INPUT_MASK, master_rate);\r\nregmap_update_bits(ad193x->regmap, AD193X_DAC_CTRL2,\r\nAD193X_DAC_WORD_LEN_MASK,\r\nword_len << AD193X_DAC_WORD_LEN_SHFT);\r\nregmap_update_bits(ad193x->regmap, AD193X_ADC_CTRL1,\r\nAD193X_ADC_WORD_LEN_MASK, word_len);\r\nreturn 0;\r\n}\r\nstatic int ad193x_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ad193x_priv *ad193x = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncodec->control_data = ad193x->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 0, 0, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_write(ad193x->regmap, AD193X_DAC_CHNL_MUTE, 0x0);\r\nregmap_write(ad193x->regmap, AD193X_DAC_CTRL2, 0x1A);\r\nregmap_write(ad193x->regmap, AD193X_DAC_CTRL0, 0x41);\r\nregmap_write(ad193x->regmap, AD193X_ADC_CTRL0, 0x3);\r\nregmap_write(ad193x->regmap, AD193X_ADC_CTRL1, 0x43);\r\nregmap_write(ad193x->regmap, AD193X_PLL_CLK_CTRL0, 0x99);\r\nregmap_write(ad193x->regmap, AD193X_PLL_CLK_CTRL1, 0x04);\r\nreturn ret;\r\n}\r\nstatic bool adau193x_reg_volatile(struct device *dev, unsigned int reg)\r\n{\r\nreturn false;\r\n}\r\nstatic int __devinit ad193x_spi_probe(struct spi_device *spi)\r\n{\r\nstruct ad193x_priv *ad193x;\r\nint ret;\r\nad193x = devm_kzalloc(&spi->dev, sizeof(struct ad193x_priv),\r\nGFP_KERNEL);\r\nif (ad193x == NULL)\r\nreturn -ENOMEM;\r\nad193x->regmap = regmap_init_spi(spi, &ad193x_spi_regmap_config);\r\nif (IS_ERR(ad193x->regmap)) {\r\nret = PTR_ERR(ad193x->regmap);\r\ngoto err_out;\r\n}\r\nspi_set_drvdata(spi, ad193x);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_ad193x, &ad193x_dai, 1);\r\nif (ret < 0)\r\ngoto err_regmap_exit;\r\nreturn 0;\r\nerr_regmap_exit:\r\nregmap_exit(ad193x->regmap);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int __devexit ad193x_spi_remove(struct spi_device *spi)\r\n{\r\nstruct ad193x_priv *ad193x = spi_get_drvdata(spi);\r\nsnd_soc_unregister_codec(&spi->dev);\r\nregmap_exit(ad193x->regmap);\r\nreturn 0;\r\n}\r\nstatic int __devinit ad193x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ad193x_priv *ad193x;\r\nint ret;\r\nad193x = devm_kzalloc(&client->dev, sizeof(struct ad193x_priv),\r\nGFP_KERNEL);\r\nif (ad193x == NULL)\r\nreturn -ENOMEM;\r\nad193x->regmap = regmap_init_i2c(client, &ad193x_i2c_regmap_config);\r\nif (IS_ERR(ad193x->regmap)) {\r\nret = PTR_ERR(ad193x->regmap);\r\ngoto err_out;\r\n}\r\ni2c_set_clientdata(client, ad193x);\r\nret = snd_soc_register_codec(&client->dev,\r\n&soc_codec_dev_ad193x, &ad193x_dai, 1);\r\nif (ret < 0)\r\ngoto err_regmap_exit;\r\nreturn 0;\r\nerr_regmap_exit:\r\nregmap_exit(ad193x->regmap);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int __devexit ad193x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct ad193x_priv *ad193x = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nregmap_exit(ad193x->regmap);\r\nreturn 0;\r\n}\r\nstatic int __init ad193x_modinit(void)\r\n{\r\nint ret;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&ad193x_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register AD193X I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&ad193x_spi_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register AD193X SPI driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit ad193x_modexit(void)\r\n{\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&ad193x_spi_driver);\r\n#endif\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&ad193x_i2c_driver);\r\n#endif\r\n}
