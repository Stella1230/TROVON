static int sis_fetch_size(void)\r\n{\r\nu8 temp_size;\r\nint i;\r\nstruct aper_size_info_8 *values;\r\npci_read_config_byte(agp_bridge->dev, SIS_APSIZE, &temp_size);\r\nvalues = A_SIZE_8(agp_bridge->driver->aperture_sizes);\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif ((temp_size == values[i].size_value) ||\r\n((temp_size & ~(0x07)) ==\r\n(values[i].size_value & ~(0x07)))) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sis_tlbflush(struct agp_memory *mem)\r\n{\r\npci_write_config_byte(agp_bridge->dev, SIS_TLBFLUSH, 0x02);\r\n}\r\nstatic int sis_configure(void)\r\n{\r\nu32 temp;\r\nstruct aper_size_info_8 *current_size;\r\ncurrent_size = A_SIZE_8(agp_bridge->current_size);\r\npci_write_config_byte(agp_bridge->dev, SIS_TLBCNTRL, 0x05);\r\npci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);\r\nagp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\npci_write_config_dword(agp_bridge->dev, SIS_ATTBASE,\r\nagp_bridge->gatt_bus_addr);\r\npci_write_config_byte(agp_bridge->dev, SIS_APSIZE,\r\ncurrent_size->size_value);\r\nreturn 0;\r\n}\r\nstatic void sis_cleanup(void)\r\n{\r\nstruct aper_size_info_8 *previous_size;\r\nprevious_size = A_SIZE_8(agp_bridge->previous_size);\r\npci_write_config_byte(agp_bridge->dev, SIS_APSIZE,\r\n(previous_size->size_value & ~(0x03)));\r\n}\r\nstatic void sis_delayed_enable(struct agp_bridge_data *bridge, u32 mode)\r\n{\r\nstruct pci_dev *device = NULL;\r\nu32 command;\r\nint rate;\r\ndev_info(&agp_bridge->dev->dev, "AGP %d.%d bridge\n",\r\nagp_bridge->major_version, agp_bridge->minor_version);\r\npci_read_config_dword(agp_bridge->dev, agp_bridge->capndx + PCI_AGP_STATUS, &command);\r\ncommand = agp_collect_device_status(bridge, mode, command);\r\ncommand |= AGPSTAT_AGP_ENABLE;\r\nrate = (command & 0x7) << 2;\r\nfor_each_pci_dev(device) {\r\nu8 agp = pci_find_capability(device, PCI_CAP_ID_AGP);\r\nif (!agp)\r\ncontinue;\r\ndev_info(&agp_bridge->dev->dev, "putting AGP V3 device at %s into %dx mode\n",\r\npci_name(device), rate);\r\npci_write_config_dword(device, agp + PCI_AGP_COMMAND, command);\r\nif (device->device == bridge->dev->device) {\r\ndev_info(&agp_bridge->dev->dev, "SiS delay workaround: giving bridge time to recover\n");\r\nmsleep(10);\r\n}\r\n}\r\n}\r\nstatic void __devinit sis_get_driver(struct agp_bridge_data *bridge)\r\n{\r\nint i;\r\nfor (i=0; sis_broken_chipsets[i]!=0; ++i)\r\nif (bridge->dev->device==sis_broken_chipsets[i])\r\nbreak;\r\nif (sis_broken_chipsets[i] || agp_sis_force_delay)\r\nsis_driver.agp_enable=sis_delayed_enable;\r\nif ((agp_bridge->major_version == 3 && agp_bridge->minor_version >= 5\r\n&& agp_sis_agp_spec!=0) || agp_sis_agp_spec==1) {\r\nsis_driver.aperture_sizes = agp3_generic_sizes;\r\nsis_driver.size_type = U16_APER_SIZE;\r\nsis_driver.num_aperture_sizes = AGP_GENERIC_SIZES_ENTRIES;\r\nsis_driver.configure = agp3_generic_configure;\r\nsis_driver.fetch_size = agp3_generic_fetch_size;\r\nsis_driver.cleanup = agp3_generic_cleanup;\r\nsis_driver.tlb_flush = agp3_generic_tlbflush;\r\n}\r\n}\r\nstatic int __devinit agp_sis_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nu8 cap_ptr;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\ndev_info(&pdev->dev, "SiS chipset [%04x/%04x]\n",\r\npdev->vendor, pdev->device);\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->driver = &sis_driver;\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\nget_agp_version(bridge);\r\npci_read_config_dword(pdev, bridge->capndx+PCI_AGP_STATUS, &bridge->mode);\r\nsis_get_driver(bridge);\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void __devexit agp_sis_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int agp_sis_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int agp_sis_resume(struct pci_dev *pdev)\r\n{\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nreturn sis_driver.configure();\r\n}\r\nstatic int __init agp_sis_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_sis_pci_driver);\r\n}\r\nstatic void __exit agp_sis_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_sis_pci_driver);\r\n}
