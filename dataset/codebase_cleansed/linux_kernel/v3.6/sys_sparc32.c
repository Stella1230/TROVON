asmlinkage long compat_sys_ipc(u32 call, u32 first, u32 second, u32 third, compat_uptr_t ptr, u32 fifth)\r\n{\r\nint version;\r\nversion = call >> 16;\r\ncall &= 0xffff;\r\nswitch (call) {\r\ncase SEMTIMEDOP:\r\nif (fifth)\r\nreturn compat_sys_semtimedop((int)first,\r\ncompat_ptr(ptr), second,\r\ncompat_ptr(fifth));\r\ncase SEMOP:\r\nreturn sys_semtimedop((int)first, compat_ptr(ptr), second,\r\nNULL);\r\ncase SEMGET:\r\nreturn sys_semget((int)first, (int)second, third);\r\ncase SEMCTL:\r\nreturn compat_sys_semctl((int)first, (int)second, third,\r\ncompat_ptr(ptr));\r\ncase MSGSND:\r\nreturn compat_sys_msgsnd((int)first, (int)second, third,\r\ncompat_ptr(ptr));\r\ncase MSGRCV:\r\nreturn compat_sys_msgrcv((int)first, second, (int)fifth,\r\nthird, version, compat_ptr(ptr));\r\ncase MSGGET:\r\nreturn sys_msgget((int)first, second);\r\ncase MSGCTL:\r\nreturn compat_sys_msgctl((int)first, second, compat_ptr(ptr));\r\ncase SHMAT:\r\nreturn compat_sys_shmat((int)first, second, third, version,\r\ncompat_ptr(ptr));\r\ncase SHMDT:\r\nreturn sys_shmdt(compat_ptr(ptr));\r\ncase SHMGET:\r\nreturn sys_shmget((int)first, second, third);\r\ncase SHMCTL:\r\nreturn compat_sys_shmctl((int)first, second, compat_ptr(ptr));\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nasmlinkage long sys32_truncate64(const char __user * path, unsigned long high, unsigned long low)\r\n{\r\nif ((int)high < 0)\r\nreturn -EINVAL;\r\nelse\r\nreturn sys_truncate(path, (high << 32) | low);\r\n}\r\nasmlinkage long sys32_ftruncate64(unsigned int fd, unsigned long high, unsigned long low)\r\n{\r\nif ((int)high < 0)\r\nreturn -EINVAL;\r\nelse\r\nreturn sys_ftruncate(fd, (high << 32) | low);\r\n}\r\nstatic int cp_compat_stat64(struct kstat *stat,\r\nstruct compat_stat64 __user *statbuf)\r\n{\r\nint err;\r\nerr = put_user(huge_encode_dev(stat->dev), &statbuf->st_dev);\r\nerr |= put_user(stat->ino, &statbuf->st_ino);\r\nerr |= put_user(stat->mode, &statbuf->st_mode);\r\nerr |= put_user(stat->nlink, &statbuf->st_nlink);\r\nerr |= put_user(from_kuid_munged(current_user_ns(), stat->uid), &statbuf->st_uid);\r\nerr |= put_user(from_kgid_munged(current_user_ns(), stat->gid), &statbuf->st_gid);\r\nerr |= put_user(huge_encode_dev(stat->rdev), &statbuf->st_rdev);\r\nerr |= put_user(0, (unsigned long __user *) &statbuf->__pad3[0]);\r\nerr |= put_user(stat->size, &statbuf->st_size);\r\nerr |= put_user(stat->blksize, &statbuf->st_blksize);\r\nerr |= put_user(0, (unsigned int __user *) &statbuf->__pad4[0]);\r\nerr |= put_user(0, (unsigned int __user *) &statbuf->__pad4[4]);\r\nerr |= put_user(stat->blocks, &statbuf->st_blocks);\r\nerr |= put_user(stat->atime.tv_sec, &statbuf->st_atime);\r\nerr |= put_user(stat->atime.tv_nsec, &statbuf->st_atime_nsec);\r\nerr |= put_user(stat->mtime.tv_sec, &statbuf->st_mtime);\r\nerr |= put_user(stat->mtime.tv_nsec, &statbuf->st_mtime_nsec);\r\nerr |= put_user(stat->ctime.tv_sec, &statbuf->st_ctime);\r\nerr |= put_user(stat->ctime.tv_nsec, &statbuf->st_ctime_nsec);\r\nerr |= put_user(0, &statbuf->__unused4);\r\nerr |= put_user(0, &statbuf->__unused5);\r\nreturn err;\r\n}\r\nasmlinkage long compat_sys_stat64(const char __user * filename,\r\nstruct compat_stat64 __user *statbuf)\r\n{\r\nstruct kstat stat;\r\nint error = vfs_stat(filename, &stat);\r\nif (!error)\r\nerror = cp_compat_stat64(&stat, statbuf);\r\nreturn error;\r\n}\r\nasmlinkage long compat_sys_lstat64(const char __user * filename,\r\nstruct compat_stat64 __user *statbuf)\r\n{\r\nstruct kstat stat;\r\nint error = vfs_lstat(filename, &stat);\r\nif (!error)\r\nerror = cp_compat_stat64(&stat, statbuf);\r\nreturn error;\r\n}\r\nasmlinkage long compat_sys_fstat64(unsigned int fd,\r\nstruct compat_stat64 __user * statbuf)\r\n{\r\nstruct kstat stat;\r\nint error = vfs_fstat(fd, &stat);\r\nif (!error)\r\nerror = cp_compat_stat64(&stat, statbuf);\r\nreturn error;\r\n}\r\nasmlinkage long compat_sys_fstatat64(unsigned int dfd,\r\nconst char __user *filename,\r\nstruct compat_stat64 __user * statbuf, int flag)\r\n{\r\nstruct kstat stat;\r\nint error;\r\nerror = vfs_fstatat(dfd, filename, &stat, flag);\r\nif (error)\r\nreturn error;\r\nreturn cp_compat_stat64(&stat, statbuf);\r\n}\r\nasmlinkage long compat_sys_sysfs(int option, u32 arg1, u32 arg2)\r\n{\r\nreturn sys_sysfs(option, arg1, arg2);\r\n}\r\nasmlinkage long compat_sys_sched_rr_get_interval(compat_pid_t pid, struct compat_timespec __user *interval)\r\n{\r\nstruct timespec t;\r\nint ret;\r\nmm_segment_t old_fs = get_fs ();\r\nset_fs (KERNEL_DS);\r\nret = sys_sched_rr_get_interval(pid, (struct timespec __user *) &t);\r\nset_fs (old_fs);\r\nif (put_compat_timespec(&t, interval))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nasmlinkage long compat_sys_rt_sigprocmask(int how,\r\ncompat_sigset_t __user *set,\r\ncompat_sigset_t __user *oset,\r\ncompat_size_t sigsetsize)\r\n{\r\nsigset_t s;\r\ncompat_sigset_t s32;\r\nint ret;\r\nmm_segment_t old_fs = get_fs();\r\nif (set) {\r\nif (copy_from_user (&s32, set, sizeof(compat_sigset_t)))\r\nreturn -EFAULT;\r\nswitch (_NSIG_WORDS) {\r\ncase 4: s.sig[3] = s32.sig[6] | (((long)s32.sig[7]) << 32);\r\ncase 3: s.sig[2] = s32.sig[4] | (((long)s32.sig[5]) << 32);\r\ncase 2: s.sig[1] = s32.sig[2] | (((long)s32.sig[3]) << 32);\r\ncase 1: s.sig[0] = s32.sig[0] | (((long)s32.sig[1]) << 32);\r\n}\r\n}\r\nset_fs (KERNEL_DS);\r\nret = sys_rt_sigprocmask(how,\r\nset ? (sigset_t __user *) &s : NULL,\r\noset ? (sigset_t __user *) &s : NULL,\r\nsigsetsize);\r\nset_fs (old_fs);\r\nif (ret) return ret;\r\nif (oset) {\r\nswitch (_NSIG_WORDS) {\r\ncase 4: s32.sig[7] = (s.sig[3] >> 32); s32.sig[6] = s.sig[3];\r\ncase 3: s32.sig[5] = (s.sig[2] >> 32); s32.sig[4] = s.sig[2];\r\ncase 2: s32.sig[3] = (s.sig[1] >> 32); s32.sig[2] = s.sig[1];\r\ncase 1: s32.sig[1] = (s.sig[0] >> 32); s32.sig[0] = s.sig[0];\r\n}\r\nif (copy_to_user (oset, &s32, sizeof(compat_sigset_t)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nasmlinkage long sys32_rt_sigpending(compat_sigset_t __user *set,\r\ncompat_size_t sigsetsize)\r\n{\r\nsigset_t s;\r\ncompat_sigset_t s32;\r\nint ret;\r\nmm_segment_t old_fs = get_fs();\r\nset_fs (KERNEL_DS);\r\nret = sys_rt_sigpending((sigset_t __user *) &s, sigsetsize);\r\nset_fs (old_fs);\r\nif (!ret) {\r\nswitch (_NSIG_WORDS) {\r\ncase 4: s32.sig[7] = (s.sig[3] >> 32); s32.sig[6] = s.sig[3];\r\ncase 3: s32.sig[5] = (s.sig[2] >> 32); s32.sig[4] = s.sig[2];\r\ncase 2: s32.sig[3] = (s.sig[1] >> 32); s32.sig[2] = s.sig[1];\r\ncase 1: s32.sig[1] = (s.sig[0] >> 32); s32.sig[0] = s.sig[0];\r\n}\r\nif (copy_to_user (set, &s32, sizeof(compat_sigset_t)))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long compat_sys_rt_sigqueueinfo(int pid, int sig,\r\nstruct compat_siginfo __user *uinfo)\r\n{\r\nsiginfo_t info;\r\nint ret;\r\nmm_segment_t old_fs = get_fs();\r\nif (copy_siginfo_from_user32(&info, uinfo))\r\nreturn -EFAULT;\r\nset_fs (KERNEL_DS);\r\nret = sys_rt_sigqueueinfo(pid, sig, (siginfo_t __user *) &info);\r\nset_fs (old_fs);\r\nreturn ret;\r\n}\r\nasmlinkage long compat_sys_sigaction(int sig, struct old_sigaction32 __user *act,\r\nstruct old_sigaction32 __user *oact)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\nWARN_ON_ONCE(sig >= 0);\r\nsig = -sig;\r\nif (act) {\r\ncompat_old_sigset_t mask;\r\nu32 u_handler, u_restorer;\r\nret = get_user(u_handler, &act->sa_handler);\r\nnew_ka.sa.sa_handler = compat_ptr(u_handler);\r\nret |= __get_user(u_restorer, &act->sa_restorer);\r\nnew_ka.sa.sa_restorer = compat_ptr(u_restorer);\r\nret |= __get_user(new_ka.sa.sa_flags, &act->sa_flags);\r\nret |= __get_user(mask, &act->sa_mask);\r\nif (ret)\r\nreturn ret;\r\nnew_ka.ka_restorer = NULL;\r\nsiginitset(&new_ka.sa.sa_mask, mask);\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nret = put_user(ptr_to_compat(old_ka.sa.sa_handler), &oact->sa_handler);\r\nret |= __put_user(ptr_to_compat(old_ka.sa.sa_restorer), &oact->sa_restorer);\r\nret |= __put_user(old_ka.sa.sa_flags, &oact->sa_flags);\r\nret |= __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long compat_sys_rt_sigaction(int sig,\r\nstruct sigaction32 __user *act,\r\nstruct sigaction32 __user *oact,\r\nvoid __user *restorer,\r\ncompat_size_t sigsetsize)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\ncompat_sigset_t set32;\r\nif (sigsetsize != sizeof(compat_sigset_t))\r\nreturn -EINVAL;\r\nif (act) {\r\nu32 u_handler, u_restorer;\r\nnew_ka.ka_restorer = restorer;\r\nret = get_user(u_handler, &act->sa_handler);\r\nnew_ka.sa.sa_handler = compat_ptr(u_handler);\r\nret |= __copy_from_user(&set32, &act->sa_mask, sizeof(compat_sigset_t));\r\nswitch (_NSIG_WORDS) {\r\ncase 4: new_ka.sa.sa_mask.sig[3] = set32.sig[6] | (((long)set32.sig[7]) << 32);\r\ncase 3: new_ka.sa.sa_mask.sig[2] = set32.sig[4] | (((long)set32.sig[5]) << 32);\r\ncase 2: new_ka.sa.sa_mask.sig[1] = set32.sig[2] | (((long)set32.sig[3]) << 32);\r\ncase 1: new_ka.sa.sa_mask.sig[0] = set32.sig[0] | (((long)set32.sig[1]) << 32);\r\n}\r\nret |= __get_user(new_ka.sa.sa_flags, &act->sa_flags);\r\nret |= __get_user(u_restorer, &act->sa_restorer);\r\nnew_ka.sa.sa_restorer = compat_ptr(u_restorer);\r\nif (ret)\r\nreturn -EFAULT;\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nswitch (_NSIG_WORDS) {\r\ncase 4: set32.sig[7] = (old_ka.sa.sa_mask.sig[3] >> 32); set32.sig[6] = old_ka.sa.sa_mask.sig[3];\r\ncase 3: set32.sig[5] = (old_ka.sa.sa_mask.sig[2] >> 32); set32.sig[4] = old_ka.sa.sa_mask.sig[2];\r\ncase 2: set32.sig[3] = (old_ka.sa.sa_mask.sig[1] >> 32); set32.sig[2] = old_ka.sa.sa_mask.sig[1];\r\ncase 1: set32.sig[1] = (old_ka.sa.sa_mask.sig[0] >> 32); set32.sig[0] = old_ka.sa.sa_mask.sig[0];\r\n}\r\nret = put_user(ptr_to_compat(old_ka.sa.sa_handler), &oact->sa_handler);\r\nret |= __copy_to_user(&oact->sa_mask, &set32, sizeof(compat_sigset_t));\r\nret |= __put_user(old_ka.sa.sa_flags, &oact->sa_flags);\r\nret |= __put_user(ptr_to_compat(old_ka.sa.sa_restorer), &oact->sa_restorer);\r\nif (ret)\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long sparc32_execve(struct pt_regs *regs)\r\n{\r\nint error, base = 0;\r\nchar *filename;\r\nif ((u32)regs->u_regs[UREG_G1] == 0)\r\nbase = 1;\r\nfilename = getname(compat_ptr(regs->u_regs[base + UREG_I0]));\r\nerror = PTR_ERR(filename);\r\nif (IS_ERR(filename))\r\ngoto out;\r\nerror = compat_do_execve(filename,\r\ncompat_ptr(regs->u_regs[base + UREG_I1]),\r\ncompat_ptr(regs->u_regs[base + UREG_I2]), regs);\r\nputname(filename);\r\nif (!error) {\r\nfprs_write(0);\r\ncurrent_thread_info()->xfsr[0] = 0;\r\ncurrent_thread_info()->fpsaved[0] = 0;\r\nregs->tstate &= ~TSTATE_PEF;\r\n}\r\nout:\r\nreturn error;\r\n}\r\nasmlinkage long sys32_init_module(void __user *umod, u32 len,\r\nconst char __user *uargs)\r\n{\r\nreturn sys_init_module(umod, len, uargs);\r\n}\r\nasmlinkage long sys32_delete_module(const char __user *name_user,\r\nunsigned int flags)\r\n{\r\nreturn sys_delete_module(name_user, flags);\r\n}\r\nasmlinkage long sys32_init_module(const char __user *name_user,\r\nstruct module __user *mod_user)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nasmlinkage long sys32_delete_module(const char __user *name_user)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nasmlinkage compat_ssize_t sys32_pread64(unsigned int fd,\r\nchar __user *ubuf,\r\ncompat_size_t count,\r\nunsigned long poshi,\r\nunsigned long poslo)\r\n{\r\nreturn sys_pread64(fd, ubuf, count, (poshi << 32) | poslo);\r\n}\r\nasmlinkage compat_ssize_t sys32_pwrite64(unsigned int fd,\r\nchar __user *ubuf,\r\ncompat_size_t count,\r\nunsigned long poshi,\r\nunsigned long poslo)\r\n{\r\nreturn sys_pwrite64(fd, ubuf, count, (poshi << 32) | poslo);\r\n}\r\nasmlinkage long compat_sys_readahead(int fd,\r\nunsigned long offhi,\r\nunsigned long offlo,\r\ncompat_size_t count)\r\n{\r\nreturn sys_readahead(fd, (offhi << 32) | offlo, count);\r\n}\r\nlong compat_sys_fadvise64(int fd,\r\nunsigned long offhi,\r\nunsigned long offlo,\r\ncompat_size_t len, int advice)\r\n{\r\nreturn sys_fadvise64_64(fd, (offhi << 32) | offlo, len, advice);\r\n}\r\nlong compat_sys_fadvise64_64(int fd,\r\nunsigned long offhi, unsigned long offlo,\r\nunsigned long lenhi, unsigned long lenlo,\r\nint advice)\r\n{\r\nreturn sys_fadvise64_64(fd,\r\n(offhi << 32) | offlo,\r\n(lenhi << 32) | lenlo,\r\nadvice);\r\n}\r\nasmlinkage long compat_sys_sendfile(int out_fd, int in_fd,\r\ncompat_off_t __user *offset,\r\ncompat_size_t count)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nint ret;\r\noff_t of;\r\nif (offset && get_user(of, offset))\r\nreturn -EFAULT;\r\nset_fs(KERNEL_DS);\r\nret = sys_sendfile(out_fd, in_fd,\r\noffset ? (off_t __user *) &of : NULL,\r\ncount);\r\nset_fs(old_fs);\r\nif (offset && put_user(of, offset))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nasmlinkage long compat_sys_sendfile64(int out_fd, int in_fd,\r\ncompat_loff_t __user *offset,\r\ncompat_size_t count)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nint ret;\r\nloff_t lof;\r\nif (offset && get_user(lof, offset))\r\nreturn -EFAULT;\r\nset_fs(KERNEL_DS);\r\nret = sys_sendfile64(out_fd, in_fd,\r\noffset ? (loff_t __user *) &lof : NULL,\r\ncount);\r\nset_fs(old_fs);\r\nif (offset && put_user(lof, offset))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nasmlinkage long sparc32_open(const char __user *filename,\r\nint flags, int mode)\r\n{\r\nreturn do_sys_open(AT_FDCWD, filename, flags, mode);\r\n}\r\nlong sys32_lookup_dcookie(unsigned long cookie_high,\r\nunsigned long cookie_low,\r\nchar __user *buf, size_t len)\r\n{\r\nreturn sys_lookup_dcookie((cookie_high << 32) | cookie_low,\r\nbuf, len);\r\n}\r\nlong compat_sync_file_range(int fd, unsigned long off_high, unsigned long off_low, unsigned long nb_high, unsigned long nb_low, int flags)\r\n{\r\nreturn sys_sync_file_range(fd,\r\n(off_high << 32) | off_low,\r\n(nb_high << 32) | nb_low,\r\nflags);\r\n}\r\nasmlinkage long compat_sys_fallocate(int fd, int mode, u32 offhi, u32 offlo,\r\nu32 lenhi, u32 lenlo)\r\n{\r\nreturn sys_fallocate(fd, mode, ((loff_t)offhi << 32) | offlo,\r\n((loff_t)lenhi << 32) | lenlo);\r\n}
