static int __used __init register_ip_vs_protocol(struct ip_vs_protocol *pp)\r\n{\r\nunsigned int hash = IP_VS_PROTO_HASH(pp->protocol);\r\npp->next = ip_vs_proto_table[hash];\r\nip_vs_proto_table[hash] = pp;\r\nif (pp->init != NULL)\r\npp->init(pp);\r\nreturn 0;\r\n}\r\nstatic int\r\nregister_ip_vs_proto_netns(struct net *net, struct ip_vs_protocol *pp)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nunsigned int hash = IP_VS_PROTO_HASH(pp->protocol);\r\nstruct ip_vs_proto_data *pd =\r\nkzalloc(sizeof(struct ip_vs_proto_data), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\npd->pp = pp;\r\npd->next = ipvs->proto_data_table[hash];\r\nipvs->proto_data_table[hash] = pd;\r\natomic_set(&pd->appcnt, 0);\r\nif (pp->init_netns != NULL) {\r\nint ret = pp->init_netns(net, pd);\r\nif (ret) {\r\nipvs->proto_data_table[hash] = pd->next;\r\nkfree(pd);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int unregister_ip_vs_protocol(struct ip_vs_protocol *pp)\r\n{\r\nstruct ip_vs_protocol **pp_p;\r\nunsigned int hash = IP_VS_PROTO_HASH(pp->protocol);\r\npp_p = &ip_vs_proto_table[hash];\r\nfor (; *pp_p; pp_p = &(*pp_p)->next) {\r\nif (*pp_p == pp) {\r\n*pp_p = pp->next;\r\nif (pp->exit != NULL)\r\npp->exit(pp);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ESRCH;\r\n}\r\nstatic int\r\nunregister_ip_vs_proto_netns(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_proto_data **pd_p;\r\nunsigned int hash = IP_VS_PROTO_HASH(pd->pp->protocol);\r\npd_p = &ipvs->proto_data_table[hash];\r\nfor (; *pd_p; pd_p = &(*pd_p)->next) {\r\nif (*pd_p == pd) {\r\n*pd_p = pd->next;\r\nif (pd->pp->exit_netns != NULL)\r\npd->pp->exit_netns(net, pd);\r\nkfree(pd);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ESRCH;\r\n}\r\nstruct ip_vs_protocol * ip_vs_proto_get(unsigned short proto)\r\n{\r\nstruct ip_vs_protocol *pp;\r\nunsigned int hash = IP_VS_PROTO_HASH(proto);\r\nfor (pp = ip_vs_proto_table[hash]; pp; pp = pp->next) {\r\nif (pp->protocol == proto)\r\nreturn pp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ip_vs_proto_data *\r\n__ipvs_proto_data_get(struct netns_ipvs *ipvs, unsigned short proto)\r\n{\r\nstruct ip_vs_proto_data *pd;\r\nunsigned int hash = IP_VS_PROTO_HASH(proto);\r\nfor (pd = ipvs->proto_data_table[hash]; pd; pd = pd->next) {\r\nif (pd->pp->protocol == proto)\r\nreturn pd;\r\n}\r\nreturn NULL;\r\n}\r\nstruct ip_vs_proto_data *\r\nip_vs_proto_data_get(struct net *net, unsigned short proto)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nreturn __ipvs_proto_data_get(ipvs, proto);\r\n}\r\nvoid ip_vs_protocol_timeout_change(struct netns_ipvs *ipvs, int flags)\r\n{\r\nstruct ip_vs_proto_data *pd;\r\nint i;\r\nfor (i = 0; i < IP_VS_PROTO_TAB_SIZE; i++) {\r\nfor (pd = ipvs->proto_data_table[i]; pd; pd = pd->next) {\r\nif (pd->pp->timeout_change)\r\npd->pp->timeout_change(pd, flags);\r\n}\r\n}\r\n}\r\nint *\r\nip_vs_create_timeout_table(int *table, int size)\r\n{\r\nreturn kmemdup(table, size, GFP_KERNEL);\r\n}\r\nint\r\nip_vs_set_state_timeout(int *table, int num, const char *const *names,\r\nconst char *name, int to)\r\n{\r\nint i;\r\nif (!table || !name || !to)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num; i++) {\r\nif (strcmp(names[i], name))\r\ncontinue;\r\ntable[i] = to * HZ;\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nconst char * ip_vs_state_name(__u16 proto, int state)\r\n{\r\nstruct ip_vs_protocol *pp = ip_vs_proto_get(proto);\r\nif (pp == NULL || pp->state_name == NULL)\r\nreturn (IPPROTO_IP == proto) ? "NONE" : "ERR!";\r\nreturn pp->state_name(state);\r\n}\r\nstatic void\r\nip_vs_tcpudp_debug_packet_v4(struct ip_vs_protocol *pp,\r\nconst struct sk_buff *skb,\r\nint offset,\r\nconst char *msg)\r\n{\r\nchar buf[128];\r\nstruct iphdr _iph, *ih;\r\nih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph);\r\nif (ih == NULL)\r\nsprintf(buf, "TRUNCATED");\r\nelse if (ih->frag_off & htons(IP_OFFSET))\r\nsprintf(buf, "%pI4->%pI4 frag", &ih->saddr, &ih->daddr);\r\nelse {\r\n__be16 _ports[2], *pptr;\r\npptr = skb_header_pointer(skb, offset + ih->ihl*4,\r\nsizeof(_ports), _ports);\r\nif (pptr == NULL)\r\nsprintf(buf, "TRUNCATED %pI4->%pI4",\r\n&ih->saddr, &ih->daddr);\r\nelse\r\nsprintf(buf, "%pI4:%u->%pI4:%u",\r\n&ih->saddr, ntohs(pptr[0]),\r\n&ih->daddr, ntohs(pptr[1]));\r\n}\r\npr_debug("%s: %s %s\n", msg, pp->name, buf);\r\n}\r\nstatic void\r\nip_vs_tcpudp_debug_packet_v6(struct ip_vs_protocol *pp,\r\nconst struct sk_buff *skb,\r\nint offset,\r\nconst char *msg)\r\n{\r\nchar buf[192];\r\nstruct ipv6hdr _iph, *ih;\r\nih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph);\r\nif (ih == NULL)\r\nsprintf(buf, "TRUNCATED");\r\nelse if (ih->nexthdr == IPPROTO_FRAGMENT)\r\nsprintf(buf, "%pI6->%pI6 frag", &ih->saddr, &ih->daddr);\r\nelse {\r\n__be16 _ports[2], *pptr;\r\npptr = skb_header_pointer(skb, offset + sizeof(struct ipv6hdr),\r\nsizeof(_ports), _ports);\r\nif (pptr == NULL)\r\nsprintf(buf, "TRUNCATED %pI6->%pI6",\r\n&ih->saddr, &ih->daddr);\r\nelse\r\nsprintf(buf, "%pI6:%u->%pI6:%u",\r\n&ih->saddr, ntohs(pptr[0]),\r\n&ih->daddr, ntohs(pptr[1]));\r\n}\r\npr_debug("%s: %s %s\n", msg, pp->name, buf);\r\n}\r\nvoid\r\nip_vs_tcpudp_debug_packet(int af, struct ip_vs_protocol *pp,\r\nconst struct sk_buff *skb,\r\nint offset,\r\nconst char *msg)\r\n{\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nip_vs_tcpudp_debug_packet_v6(pp, skb, offset, msg);\r\nelse\r\n#endif\r\nip_vs_tcpudp_debug_packet_v4(pp, skb, offset, msg);\r\n}\r\nint __net_init ip_vs_protocol_net_init(struct net *net)\r\n{\r\nint i, ret;\r\nstatic struct ip_vs_protocol *protos[] = {\r\n#ifdef CONFIG_IP_VS_PROTO_TCP\r\n&ip_vs_protocol_tcp,\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_UDP\r\n&ip_vs_protocol_udp,\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_SCTP\r\n&ip_vs_protocol_sctp,\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_AH\r\n&ip_vs_protocol_ah,\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_ESP\r\n&ip_vs_protocol_esp,\r\n#endif\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(protos); i++) {\r\nret = register_ip_vs_proto_netns(net, protos[i]);\r\nif (ret < 0)\r\ngoto cleanup;\r\n}\r\nreturn 0;\r\ncleanup:\r\nip_vs_protocol_net_cleanup(net);\r\nreturn ret;\r\n}\r\nvoid __net_exit ip_vs_protocol_net_cleanup(struct net *net)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_proto_data *pd;\r\nint i;\r\nfor (i = 0; i < IP_VS_PROTO_TAB_SIZE; i++) {\r\nwhile ((pd = ipvs->proto_data_table[i]) != NULL)\r\nunregister_ip_vs_proto_netns(net, pd);\r\n}\r\n}\r\nint __init ip_vs_protocol_init(void)\r\n{\r\nchar protocols[64];\r\n#define REGISTER_PROTOCOL(p) \\r\ndo { \\r\nregister_ip_vs_protocol(p); \\r\nstrcat(protocols, ", "); \\r\nstrcat(protocols, (p)->name); \\r\n} while (0)\r\nprotocols[0] = '\0';\r\nprotocols[2] = '\0';\r\n#ifdef CONFIG_IP_VS_PROTO_TCP\r\nREGISTER_PROTOCOL(&ip_vs_protocol_tcp);\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_UDP\r\nREGISTER_PROTOCOL(&ip_vs_protocol_udp);\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_SCTP\r\nREGISTER_PROTOCOL(&ip_vs_protocol_sctp);\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_AH\r\nREGISTER_PROTOCOL(&ip_vs_protocol_ah);\r\n#endif\r\n#ifdef CONFIG_IP_VS_PROTO_ESP\r\nREGISTER_PROTOCOL(&ip_vs_protocol_esp);\r\n#endif\r\npr_info("Registered protocols (%s)\n", &protocols[2]);\r\nreturn 0;\r\n}\r\nvoid ip_vs_protocol_cleanup(void)\r\n{\r\nstruct ip_vs_protocol *pp;\r\nint i;\r\nfor (i = 0; i < IP_VS_PROTO_TAB_SIZE; i++) {\r\nwhile ((pp = ip_vs_proto_table[i]) != NULL)\r\nunregister_ip_vs_protocol(pp);\r\n}\r\n}
