static void\r\nauxch_fini(struct drm_device *dev, int ch)\r\n{\r\nnv_mask(dev, 0x00e4e4 + (ch * 0x50), 0x00310000, 0x00000000);\r\n}\r\nstatic int\r\nauxch_init(struct drm_device *dev, int ch)\r\n{\r\nconst u32 unksel = 1;\r\nconst u32 ureq = unksel ? 0x00100000 : 0x00200000;\r\nconst u32 urep = unksel ? 0x01000000 : 0x02000000;\r\nu32 ctrl, timeout;\r\ntimeout = 1000;\r\ndo {\r\nctrl = nv_rd32(dev, 0x00e4e4 + (ch * 0x50));\r\nudelay(1);\r\nif (!timeout--) {\r\nAUX_ERR("begin idle timeout 0x%08x", ctrl);\r\nreturn -EBUSY;\r\n}\r\n} while (ctrl & 0x03010000);\r\nnv_mask(dev, 0x00e4e4 + (ch * 0x50), 0x00300000, ureq);\r\ntimeout = 1000;\r\ndo {\r\nctrl = nv_rd32(dev, 0x00e4e4 + (ch * 0x50));\r\nudelay(1);\r\nif (!timeout--) {\r\nAUX_ERR("magic wait 0x%08x\n", ctrl);\r\nauxch_fini(dev, ch);\r\nreturn -EBUSY;\r\n}\r\n} while ((ctrl & 0x03000000) != urep);\r\nreturn 0;\r\n}\r\nstatic int\r\nauxch_tx(struct drm_device *dev, int ch, u8 type, u32 addr, u8 *data, u8 size)\r\n{\r\nu32 ctrl, stat, timeout, retries;\r\nu32 xbuf[4] = {};\r\nint ret, i;\r\nAUX_DBG("%d: 0x%08x %d\n", type, addr, size);\r\nret = auxch_init(dev, ch);\r\nif (ret)\r\ngoto out;\r\nstat = nv_rd32(dev, 0x00e4e8 + (ch * 0x50));\r\nif (!(stat & 0x10000000)) {\r\nAUX_DBG("sink not detected\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (!(type & 1)) {\r\nmemcpy(xbuf, data, size);\r\nfor (i = 0; i < 16; i += 4) {\r\nAUX_DBG("wr 0x%08x\n", xbuf[i / 4]);\r\nnv_wr32(dev, 0x00e4c0 + (ch * 0x50) + i, xbuf[i / 4]);\r\n}\r\n}\r\nctrl = nv_rd32(dev, 0x00e4e4 + (ch * 0x50));\r\nctrl &= ~0x0001f0ff;\r\nctrl |= type << 12;\r\nctrl |= size - 1;\r\nnv_wr32(dev, 0x00e4e0 + (ch * 0x50), addr);\r\nret = -EREMOTEIO;\r\nfor (retries = 0; retries < 32; retries++) {\r\nnv_wr32(dev, 0x00e4e4 + (ch * 0x50), 0x80000000 | ctrl);\r\nnv_wr32(dev, 0x00e4e4 + (ch * 0x50), 0x00000000 | ctrl);\r\nif (retries)\r\nudelay(400);\r\nnv_wr32(dev, 0x00e4e4 + (ch * 0x50), 0x00010000 | ctrl);\r\ntimeout = 1000;\r\ndo {\r\nctrl = nv_rd32(dev, 0x00e4e4 + (ch * 0x50));\r\nudelay(1);\r\nif (!timeout--) {\r\nAUX_ERR("tx req timeout 0x%08x\n", ctrl);\r\ngoto out;\r\n}\r\n} while (ctrl & 0x00010000);\r\nstat = nv_mask(dev, 0x00e4e8 + (ch * 0x50), 0, 0);\r\nif (!(stat & 0x000f0f00)) {\r\nret = 0;\r\nbreak;\r\n}\r\nAUX_DBG("%02d 0x%08x 0x%08x\n", retries, ctrl, stat);\r\n}\r\nif (type & 1) {\r\nfor (i = 0; i < 16; i += 4) {\r\nxbuf[i / 4] = nv_rd32(dev, 0x00e4d0 + (ch * 0x50) + i);\r\nAUX_DBG("rd 0x%08x\n", xbuf[i / 4]);\r\n}\r\nmemcpy(data, xbuf, size);\r\n}\r\nout:\r\nauxch_fini(dev, ch);\r\nreturn ret;\r\n}\r\nu8 *\r\nnouveau_dp_bios_data(struct drm_device *dev, struct dcb_entry *dcb, u8 **entry)\r\n{\r\nstruct bit_entry d;\r\nu8 *table;\r\nint i;\r\nif (bit_table(dev, 'd', &d)) {\r\nNV_ERROR(dev, "BIT 'd' table not found\n");\r\nreturn NULL;\r\n}\r\nif (d.version != 1) {\r\nNV_ERROR(dev, "BIT 'd' table version %d unknown\n", d.version);\r\nreturn NULL;\r\n}\r\ntable = ROMPTR(dev, d.data[0]);\r\nif (!table) {\r\nNV_ERROR(dev, "displayport table pointer invalid\n");\r\nreturn NULL;\r\n}\r\nswitch (table[0]) {\r\ncase 0x20:\r\ncase 0x21:\r\ncase 0x30:\r\ncase 0x40:\r\nbreak;\r\ndefault:\r\nNV_ERROR(dev, "displayport table 0x%02x unknown\n", table[0]);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < table[3]; i++) {\r\n*entry = ROMPTR(dev, table[table[1] + (i * table[2])]);\r\nif (*entry && bios_encoder_match(dcb, ROM32((*entry)[0])))\r\nreturn table;\r\n}\r\nNV_ERROR(dev, "displayport encoder table not found\n");\r\nreturn NULL;\r\n}\r\nstatic void\r\ndp_set_link_config(struct drm_device *dev, struct dp_state *dp)\r\n{\r\nu8 sink[2];\r\nNV_DEBUG_KMS(dev, "%d lanes at %d KB/s\n", dp->link_nr, dp->link_bw);\r\ndp->func->link_set(dev, dp->dcb, dp->crtc, dp->link_nr, dp->link_bw,\r\ndp->dpcd[2] & DP_ENHANCED_FRAME_CAP);\r\nsink[0] = dp->link_bw / 27000;\r\nsink[1] = dp->link_nr;\r\nif (dp->dpcd[2] & DP_ENHANCED_FRAME_CAP)\r\nsink[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\r\nauxch_tx(dev, dp->auxch, 8, DP_LINK_BW_SET, sink, 2);\r\n}\r\nstatic void\r\ndp_set_training_pattern(struct drm_device *dev, struct dp_state *dp, u8 pattern)\r\n{\r\nu8 sink_tp;\r\nNV_DEBUG_KMS(dev, "training pattern %d\n", pattern);\r\ndp->func->train_set(dev, dp->dcb, pattern);\r\nauxch_tx(dev, dp->auxch, 9, DP_TRAINING_PATTERN_SET, &sink_tp, 1);\r\nsink_tp &= ~DP_TRAINING_PATTERN_MASK;\r\nsink_tp |= pattern;\r\nauxch_tx(dev, dp->auxch, 8, DP_TRAINING_PATTERN_SET, &sink_tp, 1);\r\n}\r\nstatic int\r\ndp_link_train_commit(struct drm_device *dev, struct dp_state *dp)\r\n{\r\nint i;\r\nfor (i = 0; i < dp->link_nr; i++) {\r\nu8 lane = (dp->stat[4 + (i >> 1)] >> ((i & 1) * 4)) & 0xf;\r\nu8 lpre = (lane & 0x0c) >> 2;\r\nu8 lvsw = (lane & 0x03) >> 0;\r\ndp->conf[i] = (lpre << 3) | lvsw;\r\nif (lvsw == DP_TRAIN_VOLTAGE_SWING_1200)\r\ndp->conf[i] |= DP_TRAIN_MAX_SWING_REACHED;\r\nif ((lpre << 3) == DP_TRAIN_PRE_EMPHASIS_9_5)\r\ndp->conf[i] |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\r\nNV_DEBUG_KMS(dev, "config lane %d %02x\n", i, dp->conf[i]);\r\ndp->func->train_adj(dev, dp->dcb, i, lvsw, lpre);\r\n}\r\nreturn auxch_tx(dev, dp->auxch, 8, DP_TRAINING_LANE0_SET, dp->conf, 4);\r\n}\r\nstatic int\r\ndp_link_train_update(struct drm_device *dev, struct dp_state *dp, u32 delay)\r\n{\r\nint ret;\r\nudelay(delay);\r\nret = auxch_tx(dev, dp->auxch, 9, DP_LANE0_1_STATUS, dp->stat, 6);\r\nif (ret)\r\nreturn ret;\r\nNV_DEBUG_KMS(dev, "status %02x %02x %02x %02x %02x %02x\n",\r\ndp->stat[0], dp->stat[1], dp->stat[2], dp->stat[3],\r\ndp->stat[4], dp->stat[5]);\r\nreturn 0;\r\n}\r\nstatic int\r\ndp_link_train_cr(struct drm_device *dev, struct dp_state *dp)\r\n{\r\nbool cr_done = false, abort = false;\r\nint voltage = dp->conf[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\r\nint tries = 0, i;\r\ndp_set_training_pattern(dev, dp, DP_TRAINING_PATTERN_1);\r\ndo {\r\nif (dp_link_train_commit(dev, dp) ||\r\ndp_link_train_update(dev, dp, 100))\r\nbreak;\r\ncr_done = true;\r\nfor (i = 0; i < dp->link_nr; i++) {\r\nu8 lane = (dp->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;\r\nif (!(lane & DP_LANE_CR_DONE)) {\r\ncr_done = false;\r\nif (dp->conf[i] & DP_TRAIN_MAX_SWING_REACHED)\r\nabort = true;\r\nbreak;\r\n}\r\n}\r\nif ((dp->conf[0] & DP_TRAIN_VOLTAGE_SWING_MASK) != voltage) {\r\nvoltage = dp->conf[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\r\ntries = 0;\r\n}\r\n} while (!cr_done && !abort && ++tries < 5);\r\nreturn cr_done ? 0 : -1;\r\n}\r\nstatic int\r\ndp_link_train_eq(struct drm_device *dev, struct dp_state *dp)\r\n{\r\nbool eq_done, cr_done = true;\r\nint tries = 0, i;\r\ndp_set_training_pattern(dev, dp, DP_TRAINING_PATTERN_2);\r\ndo {\r\nif (dp_link_train_update(dev, dp, 400))\r\nbreak;\r\neq_done = !!(dp->stat[2] & DP_INTERLANE_ALIGN_DONE);\r\nfor (i = 0; i < dp->link_nr && eq_done; i++) {\r\nu8 lane = (dp->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;\r\nif (!(lane & DP_LANE_CR_DONE))\r\ncr_done = false;\r\nif (!(lane & DP_LANE_CHANNEL_EQ_DONE) ||\r\n!(lane & DP_LANE_SYMBOL_LOCKED))\r\neq_done = false;\r\n}\r\nif (dp_link_train_commit(dev, dp))\r\nbreak;\r\n} while (!eq_done && cr_done && ++tries <= 5);\r\nreturn eq_done ? 0 : -1;\r\n}\r\nstatic void\r\ndp_set_downspread(struct drm_device *dev, struct dp_state *dp, bool enable)\r\n{\r\nu16 script = 0x0000;\r\nu8 *entry, *table = nouveau_dp_bios_data(dev, dp->dcb, &entry);\r\nif (table) {\r\nif (table[0] >= 0x20 && table[0] <= 0x30) {\r\nif (enable) script = ROM16(entry[12]);\r\nelse script = ROM16(entry[14]);\r\n} else\r\nif (table[0] == 0x40) {\r\nif (enable) script = ROM16(entry[11]);\r\nelse script = ROM16(entry[13]);\r\n}\r\n}\r\nnouveau_bios_run_init_table(dev, script, dp->dcb, dp->crtc);\r\n}\r\nstatic void\r\ndp_link_train_init(struct drm_device *dev, struct dp_state *dp)\r\n{\r\nu16 script = 0x0000;\r\nu8 *entry, *table = nouveau_dp_bios_data(dev, dp->dcb, &entry);\r\nif (table) {\r\nif (table[0] >= 0x20 && table[0] <= 0x30)\r\nscript = ROM16(entry[6]);\r\nelse\r\nif (table[0] == 0x40)\r\nscript = ROM16(entry[5]);\r\n}\r\nnouveau_bios_run_init_table(dev, script, dp->dcb, dp->crtc);\r\n}\r\nstatic void\r\ndp_link_train_fini(struct drm_device *dev, struct dp_state *dp)\r\n{\r\nu16 script = 0x0000;\r\nu8 *entry, *table = nouveau_dp_bios_data(dev, dp->dcb, &entry);\r\nif (table) {\r\nif (table[0] >= 0x20 && table[0] <= 0x30)\r\nscript = ROM16(entry[8]);\r\nelse\r\nif (table[0] == 0x40)\r\nscript = ROM16(entry[7]);\r\n}\r\nnouveau_bios_run_init_table(dev, script, dp->dcb, dp->crtc);\r\n}\r\nbool\r\nnouveau_dp_link_train(struct drm_encoder *encoder, u32 datarate,\r\nstruct dp_train_func *func)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct nouveau_connector *nv_connector =\r\nnouveau_encoder_connector_get(nv_encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_i2c_chan *auxch;\r\nconst u32 bw_list[] = { 270000, 162000, 0 };\r\nconst u32 *link_bw = bw_list;\r\nstruct dp_state dp;\r\nauxch = nouveau_i2c_find(dev, nv_encoder->dcb->i2c_index);\r\nif (!auxch)\r\nreturn false;\r\ndp.func = func;\r\ndp.dcb = nv_encoder->dcb;\r\ndp.crtc = nv_crtc->index;\r\ndp.auxch = auxch->drive;\r\ndp.dpcd = nv_encoder->dp.dpcd;\r\ndatarate = (datarate / 8) * 10;\r\nnouveau_gpio_irq(dev, 0, nv_connector->hpd, 0xff, false);\r\ndp_set_downspread(dev, &dp, nv_encoder->dp.dpcd[3] & 1);\r\ndp_link_train_init(dev, &dp);\r\nwhile (*link_bw > nv_encoder->dp.link_bw)\r\nlink_bw++;\r\nwhile (link_bw[0]) {\r\ndp.link_nr = nv_encoder->dp.link_nr;\r\nwhile ((dp.link_nr >> 1) * link_bw[0] > datarate)\r\ndp.link_nr >>= 1;\r\nwhile ((link_bw[1] * dp.link_nr) > datarate)\r\nlink_bw++;\r\ndp.link_bw = link_bw[0];\r\ndp_set_link_config(dev, &dp);\r\nmemset(dp.stat, 0x00, sizeof(dp.stat));\r\nif (!dp_link_train_cr(dev, &dp) &&\r\n!dp_link_train_eq(dev, &dp))\r\nbreak;\r\nlink_bw++;\r\n}\r\ndp_set_training_pattern(dev, &dp, DP_TRAINING_PATTERN_DISABLE);\r\ndp_link_train_fini(dev, &dp);\r\nnouveau_gpio_irq(dev, 0, nv_connector->hpd, 0xff, true);\r\nreturn true;\r\n}\r\nvoid\r\nnouveau_dp_dpms(struct drm_encoder *encoder, int mode, u32 datarate,\r\nstruct dp_train_func *func)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_i2c_chan *auxch;\r\nu8 status;\r\nauxch = nouveau_i2c_find(encoder->dev, nv_encoder->dcb->i2c_index);\r\nif (!auxch)\r\nreturn;\r\nif (mode == DRM_MODE_DPMS_ON)\r\nstatus = DP_SET_POWER_D0;\r\nelse\r\nstatus = DP_SET_POWER_D3;\r\nnouveau_dp_auxch(auxch, 8, DP_SET_POWER, &status, 1);\r\nif (mode == DRM_MODE_DPMS_ON)\r\nnouveau_dp_link_train(encoder, datarate, func);\r\n}\r\nstatic void\r\nnouveau_dp_probe_oui(struct drm_device *dev, struct nouveau_i2c_chan *auxch,\r\nu8 *dpcd)\r\n{\r\nu8 buf[3];\r\nif (!(dpcd[DP_DOWN_STREAM_PORT_COUNT] & DP_OUI_SUPPORT))\r\nreturn;\r\nif (!auxch_tx(dev, auxch->drive, 9, DP_SINK_OUI, buf, 3))\r\nNV_DEBUG_KMS(dev, "Sink OUI: %02hx%02hx%02hx\n",\r\nbuf[0], buf[1], buf[2]);\r\nif (!auxch_tx(dev, auxch->drive, 9, DP_BRANCH_OUI, buf, 3))\r\nNV_DEBUG_KMS(dev, "Branch OUI: %02hx%02hx%02hx\n",\r\nbuf[0], buf[1], buf[2]);\r\n}\r\nbool\r\nnouveau_dp_detect(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_i2c_chan *auxch;\r\nu8 *dpcd = nv_encoder->dp.dpcd;\r\nint ret;\r\nauxch = nouveau_i2c_find(dev, nv_encoder->dcb->i2c_index);\r\nif (!auxch)\r\nreturn false;\r\nret = auxch_tx(dev, auxch->drive, 9, DP_DPCD_REV, dpcd, 8);\r\nif (ret)\r\nreturn false;\r\nnv_encoder->dp.link_bw = 27000 * dpcd[1];\r\nnv_encoder->dp.link_nr = dpcd[2] & DP_MAX_LANE_COUNT_MASK;\r\nNV_DEBUG_KMS(dev, "display: %dx%d dpcd 0x%02x\n",\r\nnv_encoder->dp.link_nr, nv_encoder->dp.link_bw, dpcd[0]);\r\nNV_DEBUG_KMS(dev, "encoder: %dx%d\n",\r\nnv_encoder->dcb->dpconf.link_nr,\r\nnv_encoder->dcb->dpconf.link_bw);\r\nif (nv_encoder->dcb->dpconf.link_nr < nv_encoder->dp.link_nr)\r\nnv_encoder->dp.link_nr = nv_encoder->dcb->dpconf.link_nr;\r\nif (nv_encoder->dcb->dpconf.link_bw < nv_encoder->dp.link_bw)\r\nnv_encoder->dp.link_bw = nv_encoder->dcb->dpconf.link_bw;\r\nNV_DEBUG_KMS(dev, "maximum: %dx%d\n",\r\nnv_encoder->dp.link_nr, nv_encoder->dp.link_bw);\r\nnouveau_dp_probe_oui(dev, auxch, dpcd);\r\nreturn true;\r\n}\r\nint\r\nnouveau_dp_auxch(struct nouveau_i2c_chan *auxch, int cmd, int addr,\r\nuint8_t *data, int data_nr)\r\n{\r\nreturn auxch_tx(auxch->dev, auxch->drive, cmd, addr, data, data_nr);\r\n}\r\nstatic int\r\nnouveau_dp_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct nouveau_i2c_chan *auxch = (struct nouveau_i2c_chan *)adap;\r\nstruct i2c_msg *msg = msgs;\r\nint ret, mcnt = num;\r\nwhile (mcnt--) {\r\nu8 remaining = msg->len;\r\nu8 *ptr = msg->buf;\r\nwhile (remaining) {\r\nu8 cnt = (remaining > 16) ? 16 : remaining;\r\nu8 cmd;\r\nif (msg->flags & I2C_M_RD)\r\ncmd = AUX_I2C_READ;\r\nelse\r\ncmd = AUX_I2C_WRITE;\r\nif (mcnt || remaining > 16)\r\ncmd |= AUX_I2C_MOT;\r\nret = nouveau_dp_auxch(auxch, cmd, msg->addr, ptr, cnt);\r\nif (ret < 0)\r\nreturn ret;\r\nptr += cnt;\r\nremaining -= cnt;\r\n}\r\nmsg++;\r\n}\r\nreturn num;\r\n}\r\nstatic u32\r\nnouveau_dp_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}
