static inline void usbhs_write(void __iomem *base, u32 reg, u32 val)\r\n{\r\n__raw_writel(val, base + reg);\r\n}\r\nstatic inline u32 usbhs_read(void __iomem *base, u32 reg)\r\n{\r\nreturn __raw_readl(base + reg);\r\n}\r\nstatic inline void usbhs_writeb(void __iomem *base, u8 reg, u8 val)\r\n{\r\n__raw_writeb(val, base + reg);\r\n}\r\nstatic inline u8 usbhs_readb(void __iomem *base, u8 reg)\r\n{\r\nreturn __raw_readb(base + reg);\r\n}\r\nstatic struct platform_device *omap_usbhs_alloc_child(const char *name,\r\nstruct resource *res, int num_resources, void *pdata,\r\nsize_t pdata_size, struct device *dev)\r\n{\r\nstruct platform_device *child;\r\nint ret;\r\nchild = platform_device_alloc(name, 0);\r\nif (!child) {\r\ndev_err(dev, "platform_device_alloc %s failed\n", name);\r\ngoto err_end;\r\n}\r\nret = platform_device_add_resources(child, res, num_resources);\r\nif (ret) {\r\ndev_err(dev, "platform_device_add_resources failed\n");\r\ngoto err_alloc;\r\n}\r\nret = platform_device_add_data(child, pdata, pdata_size);\r\nif (ret) {\r\ndev_err(dev, "platform_device_add_data failed\n");\r\ngoto err_alloc;\r\n}\r\nchild->dev.dma_mask = &usbhs_dmamask;\r\ndma_set_coherent_mask(&child->dev, DMA_BIT_MASK(32));\r\nchild->dev.parent = dev;\r\nret = platform_device_add(child);\r\nif (ret) {\r\ndev_err(dev, "platform_device_add failed\n");\r\ngoto err_alloc;\r\n}\r\nreturn child;\r\nerr_alloc:\r\nplatform_device_put(child);\r\nerr_end:\r\nreturn NULL;\r\n}\r\nstatic int omap_usbhs_alloc_children(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usbhs_hcd_omap *omap;\r\nstruct ehci_hcd_omap_platform_data *ehci_data;\r\nstruct ohci_hcd_omap_platform_data *ohci_data;\r\nstruct platform_device *ehci;\r\nstruct platform_device *ohci;\r\nstruct resource *res;\r\nstruct resource resources[2];\r\nint ret;\r\nomap = platform_get_drvdata(pdev);\r\nehci_data = omap->platdata.ehci_data;\r\nohci_data = omap->platdata.ohci_data;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ehci");\r\nif (!res) {\r\ndev_err(dev, "EHCI get resource IORESOURCE_MEM failed\n");\r\nret = -ENODEV;\r\ngoto err_end;\r\n}\r\nresources[0] = *res;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "ehci-irq");\r\nif (!res) {\r\ndev_err(dev, " EHCI get resource IORESOURCE_IRQ failed\n");\r\nret = -ENODEV;\r\ngoto err_end;\r\n}\r\nresources[1] = *res;\r\nehci = omap_usbhs_alloc_child(OMAP_EHCI_DEVICE, resources, 2, ehci_data,\r\nsizeof(*ehci_data), dev);\r\nif (!ehci) {\r\ndev_err(dev, "omap_usbhs_alloc_child failed\n");\r\nret = -ENOMEM;\r\ngoto err_end;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ohci");\r\nif (!res) {\r\ndev_err(dev, "OHCI get resource IORESOURCE_MEM failed\n");\r\nret = -ENODEV;\r\ngoto err_ehci;\r\n}\r\nresources[0] = *res;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "ohci-irq");\r\nif (!res) {\r\ndev_err(dev, "OHCI get resource IORESOURCE_IRQ failed\n");\r\nret = -ENODEV;\r\ngoto err_ehci;\r\n}\r\nresources[1] = *res;\r\nohci = omap_usbhs_alloc_child(OMAP_OHCI_DEVICE, resources, 2, ohci_data,\r\nsizeof(*ohci_data), dev);\r\nif (!ohci) {\r\ndev_err(dev, "omap_usbhs_alloc_child failed\n");\r\nret = -ENOMEM;\r\ngoto err_ehci;\r\n}\r\nreturn 0;\r\nerr_ehci:\r\nplatform_device_unregister(ehci);\r\nerr_end:\r\nreturn ret;\r\n}\r\nstatic bool is_ohci_port(enum usbhs_omap_port_mode pmode)\r\n{\r\nswitch (pmode) {\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic unsigned ohci_omap3_fslsmode(enum usbhs_omap_port_mode mode)\r\n{\r\nswitch (mode) {\r\ncase OMAP_USBHS_PORT_MODE_UNUSED:\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_6PIN_PHY_DAT_SE0;\r\ncase OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_6PIN_PHY_DP_DM;\r\ncase OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_3PIN_PHY;\r\ncase OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_4PIN_PHY;\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_6PIN_TLL_DAT_SE0;\r\ncase OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_6PIN_TLL_DP_DM;\r\ncase OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_3PIN_TLL;\r\ncase OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_4PIN_TLL;\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0:\r\nreturn OMAP_TLL_FSLSMODE_2PIN_TLL_DAT_SE0;\r\ncase OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM:\r\nreturn OMAP_TLL_FSLSMODE_2PIN_DAT_DP_DM;\r\ndefault:\r\npr_warning("Invalid port mode, using default\n");\r\nreturn OMAP_TLL_FSLSMODE_6PIN_PHY_DAT_SE0;\r\n}\r\n}\r\nstatic void usbhs_omap_tll_init(struct device *dev, u8 tll_channel_count)\r\n{\r\nstruct usbhs_hcd_omap *omap = dev_get_drvdata(dev);\r\nstruct usbhs_omap_platform_data *pdata = dev->platform_data;\r\nunsigned reg;\r\nint i;\r\nreg = usbhs_read(omap->tll_base, OMAP_TLL_SHARED_CONF);\r\nreg |= (OMAP_TLL_SHARED_CONF_FCLK_IS_ON\r\n| OMAP_TLL_SHARED_CONF_USB_DIVRATION);\r\nreg &= ~OMAP_TLL_SHARED_CONF_USB_90D_DDR_EN;\r\nreg &= ~OMAP_TLL_SHARED_CONF_USB_180D_SDR_EN;\r\nusbhs_write(omap->tll_base, OMAP_TLL_SHARED_CONF, reg);\r\nfor (i = 0; i < tll_channel_count; i++) {\r\nreg = usbhs_read(omap->tll_base,\r\nOMAP_TLL_CHANNEL_CONF(i));\r\nif (is_ohci_port(pdata->port_mode[i])) {\r\nreg |= ohci_omap3_fslsmode(pdata->port_mode[i])\r\n<< OMAP_TLL_CHANNEL_CONF_FSLSMODE_SHIFT;\r\nreg |= OMAP_TLL_CHANNEL_CONF_CHANMODE_FSLS;\r\n} else if (pdata->port_mode[i] == OMAP_EHCI_PORT_MODE_TLL) {\r\nreg &= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE\r\n| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF\r\n| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);\r\n} else\r\ncontinue;\r\nreg |= OMAP_TLL_CHANNEL_CONF_CHANEN;\r\nusbhs_write(omap->tll_base,\r\nOMAP_TLL_CHANNEL_CONF(i), reg);\r\nusbhs_writeb(omap->tll_base,\r\nOMAP_TLL_ULPI_SCRATCH_REGISTER(i), 0xbe);\r\n}\r\n}\r\nstatic int usbhs_runtime_resume(struct device *dev)\r\n{\r\nstruct usbhs_hcd_omap *omap = dev_get_drvdata(dev);\r\nstruct usbhs_omap_platform_data *pdata = &omap->platdata;\r\nunsigned long flags;\r\ndev_dbg(dev, "usbhs_runtime_resume\n");\r\nif (!pdata) {\r\ndev_dbg(dev, "missing platform_data\n");\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&omap->lock, flags);\r\nif (omap->ehci_logic_fck && !IS_ERR(omap->ehci_logic_fck))\r\nclk_enable(omap->ehci_logic_fck);\r\nif (is_ehci_tll_mode(pdata->port_mode[0])) {\r\nclk_enable(omap->usbhost_p1_fck);\r\nclk_enable(omap->usbtll_p1_fck);\r\n}\r\nif (is_ehci_tll_mode(pdata->port_mode[1])) {\r\nclk_enable(omap->usbhost_p2_fck);\r\nclk_enable(omap->usbtll_p2_fck);\r\n}\r\nclk_enable(omap->utmi_p1_fck);\r\nclk_enable(omap->utmi_p2_fck);\r\nspin_unlock_irqrestore(&omap->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usbhs_runtime_suspend(struct device *dev)\r\n{\r\nstruct usbhs_hcd_omap *omap = dev_get_drvdata(dev);\r\nstruct usbhs_omap_platform_data *pdata = &omap->platdata;\r\nunsigned long flags;\r\ndev_dbg(dev, "usbhs_runtime_suspend\n");\r\nif (!pdata) {\r\ndev_dbg(dev, "missing platform_data\n");\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&omap->lock, flags);\r\nif (is_ehci_tll_mode(pdata->port_mode[0])) {\r\nclk_disable(omap->usbhost_p1_fck);\r\nclk_disable(omap->usbtll_p1_fck);\r\n}\r\nif (is_ehci_tll_mode(pdata->port_mode[1])) {\r\nclk_disable(omap->usbhost_p2_fck);\r\nclk_disable(omap->usbtll_p2_fck);\r\n}\r\nclk_disable(omap->utmi_p2_fck);\r\nclk_disable(omap->utmi_p1_fck);\r\nif (omap->ehci_logic_fck && !IS_ERR(omap->ehci_logic_fck))\r\nclk_disable(omap->ehci_logic_fck);\r\nspin_unlock_irqrestore(&omap->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void omap_usbhs_init(struct device *dev)\r\n{\r\nstruct usbhs_hcd_omap *omap = dev_get_drvdata(dev);\r\nstruct usbhs_omap_platform_data *pdata = &omap->platdata;\r\nunsigned long flags;\r\nunsigned reg;\r\ndev_dbg(dev, "starting TI HSUSB Controller\n");\r\npm_runtime_get_sync(dev);\r\nif (pdata->ehci_data->phy_reset) {\r\nif (gpio_is_valid(pdata->ehci_data->reset_gpio_port[0]))\r\ngpio_request_one(pdata->ehci_data->reset_gpio_port[0],\r\nGPIOF_OUT_INIT_LOW, "USB1 PHY reset");\r\nif (gpio_is_valid(pdata->ehci_data->reset_gpio_port[1]))\r\ngpio_request_one(pdata->ehci_data->reset_gpio_port[1],\r\nGPIOF_OUT_INIT_LOW, "USB2 PHY reset");\r\nudelay(10);\r\n}\r\nspin_lock_irqsave(&omap->lock, flags);\r\nomap->usbhs_rev = usbhs_read(omap->uhh_base, OMAP_UHH_REVISION);\r\ndev_dbg(dev, "OMAP UHH_REVISION 0x%x\n", omap->usbhs_rev);\r\nreg = usbhs_read(omap->uhh_base, OMAP_UHH_HOSTCONFIG);\r\nreg |= (OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN\r\n| OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN\r\n| OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN);\r\nreg |= OMAP4_UHH_HOSTCONFIG_APP_START_CLK;\r\nreg &= ~OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN;\r\nif (is_omap_usbhs_rev1(omap)) {\r\nif (pdata->port_mode[0] == OMAP_USBHS_PORT_MODE_UNUSED)\r\nreg &= ~OMAP_UHH_HOSTCONFIG_P1_CONNECT_STATUS;\r\nif (pdata->port_mode[1] == OMAP_USBHS_PORT_MODE_UNUSED)\r\nreg &= ~OMAP_UHH_HOSTCONFIG_P2_CONNECT_STATUS;\r\nif (pdata->port_mode[2] == OMAP_USBHS_PORT_MODE_UNUSED)\r\nreg &= ~OMAP_UHH_HOSTCONFIG_P3_CONNECT_STATUS;\r\nif (cpu_is_omap3430() && (omap_rev() <= OMAP3430_REV_ES2_1)) {\r\ndev_dbg(dev, "OMAP3 ES version <= ES2.1\n");\r\nif (is_ehci_phy_mode(pdata->port_mode[0]) ||\r\nis_ehci_phy_mode(pdata->port_mode[1]) ||\r\nis_ehci_phy_mode(pdata->port_mode[2]))\r\nreg &= ~OMAP_UHH_HOSTCONFIG_ULPI_BYPASS;\r\nelse\r\nreg |= OMAP_UHH_HOSTCONFIG_ULPI_BYPASS;\r\n} else {\r\ndev_dbg(dev, "OMAP3 ES version > ES2.1\n");\r\nif (is_ehci_phy_mode(pdata->port_mode[0]))\r\nreg &= ~OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS;\r\nelse\r\nreg |= OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS;\r\nif (is_ehci_phy_mode(pdata->port_mode[1]))\r\nreg &= ~OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS;\r\nelse\r\nreg |= OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS;\r\nif (is_ehci_phy_mode(pdata->port_mode[2]))\r\nreg &= ~OMAP_UHH_HOSTCONFIG_ULPI_P3_BYPASS;\r\nelse\r\nreg |= OMAP_UHH_HOSTCONFIG_ULPI_P3_BYPASS;\r\n}\r\n} else if (is_omap_usbhs_rev2(omap)) {\r\nreg &= ~OMAP4_P1_MODE_CLEAR;\r\nreg &= ~OMAP4_P2_MODE_CLEAR;\r\nif (is_ehci_tll_mode(pdata->port_mode[0]) ||\r\n(is_ohci_port(pdata->port_mode[0])))\r\nreg |= OMAP4_P1_MODE_TLL;\r\nelse if (is_ehci_hsic_mode(pdata->port_mode[0]))\r\nreg |= OMAP4_P1_MODE_HSIC;\r\nif (is_ehci_tll_mode(pdata->port_mode[1]) ||\r\n(is_ohci_port(pdata->port_mode[1])))\r\nreg |= OMAP4_P2_MODE_TLL;\r\nelse if (is_ehci_hsic_mode(pdata->port_mode[1]))\r\nreg |= OMAP4_P2_MODE_HSIC;\r\n}\r\nusbhs_write(omap->uhh_base, OMAP_UHH_HOSTCONFIG, reg);\r\ndev_dbg(dev, "UHH setup done, uhh_hostconfig=%x\n", reg);\r\nif (is_ehci_tll_mode(pdata->port_mode[0]) ||\r\nis_ehci_tll_mode(pdata->port_mode[1]) ||\r\nis_ehci_tll_mode(pdata->port_mode[2]) ||\r\n(is_ohci_port(pdata->port_mode[0])) ||\r\n(is_ohci_port(pdata->port_mode[1])) ||\r\n(is_ohci_port(pdata->port_mode[2]))) {\r\nif (is_omap_usbhs_rev2(omap))\r\nusbhs_omap_tll_init(dev, OMAP_REV2_TLL_CHANNEL_COUNT);\r\nelse\r\nusbhs_omap_tll_init(dev, OMAP_TLL_CHANNEL_COUNT);\r\n}\r\nspin_unlock_irqrestore(&omap->lock, flags);\r\nif (pdata->ehci_data->phy_reset) {\r\nudelay(10);\r\nif (gpio_is_valid(pdata->ehci_data->reset_gpio_port[0]))\r\ngpio_set_value_cansleep\r\n(pdata->ehci_data->reset_gpio_port[0], 1);\r\nif (gpio_is_valid(pdata->ehci_data->reset_gpio_port[1]))\r\ngpio_set_value_cansleep\r\n(pdata->ehci_data->reset_gpio_port[1], 1);\r\n}\r\npm_runtime_put_sync(dev);\r\n}\r\nstatic void omap_usbhs_deinit(struct device *dev)\r\n{\r\nstruct usbhs_hcd_omap *omap = dev_get_drvdata(dev);\r\nstruct usbhs_omap_platform_data *pdata = &omap->platdata;\r\nif (pdata->ehci_data->phy_reset) {\r\nif (gpio_is_valid(pdata->ehci_data->reset_gpio_port[0]))\r\ngpio_free(pdata->ehci_data->reset_gpio_port[0]);\r\nif (gpio_is_valid(pdata->ehci_data->reset_gpio_port[1]))\r\ngpio_free(pdata->ehci_data->reset_gpio_port[1]);\r\n}\r\n}\r\nstatic int __devinit usbhs_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usbhs_omap_platform_data *pdata = dev->platform_data;\r\nstruct usbhs_hcd_omap *omap;\r\nstruct resource *res;\r\nint ret = 0;\r\nint i;\r\nif (!pdata) {\r\ndev_err(dev, "Missing platform data\n");\r\nret = -ENOMEM;\r\ngoto end_probe;\r\n}\r\nomap = kzalloc(sizeof(*omap), GFP_KERNEL);\r\nif (!omap) {\r\ndev_err(dev, "Memory allocation failed\n");\r\nret = -ENOMEM;\r\ngoto end_probe;\r\n}\r\nspin_lock_init(&omap->lock);\r\nfor (i = 0; i < OMAP3_HS_USB_PORTS; i++)\r\nomap->platdata.port_mode[i] = pdata->port_mode[i];\r\nomap->platdata.ehci_data = pdata->ehci_data;\r\nomap->platdata.ohci_data = pdata->ohci_data;\r\npm_runtime_enable(dev);\r\nfor (i = 0; i < OMAP3_HS_USB_PORTS; i++)\r\nif (is_ehci_phy_mode(i) || is_ehci_tll_mode(i) ||\r\nis_ehci_hsic_mode(i)) {\r\nomap->ehci_logic_fck = clk_get(dev, "ehci_logic_fck");\r\nif (IS_ERR(omap->ehci_logic_fck)) {\r\nret = PTR_ERR(omap->ehci_logic_fck);\r\ndev_warn(dev, "ehci_logic_fck failed:%d\n",\r\nret);\r\n}\r\nbreak;\r\n}\r\nomap->utmi_p1_fck = clk_get(dev, "utmi_p1_gfclk");\r\nif (IS_ERR(omap->utmi_p1_fck)) {\r\nret = PTR_ERR(omap->utmi_p1_fck);\r\ndev_err(dev, "utmi_p1_gfclk failed error:%d\n", ret);\r\ngoto err_end;\r\n}\r\nomap->xclk60mhsp1_ck = clk_get(dev, "xclk60mhsp1_ck");\r\nif (IS_ERR(omap->xclk60mhsp1_ck)) {\r\nret = PTR_ERR(omap->xclk60mhsp1_ck);\r\ndev_err(dev, "xclk60mhsp1_ck failed error:%d\n", ret);\r\ngoto err_utmi_p1_fck;\r\n}\r\nomap->utmi_p2_fck = clk_get(dev, "utmi_p2_gfclk");\r\nif (IS_ERR(omap->utmi_p2_fck)) {\r\nret = PTR_ERR(omap->utmi_p2_fck);\r\ndev_err(dev, "utmi_p2_gfclk failed error:%d\n", ret);\r\ngoto err_xclk60mhsp1_ck;\r\n}\r\nomap->xclk60mhsp2_ck = clk_get(dev, "xclk60mhsp2_ck");\r\nif (IS_ERR(omap->xclk60mhsp2_ck)) {\r\nret = PTR_ERR(omap->xclk60mhsp2_ck);\r\ndev_err(dev, "xclk60mhsp2_ck failed error:%d\n", ret);\r\ngoto err_utmi_p2_fck;\r\n}\r\nomap->usbhost_p1_fck = clk_get(dev, "usb_host_hs_utmi_p1_clk");\r\nif (IS_ERR(omap->usbhost_p1_fck)) {\r\nret = PTR_ERR(omap->usbhost_p1_fck);\r\ndev_err(dev, "usbhost_p1_fck failed error:%d\n", ret);\r\ngoto err_xclk60mhsp2_ck;\r\n}\r\nomap->usbtll_p1_fck = clk_get(dev, "usb_tll_hs_usb_ch0_clk");\r\nif (IS_ERR(omap->usbtll_p1_fck)) {\r\nret = PTR_ERR(omap->usbtll_p1_fck);\r\ndev_err(dev, "usbtll_p1_fck failed error:%d\n", ret);\r\ngoto err_usbhost_p1_fck;\r\n}\r\nomap->usbhost_p2_fck = clk_get(dev, "usb_host_hs_utmi_p2_clk");\r\nif (IS_ERR(omap->usbhost_p2_fck)) {\r\nret = PTR_ERR(omap->usbhost_p2_fck);\r\ndev_err(dev, "usbhost_p2_fck failed error:%d\n", ret);\r\ngoto err_usbtll_p1_fck;\r\n}\r\nomap->usbtll_p2_fck = clk_get(dev, "usb_tll_hs_usb_ch1_clk");\r\nif (IS_ERR(omap->usbtll_p2_fck)) {\r\nret = PTR_ERR(omap->usbtll_p2_fck);\r\ndev_err(dev, "usbtll_p2_fck failed error:%d\n", ret);\r\ngoto err_usbhost_p2_fck;\r\n}\r\nomap->init_60m_fclk = clk_get(dev, "init_60m_fclk");\r\nif (IS_ERR(omap->init_60m_fclk)) {\r\nret = PTR_ERR(omap->init_60m_fclk);\r\ndev_err(dev, "init_60m_fclk failed error:%d\n", ret);\r\ngoto err_usbtll_p2_fck;\r\n}\r\nif (is_ehci_phy_mode(pdata->port_mode[0])) {\r\nret = clk_set_parent(omap->utmi_p1_fck,\r\nomap->xclk60mhsp1_ck);\r\nif (ret != 0)\r\ndev_err(dev, "xclk60mhsp1_ck set parent"\r\n"failed error:%d\n", ret);\r\n} else if (is_ehci_tll_mode(pdata->port_mode[0])) {\r\nret = clk_set_parent(omap->utmi_p1_fck,\r\nomap->init_60m_fclk);\r\nif (ret != 0)\r\ndev_err(dev, "init_60m_fclk set parent"\r\n"failed error:%d\n", ret);\r\n}\r\nif (is_ehci_phy_mode(pdata->port_mode[1])) {\r\nret = clk_set_parent(omap->utmi_p2_fck,\r\nomap->xclk60mhsp2_ck);\r\nif (ret != 0)\r\ndev_err(dev, "xclk60mhsp2_ck set parent"\r\n"failed error:%d\n", ret);\r\n} else if (is_ehci_tll_mode(pdata->port_mode[1])) {\r\nret = clk_set_parent(omap->utmi_p2_fck,\r\nomap->init_60m_fclk);\r\nif (ret != 0)\r\ndev_err(dev, "init_60m_fclk set parent"\r\n"failed error:%d\n", ret);\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "uhh");\r\nif (!res) {\r\ndev_err(dev, "UHH EHCI get resource failed\n");\r\nret = -ENODEV;\r\ngoto err_init_60m_fclk;\r\n}\r\nomap->uhh_base = ioremap(res->start, resource_size(res));\r\nif (!omap->uhh_base) {\r\ndev_err(dev, "UHH ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_init_60m_fclk;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tll");\r\nif (!res) {\r\ndev_err(dev, "UHH EHCI get resource failed\n");\r\nret = -ENODEV;\r\ngoto err_tll;\r\n}\r\nomap->tll_base = ioremap(res->start, resource_size(res));\r\nif (!omap->tll_base) {\r\ndev_err(dev, "TLL ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_tll;\r\n}\r\nplatform_set_drvdata(pdev, omap);\r\nomap_usbhs_init(dev);\r\nret = omap_usbhs_alloc_children(pdev);\r\nif (ret) {\r\ndev_err(dev, "omap_usbhs_alloc_children failed\n");\r\ngoto err_alloc;\r\n}\r\ngoto end_probe;\r\nerr_alloc:\r\nomap_usbhs_deinit(&pdev->dev);\r\niounmap(omap->tll_base);\r\nerr_tll:\r\niounmap(omap->uhh_base);\r\nerr_init_60m_fclk:\r\nclk_put(omap->init_60m_fclk);\r\nerr_usbtll_p2_fck:\r\nclk_put(omap->usbtll_p2_fck);\r\nerr_usbhost_p2_fck:\r\nclk_put(omap->usbhost_p2_fck);\r\nerr_usbtll_p1_fck:\r\nclk_put(omap->usbtll_p1_fck);\r\nerr_usbhost_p1_fck:\r\nclk_put(omap->usbhost_p1_fck);\r\nerr_xclk60mhsp2_ck:\r\nclk_put(omap->xclk60mhsp2_ck);\r\nerr_utmi_p2_fck:\r\nclk_put(omap->utmi_p2_fck);\r\nerr_xclk60mhsp1_ck:\r\nclk_put(omap->xclk60mhsp1_ck);\r\nerr_utmi_p1_fck:\r\nclk_put(omap->utmi_p1_fck);\r\nerr_end:\r\nclk_put(omap->ehci_logic_fck);\r\npm_runtime_disable(dev);\r\nkfree(omap);\r\nend_probe:\r\nreturn ret;\r\n}\r\nstatic int __devexit usbhs_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct usbhs_hcd_omap *omap = platform_get_drvdata(pdev);\r\nomap_usbhs_deinit(&pdev->dev);\r\niounmap(omap->tll_base);\r\niounmap(omap->uhh_base);\r\nclk_put(omap->init_60m_fclk);\r\nclk_put(omap->usbtll_p2_fck);\r\nclk_put(omap->usbhost_p2_fck);\r\nclk_put(omap->usbtll_p1_fck);\r\nclk_put(omap->usbhost_p1_fck);\r\nclk_put(omap->xclk60mhsp2_ck);\r\nclk_put(omap->utmi_p2_fck);\r\nclk_put(omap->xclk60mhsp1_ck);\r\nclk_put(omap->utmi_p1_fck);\r\nclk_put(omap->ehci_logic_fck);\r\npm_runtime_disable(&pdev->dev);\r\nkfree(omap);\r\nreturn 0;\r\n}\r\nstatic int __init omap_usbhs_drvinit(void)\r\n{\r\nreturn platform_driver_probe(&usbhs_omap_driver, usbhs_omap_probe);\r\n}\r\nstatic void __exit omap_usbhs_drvexit(void)\r\n{\r\nplatform_driver_unregister(&usbhs_omap_driver);\r\n}
