static inline int fw_hash(u32 handle)\r\n{\r\nif (HTSIZE == 4096)\r\nreturn ((handle >> 24) & 0xFFF) ^\r\n((handle >> 12) & 0xFFF) ^\r\n(handle & 0xFFF);\r\nelse if (HTSIZE == 2048)\r\nreturn ((handle >> 22) & 0x7FF) ^\r\n((handle >> 11) & 0x7FF) ^\r\n(handle & 0x7FF);\r\nelse if (HTSIZE == 1024)\r\nreturn ((handle >> 20) & 0x3FF) ^\r\n((handle >> 10) & 0x3FF) ^\r\n(handle & 0x3FF);\r\nelse if (HTSIZE == 512)\r\nreturn (handle >> 27) ^\r\n((handle >> 18) & 0x1FF) ^\r\n((handle >> 9) & 0x1FF) ^\r\n(handle & 0x1FF);\r\nelse if (HTSIZE == 256) {\r\nu8 *t = (u8 *) &handle;\r\nreturn t[0] ^ t[1] ^ t[2] ^ t[3];\r\n} else\r\nreturn handle & (HTSIZE - 1);\r\n}\r\nstatic int fw_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct fw_head *head = (struct fw_head *)tp->root;\r\nstruct fw_filter *f;\r\nint r;\r\nu32 id = skb->mark;\r\nif (head != NULL) {\r\nid &= head->mask;\r\nfor (f = head->ht[fw_hash(id)]; f; f = f->next) {\r\nif (f->id == id) {\r\n*res = f->res;\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (!tcf_match_indev(skb, f->indev))\r\ncontinue;\r\n#endif\r\nr = tcf_exts_exec(skb, &f->exts, res);\r\nif (r < 0)\r\ncontinue;\r\nreturn r;\r\n}\r\n}\r\n} else {\r\nif (id && (TC_H_MAJ(id) == 0 ||\r\n!(TC_H_MAJ(id ^ tp->q->handle)))) {\r\nres->classid = id;\r\nres->class = 0;\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic unsigned long fw_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct fw_head *head = (struct fw_head *)tp->root;\r\nstruct fw_filter *f;\r\nif (head == NULL)\r\nreturn 0;\r\nfor (f = head->ht[fw_hash(handle)]; f; f = f->next) {\r\nif (f->id == handle)\r\nreturn (unsigned long)f;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fw_put(struct tcf_proto *tp, unsigned long f)\r\n{\r\n}\r\nstatic int fw_init(struct tcf_proto *tp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void fw_delete_filter(struct tcf_proto *tp, struct fw_filter *f)\r\n{\r\ntcf_unbind_filter(tp, &f->res);\r\ntcf_exts_destroy(tp, &f->exts);\r\nkfree(f);\r\n}\r\nstatic void fw_destroy(struct tcf_proto *tp)\r\n{\r\nstruct fw_head *head = tp->root;\r\nstruct fw_filter *f;\r\nint h;\r\nif (head == NULL)\r\nreturn;\r\nfor (h = 0; h < HTSIZE; h++) {\r\nwhile ((f = head->ht[h]) != NULL) {\r\nhead->ht[h] = f->next;\r\nfw_delete_filter(tp, f);\r\n}\r\n}\r\nkfree(head);\r\n}\r\nstatic int fw_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct fw_head *head = (struct fw_head *)tp->root;\r\nstruct fw_filter *f = (struct fw_filter *)arg;\r\nstruct fw_filter **fp;\r\nif (head == NULL || f == NULL)\r\ngoto out;\r\nfor (fp = &head->ht[fw_hash(f->id)]; *fp; fp = &(*fp)->next) {\r\nif (*fp == f) {\r\ntcf_tree_lock(tp);\r\n*fp = f->next;\r\ntcf_tree_unlock(tp);\r\nfw_delete_filter(tp, f);\r\nreturn 0;\r\n}\r\n}\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nfw_change_attrs(struct tcf_proto *tp, struct fw_filter *f,\r\nstruct nlattr **tb, struct nlattr **tca, unsigned long base)\r\n{\r\nstruct fw_head *head = (struct fw_head *)tp->root;\r\nstruct tcf_exts e;\r\nu32 mask;\r\nint err;\r\nerr = tcf_exts_validate(tp, tb, tca[TCA_RATE], &e, &fw_ext_map);\r\nif (err < 0)\r\nreturn err;\r\nerr = -EINVAL;\r\nif (tb[TCA_FW_CLASSID]) {\r\nf->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);\r\ntcf_bind_filter(tp, &f->res, base);\r\n}\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (tb[TCA_FW_INDEV]) {\r\nerr = tcf_change_indev(tp, f->indev, tb[TCA_FW_INDEV]);\r\nif (err < 0)\r\ngoto errout;\r\n}\r\n#endif\r\nif (tb[TCA_FW_MASK]) {\r\nmask = nla_get_u32(tb[TCA_FW_MASK]);\r\nif (mask != head->mask)\r\ngoto errout;\r\n} else if (head->mask != 0xFFFFFFFF)\r\ngoto errout;\r\ntcf_exts_change(tp, &f->exts, &e);\r\nreturn 0;\r\nerrout:\r\ntcf_exts_destroy(tp, &e);\r\nreturn err;\r\n}\r\nstatic int fw_change(struct tcf_proto *tp, unsigned long base,\r\nu32 handle,\r\nstruct nlattr **tca,\r\nunsigned long *arg)\r\n{\r\nstruct fw_head *head = (struct fw_head *)tp->root;\r\nstruct fw_filter *f = (struct fw_filter *) *arg;\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_FW_MAX + 1];\r\nint err;\r\nif (!opt)\r\nreturn handle ? -EINVAL : 0;\r\nerr = nla_parse_nested(tb, TCA_FW_MAX, opt, fw_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (f != NULL) {\r\nif (f->id != handle && handle)\r\nreturn -EINVAL;\r\nreturn fw_change_attrs(tp, f, tb, tca, base);\r\n}\r\nif (!handle)\r\nreturn -EINVAL;\r\nif (head == NULL) {\r\nu32 mask = 0xFFFFFFFF;\r\nif (tb[TCA_FW_MASK])\r\nmask = nla_get_u32(tb[TCA_FW_MASK]);\r\nhead = kzalloc(sizeof(struct fw_head), GFP_KERNEL);\r\nif (head == NULL)\r\nreturn -ENOBUFS;\r\nhead->mask = mask;\r\ntcf_tree_lock(tp);\r\ntp->root = head;\r\ntcf_tree_unlock(tp);\r\n}\r\nf = kzalloc(sizeof(struct fw_filter), GFP_KERNEL);\r\nif (f == NULL)\r\nreturn -ENOBUFS;\r\nf->id = handle;\r\nerr = fw_change_attrs(tp, f, tb, tca, base);\r\nif (err < 0)\r\ngoto errout;\r\nf->next = head->ht[fw_hash(handle)];\r\ntcf_tree_lock(tp);\r\nhead->ht[fw_hash(handle)] = f;\r\ntcf_tree_unlock(tp);\r\n*arg = (unsigned long)f;\r\nreturn 0;\r\nerrout:\r\nkfree(f);\r\nreturn err;\r\n}\r\nstatic void fw_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct fw_head *head = (struct fw_head *)tp->root;\r\nint h;\r\nif (head == NULL)\r\narg->stop = 1;\r\nif (arg->stop)\r\nreturn;\r\nfor (h = 0; h < HTSIZE; h++) {\r\nstruct fw_filter *f;\r\nfor (f = head->ht[h]; f; f = f->next) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(tp, (unsigned long)f, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\narg->count++;\r\n}\r\n}\r\n}\r\nstatic int fw_dump(struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct fw_head *head = (struct fw_head *)tp->root;\r\nstruct fw_filter *f = (struct fw_filter *)fh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct nlattr *nest;\r\nif (f == NULL)\r\nreturn skb->len;\r\nt->tcm_handle = f->id;\r\nif (!f->res.classid && !tcf_exts_is_available(&f->exts))\r\nreturn skb->len;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (f->res.classid &&\r\nnla_put_u32(skb, TCA_FW_CLASSID, f->res.classid))\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (strlen(f->indev) &&\r\nnla_put_string(skb, TCA_FW_INDEV, f->indev))\r\ngoto nla_put_failure;\r\n#endif\r\nif (head->mask != 0xFFFFFFFF &&\r\nnla_put_u32(skb, TCA_FW_MASK, head->mask))\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &f->exts, &fw_ext_map) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &f->exts, &fw_ext_map) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init init_fw(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_fw_ops);\r\n}\r\nstatic void __exit exit_fw(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_fw_ops);\r\n}
