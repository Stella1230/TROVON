static void pm_mtevent(struct pm *pm, struct input_dev *input)\r\n{\r\nint i;\r\nfor (i = 0; i < pm->maxcontacts; ++i) {\r\ninput_mt_slot(input, i);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER,\r\npm->slots[i].active);\r\nif (pm->slots[i].active) {\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_X, pm->slots[i].x);\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_Y, pm->slots[i].y);\r\n}\r\n}\r\ninput_mt_report_pointer_emulation(input, true);\r\ninput_sync(input);\r\n}\r\nstatic bool pm_checkpacket(unsigned char *packet)\r\n{\r\nint total = 0;\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\ntotal += packet[i];\r\nreturn packet[5] == (unsigned char)~(total & 0xff);\r\n}\r\nstatic void pm_parse_9000(struct pm *pm)\r\n{\r\nstruct input_dev *dev = pm->dev;\r\nif ((pm->data[0] & 0x80) && pm->packetsize == ++pm->idx) {\r\ninput_report_abs(dev, ABS_X, pm->data[1] * 128 + pm->data[2]);\r\ninput_report_abs(dev, ABS_Y, pm->data[3] * 128 + pm->data[4]);\r\ninput_report_key(dev, BTN_TOUCH, !!(pm->data[0] & 0x40));\r\ninput_sync(dev);\r\npm->idx = 0;\r\n}\r\n}\r\nstatic void pm_parse_6000(struct pm *pm)\r\n{\r\nstruct input_dev *dev = pm->dev;\r\nif ((pm->data[0] & 0xbf) == 0x30 && pm->packetsize == ++pm->idx) {\r\nif (pm_checkpacket(pm->data)) {\r\ninput_report_abs(dev, ABS_X,\r\npm->data[2] * 256 + pm->data[1]);\r\ninput_report_abs(dev, ABS_Y,\r\npm->data[4] * 256 + pm->data[3]);\r\ninput_report_key(dev, BTN_TOUCH, pm->data[0] & 0x40);\r\ninput_sync(dev);\r\n}\r\npm->idx = 0;\r\n}\r\n}\r\nstatic void pm_parse_3000(struct pm *pm)\r\n{\r\nstruct input_dev *dev = pm->dev;\r\nif ((pm->data[0] & 0xce) == 0x40 && pm->packetsize == ++pm->idx) {\r\nif (pm_checkpacket(pm->data)) {\r\nint slotnum = pm->data[0] & 0x0f;\r\npm->slots[slotnum].active = pm->data[0] & 0x30;\r\npm->slots[slotnum].x = pm->data[2] * 256 + pm->data[1];\r\npm->slots[slotnum].y = pm->data[4] * 256 + pm->data[3];\r\npm_mtevent(pm, dev);\r\n}\r\npm->idx = 0;\r\n}\r\n}\r\nstatic void pm_parse_6250(struct pm *pm)\r\n{\r\nstruct input_dev *dev = pm->dev;\r\nif ((pm->data[0] & 0xb0) == 0x30 && pm->packetsize == ++pm->idx) {\r\nif (pm_checkpacket(pm->data)) {\r\nint slotnum = pm->data[0] & 0x0f;\r\npm->slots[slotnum].active = pm->data[0] & 0x40;\r\npm->slots[slotnum].x = pm->data[2] * 256 + pm->data[1];\r\npm->slots[slotnum].y = pm->data[4] * 256 + pm->data[3];\r\npm_mtevent(pm, dev);\r\n}\r\npm->idx = 0;\r\n}\r\n}\r\nstatic irqreturn_t pm_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct pm *pm = serio_get_drvdata(serio);\r\npm->data[pm->idx] = data;\r\npm->parse_packet(pm);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pm_disconnect(struct serio *serio)\r\n{\r\nstruct pm *pm = serio_get_drvdata(serio);\r\nserio_close(serio);\r\ninput_unregister_device(pm->dev);\r\nkfree(pm);\r\nserio_set_drvdata(serio, NULL);\r\n}\r\nstatic int pm_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct pm *pm;\r\nstruct input_dev *input_dev;\r\nint max_x, max_y;\r\nint err;\r\npm = kzalloc(sizeof(struct pm), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!pm || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\npm->serio = serio;\r\npm->dev = input_dev;\r\nsnprintf(pm->phys, sizeof(pm->phys), "%s/input0", serio->phys);\r\npm->maxcontacts = 1;\r\ninput_dev->name = "PenMount Serial TouchScreen";\r\ninput_dev->phys = pm->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_PENMOUNT;\r\ninput_dev->id.product = 0;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\nswitch (serio->id.id) {\r\ndefault:\r\ncase 0:\r\npm->packetsize = 5;\r\npm->parse_packet = pm_parse_9000;\r\ninput_dev->id.product = 0x9000;\r\nmax_x = max_y = 0x3ff;\r\nbreak;\r\ncase 1:\r\npm->packetsize = 6;\r\npm->parse_packet = pm_parse_6000;\r\ninput_dev->id.product = 0x6000;\r\nmax_x = max_y = 0x3ff;\r\nbreak;\r\ncase 2:\r\npm->packetsize = 6;\r\npm->parse_packet = pm_parse_3000;\r\ninput_dev->id.product = 0x3000;\r\nmax_x = max_y = 0x7ff;\r\npm->maxcontacts = PM_3000_MTSLOT;\r\nbreak;\r\ncase 3:\r\npm->packetsize = 6;\r\npm->parse_packet = pm_parse_6250;\r\ninput_dev->id.product = 0x6250;\r\nmax_x = max_y = 0x3ff;\r\npm->maxcontacts = PM_6250_MTSLOT;\r\nbreak;\r\n}\r\ninput_set_abs_params(pm->dev, ABS_X, 0, max_x, 0, 0);\r\ninput_set_abs_params(pm->dev, ABS_Y, 0, max_y, 0, 0);\r\nif (pm->maxcontacts > 1) {\r\ninput_mt_init_slots(pm->dev, pm->maxcontacts);\r\ninput_set_abs_params(pm->dev,\r\nABS_MT_POSITION_X, 0, max_x, 0, 0);\r\ninput_set_abs_params(pm->dev,\r\nABS_MT_POSITION_Y, 0, max_y, 0, 0);\r\n}\r\nserio_set_drvdata(serio, pm);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = input_register_device(pm->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3: serio_close(serio);\r\nfail2: serio_set_drvdata(serio, NULL);\r\nfail1: input_free_device(input_dev);\r\nkfree(pm);\r\nreturn err;\r\n}
