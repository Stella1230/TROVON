int *load_mixer_volumes(char *name, int *levels, int present)\r\n{\r\nint i, n;\r\nfor (i = 0; i < num_mixer_volumes; i++) {\r\nif (strncmp(name, mixer_vols[i].name, 32) == 0) {\r\nif (present)\r\nmixer_vols[i].num = i;\r\nreturn mixer_vols[i].levels;\r\n}\r\n}\r\nif (num_mixer_volumes >= MAX_MIXER_DEV) {\r\nprintk(KERN_ERR "Sound: Too many mixers (%s)\n", name);\r\nreturn levels;\r\n}\r\nn = num_mixer_volumes++;\r\nstrncpy(mixer_vols[n].name, name, 32);\r\nif (present)\r\nmixer_vols[n].num = n;\r\nelse\r\nmixer_vols[n].num = -1;\r\nfor (i = 0; i < 32; i++)\r\nmixer_vols[n].levels[i] = levels[i];\r\nreturn mixer_vols[n].levels;\r\n}\r\nstatic int set_mixer_levels(void __user * arg)\r\n{\r\nmixer_vol_table buf;\r\nif (__copy_from_user(&buf, arg, sizeof(buf)))\r\nreturn -EFAULT;\r\nload_mixer_volumes(buf.name, buf.levels, 0);\r\nif (__copy_to_user(arg, &buf, sizeof(buf)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_mixer_levels(void __user * arg)\r\n{\r\nint n;\r\nif (__get_user(n, (int __user *)(&(((mixer_vol_table __user *)arg)->num))))\r\nreturn -EFAULT;\r\nif (n < 0 || n >= num_mixer_volumes)\r\nreturn -EINVAL;\r\nif (__copy_to_user(arg, &mixer_vols[n], sizeof(mixer_vol_table)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic ssize_t sound_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nint dev = iminor(file->f_path.dentry->d_inode);\r\nint ret = -EINVAL;\r\nmutex_lock(&soundcard_mutex);\r\nDEB(printk("sound_read(dev=%d, count=%d)\n", dev, count));\r\nswitch (dev & 0x0f) {\r\ncase SND_DEV_DSP:\r\ncase SND_DEV_DSP16:\r\ncase SND_DEV_AUDIO:\r\nret = audio_read(dev, file, buf, count);\r\nbreak;\r\ncase SND_DEV_SEQ:\r\ncase SND_DEV_SEQ2:\r\nret = sequencer_read(dev, file, buf, count);\r\nbreak;\r\ncase SND_DEV_MIDIN:\r\nret = MIDIbuf_read(dev, file, buf, count);\r\n}\r\nmutex_unlock(&soundcard_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t sound_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\r\n{\r\nint dev = iminor(file->f_path.dentry->d_inode);\r\nint ret = -EINVAL;\r\nmutex_lock(&soundcard_mutex);\r\nDEB(printk("sound_write(dev=%d, count=%d)\n", dev, count));\r\nswitch (dev & 0x0f) {\r\ncase SND_DEV_SEQ:\r\ncase SND_DEV_SEQ2:\r\nret = sequencer_write(dev, file, buf, count);\r\nbreak;\r\ncase SND_DEV_DSP:\r\ncase SND_DEV_DSP16:\r\ncase SND_DEV_AUDIO:\r\nret = audio_write(dev, file, buf, count);\r\nbreak;\r\ncase SND_DEV_MIDIN:\r\nret = MIDIbuf_write(dev, file, buf, count);\r\nbreak;\r\n}\r\nmutex_unlock(&soundcard_mutex);\r\nreturn ret;\r\n}\r\nstatic int sound_open(struct inode *inode, struct file *file)\r\n{\r\nint dev = iminor(inode);\r\nint retval;\r\nDEB(printk("sound_open(dev=%d)\n", dev));\r\nif ((dev >= SND_NDEVS) || (dev < 0)) {\r\nprintk(KERN_ERR "Invalid minor device %d\n", dev);\r\nreturn -ENXIO;\r\n}\r\nmutex_lock(&soundcard_mutex);\r\nswitch (dev & 0x0f) {\r\ncase SND_DEV_CTL:\r\ndev >>= 4;\r\nif (dev >= 0 && dev < MAX_MIXER_DEV && mixer_devs[dev] == NULL) {\r\nrequest_module("mixer%d", dev);\r\n}\r\nretval = -ENXIO;\r\nif (dev && (dev >= num_mixers || mixer_devs[dev] == NULL))\r\nbreak;\r\nif (!try_module_get(mixer_devs[dev]->owner))\r\nbreak;\r\nretval = 0;\r\nbreak;\r\ncase SND_DEV_SEQ:\r\ncase SND_DEV_SEQ2:\r\nretval = sequencer_open(dev, file);\r\nbreak;\r\ncase SND_DEV_MIDIN:\r\nretval = MIDIbuf_open(dev, file);\r\nbreak;\r\ncase SND_DEV_DSP:\r\ncase SND_DEV_DSP16:\r\ncase SND_DEV_AUDIO:\r\nretval = audio_open(dev, file);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Invalid minor device %d\n", dev);\r\nretval = -ENXIO;\r\n}\r\nmutex_unlock(&soundcard_mutex);\r\nreturn retval;\r\n}\r\nstatic int sound_release(struct inode *inode, struct file *file)\r\n{\r\nint dev = iminor(inode);\r\nmutex_lock(&soundcard_mutex);\r\nDEB(printk("sound_release(dev=%d)\n", dev));\r\nswitch (dev & 0x0f) {\r\ncase SND_DEV_CTL:\r\nmodule_put(mixer_devs[dev >> 4]->owner);\r\nbreak;\r\ncase SND_DEV_SEQ:\r\ncase SND_DEV_SEQ2:\r\nsequencer_release(dev, file);\r\nbreak;\r\ncase SND_DEV_MIDIN:\r\nMIDIbuf_release(dev, file);\r\nbreak;\r\ncase SND_DEV_DSP:\r\ncase SND_DEV_DSP16:\r\ncase SND_DEV_AUDIO:\r\naudio_release(dev, file);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Sound error: Releasing unknown device 0x%02x\n", dev);\r\n}\r\nmutex_unlock(&soundcard_mutex);\r\nreturn 0;\r\n}\r\nstatic int get_mixer_info(int dev, void __user *arg)\r\n{\r\nmixer_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.id, mixer_devs[dev]->id, sizeof(info.id));\r\nstrlcpy(info.name, mixer_devs[dev]->name, sizeof(info.name));\r\ninfo.modify_counter = mixer_devs[dev]->modify_counter;\r\nif (__copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_old_mixer_info(int dev, void __user *arg)\r\n{\r\n_old_mixer_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.id, mixer_devs[dev]->id, sizeof(info.id));\r\nstrlcpy(info.name, mixer_devs[dev]->name, sizeof(info.name));\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int sound_mixer_ioctl(int mixdev, unsigned int cmd, void __user *arg)\r\n{\r\nif (mixdev < 0 || mixdev >= MAX_MIXER_DEV)\r\nreturn -ENXIO;\r\nif (mixer_devs[mixdev] == NULL) {\r\nrequest_module("mixer%d", mixdev);\r\n}\r\nif (mixdev >= num_mixers || !mixer_devs[mixdev])\r\nreturn -ENXIO;\r\nif (cmd == SOUND_MIXER_INFO)\r\nreturn get_mixer_info(mixdev, arg);\r\nif (cmd == SOUND_OLD_MIXER_INFO)\r\nreturn get_old_mixer_info(mixdev, arg);\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE)\r\nmixer_devs[mixdev]->modify_counter++;\r\nif (!mixer_devs[mixdev]->ioctl)\r\nreturn -EINVAL;\r\nreturn mixer_devs[mixdev]->ioctl(mixdev, cmd, arg);\r\n}\r\nstatic long sound_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint len = 0, dtype;\r\nint dev = iminor(file->f_dentry->d_inode);\r\nlong ret = -EINVAL;\r\nvoid __user *p = (void __user *)arg;\r\nif (_SIOC_DIR(cmd) != _SIOC_NONE && _SIOC_DIR(cmd) != 0) {\r\nlen = _SIOC_SIZE(cmd);\r\nif (len < 1 || len > 65536 || !p)\r\nreturn -EFAULT;\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE)\r\nif (!access_ok(VERIFY_READ, p, len))\r\nreturn -EFAULT;\r\nif (_SIOC_DIR(cmd) & _SIOC_READ)\r\nif (!access_ok(VERIFY_WRITE, p, len))\r\nreturn -EFAULT;\r\n}\r\nDEB(printk("sound_ioctl(dev=%d, cmd=0x%x, arg=0x%x)\n", dev, cmd, arg));\r\nif (cmd == OSS_GETVERSION)\r\nreturn __put_user(SOUND_VERSION, (int __user *)p);\r\nmutex_lock(&soundcard_mutex);\r\nif (_IOC_TYPE(cmd) == 'M' && num_mixers > 0 &&\r\n(dev & 0x0f) != SND_DEV_CTL) {\r\ndtype = dev & 0x0f;\r\nswitch (dtype) {\r\ncase SND_DEV_DSP:\r\ncase SND_DEV_DSP16:\r\ncase SND_DEV_AUDIO:\r\nret = sound_mixer_ioctl(audio_devs[dev >> 4]->mixer_dev,\r\ncmd, p);\r\nbreak;\r\ndefault:\r\nret = sound_mixer_ioctl(dev >> 4, cmd, p);\r\nbreak;\r\n}\r\nmutex_unlock(&soundcard_mutex);\r\nreturn ret;\r\n}\r\nswitch (dev & 0x0f) {\r\ncase SND_DEV_CTL:\r\nif (cmd == SOUND_MIXER_GETLEVELS)\r\nret = get_mixer_levels(p);\r\nelse if (cmd == SOUND_MIXER_SETLEVELS)\r\nret = set_mixer_levels(p);\r\nelse\r\nret = sound_mixer_ioctl(dev >> 4, cmd, p);\r\nbreak;\r\ncase SND_DEV_SEQ:\r\ncase SND_DEV_SEQ2:\r\nret = sequencer_ioctl(dev, file, cmd, p);\r\nbreak;\r\ncase SND_DEV_DSP:\r\ncase SND_DEV_DSP16:\r\ncase SND_DEV_AUDIO:\r\nret = audio_ioctl(dev, file, cmd, p);\r\nbreak;\r\ncase SND_DEV_MIDIN:\r\nret = MIDIbuf_ioctl(dev, file, cmd, p);\r\nbreak;\r\n}\r\nmutex_unlock(&soundcard_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int sound_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nint dev = iminor(inode);\r\nDEB(printk("sound_poll(dev=%d)\n", dev));\r\nswitch (dev & 0x0f) {\r\ncase SND_DEV_SEQ:\r\ncase SND_DEV_SEQ2:\r\nreturn sequencer_poll(dev, file, wait);\r\ncase SND_DEV_MIDIN:\r\nreturn MIDIbuf_poll(dev, file, wait);\r\ncase SND_DEV_DSP:\r\ncase SND_DEV_DSP16:\r\ncase SND_DEV_AUDIO:\r\nreturn DMAbuf_poll(file, dev >> 4, wait);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sound_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nint dev_class;\r\nunsigned long size;\r\nstruct dma_buffparms *dmap = NULL;\r\nint dev = iminor(file->f_path.dentry->d_inode);\r\ndev_class = dev & 0x0f;\r\ndev >>= 4;\r\nif (dev_class != SND_DEV_DSP && dev_class != SND_DEV_DSP16 && dev_class != SND_DEV_AUDIO) {\r\nprintk(KERN_ERR "Sound: mmap() not supported for other than audio devices\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&soundcard_mutex);\r\nif (vma->vm_flags & VM_WRITE)\r\ndmap = audio_devs[dev]->dmap_out;\r\nelse if (vma->vm_flags & VM_READ)\r\ndmap = audio_devs[dev]->dmap_in;\r\nelse {\r\nprintk(KERN_ERR "Sound: Undefined mmap() access\n");\r\nmutex_unlock(&soundcard_mutex);\r\nreturn -EINVAL;\r\n}\r\nif (dmap == NULL) {\r\nprintk(KERN_ERR "Sound: mmap() error. dmap == NULL\n");\r\nmutex_unlock(&soundcard_mutex);\r\nreturn -EIO;\r\n}\r\nif (dmap->raw_buf == NULL) {\r\nprintk(KERN_ERR "Sound: mmap() called when raw_buf == NULL\n");\r\nmutex_unlock(&soundcard_mutex);\r\nreturn -EIO;\r\n}\r\nif (dmap->mapping_flags) {\r\nprintk(KERN_ERR "Sound: mmap() called twice for the same DMA buffer\n");\r\nmutex_unlock(&soundcard_mutex);\r\nreturn -EIO;\r\n}\r\nif (vma->vm_pgoff != 0) {\r\nprintk(KERN_ERR "Sound: mmap() offset must be 0.\n");\r\nmutex_unlock(&soundcard_mutex);\r\nreturn -EINVAL;\r\n}\r\nsize = vma->vm_end - vma->vm_start;\r\nif (size != dmap->bytes_in_use) {\r\nprintk(KERN_WARNING "Sound: mmap() size = %ld. Should be %d\n", size, dmap->bytes_in_use);\r\n}\r\nif (remap_pfn_range(vma, vma->vm_start,\r\nvirt_to_phys(dmap->raw_buf) >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot)) {\r\nmutex_unlock(&soundcard_mutex);\r\nreturn -EAGAIN;\r\n}\r\ndmap->mapping_flags |= DMA_MAP_MAPPED;\r\nif( audio_devs[dev]->d->mmap)\r\naudio_devs[dev]->d->mmap(dev);\r\nmemset(dmap->raw_buf,\r\ndmap->neutral_byte,\r\ndmap->bytes_in_use);\r\nmutex_unlock(&soundcard_mutex);\r\nreturn 0;\r\n}\r\nstatic int create_special_devices(void)\r\n{\r\nint seq1,seq2;\r\nseq1=register_sound_special(&oss_sound_fops, 1);\r\nif(seq1==-1)\r\ngoto bad;\r\nseq2=register_sound_special(&oss_sound_fops, 8);\r\nif(seq2!=-1)\r\nreturn 0;\r\nunregister_sound_special(1);\r\nbad:\r\nreturn -1;\r\n}\r\nstatic int __init oss_init(void)\r\n{\r\nint err;\r\nint i, j;\r\n#ifdef CONFIG_PCI\r\nif(dmabug)\r\nisa_dma_bridge_buggy = dmabug;\r\n#endif\r\nerr = create_special_devices();\r\nif (err) {\r\nprintk(KERN_ERR "sound: driver already loaded/included in kernel\n");\r\nreturn err;\r\n}\r\nsound_dmap_flag = (dmabuf > 0 ? 1 : 0);\r\nfor (i = 0; i < ARRAY_SIZE(dev_list); i++) {\r\nj = 0;\r\ndo {\r\nunsigned short minor = dev_list[i].minor + j * 0x10;\r\nif (!register_sound_special(&oss_sound_fops, minor))\r\ndev_list[i].enabled = (1 << j);\r\n} while (++j < num_audiodevs);\r\n}\r\nif (sound_nblocks >= MAX_MEM_BLOCKS - 1)\r\nprintk(KERN_ERR "Sound warning: Deallocation table was too small.\n");\r\nreturn 0;\r\n}\r\nstatic void __exit oss_cleanup(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(dev_list); i++) {\r\nj = 0;\r\ndo {\r\nif (dev_list[i].enabled & (1 << j))\r\nunregister_sound_special(dev_list[i].minor);\r\n} while (++j < num_audiodevs);\r\n}\r\nunregister_sound_special(1);\r\nunregister_sound_special(8);\r\nsound_stop_timer();\r\nsequencer_unload();\r\nfor (i = 0; i < MAX_DMA_CHANNELS; i++)\r\nif (dma_alloc_map[i] != DMA_MAP_UNAVAIL) {\r\nprintk(KERN_ERR "Sound: Hmm, DMA%d was left allocated - fixed\n", i);\r\nsound_free_dma(i);\r\n}\r\nfor (i = 0; i < sound_nblocks; i++)\r\nvfree(sound_mem_blocks[i]);\r\n}\r\nint sound_alloc_dma(int chn, char *deviceID)\r\n{\r\nint err;\r\nif ((err = request_dma(chn, deviceID)) != 0)\r\nreturn err;\r\ndma_alloc_map[chn] = DMA_MAP_FREE;\r\nreturn 0;\r\n}\r\nint sound_open_dma(int chn, char *deviceID)\r\n{\r\nif (!valid_dma(chn)) {\r\nprintk(KERN_ERR "sound_open_dma: Invalid DMA channel %d\n", chn);\r\nreturn 1;\r\n}\r\nif (dma_alloc_map[chn] != DMA_MAP_FREE) {\r\nprintk("sound_open_dma: DMA channel %d busy or not allocated (%d)\n", chn, dma_alloc_map[chn]);\r\nreturn 1;\r\n}\r\ndma_alloc_map[chn] = DMA_MAP_BUSY;\r\nreturn 0;\r\n}\r\nvoid sound_free_dma(int chn)\r\n{\r\nif (dma_alloc_map[chn] == DMA_MAP_UNAVAIL) {\r\nreturn;\r\n}\r\nfree_dma(chn);\r\ndma_alloc_map[chn] = DMA_MAP_UNAVAIL;\r\n}\r\nvoid sound_close_dma(int chn)\r\n{\r\nif (dma_alloc_map[chn] != DMA_MAP_BUSY) {\r\nprintk(KERN_ERR "sound_close_dma: Bad access to DMA channel %d\n", chn);\r\nreturn;\r\n}\r\ndma_alloc_map[chn] = DMA_MAP_FREE;\r\n}\r\nstatic void do_sequencer_timer(unsigned long dummy)\r\n{\r\nsequencer_timer(0);\r\n}\r\nvoid request_sound_timer(int count)\r\n{\r\nextern unsigned long seq_time;\r\nif (count < 0) {\r\nseq_timer.expires = (-count) + jiffies;\r\nadd_timer(&seq_timer);\r\nreturn;\r\n}\r\ncount += seq_time;\r\ncount -= jiffies;\r\nif (count < 1)\r\ncount = 1;\r\nseq_timer.expires = (count) + jiffies;\r\nadd_timer(&seq_timer);\r\n}\r\nvoid sound_stop_timer(void)\r\n{\r\ndel_timer(&seq_timer);\r\n}\r\nvoid conf_printf(char *name, struct address_info *hw_config)\r\n{\r\n#ifndef CONFIG_SOUND_TRACEINIT\r\nreturn;\r\n#else\r\nprintk("<%s> at 0x%03x", name, hw_config->io_base);\r\nif (hw_config->irq)\r\nprintk(" irq %d", (hw_config->irq > 0) ? hw_config->irq : -hw_config->irq);\r\nif (hw_config->dma != -1 || hw_config->dma2 != -1)\r\n{\r\nprintk(" dma %d", hw_config->dma);\r\nif (hw_config->dma2 != -1)\r\nprintk(",%d", hw_config->dma2);\r\n}\r\nprintk("\n");\r\n#endif\r\n}\r\nvoid conf_printf2(char *name, int base, int irq, int dma, int dma2)\r\n{\r\n#ifndef CONFIG_SOUND_TRACEINIT\r\nreturn;\r\n#else\r\nprintk("<%s> at 0x%03x", name, base);\r\nif (irq)\r\nprintk(" irq %d", (irq > 0) ? irq : -irq);\r\nif (dma != -1 || dma2 != -1)\r\n{\r\nprintk(" dma %d", dma);\r\nif (dma2 != -1)\r\nprintk(",%d", dma2);\r\n}\r\nprintk("\n");\r\n#endif\r\n}
