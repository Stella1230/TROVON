static struct sh_mobile_ceu_buffer *to_ceu_vb(struct vb2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct sh_mobile_ceu_buffer, vb);\r\n}\r\nstatic void ceu_write(struct sh_mobile_ceu_dev *priv,\r\nunsigned long reg_offs, u32 data)\r\n{\r\niowrite32(data, priv->base + reg_offs);\r\n}\r\nstatic u32 ceu_read(struct sh_mobile_ceu_dev *priv, unsigned long reg_offs)\r\n{\r\nreturn ioread32(priv->base + reg_offs);\r\n}\r\nstatic int sh_mobile_ceu_soft_reset(struct sh_mobile_ceu_dev *pcdev)\r\n{\r\nint i, success = 0;\r\nstruct soc_camera_device *icd = pcdev->icd;\r\nceu_write(pcdev, CAPSR, 1 << 16);\r\nfor (i = 0; i < 1000; i++) {\r\nif (!(ceu_read(pcdev, CSTSR) & 1)) {\r\nsuccess++;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nfor (i = 0; i < 1000; i++) {\r\nif (!(ceu_read(pcdev, CAPSR) & (1 << 16))) {\r\nsuccess++;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (2 != success) {\r\ndev_warn(icd->pdev, "soft reset time out\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_ceu_videobuf_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *count, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct soc_camera_device *icd = container_of(vq, struct soc_camera_device, vb2_vidq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nif (fmt) {\r\nconst struct soc_camera_format_xlate *xlate = soc_camera_xlate_by_fourcc(icd,\r\nfmt->fmt.pix.pixelformat);\r\nunsigned int bytes_per_line;\r\nint ret;\r\nif (!xlate)\r\nreturn -EINVAL;\r\nret = soc_mbus_bytes_per_line(fmt->fmt.pix.width,\r\nxlate->host_fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nbytes_per_line = max_t(u32, fmt->fmt.pix.bytesperline, ret);\r\nret = soc_mbus_image_size(xlate->host_fmt, bytes_per_line,\r\nfmt->fmt.pix.height);\r\nif (ret < 0)\r\nreturn ret;\r\nsizes[0] = max_t(u32, fmt->fmt.pix.sizeimage, ret);\r\n} else {\r\nsizes[0] = icd->sizeimage;\r\n}\r\nalloc_ctxs[0] = pcdev->alloc_ctx;\r\nif (!vq->num_buffers)\r\npcdev->sequence = 0;\r\nif (!*count)\r\n*count = 2;\r\nif (pcdev->video_limit && !*num_planes) {\r\nsize_t size = PAGE_ALIGN(sizes[0]) * *count;\r\nif (size + pcdev->buf_total > pcdev->video_limit)\r\n*count = (pcdev->video_limit - pcdev->buf_total) /\r\nPAGE_ALIGN(sizes[0]);\r\n}\r\n*num_planes = 1;\r\ndev_dbg(icd->parent, "count=%d, size=%u\n", *count, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_ceu_capture(struct sh_mobile_ceu_dev *pcdev)\r\n{\r\nstruct soc_camera_device *icd = pcdev->icd;\r\ndma_addr_t phys_addr_top, phys_addr_bottom;\r\nunsigned long top1, top2;\r\nunsigned long bottom1, bottom2;\r\nu32 status;\r\nbool planar;\r\nint ret = 0;\r\nceu_write(pcdev, CEIER, ceu_read(pcdev, CEIER) & ~CEU_CEIER_MASK);\r\nstatus = ceu_read(pcdev, CETCR);\r\nceu_write(pcdev, CETCR, ~status & CEU_CETCR_MAGIC);\r\nif (!pcdev->frozen)\r\nceu_write(pcdev, CEIER, ceu_read(pcdev, CEIER) | CEU_CEIER_MASK);\r\nceu_write(pcdev, CAPCR, ceu_read(pcdev, CAPCR) & ~CEU_CAPCR_CTNCP);\r\nceu_write(pcdev, CETCR, CEU_CETCR_MAGIC ^ CEU_CETCR_IGRW);\r\nif (status & CEU_CEIER_VBP) {\r\nsh_mobile_ceu_soft_reset(pcdev);\r\nret = -EIO;\r\n}\r\nif (pcdev->frozen) {\r\ncomplete(&pcdev->complete);\r\nreturn ret;\r\n}\r\nif (!pcdev->active)\r\nreturn ret;\r\nif (V4L2_FIELD_INTERLACED_BT == pcdev->field) {\r\ntop1 = CDBYR;\r\ntop2 = CDBCR;\r\nbottom1 = CDAYR;\r\nbottom2 = CDACR;\r\n} else {\r\ntop1 = CDAYR;\r\ntop2 = CDACR;\r\nbottom1 = CDBYR;\r\nbottom2 = CDBCR;\r\n}\r\nphys_addr_top = vb2_dma_contig_plane_dma_addr(pcdev->active, 0);\r\nswitch (icd->current_fmt->host_fmt->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nplanar = true;\r\nbreak;\r\ndefault:\r\nplanar = false;\r\n}\r\nceu_write(pcdev, top1, phys_addr_top);\r\nif (V4L2_FIELD_NONE != pcdev->field) {\r\nphys_addr_bottom = phys_addr_top + icd->bytesperline;\r\nceu_write(pcdev, bottom1, phys_addr_bottom);\r\n}\r\nif (planar) {\r\nphys_addr_top += icd->bytesperline * icd->user_height;\r\nceu_write(pcdev, top2, phys_addr_top);\r\nif (V4L2_FIELD_NONE != pcdev->field) {\r\nphys_addr_bottom = phys_addr_top + icd->bytesperline;\r\nceu_write(pcdev, bottom2, phys_addr_bottom);\r\n}\r\n}\r\nceu_write(pcdev, CAPSR, 0x1);\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_ceu_videobuf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct sh_mobile_ceu_buffer *buf = to_ceu_vb(vb);\r\nWARN(!list_empty(&buf->queue), "Buffer %p on queue!\n", vb);\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_ceu_videobuf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = container_of(vb->vb2_queue, struct soc_camera_device, vb2_vidq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct sh_mobile_ceu_buffer *buf = to_ceu_vb(vb);\r\nunsigned long size;\r\nsize = icd->sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndev_err(icd->parent, "Buffer #%d too small (%lu < %lu)\n",\r\nvb->v4l2_buf.index, vb2_plane_size(vb, 0), size);\r\ngoto error;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%p %lu\n", __func__,\r\nvb, vb2_plane_vaddr(vb, 0), vb2_get_plane_payload(vb, 0));\r\n#ifdef DEBUG\r\nif (vb2_plane_vaddr(vb, 0))\r\nmemset(vb2_plane_vaddr(vb, 0), 0xaa, vb2_get_plane_payload(vb, 0));\r\n#endif\r\nspin_lock_irq(&pcdev->lock);\r\nlist_add_tail(&buf->queue, &pcdev->capture);\r\nif (!pcdev->active) {\r\npcdev->active = vb;\r\nsh_mobile_ceu_capture(pcdev);\r\n}\r\nspin_unlock_irq(&pcdev->lock);\r\nreturn;\r\nerror:\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\n}\r\nstatic void sh_mobile_ceu_videobuf_release(struct vb2_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = container_of(vb->vb2_queue, struct soc_camera_device, vb2_vidq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_buffer *buf = to_ceu_vb(vb);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nspin_lock_irq(&pcdev->lock);\r\nif (pcdev->active == vb) {\r\nceu_write(pcdev, CAPSR, 1 << 16);\r\npcdev->active = NULL;\r\n}\r\nif (buf->queue.next)\r\nlist_del_init(&buf->queue);\r\npcdev->buf_total -= PAGE_ALIGN(vb2_plane_size(vb, 0));\r\ndev_dbg(icd->parent, "%s() %zu bytes buffers\n", __func__,\r\npcdev->buf_total);\r\nspin_unlock_irq(&pcdev->lock);\r\n}\r\nstatic int sh_mobile_ceu_videobuf_init(struct vb2_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = container_of(vb->vb2_queue, struct soc_camera_device, vb2_vidq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\npcdev->buf_total += PAGE_ALIGN(vb2_plane_size(vb, 0));\r\ndev_dbg(icd->parent, "%s() %zu bytes buffers\n", __func__,\r\npcdev->buf_total);\r\nINIT_LIST_HEAD(&to_ceu_vb(vb)->queue);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_ceu_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct soc_camera_device *icd = container_of(q, struct soc_camera_device, vb2_vidq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct list_head *buf_head, *tmp;\r\nspin_lock_irq(&pcdev->lock);\r\npcdev->active = NULL;\r\nlist_for_each_safe(buf_head, tmp, &pcdev->capture)\r\nlist_del_init(buf_head);\r\nspin_unlock_irq(&pcdev->lock);\r\nreturn sh_mobile_ceu_soft_reset(pcdev);\r\n}\r\nstatic irqreturn_t sh_mobile_ceu_irq(int irq, void *data)\r\n{\r\nstruct sh_mobile_ceu_dev *pcdev = data;\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nspin_lock(&pcdev->lock);\r\nvb = pcdev->active;\r\nif (!vb)\r\ngoto out;\r\nlist_del_init(&to_ceu_vb(vb)->queue);\r\nif (!list_empty(&pcdev->capture))\r\npcdev->active = &list_entry(pcdev->capture.next,\r\nstruct sh_mobile_ceu_buffer, queue)->vb;\r\nelse\r\npcdev->active = NULL;\r\nret = sh_mobile_ceu_capture(pcdev);\r\ndo_gettimeofday(&vb->v4l2_buf.timestamp);\r\nif (!ret) {\r\nvb->v4l2_buf.field = pcdev->field;\r\nvb->v4l2_buf.sequence = pcdev->sequence++;\r\n}\r\nvb2_buffer_done(vb, ret < 0 ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\nout:\r\nspin_unlock(&pcdev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct v4l2_subdev *find_csi2(struct sh_mobile_ceu_dev *pcdev)\r\n{\r\nstruct v4l2_subdev *sd;\r\nif (!pcdev->csi2_pdev)\r\nreturn NULL;\r\nv4l2_device_for_each_subdev(sd, &pcdev->ici.v4l2_dev)\r\nif (&pcdev->csi2_pdev->dev == v4l2_get_subdevdata(sd))\r\nreturn sd;\r\nreturn NULL;\r\n}\r\nstatic int sh_mobile_ceu_add_device(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *csi2_sd;\r\nint ret;\r\nif (pcdev->icd)\r\nreturn -EBUSY;\r\ndev_info(icd->parent,\r\n"SuperH Mobile CEU driver attached to camera %d\n",\r\nicd->devnum);\r\npm_runtime_get_sync(ici->v4l2_dev.dev);\r\npcdev->buf_total = 0;\r\nret = sh_mobile_ceu_soft_reset(pcdev);\r\ncsi2_sd = find_csi2(pcdev);\r\nif (csi2_sd) {\r\ncsi2_sd->grp_id = soc_camera_grp_id(icd);\r\nv4l2_set_subdev_hostdata(csi2_sd, icd);\r\n}\r\nret = v4l2_subdev_call(csi2_sd, core, s_power, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV) {\r\npm_runtime_put_sync(ici->v4l2_dev.dev);\r\nreturn ret;\r\n}\r\nif (ret == -ENODEV && csi2_sd)\r\ncsi2_sd->grp_id = 0;\r\npcdev->icd = icd;\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_ceu_remove_device(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *csi2_sd = find_csi2(pcdev);\r\nBUG_ON(icd != pcdev->icd);\r\nv4l2_subdev_call(csi2_sd, core, s_power, 0);\r\nif (csi2_sd)\r\ncsi2_sd->grp_id = 0;\r\nceu_write(pcdev, CEIER, 0);\r\nsh_mobile_ceu_soft_reset(pcdev);\r\nspin_lock_irq(&pcdev->lock);\r\nif (pcdev->active) {\r\nlist_del_init(&to_ceu_vb(pcdev->active)->queue);\r\nvb2_buffer_done(pcdev->active, VB2_BUF_STATE_ERROR);\r\npcdev->active = NULL;\r\n}\r\nspin_unlock_irq(&pcdev->lock);\r\npm_runtime_put_sync(ici->v4l2_dev.dev);\r\ndev_info(icd->parent,\r\n"SuperH Mobile CEU driver detached from camera %d\n",\r\nicd->devnum);\r\npcdev->icd = NULL;\r\n}\r\nstatic unsigned int size_dst(unsigned int src, unsigned int scale)\r\n{\r\nunsigned int mant_pre = scale >> 12;\r\nif (!src || !scale)\r\nreturn src;\r\nreturn ((mant_pre + 2 * (src - 1)) / (2 * mant_pre) - 1) *\r\nmant_pre * 4096 / scale + 1;\r\n}\r\nstatic u16 calc_scale(unsigned int src, unsigned int *dst)\r\n{\r\nu16 scale;\r\nif (src == *dst)\r\nreturn 0;\r\nscale = (src * 4096 / *dst) & ~7;\r\nwhile (scale > 4096 && size_dst(src, scale) < *dst)\r\nscale -= 8;\r\n*dst = size_dst(src, scale);\r\nreturn scale;\r\n}\r\nstatic void sh_mobile_ceu_set_rect(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nunsigned int height, width, cdwdr_width, in_width, in_height;\r\nunsigned int left_offset, top_offset;\r\nu32 camor;\r\ndev_geo(icd->parent, "Crop %ux%u@%u:%u\n",\r\nicd->user_width, icd->user_height, cam->ceu_left, cam->ceu_top);\r\nleft_offset = cam->ceu_left;\r\ntop_offset = cam->ceu_top;\r\nWARN_ON(icd->user_width & 3 || icd->user_height & 3);\r\nwidth = icd->user_width;\r\nif (pcdev->image_mode) {\r\nin_width = cam->width;\r\nif (!pcdev->is_16bit) {\r\nin_width *= 2;\r\nleft_offset *= 2;\r\n}\r\n} else {\r\nunsigned int w_factor;\r\nswitch (icd->current_fmt->host_fmt->packing) {\r\ncase SOC_MBUS_PACKING_2X8_PADHI:\r\nw_factor = 2;\r\nbreak;\r\ndefault:\r\nw_factor = 1;\r\n}\r\nin_width = cam->width * w_factor;\r\nleft_offset *= w_factor;\r\n}\r\ncdwdr_width = icd->bytesperline;\r\nheight = icd->user_height;\r\nin_height = cam->height;\r\nif (V4L2_FIELD_NONE != pcdev->field) {\r\nheight = (height / 2) & ~3;\r\nin_height /= 2;\r\ntop_offset /= 2;\r\ncdwdr_width *= 2;\r\n}\r\nif (pcdev->pdata->csi2) {\r\nin_width = ((in_width - 2) * 2);\r\nleft_offset *= 2;\r\n}\r\ncamor = left_offset | (top_offset << 16);\r\ndev_geo(icd->parent,\r\n"CAMOR 0x%x, CAPWR 0x%x, CFSZR 0x%x, CDWDR 0x%x\n", camor,\r\n(in_height << 16) | in_width, (height << 16) | width,\r\ncdwdr_width);\r\nceu_write(pcdev, CAMOR, camor);\r\nceu_write(pcdev, CAPWR, (in_height << 16) | in_width);\r\nceu_write(pcdev, CFSZR, (height << 16) | width);\r\nceu_write(pcdev, CDWDR, cdwdr_width);\r\n}\r\nstatic u32 capture_save_reset(struct sh_mobile_ceu_dev *pcdev)\r\n{\r\nu32 capsr = ceu_read(pcdev, CAPSR);\r\nceu_write(pcdev, CAPSR, 1 << 16);\r\nreturn capsr;\r\n}\r\nstatic void capture_restore(struct sh_mobile_ceu_dev *pcdev, u32 capsr)\r\n{\r\nunsigned long timeout = jiffies + 10 * HZ;\r\nwhile ((ceu_read(pcdev, CSTSR) & 1) && time_before(jiffies, timeout))\r\nmsleep(1);\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(pcdev->ici.v4l2_dev.dev,\r\n"Timeout waiting for frame end! Interface problem?\n");\r\nreturn;\r\n}\r\nwhile (ceu_read(pcdev, CAPSR) & (1 << 16))\r\nudelay(10);\r\nif (capsr & ~(1 << 16))\r\nceu_write(pcdev, CAPSR, capsr);\r\n}\r\nstatic struct v4l2_subdev *find_bus_subdev(struct sh_mobile_ceu_dev *pcdev,\r\nstruct soc_camera_device *icd)\r\n{\r\nif (pcdev->csi2_pdev) {\r\nstruct v4l2_subdev *csi2_sd = find_csi2(pcdev);\r\nif (csi2_sd && csi2_sd->grp_id == soc_camera_grp_id(icd))\r\nreturn csi2_sd;\r\n}\r\nreturn soc_camera_to_subdev(icd);\r\n}\r\nstatic int sh_mobile_ceu_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = find_bus_subdev(pcdev, icd);\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long value, common_flags = CEU_BUS_FLAGS;\r\nu32 capsr = capture_save_reset(pcdev);\r\nunsigned int yuv_lineskip;\r\nint ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\ncommon_flags);\r\nif (!common_flags)\r\nreturn -EINVAL;\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n}\r\nif ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {\r\nif (pcdev->pdata->flags & SH_CEU_FLAG_HSYNC_LOW)\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {\r\nif (pcdev->pdata->flags & SH_CEU_FLAG_VSYNC_LOW)\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nif (icd->current_fmt->host_fmt->bits_per_sample > 8)\r\npcdev->is_16bit = 1;\r\nelse\r\npcdev->is_16bit = 0;\r\nceu_write(pcdev, CRCNTR, 0);\r\nceu_write(pcdev, CRCMPR, 0);\r\nvalue = 0x00000010;\r\nyuv_lineskip = 0x10;\r\nswitch (icd->current_fmt->host_fmt->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\nyuv_lineskip = 0;\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nswitch (cam->code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\nvalue = 0x00000000;\r\nbreak;\r\ncase V4L2_MBUS_FMT_VYUY8_2X8:\r\nvalue = 0x00000100;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\nvalue = 0x00000200;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YVYU8_2X8:\r\nvalue = 0x00000300;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nif (icd->current_fmt->host_fmt->fourcc == V4L2_PIX_FMT_NV21 ||\r\nicd->current_fmt->host_fmt->fourcc == V4L2_PIX_FMT_NV61)\r\nvalue ^= 0x00000100;\r\nvalue |= common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW ? 1 << 1 : 0;\r\nvalue |= common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW ? 1 << 0 : 0;\r\nif (pcdev->pdata->csi2)\r\nvalue |= 3 << 12;\r\nelse if (pcdev->is_16bit)\r\nvalue |= 1 << 12;\r\nelse if (pcdev->pdata->flags & SH_CEU_FLAG_LOWER_8BIT)\r\nvalue |= 2 << 12;\r\nceu_write(pcdev, CAMCR, value);\r\nceu_write(pcdev, CAPCR, 0x00300000);\r\nswitch (pcdev->field) {\r\ncase V4L2_FIELD_INTERLACED_TB:\r\nvalue = 0x101;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nvalue = 0x102;\r\nbreak;\r\ndefault:\r\nvalue = 0;\r\nbreak;\r\n}\r\nceu_write(pcdev, CAIFR, value);\r\nsh_mobile_ceu_set_rect(icd);\r\nmdelay(1);\r\ndev_geo(icd->parent, "CFLCR 0x%x\n", pcdev->cflcr);\r\nceu_write(pcdev, CFLCR, pcdev->cflcr);\r\nvalue = 0x00000007 | yuv_lineskip;\r\nceu_write(pcdev, CDOCR, value);\r\nceu_write(pcdev, CFWCR, 0);\r\ncapture_restore(pcdev, capsr);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_ceu_try_bus_param(struct soc_camera_device *icd,\r\nunsigned char buswidth)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = find_bus_subdev(pcdev, icd);\r\nunsigned long common_flags = CEU_BUS_FLAGS;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nint ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret)\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\ncommon_flags);\r\nelse if (ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nif (!common_flags || buswidth > 16)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic bool sh_mobile_ceu_packing_supported(const struct soc_mbus_pixelfmt *fmt)\r\n{\r\nreturn fmt->packing == SOC_MBUS_PACKING_NONE ||\r\n(fmt->bits_per_sample == 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_1_5X8) ||\r\n(fmt->bits_per_sample == 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_2X8_PADHI) ||\r\n(fmt->bits_per_sample > 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_EXTEND16);\r\n}\r\nstatic struct soc_camera_device *ctrl_to_icd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn container_of(ctrl->handler, struct soc_camera_device,\r\nctrl_handler);\r\n}\r\nstatic int sh_mobile_ceu_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct soc_camera_device *icd = ctrl_to_icd(ctrl);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_SHARPNESS:\r\nswitch (icd->current_fmt->host_fmt->fourcc) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nceu_write(pcdev, CLFCR, !ctrl->val);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sh_mobile_ceu_get_formats(struct soc_camera_device *icd, unsigned int idx,\r\nstruct soc_camera_format_xlate *xlate)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nint ret, k, n;\r\nint formats = 0;\r\nstruct sh_mobile_ceu_cam *cam;\r\nenum v4l2_mbus_pixelcode code;\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = soc_mbus_get_fmtdesc(code);\r\nif (!fmt) {\r\ndev_warn(dev, "unsupported format code #%u: %d\n", idx, code);\r\nreturn 0;\r\n}\r\nif (!pcdev->pdata->csi2) {\r\nret = sh_mobile_ceu_try_bus_param(icd, fmt->bits_per_sample);\r\nif (ret < 0)\r\nreturn 0;\r\n}\r\nif (!icd->host_priv) {\r\nstruct v4l2_mbus_framefmt mf;\r\nstruct v4l2_rect rect;\r\nint shift = 0;\r\nv4l2_ctrl_new_std(&icd->ctrl_handler, &sh_mobile_ceu_ctrl_ops,\r\nV4L2_CID_SHARPNESS, 0, 1, 1, 0);\r\nif (icd->ctrl_handler.error)\r\nreturn icd->ctrl_handler.error;\r\nret = client_g_rect(sd, &rect);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\nwhile ((mf.width > pcdev->max_width ||\r\nmf.height > pcdev->max_height) && shift < 4) {\r\nmf.width = 2560 >> shift;\r\nmf.height = 1920 >> shift;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), video,\r\ns_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\nshift++;\r\n}\r\nif (shift == 4) {\r\ndev_err(dev, "Failed to configure the client below %ux%x\n",\r\nmf.width, mf.height);\r\nreturn -EIO;\r\n}\r\ndev_geo(dev, "camera fmt %ux%u\n", mf.width, mf.height);\r\ncam = kzalloc(sizeof(*cam), GFP_KERNEL);\r\nif (!cam)\r\nreturn -ENOMEM;\r\ncam->rect = rect;\r\ncam->subrect = rect;\r\ncam->width = mf.width;\r\ncam->height = mf.height;\r\nicd->host_priv = cam;\r\n} else {\r\ncam = icd->host_priv;\r\n}\r\nif (!idx)\r\ncam->extra_fmt = NULL;\r\nswitch (code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ncase V4L2_MBUS_FMT_VYUY8_2X8:\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\ncase V4L2_MBUS_FMT_YVYU8_2X8:\r\nif (cam->extra_fmt)\r\nbreak;\r\ncam->extra_fmt = sh_mobile_ceu_formats;\r\nn = ARRAY_SIZE(sh_mobile_ceu_formats);\r\nformats += n;\r\nfor (k = 0; xlate && k < n; k++) {\r\nxlate->host_fmt = &sh_mobile_ceu_formats[k];\r\nxlate->code = code;\r\nxlate++;\r\ndev_dbg(dev, "Providing format %s using code %d\n",\r\nsh_mobile_ceu_formats[k].name, code);\r\n}\r\nbreak;\r\ndefault:\r\nif (!sh_mobile_ceu_packing_supported(fmt))\r\nreturn 0;\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code;\r\nxlate++;\r\ndev_dbg(dev, "Providing format %s in pass-through mode\n",\r\nfmt->name);\r\n}\r\nreturn formats;\r\n}\r\nstatic void sh_mobile_ceu_put_formats(struct soc_camera_device *icd)\r\n{\r\nkfree(icd->host_priv);\r\nicd->host_priv = NULL;\r\n}\r\nstatic bool is_smaller(struct v4l2_rect *r1, struct v4l2_rect *r2)\r\n{\r\nreturn r1->width < r2->width || r1->height < r2->height;\r\n}\r\nstatic bool is_inside(struct v4l2_rect *r1, struct v4l2_rect *r2)\r\n{\r\nreturn r1->left > r2->left || r1->top > r2->top ||\r\nr1->left + r1->width < r2->left + r2->width ||\r\nr1->top + r1->height < r2->top + r2->height;\r\n}\r\nstatic unsigned int scale_down(unsigned int size, unsigned int scale)\r\n{\r\nreturn (size * 4096 + scale / 2) / scale;\r\n}\r\nstatic unsigned int calc_generic_scale(unsigned int input, unsigned int output)\r\n{\r\nreturn (input * 4096 + output / 2) / output;\r\n}\r\nstatic int client_g_rect(struct v4l2_subdev *sd, struct v4l2_rect *rect)\r\n{\r\nstruct v4l2_crop crop;\r\nstruct v4l2_cropcap cap;\r\nint ret;\r\ncrop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = v4l2_subdev_call(sd, video, g_crop, &crop);\r\nif (!ret) {\r\n*rect = crop.c;\r\nreturn ret;\r\n}\r\ncap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = v4l2_subdev_call(sd, video, cropcap, &cap);\r\nif (!ret)\r\n*rect = cap.defrect;\r\nreturn ret;\r\n}\r\nstatic void update_subrect(struct sh_mobile_ceu_cam *cam)\r\n{\r\nstruct v4l2_rect *rect = &cam->rect, *subrect = &cam->subrect;\r\nif (rect->width < subrect->width)\r\nsubrect->width = rect->width;\r\nif (rect->height < subrect->height)\r\nsubrect->height = rect->height;\r\nif (rect->left > subrect->left)\r\nsubrect->left = rect->left;\r\nelse if (rect->left + rect->width >\r\nsubrect->left + subrect->width)\r\nsubrect->left = rect->left + rect->width -\r\nsubrect->width;\r\nif (rect->top > subrect->top)\r\nsubrect->top = rect->top;\r\nelse if (rect->top + rect->height >\r\nsubrect->top + subrect->height)\r\nsubrect->top = rect->top + rect->height -\r\nsubrect->height;\r\n}\r\nstatic int client_s_crop(struct soc_camera_device *icd, struct v4l2_crop *crop,\r\nstruct v4l2_crop *cam_crop)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct v4l2_rect *rect = &crop->c, *cam_rect = &cam_crop->c;\r\nstruct device *dev = sd->v4l2_dev->dev;\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\nstruct v4l2_cropcap cap;\r\nint ret;\r\nunsigned int width, height;\r\nv4l2_subdev_call(sd, video, s_crop, crop);\r\nret = client_g_rect(sd, cam_rect);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!memcmp(rect, cam_rect, sizeof(*rect))) {\r\ndev_dbg(dev, "Camera S_CROP successful for %dx%d@%d:%d\n",\r\nrect->width, rect->height, rect->left, rect->top);\r\ncam->rect = *cam_rect;\r\nreturn 0;\r\n}\r\ndev_geo(dev, "Fix camera S_CROP for %dx%d@%d:%d to %dx%d@%d:%d\n",\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top,\r\nrect->width, rect->height, rect->left, rect->top);\r\nret = v4l2_subdev_call(sd, video, cropcap, &cap);\r\nif (ret < 0)\r\nreturn ret;\r\nsoc_camera_limit_side(&rect->left, &rect->width, cap.bounds.left, 2,\r\ncap.bounds.width);\r\nsoc_camera_limit_side(&rect->top, &rect->height, cap.bounds.top, 4,\r\ncap.bounds.height);\r\nwidth = max(cam_rect->width, 2);\r\nheight = max(cam_rect->height, 2);\r\nwhile (!ret && (is_smaller(cam_rect, rect) ||\r\nis_inside(cam_rect, rect)) &&\r\n(cap.bounds.width > width || cap.bounds.height > height)) {\r\nwidth *= 2;\r\nheight *= 2;\r\ncam_rect->width = width;\r\ncam_rect->height = height;\r\nif (cam_rect->left > rect->left)\r\ncam_rect->left = cap.bounds.left;\r\nif (cam_rect->left + cam_rect->width < rect->left + rect->width)\r\ncam_rect->width = rect->left + rect->width -\r\ncam_rect->left;\r\nif (cam_rect->top > rect->top)\r\ncam_rect->top = cap.bounds.top;\r\nif (cam_rect->top + cam_rect->height < rect->top + rect->height)\r\ncam_rect->height = rect->top + rect->height -\r\ncam_rect->top;\r\nv4l2_subdev_call(sd, video, s_crop, cam_crop);\r\nret = client_g_rect(sd, cam_rect);\r\ndev_geo(dev, "Camera S_CROP %d for %dx%d@%d:%d\n", ret,\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top);\r\n}\r\nif (is_smaller(cam_rect, rect) || is_inside(cam_rect, rect)) {\r\n*cam_rect = cap.bounds;\r\nv4l2_subdev_call(sd, video, s_crop, cam_crop);\r\nret = client_g_rect(sd, cam_rect);\r\ndev_geo(dev, "Camera S_CROP %d for max %dx%d@%d:%d\n", ret,\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top);\r\n}\r\nif (!ret) {\r\ncam->rect = *cam_rect;\r\nupdate_subrect(cam);\r\n}\r\nreturn ret;\r\n}\r\nstatic int client_s_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_mbus_framefmt *mf, bool ceu_can_scale)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nunsigned int width = mf->width, height = mf->height, tmp_w, tmp_h;\r\nunsigned int max_width, max_height;\r\nstruct v4l2_cropcap cap;\r\nbool ceu_1to1;\r\nint ret;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), video,\r\ns_mbus_fmt, mf);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_geo(dev, "camera scaled to %ux%u\n", mf->width, mf->height);\r\nif (width == mf->width && height == mf->height) {\r\nceu_1to1 = true;\r\ngoto update_cache;\r\n}\r\nceu_1to1 = false;\r\nif (!ceu_can_scale)\r\ngoto update_cache;\r\ncap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nret = v4l2_subdev_call(sd, video, cropcap, &cap);\r\nif (ret < 0)\r\nreturn ret;\r\nmax_width = min(cap.bounds.width, pcdev->max_width);\r\nmax_height = min(cap.bounds.height, pcdev->max_height);\r\ntmp_w = mf->width;\r\ntmp_h = mf->height;\r\nwhile ((width > tmp_w || height > tmp_h) &&\r\ntmp_w < max_width && tmp_h < max_height) {\r\ntmp_w = min(2 * tmp_w, max_width);\r\ntmp_h = min(2 * tmp_h, max_height);\r\nmf->width = tmp_w;\r\nmf->height = tmp_h;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), video,\r\ns_mbus_fmt, mf);\r\ndev_geo(dev, "Camera scaled to %ux%u\n",\r\nmf->width, mf->height);\r\nif (ret < 0) {\r\ndev_err(dev, "Client failed to set format: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nupdate_cache:\r\nret = client_g_rect(sd, &cam->rect);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ceu_1to1)\r\ncam->subrect = cam->rect;\r\nelse\r\nupdate_subrect(cam);\r\nreturn 0;\r\n}\r\nstatic int client_scale(struct soc_camera_device *icd,\r\nstruct v4l2_mbus_framefmt *mf,\r\nunsigned int *width, unsigned int *height,\r\nbool ceu_can_scale)\r\n{\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\nstruct device *dev = icd->parent;\r\nstruct v4l2_mbus_framefmt mf_tmp = *mf;\r\nunsigned int scale_h, scale_v;\r\nint ret;\r\nret = client_s_fmt(icd, &mf_tmp, ceu_can_scale);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_geo(dev, "5: camera scaled to %ux%u\n",\r\nmf_tmp.width, mf_tmp.height);\r\nscale_h = calc_generic_scale(cam->rect.width, mf_tmp.width);\r\nscale_v = calc_generic_scale(cam->rect.height, mf_tmp.height);\r\nmf->width = mf_tmp.width;\r\nmf->height = mf_tmp.height;\r\nmf->colorspace = mf_tmp.colorspace;\r\n*width = scale_down(cam->subrect.width, scale_h);\r\n*height = scale_down(cam->subrect.height, scale_v);\r\ndev_geo(dev, "8: new client sub-window %ux%u\n", *width, *height);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_ceu_set_crop(struct soc_camera_device *icd,\r\nstruct v4l2_crop *a)\r\n{\r\nstruct v4l2_rect *rect = &a->c;\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct v4l2_crop cam_crop;\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\nstruct v4l2_rect *cam_rect = &cam_crop.c;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct v4l2_mbus_framefmt mf;\r\nunsigned int scale_cam_h, scale_cam_v, scale_ceu_h, scale_ceu_v,\r\nout_width, out_height;\r\nint interm_width, interm_height;\r\nu32 capsr, cflcr;\r\nint ret;\r\ndev_geo(dev, "S_CROP(%ux%u@%u:%u)\n", rect->width, rect->height,\r\nrect->left, rect->top);\r\ncapsr = capture_save_reset(pcdev);\r\ndev_dbg(dev, "CAPSR 0x%x, CFLCR 0x%x\n", capsr, pcdev->cflcr);\r\nret = client_s_crop(icd, a, &cam_crop);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_geo(dev, "1-2: camera cropped to %ux%u@%u:%u\n",\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top);\r\nret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mf.width > pcdev->max_width || mf.height > pcdev->max_height)\r\nreturn -EINVAL;\r\nscale_cam_h = calc_generic_scale(cam_rect->width, mf.width);\r\nscale_cam_v = calc_generic_scale(cam_rect->height, mf.height);\r\ninterm_width = scale_down(rect->width, scale_cam_h);\r\ninterm_height = scale_down(rect->height, scale_cam_v);\r\nif (interm_width < icd->user_width) {\r\nu32 new_scale_h;\r\nnew_scale_h = calc_generic_scale(rect->width, icd->user_width);\r\nmf.width = scale_down(cam_rect->width, new_scale_h);\r\n}\r\nif (interm_height < icd->user_height) {\r\nu32 new_scale_v;\r\nnew_scale_v = calc_generic_scale(rect->height, icd->user_height);\r\nmf.height = scale_down(cam_rect->height, new_scale_v);\r\n}\r\nif (interm_width < icd->user_width || interm_height < icd->user_height) {\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), video,\r\ns_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_geo(dev, "New camera output %ux%u\n", mf.width, mf.height);\r\nscale_cam_h = calc_generic_scale(cam_rect->width, mf.width);\r\nscale_cam_v = calc_generic_scale(cam_rect->height, mf.height);\r\ninterm_width = scale_down(rect->width, scale_cam_h);\r\ninterm_height = scale_down(rect->height, scale_cam_v);\r\n}\r\ncam->width = mf.width;\r\ncam->height = mf.height;\r\nif (pcdev->image_mode) {\r\nout_width = min(interm_width, icd->user_width);\r\nout_height = min(interm_height, icd->user_height);\r\n} else {\r\nout_width = interm_width;\r\nout_height = interm_height;\r\n}\r\nscale_ceu_h = calc_scale(interm_width, &out_width);\r\nscale_ceu_v = calc_scale(interm_height, &out_height);\r\ndev_geo(dev, "5: CEU scales %u:%u\n", scale_ceu_h, scale_ceu_v);\r\ncflcr = scale_ceu_h | (scale_ceu_v << 16);\r\nif (cflcr != pcdev->cflcr) {\r\npcdev->cflcr = cflcr;\r\nceu_write(pcdev, CFLCR, cflcr);\r\n}\r\nicd->user_width = out_width & ~3;\r\nicd->user_height = out_height & ~3;\r\ncam->ceu_left = scale_down(rect->left - cam_rect->left, scale_cam_h) & ~1;\r\ncam->ceu_top = scale_down(rect->top - cam_rect->top, scale_cam_v) & ~1;\r\nsh_mobile_ceu_set_rect(icd);\r\ncam->subrect = *rect;\r\ndev_geo(dev, "6: CEU cropped to %ux%u@%u:%u\n",\r\nicd->user_width, icd->user_height,\r\ncam->ceu_left, cam->ceu_top);\r\nif (pcdev->active)\r\ncapsr |= 1;\r\ncapture_restore(pcdev, capsr);\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_ceu_get_crop(struct soc_camera_device *icd,\r\nstruct v4l2_crop *a)\r\n{\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->c = cam->subrect;\r\nreturn 0;\r\n}\r\nstatic void calculate_client_output(struct soc_camera_device *icd,\r\nconst struct v4l2_pix_format *pix, struct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\nstruct device *dev = icd->parent;\r\nstruct v4l2_rect *cam_subrect = &cam->subrect;\r\nunsigned int scale_v, scale_h;\r\nif (cam_subrect->width == cam->rect.width &&\r\ncam_subrect->height == cam->rect.height) {\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nreturn;\r\n}\r\ndev_geo(dev, "2: subwin %ux%u@%u:%u\n",\r\ncam_subrect->width, cam_subrect->height,\r\ncam_subrect->left, cam_subrect->top);\r\nscale_h = calc_generic_scale(cam_subrect->width, pix->width);\r\nscale_v = calc_generic_scale(cam_subrect->height, pix->height);\r\ndev_geo(dev, "3: scales %u:%u\n", scale_h, scale_v);\r\nmf->width = scale_down(cam->rect.width, scale_h);\r\nmf->height = scale_down(cam->rect.height, scale_v);\r\n}\r\nstatic int sh_mobile_ceu_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nstruct sh_mobile_ceu_cam *cam = icd->host_priv;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\n__u32 pixfmt = pix->pixelformat;\r\nconst struct soc_camera_format_xlate *xlate;\r\nunsigned int ceu_sub_width = 0, ceu_sub_height = 0;\r\nu16 scale_v, scale_h;\r\nint ret;\r\nbool image_mode;\r\nenum v4l2_field field;\r\nswitch (pix->field) {\r\ndefault:\r\npix->field = V4L2_FIELD_NONE;\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\ncase V4L2_FIELD_NONE:\r\nfield = pix->field;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nfield = V4L2_FIELD_INTERLACED_TB;\r\nbreak;\r\n}\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (!xlate) {\r\ndev_warn(dev, "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\ncalculate_client_output(icd, pix, &mf);\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nswitch (pixfmt) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nimage_mode = true;\r\nbreak;\r\ndefault:\r\nimage_mode = false;\r\n}\r\ndev_geo(dev, "S_FMT(pix=0x%x, fld 0x%x, code 0x%x, %ux%u)\n", pixfmt, mf.field, mf.code,\r\npix->width, pix->height);\r\ndev_geo(dev, "4: request camera output %ux%u\n", mf.width, mf.height);\r\nret = client_scale(icd, &mf, &ceu_sub_width, &ceu_sub_height,\r\nimage_mode && V4L2_FIELD_NONE == field);\r\ndev_geo(dev, "5-9: client scale return %d\n", ret);\r\ndev_geo(dev, "fmt %ux%u, requested %ux%u\n",\r\nmf.width, mf.height, pix->width, pix->height);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mf.code != xlate->code)\r\nreturn -EINVAL;\r\ncam->width = mf.width;\r\ncam->height = mf.height;\r\nif (pix->width > ceu_sub_width)\r\nceu_sub_width = pix->width;\r\nif (pix->height > ceu_sub_height)\r\nceu_sub_height = pix->height;\r\npix->colorspace = mf.colorspace;\r\nif (image_mode) {\r\nscale_h = calc_scale(ceu_sub_width, &pix->width);\r\nscale_v = calc_scale(ceu_sub_height, &pix->height);\r\n} else {\r\npix->width = ceu_sub_width;\r\npix->height = ceu_sub_height;\r\nscale_h = 0;\r\nscale_v = 0;\r\n}\r\npcdev->cflcr = scale_h | (scale_v << 16);\r\ndev_geo(dev, "10: W: %u : 0x%x = %u, H: %u : 0x%x = %u\n",\r\nceu_sub_width, scale_h, pix->width,\r\nceu_sub_height, scale_v, pix->height);\r\ncam->code = xlate->code;\r\nicd->current_fmt = xlate;\r\npcdev->field = field;\r\npcdev->image_mode = image_mode;\r\npix->width &= ~3;\r\npix->height &= ~3;\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_ceu_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct v4l2_mbus_framefmt mf;\r\n__u32 pixfmt = pix->pixelformat;\r\nint width, height;\r\nint ret;\r\ndev_geo(icd->parent, "TRY_FMT(pix=0x%x, %ux%u)\n",\r\npixfmt, pix->width, pix->height);\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (!xlate) {\r\nxlate = icd->current_fmt;\r\ndev_dbg(icd->parent, "Format %x not found, keeping %x\n",\r\npixfmt, xlate->host_fmt->fourcc);\r\npixfmt = xlate->host_fmt->fourcc;\r\npix->pixelformat = pixfmt;\r\npix->colorspace = icd->colorspace;\r\n}\r\nv4l_bound_align_image(&pix->width, 2, pcdev->max_width, 2,\r\n&pix->height, 4, pcdev->max_height, 2, 0);\r\nwidth = pix->width;\r\nheight = pix->height;\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.code = xlate->code;\r\nmf.colorspace = pix->colorspace;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev, soc_camera_grp_id(icd),\r\nvideo, try_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\nswitch (pixfmt) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\ncase V4L2_PIX_FMT_NV16:\r\ncase V4L2_PIX_FMT_NV61:\r\nif (pix->width < width || pix->height < height) {\r\nmf.width = pcdev->max_width;\r\nmf.height = pcdev->max_height;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), video,\r\ntry_mbus_fmt, &mf);\r\nif (ret < 0) {\r\ndev_err(icd->parent,\r\n"FIXME: client try_fmt() = %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (mf.width > width)\r\npix->width = width;\r\nif (mf.height > height)\r\npix->height = height;\r\npix->bytesperline = max(pix->bytesperline, pix->width);\r\npix->bytesperline = min(pix->bytesperline, CEU_CHDW_MAX);\r\npix->bytesperline &= ~3;\r\nbreak;\r\ndefault:\r\npix->bytesperline = 0;\r\n}\r\npix->width &= ~3;\r\npix->height &= ~3;\r\npix->sizeimage = 0;\r\ndev_geo(icd->parent, "%s(): return %d, fmt 0x%x, %ux%u\n",\r\n__func__, ret, pix->pixelformat, pix->width, pix->height);\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_ceu_set_livecrop(struct soc_camera_device *icd,\r\nstruct v4l2_crop *a)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct sh_mobile_ceu_dev *pcdev = ici->priv;\r\nu32 out_width = icd->user_width, out_height = icd->user_height;\r\nint ret;\r\npcdev->frozen = 1;\r\nret = wait_for_completion_interruptible(&pcdev->complete);\r\nret = v4l2_subdev_call(sd, video, s_stream, 0);\r\nif (ret < 0)\r\ndev_warn(icd->parent,\r\n"Client failed to stop the stream: %d\n", ret);\r\nelse\r\nsh_mobile_ceu_set_crop(icd, a);\r\ndev_geo(icd->parent, "Output after crop: %ux%u\n", icd->user_width, icd->user_height);\r\nif (icd->user_width != out_width || icd->user_height != out_height) {\r\nstruct v4l2_format f = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\n.fmt.pix = {\r\n.width = out_width,\r\n.height = out_height,\r\n.pixelformat = icd->current_fmt->host_fmt->fourcc,\r\n.field = pcdev->field,\r\n.colorspace = icd->colorspace,\r\n},\r\n};\r\nret = sh_mobile_ceu_set_fmt(icd, &f);\r\nif (!ret && (out_width != f.fmt.pix.width ||\r\nout_height != f.fmt.pix.height))\r\nret = -EINVAL;\r\nif (!ret) {\r\nicd->user_width = out_width & ~3;\r\nicd->user_height = out_height & ~3;\r\nret = sh_mobile_ceu_set_bus_param(icd);\r\n}\r\n}\r\npcdev->frozen = 0;\r\nspin_lock_irq(&pcdev->lock);\r\nsh_mobile_ceu_capture(pcdev);\r\nspin_unlock_irq(&pcdev->lock);\r\nret = v4l2_subdev_call(sd, video, s_stream, 1);\r\nreturn ret;\r\n}\r\nstatic unsigned int sh_mobile_ceu_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nreturn vb2_poll(&icd->vb2_vidq, file, pt);\r\n}\r\nstatic int sh_mobile_ceu_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->card, "SuperH_Mobile_CEU", sizeof(cap->card));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_ceu_init_videobuf(struct vb2_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->drv_priv = icd;\r\nq->ops = &sh_mobile_ceu_videobuf_ops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct sh_mobile_ceu_buffer);\r\nreturn vb2_queue_init(q);\r\n}\r\nstatic int bus_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct device *dev = data;\r\nstruct bus_wait *wait = container_of(nb, struct bus_wait, notifier);\r\nif (wait->dev != dev)\r\nreturn NOTIFY_DONE;\r\nswitch (action) {\r\ncase BUS_NOTIFY_UNBOUND_DRIVER:\r\nwait_for_completion(&wait->completion);\r\nreturn NOTIFY_OK;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __devinit sh_mobile_ceu_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_ceu_dev *pcdev;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nunsigned int irq;\r\nint err = 0;\r\nstruct bus_wait wait = {\r\n.completion = COMPLETION_INITIALIZER_ONSTACK(wait.completion),\r\n.notifier.notifier_call = bus_notify,\r\n};\r\nstruct sh_mobile_ceu_companion *csi2;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || (int)irq <= 0) {\r\ndev_err(&pdev->dev, "Not enough CEU platform resources.\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\npcdev = kzalloc(sizeof(*pcdev), GFP_KERNEL);\r\nif (!pcdev) {\r\ndev_err(&pdev->dev, "Could not allocate pcdev\n");\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nINIT_LIST_HEAD(&pcdev->capture);\r\nspin_lock_init(&pcdev->lock);\r\ninit_completion(&pcdev->complete);\r\npcdev->pdata = pdev->dev.platform_data;\r\nif (!pcdev->pdata) {\r\nerr = -EINVAL;\r\ndev_err(&pdev->dev, "CEU platform data not set.\n");\r\ngoto exit_kfree;\r\n}\r\npcdev->max_width = pcdev->pdata->max_width ? : 2560;\r\npcdev->max_height = pcdev->pdata->max_height ? : 1920;\r\nbase = ioremap_nocache(res->start, resource_size(res));\r\nif (!base) {\r\nerr = -ENXIO;\r\ndev_err(&pdev->dev, "Unable to ioremap CEU registers.\n");\r\ngoto exit_kfree;\r\n}\r\npcdev->irq = irq;\r\npcdev->base = base;\r\npcdev->video_limit = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res) {\r\nerr = dma_declare_coherent_memory(&pdev->dev, res->start,\r\nres->start,\r\nresource_size(res),\r\nDMA_MEMORY_MAP |\r\nDMA_MEMORY_EXCLUSIVE);\r\nif (!err) {\r\ndev_err(&pdev->dev, "Unable to declare CEU memory.\n");\r\nerr = -ENXIO;\r\ngoto exit_iounmap;\r\n}\r\npcdev->video_limit = resource_size(res);\r\n}\r\nerr = request_irq(pcdev->irq, sh_mobile_ceu_irq, IRQF_DISABLED,\r\ndev_name(&pdev->dev), pcdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to register CEU interrupt.\n");\r\ngoto exit_release_mem;\r\n}\r\npm_suspend_ignore_children(&pdev->dev, true);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_resume(&pdev->dev);\r\npcdev->ici.priv = pcdev;\r\npcdev->ici.v4l2_dev.dev = &pdev->dev;\r\npcdev->ici.nr = pdev->id;\r\npcdev->ici.drv_name = dev_name(&pdev->dev);\r\npcdev->ici.ops = &sh_mobile_ceu_host_ops;\r\npcdev->ici.capabilities = SOCAM_HOST_CAP_STRIDE;\r\npcdev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(pcdev->alloc_ctx)) {\r\nerr = PTR_ERR(pcdev->alloc_ctx);\r\ngoto exit_free_clk;\r\n}\r\nerr = soc_camera_host_register(&pcdev->ici);\r\nif (err)\r\ngoto exit_free_ctx;\r\ncsi2 = pcdev->pdata->csi2;\r\nif (csi2) {\r\nstruct platform_device *csi2_pdev =\r\nplatform_device_alloc("sh-mobile-csi2", csi2->id);\r\nstruct sh_csi2_pdata *csi2_pdata = csi2->platform_data;\r\nif (!csi2_pdev) {\r\nerr = -ENOMEM;\r\ngoto exit_host_unregister;\r\n}\r\npcdev->csi2_pdev = csi2_pdev;\r\nerr = platform_device_add_data(csi2_pdev, csi2_pdata, sizeof(*csi2_pdata));\r\nif (err < 0)\r\ngoto exit_pdev_put;\r\ncsi2_pdata = csi2_pdev->dev.platform_data;\r\ncsi2_pdata->v4l2_dev = &pcdev->ici.v4l2_dev;\r\ncsi2_pdev->resource = csi2->resource;\r\ncsi2_pdev->num_resources = csi2->num_resources;\r\nerr = platform_device_add(csi2_pdev);\r\nif (err < 0)\r\ngoto exit_pdev_put;\r\nwait.dev = &csi2_pdev->dev;\r\nerr = bus_register_notifier(&platform_bus_type, &wait.notifier);\r\nif (err < 0)\r\ngoto exit_pdev_unregister;\r\nif (!csi2_pdev->dev.driver) {\r\ncomplete(&wait.completion);\r\nbus_unregister_notifier(&platform_bus_type, &wait.notifier);\r\nerr = -ENXIO;\r\ngoto exit_pdev_unregister;\r\n}\r\nerr = try_module_get(csi2_pdev->dev.driver->owner);\r\ncomplete(&wait.completion);\r\nbus_unregister_notifier(&platform_bus_type, &wait.notifier);\r\nif (!err) {\r\nerr = -ENODEV;\r\ngoto exit_pdev_unregister;\r\n}\r\n}\r\nreturn 0;\r\nexit_pdev_unregister:\r\nplatform_device_del(pcdev->csi2_pdev);\r\nexit_pdev_put:\r\npcdev->csi2_pdev->resource = NULL;\r\nplatform_device_put(pcdev->csi2_pdev);\r\nexit_host_unregister:\r\nsoc_camera_host_unregister(&pcdev->ici);\r\nexit_free_ctx:\r\nvb2_dma_contig_cleanup_ctx(pcdev->alloc_ctx);\r\nexit_free_clk:\r\npm_runtime_disable(&pdev->dev);\r\nfree_irq(pcdev->irq, pcdev);\r\nexit_release_mem:\r\nif (platform_get_resource(pdev, IORESOURCE_MEM, 1))\r\ndma_release_declared_memory(&pdev->dev);\r\nexit_iounmap:\r\niounmap(base);\r\nexit_kfree:\r\nkfree(pcdev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit sh_mobile_ceu_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct sh_mobile_ceu_dev *pcdev = container_of(soc_host,\r\nstruct sh_mobile_ceu_dev, ici);\r\nstruct platform_device *csi2_pdev = pcdev->csi2_pdev;\r\nsoc_camera_host_unregister(soc_host);\r\npm_runtime_disable(&pdev->dev);\r\nfree_irq(pcdev->irq, pcdev);\r\nif (platform_get_resource(pdev, IORESOURCE_MEM, 1))\r\ndma_release_declared_memory(&pdev->dev);\r\niounmap(pcdev->base);\r\nvb2_dma_contig_cleanup_ctx(pcdev->alloc_ctx);\r\nif (csi2_pdev && csi2_pdev->dev.driver) {\r\nstruct module *csi2_drv = csi2_pdev->dev.driver->owner;\r\nplatform_device_del(csi2_pdev);\r\ncsi2_pdev->resource = NULL;\r\nplatform_device_put(csi2_pdev);\r\nmodule_put(csi2_drv);\r\n}\r\nkfree(pcdev);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_ceu_runtime_nop(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init sh_mobile_ceu_init(void)\r\n{\r\nrequest_module("sh_mobile_csi2");\r\nreturn platform_driver_register(&sh_mobile_ceu_driver);\r\n}\r\nstatic void __exit sh_mobile_ceu_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_mobile_ceu_driver);\r\n}
