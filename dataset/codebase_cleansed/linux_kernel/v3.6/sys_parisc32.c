asmlinkage int sys32_execve(struct pt_regs *regs)\r\n{\r\nint error;\r\nchar *filename;\r\nDBG(("sys32_execve(%p) r26 = 0x%lx\n", regs, regs->gr[26]));\r\nfilename = getname((const char __user *) regs->gr[26]);\r\nerror = PTR_ERR(filename);\r\nif (IS_ERR(filename))\r\ngoto out;\r\nerror = compat_do_execve(filename, compat_ptr(regs->gr[25]),\r\ncompat_ptr(regs->gr[24]), regs);\r\nputname(filename);\r\nout:\r\nreturn error;\r\n}\r\nasmlinkage long sys32_unimplemented(int r26, int r25, int r24, int r23,\r\nint r22, int r21, int r20)\r\n{\r\nprintk(KERN_ERR "%s(%d): Unimplemented 32 on 64 syscall #%d!\n",\r\ncurrent->comm, current->pid, r20);\r\nreturn -ENOSYS;\r\n}\r\nasmlinkage long sys32_sched_rr_get_interval(pid_t pid,\r\nstruct compat_timespec __user *interval)\r\n{\r\nstruct timespec t;\r\nint ret;\r\nKERNEL_SYSCALL(ret, sys_sched_rr_get_interval, pid, (struct timespec __user *)&t);\r\nif (put_compat_timespec(&t, interval))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_msgsnd(int msqid,\r\nstruct msgbuf32 __user *umsgp32,\r\nsize_t msgsz, int msgflg)\r\n{\r\nstruct msgbuf *mb;\r\nstruct msgbuf32 mb32;\r\nint err;\r\nif ((mb = kmalloc(msgsz + sizeof *mb + 4, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nerr = get_user(mb32.mtype, &umsgp32->mtype);\r\nmb->mtype = mb32.mtype;\r\nerr |= copy_from_user(mb->mtext, &umsgp32->mtext, msgsz);\r\nif (err)\r\nerr = -EFAULT;\r\nelse\r\nKERNEL_SYSCALL(err, sys_msgsnd, msqid, (struct msgbuf __user *)mb, msgsz, msgflg);\r\nkfree(mb);\r\nreturn err;\r\n}\r\nasmlinkage long sys32_msgrcv(int msqid,\r\nstruct msgbuf32 __user *umsgp32,\r\nsize_t msgsz, long msgtyp, int msgflg)\r\n{\r\nstruct msgbuf *mb;\r\nstruct msgbuf32 mb32;\r\nint err, len;\r\nif ((mb = kmalloc(msgsz + sizeof *mb + 4, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nKERNEL_SYSCALL(err, sys_msgrcv, msqid, (struct msgbuf __user *)mb, msgsz, msgtyp, msgflg);\r\nif (err >= 0) {\r\nlen = err;\r\nmb32.mtype = mb->mtype;\r\nerr = put_user(mb32.mtype, &umsgp32->mtype);\r\nerr |= copy_to_user(&umsgp32->mtext, mb->mtext, len);\r\nif (err)\r\nerr = -EFAULT;\r\nelse\r\nerr = len;\r\n}\r\nkfree(mb);\r\nreturn err;\r\n}\r\nasmlinkage int sys32_sendfile(int out_fd, int in_fd, compat_off_t __user *offset, s32 count)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nint ret;\r\noff_t of;\r\nif (offset && get_user(of, offset))\r\nreturn -EFAULT;\r\nset_fs(KERNEL_DS);\r\nret = sys_sendfile(out_fd, in_fd, offset ? (off_t __user *)&of : NULL, count);\r\nset_fs(old_fs);\r\nif (offset && put_user(of, offset))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nasmlinkage int sys32_sendfile64(int out_fd, int in_fd, compat_loff_t __user *offset, s32 count)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nint ret;\r\nloff_t lof;\r\nif (offset && get_user(lof, offset))\r\nreturn -EFAULT;\r\nset_fs(KERNEL_DS);\r\nret = sys_sendfile64(out_fd, in_fd, offset ? (loff_t __user *)&lof : NULL, count);\r\nset_fs(old_fs);\r\nif (offset && put_user(lof, offset))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nasmlinkage int sys32_lseek(unsigned int fd, int offset, unsigned int origin)\r\n{\r\nreturn sys_lseek(fd, offset, origin);\r\n}\r\nasmlinkage long sys32_semctl(int semid, int semnum, int cmd, union semun arg)\r\n{\r\nunion semun u;\r\nif (cmd == SETVAL) {\r\nu.val = *((int *)&arg + 1);\r\nreturn sys_semctl (semid, semnum, cmd, u);\r\n}\r\nreturn sys_semctl (semid, semnum, cmd, arg);\r\n}\r\nlong sys32_lookup_dcookie(u32 cookie_high, u32 cookie_low, char __user *buf,\r\nsize_t len)\r\n{\r\nreturn sys_lookup_dcookie((u64)cookie_high << 32 | cookie_low,\r\nbuf, len);\r\n}\r\nasmlinkage long compat_sys_fallocate(int fd, int mode, u32 offhi, u32 offlo,\r\nu32 lenhi, u32 lenlo)\r\n{\r\nreturn sys_fallocate(fd, mode, ((loff_t)offhi << 32) | offlo,\r\n((loff_t)lenhi << 32) | lenlo);\r\n}\r\nasmlinkage long compat_sys_fanotify_mark(int fan_fd, int flags, u32 mask_hi,\r\nu32 mask_lo, int fd,\r\nconst char __user *pathname)\r\n{\r\nreturn sys_fanotify_mark(fan_fd, flags, ((u64)mask_hi << 32) | mask_lo,\r\nfd, pathname);\r\n}
