static int check_pattern_no_oob(uint8_t *buf, struct nand_bbt_descr *td)\r\n{\r\nint ret;\r\nret = memcmp(buf, td->pattern, td->len);\r\nif (!ret)\r\nreturn ret;\r\nreturn -1;\r\n}\r\nstatic int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)\r\n{\r\nint i, end = 0;\r\nuint8_t *p = buf;\r\nif (td->options & NAND_BBT_NO_OOB)\r\nreturn check_pattern_no_oob(buf, td);\r\nend = paglen + td->offs;\r\nif (td->options & NAND_BBT_SCANEMPTY) {\r\nfor (i = 0; i < end; i++) {\r\nif (p[i] != 0xff)\r\nreturn -1;\r\n}\r\n}\r\np += end;\r\nif (memcmp(p, td->pattern, td->len))\r\nreturn -1;\r\nif (td->options & NAND_BBT_SCANEMPTY) {\r\np += td->len;\r\nend += td->len;\r\nfor (i = end; i < len; i++) {\r\nif (*p++ != 0xff)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_short_pattern(uint8_t *buf, struct nand_bbt_descr *td)\r\n{\r\nint i;\r\nuint8_t *p = buf;\r\nfor (i = 0; i < td->len; i++) {\r\nif (p[td->offs + i] != td->pattern[i])\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 add_marker_len(struct nand_bbt_descr *td)\r\n{\r\nu32 len;\r\nif (!(td->options & NAND_BBT_NO_OOB))\r\nreturn 0;\r\nlen = td->len;\r\nif (td->options & NAND_BBT_VERSION)\r\nlen++;\r\nreturn len;\r\n}\r\nstatic int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,\r\nstruct nand_bbt_descr *td, int offs)\r\n{\r\nint res, ret = 0, i, j, act = 0;\r\nstruct nand_chip *this = mtd->priv;\r\nsize_t retlen, len, totlen;\r\nloff_t from;\r\nint bits = td->options & NAND_BBT_NRBITS_MSK;\r\nuint8_t msk = (uint8_t)((1 << bits) - 1);\r\nu32 marker_len;\r\nint reserved_block_code = td->reserved_block_code;\r\ntotlen = (num * bits) >> 3;\r\nmarker_len = add_marker_len(td);\r\nfrom = ((loff_t)page) << this->page_shift;\r\nwhile (totlen) {\r\nlen = min(totlen, (size_t)(1 << this->bbt_erase_shift));\r\nif (marker_len) {\r\nlen -= marker_len;\r\nfrom += marker_len;\r\nmarker_len = 0;\r\n}\r\nres = mtd_read(mtd, from, len, &retlen, buf);\r\nif (res < 0) {\r\nif (mtd_is_eccerr(res)) {\r\npr_info("nand_bbt: ECC error in BBT at "\r\n"0x%012llx\n", from & ~mtd->writesize);\r\nreturn res;\r\n} else if (mtd_is_bitflip(res)) {\r\npr_info("nand_bbt: corrected error in BBT at "\r\n"0x%012llx\n", from & ~mtd->writesize);\r\nret = res;\r\n} else {\r\npr_info("nand_bbt: error reading BBT\n");\r\nreturn res;\r\n}\r\n}\r\nfor (i = 0; i < len; i++) {\r\nuint8_t dat = buf[i];\r\nfor (j = 0; j < 8; j += bits, act += 2) {\r\nuint8_t tmp = (dat >> j) & msk;\r\nif (tmp == msk)\r\ncontinue;\r\nif (reserved_block_code && (tmp == reserved_block_code)) {\r\npr_info("nand_read_bbt: reserved block at 0x%012llx\n",\r\n(loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift);\r\nthis->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);\r\nmtd->ecc_stats.bbtblocks++;\r\ncontinue;\r\n}\r\npr_info("nand_read_bbt: bad block at 0x%012llx\n",\r\n(loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift);\r\nif (tmp == 0)\r\nthis->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);\r\nelse\r\nthis->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);\r\nmtd->ecc_stats.badblocks++;\r\n}\r\n}\r\ntotlen -= len;\r\nfrom += len;\r\n}\r\nreturn ret;\r\n}\r\nstatic int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nint res = 0, i;\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nint offs = 0;\r\nfor (i = 0; i < this->numchips; i++) {\r\nif (chip == -1 || chip == i)\r\nres = read_bbt(mtd, buf, td->pages[i],\r\nthis->chipsize >> this->bbt_erase_shift,\r\ntd, offs);\r\nif (res)\r\nreturn res;\r\noffs += this->chipsize >> (this->bbt_erase_shift + 2);\r\n}\r\n} else {\r\nres = read_bbt(mtd, buf, td->pages[0],\r\nmtd->size >> this->bbt_erase_shift, td, 0);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scan_read_raw_data(struct mtd_info *mtd, uint8_t *buf, loff_t offs,\r\nstruct nand_bbt_descr *td)\r\n{\r\nsize_t retlen;\r\nsize_t len;\r\nlen = td->len;\r\nif (td->options & NAND_BBT_VERSION)\r\nlen++;\r\nreturn mtd_read(mtd, offs, len, &retlen, buf);\r\n}\r\nstatic int scan_read_raw_oob(struct mtd_info *mtd, uint8_t *buf, loff_t offs,\r\nsize_t len)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint res;\r\nops.mode = MTD_OPS_RAW;\r\nops.ooboffs = 0;\r\nops.ooblen = mtd->oobsize;\r\nwhile (len > 0) {\r\nops.datbuf = buf;\r\nops.len = min(len, (size_t)mtd->writesize);\r\nops.oobbuf = buf + ops.len;\r\nres = mtd_read_oob(mtd, offs, &ops);\r\nif (res)\r\nreturn res;\r\nbuf += mtd->oobsize + mtd->writesize;\r\nlen -= mtd->writesize;\r\noffs += mtd->writesize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,\r\nsize_t len, struct nand_bbt_descr *td)\r\n{\r\nif (td->options & NAND_BBT_NO_OOB)\r\nreturn scan_read_raw_data(mtd, buf, offs, td);\r\nelse\r\nreturn scan_read_raw_oob(mtd, buf, offs, len);\r\n}\r\nstatic int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,\r\nuint8_t *buf, uint8_t *oob)\r\n{\r\nstruct mtd_oob_ops ops;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.ooboffs = 0;\r\nops.ooblen = mtd->oobsize;\r\nops.datbuf = buf;\r\nops.oobbuf = oob;\r\nops.len = len;\r\nreturn mtd_write_oob(mtd, offs, &ops);\r\n}\r\nstatic u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)\r\n{\r\nu32 ver_offs = td->veroffs;\r\nif (!(td->options & NAND_BBT_NO_OOB))\r\nver_offs += mtd->writesize;\r\nreturn ver_offs;\r\n}\r\nstatic int read_abs_bbts(struct mtd_info *mtd, uint8_t *buf,\r\nstruct nand_bbt_descr *td, struct nand_bbt_descr *md)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nif (td->options & NAND_BBT_VERSION) {\r\nscan_read_raw(mtd, buf, (loff_t)td->pages[0] << this->page_shift,\r\nmtd->writesize, td);\r\ntd->version[0] = buf[bbt_get_ver_offs(mtd, td)];\r\npr_info("Bad block table at page %d, version 0x%02X\n",\r\ntd->pages[0], td->version[0]);\r\n}\r\nif (md && (md->options & NAND_BBT_VERSION)) {\r\nscan_read_raw(mtd, buf, (loff_t)md->pages[0] << this->page_shift,\r\nmtd->writesize, td);\r\nmd->version[0] = buf[bbt_get_ver_offs(mtd, md)];\r\npr_info("Bad block table at page %d, version 0x%02X\n",\r\nmd->pages[0], md->version[0]);\r\n}\r\nreturn 1;\r\n}\r\nstatic int scan_block_full(struct mtd_info *mtd, struct nand_bbt_descr *bd,\r\nloff_t offs, uint8_t *buf, size_t readlen,\r\nint scanlen, int len)\r\n{\r\nint ret, j;\r\nret = scan_read_raw_oob(mtd, buf, offs, readlen);\r\nif (ret && !mtd_is_bitflip_or_eccerr(ret))\r\nreturn ret;\r\nfor (j = 0; j < len; j++, buf += scanlen) {\r\nif (check_pattern(buf, scanlen, mtd->writesize, bd))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,\r\nloff_t offs, uint8_t *buf, int len)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint j, ret;\r\nops.ooblen = mtd->oobsize;\r\nops.oobbuf = buf;\r\nops.ooboffs = 0;\r\nops.datbuf = NULL;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nfor (j = 0; j < len; j++) {\r\nret = mtd_read_oob(mtd, offs, &ops);\r\nif (ret && !mtd_is_bitflip_or_eccerr(ret))\r\nreturn ret;\r\nif (check_short_pattern(buf, bd))\r\nreturn 1;\r\noffs += mtd->writesize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_bbt(struct mtd_info *mtd, uint8_t *buf,\r\nstruct nand_bbt_descr *bd, int chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nint i, numblocks, len, scanlen;\r\nint startblock;\r\nloff_t from;\r\nsize_t readlen;\r\npr_info("Scanning device for bad blocks\n");\r\nif (bd->options & NAND_BBT_SCANALLPAGES)\r\nlen = 1 << (this->bbt_erase_shift - this->page_shift);\r\nelse if (bd->options & NAND_BBT_SCAN2NDPAGE)\r\nlen = 2;\r\nelse\r\nlen = 1;\r\nif (!(bd->options & NAND_BBT_SCANEMPTY)) {\r\nscanlen = 0;\r\nreadlen = bd->len;\r\n} else {\r\nscanlen = mtd->writesize + mtd->oobsize;\r\nreadlen = len * mtd->writesize;\r\n}\r\nif (chip == -1) {\r\nnumblocks = mtd->size >> (this->bbt_erase_shift - 1);\r\nstartblock = 0;\r\nfrom = 0;\r\n} else {\r\nif (chip >= this->numchips) {\r\npr_warn("create_bbt(): chipnr (%d) > available chips (%d)\n",\r\nchip + 1, this->numchips);\r\nreturn -EINVAL;\r\n}\r\nnumblocks = this->chipsize >> (this->bbt_erase_shift - 1);\r\nstartblock = chip * numblocks;\r\nnumblocks += startblock;\r\nfrom = (loff_t)startblock << (this->bbt_erase_shift - 1);\r\n}\r\nif (this->bbt_options & NAND_BBT_SCANLASTPAGE)\r\nfrom += mtd->erasesize - (mtd->writesize * len);\r\nfor (i = startblock; i < numblocks;) {\r\nint ret;\r\nBUG_ON(bd->options & NAND_BBT_NO_OOB);\r\nif (bd->options & NAND_BBT_SCANALLPAGES)\r\nret = scan_block_full(mtd, bd, from, buf, readlen,\r\nscanlen, len);\r\nelse\r\nret = scan_block_fast(mtd, bd, from, buf, len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret) {\r\nthis->bbt[i >> 3] |= 0x03 << (i & 0x6);\r\npr_warn("Bad eraseblock %d at 0x%012llx\n",\r\ni >> 1, (unsigned long long)from);\r\nmtd->ecc_stats.badblocks++;\r\n}\r\ni += 2;\r\nfrom += (1 << this->bbt_erase_shift);\r\n}\r\nreturn 0;\r\n}\r\nstatic int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nint i, chips;\r\nint bits, startblock, block, dir;\r\nint scanlen = mtd->writesize + mtd->oobsize;\r\nint bbtblocks;\r\nint blocktopage = this->bbt_erase_shift - this->page_shift;\r\nif (td->options & NAND_BBT_LASTBLOCK) {\r\nstartblock = (mtd->size >> this->bbt_erase_shift) - 1;\r\ndir = -1;\r\n} else {\r\nstartblock = 0;\r\ndir = 1;\r\n}\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nchips = this->numchips;\r\nbbtblocks = this->chipsize >> this->bbt_erase_shift;\r\nstartblock &= bbtblocks - 1;\r\n} else {\r\nchips = 1;\r\nbbtblocks = mtd->size >> this->bbt_erase_shift;\r\n}\r\nbits = td->options & NAND_BBT_NRBITS_MSK;\r\nfor (i = 0; i < chips; i++) {\r\ntd->version[i] = 0;\r\ntd->pages[i] = -1;\r\nfor (block = 0; block < td->maxblocks; block++) {\r\nint actblock = startblock + dir * block;\r\nloff_t offs = (loff_t)actblock << this->bbt_erase_shift;\r\nscan_read_raw(mtd, buf, offs, mtd->writesize, td);\r\nif (!check_pattern(buf, scanlen, mtd->writesize, td)) {\r\ntd->pages[i] = actblock << blocktopage;\r\nif (td->options & NAND_BBT_VERSION) {\r\noffs = bbt_get_ver_offs(mtd, td);\r\ntd->version[i] = buf[offs];\r\n}\r\nbreak;\r\n}\r\n}\r\nstartblock += this->chipsize >> this->bbt_erase_shift;\r\n}\r\nfor (i = 0; i < chips; i++) {\r\nif (td->pages[i] == -1)\r\npr_warn("Bad block table not found for chip %d\n", i);\r\nelse\r\npr_info("Bad block table found at page %d, version "\r\n"0x%02X\n", td->pages[i], td->version[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int search_read_bbts(struct mtd_info *mtd, uint8_t * buf, struct nand_bbt_descr *td, struct nand_bbt_descr *md)\r\n{\r\nsearch_bbt(mtd, buf, td);\r\nif (md)\r\nsearch_bbt(mtd, buf, md);\r\nreturn 1;\r\n}\r\nstatic int write_bbt(struct mtd_info *mtd, uint8_t *buf,\r\nstruct nand_bbt_descr *td, struct nand_bbt_descr *md,\r\nint chipsel)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct erase_info einfo;\r\nint i, j, res, chip = 0;\r\nint bits, startblock, dir, page, offs, numblocks, sft, sftmsk;\r\nint nrchips, bbtoffs, pageoffs, ooboffs;\r\nuint8_t msk[4];\r\nuint8_t rcode = td->reserved_block_code;\r\nsize_t retlen, len = 0;\r\nloff_t to;\r\nstruct mtd_oob_ops ops;\r\nops.ooblen = mtd->oobsize;\r\nops.ooboffs = 0;\r\nops.datbuf = NULL;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nif (!rcode)\r\nrcode = 0xff;\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nnumblocks = (int)(this->chipsize >> this->bbt_erase_shift);\r\nif (chipsel == -1) {\r\nnrchips = this->numchips;\r\n} else {\r\nnrchips = chipsel + 1;\r\nchip = chipsel;\r\n}\r\n} else {\r\nnumblocks = (int)(mtd->size >> this->bbt_erase_shift);\r\nnrchips = 1;\r\n}\r\nfor (; chip < nrchips; chip++) {\r\nif (td->pages[chip] != -1) {\r\npage = td->pages[chip];\r\ngoto write;\r\n}\r\nif (td->options & NAND_BBT_LASTBLOCK) {\r\nstartblock = numblocks * (chip + 1) - 1;\r\ndir = -1;\r\n} else {\r\nstartblock = chip * numblocks;\r\ndir = 1;\r\n}\r\nfor (i = 0; i < td->maxblocks; i++) {\r\nint block = startblock + dir * i;\r\nswitch ((this->bbt[block >> 2] >>\r\n(2 * (block & 0x03))) & 0x03) {\r\ncase 0x01:\r\ncase 0x03:\r\ncontinue;\r\n}\r\npage = block <<\r\n(this->bbt_erase_shift - this->page_shift);\r\nif (!md || md->pages[chip] != page)\r\ngoto write;\r\n}\r\npr_err("No space left to write bad block table\n");\r\nreturn -ENOSPC;\r\nwrite:\r\nbits = td->options & NAND_BBT_NRBITS_MSK;\r\nmsk[2] = ~rcode;\r\nswitch (bits) {\r\ncase 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;\r\nmsk[3] = 0x01;\r\nbreak;\r\ncase 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;\r\nmsk[3] = 0x03;\r\nbreak;\r\ncase 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;\r\nmsk[3] = 0x0f;\r\nbreak;\r\ncase 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;\r\nmsk[3] = 0xff;\r\nbreak;\r\ndefault: return -EINVAL;\r\n}\r\nbbtoffs = chip * (numblocks >> 2);\r\nto = ((loff_t)page) << this->page_shift;\r\nif (td->options & NAND_BBT_SAVECONTENT) {\r\nto &= ~((loff_t)((1 << this->bbt_erase_shift) - 1));\r\nlen = 1 << this->bbt_erase_shift;\r\nres = mtd_read(mtd, to, len, &retlen, buf);\r\nif (res < 0) {\r\nif (retlen != len) {\r\npr_info("nand_bbt: error reading block "\r\n"for writing the bad block table\n");\r\nreturn res;\r\n}\r\npr_warn("nand_bbt: ECC error while reading "\r\n"block for writing bad block table\n");\r\n}\r\nops.ooblen = (len >> this->page_shift) * mtd->oobsize;\r\nops.oobbuf = &buf[len];\r\nres = mtd_read_oob(mtd, to + mtd->writesize, &ops);\r\nif (res < 0 || ops.oobretlen != ops.ooblen)\r\ngoto outerr;\r\npageoffs = page - (int)(to >> this->page_shift);\r\noffs = pageoffs << this->page_shift;\r\nmemset(&buf[offs], 0xff, (size_t)(numblocks >> sft));\r\nooboffs = len + (pageoffs * mtd->oobsize);\r\n} else if (td->options & NAND_BBT_NO_OOB) {\r\nooboffs = 0;\r\noffs = td->len;\r\nif (td->options & NAND_BBT_VERSION)\r\noffs++;\r\nlen = (size_t)(numblocks >> sft);\r\nlen += offs;\r\nlen = ALIGN(len, mtd->writesize);\r\nmemset(buf, 0xff, len);\r\nmemcpy(buf, td->pattern, td->len);\r\n} else {\r\nlen = (size_t)(numblocks >> sft);\r\nlen = ALIGN(len, mtd->writesize);\r\nmemset(buf, 0xff, len +\r\n(len >> this->page_shift)* mtd->oobsize);\r\noffs = 0;\r\nooboffs = len;\r\nmemcpy(&buf[ooboffs + td->offs], td->pattern, td->len);\r\n}\r\nif (td->options & NAND_BBT_VERSION)\r\nbuf[ooboffs + td->veroffs] = td->version[chip];\r\nfor (i = 0; i < numblocks;) {\r\nuint8_t dat;\r\ndat = this->bbt[bbtoffs + (i >> 2)];\r\nfor (j = 0; j < 4; j++, i++) {\r\nint sftcnt = (i << (3 - sft)) & sftmsk;\r\nbuf[offs + (i >> sft)] &=\r\n~(msk[dat & 0x03] << sftcnt);\r\ndat >>= 2;\r\n}\r\n}\r\nmemset(&einfo, 0, sizeof(einfo));\r\neinfo.mtd = mtd;\r\neinfo.addr = to;\r\neinfo.len = 1 << this->bbt_erase_shift;\r\nres = nand_erase_nand(mtd, &einfo, 1);\r\nif (res < 0)\r\ngoto outerr;\r\nres = scan_write_bbt(mtd, to, len, buf,\r\ntd->options & NAND_BBT_NO_OOB ? NULL :\r\n&buf[len]);\r\nif (res < 0)\r\ngoto outerr;\r\npr_info("Bad block table written to 0x%012llx, version 0x%02X\n",\r\n(unsigned long long)to, td->version[chip]);\r\ntd->pages[chip] = page;\r\n}\r\nreturn 0;\r\nouterr:\r\npr_warn("nand_bbt: error while writing bad block table %d\n", res);\r\nreturn res;\r\n}\r\nstatic inline int nand_memory_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nbd->options &= ~NAND_BBT_SCANEMPTY;\r\nreturn create_bbt(mtd, this->buffers->databuf, bd, -1);\r\n}\r\nstatic int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)\r\n{\r\nint i, chips, writeops, create, chipsel, res, res2;\r\nstruct nand_chip *this = mtd->priv;\r\nstruct nand_bbt_descr *td = this->bbt_td;\r\nstruct nand_bbt_descr *md = this->bbt_md;\r\nstruct nand_bbt_descr *rd, *rd2;\r\nif (td->options & NAND_BBT_PERCHIP)\r\nchips = this->numchips;\r\nelse\r\nchips = 1;\r\nfor (i = 0; i < chips; i++) {\r\nwriteops = 0;\r\ncreate = 0;\r\nrd = NULL;\r\nrd2 = NULL;\r\nres = res2 = 0;\r\nchipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;\r\nif (md) {\r\nif (td->pages[i] == -1 && md->pages[i] == -1) {\r\ncreate = 1;\r\nwriteops = 0x03;\r\n} else if (td->pages[i] == -1) {\r\nrd = md;\r\nwriteops = 0x01;\r\n} else if (md->pages[i] == -1) {\r\nrd = td;\r\nwriteops = 0x02;\r\n} else if (td->version[i] == md->version[i]) {\r\nrd = td;\r\nif (!(td->options & NAND_BBT_VERSION))\r\nrd2 = md;\r\n} else if (((int8_t)(td->version[i] - md->version[i])) > 0) {\r\nrd = td;\r\nwriteops = 0x02;\r\n} else {\r\nrd = md;\r\nwriteops = 0x01;\r\n}\r\n} else {\r\nif (td->pages[i] == -1) {\r\ncreate = 1;\r\nwriteops = 0x01;\r\n} else {\r\nrd = td;\r\n}\r\n}\r\nif (create) {\r\nif (!(td->options & NAND_BBT_CREATE))\r\ncontinue;\r\nif (!(this->bbt_options & NAND_BBT_CREATE_EMPTY))\r\ncreate_bbt(mtd, buf, bd, chipsel);\r\ntd->version[i] = 1;\r\nif (md)\r\nmd->version[i] = 1;\r\n}\r\nif (rd) {\r\nres = read_abs_bbt(mtd, buf, rd, chipsel);\r\nif (mtd_is_eccerr(res)) {\r\nrd->pages[i] = -1;\r\nrd->version[i] = 0;\r\ni--;\r\ncontinue;\r\n}\r\n}\r\nif (rd2) {\r\nres2 = read_abs_bbt(mtd, buf, rd2, chipsel);\r\nif (mtd_is_eccerr(res2)) {\r\nrd2->pages[i] = -1;\r\nrd2->version[i] = 0;\r\ni--;\r\ncontinue;\r\n}\r\n}\r\nif (mtd_is_bitflip(res) || mtd_is_bitflip(res2))\r\nwriteops = 0x03;\r\nif (md) {\r\ntd->version[i] = max(td->version[i], md->version[i]);\r\nmd->version[i] = td->version[i];\r\n}\r\nif ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {\r\nres = write_bbt(mtd, buf, td, md, chipsel);\r\nif (res < 0)\r\nreturn res;\r\n}\r\nif ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {\r\nres = write_bbt(mtd, buf, md, td, chipsel);\r\nif (res < 0)\r\nreturn res;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nint i, j, chips, block, nrblocks, update;\r\nuint8_t oldval, newval;\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nchips = this->numchips;\r\nnrblocks = (int)(this->chipsize >> this->bbt_erase_shift);\r\n} else {\r\nchips = 1;\r\nnrblocks = (int)(mtd->size >> this->bbt_erase_shift);\r\n}\r\nfor (i = 0; i < chips; i++) {\r\nif ((td->options & NAND_BBT_ABSPAGE) ||\r\n!(td->options & NAND_BBT_WRITE)) {\r\nif (td->pages[i] == -1)\r\ncontinue;\r\nblock = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);\r\nblock <<= 1;\r\noldval = this->bbt[(block >> 3)];\r\nnewval = oldval | (0x2 << (block & 0x06));\r\nthis->bbt[(block >> 3)] = newval;\r\nif ((oldval != newval) && td->reserved_block_code)\r\nnand_update_bbt(mtd, (loff_t)block << (this->bbt_erase_shift - 1));\r\ncontinue;\r\n}\r\nupdate = 0;\r\nif (td->options & NAND_BBT_LASTBLOCK)\r\nblock = ((i + 1) * nrblocks) - td->maxblocks;\r\nelse\r\nblock = i * nrblocks;\r\nblock <<= 1;\r\nfor (j = 0; j < td->maxblocks; j++) {\r\noldval = this->bbt[(block >> 3)];\r\nnewval = oldval | (0x2 << (block & 0x06));\r\nthis->bbt[(block >> 3)] = newval;\r\nif (oldval != newval)\r\nupdate = 1;\r\nblock += 2;\r\n}\r\nif (update && td->reserved_block_code)\r\nnand_update_bbt(mtd, (loff_t)(block - 2) << (this->bbt_erase_shift - 1));\r\n}\r\n}\r\nstatic void verify_bbt_descr(struct mtd_info *mtd, struct nand_bbt_descr *bd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nu32 pattern_len;\r\nu32 bits;\r\nu32 table_size;\r\nif (!bd)\r\nreturn;\r\npattern_len = bd->len;\r\nbits = bd->options & NAND_BBT_NRBITS_MSK;\r\nBUG_ON((this->bbt_options & NAND_BBT_NO_OOB) &&\r\n!(this->bbt_options & NAND_BBT_USE_FLASH));\r\nBUG_ON(!bits);\r\nif (bd->options & NAND_BBT_VERSION)\r\npattern_len++;\r\nif (bd->options & NAND_BBT_NO_OOB) {\r\nBUG_ON(!(this->bbt_options & NAND_BBT_USE_FLASH));\r\nBUG_ON(!(this->bbt_options & NAND_BBT_NO_OOB));\r\nBUG_ON(bd->offs);\r\nif (bd->options & NAND_BBT_VERSION)\r\nBUG_ON(bd->veroffs != bd->len);\r\nBUG_ON(bd->options & NAND_BBT_SAVECONTENT);\r\n}\r\nif (bd->options & NAND_BBT_PERCHIP)\r\ntable_size = this->chipsize >> this->bbt_erase_shift;\r\nelse\r\ntable_size = mtd->size >> this->bbt_erase_shift;\r\ntable_size >>= 3;\r\ntable_size *= bits;\r\nif (bd->options & NAND_BBT_NO_OOB)\r\ntable_size += pattern_len;\r\nBUG_ON(table_size > (1 << this->bbt_erase_shift));\r\n}\r\nint nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nint len, res = 0;\r\nuint8_t *buf;\r\nstruct nand_bbt_descr *td = this->bbt_td;\r\nstruct nand_bbt_descr *md = this->bbt_md;\r\nlen = mtd->size >> (this->bbt_erase_shift + 2);\r\nthis->bbt = kzalloc(len, GFP_KERNEL);\r\nif (!this->bbt)\r\nreturn -ENOMEM;\r\nif (!td) {\r\nif ((res = nand_memory_bbt(mtd, bd))) {\r\npr_err("nand_bbt: can't scan flash and build the RAM-based BBT\n");\r\nkfree(this->bbt);\r\nthis->bbt = NULL;\r\n}\r\nreturn res;\r\n}\r\nverify_bbt_descr(mtd, td);\r\nverify_bbt_descr(mtd, md);\r\nlen = (1 << this->bbt_erase_shift);\r\nlen += (len >> this->page_shift) * mtd->oobsize;\r\nbuf = vmalloc(len);\r\nif (!buf) {\r\nkfree(this->bbt);\r\nthis->bbt = NULL;\r\nreturn -ENOMEM;\r\n}\r\nif (td->options & NAND_BBT_ABSPAGE) {\r\nres = read_abs_bbts(mtd, buf, td, md);\r\n} else {\r\nres = search_read_bbts(mtd, buf, td, md);\r\n}\r\nif (res)\r\nres = check_create(mtd, buf, bd);\r\nmark_bbt_region(mtd, td);\r\nif (md)\r\nmark_bbt_region(mtd, md);\r\nvfree(buf);\r\nreturn res;\r\n}\r\nint nand_update_bbt(struct mtd_info *mtd, loff_t offs)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nint len, res = 0;\r\nint chip, chipsel;\r\nuint8_t *buf;\r\nstruct nand_bbt_descr *td = this->bbt_td;\r\nstruct nand_bbt_descr *md = this->bbt_md;\r\nif (!this->bbt || !td)\r\nreturn -EINVAL;\r\nlen = (1 << this->bbt_erase_shift);\r\nlen += (len >> this->page_shift) * mtd->oobsize;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nchip = (int)(offs >> this->chip_shift);\r\nchipsel = chip;\r\n} else {\r\nchip = 0;\r\nchipsel = -1;\r\n}\r\ntd->version[chip]++;\r\nif (md)\r\nmd->version[chip]++;\r\nif (td->options & NAND_BBT_WRITE) {\r\nres = write_bbt(mtd, buf, td, md, chipsel);\r\nif (res < 0)\r\ngoto out;\r\n}\r\nif (md && (md->options & NAND_BBT_WRITE)) {\r\nres = write_bbt(mtd, buf, md, td, chipsel);\r\n}\r\nout:\r\nkfree(buf);\r\nreturn res;\r\n}\r\nstatic int nand_create_badblock_pattern(struct nand_chip *this)\r\n{\r\nstruct nand_bbt_descr *bd;\r\nif (this->badblock_pattern) {\r\npr_warn("Bad block pattern already allocated; not replacing\n");\r\nreturn -EINVAL;\r\n}\r\nbd = kzalloc(sizeof(*bd), GFP_KERNEL);\r\nif (!bd)\r\nreturn -ENOMEM;\r\nbd->options = this->bbt_options & BADBLOCK_SCAN_MASK;\r\nbd->offs = this->badblockpos;\r\nbd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;\r\nbd->pattern = scan_ff_pattern;\r\nbd->options |= NAND_BBT_DYNAMICSTRUCT;\r\nthis->badblock_pattern = bd;\r\nreturn 0;\r\n}\r\nint nand_default_bbt(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nif (this->options & NAND_IS_AND) {\r\nif (!this->bbt_td) {\r\nthis->bbt_td = &bbt_main_descr;\r\nthis->bbt_md = &bbt_mirror_descr;\r\n}\r\nthis->bbt_options |= NAND_BBT_USE_FLASH;\r\nreturn nand_scan_bbt(mtd, &agand_flashbased);\r\n}\r\nif (this->bbt_options & NAND_BBT_USE_FLASH) {\r\nif (!this->bbt_td) {\r\nif (this->bbt_options & NAND_BBT_NO_OOB) {\r\nthis->bbt_td = &bbt_main_no_bbt_descr;\r\nthis->bbt_md = &bbt_mirror_no_bbt_descr;\r\n} else {\r\nthis->bbt_td = &bbt_main_descr;\r\nthis->bbt_md = &bbt_mirror_descr;\r\n}\r\n}\r\n} else {\r\nthis->bbt_td = NULL;\r\nthis->bbt_md = NULL;\r\n}\r\nif (!this->badblock_pattern)\r\nnand_create_badblock_pattern(this);\r\nreturn nand_scan_bbt(mtd, this->badblock_pattern);\r\n}\r\nint nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nint block;\r\nuint8_t res;\r\nblock = (int)(offs >> (this->bbt_erase_shift - 1));\r\nres = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;\r\npr_debug("nand_isbad_bbt(): bbt info for offs 0x%08x: "\r\n"(block %d) 0x%02x\n",\r\n(unsigned int)offs, block >> 1, res);\r\nswitch ((int)res) {\r\ncase 0x00:\r\nreturn 0;\r\ncase 0x01:\r\nreturn 1;\r\ncase 0x02:\r\nreturn allowbbt ? 0 : 1;\r\n}\r\nreturn 1;\r\n}
