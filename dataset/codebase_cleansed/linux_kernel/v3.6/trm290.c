static void trm290_prepare_drive (ide_drive_t *drive, unsigned int use_dma)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu16 reg = 0;\r\nunsigned long flags;\r\nreg = use_dma ? (0x21 | 0x82) : (0x21 & ~0x82);\r\nlocal_irq_save(flags);\r\nif (reg != hwif->select_data) {\r\nhwif->select_data = reg;\r\noutb(0x51 | (hwif->channel << 3), hwif->config_data + 1);\r\noutw(reg & 0xff, hwif->config_data);\r\n}\r\nif (drive->dev_flags & IDE_DFLAG_PRESENT) {\r\nreg = inw(hwif->config_data + 3);\r\nreg &= 0x13;\r\nreg &= ~(1 << hwif->channel);\r\noutw(reg, hwif->config_data + 3);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void trm290_dev_select(ide_drive_t *drive)\r\n{\r\ntrm290_prepare_drive(drive, !!(drive->dev_flags & IDE_DFLAG_USING_DMA));\r\noutb(drive->select | ATA_DEVICE_OBS, drive->hwif->io_ports.device_addr);\r\n}\r\nstatic int trm290_dma_check(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nif (cmd->tf_flags & IDE_TFLAG_WRITE) {\r\n#ifdef TRM290_NO_DMA_WRITES\r\nreturn 1;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int trm290_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned int count, rw = (cmd->tf_flags & IDE_TFLAG_WRITE) ? 1 : 2;\r\ncount = ide_build_dmatable(drive, cmd);\r\nif (count == 0)\r\nreturn 1;\r\noutl(hwif->dmatable_dma | rw, hwif->dma_base);\r\noutw(count * 2 - 1, hwif->dma_base + 2);\r\nreturn 0;\r\n}\r\nstatic void trm290_dma_start(ide_drive_t *drive)\r\n{\r\ntrm290_prepare_drive(drive, 1);\r\n}\r\nstatic int trm290_dma_end(ide_drive_t *drive)\r\n{\r\nu16 status = inw(drive->hwif->dma_base + 2);\r\ntrm290_prepare_drive(drive, 0);\r\nreturn status != 0x00ff;\r\n}\r\nstatic int trm290_dma_test_irq(ide_drive_t *drive)\r\n{\r\nu16 status = inw(drive->hwif->dma_base + 2);\r\nreturn status == 0x00ff;\r\n}\r\nstatic void trm290_dma_host_set(ide_drive_t *drive, int on)\r\n{\r\n}\r\nstatic void __devinit init_hwif_trm290(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned int cfg_base = pci_resource_start(dev, 4);\r\nunsigned long flags;\r\nu8 reg = 0;\r\nif ((dev->class & 5) && cfg_base)\r\nprintk(KERN_INFO DRV_NAME " %s: chip", pci_name(dev));\r\nelse {\r\ncfg_base = 0x3df0;\r\nprintk(KERN_INFO DRV_NAME " %s: using default", pci_name(dev));\r\n}\r\nprintk(KERN_CONT " config base at 0x%04x\n", cfg_base);\r\nhwif->config_data = cfg_base;\r\nhwif->dma_base = (cfg_base + 4) ^ (hwif->channel ? 0x80 : 0);\r\nprintk(KERN_INFO " %s: BM-DMA at 0x%04lx-0x%04lx\n",\r\nhwif->name, hwif->dma_base, hwif->dma_base + 3);\r\nif (ide_allocate_dma_engine(hwif))\r\nreturn;\r\nlocal_irq_save(flags);\r\noutb(0x51 | (hwif->channel << 3), hwif->config_data + 1);\r\nhwif->select_data = 0x21;\r\noutb(hwif->select_data, hwif->config_data);\r\nreg = inb(hwif->config_data + 3);\r\nreg = (reg & 0x10) | 0x03;\r\noutb(reg, hwif->config_data + 3);\r\nlocal_irq_restore(flags);\r\nif (reg & 0x10)\r\nhwif->irq = hwif->channel ? 15 : 14;\r\n#if 1\r\n{\r\nu16 new, old, compat = hwif->channel ? 0x374 : 0x3f4;\r\nstatic u16 next_offset = 0;\r\nu8 old_mask;\r\noutb(0x54 | (hwif->channel << 3), hwif->config_data + 1);\r\nold = inw(hwif->config_data);\r\nold &= ~1;\r\nold_mask = inb(old + 2);\r\nif (old != compat && old_mask == 0xff) {\r\ncompat += (next_offset += 0x400);\r\nhwif->io_ports.ctl_addr = compat + 2;\r\noutw(compat | 1, hwif->config_data);\r\nnew = inw(hwif->config_data);\r\nprintk(KERN_INFO "%s: control basereg workaround: "\r\n"old=0x%04x, new=0x%04x\n",\r\nhwif->name, old, new & ~1);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic int __devinit trm290_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nreturn ide_pci_init_one(dev, &trm290_chipset, NULL);\r\n}\r\nstatic int __init trm290_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&trm290_pci_driver);\r\n}\r\nstatic void __exit trm290_ide_exit(void)\r\n{\r\npci_unregister_driver(&trm290_pci_driver);\r\n}
