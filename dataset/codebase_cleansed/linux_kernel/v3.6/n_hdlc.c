static void flush_rx_queue(struct tty_struct *tty)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc(tty);\r\nstruct n_hdlc_buf *buf;\r\nwhile ((buf = n_hdlc_buf_get(&n_hdlc->rx_buf_list)))\r\nn_hdlc_buf_put(&n_hdlc->rx_free_buf_list, buf);\r\n}\r\nstatic void flush_tx_queue(struct tty_struct *tty)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc(tty);\r\nstruct n_hdlc_buf *buf;\r\nunsigned long flags;\r\nwhile ((buf = n_hdlc_buf_get(&n_hdlc->tx_buf_list)))\r\nn_hdlc_buf_put(&n_hdlc->tx_free_buf_list, buf);\r\nspin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock, flags);\r\nif (n_hdlc->tbuf) {\r\nn_hdlc_buf_put(&n_hdlc->tx_free_buf_list, n_hdlc->tbuf);\r\nn_hdlc->tbuf = NULL;\r\n}\r\nspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);\r\n}\r\nstatic void n_hdlc_release(struct n_hdlc *n_hdlc)\r\n{\r\nstruct tty_struct *tty = n_hdlc2tty (n_hdlc);\r\nstruct n_hdlc_buf *buf;\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_release() called\n",__FILE__,__LINE__);\r\nwake_up_interruptible (&tty->read_wait);\r\nwake_up_interruptible (&tty->write_wait);\r\nif (tty->disc_data == n_hdlc)\r\ntty->disc_data = NULL;\r\nfor(;;) {\r\nbuf = n_hdlc_buf_get(&n_hdlc->rx_free_buf_list);\r\nif (buf) {\r\nkfree(buf);\r\n} else\r\nbreak;\r\n}\r\nfor(;;) {\r\nbuf = n_hdlc_buf_get(&n_hdlc->tx_free_buf_list);\r\nif (buf) {\r\nkfree(buf);\r\n} else\r\nbreak;\r\n}\r\nfor(;;) {\r\nbuf = n_hdlc_buf_get(&n_hdlc->rx_buf_list);\r\nif (buf) {\r\nkfree(buf);\r\n} else\r\nbreak;\r\n}\r\nfor(;;) {\r\nbuf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);\r\nif (buf) {\r\nkfree(buf);\r\n} else\r\nbreak;\r\n}\r\nkfree(n_hdlc->tbuf);\r\nkfree(n_hdlc);\r\n}\r\nstatic void n_hdlc_tty_close(struct tty_struct *tty)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc (tty);\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_close() called\n",__FILE__,__LINE__);\r\nif (n_hdlc != NULL) {\r\nif (n_hdlc->magic != HDLC_MAGIC) {\r\nprintk (KERN_WARNING"n_hdlc: trying to close unopened tty!\n");\r\nreturn;\r\n}\r\n#if defined(TTY_NO_WRITE_SPLIT)\r\nclear_bit(TTY_NO_WRITE_SPLIT,&tty->flags);\r\n#endif\r\ntty->disc_data = NULL;\r\nif (tty == n_hdlc->backup_tty)\r\nn_hdlc->backup_tty = NULL;\r\nif (tty != n_hdlc->tty)\r\nreturn;\r\nif (n_hdlc->backup_tty) {\r\nn_hdlc->tty = n_hdlc->backup_tty;\r\n} else {\r\nn_hdlc_release (n_hdlc);\r\n}\r\n}\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_close() success\n",__FILE__,__LINE__);\r\n}\r\nstatic int n_hdlc_tty_open (struct tty_struct *tty)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc (tty);\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_open() called (device=%s)\n",\r\n__FILE__,__LINE__,\r\ntty->name);\r\nif (n_hdlc) {\r\nprintk (KERN_ERR"n_hdlc_tty_open:tty already associated!\n" );\r\nreturn -EEXIST;\r\n}\r\nn_hdlc = n_hdlc_alloc();\r\nif (!n_hdlc) {\r\nprintk (KERN_ERR "n_hdlc_alloc failed\n");\r\nreturn -ENFILE;\r\n}\r\ntty->disc_data = n_hdlc;\r\nn_hdlc->tty = tty;\r\ntty->receive_room = 65536;\r\n#if defined(TTY_NO_WRITE_SPLIT)\r\nset_bit(TTY_NO_WRITE_SPLIT,&tty->flags);\r\n#endif\r\ntty_driver_flush_buffer(tty);\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_open() success\n",__FILE__,__LINE__);\r\nreturn 0;\r\n}\r\nstatic void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)\r\n{\r\nregister int actual;\r\nunsigned long flags;\r\nstruct n_hdlc_buf *tbuf;\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_send_frames() called\n",__FILE__,__LINE__);\r\ncheck_again:\r\nspin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock, flags);\r\nif (n_hdlc->tbusy) {\r\nn_hdlc->woke_up = 1;\r\nspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);\r\nreturn;\r\n}\r\nn_hdlc->tbusy = 1;\r\nn_hdlc->woke_up = 0;\r\nspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);\r\ntbuf = n_hdlc->tbuf;\r\nif (!tbuf)\r\ntbuf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);\r\nwhile (tbuf) {\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)sending frame %p, count=%d\n",\r\n__FILE__,__LINE__,tbuf,tbuf->count);\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nactual = tty->ops->write(tty, tbuf->buf, tbuf->count);\r\nif (actual == -ERESTARTSYS) {\r\nn_hdlc->tbuf = tbuf;\r\nbreak;\r\n}\r\nif (actual < 0)\r\nactual = tbuf->count;\r\nif (actual == tbuf->count) {\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)frame %p completed\n",\r\n__FILE__,__LINE__,tbuf);\r\nn_hdlc_buf_put(&n_hdlc->tx_free_buf_list, tbuf);\r\nn_hdlc->tbuf = NULL;\r\nwake_up_interruptible(&tty->write_wait);\r\ntbuf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);\r\n} else {\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)frame %p pending\n",\r\n__FILE__,__LINE__,tbuf);\r\nn_hdlc->tbuf = tbuf;\r\nbreak;\r\n}\r\n}\r\nif (!tbuf)\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nspin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock, flags);\r\nn_hdlc->tbusy = 0;\r\nspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock, flags);\r\nif (n_hdlc->woke_up)\r\ngoto check_again;\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_send_frames() exit\n",__FILE__,__LINE__);\r\n}\r\nstatic void n_hdlc_tty_wakeup(struct tty_struct *tty)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc(tty);\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_wakeup() called\n",__FILE__,__LINE__);\r\nif (!n_hdlc)\r\nreturn;\r\nif (tty != n_hdlc->tty) {\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nreturn;\r\n}\r\nn_hdlc_send_frames (n_hdlc, tty);\r\n}\r\nstatic void n_hdlc_tty_receive(struct tty_struct *tty, const __u8 *data,\r\nchar *flags, int count)\r\n{\r\nregister struct n_hdlc *n_hdlc = tty2n_hdlc (tty);\r\nregister struct n_hdlc_buf *buf;\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_receive() called count=%d\n",\r\n__FILE__,__LINE__, count);\r\nif (!n_hdlc || tty != n_hdlc->tty)\r\nreturn;\r\nif (n_hdlc->magic != HDLC_MAGIC) {\r\nprintk("%s(%d) line not using HDLC discipline\n",\r\n__FILE__,__LINE__);\r\nreturn;\r\n}\r\nif ( count>maxframe ) {\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d) rx count>maxframesize, data discarded\n",\r\n__FILE__,__LINE__);\r\nreturn;\r\n}\r\nbuf = n_hdlc_buf_get(&n_hdlc->rx_free_buf_list);\r\nif (!buf) {\r\nif (n_hdlc->rx_buf_list.count < MAX_RX_BUF_COUNT)\r\nbuf = kmalloc(N_HDLC_BUF_SIZE, GFP_ATOMIC);\r\n}\r\nif (!buf) {\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d) no more rx buffers, data discarded\n",\r\n__FILE__,__LINE__);\r\nreturn;\r\n}\r\nmemcpy(buf->buf,data,count);\r\nbuf->count=count;\r\nn_hdlc_buf_put(&n_hdlc->rx_buf_list, buf);\r\nwake_up_interruptible (&tty->read_wait);\r\nif (n_hdlc->tty->fasync != NULL)\r\nkill_fasync (&n_hdlc->tty->fasync, SIGIO, POLL_IN);\r\n}\r\nstatic ssize_t n_hdlc_tty_read(struct tty_struct *tty, struct file *file,\r\n__u8 __user *buf, size_t nr)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc(tty);\r\nint ret = 0;\r\nstruct n_hdlc_buf *rbuf;\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_read() called\n",__FILE__,__LINE__);\r\nif (!n_hdlc)\r\nreturn -EIO;\r\nif (!access_ok(VERIFY_WRITE, buf, nr)) {\r\nprintk(KERN_WARNING "%s(%d) n_hdlc_tty_read() can't verify user "\r\n"buffer\n", __FILE__, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nadd_wait_queue(&tty->read_wait, &wait);\r\nfor (;;) {\r\nif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (tty_hung_up_p(file))\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nrbuf = n_hdlc_buf_get(&n_hdlc->rx_buf_list);\r\nif (rbuf) {\r\nif (rbuf->count > nr) {\r\nret = -EOVERFLOW;\r\n} else {\r\nif (copy_to_user(buf, rbuf->buf, rbuf->count))\r\nret = -EFAULT;\r\nelse\r\nret = rbuf->count;\r\n}\r\nif (n_hdlc->rx_free_buf_list.count >\r\nDEFAULT_RX_BUF_COUNT)\r\nkfree(rbuf);\r\nelse\r\nn_hdlc_buf_put(&n_hdlc->rx_free_buf_list, rbuf);\r\nbreak;\r\n}\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\nret = -EINTR;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(&tty->read_wait, &wait);\r\n__set_current_state(TASK_RUNNING);\r\nreturn ret;\r\n}\r\nstatic ssize_t n_hdlc_tty_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *data, size_t count)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc (tty);\r\nint error = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct n_hdlc_buf *tbuf;\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_write() called count=%Zd\n",\r\n__FILE__,__LINE__,count);\r\nif (!n_hdlc)\r\nreturn -EIO;\r\nif (n_hdlc->magic != HDLC_MAGIC)\r\nreturn -EIO;\r\nif (count > maxframe ) {\r\nif (debuglevel & DEBUG_LEVEL_INFO)\r\nprintk (KERN_WARNING\r\n"n_hdlc_tty_write: truncating user packet "\r\n"from %lu to %d\n", (unsigned long) count,\r\nmaxframe );\r\ncount = maxframe;\r\n}\r\nadd_wait_queue(&tty->write_wait, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\ntbuf = n_hdlc_buf_get(&n_hdlc->tx_free_buf_list);\r\nif (tbuf)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nerror = -EAGAIN;\r\nbreak;\r\n}\r\nschedule();\r\nn_hdlc = tty2n_hdlc (tty);\r\nif (!n_hdlc || n_hdlc->magic != HDLC_MAGIC ||\r\ntty != n_hdlc->tty) {\r\nprintk("n_hdlc_tty_write: %p invalid after wait!\n", n_hdlc);\r\nerror = -EIO;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerror = -EINTR;\r\nbreak;\r\n}\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&tty->write_wait, &wait);\r\nif (!error) {\r\nmemcpy(tbuf->buf, data, count);\r\ntbuf->count = error = count;\r\nn_hdlc_buf_put(&n_hdlc->tx_buf_list,tbuf);\r\nn_hdlc_send_frames(n_hdlc,tty);\r\n}\r\nreturn error;\r\n}\r\nstatic int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc (tty);\r\nint error = 0;\r\nint count;\r\nunsigned long flags;\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_ioctl() called %d\n",\r\n__FILE__,__LINE__,cmd);\r\nif (!n_hdlc || n_hdlc->magic != HDLC_MAGIC)\r\nreturn -EBADF;\r\nswitch (cmd) {\r\ncase FIONREAD:\r\nspin_lock_irqsave(&n_hdlc->rx_buf_list.spinlock,flags);\r\nif (n_hdlc->rx_buf_list.head)\r\ncount = n_hdlc->rx_buf_list.head->count;\r\nelse\r\ncount = 0;\r\nspin_unlock_irqrestore(&n_hdlc->rx_buf_list.spinlock,flags);\r\nerror = put_user(count, (int __user *)arg);\r\nbreak;\r\ncase TIOCOUTQ:\r\ncount = tty_chars_in_buffer(tty);\r\nspin_lock_irqsave(&n_hdlc->tx_buf_list.spinlock,flags);\r\nif (n_hdlc->tx_buf_list.head)\r\ncount += n_hdlc->tx_buf_list.head->count;\r\nspin_unlock_irqrestore(&n_hdlc->tx_buf_list.spinlock,flags);\r\nerror = put_user(count, (int __user *)arg);\r\nbreak;\r\ncase TCFLSH:\r\nswitch (arg) {\r\ncase TCIOFLUSH:\r\ncase TCOFLUSH:\r\nflush_tx_queue(tty);\r\n}\r\ndefault:\r\nerror = n_tty_ioctl_helper(tty, file, cmd, arg);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nstatic unsigned int n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,\r\npoll_table *wait)\r\n{\r\nstruct n_hdlc *n_hdlc = tty2n_hdlc (tty);\r\nunsigned int mask = 0;\r\nif (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_tty_poll() called\n",__FILE__,__LINE__);\r\nif (n_hdlc && n_hdlc->magic == HDLC_MAGIC && tty == n_hdlc->tty) {\r\npoll_wait(filp, &tty->read_wait, wait);\r\npoll_wait(filp, &tty->write_wait, wait);\r\nif (n_hdlc->rx_buf_list.head)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\r\nmask |= POLLHUP;\r\nif (tty_hung_up_p(filp))\r\nmask |= POLLHUP;\r\nif (!tty_is_writelocked(tty) &&\r\nn_hdlc->tx_free_buf_list.head)\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic struct n_hdlc *n_hdlc_alloc(void)\r\n{\r\nstruct n_hdlc_buf *buf;\r\nint i;\r\nstruct n_hdlc *n_hdlc = kmalloc(sizeof(*n_hdlc), GFP_KERNEL);\r\nif (!n_hdlc)\r\nreturn NULL;\r\nmemset(n_hdlc, 0, sizeof(*n_hdlc));\r\nn_hdlc_buf_list_init(&n_hdlc->rx_free_buf_list);\r\nn_hdlc_buf_list_init(&n_hdlc->tx_free_buf_list);\r\nn_hdlc_buf_list_init(&n_hdlc->rx_buf_list);\r\nn_hdlc_buf_list_init(&n_hdlc->tx_buf_list);\r\nfor(i=0;i<DEFAULT_RX_BUF_COUNT;i++) {\r\nbuf = kmalloc(N_HDLC_BUF_SIZE, GFP_KERNEL);\r\nif (buf)\r\nn_hdlc_buf_put(&n_hdlc->rx_free_buf_list,buf);\r\nelse if (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_alloc(), kalloc() failed for rx buffer %d\n",__FILE__,__LINE__, i);\r\n}\r\nfor(i=0;i<DEFAULT_TX_BUF_COUNT;i++) {\r\nbuf = kmalloc(N_HDLC_BUF_SIZE, GFP_KERNEL);\r\nif (buf)\r\nn_hdlc_buf_put(&n_hdlc->tx_free_buf_list,buf);\r\nelse if (debuglevel >= DEBUG_LEVEL_INFO)\r\nprintk("%s(%d)n_hdlc_alloc(), kalloc() failed for tx buffer %d\n",__FILE__,__LINE__, i);\r\n}\r\nn_hdlc->magic = HDLC_MAGIC;\r\nn_hdlc->flags = 0;\r\nreturn n_hdlc;\r\n}\r\nstatic void n_hdlc_buf_list_init(struct n_hdlc_buf_list *list)\r\n{\r\nmemset(list, 0, sizeof(*list));\r\nspin_lock_init(&list->spinlock);\r\n}\r\nstatic void n_hdlc_buf_put(struct n_hdlc_buf_list *list,\r\nstruct n_hdlc_buf *buf)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&list->spinlock,flags);\r\nbuf->link=NULL;\r\nif (list->tail)\r\nlist->tail->link = buf;\r\nelse\r\nlist->head = buf;\r\nlist->tail = buf;\r\n(list->count)++;\r\nspin_unlock_irqrestore(&list->spinlock,flags);\r\n}\r\nstatic struct n_hdlc_buf* n_hdlc_buf_get(struct n_hdlc_buf_list *list)\r\n{\r\nunsigned long flags;\r\nstruct n_hdlc_buf *buf;\r\nspin_lock_irqsave(&list->spinlock,flags);\r\nbuf = list->head;\r\nif (buf) {\r\nlist->head = buf->link;\r\n(list->count)--;\r\n}\r\nif (!list->head)\r\nlist->tail = NULL;\r\nspin_unlock_irqrestore(&list->spinlock,flags);\r\nreturn buf;\r\n}\r\nstatic int __init n_hdlc_init(void)\r\n{\r\nint status;\r\nif (maxframe < 4096)\r\nmaxframe = 4096;\r\nelse if (maxframe > 65535)\r\nmaxframe = 65535;\r\nprintk(hdlc_banner, maxframe);\r\nstatus = tty_register_ldisc(N_HDLC, &n_hdlc_ldisc);\r\nif (!status)\r\nprintk(hdlc_register_ok);\r\nelse\r\nprintk(hdlc_register_fail, status);\r\nif (status)\r\nprintk(hdlc_init_fail, status);\r\nreturn status;\r\n}\r\nstatic void __exit n_hdlc_exit(void)\r\n{\r\nint status = tty_unregister_ldisc(N_HDLC);\r\nif (status)\r\nprintk(hdlc_unregister_fail, status);\r\nelse\r\nprintk(hdlc_unregister_ok);\r\n}
