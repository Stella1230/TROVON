static const struct v4l2_queryctrl *ctrl_by_id(unsigned int id)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < CTRLS; i++)\r\nif (tm6000_qctrl[i].id == id)\r\nreturn tm6000_qctrl+i;\r\nreturn NULL;\r\n}\r\nstatic inline void get_next_buf(struct tm6000_dmaqueue *dma_q,\r\nstruct tm6000_buffer **buf)\r\n{\r\nstruct tm6000_core *dev = container_of(dma_q, struct tm6000_core, vidq);\r\nif (list_empty(&dma_q->active)) {\r\ndprintk(dev, V4L2_DEBUG_QUEUE, "No active queue to serve\n");\r\n*buf = NULL;\r\nreturn;\r\n}\r\n*buf = list_entry(dma_q->active.next,\r\nstruct tm6000_buffer, vb.queue);\r\n}\r\nstatic inline void buffer_filled(struct tm6000_core *dev,\r\nstruct tm6000_dmaqueue *dma_q,\r\nstruct tm6000_buffer *buf)\r\n{\r\ndprintk(dev, V4L2_DEBUG_ISOC, "[%p/%d] wakeup\n", buf, buf->vb.i);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nbuf->vb.field_count++;\r\ndo_gettimeofday(&buf->vb.ts);\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nstatic int copy_streams(u8 *data, unsigned long len,\r\nstruct urb *urb)\r\n{\r\nstruct tm6000_dmaqueue *dma_q = urb->context;\r\nstruct tm6000_core *dev = container_of(dma_q, struct tm6000_core, vidq);\r\nu8 *ptr = data, *endp = data+len;\r\nunsigned long header = 0;\r\nint rc = 0;\r\nunsigned int cmd, cpysize, pktsize, size, field, block, line, pos = 0;\r\nstruct tm6000_buffer *vbuf = NULL;\r\nchar *voutp = NULL;\r\nunsigned int linewidth;\r\nif (!dev->radio) {\r\nget_next_buf(dma_q, &vbuf);\r\nif (!vbuf)\r\nreturn rc;\r\nvoutp = videobuf_to_vmalloc(&vbuf->vb);\r\nif (!voutp)\r\nreturn 0;\r\n}\r\nfor (ptr = data; ptr < endp;) {\r\nif (!dev->isoc_ctl.cmd) {\r\nif (dev->isoc_ctl.tmp_buf_len > 0) {\r\nheader = dev->isoc_ctl.tmp_buf;\r\nif (4 - dev->isoc_ctl.tmp_buf_len > 0) {\r\nmemcpy((u8 *)&header +\r\ndev->isoc_ctl.tmp_buf_len,\r\nptr,\r\n4 - dev->isoc_ctl.tmp_buf_len);\r\nptr += 4 - dev->isoc_ctl.tmp_buf_len;\r\n}\r\ndev->isoc_ctl.tmp_buf_len = 0;\r\n} else {\r\nif (ptr + 3 >= endp) {\r\ndev->isoc_ctl.tmp_buf_len = endp - ptr;\r\nmemcpy(&dev->isoc_ctl.tmp_buf, ptr,\r\ndev->isoc_ctl.tmp_buf_len);\r\nreturn rc;\r\n}\r\nfor (; ptr < endp - 3; ptr++) {\r\nif (*(ptr + 3) == 0x47)\r\nbreak;\r\n}\r\nheader = *(unsigned long *)ptr;\r\nptr += 4;\r\n}\r\nsize = ((header & 0x7e) << 1);\r\nif (size > 0)\r\nsize -= 4;\r\nblock = (header >> 7) & 0xf;\r\nfield = (header >> 11) & 0x1;\r\nline = (header >> 12) & 0x1ff;\r\ncmd = (header >> 21) & 0x7;\r\nif (size > TM6000_URB_MSG_LEN)\r\nsize = TM6000_URB_MSG_LEN;\r\npktsize = TM6000_URB_MSG_LEN;\r\nswitch (cmd) {\r\ncase TM6000_URB_MSG_VIDEO:\r\nif (!dev->radio) {\r\nif ((dev->isoc_ctl.vfield != field) &&\r\n(field == 1)) {\r\nbuffer_filled(dev, dma_q, vbuf);\r\ndprintk(dev, V4L2_DEBUG_ISOC,\r\n"new buffer filled\n");\r\nget_next_buf(dma_q, &vbuf);\r\nif (!vbuf)\r\nreturn rc;\r\nvoutp = videobuf_to_vmalloc(&vbuf->vb);\r\nif (!voutp)\r\nreturn rc;\r\nmemset(voutp, 0, vbuf->vb.size);\r\n}\r\nlinewidth = vbuf->vb.width << 1;\r\npos = ((line << 1) - field - 1) *\r\nlinewidth + block * TM6000_URB_MSG_LEN;\r\nif (pos + size > vbuf->vb.size)\r\ncmd = TM6000_URB_MSG_ERR;\r\ndev->isoc_ctl.vfield = field;\r\n}\r\nbreak;\r\ncase TM6000_URB_MSG_VBI:\r\nbreak;\r\ncase TM6000_URB_MSG_AUDIO:\r\ncase TM6000_URB_MSG_PTS:\r\nsize = pktsize;\r\nbreak;\r\n}\r\n} else {\r\ncmd = dev->isoc_ctl.cmd;\r\nsize = dev->isoc_ctl.size;\r\npos = dev->isoc_ctl.pos;\r\npktsize = dev->isoc_ctl.pktsize;\r\nfield = dev->isoc_ctl.field;\r\n}\r\ncpysize = (endp - ptr > size) ? size : endp - ptr;\r\nif (cpysize) {\r\nswitch (cmd) {\r\ncase TM6000_URB_MSG_VIDEO:\r\nif (vbuf)\r\nmemcpy(&voutp[pos], ptr, cpysize);\r\nbreak;\r\ncase TM6000_URB_MSG_AUDIO: {\r\nint i;\r\nfor (i = 0; i < cpysize; i += 2)\r\nswab16s((u16 *)(ptr + i));\r\ntm6000_call_fillbuf(dev, TM6000_AUDIO, ptr, cpysize);\r\nbreak;\r\n}\r\ncase TM6000_URB_MSG_VBI:\r\nbreak;\r\ncase TM6000_URB_MSG_PTS: {\r\nu32 pts;\r\npts = *(u32 *)ptr;\r\ndprintk(dev, V4L2_DEBUG_ISOC, "field %d, PTS %x",\r\nfield, pts);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (ptr + pktsize > endp) {\r\ndev->isoc_ctl.pos = pos + cpysize;\r\ndev->isoc_ctl.size = size - cpysize;\r\ndev->isoc_ctl.cmd = cmd;\r\ndev->isoc_ctl.field = field;\r\ndev->isoc_ctl.pktsize = pktsize - (endp - ptr);\r\nptr += endp - ptr;\r\n} else {\r\ndev->isoc_ctl.cmd = 0;\r\nptr += pktsize;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int copy_multiplexed(u8 *ptr, unsigned long len,\r\nstruct urb *urb)\r\n{\r\nstruct tm6000_dmaqueue *dma_q = urb->context;\r\nstruct tm6000_core *dev = container_of(dma_q, struct tm6000_core, vidq);\r\nunsigned int pos = dev->isoc_ctl.pos, cpysize;\r\nint rc = 1;\r\nstruct tm6000_buffer *buf;\r\nchar *outp = NULL;\r\nget_next_buf(dma_q, &buf);\r\nif (buf)\r\noutp = videobuf_to_vmalloc(&buf->vb);\r\nif (!outp)\r\nreturn 0;\r\nwhile (len > 0) {\r\ncpysize = min(len, buf->vb.size-pos);\r\nmemcpy(&outp[pos], ptr, cpysize);\r\npos += cpysize;\r\nptr += cpysize;\r\nlen -= cpysize;\r\nif (pos >= buf->vb.size) {\r\npos = 0;\r\nbuffer_filled(dev, dma_q, buf);\r\ndprintk(dev, V4L2_DEBUG_ISOC, "new buffer filled\n");\r\nget_next_buf(dma_q, &buf);\r\nif (!buf)\r\nbreak;\r\noutp = videobuf_to_vmalloc(&(buf->vb));\r\nif (!outp)\r\nreturn rc;\r\npos = 0;\r\n}\r\n}\r\ndev->isoc_ctl.pos = pos;\r\nreturn rc;\r\n}\r\nstatic inline void print_err_status(struct tm6000_core *dev,\r\nint packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\ndprintk(dev, V4L2_DEBUG_QUEUE, "URB status %d [%s].\n",\r\nstatus, errmsg);\r\n} else {\r\ndprintk(dev, V4L2_DEBUG_QUEUE, "URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic inline int tm6000_isoc_copy(struct urb *urb)\r\n{\r\nstruct tm6000_dmaqueue *dma_q = urb->context;\r\nstruct tm6000_core *dev = container_of(dma_q, struct tm6000_core, vidq);\r\nint i, len = 0, rc = 1, status;\r\nchar *p;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstatus = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\ncontinue;\r\n}\r\nlen = urb->iso_frame_desc[i].actual_length;\r\nif (len > 0) {\r\np = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (!urb->iso_frame_desc[i].status) {\r\nif ((dev->fourcc) == V4L2_PIX_FMT_TM6000) {\r\nrc = copy_multiplexed(p, len, urb);\r\nif (rc <= 0)\r\nreturn rc;\r\n} else {\r\ncopy_streams(p, len, urb);\r\n}\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void tm6000_irq_callback(struct urb *urb)\r\n{\r\nstruct tm6000_dmaqueue *dma_q = urb->context;\r\nstruct tm6000_core *dev = container_of(dma_q, struct tm6000_core, vidq);\r\nint i;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ntm6000_err("urb completion error %d.\n", urb->status);\r\nbreak;\r\n}\r\nspin_lock(&dev->slock);\r\ntm6000_isoc_copy(urb);\r\nspin_unlock(&dev->slock);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nurb->status = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (urb->status)\r\ntm6000_err("urb resubmit failed (error=%i)\n",\r\nurb->status);\r\n}\r\nstatic void tm6000_uninit_isoc(struct tm6000_core *dev)\r\n{\r\nstruct urb *urb;\r\nint i;\r\ndev->isoc_ctl.buf = NULL;\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nurb = dev->isoc_ctl.urb[i];\r\nif (urb) {\r\nusb_kill_urb(urb);\r\nusb_unlink_urb(urb);\r\nif (dev->isoc_ctl.transfer_buffer[i]) {\r\nusb_free_coherent(dev->udev,\r\nurb->transfer_buffer_length,\r\ndev->isoc_ctl.transfer_buffer[i],\r\nurb->transfer_dma);\r\n}\r\nusb_free_urb(urb);\r\ndev->isoc_ctl.urb[i] = NULL;\r\n}\r\ndev->isoc_ctl.transfer_buffer[i] = NULL;\r\n}\r\nkfree(dev->isoc_ctl.urb);\r\nkfree(dev->isoc_ctl.transfer_buffer);\r\ndev->isoc_ctl.urb = NULL;\r\ndev->isoc_ctl.transfer_buffer = NULL;\r\ndev->isoc_ctl.num_bufs = 0;\r\n}\r\nstatic int tm6000_prepare_isoc(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_dmaqueue *dma_q = &dev->vidq;\r\nint i, j, sb_size, pipe, size, max_packets, num_bufs = 8;\r\nstruct urb *urb;\r\ntm6000_uninit_isoc(dev);\r\ntm6000_ir_int_stop(dev);\r\nusb_set_interface(dev->udev,\r\ndev->isoc_in.bInterfaceNumber,\r\ndev->isoc_in.bAlternateSetting);\r\ntm6000_ir_int_start(dev);\r\npipe = usb_rcvisocpipe(dev->udev,\r\ndev->isoc_in.endp->desc.bEndpointAddress &\r\nUSB_ENDPOINT_NUMBER_MASK);\r\nsize = usb_maxpacket(dev->udev, pipe, usb_pipeout(pipe));\r\nif (size > dev->isoc_in.maxsize)\r\nsize = dev->isoc_in.maxsize;\r\ndev->isoc_ctl.max_pkt_size = size;\r\nmax_packets = TM6000_MAX_ISO_PACKETS;\r\nsb_size = max_packets * size;\r\ndev->isoc_ctl.num_bufs = num_bufs;\r\ndev->isoc_ctl.urb = kmalloc(sizeof(void *)*num_bufs, GFP_KERNEL);\r\nif (!dev->isoc_ctl.urb) {\r\ntm6000_err("cannot alloc memory for usb buffers\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.transfer_buffer = kmalloc(sizeof(void *)*num_bufs,\r\nGFP_KERNEL);\r\nif (!dev->isoc_ctl.transfer_buffer) {\r\ntm6000_err("cannot allocate memory for usbtransfer\n");\r\nkfree(dev->isoc_ctl.urb);\r\nreturn -ENOMEM;\r\n}\r\ndprintk(dev, V4L2_DEBUG_QUEUE, "Allocating %d x %d packets"\r\n" (%d bytes) of %d bytes each to handle %u size\n",\r\nmax_packets, num_bufs, sb_size,\r\ndev->isoc_in.maxsize, size);\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nurb = usb_alloc_urb(max_packets, GFP_KERNEL);\r\nif (!urb) {\r\ntm6000_err("cannot alloc isoc_ctl.urb %i\n", i);\r\ntm6000_uninit_isoc(dev);\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.urb[i] = urb;\r\ndev->isoc_ctl.transfer_buffer[i] = usb_alloc_coherent(dev->udev,\r\nsb_size, GFP_KERNEL, &urb->transfer_dma);\r\nif (!dev->isoc_ctl.transfer_buffer[i]) {\r\ntm6000_err("unable to allocate %i bytes for transfer"\r\n" buffer %i%s\n",\r\nsb_size, i,\r\nin_interrupt() ? " while in int" : "");\r\ntm6000_uninit_isoc(dev);\r\nreturn -ENOMEM;\r\n}\r\nmemset(dev->isoc_ctl.transfer_buffer[i], 0, sb_size);\r\nusb_fill_bulk_urb(urb, dev->udev, pipe,\r\ndev->isoc_ctl.transfer_buffer[i], sb_size,\r\ntm6000_irq_callback, dma_q);\r\nurb->interval = dev->isoc_in.endp->desc.bInterval;\r\nurb->number_of_packets = max_packets;\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nfor (j = 0; j < max_packets; j++) {\r\nurb->iso_frame_desc[j].offset = size * j;\r\nurb->iso_frame_desc[j].length = size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tm6000_start_thread(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_dmaqueue *dma_q = &dev->vidq;\r\nint i;\r\ndma_q->frame = 0;\r\ndma_q->ini_jiffies = jiffies;\r\ninit_waitqueue_head(&dma_q->wq);\r\nfor (i = 0; i < dev->isoc_ctl.num_bufs; i++) {\r\nint rc = usb_submit_urb(dev->isoc_ctl.urb[i], GFP_ATOMIC);\r\nif (rc) {\r\ntm6000_err("submit of urb %i failed (error=%i)\n", i,\r\nrc);\r\ntm6000_uninit_isoc(dev);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbuffer_setup(struct videobuf_queue *vq, unsigned int *count, unsigned int *size)\r\n{\r\nstruct tm6000_fh *fh = vq->priv_data;\r\n*size = fh->fmt->depth * fh->width * fh->height >> 3;\r\nif (0 == *count)\r\n*count = TM6000_DEF_BUF;\r\nif (*count < TM6000_MIN_BUF)\r\n*count = TM6000_MIN_BUF;\r\nwhile (*size * *count > vid_limit * 1024 * 1024)\r\n(*count)--;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct tm6000_buffer *buf)\r\n{\r\nstruct tm6000_fh *fh = vq->priv_data;\r\nstruct tm6000_core *dev = fh->dev;\r\nunsigned long flags;\r\nif (in_interrupt())\r\nBUG();\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (dev->isoc_ctl.buf == buf)\r\ndev->isoc_ctl.buf = NULL;\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int\r\nbuffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct tm6000_fh *fh = vq->priv_data;\r\nstruct tm6000_buffer *buf = container_of(vb, struct tm6000_buffer, vb);\r\nstruct tm6000_core *dev = fh->dev;\r\nint rc = 0;\r\nBUG_ON(NULL == fh->fmt);\r\nbuf->vb.size = fh->fmt->depth*fh->width*fh->height >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nif (buf->fmt != fh->fmt ||\r\nbuf->vb.width != fh->width ||\r\nbuf->vb.height != fh->height ||\r\nbuf->vb.field != field) {\r\nbuf->fmt = fh->fmt;\r\nbuf->vb.width = fh->width;\r\nbuf->vb.height = fh->height;\r\nbuf->vb.field = field;\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc != 0)\r\ngoto fail;\r\n}\r\nif (!dev->isoc_ctl.num_bufs) {\r\nrc = tm6000_prepare_isoc(dev);\r\nif (rc < 0)\r\ngoto fail;\r\nrc = tm6000_start_thread(dev);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void\r\nbuffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct tm6000_buffer *buf = container_of(vb, struct tm6000_buffer, vb);\r\nstruct tm6000_fh *fh = vq->priv_data;\r\nstruct tm6000_core *dev = fh->dev;\r\nstruct tm6000_dmaqueue *vidq = &dev->vidq;\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &vidq->active);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct tm6000_buffer *buf = container_of(vb, struct tm6000_buffer, vb);\r\nfree_buffer(vq, buf);\r\n}\r\nstatic bool is_res_read(struct tm6000_core *dev, struct tm6000_fh *fh)\r\n{\r\nif (dev->resources == fh && dev->is_res_read)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool is_res_streaming(struct tm6000_core *dev, struct tm6000_fh *fh)\r\n{\r\nif (dev->resources == fh)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool res_get(struct tm6000_core *dev, struct tm6000_fh *fh,\r\nbool is_res_read)\r\n{\r\nif (dev->resources == fh && dev->is_res_read == is_res_read)\r\nreturn true;\r\nif (dev->resources)\r\nreturn false;\r\ndev->resources = fh;\r\ndev->is_res_read = is_res_read;\r\ndprintk(dev, V4L2_DEBUG_RES_LOCK, "res: get\n");\r\nreturn true;\r\n}\r\nstatic void res_free(struct tm6000_core *dev, struct tm6000_fh *fh)\r\n{\r\nif (dev->resources != fh)\r\nreturn;\r\ndev->resources = NULL;\r\ndprintk(dev, V4L2_DEBUG_RES_LOCK, "res: put\n");\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct tm6000_core *dev = ((struct tm6000_fh *)priv)->dev;\r\nstrlcpy(cap->driver, "tm6000", sizeof(cap->driver));\r\nstrlcpy(cap->card, "Trident TVMaster TM5600/6000/6010", sizeof(cap->card));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_AUDIO |\r\nV4L2_CAP_READWRITE;\r\nif (dev->tuner_type != TUNER_ABSENT)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(format)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, format[f->index].name, sizeof(f->description));\r\nf->pixelformat = format[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nf->fmt.pix.width = fh->width;\r\nf->fmt.pix.height = fh->height;\r\nf->fmt.pix.field = fh->vb_vidq.field;\r\nf->fmt.pix.pixelformat = fh->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fh->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic struct tm6000_fmt *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(format); i++)\r\nif (format[i].fourcc == fourcc)\r\nreturn format+i;\r\nreturn NULL;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tm6000_core *dev = ((struct tm6000_fh *)priv)->dev;\r\nstruct tm6000_fmt *fmt;\r\nenum v4l2_field field;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt) {\r\ndprintk(dev, V4L2_DEBUG_IOCTL_ARG, "Fourcc format (0x%08x)"\r\n" invalid.\n", f->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nfield = f->fmt.pix.field;\r\nif (field == V4L2_FIELD_ANY)\r\nfield = V4L2_FIELD_SEQ_TB;\r\nelse if (V4L2_FIELD_INTERLACED != field) {\r\ndprintk(dev, V4L2_DEBUG_IOCTL_ARG, "Field type invalid.\n");\r\nreturn -EINVAL;\r\n}\r\ntm6000_get_std_res(dev);\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.width &= ~0x01;\r\nf->fmt.pix.field = field;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nint ret = vidioc_try_fmt_vid_cap(file, fh, f);\r\nif (ret < 0)\r\nreturn ret;\r\nfh->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nfh->width = f->fmt.pix.width;\r\nfh->height = f->fmt.pix.height;\r\nfh->vb_vidq.field = f->fmt.pix.field;\r\nfh->type = f->type;\r\ndev->fourcc = f->fmt.pix.pixelformat;\r\ntm6000_set_fourcc_format(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nreturn videobuf_reqbufs(&fh->vb_vidq, p);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nreturn videobuf_querybuf(&fh->vb_vidq, p);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nreturn videobuf_qbuf(&fh->vb_vidq, p);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nreturn videobuf_dqbuf(&fh->vb_vidq, p,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (i != fh->type)\r\nreturn -EINVAL;\r\nif (!res_get(dev, fh, false))\r\nreturn -EBUSY;\r\nreturn videobuf_streamon(&fh->vb_vidq);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (i != fh->type)\r\nreturn -EINVAL;\r\nvideobuf_streamoff(&fh->vb_vidq);\r\nres_free(dev, fh);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nint rc = 0;\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\ndev->norm = *norm;\r\nrc = tm6000_init_analog_mode(dev);\r\nfh->width = dev->width;\r\nfh->height = dev->height;\r\nif (rc < 0)\r\nreturn rc;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, s_std, dev->norm);\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nunsigned int n;\r\nn = i->index;\r\nif (n >= 3)\r\nreturn -EINVAL;\r\nif (!dev->vinput[n].type)\r\nreturn -EINVAL;\r\ni->index = n;\r\nif (dev->vinput[n].type == TM6000_INPUT_TV)\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nelse\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, iname[dev->vinput[n].type]);\r\ni->std = TM6000_STD;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\n*i = dev->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nint rc = 0;\r\nif (i >= 3)\r\nreturn -EINVAL;\r\nif (!dev->vinput[i].type)\r\nreturn -EINVAL;\r\ndev->input = i;\r\nrc = vidioc_s_std(file, priv, &dev->vfd->current_norm);\r\nreturn rc;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tm6000_qctrl); i++)\r\nif (qc->id && qc->id == tm6000_qctrl[i].id) {\r\nmemcpy(qc, &(tm6000_qctrl[i]),\r\nsizeof(*qc));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nint val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_CONTRAST:\r\nval = tm6000_get_reg(dev, TM6010_REQ07_R08_LUMA_CONTRAST_ADJ, 0);\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\nval = tm6000_get_reg(dev, TM6010_REQ07_R09_LUMA_BRIGHTNESS_ADJ, 0);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\nval = tm6000_get_reg(dev, TM6010_REQ07_R0A_CHROMA_SATURATION_ADJ, 0);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\nval = tm6000_get_reg(dev, TM6010_REQ07_R0B_CHROMA_HUE_PHASE_ADJ, 0);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_MUTE:\r\nval = dev->ctl_mute;\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nval = dev->ctl_volume;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (val < 0)\r\nreturn val;\r\nctrl->value = val;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nu8 val = ctrl->value;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_CONTRAST:\r\ntm6000_set_reg(dev, TM6010_REQ07_R08_LUMA_CONTRAST_ADJ, val);\r\nreturn 0;\r\ncase V4L2_CID_BRIGHTNESS:\r\ntm6000_set_reg(dev, TM6010_REQ07_R09_LUMA_BRIGHTNESS_ADJ, val);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\ntm6000_set_reg(dev, TM6010_REQ07_R0A_CHROMA_SATURATION_ADJ, val);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\ntm6000_set_reg(dev, TM6010_REQ07_R0B_CHROMA_HUE_PHASE_ADJ, val);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_MUTE:\r\ndev->ctl_mute = val;\r\ntm6000_tvaudio_set_mute(dev, val);\r\nreturn 0;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ndev->ctl_volume = val;\r\ntm6000_set_volume(dev, val);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (unlikely(UNSET == dev->tuner_type))\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nt->rangehigh = 0xffffffffUL;\r\nt->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_tuner, t);\r\nt->audmode = dev->amode;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (UNSET == dev->tuner_type)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ndev->amode = t->audmode;\r\ndprintk(dev, 3, "audio mode: %x\n", t->audmode);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (unlikely(UNSET == dev->tuner_type))\r\nreturn -EINVAL;\r\nf->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nf->frequency = dev->freq;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (unlikely(UNSET == dev->tuner_type))\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\nif (0 == fh->radio && V4L2_TUNER_ANALOG_TV != f->type)\r\nreturn -EINVAL;\r\nif (1 == fh->radio && V4L2_TUNER_RADIO != f->type)\r\nreturn -EINVAL;\r\ndev->freq = f->frequency;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int radio_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct tm6000_fh *fh = file->private_data;\r\nstruct tm6000_core *dev = fh->dev;\r\nstrcpy(cap->driver, "tm6000");\r\nstrlcpy(cap->card, dev->name, sizeof(dev->name));\r\nsprintf(cap->bus_info, "USB%04x:%04x",\r\nle16_to_cpu(dev->udev->descriptor.idVendor),\r\nle16_to_cpu(dev->udev->descriptor.idProduct));\r\ncap->version = dev->dev_type;\r\ncap->capabilities = V4L2_CAP_TUNER |\r\nV4L2_CAP_AUDIO |\r\nV4L2_CAP_RADIO |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct tm6000_fh *fh = file->private_data;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nmemset(t, 0, sizeof(*t));\r\nstrcpy(t->name, "Radio");\r\nt->type = V4L2_TUNER_RADIO;\r\nt->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct tm6000_fh *fh = file->private_data;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nif (!dev->rinput.type)\r\nreturn -EINVAL;\r\nstrcpy(i->name, "Radio");\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nreturn 0;\r\n}\r\nstatic int radio_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (dev->input != 5)\r\nreturn -EINVAL;\r\n*i = dev->input - 5;\r\nreturn 0;\r\n}\r\nstatic int radio_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nmemset(a, 0, sizeof(*a));\r\nstrcpy(a->name, "Radio");\r\nreturn 0;\r\n}\r\nstatic int radio_s_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *a)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nstruct tm6000_fh *fh = priv;\r\nstruct tm6000_core *dev = fh->dev;\r\nif (i)\r\nreturn -EINVAL;\r\nif (!dev->rinput.type)\r\nreturn -EINVAL;\r\ndev->input = i + 5;\r\nreturn 0;\r\n}\r\nstatic int radio_s_std(struct file *file, void *fh, v4l2_std_id *norm)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nconst struct v4l2_queryctrl *ctrl;\r\nif (c->id < V4L2_CID_BASE ||\r\nc->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nif (c->id == V4L2_CID_AUDIO_MUTE) {\r\nctrl = ctrl_by_id(c->id);\r\n*c = *ctrl;\r\n} else\r\n*c = no_ctrl;\r\nreturn 0;\r\n}\r\nstatic int tm6000_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct tm6000_core *dev = video_drvdata(file);\r\nstruct tm6000_fh *fh;\r\nenum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nint i, rc;\r\nint radio = 0;\r\ndprintk(dev, V4L2_DEBUG_OPEN, "tm6000: open called (dev=%s)\n",\r\nvideo_device_node_name(vdev));\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ntype = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nradio = 1;\r\nbreak;\r\n}\r\ndev->users++;\r\ndprintk(dev, V4L2_DEBUG_OPEN, "open dev=%s type=%s users=%d\n",\r\nvideo_device_node_name(vdev), v4l2_type_names[type],\r\ndev->users);\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (NULL == fh) {\r\ndev->users--;\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = fh;\r\nfh->dev = dev;\r\nfh->radio = radio;\r\ndev->radio = radio;\r\nfh->type = type;\r\ndev->fourcc = format[0].fourcc;\r\nfh->fmt = format_by_fourcc(dev->fourcc);\r\ntm6000_get_std_res(dev);\r\nfh->width = dev->width;\r\nfh->height = dev->height;\r\ndprintk(dev, V4L2_DEBUG_OPEN, "Open: fh=0x%08lx, dev=0x%08lx, "\r\n"dev->vidq=0x%08lx\n",\r\n(unsigned long)fh, (unsigned long)dev,\r\n(unsigned long)&dev->vidq);\r\ndprintk(dev, V4L2_DEBUG_OPEN, "Open: list_empty "\r\n"queued=%d\n", list_empty(&dev->vidq.queued));\r\ndprintk(dev, V4L2_DEBUG_OPEN, "Open: list_empty "\r\n"active=%d\n", list_empty(&dev->vidq.active));\r\nrc = tm6000_init_analog_mode(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nif (dev->mode != TM6000_MODE_ANALOG) {\r\nfor (i = 0; i < ARRAY_SIZE(tm6000_qctrl); i++)\r\nqctl_regs[i] = tm6000_qctrl[i].default_value;\r\ndev->mode = TM6000_MODE_ANALOG;\r\n}\r\nif (!fh->radio) {\r\nvideobuf_queue_vmalloc_init(&fh->vb_vidq, &tm6000_video_qops,\r\nNULL, &dev->slock,\r\nfh->type,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct tm6000_buffer), fh, &dev->lock);\r\n} else {\r\ndprintk(dev, V4L2_DEBUG_OPEN, "video_open: setting radio device\n");\r\ndev->input = 5;\r\ntm6000_set_audio_rinput(dev);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_radio);\r\ntm6000_prepare_isoc(dev);\r\ntm6000_start_thread(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ntm6000_read(struct file *file, char __user *data, size_t count, loff_t *pos)\r\n{\r\nstruct tm6000_fh *fh = file->private_data;\r\nif (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (!res_get(fh->dev, fh, true))\r\nreturn -EBUSY;\r\nreturn videobuf_read_stream(&fh->vb_vidq, data, count, pos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\ntm6000_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct tm6000_fh *fh = file->private_data;\r\nstruct tm6000_buffer *buf;\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)\r\nreturn POLLERR;\r\nif (!!is_res_streaming(fh->dev, fh))\r\nreturn POLLERR;\r\nif (!is_res_read(fh->dev, fh)) {\r\nif (list_empty(&fh->vb_vidq.stream))\r\nreturn POLLERR;\r\nbuf = list_entry(fh->vb_vidq.stream.next, struct tm6000_buffer, vb.stream);\r\n} else {\r\nreturn videobuf_poll_stream(file, &fh->vb_vidq, wait);\r\n}\r\npoll_wait(file, &buf->vb.done, wait);\r\nif (buf->vb.state == VIDEOBUF_DONE ||\r\nbuf->vb.state == VIDEOBUF_ERROR)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int tm6000_release(struct file *file)\r\n{\r\nstruct tm6000_fh *fh = file->private_data;\r\nstruct tm6000_core *dev = fh->dev;\r\nstruct video_device *vdev = video_devdata(file);\r\ndprintk(dev, V4L2_DEBUG_OPEN, "tm6000: close called (dev=%s, users=%d)\n",\r\nvideo_device_node_name(vdev), dev->users);\r\ndev->users--;\r\nres_free(dev, fh);\r\nif (!dev->users) {\r\ntm6000_uninit_isoc(dev);\r\ntm6000_ir_int_stop(dev);\r\nusb_reset_configuration(dev->udev);\r\nif (dev->int_in.endp)\r\nusb_set_interface(dev->udev,\r\ndev->isoc_in.bInterfaceNumber, 2);\r\nelse\r\nusb_set_interface(dev->udev,\r\ndev->isoc_in.bInterfaceNumber, 0);\r\ntm6000_ir_int_start(dev);\r\nif (!fh->radio)\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\n}\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int tm6000_mmap(struct file *file, struct vm_area_struct * vma)\r\n{\r\nstruct tm6000_fh *fh = file->private_data;\r\nreturn videobuf_mmap_mapper(&fh->vb_vidq, vma);\r\n}\r\nstatic struct video_device *vdev_init(struct tm6000_core *dev,\r\nconst struct video_device\r\n*template, const char *type_name)\r\n{\r\nstruct video_device *vfd;\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nvfd->debug = tm6000_debug;\r\nvfd->lock = &dev->lock;\r\nset_bit(V4L2_FL_LOCK_ALL_FOPS, &vfd->flags);\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s", dev->name, type_name);\r\nvideo_set_drvdata(vfd, dev);\r\nreturn vfd;\r\n}\r\nint tm6000_v4l2_register(struct tm6000_core *dev)\r\n{\r\nint ret = -1;\r\ndev->vfd = vdev_init(dev, &tm6000_template, "video");\r\nif (!dev->vfd) {\r\nprintk(KERN_INFO "%s: can't register video device\n",\r\ndev->name);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\nINIT_LIST_HEAD(&dev->vidq.queued);\r\nret = video_register_device(dev->vfd, VFL_TYPE_GRABBER, video_nr);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "%s: can't register video device\n",\r\ndev->name);\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s\n",\r\ndev->name, video_device_node_name(dev->vfd));\r\nif (dev->caps.has_radio) {\r\ndev->radio_dev = vdev_init(dev, &tm6000_radio_template,\r\n"radio");\r\nif (!dev->radio_dev) {\r\nprintk(KERN_INFO "%s: can't register radio device\n",\r\ndev->name);\r\nreturn ret;\r\n}\r\nret = video_register_device(dev->radio_dev, VFL_TYPE_RADIO,\r\nradio_nr);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "%s: can't register radio device\n",\r\ndev->name);\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s\n",\r\ndev->name, video_device_node_name(dev->radio_dev));\r\n}\r\nprintk(KERN_INFO "Trident TVMaster TM5600/TM6000/TM6010 USB2 board (Load status: %d)\n", ret);\r\nreturn ret;\r\n}\r\nint tm6000_v4l2_unregister(struct tm6000_core *dev)\r\n{\r\nvideo_unregister_device(dev->vfd);\r\nif (dev->radio_dev) {\r\nif (video_is_registered(dev->radio_dev))\r\nvideo_unregister_device(dev->radio_dev);\r\nelse\r\nvideo_device_release(dev->radio_dev);\r\ndev->radio_dev = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint tm6000_v4l2_exit(void)\r\n{\r\nreturn 0;\r\n}
