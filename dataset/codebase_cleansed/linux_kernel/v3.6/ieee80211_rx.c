static inline void ieee80211_monitor_rx(struct ieee80211_device *ieee,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats)\r\n{\r\nstruct ieee80211_hdr_4addr *hdr =\r\n(struct ieee80211_hdr_4addr *)skb->data;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nskb->dev = ieee->dev;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, ieee80211_get_hdrlen(fc));\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = __constant_htons(ETH_P_80211_RAW);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nstatic struct ieee80211_frag_entry *\r\nieee80211_frag_cache_find(struct ieee80211_device *ieee, unsigned int seq,\r\nunsigned int frag, u8 tid,u8 *src, u8 *dst)\r\n{\r\nstruct ieee80211_frag_entry *entry;\r\nint i;\r\nfor (i = 0; i < IEEE80211_FRAG_CACHE_LEN; i++) {\r\nentry = &ieee->frag_cache[tid][i];\r\nif (entry->skb != NULL &&\r\ntime_after(jiffies, entry->first_frag_time + 2 * HZ)) {\r\nIEEE80211_DEBUG_FRAG(\r\n"expiring fragment cache entry "\r\n"seq=%u last_frag=%u\n",\r\nentry->seq, entry->last_frag);\r\ndev_kfree_skb_any(entry->skb);\r\nentry->skb = NULL;\r\n}\r\nif (entry->skb != NULL && entry->seq == seq &&\r\n(entry->last_frag + 1 == frag || frag == -1) &&\r\nmemcmp(entry->src_addr, src, ETH_ALEN) == 0 &&\r\nmemcmp(entry->dst_addr, dst, ETH_ALEN) == 0)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *\r\nieee80211_frag_cache_get(struct ieee80211_device *ieee,\r\nstruct ieee80211_hdr_4addr *hdr)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nu16 sc = le16_to_cpu(hdr->seq_ctl);\r\nunsigned int frag = WLAN_GET_SEQ_FRAG(sc);\r\nunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\r\nstruct ieee80211_frag_entry *entry;\r\nstruct ieee80211_hdr_3addrqos *hdr_3addrqos;\r\nstruct ieee80211_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif (((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct ieee80211_hdr_4addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QOS_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else if (IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct ieee80211_hdr_3addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QOS_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else {\r\ntid = 0;\r\n}\r\nif (frag == 0) {\r\nskb = dev_alloc_skb(ieee->dev->mtu +\r\nsizeof(struct ieee80211_hdr_4addr) +\r\n8 +\r\n2 +\r\n8 +\r\nETH_ALEN +\r\n(IEEE80211_QOS_HAS_SEQ(fc)?2:0) );\r\nif (skb == NULL)\r\nreturn NULL;\r\nentry = &ieee->frag_cache[tid][ieee->frag_next_idx[tid]];\r\nieee->frag_next_idx[tid]++;\r\nif (ieee->frag_next_idx[tid] >= IEEE80211_FRAG_CACHE_LEN)\r\nieee->frag_next_idx[tid] = 0;\r\nif (entry->skb != NULL)\r\ndev_kfree_skb_any(entry->skb);\r\nentry->first_frag_time = jiffies;\r\nentry->seq = seq;\r\nentry->last_frag = frag;\r\nentry->skb = skb;\r\nmemcpy(entry->src_addr, hdr->addr2, ETH_ALEN);\r\nmemcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);\r\n} else {\r\nentry = ieee80211_frag_cache_find(ieee, seq, frag, tid,hdr->addr2,\r\nhdr->addr1);\r\nif (entry != NULL) {\r\nentry->last_frag = frag;\r\nskb = entry->skb;\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic int ieee80211_frag_cache_invalidate(struct ieee80211_device *ieee,\r\nstruct ieee80211_hdr_4addr *hdr)\r\n{\r\nu16 fc = le16_to_cpu(hdr->frame_ctl);\r\nu16 sc = le16_to_cpu(hdr->seq_ctl);\r\nunsigned int seq = WLAN_GET_SEQ_SEQ(sc);\r\nstruct ieee80211_frag_entry *entry;\r\nstruct ieee80211_hdr_3addrqos *hdr_3addrqos;\r\nstruct ieee80211_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif(((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct ieee80211_hdr_4addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QOS_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else if (IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct ieee80211_hdr_3addrqos *)hdr;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QOS_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else {\r\ntid = 0;\r\n}\r\nentry = ieee80211_frag_cache_find(ieee, seq, -1, tid,hdr->addr2,\r\nhdr->addr1);\r\nif (entry == NULL) {\r\nIEEE80211_DEBUG_FRAG(\r\n"could not invalidate fragment cache "\r\n"entry (seq=%u)\n", seq);\r\nreturn -1;\r\n}\r\nentry->skb = NULL;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nieee80211_rx_frame_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats, u16 type,\r\nu16 stype)\r\n{\r\nstruct ieee80211_hdr_4addr *hdr;\r\nhdr = (struct ieee80211_hdr_4addr *)skb->data;\r\nrx_stats->len = skb->len;\r\nieee80211_rx_mgt(ieee, (struct ieee80211_hdr_4addr *)skb->data,\r\nrx_stats);\r\nif((ieee->state == IEEE80211_LINKED)&&(memcmp(hdr->addr3,ieee->current_network.bssid,ETH_ALEN))) {\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nieee80211_rx_frame_softmac(ieee, skb, rx_stats, type, stype);\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nstatic int ieee80211_is_eapol_frame(struct ieee80211_device *ieee,\r\nstruct sk_buff *skb, size_t hdrlen)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nu16 fc, ethertype;\r\nstruct ieee80211_hdr_4addr *hdr;\r\nu8 *pos;\r\nif (skb->len < 24)\r\nreturn 0;\r\nhdr = (struct ieee80211_hdr_4addr *)skb->data;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\nif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_TODS &&\r\nmemcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&\r\nmemcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {\r\n} else if ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\r\nIEEE80211_FCTL_FROMDS &&\r\nmemcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {\r\n} else\r\nreturn 0;\r\nif (skb->len < 24 + 8)\r\nreturn 0;\r\npos = skb->data + hdrlen;\r\nethertype = (pos[6] << 8) | pos[7];\r\nif (ethertype == ETH_P_PAE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nieee80211_rx_frame_decrypt(struct ieee80211_device* ieee, struct sk_buff *skb,\r\nstruct ieee80211_crypt_data *crypt)\r\n{\r\nstruct ieee80211_hdr_4addr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)\r\nreturn 0;\r\nhdr = (struct ieee80211_hdr_4addr *)skb->data;\r\nhdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\n#ifdef CONFIG_IEEE80211_CRYPT_TKIP\r\nif (ieee->tkip_countermeasures &&\r\nstrcmp(crypt->ops->name, "TKIP") == 0) {\r\nif (net_ratelimit()) {\r\nprintk(KERN_DEBUG "%s: TKIP countermeasures: dropped "\r\n"received packet from %pM\n",\r\nieee->dev->name, hdr->addr2);\r\n}\r\nreturn -1;\r\n}\r\n#endif\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nIEEE80211_DEBUG_DROP(\r\n"decryption failed (SA=%pM"\r\n") res=%d\n", hdr->addr2, res);\r\nif (res == -2)\r\nIEEE80211_DEBUG_DROP("Decryption failed ICV "\r\n"mismatch (key %d)\n",\r\nskb->data[hdrlen + 3] >> 6);\r\nieee->ieee_stats.rx_discards_undecryptable++;\r\nreturn -1;\r\n}\r\nreturn res;\r\n}\r\nstatic inline int\r\nieee80211_rx_frame_decrypt_msdu(struct ieee80211_device* ieee, struct sk_buff *skb,\r\nint keyidx, struct ieee80211_crypt_data *crypt)\r\n{\r\nstruct ieee80211_hdr_4addr *hdr;\r\nint res, hdrlen;\r\nif (crypt == NULL || crypt->ops->decrypt_msdu == NULL)\r\nreturn 0;\r\nhdr = (struct ieee80211_hdr_4addr *)skb->data;\r\nhdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\r\natomic_inc(&crypt->refcnt);\r\nres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nprintk(KERN_DEBUG "%s: MSDU decryption/MIC verification failed"\r\n" (SA=%pM keyidx=%d)\n",\r\nieee->dev->name, hdr->addr2, keyidx);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_duplicate_packet(struct ieee80211_device *ieee,\r\nstruct ieee80211_hdr_4addr *header)\r\n{\r\nu16 fc = le16_to_cpu(header->frame_ctl);\r\nu16 sc = le16_to_cpu(header->seq_ctl);\r\nu16 seq = WLAN_GET_SEQ_SEQ(sc);\r\nu16 frag = WLAN_GET_SEQ_FRAG(sc);\r\nu16 *last_seq, *last_frag;\r\nunsigned long *last_time;\r\nstruct ieee80211_hdr_3addrqos *hdr_3addrqos;\r\nstruct ieee80211_hdr_4addrqos *hdr_4addrqos;\r\nu8 tid;\r\nif(((fc & IEEE80211_FCTL_DSTODS) == IEEE80211_FCTL_DSTODS)&&IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_4addrqos = (struct ieee80211_hdr_4addrqos *)header;\r\ntid = le16_to_cpu(hdr_4addrqos->qos_ctl) & IEEE80211_QOS_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else if(IEEE80211_QOS_HAS_SEQ(fc)) {\r\nhdr_3addrqos = (struct ieee80211_hdr_3addrqos *)header;\r\ntid = le16_to_cpu(hdr_3addrqos->qos_ctl) & IEEE80211_QOS_TID;\r\ntid = UP2AC(tid);\r\ntid ++;\r\n} else {\r\ntid = 0;\r\n}\r\nswitch (ieee->iw_mode) {\r\ncase IW_MODE_ADHOC:\r\n{\r\nstruct list_head *p;\r\nstruct ieee_ibss_seq *entry = NULL;\r\nu8 *mac = header->addr2;\r\nint index = mac[5] % IEEE_IBSS_MAC_HASH_SIZE;\r\n__list_for_each(p, &ieee->ibss_mac_hash[index]) {\r\nentry = list_entry(p, struct ieee_ibss_seq, list);\r\nif (!memcmp(entry->mac, mac, ETH_ALEN))\r\nbreak;\r\n}\r\nif (p == &ieee->ibss_mac_hash[index]) {\r\nentry = kmalloc(sizeof(struct ieee_ibss_seq), GFP_ATOMIC);\r\nif (!entry) {\r\nprintk(KERN_WARNING "Cannot malloc new mac entry\n");\r\nreturn 0;\r\n}\r\nmemcpy(entry->mac, mac, ETH_ALEN);\r\nentry->seq_num[tid] = seq;\r\nentry->frag_num[tid] = frag;\r\nentry->packet_time[tid] = jiffies;\r\nlist_add(&entry->list, &ieee->ibss_mac_hash[index]);\r\nreturn 0;\r\n}\r\nlast_seq = &entry->seq_num[tid];\r\nlast_frag = &entry->frag_num[tid];\r\nlast_time = &entry->packet_time[tid];\r\nbreak;\r\n}\r\ncase IW_MODE_INFRA:\r\nlast_seq = &ieee->last_rxseq_num[tid];\r\nlast_frag = &ieee->last_rxfrag_num[tid];\r\nlast_time = &ieee->last_packet_time[tid];\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif ((*last_seq == seq) &&\r\ntime_after(*last_time + IEEE_PACKET_RETRY_TIME, jiffies)) {\r\nif (*last_frag == frag){\r\ngoto drop;\r\n}\r\nif (*last_frag + 1 != frag)\r\ngoto drop;\r\n} else\r\n*last_seq = seq;\r\n*last_frag = frag;\r\n*last_time = jiffies;\r\nreturn 0;\r\ndrop:\r\nreturn 1;\r\n}\r\nint ieee80211_rtl_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nstruct ieee80211_hdr_4addr *hdr;\r\nsize_t hdrlen;\r\nu16 fc, type, stype, sc;\r\nstruct net_device_stats *stats;\r\nunsigned int frag;\r\nu8 *payload;\r\nu16 ethertype;\r\nu8 dst[ETH_ALEN];\r\nu8 src[ETH_ALEN];\r\nu8 bssid[ETH_ALEN];\r\nstruct ieee80211_crypt_data *crypt = NULL;\r\nint keyidx = 0;\r\nhdr = (struct ieee80211_hdr_4addr *)skb->data;\r\nstats = &ieee->stats;\r\nif (skb->len < 10) {\r\nprintk(KERN_INFO "%s: SKB length < 10\n",\r\ndev->name);\r\ngoto rx_dropped;\r\n}\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nfrag = WLAN_GET_SEQ_FRAG(sc);\r\nif((fc & IEEE80211_FCTL_TODS) != IEEE80211_FCTL_TODS)\r\n{\r\nif(!memcmp(hdr->addr1,dev->dev_addr, ETH_ALEN))\r\n{\r\nieee->NumRxUnicast++;\r\n}\r\n}\r\nelse\r\n{\r\nif(!memcmp(hdr->addr3, dev->dev_addr, ETH_ALEN))\r\n{\r\nieee->NumRxUnicast++;\r\n}\r\n}\r\nhdrlen = ieee80211_get_hdrlen(fc);\r\nif (ieee->iw_mode == IW_MODE_MONITOR) {\r\nieee80211_monitor_rx(ieee, skb, rx_stats);\r\nstats->rx_packets++;\r\nstats->rx_bytes += skb->len;\r\nreturn 1;\r\n}\r\nif (ieee->host_decrypt) {\r\nint idx = 0;\r\nif (skb->len >= hdrlen + 3)\r\nidx = skb->data[hdrlen + 3] >> 6;\r\ncrypt = ieee->crypt[idx];\r\nif (crypt && (crypt->ops == NULL ||\r\ncrypt->ops->decrypt_mpdu == NULL))\r\ncrypt = NULL;\r\nif (!crypt && (fc & IEEE80211_FCTL_WEP)) {\r\nIEEE80211_DEBUG_DROP("Decryption failed (not set)"\r\n" (SA=%pM)\n",\r\nhdr->addr2);\r\nieee->ieee_stats.rx_discards_undecryptable++;\r\ngoto rx_dropped;\r\n}\r\n}\r\nif (skb->len < IEEE80211_DATA_HDR3_LEN)\r\ngoto rx_dropped;\r\nif (is_duplicate_packet(ieee, hdr))\r\ngoto rx_dropped;\r\nif (type == IEEE80211_FTYPE_MGMT) {\r\nif (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\r\ngoto rx_dropped;\r\nelse\r\ngoto rx_exit;\r\n}\r\nswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\r\ncase IEEE80211_FCTL_FROMDS:\r\nmemcpy(dst, hdr->addr1, ETH_ALEN);\r\nmemcpy(src, hdr->addr3, ETH_ALEN);\r\nmemcpy(bssid,hdr->addr2,ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_TODS:\r\nmemcpy(dst, hdr->addr3, ETH_ALEN);\r\nmemcpy(src, hdr->addr2, ETH_ALEN);\r\nmemcpy(bssid,hdr->addr1,ETH_ALEN);\r\nbreak;\r\ncase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\r\nif (skb->len < IEEE80211_DATA_HDR4_LEN)\r\ngoto rx_dropped;\r\nmemcpy(dst, hdr->addr3, ETH_ALEN);\r\nmemcpy(src, hdr->addr4, ETH_ALEN);\r\nmemcpy(bssid, ieee->current_network.bssid, ETH_ALEN);\r\nbreak;\r\ncase 0:\r\nmemcpy(dst, hdr->addr1, ETH_ALEN);\r\nmemcpy(src, hdr->addr2, ETH_ALEN);\r\nmemcpy(bssid,hdr->addr3,ETH_ALEN);\r\nbreak;\r\n}\r\ndev->last_rx = jiffies;\r\nif (stype != IEEE80211_STYPE_DATA &&\r\nstype != IEEE80211_STYPE_DATA_CFACK &&\r\nstype != IEEE80211_STYPE_DATA_CFPOLL &&\r\nstype != IEEE80211_STYPE_DATA_CFACKPOLL&&\r\nstype != IEEE80211_STYPE_QOS_DATA\r\n) {\r\nif (stype != IEEE80211_STYPE_NULLFUNC)\r\nIEEE80211_DEBUG_DROP(\r\n"RX: dropped data frame "\r\n"with no data (type=0x%02x, "\r\n"subtype=0x%02x, len=%d)\n",\r\ntype, stype, skb->len);\r\ngoto rx_dropped;\r\n}\r\nif(memcmp(bssid,ieee->current_network.bssid,ETH_ALEN)) {\r\ngoto rx_dropped;\r\n}\r\nieee->NumRxDataInPeriod++;\r\nieee->NumRxOkTotal++;\r\nif (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&\r\n(keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)\r\ngoto rx_dropped;\r\nhdr = (struct ieee80211_hdr_4addr *)skb->data;\r\nif ((frag != 0 || (fc & IEEE80211_FCTL_MOREFRAGS))) {\r\nint flen;\r\nstruct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);\r\nIEEE80211_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);\r\nif (!frag_skb) {\r\nIEEE80211_DEBUG(IEEE80211_DL_RX | IEEE80211_DL_FRAG,\r\n"Rx cannot get skb from fragment "\r\n"cache (morefrag=%d seq=%u frag=%u)\n",\r\n(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\r\nWLAN_GET_SEQ_SEQ(sc), frag);\r\ngoto rx_dropped;\r\n}\r\nflen = skb->len;\r\nif (frag != 0)\r\nflen -= hdrlen;\r\nif (frag_skb->tail + flen > frag_skb->end) {\r\nprintk(KERN_WARNING "%s: host decrypted and "\r\n"reassembled frame did not fit skb\n",\r\ndev->name);\r\nieee80211_frag_cache_invalidate(ieee, hdr);\r\ngoto rx_dropped;\r\n}\r\nif (frag == 0) {\r\nmemcpy(skb_put(frag_skb, flen), skb->data, flen);\r\n} else {\r\nmemcpy(skb_put(frag_skb, flen), skb->data + hdrlen,\r\nflen);\r\n}\r\ndev_kfree_skb_any(skb);\r\nskb = NULL;\r\nif (fc & IEEE80211_FCTL_MOREFRAGS) {\r\ngoto rx_exit;\r\n}\r\nskb = frag_skb;\r\nhdr = (struct ieee80211_hdr_4addr *)skb->data;\r\nieee80211_frag_cache_invalidate(ieee, hdr);\r\n}\r\nif (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&\r\nieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\r\ngoto rx_dropped;\r\nhdr = (struct ieee80211_hdr_4addr *)skb->data;\r\nif (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep) {\r\nif (\r\nieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nstruct eapol *eap = (struct eapol *)(skb->data +\r\n24);\r\nIEEE80211_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",\r\neap_get_type(eap->type));\r\n#endif\r\n} else {\r\nIEEE80211_DEBUG_DROP(\r\n"encryption configured, but RX "\r\n"frame not encrypted (SA=%pM)\n",\r\nhdr->addr2);\r\ngoto rx_dropped;\r\n}\r\n}\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nif (crypt && !(fc & IEEE80211_FCTL_WEP) &&\r\nieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\r\nstruct eapol *eap = (struct eapol *)(skb->data +\r\n24);\r\nIEEE80211_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",\r\neap_get_type(eap->type));\r\n}\r\n#endif\r\nif (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep &&\r\n!ieee80211_is_eapol_frame(ieee, skb, hdrlen)) {\r\nIEEE80211_DEBUG_DROP(\r\n"dropped unencrypted RX data "\r\n"frame from %pM"\r\n" (drop_unencrypted=1)\n",\r\nhdr->addr2);\r\ngoto rx_dropped;\r\n}\r\npayload = skb->data + hdrlen;\r\nethertype = (payload[6] << 8) | payload[7];\r\nif (skb->len - hdrlen >= 8 &&\r\n((memcmp(payload, rfc1042_header, SNAP_SIZE) == 0 &&\r\nethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\r\nmemcmp(payload, bridge_tunnel_header, SNAP_SIZE) == 0)) {\r\nskb_pull(skb, hdrlen + SNAP_SIZE);\r\nmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\r\nmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\r\n} else {\r\nu16 len;\r\nskb_pull(skb, hdrlen);\r\nlen = htons(skb->len);\r\nmemcpy(skb_push(skb, 2), &len, 2);\r\nmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\r\nmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += skb->len;\r\nif (skb) {\r\nskb->protocol = eth_type_trans(skb, dev);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nskb->dev = dev;\r\nskb->ip_summed = CHECKSUM_NONE;\r\nieee->last_rx_ps_time = jiffies;\r\nnetif_rx(skb);\r\n}\r\nrx_exit:\r\nreturn 1;\r\nrx_dropped:\r\nstats->rx_dropped++;\r\nreturn 0;\r\n}\r\nstatic inline int ieee80211_is_ofdm_rate(u8 rate)\r\n{\r\nswitch (rate & ~IEEE80211_BASIC_RATE_MASK) {\r\ncase IEEE80211_OFDM_RATE_6MB:\r\ncase IEEE80211_OFDM_RATE_9MB:\r\ncase IEEE80211_OFDM_RATE_12MB:\r\ncase IEEE80211_OFDM_RATE_18MB:\r\ncase IEEE80211_OFDM_RATE_24MB:\r\ncase IEEE80211_OFDM_RATE_36MB:\r\ncase IEEE80211_OFDM_RATE_48MB:\r\ncase IEEE80211_OFDM_RATE_54MB:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int ieee80211_SignalStrengthTranslate(\r\nint CurrSS\r\n)\r\n{\r\nint RetSS;\r\nif(CurrSS >= 71 && CurrSS <= 100)\r\n{\r\nRetSS = 90 + ((CurrSS - 70) / 3);\r\n}\r\nelse if(CurrSS >= 41 && CurrSS <= 70)\r\n{\r\nRetSS = 78 + ((CurrSS - 40) / 3);\r\n}\r\nelse if(CurrSS >= 31 && CurrSS <= 40)\r\n{\r\nRetSS = 66 + (CurrSS - 30);\r\n}\r\nelse if(CurrSS >= 21 && CurrSS <= 30)\r\n{\r\nRetSS = 54 + (CurrSS - 20);\r\n}\r\nelse if(CurrSS >= 5 && CurrSS <= 20)\r\n{\r\nRetSS = 42 + (((CurrSS - 5) * 2) / 3);\r\n}\r\nelse if(CurrSS == 4)\r\n{\r\nRetSS = 36;\r\n}\r\nelse if(CurrSS == 3)\r\n{\r\nRetSS = 27;\r\n}\r\nelse if(CurrSS == 2)\r\n{\r\nRetSS = 18;\r\n}\r\nelse if(CurrSS == 1)\r\n{\r\nRetSS = 9;\r\n}\r\nelse\r\n{\r\nRetSS = CurrSS;\r\n}\r\nreturn RetSS;\r\n}\r\nstatic inline void ieee80211_extract_country_ie(\r\nstruct ieee80211_device *ieee,\r\nstruct ieee80211_info_element *info_element,\r\nstruct ieee80211_network *network,\r\nu8 * addr2\r\n)\r\n{\r\nif(IS_DOT11D_ENABLE(ieee))\r\n{\r\nif(info_element->len!= 0)\r\n{\r\nmemcpy(network->CountryIeBuf, info_element->data, info_element->len);\r\nnetwork->CountryIeLen = info_element->len;\r\nif(!IS_COUNTRY_IE_VALID(ieee))\r\n{\r\nDot11d_UpdateCountryIe(ieee, addr2, info_element->len, info_element->data);\r\n}\r\n}\r\nif(IS_EQUAL_CIE_SRC(ieee, addr2) )\r\n{\r\nUPDATE_CIE_WATCHDOG(ieee);\r\n}\r\n}\r\n}\r\nint\r\nieee80211_TranslateToDbm(\r\nunsigned char SignalStrengthIndex\r\n)\r\n{\r\nunsigned char SignalPower;\r\nSignalPower = (int)SignalStrengthIndex * 7 / 10;\r\nSignalPower -= 95;\r\nreturn SignalPower;\r\n}\r\ninline int ieee80211_network_init(\r\nstruct ieee80211_device *ieee,\r\nstruct ieee80211_probe_response *beacon,\r\nstruct ieee80211_network *network,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nchar rates_str[64];\r\nchar *p;\r\n#endif\r\nstruct ieee80211_info_element *info_element;\r\nu16 left;\r\nu8 i;\r\nshort offset;\r\nu8 curRate = 0,hOpRate = 0,curRate_ex = 0;\r\nmemcpy(network->bssid, beacon->header.addr3, ETH_ALEN);\r\nnetwork->capability = beacon->capability;\r\nnetwork->last_scanned = jiffies;\r\nnetwork->time_stamp[0] = beacon->time_stamp[0];\r\nnetwork->time_stamp[1] = beacon->time_stamp[1];\r\nnetwork->beacon_interval = beacon->beacon_interval;\r\nnetwork->listen_interval = 0x0A;\r\nnetwork->rates_len = network->rates_ex_len = 0;\r\nnetwork->last_associate = 0;\r\nnetwork->ssid_len = 0;\r\nnetwork->flags = 0;\r\nnetwork->atim_window = 0;\r\nnetwork->QoS_Enable = 0;\r\nnetwork->HighestOperaRate = 0;\r\nnetwork->Turbo_Enable = 0;\r\nnetwork->CountryIeLen = 0;\r\nmemset(network->CountryIeBuf, 0, MAX_IE_LEN);\r\nif (stats->freq == IEEE80211_52GHZ_BAND) {\r\nnetwork->channel = stats->received_channel;\r\n} else\r\nnetwork->flags |= NETWORK_HAS_CCK;\r\nnetwork->wpa_ie_len = 0;\r\nnetwork->rsn_ie_len = 0;\r\ninfo_element = &beacon->info_element;\r\nleft = stats->len - ((void *)info_element - (void *)beacon);\r\nwhile (left >= sizeof(struct ieee80211_info_element_hdr)) {\r\nif (sizeof(struct ieee80211_info_element_hdr) + info_element->len > left) {\r\nIEEE80211_DEBUG_SCAN("SCAN: parse failed: info_element->len + 2 > left : info_element->len+2=%d left=%d.\n",\r\ninfo_element->len + sizeof(struct ieee80211_info_element),\r\nleft);\r\nreturn 1;\r\n}\r\nswitch (info_element->id) {\r\ncase MFIE_TYPE_SSID:\r\nif (ieee80211_is_empty_essid(info_element->data,\r\ninfo_element->len)) {\r\nnetwork->flags |= NETWORK_EMPTY_ESSID;\r\nbreak;\r\n}\r\nnetwork->ssid_len = min(info_element->len,\r\n(u8)IW_ESSID_MAX_SIZE);\r\nmemcpy(network->ssid, info_element->data, network->ssid_len);\r\nif (network->ssid_len < IW_ESSID_MAX_SIZE)\r\nmemset(network->ssid + network->ssid_len, 0,\r\nIW_ESSID_MAX_SIZE - network->ssid_len);\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_SSID: '%s' len=%d.\n",\r\nnetwork->ssid, network->ssid_len);\r\nbreak;\r\ncase MFIE_TYPE_RATES:\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\np = rates_str;\r\n#endif\r\nnetwork->rates_len = min(info_element->len, MAX_RATES_LENGTH);\r\nfor (i = 0; i < network->rates_len; i++) {\r\nnetwork->rates[i] = info_element->data[i];\r\ncurRate = network->rates[i] & 0x7f;\r\nif( hOpRate < curRate )\r\nhOpRate = curRate;\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\np += snprintf(p, sizeof(rates_str) - (p - rates_str), "%02X ", network->rates[i]);\r\n#endif\r\nif (ieee80211_is_ofdm_rate(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_OFDM;\r\nif (info_element->data[i] &\r\nIEEE80211_BASIC_RATE_MASK)\r\nnetwork->flags &=\r\n~NETWORK_HAS_CCK;\r\n}\r\n}\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_RATES: '%s' (%d)\n",\r\nrates_str, network->rates_len);\r\nbreak;\r\ncase MFIE_TYPE_RATES_EX:\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\np = rates_str;\r\n#endif\r\nnetwork->rates_ex_len = min(info_element->len, MAX_RATES_EX_LENGTH);\r\nfor (i = 0; i < network->rates_ex_len; i++) {\r\nnetwork->rates_ex[i] = info_element->data[i];\r\ncurRate_ex = network->rates_ex[i] & 0x7f;\r\nif( hOpRate < curRate_ex )\r\nhOpRate = curRate_ex;\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\np += snprintf(p, sizeof(rates_str) - (p - rates_str), "%02X ", network->rates[i]);\r\n#endif\r\nif (ieee80211_is_ofdm_rate(info_element->data[i])) {\r\nnetwork->flags |= NETWORK_HAS_OFDM;\r\nif (info_element->data[i] &\r\nIEEE80211_BASIC_RATE_MASK)\r\nnetwork->flags &=\r\n~NETWORK_HAS_CCK;\r\n}\r\n}\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_RATES_EX: '%s' (%d)\n",\r\nrates_str, network->rates_ex_len);\r\nbreak;\r\ncase MFIE_TYPE_DS_SET:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_DS_SET: %d\n",\r\ninfo_element->data[0]);\r\nif (stats->freq == IEEE80211_24GHZ_BAND)\r\nnetwork->channel = info_element->data[0];\r\nbreak;\r\ncase MFIE_TYPE_FH_SET:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_FH_SET: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_CF_SET:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_CF_SET: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_TIM:\r\nif(info_element->len < 4)\r\nbreak;\r\nnetwork->dtim_period = info_element->data[1];\r\nif(ieee->state != IEEE80211_LINKED)\r\nbreak;\r\nnetwork->last_dtim_sta_time[0] = jiffies;\r\nnetwork->last_dtim_sta_time[1] = stats->mac_time[1];\r\nnetwork->dtim_data = IEEE80211_DTIM_VALID;\r\nif(info_element->data[0] != 0)\r\nbreak;\r\nif(info_element->data[2] & 1)\r\nnetwork->dtim_data |= IEEE80211_DTIM_MBCAST;\r\noffset = (info_element->data[2] >> 1)*2;\r\nif(ieee->assoc_id < 8*offset ||\r\nieee->assoc_id > 8*(offset + info_element->len -3)) {\r\nbreak;\r\n}\r\noffset = (ieee->assoc_id/8) - offset;\r\nif(info_element->data[3+offset] & (1<<(ieee->assoc_id%8))) {\r\nnetwork->dtim_data |= IEEE80211_DTIM_UCAST;\r\n}\r\nbreak;\r\ncase MFIE_TYPE_IBSS_SET:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_IBSS_SET: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_CHALLENGE:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_CHALLENGE: ignored\n");\r\nbreak;\r\ncase MFIE_TYPE_GENERIC:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_GENERIC: %d bytes\n",\r\ninfo_element->len);\r\nif (info_element->len >= 4 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0xf2 &&\r\ninfo_element->data[3] == 0x01) {\r\nnetwork->wpa_ie_len = min(info_element->len + 2,\r\nMAX_WPA_IE_LEN);\r\nmemcpy(network->wpa_ie, info_element,\r\nnetwork->wpa_ie_len);\r\n}\r\nif (info_element->len == 7 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0xe0 &&\r\ninfo_element->data[2] == 0x4c &&\r\ninfo_element->data[3] == 0x01 &&\r\ninfo_element->data[4] == 0x02) {\r\nnetwork->Turbo_Enable = 1;\r\n}\r\nif (1 == stats->nic_type) {\r\nbreak;\r\n}\r\nif (info_element->len >= 5 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0xf2 &&\r\ninfo_element->data[3] == 0x02 &&\r\ninfo_element->data[4] == 0x00) {\r\nnetwork->wmm_info = info_element->data[6];\r\nnetwork->QoS_Enable = 1;\r\n}\r\nif (info_element->len >= 8 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0xf2 &&\r\ninfo_element->data[3] == 0x02 &&\r\ninfo_element->data[4] == 0x01) {\r\nnetwork->wmm_info = info_element->data[6];\r\nmemcpy(network->wmm_param, (u8 *)(info_element->data + 8),(info_element->len - 8));\r\nnetwork->QoS_Enable = 1;\r\n}\r\nbreak;\r\ncase MFIE_TYPE_RSN:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_RSN: %d bytes\n",\r\ninfo_element->len);\r\nnetwork->rsn_ie_len = min(info_element->len + 2,\r\nMAX_WPA_IE_LEN);\r\nmemcpy(network->rsn_ie, info_element,\r\nnetwork->rsn_ie_len);\r\nbreak;\r\ncase MFIE_TYPE_COUNTRY:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_COUNTRY: %d bytes\n",\r\ninfo_element->len);\r\nieee80211_extract_country_ie(ieee, info_element, network, beacon->header.addr2);\r\nbreak;\r\ndefault:\r\nIEEE80211_DEBUG_SCAN("unsupported IE %d\n",\r\ninfo_element->id);\r\nbreak;\r\n}\r\nleft -= sizeof(struct ieee80211_info_element_hdr) +\r\ninfo_element->len;\r\ninfo_element = (struct ieee80211_info_element *)\r\n&info_element->data[info_element->len];\r\n}\r\nnetwork->HighestOperaRate = hOpRate;\r\nnetwork->mode = 0;\r\nif (stats->freq == IEEE80211_52GHZ_BAND)\r\nnetwork->mode = IEEE_A;\r\nelse {\r\nif (network->flags & NETWORK_HAS_OFDM)\r\nnetwork->mode |= IEEE_G;\r\nif (network->flags & NETWORK_HAS_CCK)\r\nnetwork->mode |= IEEE_B;\r\n}\r\nif (network->mode == 0) {\r\nIEEE80211_DEBUG_SCAN("Filtered out '%s (%pM)' "\r\n"network.\n",\r\nescape_essid(network->ssid,\r\nnetwork->ssid_len),\r\nnetwork->bssid);\r\nreturn 1;\r\n}\r\nif (ieee80211_is_empty_essid(network->ssid, network->ssid_len))\r\nnetwork->flags |= NETWORK_EMPTY_ESSID;\r\nstats->signal = ieee80211_TranslateToDbm(stats->signalstrength);\r\nstats->noise = ieee80211_TranslateToDbm(100 - stats->signalstrength) - 25;\r\nmemcpy(&network->stats, stats, sizeof(network->stats));\r\nreturn 0;\r\n}\r\nstatic inline int is_same_network(struct ieee80211_network *src,\r\nstruct ieee80211_network *dst,\r\nstruct ieee80211_device * ieee)\r\n{\r\nreturn (((src->ssid_len == dst->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&\r\n(src->channel == dst->channel) &&\r\n!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&\r\n(!memcmp(src->ssid, dst->ssid, src->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&\r\n((src->capability & WLAN_CAPABILITY_IBSS) ==\r\n(dst->capability & WLAN_CAPABILITY_IBSS)) &&\r\n((src->capability & WLAN_CAPABILITY_BSS) ==\r\n(dst->capability & WLAN_CAPABILITY_BSS)));\r\n}\r\ninline void update_network(struct ieee80211_network *dst,\r\nstruct ieee80211_network *src)\r\n{\r\nunsigned char quality = src->stats.signalstrength;\r\nunsigned char signal = 0;\r\nunsigned char noise = 0;\r\nif(dst->stats.signalstrength > 0) {\r\nquality = (dst->stats.signalstrength * 5 + src->stats.signalstrength + 5)/6;\r\n}\r\nsignal = ieee80211_TranslateToDbm(quality);\r\nif(dst->stats.noise > 0)\r\nnoise = (dst->stats.noise * 5 + src->stats.noise)/6;\r\nmemcpy(&dst->stats, &src->stats, sizeof(struct ieee80211_rx_stats));\r\ndst->stats.signalstrength = quality;\r\ndst->stats.signal = signal;\r\ndst->stats.noise = noise;\r\ndst->capability = src->capability;\r\nmemcpy(dst->rates, src->rates, src->rates_len);\r\ndst->rates_len = src->rates_len;\r\nmemcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);\r\ndst->rates_ex_len = src->rates_ex_len;\r\ndst->HighestOperaRate= src->HighestOperaRate;\r\nif(src->ssid_len > 0)\r\n{\r\nmemset(dst->ssid, 0, dst->ssid_len);\r\ndst->ssid_len = src->ssid_len;\r\nmemcpy(dst->ssid, src->ssid, src->ssid_len);\r\n}\r\ndst->channel = src->channel;\r\ndst->mode = src->mode;\r\ndst->flags = src->flags;\r\ndst->time_stamp[0] = src->time_stamp[0];\r\ndst->time_stamp[1] = src->time_stamp[1];\r\ndst->beacon_interval = src->beacon_interval;\r\ndst->listen_interval = src->listen_interval;\r\ndst->atim_window = src->atim_window;\r\ndst->dtim_period = src->dtim_period;\r\ndst->dtim_data = src->dtim_data;\r\ndst->last_dtim_sta_time[0] = src->last_dtim_sta_time[0];\r\ndst->last_dtim_sta_time[1] = src->last_dtim_sta_time[1];\r\nmemcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);\r\ndst->wpa_ie_len = src->wpa_ie_len;\r\nmemcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);\r\ndst->rsn_ie_len = src->rsn_ie_len;\r\ndst->last_scanned = jiffies;\r\n#if 1\r\ndst->wmm_info = src->wmm_info;\r\nif(src->wmm_param[0].ac_aci_acm_aifsn|| \\r\nsrc->wmm_param[1].ac_aci_acm_aifsn|| \\r\nsrc->wmm_param[2].ac_aci_acm_aifsn|| \\r\nsrc->wmm_param[3].ac_aci_acm_aifsn) {\r\nmemcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);\r\n}\r\ndst->QoS_Enable = src->QoS_Enable;\r\n#else\r\ndst->QoS_Enable = 1;\r\n#endif\r\ndst->SignalStrength = src->SignalStrength;\r\ndst->Turbo_Enable = src->Turbo_Enable;\r\ndst->CountryIeLen = src->CountryIeLen;\r\nmemcpy(dst->CountryIeBuf, src->CountryIeBuf, src->CountryIeLen);\r\n}\r\ninline void ieee80211_process_probe_response(\r\nstruct ieee80211_device *ieee,\r\nstruct ieee80211_probe_response *beacon,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\nstruct ieee80211_network network;\r\nstruct ieee80211_network *target;\r\nstruct ieee80211_network *oldest = NULL;\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nstruct ieee80211_info_element *info_element = &beacon->info_element;\r\n#endif\r\nunsigned long flags;\r\nshort renew;\r\nu8 wmm_info;\r\nu8 is_beacon = (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) == IEEE80211_STYPE_BEACON)? 1:0;\r\nmemset(&network, 0, sizeof(struct ieee80211_network));\r\nIEEE80211_DEBUG_SCAN(\r\n"'%s' (%pM): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\n",\r\nescape_essid(info_element->data, info_element->len),\r\nbeacon->header.addr3,\r\n(beacon->capability & (1<<0xf)) ? '1' : '0',\r\n(beacon->capability & (1<<0xe)) ? '1' : '0',\r\n(beacon->capability & (1<<0xd)) ? '1' : '0',\r\n(beacon->capability & (1<<0xc)) ? '1' : '0',\r\n(beacon->capability & (1<<0xb)) ? '1' : '0',\r\n(beacon->capability & (1<<0xa)) ? '1' : '0',\r\n(beacon->capability & (1<<0x9)) ? '1' : '0',\r\n(beacon->capability & (1<<0x8)) ? '1' : '0',\r\n(beacon->capability & (1<<0x7)) ? '1' : '0',\r\n(beacon->capability & (1<<0x6)) ? '1' : '0',\r\n(beacon->capability & (1<<0x5)) ? '1' : '0',\r\n(beacon->capability & (1<<0x4)) ? '1' : '0',\r\n(beacon->capability & (1<<0x3)) ? '1' : '0',\r\n(beacon->capability & (1<<0x2)) ? '1' : '0',\r\n(beacon->capability & (1<<0x1)) ? '1' : '0',\r\n(beacon->capability & (1<<0x0)) ? '1' : '0');\r\nif (ieee80211_network_init(ieee, beacon, &network, stats)) {\r\nIEEE80211_DEBUG_SCAN("Dropped '%s' (%pM) via %s.\n",\r\nescape_essid(info_element->data,\r\ninfo_element->len),\r\nbeacon->header.addr3,\r\nWLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==\r\nIEEE80211_STYPE_PROBE_RESP ?\r\n"PROBE RESPONSE" : "BEACON");\r\nreturn;\r\n}\r\nif(ieee->bGlobalDomain)\r\n{\r\nif (WLAN_FC_GET_STYPE(beacon->header.frame_ctl) == IEEE80211_STYPE_PROBE_RESP)\r\n{\r\nif(IS_COUNTRY_IE_VALID(ieee) )\r\n{\r\nif( !IsLegalChannel(ieee, network.channel) )\r\n{\r\nprintk("GetScanInfo(): For Country code, filter probe response at channel(%d).\n", network.channel);\r\nreturn;\r\n}\r\n}\r\nelse\r\n{\r\nif(network.channel > 11)\r\n{\r\nprintk("GetScanInfo(): For Global Domain, filter probe response at channel(%d).\n", network.channel);\r\nreturn;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif(IS_COUNTRY_IE_VALID(ieee) )\r\n{\r\nif( !IsLegalChannel(ieee, network.channel) )\r\n{\r\nprintk("GetScanInfo(): For Country code, filter beacon at channel(%d).\n",network.channel);\r\nreturn;\r\n}\r\n}\r\nelse\r\n{\r\nif(network.channel > 14)\r\n{\r\nprintk("GetScanInfo(): For Global Domain, filter beacon at channel(%d).\n",network.channel);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif(is_same_network(&ieee->current_network, &network, ieee)) {\r\nwmm_info = ieee->current_network.wmm_info;\r\nif(is_beacon == 0)\r\nnetwork.flags = (~NETWORK_EMPTY_ESSID & network.flags)|(NETWORK_EMPTY_ESSID & ieee->current_network.flags);\r\nelse if(ieee->state == IEEE80211_LINKED)\r\nieee->NumRxBcnInPeriod++;\r\nupdate_network(&ieee->current_network, &network);\r\n}\r\nlist_for_each_entry(target, &ieee->network_list, list) {\r\nif (is_same_network(target, &network, ieee))\r\nbreak;\r\nif ((oldest == NULL) ||\r\n(target->last_scanned < oldest->last_scanned))\r\noldest = target;\r\n}\r\nif (&target->list == &ieee->network_list) {\r\nif (list_empty(&ieee->network_free_list)) {\r\nlist_del(&oldest->list);\r\ntarget = oldest;\r\nIEEE80211_DEBUG_SCAN("Expired '%s' (%pM) from "\r\n"network list.\n",\r\nescape_essid(target->ssid,\r\ntarget->ssid_len),\r\ntarget->bssid);\r\n} else {\r\ntarget = list_entry(ieee->network_free_list.next,\r\nstruct ieee80211_network, list);\r\nlist_del(ieee->network_free_list.next);\r\n}\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nIEEE80211_DEBUG_SCAN("Adding '%s' (%pM) via %s.\n",\r\nescape_essid(network.ssid,\r\nnetwork.ssid_len),\r\nnetwork.bssid,\r\nWLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==\r\nIEEE80211_STYPE_PROBE_RESP ?\r\n"PROBE RESPONSE" : "BEACON");\r\n#endif\r\nmemcpy(target, &network, sizeof(*target));\r\nlist_add_tail(&target->list, &ieee->network_list);\r\n} else {\r\nIEEE80211_DEBUG_SCAN("Updating '%s' (%pM) via %s.\n",\r\nescape_essid(target->ssid,\r\ntarget->ssid_len),\r\ntarget->bssid,\r\nWLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==\r\nIEEE80211_STYPE_PROBE_RESP ?\r\n"PROBE RESPONSE" : "BEACON");\r\nrenew = !time_after(target->last_scanned + ieee->scan_age, jiffies);\r\nif(is_beacon == 0)\r\nnetwork.flags = (~NETWORK_EMPTY_ESSID & network.flags)|(NETWORK_EMPTY_ESSID & target->flags);\r\nif(((network.flags & NETWORK_EMPTY_ESSID) == NETWORK_EMPTY_ESSID) \\r\n&& (((network.ssid_len > 0) && (strncmp(target->ssid, network.ssid, network.ssid_len)))\\r\n||((ieee->current_network.ssid_len == network.ssid_len)&&(strncmp(ieee->current_network.ssid, network.ssid, network.ssid_len) == 0)&&(ieee->state == IEEE80211_NOLINK))))\r\nrenew = 1;\r\nupdate_network(target, &network);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid ieee80211_rx_mgt(struct ieee80211_device *ieee,\r\nstruct ieee80211_hdr_4addr *header,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\nswitch (WLAN_FC_GET_STYPE(header->frame_ctl)) {\r\ncase IEEE80211_STYPE_BEACON:\r\nIEEE80211_DEBUG_MGMT("received BEACON (%d)\n",\r\nWLAN_FC_GET_STYPE(header->frame_ctl));\r\nIEEE80211_DEBUG_SCAN("Beacon\n");\r\nieee80211_process_probe_response(\r\nieee, (struct ieee80211_probe_response *)header, stats);\r\nbreak;\r\ncase IEEE80211_STYPE_PROBE_RESP:\r\nIEEE80211_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(header->frame_ctl));\r\nIEEE80211_DEBUG_SCAN("Probe response\n");\r\nieee80211_process_probe_response(\r\nieee, (struct ieee80211_probe_response *)header, stats);\r\nbreak;\r\n}\r\n}
