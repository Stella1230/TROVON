static void icside_irqenable_arcin_v5 (struct expansion_card *ec, int irqnr)\r\n{\r\nstruct icside_state *state = ec->irq_data;\r\nwriteb(0, state->irq_port + ICS_ARCIN_V5_INTROFFSET);\r\n}\r\nstatic void icside_irqdisable_arcin_v5 (struct expansion_card *ec, int irqnr)\r\n{\r\nstruct icside_state *state = ec->irq_data;\r\nreadb(state->irq_port + ICS_ARCIN_V5_INTROFFSET);\r\n}\r\nstatic void icside_irqenable_arcin_v6 (struct expansion_card *ec, int irqnr)\r\n{\r\nstruct icside_state *state = ec->irq_data;\r\nvoid __iomem *base = state->irq_port;\r\nstate->enabled = 1;\r\nswitch (state->channel) {\r\ncase 0:\r\nwriteb(0, base + ICS_ARCIN_V6_INTROFFSET_1);\r\nreadb(base + ICS_ARCIN_V6_INTROFFSET_2);\r\nbreak;\r\ncase 1:\r\nwriteb(0, base + ICS_ARCIN_V6_INTROFFSET_2);\r\nreadb(base + ICS_ARCIN_V6_INTROFFSET_1);\r\nbreak;\r\n}\r\n}\r\nstatic void icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)\r\n{\r\nstruct icside_state *state = ec->irq_data;\r\nstate->enabled = 0;\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);\r\n}\r\nstatic int icside_irqpending_arcin_v6(struct expansion_card *ec)\r\n{\r\nstruct icside_state *state = ec->irq_data;\r\nreturn readb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_1) & 1 ||\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_2) & 1;\r\n}\r\nstatic void icside_maskproc(ide_drive_t *drive, int mask)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct expansion_card *ec = ECARD_DEV(hwif->dev);\r\nstruct icside_state *state = ecard_get_drvdata(ec);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nstate->channel = hwif->channel;\r\nif (state->enabled && !mask) {\r\nswitch (hwif->channel) {\r\ncase 0:\r\nwriteb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);\r\nbreak;\r\ncase 1:\r\nwriteb(0, state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);\r\nbreak;\r\n}\r\n} else {\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void icside_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nunsigned long cycle_time = 0;\r\nint use_dma_info = 0;\r\nconst u8 xfer_mode = drive->dma_mode;\r\nswitch (xfer_mode) {\r\ncase XFER_MW_DMA_2:\r\ncycle_time = 250;\r\nuse_dma_info = 1;\r\nbreak;\r\ncase XFER_MW_DMA_1:\r\ncycle_time = 250;\r\nuse_dma_info = 1;\r\nbreak;\r\ncase XFER_MW_DMA_0:\r\ncycle_time = 480;\r\nbreak;\r\ncase XFER_SW_DMA_2:\r\ncase XFER_SW_DMA_1:\r\ncase XFER_SW_DMA_0:\r\ncycle_time = 480;\r\nbreak;\r\n}\r\nif (use_dma_info && drive->id[ATA_ID_EIDE_DMA_TIME] > cycle_time)\r\ncycle_time = drive->id[ATA_ID_EIDE_DMA_TIME];\r\nide_set_drivedata(drive, (void *)cycle_time);\r\nprintk(KERN_INFO "%s: %s selected (peak %luMB/s)\n",\r\ndrive->name, ide_xfer_verbose(xfer_mode),\r\n2000 / (cycle_time ? cycle_time : (unsigned long) -1));\r\n}\r\nstatic void icside_dma_host_set(ide_drive_t *drive, int on)\r\n{\r\n}\r\nstatic int icside_dma_end(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct expansion_card *ec = ECARD_DEV(hwif->dev);\r\ndisable_dma(ec->dma);\r\nreturn get_dma_residue(ec->dma) != 0;\r\n}\r\nstatic void icside_dma_start(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct expansion_card *ec = ECARD_DEV(hwif->dev);\r\nBUG_ON(dma_channel_active(ec->dma));\r\nenable_dma(ec->dma);\r\n}\r\nstatic int icside_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct expansion_card *ec = ECARD_DEV(hwif->dev);\r\nstruct icside_state *state = ecard_get_drvdata(ec);\r\nunsigned int dma_mode;\r\nif (cmd->tf_flags & IDE_TFLAG_WRITE)\r\ndma_mode = DMA_MODE_WRITE;\r\nelse\r\ndma_mode = DMA_MODE_READ;\r\nBUG_ON(dma_channel_active(ec->dma));\r\nicside_maskproc(drive, 0);\r\nwriteb(state->sel | hwif->channel, state->ioc_base);\r\nset_dma_speed(ec->dma, (unsigned long)ide_get_drivedata(drive));\r\nset_dma_sg(ec->dma, hwif->sg_table, cmd->sg_nents);\r\nset_dma_mode(ec->dma, dma_mode);\r\nreturn 0;\r\n}\r\nstatic int icside_dma_test_irq(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct expansion_card *ec = ECARD_DEV(hwif->dev);\r\nstruct icside_state *state = ecard_get_drvdata(ec);\r\nreturn readb(state->irq_port +\r\n(hwif->channel ?\r\nICS_ARCIN_V6_INTRSTAT_2 :\r\nICS_ARCIN_V6_INTRSTAT_1)) & 1;\r\n}\r\nstatic int icside_dma_init(ide_hwif_t *hwif, const struct ide_port_info *d)\r\n{\r\nhwif->dmatable_cpu = NULL;\r\nhwif->dmatable_dma = 0;\r\nreturn 0;\r\n}\r\nstatic int icside_dma_off_init(ide_hwif_t *hwif, const struct ide_port_info *d)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void icside_setup_ports(struct ide_hw *hw, void __iomem *base,\r\nstruct cardinfo *info, struct expansion_card *ec)\r\n{\r\nunsigned long port = (unsigned long)base + info->dataoffset;\r\nhw->io_ports.data_addr = port;\r\nhw->io_ports.error_addr = port + (1 << info->stepping);\r\nhw->io_ports.nsect_addr = port + (2 << info->stepping);\r\nhw->io_ports.lbal_addr = port + (3 << info->stepping);\r\nhw->io_ports.lbam_addr = port + (4 << info->stepping);\r\nhw->io_ports.lbah_addr = port + (5 << info->stepping);\r\nhw->io_ports.device_addr = port + (6 << info->stepping);\r\nhw->io_ports.status_addr = port + (7 << info->stepping);\r\nhw->io_ports.ctl_addr = (unsigned long)base + info->ctrloffset;\r\nhw->irq = ec->irq;\r\nhw->dev = &ec->dev;\r\n}\r\nstatic int __devinit\r\nicside_register_v5(struct icside_state *state, struct expansion_card *ec)\r\n{\r\nvoid __iomem *base;\r\nstruct ide_host *host;\r\nstruct ide_hw hw, *hws[] = { &hw };\r\nint ret;\r\nbase = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);\r\nif (!base)\r\nreturn -ENOMEM;\r\nstate->irq_port = base;\r\nec->irqaddr = base + ICS_ARCIN_V5_INTRSTAT;\r\nec->irqmask = 1;\r\necard_setirq(ec, &icside_ops_arcin_v5, state);\r\nicside_irqdisable_arcin_v5(ec, 0);\r\nicside_setup_ports(&hw, base, &icside_cardinfo_v5, ec);\r\nhost = ide_host_alloc(&icside_v5_port_info, hws, 1);\r\nif (host == NULL)\r\nreturn -ENODEV;\r\nstate->host = host;\r\necard_set_drvdata(ec, state);\r\nret = ide_host_register(host, &icside_v5_port_info, hws);\r\nif (ret)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\nide_host_free(host);\r\necard_set_drvdata(ec, NULL);\r\nreturn ret;\r\n}\r\nstatic int __devinit\r\nicside_register_v6(struct icside_state *state, struct expansion_card *ec)\r\n{\r\nvoid __iomem *ioc_base, *easi_base;\r\nstruct ide_host *host;\r\nunsigned int sel = 0;\r\nint ret;\r\nstruct ide_hw hw[2], *hws[] = { &hw[0], &hw[1] };\r\nstruct ide_port_info d = icside_v6_port_info;\r\nioc_base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\r\nif (!ioc_base) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\neasi_base = ioc_base;\r\nif (ecard_resource_flags(ec, ECARD_RES_EASI)) {\r\neasi_base = ecardm_iomap(ec, ECARD_RES_EASI, 0, 0);\r\nif (!easi_base) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsel = 1 << 5;\r\n}\r\nwriteb(sel, ioc_base);\r\necard_setirq(ec, &icside_ops_arcin_v6, state);\r\nstate->irq_port = easi_base;\r\nstate->ioc_base = ioc_base;\r\nstate->sel = sel;\r\nicside_irqdisable_arcin_v6(ec, 0);\r\nicside_setup_ports(&hw[0], easi_base, &icside_cardinfo_v6_1, ec);\r\nicside_setup_ports(&hw[1], easi_base, &icside_cardinfo_v6_2, ec);\r\nhost = ide_host_alloc(&d, hws, 2);\r\nif (host == NULL)\r\nreturn -ENODEV;\r\nstate->host = host;\r\necard_set_drvdata(ec, state);\r\n#ifdef CONFIG_BLK_DEV_IDEDMA_ICS\r\nif (ec->dma != NO_DMA && !request_dma(ec->dma, DRV_NAME)) {\r\nd.init_dma = icside_dma_init;\r\nd.port_ops = &icside_v6_port_ops;\r\nd.dma_ops = &icside_v6_dma_ops;\r\n}\r\n#endif\r\nret = ide_host_register(host, &d, hws);\r\nif (ret)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\nide_host_free(host);\r\nif (d.dma_ops)\r\nfree_dma(ec->dma);\r\necard_set_drvdata(ec, NULL);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __devinit\r\nicside_probe(struct expansion_card *ec, const struct ecard_id *id)\r\n{\r\nstruct icside_state *state;\r\nvoid __iomem *idmem;\r\nint ret;\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\nstate = kzalloc(sizeof(struct icside_state), GFP_KERNEL);\r\nif (!state) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nstate->type = ICS_TYPE_NOTYPE;\r\nidmem = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\r\nif (idmem) {\r\nunsigned int type;\r\ntype = readb(idmem + ICS_IDENT_OFFSET) & 1;\r\ntype |= (readb(idmem + ICS_IDENT_OFFSET + 4) & 1) << 1;\r\ntype |= (readb(idmem + ICS_IDENT_OFFSET + 8) & 1) << 2;\r\ntype |= (readb(idmem + ICS_IDENT_OFFSET + 12) & 1) << 3;\r\necardm_iounmap(ec, idmem);\r\nstate->type = type;\r\n}\r\nswitch (state->type) {\r\ncase ICS_TYPE_A3IN:\r\ndev_warn(&ec->dev, "A3IN unsupported\n");\r\nret = -ENODEV;\r\nbreak;\r\ncase ICS_TYPE_A3USER:\r\ndev_warn(&ec->dev, "A3USER unsupported\n");\r\nret = -ENODEV;\r\nbreak;\r\ncase ICS_TYPE_V5:\r\nret = icside_register_v5(state, ec);\r\nbreak;\r\ncase ICS_TYPE_V6:\r\nret = icside_register_v6(state, ec);\r\nbreak;\r\ndefault:\r\ndev_warn(&ec->dev, "unknown interface type\n");\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nif (ret == 0)\r\ngoto out;\r\nkfree(state);\r\nrelease:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __devexit icside_remove(struct expansion_card *ec)\r\n{\r\nstruct icside_state *state = ecard_get_drvdata(ec);\r\nswitch (state->type) {\r\ncase ICS_TYPE_V5:\r\nicside_irqdisable_arcin_v5(ec, 0);\r\nbreak;\r\ncase ICS_TYPE_V6:\r\nif (ec->dma != NO_DMA)\r\nfree_dma(ec->dma);\r\nicside_irqdisable_arcin_v6(ec, 0);\r\nwriteb(0, state->ioc_base);\r\nbreak;\r\n}\r\necard_set_drvdata(ec, NULL);\r\nkfree(state);\r\necard_release_resources(ec);\r\n}\r\nstatic void icside_shutdown(struct expansion_card *ec)\r\n{\r\nstruct icside_state *state = ecard_get_drvdata(ec);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nec->ops->irqdisable(ec, 0);\r\nlocal_irq_restore(flags);\r\nif (state->ioc_base)\r\nwriteb(0, state->ioc_base);\r\n}\r\nstatic int __init icside_init(void)\r\n{\r\nreturn ecard_register_driver(&icside_driver);\r\n}\r\nstatic void __exit icside_exit(void)\r\n{\r\necard_remove_driver(&icside_driver);\r\n}
