static pgprot_t drm_io_prot(uint32_t map_type, struct vm_area_struct *vma)\r\n{\r\npgprot_t tmp = vm_get_page_prot(vma->vm_flags);\r\n#if defined(__i386__) || defined(__x86_64__)\r\nif (boot_cpu_data.x86 > 3 && map_type != _DRM_AGP) {\r\npgprot_val(tmp) |= _PAGE_PCD;\r\npgprot_val(tmp) &= ~_PAGE_PWT;\r\n}\r\n#elif defined(__powerpc__)\r\npgprot_val(tmp) |= _PAGE_NO_CACHE;\r\nif (map_type == _DRM_REGISTERS)\r\npgprot_val(tmp) |= _PAGE_GUARDED;\r\n#elif defined(__ia64__)\r\nif (efi_range_is_wc(vma->vm_start, vma->vm_end -\r\nvma->vm_start))\r\ntmp = pgprot_writecombine(tmp);\r\nelse\r\ntmp = pgprot_noncached(tmp);\r\n#elif defined(__sparc__) || defined(__arm__)\r\ntmp = pgprot_noncached(tmp);\r\n#endif\r\nreturn tmp;\r\n}\r\nstatic pgprot_t drm_dma_prot(uint32_t map_type, struct vm_area_struct *vma)\r\n{\r\npgprot_t tmp = vm_get_page_prot(vma->vm_flags);\r\n#if defined(__powerpc__) && defined(CONFIG_NOT_COHERENT_CACHE)\r\ntmp |= _PAGE_NO_CACHE;\r\n#endif\r\nreturn tmp;\r\n}\r\nstatic int drm_do_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_file *priv = vma->vm_file->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nstruct drm_local_map *map = NULL;\r\nstruct drm_map_list *r_list;\r\nstruct drm_hash_item *hash;\r\nif (!drm_core_has_AGP(dev))\r\ngoto vm_fault_error;\r\nif (!dev->agp || !dev->agp->cant_use_aperture)\r\ngoto vm_fault_error;\r\nif (drm_ht_find_item(&dev->map_hash, vma->vm_pgoff, &hash))\r\ngoto vm_fault_error;\r\nr_list = drm_hash_entry(hash, struct drm_map_list, hash);\r\nmap = r_list->map;\r\nif (map && map->type == _DRM_AGP) {\r\nresource_size_t offset = (unsigned long)vmf->virtual_address -\r\nvma->vm_start;\r\nresource_size_t baddr = map->offset + offset;\r\nstruct drm_agp_mem *agpmem;\r\nstruct page *page;\r\n#ifdef __alpha__\r\nbaddr -= dev->hose->mem_space->start;\r\n#endif\r\nlist_for_each_entry(agpmem, &dev->agp->memory, head) {\r\nif (agpmem->bound <= baddr &&\r\nagpmem->bound + agpmem->pages * PAGE_SIZE > baddr)\r\nbreak;\r\n}\r\nif (&agpmem->head == &dev->agp->memory)\r\ngoto vm_fault_error;\r\noffset = (baddr - agpmem->bound) >> PAGE_SHIFT;\r\npage = agpmem->memory->pages[offset];\r\nget_page(page);\r\nvmf->page = page;\r\nDRM_DEBUG\r\n("baddr = 0x%llx page = 0x%p, offset = 0x%llx, count=%d\n",\r\n(unsigned long long)baddr,\r\nagpmem->memory->pages[offset],\r\n(unsigned long long)offset,\r\npage_count(page));\r\nreturn 0;\r\n}\r\nvm_fault_error:\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nstatic int drm_do_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nstatic int drm_do_vm_shm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_local_map *map = vma->vm_private_data;\r\nunsigned long offset;\r\nunsigned long i;\r\nstruct page *page;\r\nif (!map)\r\nreturn VM_FAULT_SIGBUS;\r\noffset = (unsigned long)vmf->virtual_address - vma->vm_start;\r\ni = (unsigned long)map->handle + offset;\r\npage = vmalloc_to_page((void *)i);\r\nif (!page)\r\nreturn VM_FAULT_SIGBUS;\r\nget_page(page);\r\nvmf->page = page;\r\nDRM_DEBUG("shm_fault 0x%lx\n", offset);\r\nreturn 0;\r\n}\r\nstatic void drm_vm_shm_close(struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *priv = vma->vm_file->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nstruct drm_vma_entry *pt, *temp;\r\nstruct drm_local_map *map;\r\nstruct drm_map_list *r_list;\r\nint found_maps = 0;\r\nDRM_DEBUG("0x%08lx,0x%08lx\n",\r\nvma->vm_start, vma->vm_end - vma->vm_start);\r\natomic_dec(&dev->vma_count);\r\nmap = vma->vm_private_data;\r\nmutex_lock(&dev->struct_mutex);\r\nlist_for_each_entry_safe(pt, temp, &dev->vmalist, head) {\r\nif (pt->vma->vm_private_data == map)\r\nfound_maps++;\r\nif (pt->vma == vma) {\r\nlist_del(&pt->head);\r\nkfree(pt);\r\n}\r\n}\r\nif (found_maps == 1 && map->flags & _DRM_REMOVABLE) {\r\nfound_maps = 0;\r\nlist_for_each_entry(r_list, &dev->maplist, head) {\r\nif (r_list->map == map)\r\nfound_maps++;\r\n}\r\nif (!found_maps) {\r\ndrm_dma_handle_t dmah;\r\nswitch (map->type) {\r\ncase _DRM_REGISTERS:\r\ncase _DRM_FRAME_BUFFER:\r\nif (drm_core_has_MTRR(dev) && map->mtrr >= 0) {\r\nint retcode;\r\nretcode = mtrr_del(map->mtrr,\r\nmap->offset,\r\nmap->size);\r\nDRM_DEBUG("mtrr_del = %d\n", retcode);\r\n}\r\niounmap(map->handle);\r\nbreak;\r\ncase _DRM_SHM:\r\nvfree(map->handle);\r\nbreak;\r\ncase _DRM_AGP:\r\ncase _DRM_SCATTER_GATHER:\r\nbreak;\r\ncase _DRM_CONSISTENT:\r\ndmah.vaddr = map->handle;\r\ndmah.busaddr = map->offset;\r\ndmah.size = map->size;\r\n__drm_pci_free(dev, &dmah);\r\nbreak;\r\ncase _DRM_GEM:\r\nDRM_ERROR("tried to rmmap GEM object\n");\r\nbreak;\r\n}\r\nkfree(map);\r\n}\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nstatic int drm_do_vm_dma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_file *priv = vma->vm_file->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nstruct drm_device_dma *dma = dev->dma;\r\nunsigned long offset;\r\nunsigned long page_nr;\r\nstruct page *page;\r\nif (!dma)\r\nreturn VM_FAULT_SIGBUS;\r\nif (!dma->pagelist)\r\nreturn VM_FAULT_SIGBUS;\r\noffset = (unsigned long)vmf->virtual_address - vma->vm_start;\r\npage_nr = offset >> PAGE_SHIFT;\r\npage = virt_to_page((dma->pagelist[page_nr] + (offset & (~PAGE_MASK))));\r\nget_page(page);\r\nvmf->page = page;\r\nDRM_DEBUG("dma_fault 0x%lx (page %lu)\n", offset, page_nr);\r\nreturn 0;\r\n}\r\nstatic int drm_do_vm_sg_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_local_map *map = vma->vm_private_data;\r\nstruct drm_file *priv = vma->vm_file->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nstruct drm_sg_mem *entry = dev->sg;\r\nunsigned long offset;\r\nunsigned long map_offset;\r\nunsigned long page_offset;\r\nstruct page *page;\r\nif (!entry)\r\nreturn VM_FAULT_SIGBUS;\r\nif (!entry->pagelist)\r\nreturn VM_FAULT_SIGBUS;\r\noffset = (unsigned long)vmf->virtual_address - vma->vm_start;\r\nmap_offset = map->offset - (unsigned long)dev->sg->virtual;\r\npage_offset = (offset >> PAGE_SHIFT) + (map_offset >> PAGE_SHIFT);\r\npage = entry->pagelist[page_offset];\r\nget_page(page);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nstatic int drm_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nreturn drm_do_vm_fault(vma, vmf);\r\n}\r\nstatic int drm_vm_shm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nreturn drm_do_vm_shm_fault(vma, vmf);\r\n}\r\nstatic int drm_vm_dma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nreturn drm_do_vm_dma_fault(vma, vmf);\r\n}\r\nstatic int drm_vm_sg_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nreturn drm_do_vm_sg_fault(vma, vmf);\r\n}\r\nvoid drm_vm_open_locked(struct drm_device *dev,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct drm_vma_entry *vma_entry;\r\nDRM_DEBUG("0x%08lx,0x%08lx\n",\r\nvma->vm_start, vma->vm_end - vma->vm_start);\r\natomic_inc(&dev->vma_count);\r\nvma_entry = kmalloc(sizeof(*vma_entry), GFP_KERNEL);\r\nif (vma_entry) {\r\nvma_entry->vma = vma;\r\nvma_entry->pid = current->pid;\r\nlist_add(&vma_entry->head, &dev->vmalist);\r\n}\r\n}\r\nstatic void drm_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *priv = vma->vm_file->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_vm_open_locked(dev, vma);\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nvoid drm_vm_close_locked(struct drm_device *dev,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct drm_vma_entry *pt, *temp;\r\nDRM_DEBUG("0x%08lx,0x%08lx\n",\r\nvma->vm_start, vma->vm_end - vma->vm_start);\r\natomic_dec(&dev->vma_count);\r\nlist_for_each_entry_safe(pt, temp, &dev->vmalist, head) {\r\nif (pt->vma == vma) {\r\nlist_del(&pt->head);\r\nkfree(pt);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void drm_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *priv = vma->vm_file->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_vm_close_locked(dev, vma);\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nstatic int drm_mmap_dma(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *priv = filp->private_data;\r\nstruct drm_device *dev;\r\nstruct drm_device_dma *dma;\r\nunsigned long length = vma->vm_end - vma->vm_start;\r\ndev = priv->minor->dev;\r\ndma = dev->dma;\r\nDRM_DEBUG("start = 0x%lx, end = 0x%lx, page offset = 0x%lx\n",\r\nvma->vm_start, vma->vm_end, vma->vm_pgoff);\r\nif (!dma || (length >> PAGE_SHIFT) != dma->page_count) {\r\nreturn -EINVAL;\r\n}\r\nif (!capable(CAP_SYS_ADMIN) &&\r\n(dma->flags & _DRM_DMA_USE_PCI_RO)) {\r\nvma->vm_flags &= ~(VM_WRITE | VM_MAYWRITE);\r\n#if defined(__i386__) || defined(__x86_64__)\r\npgprot_val(vma->vm_page_prot) &= ~_PAGE_RW;\r\n#else\r\nvma->vm_page_prot =\r\n__pgprot(pte_val\r\n(pte_wrprotect\r\n(__pte(pgprot_val(vma->vm_page_prot)))));\r\n#endif\r\n}\r\nvma->vm_ops = &drm_vm_dma_ops;\r\nvma->vm_flags |= VM_RESERVED;\r\nvma->vm_flags |= VM_DONTEXPAND;\r\ndrm_vm_open_locked(dev, vma);\r\nreturn 0;\r\n}\r\nstatic resource_size_t drm_core_get_reg_ofs(struct drm_device *dev)\r\n{\r\n#ifdef __alpha__\r\nreturn dev->hose->dense_mem_base;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nint drm_mmap_locked(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *priv = filp->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nstruct drm_local_map *map = NULL;\r\nresource_size_t offset = 0;\r\nstruct drm_hash_item *hash;\r\nDRM_DEBUG("start = 0x%lx, end = 0x%lx, page offset = 0x%lx\n",\r\nvma->vm_start, vma->vm_end, vma->vm_pgoff);\r\nif (!priv->authenticated)\r\nreturn -EACCES;\r\nif (!vma->vm_pgoff\r\n#if __OS_HAS_AGP\r\n&& (!dev->agp\r\n|| dev->agp->agp_info.device->vendor != PCI_VENDOR_ID_APPLE)\r\n#endif\r\n)\r\nreturn drm_mmap_dma(filp, vma);\r\nif (drm_ht_find_item(&dev->map_hash, vma->vm_pgoff, &hash)) {\r\nDRM_ERROR("Could not find map\n");\r\nreturn -EINVAL;\r\n}\r\nmap = drm_hash_entry(hash, struct drm_map_list, hash)->map;\r\nif (!map || ((map->flags & _DRM_RESTRICTED) && !capable(CAP_SYS_ADMIN)))\r\nreturn -EPERM;\r\nif (map->size < vma->vm_end - vma->vm_start)\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN) && (map->flags & _DRM_READ_ONLY)) {\r\nvma->vm_flags &= ~(VM_WRITE | VM_MAYWRITE);\r\n#if defined(__i386__) || defined(__x86_64__)\r\npgprot_val(vma->vm_page_prot) &= ~_PAGE_RW;\r\n#else\r\nvma->vm_page_prot =\r\n__pgprot(pte_val\r\n(pte_wrprotect\r\n(__pte(pgprot_val(vma->vm_page_prot)))));\r\n#endif\r\n}\r\nswitch (map->type) {\r\n#if !defined(__arm__)\r\ncase _DRM_AGP:\r\nif (drm_core_has_AGP(dev) && dev->agp->cant_use_aperture) {\r\n#if defined(__powerpc__)\r\npgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE;\r\n#endif\r\nvma->vm_ops = &drm_vm_ops;\r\nbreak;\r\n}\r\n#endif\r\ncase _DRM_FRAME_BUFFER:\r\ncase _DRM_REGISTERS:\r\noffset = drm_core_get_reg_ofs(dev);\r\nvma->vm_flags |= VM_IO;\r\nvma->vm_page_prot = drm_io_prot(map->type, vma);\r\n#if !defined(__arm__)\r\nif (io_remap_pfn_range(vma, vma->vm_start,\r\n(map->offset + offset) >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot))\r\nreturn -EAGAIN;\r\n#else\r\nif (remap_pfn_range(vma, vma->vm_start,\r\n(map->offset + offset) >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot))\r\nreturn -EAGAIN;\r\n#endif\r\nDRM_DEBUG(" Type = %d; start = 0x%lx, end = 0x%lx,"\r\n" offset = 0x%llx\n",\r\nmap->type,\r\nvma->vm_start, vma->vm_end, (unsigned long long)(map->offset + offset));\r\nvma->vm_ops = &drm_vm_ops;\r\nbreak;\r\ncase _DRM_CONSISTENT:\r\nif (remap_pfn_range(vma, vma->vm_start,\r\npage_to_pfn(virt_to_page(map->handle)),\r\nvma->vm_end - vma->vm_start, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\nvma->vm_page_prot = drm_dma_prot(map->type, vma);\r\ncase _DRM_SHM:\r\nvma->vm_ops = &drm_vm_shm_ops;\r\nvma->vm_private_data = (void *)map;\r\nvma->vm_flags |= VM_RESERVED;\r\nbreak;\r\ncase _DRM_SCATTER_GATHER:\r\nvma->vm_ops = &drm_vm_sg_ops;\r\nvma->vm_private_data = (void *)map;\r\nvma->vm_flags |= VM_RESERVED;\r\nvma->vm_page_prot = drm_dma_prot(map->type, vma);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nvma->vm_flags |= VM_RESERVED;\r\nvma->vm_flags |= VM_DONTEXPAND;\r\ndrm_vm_open_locked(dev, vma);\r\nreturn 0;\r\n}\r\nint drm_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *priv = filp->private_data;\r\nstruct drm_device *dev = priv->minor->dev;\r\nint ret;\r\nif (drm_device_is_unplugged(dev))\r\nreturn -ENODEV;\r\nmutex_lock(&dev->struct_mutex);\r\nret = drm_mmap_locked(filp, vma);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}
