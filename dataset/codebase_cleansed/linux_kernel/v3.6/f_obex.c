static inline struct f_obex *func_to_obex(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_obex, port.func);\r\n}\r\nstatic inline struct f_obex *port_to_obex(struct gserial *p)\r\n{\r\nreturn container_of(p, struct f_obex, port);\r\n}\r\nstatic int obex_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_obex *obex = func_to_obex(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (intf == obex->ctrl_id) {\r\nif (alt != 0)\r\ngoto fail;\r\nDBG(cdev, "reset obex ttyGS%d control\n", obex->port_num);\r\n} else if (intf == obex->data_id) {\r\nif (alt > 1)\r\ngoto fail;\r\nif (obex->port.in->driver_data) {\r\nDBG(cdev, "reset obex ttyGS%d\n", obex->port_num);\r\ngserial_disconnect(&obex->port);\r\n}\r\nif (!obex->port.in->desc || !obex->port.out->desc) {\r\nDBG(cdev, "init obex ttyGS%d\n", obex->port_num);\r\nif (config_ep_by_speed(cdev->gadget, f,\r\nobex->port.in) ||\r\nconfig_ep_by_speed(cdev->gadget, f,\r\nobex->port.out)) {\r\nobex->port.out->desc = NULL;\r\nobex->port.in->desc = NULL;\r\ngoto fail;\r\n}\r\n}\r\nif (alt == 1) {\r\nDBG(cdev, "activate obex ttyGS%d\n", obex->port_num);\r\ngserial_connect(&obex->port, obex->port_num);\r\n}\r\n} else\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nstatic int obex_get_alt(struct usb_function *f, unsigned intf)\r\n{\r\nstruct f_obex *obex = func_to_obex(f);\r\nif (intf == obex->ctrl_id)\r\nreturn 0;\r\nreturn obex->port.in->driver_data ? 1 : 0;\r\n}\r\nstatic void obex_disable(struct usb_function *f)\r\n{\r\nstruct f_obex *obex = func_to_obex(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nDBG(cdev, "obex ttyGS%d disable\n", obex->port_num);\r\ngserial_disconnect(&obex->port);\r\n}\r\nstatic void obex_connect(struct gserial *g)\r\n{\r\nstruct f_obex *obex = port_to_obex(g);\r\nstruct usb_composite_dev *cdev = g->func.config->cdev;\r\nint status;\r\nif (!obex->can_activate)\r\nreturn;\r\nstatus = usb_function_activate(&g->func);\r\nif (status)\r\nDBG(cdev, "obex ttyGS%d function activate --> %d\n",\r\nobex->port_num, status);\r\n}\r\nstatic void obex_disconnect(struct gserial *g)\r\n{\r\nstruct f_obex *obex = port_to_obex(g);\r\nstruct usb_composite_dev *cdev = g->func.config->cdev;\r\nint status;\r\nif (!obex->can_activate)\r\nreturn;\r\nstatus = usb_function_deactivate(&g->func);\r\nif (status)\r\nDBG(cdev, "obex ttyGS%d function deactivate --> %d\n",\r\nobex->port_num, status);\r\n}\r\nstatic int __init\r\nobex_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_obex *obex = func_to_obex(f);\r\nint status;\r\nstruct usb_ep *ep;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nobex->ctrl_id = status;\r\nobex_control_intf.bInterfaceNumber = status;\r\nobex_cdc_union_desc.bMasterInterface0 = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nobex->data_id = status;\r\nobex_data_nop_intf.bInterfaceNumber = status;\r\nobex_data_intf.bInterfaceNumber = status;\r\nobex_cdc_union_desc.bSlaveInterface0 = status;\r\nep = usb_ep_autoconfig(cdev->gadget, &obex_fs_ep_in_desc);\r\nif (!ep)\r\ngoto fail;\r\nobex->port.in = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &obex_fs_ep_out_desc);\r\nif (!ep)\r\ngoto fail;\r\nobex->port.out = ep;\r\nep->driver_data = cdev;\r\nf->descriptors = usb_copy_descriptors(fs_function);\r\nif (gadget_is_dualspeed(c->cdev->gadget)) {\r\nobex_hs_ep_in_desc.bEndpointAddress =\r\nobex_fs_ep_in_desc.bEndpointAddress;\r\nobex_hs_ep_out_desc.bEndpointAddress =\r\nobex_fs_ep_out_desc.bEndpointAddress;\r\nf->hs_descriptors = usb_copy_descriptors(hs_function);\r\n}\r\nstatus = usb_function_deactivate(f);\r\nif (status < 0)\r\nWARNING(cdev, "obex ttyGS%d: can't prevent enumeration, %d\n",\r\nobex->port_num, status);\r\nelse\r\nobex->can_activate = true;\r\nDBG(cdev, "obex ttyGS%d: %s speed IN/%s OUT/%s\n",\r\nobex->port_num,\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\nobex->port.in->name, obex->port.out->name);\r\nreturn 0;\r\nfail:\r\nif (obex->port.out)\r\nobex->port.out->driver_data = NULL;\r\nif (obex->port.in)\r\nobex->port.in->driver_data = NULL;\r\nERROR(cdev, "%s/%p: can't bind, err %d\n", f->name, f, status);\r\nreturn status;\r\n}\r\nstatic void\r\nobex_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nif (gadget_is_dualspeed(c->cdev->gadget))\r\nusb_free_descriptors(f->hs_descriptors);\r\nusb_free_descriptors(f->descriptors);\r\nkfree(func_to_obex(f));\r\n}\r\nstatic inline bool can_support_obex(struct usb_configuration *c)\r\n{\r\nif (!gadget_supports_altsettings(c->cdev->gadget))\r\nreturn false;\r\nreturn true;\r\n}\r\nint __init obex_bind_config(struct usb_configuration *c, u8 port_num)\r\n{\r\nstruct f_obex *obex;\r\nint status;\r\nif (!can_support_obex(c))\r\nreturn -EINVAL;\r\nif (obex_string_defs[OBEX_CTRL_IDX].id == 0) {\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nobex_string_defs[OBEX_CTRL_IDX].id = status;\r\nobex_control_intf.iInterface = status;\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nobex_string_defs[OBEX_DATA_IDX].id = status;\r\nobex_data_nop_intf.iInterface =\r\nobex_data_intf.iInterface = status;\r\n}\r\nobex = kzalloc(sizeof *obex, GFP_KERNEL);\r\nif (!obex)\r\nreturn -ENOMEM;\r\nobex->port_num = port_num;\r\nobex->port.connect = obex_connect;\r\nobex->port.disconnect = obex_disconnect;\r\nobex->port.func.name = "obex";\r\nobex->port.func.strings = obex_strings;\r\nobex->port.func.bind = obex_bind;\r\nobex->port.func.unbind = obex_unbind;\r\nobex->port.func.set_alt = obex_set_alt;\r\nobex->port.func.get_alt = obex_get_alt;\r\nobex->port.func.disable = obex_disable;\r\nstatus = usb_add_function(c, &obex->port.func);\r\nif (status)\r\nkfree(obex);\r\nreturn status;\r\n}
