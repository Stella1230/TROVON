static inline unsigned int elapsed_jiffies_msecs(unsigned long start)\r\n{\r\nunsigned long end = jiffies;\r\nif (end >= start)\r\nreturn jiffies_to_msecs(end - start);\r\nreturn jiffies_to_msecs(end + (MAX_JIFFY_OFFSET - start) + 1);\r\n}\r\nstatic char *libipw_translate_scan(struct libipw_device *ieee,\r\nchar *start, char *stop,\r\nstruct libipw_network *network,\r\nstruct iw_request_info *info)\r\n{\r\nchar custom[MAX_CUSTOM_LEN];\r\nchar *p;\r\nstruct iw_event iwe;\r\nint i, j;\r\nchar *current_val;\r\nu8 rate;\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, network->bssid, ETH_ALEN);\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\niwe.u.data.length = min(network->ssid_len, (u8) 32);\r\nstart = iwe_stream_add_point(info, start, stop,\r\n&iwe, network->ssid);\r\niwe.cmd = SIOCGIWNAME;\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11%s",\r\nlibipw_modes[network->mode]);\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);\r\niwe.cmd = SIOCGIWMODE;\r\nif (network->capability & (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {\r\nif (network->capability & WLAN_CAPABILITY_ESS)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_ADHOC;\r\nstart = iwe_stream_add_event(info, start, stop,\r\n&iwe, IW_EV_UINT_LEN);\r\n}\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = libipw_channel_to_freq(ieee, network->channel);\r\niwe.u.freq.e = 6;\r\niwe.u.freq.i = 0;\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);\r\niwe.cmd = SIOCGIWENCODE;\r\nif (network->capability & WLAN_CAPABILITY_PRIVACY)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\nstart = iwe_stream_add_point(info, start, stop,\r\n&iwe, network->ssid);\r\ncurrent_val = start + iwe_stream_lcp_len(info);\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\r\nfor (i = 0, j = 0; i < network->rates_len;) {\r\nif (j < network->rates_ex_len &&\r\n((network->rates_ex[j] & 0x7F) <\r\n(network->rates[i] & 0x7F)))\r\nrate = network->rates_ex[j++] & 0x7F;\r\nelse\r\nrate = network->rates[i++] & 0x7F;\r\niwe.u.bitrate.value = ((rate & 0x7f) * 500000);\r\ncurrent_val = iwe_stream_add_value(info, start, current_val,\r\nstop, &iwe, IW_EV_PARAM_LEN);\r\n}\r\nfor (; j < network->rates_ex_len; j++) {\r\nrate = network->rates_ex[j] & 0x7F;\r\niwe.u.bitrate.value = ((rate & 0x7f) * 500000);\r\ncurrent_val = iwe_stream_add_value(info, start, current_val,\r\nstop, &iwe, IW_EV_PARAM_LEN);\r\n}\r\nif ((current_val - start) > iwe_stream_lcp_len(info))\r\nstart = current_val;\r\niwe.cmd = IWEVQUAL;\r\niwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED |\r\nIW_QUAL_NOISE_UPDATED;\r\nif (!(network->stats.mask & LIBIPW_STATMASK_RSSI)) {\r\niwe.u.qual.updated |= IW_QUAL_QUAL_INVALID |\r\nIW_QUAL_LEVEL_INVALID;\r\niwe.u.qual.qual = 0;\r\n} else {\r\nif (ieee->perfect_rssi == ieee->worst_rssi)\r\niwe.u.qual.qual = 100;\r\nelse\r\niwe.u.qual.qual =\r\n(100 *\r\n(ieee->perfect_rssi - ieee->worst_rssi) *\r\n(ieee->perfect_rssi - ieee->worst_rssi) -\r\n(ieee->perfect_rssi - network->stats.rssi) *\r\n(15 * (ieee->perfect_rssi - ieee->worst_rssi) +\r\n62 * (ieee->perfect_rssi -\r\nnetwork->stats.rssi))) /\r\n((ieee->perfect_rssi -\r\nieee->worst_rssi) * (ieee->perfect_rssi -\r\nieee->worst_rssi));\r\nif (iwe.u.qual.qual > 100)\r\niwe.u.qual.qual = 100;\r\nelse if (iwe.u.qual.qual < 1)\r\niwe.u.qual.qual = 0;\r\n}\r\nif (!(network->stats.mask & LIBIPW_STATMASK_NOISE)) {\r\niwe.u.qual.updated |= IW_QUAL_NOISE_INVALID;\r\niwe.u.qual.noise = 0;\r\n} else {\r\niwe.u.qual.noise = network->stats.noise;\r\n}\r\nif (!(network->stats.mask & LIBIPW_STATMASK_SIGNAL)) {\r\niwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;\r\niwe.u.qual.level = 0;\r\n} else {\r\niwe.u.qual.level = network->stats.signal;\r\n}\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);\r\niwe.cmd = IWEVCUSTOM;\r\np = custom;\r\niwe.u.data.length = p - custom;\r\nif (iwe.u.data.length)\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\r\nmemset(&iwe, 0, sizeof(iwe));\r\nif (network->wpa_ie_len) {\r\nchar buf[MAX_WPA_IE_LEN];\r\nmemcpy(buf, network->wpa_ie, network->wpa_ie_len);\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = network->wpa_ie_len;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\nif (network->rsn_ie_len) {\r\nchar buf[MAX_WPA_IE_LEN];\r\nmemcpy(buf, network->rsn_ie, network->rsn_ie_len);\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = network->rsn_ie_len;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\r\n}\r\niwe.cmd = IWEVCUSTOM;\r\np = custom;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom),\r\n" Last beacon: %ums ago",\r\nelapsed_jiffies_msecs(network->last_scanned));\r\niwe.u.data.length = p - custom;\r\nif (iwe.u.data.length)\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\r\niwe.cmd = -1;\r\np = custom;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Channel flags: ");\r\nif (libipw_get_channel_flags(ieee, network->channel) &\r\nLIBIPW_CH_INVALID) {\r\niwe.cmd = IWEVCUSTOM;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom), "INVALID ");\r\n}\r\nif (libipw_get_channel_flags(ieee, network->channel) &\r\nLIBIPW_CH_RADAR_DETECT) {\r\niwe.cmd = IWEVCUSTOM;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom), "DFS ");\r\n}\r\nif (iwe.cmd == IWEVCUSTOM) {\r\niwe.u.data.length = p - custom;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\r\n}\r\nreturn start;\r\n}\r\nint libipw_wx_get_scan(struct libipw_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct libipw_network *network;\r\nunsigned long flags;\r\nint err = 0;\r\nchar *ev = extra;\r\nchar *stop = ev + wrqu->data.length;\r\nint i = 0;\r\nDECLARE_SSID_BUF(ssid);\r\nLIBIPW_DEBUG_WX("Getting scan\n");\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nlist_for_each_entry(network, &ieee->network_list, list) {\r\ni++;\r\nif (stop - ev < SCAN_ITEM_SIZE) {\r\nerr = -E2BIG;\r\nbreak;\r\n}\r\nif (ieee->scan_age == 0 ||\r\ntime_after(network->last_scanned + ieee->scan_age, jiffies))\r\nev = libipw_translate_scan(ieee, ev, stop, network,\r\ninfo);\r\nelse {\r\nLIBIPW_DEBUG_SCAN("Not showing network '%s ("\r\n"%pM)' due to age (%ums).\n",\r\nprint_ssid(ssid, network->ssid,\r\nnetwork->ssid_len),\r\nnetwork->bssid,\r\nelapsed_jiffies_msecs(\r\nnetwork->last_scanned));\r\n}\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nwrqu->data.length = ev - extra;\r\nwrqu->data.flags = 0;\r\nLIBIPW_DEBUG_WX("exit: %d networks returned.\n", i);\r\nreturn err;\r\n}\r\nint libipw_wx_set_encode(struct libipw_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nstruct net_device *dev = ieee->dev;\r\nstruct libipw_security sec = {\r\n.flags = 0\r\n};\r\nint i, key, key_provided, len;\r\nstruct lib80211_crypt_data **crypt;\r\nint host_crypto = ieee->host_encrypt || ieee->host_decrypt;\r\nDECLARE_SSID_BUF(ssid);\r\nLIBIPW_DEBUG_WX("SET_ENCODE\n");\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (key) {\r\nif (key > WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\nkey_provided = 1;\r\n} else {\r\nkey_provided = 0;\r\nkey = ieee->crypt_info.tx_keyidx;\r\n}\r\nLIBIPW_DEBUG_WX("Key: %d [%s]\n", key, key_provided ?\r\n"provided" : "default");\r\ncrypt = &ieee->crypt_info.crypt[key];\r\nif (erq->flags & IW_ENCODE_DISABLED) {\r\nif (key_provided && *crypt) {\r\nLIBIPW_DEBUG_WX("Disabling encryption on key %d.\n",\r\nkey);\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\n} else\r\nLIBIPW_DEBUG_WX("Disabling encryption.\n");\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nif (ieee->crypt_info.crypt[i] != NULL) {\r\nif (key_provided)\r\nbreak;\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info,\r\n&ieee->crypt_info.crypt[i]);\r\n}\r\n}\r\nif (i == WEP_KEYS) {\r\nsec.enabled = 0;\r\nsec.encrypt = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_ENABLED | SEC_LEVEL | SEC_ENCRYPT;\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nsec.encrypt = 1;\r\nsec.flags |= SEC_ENABLED | SEC_ENCRYPT;\r\nif (*crypt != NULL && (*crypt)->ops != NULL &&\r\nstrcmp((*crypt)->ops->name, "WEP") != 0) {\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\n}\r\nif (*crypt == NULL && host_crypto) {\r\nstruct lib80211_crypt_data *new_crypt;\r\nnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\r\nGFP_KERNEL);\r\nif (new_crypt == NULL)\r\nreturn -ENOMEM;\r\nnew_crypt->ops = lib80211_get_crypto_ops("WEP");\r\nif (!new_crypt->ops) {\r\nrequest_module("lib80211_crypt_wep");\r\nnew_crypt->ops = lib80211_get_crypto_ops("WEP");\r\n}\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv = new_crypt->ops->init(key);\r\nif (!new_crypt->ops || !new_crypt->priv) {\r\nkfree(new_crypt);\r\nnew_crypt = NULL;\r\nprintk(KERN_WARNING "%s: could not initialize WEP: "\r\n"load module lib80211_crypt_wep\n", dev->name);\r\nreturn -EOPNOTSUPP;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (erq->length > 0) {\r\nlen = erq->length <= 5 ? 5 : 13;\r\nmemcpy(sec.keys[key], keybuf, erq->length);\r\nif (len > erq->length)\r\nmemset(sec.keys[key] + erq->length, 0,\r\nlen - erq->length);\r\nLIBIPW_DEBUG_WX("Setting key %d to '%s' (%d:%d bytes)\n",\r\nkey, print_ssid(ssid, sec.keys[key], len),\r\nerq->length, len);\r\nsec.key_sizes[key] = len;\r\nif (*crypt)\r\n(*crypt)->ops->set_key(sec.keys[key], len, NULL,\r\n(*crypt)->priv);\r\nsec.flags |= (1 << key);\r\nif (key == sec.active_key)\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n} else {\r\nif (host_crypto) {\r\nlen = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,\r\nNULL, (*crypt)->priv);\r\nif (len == 0) {\r\nLIBIPW_DEBUG_WX("Setting key %d to all "\r\n"zero.\n", key);\r\nmemset(sec.keys[key], 0, 13);\r\n(*crypt)->ops->set_key(sec.keys[key], 13, NULL,\r\n(*crypt)->priv);\r\nsec.key_sizes[key] = 13;\r\nsec.flags |= (1 << key);\r\n}\r\n}\r\nif (key_provided) {\r\nLIBIPW_DEBUG_WX("Setting key %d to default Tx "\r\n"key.\n", key);\r\nieee->crypt_info.tx_keyidx = key;\r\nsec.active_key = key;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n}\r\n}\r\nif (erq->flags & (IW_ENCODE_OPEN | IW_ENCODE_RESTRICTED)) {\r\nieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);\r\nsec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN :\r\nWLAN_AUTH_SHARED_KEY;\r\nsec.flags |= SEC_AUTH_MODE;\r\nLIBIPW_DEBUG_WX("Auth: %s\n",\r\nsec.auth_mode == WLAN_AUTH_OPEN ?\r\n"OPEN" : "SHARED KEY");\r\n}\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\nsec.encode_alg[key] = SEC_ALG_WEP;\r\ndone:\r\nif (ieee->set_security)\r\nieee->set_security(dev, &sec);\r\nreturn 0;\r\n}\r\nint libipw_wx_get_encode(struct libipw_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nint len, key;\r\nstruct lib80211_crypt_data *crypt;\r\nstruct libipw_security *sec = &ieee->sec;\r\nLIBIPW_DEBUG_WX("GET_ENCODE\n");\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (key) {\r\nif (key > WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\n} else\r\nkey = ieee->crypt_info.tx_keyidx;\r\ncrypt = ieee->crypt_info.crypt[key];\r\nerq->flags = key + 1;\r\nif (!sec->enabled) {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nreturn 0;\r\n}\r\nlen = sec->key_sizes[key];\r\nmemcpy(keybuf, sec->keys[key], len);\r\nerq->length = len;\r\nerq->flags |= IW_ENCODE_ENABLED;\r\nif (ieee->open_wep)\r\nerq->flags |= IW_ENCODE_OPEN;\r\nelse\r\nerq->flags |= IW_ENCODE_RESTRICTED;\r\nreturn 0;\r\n}\r\nint libipw_wx_set_encodeext(struct libipw_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct net_device *dev = ieee->dev;\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint i, idx, ret = 0;\r\nint group_key = 0;\r\nconst char *alg, *module;\r\nstruct lib80211_crypto_ops *ops;\r\nstruct lib80211_crypt_data **crypt;\r\nstruct libipw_security sec = {\r\n.flags = 0,\r\n};\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (idx < 1 || idx > WEP_KEYS)\r\nreturn -EINVAL;\r\nidx--;\r\n} else\r\nidx = ieee->crypt_info.tx_keyidx;\r\nif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {\r\ncrypt = &ieee->crypt_info.crypt[idx];\r\ngroup_key = 1;\r\n} else {\r\nif (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)\r\nreturn -EINVAL;\r\nif (ieee->iw_mode == IW_MODE_INFRA)\r\ncrypt = &ieee->crypt_info.crypt[idx];\r\nelse\r\nreturn -EINVAL;\r\n}\r\nsec.flags |= SEC_ENABLED | SEC_ENCRYPT;\r\nif ((encoding->flags & IW_ENCODE_DISABLED) ||\r\next->alg == IW_ENCODE_ALG_NONE) {\r\nif (*crypt)\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\nfor (i = 0; i < WEP_KEYS; i++)\r\nif (ieee->crypt_info.crypt[i] != NULL)\r\nbreak;\r\nif (i == WEP_KEYS) {\r\nsec.enabled = 0;\r\nsec.encrypt = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_LEVEL;\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nsec.encrypt = 1;\r\nif (group_key ? !ieee->host_mc_decrypt :\r\n!(ieee->host_encrypt || ieee->host_decrypt ||\r\nieee->host_encrypt_msdu))\r\ngoto skip_host_crypt;\r\nswitch (ext->alg) {\r\ncase IW_ENCODE_ALG_WEP:\r\nalg = "WEP";\r\nmodule = "lib80211_crypt_wep";\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\nalg = "TKIP";\r\nmodule = "lib80211_crypt_tkip";\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\nalg = "CCMP";\r\nmodule = "lib80211_crypt_ccmp";\r\nbreak;\r\ndefault:\r\nLIBIPW_DEBUG_WX("%s: unknown crypto alg %d\n",\r\ndev->name, ext->alg);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nops = lib80211_get_crypto_ops(alg);\r\nif (ops == NULL) {\r\nrequest_module(module);\r\nops = lib80211_get_crypto_ops(alg);\r\n}\r\nif (ops == NULL) {\r\nLIBIPW_DEBUG_WX("%s: unknown crypto alg %d\n",\r\ndev->name, ext->alg);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (*crypt == NULL || (*crypt)->ops != ops) {\r\nstruct lib80211_crypt_data *new_crypt;\r\nlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\r\nnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\r\nif (new_crypt == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nnew_crypt->ops = ops;\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv = new_crypt->ops->init(idx);\r\nif (new_crypt->priv == NULL) {\r\nkfree(new_crypt);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (ext->key_len > 0 && (*crypt)->ops->set_key &&\r\n(*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,\r\n(*crypt)->priv) < 0) {\r\nLIBIPW_DEBUG_WX("%s: key setting failed\n", dev->name);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nskip_host_crypt:\r\nif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\r\nieee->crypt_info.tx_keyidx = idx;\r\nsec.active_key = idx;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n}\r\nif (ext->alg != IW_ENCODE_ALG_NONE) {\r\nmemcpy(sec.keys[idx], ext->key, ext->key_len);\r\nsec.key_sizes[idx] = ext->key_len;\r\nsec.flags |= (1 << idx);\r\nif (ext->alg == IW_ENCODE_ALG_WEP) {\r\nsec.encode_alg[idx] = SEC_ALG_WEP;\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n} else if (ext->alg == IW_ENCODE_ALG_TKIP) {\r\nsec.encode_alg[idx] = SEC_ALG_TKIP;\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_2;\r\n} else if (ext->alg == IW_ENCODE_ALG_CCMP) {\r\nsec.encode_alg[idx] = SEC_ALG_CCMP;\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_3;\r\n}\r\nif (group_key)\r\nsec.flags &= ~SEC_LEVEL;\r\n}\r\ndone:\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nreturn ret;\r\n}\r\nint libipw_wx_get_encodeext(struct libipw_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nstruct libipw_security *sec = &ieee->sec;\r\nint idx, max_key_len;\r\nmax_key_len = encoding->length - sizeof(*ext);\r\nif (max_key_len < 0)\r\nreturn -EINVAL;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (idx < 1 || idx > WEP_KEYS)\r\nreturn -EINVAL;\r\nidx--;\r\n} else\r\nidx = ieee->crypt_info.tx_keyidx;\r\nif (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) &&\r\next->alg != IW_ENCODE_ALG_WEP)\r\nif (idx != 0 || ieee->iw_mode != IW_MODE_INFRA)\r\nreturn -EINVAL;\r\nencoding->flags = idx + 1;\r\nmemset(ext, 0, sizeof(*ext));\r\nif (!sec->enabled) {\r\next->alg = IW_ENCODE_ALG_NONE;\r\next->key_len = 0;\r\nencoding->flags |= IW_ENCODE_DISABLED;\r\n} else {\r\nif (sec->encode_alg[idx] == SEC_ALG_WEP)\r\next->alg = IW_ENCODE_ALG_WEP;\r\nelse if (sec->encode_alg[idx] == SEC_ALG_TKIP)\r\next->alg = IW_ENCODE_ALG_TKIP;\r\nelse if (sec->encode_alg[idx] == SEC_ALG_CCMP)\r\next->alg = IW_ENCODE_ALG_CCMP;\r\nelse\r\nreturn -EINVAL;\r\next->key_len = sec->key_sizes[idx];\r\nmemcpy(ext->key, sec->keys[idx], ext->key_len);\r\nencoding->flags |= IW_ENCODE_ENABLED;\r\nif (ext->key_len &&\r\n(ext->alg == IW_ENCODE_ALG_TKIP ||\r\next->alg == IW_ENCODE_ALG_CCMP))\r\next->ext_flags |= IW_ENCODE_EXT_TX_SEQ_VALID;\r\n}\r\nreturn 0;\r\n}
