static int timblogiw_bytes_per_line(const struct timblogiw_tvnorm *norm)\r\n{\r\nreturn norm->width * 2;\r\n}\r\nstatic int timblogiw_frame_size(const struct timblogiw_tvnorm *norm)\r\n{\r\nreturn norm->height * timblogiw_bytes_per_line(norm);\r\n}\r\nstatic const struct timblogiw_tvnorm *timblogiw_get_norm(const v4l2_std_id std)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(timblogiw_tvnorms); i++)\r\nif (timblogiw_tvnorms[i].std & std)\r\nreturn timblogiw_tvnorms + i;\r\nreturn timblogiw_tvnorms;\r\n}\r\nstatic void timblogiw_dma_cb(void *data)\r\n{\r\nstruct timblogiw_buffer *buf = data;\r\nstruct timblogiw_fh *fh = buf->fh;\r\nstruct videobuf_buffer *vb = &buf->vb;\r\nspin_lock(&fh->queue_lock);\r\nbuf->cookie = -1;\r\nfh->frame_count++;\r\nif (vb->state != VIDEOBUF_ERROR) {\r\nlist_del(&vb->queue);\r\ndo_gettimeofday(&vb->ts);\r\nvb->field_count = fh->frame_count * 2;\r\nvb->state = VIDEOBUF_DONE;\r\nwake_up(&vb->done);\r\n}\r\nif (!list_empty(&fh->capture)) {\r\nvb = list_entry(fh->capture.next, struct videobuf_buffer,\r\nqueue);\r\nvb->state = VIDEOBUF_ACTIVE;\r\n}\r\nspin_unlock(&fh->queue_lock);\r\n}\r\nstatic bool timblogiw_dma_filter_fn(struct dma_chan *chan, void *filter_param)\r\n{\r\nreturn chan->chan_id == (uintptr_t)filter_param;\r\n}\r\nstatic int timblogiw_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *format)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw *lw = video_get_drvdata(vdev);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s entry\n", __func__);\r\nif (format->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmutex_lock(&lw->lock);\r\nformat->fmt.pix.width = fh->cur_norm->width;\r\nformat->fmt.pix.height = fh->cur_norm->height;\r\nformat->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\r\nformat->fmt.pix.bytesperline = timblogiw_bytes_per_line(fh->cur_norm);\r\nformat->fmt.pix.sizeimage = timblogiw_frame_size(fh->cur_norm);\r\nformat->fmt.pix.field = V4L2_FIELD_NONE;\r\nmutex_unlock(&lw->lock);\r\nreturn 0;\r\n}\r\nstatic int timblogiw_try_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *format)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct v4l2_pix_format *pix = &format->fmt.pix;\r\ndev_dbg(&vdev->dev,\r\n"%s - width=%d, height=%d, pixelformat=%d, field=%d\n"\r\n"bytes per line %d, size image: %d, colorspace: %d\n",\r\n__func__,\r\npix->width, pix->height, pix->pixelformat, pix->field,\r\npix->bytesperline, pix->sizeimage, pix->colorspace);\r\nif (format->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (pix->field != V4L2_FIELD_NONE)\r\nreturn -EINVAL;\r\nif (pix->pixelformat != V4L2_PIX_FMT_UYVY)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int timblogiw_s_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *format)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw *lw = video_get_drvdata(vdev);\r\nstruct timblogiw_fh *fh = priv;\r\nstruct v4l2_pix_format *pix = &format->fmt.pix;\r\nint err;\r\nmutex_lock(&lw->lock);\r\nerr = timblogiw_try_fmt(file, priv, format);\r\nif (err)\r\ngoto out;\r\nif (videobuf_queue_is_busy(&fh->vb_vidq)) {\r\ndev_err(&vdev->dev, "%s queue busy\n", __func__);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\npix->width = fh->cur_norm->width;\r\npix->height = fh->cur_norm->height;\r\nout:\r\nmutex_unlock(&lw->lock);\r\nreturn err;\r\n}\r\nstatic int timblogiw_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\ndev_dbg(&vdev->dev, "%s: Entry\n", __func__);\r\nmemset(cap, 0, sizeof(*cap));\r\nstrncpy(cap->card, TIMBLOGIWIN_NAME, sizeof(cap->card)-1);\r\nstrncpy(cap->driver, DRIVER_NAME, sizeof(cap->driver) - 1);\r\nstrlcpy(cap->bus_info, vdev->name, sizeof(cap->bus_info));\r\ncap->version = TIMBLOGIW_VERSION_CODE;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\nreturn 0;\r\n}\r\nstatic int timblogiw_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\ndev_dbg(&vdev->dev, "%s, index: %d\n", __func__, fmt->index);\r\nif (fmt->index != 0)\r\nreturn -EINVAL;\r\nmemset(fmt, 0, sizeof(*fmt));\r\nfmt->index = 0;\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstrncpy(fmt->description, "4:2:2, packed, YUYV",\r\nsizeof(fmt->description)-1);\r\nfmt->pixelformat = V4L2_PIX_FMT_UYVY;\r\nreturn 0;\r\n}\r\nstatic int timblogiw_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct timblogiw_fh *fh = priv;\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = 1;\r\ncp->timeperframe.denominator = fh->cur_norm->fps;\r\nreturn 0;\r\n}\r\nstatic int timblogiw_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nreturn videobuf_reqbufs(&fh->vb_vidq, rb);\r\n}\r\nstatic int timblogiw_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nreturn videobuf_querybuf(&fh->vb_vidq, b);\r\n}\r\nstatic int timblogiw_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nreturn videobuf_qbuf(&fh->vb_vidq, b);\r\n}\r\nstatic int timblogiw_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nreturn videobuf_dqbuf(&fh->vb_vidq, b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int timblogiw_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\n*std = fh->cur_norm->std;\r\nreturn 0;\r\n}\r\nstatic int timblogiw_s_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw *lw = video_get_drvdata(vdev);\r\nstruct timblogiw_fh *fh = priv;\r\nint err = 0;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nmutex_lock(&lw->lock);\r\nif (TIMBLOGIW_HAS_DECODER(lw))\r\nerr = v4l2_subdev_call(lw->sd_enc, core, s_std, *std);\r\nif (!err)\r\nfh->cur_norm = timblogiw_get_norm(*std);\r\nmutex_unlock(&lw->lock);\r\nreturn err;\r\n}\r\nstatic int timblogiw_enuminput(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nint i;\r\ndev_dbg(&vdev->dev, "%s: Entry\n", __func__);\r\nif (inp->index != 0)\r\nreturn -EINVAL;\r\ninp->index = 0;\r\nstrncpy(inp->name, "Timb input 1", sizeof(inp->name) - 1);\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = 0;\r\nfor (i = 0; i < ARRAY_SIZE(timblogiw_tvnorms); i++)\r\ninp->std |= timblogiw_tvnorms[i].std;\r\nreturn 0;\r\n}\r\nstatic int timblogiw_g_input(struct file *file, void *priv,\r\nunsigned int *input)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\ndev_dbg(&vdev->dev, "%s: Entry\n", __func__);\r\n*input = 0;\r\nreturn 0;\r\n}\r\nstatic int timblogiw_s_input(struct file *file, void *priv, unsigned int input)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\ndev_dbg(&vdev->dev, "%s: Entry\n", __func__);\r\nif (input != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int timblogiw_streamon(struct file *file, void *priv, unsigned int type)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ndev_dbg(&vdev->dev, "%s - No capture device\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nfh->frame_count = 0;\r\nreturn videobuf_streamon(&fh->vb_vidq);\r\n}\r\nstatic int timblogiw_streamoff(struct file *file, void *priv,\r\nunsigned int type)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s entry\n", __func__);\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn videobuf_streamoff(&fh->vb_vidq);\r\n}\r\nstatic int timblogiw_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw *lw = video_get_drvdata(vdev);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s entry\n", __func__);\r\nif (TIMBLOGIW_HAS_DECODER(lw))\r\nreturn v4l2_subdev_call(lw->sd_enc, video, querystd, std);\r\nelse {\r\n*std = fh->cur_norm->std;\r\nreturn 0;\r\n}\r\n}\r\nstatic int timblogiw_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = priv;\r\ndev_dbg(&vdev->dev, "%s - index: %d, format: %d\n", __func__,\r\nfsize->index, fsize->pixel_format);\r\nif ((fsize->index != 0) ||\r\n(fsize->pixel_format != V4L2_PIX_FMT_UYVY))\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = fh->cur_norm->width;\r\nfsize->discrete.height = fh->cur_norm->height;\r\nreturn 0;\r\n}\r\nstatic int buffer_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct timblogiw_fh *fh = vq->priv_data;\r\n*size = timblogiw_frame_size(fh->cur_norm);\r\nif (!*count)\r\n*count = 32;\r\nwhile (*size * *count > TIMBLOGIW_MAX_VIDEO_MEM * 1024 * 1024)\r\n(*count)--;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct timblogiw_fh *fh = vq->priv_data;\r\nstruct timblogiw_buffer *buf = container_of(vb, struct timblogiw_buffer,\r\nvb);\r\nunsigned int data_size = timblogiw_frame_size(fh->cur_norm);\r\nint err = 0;\r\nif (vb->baddr && vb->bsize < data_size)\r\nreturn -ENOMEM;\r\nvb->size = data_size;\r\nvb->width = fh->cur_norm->width;\r\nvb->height = fh->cur_norm->height;\r\nvb->field = field;\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nint i;\r\nunsigned int size;\r\nunsigned int bytes_per_desc = TIMBLOGIW_LINES_PER_DESC *\r\ntimblogiw_bytes_per_line(fh->cur_norm);\r\ndma_addr_t addr;\r\nsg_init_table(buf->sg, ARRAY_SIZE(buf->sg));\r\nerr = videobuf_iolock(vq, vb, NULL);\r\nif (err)\r\ngoto err;\r\naddr = videobuf_to_dma_contig(vb);\r\nfor (i = 0, size = 0; size < data_size; i++) {\r\nsg_dma_address(buf->sg + i) = addr + size;\r\nsize += bytes_per_desc;\r\nsg_dma_len(buf->sg + i) = (size > data_size) ?\r\n(bytes_per_desc - (size - data_size)) :\r\nbytes_per_desc;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\nbuf->cookie = -1;\r\nbuf->fh = fh;\r\n}\r\nreturn 0;\r\nerr:\r\nvideobuf_dma_contig_free(vq, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\nreturn err;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct timblogiw_fh *fh = vq->priv_data;\r\nstruct timblogiw_buffer *buf = container_of(vb, struct timblogiw_buffer,\r\nvb);\r\nstruct dma_async_tx_descriptor *desc;\r\nint sg_elems;\r\nint bytes_per_desc = TIMBLOGIW_LINES_PER_DESC *\r\ntimblogiw_bytes_per_line(fh->cur_norm);\r\nsg_elems = timblogiw_frame_size(fh->cur_norm) / bytes_per_desc;\r\nsg_elems +=\r\n(timblogiw_frame_size(fh->cur_norm) % bytes_per_desc) ? 1 : 0;\r\nif (list_empty(&fh->capture))\r\nvb->state = VIDEOBUF_ACTIVE;\r\nelse\r\nvb->state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&vb->queue, &fh->capture);\r\nspin_unlock_irq(&fh->queue_lock);\r\ndesc = dmaengine_prep_slave_sg(fh->chan,\r\nbuf->sg, sg_elems, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_COMPL_SKIP_SRC_UNMAP);\r\nif (!desc) {\r\nspin_lock_irq(&fh->queue_lock);\r\nlist_del_init(&vb->queue);\r\nvb->state = VIDEOBUF_PREPARED;\r\nreturn;\r\n}\r\ndesc->callback_param = buf;\r\ndesc->callback = timblogiw_dma_cb;\r\nbuf->cookie = desc->tx_submit(desc);\r\nspin_lock_irq(&fh->queue_lock);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct timblogiw_fh *fh = vq->priv_data;\r\nstruct timblogiw_buffer *buf = container_of(vb, struct timblogiw_buffer,\r\nvb);\r\nvideobuf_waiton(vq, vb, 0, 0);\r\nif (buf->cookie >= 0)\r\ndma_sync_wait(fh->chan, buf->cookie);\r\nvideobuf_dma_contig_free(vq, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int timblogiw_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw *lw = video_get_drvdata(vdev);\r\nstruct timblogiw_fh *fh;\r\nv4l2_std_id std;\r\ndma_cap_mask_t mask;\r\nint err = 0;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nmutex_lock(&lw->lock);\r\nif (lw->opened) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (TIMBLOGIW_HAS_DECODER(lw) && !lw->sd_enc) {\r\nstruct i2c_adapter *adapt;\r\nadapt = i2c_get_adapter(lw->pdata.i2c_adapter);\r\nif (!adapt) {\r\ndev_err(&vdev->dev, "No I2C bus #%d\n",\r\nlw->pdata.i2c_adapter);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nlw->sd_enc = v4l2_i2c_new_subdev_board(&lw->v4l2_dev, adapt,\r\nlw->pdata.encoder.info, NULL);\r\ni2c_put_adapter(adapt);\r\nif (!lw->sd_enc) {\r\ndev_err(&vdev->dev, "Failed to get encoder: %s\n",\r\nlw->pdata.encoder.module_name);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (!fh) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nfh->cur_norm = timblogiw_tvnorms;\r\ntimblogiw_querystd(file, fh, &std);\r\nfh->cur_norm = timblogiw_get_norm(std);\r\nINIT_LIST_HEAD(&fh->capture);\r\nspin_lock_init(&fh->queue_lock);\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_PRIVATE, mask);\r\nfh->chan = dma_request_channel(mask, timblogiw_dma_filter_fn,\r\n(void *)(uintptr_t)lw->pdata.dma_channel);\r\nif (!fh->chan) {\r\ndev_err(&vdev->dev, "Failed to get DMA channel\n");\r\nkfree(fh);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nfile->private_data = fh;\r\nvideobuf_queue_dma_contig_init(&fh->vb_vidq,\r\n&timblogiw_video_qops, lw->dev, &fh->queue_lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_NONE,\r\nsizeof(struct timblogiw_buffer), fh, NULL);\r\nlw->opened = true;\r\nout:\r\nmutex_unlock(&lw->lock);\r\nreturn err;\r\n}\r\nstatic int timblogiw_close(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw *lw = video_get_drvdata(vdev);\r\nstruct timblogiw_fh *fh = file->private_data;\r\ndev_dbg(&vdev->dev, "%s: Entry\n", __func__);\r\nvideobuf_stop(&fh->vb_vidq);\r\nvideobuf_mmap_free(&fh->vb_vidq);\r\ndma_release_channel(fh->chan);\r\nkfree(fh);\r\nmutex_lock(&lw->lock);\r\nlw->opened = false;\r\nmutex_unlock(&lw->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t timblogiw_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = file->private_data;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nreturn videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic unsigned int timblogiw_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = file->private_data;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nreturn videobuf_poll_stream(file, &fh->vb_vidq, wait);\r\n}\r\nstatic int timblogiw_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct timblogiw_fh *fh = file->private_data;\r\ndev_dbg(&vdev->dev, "%s: entry\n", __func__);\r\nreturn videobuf_mmap_mapper(&fh->vb_vidq, vma);\r\n}\r\nstatic int __devinit timblogiw_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct timblogiw *lw = NULL;\r\nstruct timb_video_platform_data *pdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data\n");\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nif (!pdata->encoder.module_name)\r\ndev_info(&pdev->dev, "Running without decoder\n");\r\nlw = kzalloc(sizeof(*lw), GFP_KERNEL);\r\nif (!lw) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nif (pdev->dev.parent)\r\nlw->dev = pdev->dev.parent;\r\nelse\r\nlw->dev = &pdev->dev;\r\nmemcpy(&lw->pdata, pdata, sizeof(lw->pdata));\r\nmutex_init(&lw->lock);\r\nlw->video_dev = timblogiw_template;\r\nstrlcpy(lw->v4l2_dev.name, DRIVER_NAME, sizeof(lw->v4l2_dev.name));\r\nerr = v4l2_device_register(NULL, &lw->v4l2_dev);\r\nif (err)\r\ngoto err_register;\r\nlw->video_dev.v4l2_dev = &lw->v4l2_dev;\r\nplatform_set_drvdata(pdev, lw);\r\nvideo_set_drvdata(&lw->video_dev, lw);\r\nerr = video_register_device(&lw->video_dev, VFL_TYPE_GRABBER, 0);\r\nif (err) {\r\ndev_err(&pdev->dev, "Error reg video: %d\n", err);\r\ngoto err_request;\r\n}\r\nreturn 0;\r\nerr_request:\r\nplatform_set_drvdata(pdev, NULL);\r\nv4l2_device_unregister(&lw->v4l2_dev);\r\nerr_register:\r\nkfree(lw);\r\nerr:\r\ndev_err(&pdev->dev, "Failed to register: %d\n", err);\r\nreturn err;\r\n}\r\nstatic int __devexit timblogiw_remove(struct platform_device *pdev)\r\n{\r\nstruct timblogiw *lw = platform_get_drvdata(pdev);\r\nvideo_unregister_device(&lw->video_dev);\r\nv4l2_device_unregister(&lw->v4l2_dev);\r\nkfree(lw);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
