static u8 mxc_w1_ds2_reset_bus(void *data)\r\n{\r\nu8 reg_val;\r\nunsigned int timeout_cnt = 0;\r\nstruct mxc_w1_device *dev = data;\r\n__raw_writeb(0x80, (dev->regs + MXC_W1_CONTROL));\r\nwhile (1) {\r\nreg_val = __raw_readb(dev->regs + MXC_W1_CONTROL);\r\nif (((reg_val >> 7) & 0x1) == 0 ||\r\ntimeout_cnt > MXC_W1_RESET_TIMEOUT)\r\nbreak;\r\nelse\r\ntimeout_cnt++;\r\nudelay(100);\r\n}\r\nreturn (reg_val >> 7) & 0x1;\r\n}\r\nstatic u8 mxc_w1_ds2_touch_bit(void *data, u8 bit)\r\n{\r\nstruct mxc_w1_device *mdev = data;\r\nvoid __iomem *ctrl_addr = mdev->regs + MXC_W1_CONTROL;\r\nunsigned int timeout_cnt = 400;\r\n__raw_writeb((1 << (5 - bit)), ctrl_addr);\r\nwhile (timeout_cnt--) {\r\nif (!((__raw_readb(ctrl_addr) >> (5 - bit)) & 0x1))\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn ((__raw_readb(ctrl_addr)) >> 3) & 0x1;\r\n}\r\nstatic int __devinit mxc_w1_probe(struct platform_device *pdev)\r\n{\r\nstruct mxc_w1_device *mdev;\r\nstruct resource *res;\r\nint err = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nmdev = kzalloc(sizeof(struct mxc_w1_device), GFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nmdev->clk = clk_get(&pdev->dev, "owire");\r\nif (!mdev->clk) {\r\nerr = -ENODEV;\r\ngoto failed_clk;\r\n}\r\nmdev->clkdiv = (clk_get_rate(mdev->clk) / 1000000) - 1;\r\nres = request_mem_region(res->start, resource_size(res),\r\n"mxc_w1");\r\nif (!res) {\r\nerr = -EBUSY;\r\ngoto failed_req;\r\n}\r\nmdev->regs = ioremap(res->start, resource_size(res));\r\nif (!mdev->regs) {\r\nprintk(KERN_ERR "Cannot map frame buffer registers\n");\r\ngoto failed_ioremap;\r\n}\r\nclk_prepare_enable(mdev->clk);\r\n__raw_writeb(mdev->clkdiv, mdev->regs + MXC_W1_TIME_DIVIDER);\r\nmdev->bus_master.data = mdev;\r\nmdev->bus_master.reset_bus = mxc_w1_ds2_reset_bus;\r\nmdev->bus_master.touch_bit = mxc_w1_ds2_touch_bit;\r\nerr = w1_add_master_device(&mdev->bus_master);\r\nif (err)\r\ngoto failed_add;\r\nplatform_set_drvdata(pdev, mdev);\r\nreturn 0;\r\nfailed_add:\r\niounmap(mdev->regs);\r\nfailed_ioremap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfailed_req:\r\nclk_put(mdev->clk);\r\nfailed_clk:\r\nkfree(mdev);\r\nreturn err;\r\n}\r\nstatic int __devexit mxc_w1_remove(struct platform_device *pdev)\r\n{\r\nstruct mxc_w1_device *mdev = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nw1_remove_master_device(&mdev->bus_master);\r\niounmap(mdev->regs);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_disable_unprepare(mdev->clk);\r\nclk_put(mdev->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init mxc_w1_init(void)\r\n{\r\nreturn platform_driver_register(&mxc_w1_driver);\r\n}\r\nstatic void mxc_w1_exit(void)\r\n{\r\nplatform_driver_unregister(&mxc_w1_driver);\r\n}
