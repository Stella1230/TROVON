static struct ocfs2_stack_plugin *ocfs2_stack_lookup(const char *name)\r\n{\r\nstruct ocfs2_stack_plugin *p;\r\nassert_spin_locked(&ocfs2_stack_lock);\r\nlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\r\nif (!strcmp(p->sp_name, name))\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ocfs2_stack_driver_request(const char *stack_name,\r\nconst char *plugin_name)\r\n{\r\nint rc;\r\nstruct ocfs2_stack_plugin *p;\r\nspin_lock(&ocfs2_stack_lock);\r\nif (strcmp(stack_name, cluster_stack_name)) {\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nif (active_stack) {\r\nif (!strcmp(active_stack->sp_name, plugin_name))\r\nrc = 0;\r\nelse\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\np = ocfs2_stack_lookup(plugin_name);\r\nif (!p || !try_module_get(p->sp_owner)) {\r\nrc = -ENOENT;\r\ngoto out;\r\n}\r\nactive_stack = p;\r\nrc = 0;\r\nout:\r\nif (!rc)\r\nactive_stack->sp_count++;\r\nspin_unlock(&ocfs2_stack_lock);\r\nreturn rc;\r\n}\r\nstatic int ocfs2_stack_driver_get(const char *stack_name)\r\n{\r\nint rc;\r\nchar *plugin_name = OCFS2_STACK_PLUGIN_O2CB;\r\nif (!stack_name || !*stack_name)\r\nstack_name = OCFS2_STACK_PLUGIN_O2CB;\r\nif (strlen(stack_name) != OCFS2_STACK_LABEL_LEN) {\r\nprintk(KERN_ERR\r\n"ocfs2 passed an invalid cluster stack label: \"%s\"\n",\r\nstack_name);\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(stack_name, OCFS2_STACK_PLUGIN_O2CB))\r\nplugin_name = OCFS2_STACK_PLUGIN_USER;\r\nrc = ocfs2_stack_driver_request(stack_name, plugin_name);\r\nif (rc == -ENOENT) {\r\nrequest_module("ocfs2_stack_%s", plugin_name);\r\nrc = ocfs2_stack_driver_request(stack_name, plugin_name);\r\n}\r\nif (rc == -ENOENT) {\r\nprintk(KERN_ERR\r\n"ocfs2: Cluster stack driver \"%s\" cannot be found\n",\r\nplugin_name);\r\n} else if (rc == -EBUSY) {\r\nprintk(KERN_ERR\r\n"ocfs2: A different cluster stack is in use\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic void ocfs2_stack_driver_put(void)\r\n{\r\nspin_lock(&ocfs2_stack_lock);\r\nBUG_ON(active_stack == NULL);\r\nBUG_ON(active_stack->sp_count == 0);\r\nactive_stack->sp_count--;\r\nif (!active_stack->sp_count) {\r\nmodule_put(active_stack->sp_owner);\r\nactive_stack = NULL;\r\n}\r\nspin_unlock(&ocfs2_stack_lock);\r\n}\r\nint ocfs2_stack_glue_register(struct ocfs2_stack_plugin *plugin)\r\n{\r\nint rc;\r\nspin_lock(&ocfs2_stack_lock);\r\nif (!ocfs2_stack_lookup(plugin->sp_name)) {\r\nplugin->sp_count = 0;\r\nplugin->sp_max_proto = locking_max_version;\r\nlist_add(&plugin->sp_list, &ocfs2_stack_list);\r\nprintk(KERN_INFO "ocfs2: Registered cluster interface %s\n",\r\nplugin->sp_name);\r\nrc = 0;\r\n} else {\r\nprintk(KERN_ERR "ocfs2: Stack \"%s\" already registered\n",\r\nplugin->sp_name);\r\nrc = -EEXIST;\r\n}\r\nspin_unlock(&ocfs2_stack_lock);\r\nreturn rc;\r\n}\r\nvoid ocfs2_stack_glue_unregister(struct ocfs2_stack_plugin *plugin)\r\n{\r\nstruct ocfs2_stack_plugin *p;\r\nspin_lock(&ocfs2_stack_lock);\r\np = ocfs2_stack_lookup(plugin->sp_name);\r\nif (p) {\r\nBUG_ON(p != plugin);\r\nBUG_ON(plugin == active_stack);\r\nBUG_ON(plugin->sp_count != 0);\r\nlist_del_init(&plugin->sp_list);\r\nprintk(KERN_INFO "ocfs2: Unregistered cluster interface %s\n",\r\nplugin->sp_name);\r\n} else {\r\nprintk(KERN_ERR "Stack \"%s\" is not registered\n",\r\nplugin->sp_name);\r\n}\r\nspin_unlock(&ocfs2_stack_lock);\r\n}\r\nvoid ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_proto)\r\n{\r\nstruct ocfs2_stack_plugin *p;\r\nspin_lock(&ocfs2_stack_lock);\r\nif (memcmp(max_proto, &locking_max_version,\r\nsizeof(struct ocfs2_protocol_version))) {\r\nBUG_ON(locking_max_version.pv_major != 0);\r\nlocking_max_version = *max_proto;\r\nlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\r\np->sp_max_proto = locking_max_version;\r\n}\r\n}\r\nspin_unlock(&ocfs2_stack_lock);\r\n}\r\nint ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\r\nint mode,\r\nstruct ocfs2_dlm_lksb *lksb,\r\nu32 flags,\r\nvoid *name,\r\nunsigned int namelen)\r\n{\r\nif (!lksb->lksb_conn)\r\nlksb->lksb_conn = conn;\r\nelse\r\nBUG_ON(lksb->lksb_conn != conn);\r\nreturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\r\nname, namelen);\r\n}\r\nint ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\r\nstruct ocfs2_dlm_lksb *lksb,\r\nu32 flags)\r\n{\r\nBUG_ON(lksb->lksb_conn == NULL);\r\nreturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\r\n}\r\nint ocfs2_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nreturn active_stack->sp_ops->lock_status(lksb);\r\n}\r\nint ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nreturn active_stack->sp_ops->lvb_valid(lksb);\r\n}\r\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nreturn active_stack->sp_ops->lock_lvb(lksb);\r\n}\r\nvoid ocfs2_dlm_dump_lksb(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nactive_stack->sp_ops->dump_lksb(lksb);\r\n}\r\nint ocfs2_stack_supports_plocks(void)\r\n{\r\nreturn active_stack && active_stack->sp_ops->plock;\r\n}\r\nint ocfs2_plock(struct ocfs2_cluster_connection *conn, u64 ino,\r\nstruct file *file, int cmd, struct file_lock *fl)\r\n{\r\nWARN_ON_ONCE(active_stack->sp_ops->plock == NULL);\r\nif (active_stack->sp_ops->plock)\r\nreturn active_stack->sp_ops->plock(conn, ino, file, cmd, fl);\r\nreturn -EOPNOTSUPP;\r\n}\r\nint ocfs2_cluster_connect(const char *stack_name,\r\nconst char *group,\r\nint grouplen,\r\nstruct ocfs2_locking_protocol *lproto,\r\nvoid (*recovery_handler)(int node_num,\r\nvoid *recovery_data),\r\nvoid *recovery_data,\r\nstruct ocfs2_cluster_connection **conn)\r\n{\r\nint rc = 0;\r\nstruct ocfs2_cluster_connection *new_conn;\r\nBUG_ON(group == NULL);\r\nBUG_ON(conn == NULL);\r\nBUG_ON(recovery_handler == NULL);\r\nif (grouplen > GROUP_NAME_MAX) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (memcmp(&lproto->lp_max_version, &locking_max_version,\r\nsizeof(struct ocfs2_protocol_version))) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nnew_conn = kzalloc(sizeof(struct ocfs2_cluster_connection),\r\nGFP_KERNEL);\r\nif (!new_conn) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(new_conn->cc_name, group, grouplen);\r\nnew_conn->cc_namelen = grouplen;\r\nnew_conn->cc_recovery_handler = recovery_handler;\r\nnew_conn->cc_recovery_data = recovery_data;\r\nnew_conn->cc_proto = lproto;\r\nnew_conn->cc_version = lproto->lp_max_version;\r\nrc = ocfs2_stack_driver_get(stack_name);\r\nif (rc)\r\ngoto out_free;\r\nrc = active_stack->sp_ops->connect(new_conn);\r\nif (rc) {\r\nocfs2_stack_driver_put();\r\ngoto out_free;\r\n}\r\n*conn = new_conn;\r\nout_free:\r\nif (rc)\r\nkfree(new_conn);\r\nout:\r\nreturn rc;\r\n}\r\nint ocfs2_cluster_connect_agnostic(const char *group,\r\nint grouplen,\r\nstruct ocfs2_locking_protocol *lproto,\r\nvoid (*recovery_handler)(int node_num,\r\nvoid *recovery_data),\r\nvoid *recovery_data,\r\nstruct ocfs2_cluster_connection **conn)\r\n{\r\nchar *stack_name = NULL;\r\nif (cluster_stack_name[0])\r\nstack_name = cluster_stack_name;\r\nreturn ocfs2_cluster_connect(stack_name, group, grouplen, lproto,\r\nrecovery_handler, recovery_data, conn);\r\n}\r\nint ocfs2_cluster_disconnect(struct ocfs2_cluster_connection *conn,\r\nint hangup_pending)\r\n{\r\nint ret;\r\nBUG_ON(conn == NULL);\r\nret = active_stack->sp_ops->disconnect(conn);\r\nif (!ret) {\r\nkfree(conn);\r\nif (!hangup_pending)\r\nocfs2_stack_driver_put();\r\n}\r\nreturn ret;\r\n}\r\nstatic void ocfs2_leave_group(const char *group)\r\n{\r\nint ret;\r\nchar *argv[5], *envp[3];\r\nargv[0] = ocfs2_hb_ctl_path;\r\nargv[1] = "-K";\r\nargv[2] = "-u";\r\nargv[3] = (char *)group;\r\nargv[4] = NULL;\r\nenvp[0] = "HOME=/";\r\nenvp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";\r\nenvp[2] = NULL;\r\nret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\r\nif (ret < 0) {\r\nprintk(KERN_ERR\r\n"ocfs2: Error %d running user helper "\r\n"\"%s %s %s %s\"\n",\r\nret, argv[0], argv[1], argv[2], argv[3]);\r\n}\r\n}\r\nvoid ocfs2_cluster_hangup(const char *group, int grouplen)\r\n{\r\nBUG_ON(group == NULL);\r\nBUG_ON(group[grouplen] != '\0');\r\nocfs2_leave_group(group);\r\nocfs2_stack_driver_put();\r\n}\r\nint ocfs2_cluster_this_node(unsigned int *node)\r\n{\r\nreturn active_stack->sp_ops->this_node(node);\r\n}\r\nstatic ssize_t ocfs2_max_locking_protocol_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t ret = 0;\r\nspin_lock(&ocfs2_stack_lock);\r\nif (locking_max_version.pv_major)\r\nret = snprintf(buf, PAGE_SIZE, "%u.%u\n",\r\nlocking_max_version.pv_major,\r\nlocking_max_version.pv_minor);\r\nspin_unlock(&ocfs2_stack_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ocfs2_loaded_cluster_plugins_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t ret = 0, total = 0, remain = PAGE_SIZE;\r\nstruct ocfs2_stack_plugin *p;\r\nspin_lock(&ocfs2_stack_lock);\r\nlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\r\nret = snprintf(buf, remain, "%s\n",\r\np->sp_name);\r\nif (ret < 0) {\r\ntotal = ret;\r\nbreak;\r\n}\r\nif (ret == remain) {\r\ntotal = -E2BIG;\r\nbreak;\r\n}\r\ntotal += ret;\r\nremain -= ret;\r\n}\r\nspin_unlock(&ocfs2_stack_lock);\r\nreturn total;\r\n}\r\nstatic ssize_t ocfs2_active_cluster_plugin_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t ret = 0;\r\nspin_lock(&ocfs2_stack_lock);\r\nif (active_stack) {\r\nret = snprintf(buf, PAGE_SIZE, "%s\n",\r\nactive_stack->sp_name);\r\nif (ret == PAGE_SIZE)\r\nret = -E2BIG;\r\n}\r\nspin_unlock(&ocfs2_stack_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ocfs2_cluster_stack_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t ret;\r\nspin_lock(&ocfs2_stack_lock);\r\nret = snprintf(buf, PAGE_SIZE, "%s\n", cluster_stack_name);\r\nspin_unlock(&ocfs2_stack_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ocfs2_cluster_stack_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nsize_t len = count;\r\nssize_t ret;\r\nif (len == 0)\r\nreturn len;\r\nif (buf[len - 1] == '\n')\r\nlen--;\r\nif ((len != OCFS2_STACK_LABEL_LEN) ||\r\n(strnlen(buf, len) != len))\r\nreturn -EINVAL;\r\nspin_lock(&ocfs2_stack_lock);\r\nif (active_stack) {\r\nif (!strncmp(buf, cluster_stack_name, len))\r\nret = count;\r\nelse\r\nret = -EBUSY;\r\n} else {\r\nmemcpy(cluster_stack_name, buf, len);\r\nret = count;\r\n}\r\nspin_unlock(&ocfs2_stack_lock);\r\nreturn ret;\r\n}\r\nstatic void ocfs2_sysfs_exit(void)\r\n{\r\nkset_unregister(ocfs2_kset);\r\n}\r\nstatic int ocfs2_sysfs_init(void)\r\n{\r\nint ret;\r\nocfs2_kset = kset_create_and_add("ocfs2", NULL, fs_kobj);\r\nif (!ocfs2_kset)\r\nreturn -ENOMEM;\r\nret = sysfs_create_group(&ocfs2_kset->kobj, &ocfs2_attr_group);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nkset_unregister(ocfs2_kset);\r\nreturn ret;\r\n}\r\nstatic int __init ocfs2_stack_glue_init(void)\r\n{\r\nstrcpy(cluster_stack_name, OCFS2_STACK_PLUGIN_O2CB);\r\nocfs2_table_header = register_sysctl_table(ocfs2_root_table);\r\nif (!ocfs2_table_header) {\r\nprintk(KERN_ERR\r\n"ocfs2 stack glue: unable to register sysctl\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn ocfs2_sysfs_init();\r\n}\r\nstatic void __exit ocfs2_stack_glue_exit(void)\r\n{\r\nmemset(&locking_max_version, 0,\r\nsizeof(struct ocfs2_protocol_version));\r\nlocking_max_version.pv_major = 0;\r\nlocking_max_version.pv_minor = 0;\r\nocfs2_sysfs_exit();\r\nif (ocfs2_table_header)\r\nunregister_sysctl_table(ocfs2_table_header);\r\n}
