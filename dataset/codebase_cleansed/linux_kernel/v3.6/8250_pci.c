static void moan_device(const char *str, struct pci_dev *dev)\r\n{\r\nprintk(KERN_WARNING\r\n"%s: %s\n"\r\n"Please send the output of lspci -vv, this\n"\r\n"message (0x%04x,0x%04x,0x%04x,0x%04x), the\n"\r\n"manufacturer and name of serial board or\n"\r\n"modem board to rmk+serial@arm.linux.org.uk.\n",\r\npci_name(dev), str, dev->vendor, dev->device,\r\ndev->subsystem_vendor, dev->subsystem_device);\r\n}\r\nstatic int\r\nsetup_port(struct serial_private *priv, struct uart_port *port,\r\nint bar, int offset, int regshift)\r\n{\r\nstruct pci_dev *dev = priv->dev;\r\nunsigned long base, len;\r\nif (bar >= PCI_NUM_BAR_RESOURCES)\r\nreturn -EINVAL;\r\nbase = pci_resource_start(dev, bar);\r\nif (pci_resource_flags(dev, bar) & IORESOURCE_MEM) {\r\nlen = pci_resource_len(dev, bar);\r\nif (!priv->remapped_bar[bar])\r\npriv->remapped_bar[bar] = ioremap_nocache(base, len);\r\nif (!priv->remapped_bar[bar])\r\nreturn -ENOMEM;\r\nport->iotype = UPIO_MEM;\r\nport->iobase = 0;\r\nport->mapbase = base + offset;\r\nport->membase = priv->remapped_bar[bar] + offset;\r\nport->regshift = regshift;\r\n} else {\r\nport->iotype = UPIO_PORT;\r\nport->iobase = base + offset;\r\nport->mapbase = 0;\r\nport->membase = NULL;\r\nport->regshift = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int addidata_apci7800_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int bar = 0, offset = board->first_offset;\r\nbar = FL_GET_BASE(board->flags);\r\nif (idx < 2) {\r\noffset += idx * board->uart_offset;\r\n} else if ((idx >= 2) && (idx < 4)) {\r\nbar += 1;\r\noffset += ((idx - 2) * board->uart_offset);\r\n} else if ((idx >= 4) && (idx < 6)) {\r\nbar += 2;\r\noffset += ((idx - 4) * board->uart_offset);\r\n} else if (idx >= 6) {\r\nbar += 3;\r\noffset += ((idx - 6) * board->uart_offset);\r\n}\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int\r\nafavlab_setup(struct serial_private *priv, const struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset;\r\nbar = FL_GET_BASE(board->flags);\r\nif (idx < 4)\r\nbar += idx;\r\nelse {\r\nbar = 4;\r\noffset += (idx - 4) * board->uart_offset;\r\n}\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_hp_diva_init(struct pci_dev *dev)\r\n{\r\nint rc = 0;\r\nswitch (dev->subsystem_device) {\r\ncase PCI_DEVICE_ID_HP_DIVA_TOSCA1:\r\ncase PCI_DEVICE_ID_HP_DIVA_HALFDOME:\r\ncase PCI_DEVICE_ID_HP_DIVA_KEYSTONE:\r\ncase PCI_DEVICE_ID_HP_DIVA_EVEREST:\r\nrc = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_HP_DIVA_TOSCA2:\r\nrc = 2;\r\nbreak;\r\ncase PCI_DEVICE_ID_HP_DIVA_MAESTRO:\r\nrc = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_HP_DIVA_POWERBAR:\r\ncase PCI_DEVICE_ID_HP_DIVA_HURRICANE:\r\nrc = 1;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\npci_hp_diva_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int offset = board->first_offset;\r\nunsigned int bar = FL_GET_BASE(board->flags);\r\nswitch (priv->dev->subsystem_device) {\r\ncase PCI_DEVICE_ID_HP_DIVA_MAESTRO:\r\nif (idx == 3)\r\nidx++;\r\nbreak;\r\ncase PCI_DEVICE_ID_HP_DIVA_EVEREST:\r\nif (idx > 0)\r\nidx++;\r\nif (idx > 2)\r\nidx++;\r\nbreak;\r\n}\r\nif (idx > 2)\r\noffset = 0x18;\r\noffset += idx * board->uart_offset;\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_inteli960ni_init(struct pci_dev *dev)\r\n{\r\nunsigned long oldval;\r\nif (!(dev->subsystem_device & 0x1000))\r\nreturn -ENODEV;\r\npci_read_config_dword(dev, 0x44, (void *)&oldval);\r\nif (oldval == 0x00001000L) {\r\nprintk(KERN_DEBUG "Local i960 firmware missing");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_plx9050_init(struct pci_dev *dev)\r\n{\r\nu8 irq_config;\r\nvoid __iomem *p;\r\nif ((pci_resource_flags(dev, 0) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar 0", dev);\r\nreturn 0;\r\n}\r\nirq_config = 0x41;\r\nif (dev->vendor == PCI_VENDOR_ID_PANACOM ||\r\ndev->subsystem_vendor == PCI_SUBVENDOR_ID_EXSYS)\r\nirq_config = 0x43;\r\nif ((dev->vendor == PCI_VENDOR_ID_PLX) &&\r\n(dev->device == PCI_DEVICE_ID_PLX_ROMULUS))\r\nirq_config = 0x5b;\r\np = ioremap_nocache(pci_resource_start(dev, 0), 0x80);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nwritel(irq_config, p + 0x4c);\r\nreadl(p + 0x4c);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic void __devexit pci_plx9050_exit(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\nif ((pci_resource_flags(dev, 0) & IORESOURCE_MEM) == 0)\r\nreturn;\r\np = ioremap_nocache(pci_resource_start(dev, 0), 0x80);\r\nif (p != NULL) {\r\nwritel(0, p + 0x4c);\r\nreadl(p + 0x4c);\r\niounmap(p);\r\n}\r\n}\r\nstatic void __devexit pci_ni8420_exit(struct pci_dev *dev)\r\n{\r\nvoid __iomem *p;\r\nunsigned long base, len;\r\nunsigned int bar = 0;\r\nif ((pci_resource_flags(dev, bar) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar", dev);\r\nreturn;\r\n}\r\nbase = pci_resource_start(dev, bar);\r\nlen = pci_resource_len(dev, bar);\r\np = ioremap_nocache(base, len);\r\nif (p == NULL)\r\nreturn;\r\nwritel(readl(p + NI8420_INT_ENABLE_REG) & ~(NI8420_INT_ENABLE_BIT),\r\np + NI8420_INT_ENABLE_REG);\r\niounmap(p);\r\n}\r\nstatic void __devexit pci_ni8430_exit(struct pci_dev *dev)\r\n{\r\nvoid __iomem *p;\r\nunsigned long base, len;\r\nunsigned int bar = 0;\r\nif ((pci_resource_flags(dev, bar) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar", dev);\r\nreturn;\r\n}\r\nbase = pci_resource_start(dev, bar);\r\nlen = pci_resource_len(dev, bar);\r\np = ioremap_nocache(base, len);\r\nif (p == NULL)\r\nreturn;\r\nwritel(MITE_LCIMR2_CLR_CPU_IE, p + MITE_LCIMR2);\r\niounmap(p);\r\n}\r\nstatic int\r\nsbs_setup(struct serial_private *priv, const struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset;\r\nbar = 0;\r\nif (idx < 4) {\r\noffset += idx * board->uart_offset;\r\n} else if (idx < 8) {\r\noffset += idx * board->uart_offset + 0xC00;\r\n} else\r\nreturn 1;\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int sbs_init(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\np = pci_ioremap_bar(dev, 0);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nwriteb(0x10, p + OCT_REG_CR_OFF);\r\nudelay(50);\r\nwriteb(0x0, p + OCT_REG_CR_OFF);\r\nwriteb(0x4, p + OCT_REG_CR_OFF);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic void __devexit sbs_exit(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\np = pci_ioremap_bar(dev, 0);\r\nif (p != NULL)\r\nwriteb(0, p + OCT_REG_CR_OFF);\r\niounmap(p);\r\n}\r\nstatic int pci_siig10x_init(struct pci_dev *dev)\r\n{\r\nu16 data;\r\nvoid __iomem *p;\r\nswitch (dev->device & 0xfff8) {\r\ncase PCI_DEVICE_ID_SIIG_1S_10x:\r\ndata = 0xffdf;\r\nbreak;\r\ncase PCI_DEVICE_ID_SIIG_2S_10x:\r\ndata = 0xf7ff;\r\nbreak;\r\ndefault:\r\ndata = 0xfffb;\r\nbreak;\r\n}\r\np = ioremap_nocache(pci_resource_start(dev, 0), 0x80);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nwritew(readw(p + 0x28) & data, p + 0x28);\r\nreadw(p + 0x28);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic int pci_siig20x_init(struct pci_dev *dev)\r\n{\r\nu8 data;\r\npci_read_config_byte(dev, 0x6f, &data);\r\npci_write_config_byte(dev, 0x6f, data & 0xef);\r\nif (((dev->device & 0xfffc) == PCI_DEVICE_ID_SIIG_2S_20x) ||\r\n((dev->device & 0xfffc) == PCI_DEVICE_ID_SIIG_2S1P_20x)) {\r\npci_read_config_byte(dev, 0x73, &data);\r\npci_write_config_byte(dev, 0x73, data & 0xef);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_siig_init(struct pci_dev *dev)\r\n{\r\nunsigned int type = dev->device & 0xff00;\r\nif (type == 0x1000)\r\nreturn pci_siig10x_init(dev);\r\nelse if (type == 0x2000)\r\nreturn pci_siig20x_init(dev);\r\nmoan_device("Unknown SIIG card", dev);\r\nreturn -ENODEV;\r\n}\r\nstatic int pci_siig_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int bar = FL_GET_BASE(board->flags) + idx, offset = 0;\r\nif (idx > 3) {\r\nbar = 4;\r\noffset = (idx - 4) * 8;\r\n}\r\nreturn setup_port(priv, port, bar, offset, 0);\r\n}\r\nstatic int pci_timedia_probe(struct pci_dev *dev)\r\n{\r\nif ((dev->subsystem_device & 0x00f0) >= 0x70) {\r\ndev_info(&dev->dev,\r\n"ignoring Timedia subdevice %04x for parport_serial\n",\r\ndev->subsystem_device);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_timedia_init(struct pci_dev *dev)\r\n{\r\nconst unsigned short *ids;\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(timedia_data); i++) {\r\nids = timedia_data[i].ids;\r\nfor (j = 0; ids[j]; j++)\r\nif (dev->subsystem_device == ids[j])\r\nreturn timedia_data[i].num;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npci_timedia_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int bar = 0, offset = board->first_offset;\r\nswitch (idx) {\r\ncase 0:\r\nbar = 0;\r\nbreak;\r\ncase 1:\r\noffset = board->uart_offset;\r\nbar = 0;\r\nbreak;\r\ncase 2:\r\nbar = 1;\r\nbreak;\r\ncase 3:\r\noffset = board->uart_offset;\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nbar = idx - 2;\r\n}\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int\r\ntitan_400l_800l_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset;\r\nswitch (idx) {\r\ncase 0:\r\nbar = 1;\r\nbreak;\r\ncase 1:\r\nbar = 2;\r\nbreak;\r\ndefault:\r\nbar = 4;\r\noffset = (idx - 2) * board->uart_offset;\r\n}\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_xircom_init(struct pci_dev *dev)\r\n{\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic int pci_ni8420_init(struct pci_dev *dev)\r\n{\r\nvoid __iomem *p;\r\nunsigned long base, len;\r\nunsigned int bar = 0;\r\nif ((pci_resource_flags(dev, bar) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar", dev);\r\nreturn 0;\r\n}\r\nbase = pci_resource_start(dev, bar);\r\nlen = pci_resource_len(dev, bar);\r\np = ioremap_nocache(base, len);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nwritel(readl(p + NI8420_INT_ENABLE_REG) | NI8420_INT_ENABLE_BIT,\r\np + NI8420_INT_ENABLE_REG);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic int pci_ni8430_init(struct pci_dev *dev)\r\n{\r\nvoid __iomem *p;\r\nunsigned long base, len;\r\nu32 device_window;\r\nunsigned int bar = 0;\r\nif ((pci_resource_flags(dev, bar) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar", dev);\r\nreturn 0;\r\n}\r\nbase = pci_resource_start(dev, bar);\r\nlen = pci_resource_len(dev, bar);\r\np = ioremap_nocache(base, len);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\ndevice_window = ((base + MITE_IOWBSR1_WIN_OFFSET) & 0xffffff00)\r\n| MITE_IOWBSR1_WENAB | MITE_IOWBSR1_WSIZE;\r\nwritel(device_window, p + MITE_IOWBSR1);\r\nwritel((readl(p + MITE_IOWCR1) & MITE_IOWCR1_RAMSEL_MASK),\r\np + MITE_IOWCR1);\r\nwritel(MITE_LCIMR1_IO_IE_0, p + MITE_LCIMR1);\r\nwritel(MITE_LCIMR2_SET_CPU_IE, p + MITE_LCIMR2);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic int\r\npci_ni8430_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nvoid __iomem *p;\r\nunsigned long base, len;\r\nunsigned int bar, offset = board->first_offset;\r\nif (idx >= board->num_ports)\r\nreturn 1;\r\nbar = FL_GET_BASE(board->flags);\r\noffset += idx * board->uart_offset;\r\nbase = pci_resource_start(priv->dev, bar);\r\nlen = pci_resource_len(priv->dev, bar);\r\np = ioremap_nocache(base, len);\r\nwriteb(readb(p + offset + NI8430_PORTCON) | NI8430_PORTCON_TXVR_ENABLE,\r\np + offset + NI8430_PORTCON);\r\niounmap(p);\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_netmos_9900_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int bar;\r\nif ((priv->dev->subsystem_device & 0xff00) == 0x3000) {\r\nbar = 3 * idx;\r\nreturn setup_port(priv, port, bar, 0, board->reg_shift);\r\n} else {\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\n}\r\nstatic int pci_netmos_9900_numports(struct pci_dev *dev)\r\n{\r\nunsigned int c = dev->class;\r\nunsigned int pi;\r\nunsigned short sub_serports;\r\npi = (c & 0xff);\r\nif (pi == 2) {\r\nreturn 1;\r\n} else if ((pi == 0) &&\r\n(dev->device == PCI_DEVICE_ID_NETMOS_9900)) {\r\nsub_serports = dev->subsystem_device & 0xf;\r\nif (sub_serports > 0) {\r\nreturn sub_serports;\r\n} else {\r\nprintk(KERN_NOTICE "NetMos/Mostech serial driver ignoring port on ambiguous config.\n");\r\nreturn 0;\r\n}\r\n}\r\nmoan_device("unknown NetMos/Mostech program interface", dev);\r\nreturn 0;\r\n}\r\nstatic int pci_netmos_init(struct pci_dev *dev)\r\n{\r\nunsigned int num_serial = dev->subsystem_device & 0xf;\r\nif ((dev->device == PCI_DEVICE_ID_NETMOS_9901) ||\r\n(dev->device == PCI_DEVICE_ID_NETMOS_9865))\r\nreturn 0;\r\nif (dev->subsystem_vendor == PCI_VENDOR_ID_IBM &&\r\ndev->subsystem_device == 0x0299)\r\nreturn 0;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_NETMOS_9904:\r\ncase PCI_DEVICE_ID_NETMOS_9912:\r\ncase PCI_DEVICE_ID_NETMOS_9922:\r\ncase PCI_DEVICE_ID_NETMOS_9900:\r\nnum_serial = pci_netmos_9900_numports(dev);\r\nbreak;\r\ndefault:\r\nif (num_serial == 0 ) {\r\nmoan_device("unknown NetMos/Mostech device", dev);\r\n}\r\n}\r\nif (num_serial == 0)\r\nreturn -ENODEV;\r\nreturn num_serial;\r\n}\r\nstatic int pci_ite887x_init(struct pci_dev *dev)\r\n{\r\nstatic const short inta_addr[] = { 0x2a0, 0x2c0, 0x220, 0x240, 0x1e0,\r\n0x200, 0x280, 0 };\r\nint ret, i, type;\r\nstruct resource *iobase = NULL;\r\nu32 miscr, uartbar, ioport;\r\ni = 0;\r\nwhile (inta_addr[i] && iobase == NULL) {\r\niobase = request_region(inta_addr[i], ITE_887x_IOSIZE,\r\n"ite887x");\r\nif (iobase != NULL) {\r\npci_write_config_dword(dev, ITE_887x_POSIO0,\r\nITE_887x_POSIO_ENABLE | ITE_887x_POSIO_SPEED |\r\nITE_887x_POSIO_IOSIZE_32 | inta_addr[i]);\r\npci_write_config_dword(dev, ITE_887x_INTCBAR,\r\ninta_addr[i]);\r\nret = inb(inta_addr[i]);\r\nif (ret != 0xff) {\r\nbreak;\r\n}\r\nrelease_region(iobase->start, ITE_887x_IOSIZE);\r\niobase = NULL;\r\n}\r\ni++;\r\n}\r\nif (!inta_addr[i]) {\r\nprintk(KERN_ERR "ite887x: could not find iobase\n");\r\nreturn -ENODEV;\r\n}\r\ntype = inb(iobase->start + 0x18) & 0x0f;\r\nswitch (type) {\r\ncase 0x2:\r\ncase 0xa:\r\nret = 0;\r\nbreak;\r\ncase 0xe:\r\nret = 2;\r\nbreak;\r\ncase 0x6:\r\nret = 1;\r\nbreak;\r\ncase 0x8:\r\nret = 2;\r\nbreak;\r\ndefault:\r\nmoan_device("Unknown ITE887x", dev);\r\nret = -ENODEV;\r\n}\r\nfor (i = 0; i < ret; i++) {\r\npci_read_config_dword(dev, ITE_887x_PS0BAR + (0x4 * (i + 1)),\r\n&ioport);\r\nioport &= 0x0000FF00;\r\npci_write_config_dword(dev, ITE_887x_POSIO0 + (0x4 * (i + 1)),\r\nITE_887x_POSIO_ENABLE | ITE_887x_POSIO_SPEED |\r\nITE_887x_POSIO_IOSIZE_8 | ioport);\r\npci_read_config_dword(dev, ITE_887x_UARTBAR, &uartbar);\r\nuartbar &= ~(0xffff << (16 * i));\r\nuartbar |= (ioport << (16 * i));\r\npci_write_config_dword(dev, ITE_887x_UARTBAR, uartbar);\r\npci_read_config_dword(dev, ITE_887x_MISCR, &miscr);\r\nmiscr &= ~(0xf << (12 - 4 * i));\r\nmiscr |= 1 << (23 - i);\r\npci_write_config_dword(dev, ITE_887x_MISCR, miscr);\r\n}\r\nif (ret <= 0) {\r\nrelease_region(iobase->start, ITE_887x_IOSIZE);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __devexit pci_ite887x_exit(struct pci_dev *dev)\r\n{\r\nu32 ioport;\r\npci_read_config_dword(dev, ITE_887x_POSIO0, &ioport);\r\nioport &= 0xffff;\r\nrelease_region(ioport, ITE_887x_IOSIZE);\r\n}\r\nstatic int pci_oxsemi_tornado_init(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\nunsigned long deviceID;\r\nunsigned int number_uarts = 0;\r\nif (dev->vendor == PCI_VENDOR_ID_OXSEMI &&\r\n(dev->device & 0xF000) != 0xC000)\r\nreturn 0;\r\np = pci_iomap(dev, 0, 5);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\ndeviceID = ioread32(p);\r\nif (deviceID == 0x07000200) {\r\nnumber_uarts = ioread8(p + 4);\r\nprintk(KERN_DEBUG\r\n"%d ports detected on Oxford PCI Express device\n",\r\nnumber_uarts);\r\n}\r\npci_iounmap(dev, p);\r\nreturn number_uarts;\r\n}\r\nstatic int\r\npci_default_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset, maxnr;\r\nbar = FL_GET_BASE(board->flags);\r\nif (board->flags & FL_BASE_BARS)\r\nbar += idx;\r\nelse\r\noffset += idx * board->uart_offset;\r\nmaxnr = (pci_resource_len(priv->dev, bar) - board->first_offset) >>\r\n(board->reg_shift + 3);\r\nif (board->flags & FL_REGION_SZ_CAP && idx >= maxnr)\r\nreturn 1;\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int\r\nce4100_serial_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nint ret;\r\nret = setup_port(priv, port, 0, 0, board->reg_shift);\r\nport->iotype = UPIO_MEM32;\r\nport->type = PORT_XSCALE;\r\nport->flags = (port->flags | UPF_FIXED_PORT | UPF_FIXED_TYPE);\r\nport->regshift = 2;\r\nreturn ret;\r\n}\r\nstatic int\r\npci_omegapci_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nreturn setup_port(priv, port, 2, idx * 8, 0);\r\n}\r\nstatic int skip_tx_en_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nport->flags |= UPF_NO_TXEN_TEST;\r\nprintk(KERN_DEBUG "serial8250: skipping TxEn test for device "\r\n"[%04x:%04x] subsystem [%04x:%04x]\n",\r\npriv->dev->vendor,\r\npriv->dev->device,\r\npriv->dev->subsystem_vendor,\r\npriv->dev->subsystem_device);\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\nstatic void kt_handle_break(struct uart_port *p)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(p, struct uart_8250_port, port);\r\nserial8250_clear_and_reinit_fifos(up);\r\n}\r\nstatic unsigned int kt_serial_in(struct uart_port *p, int offset)\r\n{\r\nstruct uart_8250_port *up =\r\ncontainer_of(p, struct uart_8250_port, port);\r\nunsigned int val;\r\nval = inb(p->iobase + offset);\r\nif (offset == UART_IER) {\r\nif (val == 0)\r\nval = up->ier;\r\n}\r\nreturn val;\r\n}\r\nstatic int kt_serial_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nport->flags |= UPF_BUG_THRE;\r\nport->serial_in = kt_serial_in;\r\nport->handle_break = kt_handle_break;\r\nreturn skip_tx_en_setup(priv, board, port, idx);\r\n}\r\nstatic int pci_eg20t_init(struct pci_dev *dev)\r\n{\r\n#if defined(CONFIG_SERIAL_PCH_UART) || defined(CONFIG_SERIAL_PCH_UART_MODULE)\r\nreturn -ENODEV;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int\r\npci_xr17c154_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_port *port, int idx)\r\n{\r\nport->flags |= UPF_EXAR_EFR;\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\nstatic inline int quirk_id_matches(u32 quirk_id, u32 dev_id)\r\n{\r\nreturn quirk_id == PCI_ANY_ID || quirk_id == dev_id;\r\n}\r\nstatic struct pci_serial_quirk *find_quirk(struct pci_dev *dev)\r\n{\r\nstruct pci_serial_quirk *quirk;\r\nfor (quirk = pci_serial_quirks; ; quirk++)\r\nif (quirk_id_matches(quirk->vendor, dev->vendor) &&\r\nquirk_id_matches(quirk->device, dev->device) &&\r\nquirk_id_matches(quirk->subvendor, dev->subsystem_vendor) &&\r\nquirk_id_matches(quirk->subdevice, dev->subsystem_device))\r\nbreak;\r\nreturn quirk;\r\n}\r\nstatic inline int get_pci_irq(struct pci_dev *dev,\r\nconst struct pciserial_board *board)\r\n{\r\nif (board->flags & FL_NOIRQ)\r\nreturn 0;\r\nelse\r\nreturn dev->irq;\r\n}\r\nstatic int __devinit\r\nserial_pci_guess_board(struct pci_dev *dev, struct pciserial_board *board)\r\n{\r\nconst struct pci_device_id *blacklist;\r\nint num_iomem, num_port, first_port = -1, i;\r\nif ((((dev->class >> 8) != PCI_CLASS_COMMUNICATION_SERIAL) &&\r\n((dev->class >> 8) != PCI_CLASS_COMMUNICATION_MODEM)) ||\r\n(dev->class & 0xff) > 6)\r\nreturn -ENODEV;\r\nfor (blacklist = softmodem_blacklist;\r\nblacklist < softmodem_blacklist + ARRAY_SIZE(softmodem_blacklist);\r\nblacklist++) {\r\nif (dev->vendor == blacklist->vendor &&\r\ndev->device == blacklist->device)\r\nreturn -ENODEV;\r\n}\r\nnum_iomem = num_port = 0;\r\nfor (i = 0; i < PCI_NUM_BAR_RESOURCES; i++) {\r\nif (pci_resource_flags(dev, i) & IORESOURCE_IO) {\r\nnum_port++;\r\nif (first_port == -1)\r\nfirst_port = i;\r\n}\r\nif (pci_resource_flags(dev, i) & IORESOURCE_MEM)\r\nnum_iomem++;\r\n}\r\nif (num_iomem <= 1 && num_port == 1) {\r\nboard->flags = first_port;\r\nboard->num_ports = pci_resource_len(dev, first_port) / 8;\r\nreturn 0;\r\n}\r\nfirst_port = -1;\r\nnum_port = 0;\r\nfor (i = 0; i < PCI_NUM_BAR_RESOURCES; i++) {\r\nif (pci_resource_flags(dev, i) & IORESOURCE_IO &&\r\npci_resource_len(dev, i) == 8 &&\r\n(first_port == -1 || (first_port + num_port) == i)) {\r\nnum_port++;\r\nif (first_port == -1)\r\nfirst_port = i;\r\n}\r\n}\r\nif (num_port > 1) {\r\nboard->flags = first_port | FL_BASE_BARS;\r\nboard->num_ports = num_port;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic inline int\r\nserial_pci_matches(const struct pciserial_board *board,\r\nconst struct pciserial_board *guessed)\r\n{\r\nreturn\r\nboard->num_ports == guessed->num_ports &&\r\nboard->base_baud == guessed->base_baud &&\r\nboard->uart_offset == guessed->uart_offset &&\r\nboard->reg_shift == guessed->reg_shift &&\r\nboard->first_offset == guessed->first_offset;\r\n}\r\nstruct serial_private *\r\npciserial_init_ports(struct pci_dev *dev, const struct pciserial_board *board)\r\n{\r\nstruct uart_port serial_port;\r\nstruct serial_private *priv;\r\nstruct pci_serial_quirk *quirk;\r\nint rc, nr_ports, i;\r\nnr_ports = board->num_ports;\r\nquirk = find_quirk(dev);\r\nif (quirk->init) {\r\nrc = quirk->init(dev);\r\nif (rc < 0) {\r\npriv = ERR_PTR(rc);\r\ngoto err_out;\r\n}\r\nif (rc)\r\nnr_ports = rc;\r\n}\r\npriv = kzalloc(sizeof(struct serial_private) +\r\nsizeof(unsigned int) * nr_ports,\r\nGFP_KERNEL);\r\nif (!priv) {\r\npriv = ERR_PTR(-ENOMEM);\r\ngoto err_deinit;\r\n}\r\npriv->dev = dev;\r\npriv->quirk = quirk;\r\nmemset(&serial_port, 0, sizeof(struct uart_port));\r\nserial_port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;\r\nserial_port.uartclk = board->base_baud * 16;\r\nserial_port.irq = get_pci_irq(dev, board);\r\nserial_port.dev = &dev->dev;\r\nfor (i = 0; i < nr_ports; i++) {\r\nif (quirk->setup(priv, board, &serial_port, i))\r\nbreak;\r\n#ifdef SERIAL_DEBUG_PCI\r\nprintk(KERN_DEBUG "Setup PCI port: port %lx, irq %d, type %d\n",\r\nserial_port.iobase, serial_port.irq, serial_port.iotype);\r\n#endif\r\npriv->line[i] = serial8250_register_port(&serial_port);\r\nif (priv->line[i] < 0) {\r\nprintk(KERN_WARNING "Couldn't register serial port %s: %d\n", pci_name(dev), priv->line[i]);\r\nbreak;\r\n}\r\n}\r\npriv->nr = i;\r\nreturn priv;\r\nerr_deinit:\r\nif (quirk->exit)\r\nquirk->exit(dev);\r\nerr_out:\r\nreturn priv;\r\n}\r\nvoid pciserial_remove_ports(struct serial_private *priv)\r\n{\r\nstruct pci_serial_quirk *quirk;\r\nint i;\r\nfor (i = 0; i < priv->nr; i++)\r\nserial8250_unregister_port(priv->line[i]);\r\nfor (i = 0; i < PCI_NUM_BAR_RESOURCES; i++) {\r\nif (priv->remapped_bar[i])\r\niounmap(priv->remapped_bar[i]);\r\npriv->remapped_bar[i] = NULL;\r\n}\r\nquirk = find_quirk(priv->dev);\r\nif (quirk->exit)\r\nquirk->exit(priv->dev);\r\nkfree(priv);\r\n}\r\nvoid pciserial_suspend_ports(struct serial_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < priv->nr; i++)\r\nif (priv->line[i] >= 0)\r\nserial8250_suspend_port(priv->line[i]);\r\nif (priv->quirk->exit)\r\npriv->quirk->exit(priv->dev);\r\n}\r\nvoid pciserial_resume_ports(struct serial_private *priv)\r\n{\r\nint i;\r\nif (priv->quirk->init)\r\npriv->quirk->init(priv->dev);\r\nfor (i = 0; i < priv->nr; i++)\r\nif (priv->line[i] >= 0)\r\nserial8250_resume_port(priv->line[i]);\r\n}\r\nstatic int __devinit\r\npciserial_init_one(struct pci_dev *dev, const struct pci_device_id *ent)\r\n{\r\nstruct pci_serial_quirk *quirk;\r\nstruct serial_private *priv;\r\nconst struct pciserial_board *board;\r\nstruct pciserial_board tmp;\r\nint rc;\r\nquirk = find_quirk(dev);\r\nif (quirk->probe) {\r\nrc = quirk->probe(dev);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (ent->driver_data >= ARRAY_SIZE(pci_boards)) {\r\nprintk(KERN_ERR "pci_init_one: invalid driver_data: %ld\n",\r\nent->driver_data);\r\nreturn -EINVAL;\r\n}\r\nboard = &pci_boards[ent->driver_data];\r\nrc = pci_enable_device(dev);\r\npci_save_state(dev);\r\nif (rc)\r\nreturn rc;\r\nif (ent->driver_data == pbn_default) {\r\nmemcpy(&tmp, board, sizeof(struct pciserial_board));\r\nboard = &tmp;\r\nrc = serial_pci_guess_board(dev, &tmp);\r\nif (rc)\r\ngoto disable;\r\n} else {\r\nmemcpy(&tmp, &pci_boards[pbn_default],\r\nsizeof(struct pciserial_board));\r\nrc = serial_pci_guess_board(dev, &tmp);\r\nif (rc == 0 && serial_pci_matches(board, &tmp))\r\nmoan_device("Redundant entry in serial pci_table.",\r\ndev);\r\n}\r\npriv = pciserial_init_ports(dev, board);\r\nif (!IS_ERR(priv)) {\r\npci_set_drvdata(dev, priv);\r\nreturn 0;\r\n}\r\nrc = PTR_ERR(priv);\r\ndisable:\r\npci_disable_device(dev);\r\nreturn rc;\r\n}\r\nstatic void __devexit pciserial_remove_one(struct pci_dev *dev)\r\n{\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\npci_set_drvdata(dev, NULL);\r\npciserial_remove_ports(priv);\r\npci_disable_device(dev);\r\n}\r\nstatic int pciserial_suspend_one(struct pci_dev *dev, pm_message_t state)\r\n{\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\nif (priv)\r\npciserial_suspend_ports(priv);\r\npci_save_state(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, state));\r\nreturn 0;\r\n}\r\nstatic int pciserial_resume_one(struct pci_dev *dev)\r\n{\r\nint err;\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nif (priv) {\r\nerr = pci_enable_device(dev);\r\nif (err)\r\nprintk(KERN_ERR "pciserial: Unable to re-enable ports, trying to continue.\n");\r\npciserial_resume_ports(priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t serial8250_io_error_detected(struct pci_dev *dev,\r\npci_channel_state_t state)\r\n{\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (priv)\r\npciserial_suspend_ports(priv);\r\npci_disable_device(dev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t serial8250_io_slot_reset(struct pci_dev *dev)\r\n{\r\nint rc;\r\nrc = pci_enable_device(dev);\r\nif (rc)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\npci_restore_state(dev);\r\npci_save_state(dev);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void serial8250_io_resume(struct pci_dev *dev)\r\n{\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\nif (priv)\r\npciserial_resume_ports(priv);\r\n}\r\nstatic int __init serial8250_pci_init(void)\r\n{\r\nreturn pci_register_driver(&serial_pci_driver);\r\n}\r\nstatic void __exit serial8250_pci_exit(void)\r\n{\r\npci_unregister_driver(&serial_pci_driver);\r\n}
