static void printstat_val(struct seq_file *s, atomic_long_t *v, char *id)\r\n{\r\nunsigned long val = atomic_long_read(v);\r\nseq_printf(s, "%16lu %s\n", val, id);\r\n}\r\nstatic int statistics_show(struct seq_file *s, void *p)\r\n{\r\nprintstat(s, vdata_alloc);\r\nprintstat(s, vdata_free);\r\nprintstat(s, gts_alloc);\r\nprintstat(s, gts_free);\r\nprintstat(s, gms_alloc);\r\nprintstat(s, gms_free);\r\nprintstat(s, gts_double_allocate);\r\nprintstat(s, assign_context);\r\nprintstat(s, assign_context_failed);\r\nprintstat(s, free_context);\r\nprintstat(s, load_user_context);\r\nprintstat(s, load_kernel_context);\r\nprintstat(s, lock_kernel_context);\r\nprintstat(s, unlock_kernel_context);\r\nprintstat(s, steal_user_context);\r\nprintstat(s, steal_kernel_context);\r\nprintstat(s, steal_context_failed);\r\nprintstat(s, nopfn);\r\nprintstat(s, asid_new);\r\nprintstat(s, asid_next);\r\nprintstat(s, asid_wrap);\r\nprintstat(s, asid_reuse);\r\nprintstat(s, intr);\r\nprintstat(s, intr_cbr);\r\nprintstat(s, intr_tfh);\r\nprintstat(s, intr_spurious);\r\nprintstat(s, intr_mm_lock_failed);\r\nprintstat(s, call_os);\r\nprintstat(s, call_os_wait_queue);\r\nprintstat(s, user_flush_tlb);\r\nprintstat(s, user_unload_context);\r\nprintstat(s, user_exception);\r\nprintstat(s, set_context_option);\r\nprintstat(s, check_context_retarget_intr);\r\nprintstat(s, check_context_unload);\r\nprintstat(s, tlb_dropin);\r\nprintstat(s, tlb_preload_page);\r\nprintstat(s, tlb_dropin_fail_no_asid);\r\nprintstat(s, tlb_dropin_fail_upm);\r\nprintstat(s, tlb_dropin_fail_invalid);\r\nprintstat(s, tlb_dropin_fail_range_active);\r\nprintstat(s, tlb_dropin_fail_idle);\r\nprintstat(s, tlb_dropin_fail_fmm);\r\nprintstat(s, tlb_dropin_fail_no_exception);\r\nprintstat(s, tfh_stale_on_fault);\r\nprintstat(s, mmu_invalidate_range);\r\nprintstat(s, mmu_invalidate_page);\r\nprintstat(s, flush_tlb);\r\nprintstat(s, flush_tlb_gru);\r\nprintstat(s, flush_tlb_gru_tgh);\r\nprintstat(s, flush_tlb_gru_zero_asid);\r\nprintstat(s, copy_gpa);\r\nprintstat(s, read_gpa);\r\nprintstat(s, mesq_receive);\r\nprintstat(s, mesq_receive_none);\r\nprintstat(s, mesq_send);\r\nprintstat(s, mesq_send_failed);\r\nprintstat(s, mesq_noop);\r\nprintstat(s, mesq_send_unexpected_error);\r\nprintstat(s, mesq_send_lb_overflow);\r\nprintstat(s, mesq_send_qlimit_reached);\r\nprintstat(s, mesq_send_amo_nacked);\r\nprintstat(s, mesq_send_put_nacked);\r\nprintstat(s, mesq_qf_locked);\r\nprintstat(s, mesq_qf_noop_not_full);\r\nprintstat(s, mesq_qf_switch_head_failed);\r\nprintstat(s, mesq_qf_unexpected_error);\r\nprintstat(s, mesq_noop_unexpected_error);\r\nprintstat(s, mesq_noop_lb_overflow);\r\nprintstat(s, mesq_noop_qlimit_reached);\r\nprintstat(s, mesq_noop_amo_nacked);\r\nprintstat(s, mesq_noop_put_nacked);\r\nprintstat(s, mesq_noop_page_overflow);\r\nreturn 0;\r\n}\r\nstatic ssize_t statistics_write(struct file *file, const char __user *userbuf,\r\nsize_t count, loff_t *data)\r\n{\r\nmemset(&gru_stats, 0, sizeof(gru_stats));\r\nreturn count;\r\n}\r\nstatic int mcs_statistics_show(struct seq_file *s, void *p)\r\n{\r\nint op;\r\nunsigned long total, count, max;\r\nstatic char *id[] = {"cch_allocate", "cch_start", "cch_interrupt",\r\n"cch_interrupt_sync", "cch_deallocate", "tfh_write_only",\r\n"tfh_write_restart", "tgh_invalidate"};\r\nseq_printf(s, "%-20s%12s%12s%12s\n", "#id", "count", "aver-clks", "max-clks");\r\nfor (op = 0; op < mcsop_last; op++) {\r\ncount = atomic_long_read(&mcs_op_statistics[op].count);\r\ntotal = atomic_long_read(&mcs_op_statistics[op].total);\r\nmax = mcs_op_statistics[op].max;\r\nseq_printf(s, "%-20s%12ld%12ld%12ld\n", id[op], count,\r\ncount ? total / count : 0, max);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t mcs_statistics_write(struct file *file,\r\nconst char __user *userbuf, size_t count, loff_t *data)\r\n{\r\nmemset(mcs_op_statistics, 0, sizeof(mcs_op_statistics));\r\nreturn count;\r\n}\r\nstatic int options_show(struct seq_file *s, void *p)\r\n{\r\nseq_printf(s, "#bitmask: 1=trace, 2=statistics\n");\r\nseq_printf(s, "0x%lx\n", gru_options);\r\nreturn 0;\r\n}\r\nstatic ssize_t options_write(struct file *file, const char __user *userbuf,\r\nsize_t count, loff_t *data)\r\n{\r\nchar buf[20];\r\nif (count >= sizeof(buf))\r\nreturn -EINVAL;\r\nif (copy_from_user(buf, userbuf, count))\r\nreturn -EFAULT;\r\nbuf[count] = '\0';\r\nif (strict_strtoul(buf, 0, &gru_options))\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int cch_seq_show(struct seq_file *file, void *data)\r\n{\r\nlong gid = *(long *)data;\r\nint i;\r\nstruct gru_state *gru = GID_TO_GRU(gid);\r\nstruct gru_thread_state *ts;\r\nconst char *mode[] = { "??", "UPM", "INTR", "OS_POLL" };\r\nif (gid == 0)\r\nseq_printf(file, "#%5s%5s%6s%7s%9s%6s%8s%8s\n", "gid", "bid",\r\n"ctx#", "asid", "pid", "cbrs", "dsbytes", "mode");\r\nif (gru)\r\nfor (i = 0; i < GRU_NUM_CCH; i++) {\r\nts = gru->gs_gts[i];\r\nif (!ts)\r\ncontinue;\r\nseq_printf(file, " %5d%5d%6d%7d%9d%6d%8d%8s\n",\r\ngru->gs_gid, gru->gs_blade_id, i,\r\nis_kernel_context(ts) ? 0 : ts->ts_gms->ms_asids[gid].mt_asid,\r\nis_kernel_context(ts) ? 0 : ts->ts_tgid_owner,\r\nts->ts_cbr_au_count * GRU_CBR_AU_SIZE,\r\nts->ts_cbr_au_count * GRU_DSR_AU_BYTES,\r\nmode[ts->ts_user_options &\r\nGRU_OPT_MISS_MASK]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gru_seq_show(struct seq_file *file, void *data)\r\n{\r\nlong gid = *(long *)data, ctxfree, cbrfree, dsrfree;\r\nstruct gru_state *gru = GID_TO_GRU(gid);\r\nif (gid == 0) {\r\nseq_printf(file, "#%5s%5s%7s%6s%6s%8s%6s%6s\n", "gid", "nid",\r\n"ctx", "cbr", "dsr", "ctx", "cbr", "dsr");\r\nseq_printf(file, "#%5s%5s%7s%6s%6s%8s%6s%6s\n", "", "", "busy",\r\n"busy", "busy", "free", "free", "free");\r\n}\r\nif (gru) {\r\nctxfree = GRU_NUM_CCH - gru->gs_active_contexts;\r\ncbrfree = hweight64(gru->gs_cbr_map) * GRU_CBR_AU_SIZE;\r\ndsrfree = hweight64(gru->gs_dsr_map) * GRU_DSR_AU_BYTES;\r\nseq_printf(file, " %5d%5d%7ld%6ld%6ld%8ld%6ld%6ld\n",\r\ngru->gs_gid, gru->gs_blade_id, GRU_NUM_CCH - ctxfree,\r\nGRU_NUM_CBE - cbrfree, GRU_NUM_DSR_BYTES - dsrfree,\r\nctxfree, cbrfree, dsrfree);\r\n}\r\nreturn 0;\r\n}\r\nstatic void seq_stop(struct seq_file *file, void *data)\r\n{\r\n}\r\nstatic void *seq_start(struct seq_file *file, loff_t *gid)\r\n{\r\nif (*gid < gru_max_gids)\r\nreturn gid;\r\nreturn NULL;\r\n}\r\nstatic void *seq_next(struct seq_file *file, void *data, loff_t *gid)\r\n{\r\n(*gid)++;\r\nif (*gid < gru_max_gids)\r\nreturn gid;\r\nreturn NULL;\r\n}\r\nstatic int statistics_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, statistics_show, NULL);\r\n}\r\nstatic int mcs_statistics_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, mcs_statistics_show, NULL);\r\n}\r\nstatic int options_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, options_show, NULL);\r\n}\r\nstatic int cch_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &cch_seq_ops);\r\n}\r\nstatic int gru_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &gru_seq_ops);\r\n}\r\nstatic int create_proc_file(struct proc_entry *p)\r\n{\r\np->entry = proc_create(p->name, p->mode, proc_gru, p->fops);\r\nif (!p->entry)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void delete_proc_files(void)\r\n{\r\nstruct proc_entry *p;\r\nif (proc_gru) {\r\nfor (p = proc_files; p->name; p++)\r\nif (p->entry)\r\nremove_proc_entry(p->name, proc_gru);\r\nremove_proc_entry("gru", proc_gru->parent);\r\n}\r\n}\r\nint gru_proc_init(void)\r\n{\r\nstruct proc_entry *p;\r\nproc_gru = proc_mkdir("sgi_uv/gru", NULL);\r\nfor (p = proc_files; p->name; p++)\r\nif (create_proc_file(p))\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndelete_proc_files();\r\nreturn -1;\r\n}\r\nvoid gru_proc_exit(void)\r\n{\r\ndelete_proc_files();\r\n}
