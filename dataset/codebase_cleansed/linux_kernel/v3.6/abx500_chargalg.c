static void abx500_chargalg_safety_timer_expired(unsigned long data)\r\n{\r\nstruct abx500_chargalg *di = (struct abx500_chargalg *) data;\r\ndev_err(di->dev, "Safety timer expired\n");\r\ndi->events.safety_timer_expired = true;\r\nqueue_work(di->chargalg_wq, &di->chargalg_work);\r\n}\r\nstatic void abx500_chargalg_maintenance_timer_expired(unsigned long data)\r\n{\r\nstruct abx500_chargalg *di = (struct abx500_chargalg *) data;\r\ndev_dbg(di->dev, "Maintenance timer expired\n");\r\ndi->events.maintenance_timer_expired = true;\r\nqueue_work(di->chargalg_wq, &di->chargalg_work);\r\n}\r\nstatic void abx500_chargalg_state_to(struct abx500_chargalg *di,\r\nenum abx500_chargalg_states state)\r\n{\r\ndev_dbg(di->dev,\r\n"State changed: %s (From state: [%d] %s =to=> [%d] %s )\n",\r\ndi->charge_state == state ? "NO" : "YES",\r\ndi->charge_state,\r\nstates[di->charge_state],\r\nstate,\r\nstates[state]);\r\ndi->charge_state = state;\r\n}\r\nstatic int abx500_chargalg_check_charger_connection(struct abx500_chargalg *di)\r\n{\r\nif (di->chg_info.conn_chg != di->chg_info.prev_conn_chg ||\r\ndi->susp_status.suspended_change) {\r\nif ((di->chg_info.conn_chg & AC_CHG) &&\r\n!di->susp_status.ac_suspended) {\r\ndev_dbg(di->dev, "Charging source is AC\n");\r\nif (di->chg_info.charger_type != AC_CHG) {\r\ndi->chg_info.charger_type = AC_CHG;\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\n}\r\n} else if ((di->chg_info.conn_chg & USB_CHG) &&\r\n!di->susp_status.usb_suspended) {\r\ndev_dbg(di->dev, "Charging source is USB\n");\r\ndi->chg_info.charger_type = USB_CHG;\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\n} else if (di->chg_info.conn_chg &&\r\n(di->susp_status.ac_suspended ||\r\ndi->susp_status.usb_suspended)) {\r\ndev_dbg(di->dev, "Charging is suspended\n");\r\ndi->chg_info.charger_type = NO_CHG;\r\nabx500_chargalg_state_to(di, STATE_SUSPENDED_INIT);\r\n} else {\r\ndev_dbg(di->dev, "Charging source is OFF\n");\r\ndi->chg_info.charger_type = NO_CHG;\r\nabx500_chargalg_state_to(di, STATE_HANDHELD_INIT);\r\n}\r\ndi->chg_info.prev_conn_chg = di->chg_info.conn_chg;\r\ndi->susp_status.suspended_change = false;\r\n}\r\nreturn di->chg_info.conn_chg;\r\n}\r\nstatic void abx500_chargalg_start_safety_timer(struct abx500_chargalg *di)\r\n{\r\nunsigned long timer_expiration = 0;\r\nswitch (di->chg_info.charger_type) {\r\ncase AC_CHG:\r\ntimer_expiration =\r\nround_jiffies(jiffies +\r\n(di->bat->main_safety_tmr_h * 3600 * HZ));\r\nbreak;\r\ncase USB_CHG:\r\ntimer_expiration =\r\nround_jiffies(jiffies +\r\n(di->bat->usb_safety_tmr_h * 3600 * HZ));\r\nbreak;\r\ndefault:\r\ndev_err(di->dev, "Unknown charger to charge from\n");\r\nbreak;\r\n}\r\ndi->events.safety_timer_expired = false;\r\ndi->safety_timer.expires = timer_expiration;\r\nif (!timer_pending(&di->safety_timer))\r\nadd_timer(&di->safety_timer);\r\nelse\r\nmod_timer(&di->safety_timer, timer_expiration);\r\n}\r\nstatic void abx500_chargalg_stop_safety_timer(struct abx500_chargalg *di)\r\n{\r\ndi->events.safety_timer_expired = false;\r\ndel_timer(&di->safety_timer);\r\n}\r\nstatic void abx500_chargalg_start_maintenance_timer(struct abx500_chargalg *di,\r\nint duration)\r\n{\r\nunsigned long timer_expiration;\r\ntimer_expiration = round_jiffies(jiffies + (duration * 3600 * HZ));\r\ndi->events.maintenance_timer_expired = false;\r\ndi->maintenance_timer.expires = timer_expiration;\r\nif (!timer_pending(&di->maintenance_timer))\r\nadd_timer(&di->maintenance_timer);\r\nelse\r\nmod_timer(&di->maintenance_timer, timer_expiration);\r\n}\r\nstatic void abx500_chargalg_stop_maintenance_timer(struct abx500_chargalg *di)\r\n{\r\ndi->events.maintenance_timer_expired = false;\r\ndel_timer(&di->maintenance_timer);\r\n}\r\nstatic int abx500_chargalg_kick_watchdog(struct abx500_chargalg *di)\r\n{\r\nif (di->ac_chg && di->ac_chg->ops.kick_wd &&\r\ndi->chg_info.online_chg & AC_CHG)\r\nreturn di->ac_chg->ops.kick_wd(di->ac_chg);\r\nelse if (di->usb_chg && di->usb_chg->ops.kick_wd &&\r\ndi->chg_info.online_chg & USB_CHG)\r\nreturn di->usb_chg->ops.kick_wd(di->usb_chg);\r\nreturn -ENXIO;\r\n}\r\nstatic int abx500_chargalg_ac_en(struct abx500_chargalg *di, int enable,\r\nint vset, int iset)\r\n{\r\nif (!di->ac_chg || !di->ac_chg->ops.enable)\r\nreturn -ENXIO;\r\nif (di->ac_chg->max_out_volt)\r\nvset = min(vset, di->ac_chg->max_out_volt);\r\nif (di->ac_chg->max_out_curr)\r\niset = min(iset, di->ac_chg->max_out_curr);\r\ndi->chg_info.ac_iset = iset;\r\ndi->chg_info.ac_vset = vset;\r\nreturn di->ac_chg->ops.enable(di->ac_chg, enable, vset, iset);\r\n}\r\nstatic int abx500_chargalg_usb_en(struct abx500_chargalg *di, int enable,\r\nint vset, int iset)\r\n{\r\nif (!di->usb_chg || !di->usb_chg->ops.enable)\r\nreturn -ENXIO;\r\nif (di->usb_chg->max_out_volt)\r\nvset = min(vset, di->usb_chg->max_out_volt);\r\nif (di->usb_chg->max_out_curr)\r\niset = min(iset, di->usb_chg->max_out_curr);\r\ndi->chg_info.usb_iset = iset;\r\ndi->chg_info.usb_vset = vset;\r\nreturn di->usb_chg->ops.enable(di->usb_chg, enable, vset, iset);\r\n}\r\nstatic int abx500_chargalg_update_chg_curr(struct abx500_chargalg *di,\r\nint iset)\r\n{\r\nif (di->ac_chg && di->ac_chg->ops.update_curr &&\r\ndi->chg_info.charger_type & AC_CHG) {\r\nif (di->ac_chg->max_out_curr)\r\niset = min(iset, di->ac_chg->max_out_curr);\r\ndi->chg_info.ac_iset = iset;\r\nreturn di->ac_chg->ops.update_curr(di->ac_chg, iset);\r\n} else if (di->usb_chg && di->usb_chg->ops.update_curr &&\r\ndi->chg_info.charger_type & USB_CHG) {\r\nif (di->usb_chg->max_out_curr)\r\niset = min(iset, di->usb_chg->max_out_curr);\r\ndi->chg_info.usb_iset = iset;\r\nreturn di->usb_chg->ops.update_curr(di->usb_chg, iset);\r\n}\r\nreturn -ENXIO;\r\n}\r\nstatic void abx500_chargalg_stop_charging(struct abx500_chargalg *di)\r\n{\r\nabx500_chargalg_ac_en(di, false, 0, 0);\r\nabx500_chargalg_usb_en(di, false, 0, 0);\r\nabx500_chargalg_stop_safety_timer(di);\r\nabx500_chargalg_stop_maintenance_timer(di);\r\ndi->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\ndi->maintenance_chg = false;\r\ncancel_delayed_work(&di->chargalg_wd_work);\r\npower_supply_changed(&di->chargalg_psy);\r\n}\r\nstatic void abx500_chargalg_hold_charging(struct abx500_chargalg *di)\r\n{\r\nabx500_chargalg_ac_en(di, false, 0, 0);\r\nabx500_chargalg_usb_en(di, false, 0, 0);\r\nabx500_chargalg_stop_safety_timer(di);\r\nabx500_chargalg_stop_maintenance_timer(di);\r\ndi->charge_status = POWER_SUPPLY_STATUS_CHARGING;\r\ndi->maintenance_chg = false;\r\ncancel_delayed_work(&di->chargalg_wd_work);\r\npower_supply_changed(&di->chargalg_psy);\r\n}\r\nstatic void abx500_chargalg_start_charging(struct abx500_chargalg *di,\r\nint vset, int iset)\r\n{\r\nswitch (di->chg_info.charger_type) {\r\ncase AC_CHG:\r\ndev_dbg(di->dev,\r\n"AC parameters: Vset %d, Ich %d\n", vset, iset);\r\nabx500_chargalg_usb_en(di, false, 0, 0);\r\nabx500_chargalg_ac_en(di, true, vset, iset);\r\nbreak;\r\ncase USB_CHG:\r\ndev_dbg(di->dev,\r\n"USB parameters: Vset %d, Ich %d\n", vset, iset);\r\nabx500_chargalg_ac_en(di, false, 0, 0);\r\nabx500_chargalg_usb_en(di, true, vset, iset);\r\nbreak;\r\ndefault:\r\ndev_err(di->dev, "Unknown charger to charge from\n");\r\nbreak;\r\n}\r\n}\r\nstatic void abx500_chargalg_check_temp(struct abx500_chargalg *di)\r\n{\r\nif (di->batt_data.temp > (di->bat->temp_low + di->t_hyst_norm) &&\r\ndi->batt_data.temp < (di->bat->temp_high - di->t_hyst_norm)) {\r\ndi->events.btemp_underover = false;\r\ndi->events.btemp_lowhigh = false;\r\ndi->t_hyst_norm = 0;\r\ndi->t_hyst_lowhigh = 0;\r\n} else {\r\nif (((di->batt_data.temp >= di->bat->temp_high) &&\r\n(di->batt_data.temp <\r\n(di->bat->temp_over - di->t_hyst_lowhigh))) ||\r\n((di->batt_data.temp >\r\n(di->bat->temp_under + di->t_hyst_lowhigh)) &&\r\n(di->batt_data.temp <= di->bat->temp_low))) {\r\ndi->events.btemp_underover = false;\r\ndi->events.btemp_lowhigh = true;\r\ndi->t_hyst_norm = di->bat->temp_hysteresis;\r\ndi->t_hyst_lowhigh = 0;\r\n} else if (di->batt_data.temp <= di->bat->temp_under ||\r\ndi->batt_data.temp >= di->bat->temp_over) {\r\ndi->events.btemp_underover = true;\r\ndi->events.btemp_lowhigh = false;\r\ndi->t_hyst_norm = 0;\r\ndi->t_hyst_lowhigh = di->bat->temp_hysteresis;\r\n} else {\r\ndev_dbg(di->dev, "Within hysteresis limit temp: %d "\r\n"hyst_lowhigh %d, hyst normal %d\n",\r\ndi->batt_data.temp, di->t_hyst_lowhigh,\r\ndi->t_hyst_norm);\r\n}\r\n}\r\n}\r\nstatic void abx500_chargalg_check_charger_voltage(struct abx500_chargalg *di)\r\n{\r\nif (di->chg_info.usb_volt > di->bat->chg_params->usb_volt_max)\r\ndi->chg_info.usb_chg_ok = false;\r\nelse\r\ndi->chg_info.usb_chg_ok = true;\r\nif (di->chg_info.ac_volt > di->bat->chg_params->ac_volt_max)\r\ndi->chg_info.ac_chg_ok = false;\r\nelse\r\ndi->chg_info.ac_chg_ok = true;\r\n}\r\nstatic void abx500_chargalg_end_of_charge(struct abx500_chargalg *di)\r\n{\r\nif (di->charge_status == POWER_SUPPLY_STATUS_CHARGING &&\r\ndi->charge_state == STATE_NORMAL &&\r\n!di->maintenance_chg && (di->batt_data.volt >=\r\ndi->bat->bat_type[di->bat->batt_id].termination_vol ||\r\ndi->events.usb_cv_active || di->events.ac_cv_active) &&\r\ndi->batt_data.avg_curr <\r\ndi->bat->bat_type[di->bat->batt_id].termination_curr &&\r\ndi->batt_data.avg_curr > 0) {\r\nif (++di->eoc_cnt >= EOC_COND_CNT) {\r\ndi->eoc_cnt = 0;\r\ndi->charge_status = POWER_SUPPLY_STATUS_FULL;\r\ndi->maintenance_chg = true;\r\ndev_dbg(di->dev, "EOC reached!\n");\r\npower_supply_changed(&di->chargalg_psy);\r\n} else {\r\ndev_dbg(di->dev,\r\n" EOC limit reached for the %d"\r\n" time, out of %d before EOC\n",\r\ndi->eoc_cnt,\r\nEOC_COND_CNT);\r\n}\r\n} else {\r\ndi->eoc_cnt = 0;\r\n}\r\n}\r\nstatic void init_maxim_chg_curr(struct abx500_chargalg *di)\r\n{\r\ndi->ccm.original_iset =\r\ndi->bat->bat_type[di->bat->batt_id].normal_cur_lvl;\r\ndi->ccm.current_iset =\r\ndi->bat->bat_type[di->bat->batt_id].normal_cur_lvl;\r\ndi->ccm.test_delta_i = di->bat->maxi->charger_curr_step;\r\ndi->ccm.max_current = di->bat->maxi->chg_curr;\r\ndi->ccm.condition_cnt = di->bat->maxi->wait_cycles;\r\ndi->ccm.level = 0;\r\n}\r\nstatic enum maxim_ret abx500_chargalg_chg_curr_maxim(struct abx500_chargalg *di)\r\n{\r\nint delta_i;\r\nif (!di->bat->maxi->ena_maxi)\r\nreturn MAXIM_RET_NOACTION;\r\ndelta_i = di->ccm.original_iset - di->batt_data.inst_curr;\r\nif (di->events.vbus_collapsed) {\r\ndev_dbg(di->dev, "Charger voltage has collapsed %d\n",\r\ndi->ccm.wait_cnt);\r\nif (di->ccm.wait_cnt == 0) {\r\ndev_dbg(di->dev, "lowering current\n");\r\ndi->ccm.wait_cnt++;\r\ndi->ccm.condition_cnt = di->bat->maxi->wait_cycles;\r\ndi->ccm.max_current =\r\ndi->ccm.current_iset - di->ccm.test_delta_i;\r\ndi->ccm.current_iset = di->ccm.max_current;\r\ndi->ccm.level--;\r\nreturn MAXIM_RET_CHANGE;\r\n} else {\r\ndev_dbg(di->dev, "waiting\n");\r\ndi->ccm.wait_cnt = (di->ccm.wait_cnt + 1) % 3;\r\nreturn MAXIM_RET_NOACTION;\r\n}\r\n}\r\ndi->ccm.wait_cnt = 0;\r\nif ((di->batt_data.inst_curr > di->ccm.original_iset)) {\r\ndev_dbg(di->dev, " Maximization Ibat (%dmA) too high"\r\n" (limit %dmA) (current iset: %dmA)!\n",\r\ndi->batt_data.inst_curr, di->ccm.original_iset,\r\ndi->ccm.current_iset);\r\nif (di->ccm.current_iset == di->ccm.original_iset)\r\nreturn MAXIM_RET_NOACTION;\r\ndi->ccm.condition_cnt = di->bat->maxi->wait_cycles;\r\ndi->ccm.current_iset = di->ccm.original_iset;\r\ndi->ccm.level = 0;\r\nreturn MAXIM_RET_IBAT_TOO_HIGH;\r\n}\r\nif (delta_i > di->ccm.test_delta_i &&\r\n(di->ccm.current_iset + di->ccm.test_delta_i) <\r\ndi->ccm.max_current) {\r\nif (di->ccm.condition_cnt-- == 0) {\r\ndi->ccm.condition_cnt = di->bat->maxi->wait_cycles;\r\ndi->ccm.current_iset += di->ccm.test_delta_i;\r\ndi->ccm.level++;\r\ndev_dbg(di->dev, " Maximization needed, increase"\r\n" with %d mA to %dmA (Optimal ibat: %d)"\r\n" Level %d\n",\r\ndi->ccm.test_delta_i,\r\ndi->ccm.current_iset,\r\ndi->ccm.original_iset,\r\ndi->ccm.level);\r\nreturn MAXIM_RET_CHANGE;\r\n} else {\r\nreturn MAXIM_RET_NOACTION;\r\n}\r\n} else {\r\ndi->ccm.condition_cnt = di->bat->maxi->wait_cycles;\r\nreturn MAXIM_RET_NOACTION;\r\n}\r\n}\r\nstatic void handle_maxim_chg_curr(struct abx500_chargalg *di)\r\n{\r\nenum maxim_ret ret;\r\nint result;\r\nret = abx500_chargalg_chg_curr_maxim(di);\r\nswitch (ret) {\r\ncase MAXIM_RET_CHANGE:\r\nresult = abx500_chargalg_update_chg_curr(di,\r\ndi->ccm.current_iset);\r\nif (result)\r\ndev_err(di->dev, "failed to set chg curr\n");\r\nbreak;\r\ncase MAXIM_RET_IBAT_TOO_HIGH:\r\nresult = abx500_chargalg_update_chg_curr(di,\r\ndi->bat->bat_type[di->bat->batt_id].normal_cur_lvl);\r\nif (result)\r\ndev_err(di->dev, "failed to set chg curr\n");\r\nbreak;\r\ncase MAXIM_RET_NOACTION:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int abx500_chargalg_get_ext_psy_data(struct device *dev, void *data)\r\n{\r\nstruct power_supply *psy;\r\nstruct power_supply *ext;\r\nstruct abx500_chargalg *di;\r\nunion power_supply_propval ret;\r\nint i, j;\r\nbool psy_found = false;\r\npsy = (struct power_supply *)data;\r\next = dev_get_drvdata(dev);\r\ndi = to_abx500_chargalg_device_info(psy);\r\nfor (i = 0; i < ext->num_supplicants; i++) {\r\nif (!strcmp(ext->supplied_to[i], psy->name))\r\npsy_found = true;\r\n}\r\nif (!psy_found)\r\nreturn 0;\r\nfor (j = 0; j < ext->num_properties; j++) {\r\nenum power_supply_property prop;\r\nprop = ext->properties[j];\r\nif (!di->ac_chg &&\r\next->type == POWER_SUPPLY_TYPE_MAINS)\r\ndi->ac_chg = psy_to_ux500_charger(ext);\r\nelse if (!di->usb_chg &&\r\next->type == POWER_SUPPLY_TYPE_USB)\r\ndi->usb_chg = psy_to_ux500_charger(ext);\r\nif (ext->get_property(ext, prop, &ret))\r\ncontinue;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nif (ret.intval)\r\ndi->events.batt_rem = false;\r\nelse\r\ndi->events.batt_rem = true;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_MAINS:\r\nif (!ret.intval &&\r\n(di->chg_info.conn_chg & AC_CHG)) {\r\ndi->chg_info.prev_conn_chg =\r\ndi->chg_info.conn_chg;\r\ndi->chg_info.conn_chg &= ~AC_CHG;\r\n}\r\nelse if (ret.intval &&\r\n!(di->chg_info.conn_chg & AC_CHG)) {\r\ndi->chg_info.prev_conn_chg =\r\ndi->chg_info.conn_chg;\r\ndi->chg_info.conn_chg |= AC_CHG;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB:\r\nif (!ret.intval &&\r\n(di->chg_info.conn_chg & USB_CHG)) {\r\ndi->chg_info.prev_conn_chg =\r\ndi->chg_info.conn_chg;\r\ndi->chg_info.conn_chg &= ~USB_CHG;\r\n}\r\nelse if (ret.intval &&\r\n!(di->chg_info.conn_chg & USB_CHG)) {\r\ndi->chg_info.prev_conn_chg =\r\ndi->chg_info.conn_chg;\r\ndi->chg_info.conn_chg |= USB_CHG;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_MAINS:\r\nif (!ret.intval &&\r\n(di->chg_info.online_chg & AC_CHG)) {\r\ndi->chg_info.prev_online_chg =\r\ndi->chg_info.online_chg;\r\ndi->chg_info.online_chg &= ~AC_CHG;\r\n}\r\nelse if (ret.intval &&\r\n!(di->chg_info.online_chg & AC_CHG)) {\r\ndi->chg_info.prev_online_chg =\r\ndi->chg_info.online_chg;\r\ndi->chg_info.online_chg |= AC_CHG;\r\nqueue_delayed_work(di->chargalg_wq,\r\n&di->chargalg_wd_work, 0);\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB:\r\nif (!ret.intval &&\r\n(di->chg_info.online_chg & USB_CHG)) {\r\ndi->chg_info.prev_online_chg =\r\ndi->chg_info.online_chg;\r\ndi->chg_info.online_chg &= ~USB_CHG;\r\n}\r\nelse if (ret.intval &&\r\n!(di->chg_info.online_chg & USB_CHG)) {\r\ndi->chg_info.prev_online_chg =\r\ndi->chg_info.online_chg;\r\ndi->chg_info.online_chg |= USB_CHG;\r\nqueue_delayed_work(di->chargalg_wq,\r\n&di->chargalg_wd_work, 0);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_MAINS:\r\nswitch (ret.intval) {\r\ncase POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:\r\ndi->events.mainextchnotok = true;\r\ndi->events.main_thermal_prot = false;\r\ndi->events.main_ovv = false;\r\ndi->events.ac_wd_expired = false;\r\nbreak;\r\ncase POWER_SUPPLY_HEALTH_DEAD:\r\ndi->events.ac_wd_expired = true;\r\ndi->events.mainextchnotok = false;\r\ndi->events.main_ovv = false;\r\ndi->events.main_thermal_prot = false;\r\nbreak;\r\ncase POWER_SUPPLY_HEALTH_COLD:\r\ncase POWER_SUPPLY_HEALTH_OVERHEAT:\r\ndi->events.main_thermal_prot = true;\r\ndi->events.mainextchnotok = false;\r\ndi->events.main_ovv = false;\r\ndi->events.ac_wd_expired = false;\r\nbreak;\r\ncase POWER_SUPPLY_HEALTH_OVERVOLTAGE:\r\ndi->events.main_ovv = true;\r\ndi->events.mainextchnotok = false;\r\ndi->events.main_thermal_prot = false;\r\ndi->events.ac_wd_expired = false;\r\nbreak;\r\ncase POWER_SUPPLY_HEALTH_GOOD:\r\ndi->events.main_thermal_prot = false;\r\ndi->events.mainextchnotok = false;\r\ndi->events.main_ovv = false;\r\ndi->events.ac_wd_expired = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB:\r\nswitch (ret.intval) {\r\ncase POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:\r\ndi->events.usbchargernotok = true;\r\ndi->events.usb_thermal_prot = false;\r\ndi->events.vbus_ovv = false;\r\ndi->events.usb_wd_expired = false;\r\nbreak;\r\ncase POWER_SUPPLY_HEALTH_DEAD:\r\ndi->events.usb_wd_expired = true;\r\ndi->events.usbchargernotok = false;\r\ndi->events.usb_thermal_prot = false;\r\ndi->events.vbus_ovv = false;\r\nbreak;\r\ncase POWER_SUPPLY_HEALTH_COLD:\r\ncase POWER_SUPPLY_HEALTH_OVERHEAT:\r\ndi->events.usb_thermal_prot = true;\r\ndi->events.usbchargernotok = false;\r\ndi->events.vbus_ovv = false;\r\ndi->events.usb_wd_expired = false;\r\nbreak;\r\ncase POWER_SUPPLY_HEALTH_OVERVOLTAGE:\r\ndi->events.vbus_ovv = true;\r\ndi->events.usbchargernotok = false;\r\ndi->events.usb_thermal_prot = false;\r\ndi->events.usb_wd_expired = false;\r\nbreak;\r\ncase POWER_SUPPLY_HEALTH_GOOD:\r\ndi->events.usbchargernotok = false;\r\ndi->events.usb_thermal_prot = false;\r\ndi->events.vbus_ovv = false;\r\ndi->events.usb_wd_expired = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\ndi->batt_data.volt = ret.intval / 1000;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_MAINS:\r\ndi->chg_info.ac_volt = ret.intval / 1000;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB:\r\ndi->chg_info.usb_volt = ret.intval / 1000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_MAINS:\r\nif (ret.intval)\r\ndi->events.ac_cv_active = true;\r\nelse\r\ndi->events.ac_cv_active = false;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB:\r\nif (ret.intval)\r\ndi->events.usb_cv_active = true;\r\nelse\r\ndi->events.usb_cv_active = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nif (ret.intval)\r\ndi->events.batt_unknown = false;\r\nelse\r\ndi->events.batt_unknown = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\ndi->batt_data.temp = ret.intval / 10;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_MAINS:\r\ndi->chg_info.ac_curr =\r\nret.intval / 1000;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB:\r\ndi->chg_info.usb_curr =\r\nret.intval / 1000;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\ndi->batt_data.inst_curr = ret.intval / 1000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\ndi->batt_data.avg_curr = ret.intval / 1000;\r\nbreak;\r\ncase POWER_SUPPLY_TYPE_USB:\r\nif (ret.intval)\r\ndi->events.vbus_collapsed = true;\r\nelse\r\ndi->events.vbus_collapsed = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\ndi->batt_data.percent = ret.intval;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void abx500_chargalg_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct abx500_chargalg *di = to_abx500_chargalg_device_info(psy);\r\nqueue_work(di->chargalg_wq, &di->chargalg_work);\r\n}\r\nstatic void abx500_chargalg_algorithm(struct abx500_chargalg *di)\r\n{\r\nint charger_status;\r\nclass_for_each_device(power_supply_class, NULL,\r\n&di->chargalg_psy, abx500_chargalg_get_ext_psy_data);\r\nabx500_chargalg_end_of_charge(di);\r\nabx500_chargalg_check_temp(di);\r\nabx500_chargalg_check_charger_voltage(di);\r\ncharger_status = abx500_chargalg_check_charger_connection(di);\r\nif (!charger_status ||\r\n(di->events.batt_unknown && !di->bat->chg_unknown_bat)) {\r\nif (di->charge_state != STATE_HANDHELD) {\r\ndi->events.safety_timer_expired = false;\r\nabx500_chargalg_state_to(di, STATE_HANDHELD_INIT);\r\n}\r\n}\r\nelse if (di->charge_state == STATE_SUSPENDED_INIT ||\r\ndi->charge_state == STATE_SUSPENDED) {\r\n}\r\nelse if (di->events.safety_timer_expired) {\r\nif (di->charge_state != STATE_SAFETY_TIMER_EXPIRED)\r\nabx500_chargalg_state_to(di,\r\nSTATE_SAFETY_TIMER_EXPIRED_INIT);\r\n}\r\nelse if (di->events.batt_rem) {\r\nif (di->charge_state != STATE_BATT_REMOVED)\r\nabx500_chargalg_state_to(di, STATE_BATT_REMOVED_INIT);\r\n}\r\nelse if (di->events.mainextchnotok || di->events.usbchargernotok) {\r\nif (di->charge_state != STATE_CHG_NOT_OK &&\r\n!di->events.vbus_collapsed)\r\nabx500_chargalg_state_to(di, STATE_CHG_NOT_OK_INIT);\r\n}\r\nelse if (di->events.vbus_ovv ||\r\ndi->events.main_ovv ||\r\ndi->events.batt_ovv ||\r\n!di->chg_info.usb_chg_ok ||\r\n!di->chg_info.ac_chg_ok) {\r\nif (di->charge_state != STATE_OVV_PROTECT)\r\nabx500_chargalg_state_to(di, STATE_OVV_PROTECT_INIT);\r\n}\r\nelse if (di->events.main_thermal_prot ||\r\ndi->events.usb_thermal_prot) {\r\nif (di->charge_state != STATE_HW_TEMP_PROTECT)\r\nabx500_chargalg_state_to(di,\r\nSTATE_HW_TEMP_PROTECT_INIT);\r\n}\r\nelse if (di->events.btemp_underover) {\r\nif (di->charge_state != STATE_TEMP_UNDEROVER)\r\nabx500_chargalg_state_to(di,\r\nSTATE_TEMP_UNDEROVER_INIT);\r\n}\r\nelse if (di->events.ac_wd_expired ||\r\ndi->events.usb_wd_expired) {\r\nif (di->charge_state != STATE_WD_EXPIRED)\r\nabx500_chargalg_state_to(di, STATE_WD_EXPIRED_INIT);\r\n}\r\nelse if (di->events.btemp_lowhigh) {\r\nif (di->charge_state != STATE_TEMP_LOWHIGH)\r\nabx500_chargalg_state_to(di, STATE_TEMP_LOWHIGH_INIT);\r\n}\r\ndev_dbg(di->dev,\r\n"[CHARGALG] Vb %d Ib_avg %d Ib_inst %d Tb %d Cap %d Maint %d "\r\n"State %s Active_chg %d Chg_status %d AC %d USB %d "\r\n"AC_online %d USB_online %d AC_CV %d USB_CV %d AC_I %d "\r\n"USB_I %d AC_Vset %d AC_Iset %d USB_Vset %d USB_Iset %d\n",\r\ndi->batt_data.volt,\r\ndi->batt_data.avg_curr,\r\ndi->batt_data.inst_curr,\r\ndi->batt_data.temp,\r\ndi->batt_data.percent,\r\ndi->maintenance_chg,\r\nstates[di->charge_state],\r\ndi->chg_info.charger_type,\r\ndi->charge_status,\r\ndi->chg_info.conn_chg & AC_CHG,\r\ndi->chg_info.conn_chg & USB_CHG,\r\ndi->chg_info.online_chg & AC_CHG,\r\ndi->chg_info.online_chg & USB_CHG,\r\ndi->events.ac_cv_active,\r\ndi->events.usb_cv_active,\r\ndi->chg_info.ac_curr,\r\ndi->chg_info.usb_curr,\r\ndi->chg_info.ac_vset,\r\ndi->chg_info.ac_iset,\r\ndi->chg_info.usb_vset,\r\ndi->chg_info.usb_iset);\r\nswitch (di->charge_state) {\r\ncase STATE_HANDHELD_INIT:\r\nabx500_chargalg_stop_charging(di);\r\ndi->charge_status = POWER_SUPPLY_STATUS_DISCHARGING;\r\nabx500_chargalg_state_to(di, STATE_HANDHELD);\r\ncase STATE_HANDHELD:\r\nbreak;\r\ncase STATE_SUSPENDED_INIT:\r\nif (di->susp_status.ac_suspended)\r\nabx500_chargalg_ac_en(di, false, 0, 0);\r\nif (di->susp_status.usb_suspended)\r\nabx500_chargalg_usb_en(di, false, 0, 0);\r\nabx500_chargalg_stop_safety_timer(di);\r\nabx500_chargalg_stop_maintenance_timer(di);\r\ndi->charge_status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\ndi->maintenance_chg = false;\r\nabx500_chargalg_state_to(di, STATE_SUSPENDED);\r\npower_supply_changed(&di->chargalg_psy);\r\ncase STATE_SUSPENDED:\r\nbreak;\r\ncase STATE_BATT_REMOVED_INIT:\r\nabx500_chargalg_stop_charging(di);\r\nabx500_chargalg_state_to(di, STATE_BATT_REMOVED);\r\ncase STATE_BATT_REMOVED:\r\nif (!di->events.batt_rem)\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\nbreak;\r\ncase STATE_HW_TEMP_PROTECT_INIT:\r\nabx500_chargalg_stop_charging(di);\r\nabx500_chargalg_state_to(di, STATE_HW_TEMP_PROTECT);\r\ncase STATE_HW_TEMP_PROTECT:\r\nif (!di->events.main_thermal_prot &&\r\n!di->events.usb_thermal_prot)\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\nbreak;\r\ncase STATE_OVV_PROTECT_INIT:\r\nabx500_chargalg_stop_charging(di);\r\nabx500_chargalg_state_to(di, STATE_OVV_PROTECT);\r\ncase STATE_OVV_PROTECT:\r\nif (!di->events.vbus_ovv &&\r\n!di->events.main_ovv &&\r\n!di->events.batt_ovv &&\r\ndi->chg_info.usb_chg_ok &&\r\ndi->chg_info.ac_chg_ok)\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\nbreak;\r\ncase STATE_CHG_NOT_OK_INIT:\r\nabx500_chargalg_stop_charging(di);\r\nabx500_chargalg_state_to(di, STATE_CHG_NOT_OK);\r\ncase STATE_CHG_NOT_OK:\r\nif (!di->events.mainextchnotok &&\r\n!di->events.usbchargernotok)\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\nbreak;\r\ncase STATE_SAFETY_TIMER_EXPIRED_INIT:\r\nabx500_chargalg_stop_charging(di);\r\nabx500_chargalg_state_to(di, STATE_SAFETY_TIMER_EXPIRED);\r\ncase STATE_SAFETY_TIMER_EXPIRED:\r\nbreak;\r\ncase STATE_NORMAL_INIT:\r\nabx500_chargalg_start_charging(di,\r\ndi->bat->bat_type[di->bat->batt_id].normal_vol_lvl,\r\ndi->bat->bat_type[di->bat->batt_id].normal_cur_lvl);\r\nabx500_chargalg_state_to(di, STATE_NORMAL);\r\nabx500_chargalg_start_safety_timer(di);\r\nabx500_chargalg_stop_maintenance_timer(di);\r\ninit_maxim_chg_curr(di);\r\ndi->charge_status = POWER_SUPPLY_STATUS_CHARGING;\r\ndi->eoc_cnt = 0;\r\ndi->maintenance_chg = false;\r\npower_supply_changed(&di->chargalg_psy);\r\nbreak;\r\ncase STATE_NORMAL:\r\nhandle_maxim_chg_curr(di);\r\nif (di->charge_status == POWER_SUPPLY_STATUS_FULL &&\r\ndi->maintenance_chg) {\r\nif (di->bat->no_maintenance)\r\nabx500_chargalg_state_to(di,\r\nSTATE_WAIT_FOR_RECHARGE_INIT);\r\nelse\r\nabx500_chargalg_state_to(di,\r\nSTATE_MAINTENANCE_A_INIT);\r\n}\r\nbreak;\r\ncase STATE_WAIT_FOR_RECHARGE_INIT:\r\nabx500_chargalg_hold_charging(di);\r\nabx500_chargalg_state_to(di, STATE_WAIT_FOR_RECHARGE);\r\ndi->rch_cnt = RCH_COND_CNT;\r\ncase STATE_WAIT_FOR_RECHARGE:\r\nif (di->batt_data.volt <=\r\ndi->bat->bat_type[di->bat->batt_id].recharge_vol) {\r\nif (di->rch_cnt-- == 0)\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\n} else\r\ndi->rch_cnt = RCH_COND_CNT;\r\nbreak;\r\ncase STATE_MAINTENANCE_A_INIT:\r\nabx500_chargalg_stop_safety_timer(di);\r\nabx500_chargalg_start_maintenance_timer(di,\r\ndi->bat->bat_type[\r\ndi->bat->batt_id].maint_a_chg_timer_h);\r\nabx500_chargalg_start_charging(di,\r\ndi->bat->bat_type[\r\ndi->bat->batt_id].maint_a_vol_lvl,\r\ndi->bat->bat_type[\r\ndi->bat->batt_id].maint_a_cur_lvl);\r\nabx500_chargalg_state_to(di, STATE_MAINTENANCE_A);\r\npower_supply_changed(&di->chargalg_psy);\r\ncase STATE_MAINTENANCE_A:\r\nif (di->events.maintenance_timer_expired) {\r\nabx500_chargalg_stop_maintenance_timer(di);\r\nabx500_chargalg_state_to(di, STATE_MAINTENANCE_B_INIT);\r\n}\r\nbreak;\r\ncase STATE_MAINTENANCE_B_INIT:\r\nabx500_chargalg_start_maintenance_timer(di,\r\ndi->bat->bat_type[\r\ndi->bat->batt_id].maint_b_chg_timer_h);\r\nabx500_chargalg_start_charging(di,\r\ndi->bat->bat_type[\r\ndi->bat->batt_id].maint_b_vol_lvl,\r\ndi->bat->bat_type[\r\ndi->bat->batt_id].maint_b_cur_lvl);\r\nabx500_chargalg_state_to(di, STATE_MAINTENANCE_B);\r\npower_supply_changed(&di->chargalg_psy);\r\ncase STATE_MAINTENANCE_B:\r\nif (di->events.maintenance_timer_expired) {\r\nabx500_chargalg_stop_maintenance_timer(di);\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\n}\r\nbreak;\r\ncase STATE_TEMP_LOWHIGH_INIT:\r\nabx500_chargalg_start_charging(di,\r\ndi->bat->bat_type[\r\ndi->bat->batt_id].low_high_vol_lvl,\r\ndi->bat->bat_type[\r\ndi->bat->batt_id].low_high_cur_lvl);\r\nabx500_chargalg_stop_maintenance_timer(di);\r\ndi->charge_status = POWER_SUPPLY_STATUS_CHARGING;\r\nabx500_chargalg_state_to(di, STATE_TEMP_LOWHIGH);\r\npower_supply_changed(&di->chargalg_psy);\r\ncase STATE_TEMP_LOWHIGH:\r\nif (!di->events.btemp_lowhigh)\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\nbreak;\r\ncase STATE_WD_EXPIRED_INIT:\r\nabx500_chargalg_stop_charging(di);\r\nabx500_chargalg_state_to(di, STATE_WD_EXPIRED);\r\ncase STATE_WD_EXPIRED:\r\nif (!di->events.ac_wd_expired &&\r\n!di->events.usb_wd_expired)\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\nbreak;\r\ncase STATE_TEMP_UNDEROVER_INIT:\r\nabx500_chargalg_stop_charging(di);\r\nabx500_chargalg_state_to(di, STATE_TEMP_UNDEROVER);\r\ncase STATE_TEMP_UNDEROVER:\r\nif (!di->events.btemp_underover)\r\nabx500_chargalg_state_to(di, STATE_NORMAL_INIT);\r\nbreak;\r\n}\r\nif (di->charge_state == STATE_NORMAL_INIT ||\r\ndi->charge_state == STATE_MAINTENANCE_A_INIT ||\r\ndi->charge_state == STATE_MAINTENANCE_B_INIT)\r\nqueue_work(di->chargalg_wq, &di->chargalg_work);\r\n}\r\nstatic void abx500_chargalg_periodic_work(struct work_struct *work)\r\n{\r\nstruct abx500_chargalg *di = container_of(work,\r\nstruct abx500_chargalg, chargalg_periodic_work.work);\r\nabx500_chargalg_algorithm(di);\r\nif (di->chg_info.conn_chg)\r\nqueue_delayed_work(di->chargalg_wq,\r\n&di->chargalg_periodic_work,\r\ndi->bat->interval_charging * HZ);\r\nelse\r\nqueue_delayed_work(di->chargalg_wq,\r\n&di->chargalg_periodic_work,\r\ndi->bat->interval_not_charging * HZ);\r\n}\r\nstatic void abx500_chargalg_wd_work(struct work_struct *work)\r\n{\r\nint ret;\r\nstruct abx500_chargalg *di = container_of(work,\r\nstruct abx500_chargalg, chargalg_wd_work.work);\r\ndev_dbg(di->dev, "abx500_chargalg_wd_work\n");\r\nret = abx500_chargalg_kick_watchdog(di);\r\nif (ret < 0)\r\ndev_err(di->dev, "failed to kick watchdog\n");\r\nqueue_delayed_work(di->chargalg_wq,\r\n&di->chargalg_wd_work, CHG_WD_INTERVAL);\r\n}\r\nstatic void abx500_chargalg_work(struct work_struct *work)\r\n{\r\nstruct abx500_chargalg *di = container_of(work,\r\nstruct abx500_chargalg, chargalg_work);\r\nabx500_chargalg_algorithm(di);\r\n}\r\nstatic int abx500_chargalg_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct abx500_chargalg *di;\r\ndi = to_abx500_chargalg_device_info(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = di->charge_status;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (di->events.batt_ovv) {\r\nval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\n} else if (di->events.btemp_underover) {\r\nif (di->batt_data.temp <= di->bat->temp_under)\r\nval->intval = POWER_SUPPLY_HEALTH_COLD;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\n} else {\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t abx500_chargalg_sysfs_charger(struct kobject *kobj,\r\nstruct attribute *attr, const char *buf, size_t length)\r\n{\r\nstruct abx500_chargalg *di = container_of(kobj,\r\nstruct abx500_chargalg, chargalg_kobject);\r\nlong int param;\r\nint ac_usb;\r\nint ret;\r\nchar entry = *attr->name;\r\nswitch (entry) {\r\ncase 'c':\r\nret = strict_strtol(buf, 10, &param);\r\nif (ret < 0)\r\nreturn ret;\r\nac_usb = param;\r\nswitch (ac_usb) {\r\ncase 0:\r\ndi->susp_status.ac_suspended = true;\r\ndi->susp_status.usb_suspended = true;\r\ndi->susp_status.suspended_change = true;\r\nqueue_work(di->chargalg_wq,\r\n&di->chargalg_work);\r\nbreak;\r\ncase 1:\r\ndi->susp_status.ac_suspended = false;\r\ndi->susp_status.suspended_change = true;\r\nqueue_work(di->chargalg_wq,\r\n&di->chargalg_work);\r\nbreak;\r\ncase 2:\r\ndi->susp_status.usb_suspended = false;\r\ndi->susp_status.suspended_change = true;\r\nqueue_work(di->chargalg_wq,\r\n&di->chargalg_work);\r\nbreak;\r\ndefault:\r\ndev_info(di->dev, "Wrong input\n"\r\n"Enter 0. Disable AC/USB Charging\n"\r\n"1. Enable AC charging\n"\r\n"2. Enable USB Charging\n");\r\n};\r\nbreak;\r\n};\r\nreturn strlen(buf);\r\n}\r\nstatic void abx500_chargalg_sysfs_exit(struct abx500_chargalg *di)\r\n{\r\nkobject_del(&di->chargalg_kobject);\r\n}\r\nstatic int abx500_chargalg_sysfs_init(struct abx500_chargalg *di)\r\n{\r\nint ret = 0;\r\nret = kobject_init_and_add(&di->chargalg_kobject,\r\n&abx500_chargalg_ktype,\r\nNULL, "abx500_chargalg");\r\nif (ret < 0)\r\ndev_err(di->dev, "failed to create sysfs entry\n");\r\nreturn ret;\r\n}\r\nstatic int abx500_chargalg_resume(struct platform_device *pdev)\r\n{\r\nstruct abx500_chargalg *di = platform_get_drvdata(pdev);\r\nif (di->chg_info.online_chg)\r\nqueue_delayed_work(di->chargalg_wq, &di->chargalg_wd_work, 0);\r\nqueue_delayed_work(di->chargalg_wq, &di->chargalg_periodic_work, 0);\r\nreturn 0;\r\n}\r\nstatic int abx500_chargalg_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct abx500_chargalg *di = platform_get_drvdata(pdev);\r\nif (di->chg_info.online_chg)\r\ncancel_delayed_work_sync(&di->chargalg_wd_work);\r\ncancel_delayed_work_sync(&di->chargalg_periodic_work);\r\nreturn 0;\r\n}\r\nstatic int __devexit abx500_chargalg_remove(struct platform_device *pdev)\r\n{\r\nstruct abx500_chargalg *di = platform_get_drvdata(pdev);\r\nabx500_chargalg_sysfs_exit(di);\r\ndestroy_workqueue(di->chargalg_wq);\r\nflush_scheduled_work();\r\npower_supply_unregister(&di->chargalg_psy);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(di);\r\nreturn 0;\r\n}\r\nstatic int __devinit abx500_chargalg_probe(struct platform_device *pdev)\r\n{\r\nstruct abx500_bm_plat_data *plat_data;\r\nint ret = 0;\r\nstruct abx500_chargalg *di =\r\nkzalloc(sizeof(struct abx500_chargalg), GFP_KERNEL);\r\nif (!di)\r\nreturn -ENOMEM;\r\ndi->dev = &pdev->dev;\r\nplat_data = pdev->dev.platform_data;\r\ndi->pdata = plat_data->chargalg;\r\ndi->bat = plat_data->battery;\r\ndi->chargalg_psy.name = "abx500_chargalg";\r\ndi->chargalg_psy.type = POWER_SUPPLY_TYPE_BATTERY;\r\ndi->chargalg_psy.properties = abx500_chargalg_props;\r\ndi->chargalg_psy.num_properties = ARRAY_SIZE(abx500_chargalg_props);\r\ndi->chargalg_psy.get_property = abx500_chargalg_get_property;\r\ndi->chargalg_psy.supplied_to = di->pdata->supplied_to;\r\ndi->chargalg_psy.num_supplicants = di->pdata->num_supplicants;\r\ndi->chargalg_psy.external_power_changed =\r\nabx500_chargalg_external_power_changed;\r\ninit_timer(&di->safety_timer);\r\ndi->safety_timer.function = abx500_chargalg_safety_timer_expired;\r\ndi->safety_timer.data = (unsigned long) di;\r\ninit_timer(&di->maintenance_timer);\r\ndi->maintenance_timer.function =\r\nabx500_chargalg_maintenance_timer_expired;\r\ndi->maintenance_timer.data = (unsigned long) di;\r\ndi->chargalg_wq =\r\ncreate_singlethread_workqueue("abx500_chargalg_wq");\r\nif (di->chargalg_wq == NULL) {\r\ndev_err(di->dev, "failed to create work queue\n");\r\ngoto free_device_info;\r\n}\r\nINIT_DELAYED_WORK_DEFERRABLE(&di->chargalg_periodic_work,\r\nabx500_chargalg_periodic_work);\r\nINIT_DELAYED_WORK_DEFERRABLE(&di->chargalg_wd_work,\r\nabx500_chargalg_wd_work);\r\nINIT_WORK(&di->chargalg_work, abx500_chargalg_work);\r\ndi->chg_info.prev_conn_chg = -1;\r\nret = power_supply_register(di->dev, &di->chargalg_psy);\r\nif (ret) {\r\ndev_err(di->dev, "failed to register chargalg psy\n");\r\ngoto free_chargalg_wq;\r\n}\r\nplatform_set_drvdata(pdev, di);\r\nret = abx500_chargalg_sysfs_init(di);\r\nif (ret) {\r\ndev_err(di->dev, "failed to create sysfs entry\n");\r\ngoto free_psy;\r\n}\r\nqueue_delayed_work(di->chargalg_wq, &di->chargalg_periodic_work, 0);\r\ndev_info(di->dev, "probe success\n");\r\nreturn ret;\r\nfree_psy:\r\npower_supply_unregister(&di->chargalg_psy);\r\nfree_chargalg_wq:\r\ndestroy_workqueue(di->chargalg_wq);\r\nfree_device_info:\r\nkfree(di);\r\nreturn ret;\r\n}\r\nstatic int __init abx500_chargalg_init(void)\r\n{\r\nreturn platform_driver_register(&abx500_chargalg_driver);\r\n}\r\nstatic void __exit abx500_chargalg_exit(void)\r\n{\r\nplatform_driver_unregister(&abx500_chargalg_driver);\r\n}
