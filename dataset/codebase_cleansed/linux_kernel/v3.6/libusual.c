void usb_usual_set_present(int type)\r\n{\r\nstruct mod_status *st;\r\nunsigned long flags;\r\nif (type <= 0 || type >= 3)\r\nreturn;\r\nst = &stat[type];\r\nspin_lock_irqsave(&usu_lock, flags);\r\nst->fls |= USU_MOD_FL_PRESENT;\r\nspin_unlock_irqrestore(&usu_lock, flags);\r\n}\r\nvoid usb_usual_clear_present(int type)\r\n{\r\nstruct mod_status *st;\r\nunsigned long flags;\r\nif (type <= 0 || type >= 3)\r\nreturn;\r\nst = &stat[type];\r\nspin_lock_irqsave(&usu_lock, flags);\r\nst->fls &= ~USU_MOD_FL_PRESENT;\r\nspin_unlock_irqrestore(&usu_lock, flags);\r\n}\r\nint usb_usual_check_type(const struct usb_device_id *id, int caller_type)\r\n{\r\nint id_type = USB_US_TYPE(id->driver_info);\r\nif (caller_type <= 0 || caller_type >= 3)\r\nreturn -EINVAL;\r\nif (id_type == caller_type)\r\nreturn 0;\r\nif (id_type == USB_US_TYPE_NONE && caller_type == atomic_read(&usu_bias))\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nstatic int usu_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint rc;\r\nunsigned long type;\r\nstruct task_struct* task;\r\nunsigned long flags;\r\ntype = USB_US_TYPE(id->driver_info);\r\nif (type == 0)\r\ntype = atomic_read(&usu_bias);\r\nspin_lock_irqsave(&usu_lock, flags);\r\nif ((stat[type].fls & (USU_MOD_FL_THREAD|USU_MOD_FL_PRESENT)) != 0) {\r\nspin_unlock_irqrestore(&usu_lock, flags);\r\nreturn -ENXIO;\r\n}\r\nstat[type].fls |= USU_MOD_FL_THREAD;\r\nspin_unlock_irqrestore(&usu_lock, flags);\r\ntask = kthread_run(usu_probe_thread, (void*)type, "libusual_%ld", type);\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\nprintk(KERN_WARNING "libusual: "\r\n"Unable to start the thread for %s: %d\n",\r\nbias_names[type], rc);\r\nspin_lock_irqsave(&usu_lock, flags);\r\nstat[type].fls &= ~USU_MOD_FL_THREAD;\r\nspin_unlock_irqrestore(&usu_lock, flags);\r\nreturn rc;\r\n}\r\natomic_inc(&total_threads);\r\nreturn -ENXIO;\r\n}\r\nstatic void usu_disconnect(struct usb_interface *intf)\r\n{\r\n;\r\n}\r\nstatic int usu_probe_thread(void *arg)\r\n{\r\nint type = (unsigned long) arg;\r\nstruct mod_status *st = &stat[type];\r\nint rc;\r\nunsigned long flags;\r\nmutex_lock(&usu_probe_mutex);\r\nrc = request_module(bias_names[type]);\r\nspin_lock_irqsave(&usu_lock, flags);\r\nif (rc == 0 && (st->fls & USU_MOD_FL_PRESENT) == 0) {\r\nprintk(KERN_NOTICE "libusual: "\r\n"modprobe for %s succeeded, but module is not present\n",\r\nbias_names[type]);\r\n}\r\nst->fls &= ~USU_MOD_FL_THREAD;\r\nspin_unlock_irqrestore(&usu_lock, flags);\r\nmutex_unlock(&usu_probe_mutex);\r\ncomplete_and_exit(&usu_end_notify, 0);\r\n}\r\nstatic int __init usb_usual_init(void)\r\n{\r\nint rc;\r\nmutex_lock(&usu_probe_mutex);\r\nrc = usb_register(&usu_driver);\r\nmutex_unlock(&usu_probe_mutex);\r\nreturn rc;\r\n}\r\nstatic void __exit usb_usual_exit(void)\r\n{\r\nusb_deregister(&usu_driver);\r\nwhile (atomic_read(&total_threads) > 0) {\r\nwait_for_completion(&usu_end_notify);\r\natomic_dec(&total_threads);\r\n}\r\n}\r\nstatic int usu_set_bias(const char *bias_s, struct kernel_param *kp)\r\n{\r\nint i;\r\nint len;\r\nint bias_n = 0;\r\nlen = strlen(bias_s);\r\nif (len == 0)\r\nreturn -EDOM;\r\nif (bias_s[len-1] == '\n')\r\n--len;\r\nfor (i = 1; i < 3; i++) {\r\nif (strncmp(bias_s, bias_names[i], len) == 0) {\r\nbias_n = i;\r\nbreak;\r\n}\r\n}\r\nif (bias_n == 0)\r\nreturn -EINVAL;\r\natomic_set(&usu_bias, bias_n);\r\nreturn 0;\r\n}\r\nstatic int usu_get_bias(char *buffer, struct kernel_param *kp)\r\n{\r\nreturn strlen(strcpy(buffer, bias_names[atomic_read(&usu_bias)]));\r\n}
