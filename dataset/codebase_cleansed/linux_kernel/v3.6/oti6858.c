static void setup_line(struct work_struct *work)\r\n{\r\nstruct oti6858_private *priv = container_of(work,\r\nstruct oti6858_private, delayed_setup_work.work);\r\nstruct usb_serial_port *port = priv->port;\r\nstruct oti6858_control_pkt *new_setup;\r\nunsigned long flags;\r\nint result;\r\nnew_setup = kmalloc(OTI6858_CTRL_PKT_SIZE, GFP_KERNEL);\r\nif (new_setup == NULL) {\r\ndev_err(&port->dev, "%s(): out of memory!\n", __func__);\r\nschedule_delayed_work(&priv->delayed_setup_work,\r\nmsecs_to_jiffies(2));\r\nreturn;\r\n}\r\nresult = usb_control_msg(port->serial->dev,\r\nusb_rcvctrlpipe(port->serial->dev, 0),\r\nOTI6858_REQ_T_GET_STATUS,\r\nOTI6858_REQ_GET_STATUS,\r\n0, 0,\r\nnew_setup, OTI6858_CTRL_PKT_SIZE,\r\n100);\r\nif (result != OTI6858_CTRL_PKT_SIZE) {\r\ndev_err(&port->dev, "%s(): error reading status\n", __func__);\r\nkfree(new_setup);\r\nschedule_delayed_work(&priv->delayed_setup_work,\r\nmsecs_to_jiffies(2));\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!OTI6858_CTRL_EQUALS_PENDING(new_setup, priv)) {\r\nnew_setup->divisor = priv->pending_setup.divisor;\r\nnew_setup->control = priv->pending_setup.control;\r\nnew_setup->frame_fmt = priv->pending_setup.frame_fmt;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nresult = usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nOTI6858_REQ_T_SET_LINE,\r\nOTI6858_REQ_SET_LINE,\r\n0, 0,\r\nnew_setup, OTI6858_CTRL_PKT_SIZE,\r\n100);\r\n} else {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nresult = 0;\r\n}\r\nkfree(new_setup);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (result != OTI6858_CTRL_PKT_SIZE)\r\npriv->transient = 0;\r\npriv->setup_done = 1;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndbg("%s(): submitting interrupt urb", __func__);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result != 0) {\r\ndev_err(&port->dev, "%s(): usb_submit_urb() failed"\r\n" with error %d\n", __func__, result);\r\n}\r\n}\r\nstatic void send_data(struct work_struct *work)\r\n{\r\nstruct oti6858_private *priv = container_of(work,\r\nstruct oti6858_private, delayed_write_work.work);\r\nstruct usb_serial_port *port = priv->port;\r\nint count = 0, result;\r\nunsigned long flags;\r\nu8 *allow;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->flags.write_urb_in_use) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nschedule_delayed_work(&priv->delayed_write_work,\r\nmsecs_to_jiffies(2));\r\nreturn;\r\n}\r\npriv->flags.write_urb_in_use = 1;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nspin_lock_irqsave(&port->lock, flags);\r\ncount = kfifo_len(&port->write_fifo);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (count > port->bulk_out_size)\r\ncount = port->bulk_out_size;\r\nif (count != 0) {\r\nallow = kmalloc(1, GFP_KERNEL);\r\nif (!allow) {\r\ndev_err_console(port, "%s(): kmalloc failed\n",\r\n__func__);\r\nreturn;\r\n}\r\nresult = usb_control_msg(port->serial->dev,\r\nusb_rcvctrlpipe(port->serial->dev, 0),\r\nOTI6858_REQ_T_CHECK_TXBUFF,\r\nOTI6858_REQ_CHECK_TXBUFF,\r\ncount, 0, allow, 1, 100);\r\nif (result != 1 || *allow != 0)\r\ncount = 0;\r\nkfree(allow);\r\n}\r\nif (count == 0) {\r\npriv->flags.write_urb_in_use = 0;\r\ndbg("%s(): submitting interrupt urb", __func__);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);\r\nif (result != 0) {\r\ndev_err(&port->dev, "%s(): usb_submit_urb() failed"\r\n" with error %d\n", __func__, result);\r\n}\r\nreturn;\r\n}\r\ncount = kfifo_out_locked(&port->write_fifo,\r\nport->write_urb->transfer_buffer,\r\ncount, &port->lock);\r\nport->write_urb->transfer_buffer_length = count;\r\nresult = usb_submit_urb(port->write_urb, GFP_NOIO);\r\nif (result != 0) {\r\ndev_err_console(port, "%s(): usb_submit_urb() failed"\r\n" with error %d\n", __func__, result);\r\npriv->flags.write_urb_in_use = 0;\r\n}\r\nusb_serial_port_softint(port);\r\n}\r\nstatic int oti6858_startup(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port = serial->port[0];\r\nstruct oti6858_private *priv;\r\nint i;\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\npriv = kzalloc(sizeof(struct oti6858_private), GFP_KERNEL);\r\nif (!priv)\r\nbreak;\r\nspin_lock_init(&priv->lock);\r\ninit_waitqueue_head(&priv->intr_wait);\r\npriv->port = port;\r\nINIT_DELAYED_WORK(&priv->delayed_setup_work, setup_line);\r\nINIT_DELAYED_WORK(&priv->delayed_write_work, send_data);\r\nusb_set_serial_port_data(serial->port[i], priv);\r\n}\r\nif (i == serial->num_ports)\r\nreturn 0;\r\nfor (--i; i >= 0; --i) {\r\npriv = usb_get_serial_port_data(serial->port[i]);\r\nkfree(priv);\r\nusb_set_serial_port_data(serial->port[i], NULL);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int oti6858_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nif (!count)\r\nreturn count;\r\ncount = kfifo_in_locked(&port->write_fifo, buf, count, &port->lock);\r\nreturn count;\r\n}\r\nstatic int oti6858_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint room = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nroom = kfifo_avail(&port->write_fifo);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn room;\r\n}\r\nstatic int oti6858_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nint chars = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nchars = kfifo_len(&port->write_fifo);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn chars;\r\n}\r\nstatic void oti6858_init_termios(struct tty_struct *tty)\r\n{\r\n*(tty->termios) = tty_std_termios;\r\ntty->termios->c_cflag = B38400 | CS8 | CREAD | HUPCL | CLOCAL;\r\ntty->termios->c_ispeed = 38400;\r\ntty->termios->c_ospeed = 38400;\r\n}\r\nstatic void oti6858_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int cflag;\r\nu8 frame_fmt, control;\r\n__le16 divisor;\r\nint br;\r\nif (!tty) {\r\ndbg("%s(): no tty structures", __func__);\r\nreturn;\r\n}\r\ncflag = tty->termios->c_cflag;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ndivisor = priv->pending_setup.divisor;\r\nframe_fmt = priv->pending_setup.frame_fmt;\r\ncontrol = priv->pending_setup.control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nframe_fmt &= ~FMT_DATA_BITS_MASK;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nframe_fmt |= FMT_DATA_BITS_5;\r\nbreak;\r\ncase CS6:\r\nframe_fmt |= FMT_DATA_BITS_6;\r\nbreak;\r\ncase CS7:\r\nframe_fmt |= FMT_DATA_BITS_7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nframe_fmt |= FMT_DATA_BITS_8;\r\nbreak;\r\n}\r\nbr = tty_get_baud_rate(tty);\r\nif (br == 0) {\r\ndivisor = 0;\r\n} else {\r\nint real_br;\r\nint new_divisor;\r\nbr = min(br, OTI6858_MAX_BAUD_RATE);\r\nnew_divisor = (96000000 + 8 * br) / (16 * br);\r\nreal_br = 96000000 / (16 * new_divisor);\r\ndivisor = cpu_to_le16(new_divisor);\r\ntty_encode_baud_rate(tty, real_br, real_br);\r\n}\r\nframe_fmt &= ~FMT_STOP_BITS_MASK;\r\nif ((cflag & CSTOPB) != 0)\r\nframe_fmt |= FMT_STOP_BITS_2;\r\nelse\r\nframe_fmt |= FMT_STOP_BITS_1;\r\nframe_fmt &= ~FMT_PARITY_MASK;\r\nif ((cflag & PARENB) != 0) {\r\nif ((cflag & PARODD) != 0)\r\nframe_fmt |= FMT_PARITY_ODD;\r\nelse\r\nframe_fmt |= FMT_PARITY_EVEN;\r\n} else {\r\nframe_fmt |= FMT_PARITY_NONE;\r\n}\r\ncontrol &= ~CONTROL_MASK;\r\nif ((cflag & CRTSCTS) != 0)\r\ncontrol |= (CONTROL_DTR_HIGH | CONTROL_RTS_HIGH);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (divisor != priv->pending_setup.divisor\r\n|| control != priv->pending_setup.control\r\n|| frame_fmt != priv->pending_setup.frame_fmt) {\r\npriv->pending_setup.divisor = divisor;\r\npriv->pending_setup.control = control;\r\npriv->pending_setup.frame_fmt = frame_fmt;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int oti6858_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nstruct ktermios tmp_termios;\r\nstruct usb_serial *serial = port->serial;\r\nstruct oti6858_control_pkt *buf;\r\nunsigned long flags;\r\nint result;\r\nusb_clear_halt(serial->dev, port->write_urb->pipe);\r\nusb_clear_halt(serial->dev, port->read_urb->pipe);\r\nbuf = kmalloc(OTI6858_CTRL_PKT_SIZE, GFP_KERNEL);\r\nif (buf == NULL) {\r\ndev_err(&port->dev, "%s(): out of memory!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nOTI6858_REQ_T_GET_STATUS,\r\nOTI6858_REQ_GET_STATUS,\r\n0, 0,\r\nbuf, OTI6858_CTRL_PKT_SIZE,\r\n100);\r\nif (result != OTI6858_CTRL_PKT_SIZE) {\r\nbuf->divisor = cpu_to_le16(0x009c);\r\nbuf->frame_fmt = 0x03;\r\nbuf->something = 0x43;\r\nbuf->control = 0x4c;\r\nbuf->tx_status = 0x00;\r\nbuf->pin_state = 0x5b;\r\nbuf->rx_bytes_avail = 0x00;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nmemcpy(&priv->status, buf, OTI6858_CTRL_PKT_SIZE);\r\npriv->pending_setup.divisor = buf->divisor;\r\npriv->pending_setup.frame_fmt = buf->frame_fmt;\r\npriv->pending_setup.control = buf->control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nkfree(buf);\r\ndbg("%s(): submitting interrupt urb", __func__);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result != 0) {\r\ndev_err(&port->dev, "%s(): usb_submit_urb() failed"\r\n" with error %d\n", __func__, result);\r\noti6858_close(port);\r\nreturn result;\r\n}\r\nif (tty)\r\noti6858_set_termios(tty, port, &tmp_termios);\r\nport->port.drain_delay = 256;\r\nreturn 0;\r\n}\r\nstatic void oti6858_close(struct usb_serial_port *port)\r\n{\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nkfifo_reset_out(&port->write_fifo);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndbg("%s(): after buf_clear()", __func__);\r\ncancel_delayed_work_sync(&priv->delayed_setup_work);\r\ncancel_delayed_work_sync(&priv->delayed_write_work);\r\ndbg("%s(): shutting down urbs", __func__);\r\nusb_kill_urb(port->write_urb);\r\nusb_kill_urb(port->read_urb);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic int oti6858_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\ndbg("%s(port = %d, set = 0x%08x, clear = 0x%08x)",\r\n__func__, port->number, set, clear);\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol = priv->pending_setup.control;\r\nif ((set & TIOCM_RTS) != 0)\r\ncontrol |= CONTROL_RTS_HIGH;\r\nif ((set & TIOCM_DTR) != 0)\r\ncontrol |= CONTROL_DTR_HIGH;\r\nif ((clear & TIOCM_RTS) != 0)\r\ncontrol &= ~CONTROL_RTS_HIGH;\r\nif ((clear & TIOCM_DTR) != 0)\r\ncontrol &= ~CONTROL_DTR_HIGH;\r\nif (control != priv->pending_setup.control)\r\npriv->pending_setup.control = control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int oti6858_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned pin_state;\r\nunsigned result = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npin_state = priv->status.pin_state & PIN_MASK;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif ((pin_state & PIN_RTS) != 0)\r\nresult |= TIOCM_RTS;\r\nif ((pin_state & PIN_CTS) != 0)\r\nresult |= TIOCM_CTS;\r\nif ((pin_state & PIN_DSR) != 0)\r\nresult |= TIOCM_DSR;\r\nif ((pin_state & PIN_DTR) != 0)\r\nresult |= TIOCM_DTR;\r\nif ((pin_state & PIN_RI) != 0)\r\nresult |= TIOCM_RI;\r\nif ((pin_state & PIN_DCD) != 0)\r\nresult |= TIOCM_CD;\r\ndbg("%s() = 0x%08x", __func__, result);\r\nreturn result;\r\n}\r\nstatic int wait_modem_info(struct usb_serial_port *port, unsigned int arg)\r\n{\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int prev, status;\r\nunsigned int changed;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nprev = priv->status.pin_state;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwhile (1) {\r\nwait_event_interruptible(priv->intr_wait,\r\npriv->status.pin_state != prev);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = priv->status.pin_state & PIN_MASK;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nchanged = prev ^ status;\r\nif (((arg & TIOCM_RNG) && (changed & PIN_RI)) ||\r\n((arg & TIOCM_DSR) && (changed & PIN_DSR)) ||\r\n((arg & TIOCM_CD) && (changed & PIN_DCD)) ||\r\n((arg & TIOCM_CTS) && (changed & PIN_CTS)))\r\nreturn 0;\r\nprev = status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int oti6858_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndbg("%s(port = %d, cmd = 0x%04x, arg = 0x%08lx)",\r\n__func__, port->number, cmd, arg);\r\nswitch (cmd) {\r\ncase TIOCMIWAIT:\r\ndbg("%s(): TIOCMIWAIT", __func__);\r\nreturn wait_modem_info(port, arg);\r\ndefault:\r\ndbg("%s(): 0x%04x not supported", __func__, cmd);\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void oti6858_release(struct usb_serial *serial)\r\n{\r\nint i;\r\nfor (i = 0; i < serial->num_ports; ++i)\r\nkfree(usb_get_serial_port_data(serial->port[i]));\r\n}\r\nstatic void oti6858_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nint transient = 0, can_recv = 0, resubmit = 1;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s(): urb shutting down with status: %d",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndbg("%s(): nonzero urb status received: %d",\r\n__func__, status);\r\nbreak;\r\n}\r\nif (status == 0 && urb->actual_length == OTI6858_CTRL_PKT_SIZE) {\r\nstruct oti6858_control_pkt *xs = urb->transfer_buffer;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->transient) {\r\nif (!OTI6858_CTRL_EQUALS_PENDING(xs, priv)) {\r\nif (xs->rx_bytes_avail == 0) {\r\npriv->transient = 4;\r\npriv->setup_done = 0;\r\nresubmit = 0;\r\ndbg("%s(): scheduling setup_line()",\r\n__func__);\r\nschedule_delayed_work(&priv->delayed_setup_work, 0);\r\n}\r\n}\r\n} else {\r\nif (OTI6858_CTRL_EQUALS_PENDING(xs, priv)) {\r\npriv->transient = 0;\r\n} else if (!priv->setup_done) {\r\nresubmit = 0;\r\n} else if (--priv->transient == 0) {\r\nif (xs->rx_bytes_avail == 0) {\r\npriv->transient = 4;\r\npriv->setup_done = 0;\r\nresubmit = 0;\r\ndbg("%s(): scheduling setup_line()",\r\n__func__);\r\nschedule_delayed_work(&priv->delayed_setup_work, 0);\r\n}\r\n}\r\n}\r\nif (!priv->transient) {\r\nif (xs->pin_state != priv->status.pin_state)\r\nwake_up_interruptible(&priv->intr_wait);\r\nmemcpy(&priv->status, xs, OTI6858_CTRL_PKT_SIZE);\r\n}\r\nif (!priv->transient && xs->rx_bytes_avail != 0) {\r\ncan_recv = xs->rx_bytes_avail;\r\npriv->flags.read_urb_in_use = 1;\r\n}\r\ntransient = priv->transient;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nif (can_recv) {\r\nint result;\r\nresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\r\nif (result != 0) {\r\npriv->flags.read_urb_in_use = 0;\r\ndev_err(&port->dev, "%s(): usb_submit_urb() failed,"\r\n" error %d\n", __func__, result);\r\n} else {\r\nresubmit = 0;\r\n}\r\n} else if (!transient) {\r\nunsigned long flags;\r\nint count;\r\nspin_lock_irqsave(&port->lock, flags);\r\ncount = kfifo_len(&port->write_fifo);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->flags.write_urb_in_use == 0 && count != 0) {\r\nschedule_delayed_work(&priv->delayed_write_work, 0);\r\nresubmit = 0;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nif (resubmit) {\r\nint result;\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result != 0) {\r\ndev_err(&urb->dev->dev,\r\n"%s(): usb_submit_urb() failed with"\r\n" error %d\n", __func__, result);\r\n}\r\n}\r\n}\r\nstatic void oti6858_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned long flags;\r\nint status = urb->status;\r\nint result;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->flags.read_urb_in_use = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (status != 0) {\r\ndbg("%s(): unable to handle the error, exiting", __func__);\r\nreturn;\r\n}\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty != NULL && urb->actual_length > 0) {\r\ntty_insert_flip_string(tty, data, urb->actual_length);\r\ntty_flip_buffer_push(tty);\r\n}\r\ntty_kref_put(tty);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\r\nif (result != 0 && result != -EPERM) {\r\ndev_err(&port->dev, "%s(): usb_submit_urb() failed,"\r\n" error %d\n", __func__, result);\r\n}\r\n}\r\nstatic void oti6858_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct oti6858_private *priv = usb_get_serial_port_data(port);\r\nint status = urb->status;\r\nint result;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s(): urb shutting down with status: %d",\r\n__func__, status);\r\npriv->flags.write_urb_in_use = 0;\r\nreturn;\r\ndefault:\r\ndbg("%s(): nonzero write bulk status received: %d",\r\n__func__, status);\r\ndbg("%s(): overflow in write", __func__);\r\nport->write_urb->transfer_buffer_length = 1;\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err_console(port, "%s(): usb_submit_urb() failed,"\r\n" error %d\n", __func__, result);\r\n} else {\r\nreturn;\r\n}\r\n}\r\npriv->flags.write_urb_in_use = 0;\r\ndbg("%s(): submitting interrupt urb", __func__);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\r\nif (result != 0) {\r\ndev_err(&port->dev, "%s(): failed submitting int urb,"\r\n" error %d\n", __func__, result);\r\n}\r\n}
