static void inline enable_irqs(int mask)\r\n{\r\nlcdc.irq_mask |= mask;\r\n}\r\nstatic void inline disable_irqs(int mask)\r\n{\r\nlcdc.irq_mask &= ~mask;\r\n}\r\nstatic void set_load_mode(enum lcdc_load_mode mode)\r\n{\r\nu32 l;\r\nl = omap_readl(OMAP_LCDC_CONTROL);\r\nl &= ~(3 << 20);\r\nswitch (mode) {\r\ncase OMAP_LCDC_LOAD_PALETTE:\r\nl |= 1 << 20;\r\nbreak;\r\ncase OMAP_LCDC_LOAD_FRAME:\r\nl |= 2 << 20;\r\nbreak;\r\ncase OMAP_LCDC_LOAD_PALETTE_AND_FRAME:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nomap_writel(l, OMAP_LCDC_CONTROL);\r\n}\r\nstatic void enable_controller(void)\r\n{\r\nu32 l;\r\nl = omap_readl(OMAP_LCDC_CONTROL);\r\nl |= OMAP_LCDC_CTRL_LCD_EN;\r\nl &= ~OMAP_LCDC_IRQ_MASK;\r\nl |= lcdc.irq_mask | OMAP_LCDC_IRQ_DONE;\r\nomap_writel(l, OMAP_LCDC_CONTROL);\r\n}\r\nstatic void disable_controller_async(void)\r\n{\r\nu32 l;\r\nu32 mask;\r\nl = omap_readl(OMAP_LCDC_CONTROL);\r\nmask = OMAP_LCDC_CTRL_LCD_EN | OMAP_LCDC_IRQ_MASK;\r\nmask &= ~OMAP_LCDC_IRQ_DONE;\r\nl &= ~mask;\r\nomap_writel(l, OMAP_LCDC_CONTROL);\r\n}\r\nstatic void disable_controller(void)\r\n{\r\ninit_completion(&lcdc.last_frame_complete);\r\ndisable_controller_async();\r\nif (!wait_for_completion_timeout(&lcdc.last_frame_complete,\r\nmsecs_to_jiffies(500)))\r\ndev_err(lcdc.fbdev->dev, "timeout waiting for FRAME DONE\n");\r\n}\r\nstatic void reset_controller(u32 status)\r\n{\r\nstatic unsigned long reset_count;\r\nstatic unsigned long last_jiffies;\r\ndisable_controller_async();\r\nreset_count++;\r\nif (reset_count == 1 || time_after(jiffies, last_jiffies + HZ)) {\r\ndev_err(lcdc.fbdev->dev,\r\n"resetting (status %#010x,reset count %lu)\n",\r\nstatus, reset_count);\r\nlast_jiffies = jiffies;\r\n}\r\nif (reset_count < 100) {\r\nenable_controller();\r\n} else {\r\nreset_count = 0;\r\ndev_err(lcdc.fbdev->dev,\r\n"too many reset attempts, giving up.\n");\r\n}\r\n}\r\nstatic void setup_lcd_dma(void)\r\n{\r\nstatic const int dma_elem_type[] = {\r\n0,\r\nOMAP_DMA_DATA_TYPE_S8,\r\nOMAP_DMA_DATA_TYPE_S16,\r\n0,\r\nOMAP_DMA_DATA_TYPE_S32,\r\n};\r\nstruct omapfb_plane_struct *plane = lcdc.fbdev->fb_info[0]->par;\r\nstruct fb_var_screeninfo *var = &lcdc.fbdev->fb_info[0]->var;\r\nunsigned long src;\r\nint esize, xelem, yelem;\r\nsrc = lcdc.vram_phys + lcdc.frame_offset;\r\nswitch (var->rotate) {\r\ncase 0:\r\nif (plane->info.mirror || (src & 3) ||\r\nlcdc.color_mode == OMAPFB_COLOR_YUV420 ||\r\n(lcdc.xres & 1))\r\nesize = 2;\r\nelse\r\nesize = 4;\r\nxelem = lcdc.xres * lcdc.bpp / 8 / esize;\r\nyelem = lcdc.yres;\r\nbreak;\r\ncase 90:\r\ncase 180:\r\ncase 270:\r\nif (cpu_is_omap15xx()) {\r\nBUG();\r\n}\r\nesize = 2;\r\nxelem = lcdc.yres * lcdc.bpp / 16;\r\nyelem = lcdc.xres;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\n#ifdef VERBOSE\r\ndev_dbg(lcdc.fbdev->dev,\r\n"setup_dma: src %#010lx esize %d xelem %d yelem %d\n",\r\nsrc, esize, xelem, yelem);\r\n#endif\r\nomap_set_lcd_dma_b1(src, xelem, yelem, dma_elem_type[esize]);\r\nif (!cpu_is_omap15xx()) {\r\nint bpp = lcdc.bpp;\r\nif (lcdc.color_mode == OMAPFB_COLOR_YUV420)\r\nbpp = 16;\r\nomap_set_lcd_dma_b1_vxres(\r\nlcdc.screen_width * bpp / 8 / esize);\r\nomap_set_lcd_dma_b1_rotation(var->rotate);\r\nomap_set_lcd_dma_b1_mirror(plane->info.mirror);\r\n}\r\nomap_setup_lcd_dma();\r\n}\r\nstatic irqreturn_t lcdc_irq_handler(int irq, void *dev_id)\r\n{\r\nu32 status;\r\nstatus = omap_readl(OMAP_LCDC_STATUS);\r\nif (status & (OMAP_LCDC_STAT_FUF | OMAP_LCDC_STAT_SYNC_LOST))\r\nreset_controller(status);\r\nelse {\r\nif (status & OMAP_LCDC_STAT_DONE) {\r\nu32 l;\r\nl = omap_readl(OMAP_LCDC_CONTROL);\r\nl &= ~OMAP_LCDC_IRQ_DONE;\r\nomap_writel(l, OMAP_LCDC_CONTROL);\r\ncomplete(&lcdc.last_frame_complete);\r\n}\r\nif (status & OMAP_LCDC_STAT_LOADED_PALETTE) {\r\ndisable_controller_async();\r\ncomplete(&lcdc.palette_load_complete);\r\n}\r\n}\r\nstatus &= ~(OMAP_LCDC_STAT_VSYNC |\r\nOMAP_LCDC_STAT_LOADED_PALETTE |\r\nOMAP_LCDC_STAT_ABC |\r\nOMAP_LCDC_STAT_LINE_INT);\r\nomap_writel(status, OMAP_LCDC_STATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int omap_lcdc_setup_plane(int plane, int channel_out,\r\nunsigned long offset, int screen_width,\r\nint pos_x, int pos_y, int width, int height,\r\nint color_mode)\r\n{\r\nstruct fb_var_screeninfo *var = &lcdc.fbdev->fb_info[0]->var;\r\nstruct lcd_panel *panel = lcdc.fbdev->panel;\r\nint rot_x, rot_y;\r\nif (var->rotate == 0) {\r\nrot_x = panel->x_res;\r\nrot_y = panel->y_res;\r\n} else {\r\nrot_x = panel->y_res;\r\nrot_y = panel->x_res;\r\n}\r\nif (plane != 0 || channel_out != 0 || pos_x != 0 || pos_y != 0 ||\r\nwidth > rot_x || height > rot_y) {\r\n#ifdef VERBOSE\r\ndev_dbg(lcdc.fbdev->dev,\r\n"invalid plane params plane %d pos_x %d pos_y %d "\r\n"w %d h %d\n", plane, pos_x, pos_y, width, height);\r\n#endif\r\nreturn -EINVAL;\r\n}\r\nlcdc.frame_offset = offset;\r\nlcdc.xres = width;\r\nlcdc.yres = height;\r\nlcdc.screen_width = screen_width;\r\nlcdc.color_mode = color_mode;\r\nswitch (color_mode) {\r\ncase OMAPFB_COLOR_CLUT_8BPP:\r\nlcdc.bpp = 8;\r\nlcdc.palette_code = 0x3000;\r\nlcdc.palette_size = 512;\r\nbreak;\r\ncase OMAPFB_COLOR_RGB565:\r\nlcdc.bpp = 16;\r\nlcdc.palette_code = 0x4000;\r\nlcdc.palette_size = 32;\r\nbreak;\r\ncase OMAPFB_COLOR_RGB444:\r\nlcdc.bpp = 16;\r\nlcdc.palette_code = 0x4000;\r\nlcdc.palette_size = 32;\r\nbreak;\r\ncase OMAPFB_COLOR_YUV420:\r\nif (lcdc.ext_mode) {\r\nlcdc.bpp = 12;\r\nbreak;\r\n}\r\ncase OMAPFB_COLOR_YUV422:\r\nif (lcdc.ext_mode) {\r\nlcdc.bpp = 16;\r\nbreak;\r\n}\r\ndefault:\r\ndev_dbg(lcdc.fbdev->dev, "invalid color mode %d\n", color_mode);\r\nBUG();\r\nreturn -1;\r\n}\r\nif (lcdc.ext_mode) {\r\nsetup_lcd_dma();\r\nreturn 0;\r\n}\r\nif (lcdc.update_mode == OMAPFB_AUTO_UPDATE) {\r\ndisable_controller();\r\nomap_stop_lcd_dma();\r\nsetup_lcd_dma();\r\nenable_controller();\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_lcdc_enable_plane(int plane, int enable)\r\n{\r\ndev_dbg(lcdc.fbdev->dev,\r\n"plane %d enable %d update_mode %d ext_mode %d\n",\r\nplane, enable, lcdc.update_mode, lcdc.ext_mode);\r\nif (plane != OMAPFB_PLANE_GFX)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void load_palette(void)\r\n{\r\nu16 *palette;\r\npalette = (u16 *)lcdc.palette_virt;\r\n*(u16 *)palette &= 0x0fff;\r\n*(u16 *)palette |= lcdc.palette_code;\r\nomap_set_lcd_dma_b1(lcdc.palette_phys,\r\nlcdc.palette_size / 4 + 1, 1, OMAP_DMA_DATA_TYPE_S32);\r\nomap_set_lcd_dma_single_transfer(1);\r\nomap_setup_lcd_dma();\r\ninit_completion(&lcdc.palette_load_complete);\r\nenable_irqs(OMAP_LCDC_IRQ_LOADED_PALETTE);\r\nset_load_mode(OMAP_LCDC_LOAD_PALETTE);\r\nenable_controller();\r\nif (!wait_for_completion_timeout(&lcdc.palette_load_complete,\r\nmsecs_to_jiffies(500)))\r\ndev_err(lcdc.fbdev->dev, "timeout waiting for FRAME DONE\n");\r\ndisable_irqs(OMAP_LCDC_IRQ_LOADED_PALETTE);\r\nomap_stop_lcd_dma();\r\nomap_set_lcd_dma_single_transfer(lcdc.ext_mode);\r\n}\r\nstatic int omap_lcdc_setcolreg(u_int regno, u16 red, u16 green, u16 blue,\r\nu16 transp, int update_hw_pal)\r\n{\r\nu16 *palette;\r\nif (lcdc.color_mode != OMAPFB_COLOR_CLUT_8BPP || regno > 255)\r\nreturn -EINVAL;\r\npalette = (u16 *)lcdc.palette_virt;\r\npalette[regno] &= ~0x0fff;\r\npalette[regno] |= ((red >> 12) << 8) | ((green >> 12) << 4 ) |\r\n(blue >> 12);\r\nif (update_hw_pal) {\r\ndisable_controller();\r\nomap_stop_lcd_dma();\r\nload_palette();\r\nsetup_lcd_dma();\r\nset_load_mode(OMAP_LCDC_LOAD_FRAME);\r\nenable_controller();\r\n}\r\nreturn 0;\r\n}\r\nstatic void calc_ck_div(int is_tft, int pck, int *pck_div)\r\n{\r\nunsigned long lck;\r\npck = max(1, pck);\r\nlck = clk_get_rate(lcdc.lcd_ck);\r\n*pck_div = (lck + pck - 1) / pck;\r\nif (is_tft)\r\n*pck_div = max(2, *pck_div);\r\nelse\r\n*pck_div = max(3, *pck_div);\r\nif (*pck_div > 255) {\r\n*pck_div = 255;\r\ndev_warn(lcdc.fbdev->dev, "pixclock %d kHz too low.\n",\r\npck / 1000);\r\n}\r\n}\r\nstatic void inline setup_regs(void)\r\n{\r\nu32 l;\r\nstruct lcd_panel *panel = lcdc.fbdev->panel;\r\nint is_tft = panel->config & OMAP_LCDC_PANEL_TFT;\r\nunsigned long lck;\r\nint pcd;\r\nl = omap_readl(OMAP_LCDC_CONTROL);\r\nl &= ~OMAP_LCDC_CTRL_LCD_TFT;\r\nl |= is_tft ? OMAP_LCDC_CTRL_LCD_TFT : 0;\r\n#ifdef CONFIG_MACH_OMAP_PALMTE\r\nl |= (is_tft && panel->bpp == 8) ? 0x810000 : 0;\r\n#endif\r\nomap_writel(l, OMAP_LCDC_CONTROL);\r\nl = omap_readl(OMAP_LCDC_TIMING2);\r\nl &= ~(((1 << 6) - 1) << 20);\r\nl |= (panel->config & OMAP_LCDC_SIGNAL_MASK) << 20;\r\nomap_writel(l, OMAP_LCDC_TIMING2);\r\nl = panel->x_res - 1;\r\nl |= (panel->hsw - 1) << 10;\r\nl |= (panel->hfp - 1) << 16;\r\nl |= (panel->hbp - 1) << 24;\r\nomap_writel(l, OMAP_LCDC_TIMING0);\r\nl = panel->y_res - 1;\r\nl |= (panel->vsw - 1) << 10;\r\nl |= panel->vfp << 16;\r\nl |= panel->vbp << 24;\r\nomap_writel(l, OMAP_LCDC_TIMING1);\r\nl = omap_readl(OMAP_LCDC_TIMING2);\r\nl &= ~0xff;\r\nlck = clk_get_rate(lcdc.lcd_ck);\r\nif (!panel->pcd)\r\ncalc_ck_div(is_tft, panel->pixel_clock * 1000, &pcd);\r\nelse {\r\ndev_warn(lcdc.fbdev->dev,\r\n"Pixel clock divider value is obsolete.\n"\r\n"Try to set pixel_clock to %lu and pcd to 0 "\r\n"in drivers/video/omap/lcd_%s.c and submit a patch.\n",\r\nlck / panel->pcd / 1000, panel->name);\r\npcd = panel->pcd;\r\n}\r\nl |= pcd & 0xff;\r\nl |= panel->acb << 8;\r\nomap_writel(l, OMAP_LCDC_TIMING2);\r\npanel->pixel_clock = lck / pcd / 1000;\r\n}\r\nstatic int omap_lcdc_set_update_mode(enum omapfb_update_mode mode)\r\n{\r\nint r = 0;\r\nif (mode != lcdc.update_mode) {\r\nswitch (mode) {\r\ncase OMAPFB_AUTO_UPDATE:\r\nsetup_regs();\r\nload_palette();\r\nsetup_lcd_dma();\r\nset_load_mode(OMAP_LCDC_LOAD_FRAME);\r\nenable_irqs(OMAP_LCDC_IRQ_DONE);\r\nenable_controller();\r\nlcdc.update_mode = mode;\r\nbreak;\r\ncase OMAPFB_UPDATE_DISABLED:\r\ndisable_controller();\r\nomap_stop_lcd_dma();\r\nlcdc.update_mode = mode;\r\nbreak;\r\ndefault:\r\nr = -EINVAL;\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic enum omapfb_update_mode omap_lcdc_get_update_mode(void)\r\n{\r\nreturn lcdc.update_mode;\r\n}\r\nstatic void omap_lcdc_suspend(void)\r\n{\r\nomap_lcdc_set_update_mode(OMAPFB_UPDATE_DISABLED);\r\n}\r\nstatic void omap_lcdc_resume(void)\r\n{\r\nomap_lcdc_set_update_mode(OMAPFB_AUTO_UPDATE);\r\n}\r\nstatic void omap_lcdc_get_caps(int plane, struct omapfb_caps *caps)\r\n{\r\nreturn;\r\n}\r\nint omap_lcdc_set_dma_callback(void (*callback)(void *data), void *data)\r\n{\r\nBUG_ON(callback == NULL);\r\nif (lcdc.dma_callback)\r\nreturn -EBUSY;\r\nelse {\r\nlcdc.dma_callback = callback;\r\nlcdc.dma_callback_data = data;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap_lcdc_free_dma_callback(void)\r\n{\r\nlcdc.dma_callback = NULL;\r\n}\r\nstatic void lcdc_dma_handler(u16 status, void *data)\r\n{\r\nif (lcdc.dma_callback)\r\nlcdc.dma_callback(lcdc.dma_callback_data);\r\n}\r\nstatic int mmap_kern(void)\r\n{\r\nstruct vm_struct *kvma;\r\nstruct vm_area_struct vma;\r\npgprot_t pgprot;\r\nunsigned long vaddr;\r\nkvma = get_vm_area(lcdc.vram_size, VM_IOREMAP);\r\nif (kvma == NULL) {\r\ndev_err(lcdc.fbdev->dev, "can't get kernel vm area\n");\r\nreturn -ENOMEM;\r\n}\r\nvma.vm_mm = &init_mm;\r\nvaddr = (unsigned long)kvma->addr;\r\nvma.vm_start = vaddr;\r\nvma.vm_end = vaddr + lcdc.vram_size;\r\npgprot = pgprot_writecombine(pgprot_kernel);\r\nif (io_remap_pfn_range(&vma, vaddr,\r\nlcdc.vram_phys >> PAGE_SHIFT,\r\nlcdc.vram_size, pgprot) < 0) {\r\ndev_err(lcdc.fbdev->dev, "kernel mmap for FB memory failed\n");\r\nreturn -EAGAIN;\r\n}\r\nlcdc.vram_virt = (void *)vaddr;\r\nreturn 0;\r\n}\r\nstatic void unmap_kern(void)\r\n{\r\nvunmap(lcdc.vram_virt);\r\n}\r\nstatic int alloc_palette_ram(void)\r\n{\r\nlcdc.palette_virt = dma_alloc_writecombine(lcdc.fbdev->dev,\r\nMAX_PALETTE_SIZE, &lcdc.palette_phys, GFP_KERNEL);\r\nif (lcdc.palette_virt == NULL) {\r\ndev_err(lcdc.fbdev->dev, "failed to alloc palette memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(lcdc.palette_virt, 0, MAX_PALETTE_SIZE);\r\nreturn 0;\r\n}\r\nstatic void free_palette_ram(void)\r\n{\r\ndma_free_writecombine(lcdc.fbdev->dev, MAX_PALETTE_SIZE,\r\nlcdc.palette_virt, lcdc.palette_phys);\r\n}\r\nstatic int alloc_fbmem(struct omapfb_mem_region *region)\r\n{\r\nint bpp;\r\nint frame_size;\r\nstruct lcd_panel *panel = lcdc.fbdev->panel;\r\nbpp = panel->bpp;\r\nif (bpp == 12)\r\nbpp = 16;\r\nframe_size = PAGE_ALIGN(panel->x_res * bpp / 8 * panel->y_res);\r\nif (region->size > frame_size)\r\nframe_size = region->size;\r\nlcdc.vram_size = frame_size;\r\nlcdc.vram_virt = dma_alloc_writecombine(lcdc.fbdev->dev,\r\nlcdc.vram_size, &lcdc.vram_phys, GFP_KERNEL);\r\nif (lcdc.vram_virt == NULL) {\r\ndev_err(lcdc.fbdev->dev, "unable to allocate FB DMA memory\n");\r\nreturn -ENOMEM;\r\n}\r\nregion->size = frame_size;\r\nregion->paddr = lcdc.vram_phys;\r\nregion->vaddr = lcdc.vram_virt;\r\nregion->alloc = 1;\r\nmemset(lcdc.vram_virt, 0, lcdc.vram_size);\r\nreturn 0;\r\n}\r\nstatic void free_fbmem(void)\r\n{\r\ndma_free_writecombine(lcdc.fbdev->dev, lcdc.vram_size,\r\nlcdc.vram_virt, lcdc.vram_phys);\r\n}\r\nstatic int setup_fbmem(struct omapfb_mem_desc *req_md)\r\n{\r\nint r;\r\nif (!req_md->region_cnt) {\r\ndev_err(lcdc.fbdev->dev, "no memory regions defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (req_md->region_cnt > 1) {\r\ndev_err(lcdc.fbdev->dev, "only one plane is supported\n");\r\nreq_md->region_cnt = 1;\r\n}\r\nif (req_md->region[0].paddr == 0) {\r\nlcdc.fbmem_allocated = 1;\r\nif ((r = alloc_fbmem(&req_md->region[0])) < 0)\r\nreturn r;\r\nreturn 0;\r\n}\r\nlcdc.vram_phys = req_md->region[0].paddr;\r\nlcdc.vram_size = req_md->region[0].size;\r\nif ((r = mmap_kern()) < 0)\r\nreturn r;\r\ndev_dbg(lcdc.fbdev->dev, "vram at %08x size %08lx mapped to 0x%p\n",\r\nlcdc.vram_phys, lcdc.vram_size, lcdc.vram_virt);\r\nreturn 0;\r\n}\r\nstatic void cleanup_fbmem(void)\r\n{\r\nif (lcdc.fbmem_allocated)\r\nfree_fbmem();\r\nelse\r\nunmap_kern();\r\n}\r\nstatic int omap_lcdc_init(struct omapfb_device *fbdev, int ext_mode,\r\nstruct omapfb_mem_desc *req_vram)\r\n{\r\nint r;\r\nu32 l;\r\nint rate;\r\nstruct clk *tc_ck;\r\nlcdc.irq_mask = 0;\r\nlcdc.fbdev = fbdev;\r\nlcdc.ext_mode = ext_mode;\r\nl = 0;\r\nomap_writel(l, OMAP_LCDC_CONTROL);\r\nlcdc.lcd_ck = clk_get(fbdev->dev, "lcd_ck");\r\nif (IS_ERR(lcdc.lcd_ck)) {\r\ndev_err(fbdev->dev, "unable to access LCD clock\n");\r\nr = PTR_ERR(lcdc.lcd_ck);\r\ngoto fail0;\r\n}\r\ntc_ck = clk_get(fbdev->dev, "tc_ck");\r\nif (IS_ERR(tc_ck)) {\r\ndev_err(fbdev->dev, "unable to access TC clock\n");\r\nr = PTR_ERR(tc_ck);\r\ngoto fail1;\r\n}\r\nrate = clk_get_rate(tc_ck);\r\nclk_put(tc_ck);\r\nif (machine_is_ams_delta())\r\nrate /= 4;\r\nif (machine_is_omap_h3())\r\nrate /= 3;\r\nr = clk_set_rate(lcdc.lcd_ck, rate);\r\nif (r) {\r\ndev_err(fbdev->dev, "failed to adjust LCD rate\n");\r\ngoto fail1;\r\n}\r\nclk_enable(lcdc.lcd_ck);\r\nr = request_irq(OMAP_LCDC_IRQ, lcdc_irq_handler, 0, MODULE_NAME, fbdev);\r\nif (r) {\r\ndev_err(fbdev->dev, "unable to get IRQ\n");\r\ngoto fail2;\r\n}\r\nr = omap_request_lcd_dma(lcdc_dma_handler, NULL);\r\nif (r) {\r\ndev_err(fbdev->dev, "unable to get LCD DMA\n");\r\ngoto fail3;\r\n}\r\nomap_set_lcd_dma_single_transfer(ext_mode);\r\nomap_set_lcd_dma_ext_controller(ext_mode);\r\nif (!ext_mode)\r\nif ((r = alloc_palette_ram()) < 0)\r\ngoto fail4;\r\nif ((r = setup_fbmem(req_vram)) < 0)\r\ngoto fail5;\r\npr_info("omapfb: LCDC initialized\n");\r\nreturn 0;\r\nfail5:\r\nif (!ext_mode)\r\nfree_palette_ram();\r\nfail4:\r\nomap_free_lcd_dma();\r\nfail3:\r\nfree_irq(OMAP_LCDC_IRQ, lcdc.fbdev);\r\nfail2:\r\nclk_disable(lcdc.lcd_ck);\r\nfail1:\r\nclk_put(lcdc.lcd_ck);\r\nfail0:\r\nreturn r;\r\n}\r\nstatic void omap_lcdc_cleanup(void)\r\n{\r\nif (!lcdc.ext_mode)\r\nfree_palette_ram();\r\ncleanup_fbmem();\r\nomap_free_lcd_dma();\r\nfree_irq(OMAP_LCDC_IRQ, lcdc.fbdev);\r\nclk_disable(lcdc.lcd_ck);\r\nclk_put(lcdc.lcd_ck);\r\n}
