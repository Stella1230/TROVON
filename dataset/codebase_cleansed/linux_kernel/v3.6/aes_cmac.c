static void gf_mulx(u8 *pad)\r\n{\r\nint i, carry;\r\ncarry = pad[0] & 0x80;\r\nfor (i = 0; i < AES_BLOCK_SIZE - 1; i++)\r\npad[i] = (pad[i] << 1) | (pad[i + 1] >> 7);\r\npad[AES_BLOCK_SIZE - 1] <<= 1;\r\nif (carry)\r\npad[AES_BLOCK_SIZE - 1] ^= 0x87;\r\n}\r\nstatic void aes_128_cmac_vector(struct crypto_cipher *tfm, size_t num_elem,\r\nconst u8 *addr[], const size_t *len, u8 *mac)\r\n{\r\nu8 scratch[2 * AES_BLOCK_SIZE];\r\nu8 *cbc, *pad;\r\nconst u8 *pos, *end;\r\nsize_t i, e, left, total_len;\r\ncbc = scratch;\r\npad = scratch + AES_BLOCK_SIZE;\r\nmemset(cbc, 0, AES_BLOCK_SIZE);\r\ntotal_len = 0;\r\nfor (e = 0; e < num_elem; e++)\r\ntotal_len += len[e];\r\nleft = total_len;\r\ne = 0;\r\npos = addr[0];\r\nend = pos + len[0];\r\nwhile (left >= AES_BLOCK_SIZE) {\r\nfor (i = 0; i < AES_BLOCK_SIZE; i++) {\r\ncbc[i] ^= *pos++;\r\nif (pos >= end) {\r\ne++;\r\npos = addr[e];\r\nend = pos + len[e];\r\n}\r\n}\r\nif (left > AES_BLOCK_SIZE)\r\ncrypto_cipher_encrypt_one(tfm, cbc, cbc);\r\nleft -= AES_BLOCK_SIZE;\r\n}\r\nmemset(pad, 0, AES_BLOCK_SIZE);\r\ncrypto_cipher_encrypt_one(tfm, pad, pad);\r\ngf_mulx(pad);\r\nif (left || total_len == 0) {\r\nfor (i = 0; i < left; i++) {\r\ncbc[i] ^= *pos++;\r\nif (pos >= end) {\r\ne++;\r\npos = addr[e];\r\nend = pos + len[e];\r\n}\r\n}\r\ncbc[left] ^= 0x80;\r\ngf_mulx(pad);\r\n}\r\nfor (i = 0; i < AES_BLOCK_SIZE; i++)\r\npad[i] ^= cbc[i];\r\ncrypto_cipher_encrypt_one(tfm, pad, pad);\r\nmemcpy(mac, pad, CMAC_TLEN);\r\n}\r\nvoid ieee80211_aes_cmac(struct crypto_cipher *tfm, const u8 *aad,\r\nconst u8 *data, size_t data_len, u8 *mic)\r\n{\r\nconst u8 *addr[3];\r\nsize_t len[3];\r\nu8 zero[CMAC_TLEN];\r\nmemset(zero, 0, CMAC_TLEN);\r\naddr[0] = aad;\r\nlen[0] = AAD_LEN;\r\naddr[1] = data;\r\nlen[1] = data_len - CMAC_TLEN;\r\naddr[2] = zero;\r\nlen[2] = CMAC_TLEN;\r\naes_128_cmac_vector(tfm, 3, addr, len, mic);\r\n}\r\nstruct crypto_cipher * ieee80211_aes_cmac_key_setup(const u8 key[])\r\n{\r\nstruct crypto_cipher *tfm;\r\ntfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);\r\nif (!IS_ERR(tfm))\r\ncrypto_cipher_setkey(tfm, key, AES_CMAC_KEY_LEN);\r\nreturn tfm;\r\n}\r\nvoid ieee80211_aes_cmac_key_free(struct crypto_cipher *tfm)\r\n{\r\ncrypto_free_cipher(tfm);\r\n}
