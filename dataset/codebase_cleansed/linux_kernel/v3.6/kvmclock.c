static int parse_no_kvmclock(char *arg)\r\n{\r\nkvmclock = 0;\r\nreturn 0;\r\n}\r\nstatic unsigned long kvm_get_wallclock(void)\r\n{\r\nstruct pvclock_vcpu_time_info *vcpu_time;\r\nstruct timespec ts;\r\nint low, high;\r\nlow = (int)__pa_symbol(&wall_clock);\r\nhigh = ((u64)__pa_symbol(&wall_clock) >> 32);\r\nnative_write_msr(msr_kvm_wall_clock, low, high);\r\nvcpu_time = &get_cpu_var(hv_clock);\r\npvclock_read_wallclock(&wall_clock, vcpu_time, &ts);\r\nput_cpu_var(hv_clock);\r\nreturn ts.tv_sec;\r\n}\r\nstatic int kvm_set_wallclock(unsigned long now)\r\n{\r\nreturn -1;\r\n}\r\nstatic cycle_t kvm_clock_read(void)\r\n{\r\nstruct pvclock_vcpu_time_info *src;\r\ncycle_t ret;\r\npreempt_disable_notrace();\r\nsrc = &__get_cpu_var(hv_clock);\r\nret = pvclock_clocksource_read(src);\r\npreempt_enable_notrace();\r\nreturn ret;\r\n}\r\nstatic cycle_t kvm_clock_get_cycles(struct clocksource *cs)\r\n{\r\nreturn kvm_clock_read();\r\n}\r\nstatic unsigned long kvm_get_tsc_khz(void)\r\n{\r\nstruct pvclock_vcpu_time_info *src;\r\nsrc = &per_cpu(hv_clock, 0);\r\nreturn pvclock_tsc_khz(src);\r\n}\r\nstatic void kvm_get_preset_lpj(void)\r\n{\r\nunsigned long khz;\r\nu64 lpj;\r\nkhz = kvm_get_tsc_khz();\r\nlpj = ((u64)khz * 1000);\r\ndo_div(lpj, HZ);\r\npreset_lpj = lpj;\r\n}\r\nbool kvm_check_and_clear_guest_paused(void)\r\n{\r\nbool ret = false;\r\nstruct pvclock_vcpu_time_info *src;\r\nsrc = &__get_cpu_var(hv_clock);\r\nif ((src->flags & PVCLOCK_GUEST_STOPPED) != 0) {\r\n__this_cpu_and(hv_clock.flags, ~PVCLOCK_GUEST_STOPPED);\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nint kvm_register_clock(char *txt)\r\n{\r\nint cpu = smp_processor_id();\r\nint low, high, ret;\r\nlow = (int)__pa(&per_cpu(hv_clock, cpu)) | 1;\r\nhigh = ((u64)__pa(&per_cpu(hv_clock, cpu)) >> 32);\r\nret = native_write_msr_safe(msr_kvm_system_time, low, high);\r\nprintk(KERN_INFO "kvm-clock: cpu %d, msr %x:%x, %s\n",\r\ncpu, high, low, txt);\r\nreturn ret;\r\n}\r\nstatic void kvm_save_sched_clock_state(void)\r\n{\r\n}\r\nstatic void kvm_restore_sched_clock_state(void)\r\n{\r\nkvm_register_clock("primary cpu clock, resume");\r\n}\r\nstatic void __cpuinit kvm_setup_secondary_clock(void)\r\n{\r\nWARN_ON(kvm_register_clock("secondary cpu clock"));\r\n}\r\nstatic void kvm_crash_shutdown(struct pt_regs *regs)\r\n{\r\nnative_write_msr(msr_kvm_system_time, 0, 0);\r\nkvm_disable_steal_time();\r\nnative_machine_crash_shutdown(regs);\r\n}\r\nstatic void kvm_shutdown(void)\r\n{\r\nnative_write_msr(msr_kvm_system_time, 0, 0);\r\nkvm_disable_steal_time();\r\nnative_machine_shutdown();\r\n}\r\nvoid __init kvmclock_init(void)\r\n{\r\nif (!kvm_para_available())\r\nreturn;\r\nif (kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) {\r\nmsr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;\r\nmsr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;\r\n} else if (!(kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))\r\nreturn;\r\nprintk(KERN_INFO "kvm-clock: Using msrs %x and %x",\r\nmsr_kvm_system_time, msr_kvm_wall_clock);\r\nif (kvm_register_clock("boot clock"))\r\nreturn;\r\npv_time_ops.sched_clock = kvm_clock_read;\r\nx86_platform.calibrate_tsc = kvm_get_tsc_khz;\r\nx86_platform.get_wallclock = kvm_get_wallclock;\r\nx86_platform.set_wallclock = kvm_set_wallclock;\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nx86_cpuinit.early_percpu_clock_init =\r\nkvm_setup_secondary_clock;\r\n#endif\r\nx86_platform.save_sched_clock_state = kvm_save_sched_clock_state;\r\nx86_platform.restore_sched_clock_state = kvm_restore_sched_clock_state;\r\nmachine_ops.shutdown = kvm_shutdown;\r\n#ifdef CONFIG_KEXEC\r\nmachine_ops.crash_shutdown = kvm_crash_shutdown;\r\n#endif\r\nkvm_get_preset_lpj();\r\nclocksource_register_hz(&kvm_clock, NSEC_PER_SEC);\r\npv_info.paravirt_enabled = 1;\r\npv_info.name = "KVM";\r\nif (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))\r\npvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);\r\n}
