static int __hw_addr_create_ex(struct netdev_hw_addr_list *list,\r\nunsigned char *addr, int addr_len,\r\nunsigned char addr_type, bool global)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nint alloc_size;\r\nalloc_size = sizeof(*ha);\r\nif (alloc_size < L1_CACHE_BYTES)\r\nalloc_size = L1_CACHE_BYTES;\r\nha = kmalloc(alloc_size, GFP_ATOMIC);\r\nif (!ha)\r\nreturn -ENOMEM;\r\nmemcpy(ha->addr, addr, addr_len);\r\nha->type = addr_type;\r\nha->refcount = 1;\r\nha->global_use = global;\r\nha->synced = false;\r\nlist_add_tail_rcu(&ha->list, &list->list);\r\nlist->count++;\r\nreturn 0;\r\n}\r\nstatic int __hw_addr_add_ex(struct netdev_hw_addr_list *list,\r\nunsigned char *addr, int addr_len,\r\nunsigned char addr_type, bool global)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nif (addr_len > MAX_ADDR_LEN)\r\nreturn -EINVAL;\r\nlist_for_each_entry(ha, &list->list, list) {\r\nif (!memcmp(ha->addr, addr, addr_len) &&\r\nha->type == addr_type) {\r\nif (global) {\r\nif (ha->global_use)\r\nreturn 0;\r\nelse\r\nha->global_use = true;\r\n}\r\nha->refcount++;\r\nreturn 0;\r\n}\r\n}\r\nreturn __hw_addr_create_ex(list, addr, addr_len, addr_type, global);\r\n}\r\nstatic int __hw_addr_add(struct netdev_hw_addr_list *list, unsigned char *addr,\r\nint addr_len, unsigned char addr_type)\r\n{\r\nreturn __hw_addr_add_ex(list, addr, addr_len, addr_type, false);\r\n}\r\nstatic int __hw_addr_del_ex(struct netdev_hw_addr_list *list,\r\nunsigned char *addr, int addr_len,\r\nunsigned char addr_type, bool global)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nlist_for_each_entry(ha, &list->list, list) {\r\nif (!memcmp(ha->addr, addr, addr_len) &&\r\n(ha->type == addr_type || !addr_type)) {\r\nif (global) {\r\nif (!ha->global_use)\r\nbreak;\r\nelse\r\nha->global_use = false;\r\n}\r\nif (--ha->refcount)\r\nreturn 0;\r\nlist_del_rcu(&ha->list);\r\nkfree_rcu(ha, rcu_head);\r\nlist->count--;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int __hw_addr_del(struct netdev_hw_addr_list *list, unsigned char *addr,\r\nint addr_len, unsigned char addr_type)\r\n{\r\nreturn __hw_addr_del_ex(list, addr, addr_len, addr_type, false);\r\n}\r\nint __hw_addr_add_multiple(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr_list *from_list,\r\nint addr_len, unsigned char addr_type)\r\n{\r\nint err;\r\nstruct netdev_hw_addr *ha, *ha2;\r\nunsigned char type;\r\nlist_for_each_entry(ha, &from_list->list, list) {\r\ntype = addr_type ? addr_type : ha->type;\r\nerr = __hw_addr_add(to_list, ha->addr, addr_len, type);\r\nif (err)\r\ngoto unroll;\r\n}\r\nreturn 0;\r\nunroll:\r\nlist_for_each_entry(ha2, &from_list->list, list) {\r\nif (ha2 == ha)\r\nbreak;\r\ntype = addr_type ? addr_type : ha2->type;\r\n__hw_addr_del(to_list, ha2->addr, addr_len, type);\r\n}\r\nreturn err;\r\n}\r\nvoid __hw_addr_del_multiple(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr_list *from_list,\r\nint addr_len, unsigned char addr_type)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nunsigned char type;\r\nlist_for_each_entry(ha, &from_list->list, list) {\r\ntype = addr_type ? addr_type : ha->type;\r\n__hw_addr_del(to_list, ha->addr, addr_len, type);\r\n}\r\n}\r\nint __hw_addr_sync(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr_list *from_list,\r\nint addr_len)\r\n{\r\nint err = 0;\r\nstruct netdev_hw_addr *ha, *tmp;\r\nlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\r\nif (!ha->synced) {\r\nerr = __hw_addr_add(to_list, ha->addr,\r\naddr_len, ha->type);\r\nif (err)\r\nbreak;\r\nha->synced = true;\r\nha->refcount++;\r\n} else if (ha->refcount == 1) {\r\n__hw_addr_del(to_list, ha->addr, addr_len, ha->type);\r\n__hw_addr_del(from_list, ha->addr, addr_len, ha->type);\r\n}\r\n}\r\nreturn err;\r\n}\r\nvoid __hw_addr_unsync(struct netdev_hw_addr_list *to_list,\r\nstruct netdev_hw_addr_list *from_list,\r\nint addr_len)\r\n{\r\nstruct netdev_hw_addr *ha, *tmp;\r\nlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\r\nif (ha->synced) {\r\n__hw_addr_del(to_list, ha->addr,\r\naddr_len, ha->type);\r\nha->synced = false;\r\n__hw_addr_del(from_list, ha->addr,\r\naddr_len, ha->type);\r\n}\r\n}\r\n}\r\nvoid __hw_addr_flush(struct netdev_hw_addr_list *list)\r\n{\r\nstruct netdev_hw_addr *ha, *tmp;\r\nlist_for_each_entry_safe(ha, tmp, &list->list, list) {\r\nlist_del_rcu(&ha->list);\r\nkfree_rcu(ha, rcu_head);\r\n}\r\nlist->count = 0;\r\n}\r\nvoid __hw_addr_init(struct netdev_hw_addr_list *list)\r\n{\r\nINIT_LIST_HEAD(&list->list);\r\nlist->count = 0;\r\n}\r\nvoid dev_addr_flush(struct net_device *dev)\r\n{\r\n__hw_addr_flush(&dev->dev_addrs);\r\ndev->dev_addr = NULL;\r\n}\r\nint dev_addr_init(struct net_device *dev)\r\n{\r\nunsigned char addr[MAX_ADDR_LEN];\r\nstruct netdev_hw_addr *ha;\r\nint err;\r\n__hw_addr_init(&dev->dev_addrs);\r\nmemset(addr, 0, sizeof(addr));\r\nerr = __hw_addr_add(&dev->dev_addrs, addr, sizeof(addr),\r\nNETDEV_HW_ADDR_T_LAN);\r\nif (!err) {\r\nha = list_first_entry(&dev->dev_addrs.list,\r\nstruct netdev_hw_addr, list);\r\ndev->dev_addr = ha->addr;\r\n}\r\nreturn err;\r\n}\r\nint dev_addr_add(struct net_device *dev, unsigned char *addr,\r\nunsigned char addr_type)\r\n{\r\nint err;\r\nASSERT_RTNL();\r\nerr = __hw_addr_add(&dev->dev_addrs, addr, dev->addr_len, addr_type);\r\nif (!err)\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\r\nreturn err;\r\n}\r\nint dev_addr_del(struct net_device *dev, unsigned char *addr,\r\nunsigned char addr_type)\r\n{\r\nint err;\r\nstruct netdev_hw_addr *ha;\r\nASSERT_RTNL();\r\nha = list_first_entry(&dev->dev_addrs.list,\r\nstruct netdev_hw_addr, list);\r\nif (ha->addr == dev->dev_addr && ha->refcount == 1)\r\nreturn -ENOENT;\r\nerr = __hw_addr_del(&dev->dev_addrs, addr, dev->addr_len,\r\naddr_type);\r\nif (!err)\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\r\nreturn err;\r\n}\r\nint dev_addr_add_multiple(struct net_device *to_dev,\r\nstruct net_device *from_dev,\r\nunsigned char addr_type)\r\n{\r\nint err;\r\nASSERT_RTNL();\r\nif (from_dev->addr_len != to_dev->addr_len)\r\nreturn -EINVAL;\r\nerr = __hw_addr_add_multiple(&to_dev->dev_addrs, &from_dev->dev_addrs,\r\nto_dev->addr_len, addr_type);\r\nif (!err)\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, to_dev);\r\nreturn err;\r\n}\r\nint dev_addr_del_multiple(struct net_device *to_dev,\r\nstruct net_device *from_dev,\r\nunsigned char addr_type)\r\n{\r\nASSERT_RTNL();\r\nif (from_dev->addr_len != to_dev->addr_len)\r\nreturn -EINVAL;\r\n__hw_addr_del_multiple(&to_dev->dev_addrs, &from_dev->dev_addrs,\r\nto_dev->addr_len, addr_type);\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, to_dev);\r\nreturn 0;\r\n}\r\nint dev_uc_add_excl(struct net_device *dev, unsigned char *addr)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nlist_for_each_entry(ha, &dev->uc.list, list) {\r\nif (!memcmp(ha->addr, addr, dev->addr_len) &&\r\nha->type == NETDEV_HW_ADDR_T_UNICAST) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nerr = __hw_addr_create_ex(&dev->uc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_UNICAST, true);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nout:\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_uc_add(struct net_device *dev, unsigned char *addr)\r\n{\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nerr = __hw_addr_add(&dev->uc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_UNICAST);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_uc_del(struct net_device *dev, unsigned char *addr)\r\n{\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nerr = __hw_addr_del(&dev->uc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_UNICAST);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_uc_sync(struct net_device *to, struct net_device *from)\r\n{\r\nint err = 0;\r\nif (to->addr_len != from->addr_len)\r\nreturn -EINVAL;\r\nnetif_addr_lock_nested(to);\r\nerr = __hw_addr_sync(&to->uc, &from->uc, to->addr_len);\r\nif (!err)\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nreturn err;\r\n}\r\nvoid dev_uc_unsync(struct net_device *to, struct net_device *from)\r\n{\r\nif (to->addr_len != from->addr_len)\r\nreturn;\r\nnetif_addr_lock_bh(from);\r\nnetif_addr_lock_nested(to);\r\n__hw_addr_unsync(&to->uc, &from->uc, to->addr_len);\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nnetif_addr_unlock_bh(from);\r\n}\r\nvoid dev_uc_flush(struct net_device *dev)\r\n{\r\nnetif_addr_lock_bh(dev);\r\n__hw_addr_flush(&dev->uc);\r\nnetif_addr_unlock_bh(dev);\r\n}\r\nvoid dev_uc_init(struct net_device *dev)\r\n{\r\n__hw_addr_init(&dev->uc);\r\n}\r\nint dev_mc_add_excl(struct net_device *dev, unsigned char *addr)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nlist_for_each_entry(ha, &dev->mc.list, list) {\r\nif (!memcmp(ha->addr, addr, dev->addr_len) &&\r\nha->type == NETDEV_HW_ADDR_T_MULTICAST) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nerr = __hw_addr_create_ex(&dev->mc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_MULTICAST, true);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nout:\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nstatic int __dev_mc_add(struct net_device *dev, unsigned char *addr,\r\nbool global)\r\n{\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nerr = __hw_addr_add_ex(&dev->mc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_MULTICAST, global);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_mc_add(struct net_device *dev, unsigned char *addr)\r\n{\r\nreturn __dev_mc_add(dev, addr, false);\r\n}\r\nint dev_mc_add_global(struct net_device *dev, unsigned char *addr)\r\n{\r\nreturn __dev_mc_add(dev, addr, true);\r\n}\r\nstatic int __dev_mc_del(struct net_device *dev, unsigned char *addr,\r\nbool global)\r\n{\r\nint err;\r\nnetif_addr_lock_bh(dev);\r\nerr = __hw_addr_del_ex(&dev->mc, addr, dev->addr_len,\r\nNETDEV_HW_ADDR_T_MULTICAST, global);\r\nif (!err)\r\n__dev_set_rx_mode(dev);\r\nnetif_addr_unlock_bh(dev);\r\nreturn err;\r\n}\r\nint dev_mc_del(struct net_device *dev, unsigned char *addr)\r\n{\r\nreturn __dev_mc_del(dev, addr, false);\r\n}\r\nint dev_mc_del_global(struct net_device *dev, unsigned char *addr)\r\n{\r\nreturn __dev_mc_del(dev, addr, true);\r\n}\r\nint dev_mc_sync(struct net_device *to, struct net_device *from)\r\n{\r\nint err = 0;\r\nif (to->addr_len != from->addr_len)\r\nreturn -EINVAL;\r\nnetif_addr_lock_nested(to);\r\nerr = __hw_addr_sync(&to->mc, &from->mc, to->addr_len);\r\nif (!err)\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nreturn err;\r\n}\r\nvoid dev_mc_unsync(struct net_device *to, struct net_device *from)\r\n{\r\nif (to->addr_len != from->addr_len)\r\nreturn;\r\nnetif_addr_lock_bh(from);\r\nnetif_addr_lock_nested(to);\r\n__hw_addr_unsync(&to->mc, &from->mc, to->addr_len);\r\n__dev_set_rx_mode(to);\r\nnetif_addr_unlock(to);\r\nnetif_addr_unlock_bh(from);\r\n}\r\nvoid dev_mc_flush(struct net_device *dev)\r\n{\r\nnetif_addr_lock_bh(dev);\r\n__hw_addr_flush(&dev->mc);\r\nnetif_addr_unlock_bh(dev);\r\n}\r\nvoid dev_mc_init(struct net_device *dev)\r\n{\r\n__hw_addr_init(&dev->mc);\r\n}\r\nstatic int dev_mc_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nstruct net_device *dev = v;\r\nif (v == SEQ_START_TOKEN)\r\nreturn 0;\r\nnetif_addr_lock_bh(dev);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint i;\r\nseq_printf(seq, "%-4d %-15s %-5d %-5d ", dev->ifindex,\r\ndev->name, ha->refcount, ha->global_use);\r\nfor (i = 0; i < dev->addr_len; i++)\r\nseq_printf(seq, "%02x", ha->addr[i]);\r\nseq_putc(seq, '\n');\r\n}\r\nnetif_addr_unlock_bh(dev);\r\nreturn 0;\r\n}\r\nstatic int dev_mc_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &dev_mc_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int __net_init dev_mc_net_init(struct net *net)\r\n{\r\nif (!proc_net_fops_create(net, "dev_mcast", 0, &dev_mc_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit dev_mc_net_exit(struct net *net)\r\n{\r\nproc_net_remove(net, "dev_mcast");\r\n}\r\nvoid __init dev_mcast_init(void)\r\n{\r\nregister_pernet_subsys(&dev_mc_net_ops);\r\n}
