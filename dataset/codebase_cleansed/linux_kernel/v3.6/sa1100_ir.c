static unsigned sa1100_irda_dma_xferred(struct sa1100_buf *buf)\r\n{\r\nstruct dma_chan *chan = buf->chan;\r\nstruct dma_tx_state state;\r\nenum dma_status status;\r\nstatus = chan->device->device_tx_status(chan, buf->cookie, &state);\r\nif (status != DMA_PAUSED)\r\nreturn 0;\r\nreturn sg_dma_len(&buf->sg) - state.residue;\r\n}\r\nstatic int sa1100_irda_dma_request(struct device *dev, struct sa1100_buf *buf,\r\nconst char *name, struct dma_slave_config *cfg)\r\n{\r\ndma_cap_mask_t m;\r\nint ret;\r\ndma_cap_zero(m);\r\ndma_cap_set(DMA_SLAVE, m);\r\nbuf->chan = dma_request_channel(m, sa11x0_dma_filter_fn, (void *)name);\r\nif (!buf->chan) {\r\ndev_err(dev, "unable to request DMA channel for %s\n",\r\nname);\r\nreturn -ENOENT;\r\n}\r\nret = dmaengine_slave_config(buf->chan, cfg);\r\nif (ret)\r\ndev_warn(dev, "DMA slave_config for %s returned %d\n",\r\nname, ret);\r\nbuf->dev = buf->chan->device->dev;\r\nreturn 0;\r\n}\r\nstatic void sa1100_irda_dma_start(struct sa1100_buf *buf,\r\nenum dma_transfer_direction dir, dma_async_tx_callback cb, void *cb_p)\r\n{\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *chan = buf->chan;\r\ndesc = dmaengine_prep_slave_sg(chan, &buf->sg, 1, dir,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (desc) {\r\ndesc->callback = cb;\r\ndesc->callback_param = cb_p;\r\nbuf->cookie = dmaengine_submit(desc);\r\ndma_async_issue_pending(chan);\r\n}\r\n}\r\nstatic int sa1100_irda_rx_alloc(struct sa1100_irda *si)\r\n{\r\nif (si->dma_rx.skb)\r\nreturn 0;\r\nsi->dma_rx.skb = alloc_skb(HPSIR_MAX_RXLEN + 1, GFP_ATOMIC);\r\nif (!si->dma_rx.skb) {\r\nprintk(KERN_ERR "sa1100_ir: out of memory for RX SKB\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(si->dma_rx.skb, 1);\r\nsg_set_buf(&si->dma_rx.sg, si->dma_rx.skb->data, HPSIR_MAX_RXLEN);\r\nif (dma_map_sg(si->dma_rx.dev, &si->dma_rx.sg, 1, DMA_FROM_DEVICE) == 0) {\r\ndev_kfree_skb_any(si->dma_rx.skb);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sa1100_irda_rx_dma_start(struct sa1100_irda *si)\r\n{\r\nif (!si->dma_rx.skb) {\r\nprintk(KERN_ERR "sa1100_ir: rx buffer went missing\n");\r\nreturn;\r\n}\r\nSer2HSCR0 = HSCR0_HSSP;\r\ndmaengine_terminate_all(si->dma_rx.chan);\r\nsa1100_irda_dma_start(&si->dma_rx, DMA_DEV_TO_MEM, NULL, NULL);\r\nSer2HSCR0 = HSCR0_HSSP | HSCR0_RXE;\r\n}\r\nstatic void sa1100_irda_check_speed(struct sa1100_irda *si)\r\n{\r\nif (si->newspeed) {\r\nsa1100_irda_set_speed(si, si->newspeed);\r\nsi->newspeed = 0;\r\n}\r\n}\r\nstatic void sa1100_irda_sirtxdma_irq(void *id)\r\n{\r\nstruct net_device *dev = id;\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\ndma_unmap_sg(si->dma_tx.dev, &si->dma_tx.sg, 1, DMA_TO_DEVICE);\r\ndev_kfree_skb(si->dma_tx.skb);\r\nsi->dma_tx.skb = NULL;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += sg_dma_len(&si->dma_tx.sg);\r\ndo\r\nrmb();\r\nwhile (Ser2UTSR1 & UTSR1_TBY);\r\nSer2UTSR0 = UTSR0_REB | UTSR0_RBB | UTSR0_RID;\r\nSer2UTCR3 = UTCR3_RIE | UTCR3_RXE | UTCR3_TXE;\r\nsa1100_irda_check_speed(si);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int sa1100_irda_sir_tx_start(struct sk_buff *skb, struct net_device *dev,\r\nstruct sa1100_irda *si)\r\n{\r\nsi->tx_buff.data = si->tx_buff.head;\r\nsi->tx_buff.len = async_wrap_skb(skb, si->tx_buff.data,\r\nsi->tx_buff.truesize);\r\nsi->dma_tx.skb = skb;\r\nsg_set_buf(&si->dma_tx.sg, si->tx_buff.data, si->tx_buff.len);\r\nif (dma_map_sg(si->dma_tx.dev, &si->dma_tx.sg, 1, DMA_TO_DEVICE) == 0) {\r\nsi->dma_tx.skb = NULL;\r\nnetif_wake_queue(dev);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nsa1100_irda_dma_start(&si->dma_tx, DMA_MEM_TO_DEV, sa1100_irda_sirtxdma_irq, dev);\r\nSer2UTCR3 = UTCR3_TXE;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t sa1100_irda_sir_irq(struct net_device *dev, struct sa1100_irda *si)\r\n{\r\nint status;\r\nstatus = Ser2UTSR0;\r\nwhile (status & UTSR0_EIF) {\r\nint stat, data;\r\nstat = Ser2UTSR1;\r\ndata = Ser2UTDR;\r\nif (stat & (UTSR1_FRE | UTSR1_ROR)) {\r\ndev->stats.rx_errors++;\r\nif (stat & UTSR1_FRE)\r\ndev->stats.rx_frame_errors++;\r\nif (stat & UTSR1_ROR)\r\ndev->stats.rx_fifo_errors++;\r\n} else\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, data);\r\nstatus = Ser2UTSR0;\r\n}\r\nSer2UTSR0 = status & (UTSR0_RID | UTSR0_RBB | UTSR0_REB);\r\nif (status & UTSR0_RFS) {\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, Ser2UTDR);\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, Ser2UTDR);\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, Ser2UTDR);\r\n}\r\nif (status & (UTSR0_RFS | UTSR0_RID)) {\r\ndo {\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff,\r\nSer2UTDR);\r\n} while (Ser2UTSR1 & UTSR1_RNE);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sa1100_irda_firtxdma_irq(void *id)\r\n{\r\nstruct net_device *dev = id;\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\ndo\r\nrmb();\r\nwhile (!(Ser2HSSR0 & HSSR0_TUR) || Ser2HSSR1 & HSSR1_TBY);\r\nSer2HSSR0 = HSSR0_TUR;\r\nsa1100_irda_check_speed(si);\r\nsa1100_irda_rx_dma_start(si);\r\nskb = si->dma_tx.skb;\r\nif (skb) {\r\ndma_unmap_sg(si->dma_tx.dev, &si->dma_tx.sg, 1,\r\nDMA_TO_DEVICE);\r\ndev->stats.tx_packets ++;\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb_irq(skb);\r\nsi->dma_tx.skb = NULL;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int sa1100_irda_fir_tx_start(struct sk_buff *skb, struct net_device *dev,\r\nstruct sa1100_irda *si)\r\n{\r\nint mtt = irda_get_mtt(skb);\r\nsi->dma_tx.skb = skb;\r\nsg_set_buf(&si->dma_tx.sg, skb->data, skb->len);\r\nif (dma_map_sg(si->dma_tx.dev, &si->dma_tx.sg, 1, DMA_TO_DEVICE) == 0) {\r\nsi->dma_tx.skb = NULL;\r\nnetif_wake_queue(dev);\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nsa1100_irda_dma_start(&si->dma_tx, DMA_MEM_TO_DEV, sa1100_irda_firtxdma_irq, dev);\r\nif (mtt)\r\nudelay(mtt);\r\nSer2HSCR0 = HSCR0_HSSP | HSCR0_TXE;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void sa1100_irda_fir_error(struct sa1100_irda *si, struct net_device *dev)\r\n{\r\nstruct sk_buff *skb = si->dma_rx.skb;\r\nunsigned int len, stat, data;\r\nif (!skb) {\r\nprintk(KERN_ERR "sa1100_ir: SKB is NULL!\n");\r\nreturn;\r\n}\r\nlen = sa1100_irda_dma_xferred(&si->dma_rx);\r\nif (len > HPSIR_MAX_RXLEN)\r\nlen = HPSIR_MAX_RXLEN;\r\ndma_unmap_sg(si->dma_rx.dev, &si->dma_rx.sg, 1, DMA_FROM_DEVICE);\r\ndo {\r\nstat = Ser2HSSR1;\r\nrmb();\r\ndata = Ser2HSDR;\r\nif (stat & (HSSR1_CRE | HSSR1_ROR)) {\r\ndev->stats.rx_errors++;\r\nif (stat & HSSR1_CRE)\r\ndev->stats.rx_crc_errors++;\r\nif (stat & HSSR1_ROR)\r\ndev->stats.rx_frame_errors++;\r\n} else\r\nskb->data[len++] = data;\r\nif (stat & HSSR1_EOF)\r\nbreak;\r\n} while (Ser2HSSR0 & HSSR0_EIF);\r\nif (stat & HSSR1_EOF) {\r\nsi->dma_rx.skb = NULL;\r\nskb_put(skb, len);\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nsa1100_irda_rx_alloc(si);\r\nnetif_rx(skb);\r\n} else {\r\ndma_map_sg(si->dma_rx.dev, &si->dma_rx.sg, 1, DMA_FROM_DEVICE);\r\n}\r\n}\r\nstatic irqreturn_t sa1100_irda_fir_irq(struct net_device *dev, struct sa1100_irda *si)\r\n{\r\ndmaengine_pause(si->dma_rx.chan);\r\nif (Ser2HSSR0 & (HSSR0_FRE | HSSR0_RAB)) {\r\ndev->stats.rx_errors++;\r\nif (Ser2HSSR0 & HSSR0_FRE)\r\ndev->stats.rx_frame_errors++;\r\nSer2HSCR0 = HSCR0_HSSP;\r\nSer2HSSR0 = HSSR0_FRE | HSSR0_RAB;\r\n}\r\nif (Ser2HSSR0 & HSSR0_EIF)\r\nsa1100_irda_fir_error(si, dev);\r\nsa1100_irda_rx_dma_start(si);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sa1100_irda_set_speed(struct sa1100_irda *si, int speed)\r\n{\r\nunsigned long flags;\r\nint brd, ret = -EINVAL;\r\nswitch (speed) {\r\ncase 9600: case 19200: case 38400:\r\ncase 57600: case 115200:\r\nbrd = 3686400 / (16 * speed) - 1;\r\nif (IS_FIR(si)) {\r\ndmaengine_terminate_all(si->dma_rx.chan);\r\ndmaengine_slave_config(si->dma_tx.chan,\r\n&sa1100_irda_sir_tx);\r\n}\r\nlocal_irq_save(flags);\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = HSCR0_UART;\r\nSer2UTCR1 = brd >> 8;\r\nSer2UTCR2 = brd;\r\nSer2UTSR0 = UTSR0_REB | UTSR0_RBB | UTSR0_RID;\r\nSer2UTCR3 = UTCR3_RIE | UTCR3_RXE | UTCR3_TXE;\r\nif (si->pdata->set_speed)\r\nsi->pdata->set_speed(si->dev, speed);\r\nsi->speed = speed;\r\nsi->tx_start = sa1100_irda_sir_tx_start;\r\nsi->irq = sa1100_irda_sir_irq;\r\nlocal_irq_restore(flags);\r\nret = 0;\r\nbreak;\r\ncase 4000000:\r\nif (!IS_FIR(si))\r\ndmaengine_slave_config(si->dma_tx.chan,\r\n&sa1100_irda_fir_tx);\r\nlocal_irq_save(flags);\r\nSer2HSSR0 = 0xff;\r\nSer2HSCR0 = HSCR0_HSSP;\r\nSer2UTCR3 = 0;\r\nsi->speed = speed;\r\nsi->tx_start = sa1100_irda_fir_tx_start;\r\nsi->irq = sa1100_irda_fir_irq;\r\nif (si->pdata->set_speed)\r\nsi->pdata->set_speed(si->dev, speed);\r\nsa1100_irda_rx_alloc(si);\r\nsa1100_irda_rx_dma_start(si);\r\nlocal_irq_restore(flags);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\n__sa1100_irda_set_power(struct sa1100_irda *si, unsigned int state)\r\n{\r\nint ret = 0;\r\nif (si->pdata->set_power)\r\nret = si->pdata->set_power(si->dev, state);\r\nreturn ret;\r\n}\r\nstatic inline int\r\nsa1100_set_power(struct sa1100_irda *si, unsigned int state)\r\n{\r\nint ret;\r\nret = __sa1100_irda_set_power(si, state);\r\nif (ret == 0)\r\nsi->power = state;\r\nreturn ret;\r\n}\r\nstatic irqreturn_t sa1100_irda_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nreturn si->irq(dev, si);\r\n}\r\nstatic int sa1100_irda_hard_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nint speed = irda_get_next_speed(skb);\r\nif (speed != si->speed && speed != -1)\r\nsi->newspeed = speed;\r\nif (skb->len == 0) {\r\nsa1100_irda_check_speed(si);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\nBUG_ON(si->dma_tx.skb);\r\nreturn si->tx_start(skb, dev, si);\r\n}\r\nstatic int\r\nsa1100_irda_ioctl(struct net_device *dev, struct ifreq *ifreq, int cmd)\r\n{\r\nstruct if_irda_req *rq = (struct if_irda_req *)ifreq;\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (si->open) {\r\nret = sa1100_irda_set_speed(si,\r\nrq->ifr_baudrate);\r\n} else {\r\nprintk("sa1100_irda_ioctl: SIOCSBANDWIDTH: !netif_running\n");\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nret = -EPERM;\r\nif (capable(CAP_NET_ADMIN)) {\r\nirda_device_set_media_busy(dev, TRUE);\r\nret = 0;\r\n}\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nrq->ifr_receiving = IS_FIR(si) ? 0\r\n: si->rx_buff.state != OUTSIDE_FRAME;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sa1100_irda_startup(struct sa1100_irda *si)\r\n{\r\nint ret;\r\nif (si->pdata->startup) {\r\nret = si->pdata->startup(si->dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nPPSR &= ~PPC_TXD2;\r\nPSDR &= ~PPC_TXD2;\r\nPPDR |= PPC_TXD2;\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = HSCR0_UART;\r\nSer2UTCR4 = si->utcr4;\r\nSer2UTCR0 = UTCR0_8BitData;\r\nSer2HSCR2 = HSCR2_TrDataH | HSCR2_RcDataL;\r\nSer2UTSR0 = UTSR0_REB | UTSR0_RBB | UTSR0_RID;\r\nret = sa1100_irda_set_speed(si, si->speed = 9600);\r\nif (ret) {\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = 0;\r\nif (si->pdata->shutdown)\r\nsi->pdata->shutdown(si->dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void sa1100_irda_shutdown(struct sa1100_irda *si)\r\n{\r\ndmaengine_terminate_all(si->dma_rx.chan);\r\ndmaengine_terminate_all(si->dma_tx.chan);\r\nSer2UTCR3 = 0;\r\nSer2HSCR0 = 0;\r\nif (si->pdata->shutdown)\r\nsi->pdata->shutdown(si->dev);\r\n}\r\nstatic int sa1100_irda_start(struct net_device *dev)\r\n{\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nint err;\r\nsi->speed = 9600;\r\nerr = sa1100_irda_dma_request(si->dev, &si->dma_rx, "Ser2ICPRc",\r\n&sa1100_irda_fir_rx);\r\nif (err)\r\ngoto err_rx_dma;\r\nerr = sa1100_irda_dma_request(si->dev, &si->dma_tx, "Ser2ICPTr",\r\n&sa1100_irda_sir_tx);\r\nif (err)\r\ngoto err_tx_dma;\r\nerr = sa1100_irda_startup(si);\r\nif (err)\r\ngoto err_startup;\r\nsi->irlap = irlap_open(dev, &si->qos, "sa1100");\r\nerr = -ENOMEM;\r\nif (!si->irlap)\r\ngoto err_irlap;\r\nerr = request_irq(dev->irq, sa1100_irda_irq, 0, dev->name, dev);\r\nif (err)\r\ngoto err_irq;\r\nsi->open = 1;\r\nsa1100_set_power(si, power_level);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nerr_irq:\r\nirlap_close(si->irlap);\r\nerr_irlap:\r\nsi->open = 0;\r\nsa1100_irda_shutdown(si);\r\nerr_startup:\r\ndma_release_channel(si->dma_tx.chan);\r\nerr_tx_dma:\r\ndma_release_channel(si->dma_rx.chan);\r\nerr_rx_dma:\r\nreturn err;\r\n}\r\nstatic int sa1100_irda_stop(struct net_device *dev)\r\n{\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nnetif_stop_queue(dev);\r\nsi->open = 0;\r\nsa1100_irda_shutdown(si);\r\nskb = si->dma_rx.skb;\r\nif (skb) {\r\ndma_unmap_sg(si->dma_rx.dev, &si->dma_rx.sg, 1,\r\nDMA_FROM_DEVICE);\r\ndev_kfree_skb(skb);\r\nsi->dma_rx.skb = NULL;\r\n}\r\nskb = si->dma_tx.skb;\r\nif (skb) {\r\ndma_unmap_sg(si->dma_tx.dev, &si->dma_tx.sg, 1,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb(skb);\r\nsi->dma_tx.skb = NULL;\r\n}\r\nif (si->irlap) {\r\nirlap_close(si->irlap);\r\nsi->irlap = NULL;\r\n}\r\ndma_release_channel(si->dma_tx.chan);\r\ndma_release_channel(si->dma_rx.chan);\r\nfree_irq(dev->irq, dev);\r\nsa1100_set_power(si, 0);\r\nreturn 0;\r\n}\r\nstatic int sa1100_irda_init_iobuf(iobuff_t *io, int size)\r\n{\r\nio->head = kmalloc(size, GFP_KERNEL | GFP_DMA);\r\nif (io->head != NULL) {\r\nio->truesize = size;\r\nio->in_frame = FALSE;\r\nio->state = OUTSIDE_FRAME;\r\nio->data = io->head;\r\n}\r\nreturn io->head ? 0 : -ENOMEM;\r\n}\r\nstatic int sa1100_irda_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct sa1100_irda *si;\r\nunsigned int baudrate_mask;\r\nint err, irq;\r\nif (!pdev->dev.platform_data)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn irq < 0 ? irq : -ENXIO;\r\nerr = request_mem_region(__PREG(Ser2UTCR0), 0x24, "IrDA") ? 0 : -EBUSY;\r\nif (err)\r\ngoto err_mem_1;\r\nerr = request_mem_region(__PREG(Ser2HSCR0), 0x1c, "IrDA") ? 0 : -EBUSY;\r\nif (err)\r\ngoto err_mem_2;\r\nerr = request_mem_region(__PREG(Ser2HSCR2), 0x04, "IrDA") ? 0 : -EBUSY;\r\nif (err)\r\ngoto err_mem_3;\r\ndev = alloc_irdadev(sizeof(struct sa1100_irda));\r\nif (!dev)\r\ngoto err_mem_4;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nsi = netdev_priv(dev);\r\nsi->dev = &pdev->dev;\r\nsi->pdata = pdev->dev.platform_data;\r\nsg_init_table(&si->dma_rx.sg, 1);\r\nsg_init_table(&si->dma_tx.sg, 1);\r\nerr = sa1100_irda_init_iobuf(&si->rx_buff, 14384);\r\nif (err)\r\ngoto err_mem_5;\r\nerr = sa1100_irda_init_iobuf(&si->tx_buff, IRDA_SIR_MAX_FRAME);\r\nif (err)\r\ngoto err_mem_5;\r\ndev->netdev_ops = &sa1100_irda_netdev_ops;\r\ndev->irq = irq;\r\nirda_init_max_qos_capabilies(&si->qos);\r\nbaudrate_mask = IR_9600;\r\nswitch (max_rate) {\r\ncase 4000000: baudrate_mask |= IR_4000000 << 8;\r\ncase 115200: baudrate_mask |= IR_115200;\r\ncase 57600: baudrate_mask |= IR_57600;\r\ncase 38400: baudrate_mask |= IR_38400;\r\ncase 19200: baudrate_mask |= IR_19200;\r\n}\r\nsi->qos.baud_rate.bits &= baudrate_mask;\r\nsi->qos.min_turn_time.bits = 7;\r\nirda_qos_bits_to_value(&si->qos);\r\nsi->utcr4 = UTCR4_HPSIR;\r\nif (tx_lpm)\r\nsi->utcr4 |= UTCR4_Z1_6us;\r\nSer2UTCR3 = 0;\r\nSer2UTCR4 = si->utcr4;\r\nSer2HSCR0 = HSCR0_UART;\r\nerr = register_netdev(dev);\r\nif (err == 0)\r\nplatform_set_drvdata(pdev, dev);\r\nif (err) {\r\nerr_mem_5:\r\nkfree(si->tx_buff.head);\r\nkfree(si->rx_buff.head);\r\nfree_netdev(dev);\r\nerr_mem_4:\r\nrelease_mem_region(__PREG(Ser2HSCR2), 0x04);\r\nerr_mem_3:\r\nrelease_mem_region(__PREG(Ser2HSCR0), 0x1c);\r\nerr_mem_2:\r\nrelease_mem_region(__PREG(Ser2UTCR0), 0x24);\r\n}\r\nerr_mem_1:\r\nreturn err;\r\n}\r\nstatic int sa1100_irda_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nif (dev) {\r\nstruct sa1100_irda *si = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nkfree(si->tx_buff.head);\r\nkfree(si->rx_buff.head);\r\nfree_netdev(dev);\r\n}\r\nrelease_mem_region(__PREG(Ser2HSCR2), 0x04);\r\nrelease_mem_region(__PREG(Ser2HSCR0), 0x1c);\r\nrelease_mem_region(__PREG(Ser2UTCR0), 0x24);\r\nreturn 0;\r\n}\r\nstatic int sa1100_irda_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct sa1100_irda *si;\r\nif (!dev)\r\nreturn 0;\r\nsi = netdev_priv(dev);\r\nif (si->open) {\r\nnetif_device_detach(dev);\r\ndisable_irq(dev->irq);\r\nsa1100_irda_shutdown(si);\r\n__sa1100_irda_set_power(si, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sa1100_irda_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct sa1100_irda *si;\r\nif (!dev)\r\nreturn 0;\r\nsi = netdev_priv(dev);\r\nif (si->open) {\r\nif (si->newspeed) {\r\nsi->speed = si->newspeed;\r\nsi->newspeed = 0;\r\n}\r\nsa1100_irda_startup(si);\r\n__sa1100_irda_set_power(si, si->power);\r\nenable_irq(dev->irq);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sa1100_irda_init(void)\r\n{\r\nif (power_level < 1)\r\npower_level = 1;\r\nif (power_level > 3)\r\npower_level = 3;\r\nreturn platform_driver_register(&sa1100ir_driver);\r\n}\r\nstatic void __exit sa1100_irda_exit(void)\r\n{\r\nplatform_driver_unregister(&sa1100ir_driver);\r\n}
