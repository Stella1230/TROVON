struct net_device * __init ni5010_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct ni5010_local));\r\nint *port;\r\nint err = 0;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio = dev->base_addr;\r\nirq = dev->irq;\r\n}\r\nPRINTK2((KERN_DEBUG "%s: Entering ni5010_probe\n", dev->name));\r\nif (io > 0x1ff) {\r\nerr = ni5010_probe1(dev, io);\r\n} else if (io != 0) {\r\nerr = -ENXIO;\r\n} else {\r\n#ifdef FULL_IODETECT\r\nfor (io=0x200; io<0x400 && ni5010_probe1(dev, io) ; io+=0x20)\r\n;\r\nif (io == 0x400)\r\nerr = -ENODEV;\r\n#else\r\nfor (port = ports; *port && ni5010_probe1(dev, *port); port++)\r\n;\r\nif (!*port)\r\nerr = -ENODEV;\r\n#endif\r\n}\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\nrelease_region(dev->base_addr, NI5010_IO_EXTENT);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic inline int rd_port(int ioaddr)\r\n{\r\ninb(IE_RBUF);\r\nreturn inb(IE_SAPROM);\r\n}\r\nstatic void __init trigger_irq(int ioaddr)\r\n{\r\noutb(0x00, EDLC_RESET);\r\noutb(0x00, IE_RESET);\r\noutb(0x00, EDLC_XMASK);\r\noutb(0x00, EDLC_RMASK);\r\noutb(0xff, EDLC_XCLR);\r\noutb(0xff, EDLC_RCLR);\r\noutb(XMD_IG_PAR | XMD_T_MODE | XMD_LBC, EDLC_XMODE);\r\noutb(RMD_BROADCAST, EDLC_RMODE);\r\noutb(XM_ALL, EDLC_XMASK);\r\nudelay(50);\r\noutb(MM_EN_XMT|MM_MUX, IE_MMODE);\r\n}\r\nstatic int __init ni5010_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nstatic unsigned version_printed;\r\nstruct ni5010_local *lp;\r\nint i;\r\nunsigned int data = 0;\r\nint boguscount = 40;\r\nint err = -ENODEV;\r\ndev->base_addr = ioaddr;\r\ndev->irq = irq;\r\nif (!request_region(ioaddr, NI5010_IO_EXTENT, boardname))\r\nreturn -EBUSY;\r\nPRINTK2((KERN_DEBUG "%s: entering ni5010_probe1(%#3x)\n",\r\ndev->name, ioaddr));\r\nif (inb(ioaddr+0) == 0xff)\r\ngoto out;\r\nwhile ( (rd_port(ioaddr) & rd_port(ioaddr) & rd_port(ioaddr) &\r\nrd_port(ioaddr) & rd_port(ioaddr) & rd_port(ioaddr)) != 0xff)\r\n{\r\nif (boguscount-- == 0)\r\ngoto out;\r\n}\r\nPRINTK2((KERN_DEBUG "%s: I/O #1 passed!\n", dev->name));\r\nfor (i=0; i<32; i++)\r\nif ( (data = rd_port(ioaddr)) != 0xff) break;\r\nif (data==0xff)\r\ngoto out;\r\nPRINTK2((KERN_DEBUG "%s: I/O #2 passed!\n", dev->name));\r\nif ((data != SA_ADDR0) || (rd_port(ioaddr) != SA_ADDR1) ||\r\n(rd_port(ioaddr) != SA_ADDR2))\r\ngoto out;\r\nfor (i=0; i<4; i++)\r\nrd_port(ioaddr);\r\nif ( (rd_port(ioaddr) != NI5010_MAGICVAL1) ||\r\n(rd_port(ioaddr) != NI5010_MAGICVAL2) )\r\ngoto out;\r\nPRINTK2((KERN_DEBUG "%s: I/O #3 passed!\n", dev->name));\r\nif (NI5010_DEBUG && version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version);\r\nprintk("NI5010 ethercard probe at 0x%x: ", ioaddr);\r\ndev->base_addr = ioaddr;\r\nfor (i=0; i<6; i++) {\r\noutw(i, IE_GP);\r\ndev->dev_addr[i] = inb(IE_SAPROM);\r\n}\r\nprintk("%pM ", dev->dev_addr);\r\nPRINTK2((KERN_DEBUG "%s: I/O #4 passed!\n", dev->name));\r\n#ifdef JUMPERED_INTERRUPTS\r\nif (dev->irq == 0xff)\r\n;\r\nelse if (dev->irq < 2) {\r\nunsigned long irq_mask;\r\nPRINTK2((KERN_DEBUG "%s: I/O #5 passed!\n", dev->name));\r\nirq_mask = probe_irq_on();\r\ntrigger_irq(ioaddr);\r\nmdelay(20);\r\ndev->irq = probe_irq_off(irq_mask);\r\nPRINTK2((KERN_DEBUG "%s: I/O #6 passed!\n", dev->name));\r\nif (dev->irq == 0) {\r\nerr = -EAGAIN;\r\nprintk(KERN_WARNING "%s: no IRQ found!\n", dev->name);\r\ngoto out;\r\n}\r\nPRINTK2((KERN_DEBUG "%s: I/O #7 passed!\n", dev->name));\r\n} else if (dev->irq == 2) {\r\ndev->irq = 9;\r\n}\r\n#endif\r\nPRINTK2((KERN_DEBUG "%s: I/O #9 passed!\n", dev->name));\r\nlp = netdev_priv(dev);\r\nspin_lock_init(&lp->lock);\r\nPRINTK2((KERN_DEBUG "%s: I/O #10 passed!\n", dev->name));\r\nif (!bufsize_rcv) {\r\noutb(1, IE_MMODE);\r\noutw(0, IE_GP);\r\noutb(0, IE_RBUF);\r\nfor (i = 1; i < 0xff; i++) {\r\noutw(i << 8, IE_GP);\r\noutb(i, IE_RBUF);\r\noutw(0x0, IE_GP);\r\ndata = inb(IE_RBUF);\r\nif (data == i) break;\r\n}\r\nbufsize_rcv = i << 8;\r\noutw(0, IE_GP);\r\noutb(0, IE_RBUF);\r\n}\r\nprintk("-> bufsize rcv/xmt=%d/%d\n", bufsize_rcv, NI5010_BUFSIZE);\r\ndev->netdev_ops = &ni5010_netdev_ops;\r\ndev->watchdog_timeo = HZ/20;\r\ndev->flags &= ~IFF_MULTICAST;\r\noutb(0, EDLC_RMASK);\r\noutb(0, EDLC_XMASK);\r\noutb(0xff, EDLC_RCLR);\r\noutb(0xff, EDLC_XCLR);\r\nprintk(KERN_INFO "%s: NI5010 found at 0x%x, using IRQ %d", dev->name, ioaddr, dev->irq);\r\nif (dev->dma)\r\nprintk(" & DMA %d", dev->dma);\r\nprintk(".\n");\r\nreturn 0;\r\nout:\r\nrelease_region(dev->base_addr, NI5010_IO_EXTENT);\r\nreturn err;\r\n}\r\nstatic int ni5010_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nint i;\r\nPRINTK2((KERN_DEBUG "%s: entering ni5010_open()\n", dev->name));\r\nif (request_irq(dev->irq, ni5010_interrupt, 0, boardname, dev)) {\r\nprintk(KERN_WARNING "%s: Cannot get irq %#2x\n", dev->name, dev->irq);\r\nreturn -EAGAIN;\r\n}\r\nPRINTK3((KERN_DEBUG "%s: passed open() #1\n", dev->name));\r\n#ifdef JUMPERED_DMA\r\nif (request_dma(dev->dma, cardname)) {\r\nprintk(KERN_WARNING "%s: Cannot get dma %#2x\n", dev->name, dev->dma);\r\nfree_irq(dev->irq, NULL);\r\nreturn -EAGAIN;\r\n}\r\n#endif\r\nPRINTK3((KERN_DEBUG "%s: passed open() #2\n", dev->name));\r\noutb(RS_RESET, EDLC_RESET);\r\noutb(0, IE_RESET);\r\noutb(XMD_LBC, EDLC_XMODE);\r\nPRINTK3((KERN_DEBUG "%s: passed open() #3\n", dev->name));\r\nfor(i = 0;i < 6; i++) {\r\noutb(dev->dev_addr[i], EDLC_ADDR + i);\r\n}\r\nPRINTK3((KERN_DEBUG "%s: Initialising ni5010\n", dev->name));\r\noutb(0, EDLC_XMASK);\r\noutb(XMD_IG_PAR | XMD_T_MODE | XMD_LBC, EDLC_XMODE);\r\noutb(0xff, EDLC_XCLR);\r\noutb(RMD_BROADCAST, EDLC_RMODE);\r\nreset_receiver(dev);\r\noutb(0, EDLC_RESET);\r\nnetif_start_queue(dev);\r\nif (NI5010_DEBUG) ni5010_show_registers(dev);\r\nPRINTK((KERN_DEBUG "%s: open successful\n", dev->name));\r\nreturn 0;\r\n}\r\nstatic void reset_receiver(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nPRINTK3((KERN_DEBUG "%s: resetting receiver\n", dev->name));\r\noutw(0, IE_GP);\r\noutb(0xff, EDLC_RCLR);\r\noutb(0, IE_MMODE);\r\noutb(MM_EN_RCV, IE_MMODE);\r\noutb(0xff, EDLC_RMASK);\r\n}\r\nstatic void ni5010_timeout(struct net_device *dev)\r\n{\r\nprintk(KERN_WARNING "%s: transmit timed out, %s?\n", dev->name,\r\ntx_done(dev) ? "IRQ conflict" : "network cable problem");\r\nchipset_init(dev, 1);\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int ni5010_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nPRINTK2((KERN_DEBUG "%s: entering ni5010_send_packet\n", dev->name));\r\nnetif_stop_queue(dev);\r\nhardware_send_packet(dev, (unsigned char *)skb->data, skb->len, length-skb->len);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t ni5010_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct ni5010_local *lp;\r\nint ioaddr, status;\r\nint xmit_was_error = 0;\r\nPRINTK2((KERN_DEBUG "%s: entering ni5010_interrupt\n", dev->name));\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nspin_lock(&lp->lock);\r\nstatus = inb(IE_ISTAT);\r\nPRINTK3((KERN_DEBUG "%s: IE_ISTAT = %#02x\n", dev->name, status));\r\nif ((status & IS_R_INT) == 0) ni5010_rx(dev);\r\nif ((status & IS_X_INT) == 0) {\r\nxmit_was_error = process_xmt_interrupt(dev);\r\n}\r\nif ((status & IS_DMA_INT) == 0) {\r\nPRINTK((KERN_DEBUG "%s: DMA complete (?)\n", dev->name));\r\noutb(0, IE_DMA_RST);\r\n}\r\nif (!xmit_was_error)\r\nreset_receiver(dev);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dump_packet(void *buf, int len)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "Packet length = %#4x\n", len);\r\nfor (i = 0; i < len; i++){\r\nif (i % 16 == 0) printk(KERN_DEBUG "%#4.4x", i);\r\nif (i % 2 == 0) printk(" ");\r\nprintk("%2.2x", ((unsigned char *)buf)[i]);\r\nif (i % 16 == 15) printk("\n");\r\n}\r\nprintk("\n");\r\n}\r\nstatic void ni5010_rx(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nunsigned char rcv_stat;\r\nstruct sk_buff *skb;\r\nint i_pkt_size;\r\nPRINTK2((KERN_DEBUG "%s: entering ni5010_rx()\n", dev->name));\r\nrcv_stat = inb(EDLC_RSTAT);\r\nPRINTK3((KERN_DEBUG "%s: EDLC_RSTAT = %#2x\n", dev->name, rcv_stat));\r\nif ( (rcv_stat & RS_VALID_BITS) != RS_PKT_OK) {\r\nPRINTK((KERN_INFO "%s: receive error.\n", dev->name));\r\ndev->stats.rx_errors++;\r\nif (rcv_stat & RS_RUNT) dev->stats.rx_length_errors++;\r\nif (rcv_stat & RS_ALIGN) dev->stats.rx_frame_errors++;\r\nif (rcv_stat & RS_CRC_ERR) dev->stats.rx_crc_errors++;\r\nif (rcv_stat & RS_OFLW) dev->stats.rx_fifo_errors++;\r\noutb(0xff, EDLC_RCLR);\r\nreturn;\r\n}\r\noutb(0xff, EDLC_RCLR);\r\ni_pkt_size = inw(IE_RCNT);\r\nif (i_pkt_size > ETH_FRAME_LEN || i_pkt_size < 10 ) {\r\nPRINTK((KERN_DEBUG "%s: Packet size error, packet size = %#4.4x\n",\r\ndev->name, i_pkt_size));\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\nreturn;\r\n}\r\nskb = netdev_alloc_skb(dev, i_pkt_size + 3);\r\nif (skb == NULL) {\r\nprintk(KERN_WARNING "%s: Memory squeeze, dropping packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\noutb(MM_MUX, IE_MMODE);\r\noutw(0, IE_GP);\r\ninsb(IE_RBUF, skb_put(skb, i_pkt_size), i_pkt_size);\r\nif (NI5010_DEBUG >= 4)\r\ndump_packet(skb->data, skb->len);\r\nskb->protocol = eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += i_pkt_size;\r\nPRINTK2((KERN_DEBUG "%s: Received packet, size=%#4.4x\n",\r\ndev->name, i_pkt_size));\r\n}\r\nstatic int process_xmt_interrupt(struct net_device *dev)\r\n{\r\nstruct ni5010_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nint xmit_stat;\r\nPRINTK2((KERN_DEBUG "%s: entering process_xmt_interrupt\n", dev->name));\r\nxmit_stat = inb(EDLC_XSTAT);\r\nPRINTK3((KERN_DEBUG "%s: EDLC_XSTAT = %2.2x\n", dev->name, xmit_stat));\r\noutb(0, EDLC_XMASK);\r\noutb(0xff, EDLC_XCLR);\r\nif (xmit_stat & XS_COLL){\r\nPRINTK((KERN_DEBUG "%s: collision detected, retransmitting\n",\r\ndev->name));\r\noutw(NI5010_BUFSIZE - lp->o_pkt_size, IE_GP);\r\noutb(MM_EN_XMT | MM_MUX, IE_MMODE);\r\noutb(XM_ALL, EDLC_XMASK);\r\ndev->stats.collisions++;\r\nreturn 1;\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += lp->o_pkt_size;\r\nnetif_wake_queue(dev);\r\nPRINTK2((KERN_DEBUG "%s: sent packet, size=%#4.4x\n",\r\ndev->name, lp->o_pkt_size));\r\nreturn 0;\r\n}\r\nstatic int ni5010_close(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nPRINTK2((KERN_DEBUG "%s: entering ni5010_close\n", dev->name));\r\n#ifdef JUMPERED_INTERRUPTS\r\nfree_irq(dev->irq, NULL);\r\n#endif\r\noutb(0, IE_MMODE);\r\noutb(RS_RESET, EDLC_RESET);\r\nnetif_stop_queue(dev);\r\nPRINTK((KERN_DEBUG "%s: %s closed down\n", dev->name, boardname));\r\nreturn 0;\r\n}\r\nstatic void ni5010_set_multicast_list(struct net_device *dev)\r\n{\r\nshort ioaddr = dev->base_addr;\r\nPRINTK2((KERN_DEBUG "%s: entering set_multicast_list\n", dev->name));\r\nif (dev->flags & IFF_PROMISC || dev->flags & IFF_ALLMULTI ||\r\n!netdev_mc_empty(dev)) {\r\noutb(RMD_PROMISC, EDLC_RMODE);\r\nPRINTK((KERN_DEBUG "%s: Entering promiscuous mode\n", dev->name));\r\n} else {\r\nPRINTK((KERN_DEBUG "%s: Entering broadcast mode\n", dev->name));\r\noutb(RMD_BROADCAST, EDLC_RMODE);\r\n}\r\n}\r\nstatic void hardware_send_packet(struct net_device *dev, char *buf, int length, int pad)\r\n{\r\nstruct ni5010_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nunsigned int buf_offs;\r\nPRINTK2((KERN_DEBUG "%s: entering hardware_send_packet\n", dev->name));\r\nif (length > ETH_FRAME_LEN) {\r\nPRINTK((KERN_WARNING "%s: packet too large, not possible\n",\r\ndev->name));\r\nreturn;\r\n}\r\nif (NI5010_DEBUG) ni5010_show_registers(dev);\r\nif (inb(IE_ISTAT) & IS_EN_XMT) {\r\nPRINTK((KERN_WARNING "%s: sending packet while already transmitting, not possible\n",\r\ndev->name));\r\nreturn;\r\n}\r\nif (NI5010_DEBUG > 3) dump_packet(buf, length);\r\nbuf_offs = NI5010_BUFSIZE - length - pad;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nlp->o_pkt_size = length + pad;\r\noutb(0, EDLC_RMASK);\r\noutb(0, IE_MMODE);\r\noutb(0xff, EDLC_RCLR);\r\noutw(buf_offs, IE_GP);\r\noutsb(IE_XBUF, buf, length);\r\nwhile(pad--)\r\noutb(0, IE_XBUF);\r\noutw(buf_offs, IE_GP);\r\noutb(MM_EN_XMT | MM_MUX, IE_MMODE);\r\noutb(XM_ALL, EDLC_XMASK);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nnetif_wake_queue(dev);\r\nif (NI5010_DEBUG) ni5010_show_registers(dev);\r\n}\r\nstatic void chipset_init(struct net_device *dev, int startp)\r\n{\r\nPRINTK3((KERN_DEBUG "%s: doing NOTHING in chipset_init\n", dev->name));\r\n}\r\nstatic void ni5010_show_registers(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr;\r\nPRINTK3((KERN_DEBUG "%s: XSTAT %#2.2x\n", dev->name, inb(EDLC_XSTAT)));\r\nPRINTK3((KERN_DEBUG "%s: XMASK %#2.2x\n", dev->name, inb(EDLC_XMASK)));\r\nPRINTK3((KERN_DEBUG "%s: RSTAT %#2.2x\n", dev->name, inb(EDLC_RSTAT)));\r\nPRINTK3((KERN_DEBUG "%s: RMASK %#2.2x\n", dev->name, inb(EDLC_RMASK)));\r\nPRINTK3((KERN_DEBUG "%s: RMODE %#2.2x\n", dev->name, inb(EDLC_RMODE)));\r\nPRINTK3((KERN_DEBUG "%s: XMODE %#2.2x\n", dev->name, inb(EDLC_XMODE)));\r\nPRINTK3((KERN_DEBUG "%s: ISTAT %#2.2x\n", dev->name, inb(IE_ISTAT)));\r\n}\r\nstatic int __init ni5010_init_module(void)\r\n{\r\nPRINTK2((KERN_DEBUG "%s: entering init_module\n", boardname));\r\nif (io <= 0){\r\nprintk(KERN_WARNING "%s: Autoprobing for modules is hazardous, trying anyway..\n", boardname);\r\n}\r\nPRINTK2((KERN_DEBUG "%s: init_module irq=%#2x, io=%#3x\n", boardname, irq, io));\r\ndev_ni5010 = ni5010_probe(-1);\r\nif (IS_ERR(dev_ni5010))\r\nreturn PTR_ERR(dev_ni5010);\r\nreturn 0;\r\n}\r\nstatic void __exit ni5010_cleanup_module(void)\r\n{\r\nPRINTK2((KERN_DEBUG "%s: entering cleanup_module\n", boardname));\r\nunregister_netdev(dev_ni5010);\r\nrelease_region(dev_ni5010->base_addr, NI5010_IO_EXTENT);\r\nfree_netdev(dev_ni5010);\r\n}
