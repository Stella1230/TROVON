static void pch_phub_read_modify_write_reg(struct pch_phub_reg *chip,\r\nunsigned int reg_addr_offset,\r\nunsigned int data, unsigned int mask)\r\n{\r\nvoid __iomem *reg_addr = chip->pch_phub_base_address + reg_addr_offset;\r\niowrite32(((ioread32(reg_addr) & ~mask)) | data, reg_addr);\r\n}\r\nstatic void pch_phub_save_reg_conf(struct pci_dev *pdev)\r\n{\r\nunsigned int i;\r\nstruct pch_phub_reg *chip = pci_get_drvdata(pdev);\r\nvoid __iomem *p = chip->pch_phub_base_address;\r\nchip->phub_id_reg = ioread32(p + PCH_PHUB_ID_REG);\r\nchip->q_pri_val_reg = ioread32(p + PCH_PHUB_QUEUE_PRI_VAL_REG);\r\nchip->rc_q_maxsize_reg = ioread32(p + PCH_PHUB_RC_QUEUE_MAXSIZE_REG);\r\nchip->bri_q_maxsize_reg = ioread32(p + PCH_PHUB_BRI_QUEUE_MAXSIZE_REG);\r\nchip->comp_resp_timeout_reg =\r\nioread32(p + PCH_PHUB_COMP_RESP_TIMEOUT_REG);\r\nchip->bus_slave_control_reg =\r\nioread32(p + PCH_PHUB_BUS_SLAVE_CONTROL_REG);\r\nchip->deadlock_avoid_type_reg =\r\nioread32(p + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);\r\nchip->intpin_reg_wpermit_reg0 =\r\nioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);\r\nchip->intpin_reg_wpermit_reg1 =\r\nioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG1);\r\nchip->intpin_reg_wpermit_reg2 =\r\nioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG2);\r\nchip->intpin_reg_wpermit_reg3 =\r\nioread32(p + PCH_PHUB_INTPIN_REG_WPERMIT_REG3);\r\ndev_dbg(&pdev->dev, "%s : "\r\n"chip->phub_id_reg=%x, "\r\n"chip->q_pri_val_reg=%x, "\r\n"chip->rc_q_maxsize_reg=%x, "\r\n"chip->bri_q_maxsize_reg=%x, "\r\n"chip->comp_resp_timeout_reg=%x, "\r\n"chip->bus_slave_control_reg=%x, "\r\n"chip->deadlock_avoid_type_reg=%x, "\r\n"chip->intpin_reg_wpermit_reg0=%x, "\r\n"chip->intpin_reg_wpermit_reg1=%x, "\r\n"chip->intpin_reg_wpermit_reg2=%x, "\r\n"chip->intpin_reg_wpermit_reg3=%x\n", __func__,\r\nchip->phub_id_reg,\r\nchip->q_pri_val_reg,\r\nchip->rc_q_maxsize_reg,\r\nchip->bri_q_maxsize_reg,\r\nchip->comp_resp_timeout_reg,\r\nchip->bus_slave_control_reg,\r\nchip->deadlock_avoid_type_reg,\r\nchip->intpin_reg_wpermit_reg0,\r\nchip->intpin_reg_wpermit_reg1,\r\nchip->intpin_reg_wpermit_reg2,\r\nchip->intpin_reg_wpermit_reg3);\r\nfor (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {\r\nchip->int_reduce_control_reg[i] =\r\nioread32(p + PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE + 4 * i);\r\ndev_dbg(&pdev->dev, "%s : "\r\n"chip->int_reduce_control_reg[%d]=%x\n",\r\n__func__, i, chip->int_reduce_control_reg[i]);\r\n}\r\nchip->clkcfg_reg = ioread32(p + CLKCFG_REG_OFFSET);\r\nif ((chip->ioh_type == 2) || (chip->ioh_type == 4))\r\nchip->funcsel_reg = ioread32(p + FUNCSEL_REG_OFFSET);\r\n}\r\nstatic void pch_phub_restore_reg_conf(struct pci_dev *pdev)\r\n{\r\nunsigned int i;\r\nstruct pch_phub_reg *chip = pci_get_drvdata(pdev);\r\nvoid __iomem *p;\r\np = chip->pch_phub_base_address;\r\niowrite32(chip->phub_id_reg, p + PCH_PHUB_ID_REG);\r\niowrite32(chip->q_pri_val_reg, p + PCH_PHUB_QUEUE_PRI_VAL_REG);\r\niowrite32(chip->rc_q_maxsize_reg, p + PCH_PHUB_RC_QUEUE_MAXSIZE_REG);\r\niowrite32(chip->bri_q_maxsize_reg, p + PCH_PHUB_BRI_QUEUE_MAXSIZE_REG);\r\niowrite32(chip->comp_resp_timeout_reg,\r\np + PCH_PHUB_COMP_RESP_TIMEOUT_REG);\r\niowrite32(chip->bus_slave_control_reg,\r\np + PCH_PHUB_BUS_SLAVE_CONTROL_REG);\r\niowrite32(chip->deadlock_avoid_type_reg,\r\np + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);\r\niowrite32(chip->intpin_reg_wpermit_reg0,\r\np + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);\r\niowrite32(chip->intpin_reg_wpermit_reg1,\r\np + PCH_PHUB_INTPIN_REG_WPERMIT_REG1);\r\niowrite32(chip->intpin_reg_wpermit_reg2,\r\np + PCH_PHUB_INTPIN_REG_WPERMIT_REG2);\r\niowrite32(chip->intpin_reg_wpermit_reg3,\r\np + PCH_PHUB_INTPIN_REG_WPERMIT_REG3);\r\ndev_dbg(&pdev->dev, "%s : "\r\n"chip->phub_id_reg=%x, "\r\n"chip->q_pri_val_reg=%x, "\r\n"chip->rc_q_maxsize_reg=%x, "\r\n"chip->bri_q_maxsize_reg=%x, "\r\n"chip->comp_resp_timeout_reg=%x, "\r\n"chip->bus_slave_control_reg=%x, "\r\n"chip->deadlock_avoid_type_reg=%x, "\r\n"chip->intpin_reg_wpermit_reg0=%x, "\r\n"chip->intpin_reg_wpermit_reg1=%x, "\r\n"chip->intpin_reg_wpermit_reg2=%x, "\r\n"chip->intpin_reg_wpermit_reg3=%x\n", __func__,\r\nchip->phub_id_reg,\r\nchip->q_pri_val_reg,\r\nchip->rc_q_maxsize_reg,\r\nchip->bri_q_maxsize_reg,\r\nchip->comp_resp_timeout_reg,\r\nchip->bus_slave_control_reg,\r\nchip->deadlock_avoid_type_reg,\r\nchip->intpin_reg_wpermit_reg0,\r\nchip->intpin_reg_wpermit_reg1,\r\nchip->intpin_reg_wpermit_reg2,\r\nchip->intpin_reg_wpermit_reg3);\r\nfor (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {\r\niowrite32(chip->int_reduce_control_reg[i],\r\np + PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE + 4 * i);\r\ndev_dbg(&pdev->dev, "%s : "\r\n"chip->int_reduce_control_reg[%d]=%x\n",\r\n__func__, i, chip->int_reduce_control_reg[i]);\r\n}\r\niowrite32(chip->clkcfg_reg, p + CLKCFG_REG_OFFSET);\r\nif ((chip->ioh_type == 2) || (chip->ioh_type == 4))\r\niowrite32(chip->funcsel_reg, p + FUNCSEL_REG_OFFSET);\r\n}\r\nstatic void pch_phub_read_serial_rom(struct pch_phub_reg *chip,\r\nunsigned int offset_address, u8 *data)\r\n{\r\nvoid __iomem *mem_addr = chip->pch_phub_extrom_base_address +\r\noffset_address;\r\n*data = ioread8(mem_addr);\r\n}\r\nstatic int pch_phub_write_serial_rom(struct pch_phub_reg *chip,\r\nunsigned int offset_address, u8 data)\r\n{\r\nvoid __iomem *mem_addr = chip->pch_phub_extrom_base_address +\r\n(offset_address & PCH_WORD_ADDR_MASK);\r\nint i;\r\nunsigned int word_data;\r\nunsigned int pos;\r\nunsigned int mask;\r\npos = (offset_address % 4) * 8;\r\nmask = ~(0xFF << pos);\r\niowrite32(PCH_PHUB_ROM_WRITE_ENABLE,\r\nchip->pch_phub_extrom_base_address + PHUB_CONTROL);\r\nword_data = ioread32(mem_addr);\r\niowrite32((word_data & mask) | (u32)data << pos, mem_addr);\r\ni = 0;\r\nwhile (ioread8(chip->pch_phub_extrom_base_address +\r\nPHUB_STATUS) != 0x00) {\r\nmsleep(1);\r\nif (i == PHUB_TIMEOUT)\r\nreturn -ETIMEDOUT;\r\ni++;\r\n}\r\niowrite32(PCH_PHUB_ROM_WRITE_DISABLE,\r\nchip->pch_phub_extrom_base_address + PHUB_CONTROL);\r\nreturn 0;\r\n}\r\nstatic void pch_phub_read_serial_rom_val(struct pch_phub_reg *chip,\r\nunsigned int offset_address, u8 *data)\r\n{\r\nunsigned int mem_addr;\r\nmem_addr = chip->pch_mac_start_address +\r\npch_phub_mac_offset[offset_address];\r\npch_phub_read_serial_rom(chip, mem_addr, data);\r\n}\r\nstatic int pch_phub_write_serial_rom_val(struct pch_phub_reg *chip,\r\nunsigned int offset_address, u8 data)\r\n{\r\nint retval;\r\nunsigned int mem_addr;\r\nmem_addr = chip->pch_mac_start_address +\r\npch_phub_mac_offset[offset_address];\r\nretval = pch_phub_write_serial_rom(chip, mem_addr, data);\r\nreturn retval;\r\n}\r\nstatic int pch_phub_gbe_serial_rom_conf(struct pch_phub_reg *chip)\r\n{\r\nint retval;\r\nretval = pch_phub_write_serial_rom(chip, 0x0b, 0xbc);\r\nretval |= pch_phub_write_serial_rom(chip, 0x0a, 0x10);\r\nretval |= pch_phub_write_serial_rom(chip, 0x09, 0x01);\r\nretval |= pch_phub_write_serial_rom(chip, 0x08, 0x02);\r\nretval |= pch_phub_write_serial_rom(chip, 0x0f, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x0e, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x0d, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x0c, 0x80);\r\nretval |= pch_phub_write_serial_rom(chip, 0x13, 0xbc);\r\nretval |= pch_phub_write_serial_rom(chip, 0x12, 0x10);\r\nretval |= pch_phub_write_serial_rom(chip, 0x11, 0x01);\r\nretval |= pch_phub_write_serial_rom(chip, 0x10, 0x18);\r\nretval |= pch_phub_write_serial_rom(chip, 0x1b, 0xbc);\r\nretval |= pch_phub_write_serial_rom(chip, 0x1a, 0x10);\r\nretval |= pch_phub_write_serial_rom(chip, 0x19, 0x01);\r\nretval |= pch_phub_write_serial_rom(chip, 0x18, 0x19);\r\nretval |= pch_phub_write_serial_rom(chip, 0x23, 0xbc);\r\nretval |= pch_phub_write_serial_rom(chip, 0x22, 0x10);\r\nretval |= pch_phub_write_serial_rom(chip, 0x21, 0x01);\r\nretval |= pch_phub_write_serial_rom(chip, 0x20, 0x3a);\r\nretval |= pch_phub_write_serial_rom(chip, 0x27, 0x01);\r\nretval |= pch_phub_write_serial_rom(chip, 0x26, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x25, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x24, 0x00);\r\nreturn retval;\r\n}\r\nstatic int pch_phub_gbe_serial_rom_conf_mp(struct pch_phub_reg *chip)\r\n{\r\nint retval;\r\nu32 offset_addr;\r\noffset_addr = 0x200;\r\nretval = pch_phub_write_serial_rom(chip, 0x03 + offset_addr, 0xbc);\r\nretval |= pch_phub_write_serial_rom(chip, 0x02 + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x01 + offset_addr, 0x40);\r\nretval |= pch_phub_write_serial_rom(chip, 0x00 + offset_addr, 0x02);\r\nretval |= pch_phub_write_serial_rom(chip, 0x07 + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x06 + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x05 + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x04 + offset_addr, 0x80);\r\nretval |= pch_phub_write_serial_rom(chip, 0x0b + offset_addr, 0xbc);\r\nretval |= pch_phub_write_serial_rom(chip, 0x0a + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x09 + offset_addr, 0x40);\r\nretval |= pch_phub_write_serial_rom(chip, 0x08 + offset_addr, 0x18);\r\nretval |= pch_phub_write_serial_rom(chip, 0x13 + offset_addr, 0xbc);\r\nretval |= pch_phub_write_serial_rom(chip, 0x12 + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x11 + offset_addr, 0x40);\r\nretval |= pch_phub_write_serial_rom(chip, 0x10 + offset_addr, 0x19);\r\nretval |= pch_phub_write_serial_rom(chip, 0x1b + offset_addr, 0xbc);\r\nretval |= pch_phub_write_serial_rom(chip, 0x1a + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x19 + offset_addr, 0x40);\r\nretval |= pch_phub_write_serial_rom(chip, 0x18 + offset_addr, 0x3a);\r\nretval |= pch_phub_write_serial_rom(chip, 0x1f + offset_addr, 0x01);\r\nretval |= pch_phub_write_serial_rom(chip, 0x1e + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x1d + offset_addr, 0x00);\r\nretval |= pch_phub_write_serial_rom(chip, 0x1c + offset_addr, 0x00);\r\nreturn retval;\r\n}\r\nstatic void pch_phub_read_gbe_mac_addr(struct pch_phub_reg *chip, u8 *data)\r\n{\r\nint i;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\npch_phub_read_serial_rom_val(chip, i, &data[i]);\r\n}\r\nstatic int pch_phub_write_gbe_mac_addr(struct pch_phub_reg *chip, u8 *data)\r\n{\r\nint retval;\r\nint i;\r\nif ((chip->ioh_type == 1) || (chip->ioh_type == 5))\r\nretval = pch_phub_gbe_serial_rom_conf(chip);\r\nelse\r\nretval = pch_phub_gbe_serial_rom_conf_mp(chip);\r\nif (retval)\r\nreturn retval;\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nretval = pch_phub_write_serial_rom_val(chip, i, data[i]);\r\nif (retval)\r\nreturn retval;\r\n}\r\nreturn retval;\r\n}\r\nstatic ssize_t pch_phub_bin_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nunsigned int rom_signature;\r\nunsigned char rom_length;\r\nunsigned int tmp;\r\nunsigned int addr_offset;\r\nunsigned int orom_size;\r\nint ret;\r\nint err;\r\nssize_t rom_size;\r\nstruct pch_phub_reg *chip =\r\ndev_get_drvdata(container_of(kobj, struct device, kobj));\r\nret = mutex_lock_interruptible(&pch_phub_mutex);\r\nif (ret) {\r\nerr = -ERESTARTSYS;\r\ngoto return_err_nomutex;\r\n}\r\nchip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);\r\nif (!chip->pch_phub_extrom_base_address)\r\ngoto exrom_map_err;\r\npch_phub_read_serial_rom(chip, chip->pch_opt_rom_start_address,\r\n(unsigned char *)&rom_signature);\r\nrom_signature &= 0xff;\r\npch_phub_read_serial_rom(chip, chip->pch_opt_rom_start_address + 1,\r\n(unsigned char *)&tmp);\r\nrom_signature |= (tmp & 0xff) << 8;\r\nif (rom_signature == 0xAA55) {\r\npch_phub_read_serial_rom(chip,\r\nchip->pch_opt_rom_start_address + 2,\r\n&rom_length);\r\norom_size = rom_length * 512;\r\nif (orom_size < off) {\r\naddr_offset = 0;\r\ngoto return_ok;\r\n}\r\nif (orom_size < count) {\r\naddr_offset = 0;\r\ngoto return_ok;\r\n}\r\nfor (addr_offset = 0; addr_offset < count; addr_offset++) {\r\npch_phub_read_serial_rom(chip,\r\nchip->pch_opt_rom_start_address + addr_offset + off,\r\n&buf[addr_offset]);\r\n}\r\n} else {\r\nerr = -ENODATA;\r\ngoto return_err;\r\n}\r\nreturn_ok:\r\npci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\r\nmutex_unlock(&pch_phub_mutex);\r\nreturn addr_offset;\r\nreturn_err:\r\npci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\r\nexrom_map_err:\r\nmutex_unlock(&pch_phub_mutex);\r\nreturn_err_nomutex:\r\nreturn err;\r\n}\r\nstatic ssize_t pch_phub_bin_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nint err;\r\nunsigned int addr_offset;\r\nint ret;\r\nssize_t rom_size;\r\nstruct pch_phub_reg *chip =\r\ndev_get_drvdata(container_of(kobj, struct device, kobj));\r\nret = mutex_lock_interruptible(&pch_phub_mutex);\r\nif (ret)\r\nreturn -ERESTARTSYS;\r\nif (off > PCH_PHUB_OROM_SIZE) {\r\naddr_offset = 0;\r\ngoto return_ok;\r\n}\r\nif (count > PCH_PHUB_OROM_SIZE) {\r\naddr_offset = 0;\r\ngoto return_ok;\r\n}\r\nchip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);\r\nif (!chip->pch_phub_extrom_base_address) {\r\nerr = -ENOMEM;\r\ngoto exrom_map_err;\r\n}\r\nfor (addr_offset = 0; addr_offset < count; addr_offset++) {\r\nif (PCH_PHUB_OROM_SIZE < off + addr_offset)\r\ngoto return_ok;\r\nret = pch_phub_write_serial_rom(chip,\r\nchip->pch_opt_rom_start_address + addr_offset + off,\r\nbuf[addr_offset]);\r\nif (ret) {\r\nerr = ret;\r\ngoto return_err;\r\n}\r\n}\r\nreturn_ok:\r\npci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\r\nmutex_unlock(&pch_phub_mutex);\r\nreturn addr_offset;\r\nreturn_err:\r\npci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\r\nexrom_map_err:\r\nmutex_unlock(&pch_phub_mutex);\r\nreturn err;\r\n}\r\nstatic ssize_t show_pch_mac(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 mac[8];\r\nstruct pch_phub_reg *chip = dev_get_drvdata(dev);\r\nssize_t rom_size;\r\nchip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);\r\nif (!chip->pch_phub_extrom_base_address)\r\nreturn -ENOMEM;\r\npch_phub_read_gbe_mac_addr(chip, mac);\r\npci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\r\nreturn sprintf(buf, "%pM\n", mac);\r\n}\r\nstatic ssize_t store_pch_mac(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu8 mac[6];\r\nssize_t rom_size;\r\nstruct pch_phub_reg *chip = dev_get_drvdata(dev);\r\nif (count != 18)\r\nreturn -EINVAL;\r\nsscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",\r\n(u32 *)&mac[0], (u32 *)&mac[1], (u32 *)&mac[2], (u32 *)&mac[3],\r\n(u32 *)&mac[4], (u32 *)&mac[5]);\r\nchip->pch_phub_extrom_base_address = pci_map_rom(chip->pdev, &rom_size);\r\nif (!chip->pch_phub_extrom_base_address)\r\nreturn -ENOMEM;\r\npch_phub_write_gbe_mac_addr(chip, mac);\r\npci_unmap_rom(chip->pdev, chip->pch_phub_extrom_base_address);\r\nreturn count;\r\n}\r\nstatic int __devinit pch_phub_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint retval;\r\nint ret;\r\nstruct pch_phub_reg *chip;\r\nchip = kzalloc(sizeof(struct pch_phub_reg), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"%s : pci_enable_device FAILED(ret=%d)", __func__, ret);\r\ngoto err_pci_enable_dev;\r\n}\r\ndev_dbg(&pdev->dev, "%s : pci_enable_device returns %d\n", __func__,\r\nret);\r\nret = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"%s : pci_request_regions FAILED(ret=%d)", __func__, ret);\r\ngoto err_req_regions;\r\n}\r\ndev_dbg(&pdev->dev, "%s : "\r\n"pci_request_regions returns %d\n", __func__, ret);\r\nchip->pch_phub_base_address = pci_iomap(pdev, 1, 0);\r\nif (chip->pch_phub_base_address == 0) {\r\ndev_err(&pdev->dev, "%s : pci_iomap FAILED", __func__);\r\nret = -ENOMEM;\r\ngoto err_pci_iomap;\r\n}\r\ndev_dbg(&pdev->dev, "%s : pci_iomap SUCCESS and value "\r\n"in pch_phub_base_address variable is %p\n", __func__,\r\nchip->pch_phub_base_address);\r\nchip->pdev = pdev;\r\nif (id->driver_data == 1) {\r\nconst char *board_name;\r\nretval = sysfs_create_file(&pdev->dev.kobj,\r\n&dev_attr_pch_mac.attr);\r\nif (retval)\r\ngoto err_sysfs_create;\r\nretval = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);\r\nif (retval)\r\ngoto exit_bin_attr;\r\npch_phub_read_modify_write_reg(chip,\r\n(unsigned int)CLKCFG_REG_OFFSET,\r\nCLKCFG_CAN_50MHZ,\r\nCLKCFG_CANCLK_MASK);\r\nboard_name = dmi_get_system_info(DMI_BOARD_NAME);\r\nif (board_name && strstr(board_name, "CM-iTC"))\r\npch_phub_read_modify_write_reg(chip,\r\n(unsigned int)CLKCFG_REG_OFFSET,\r\nCLKCFG_UART_48MHZ | CLKCFG_BAUDDIV |\r\nCLKCFG_PLL2VCO | CLKCFG_UARTCLKSEL,\r\nCLKCFG_UART_MASK);\r\niowrite32(0x000affaa, chip->pch_phub_base_address + 0x14);\r\niowrite32(0x25, chip->pch_phub_base_address + 0x44);\r\nchip->pch_opt_rom_start_address = PCH_PHUB_ROM_START_ADDR_EG20T;\r\nchip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_EG20T;\r\n} else if (id->driver_data == 2) {\r\nretval = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);\r\nif (retval)\r\ngoto err_sysfs_create;\r\niowrite32(0x000affa0, chip->pch_phub_base_address + 0x14);\r\nchip->pch_opt_rom_start_address =\\r\nPCH_PHUB_ROM_START_ADDR_ML7213;\r\n} else if (id->driver_data == 3) {\r\niowrite32(0x000a0000, chip->pch_phub_base_address + 0x14);\r\niowrite32(0x25, chip->pch_phub_base_address + 0x140);\r\nchip->pch_opt_rom_start_address =\\r\nPCH_PHUB_ROM_START_ADDR_ML7223;\r\nchip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_ML7223;\r\n} else if (id->driver_data == 4) {\r\nretval = sysfs_create_file(&pdev->dev.kobj,\r\n&dev_attr_pch_mac.attr);\r\nif (retval)\r\ngoto err_sysfs_create;\r\nretval = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);\r\nif (retval)\r\ngoto exit_bin_attr;\r\niowrite32(0x0000ffa0, chip->pch_phub_base_address + 0x14);\r\nchip->pch_opt_rom_start_address =\\r\nPCH_PHUB_ROM_START_ADDR_ML7223;\r\nchip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_ML7223;\r\n} else if (id->driver_data == 5) {\r\nretval = sysfs_create_file(&pdev->dev.kobj,\r\n&dev_attr_pch_mac.attr);\r\nif (retval)\r\ngoto err_sysfs_create;\r\nretval = sysfs_create_bin_file(&pdev->dev.kobj, &pch_bin_attr);\r\nif (retval)\r\ngoto exit_bin_attr;\r\niowrite32(0x000affaa, chip->pch_phub_base_address + 0x14);\r\niowrite32(0x25, chip->pch_phub_base_address + 0x44);\r\nchip->pch_opt_rom_start_address = PCH_PHUB_ROM_START_ADDR_EG20T;\r\nchip->pch_mac_start_address = PCH_PHUB_MAC_START_ADDR_EG20T;\r\n}\r\nchip->ioh_type = id->driver_data;\r\npci_set_drvdata(pdev, chip);\r\nreturn 0;\r\nexit_bin_attr:\r\nsysfs_remove_file(&pdev->dev.kobj, &dev_attr_pch_mac.attr);\r\nerr_sysfs_create:\r\npci_iounmap(pdev, chip->pch_phub_base_address);\r\nerr_pci_iomap:\r\npci_release_regions(pdev);\r\nerr_req_regions:\r\npci_disable_device(pdev);\r\nerr_pci_enable_dev:\r\nkfree(chip);\r\ndev_err(&pdev->dev, "%s returns %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void __devexit pch_phub_remove(struct pci_dev *pdev)\r\n{\r\nstruct pch_phub_reg *chip = pci_get_drvdata(pdev);\r\nsysfs_remove_file(&pdev->dev.kobj, &dev_attr_pch_mac.attr);\r\nsysfs_remove_bin_file(&pdev->dev.kobj, &pch_bin_attr);\r\npci_iounmap(pdev, chip->pch_phub_base_address);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(chip);\r\n}\r\nstatic int pch_phub_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nint ret;\r\npch_phub_save_reg_conf(pdev);\r\nret = pci_save_state(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n" %s -pci_save_state returns %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int pch_phub_resume(struct pci_dev *pdev)\r\n{\r\nint ret;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"%s-pci_enable_device failed(ret=%d) ", __func__, ret);\r\nreturn ret;\r\n}\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\npch_phub_restore_reg_conf(pdev);\r\nreturn 0;\r\n}\r\nstatic int __init pch_phub_pci_init(void)\r\n{\r\nreturn pci_register_driver(&pch_phub_driver);\r\n}\r\nstatic void __exit pch_phub_pci_exit(void)\r\n{\r\npci_unregister_driver(&pch_phub_driver);\r\n}
