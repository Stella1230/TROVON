int\r\nnv04_timer_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 m, n, d;\r\nnv_wr32(dev, NV04_PTIMER_INTR_EN_0, 0x00000000);\r\nnv_wr32(dev, NV04_PTIMER_INTR_0, 0xFFFFFFFF);\r\nd = 1000000 / 32;\r\nif (dev_priv->chipset < 0x40) {\r\nn = nouveau_hw_get_clock(dev, PLL_CORE);\r\n} else\r\nif (dev_priv->chipset == 0x40) {\r\nn = 0;\r\n} else {\r\nn = dev_priv->crystal;\r\nm = 1;\r\nwhile (n < (d * 2)) {\r\nn += (n / m);\r\nm++;\r\n}\r\nnv_wr32(dev, 0x009220, m - 1);\r\n}\r\nif (!n) {\r\nNV_WARN(dev, "PTIMER: unknown input clock freq\n");\r\nif (!nv_rd32(dev, NV04_PTIMER_NUMERATOR) ||\r\n!nv_rd32(dev, NV04_PTIMER_DENOMINATOR)) {\r\nnv_wr32(dev, NV04_PTIMER_NUMERATOR, 1);\r\nnv_wr32(dev, NV04_PTIMER_DENOMINATOR, 1);\r\n}\r\nreturn 0;\r\n}\r\nwhile (((n % 5) == 0) && ((d % 5) == 0)) {\r\nn /= 5;\r\nd /= 5;\r\n}\r\nwhile (((n % 2) == 0) && ((d % 2) == 0)) {\r\nn /= 2;\r\nd /= 2;\r\n}\r\nwhile (n > 0xffff || d > 0xffff) {\r\nn >>= 1;\r\nd >>= 1;\r\n}\r\nnv_wr32(dev, NV04_PTIMER_NUMERATOR, n);\r\nnv_wr32(dev, NV04_PTIMER_DENOMINATOR, d);\r\nreturn 0;\r\n}\r\nu64\r\nnv04_timer_read(struct drm_device *dev)\r\n{\r\nu32 hi, lo;\r\ndo {\r\nhi = nv_rd32(dev, NV04_PTIMER_TIME_1);\r\nlo = nv_rd32(dev, NV04_PTIMER_TIME_0);\r\n} while (hi != nv_rd32(dev, NV04_PTIMER_TIME_1));\r\nreturn ((u64)hi << 32 | lo);\r\n}\r\nvoid\r\nnv04_timer_takedown(struct drm_device *dev)\r\n{\r\n}
