const struct max1363_mode\r\n*max1363_match_mode(const unsigned long *mask,\r\nconst struct max1363_chip_info *ci)\r\n{\r\nint i;\r\nif (mask)\r\nfor (i = 0; i < ci->num_modes; i++)\r\nif (bitmap_subset(mask,\r\nmax1363_mode_table[ci->mode_list[i]].\r\nmodemask,\r\nMAX1363_MAX_CHANNELS))\r\nreturn &max1363_mode_table[ci->mode_list[i]];\r\nreturn NULL;\r\n}\r\nstatic int max1363_write_basic_config(struct i2c_client *client,\r\nunsigned char d1,\r\nunsigned char d2)\r\n{\r\nu8 tx_buf[2] = {d1, d2};\r\nreturn i2c_master_send(client, tx_buf, 2);\r\n}\r\nint max1363_set_scan_mode(struct max1363_state *st)\r\n{\r\nst->configbyte &= ~(MAX1363_CHANNEL_SEL_MASK\r\n| MAX1363_SCAN_MASK\r\n| MAX1363_SE_DE_MASK);\r\nst->configbyte |= st->current_mode->conf;\r\nreturn max1363_write_basic_config(st->client,\r\nst->setupbyte,\r\nst->configbyte);\r\n}\r\nstatic int max1363_read_single_chan(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nlong m)\r\n{\r\nint ret = 0;\r\ns32 data;\r\nchar rxbuf[2];\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nstruct i2c_client *client = st->client;\r\nmutex_lock(&indio_dev->mlock);\r\nif (st->monitor_on || iio_buffer_enabled(indio_dev)) {\r\nret = -EBUSY;\r\ngoto error_ret;\r\n}\r\nif (st->current_mode != &max1363_mode_table[chan->address]) {\r\nst->current_mode = &max1363_mode_table[chan->address];\r\nret = max1363_set_scan_mode(st);\r\nif (ret < 0)\r\ngoto error_ret;\r\n}\r\nif (st->chip_info->bits != 8) {\r\ndata = i2c_master_recv(client, rxbuf, 2);\r\nif (data < 0) {\r\nret = data;\r\ngoto error_ret;\r\n}\r\ndata = (s32)(rxbuf[1]) | ((s32)(rxbuf[0] & 0x0F)) << 8;\r\n} else {\r\ndata = i2c_master_recv(client, rxbuf, 1);\r\nif (data < 0) {\r\nret = data;\r\ngoto error_ret;\r\n}\r\ndata = rxbuf[0];\r\n}\r\n*val = data;\r\nerror_ret:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int max1363_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nint ret;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = max1363_read_single_chan(indio_dev, chan, val, m);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif ((1 << (st->chip_info->bits + 1)) >\r\nst->chip_info->int_vref_mv) {\r\n*val = 0;\r\n*val2 = 500000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n} else {\r\n*val = (st->chip_info->int_vref_mv)\r\n>> st->chip_info->bits;\r\nreturn IIO_VAL_INT;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t max1363_monitor_show_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct max1363_state *st = iio_priv(dev_to_iio_dev(dev));\r\nreturn sprintf(buf, "%d\n", max1363_monitor_speeds[st->monitor_speed]);\r\n}\r\nstatic ssize_t max1363_monitor_store_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nint i, ret;\r\nunsigned long val;\r\nbool found = false;\r\nret = strict_strtoul(buf, 10, &val);\r\nif (ret)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(max1363_monitor_speeds); i++)\r\nif (val == max1363_monitor_speeds[i]) {\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nst->monitor_speed = i;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn 0;\r\n}\r\nstatic int max1363_read_thresh(struct iio_dev *indio_dev,\r\nu64 event_code,\r\nint *val)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nif (IIO_EVENT_CODE_EXTRACT_DIR(event_code) == IIO_EV_DIR_FALLING)\r\n*val = st->thresh_low[IIO_EVENT_CODE_EXTRACT_CHAN(event_code)];\r\nelse\r\n*val = st->thresh_high[IIO_EVENT_CODE_EXTRACT_CHAN(event_code)];\r\nreturn 0;\r\n}\r\nstatic int max1363_write_thresh(struct iio_dev *indio_dev,\r\nu64 event_code,\r\nint val)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nswitch (st->chip_info->bits) {\r\ncase 10:\r\nif (val > 0x3FF)\r\nreturn -EINVAL;\r\nbreak;\r\ncase 12:\r\nif (val > 0xFFF)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nswitch (IIO_EVENT_CODE_EXTRACT_DIR(event_code)) {\r\ncase IIO_EV_DIR_FALLING:\r\nst->thresh_low[IIO_EVENT_CODE_EXTRACT_CHAN(event_code)] = val;\r\nbreak;\r\ncase IIO_EV_DIR_RISING:\r\nst->thresh_high[IIO_EVENT_CODE_EXTRACT_CHAN(event_code)] = val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t max1363_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\ns64 timestamp = iio_get_time_ns();\r\nunsigned long mask, loc;\r\nu8 rx;\r\nu8 tx[2] = { st->setupbyte,\r\nMAX1363_MON_INT_ENABLE | (st->monitor_speed << 1) | 0xF0 };\r\ni2c_master_recv(st->client, &rx, 1);\r\nmask = rx;\r\nfor_each_set_bit(loc, &mask, 8)\r\niio_push_event(indio_dev, max1363_event_codes[loc], timestamp);\r\ni2c_master_send(st->client, tx, 2);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max1363_read_event_config(struct iio_dev *indio_dev,\r\nu64 event_code)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nint val;\r\nint number = IIO_EVENT_CODE_EXTRACT_CHAN(event_code);\r\nmutex_lock(&indio_dev->mlock);\r\nif (IIO_EVENT_CODE_EXTRACT_DIR(event_code) == IIO_EV_DIR_FALLING)\r\nval = (1 << number) & st->mask_low;\r\nelse\r\nval = (1 << number) & st->mask_high;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn val;\r\n}\r\nstatic int max1363_monitor_mode_update(struct max1363_state *st, int enabled)\r\n{\r\nu8 *tx_buf;\r\nint ret, i = 3, j;\r\nunsigned long numelements;\r\nint len;\r\nconst long *modemask;\r\nif (!enabled) {\r\nst->setupbyte &= ~MAX1363_SETUP_MONITOR_SETUP;\r\nst->configbyte &= ~MAX1363_SCAN_MASK;\r\nst->monitor_on = false;\r\nreturn max1363_write_basic_config(st->client,\r\nst->setupbyte,\r\nst->configbyte);\r\n}\r\nst->setupbyte |= MAX1363_SETUP_MONITOR_SETUP;\r\nst->configbyte &= ~(MAX1363_CHANNEL_SEL_MASK\r\n| MAX1363_SCAN_MASK\r\n| MAX1363_SE_DE_MASK);\r\nst->configbyte |= MAX1363_CONFIG_SCAN_MONITOR_MODE;\r\nif ((st->mask_low | st->mask_high) & 0x0F) {\r\nst->configbyte |= max1363_mode_table[s0to3].conf;\r\nmodemask = max1363_mode_table[s0to3].modemask;\r\n} else if ((st->mask_low | st->mask_high) & 0x30) {\r\nst->configbyte |= max1363_mode_table[d0m1to2m3].conf;\r\nmodemask = max1363_mode_table[d0m1to2m3].modemask;\r\n} else {\r\nst->configbyte |= max1363_mode_table[d1m0to3m2].conf;\r\nmodemask = max1363_mode_table[d1m0to3m2].modemask;\r\n}\r\nnumelements = bitmap_weight(modemask, MAX1363_MAX_CHANNELS);\r\nlen = 3 * numelements + 3;\r\ntx_buf = kmalloc(len, GFP_KERNEL);\r\nif (!tx_buf) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\ntx_buf[0] = st->configbyte;\r\ntx_buf[1] = st->setupbyte;\r\ntx_buf[2] = (st->monitor_speed << 1);\r\nfor (j = 0; j < 8; j++)\r\nif (test_bit(j, modemask)) {\r\nif (st->mask_low & (1 << j)) {\r\ntx_buf[i] = (st->thresh_low[j] >> 4) & 0xFF;\r\ntx_buf[i + 1] = (st->thresh_low[j] << 4) & 0xF0;\r\n} else if (j < 4) {\r\ntx_buf[i] = 0;\r\ntx_buf[i + 1] = 0;\r\n} else {\r\ntx_buf[i] = 0x80;\r\ntx_buf[i + 1] = 0;\r\n}\r\nif (st->mask_high & (1 << j)) {\r\ntx_buf[i + 1] |=\r\n(st->thresh_high[j] >> 8) & 0x0F;\r\ntx_buf[i + 2] = st->thresh_high[j] & 0xFF;\r\n} else if (j < 4) {\r\ntx_buf[i + 1] |= 0x0F;\r\ntx_buf[i + 2] = 0xFF;\r\n} else {\r\ntx_buf[i + 1] |= 0x07;\r\ntx_buf[i + 2] = 0xFF;\r\n}\r\ni += 3;\r\n}\r\nret = i2c_master_send(st->client, tx_buf, len);\r\nif (ret < 0)\r\ngoto error_ret;\r\nif (ret != len) {\r\nret = -EIO;\r\ngoto error_ret;\r\n}\r\ntx_buf[0] = st->setupbyte;\r\ntx_buf[1] = MAX1363_MON_INT_ENABLE | (st->monitor_speed << 1) | 0xF0;\r\nret = i2c_master_send(st->client, tx_buf, 2);\r\nif (ret < 0)\r\ngoto error_ret;\r\nif (ret != 2) {\r\nret = -EIO;\r\ngoto error_ret;\r\n}\r\nret = 0;\r\nst->monitor_on = true;\r\nerror_ret:\r\nkfree(tx_buf);\r\nreturn ret;\r\n}\r\nstatic inline int __max1363_check_event_mask(int thismask, int checkmask)\r\n{\r\nint ret = 0;\r\nif (thismask < 4) {\r\nif (checkmask & ~0x0F) {\r\nret = -EBUSY;\r\ngoto error_ret;\r\n}\r\n} else if (thismask < 6) {\r\nif (checkmask & ~0x30) {\r\nret = -EBUSY;\r\ngoto error_ret;\r\n}\r\n} else if (checkmask & ~0xC0)\r\nret = -EBUSY;\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int max1363_write_event_config(struct iio_dev *indio_dev,\r\nu64 event_code,\r\nint state)\r\n{\r\nint ret = 0;\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nu16 unifiedmask;\r\nint number = IIO_EVENT_CODE_EXTRACT_CHAN(event_code);\r\nmutex_lock(&indio_dev->mlock);\r\nunifiedmask = st->mask_low | st->mask_high;\r\nif (IIO_EVENT_CODE_EXTRACT_DIR(event_code) == IIO_EV_DIR_FALLING) {\r\nif (state == 0)\r\nst->mask_low &= ~(1 << number);\r\nelse {\r\nret = __max1363_check_event_mask((1 << number),\r\nunifiedmask);\r\nif (ret)\r\ngoto error_ret;\r\nst->mask_low |= (1 << number);\r\n}\r\n} else {\r\nif (state == 0)\r\nst->mask_high &= ~(1 << number);\r\nelse {\r\nret = __max1363_check_event_mask((1 << number),\r\nunifiedmask);\r\nif (ret)\r\ngoto error_ret;\r\nst->mask_high |= (1 << number);\r\n}\r\n}\r\nmax1363_monitor_mode_update(st, !!(st->mask_high | st->mask_low));\r\nerror_ret:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int max1363_initial_setup(struct max1363_state *st)\r\n{\r\nst->setupbyte = MAX1363_SETUP_AIN3_IS_AIN3_REF_IS_VDD\r\n| MAX1363_SETUP_POWER_UP_INT_REF\r\n| MAX1363_SETUP_INT_CLOCK\r\n| MAX1363_SETUP_UNIPOLAR\r\n| MAX1363_SETUP_NORESET;\r\nst->setupbyte = MAX1363_SETUP_BYTE(st->setupbyte);\r\nst->current_mode = &max1363_mode_table[st->chip_info->default_mode];\r\nst->configbyte = MAX1363_CONFIG_BYTE(st->configbyte);\r\nreturn max1363_set_scan_mode(st);\r\n}\r\nstatic int __devinit max1363_alloc_scan_masks(struct iio_dev *indio_dev)\r\n{\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nunsigned long *masks;\r\nint i;\r\nmasks = kzalloc(BITS_TO_LONGS(MAX1363_MAX_CHANNELS)*sizeof(long)*\r\n(st->chip_info->num_modes + 1), GFP_KERNEL);\r\nif (!masks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < st->chip_info->num_modes; i++)\r\nbitmap_copy(masks + BITS_TO_LONGS(MAX1363_MAX_CHANNELS)*i,\r\nmax1363_mode_table[st->chip_info->mode_list[i]]\r\n.modemask, MAX1363_MAX_CHANNELS);\r\nindio_dev->available_scan_masks = masks;\r\nreturn 0;\r\n}\r\nstatic int __devinit max1363_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct max1363_state *st;\r\nstruct iio_dev *indio_dev;\r\nstruct regulator *reg;\r\nreg = regulator_get(&client->dev, "vcc");\r\nif (IS_ERR(reg)) {\r\nret = PTR_ERR(reg);\r\ngoto error_out;\r\n}\r\nret = regulator_enable(reg);\r\nif (ret)\r\ngoto error_put_reg;\r\nindio_dev = iio_device_alloc(sizeof(struct max1363_state));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error_disable_reg;\r\n}\r\nret = iio_map_array_register(indio_dev, client->dev.platform_data);\r\nif (ret < 0)\r\ngoto error_free_device;\r\nst = iio_priv(indio_dev);\r\nst->reg = reg;\r\ni2c_set_clientdata(client, indio_dev);\r\nst->chip_info = &max1363_chip_info_tbl[id->driver_data];\r\nst->client = client;\r\nret = max1363_alloc_scan_masks(indio_dev);\r\nif (ret)\r\ngoto error_unregister_map;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->name = id->name;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\nindio_dev->info = st->chip_info->info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\nret = max1363_initial_setup(st);\r\nif (ret < 0)\r\ngoto error_free_available_scan_masks;\r\nret = max1363_register_ring_funcs_and_init(indio_dev);\r\nif (ret)\r\ngoto error_free_available_scan_masks;\r\nret = iio_buffer_register(indio_dev,\r\nst->chip_info->channels,\r\nst->chip_info->num_channels);\r\nif (ret)\r\ngoto error_cleanup_ring;\r\nif (client->irq) {\r\nret = request_threaded_irq(st->client->irq,\r\nNULL,\r\n&max1363_event_handler,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"max1363_event",\r\nindio_dev);\r\nif (ret)\r\ngoto error_uninit_ring;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto error_free_irq;\r\nreturn 0;\r\nerror_free_irq:\r\nfree_irq(st->client->irq, indio_dev);\r\nerror_uninit_ring:\r\niio_buffer_unregister(indio_dev);\r\nerror_cleanup_ring:\r\nmax1363_ring_cleanup(indio_dev);\r\nerror_free_available_scan_masks:\r\nkfree(indio_dev->available_scan_masks);\r\nerror_unregister_map:\r\niio_map_array_unregister(indio_dev, client->dev.platform_data);\r\nerror_free_device:\r\niio_device_free(indio_dev);\r\nerror_disable_reg:\r\nregulator_disable(reg);\r\nerror_put_reg:\r\nregulator_put(reg);\r\nerror_out:\r\nreturn ret;\r\n}\r\nstatic int max1363_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct max1363_state *st = iio_priv(indio_dev);\r\nstruct regulator *reg = st->reg;\r\niio_device_unregister(indio_dev);\r\nif (client->irq)\r\nfree_irq(st->client->irq, indio_dev);\r\niio_buffer_unregister(indio_dev);\r\nmax1363_ring_cleanup(indio_dev);\r\nkfree(indio_dev->available_scan_masks);\r\nif (!IS_ERR(reg)) {\r\nregulator_disable(reg);\r\nregulator_put(reg);\r\n}\r\niio_map_array_unregister(indio_dev, client->dev.platform_data);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
