static int get_audio_std(v4l2_std_id v4l2_std)\r\n{\r\nint i = 0;\r\nfor (; i < map_size; i++) {\r\nif (v4l2_std & video_to_audio_map[i].video_std)\r\nreturn video_to_audio_map[i].audio_std;\r\n}\r\nreturn TLG_TUNE_ASTD_A2;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *p = front->pd;\r\nlogs(front);\r\nstrcpy(cap->driver, "tele-video");\r\nstrcpy(cap->card, "Telegent Poseidon");\r\nusb_make_path(p->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TUNER |\r\nV4L2_CAP_AUDIO | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE | V4L2_CAP_VBI_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic void init_copy(struct video_data *video, bool index)\r\n{\r\nstruct front_face *front = video->front;\r\nvideo->field_count = index;\r\nvideo->lines_copied = 0;\r\nvideo->prev_left = 0 ;\r\nvideo->dst = (char *)videobuf_to_vmalloc(front->curr_frame)\r\n+ index * video->lines_size;\r\nvideo->vbi->copied = 0;\r\n}\r\nstatic bool get_frame(struct front_face *front, int *need_init)\r\n{\r\nstruct videobuf_buffer *vb = front->curr_frame;\r\nif (vb)\r\nreturn true;\r\nspin_lock(&front->queue_lock);\r\nif (!list_empty(&front->active)) {\r\nvb = list_entry(front->active.next,\r\nstruct videobuf_buffer, queue);\r\nif (need_init)\r\n*need_init = 1;\r\nfront->curr_frame = vb;\r\nlist_del_init(&vb->queue);\r\n}\r\nspin_unlock(&front->queue_lock);\r\nreturn !!vb;\r\n}\r\nstatic bool get_video_frame(struct front_face *front, struct video_data *video)\r\n{\r\nint need_init = 0;\r\nbool ret = true;\r\nret = get_frame(front, &need_init);\r\nif (ret && need_init)\r\ninit_copy(video, 0);\r\nreturn ret;\r\n}\r\nstatic void submit_frame(struct front_face *front)\r\n{\r\nstruct videobuf_buffer *vb = front->curr_frame;\r\nif (vb == NULL)\r\nreturn;\r\nfront->curr_frame = NULL;\r\nvb->state = VIDEOBUF_DONE;\r\nvb->field_count++;\r\ndo_gettimeofday(&vb->ts);\r\nwake_up(&vb->done);\r\n}\r\nstatic void end_field(struct video_data *video)\r\n{\r\nif (1 == video->field_count)\r\nsubmit_frame(video->front);\r\nelse\r\ninit_copy(video, 1);\r\n}\r\nstatic void copy_video_data(struct video_data *video, char *src,\r\nunsigned int count)\r\n{\r\n#define copy_data(len) \\r\ndo { \\r\nif (++video->lines_copied > video->lines_per_field) \\r\ngoto overflow; \\r\nmemcpy(video->dst, src, len);\\r\nvideo->dst += len + video->lines_size; \\r\nsrc += len; \\r\ncount -= len; \\r\n} while (0)\r\nwhile (count && count >= video->lines_size) {\r\nif (video->prev_left) {\r\ncopy_data(video->prev_left);\r\nvideo->prev_left = 0;\r\ncontinue;\r\n}\r\ncopy_data(video->lines_size);\r\n}\r\nif (count && count < video->lines_size) {\r\nmemcpy(video->dst, src, count);\r\nvideo->prev_left = video->lines_size - count;\r\nvideo->dst += count;\r\n}\r\nreturn;\r\noverflow:\r\nend_field(video);\r\n}\r\nstatic void check_trailer(struct video_data *video, char *src, int count)\r\n{\r\nstruct vbi_data *vbi = video->vbi;\r\nint offset;\r\nchar *buf;\r\noffset = (video->context.pix.sizeimage / 2 + vbi->vbi_size / 2)\r\n- (vbi->copied + video->lines_size * video->lines_copied);\r\nif (video->prev_left)\r\noffset -= (video->lines_size - video->prev_left);\r\nif (offset > count || offset <= 0)\r\ngoto short_package;\r\nbuf = src + offset;\r\nif (!strncmp(buf, "VFHS", 4)) {\r\nint field_num = *((u32 *)(buf + 12));\r\nif ((field_num & 1) ^ video->field_count) {\r\ninit_copy(video, video->field_count);\r\nreturn;\r\n}\r\ncopy_video_data(video, src, offset);\r\n}\r\nshort_package:\r\nend_field(video);\r\n}\r\nstatic inline void copy_vbi_data(struct vbi_data *vbi,\r\nchar *src, unsigned int count)\r\n{\r\nstruct front_face *front = vbi->front;\r\nif (front && get_frame(front, NULL)) {\r\nchar *buf = videobuf_to_vmalloc(front->curr_frame);\r\nif (vbi->video->field_count)\r\nbuf += (vbi->vbi_size / 2);\r\nmemcpy(buf + vbi->copied, src, count);\r\n}\r\nvbi->copied += count;\r\n}\r\nstatic inline void copy_vbi_video_data(struct video_data *video,\r\nchar *src, unsigned int count)\r\n{\r\nstruct vbi_data *vbi = video->vbi;\r\nunsigned int vbi_delta = (vbi->vbi_size / 2) - vbi->copied;\r\nif (vbi_delta >= count) {\r\ncopy_vbi_data(vbi, src, count);\r\n} else {\r\nif (vbi_delta) {\r\ncopy_vbi_data(vbi, src, vbi_delta);\r\nif (vbi->front && video->field_count)\r\nsubmit_frame(vbi->front);\r\n}\r\ncopy_video_data(video, src + vbi_delta, count - vbi_delta);\r\n}\r\n}\r\nstatic void urb_complete_bulk(struct urb *urb)\r\n{\r\nstruct front_face *front = urb->context;\r\nstruct video_data *video = &front->pd->video_data;\r\nchar *src = (char *)urb->transfer_buffer;\r\nint count = urb->actual_length;\r\nint ret = 0;\r\nif (!video->is_streaming || urb->status) {\r\nif (urb->status == -EPROTO)\r\ngoto resend_it;\r\nreturn;\r\n}\r\nif (!get_video_frame(front, video))\r\ngoto resend_it;\r\nif (count == urb->transfer_buffer_length)\r\ncopy_vbi_video_data(video, src, count);\r\nelse\r\ncheck_trailer(video, src, count);\r\nresend_it:\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\nlog(" submit failed: error %d", ret);\r\n}\r\nstatic int get_chunk(int start, struct urb *urb,\r\nint *head, int *tail, int *bubble_err)\r\n{\r\nstruct usb_iso_packet_descriptor *pkt = NULL;\r\nint ret = GET_SUCCESS;\r\nfor (*head = *tail = -1; start < urb->number_of_packets; start++) {\r\npkt = &urb->iso_frame_desc[start];\r\nif (-EOVERFLOW == pkt->status) {\r\nif (++*bubble_err > urb->number_of_packets / 3)\r\nreturn GET_TOO_MUCH_BUBBLE;\r\ncontinue;\r\n}\r\nif (pkt->status || pkt->actual_length <= 0\r\n|| pkt->actual_length > ISO_PKT_SIZE) {\r\nif (*head != -1)\r\nbreak;\r\ncontinue;\r\n}\r\nif (pkt->actual_length == ISO_PKT_SIZE) {\r\nif (*head == -1)\r\n*head = start;\r\n*tail = start;\r\ncontinue;\r\n}\r\nif (pkt->actual_length < ISO_PKT_SIZE) {\r\nif (*head == -1) {\r\n*head = start;\r\n*tail = start;\r\nreturn GET_TRAILER;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (*head == -1 && *tail == -1)\r\nret = GET_NONE;\r\nreturn ret;\r\n}\r\nstatic void urb_complete_iso(struct urb *urb)\r\n{\r\nstruct front_face *front = urb->context;\r\nstruct video_data *video = &front->pd->video_data;\r\nint bubble_err = 0, head = 0, tail = 0;\r\nchar *src = (char *)urb->transfer_buffer;\r\nint ret = 0;\r\nif (!video->is_streaming)\r\nreturn;\r\ndo {\r\nif (!get_video_frame(front, video))\r\ngoto out;\r\nswitch (get_chunk(head, urb, &head, &tail, &bubble_err)) {\r\ncase GET_SUCCESS:\r\ncopy_vbi_video_data(video, src + (head * ISO_PKT_SIZE),\r\n(tail - head + 1) * ISO_PKT_SIZE);\r\nbreak;\r\ncase GET_TRAILER:\r\ncheck_trailer(video, src + (head * ISO_PKT_SIZE),\r\nISO_PKT_SIZE);\r\nbreak;\r\ncase GET_NONE:\r\ngoto out;\r\ncase GET_TOO_MUCH_BUBBLE:\r\nlog("\t We got too much bubble");\r\nschedule_work(&video->bubble_work);\r\nreturn;\r\n}\r\n} while (head = tail + 1, head < urb->number_of_packets);\r\nout:\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret)\r\nlog("usb_submit_urb err : %d", ret);\r\n}\r\nstatic int prepare_iso_urb(struct video_data *video)\r\n{\r\nstruct usb_device *udev = video->pd->udev;\r\nint i;\r\nif (video->urb_array[0])\r\nreturn 0;\r\nfor (i = 0; i < SBUF_NUM; i++) {\r\nstruct urb *urb;\r\nvoid *mem;\r\nint j;\r\nurb = usb_alloc_urb(PK_PER_URB, GFP_KERNEL);\r\nif (urb == NULL)\r\ngoto out;\r\nvideo->urb_array[i] = urb;\r\nmem = usb_alloc_coherent(udev,\r\nISO_PKT_SIZE * PK_PER_URB,\r\nGFP_KERNEL,\r\n&urb->transfer_dma);\r\nurb->complete = urb_complete_iso;\r\nurb->dev = udev;\r\nurb->context = video->front;\r\nurb->pipe = usb_rcvisocpipe(udev,\r\nvideo->endpoint_addr);\r\nurb->interval = 1;\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nurb->number_of_packets = PK_PER_URB;\r\nurb->transfer_buffer = mem;\r\nurb->transfer_buffer_length = PK_PER_URB * ISO_PKT_SIZE;\r\nfor (j = 0; j < PK_PER_URB; j++) {\r\nurb->iso_frame_desc[j].offset = ISO_PKT_SIZE * j;\r\nurb->iso_frame_desc[j].length = ISO_PKT_SIZE;\r\n}\r\n}\r\nreturn 0;\r\nout:\r\nfor (; i > 0; i--)\r\n;\r\nreturn -ENOMEM;\r\n}\r\nint alloc_bulk_urbs_generic(struct urb **urb_array, int num,\r\nstruct usb_device *udev, u8 ep_addr,\r\nint buf_size, gfp_t gfp_flags,\r\nusb_complete_t complete_fn, void *context)\r\n{\r\nint i = 0;\r\nfor (; i < num; i++) {\r\nvoid *mem;\r\nstruct urb *urb = usb_alloc_urb(0, gfp_flags);\r\nif (urb == NULL)\r\nreturn i;\r\nmem = usb_alloc_coherent(udev, buf_size, gfp_flags,\r\n&urb->transfer_dma);\r\nif (mem == NULL) {\r\nusb_free_urb(urb);\r\nreturn i;\r\n}\r\nusb_fill_bulk_urb(urb, udev, usb_rcvbulkpipe(udev, ep_addr),\r\nmem, buf_size, complete_fn, context);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nurb_array[i] = urb;\r\n}\r\nreturn i;\r\n}\r\nvoid free_all_urb_generic(struct urb **urb_array, int num)\r\n{\r\nint i;\r\nstruct urb *urb;\r\nfor (i = 0; i < num; i++) {\r\nurb = urb_array[i];\r\nif (urb) {\r\nusb_free_coherent(urb->dev,\r\nurb->transfer_buffer_length,\r\nurb->transfer_buffer,\r\nurb->transfer_dma);\r\nusb_free_urb(urb);\r\nurb_array[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int prepare_bulk_urb(struct video_data *video)\r\n{\r\nif (video->urb_array[0])\r\nreturn 0;\r\nalloc_bulk_urbs_generic(video->urb_array, SBUF_NUM,\r\nvideo->pd->udev, video->endpoint_addr,\r\n0x2000, GFP_KERNEL,\r\nurb_complete_bulk, video->front);\r\nreturn 0;\r\n}\r\nstatic void free_all_urb(struct video_data *video)\r\n{\r\nfree_all_urb_generic(video->urb_array, SBUF_NUM);\r\n}\r\nstatic void pd_buf_release(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nvideobuf_vmalloc_free(vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic void pd_buf_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct front_face *front = q->priv_data;\r\nvb->state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&vb->queue, &front->active);\r\n}\r\nstatic int pd_buf_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct front_face *front = q->priv_data;\r\nint rc;\r\nswitch (front->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (VIDEOBUF_NEEDS_INIT == vb->state) {\r\nstruct v4l2_pix_format *pix;\r\npix = &front->pd->video_data.context.pix;\r\nvb->size = pix->sizeimage;\r\nvb->width = pix->width;\r\nvb->height = pix->height;\r\nrc = videobuf_iolock(q, vb, NULL);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (VIDEOBUF_NEEDS_INIT == vb->state) {\r\nvb->size = front->pd->vbi_data.vbi_size;\r\nrc = videobuf_iolock(q, vb, NULL);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nvb->field = field;\r\nvb->state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\n}\r\nstatic int fire_all_urb(struct video_data *video)\r\n{\r\nint i, ret;\r\nvideo->is_streaming = 1;\r\nfor (i = 0; i < SBUF_NUM; i++) {\r\nret = usb_submit_urb(video->urb_array[i], GFP_KERNEL);\r\nif (ret)\r\nlog("(%d) failed: error %d", i, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int start_video_stream(struct poseidon *pd)\r\n{\r\nstruct video_data *video = &pd->video_data;\r\ns32 cmd_status;\r\nsend_set_req(pd, TAKE_REQUEST, 0, &cmd_status);\r\nsend_set_req(pd, PLAY_SERVICE, TLG_TUNE_PLAY_SVC_START, &cmd_status);\r\nif (pd->cur_transfer_mode) {\r\nprepare_iso_urb(video);\r\nINIT_WORK(&video->bubble_work, iso_bubble_handler);\r\n} else {\r\nprepare_bulk_urb(video);\r\n}\r\nfire_all_urb(video);\r\nreturn 0;\r\n}\r\nstatic int pd_buf_setup(struct videobuf_queue *q, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct front_face *front = q->priv_data;\r\nstruct poseidon *pd = front->pd;\r\nswitch (front->type) {\r\ndefault:\r\nreturn -EINVAL;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE: {\r\nstruct video_data *video = &pd->video_data;\r\nstruct v4l2_pix_format *pix = &video->context.pix;\r\n*size = PAGE_ALIGN(pix->sizeimage);\r\nif (*count < 4)\r\n*count = 4;\r\nif (1) {\r\nvideo->endpoint_addr = 0x82;\r\nvideo->vbi = &pd->vbi_data;\r\nvideo->vbi->video = video;\r\nvideo->pd = pd;\r\nvideo->lines_per_field = pix->height / 2;\r\nvideo->lines_size = pix->width * 2;\r\nvideo->front = front;\r\n}\r\nreturn start_video_stream(pd);\r\n}\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE: {\r\nstruct vbi_data *vbi = &pd->vbi_data;\r\n*size = PAGE_ALIGN(vbi->vbi_size);\r\nlog("size : %d", *size);\r\nif (*count == 0)\r\n*count = 4;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt(struct file *file, void *fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (ARRAY_SIZE(poseidon_formats) <= f->index)\r\nreturn -EINVAL;\r\nf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nf->flags = 0;\r\nf->pixelformat = poseidon_formats[f->index].fourcc;\r\nstrcpy(f->description, poseidon_formats[f->index].name);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nlogs(front);\r\nf->fmt.pix = pd->video_data.context.pix;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pd_vidioc_s_fmt(struct poseidon *pd, struct v4l2_pix_format *pix)\r\n{\r\nstruct video_data *video = &pd->video_data;\r\nstruct running_context *context = &video->context;\r\nstruct v4l2_pix_format *pix_def = &context->pix;\r\ns32 ret = 0, cmd_status = 0, vid_resol;\r\nif (pix->pixelformat == V4L2_PIX_FMT_RGB565) {\r\nvid_resol = TLG_TUNER_VID_FORMAT_RGB_565;\r\n} else {\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\nvid_resol = TLG_TUNER_VID_FORMAT_YUV;\r\n}\r\nret = send_set_req(pd, VIDEO_STREAM_FMT_SEL,\r\nvid_resol, &cmd_status);\r\nvid_resol = TLG_TUNE_VID_RES_720;\r\nswitch (pix->width) {\r\ncase 704:\r\nvid_resol = TLG_TUNE_VID_RES_704;\r\nbreak;\r\ndefault:\r\npix->width = 720;\r\ncase 720:\r\nbreak;\r\n}\r\nret |= send_set_req(pd, VIDEO_ROSOLU_SEL,\r\nvid_resol, &cmd_status);\r\nif (ret || cmd_status)\r\nreturn -EBUSY;\r\npix_def->pixelformat = pix->pixelformat;\r\npix->height = (context->tvnormid & V4L2_STD_525_60) ? 480 : 576;\r\nif ((pix_def->width != pix->width)\r\n|| (pix_def->height != pix->height)) {\r\npix_def->width = pix->width;\r\npix_def->height = pix->height;\r\npix_def->bytesperline = pix->width * 2;\r\npix_def->sizeimage = pix->width * pix->height * 2;\r\n}\r\n*pix = *pix_def;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nlogs(front);\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != f->type)\r\nreturn -EINVAL;\r\nmutex_lock(&pd->lock);\r\nif (pd->file_for_stream == NULL)\r\npd->file_for_stream = file;\r\nelse if (file != pd->file_for_stream) {\r\nmutex_unlock(&pd->lock);\r\nreturn -EINVAL;\r\n}\r\npd_vidioc_s_fmt(pd, &f->fmt.pix);\r\nmutex_unlock(&pd->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vbi(struct file *file, void *fh,\r\nstruct v4l2_format *v4l2_f)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nstruct v4l2_vbi_format *vbi_fmt = &v4l2_f->fmt.vbi;\r\nvbi_fmt->samples_per_line = 720 * 2;\r\nvbi_fmt->sampling_rate = 6750000 * 4;\r\nvbi_fmt->sample_format = V4L2_PIX_FMT_GREY;\r\nvbi_fmt->offset = 64 * 4;\r\nif (pd->video_data.context.tvnormid & V4L2_STD_525_60) {\r\nvbi_fmt->start[0] = 10;\r\nvbi_fmt->start[1] = 264;\r\nvbi_fmt->count[0] = V4L_NTSC_VBI_LINES;\r\nvbi_fmt->count[1] = V4L_NTSC_VBI_LINES;\r\n} else {\r\nvbi_fmt->start[0] = 6;\r\nvbi_fmt->start[1] = 314;\r\nvbi_fmt->count[0] = V4L_PAL_VBI_LINES;\r\nvbi_fmt->count[1] = V4L_PAL_VBI_LINES;\r\n}\r\nvbi_fmt->flags = V4L2_VBI_UNSYNC;\r\nlogs(front);\r\nreturn 0;\r\n}\r\nstatic int set_std(struct poseidon *pd, v4l2_std_id *norm)\r\n{\r\nstruct video_data *video = &pd->video_data;\r\nstruct vbi_data *vbi = &pd->vbi_data;\r\nstruct running_context *context;\r\nstruct v4l2_pix_format *pix;\r\ns32 i, ret = 0, cmd_status, param;\r\nint height;\r\nfor (i = 0; i < POSEIDON_TVNORMS; i++) {\r\nif (*norm & poseidon_tvnorms[i].v4l2_id) {\r\nparam = poseidon_tvnorms[i].tlg_tvnorm;\r\nlog("name : %s", poseidon_tvnorms[i].name);\r\ngoto found;\r\n}\r\n}\r\nreturn -EINVAL;\r\nfound:\r\nmutex_lock(&pd->lock);\r\nret = send_set_req(pd, VIDEO_STD_SEL, param, &cmd_status);\r\nif (ret || cmd_status)\r\ngoto out;\r\ncontext = &video->context;\r\ncontext->tvnormid = poseidon_tvnorms[i].v4l2_id;\r\nif (context->tvnormid & V4L2_STD_525_60) {\r\nvbi->vbi_size = V4L_NTSC_VBI_FRAMESIZE;\r\nheight = 480;\r\n} else {\r\nvbi->vbi_size = V4L_PAL_VBI_FRAMESIZE;\r\nheight = 576;\r\n}\r\npix = &context->pix;\r\nif (pix->height != height) {\r\npix->height = height;\r\npix->sizeimage = pix->width * pix->height * 2;\r\n}\r\nout:\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *norm)\r\n{\r\nstruct front_face *front = fh;\r\nlogs(front);\r\nreturn set_std(front->pd, norm);\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *in)\r\n{\r\nstruct front_face *front = fh;\r\nif (in->index < 0 || in->index >= POSEIDON_INPUTS)\r\nreturn -EINVAL;\r\nstrcpy(in->name, pd_inputs[in->index].name);\r\nin->type = V4L2_INPUT_TYPE_TUNER;\r\nin->audioset = 0;\r\nin->tuner = 0;\r\nin->std = V4L2_STD_ALL;\r\nin->status = 0;\r\nlogs(front);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nstruct running_context *context = &pd->video_data.context;\r\nlogs(front);\r\n*i = context->sig_index;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int i)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\ns32 ret, cmd_status;\r\nif (i < 0 || i >= POSEIDON_INPUTS)\r\nreturn -EINVAL;\r\nret = send_set_req(pd, SGNL_SRC_SEL,\r\npd_inputs[i].tlg_src, &cmd_status);\r\nif (ret)\r\nreturn ret;\r\npd->video_data.context.sig_index = i;\r\nreturn 0;\r\n}\r\nstatic struct poseidon_control *check_control_id(__u32 id)\r\n{\r\nstruct poseidon_control *control = &controls[0];\r\nint array_size = ARRAY_SIZE(controls);\r\nfor (; control < &controls[array_size]; control++)\r\nif (control->v4l2_ctrl.id == id)\r\nreturn control;\r\nreturn NULL;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *fh,\r\nstruct v4l2_queryctrl *a)\r\n{\r\nstruct poseidon_control *control = NULL;\r\ncontrol = check_control_id(a->id);\r\nif (!control)\r\nreturn -EINVAL;\r\n*a = control->v4l2_ctrl;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *ctrl)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nstruct poseidon_control *control = NULL;\r\nstruct tuner_custom_parameter_s tuner_param;\r\ns32 ret = 0, cmd_status;\r\ncontrol = check_control_id(ctrl->id);\r\nif (!control)\r\nreturn -EINVAL;\r\nmutex_lock(&pd->lock);\r\nret = send_get_req(pd, TUNER_CUSTOM_PARAMETER, control->vc_id,\r\n&tuner_param, &cmd_status, sizeof(tuner_param));\r\nmutex_unlock(&pd->lock);\r\nif (ret || cmd_status)\r\nreturn -1;\r\nctrl->value = tuner_param.param_value;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *a)\r\n{\r\nstruct tuner_custom_parameter_s param = {0};\r\nstruct poseidon_control *control = NULL;\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\ns32 ret = 0, cmd_status, params;\r\ncontrol = check_control_id(a->id);\r\nif (!control)\r\nreturn -EINVAL;\r\nparam.param_value = a->value;\r\nparam.param_id = control->vc_id;\r\nparams = *(s32 *)&param;\r\nmutex_lock(&pd->lock);\r\nret = send_set_req(pd, TUNER_CUSTOM_PARAMETER, params, &cmd_status);\r\nret = send_set_req(pd, TAKE_REQUEST, 0, &cmd_status);\r\nmutex_unlock(&pd->lock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ/4);\r\nreturn ret;\r\n}\r\nstatic int vidioc_enumaudio(struct file *file, void *fh, struct v4l2_audio *a)\r\n{\r\nif (0 != a->index)\r\nreturn -EINVAL;\r\na->capability = V4L2_AUDCAP_STEREO;\r\nstrcpy(a->name, "USB audio in");\r\na->mode = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *fh, struct v4l2_audio *a)\r\n{\r\na->index = 0;\r\na->capability = V4L2_AUDCAP_STEREO;\r\nstrcpy(a->name, "USB audio in");\r\na->mode = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *fh, struct v4l2_audio *a)\r\n{\r\nreturn (0 == a->index) ? 0 : -EINVAL;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *fh, struct v4l2_tuner *tuner)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nstruct tuner_atv_sig_stat_s atv_stat;\r\ns32 count = 5, ret, cmd_status;\r\nint index;\r\nif (0 != tuner->index)\r\nreturn -EINVAL;\r\nmutex_lock(&pd->lock);\r\nret = send_get_req(pd, TUNER_STATUS, TLG_MODE_ANALOG_TV,\r\n&atv_stat, &cmd_status, sizeof(atv_stat));\r\nwhile (atv_stat.sig_lock_busy && count-- && !ret) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\nret = send_get_req(pd, TUNER_STATUS, TLG_MODE_ANALOG_TV,\r\n&atv_stat, &cmd_status, sizeof(atv_stat));\r\n}\r\nmutex_unlock(&pd->lock);\r\nif (debug_mode)\r\nlog("P:%d,S:%d", atv_stat.sig_present, atv_stat.sig_strength);\r\nif (ret || cmd_status)\r\ntuner->signal = 0;\r\nelse if (atv_stat.sig_present && !atv_stat.sig_strength)\r\ntuner->signal = 0xFFFF;\r\nelse\r\ntuner->signal = (atv_stat.sig_strength * 255 / 10) << 8;\r\nstrcpy(tuner->name, "Telegent Systems");\r\ntuner->type = V4L2_TUNER_ANALOG_TV;\r\ntuner->rangelow = TUNER_FREQ_MIN / 62500;\r\ntuner->rangehigh = TUNER_FREQ_MAX / 62500;\r\ntuner->capability = V4L2_TUNER_CAP_NORM | V4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2;\r\nindex = pd->video_data.context.audio_idx;\r\ntuner->rxsubchans = pd_audio_modes[index].v4l2_audio_sub;\r\ntuner->audmode = pd_audio_modes[index].v4l2_audio_mode;\r\ntuner->afc = 0;\r\nlogs(front);\r\nreturn 0;\r\n}\r\nstatic int pd_vidioc_s_tuner(struct poseidon *pd, int index)\r\n{\r\ns32 ret = 0, cmd_status, param, audiomode;\r\nmutex_lock(&pd->lock);\r\nparam = pd_audio_modes[index].tlg_audio_mode;\r\nret = send_set_req(pd, TUNER_AUD_MODE, param, &cmd_status);\r\naudiomode = get_audio_std(pd->video_data.context.tvnormid);\r\nret |= send_set_req(pd, TUNER_AUD_ANA_STD, audiomode,\r\n&cmd_status);\r\nif (!ret)\r\npd->video_data.context.audio_idx = index;\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *fh, struct v4l2_tuner *a)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nint index;\r\nif (0 != a->index)\r\nreturn -EINVAL;\r\nlogs(front);\r\nfor (index = 0; index < POSEIDON_AUDIOMODS; index++)\r\nif (a->audmode == pd_audio_modes[index].v4l2_audio_mode)\r\nreturn pd_vidioc_s_tuner(pd, index);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *fh,\r\nstruct v4l2_frequency *freq)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nstruct running_context *context = &pd->video_data.context;\r\nif (0 != freq->tuner)\r\nreturn -EINVAL;\r\nfreq->frequency = context->freq;\r\nfreq->type = V4L2_TUNER_ANALOG_TV;\r\nreturn 0;\r\n}\r\nstatic int set_frequency(struct poseidon *pd, __u32 frequency)\r\n{\r\ns32 ret = 0, param, cmd_status;\r\nstruct running_context *context = &pd->video_data.context;\r\nparam = frequency * 62500 / 1000;\r\nif (param < TUNER_FREQ_MIN/1000 || param > TUNER_FREQ_MAX / 1000)\r\nreturn -EINVAL;\r\nmutex_lock(&pd->lock);\r\nret = send_set_req(pd, TUNE_FREQ_SELECT, param, &cmd_status);\r\nret = send_set_req(pd, TAKE_REQUEST, 0, &cmd_status);\r\nmsleep(250);\r\ncontext->freq = frequency;\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *fh,\r\nstruct v4l2_frequency *freq)\r\n{\r\nstruct front_face *front = fh;\r\nstruct poseidon *pd = front->pd;\r\nlogs(front);\r\n#ifdef CONFIG_PM\r\npd->pm_suspend = pm_video_suspend;\r\npd->pm_resume = pm_video_resume;\r\n#endif\r\nreturn set_frequency(pd, freq->frequency);\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *fh,\r\nstruct v4l2_requestbuffers *b)\r\n{\r\nstruct front_face *front = file->private_data;\r\nlogs(front);\r\nreturn videobuf_reqbufs(&front->q, b);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct front_face *front = file->private_data;\r\nlogs(front);\r\nreturn videobuf_querybuf(&front->q, b);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct front_face *front = file->private_data;\r\nreturn videobuf_qbuf(&front->q, b);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct front_face *front = file->private_data;\r\nreturn videobuf_dqbuf(&front->q, b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int usb_transfer_stop(struct video_data *video)\r\n{\r\nif (video->is_streaming) {\r\nint i;\r\ns32 cmd_status;\r\nstruct poseidon *pd = video->pd;\r\nvideo->is_streaming = 0;\r\nfor (i = 0; i < SBUF_NUM; ++i) {\r\nif (video->urb_array[i])\r\nusb_kill_urb(video->urb_array[i]);\r\n}\r\nsend_set_req(pd, PLAY_SERVICE, TLG_TUNE_PLAY_SVC_STOP,\r\n&cmd_status);\r\n}\r\nreturn 0;\r\n}\r\nint stop_all_video_stream(struct poseidon *pd)\r\n{\r\nstruct video_data *video = &pd->video_data;\r\nstruct vbi_data *vbi = &pd->vbi_data;\r\nmutex_lock(&pd->lock);\r\nif (video->is_streaming) {\r\nstruct front_face *front = video->front;\r\nusb_transfer_stop(video);\r\nfree_all_urb(video);\r\nvideobuf_stop(&front->q);\r\nvideobuf_mmap_free(&front->q);\r\nfront = vbi->front;\r\nif (front) {\r\nvideobuf_stop(&front->q);\r\nvideobuf_mmap_free(&front->q);\r\n}\r\n}\r\nmutex_unlock(&pd->lock);\r\nreturn 0;\r\n}\r\nstatic void iso_bubble_handler(struct work_struct *w)\r\n{\r\nstruct video_data *video;\r\nstruct poseidon *pd;\r\nvideo = container_of(w, struct video_data, bubble_work);\r\npd = video->pd;\r\nmutex_lock(&pd->lock);\r\nusb_transfer_stop(video);\r\nmsleep(500);\r\nstart_video_stream(pd);\r\nmutex_unlock(&pd->lock);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *fh,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct front_face *front = fh;\r\nlogs(front);\r\nif (unlikely(type != front->type))\r\nreturn -EINVAL;\r\nreturn videobuf_streamon(&front->q);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *fh,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct front_face *front = file->private_data;\r\nlogs(front);\r\nif (unlikely(type != front->type))\r\nreturn -EINVAL;\r\nreturn videobuf_streamoff(&front->q);\r\n}\r\nstatic int pd_video_checkmode(struct poseidon *pd)\r\n{\r\ns32 ret = 0, cmd_status, audiomode;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ/2);\r\nret = usb_set_interface(pd->udev, 0,\r\n(pd->cur_transfer_mode ?\r\nISO_3K_BULK_ALTERNATE_IFACE :\r\nBULK_ALTERNATE_IFACE));\r\nif (ret < 0)\r\ngoto error;\r\nret = set_tuner_mode(pd, TLG_MODE_ANALOG_TV);\r\nret |= send_set_req(pd, SGNL_SRC_SEL,\r\nTLG_SIG_SRC_ANTENNA, &cmd_status);\r\nret |= send_set_req(pd, VIDEO_STD_SEL,\r\nTLG_TUNE_VSTD_PAL_D, &cmd_status);\r\nret |= send_set_req(pd, VIDEO_STREAM_FMT_SEL,\r\nTLG_TUNER_VID_FORMAT_YUV, &cmd_status);\r\nret |= send_set_req(pd, VIDEO_ROSOLU_SEL,\r\nTLG_TUNE_VID_RES_720, &cmd_status);\r\nret |= send_set_req(pd, TUNE_FREQ_SELECT, TUNER_FREQ_MIN, &cmd_status);\r\nret |= send_set_req(pd, VBI_DATA_SEL, 1, &cmd_status);\r\naudiomode = get_audio_std(pd->video_data.context.tvnormid);\r\nret |= send_set_req(pd, TUNER_AUD_ANA_STD, audiomode, &cmd_status);\r\nret |= send_set_req(pd, TUNER_AUD_MODE,\r\nTLG_TUNE_TVAUDIO_MODE_STEREO, &cmd_status);\r\nret |= send_set_req(pd, AUDIO_SAMPLE_RATE_SEL,\r\nATV_AUDIO_RATE_48K, &cmd_status);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int pm_video_suspend(struct poseidon *pd)\r\n{\r\npm_alsa_suspend(pd);\r\nusb_transfer_stop(&pd->video_data);\r\nfree_all_urb(&pd->video_data);\r\nusb_set_interface(pd->udev, 0, 0);\r\nmsleep(300);\r\nreturn 0;\r\n}\r\nstatic int restore_v4l2_context(struct poseidon *pd,\r\nstruct running_context *context)\r\n{\r\nstruct front_face *front = pd->video_data.front;\r\npd_video_checkmode(pd);\r\nset_std(pd, &context->tvnormid);\r\nvidioc_s_input(NULL, front, context->sig_index);\r\npd_vidioc_s_tuner(pd, context->audio_idx);\r\npd_vidioc_s_fmt(pd, &context->pix);\r\nset_frequency(pd, context->freq);\r\nreturn 0;\r\n}\r\nstatic int pm_video_resume(struct poseidon *pd)\r\n{\r\nstruct video_data *video = &pd->video_data;\r\nrestore_v4l2_context(pd, &video->context);\r\nif (video->front->curr_frame)\r\ninit_copy(video, 0);\r\nstart_video_stream(pd);\r\npm_alsa_resume(pd);\r\nreturn 0;\r\n}\r\nvoid set_debug_mode(struct video_device *vfd, int debug_mode)\r\n{\r\nvfd->debug = 0;\r\nif (debug_mode & 0x1)\r\nvfd->debug = V4L2_DEBUG_IOCTL;\r\nif (debug_mode & 0x2)\r\nvfd->debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;\r\n}\r\nstatic void init_video_context(struct running_context *context)\r\n{\r\ncontext->sig_index = 0;\r\ncontext->audio_idx = 1;\r\ncontext->tvnormid = V4L2_STD_PAL_D;\r\ncontext->pix = (struct v4l2_pix_format) {\r\n.width = 720,\r\n.height = 576,\r\n.pixelformat = V4L2_PIX_FMT_YUYV,\r\n.field = V4L2_FIELD_INTERLACED,\r\n.bytesperline = 720 * 2,\r\n.sizeimage = 720 * 576 * 2,\r\n.colorspace = V4L2_COLORSPACE_SMPTE170M,\r\n.priv = 0\r\n};\r\n}\r\nstatic int pd_video_open(struct file *file)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct poseidon *pd = video_get_drvdata(vfd);\r\nstruct front_face *front = NULL;\r\nint ret = -ENOMEM;\r\nmutex_lock(&pd->lock);\r\nusb_autopm_get_interface(pd->interface);\r\nif (vfd->vfl_type == VFL_TYPE_GRABBER\r\n&& !(pd->state & POSEIDON_STATE_ANALOG)) {\r\nfront = kzalloc(sizeof(struct front_face), GFP_KERNEL);\r\nif (!front)\r\ngoto out;\r\npd->cur_transfer_mode = usb_transfer_mode;\r\ninit_video_context(&pd->video_data.context);\r\nret = pd_video_checkmode(pd);\r\nif (ret < 0) {\r\nkfree(front);\r\nret = -1;\r\ngoto out;\r\n}\r\npd->state |= POSEIDON_STATE_ANALOG;\r\nfront->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\npd->video_data.users++;\r\nset_debug_mode(vfd, debug_mode);\r\nvideobuf_queue_vmalloc_init(&front->q, &pd_video_qops,\r\nNULL, &front->queue_lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct videobuf_buffer),\r\nfront, NULL);\r\n} else if (vfd->vfl_type == VFL_TYPE_VBI\r\n&& !(pd->state & POSEIDON_STATE_VBI)) {\r\nfront = kzalloc(sizeof(struct front_face), GFP_KERNEL);\r\nif (!front)\r\ngoto out;\r\npd->state |= POSEIDON_STATE_VBI;\r\nfront->type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\npd->vbi_data.front = front;\r\npd->vbi_data.users++;\r\nvideobuf_queue_vmalloc_init(&front->q, &pd_video_qops,\r\nNULL, &front->queue_lock,\r\nV4L2_BUF_TYPE_VBI_CAPTURE,\r\nV4L2_FIELD_NONE,\r\nsizeof(struct videobuf_buffer),\r\nfront, NULL);\r\n} else {\r\nlog("other ");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfront->pd = pd;\r\nfront->curr_frame = NULL;\r\nINIT_LIST_HEAD(&front->active);\r\nspin_lock_init(&front->queue_lock);\r\nfile->private_data = front;\r\nkref_get(&pd->kref);\r\nmutex_unlock(&pd->lock);\r\nreturn 0;\r\nout:\r\nusb_autopm_put_interface(pd->interface);\r\nmutex_unlock(&pd->lock);\r\nreturn ret;\r\n}\r\nstatic int pd_video_release(struct file *file)\r\n{\r\nstruct front_face *front = file->private_data;\r\nstruct poseidon *pd = front->pd;\r\ns32 cmd_status = 0;\r\nlogs(front);\r\nmutex_lock(&pd->lock);\r\nif (front->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\npd->state &= ~POSEIDON_STATE_ANALOG;\r\nusb_transfer_stop(&pd->video_data);\r\nfree_all_urb(&pd->video_data);\r\nsend_set_req(pd, PLAY_SERVICE, TLG_TUNE_PLAY_SVC_STOP,\r\n&cmd_status);\r\npd->file_for_stream = NULL;\r\npd->video_data.users--;\r\n} else if (front->type == V4L2_BUF_TYPE_VBI_CAPTURE) {\r\npd->state &= ~POSEIDON_STATE_VBI;\r\npd->vbi_data.front = NULL;\r\npd->vbi_data.users--;\r\n}\r\nvideobuf_stop(&front->q);\r\nvideobuf_mmap_free(&front->q);\r\nusb_autopm_put_interface(pd->interface);\r\nmutex_unlock(&pd->lock);\r\nkfree(front);\r\nfile->private_data = NULL;\r\nkref_put(&pd->kref, poseidon_delete);\r\nreturn 0;\r\n}\r\nstatic int pd_video_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct front_face *front = file->private_data;\r\nreturn videobuf_mmap_mapper(&front->q, vma);\r\n}\r\nstatic unsigned int pd_video_poll(struct file *file, poll_table *table)\r\n{\r\nstruct front_face *front = file->private_data;\r\nreturn videobuf_poll_stream(file, &front->q, table);\r\n}\r\nstatic ssize_t pd_video_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct front_face *front = file->private_data;\r\nreturn videobuf_read_stream(&front->q, buffer, count, ppos,\r\n0, file->f_flags & O_NONBLOCK);\r\n}\r\nstruct video_device *vdev_init(struct poseidon *pd, struct video_device *tmp)\r\n{\r\nstruct video_device *vfd;\r\nvfd = video_device_alloc();\r\nif (vfd == NULL)\r\nreturn NULL;\r\n*vfd = *tmp;\r\nvfd->minor = -1;\r\nvfd->v4l2_dev = &pd->v4l2_dev;\r\nvfd->release = video_device_release;\r\nvideo_set_drvdata(vfd, pd);\r\nreturn vfd;\r\n}\r\nvoid destroy_video_device(struct video_device **v_dev)\r\n{\r\nstruct video_device *dev = *v_dev;\r\nif (dev == NULL)\r\nreturn;\r\nif (video_is_registered(dev))\r\nvideo_unregister_device(dev);\r\nelse\r\nvideo_device_release(dev);\r\n*v_dev = NULL;\r\n}\r\nvoid pd_video_exit(struct poseidon *pd)\r\n{\r\nstruct video_data *video = &pd->video_data;\r\nstruct vbi_data *vbi = &pd->vbi_data;\r\ndestroy_video_device(&video->v_dev);\r\ndestroy_video_device(&vbi->v_dev);\r\nlog();\r\n}\r\nint pd_video_init(struct poseidon *pd)\r\n{\r\nstruct video_data *video = &pd->video_data;\r\nstruct vbi_data *vbi = &pd->vbi_data;\r\nint ret = -ENOMEM;\r\nvideo->v_dev = vdev_init(pd, &pd_video_template);\r\nif (video->v_dev == NULL)\r\ngoto out;\r\nret = video_register_device(video->v_dev, VFL_TYPE_GRABBER, -1);\r\nif (ret != 0)\r\ngoto out;\r\nvbi->v_dev = vdev_init(pd, &pd_video_template);\r\nif (vbi->v_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = video_register_device(vbi->v_dev, VFL_TYPE_VBI, -1);\r\nif (ret != 0)\r\ngoto out;\r\nlog("register VIDEO/VBI devices");\r\nreturn 0;\r\nout:\r\nlog("VIDEO/VBI devices register failed, : %d", ret);\r\npd_video_exit(pd);\r\nreturn ret;\r\n}
