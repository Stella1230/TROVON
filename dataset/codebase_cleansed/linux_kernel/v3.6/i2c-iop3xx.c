static inline unsigned char\r\niic_cook_addr(struct i2c_msg *msg)\r\n{\r\nunsigned char addr;\r\naddr = (msg->addr << 1);\r\nif (msg->flags & I2C_M_RD)\r\naddr |= 1;\r\nreturn addr;\r\n}\r\nstatic void\r\niop3xx_i2c_reset(struct i2c_algo_iop3xx_data *iop3xx_adap)\r\n{\r\n__raw_writel(IOP3XX_ICR_UNIT_RESET, iop3xx_adap->ioaddr + CR_OFFSET);\r\n__raw_writel(IOP3XX_ISR_CLEARBITS, iop3xx_adap->ioaddr + SR_OFFSET);\r\n__raw_writel(0, iop3xx_adap->ioaddr + CR_OFFSET);\r\n}\r\nstatic void\r\niop3xx_i2c_enable(struct i2c_algo_iop3xx_data *iop3xx_adap)\r\n{\r\nu32 cr = IOP3XX_ICR_GCD | IOP3XX_ICR_SCLEN | IOP3XX_ICR_UE;\r\n#if defined(CONFIG_ARCH_IOP32X) || defined(CONFIG_ARCH_IOP33X)\r\nif (iop3xx_adap->id == 0) {\r\ngpio_line_set(IOP3XX_GPIO_LINE(7), GPIO_LOW);\r\ngpio_line_set(IOP3XX_GPIO_LINE(6), GPIO_LOW);\r\n} else {\r\ngpio_line_set(IOP3XX_GPIO_LINE(5), GPIO_LOW);\r\ngpio_line_set(IOP3XX_GPIO_LINE(4), GPIO_LOW);\r\n}\r\n#endif\r\niop3xx_adap->SR_enabled =\r\nIOP3XX_ISR_ALD | IOP3XX_ISR_BERRD |\r\nIOP3XX_ISR_RXFULL | IOP3XX_ISR_TXEMPTY;\r\ncr |= IOP3XX_ICR_ALD_IE | IOP3XX_ICR_BERR_IE |\r\nIOP3XX_ICR_RXFULL_IE | IOP3XX_ICR_TXEMPTY_IE;\r\n__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\r\n}\r\nstatic void\r\niop3xx_i2c_transaction_cleanup(struct i2c_algo_iop3xx_data *iop3xx_adap)\r\n{\r\nunsigned long cr = __raw_readl(iop3xx_adap->ioaddr + CR_OFFSET);\r\ncr &= ~(IOP3XX_ICR_MSTART | IOP3XX_ICR_TBYTE |\r\nIOP3XX_ICR_MSTOP | IOP3XX_ICR_SCLEN);\r\n__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\r\n}\r\nstatic irqreturn_t\r\niop3xx_i2c_irq_handler(int this_irq, void *dev_id)\r\n{\r\nstruct i2c_algo_iop3xx_data *iop3xx_adap = dev_id;\r\nu32 sr = __raw_readl(iop3xx_adap->ioaddr + SR_OFFSET);\r\nif ((sr &= iop3xx_adap->SR_enabled)) {\r\n__raw_writel(sr, iop3xx_adap->ioaddr + SR_OFFSET);\r\niop3xx_adap->SR_received |= sr;\r\nwake_up_interruptible(&iop3xx_adap->waitq);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\niop3xx_i2c_error(u32 sr)\r\n{\r\nint rc = 0;\r\nif ((sr & IOP3XX_ISR_BERRD)) {\r\nif ( !rc ) rc = -I2C_ERR_BERR;\r\n}\r\nif ((sr & IOP3XX_ISR_ALD)) {\r\nif ( !rc ) rc = -I2C_ERR_ALD;\r\n}\r\nreturn rc;\r\n}\r\nstatic inline u32\r\niop3xx_i2c_get_srstat(struct i2c_algo_iop3xx_data *iop3xx_adap)\r\n{\r\nunsigned long flags;\r\nu32 sr;\r\nspin_lock_irqsave(&iop3xx_adap->lock, flags);\r\nsr = iop3xx_adap->SR_received;\r\niop3xx_adap->SR_received = 0;\r\nspin_unlock_irqrestore(&iop3xx_adap->lock, flags);\r\nreturn sr;\r\n}\r\nstatic int\r\niop3xx_i2c_wait_event(struct i2c_algo_iop3xx_data *iop3xx_adap,\r\nunsigned flags, unsigned* status,\r\ncompare_func compare)\r\n{\r\nunsigned sr = 0;\r\nint interrupted;\r\nint done;\r\nint rc = 0;\r\ndo {\r\ninterrupted = wait_event_interruptible_timeout (\r\niop3xx_adap->waitq,\r\n(done = compare( sr = iop3xx_i2c_get_srstat(iop3xx_adap) ,flags )),\r\n1 * HZ;\r\n);\r\nif ((rc = iop3xx_i2c_error(sr)) < 0) {\r\n*status = sr;\r\nreturn rc;\r\n} else if (!interrupted) {\r\n*status = sr;\r\nreturn -ETIMEDOUT;\r\n}\r\n} while(!done);\r\n*status = sr;\r\nreturn 0;\r\n}\r\nstatic int\r\nall_bits_clear(unsigned test, unsigned mask)\r\n{\r\nreturn (test & mask) == 0;\r\n}\r\nstatic int\r\nany_bits_set(unsigned test, unsigned mask)\r\n{\r\nreturn (test & mask) != 0;\r\n}\r\nstatic int\r\niop3xx_i2c_wait_tx_done(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)\r\n{\r\nreturn iop3xx_i2c_wait_event(\r\niop3xx_adap,\r\nIOP3XX_ISR_TXEMPTY | IOP3XX_ISR_ALD | IOP3XX_ISR_BERRD,\r\nstatus, any_bits_set);\r\n}\r\nstatic int\r\niop3xx_i2c_wait_rx_done(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)\r\n{\r\nreturn iop3xx_i2c_wait_event(\r\niop3xx_adap,\r\nIOP3XX_ISR_RXFULL | IOP3XX_ISR_ALD | IOP3XX_ISR_BERRD,\r\nstatus, any_bits_set);\r\n}\r\nstatic int\r\niop3xx_i2c_wait_idle(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)\r\n{\r\nreturn iop3xx_i2c_wait_event(\r\niop3xx_adap, IOP3XX_ISR_UNITBUSY, status, all_bits_clear);\r\n}\r\nstatic int\r\niop3xx_i2c_send_target_addr(struct i2c_algo_iop3xx_data *iop3xx_adap,\r\nstruct i2c_msg* msg)\r\n{\r\nunsigned long cr = __raw_readl(iop3xx_adap->ioaddr + CR_OFFSET);\r\nint status;\r\nint rc;\r\nif (msg->addr == MYSAR) {\r\nreturn -EBUSY;\r\n}\r\n__raw_writel(iic_cook_addr(msg), iop3xx_adap->ioaddr + DBR_OFFSET);\r\ncr &= ~(IOP3XX_ICR_MSTOP | IOP3XX_ICR_NACK);\r\ncr |= IOP3XX_ICR_MSTART | IOP3XX_ICR_TBYTE;\r\n__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\r\nrc = iop3xx_i2c_wait_tx_done(iop3xx_adap, &status);\r\nreturn rc;\r\n}\r\nstatic int\r\niop3xx_i2c_write_byte(struct i2c_algo_iop3xx_data *iop3xx_adap, char byte,\r\nint stop)\r\n{\r\nunsigned long cr = __raw_readl(iop3xx_adap->ioaddr + CR_OFFSET);\r\nint status;\r\nint rc = 0;\r\n__raw_writel(byte, iop3xx_adap->ioaddr + DBR_OFFSET);\r\ncr &= ~IOP3XX_ICR_MSTART;\r\nif (stop) {\r\ncr |= IOP3XX_ICR_MSTOP;\r\n} else {\r\ncr &= ~IOP3XX_ICR_MSTOP;\r\n}\r\ncr |= IOP3XX_ICR_TBYTE;\r\n__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\r\nrc = iop3xx_i2c_wait_tx_done(iop3xx_adap, &status);\r\nreturn rc;\r\n}\r\nstatic int\r\niop3xx_i2c_read_byte(struct i2c_algo_iop3xx_data *iop3xx_adap, char* byte,\r\nint stop)\r\n{\r\nunsigned long cr = __raw_readl(iop3xx_adap->ioaddr + CR_OFFSET);\r\nint status;\r\nint rc = 0;\r\ncr &= ~IOP3XX_ICR_MSTART;\r\nif (stop) {\r\ncr |= IOP3XX_ICR_MSTOP | IOP3XX_ICR_NACK;\r\n} else {\r\ncr &= ~(IOP3XX_ICR_MSTOP | IOP3XX_ICR_NACK);\r\n}\r\ncr |= IOP3XX_ICR_TBYTE;\r\n__raw_writel(cr, iop3xx_adap->ioaddr + CR_OFFSET);\r\nrc = iop3xx_i2c_wait_rx_done(iop3xx_adap, &status);\r\n*byte = __raw_readl(iop3xx_adap->ioaddr + DBR_OFFSET);\r\nreturn rc;\r\n}\r\nstatic int\r\niop3xx_i2c_writebytes(struct i2c_adapter *i2c_adap, const char *buf, int count)\r\n{\r\nstruct i2c_algo_iop3xx_data *iop3xx_adap = i2c_adap->algo_data;\r\nint ii;\r\nint rc = 0;\r\nfor (ii = 0; rc == 0 && ii != count; ++ii)\r\nrc = iop3xx_i2c_write_byte(iop3xx_adap, buf[ii], ii==count-1);\r\nreturn rc;\r\n}\r\nstatic int\r\niop3xx_i2c_readbytes(struct i2c_adapter *i2c_adap, char *buf, int count)\r\n{\r\nstruct i2c_algo_iop3xx_data *iop3xx_adap = i2c_adap->algo_data;\r\nint ii;\r\nint rc = 0;\r\nfor (ii = 0; rc == 0 && ii != count; ++ii)\r\nrc = iop3xx_i2c_read_byte(iop3xx_adap, &buf[ii], ii==count-1);\r\nreturn rc;\r\n}\r\nstatic int\r\niop3xx_i2c_handle_msg(struct i2c_adapter *i2c_adap, struct i2c_msg* pmsg)\r\n{\r\nstruct i2c_algo_iop3xx_data *iop3xx_adap = i2c_adap->algo_data;\r\nint rc;\r\nrc = iop3xx_i2c_send_target_addr(iop3xx_adap, pmsg);\r\nif (rc < 0) {\r\nreturn rc;\r\n}\r\nif ((pmsg->flags&I2C_M_RD)) {\r\nreturn iop3xx_i2c_readbytes(i2c_adap, pmsg->buf, pmsg->len);\r\n} else {\r\nreturn iop3xx_i2c_writebytes(i2c_adap, pmsg->buf, pmsg->len);\r\n}\r\n}\r\nstatic int\r\niop3xx_i2c_master_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct i2c_algo_iop3xx_data *iop3xx_adap = i2c_adap->algo_data;\r\nint im = 0;\r\nint ret = 0;\r\nint status;\r\niop3xx_i2c_wait_idle(iop3xx_adap, &status);\r\niop3xx_i2c_reset(iop3xx_adap);\r\niop3xx_i2c_enable(iop3xx_adap);\r\nfor (im = 0; ret == 0 && im != num; im++) {\r\nret = iop3xx_i2c_handle_msg(i2c_adap, &msgs[im]);\r\n}\r\niop3xx_i2c_transaction_cleanup(iop3xx_adap);\r\nif(ret)\r\nreturn ret;\r\nreturn im;\r\n}\r\nstatic u32\r\niop3xx_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int\r\niop3xx_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_adapter *padapter = platform_get_drvdata(pdev);\r\nstruct i2c_algo_iop3xx_data *adapter_data =\r\n(struct i2c_algo_iop3xx_data *)padapter->algo_data;\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nunsigned long cr = __raw_readl(adapter_data->ioaddr + CR_OFFSET);\r\ncr &= ~(IOP3XX_ICR_ALD_IE | IOP3XX_ICR_BERR_IE |\r\nIOP3XX_ICR_RXFULL_IE | IOP3XX_ICR_TXEMPTY_IE);\r\n__raw_writel(cr, adapter_data->ioaddr + CR_OFFSET);\r\niounmap(adapter_data->ioaddr);\r\nrelease_mem_region(res->start, IOP3XX_I2C_IO_SIZE);\r\nkfree(adapter_data);\r\nkfree(padapter);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\niop3xx_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint ret, irq;\r\nstruct i2c_adapter *new_adapter;\r\nstruct i2c_algo_iop3xx_data *adapter_data;\r\nnew_adapter = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);\r\nif (!new_adapter) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nadapter_data = kzalloc(sizeof(struct i2c_algo_iop3xx_data), GFP_KERNEL);\r\nif (!adapter_data) {\r\nret = -ENOMEM;\r\ngoto free_adapter;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ngoto free_both;\r\n}\r\nif (!request_mem_region(res->start, IOP3XX_I2C_IO_SIZE, pdev->name)) {\r\nret = -EBUSY;\r\ngoto free_both;\r\n}\r\nadapter_data->id = i2c_id++;\r\nadapter_data->ioaddr = ioremap(res->start, IOP3XX_I2C_IO_SIZE);\r\nif (!adapter_data->ioaddr) {\r\nret = -ENOMEM;\r\ngoto release_region;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = -ENXIO;\r\ngoto unmap;\r\n}\r\nret = request_irq(irq, iop3xx_i2c_irq_handler, 0,\r\npdev->name, adapter_data);\r\nif (ret) {\r\nret = -EIO;\r\ngoto unmap;\r\n}\r\nmemcpy(new_adapter->name, pdev->name, strlen(pdev->name));\r\nnew_adapter->owner = THIS_MODULE;\r\nnew_adapter->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nnew_adapter->dev.parent = &pdev->dev;\r\nnew_adapter->nr = pdev->id;\r\nnew_adapter->timeout = HZ;\r\nnew_adapter->algo = &iop3xx_i2c_algo;\r\ninit_waitqueue_head(&adapter_data->waitq);\r\nspin_lock_init(&adapter_data->lock);\r\niop3xx_i2c_reset(adapter_data);\r\niop3xx_i2c_enable(adapter_data);\r\nplatform_set_drvdata(pdev, new_adapter);\r\nnew_adapter->algo_data = adapter_data;\r\ni2c_add_numbered_adapter(new_adapter);\r\nreturn 0;\r\nunmap:\r\niounmap(adapter_data->ioaddr);\r\nrelease_region:\r\nrelease_mem_region(res->start, IOP3XX_I2C_IO_SIZE);\r\nfree_both:\r\nkfree(adapter_data);\r\nfree_adapter:\r\nkfree(new_adapter);\r\nout:\r\nreturn ret;\r\n}
