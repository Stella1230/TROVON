static void sigd_put_skb(struct sk_buff *skb)\r\n{\r\n#ifdef WAIT_FOR_DEMON\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&sigd_sleep, &wait);\r\nwhile (!sigd) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\npr_debug("atmsvc: waiting for signaling daemon...\n");\r\nschedule();\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&sigd_sleep, &wait);\r\n#else\r\nif (!sigd) {\r\npr_debug("atmsvc: no signaling daemon\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\n#endif\r\natm_force_charge(sigd, skb->truesize);\r\nskb_queue_tail(&sk_atm(sigd)->sk_receive_queue, skb);\r\nsk_atm(sigd)->sk_data_ready(sk_atm(sigd), skb->len);\r\n}\r\nstatic void modify_qos(struct atm_vcc *vcc, struct atmsvc_msg *msg)\r\n{\r\nstruct sk_buff *skb;\r\nif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\r\n!test_bit(ATM_VF_READY, &vcc->flags))\r\nreturn;\r\nmsg->type = as_error;\r\nif (!vcc->dev->ops->change_qos)\r\nmsg->reply = -EOPNOTSUPP;\r\nelse {\r\nmsg->reply = vcc->dev->ops->change_qos(vcc, &msg->qos,\r\nmsg->reply);\r\nif (!msg->reply)\r\nmsg->type = as_okay;\r\n}\r\nwhile (!(skb = alloc_skb(sizeof(struct atmsvc_msg), GFP_KERNEL)))\r\nschedule();\r\n*(struct atmsvc_msg *)skb_put(skb, sizeof(struct atmsvc_msg)) = *msg;\r\nsigd_put_skb(skb);\r\n}\r\nstatic int sigd_send(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct atmsvc_msg *msg;\r\nstruct atm_vcc *session_vcc;\r\nstruct sock *sk;\r\nmsg = (struct atmsvc_msg *) skb->data;\r\natomic_sub(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);\r\nvcc = *(struct atm_vcc **) &msg->vcc;\r\npr_debug("%d (0x%lx)\n", (int)msg->type, (unsigned long)vcc);\r\nsk = sk_atm(vcc);\r\nswitch (msg->type) {\r\ncase as_okay:\r\nsk->sk_err = -msg->reply;\r\nclear_bit(ATM_VF_WAITING, &vcc->flags);\r\nif (!*vcc->local.sas_addr.prv && !*vcc->local.sas_addr.pub) {\r\nvcc->local.sas_family = AF_ATMSVC;\r\nmemcpy(vcc->local.sas_addr.prv,\r\nmsg->local.sas_addr.prv, ATM_ESA_LEN);\r\nmemcpy(vcc->local.sas_addr.pub,\r\nmsg->local.sas_addr.pub, ATM_E164_LEN + 1);\r\n}\r\nsession_vcc = vcc->session ? vcc->session : vcc;\r\nif (session_vcc->vpi || session_vcc->vci)\r\nbreak;\r\nsession_vcc->itf = msg->pvc.sap_addr.itf;\r\nsession_vcc->vpi = msg->pvc.sap_addr.vpi;\r\nsession_vcc->vci = msg->pvc.sap_addr.vci;\r\nif (session_vcc->vpi || session_vcc->vci)\r\nsession_vcc->qos = msg->qos;\r\nbreak;\r\ncase as_error:\r\nclear_bit(ATM_VF_REGIS, &vcc->flags);\r\nclear_bit(ATM_VF_READY, &vcc->flags);\r\nsk->sk_err = -msg->reply;\r\nclear_bit(ATM_VF_WAITING, &vcc->flags);\r\nbreak;\r\ncase as_indicate:\r\nvcc = *(struct atm_vcc **)&msg->listen_vcc;\r\nsk = sk_atm(vcc);\r\npr_debug("as_indicate!!!\n");\r\nlock_sock(sk);\r\nif (sk_acceptq_is_full(sk)) {\r\nsigd_enq(NULL, as_reject, vcc, NULL, NULL);\r\ndev_kfree_skb(skb);\r\ngoto as_indicate_complete;\r\n}\r\nsk->sk_ack_backlog++;\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\npr_debug("waking sk_sleep(sk) 0x%p\n", sk_sleep(sk));\r\nsk->sk_state_change(sk);\r\nas_indicate_complete:\r\nrelease_sock(sk);\r\nreturn 0;\r\ncase as_close:\r\nset_bit(ATM_VF_RELEASED, &vcc->flags);\r\nvcc_release_async(vcc, msg->reply);\r\ngoto out;\r\ncase as_modify:\r\nmodify_qos(vcc, msg);\r\nbreak;\r\ncase as_addparty:\r\ncase as_dropparty:\r\nsk->sk_err_soft = msg->reply;\r\nclear_bit(ATM_VF_WAITING, &vcc->flags);\r\nbreak;\r\ndefault:\r\npr_alert("bad message type %d\n", (int)msg->type);\r\nreturn -EINVAL;\r\n}\r\nsk->sk_state_change(sk);\r\nout:\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nvoid sigd_enq2(struct atm_vcc *vcc, enum atmsvc_msg_type type,\r\nstruct atm_vcc *listen_vcc, const struct sockaddr_atmpvc *pvc,\r\nconst struct sockaddr_atmsvc *svc, const struct atm_qos *qos,\r\nint reply)\r\n{\r\nstruct sk_buff *skb;\r\nstruct atmsvc_msg *msg;\r\nstatic unsigned int session = 0;\r\npr_debug("%d (0x%p)\n", (int)type, vcc);\r\nwhile (!(skb = alloc_skb(sizeof(struct atmsvc_msg), GFP_KERNEL)))\r\nschedule();\r\nmsg = (struct atmsvc_msg *)skb_put(skb, sizeof(struct atmsvc_msg));\r\nmemset(msg, 0, sizeof(*msg));\r\nmsg->type = type;\r\n*(struct atm_vcc **) &msg->vcc = vcc;\r\n*(struct atm_vcc **) &msg->listen_vcc = listen_vcc;\r\nmsg->reply = reply;\r\nif (qos)\r\nmsg->qos = *qos;\r\nif (vcc)\r\nmsg->sap = vcc->sap;\r\nif (svc)\r\nmsg->svc = *svc;\r\nif (vcc)\r\nmsg->local = vcc->local;\r\nif (pvc)\r\nmsg->pvc = *pvc;\r\nif (vcc) {\r\nif (type == as_connect && test_bit(ATM_VF_SESSION, &vcc->flags))\r\nmsg->session = ++session;\r\n}\r\nsigd_put_skb(skb);\r\nif (vcc)\r\nset_bit(ATM_VF_REGIS, &vcc->flags);\r\n}\r\nvoid sigd_enq(struct atm_vcc *vcc, enum atmsvc_msg_type type,\r\nstruct atm_vcc *listen_vcc, const struct sockaddr_atmpvc *pvc,\r\nconst struct sockaddr_atmsvc *svc)\r\n{\r\nsigd_enq2(vcc, type, listen_vcc, pvc, svc, vcc ? &vcc->qos : NULL, 0);\r\n}\r\nstatic void purge_vcc(struct atm_vcc *vcc)\r\n{\r\nif (sk_atm(vcc)->sk_family == PF_ATMSVC &&\r\n!test_bit(ATM_VF_META, &vcc->flags)) {\r\nset_bit(ATM_VF_RELEASED, &vcc->flags);\r\nclear_bit(ATM_VF_REGIS, &vcc->flags);\r\nvcc_release_async(vcc, -EUNATCH);\r\n}\r\n}\r\nstatic void sigd_close(struct atm_vcc *vcc)\r\n{\r\nstruct hlist_node *node;\r\nstruct sock *s;\r\nint i;\r\npr_debug("\n");\r\nsigd = NULL;\r\nif (skb_peek(&sk_atm(vcc)->sk_receive_queue))\r\npr_err("closing with requests pending\n");\r\nskb_queue_purge(&sk_atm(vcc)->sk_receive_queue);\r\nread_lock(&vcc_sklist_lock);\r\nfor (i = 0; i < VCC_HTABLE_SIZE; ++i) {\r\nstruct hlist_head *head = &vcc_hash[i];\r\nsk_for_each(s, node, head) {\r\nvcc = atm_sk(s);\r\npurge_vcc(vcc);\r\n}\r\n}\r\nread_unlock(&vcc_sklist_lock);\r\n}\r\nint sigd_attach(struct atm_vcc *vcc)\r\n{\r\nif (sigd)\r\nreturn -EADDRINUSE;\r\npr_debug("\n");\r\nsigd = vcc;\r\nvcc->dev = &sigd_dev;\r\nvcc_insert_socket(sk_atm(vcc));\r\nset_bit(ATM_VF_META, &vcc->flags);\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\n#ifdef WAIT_FOR_DEMON\r\nwake_up(&sigd_sleep);\r\n#endif\r\nreturn 0;\r\n}
