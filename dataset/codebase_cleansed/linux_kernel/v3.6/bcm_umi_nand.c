static void nand_dma_handler(DMA_Device_t dev, int reason, void *userData)\r\n{\r\ncomplete(&nand_comp);\r\n}\r\nstatic int nand_dma_init(void)\r\n{\r\nint rc;\r\nrc = dma_set_device_handler(DMA_DEVICE_NAND_MEM_TO_MEM,\r\nnand_dma_handler, NULL);\r\nif (rc != 0) {\r\nprintk(KERN_ERR "dma_set_device_handler failed: %d\n", rc);\r\nreturn rc;\r\n}\r\nvirtPtr =\r\ndma_alloc_coherent(NULL, DMA_MAX_BUFLEN, &physPtr, GFP_KERNEL);\r\nif (virtPtr == NULL) {\r\nprintk(KERN_ERR "NAND - Failed to allocate memory for DMA buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nand_dma_term(void)\r\n{\r\nif (virtPtr != NULL)\r\ndma_free_coherent(NULL, DMA_MAX_BUFLEN, virtPtr, physPtr);\r\n}\r\nstatic void nand_dma_read(void *buf, int len)\r\n{\r\nint offset = 0;\r\nint tmp_len = 0;\r\nint len_left = len;\r\nDMA_Handle_t hndl;\r\nif (virtPtr == NULL)\r\npanic("nand_dma_read: virtPtr == NULL\n");\r\nif ((void *)physPtr == NULL)\r\npanic("nand_dma_read: physPtr == NULL\n");\r\nhndl = dma_request_channel(DMA_DEVICE_NAND_MEM_TO_MEM);\r\nif (hndl < 0) {\r\nprintk(KERN_ERR\r\n"nand_dma_read: unable to allocate dma channel: %d\n",\r\n(int)hndl);\r\npanic("\n");\r\n}\r\nwhile (len_left > 0) {\r\nif (len_left > DMA_MAX_LEN) {\r\ntmp_len = DMA_MAX_LEN;\r\nlen_left -= DMA_MAX_LEN;\r\n} else {\r\ntmp_len = len_left;\r\nlen_left = 0;\r\n}\r\ninit_completion(&nand_comp);\r\ndma_transfer_mem_to_mem(hndl, REG_NAND_DATA_PADDR,\r\nphysPtr + offset, tmp_len);\r\nwait_for_completion(&nand_comp);\r\noffset += tmp_len;\r\n}\r\ndma_free_channel(hndl);\r\nif (buf != NULL)\r\nmemcpy(buf, virtPtr, len);\r\n}\r\nstatic void nand_dma_write(const void *buf, int len)\r\n{\r\nint offset = 0;\r\nint tmp_len = 0;\r\nint len_left = len;\r\nDMA_Handle_t hndl;\r\nif (buf == NULL)\r\npanic("nand_dma_write: buf == NULL\n");\r\nif (virtPtr == NULL)\r\npanic("nand_dma_write: virtPtr == NULL\n");\r\nif ((void *)physPtr == NULL)\r\npanic("nand_dma_write: physPtr == NULL\n");\r\nmemcpy(virtPtr, buf, len);\r\nhndl = dma_request_channel(DMA_DEVICE_NAND_MEM_TO_MEM);\r\nif (hndl < 0) {\r\nprintk(KERN_ERR\r\n"nand_dma_write: unable to allocate dma channel: %d\n",\r\n(int)hndl);\r\npanic("\n");\r\n}\r\nwhile (len_left > 0) {\r\nif (len_left > DMA_MAX_LEN) {\r\ntmp_len = DMA_MAX_LEN;\r\nlen_left -= DMA_MAX_LEN;\r\n} else {\r\ntmp_len = len_left;\r\nlen_left = 0;\r\n}\r\ninit_completion(&nand_comp);\r\ndma_transfer_mem_to_mem(hndl, physPtr + offset,\r\nREG_NAND_DATA_PADDR, tmp_len);\r\nwait_for_completion(&nand_comp);\r\noffset += tmp_len;\r\n}\r\ndma_free_channel(hndl);\r\n}\r\nstatic int nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nreturn nand_bcm_umi_dev_ready();\r\n}\r\nint bcm_umi_nand_inithw(void)\r\n{\r\nREG_UMI_NAND_TCR &= ~0x7ffff;\r\nREG_UMI_NAND_TCR |= HW_CFG_NAND_TCR;\r\n#if !defined(CONFIG_MTD_NAND_BCM_UMI_HWCS)\r\nREG_UMI_NAND_TCR |= REG_UMI_NAND_TCR_CS_SWCTRL;\r\n#endif\r\nREG_UMI_NAND_RCSR |= REG_UMI_NAND_RCSR_CS_ASSERTED;\r\nREG_UMI_NAND_TCR &= ~REG_UMI_NAND_TCR_WORD16;\r\nREG_UMI_MMD_ICR |= REG_UMI_MMD_ICR_FLASH_WP;\r\nwritel(NAND_CMD_RESET, bcm_umi_io_base + REG_NAND_CMD_OFFSET);\r\nnand_bcm_umi_wait_till_ready();\r\n#if NAND_ECC_BCH\r\nnand_bcm_umi_bch_config_ecc(NAND_ECC_NUM_BYTES);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void bcm_umi_nand_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif (ctrl & NAND_CLE) {\r\nchip->IO_ADDR_W = bcm_umi_io_base + REG_NAND_CMD_OFFSET;\r\ngoto CMD;\r\n}\r\nif (ctrl & NAND_ALE) {\r\nchip->IO_ADDR_W =\r\nbcm_umi_io_base + REG_NAND_ADDR_OFFSET;\r\ngoto CMD;\r\n}\r\nchip->IO_ADDR_W = bcm_umi_io_base + REG_NAND_DATA8_OFFSET;\r\n}\r\nCMD:\r\nif (cmd != NAND_CMD_NONE)\r\nwriteb(cmd, chip->IO_ADDR_W);\r\n}\r\nstatic void bcm_umi_nand_write_buf(struct mtd_info *mtd, const u_char * buf,\r\nint len)\r\n{\r\nif (USE_DIRECT_IO(len)) {\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i = 0; i < len; i++)\r\nwriteb(buf[i], this->IO_ADDR_W);\r\n}\r\n#if USE_DMA\r\nelse\r\nnand_dma_write(buf, len);\r\n#endif\r\n}\r\nstatic void bcm_umi_nand_read_buf(struct mtd_info *mtd, u_char * buf, int len)\r\n{\r\nif (USE_DIRECT_IO(len)) {\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = readb(this->IO_ADDR_R);\r\n}\r\n#if USE_DMA\r\nelse\r\nnand_dma_read(buf, len);\r\n#endif\r\n}\r\nstatic int bcm_umi_nand_verify_buf(struct mtd_info *mtd, const u_char * buf,\r\nint len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret = chip->ecc.read_page(mtd, chip, readbackbuf, 0, 0);\r\nif (ret < 0)\r\nreturn -EFAULT;\r\nelse {\r\nif (memcmp(readbackbuf, buf, len) == 0)\r\nreturn 0;\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit bcm_umi_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct nand_chip *this;\r\nstruct resource *r;\r\nint err = 0;\r\nprintk(gBanner);\r\nboard_mtd =\r\nkmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip),\r\nGFP_KERNEL);\r\nif (!board_mtd) {\r\nprintk(KERN_WARNING\r\n"Unable to allocate NAND MTD device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nerr = -ENXIO;\r\ngoto out_free;\r\n}\r\nbcm_umi_io_base = ioremap(r->start, resource_size(r));\r\nif (!bcm_umi_io_base) {\r\nprintk(KERN_ERR "ioremap to access BCM UMI NAND chip failed\n");\r\nerr = -EIO;\r\ngoto out_free;\r\n}\r\nthis = (struct nand_chip *)(&board_mtd[1]);\r\nmemset((char *)board_mtd, 0, sizeof(struct mtd_info));\r\nmemset((char *)this, 0, sizeof(struct nand_chip));\r\nboard_mtd->priv = this;\r\nif (bcm_umi_nand_inithw() < 0) {\r\nprintk(KERN_ERR "BCM UMI NAND chip could not be initialized\n");\r\nerr = -EIO;\r\ngoto out_unmap;\r\n}\r\nthis->IO_ADDR_W = bcm_umi_io_base + REG_NAND_DATA8_OFFSET;\r\nthis->IO_ADDR_R = bcm_umi_io_base + REG_NAND_DATA8_OFFSET;\r\nthis->chip_delay = 0;\r\nthis->dev_ready = nand_dev_ready;\r\nthis->options = 0;\r\nthis->write_buf = bcm_umi_nand_write_buf;\r\nthis->read_buf = bcm_umi_nand_read_buf;\r\nthis->verify_buf = bcm_umi_nand_verify_buf;\r\nthis->cmd_ctrl = bcm_umi_nand_hwcontrol;\r\nthis->ecc.mode = NAND_ECC_HW;\r\nthis->ecc.size = 512;\r\nthis->ecc.bytes = NAND_ECC_NUM_BYTES;\r\n#if NAND_ECC_BCH\r\nthis->ecc.read_page = bcm_umi_bch_read_page_hwecc;\r\nthis->ecc.write_page = bcm_umi_bch_write_page_hwecc;\r\n#else\r\nthis->ecc.correct = nand_correct_data512;\r\nthis->ecc.calculate = bcm_umi_hamming_get_hw_ecc;\r\nthis->ecc.hwctl = bcm_umi_hamming_enable_hwecc;\r\n#endif\r\n#if USE_DMA\r\nerr = nand_dma_init();\r\nif (err != 0)\r\ngoto out_unmap;\r\n#endif\r\nerr = nand_scan_ident(board_mtd, 1, NULL);\r\nif (err) {\r\nprintk(KERN_ERR "nand_scan failed: %d\n", err);\r\ngoto out_unmap;\r\n}\r\nswitch (board_mtd->writesize) {\r\ncase 4096:\r\nthis->ecc.layout = &nand_hw_eccoob_4096;\r\nbreak;\r\ncase 2048:\r\nthis->ecc.layout = &nand_hw_eccoob_2048;\r\nbreak;\r\ncase 512:\r\nthis->ecc.layout = &nand_hw_eccoob_512;\r\nbreak;\r\ndefault:\r\n{\r\nprintk(KERN_ERR "NAND - Unrecognized pagesize: %d\n",\r\nboard_mtd->writesize);\r\nerr = -EINVAL;\r\ngoto out_unmap;\r\n}\r\n}\r\n#if NAND_ECC_BCH\r\nif (board_mtd->writesize > 512) {\r\nif (this->bbt_options & NAND_BBT_USE_FLASH)\r\nlargepage_bbt.options = NAND_BBT_SCAN2NDPAGE;\r\nthis->badblock_pattern = &largepage_bbt;\r\n}\r\nthis->ecc.strength = 8;\r\n#endif\r\nerr = nand_scan_tail(board_mtd);\r\nif (err) {\r\nprintk(KERN_ERR "nand_scan failed: %d\n", err);\r\ngoto out_unmap;\r\n}\r\nboard_mtd->name = "bcm_umi-nand";\r\nmtd_device_parse_register(board_mtd, NULL, NULL, NULL, 0);\r\nreturn 0;\r\nout_unmap:\r\niounmap(bcm_umi_io_base);\r\nout_free:\r\nkfree(board_mtd);\r\nreturn err;\r\n}\r\nstatic int bcm_umi_nand_remove(struct platform_device *pdev)\r\n{\r\n#if USE_DMA\r\nnand_dma_term();\r\n#endif\r\nnand_release(board_mtd);\r\niounmap(bcm_umi_io_base);\r\nkfree(board_mtd);\r\nreturn 0;\r\n}\r\nstatic int bcm_umi_nand_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nprintk(KERN_ERR "MTD NAND suspend is being called\n");\r\nreturn 0;\r\n}\r\nstatic int bcm_umi_nand_resume(struct platform_device *pdev)\r\n{\r\nprintk(KERN_ERR "MTD NAND resume is being called\n");\r\nreturn 0;\r\n}
