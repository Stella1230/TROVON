static int da9052_set_led_brightness(struct da9052_led *led)\r\n{\r\nu8 val;\r\nint error;\r\nval = (led->brightness & 0x7f) | DA9052_LED_CONT_DIM;\r\nerror = da9052_reg_write(led->da9052, led_reg[led->led_index], val);\r\nif (error < 0)\r\ndev_err(led->da9052->dev, "Failed to set led brightness, %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nstatic void da9052_led_work(struct work_struct *work)\r\n{\r\nstruct da9052_led *led = container_of(work, struct da9052_led, work);\r\nda9052_set_led_brightness(led);\r\n}\r\nstatic void da9052_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct da9052_led *led;\r\nled = container_of(led_cdev, struct da9052_led, cdev);\r\nled->brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic int da9052_configure_leds(struct da9052 *da9052)\r\n{\r\nint error;\r\nunsigned char register_value = DA9052_OPENDRAIN_OUTPUT\r\n| DA9052_SET_HIGH_LVL_OUTPUT;\r\nerror = da9052_reg_update(da9052, DA9052_GPIO_14_15_REG,\r\nDA9052_MASK_LOWER_NIBBLE,\r\nregister_value);\r\nif (error < 0) {\r\ndev_err(da9052->dev, "Failed to write GPIO 14-15 reg, %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = da9052_reg_update(da9052, DA9052_GPIO_14_15_REG,\r\nDA9052_MASK_UPPER_NIBBLE,\r\nregister_value << DA9052_NIBBLE_SHIFT);\r\nif (error < 0)\r\ndev_err(da9052->dev, "Failed to write GPIO 14-15 reg, %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nstatic int __devinit da9052_led_probe(struct platform_device *pdev)\r\n{\r\nstruct da9052_pdata *pdata;\r\nstruct da9052 *da9052;\r\nstruct led_platform_data *pled;\r\nstruct da9052_led *led = NULL;\r\nint error = -ENODEV;\r\nint i;\r\nda9052 = dev_get_drvdata(pdev->dev.parent);\r\npdata = da9052->dev->platform_data;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "No platform data\n");\r\ngoto err;\r\n}\r\npled = pdata->pled;\r\nif (pled == NULL) {\r\ndev_err(&pdev->dev, "No platform data for LED\n");\r\ngoto err;\r\n}\r\nled = devm_kzalloc(&pdev->dev,\r\nsizeof(struct da9052_led) * pled->num_leds,\r\nGFP_KERNEL);\r\nif (led == NULL) {\r\ndev_err(&pdev->dev, "Failed to alloc memory\n");\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (i = 0; i < pled->num_leds; i++) {\r\nled[i].cdev.name = pled->leds[i].name;\r\nled[i].cdev.brightness_set = da9052_led_set;\r\nled[i].cdev.brightness = LED_OFF;\r\nled[i].cdev.max_brightness = DA9052_MAX_BRIGHTNESS;\r\nled[i].brightness = LED_OFF;\r\nled[i].led_index = pled->leds[i].flags;\r\nled[i].da9052 = dev_get_drvdata(pdev->dev.parent);\r\nINIT_WORK(&led[i].work, da9052_led_work);\r\nerror = led_classdev_register(pdev->dev.parent, &led[i].cdev);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to register led %d\n",\r\nled[i].led_index);\r\ngoto err_register;\r\n}\r\nerror = da9052_set_led_brightness(&led[i]);\r\nif (error) {\r\ndev_err(&pdev->dev, "Unable to init led %d\n",\r\nled[i].led_index);\r\ncontinue;\r\n}\r\n}\r\nerror = da9052_configure_leds(led->da9052);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to configure GPIO LED%d\n", error);\r\ngoto err_register;\r\n}\r\nplatform_set_drvdata(pdev, led);\r\nreturn 0;\r\nerr_register:\r\nfor (i = i - 1; i >= 0; i--) {\r\nled_classdev_unregister(&led[i].cdev);\r\ncancel_work_sync(&led[i].work);\r\n}\r\nerr:\r\nreturn error;\r\n}\r\nstatic int __devexit da9052_led_remove(struct platform_device *pdev)\r\n{\r\nstruct da9052_led *led = platform_get_drvdata(pdev);\r\nstruct da9052_pdata *pdata;\r\nstruct da9052 *da9052;\r\nstruct led_platform_data *pled;\r\nint i;\r\nda9052 = dev_get_drvdata(pdev->dev.parent);\r\npdata = da9052->dev->platform_data;\r\npled = pdata->pled;\r\nfor (i = 0; i < pled->num_leds; i++) {\r\nled[i].brightness = 0;\r\nda9052_set_led_brightness(&led[i]);\r\nled_classdev_unregister(&led[i].cdev);\r\ncancel_work_sync(&led[i].work);\r\n}\r\nreturn 0;\r\n}
