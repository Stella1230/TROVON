int mxl111sf_ctrl_msg(struct dvb_usb_device *d,\r\nu8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nint wo = (rbuf == NULL || rlen == 0);\r\nint ret;\r\nu8 sndbuf[1+wlen];\r\ndeb_adv("%s(wlen = %d, rlen = %d)\n", __func__, wlen, rlen);\r\nmemset(sndbuf, 0, 1+wlen);\r\nsndbuf[0] = cmd;\r\nmemcpy(&sndbuf[1], wbuf, wlen);\r\nret = (wo) ? dvb_usb_generic_write(d, sndbuf, 1+wlen) :\r\ndvb_usb_generic_rw(d, sndbuf, 1+wlen, rbuf, rlen, 0);\r\nmxl_fail(ret);\r\nreturn ret;\r\n}\r\nint mxl111sf_read_reg(struct mxl111sf_state *state, u8 addr, u8 *data)\r\n{\r\nu8 buf[2];\r\nint ret;\r\nret = mxl111sf_ctrl_msg(state->d, MXL_CMD_REG_READ, &addr, 1, buf, 2);\r\nif (mxl_fail(ret)) {\r\nmxl_debug("error reading reg: 0x%02x", addr);\r\ngoto fail;\r\n}\r\nif (buf[0] == addr)\r\n*data = buf[1];\r\nelse {\r\nerr("invalid response reading reg: 0x%02x != 0x%02x, 0x%02x",\r\naddr, buf[0], buf[1]);\r\nret = -EINVAL;\r\n}\r\ndeb_reg("R: (0x%02x, 0x%02x)\n", addr, *data);\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl111sf_write_reg(struct mxl111sf_state *state, u8 addr, u8 data)\r\n{\r\nu8 buf[] = { addr, data };\r\nint ret;\r\ndeb_reg("W: (0x%02x, 0x%02x)\n", addr, data);\r\nret = mxl111sf_ctrl_msg(state->d, MXL_CMD_REG_WRITE, buf, 2, NULL, 0);\r\nif (mxl_fail(ret))\r\nerr("error writing reg: 0x%02x, val: 0x%02x", addr, data);\r\nreturn ret;\r\n}\r\nint mxl111sf_write_reg_mask(struct mxl111sf_state *state,\r\nu8 addr, u8 mask, u8 data)\r\n{\r\nint ret;\r\nu8 val;\r\nif (mask != 0xff) {\r\nret = mxl111sf_read_reg(state, addr, &val);\r\n#if 1\r\nif (mxl_fail(ret))\r\nerr("error writing addr: 0x%02x, mask: 0x%02x, "\r\n"data: 0x%02x, retrying...", addr, mask, data);\r\nret = mxl111sf_read_reg(state, addr, &val);\r\n#endif\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n}\r\nval &= ~mask;\r\nval |= data;\r\nret = mxl111sf_write_reg(state, addr, val);\r\nmxl_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl111sf_ctrl_program_regs(struct mxl111sf_state *state,\r\nstruct mxl111sf_reg_ctrl_info *ctrl_reg_info)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; ctrl_reg_info[i].addr |\r\nctrl_reg_info[i].mask |\r\nctrl_reg_info[i].data; i++) {\r\nret = mxl111sf_write_reg_mask(state,\r\nctrl_reg_info[i].addr,\r\nctrl_reg_info[i].mask,\r\nctrl_reg_info[i].data);\r\nif (mxl_fail(ret)) {\r\nerr("failed on reg #%d (0x%02x)", i,\r\nctrl_reg_info[i].addr);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxl1x1sf_get_chip_info(struct mxl111sf_state *state)\r\n{\r\nint ret;\r\nu8 id, ver;\r\nchar *mxl_chip, *mxl_rev;\r\nif ((state->chip_id) && (state->chip_ver))\r\nreturn 0;\r\nret = mxl111sf_read_reg(state, CHIP_ID_REG, &id);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nstate->chip_id = id;\r\nret = mxl111sf_read_reg(state, TOP_CHIP_REV_ID_REG, &ver);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nstate->chip_ver = ver;\r\nswitch (id) {\r\ncase 0x61:\r\nmxl_chip = "MxL101SF";\r\nbreak;\r\ncase 0x63:\r\nmxl_chip = "MxL111SF";\r\nbreak;\r\ndefault:\r\nmxl_chip = "UNKNOWN MxL1X1";\r\nbreak;\r\n}\r\nswitch (ver) {\r\ncase 0x36:\r\nstate->chip_rev = MXL111SF_V6;\r\nmxl_rev = "v6";\r\nbreak;\r\ncase 0x08:\r\nstate->chip_rev = MXL111SF_V8_100;\r\nmxl_rev = "v8_100";\r\nbreak;\r\ncase 0x18:\r\nstate->chip_rev = MXL111SF_V8_200;\r\nmxl_rev = "v8_200";\r\nbreak;\r\ndefault:\r\nstate->chip_rev = 0;\r\nmxl_rev = "UNKNOWN REVISION";\r\nbreak;\r\n}\r\ninfo("%s detected, %s (0x%x)", mxl_chip, mxl_rev, ver);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_adap_fe_init(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nstruct mxl111sf_adap_state *adap_state = adap->fe_adap[fe->id].priv;\r\nint err;\r\nif (!state->chip_id) {\r\nmxl_debug("driver not yet initialized, exit.");\r\ngoto fail;\r\n}\r\ndeb_info("%s()\n", __func__);\r\nmutex_lock(&state->fe_lock);\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(adap->dev->udev, 0, state->alt_mode) < 0)\r\nerr("set interface failed");\r\nerr = mxl1x1sf_soft_reset(state);\r\nmxl_fail(err);\r\nerr = mxl111sf_init_tuner_demod(state);\r\nmxl_fail(err);\r\nerr = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nmxl_fail(err);\r\nmxl111sf_enable_usb_output(state);\r\nmxl_fail(err);\r\nmxl1x1sf_top_master_ctrl(state, 1);\r\nmxl_fail(err);\r\nif ((MXL111SF_GPIO_MOD_DVBT != adap_state->gpio_mode) &&\r\n(state->chip_rev > MXL111SF_V6)) {\r\nmxl111sf_config_pin_mux_modes(state,\r\nPIN_MUX_TS_SPI_IN_MODE_1);\r\nmxl_fail(err);\r\n}\r\nerr = mxl111sf_init_port_expander(state);\r\nif (!mxl_fail(err)) {\r\nstate->gpio_mode = adap_state->gpio_mode;\r\nerr = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nmxl_fail(err);\r\n#if 0\r\nerr = fe->ops.init(fe);\r\n#endif\r\nmsleep(100);\r\n}\r\nreturn (adap_state->fe_init) ? adap_state->fe_init(fe) : 0;\r\nfail:\r\nreturn -ENODEV;\r\n}\r\nstatic int mxl111sf_adap_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nstruct mxl111sf_adap_state *adap_state = adap->fe_adap[fe->id].priv;\r\nint err;\r\nif (!state->chip_id) {\r\nmxl_debug("driver not yet initialized, exit.");\r\ngoto fail;\r\n}\r\ndeb_info("%s()\n", __func__);\r\nerr = (adap_state->fe_sleep) ? adap_state->fe_sleep(fe) : 0;\r\nmutex_unlock(&state->fe_lock);\r\nreturn err;\r\nfail:\r\nreturn -ENODEV;\r\n}\r\nstatic int mxl111sf_ep6_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nstruct mxl111sf_adap_state *adap_state = adap->fe_adap[adap->active_fe].priv;\r\nint ret = 0;\r\ndeb_info("%s(%d)\n", __func__, onoff);\r\nif (onoff) {\r\nret = mxl111sf_enable_usb_output(state);\r\nmxl_fail(ret);\r\nret = mxl111sf_config_mpeg_in(state, 1, 1,\r\nadap_state->ep6_clockphase,\r\n0, 0);\r\nmxl_fail(ret);\r\n#if 0\r\n} else {\r\nret = mxl111sf_disable_656_port(state);\r\nmxl_fail(ret);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_ep5_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint ret = 0;\r\ndeb_info("%s(%d)\n", __func__, onoff);\r\nif (onoff) {\r\nret = mxl111sf_enable_usb_output(state);\r\nmxl_fail(ret);\r\nret = mxl111sf_init_i2s_port(state, 200);\r\nmxl_fail(ret);\r\nret = mxl111sf_config_i2s(state, 0, 15);\r\nmxl_fail(ret);\r\n} else {\r\nret = mxl111sf_disable_i2s_port(state);\r\nmxl_fail(ret);\r\n}\r\nif (state->chip_rev > MXL111SF_V6)\r\nret = mxl111sf_config_spi(state, onoff);\r\nmxl_fail(ret);\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_ep4_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint ret = 0;\r\ndeb_info("%s(%d)\n", __func__, onoff);\r\nif (onoff) {\r\nret = mxl111sf_enable_usb_output(state);\r\nmxl_fail(ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_lgdt3305_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint fe_id = adap->num_frontends_initialized;\r\nstruct mxl111sf_adap_state *adap_state = adap->fe_adap[fe_id].priv;\r\nint ret;\r\ndeb_adv("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(adap->dev->udev, 0, state->alt_mode) < 0)\r\nerr("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_ATSC;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_TUNER_MODE;\r\nadap_state->ep6_clockphase = 1;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_port_expander(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nadap->fe_adap[fe_id].fe = dvb_attach(lgdt3305_attach,\r\n&hauppauge_lgdt3305_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe_adap[fe_id].fe) {\r\nadap_state->fe_init = adap->fe_adap[fe_id].fe->ops.init;\r\nadap->fe_adap[fe_id].fe->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe_adap[fe_id].fe->ops.sleep;\r\nadap->fe_adap[fe_id].fe->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_lg2160_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint fe_id = adap->num_frontends_initialized;\r\nstruct mxl111sf_adap_state *adap_state = adap->fe_adap[fe_id].priv;\r\nint ret;\r\ndeb_adv("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(adap->dev->udev, 0, state->alt_mode) < 0)\r\nerr("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_TUNER_MODE;\r\nadap_state->ep6_clockphase = 1;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_port_expander(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = get_chip_info(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nadap->fe_adap[fe_id].fe = dvb_attach(lg2160_attach,\r\n&hauppauge_lg2160_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe_adap[fe_id].fe) {\r\nadap_state->fe_init = adap->fe_adap[fe_id].fe->ops.init;\r\nadap->fe_adap[fe_id].fe->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe_adap[fe_id].fe->ops.sleep;\r\nadap->fe_adap[fe_id].fe->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_lg2161_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint fe_id = adap->num_frontends_initialized;\r\nstruct mxl111sf_adap_state *adap_state = adap->fe_adap[fe_id].priv;\r\nint ret;\r\ndeb_adv("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(adap->dev->udev, 0, state->alt_mode) < 0)\r\nerr("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_TUNER_MODE;\r\nadap_state->ep6_clockphase = 1;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_port_expander(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = get_chip_info(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nadap->fe_adap[fe_id].fe = dvb_attach(lg2160_attach,\r\n(MXL111SF_V8_200 == state->chip_rev) ?\r\n&hauppauge_lg2161_1040_config :\r\n&hauppauge_lg2161_1019_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe_adap[fe_id].fe) {\r\nadap_state->fe_init = adap->fe_adap[fe_id].fe->ops.init;\r\nadap->fe_adap[fe_id].fe->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe_adap[fe_id].fe->ops.sleep;\r\nadap->fe_adap[fe_id].fe->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_lg2161_ep6_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint fe_id = adap->num_frontends_initialized;\r\nstruct mxl111sf_adap_state *adap_state = adap->fe_adap[fe_id].priv;\r\nint ret;\r\ndeb_adv("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(adap->dev->udev, 0, state->alt_mode) < 0)\r\nerr("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_TUNER_MODE;\r\nadap_state->ep6_clockphase = 0;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_port_expander(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = get_chip_info(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nadap->fe_adap[fe_id].fe = dvb_attach(lg2160_attach,\r\n(MXL111SF_V8_200 == state->chip_rev) ?\r\n&hauppauge_lg2161_1040_ep6_config :\r\n&hauppauge_lg2161_1019_ep6_config,\r\n&adap->dev->i2c_adap);\r\nif (adap->fe_adap[fe_id].fe) {\r\nadap_state->fe_init = adap->fe_adap[fe_id].fe->ops.init;\r\nadap->fe_adap[fe_id].fe->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe_adap[fe_id].fe->ops.sleep;\r\nadap->fe_adap[fe_id].fe->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_attach_demod(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint fe_id = adap->num_frontends_initialized;\r\nstruct mxl111sf_adap_state *adap_state = adap->fe_adap[fe_id].priv;\r\nint ret;\r\ndeb_adv("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 1 : 2;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(adap->dev->udev, 0, state->alt_mode) < 0)\r\nerr("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_DVBT;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_SOC_MODE;\r\nadap_state->ep6_clockphase = 1;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nmxl111sf_init_port_expander(state);\r\nadap->fe_adap[fe_id].fe = dvb_attach(mxl111sf_demod_attach, state,\r\n&mxl_demod_config);\r\nif (adap->fe_adap[fe_id].fe) {\r\nadap_state->fe_init = adap->fe_adap[fe_id].fe->ops.init;\r\nadap->fe_adap[fe_id].fe->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe_adap[fe_id].fe->ops.sleep;\r\nadap->fe_adap[fe_id].fe->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic inline int mxl111sf_set_ant_path(struct mxl111sf_state *state,\r\nint antpath)\r\n{\r\nreturn mxl111sf_idac_config(state, 1, 1,\r\n(antpath == ANT_PATH_INTERNAL) ?\r\n0x3f : 0x00, 0);\r\n}\r\nstatic int mxl111sf_ant_hunt(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint antctrl = dvb_usb_mxl111sf_rfswitch;\r\nu16 rxPwrA, rxPwr0, rxPwr1, rxPwr2;\r\nmxl111sf_set_ant_path(state, antctrl == ANT_PATH_AUTO ?\r\nANT_PATH_EXTERNAL : antctrl);\r\nif (antctrl == ANT_PATH_AUTO) {\r\n#if 0\r\nmsleep(ANT_HUNT_SLEEP);\r\n#endif\r\nfe->ops.tuner_ops.get_rf_strength(fe, &rxPwrA);\r\nmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\r\nmsleep(ANT_HUNT_SLEEP);\r\nfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr0);\r\nmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\r\nmsleep(ANT_HUNT_SLEEP);\r\nfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr1);\r\nmxl111sf_set_ant_path(state, ANT_PATH_INTERNAL);\r\nmsleep(ANT_HUNT_SLEEP);\r\nfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr2);\r\nif (rxPwr1+ANT_EXT_TWEAK >= rxPwr2) {\r\nmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\r\nDbgAntHunt(ANT_PATH_EXTERNAL, rxPwrA,\r\nrxPwr0, rxPwr1, rxPwr2);\r\n} else {\r\nDbgAntHunt(ANT_PATH_INTERNAL, rxPwrA,\r\nrxPwr0, rxPwr1, rxPwr2);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_attach_tuner(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct mxl111sf_state *state = d->priv;\r\nint fe_id = adap->num_frontends_initialized;\r\ndeb_adv("%s()\n", __func__);\r\nif (NULL != dvb_attach(mxl111sf_tuner_attach,\r\nadap->fe_adap[fe_id].fe, state,\r\n&mxl_tuner_config))\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int mxl111sf_fe_ioctl_override(struct dvb_frontend *fe,\r\nunsigned int cmd, void *parg,\r\nunsigned int stage)\r\n{\r\nint err = 0;\r\nswitch (stage) {\r\ncase DVB_FE_IOCTL_PRE:\r\nswitch (cmd) {\r\ncase FE_READ_SIGNAL_STRENGTH:\r\nerr = fe->ops.tuner_ops.get_rf_strength(fe, parg);\r\nif (0 == err)\r\nerr = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase DVB_FE_IOCTL_POST:\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic u32 mxl111sf_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int mxl111sf_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct dvb_usb_device *d = NULL;\r\ndeb_adv("%s()\n", __func__);\r\nif (((dvb_usb_mxl111sf_isoc) &&\r\n(0 == dvb_usb_device_init(intf,\r\n&mxl111sf_dvbt_isoc_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_atsc_isoc_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_atsc_mh_isoc_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mh_isoc_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n((dvb_usb_mxl111sf_spi) &&\r\n(0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mercury_spi_isoc_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mercury_mh_spi_isoc_properties,\r\nTHIS_MODULE, &d, adapter_nr))) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mercury_tp_isoc_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mercury_mh_tp_isoc_properties,\r\nTHIS_MODULE, &d, adapter_nr))) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_dvbt_bulk_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_atsc_bulk_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_atsc_mh_bulk_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mh_bulk_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n((dvb_usb_mxl111sf_spi) &&\r\n(0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mercury_spi_bulk_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mercury_mh_spi_bulk_properties,\r\nTHIS_MODULE, &d, adapter_nr))) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mercury_tp_bulk_properties,\r\nTHIS_MODULE, &d, adapter_nr) ||\r\n0 == dvb_usb_device_init(intf,\r\n&mxl111sf_mercury_mh_tp_bulk_properties,\r\nTHIS_MODULE, &d, adapter_nr) || 0) {\r\nstruct mxl111sf_state *state = d->priv;\r\nstatic u8 eeprom[256];\r\nstruct i2c_client c;\r\nint ret;\r\nret = get_chip_info(state);\r\nif (mxl_fail(ret))\r\nerr("failed to get chip info during probe");\r\nmutex_init(&state->fe_lock);\r\nif (state->chip_rev > MXL111SF_V6)\r\nmxl111sf_config_pin_mux_modes(state,\r\nPIN_MUX_TS_SPI_IN_MODE_1);\r\nc.adapter = &d->i2c_adap;\r\nc.addr = 0xa0 >> 1;\r\nret = tveeprom_read(&c, eeprom, sizeof(eeprom));\r\nif (mxl_fail(ret))\r\nreturn 0;\r\ntveeprom_hauppauge_analog(&c, &state->tv,\r\n(0x84 == eeprom[0xa0]) ?\r\neeprom + 0xa0 : eeprom + 0x80);\r\n#if 0\r\nswitch (state->tv.model) {\r\ncase 117001:\r\ncase 126001:\r\ncase 138001:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: warning: "\r\n"unknown hauppauge model #%d\n",\r\n__func__, state->tv.model);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nerr("Your device is not yet supported by this driver. "\r\n"See kernellabs.com for more info");\r\nreturn -EINVAL;\r\n}
