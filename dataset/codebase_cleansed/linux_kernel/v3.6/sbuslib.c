void sbusfb_fill_var(struct fb_var_screeninfo *var, struct device_node *dp,\r\nint bpp)\r\n{\r\nmemset(var, 0, sizeof(*var));\r\nvar->xres = of_getintprop_default(dp, "width", 1152);\r\nvar->yres = of_getintprop_default(dp, "height", 900);\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nvar->bits_per_pixel = bpp;\r\n}\r\nstatic unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)\r\n{\r\nif (size == SBUS_MMAP_EMPTY) return 0;\r\nif (size >= 0) return size;\r\nreturn fbsize * (-size);\r\n}\r\nint sbusfb_mmap_helper(struct sbus_mmap_map *map,\r\nunsigned long physbase,\r\nunsigned long fbsize,\r\nunsigned long iospace,\r\nstruct vm_area_struct *vma)\r\n{\r\nunsigned int size, page, r, map_size;\r\nunsigned long map_offset = 0;\r\nunsigned long off;\r\nint i;\r\nif (!(vma->vm_flags & (VM_SHARED | VM_MAYSHARE)))\r\nreturn -EINVAL;\r\nsize = vma->vm_end - vma->vm_start;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\r\nreturn -EINVAL;\r\noff = vma->vm_pgoff << PAGE_SHIFT;\r\nvma->vm_flags |= (VM_IO | VM_RESERVED);\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nfor (page = 0; page < size; ){\r\nmap_size = 0;\r\nfor (i = 0; map[i].size; i++)\r\nif (map[i].voff == off+page) {\r\nmap_size = sbusfb_mmapsize(map[i].size, fbsize);\r\n#ifdef __sparc_v9__\r\n#define POFF_MASK (PAGE_MASK|0x1UL)\r\n#else\r\n#define POFF_MASK (PAGE_MASK)\r\n#endif\r\nmap_offset = (physbase + map[i].poff) & POFF_MASK;\r\nbreak;\r\n}\r\nif (!map_size) {\r\npage += PAGE_SIZE;\r\ncontinue;\r\n}\r\nif (page + map_size > size)\r\nmap_size = size - page;\r\nr = io_remap_pfn_range(vma,\r\nvma->vm_start + page,\r\nMK_IOSPACE_PFN(iospace,\r\nmap_offset >> PAGE_SHIFT),\r\nmap_size,\r\nvma->vm_page_prot);\r\nif (r)\r\nreturn -EAGAIN;\r\npage += map_size;\r\n}\r\nreturn 0;\r\n}\r\nint sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\r\nstruct fb_info *info,\r\nint type, int fb_depth, unsigned long fb_size)\r\n{\r\nswitch(cmd) {\r\ncase FBIOGTYPE: {\r\nstruct fbtype __user *f = (struct fbtype __user *) arg;\r\nif (put_user(type, &f->fb_type) ||\r\n__put_user(info->var.yres, &f->fb_height) ||\r\n__put_user(info->var.xres, &f->fb_width) ||\r\n__put_user(fb_depth, &f->fb_depth) ||\r\n__put_user(0, &f->fb_cmsize) ||\r\n__put_user(fb_size, &f->fb_cmsize))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase FBIOPUTCMAP_SPARC: {\r\nstruct fbcmap __user *c = (struct fbcmap __user *) arg;\r\nstruct fb_cmap cmap;\r\nu16 red, green, blue;\r\nu8 red8, green8, blue8;\r\nunsigned char __user *ured;\r\nunsigned char __user *ugreen;\r\nunsigned char __user *ublue;\r\nint index, count, i;\r\nif (get_user(index, &c->index) ||\r\n__get_user(count, &c->count) ||\r\n__get_user(ured, &c->red) ||\r\n__get_user(ugreen, &c->green) ||\r\n__get_user(ublue, &c->blue))\r\nreturn -EFAULT;\r\ncmap.len = 1;\r\ncmap.red = &red;\r\ncmap.green = &green;\r\ncmap.blue = &blue;\r\ncmap.transp = NULL;\r\nfor (i = 0; i < count; i++) {\r\nint err;\r\nif (get_user(red8, &ured[i]) ||\r\nget_user(green8, &ugreen[i]) ||\r\nget_user(blue8, &ublue[i]))\r\nreturn -EFAULT;\r\nred = red8 << 8;\r\ngreen = green8 << 8;\r\nblue = blue8 << 8;\r\ncmap.start = index + i;\r\nerr = fb_set_cmap(&cmap, info);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\ncase FBIOGETCMAP_SPARC: {\r\nstruct fbcmap __user *c = (struct fbcmap __user *) arg;\r\nunsigned char __user *ured;\r\nunsigned char __user *ugreen;\r\nunsigned char __user *ublue;\r\nstruct fb_cmap *cmap = &info->cmap;\r\nint index, count, i;\r\nu8 red, green, blue;\r\nif (get_user(index, &c->index) ||\r\n__get_user(count, &c->count) ||\r\n__get_user(ured, &c->red) ||\r\n__get_user(ugreen, &c->green) ||\r\n__get_user(ublue, &c->blue))\r\nreturn -EFAULT;\r\nif (index + count > cmap->len)\r\nreturn -EINVAL;\r\nfor (i = 0; i < count; i++) {\r\nred = cmap->red[index + i] >> 8;\r\ngreen = cmap->green[index + i] >> 8;\r\nblue = cmap->blue[index + i] >> 8;\r\nif (put_user(red, &ured[i]) ||\r\nput_user(green, &ugreen[i]) ||\r\nput_user(blue, &ublue[i]))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\n}\r\nstatic int fbiogetputcmap(struct fb_info *info, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct fbcmap32 __user *argp = (void __user *)arg;\r\nstruct fbcmap __user *p = compat_alloc_user_space(sizeof(*p));\r\nu32 addr;\r\nint ret;\r\nret = copy_in_user(p, argp, 2 * sizeof(int));\r\nret |= get_user(addr, &argp->red);\r\nret |= put_user(compat_ptr(addr), &p->red);\r\nret |= get_user(addr, &argp->green);\r\nret |= put_user(compat_ptr(addr), &p->green);\r\nret |= get_user(addr, &argp->blue);\r\nret |= put_user(compat_ptr(addr), &p->blue);\r\nif (ret)\r\nreturn -EFAULT;\r\nreturn info->fbops->fb_ioctl(info,\r\n(cmd == FBIOPUTCMAP32) ?\r\nFBIOPUTCMAP_SPARC : FBIOGETCMAP_SPARC,\r\n(unsigned long)p);\r\n}\r\nstatic int fbiogscursor(struct fb_info *info, unsigned long arg)\r\n{\r\nstruct fbcursor __user *p = compat_alloc_user_space(sizeof(*p));\r\nstruct fbcursor32 __user *argp = (void __user *)arg;\r\ncompat_uptr_t addr;\r\nint ret;\r\nret = copy_in_user(p, argp,\r\n2 * sizeof (short) + 2 * sizeof(struct fbcurpos));\r\nret |= copy_in_user(&p->size, &argp->size, sizeof(struct fbcurpos));\r\nret |= copy_in_user(&p->cmap, &argp->cmap, 2 * sizeof(int));\r\nret |= get_user(addr, &argp->cmap.red);\r\nret |= put_user(compat_ptr(addr), &p->cmap.red);\r\nret |= get_user(addr, &argp->cmap.green);\r\nret |= put_user(compat_ptr(addr), &p->cmap.green);\r\nret |= get_user(addr, &argp->cmap.blue);\r\nret |= put_user(compat_ptr(addr), &p->cmap.blue);\r\nret |= get_user(addr, &argp->mask);\r\nret |= put_user(compat_ptr(addr), &p->mask);\r\nret |= get_user(addr, &argp->image);\r\nret |= put_user(compat_ptr(addr), &p->image);\r\nif (ret)\r\nreturn -EFAULT;\r\nreturn info->fbops->fb_ioctl(info, FBIOSCURSOR, (unsigned long)p);\r\n}\r\nint sbusfb_compat_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase FBIOGTYPE:\r\ncase FBIOSATTR:\r\ncase FBIOGATTR:\r\ncase FBIOSVIDEO:\r\ncase FBIOGVIDEO:\r\ncase FBIOGCURSOR32:\r\ncase FBIOSCURPOS:\r\ncase FBIOGCURPOS:\r\ncase FBIOGCURMAX:\r\nreturn info->fbops->fb_ioctl(info, cmd, arg);\r\ncase FBIOPUTCMAP32:\r\nreturn fbiogetputcmap(info, cmd, arg);\r\ncase FBIOGETCMAP32:\r\nreturn fbiogetputcmap(info, cmd, arg);\r\ncase FBIOSCURSOR32:\r\nreturn fbiogscursor(info, arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}
