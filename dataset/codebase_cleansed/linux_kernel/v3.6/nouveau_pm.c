static int\r\nnouveau_pwmfan_get(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct gpio_func gpio;\r\nu32 divs, duty;\r\nint ret;\r\nif (!pm->pwm_get)\r\nreturn -ENODEV;\r\nret = nouveau_gpio_find(dev, 0, DCB_GPIO_PWM_FAN, 0xff, &gpio);\r\nif (ret == 0) {\r\nret = pm->pwm_get(dev, gpio.line, &divs, &duty);\r\nif (ret == 0 && divs) {\r\ndivs = max(divs, duty);\r\nif (dev_priv->card_type <= NV_40 || (gpio.log[0] & 1))\r\nduty = divs - duty;\r\nreturn (duty * 100) / divs;\r\n}\r\nreturn nouveau_gpio_func_get(dev, gpio.func) * 100;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nnouveau_pwmfan_set(struct drm_device *dev, int percent)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct gpio_func gpio;\r\nu32 divs, duty;\r\nint ret;\r\nif (!pm->pwm_set)\r\nreturn -ENODEV;\r\nret = nouveau_gpio_find(dev, 0, DCB_GPIO_PWM_FAN, 0xff, &gpio);\r\nif (ret == 0) {\r\ndivs = pm->fan.pwm_divisor;\r\nif (pm->fan.pwm_freq) {\r\ndivs = 135000 / pm->fan.pwm_freq;\r\nif (dev_priv->chipset < 0xa3)\r\ndivs /= 4;\r\n}\r\nduty = ((divs * percent) + 99) / 100;\r\nif (dev_priv->card_type <= NV_40 || (gpio.log[0] & 1))\r\nduty = divs - duty;\r\nret = pm->pwm_set(dev, gpio.line, divs, duty);\r\nif (!ret)\r\npm->fan.percent = percent;\r\nreturn ret;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nnouveau_pm_perflvl_aux(struct drm_device *dev, struct nouveau_pm_level *perflvl,\r\nstruct nouveau_pm_level *a, struct nouveau_pm_level *b)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nint ret;\r\nif (a->fanspeed && b->fanspeed && b->fanspeed > a->fanspeed) {\r\nret = nouveau_pwmfan_set(dev, perflvl->fanspeed);\r\nif (ret && ret != -ENODEV) {\r\nNV_ERROR(dev, "fanspeed set failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (pm->voltage.supported && pm->voltage_set) {\r\nif (perflvl->volt_min && b->volt_min > a->volt_min) {\r\nret = pm->voltage_set(dev, perflvl->volt_min);\r\nif (ret) {\r\nNV_ERROR(dev, "voltage set failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_pm_perflvl_set(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nvoid *state;\r\nint ret;\r\nif (perflvl == pm->cur)\r\nreturn 0;\r\nret = nouveau_pm_perflvl_aux(dev, perflvl, pm->cur, perflvl);\r\nif (ret)\r\nreturn ret;\r\nstate = pm->clocks_pre(dev, perflvl);\r\nif (IS_ERR(state)) {\r\nret = PTR_ERR(state);\r\ngoto error;\r\n}\r\nret = pm->clocks_set(dev, state);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_pm_perflvl_aux(dev, perflvl, perflvl, pm->cur);\r\nif (ret)\r\nreturn ret;\r\npm->cur = perflvl;\r\nreturn 0;\r\nerror:\r\nnouveau_pm_perflvl_aux(dev, perflvl, perflvl, pm->cur);\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_pm_trigger(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_profile *profile = NULL;\r\nstruct nouveau_pm_level *perflvl = NULL;\r\nint ret;\r\nif (power_supply_is_system_supplied())\r\nprofile = pm->profile_ac;\r\nelse\r\nprofile = pm->profile_dc;\r\nif (profile != pm->profile) {\r\npm->profile->func->fini(pm->profile);\r\npm->profile = profile;\r\npm->profile->func->init(pm->profile);\r\n}\r\nperflvl = profile->func->select(profile);\r\nif (perflvl != pm->cur) {\r\nstruct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;\r\nu64 time0 = ptimer->read(dev);\r\nNV_INFO(dev, "setting performance level: %d", perflvl->id);\r\nret = nouveau_pm_perflvl_set(dev, perflvl);\r\nif (ret)\r\nNV_INFO(dev, "> reclocking failed: %d\n\n", ret);\r\nNV_INFO(dev, "> reclocking took %lluns\n\n",\r\nptimer->read(dev) - time0);\r\n}\r\n}\r\nstatic struct nouveau_pm_profile *\r\nprofile_find(struct drm_device *dev, const char *string)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_profile *profile;\r\nlist_for_each_entry(profile, &pm->profiles, head) {\r\nif (!strncmp(profile->name, string, sizeof(profile->name)))\r\nreturn profile;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nnouveau_pm_profile_set(struct drm_device *dev, const char *profile)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_profile *ac = NULL, *dc = NULL;\r\nchar string[16], *cur = string, *ptr;\r\nif (nouveau_perflvl_wr != 7777)\r\nreturn -EPERM;\r\nstrncpy(string, profile, sizeof(string));\r\nstring[sizeof(string) - 1] = 0;\r\nif ((ptr = strchr(string, '\n')))\r\n*ptr = '\0';\r\nptr = strsep(&cur, ",");\r\nif (ptr)\r\nac = profile_find(dev, ptr);\r\nptr = strsep(&cur, ",");\r\nif (ptr)\r\ndc = profile_find(dev, ptr);\r\nelse\r\ndc = ac;\r\nif (ac == NULL || dc == NULL)\r\nreturn -EINVAL;\r\npm->profile_ac = ac;\r\npm->profile_dc = dc;\r\nnouveau_pm_trigger(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_pm_static_dummy(struct nouveau_pm_profile *profile)\r\n{\r\n}\r\nstatic struct nouveau_pm_level *\r\nnouveau_pm_static_select(struct nouveau_pm_profile *profile)\r\n{\r\nreturn container_of(profile, struct nouveau_pm_level, profile);\r\n}\r\nstatic int\r\nnouveau_pm_perflvl_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nint ret;\r\nmemset(perflvl, 0, sizeof(*perflvl));\r\nif (pm->clocks_get) {\r\nret = pm->clocks_get(dev, perflvl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pm->voltage.supported && pm->voltage_get) {\r\nret = pm->voltage_get(dev);\r\nif (ret > 0) {\r\nperflvl->volt_min = ret;\r\nperflvl->volt_max = ret;\r\n}\r\n}\r\nret = nouveau_pwmfan_get(dev);\r\nif (ret > 0)\r\nperflvl->fanspeed = ret;\r\nnouveau_mem_timing_read(dev, &perflvl->timing);\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_pm_perflvl_info(struct nouveau_pm_level *perflvl, char *ptr, int len)\r\n{\r\nchar c[16], s[16], v[32], f[16], m[16];\r\nc[0] = '\0';\r\nif (perflvl->core)\r\nsnprintf(c, sizeof(c), " core %dMHz", perflvl->core / 1000);\r\ns[0] = '\0';\r\nif (perflvl->shader)\r\nsnprintf(s, sizeof(s), " shader %dMHz", perflvl->shader / 1000);\r\nm[0] = '\0';\r\nif (perflvl->memory)\r\nsnprintf(m, sizeof(m), " memory %dMHz", perflvl->memory / 1000);\r\nv[0] = '\0';\r\nif (perflvl->volt_min && perflvl->volt_min != perflvl->volt_max) {\r\nsnprintf(v, sizeof(v), " voltage %dmV-%dmV",\r\nperflvl->volt_min / 1000, perflvl->volt_max / 1000);\r\n} else\r\nif (perflvl->volt_min) {\r\nsnprintf(v, sizeof(v), " voltage %dmV",\r\nperflvl->volt_min / 1000);\r\n}\r\nf[0] = '\0';\r\nif (perflvl->fanspeed)\r\nsnprintf(f, sizeof(f), " fanspeed %d%%", perflvl->fanspeed);\r\nsnprintf(ptr, len, "%s%s%s%s%s\n", c, s, m, v, f);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_get_perflvl_info(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct nouveau_pm_level *perflvl =\r\ncontainer_of(a, struct nouveau_pm_level, dev_attr);\r\nchar *ptr = buf;\r\nint len = PAGE_SIZE;\r\nsnprintf(ptr, len, "%d:", perflvl->id);\r\nptr += strlen(buf);\r\nlen -= strlen(buf);\r\nnouveau_pm_perflvl_info(perflvl, ptr, len);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_get_perflvl(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(to_pci_dev(d));\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_level cur;\r\nint len = PAGE_SIZE, ret;\r\nchar *ptr = buf;\r\nsnprintf(ptr, len, "profile: %s, %s\nc:",\r\npm->profile_ac->name, pm->profile_dc->name);\r\nptr += strlen(buf);\r\nlen -= strlen(buf);\r\nret = nouveau_pm_perflvl_get(dev, &cur);\r\nif (ret == 0)\r\nnouveau_pm_perflvl_info(&cur, ptr, len);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nnouveau_pm_set_perflvl(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(to_pci_dev(d));\r\nint ret;\r\nret = nouveau_pm_profile_set(dev, buf);\r\nif (ret)\r\nreturn ret;\r\nreturn strlen(buf);\r\n}\r\nstatic int\r\nnouveau_sysfs_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct device *d = &dev->pdev->dev;\r\nint ret, i;\r\nret = device_create_file(d, &dev_attr_performance_level);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nstruct nouveau_pm_level *perflvl = &pm->perflvl[i];\r\nperflvl->dev_attr.attr.name = perflvl->name;\r\nperflvl->dev_attr.attr.mode = S_IRUGO;\r\nperflvl->dev_attr.show = nouveau_pm_get_perflvl_info;\r\nperflvl->dev_attr.store = NULL;\r\nsysfs_attr_init(&perflvl->dev_attr.attr);\r\nret = device_create_file(d, &perflvl->dev_attr);\r\nif (ret) {\r\nNV_ERROR(dev, "failed pervlvl %d sysfs: %d\n",\r\nperflvl->id, i);\r\nperflvl->dev_attr.attr.name = NULL;\r\nnouveau_pm_fini(dev);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_sysfs_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct device *d = &dev->pdev->dev;\r\nint i;\r\ndevice_remove_file(d, &dev_attr_performance_level);\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nstruct nouveau_pm_level *pl = &pm->perflvl[i];\r\nif (!pl->dev_attr.attr.name)\r\nbreak;\r\ndevice_remove_file(d, &pl->dev_attr);\r\n}\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_show_temp(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", pm->temp_get(dev)*1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_max_temp(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temp = &pm->threshold_temp;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp->down_clock*1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_max_temp(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temp = &pm->threshold_temp;\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntemp->down_clock = value/1000;\r\nnouveau_temp_safety_checks(dev);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_critical_temp(struct device *d, struct device_attribute *a,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temp = &pm->threshold_temp;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp->critical*1000);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_critical_temp(struct device *d, struct device_attribute *a,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temp = &pm->threshold_temp;\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn count;\r\ntemp->critical = value/1000;\r\nnouveau_temp_safety_checks(dev);\r\nreturn count;\r\n}\r\nstatic ssize_t nouveau_hwmon_show_name(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "nouveau\n");\r\n}\r\nstatic ssize_t nouveau_hwmon_show_update_rate(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "1000\n");\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_show_fan0_input(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;\r\nstruct gpio_func gpio;\r\nu32 cycles, cur, prev;\r\nu64 start;\r\nint ret;\r\nret = nouveau_gpio_find(dev, 0, DCB_GPIO_FAN_SENSE, 0xff, &gpio);\r\nif (ret)\r\nreturn ret;\r\nstart = ptimer->read(dev);\r\nprev = nouveau_gpio_sense(dev, 0, gpio.line);\r\ncycles = 0;\r\ndo {\r\ncur = nouveau_gpio_sense(dev, 0, gpio.line);\r\nif (prev != cur) {\r\ncycles++;\r\nprev = cur;\r\n}\r\nusleep_range(500, 1000);\r\n} while (ptimer->read(dev) - start < 250000000);\r\nreturn sprintf(buf, "%i\n", cycles / 4 * 4 * 60);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_get_pwm0(struct device *d, struct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nint ret;\r\nret = nouveau_pwmfan_get(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_pwm0(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nint ret = -ENODEV;\r\nlong value;\r\nif (nouveau_perflvl_wr != 7777)\r\nreturn -EPERM;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn -EINVAL;\r\nif (value < pm->fan.min_duty)\r\nvalue = pm->fan.min_duty;\r\nif (value > pm->fan.max_duty)\r\nvalue = pm->fan.max_duty;\r\nret = nouveau_pwmfan_set(dev, value);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_get_pwm0_min(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nreturn sprintf(buf, "%i\n", pm->fan.min_duty);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_pwm0_min(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn -EINVAL;\r\nif (value < 0)\r\nvalue = 0;\r\nif (pm->fan.max_duty - value < 10)\r\nvalue = pm->fan.max_duty - 10;\r\nif (value < 10)\r\npm->fan.min_duty = 10;\r\nelse\r\npm->fan.min_duty = value;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_get_pwm0_max(struct device *d,\r\nstruct device_attribute *a, char *buf)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nreturn sprintf(buf, "%i\n", pm->fan.max_duty);\r\n}\r\nstatic ssize_t\r\nnouveau_hwmon_set_pwm0_max(struct device *d, struct device_attribute *a,\r\nconst char *buf, size_t count)\r\n{\r\nstruct drm_device *dev = dev_get_drvdata(d);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nlong value;\r\nif (kstrtol(buf, 10, &value) == -EINVAL)\r\nreturn -EINVAL;\r\nif (value < 0)\r\nvalue = 0;\r\nif (value - pm->fan.min_duty < 10)\r\nvalue = pm->fan.min_duty + 10;\r\nif (value > 100)\r\npm->fan.max_duty = 100;\r\nelse\r\npm->fan.max_duty = value;\r\nreturn count;\r\n}\r\nstatic int\r\nnouveau_hwmon_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\n#if defined(CONFIG_HWMON) || (defined(MODULE) && defined(CONFIG_HWMON_MODULE))\r\nstruct device *hwmon_dev;\r\nint ret = 0;\r\nif (!pm->temp_get)\r\nreturn -ENODEV;\r\nhwmon_dev = hwmon_device_register(&dev->pdev->dev);\r\nif (IS_ERR(hwmon_dev)) {\r\nret = PTR_ERR(hwmon_dev);\r\nNV_ERROR(dev,\r\n"Unable to register hwmon device: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(hwmon_dev, dev);\r\nret = sysfs_create_group(&dev->pdev->dev.kobj, &hwmon_attrgroup);\r\nif (ret) {\r\nif (ret)\r\ngoto error;\r\n}\r\nif (nouveau_pwmfan_get(dev) >= 0) {\r\nret = sysfs_create_group(&dev->pdev->dev.kobj,\r\n&hwmon_pwm_fan_attrgroup);\r\nif (ret)\r\ngoto error;\r\n}\r\nif (nouveau_gpio_func_valid(dev, DCB_GPIO_FAN_SENSE)) {\r\nret = sysfs_create_group(&dev->pdev->dev.kobj,\r\n&hwmon_fan_rpm_attrgroup);\r\nif (ret)\r\ngoto error;\r\n}\r\npm->hwmon = hwmon_dev;\r\nreturn 0;\r\nerror:\r\nNV_ERROR(dev, "Unable to create some hwmon sysfs files: %d\n", ret);\r\nhwmon_device_unregister(hwmon_dev);\r\npm->hwmon = NULL;\r\nreturn ret;\r\n#else\r\npm->hwmon = NULL;\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void\r\nnouveau_hwmon_fini(struct drm_device *dev)\r\n{\r\n#if defined(CONFIG_HWMON) || (defined(MODULE) && defined(CONFIG_HWMON_MODULE))\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nif (pm->hwmon) {\r\nsysfs_remove_group(&dev->pdev->dev.kobj, &hwmon_attrgroup);\r\nsysfs_remove_group(&dev->pdev->dev.kobj,\r\n&hwmon_pwm_fan_attrgroup);\r\nsysfs_remove_group(&dev->pdev->dev.kobj,\r\n&hwmon_fan_rpm_attrgroup);\r\nhwmon_device_unregister(pm->hwmon);\r\n}\r\n#endif\r\n}\r\nstatic int\r\nnouveau_pm_acpi_event(struct notifier_block *nb, unsigned long val, void *data)\r\n{\r\nstruct drm_nouveau_private *dev_priv =\r\ncontainer_of(nb, struct drm_nouveau_private, engine.pm.acpi_nb);\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct acpi_bus_event *entry = (struct acpi_bus_event *)data;\r\nif (strcmp(entry->device_class, "ac_adapter") == 0) {\r\nbool ac = power_supply_is_system_supplied();\r\nNV_DEBUG(dev, "power supply changed: %s\n", ac ? "AC" : "DC");\r\nnouveau_pm_trigger(dev);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nint\r\nnouveau_pm_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nchar info[256];\r\nint ret, i;\r\nnouveau_volt_init(dev);\r\nnouveau_temp_init(dev);\r\nret = nouveau_pm_perflvl_get(dev, &pm->boot);\r\nif (ret) {\r\nNV_ERROR(dev, "failed to determine boot perflvl\n");\r\nreturn ret;\r\n}\r\nstrncpy(pm->boot.name, "boot", 4);\r\nstrncpy(pm->boot.profile.name, "boot", 4);\r\npm->boot.profile.func = &nouveau_pm_static_profile_func;\r\nINIT_LIST_HEAD(&pm->profiles);\r\nlist_add(&pm->boot.profile.head, &pm->profiles);\r\npm->profile_ac = &pm->boot.profile;\r\npm->profile_dc = &pm->boot.profile;\r\npm->profile = &pm->boot.profile;\r\npm->cur = &pm->boot;\r\nnouveau_perf_init(dev);\r\nNV_INFO(dev, "%d available performance level(s)\n", pm->nr_perflvl);\r\nfor (i = 0; i < pm->nr_perflvl; i++) {\r\nnouveau_pm_perflvl_info(&pm->perflvl[i], info, sizeof(info));\r\nNV_INFO(dev, "%d:%s", pm->perflvl[i].id, info);\r\n}\r\nnouveau_pm_perflvl_info(&pm->boot, info, sizeof(info));\r\nNV_INFO(dev, "c:%s", info);\r\nif (nouveau_perflvl != NULL)\r\nnouveau_pm_profile_set(dev, nouveau_perflvl);\r\npm->fan.percent = nouveau_pwmfan_get(dev);\r\nnouveau_sysfs_init(dev);\r\nnouveau_hwmon_init(dev);\r\n#if defined(CONFIG_ACPI) && defined(CONFIG_POWER_SUPPLY)\r\npm->acpi_nb.notifier_call = nouveau_pm_acpi_event;\r\nregister_acpi_notifier(&pm->acpi_nb);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_pm_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_profile *profile, *tmp;\r\nlist_for_each_entry_safe(profile, tmp, &pm->profiles, head) {\r\nlist_del(&profile->head);\r\nprofile->func->destroy(profile);\r\n}\r\nif (pm->cur != &pm->boot)\r\nnouveau_pm_perflvl_set(dev, &pm->boot);\r\nnouveau_temp_fini(dev);\r\nnouveau_perf_fini(dev);\r\nnouveau_volt_fini(dev);\r\n#if defined(CONFIG_ACPI) && defined(CONFIG_POWER_SUPPLY)\r\nunregister_acpi_notifier(&pm->acpi_nb);\r\n#endif\r\nnouveau_hwmon_fini(dev);\r\nnouveau_sysfs_fini(dev);\r\n}\r\nvoid\r\nnouveau_pm_resume(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_level *perflvl;\r\nif (!pm->cur || pm->cur == &pm->boot)\r\nreturn;\r\nperflvl = pm->cur;\r\npm->cur = &pm->boot;\r\nnouveau_pm_perflvl_set(dev, perflvl);\r\nnouveau_pwmfan_set(dev, pm->fan.percent);\r\n}
