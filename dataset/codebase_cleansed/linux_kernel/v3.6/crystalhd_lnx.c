static irqreturn_t chd_dec_isr(int irq, void *arg)\r\n{\r\nstruct crystalhd_adp *adp = (struct crystalhd_adp *) arg;\r\nint rc = 0;\r\nif (adp)\r\nrc = crystalhd_cmd_interrupt(&adp->cmds);\r\nreturn IRQ_RETVAL(rc);\r\n}\r\nstatic int chd_dec_enable_int(struct crystalhd_adp *adp)\r\n{\r\nint rc = 0;\r\nif (!adp || !adp->pdev) {\r\nBCMLOG_ERR("Invalid arg!!\n");\r\nreturn -EINVAL;\r\n}\r\nif (adp->pdev->msi_enabled)\r\nadp->msi = 1;\r\nelse\r\nadp->msi = pci_enable_msi(adp->pdev);\r\nrc = request_irq(adp->pdev->irq, chd_dec_isr, IRQF_SHARED,\r\nadp->name, (void *)adp);\r\nif (rc) {\r\nBCMLOG_ERR("Interrupt request failed..\n");\r\npci_disable_msi(adp->pdev);\r\n}\r\nreturn rc;\r\n}\r\nstatic int chd_dec_disable_int(struct crystalhd_adp *adp)\r\n{\r\nif (!adp || !adp->pdev) {\r\nBCMLOG_ERR("Invalid arg!!\n");\r\nreturn -EINVAL;\r\n}\r\nfree_irq(adp->pdev->irq, adp);\r\nif (adp->msi)\r\npci_disable_msi(adp->pdev);\r\nreturn 0;\r\n}\r\nstruct crystalhd_ioctl_data *chd_dec_alloc_iodata(struct crystalhd_adp *adp, bool isr)\r\n{\r\nunsigned long flags = 0;\r\nstruct crystalhd_ioctl_data *temp;\r\nif (!adp)\r\nreturn NULL;\r\nspin_lock_irqsave(&adp->lock, flags);\r\ntemp = adp->idata_free_head;\r\nif (temp) {\r\nadp->idata_free_head = adp->idata_free_head->next;\r\nmemset(temp, 0, sizeof(*temp));\r\n}\r\nspin_unlock_irqrestore(&adp->lock, flags);\r\nreturn temp;\r\n}\r\nvoid chd_dec_free_iodata(struct crystalhd_adp *adp, struct crystalhd_ioctl_data *iodata,\r\nbool isr)\r\n{\r\nunsigned long flags = 0;\r\nif (!adp || !iodata)\r\nreturn;\r\nspin_lock_irqsave(&adp->lock, flags);\r\niodata->next = adp->idata_free_head;\r\nadp->idata_free_head = iodata;\r\nspin_unlock_irqrestore(&adp->lock, flags);\r\n}\r\nstatic inline int crystalhd_user_data(unsigned long ud, void *dr, int size, int set)\r\n{\r\nint rc;\r\nif (!ud || !dr) {\r\nBCMLOG_ERR("Invalid arg\n");\r\nreturn -EINVAL;\r\n}\r\nif (set)\r\nrc = copy_to_user((void *)ud, dr, size);\r\nelse\r\nrc = copy_from_user(dr, (void *)ud, size);\r\nif (rc) {\r\nBCMLOG_ERR("Invalid args for command\n");\r\nrc = -EFAULT;\r\n}\r\nreturn rc;\r\n}\r\nstatic int chd_dec_fetch_cdata(struct crystalhd_adp *adp, struct crystalhd_ioctl_data *io,\r\nuint32_t m_sz, unsigned long ua)\r\n{\r\nunsigned long ua_off;\r\nint rc = 0;\r\nif (!adp || !io || !ua || !m_sz) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn -EINVAL;\r\n}\r\nio->add_cdata = vmalloc(m_sz);\r\nif (!io->add_cdata) {\r\nBCMLOG_ERR("kalloc fail for sz:%x\n", m_sz);\r\nreturn -ENOMEM;\r\n}\r\nio->add_cdata_sz = m_sz;\r\nua_off = ua + sizeof(io->udata);\r\nrc = crystalhd_user_data(ua_off, io->add_cdata, io->add_cdata_sz, 0);\r\nif (rc) {\r\nBCMLOG_ERR("failed to pull add_cdata sz:%x ua_off:%x\n",\r\nio->add_cdata_sz, (unsigned int)ua_off);\r\nkfree(io->add_cdata);\r\nio->add_cdata = NULL;\r\nreturn -ENODATA;\r\n}\r\nreturn rc;\r\n}\r\nstatic int chd_dec_release_cdata(struct crystalhd_adp *adp,\r\nstruct crystalhd_ioctl_data *io, unsigned long ua)\r\n{\r\nunsigned long ua_off;\r\nint rc;\r\nif (!adp || !io || !ua) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn -EINVAL;\r\n}\r\nif (io->cmd != BCM_IOC_FW_DOWNLOAD) {\r\nua_off = ua + sizeof(io->udata);\r\nrc = crystalhd_user_data(ua_off, io->add_cdata,\r\nio->add_cdata_sz, 1);\r\nif (rc) {\r\nBCMLOG_ERR("failed to push add_cdata sz:%x ua_off:%x\n",\r\nio->add_cdata_sz, (unsigned int)ua_off);\r\nreturn -ENODATA;\r\n}\r\n}\r\nif (io->add_cdata) {\r\nvfree(io->add_cdata);\r\nio->add_cdata = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int chd_dec_proc_user_data(struct crystalhd_adp *adp,\r\nstruct crystalhd_ioctl_data *io,\r\nunsigned long ua, int set)\r\n{\r\nint rc;\r\nuint32_t m_sz = 0;\r\nif (!adp || !io || !ua) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn -EINVAL;\r\n}\r\nrc = crystalhd_user_data(ua, &io->udata, sizeof(io->udata), set);\r\nif (rc) {\r\nBCMLOG_ERR("failed to %s iodata\n", (set ? "set" : "get"));\r\nreturn rc;\r\n}\r\nswitch (io->cmd) {\r\ncase BCM_IOC_MEM_RD:\r\ncase BCM_IOC_MEM_WR:\r\ncase BCM_IOC_FW_DOWNLOAD:\r\nm_sz = io->udata.u.devMem.NumDwords * 4;\r\nif (set)\r\nrc = chd_dec_release_cdata(adp, io, ua);\r\nelse\r\nrc = chd_dec_fetch_cdata(adp, io, m_sz, ua);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int chd_dec_api_cmd(struct crystalhd_adp *adp, unsigned long ua,\r\nuint32_t uid, uint32_t cmd, crystalhd_cmd_proc func)\r\n{\r\nint rc;\r\nstruct crystalhd_ioctl_data *temp;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\ntemp = chd_dec_alloc_iodata(adp, 0);\r\nif (!temp) {\r\nBCMLOG_ERR("Failed to get iodata..\n");\r\nreturn -EINVAL;\r\n}\r\ntemp->u_id = uid;\r\ntemp->cmd = cmd;\r\nrc = chd_dec_proc_user_data(adp, temp, ua, 0);\r\nif (!rc) {\r\nsts = func(&adp->cmds, temp);\r\nif (sts == BC_STS_PENDING)\r\nsts = BC_STS_NOT_IMPL;\r\ntemp->udata.RetSts = sts;\r\nrc = chd_dec_proc_user_data(adp, temp, ua, 1);\r\n}\r\nif (temp) {\r\nchd_dec_free_iodata(adp, temp, 0);\r\ntemp = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic long chd_dec_ioctl(struct file *fd, unsigned int cmd, unsigned long ua)\r\n{\r\nstruct crystalhd_adp *adp = chd_get_adp();\r\ncrystalhd_cmd_proc cproc;\r\nstruct crystalhd_user *uc;\r\nint ret;\r\nif (!adp || !fd) {\r\nBCMLOG_ERR("Invalid adp\n");\r\nreturn -EINVAL;\r\n}\r\nuc = fd->private_data;\r\nif (!uc) {\r\nBCMLOG_ERR("Failed to get uc\n");\r\nreturn -ENODATA;\r\n}\r\nmutex_lock(&chd_dec_mutex);\r\ncproc = crystalhd_get_cmd_proc(&adp->cmds, cmd, uc);\r\nif (!cproc) {\r\nBCMLOG_ERR("Unhandled command: %d\n", cmd);\r\nmutex_unlock(&chd_dec_mutex);\r\nreturn -EINVAL;\r\n}\r\nret = chd_dec_api_cmd(adp, ua, uc->uid, cmd, cproc);\r\nmutex_unlock(&chd_dec_mutex);\r\nreturn ret;\r\n}\r\nstatic int chd_dec_open(struct inode *in, struct file *fd)\r\n{\r\nstruct crystalhd_adp *adp = chd_get_adp();\r\nint rc = 0;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nstruct crystalhd_user *uc = NULL;\r\nif (!adp) {\r\nBCMLOG_ERR("Invalid adp\n");\r\nreturn -EINVAL;\r\n}\r\nif (adp->cfg_users >= BC_LINK_MAX_OPENS) {\r\nBCMLOG(BCMLOG_INFO, "Already in use.%d\n", adp->cfg_users);\r\nreturn -EBUSY;\r\n}\r\nsts = crystalhd_user_open(&adp->cmds, &uc);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("cmd_user_open - %d\n", sts);\r\nrc = -EBUSY;\r\n}\r\nadp->cfg_users++;\r\nfd->private_data = uc;\r\nreturn rc;\r\n}\r\nstatic int chd_dec_close(struct inode *in, struct file *fd)\r\n{\r\nstruct crystalhd_adp *adp = chd_get_adp();\r\nstruct crystalhd_user *uc;\r\nif (!adp) {\r\nBCMLOG_ERR("Invalid adp\n");\r\nreturn -EINVAL;\r\n}\r\nuc = fd->private_data;\r\nif (!uc) {\r\nBCMLOG_ERR("Failed to get uc\n");\r\nreturn -ENODATA;\r\n}\r\ncrystalhd_user_close(&adp->cmds, uc);\r\nadp->cfg_users--;\r\nreturn 0;\r\n}\r\nstatic int __devinit chd_dec_init_chdev(struct crystalhd_adp *adp)\r\n{\r\nstruct crystalhd_ioctl_data *temp;\r\nstruct device *dev;\r\nint rc = -ENODEV, i = 0;\r\nif (!adp)\r\ngoto fail;\r\nadp->chd_dec_major = register_chrdev(0, CRYSTALHD_API_NAME,\r\n&chd_dec_fops);\r\nif (adp->chd_dec_major < 0) {\r\nBCMLOG_ERR("Failed to create config dev\n");\r\nrc = adp->chd_dec_major;\r\ngoto fail;\r\n}\r\ncrystalhd_class = class_create(THIS_MODULE, "crystalhd");\r\nif (IS_ERR(crystalhd_class)) {\r\nBCMLOG_ERR("failed to create class\n");\r\ngoto fail;\r\n}\r\ndev = device_create(crystalhd_class, NULL, MKDEV(adp->chd_dec_major, 0),\r\nNULL, "crystalhd");\r\nif (IS_ERR(dev)) {\r\nBCMLOG_ERR("failed to create device\n");\r\ngoto device_create_fail;\r\n}\r\nrc = crystalhd_create_elem_pool(adp, BC_LINK_ELEM_POOL_SZ);\r\nif (rc) {\r\nBCMLOG_ERR("failed to create device\n");\r\ngoto elem_pool_fail;\r\n}\r\nfor (i = 0; i < CHD_IODATA_POOL_SZ; i++) {\r\ntemp = kzalloc(sizeof(struct crystalhd_ioctl_data), GFP_KERNEL);\r\nif (!temp) {\r\nBCMLOG_ERR("ioctl data pool kzalloc failed\n");\r\nrc = -ENOMEM;\r\ngoto kzalloc_fail;\r\n}\r\nchd_dec_free_iodata(adp, temp, 0);\r\n}\r\nreturn 0;\r\nkzalloc_fail:\r\ncrystalhd_delete_elem_pool(adp);\r\nelem_pool_fail:\r\ndevice_destroy(crystalhd_class, MKDEV(adp->chd_dec_major, 0));\r\ndevice_create_fail:\r\nclass_destroy(crystalhd_class);\r\nfail:\r\nreturn rc;\r\n}\r\nstatic void __devexit chd_dec_release_chdev(struct crystalhd_adp *adp)\r\n{\r\nstruct crystalhd_ioctl_data *temp = NULL;\r\nif (!adp)\r\nreturn;\r\nif (adp->chd_dec_major > 0) {\r\ndevice_destroy(crystalhd_class, MKDEV(adp->chd_dec_major, 0));\r\nunregister_chrdev(adp->chd_dec_major, CRYSTALHD_API_NAME);\r\nBCMLOG(BCMLOG_INFO, "released api device - %d\n",\r\nadp->chd_dec_major);\r\nclass_destroy(crystalhd_class);\r\n}\r\nadp->chd_dec_major = 0;\r\ndo {\r\ntemp = chd_dec_alloc_iodata(adp, 0);\r\nkfree(temp);\r\n} while (temp);\r\ncrystalhd_delete_elem_pool(adp);\r\n}\r\nstatic int __devinit chd_pci_reserve_mem(struct crystalhd_adp *pinfo)\r\n{\r\nint rc;\r\nunsigned long bar2 = pci_resource_start(pinfo->pdev, 2);\r\nuint32_t mem_len = pci_resource_len(pinfo->pdev, 2);\r\nunsigned long bar0 = pci_resource_start(pinfo->pdev, 0);\r\nuint32_t i2o_len = pci_resource_len(pinfo->pdev, 0);\r\nBCMLOG(BCMLOG_SSTEP, "bar2:0x%lx-0x%08x bar0:0x%lx-0x%08x\n",\r\nbar2, mem_len, bar0, i2o_len);\r\nrc = check_mem_region(bar2, mem_len);\r\nif (rc) {\r\nBCMLOG_ERR("No valid mem region...\n");\r\nreturn -ENOMEM;\r\n}\r\npinfo->addr = ioremap_nocache(bar2, mem_len);\r\nif (!pinfo->addr) {\r\nBCMLOG_ERR("Failed to remap mem region...\n");\r\nreturn -ENOMEM;\r\n}\r\npinfo->pci_mem_start = bar2;\r\npinfo->pci_mem_len = mem_len;\r\nrc = check_mem_region(bar0, i2o_len);\r\nif (rc) {\r\nBCMLOG_ERR("No valid mem region...\n");\r\nreturn -ENOMEM;\r\n}\r\npinfo->i2o_addr = ioremap_nocache(bar0, i2o_len);\r\nif (!pinfo->i2o_addr) {\r\nBCMLOG_ERR("Failed to remap mem region...\n");\r\nreturn -ENOMEM;\r\n}\r\npinfo->pci_i2o_start = bar0;\r\npinfo->pci_i2o_len = i2o_len;\r\nrc = pci_request_regions(pinfo->pdev, pinfo->name);\r\nif (rc < 0) {\r\nBCMLOG_ERR("Region request failed: %d\n", rc);\r\nreturn rc;\r\n}\r\nBCMLOG(BCMLOG_SSTEP, "Mapped addr:0x%08lx i2o_addr:0x%08lx\n",\r\n(unsigned long)pinfo->addr, (unsigned long)pinfo->i2o_addr);\r\nreturn 0;\r\n}\r\nstatic void __devexit chd_pci_release_mem(struct crystalhd_adp *pinfo)\r\n{\r\nif (!pinfo)\r\nreturn;\r\nif (pinfo->addr)\r\niounmap(pinfo->addr);\r\nif (pinfo->i2o_addr)\r\niounmap(pinfo->i2o_addr);\r\npci_release_regions(pinfo->pdev);\r\n}\r\nstatic void __devexit chd_dec_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct crystalhd_adp *pinfo;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\npinfo = pci_get_drvdata(pdev);\r\nif (!pinfo) {\r\nBCMLOG_ERR("could not get adp\n");\r\nreturn;\r\n}\r\nsts = crystalhd_delete_cmd_context(&pinfo->cmds);\r\nif (sts != BC_STS_SUCCESS)\r\nBCMLOG_ERR("cmd delete :%d\n", sts);\r\nchd_dec_release_chdev(pinfo);\r\nchd_dec_disable_int(pinfo);\r\nchd_pci_release_mem(pinfo);\r\npci_disable_device(pinfo->pdev);\r\nkfree(pinfo);\r\ng_adp_info = NULL;\r\n}\r\nstatic int __devinit chd_dec_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *entry)\r\n{\r\nstruct crystalhd_adp *pinfo;\r\nint rc;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nBCMLOG(BCMLOG_DBG, "PCI_INFO: Vendor:0x%04x Device:0x%04x "\r\n"s_vendor:0x%04x s_device: 0x%04x\n",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\npinfo = kzalloc(sizeof(struct crystalhd_adp), GFP_KERNEL);\r\nif (!pinfo) {\r\nBCMLOG_ERR("Failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\npinfo->pdev = pdev;\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\nBCMLOG_ERR("Failed to enable PCI device\n");\r\ngoto err;\r\n}\r\nsnprintf(pinfo->name, sizeof(pinfo->name), "crystalhd_pci_e:%d:%d:%d",\r\npdev->bus->number, PCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn));\r\nrc = chd_pci_reserve_mem(pinfo);\r\nif (rc) {\r\nBCMLOG_ERR("Failed to setup memory regions.\n");\r\npci_disable_device(pdev);\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\npinfo->present = 1;\r\npinfo->drv_data = entry->driver_data;\r\nspin_lock_init(&pinfo->lock);\r\nchd_dec_init_chdev(pinfo);\r\nrc = chd_dec_enable_int(pinfo);\r\nif (rc) {\r\nBCMLOG_ERR("_enable_int err:%d\n", rc);\r\npci_disable_device(pdev);\r\nrc = -ENODEV;\r\ngoto err;\r\n}\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\npci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\npinfo->dmabits = 64;\r\n} else if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\npci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\npinfo->dmabits = 32;\r\n} else {\r\nBCMLOG_ERR("Unabled to setup DMA %d\n", rc);\r\npci_disable_device(pdev);\r\nrc = -ENODEV;\r\ngoto err;\r\n}\r\nsts = crystalhd_setup_cmd_context(&pinfo->cmds, pinfo);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("cmd setup :%d\n", sts);\r\npci_disable_device(pdev);\r\nrc = -ENODEV;\r\ngoto err;\r\n}\r\npci_set_master(pdev);\r\npci_set_drvdata(pdev, pinfo);\r\ng_adp_info = pinfo;\r\nreturn 0;\r\nerr:\r\nkfree(pinfo);\r\nreturn rc;\r\n}\r\nint chd_dec_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct crystalhd_adp *adp;\r\nstruct crystalhd_ioctl_data *temp;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nadp = pci_get_drvdata(pdev);\r\nif (!adp) {\r\nBCMLOG_ERR("could not get adp\n");\r\nreturn -ENODEV;\r\n}\r\ntemp = chd_dec_alloc_iodata(adp, false);\r\nif (!temp) {\r\nBCMLOG_ERR("could not get ioctl data\n");\r\nreturn -ENODEV;\r\n}\r\nsts = crystalhd_suspend(&adp->cmds, temp);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("BCM70012 Suspend %d\n", sts);\r\nreturn -ENODEV;\r\n}\r\nchd_dec_free_iodata(adp, temp, false);\r\nchd_dec_disable_int(adp);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nint chd_dec_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct crystalhd_adp *adp;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nint rc;\r\nadp = pci_get_drvdata(pdev);\r\nif (!adp) {\r\nBCMLOG_ERR("could not get adp\n");\r\nreturn -ENODEV;\r\n}\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nif (pci_enable_device(pdev)) {\r\nBCMLOG_ERR("Failed to enable PCI device\n");\r\nreturn 1;\r\n}\r\npci_set_master(pdev);\r\nrc = chd_dec_enable_int(adp);\r\nif (rc) {\r\nBCMLOG_ERR("_enable_int err:%d\n", rc);\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nsts = crystalhd_resume(&adp->cmds);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("BCM70012 Resume %d\n", sts);\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nvoid chd_set_log_level(struct crystalhd_adp *adp, char *arg)\r\n{\r\nif ((!arg) || (strlen(arg) < 3))\r\ng_linklog_level = BCMLOG_ERROR | BCMLOG_DATA;\r\nelse if (!strncmp(arg, "sstep", 5))\r\ng_linklog_level = BCMLOG_INFO | BCMLOG_DATA | BCMLOG_DBG |\r\nBCMLOG_SSTEP | BCMLOG_ERROR;\r\nelse if (!strncmp(arg, "info", 4))\r\ng_linklog_level = BCMLOG_ERROR | BCMLOG_DATA | BCMLOG_INFO;\r\nelse if (!strncmp(arg, "debug", 5))\r\ng_linklog_level = BCMLOG_ERROR | BCMLOG_DATA | BCMLOG_INFO |\r\nBCMLOG_DBG;\r\nelse if (!strncmp(arg, "pball", 5))\r\ng_linklog_level = 0xFFFFFFFF & ~(BCMLOG_SPINLOCK);\r\nelse if (!strncmp(arg, "silent", 6))\r\ng_linklog_level = 0;\r\nelse\r\ng_linklog_level = 0;\r\n}\r\nstruct crystalhd_adp *chd_get_adp(void)\r\n{\r\nreturn g_adp_info;\r\n}\r\nstatic int __init chd_dec_module_init(void)\r\n{\r\nint rc;\r\nchd_set_log_level(NULL, "debug");\r\nBCMLOG(BCMLOG_DATA, "Loading crystalhd %d.%d.%d\n",\r\ncrystalhd_kmod_major, crystalhd_kmod_minor, crystalhd_kmod_rev);\r\nrc = pci_register_driver(&bc_chd_70012_driver);\r\nif (rc < 0)\r\nBCMLOG_ERR("Could not find any devices. err:%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic void __exit chd_dec_module_cleanup(void)\r\n{\r\nBCMLOG(BCMLOG_DATA, "unloading crystalhd %d.%d.%d\n",\r\ncrystalhd_kmod_major, crystalhd_kmod_minor, crystalhd_kmod_rev);\r\npci_unregister_driver(&bc_chd_70012_driver);\r\n}
