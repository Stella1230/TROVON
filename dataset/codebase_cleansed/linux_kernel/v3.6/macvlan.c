static struct macvlan_dev *macvlan_hash_lookup(const struct macvlan_port *port,\r\nconst unsigned char *addr)\r\n{\r\nstruct macvlan_dev *vlan;\r\nstruct hlist_node *n;\r\nhlist_for_each_entry_rcu(vlan, n, &port->vlan_hash[addr[5]], hlist) {\r\nif (ether_addr_equal_64bits(vlan->dev->dev_addr, addr))\r\nreturn vlan;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void macvlan_hash_add(struct macvlan_dev *vlan)\r\n{\r\nstruct macvlan_port *port = vlan->port;\r\nconst unsigned char *addr = vlan->dev->dev_addr;\r\nhlist_add_head_rcu(&vlan->hlist, &port->vlan_hash[addr[5]]);\r\n}\r\nstatic void macvlan_hash_del(struct macvlan_dev *vlan, bool sync)\r\n{\r\nhlist_del_rcu(&vlan->hlist);\r\nif (sync)\r\nsynchronize_rcu();\r\n}\r\nstatic void macvlan_hash_change_addr(struct macvlan_dev *vlan,\r\nconst unsigned char *addr)\r\n{\r\nmacvlan_hash_del(vlan, true);\r\nmemcpy(vlan->dev->dev_addr, addr, ETH_ALEN);\r\nmacvlan_hash_add(vlan);\r\n}\r\nstatic int macvlan_addr_busy(const struct macvlan_port *port,\r\nconst unsigned char *addr)\r\n{\r\nif (ether_addr_equal_64bits(port->dev->dev_addr, addr))\r\nreturn 1;\r\nif (macvlan_hash_lookup(port, addr))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int macvlan_broadcast_one(struct sk_buff *skb,\r\nconst struct macvlan_dev *vlan,\r\nconst struct ethhdr *eth, bool local)\r\n{\r\nstruct net_device *dev = vlan->dev;\r\nif (!skb)\r\nreturn NET_RX_DROP;\r\nif (local)\r\nreturn vlan->forward(dev, skb);\r\nskb->dev = dev;\r\nif (ether_addr_equal_64bits(eth->h_dest, dev->broadcast))\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_MULTICAST;\r\nreturn vlan->receive(skb);\r\n}\r\nstatic void macvlan_broadcast(struct sk_buff *skb,\r\nconst struct macvlan_port *port,\r\nstruct net_device *src,\r\nenum macvlan_mode mode)\r\n{\r\nconst struct ethhdr *eth = eth_hdr(skb);\r\nconst struct macvlan_dev *vlan;\r\nstruct hlist_node *n;\r\nstruct sk_buff *nskb;\r\nunsigned int i;\r\nint err;\r\nif (skb->protocol == htons(ETH_P_PAUSE))\r\nreturn;\r\nfor (i = 0; i < MACVLAN_HASH_SIZE; i++) {\r\nhlist_for_each_entry_rcu(vlan, n, &port->vlan_hash[i], hlist) {\r\nif (vlan->dev == src || !(vlan->mode & mode))\r\ncontinue;\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nerr = macvlan_broadcast_one(nskb, vlan, eth,\r\nmode == MACVLAN_MODE_BRIDGE);\r\nmacvlan_count_rx(vlan, skb->len + ETH_HLEN,\r\nerr == NET_RX_SUCCESS, 1);\r\n}\r\n}\r\n}\r\nstatic rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)\r\n{\r\nstruct macvlan_port *port;\r\nstruct sk_buff *skb = *pskb;\r\nconst struct ethhdr *eth = eth_hdr(skb);\r\nconst struct macvlan_dev *vlan;\r\nconst struct macvlan_dev *src;\r\nstruct net_device *dev;\r\nunsigned int len = 0;\r\nint ret = NET_RX_DROP;\r\nport = macvlan_port_get_rcu(skb->dev);\r\nif (is_multicast_ether_addr(eth->h_dest)) {\r\nskb = ip_check_defrag(skb, IP_DEFRAG_MACVLAN);\r\nif (!skb)\r\nreturn RX_HANDLER_CONSUMED;\r\neth = eth_hdr(skb);\r\nsrc = macvlan_hash_lookup(port, eth->h_source);\r\nif (!src)\r\nmacvlan_broadcast(skb, port, NULL,\r\nMACVLAN_MODE_PRIVATE |\r\nMACVLAN_MODE_VEPA |\r\nMACVLAN_MODE_PASSTHRU|\r\nMACVLAN_MODE_BRIDGE);\r\nelse if (src->mode == MACVLAN_MODE_VEPA)\r\nmacvlan_broadcast(skb, port, src->dev,\r\nMACVLAN_MODE_VEPA |\r\nMACVLAN_MODE_BRIDGE);\r\nelse if (src->mode == MACVLAN_MODE_BRIDGE)\r\nmacvlan_broadcast(skb, port, src->dev,\r\nMACVLAN_MODE_VEPA);\r\nelse {\r\nvlan = src;\r\nret = macvlan_broadcast_one(skb, vlan, eth, 0);\r\ngoto out;\r\n}\r\nreturn RX_HANDLER_PASS;\r\n}\r\nif (port->passthru)\r\nvlan = list_first_entry(&port->vlans, struct macvlan_dev, list);\r\nelse\r\nvlan = macvlan_hash_lookup(port, eth->h_dest);\r\nif (vlan == NULL)\r\nreturn RX_HANDLER_PASS;\r\ndev = vlan->dev;\r\nif (unlikely(!(dev->flags & IFF_UP))) {\r\nkfree_skb(skb);\r\nreturn RX_HANDLER_CONSUMED;\r\n}\r\nlen = skb->len + ETH_HLEN;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\ngoto out;\r\nskb->dev = dev;\r\nskb->pkt_type = PACKET_HOST;\r\nret = vlan->receive(skb);\r\nout:\r\nmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, 0);\r\nreturn RX_HANDLER_CONSUMED;\r\n}\r\nstatic int macvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nconst struct macvlan_dev *vlan = netdev_priv(dev);\r\nconst struct macvlan_port *port = vlan->port;\r\nconst struct macvlan_dev *dest;\r\n__u8 ip_summed = skb->ip_summed;\r\nif (vlan->mode == MACVLAN_MODE_BRIDGE) {\r\nconst struct ethhdr *eth = (void *)skb->data;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nif (is_multicast_ether_addr(eth->h_dest)) {\r\nmacvlan_broadcast(skb, port, dev, MACVLAN_MODE_BRIDGE);\r\ngoto xmit_world;\r\n}\r\ndest = macvlan_hash_lookup(port, eth->h_dest);\r\nif (dest && dest->mode == MACVLAN_MODE_BRIDGE) {\r\ndev_forward_skb(vlan->lowerdev, skb);\r\nreturn NET_XMIT_SUCCESS;\r\n}\r\n}\r\nxmit_world:\r\nskb->ip_summed = ip_summed;\r\nskb->dev = vlan->lowerdev;\r\nreturn dev_queue_xmit(skb);\r\n}\r\nnetdev_tx_t macvlan_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nunsigned int len = skb->len;\r\nint ret;\r\nconst struct macvlan_dev *vlan = netdev_priv(dev);\r\nret = macvlan_queue_xmit(skb, dev);\r\nif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\r\nstruct macvlan_pcpu_stats *pcpu_stats;\r\npcpu_stats = this_cpu_ptr(vlan->pcpu_stats);\r\nu64_stats_update_begin(&pcpu_stats->syncp);\r\npcpu_stats->tx_packets++;\r\npcpu_stats->tx_bytes += len;\r\nu64_stats_update_end(&pcpu_stats->syncp);\r\n} else {\r\nthis_cpu_inc(vlan->pcpu_stats->tx_dropped);\r\n}\r\nreturn ret;\r\n}\r\nstatic int macvlan_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned len)\r\n{\r\nconst struct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nreturn dev_hard_header(skb, lowerdev, type, daddr,\r\nsaddr ? : dev->dev_addr, len);\r\n}\r\nstatic int macvlan_open(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nint err;\r\nif (vlan->port->passthru) {\r\nif (!(vlan->flags & MACVLAN_FLAG_NOPROMISC))\r\ndev_set_promiscuity(lowerdev, 1);\r\ngoto hash_add;\r\n}\r\nerr = -EBUSY;\r\nif (macvlan_addr_busy(vlan->port, dev->dev_addr))\r\ngoto out;\r\nerr = dev_uc_add(lowerdev, dev->dev_addr);\r\nif (err < 0)\r\ngoto out;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nerr = dev_set_allmulti(lowerdev, 1);\r\nif (err < 0)\r\ngoto del_unicast;\r\n}\r\nhash_add:\r\nmacvlan_hash_add(vlan);\r\nreturn 0;\r\ndel_unicast:\r\ndev_uc_del(lowerdev, dev->dev_addr);\r\nout:\r\nreturn err;\r\n}\r\nstatic int macvlan_stop(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\ndev_uc_unsync(lowerdev, dev);\r\ndev_mc_unsync(lowerdev, dev);\r\nif (vlan->port->passthru) {\r\nif (!(vlan->flags & MACVLAN_FLAG_NOPROMISC))\r\ndev_set_promiscuity(lowerdev, -1);\r\ngoto hash_del;\r\n}\r\nif (dev->flags & IFF_ALLMULTI)\r\ndev_set_allmulti(lowerdev, -1);\r\ndev_uc_del(lowerdev, dev->dev_addr);\r\nhash_del:\r\nmacvlan_hash_del(vlan, !dev->dismantle);\r\nreturn 0;\r\n}\r\nstatic int macvlan_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nstruct sockaddr *addr = p;\r\nint err;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nif (!(dev->flags & IFF_UP)) {\r\ndev->addr_assign_type &= ~NET_ADDR_RANDOM;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\n} else {\r\nif (macvlan_addr_busy(vlan->port, addr->sa_data))\r\nreturn -EBUSY;\r\nerr = dev_uc_add(lowerdev, addr->sa_data);\r\nif (err)\r\nreturn err;\r\ndev_uc_del(lowerdev, dev->dev_addr);\r\nmacvlan_hash_change_addr(vlan, addr->sa_data);\r\n}\r\nreturn 0;\r\n}\r\nstatic void macvlan_change_rx_flags(struct net_device *dev, int change)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nif (change & IFF_ALLMULTI)\r\ndev_set_allmulti(lowerdev, dev->flags & IFF_ALLMULTI ? 1 : -1);\r\n}\r\nstatic void macvlan_set_mac_lists(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\ndev_uc_sync(vlan->lowerdev, dev);\r\ndev_mc_sync(vlan->lowerdev, dev);\r\n}\r\nstatic int macvlan_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (new_mtu < 68 || vlan->lowerdev->mtu < new_mtu)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void macvlan_set_lockdep_class_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_unused)\r\n{\r\nlockdep_set_class(&txq->_xmit_lock,\r\n&macvlan_netdev_xmit_lock_key);\r\n}\r\nstatic void macvlan_set_lockdep_class(struct net_device *dev)\r\n{\r\nlockdep_set_class(&dev->addr_list_lock,\r\n&macvlan_netdev_addr_lock_key);\r\nnetdev_for_each_tx_queue(dev, macvlan_set_lockdep_class_one, NULL);\r\n}\r\nstatic int macvlan_init(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nconst struct net_device *lowerdev = vlan->lowerdev;\r\ndev->state = (dev->state & ~MACVLAN_STATE_MASK) |\r\n(lowerdev->state & MACVLAN_STATE_MASK);\r\ndev->features = lowerdev->features & MACVLAN_FEATURES;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->gso_max_size = lowerdev->gso_max_size;\r\ndev->iflink = lowerdev->ifindex;\r\ndev->hard_header_len = lowerdev->hard_header_len;\r\nmacvlan_set_lockdep_class(dev);\r\nvlan->pcpu_stats = alloc_percpu(struct macvlan_pcpu_stats);\r\nif (!vlan->pcpu_stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void macvlan_uninit(struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct macvlan_port *port = vlan->port;\r\nfree_percpu(vlan->pcpu_stats);\r\nport->count -= 1;\r\nif (!port->count)\r\nmacvlan_port_destroy(port->dev);\r\n}\r\nstatic struct rtnl_link_stats64 *macvlan_dev_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (vlan->pcpu_stats) {\r\nstruct macvlan_pcpu_stats *p;\r\nu64 rx_packets, rx_bytes, rx_multicast, tx_packets, tx_bytes;\r\nu32 rx_errors = 0, tx_dropped = 0;\r\nunsigned int start;\r\nint i;\r\nfor_each_possible_cpu(i) {\r\np = per_cpu_ptr(vlan->pcpu_stats, i);\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&p->syncp);\r\nrx_packets = p->rx_packets;\r\nrx_bytes = p->rx_bytes;\r\nrx_multicast = p->rx_multicast;\r\ntx_packets = p->tx_packets;\r\ntx_bytes = p->tx_bytes;\r\n} while (u64_stats_fetch_retry_bh(&p->syncp, start));\r\nstats->rx_packets += rx_packets;\r\nstats->rx_bytes += rx_bytes;\r\nstats->multicast += rx_multicast;\r\nstats->tx_packets += tx_packets;\r\nstats->tx_bytes += tx_bytes;\r\nrx_errors += p->rx_errors;\r\ntx_dropped += p->tx_dropped;\r\n}\r\nstats->rx_errors = rx_errors;\r\nstats->rx_dropped = rx_errors;\r\nstats->tx_dropped = tx_dropped;\r\n}\r\nreturn stats;\r\n}\r\nstatic int macvlan_vlan_rx_add_vid(struct net_device *dev,\r\nunsigned short vid)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nreturn vlan_vid_add(lowerdev, vid);\r\n}\r\nstatic int macvlan_vlan_rx_kill_vid(struct net_device *dev,\r\nunsigned short vid)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct net_device *lowerdev = vlan->lowerdev;\r\nvlan_vid_del(lowerdev, vid);\r\nreturn 0;\r\n}\r\nstatic int macvlan_fdb_add(struct ndmsg *ndm,\r\nstruct net_device *dev,\r\nunsigned char *addr,\r\nu16 flags)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint err = -EINVAL;\r\nif (!vlan->port->passthru)\r\nreturn -EOPNOTSUPP;\r\nif (is_unicast_ether_addr(addr))\r\nerr = dev_uc_add_excl(dev, addr);\r\nelse if (is_multicast_ether_addr(addr))\r\nerr = dev_mc_add_excl(dev, addr);\r\nreturn err;\r\n}\r\nstatic int macvlan_fdb_del(struct ndmsg *ndm,\r\nstruct net_device *dev,\r\nunsigned char *addr)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nint err = -EINVAL;\r\nif (!vlan->port->passthru)\r\nreturn -EOPNOTSUPP;\r\nif (is_unicast_ether_addr(addr))\r\nerr = dev_uc_del(dev, addr);\r\nelse if (is_multicast_ether_addr(addr))\r\nerr = dev_mc_del(dev, addr);\r\nreturn err;\r\n}\r\nstatic void macvlan_ethtool_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nsnprintf(drvinfo->driver, 32, "macvlan");\r\nsnprintf(drvinfo->version, 32, "0.1");\r\n}\r\nstatic int macvlan_ethtool_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nconst struct macvlan_dev *vlan = netdev_priv(dev);\r\nreturn __ethtool_get_settings(vlan->lowerdev, cmd);\r\n}\r\nvoid macvlan_common_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\r\ndev->netdev_ops = &macvlan_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->header_ops = &macvlan_hard_header_ops,\r\ndev->ethtool_ops = &macvlan_ethtool_ops;\r\n}\r\nstatic void macvlan_setup(struct net_device *dev)\r\n{\r\nmacvlan_common_setup(dev);\r\ndev->tx_queue_len = 0;\r\n}\r\nstatic int macvlan_port_create(struct net_device *dev)\r\n{\r\nstruct macvlan_port *port;\r\nunsigned int i;\r\nint err;\r\nif (dev->type != ARPHRD_ETHER || dev->flags & IFF_LOOPBACK)\r\nreturn -EINVAL;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (port == NULL)\r\nreturn -ENOMEM;\r\nport->passthru = false;\r\nport->dev = dev;\r\nINIT_LIST_HEAD(&port->vlans);\r\nfor (i = 0; i < MACVLAN_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&port->vlan_hash[i]);\r\nerr = netdev_rx_handler_register(dev, macvlan_handle_frame, port);\r\nif (err)\r\nkfree(port);\r\nelse\r\ndev->priv_flags |= IFF_MACVLAN_PORT;\r\nreturn err;\r\n}\r\nstatic void macvlan_port_destroy(struct net_device *dev)\r\n{\r\nstruct macvlan_port *port = macvlan_port_get(dev);\r\ndev->priv_flags &= ~IFF_MACVLAN_PORT;\r\nnetdev_rx_handler_unregister(dev);\r\nkfree_rcu(port, rcu);\r\n}\r\nstatic int macvlan_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (data && data[IFLA_MACVLAN_MODE]) {\r\nswitch (nla_get_u32(data[IFLA_MACVLAN_MODE])) {\r\ncase MACVLAN_MODE_PRIVATE:\r\ncase MACVLAN_MODE_VEPA:\r\ncase MACVLAN_MODE_BRIDGE:\r\ncase MACVLAN_MODE_PASSTHRU:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint macvlan_common_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[],\r\nint (*receive)(struct sk_buff *skb),\r\nint (*forward)(struct net_device *dev,\r\nstruct sk_buff *skb))\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nstruct macvlan_port *port;\r\nstruct net_device *lowerdev;\r\nint err;\r\nif (!tb[IFLA_LINK])\r\nreturn -EINVAL;\r\nlowerdev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\r\nif (lowerdev == NULL)\r\nreturn -ENODEV;\r\nif (lowerdev->rtnl_link_ops == dev->rtnl_link_ops) {\r\nstruct macvlan_dev *lowervlan = netdev_priv(lowerdev);\r\nlowerdev = lowervlan->lowerdev;\r\n}\r\nif (!tb[IFLA_MTU])\r\ndev->mtu = lowerdev->mtu;\r\nelse if (dev->mtu > lowerdev->mtu)\r\nreturn -EINVAL;\r\nif (!tb[IFLA_ADDRESS])\r\neth_hw_addr_random(dev);\r\nif (!macvlan_port_exists(lowerdev)) {\r\nerr = macvlan_port_create(lowerdev);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nport = macvlan_port_get(lowerdev);\r\nif (port->passthru)\r\nreturn -EINVAL;\r\nvlan->lowerdev = lowerdev;\r\nvlan->dev = dev;\r\nvlan->port = port;\r\nvlan->receive = receive;\r\nvlan->forward = forward;\r\nvlan->mode = MACVLAN_MODE_VEPA;\r\nif (data && data[IFLA_MACVLAN_MODE])\r\nvlan->mode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\r\nif (data && data[IFLA_MACVLAN_FLAGS])\r\nvlan->flags = nla_get_u16(data[IFLA_MACVLAN_FLAGS]);\r\nif (vlan->mode == MACVLAN_MODE_PASSTHRU) {\r\nif (port->count)\r\nreturn -EINVAL;\r\nport->passthru = true;\r\nmemcpy(dev->dev_addr, lowerdev->dev_addr, ETH_ALEN);\r\n}\r\nport->count += 1;\r\nerr = register_netdevice(dev);\r\nif (err < 0)\r\ngoto destroy_port;\r\nlist_add_tail(&vlan->list, &port->vlans);\r\nnetif_stacked_transfer_operstate(lowerdev, dev);\r\nreturn 0;\r\ndestroy_port:\r\nport->count -= 1;\r\nif (!port->count)\r\nmacvlan_port_destroy(lowerdev);\r\nreturn err;\r\n}\r\nstatic int macvlan_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nreturn macvlan_common_newlink(src_net, dev, tb, data,\r\nnetif_rx,\r\ndev_forward_skb);\r\n}\r\nvoid macvlan_dellink(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nlist_del(&vlan->list);\r\nunregister_netdevice_queue(dev, head);\r\n}\r\nstatic int macvlan_changelink(struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (data && data[IFLA_MACVLAN_MODE])\r\nvlan->mode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\r\nif (data && data[IFLA_MACVLAN_FLAGS]) {\r\n__u16 flags = nla_get_u16(data[IFLA_MACVLAN_FLAGS]);\r\nbool promisc = (flags ^ vlan->flags) & MACVLAN_FLAG_NOPROMISC;\r\nif (promisc && (flags & MACVLAN_FLAG_NOPROMISC))\r\ndev_set_promiscuity(vlan->lowerdev, -1);\r\nelse if (promisc && !(flags & MACVLAN_FLAG_NOPROMISC))\r\ndev_set_promiscuity(vlan->lowerdev, 1);\r\nvlan->flags = flags;\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t macvlan_get_size(const struct net_device *dev)\r\n{\r\nreturn nla_total_size(4);\r\n}\r\nstatic int macvlan_fill_info(struct sk_buff *skb,\r\nconst struct net_device *dev)\r\n{\r\nstruct macvlan_dev *vlan = netdev_priv(dev);\r\nif (nla_put_u32(skb, IFLA_MACVLAN_MODE, vlan->mode))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_MACVLAN_FLAGS, vlan->flags))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nint macvlan_link_register(struct rtnl_link_ops *ops)\r\n{\r\nops->priv_size = sizeof(struct macvlan_dev);\r\nops->validate = macvlan_validate;\r\nops->maxtype = IFLA_MACVLAN_MAX;\r\nops->policy = macvlan_policy;\r\nops->changelink = macvlan_changelink;\r\nops->get_size = macvlan_get_size;\r\nops->fill_info = macvlan_fill_info;\r\nreturn rtnl_link_register(ops);\r\n}\r\nstatic int macvlan_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nstruct macvlan_dev *vlan, *next;\r\nstruct macvlan_port *port;\r\nLIST_HEAD(list_kill);\r\nif (!macvlan_port_exists(dev))\r\nreturn NOTIFY_DONE;\r\nport = macvlan_port_get(dev);\r\nswitch (event) {\r\ncase NETDEV_CHANGE:\r\nlist_for_each_entry(vlan, &port->vlans, list)\r\nnetif_stacked_transfer_operstate(vlan->lowerdev,\r\nvlan->dev);\r\nbreak;\r\ncase NETDEV_FEAT_CHANGE:\r\nlist_for_each_entry(vlan, &port->vlans, list) {\r\nvlan->dev->features = dev->features & MACVLAN_FEATURES;\r\nvlan->dev->gso_max_size = dev->gso_max_size;\r\nnetdev_features_change(vlan->dev);\r\n}\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nif (dev->reg_state != NETREG_UNREGISTERING)\r\nbreak;\r\nlist_for_each_entry_safe(vlan, next, &port->vlans, list)\r\nvlan->dev->rtnl_link_ops->dellink(vlan->dev, &list_kill);\r\nunregister_netdevice_many(&list_kill);\r\nlist_del(&list_kill);\r\nbreak;\r\ncase NETDEV_PRE_TYPE_CHANGE:\r\nreturn NOTIFY_BAD;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init macvlan_init_module(void)\r\n{\r\nint err;\r\nregister_netdevice_notifier(&macvlan_notifier_block);\r\nerr = macvlan_link_register(&macvlan_link_ops);\r\nif (err < 0)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\nunregister_netdevice_notifier(&macvlan_notifier_block);\r\nreturn err;\r\n}\r\nstatic void __exit macvlan_cleanup_module(void)\r\n{\r\nrtnl_link_unregister(&macvlan_link_ops);\r\nunregister_netdevice_notifier(&macvlan_notifier_block);\r\n}
