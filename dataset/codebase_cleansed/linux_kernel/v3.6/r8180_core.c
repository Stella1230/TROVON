static void rtl8180_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev->netdev_ops->ndo_stop)\r\ndev->netdev_ops->ndo_stop(dev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int rtl8180_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (!netif_running(dev))\r\ngoto out_pci_suspend;\r\nif (dev->netdev_ops->ndo_stop)\r\ndev->netdev_ops->ndo_stop(dev);\r\nnetif_device_detach(dev);\r\nout_pci_suspend:\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int rtl8180_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nint err;\r\nu32 val;\r\npci_set_power_state(pdev, PCI_D0);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: pci_enable_device failed on resume\n",\r\ndev->name);\r\nreturn err;\r\n}\r\npci_restore_state(pdev);\r\npci_read_config_dword(pdev, 0x40, &val);\r\nif ((val & 0x0000ff00) != 0)\r\npci_write_config_dword(pdev, 0x40, val & 0xffff00ff);\r\nif (!netif_running(dev))\r\ngoto out;\r\nif (dev->netdev_ops->ndo_open)\r\ndev->netdev_ops->ndo_open(dev);\r\nnetif_device_attach(dev);\r\nout:\r\nreturn 0;\r\n}\r\nu8 read_nic_byte(struct net_device *dev, int x)\r\n{\r\nreturn 0xff&readb((u8 *)dev->mem_start + x);\r\n}\r\nu32 read_nic_dword(struct net_device *dev, int x)\r\n{\r\nreturn readl((u8 *)dev->mem_start + x);\r\n}\r\nu16 read_nic_word(struct net_device *dev, int x)\r\n{\r\nreturn readw((u8 *)dev->mem_start + x);\r\n}\r\nvoid write_nic_byte(struct net_device *dev, int x, u8 y)\r\n{\r\nwriteb(y, (u8 *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\nvoid write_nic_dword(struct net_device *dev, int x, u32 y)\r\n{\r\nwritel(y, (u8 *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\nvoid write_nic_word(struct net_device *dev, int x, u16 y)\r\n{\r\nwritew(y, (u8 *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\ninline void force_pci_posting(struct net_device *dev)\r\n{\r\nread_nic_byte(dev, EPROM_CMD);\r\nmb();\r\n}\r\nstatic int proc_get_registers(char *page, char **start,\r\noff_t offset, int count,\r\nint *eof, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nint len = 0;\r\nint i, n;\r\nint max = 0xff;\r\nfor (n = 0; n <= max;) {\r\nlen += snprintf(page + len, count - len, "\nD: %2x > ", n);\r\nfor (i = 0; i < 16 && n <= max; i++, n++)\r\nlen += snprintf(page + len, count - len, "%2x ",\r\nread_nic_byte(dev, n));\r\n}\r\nlen += snprintf(page + len, count - len, "\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nstatic int proc_get_stats_hw(char *page, char **start,\r\noff_t offset, int count,\r\nint *eof, void *data)\r\n{\r\nint len = 0;\r\n*eof = 1;\r\nreturn len;\r\n}\r\nstatic int proc_get_stats_rx(char *page, char **start,\r\noff_t offset, int count,\r\nint *eof, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nint len = 0;\r\nlen += snprintf(page + len, count - len,\r\n"RX OK: %lu\n"\r\n"RX Retry: %lu\n"\r\n"RX CRC Error(0-500): %lu\n"\r\n"RX CRC Error(500-1000): %lu\n"\r\n"RX CRC Error(>1000): %lu\n"\r\n"RX ICV Error: %lu\n",\r\npriv->stats.rxint,\r\npriv->stats.rxerr,\r\npriv->stats.rxcrcerrmin,\r\npriv->stats.rxcrcerrmid,\r\npriv->stats.rxcrcerrmax,\r\npriv->stats.rxicverr\r\n);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nstatic int proc_get_stats_tx(char *page, char **start,\r\noff_t offset, int count,\r\nint *eof, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nint len = 0;\r\nunsigned long totalOK;\r\ntotalOK = priv->stats.txnpokint+priv->stats.txhpokint+priv->stats.txlpokint;\r\nlen += snprintf(page + len, count - len,\r\n"TX OK: %lu\n"\r\n"TX Error: %lu\n"\r\n"TX Retry: %lu\n"\r\n"TX beacon OK: %lu\n"\r\n"TX beacon error: %lu\n",\r\ntotalOK,\r\npriv->stats.txnperr+priv->stats.txhperr+priv->stats.txlperr,\r\npriv->stats.txretry,\r\npriv->stats.txbeacon,\r\npriv->stats.txbeaconerr\r\n);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nvoid rtl8180_proc_module_init(void)\r\n{\r\nDMESG("Initializing proc filesystem");\r\nrtl8180_proc = proc_mkdir(RTL8180_MODULE_NAME, init_net.proc_net);\r\n}\r\nvoid rtl8180_proc_module_remove(void)\r\n{\r\nremove_proc_entry(RTL8180_MODULE_NAME, init_net.proc_net);\r\n}\r\nvoid rtl8180_proc_remove_one(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nif (priv->dir_dev) {\r\nremove_proc_entry("stats-hw", priv->dir_dev);\r\nremove_proc_entry("stats-tx", priv->dir_dev);\r\nremove_proc_entry("stats-rx", priv->dir_dev);\r\nremove_proc_entry("registers", priv->dir_dev);\r\nremove_proc_entry(dev->name, rtl8180_proc);\r\npriv->dir_dev = NULL;\r\n}\r\n}\r\nvoid rtl8180_proc_init_one(struct net_device *dev)\r\n{\r\nstruct proc_dir_entry *e;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\npriv->dir_dev = rtl8180_proc;\r\nif (!priv->dir_dev) {\r\nDMESGE("Unable to initialize /proc/net/r8180/%s\n",\r\ndev->name);\r\nreturn;\r\n}\r\ne = create_proc_read_entry("stats-hw", S_IFREG | S_IRUGO,\r\npriv->dir_dev, proc_get_stats_hw, dev);\r\nif (!e) {\r\nDMESGE("Unable to initialize "\r\n"/proc/net/r8180/%s/stats-hw\n",\r\ndev->name);\r\n}\r\ne = create_proc_read_entry("stats-rx", S_IFREG | S_IRUGO,\r\npriv->dir_dev, proc_get_stats_rx, dev);\r\nif (!e) {\r\nDMESGE("Unable to initialize "\r\n"/proc/net/r8180/%s/stats-rx\n",\r\ndev->name);\r\n}\r\ne = create_proc_read_entry("stats-tx", S_IFREG | S_IRUGO,\r\npriv->dir_dev, proc_get_stats_tx, dev);\r\nif (!e) {\r\nDMESGE("Unable to initialize "\r\n"/proc/net/r8180/%s/stats-tx\n",\r\ndev->name);\r\n}\r\ne = create_proc_read_entry("registers", S_IFREG | S_IRUGO,\r\npriv->dir_dev, proc_get_registers, dev);\r\nif (!e) {\r\nDMESGE("Unable to initialize "\r\n"/proc/net/r8180/%s/registers\n",\r\ndev->name);\r\n}\r\n}\r\nshort buffer_add(struct buffer **buffer, u32 *buf, dma_addr_t dma,\r\nstruct buffer **bufferhead)\r\n{\r\nstruct buffer *tmp;\r\nif (!*buffer) {\r\n*buffer = kmalloc(sizeof(struct buffer), GFP_KERNEL);\r\nif (*buffer == NULL) {\r\nDMESGE("Failed to kmalloc head of TX/RX struct");\r\nreturn -1;\r\n}\r\n(*buffer)->next = *buffer;\r\n(*buffer)->buf = buf;\r\n(*buffer)->dma = dma;\r\nif (bufferhead != NULL)\r\n(*bufferhead) = (*buffer);\r\nreturn 0;\r\n}\r\ntmp = *buffer;\r\nwhile (tmp->next != (*buffer))\r\ntmp = tmp->next;\r\ntmp->next = kmalloc(sizeof(struct buffer), GFP_KERNEL);\r\nif (tmp->next == NULL) {\r\nDMESGE("Failed to kmalloc TX/RX struct");\r\nreturn -1;\r\n}\r\ntmp->next->buf = buf;\r\ntmp->next->dma = dma;\r\ntmp->next->next = *buffer;\r\nreturn 0;\r\n}\r\nvoid buffer_free(struct net_device *dev, struct buffer **buffer, int len, short consistent)\r\n{\r\nstruct buffer *tmp, *next;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct pci_dev *pdev = priv->pdev;\r\nif (!*buffer)\r\nreturn;\r\ntmp = *buffer;\r\ndo {\r\nnext = tmp->next;\r\nif (consistent) {\r\npci_free_consistent(pdev, len,\r\ntmp->buf, tmp->dma);\r\n} else {\r\npci_unmap_single(pdev, tmp->dma,\r\nlen, PCI_DMA_FROMDEVICE);\r\nkfree(tmp->buf);\r\n}\r\nkfree(tmp);\r\ntmp = next;\r\n} while (next != *buffer);\r\n*buffer = NULL;\r\n}\r\nvoid print_buffer(u32 *buffer, int len)\r\n{\r\nint i;\r\nu8 *buf = (u8 *)buffer;\r\nprintk("ASCII BUFFER DUMP (len: %x):\n", len);\r\nfor (i = 0; i < len; i++)\r\nprintk("%c", buf[i]);\r\nprintk("\nBINARY BUFFER DUMP (len: %x):\n", len);\r\nfor (i = 0; i < len; i++)\r\nprintk("%02x", buf[i]);\r\nprintk("\n");\r\n}\r\nint get_curr_tx_free_desc(struct net_device *dev, int priority)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu32 *tail;\r\nu32 *head;\r\nint ret;\r\nswitch (priority) {\r\ncase MANAGE_PRIORITY:\r\nhead = priv->txmapringhead;\r\ntail = priv->txmapringtail;\r\nbreak;\r\ncase BK_PRIORITY:\r\nhead = priv->txbkpringhead;\r\ntail = priv->txbkpringtail;\r\nbreak;\r\ncase BE_PRIORITY:\r\nhead = priv->txbepringhead;\r\ntail = priv->txbepringtail;\r\nbreak;\r\ncase VI_PRIORITY:\r\nhead = priv->txvipringhead;\r\ntail = priv->txvipringtail;\r\nbreak;\r\ncase VO_PRIORITY:\r\nhead = priv->txvopringhead;\r\ntail = priv->txvopringtail;\r\nbreak;\r\ncase HI_PRIORITY:\r\nhead = priv->txhpringhead;\r\ntail = priv->txhpringtail;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nif (head <= tail)\r\nret = priv->txringcount - (tail - head)/8;\r\nelse\r\nret = (head - tail)/8;\r\nif (ret > priv->txringcount)\r\nDMESG("BUG");\r\nreturn ret;\r\n}\r\nshort check_nic_enought_desc(struct net_device *dev, int priority)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = netdev_priv(dev);\r\nint requiredbyte, required;\r\nrequiredbyte = priv->ieee80211->fts + sizeof(struct ieee80211_header_data);\r\nif (ieee->current_network.QoS_Enable)\r\nrequiredbyte += 2;\r\nrequired = requiredbyte / (priv->txbuffsize-4);\r\nif (requiredbyte % priv->txbuffsize)\r\nrequired++;\r\nreturn (required+2 < get_curr_tx_free_desc(dev, priority));\r\n}\r\nvoid fix_tx_fifo(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nu32 *tmp;\r\nint i;\r\nfor (tmp = priv->txmapring, i = 0;\r\ni < priv->txringcount;\r\ntmp += 8, i++) {\r\n*tmp = *tmp & ~(1<<31);\r\n}\r\nfor (tmp = priv->txbkpring, i = 0;\r\ni < priv->txringcount;\r\ntmp += 8, i++) {\r\n*tmp = *tmp & ~(1<<31);\r\n}\r\nfor (tmp = priv->txbepring, i = 0;\r\ni < priv->txringcount;\r\ntmp += 8, i++) {\r\n*tmp = *tmp & ~(1<<31);\r\n}\r\nfor (tmp = priv->txvipring, i = 0;\r\ni < priv->txringcount;\r\ntmp += 8, i++) {\r\n*tmp = *tmp & ~(1<<31);\r\n}\r\nfor (tmp = priv->txvopring, i = 0;\r\ni < priv->txringcount;\r\ntmp += 8, i++) {\r\n*tmp = *tmp & ~(1<<31);\r\n}\r\nfor (tmp = priv->txhpring, i = 0;\r\ni < priv->txringcount;\r\ntmp += 8, i++) {\r\n*tmp = *tmp & ~(1<<31);\r\n}\r\nfor (tmp = priv->txbeaconring, i = 0;\r\ni < priv->txbeaconcount;\r\ntmp += 8, i++) {\r\n*tmp = *tmp & ~(1<<31);\r\n}\r\npriv->txmapringtail = priv->txmapring;\r\npriv->txmapringhead = priv->txmapring;\r\npriv->txmapbufstail = priv->txmapbufs;\r\npriv->txbkpringtail = priv->txbkpring;\r\npriv->txbkpringhead = priv->txbkpring;\r\npriv->txbkpbufstail = priv->txbkpbufs;\r\npriv->txbepringtail = priv->txbepring;\r\npriv->txbepringhead = priv->txbepring;\r\npriv->txbepbufstail = priv->txbepbufs;\r\npriv->txvipringtail = priv->txvipring;\r\npriv->txvipringhead = priv->txvipring;\r\npriv->txvipbufstail = priv->txvipbufs;\r\npriv->txvopringtail = priv->txvopring;\r\npriv->txvopringhead = priv->txvopring;\r\npriv->txvopbufstail = priv->txvopbufs;\r\npriv->txhpringtail = priv->txhpring;\r\npriv->txhpringhead = priv->txhpring;\r\npriv->txhpbufstail = priv->txhpbufs;\r\npriv->txbeaconringtail = priv->txbeaconring;\r\npriv->txbeaconbufstail = priv->txbeaconbufs;\r\nset_nic_txring(dev);\r\nieee80211_reset_queue(priv->ieee80211);\r\npriv->ack_tx_to_ieee = 0;\r\n}\r\nvoid fix_rx_fifo(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nu32 *tmp;\r\nstruct buffer *rxbuf;\r\nu8 rx_desc_size;\r\nrx_desc_size = 8;\r\nfor (tmp = priv->rxring, rxbuf = priv->rxbufferhead;\r\n(tmp < (priv->rxring)+(priv->rxringcount)*rx_desc_size);\r\ntmp += rx_desc_size, rxbuf = rxbuf->next) {\r\n*(tmp+2) = rxbuf->dma;\r\n*tmp = *tmp & ~0xfff;\r\n*tmp = *tmp | priv->rxbuffersize;\r\n*tmp |= (1<<31);\r\n}\r\npriv->rxringtail = priv->rxring;\r\npriv->rxbuffer = priv->rxbufferhead;\r\npriv->rx_skb_complete = 1;\r\nset_nic_rxring(dev);\r\n}\r\nvoid rtl8180_RSSI_calc(struct net_device *dev, u8 *rssi, u8 *qual)\r\n{\r\nu32 temp;\r\nu32 temp2;\r\nu32 q;\r\nu32 orig_qual;\r\nu8 _rssi;\r\nq = *qual;\r\norig_qual = *qual;\r\n_rssi = 0;\r\nif (q <= 0x4e) {\r\ntemp = QUALITY_MAP[q];\r\n} else {\r\nif (q & 0x80)\r\ntemp = 0x32;\r\nelse\r\ntemp = 1;\r\n}\r\n*qual = temp;\r\ntemp2 = *rssi;\r\nif (_rssi < 0x64) {\r\nif (_rssi == 0)\r\n*rssi = 1;\r\n} else {\r\n*rssi = 0x64;\r\n}\r\nreturn;\r\n}\r\nvoid rtl8180_irq_enable(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\npriv->irq_enabled = 1;\r\nwrite_nic_word(dev, INTA_MASK, priv->irq_mask);\r\n}\r\nvoid rtl8180_irq_disable(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nwrite_nic_dword(dev, IMR, 0);\r\nforce_pci_posting(dev);\r\npriv->irq_enabled = 0;\r\n}\r\nvoid rtl8180_set_mode(struct net_device *dev, int mode)\r\n{\r\nu8 ecmd;\r\necmd = read_nic_byte(dev, EPROM_CMD);\r\necmd = ecmd & ~EPROM_CMD_OPERATING_MODE_MASK;\r\necmd = ecmd | (mode<<EPROM_CMD_OPERATING_MODE_SHIFT);\r\necmd = ecmd & ~(1<<EPROM_CS_SHIFT);\r\necmd = ecmd & ~(1<<EPROM_CK_SHIFT);\r\nwrite_nic_byte(dev, EPROM_CMD, ecmd);\r\n}\r\nvoid rtl8180_update_msr(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu8 msr;\r\nu32 rxconf;\r\nmsr = read_nic_byte(dev, MSR);\r\nmsr &= ~MSR_LINK_MASK;\r\nrxconf = read_nic_dword(dev, RX_CONF);\r\nif (priv->ieee80211->state == IEEE80211_LINKED) {\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nmsr |= (MSR_LINK_ADHOC<<MSR_LINK_SHIFT);\r\nelse if (priv->ieee80211->iw_mode == IW_MODE_MASTER)\r\nmsr |= (MSR_LINK_MASTER<<MSR_LINK_SHIFT);\r\nelse if (priv->ieee80211->iw_mode == IW_MODE_INFRA)\r\nmsr |= (MSR_LINK_MANAGED<<MSR_LINK_SHIFT);\r\nelse\r\nmsr |= (MSR_LINK_NONE<<MSR_LINK_SHIFT);\r\nrxconf |= (1<<RX_CHECK_BSSID_SHIFT);\r\n} else {\r\nmsr |= (MSR_LINK_NONE<<MSR_LINK_SHIFT);\r\nrxconf &= ~(1<<RX_CHECK_BSSID_SHIFT);\r\n}\r\nwrite_nic_byte(dev, MSR, msr);\r\nwrite_nic_dword(dev, RX_CONF, rxconf);\r\n}\r\nvoid rtl8180_set_chan(struct net_device *dev, short ch)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nif ((ch > 14) || (ch < 1)) {\r\nprintk("In %s: Invalid chnanel %d\n", __func__, ch);\r\nreturn;\r\n}\r\npriv->chan = ch;\r\npriv->rf_set_chan(dev, priv->chan);\r\n}\r\nvoid rtl8180_rx_enable(struct net_device *dev)\r\n{\r\nu8 cmd;\r\nu32 rxconf;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nrxconf = read_nic_dword(dev, RX_CONF);\r\nrxconf = rxconf & ~MAC_FILTER_MASK;\r\nrxconf = rxconf | (1<<ACCEPT_MNG_FRAME_SHIFT);\r\nrxconf = rxconf | (1<<ACCEPT_DATA_FRAME_SHIFT);\r\nrxconf = rxconf | (1<<ACCEPT_BCAST_FRAME_SHIFT);\r\nrxconf = rxconf | (1<<ACCEPT_MCAST_FRAME_SHIFT);\r\nif (dev->flags & IFF_PROMISC)\r\nDMESG("NIC in promisc mode");\r\nif (priv->ieee80211->iw_mode == IW_MODE_MONITOR || \\r\ndev->flags & IFF_PROMISC) {\r\nrxconf = rxconf | (1<<ACCEPT_ALLMAC_FRAME_SHIFT);\r\n} else {\r\nrxconf = rxconf | (1<<ACCEPT_NICMAC_FRAME_SHIFT);\r\n}\r\nif (priv->ieee80211->iw_mode == IW_MODE_MONITOR) {\r\nrxconf = rxconf | (1<<ACCEPT_CTL_FRAME_SHIFT);\r\nrxconf = rxconf | (1<<ACCEPT_ICVERR_FRAME_SHIFT);\r\nrxconf = rxconf | (1<<ACCEPT_PWR_FRAME_SHIFT);\r\n}\r\nif (priv->crcmon == 1 && priv->ieee80211->iw_mode == IW_MODE_MONITOR)\r\nrxconf = rxconf | (1<<ACCEPT_CRCERR_FRAME_SHIFT);\r\nrxconf = rxconf & ~RX_FIFO_THRESHOLD_MASK;\r\nrxconf = rxconf | (RX_FIFO_THRESHOLD_NONE << RX_FIFO_THRESHOLD_SHIFT);\r\nrxconf = rxconf | (1<<RX_AUTORESETPHY_SHIFT);\r\nrxconf = rxconf & ~MAX_RX_DMA_MASK;\r\nrxconf = rxconf | (MAX_RX_DMA_2048<<MAX_RX_DMA_SHIFT);\r\nrxconf = rxconf | RCR_ONLYERLPKT;\r\nrxconf = rxconf & ~RCR_CS_MASK;\r\nwrite_nic_dword(dev, RX_CONF, rxconf);\r\nfix_rx_fifo(dev);\r\ncmd = read_nic_byte(dev, CMD);\r\nwrite_nic_byte(dev, CMD, cmd | (1<<CMD_RX_ENABLE_SHIFT));\r\n}\r\nvoid set_nic_txring(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nwrite_nic_dword(dev, TX_MANAGEPRIORITY_RING_ADDR, priv->txmapringdma);\r\nwrite_nic_dword(dev, TX_BKPRIORITY_RING_ADDR, priv->txbkpringdma);\r\nwrite_nic_dword(dev, TX_BEPRIORITY_RING_ADDR, priv->txbepringdma);\r\nwrite_nic_dword(dev, TX_VIPRIORITY_RING_ADDR, priv->txvipringdma);\r\nwrite_nic_dword(dev, TX_VOPRIORITY_RING_ADDR, priv->txvopringdma);\r\nwrite_nic_dword(dev, TX_HIGHPRIORITY_RING_ADDR, priv->txhpringdma);\r\nwrite_nic_dword(dev, TX_BEACON_RING_ADDR, priv->txbeaconringdma);\r\n}\r\nvoid rtl8180_conttx_enable(struct net_device *dev)\r\n{\r\nu32 txconf;\r\ntxconf = read_nic_dword(dev, TX_CONF);\r\ntxconf = txconf & ~TX_LOOPBACK_MASK;\r\ntxconf = txconf | (TX_LOOPBACK_CONTINUE<<TX_LOOPBACK_SHIFT);\r\nwrite_nic_dword(dev, TX_CONF, txconf);\r\n}\r\nvoid rtl8180_conttx_disable(struct net_device *dev)\r\n{\r\nu32 txconf;\r\ntxconf = read_nic_dword(dev, TX_CONF);\r\ntxconf = txconf & ~TX_LOOPBACK_MASK;\r\ntxconf = txconf | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT);\r\nwrite_nic_dword(dev, TX_CONF, txconf);\r\n}\r\nvoid rtl8180_tx_enable(struct net_device *dev)\r\n{\r\nu8 cmd;\r\nu8 tx_agc_ctl;\r\nu8 byte;\r\nu32 txconf;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\ntxconf = read_nic_dword(dev, TX_CONF);\r\nbyte = read_nic_byte(dev, CW_CONF);\r\nbyte &= ~(1<<CW_CONF_PERPACKET_CW_SHIFT);\r\nbyte &= ~(1<<CW_CONF_PERPACKET_RETRY_SHIFT);\r\nwrite_nic_byte(dev, CW_CONF, byte);\r\ntx_agc_ctl = read_nic_byte(dev, TX_AGC_CTL);\r\ntx_agc_ctl &= ~(1<<TX_AGC_CTL_PERPACKET_GAIN_SHIFT);\r\ntx_agc_ctl &= ~(1<<TX_AGC_CTL_PERPACKET_ANTSEL_SHIFT);\r\ntx_agc_ctl |= (1<<TX_AGC_CTL_FEEDBACK_ANT);\r\nwrite_nic_byte(dev, TX_AGC_CTL, tx_agc_ctl);\r\nwrite_nic_byte(dev, 0xec, 0x3f);\r\ntxconf = txconf & ~(1<<TCR_PROBE_NOTIMESTAMP_SHIFT);\r\ntxconf = txconf & ~TX_LOOPBACK_MASK;\r\ntxconf = txconf | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT);\r\ntxconf = txconf & ~TCR_DPRETRY_MASK;\r\ntxconf = txconf & ~TCR_RTSRETRY_MASK;\r\ntxconf = txconf | (priv->retry_data<<TX_DPRETRY_SHIFT);\r\ntxconf = txconf | (priv->retry_rts<<TX_RTSRETRY_SHIFT);\r\ntxconf = txconf & ~(1<<TX_NOCRC_SHIFT);\r\nif (priv->hw_plcp_len)\r\ntxconf = txconf & ~TCR_PLCP_LEN;\r\nelse\r\ntxconf = txconf | TCR_PLCP_LEN;\r\ntxconf = txconf & ~TCR_MXDMA_MASK;\r\ntxconf = txconf | (TCR_MXDMA_2048<<TCR_MXDMA_SHIFT);\r\ntxconf = txconf | TCR_CWMIN;\r\ntxconf = txconf | TCR_DISCW;\r\ntxconf = txconf | (1 << TX_NOICV_SHIFT);\r\nwrite_nic_dword(dev, TX_CONF, txconf);\r\nfix_tx_fifo(dev);\r\ncmd = read_nic_byte(dev, CMD);\r\nwrite_nic_byte(dev, CMD, cmd | (1<<CMD_TX_ENABLE_SHIFT));\r\nwrite_nic_dword(dev, TX_CONF, txconf);\r\n}\r\nvoid rtl8180_beacon_tx_enable(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\npriv->dma_poll_stop_mask &= ~(TPPOLLSTOP_BQ);\r\nwrite_nic_byte(dev, TPPollStop, priv->dma_poll_mask);\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\n}\r\nvoid rtl8180_beacon_tx_disable(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\npriv->dma_poll_stop_mask |= TPPOLLSTOP_BQ;\r\nwrite_nic_byte(dev, TPPollStop, priv->dma_poll_stop_mask);\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\n}\r\nvoid rtl8180_rtx_disable(struct net_device *dev)\r\n{\r\nu8 cmd;\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\ncmd = read_nic_byte(dev, CMD);\r\nwrite_nic_byte(dev, CMD, cmd & ~\\r\n((1<<CMD_RX_ENABLE_SHIFT)|(1<<CMD_TX_ENABLE_SHIFT)));\r\nforce_pci_posting(dev);\r\nmdelay(10);\r\nif (!priv->rx_skb_complete)\r\ndev_kfree_skb_any(priv->rx_skb);\r\n}\r\nshort alloc_tx_desc_ring(struct net_device *dev, int bufsize, int count,\r\nint addr)\r\n{\r\nint i;\r\nu32 *desc;\r\nu32 *tmp;\r\ndma_addr_t dma_desc, dma_tmp;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct pci_dev *pdev = priv->pdev;\r\nvoid *buf;\r\nif ((bufsize & 0xfff) != bufsize) {\r\nDMESGE("TX buffer allocation too large");\r\nreturn 0;\r\n}\r\ndesc = (u32 *)pci_alloc_consistent(pdev,\r\nsizeof(u32)*8*count+256, &dma_desc);\r\nif (desc == NULL)\r\nreturn -1;\r\nif (dma_desc & 0xff)\r\nWARN(1, "DMA buffer is not aligned\n");\r\ntmp = desc;\r\nfor (i = 0; i < count; i++) {\r\nbuf = (void *)pci_alloc_consistent(pdev, bufsize, &dma_tmp);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nswitch (addr) {\r\ncase TX_MANAGEPRIORITY_RING_ADDR:\r\nif (-1 == buffer_add(&(priv->txmapbufs), buf, dma_tmp, NULL)) {\r\nDMESGE("Unable to allocate mem for buffer NP");\r\nreturn -ENOMEM;\r\n}\r\nbreak;\r\ncase TX_BKPRIORITY_RING_ADDR:\r\nif (-1 == buffer_add(&(priv->txbkpbufs), buf, dma_tmp, NULL)) {\r\nDMESGE("Unable to allocate mem for buffer LP");\r\nreturn -ENOMEM;\r\n}\r\nbreak;\r\ncase TX_BEPRIORITY_RING_ADDR:\r\nif (-1 == buffer_add(&(priv->txbepbufs), buf, dma_tmp, NULL)) {\r\nDMESGE("Unable to allocate mem for buffer NP");\r\nreturn -ENOMEM;\r\n}\r\nbreak;\r\ncase TX_VIPRIORITY_RING_ADDR:\r\nif (-1 == buffer_add(&(priv->txvipbufs), buf, dma_tmp, NULL)) {\r\nDMESGE("Unable to allocate mem for buffer LP");\r\nreturn -ENOMEM;\r\n}\r\nbreak;\r\ncase TX_VOPRIORITY_RING_ADDR:\r\nif (-1 == buffer_add(&(priv->txvopbufs), buf, dma_tmp, NULL)) {\r\nDMESGE("Unable to allocate mem for buffer NP");\r\nreturn -ENOMEM;\r\n}\r\nbreak;\r\ncase TX_HIGHPRIORITY_RING_ADDR:\r\nif (-1 == buffer_add(&(priv->txhpbufs), buf, dma_tmp, NULL)) {\r\nDMESGE("Unable to allocate mem for buffer HP");\r\nreturn -ENOMEM;\r\n}\r\nbreak;\r\ncase TX_BEACON_RING_ADDR:\r\nif (-1 == buffer_add(&(priv->txbeaconbufs), buf, dma_tmp, NULL)) {\r\nDMESGE("Unable to allocate mem for buffer BP");\r\nreturn -ENOMEM;\r\n}\r\nbreak;\r\n}\r\n*tmp = *tmp & ~(1<<31);\r\n*(tmp+2) = (u32)dma_tmp;\r\n*(tmp+3) = bufsize;\r\nif (i+1 < count)\r\n*(tmp+4) = (u32)dma_desc+((i+1)*8*4);\r\nelse\r\n*(tmp+4) = (u32)dma_desc;\r\ntmp = tmp+8;\r\n}\r\nswitch (addr) {\r\ncase TX_MANAGEPRIORITY_RING_ADDR:\r\npriv->txmapringdma = dma_desc;\r\npriv->txmapring = desc;\r\nbreak;\r\ncase TX_BKPRIORITY_RING_ADDR:\r\npriv->txbkpringdma = dma_desc;\r\npriv->txbkpring = desc;\r\nbreak;\r\ncase TX_BEPRIORITY_RING_ADDR:\r\npriv->txbepringdma = dma_desc;\r\npriv->txbepring = desc;\r\nbreak;\r\ncase TX_VIPRIORITY_RING_ADDR:\r\npriv->txvipringdma = dma_desc;\r\npriv->txvipring = desc;\r\nbreak;\r\ncase TX_VOPRIORITY_RING_ADDR:\r\npriv->txvopringdma = dma_desc;\r\npriv->txvopring = desc;\r\nbreak;\r\ncase TX_HIGHPRIORITY_RING_ADDR:\r\npriv->txhpringdma = dma_desc;\r\npriv->txhpring = desc;\r\nbreak;\r\ncase TX_BEACON_RING_ADDR:\r\npriv->txbeaconringdma = dma_desc;\r\npriv->txbeaconring = desc;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid free_tx_desc_rings(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct pci_dev *pdev = priv->pdev;\r\nint count = priv->txringcount;\r\npci_free_consistent(pdev, sizeof(u32)*8*count+256,\r\npriv->txmapring, priv->txmapringdma);\r\nbuffer_free(dev, &(priv->txmapbufs), priv->txbuffsize, 1);\r\npci_free_consistent(pdev, sizeof(u32)*8*count+256,\r\npriv->txbkpring, priv->txbkpringdma);\r\nbuffer_free(dev, &(priv->txbkpbufs), priv->txbuffsize, 1);\r\npci_free_consistent(pdev, sizeof(u32)*8*count+256,\r\npriv->txbepring, priv->txbepringdma);\r\nbuffer_free(dev, &(priv->txbepbufs), priv->txbuffsize, 1);\r\npci_free_consistent(pdev, sizeof(u32)*8*count+256,\r\npriv->txvipring, priv->txvipringdma);\r\nbuffer_free(dev, &(priv->txvipbufs), priv->txbuffsize, 1);\r\npci_free_consistent(pdev, sizeof(u32)*8*count+256,\r\npriv->txvopring, priv->txvopringdma);\r\nbuffer_free(dev, &(priv->txvopbufs), priv->txbuffsize, 1);\r\npci_free_consistent(pdev, sizeof(u32)*8*count+256,\r\npriv->txhpring, priv->txhpringdma);\r\nbuffer_free(dev, &(priv->txhpbufs), priv->txbuffsize, 1);\r\ncount = priv->txbeaconcount;\r\npci_free_consistent(pdev, sizeof(u32)*8*count+256,\r\npriv->txbeaconring, priv->txbeaconringdma);\r\nbuffer_free(dev, &(priv->txbeaconbufs), priv->txbuffsize, 1);\r\n}\r\nvoid free_rx_desc_ring(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct pci_dev *pdev = priv->pdev;\r\nint count = priv->rxringcount;\r\npci_free_consistent(pdev, sizeof(u32)*8*count+256,\r\npriv->rxring, priv->rxringdma);\r\nbuffer_free(dev, &(priv->rxbuffer), priv->rxbuffersize, 0);\r\n}\r\nshort alloc_rx_desc_ring(struct net_device *dev, u16 bufsize, int count)\r\n{\r\nint i;\r\nu32 *desc;\r\nu32 *tmp;\r\ndma_addr_t dma_desc, dma_tmp;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct pci_dev *pdev = priv->pdev;\r\nvoid *buf;\r\nu8 rx_desc_size;\r\nrx_desc_size = 8;\r\nif ((bufsize & 0xfff) != bufsize) {\r\nDMESGE("RX buffer allocation too large");\r\nreturn -1;\r\n}\r\ndesc = (u32 *)pci_alloc_consistent(pdev, sizeof(u32)*rx_desc_size*count+256,\r\n&dma_desc);\r\nif (dma_desc & 0xff)\r\nWARN(1, "DMA buffer is not aligned\n");\r\npriv->rxring = desc;\r\npriv->rxringdma = dma_desc;\r\ntmp = desc;\r\nfor (i = 0; i < count; i++) {\r\nbuf = kmalloc(bufsize * sizeof(u8), GFP_ATOMIC);\r\nif (buf == NULL) {\r\nDMESGE("Failed to kmalloc RX buffer");\r\nreturn -1;\r\n}\r\ndma_tmp = pci_map_single(pdev, buf, bufsize * sizeof(u8),\r\nPCI_DMA_FROMDEVICE);\r\nif (-1 == buffer_add(&(priv->rxbuffer), buf, dma_tmp,\r\n&(priv->rxbufferhead))) {\r\nDMESGE("Unable to allocate mem RX buf");\r\nreturn -1;\r\n}\r\n*tmp = 0;\r\n*tmp = *tmp | (bufsize&0xfff);\r\n*(tmp+2) = (u32)dma_tmp;\r\n*tmp = *tmp | (1<<31);\r\ntmp = tmp+rx_desc_size;\r\n}\r\n*(tmp-rx_desc_size) = *(tmp-rx_desc_size) | (1<<30);\r\nreturn 0;\r\n}\r\nvoid set_nic_rxring(struct net_device *dev)\r\n{\r\nu8 pgreg;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\npgreg = read_nic_byte(dev, PGSELECT);\r\nwrite_nic_byte(dev, PGSELECT, pgreg & ~(1<<PGSELECT_PG_SHIFT));\r\nwrite_nic_dword(dev, RXRING_ADDR, priv->rxringdma);\r\n}\r\nvoid rtl8180_reset(struct net_device *dev)\r\n{\r\nu8 cr;\r\nrtl8180_irq_disable(dev);\r\ncr = read_nic_byte(dev, CMD);\r\ncr = cr & 2;\r\ncr = cr | (1<<CMD_RST_SHIFT);\r\nwrite_nic_byte(dev, CMD, cr);\r\nforce_pci_posting(dev);\r\nmdelay(200);\r\nif (read_nic_byte(dev, CMD) & (1<<CMD_RST_SHIFT))\r\nDMESGW("Card reset timeout!");\r\nelse\r\nDMESG("Card successfully reset");\r\nrtl8180_set_mode(dev, EPROM_CMD_LOAD);\r\nforce_pci_posting(dev);\r\nmdelay(200);\r\n}\r\ninline u16 ieeerate2rtlrate(int rate)\r\n{\r\nswitch (rate) {\r\ncase 10:\r\nreturn 0;\r\ncase 20:\r\nreturn 1;\r\ncase 55:\r\nreturn 2;\r\ncase 110:\r\nreturn 3;\r\ncase 60:\r\nreturn 4;\r\ncase 90:\r\nreturn 5;\r\ncase 120:\r\nreturn 6;\r\ncase 180:\r\nreturn 7;\r\ncase 240:\r\nreturn 8;\r\ncase 360:\r\nreturn 9;\r\ncase 480:\r\nreturn 10;\r\ncase 540:\r\nreturn 11;\r\ndefault:\r\nreturn 3;\r\n}\r\n}\r\ninline u16 rtl8180_rate2rate(short rate)\r\n{\r\nif (rate > 12)\r\nreturn 10;\r\nreturn rtl_rate[rate];\r\n}\r\ninline u8 rtl8180_IsWirelessBMode(u16 rate)\r\n{\r\nif (((rate <= 110) && (rate != 60) && (rate != 90)) || (rate == 220))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nu16 ComputeTxTime(u16 FrameLength, u16 DataRate, u8 bManagementFrame,\r\nu8 bShortPreamble)\r\n{\r\nu16 FrameTime;\r\nu16 N_DBPS;\r\nu16 Ceiling;\r\nif (rtl8180_IsWirelessBMode(DataRate)) {\r\nif (bManagementFrame || !bShortPreamble || DataRate == 10)\r\nFrameTime = (u16)(144+48+(FrameLength*8/(DataRate/10)));\r\nelse\r\nFrameTime = (u16)(72+24+(FrameLength*8/(DataRate/10)));\r\nif ((FrameLength*8 % (DataRate/10)) != 0)\r\nFrameTime++;\r\n} else {\r\nN_DBPS = N_DBPSOfRate(DataRate);\r\nCeiling = (16 + 8*FrameLength + 6) / N_DBPS\r\n+ (((16 + 8*FrameLength + 6) % N_DBPS) ? 1 : 0);\r\nFrameTime = (u16)(16 + 4 + 4*Ceiling + 6);\r\n}\r\nreturn FrameTime;\r\n}\r\nu16 N_DBPSOfRate(u16 DataRate)\r\n{\r\nu16 N_DBPS = 24;\r\nswitch (DataRate) {\r\ncase 60:\r\nN_DBPS = 24;\r\nbreak;\r\ncase 90:\r\nN_DBPS = 36;\r\nbreak;\r\ncase 120:\r\nN_DBPS = 48;\r\nbreak;\r\ncase 180:\r\nN_DBPS = 72;\r\nbreak;\r\ncase 240:\r\nN_DBPS = 96;\r\nbreak;\r\ncase 360:\r\nN_DBPS = 144;\r\nbreak;\r\ncase 480:\r\nN_DBPS = 192;\r\nbreak;\r\ncase 540:\r\nN_DBPS = 216;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn N_DBPS;\r\n}\r\nlong NetgearSignalStrengthTranslate(long LastSS, long CurrSS)\r\n{\r\nlong RetSS;\r\nif (CurrSS >= 71 && CurrSS <= 100)\r\nRetSS = 90 + ((CurrSS - 70) / 3);\r\nelse if (CurrSS >= 41 && CurrSS <= 70)\r\nRetSS = 78 + ((CurrSS - 40) / 3);\r\nelse if (CurrSS >= 31 && CurrSS <= 40)\r\nRetSS = 66 + (CurrSS - 30);\r\nelse if (CurrSS >= 21 && CurrSS <= 30)\r\nRetSS = 54 + (CurrSS - 20);\r\nelse if (CurrSS >= 5 && CurrSS <= 20)\r\nRetSS = 42 + (((CurrSS - 5) * 2) / 3);\r\nelse if (CurrSS == 4)\r\nRetSS = 36;\r\nelse if (CurrSS == 3)\r\nRetSS = 27;\r\nelse if (CurrSS == 2)\r\nRetSS = 18;\r\nelse if (CurrSS == 1)\r\nRetSS = 9;\r\nelse\r\nRetSS = CurrSS;\r\nif (LastSS > 0)\r\nRetSS = ((LastSS * 5) + (RetSS) + 5) / 6;\r\nreturn RetSS;\r\n}\r\nlong TranslateToDbm8185(u8 SignalStrengthIndex)\r\n{\r\nlong SignalPower;\r\nSignalPower = (long)((SignalStrengthIndex + 1) >> 1);\r\nSignalPower -= 95;\r\nreturn SignalPower;\r\n}\r\nvoid PerformUndecoratedSignalSmoothing8185(struct r8180_priv *priv,\r\nbool bCckRate)\r\n{\r\npriv->bCurCCKPkt = bCckRate;\r\nif (priv->UndecoratedSmoothedSS >= 0)\r\npriv->UndecoratedSmoothedSS = ((priv->UndecoratedSmoothedSS * 5) +\r\n(priv->SignalStrength * 10)) / 6;\r\nelse\r\npriv->UndecoratedSmoothedSS = priv->SignalStrength * 10;\r\npriv->UndercorateSmoothedRxPower = ((priv->UndercorateSmoothedRxPower * 50) +\r\n(priv->RxPower * 11)) / 60;\r\nif (bCckRate)\r\npriv->CurCCKRSSI = priv->RSSI;\r\nelse\r\npriv->CurCCKRSSI = 0;\r\n}\r\nvoid rtl8180_rx(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct sk_buff *tmp_skb;\r\nshort first, last;\r\nu32 len;\r\nint lastlen;\r\nunsigned char quality, signal;\r\nu8 rate;\r\nu32 *tmp, *tmp2;\r\nu8 rx_desc_size;\r\nu8 padding;\r\nchar rxpower = 0;\r\nu32 RXAGC = 0;\r\nlong RxAGC_dBm = 0;\r\nu8 LNA = 0, BB = 0;\r\nu8 LNA_gain[4] = {02, 17, 29, 39};\r\nu8 Antenna = 0;\r\nstruct ieee80211_hdr_4addr *hdr;\r\nu16 fc, type;\r\nu8 bHwError = 0, bCRC = 0, bICV = 0;\r\nbool bCckRate = false;\r\nu8 RSSI = 0;\r\nlong SignalStrengthIndex = 0;\r\nstruct ieee80211_rx_stats stats = {\r\n.signal = 0,\r\n.noise = -98,\r\n.rate = 0,\r\n.freq = IEEE80211_24GHZ_BAND,\r\n};\r\nstats.nic_type = NIC_8185B;\r\nrx_desc_size = 8;\r\nif ((*(priv->rxringtail)) & (1<<31)) {\r\npriv->stats.rxnodata++;\r\npriv->ieee80211->stats.rx_errors++;\r\ntmp2 = NULL;\r\ntmp = priv->rxringtail;\r\ndo {\r\nif (tmp == priv->rxring)\r\ntmp = priv->rxring + (priv->rxringcount - 1)*rx_desc_size;\r\nelse\r\ntmp -= rx_desc_size;\r\nif (!(*tmp & (1<<31)))\r\ntmp2 = tmp;\r\n} while (tmp != priv->rxring);\r\nif (tmp2)\r\npriv->rxringtail = tmp2;\r\n}\r\nwhile (!(*(priv->rxringtail) & (1<<31))) {\r\nif (*(priv->rxringtail) & (1<<26))\r\nDMESGW("RX buffer overflow");\r\nif (*(priv->rxringtail) & (1<<12))\r\npriv->stats.rxicverr++;\r\nif (*(priv->rxringtail) & (1<<27)) {\r\npriv->stats.rxdmafail++;\r\ngoto drop;\r\n}\r\npci_dma_sync_single_for_cpu(priv->pdev,\r\npriv->rxbuffer->dma,\r\npriv->rxbuffersize * \\r\nsizeof(u8),\r\nPCI_DMA_FROMDEVICE);\r\nfirst = *(priv->rxringtail) & (1<<29) ? 1 : 0;\r\nif (first)\r\npriv->rx_prevlen = 0;\r\nlast = *(priv->rxringtail) & (1<<28) ? 1 : 0;\r\nif (last) {\r\nlastlen = ((*priv->rxringtail) & 0xfff);\r\nif (lastlen < priv->rx_prevlen)\r\nlen = 0;\r\nelse\r\nlen = lastlen-priv->rx_prevlen;\r\nif (*(priv->rxringtail) & (1<<13)) {\r\nif ((*(priv->rxringtail) & 0xfff) < 500)\r\npriv->stats.rxcrcerrmin++;\r\nelse if ((*(priv->rxringtail) & 0x0fff) > 1000)\r\npriv->stats.rxcrcerrmax++;\r\nelse\r\npriv->stats.rxcrcerrmid++;\r\n}\r\n} else {\r\nlen = priv->rxbuffersize;\r\n}\r\nif (first && last) {\r\npadding = ((*(priv->rxringtail+3))&(0x04000000))>>26;\r\n} else if (first) {\r\npadding = ((*(priv->rxringtail+3))&(0x04000000))>>26;\r\nif (padding)\r\nlen -= 2;\r\n} else {\r\npadding = 0;\r\n}\r\npadding = 0;\r\npriv->rx_prevlen += len;\r\nif (priv->rx_prevlen > MAX_FRAG_THRESHOLD + 100) {\r\nif (!priv->rx_skb_complete)\r\ndev_kfree_skb_any(priv->rx_skb);\r\npriv->rx_skb_complete = 1;\r\n}\r\nsignal = (unsigned char)(((*(priv->rxringtail+3)) & (0x00ff0000))>>16);\r\nsignal = (signal & 0xfe) >> 1;\r\nquality = (unsigned char)((*(priv->rxringtail+3)) & (0xff));\r\nstats.mac_time[0] = *(priv->rxringtail+1);\r\nstats.mac_time[1] = *(priv->rxringtail+2);\r\nrxpower = ((char)(((*(priv->rxringtail+4)) & (0x00ff0000))>>16))/2 - 42;\r\nRSSI = ((u8)(((*(priv->rxringtail+3)) & (0x0000ff00))>>8)) & (0x7f);\r\nrate = ((*(priv->rxringtail)) &\r\n((1<<23)|(1<<22)|(1<<21)|(1<<20)))>>20;\r\nstats.rate = rtl8180_rate2rate(rate);\r\nAntenna = (((*(priv->rxringtail+3)) & (0x00008000)) == 0) ? 0 : 1;\r\nif (!rtl8180_IsWirelessBMode(stats.rate)) {\r\nRxAGC_dBm = rxpower+1;\r\n} else {\r\nRxAGC_dBm = signal;\r\nLNA = (u8) (RxAGC_dBm & 0x60) >> 5;\r\nBB = (u8) (RxAGC_dBm & 0x1F);\r\nRxAGC_dBm = -(LNA_gain[LNA] + (BB*2));\r\nRxAGC_dBm += 4;\r\n}\r\nif (RxAGC_dBm & 0x80)\r\nRXAGC = ~(RxAGC_dBm)+1;\r\nbCckRate = rtl8180_IsWirelessBMode(stats.rate);\r\nif (!rtl8180_IsWirelessBMode(stats.rate)) {\r\nif (RXAGC > 90)\r\nRXAGC = 90;\r\nelse if (RXAGC < 25)\r\nRXAGC = 25;\r\nRXAGC = (90-RXAGC)*100/65;\r\n} else {\r\nif (RXAGC > 95)\r\nRXAGC = 95;\r\nelse if (RXAGC < 30)\r\nRXAGC = 30;\r\nRXAGC = (95-RXAGC)*100/65;\r\n}\r\npriv->SignalStrength = (u8)RXAGC;\r\npriv->RecvSignalPower = RxAGC_dBm;\r\npriv->RxPower = rxpower;\r\npriv->RSSI = RSSI;\r\nif (quality >= 127)\r\nquality = 1;\r\nelse if (quality < 27)\r\nquality = 100;\r\nelse\r\nquality = 127 - quality;\r\npriv->SignalQuality = quality;\r\nstats.signal = (u8)quality;\r\nstats.signalstrength = RXAGC;\r\nif (stats.signalstrength > 100)\r\nstats.signalstrength = 100;\r\nstats.signalstrength = (stats.signalstrength * 70)/100 + 30;\r\nstats.rssi = priv->wstats.qual.qual = priv->SignalQuality;\r\nstats.noise = priv->wstats.qual.noise = 100 - priv->wstats.qual.qual;\r\nbHwError = (((*(priv->rxringtail)) & (0x00000fff)) == 4080) |\r\n(((*(priv->rxringtail)) & (0x04000000)) != 0) |\r\n(((*(priv->rxringtail)) & (0x08000000)) != 0) |\r\n(((~(*(priv->rxringtail))) & (0x10000000)) != 0) |\r\n(((~(*(priv->rxringtail))) & (0x20000000)) != 0);\r\nbCRC = ((*(priv->rxringtail)) & (0x00002000)) >> 13;\r\nbICV = ((*(priv->rxringtail)) & (0x00001000)) >> 12;\r\nhdr = (struct ieee80211_hdr_4addr *)priv->rxbuffer->buf;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nif (IEEE80211_FTYPE_CTL != type &&\r\n!bHwError && !bCRC && !bICV &&\r\neqMacAddr(priv->ieee80211->current_network.bssid,\r\nfc & IEEE80211_FCTL_TODS ? hdr->addr1 :\r\nfc & IEEE80211_FCTL_FROMDS ? hdr->addr2 :\r\nhdr->addr3)) {\r\nPerformUndecoratedSignalSmoothing8185(priv, bCckRate);\r\nSignalStrengthIndex = NetgearSignalStrengthTranslate(\r\npriv->LastSignalStrengthInPercent,\r\npriv->SignalStrength);\r\npriv->LastSignalStrengthInPercent = SignalStrengthIndex;\r\npriv->Stats_SignalStrength = TranslateToDbm8185((u8)SignalStrengthIndex);\r\npriv->Stats_SignalQuality = (long)(priv->Stats_SignalQuality * 5 + (long)priv->SignalQuality + 5) / 6;\r\npriv->Stats_RecvSignalPower = (long)(priv->Stats_RecvSignalPower * 5 + priv->RecvSignalPower - 1) / 6;\r\npriv->LastRxPktAntenna = Antenna ? 1 : 0;\r\nSwAntennaDiversityRxOk8185(dev, priv->SignalStrength);\r\n}\r\nif (first) {\r\nif (!priv->rx_skb_complete) {\r\ndev_kfree_skb_any(priv->rx_skb);\r\npriv->stats.rxnolast++;\r\n}\r\nif (priv->prism_hdr && priv->ieee80211->iw_mode == IW_MODE_MONITOR) {\r\n} else {\r\npriv->rx_skb = dev_alloc_skb(len+2);\r\nif (!priv->rx_skb)\r\ngoto drop;\r\n}\r\npriv->rx_skb_complete = 0;\r\npriv->rx_skb->dev = dev;\r\n} else {\r\nif (!priv->rx_skb_complete) {\r\ntmp_skb = dev_alloc_skb(priv->rx_skb->len+len+2);\r\nif (!tmp_skb)\r\ngoto drop;\r\ntmp_skb->dev = dev;\r\nmemcpy(skb_put(tmp_skb, priv->rx_skb->len),\r\npriv->rx_skb->data,\r\npriv->rx_skb->len);\r\ndev_kfree_skb_any(priv->rx_skb);\r\npriv->rx_skb = tmp_skb;\r\n}\r\n}\r\nif (!priv->rx_skb_complete) {\r\nif (padding) {\r\nmemcpy(skb_put(priv->rx_skb, len),\r\n(((unsigned char *)priv->rxbuffer->buf) + 2), len);\r\n} else {\r\nmemcpy(skb_put(priv->rx_skb, len),\r\npriv->rxbuffer->buf, len);\r\n}\r\n}\r\nif (last && !priv->rx_skb_complete) {\r\nif (priv->rx_skb->len > 4)\r\nskb_trim(priv->rx_skb, priv->rx_skb->len-4);\r\nif (!ieee80211_rtl_rx(priv->ieee80211,\r\npriv->rx_skb, &stats))\r\ndev_kfree_skb_any(priv->rx_skb);\r\npriv->rx_skb_complete = 1;\r\n}\r\npci_dma_sync_single_for_device(priv->pdev,\r\npriv->rxbuffer->dma,\r\npriv->rxbuffersize * \\r\nsizeof(u8),\r\nPCI_DMA_FROMDEVICE);\r\ndrop:\r\n*(priv->rxringtail+2) = priv->rxbuffer->dma;\r\n*(priv->rxringtail) = *(priv->rxringtail) & ~0xfff;\r\n*(priv->rxringtail) =\r\n*(priv->rxringtail) | priv->rxbuffersize;\r\n*(priv->rxringtail) =\r\n*(priv->rxringtail) | (1<<31);\r\npriv->rxringtail += rx_desc_size;\r\nif (priv->rxringtail >=\r\n(priv->rxring)+(priv->rxringcount)*rx_desc_size)\r\npriv->rxringtail = priv->rxring;\r\npriv->rxbuffer = (priv->rxbuffer->next);\r\n}\r\n}\r\nvoid rtl8180_dma_kick(struct net_device *dev, int priority)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\nwrite_nic_byte(dev, TX_DMA_POLLING,\r\n(1 << (priority + 1)) | priv->dma_poll_mask);\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\nforce_pci_posting(dev);\r\n}\r\nvoid rtl8180_data_hard_stop(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\npriv->dma_poll_stop_mask |= TPPOLLSTOP_AC_VIQ;\r\nwrite_nic_byte(dev, TPPollStop, priv->dma_poll_stop_mask);\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\n}\r\nvoid rtl8180_data_hard_resume(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\npriv->dma_poll_stop_mask &= ~(TPPOLLSTOP_AC_VIQ);\r\nwrite_nic_byte(dev, TPPollStop, priv->dma_poll_stop_mask);\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\n}\r\nvoid rtl8180_hard_data_xmit(struct sk_buff *skb, struct net_device *dev, int\r\nrate) {\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nint mode;\r\nstruct ieee80211_hdr_3addr *h = (struct ieee80211_hdr_3addr *) skb->data;\r\nshort morefrag = (h->frame_control) & IEEE80211_FCTL_MOREFRAGS;\r\nunsigned long flags;\r\nint priority;\r\nmode = priv->ieee80211->iw_mode;\r\nrate = ieeerate2rtlrate(rate);\r\npriority = AC2Q(skb->priority);\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nif (priv->ieee80211->bHwRadioOff) {\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nreturn;\r\n}\r\nif (!check_nic_enought_desc(dev, priority)) {\r\nDMESGW("Error: no descriptor left by previous TX (avail %d) ",\r\nget_curr_tx_free_desc(dev, priority));\r\nieee80211_rtl_stop_queue(priv->ieee80211);\r\n}\r\nrtl8180_tx(dev, skb->data, skb->len, priority, morefrag, 0, rate);\r\nif (!check_nic_enought_desc(dev, priority))\r\nieee80211_rtl_stop_queue(priv->ieee80211);\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\n}\r\nint rtl8180_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nunsigned long flags;\r\nint priority;\r\npriority = MANAGE_PRIORITY;\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nif (priv->ieee80211->bHwRadioOff) {\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nrtl8180_tx(dev, skb->data, skb->len, priority,\r\n0, 0, ieeerate2rtlrate(priv->ieee80211->basic_rate));\r\npriv->ieee80211->stats.tx_bytes += skb->len;\r\npriv->ieee80211->stats.tx_packets++;\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nu16 rtl8180_len2duration(u32 len, short rate, short *ext)\r\n{\r\nu16 duration;\r\nu16 drift;\r\n*ext = 0;\r\nswitch (rate) {\r\ncase 0:\r\n*ext = 0;\r\nduration = ((len+4)<<4) / 0x2;\r\ndrift = ((len+4)<<4) % 0x2;\r\nif (drift == 0)\r\nbreak;\r\nduration++;\r\nbreak;\r\ncase 1:\r\n*ext = 0;\r\nduration = ((len+4)<<4) / 0x4;\r\ndrift = ((len+4)<<4) % 0x4;\r\nif (drift == 0)\r\nbreak;\r\nduration++;\r\nbreak;\r\ncase 2:\r\n*ext = 0;\r\nduration = ((len+4)<<4) / 0xb;\r\ndrift = ((len+4)<<4) % 0xb;\r\nif (drift == 0)\r\nbreak;\r\nduration++;\r\nbreak;\r\ndefault:\r\ncase 3:\r\n*ext = 0;\r\nduration = ((len+4)<<4) / 0x16;\r\ndrift = ((len+4)<<4) % 0x16;\r\nif (drift == 0)\r\nbreak;\r\nduration++;\r\nif (drift > 6)\r\nbreak;\r\n*ext = 1;\r\nbreak;\r\n}\r\nreturn duration;\r\n}\r\nvoid rtl8180_prepare_beacon(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct sk_buff *skb;\r\nu16 word = read_nic_word(dev, BcnItv);\r\nword &= ~BcnItv_BcnItv;\r\nword |= cpu_to_le16(priv->ieee80211->current_network.beacon_interval);\r\nwrite_nic_word(dev, BcnItv, word);\r\nskb = ieee80211_get_beacon(priv->ieee80211);\r\nif (skb) {\r\nrtl8180_tx(dev, skb->data, skb->len, BEACON_PRIORITY,\r\n0, 0, ieeerate2rtlrate(priv->ieee80211->basic_rate));\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nshort rtl8180_tx(struct net_device *dev, u8* txbuf, int len, int priority,\r\nshort morefrag, short descfrag, int rate)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu32 *tail, *temp_tail;\r\nu32 *begin;\r\nu32 *buf;\r\nint i;\r\nint remain;\r\nint buflen;\r\nint count;\r\nu16 duration;\r\nshort ext;\r\nstruct buffer *buflist;\r\nstruct ieee80211_hdr_3addr *frag_hdr = (struct ieee80211_hdr_3addr *)txbuf;\r\nu8 dest[ETH_ALEN];\r\nu8 bUseShortPreamble = 0;\r\nu8 bCTSEnable = 0;\r\nu8 bRTSEnable = 0;\r\nu16 Duration = 0;\r\nu16 RtsDur = 0;\r\nu16 ThisFrameTime = 0;\r\nu16 TxDescDuration = 0;\r\nu8 ownbit_flag = false;\r\nswitch (priority) {\r\ncase MANAGE_PRIORITY:\r\ntail = priv->txmapringtail;\r\nbegin = priv->txmapring;\r\nbuflist = priv->txmapbufstail;\r\ncount = priv->txringcount;\r\nbreak;\r\ncase BK_PRIORITY:\r\ntail = priv->txbkpringtail;\r\nbegin = priv->txbkpring;\r\nbuflist = priv->txbkpbufstail;\r\ncount = priv->txringcount;\r\nbreak;\r\ncase BE_PRIORITY:\r\ntail = priv->txbepringtail;\r\nbegin = priv->txbepring;\r\nbuflist = priv->txbepbufstail;\r\ncount = priv->txringcount;\r\nbreak;\r\ncase VI_PRIORITY:\r\ntail = priv->txvipringtail;\r\nbegin = priv->txvipring;\r\nbuflist = priv->txvipbufstail;\r\ncount = priv->txringcount;\r\nbreak;\r\ncase VO_PRIORITY:\r\ntail = priv->txvopringtail;\r\nbegin = priv->txvopring;\r\nbuflist = priv->txvopbufstail;\r\ncount = priv->txringcount;\r\nbreak;\r\ncase HI_PRIORITY:\r\ntail = priv->txhpringtail;\r\nbegin = priv->txhpring;\r\nbuflist = priv->txhpbufstail;\r\ncount = priv->txringcount;\r\nbreak;\r\ncase BEACON_PRIORITY:\r\ntail = priv->txbeaconringtail;\r\nbegin = priv->txbeaconring;\r\nbuflist = priv->txbeaconbufstail;\r\ncount = priv->txbeaconcount;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nmemcpy(&dest, frag_hdr->addr1, ETH_ALEN);\r\nif (is_multicast_ether_addr(dest)) {\r\nDuration = 0;\r\nRtsDur = 0;\r\nbRTSEnable = 0;\r\nbCTSEnable = 0;\r\nThisFrameTime = ComputeTxTime(len + sCrcLng, rtl8180_rate2rate(rate),\r\n0, bUseShortPreamble);\r\nTxDescDuration = ThisFrameTime;\r\n} else {\r\nu16 AckTime;\r\npriv->NumTxUnicast++;\r\nAckTime = ComputeTxTime(14, 10, 0, 0);\r\nif (((len + sCrcLng) > priv->rts) && priv->rts) {\r\nu16 RtsTime, CtsTime;\r\nbRTSEnable = 1;\r\nbCTSEnable = 0;\r\nRtsTime = ComputeTxTime(sAckCtsLng/8, priv->ieee80211->basic_rate, 0, 0);\r\nCtsTime = ComputeTxTime(14, 10, 0, 0);\r\nThisFrameTime = ComputeTxTime(len + sCrcLng,\r\nrtl8180_rate2rate(rate),\r\n0,\r\nbUseShortPreamble);\r\nRtsDur = CtsTime + ThisFrameTime + AckTime + 3*aSifsTime;\r\nTxDescDuration = RtsTime + RtsDur;\r\n} else {\r\nbCTSEnable = 0;\r\nbRTSEnable = 0;\r\nRtsDur = 0;\r\nThisFrameTime = ComputeTxTime(len + sCrcLng, rtl8180_rate2rate(rate),\r\n0, bUseShortPreamble);\r\nTxDescDuration = ThisFrameTime + aSifsTime + AckTime;\r\n}\r\nif (!(frag_hdr->frame_control & IEEE80211_FCTL_MOREFRAGS)) {\r\nDuration = aSifsTime + AckTime;\r\n} else {\r\nu16 NextFragTime;\r\nNextFragTime = ComputeTxTime(len + sCrcLng,\r\nrtl8180_rate2rate(rate),\r\n0,\r\nbUseShortPreamble);\r\nDuration = NextFragTime + 3*aSifsTime + 2*AckTime;\r\n}\r\n}\r\nfrag_hdr->duration_id = Duration;\r\nbuflen = priv->txbuffsize;\r\nremain = len;\r\ntemp_tail = tail;\r\nwhile (remain != 0) {\r\nmb();\r\nif (!buflist) {\r\nDMESGE("TX buffer error, cannot TX frames. pri %d.", priority);\r\nreturn -1;\r\n}\r\nbuf = buflist->buf;\r\nif ((*tail & (1 << 31)) && (priority != BEACON_PRIORITY)) {\r\nDMESGW("No more TX desc, returning %x of %x",\r\nremain, len);\r\npriv->stats.txrdu++;\r\nreturn remain;\r\n}\r\n*tail = 0;\r\n*(tail+1) = 0;\r\n*(tail+3) = 0;\r\n*(tail+5) = 0;\r\n*(tail+6) = 0;\r\n*(tail+7) = 0;\r\n*tail |= (1<<15);\r\nif (remain == len && !descfrag) {\r\nownbit_flag = false;\r\n*tail = *tail | (1<<29) ;\r\n*tail = *tail | (len);\r\n} else {\r\nownbit_flag = true;\r\n}\r\nfor (i = 0; i < buflen && remain > 0; i++, remain--) {\r\n((u8 *)buf)[i] = txbuf[i];\r\nif (remain == 4 && i+4 >= buflen)\r\nbreak;\r\n}\r\ntxbuf = txbuf + i;\r\n*(tail+3) = *(tail+3) & ~0xfff;\r\n*(tail+3) = *(tail+3) | i;\r\nif (priv->ieee80211->current_network.capability&WLAN_CAPABILITY_SHORT_PREAMBLE)\r\nif (priv->plcp_preamble_mode == 1 && rate != 0)\r\n;\r\nif (bCTSEnable)\r\n*tail |= (1<<18);\r\nif (bRTSEnable) {\r\n*tail |= ((ieeerate2rtlrate(priv->ieee80211->basic_rate))<<19);\r\n*tail |= (1<<23);\r\n*(tail+1) |= (RtsDur&0xffff);\r\n}\r\n*(tail+3) |= ((TxDescDuration&0xffff)<<16);\r\n*(tail+5) |= (11<<8);\r\n*tail = *tail | ((rate&0xf) << 24);\r\nif (!priv->hw_plcp_len) {\r\nduration = rtl8180_len2duration(len, rate, &ext);\r\n*(tail+1) = *(tail+1) | ((duration & 0x7fff)<<16);\r\nif (ext)\r\n*(tail+1) = *(tail+1) | (1<<31);\r\n}\r\nif (morefrag)\r\n*tail = (*tail) | (1<<17);\r\nif (!remain)\r\n*tail = (*tail) | (1<<28);\r\n*(tail+5) = *(tail+5)|(2<<27);\r\n*(tail+7) = *(tail+7)|(1<<4);\r\nwmb();\r\nif (ownbit_flag)\r\n*tail = *tail | (1<<31);\r\nif ((tail - begin)/8 == count-1)\r\ntail = begin;\r\nelse\r\ntail = tail+8;\r\nbuflist = buflist->next;\r\nmb();\r\nswitch (priority) {\r\ncase MANAGE_PRIORITY:\r\npriv->txmapringtail = tail;\r\npriv->txmapbufstail = buflist;\r\nbreak;\r\ncase BK_PRIORITY:\r\npriv->txbkpringtail = tail;\r\npriv->txbkpbufstail = buflist;\r\nbreak;\r\ncase BE_PRIORITY:\r\npriv->txbepringtail = tail;\r\npriv->txbepbufstail = buflist;\r\nbreak;\r\ncase VI_PRIORITY:\r\npriv->txvipringtail = tail;\r\npriv->txvipbufstail = buflist;\r\nbreak;\r\ncase VO_PRIORITY:\r\npriv->txvopringtail = tail;\r\npriv->txvopbufstail = buflist;\r\nbreak;\r\ncase HI_PRIORITY:\r\npriv->txhpringtail = tail;\r\npriv->txhpbufstail = buflist;\r\nbreak;\r\ncase BEACON_PRIORITY:\r\nbreak;\r\n}\r\n}\r\n*temp_tail = *temp_tail | (1<<31);\r\nrtl8180_dma_kick(dev, priority);\r\nreturn 0;\r\n}\r\nvoid rtl8180_link_change(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu16 beacon_interval;\r\nstruct ieee80211_network *net = &priv->ieee80211->current_network;\r\nrtl8180_update_msr(dev);\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\nwrite_nic_dword(dev, BSSID, ((u32 *)net->bssid)[0]);\r\nwrite_nic_word(dev, BSSID+4, ((u16 *)net->bssid)[2]);\r\nbeacon_interval = read_nic_dword(dev, BEACON_INTERVAL);\r\nbeacon_interval &= ~BEACON_INTERVAL_MASK;\r\nbeacon_interval |= net->beacon_interval;\r\nwrite_nic_dword(dev, BEACON_INTERVAL, beacon_interval);\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\nrtl8180_set_chan(dev, priv->chan);\r\n}\r\nvoid rtl8180_rq_tx_ack(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nwrite_nic_byte(dev, CONFIG4, read_nic_byte(dev, CONFIG4) | CONFIG4_PWRMGT);\r\npriv->ack_tx_to_ieee = 1;\r\n}\r\nshort rtl8180_is_tx_queue_empty(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu32 *d;\r\nfor (d = priv->txmapring;\r\nd < priv->txmapring + priv->txringcount; d += 8)\r\nif (*d & (1<<31))\r\nreturn 0;\r\nfor (d = priv->txbkpring;\r\nd < priv->txbkpring + priv->txringcount; d += 8)\r\nif (*d & (1<<31))\r\nreturn 0;\r\nfor (d = priv->txbepring;\r\nd < priv->txbepring + priv->txringcount; d += 8)\r\nif (*d & (1<<31))\r\nreturn 0;\r\nfor (d = priv->txvipring;\r\nd < priv->txvipring + priv->txringcount; d += 8)\r\nif (*d & (1<<31))\r\nreturn 0;\r\nfor (d = priv->txvopring;\r\nd < priv->txvopring + priv->txringcount; d += 8)\r\nif (*d & (1<<31))\r\nreturn 0;\r\nfor (d = priv->txhpring;\r\nd < priv->txhpring + priv->txringcount; d += 8)\r\nif (*d & (1<<31))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid rtl8180_hw_wakeup(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nspin_lock_irqsave(&priv->ps_lock, flags);\r\nwrite_nic_byte(dev, CONFIG4, read_nic_byte(dev, CONFIG4) & ~CONFIG4_PWRMGT);\r\nif (priv->rf_wakeup)\r\npriv->rf_wakeup(dev);\r\nspin_unlock_irqrestore(&priv->ps_lock, flags);\r\n}\r\nvoid rtl8180_hw_sleep_down(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nspin_lock_irqsave(&priv->ps_lock, flags);\r\nif (priv->rf_sleep)\r\npriv->rf_sleep(dev);\r\nspin_unlock_irqrestore(&priv->ps_lock, flags);\r\n}\r\nvoid rtl8180_hw_sleep(struct net_device *dev, u32 th, u32 tl)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu32 rb = jiffies;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->ps_lock, flags);\r\ntl -= MSECS(4+16+7);\r\nif (((tl >= rb) && (tl-rb) <= MSECS(MIN_SLEEP_TIME))\r\n|| ((rb > tl) && (rb-tl) < MSECS(MIN_SLEEP_TIME))) {\r\nspin_unlock_irqrestore(&priv->ps_lock, flags);\r\nprintk("too short to sleep\n");\r\nreturn;\r\n}\r\n{\r\nu32 tmp = (tl > rb) ? (tl-rb) : (rb-tl);\r\npriv->DozePeriodInPast2Sec += jiffies_to_msecs(tmp);\r\nqueue_delayed_work(priv->ieee80211->wq, &priv->ieee80211->hw_wakeup_wq, tmp);\r\n}\r\nif (((tl > rb) && ((tl-rb) > MSECS(MAX_SLEEP_TIME))) ||\r\n((tl < rb) && ((rb-tl) > MSECS(MAX_SLEEP_TIME)))) {\r\nspin_unlock_irqrestore(&priv->ps_lock, flags);\r\nreturn;\r\n}\r\nqueue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->hw_sleep_wq);\r\nspin_unlock_irqrestore(&priv->ps_lock, flags);\r\n}\r\nvoid rtl8180_wmm_param_update(struct work_struct *work)\r\n{\r\nstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, wmm_param_update_wq);\r\nstruct net_device *dev = ieee->dev;\r\nu8 *ac_param = (u8 *)(ieee->current_network.wmm_param);\r\nu8 mode = ieee->current_network.mode;\r\nAC_CODING eACI;\r\nAC_PARAM AcParam;\r\nPAC_PARAM pAcParam;\r\nu8 i;\r\nif (!ieee->current_network.QoS_Enable) {\r\nAcParam.longData = 0;\r\nAcParam.f.AciAifsn.f.AIFSN = 2;\r\nAcParam.f.AciAifsn.f.ACM = 0;\r\nAcParam.f.Ecw.f.ECWmin = 3;\r\nAcParam.f.Ecw.f.ECWmax = 7;\r\nAcParam.f.TXOPLimit = 0;\r\nfor (eACI = 0; eACI < AC_MAX; eACI++) {\r\nAcParam.f.AciAifsn.f.ACI = (u8)eACI;\r\n{\r\nu8 u1bAIFS;\r\nu32 u4bAcParam;\r\npAcParam = (PAC_PARAM)(&AcParam);\r\nu1bAIFS = pAcParam->f.AciAifsn.f.AIFSN * (((mode&IEEE_G) == IEEE_G) ? 9 : 20) + aSifsTime;\r\nu4bAcParam = ((((u32)(pAcParam->f.TXOPLimit))<<AC_PARAM_TXOP_LIMIT_OFFSET)|\r\n(((u32)(pAcParam->f.Ecw.f.ECWmax))<<AC_PARAM_ECW_MAX_OFFSET)|\r\n(((u32)(pAcParam->f.Ecw.f.ECWmin))<<AC_PARAM_ECW_MIN_OFFSET)|\r\n(((u32)u1bAIFS) << AC_PARAM_AIFS_OFFSET));\r\nswitch (eACI) {\r\ncase AC1_BK:\r\nwrite_nic_dword(dev, AC_BK_PARAM, u4bAcParam);\r\nbreak;\r\ncase AC0_BE:\r\nwrite_nic_dword(dev, AC_BE_PARAM, u4bAcParam);\r\nbreak;\r\ncase AC2_VI:\r\nwrite_nic_dword(dev, AC_VI_PARAM, u4bAcParam);\r\nbreak;\r\ncase AC3_VO:\r\nwrite_nic_dword(dev, AC_VO_PARAM, u4bAcParam);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "SetHwReg8185():invalid ACI: %d!\n", eACI);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nfor (i = 0; i < AC_MAX; i++) {\r\npAcParam = (AC_PARAM *)ac_param;\r\n{\r\nAC_CODING eACI;\r\nu8 u1bAIFS;\r\nu32 u4bAcParam;\r\neACI = pAcParam->f.AciAifsn.f.ACI;\r\nu1bAIFS = pAcParam->f.AciAifsn.f.AIFSN * (((mode&IEEE_G) == IEEE_G) ? 9 : 20) + aSifsTime;\r\nu4bAcParam = ((((u32)(pAcParam->f.TXOPLimit)) << AC_PARAM_TXOP_LIMIT_OFFSET) |\r\n(((u32)(pAcParam->f.Ecw.f.ECWmax)) << AC_PARAM_ECW_MAX_OFFSET) |\r\n(((u32)(pAcParam->f.Ecw.f.ECWmin)) << AC_PARAM_ECW_MIN_OFFSET) |\r\n(((u32)u1bAIFS) << AC_PARAM_AIFS_OFFSET));\r\nswitch (eACI) {\r\ncase AC1_BK:\r\nwrite_nic_dword(dev, AC_BK_PARAM, u4bAcParam);\r\nbreak;\r\ncase AC0_BE:\r\nwrite_nic_dword(dev, AC_BE_PARAM, u4bAcParam);\r\nbreak;\r\ncase AC2_VI:\r\nwrite_nic_dword(dev, AC_VI_PARAM, u4bAcParam);\r\nbreak;\r\ncase AC3_VO:\r\nwrite_nic_dword(dev, AC_VO_PARAM, u4bAcParam);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "SetHwReg8185(): invalid ACI: %d !\n", eACI);\r\nbreak;\r\n}\r\n}\r\nac_param += (sizeof(AC_PARAM));\r\n}\r\n}\r\nvoid watch_dog_adaptive(unsigned long data)\r\n{\r\nstruct r8180_priv* priv = ieee80211_priv((struct net_device *)data);\r\nif (!priv->up) {\r\nDMESG("<----watch_dog_adaptive():driver is not up!\n");\r\nreturn;\r\n}\r\nif (CheckHighPower((struct net_device *)data))\r\nqueue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->tx_pw_wq);\r\nif (CheckTxPwrTracking((struct net_device *)data))\r\nTxPwrTracking87SE((struct net_device *)data);\r\nif (CheckDig((struct net_device *)data) == true)\r\nqueue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->hw_dig_wq);\r\nrtl8180_watch_dog((struct net_device *)data);\r\nqueue_work(priv->ieee80211->wq, (void *)&priv->ieee80211->GPIOChangeRFWorkItem);\r\npriv->watch_dog_timer.expires = jiffies + MSECS(IEEE80211_WATCH_DOG_TIME);\r\nadd_timer(&priv->watch_dog_timer);\r\n}\r\nstatic void rtl8180_set_channel_map(u8 channel_plan, struct ieee80211_device *ieee)\r\n{\r\nint i;\r\nieee->MinPassiveChnlNum = MAX_CHANNEL_NUMBER+1;\r\nieee->IbssStartChnl = 0;\r\nswitch (channel_plan) {\r\ncase COUNTRY_CODE_FCC:\r\ncase COUNTRY_CODE_IC:\r\ncase COUNTRY_CODE_ETSI:\r\ncase COUNTRY_CODE_SPAIN:\r\ncase COUNTRY_CODE_FRANCE:\r\ncase COUNTRY_CODE_MKK:\r\ncase COUNTRY_CODE_MKK1:\r\ncase COUNTRY_CODE_ISRAEL:\r\ncase COUNTRY_CODE_TELEC:\r\n{\r\nDot11d_Init(ieee);\r\nieee->bGlobalDomain = false;\r\nif (ChannelPlan[channel_plan].Len != 0) {\r\nmemset(GET_DOT11D_INFO(ieee)->channel_map, 0, sizeof(GET_DOT11D_INFO(ieee)->channel_map));\r\nfor (i = 0; i < ChannelPlan[channel_plan].Len; i++) {\r\nif (ChannelPlan[channel_plan].Channel[i] <= 14)\r\nGET_DOT11D_INFO(ieee)->channel_map[ChannelPlan[channel_plan].Channel[i]] = 1;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase COUNTRY_CODE_GLOBAL_DOMAIN:\r\n{\r\nGET_DOT11D_INFO(ieee)->bEnabled = 0;\r\nDot11d_Reset(ieee);\r\nieee->bGlobalDomain = true;\r\nbreak;\r\n}\r\ncase COUNTRY_CODE_WORLD_WIDE_13_INDEX:\r\n{\r\nieee->MinPassiveChnlNum = 12;\r\nieee->IbssStartChnl = 10;\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nDot11d_Init(ieee);\r\nieee->bGlobalDomain = false;\r\nmemset(GET_DOT11D_INFO(ieee)->channel_map, 0, sizeof(GET_DOT11D_INFO(ieee)->channel_map));\r\nfor (i = 1; i <= 14; i++)\r\nGET_DOT11D_INFO(ieee)->channel_map[i] = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void rtl8180_statistics_init(struct Stats *pstats)\r\n{\r\nmemset(pstats, 0, sizeof(struct Stats));\r\n}\r\nstatic void rtl8180_link_detect_init(plink_detect_t plink_detect)\r\n{\r\nmemset(plink_detect, 0, sizeof(link_detect_t));\r\nplink_detect->SlotNum = DEFAULT_SLOT_NUM;\r\n}\r\nstatic void rtl8187se_eeprom_register_read(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct net_device *dev = eeprom->data;\r\nu8 reg = read_nic_byte(dev, EPROM_CMD);\r\neeprom->reg_data_in = reg & RTL818X_EEPROM_CMD_WRITE;\r\neeprom->reg_data_out = reg & RTL818X_EEPROM_CMD_READ;\r\neeprom->reg_data_clock = reg & RTL818X_EEPROM_CMD_CK;\r\neeprom->reg_chip_select = reg & RTL818X_EEPROM_CMD_CS;\r\n}\r\nstatic void rtl8187se_eeprom_register_write(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct net_device *dev = eeprom->data;\r\nu8 reg = 2 << 6;\r\nif (eeprom->reg_data_in)\r\nreg |= RTL818X_EEPROM_CMD_WRITE;\r\nif (eeprom->reg_data_out)\r\nreg |= RTL818X_EEPROM_CMD_READ;\r\nif (eeprom->reg_data_clock)\r\nreg |= RTL818X_EEPROM_CMD_CK;\r\nif (eeprom->reg_chip_select)\r\nreg |= RTL818X_EEPROM_CMD_CS;\r\nwrite_nic_byte(dev, EPROM_CMD, reg);\r\nread_nic_byte(dev, EPROM_CMD);\r\nudelay(10);\r\n}\r\nshort rtl8180_init(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu16 word;\r\nu16 version;\r\nu32 usValue;\r\nu16 tmpu16;\r\nint i, j;\r\nstruct eeprom_93cx6 eeprom;\r\nu16 eeprom_val;\r\neeprom.data = dev;\r\neeprom.register_read = rtl8187se_eeprom_register_read;\r\neeprom.register_write = rtl8187se_eeprom_register_write;\r\neeprom.width = PCI_EEPROM_WIDTH_93C46;\r\neeprom_93cx6_read(&eeprom, EEPROM_COUNTRY_CODE>>1, &eeprom_val);\r\npriv->channel_plan = eeprom_val & 0xFF;\r\nif (priv->channel_plan > COUNTRY_CODE_GLOBAL_DOMAIN) {\r\nprintk("rtl8180_init:Error channel plan! Set to default.\n");\r\npriv->channel_plan = 0;\r\n}\r\nDMESG("Channel plan is %d\n", priv->channel_plan);\r\nrtl8180_set_channel_map(priv->channel_plan, priv->ieee80211);\r\npriv->txbuffsize = 2048;\r\npriv->txringcount = 32;\r\npriv->rxbuffersize = 2048;\r\npriv->rxringcount = 64;\r\npriv->txbeaconcount = 2;\r\npriv->rx_skb_complete = 1;\r\npriv->RFChangeInProgress = false;\r\npriv->SetRFPowerStateInProgress = false;\r\npriv->RFProgType = 0;\r\npriv->bInHctTest = false;\r\npriv->irq_enabled = 0;\r\nrtl8180_statistics_init(&priv->stats);\r\nrtl8180_link_detect_init(&priv->link_detect);\r\npriv->ack_tx_to_ieee = 0;\r\npriv->ieee80211->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;\r\npriv->ieee80211->iw_mode = IW_MODE_INFRA;\r\npriv->ieee80211->softmac_features = IEEE_SOFTMAC_SCAN |\r\nIEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ |\r\nIEEE_SOFTMAC_PROBERS | IEEE_SOFTMAC_TX_QUEUE;\r\npriv->ieee80211->active_scan = 1;\r\npriv->ieee80211->rate = 110;\r\npriv->ieee80211->modulation = IEEE80211_CCK_MODULATION;\r\npriv->ieee80211->host_encrypt = 1;\r\npriv->ieee80211->host_decrypt = 1;\r\npriv->ieee80211->sta_wake_up = rtl8180_hw_wakeup;\r\npriv->ieee80211->ps_request_tx_ack = rtl8180_rq_tx_ack;\r\npriv->ieee80211->enter_sleep_state = rtl8180_hw_sleep;\r\npriv->ieee80211->ps_is_queue_empty = rtl8180_is_tx_queue_empty;\r\npriv->hw_wep = hwwep;\r\npriv->prism_hdr = 0;\r\npriv->dev = dev;\r\npriv->retry_rts = DEFAULT_RETRY_RTS;\r\npriv->retry_data = DEFAULT_RETRY_DATA;\r\npriv->RFChangeInProgress = false;\r\npriv->SetRFPowerStateInProgress = false;\r\npriv->RFProgType = 0;\r\npriv->bInHctTest = false;\r\npriv->bInactivePs = true;\r\npriv->ieee80211->bInactivePs = priv->bInactivePs;\r\npriv->bSwRfProcessing = false;\r\npriv->eRFPowerState = eRfOff;\r\npriv->RfOffReason = 0;\r\npriv->LedStrategy = SW_LED_MODE0;\r\npriv->TxPollingTimes = 0;\r\npriv->bLeisurePs = true;\r\npriv->dot11PowerSaveMode = eActive;\r\npriv->AdMinCheckPeriod = 5;\r\npriv->AdMaxCheckPeriod = 10;\r\npriv->AdMaxRxSsThreshold = 30;\r\npriv->AdRxSsThreshold = 20;\r\npriv->AdCheckPeriod = priv->AdMinCheckPeriod;\r\npriv->AdTickCount = 0;\r\npriv->AdRxSignalStrength = -1;\r\npriv->RegSwAntennaDiversityMechanism = 0;\r\npriv->RegDefaultAntenna = 0;\r\npriv->SignalStrength = 0;\r\npriv->AdRxOkCnt = 0;\r\npriv->CurrAntennaIndex = 0;\r\npriv->AdRxSsBeforeSwitched = 0;\r\ninit_timer(&priv->SwAntennaDiversityTimer);\r\npriv->SwAntennaDiversityTimer.data = (unsigned long)dev;\r\npriv->SwAntennaDiversityTimer.function = (void *)SwAntennaDiversityTimerCallback;\r\npriv->bDigMechanism = 1;\r\npriv->InitialGain = 6;\r\npriv->bXtalCalibration = false;\r\npriv->XtalCal_Xin = 0;\r\npriv->XtalCal_Xout = 0;\r\npriv->bTxPowerTrack = false;\r\npriv->ThermalMeter = 0;\r\npriv->FalseAlarmRegValue = 0;\r\npriv->RegDigOfdmFaUpTh = 0xc;\r\npriv->DIG_NumberFallbackVote = 0;\r\npriv->DIG_NumberUpgradeVote = 0;\r\npriv->LastSignalStrengthInPercent = 0;\r\npriv->Stats_SignalStrength = 0;\r\npriv->LastRxPktAntenna = 0;\r\npriv->SignalQuality = 0;\r\npriv->Stats_SignalQuality = 0;\r\npriv->RecvSignalPower = 0;\r\npriv->Stats_RecvSignalPower = 0;\r\npriv->AdMainAntennaRxOkCnt = 0;\r\npriv->AdAuxAntennaRxOkCnt = 0;\r\npriv->bHWAdSwitched = false;\r\npriv->bRegHighPowerMechanism = true;\r\npriv->RegHiPwrUpperTh = 77;\r\npriv->RegHiPwrLowerTh = 75;\r\npriv->RegRSSIHiPwrUpperTh = 70;\r\npriv->RegRSSIHiPwrLowerTh = 20;\r\npriv->bCurCCKPkt = false;\r\npriv->UndecoratedSmoothedSS = -1;\r\npriv->bToUpdateTxPwr = false;\r\npriv->CurCCKRSSI = 0;\r\npriv->RxPower = 0;\r\npriv->RSSI = 0;\r\npriv->NumTxOkTotal = 0;\r\npriv->NumTxUnicast = 0;\r\npriv->keepAliveLevel = DEFAULT_KEEP_ALIVE_LEVEL;\r\npriv->PowerProfile = POWER_PROFILE_AC;\r\npriv->CurrRetryCnt = 0;\r\npriv->LastRetryCnt = 0;\r\npriv->LastTxokCnt = 0;\r\npriv->LastRxokCnt = 0;\r\npriv->LastRetryRate = 0;\r\npriv->bTryuping = 0;\r\npriv->CurrTxRate = 0;\r\npriv->CurrRetryRate = 0;\r\npriv->TryupingCount = 0;\r\npriv->TryupingCountNoData = 0;\r\npriv->TryDownCountLowData = 0;\r\npriv->LastTxOKBytes = 0;\r\npriv->LastFailTxRate = 0;\r\npriv->LastFailTxRateSS = 0;\r\npriv->FailTxRateCount = 0;\r\npriv->LastTxThroughput = 0;\r\npriv->NumTxOkBytesTotal = 0;\r\npriv->ForcedDataRate = 0;\r\npriv->RegBModeGainStage = 1;\r\npriv->promisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\r\nspin_lock_init(&priv->irq_lock);\r\nspin_lock_init(&priv->irq_th_lock);\r\nspin_lock_init(&priv->tx_lock);\r\nspin_lock_init(&priv->ps_lock);\r\nspin_lock_init(&priv->rf_ps_lock);\r\nsema_init(&priv->wx_sem, 1);\r\nsema_init(&priv->rf_state, 1);\r\nINIT_WORK(&priv->reset_wq, (void *)rtl8180_restart_wq);\r\nINIT_WORK(&priv->tx_irq_wq, (void *)rtl8180_tx_irq_wq);\r\nINIT_DELAYED_WORK(&priv->ieee80211->hw_wakeup_wq,\r\n(void *)rtl8180_hw_wakeup_wq);\r\nINIT_DELAYED_WORK(&priv->ieee80211->hw_sleep_wq,\r\n(void *)rtl8180_hw_sleep_wq);\r\nINIT_WORK(&priv->ieee80211->wmm_param_update_wq,\r\n(void *)rtl8180_wmm_param_update);\r\nINIT_DELAYED_WORK(&priv->ieee80211->rate_adapter_wq,\r\n(void *)rtl8180_rate_adapter);\r\nINIT_DELAYED_WORK(&priv->ieee80211->hw_dig_wq,\r\n(void *)rtl8180_hw_dig_wq);\r\nINIT_DELAYED_WORK(&priv->ieee80211->tx_pw_wq,\r\n(void *)rtl8180_tx_pw_wq);\r\nINIT_DELAYED_WORK(&priv->ieee80211->GPIOChangeRFWorkItem,\r\n(void *) GPIOChangeRFWorkItemCallBack);\r\ntasklet_init(&priv->irq_rx_tasklet,\r\n(void(*)(unsigned long)) rtl8180_irq_rx_tasklet,\r\n(unsigned long)priv);\r\ninit_timer(&priv->watch_dog_timer);\r\npriv->watch_dog_timer.data = (unsigned long)dev;\r\npriv->watch_dog_timer.function = watch_dog_adaptive;\r\ninit_timer(&priv->rateadapter_timer);\r\npriv->rateadapter_timer.data = (unsigned long)dev;\r\npriv->rateadapter_timer.function = timer_rate_adaptive;\r\npriv->RateAdaptivePeriod = RATE_ADAPTIVE_TIMER_PERIOD;\r\npriv->bEnhanceTxPwr = false;\r\npriv->ieee80211->softmac_hard_start_xmit = rtl8180_hard_start_xmit;\r\npriv->ieee80211->set_chan = rtl8180_set_chan;\r\npriv->ieee80211->link_change = rtl8180_link_change;\r\npriv->ieee80211->softmac_data_hard_start_xmit = rtl8180_hard_data_xmit;\r\npriv->ieee80211->data_hard_stop = rtl8180_data_hard_stop;\r\npriv->ieee80211->data_hard_resume = rtl8180_data_hard_resume;\r\npriv->ieee80211->init_wmmparam_flag = 0;\r\npriv->ieee80211->start_send_beacons = rtl8180_start_tx_beacon;\r\npriv->ieee80211->stop_send_beacons = rtl8180_beacon_tx_disable;\r\npriv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;\r\npriv->MWIEnable = 0;\r\npriv->ShortRetryLimit = 7;\r\npriv->LongRetryLimit = 7;\r\npriv->EarlyRxThreshold = 7;\r\npriv->CSMethod = (0x01 << 29);\r\npriv->TransmitConfig = TCR_DurProcMode_OFFSET |\r\n(7<<TCR_MXDMA_OFFSET) |\r\n(priv->ShortRetryLimit<<TCR_SRL_OFFSET) |\r\n(priv->LongRetryLimit<<TCR_LRL_OFFSET) |\r\n(0 ? TCR_SAT : 0);\r\npriv->ReceiveConfig = RCR_AMF | RCR_ADF | RCR_ACF |\r\nRCR_AB | RCR_AM | RCR_APM |\r\n(7<<RCR_MXDMA_OFFSET) |\r\n(priv->EarlyRxThreshold<<RCR_FIFO_OFFSET) |\r\n(priv->EarlyRxThreshold == 7 ?\r\nRCR_ONLYERLPKT : 0);\r\npriv->IntrMask = IMR_TMGDOK | IMR_TBDER | IMR_THPDER |\r\nIMR_THPDER | IMR_THPDOK |\r\nIMR_TVODER | IMR_TVODOK |\r\nIMR_TVIDER | IMR_TVIDOK |\r\nIMR_TBEDER | IMR_TBEDOK |\r\nIMR_TBKDER | IMR_TBKDOK |\r\nIMR_RDU |\r\nIMR_RER | IMR_ROK |\r\nIMR_RQoSOK;\r\npriv->InitialGain = 6;\r\nDMESG("MAC controller is a RTL8187SE b/g");\r\npriv->phy_ver = 2;\r\npriv->ieee80211->modulation |= IEEE80211_OFDM_MODULATION;\r\npriv->ieee80211->short_slot = 1;\r\npriv->enable_gpio0 = 0;\r\neeprom_93cx6_read(&eeprom, EEPROM_SW_REVD_OFFSET, &eeprom_val);\r\nusValue = eeprom_val;\r\nDMESG("usValue is 0x%x\n", usValue);\r\nif ((usValue & EEPROM_SW_AD_MASK) != EEPROM_SW_AD_ENABLE)\r\npriv->EEPROMSwAntennaDiversity = false;\r\nelse\r\npriv->EEPROMSwAntennaDiversity = true;\r\nif ((usValue & EEPROM_DEF_ANT_MASK) != EEPROM_DEF_ANT_1)\r\npriv->EEPROMDefaultAntenna1 = false;\r\nelse\r\npriv->EEPROMDefaultAntenna1 = true;\r\nif (priv->RegSwAntennaDiversityMechanism == 0)\r\npriv->bSwAntennaDiverity = priv->EEPROMSwAntennaDiversity;\r\nelse\r\npriv->bSwAntennaDiverity = ((priv->RegSwAntennaDiversityMechanism == 1) ? false : true);\r\nif (priv->RegDefaultAntenna == 0)\r\npriv->bDefaultAntenna1 = priv->EEPROMDefaultAntenna1;\r\nelse\r\npriv->bDefaultAntenna1 = ((priv->RegDefaultAntenna == 2) ? true : false);\r\npriv->hw_plcp_len = 1;\r\npriv->plcp_preamble_mode = 2;\r\nif (RCR_9356SEL & read_nic_dword(dev, RCR))\r\npriv->epromtype = EPROM_93c56;\r\nelse\r\npriv->epromtype = EPROM_93c46;\r\neeprom_93cx6_multiread(&eeprom, 0x7, (__le16 *)\r\ndev->dev_addr, 3);\r\nfor (i = 1, j = 0; i < 14; i += 2, j++) {\r\neeprom_93cx6_read(&eeprom, EPROM_TXPW_CH1_2 + j, &word);\r\npriv->chtxpwr[i] = word & 0xff;\r\npriv->chtxpwr[i+1] = (word & 0xff00)>>8;\r\n}\r\nfor (i = 1, j = 0; i < 14; i += 2, j++) {\r\neeprom_93cx6_read(&eeprom, EPROM_TXPW_OFDM_CH1_2 + j, &word);\r\npriv->chtxpwr_ofdm[i] = word & 0xff;\r\npriv->chtxpwr_ofdm[i+1] = (word & 0xff00) >> 8;\r\n}\r\neeprom_93cx6_read(&eeprom, EEPROM_RSV>>1, &tmpu16);\r\npriv->XtalCal_Xout = tmpu16 & EEPROM_XTAL_CAL_XOUT_MASK;\r\npriv->XtalCal_Xin = (tmpu16 & EEPROM_XTAL_CAL_XIN_MASK) >> 4;\r\nif ((tmpu16 & EEPROM_XTAL_CAL_ENABLE) >> 12)\r\npriv->bXtalCalibration = true;\r\npriv->ThermalMeter = (u8)((tmpu16 & EEPROM_THERMAL_METER_MASK) >> 8);\r\nif ((tmpu16 & EEPROM_THERMAL_METER_ENABLE) >> 13)\r\npriv->bTxPowerTrack = true;\r\neeprom_93cx6_read(&eeprom, EPROM_TXPW_BASE, &word);\r\npriv->cck_txpwr_base = word & 0xf;\r\npriv->ofdm_txpwr_base = (word>>4) & 0xf;\r\neeprom_93cx6_read(&eeprom, EPROM_VERSION, &version);\r\nDMESG("EEPROM version %x", version);\r\npriv->rcr_csense = 3;\r\neeprom_93cx6_read(&eeprom, ENERGY_TRESHOLD, &eeprom_val);\r\npriv->cs_treshold = (eeprom_val & 0xff00) >> 8;\r\neeprom_93cx6_read(&eeprom, RFCHIPID, &eeprom_val);\r\npriv->rf_sleep = rtl8225z4_rf_sleep;\r\npriv->rf_wakeup = rtl8225z4_rf_wakeup;\r\nDMESGW("**PLEASE** REPORT SUCCESSFUL/UNSUCCESSFUL TO Realtek!");\r\npriv->rf_close = rtl8225z2_rf_close;\r\npriv->rf_init = rtl8225z2_rf_init;\r\npriv->rf_set_chan = rtl8225z2_rf_set_chan;\r\npriv->rf_set_sens = NULL;\r\nif (0 != alloc_rx_desc_ring(dev, priv->rxbuffersize, priv->rxringcount))\r\nreturn -ENOMEM;\r\nif (0 != alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,\r\nTX_MANAGEPRIORITY_RING_ADDR))\r\nreturn -ENOMEM;\r\nif (0 != alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,\r\nTX_BKPRIORITY_RING_ADDR))\r\nreturn -ENOMEM;\r\nif (0 != alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,\r\nTX_BEPRIORITY_RING_ADDR))\r\nreturn -ENOMEM;\r\nif (0 != alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,\r\nTX_VIPRIORITY_RING_ADDR))\r\nreturn -ENOMEM;\r\nif (0 != alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,\r\nTX_VOPRIORITY_RING_ADDR))\r\nreturn -ENOMEM;\r\nif (0 != alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,\r\nTX_HIGHPRIORITY_RING_ADDR))\r\nreturn -ENOMEM;\r\nif (0 != alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txbeaconcount,\r\nTX_BEACON_RING_ADDR))\r\nreturn -ENOMEM;\r\nif (request_irq(dev->irq, (void *)rtl8180_interrupt, IRQF_SHARED, dev->name, dev)) {\r\nDMESGE("Error allocating IRQ %d", dev->irq);\r\nreturn -1;\r\n} else {\r\npriv->irq = dev->irq;\r\nDMESG("IRQ %d", dev->irq);\r\n}\r\nreturn 0;\r\n}\r\nvoid rtl8180_no_hw_wep(struct net_device *dev)\r\n{\r\n}\r\nvoid rtl8180_set_hw_wep(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu8 pgreg;\r\nu8 security;\r\nu32 key0_word4;\r\npgreg = read_nic_byte(dev, PGSELECT);\r\nwrite_nic_byte(dev, PGSELECT, pgreg & ~(1<<PGSELECT_PG_SHIFT));\r\nkey0_word4 = read_nic_dword(dev, KEY0+4+4+4);\r\nkey0_word4 &= ~0xff;\r\nkey0_word4 |= priv->key0[3] & 0xff;\r\nwrite_nic_dword(dev, KEY0, (priv->key0[0]));\r\nwrite_nic_dword(dev, KEY0+4, (priv->key0[1]));\r\nwrite_nic_dword(dev, KEY0+4+4, (priv->key0[2]));\r\nwrite_nic_dword(dev, KEY0+4+4+4, (key0_word4));\r\nsecurity = read_nic_byte(dev, SECURITY);\r\nsecurity |= (1<<SECURITY_WEP_TX_ENABLE_SHIFT);\r\nsecurity |= (1<<SECURITY_WEP_RX_ENABLE_SHIFT);\r\nsecurity &= ~SECURITY_ENCRYP_MASK;\r\nsecurity |= (SECURITY_ENCRYP_104<<SECURITY_ENCRYP_SHIFT);\r\nwrite_nic_byte(dev, SECURITY, security);\r\nDMESG("key %x %x %x %x", read_nic_dword(dev, KEY0+4+4+4),\r\nread_nic_dword(dev, KEY0+4+4), read_nic_dword(dev, KEY0+4),\r\nread_nic_dword(dev, KEY0));\r\n}\r\nvoid rtl8185_rf_pins_enable(struct net_device *dev)\r\n{\r\nwrite_nic_word(dev, RFPinsEnable, 0x1fff);\r\n}\r\nvoid rtl8185_set_anaparam2(struct net_device *dev, u32 a)\r\n{\r\nu8 conf3;\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\nconf3 = read_nic_byte(dev, CONFIG3);\r\nwrite_nic_byte(dev, CONFIG3, conf3 | (1<<CONFIG3_ANAPARAM_W_SHIFT));\r\nwrite_nic_dword(dev, ANAPARAM2, a);\r\nconf3 = read_nic_byte(dev, CONFIG3);\r\nwrite_nic_byte(dev, CONFIG3, conf3 & ~(1<<CONFIG3_ANAPARAM_W_SHIFT));\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\n}\r\nvoid rtl8180_set_anaparam(struct net_device *dev, u32 a)\r\n{\r\nu8 conf3;\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\nconf3 = read_nic_byte(dev, CONFIG3);\r\nwrite_nic_byte(dev, CONFIG3, conf3 | (1<<CONFIG3_ANAPARAM_W_SHIFT));\r\nwrite_nic_dword(dev, ANAPARAM, a);\r\nconf3 = read_nic_byte(dev, CONFIG3);\r\nwrite_nic_byte(dev, CONFIG3, conf3 & ~(1<<CONFIG3_ANAPARAM_W_SHIFT));\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\n}\r\nvoid rtl8185_tx_antenna(struct net_device *dev, u8 ant)\r\n{\r\nwrite_nic_byte(dev, TX_ANTENNA, ant);\r\nforce_pci_posting(dev);\r\nmdelay(1);\r\n}\r\nvoid rtl8185_write_phy(struct net_device *dev, u8 adr, u32 data)\r\n{\r\nu32 phyw;\r\nadr |= 0x80;\r\nphyw = ((data<<8) | adr);\r\nwrite_nic_byte(dev, 0x7f, ((phyw & 0xff000000) >> 24));\r\nwrite_nic_byte(dev, 0x7e, ((phyw & 0x00ff0000) >> 16));\r\nwrite_nic_byte(dev, 0x7d, ((phyw & 0x0000ff00) >> 8));\r\nwrite_nic_byte(dev, 0x7c, ((phyw & 0x000000ff)));\r\n}\r\ninline void write_phy_ofdm(struct net_device *dev, u8 adr, u32 data)\r\n{\r\ndata = data & 0xff;\r\nrtl8185_write_phy(dev, adr, data);\r\n}\r\nvoid write_phy_cck(struct net_device *dev, u8 adr, u32 data)\r\n{\r\ndata = data & 0xff;\r\nrtl8185_write_phy(dev, adr, data | 0x10000);\r\n}\r\nvoid rtl8185_set_rate(struct net_device *dev)\r\n{\r\nint i;\r\nu16 word;\r\nint basic_rate, min_rr_rate, max_rr_rate;\r\nbasic_rate = ieeerate2rtlrate(240);\r\nmin_rr_rate = ieeerate2rtlrate(60);\r\nmax_rr_rate = ieeerate2rtlrate(240);\r\nwrite_nic_byte(dev, RESP_RATE,\r\nmax_rr_rate<<MAX_RESP_RATE_SHIFT |\r\nmin_rr_rate<<MIN_RESP_RATE_SHIFT);\r\nword = read_nic_word(dev, BRSR);\r\nword &= ~BRSR_MBR_8185;\r\nfor (i = 0; i <= basic_rate; i++)\r\nword |= (1<<i);\r\nwrite_nic_word(dev, BRSR, word);\r\n}\r\nvoid rtl8180_adapter_start(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nrtl8180_rtx_disable(dev);\r\nrtl8180_reset(dev);\r\npriv->irq_mask = 0x6fcf;\r\npriv->dma_poll_mask = 0;\r\nrtl8180_beacon_tx_disable(dev);\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\nwrite_nic_dword(dev, MAC0, ((u32 *)dev->dev_addr)[0]);\r\nwrite_nic_word(dev, MAC4, ((u32 *)dev->dev_addr)[1] & 0xffff);\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\nrtl8180_update_msr(dev);\r\nfix_rx_fifo(dev);\r\nfix_tx_fifo(dev);\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\nwrite_nic_byte(dev,\r\nCONFIG2, read_nic_byte(dev, CONFIG2) & ~\\r\n(1<<CONFIG2_DMA_POLLING_MODE_SHIFT));\r\nwrite_nic_byte(dev,\r\nCONFIG2, read_nic_byte(dev, CONFIG2)|(1<<4));\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\nwrite_nic_dword(dev, INT_TIMEOUT, 0);\r\nwrite_nic_byte(dev, WPA_CONFIG, 0);\r\nrtl8180_no_hw_wep(dev);\r\nrtl8185_set_rate(dev);\r\nwrite_nic_byte(dev, RATE_FALLBACK, 0x81);\r\nwrite_nic_byte(dev, GP_ENABLE, read_nic_byte(dev, GP_ENABLE) & ~(1<<6));\r\nrtl8180_set_mode(dev, EPROM_CMD_CONFIG);\r\nwrite_nic_byte(dev, CONFIG3, read_nic_byte(dev, CONFIG3)\r\n| (1 << CONFIG3_CLKRUN_SHIFT));\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\npriv->rf_init(dev);\r\nif (priv->rf_set_sens != NULL)\r\npriv->rf_set_sens(dev, priv->sens);\r\nrtl8180_irq_enable(dev);\r\nnetif_start_queue(dev);\r\n}\r\nvoid rtl8180_start_tx_beacon(struct net_device *dev)\r\n{\r\nu16 word;\r\nDMESG("Enabling beacon TX");\r\nrtl8180_prepare_beacon(dev);\r\nrtl8180_irq_disable(dev);\r\nrtl8180_beacon_tx_enable(dev);\r\nword = read_nic_word(dev, AtimWnd) & ~AtimWnd_AtimWnd;\r\nwrite_nic_word(dev, AtimWnd, word);\r\nword = read_nic_word(dev, BintrItv);\r\nword &= ~BintrItv_BintrItv;\r\nword |= 1000;\r\nwrite_nic_word(dev, BintrItv, word);\r\nrtl8180_set_mode(dev, EPROM_CMD_NORMAL);\r\nrtl8185b_irq_enable(dev);\r\n}\r\nstatic struct net_device_stats *rtl8180_stats(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nreturn &priv->ieee80211->stats;\r\n}\r\nbool\r\nMgntActSet_802_11_PowerSaveMode(\r\nstruct r8180_priv *priv,\r\nRT_PS_MODE rtPsMode\r\n)\r\n{\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nreturn false;\r\npriv->ieee80211->ps = rtPsMode;\r\nreturn true;\r\n}\r\nvoid LeisurePSEnter(struct r8180_priv *priv)\r\n{\r\nif (priv->bLeisurePs) {\r\nif (priv->ieee80211->ps == IEEE80211_PS_DISABLED)\r\nMgntActSet_802_11_PowerSaveMode(priv, IEEE80211_PS_MBCAST|IEEE80211_PS_UNICAST);\r\n}\r\n}\r\nvoid LeisurePSLeave(struct r8180_priv *priv)\r\n{\r\nif (priv->bLeisurePs) {\r\nif (priv->ieee80211->ps != IEEE80211_PS_DISABLED)\r\nMgntActSet_802_11_PowerSaveMode(priv, IEEE80211_PS_DISABLED);\r\n}\r\n}\r\nvoid rtl8180_hw_wakeup_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, hw_wakeup_wq);\r\nstruct net_device *dev = ieee->dev;\r\nrtl8180_hw_wakeup(dev);\r\n}\r\nvoid rtl8180_hw_sleep_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, hw_sleep_wq);\r\nstruct net_device *dev = ieee->dev;\r\nrtl8180_hw_sleep_down(dev);\r\n}\r\nstatic void MgntLinkKeepAlive(struct r8180_priv *priv)\r\n{\r\nif (priv->keepAliveLevel == 0)\r\nreturn;\r\nif (priv->ieee80211->state == IEEE80211_LINKED) {\r\nif ((priv->keepAliveLevel == 2) ||\r\n(priv->link_detect.LastNumTxUnicast == priv->NumTxUnicast &&\r\npriv->link_detect.LastNumRxUnicast == priv->ieee80211->NumRxUnicast)\r\n) {\r\npriv->link_detect.IdleCount++;\r\nif (priv->link_detect.IdleCount >= ((KEEP_ALIVE_INTERVAL / CHECK_FOR_HANG_PERIOD)-1)) {\r\npriv->link_detect.IdleCount = 0;\r\nieee80211_sta_ps_send_null_frame(priv->ieee80211, false);\r\n}\r\n} else {\r\npriv->link_detect.IdleCount = 0;\r\n}\r\npriv->link_detect.LastNumTxUnicast = priv->NumTxUnicast;\r\npriv->link_detect.LastNumRxUnicast = priv->ieee80211->NumRxUnicast;\r\n}\r\n}\r\nvoid rtl8180_watch_dog(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nbool bEnterPS = false;\r\nbool bBusyTraffic = false;\r\nu32 TotalRxNum = 0;\r\nu16 SlotIndex = 0;\r\nu16 i = 0;\r\nif (priv->ieee80211->actscanning == false) {\r\nif ((priv->ieee80211->iw_mode != IW_MODE_ADHOC) &&\r\n(priv->ieee80211->state == IEEE80211_NOLINK) &&\r\n(priv->ieee80211->beinretry == false) &&\r\n(priv->eRFPowerState == eRfOn))\r\nIPSEnter(dev);\r\n}\r\nif ((priv->ieee80211->state == IEEE80211_LINKED) && (priv->ieee80211->iw_mode == IW_MODE_INFRA)) {\r\nSlotIndex = (priv->link_detect.SlotIndex++) % priv->link_detect.SlotNum;\r\npriv->link_detect.RxFrameNum[SlotIndex] = priv->ieee80211->NumRxDataInPeriod + priv->ieee80211->NumRxBcnInPeriod;\r\nfor (i = 0; i < priv->link_detect.SlotNum; i++)\r\nTotalRxNum += priv->link_detect.RxFrameNum[i];\r\nif (TotalRxNum == 0) {\r\npriv->ieee80211->state = IEEE80211_ASSOCIATING;\r\nqueue_work(priv->ieee80211->wq, &priv->ieee80211->associate_procedure_wq);\r\n}\r\n}\r\nMgntLinkKeepAlive(priv);\r\nif (priv->PowerProfile == POWER_PROFILE_BATTERY)\r\npriv->bLeisurePs = true;\r\nelse if (priv->PowerProfile == POWER_PROFILE_AC) {\r\nLeisurePSLeave(priv);\r\npriv->bLeisurePs = false;\r\n}\r\nif (priv->ieee80211->state == IEEE80211_LINKED) {\r\npriv->link_detect.NumRxOkInPeriod = priv->ieee80211->NumRxDataInPeriod;\r\nif (priv->link_detect.NumRxOkInPeriod > 666 ||\r\npriv->link_detect.NumTxOkInPeriod > 666) {\r\nbBusyTraffic = true;\r\n}\r\nif (((priv->link_detect.NumRxOkInPeriod + priv->link_detect.NumTxOkInPeriod) > 8)\r\n|| (priv->link_detect.NumRxOkInPeriod > 2)) {\r\nbEnterPS = false;\r\n} else\r\nbEnterPS = true;\r\nif (bEnterPS)\r\nLeisurePSEnter(priv);\r\nelse\r\nLeisurePSLeave(priv);\r\n} else\r\nLeisurePSLeave(priv);\r\npriv->link_detect.bBusyTraffic = bBusyTraffic;\r\npriv->link_detect.NumRxOkInPeriod = 0;\r\npriv->link_detect.NumTxOkInPeriod = 0;\r\npriv->ieee80211->NumRxDataInPeriod = 0;\r\npriv->ieee80211->NumRxBcnInPeriod = 0;\r\n}\r\nint _rtl8180_up(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\npriv->up = 1;\r\nDMESG("Bringing up iface");\r\nrtl8185b_adapter_start(dev);\r\nrtl8185b_rx_enable(dev);\r\nrtl8185b_tx_enable(dev);\r\nif (priv->bInactivePs) {\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nIPSLeave(dev);\r\n}\r\ntimer_rate_adaptive((unsigned long)dev);\r\nwatch_dog_adaptive((unsigned long)dev);\r\nif (priv->bSwAntennaDiverity)\r\nSwAntennaDiversityTimerCallback(dev);\r\nieee80211_softmac_start_protocol(priv->ieee80211);\r\nreturn 0;\r\n}\r\nint rtl8180_open(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nint ret;\r\ndown(&priv->wx_sem);\r\nret = rtl8180_up(dev);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nint rtl8180_up(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nif (priv->up == 1)\r\nreturn -1;\r\nreturn _rtl8180_up(dev);\r\n}\r\nint rtl8180_close(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nint ret;\r\ndown(&priv->wx_sem);\r\nret = rtl8180_down(dev);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nint rtl8180_down(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nif (priv->up == 0)\r\nreturn -1;\r\npriv->up = 0;\r\nieee80211_softmac_stop_protocol(priv->ieee80211);\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\nrtl8180_rtx_disable(dev);\r\nrtl8180_irq_disable(dev);\r\ndel_timer_sync(&priv->watch_dog_timer);\r\ndel_timer_sync(&priv->rateadapter_timer);\r\ncancel_delayed_work(&priv->ieee80211->rate_adapter_wq);\r\ncancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);\r\ncancel_delayed_work(&priv->ieee80211->hw_sleep_wq);\r\ncancel_delayed_work(&priv->ieee80211->hw_dig_wq);\r\ncancel_delayed_work(&priv->ieee80211->tx_pw_wq);\r\ndel_timer_sync(&priv->SwAntennaDiversityTimer);\r\nSetZebraRFPowerState8185(dev, eRfOff);\r\nmemset(&(priv->ieee80211->current_network), 0, sizeof(struct ieee80211_network));\r\npriv->ieee80211->state = IEEE80211_NOLINK;\r\nreturn 0;\r\n}\r\nvoid rtl8180_restart_wq(struct work_struct *work)\r\n{\r\nstruct r8180_priv *priv = container_of(work, struct r8180_priv, reset_wq);\r\nstruct net_device *dev = priv->dev;\r\ndown(&priv->wx_sem);\r\nrtl8180_commit(dev);\r\nup(&priv->wx_sem);\r\n}\r\nvoid rtl8180_restart(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nschedule_work(&priv->reset_wq);\r\n}\r\nvoid rtl8180_commit(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nif (priv->up == 0)\r\nreturn ;\r\ndel_timer_sync(&priv->watch_dog_timer);\r\ndel_timer_sync(&priv->rateadapter_timer);\r\ncancel_delayed_work(&priv->ieee80211->rate_adapter_wq);\r\ncancel_delayed_work(&priv->ieee80211->hw_wakeup_wq);\r\ncancel_delayed_work(&priv->ieee80211->hw_sleep_wq);\r\ncancel_delayed_work(&priv->ieee80211->hw_dig_wq);\r\ncancel_delayed_work(&priv->ieee80211->tx_pw_wq);\r\ndel_timer_sync(&priv->SwAntennaDiversityTimer);\r\nieee80211_softmac_stop_protocol(priv->ieee80211);\r\nrtl8180_irq_disable(dev);\r\nrtl8180_rtx_disable(dev);\r\n_rtl8180_up(dev);\r\n}\r\nstatic void r8180_set_multicast(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nshort promisc;\r\npromisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\r\nif (promisc != priv->promisc)\r\nrtl8180_restart(dev);\r\npriv->promisc = promisc;\r\n}\r\nint r8180_set_mac_adr(struct net_device *dev, void *mac)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nstruct sockaddr *addr = mac;\r\ndown(&priv->wx_sem);\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nif (priv->ieee80211->iw_mode == IW_MODE_MASTER)\r\nmemcpy(priv->ieee80211->current_network.bssid, dev->dev_addr, ETH_ALEN);\r\nif (priv->up) {\r\nrtl8180_down(dev);\r\nrtl8180_up(dev);\r\n}\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nint rtl8180_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct iwreq *wrq = (struct iwreq *) rq;\r\nint ret = -1;\r\nswitch (cmd) {\r\ncase RTL_IOCTL_WPA_SUPPLICANT:\r\nret = ieee80211_wpa_supplicant_ioctl(priv->ieee80211, &wrq->u.data);\r\nreturn ret;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int __devinit rtl8180_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned long ioaddr = 0;\r\nstruct net_device *dev = NULL;\r\nstruct r8180_priv *priv = NULL;\r\nu8 unit = 0;\r\nint ret = -ENODEV;\r\nunsigned long pmem_start, pmem_len, pmem_flags;\r\nDMESG("Configuring chip resources");\r\nif (pci_enable_device(pdev)) {\r\nDMESG("Failed to enable PCI device");\r\nreturn -EIO;\r\n}\r\npci_set_master(pdev);\r\npci_set_dma_mask(pdev, 0xffffff00ULL);\r\npci_set_consistent_dma_mask(pdev, 0xffffff00ULL);\r\ndev = alloc_ieee80211(sizeof(struct r8180_priv));\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto fail_free;\r\n}\r\npriv = ieee80211_priv(dev);\r\npriv->ieee80211 = netdev_priv(dev);\r\npci_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npriv = ieee80211_priv(dev);\r\npriv->pdev = pdev;\r\npmem_start = pci_resource_start(pdev, 1);\r\npmem_len = pci_resource_len(pdev, 1);\r\npmem_flags = pci_resource_flags(pdev, 1);\r\nif (!(pmem_flags & IORESOURCE_MEM)) {\r\nDMESG("region #1 not a MMIO resource, aborting");\r\ngoto fail;\r\n}\r\nif (!request_mem_region(pmem_start, pmem_len, RTL8180_MODULE_NAME)) {\r\nDMESG("request_mem_region failed!");\r\ngoto fail;\r\n}\r\nioaddr = (unsigned long)ioremap_nocache(pmem_start, pmem_len);\r\nif (ioaddr == (unsigned long)NULL) {\r\nDMESG("ioremap failed!");\r\ngoto fail1;\r\n}\r\ndev->mem_start = ioaddr;\r\ndev->mem_end = ioaddr + pci_resource_len(pdev, 0);\r\npci_read_config_byte(pdev, 0x05, &unit);\r\npci_write_config_byte(pdev, 0x05, unit & (~0x04));\r\ndev->irq = pdev->irq;\r\npriv->irq = 0;\r\ndev->netdev_ops = &rtl8180_netdev_ops;\r\ndev->wireless_handlers = &r8180_wx_handlers_def;\r\ndev->type = ARPHRD_ETHER;\r\ndev->watchdog_timeo = HZ*3;\r\nif (dev_alloc_name(dev, ifname) < 0) {\r\nDMESG("Oops: devname already taken! Trying wlan%%d...\n");\r\nstrcpy(ifname, "wlan%d");\r\ndev_alloc_name(dev, ifname);\r\n}\r\nif (rtl8180_init(dev) != 0) {\r\nDMESG("Initialization failed");\r\ngoto fail1;\r\n}\r\nnetif_carrier_off(dev);\r\nregister_netdev(dev);\r\nrtl8180_proc_init_one(dev);\r\nDMESG("Driver probe completed\n");\r\nreturn 0;\r\nfail1:\r\nif (dev->mem_start != (unsigned long)NULL) {\r\niounmap((void *)dev->mem_start);\r\nrelease_mem_region(pci_resource_start(pdev, 1),\r\npci_resource_len(pdev, 1));\r\n}\r\nfail:\r\nif (dev) {\r\nif (priv->irq) {\r\nfree_irq(dev->irq, dev);\r\ndev->irq = 0;\r\n}\r\nfree_ieee80211(dev);\r\n}\r\nfail_free:\r\npci_disable_device(pdev);\r\nDMESG("wlan driver load failed\n");\r\npci_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic void __devexit rtl8180_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct r8180_priv *priv;\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev) {\r\nunregister_netdev(dev);\r\npriv = ieee80211_priv(dev);\r\nrtl8180_proc_remove_one(dev);\r\nrtl8180_down(dev);\r\npriv->rf_close(dev);\r\nrtl8180_reset(dev);\r\nmdelay(10);\r\nif (priv->irq) {\r\nDMESG("Freeing irq %d", dev->irq);\r\nfree_irq(dev->irq, dev);\r\npriv->irq = 0;\r\n}\r\nfree_rx_desc_ring(dev);\r\nfree_tx_desc_rings(dev);\r\nif (dev->mem_start != (unsigned long)NULL) {\r\niounmap((void *)dev->mem_start);\r\nrelease_mem_region(pci_resource_start(pdev, 1),\r\npci_resource_len(pdev, 1));\r\n}\r\nfree_ieee80211(dev);\r\n}\r\npci_disable_device(pdev);\r\nDMESG("wlan driver removed\n");\r\n}\r\nstatic int __init rtl8180_pci_module_init(void)\r\n{\r\nint ret;\r\nret = ieee80211_crypto_init();\r\nif (ret) {\r\nprintk(KERN_ERR "ieee80211_crypto_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ieee80211_crypto_tkip_init();\r\nif (ret) {\r\nprintk(KERN_ERR "ieee80211_crypto_tkip_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ieee80211_crypto_ccmp_init();\r\nif (ret) {\r\nprintk(KERN_ERR "ieee80211_crypto_ccmp_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ieee80211_crypto_wep_init();\r\nif (ret) {\r\nprintk(KERN_ERR "ieee80211_crypto_wep_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nprintk(KERN_INFO "\nLinux kernel driver for RTL8180 / RTL8185 based WLAN cards\n");\r\nprintk(KERN_INFO "Copyright (c) 2004-2005, Andrea Merello\n");\r\nDMESG("Initializing module");\r\nDMESG("Wireless extensions version %d", WIRELESS_EXT);\r\nrtl8180_proc_module_init();\r\nif (pci_register_driver(&rtl8180_pci_driver)) {\r\nDMESG("No device found");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit rtl8180_pci_module_exit(void)\r\n{\r\npci_unregister_driver(&rtl8180_pci_driver);\r\nrtl8180_proc_module_remove();\r\nieee80211_crypto_tkip_exit();\r\nieee80211_crypto_ccmp_exit();\r\nieee80211_crypto_wep_exit();\r\nieee80211_crypto_deinit();\r\nDMESG("Exiting");\r\n}\r\nvoid rtl8180_try_wake_queue(struct net_device *dev, int pri)\r\n{\r\nunsigned long flags;\r\nshort enough_desc;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nenough_desc = check_nic_enought_desc(dev, pri);\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nif (enough_desc)\r\nieee80211_rtl_wake_queue(priv->ieee80211);\r\n}\r\nvoid rtl8180_tx_isr(struct net_device *dev, int pri, short error)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nu32 *tail;\r\nu32 *head;\r\nu32 *begin;\r\nu32 *nicv;\r\nu32 nic;\r\nu32 nicbegin;\r\nunsigned long flag;\r\nint offs;\r\nint j, i;\r\nint hd;\r\nif (error)\r\npriv->stats.txretry++;\r\nspin_lock_irqsave(&priv->tx_lock, flag);\r\nswitch (pri) {\r\ncase MANAGE_PRIORITY:\r\ntail = priv->txmapringtail;\r\nbegin = priv->txmapring;\r\nhead = priv->txmapringhead;\r\nnic = read_nic_dword(dev, TX_MANAGEPRIORITY_RING_ADDR);\r\nnicbegin = priv->txmapringdma;\r\nbreak;\r\ncase BK_PRIORITY:\r\ntail = priv->txbkpringtail;\r\nbegin = priv->txbkpring;\r\nhead = priv->txbkpringhead;\r\nnic = read_nic_dword(dev, TX_BKPRIORITY_RING_ADDR);\r\nnicbegin = priv->txbkpringdma;\r\nbreak;\r\ncase BE_PRIORITY:\r\ntail = priv->txbepringtail;\r\nbegin = priv->txbepring;\r\nhead = priv->txbepringhead;\r\nnic = read_nic_dword(dev, TX_BEPRIORITY_RING_ADDR);\r\nnicbegin = priv->txbepringdma;\r\nbreak;\r\ncase VI_PRIORITY:\r\ntail = priv->txvipringtail;\r\nbegin = priv->txvipring;\r\nhead = priv->txvipringhead;\r\nnic = read_nic_dword(dev, TX_VIPRIORITY_RING_ADDR);\r\nnicbegin = priv->txvipringdma;\r\nbreak;\r\ncase VO_PRIORITY:\r\ntail = priv->txvopringtail;\r\nbegin = priv->txvopring;\r\nhead = priv->txvopringhead;\r\nnic = read_nic_dword(dev, TX_VOPRIORITY_RING_ADDR);\r\nnicbegin = priv->txvopringdma;\r\nbreak;\r\ncase HI_PRIORITY:\r\ntail = priv->txhpringtail;\r\nbegin = priv->txhpring;\r\nhead = priv->txhpringhead;\r\nnic = read_nic_dword(dev, TX_HIGHPRIORITY_RING_ADDR);\r\nnicbegin = priv->txhpringdma;\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&priv->tx_lock, flag);\r\nreturn ;\r\n}\r\nnicv = (u32 *)((nic - nicbegin) + (u8*)begin);\r\nif ((head <= tail && (nicv > tail || nicv < head)) ||\r\n(head > tail && (nicv > tail && nicv < head))) {\r\nDMESGW("nic has lost pointer");\r\nspin_unlock_irqrestore(&priv->tx_lock, flag);\r\nrtl8180_restart(dev);\r\nreturn;\r\n}\r\noffs = (nic - nicbegin);\r\noffs = offs / 8 / 4;\r\nhd = (head - begin) / 8;\r\nif (offs >= hd)\r\nj = offs - hd;\r\nelse\r\nj = offs + (priv->txringcount-1-hd);\r\nj -= 2;\r\nif (j < 0)\r\nj = 0;\r\nfor (i = 0; i < j; i++) {\r\nif ((*head) & (1<<31))\r\nbreak;\r\nif (((*head)&(0x10000000)) != 0) {\r\npriv->CurrRetryCnt += (u16)((*head) & (0x000000ff));\r\nif (!error)\r\npriv->NumTxOkTotal++;\r\n}\r\nif (!error)\r\npriv->NumTxOkBytesTotal += (*(head+3)) & (0x00000fff);\r\n*head = *head & ~(1<<31);\r\nif ((head - begin)/8 == priv->txringcount-1)\r\nhead = begin;\r\nelse\r\nhead += 8;\r\n}\r\nswitch (pri) {\r\ncase MANAGE_PRIORITY:\r\npriv->txmapringhead = head;\r\nif (priv->ack_tx_to_ieee) {\r\nif (rtl8180_is_tx_queue_empty(dev)) {\r\npriv->ack_tx_to_ieee = 0;\r\nieee80211_ps_tx_ack(priv->ieee80211, !error);\r\n}\r\n}\r\nbreak;\r\ncase BK_PRIORITY:\r\npriv->txbkpringhead = head;\r\nbreak;\r\ncase BE_PRIORITY:\r\npriv->txbepringhead = head;\r\nbreak;\r\ncase VI_PRIORITY:\r\npriv->txvipringhead = head;\r\nbreak;\r\ncase VO_PRIORITY:\r\npriv->txvopringhead = head;\r\nbreak;\r\ncase HI_PRIORITY:\r\npriv->txhpringhead = head;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_lock, flag);\r\n}\r\nvoid rtl8180_tx_irq_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device * ieee = (struct ieee80211_device *)\r\ncontainer_of(dwork, struct ieee80211_device, watch_dog_wq);\r\nstruct net_device *dev = ieee->dev;\r\nrtl8180_tx_isr(dev, MANAGE_PRIORITY, 0);\r\n}\r\nirqreturn_t rtl8180_interrupt(int irq, void *netdev, struct pt_regs *regs)\r\n{\r\nstruct net_device *dev = (struct net_device *) netdev;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nunsigned long flags;\r\nu32 inta;\r\nif (priv->irq_enabled == 0)\r\nreturn IRQ_HANDLED;\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\ninta = read_nic_dword(dev, ISR);\r\nwrite_nic_dword(dev, ISR, inta);\r\npriv->stats.shints++;\r\nif (!inta) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (inta == 0xffff) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\npriv->stats.ints++;\r\nif (!netif_running(dev)) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (inta & ISR_TimeOut)\r\nwrite_nic_dword(dev, TimerInt, 0);\r\nif (inta & ISR_TBDOK)\r\npriv->stats.txbeacon++;\r\nif (inta & ISR_TBDER)\r\npriv->stats.txbeaconerr++;\r\nif (inta & IMR_TMGDOK)\r\nrtl8180_tx_isr(dev, MANAGE_PRIORITY, 0);\r\nif (inta & ISR_THPDER) {\r\npriv->stats.txhperr++;\r\nrtl8180_tx_isr(dev, HI_PRIORITY, 1);\r\npriv->ieee80211->stats.tx_errors++;\r\n}\r\nif (inta & ISR_THPDOK) {\r\npriv->link_detect.NumTxOkInPeriod++;\r\npriv->stats.txhpokint++;\r\nrtl8180_tx_isr(dev, HI_PRIORITY, 0);\r\n}\r\nif (inta & ISR_RER)\r\npriv->stats.rxerr++;\r\nif (inta & ISR_TBKDER) {\r\npriv->stats.txbkperr++;\r\npriv->ieee80211->stats.tx_errors++;\r\nrtl8180_tx_isr(dev, BK_PRIORITY, 1);\r\nrtl8180_try_wake_queue(dev, BE_PRIORITY);\r\n}\r\nif (inta & ISR_TBEDER) {\r\npriv->stats.txbeperr++;\r\npriv->ieee80211->stats.tx_errors++;\r\nrtl8180_tx_isr(dev, BE_PRIORITY, 1);\r\nrtl8180_try_wake_queue(dev, BE_PRIORITY);\r\n}\r\nif (inta & ISR_TNPDER) {\r\npriv->stats.txnperr++;\r\npriv->ieee80211->stats.tx_errors++;\r\nrtl8180_tx_isr(dev, NORM_PRIORITY, 1);\r\nrtl8180_try_wake_queue(dev, NORM_PRIORITY);\r\n}\r\nif (inta & ISR_TLPDER) {\r\npriv->stats.txlperr++;\r\npriv->ieee80211->stats.tx_errors++;\r\nrtl8180_tx_isr(dev, LOW_PRIORITY, 1);\r\nrtl8180_try_wake_queue(dev, LOW_PRIORITY);\r\n}\r\nif (inta & ISR_ROK) {\r\npriv->stats.rxint++;\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & ISR_RQoSOK) {\r\npriv->stats.rxint++;\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & ISR_BcnInt)\r\nrtl8180_prepare_beacon(dev);\r\nif (inta & ISR_RDU) {\r\nDMESGW("No RX descriptor available");\r\npriv->stats.rxrdu++;\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & ISR_RXFOVW) {\r\npriv->stats.rxoverflow++;\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & ISR_TXFOVW)\r\npriv->stats.txoverflow++;\r\nif (inta & ISR_TNPDOK) {\r\npriv->link_detect.NumTxOkInPeriod++;\r\npriv->stats.txnpokint++;\r\nrtl8180_tx_isr(dev, NORM_PRIORITY, 0);\r\n}\r\nif (inta & ISR_TLPDOK) {\r\npriv->link_detect.NumTxOkInPeriod++;\r\npriv->stats.txlpokint++;\r\nrtl8180_tx_isr(dev, LOW_PRIORITY, 0);\r\nrtl8180_try_wake_queue(dev, LOW_PRIORITY);\r\n}\r\nif (inta & ISR_TBKDOK) {\r\npriv->stats.txbkpokint++;\r\npriv->link_detect.NumTxOkInPeriod++;\r\nrtl8180_tx_isr(dev, BK_PRIORITY, 0);\r\nrtl8180_try_wake_queue(dev, BE_PRIORITY);\r\n}\r\nif (inta & ISR_TBEDOK) {\r\npriv->stats.txbeperr++;\r\npriv->link_detect.NumTxOkInPeriod++;\r\nrtl8180_tx_isr(dev, BE_PRIORITY, 0);\r\nrtl8180_try_wake_queue(dev, BE_PRIORITY);\r\n}\r\nforce_pci_posting(dev);\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid rtl8180_irq_rx_tasklet(struct r8180_priv *priv)\r\n{\r\nrtl8180_rx(priv->dev);\r\n}\r\nvoid GPIOChangeRFWorkItemCallBack(struct work_struct *work)\r\n{\r\nstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, GPIOChangeRFWorkItem.work);\r\nstruct net_device *dev = ieee->dev;\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nu8 btPSR;\r\nu8 btConfig0;\r\nRT_RF_POWER_STATE eRfPowerStateToSet;\r\nbool bActuallySet = false;\r\nchar *argv[3];\r\nstatic char *RadioPowerPath = "/etc/acpi/events/RadioPower.sh";\r\nstatic char *envp[] = {"HOME=/", "TERM=linux", "PATH=/usr/bin:/bin", NULL};\r\nstatic int readf_count = 0;\r\nif (readf_count % 10 == 0)\r\npriv->PowerProfile = read_acadapter_file("/proc/acpi/ac_adapter/AC0/state");\r\nreadf_count = (readf_count+1)%0xffff;\r\nbtPSR = read_nic_byte(dev, PSR);\r\nwrite_nic_byte(dev, PSR, (btPSR & ~BIT3));\r\nudelay(4);\r\nbtConfig0 = btPSR = read_nic_byte(dev, CONFIG0);\r\neRfPowerStateToSet = (btConfig0 & BIT4) ? eRfOn : eRfOff;\r\nif (eRfPowerStateToSet == eRfOn)\r\nwrite_nic_byte(dev, PSR, btPSR | BIT3);\r\nif ((priv->ieee80211->bHwRadioOff == true) &&\r\n(eRfPowerStateToSet == eRfOn)) {\r\npriv->ieee80211->bHwRadioOff = false;\r\nbActuallySet = true;\r\n} else if ((priv->ieee80211->bHwRadioOff == false) &&\r\n(eRfPowerStateToSet == eRfOff)) {\r\npriv->ieee80211->bHwRadioOff = true;\r\nbActuallySet = true;\r\n}\r\nif (bActuallySet) {\r\nMgntActSet_RF_State(dev, eRfPowerStateToSet, RF_CHANGE_BY_HW);\r\nif (priv->ieee80211->bHwRadioOff == true)\r\nargv[1] = "RFOFF";\r\nelse\r\nargv[1] = "RFON";\r\nargv[0] = RadioPowerPath;\r\nargv[2] = NULL;\r\ncall_usermodehelper(RadioPowerPath, argv, envp, UMH_WAIT_PROC);\r\n}\r\n}\r\nstatic u8 read_acadapter_file(char *filename)\r\n{\r\nreturn 0;\r\n}
