static void\r\nkvp_register(void)\r\n{\r\nstruct cn_msg *msg;\r\nstruct hv_kvp_msg *kvp_msg;\r\nchar *version;\r\nmsg = kzalloc(sizeof(*msg) + sizeof(struct hv_kvp_msg), GFP_ATOMIC);\r\nif (msg) {\r\nkvp_msg = (struct hv_kvp_msg *)msg->data;\r\nversion = kvp_msg->body.kvp_register.version;\r\nmsg->id.idx = CN_KVP_IDX;\r\nmsg->id.val = CN_KVP_VAL;\r\nkvp_msg->kvp_hdr.operation = KVP_OP_REGISTER;\r\nstrcpy(version, HV_DRV_VERSION);\r\nmsg->len = sizeof(struct hv_kvp_msg);\r\ncn_netlink_send(msg, 0, GFP_ATOMIC);\r\nkfree(msg);\r\n}\r\n}\r\nstatic void\r\nkvp_work_func(struct work_struct *dummy)\r\n{\r\nkvp_respond_to_host("Unknown key", "Guest timed out", TIMEOUT_FIRED);\r\n}\r\nstatic void\r\nkvp_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\r\n{\r\nstruct hv_kvp_msg *message;\r\nstruct hv_kvp_msg_enumerate *data;\r\nmessage = (struct hv_kvp_msg *)msg->data;\r\nswitch (message->kvp_hdr.operation) {\r\ncase KVP_OP_REGISTER:\r\npr_info("KVP: user-mode registering done.\n");\r\nkvp_register();\r\nkvp_transaction.active = false;\r\nhv_kvp_onchannelcallback(kvp_transaction.kvp_context);\r\nbreak;\r\ndefault:\r\ndata = &message->body.kvp_enum_data;\r\nif (cancel_delayed_work_sync(&kvp_work))\r\nkvp_respond_to_host(data->data.key,\r\ndata->data.value,\r\n!strlen(data->data.key));\r\n}\r\n}\r\nstatic void\r\nkvp_send_key(struct work_struct *dummy)\r\n{\r\nstruct cn_msg *msg;\r\nstruct hv_kvp_msg *message;\r\nstruct hv_kvp_msg *in_msg;\r\n__u8 operation = kvp_transaction.kvp_msg->kvp_hdr.operation;\r\n__u8 pool = kvp_transaction.kvp_msg->kvp_hdr.pool;\r\n__u32 val32;\r\n__u64 val64;\r\nmsg = kzalloc(sizeof(*msg) + sizeof(struct hv_kvp_msg) , GFP_ATOMIC);\r\nif (!msg)\r\nreturn;\r\nmsg->id.idx = CN_KVP_IDX;\r\nmsg->id.val = CN_KVP_VAL;\r\nmessage = (struct hv_kvp_msg *)msg->data;\r\nmessage->kvp_hdr.operation = operation;\r\nmessage->kvp_hdr.pool = pool;\r\nin_msg = kvp_transaction.kvp_msg;\r\nswitch (message->kvp_hdr.operation) {\r\ncase KVP_OP_SET:\r\nswitch (in_msg->body.kvp_set.data.value_type) {\r\ncase REG_SZ:\r\nmessage->body.kvp_set.data.value_size =\r\nutf16s_to_utf8s(\r\n(wchar_t *)in_msg->body.kvp_set.data.value,\r\nin_msg->body.kvp_set.data.value_size,\r\nUTF16_LITTLE_ENDIAN,\r\nmessage->body.kvp_set.data.value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE - 1) + 1;\r\nbreak;\r\ncase REG_U32:\r\nval32 = in_msg->body.kvp_set.data.value_u32;\r\nmessage->body.kvp_set.data.value_size =\r\nsprintf(message->body.kvp_set.data.value,\r\n"%d", val32) + 1;\r\nbreak;\r\ncase REG_U64:\r\nval64 = in_msg->body.kvp_set.data.value_u64;\r\nmessage->body.kvp_set.data.value_size =\r\nsprintf(message->body.kvp_set.data.value,\r\n"%llu", val64) + 1;\r\nbreak;\r\n}\r\ncase KVP_OP_GET:\r\nmessage->body.kvp_set.data.key_size =\r\nutf16s_to_utf8s(\r\n(wchar_t *)in_msg->body.kvp_set.data.key,\r\nin_msg->body.kvp_set.data.key_size,\r\nUTF16_LITTLE_ENDIAN,\r\nmessage->body.kvp_set.data.key,\r\nHV_KVP_EXCHANGE_MAX_KEY_SIZE - 1) + 1;\r\nbreak;\r\ncase KVP_OP_DELETE:\r\nmessage->body.kvp_delete.key_size =\r\nutf16s_to_utf8s(\r\n(wchar_t *)in_msg->body.kvp_delete.key,\r\nin_msg->body.kvp_delete.key_size,\r\nUTF16_LITTLE_ENDIAN,\r\nmessage->body.kvp_delete.key,\r\nHV_KVP_EXCHANGE_MAX_KEY_SIZE - 1) + 1;\r\nbreak;\r\ncase KVP_OP_ENUMERATE:\r\nmessage->body.kvp_enum_data.index =\r\nin_msg->body.kvp_enum_data.index;\r\nbreak;\r\n}\r\nmsg->len = sizeof(struct hv_kvp_msg);\r\ncn_netlink_send(msg, 0, GFP_ATOMIC);\r\nkfree(msg);\r\nreturn;\r\n}\r\nstatic void\r\nkvp_respond_to_host(char *key, char *value, int error)\r\n{\r\nstruct hv_kvp_msg *kvp_msg;\r\nstruct hv_kvp_exchg_msg_value *kvp_data;\r\nchar *key_name;\r\nstruct icmsg_hdr *icmsghdrp;\r\nint keylen = 0;\r\nint valuelen = 0;\r\nu32 buf_len;\r\nstruct vmbus_channel *channel;\r\nu64 req_id;\r\nif (!kvp_transaction.active) {\r\npr_warn("KVP: Transaction not active\n");\r\nreturn;\r\n}\r\nbuf_len = kvp_transaction.recv_len;\r\nchannel = kvp_transaction.recv_channel;\r\nreq_id = kvp_transaction.recv_req_id;\r\nkvp_transaction.active = false;\r\nicmsghdrp = (struct icmsg_hdr *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr)];\r\nif (channel->onchannel_callback == NULL)\r\nreturn;\r\nif (error) {\r\nicmsghdrp->status = HV_S_CONT;\r\ngoto response_done;\r\n}\r\nicmsghdrp->status = HV_S_OK;\r\nkvp_msg = (struct hv_kvp_msg *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nswitch (kvp_transaction.kvp_msg->kvp_hdr.operation) {\r\ncase KVP_OP_GET:\r\nkvp_data = &kvp_msg->body.kvp_get.data;\r\ngoto copy_value;\r\ncase KVP_OP_SET:\r\ncase KVP_OP_DELETE:\r\ngoto response_done;\r\ndefault:\r\nbreak;\r\n}\r\nkvp_data = &kvp_msg->body.kvp_enum_data.data;\r\nkey_name = key;\r\nkeylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,\r\n(wchar_t *) kvp_data->key,\r\n(HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2) - 2);\r\nkvp_data->key_size = 2*(keylen + 1);\r\ncopy_value:\r\nvaluelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,\r\n(wchar_t *) kvp_data->value,\r\n(HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2) - 2);\r\nkvp_data->value_size = 2*(valuelen + 1);\r\nif ((keylen < 0) || (valuelen < 0))\r\nicmsghdrp->status = HV_E_FAIL;\r\nkvp_data->value_type = REG_SZ;\r\nresponse_done:\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nvoid hv_kvp_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct hv_kvp_msg *kvp_msg;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct icmsg_negotiate *negop = NULL;\r\nif (kvp_transaction.active) {\r\nkvp_transaction.kvp_context = context;\r\nreturn;\r\n}\r\nvmbus_recvpacket(channel, recv_buffer, PAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nvmbus_prep_negotiate_resp(icmsghdrp, negop,\r\nrecv_buffer, MAX_SRV_VER, MAX_SRV_VER);\r\n} else {\r\nkvp_msg = (struct hv_kvp_msg *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nkvp_transaction.recv_len = recvlen;\r\nkvp_transaction.recv_channel = channel;\r\nkvp_transaction.recv_req_id = requestid;\r\nkvp_transaction.active = true;\r\nkvp_transaction.kvp_msg = kvp_msg;\r\nschedule_work(&kvp_sendkey_work);\r\nschedule_delayed_work(&kvp_work, 5*HZ);\r\nreturn;\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nint\r\nhv_kvp_init(struct hv_util_service *srv)\r\n{\r\nint err;\r\nerr = cn_add_callback(&kvp_id, kvp_name, kvp_cn_callback);\r\nif (err)\r\nreturn err;\r\nrecv_buffer = srv->recv_buffer;\r\nkvp_transaction.active = true;\r\nreturn 0;\r\n}\r\nvoid hv_kvp_deinit(void)\r\n{\r\ncn_del_callback(&kvp_id);\r\ncancel_delayed_work_sync(&kvp_work);\r\ncancel_work_sync(&kvp_sendkey_work);\r\n}
