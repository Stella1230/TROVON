int\r\nlpfc_els_chk_latt(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t ha_copy;\r\nif (vport->port_state >= LPFC_VPORT_READY ||\r\nphba->link_state == LPFC_LINK_DOWN ||\r\nphba->sli_rev > LPFC_SLI_REV3)\r\nreturn 0;\r\nif (lpfc_readl(phba->HAregaddr, &ha_copy))\r\nreturn 1;\r\nif (!(ha_copy & HA_LATT))\r\nreturn 0;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,\r\n"0237 Pending Link Event during "\r\n"Discovery: State x%x\n",\r\nphba->pport->port_state);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_ABORT_DISCOVERY;\r\nspin_unlock_irq(shost->host_lock);\r\nif (phba->link_state != LPFC_CLEAR_LA)\r\nlpfc_issue_clear_la(phba, vport);\r\nreturn 1;\r\n}\r\nstruct lpfc_iocbq *\r\nlpfc_prep_els_iocb(struct lpfc_vport *vport, uint8_t expectRsp,\r\nuint16_t cmdSize, uint8_t retry,\r\nstruct lpfc_nodelist *ndlp, uint32_t did,\r\nuint32_t elscmd)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_dmabuf *pcmd, *prsp, *pbuflist;\r\nstruct ulp_bde64 *bpl;\r\nIOCB_t *icmd;\r\nif (!lpfc_is_link_up(phba))\r\nreturn NULL;\r\nelsiocb = lpfc_sli_get_iocbq(phba);\r\nif (elsiocb == NULL)\r\nreturn NULL;\r\nif ((did == Fabric_DID) &&\r\n(phba->hba_flag & HBA_FIP_SUPPORT) &&\r\n((elscmd == ELS_CMD_FLOGI) ||\r\n(elscmd == ELS_CMD_FDISC) ||\r\n(elscmd == ELS_CMD_LOGO)))\r\nswitch (elscmd) {\r\ncase ELS_CMD_FLOGI:\r\nelsiocb->iocb_flag |=\r\n((LPFC_ELS_ID_FLOGI << LPFC_FIP_ELS_ID_SHIFT)\r\n& LPFC_FIP_ELS_ID_MASK);\r\nbreak;\r\ncase ELS_CMD_FDISC:\r\nelsiocb->iocb_flag |=\r\n((LPFC_ELS_ID_FDISC << LPFC_FIP_ELS_ID_SHIFT)\r\n& LPFC_FIP_ELS_ID_MASK);\r\nbreak;\r\ncase ELS_CMD_LOGO:\r\nelsiocb->iocb_flag |=\r\n((LPFC_ELS_ID_LOGO << LPFC_FIP_ELS_ID_SHIFT)\r\n& LPFC_FIP_ELS_ID_MASK);\r\nbreak;\r\n}\r\nelse\r\nelsiocb->iocb_flag &= ~LPFC_FIP_ELS_ID_MASK;\r\nicmd = &elsiocb->iocb;\r\npcmd = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (pcmd)\r\npcmd->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &pcmd->phys);\r\nif (!pcmd || !pcmd->virt)\r\ngoto els_iocb_free_pcmb_exit;\r\nINIT_LIST_HEAD(&pcmd->list);\r\nif (expectRsp) {\r\nprsp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (prsp)\r\nprsp->virt = lpfc_mbuf_alloc(phba, MEM_PRI,\r\n&prsp->phys);\r\nif (!prsp || !prsp->virt)\r\ngoto els_iocb_free_prsp_exit;\r\nINIT_LIST_HEAD(&prsp->list);\r\n} else\r\nprsp = NULL;\r\npbuflist = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (pbuflist)\r\npbuflist->virt = lpfc_mbuf_alloc(phba, MEM_PRI,\r\n&pbuflist->phys);\r\nif (!pbuflist || !pbuflist->virt)\r\ngoto els_iocb_free_pbuf_exit;\r\nINIT_LIST_HEAD(&pbuflist->list);\r\nif (expectRsp) {\r\nicmd->un.elsreq64.bdl.addrHigh = putPaddrHigh(pbuflist->phys);\r\nicmd->un.elsreq64.bdl.addrLow = putPaddrLow(pbuflist->phys);\r\nicmd->un.elsreq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\nicmd->un.elsreq64.bdl.bdeSize = (2 * sizeof(struct ulp_bde64));\r\nicmd->un.elsreq64.remoteID = did;\r\nicmd->ulpCommand = CMD_ELS_REQUEST64_CR;\r\nicmd->ulpTimeout = phba->fc_ratov * 2;\r\n} else {\r\nicmd->un.xseq64.bdl.addrHigh = putPaddrHigh(pbuflist->phys);\r\nicmd->un.xseq64.bdl.addrLow = putPaddrLow(pbuflist->phys);\r\nicmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\nicmd->un.xseq64.bdl.bdeSize = sizeof(struct ulp_bde64);\r\nicmd->un.xseq64.xmit_els_remoteID = did;\r\nicmd->ulpCommand = CMD_XMIT_ELS_RSP64_CX;\r\n}\r\nicmd->ulpBdeCount = 1;\r\nicmd->ulpLe = 1;\r\nicmd->ulpClass = CLASS3;\r\nif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) ||\r\n((phba->sli_rev == LPFC_SLI_REV4) &&\r\n(vport->fc_flag & FC_PT2PT))) {\r\nif (expectRsp) {\r\nicmd->un.elsreq64.myID = vport->fc_myDID;\r\nicmd->ulpContext = phba->vpi_ids[vport->vpi];\r\n}\r\nicmd->ulpCt_h = 0;\r\nif (elscmd == ELS_CMD_ECHO)\r\nicmd->ulpCt_l = 0;\r\nelse\r\nicmd->ulpCt_l = 1;\r\n}\r\nbpl = (struct ulp_bde64 *) pbuflist->virt;\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(pcmd->phys));\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(pcmd->phys));\r\nbpl->tus.f.bdeSize = cmdSize;\r\nbpl->tus.f.bdeFlags = 0;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nif (expectRsp) {\r\nbpl++;\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(prsp->phys));\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(prsp->phys));\r\nbpl->tus.f.bdeSize = FCELSSIZE;\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\n}\r\nelsiocb->context1 = lpfc_nlp_get(ndlp);\r\nif (!elsiocb->context1)\r\ngoto els_iocb_free_pbuf_exit;\r\nelsiocb->context2 = pcmd;\r\nelsiocb->context3 = pbuflist;\r\nelsiocb->retry = retry;\r\nelsiocb->vport = vport;\r\nelsiocb->drvrTimeout = (phba->fc_ratov << 1) + LPFC_DRVR_TIMEOUT;\r\nif (prsp) {\r\nlist_add(&prsp->list, &pcmd->list);\r\n}\r\nif (expectRsp) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0116 Xmit ELS command x%x to remote "\r\n"NPORT x%x I/O tag: x%x, port state: x%x\n",\r\nelscmd, did, elsiocb->iotag,\r\nvport->port_state);\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0117 Xmit ELS response x%x to remote "\r\n"NPORT x%x I/O tag: x%x, size: x%x\n",\r\nelscmd, ndlp->nlp_DID, elsiocb->iotag,\r\ncmdSize);\r\n}\r\nreturn elsiocb;\r\nels_iocb_free_pbuf_exit:\r\nif (expectRsp)\r\nlpfc_mbuf_free(phba, prsp->virt, prsp->phys);\r\nkfree(pbuflist);\r\nels_iocb_free_prsp_exit:\r\nlpfc_mbuf_free(phba, pcmd->virt, pcmd->phys);\r\nkfree(prsp);\r\nels_iocb_free_pcmb_exit:\r\nkfree(pcmd);\r\nlpfc_sli_release_iocbq(phba, elsiocb);\r\nreturn NULL;\r\n}\r\nint\r\nlpfc_issue_fabric_reglogin(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nLPFC_MBOXQ_t *mbox;\r\nstruct lpfc_dmabuf *mp;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct serv_parm *sp;\r\nint rc;\r\nint err = 0;\r\nsp = &phba->fc_fabparam;\r\nndlp = lpfc_findnode_did(vport, Fabric_DID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {\r\nerr = 1;\r\ngoto fail;\r\n}\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mbox) {\r\nerr = 2;\r\ngoto fail;\r\n}\r\nvport->port_state = LPFC_FABRIC_CFG_LINK;\r\nlpfc_config_link(phba, mbox);\r\nmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nmbox->vport = vport;\r\nrc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nerr = 3;\r\ngoto fail_free_mbox;\r\n}\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mbox) {\r\nerr = 4;\r\ngoto fail;\r\n}\r\nrc = lpfc_reg_rpi(phba, vport->vpi, Fabric_DID, (uint8_t *)sp, mbox,\r\nndlp->nlp_rpi);\r\nif (rc) {\r\nerr = 5;\r\ngoto fail_free_mbox;\r\n}\r\nmbox->mbox_cmpl = lpfc_mbx_cmpl_fabric_reg_login;\r\nmbox->vport = vport;\r\nmbox->context2 = lpfc_nlp_get(ndlp);\r\nrc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nerr = 6;\r\ngoto fail_issue_reg_login;\r\n}\r\nreturn 0;\r\nfail_issue_reg_login:\r\nlpfc_nlp_put(ndlp);\r\nmp = (struct lpfc_dmabuf *) mbox->context1;\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\nfail_free_mbox:\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nfail:\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0249 Cannot issue Register Fabric login: Err %d\n", err);\r\nreturn -ENXIO;\r\n}\r\nint\r\nlpfc_issue_reg_vfi(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nLPFC_MBOXQ_t *mboxq;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct serv_parm *sp;\r\nstruct lpfc_dmabuf *dmabuf;\r\nint rc = 0;\r\nsp = &phba->fc_fabparam;\r\nif ((phba->sli_rev == LPFC_SLI_REV4) &&\r\n!(phba->link_flag & LS_LOOPBACK_MODE) &&\r\n!(vport->fc_flag & FC_PT2PT)) {\r\nndlp = lpfc_findnode_did(vport, Fabric_DID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {\r\nrc = -ENODEV;\r\ngoto fail;\r\n}\r\n}\r\ndmabuf = kzalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (!dmabuf) {\r\nrc = -ENOMEM;\r\ngoto fail;\r\n}\r\ndmabuf->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &dmabuf->phys);\r\nif (!dmabuf->virt) {\r\nrc = -ENOMEM;\r\ngoto fail_free_dmabuf;\r\n}\r\nmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mboxq) {\r\nrc = -ENOMEM;\r\ngoto fail_free_coherent;\r\n}\r\nvport->port_state = LPFC_FABRIC_CFG_LINK;\r\nmemcpy(dmabuf->virt, &phba->fc_fabparam, sizeof(vport->fc_sparam));\r\nlpfc_reg_vfi(mboxq, vport, dmabuf->phys);\r\nmboxq->mbox_cmpl = lpfc_mbx_cmpl_reg_vfi;\r\nmboxq->vport = vport;\r\nmboxq->context1 = dmabuf;\r\nrc = lpfc_sli_issue_mbox(phba, mboxq, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nrc = -ENXIO;\r\ngoto fail_free_mbox;\r\n}\r\nreturn 0;\r\nfail_free_mbox:\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\nfail_free_coherent:\r\nlpfc_mbuf_free(phba, dmabuf->virt, dmabuf->phys);\r\nfail_free_dmabuf:\r\nkfree(dmabuf);\r\nfail:\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0289 Issue Register VFI failed: Err %d\n", rc);\r\nreturn rc;\r\n}\r\nint\r\nlpfc_issue_unreg_vfi(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct Scsi_Host *shost;\r\nLPFC_MBOXQ_t *mboxq;\r\nint rc;\r\nmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mboxq) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_DISCOVERY|LOG_MBOX,\r\n"2556 UNREG_VFI mbox allocation failed"\r\n"HBA state x%x\n", phba->pport->port_state);\r\nreturn -ENOMEM;\r\n}\r\nlpfc_unreg_vfi(mboxq, vport);\r\nmboxq->vport = vport;\r\nmboxq->mbox_cmpl = lpfc_unregister_vfi_cmpl;\r\nrc = lpfc_sli_issue_mbox(phba, mboxq, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_DISCOVERY|LOG_MBOX,\r\n"2557 UNREG_VFI issue mbox failed rc x%x "\r\n"HBA state x%x\n",\r\nrc, phba->pport->port_state);\r\nmempool_free(mboxq, phba->mbox_mem_pool);\r\nreturn -EIO;\r\n}\r\nshost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_VFI_REGISTERED;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn 0;\r\n}\r\nstatic uint8_t\r\nlpfc_check_clean_addr_bit(struct lpfc_vport *vport,\r\nstruct serv_parm *sp)\r\n{\r\nuint8_t fabric_param_changed = 0;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif ((vport->fc_prevDID != vport->fc_myDID) ||\r\nmemcmp(&vport->fabric_portname, &sp->portName,\r\nsizeof(struct lpfc_name)) ||\r\nmemcmp(&vport->fabric_nodename, &sp->nodeName,\r\nsizeof(struct lpfc_name)))\r\nfabric_param_changed = 1;\r\nif (fabric_param_changed && !sp->cmn.clean_address_bit &&\r\n(vport->fc_prevDID || lpfc_delay_discovery)) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_DISC_DELAYED;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nreturn fabric_param_changed;\r\n}\r\nstatic int\r\nlpfc_cmpl_els_flogi_fabric(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nstruct serv_parm *sp, IOCB_t *irsp)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_nodelist *np;\r\nstruct lpfc_nodelist *next_np;\r\nuint8_t fabric_param_changed;\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_FABRIC;\r\nspin_unlock_irq(shost->host_lock);\r\nphba->fc_edtov = be32_to_cpu(sp->cmn.e_d_tov);\r\nif (sp->cmn.edtovResolution)\r\nphba->fc_edtov = (phba->fc_edtov + 999999) / 1000000;\r\nphba->fc_edtovResol = sp->cmn.edtovResolution;\r\nphba->fc_ratov = (be32_to_cpu(sp->cmn.w2.r_a_tov) + 999) / 1000;\r\nif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_PUBLIC_LOOP;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nvport->fc_myDID = irsp->un.ulpWord[4] & Mask_DID;\r\nmemcpy(&ndlp->nlp_portname, &sp->portName, sizeof(struct lpfc_name));\r\nmemcpy(&ndlp->nlp_nodename, &sp->nodeName, sizeof(struct lpfc_name));\r\nndlp->nlp_class_sup = 0;\r\nif (sp->cls1.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS1;\r\nif (sp->cls2.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS2;\r\nif (sp->cls3.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS3;\r\nif (sp->cls4.classValid)\r\nndlp->nlp_class_sup |= FC_COS_CLASS4;\r\nndlp->nlp_maxframe = ((sp->cmn.bbRcvSizeMsb & 0x0F) << 8) |\r\nsp->cmn.bbRcvSizeLsb;\r\nfabric_param_changed = lpfc_check_clean_addr_bit(vport, sp);\r\nmemcpy(&vport->fabric_portname, &sp->portName,\r\nsizeof(struct lpfc_name));\r\nmemcpy(&vport->fabric_nodename, &sp->nodeName,\r\nsizeof(struct lpfc_name));\r\nmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\r\nif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) {\r\nif (sp->cmn.response_multiple_NPort) {\r\nlpfc_printf_vlog(vport, KERN_WARNING,\r\nLOG_ELS | LOG_VPORT,\r\n"1816 FLOGI NPIV supported, "\r\n"response data 0x%x\n",\r\nsp->cmn.response_multiple_NPort);\r\nspin_lock_irq(&phba->hbalock);\r\nphba->link_flag |= LS_NPIV_FAB_SUPPORTED;\r\nspin_unlock_irq(&phba->hbalock);\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_WARNING,\r\nLOG_ELS | LOG_VPORT,\r\n"1817 Fabric does not support NPIV "\r\n"- configuring single port mode.\n");\r\nspin_lock_irq(&phba->hbalock);\r\nphba->link_flag &= ~LS_NPIV_FAB_SUPPORTED;\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\n}\r\nif (fabric_param_changed &&\r\n!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\r\nlist_for_each_entry_safe(np, next_np,\r\n&vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(np))\r\ncontinue;\r\nif ((np->nlp_state != NLP_STE_NPR_NODE) ||\r\n!(np->nlp_flag & NLP_NPR_ADISC))\r\ncontinue;\r\nspin_lock_irq(shost->host_lock);\r\nnp->nlp_flag &= ~NLP_NPR_ADISC;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_unreg_rpi(vport, np);\r\n}\r\nlpfc_cleanup_pending_mbox(vport);\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nlpfc_sli4_unreg_all_rpis(vport);\r\nlpfc_mbx_unreg_vpi(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\r\nspin_unlock_irq(shost->host_lock);\r\n} else if ((phba->sli_rev == LPFC_SLI_REV4) &&\r\n!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\r\nlpfc_register_new_vport(phba, vport, ndlp);\r\nreturn 0;\r\n}\r\nif (phba->sli_rev < LPFC_SLI_REV4) {\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_REG_LOGIN_ISSUE);\r\nif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED &&\r\nvport->fc_flag & FC_VPORT_NEEDS_REG_VPI)\r\nlpfc_register_new_vport(phba, vport, ndlp);\r\nelse\r\nlpfc_issue_fabric_reglogin(vport);\r\n} else {\r\nndlp->nlp_type |= NLP_FABRIC;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\r\nif ((!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) &&\r\n(vport->vpi_state & LPFC_VPI_REGISTERED)) {\r\nlpfc_start_fdiscs(phba);\r\nlpfc_do_scr_ns_plogi(phba, vport);\r\n} else if (vport->fc_flag & FC_VFI_REGISTERED)\r\nlpfc_issue_init_vpi(vport);\r\nelse {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"3135 Need register VFI: (x%x/%x)\n",\r\nvport->fc_prevDID, vport->fc_myDID);\r\nlpfc_issue_reg_vfi(vport);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_cmpl_els_flogi_nport(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nstruct serv_parm *sp)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nLPFC_MBOXQ_t *mbox;\r\nint rc;\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\r\nspin_unlock_irq(shost->host_lock);\r\nphba->fc_edtov = FF_DEF_EDTOV;\r\nphba->fc_ratov = FF_DEF_RATOV;\r\nrc = memcmp(&vport->fc_portname, &sp->portName,\r\nsizeof(vport->fc_portname));\r\nif (rc >= 0) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_PT2PT_PLOGI;\r\nspin_unlock_irq(shost->host_lock);\r\nif (rc)\r\nvport->fc_myDID = PT2PT_LocalID;\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mbox)\r\ngoto fail;\r\nlpfc_config_link(phba, mbox);\r\nmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nmbox->vport = vport;\r\nrc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\ngoto fail;\r\n}\r\nif ((phba->sli_rev == LPFC_SLI_REV4) && rc)\r\nlpfc_issue_reg_vfi(vport);\r\nlpfc_nlp_put(ndlp);\r\nndlp = lpfc_findnode_did(vport, PT2PT_RemoteID);\r\nif (!ndlp) {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp)\r\ngoto fail;\r\nlpfc_nlp_init(vport, ndlp, PT2PT_RemoteID);\r\n} else if (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp,\r\nNLP_STE_UNUSED_NODE);\r\nif(!ndlp)\r\ngoto fail;\r\n}\r\nmemcpy(&ndlp->nlp_portname, &sp->portName,\r\nsizeof(struct lpfc_name));\r\nmemcpy(&ndlp->nlp_nodename, &sp->nodeName,\r\nsizeof(struct lpfc_name));\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\n} else\r\nlpfc_nlp_put(ndlp);\r\nphba->sli3_options &= ~LPFC_SLI3_NPIV_ENABLED;\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_PT2PT;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_disc_start(vport);\r\nreturn 0;\r\nfail:\r\nreturn -ENXIO;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_flogi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_nodelist *ndlp = cmdiocb->context1;\r\nstruct lpfc_dmabuf *pcmd = cmdiocb->context2, *prsp;\r\nstruct serv_parm *sp;\r\nuint16_t fcf_index;\r\nint rc;\r\nif (lpfc_els_chk_latt(vport)) {\r\nlpfc_nlp_put(ndlp);\r\ngoto out;\r\n}\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"FLOGI cmpl: status:x%x/x%x state:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nvport->port_state);\r\nif (irsp->ulpStatus) {\r\nif ((phba->hba_flag & HBA_FIP_SUPPORT) &&\r\n(phba->fcf.fcf_flag & FCF_DISCOVERY)) {\r\nif (phba->link_state < LPFC_LINK_UP)\r\ngoto stop_rr_fcf_flogi;\r\nif ((phba->fcoe_cvl_eventtag_attn ==\r\nphba->fcoe_cvl_eventtag) &&\r\n(irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&\r\n(irsp->un.ulpWord[4] == IOERR_SLI_ABORTED))\r\ngoto stop_rr_fcf_flogi;\r\nelse\r\nphba->fcoe_cvl_eventtag_attn =\r\nphba->fcoe_cvl_eventtag;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FIP | LOG_ELS,\r\n"2611 FLOGI failed on FCF (x%x), "\r\n"status:x%x/x%x, tmo:x%x, perform "\r\n"roundrobin FCF failover\n",\r\nphba->fcf.current_rec.fcf_indx,\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout);\r\nlpfc_sli4_set_fcf_flogi_fail(phba,\r\nphba->fcf.current_rec.fcf_indx);\r\nfcf_index = lpfc_sli4_fcf_rr_next_index_get(phba);\r\nrc = lpfc_sli4_fcf_rr_next_proc(vport, fcf_index);\r\nif (rc)\r\ngoto out;\r\n}\r\nstop_rr_fcf_flogi:\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"2858 FLOGI failure Status:x%x/x%x TMO:x%x\n",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout);\r\nif (lpfc_els_retry(phba, cmdiocb, rspiocb))\r\ngoto out;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0100 FLOGI failure Status:x%x/x%x TMO:x%x\n",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\r\nspin_unlock_irq(shost->host_lock);\r\nif (phba->alpa_map[0] == 0)\r\nvport->cfg_discovery_threads = LPFC_MAX_DISC_THREADS;\r\nif ((phba->sli_rev == LPFC_SLI_REV4) &&\r\n(!(vport->fc_flag & FC_VFI_REGISTERED) ||\r\n(vport->fc_prevDID != vport->fc_myDID))) {\r\nif (vport->fc_flag & FC_VFI_REGISTERED)\r\nlpfc_sli4_unreg_all_rpis(vport);\r\nlpfc_issue_reg_vfi(vport);\r\nlpfc_nlp_put(ndlp);\r\ngoto out;\r\n}\r\ngoto flogifail;\r\n}\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_VPORT_CVL_RCVD;\r\nvport->fc_flag &= ~FC_VPORT_LOGO_RCVD;\r\nspin_unlock_irq(shost->host_lock);\r\nprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\r\nsp = prsp->virt + sizeof(uint32_t);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0101 FLOGI completes successfully "\r\n"Data: x%x x%x x%x x%x\n",\r\nirsp->un.ulpWord[4], sp->cmn.e_d_tov,\r\nsp->cmn.w2.r_a_tov, sp->cmn.edtovResolution);\r\nif (vport->port_state == LPFC_FLOGI) {\r\nif (sp->cmn.fPort)\r\nrc = lpfc_cmpl_els_flogi_fabric(vport, ndlp, sp, irsp);\r\nelse if (!(phba->hba_flag & HBA_FCOE_MODE))\r\nrc = lpfc_cmpl_els_flogi_nport(vport, ndlp, sp);\r\nelse {\r\nlpfc_printf_vlog(vport, KERN_ERR,\r\nLOG_FIP | LOG_ELS,\r\n"2831 FLOGI response with cleared Fabric "\r\n"bit fcf_index 0x%x "\r\n"Switch Name %02x%02x%02x%02x%02x%02x%02x%02x "\r\n"Fabric Name "\r\n"%02x%02x%02x%02x%02x%02x%02x%02x\n",\r\nphba->fcf.current_rec.fcf_indx,\r\nphba->fcf.current_rec.switch_name[0],\r\nphba->fcf.current_rec.switch_name[1],\r\nphba->fcf.current_rec.switch_name[2],\r\nphba->fcf.current_rec.switch_name[3],\r\nphba->fcf.current_rec.switch_name[4],\r\nphba->fcf.current_rec.switch_name[5],\r\nphba->fcf.current_rec.switch_name[6],\r\nphba->fcf.current_rec.switch_name[7],\r\nphba->fcf.current_rec.fabric_name[0],\r\nphba->fcf.current_rec.fabric_name[1],\r\nphba->fcf.current_rec.fabric_name[2],\r\nphba->fcf.current_rec.fabric_name[3],\r\nphba->fcf.current_rec.fabric_name[4],\r\nphba->fcf.current_rec.fabric_name[5],\r\nphba->fcf.current_rec.fabric_name[6],\r\nphba->fcf.current_rec.fabric_name[7]);\r\nlpfc_nlp_put(ndlp);\r\nspin_lock_irq(&phba->hbalock);\r\nphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\r\nphba->hba_flag &= ~(FCF_RR_INPROG | HBA_DEVLOSS_TMO);\r\nspin_unlock_irq(&phba->hbalock);\r\ngoto out;\r\n}\r\nif (!rc) {\r\nif (phba->hba_flag & HBA_FIP_SUPPORT)\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FIP |\r\nLOG_ELS,\r\n"2769 FLOGI to FCF (x%x) "\r\n"completed successfully\n",\r\nphba->fcf.current_rec.fcf_indx);\r\nspin_lock_irq(&phba->hbalock);\r\nphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\r\nphba->hba_flag &= ~(FCF_RR_INPROG | HBA_DEVLOSS_TMO);\r\nspin_unlock_irq(&phba->hbalock);\r\ngoto out;\r\n}\r\n}\r\nflogifail:\r\nlpfc_nlp_put(ndlp);\r\nif (!lpfc_error_lost_link(irsp)) {\r\nlpfc_disc_list_loopmap(vport);\r\nlpfc_disc_start(vport);\r\n} else if (((irsp->ulpStatus != IOSTAT_LOCAL_REJECT) ||\r\n((irsp->un.ulpWord[4] != IOERR_SLI_ABORTED) &&\r\n(irsp->un.ulpWord[4] != IOERR_SLI_DOWN))) &&\r\n(phba->link_state != LPFC_CLEAR_LA)) {\r\nlpfc_issue_clear_la(phba, vport);\r\n}\r\nout:\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\n}\r\nstatic int\r\nlpfc_issue_els_flogi(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nuint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct serv_parm *sp;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli_ring *pring;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nuint32_t tmo;\r\nint rc;\r\npring = &phba->sli.ring[LPFC_ELS_RING];\r\ncmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_FLOGI);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_FLOGI;\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, &vport->fc_sparam, sizeof(struct serv_parm));\r\nsp = (struct serv_parm *) pcmd;\r\nsp->cmn.e_d_tov = 0;\r\nsp->cmn.w2.r_a_tov = 0;\r\nsp->cmn.virtual_fabric_support = 0;\r\nsp->cls1.classValid = 0;\r\nsp->cls2.seqDelivery = 1;\r\nsp->cls3.seqDelivery = 1;\r\nif (sp->cmn.fcphLow < FC_PH3)\r\nsp->cmn.fcphLow = FC_PH3;\r\nif (sp->cmn.fcphHigh < FC_PH3)\r\nsp->cmn.fcphHigh = FC_PH3;\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) ==\r\nLPFC_SLI_INTF_IF_TYPE_0) {\r\nelsiocb->iocb.ulpCt_h = ((SLI4_CT_FCFI >> 1) & 1);\r\nelsiocb->iocb.ulpCt_l = (SLI4_CT_FCFI & 1);\r\nelsiocb->iocb.ulpContext = phba->fcf.fcfi;\r\n}\r\n} else {\r\nif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) {\r\nsp->cmn.request_multiple_Nport = 1;\r\nicmd->ulpCt_h = 1;\r\nicmd->ulpCt_l = 0;\r\n} else\r\nsp->cmn.request_multiple_Nport = 0;\r\n}\r\nif (phba->fc_topology != LPFC_TOPOLOGY_LOOP) {\r\nicmd->un.elsreq64.myID = 0;\r\nicmd->un.elsreq64.fl = 1;\r\n}\r\ntmo = phba->fc_ratov;\r\nphba->fc_ratov = LPFC_DISC_FLOGI_TMO;\r\nlpfc_set_disctmo(vport);\r\nphba->fc_ratov = tmo;\r\nphba->fc_stat.elsXmitFLOGI++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_flogi;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue FLOGI: opt:x%x",\r\nphba->sli3_options, 0, 0);\r\nrc = lpfc_issue_fabric_iocb(phba, elsiocb);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlpfc_els_abort_flogi(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_sli_ring *pring;\r\nstruct lpfc_iocbq *iocb, *next_iocb;\r\nstruct lpfc_nodelist *ndlp;\r\nIOCB_t *icmd;\r\nlpfc_printf_log(phba, KERN_INFO, LOG_DISCOVERY,\r\n"0201 Abort outstanding I/O on NPort x%x\n",\r\nFabric_DID);\r\npring = &phba->sli.ring[LPFC_ELS_RING];\r\nspin_lock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(iocb, next_iocb, &pring->txcmplq, list) {\r\nicmd = &iocb->iocb;\r\nif (icmd->ulpCommand == CMD_ELS_REQUEST64_CR) {\r\nndlp = (struct lpfc_nodelist *)(iocb->context1);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp) &&\r\n(ndlp->nlp_DID == Fabric_DID))\r\nlpfc_sli_issue_abort_iotag(phba, pring, iocb);\r\n}\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nreturn 0;\r\n}\r\nint\r\nlpfc_initial_flogi(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_nodelist *ndlp;\r\nvport->port_state = LPFC_FLOGI;\r\nlpfc_set_disctmo(vport);\r\nndlp = lpfc_findnode_did(vport, Fabric_DID);\r\nif (!ndlp) {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp)\r\nreturn 0;\r\nlpfc_nlp_init(vport, ndlp, Fabric_DID);\r\nndlp->nlp_type |= NLP_FABRIC;\r\nlpfc_enqueue_node(vport, ndlp);\r\n} else if (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp, NLP_STE_UNUSED_NODE);\r\nif (!ndlp)\r\nreturn 0;\r\n}\r\nif (lpfc_issue_els_flogi(vport, ndlp, 0)) {\r\nlpfc_nlp_put(ndlp);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint\r\nlpfc_initial_fdisc(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_nodelist *ndlp;\r\nndlp = lpfc_findnode_did(vport, Fabric_DID);\r\nif (!ndlp) {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp)\r\nreturn 0;\r\nlpfc_nlp_init(vport, ndlp, Fabric_DID);\r\nlpfc_enqueue_node(vport, ndlp);\r\n} else if (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp, NLP_STE_UNUSED_NODE);\r\nif (!ndlp)\r\nreturn 0;\r\n}\r\nif (lpfc_issue_els_fdisc(vport, ndlp, 0)) {\r\nlpfc_nlp_put(ndlp);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid\r\nlpfc_more_plogi(struct lpfc_vport *vport)\r\n{\r\nint sentplogi;\r\nif (vport->num_disc_nodes)\r\nvport->num_disc_nodes--;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0232 Continue discovery with %d PLOGIs to go "\r\n"Data: x%x x%x x%x\n",\r\nvport->num_disc_nodes, vport->fc_plogi_cnt,\r\nvport->fc_flag, vport->port_state);\r\nif (vport->fc_flag & FC_NLP_MORE)\r\nsentplogi = lpfc_els_disc_plogi(vport);\r\nreturn;\r\n}\r\nstatic struct lpfc_nodelist *\r\nlpfc_plogi_confirm_nport(struct lpfc_hba *phba, uint32_t *prsp,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_vport *vport = ndlp->vport;\r\nstruct lpfc_nodelist *new_ndlp;\r\nstruct lpfc_rport_data *rdata;\r\nstruct fc_rport *rport;\r\nstruct serv_parm *sp;\r\nuint8_t name[sizeof(struct lpfc_name)];\r\nuint32_t rc, keepDID = 0;\r\nint put_node;\r\nint put_rport;\r\nstruct lpfc_node_rrqs rrq;\r\nif (ndlp->nlp_type & NLP_FABRIC)\r\nreturn ndlp;\r\nsp = (struct serv_parm *) ((uint8_t *) prsp + sizeof(uint32_t));\r\nmemset(name, 0, sizeof(struct lpfc_name));\r\nnew_ndlp = lpfc_findnode_wwpn(vport, &sp->portName);\r\nif (new_ndlp == ndlp && NLP_CHK_NODE_ACT(new_ndlp))\r\nreturn ndlp;\r\nmemset(&rrq.xri_bitmap, 0, sizeof(new_ndlp->active_rrqs.xri_bitmap));\r\nif (!new_ndlp) {\r\nrc = memcmp(&ndlp->nlp_portname, name,\r\nsizeof(struct lpfc_name));\r\nif (!rc)\r\nreturn ndlp;\r\nnew_ndlp = mempool_alloc(phba->nlp_mem_pool, GFP_ATOMIC);\r\nif (!new_ndlp)\r\nreturn ndlp;\r\nlpfc_nlp_init(vport, new_ndlp, ndlp->nlp_DID);\r\n} else if (!NLP_CHK_NODE_ACT(new_ndlp)) {\r\nrc = memcmp(&ndlp->nlp_portname, name,\r\nsizeof(struct lpfc_name));\r\nif (!rc)\r\nreturn ndlp;\r\nnew_ndlp = lpfc_enable_node(vport, new_ndlp,\r\nNLP_STE_UNUSED_NODE);\r\nif (!new_ndlp)\r\nreturn ndlp;\r\nkeepDID = new_ndlp->nlp_DID;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nmemcpy(&rrq.xri_bitmap,\r\n&new_ndlp->active_rrqs.xri_bitmap,\r\nsizeof(new_ndlp->active_rrqs.xri_bitmap));\r\n} else {\r\nkeepDID = new_ndlp->nlp_DID;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nmemcpy(&rrq.xri_bitmap,\r\n&new_ndlp->active_rrqs.xri_bitmap,\r\nsizeof(new_ndlp->active_rrqs.xri_bitmap));\r\n}\r\nlpfc_unreg_rpi(vport, new_ndlp);\r\nnew_ndlp->nlp_DID = ndlp->nlp_DID;\r\nnew_ndlp->nlp_prev_state = ndlp->nlp_prev_state;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nmemcpy(new_ndlp->active_rrqs.xri_bitmap,\r\n&ndlp->active_rrqs.xri_bitmap,\r\nsizeof(ndlp->active_rrqs.xri_bitmap));\r\nif (ndlp->nlp_flag & NLP_NPR_2B_DISC)\r\nnew_ndlp->nlp_flag |= NLP_NPR_2B_DISC;\r\nndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\r\nlpfc_nlp_set_state(vport, new_ndlp, ndlp->nlp_state);\r\nif (memcmp(&ndlp->nlp_portname, name, sizeof(struct lpfc_name)) == 0) {\r\nrport = ndlp->rport;\r\nif (rport) {\r\nrdata = rport->dd_data;\r\nif (rdata->pnode == ndlp) {\r\nlpfc_nlp_put(ndlp);\r\nndlp->rport = NULL;\r\nrdata->pnode = lpfc_nlp_get(new_ndlp);\r\nnew_ndlp->rport = rport;\r\n}\r\nnew_ndlp->nlp_type = ndlp->nlp_type;\r\n}\r\nif (ndlp->nlp_DID == 0) {\r\nspin_lock_irq(&phba->ndlp_lock);\r\nNLP_SET_FREE_REQ(ndlp);\r\nspin_unlock_irq(&phba->ndlp_lock);\r\n}\r\nndlp->nlp_DID = keepDID;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nmemcpy(&ndlp->active_rrqs.xri_bitmap,\r\n&rrq.xri_bitmap,\r\nsizeof(ndlp->active_rrqs.xri_bitmap));\r\nlpfc_drop_node(vport, ndlp);\r\n}\r\nelse {\r\nlpfc_unreg_rpi(vport, ndlp);\r\nndlp->nlp_DID = keepDID;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nmemcpy(&ndlp->active_rrqs.xri_bitmap,\r\n&rrq.xri_bitmap,\r\nsizeof(ndlp->active_rrqs.xri_bitmap));\r\nmemcpy(&new_ndlp->nlp_portname, &ndlp->nlp_portname,\r\nsizeof(struct lpfc_name));\r\nmemcpy(&new_ndlp->nlp_nodename, &ndlp->nlp_nodename,\r\nsizeof(struct lpfc_name));\r\nnew_ndlp->nlp_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nrport = ndlp->rport;\r\nif (rport) {\r\nrdata = rport->dd_data;\r\nput_node = rdata->pnode != NULL;\r\nput_rport = ndlp->rport != NULL;\r\nrdata->pnode = NULL;\r\nndlp->rport = NULL;\r\nif (put_node)\r\nlpfc_nlp_put(ndlp);\r\nif (put_rport)\r\nput_device(&rport->dev);\r\n}\r\n}\r\nreturn new_ndlp;\r\n}\r\nvoid\r\nlpfc_end_rscn(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (vport->fc_flag & FC_RSCN_MODE) {\r\nif (vport->fc_rscn_id_cnt ||\r\n(vport->fc_flag & FC_RSCN_DISCOVERY) != 0)\r\nlpfc_els_handle_rscn(vport);\r\nelse {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_RSCN_MODE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\n}\r\n}\r\nstatic void\r\nlpfc_cmpl_els_rrq(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nIOCB_t *irsp;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_node_rrq *rrq;\r\nrrq = cmdiocb->context_un.rrq;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\nirsp = &rspiocb->iocb;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"RRQ cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->un.elsreq64.remoteID);\r\nndlp = lpfc_findnode_did(vport, irsp->un.elsreq64.remoteID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp) || ndlp != rrq->ndlp) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"2882 RRQ completes to NPort x%x "\r\n"with no ndlp. Data: x%x x%x x%x\n",\r\nirsp->un.elsreq64.remoteID,\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpIoTag);\r\ngoto out;\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"2880 RRQ completes to NPort x%x "\r\n"Data: x%x x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout, rrq->xritag, rrq->rxid);\r\nif (irsp->ulpStatus) {\r\nif (irsp->ulpStatus != IOSTAT_LS_RJT ||\r\n(((irsp->un.ulpWord[4]) >> 16 != LSRJT_INVALID_CMD) &&\r\n((irsp->un.ulpWord[4]) >> 16 != LSRJT_UNABLE_TPC)) ||\r\n(phba)->pport->cfg_log_verbose & LOG_ELS)\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"2881 RRQ failure DID:%06X Status:x%x/x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\n}\r\nout:\r\nif (rrq)\r\nlpfc_clr_rrq_active(phba, rrq->xritag, rrq);\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_plogi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_dmabuf *prsp;\r\nint disc, rc, did, type;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\nirsp = &rspiocb->iocb;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"PLOGI cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->un.elsreq64.remoteID);\r\nndlp = lpfc_findnode_did(vport, irsp->un.elsreq64.remoteID);\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0136 PLOGI completes to NPort x%x "\r\n"with no ndlp. Data: x%x x%x x%x\n",\r\nirsp->un.elsreq64.remoteID,\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpIoTag);\r\ngoto out;\r\n}\r\nspin_lock_irq(shost->host_lock);\r\ndisc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);\r\nndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\nrc = 0;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0102 PLOGI completes to NPort x%x "\r\n"Data: x%x x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout, disc, vport->num_disc_nodes);\r\nif (lpfc_els_chk_latt(vport)) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\ngoto out;\r\n}\r\ntype = ndlp->nlp_type;\r\ndid = ndlp->nlp_DID;\r\nif (irsp->ulpStatus) {\r\nif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\r\nif (disc) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\ngoto out;\r\n}\r\nif (irsp->ulpStatus != IOSTAT_LS_RJT ||\r\n(((irsp->un.ulpWord[4]) >> 16 != LSRJT_INVALID_CMD) &&\r\n((irsp->un.ulpWord[4]) >> 16 != LSRJT_UNABLE_TPC)) ||\r\n(phba)->pport->cfg_log_verbose & LOG_ELS)\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"2753 PLOGI failure DID:%06X Status:x%x/x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\nif (lpfc_error_lost_link(irsp))\r\nrc = NLP_STE_FREED_NODE;\r\nelse\r\nrc = lpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_CMPL_PLOGI);\r\n} else {\r\nprsp = list_entry(((struct lpfc_dmabuf *)\r\ncmdiocb->context2)->list.next,\r\nstruct lpfc_dmabuf, list);\r\nndlp = lpfc_plogi_confirm_nport(phba, prsp->virt, ndlp);\r\nrc = lpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_CMPL_PLOGI);\r\n}\r\nif (disc && vport->num_disc_nodes) {\r\nlpfc_more_plogi(vport);\r\nif (vport->num_disc_nodes == 0) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_NDISC_ACTIVE;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_can_disctmo(vport);\r\nlpfc_end_rscn(vport);\r\n}\r\n}\r\nout:\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nint\r\nlpfc_issue_els_plogi(struct lpfc_vport *vport, uint32_t did, uint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct serv_parm *sp;\r\nIOCB_t *icmd;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli *psli;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint ret;\r\npsli = &phba->sli;\r\nndlp = lpfc_findnode_did(vport, did);\r\nif (ndlp && !NLP_CHK_NODE_ACT(ndlp))\r\nndlp = NULL;\r\ncmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp, did,\r\nELS_CMD_PLOGI);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_PLOGI;\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, &vport->fc_sparam, sizeof(struct serv_parm));\r\nsp = (struct serv_parm *) pcmd;\r\nif ((vport->fc_flag & FC_FABRIC) && !(vport->fc_flag & FC_PUBLIC_LOOP))\r\nsp->cmn.altBbCredit = 1;\r\nif (sp->cmn.fcphLow < FC_PH_4_3)\r\nsp->cmn.fcphLow = FC_PH_4_3;\r\nif (sp->cmn.fcphHigh < FC_PH3)\r\nsp->cmn.fcphHigh = FC_PH3;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue PLOGI: did:x%x",\r\ndid, 0, 0);\r\nphba->fc_stat.elsXmitPLOGI++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_plogi;\r\nret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (ret == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_prli(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp;\r\nstruct lpfc_sli *psli;\r\nstruct lpfc_nodelist *ndlp;\r\npsli = &phba->sli;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\nirsp = &(rspiocb->iocb);\r\nndlp = (struct lpfc_nodelist *) cmdiocb->context1;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_PRLI_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"PRLI cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nndlp->nlp_DID);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0103 PRLI completes to NPort x%x "\r\n"Data: x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout, vport->num_disc_nodes);\r\nvport->fc_prli_sent--;\r\nif (lpfc_els_chk_latt(vport))\r\ngoto out;\r\nif (irsp->ulpStatus) {\r\nif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\r\ngoto out;\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"2754 PRLI failure DID:%06X Status:x%x/x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\nif (lpfc_error_lost_link(irsp))\r\ngoto out;\r\nelse\r\nlpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_CMPL_PRLI);\r\n} else\r\nlpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_CMPL_PRLI);\r\nout:\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nint\r\nlpfc_issue_els_prli(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nuint8_t retry)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nPRLI *npr;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\ncmdsize = (sizeof(uint32_t) + sizeof(PRLI));\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_PRLI);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\nmemset(pcmd, 0, (sizeof(PRLI) + sizeof(uint32_t)));\r\n*((uint32_t *) (pcmd)) = ELS_CMD_PRLI;\r\npcmd += sizeof(uint32_t);\r\nnpr = (PRLI *) pcmd;\r\nif (phba->vpd.rev.feaLevelHigh >= 0x02) {\r\nnpr->ConfmComplAllowed = 1;\r\nnpr->Retry = 1;\r\nnpr->TaskRetryIdReq = 1;\r\n}\r\nnpr->estabImagePair = 1;\r\nnpr->readXferRdyDis = 1;\r\nnpr->prliType = PRLI_FCP_TYPE;\r\nnpr->initiatorFunc = 1;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue PRLI: did:x%x",\r\nndlp->nlp_DID, 0, 0);\r\nphba->fc_stat.elsXmitPRLI++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_prli;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_PRLI_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) ==\r\nIOCB_ERROR) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_PRLI_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nvport->fc_prli_sent++;\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_rscn_disc(struct lpfc_vport *vport)\r\n{\r\nlpfc_can_disctmo(vport);\r\nif (vport->fc_npr_cnt)\r\nif (lpfc_els_disc_plogi(vport))\r\nreturn;\r\nlpfc_end_rscn(vport);\r\n}\r\nstatic void\r\nlpfc_adisc_done(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\r\n!(vport->fc_flag & FC_RSCN_MODE) &&\r\n(phba->sli_rev < LPFC_SLI_REV4)) {\r\nlpfc_issue_reg_vpi(phba, vport);\r\nreturn;\r\n}\r\nif (vport->port_state < LPFC_VPORT_READY) {\r\nif (vport->port_type == LPFC_PHYSICAL_PORT)\r\nlpfc_issue_clear_la(phba, vport);\r\nif (!(vport->fc_flag & FC_ABORT_DISCOVERY)) {\r\nvport->num_disc_nodes = 0;\r\nif (vport->fc_npr_cnt)\r\nlpfc_els_disc_plogi(vport);\r\nif (!vport->num_disc_nodes) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_NDISC_ACTIVE;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_can_disctmo(vport);\r\nlpfc_end_rscn(vport);\r\n}\r\n}\r\nvport->port_state = LPFC_VPORT_READY;\r\n} else\r\nlpfc_rscn_disc(vport);\r\n}\r\nvoid\r\nlpfc_more_adisc(struct lpfc_vport *vport)\r\n{\r\nint sentadisc;\r\nif (vport->num_disc_nodes)\r\nvport->num_disc_nodes--;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0210 Continue discovery with %d ADISCs to go "\r\n"Data: x%x x%x x%x\n",\r\nvport->num_disc_nodes, vport->fc_adisc_cnt,\r\nvport->fc_flag, vport->port_state);\r\nif (vport->fc_flag & FC_NLP_MORE) {\r\nlpfc_set_disctmo(vport);\r\nsentadisc = lpfc_els_disc_adisc(vport);\r\n}\r\nif (!vport->num_disc_nodes)\r\nlpfc_adisc_done(vport);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_adisc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp;\r\nstruct lpfc_nodelist *ndlp;\r\nint disc;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\nirsp = &(rspiocb->iocb);\r\nndlp = (struct lpfc_nodelist *) cmdiocb->context1;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"ADISC cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nndlp->nlp_DID);\r\nspin_lock_irq(shost->host_lock);\r\ndisc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);\r\nndlp->nlp_flag &= ~(NLP_ADISC_SND | NLP_NPR_2B_DISC);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0104 ADISC completes to NPort x%x "\r\n"Data: x%x x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout, disc, vport->num_disc_nodes);\r\nif (lpfc_els_chk_latt(vport)) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\ngoto out;\r\n}\r\nif (irsp->ulpStatus) {\r\nif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\r\nif (disc) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_set_disctmo(vport);\r\n}\r\ngoto out;\r\n}\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"2755 ADISC failure DID:%06X Status:x%x/x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\nif (!lpfc_error_lost_link(irsp))\r\nlpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_CMPL_ADISC);\r\n} else\r\nlpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_CMPL_ADISC);\r\nif (disc && vport->num_disc_nodes)\r\nlpfc_more_adisc(vport);\r\nout:\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nint\r\nlpfc_issue_els_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nuint8_t retry)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nADISC *ap;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\ncmdsize = (sizeof(uint32_t) + sizeof(ADISC));\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_ADISC);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ADISC;\r\npcmd += sizeof(uint32_t);\r\nap = (ADISC *) pcmd;\r\nap->hardAL_PA = phba->fc_pref_ALPA;\r\nmemcpy(&ap->portName, &vport->fc_portname, sizeof(struct lpfc_name));\r\nmemcpy(&ap->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\r\nap->DID = be32_to_cpu(vport->fc_myDID);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue ADISC: did:x%x",\r\nndlp->nlp_DID, 0, 0);\r\nphba->fc_stat.elsXmitADISC++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_adisc;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_ADISC_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) ==\r\nIOCB_ERROR) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_ADISC_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_logo(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\r\nstruct lpfc_vport *vport = ndlp->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp;\r\nstruct lpfc_sli *psli;\r\nstruct lpfcMboxq *mbox;\r\npsli = &phba->sli;\r\ncmdiocb->context_un.rsp_iocb = rspiocb;\r\nirsp = &(rspiocb->iocb);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_LOGO_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"LOGO cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nndlp->nlp_DID);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0105 LOGO completes to NPort x%x "\r\n"Data: x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout, vport->num_disc_nodes);\r\nif (lpfc_els_chk_latt(vport))\r\ngoto out;\r\nif (ndlp->nlp_flag & NLP_TARGET_REMOVE) {\r\nlpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_DEVICE_RM);\r\ngoto out;\r\n}\r\nif (irsp->ulpStatus) {\r\nif (lpfc_els_retry(phba, cmdiocb, rspiocb))\r\ngoto out;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"2756 LOGO failure DID:%06X Status:x%x/x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\nif (lpfc_error_lost_link(irsp))\r\ngoto out;\r\nelse\r\nlpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_CMPL_LOGO);\r\n} else\r\nlpfc_disc_state_machine(vport, ndlp, cmdiocb,\r\nNLP_EVT_CMPL_LOGO);\r\nout:\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nif ((vport->fc_flag & FC_PT2PT) &&\r\n!(vport->fc_flag & FC_PT2PT_PLOGI)) {\r\nphba->pport->fc_myDID = 0;\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (mbox) {\r\nlpfc_config_link(phba, mbox);\r\nmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nmbox->vport = vport;\r\nif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT) ==\r\nMBX_NOT_FINISHED) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nint\r\nlpfc_issue_els_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nuint8_t retry)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint rc;\r\nspin_lock_irq(shost->host_lock);\r\nif (ndlp->nlp_flag & NLP_LOGO_SND) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn 0;\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\ncmdsize = (2 * sizeof(uint32_t)) + sizeof(struct lpfc_name);\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_LOGO);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_LOGO;\r\npcmd += sizeof(uint32_t);\r\n*((uint32_t *) (pcmd)) = be32_to_cpu(vport->fc_myDID);\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, &vport->fc_portname, sizeof(struct lpfc_name));\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue LOGO: did:x%x",\r\nndlp->nlp_DID, 0, 0);\r\nphba->fc_stat.elsXmitLOGO++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_logo;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_LOGO_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_LOGO_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_cmd(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nIOCB_t *irsp;\r\nirsp = &rspiocb->iocb;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"ELS cmd cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->un.elsreq64.remoteID);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0106 ELS cmd tag x%x completes Data: x%x x%x x%x\n",\r\nirsp->ulpIoTag, irsp->ulpStatus,\r\nirsp->un.ulpWord[4], irsp->ulpTimeout);\r\nlpfc_els_chk_latt(vport);\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nint\r\nlpfc_issue_els_scr(struct lpfc_vport *vport, uint32_t nportid, uint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli *psli;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nstruct lpfc_nodelist *ndlp;\r\npsli = &phba->sli;\r\ncmdsize = (sizeof(uint32_t) + sizeof(SCR));\r\nndlp = lpfc_findnode_did(vport, nportid);\r\nif (!ndlp) {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp)\r\nreturn 1;\r\nlpfc_nlp_init(vport, ndlp, nportid);\r\nlpfc_enqueue_node(vport, ndlp);\r\n} else if (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp, NLP_STE_UNUSED_NODE);\r\nif (!ndlp)\r\nreturn 1;\r\n}\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_SCR);\r\nif (!elsiocb) {\r\nlpfc_nlp_put(ndlp);\r\nreturn 1;\r\n}\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_SCR;\r\npcmd += sizeof(uint32_t);\r\nmemset(pcmd, 0, sizeof(SCR));\r\n((SCR *) pcmd)->Function = SCR_FUNC_FULL;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue SCR: did:x%x",\r\nndlp->nlp_DID, 0, 0);\r\nphba->fc_stat.elsXmitSCR++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_cmd;\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) ==\r\nIOCB_ERROR) {\r\nlpfc_nlp_put(ndlp);\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nlpfc_nlp_put(ndlp);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_issue_els_farpr(struct lpfc_vport *vport, uint32_t nportid, uint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli *psli;\r\nFARP *fp;\r\nuint8_t *pcmd;\r\nuint32_t *lp;\r\nuint16_t cmdsize;\r\nstruct lpfc_nodelist *ondlp;\r\nstruct lpfc_nodelist *ndlp;\r\npsli = &phba->sli;\r\ncmdsize = (sizeof(uint32_t) + sizeof(FARP));\r\nndlp = lpfc_findnode_did(vport, nportid);\r\nif (!ndlp) {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp)\r\nreturn 1;\r\nlpfc_nlp_init(vport, ndlp, nportid);\r\nlpfc_enqueue_node(vport, ndlp);\r\n} else if (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp, NLP_STE_UNUSED_NODE);\r\nif (!ndlp)\r\nreturn 1;\r\n}\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_RNID);\r\nif (!elsiocb) {\r\nlpfc_nlp_put(ndlp);\r\nreturn 1;\r\n}\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_FARPR;\r\npcmd += sizeof(uint32_t);\r\nfp = (FARP *) (pcmd);\r\nmemset(fp, 0, sizeof(FARP));\r\nlp = (uint32_t *) pcmd;\r\n*lp++ = be32_to_cpu(nportid);\r\n*lp++ = be32_to_cpu(vport->fc_myDID);\r\nfp->Rflags = 0;\r\nfp->Mflags = (FARP_MATCH_PORT | FARP_MATCH_NODE);\r\nmemcpy(&fp->RportName, &vport->fc_portname, sizeof(struct lpfc_name));\r\nmemcpy(&fp->RnodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\r\nondlp = lpfc_findnode_did(vport, nportid);\r\nif (ondlp && NLP_CHK_NODE_ACT(ondlp)) {\r\nmemcpy(&fp->OportName, &ondlp->nlp_portname,\r\nsizeof(struct lpfc_name));\r\nmemcpy(&fp->OnodeName, &ondlp->nlp_nodename,\r\nsizeof(struct lpfc_name));\r\n}\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue FARPR: did:x%x",\r\nndlp->nlp_DID, 0, 0);\r\nphba->fc_stat.elsXmitFARPR++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_cmd;\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) ==\r\nIOCB_ERROR) {\r\nlpfc_nlp_put(ndlp);\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nlpfc_nlp_put(ndlp);\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_cancel_retry_delay_tmo(struct lpfc_vport *vport, struct lpfc_nodelist *nlp)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_work_evt *evtp;\r\nif (!(nlp->nlp_flag & NLP_DELAY_TMO))\r\nreturn;\r\nspin_lock_irq(shost->host_lock);\r\nnlp->nlp_flag &= ~NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\ndel_timer_sync(&nlp->nlp_delayfunc);\r\nnlp->nlp_last_elscmd = 0;\r\nif (!list_empty(&nlp->els_retry_evt.evt_listp)) {\r\nlist_del_init(&nlp->els_retry_evt.evt_listp);\r\nevtp = &nlp->els_retry_evt;\r\nlpfc_nlp_put((struct lpfc_nodelist *)evtp->evt_arg1);\r\n}\r\nif (nlp->nlp_flag & NLP_NPR_2B_DISC) {\r\nspin_lock_irq(shost->host_lock);\r\nnlp->nlp_flag &= ~NLP_NPR_2B_DISC;\r\nspin_unlock_irq(shost->host_lock);\r\nif (vport->num_disc_nodes) {\r\nif (vport->port_state < LPFC_VPORT_READY) {\r\nlpfc_more_adisc(vport);\r\n} else {\r\nlpfc_more_plogi(vport);\r\nif (vport->num_disc_nodes == 0) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_NDISC_ACTIVE;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_can_disctmo(vport);\r\nlpfc_end_rscn(vport);\r\n}\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid\r\nlpfc_els_retry_delay(unsigned long ptr)\r\n{\r\nstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) ptr;\r\nstruct lpfc_vport *vport = ndlp->vport;\r\nstruct lpfc_hba *phba = vport->phba;\r\nunsigned long flags;\r\nstruct lpfc_work_evt *evtp = &ndlp->els_retry_evt;\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nif (!list_empty(&evtp->evt_listp)) {\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn;\r\n}\r\nevtp->evt_arg1 = lpfc_nlp_get(ndlp);\r\nif (evtp->evt_arg1) {\r\nevtp->evt = LPFC_EVT_ELS_RETRY;\r\nlist_add_tail(&evtp->evt_listp, &phba->work_list);\r\nlpfc_worker_wake_up(phba);\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_els_retry_delay_handler(struct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_vport *vport = ndlp->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nuint32_t cmd, did, retry;\r\nspin_lock_irq(shost->host_lock);\r\ndid = ndlp->nlp_DID;\r\ncmd = ndlp->nlp_last_elscmd;\r\nndlp->nlp_last_elscmd = 0;\r\nif (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn;\r\n}\r\nndlp->nlp_flag &= ~NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\ndel_timer_sync(&ndlp->nlp_delayfunc);\r\nretry = ndlp->nlp_retry;\r\nndlp->nlp_retry = 0;\r\nswitch (cmd) {\r\ncase ELS_CMD_FLOGI:\r\nlpfc_issue_els_flogi(vport, ndlp, retry);\r\nbreak;\r\ncase ELS_CMD_PLOGI:\r\nif (!lpfc_issue_els_plogi(vport, ndlp->nlp_DID, retry)) {\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\r\n}\r\nbreak;\r\ncase ELS_CMD_ADISC:\r\nif (!lpfc_issue_els_adisc(vport, ndlp, retry)) {\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\r\n}\r\nbreak;\r\ncase ELS_CMD_PRLI:\r\nif (!lpfc_issue_els_prli(vport, ndlp, retry)) {\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);\r\n}\r\nbreak;\r\ncase ELS_CMD_LOGO:\r\nif (!lpfc_issue_els_logo(vport, ndlp, retry)) {\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\n}\r\nbreak;\r\ncase ELS_CMD_FDISC:\r\nif (!(vport->fc_flag & FC_VPORT_NEEDS_INIT_VPI))\r\nlpfc_issue_els_fdisc(vport, ndlp, retry);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_els_retry(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\r\nstruct lpfc_dmabuf *pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nuint32_t *elscmd;\r\nstruct ls_rjt stat;\r\nint retry = 0, maxretry = lpfc_max_els_tries, delay = 0;\r\nint logerr = 0;\r\nuint32_t cmd = 0;\r\nuint32_t did;\r\nif (pcmd && pcmd->virt) {\r\nelscmd = (uint32_t *) (pcmd->virt);\r\ncmd = *elscmd++;\r\n}\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp))\r\ndid = ndlp->nlp_DID;\r\nelse {\r\ndid = irsp->un.elsreq64.remoteID;\r\nndlp = lpfc_findnode_did(vport, did);\r\nif ((!ndlp || !NLP_CHK_NODE_ACT(ndlp))\r\n&& (cmd != ELS_CMD_PLOGI))\r\nreturn 1;\r\n}\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Retry ELS: wd7:x%x wd4:x%x did:x%x",\r\n*(((uint32_t *) irsp) + 7), irsp->un.ulpWord[4], ndlp->nlp_DID);\r\nswitch (irsp->ulpStatus) {\r\ncase IOSTAT_FCP_RSP_ERROR:\r\nbreak;\r\ncase IOSTAT_REMOTE_STOP:\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\nlpfc_set_rrq_active(phba, ndlp,\r\ncmdiocb->sli4_lxritag, 0, 0);\r\n}\r\nbreak;\r\ncase IOSTAT_LOCAL_REJECT:\r\nswitch ((irsp->un.ulpWord[4] & 0xff)) {\r\ncase IOERR_LOOP_OPEN_FAILURE:\r\nif (cmd == ELS_CMD_FLOGI) {\r\nif (PCI_DEVICE_ID_HORNET ==\r\nphba->pcidev->device) {\r\nphba->fc_topology = LPFC_TOPOLOGY_LOOP;\r\nphba->pport->fc_myDID = 0;\r\nphba->alpa_map[0] = 0;\r\nphba->alpa_map[1] = 0;\r\n}\r\n}\r\nif (cmd == ELS_CMD_PLOGI && cmdiocb->retry == 0)\r\ndelay = 1000;\r\nretry = 1;\r\nbreak;\r\ncase IOERR_ILLEGAL_COMMAND:\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0124 Retry illegal cmd x%x "\r\n"retry:x%x delay:x%x\n",\r\ncmd, cmdiocb->retry, delay);\r\nretry = 1;\r\nmaxretry = 8;\r\nif (cmdiocb->retry > 2)\r\ndelay = 1000;\r\nbreak;\r\ncase IOERR_NO_RESOURCES:\r\nlogerr = 1;\r\nretry = 1;\r\nif (cmdiocb->retry > 100)\r\ndelay = 100;\r\nmaxretry = 250;\r\nbreak;\r\ncase IOERR_ILLEGAL_FRAME:\r\ndelay = 100;\r\nretry = 1;\r\nbreak;\r\ncase IOERR_SEQUENCE_TIMEOUT:\r\ncase IOERR_INVALID_RPI:\r\nretry = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase IOSTAT_NPORT_RJT:\r\ncase IOSTAT_FABRIC_RJT:\r\nif (irsp->un.ulpWord[4] & RJT_UNAVAIL_TEMP) {\r\nretry = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase IOSTAT_NPORT_BSY:\r\ncase IOSTAT_FABRIC_BSY:\r\nlogerr = 1;\r\nretry = 1;\r\nbreak;\r\ncase IOSTAT_LS_RJT:\r\nstat.un.lsRjtError = be32_to_cpu(irsp->un.ulpWord[4]);\r\nswitch (stat.un.b.lsRjtRsnCode) {\r\ncase LSRJT_UNABLE_TPC:\r\nif (stat.un.b.lsRjtRsnCodeExp ==\r\nLSEXP_CMD_IN_PROGRESS) {\r\nif (cmd == ELS_CMD_PLOGI) {\r\ndelay = 1000;\r\nmaxretry = 48;\r\n}\r\nretry = 1;\r\nbreak;\r\n}\r\nif (stat.un.b.lsRjtRsnCodeExp ==\r\nLSEXP_CANT_GIVE_DATA) {\r\nif (cmd == ELS_CMD_PLOGI) {\r\ndelay = 1000;\r\nmaxretry = 48;\r\n}\r\nretry = 1;\r\nbreak;\r\n}\r\nif (cmd == ELS_CMD_PLOGI) {\r\ndelay = 1000;\r\nmaxretry = lpfc_max_els_tries + 1;\r\nretry = 1;\r\nbreak;\r\n}\r\nif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\r\n(cmd == ELS_CMD_FDISC) &&\r\n(stat.un.b.lsRjtRsnCodeExp == LSEXP_OUT_OF_RESOURCE)){\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0125 FDISC Failed (x%x). "\r\n"Fabric out of resources\n",\r\nstat.un.lsRjtError);\r\nlpfc_vport_set_state(vport,\r\nFC_VPORT_NO_FABRIC_RSCS);\r\n}\r\nbreak;\r\ncase LSRJT_LOGICAL_BSY:\r\nif ((cmd == ELS_CMD_PLOGI) ||\r\n(cmd == ELS_CMD_PRLI)) {\r\ndelay = 1000;\r\nmaxretry = 48;\r\n} else if (cmd == ELS_CMD_FDISC) {\r\nmaxretry = 48;\r\nif (cmdiocb->retry >= 32)\r\ndelay = 1000;\r\n}\r\nretry = 1;\r\nbreak;\r\ncase LSRJT_LOGICAL_ERR:\r\nif (cmd == ELS_CMD_FDISC &&\r\nstat.un.b.lsRjtRsnCodeExp == LSEXP_PORT_LOGIN_REQ) {\r\nmaxretry = 3;\r\ndelay = 1000;\r\nretry = 1;\r\nbreak;\r\n}\r\ncase LSRJT_PROTOCOL_ERR:\r\nif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\r\n(cmd == ELS_CMD_FDISC) &&\r\n((stat.un.b.lsRjtRsnCodeExp == LSEXP_INVALID_PNAME) ||\r\n(stat.un.b.lsRjtRsnCodeExp == LSEXP_INVALID_NPORT_ID))\r\n) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0122 FDISC Failed (x%x). "\r\n"Fabric Detected Bad WWN\n",\r\nstat.un.lsRjtError);\r\nlpfc_vport_set_state(vport,\r\nFC_VPORT_FABRIC_REJ_WWN);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase IOSTAT_INTERMED_RSP:\r\ncase IOSTAT_BA_RJT:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (did == FDMI_DID)\r\nretry = 1;\r\nif ((cmd == ELS_CMD_FLOGI) &&\r\n(phba->fc_topology != LPFC_TOPOLOGY_LOOP) &&\r\n!lpfc_error_lost_link(irsp)) {\r\nretry = 1;\r\nmaxretry = 0;\r\nif (cmdiocb->retry >= 100)\r\ndelay = 5000;\r\nelse if (cmdiocb->retry >= 32)\r\ndelay = 1000;\r\n} else if ((cmd == ELS_CMD_FDISC) && !lpfc_error_lost_link(irsp)) {\r\nretry = 1;\r\nmaxretry = vport->cfg_devloss_tmo;\r\ndelay = 1000;\r\n}\r\ncmdiocb->retry++;\r\nif (maxretry && (cmdiocb->retry >= maxretry)) {\r\nphba->fc_stat.elsRetryExceeded++;\r\nretry = 0;\r\n}\r\nif ((vport->load_flag & FC_UNLOADING) != 0)\r\nretry = 0;\r\nif (retry) {\r\nif ((cmd == ELS_CMD_PLOGI) || (cmd == ELS_CMD_FDISC)) {\r\nif (phba->fcf.fcf_flag & FCF_DISCOVERY) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"2849 Stop retry ELS command "\r\n"x%x to remote NPORT x%x, "\r\n"Data: x%x x%x\n", cmd, did,\r\ncmdiocb->retry, delay);\r\nreturn 0;\r\n}\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0107 Retry ELS command x%x to remote "\r\n"NPORT x%x Data: x%x x%x\n",\r\ncmd, did, cmdiocb->retry, delay);\r\nif (((cmd == ELS_CMD_PLOGI) || (cmd == ELS_CMD_ADISC)) &&\r\n((irsp->ulpStatus != IOSTAT_LOCAL_REJECT) ||\r\n((irsp->un.ulpWord[4] & 0xff) != IOERR_NO_RESOURCES))) {\r\nif (timer_pending(&vport->fc_disctmo) ||\r\n(vport->fc_flag & FC_RSCN_MODE))\r\nlpfc_set_disctmo(vport);\r\n}\r\nphba->fc_stat.elsXmitRetry++;\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp) && delay) {\r\nphba->fc_stat.elsDelayRetry++;\r\nndlp->nlp_retry = cmdiocb->retry;\r\nmod_timer(&ndlp->nlp_delayfunc,\r\njiffies + msecs_to_jiffies(delay));\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nif (cmd == ELS_CMD_PRLI)\r\nlpfc_nlp_set_state(vport, ndlp,\r\nNLP_STE_REG_LOGIN_ISSUE);\r\nelse\r\nlpfc_nlp_set_state(vport, ndlp,\r\nNLP_STE_NPR_NODE);\r\nndlp->nlp_last_elscmd = cmd;\r\nreturn 1;\r\n}\r\nswitch (cmd) {\r\ncase ELS_CMD_FLOGI:\r\nlpfc_issue_els_flogi(vport, ndlp, cmdiocb->retry);\r\nreturn 1;\r\ncase ELS_CMD_FDISC:\r\nlpfc_issue_els_fdisc(vport, ndlp, cmdiocb->retry);\r\nreturn 1;\r\ncase ELS_CMD_PLOGI:\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp,\r\nNLP_STE_PLOGI_ISSUE);\r\n}\r\nlpfc_issue_els_plogi(vport, did, cmdiocb->retry);\r\nreturn 1;\r\ncase ELS_CMD_ADISC:\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\r\nlpfc_issue_els_adisc(vport, ndlp, cmdiocb->retry);\r\nreturn 1;\r\ncase ELS_CMD_PRLI:\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);\r\nlpfc_issue_els_prli(vport, ndlp, cmdiocb->retry);\r\nreturn 1;\r\ncase ELS_CMD_LOGO:\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nlpfc_issue_els_logo(vport, ndlp, cmdiocb->retry);\r\nreturn 1;\r\n}\r\n}\r\nif (logerr) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0137 No retry ELS command x%x to remote "\r\n"NPORT x%x: Out of Resources: Error:x%x/%x\n",\r\ncmd, did, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\n}\r\nelse {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0108 No retry ELS command x%x to remote "\r\n"NPORT x%x Retried:%d Error:x%x/%x\n",\r\ncmd, did, cmdiocb->retry, irsp->ulpStatus,\r\nirsp->un.ulpWord[4]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_free_data(struct lpfc_hba *phba, struct lpfc_dmabuf *buf_ptr1)\r\n{\r\nstruct lpfc_dmabuf *buf_ptr;\r\nif (!list_empty(&buf_ptr1->list)) {\r\nlist_remove_head(&buf_ptr1->list, buf_ptr,\r\nstruct lpfc_dmabuf,\r\nlist);\r\nlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\r\nkfree(buf_ptr);\r\n}\r\nlpfc_mbuf_free(phba, buf_ptr1->virt, buf_ptr1->phys);\r\nkfree(buf_ptr1);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_free_bpl(struct lpfc_hba *phba, struct lpfc_dmabuf *buf_ptr)\r\n{\r\nlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\r\nkfree(buf_ptr);\r\nreturn 0;\r\n}\r\nint\r\nlpfc_els_free_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *elsiocb)\r\n{\r\nstruct lpfc_dmabuf *buf_ptr, *buf_ptr1;\r\nstruct lpfc_nodelist *ndlp;\r\nndlp = (struct lpfc_nodelist *)elsiocb->context1;\r\nif (ndlp) {\r\nif (ndlp->nlp_flag & NLP_DEFER_RM) {\r\nlpfc_nlp_put(ndlp);\r\nif (!lpfc_nlp_not_used(ndlp)) {\r\nndlp->nlp_flag &= ~NLP_DEFER_RM;\r\n}\r\n}\r\nelse\r\nlpfc_nlp_put(ndlp);\r\nelsiocb->context1 = NULL;\r\n}\r\nif (elsiocb->context2) {\r\nif (elsiocb->iocb_flag & LPFC_DELAY_MEM_FREE) {\r\nelsiocb->iocb_flag &= ~LPFC_DELAY_MEM_FREE;\r\nbuf_ptr = elsiocb->context2;\r\nelsiocb->context2 = NULL;\r\nif (buf_ptr) {\r\nbuf_ptr1 = NULL;\r\nspin_lock_irq(&phba->hbalock);\r\nif (!list_empty(&buf_ptr->list)) {\r\nlist_remove_head(&buf_ptr->list,\r\nbuf_ptr1, struct lpfc_dmabuf,\r\nlist);\r\nINIT_LIST_HEAD(&buf_ptr1->list);\r\nlist_add_tail(&buf_ptr1->list,\r\n&phba->elsbuf);\r\nphba->elsbuf_cnt++;\r\n}\r\nINIT_LIST_HEAD(&buf_ptr->list);\r\nlist_add_tail(&buf_ptr->list, &phba->elsbuf);\r\nphba->elsbuf_cnt++;\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\n} else {\r\nbuf_ptr1 = (struct lpfc_dmabuf *) elsiocb->context2;\r\nlpfc_els_free_data(phba, buf_ptr1);\r\n}\r\n}\r\nif (elsiocb->context3) {\r\nbuf_ptr = (struct lpfc_dmabuf *) elsiocb->context3;\r\nlpfc_els_free_bpl(phba, buf_ptr);\r\n}\r\nlpfc_sli_release_iocbq(phba, elsiocb);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_logo_acc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nIOCB_t *irsp;\r\nirsp = &rspiocb->iocb;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"ACC LOGO cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], ndlp->nlp_DID);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0109 ACC to LOGO completes to NPort x%x "\r\n"Data: x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\nif (ndlp->nlp_state == NLP_STE_NPR_NODE) {\r\nif (!lpfc_nlp_not_used(ndlp)) {\r\nlpfc_unreg_rpi(vport, ndlp);\r\n} else {\r\ncmdiocb->context1 = NULL;\r\n}\r\n}\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nif (ndlp->nlp_type & NLP_FABRIC)\r\nlpfc_nlp_put(ndlp);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_mbx_cmpl_dflt_rpi(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nstruct lpfc_dmabuf *mp = (struct lpfc_dmabuf *) (pmb->context1);\r\nstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) pmb->context2;\r\npmb->context1 = NULL;\r\npmb->context2 = NULL;\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)) {\r\nlpfc_nlp_put(ndlp);\r\nlpfc_nlp_not_used(ndlp);\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_rsp(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\r\nstruct lpfc_vport *vport = ndlp ? ndlp->vport : NULL;\r\nstruct Scsi_Host *shost = vport ? lpfc_shost_from_vport(vport) : NULL;\r\nIOCB_t *irsp;\r\nuint8_t *pcmd;\r\nLPFC_MBOXQ_t *mbox = NULL;\r\nstruct lpfc_dmabuf *mp = NULL;\r\nuint32_t ls_rjt = 0;\r\nirsp = &rspiocb->iocb;\r\nif (cmdiocb->context_un.mbox)\r\nmbox = cmdiocb->context_un.mbox;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) cmdiocb->context2)->virt);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp) &&\r\n(*((uint32_t *) (pcmd)) == ELS_CMD_LS_RJT)) {\r\nif (!(ndlp->nlp_flag & NLP_RM_DFLT_RPI))\r\nls_rjt = 1;\r\n}\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp) || lpfc_els_chk_latt(vport)) {\r\nif (mbox) {\r\nmp = (struct lpfc_dmabuf *) mbox->context1;\r\nif (mp) {\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\n}\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\n}\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp) &&\r\n(ndlp->nlp_flag & NLP_RM_DFLT_RPI))\r\nif (lpfc_nlp_not_used(ndlp)) {\r\nndlp = NULL;\r\ncmdiocb->context1 = NULL;\r\n}\r\ngoto out;\r\n}\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"ELS rsp cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\ncmdiocb->iocb.un.elsreq64.remoteID);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0110 ELS response tag x%x completes "\r\n"Data: x%x x%x x%x x%x x%x x%x x%x\n",\r\ncmdiocb->iocb.ulpIoTag, rspiocb->iocb.ulpStatus,\r\nrspiocb->iocb.un.ulpWord[4], rspiocb->iocb.ulpTimeout,\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\nif (mbox) {\r\nif ((rspiocb->iocb.ulpStatus == 0)\r\n&& (ndlp->nlp_flag & NLP_ACC_REGLOGIN)) {\r\nlpfc_unreg_rpi(vport, ndlp);\r\nmbox->context2 = lpfc_nlp_get(ndlp);\r\nmbox->vport = vport;\r\nif (ndlp->nlp_flag & NLP_RM_DFLT_RPI) {\r\nmbox->mbox_flag |= LPFC_MBX_IMED_UNREG;\r\nmbox->mbox_cmpl = lpfc_mbx_cmpl_dflt_rpi;\r\n}\r\nelse {\r\nmbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp,\r\nNLP_STE_REG_LOGIN_ISSUE);\r\n}\r\nif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\r\n!= MBX_NOT_FINISHED)\r\ngoto out;\r\nelse\r\nlpfc_nlp_put(ndlp);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0138 ELS rsp: Cannot issue reg_login for x%x "\r\n"Data: x%x x%x x%x\n",\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\nif (lpfc_nlp_not_used(ndlp)) {\r\nndlp = NULL;\r\ncmdiocb->context1 = NULL;\r\n}\r\n} else {\r\nif (!lpfc_error_lost_link(irsp) &&\r\nndlp->nlp_flag & NLP_ACC_REGLOGIN) {\r\nif (lpfc_nlp_not_used(ndlp)) {\r\nndlp = NULL;\r\ncmdiocb->context1 = NULL;\r\n}\r\n}\r\n}\r\nmp = (struct lpfc_dmabuf *) mbox->context1;\r\nif (mp) {\r\nlpfc_mbuf_free(phba, mp->virt, mp->phys);\r\nkfree(mp);\r\n}\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\n}\r\nout:\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~(NLP_ACC_REGLOGIN | NLP_RM_DFLT_RPI);\r\nspin_unlock_irq(shost->host_lock);\r\nif (ls_rjt)\r\nif (lpfc_nlp_not_used(ndlp))\r\ncmdiocb->context1 = NULL;\r\n}\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nreturn;\r\n}\r\nint\r\nlpfc_els_rsp_acc(struct lpfc_vport *vport, uint32_t flag,\r\nstruct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp,\r\nLPFC_MBOXQ_t *mbox)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nIOCB_t *oldcmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli *psli;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint rc;\r\nELS_PKT *els_pkt_ptr;\r\npsli = &phba->sli;\r\noldcmd = &oldiocb->iocb;\r\nswitch (flag) {\r\ncase ELS_CMD_ACC:\r\ncmdsize = sizeof(uint32_t);\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\r\nndlp, ndlp->nlp_DID, ELS_CMD_ACC);\r\nif (!elsiocb) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_LOGO_ACC;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn 1;\r\n}\r\nicmd = &elsiocb->iocb;\r\nicmd->ulpContext = oldcmd->ulpContext;\r\nicmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\r\npcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint32_t);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Issue ACC: did:x%x flg:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, 0);\r\nbreak;\r\ncase ELS_CMD_PLOGI:\r\ncmdsize = (sizeof(struct serv_parm) + sizeof(uint32_t));\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\r\nndlp, ndlp->nlp_DID, ELS_CMD_ACC);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\nicmd->ulpContext = oldcmd->ulpContext;\r\nicmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\r\npcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\nif (mbox)\r\nelsiocb->context_un.mbox = mbox;\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, &vport->fc_sparam, sizeof(struct serv_parm));\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Issue ACC PLOGI: did:x%x flg:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, 0);\r\nbreak;\r\ncase ELS_CMD_PRLO:\r\ncmdsize = sizeof(uint32_t) + sizeof(PRLO);\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\r\nndlp, ndlp->nlp_DID, ELS_CMD_PRLO);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\nicmd->ulpContext = oldcmd->ulpContext;\r\nicmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\r\npcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\nmemcpy(pcmd, ((struct lpfc_dmabuf *) oldiocb->context2)->virt,\r\nsizeof(uint32_t) + sizeof(PRLO));\r\n*((uint32_t *) (pcmd)) = ELS_CMD_PRLO_ACC;\r\nels_pkt_ptr = (ELS_PKT *) pcmd;\r\nels_pkt_ptr->un.prlo.acceptRspCode = PRLO_REQ_EXECUTED;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Issue ACC PRLO: did:x%x flg:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, 0);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0128 Xmit ELS ACC response tag x%x, XRI: x%x, "\r\n"DID: x%x, nlp_flag: x%x nlp_state: x%x RPI: x%x "\r\n"fc_flag x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext,\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi, vport->fc_flag);\r\nif (ndlp->nlp_flag & NLP_LOGO_ACC) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_LOGO_ACC;\r\nspin_unlock_irq(shost->host_lock);\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_logo_acc;\r\n} else {\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\n}\r\nphba->fc_stat.elsXmitACC++;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlpfc_els_rsp_reject(struct lpfc_vport *vport, uint32_t rejectError,\r\nstruct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp,\r\nLPFC_MBOXQ_t *mbox)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nIOCB_t *oldcmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli *psli;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint rc;\r\npsli = &phba->sli;\r\ncmdsize = 2 * sizeof(uint32_t);\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_LS_RJT);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\noldcmd = &oldiocb->iocb;\r\nicmd->ulpContext = oldcmd->ulpContext;\r\nicmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_LS_RJT;\r\npcmd += sizeof(uint32_t);\r\n*((uint32_t *) (pcmd)) = rejectError;\r\nif (mbox)\r\nelsiocb->context_un.mbox = mbox;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0129 Xmit ELS RJT x%x response tag x%x "\r\n"xri x%x, did x%x, nlp_flag x%x, nlp_state x%x, "\r\n"rpi x%x\n",\r\nrejectError, elsiocb->iotag,\r\nelsiocb->iocb.ulpContext, ndlp->nlp_DID,\r\nndlp->nlp_flag, ndlp->nlp_state, ndlp->nlp_rpi);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Issue LS_RJT: did:x%x flg:x%x err:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, rejectError);\r\nphba->fc_stat.elsXmitLSRJT++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlpfc_els_rsp_adisc_acc(struct lpfc_vport *vport, struct lpfc_iocbq *oldiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nADISC *ap;\r\nIOCB_t *icmd, *oldcmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint rc;\r\ncmdsize = sizeof(uint32_t) + sizeof(ADISC);\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_ACC);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\noldcmd = &oldiocb->iocb;\r\nicmd->ulpContext = oldcmd->ulpContext;\r\nicmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0130 Xmit ADISC ACC response iotag x%x xri: "\r\n"x%x, did x%x, nlp_flag x%x, nlp_state x%x rpi x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext,\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint32_t);\r\nap = (ADISC *) (pcmd);\r\nap->hardAL_PA = phba->fc_pref_ALPA;\r\nmemcpy(&ap->portName, &vport->fc_portname, sizeof(struct lpfc_name));\r\nmemcpy(&ap->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\r\nap->DID = be32_to_cpu(vport->fc_myDID);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Issue ACC ADISC: did:x%x flg:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, 0);\r\nphba->fc_stat.elsXmitACC++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlpfc_els_rsp_prli_acc(struct lpfc_vport *vport, struct lpfc_iocbq *oldiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nPRLI *npr;\r\nlpfc_vpd_t *vpd;\r\nIOCB_t *icmd;\r\nIOCB_t *oldcmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli *psli;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint rc;\r\npsli = &phba->sli;\r\ncmdsize = sizeof(uint32_t) + sizeof(PRLI);\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\r\nndlp->nlp_DID, (ELS_CMD_ACC | (ELS_CMD_PRLI & ~ELS_RSP_MASK)));\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\noldcmd = &oldiocb->iocb;\r\nicmd->ulpContext = oldcmd->ulpContext;\r\nicmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0131 Xmit PRLI ACC response tag x%x xri x%x, "\r\n"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext,\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = (ELS_CMD_ACC | (ELS_CMD_PRLI & ~ELS_RSP_MASK));\r\npcmd += sizeof(uint32_t);\r\nmemset(pcmd, 0, sizeof(PRLI));\r\nnpr = (PRLI *) pcmd;\r\nvpd = &phba->vpd;\r\nif ((ndlp->nlp_type & NLP_FCP_TARGET) &&\r\n(vpd->rev.feaLevelHigh >= 0x02)) {\r\nnpr->ConfmComplAllowed = 1;\r\nnpr->Retry = 1;\r\nnpr->TaskRetryIdReq = 1;\r\n}\r\nnpr->acceptRspCode = PRLI_REQ_EXECUTED;\r\nnpr->estabImagePair = 1;\r\nnpr->readXferRdyDis = 1;\r\nnpr->ConfmComplAllowed = 1;\r\nnpr->prliType = PRLI_FCP_TYPE;\r\nnpr->initiatorFunc = 1;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Issue ACC PRLI: did:x%x flg:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, 0);\r\nphba->fc_stat.elsXmitACC++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rsp_rnid_acc(struct lpfc_vport *vport, uint8_t format,\r\nstruct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nRNID *rn;\r\nIOCB_t *icmd, *oldcmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli *psli;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint rc;\r\npsli = &phba->sli;\r\ncmdsize = sizeof(uint32_t) + sizeof(uint32_t)\r\n+ (2 * sizeof(struct lpfc_name));\r\nif (format)\r\ncmdsize += sizeof(RNID_TOP_DISC);\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_ACC);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\noldcmd = &oldiocb->iocb;\r\nicmd->ulpContext = oldcmd->ulpContext;\r\nicmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0132 Xmit RNID ACC response tag x%x xri x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext);\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint32_t);\r\nmemset(pcmd, 0, sizeof(RNID));\r\nrn = (RNID *) (pcmd);\r\nrn->Format = format;\r\nrn->CommonLen = (2 * sizeof(struct lpfc_name));\r\nmemcpy(&rn->portName, &vport->fc_portname, sizeof(struct lpfc_name));\r\nmemcpy(&rn->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\r\nswitch (format) {\r\ncase 0:\r\nrn->SpecificLen = 0;\r\nbreak;\r\ncase RNID_TOPOLOGY_DISC:\r\nrn->SpecificLen = sizeof(RNID_TOP_DISC);\r\nmemcpy(&rn->un.topologyDisc.portName,\r\n&vport->fc_portname, sizeof(struct lpfc_name));\r\nrn->un.topologyDisc.unitType = RNID_HBA;\r\nrn->un.topologyDisc.physPort = 0;\r\nrn->un.topologyDisc.attachedNodes = 0;\r\nbreak;\r\ndefault:\r\nrn->CommonLen = 0;\r\nrn->SpecificLen = 0;\r\nbreak;\r\n}\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Issue ACC RNID: did:x%x flg:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, 0);\r\nphba->fc_stat.elsXmitACC++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_els_clear_rrq(struct lpfc_vport *vport,\r\nstruct lpfc_iocbq *iocb, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint8_t *pcmd;\r\nstruct RRQ *rrq;\r\nuint16_t rxid;\r\nuint16_t xri;\r\nstruct lpfc_node_rrq *prrq;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) iocb->context2)->virt);\r\npcmd += sizeof(uint32_t);\r\nrrq = (struct RRQ *)pcmd;\r\nrrq->rrq_exchg = be32_to_cpu(rrq->rrq_exchg);\r\nrxid = bf_get(rrq_rxid, rrq);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"2883 Clear RRQ for SID:x%x OXID:x%x RXID:x%x"\r\n" x%x x%x\n",\r\nbe32_to_cpu(bf_get(rrq_did, rrq)),\r\nbf_get(rrq_oxid, rrq),\r\nrxid,\r\niocb->iotag, iocb->iocb.ulpContext);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Clear RRQ: did:x%x flg:x%x exchg:x%.08x",\r\nndlp->nlp_DID, ndlp->nlp_flag, rrq->rrq_exchg);\r\nif (vport->fc_myDID == be32_to_cpu(bf_get(rrq_did, rrq)))\r\nxri = bf_get(rrq_oxid, rrq);\r\nelse\r\nxri = rxid;\r\nprrq = lpfc_get_active_rrq(vport, xri, ndlp->nlp_DID);\r\nif (prrq)\r\nlpfc_clr_rrq_active(phba, xri, prrq);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_els_rsp_echo_acc(struct lpfc_vport *vport, uint8_t *data,\r\nstruct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_sli *psli;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint rc;\r\npsli = &phba->sli;\r\ncmdsize = oldiocb->iocb.unsli3.rcvsli3.acc_len;\r\nif (cmdsize > LPFC_BPL_SIZE)\r\ncmdsize = LPFC_BPL_SIZE;\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_ACC);\r\nif (!elsiocb)\r\nreturn 1;\r\nelsiocb->iocb.ulpContext = oldiocb->iocb.ulpContext;\r\nelsiocb->iocb.unsli3.rcvsli3.ox_id = oldiocb->iocb.unsli3.rcvsli3.ox_id;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"2876 Xmit ECHO ACC response tag x%x xri x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext);\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, data, cmdsize - sizeof(uint32_t));\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\r\n"Issue ACC ECHO: did:x%x flg:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, 0);\r\nphba->fc_stat.elsXmitACC++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nrc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlpfc_els_disc_adisc(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_nodelist *ndlp, *next_ndlp;\r\nint sentadisc = 0;\r\nlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp))\r\ncontinue;\r\nif (ndlp->nlp_state == NLP_STE_NPR_NODE &&\r\n(ndlp->nlp_flag & NLP_NPR_2B_DISC) != 0 &&\r\n(ndlp->nlp_flag & NLP_NPR_ADISC) != 0) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_NPR_ADISC;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\r\nlpfc_issue_els_adisc(vport, ndlp, 0);\r\nsentadisc++;\r\nvport->num_disc_nodes++;\r\nif (vport->num_disc_nodes >=\r\nvport->cfg_discovery_threads) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_NLP_MORE;\r\nspin_unlock_irq(shost->host_lock);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (sentadisc == 0) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_NLP_MORE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nreturn sentadisc;\r\n}\r\nint\r\nlpfc_els_disc_plogi(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_nodelist *ndlp, *next_ndlp;\r\nint sentplogi = 0;\r\nlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp))\r\ncontinue;\r\nif (ndlp->nlp_state == NLP_STE_NPR_NODE &&\r\n(ndlp->nlp_flag & NLP_NPR_2B_DISC) != 0 &&\r\n(ndlp->nlp_flag & NLP_DELAY_TMO) == 0 &&\r\n(ndlp->nlp_flag & NLP_NPR_ADISC) == 0) {\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\r\nlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\r\nsentplogi++;\r\nvport->num_disc_nodes++;\r\nif (vport->num_disc_nodes >=\r\nvport->cfg_discovery_threads) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_NLP_MORE;\r\nspin_unlock_irq(shost->host_lock);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (sentplogi) {\r\nlpfc_set_disctmo(vport);\r\n}\r\nelse {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_NLP_MORE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nreturn sentplogi;\r\n}\r\nvoid\r\nlpfc_els_flush_rscn(struct lpfc_vport *vport)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nint i;\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->fc_rscn_flush) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn;\r\n}\r\nvport->fc_rscn_flush = 1;\r\nspin_unlock_irq(shost->host_lock);\r\nfor (i = 0; i < vport->fc_rscn_id_cnt; i++) {\r\nlpfc_in_buf_free(phba, vport->fc_rscn_id_list[i]);\r\nvport->fc_rscn_id_list[i] = NULL;\r\n}\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_rscn_id_cnt = 0;\r\nvport->fc_flag &= ~(FC_RSCN_MODE | FC_RSCN_DISCOVERY);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_can_disctmo(vport);\r\nvport->fc_rscn_flush = 0;\r\n}\r\nint\r\nlpfc_rscn_payload_check(struct lpfc_vport *vport, uint32_t did)\r\n{\r\nD_ID ns_did;\r\nD_ID rscn_did;\r\nuint32_t *lp;\r\nuint32_t payload_len, i;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nns_did.un.word = did;\r\nif ((did & Fabric_DID_MASK) == Fabric_DID_MASK)\r\nreturn 0;\r\nif (vport->fc_flag & FC_RSCN_DISCOVERY)\r\nreturn did;\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->fc_rscn_flush) {\r\nspin_unlock_irq(shost->host_lock);\r\nreturn 0;\r\n}\r\nvport->fc_rscn_flush = 1;\r\nspin_unlock_irq(shost->host_lock);\r\nfor (i = 0; i < vport->fc_rscn_id_cnt; i++) {\r\nlp = vport->fc_rscn_id_list[i]->virt;\r\npayload_len = be32_to_cpu(*lp++ & ~ELS_CMD_MASK);\r\npayload_len -= sizeof(uint32_t);\r\nwhile (payload_len) {\r\nrscn_did.un.word = be32_to_cpu(*lp++);\r\npayload_len -= sizeof(uint32_t);\r\nswitch (rscn_did.un.b.resv & RSCN_ADDRESS_FORMAT_MASK) {\r\ncase RSCN_ADDRESS_FORMAT_PORT:\r\nif ((ns_did.un.b.domain == rscn_did.un.b.domain)\r\n&& (ns_did.un.b.area == rscn_did.un.b.area)\r\n&& (ns_did.un.b.id == rscn_did.un.b.id))\r\ngoto return_did_out;\r\nbreak;\r\ncase RSCN_ADDRESS_FORMAT_AREA:\r\nif ((ns_did.un.b.domain == rscn_did.un.b.domain)\r\n&& (ns_did.un.b.area == rscn_did.un.b.area))\r\ngoto return_did_out;\r\nbreak;\r\ncase RSCN_ADDRESS_FORMAT_DOMAIN:\r\nif (ns_did.un.b.domain == rscn_did.un.b.domain)\r\ngoto return_did_out;\r\nbreak;\r\ncase RSCN_ADDRESS_FORMAT_FABRIC:\r\ngoto return_did_out;\r\n}\r\n}\r\n}\r\nvport->fc_rscn_flush = 0;\r\nreturn 0;\r\nreturn_did_out:\r\nvport->fc_rscn_flush = 0;\r\nreturn did;\r\n}\r\nstatic int\r\nlpfc_rscn_recovery_check(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_nodelist *ndlp = NULL;\r\nlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp) ||\r\n(ndlp->nlp_state == NLP_STE_UNUSED_NODE) ||\r\n!lpfc_rscn_payload_check(vport, ndlp->nlp_DID))\r\ncontinue;\r\nlpfc_disc_state_machine(vport, ndlp, NULL,\r\nNLP_EVT_DEVICE_RECOVERY);\r\nlpfc_cancel_retry_delay_tmo(vport, ndlp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_send_rscn_event(struct lpfc_vport *vport,\r\nstruct lpfc_iocbq *cmdiocb)\r\n{\r\nstruct lpfc_dmabuf *pcmd;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nuint32_t *payload_ptr;\r\nuint32_t payload_len;\r\nstruct lpfc_rscn_event_header *rscn_event_data;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\npayload_ptr = (uint32_t *) pcmd->virt;\r\npayload_len = be32_to_cpu(*payload_ptr & ~ELS_CMD_MASK);\r\nrscn_event_data = kmalloc(sizeof(struct lpfc_rscn_event_header) +\r\npayload_len, GFP_KERNEL);\r\nif (!rscn_event_data) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0147 Failed to allocate memory for RSCN event\n");\r\nreturn;\r\n}\r\nrscn_event_data->event_type = FC_REG_RSCN_EVENT;\r\nrscn_event_data->payload_length = payload_len;\r\nmemcpy(rscn_event_data->rscn_payload, payload_ptr,\r\npayload_len);\r\nfc_host_post_vendor_event(shost,\r\nfc_get_event_number(),\r\nsizeof(struct lpfc_els_event_header) + payload_len,\r\n(char *)rscn_event_data,\r\nLPFC_NL_VENDOR_ID);\r\nkfree(rscn_event_data);\r\n}\r\nstatic int\r\nlpfc_els_rcv_rscn(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_dmabuf *pcmd;\r\nuint32_t *lp, *datap;\r\nIOCB_t *icmd;\r\nuint32_t payload_len, length, nportid, *cmd;\r\nint rscn_cnt;\r\nint rscn_id = 0, hba_id = 0;\r\nint i;\r\nicmd = &cmdiocb->iocb;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\npayload_len = be32_to_cpu(*lp++ & ~ELS_CMD_MASK);\r\npayload_len -= sizeof(uint32_t);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0214 RSCN received Data: x%x x%x x%x x%x\n",\r\nvport->fc_flag, payload_len, *lp,\r\nvport->fc_rscn_id_cnt);\r\nlpfc_send_rscn_event(vport, cmdiocb);\r\nfor (i = 0; i < payload_len/sizeof(uint32_t); i++)\r\nfc_host_post_event(shost, fc_get_event_number(),\r\nFCH_EVT_RSCN, lp[i]);\r\nif (vport->port_state <= LPFC_NS_QRY) {\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RSCN ignore: did:x%x/ste:x%x flg:x%x",\r\nndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nreturn 0;\r\n}\r\nif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\r\n!(vport->cfg_peer_port_login)) {\r\ni = payload_len;\r\ndatap = lp;\r\nwhile (i > 0) {\r\nnportid = *datap++;\r\nnportid = ((be32_to_cpu(nportid)) & Mask_DID);\r\ni -= sizeof(uint32_t);\r\nrscn_id++;\r\nif (lpfc_find_vport_by_did(phba, nportid))\r\nhba_id++;\r\n}\r\nif (rscn_id == hba_id) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0219 Ignore RSCN "\r\n"Data: x%x x%x x%x x%x\n",\r\nvport->fc_flag, payload_len,\r\n*lp, vport->fc_rscn_id_cnt);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RSCN vport: did:x%x/ste:x%x flg:x%x",\r\nndlp->nlp_DID, vport->port_state,\r\nndlp->nlp_flag);\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb,\r\nndlp, NULL);\r\nreturn 0;\r\n}\r\n}\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->fc_rscn_flush) {\r\nvport->fc_flag |= FC_RSCN_DISCOVERY;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nreturn 0;\r\n}\r\nvport->fc_rscn_flush = 1;\r\nspin_unlock_irq(shost->host_lock);\r\nrscn_cnt = vport->fc_rscn_id_cnt;\r\nif (vport->fc_flag & (FC_RSCN_MODE | FC_NDISC_ACTIVE)) {\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RSCN defer: did:x%x/ste:x%x flg:x%x",\r\nndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_RSCN_DEFERRED;\r\nif ((rscn_cnt < FC_MAX_HOLD_RSCN) &&\r\n!(vport->fc_flag & FC_RSCN_DISCOVERY)) {\r\nvport->fc_flag |= FC_RSCN_MODE;\r\nspin_unlock_irq(shost->host_lock);\r\nif (rscn_cnt) {\r\ncmd = vport->fc_rscn_id_list[rscn_cnt-1]->virt;\r\nlength = be32_to_cpu(*cmd & ~ELS_CMD_MASK);\r\n}\r\nif ((rscn_cnt) &&\r\n(payload_len + length <= LPFC_BPL_SIZE)) {\r\n*cmd &= ELS_CMD_MASK;\r\n*cmd |= cpu_to_be32(payload_len + length);\r\nmemcpy(((uint8_t *)cmd) + length, lp,\r\npayload_len);\r\n} else {\r\nvport->fc_rscn_id_list[rscn_cnt] = pcmd;\r\nvport->fc_rscn_id_cnt++;\r\ncmdiocb->context2 = NULL;\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0235 Deferred RSCN "\r\n"Data: x%x x%x x%x\n",\r\nvport->fc_rscn_id_cnt, vport->fc_flag,\r\nvport->port_state);\r\n} else {\r\nvport->fc_flag |= FC_RSCN_DISCOVERY;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0234 ReDiscovery RSCN "\r\n"Data: x%x x%x x%x\n",\r\nvport->fc_rscn_id_cnt, vport->fc_flag,\r\nvport->port_state);\r\n}\r\nvport->fc_rscn_flush = 0;\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nlpfc_rscn_recovery_check(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_RSCN_DEFERRED;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn 0;\r\n}\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RSCN: did:x%x/ste:x%x flg:x%x",\r\nndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_RSCN_MODE;\r\nspin_unlock_irq(shost->host_lock);\r\nvport->fc_rscn_id_list[vport->fc_rscn_id_cnt++] = pcmd;\r\nvport->fc_rscn_flush = 0;\r\ncmdiocb->context2 = NULL;\r\nlpfc_set_disctmo(vport);\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nlpfc_rscn_recovery_check(vport);\r\nreturn lpfc_els_handle_rscn(vport);\r\n}\r\nint\r\nlpfc_els_handle_rscn(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_hba *phba = vport->phba;\r\nif (vport->load_flag & FC_UNLOADING) {\r\nlpfc_els_flush_rscn(vport);\r\nreturn 0;\r\n}\r\nlpfc_set_disctmo(vport);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\r\n"0215 RSCN processed Data: x%x x%x x%x x%x\n",\r\nvport->fc_flag, 0, vport->fc_rscn_id_cnt,\r\nvport->port_state);\r\nvport->fc_ns_retry = 0;\r\nvport->num_disc_nodes = 0;\r\nndlp = lpfc_findnode_did(vport, NameServer_DID);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp)\r\n&& ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) {\r\nif (lpfc_ns_cmd(vport, SLI_CTNS_GID_FT, 0, 0) == 0)\r\nreturn 1;\r\n} else {\r\nndlp = lpfc_findnode_did(vport, NameServer_DID);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp))\r\nreturn 1;\r\nif (ndlp) {\r\nndlp = lpfc_enable_node(vport, ndlp,\r\nNLP_STE_PLOGI_ISSUE);\r\nif (!ndlp) {\r\nlpfc_els_flush_rscn(vport);\r\nreturn 0;\r\n}\r\nndlp->nlp_prev_state = NLP_STE_UNUSED_NODE;\r\n} else {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp) {\r\nlpfc_els_flush_rscn(vport);\r\nreturn 0;\r\n}\r\nlpfc_nlp_init(vport, ndlp, NameServer_DID);\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\r\n}\r\nndlp->nlp_type |= NLP_FABRIC;\r\nlpfc_issue_els_plogi(vport, NameServer_DID, 0);\r\nreturn 1;\r\n}\r\nlpfc_els_flush_rscn(vport);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_flogi(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_dmabuf *pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nuint32_t *lp = (uint32_t *) pcmd->virt;\r\nIOCB_t *icmd = &cmdiocb->iocb;\r\nstruct serv_parm *sp;\r\nLPFC_MBOXQ_t *mbox;\r\nstruct ls_rjt stat;\r\nuint32_t cmd, did;\r\nint rc;\r\ncmd = *lp++;\r\nsp = (struct serv_parm *) lp;\r\nlpfc_set_disctmo(vport);\r\nif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\r\ndid = icmd->un.elsreq64.remoteID;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0113 An FLOGI ELS command x%x was "\r\n"received from DID x%x in Loop Mode\n",\r\ncmd, did);\r\nreturn 1;\r\n}\r\nif ((lpfc_check_sparm(vport, ndlp, sp, CLASS3, 1))) {\r\nrc = memcmp(&vport->fc_portname, &sp->portName,\r\nsizeof(struct lpfc_name));\r\nif (!rc) {\r\nif (phba->sli_rev < LPFC_SLI_REV4) {\r\nmbox = mempool_alloc(phba->mbox_mem_pool,\r\nGFP_KERNEL);\r\nif (!mbox)\r\nreturn 1;\r\nlpfc_linkdown(phba);\r\nlpfc_init_link(phba, mbox,\r\nphba->cfg_topology,\r\nphba->cfg_link_speed);\r\nmbox->u.mb.un.varInitLnk.lipsr_AL_PA = 0;\r\nmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nmbox->vport = vport;\r\nrc = lpfc_sli_issue_mbox(phba, mbox,\r\nMBX_NOWAIT);\r\nlpfc_set_loopback_flag(phba);\r\nif (rc == MBX_NOT_FINISHED)\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nreturn 1;\r\n} else {\r\nlpfc_els_abort_flogi(phba);\r\nreturn 0;\r\n}\r\n} else if (rc > 0) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_PT2PT_PLOGI;\r\nspin_unlock_irq(shost->host_lock);\r\nvport->fc_myDID = PT2PT_LocalID;\r\n}\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_PT2PT;\r\nvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\r\nspin_unlock_irq(shost->host_lock);\r\ndid = vport->fc_myDID;\r\nvport->fc_myDID = Fabric_DID;\r\n} else {\r\nstat.un.b.lsRjtRsvd0 = 0;\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;\r\nstat.un.b.vendorUnique = 0;\r\ndid = vport->fc_myDID;\r\nvport->fc_myDID = Fabric_DID;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\r\nNULL);\r\nvport->fc_myDID = did;\r\nreturn 1;\r\n}\r\nlpfc_els_rsp_acc(vport, ELS_CMD_PLOGI, cmdiocb, ndlp, NULL);\r\nvport->fc_myDID = did;\r\nif (!(vport->fc_flag & FC_PT2PT_PLOGI)) {\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (!mbox)\r\ngoto fail;\r\nlpfc_config_link(phba, mbox);\r\nmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nmbox->vport = vport;\r\nrc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nreturn 1;\r\n}\r\nstatic int\r\nlpfc_els_rcv_rnid(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_dmabuf *pcmd;\r\nuint32_t *lp;\r\nIOCB_t *icmd;\r\nRNID *rn;\r\nstruct ls_rjt stat;\r\nuint32_t cmd, did;\r\nicmd = &cmdiocb->iocb;\r\ndid = icmd->un.elsreq64.remoteID;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\ncmd = *lp++;\r\nrn = (RNID *) lp;\r\nswitch (rn->Format) {\r\ncase 0:\r\ncase RNID_TOPOLOGY_DISC:\r\nlpfc_els_rsp_rnid_acc(vport, rn->Format, cmdiocb, ndlp);\r\nbreak;\r\ndefault:\r\nstat.un.b.lsRjtRsvd0 = 0;\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\r\nstat.un.b.vendorUnique = 0;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\r\nNULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_echo(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nuint8_t *pcmd;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) cmdiocb->context2)->virt);\r\npcmd += sizeof(uint32_t);\r\nlpfc_els_rsp_echo_acc(vport, pcmd, cmdiocb, ndlp);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_lirr(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct ls_rjt stat;\r\nstat.un.b.lsRjtRsvd0 = 0;\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\r\nstat.un.b.vendorUnique = 0;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_els_rcv_rrq(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nif (vport->phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_els_clear_rrq(vport, cmdiocb, ndlp);\r\n}\r\nstatic void\r\nlpfc_els_rsp_rls_acc(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t *mb;\r\nIOCB_t *icmd;\r\nstruct RLS_RSP *rls_rsp;\r\nuint8_t *pcmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_nodelist *ndlp;\r\nuint16_t oxid;\r\nuint16_t rxid;\r\nuint32_t cmdsize;\r\nmb = &pmb->u.mb;\r\nndlp = (struct lpfc_nodelist *) pmb->context2;\r\nrxid = (uint16_t) ((unsigned long)(pmb->context1) & 0xffff);\r\noxid = (uint16_t) (((unsigned long)(pmb->context1) >> 16) & 0xffff);\r\npmb->context1 = NULL;\r\npmb->context2 = NULL;\r\nif (mb->mbxStatus) {\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\ncmdsize = sizeof(struct RLS_RSP) + sizeof(uint32_t);\r\nelsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\r\nlpfc_max_els_tries, ndlp,\r\nndlp->nlp_DID, ELS_CMD_ACC);\r\nlpfc_nlp_put(ndlp);\r\nif (!elsiocb) {\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nicmd = &elsiocb->iocb;\r\nicmd->ulpContext = rxid;\r\nicmd->unsli3.rcvsli3.ox_id = oxid;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint32_t);\r\nrls_rsp = (struct RLS_RSP *)pcmd;\r\nrls_rsp->linkFailureCnt = cpu_to_be32(mb->un.varRdLnk.linkFailureCnt);\r\nrls_rsp->lossSyncCnt = cpu_to_be32(mb->un.varRdLnk.lossSyncCnt);\r\nrls_rsp->lossSignalCnt = cpu_to_be32(mb->un.varRdLnk.lossSignalCnt);\r\nrls_rsp->primSeqErrCnt = cpu_to_be32(mb->un.varRdLnk.primSeqErrCnt);\r\nrls_rsp->invalidXmitWord = cpu_to_be32(mb->un.varRdLnk.invalidXmitWord);\r\nrls_rsp->crcCnt = cpu_to_be32(mb->un.varRdLnk.crcCnt);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_ELS,\r\n"2874 Xmit ELS RLS ACC response tag x%x xri x%x, "\r\n"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext,\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nphba->fc_stat.elsXmitACC++;\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) == IOCB_ERROR)\r\nlpfc_els_free_iocb(phba, elsiocb);\r\n}\r\nstatic void\r\nlpfc_els_rsp_rps_acc(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t *mb;\r\nIOCB_t *icmd;\r\nRPS_RSP *rps_rsp;\r\nuint8_t *pcmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct lpfc_nodelist *ndlp;\r\nuint16_t status;\r\nuint16_t oxid;\r\nuint16_t rxid;\r\nuint32_t cmdsize;\r\nmb = &pmb->u.mb;\r\nndlp = (struct lpfc_nodelist *) pmb->context2;\r\nrxid = (uint16_t) ((unsigned long)(pmb->context1) & 0xffff);\r\noxid = (uint16_t) (((unsigned long)(pmb->context1) >> 16) & 0xffff);\r\npmb->context1 = NULL;\r\npmb->context2 = NULL;\r\nif (mb->mbxStatus) {\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\ncmdsize = sizeof(RPS_RSP) + sizeof(uint32_t);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nelsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\r\nlpfc_max_els_tries, ndlp,\r\nndlp->nlp_DID, ELS_CMD_ACC);\r\nlpfc_nlp_put(ndlp);\r\nif (!elsiocb)\r\nreturn;\r\nicmd = &elsiocb->iocb;\r\nicmd->ulpContext = rxid;\r\nicmd->unsli3.rcvsli3.ox_id = oxid;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint32_t);\r\nrps_rsp = (RPS_RSP *)pcmd;\r\nif (phba->fc_topology != LPFC_TOPOLOGY_LOOP)\r\nstatus = 0x10;\r\nelse\r\nstatus = 0x8;\r\nif (phba->pport->fc_flag & FC_FABRIC)\r\nstatus |= 0x4;\r\nrps_rsp->rsvd1 = 0;\r\nrps_rsp->portStatus = cpu_to_be16(status);\r\nrps_rsp->linkFailureCnt = cpu_to_be32(mb->un.varRdLnk.linkFailureCnt);\r\nrps_rsp->lossSyncCnt = cpu_to_be32(mb->un.varRdLnk.lossSyncCnt);\r\nrps_rsp->lossSignalCnt = cpu_to_be32(mb->un.varRdLnk.lossSignalCnt);\r\nrps_rsp->primSeqErrCnt = cpu_to_be32(mb->un.varRdLnk.primSeqErrCnt);\r\nrps_rsp->invalidXmitWord = cpu_to_be32(mb->un.varRdLnk.invalidXmitWord);\r\nrps_rsp->crcCnt = cpu_to_be32(mb->un.varRdLnk.crcCnt);\r\nlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_ELS,\r\n"0118 Xmit ELS RPS ACC response tag x%x xri x%x, "\r\n"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext,\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nphba->fc_stat.elsXmitACC++;\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) == IOCB_ERROR)\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_els_rcv_rls(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nLPFC_MBOXQ_t *mbox;\r\nstruct lpfc_dmabuf *pcmd;\r\nstruct ls_rjt stat;\r\nif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\r\n(ndlp->nlp_state != NLP_STE_MAPPED_NODE))\r\ngoto reject_out;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_ATOMIC);\r\nif (mbox) {\r\nlpfc_read_lnk_stat(phba, mbox);\r\nmbox->context1 = (void *)((unsigned long)\r\n((cmdiocb->iocb.unsli3.rcvsli3.ox_id << 16) |\r\ncmdiocb->iocb.ulpContext));\r\nmbox->context2 = lpfc_nlp_get(ndlp);\r\nmbox->vport = vport;\r\nmbox->mbox_cmpl = lpfc_els_rsp_rls_acc;\r\nif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\r\n!= MBX_NOT_FINISHED)\r\nreturn 0;\r\nlpfc_nlp_put(ndlp);\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\n}\r\nreject_out:\r\nstat.un.b.lsRjtRsvd0 = 0;\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\r\nstat.un.b.vendorUnique = 0;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_rtv(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct ls_rjt stat;\r\nstruct RTV_RSP *rtv_rsp;\r\nuint8_t *pcmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nuint32_t cmdsize;\r\nif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\r\n(ndlp->nlp_state != NLP_STE_MAPPED_NODE))\r\ngoto reject_out;\r\ncmdsize = sizeof(struct RTV_RSP) + sizeof(uint32_t);\r\nelsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\r\nlpfc_max_els_tries, ndlp,\r\nndlp->nlp_DID, ELS_CMD_ACC);\r\nif (!elsiocb)\r\nreturn 1;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint32_t);\r\nelsiocb->iocb.ulpContext = cmdiocb->iocb.ulpContext;\r\nelsiocb->iocb.unsli3.rcvsli3.ox_id = cmdiocb->iocb.unsli3.rcvsli3.ox_id;\r\nrtv_rsp = (struct RTV_RSP *)pcmd;\r\nrtv_rsp->ratov = cpu_to_be32(phba->fc_ratov * 1000);\r\nrtv_rsp->edtov = cpu_to_be32(phba->fc_edtov);\r\nbf_set(qtov_edtovres, rtv_rsp, phba->fc_edtovResol ? 1 : 0);\r\nbf_set(qtov_rttov, rtv_rsp, 0);\r\nrtv_rsp->qtov = cpu_to_be32(rtv_rsp->qtov);\r\nlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_ELS,\r\n"2875 Xmit ELS RTV ACC response tag x%x xri x%x, "\r\n"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x, "\r\n"Data: x%x x%x x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext,\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi,\r\nrtv_rsp->ratov, rtv_rsp->edtov, rtv_rsp->qtov);\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nphba->fc_stat.elsXmitACC++;\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) == IOCB_ERROR)\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 0;\r\nreject_out:\r\nstat.un.b.lsRjtRsvd0 = 0;\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\r\nstat.un.b.vendorUnique = 0;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_rps(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t *lp;\r\nuint8_t flag;\r\nLPFC_MBOXQ_t *mbox;\r\nstruct lpfc_dmabuf *pcmd;\r\nRPS *rps;\r\nstruct ls_rjt stat;\r\nif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\r\n(ndlp->nlp_state != NLP_STE_MAPPED_NODE))\r\ngoto reject_out;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\nflag = (be32_to_cpu(*lp++) & 0xf);\r\nrps = (RPS *) lp;\r\nif ((flag == 0) ||\r\n((flag == 1) && (be32_to_cpu(rps->un.portNum) == 0)) ||\r\n((flag == 2) && (memcmp(&rps->un.portName, &vport->fc_portname,\r\nsizeof(struct lpfc_name)) == 0))) {\r\nprintk("Fix me....\n");\r\ndump_stack();\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_ATOMIC);\r\nif (mbox) {\r\nlpfc_read_lnk_stat(phba, mbox);\r\nmbox->context1 = (void *)((unsigned long)\r\n((cmdiocb->iocb.unsli3.rcvsli3.ox_id << 16) |\r\ncmdiocb->iocb.ulpContext));\r\nmbox->context2 = lpfc_nlp_get(ndlp);\r\nmbox->vport = vport;\r\nmbox->mbox_cmpl = lpfc_els_rsp_rps_acc;\r\nif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\r\n!= MBX_NOT_FINISHED)\r\nreturn 0;\r\nlpfc_nlp_put(ndlp);\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\n}\r\n}\r\nreject_out:\r\nstat.un.b.lsRjtRsvd0 = 0;\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\r\nstat.un.b.vendorUnique = 0;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_issue_els_rrq(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nuint32_t did, struct lpfc_node_rrq *rrq)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct RRQ *els_rrq;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint ret;\r\nif (ndlp != rrq->ndlp)\r\nndlp = rrq->ndlp;\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp))\r\nreturn 1;\r\ncmdsize = (sizeof(uint32_t) + sizeof(struct RRQ));\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp, did,\r\nELS_CMD_RRQ);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_RRQ;\r\npcmd += sizeof(uint32_t);\r\nels_rrq = (struct RRQ *) pcmd;\r\nbf_set(rrq_oxid, els_rrq, phba->sli4_hba.xri_ids[rrq->xritag]);\r\nbf_set(rrq_rxid, els_rrq, rrq->rxid);\r\nbf_set(rrq_did, els_rrq, vport->fc_myDID);\r\nels_rrq->rrq = cpu_to_be32(els_rrq->rrq);\r\nels_rrq->rrq_exchg = cpu_to_be32(els_rrq->rrq_exchg);\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue RRQ: did:x%x",\r\ndid, rrq->xritag, rrq->rxid);\r\nelsiocb->context_un.rrq = rrq;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rrq;\r\nret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\r\nif (ret == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlpfc_send_rrq(struct lpfc_hba *phba, struct lpfc_node_rrq *rrq)\r\n{\r\nstruct lpfc_nodelist *ndlp = lpfc_findnode_did(rrq->vport,\r\nrrq->nlp_DID);\r\nif (lpfc_test_rrq_active(phba, ndlp, rrq->xritag))\r\nreturn lpfc_issue_els_rrq(rrq->vport, ndlp,\r\nrrq->nlp_DID, rrq);\r\nelse\r\nreturn 1;\r\n}\r\nstatic int\r\nlpfc_els_rsp_rpl_acc(struct lpfc_vport *vport, uint16_t cmdsize,\r\nstruct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd, *oldcmd;\r\nRPL_RSP rpl_rsp;\r\nstruct lpfc_iocbq *elsiocb;\r\nuint8_t *pcmd;\r\nelsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\r\nndlp->nlp_DID, ELS_CMD_ACC);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\noldcmd = &oldiocb->iocb;\r\nicmd->ulpContext = oldcmd->ulpContext;\r\nicmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\r\npcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\r\npcmd += sizeof(uint16_t);\r\n*((uint16_t *)(pcmd)) = be16_to_cpu(cmdsize);\r\npcmd += sizeof(uint16_t);\r\nrpl_rsp.listLen = be32_to_cpu(1);\r\nrpl_rsp.index = 0;\r\nrpl_rsp.port_num_blk.portNum = 0;\r\nrpl_rsp.port_num_blk.portID = be32_to_cpu(vport->fc_myDID);\r\nmemcpy(&rpl_rsp.port_num_blk.portName, &vport->fc_portname,\r\nsizeof(struct lpfc_name));\r\nmemcpy(pcmd, &rpl_rsp, cmdsize - sizeof(uint32_t));\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0120 Xmit ELS RPL ACC response tag x%x "\r\n"xri x%x, did x%x, nlp_flag x%x, nlp_state x%x, "\r\n"rpi x%x\n",\r\nelsiocb->iotag, elsiocb->iocb.ulpContext,\r\nndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\r\nndlp->nlp_rpi);\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\r\nphba->fc_stat.elsXmitACC++;\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) ==\r\nIOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_rpl(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_dmabuf *pcmd;\r\nuint32_t *lp;\r\nuint32_t maxsize;\r\nuint16_t cmdsize;\r\nRPL *rpl;\r\nstruct ls_rjt stat;\r\nif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\r\n(ndlp->nlp_state != NLP_STE_MAPPED_NODE)) {\r\nstat.un.b.lsRjtRsvd0 = 0;\r\nstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\r\nstat.un.b.vendorUnique = 0;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\r\nNULL);\r\nreturn 0;\r\n}\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\nrpl = (RPL *) (lp + 1);\r\nmaxsize = be32_to_cpu(rpl->maxsize);\r\nif ((rpl->index == 0) &&\r\n((maxsize == 0) ||\r\n((maxsize * sizeof(uint32_t)) >= sizeof(RPL_RSP)))) {\r\ncmdsize = sizeof(uint32_t) + sizeof(RPL_RSP);\r\n} else {\r\ncmdsize = sizeof(uint32_t) + maxsize * sizeof(uint32_t);\r\n}\r\nlpfc_els_rsp_rpl_acc(vport, cmdsize, cmdiocb, ndlp);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_farp(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_dmabuf *pcmd;\r\nuint32_t *lp;\r\nIOCB_t *icmd;\r\nFARP *fp;\r\nuint32_t cmd, cnt, did;\r\nicmd = &cmdiocb->iocb;\r\ndid = icmd->un.elsreq64.remoteID;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\ncmd = *lp++;\r\nfp = (FARP *) lp;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0601 FARP-REQ received from DID x%x\n", did);\r\nif (fp->Mflags & ~(FARP_MATCH_NODE | FARP_MATCH_PORT)) {\r\nreturn 0;\r\n}\r\ncnt = 0;\r\nif (fp->Mflags & FARP_MATCH_PORT) {\r\nif (memcmp(&fp->RportName, &vport->fc_portname,\r\nsizeof(struct lpfc_name)) == 0)\r\ncnt = 1;\r\n}\r\nif (fp->Mflags & FARP_MATCH_NODE) {\r\nif (memcmp(&fp->RnodeName, &vport->fc_nodename,\r\nsizeof(struct lpfc_name)) == 0)\r\ncnt = 1;\r\n}\r\nif (cnt) {\r\nif ((ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) ||\r\n(ndlp->nlp_state == NLP_STE_MAPPED_NODE)) {\r\nif (fp->Rflags & FARP_REQUEST_PLOGI) {\r\nndlp->nlp_prev_state = ndlp->nlp_state;\r\nlpfc_nlp_set_state(vport, ndlp,\r\nNLP_STE_PLOGI_ISSUE);\r\nlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\r\n}\r\nif (fp->Rflags & FARP_REQUEST_FARPR)\r\nlpfc_issue_els_farpr(vport, did, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_farpr(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_dmabuf *pcmd;\r\nuint32_t *lp;\r\nIOCB_t *icmd;\r\nuint32_t cmd, did;\r\nicmd = &cmdiocb->iocb;\r\ndid = icmd->un.elsreq64.remoteID;\r\npcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\r\nlp = (uint32_t *) pcmd->virt;\r\ncmd = *lp++;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0600 FARP-RSP received from DID x%x\n", did);\r\nlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_els_rcv_fan(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_nodelist *fan_ndlp)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t *lp;\r\nFAN *fp;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS, "0265 FAN received\n");\r\nlp = (uint32_t *)((struct lpfc_dmabuf *)cmdiocb->context2)->virt;\r\nfp = (FAN *) ++lp;\r\nif ((vport == phba->pport) &&\r\n(vport->port_state == LPFC_LOCAL_CFG_LINK)) {\r\nif ((memcmp(&phba->fc_fabparam.nodeName, &fp->FnodeName,\r\nsizeof(struct lpfc_name))) ||\r\n(memcmp(&phba->fc_fabparam.portName, &fp->FportName,\r\nsizeof(struct lpfc_name)))) {\r\nlpfc_issue_init_vfi(vport);\r\n} else {\r\nvport->fc_myDID = vport->fc_prevDID;\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nlpfc_issue_fabric_reglogin(vport);\r\nelse {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"3138 Need register VFI: (x%x/%x)\n",\r\nvport->fc_prevDID, vport->fc_myDID);\r\nlpfc_issue_reg_vfi(vport);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_els_timeout(unsigned long ptr)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) ptr;\r\nstruct lpfc_hba *phba = vport->phba;\r\nuint32_t tmo_posted;\r\nunsigned long iflag;\r\nspin_lock_irqsave(&vport->work_port_lock, iflag);\r\ntmo_posted = vport->work_port_events & WORKER_ELS_TMO;\r\nif (!tmo_posted)\r\nvport->work_port_events |= WORKER_ELS_TMO;\r\nspin_unlock_irqrestore(&vport->work_port_lock, iflag);\r\nif (!tmo_posted)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_els_timeout_handler(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_sli_ring *pring;\r\nstruct lpfc_iocbq *tmp_iocb, *piocb;\r\nIOCB_t *cmd = NULL;\r\nstruct lpfc_dmabuf *pcmd;\r\nuint32_t els_command = 0;\r\nuint32_t timeout;\r\nuint32_t remote_ID = 0xffffffff;\r\nLIST_HEAD(txcmplq_completions);\r\nLIST_HEAD(abort_list);\r\ntimeout = (uint32_t)(phba->fc_ratov << 1);\r\npring = &phba->sli.ring[LPFC_ELS_RING];\r\nspin_lock_irq(&phba->hbalock);\r\nlist_splice_init(&pring->txcmplq, &txcmplq_completions);\r\nspin_unlock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(piocb, tmp_iocb, &txcmplq_completions, list) {\r\ncmd = &piocb->iocb;\r\nif ((piocb->iocb_flag & LPFC_IO_LIBDFC) != 0 ||\r\npiocb->iocb.ulpCommand == CMD_ABORT_XRI_CN ||\r\npiocb->iocb.ulpCommand == CMD_CLOSE_XRI_CN)\r\ncontinue;\r\nif (piocb->vport != vport)\r\ncontinue;\r\npcmd = (struct lpfc_dmabuf *) piocb->context2;\r\nif (pcmd)\r\nels_command = *(uint32_t *) (pcmd->virt);\r\nif (els_command == ELS_CMD_FARP ||\r\nels_command == ELS_CMD_FARPR ||\r\nels_command == ELS_CMD_FDISC)\r\ncontinue;\r\nif (piocb->drvrTimeout > 0) {\r\nif (piocb->drvrTimeout >= timeout)\r\npiocb->drvrTimeout -= timeout;\r\nelse\r\npiocb->drvrTimeout = 0;\r\ncontinue;\r\n}\r\nremote_ID = 0xffffffff;\r\nif (cmd->ulpCommand != CMD_GEN_REQUEST64_CR)\r\nremote_ID = cmd->un.elsreq64.remoteID;\r\nelse {\r\nstruct lpfc_nodelist *ndlp;\r\nndlp = __lpfc_findnode_rpi(vport, cmd->ulpContext);\r\nif (ndlp && NLP_CHK_NODE_ACT(ndlp))\r\nremote_ID = ndlp->nlp_DID;\r\n}\r\nlist_add_tail(&piocb->dlist, &abort_list);\r\n}\r\nspin_lock_irq(&phba->hbalock);\r\nlist_splice(&txcmplq_completions, &pring->txcmplq);\r\nspin_unlock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(piocb, tmp_iocb, &abort_list, dlist) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0127 ELS timeout Data: x%x x%x x%x "\r\n"x%x\n", els_command,\r\nremote_ID, cmd->ulpCommand, cmd->ulpIoTag);\r\nspin_lock_irq(&phba->hbalock);\r\nlist_del_init(&piocb->dlist);\r\nlpfc_sli_issue_abort_iotag(phba, pring, piocb);\r\nspin_unlock_irq(&phba->hbalock);\r\n}\r\nif (phba->sli.ring[LPFC_ELS_RING].txcmplq_cnt)\r\nmod_timer(&vport->els_tmofunc, jiffies + HZ * timeout);\r\n}\r\nvoid\r\nlpfc_els_flush_cmd(struct lpfc_vport *vport)\r\n{\r\nLIST_HEAD(completions);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];\r\nstruct lpfc_iocbq *tmp_iocb, *piocb;\r\nIOCB_t *cmd = NULL;\r\nlpfc_fabric_abort_vport(vport);\r\nspin_lock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txq, list) {\r\ncmd = &piocb->iocb;\r\nif (piocb->iocb_flag & LPFC_IO_LIBDFC) {\r\ncontinue;\r\n}\r\nif (cmd->ulpCommand == CMD_QUE_RING_BUF_CN ||\r\ncmd->ulpCommand == CMD_QUE_RING_BUF64_CN ||\r\ncmd->ulpCommand == CMD_CLOSE_XRI_CN ||\r\ncmd->ulpCommand == CMD_ABORT_XRI_CN)\r\ncontinue;\r\nif (piocb->vport != vport)\r\ncontinue;\r\nlist_move_tail(&piocb->list, &completions);\r\npring->txq_cnt--;\r\n}\r\nlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txcmplq, list) {\r\nif (piocb->iocb_flag & LPFC_IO_LIBDFC) {\r\ncontinue;\r\n}\r\nif (piocb->vport != vport)\r\ncontinue;\r\nlpfc_sli_issue_abort_iotag(phba, pring, piocb);\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\r\nIOERR_SLI_ABORTED);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_els_flush_all_cmd(struct lpfc_hba *phba)\r\n{\r\nLIST_HEAD(completions);\r\nstruct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];\r\nstruct lpfc_iocbq *tmp_iocb, *piocb;\r\nIOCB_t *cmd = NULL;\r\nlpfc_fabric_abort_hba(phba);\r\nspin_lock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txq, list) {\r\ncmd = &piocb->iocb;\r\nif (piocb->iocb_flag & LPFC_IO_LIBDFC)\r\ncontinue;\r\nif (cmd->ulpCommand == CMD_QUE_RING_BUF_CN ||\r\ncmd->ulpCommand == CMD_QUE_RING_BUF64_CN ||\r\ncmd->ulpCommand == CMD_CLOSE_XRI_CN ||\r\ncmd->ulpCommand == CMD_ABORT_XRI_CN)\r\ncontinue;\r\nlist_move_tail(&piocb->list, &completions);\r\npring->txq_cnt--;\r\n}\r\nlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txcmplq, list) {\r\nif (piocb->iocb_flag & LPFC_IO_LIBDFC)\r\ncontinue;\r\nlpfc_sli_issue_abort_iotag(phba, pring, piocb);\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\r\nIOERR_SLI_ABORTED);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_send_els_failure_event(struct lpfc_hba *phba,\r\nstruct lpfc_iocbq *cmdiocbp,\r\nstruct lpfc_iocbq *rspiocbp)\r\n{\r\nstruct lpfc_vport *vport = cmdiocbp->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_lsrjt_event lsrjt_event;\r\nstruct lpfc_fabric_event_header fabric_event;\r\nstruct ls_rjt stat;\r\nstruct lpfc_nodelist *ndlp;\r\nuint32_t *pcmd;\r\nndlp = cmdiocbp->context1;\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp))\r\nreturn;\r\nif (rspiocbp->iocb.ulpStatus == IOSTAT_LS_RJT) {\r\nlsrjt_event.header.event_type = FC_REG_ELS_EVENT;\r\nlsrjt_event.header.subcategory = LPFC_EVENT_LSRJT_RCV;\r\nmemcpy(lsrjt_event.header.wwpn, &ndlp->nlp_portname,\r\nsizeof(struct lpfc_name));\r\nmemcpy(lsrjt_event.header.wwnn, &ndlp->nlp_nodename,\r\nsizeof(struct lpfc_name));\r\npcmd = (uint32_t *) (((struct lpfc_dmabuf *)\r\ncmdiocbp->context2)->virt);\r\nlsrjt_event.command = (pcmd != NULL) ? *pcmd : 0;\r\nstat.un.lsRjtError = be32_to_cpu(rspiocbp->iocb.un.ulpWord[4]);\r\nlsrjt_event.reason_code = stat.un.b.lsRjtRsnCode;\r\nlsrjt_event.explanation = stat.un.b.lsRjtRsnCodeExp;\r\nfc_host_post_vendor_event(shost,\r\nfc_get_event_number(),\r\nsizeof(lsrjt_event),\r\n(char *)&lsrjt_event,\r\nLPFC_NL_VENDOR_ID);\r\nreturn;\r\n}\r\nif ((rspiocbp->iocb.ulpStatus == IOSTAT_NPORT_BSY) ||\r\n(rspiocbp->iocb.ulpStatus == IOSTAT_FABRIC_BSY)) {\r\nfabric_event.event_type = FC_REG_FABRIC_EVENT;\r\nif (rspiocbp->iocb.ulpStatus == IOSTAT_NPORT_BSY)\r\nfabric_event.subcategory = LPFC_EVENT_PORT_BUSY;\r\nelse\r\nfabric_event.subcategory = LPFC_EVENT_FABRIC_BUSY;\r\nmemcpy(fabric_event.wwpn, &ndlp->nlp_portname,\r\nsizeof(struct lpfc_name));\r\nmemcpy(fabric_event.wwnn, &ndlp->nlp_nodename,\r\nsizeof(struct lpfc_name));\r\nfc_host_post_vendor_event(shost,\r\nfc_get_event_number(),\r\nsizeof(fabric_event),\r\n(char *)&fabric_event,\r\nLPFC_NL_VENDOR_ID);\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nlpfc_send_els_event(struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp,\r\nuint32_t *payload)\r\n{\r\nstruct lpfc_els_event_header *els_data = NULL;\r\nstruct lpfc_logo_event *logo_data = NULL;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nif (*payload == ELS_CMD_LOGO) {\r\nlogo_data = kmalloc(sizeof(struct lpfc_logo_event), GFP_KERNEL);\r\nif (!logo_data) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0148 Failed to allocate memory "\r\n"for LOGO event\n");\r\nreturn;\r\n}\r\nels_data = &logo_data->header;\r\n} else {\r\nels_data = kmalloc(sizeof(struct lpfc_els_event_header),\r\nGFP_KERNEL);\r\nif (!els_data) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0149 Failed to allocate memory "\r\n"for ELS event\n");\r\nreturn;\r\n}\r\n}\r\nels_data->event_type = FC_REG_ELS_EVENT;\r\nswitch (*payload) {\r\ncase ELS_CMD_PLOGI:\r\nels_data->subcategory = LPFC_EVENT_PLOGI_RCV;\r\nbreak;\r\ncase ELS_CMD_PRLO:\r\nels_data->subcategory = LPFC_EVENT_PRLO_RCV;\r\nbreak;\r\ncase ELS_CMD_ADISC:\r\nels_data->subcategory = LPFC_EVENT_ADISC_RCV;\r\nbreak;\r\ncase ELS_CMD_LOGO:\r\nels_data->subcategory = LPFC_EVENT_LOGO_RCV;\r\nmemcpy(logo_data->logo_wwpn, &payload[2],\r\nsizeof(struct lpfc_name));\r\nbreak;\r\ndefault:\r\nkfree(els_data);\r\nreturn;\r\n}\r\nmemcpy(els_data->wwpn, &ndlp->nlp_portname, sizeof(struct lpfc_name));\r\nmemcpy(els_data->wwnn, &ndlp->nlp_nodename, sizeof(struct lpfc_name));\r\nif (*payload == ELS_CMD_LOGO) {\r\nfc_host_post_vendor_event(shost,\r\nfc_get_event_number(),\r\nsizeof(struct lpfc_logo_event),\r\n(char *)logo_data,\r\nLPFC_NL_VENDOR_ID);\r\nkfree(logo_data);\r\n} else {\r\nfc_host_post_vendor_event(shost,\r\nfc_get_event_number(),\r\nsizeof(struct lpfc_els_event_header),\r\n(char *)els_data,\r\nLPFC_NL_VENDOR_ID);\r\nkfree(els_data);\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_els_unsol_buffer(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\r\nstruct lpfc_vport *vport, struct lpfc_iocbq *elsiocb)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct ls_rjt stat;\r\nuint32_t *payload;\r\nuint32_t cmd, did, newnode, rjt_err = 0;\r\nIOCB_t *icmd = &elsiocb->iocb;\r\nif (!vport || !(elsiocb->context2))\r\ngoto dropit;\r\nnewnode = 0;\r\npayload = ((struct lpfc_dmabuf *)elsiocb->context2)->virt;\r\ncmd = *payload;\r\nif ((phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) == 0)\r\nlpfc_post_buffer(phba, pring, 1);\r\ndid = icmd->un.rcvels.remoteID;\r\nif (icmd->ulpStatus) {\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV Unsol ELS: status:x%x/x%x did:x%x",\r\nicmd->ulpStatus, icmd->un.ulpWord[4], did);\r\ngoto dropit;\r\n}\r\nif (lpfc_els_chk_latt(vport))\r\ngoto dropit;\r\nif (vport->load_flag & FC_UNLOADING)\r\ngoto dropit;\r\nif ((vport->fc_flag & FC_DISC_DELAYED) &&\r\n(cmd != ELS_CMD_PLOGI))\r\ngoto dropit;\r\nndlp = lpfc_findnode_did(vport, did);\r\nif (!ndlp) {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp)\r\ngoto dropit;\r\nlpfc_nlp_init(vport, ndlp, did);\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nnewnode = 1;\r\nif ((did & Fabric_DID_MASK) == Fabric_DID_MASK)\r\nndlp->nlp_type |= NLP_FABRIC;\r\n} else if (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp,\r\nNLP_STE_UNUSED_NODE);\r\nif (!ndlp)\r\ngoto dropit;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nnewnode = 1;\r\nif ((did & Fabric_DID_MASK) == Fabric_DID_MASK)\r\nndlp->nlp_type |= NLP_FABRIC;\r\n} else if (ndlp->nlp_state == NLP_STE_UNUSED_NODE) {\r\nndlp = lpfc_nlp_get(ndlp);\r\nif (!ndlp)\r\ngoto dropit;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\r\nnewnode = 1;\r\n}\r\nphba->fc_stat.elsRcvFrame++;\r\nelsiocb->context1 = lpfc_nlp_get(ndlp);\r\nelsiocb->vport = vport;\r\nif ((cmd & ELS_CMD_MASK) == ELS_CMD_RSCN) {\r\ncmd &= ELS_CMD_MASK;\r\n}\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0112 ELS command x%x received from NPORT x%x "\r\n"Data: x%x\n", cmd, did, vport->port_state);\r\nswitch (cmd) {\r\ncase ELS_CMD_PLOGI:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV PLOGI: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvPLOGI++;\r\nndlp = lpfc_plogi_confirm_nport(phba, payload, ndlp);\r\nlpfc_send_els_event(vport, ndlp, payload);\r\nif (vport->fc_flag & FC_DISC_DELAYED) {\r\nrjt_err = LSRJT_UNABLE_TPC;\r\nbreak;\r\n}\r\nif (vport->port_state < LPFC_DISC_AUTH) {\r\nif (!(phba->pport->fc_flag & FC_PT2PT) ||\r\n(phba->pport->fc_flag & FC_PT2PT_PLOGI)) {\r\nrjt_err = LSRJT_UNABLE_TPC;\r\nbreak;\r\n}\r\n}\r\nshost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_TARGET_REMOVE;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_disc_state_machine(vport, ndlp, elsiocb,\r\nNLP_EVT_RCV_PLOGI);\r\nbreak;\r\ncase ELS_CMD_FLOGI:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV FLOGI: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvFLOGI++;\r\nlpfc_els_rcv_flogi(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_LOGO:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV LOGO: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvLOGO++;\r\nlpfc_send_els_event(vport, ndlp, payload);\r\nif (vport->port_state < LPFC_DISC_AUTH) {\r\nrjt_err = LSRJT_UNABLE_TPC;\r\nbreak;\r\n}\r\nlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_LOGO);\r\nbreak;\r\ncase ELS_CMD_PRLO:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV PRLO: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvPRLO++;\r\nlpfc_send_els_event(vport, ndlp, payload);\r\nif (vport->port_state < LPFC_DISC_AUTH) {\r\nrjt_err = LSRJT_UNABLE_TPC;\r\nbreak;\r\n}\r\nlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_PRLO);\r\nbreak;\r\ncase ELS_CMD_RSCN:\r\nphba->fc_stat.elsRcvRSCN++;\r\nlpfc_els_rcv_rscn(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_ADISC:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV ADISC: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nlpfc_send_els_event(vport, ndlp, payload);\r\nphba->fc_stat.elsRcvADISC++;\r\nif (vport->port_state < LPFC_DISC_AUTH) {\r\nrjt_err = LSRJT_UNABLE_TPC;\r\nbreak;\r\n}\r\nlpfc_disc_state_machine(vport, ndlp, elsiocb,\r\nNLP_EVT_RCV_ADISC);\r\nbreak;\r\ncase ELS_CMD_PDISC:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV PDISC: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvPDISC++;\r\nif (vport->port_state < LPFC_DISC_AUTH) {\r\nrjt_err = LSRJT_UNABLE_TPC;\r\nbreak;\r\n}\r\nlpfc_disc_state_machine(vport, ndlp, elsiocb,\r\nNLP_EVT_RCV_PDISC);\r\nbreak;\r\ncase ELS_CMD_FARPR:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV FARPR: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvFARPR++;\r\nlpfc_els_rcv_farpr(vport, elsiocb, ndlp);\r\nbreak;\r\ncase ELS_CMD_FARP:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV FARP: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvFARP++;\r\nlpfc_els_rcv_farp(vport, elsiocb, ndlp);\r\nbreak;\r\ncase ELS_CMD_FAN:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV FAN: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvFAN++;\r\nlpfc_els_rcv_fan(vport, elsiocb, ndlp);\r\nbreak;\r\ncase ELS_CMD_PRLI:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV PRLI: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvPRLI++;\r\nif (vport->port_state < LPFC_DISC_AUTH) {\r\nrjt_err = LSRJT_UNABLE_TPC;\r\nbreak;\r\n}\r\nlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_PRLI);\r\nbreak;\r\ncase ELS_CMD_LIRR:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV LIRR: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvLIRR++;\r\nlpfc_els_rcv_lirr(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_RLS:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RLS: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvRLS++;\r\nlpfc_els_rcv_rls(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_RPS:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RPS: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvRPS++;\r\nlpfc_els_rcv_rps(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_RPL:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RPL: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvRPL++;\r\nlpfc_els_rcv_rpl(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_RNID:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RNID: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvRNID++;\r\nlpfc_els_rcv_rnid(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_RTV:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RTV: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvRTV++;\r\nlpfc_els_rcv_rtv(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_RRQ:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV RRQ: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvRRQ++;\r\nlpfc_els_rcv_rrq(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ncase ELS_CMD_ECHO:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV ECHO: did:x%x/ste:x%x flg:x%x",\r\ndid, vport->port_state, ndlp->nlp_flag);\r\nphba->fc_stat.elsRcvECHO++;\r\nlpfc_els_rcv_echo(vport, elsiocb, ndlp);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\ndefault:\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\r\n"RCV ELS cmd: cmd:x%x did:x%x/ste:x%x",\r\ncmd, did, vport->port_state);\r\nrjt_err = LSRJT_CMD_UNSUPPORTED;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0115 Unknown ELS command x%x "\r\n"received from NPORT x%x\n", cmd, did);\r\nif (newnode)\r\nlpfc_nlp_put(ndlp);\r\nbreak;\r\n}\r\nif (rjt_err) {\r\nmemset(&stat, 0, sizeof(stat));\r\nstat.un.b.lsRjtRsnCode = rjt_err;\r\nstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\r\nlpfc_els_rsp_reject(vport, stat.un.lsRjtError, elsiocb, ndlp,\r\nNULL);\r\n}\r\nlpfc_nlp_put(elsiocb->context1);\r\nelsiocb->context1 = NULL;\r\nreturn;\r\ndropit:\r\nif (vport && !(vport->load_flag & FC_UNLOADING))\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0111 Dropping received ELS cmd "\r\n"Data: x%x x%x x%x\n",\r\nicmd->ulpStatus, icmd->un.ulpWord[4], icmd->ulpTimeout);\r\nphba->fc_stat.elsRcvDrop++;\r\n}\r\nvoid\r\nlpfc_els_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\r\nstruct lpfc_iocbq *elsiocb)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nIOCB_t *icmd = &elsiocb->iocb;\r\ndma_addr_t paddr;\r\nstruct lpfc_dmabuf *bdeBuf1 = elsiocb->context2;\r\nstruct lpfc_dmabuf *bdeBuf2 = elsiocb->context3;\r\nelsiocb->context1 = NULL;\r\nelsiocb->context2 = NULL;\r\nelsiocb->context3 = NULL;\r\nif (icmd->ulpStatus == IOSTAT_NEED_BUFFER) {\r\nlpfc_sli_hbqbuf_add_hbqs(phba, LPFC_ELS_HBQ);\r\n} else if (icmd->ulpStatus == IOSTAT_LOCAL_REJECT &&\r\n(icmd->un.ulpWord[4] & 0xff) == IOERR_RCV_BUFFER_WAITING) {\r\nphba->fc_stat.NoRcvBuf++;\r\nif (!(phba->sli3_options & LPFC_SLI3_HBQ_ENABLED))\r\nlpfc_post_buffer(phba, pring, 0);\r\nreturn;\r\n}\r\nif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\r\n(icmd->ulpCommand == CMD_IOCB_RCV_ELS64_CX ||\r\nicmd->ulpCommand == CMD_IOCB_RCV_SEQ64_CX)) {\r\nif (icmd->unsli3.rcvsli3.vpi == 0xffff)\r\nvport = phba->pport;\r\nelse\r\nvport = lpfc_find_vport_by_vpid(phba,\r\nicmd->unsli3.rcvsli3.vpi);\r\n}\r\nif (icmd->ulpBdeCount == 0)\r\nreturn;\r\nif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\r\nelsiocb->context2 = bdeBuf1;\r\n} else {\r\npaddr = getPaddr(icmd->un.cont64[0].addrHigh,\r\nicmd->un.cont64[0].addrLow);\r\nelsiocb->context2 = lpfc_sli_ringpostbuf_get(phba, pring,\r\npaddr);\r\n}\r\nlpfc_els_unsol_buffer(phba, pring, vport, elsiocb);\r\nif (elsiocb->context2) {\r\nlpfc_in_buf_free(phba, (struct lpfc_dmabuf *)elsiocb->context2);\r\nelsiocb->context2 = NULL;\r\n}\r\nif ((phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) &&\r\nicmd->ulpBdeCount == 2) {\r\nelsiocb->context2 = bdeBuf2;\r\nlpfc_els_unsol_buffer(phba, pring, vport, elsiocb);\r\nif (elsiocb->context2) {\r\nlpfc_in_buf_free(phba, elsiocb->context2);\r\nelsiocb->context2 = NULL;\r\n}\r\n}\r\n}\r\nvoid\r\nlpfc_do_scr_ns_plogi(struct lpfc_hba *phba, struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_nodelist *ndlp, *ndlp_fdmi;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nspin_lock_irq(shost->host_lock);\r\nif (vport->fc_flag & FC_DISC_DELAYED) {\r\nspin_unlock_irq(shost->host_lock);\r\nmod_timer(&vport->delayed_disc_tmo,\r\njiffies + HZ * phba->fc_ratov);\r\nreturn;\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\nndlp = lpfc_findnode_did(vport, NameServer_DID);\r\nif (!ndlp) {\r\nndlp = mempool_alloc(phba->nlp_mem_pool, GFP_KERNEL);\r\nif (!ndlp) {\r\nif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\r\nlpfc_disc_start(vport);\r\nreturn;\r\n}\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0251 NameServer login: no memory\n");\r\nreturn;\r\n}\r\nlpfc_nlp_init(vport, ndlp, NameServer_DID);\r\n} else if (!NLP_CHK_NODE_ACT(ndlp)) {\r\nndlp = lpfc_enable_node(vport, ndlp, NLP_STE_UNUSED_NODE);\r\nif (!ndlp) {\r\nif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\r\nlpfc_disc_start(vport);\r\nreturn;\r\n}\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0348 NameServer login: node freed\n");\r\nreturn;\r\n}\r\n}\r\nndlp->nlp_type |= NLP_FABRIC;\r\nlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\r\nif (lpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0)) {\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0252 Cannot issue NameServer login\n");\r\nreturn;\r\n}\r\nif (vport->cfg_fdmi_on) {\r\nndlp_fdmi = lpfc_findnode_did(vport, FDMI_DID);\r\nif (!ndlp_fdmi) {\r\nndlp_fdmi = mempool_alloc(phba->nlp_mem_pool,\r\nGFP_KERNEL);\r\nif (ndlp_fdmi) {\r\nlpfc_nlp_init(vport, ndlp_fdmi, FDMI_DID);\r\nndlp_fdmi->nlp_type |= NLP_FABRIC;\r\n} else\r\nreturn;\r\n}\r\nif (!NLP_CHK_NODE_ACT(ndlp_fdmi))\r\nndlp_fdmi = lpfc_enable_node(vport,\r\nndlp_fdmi,\r\nNLP_STE_NPR_NODE);\r\nif (ndlp_fdmi) {\r\nlpfc_nlp_set_state(vport, ndlp_fdmi,\r\nNLP_STE_PLOGI_ISSUE);\r\nlpfc_issue_els_plogi(vport, ndlp_fdmi->nlp_DID, 0);\r\n}\r\n}\r\n}\r\nstatic void\r\nlpfc_cmpl_reg_new_vport(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nstruct lpfc_vport *vport = pmb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) pmb->context2;\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nint rc;\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;\r\nspin_unlock_irq(shost->host_lock);\r\nif (mb->mbxStatus) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_MBOX,\r\n"0915 Register VPI failed : Status: x%x"\r\n" upd bit: x%x \n", mb->mbxStatus,\r\nmb->un.varRegVpi.upd);\r\nif (phba->sli_rev == LPFC_SLI_REV4 &&\r\nmb->un.varRegVpi.upd)\r\ngoto mbox_err_exit ;\r\nswitch (mb->mbxStatus) {\r\ncase 0x11:\r\ncase 0x9603:\r\ncase 0x9602:\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_can_disctmo(vport);\r\nbreak;\r\ncase 0x20:\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_init_vpi(phba, pmb, vport->vpi);\r\npmb->vport = vport;\r\npmb->mbox_cmpl = lpfc_init_vpi_cmpl;\r\nrc = lpfc_sli_issue_mbox(phba, pmb,\r\nMBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED) {\r\nlpfc_printf_vlog(vport,\r\nKERN_ERR, LOG_MBOX,\r\n"2732 Failed to issue INIT_VPI"\r\n" mailbox command\n");\r\n} else {\r\nlpfc_nlp_put(ndlp);\r\nreturn;\r\n}\r\ndefault:\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_sli4_unreg_all_rpis(vport);\r\nlpfc_mbx_unreg_vpi(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\r\nspin_unlock_irq(shost->host_lock);\r\nif (vport->port_type == LPFC_PHYSICAL_PORT\r\n&& !(vport->fc_flag & FC_LOGO_RCVD_DID_CHNG))\r\nlpfc_issue_init_vfi(vport);\r\nelse\r\nlpfc_initial_fdisc(vport);\r\nbreak;\r\n}\r\n} else {\r\nspin_lock_irq(shost->host_lock);\r\nvport->vpi_state |= LPFC_VPI_REGISTERED;\r\nspin_unlock_irq(shost->host_lock);\r\nif (vport == phba->pport) {\r\nif (phba->sli_rev < LPFC_SLI_REV4)\r\nlpfc_issue_fabric_reglogin(vport);\r\nelse {\r\nif (vport->port_state != LPFC_FDISC)\r\nlpfc_start_fdiscs(phba);\r\nlpfc_do_scr_ns_plogi(phba, vport);\r\n}\r\n} else\r\nlpfc_do_scr_ns_plogi(phba, vport);\r\n}\r\nmbox_err_exit:\r\nlpfc_nlp_put(ndlp);\r\nmempool_free(pmb, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_register_new_vport(struct lpfc_hba *phba, struct lpfc_vport *vport,\r\nstruct lpfc_nodelist *ndlp)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nLPFC_MBOXQ_t *mbox;\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (mbox) {\r\nlpfc_reg_vpi(vport, mbox);\r\nmbox->vport = vport;\r\nmbox->context2 = lpfc_nlp_get(ndlp);\r\nmbox->mbox_cmpl = lpfc_cmpl_reg_new_vport;\r\nif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\r\n== MBX_NOT_FINISHED) {\r\nlpfc_nlp_put(ndlp);\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_MBOX,\r\n"0253 Register VPI: Can't send mbox\n");\r\ngoto mbox_err_exit;\r\n}\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_MBOX,\r\n"0254 Register VPI: no memory\n");\r\ngoto mbox_err_exit;\r\n}\r\nreturn;\r\nmbox_err_exit:\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;\r\nspin_unlock_irq(shost->host_lock);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_cancel_all_vport_retry_delay_timer(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport **vports;\r\nstruct lpfc_nodelist *ndlp;\r\nuint32_t link_state;\r\nint i;\r\nlink_state = phba->link_state;\r\nlpfc_linkdown(phba);\r\nphba->link_state = link_state;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports) {\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nndlp = lpfc_findnode_did(vports[i], Fabric_DID);\r\nif (ndlp)\r\nlpfc_cancel_retry_delay_tmo(vports[i], ndlp);\r\nlpfc_els_flush_cmd(vports[i]);\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n}\r\n}\r\nvoid\r\nlpfc_retry_pport_discovery(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_nodelist *ndlp;\r\nstruct Scsi_Host *shost;\r\nlpfc_cancel_all_vport_retry_delay_timer(phba);\r\nndlp = lpfc_findnode_did(phba->pport, Fabric_DID);\r\nif (!ndlp)\r\nreturn;\r\nshost = lpfc_shost_from_vport(phba->pport);\r\nmod_timer(&ndlp->nlp_delayfunc, jiffies + HZ);\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_DELAY_TMO;\r\nspin_unlock_irq(shost->host_lock);\r\nndlp->nlp_last_elscmd = ELS_CMD_FLOGI;\r\nphba->pport->port_state = LPFC_FLOGI;\r\nreturn;\r\n}\r\nstatic int\r\nlpfc_fabric_login_reqd(struct lpfc_hba *phba,\r\nstruct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nif ((rspiocb->iocb.ulpStatus != IOSTAT_FABRIC_RJT) ||\r\n(rspiocb->iocb.un.ulpWord[4] != RJT_LOGIN_REQUIRED))\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_fdisc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\r\nstruct lpfc_nodelist *np;\r\nstruct lpfc_nodelist *next_np;\r\nIOCB_t *irsp = &rspiocb->iocb;\r\nstruct lpfc_iocbq *piocb;\r\nstruct lpfc_dmabuf *pcmd = cmdiocb->context2, *prsp;\r\nstruct serv_parm *sp;\r\nuint8_t fabric_param_changed;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"0123 FDISC completes. x%x/x%x prevDID: x%x\n",\r\nirsp->ulpStatus, irsp->un.ulpWord[4],\r\nvport->fc_prevDID);\r\nlist_for_each_entry(piocb, &phba->fabric_iocb_list, list) {\r\nlpfc_set_disctmo(piocb->vport);\r\n}\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"FDISC cmpl: status:x%x/x%x prevdid:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], vport->fc_prevDID);\r\nif (irsp->ulpStatus) {\r\nif (lpfc_fabric_login_reqd(phba, cmdiocb, rspiocb)) {\r\nlpfc_retry_pport_discovery(phba);\r\ngoto out;\r\n}\r\nif (lpfc_els_retry(phba, cmdiocb, rspiocb))\r\ngoto out;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0126 FDISC failed. (x%x/x%x)\n",\r\nirsp->ulpStatus, irsp->un.ulpWord[4]);\r\ngoto fdisc_failed;\r\n}\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_VPORT_CVL_RCVD;\r\nvport->fc_flag &= ~FC_VPORT_LOGO_RCVD;\r\nvport->fc_flag |= FC_FABRIC;\r\nif (vport->phba->fc_topology == LPFC_TOPOLOGY_LOOP)\r\nvport->fc_flag |= FC_PUBLIC_LOOP;\r\nspin_unlock_irq(shost->host_lock);\r\nvport->fc_myDID = irsp->un.ulpWord[4] & Mask_DID;\r\nlpfc_vport_set_state(vport, FC_VPORT_ACTIVE);\r\nprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\r\nsp = prsp->virt + sizeof(uint32_t);\r\nfabric_param_changed = lpfc_check_clean_addr_bit(vport, sp);\r\nmemcpy(&vport->fabric_portname, &sp->portName,\r\nsizeof(struct lpfc_name));\r\nmemcpy(&vport->fabric_nodename, &sp->nodeName,\r\nsizeof(struct lpfc_name));\r\nif (fabric_param_changed &&\r\n!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\r\nlist_for_each_entry_safe(np, next_np,\r\n&vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp) ||\r\n(np->nlp_state != NLP_STE_NPR_NODE) ||\r\n!(np->nlp_flag & NLP_NPR_ADISC))\r\ncontinue;\r\nspin_lock_irq(shost->host_lock);\r\nnp->nlp_flag &= ~NLP_NPR_ADISC;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_unreg_rpi(vport, np);\r\n}\r\nlpfc_cleanup_pending_mbox(vport);\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_sli4_unreg_all_rpis(vport);\r\nlpfc_mbx_unreg_vpi(vport);\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nvport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\r\nelse\r\nvport->fc_flag |= FC_LOGO_RCVD_DID_CHNG;\r\nspin_unlock_irq(shost->host_lock);\r\n} else if ((phba->sli_rev == LPFC_SLI_REV4) &&\r\n!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\r\nlpfc_register_new_vport(phba, vport, ndlp);\r\ngoto out;\r\n}\r\nif (vport->fc_flag & FC_VPORT_NEEDS_INIT_VPI)\r\nlpfc_issue_init_vpi(vport);\r\nelse if (vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)\r\nlpfc_register_new_vport(phba, vport, ndlp);\r\nelse\r\nlpfc_do_scr_ns_plogi(phba, vport);\r\ngoto out;\r\nfdisc_failed:\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_can_disctmo(vport);\r\nlpfc_nlp_put(ndlp);\r\nout:\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\n}\r\nstatic int\r\nlpfc_issue_els_fdisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\r\nuint8_t retry)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nstruct serv_parm *sp;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\nint did = ndlp->nlp_DID;\r\nint rc;\r\nvport->port_state = LPFC_FDISC;\r\nvport->fc_myDID = 0;\r\ncmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp, did,\r\nELS_CMD_FDISC);\r\nif (!elsiocb) {\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0255 Issue FDISC: no IOCB\n");\r\nreturn 1;\r\n}\r\nicmd = &elsiocb->iocb;\r\nicmd->un.elsreq64.myID = 0;\r\nicmd->un.elsreq64.fl = 1;\r\nif (phba->sli_rev == LPFC_SLI_REV3) {\r\nicmd->ulpCt_h = 1;\r\nicmd->ulpCt_l = 0;\r\n}\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_FDISC;\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, &vport->phba->pport->fc_sparam, sizeof(struct serv_parm));\r\nsp = (struct serv_parm *) pcmd;\r\nsp->cmn.e_d_tov = 0;\r\nsp->cmn.w2.r_a_tov = 0;\r\nsp->cmn.virtual_fabric_support = 0;\r\nsp->cls1.classValid = 0;\r\nsp->cls2.seqDelivery = 1;\r\nsp->cls3.seqDelivery = 1;\r\npcmd += sizeof(uint32_t);\r\npcmd += sizeof(uint32_t);\r\npcmd += sizeof(uint32_t);\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, &vport->fc_portname, 8);\r\npcmd += sizeof(uint32_t);\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, &vport->fc_nodename, 8);\r\nlpfc_set_disctmo(vport);\r\nphba->fc_stat.elsXmitFDISC++;\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_fdisc;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue FDISC: did:x%x",\r\ndid, 0, 0);\r\nrc = lpfc_issue_fabric_iocb(phba, elsiocb);\r\nif (rc == IOCB_ERROR) {\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nlpfc_vport_set_state(vport, FC_VPORT_FAILED);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\r\n"0256 Issue FDISC: Cannot send IOCB\n");\r\nreturn 1;\r\n}\r\nlpfc_vport_set_state(vport, FC_VPORT_INITIALIZING);\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_cmpl_els_npiv_logo(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct lpfc_vport *vport = cmdiocb->vport;\r\nIOCB_t *irsp;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nndlp = (struct lpfc_nodelist *)cmdiocb->context1;\r\nirsp = &rspiocb->iocb;\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"LOGO npiv cmpl: status:x%x/x%x did:x%x",\r\nirsp->ulpStatus, irsp->un.ulpWord[4], irsp->un.rcvels.remoteID);\r\nlpfc_els_free_iocb(phba, cmdiocb);\r\nvport->unreg_vpi_cmpl = VPORT_ERROR;\r\nlpfc_nlp_put(ndlp);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\r\n"2928 NPIV LOGO completes to NPort x%x "\r\n"Data: x%x x%x x%x x%x\n",\r\nndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\r\nirsp->ulpTimeout, vport->num_disc_nodes);\r\nif (irsp->ulpStatus == IOSTAT_SUCCESS) {\r\nspin_lock_irq(shost->host_lock);\r\nvport->fc_flag &= ~FC_FABRIC;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\n}\r\nint\r\nlpfc_issue_els_npiv_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\r\nstruct lpfc_hba *phba = vport->phba;\r\nIOCB_t *icmd;\r\nstruct lpfc_iocbq *elsiocb;\r\nuint8_t *pcmd;\r\nuint16_t cmdsize;\r\ncmdsize = 2 * sizeof(uint32_t) + sizeof(struct lpfc_name);\r\nelsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp, ndlp->nlp_DID,\r\nELS_CMD_LOGO);\r\nif (!elsiocb)\r\nreturn 1;\r\nicmd = &elsiocb->iocb;\r\npcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\r\n*((uint32_t *) (pcmd)) = ELS_CMD_LOGO;\r\npcmd += sizeof(uint32_t);\r\n*((uint32_t *) (pcmd)) = be32_to_cpu(vport->fc_myDID);\r\npcmd += sizeof(uint32_t);\r\nmemcpy(pcmd, &vport->fc_portname, sizeof(struct lpfc_name));\r\nlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Issue LOGO npiv did:x%x flg:x%x",\r\nndlp->nlp_DID, ndlp->nlp_flag, 0);\r\nelsiocb->iocb_cmpl = lpfc_cmpl_els_npiv_logo;\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag |= NLP_LOGO_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nif (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0) ==\r\nIOCB_ERROR) {\r\nspin_lock_irq(shost->host_lock);\r\nndlp->nlp_flag &= ~NLP_LOGO_SND;\r\nspin_unlock_irq(shost->host_lock);\r\nlpfc_els_free_iocb(phba, elsiocb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_fabric_block_timeout(unsigned long ptr)\r\n{\r\nstruct lpfc_hba *phba = (struct lpfc_hba *) ptr;\r\nunsigned long iflags;\r\nuint32_t tmo_posted;\r\nspin_lock_irqsave(&phba->pport->work_port_lock, iflags);\r\ntmo_posted = phba->pport->work_port_events & WORKER_FABRIC_BLOCK_TMO;\r\nif (!tmo_posted)\r\nphba->pport->work_port_events |= WORKER_FABRIC_BLOCK_TMO;\r\nspin_unlock_irqrestore(&phba->pport->work_port_lock, iflags);\r\nif (!tmo_posted)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_resume_fabric_iocbs(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_iocbq *iocb;\r\nunsigned long iflags;\r\nint ret;\r\nIOCB_t *cmd;\r\nrepeat:\r\niocb = NULL;\r\nspin_lock_irqsave(&phba->hbalock, iflags);\r\nif (atomic_read(&phba->fabric_iocb_count) == 0) {\r\nlist_remove_head(&phba->fabric_iocb_list, iocb, typeof(*iocb),\r\nlist);\r\nif (iocb)\r\natomic_inc(&phba->fabric_iocb_count);\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, iflags);\r\nif (iocb) {\r\niocb->fabric_iocb_cmpl = iocb->iocb_cmpl;\r\niocb->iocb_cmpl = lpfc_cmpl_fabric_iocb;\r\niocb->iocb_flag |= LPFC_IO_FABRIC;\r\nlpfc_debugfs_disc_trc(iocb->vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Fabric sched1: ste:x%x",\r\niocb->vport->port_state, 0, 0);\r\nret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, iocb, 0);\r\nif (ret == IOCB_ERROR) {\r\niocb->iocb_cmpl = iocb->fabric_iocb_cmpl;\r\niocb->fabric_iocb_cmpl = NULL;\r\niocb->iocb_flag &= ~LPFC_IO_FABRIC;\r\ncmd = &iocb->iocb;\r\ncmd->ulpStatus = IOSTAT_LOCAL_REJECT;\r\ncmd->un.ulpWord[4] = IOERR_SLI_ABORTED;\r\niocb->iocb_cmpl(phba, iocb, iocb);\r\natomic_dec(&phba->fabric_iocb_count);\r\ngoto repeat;\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid\r\nlpfc_unblock_fabric_iocbs(struct lpfc_hba *phba)\r\n{\r\nclear_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\r\nlpfc_resume_fabric_iocbs(phba);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_block_fabric_iocbs(struct lpfc_hba *phba)\r\n{\r\nint blocked;\r\nblocked = test_and_set_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\r\nif (!blocked)\r\nmod_timer(&phba->fabric_block_timer, jiffies + HZ/10 );\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_cmpl_fabric_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\r\nstruct lpfc_iocbq *rspiocb)\r\n{\r\nstruct ls_rjt stat;\r\nif ((cmdiocb->iocb_flag & LPFC_IO_FABRIC) != LPFC_IO_FABRIC)\r\nBUG();\r\nswitch (rspiocb->iocb.ulpStatus) {\r\ncase IOSTAT_NPORT_RJT:\r\ncase IOSTAT_FABRIC_RJT:\r\nif (rspiocb->iocb.un.ulpWord[4] & RJT_UNAVAIL_TEMP) {\r\nlpfc_block_fabric_iocbs(phba);\r\n}\r\nbreak;\r\ncase IOSTAT_NPORT_BSY:\r\ncase IOSTAT_FABRIC_BSY:\r\nlpfc_block_fabric_iocbs(phba);\r\nbreak;\r\ncase IOSTAT_LS_RJT:\r\nstat.un.lsRjtError =\r\nbe32_to_cpu(rspiocb->iocb.un.ulpWord[4]);\r\nif ((stat.un.b.lsRjtRsnCode == LSRJT_UNABLE_TPC) ||\r\n(stat.un.b.lsRjtRsnCode == LSRJT_LOGICAL_BSY))\r\nlpfc_block_fabric_iocbs(phba);\r\nbreak;\r\n}\r\nif (atomic_read(&phba->fabric_iocb_count) == 0)\r\nBUG();\r\ncmdiocb->iocb_cmpl = cmdiocb->fabric_iocb_cmpl;\r\ncmdiocb->fabric_iocb_cmpl = NULL;\r\ncmdiocb->iocb_flag &= ~LPFC_IO_FABRIC;\r\ncmdiocb->iocb_cmpl(phba, cmdiocb, rspiocb);\r\natomic_dec(&phba->fabric_iocb_count);\r\nif (!test_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags)) {\r\nlpfc_resume_fabric_iocbs(phba);\r\n}\r\n}\r\nstatic int\r\nlpfc_issue_fabric_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *iocb)\r\n{\r\nunsigned long iflags;\r\nint ready;\r\nint ret;\r\nif (atomic_read(&phba->fabric_iocb_count) > 1)\r\nBUG();\r\nspin_lock_irqsave(&phba->hbalock, iflags);\r\nready = atomic_read(&phba->fabric_iocb_count) == 0 &&\r\n!test_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\r\nif (ready)\r\natomic_inc(&phba->fabric_iocb_count);\r\nspin_unlock_irqrestore(&phba->hbalock, iflags);\r\nif (ready) {\r\niocb->fabric_iocb_cmpl = iocb->iocb_cmpl;\r\niocb->iocb_cmpl = lpfc_cmpl_fabric_iocb;\r\niocb->iocb_flag |= LPFC_IO_FABRIC;\r\nlpfc_debugfs_disc_trc(iocb->vport, LPFC_DISC_TRC_ELS_CMD,\r\n"Fabric sched2: ste:x%x",\r\niocb->vport->port_state, 0, 0);\r\nret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, iocb, 0);\r\nif (ret == IOCB_ERROR) {\r\niocb->iocb_cmpl = iocb->fabric_iocb_cmpl;\r\niocb->fabric_iocb_cmpl = NULL;\r\niocb->iocb_flag &= ~LPFC_IO_FABRIC;\r\natomic_dec(&phba->fabric_iocb_count);\r\n}\r\n} else {\r\nspin_lock_irqsave(&phba->hbalock, iflags);\r\nlist_add_tail(&iocb->list, &phba->fabric_iocb_list);\r\nspin_unlock_irqrestore(&phba->hbalock, iflags);\r\nret = IOCB_SUCCESS;\r\n}\r\nreturn ret;\r\n}\r\nstatic void lpfc_fabric_abort_vport(struct lpfc_vport *vport)\r\n{\r\nLIST_HEAD(completions);\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *tmp_iocb, *piocb;\r\nspin_lock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(piocb, tmp_iocb, &phba->fabric_iocb_list,\r\nlist) {\r\nif (piocb->vport != vport)\r\ncontinue;\r\nlist_move_tail(&piocb->list, &completions);\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\r\nIOERR_SLI_ABORTED);\r\n}\r\nvoid lpfc_fabric_abort_nport(struct lpfc_nodelist *ndlp)\r\n{\r\nLIST_HEAD(completions);\r\nstruct lpfc_hba *phba = ndlp->phba;\r\nstruct lpfc_iocbq *tmp_iocb, *piocb;\r\nstruct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];\r\nspin_lock_irq(&phba->hbalock);\r\nlist_for_each_entry_safe(piocb, tmp_iocb, &phba->fabric_iocb_list,\r\nlist) {\r\nif ((lpfc_check_sli_ndlp(phba, pring, piocb, ndlp))) {\r\nlist_move_tail(&piocb->list, &completions);\r\n}\r\n}\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\r\nIOERR_SLI_ABORTED);\r\n}\r\nvoid lpfc_fabric_abort_hba(struct lpfc_hba *phba)\r\n{\r\nLIST_HEAD(completions);\r\nspin_lock_irq(&phba->hbalock);\r\nlist_splice_init(&phba->fabric_iocb_list, &completions);\r\nspin_unlock_irq(&phba->hbalock);\r\nlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\r\nIOERR_SLI_ABORTED);\r\n}\r\nvoid\r\nlpfc_sli4_vport_delete_els_xri_aborted(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_sglq *sglq_entry = NULL, *sglq_next = NULL;\r\nunsigned long iflag = 0;\r\nspin_lock_irqsave(&phba->hbalock, iflag);\r\nspin_lock(&phba->sli4_hba.abts_sgl_list_lock);\r\nlist_for_each_entry_safe(sglq_entry, sglq_next,\r\n&phba->sli4_hba.lpfc_abts_els_sgl_list, list) {\r\nif (sglq_entry->ndlp && sglq_entry->ndlp->vport == vport)\r\nsglq_entry->ndlp = NULL;\r\n}\r\nspin_unlock(&phba->sli4_hba.abts_sgl_list_lock);\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_sli4_els_xri_aborted(struct lpfc_hba *phba,\r\nstruct sli4_wcqe_xri_aborted *axri)\r\n{\r\nuint16_t xri = bf_get(lpfc_wcqe_xa_xri, axri);\r\nuint16_t rxid = bf_get(lpfc_wcqe_xa_remote_xid, axri);\r\nuint16_t lxri = 0;\r\nstruct lpfc_sglq *sglq_entry = NULL, *sglq_next = NULL;\r\nunsigned long iflag = 0;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];\r\nspin_lock_irqsave(&phba->hbalock, iflag);\r\nspin_lock(&phba->sli4_hba.abts_sgl_list_lock);\r\nlist_for_each_entry_safe(sglq_entry, sglq_next,\r\n&phba->sli4_hba.lpfc_abts_els_sgl_list, list) {\r\nif (sglq_entry->sli4_xritag == xri) {\r\nlist_del(&sglq_entry->list);\r\nndlp = sglq_entry->ndlp;\r\nsglq_entry->ndlp = NULL;\r\nlist_add_tail(&sglq_entry->list,\r\n&phba->sli4_hba.lpfc_sgl_list);\r\nsglq_entry->state = SGL_FREED;\r\nspin_unlock(&phba->sli4_hba.abts_sgl_list_lock);\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nlpfc_set_rrq_active(phba, ndlp,\r\nsglq_entry->sli4_lxritag,\r\nrxid, 1);\r\nif (pring->txq_cnt)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\n}\r\nspin_unlock(&phba->sli4_hba.abts_sgl_list_lock);\r\nlxri = lpfc_sli4_xri_inrange(phba, xri);\r\nif (lxri == NO_XRI) {\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nreturn;\r\n}\r\nsglq_entry = __lpfc_get_active_sglq(phba, lxri);\r\nif (!sglq_entry || (sglq_entry->sli4_xritag != xri)) {\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nreturn;\r\n}\r\nsglq_entry->state = SGL_XRI_ABORTED;\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nreturn;\r\n}
