static ssize_t\r\nqla4_8xxx_sysfs_read_fw_dump(struct file *filep, struct kobject *kobj,\r\nstruct bin_attribute *ba, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nif (!is_qla8022(ha))\r\nreturn -EINVAL;\r\nif (!test_bit(AF_82XX_DUMP_READING, &ha->flags))\r\nreturn 0;\r\nreturn memory_read_from_buffer(buf, count, &off, ha->fw_dump,\r\nha->fw_dump_size);\r\n}\r\nstatic ssize_t\r\nqla4_8xxx_sysfs_write_fw_dump(struct file *filep, struct kobject *kobj,\r\nstruct bin_attribute *ba, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nuint32_t dev_state;\r\nlong reading;\r\nint ret = 0;\r\nif (!is_qla8022(ha))\r\nreturn -EINVAL;\r\nif (off != 0)\r\nreturn ret;\r\nbuf[1] = 0;\r\nret = kstrtol(buf, 10, &reading);\r\nif (ret) {\r\nql4_printk(KERN_ERR, ha, "%s: Invalid input. Return err %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nswitch (reading) {\r\ncase 0:\r\nif (test_and_clear_bit(AF_82XX_DUMP_READING, &ha->flags)) {\r\nclear_bit(AF_82XX_FW_DUMPED, &ha->flags);\r\nqla4xxx_alloc_fw_dump(ha);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Firmware template reloaded\n"));\r\n}\r\nbreak;\r\ncase 1:\r\nif (test_bit(AF_82XX_FW_DUMPED, &ha->flags) &&\r\n!test_bit(AF_82XX_DUMP_READING, &ha->flags)) {\r\nset_bit(AF_82XX_DUMP_READING, &ha->flags);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Raw firmware dump ready for read on (%ld).\n",\r\nha->host_no));\r\n}\r\nbreak;\r\ncase 2:\r\nqla4_8xxx_idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nif (dev_state == QLA82XX_DEV_READY) {\r\nql4_printk(KERN_INFO, ha,\r\n"%s: Setting Need reset, reset_owner is 0x%x.\n",\r\n__func__, ha->func_num);\r\nqla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA82XX_DEV_NEED_RESET);\r\nset_bit(AF_82XX_RST_OWNER, &ha->flags);\r\n} else\r\nql4_printk(KERN_INFO, ha,\r\n"%s: Reset not performed as device state is 0x%x\n",\r\n__func__, dev_state);\r\nqla4_8xxx_idc_unlock(ha);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nvoid qla4_8xxx_alloc_sysfs_attr(struct scsi_qla_host *ha)\r\n{\r\nstruct Scsi_Host *host = ha->host;\r\nstruct sysfs_entry *iter;\r\nint ret;\r\nfor (iter = bin_file_entries; iter->name; iter++) {\r\nret = sysfs_create_bin_file(&host->shost_gendev.kobj,\r\niter->attr);\r\nif (ret)\r\nql4_printk(KERN_ERR, ha,\r\n"Unable to create sysfs %s binary attribute (%d).\n",\r\niter->name, ret);\r\n}\r\n}\r\nvoid qla4_8xxx_free_sysfs_attr(struct scsi_qla_host *ha)\r\n{\r\nstruct Scsi_Host *host = ha->host;\r\nstruct sysfs_entry *iter;\r\nfor (iter = bin_file_entries; iter->name; iter++)\r\nsysfs_remove_bin_file(&host->shost_gendev.kobj,\r\niter->attr);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nif (is_qla8022(ha))\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%02d.%02d (%x)\n",\r\nha->firmware_version[0],\r\nha->firmware_version[1],\r\nha->patch_number, ha->build_number);\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%02d.%02d.%02d\n",\r\nha->firmware_version[0],\r\nha->firmware_version[1],\r\nha->patch_number, ha->build_number);\r\n}\r\nstatic ssize_t\r\nqla4xxx_serial_num_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ha->serial_number);\r\n}\r\nstatic ssize_t\r\nqla4xxx_iscsi_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%02d\n", ha->iscsi_major,\r\nha->iscsi_minor);\r\n}\r\nstatic ssize_t\r\nqla4xxx_optrom_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%02d.%02d.%02d\n",\r\nha->bootload_major, ha->bootload_minor,\r\nha->bootload_patch, ha->bootload_build);\r\n}\r\nstatic ssize_t\r\nqla4xxx_board_id_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08X\n", ha->board_id);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nqla4xxx_get_firmware_state(ha);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08X%8X\n", ha->firmware_state,\r\nha->addl_fw_state);\r\n}\r\nstatic ssize_t\r\nqla4xxx_phy_port_cnt_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nif (!is_qla8022(ha))\r\nreturn -ENOSYS;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04X\n", ha->phy_port_cnt);\r\n}\r\nstatic ssize_t\r\nqla4xxx_phy_port_num_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nif (!is_qla8022(ha))\r\nreturn -ENOSYS;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04X\n", ha->phy_port_num);\r\n}\r\nstatic ssize_t\r\nqla4xxx_iscsi_func_cnt_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nif (!is_qla8022(ha))\r\nreturn -ENOSYS;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04X\n", ha->iscsi_pci_func_cnt);\r\n}\r\nstatic ssize_t\r\nqla4xxx_hba_model_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ha->model_name);\r\n}
