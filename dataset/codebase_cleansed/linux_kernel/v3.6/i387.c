static inline bool interrupted_kernel_fpu_idle(void)\r\n{\r\nreturn !__thread_has_fpu(current) &&\r\n(read_cr0() & X86_CR0_TS);\r\n}\r\nstatic inline bool interrupted_user_mode(void)\r\n{\r\nstruct pt_regs *regs = get_irq_regs();\r\nreturn regs && user_mode_vm(regs);\r\n}\r\nbool irq_fpu_usable(void)\r\n{\r\nreturn !in_interrupt() ||\r\ninterrupted_user_mode() ||\r\ninterrupted_kernel_fpu_idle();\r\n}\r\nvoid kernel_fpu_begin(void)\r\n{\r\nstruct task_struct *me = current;\r\nWARN_ON_ONCE(!irq_fpu_usable());\r\npreempt_disable();\r\nif (__thread_has_fpu(me)) {\r\n__save_init_fpu(me);\r\n__thread_clear_has_fpu(me);\r\n} else {\r\nthis_cpu_write(fpu_owner_task, NULL);\r\nclts();\r\n}\r\n}\r\nvoid kernel_fpu_end(void)\r\n{\r\nstts();\r\npreempt_enable();\r\n}\r\nvoid unlazy_fpu(struct task_struct *tsk)\r\n{\r\npreempt_disable();\r\nif (__thread_has_fpu(tsk)) {\r\n__save_init_fpu(tsk);\r\n__thread_fpu_end(tsk);\r\n} else\r\ntsk->fpu_counter = 0;\r\npreempt_enable();\r\n}\r\nstatic void __cpuinit mxcsr_feature_mask_init(void)\r\n{\r\nunsigned long mask = 0;\r\nclts();\r\nif (cpu_has_fxsr) {\r\nmemset(&fx_scratch, 0, sizeof(struct i387_fxsave_struct));\r\nasm volatile("fxsave %0" : : "m" (fx_scratch));\r\nmask = fx_scratch.mxcsr_mask;\r\nif (mask == 0)\r\nmask = 0x0000ffbf;\r\n}\r\nmxcsr_feature_mask &= mask;\r\nstts();\r\n}\r\nstatic void __cpuinit init_thread_xstate(void)\r\n{\r\nif (!HAVE_HWFP) {\r\nsetup_clear_cpu_cap(X86_FEATURE_XSAVE);\r\nsetup_clear_cpu_cap(X86_FEATURE_XSAVEOPT);\r\nxstate_size = sizeof(struct i387_soft_struct);\r\nreturn;\r\n}\r\nif (cpu_has_fxsr)\r\nxstate_size = sizeof(struct i387_fxsave_struct);\r\nelse\r\nxstate_size = sizeof(struct i387_fsave_struct);\r\n}\r\nvoid __cpuinit fpu_init(void)\r\n{\r\nunsigned long cr0;\r\nunsigned long cr4_mask = 0;\r\nif (cpu_has_fxsr)\r\ncr4_mask |= X86_CR4_OSFXSR;\r\nif (cpu_has_xmm)\r\ncr4_mask |= X86_CR4_OSXMMEXCPT;\r\nif (cr4_mask)\r\nset_in_cr4(cr4_mask);\r\ncr0 = read_cr0();\r\ncr0 &= ~(X86_CR0_TS|X86_CR0_EM);\r\nif (!HAVE_HWFP)\r\ncr0 |= X86_CR0_EM;\r\nwrite_cr0(cr0);\r\nif (!smp_processor_id())\r\ninit_thread_xstate();\r\nmxcsr_feature_mask_init();\r\ncurrent_thread_info()->status = 0;\r\nclear_used_math();\r\n}\r\nvoid fpu_finit(struct fpu *fpu)\r\n{\r\nif (!HAVE_HWFP) {\r\nfinit_soft_fpu(&fpu->state->soft);\r\nreturn;\r\n}\r\nif (cpu_has_fxsr) {\r\nstruct i387_fxsave_struct *fx = &fpu->state->fxsave;\r\nmemset(fx, 0, xstate_size);\r\nfx->cwd = 0x37f;\r\nif (cpu_has_xmm)\r\nfx->mxcsr = MXCSR_DEFAULT;\r\n} else {\r\nstruct i387_fsave_struct *fp = &fpu->state->fsave;\r\nmemset(fp, 0, xstate_size);\r\nfp->cwd = 0xffff037fu;\r\nfp->swd = 0xffff0000u;\r\nfp->twd = 0xffffffffu;\r\nfp->fos = 0xffff0000u;\r\n}\r\n}\r\nint init_fpu(struct task_struct *tsk)\r\n{\r\nint ret;\r\nif (tsk_used_math(tsk)) {\r\nif (HAVE_HWFP && tsk == current)\r\nunlazy_fpu(tsk);\r\ntsk->thread.fpu.last_cpu = ~0;\r\nreturn 0;\r\n}\r\nret = fpu_alloc(&tsk->thread.fpu);\r\nif (ret)\r\nreturn ret;\r\nfpu_finit(&tsk->thread.fpu);\r\nset_stopped_child_used_math(tsk);\r\nreturn 0;\r\n}\r\nint fpregs_active(struct task_struct *target, const struct user_regset *regset)\r\n{\r\nreturn tsk_used_math(target) ? regset->n : 0;\r\n}\r\nint xfpregs_active(struct task_struct *target, const struct user_regset *regset)\r\n{\r\nreturn (cpu_has_fxsr && tsk_used_math(target)) ? regset->n : 0;\r\n}\r\nint xfpregs_get(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nint ret;\r\nif (!cpu_has_fxsr)\r\nreturn -ENODEV;\r\nret = init_fpu(target);\r\nif (ret)\r\nreturn ret;\r\nsanitize_i387_state(target);\r\nreturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\n&target->thread.fpu.state->fxsave, 0, -1);\r\n}\r\nint xfpregs_set(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nint ret;\r\nif (!cpu_has_fxsr)\r\nreturn -ENODEV;\r\nret = init_fpu(target);\r\nif (ret)\r\nreturn ret;\r\nsanitize_i387_state(target);\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\n&target->thread.fpu.state->fxsave, 0, -1);\r\ntarget->thread.fpu.state->fxsave.mxcsr &= mxcsr_feature_mask;\r\nif (cpu_has_xsave)\r\ntarget->thread.fpu.state->xsave.xsave_hdr.xstate_bv |= XSTATE_FPSSE;\r\nreturn ret;\r\n}\r\nint xstateregs_get(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nint ret;\r\nif (!cpu_has_xsave)\r\nreturn -ENODEV;\r\nret = init_fpu(target);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(&target->thread.fpu.state->fxsave.sw_reserved,\r\nxstate_fx_sw_bytes, sizeof(xstate_fx_sw_bytes));\r\nret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\n&target->thread.fpu.state->xsave, 0, -1);\r\nreturn ret;\r\n}\r\nint xstateregs_set(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nint ret;\r\nstruct xsave_hdr_struct *xsave_hdr;\r\nif (!cpu_has_xsave)\r\nreturn -ENODEV;\r\nret = init_fpu(target);\r\nif (ret)\r\nreturn ret;\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\n&target->thread.fpu.state->xsave, 0, -1);\r\ntarget->thread.fpu.state->fxsave.mxcsr &= mxcsr_feature_mask;\r\nxsave_hdr = &target->thread.fpu.state->xsave.xsave_hdr;\r\nxsave_hdr->xstate_bv &= pcntxt_mask;\r\nxsave_hdr->reserved1[0] = xsave_hdr->reserved1[1] = 0;\r\nreturn ret;\r\n}\r\nstatic inline unsigned short twd_i387_to_fxsr(unsigned short twd)\r\n{\r\nunsigned int tmp;\r\ntmp = ~twd;\r\ntmp = (tmp | (tmp>>1)) & 0x5555;\r\ntmp = (tmp | (tmp >> 1)) & 0x3333;\r\ntmp = (tmp | (tmp >> 2)) & 0x0f0f;\r\ntmp = (tmp | (tmp >> 4)) & 0x00ff;\r\nreturn tmp;\r\n}\r\nstatic inline u32 twd_fxsr_to_i387(struct i387_fxsave_struct *fxsave)\r\n{\r\nstruct _fpxreg *st;\r\nu32 tos = (fxsave->swd >> 11) & 7;\r\nu32 twd = (unsigned long) fxsave->twd;\r\nu32 tag;\r\nu32 ret = 0xffff0000u;\r\nint i;\r\nfor (i = 0; i < 8; i++, twd >>= 1) {\r\nif (twd & 0x1) {\r\nst = FPREG_ADDR(fxsave, (i - tos) & 7);\r\nswitch (st->exponent & 0x7fff) {\r\ncase 0x7fff:\r\ntag = FP_EXP_TAG_SPECIAL;\r\nbreak;\r\ncase 0x0000:\r\nif (!st->significand[0] &&\r\n!st->significand[1] &&\r\n!st->significand[2] &&\r\n!st->significand[3])\r\ntag = FP_EXP_TAG_ZERO;\r\nelse\r\ntag = FP_EXP_TAG_SPECIAL;\r\nbreak;\r\ndefault:\r\nif (st->significand[3] & 0x8000)\r\ntag = FP_EXP_TAG_VALID;\r\nelse\r\ntag = FP_EXP_TAG_SPECIAL;\r\nbreak;\r\n}\r\n} else {\r\ntag = FP_EXP_TAG_EMPTY;\r\n}\r\nret |= tag << (2 * i);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nconvert_from_fxsr(struct user_i387_ia32_struct *env, struct task_struct *tsk)\r\n{\r\nstruct i387_fxsave_struct *fxsave = &tsk->thread.fpu.state->fxsave;\r\nstruct _fpreg *to = (struct _fpreg *) &env->st_space[0];\r\nstruct _fpxreg *from = (struct _fpxreg *) &fxsave->st_space[0];\r\nint i;\r\nenv->cwd = fxsave->cwd | 0xffff0000u;\r\nenv->swd = fxsave->swd | 0xffff0000u;\r\nenv->twd = twd_fxsr_to_i387(fxsave);\r\n#ifdef CONFIG_X86_64\r\nenv->fip = fxsave->rip;\r\nenv->foo = fxsave->rdp;\r\nenv->fcs = task_pt_regs(tsk)->cs;\r\nif (tsk == current) {\r\nsavesegment(ds, env->fos);\r\n} else {\r\nenv->fos = tsk->thread.ds;\r\n}\r\nenv->fos |= 0xffff0000;\r\n#else\r\nenv->fip = fxsave->fip;\r\nenv->fcs = (u16) fxsave->fcs | ((u32) fxsave->fop << 16);\r\nenv->foo = fxsave->foo;\r\nenv->fos = fxsave->fos;\r\n#endif\r\nfor (i = 0; i < 8; ++i)\r\nmemcpy(&to[i], &from[i], sizeof(to[0]));\r\n}\r\nstatic void convert_to_fxsr(struct task_struct *tsk,\r\nconst struct user_i387_ia32_struct *env)\r\n{\r\nstruct i387_fxsave_struct *fxsave = &tsk->thread.fpu.state->fxsave;\r\nstruct _fpreg *from = (struct _fpreg *) &env->st_space[0];\r\nstruct _fpxreg *to = (struct _fpxreg *) &fxsave->st_space[0];\r\nint i;\r\nfxsave->cwd = env->cwd;\r\nfxsave->swd = env->swd;\r\nfxsave->twd = twd_i387_to_fxsr(env->twd);\r\nfxsave->fop = (u16) ((u32) env->fcs >> 16);\r\n#ifdef CONFIG_X86_64\r\nfxsave->rip = env->fip;\r\nfxsave->rdp = env->foo;\r\n#else\r\nfxsave->fip = env->fip;\r\nfxsave->fcs = (env->fcs & 0xffff);\r\nfxsave->foo = env->foo;\r\nfxsave->fos = env->fos;\r\n#endif\r\nfor (i = 0; i < 8; ++i)\r\nmemcpy(&to[i], &from[i], sizeof(from[0]));\r\n}\r\nint fpregs_get(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nvoid *kbuf, void __user *ubuf)\r\n{\r\nstruct user_i387_ia32_struct env;\r\nint ret;\r\nret = init_fpu(target);\r\nif (ret)\r\nreturn ret;\r\nif (!HAVE_HWFP)\r\nreturn fpregs_soft_get(target, regset, pos, count, kbuf, ubuf);\r\nif (!cpu_has_fxsr) {\r\nreturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\r\n&target->thread.fpu.state->fsave, 0,\r\n-1);\r\n}\r\nsanitize_i387_state(target);\r\nif (kbuf && pos == 0 && count == sizeof(env)) {\r\nconvert_from_fxsr(kbuf, target);\r\nreturn 0;\r\n}\r\nconvert_from_fxsr(&env, target);\r\nreturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, &env, 0, -1);\r\n}\r\nint fpregs_set(struct task_struct *target, const struct user_regset *regset,\r\nunsigned int pos, unsigned int count,\r\nconst void *kbuf, const void __user *ubuf)\r\n{\r\nstruct user_i387_ia32_struct env;\r\nint ret;\r\nret = init_fpu(target);\r\nif (ret)\r\nreturn ret;\r\nsanitize_i387_state(target);\r\nif (!HAVE_HWFP)\r\nreturn fpregs_soft_set(target, regset, pos, count, kbuf, ubuf);\r\nif (!cpu_has_fxsr) {\r\nreturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\r\n&target->thread.fpu.state->fsave, 0, -1);\r\n}\r\nif (pos > 0 || count < sizeof(env))\r\nconvert_from_fxsr(&env, target);\r\nret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &env, 0, -1);\r\nif (!ret)\r\nconvert_to_fxsr(target, &env);\r\nif (cpu_has_xsave)\r\ntarget->thread.fpu.state->xsave.xsave_hdr.xstate_bv |= XSTATE_FP;\r\nreturn ret;\r\n}\r\nstatic inline int save_i387_fsave(struct _fpstate_ia32 __user *buf)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct i387_fsave_struct *fp = &tsk->thread.fpu.state->fsave;\r\nfp->status = fp->swd;\r\nif (__copy_to_user(buf, fp, sizeof(struct i387_fsave_struct)))\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int save_i387_fxsave(struct _fpstate_ia32 __user *buf)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct i387_fxsave_struct *fx = &tsk->thread.fpu.state->fxsave;\r\nstruct user_i387_ia32_struct env;\r\nint err = 0;\r\nconvert_from_fxsr(&env, tsk);\r\nif (__copy_to_user(buf, &env, sizeof(env)))\r\nreturn -1;\r\nerr |= __put_user(fx->swd, &buf->status);\r\nerr |= __put_user(X86_FXSR_MAGIC, &buf->magic);\r\nif (err)\r\nreturn -1;\r\nif (__copy_to_user(&buf->_fxsr_env[0], fx, xstate_size))\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int save_i387_xsave(void __user *buf)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct _fpstate_ia32 __user *fx = buf;\r\nint err = 0;\r\nsanitize_i387_state(tsk);\r\ntsk->thread.fpu.state->xsave.xsave_hdr.xstate_bv |= XSTATE_FPSSE;\r\nif (save_i387_fxsave(fx) < 0)\r\nreturn -1;\r\nerr = __copy_to_user(&fx->sw_reserved, &fx_sw_reserved_ia32,\r\nsizeof(struct _fpx_sw_bytes));\r\nerr |= __put_user(FP_XSTATE_MAGIC2,\r\n(__u32 __user *) (buf + sig_xstate_ia32_size\r\n- FP_XSTATE_MAGIC2_SIZE));\r\nif (err)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nint save_i387_xstate_ia32(void __user *buf)\r\n{\r\nstruct _fpstate_ia32 __user *fp = (struct _fpstate_ia32 __user *) buf;\r\nstruct task_struct *tsk = current;\r\nif (!used_math())\r\nreturn 0;\r\nif (!access_ok(VERIFY_WRITE, buf, sig_xstate_ia32_size))\r\nreturn -EACCES;\r\nclear_used_math();\r\nif (!HAVE_HWFP) {\r\nreturn fpregs_soft_get(current, NULL,\r\n0, sizeof(struct user_i387_ia32_struct),\r\nNULL, fp) ? -1 : 1;\r\n}\r\nunlazy_fpu(tsk);\r\nif (cpu_has_xsave)\r\nreturn save_i387_xsave(fp);\r\nif (cpu_has_fxsr)\r\nreturn save_i387_fxsave(fp);\r\nelse\r\nreturn save_i387_fsave(fp);\r\n}\r\nstatic inline int restore_i387_fsave(struct _fpstate_ia32 __user *buf)\r\n{\r\nstruct task_struct *tsk = current;\r\nreturn __copy_from_user(&tsk->thread.fpu.state->fsave, buf,\r\nsizeof(struct i387_fsave_struct));\r\n}\r\nstatic int restore_i387_fxsave(struct _fpstate_ia32 __user *buf,\r\nunsigned int size)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct user_i387_ia32_struct env;\r\nint err;\r\nerr = __copy_from_user(&tsk->thread.fpu.state->fxsave, &buf->_fxsr_env[0],\r\nsize);\r\ntsk->thread.fpu.state->fxsave.mxcsr &= mxcsr_feature_mask;\r\nif (err || __copy_from_user(&env, buf, sizeof(env)))\r\nreturn 1;\r\nconvert_to_fxsr(tsk, &env);\r\nreturn 0;\r\n}\r\nstatic int restore_i387_xsave(void __user *buf)\r\n{\r\nstruct _fpx_sw_bytes fx_sw_user;\r\nstruct _fpstate_ia32 __user *fx_user =\r\n((struct _fpstate_ia32 __user *) buf);\r\nstruct i387_fxsave_struct __user *fx =\r\n(struct i387_fxsave_struct __user *) &fx_user->_fxsr_env[0];\r\nstruct xsave_hdr_struct *xsave_hdr =\r\n&current->thread.fpu.state->xsave.xsave_hdr;\r\nu64 mask;\r\nint err;\r\nif (check_for_xstate(fx, buf, &fx_sw_user))\r\ngoto fx_only;\r\nmask = fx_sw_user.xstate_bv;\r\nerr = restore_i387_fxsave(buf, fx_sw_user.xstate_size);\r\nxsave_hdr->xstate_bv &= pcntxt_mask;\r\nxsave_hdr->reserved1[0] = xsave_hdr->reserved1[1] = 0;\r\nmask = ~(pcntxt_mask & ~mask);\r\nxsave_hdr->xstate_bv &= mask;\r\nreturn err;\r\nfx_only:\r\nxsave_hdr->xstate_bv = XSTATE_FPSSE;\r\nreturn restore_i387_fxsave(buf, sizeof(struct i387_fxsave_struct));\r\n}\r\nint restore_i387_xstate_ia32(void __user *buf)\r\n{\r\nint err;\r\nstruct task_struct *tsk = current;\r\nstruct _fpstate_ia32 __user *fp = (struct _fpstate_ia32 __user *) buf;\r\nif (HAVE_HWFP)\r\nclear_fpu(tsk);\r\nif (!buf) {\r\nif (used_math()) {\r\nclear_fpu(tsk);\r\nclear_used_math();\r\n}\r\nreturn 0;\r\n} else\r\nif (!access_ok(VERIFY_READ, buf, sig_xstate_ia32_size))\r\nreturn -EACCES;\r\nif (!used_math()) {\r\nerr = init_fpu(tsk);\r\nif (err)\r\nreturn err;\r\n}\r\nif (HAVE_HWFP) {\r\nif (cpu_has_xsave)\r\nerr = restore_i387_xsave(buf);\r\nelse if (cpu_has_fxsr)\r\nerr = restore_i387_fxsave(fp, sizeof(struct\r\ni387_fxsave_struct));\r\nelse\r\nerr = restore_i387_fsave(fp);\r\n} else {\r\nerr = fpregs_soft_set(current, NULL,\r\n0, sizeof(struct user_i387_ia32_struct),\r\nNULL, fp) != 0;\r\n}\r\nset_used_math();\r\nreturn err;\r\n}\r\nint dump_fpu(struct pt_regs *regs, struct user_i387_struct *fpu)\r\n{\r\nstruct task_struct *tsk = current;\r\nint fpvalid;\r\nfpvalid = !!used_math();\r\nif (fpvalid)\r\nfpvalid = !fpregs_get(tsk, NULL,\r\n0, sizeof(struct user_i387_ia32_struct),\r\nfpu, NULL);\r\nreturn fpvalid;\r\n}
