static void rhine_wait_bit(struct rhine_private *rp, u8 reg, u8 mask, bool low)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\nint i;\r\nfor (i = 0; i < 1024; i++) {\r\nbool has_mask_bits = !!(ioread8(ioaddr + reg) & mask);\r\nif (low ^ has_mask_bits)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i > 64) {\r\nnetif_dbg(rp, hw, rp->dev, "%s bit wait (%02x/%02x) cycle "\r\n"count: %04d\n", low ? "low" : "high", reg, mask, i);\r\n}\r\n}\r\nstatic void rhine_wait_bit_high(struct rhine_private *rp, u8 reg, u8 mask)\r\n{\r\nrhine_wait_bit(rp, reg, mask, false);\r\n}\r\nstatic void rhine_wait_bit_low(struct rhine_private *rp, u8 reg, u8 mask)\r\n{\r\nrhine_wait_bit(rp, reg, mask, true);\r\n}\r\nstatic u32 rhine_get_events(struct rhine_private *rp)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\nu32 intr_status;\r\nintr_status = ioread16(ioaddr + IntrStatus);\r\nif (rp->quirks & rqStatusWBRace)\r\nintr_status |= ioread8(ioaddr + IntrStatus2) << 16;\r\nreturn intr_status;\r\n}\r\nstatic void rhine_ack_events(struct rhine_private *rp, u32 mask)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\nif (rp->quirks & rqStatusWBRace)\r\niowrite8(mask >> 16, ioaddr + IntrStatus2);\r\niowrite16(mask, ioaddr + IntrStatus);\r\nmmiowb();\r\n}\r\nstatic void rhine_power_init(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu16 wolstat;\r\nif (rp->quirks & rqWOL) {\r\niowrite8(ioread8(ioaddr + StickyHW) & 0xFC, ioaddr + StickyHW);\r\niowrite8(0x80, ioaddr + WOLcgClr);\r\niowrite8(0xFF, ioaddr + WOLcrClr);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x03, ioaddr + WOLcrClr1);\r\nwolstat = ioread8(ioaddr + PwrcsrSet);\r\nif (rp->quirks & rq6patterns)\r\nwolstat |= (ioread8(ioaddr + PwrcsrSet1) & 0x03) << 8;\r\niowrite8(0xFF, ioaddr + PwrcsrClr);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x03, ioaddr + PwrcsrClr1);\r\nif (wolstat) {\r\nchar *reason;\r\nswitch (wolstat) {\r\ncase WOLmagic:\r\nreason = "Magic packet";\r\nbreak;\r\ncase WOLlnkon:\r\nreason = "Link went up";\r\nbreak;\r\ncase WOLlnkoff:\r\nreason = "Link went down";\r\nbreak;\r\ncase WOLucast:\r\nreason = "Unicast packet";\r\nbreak;\r\ncase WOLbmcast:\r\nreason = "Multicast/broadcast packet";\r\nbreak;\r\ndefault:\r\nreason = "Unknown";\r\n}\r\nnetdev_info(dev, "Woke system up. Reason: %s\n",\r\nreason);\r\n}\r\n}\r\n}\r\nstatic void rhine_chip_reset(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu8 cmd1;\r\niowrite8(Cmd1Reset, ioaddr + ChipCmd1);\r\nIOSYNC;\r\nif (ioread8(ioaddr + ChipCmd1) & Cmd1Reset) {\r\nnetdev_info(dev, "Reset not complete yet. Trying harder.\n");\r\nif (rp->quirks & rqForceReset)\r\niowrite8(0x40, ioaddr + MiscCmd);\r\nrhine_wait_bit_low(rp, ChipCmd1, Cmd1Reset);\r\n}\r\ncmd1 = ioread8(ioaddr + ChipCmd1);\r\nnetif_info(rp, hw, dev, "Reset %s\n", (cmd1 & Cmd1Reset) ?\r\n"failed" : "succeeded");\r\n}\r\nstatic void enable_mmio(long pioaddr, u32 quirks)\r\n{\r\nint n;\r\nif (quirks & rqRhineI) {\r\nn = inb(pioaddr + ConfigA) | 0x20;\r\noutb(n, pioaddr + ConfigA);\r\n} else {\r\nn = inb(pioaddr + ConfigD) | 0x80;\r\noutb(n, pioaddr + ConfigD);\r\n}\r\n}\r\nstatic void __devinit rhine_reload_eeprom(long pioaddr, struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint i;\r\noutb(0x20, pioaddr + MACRegEEcsr);\r\nfor (i = 0; i < 1024; i++) {\r\nif (!(inb(pioaddr + MACRegEEcsr) & 0x20))\r\nbreak;\r\n}\r\nif (i > 512)\r\npr_info("%4d cycles used @ %s:%d\n", i, __func__, __LINE__);\r\n#ifdef USE_MMIO\r\nenable_mmio(pioaddr, rp->quirks);\r\n#endif\r\nif (rp->quirks & rqWOL)\r\niowrite8(ioread8(ioaddr + ConfigA) & 0xFC, ioaddr + ConfigA);\r\n}\r\nstatic void rhine_poll(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nconst int irq = rp->pdev->irq;\r\ndisable_irq(irq);\r\nrhine_interrupt(irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic void rhine_kick_tx_threshold(struct rhine_private *rp)\r\n{\r\nif (rp->tx_thresh < 0xe0) {\r\nvoid __iomem *ioaddr = rp->base;\r\nrp->tx_thresh += 0x20;\r\nBYTE_REG_BITS_SET(rp->tx_thresh, 0x80, ioaddr + TxConfig);\r\n}\r\n}\r\nstatic void rhine_tx_err(struct rhine_private *rp, u32 status)\r\n{\r\nstruct net_device *dev = rp->dev;\r\nif (status & IntrTxAborted) {\r\nnetif_info(rp, tx_err, dev,\r\n"Abort %08x, frame dropped\n", status);\r\n}\r\nif (status & IntrTxUnderrun) {\r\nrhine_kick_tx_threshold(rp);\r\nnetif_info(rp, tx_err ,dev, "Transmitter underrun, "\r\n"Tx threshold now %02x\n", rp->tx_thresh);\r\n}\r\nif (status & IntrTxDescRace)\r\nnetif_info(rp, tx_err, dev, "Tx descriptor write-back race\n");\r\nif ((status & IntrTxError) &&\r\n(status & (IntrTxAborted | IntrTxUnderrun | IntrTxDescRace)) == 0) {\r\nrhine_kick_tx_threshold(rp);\r\nnetif_info(rp, tx_err, dev, "Unspecified error. "\r\n"Tx threshold now %02x\n", rp->tx_thresh);\r\n}\r\nrhine_restart_tx(dev);\r\n}\r\nstatic void rhine_update_rx_crc_and_missed_errord(struct rhine_private *rp)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\nstruct net_device_stats *stats = &rp->dev->stats;\r\nstats->rx_crc_errors += ioread16(ioaddr + RxCRCErrs);\r\nstats->rx_missed_errors += ioread16(ioaddr + RxMissed);\r\niowrite32(0, ioaddr + RxMissed);\r\nioread16(ioaddr + RxCRCErrs);\r\nioread16(ioaddr + RxMissed);\r\n}\r\nstatic int rhine_napipoll(struct napi_struct *napi, int budget)\r\n{\r\nstruct rhine_private *rp = container_of(napi, struct rhine_private, napi);\r\nstruct net_device *dev = rp->dev;\r\nvoid __iomem *ioaddr = rp->base;\r\nu16 enable_mask = RHINE_EVENT & 0xffff;\r\nint work_done = 0;\r\nu32 status;\r\nstatus = rhine_get_events(rp);\r\nrhine_ack_events(rp, status & ~RHINE_EVENT_SLOW);\r\nif (status & RHINE_EVENT_NAPI_RX)\r\nwork_done += rhine_rx(dev, budget);\r\nif (status & RHINE_EVENT_NAPI_TX) {\r\nif (status & RHINE_EVENT_NAPI_TX_ERR) {\r\nrhine_wait_bit_low(rp, ChipCmd, CmdTxOn);\r\nif (ioread8(ioaddr + ChipCmd) & CmdTxOn)\r\nnetif_warn(rp, tx_err, dev, "Tx still on\n");\r\n}\r\nrhine_tx(dev);\r\nif (status & RHINE_EVENT_NAPI_TX_ERR)\r\nrhine_tx_err(rp, status);\r\n}\r\nif (status & IntrStatsMax) {\r\nspin_lock(&rp->lock);\r\nrhine_update_rx_crc_and_missed_errord(rp);\r\nspin_unlock(&rp->lock);\r\n}\r\nif (status & RHINE_EVENT_SLOW) {\r\nenable_mask &= ~RHINE_EVENT_SLOW;\r\nschedule_work(&rp->slow_event_task);\r\n}\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\niowrite16(enable_mask, ioaddr + IntrEnable);\r\nmmiowb();\r\n}\r\nreturn work_done;\r\n}\r\nstatic void __devinit rhine_hw_init(struct net_device *dev, long pioaddr)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nrhine_chip_reset(dev);\r\nif (rp->quirks & rqRhineI)\r\nmsleep(5);\r\nrhine_reload_eeprom(pioaddr, dev);\r\n}\r\nstatic int __devinit rhine_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct rhine_private *rp;\r\nint i, rc;\r\nu32 quirks;\r\nlong pioaddr;\r\nlong memaddr;\r\nvoid __iomem *ioaddr;\r\nint io_size, phy_id;\r\nconst char *name;\r\n#ifdef USE_MMIO\r\nint bar = 1;\r\n#else\r\nint bar = 0;\r\n#endif\r\n#ifndef MODULE\r\npr_info_once("%s\n", version);\r\n#endif\r\nio_size = 256;\r\nphy_id = 0;\r\nquirks = 0;\r\nname = "Rhine";\r\nif (pdev->revision < VTunknown0) {\r\nquirks = rqRhineI;\r\nio_size = 128;\r\n}\r\nelse if (pdev->revision >= VT6102) {\r\nquirks = rqWOL | rqForceReset;\r\nif (pdev->revision < VT6105) {\r\nname = "Rhine II";\r\nquirks |= rqStatusWBRace;\r\n}\r\nelse {\r\nphy_id = 1;\r\nif (pdev->revision >= VT6105_B0)\r\nquirks |= rq6patterns;\r\nif (pdev->revision < VT6105M)\r\nname = "Rhine III";\r\nelse\r\nname = "Rhine III (Management Adapter)";\r\n}\r\n}\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err_out;\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"32-bit PCI DMA addresses not supported by the card!?\n");\r\ngoto err_out;\r\n}\r\nif ((pci_resource_len(pdev, 0) < io_size) ||\r\n(pci_resource_len(pdev, 1) < io_size)) {\r\nrc = -EIO;\r\ndev_err(&pdev->dev, "Insufficient PCI resources, aborting\n");\r\ngoto err_out;\r\n}\r\npioaddr = pci_resource_start(pdev, 0);\r\nmemaddr = pci_resource_start(pdev, 1);\r\npci_set_master(pdev);\r\ndev = alloc_etherdev(sizeof(struct rhine_private));\r\nif (!dev) {\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nrp = netdev_priv(dev);\r\nrp->dev = dev;\r\nrp->quirks = quirks;\r\nrp->pioaddr = pioaddr;\r\nrp->pdev = pdev;\r\nrp->msg_enable = netif_msg_init(debug, RHINE_MSG_DEFAULT);\r\nrc = pci_request_regions(pdev, DRV_NAME);\r\nif (rc)\r\ngoto err_out_free_netdev;\r\nioaddr = pci_iomap(pdev, bar, io_size);\r\nif (!ioaddr) {\r\nrc = -EIO;\r\ndev_err(&pdev->dev,\r\n"ioremap failed for device %s, region 0x%X @ 0x%lX\n",\r\npci_name(pdev), io_size, memaddr);\r\ngoto err_out_free_res;\r\n}\r\n#ifdef USE_MMIO\r\nenable_mmio(pioaddr, quirks);\r\ni = 0;\r\nwhile (mmio_verify_registers[i]) {\r\nint reg = mmio_verify_registers[i++];\r\nunsigned char a = inb(pioaddr+reg);\r\nunsigned char b = readb(ioaddr+reg);\r\nif (a != b) {\r\nrc = -EIO;\r\ndev_err(&pdev->dev,\r\n"MMIO do not match PIO [%02x] (%02x != %02x)\n",\r\nreg, a, b);\r\ngoto err_out_unmap;\r\n}\r\n}\r\n#endif\r\nrp->base = ioaddr;\r\nrhine_power_init(dev);\r\nrhine_hw_init(dev, pioaddr);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = ioread8(ioaddr + StationAddr + i);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nnetdev_err(dev, "Invalid MAC address: %pM\n", dev->dev_addr);\r\neth_hw_addr_random(dev);\r\nnetdev_info(dev, "Using random MAC address: %pM\n",\r\ndev->dev_addr);\r\n}\r\nmemcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);\r\nif (!phy_id)\r\nphy_id = ioread8(ioaddr + 0x6C);\r\nspin_lock_init(&rp->lock);\r\nmutex_init(&rp->task_lock);\r\nINIT_WORK(&rp->reset_task, rhine_reset_task);\r\nINIT_WORK(&rp->slow_event_task, rhine_slow_event_task);\r\nrp->mii_if.dev = dev;\r\nrp->mii_if.mdio_read = mdio_read;\r\nrp->mii_if.mdio_write = mdio_write;\r\nrp->mii_if.phy_id_mask = 0x1f;\r\nrp->mii_if.reg_num_mask = 0x1f;\r\ndev->netdev_ops = &rhine_netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops,\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nnetif_napi_add(dev, &rp->napi, rhine_napipoll, 64);\r\nif (rp->quirks & rqRhineI)\r\ndev->features |= NETIF_F_SG|NETIF_F_HW_CSUM;\r\nif (pdev->revision >= VT6105M)\r\ndev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |\r\nNETIF_F_HW_VLAN_FILTER;\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_out_unmap;\r\nnetdev_info(dev, "VIA %s at 0x%lx, %pM, IRQ %d\n",\r\nname,\r\n#ifdef USE_MMIO\r\nmemaddr,\r\n#else\r\n(long)ioaddr,\r\n#endif\r\ndev->dev_addr, pdev->irq);\r\npci_set_drvdata(pdev, dev);\r\n{\r\nu16 mii_cmd;\r\nint mii_status = mdio_read(dev, phy_id, 1);\r\nmii_cmd = mdio_read(dev, phy_id, MII_BMCR) & ~BMCR_ISOLATE;\r\nmdio_write(dev, phy_id, MII_BMCR, mii_cmd);\r\nif (mii_status != 0xffff && mii_status != 0x0000) {\r\nrp->mii_if.advertising = mdio_read(dev, phy_id, 4);\r\nnetdev_info(dev,\r\n"MII PHY found at address %d, status 0x%04x advertising %04x Link %04x\n",\r\nphy_id,\r\nmii_status, rp->mii_if.advertising,\r\nmdio_read(dev, phy_id, 5));\r\nif (mii_status & BMSR_LSTATUS)\r\nnetif_carrier_on(dev);\r\nelse\r\nnetif_carrier_off(dev);\r\n}\r\n}\r\nrp->mii_if.phy_id = phy_id;\r\nif (avoid_D3)\r\nnetif_info(rp, probe, dev, "No D3 power state at shutdown\n");\r\nreturn 0;\r\nerr_out_unmap:\r\npci_iounmap(pdev, ioaddr);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_free_netdev:\r\nfree_netdev(dev);\r\nerr_out:\r\nreturn rc;\r\n}\r\nstatic int alloc_ring(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid *ring;\r\ndma_addr_t ring_dma;\r\nring = pci_alloc_consistent(rp->pdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\n&ring_dma);\r\nif (!ring) {\r\nnetdev_err(dev, "Could not allocate DMA memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (rp->quirks & rqRhineI) {\r\nrp->tx_bufs = pci_alloc_consistent(rp->pdev,\r\nPKT_BUF_SZ * TX_RING_SIZE,\r\n&rp->tx_bufs_dma);\r\nif (rp->tx_bufs == NULL) {\r\npci_free_consistent(rp->pdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\nring, ring_dma);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nrp->rx_ring = ring;\r\nrp->tx_ring = ring + RX_RING_SIZE * sizeof(struct rx_desc);\r\nrp->rx_ring_dma = ring_dma;\r\nrp->tx_ring_dma = ring_dma + RX_RING_SIZE * sizeof(struct rx_desc);\r\nreturn 0;\r\n}\r\nstatic void free_ring(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\npci_free_consistent(rp->pdev,\r\nRX_RING_SIZE * sizeof(struct rx_desc) +\r\nTX_RING_SIZE * sizeof(struct tx_desc),\r\nrp->rx_ring, rp->rx_ring_dma);\r\nrp->tx_ring = NULL;\r\nif (rp->tx_bufs)\r\npci_free_consistent(rp->pdev, PKT_BUF_SZ * TX_RING_SIZE,\r\nrp->tx_bufs, rp->tx_bufs_dma);\r\nrp->tx_bufs = NULL;\r\n}\r\nstatic void alloc_rbufs(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\ndma_addr_t next;\r\nint i;\r\nrp->dirty_rx = rp->cur_rx = 0;\r\nrp->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\r\nrp->rx_head_desc = &rp->rx_ring[0];\r\nnext = rp->rx_ring_dma;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nrp->rx_ring[i].rx_status = 0;\r\nrp->rx_ring[i].desc_length = cpu_to_le32(rp->rx_buf_sz);\r\nnext += sizeof(struct rx_desc);\r\nrp->rx_ring[i].next_desc = cpu_to_le32(next);\r\nrp->rx_skbuff[i] = NULL;\r\n}\r\nrp->rx_ring[i-1].next_desc = cpu_to_le32(rp->rx_ring_dma);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, rp->rx_buf_sz);\r\nrp->rx_skbuff[i] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nrp->rx_skbuff_dma[i] =\r\npci_map_single(rp->pdev, skb->data, rp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nrp->rx_ring[i].addr = cpu_to_le32(rp->rx_skbuff_dma[i]);\r\nrp->rx_ring[i].rx_status = cpu_to_le32(DescOwn);\r\n}\r\nrp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\r\n}\r\nstatic void free_rbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nrp->rx_ring[i].rx_status = 0;\r\nrp->rx_ring[i].addr = cpu_to_le32(0xBADF00D0);\r\nif (rp->rx_skbuff[i]) {\r\npci_unmap_single(rp->pdev,\r\nrp->rx_skbuff_dma[i],\r\nrp->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(rp->rx_skbuff[i]);\r\n}\r\nrp->rx_skbuff[i] = NULL;\r\n}\r\n}\r\nstatic void alloc_tbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\ndma_addr_t next;\r\nint i;\r\nrp->dirty_tx = rp->cur_tx = 0;\r\nnext = rp->tx_ring_dma;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nrp->tx_skbuff[i] = NULL;\r\nrp->tx_ring[i].tx_status = 0;\r\nrp->tx_ring[i].desc_length = cpu_to_le32(TXDESC);\r\nnext += sizeof(struct tx_desc);\r\nrp->tx_ring[i].next_desc = cpu_to_le32(next);\r\nif (rp->quirks & rqRhineI)\r\nrp->tx_buf[i] = &rp->tx_bufs[i * PKT_BUF_SZ];\r\n}\r\nrp->tx_ring[i-1].next_desc = cpu_to_le32(rp->tx_ring_dma);\r\n}\r\nstatic void free_tbufs(struct net_device* dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nrp->tx_ring[i].tx_status = 0;\r\nrp->tx_ring[i].desc_length = cpu_to_le32(TXDESC);\r\nrp->tx_ring[i].addr = cpu_to_le32(0xBADF00D0);\r\nif (rp->tx_skbuff[i]) {\r\nif (rp->tx_skbuff_dma[i]) {\r\npci_unmap_single(rp->pdev,\r\nrp->tx_skbuff_dma[i],\r\nrp->tx_skbuff[i]->len,\r\nPCI_DMA_TODEVICE);\r\n}\r\ndev_kfree_skb(rp->tx_skbuff[i]);\r\n}\r\nrp->tx_skbuff[i] = NULL;\r\nrp->tx_buf[i] = NULL;\r\n}\r\n}\r\nstatic void rhine_check_media(struct net_device *dev, unsigned int init_media)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nmii_check_media(&rp->mii_if, netif_msg_link(rp), init_media);\r\nif (rp->mii_if.full_duplex)\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1FDuplex,\r\nioaddr + ChipCmd1);\r\nelse\r\niowrite8(ioread8(ioaddr + ChipCmd1) & ~Cmd1FDuplex,\r\nioaddr + ChipCmd1);\r\nnetif_info(rp, link, dev, "force_media %d, carrier %d\n",\r\nrp->mii_if.force_media, netif_carrier_ok(dev));\r\n}\r\nstatic void rhine_set_carrier(struct mii_if_info *mii)\r\n{\r\nstruct net_device *dev = mii->dev;\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (mii->force_media) {\r\nif (!netif_carrier_ok(dev))\r\nnetif_carrier_on(dev);\r\n} else\r\nrhine_check_media(dev, 0);\r\nnetif_info(rp, link, dev, "force_media %d, carrier %d\n",\r\nmii->force_media, netif_carrier_ok(dev));\r\n}\r\nstatic void rhine_set_cam(void __iomem *ioaddr, int idx, u8 *addr)\r\n{\r\nint i;\r\niowrite8(CAMC_CAMEN, ioaddr + CamCon);\r\nwmb();\r\nidx &= (MCAM_SIZE - 1);\r\niowrite8((u8) idx, ioaddr + CamAddr);\r\nfor (i = 0; i < 6; i++, addr++)\r\niowrite8(*addr, ioaddr + MulticastFilter0 + i);\r\nudelay(10);\r\nwmb();\r\niowrite8(CAMC_CAMWR | CAMC_CAMEN, ioaddr + CamCon);\r\nudelay(10);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_vlan_cam(void __iomem *ioaddr, int idx, u8 *addr)\r\n{\r\niowrite8(CAMC_CAMEN | CAMC_VCAMSL, ioaddr + CamCon);\r\nwmb();\r\nidx &= (VCAM_SIZE - 1);\r\niowrite8((u8) idx, ioaddr + CamAddr);\r\niowrite16(*((u16 *) addr), ioaddr + MulticastFilter0 + 6);\r\nudelay(10);\r\nwmb();\r\niowrite8(CAMC_CAMWR | CAMC_CAMEN, ioaddr + CamCon);\r\nudelay(10);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_cam_mask(void __iomem *ioaddr, u32 mask)\r\n{\r\niowrite8(CAMC_CAMEN, ioaddr + CamCon);\r\nwmb();\r\niowrite32(mask, ioaddr + CamMask);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_set_vlan_cam_mask(void __iomem *ioaddr, u32 mask)\r\n{\r\niowrite8(CAMC_CAMEN | CAMC_VCAMSL, ioaddr + CamCon);\r\nwmb();\r\niowrite32(mask, ioaddr + CamMask);\r\niowrite8(0, ioaddr + CamCon);\r\n}\r\nstatic void rhine_init_cam_filter(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nrhine_set_vlan_cam_mask(ioaddr, 0);\r\nrhine_set_cam_mask(ioaddr, 0);\r\nBYTE_REG_BITS_ON(TCR_PQEN, ioaddr + TxConfig);\r\nBYTE_REG_BITS_OFF(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\n}\r\nstatic void rhine_update_vcam(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu16 vid;\r\nu32 vCAMmask = 0;\r\nunsigned int i = 0;\r\nfor_each_set_bit(vid, rp->active_vlans, VLAN_N_VID) {\r\nrhine_set_vlan_cam(ioaddr, i, (u8 *)&vid);\r\nvCAMmask |= 1 << i;\r\nif (++i >= VCAM_SIZE)\r\nbreak;\r\n}\r\nrhine_set_vlan_cam_mask(ioaddr, vCAMmask);\r\n}\r\nstatic int rhine_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nspin_lock_bh(&rp->lock);\r\nset_bit(vid, rp->active_vlans);\r\nrhine_update_vcam(dev);\r\nspin_unlock_bh(&rp->lock);\r\nreturn 0;\r\n}\r\nstatic int rhine_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nspin_lock_bh(&rp->lock);\r\nclear_bit(vid, rp->active_vlans);\r\nrhine_update_vcam(dev);\r\nspin_unlock_bh(&rp->lock);\r\nreturn 0;\r\n}\r\nstatic void init_registers(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint i;\r\nfor (i = 0; i < 6; i++)\r\niowrite8(dev->dev_addr[i], ioaddr + StationAddr + i);\r\niowrite16(0x0006, ioaddr + PCIBusConfig);\r\niowrite8(0x20, ioaddr + TxConfig);\r\nrp->tx_thresh = 0x20;\r\nrp->rx_thresh = 0x60;\r\niowrite32(rp->rx_ring_dma, ioaddr + RxRingPtr);\r\niowrite32(rp->tx_ring_dma, ioaddr + TxRingPtr);\r\nrhine_set_rx_mode(dev);\r\nif (rp->pdev->revision >= VT6105M)\r\nrhine_init_cam_filter(dev);\r\nnapi_enable(&rp->napi);\r\niowrite16(RHINE_EVENT & 0xffff, ioaddr + IntrEnable);\r\niowrite16(CmdStart | CmdTxOn | CmdRxOn | (Cmd1NoTxPoll << 8),\r\nioaddr + ChipCmd);\r\nrhine_check_media(dev, 1);\r\n}\r\nstatic void rhine_enable_linkmon(struct rhine_private *rp)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\niowrite8(0, ioaddr + MIICmd);\r\niowrite8(MII_BMSR, ioaddr + MIIRegAddr);\r\niowrite8(0x80, ioaddr + MIICmd);\r\nrhine_wait_bit_high(rp, MIIRegAddr, 0x20);\r\niowrite8(MII_BMSR | 0x40, ioaddr + MIIRegAddr);\r\n}\r\nstatic void rhine_disable_linkmon(struct rhine_private *rp)\r\n{\r\nvoid __iomem *ioaddr = rp->base;\r\niowrite8(0, ioaddr + MIICmd);\r\nif (rp->quirks & rqRhineI) {\r\niowrite8(0x01, ioaddr + MIIRegAddr);\r\nmdelay(1);\r\niowrite8(0x80, ioaddr + MIICmd);\r\nrhine_wait_bit_high(rp, MIIRegAddr, 0x20);\r\niowrite8(0, ioaddr + MIICmd);\r\n}\r\nelse\r\nrhine_wait_bit_high(rp, MIIRegAddr, 0x80);\r\n}\r\nstatic int mdio_read(struct net_device *dev, int phy_id, int regnum)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint result;\r\nrhine_disable_linkmon(rp);\r\niowrite8(phy_id, ioaddr + MIIPhyAddr);\r\niowrite8(regnum, ioaddr + MIIRegAddr);\r\niowrite8(0x40, ioaddr + MIICmd);\r\nrhine_wait_bit_low(rp, MIICmd, 0x40);\r\nresult = ioread16(ioaddr + MIIData);\r\nrhine_enable_linkmon(rp);\r\nreturn result;\r\n}\r\nstatic void mdio_write(struct net_device *dev, int phy_id, int regnum, int value)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nrhine_disable_linkmon(rp);\r\niowrite8(phy_id, ioaddr + MIIPhyAddr);\r\niowrite8(regnum, ioaddr + MIIRegAddr);\r\niowrite16(value, ioaddr + MIIData);\r\niowrite8(0x20, ioaddr + MIICmd);\r\nrhine_wait_bit_low(rp, MIICmd, 0x20);\r\nrhine_enable_linkmon(rp);\r\n}\r\nstatic void rhine_task_disable(struct rhine_private *rp)\r\n{\r\nmutex_lock(&rp->task_lock);\r\nrp->task_enable = false;\r\nmutex_unlock(&rp->task_lock);\r\ncancel_work_sync(&rp->slow_event_task);\r\ncancel_work_sync(&rp->reset_task);\r\n}\r\nstatic void rhine_task_enable(struct rhine_private *rp)\r\n{\r\nmutex_lock(&rp->task_lock);\r\nrp->task_enable = true;\r\nmutex_unlock(&rp->task_lock);\r\n}\r\nstatic int rhine_open(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint rc;\r\nrc = request_irq(rp->pdev->irq, rhine_interrupt, IRQF_SHARED, dev->name,\r\ndev);\r\nif (rc)\r\nreturn rc;\r\nnetif_dbg(rp, ifup, dev, "%s() irq %d\n", __func__, rp->pdev->irq);\r\nrc = alloc_ring(dev);\r\nif (rc) {\r\nfree_irq(rp->pdev->irq, dev);\r\nreturn rc;\r\n}\r\nalloc_rbufs(dev);\r\nalloc_tbufs(dev);\r\nrhine_chip_reset(dev);\r\nrhine_task_enable(rp);\r\ninit_registers(dev);\r\nnetif_dbg(rp, ifup, dev, "%s() Done - status %04x MII status: %04x\n",\r\n__func__, ioread16(ioaddr + ChipCmd),\r\nmdio_read(dev, rp->mii_if.phy_id, MII_BMSR));\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void rhine_reset_task(struct work_struct *work)\r\n{\r\nstruct rhine_private *rp = container_of(work, struct rhine_private,\r\nreset_task);\r\nstruct net_device *dev = rp->dev;\r\nmutex_lock(&rp->task_lock);\r\nif (!rp->task_enable)\r\ngoto out_unlock;\r\nnapi_disable(&rp->napi);\r\nspin_lock_bh(&rp->lock);\r\nfree_tbufs(dev);\r\nfree_rbufs(dev);\r\nalloc_tbufs(dev);\r\nalloc_rbufs(dev);\r\nrhine_chip_reset(dev);\r\ninit_registers(dev);\r\nspin_unlock_bh(&rp->lock);\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_errors++;\r\nnetif_wake_queue(dev);\r\nout_unlock:\r\nmutex_unlock(&rp->task_lock);\r\n}\r\nstatic void rhine_tx_timeout(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nnetdev_warn(dev, "Transmit timed out, status %04x, PHY status %04x, resetting...\n",\r\nioread16(ioaddr + IntrStatus),\r\nmdio_read(dev, rp->mii_if.phy_id, MII_BMSR));\r\nschedule_work(&rp->reset_task);\r\n}\r\nstatic netdev_tx_t rhine_start_tx(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nunsigned entry;\r\nentry = rp->cur_tx % TX_RING_SIZE;\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nrp->tx_skbuff[entry] = skb;\r\nif ((rp->quirks & rqRhineI) &&\r\n(((unsigned long)skb->data & 3) || skb_shinfo(skb)->nr_frags != 0 || skb->ip_summed == CHECKSUM_PARTIAL)) {\r\nif (skb->len > PKT_BUF_SZ) {\r\ndev_kfree_skb(skb);\r\nrp->tx_skbuff[entry] = NULL;\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb_copy_and_csum_dev(skb, rp->tx_buf[entry]);\r\nif (skb->len < ETH_ZLEN)\r\nmemset(rp->tx_buf[entry] + skb->len, 0,\r\nETH_ZLEN - skb->len);\r\nrp->tx_skbuff_dma[entry] = 0;\r\nrp->tx_ring[entry].addr = cpu_to_le32(rp->tx_bufs_dma +\r\n(rp->tx_buf[entry] -\r\nrp->tx_bufs));\r\n} else {\r\nrp->tx_skbuff_dma[entry] =\r\npci_map_single(rp->pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nrp->tx_ring[entry].addr = cpu_to_le32(rp->tx_skbuff_dma[entry]);\r\n}\r\nrp->tx_ring[entry].desc_length =\r\ncpu_to_le32(TXDESC | (skb->len >= ETH_ZLEN ? skb->len : ETH_ZLEN));\r\nif (unlikely(vlan_tx_tag_present(skb))) {\r\nrp->tx_ring[entry].tx_status = cpu_to_le32((vlan_tx_tag_get(skb)) << 16);\r\nrp->tx_ring[entry].desc_length |= cpu_to_le32(0x020000);\r\n}\r\nelse\r\nrp->tx_ring[entry].tx_status = 0;\r\nwmb();\r\nrp->tx_ring[entry].tx_status |= cpu_to_le32(DescOwn);\r\nwmb();\r\nrp->cur_tx++;\r\nif (vlan_tx_tag_present(skb))\r\nBYTE_REG_BITS_ON(1 << 7, ioaddr + TQWake);\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1TxDemand,\r\nioaddr + ChipCmd1);\r\nIOSYNC;\r\nif (rp->cur_tx == rp->dirty_tx + TX_QUEUE_LEN)\r\nnetif_stop_queue(dev);\r\nnetif_dbg(rp, tx_queued, dev, "Transmit frame #%d queued in slot %d\n",\r\nrp->cur_tx - 1, entry);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void rhine_irq_disable(struct rhine_private *rp)\r\n{\r\niowrite16(0x0000, rp->base + IntrEnable);\r\nmmiowb();\r\n}\r\nstatic irqreturn_t rhine_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = dev_instance;\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nu32 status;\r\nint handled = 0;\r\nstatus = rhine_get_events(rp);\r\nnetif_dbg(rp, intr, dev, "Interrupt, status %08x\n", status);\r\nif (status & RHINE_EVENT) {\r\nhandled = 1;\r\nrhine_irq_disable(rp);\r\nnapi_schedule(&rp->napi);\r\n}\r\nif (status & ~(IntrLinkChange | IntrStatsMax | RHINE_EVENT_NAPI)) {\r\nnetif_err(rp, intr, dev, "Something Wicked happened! %08x\n",\r\nstatus);\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void rhine_tx(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint txstatus = 0, entry = rp->dirty_tx % TX_RING_SIZE;\r\nwhile (rp->dirty_tx != rp->cur_tx) {\r\ntxstatus = le32_to_cpu(rp->tx_ring[entry].tx_status);\r\nnetif_dbg(rp, tx_done, dev, "Tx scavenge %d status %08x\n",\r\nentry, txstatus);\r\nif (txstatus & DescOwn)\r\nbreak;\r\nif (txstatus & 0x8000) {\r\nnetif_dbg(rp, tx_done, dev,\r\n"Transmit error, Tx status %08x\n", txstatus);\r\ndev->stats.tx_errors++;\r\nif (txstatus & 0x0400)\r\ndev->stats.tx_carrier_errors++;\r\nif (txstatus & 0x0200)\r\ndev->stats.tx_window_errors++;\r\nif (txstatus & 0x0100)\r\ndev->stats.tx_aborted_errors++;\r\nif (txstatus & 0x0080)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (((rp->quirks & rqRhineI) && txstatus & 0x0002) ||\r\n(txstatus & 0x0800) || (txstatus & 0x1000)) {\r\ndev->stats.tx_fifo_errors++;\r\nrp->tx_ring[entry].tx_status = cpu_to_le32(DescOwn);\r\nbreak;\r\n}\r\n} else {\r\nif (rp->quirks & rqRhineI)\r\ndev->stats.collisions += (txstatus >> 3) & 0x0F;\r\nelse\r\ndev->stats.collisions += txstatus & 0x0F;\r\nnetif_dbg(rp, tx_done, dev, "collisions: %1.1x:%1.1x\n",\r\n(txstatus >> 3) & 0xF, txstatus & 0xF);\r\ndev->stats.tx_bytes += rp->tx_skbuff[entry]->len;\r\ndev->stats.tx_packets++;\r\n}\r\nif (rp->tx_skbuff_dma[entry]) {\r\npci_unmap_single(rp->pdev,\r\nrp->tx_skbuff_dma[entry],\r\nrp->tx_skbuff[entry]->len,\r\nPCI_DMA_TODEVICE);\r\n}\r\ndev_kfree_skb_irq(rp->tx_skbuff[entry]);\r\nrp->tx_skbuff[entry] = NULL;\r\nentry = (++rp->dirty_tx) % TX_RING_SIZE;\r\n}\r\nif ((rp->cur_tx - rp->dirty_tx) < TX_QUEUE_LEN - 4)\r\nnetif_wake_queue(dev);\r\n}\r\nstatic inline u16 rhine_get_vlan_tci(struct sk_buff *skb, int data_size)\r\n{\r\nu8 *trailer = (u8 *)skb->data + ((data_size + 3) & ~3) + 2;\r\nreturn be16_to_cpup((__be16 *)trailer);\r\n}\r\nstatic int rhine_rx(struct net_device *dev, int limit)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint count;\r\nint entry = rp->cur_rx % RX_RING_SIZE;\r\nnetif_dbg(rp, rx_status, dev, "%s(), entry %d status %08x\n", __func__,\r\nentry, le32_to_cpu(rp->rx_head_desc->rx_status));\r\nfor (count = 0; count < limit; ++count) {\r\nstruct rx_desc *desc = rp->rx_head_desc;\r\nu32 desc_status = le32_to_cpu(desc->rx_status);\r\nu32 desc_length = le32_to_cpu(desc->desc_length);\r\nint data_size = desc_status >> 16;\r\nif (desc_status & DescOwn)\r\nbreak;\r\nnetif_dbg(rp, rx_status, dev, "%s() status %08x\n", __func__,\r\ndesc_status);\r\nif ((desc_status & (RxWholePkt | RxErr)) != RxWholePkt) {\r\nif ((desc_status & RxWholePkt) != RxWholePkt) {\r\nnetdev_warn(dev,\r\n"Oversized Ethernet frame spanned multiple buffers, "\r\n"entry %#x length %d status %08x!\n",\r\nentry, data_size,\r\ndesc_status);\r\nnetdev_warn(dev,\r\n"Oversized Ethernet frame %p vs %p\n",\r\nrp->rx_head_desc,\r\n&rp->rx_ring[entry]);\r\ndev->stats.rx_length_errors++;\r\n} else if (desc_status & RxErr) {\r\nnetif_dbg(rp, rx_err, dev,\r\n"%s() Rx error %08x\n", __func__,\r\ndesc_status);\r\ndev->stats.rx_errors++;\r\nif (desc_status & 0x0030)\r\ndev->stats.rx_length_errors++;\r\nif (desc_status & 0x0048)\r\ndev->stats.rx_fifo_errors++;\r\nif (desc_status & 0x0004)\r\ndev->stats.rx_frame_errors++;\r\nif (desc_status & 0x0002) {\r\nspin_lock(&rp->lock);\r\ndev->stats.rx_crc_errors++;\r\nspin_unlock(&rp->lock);\r\n}\r\n}\r\n} else {\r\nstruct sk_buff *skb = NULL;\r\nint pkt_len = data_size - 4;\r\nu16 vlan_tci = 0;\r\nif (pkt_len < rx_copybreak)\r\nskb = netdev_alloc_skb_ip_align(dev, pkt_len);\r\nif (skb) {\r\npci_dma_sync_single_for_cpu(rp->pdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nskb_copy_to_linear_data(skb,\r\nrp->rx_skbuff[entry]->data,\r\npkt_len);\r\nskb_put(skb, pkt_len);\r\npci_dma_sync_single_for_device(rp->pdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\n} else {\r\nskb = rp->rx_skbuff[entry];\r\nif (skb == NULL) {\r\nnetdev_err(dev, "Inconsistent Rx descriptor chain\n");\r\nbreak;\r\n}\r\nrp->rx_skbuff[entry] = NULL;\r\nskb_put(skb, pkt_len);\r\npci_unmap_single(rp->pdev,\r\nrp->rx_skbuff_dma[entry],\r\nrp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\n}\r\nif (unlikely(desc_length & DescTag))\r\nvlan_tci = rhine_get_vlan_tci(skb, data_size);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nif (unlikely(desc_length & DescTag))\r\n__vlan_hwaccel_put_tag(skb, vlan_tci);\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_bytes += pkt_len;\r\ndev->stats.rx_packets++;\r\n}\r\nentry = (++rp->cur_rx) % RX_RING_SIZE;\r\nrp->rx_head_desc = &rp->rx_ring[entry];\r\n}\r\nfor (; rp->cur_rx - rp->dirty_rx > 0; rp->dirty_rx++) {\r\nstruct sk_buff *skb;\r\nentry = rp->dirty_rx % RX_RING_SIZE;\r\nif (rp->rx_skbuff[entry] == NULL) {\r\nskb = netdev_alloc_skb(dev, rp->rx_buf_sz);\r\nrp->rx_skbuff[entry] = skb;\r\nif (skb == NULL)\r\nbreak;\r\nrp->rx_skbuff_dma[entry] =\r\npci_map_single(rp->pdev, skb->data,\r\nrp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nrp->rx_ring[entry].addr = cpu_to_le32(rp->rx_skbuff_dma[entry]);\r\n}\r\nrp->rx_ring[entry].rx_status = cpu_to_le32(DescOwn);\r\n}\r\nreturn count;\r\n}\r\nstatic void rhine_restart_tx(struct net_device *dev) {\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nint entry = rp->dirty_tx % TX_RING_SIZE;\r\nu32 intr_status;\r\nintr_status = rhine_get_events(rp);\r\nif ((intr_status & IntrTxErrSummary) == 0) {\r\niowrite32(rp->tx_ring_dma + entry * sizeof(struct tx_desc),\r\nioaddr + TxRingPtr);\r\niowrite8(ioread8(ioaddr + ChipCmd) | CmdTxOn,\r\nioaddr + ChipCmd);\r\nif (rp->tx_ring[entry].desc_length & cpu_to_le32(0x020000))\r\nBYTE_REG_BITS_ON(1 << 7, ioaddr + TQWake);\r\niowrite8(ioread8(ioaddr + ChipCmd1) | Cmd1TxDemand,\r\nioaddr + ChipCmd1);\r\nIOSYNC;\r\n}\r\nelse {\r\nnetif_warn(rp, tx_err, dev, "another error occurred %08x\n",\r\nintr_status);\r\n}\r\n}\r\nstatic void rhine_slow_event_task(struct work_struct *work)\r\n{\r\nstruct rhine_private *rp =\r\ncontainer_of(work, struct rhine_private, slow_event_task);\r\nstruct net_device *dev = rp->dev;\r\nu32 intr_status;\r\nmutex_lock(&rp->task_lock);\r\nif (!rp->task_enable)\r\ngoto out_unlock;\r\nintr_status = rhine_get_events(rp);\r\nrhine_ack_events(rp, intr_status & RHINE_EVENT_SLOW);\r\nif (intr_status & IntrLinkChange)\r\nrhine_check_media(dev, 0);\r\nif (intr_status & IntrPCIErr)\r\nnetif_warn(rp, hw, dev, "PCI error\n");\r\nnapi_disable(&rp->napi);\r\nrhine_irq_disable(rp);\r\nnapi_enable(&rp->napi);\r\nnapi_schedule(&rp->napi);\r\nout_unlock:\r\nmutex_unlock(&rp->task_lock);\r\n}\r\nstatic struct net_device_stats *rhine_get_stats(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nspin_lock_bh(&rp->lock);\r\nrhine_update_rx_crc_and_missed_errord(rp);\r\nspin_unlock_bh(&rp->lock);\r\nreturn &dev->stats;\r\n}\r\nstatic void rhine_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nu32 mc_filter[2];\r\nu8 rx_mode = 0x0C;\r\nstruct netdev_hw_addr *ha;\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode = 0x1C;\r\niowrite32(0xffffffff, ioaddr + MulticastFilter0);\r\niowrite32(0xffffffff, ioaddr + MulticastFilter1);\r\n} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\niowrite32(0xffffffff, ioaddr + MulticastFilter0);\r\niowrite32(0xffffffff, ioaddr + MulticastFilter1);\r\n} else if (rp->pdev->revision >= VT6105M) {\r\nint i = 0;\r\nu32 mCAMmask = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (i == MCAM_SIZE)\r\nbreak;\r\nrhine_set_cam(ioaddr, i, ha->addr);\r\nmCAMmask |= 1 << i;\r\ni++;\r\n}\r\nrhine_set_cam_mask(ioaddr, mCAMmask);\r\n} else {\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\n}\r\niowrite32(mc_filter[0], ioaddr + MulticastFilter0);\r\niowrite32(mc_filter[1], ioaddr + MulticastFilter1);\r\n}\r\nif (rp->pdev->revision >= VT6105M) {\r\nif (dev->flags & IFF_PROMISC)\r\nBYTE_REG_BITS_OFF(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\nelse\r\nBYTE_REG_BITS_ON(BCR1_VIDFR, ioaddr + PCIBusConfig1);\r\n}\r\nBYTE_REG_BITS_ON(rx_mode, ioaddr + RxConfig);\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(rp->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nmutex_lock(&rp->task_lock);\r\nrc = mii_ethtool_gset(&rp->mii_if, cmd);\r\nmutex_unlock(&rp->task_lock);\r\nreturn rc;\r\n}\r\nstatic int netdev_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nmutex_lock(&rp->task_lock);\r\nrc = mii_ethtool_sset(&rp->mii_if, cmd);\r\nrhine_set_carrier(&rp->mii_if);\r\nmutex_unlock(&rp->task_lock);\r\nreturn rc;\r\n}\r\nstatic int netdev_nway_reset(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nreturn mii_nway_restart(&rp->mii_if);\r\n}\r\nstatic u32 netdev_get_link(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nreturn mii_link_ok(&rp->mii_if);\r\n}\r\nstatic u32 netdev_get_msglevel(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nreturn rp->msg_enable;\r\n}\r\nstatic void netdev_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nrp->msg_enable = value;\r\n}\r\nstatic void rhine_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (!(rp->quirks & rqWOL))\r\nreturn;\r\nspin_lock_irq(&rp->lock);\r\nwol->supported = WAKE_PHY | WAKE_MAGIC |\r\nWAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\nwol->wolopts = rp->wolopts;\r\nspin_unlock_irq(&rp->lock);\r\n}\r\nstatic int rhine_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nu32 support = WAKE_PHY | WAKE_MAGIC |\r\nWAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\nif (!(rp->quirks & rqWOL))\r\nreturn -EINVAL;\r\nif (wol->wolopts & ~support)\r\nreturn -EINVAL;\r\nspin_lock_irq(&rp->lock);\r\nrp->wolopts = wol->wolopts;\r\nspin_unlock_irq(&rp->lock);\r\nreturn 0;\r\n}\r\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nint rc;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nmutex_lock(&rp->task_lock);\r\nrc = generic_mii_ioctl(&rp->mii_if, if_mii(rq), cmd, NULL);\r\nrhine_set_carrier(&rp->mii_if);\r\nmutex_unlock(&rp->task_lock);\r\nreturn rc;\r\n}\r\nstatic int rhine_close(struct net_device *dev)\r\n{\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nrhine_task_disable(rp);\r\nnapi_disable(&rp->napi);\r\nnetif_stop_queue(dev);\r\nnetif_dbg(rp, ifdown, dev, "Shutting down ethercard, status was %04x\n",\r\nioread16(ioaddr + ChipCmd));\r\niowrite8(rp->tx_thresh | 0x02, ioaddr + TxConfig);\r\nrhine_irq_disable(rp);\r\niowrite16(CmdStop, ioaddr + ChipCmd);\r\nfree_irq(rp->pdev->irq, dev);\r\nfree_rbufs(dev);\r\nfree_tbufs(dev);\r\nfree_ring(dev);\r\nreturn 0;\r\n}\r\nstatic void __devexit rhine_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\npci_iounmap(pdev, rp->base);\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic void rhine_shutdown (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = rp->base;\r\nif (!(rp->quirks & rqWOL))\r\nreturn;\r\nrhine_power_init(dev);\r\nif (rp->quirks & rq6patterns)\r\niowrite8(0x04, ioaddr + WOLcgClr);\r\nspin_lock(&rp->lock);\r\nif (rp->wolopts & WAKE_MAGIC) {\r\niowrite8(WOLmagic, ioaddr + WOLcrSet);\r\niowrite8(ioread8(ioaddr + ConfigA) | 0x03, ioaddr + ConfigA);\r\n}\r\nif (rp->wolopts & (WAKE_BCAST|WAKE_MCAST))\r\niowrite8(WOLbmcast, ioaddr + WOLcgSet);\r\nif (rp->wolopts & WAKE_PHY)\r\niowrite8(WOLlnkon | WOLlnkoff, ioaddr + WOLcrSet);\r\nif (rp->wolopts & WAKE_UCAST)\r\niowrite8(WOLucast, ioaddr + WOLcrSet);\r\nif (rp->wolopts) {\r\niowrite8(0x01, ioaddr + PwcfgSet);\r\niowrite8(ioread8(ioaddr + StickyHW) | 0x04, ioaddr + StickyHW);\r\n}\r\nspin_unlock(&rp->lock);\r\nif (system_state == SYSTEM_POWER_OFF && !avoid_D3) {\r\niowrite8(ioread8(ioaddr + StickyHW) | 0x03, ioaddr + StickyHW);\r\npci_wake_from_d3(pdev, true);\r\npci_set_power_state(pdev, PCI_D3hot);\r\n}\r\n}\r\nstatic int rhine_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nrhine_task_disable(rp);\r\nrhine_irq_disable(rp);\r\nnapi_disable(&rp->napi);\r\nnetif_device_detach(dev);\r\nrhine_shutdown(pdev);\r\nreturn 0;\r\n}\r\nstatic int rhine_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct rhine_private *rp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\n#ifdef USE_MMIO\r\nenable_mmio(rp->pioaddr, rp->quirks);\r\n#endif\r\nrhine_power_init(dev);\r\nfree_tbufs(dev);\r\nfree_rbufs(dev);\r\nalloc_tbufs(dev);\r\nalloc_rbufs(dev);\r\nrhine_task_enable(rp);\r\nspin_lock_bh(&rp->lock);\r\ninit_registers(dev);\r\nspin_unlock_bh(&rp->lock);\r\nnetif_device_attach(dev);\r\nreturn 0;\r\n}\r\nstatic int __init rhine_init(void)\r\n{\r\n#ifdef MODULE\r\npr_info("%s\n", version);\r\n#endif\r\nif (dmi_check_system(rhine_dmi_table)) {\r\navoid_D3 = true;\r\npr_warn("Broken BIOS detected, avoid_D3 enabled\n");\r\n}\r\nelse if (avoid_D3)\r\npr_info("avoid_D3 set\n");\r\nreturn pci_register_driver(&rhine_driver);\r\n}\r\nstatic void __exit rhine_cleanup(void)\r\n{\r\npci_unregister_driver(&rhine_driver);\r\n}
