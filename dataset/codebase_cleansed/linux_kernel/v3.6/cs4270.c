static int cs4270_reg_is_readable(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nreturn (reg >= CS4270_FIRSTREG) && (reg <= CS4270_LASTREG);\r\n}\r\nstatic int cs4270_reg_is_volatile(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nif ((reg < CS4270_FIRSTREG) || (reg > CS4270_LASTREG))\r\nreturn 1;\r\nreturn reg == CS4270_CHIPID;\r\n}\r\nstatic int cs4270_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\ncs4270->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int cs4270_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncs4270->mode = format & SND_SOC_DAIFMT_FORMAT_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "invalid dai format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncs4270->slave_mode = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncs4270->slave_mode = 0;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs4270_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nunsigned int i;\r\nunsigned int rate;\r\nunsigned int ratio;\r\nint reg;\r\nrate = params_rate(params);\r\nratio = cs4270->mclk / rate;\r\nfor (i = 0; i < NUM_MCLK_RATIOS; i++) {\r\nif (cs4270_mode_ratios[i].ratio == ratio)\r\nbreak;\r\n}\r\nif (i == NUM_MCLK_RATIOS) {\r\ndev_err(codec->dev, "could not find matching ratio\n");\r\nreturn -EINVAL;\r\n}\r\nreg = snd_soc_read(codec, CS4270_MODE);\r\nreg &= ~(CS4270_MODE_SPEED_MASK | CS4270_MODE_DIV_MASK);\r\nreg |= cs4270_mode_ratios[i].mclk;\r\nif (cs4270->slave_mode)\r\nreg |= CS4270_MODE_SLAVE;\r\nelse\r\nreg |= cs4270_mode_ratios[i].speed_mode;\r\nret = snd_soc_write(codec, CS4270_MODE, reg);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nreg = snd_soc_read(codec, CS4270_FORMAT);\r\nreg &= ~(CS4270_FORMAT_DAC_MASK | CS4270_FORMAT_ADC_MASK);\r\nswitch (cs4270->mode) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nreg |= CS4270_FORMAT_DAC_I2S | CS4270_FORMAT_ADC_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nreg |= CS4270_FORMAT_DAC_LJ | CS4270_FORMAT_ADC_LJ;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unknown dai format\n");\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_write(codec, CS4270_FORMAT, reg);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cs4270_dai_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint reg6;\r\nreg6 = snd_soc_read(codec, CS4270_MUTE);\r\nif (mute)\r\nreg6 |= CS4270_MUTE_DAC_A | CS4270_MUTE_DAC_B;\r\nelse {\r\nreg6 &= ~(CS4270_MUTE_DAC_A | CS4270_MUTE_DAC_B);\r\nreg6 |= cs4270->manual_mute;\r\n}\r\nreturn snd_soc_write(codec, CS4270_MUTE, reg6);\r\n}\r\nstatic int cs4270_soc_put_mute(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint left = !ucontrol->value.integer.value[0];\r\nint right = !ucontrol->value.integer.value[1];\r\ncs4270->manual_mute = (left ? CS4270_MUTE_DAC_A : 0) |\r\n(right ? CS4270_MUTE_DAC_B : 0);\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\n}\r\nstatic int cs4270_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint i, ret;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, cs4270->control_type);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to set cache I/O (ret=%i)\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_update_bits(codec, CS4270_MUTE, CS4270_MUTE_AUTO, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_update_bits(codec, CS4270_TRANS,\r\nCS4270_TRANS_SOFT | CS4270_TRANS_ZERO, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "i2c write failed\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_add_codec_controls(codec, cs4270_snd_controls,\r\nARRAY_SIZE(cs4270_snd_controls));\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to add controls\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\r\ncs4270->supplies[i].supply = supply_names[i];\r\nret = regulator_bulk_get(codec->dev, ARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nif (ret < 0)\r\ngoto error_free_regulators;\r\nreturn 0;\r\nerror_free_regulators:\r\nregulator_bulk_free(ARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nreturn ret;\r\n}\r\nstatic int cs4270_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nregulator_bulk_disable(ARRAY_SIZE(cs4270->supplies), cs4270->supplies);\r\nregulator_bulk_free(ARRAY_SIZE(cs4270->supplies), cs4270->supplies);\r\nreturn 0;\r\n}\r\nstatic int cs4270_soc_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint reg, ret;\r\nreg = snd_soc_read(codec, CS4270_PWRCTL) | CS4270_PWRCTL_PDN_ALL;\r\nif (reg < 0)\r\nreturn reg;\r\nret = snd_soc_write(codec, CS4270_PWRCTL, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nregulator_bulk_disable(ARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nreturn 0;\r\n}\r\nstatic int cs4270_soc_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct cs4270_private *cs4270 = snd_soc_codec_get_drvdata(codec);\r\nint reg, ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs4270->supplies),\r\ncs4270->supplies);\r\nif (ret != 0)\r\nreturn ret;\r\nndelay(500);\r\nsnd_soc_cache_sync(codec);\r\nreg = snd_soc_read(codec, CS4270_PWRCTL);\r\nreg &= ~CS4270_PWRCTL_PDN_ALL;\r\nreturn snd_soc_write(codec, CS4270_PWRCTL, reg);\r\n}\r\nstatic int cs4270_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs4270_private *cs4270;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(i2c_client, CS4270_CHIPID);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "failed to read i2c at addr %X\n",\r\ni2c_client->addr);\r\nreturn ret;\r\n}\r\nif ((ret & 0xF0) != 0xC0) {\r\ndev_err(&i2c_client->dev, "device at addr %X is not a CS4270\n",\r\ni2c_client->addr);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&i2c_client->dev, "found device at i2c address %X\n",\r\ni2c_client->addr);\r\ndev_info(&i2c_client->dev, "hardware revision %X\n", ret & 0xF);\r\ncs4270 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs4270_private),\r\nGFP_KERNEL);\r\nif (!cs4270) {\r\ndev_err(&i2c_client->dev, "could not allocate codec\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(i2c_client, cs4270);\r\ncs4270->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_device_cs4270, &cs4270_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int cs4270_i2c_remove(struct i2c_client *i2c_client)\r\n{\r\nsnd_soc_unregister_codec(&i2c_client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init cs4270_init(void)\r\n{\r\nreturn i2c_add_driver(&cs4270_i2c_driver);\r\n}\r\nstatic void __exit cs4270_exit(void)\r\n{\r\ni2c_del_driver(&cs4270_i2c_driver);\r\n}
