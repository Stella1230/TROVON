static inline void mbcs_getdma_init(struct getdma *gdma)\r\n{\r\nmemset(gdma, 0, sizeof(struct getdma));\r\ngdma->DoneIntEnable = 1;\r\n}\r\nstatic inline void mbcs_putdma_init(struct putdma *pdma)\r\n{\r\nmemset(pdma, 0, sizeof(struct putdma));\r\npdma->DoneIntEnable = 1;\r\n}\r\nstatic inline void mbcs_algo_init(struct algoblock *algo_soft)\r\n{\r\nmemset(algo_soft, 0, sizeof(struct algoblock));\r\n}\r\nstatic inline void mbcs_getdma_set(void *mmr,\r\nuint64_t hostAddr,\r\nuint64_t localAddr,\r\nuint64_t localRamSel,\r\nuint64_t numPkts,\r\nuint64_t amoEnable,\r\nuint64_t intrEnable,\r\nuint64_t peerIO,\r\nuint64_t amoHostDest,\r\nuint64_t amoModType, uint64_t intrHostDest,\r\nuint64_t intrVector)\r\n{\r\nunion dma_control rdma_control;\r\nunion dma_amo_dest amo_dest;\r\nunion intr_dest intr_dest;\r\nunion dma_localaddr local_addr;\r\nunion dma_hostaddr host_addr;\r\nrdma_control.dma_control_reg = 0;\r\namo_dest.dma_amo_dest_reg = 0;\r\nintr_dest.intr_dest_reg = 0;\r\nlocal_addr.dma_localaddr_reg = 0;\r\nhost_addr.dma_hostaddr_reg = 0;\r\nhost_addr.dma_sys_addr = hostAddr;\r\nMBCS_MMR_SET(mmr, MBCS_RD_DMA_SYS_ADDR, host_addr.dma_hostaddr_reg);\r\nlocal_addr.dma_ram_addr = localAddr;\r\nlocal_addr.dma_ram_sel = localRamSel;\r\nMBCS_MMR_SET(mmr, MBCS_RD_DMA_LOC_ADDR, local_addr.dma_localaddr_reg);\r\nrdma_control.dma_op_length = numPkts;\r\nrdma_control.done_amo_en = amoEnable;\r\nrdma_control.done_int_en = intrEnable;\r\nrdma_control.pio_mem_n = peerIO;\r\nMBCS_MMR_SET(mmr, MBCS_RD_DMA_CTRL, rdma_control.dma_control_reg);\r\namo_dest.dma_amo_sys_addr = amoHostDest;\r\namo_dest.dma_amo_mod_type = amoModType;\r\nMBCS_MMR_SET(mmr, MBCS_RD_DMA_AMO_DEST, amo_dest.dma_amo_dest_reg);\r\nintr_dest.address = intrHostDest;\r\nintr_dest.int_vector = intrVector;\r\nMBCS_MMR_SET(mmr, MBCS_RD_DMA_INT_DEST, intr_dest.intr_dest_reg);\r\n}\r\nstatic inline void mbcs_putdma_set(void *mmr,\r\nuint64_t hostAddr,\r\nuint64_t localAddr,\r\nuint64_t localRamSel,\r\nuint64_t numPkts,\r\nuint64_t amoEnable,\r\nuint64_t intrEnable,\r\nuint64_t peerIO,\r\nuint64_t amoHostDest,\r\nuint64_t amoModType,\r\nuint64_t intrHostDest, uint64_t intrVector)\r\n{\r\nunion dma_control wdma_control;\r\nunion dma_amo_dest amo_dest;\r\nunion intr_dest intr_dest;\r\nunion dma_localaddr local_addr;\r\nunion dma_hostaddr host_addr;\r\nwdma_control.dma_control_reg = 0;\r\namo_dest.dma_amo_dest_reg = 0;\r\nintr_dest.intr_dest_reg = 0;\r\nlocal_addr.dma_localaddr_reg = 0;\r\nhost_addr.dma_hostaddr_reg = 0;\r\nhost_addr.dma_sys_addr = hostAddr;\r\nMBCS_MMR_SET(mmr, MBCS_WR_DMA_SYS_ADDR, host_addr.dma_hostaddr_reg);\r\nlocal_addr.dma_ram_addr = localAddr;\r\nlocal_addr.dma_ram_sel = localRamSel;\r\nMBCS_MMR_SET(mmr, MBCS_WR_DMA_LOC_ADDR, local_addr.dma_localaddr_reg);\r\nwdma_control.dma_op_length = numPkts;\r\nwdma_control.done_amo_en = amoEnable;\r\nwdma_control.done_int_en = intrEnable;\r\nwdma_control.pio_mem_n = peerIO;\r\nMBCS_MMR_SET(mmr, MBCS_WR_DMA_CTRL, wdma_control.dma_control_reg);\r\namo_dest.dma_amo_sys_addr = amoHostDest;\r\namo_dest.dma_amo_mod_type = amoModType;\r\nMBCS_MMR_SET(mmr, MBCS_WR_DMA_AMO_DEST, amo_dest.dma_amo_dest_reg);\r\nintr_dest.address = intrHostDest;\r\nintr_dest.int_vector = intrVector;\r\nMBCS_MMR_SET(mmr, MBCS_WR_DMA_INT_DEST, intr_dest.intr_dest_reg);\r\n}\r\nstatic inline void mbcs_algo_set(void *mmr,\r\nuint64_t amoHostDest,\r\nuint64_t amoModType,\r\nuint64_t intrHostDest,\r\nuint64_t intrVector, uint64_t algoStepCount)\r\n{\r\nunion dma_amo_dest amo_dest;\r\nunion intr_dest intr_dest;\r\nunion algo_step step;\r\nstep.algo_step_reg = 0;\r\nintr_dest.intr_dest_reg = 0;\r\namo_dest.dma_amo_dest_reg = 0;\r\namo_dest.dma_amo_sys_addr = amoHostDest;\r\namo_dest.dma_amo_mod_type = amoModType;\r\nMBCS_MMR_SET(mmr, MBCS_ALG_AMO_DEST, amo_dest.dma_amo_dest_reg);\r\nintr_dest.address = intrHostDest;\r\nintr_dest.int_vector = intrVector;\r\nMBCS_MMR_SET(mmr, MBCS_ALG_INT_DEST, intr_dest.intr_dest_reg);\r\nstep.alg_step_cnt = algoStepCount;\r\nMBCS_MMR_SET(mmr, MBCS_ALG_STEP, step.algo_step_reg);\r\n}\r\nstatic inline int mbcs_getdma_start(struct mbcs_soft *soft)\r\n{\r\nvoid *mmr_base;\r\nstruct getdma *gdma;\r\nuint64_t numPkts;\r\nunion cm_control cm_control;\r\nmmr_base = soft->mmr_base;\r\ngdma = &soft->getdma;\r\nif (!gdma->hostAddr)\r\nreturn -1;\r\nnumPkts =\r\n(gdma->bytes + (MBCS_CACHELINE_SIZE - 1)) / MBCS_CACHELINE_SIZE;\r\nmbcs_getdma_set(mmr_base, tiocx_dma_addr(gdma->hostAddr),\r\ngdma->localAddr,\r\n(gdma->localAddr < MB2) ? 0 :\r\n(gdma->localAddr < MB4) ? 1 :\r\n(gdma->localAddr < MB6) ? 2 : 3,\r\nnumPkts,\r\ngdma->DoneAmoEnable,\r\ngdma->DoneIntEnable,\r\ngdma->peerIO,\r\ngdma->amoHostDest,\r\ngdma->amoModType,\r\ngdma->intrHostDest, gdma->intrVector);\r\ncm_control.cm_control_reg = MBCS_MMR_GET(mmr_base, MBCS_CM_CONTROL);\r\ncm_control.rd_dma_go = 1;\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_CONTROL, cm_control.cm_control_reg);\r\nreturn 0;\r\n}\r\nstatic inline int mbcs_putdma_start(struct mbcs_soft *soft)\r\n{\r\nvoid *mmr_base;\r\nstruct putdma *pdma;\r\nuint64_t numPkts;\r\nunion cm_control cm_control;\r\nmmr_base = soft->mmr_base;\r\npdma = &soft->putdma;\r\nif (!pdma->hostAddr)\r\nreturn -1;\r\nnumPkts =\r\n(pdma->bytes + (MBCS_CACHELINE_SIZE - 1)) / MBCS_CACHELINE_SIZE;\r\nmbcs_putdma_set(mmr_base, tiocx_dma_addr(pdma->hostAddr),\r\npdma->localAddr,\r\n(pdma->localAddr < MB2) ? 0 :\r\n(pdma->localAddr < MB4) ? 1 :\r\n(pdma->localAddr < MB6) ? 2 : 3,\r\nnumPkts,\r\npdma->DoneAmoEnable,\r\npdma->DoneIntEnable,\r\npdma->peerIO,\r\npdma->amoHostDest,\r\npdma->amoModType,\r\npdma->intrHostDest, pdma->intrVector);\r\ncm_control.cm_control_reg = MBCS_MMR_GET(mmr_base, MBCS_CM_CONTROL);\r\ncm_control.wr_dma_go = 1;\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_CONTROL, cm_control.cm_control_reg);\r\nreturn 0;\r\n}\r\nstatic inline int mbcs_algo_start(struct mbcs_soft *soft)\r\n{\r\nstruct algoblock *algo_soft = &soft->algo;\r\nvoid *mmr_base = soft->mmr_base;\r\nunion cm_control cm_control;\r\nif (mutex_lock_interruptible(&soft->algolock))\r\nreturn -ERESTARTSYS;\r\natomic_set(&soft->algo_done, 0);\r\nmbcs_algo_set(mmr_base,\r\nalgo_soft->amoHostDest,\r\nalgo_soft->amoModType,\r\nalgo_soft->intrHostDest,\r\nalgo_soft->intrVector, algo_soft->algoStepCount);\r\ncm_control.cm_control_reg = MBCS_MMR_GET(mmr_base, MBCS_CM_CONTROL);\r\ncm_control.alg_done_int_en = 1;\r\ncm_control.alg_go = 1;\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_CONTROL, cm_control.cm_control_reg);\r\nmutex_unlock(&soft->algolock);\r\nreturn 0;\r\n}\r\nstatic inline ssize_t\r\ndo_mbcs_sram_dmawrite(struct mbcs_soft *soft, uint64_t hostAddr,\r\nsize_t len, loff_t * off)\r\n{\r\nint rv = 0;\r\nif (mutex_lock_interruptible(&soft->dmawritelock))\r\nreturn -ERESTARTSYS;\r\natomic_set(&soft->dmawrite_done, 0);\r\nsoft->putdma.hostAddr = hostAddr;\r\nsoft->putdma.localAddr = *off;\r\nsoft->putdma.bytes = len;\r\nif (mbcs_putdma_start(soft) < 0) {\r\nDBG(KERN_ALERT "do_mbcs_sram_dmawrite: "\r\n"mbcs_putdma_start failed\n");\r\nrv = -EAGAIN;\r\ngoto dmawrite_exit;\r\n}\r\nif (wait_event_interruptible(soft->dmawrite_queue,\r\natomic_read(&soft->dmawrite_done))) {\r\nrv = -ERESTARTSYS;\r\ngoto dmawrite_exit;\r\n}\r\nrv = len;\r\n*off += len;\r\ndmawrite_exit:\r\nmutex_unlock(&soft->dmawritelock);\r\nreturn rv;\r\n}\r\nstatic inline ssize_t\r\ndo_mbcs_sram_dmaread(struct mbcs_soft *soft, uint64_t hostAddr,\r\nsize_t len, loff_t * off)\r\n{\r\nint rv = 0;\r\nif (mutex_lock_interruptible(&soft->dmareadlock))\r\nreturn -ERESTARTSYS;\r\natomic_set(&soft->dmawrite_done, 0);\r\nsoft->getdma.hostAddr = hostAddr;\r\nsoft->getdma.localAddr = *off;\r\nsoft->getdma.bytes = len;\r\nif (mbcs_getdma_start(soft) < 0) {\r\nDBG(KERN_ALERT "mbcs_strategy: mbcs_getdma_start failed\n");\r\nrv = -EAGAIN;\r\ngoto dmaread_exit;\r\n}\r\nif (wait_event_interruptible(soft->dmaread_queue,\r\natomic_read(&soft->dmaread_done))) {\r\nrv = -ERESTARTSYS;\r\ngoto dmaread_exit;\r\n}\r\nrv = len;\r\n*off += len;\r\ndmaread_exit:\r\nmutex_unlock(&soft->dmareadlock);\r\nreturn rv;\r\n}\r\nstatic int mbcs_open(struct inode *ip, struct file *fp)\r\n{\r\nstruct mbcs_soft *soft;\r\nint minor;\r\nmutex_lock(&mbcs_mutex);\r\nminor = iminor(ip);\r\nlist_for_each_entry(soft, &soft_list, list) {\r\nif (soft->nasid == minor) {\r\nfp->private_data = soft->cxdev;\r\nmutex_unlock(&mbcs_mutex);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&mbcs_mutex);\r\nreturn -ENODEV;\r\n}\r\nstatic ssize_t mbcs_sram_read(struct file * fp, char __user *buf, size_t len, loff_t * off)\r\n{\r\nstruct cx_dev *cx_dev = fp->private_data;\r\nstruct mbcs_soft *soft = cx_dev->soft;\r\nuint64_t hostAddr;\r\nint rv = 0;\r\nhostAddr = __get_dma_pages(GFP_KERNEL, get_order(len));\r\nif (hostAddr == 0)\r\nreturn -ENOMEM;\r\nrv = do_mbcs_sram_dmawrite(soft, hostAddr, len, off);\r\nif (rv < 0)\r\ngoto exit;\r\nif (copy_to_user(buf, (void *)hostAddr, len))\r\nrv = -EFAULT;\r\nexit:\r\nfree_pages(hostAddr, get_order(len));\r\nreturn rv;\r\n}\r\nstatic ssize_t\r\nmbcs_sram_write(struct file * fp, const char __user *buf, size_t len, loff_t * off)\r\n{\r\nstruct cx_dev *cx_dev = fp->private_data;\r\nstruct mbcs_soft *soft = cx_dev->soft;\r\nuint64_t hostAddr;\r\nint rv = 0;\r\nhostAddr = __get_dma_pages(GFP_KERNEL, get_order(len));\r\nif (hostAddr == 0)\r\nreturn -ENOMEM;\r\nif (copy_from_user((void *)hostAddr, buf, len)) {\r\nrv = -EFAULT;\r\ngoto exit;\r\n}\r\nrv = do_mbcs_sram_dmaread(soft, hostAddr, len, off);\r\nexit:\r\nfree_pages(hostAddr, get_order(len));\r\nreturn rv;\r\n}\r\nstatic loff_t mbcs_sram_llseek(struct file * filp, loff_t off, int whence)\r\n{\r\nloff_t newpos;\r\nswitch (whence) {\r\ncase SEEK_SET:\r\nnewpos = off;\r\nbreak;\r\ncase SEEK_CUR:\r\nnewpos = filp->f_pos + off;\r\nbreak;\r\ncase SEEK_END:\r\nnewpos = MBCS_SRAM_SIZE + off;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (newpos < 0)\r\nreturn -EINVAL;\r\nfilp->f_pos = newpos;\r\nreturn newpos;\r\n}\r\nstatic uint64_t mbcs_pioaddr(struct mbcs_soft *soft, uint64_t offset)\r\n{\r\nuint64_t mmr_base;\r\nmmr_base = (uint64_t) (soft->mmr_base + offset);\r\nreturn mmr_base;\r\n}\r\nstatic void mbcs_debug_pioaddr_set(struct mbcs_soft *soft)\r\n{\r\nsoft->debug_addr = mbcs_pioaddr(soft, MBCS_DEBUG_START);\r\n}\r\nstatic void mbcs_gscr_pioaddr_set(struct mbcs_soft *soft)\r\n{\r\nsoft->gscr_addr = mbcs_pioaddr(soft, MBCS_GSCR_START);\r\n}\r\nstatic int mbcs_gscr_mmap(struct file *fp, struct vm_area_struct *vma)\r\n{\r\nstruct cx_dev *cx_dev = fp->private_data;\r\nstruct mbcs_soft *soft = cx_dev->soft;\r\nif (vma->vm_pgoff != 0)\r\nreturn -EINVAL;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nif (remap_pfn_range(vma,\r\nvma->vm_start,\r\n__pa(soft->gscr_addr) >> PAGE_SHIFT,\r\nPAGE_SIZE,\r\nvma->vm_page_prot))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nmbcs_completion_intr_handler(int irq, void *arg)\r\n{\r\nstruct mbcs_soft *soft = (struct mbcs_soft *)arg;\r\nvoid *mmr_base;\r\nunion cm_status cm_status;\r\nunion cm_control cm_control;\r\nmmr_base = soft->mmr_base;\r\ncm_status.cm_status_reg = MBCS_MMR_GET(mmr_base, MBCS_CM_STATUS);\r\nif (cm_status.rd_dma_done) {\r\ncm_control.cm_control_reg =\r\nMBCS_MMR_GET(mmr_base, MBCS_CM_CONTROL);\r\ncm_control.rd_dma_clr = 1;\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_CONTROL,\r\ncm_control.cm_control_reg);\r\natomic_set(&soft->dmaread_done, 1);\r\nwake_up(&soft->dmaread_queue);\r\n}\r\nif (cm_status.wr_dma_done) {\r\ncm_control.cm_control_reg =\r\nMBCS_MMR_GET(mmr_base, MBCS_CM_CONTROL);\r\ncm_control.wr_dma_clr = 1;\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_CONTROL,\r\ncm_control.cm_control_reg);\r\natomic_set(&soft->dmawrite_done, 1);\r\nwake_up(&soft->dmawrite_queue);\r\n}\r\nif (cm_status.alg_done) {\r\ncm_control.cm_control_reg =\r\nMBCS_MMR_GET(mmr_base, MBCS_CM_CONTROL);\r\ncm_control.alg_done_clr = 1;\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_CONTROL,\r\ncm_control.cm_control_reg);\r\natomic_set(&soft->algo_done, 1);\r\nwake_up(&soft->algo_queue);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mbcs_intr_alloc(struct cx_dev *dev)\r\n{\r\nstruct sn_irq_info *sn_irq;\r\nstruct mbcs_soft *soft;\r\nstruct getdma *getdma;\r\nstruct putdma *putdma;\r\nstruct algoblock *algo;\r\nsoft = dev->soft;\r\ngetdma = &soft->getdma;\r\nputdma = &soft->putdma;\r\nalgo = &soft->algo;\r\nsoft->get_sn_irq = NULL;\r\nsoft->put_sn_irq = NULL;\r\nsoft->algo_sn_irq = NULL;\r\nsn_irq = tiocx_irq_alloc(dev->cx_id.nasid, TIOCX_CORELET, -1, -1, -1);\r\nif (sn_irq == NULL)\r\nreturn -EAGAIN;\r\nsoft->get_sn_irq = sn_irq;\r\ngetdma->intrHostDest = sn_irq->irq_xtalkaddr;\r\ngetdma->intrVector = sn_irq->irq_irq;\r\nif (request_irq(sn_irq->irq_irq,\r\n(void *)mbcs_completion_intr_handler, IRQF_SHARED,\r\n"MBCS get intr", (void *)soft)) {\r\ntiocx_irq_free(soft->get_sn_irq);\r\nreturn -EAGAIN;\r\n}\r\nsn_irq = tiocx_irq_alloc(dev->cx_id.nasid, TIOCX_CORELET, -1, -1, -1);\r\nif (sn_irq == NULL) {\r\nfree_irq(soft->get_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->get_sn_irq);\r\nreturn -EAGAIN;\r\n}\r\nsoft->put_sn_irq = sn_irq;\r\nputdma->intrHostDest = sn_irq->irq_xtalkaddr;\r\nputdma->intrVector = sn_irq->irq_irq;\r\nif (request_irq(sn_irq->irq_irq,\r\n(void *)mbcs_completion_intr_handler, IRQF_SHARED,\r\n"MBCS put intr", (void *)soft)) {\r\ntiocx_irq_free(soft->put_sn_irq);\r\nfree_irq(soft->get_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->get_sn_irq);\r\nreturn -EAGAIN;\r\n}\r\nsn_irq = tiocx_irq_alloc(dev->cx_id.nasid, TIOCX_CORELET, -1, -1, -1);\r\nif (sn_irq == NULL) {\r\nfree_irq(soft->put_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->put_sn_irq);\r\nfree_irq(soft->get_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->get_sn_irq);\r\nreturn -EAGAIN;\r\n}\r\nsoft->algo_sn_irq = sn_irq;\r\nalgo->intrHostDest = sn_irq->irq_xtalkaddr;\r\nalgo->intrVector = sn_irq->irq_irq;\r\nif (request_irq(sn_irq->irq_irq,\r\n(void *)mbcs_completion_intr_handler, IRQF_SHARED,\r\n"MBCS algo intr", (void *)soft)) {\r\ntiocx_irq_free(soft->algo_sn_irq);\r\nfree_irq(soft->put_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->put_sn_irq);\r\nfree_irq(soft->get_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->get_sn_irq);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mbcs_intr_dealloc(struct cx_dev *dev)\r\n{\r\nstruct mbcs_soft *soft;\r\nsoft = dev->soft;\r\nfree_irq(soft->get_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->get_sn_irq);\r\nfree_irq(soft->put_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->put_sn_irq);\r\nfree_irq(soft->algo_sn_irq->irq_irq, soft);\r\ntiocx_irq_free(soft->algo_sn_irq);\r\n}\r\nstatic inline int mbcs_hw_init(struct mbcs_soft *soft)\r\n{\r\nvoid *mmr_base = soft->mmr_base;\r\nunion cm_control cm_control;\r\nunion cm_req_timeout cm_req_timeout;\r\nuint64_t err_stat;\r\ncm_req_timeout.cm_req_timeout_reg =\r\nMBCS_MMR_GET(mmr_base, MBCS_CM_REQ_TOUT);\r\ncm_req_timeout.time_out = MBCS_CM_CONTROL_REQ_TOUT_MASK;\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_REQ_TOUT,\r\ncm_req_timeout.cm_req_timeout_reg);\r\nmbcs_gscr_pioaddr_set(soft);\r\nmbcs_debug_pioaddr_set(soft);\r\nerr_stat = MBCS_MMR_GET(mmr_base, MBCS_CM_ERR_STAT);\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_CLR_ERR_STAT, err_stat);\r\nMBCS_MMR_ZERO(mmr_base, MBCS_CM_ERROR_DETAIL1);\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_ERR_INT_EN, 0x3ffffff7e00ffUL);\r\ncm_control.cm_control_reg = MBCS_MMR_GET(mmr_base, MBCS_CM_CONTROL);\r\ncm_control.rearm_stat_regs = 1;\r\ncm_control.alg_clr = 1;\r\ncm_control.wr_dma_clr = 1;\r\ncm_control.rd_dma_clr = 1;\r\nMBCS_MMR_SET(mmr_base, MBCS_CM_CONTROL, cm_control.cm_control_reg);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_algo(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct cx_dev *cx_dev = to_cx_dev(dev);\r\nstruct mbcs_soft *soft = cx_dev->soft;\r\nuint64_t debug0;\r\ndebug0 = *(uint64_t *) soft->debug_addr;\r\nreturn sprintf(buf, "0x%x 0x%x\n",\r\nupper_32_bits(debug0), lower_32_bits(debug0));\r\n}\r\nstatic ssize_t store_algo(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint n;\r\nstruct cx_dev *cx_dev = to_cx_dev(dev);\r\nstruct mbcs_soft *soft = cx_dev->soft;\r\nif (count <= 0)\r\nreturn 0;\r\nn = simple_strtoul(buf, NULL, 0);\r\nif (n == 1) {\r\nmbcs_algo_start(soft);\r\nif (wait_event_interruptible(soft->algo_queue,\r\natomic_read(&soft->algo_done)))\r\nreturn -ERESTARTSYS;\r\n}\r\nreturn count;\r\n}\r\nstatic int mbcs_probe(struct cx_dev *dev, const struct cx_device_id *id)\r\n{\r\nstruct mbcs_soft *soft;\r\ndev->soft = NULL;\r\nsoft = kzalloc(sizeof(struct mbcs_soft), GFP_KERNEL);\r\nif (soft == NULL)\r\nreturn -ENOMEM;\r\nsoft->nasid = dev->cx_id.nasid;\r\nlist_add(&soft->list, &soft_list);\r\nsoft->mmr_base = (void *)tiocx_swin_base(dev->cx_id.nasid);\r\ndev->soft = soft;\r\nsoft->cxdev = dev;\r\ninit_waitqueue_head(&soft->dmawrite_queue);\r\ninit_waitqueue_head(&soft->dmaread_queue);\r\ninit_waitqueue_head(&soft->algo_queue);\r\nmutex_init(&soft->dmawritelock);\r\nmutex_init(&soft->dmareadlock);\r\nmutex_init(&soft->algolock);\r\nmbcs_getdma_init(&soft->getdma);\r\nmbcs_putdma_init(&soft->putdma);\r\nmbcs_algo_init(&soft->algo);\r\nmbcs_hw_init(soft);\r\nmbcs_intr_alloc(dev);\r\ndevice_create_file(&dev->dev, &dev_attr_algo);\r\nreturn 0;\r\n}\r\nstatic int mbcs_remove(struct cx_dev *dev)\r\n{\r\nif (dev->soft) {\r\nmbcs_intr_dealloc(dev);\r\nkfree(dev->soft);\r\n}\r\ndevice_remove_file(&dev->dev, &dev_attr_algo);\r\nreturn 0;\r\n}\r\nstatic void __exit mbcs_exit(void)\r\n{\r\nunregister_chrdev(mbcs_major, DEVICE_NAME);\r\ncx_driver_unregister(&mbcs_driver);\r\n}\r\nstatic int __init mbcs_init(void)\r\n{\r\nint rv;\r\nif (!ia64_platform_is("sn2"))\r\nreturn -ENODEV;\r\nrv = register_chrdev(mbcs_major, DEVICE_NAME, &mbcs_ops);\r\nif (rv < 0) {\r\nDBG(KERN_ALERT "mbcs_init: can't get major number. %d\n", rv);\r\nreturn rv;\r\n}\r\nmbcs_major = rv;\r\nreturn cx_driver_register(&mbcs_driver);\r\n}
