static int fc0013_writereg(struct fc0013_priv *priv, u8 reg, u8 val)\r\n{\r\nu8 buf[2] = {reg, val};\r\nstruct i2c_msg msg = {\r\n.addr = priv->addr, .flags = 0, .buf = buf, .len = 2\r\n};\r\nif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\r\nerr("I2C write reg failed, reg: %02x, val: %02x", reg, val);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fc0013_readreg(struct fc0013_priv *priv, u8 reg, u8 *val)\r\n{\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = priv->addr, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = priv->addr, .flags = I2C_M_RD, .buf = val, .len = 1 },\r\n};\r\nif (i2c_transfer(priv->i2c, msg, 2) != 2) {\r\nerr("I2C read reg failed, reg: %02x", reg);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fc0013_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int fc0013_init(struct dvb_frontend *fe)\r\n{\r\nstruct fc0013_priv *priv = fe->tuner_priv;\r\nint i, ret = 0;\r\nunsigned char reg[] = {\r\n0x00,\r\n0x09,\r\n0x16,\r\n0x00,\r\n0x00,\r\n0x17,\r\n0x02,\r\n0x0a,\r\n0xff,\r\n0x6f,\r\n0xb8,\r\n0x82,\r\n0xfc,\r\n0x01,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x50,\r\n0x01,\r\n};\r\nswitch (priv->xtal_freq) {\r\ncase FC_XTAL_27_MHZ:\r\ncase FC_XTAL_28_8_MHZ:\r\nreg[0x07] |= 0x20;\r\nbreak;\r\ncase FC_XTAL_36_MHZ:\r\ndefault:\r\nbreak;\r\n}\r\nif (priv->dual_master)\r\nreg[0x0c] |= 0x02;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfor (i = 1; i < sizeof(reg); i++) {\r\nret = fc0013_writereg(priv, i, reg[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret)\r\nerr("fc0013_writereg failed: %d", ret);\r\nreturn ret;\r\n}\r\nstatic int fc0013_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nint fc0013_rc_cal_add(struct dvb_frontend *fe, int rc_val)\r\n{\r\nstruct fc0013_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu8 rc_cal;\r\nint val;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = fc0013_writereg(priv, 0x10, 0x00);\r\nif (ret)\r\ngoto error_out;\r\nret = fc0013_readreg(priv, 0x10, &rc_cal);\r\nif (ret)\r\ngoto error_out;\r\nrc_cal &= 0x0f;\r\nval = (int)rc_cal + rc_val;\r\nret = fc0013_writereg(priv, 0x0d, 0x11);\r\nif (ret)\r\ngoto error_out;\r\nif (val > 15)\r\nret = fc0013_writereg(priv, 0x10, 0x0f);\r\nelse if (val < 0)\r\nret = fc0013_writereg(priv, 0x10, 0x00);\r\nelse\r\nret = fc0013_writereg(priv, 0x10, (u8)val);\r\nerror_out:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nint fc0013_rc_cal_reset(struct dvb_frontend *fe)\r\n{\r\nstruct fc0013_priv *priv = fe->tuner_priv;\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = fc0013_writereg(priv, 0x0d, 0x01);\r\nif (!ret)\r\nret = fc0013_writereg(priv, 0x10, 0x00);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int fc0013_set_vhf_track(struct fc0013_priv *priv, u32 freq)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = fc0013_readreg(priv, 0x1d, &tmp);\r\nif (ret)\r\ngoto error_out;\r\ntmp &= 0xe3;\r\nif (freq <= 177500) {\r\nret = fc0013_writereg(priv, 0x1d, tmp | 0x1c);\r\n} else if (freq <= 184500) {\r\nret = fc0013_writereg(priv, 0x1d, tmp | 0x18);\r\n} else if (freq <= 191500) {\r\nret = fc0013_writereg(priv, 0x1d, tmp | 0x14);\r\n} else if (freq <= 198500) {\r\nret = fc0013_writereg(priv, 0x1d, tmp | 0x10);\r\n} else if (freq <= 205500) {\r\nret = fc0013_writereg(priv, 0x1d, tmp | 0x0c);\r\n} else if (freq <= 219500) {\r\nret = fc0013_writereg(priv, 0x1d, tmp | 0x08);\r\n} else if (freq < 300000) {\r\nret = fc0013_writereg(priv, 0x1d, tmp | 0x04);\r\n} else {\r\nret = fc0013_writereg(priv, 0x1d, tmp | 0x1c);\r\n}\r\nif (ret)\r\ngoto error_out;\r\nerror_out:\r\nreturn ret;\r\n}\r\nstatic int fc0013_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct fc0013_priv *priv = fe->tuner_priv;\r\nint i, ret = 0;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nu32 freq = p->frequency / 1000;\r\nu32 delsys = p->delivery_system;\r\nunsigned char reg[7], am, pm, multi, tmp;\r\nunsigned long f_vco;\r\nunsigned short xtal_freq_khz_2, xin, xdiv;\r\nint vco_select = false;\r\nif (fe->callback) {\r\nret = fe->callback(priv->i2c, DVB_FRONTEND_COMPONENT_TUNER,\r\nFC_FE_CALLBACK_VHF_ENABLE, (freq > 300000 ? 0 : 1));\r\nif (ret)\r\ngoto exit;\r\n}\r\nswitch (priv->xtal_freq) {\r\ncase FC_XTAL_27_MHZ:\r\nxtal_freq_khz_2 = 27000 / 2;\r\nbreak;\r\ncase FC_XTAL_36_MHZ:\r\nxtal_freq_khz_2 = 36000 / 2;\r\nbreak;\r\ncase FC_XTAL_28_8_MHZ:\r\ndefault:\r\nxtal_freq_khz_2 = 28800 / 2;\r\nbreak;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = fc0013_set_vhf_track(priv, freq);\r\nif (ret)\r\ngoto exit;\r\nif (freq < 300000) {\r\nret = fc0013_readreg(priv, 0x07, &tmp);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_writereg(priv, 0x07, tmp | 0x10);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_readreg(priv, 0x14, &tmp);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_writereg(priv, 0x14, tmp & 0x1f);\r\nif (ret)\r\ngoto exit;\r\n} else if (freq <= 862000) {\r\nret = fc0013_readreg(priv, 0x07, &tmp);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_writereg(priv, 0x07, tmp & 0xef);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_readreg(priv, 0x14, &tmp);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_writereg(priv, 0x14, (tmp & 0x1f) | 0x40);\r\nif (ret)\r\ngoto exit;\r\n} else {\r\nret = fc0013_readreg(priv, 0x07, &tmp);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_writereg(priv, 0x07, tmp & 0xef);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_readreg(priv, 0x14, &tmp);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_writereg(priv, 0x14, (tmp & 0x1f) | 0x20);\r\nif (ret)\r\ngoto exit;\r\n}\r\nif (freq < 37084) {\r\nmulti = 96;\r\nreg[5] = 0x82;\r\nreg[6] = 0x00;\r\n} else if (freq < 55625) {\r\nmulti = 64;\r\nreg[5] = 0x02;\r\nreg[6] = 0x02;\r\n} else if (freq < 74167) {\r\nmulti = 48;\r\nreg[5] = 0x42;\r\nreg[6] = 0x00;\r\n} else if (freq < 111250) {\r\nmulti = 32;\r\nreg[5] = 0x82;\r\nreg[6] = 0x02;\r\n} else if (freq < 148334) {\r\nmulti = 24;\r\nreg[5] = 0x22;\r\nreg[6] = 0x00;\r\n} else if (freq < 222500) {\r\nmulti = 16;\r\nreg[5] = 0x42;\r\nreg[6] = 0x02;\r\n} else if (freq < 296667) {\r\nmulti = 12;\r\nreg[5] = 0x12;\r\nreg[6] = 0x00;\r\n} else if (freq < 445000) {\r\nmulti = 8;\r\nreg[5] = 0x22;\r\nreg[6] = 0x02;\r\n} else if (freq < 593334) {\r\nmulti = 6;\r\nreg[5] = 0x0a;\r\nreg[6] = 0x00;\r\n} else if (freq < 950000) {\r\nmulti = 4;\r\nreg[5] = 0x12;\r\nreg[6] = 0x02;\r\n} else {\r\nmulti = 2;\r\nreg[5] = 0x0a;\r\nreg[6] = 0x02;\r\n}\r\nf_vco = freq * multi;\r\nif (f_vco >= 3060000) {\r\nreg[6] |= 0x08;\r\nvco_select = true;\r\n}\r\nif (freq >= 45000) {\r\nxdiv = (unsigned short)(f_vco / xtal_freq_khz_2);\r\nif ((f_vco - xdiv * xtal_freq_khz_2) >= (xtal_freq_khz_2 / 2))\r\nxdiv++;\r\npm = (unsigned char)(xdiv / 8);\r\nam = (unsigned char)(xdiv - (8 * pm));\r\nif (am < 2) {\r\nreg[1] = am + 8;\r\nreg[2] = pm - 1;\r\n} else {\r\nreg[1] = am;\r\nreg[2] = pm;\r\n}\r\n} else {\r\nreg[1] = 0x06;\r\nreg[2] = 0x11;\r\n}\r\nreg[6] |= 0x20;\r\nxin = (unsigned short)(f_vco - (f_vco / xtal_freq_khz_2) * xtal_freq_khz_2);\r\nxin = (xin << 15) / xtal_freq_khz_2;\r\nif (xin >= 16384)\r\nxin += 32768;\r\nreg[3] = xin >> 8;\r\nreg[4] = xin & 0xff;\r\nif (delsys == SYS_DVBT) {\r\nreg[6] &= 0x3f;\r\nswitch (p->bandwidth_hz) {\r\ncase 6000000:\r\nreg[6] |= 0x80;\r\nbreak;\r\ncase 7000000:\r\nreg[6] |= 0x40;\r\nbreak;\r\ncase 8000000:\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nerr("%s: modulation type not supported!", __func__);\r\nreturn -EINVAL;\r\n}\r\nreg[5] |= 0x07;\r\nfor (i = 1; i <= 6; i++) {\r\nret = fc0013_writereg(priv, i, reg[i]);\r\nif (ret)\r\ngoto exit;\r\n}\r\nret = fc0013_readreg(priv, 0x11, &tmp);\r\nif (ret)\r\ngoto exit;\r\nif (multi == 64)\r\nret = fc0013_writereg(priv, 0x11, tmp | 0x04);\r\nelse\r\nret = fc0013_writereg(priv, 0x11, tmp & 0xfb);\r\nif (ret)\r\ngoto exit;\r\nret = fc0013_writereg(priv, 0x0e, 0x80);\r\nif (!ret)\r\nret = fc0013_writereg(priv, 0x0e, 0x00);\r\nif (!ret)\r\nret = fc0013_writereg(priv, 0x0e, 0x00);\r\nif (!ret) {\r\nmsleep(10);\r\nret = fc0013_readreg(priv, 0x0e, &tmp);\r\n}\r\nif (ret)\r\ngoto exit;\r\ntmp &= 0x3f;\r\nif (vco_select) {\r\nif (tmp > 0x3c) {\r\nreg[6] &= ~0x08;\r\nret = fc0013_writereg(priv, 0x06, reg[6]);\r\nif (!ret)\r\nret = fc0013_writereg(priv, 0x0e, 0x80);\r\nif (!ret)\r\nret = fc0013_writereg(priv, 0x0e, 0x00);\r\n}\r\n} else {\r\nif (tmp < 0x02) {\r\nreg[6] |= 0x08;\r\nret = fc0013_writereg(priv, 0x06, reg[6]);\r\nif (!ret)\r\nret = fc0013_writereg(priv, 0x0e, 0x80);\r\nif (!ret)\r\nret = fc0013_writereg(priv, 0x0e, 0x00);\r\n}\r\n}\r\npriv->frequency = p->frequency;\r\npriv->bandwidth = p->bandwidth_hz;\r\nexit:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret)\r\nwarn("%s: failed: %d", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int fc0013_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct fc0013_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int fc0013_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int fc0013_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nstruct fc0013_priv *priv = fe->tuner_priv;\r\n*bandwidth = priv->bandwidth;\r\nreturn 0;\r\n}\r\nstatic int fc0013_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct fc0013_priv *priv = fe->tuner_priv;\r\nint ret;\r\nunsigned char tmp;\r\nint int_temp, lna_gain, int_lna, tot_agc_gain, power;\r\nconst int fc0013_lna_gain_table[] = {\r\n-63, -58, -99, -73,\r\n-63, -65, -54, -60,\r\n71, 70, 68, 67,\r\n65, 63, 61, 58,\r\n197, 191, 188, 186,\r\n184, 182, 181, 179,\r\n};\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = fc0013_writereg(priv, 0x13, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = fc0013_readreg(priv, 0x13, &tmp);\r\nif (ret)\r\ngoto err;\r\nint_temp = tmp;\r\nret = fc0013_readreg(priv, 0x14, &tmp);\r\nif (ret)\r\ngoto err;\r\nlna_gain = tmp & 0x1f;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (lna_gain < ARRAY_SIZE(fc0013_lna_gain_table)) {\r\nint_lna = fc0013_lna_gain_table[lna_gain];\r\ntot_agc_gain = (abs((int_temp >> 5) - 7) - 2 +\r\n(int_temp & 0x1f)) * 2;\r\npower = INPUT_ADC_LEVEL - tot_agc_gain - int_lna / 10;\r\nif (power >= 45)\r\n*strength = 255;\r\nelse if (power < -95)\r\n*strength = 0;\r\nelse\r\n*strength = (power + 95) * 255 / 140;\r\n*strength |= *strength << 8;\r\n} else {\r\nret = -1;\r\n}\r\ngoto exit;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nexit:\r\nif (ret)\r\nwarn("%s: failed: %d", __func__, ret);\r\nreturn ret;\r\n}\r\nstruct dvb_frontend *fc0013_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, u8 i2c_address, int dual_master,\r\nenum fc001x_xtal_freq xtal_freq)\r\n{\r\nstruct fc0013_priv *priv = NULL;\r\npriv = kzalloc(sizeof(struct fc0013_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c = i2c;\r\npriv->dual_master = dual_master;\r\npriv->addr = i2c_address;\r\npriv->xtal_freq = xtal_freq;\r\ninfo("Fitipower FC0013 successfully attached.");\r\nfe->tuner_priv = priv;\r\nmemcpy(&fe->ops.tuner_ops, &fc0013_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\n}
