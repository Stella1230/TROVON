static void pt1_write_reg(struct pt1 *pt1, int reg, u32 data)\r\n{\r\nwritel(data, pt1->regs + reg * 4);\r\n}\r\nstatic u32 pt1_read_reg(struct pt1 *pt1, int reg)\r\n{\r\nreturn readl(pt1->regs + reg * 4);\r\n}\r\nstatic void pt1_increment_table_count(struct pt1 *pt1)\r\n{\r\npt1_write_reg(pt1, 0, 0x00000020);\r\n}\r\nstatic void pt1_init_table_count(struct pt1 *pt1)\r\n{\r\npt1_write_reg(pt1, 0, 0x00000010);\r\n}\r\nstatic void pt1_register_tables(struct pt1 *pt1, u32 first_pfn)\r\n{\r\npt1_write_reg(pt1, 5, first_pfn);\r\npt1_write_reg(pt1, 0, 0x0c000040);\r\n}\r\nstatic void pt1_unregister_tables(struct pt1 *pt1)\r\n{\r\npt1_write_reg(pt1, 0, 0x08080000);\r\n}\r\nstatic int pt1_sync(struct pt1 *pt1)\r\n{\r\nint i;\r\nfor (i = 0; i < 57; i++) {\r\nif (pt1_read_reg(pt1, 0) & 0x20000000)\r\nreturn 0;\r\npt1_write_reg(pt1, 0, 0x00000008);\r\n}\r\npt1_printk(KERN_ERR, pt1, "could not sync\n");\r\nreturn -EIO;\r\n}\r\nstatic u64 pt1_identify(struct pt1 *pt1)\r\n{\r\nint i;\r\nu64 id;\r\nid = 0;\r\nfor (i = 0; i < 57; i++) {\r\nid |= (u64)(pt1_read_reg(pt1, 0) >> 30 & 1) << i;\r\npt1_write_reg(pt1, 0, 0x00000008);\r\n}\r\nreturn id;\r\n}\r\nstatic int pt1_unlock(struct pt1 *pt1)\r\n{\r\nint i;\r\npt1_write_reg(pt1, 0, 0x00000008);\r\nfor (i = 0; i < 3; i++) {\r\nif (pt1_read_reg(pt1, 0) & 0x80000000)\r\nreturn 0;\r\nschedule_timeout_uninterruptible((HZ + 999) / 1000);\r\n}\r\npt1_printk(KERN_ERR, pt1, "could not unlock\n");\r\nreturn -EIO;\r\n}\r\nstatic int pt1_reset_pci(struct pt1 *pt1)\r\n{\r\nint i;\r\npt1_write_reg(pt1, 0, 0x01010000);\r\npt1_write_reg(pt1, 0, 0x01000000);\r\nfor (i = 0; i < 10; i++) {\r\nif (pt1_read_reg(pt1, 0) & 0x00000001)\r\nreturn 0;\r\nschedule_timeout_uninterruptible((HZ + 999) / 1000);\r\n}\r\npt1_printk(KERN_ERR, pt1, "could not reset PCI\n");\r\nreturn -EIO;\r\n}\r\nstatic int pt1_reset_ram(struct pt1 *pt1)\r\n{\r\nint i;\r\npt1_write_reg(pt1, 0, 0x02020000);\r\npt1_write_reg(pt1, 0, 0x02000000);\r\nfor (i = 0; i < 10; i++) {\r\nif (pt1_read_reg(pt1, 0) & 0x00000002)\r\nreturn 0;\r\nschedule_timeout_uninterruptible((HZ + 999) / 1000);\r\n}\r\npt1_printk(KERN_ERR, pt1, "could not reset RAM\n");\r\nreturn -EIO;\r\n}\r\nstatic int pt1_do_enable_ram(struct pt1 *pt1)\r\n{\r\nint i, j;\r\nu32 status;\r\nstatus = pt1_read_reg(pt1, 0) & 0x00000004;\r\npt1_write_reg(pt1, 0, 0x00000002);\r\nfor (i = 0; i < 10; i++) {\r\nfor (j = 0; j < 1024; j++) {\r\nif ((pt1_read_reg(pt1, 0) & 0x00000004) != status)\r\nreturn 0;\r\n}\r\nschedule_timeout_uninterruptible((HZ + 999) / 1000);\r\n}\r\npt1_printk(KERN_ERR, pt1, "could not enable RAM\n");\r\nreturn -EIO;\r\n}\r\nstatic int pt1_enable_ram(struct pt1 *pt1)\r\n{\r\nint i, ret;\r\nint phase;\r\nschedule_timeout_uninterruptible((HZ + 999) / 1000);\r\nphase = pt1->pdev->device == 0x211a ? 128 : 166;\r\nfor (i = 0; i < phase; i++) {\r\nret = pt1_do_enable_ram(pt1);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pt1_disable_ram(struct pt1 *pt1)\r\n{\r\npt1_write_reg(pt1, 0, 0x0b0b0000);\r\n}\r\nstatic void pt1_set_stream(struct pt1 *pt1, int index, int enabled)\r\n{\r\npt1_write_reg(pt1, 2, 1 << (index + 8) | enabled << index);\r\n}\r\nstatic void pt1_init_streams(struct pt1 *pt1)\r\n{\r\nint i;\r\nfor (i = 0; i < PT1_NR_ADAPS; i++)\r\npt1_set_stream(pt1, i, 0);\r\n}\r\nstatic int pt1_filter(struct pt1 *pt1, struct pt1_buffer_page *page)\r\n{\r\nu32 upacket;\r\nint i;\r\nint index;\r\nstruct pt1_adapter *adap;\r\nint offset;\r\nu8 *buf;\r\nint sc;\r\nif (!page->upackets[PT1_NR_UPACKETS - 1])\r\nreturn 0;\r\nfor (i = 0; i < PT1_NR_UPACKETS; i++) {\r\nupacket = le32_to_cpu(page->upackets[i]);\r\nindex = (upacket >> 29) - 1;\r\nif (index < 0 || index >= PT1_NR_ADAPS)\r\ncontinue;\r\nadap = pt1->adaps[index];\r\nif (upacket >> 25 & 1)\r\nadap->upacket_count = 0;\r\nelse if (!adap->upacket_count)\r\ncontinue;\r\nif (upacket >> 24 & 1)\r\nprintk_ratelimited(KERN_INFO "earth-pt1: device "\r\n"buffer overflowing. table[%d] buf[%d]\n",\r\npt1->table_index, pt1->buf_index);\r\nsc = upacket >> 26 & 0x7;\r\nif (adap->st_count != -1 && sc != ((adap->st_count + 1) & 0x7))\r\nprintk_ratelimited(KERN_INFO "earth-pt1: data loss"\r\n" in streamID(adapter)[%d]\n", index);\r\nadap->st_count = sc;\r\nbuf = adap->buf;\r\noffset = adap->packet_count * 188 + adap->upacket_count * 3;\r\nbuf[offset] = upacket >> 16;\r\nbuf[offset + 1] = upacket >> 8;\r\nif (adap->upacket_count != 62)\r\nbuf[offset + 2] = upacket;\r\nif (++adap->upacket_count >= 63) {\r\nadap->upacket_count = 0;\r\nif (++adap->packet_count >= 21) {\r\ndvb_dmx_swfilter_packets(&adap->demux, buf, 21);\r\nadap->packet_count = 0;\r\n}\r\n}\r\n}\r\npage->upackets[PT1_NR_UPACKETS - 1] = 0;\r\nreturn 1;\r\n}\r\nstatic int pt1_thread(void *data)\r\n{\r\nstruct pt1 *pt1;\r\nstruct pt1_buffer_page *page;\r\npt1 = data;\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\ntry_to_freeze();\r\npage = pt1->tables[pt1->table_index].bufs[pt1->buf_index].page;\r\nif (!pt1_filter(pt1, page)) {\r\nschedule_timeout_interruptible((HZ + 999) / 1000);\r\ncontinue;\r\n}\r\nif (++pt1->buf_index >= PT1_NR_BUFS) {\r\npt1_increment_table_count(pt1);\r\npt1->buf_index = 0;\r\nif (++pt1->table_index >= pt1_nr_tables)\r\npt1->table_index = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pt1_free_page(struct pt1 *pt1, void *page, dma_addr_t addr)\r\n{\r\ndma_free_coherent(&pt1->pdev->dev, PT1_PAGE_SIZE, page, addr);\r\n}\r\nstatic void *pt1_alloc_page(struct pt1 *pt1, dma_addr_t *addrp, u32 *pfnp)\r\n{\r\nvoid *page;\r\ndma_addr_t addr;\r\npage = dma_alloc_coherent(&pt1->pdev->dev, PT1_PAGE_SIZE, &addr,\r\nGFP_KERNEL);\r\nif (page == NULL)\r\nreturn NULL;\r\nBUG_ON(addr & (PT1_PAGE_SIZE - 1));\r\nBUG_ON(addr >> PT1_PAGE_SHIFT >> 31 >> 1);\r\n*addrp = addr;\r\n*pfnp = addr >> PT1_PAGE_SHIFT;\r\nreturn page;\r\n}\r\nstatic void pt1_cleanup_buffer(struct pt1 *pt1, struct pt1_buffer *buf)\r\n{\r\npt1_free_page(pt1, buf->page, buf->addr);\r\n}\r\nstatic int\r\npt1_init_buffer(struct pt1 *pt1, struct pt1_buffer *buf, u32 *pfnp)\r\n{\r\nstruct pt1_buffer_page *page;\r\ndma_addr_t addr;\r\npage = pt1_alloc_page(pt1, &addr, pfnp);\r\nif (page == NULL)\r\nreturn -ENOMEM;\r\npage->upackets[PT1_NR_UPACKETS - 1] = 0;\r\nbuf->page = page;\r\nbuf->addr = addr;\r\nreturn 0;\r\n}\r\nstatic void pt1_cleanup_table(struct pt1 *pt1, struct pt1_table *table)\r\n{\r\nint i;\r\nfor (i = 0; i < PT1_NR_BUFS; i++)\r\npt1_cleanup_buffer(pt1, &table->bufs[i]);\r\npt1_free_page(pt1, table->page, table->addr);\r\n}\r\nstatic int\r\npt1_init_table(struct pt1 *pt1, struct pt1_table *table, u32 *pfnp)\r\n{\r\nstruct pt1_table_page *page;\r\ndma_addr_t addr;\r\nint i, ret;\r\nu32 buf_pfn;\r\npage = pt1_alloc_page(pt1, &addr, pfnp);\r\nif (page == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < PT1_NR_BUFS; i++) {\r\nret = pt1_init_buffer(pt1, &table->bufs[i], &buf_pfn);\r\nif (ret < 0)\r\ngoto err;\r\npage->buf_pfns[i] = cpu_to_le32(buf_pfn);\r\n}\r\npt1_increment_table_count(pt1);\r\ntable->page = page;\r\ntable->addr = addr;\r\nreturn 0;\r\nerr:\r\nwhile (i--)\r\npt1_cleanup_buffer(pt1, &table->bufs[i]);\r\npt1_free_page(pt1, page, addr);\r\nreturn ret;\r\n}\r\nstatic void pt1_cleanup_tables(struct pt1 *pt1)\r\n{\r\nstruct pt1_table *tables;\r\nint i;\r\ntables = pt1->tables;\r\npt1_unregister_tables(pt1);\r\nfor (i = 0; i < pt1_nr_tables; i++)\r\npt1_cleanup_table(pt1, &tables[i]);\r\nvfree(tables);\r\n}\r\nstatic int pt1_init_tables(struct pt1 *pt1)\r\n{\r\nstruct pt1_table *tables;\r\nint i, ret;\r\nu32 first_pfn, pfn;\r\ntables = vmalloc(sizeof(struct pt1_table) * pt1_nr_tables);\r\nif (tables == NULL)\r\nreturn -ENOMEM;\r\npt1_init_table_count(pt1);\r\ni = 0;\r\nif (pt1_nr_tables) {\r\nret = pt1_init_table(pt1, &tables[0], &first_pfn);\r\nif (ret)\r\ngoto err;\r\ni++;\r\n}\r\nwhile (i < pt1_nr_tables) {\r\nret = pt1_init_table(pt1, &tables[i], &pfn);\r\nif (ret)\r\ngoto err;\r\ntables[i - 1].page->next_pfn = cpu_to_le32(pfn);\r\ni++;\r\n}\r\ntables[pt1_nr_tables - 1].page->next_pfn = cpu_to_le32(first_pfn);\r\npt1_register_tables(pt1, first_pfn);\r\npt1->tables = tables;\r\nreturn 0;\r\nerr:\r\nwhile (i--)\r\npt1_cleanup_table(pt1, &tables[i]);\r\nvfree(tables);\r\nreturn ret;\r\n}\r\nstatic int pt1_start_polling(struct pt1 *pt1)\r\n{\r\nint ret = 0;\r\nmutex_lock(&pt1->lock);\r\nif (!pt1->kthread) {\r\npt1->kthread = kthread_run(pt1_thread, pt1, "earth-pt1");\r\nif (IS_ERR(pt1->kthread)) {\r\nret = PTR_ERR(pt1->kthread);\r\npt1->kthread = NULL;\r\n}\r\n}\r\nmutex_unlock(&pt1->lock);\r\nreturn ret;\r\n}\r\nstatic int pt1_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct pt1_adapter *adap;\r\nadap = container_of(feed->demux, struct pt1_adapter, demux);\r\nif (!adap->users++) {\r\nint ret;\r\nret = pt1_start_polling(adap->pt1);\r\nif (ret)\r\nreturn ret;\r\npt1_set_stream(adap->pt1, adap->index, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pt1_stop_polling(struct pt1 *pt1)\r\n{\r\nint i, count;\r\nmutex_lock(&pt1->lock);\r\nfor (i = 0, count = 0; i < PT1_NR_ADAPS; i++)\r\ncount += pt1->adaps[i]->users;\r\nif (count == 0 && pt1->kthread) {\r\nkthread_stop(pt1->kthread);\r\npt1->kthread = NULL;\r\n}\r\nmutex_unlock(&pt1->lock);\r\n}\r\nstatic int pt1_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct pt1_adapter *adap;\r\nadap = container_of(feed->demux, struct pt1_adapter, demux);\r\nif (!--adap->users) {\r\npt1_set_stream(adap->pt1, adap->index, 0);\r\npt1_stop_polling(adap->pt1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\npt1_update_power(struct pt1 *pt1)\r\n{\r\nint bits;\r\nint i;\r\nstruct pt1_adapter *adap;\r\nstatic const int sleep_bits[] = {\r\n1 << 4,\r\n1 << 6 | 1 << 7,\r\n1 << 5,\r\n1 << 6 | 1 << 8,\r\n};\r\nbits = pt1->power | !pt1->reset << 3;\r\nmutex_lock(&pt1->lock);\r\nfor (i = 0; i < PT1_NR_ADAPS; i++) {\r\nadap = pt1->adaps[i];\r\nswitch (adap->voltage) {\r\ncase SEC_VOLTAGE_13:\r\nbits |= 1 << 1;\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\nbits |= 1 << 1 | 1 << 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbits |= sleep_bits[i];\r\n}\r\npt1_write_reg(pt1, 1, bits);\r\nmutex_unlock(&pt1->lock);\r\n}\r\nstatic int pt1_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct pt1_adapter *adap;\r\nadap = container_of(fe->dvb, struct pt1_adapter, adap);\r\nadap->voltage = voltage;\r\npt1_update_power(adap->pt1);\r\nif (adap->orig_set_voltage)\r\nreturn adap->orig_set_voltage(fe, voltage);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int pt1_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct pt1_adapter *adap;\r\nadap = container_of(fe->dvb, struct pt1_adapter, adap);\r\nadap->sleep = 1;\r\npt1_update_power(adap->pt1);\r\nif (adap->orig_sleep)\r\nreturn adap->orig_sleep(fe);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int pt1_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct pt1_adapter *adap;\r\nadap = container_of(fe->dvb, struct pt1_adapter, adap);\r\nadap->sleep = 0;\r\npt1_update_power(adap->pt1);\r\nschedule_timeout_uninterruptible((HZ + 999) / 1000);\r\nif (adap->orig_init)\r\nreturn adap->orig_init(fe);\r\nelse\r\nreturn 0;\r\n}\r\nstatic void pt1_free_adapter(struct pt1_adapter *adap)\r\n{\r\nadap->demux.dmx.close(&adap->demux.dmx);\r\ndvb_dmxdev_release(&adap->dmxdev);\r\ndvb_dmx_release(&adap->demux);\r\ndvb_unregister_adapter(&adap->adap);\r\nfree_page((unsigned long)adap->buf);\r\nkfree(adap);\r\n}\r\nstatic struct pt1_adapter *\r\npt1_alloc_adapter(struct pt1 *pt1)\r\n{\r\nstruct pt1_adapter *adap;\r\nvoid *buf;\r\nstruct dvb_adapter *dvb_adap;\r\nstruct dvb_demux *demux;\r\nstruct dmxdev *dmxdev;\r\nint ret;\r\nadap = kzalloc(sizeof(struct pt1_adapter), GFP_KERNEL);\r\nif (!adap) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nadap->pt1 = pt1;\r\nadap->voltage = SEC_VOLTAGE_OFF;\r\nadap->sleep = 1;\r\nbuf = (u8 *)__get_free_page(GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto err_kfree;\r\n}\r\nadap->buf = buf;\r\nadap->upacket_count = 0;\r\nadap->packet_count = 0;\r\nadap->st_count = -1;\r\ndvb_adap = &adap->adap;\r\ndvb_adap->priv = adap;\r\nret = dvb_register_adapter(dvb_adap, DRIVER_NAME, THIS_MODULE,\r\n&pt1->pdev->dev, adapter_nr);\r\nif (ret < 0)\r\ngoto err_free_page;\r\ndemux = &adap->demux;\r\ndemux->dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\r\ndemux->priv = adap;\r\ndemux->feednum = 256;\r\ndemux->filternum = 256;\r\ndemux->start_feed = pt1_start_feed;\r\ndemux->stop_feed = pt1_stop_feed;\r\ndemux->write_to_decoder = NULL;\r\nret = dvb_dmx_init(demux);\r\nif (ret < 0)\r\ngoto err_unregister_adapter;\r\ndmxdev = &adap->dmxdev;\r\ndmxdev->filternum = 256;\r\ndmxdev->demux = &demux->dmx;\r\ndmxdev->capabilities = 0;\r\nret = dvb_dmxdev_init(dmxdev, dvb_adap);\r\nif (ret < 0)\r\ngoto err_dmx_release;\r\nreturn adap;\r\nerr_dmx_release:\r\ndvb_dmx_release(demux);\r\nerr_unregister_adapter:\r\ndvb_unregister_adapter(dvb_adap);\r\nerr_free_page:\r\nfree_page((unsigned long)buf);\r\nerr_kfree:\r\nkfree(adap);\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void pt1_cleanup_adapters(struct pt1 *pt1)\r\n{\r\nint i;\r\nfor (i = 0; i < PT1_NR_ADAPS; i++)\r\npt1_free_adapter(pt1->adaps[i]);\r\n}\r\nstatic int pt1_init_adapters(struct pt1 *pt1)\r\n{\r\nint i;\r\nstruct pt1_adapter *adap;\r\nint ret;\r\nfor (i = 0; i < PT1_NR_ADAPS; i++) {\r\nadap = pt1_alloc_adapter(pt1);\r\nif (IS_ERR(adap)) {\r\nret = PTR_ERR(adap);\r\ngoto err;\r\n}\r\nadap->index = i;\r\npt1->adaps[i] = adap;\r\n}\r\nreturn 0;\r\nerr:\r\nwhile (i--)\r\npt1_free_adapter(pt1->adaps[i]);\r\nreturn ret;\r\n}\r\nstatic void pt1_cleanup_frontend(struct pt1_adapter *adap)\r\n{\r\ndvb_unregister_frontend(adap->fe);\r\n}\r\nstatic int pt1_init_frontend(struct pt1_adapter *adap, struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nadap->orig_set_voltage = fe->ops.set_voltage;\r\nadap->orig_sleep = fe->ops.sleep;\r\nadap->orig_init = fe->ops.init;\r\nfe->ops.set_voltage = pt1_set_voltage;\r\nfe->ops.sleep = pt1_sleep;\r\nfe->ops.init = pt1_wakeup;\r\nret = dvb_register_frontend(&adap->adap, fe);\r\nif (ret < 0)\r\nreturn ret;\r\nadap->fe = fe;\r\nreturn 0;\r\n}\r\nstatic void pt1_cleanup_frontends(struct pt1 *pt1)\r\n{\r\nint i;\r\nfor (i = 0; i < PT1_NR_ADAPS; i++)\r\npt1_cleanup_frontend(pt1->adaps[i]);\r\n}\r\nstatic int pt1_init_frontends(struct pt1 *pt1)\r\n{\r\nint i, j;\r\nstruct i2c_adapter *i2c_adap;\r\nconst struct pt1_config *configs, *config;\r\nstruct dvb_frontend *fe[4];\r\nint ret;\r\ni = 0;\r\nj = 0;\r\ni2c_adap = &pt1->i2c_adap;\r\nconfigs = pt1->pdev->device == 0x211a ? pt1_configs : pt2_configs;\r\ndo {\r\nconfig = &configs[i / 2];\r\nfe[i] = va1j5jf8007s_attach(&config->va1j5jf8007s_config,\r\ni2c_adap);\r\nif (!fe[i]) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ni++;\r\nfe[i] = va1j5jf8007t_attach(&config->va1j5jf8007t_config,\r\ni2c_adap);\r\nif (!fe[i]) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ni++;\r\nret = va1j5jf8007s_prepare(fe[i - 2]);\r\nif (ret < 0)\r\ngoto err;\r\nret = va1j5jf8007t_prepare(fe[i - 1]);\r\nif (ret < 0)\r\ngoto err;\r\n} while (i < 4);\r\ndo {\r\nret = pt1_init_frontend(pt1->adaps[j], fe[j]);\r\nif (ret < 0)\r\ngoto err;\r\n} while (++j < 4);\r\nreturn 0;\r\nerr:\r\nwhile (i-- > j)\r\nfe[i]->ops.release(fe[i]);\r\nwhile (j--)\r\ndvb_unregister_frontend(fe[j]);\r\nreturn ret;\r\n}\r\nstatic void pt1_i2c_emit(struct pt1 *pt1, int addr, int busy, int read_enable,\r\nint clock, int data, int next_addr)\r\n{\r\npt1_write_reg(pt1, 4, addr << 18 | busy << 13 | read_enable << 12 |\r\n!clock << 11 | !data << 10 | next_addr);\r\n}\r\nstatic void pt1_i2c_write_bit(struct pt1 *pt1, int addr, int *addrp, int data)\r\n{\r\npt1_i2c_emit(pt1, addr, 1, 0, 0, data, addr + 1);\r\npt1_i2c_emit(pt1, addr + 1, 1, 0, 1, data, addr + 2);\r\npt1_i2c_emit(pt1, addr + 2, 1, 0, 0, data, addr + 3);\r\n*addrp = addr + 3;\r\n}\r\nstatic void pt1_i2c_read_bit(struct pt1 *pt1, int addr, int *addrp)\r\n{\r\npt1_i2c_emit(pt1, addr, 1, 0, 0, 1, addr + 1);\r\npt1_i2c_emit(pt1, addr + 1, 1, 0, 1, 1, addr + 2);\r\npt1_i2c_emit(pt1, addr + 2, 1, 1, 1, 1, addr + 3);\r\npt1_i2c_emit(pt1, addr + 3, 1, 0, 0, 1, addr + 4);\r\n*addrp = addr + 4;\r\n}\r\nstatic void pt1_i2c_write_byte(struct pt1 *pt1, int addr, int *addrp, int data)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\npt1_i2c_write_bit(pt1, addr, &addr, data >> (7 - i) & 1);\r\npt1_i2c_write_bit(pt1, addr, &addr, 1);\r\n*addrp = addr;\r\n}\r\nstatic void pt1_i2c_read_byte(struct pt1 *pt1, int addr, int *addrp, int last)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\npt1_i2c_read_bit(pt1, addr, &addr);\r\npt1_i2c_write_bit(pt1, addr, &addr, last);\r\n*addrp = addr;\r\n}\r\nstatic void pt1_i2c_prepare(struct pt1 *pt1, int addr, int *addrp)\r\n{\r\npt1_i2c_emit(pt1, addr, 1, 0, 1, 1, addr + 1);\r\npt1_i2c_emit(pt1, addr + 1, 1, 0, 1, 0, addr + 2);\r\npt1_i2c_emit(pt1, addr + 2, 1, 0, 0, 0, addr + 3);\r\n*addrp = addr + 3;\r\n}\r\nstatic void\r\npt1_i2c_write_msg(struct pt1 *pt1, int addr, int *addrp, struct i2c_msg *msg)\r\n{\r\nint i;\r\npt1_i2c_prepare(pt1, addr, &addr);\r\npt1_i2c_write_byte(pt1, addr, &addr, msg->addr << 1);\r\nfor (i = 0; i < msg->len; i++)\r\npt1_i2c_write_byte(pt1, addr, &addr, msg->buf[i]);\r\n*addrp = addr;\r\n}\r\nstatic void\r\npt1_i2c_read_msg(struct pt1 *pt1, int addr, int *addrp, struct i2c_msg *msg)\r\n{\r\nint i;\r\npt1_i2c_prepare(pt1, addr, &addr);\r\npt1_i2c_write_byte(pt1, addr, &addr, msg->addr << 1 | 1);\r\nfor (i = 0; i < msg->len; i++)\r\npt1_i2c_read_byte(pt1, addr, &addr, i == msg->len - 1);\r\n*addrp = addr;\r\n}\r\nstatic int pt1_i2c_end(struct pt1 *pt1, int addr)\r\n{\r\npt1_i2c_emit(pt1, addr, 1, 0, 0, 0, addr + 1);\r\npt1_i2c_emit(pt1, addr + 1, 1, 0, 1, 0, addr + 2);\r\npt1_i2c_emit(pt1, addr + 2, 1, 0, 1, 1, 0);\r\npt1_write_reg(pt1, 0, 0x00000004);\r\ndo {\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nschedule_timeout_interruptible((HZ + 999) / 1000);\r\n} while (pt1_read_reg(pt1, 0) & 0x00000080);\r\nreturn 0;\r\n}\r\nstatic void pt1_i2c_begin(struct pt1 *pt1, int *addrp)\r\n{\r\nint addr;\r\naddr = 0;\r\npt1_i2c_emit(pt1, addr, 0, 0, 1, 1, addr );\r\naddr = addr + 1;\r\nif (!pt1->i2c_running) {\r\npt1_i2c_emit(pt1, addr, 1, 0, 1, 1, addr + 1);\r\npt1_i2c_emit(pt1, addr + 1, 1, 0, 1, 0, addr + 2);\r\naddr = addr + 2;\r\npt1->i2c_running = 1;\r\n}\r\n*addrp = addr;\r\n}\r\nstatic int pt1_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct pt1 *pt1;\r\nint i;\r\nstruct i2c_msg *msg, *next_msg;\r\nint addr, ret;\r\nu16 len;\r\nu32 word;\r\npt1 = i2c_get_adapdata(adap);\r\nfor (i = 0; i < num; i++) {\r\nmsg = &msgs[i];\r\nif (msg->flags & I2C_M_RD)\r\nreturn -ENOTSUPP;\r\nif (i + 1 < num)\r\nnext_msg = &msgs[i + 1];\r\nelse\r\nnext_msg = NULL;\r\nif (next_msg && next_msg->flags & I2C_M_RD) {\r\ni++;\r\nlen = next_msg->len;\r\nif (len > 4)\r\nreturn -ENOTSUPP;\r\npt1_i2c_begin(pt1, &addr);\r\npt1_i2c_write_msg(pt1, addr, &addr, msg);\r\npt1_i2c_read_msg(pt1, addr, &addr, next_msg);\r\nret = pt1_i2c_end(pt1, addr);\r\nif (ret < 0)\r\nreturn ret;\r\nword = pt1_read_reg(pt1, 2);\r\nwhile (len--) {\r\nnext_msg->buf[len] = word;\r\nword >>= 8;\r\n}\r\n} else {\r\npt1_i2c_begin(pt1, &addr);\r\npt1_i2c_write_msg(pt1, addr, &addr, msg);\r\nret = pt1_i2c_end(pt1, addr);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn num;\r\n}\r\nstatic u32 pt1_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic void pt1_i2c_wait(struct pt1 *pt1)\r\n{\r\nint i;\r\nfor (i = 0; i < 128; i++)\r\npt1_i2c_emit(pt1, 0, 0, 0, 1, 1, 0);\r\n}\r\nstatic void pt1_i2c_init(struct pt1 *pt1)\r\n{\r\nint i;\r\nfor (i = 0; i < 1024; i++)\r\npt1_i2c_emit(pt1, i, 0, 0, 1, 1, 0);\r\n}\r\nstatic void __devexit pt1_remove(struct pci_dev *pdev)\r\n{\r\nstruct pt1 *pt1;\r\nvoid __iomem *regs;\r\npt1 = pci_get_drvdata(pdev);\r\nregs = pt1->regs;\r\nif (pt1->kthread)\r\nkthread_stop(pt1->kthread);\r\npt1_cleanup_tables(pt1);\r\npt1_cleanup_frontends(pt1);\r\npt1_disable_ram(pt1);\r\npt1->power = 0;\r\npt1->reset = 1;\r\npt1_update_power(pt1);\r\npt1_cleanup_adapters(pt1);\r\ni2c_del_adapter(&pt1->i2c_adap);\r\npci_set_drvdata(pdev, NULL);\r\nkfree(pt1);\r\npci_iounmap(pdev, regs);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int __devinit\r\npt1_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint ret;\r\nvoid __iomem *regs;\r\nstruct pt1 *pt1;\r\nstruct i2c_adapter *i2c_adap;\r\nret = pci_enable_device(pdev);\r\nif (ret < 0)\r\ngoto err;\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret < 0)\r\ngoto err_pci_disable_device;\r\npci_set_master(pdev);\r\nret = pci_request_regions(pdev, DRIVER_NAME);\r\nif (ret < 0)\r\ngoto err_pci_disable_device;\r\nregs = pci_iomap(pdev, 0, 0);\r\nif (!regs) {\r\nret = -EIO;\r\ngoto err_pci_release_regions;\r\n}\r\npt1 = kzalloc(sizeof(struct pt1), GFP_KERNEL);\r\nif (!pt1) {\r\nret = -ENOMEM;\r\ngoto err_pci_iounmap;\r\n}\r\nmutex_init(&pt1->lock);\r\npt1->pdev = pdev;\r\npt1->regs = regs;\r\npci_set_drvdata(pdev, pt1);\r\nret = pt1_init_adapters(pt1);\r\nif (ret < 0)\r\ngoto err_kfree;\r\nmutex_init(&pt1->lock);\r\npt1->power = 0;\r\npt1->reset = 1;\r\npt1_update_power(pt1);\r\ni2c_adap = &pt1->i2c_adap;\r\ni2c_adap->algo = &pt1_i2c_algo;\r\ni2c_adap->algo_data = NULL;\r\ni2c_adap->dev.parent = &pdev->dev;\r\nstrcpy(i2c_adap->name, DRIVER_NAME);\r\ni2c_set_adapdata(i2c_adap, pt1);\r\nret = i2c_add_adapter(i2c_adap);\r\nif (ret < 0)\r\ngoto err_pt1_cleanup_adapters;\r\npt1_i2c_init(pt1);\r\npt1_i2c_wait(pt1);\r\nret = pt1_sync(pt1);\r\nif (ret < 0)\r\ngoto err_i2c_del_adapter;\r\npt1_identify(pt1);\r\nret = pt1_unlock(pt1);\r\nif (ret < 0)\r\ngoto err_i2c_del_adapter;\r\nret = pt1_reset_pci(pt1);\r\nif (ret < 0)\r\ngoto err_i2c_del_adapter;\r\nret = pt1_reset_ram(pt1);\r\nif (ret < 0)\r\ngoto err_i2c_del_adapter;\r\nret = pt1_enable_ram(pt1);\r\nif (ret < 0)\r\ngoto err_i2c_del_adapter;\r\npt1_init_streams(pt1);\r\npt1->power = 1;\r\npt1_update_power(pt1);\r\nschedule_timeout_uninterruptible((HZ + 49) / 50);\r\npt1->reset = 0;\r\npt1_update_power(pt1);\r\nschedule_timeout_uninterruptible((HZ + 999) / 1000);\r\nret = pt1_init_frontends(pt1);\r\nif (ret < 0)\r\ngoto err_pt1_disable_ram;\r\nret = pt1_init_tables(pt1);\r\nif (ret < 0)\r\ngoto err_pt1_cleanup_frontends;\r\nreturn 0;\r\nerr_pt1_cleanup_frontends:\r\npt1_cleanup_frontends(pt1);\r\nerr_pt1_disable_ram:\r\npt1_disable_ram(pt1);\r\npt1->power = 0;\r\npt1->reset = 1;\r\npt1_update_power(pt1);\r\nerr_i2c_del_adapter:\r\ni2c_del_adapter(i2c_adap);\r\nerr_pt1_cleanup_adapters:\r\npt1_cleanup_adapters(pt1);\r\nerr_kfree:\r\npci_set_drvdata(pdev, NULL);\r\nkfree(pt1);\r\nerr_pci_iounmap:\r\npci_iounmap(pdev, regs);\r\nerr_pci_release_regions:\r\npci_release_regions(pdev);\r\nerr_pci_disable_device:\r\npci_disable_device(pdev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __init pt1_init(void)\r\n{\r\nreturn pci_register_driver(&pt1_driver);\r\n}\r\nstatic void __exit pt1_cleanup(void)\r\n{\r\npci_unregister_driver(&pt1_driver);\r\n}
