static int ghes_ioremap_init(void)\r\n{\r\nghes_ioremap_area = __get_vm_area(PAGE_SIZE * GHES_IOREMAP_PAGES,\r\nVM_IOREMAP, VMALLOC_START, VMALLOC_END);\r\nif (!ghes_ioremap_area) {\r\npr_err(GHES_PFX "Failed to allocate virtual memory area for atomic ioremap.\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ghes_ioremap_exit(void)\r\n{\r\nfree_vm_area(ghes_ioremap_area);\r\n}\r\nstatic void __iomem *ghes_ioremap_pfn_nmi(u64 pfn)\r\n{\r\nunsigned long vaddr;\r\nvaddr = (unsigned long)GHES_IOREMAP_NMI_PAGE(ghes_ioremap_area->addr);\r\nioremap_page_range(vaddr, vaddr + PAGE_SIZE,\r\npfn << PAGE_SHIFT, PAGE_KERNEL);\r\nreturn (void __iomem *)vaddr;\r\n}\r\nstatic void __iomem *ghes_ioremap_pfn_irq(u64 pfn)\r\n{\r\nunsigned long vaddr;\r\nvaddr = (unsigned long)GHES_IOREMAP_IRQ_PAGE(ghes_ioremap_area->addr);\r\nioremap_page_range(vaddr, vaddr + PAGE_SIZE,\r\npfn << PAGE_SHIFT, PAGE_KERNEL);\r\nreturn (void __iomem *)vaddr;\r\n}\r\nstatic void ghes_iounmap_nmi(void __iomem *vaddr_ptr)\r\n{\r\nunsigned long vaddr = (unsigned long __force)vaddr_ptr;\r\nvoid *base = ghes_ioremap_area->addr;\r\nBUG_ON(vaddr != (unsigned long)GHES_IOREMAP_NMI_PAGE(base));\r\nunmap_kernel_range_noflush(vaddr, PAGE_SIZE);\r\n__flush_tlb_one(vaddr);\r\n}\r\nstatic void ghes_iounmap_irq(void __iomem *vaddr_ptr)\r\n{\r\nunsigned long vaddr = (unsigned long __force)vaddr_ptr;\r\nvoid *base = ghes_ioremap_area->addr;\r\nBUG_ON(vaddr != (unsigned long)GHES_IOREMAP_IRQ_PAGE(base));\r\nunmap_kernel_range_noflush(vaddr, PAGE_SIZE);\r\n__flush_tlb_one(vaddr);\r\n}\r\nstatic int ghes_estatus_pool_init(void)\r\n{\r\nghes_estatus_pool = gen_pool_create(GHES_ESTATUS_POOL_MIN_ALLOC_ORDER, -1);\r\nif (!ghes_estatus_pool)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void ghes_estatus_pool_free_chunk_page(struct gen_pool *pool,\r\nstruct gen_pool_chunk *chunk,\r\nvoid *data)\r\n{\r\nfree_page(chunk->start_addr);\r\n}\r\nstatic void ghes_estatus_pool_exit(void)\r\n{\r\ngen_pool_for_each_chunk(ghes_estatus_pool,\r\nghes_estatus_pool_free_chunk_page, NULL);\r\ngen_pool_destroy(ghes_estatus_pool);\r\n}\r\nstatic int ghes_estatus_pool_expand(unsigned long len)\r\n{\r\nunsigned long i, pages, size, addr;\r\nint ret;\r\nghes_estatus_pool_size_request += PAGE_ALIGN(len);\r\nsize = gen_pool_size(ghes_estatus_pool);\r\nif (size >= ghes_estatus_pool_size_request)\r\nreturn 0;\r\npages = (ghes_estatus_pool_size_request - size) / PAGE_SIZE;\r\nfor (i = 0; i < pages; i++) {\r\naddr = __get_free_page(GFP_KERNEL);\r\nif (!addr)\r\nreturn -ENOMEM;\r\nret = gen_pool_add(ghes_estatus_pool, addr, PAGE_SIZE, -1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ghes_estatus_pool_shrink(unsigned long len)\r\n{\r\nghes_estatus_pool_size_request -= PAGE_ALIGN(len);\r\n}\r\nstatic struct ghes *ghes_new(struct acpi_hest_generic *generic)\r\n{\r\nstruct ghes *ghes;\r\nunsigned int error_block_length;\r\nint rc;\r\nghes = kzalloc(sizeof(*ghes), GFP_KERNEL);\r\nif (!ghes)\r\nreturn ERR_PTR(-ENOMEM);\r\nghes->generic = generic;\r\nrc = apei_map_generic_address(&generic->error_status_address);\r\nif (rc)\r\ngoto err_free;\r\nerror_block_length = generic->error_block_length;\r\nif (error_block_length > GHES_ESTATUS_MAX_SIZE) {\r\npr_warning(FW_WARN GHES_PFX\r\n"Error status block length is too long: %u for "\r\n"generic hardware error source: %d.\n",\r\nerror_block_length, generic->header.source_id);\r\nerror_block_length = GHES_ESTATUS_MAX_SIZE;\r\n}\r\nghes->estatus = kmalloc(error_block_length, GFP_KERNEL);\r\nif (!ghes->estatus) {\r\nrc = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\nreturn ghes;\r\nerr_unmap:\r\napei_unmap_generic_address(&generic->error_status_address);\r\nerr_free:\r\nkfree(ghes);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic void ghes_fini(struct ghes *ghes)\r\n{\r\nkfree(ghes->estatus);\r\napei_unmap_generic_address(&ghes->generic->error_status_address);\r\n}\r\nstatic inline int ghes_severity(int severity)\r\n{\r\nswitch (severity) {\r\ncase CPER_SEV_INFORMATIONAL:\r\nreturn GHES_SEV_NO;\r\ncase CPER_SEV_CORRECTED:\r\nreturn GHES_SEV_CORRECTED;\r\ncase CPER_SEV_RECOVERABLE:\r\nreturn GHES_SEV_RECOVERABLE;\r\ncase CPER_SEV_FATAL:\r\nreturn GHES_SEV_PANIC;\r\ndefault:\r\nreturn GHES_SEV_PANIC;\r\n}\r\n}\r\nstatic void ghes_copy_tofrom_phys(void *buffer, u64 paddr, u32 len,\r\nint from_phys)\r\n{\r\nvoid __iomem *vaddr;\r\nunsigned long flags = 0;\r\nint in_nmi = in_nmi();\r\nu64 offset;\r\nu32 trunk;\r\nwhile (len > 0) {\r\noffset = paddr - (paddr & PAGE_MASK);\r\nif (in_nmi) {\r\nraw_spin_lock(&ghes_ioremap_lock_nmi);\r\nvaddr = ghes_ioremap_pfn_nmi(paddr >> PAGE_SHIFT);\r\n} else {\r\nspin_lock_irqsave(&ghes_ioremap_lock_irq, flags);\r\nvaddr = ghes_ioremap_pfn_irq(paddr >> PAGE_SHIFT);\r\n}\r\ntrunk = PAGE_SIZE - offset;\r\ntrunk = min(trunk, len);\r\nif (from_phys)\r\nmemcpy_fromio(buffer, vaddr + offset, trunk);\r\nelse\r\nmemcpy_toio(vaddr + offset, buffer, trunk);\r\nlen -= trunk;\r\npaddr += trunk;\r\nbuffer += trunk;\r\nif (in_nmi) {\r\nghes_iounmap_nmi(vaddr);\r\nraw_spin_unlock(&ghes_ioremap_lock_nmi);\r\n} else {\r\nghes_iounmap_irq(vaddr);\r\nspin_unlock_irqrestore(&ghes_ioremap_lock_irq, flags);\r\n}\r\n}\r\n}\r\nstatic int ghes_read_estatus(struct ghes *ghes, int silent)\r\n{\r\nstruct acpi_hest_generic *g = ghes->generic;\r\nu64 buf_paddr;\r\nu32 len;\r\nint rc;\r\nrc = apei_read(&buf_paddr, &g->error_status_address);\r\nif (rc) {\r\nif (!silent && printk_ratelimit())\r\npr_warning(FW_WARN GHES_PFX\r\n"Failed to read error status block address for hardware error source: %d.\n",\r\ng->header.source_id);\r\nreturn -EIO;\r\n}\r\nif (!buf_paddr)\r\nreturn -ENOENT;\r\nghes_copy_tofrom_phys(ghes->estatus, buf_paddr,\r\nsizeof(*ghes->estatus), 1);\r\nif (!ghes->estatus->block_status)\r\nreturn -ENOENT;\r\nghes->buffer_paddr = buf_paddr;\r\nghes->flags |= GHES_TO_CLEAR;\r\nrc = -EIO;\r\nlen = apei_estatus_len(ghes->estatus);\r\nif (len < sizeof(*ghes->estatus))\r\ngoto err_read_block;\r\nif (len > ghes->generic->error_block_length)\r\ngoto err_read_block;\r\nif (apei_estatus_check_header(ghes->estatus))\r\ngoto err_read_block;\r\nghes_copy_tofrom_phys(ghes->estatus + 1,\r\nbuf_paddr + sizeof(*ghes->estatus),\r\nlen - sizeof(*ghes->estatus), 1);\r\nif (apei_estatus_check(ghes->estatus))\r\ngoto err_read_block;\r\nrc = 0;\r\nerr_read_block:\r\nif (rc && !silent && printk_ratelimit())\r\npr_warning(FW_WARN GHES_PFX\r\n"Failed to read error status block!\n");\r\nreturn rc;\r\n}\r\nstatic void ghes_clear_estatus(struct ghes *ghes)\r\n{\r\nghes->estatus->block_status = 0;\r\nif (!(ghes->flags & GHES_TO_CLEAR))\r\nreturn;\r\nghes_copy_tofrom_phys(ghes->estatus, ghes->buffer_paddr,\r\nsizeof(ghes->estatus->block_status), 0);\r\nghes->flags &= ~GHES_TO_CLEAR;\r\n}\r\nstatic void ghes_do_proc(const struct acpi_hest_generic_status *estatus)\r\n{\r\nint sev, sec_sev;\r\nstruct acpi_hest_generic_data *gdata;\r\nsev = ghes_severity(estatus->error_severity);\r\napei_estatus_for_each_section(estatus, gdata) {\r\nsec_sev = ghes_severity(gdata->error_severity);\r\nif (!uuid_le_cmp(*(uuid_le *)gdata->section_type,\r\nCPER_SEC_PLATFORM_MEM)) {\r\nstruct cper_sec_mem_err *mem_err;\r\nmem_err = (struct cper_sec_mem_err *)(gdata+1);\r\n#ifdef CONFIG_X86_MCE\r\napei_mce_report_mem_error(sev == GHES_SEV_CORRECTED,\r\nmem_err);\r\n#endif\r\n#ifdef CONFIG_ACPI_APEI_MEMORY_FAILURE\r\nif (sev == GHES_SEV_RECOVERABLE &&\r\nsec_sev == GHES_SEV_RECOVERABLE &&\r\nmem_err->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS) {\r\nunsigned long pfn;\r\npfn = mem_err->physical_addr >> PAGE_SHIFT;\r\nmemory_failure_queue(pfn, 0, 0);\r\n}\r\n#endif\r\n}\r\n#ifdef CONFIG_ACPI_APEI_PCIEAER\r\nelse if (!uuid_le_cmp(*(uuid_le *)gdata->section_type,\r\nCPER_SEC_PCIE)) {\r\nstruct cper_sec_pcie *pcie_err;\r\npcie_err = (struct cper_sec_pcie *)(gdata+1);\r\nif (sev == GHES_SEV_RECOVERABLE &&\r\nsec_sev == GHES_SEV_RECOVERABLE &&\r\npcie_err->validation_bits & CPER_PCIE_VALID_DEVICE_ID &&\r\npcie_err->validation_bits & CPER_PCIE_VALID_AER_INFO) {\r\nunsigned int devfn;\r\nint aer_severity;\r\ndevfn = PCI_DEVFN(pcie_err->device_id.device,\r\npcie_err->device_id.function);\r\naer_severity = cper_severity_to_aer(sev);\r\naer_recover_queue(pcie_err->device_id.segment,\r\npcie_err->device_id.bus,\r\ndevfn, aer_severity);\r\n}\r\n}\r\n#endif\r\n}\r\n}\r\nstatic void __ghes_print_estatus(const char *pfx,\r\nconst struct acpi_hest_generic *generic,\r\nconst struct acpi_hest_generic_status *estatus)\r\n{\r\nstatic atomic_t seqno;\r\nunsigned int curr_seqno;\r\nchar pfx_seq[64];\r\nif (pfx == NULL) {\r\nif (ghes_severity(estatus->error_severity) <=\r\nGHES_SEV_CORRECTED)\r\npfx = KERN_WARNING;\r\nelse\r\npfx = KERN_ERR;\r\n}\r\ncurr_seqno = atomic_inc_return(&seqno);\r\nsnprintf(pfx_seq, sizeof(pfx_seq), "%s{%u}" HW_ERR, pfx, curr_seqno);\r\nprintk("%s""Hardware error from APEI Generic Hardware Error Source: %d\n",\r\npfx_seq, generic->header.source_id);\r\napei_estatus_print(pfx_seq, estatus);\r\n}\r\nstatic int ghes_print_estatus(const char *pfx,\r\nconst struct acpi_hest_generic *generic,\r\nconst struct acpi_hest_generic_status *estatus)\r\n{\r\n/* Not more than 2 messages every 5 seconds */\r\nstatic DEFINE_RATELIMIT_STATE(ratelimit_corrected, 5*HZ, 2);\r\nstatic DEFINE_RATELIMIT_STATE(ratelimit_uncorrected, 5*HZ, 2);\r\nstruct ratelimit_state *ratelimit;\r\nif (ghes_severity(estatus->error_severity) <= GHES_SEV_CORRECTED)\r\nratelimit = &ratelimit_corrected;\r\nelse\r\nratelimit = &ratelimit_uncorrected;\r\nif (__ratelimit(ratelimit)) {\r\n__ghes_print_estatus(pfx, generic, estatus);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\n/*\r\n* GHES error status reporting throttle, to report more kinds of\r\n* errors, instead of just most frequently occurred errors.\r\n*/\r\nstatic int ghes_estatus_cached(struct acpi_hest_generic_status *estatus)\r\n{\r\nu32 len;\r\nint i, cached = 0;\r\nunsigned long long now;\r\nstruct ghes_estatus_cache *cache;\r\nstruct acpi_hest_generic_status *cache_estatus;\r\nlen = apei_estatus_len(estatus);\r\nrcu_read_lock();\r\nfor (i = 0; i < GHES_ESTATUS_CACHES_SIZE; i++) {\r\ncache = rcu_dereference(ghes_estatus_caches[i]);\r\nif (cache == NULL)\r\ncontinue;\r\nif (len != cache->estatus_len)\r\ncontinue;\r\ncache_estatus = GHES_ESTATUS_FROM_CACHE(cache);\r\nif (memcmp(estatus, cache_estatus, len))\r\ncontinue;\r\natomic_inc(&cache->count);\r\nnow = sched_clock();\r\nif (now - cache->time_in < GHES_ESTATUS_IN_CACHE_MAX_NSEC)\r\ncached = 1;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn cached;\r\n}\r\nstatic struct ghes_estatus_cache *ghes_estatus_cache_alloc(\r\nstruct acpi_hest_generic *generic,\r\nstruct acpi_hest_generic_status *estatus)\r\n{\r\nint alloced;\r\nu32 len, cache_len;\r\nstruct ghes_estatus_cache *cache;\r\nstruct acpi_hest_generic_status *cache_estatus;\r\nalloced = atomic_add_return(1, &ghes_estatus_cache_alloced);\r\nif (alloced > GHES_ESTATUS_CACHE_ALLOCED_MAX) {\r\natomic_dec(&ghes_estatus_cache_alloced);\r\nreturn NULL;\r\n}\r\nlen = apei_estatus_len(estatus);\r\ncache_len = GHES_ESTATUS_CACHE_LEN(len);\r\ncache = (void *)gen_pool_alloc(ghes_estatus_pool, cache_len);\r\nif (!cache) {\r\natomic_dec(&ghes_estatus_cache_alloced);\r\nreturn NULL;\r\n}\r\ncache_estatus = GHES_ESTATUS_FROM_CACHE(cache);\r\nmemcpy(cache_estatus, estatus, len);\r\ncache->estatus_len = len;\r\natomic_set(&cache->count, 0);\r\ncache->generic = generic;\r\ncache->time_in = sched_clock();\r\nreturn cache;\r\n}\r\nstatic void ghes_estatus_cache_free(struct ghes_estatus_cache *cache)\r\n{\r\nu32 len;\r\nlen = apei_estatus_len(GHES_ESTATUS_FROM_CACHE(cache));\r\nlen = GHES_ESTATUS_CACHE_LEN(len);\r\ngen_pool_free(ghes_estatus_pool, (unsigned long)cache, len);\r\natomic_dec(&ghes_estatus_cache_alloced);\r\n}\r\nstatic void ghes_estatus_cache_rcu_free(struct rcu_head *head)\r\n{\r\nstruct ghes_estatus_cache *cache;\r\ncache = container_of(head, struct ghes_estatus_cache, rcu);\r\nghes_estatus_cache_free(cache);\r\n}\r\nstatic void ghes_estatus_cache_add(\r\nstruct acpi_hest_generic *generic,\r\nstruct acpi_hest_generic_status *estatus)\r\n{\r\nint i, slot = -1, count;\r\nunsigned long long now, duration, period, max_period = 0;\r\nstruct ghes_estatus_cache *cache, *slot_cache = NULL, *new_cache;\r\nnew_cache = ghes_estatus_cache_alloc(generic, estatus);\r\nif (new_cache == NULL)\r\nreturn;\r\nrcu_read_lock();\r\nnow = sched_clock();\r\nfor (i = 0; i < GHES_ESTATUS_CACHES_SIZE; i++) {\r\ncache = rcu_dereference(ghes_estatus_caches[i]);\r\nif (cache == NULL) {\r\nslot = i;\r\nslot_cache = NULL;\r\nbreak;\r\n}\r\nduration = now - cache->time_in;\r\nif (duration >= GHES_ESTATUS_IN_CACHE_MAX_NSEC) {\r\nslot = i;\r\nslot_cache = cache;\r\nbreak;\r\n}\r\ncount = atomic_read(&cache->count);\r\nperiod = duration;\r\ndo_div(period, (count + 1));\r\nif (period > max_period) {\r\nmax_period = period;\r\nslot = i;\r\nslot_cache = cache;\r\n}\r\n}\r\n/* new_cache must be put into array after its contents are written */\r\nsmp_wmb();\r\nif (slot != -1 && cmpxchg(ghes_estatus_caches + slot,\r\nslot_cache, new_cache) == slot_cache) {\r\nif (slot_cache)\r\ncall_rcu(&slot_cache->rcu, ghes_estatus_cache_rcu_free);\r\n} else\r\nghes_estatus_cache_free(new_cache);\r\nrcu_read_unlock();\r\n}\r\nstatic int ghes_proc(struct ghes *ghes)\r\n{\r\nint rc;\r\nrc = ghes_read_estatus(ghes, 0);\r\nif (rc)\r\ngoto out;\r\nif (!ghes_estatus_cached(ghes->estatus)) {\r\nif (ghes_print_estatus(NULL, ghes->generic, ghes->estatus))\r\nghes_estatus_cache_add(ghes->generic, ghes->estatus);\r\n}\r\nghes_do_proc(ghes->estatus);\r\nout:\r\nghes_clear_estatus(ghes);\r\nreturn 0;\r\n}\r\nstatic void ghes_add_timer(struct ghes *ghes)\r\n{\r\nstruct acpi_hest_generic *g = ghes->generic;\r\nunsigned long expire;\r\nif (!g->notify.poll_interval) {\r\npr_warning(FW_WARN GHES_PFX "Poll interval is 0 for generic hardware error source: %d, disabled.\n",\r\ng->header.source_id);\r\nreturn;\r\n}\r\nexpire = jiffies + msecs_to_jiffies(g->notify.poll_interval);\r\nghes->timer.expires = round_jiffies_relative(expire);\r\nadd_timer(&ghes->timer);\r\n}\r\nstatic void ghes_poll_func(unsigned long data)\r\n{\r\nstruct ghes *ghes = (void *)data;\r\nghes_proc(ghes);\r\nif (!(ghes->flags & GHES_EXITING))\r\nghes_add_timer(ghes);\r\n}\r\nstatic irqreturn_t ghes_irq_func(int irq, void *data)\r\n{\r\nstruct ghes *ghes = data;\r\nint rc;\r\nrc = ghes_proc(ghes);\r\nif (rc)\r\nreturn IRQ_NONE;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ghes_notify_sci(struct notifier_block *this,\r\nunsigned long event, void *data)\r\n{\r\nstruct ghes *ghes;\r\nint ret = NOTIFY_DONE;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(ghes, &ghes_sci, list) {\r\nif (!ghes_proc(ghes))\r\nret = NOTIFY_OK;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic struct llist_node *llist_nodes_reverse(struct llist_node *llnode)\r\n{\r\nstruct llist_node *next, *tail = NULL;\r\nwhile (llnode) {\r\nnext = llnode->next;\r\nllnode->next = tail;\r\ntail = llnode;\r\nllnode = next;\r\n}\r\nreturn tail;\r\n}\r\nstatic void ghes_proc_in_irq(struct irq_work *irq_work)\r\n{\r\nstruct llist_node *llnode, *next;\r\nstruct ghes_estatus_node *estatus_node;\r\nstruct acpi_hest_generic *generic;\r\nstruct acpi_hest_generic_status *estatus;\r\nu32 len, node_len;\r\nllnode = llist_del_all(&ghes_estatus_llist);\r\n/*\r\n* Because the time order of estatus in list is reversed,\r\n* revert it back to proper order.\r\n*/\r\nllnode = llist_nodes_reverse(llnode);\r\nwhile (llnode) {\r\nnext = llnode->next;\r\nestatus_node = llist_entry(llnode, struct ghes_estatus_node,\r\nllnode);\r\nestatus = GHES_ESTATUS_FROM_NODE(estatus_node);\r\nlen = apei_estatus_len(estatus);\r\nnode_len = GHES_ESTATUS_NODE_LEN(len);\r\nghes_do_proc(estatus);\r\nif (!ghes_estatus_cached(estatus)) {\r\ngeneric = estatus_node->generic;\r\nif (ghes_print_estatus(NULL, generic, estatus))\r\nghes_estatus_cache_add(generic, estatus);\r\n}\r\ngen_pool_free(ghes_estatus_pool, (unsigned long)estatus_node,\r\nnode_len);\r\nllnode = next;\r\n}\r\n}\r\nstatic void ghes_print_queued_estatus(void)\r\n{\r\nstruct llist_node *llnode;\r\nstruct ghes_estatus_node *estatus_node;\r\nstruct acpi_hest_generic *generic;\r\nstruct acpi_hest_generic_status *estatus;\r\nu32 len, node_len;\r\nllnode = llist_del_all(&ghes_estatus_llist);\r\n/*\r\n* Because the time order of estatus in list is reversed,\r\n* revert it back to proper order.\r\n*/\r\nllnode = llist_nodes_reverse(llnode);\r\nwhile (llnode) {\r\nestatus_node = llist_entry(llnode, struct ghes_estatus_node,\r\nllnode);\r\nestatus = GHES_ESTATUS_FROM_NODE(estatus_node);\r\nlen = apei_estatus_len(estatus);\r\nnode_len = GHES_ESTATUS_NODE_LEN(len);\r\ngeneric = estatus_node->generic;\r\nghes_print_estatus(NULL, generic, estatus);\r\nllnode = llnode->next;\r\n}\r\n}\r\nstatic int ghes_notify_nmi(unsigned int cmd, struct pt_regs *regs)\r\n{\r\nstruct ghes *ghes, *ghes_global = NULL;\r\nint sev, sev_global = -1;\r\nint ret = NMI_DONE;\r\nraw_spin_lock(&ghes_nmi_lock);\r\nlist_for_each_entry_rcu(ghes, &ghes_nmi, list) {\r\nif (ghes_read_estatus(ghes, 1)) {\r\nghes_clear_estatus(ghes);\r\ncontinue;\r\n}\r\nsev = ghes_severity(ghes->estatus->error_severity);\r\nif (sev > sev_global) {\r\nsev_global = sev;\r\nghes_global = ghes;\r\n}\r\nret = NMI_HANDLED;\r\n}\r\nif (ret == NMI_DONE)\r\ngoto out;\r\nif (sev_global >= GHES_SEV_PANIC) {\r\noops_begin();\r\nghes_print_queued_estatus();\r\n__ghes_print_estatus(KERN_EMERG, ghes_global->generic,\r\nghes_global->estatus);\r\n/* reboot to log the error! */\r\nif (panic_timeout == 0)\r\npanic_timeout = ghes_panic_timeout;\r\npanic("Fatal hardware error!");\r\n}\r\nlist_for_each_entry_rcu(ghes, &ghes_nmi, list) {\r\n#ifdef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG\r\nu32 len, node_len;\r\nstruct ghes_estatus_node *estatus_node;\r\nstruct acpi_hest_generic_status *estatus;\r\n#endif\r\nif (!(ghes->flags & GHES_TO_CLEAR))\r\ncontinue;\r\n#ifdef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG\r\nif (ghes_estatus_cached(ghes->estatus))\r\ngoto next;\r\n/* Save estatus for further processing in IRQ context */\r\nlen = apei_estatus_len(ghes->estatus);\r\nnode_len = GHES_ESTATUS_NODE_LEN(len);\r\nestatus_node = (void *)gen_pool_alloc(ghes_estatus_pool,\r\nnode_len);\r\nif (estatus_node) {\r\nestatus_node->generic = ghes->generic;\r\nestatus = GHES_ESTATUS_FROM_NODE(estatus_node);\r\nmemcpy(estatus, ghes->estatus, len);\r\nllist_add(&estatus_node->llnode, &ghes_estatus_llist);\r\n}\r\nnext:\r\n#endif\r\nghes_clear_estatus(ghes);\r\n}\r\n#ifdef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG\r\nirq_work_queue(&ghes_proc_irq_work);\r\n#endif\r\nout:\r\nraw_spin_unlock(&ghes_nmi_lock);\r\nreturn ret;\r\n}\r\nstatic struct notifier_block ghes_notifier_sci = {\r\n.notifier_call = ghes_notify_sci,\r\n};\r\nstatic unsigned long ghes_esource_prealloc_size(\r\nconst struct acpi_hest_generic *generic)\r\n{\r\nunsigned long block_length, prealloc_records, prealloc_size;\r\nblock_length = min_t(unsigned long, generic->error_block_length,\r\nGHES_ESTATUS_MAX_SIZE);\r\nprealloc_records = max_t(unsigned long,\r\ngeneric->records_to_preallocate, 1);\r\nprealloc_size = min_t(unsigned long, block_length * prealloc_records,\r\nGHES_ESOURCE_PREALLOC_MAX_SIZE);\r\nreturn prealloc_size;\r\n}\r\nstatic int __devinit ghes_probe(struct platform_device *ghes_dev)\r\n{\r\nstruct acpi_hest_generic *generic;\r\nstruct ghes *ghes = NULL;\r\nunsigned long len;\r\nint rc = -EINVAL;\r\ngeneric = *(struct acpi_hest_generic **)ghes_dev->dev.platform_data;\r\nif (!generic->enabled)\r\nreturn -ENODEV;\r\nswitch (generic->notify.type) {\r\ncase ACPI_HEST_NOTIFY_POLLED:\r\ncase ACPI_HEST_NOTIFY_EXTERNAL:\r\ncase ACPI_HEST_NOTIFY_SCI:\r\ncase ACPI_HEST_NOTIFY_NMI:\r\nbreak;\r\ncase ACPI_HEST_NOTIFY_LOCAL:\r\npr_warning(GHES_PFX "Generic hardware error source: %d notified via local interrupt is not supported!\n",\r\ngeneric->header.source_id);\r\ngoto err;\r\ndefault:\r\npr_warning(FW_WARN GHES_PFX "Unknown notification type: %u for generic hardware error source: %d\n",\r\ngeneric->notify.type, generic->header.source_id);\r\ngoto err;\r\n}\r\nrc = -EIO;\r\nif (generic->error_block_length <\r\nsizeof(struct acpi_hest_generic_status)) {\r\npr_warning(FW_BUG GHES_PFX "Invalid error block length: %u for generic hardware error source: %d\n",\r\ngeneric->error_block_length,\r\ngeneric->header.source_id);\r\ngoto err;\r\n}\r\nghes = ghes_new(generic);\r\nif (IS_ERR(ghes)) {\r\nrc = PTR_ERR(ghes);\r\nghes = NULL;\r\ngoto err;\r\n}\r\nswitch (generic->notify.type) {\r\ncase ACPI_HEST_NOTIFY_POLLED:\r\nghes->timer.function = ghes_poll_func;\r\nghes->timer.data = (unsigned long)ghes;\r\ninit_timer_deferrable(&ghes->timer);\r\nghes_add_timer(ghes);\r\nbreak;\r\ncase ACPI_HEST_NOTIFY_EXTERNAL:\r\n/* External interrupt vector is GSI */\r\nif (acpi_gsi_to_irq(generic->notify.vector, &ghes->irq)) {\r\npr_err(GHES_PFX "Failed to map GSI to IRQ for generic hardware error source: %d\n",\r\ngeneric->header.source_id);\r\ngoto err;\r\n}\r\nif (request_irq(ghes->irq, ghes_irq_func,\r\n0, "GHES IRQ", ghes)) {\r\npr_err(GHES_PFX "Failed to register IRQ for generic hardware error source: %d\n",\r\ngeneric->header.source_id);\r\ngoto err;\r\n}\r\nbreak;\r\ncase ACPI_HEST_NOTIFY_SCI:\r\nmutex_lock(&ghes_list_mutex);\r\nif (list_empty(&ghes_sci))\r\nregister_acpi_hed_notifier(&ghes_notifier_sci);\r\nlist_add_rcu(&ghes->list, &ghes_sci);\r\nmutex_unlock(&ghes_list_mutex);\r\nbreak;\r\ncase ACPI_HEST_NOTIFY_NMI:\r\nlen = ghes_esource_prealloc_size(generic);\r\nghes_estatus_pool_expand(len);\r\nmutex_lock(&ghes_list_mutex);\r\nif (list_empty(&ghes_nmi))\r\nregister_nmi_handler(NMI_LOCAL, ghes_notify_nmi, 0,\r\n"ghes");\r\nlist_add_rcu(&ghes->list, &ghes_nmi);\r\nmutex_unlock(&ghes_list_mutex);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nplatform_set_drvdata(ghes_dev, ghes);\r\nreturn 0;\r\nerr:\r\nif (ghes) {\r\nghes_fini(ghes);\r\nkfree(ghes);\r\n}\r\nreturn rc;\r\n}\r\nstatic int __devexit ghes_remove(struct platform_device *ghes_dev)\r\n{\r\nstruct ghes *ghes;\r\nstruct acpi_hest_generic *generic;\r\nunsigned long len;\r\nghes = platform_get_drvdata(ghes_dev);\r\ngeneric = ghes->generic;\r\nghes->flags |= GHES_EXITING;\r\nswitch (generic->notify.type) {\r\ncase ACPI_HEST_NOTIFY_POLLED:\r\ndel_timer_sync(&ghes->timer);\r\nbreak;\r\ncase ACPI_HEST_NOTIFY_EXTERNAL:\r\nfree_irq(ghes->irq, ghes);\r\nbreak;\r\ncase ACPI_HEST_NOTIFY_SCI:\r\nmutex_lock(&ghes_list_mutex);\r\nlist_del_rcu(&ghes->list);\r\nif (list_empty(&ghes_sci))\r\nunregister_acpi_hed_notifier(&ghes_notifier_sci);\r\nmutex_unlock(&ghes_list_mutex);\r\nbreak;\r\ncase ACPI_HEST_NOTIFY_NMI:\r\nmutex_lock(&ghes_list_mutex);\r\nlist_del_rcu(&ghes->list);\r\nif (list_empty(&ghes_nmi))\r\nunregister_nmi_handler(NMI_LOCAL, "ghes");\r\nmutex_unlock(&ghes_list_mutex);\r\n/*\r\n* To synchronize with NMI handler, ghes can only be\r\n* freed after NMI handler finishes.\r\n*/\r\nsynchronize_rcu();\r\nlen = ghes_esource_prealloc_size(generic);\r\nghes_estatus_pool_shrink(len);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nghes_fini(ghes);\r\nkfree(ghes);\r\nplatform_set_drvdata(ghes_dev, NULL);\r\nreturn 0;\r\n}\r\nstatic struct platform_driver ghes_platform_driver = {\r\n.driver = {\r\n.name = "GHES",\r\n.owner = THIS_MODULE,\r\n},\r\n.probe = ghes_probe,\r\n.remove = ghes_remove,\r\n};\r\nstatic int __init ghes_init(void)\r\n{\r\nint rc;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nif (hest_disable) {\r\npr_info(GHES_PFX "HEST is not enabled!\n");\r\nreturn -EINVAL;\r\n}\r\nif (ghes_disable) {\r\npr_info(GHES_PFX "GHES is not enabled!\n");\r\nreturn -EINVAL;\r\n}\r\ninit_irq_work(&ghes_proc_irq_work, ghes_proc_in_irq);\r\nrc = ghes_ioremap_init();\r\nif (rc)\r\ngoto err;\r\nrc = ghes_estatus_pool_init();\r\nif (rc)\r\ngoto err_ioremap_exit;\r\nrc = ghes_estatus_pool_expand(GHES_ESTATUS_CACHE_AVG_SIZE *\r\nGHES_ESTATUS_CACHE_ALLOCED_MAX);\r\nif (rc)\r\ngoto err_pool_exit;\r\nrc = platform_driver_register(&ghes_platform_driver);\r\nif (rc)\r\ngoto err_pool_exit;\r\nrc = apei_osc_setup();\r\nif (rc == 0 && osc_sb_apei_support_acked)\r\npr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit and WHEA _OSC.\n");\r\nelse if (rc == 0 && !osc_sb_apei_support_acked)\r\npr_info(GHES_PFX "APEI firmware first mode is enabled by WHEA _OSC.\n");\r\nelse if (rc && osc_sb_apei_support_acked)\r\npr_info(GHES_PFX "APEI firmware first mode is enabled by APEI bit.\n");\r\nelse\r\npr_info(GHES_PFX "Failed to enable APEI firmware first mode.\n");\r\nreturn 0;\r\nerr_pool_exit:\r\nghes_estatus_pool_exit();\r\nerr_ioremap_exit:\r\nghes_ioremap_exit();\r\nerr:\r\nreturn rc;\r\n}\r\nstatic void __exit ghes_exit(void)\r\n{\r\nplatform_driver_unregister(&ghes_platform_driver);\r\nghes_estatus_pool_exit();\r\nghes_ioremap_exit();\r\n}\r\nmodule_init(ghes_init);\r\nmodule_exit(ghes_exit);\r\nMODULE_AUTHOR("Huang Ying");\r\nMODULE_DESCRIPTION("APEI Generic Hardware Error Source support");\r\nMODULE_LICENSE("GPL");\r\nMODULE_ALIAS("platform:GHES"
