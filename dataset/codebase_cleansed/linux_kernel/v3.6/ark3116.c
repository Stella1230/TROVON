static int is_irda(struct usb_serial *serial)\r\n{\r\nstruct usb_device *dev = serial->dev;\r\nif (le16_to_cpu(dev->descriptor.idVendor) == 0x18ec &&\r\nle16_to_cpu(dev->descriptor.idProduct) == 0x3118)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ark3116_write_reg(struct usb_serial *serial,\r\nunsigned reg, __u8 val)\r\n{\r\nint result;\r\nresult = usb_control_msg(serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\n0xfe, 0x40, val, reg,\r\nNULL, 0, ARK_TIMEOUT);\r\nreturn result;\r\n}\r\nstatic int ark3116_read_reg(struct usb_serial *serial,\r\nunsigned reg, unsigned char *buf)\r\n{\r\nint result;\r\nresult = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\n0xfe, 0xc0, 0, reg,\r\nbuf, 1, ARK_TIMEOUT);\r\nif (result < 0)\r\nreturn result;\r\nelse\r\nreturn buf[0];\r\n}\r\nstatic inline int calc_divisor(int bps)\r\n{\r\nreturn (12000000 + 2*bps) / (4*bps);\r\n}\r\nstatic int ark3116_attach(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port = serial->port[0];\r\nstruct ark3116_private *priv;\r\nif ((serial->num_bulk_in == 0) ||\r\n(serial->num_bulk_out == 0) ||\r\n(serial->num_interrupt_in == 0)) {\r\ndev_err(&serial->dev->dev,\r\n"%s - missing endpoint - "\r\n"bulk in: %d, bulk out: %d, int in %d\n",\r\nKBUILD_MODNAME,\r\nserial->num_bulk_in,\r\nserial->num_bulk_out,\r\nserial->num_interrupt_in);\r\nreturn -EINVAL;\r\n}\r\npriv = kzalloc(sizeof(struct ark3116_private),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&priv->delta_msr_wait);\r\nmutex_init(&priv->hw_lock);\r\nspin_lock_init(&priv->status_lock);\r\npriv->irda = is_irda(serial);\r\nusb_set_serial_port_data(port, priv);\r\nark3116_write_reg(serial, UART_IER, 0);\r\nark3116_write_reg(serial, UART_FCR, 0);\r\npriv->hcr = 0;\r\nark3116_write_reg(serial, 0x8 , 0);\r\npriv->mcr = 0;\r\nark3116_write_reg(serial, UART_MCR, 0);\r\nif (!(priv->irda)) {\r\nark3116_write_reg(serial, 0xb , 0);\r\n} else {\r\nark3116_write_reg(serial, 0xb , 1);\r\nark3116_write_reg(serial, 0xc , 0);\r\nark3116_write_reg(serial, 0xd , 0x41);\r\nark3116_write_reg(serial, 0xa , 1);\r\n}\r\nark3116_write_reg(serial, UART_LCR, UART_LCR_DLAB);\r\npriv->quot = calc_divisor(9600);\r\nark3116_write_reg(serial, UART_DLL, priv->quot & 0xff);\r\nark3116_write_reg(serial, UART_DLM, (priv->quot>>8) & 0xff);\r\npriv->lcr = UART_LCR_WLEN8;\r\nark3116_write_reg(serial, UART_LCR, UART_LCR_WLEN8);\r\nark3116_write_reg(serial, 0xe, 0);\r\nif (priv->irda)\r\nark3116_write_reg(serial, 0x9, 0);\r\ndev_info(&serial->dev->dev,\r\n"%s using %s mode\n",\r\nKBUILD_MODNAME,\r\npriv->irda ? "IrDA" : "RS232");\r\nreturn 0;\r\n}\r\nstatic void ark3116_release(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port = serial->port[0];\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nusb_set_serial_port_data(port, NULL);\r\nmutex_destroy(&priv->hw_lock);\r\nkfree(priv);\r\n}\r\nstatic void ark3116_init_termios(struct tty_struct *tty)\r\n{\r\nstruct ktermios *termios = tty->termios;\r\n*termios = tty_std_termios;\r\ntermios->c_cflag = B9600 | CS8\r\n| CREAD | HUPCL | CLOCAL;\r\ntermios->c_ispeed = 9600;\r\ntermios->c_ospeed = 9600;\r\n}\r\nstatic void ark3116_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nstruct ktermios *termios = tty->termios;\r\nunsigned int cflag = termios->c_cflag;\r\nint bps = tty_get_baud_rate(tty);\r\nint quot;\r\n__u8 lcr, hcr, eval;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nlcr = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nlcr = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nlcr = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nlcr = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (cflag & CSTOPB)\r\nlcr |= UART_LCR_STOP;\r\nif (cflag & PARENB)\r\nlcr |= UART_LCR_PARITY;\r\nif (!(cflag & PARODD))\r\nlcr |= UART_LCR_EPAR;\r\n#ifdef CMSPAR\r\nif (cflag & CMSPAR)\r\nlcr |= UART_LCR_SPAR;\r\n#endif\r\nhcr = (cflag & CRTSCTS) ? 0x03 : 0x00;\r\ndev_dbg(&port->dev, "%s - setting bps to %d\n", __func__, bps);\r\neval = 0;\r\nswitch (bps) {\r\ncase 0:\r\nquot = calc_divisor(9600);\r\nbreak;\r\ndefault:\r\nif ((bps < 75) || (bps > 3000000))\r\nbps = 9600;\r\nquot = calc_divisor(bps);\r\nbreak;\r\ncase 460800:\r\neval = 1;\r\nquot = calc_divisor(bps);\r\nbreak;\r\ncase 921600:\r\neval = 2;\r\nquot = calc_divisor(bps);\r\nbreak;\r\n}\r\nmutex_lock(&priv->hw_lock);\r\nlcr |= (priv->lcr & UART_LCR_SBC);\r\ndev_dbg(&port->dev, "%s - setting hcr:0x%02x,lcr:0x%02x,quot:%d\n",\r\n__func__, hcr, lcr, quot);\r\nif (priv->hcr != hcr) {\r\npriv->hcr = hcr;\r\nark3116_write_reg(serial, 0x8, hcr);\r\n}\r\nif (priv->quot != quot) {\r\npriv->quot = quot;\r\npriv->lcr = lcr;\r\nark3116_write_reg(serial, UART_FCR, 0);\r\nark3116_write_reg(serial, UART_LCR,\r\nlcr|UART_LCR_DLAB);\r\nark3116_write_reg(serial, UART_DLL, quot & 0xff);\r\nark3116_write_reg(serial, UART_DLM, (quot>>8) & 0xff);\r\nark3116_write_reg(serial, UART_LCR, lcr);\r\nark3116_write_reg(serial, 0xe, eval);\r\nark3116_write_reg(serial, UART_FCR, UART_FCR_DMA_SELECT);\r\n} else if (priv->lcr != lcr) {\r\npriv->lcr = lcr;\r\nark3116_write_reg(serial, UART_LCR, lcr);\r\n}\r\nmutex_unlock(&priv->hw_lock);\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\ndev_warn(&serial->dev->dev,\r\n"%s: don't know how to do software flow control\n",\r\nKBUILD_MODNAME);\r\n}\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, bps, bps);\r\n}\r\nstatic void ark3116_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nif (serial->dev) {\r\nark3116_write_reg(serial, UART_FCR, 0);\r\nark3116_write_reg(serial, UART_IER, 0);\r\nusb_serial_generic_close(port);\r\nif (serial->num_interrupt_in)\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\n}\r\nstatic int ark3116_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial = port->serial;\r\nunsigned char *buf;\r\nint result;\r\nbuf = kmalloc(1, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nresult = usb_serial_generic_open(tty, port);\r\nif (result) {\r\ndev_dbg(&port->dev,\r\n"%s - usb_serial_generic_open failed: %d\n",\r\n__func__, result);\r\ngoto err_out;\r\n}\r\nark3116_read_reg(serial, UART_RX, buf);\r\npriv->msr = ark3116_read_reg(serial, UART_MSR, buf);\r\npriv->lsr = ark3116_read_reg(serial, UART_LSR, buf);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev, "submit irq_in urb failed %d\n",\r\nresult);\r\nark3116_close(port);\r\ngoto err_out;\r\n}\r\nark3116_write_reg(port->serial, UART_IER, UART_IER_MSI|UART_IER_RLSI);\r\nark3116_write_reg(port->serial, UART_FCR, UART_FCR_DMA_SELECT);\r\nif (tty)\r\nark3116_set_termios(tty, port, NULL);\r\nerr_out:\r\nkfree(buf);\r\nreturn result;\r\n}\r\nstatic int ark3116_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nstruct async_icount cnow = priv->icount;\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int ark3116_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nstruct serial_struct serstruct;\r\nvoid __user *user_arg = (void __user *)arg;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmemset(&serstruct, 0, sizeof(serstruct));\r\nserstruct.type = PORT_16654;\r\nserstruct.line = port->serial->minor;\r\nserstruct.port = port->number;\r\nserstruct.custom_divisor = 0;\r\nserstruct.baud_base = 460800;\r\nif (copy_to_user(user_arg, &serstruct, sizeof(serstruct)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TIOCSSERIAL:\r\nif (copy_from_user(&serstruct, user_arg, sizeof(serstruct)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TIOCMIWAIT:\r\nfor (;;) {\r\nstruct async_icount prev = priv->icount;\r\ninterruptible_sleep_on(&priv->delta_msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nif ((prev.rng == priv->icount.rng) &&\r\n(prev.dsr == priv->icount.dsr) &&\r\n(prev.dcd == priv->icount.dcd) &&\r\n(prev.cts == priv->icount.cts))\r\nreturn -EIO;\r\nif ((arg & TIOCM_RNG &&\r\n(prev.rng != priv->icount.rng)) ||\r\n(arg & TIOCM_DSR &&\r\n(prev.dsr != priv->icount.dsr)) ||\r\n(arg & TIOCM_CD &&\r\n(prev.dcd != priv->icount.dcd)) ||\r\n(arg & TIOCM_CTS &&\r\n(prev.cts != priv->icount.cts)))\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int ark3116_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\n__u32 status;\r\n__u32 ctrl;\r\nunsigned long flags;\r\nmutex_lock(&priv->hw_lock);\r\nctrl = priv->mcr;\r\nmutex_unlock(&priv->hw_lock);\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\nstatus = priv->msr;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nreturn (status & UART_MSR_DSR ? TIOCM_DSR : 0) |\r\n(status & UART_MSR_CTS ? TIOCM_CTS : 0) |\r\n(status & UART_MSR_RI ? TIOCM_RI : 0) |\r\n(status & UART_MSR_DCD ? TIOCM_CD : 0) |\r\n(ctrl & UART_MCR_DTR ? TIOCM_DTR : 0) |\r\n(ctrl & UART_MCR_RTS ? TIOCM_RTS : 0) |\r\n(ctrl & UART_MCR_OUT1 ? TIOCM_OUT1 : 0) |\r\n(ctrl & UART_MCR_OUT2 ? TIOCM_OUT2 : 0);\r\n}\r\nstatic int ark3116_tiocmset(struct tty_struct *tty,\r\nunsigned set, unsigned clr)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nmutex_lock(&priv->hw_lock);\r\nif (set & TIOCM_RTS)\r\npriv->mcr |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\npriv->mcr |= UART_MCR_DTR;\r\nif (set & TIOCM_OUT1)\r\npriv->mcr |= UART_MCR_OUT1;\r\nif (set & TIOCM_OUT2)\r\npriv->mcr |= UART_MCR_OUT2;\r\nif (clr & TIOCM_RTS)\r\npriv->mcr &= ~UART_MCR_RTS;\r\nif (clr & TIOCM_DTR)\r\npriv->mcr &= ~UART_MCR_DTR;\r\nif (clr & TIOCM_OUT1)\r\npriv->mcr &= ~UART_MCR_OUT1;\r\nif (clr & TIOCM_OUT2)\r\npriv->mcr &= ~UART_MCR_OUT2;\r\nark3116_write_reg(port->serial, UART_MCR, priv->mcr);\r\nmutex_unlock(&priv->hw_lock);\r\nreturn 0;\r\n}\r\nstatic void ark3116_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nmutex_lock(&priv->hw_lock);\r\nif (break_state)\r\npriv->lcr |= UART_LCR_SBC;\r\nelse\r\npriv->lcr &= ~UART_LCR_SBC;\r\nark3116_write_reg(port->serial, UART_LCR, priv->lcr);\r\nmutex_unlock(&priv->hw_lock);\r\n}\r\nstatic void ark3116_update_msr(struct usb_serial_port *port, __u8 msr)\r\n{\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\npriv->msr = msr;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nif (msr & UART_MSR_ANY_DELTA) {\r\nif (msr & UART_MSR_DCTS)\r\npriv->icount.cts++;\r\nif (msr & UART_MSR_DDSR)\r\npriv->icount.dsr++;\r\nif (msr & UART_MSR_DDCD)\r\npriv->icount.dcd++;\r\nif (msr & UART_MSR_TERI)\r\npriv->icount.rng++;\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\n}\r\n}\r\nstatic void ark3116_update_lsr(struct usb_serial_port *port, __u8 lsr)\r\n{\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\npriv->lsr |= lsr;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nif (lsr&UART_LSR_BRK_ERROR_BITS) {\r\nif (lsr & UART_LSR_BI)\r\npriv->icount.brk++;\r\nif (lsr & UART_LSR_FE)\r\npriv->icount.frame++;\r\nif (lsr & UART_LSR_PE)\r\npriv->icount.parity++;\r\nif (lsr & UART_LSR_OE)\r\npriv->icount.overrun++;\r\n}\r\n}\r\nstatic void ark3116_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nint status = urb->status;\r\nconst __u8 *data = urb->transfer_buffer;\r\nint result;\r\nswitch (status) {\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\nbreak;\r\ncase 0:\r\nif ((urb->actual_length == 4) && (data[0] == 0xe8)) {\r\nconst __u8 id = data[1]&UART_IIR_ID;\r\ndev_dbg(&port->dev, "%s: iir=%02x\n", __func__, data[1]);\r\nif (id == UART_IIR_MSI) {\r\ndev_dbg(&port->dev, "%s: msr=%02x\n",\r\n__func__, data[3]);\r\nark3116_update_msr(port, data[3]);\r\nbreak;\r\n} else if (id == UART_IIR_RLSI) {\r\ndev_dbg(&port->dev, "%s: lsr=%02x\n",\r\n__func__, data[2]);\r\nark3116_update_lsr(port, data[2]);\r\nbreak;\r\n}\r\n}\r\nusb_serial_debug_data(debug, &port->dev,\r\n__func__,\r\nurb->actual_length,\r\nurb->transfer_buffer);\r\nbreak;\r\n}\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&urb->dev->dev,\r\n"%s - Error %d submitting interrupt urb\n",\r\n__func__, result);\r\n}\r\nstatic void ark3116_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct ark3116_private *priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nchar tty_flag = TTY_NORMAL;\r\nunsigned long flags;\r\n__u32 lsr;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\nlsr = priv->lsr;\r\npriv->lsr &= ~UART_LSR_BRK_ERROR_BITS;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nif (!urb->actual_length)\r\nreturn;\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn;\r\nif (lsr & UART_LSR_BRK_ERROR_BITS) {\r\nif (lsr & UART_LSR_BI)\r\ntty_flag = TTY_BREAK;\r\nelse if (lsr & UART_LSR_PE)\r\ntty_flag = TTY_PARITY;\r\nelse if (lsr & UART_LSR_FE)\r\ntty_flag = TTY_FRAME;\r\nif (lsr & UART_LSR_OE)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\n}\r\ntty_insert_flip_string_fixed_flag(tty, data, tty_flag,\r\nurb->actual_length);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}
