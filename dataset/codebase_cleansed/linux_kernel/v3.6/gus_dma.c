static void snd_gf1_dma_ack(struct snd_gus_card * gus)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_DRAM_DMA_CONTROL, 0x00);\r\nsnd_gf1_look8(gus, SNDRV_GF1_GB_DRAM_DMA_CONTROL);\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\n}\r\nstatic void snd_gf1_dma_program(struct snd_gus_card * gus,\r\nunsigned int addr,\r\nunsigned long buf_addr,\r\nunsigned int count,\r\nunsigned int cmd)\r\n{\r\nunsigned long flags;\r\nunsigned int address;\r\nunsigned char dma_cmd;\r\nunsigned int address_high;\r\nsnd_printdd("dma_transfer: addr=0x%x, buf=0x%lx, count=0x%x\n",\r\naddr, buf_addr, count);\r\nif (gus->gf1.dma1 > 3) {\r\nif (gus->gf1.enh_mode) {\r\naddress = addr >> 1;\r\n} else {\r\nif (addr & 0x1f) {\r\nsnd_printd("snd_gf1_dma_transfer: unaligned address (0x%x)?\n", addr);\r\nreturn;\r\n}\r\naddress = (addr & 0x000c0000) | ((addr & 0x0003ffff) >> 1);\r\n}\r\n} else {\r\naddress = addr;\r\n}\r\ndma_cmd = SNDRV_GF1_DMA_ENABLE | (unsigned short) cmd;\r\n#if 0\r\ndma_cmd |= 0x08;\r\n#endif\r\nif (dma_cmd & SNDRV_GF1_DMA_16BIT) {\r\ncount++;\r\ncount &= ~1;\r\n}\r\nif (gus->gf1.dma1 > 3) {\r\ndma_cmd |= SNDRV_GF1_DMA_WIDTH16;\r\ncount++;\r\ncount &= ~1;\r\n}\r\nsnd_gf1_dma_ack(gus);\r\nsnd_dma_program(gus->gf1.dma1, buf_addr, count, dma_cmd & SNDRV_GF1_DMA_READ ? DMA_MODE_READ : DMA_MODE_WRITE);\r\n#if 0\r\nsnd_printk(KERN_DEBUG "address = 0x%x, count = 0x%x, dma_cmd = 0x%x\n",\r\naddress << 1, count, dma_cmd);\r\n#endif\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\nif (gus->gf1.enh_mode) {\r\naddress_high = ((address >> 16) & 0x000000f0) | (address & 0x0000000f);\r\nsnd_gf1_write16(gus, SNDRV_GF1_GW_DRAM_DMA_LOW, (unsigned short) (address >> 4));\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_DRAM_DMA_HIGH, (unsigned char) address_high);\r\n} else\r\nsnd_gf1_write16(gus, SNDRV_GF1_GW_DRAM_DMA_LOW, (unsigned short) (address >> 4));\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_DRAM_DMA_CONTROL, dma_cmd);\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\n}\r\nstatic struct snd_gf1_dma_block *snd_gf1_dma_next_block(struct snd_gus_card * gus)\r\n{\r\nstruct snd_gf1_dma_block *block;\r\nif (gus->gf1.dma_data_pcm) {\r\nblock = gus->gf1.dma_data_pcm;\r\nif (gus->gf1.dma_data_pcm_last == block) {\r\ngus->gf1.dma_data_pcm =\r\ngus->gf1.dma_data_pcm_last = NULL;\r\n} else {\r\ngus->gf1.dma_data_pcm = block->next;\r\n}\r\n} else if (gus->gf1.dma_data_synth) {\r\nblock = gus->gf1.dma_data_synth;\r\nif (gus->gf1.dma_data_synth_last == block) {\r\ngus->gf1.dma_data_synth =\r\ngus->gf1.dma_data_synth_last = NULL;\r\n} else {\r\ngus->gf1.dma_data_synth = block->next;\r\n}\r\n} else {\r\nblock = NULL;\r\n}\r\nif (block) {\r\ngus->gf1.dma_ack = block->ack;\r\ngus->gf1.dma_private_data = block->private_data;\r\n}\r\nreturn block;\r\n}\r\nstatic void snd_gf1_dma_interrupt(struct snd_gus_card * gus)\r\n{\r\nstruct snd_gf1_dma_block *block;\r\nsnd_gf1_dma_ack(gus);\r\nif (gus->gf1.dma_ack)\r\ngus->gf1.dma_ack(gus, gus->gf1.dma_private_data);\r\nspin_lock(&gus->dma_lock);\r\nif (gus->gf1.dma_data_pcm == NULL &&\r\ngus->gf1.dma_data_synth == NULL) {\r\ngus->gf1.dma_ack = NULL;\r\ngus->gf1.dma_flags &= ~SNDRV_GF1_DMA_TRIGGER;\r\nspin_unlock(&gus->dma_lock);\r\nreturn;\r\n}\r\nblock = snd_gf1_dma_next_block(gus);\r\nspin_unlock(&gus->dma_lock);\r\nsnd_gf1_dma_program(gus, block->addr, block->buf_addr, block->count, (unsigned short) block->cmd);\r\nkfree(block);\r\n#if 0\r\nsnd_printd(KERN_DEBUG "program dma (IRQ) - "\r\n"addr = 0x%x, buffer = 0x%lx, count = 0x%x, cmd = 0x%x\n",\r\nblock->addr, block->buf_addr, block->count, block->cmd);\r\n#endif\r\n}\r\nint snd_gf1_dma_init(struct snd_gus_card * gus)\r\n{\r\nmutex_lock(&gus->dma_mutex);\r\ngus->gf1.dma_shared++;\r\nif (gus->gf1.dma_shared > 1) {\r\nmutex_unlock(&gus->dma_mutex);\r\nreturn 0;\r\n}\r\ngus->gf1.interrupt_handler_dma_write = snd_gf1_dma_interrupt;\r\ngus->gf1.dma_data_pcm =\r\ngus->gf1.dma_data_pcm_last =\r\ngus->gf1.dma_data_synth =\r\ngus->gf1.dma_data_synth_last = NULL;\r\nmutex_unlock(&gus->dma_mutex);\r\nreturn 0;\r\n}\r\nint snd_gf1_dma_done(struct snd_gus_card * gus)\r\n{\r\nstruct snd_gf1_dma_block *block;\r\nmutex_lock(&gus->dma_mutex);\r\ngus->gf1.dma_shared--;\r\nif (!gus->gf1.dma_shared) {\r\nsnd_dma_disable(gus->gf1.dma1);\r\nsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_DMA_WRITE);\r\nsnd_gf1_dma_ack(gus);\r\nwhile ((block = gus->gf1.dma_data_pcm)) {\r\ngus->gf1.dma_data_pcm = block->next;\r\nkfree(block);\r\n}\r\nwhile ((block = gus->gf1.dma_data_synth)) {\r\ngus->gf1.dma_data_synth = block->next;\r\nkfree(block);\r\n}\r\ngus->gf1.dma_data_pcm_last =\r\ngus->gf1.dma_data_synth_last = NULL;\r\n}\r\nmutex_unlock(&gus->dma_mutex);\r\nreturn 0;\r\n}\r\nint snd_gf1_dma_transfer_block(struct snd_gus_card * gus,\r\nstruct snd_gf1_dma_block * __block,\r\nint atomic,\r\nint synth)\r\n{\r\nunsigned long flags;\r\nstruct snd_gf1_dma_block *block;\r\nblock = kmalloc(sizeof(*block), atomic ? GFP_ATOMIC : GFP_KERNEL);\r\nif (block == NULL) {\r\nsnd_printk(KERN_ERR "gf1: DMA transfer failure; not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*block = *__block;\r\nblock->next = NULL;\r\nsnd_printdd("addr = 0x%x, buffer = 0x%lx, count = 0x%x, cmd = 0x%x\n",\r\nblock->addr, (long) block->buffer, block->count,\r\nblock->cmd);\r\nsnd_printdd("gus->gf1.dma_data_pcm_last = 0x%lx\n",\r\n(long)gus->gf1.dma_data_pcm_last);\r\nsnd_printdd("gus->gf1.dma_data_pcm = 0x%lx\n",\r\n(long)gus->gf1.dma_data_pcm);\r\nspin_lock_irqsave(&gus->dma_lock, flags);\r\nif (synth) {\r\nif (gus->gf1.dma_data_synth_last) {\r\ngus->gf1.dma_data_synth_last->next = block;\r\ngus->gf1.dma_data_synth_last = block;\r\n} else {\r\ngus->gf1.dma_data_synth =\r\ngus->gf1.dma_data_synth_last = block;\r\n}\r\n} else {\r\nif (gus->gf1.dma_data_pcm_last) {\r\ngus->gf1.dma_data_pcm_last->next = block;\r\ngus->gf1.dma_data_pcm_last = block;\r\n} else {\r\ngus->gf1.dma_data_pcm =\r\ngus->gf1.dma_data_pcm_last = block;\r\n}\r\n}\r\nif (!(gus->gf1.dma_flags & SNDRV_GF1_DMA_TRIGGER)) {\r\ngus->gf1.dma_flags |= SNDRV_GF1_DMA_TRIGGER;\r\nblock = snd_gf1_dma_next_block(gus);\r\nspin_unlock_irqrestore(&gus->dma_lock, flags);\r\nif (block == NULL)\r\nreturn 0;\r\nsnd_gf1_dma_program(gus, block->addr, block->buf_addr, block->count, (unsigned short) block->cmd);\r\nkfree(block);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&gus->dma_lock, flags);\r\nreturn 0;\r\n}
