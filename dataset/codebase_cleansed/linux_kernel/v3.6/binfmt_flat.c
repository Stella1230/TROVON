static int flat_core_dump(struct coredump_params *cprm)\r\n{\r\nprintk("Process %s:%d received signr %d and should have core dumped\n",\r\ncurrent->comm, current->pid, (int) cprm->signr);\r\nreturn(1);\r\n}\r\nstatic unsigned long create_flat_tables(\r\nunsigned long pp,\r\nstruct linux_binprm * bprm)\r\n{\r\nunsigned long *argv,*envp;\r\nunsigned long * sp;\r\nchar * p = (char*)pp;\r\nint argc = bprm->argc;\r\nint envc = bprm->envc;\r\nchar uninitialized_var(dummy);\r\nsp = (unsigned long *)p;\r\nsp -= (envc + argc + 2) + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\r\nsp = (unsigned long *) ((unsigned long)sp & -FLAT_STACK_ALIGN);\r\nargv = sp + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\r\nenvp = argv + (argc + 1);\r\nif (flat_argvp_envp_on_stack()) {\r\nput_user((unsigned long) envp, sp + 2);\r\nput_user((unsigned long) argv, sp + 1);\r\n}\r\nput_user(argc, sp);\r\ncurrent->mm->arg_start = (unsigned long) p;\r\nwhile (argc-->0) {\r\nput_user((unsigned long) p, argv++);\r\ndo {\r\nget_user(dummy, p); p++;\r\n} while (dummy);\r\n}\r\nput_user((unsigned long) NULL, argv);\r\ncurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\r\nwhile (envc-->0) {\r\nput_user((unsigned long)p, envp); envp++;\r\ndo {\r\nget_user(dummy, p); p++;\r\n} while (dummy);\r\n}\r\nput_user((unsigned long) NULL, envp);\r\ncurrent->mm->env_end = (unsigned long) p;\r\nreturn (unsigned long)sp;\r\n}\r\nstatic int decompress_exec(\r\nstruct linux_binprm *bprm,\r\nunsigned long offset,\r\nchar *dst,\r\nlong len,\r\nint fd)\r\n{\r\nunsigned char *buf;\r\nz_stream strm;\r\nloff_t fpos;\r\nint ret, retval;\r\nDBG_FLT("decompress_exec(offset=%x,buf=%x,len=%x)\n",(int)offset, (int)dst, (int)len);\r\nmemset(&strm, 0, sizeof(strm));\r\nstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\r\nif (strm.workspace == NULL) {\r\nDBG_FLT("binfmt_flat: no memory for decompress workspace\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\r\nif (buf == NULL) {\r\nDBG_FLT("binfmt_flat: no memory for read buffer\n");\r\nretval = -ENOMEM;\r\ngoto out_free;\r\n}\r\nfpos = offset;\r\nret = bprm->file->f_op->read(bprm->file, buf, LBUFSIZE, &fpos);\r\nstrm.next_in = buf;\r\nstrm.avail_in = ret;\r\nstrm.total_in = 0;\r\nretval = -ENOEXEC;\r\nif (ret < 10) {\r\nDBG_FLT("binfmt_flat: file too small?\n");\r\ngoto out_free_buf;\r\n}\r\nif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\r\nDBG_FLT("binfmt_flat: unknown compression magic?\n");\r\ngoto out_free_buf;\r\n}\r\nif (buf[2] != 8) {\r\nDBG_FLT("binfmt_flat: unknown compression method?\n");\r\ngoto out_free_buf;\r\n}\r\nif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\r\n(buf[3] & RESERVED)) {\r\nDBG_FLT("binfmt_flat: unknown flags?\n");\r\ngoto out_free_buf;\r\n}\r\nret = 10;\r\nif (buf[3] & EXTRA_FIELD) {\r\nret += 2 + buf[10] + (buf[11] << 8);\r\nif (unlikely(LBUFSIZE <= ret)) {\r\nDBG_FLT("binfmt_flat: buffer overflow (EXTRA)?\n");\r\ngoto out_free_buf;\r\n}\r\n}\r\nif (buf[3] & ORIG_NAME) {\r\nwhile (ret < LBUFSIZE && buf[ret++] != 0)\r\n;\r\nif (unlikely(LBUFSIZE == ret)) {\r\nDBG_FLT("binfmt_flat: buffer overflow (ORIG_NAME)?\n");\r\ngoto out_free_buf;\r\n}\r\n}\r\nif (buf[3] & COMMENT) {\r\nwhile (ret < LBUFSIZE && buf[ret++] != 0)\r\n;\r\nif (unlikely(LBUFSIZE == ret)) {\r\nDBG_FLT("binfmt_flat: buffer overflow (COMMENT)?\n");\r\ngoto out_free_buf;\r\n}\r\n}\r\nstrm.next_in += ret;\r\nstrm.avail_in -= ret;\r\nstrm.next_out = dst;\r\nstrm.avail_out = len;\r\nstrm.total_out = 0;\r\nif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\r\nDBG_FLT("binfmt_flat: zlib init failed?\n");\r\ngoto out_free_buf;\r\n}\r\nwhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\r\nret = bprm->file->f_op->read(bprm->file, buf, LBUFSIZE, &fpos);\r\nif (ret <= 0)\r\nbreak;\r\nlen -= ret;\r\nstrm.next_in = buf;\r\nstrm.avail_in = ret;\r\nstrm.total_in = 0;\r\n}\r\nif (ret < 0) {\r\nDBG_FLT("binfmt_flat: decompression failed (%d), %s\n",\r\nret, strm.msg);\r\ngoto out_zlib;\r\n}\r\nretval = 0;\r\nout_zlib:\r\nzlib_inflateEnd(&strm);\r\nout_free_buf:\r\nkfree(buf);\r\nout_free:\r\nkfree(strm.workspace);\r\nreturn retval;\r\n}\r\nstatic unsigned long\r\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\r\n{\r\nunsigned long addr;\r\nint id;\r\nunsigned long start_brk;\r\nunsigned long start_data;\r\nunsigned long text_len;\r\nunsigned long start_code;\r\n#ifdef CONFIG_BINFMT_SHARED_FLAT\r\nif (r == 0)\r\nid = curid;\r\nelse {\r\nid = (r >> 24) & 0xff;\r\nr &= 0x00ffffff;\r\n}\r\nif (id >= MAX_SHARED_LIBS) {\r\nprintk("BINFMT_FLAT: reference 0x%x to shared library %d",\r\n(unsigned) r, id);\r\ngoto failed;\r\n}\r\nif (curid != id) {\r\nif (internalp) {\r\nprintk("BINFMT_FLAT: reloc address 0x%x not in same module "\r\n"(%d != %d)", (unsigned) r, curid, id);\r\ngoto failed;\r\n} else if ( ! p->lib_list[id].loaded &&\r\nIS_ERR_VALUE(load_flat_shared_library(id, p))) {\r\nprintk("BINFMT_FLAT: failed to load library %d", id);\r\ngoto failed;\r\n}\r\nif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\r\np->lib_list[curid].build_date < p->lib_list[id].build_date) {\r\nprintk("BINFMT_FLAT: library %d is younger than %d", id, curid);\r\ngoto failed;\r\n}\r\n}\r\n#else\r\nid = 0;\r\n#endif\r\nstart_brk = p->lib_list[id].start_brk;\r\nstart_data = p->lib_list[id].start_data;\r\nstart_code = p->lib_list[id].start_code;\r\ntext_len = p->lib_list[id].text_len;\r\nif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\r\nprintk("BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x/0x%x)",\r\n(int) r,(int)(start_brk-start_data+text_len),(int)text_len);\r\ngoto failed;\r\n}\r\nif (r < text_len)\r\naddr = r + start_code;\r\nelse\r\naddr = r - text_len + start_data;\r\nreturn(addr);\r\nfailed:\r\nprintk(", killing %s!\n", current->comm);\r\nsend_sig(SIGSEGV, current, 0);\r\nreturn RELOC_FAILED;\r\n}\r\nvoid old_reloc(unsigned long rl)\r\n{\r\n#ifdef DEBUG\r\nchar *segment[] = { "TEXT", "DATA", "BSS", "*UNKNOWN*" };\r\n#endif\r\nflat_v2_reloc_t r;\r\nunsigned long *ptr;\r\nr.value = rl;\r\n#if defined(CONFIG_COLDFIRE)\r\nptr = (unsigned long *) (current->mm->start_code + r.reloc.offset);\r\n#else\r\nptr = (unsigned long *) (current->mm->start_data + r.reloc.offset);\r\n#endif\r\n#ifdef DEBUG\r\nprintk("Relocation of variable at DATASEG+%x "\r\n"(address %p, currently %x) into segment %s\n",\r\nr.reloc.offset, ptr, (int)*ptr, segment[r.reloc.type]);\r\n#endif\r\nswitch (r.reloc.type) {\r\ncase OLD_FLAT_RELOC_TYPE_TEXT:\r\n*ptr += current->mm->start_code;\r\nbreak;\r\ncase OLD_FLAT_RELOC_TYPE_DATA:\r\n*ptr += current->mm->start_data;\r\nbreak;\r\ncase OLD_FLAT_RELOC_TYPE_BSS:\r\n*ptr += current->mm->end_data;\r\nbreak;\r\ndefault:\r\nprintk("BINFMT_FLAT: Unknown relocation type=%x\n", r.reloc.type);\r\nbreak;\r\n}\r\n#ifdef DEBUG\r\nprintk("Relocation became %x\n", (int)*ptr);\r\n#endif\r\n}\r\nstatic int load_flat_file(struct linux_binprm * bprm,\r\nstruct lib_info *libinfo, int id, unsigned long *extra_stack)\r\n{\r\nstruct flat_hdr * hdr;\r\nunsigned long textpos = 0, datapos = 0, result;\r\nunsigned long realdatastart = 0;\r\nunsigned long text_len, data_len, bss_len, stack_len, flags;\r\nunsigned long len, memp = 0;\r\nunsigned long memp_size, extra, rlim;\r\nunsigned long *reloc = 0, *rp;\r\nstruct inode *inode;\r\nint i, rev, relocs = 0;\r\nloff_t fpos;\r\nunsigned long start_code, end_code;\r\nint ret;\r\nhdr = ((struct flat_hdr *) bprm->buf);\r\ninode = bprm->file->f_path.dentry->d_inode;\r\ntext_len = ntohl(hdr->data_start);\r\ndata_len = ntohl(hdr->data_end) - ntohl(hdr->data_start);\r\nbss_len = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\r\nstack_len = ntohl(hdr->stack_size);\r\nif (extra_stack) {\r\nstack_len += *extra_stack;\r\n*extra_stack = stack_len;\r\n}\r\nrelocs = ntohl(hdr->reloc_count);\r\nflags = ntohl(hdr->flags);\r\nrev = ntohl(hdr->rev);\r\nif (strncmp(hdr->magic, "bFLT", 4)) {\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nif (flags & FLAT_FLAG_KTRACE)\r\nprintk("BINFMT_FLAT: Loading file: %s\n", bprm->filename);\r\nif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\r\nprintk("BINFMT_FLAT: bad flat file version 0x%x (supported "\r\n"0x%lx and 0x%lx)\n",\r\nrev, FLAT_VERSION, OLD_FLAT_VERSION);\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nif (rev == OLD_FLAT_VERSION && id != 0) {\r\nprintk("BINFMT_FLAT: shared libraries are not available before rev 0x%x\n",\r\n(int) FLAT_VERSION);\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\r\nflags = FLAT_FLAG_RAM;\r\n#ifndef CONFIG_BINFMT_ZFLAT\r\nif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\r\nprintk("Support for ZFLAT executables is not enabled.\n");\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\n#endif\r\nrlim = rlimit(RLIMIT_DATA);\r\nif (rlim >= RLIM_INFINITY)\r\nrlim = ~0;\r\nif (data_len + bss_len > rlim) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (id == 0) {\r\nresult = flush_old_exec(bprm);\r\nif (result) {\r\nret = result;\r\ngoto err;\r\n}\r\nset_personality(PER_LINUX_32BIT);\r\nsetup_new_exec(bprm);\r\n}\r\nextra = max_t(unsigned long, bss_len + stack_len,\r\nrelocs * sizeof(unsigned long));\r\nif ((flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP)) == 0) {\r\nDBG_FLT("BINFMT_FLAT: ROM mapping of file (we hope)\n");\r\ntextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\r\nMAP_PRIVATE|MAP_EXECUTABLE, 0);\r\nif (!textpos || IS_ERR_VALUE(textpos)) {\r\nif (!textpos)\r\ntextpos = (unsigned long) -ENOMEM;\r\nprintk("Unable to mmap process text, errno %d\n", (int)-textpos);\r\nret = textpos;\r\ngoto err;\r\n}\r\nlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\r\nlen = PAGE_ALIGN(len);\r\nrealdatastart = vm_mmap(0, 0, len,\r\nPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\r\nif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\r\nif (!realdatastart)\r\nrealdatastart = (unsigned long) -ENOMEM;\r\nprintk("Unable to allocate RAM for process data, errno %d\n",\r\n(int)-realdatastart);\r\nvm_munmap(textpos, text_len);\r\nret = realdatastart;\r\ngoto err;\r\n}\r\ndatapos = ALIGN(realdatastart +\r\nMAX_SHARED_LIBS * sizeof(unsigned long),\r\nFLAT_DATA_ALIGN);\r\nDBG_FLT("BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\n",\r\n(int)(data_len + bss_len + stack_len), (int)datapos);\r\nfpos = ntohl(hdr->data_start);\r\n#ifdef CONFIG_BINFMT_ZFLAT\r\nif (flags & FLAT_FLAG_GZDATA) {\r\nresult = decompress_exec(bprm, fpos, (char *) datapos,\r\ndata_len + (relocs * sizeof(unsigned long)), 0);\r\n} else\r\n#endif\r\n{\r\nresult = bprm->file->f_op->read(bprm->file, (char *) datapos,\r\ndata_len + (relocs * sizeof(unsigned long)), &fpos);\r\n}\r\nif (IS_ERR_VALUE(result)) {\r\nprintk("Unable to read data+bss, errno %d\n", (int)-result);\r\nvm_munmap(textpos, text_len);\r\nvm_munmap(realdatastart, len);\r\nret = result;\r\ngoto err;\r\n}\r\nreloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));\r\nmemp = realdatastart;\r\nmemp_size = len;\r\n} else {\r\nlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\r\nlen = PAGE_ALIGN(len);\r\ntextpos = vm_mmap(0, 0, len,\r\nPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\r\nif (!textpos || IS_ERR_VALUE(textpos)) {\r\nif (!textpos)\r\ntextpos = (unsigned long) -ENOMEM;\r\nprintk("Unable to allocate RAM for process text/data, errno %d\n",\r\n(int)-textpos);\r\nret = textpos;\r\ngoto err;\r\n}\r\nrealdatastart = textpos + ntohl(hdr->data_start);\r\ndatapos = ALIGN(realdatastart +\r\nMAX_SHARED_LIBS * sizeof(unsigned long),\r\nFLAT_DATA_ALIGN);\r\nreloc = (unsigned long *)\r\n(datapos + (ntohl(hdr->reloc_start) - text_len));\r\nmemp = textpos;\r\nmemp_size = len;\r\n#ifdef CONFIG_BINFMT_ZFLAT\r\nif (flags & FLAT_FLAG_GZIP) {\r\nresult = decompress_exec(bprm, sizeof (struct flat_hdr),\r\n(((char *) textpos) + sizeof (struct flat_hdr)),\r\n(text_len + data_len + (relocs * sizeof(unsigned long))\r\n- sizeof (struct flat_hdr)),\r\n0);\r\nmemmove((void *) datapos, (void *) realdatastart,\r\ndata_len + (relocs * sizeof(unsigned long)));\r\n} else if (flags & FLAT_FLAG_GZDATA) {\r\nfpos = 0;\r\nresult = bprm->file->f_op->read(bprm->file,\r\n(char *) textpos, text_len, &fpos);\r\nif (!IS_ERR_VALUE(result))\r\nresult = decompress_exec(bprm, text_len, (char *) datapos,\r\ndata_len + (relocs * sizeof(unsigned long)), 0);\r\n}\r\nelse\r\n#endif\r\n{\r\nfpos = 0;\r\nresult = bprm->file->f_op->read(bprm->file,\r\n(char *) textpos, text_len, &fpos);\r\nif (!IS_ERR_VALUE(result)) {\r\nfpos = ntohl(hdr->data_start);\r\nresult = bprm->file->f_op->read(bprm->file, (char *) datapos,\r\ndata_len + (relocs * sizeof(unsigned long)), &fpos);\r\n}\r\n}\r\nif (IS_ERR_VALUE(result)) {\r\nprintk("Unable to read code+data+bss, errno %d\n",(int)-result);\r\nvm_munmap(textpos, text_len + data_len + extra +\r\nMAX_SHARED_LIBS * sizeof(unsigned long));\r\nret = result;\r\ngoto err;\r\n}\r\n}\r\nif (flags & FLAT_FLAG_KTRACE)\r\nprintk("Mapping is %x, Entry point is %x, data_start is %x\n",\r\n(int)textpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\r\nstart_code = textpos + sizeof (struct flat_hdr);\r\nend_code = textpos + text_len;\r\nif (id == 0) {\r\ncurrent->mm->start_code = start_code;\r\ncurrent->mm->end_code = end_code;\r\ncurrent->mm->start_data = datapos;\r\ncurrent->mm->end_data = datapos + data_len;\r\ncurrent->mm->start_brk = datapos + data_len + bss_len;\r\ncurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\r\ncurrent->mm->context.end_brk = memp + memp_size - stack_len;\r\n}\r\nif (flags & FLAT_FLAG_KTRACE)\r\nprintk("%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\n",\r\nid ? "Lib" : "Load", bprm->filename,\r\n(int) start_code, (int) end_code,\r\n(int) datapos,\r\n(int) (datapos + data_len),\r\n(int) (datapos + data_len),\r\n(int) (((datapos + data_len + bss_len) + 3) & ~3));\r\ntext_len -= sizeof(struct flat_hdr);\r\nlibinfo->lib_list[id].start_code = start_code;\r\nlibinfo->lib_list[id].start_data = datapos;\r\nlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\r\nlibinfo->lib_list[id].text_len = text_len;\r\nlibinfo->lib_list[id].loaded = 1;\r\nlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\r\nlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\r\nif (flags & FLAT_FLAG_GOTPIC) {\r\nfor (rp = (unsigned long *)datapos; *rp != 0xffffffff; rp++) {\r\nunsigned long addr;\r\nif (*rp) {\r\naddr = calc_reloc(*rp, libinfo, id, 0);\r\nif (addr == RELOC_FAILED) {\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\n*rp = addr;\r\n}\r\n}\r\n}\r\nif (rev > OLD_FLAT_VERSION) {\r\nunsigned long persistent = 0;\r\nfor (i=0; i < relocs; i++) {\r\nunsigned long addr, relval;\r\nrelval = ntohl(reloc[i]);\r\nif (flat_set_persistent (relval, &persistent))\r\ncontinue;\r\naddr = flat_get_relocate_addr(relval);\r\nrp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);\r\nif (rp == (unsigned long *)RELOC_FAILED) {\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\naddr = flat_get_addr_from_rp(rp, relval, flags,\r\n&persistent);\r\nif (addr != 0) {\r\nif ((flags & FLAT_FLAG_GOTPIC) == 0)\r\naddr = ntohl(addr);\r\naddr = calc_reloc(addr, libinfo, id, 0);\r\nif (addr == RELOC_FAILED) {\r\nret = -ENOEXEC;\r\ngoto err;\r\n}\r\nflat_put_addr_at_rp(rp, addr, relval);\r\n}\r\n}\r\n} else {\r\nfor (i=0; i < relocs; i++)\r\nold_reloc(ntohl(reloc[i]));\r\n}\r\nflush_icache_range(start_code, end_code);\r\nmemset((void*)(datapos + data_len), 0, bss_len +\r\n(memp + memp_size - stack_len -\r\nlibinfo->lib_list[id].start_brk) +\r\nstack_len);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int load_flat_shared_library(int id, struct lib_info *libs)\r\n{\r\nstruct linux_binprm bprm;\r\nint res;\r\nchar buf[16];\r\nmemset(&bprm, 0, sizeof(bprm));\r\nsprintf(buf, "/lib/lib%d.so", id);\r\nbprm.filename = buf;\r\nbprm.file = open_exec(bprm.filename);\r\nres = PTR_ERR(bprm.file);\r\nif (IS_ERR(bprm.file))\r\nreturn res;\r\nbprm.cred = prepare_exec_creds();\r\nres = -ENOMEM;\r\nif (!bprm.cred)\r\ngoto out;\r\nbprm.cred_prepared = 1;\r\nres = prepare_binprm(&bprm);\r\nif (!IS_ERR_VALUE(res))\r\nres = load_flat_file(&bprm, libs, id, NULL);\r\nabort_creds(bprm.cred);\r\nout:\r\nallow_write_access(bprm.file);\r\nfput(bprm.file);\r\nreturn(res);\r\n}\r\nstatic int load_flat_binary(struct linux_binprm * bprm, struct pt_regs * regs)\r\n{\r\nstruct lib_info libinfo;\r\nunsigned long p = bprm->p;\r\nunsigned long stack_len;\r\nunsigned long start_addr;\r\nunsigned long *sp;\r\nint res;\r\nint i, j;\r\nmemset(&libinfo, 0, sizeof(libinfo));\r\n#define TOP_OF_ARGS (PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *))\r\nstack_len = TOP_OF_ARGS - bprm->p;\r\nstack_len += (bprm->argc + 1) * sizeof(char *);\r\nstack_len += (bprm->envc + 1) * sizeof(char *);\r\nstack_len += FLAT_STACK_ALIGN - 1;\r\nres = load_flat_file(bprm, &libinfo, 0, &stack_len);\r\nif (IS_ERR_VALUE(res))\r\nreturn res;\r\nfor (i=0; i<MAX_SHARED_LIBS; i++)\r\nif (libinfo.lib_list[i].loaded)\r\nfor (j=0; j<MAX_SHARED_LIBS; j++)\r\n(-(j+1))[(unsigned long *)(libinfo.lib_list[i].start_data)] =\r\n(libinfo.lib_list[j].loaded)?\r\nlibinfo.lib_list[j].start_data:UNLOADED_LIB;\r\ninstall_exec_creds(bprm);\r\nset_binfmt(&flat_format);\r\np = ((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;\r\nDBG_FLT("p=%x\n", (int)p);\r\nfor (i = TOP_OF_ARGS - 1; i >= bprm->p; i--)\r\n* (char *) --p =\r\n((char *) page_address(bprm->page[i/PAGE_SIZE]))[i % PAGE_SIZE];\r\nsp = (unsigned long *) create_flat_tables(p, bprm);\r\nstart_addr = libinfo.lib_list[0].entry;\r\n#ifdef CONFIG_BINFMT_SHARED_FLAT\r\nfor (i = MAX_SHARED_LIBS-1; i>0; i--) {\r\nif (libinfo.lib_list[i].loaded) {\r\n--sp; put_user(start_addr, sp);\r\nstart_addr = libinfo.lib_list[i].entry;\r\n}\r\n}\r\n#endif\r\ncurrent->mm->start_stack = (unsigned long )sp;\r\n#ifdef FLAT_PLAT_INIT\r\nFLAT_PLAT_INIT(regs);\r\n#endif\r\nDBG_FLT("start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)\n",\r\n(int)regs, (int)start_addr, (int)current->mm->start_stack);\r\nstart_thread(regs, start_addr, current->mm->start_stack);\r\nreturn 0;\r\n}\r\nstatic int __init init_flat_binfmt(void)\r\n{\r\nregister_binfmt(&flat_format);\r\nreturn 0;\r\n}
