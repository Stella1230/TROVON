static irqreturn_t mk712_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned char status;\r\nstatic int debounce = 1;\r\nstatic unsigned short last_x;\r\nstatic unsigned short last_y;\r\nspin_lock(&mk712_lock);\r\nstatus = inb(mk712_io + MK712_STATUS);\r\nif (~status & MK712_CONVERSION_COMPLETE) {\r\ndebounce = 1;\r\ngoto end;\r\n}\r\nif (~status & MK712_STATUS_TOUCH) {\r\ndebounce = 1;\r\ninput_report_key(mk712_dev, BTN_TOUCH, 0);\r\ngoto end;\r\n}\r\nif (debounce) {\r\ndebounce = 0;\r\ngoto end;\r\n}\r\ninput_report_key(mk712_dev, BTN_TOUCH, 1);\r\ninput_report_abs(mk712_dev, ABS_X, last_x);\r\ninput_report_abs(mk712_dev, ABS_Y, last_y);\r\nend:\r\nlast_x = inw(mk712_io + MK712_X) & 0x0fff;\r\nlast_y = inw(mk712_io + MK712_Y) & 0x0fff;\r\ninput_sync(mk712_dev);\r\nspin_unlock(&mk712_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mk712_open(struct input_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mk712_lock, flags);\r\noutb(0, mk712_io + MK712_CONTROL);\r\noutb(MK712_ENABLE_INT | MK712_INT_ON_CONVERSION_COMPLETE |\r\nMK712_INT_ON_CHANGE_IN_TOUCH_STATUS |\r\nMK712_ENABLE_PERIODIC_CONVERSIONS |\r\nMK712_POWERUP, mk712_io + MK712_CONTROL);\r\noutb(10, mk712_io + MK712_RATE);\r\nspin_unlock_irqrestore(&mk712_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mk712_close(struct input_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mk712_lock, flags);\r\noutb(0, mk712_io + MK712_CONTROL);\r\nspin_unlock_irqrestore(&mk712_lock, flags);\r\n}\r\nstatic int __init mk712_init(void)\r\n{\r\nint err;\r\nif (!request_region(mk712_io, 8, "mk712")) {\r\nprintk(KERN_WARNING "mk712: unable to get IO region\n");\r\nreturn -ENODEV;\r\n}\r\noutb(0, mk712_io + MK712_CONTROL);\r\nif ((inw(mk712_io + MK712_X) & 0xf000) ||\r\n(inw(mk712_io + MK712_Y) & 0xf000) ||\r\n(inw(mk712_io + MK712_STATUS) & 0xf333)) {\r\nprintk(KERN_WARNING "mk712: device not present\n");\r\nerr = -ENODEV;\r\ngoto fail1;\r\n}\r\nmk712_dev = input_allocate_device();\r\nif (!mk712_dev) {\r\nprintk(KERN_ERR "mk712: not enough memory\n");\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nmk712_dev->name = "ICS MicroClock MK712 TouchScreen";\r\nmk712_dev->phys = "isa0260/input0";\r\nmk712_dev->id.bustype = BUS_ISA;\r\nmk712_dev->id.vendor = 0x0005;\r\nmk712_dev->id.product = 0x0001;\r\nmk712_dev->id.version = 0x0100;\r\nmk712_dev->open = mk712_open;\r\nmk712_dev->close = mk712_close;\r\nmk712_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nmk712_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(mk712_dev, ABS_X, 0, 0xfff, 88, 0);\r\ninput_set_abs_params(mk712_dev, ABS_Y, 0, 0xfff, 88, 0);\r\nif (request_irq(mk712_irq, mk712_interrupt, 0, "mk712", mk712_dev)) {\r\nprintk(KERN_WARNING "mk712: unable to get IRQ\n");\r\nerr = -EBUSY;\r\ngoto fail1;\r\n}\r\nerr = input_register_device(mk712_dev);\r\nif (err)\r\ngoto fail2;\r\nreturn 0;\r\nfail2: free_irq(mk712_irq, mk712_dev);\r\nfail1: input_free_device(mk712_dev);\r\nrelease_region(mk712_io, 8);\r\nreturn err;\r\n}\r\nstatic void __exit mk712_exit(void)\r\n{\r\ninput_unregister_device(mk712_dev);\r\nfree_irq(mk712_irq, mk712_dev);\r\nrelease_region(mk712_io, 8);\r\n}
