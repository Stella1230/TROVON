static int tsc2005_cmd(struct tsc2005 *ts, u8 cmd)\r\n{\r\nu8 tx = TSC2005_CMD | TSC2005_CMD_12BIT | cmd;\r\nstruct spi_transfer xfer = {\r\n.tx_buf = &tx,\r\n.len = 1,\r\n.bits_per_word = 8,\r\n};\r\nstruct spi_message msg;\r\nint error;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nerror = spi_sync(ts->spi, &msg);\r\nif (error) {\r\ndev_err(&ts->spi->dev, "%s: failed, command: %x, error: %d\n",\r\n__func__, cmd, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tsc2005_write(struct tsc2005 *ts, u8 reg, u16 value)\r\n{\r\nu32 tx = ((reg | TSC2005_REG_PND0) << 16) | value;\r\nstruct spi_transfer xfer = {\r\n.tx_buf = &tx,\r\n.len = 4,\r\n.bits_per_word = 24,\r\n};\r\nstruct spi_message msg;\r\nint error;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nerror = spi_sync(ts->spi, &msg);\r\nif (error) {\r\ndev_err(&ts->spi->dev,\r\n"%s: failed, register: %x, value: %x, error: %d\n",\r\n__func__, reg, value, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tsc2005_setup_read(struct tsc2005_spi_rd *rd, u8 reg, bool last)\r\n{\r\nmemset(rd, 0, sizeof(*rd));\r\nrd->spi_tx = (reg | TSC2005_REG_READ) << 16;\r\nrd->spi_xfer.tx_buf = &rd->spi_tx;\r\nrd->spi_xfer.rx_buf = &rd->spi_rx;\r\nrd->spi_xfer.len = 4;\r\nrd->spi_xfer.bits_per_word = 24;\r\nrd->spi_xfer.cs_change = !last;\r\n}\r\nstatic int tsc2005_read(struct tsc2005 *ts, u8 reg, u16 *value)\r\n{\r\nstruct tsc2005_spi_rd spi_rd;\r\nstruct spi_message msg;\r\nint error;\r\ntsc2005_setup_read(&spi_rd, reg, true);\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&spi_rd.spi_xfer, &msg);\r\nerror = spi_sync(ts->spi, &msg);\r\nif (error)\r\nreturn error;\r\n*value = spi_rd.spi_rx;\r\nreturn 0;\r\n}\r\nstatic void tsc2005_update_pen_state(struct tsc2005 *ts,\r\nint x, int y, int pressure)\r\n{\r\nif (pressure) {\r\ninput_report_abs(ts->idev, ABS_X, x);\r\ninput_report_abs(ts->idev, ABS_Y, y);\r\ninput_report_abs(ts->idev, ABS_PRESSURE, pressure);\r\nif (!ts->pen_down) {\r\ninput_report_key(ts->idev, BTN_TOUCH, !!pressure);\r\nts->pen_down = true;\r\n}\r\n} else {\r\ninput_report_abs(ts->idev, ABS_PRESSURE, 0);\r\nif (ts->pen_down) {\r\ninput_report_key(ts->idev, BTN_TOUCH, 0);\r\nts->pen_down = false;\r\n}\r\n}\r\ninput_sync(ts->idev);\r\ndev_dbg(&ts->spi->dev, "point(%4d,%4d), pressure (%4d)\n", x, y,\r\npressure);\r\n}\r\nstatic irqreturn_t tsc2005_irq_thread(int irq, void *_ts)\r\n{\r\nstruct tsc2005 *ts = _ts;\r\nunsigned long flags;\r\nunsigned int pressure;\r\nu32 x, y;\r\nu32 z1, z2;\r\nint error;\r\nerror = spi_sync(ts->spi, &ts->spi_read_msg);\r\nif (unlikely(error))\r\ngoto out;\r\nx = ts->spi_x.spi_rx;\r\ny = ts->spi_y.spi_rx;\r\nz1 = ts->spi_z1.spi_rx;\r\nz2 = ts->spi_z2.spi_rx;\r\nif (unlikely(x > MAX_12BIT || y > MAX_12BIT))\r\ngoto out;\r\nif (unlikely(z1 == 0 || z2 > MAX_12BIT || z1 >= z2))\r\ngoto out;\r\nif (!ts->pen_down &&\r\nts->in_x == x && ts->in_y == y &&\r\nts->in_z1 == z1 && ts->in_z2 == z2) {\r\ngoto out;\r\n}\r\nts->in_x = x;\r\nts->in_y = y;\r\nts->in_z1 = z1;\r\nts->in_z2 = z2;\r\npressure = x * (z2 - z1) / z1;\r\npressure = pressure * ts->x_plate_ohm / 4096;\r\nif (unlikely(pressure > MAX_12BIT))\r\ngoto out;\r\nspin_lock_irqsave(&ts->lock, flags);\r\ntsc2005_update_pen_state(ts, x, y, pressure);\r\nmod_timer(&ts->penup_timer,\r\njiffies + msecs_to_jiffies(TSC2005_PENUP_TIME_MS));\r\nspin_unlock_irqrestore(&ts->lock, flags);\r\nts->last_valid_interrupt = jiffies;\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsc2005_penup_timer(unsigned long data)\r\n{\r\nstruct tsc2005 *ts = (struct tsc2005 *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ts->lock, flags);\r\ntsc2005_update_pen_state(ts, 0, 0, 0);\r\nspin_unlock_irqrestore(&ts->lock, flags);\r\n}\r\nstatic void tsc2005_start_scan(struct tsc2005 *ts)\r\n{\r\ntsc2005_write(ts, TSC2005_REG_CFR0, TSC2005_CFR0_INITVALUE);\r\ntsc2005_write(ts, TSC2005_REG_CFR1, TSC2005_CFR1_INITVALUE);\r\ntsc2005_write(ts, TSC2005_REG_CFR2, TSC2005_CFR2_INITVALUE);\r\ntsc2005_cmd(ts, TSC2005_CMD_NORMAL);\r\n}\r\nstatic void tsc2005_stop_scan(struct tsc2005 *ts)\r\n{\r\ntsc2005_cmd(ts, TSC2005_CMD_STOP);\r\n}\r\nstatic void __tsc2005_disable(struct tsc2005 *ts)\r\n{\r\ntsc2005_stop_scan(ts);\r\ndisable_irq(ts->spi->irq);\r\ndel_timer_sync(&ts->penup_timer);\r\ncancel_delayed_work_sync(&ts->esd_work);\r\nenable_irq(ts->spi->irq);\r\n}\r\nstatic void __tsc2005_enable(struct tsc2005 *ts)\r\n{\r\ntsc2005_start_scan(ts);\r\nif (ts->esd_timeout && ts->set_reset) {\r\nts->last_valid_interrupt = jiffies;\r\nschedule_delayed_work(&ts->esd_work,\r\nround_jiffies_relative(\r\nmsecs_to_jiffies(ts->esd_timeout)));\r\n}\r\n}\r\nstatic ssize_t tsc2005_selftest_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\nu16 temp_high;\r\nu16 temp_high_orig;\r\nu16 temp_high_test;\r\nbool success = true;\r\nint error;\r\nmutex_lock(&ts->mutex);\r\n__tsc2005_disable(ts);\r\nerror = tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high_orig);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d\n", error);\r\nsuccess = false;\r\ngoto out;\r\n}\r\ntemp_high_test = (temp_high_orig - 1) & MAX_12BIT;\r\nerror = tsc2005_write(ts, TSC2005_REG_TEMP_HIGH, temp_high_test);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: write error %d\n", error);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nerror = tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d after write\n",\r\nerror);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nif (temp_high != temp_high_test) {\r\ndev_warn(dev, "selftest failed: %d != %d\n",\r\ntemp_high, temp_high_test);\r\nsuccess = false;\r\n}\r\nts->set_reset(false);\r\nusleep_range(100, 500);\r\nts->set_reset(true);\r\nif (!success)\r\ngoto out;\r\nerror = tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d after reset\n",\r\nerror);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nif (temp_high != temp_high_orig) {\r\ndev_warn(dev, "selftest failed after reset: %d != %d\n",\r\ntemp_high, temp_high_orig);\r\nsuccess = false;\r\n}\r\nout:\r\n__tsc2005_enable(ts);\r\nmutex_unlock(&ts->mutex);\r\nreturn sprintf(buf, "%d\n", success);\r\n}\r\nstatic umode_t tsc2005_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\numode_t mode = attr->mode;\r\nif (attr == &dev_attr_selftest.attr) {\r\nif (!ts->set_reset)\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic void tsc2005_esd_work(struct work_struct *work)\r\n{\r\nstruct tsc2005 *ts = container_of(work, struct tsc2005, esd_work.work);\r\nint error;\r\nu16 r;\r\nif (!mutex_trylock(&ts->mutex)) {\r\ngoto reschedule;\r\n}\r\nif (time_is_after_jiffies(ts->last_valid_interrupt +\r\nmsecs_to_jiffies(ts->esd_timeout)))\r\ngoto out;\r\nerror = tsc2005_read(ts, TSC2005_REG_CFR0, &r);\r\nif (!error &&\r\n!((r ^ TSC2005_CFR0_INITVALUE) & TSC2005_CFR0_RW_MASK)) {\r\ngoto out;\r\n}\r\ndev_info(&ts->spi->dev, "TSC2005 not responding - resetting\n");\r\ndisable_irq(ts->spi->irq);\r\ndel_timer_sync(&ts->penup_timer);\r\ntsc2005_update_pen_state(ts, 0, 0, 0);\r\nts->set_reset(false);\r\nusleep_range(100, 500);\r\nts->set_reset(true);\r\nenable_irq(ts->spi->irq);\r\ntsc2005_start_scan(ts);\r\nout:\r\nmutex_unlock(&ts->mutex);\r\nreschedule:\r\nschedule_delayed_work(&ts->esd_work,\r\nround_jiffies_relative(\r\nmsecs_to_jiffies(ts->esd_timeout)));\r\n}\r\nstatic int tsc2005_open(struct input_dev *input)\r\n{\r\nstruct tsc2005 *ts = input_get_drvdata(input);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended)\r\n__tsc2005_enable(ts);\r\nts->opened = true;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}\r\nstatic void tsc2005_close(struct input_dev *input)\r\n{\r\nstruct tsc2005 *ts = input_get_drvdata(input);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended)\r\n__tsc2005_disable(ts);\r\nts->opened = false;\r\nmutex_unlock(&ts->mutex);\r\n}\r\nstatic void __devinit tsc2005_setup_spi_xfer(struct tsc2005 *ts)\r\n{\r\ntsc2005_setup_read(&ts->spi_x, TSC2005_REG_X, false);\r\ntsc2005_setup_read(&ts->spi_y, TSC2005_REG_Y, false);\r\ntsc2005_setup_read(&ts->spi_z1, TSC2005_REG_Z1, false);\r\ntsc2005_setup_read(&ts->spi_z2, TSC2005_REG_Z2, true);\r\nspi_message_init(&ts->spi_read_msg);\r\nspi_message_add_tail(&ts->spi_x.spi_xfer, &ts->spi_read_msg);\r\nspi_message_add_tail(&ts->spi_y.spi_xfer, &ts->spi_read_msg);\r\nspi_message_add_tail(&ts->spi_z1.spi_xfer, &ts->spi_read_msg);\r\nspi_message_add_tail(&ts->spi_z2.spi_xfer, &ts->spi_read_msg);\r\n}\r\nstatic int __devinit tsc2005_probe(struct spi_device *spi)\r\n{\r\nconst struct tsc2005_platform_data *pdata = spi->dev.platform_data;\r\nstruct tsc2005 *ts;\r\nstruct input_dev *input_dev;\r\nunsigned int max_x, max_y, max_p;\r\nunsigned int fudge_x, fudge_y, fudge_p;\r\nint error;\r\nif (!pdata) {\r\ndev_dbg(&spi->dev, "no platform data\n");\r\nreturn -ENODEV;\r\n}\r\nfudge_x = pdata->ts_x_fudge ? : 4;\r\nfudge_y = pdata->ts_y_fudge ? : 8;\r\nfudge_p = pdata->ts_pressure_fudge ? : 2;\r\nmax_x = pdata->ts_x_max ? : MAX_12BIT;\r\nmax_y = pdata->ts_y_max ? : MAX_12BIT;\r\nmax_p = pdata->ts_pressure_max ? : MAX_12BIT;\r\nif (spi->irq <= 0) {\r\ndev_dbg(&spi->dev, "no irq\n");\r\nreturn -ENODEV;\r\n}\r\nspi->mode = SPI_MODE_0;\r\nspi->bits_per_word = 8;\r\nif (!spi->max_speed_hz)\r\nspi->max_speed_hz = TSC2005_SPI_MAX_SPEED_HZ;\r\nerror = spi_setup(spi);\r\nif (error)\r\nreturn error;\r\nts = kzalloc(sizeof(*ts), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nts->spi = spi;\r\nts->idev = input_dev;\r\nts->x_plate_ohm = pdata->ts_x_plate_ohm ? : 280;\r\nts->esd_timeout = pdata->esd_timeout_ms;\r\nts->set_reset = pdata->set_reset;\r\nmutex_init(&ts->mutex);\r\nspin_lock_init(&ts->lock);\r\nsetup_timer(&ts->penup_timer, tsc2005_penup_timer, (unsigned long)ts);\r\nINIT_DELAYED_WORK(&ts->esd_work, tsc2005_esd_work);\r\ntsc2005_setup_spi_xfer(ts);\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input-ts", dev_name(&spi->dev));\r\ninput_dev->name = "TSC2005 touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_SPI;\r\ninput_dev->dev.parent = &spi->dev;\r\ninput_dev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, max_x, fudge_x, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, max_y, fudge_y, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, max_p, fudge_p, 0);\r\ninput_dev->open = tsc2005_open;\r\ninput_dev->close = tsc2005_close;\r\ninput_set_drvdata(input_dev, ts);\r\ntsc2005_stop_scan(ts);\r\nerror = request_threaded_irq(spi->irq, NULL, tsc2005_irq_thread,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"tsc2005", ts);\r\nif (error) {\r\ndev_err(&spi->dev, "Failed to request irq, err: %d\n", error);\r\ngoto err_free_mem;\r\n}\r\nspi_set_drvdata(spi, ts);\r\nerror = sysfs_create_group(&spi->dev.kobj, &tsc2005_attr_group);\r\nif (error) {\r\ndev_err(&spi->dev,\r\n"Failed to create sysfs attributes, err: %d\n", error);\r\ngoto err_clear_drvdata;\r\n}\r\nerror = input_register_device(ts->idev);\r\nif (error) {\r\ndev_err(&spi->dev,\r\n"Failed to register input device, err: %d\n", error);\r\ngoto err_remove_sysfs;\r\n}\r\nirq_set_irq_wake(spi->irq, 1);\r\nreturn 0;\r\nerr_remove_sysfs:\r\nsysfs_remove_group(&spi->dev.kobj, &tsc2005_attr_group);\r\nerr_clear_drvdata:\r\nspi_set_drvdata(spi, NULL);\r\nfree_irq(spi->irq, ts);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ts);\r\nreturn error;\r\n}\r\nstatic int __devexit tsc2005_remove(struct spi_device *spi)\r\n{\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\nsysfs_remove_group(&ts->spi->dev.kobj, &tsc2005_attr_group);\r\nfree_irq(ts->spi->irq, ts);\r\ninput_unregister_device(ts->idev);\r\nkfree(ts);\r\nspi_set_drvdata(spi, NULL);\r\nreturn 0;\r\n}\r\nstatic int tsc2005_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended && ts->opened)\r\n__tsc2005_disable(ts);\r\nts->suspended = true;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}\r\nstatic int tsc2005_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\nmutex_lock(&ts->mutex);\r\nif (ts->suspended && ts->opened)\r\n__tsc2005_enable(ts);\r\nts->suspended = false;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}
