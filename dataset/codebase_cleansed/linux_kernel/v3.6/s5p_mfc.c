static void clear_work_bit(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nspin_lock(&dev->condlock);\r\nclear_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock(&dev->condlock);\r\n}\r\nstatic void wake_up_ctx(struct s5p_mfc_ctx *ctx, unsigned int reason,\r\nunsigned int err)\r\n{\r\nctx->int_cond = 1;\r\nctx->int_type = reason;\r\nctx->int_err = err;\r\nwake_up(&ctx->queue);\r\n}\r\nstatic void wake_up_dev(struct s5p_mfc_dev *dev, unsigned int reason,\r\nunsigned int err)\r\n{\r\ndev->int_cond = 1;\r\ndev->int_type = reason;\r\ndev->int_err = err;\r\nwake_up(&dev->queue);\r\n}\r\nstatic void s5p_mfc_watchdog(unsigned long arg)\r\n{\r\nstruct s5p_mfc_dev *dev = (struct s5p_mfc_dev *)arg;\r\nif (test_bit(0, &dev->hw_lock))\r\natomic_inc(&dev->watchdog_cnt);\r\nif (atomic_read(&dev->watchdog_cnt) >= MFC_WATCHDOG_CNT) {\r\nmfc_err("Time out during waiting for HW\n");\r\nqueue_work(dev->watchdog_workqueue, &dev->watchdog_work);\r\n}\r\ndev->watchdog_timer.expires = jiffies +\r\nmsecs_to_jiffies(MFC_WATCHDOG_INTERVAL);\r\nadd_timer(&dev->watchdog_timer);\r\n}\r\nstatic void s5p_mfc_watchdog_worker(struct work_struct *work)\r\n{\r\nstruct s5p_mfc_dev *dev;\r\nstruct s5p_mfc_ctx *ctx;\r\nunsigned long flags;\r\nint mutex_locked;\r\nint i, ret;\r\ndev = container_of(work, struct s5p_mfc_dev, watchdog_work);\r\nmfc_err("Driver timeout error handling\n");\r\nmutex_locked = mutex_trylock(&dev->mfc_mutex);\r\nif (!mutex_locked)\r\nmfc_err("Error: some instance may be closing/opening\n");\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\ns5p_mfc_clock_off();\r\nfor (i = 0; i < MFC_NUM_CONTEXTS; i++) {\r\nctx = dev->ctx[i];\r\nif (!ctx)\r\ncontinue;\r\nctx->state = MFCINST_ERROR;\r\ns5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\r\ns5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\r\nclear_work_bit(ctx);\r\nwake_up_ctx(ctx, S5P_FIMV_R2H_CMD_ERR_RET, 0);\r\n}\r\nclear_bit(0, &dev->hw_lock);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nif (dev->num_inst > 0) {\r\nret = s5p_mfc_reload_firmware(dev);\r\nif (ret) {\r\nmfc_err("Failed to reload FW\n");\r\ngoto unlock;\r\n}\r\ns5p_mfc_clock_on();\r\nret = s5p_mfc_init_hw(dev);\r\nif (ret)\r\nmfc_err("Failed to reinit FW\n");\r\n}\r\nunlock:\r\nif (mutex_locked)\r\nmutex_unlock(&dev->mfc_mutex);\r\n}\r\nstatic enum s5p_mfc_node_type s5p_mfc_get_node_type(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (!vdev) {\r\nmfc_err("failed to get video_device");\r\nreturn MFCNODE_INVALID;\r\n}\r\nif (vdev->index == 0)\r\nreturn MFCNODE_DECODER;\r\nelse if (vdev->index == 1)\r\nreturn MFCNODE_ENCODER;\r\nreturn MFCNODE_INVALID;\r\n}\r\nstatic void s5p_mfc_clear_int_flags(struct s5p_mfc_dev *dev)\r\n{\r\nmfc_write(dev, 0, S5P_FIMV_RISC_HOST_INT);\r\nmfc_write(dev, 0, S5P_FIMV_RISC2HOST_CMD);\r\nmfc_write(dev, 0xffff, S5P_FIMV_SI_RTN_CHID);\r\n}\r\nstatic void s5p_mfc_handle_frame_all_extracted(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_buf *dst_buf;\r\nctx->state = MFCINST_FINISHED;\r\nctx->sequence++;\r\nwhile (!list_empty(&ctx->dst_queue)) {\r\ndst_buf = list_entry(ctx->dst_queue.next,\r\nstruct s5p_mfc_buf, list);\r\nmfc_debug(2, "Cleaning up buffer: %d\n",\r\ndst_buf->b->v4l2_buf.index);\r\nvb2_set_plane_payload(dst_buf->b, 0, 0);\r\nvb2_set_plane_payload(dst_buf->b, 1, 0);\r\nlist_del(&dst_buf->list);\r\nctx->dst_queue_cnt--;\r\ndst_buf->b->v4l2_buf.sequence = (ctx->sequence++);\r\nif (s5p_mfc_read_shm(ctx, PIC_TIME_TOP) ==\r\ns5p_mfc_read_shm(ctx, PIC_TIME_BOT))\r\ndst_buf->b->v4l2_buf.field = V4L2_FIELD_NONE;\r\nelse\r\ndst_buf->b->v4l2_buf.field = V4L2_FIELD_INTERLACED;\r\nctx->dec_dst_flag &= ~(1 << dst_buf->b->v4l2_buf.index);\r\nvb2_buffer_done(dst_buf->b, VB2_BUF_STATE_DONE);\r\n}\r\n}\r\nstatic void s5p_mfc_handle_frame_copy_time(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *dst_buf, *src_buf;\r\nsize_t dec_y_addr = s5p_mfc_get_dec_y_adr();\r\nunsigned int frame_type = s5p_mfc_get_frame_type();\r\nsrc_buf = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\nlist_for_each_entry(dst_buf, &ctx->dst_queue, list) {\r\nif (vb2_dma_contig_plane_dma_addr(dst_buf->b, 0) == dec_y_addr) {\r\nmemcpy(&dst_buf->b->v4l2_buf.timecode,\r\n&src_buf->b->v4l2_buf.timecode,\r\nsizeof(struct v4l2_timecode));\r\nmemcpy(&dst_buf->b->v4l2_buf.timestamp,\r\n&src_buf->b->v4l2_buf.timestamp,\r\nsizeof(struct timeval));\r\nswitch (frame_type) {\r\ncase S5P_FIMV_DECODE_FRAME_I_FRAME:\r\ndst_buf->b->v4l2_buf.flags |=\r\nV4L2_BUF_FLAG_KEYFRAME;\r\nbreak;\r\ncase S5P_FIMV_DECODE_FRAME_P_FRAME:\r\ndst_buf->b->v4l2_buf.flags |=\r\nV4L2_BUF_FLAG_PFRAME;\r\nbreak;\r\ncase S5P_FIMV_DECODE_FRAME_B_FRAME:\r\ndst_buf->b->v4l2_buf.flags |=\r\nV4L2_BUF_FLAG_BFRAME;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void s5p_mfc_handle_frame_new(struct s5p_mfc_ctx *ctx, unsigned int err)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *dst_buf;\r\nsize_t dspl_y_addr = s5p_mfc_get_dspl_y_adr();\r\nunsigned int frame_type = s5p_mfc_get_frame_type();\r\nunsigned int index;\r\nif (frame_type == S5P_FIMV_DECODE_FRAME_SKIPPED) {\r\nif (!ctx->after_packed_pb)\r\nctx->sequence++;\r\nctx->after_packed_pb = 0;\r\nreturn;\r\n}\r\nctx->sequence++;\r\nlist_for_each_entry(dst_buf, &ctx->dst_queue, list) {\r\nif (vb2_dma_contig_plane_dma_addr(dst_buf->b, 0) == dspl_y_addr) {\r\nlist_del(&dst_buf->list);\r\nctx->dst_queue_cnt--;\r\ndst_buf->b->v4l2_buf.sequence = ctx->sequence;\r\nif (s5p_mfc_read_shm(ctx, PIC_TIME_TOP) ==\r\ns5p_mfc_read_shm(ctx, PIC_TIME_BOT))\r\ndst_buf->b->v4l2_buf.field = V4L2_FIELD_NONE;\r\nelse\r\ndst_buf->b->v4l2_buf.field =\r\nV4L2_FIELD_INTERLACED;\r\nvb2_set_plane_payload(dst_buf->b, 0, ctx->luma_size);\r\nvb2_set_plane_payload(dst_buf->b, 1, ctx->chroma_size);\r\nclear_bit(dst_buf->b->v4l2_buf.index,\r\n&ctx->dec_dst_flag);\r\nvb2_buffer_done(dst_buf->b,\r\nerr ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\nindex = dst_buf->b->v4l2_buf.index;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void s5p_mfc_handle_frame(struct s5p_mfc_ctx *ctx,\r\nunsigned int reason, unsigned int err)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned int dst_frame_status;\r\nstruct s5p_mfc_buf *src_buf;\r\nunsigned long flags;\r\nunsigned int res_change;\r\nunsigned int index;\r\ndst_frame_status = s5p_mfc_get_dspl_status()\r\n& S5P_FIMV_DEC_STATUS_DECODING_STATUS_MASK;\r\nres_change = s5p_mfc_get_dspl_status()\r\n& S5P_FIMV_DEC_STATUS_RESOLUTION_MASK;\r\nmfc_debug(2, "Frame Status: %x\n", dst_frame_status);\r\nif (ctx->state == MFCINST_RES_CHANGE_INIT)\r\nctx->state = MFCINST_RES_CHANGE_FLUSH;\r\nif (res_change) {\r\nctx->state = MFCINST_RES_CHANGE_INIT;\r\ns5p_mfc_clear_int_flags(dev);\r\nwake_up_ctx(ctx, reason, err);\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nBUG();\r\ns5p_mfc_clock_off();\r\ns5p_mfc_try_run(dev);\r\nreturn;\r\n}\r\nif (ctx->dpb_flush_flag)\r\nctx->dpb_flush_flag = 0;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (dst_frame_status == S5P_FIMV_DEC_STATUS_DECODING_EMPTY) {\r\nif (ctx->state == MFCINST_RES_CHANGE_FLUSH) {\r\ns5p_mfc_handle_frame_all_extracted(ctx);\r\nctx->state = MFCINST_RES_CHANGE_END;\r\ngoto leave_handle_frame;\r\n} else {\r\ns5p_mfc_handle_frame_all_extracted(ctx);\r\n}\r\n}\r\nif (dst_frame_status == S5P_FIMV_DEC_STATUS_DECODING_DISPLAY ||\r\ndst_frame_status == S5P_FIMV_DEC_STATUS_DECODING_ONLY)\r\ns5p_mfc_handle_frame_copy_time(ctx);\r\nif (dst_frame_status == S5P_FIMV_DEC_STATUS_DISPLAY_ONLY ||\r\ndst_frame_status == S5P_FIMV_DEC_STATUS_DECODING_DISPLAY) {\r\ns5p_mfc_handle_frame_new(ctx, err);\r\n} else {\r\nmfc_debug(2, "No frame decode\n");\r\n}\r\nif (dst_frame_status != S5P_FIMV_DEC_STATUS_DISPLAY_ONLY\r\n&& !list_empty(&ctx->src_queue)) {\r\nsrc_buf = list_entry(ctx->src_queue.next, struct s5p_mfc_buf,\r\nlist);\r\nctx->consumed_stream += s5p_mfc_get_consumed_stream();\r\nif (ctx->codec_mode != S5P_FIMV_CODEC_H264_DEC &&\r\ns5p_mfc_get_frame_type() == S5P_FIMV_DECODE_FRAME_P_FRAME\r\n&& ctx->consumed_stream + STUFF_BYTE <\r\nsrc_buf->b->v4l2_planes[0].bytesused) {\r\nmfc_debug(2, "Running again the same buffer\n");\r\nctx->after_packed_pb = 1;\r\n} else {\r\nindex = src_buf->b->v4l2_buf.index;\r\nmfc_debug(2, "MFC needs next buffer\n");\r\nctx->consumed_stream = 0;\r\nlist_del(&src_buf->list);\r\nctx->src_queue_cnt--;\r\nif (s5p_mfc_err_dec(err) > 0)\r\nvb2_buffer_done(src_buf->b, VB2_BUF_STATE_ERROR);\r\nelse\r\nvb2_buffer_done(src_buf->b, VB2_BUF_STATE_DONE);\r\n}\r\n}\r\nleave_handle_frame:\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nif ((ctx->src_queue_cnt == 0 && ctx->state != MFCINST_FINISHING)\r\n|| ctx->dst_queue_cnt < ctx->dpb_count)\r\nclear_work_bit(ctx);\r\ns5p_mfc_clear_int_flags(dev);\r\nwake_up_ctx(ctx, reason, err);\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nBUG();\r\ns5p_mfc_clock_off();\r\ns5p_mfc_try_run(dev);\r\n}\r\nstatic void s5p_mfc_handle_error(struct s5p_mfc_ctx *ctx,\r\nunsigned int reason, unsigned int err)\r\n{\r\nstruct s5p_mfc_dev *dev;\r\nunsigned long flags;\r\nif (ctx == NULL)\r\nreturn;\r\ndev = ctx->dev;\r\nmfc_err("Interrupt Error: %08x\n", err);\r\ns5p_mfc_clear_int_flags(dev);\r\nwake_up_dev(dev, reason, err);\r\nswitch (ctx->state) {\r\ncase MFCINST_INIT:\r\ncase MFCINST_GOT_INST:\r\ncase MFCINST_HEAD_PARSED:\r\ncase MFCINST_RETURN_INST:\r\nclear_work_bit(ctx);\r\nwake_up_ctx(ctx, reason, err);\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nBUG();\r\ns5p_mfc_clock_off();\r\nctx->state = MFCINST_ERROR;\r\nbreak;\r\ncase MFCINST_FINISHING:\r\ncase MFCINST_FINISHED:\r\ncase MFCINST_RUNNING:\r\nclear_work_bit(ctx);\r\nctx->state = MFCINST_ERROR;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\ns5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\r\ns5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nBUG();\r\ns5p_mfc_clock_off();\r\nbreak;\r\ndefault:\r\nmfc_err("Encountered an error interrupt which had not been handled\n");\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void s5p_mfc_handle_seq_done(struct s5p_mfc_ctx *ctx,\r\nunsigned int reason, unsigned int err)\r\n{\r\nstruct s5p_mfc_dev *dev;\r\nunsigned int guard_width, guard_height;\r\nif (ctx == NULL)\r\nreturn;\r\ndev = ctx->dev;\r\nif (ctx->c_ops->post_seq_start) {\r\nif (ctx->c_ops->post_seq_start(ctx))\r\nmfc_err("post_seq_start() failed\n");\r\n} else {\r\nctx->img_width = s5p_mfc_get_img_width();\r\nctx->img_height = s5p_mfc_get_img_height();\r\nctx->buf_width = ALIGN(ctx->img_width,\r\nS5P_FIMV_NV12MT_HALIGN);\r\nctx->buf_height = ALIGN(ctx->img_height,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nmfc_debug(2, "SEQ Done: Movie dimensions %dx%d, "\r\n"buffer dimensions: %dx%d\n", ctx->img_width,\r\nctx->img_height, ctx->buf_width,\r\nctx->buf_height);\r\nif (ctx->codec_mode == S5P_FIMV_CODEC_H264_DEC) {\r\nctx->luma_size = ALIGN(ctx->buf_width *\r\nctx->buf_height, S5P_FIMV_DEC_BUF_ALIGN);\r\nctx->chroma_size = ALIGN(ctx->buf_width *\r\nALIGN((ctx->img_height >> 1),\r\nS5P_FIMV_NV12MT_VALIGN),\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\nctx->mv_size = ALIGN(ctx->buf_width *\r\nALIGN((ctx->buf_height >> 2),\r\nS5P_FIMV_NV12MT_VALIGN),\r\nS5P_FIMV_DEC_BUF_ALIGN);\r\n} else {\r\nguard_width = ALIGN(ctx->img_width + 24,\r\nS5P_FIMV_NV12MT_HALIGN);\r\nguard_height = ALIGN(ctx->img_height + 16,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nctx->luma_size = ALIGN(guard_width *\r\nguard_height, S5P_FIMV_DEC_BUF_ALIGN);\r\nguard_width = ALIGN(ctx->img_width + 16,\r\nS5P_FIMV_NV12MT_HALIGN);\r\nguard_height = ALIGN((ctx->img_height >> 1) + 4,\r\nS5P_FIMV_NV12MT_VALIGN);\r\nctx->chroma_size = ALIGN(guard_width *\r\nguard_height, S5P_FIMV_DEC_BUF_ALIGN);\r\nctx->mv_size = 0;\r\n}\r\nctx->dpb_count = s5p_mfc_get_dpb_count();\r\nif (ctx->img_width == 0 || ctx->img_height == 0)\r\nctx->state = MFCINST_ERROR;\r\nelse\r\nctx->state = MFCINST_HEAD_PARSED;\r\n}\r\ns5p_mfc_clear_int_flags(dev);\r\nclear_work_bit(ctx);\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nBUG();\r\ns5p_mfc_clock_off();\r\ns5p_mfc_try_run(dev);\r\nwake_up_ctx(ctx, reason, err);\r\n}\r\nstatic void s5p_mfc_handle_init_buffers(struct s5p_mfc_ctx *ctx,\r\nunsigned int reason, unsigned int err)\r\n{\r\nstruct s5p_mfc_buf *src_buf;\r\nstruct s5p_mfc_dev *dev;\r\nunsigned long flags;\r\nif (ctx == NULL)\r\nreturn;\r\ndev = ctx->dev;\r\ns5p_mfc_clear_int_flags(dev);\r\nctx->int_type = reason;\r\nctx->int_err = err;\r\nctx->int_cond = 1;\r\nspin_lock(&dev->condlock);\r\nclear_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock(&dev->condlock);\r\nif (err == 0) {\r\nctx->state = MFCINST_RUNNING;\r\nif (!ctx->dpb_flush_flag) {\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (!list_empty(&ctx->src_queue)) {\r\nsrc_buf = list_entry(ctx->src_queue.next,\r\nstruct s5p_mfc_buf, list);\r\nlist_del(&src_buf->list);\r\nctx->src_queue_cnt--;\r\nvb2_buffer_done(src_buf->b,\r\nVB2_BUF_STATE_DONE);\r\n}\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n} else {\r\nctx->dpb_flush_flag = 0;\r\n}\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nBUG();\r\ns5p_mfc_clock_off();\r\nwake_up(&ctx->queue);\r\ns5p_mfc_try_run(dev);\r\n} else {\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nBUG();\r\ns5p_mfc_clock_off();\r\nwake_up(&ctx->queue);\r\n}\r\n}\r\nstatic irqreturn_t s5p_mfc_irq(int irq, void *priv)\r\n{\r\nstruct s5p_mfc_dev *dev = priv;\r\nstruct s5p_mfc_ctx *ctx;\r\nunsigned int reason;\r\nunsigned int err;\r\nmfc_debug_enter();\r\natomic_set(&dev->watchdog_cnt, 0);\r\nctx = dev->ctx[dev->curr_ctx];\r\nreason = s5p_mfc_get_int_reason();\r\nerr = s5p_mfc_get_int_err();\r\nmfc_debug(1, "Int reason: %d (err: %08x)\n", reason, err);\r\nswitch (reason) {\r\ncase S5P_FIMV_R2H_CMD_ERR_RET:\r\nif (ctx->state == MFCINST_RUNNING &&\r\ns5p_mfc_err_dec(err) >= S5P_FIMV_ERR_WARNINGS_START)\r\ns5p_mfc_handle_frame(ctx, reason, err);\r\nelse\r\ns5p_mfc_handle_error(ctx, reason, err);\r\nclear_bit(0, &dev->enter_suspend);\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_SLICE_DONE_RET:\r\ncase S5P_FIMV_R2H_CMD_FRAME_DONE_RET:\r\nif (ctx->c_ops->post_frame_start) {\r\nif (ctx->c_ops->post_frame_start(ctx))\r\nmfc_err("post_frame_start() failed\n");\r\ns5p_mfc_clear_int_flags(dev);\r\nwake_up_ctx(ctx, reason, err);\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nBUG();\r\ns5p_mfc_clock_off();\r\ns5p_mfc_try_run(dev);\r\n} else {\r\ns5p_mfc_handle_frame(ctx, reason, err);\r\n}\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_SEQ_DONE_RET:\r\ns5p_mfc_handle_seq_done(ctx, reason, err);\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_OPEN_INSTANCE_RET:\r\nctx->inst_no = s5p_mfc_get_inst_no();\r\nctx->state = MFCINST_GOT_INST;\r\nclear_work_bit(ctx);\r\nwake_up(&ctx->queue);\r\ngoto irq_cleanup_hw;\r\ncase S5P_FIMV_R2H_CMD_CLOSE_INSTANCE_RET:\r\nclear_work_bit(ctx);\r\nctx->state = MFCINST_FREE;\r\nwake_up(&ctx->queue);\r\ngoto irq_cleanup_hw;\r\ncase S5P_FIMV_R2H_CMD_SYS_INIT_RET:\r\ncase S5P_FIMV_R2H_CMD_FW_STATUS_RET:\r\ncase S5P_FIMV_R2H_CMD_SLEEP_RET:\r\ncase S5P_FIMV_R2H_CMD_WAKEUP_RET:\r\nif (ctx)\r\nclear_work_bit(ctx);\r\ns5p_mfc_clear_int_flags(dev);\r\nwake_up_dev(dev, reason, err);\r\nclear_bit(0, &dev->hw_lock);\r\nclear_bit(0, &dev->enter_suspend);\r\nbreak;\r\ncase S5P_FIMV_R2H_CMD_INIT_BUFFERS_RET:\r\ns5p_mfc_handle_init_buffers(ctx, reason, err);\r\nbreak;\r\ndefault:\r\nmfc_debug(2, "Unknown int reason\n");\r\ns5p_mfc_clear_int_flags(dev);\r\n}\r\nmfc_debug_leave();\r\nreturn IRQ_HANDLED;\r\nirq_cleanup_hw:\r\ns5p_mfc_clear_int_flags(dev);\r\nctx->int_type = reason;\r\nctx->int_err = err;\r\nctx->int_cond = 1;\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nmfc_err("Failed to unlock hw\n");\r\ns5p_mfc_clock_off();\r\ns5p_mfc_try_run(dev);\r\nmfc_debug(2, "Exit via irq_cleanup_hw\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s5p_mfc_open(struct file *file)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_ctx *ctx = NULL;\r\nstruct vb2_queue *q;\r\nunsigned long flags;\r\nint ret = 0;\r\nmfc_debug_enter();\r\ndev->num_inst++;\r\nctx = kzalloc(sizeof *ctx, GFP_KERNEL);\r\nif (!ctx) {\r\nmfc_err("Not enough memory\n");\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->dev = dev;\r\nINIT_LIST_HEAD(&ctx->src_queue);\r\nINIT_LIST_HEAD(&ctx->dst_queue);\r\nctx->src_queue_cnt = 0;\r\nctx->dst_queue_cnt = 0;\r\nctx->num = 0;\r\nwhile (dev->ctx[ctx->num]) {\r\nctx->num++;\r\nif (ctx->num >= MFC_NUM_CONTEXTS) {\r\nmfc_err("Too many open contexts\n");\r\nret = -EBUSY;\r\ngoto err_no_ctx;\r\n}\r\n}\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nclear_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\ndev->ctx[ctx->num] = ctx;\r\nif (s5p_mfc_get_node_type(file) == MFCNODE_DECODER) {\r\nctx->type = MFCINST_DECODER;\r\nctx->c_ops = get_dec_codec_ops();\r\nret = s5p_mfc_dec_ctrls_setup(ctx);\r\nif (ret) {\r\nmfc_err("Failed to setup mfc controls\n");\r\ngoto err_ctrls_setup;\r\n}\r\n} else if (s5p_mfc_get_node_type(file) == MFCNODE_ENCODER) {\r\nctx->type = MFCINST_ENCODER;\r\nctx->c_ops = get_enc_codec_ops();\r\nINIT_LIST_HEAD(&ctx->ref_queue);\r\nctx->ref_queue_cnt = 0;\r\nret = s5p_mfc_enc_ctrls_setup(ctx);\r\nif (ret) {\r\nmfc_err("Failed to setup mfc controls\n");\r\ngoto err_ctrls_setup;\r\n}\r\n} else {\r\nret = -ENOENT;\r\ngoto err_bad_node;\r\n}\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nctx->inst_no = -1;\r\nif (dev->num_inst == 1) {\r\ndev->watchdog_timer.expires = jiffies +\r\nmsecs_to_jiffies(MFC_WATCHDOG_INTERVAL);\r\nadd_timer(&dev->watchdog_timer);\r\nret = s5p_mfc_power_on();\r\nif (ret < 0) {\r\nmfc_err("power on failed\n");\r\ngoto err_pwr_enable;\r\n}\r\ns5p_mfc_clock_on();\r\nret = s5p_mfc_alloc_and_load_firmware(dev);\r\nif (ret)\r\ngoto err_alloc_fw;\r\nret = s5p_mfc_init_hw(dev);\r\nif (ret)\r\ngoto err_init_hw;\r\ns5p_mfc_clock_off();\r\n}\r\nq = &ctx->vq_dst;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\nq->drv_priv = &ctx->fh;\r\nif (s5p_mfc_get_node_type(file) == MFCNODE_DECODER) {\r\nq->io_modes = VB2_MMAP;\r\nq->ops = get_dec_queue_ops();\r\n} else if (s5p_mfc_get_node_type(file) == MFCNODE_ENCODER) {\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->ops = get_enc_queue_ops();\r\n} else {\r\nret = -ENOENT;\r\ngoto err_queue_init;\r\n}\r\nq->mem_ops = (struct vb2_mem_ops *)&vb2_dma_contig_memops;\r\nret = vb2_queue_init(q);\r\nif (ret) {\r\nmfc_err("Failed to initialize videobuf2 queue(capture)\n");\r\ngoto err_queue_init;\r\n}\r\nq = &ctx->vq_src;\r\nq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nq->io_modes = VB2_MMAP;\r\nq->drv_priv = &ctx->fh;\r\nif (s5p_mfc_get_node_type(file) == MFCNODE_DECODER) {\r\nq->io_modes = VB2_MMAP;\r\nq->ops = get_dec_queue_ops();\r\n} else if (s5p_mfc_get_node_type(file) == MFCNODE_ENCODER) {\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->ops = get_enc_queue_ops();\r\n} else {\r\nret = -ENOENT;\r\ngoto err_queue_init;\r\n}\r\nq->mem_ops = (struct vb2_mem_ops *)&vb2_dma_contig_memops;\r\nret = vb2_queue_init(q);\r\nif (ret) {\r\nmfc_err("Failed to initialize videobuf2 queue(output)\n");\r\ngoto err_queue_init;\r\n}\r\ninit_waitqueue_head(&ctx->queue);\r\nmfc_debug_leave();\r\nreturn ret;\r\nerr_queue_init:\r\nerr_init_hw:\r\ns5p_mfc_release_firmware(dev);\r\nerr_alloc_fw:\r\ndev->ctx[ctx->num] = NULL;\r\ndel_timer_sync(&dev->watchdog_timer);\r\ns5p_mfc_clock_off();\r\nerr_pwr_enable:\r\nif (dev->num_inst == 1) {\r\nif (s5p_mfc_power_off() < 0)\r\nmfc_err("power off failed\n");\r\ns5p_mfc_release_firmware(dev);\r\n}\r\nerr_ctrls_setup:\r\ns5p_mfc_dec_ctrls_delete(ctx);\r\nerr_bad_node:\r\nerr_no_ctx:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nerr_alloc:\r\ndev->num_inst--;\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int s5p_mfc_release(struct file *file)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nmfc_debug_enter();\r\ns5p_mfc_clock_on();\r\nvb2_queue_release(&ctx->vq_src);\r\nvb2_queue_release(&ctx->vq_dst);\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nclear_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\nif (ctx->inst_no != MFC_NO_INSTANCE_SET) {\r\nmfc_debug(2, "Has to free instance\n");\r\nctx->state = MFCINST_RETURN_INST;\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nset_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_try_run(dev);\r\nif (s5p_mfc_wait_for_done_ctx\r\n(ctx, S5P_FIMV_R2H_CMD_CLOSE_INSTANCE_RET, 0)) {\r\ns5p_mfc_clock_off();\r\nmfc_err("Err returning instance\n");\r\n}\r\nmfc_debug(2, "After free instance\n");\r\ns5p_mfc_release_codec_buffers(ctx);\r\ns5p_mfc_release_instance_buffer(ctx);\r\nif (ctx->type == MFCINST_DECODER)\r\ns5p_mfc_release_dec_desc_buffer(ctx);\r\nctx->inst_no = MFC_NO_INSTANCE_SET;\r\n}\r\nif (dev->curr_ctx == ctx->num)\r\nclear_bit(0, &dev->hw_lock);\r\ndev->num_inst--;\r\nif (dev->num_inst == 0) {\r\nmfc_debug(2, "Last instance - release firmware\n");\r\ns5p_mfc_reset(dev);\r\ns5p_mfc_release_firmware(dev);\r\ndel_timer_sync(&dev->watchdog_timer);\r\nif (s5p_mfc_power_off() < 0)\r\nmfc_err("Power off failed\n");\r\n}\r\nmfc_debug(2, "Shutting down clock\n");\r\ns5p_mfc_clock_off();\r\ndev->ctx[ctx->num] = NULL;\r\ns5p_mfc_dec_ctrls_delete(ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nmfc_debug_leave();\r\nreturn 0;\r\n}\r\nstatic unsigned int s5p_mfc_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct vb2_queue *src_q, *dst_q;\r\nstruct vb2_buffer *src_vb = NULL, *dst_vb = NULL;\r\nunsigned int rc = 0;\r\nunsigned long flags;\r\nsrc_q = &ctx->vq_src;\r\ndst_q = &ctx->vq_dst;\r\nif ((!src_q->streaming || list_empty(&src_q->queued_list))\r\n&& (!dst_q->streaming || list_empty(&dst_q->queued_list))) {\r\nrc = POLLERR;\r\ngoto end;\r\n}\r\nmutex_unlock(&dev->mfc_mutex);\r\npoll_wait(file, &src_q->done_wq, wait);\r\npoll_wait(file, &dst_q->done_wq, wait);\r\nmutex_lock(&dev->mfc_mutex);\r\nspin_lock_irqsave(&src_q->done_lock, flags);\r\nif (!list_empty(&src_q->done_list))\r\nsrc_vb = list_first_entry(&src_q->done_list, struct vb2_buffer,\r\ndone_entry);\r\nif (src_vb && (src_vb->state == VB2_BUF_STATE_DONE\r\n|| src_vb->state == VB2_BUF_STATE_ERROR))\r\nrc |= POLLOUT | POLLWRNORM;\r\nspin_unlock_irqrestore(&src_q->done_lock, flags);\r\nspin_lock_irqsave(&dst_q->done_lock, flags);\r\nif (!list_empty(&dst_q->done_list))\r\ndst_vb = list_first_entry(&dst_q->done_list, struct vb2_buffer,\r\ndone_entry);\r\nif (dst_vb && (dst_vb->state == VB2_BUF_STATE_DONE\r\n|| dst_vb->state == VB2_BUF_STATE_ERROR))\r\nrc |= POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&dst_q->done_lock, flags);\r\nend:\r\nreturn rc;\r\n}\r\nstatic int s5p_mfc_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nint ret;\r\nif (offset < DST_QUEUE_OFF_BASE) {\r\nmfc_debug(2, "mmaping source\n");\r\nret = vb2_mmap(&ctx->vq_src, vma);\r\n} else {\r\nmfc_debug(2, "mmaping destination\n");\r\nvma->vm_pgoff -= (DST_QUEUE_OFF_BASE >> PAGE_SHIFT);\r\nret = vb2_mmap(&ctx->vq_dst, vma);\r\n}\r\nreturn ret;\r\n}\r\nstatic int match_child(struct device *dev, void *data)\r\n{\r\nif (!dev_name(dev))\r\nreturn 0;\r\nreturn !strcmp(dev_name(dev), (char *)data);\r\n}\r\nstatic int s5p_mfc_probe(struct platform_device *pdev)\r\n{\r\nstruct s5p_mfc_dev *dev;\r\nstruct video_device *vfd;\r\nstruct resource *res;\r\nint ret;\r\npr_debug("%s++\n", __func__);\r\ndev = devm_kzalloc(&pdev->dev, sizeof *dev, GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&pdev->dev, "Not enough memory for MFC device\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&dev->irqlock);\r\nspin_lock_init(&dev->condlock);\r\ndev->plat_dev = pdev;\r\nif (!dev->plat_dev) {\r\ndev_err(&pdev->dev, "No platform data specified\n");\r\nreturn -ENODEV;\r\n}\r\nret = s5p_mfc_init_pm(dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get mfc clock source\n");\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->regs_base = devm_request_and_ioremap(&pdev->dev, res);\r\nif (dev->regs_base == NULL) {\r\ndev_err(&pdev->dev, "Failed to obtain io memory\n");\r\nreturn -ENOENT;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get irq resource\n");\r\nret = -ENOENT;\r\ngoto err_res;\r\n}\r\ndev->irq = res->start;\r\nret = devm_request_irq(&pdev->dev, dev->irq, s5p_mfc_irq,\r\nIRQF_DISABLED, pdev->name, dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to install irq (%d)\n", ret);\r\ngoto err_res;\r\n}\r\ndev->mem_dev_l = device_find_child(&dev->plat_dev->dev, "s5p-mfc-l",\r\nmatch_child);\r\nif (!dev->mem_dev_l) {\r\nmfc_err("Mem child (L) device get failed\n");\r\nret = -ENODEV;\r\ngoto err_res;\r\n}\r\ndev->mem_dev_r = device_find_child(&dev->plat_dev->dev, "s5p-mfc-r",\r\nmatch_child);\r\nif (!dev->mem_dev_r) {\r\nmfc_err("Mem child (R) device get failed\n");\r\nret = -ENODEV;\r\ngoto err_res;\r\n}\r\ndev->alloc_ctx[0] = vb2_dma_contig_init_ctx(dev->mem_dev_l);\r\nif (IS_ERR_OR_NULL(dev->alloc_ctx[0])) {\r\nret = PTR_ERR(dev->alloc_ctx[0]);\r\ngoto err_res;\r\n}\r\ndev->alloc_ctx[1] = vb2_dma_contig_init_ctx(dev->mem_dev_r);\r\nif (IS_ERR_OR_NULL(dev->alloc_ctx[1])) {\r\nret = PTR_ERR(dev->alloc_ctx[1]);\r\ngoto err_mem_init_ctx_1;\r\n}\r\nmutex_init(&dev->mfc_mutex);\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret)\r\ngoto err_v4l2_dev_reg;\r\ninit_waitqueue_head(&dev->queue);\r\nvfd = video_device_alloc();\r\nif (!vfd) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto err_dec_alloc;\r\n}\r\nvfd->fops = &s5p_mfc_fops,\r\nvfd->ioctl_ops = get_dec_v4l2_ioctl_ops();\r\nvfd->release = video_device_release,\r\nvfd->lock = &dev->mfc_mutex;\r\nset_bit(V4L2_FL_LOCK_ALL_FOPS, &vfd->flags);\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s", S5P_MFC_DEC_NAME);\r\ndev->vfd_dec = vfd;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to register video device\n");\r\nvideo_device_release(vfd);\r\ngoto err_dec_reg;\r\n}\r\nv4l2_info(&dev->v4l2_dev,\r\n"decoder registered as /dev/video%d\n", vfd->num);\r\nvideo_set_drvdata(vfd, dev);\r\nvfd = video_device_alloc();\r\nif (!vfd) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto err_enc_alloc;\r\n}\r\nvfd->fops = &s5p_mfc_fops,\r\nvfd->ioctl_ops = get_enc_v4l2_ioctl_ops();\r\nvfd->release = video_device_release,\r\nvfd->lock = &dev->mfc_mutex;\r\nset_bit(V4L2_FL_LOCK_ALL_FOPS, &vfd->flags);\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s", S5P_MFC_ENC_NAME);\r\ndev->vfd_enc = vfd;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to register video device\n");\r\nvideo_device_release(vfd);\r\ngoto err_enc_reg;\r\n}\r\nv4l2_info(&dev->v4l2_dev,\r\n"encoder registered as /dev/video%d\n", vfd->num);\r\nvideo_set_drvdata(vfd, dev);\r\nplatform_set_drvdata(pdev, dev);\r\ndev->hw_lock = 0;\r\ndev->watchdog_workqueue = create_singlethread_workqueue(S5P_MFC_NAME);\r\nINIT_WORK(&dev->watchdog_work, s5p_mfc_watchdog_worker);\r\natomic_set(&dev->watchdog_cnt, 0);\r\ninit_timer(&dev->watchdog_timer);\r\ndev->watchdog_timer.data = (unsigned long)dev;\r\ndev->watchdog_timer.function = s5p_mfc_watchdog;\r\npr_debug("%s--\n", __func__);\r\nreturn 0;\r\nerr_enc_reg:\r\nvideo_device_release(dev->vfd_enc);\r\nerr_enc_alloc:\r\nvideo_unregister_device(dev->vfd_dec);\r\nerr_dec_reg:\r\nvideo_device_release(dev->vfd_dec);\r\nerr_dec_alloc:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nerr_v4l2_dev_reg:\r\nvb2_dma_contig_cleanup_ctx(dev->alloc_ctx[1]);\r\nerr_mem_init_ctx_1:\r\nvb2_dma_contig_cleanup_ctx(dev->alloc_ctx[0]);\r\nerr_res:\r\ns5p_mfc_final_pm(dev);\r\npr_debug("%s-- with error\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int __devexit s5p_mfc_remove(struct platform_device *pdev)\r\n{\r\nstruct s5p_mfc_dev *dev = platform_get_drvdata(pdev);\r\nv4l2_info(&dev->v4l2_dev, "Removing %s\n", pdev->name);\r\ndel_timer_sync(&dev->watchdog_timer);\r\nflush_workqueue(dev->watchdog_workqueue);\r\ndestroy_workqueue(dev->watchdog_workqueue);\r\nvideo_unregister_device(dev->vfd_enc);\r\nvideo_unregister_device(dev->vfd_dec);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nvb2_dma_contig_cleanup_ctx(dev->alloc_ctx[0]);\r\nvb2_dma_contig_cleanup_ctx(dev->alloc_ctx[1]);\r\ns5p_mfc_final_pm(dev);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s5p_mfc_dev *m_dev = platform_get_drvdata(pdev);\r\nint ret;\r\nif (m_dev->num_inst == 0)\r\nreturn 0;\r\nreturn s5p_mfc_sleep(m_dev);\r\nif (test_and_set_bit(0, &m_dev->enter_suspend) != 0) {\r\nmfc_err("Error: going to suspend for a second time\n");\r\nreturn -EIO;\r\n}\r\nwhile (test_and_set_bit(0, &m_dev->hw_lock) != 0) {\r\nret = wait_event_interruptible_timeout(m_dev->queue,\r\nm_dev->int_cond || m_dev->ctx[m_dev->curr_ctx]->int_cond,\r\nmsecs_to_jiffies(MFC_INT_TIMEOUT));\r\nif (ret == 0) {\r\nmfc_err("Waiting for hardware to finish timed out\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s5p_mfc_dev *m_dev = platform_get_drvdata(pdev);\r\nif (m_dev->num_inst == 0)\r\nreturn 0;\r\nreturn s5p_mfc_wakeup(m_dev);\r\n}\r\nstatic int s5p_mfc_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s5p_mfc_dev *m_dev = platform_get_drvdata(pdev);\r\natomic_set(&m_dev->pm.power, 0);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s5p_mfc_dev *m_dev = platform_get_drvdata(pdev);\r\nint pre_power;\r\nif (!m_dev->alloc_ctx)\r\nreturn 0;\r\npre_power = atomic_read(&m_dev->pm.power);\r\natomic_set(&m_dev->pm.power, 1);\r\nreturn 0;\r\n}
