struct ab8500_fg *ab8500_fg_get(void)\r\n{\r\nstruct ab8500_fg *fg;\r\nif (list_empty(&ab8500_fg_list))\r\nreturn NULL;\r\nfg = list_first_entry(&ab8500_fg_list, struct ab8500_fg, node);\r\nreturn fg;\r\n}\r\nstatic u8 ab8500_volt_to_regval(int voltage)\r\n{\r\nint i;\r\nif (voltage < ab8500_fg_lowbat_voltage_map[0])\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_fg_lowbat_voltage_map); i++) {\r\nif (voltage < ab8500_fg_lowbat_voltage_map[i])\r\nreturn (u8) i - 1;\r\n}\r\nreturn (u8) ARRAY_SIZE(ab8500_fg_lowbat_voltage_map) - 1;\r\n}\r\nstatic int ab8500_fg_is_low_curr(struct ab8500_fg *di, int curr)\r\n{\r\nif (curr > -di->bat->fg_params->high_curr_threshold)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int ab8500_fg_add_cap_sample(struct ab8500_fg *di, int sample)\r\n{\r\nstruct timespec ts;\r\nstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\r\ngetnstimeofday(&ts);\r\ndo {\r\navg->sum += sample - avg->samples[avg->pos];\r\navg->samples[avg->pos] = sample;\r\navg->time_stamps[avg->pos] = ts.tv_sec;\r\navg->pos++;\r\nif (avg->pos == NBR_AVG_SAMPLES)\r\navg->pos = 0;\r\nif (avg->nbr_samples < NBR_AVG_SAMPLES)\r\navg->nbr_samples++;\r\n} while (ts.tv_sec - VALID_CAPACITY_SEC > avg->time_stamps[avg->pos]);\r\navg->avg = avg->sum / avg->nbr_samples;\r\nreturn avg->avg;\r\n}\r\nstatic void ab8500_fg_clear_cap_samples(struct ab8500_fg *di)\r\n{\r\nint i;\r\nstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\r\navg->pos = 0;\r\navg->nbr_samples = 0;\r\navg->sum = 0;\r\navg->avg = 0;\r\nfor (i = 0; i < NBR_AVG_SAMPLES; i++) {\r\navg->samples[i] = 0;\r\navg->time_stamps[i] = 0;\r\n}\r\n}\r\nstatic void ab8500_fg_fill_cap_sample(struct ab8500_fg *di, int sample)\r\n{\r\nint i;\r\nstruct timespec ts;\r\nstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\r\ngetnstimeofday(&ts);\r\nfor (i = 0; i < NBR_AVG_SAMPLES; i++) {\r\navg->samples[i] = sample;\r\navg->time_stamps[i] = ts.tv_sec;\r\n}\r\navg->pos = 0;\r\navg->nbr_samples = NBR_AVG_SAMPLES;\r\navg->sum = sample * NBR_AVG_SAMPLES;\r\navg->avg = sample;\r\n}\r\nstatic int ab8500_fg_coulomb_counter(struct ab8500_fg *di, bool enable)\r\n{\r\nint ret = 0;\r\nmutex_lock(&di->cc_lock);\r\nif (enable) {\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG, 0x00);\r\nif (ret)\r\ngoto cc_err;\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU,\r\ndi->fg_samples);\r\nif (ret)\r\ngoto cc_err;\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG,\r\n(CC_DEEP_SLEEP_ENA | CC_PWR_UP_ENA));\r\nif (ret)\r\ngoto cc_err;\r\ndi->flags.fg_enabled = true;\r\n} else {\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG, 0);\r\nif (ret)\r\ngoto cc_err;\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU_CTRL, 0);\r\nif (ret)\r\ngoto cc_err;\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG, 0);\r\nif (ret)\r\ngoto cc_err;\r\ndi->flags.fg_enabled = false;\r\n}\r\ndev_dbg(di->dev, " CC enabled: %d Samples: %d\n",\r\nenable, di->fg_samples);\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\ncc_err:\r\ndev_err(di->dev, "%s Enabling coulomb counter failed\n", __func__);\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\n}\r\nint ab8500_fg_inst_curr_start(struct ab8500_fg *di)\r\n{\r\nu8 reg_val;\r\nint ret;\r\nmutex_lock(&di->cc_lock);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG, &reg_val);\r\nif (ret < 0)\r\ngoto fail;\r\nif (!(reg_val & CC_PWR_UP_ENA)) {\r\ndev_dbg(di->dev, "%s Enable FG\n", __func__);\r\ndi->turn_off_fg = true;\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU,\r\nSEC_TO_SAMPLE(10));\r\nif (ret)\r\ngoto fail;\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG,\r\n(CC_DEEP_SLEEP_ENA | CC_PWR_UP_ENA));\r\nif (ret)\r\ngoto fail;\r\n} else {\r\ndi->turn_off_fg = false;\r\n}\r\nINIT_COMPLETION(di->ab8500_fg_complete);\r\nenable_irq(di->irq);\r\nreturn 0;\r\nfail:\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\n}\r\nint ab8500_fg_inst_curr_done(struct ab8500_fg *di)\r\n{\r\nreturn completion_done(&di->ab8500_fg_complete);\r\n}\r\nint ab8500_fg_inst_curr_finalize(struct ab8500_fg *di, int *res)\r\n{\r\nu8 low, high;\r\nint val;\r\nint ret;\r\nint timeout;\r\nif (!completion_done(&di->ab8500_fg_complete)) {\r\ntimeout = wait_for_completion_timeout(&di->ab8500_fg_complete,\r\nINS_CURR_TIMEOUT);\r\ndev_dbg(di->dev, "Finalize time: %d ms\n",\r\n((INS_CURR_TIMEOUT - timeout) * 1000) / HZ);\r\nif (!timeout) {\r\nret = -ETIME;\r\ndisable_irq(di->irq);\r\ndev_err(di->dev, "completion timed out [%d]\n",\r\n__LINE__);\r\ngoto fail;\r\n}\r\n}\r\ndisable_irq(di->irq);\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\nREAD_REQ, READ_REQ);\r\nusleep_range(100, 100);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_SMPL_CNVL_REG, &low);\r\nif (ret < 0)\r\ngoto fail;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_SMPL_CNVH_REG, &high);\r\nif (ret < 0)\r\ngoto fail;\r\nif (high & 0x10)\r\nval = (low | (high << 8) | 0xFFFFE000);\r\nelse\r\nval = (low | (high << 8));\r\nval = (val * QLSB_NANO_AMP_HOURS_X10 * 36 * 4) /\r\n(1000 * di->bat->fg_res);\r\nif (di->turn_off_fg) {\r\ndev_dbg(di->dev, "%s Disable FG\n", __func__);\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG, 0);\r\nif (ret)\r\ngoto fail;\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG, 0);\r\nif (ret)\r\ngoto fail;\r\n}\r\nmutex_unlock(&di->cc_lock);\r\n(*res) = val;\r\nreturn 0;\r\nfail:\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\n}\r\nint ab8500_fg_inst_curr_blocking(struct ab8500_fg *di)\r\n{\r\nint ret;\r\nint res = 0;\r\nret = ab8500_fg_inst_curr_start(di);\r\nif (ret) {\r\ndev_err(di->dev, "Failed to initialize fg_inst\n");\r\nreturn 0;\r\n}\r\nret = ab8500_fg_inst_curr_finalize(di, &res);\r\nif (ret) {\r\ndev_err(di->dev, "Failed to finalize fg_inst\n");\r\nreturn 0;\r\n}\r\nreturn res;\r\n}\r\nstatic void ab8500_fg_acc_cur_work(struct work_struct *work)\r\n{\r\nint val;\r\nint ret;\r\nu8 low, med, high;\r\nstruct ab8500_fg *di = container_of(work,\r\nstruct ab8500_fg, fg_acc_cur_work);\r\nmutex_lock(&di->cc_lock);\r\nret = abx500_set_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_NCOV_ACCU_CTRL, RD_NCONV_ACCU_REQ);\r\nif (ret)\r\ngoto exit;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_NCOV_ACCU_LOW, &low);\r\nif (ret < 0)\r\ngoto exit;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_NCOV_ACCU_MED, &med);\r\nif (ret < 0)\r\ngoto exit;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_NCOV_ACCU_HIGH, &high);\r\nif (ret < 0)\r\ngoto exit;\r\nif (high & 0x10)\r\nval = (low | (med << 8) | (high << 16) | 0xFFE00000);\r\nelse\r\nval = (low | (med << 8) | (high << 16));\r\ndi->accu_charge = (val * QLSB_NANO_AMP_HOURS_X10) /\r\n(100 * di->bat->fg_res);\r\ndi->avg_curr = (val * QLSB_NANO_AMP_HOURS_X10 * 36) /\r\n(1000 * di->bat->fg_res * (di->fg_samples / 4));\r\ndi->flags.conv_done = true;\r\nmutex_unlock(&di->cc_lock);\r\nqueue_work(di->fg_wq, &di->fg_work);\r\nreturn;\r\nexit:\r\ndev_err(di->dev,\r\n"Failed to read or write gas gauge registers\n");\r\nmutex_unlock(&di->cc_lock);\r\nqueue_work(di->fg_wq, &di->fg_work);\r\n}\r\nstatic int ab8500_fg_bat_voltage(struct ab8500_fg *di)\r\n{\r\nint vbat;\r\nstatic int prev;\r\nvbat = ab8500_gpadc_convert(di->gpadc, MAIN_BAT_V);\r\nif (vbat < 0) {\r\ndev_err(di->dev,\r\n"%s gpadc conversion failed, using previous value\n",\r\n__func__);\r\nreturn prev;\r\n}\r\nprev = vbat;\r\nreturn vbat;\r\n}\r\nstatic int ab8500_fg_volt_to_capacity(struct ab8500_fg *di, int voltage)\r\n{\r\nint i, tbl_size;\r\nstruct abx500_v_to_cap *tbl;\r\nint cap = 0;\r\ntbl = di->bat->bat_type[di->bat->batt_id].v_to_cap_tbl,\r\ntbl_size = di->bat->bat_type[di->bat->batt_id].n_v_cap_tbl_elements;\r\nfor (i = 0; i < tbl_size; ++i) {\r\nif (voltage > tbl[i].voltage)\r\nbreak;\r\n}\r\nif ((i > 0) && (i < tbl_size)) {\r\ncap = interpolate(voltage,\r\ntbl[i].voltage,\r\ntbl[i].capacity * 10,\r\ntbl[i-1].voltage,\r\ntbl[i-1].capacity * 10);\r\n} else if (i == 0) {\r\ncap = 1000;\r\n} else {\r\ncap = 0;\r\n}\r\ndev_dbg(di->dev, "%s Vbat: %d, Cap: %d per mille",\r\n__func__, voltage, cap);\r\nreturn cap;\r\n}\r\nstatic int ab8500_fg_uncomp_volt_to_capacity(struct ab8500_fg *di)\r\n{\r\ndi->vbat = ab8500_fg_bat_voltage(di);\r\nreturn ab8500_fg_volt_to_capacity(di, di->vbat);\r\n}\r\nstatic int ab8500_fg_battery_resistance(struct ab8500_fg *di)\r\n{\r\nint i, tbl_size;\r\nstruct batres_vs_temp *tbl;\r\nint resist = 0;\r\ntbl = di->bat->bat_type[di->bat->batt_id].batres_tbl;\r\ntbl_size = di->bat->bat_type[di->bat->batt_id].n_batres_tbl_elements;\r\nfor (i = 0; i < tbl_size; ++i) {\r\nif (di->bat_temp / 10 > tbl[i].temp)\r\nbreak;\r\n}\r\nif ((i > 0) && (i < tbl_size)) {\r\nresist = interpolate(di->bat_temp / 10,\r\ntbl[i].temp,\r\ntbl[i].resist,\r\ntbl[i-1].temp,\r\ntbl[i-1].resist);\r\n} else if (i == 0) {\r\nresist = tbl[0].resist;\r\n} else {\r\nresist = tbl[tbl_size - 1].resist;\r\n}\r\ndev_dbg(di->dev, "%s Temp: %d battery internal resistance: %d"\r\n" fg resistance %d, total: %d (mOhm)\n",\r\n__func__, di->bat_temp, resist, di->bat->fg_res / 10,\r\n(di->bat->fg_res / 10) + resist);\r\nresist += di->bat->fg_res / 10;\r\nreturn resist;\r\n}\r\nstatic int ab8500_fg_load_comp_volt_to_capacity(struct ab8500_fg *di)\r\n{\r\nint vbat_comp, res;\r\nint i = 0;\r\nint vbat = 0;\r\nab8500_fg_inst_curr_start(di);\r\ndo {\r\nvbat += ab8500_fg_bat_voltage(di);\r\ni++;\r\nmsleep(5);\r\n} while (!ab8500_fg_inst_curr_done(di));\r\nab8500_fg_inst_curr_finalize(di, &di->inst_curr);\r\ndi->vbat = vbat / i;\r\nres = ab8500_fg_battery_resistance(di);\r\nvbat_comp = di->vbat - (di->inst_curr * res) / 1000;\r\ndev_dbg(di->dev, "%s Measured Vbat: %dmV,Compensated Vbat %dmV, "\r\n"R: %dmOhm, Current: %dmA Vbat Samples: %d\n",\r\n__func__, di->vbat, vbat_comp, res, di->inst_curr, i);\r\nreturn ab8500_fg_volt_to_capacity(di, vbat_comp);\r\n}\r\nstatic int ab8500_fg_convert_mah_to_permille(struct ab8500_fg *di, int cap_mah)\r\n{\r\nreturn (cap_mah * 1000) / di->bat_cap.max_mah_design;\r\n}\r\nstatic int ab8500_fg_convert_permille_to_mah(struct ab8500_fg *di, int cap_pm)\r\n{\r\nreturn cap_pm * di->bat_cap.max_mah_design / 1000;\r\n}\r\nstatic int ab8500_fg_convert_mah_to_uwh(struct ab8500_fg *di, int cap_mah)\r\n{\r\nu64 div_res;\r\nu32 div_rem;\r\ndiv_res = ((u64) cap_mah) * ((u64) di->vbat_nom);\r\ndiv_rem = do_div(div_res, 1000);\r\nif (div_rem >= 1000 / 2)\r\ndiv_res++;\r\nreturn (int) div_res;\r\n}\r\nstatic int ab8500_fg_calc_cap_charging(struct ab8500_fg *di)\r\n{\r\ndev_dbg(di->dev, "%s cap_mah %d accu_charge %d\n",\r\n__func__,\r\ndi->bat_cap.mah,\r\ndi->accu_charge);\r\nif (di->bat_cap.mah + di->accu_charge > 0)\r\ndi->bat_cap.mah += di->accu_charge;\r\nelse\r\ndi->bat_cap.mah = 0;\r\nif (di->bat_cap.mah >= di->bat_cap.max_mah_design ||\r\ndi->flags.force_full) {\r\ndi->bat_cap.mah = di->bat_cap.max_mah_design;\r\n}\r\nab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\r\ndi->bat_cap.permille =\r\nab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\r\ndi->vbat = ab8500_fg_bat_voltage(di);\r\ndi->inst_curr = ab8500_fg_inst_curr_blocking(di);\r\nreturn di->bat_cap.mah;\r\n}\r\nstatic int ab8500_fg_calc_cap_discharge_voltage(struct ab8500_fg *di, bool comp)\r\n{\r\nint permille, mah;\r\nif (comp)\r\npermille = ab8500_fg_load_comp_volt_to_capacity(di);\r\nelse\r\npermille = ab8500_fg_uncomp_volt_to_capacity(di);\r\nmah = ab8500_fg_convert_permille_to_mah(di, permille);\r\ndi->bat_cap.mah = ab8500_fg_add_cap_sample(di, mah);\r\ndi->bat_cap.permille =\r\nab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\r\nreturn di->bat_cap.mah;\r\n}\r\nstatic int ab8500_fg_calc_cap_discharge_fg(struct ab8500_fg *di)\r\n{\r\nint permille_volt, permille;\r\ndev_dbg(di->dev, "%s cap_mah %d accu_charge %d\n",\r\n__func__,\r\ndi->bat_cap.mah,\r\ndi->accu_charge);\r\nif (di->bat_cap.mah + di->accu_charge > 0)\r\ndi->bat_cap.mah += di->accu_charge;\r\nelse\r\ndi->bat_cap.mah = 0;\r\nif (di->bat_cap.mah >= di->bat_cap.max_mah_design)\r\ndi->bat_cap.mah = di->bat_cap.max_mah_design;\r\npermille = ab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\r\npermille_volt = ab8500_fg_uncomp_volt_to_capacity(di);\r\nif (permille < permille_volt) {\r\ndi->bat_cap.permille = permille_volt;\r\ndi->bat_cap.mah = ab8500_fg_convert_permille_to_mah(di,\r\ndi->bat_cap.permille);\r\ndev_dbg(di->dev, "%s voltage based: perm %d perm_volt %d\n",\r\n__func__,\r\npermille,\r\npermille_volt);\r\nab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\r\n} else {\r\nab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\r\ndi->bat_cap.permille =\r\nab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\r\n}\r\nreturn di->bat_cap.mah;\r\n}\r\nstatic int ab8500_fg_capacity_level(struct ab8500_fg *di)\r\n{\r\nint ret, percent;\r\npercent = di->bat_cap.permille / 10;\r\nif (percent <= di->bat->cap_levels->critical ||\r\ndi->flags.low_bat)\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\r\nelse if (percent <= di->bat->cap_levels->low)\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\r\nelse if (percent <= di->bat->cap_levels->normal)\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\r\nelse if (percent <= di->bat->cap_levels->high)\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_HIGH;\r\nelse\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\r\nreturn ret;\r\n}\r\nstatic void ab8500_fg_check_capacity_limits(struct ab8500_fg *di, bool init)\r\n{\r\nbool changed = false;\r\ndi->bat_cap.level = ab8500_fg_capacity_level(di);\r\nif (di->bat_cap.level != di->bat_cap.prev_level) {\r\nif (!(!di->flags.charging && di->bat_cap.level >\r\ndi->bat_cap.prev_level) || init) {\r\ndev_dbg(di->dev, "level changed from %d to %d\n",\r\ndi->bat_cap.prev_level,\r\ndi->bat_cap.level);\r\ndi->bat_cap.prev_level = di->bat_cap.level;\r\nchanged = true;\r\n} else {\r\ndev_dbg(di->dev, "level not allowed to go up "\r\n"since no charger is connected: %d to %d\n",\r\ndi->bat_cap.prev_level,\r\ndi->bat_cap.level);\r\n}\r\n}\r\nif (di->flags.low_bat) {\r\ndev_dbg(di->dev, "Battery low, set capacity to 0\n");\r\ndi->bat_cap.prev_percent = 0;\r\ndi->bat_cap.permille = 0;\r\ndi->bat_cap.prev_mah = 0;\r\ndi->bat_cap.mah = 0;\r\nchanged = true;\r\n} else if (di->flags.fully_charged) {\r\nif (di->flags.force_full) {\r\ndi->bat_cap.prev_percent = di->bat_cap.permille / 10;\r\ndi->bat_cap.prev_mah = di->bat_cap.mah;\r\n} else if (!di->flags.force_full &&\r\ndi->bat_cap.prev_percent !=\r\n(di->bat_cap.permille) / 10 &&\r\n(di->bat_cap.permille / 10) <\r\ndi->bat->fg_params->maint_thres) {\r\ndev_dbg(di->dev,\r\n"battery reported full "\r\n"but capacity dropping: %d\n",\r\ndi->bat_cap.permille / 10);\r\ndi->bat_cap.prev_percent = di->bat_cap.permille / 10;\r\ndi->bat_cap.prev_mah = di->bat_cap.mah;\r\nchanged = true;\r\n}\r\n} else if (di->bat_cap.prev_percent != di->bat_cap.permille / 10) {\r\nif (di->bat_cap.permille / 10 == 0) {\r\ndi->bat_cap.prev_percent = 1;\r\ndi->bat_cap.permille = 1;\r\ndi->bat_cap.prev_mah = 1;\r\ndi->bat_cap.mah = 1;\r\nchanged = true;\r\n} else if (!(!di->flags.charging &&\r\n(di->bat_cap.permille / 10) >\r\ndi->bat_cap.prev_percent) || init) {\r\ndev_dbg(di->dev,\r\n"capacity changed from %d to %d (%d)\n",\r\ndi->bat_cap.prev_percent,\r\ndi->bat_cap.permille / 10,\r\ndi->bat_cap.permille);\r\ndi->bat_cap.prev_percent = di->bat_cap.permille / 10;\r\ndi->bat_cap.prev_mah = di->bat_cap.mah;\r\nchanged = true;\r\n} else {\r\ndev_dbg(di->dev, "capacity not allowed to go up since "\r\n"no charger is connected: %d to %d (%d)\n",\r\ndi->bat_cap.prev_percent,\r\ndi->bat_cap.permille / 10,\r\ndi->bat_cap.permille);\r\n}\r\n}\r\nif (changed) {\r\npower_supply_changed(&di->fg_psy);\r\nif (di->flags.fully_charged && di->flags.force_full) {\r\ndev_dbg(di->dev, "Battery full, notifying.\n");\r\ndi->flags.force_full = false;\r\nsysfs_notify(&di->fg_kobject, NULL, "charge_full");\r\n}\r\nsysfs_notify(&di->fg_kobject, NULL, "charge_now");\r\n}\r\n}\r\nstatic void ab8500_fg_charge_state_to(struct ab8500_fg *di,\r\nenum ab8500_fg_charge_state new_state)\r\n{\r\ndev_dbg(di->dev, "Charge state from %d [%s] to %d [%s]\n",\r\ndi->charge_state,\r\ncharge_state[di->charge_state],\r\nnew_state,\r\ncharge_state[new_state]);\r\ndi->charge_state = new_state;\r\n}\r\nstatic void ab8500_fg_discharge_state_to(struct ab8500_fg *di,\r\nenum ab8500_fg_discharge_state new_state)\r\n{\r\ndev_dbg(di->dev, "Disharge state from %d [%s] to %d [%s]\n",\r\ndi->discharge_state,\r\ndischarge_state[di->discharge_state],\r\nnew_state,\r\ndischarge_state[new_state]);\r\ndi->discharge_state = new_state;\r\n}\r\nstatic void ab8500_fg_algorithm_charging(struct ab8500_fg *di)\r\n{\r\nif (di->discharge_state != AB8500_FG_DISCHARGE_INIT_RECOVERY)\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_INIT_RECOVERY);\r\nswitch (di->charge_state) {\r\ncase AB8500_FG_CHARGE_INIT:\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bat->fg_params->accu_charging);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_READOUT);\r\nbreak;\r\ncase AB8500_FG_CHARGE_READOUT:\r\nmutex_lock(&di->cc_lock);\r\nif (!di->flags.conv_done) {\r\nmutex_unlock(&di->cc_lock);\r\ndev_dbg(di->dev, "%s CC conv not done\n",\r\n__func__);\r\nbreak;\r\n}\r\ndi->flags.conv_done = false;\r\nmutex_unlock(&di->cc_lock);\r\nab8500_fg_calc_cap_charging(di);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nab8500_fg_check_capacity_limits(di, false);\r\n}\r\nstatic void force_capacity(struct ab8500_fg *di)\r\n{\r\nint cap;\r\nab8500_fg_clear_cap_samples(di);\r\ncap = di->bat_cap.user_mah;\r\nif (cap > di->bat_cap.max_mah_design) {\r\ndev_dbg(di->dev, "Remaining cap %d can't be bigger than total"\r\n" %d\n", cap, di->bat_cap.max_mah_design);\r\ncap = di->bat_cap.max_mah_design;\r\n}\r\nab8500_fg_fill_cap_sample(di, di->bat_cap.user_mah);\r\ndi->bat_cap.permille = ab8500_fg_convert_mah_to_permille(di, cap);\r\ndi->bat_cap.mah = cap;\r\nab8500_fg_check_capacity_limits(di, true);\r\n}\r\nstatic bool check_sysfs_capacity(struct ab8500_fg *di)\r\n{\r\nint cap, lower, upper;\r\nint cap_permille;\r\ncap = di->bat_cap.user_mah;\r\ncap_permille = ab8500_fg_convert_mah_to_permille(di,\r\ndi->bat_cap.user_mah);\r\nlower = di->bat_cap.permille - di->bat->fg_params->user_cap_limit * 10;\r\nupper = di->bat_cap.permille + di->bat->fg_params->user_cap_limit * 10;\r\nif (lower < 0)\r\nlower = 0;\r\nif (upper > 1000)\r\nupper = 1000;\r\ndev_dbg(di->dev, "Capacity limits:"\r\n" (Lower: %d User: %d Upper: %d) [user: %d, was: %d]\n",\r\nlower, cap_permille, upper, cap, di->bat_cap.mah);\r\nif (cap_permille > lower && cap_permille < upper) {\r\ndev_dbg(di->dev, "OK! Using users cap %d uAh now\n", cap);\r\nforce_capacity(di);\r\nreturn true;\r\n}\r\ndev_dbg(di->dev, "Capacity from user out of limits, ignoring");\r\nreturn false;\r\n}\r\nstatic void ab8500_fg_algorithm_discharging(struct ab8500_fg *di)\r\n{\r\nint sleep_time;\r\nif (di->charge_state != AB8500_FG_CHARGE_INIT)\r\nab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\r\nswitch (di->discharge_state) {\r\ncase AB8500_FG_DISCHARGE_INIT:\r\ndi->init_cnt = 0;\r\ndi->fg_samples = SEC_TO_SAMPLE(di->bat->fg_params->init_timer);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_INITMEASURING);\r\ncase AB8500_FG_DISCHARGE_INITMEASURING:\r\nsleep_time = di->bat->fg_params->init_timer;\r\nif (di->init_cnt >\r\ndi->bat->fg_params->init_discard_time) {\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\nab8500_fg_check_capacity_limits(di, true);\r\n}\r\ndi->init_cnt += sleep_time;\r\nif (di->init_cnt > di->bat->fg_params->init_total_time)\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT_INIT);\r\nbreak;\r\ncase AB8500_FG_DISCHARGE_INIT_RECOVERY:\r\ndi->recovery_cnt = 0;\r\ndi->recovery_needed = true;\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_RECOVERY);\r\ncase AB8500_FG_DISCHARGE_RECOVERY:\r\nsleep_time = di->bat->fg_params->recovery_sleep_timer;\r\ndi->inst_curr = ab8500_fg_inst_curr_blocking(di);\r\nif (ab8500_fg_is_low_curr(di, di->inst_curr)) {\r\nif (di->recovery_cnt >\r\ndi->bat->fg_params->recovery_total_time) {\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bat->fg_params->accu_high_curr);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT);\r\ndi->recovery_needed = false;\r\n} else {\r\nqueue_delayed_work(di->fg_wq,\r\n&di->fg_periodic_work,\r\nsleep_time * HZ);\r\n}\r\ndi->recovery_cnt += sleep_time;\r\n} else {\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bat->fg_params->accu_high_curr);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT);\r\n}\r\nbreak;\r\ncase AB8500_FG_DISCHARGE_READOUT_INIT:\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bat->fg_params->accu_high_curr);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT);\r\nbreak;\r\ncase AB8500_FG_DISCHARGE_READOUT:\r\ndi->inst_curr = ab8500_fg_inst_curr_blocking(di);\r\nif (ab8500_fg_is_low_curr(di, di->inst_curr)) {\r\nif (di->high_curr_mode) {\r\ndi->high_curr_mode = false;\r\ndi->high_curr_cnt = 0;\r\n}\r\nif (di->recovery_needed) {\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_RECOVERY);\r\nqueue_delayed_work(di->fg_wq,\r\n&di->fg_periodic_work, 0);\r\nbreak;\r\n}\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\n} else {\r\nmutex_lock(&di->cc_lock);\r\nif (!di->flags.conv_done) {\r\nmutex_unlock(&di->cc_lock);\r\ndev_dbg(di->dev, "%s CC conv not done\n",\r\n__func__);\r\nbreak;\r\n}\r\ndi->flags.conv_done = false;\r\nmutex_unlock(&di->cc_lock);\r\nif (!di->high_curr_mode) {\r\ndi->high_curr_mode = true;\r\ndi->high_curr_cnt = 0;\r\n}\r\ndi->high_curr_cnt +=\r\ndi->bat->fg_params->accu_high_curr;\r\nif (di->high_curr_cnt >\r\ndi->bat->fg_params->high_curr_time)\r\ndi->recovery_needed = true;\r\nab8500_fg_calc_cap_discharge_fg(di);\r\n}\r\nab8500_fg_check_capacity_limits(di, false);\r\nbreak;\r\ncase AB8500_FG_DISCHARGE_WAKEUP:\r\nab8500_fg_coulomb_counter(di, true);\r\ndi->inst_curr = ab8500_fg_inst_curr_blocking(di);\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bat->fg_params->accu_high_curr);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT);\r\nab8500_fg_check_capacity_limits(di, false);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ab8500_fg_algorithm_calibrate(struct ab8500_fg *di)\r\n{\r\nint ret;\r\nswitch (di->calib_state) {\r\ncase AB8500_FG_CALIB_INIT:\r\ndev_dbg(di->dev, "Calibration ongoing...\n");\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\nCC_INT_CAL_N_AVG_MASK, CC_INT_CAL_SAMPLES_8);\r\nif (ret < 0)\r\ngoto err;\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\nCC_INTAVGOFFSET_ENA, CC_INTAVGOFFSET_ENA);\r\nif (ret < 0)\r\ngoto err;\r\ndi->calib_state = AB8500_FG_CALIB_WAIT;\r\nbreak;\r\ncase AB8500_FG_CALIB_END:\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\nCC_MUXOFFSET, CC_MUXOFFSET);\r\nif (ret < 0)\r\ngoto err;\r\ndi->flags.calibrate = false;\r\ndev_dbg(di->dev, "Calibration done...\n");\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\nbreak;\r\ncase AB8500_FG_CALIB_WAIT:\r\ndev_dbg(di->dev, "Calibration WFI\n");\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\nerr:\r\ndev_err(di->dev, "failed to calibrate the CC\n");\r\ndi->flags.calibrate = false;\r\ndi->calib_state = AB8500_FG_CALIB_INIT;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n}\r\nstatic void ab8500_fg_algorithm(struct ab8500_fg *di)\r\n{\r\nif (di->flags.calibrate)\r\nab8500_fg_algorithm_calibrate(di);\r\nelse {\r\nif (di->flags.charging)\r\nab8500_fg_algorithm_charging(di);\r\nelse\r\nab8500_fg_algorithm_discharging(di);\r\n}\r\ndev_dbg(di->dev, "[FG_DATA] %d %d %d %d %d %d %d %d %d "\r\n"%d %d %d %d %d %d %d\n",\r\ndi->bat_cap.max_mah_design,\r\ndi->bat_cap.mah,\r\ndi->bat_cap.permille,\r\ndi->bat_cap.level,\r\ndi->bat_cap.prev_mah,\r\ndi->bat_cap.prev_percent,\r\ndi->bat_cap.prev_level,\r\ndi->vbat,\r\ndi->inst_curr,\r\ndi->avg_curr,\r\ndi->accu_charge,\r\ndi->flags.charging,\r\ndi->charge_state,\r\ndi->discharge_state,\r\ndi->high_curr_mode,\r\ndi->recovery_needed);\r\n}\r\nstatic void ab8500_fg_periodic_work(struct work_struct *work)\r\n{\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\r\nfg_periodic_work.work);\r\nif (di->init_capacity) {\r\ndi->inst_curr = ab8500_fg_inst_curr_blocking(di);\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\nab8500_fg_check_capacity_limits(di, true);\r\ndi->init_capacity = false;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n} else if (di->flags.user_cap) {\r\nif (check_sysfs_capacity(di)) {\r\nab8500_fg_check_capacity_limits(di, true);\r\nif (di->flags.charging)\r\nab8500_fg_charge_state_to(di,\r\nAB8500_FG_CHARGE_INIT);\r\nelse\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT_INIT);\r\n}\r\ndi->flags.user_cap = false;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n} else\r\nab8500_fg_algorithm(di);\r\n}\r\nstatic void ab8500_fg_check_hw_failure_work(struct work_struct *work)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\r\nfg_check_hw_failure_work.work);\r\nif (di->flags.bat_ovv) {\r\nret = abx500_get_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_CH_STAT_REG,\r\n&reg_value);\r\nif (ret < 0) {\r\ndev_err(di->dev, "%s ab8500 read failed\n", __func__);\r\nreturn;\r\n}\r\nif ((reg_value & BATT_OVV) != BATT_OVV) {\r\ndev_dbg(di->dev, "Battery recovered from OVV\n");\r\ndi->flags.bat_ovv = false;\r\npower_supply_changed(&di->fg_psy);\r\nreturn;\r\n}\r\nqueue_delayed_work(di->fg_wq, &di->fg_check_hw_failure_work,\r\nround_jiffies(HZ));\r\n}\r\n}\r\nstatic void ab8500_fg_low_bat_work(struct work_struct *work)\r\n{\r\nint vbat;\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\r\nfg_low_bat_work.work);\r\nvbat = ab8500_fg_bat_voltage(di);\r\nif (vbat < di->bat->fg_params->lowbat_threshold) {\r\ndi->flags.low_bat = true;\r\ndev_warn(di->dev, "Battery voltage still LOW\n");\r\nqueue_delayed_work(di->fg_wq, &di->fg_low_bat_work,\r\nround_jiffies(LOW_BAT_CHECK_INTERVAL));\r\n} else {\r\ndi->flags.low_bat = false;\r\ndev_warn(di->dev, "Battery voltage OK again\n");\r\n}\r\nab8500_fg_check_capacity_limits(di, false);\r\ndi->flags.low_bat_delay = false;\r\n}\r\nstatic int ab8500_fg_battok_calc(struct ab8500_fg *di, int target)\r\n{\r\nif (target > BATT_OK_MIN +\r\n(BATT_OK_INCREMENT * BATT_OK_MAX_NR_INCREMENTS))\r\nreturn BATT_OK_MAX_NR_INCREMENTS;\r\nif (target < BATT_OK_MIN)\r\nreturn 0;\r\nreturn (target - BATT_OK_MIN) / BATT_OK_INCREMENT;\r\n}\r\nstatic int ab8500_fg_battok_init_hw_register(struct ab8500_fg *di)\r\n{\r\nint selected;\r\nint sel0;\r\nint sel1;\r\nint cbp_sel0;\r\nint cbp_sel1;\r\nint ret;\r\nint new_val;\r\nsel0 = di->bat->fg_params->battok_falling_th_sel0;\r\nsel1 = di->bat->fg_params->battok_raising_th_sel1;\r\ncbp_sel0 = ab8500_fg_battok_calc(di, sel0);\r\ncbp_sel1 = ab8500_fg_battok_calc(di, sel1);\r\nselected = BATT_OK_MIN + cbp_sel0 * BATT_OK_INCREMENT;\r\nif (selected != sel0)\r\ndev_warn(di->dev, "Invalid voltage step:%d, using %d %d\n",\r\nsel0, selected, cbp_sel0);\r\nselected = BATT_OK_MIN + cbp_sel1 * BATT_OK_INCREMENT;\r\nif (selected != sel1)\r\ndev_warn(di->dev, "Invalid voltage step:%d, using %d %d\n",\r\nsel1, selected, cbp_sel1);\r\nnew_val = cbp_sel0 | (cbp_sel1 << 4);\r\ndev_dbg(di->dev, "using: %x %d %d\n", new_val, cbp_sel0, cbp_sel1);\r\nret = abx500_set_register_interruptible(di->dev, AB8500_SYS_CTRL2_BLOCK,\r\nAB8500_BATT_OK_REG, new_val);\r\nreturn ret;\r\n}\r\nstatic void ab8500_fg_instant_work(struct work_struct *work)\r\n{\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg, fg_work);\r\nab8500_fg_algorithm(di);\r\n}\r\nstatic irqreturn_t ab8500_fg_cc_data_end_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\ncomplete(&di->ab8500_fg_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_fg_cc_int_calib_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\ndi->calib_state = AB8500_FG_CALIB_END;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_fg_cc_convend_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\nqueue_work(di->fg_wq, &di->fg_acc_cur_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_fg_batt_ovv_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\ndev_dbg(di->dev, "Battery OVV\n");\r\ndi->flags.bat_ovv = true;\r\npower_supply_changed(&di->fg_psy);\r\nqueue_delayed_work(di->fg_wq, &di->fg_check_hw_failure_work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_fg_lowbatf_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\nif (!di->flags.low_bat_delay) {\r\ndev_warn(di->dev, "Battery voltage is below LOW threshold\n");\r\ndi->flags.low_bat_delay = true;\r\nqueue_delayed_work(di->fg_wq, &di->fg_low_bat_work,\r\nround_jiffies(LOW_BAT_CHECK_INTERVAL));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ab8500_fg_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct ab8500_fg *di;\r\ndi = to_ab8500_fg_device_info(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (di->flags.bat_ovv)\r\nval->intval = BATT_OVV_VALUE * 1000;\r\nelse\r\nval->intval = di->vbat * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nval->intval = di->inst_curr * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nval->intval = di->avg_curr * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\nval->intval = ab8500_fg_convert_mah_to_uwh(di,\r\ndi->bat_cap.max_mah_design);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\nval->intval = ab8500_fg_convert_mah_to_uwh(di,\r\ndi->bat_cap.max_mah);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\nif (di->flags.batt_unknown && !di->bat->chg_unknown_bat &&\r\ndi->flags.batt_id_received)\r\nval->intval = ab8500_fg_convert_mah_to_uwh(di,\r\ndi->bat_cap.max_mah);\r\nelse\r\nval->intval = ab8500_fg_convert_mah_to_uwh(di,\r\ndi->bat_cap.prev_mah);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = di->bat_cap.max_mah_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nval->intval = di->bat_cap.max_mah;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nif (di->flags.batt_unknown && !di->bat->chg_unknown_bat &&\r\ndi->flags.batt_id_received)\r\nval->intval = di->bat_cap.max_mah;\r\nelse\r\nval->intval = di->bat_cap.prev_mah;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nif (di->flags.batt_unknown && !di->bat->chg_unknown_bat &&\r\ndi->flags.batt_id_received)\r\nval->intval = 100;\r\nelse\r\nval->intval = di->bat_cap.prev_percent;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\r\nif (di->flags.batt_unknown && !di->bat->chg_unknown_bat &&\r\ndi->flags.batt_id_received)\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\r\nelse\r\nval->intval = di->bat_cap.prev_level;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_fg_get_ext_psy_data(struct device *dev, void *data)\r\n{\r\nstruct power_supply *psy;\r\nstruct power_supply *ext;\r\nstruct ab8500_fg *di;\r\nunion power_supply_propval ret;\r\nint i, j;\r\nbool psy_found = false;\r\npsy = (struct power_supply *)data;\r\next = dev_get_drvdata(dev);\r\ndi = to_ab8500_fg_device_info(psy);\r\nfor (i = 0; i < ext->num_supplicants; i++) {\r\nif (!strcmp(ext->supplied_to[i], psy->name))\r\npsy_found = true;\r\n}\r\nif (!psy_found)\r\nreturn 0;\r\nfor (j = 0; j < ext->num_properties; j++) {\r\nenum power_supply_property prop;\r\nprop = ext->properties[j];\r\nif (ext->get_property(ext, prop, &ret))\r\ncontinue;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nswitch (ret.intval) {\r\ncase POWER_SUPPLY_STATUS_UNKNOWN:\r\ncase POWER_SUPPLY_STATUS_DISCHARGING:\r\ncase POWER_SUPPLY_STATUS_NOT_CHARGING:\r\nif (!di->flags.charging)\r\nbreak;\r\ndi->flags.charging = false;\r\ndi->flags.fully_charged = false;\r\nqueue_work(di->fg_wq, &di->fg_work);\r\nbreak;\r\ncase POWER_SUPPLY_STATUS_FULL:\r\nif (di->flags.fully_charged)\r\nbreak;\r\ndi->flags.fully_charged = true;\r\ndi->flags.force_full = true;\r\ndi->bat_cap.max_mah = di->bat_cap.mah;\r\nqueue_work(di->fg_wq, &di->fg_work);\r\nbreak;\r\ncase POWER_SUPPLY_STATUS_CHARGING:\r\nif (di->flags.charging)\r\nbreak;\r\ndi->flags.charging = true;\r\ndi->flags.fully_charged = false;\r\nqueue_work(di->fg_wq, &di->fg_work);\r\nbreak;\r\n};\r\ndefault:\r\nbreak;\r\n};\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nif (!di->flags.batt_id_received) {\r\nconst struct abx500_battery_type *b;\r\nb = &(di->bat->bat_type[di->bat->batt_id]);\r\ndi->flags.batt_id_received = true;\r\ndi->bat_cap.max_mah_design =\r\nMILLI_TO_MICRO *\r\nb->charge_full_design;\r\ndi->bat_cap.max_mah =\r\ndi->bat_cap.max_mah_design;\r\ndi->vbat_nom = b->nominal_voltage;\r\n}\r\nif (ret.intval)\r\ndi->flags.batt_unknown = false;\r\nelse\r\ndi->flags.batt_unknown = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nswitch (ext->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nif (di->flags.batt_id_received)\r\ndi->bat_temp = ret.intval;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_fg_init_hw_registers(struct ab8500_fg *di)\r\n{\r\nint ret;\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER,\r\nAB8500_BATT_OVV,\r\nBATT_OVV_TH_4P75,\r\nBATT_OVV_TH_4P75);\r\nif (ret) {\r\ndev_err(di->dev, "failed to set BATT_OVV\n");\r\ngoto out;\r\n}\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER,\r\nAB8500_BATT_OVV,\r\nBATT_OVV_ENA,\r\nBATT_OVV_ENA);\r\nif (ret) {\r\ndev_err(di->dev, "failed to enable BATT_OVV\n");\r\ngoto out;\r\n}\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_SYS_CTRL2_BLOCK,\r\nAB8500_LOW_BAT_REG,\r\nab8500_volt_to_regval(\r\ndi->bat->fg_params->lowbat_threshold) << 1 |\r\nLOW_BAT_ENABLE);\r\nif (ret) {\r\ndev_err(di->dev, "%s write failed\n", __func__);\r\ngoto out;\r\n}\r\nret = ab8500_fg_battok_init_hw_register(di);\r\nif (ret) {\r\ndev_err(di->dev, "BattOk init write failed.\n");\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ab8500_fg_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct ab8500_fg *di = to_ab8500_fg_device_info(psy);\r\nclass_for_each_device(power_supply_class, NULL,\r\n&di->fg_psy, ab8500_fg_get_ext_psy_data);\r\n}\r\nstatic void ab8500_fg_reinit_work(struct work_struct *work)\r\n{\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\r\nfg_reinit_work.work);\r\nif (di->flags.calibrate == false) {\r\ndev_dbg(di->dev, "Resetting FG state machine to init.\n");\r\nab8500_fg_clear_cap_samples(di);\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\nab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\r\nab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_INIT);\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n} else {\r\ndev_err(di->dev, "Residual offset calibration ongoing "\r\n"retrying..\n");\r\nqueue_delayed_work(di->fg_wq, &di->fg_reinit_work,\r\nround_jiffies(1));\r\n}\r\n}\r\nvoid ab8500_fg_reinit(void)\r\n{\r\nstruct ab8500_fg *di = ab8500_fg_get();\r\nif (di != NULL)\r\nqueue_delayed_work(di->fg_wq, &di->fg_reinit_work, 0);\r\n}\r\nstatic ssize_t charge_full_show(struct ab8500_fg *di, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", di->bat_cap.max_mah);\r\n}\r\nstatic ssize_t charge_full_store(struct ab8500_fg *di, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long charge_full;\r\nssize_t ret = -EINVAL;\r\nret = strict_strtoul(buf, 10, &charge_full);\r\ndev_dbg(di->dev, "Ret %zd charge_full %lu", ret, charge_full);\r\nif (!ret) {\r\ndi->bat_cap.max_mah = (int) charge_full;\r\nret = count;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t charge_now_show(struct ab8500_fg *di, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", di->bat_cap.prev_mah);\r\n}\r\nstatic ssize_t charge_now_store(struct ab8500_fg *di, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long charge_now;\r\nssize_t ret;\r\nret = strict_strtoul(buf, 10, &charge_now);\r\ndev_dbg(di->dev, "Ret %zd charge_now %lu was %d",\r\nret, charge_now, di->bat_cap.prev_mah);\r\nif (!ret) {\r\ndi->bat_cap.user_mah = (int) charge_now;\r\ndi->flags.user_cap = true;\r\nret = count;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nab8500_fg_show(struct kobject *kobj, struct attribute *attr, char *buf)\r\n{\r\nstruct ab8500_fg_sysfs_entry *entry;\r\nstruct ab8500_fg *di;\r\nentry = container_of(attr, struct ab8500_fg_sysfs_entry, attr);\r\ndi = container_of(kobj, struct ab8500_fg, fg_kobject);\r\nif (!entry->show)\r\nreturn -EIO;\r\nreturn entry->show(di, buf);\r\n}\r\nstatic ssize_t\r\nab8500_fg_store(struct kobject *kobj, struct attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct ab8500_fg_sysfs_entry *entry;\r\nstruct ab8500_fg *di;\r\nentry = container_of(attr, struct ab8500_fg_sysfs_entry, attr);\r\ndi = container_of(kobj, struct ab8500_fg, fg_kobject);\r\nif (!entry->store)\r\nreturn -EIO;\r\nreturn entry->store(di, buf, count);\r\n}\r\nstatic void ab8500_fg_sysfs_exit(struct ab8500_fg *di)\r\n{\r\nkobject_del(&di->fg_kobject);\r\n}\r\nstatic int ab8500_fg_sysfs_init(struct ab8500_fg *di)\r\n{\r\nint ret = 0;\r\nret = kobject_init_and_add(&di->fg_kobject,\r\n&ab8500_fg_ktype,\r\nNULL, "battery");\r\nif (ret < 0)\r\ndev_err(di->dev, "failed to create sysfs entry\n");\r\nreturn ret;\r\n}\r\nstatic int ab8500_fg_resume(struct platform_device *pdev)\r\n{\r\nstruct ab8500_fg *di = platform_get_drvdata(pdev);\r\nif (!di->flags.charging) {\r\nab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_WAKEUP);\r\nqueue_work(di->fg_wq, &di->fg_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_fg_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct ab8500_fg *di = platform_get_drvdata(pdev);\r\nflush_delayed_work(&di->fg_periodic_work);\r\nif (di->flags.fg_enabled && !di->flags.charging)\r\nab8500_fg_coulomb_counter(di, false);\r\nreturn 0;\r\n}\r\nstatic int __devexit ab8500_fg_remove(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct ab8500_fg *di = platform_get_drvdata(pdev);\r\nlist_del(&di->node);\r\nret = ab8500_fg_coulomb_counter(di, false);\r\nif (ret)\r\ndev_err(di->dev, "failed to disable coulomb counter\n");\r\ndestroy_workqueue(di->fg_wq);\r\nab8500_fg_sysfs_exit(di);\r\nflush_scheduled_work();\r\npower_supply_unregister(&di->fg_psy);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(di);\r\nreturn ret;\r\n}\r\nstatic int __devinit ab8500_fg_probe(struct platform_device *pdev)\r\n{\r\nint i, irq;\r\nint ret = 0;\r\nstruct abx500_bm_plat_data *plat_data = pdev->dev.platform_data;\r\nstruct ab8500_fg *di;\r\nif (!plat_data) {\r\ndev_err(&pdev->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\ndi = kzalloc(sizeof(*di), GFP_KERNEL);\r\nif (!di)\r\nreturn -ENOMEM;\r\nmutex_init(&di->cc_lock);\r\ndi->dev = &pdev->dev;\r\ndi->parent = dev_get_drvdata(pdev->dev.parent);\r\ndi->gpadc = ab8500_gpadc_get("ab8500-gpadc.0");\r\ndi->pdata = plat_data->fg;\r\nif (!di->pdata) {\r\ndev_err(di->dev, "no fg platform data supplied\n");\r\nret = -EINVAL;\r\ngoto free_device_info;\r\n}\r\ndi->bat = plat_data->battery;\r\nif (!di->bat) {\r\ndev_err(di->dev, "no battery platform data supplied\n");\r\nret = -EINVAL;\r\ngoto free_device_info;\r\n}\r\ndi->fg_psy.name = "ab8500_fg";\r\ndi->fg_psy.type = POWER_SUPPLY_TYPE_BATTERY;\r\ndi->fg_psy.properties = ab8500_fg_props;\r\ndi->fg_psy.num_properties = ARRAY_SIZE(ab8500_fg_props);\r\ndi->fg_psy.get_property = ab8500_fg_get_property;\r\ndi->fg_psy.supplied_to = di->pdata->supplied_to;\r\ndi->fg_psy.num_supplicants = di->pdata->num_supplicants;\r\ndi->fg_psy.external_power_changed = ab8500_fg_external_power_changed;\r\ndi->bat_cap.max_mah_design = MILLI_TO_MICRO *\r\ndi->bat->bat_type[di->bat->batt_id].charge_full_design;\r\ndi->bat_cap.max_mah = di->bat_cap.max_mah_design;\r\ndi->vbat_nom = di->bat->bat_type[di->bat->batt_id].nominal_voltage;\r\ndi->init_capacity = true;\r\nab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\r\nab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_INIT);\r\ndi->fg_wq = create_singlethread_workqueue("ab8500_fg_wq");\r\nif (di->fg_wq == NULL) {\r\ndev_err(di->dev, "failed to create work queue\n");\r\ngoto free_device_info;\r\n}\r\nINIT_WORK(&di->fg_work, ab8500_fg_instant_work);\r\nINIT_WORK(&di->fg_acc_cur_work, ab8500_fg_acc_cur_work);\r\nINIT_DELAYED_WORK_DEFERRABLE(&di->fg_reinit_work,\r\nab8500_fg_reinit_work);\r\nINIT_DELAYED_WORK_DEFERRABLE(&di->fg_periodic_work,\r\nab8500_fg_periodic_work);\r\nINIT_DELAYED_WORK_DEFERRABLE(&di->fg_low_bat_work,\r\nab8500_fg_low_bat_work);\r\nINIT_DELAYED_WORK_DEFERRABLE(&di->fg_check_hw_failure_work,\r\nab8500_fg_check_hw_failure_work);\r\nret = ab8500_fg_init_hw_registers(di);\r\nif (ret) {\r\ndev_err(di->dev, "failed to initialize registers\n");\r\ngoto free_inst_curr_wq;\r\n}\r\ndi->flags.batt_unknown = true;\r\ndi->flags.batt_id_received = false;\r\nret = power_supply_register(di->dev, &di->fg_psy);\r\nif (ret) {\r\ndev_err(di->dev, "failed to register FG psy\n");\r\ngoto free_inst_curr_wq;\r\n}\r\ndi->fg_samples = SEC_TO_SAMPLE(di->bat->fg_params->init_timer);\r\nab8500_fg_coulomb_counter(di, true);\r\ninit_completion(&di->ab8500_fg_complete);\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_fg_irq); i++) {\r\nirq = platform_get_irq_byname(pdev, ab8500_fg_irq[i].name);\r\nret = request_threaded_irq(irq, NULL, ab8500_fg_irq[i].isr,\r\nIRQF_SHARED | IRQF_NO_SUSPEND,\r\nab8500_fg_irq[i].name, di);\r\nif (ret != 0) {\r\ndev_err(di->dev, "failed to request %s IRQ %d: %d\n"\r\n, ab8500_fg_irq[i].name, irq, ret);\r\ngoto free_irq;\r\n}\r\ndev_dbg(di->dev, "Requested %s IRQ %d: %d\n",\r\nab8500_fg_irq[i].name, irq, ret);\r\n}\r\ndi->irq = platform_get_irq_byname(pdev, "CCEOC");\r\ndisable_irq(di->irq);\r\nplatform_set_drvdata(pdev, di);\r\nret = ab8500_fg_sysfs_init(di);\r\nif (ret) {\r\ndev_err(di->dev, "failed to create sysfs entry\n");\r\ngoto free_irq;\r\n}\r\ndi->flags.calibrate = true;\r\ndi->calib_state = AB8500_FG_CALIB_INIT;\r\ndi->bat_temp = 210;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\nlist_add_tail(&di->node, &ab8500_fg_list);\r\nreturn ret;\r\nfree_irq:\r\npower_supply_unregister(&di->fg_psy);\r\nfor (i = i - 1; i >= 0; i--) {\r\nirq = platform_get_irq_byname(pdev, ab8500_fg_irq[i].name);\r\nfree_irq(irq, di);\r\n}\r\nfree_inst_curr_wq:\r\ndestroy_workqueue(di->fg_wq);\r\nfree_device_info:\r\nkfree(di);\r\nreturn ret;\r\n}\r\nstatic int __init ab8500_fg_init(void)\r\n{\r\nreturn platform_driver_register(&ab8500_fg_driver);\r\n}\r\nstatic void __exit ab8500_fg_exit(void)\r\n{\r\nplatform_driver_unregister(&ab8500_fg_driver);\r\n}
