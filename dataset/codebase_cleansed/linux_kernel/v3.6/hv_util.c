static void shutdown_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nu8 execute_shutdown = false;\r\nu8 *shut_txf_buf = util_shutdown.recv_buffer;\r\nstruct shutdown_msg_data *shutdown_msg;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct icmsg_negotiate *negop = NULL;\r\nvmbus_recvpacket(channel, shut_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&shut_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nvmbus_prep_negotiate_resp(icmsghdrp, negop,\r\nshut_txf_buf, MAX_SRV_VER, MAX_SRV_VER);\r\n} else {\r\nshutdown_msg =\r\n(struct shutdown_msg_data *)&shut_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nswitch (shutdown_msg->flags) {\r\ncase 0:\r\ncase 1:\r\nicmsghdrp->status = HV_S_OK;\r\nexecute_shutdown = true;\r\npr_info("Shutdown request received -"\r\n" graceful shutdown initiated\n");\r\nbreak;\r\ndefault:\r\nicmsghdrp->status = HV_E_FAIL;\r\nexecute_shutdown = false;\r\npr_info("Shutdown request received -"\r\n" Invalid request\n");\r\nbreak;\r\n}\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, shut_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nif (execute_shutdown == true)\r\norderly_poweroff(true);\r\n}\r\nstatic inline void do_adj_guesttime(u64 hosttime)\r\n{\r\ns64 host_tns;\r\nstruct timespec host_ts;\r\nhost_tns = (hosttime - WLTIMEDELTA) * 100;\r\nhost_ts = ns_to_timespec(host_tns);\r\ndo_settimeofday(&host_ts);\r\n}\r\nstatic void hv_set_host_time(struct work_struct *work)\r\n{\r\nstruct adj_time_work *wrk;\r\nwrk = container_of(work, struct adj_time_work, work);\r\ndo_adj_guesttime(wrk->host_time);\r\nkfree(wrk);\r\n}\r\nstatic inline void adj_guesttime(u64 hosttime, u8 flags)\r\n{\r\nstruct adj_time_work *wrk;\r\nstatic s32 scnt = 50;\r\nwrk = kmalloc(sizeof(struct adj_time_work), GFP_ATOMIC);\r\nif (wrk == NULL)\r\nreturn;\r\nwrk->host_time = hosttime;\r\nif ((flags & ICTIMESYNCFLAG_SYNC) != 0) {\r\nINIT_WORK(&wrk->work, hv_set_host_time);\r\nschedule_work(&wrk->work);\r\nreturn;\r\n}\r\nif ((flags & ICTIMESYNCFLAG_SAMPLE) != 0 && scnt > 0) {\r\nscnt--;\r\nINIT_WORK(&wrk->work, hv_set_host_time);\r\nschedule_work(&wrk->work);\r\n} else\r\nkfree(wrk);\r\n}\r\nstatic void timesync_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct ictimesync_data *timedatap;\r\nu8 *time_txf_buf = util_timesynch.recv_buffer;\r\nvmbus_recvpacket(channel, time_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&time_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nvmbus_prep_negotiate_resp(icmsghdrp, NULL, time_txf_buf,\r\nMAX_SRV_VER, MAX_SRV_VER);\r\n} else {\r\ntimedatap = (struct ictimesync_data *)&time_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nadj_guesttime(timedatap->parenttime, timedatap->flags);\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, time_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nstatic void heartbeat_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct heartbeat_msg_data *heartbeat_msg;\r\nu8 *hbeat_txf_buf = util_heartbeat.recv_buffer;\r\nvmbus_recvpacket(channel, hbeat_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&hbeat_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nvmbus_prep_negotiate_resp(icmsghdrp, NULL,\r\nhbeat_txf_buf, MAX_SRV_VER, MAX_SRV_VER);\r\n} else {\r\nheartbeat_msg =\r\n(struct heartbeat_msg_data *)&hbeat_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nheartbeat_msg->seq_num += 1;\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, hbeat_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nstatic int util_probe(struct hv_device *dev,\r\nconst struct hv_vmbus_device_id *dev_id)\r\n{\r\nstruct hv_util_service *srv =\r\n(struct hv_util_service *)dev_id->driver_data;\r\nint ret;\r\nsrv->recv_buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!srv->recv_buffer)\r\nreturn -ENOMEM;\r\nif (srv->util_init) {\r\nret = srv->util_init(srv);\r\nif (ret) {\r\nret = -ENODEV;\r\ngoto error1;\r\n}\r\n}\r\nret = vmbus_open(dev->channel, 2 * PAGE_SIZE, 2 * PAGE_SIZE, NULL, 0,\r\nsrv->util_cb, dev->channel);\r\nif (ret)\r\ngoto error;\r\nhv_set_drvdata(dev, srv);\r\nreturn 0;\r\nerror:\r\nif (srv->util_deinit)\r\nsrv->util_deinit();\r\nerror1:\r\nkfree(srv->recv_buffer);\r\nreturn ret;\r\n}\r\nstatic int util_remove(struct hv_device *dev)\r\n{\r\nstruct hv_util_service *srv = hv_get_drvdata(dev);\r\nvmbus_close(dev->channel);\r\nif (srv->util_deinit)\r\nsrv->util_deinit();\r\nkfree(srv->recv_buffer);\r\nreturn 0;\r\n}\r\nstatic int __init init_hyperv_utils(void)\r\n{\r\npr_info("Registering HyperV Utility Driver\n");\r\nreturn vmbus_driver_register(&util_drv);\r\n}\r\nstatic void exit_hyperv_utils(void)\r\n{\r\npr_info("De-Registered HyperV Utility Driver\n");\r\nvmbus_driver_unregister(&util_drv);\r\n}
