static bool ipv6_mapped_addr_any(const struct in6_addr *a)\r\n{\r\nreturn ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);\r\n}\r\nint ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct in6_addr *daddr, *final_p, final;\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6;\r\nstruct ip6_flowlabel *flowlabel = NULL;\r\nstruct ipv6_txoptions *opt;\r\nint addr_type;\r\nint err;\r\nif (usin->sin6_family == AF_INET) {\r\nif (__ipv6_only_sock(sk))\r\nreturn -EAFNOSUPPORT;\r\nerr = ip4_datagram_connect(sk, uaddr, addr_len);\r\ngoto ipv4_connected;\r\n}\r\nif (addr_len < SIN6_LEN_RFC2133)\r\nreturn -EINVAL;\r\nif (usin->sin6_family != AF_INET6)\r\nreturn -EAFNOSUPPORT;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nif (np->sndflow) {\r\nfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\r\nif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\r\nflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\r\nif (flowlabel == NULL)\r\nreturn -EINVAL;\r\nusin->sin6_addr = flowlabel->dst;\r\n}\r\n}\r\naddr_type = ipv6_addr_type(&usin->sin6_addr);\r\nif (addr_type == IPV6_ADDR_ANY) {\r\nusin->sin6_addr.s6_addr[15] = 0x01;\r\n}\r\ndaddr = &usin->sin6_addr;\r\nif (addr_type == IPV6_ADDR_MAPPED) {\r\nstruct sockaddr_in sin;\r\nif (__ipv6_only_sock(sk)) {\r\nerr = -ENETUNREACH;\r\ngoto out;\r\n}\r\nsin.sin_family = AF_INET;\r\nsin.sin_addr.s_addr = daddr->s6_addr32[3];\r\nsin.sin_port = usin->sin6_port;\r\nerr = ip4_datagram_connect(sk,\r\n(struct sockaddr *) &sin,\r\nsizeof(sin));\r\nipv4_connected:\r\nif (err)\r\ngoto out;\r\nipv6_addr_set_v4mapped(inet->inet_daddr, &np->daddr);\r\nif (ipv6_addr_any(&np->saddr) ||\r\nipv6_mapped_addr_any(&np->saddr))\r\nipv6_addr_set_v4mapped(inet->inet_saddr, &np->saddr);\r\nif (ipv6_addr_any(&np->rcv_saddr) ||\r\nipv6_mapped_addr_any(&np->rcv_saddr)) {\r\nipv6_addr_set_v4mapped(inet->inet_rcv_saddr,\r\n&np->rcv_saddr);\r\nif (sk->sk_prot->rehash)\r\nsk->sk_prot->rehash(sk);\r\n}\r\ngoto out;\r\n}\r\nif (addr_type&IPV6_ADDR_LINKLOCAL) {\r\nif (addr_len >= sizeof(struct sockaddr_in6) &&\r\nusin->sin6_scope_id) {\r\nif (sk->sk_bound_dev_if &&\r\nsk->sk_bound_dev_if != usin->sin6_scope_id) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nsk->sk_bound_dev_if = usin->sin6_scope_id;\r\n}\r\nif (!sk->sk_bound_dev_if && (addr_type & IPV6_ADDR_MULTICAST))\r\nsk->sk_bound_dev_if = np->mcast_oif;\r\nif (!sk->sk_bound_dev_if) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nnp->daddr = *daddr;\r\nnp->flow_label = fl6.flowlabel;\r\ninet->inet_dport = usin->sin6_port;\r\nfl6.flowi6_proto = sk->sk_protocol;\r\nfl6.daddr = np->daddr;\r\nfl6.saddr = np->saddr;\r\nfl6.flowi6_oif = sk->sk_bound_dev_if;\r\nfl6.flowi6_mark = sk->sk_mark;\r\nfl6.fl6_dport = inet->inet_dport;\r\nfl6.fl6_sport = inet->inet_sport;\r\nif (!fl6.flowi6_oif && (addr_type&IPV6_ADDR_MULTICAST))\r\nfl6.flowi6_oif = np->mcast_oif;\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\r\nopt = flowlabel ? flowlabel->opt : np->opt;\r\nfinal_p = fl6_update_dst(&fl6, opt, &final);\r\ndst = ip6_dst_lookup_flow(sk, &fl6, final_p, true);\r\nerr = 0;\r\nif (IS_ERR(dst)) {\r\nerr = PTR_ERR(dst);\r\ngoto out;\r\n}\r\nif (ipv6_addr_any(&np->saddr))\r\nnp->saddr = fl6.saddr;\r\nif (ipv6_addr_any(&np->rcv_saddr)) {\r\nnp->rcv_saddr = fl6.saddr;\r\ninet->inet_rcv_saddr = LOOPBACK4_IPV6;\r\nif (sk->sk_prot->rehash)\r\nsk->sk_prot->rehash(sk);\r\n}\r\nip6_dst_store(sk, dst,\r\nipv6_addr_equal(&fl6.daddr, &np->daddr) ?\r\n&np->daddr : NULL,\r\n#ifdef CONFIG_IPV6_SUBTREES\r\nipv6_addr_equal(&fl6.saddr, &np->saddr) ?\r\n&np->saddr :\r\n#endif\r\nNULL);\r\nsk->sk_state = TCP_ESTABLISHED;\r\nout:\r\nfl6_sock_release(flowlabel);\r\nreturn err;\r\n}\r\nvoid ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\r\n__be16 port, u32 info, u8 *payload)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct icmp6hdr *icmph = icmp6_hdr(skb);\r\nstruct sock_exterr_skb *serr;\r\nif (!np->recverr)\r\nreturn;\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nserr = SKB_EXT_ERR(skb);\r\nserr->ee.ee_errno = err;\r\nserr->ee.ee_origin = SO_EE_ORIGIN_ICMP6;\r\nserr->ee.ee_type = icmph->icmp6_type;\r\nserr->ee.ee_code = icmph->icmp6_code;\r\nserr->ee.ee_pad = 0;\r\nserr->ee.ee_info = info;\r\nserr->ee.ee_data = 0;\r\nserr->addr_offset = (u8 *)&(((struct ipv6hdr *)(icmph + 1))->daddr) -\r\nskb_network_header(skb);\r\nserr->port = port;\r\n__skb_pull(skb, payload - skb->data);\r\nskb_reset_transport_header(skb);\r\nif (sock_queue_err_skb(sk, skb))\r\nkfree_skb(skb);\r\n}\r\nvoid ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sock_exterr_skb *serr;\r\nstruct ipv6hdr *iph;\r\nstruct sk_buff *skb;\r\nif (!np->recverr)\r\nreturn;\r\nskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nskb_put(skb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(skb);\r\niph = ipv6_hdr(skb);\r\niph->daddr = fl6->daddr;\r\nserr = SKB_EXT_ERR(skb);\r\nserr->ee.ee_errno = err;\r\nserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\r\nserr->ee.ee_type = 0;\r\nserr->ee.ee_code = 0;\r\nserr->ee.ee_pad = 0;\r\nserr->ee.ee_info = info;\r\nserr->ee.ee_data = 0;\r\nserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\r\nserr->port = fl6->fl6_dport;\r\n__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\r\nskb_reset_transport_header(skb);\r\nif (sock_queue_err_skb(sk, skb))\r\nkfree_skb(skb);\r\n}\r\nvoid ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6hdr *iph;\r\nstruct sk_buff *skb;\r\nstruct ip6_mtuinfo *mtu_info;\r\nif (!np->rxopt.bits.rxpmtu)\r\nreturn;\r\nskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_put(skb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(skb);\r\niph = ipv6_hdr(skb);\r\niph->daddr = fl6->daddr;\r\nmtu_info = IP6CBMTU(skb);\r\nmtu_info->ip6m_mtu = mtu;\r\nmtu_info->ip6m_addr.sin6_family = AF_INET6;\r\nmtu_info->ip6m_addr.sin6_port = 0;\r\nmtu_info->ip6m_addr.sin6_flowinfo = 0;\r\nmtu_info->ip6m_addr.sin6_scope_id = fl6->flowi6_oif;\r\nmtu_info->ip6m_addr.sin6_addr = ipv6_hdr(skb)->daddr;\r\n__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\r\nskb_reset_transport_header(skb);\r\nskb = xchg(&np->rxpmtu, skb);\r\nkfree_skb(skb);\r\n}\r\nint ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sock_exterr_skb *serr;\r\nstruct sk_buff *skb, *skb2;\r\nstruct sockaddr_in6 *sin;\r\nstruct {\r\nstruct sock_extended_err ee;\r\nstruct sockaddr_in6 offender;\r\n} errhdr;\r\nint err;\r\nint copied;\r\nerr = -EAGAIN;\r\nskb = skb_dequeue(&sk->sk_error_queue);\r\nif (skb == NULL)\r\ngoto out;\r\ncopied = skb->len;\r\nif (copied > len) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (err)\r\ngoto out_free_skb;\r\nsock_recv_timestamp(msg, sk, skb);\r\nserr = SKB_EXT_ERR(skb);\r\nsin = (struct sockaddr_in6 *)msg->msg_name;\r\nif (sin) {\r\nconst unsigned char *nh = skb_network_header(skb);\r\nsin->sin6_family = AF_INET6;\r\nsin->sin6_flowinfo = 0;\r\nsin->sin6_port = serr->port;\r\nsin->sin6_scope_id = 0;\r\nif (skb->protocol == htons(ETH_P_IPV6)) {\r\nsin->sin6_addr =\r\n*(struct in6_addr *)(nh + serr->addr_offset);\r\nif (np->sndflow)\r\nsin->sin6_flowinfo =\r\n(*(__be32 *)(nh + serr->addr_offset - 24) &\r\nIPV6_FLOWINFO_MASK);\r\nif (ipv6_addr_type(&sin->sin6_addr) & IPV6_ADDR_LINKLOCAL)\r\nsin->sin6_scope_id = IP6CB(skb)->iif;\r\n} else {\r\nipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),\r\n&sin->sin6_addr);\r\n}\r\n}\r\nmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\r\nsin = &errhdr.offender;\r\nsin->sin6_family = AF_UNSPEC;\r\nif (serr->ee.ee_origin != SO_EE_ORIGIN_LOCAL) {\r\nsin->sin6_family = AF_INET6;\r\nsin->sin6_flowinfo = 0;\r\nsin->sin6_scope_id = 0;\r\nif (skb->protocol == htons(ETH_P_IPV6)) {\r\nsin->sin6_addr = ipv6_hdr(skb)->saddr;\r\nif (np->rxopt.all)\r\ndatagram_recv_ctl(sk, msg, skb);\r\nif (ipv6_addr_type(&sin->sin6_addr) & IPV6_ADDR_LINKLOCAL)\r\nsin->sin6_scope_id = IP6CB(skb)->iif;\r\n} else {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\r\n&sin->sin6_addr);\r\nif (inet->cmsg_flags)\r\nip_cmsg_recv(msg, skb);\r\n}\r\n}\r\nput_cmsg(msg, SOL_IPV6, IPV6_RECVERR, sizeof(errhdr), &errhdr);\r\nmsg->msg_flags |= MSG_ERRQUEUE;\r\nerr = copied;\r\nspin_lock_bh(&sk->sk_error_queue.lock);\r\nsk->sk_err = 0;\r\nif ((skb2 = skb_peek(&sk->sk_error_queue)) != NULL) {\r\nsk->sk_err = SKB_EXT_ERR(skb2)->ee.ee_errno;\r\nspin_unlock_bh(&sk->sk_error_queue.lock);\r\nsk->sk_error_report(sk);\r\n} else {\r\nspin_unlock_bh(&sk->sk_error_queue.lock);\r\n}\r\nout_free_skb:\r\nkfree_skb(skb);\r\nout:\r\nreturn err;\r\n}\r\nint ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sk_buff *skb;\r\nstruct sockaddr_in6 *sin;\r\nstruct ip6_mtuinfo mtu_info;\r\nint err;\r\nint copied;\r\nerr = -EAGAIN;\r\nskb = xchg(&np->rxpmtu, NULL);\r\nif (skb == NULL)\r\ngoto out;\r\ncopied = skb->len;\r\nif (copied > len) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (err)\r\ngoto out_free_skb;\r\nsock_recv_timestamp(msg, sk, skb);\r\nmemcpy(&mtu_info, IP6CBMTU(skb), sizeof(mtu_info));\r\nsin = (struct sockaddr_in6 *)msg->msg_name;\r\nif (sin) {\r\nsin->sin6_family = AF_INET6;\r\nsin->sin6_flowinfo = 0;\r\nsin->sin6_port = 0;\r\nsin->sin6_scope_id = mtu_info.ip6m_addr.sin6_scope_id;\r\nsin->sin6_addr = mtu_info.ip6m_addr.sin6_addr;\r\n}\r\nput_cmsg(msg, SOL_IPV6, IPV6_PATHMTU, sizeof(mtu_info), &mtu_info);\r\nerr = copied;\r\nout_free_skb:\r\nkfree_skb(skb);\r\nout:\r\nreturn err;\r\n}\r\nint datagram_recv_ctl(struct sock *sk, struct msghdr *msg, struct sk_buff *skb)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct inet6_skb_parm *opt = IP6CB(skb);\r\nunsigned char *nh = skb_network_header(skb);\r\nif (np->rxopt.bits.rxinfo) {\r\nstruct in6_pktinfo src_info;\r\nsrc_info.ipi6_ifindex = opt->iif;\r\nsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\r\nput_cmsg(msg, SOL_IPV6, IPV6_PKTINFO, sizeof(src_info), &src_info);\r\n}\r\nif (np->rxopt.bits.rxhlim) {\r\nint hlim = ipv6_hdr(skb)->hop_limit;\r\nput_cmsg(msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\r\n}\r\nif (np->rxopt.bits.rxtclass) {\r\nint tclass = ipv6_tclass(ipv6_hdr(skb));\r\nput_cmsg(msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\r\n}\r\nif (np->rxopt.bits.rxflow && (*(__be32 *)nh & IPV6_FLOWINFO_MASK)) {\r\n__be32 flowinfo = *(__be32 *)nh & IPV6_FLOWINFO_MASK;\r\nput_cmsg(msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);\r\n}\r\nif (np->rxopt.bits.hopopts && opt->hop) {\r\nu8 *ptr = nh + opt->hop;\r\nput_cmsg(msg, SOL_IPV6, IPV6_HOPOPTS, (ptr[1]+1)<<3, ptr);\r\n}\r\nif (opt->lastopt &&\r\n(np->rxopt.bits.dstopts || np->rxopt.bits.srcrt)) {\r\nunsigned int off = sizeof(struct ipv6hdr);\r\nu8 nexthdr = ipv6_hdr(skb)->nexthdr;\r\nwhile (off <= opt->lastopt) {\r\nunsigned int len;\r\nu8 *ptr = nh + off;\r\nswitch (nexthdr) {\r\ncase IPPROTO_DSTOPTS:\r\nnexthdr = ptr[0];\r\nlen = (ptr[1] + 1) << 3;\r\nif (np->rxopt.bits.dstopts)\r\nput_cmsg(msg, SOL_IPV6, IPV6_DSTOPTS, len, ptr);\r\nbreak;\r\ncase IPPROTO_ROUTING:\r\nnexthdr = ptr[0];\r\nlen = (ptr[1] + 1) << 3;\r\nif (np->rxopt.bits.srcrt)\r\nput_cmsg(msg, SOL_IPV6, IPV6_RTHDR, len, ptr);\r\nbreak;\r\ncase IPPROTO_AH:\r\nnexthdr = ptr[0];\r\nlen = (ptr[1] + 2) << 2;\r\nbreak;\r\ndefault:\r\nnexthdr = ptr[0];\r\nlen = (ptr[1] + 1) << 3;\r\nbreak;\r\n}\r\noff += len;\r\n}\r\n}\r\nif (np->rxopt.bits.rxoinfo) {\r\nstruct in6_pktinfo src_info;\r\nsrc_info.ipi6_ifindex = opt->iif;\r\nsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\r\n}\r\nif (np->rxopt.bits.rxohlim) {\r\nint hlim = ipv6_hdr(skb)->hop_limit;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\r\n}\r\nif (np->rxopt.bits.ohopopts && opt->hop) {\r\nu8 *ptr = nh + opt->hop;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292HOPOPTS, (ptr[1]+1)<<3, ptr);\r\n}\r\nif (np->rxopt.bits.odstopts && opt->dst0) {\r\nu8 *ptr = nh + opt->dst0;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\r\n}\r\nif (np->rxopt.bits.osrcrt && opt->srcrt) {\r\nstruct ipv6_rt_hdr *rthdr = (struct ipv6_rt_hdr *)(nh + opt->srcrt);\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292RTHDR, (rthdr->hdrlen+1) << 3, rthdr);\r\n}\r\nif (np->rxopt.bits.odstopts && opt->dst1) {\r\nu8 *ptr = nh + opt->dst1;\r\nput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\r\n}\r\nif (np->rxopt.bits.rxorigdstaddr) {\r\nstruct sockaddr_in6 sin6;\r\n__be16 *ports = (__be16 *) skb_transport_header(skb);\r\nif (skb_transport_offset(skb) + 4 <= skb->len) {\r\nsin6.sin6_family = AF_INET6;\r\nsin6.sin6_addr = ipv6_hdr(skb)->daddr;\r\nsin6.sin6_port = ports[1];\r\nsin6.sin6_flowinfo = 0;\r\nsin6.sin6_scope_id = 0;\r\nput_cmsg(msg, SOL_IPV6, IPV6_ORIGDSTADDR, sizeof(sin6), &sin6);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint datagram_send_ctl(struct net *net, struct sock *sk,\r\nstruct msghdr *msg, struct flowi6 *fl6,\r\nstruct ipv6_txoptions *opt,\r\nint *hlimit, int *tclass, int *dontfrag)\r\n{\r\nstruct in6_pktinfo *src_info;\r\nstruct cmsghdr *cmsg;\r\nstruct ipv6_rt_hdr *rthdr;\r\nstruct ipv6_opt_hdr *hdr;\r\nint len;\r\nint err = 0;\r\nfor (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\r\nint addr_type;\r\nif (!CMSG_OK(msg, cmsg)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (cmsg->cmsg_level != SOL_IPV6)\r\ncontinue;\r\nswitch (cmsg->cmsg_type) {\r\ncase IPV6_PKTINFO:\r\ncase IPV6_2292PKTINFO:\r\n{\r\nstruct net_device *dev = NULL;\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct in6_pktinfo))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\r\nif (src_info->ipi6_ifindex) {\r\nif (fl6->flowi6_oif &&\r\nsrc_info->ipi6_ifindex != fl6->flowi6_oif)\r\nreturn -EINVAL;\r\nfl6->flowi6_oif = src_info->ipi6_ifindex;\r\n}\r\naddr_type = __ipv6_addr_type(&src_info->ipi6_addr);\r\nrcu_read_lock();\r\nif (fl6->flowi6_oif) {\r\ndev = dev_get_by_index_rcu(net, fl6->flowi6_oif);\r\nif (!dev) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\n} else if (addr_type & IPV6_ADDR_LINKLOCAL) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nif (addr_type != IPV6_ADDR_ANY) {\r\nint strict = __ipv6_addr_src_scope(addr_type) <= IPV6_ADDR_SCOPE_LINKLOCAL;\r\nif (!(inet_sk(sk)->freebind || inet_sk(sk)->transparent) &&\r\n!ipv6_chk_addr(net, &src_info->ipi6_addr,\r\nstrict ? dev : NULL, 0))\r\nerr = -EINVAL;\r\nelse\r\nfl6->saddr = src_info->ipi6_addr;\r\n}\r\nrcu_read_unlock();\r\nif (err)\r\ngoto exit_f;\r\nbreak;\r\n}\r\ncase IPV6_FLOWINFO:\r\nif (cmsg->cmsg_len < CMSG_LEN(4)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (fl6->flowlabel&IPV6_FLOWINFO_MASK) {\r\nif ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\n}\r\nfl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);\r\nbreak;\r\ncase IPV6_2292HOPOPTS:\r\ncase IPV6_HOPOPTS:\r\nif (opt->hopopt || cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nhdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\r\nlen = ((hdr->hdrlen + 1) << 3);\r\nif (cmsg->cmsg_len < CMSG_LEN(len)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (!capable(CAP_NET_RAW)) {\r\nerr = -EPERM;\r\ngoto exit_f;\r\n}\r\nopt->opt_nflen += len;\r\nopt->hopopt = hdr;\r\nbreak;\r\ncase IPV6_2292DSTOPTS:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nhdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\r\nlen = ((hdr->hdrlen + 1) << 3);\r\nif (cmsg->cmsg_len < CMSG_LEN(len)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (!capable(CAP_NET_RAW)) {\r\nerr = -EPERM;\r\ngoto exit_f;\r\n}\r\nif (opt->dst1opt) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nopt->opt_flen += len;\r\nopt->dst1opt = hdr;\r\nbreak;\r\ncase IPV6_DSTOPTS:\r\ncase IPV6_RTHDRDSTOPTS:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nhdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\r\nlen = ((hdr->hdrlen + 1) << 3);\r\nif (cmsg->cmsg_len < CMSG_LEN(len)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif (!capable(CAP_NET_RAW)) {\r\nerr = -EPERM;\r\ngoto exit_f;\r\n}\r\nif (cmsg->cmsg_type == IPV6_DSTOPTS) {\r\nopt->opt_flen += len;\r\nopt->dst1opt = hdr;\r\n} else {\r\nopt->opt_nflen += len;\r\nopt->dst0opt = hdr;\r\n}\r\nbreak;\r\ncase IPV6_2292RTHDR:\r\ncase IPV6_RTHDR:\r\nif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_rt_hdr))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nrthdr = (struct ipv6_rt_hdr *)CMSG_DATA(cmsg);\r\nswitch (rthdr->type) {\r\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\r\ncase IPV6_SRCRT_TYPE_2:\r\nif (rthdr->hdrlen != 2 ||\r\nrthdr->segments_left != 1) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nlen = ((rthdr->hdrlen + 1) << 3);\r\nif (cmsg->cmsg_len < CMSG_LEN(len)) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nif ((rthdr->hdrlen >> 1) != rthdr->segments_left) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nopt->opt_nflen += len;\r\nopt->srcrt = rthdr;\r\nif (cmsg->cmsg_type == IPV6_2292RTHDR && opt->dst1opt) {\r\nint dsthdrlen = ((opt->dst1opt->hdrlen+1)<<3);\r\nopt->opt_nflen += dsthdrlen;\r\nopt->dst0opt = opt->dst1opt;\r\nopt->dst1opt = NULL;\r\nopt->opt_flen -= dsthdrlen;\r\n}\r\nbreak;\r\ncase IPV6_2292HOPLIMIT:\r\ncase IPV6_HOPLIMIT:\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(int))) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\n*hlimit = *(int *)CMSG_DATA(cmsg);\r\nif (*hlimit < -1 || *hlimit > 0xff) {\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\nbreak;\r\ncase IPV6_TCLASS:\r\n{\r\nint tc;\r\nerr = -EINVAL;\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\r\ngoto exit_f;\r\ntc = *(int *)CMSG_DATA(cmsg);\r\nif (tc < -1 || tc > 0xff)\r\ngoto exit_f;\r\nerr = 0;\r\n*tclass = tc;\r\nbreak;\r\n}\r\ncase IPV6_DONTFRAG:\r\n{\r\nint df;\r\nerr = -EINVAL;\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\r\ngoto exit_f;\r\ndf = *(int *)CMSG_DATA(cmsg);\r\nif (df < 0 || df > 1)\r\ngoto exit_f;\r\nerr = 0;\r\n*dontfrag = df;\r\nbreak;\r\n}\r\ndefault:\r\nLIMIT_NETDEBUG(KERN_DEBUG "invalid cmsg type: %d\n",\r\ncmsg->cmsg_type);\r\nerr = -EINVAL;\r\ngoto exit_f;\r\n}\r\n}\r\nexit_f:\r\nreturn err;\r\n}
