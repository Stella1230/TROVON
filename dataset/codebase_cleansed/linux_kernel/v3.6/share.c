static void dead_write_lines (struct parport *p, unsigned char b){}\r\nstatic unsigned char dead_read_lines (struct parport *p) { return 0; }\r\nstatic unsigned char dead_frob_lines (struct parport *p, unsigned char b,\r\nunsigned char c) { return 0; }\r\nstatic void dead_onearg (struct parport *p){}\r\nstatic void dead_initstate (struct pardevice *d, struct parport_state *s) { }\r\nstatic void dead_state (struct parport *p, struct parport_state *s) { }\r\nstatic size_t dead_write (struct parport *p, const void *b, size_t l, int f)\r\n{ return 0; }\r\nstatic size_t dead_read (struct parport *p, void *b, size_t l, int f)\r\n{ return 0; }\r\nstatic void attach_driver_chain(struct parport *port)\r\n{\r\nstruct parport_driver *drv;\r\nlist_for_each_entry(drv, &drivers, list)\r\ndrv->attach(port);\r\n}\r\nstatic void detach_driver_chain(struct parport *port)\r\n{\r\nstruct parport_driver *drv;\r\nlist_for_each_entry(drv, &drivers, list)\r\ndrv->detach (port);\r\n}\r\nstatic void get_lowlevel_driver (void)\r\n{\r\nrequest_module ("parport_lowlevel");\r\n}\r\nint parport_register_driver (struct parport_driver *drv)\r\n{\r\nstruct parport *port;\r\nif (list_empty(&portlist))\r\nget_lowlevel_driver ();\r\nmutex_lock(&registration_lock);\r\nlist_for_each_entry(port, &portlist, list)\r\ndrv->attach(port);\r\nlist_add(&drv->list, &drivers);\r\nmutex_unlock(&registration_lock);\r\nreturn 0;\r\n}\r\nvoid parport_unregister_driver (struct parport_driver *drv)\r\n{\r\nstruct parport *port;\r\nmutex_lock(&registration_lock);\r\nlist_del_init(&drv->list);\r\nlist_for_each_entry(port, &portlist, list)\r\ndrv->detach(port);\r\nmutex_unlock(&registration_lock);\r\n}\r\nstatic void free_port (struct parport *port)\r\n{\r\nint d;\r\nspin_lock(&full_list_lock);\r\nlist_del(&port->full_list);\r\nspin_unlock(&full_list_lock);\r\nfor (d = 0; d < 5; d++) {\r\nkfree(port->probe_info[d].class_name);\r\nkfree(port->probe_info[d].mfr);\r\nkfree(port->probe_info[d].model);\r\nkfree(port->probe_info[d].cmdset);\r\nkfree(port->probe_info[d].description);\r\n}\r\nkfree(port->name);\r\nkfree(port);\r\n}\r\nstruct parport *parport_get_port (struct parport *port)\r\n{\r\natomic_inc (&port->ref_count);\r\nreturn port;\r\n}\r\nvoid parport_put_port (struct parport *port)\r\n{\r\nif (atomic_dec_and_test (&port->ref_count))\r\nfree_port (port);\r\nreturn;\r\n}\r\nstruct parport *parport_register_port(unsigned long base, int irq, int dma,\r\nstruct parport_operations *ops)\r\n{\r\nstruct list_head *l;\r\nstruct parport *tmp;\r\nint num;\r\nint device;\r\nchar *name;\r\ntmp = kmalloc(sizeof(struct parport), GFP_KERNEL);\r\nif (!tmp) {\r\nprintk(KERN_WARNING "parport: memory squeeze\n");\r\nreturn NULL;\r\n}\r\nmemset(tmp, 0, sizeof(struct parport));\r\ntmp->base = base;\r\ntmp->irq = irq;\r\ntmp->dma = dma;\r\ntmp->muxport = tmp->daisy = tmp->muxsel = -1;\r\ntmp->modes = 0;\r\nINIT_LIST_HEAD(&tmp->list);\r\ntmp->devices = tmp->cad = NULL;\r\ntmp->flags = 0;\r\ntmp->ops = ops;\r\ntmp->physport = tmp;\r\nmemset (tmp->probe_info, 0, 5 * sizeof (struct parport_device_info));\r\nrwlock_init(&tmp->cad_lock);\r\nspin_lock_init(&tmp->waitlist_lock);\r\nspin_lock_init(&tmp->pardevice_lock);\r\ntmp->ieee1284.mode = IEEE1284_MODE_COMPAT;\r\ntmp->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\nsema_init(&tmp->ieee1284.irq, 0);\r\ntmp->spintime = parport_default_spintime;\r\natomic_set (&tmp->ref_count, 1);\r\nINIT_LIST_HEAD(&tmp->full_list);\r\nname = kmalloc(15, GFP_KERNEL);\r\nif (!name) {\r\nprintk(KERN_ERR "parport: memory squeeze\n");\r\nkfree(tmp);\r\nreturn NULL;\r\n}\r\nspin_lock(&full_list_lock);\r\nfor (l = all_ports.next, num = 0; l != &all_ports; l = l->next, num++) {\r\nstruct parport *p = list_entry(l, struct parport, full_list);\r\nif (p->number != num)\r\nbreak;\r\n}\r\ntmp->portnum = tmp->number = num;\r\nlist_add_tail(&tmp->full_list, l);\r\nspin_unlock(&full_list_lock);\r\nsprintf(name, "parport%d", tmp->portnum = tmp->number);\r\ntmp->name = name;\r\nfor (device = 0; device < 5; device++)\r\ntmp->probe_info[device].class = PARPORT_CLASS_LEGACY;\r\ntmp->waithead = tmp->waittail = NULL;\r\nreturn tmp;\r\n}\r\nvoid parport_announce_port (struct parport *port)\r\n{\r\nint i;\r\n#ifdef CONFIG_PARPORT_1284\r\nparport_daisy_init(port);\r\n#endif\r\nif (!port->dev)\r\nprintk(KERN_WARNING "%s: fix this legacy "\r\n"no-device port driver!\n",\r\nport->name);\r\nparport_proc_register(port);\r\nmutex_lock(&registration_lock);\r\nspin_lock_irq(&parportlist_lock);\r\nlist_add_tail(&port->list, &portlist);\r\nfor (i = 1; i < 3; i++) {\r\nstruct parport *slave = port->slaves[i-1];\r\nif (slave)\r\nlist_add_tail(&slave->list, &portlist);\r\n}\r\nspin_unlock_irq(&parportlist_lock);\r\nattach_driver_chain (port);\r\nfor (i = 1; i < 3; i++) {\r\nstruct parport *slave = port->slaves[i-1];\r\nif (slave)\r\nattach_driver_chain(slave);\r\n}\r\nmutex_unlock(&registration_lock);\r\n}\r\nvoid parport_remove_port(struct parport *port)\r\n{\r\nint i;\r\nmutex_lock(&registration_lock);\r\ndetach_driver_chain (port);\r\n#ifdef CONFIG_PARPORT_1284\r\nparport_daisy_fini(port);\r\nfor (i = 1; i < 3; i++) {\r\nstruct parport *slave = port->slaves[i-1];\r\nif (!slave)\r\ncontinue;\r\ndetach_driver_chain(slave);\r\nparport_daisy_fini(slave);\r\n}\r\n#endif\r\nport->ops = &dead_ops;\r\nspin_lock(&parportlist_lock);\r\nlist_del_init(&port->list);\r\nfor (i = 1; i < 3; i++) {\r\nstruct parport *slave = port->slaves[i-1];\r\nif (slave)\r\nlist_del_init(&slave->list);\r\n}\r\nspin_unlock(&parportlist_lock);\r\nmutex_unlock(&registration_lock);\r\nparport_proc_unregister(port);\r\nfor (i = 1; i < 3; i++) {\r\nstruct parport *slave = port->slaves[i-1];\r\nif (slave)\r\nparport_put_port(slave);\r\n}\r\n}\r\nstruct pardevice *\r\nparport_register_device(struct parport *port, const char *name,\r\nint (*pf)(void *), void (*kf)(void *),\r\nvoid (*irq_func)(void *),\r\nint flags, void *handle)\r\n{\r\nstruct pardevice *tmp;\r\nif (port->physport->flags & PARPORT_FLAG_EXCL) {\r\nprintk (KERN_DEBUG "%s: no more devices allowed\n",\r\nport->name);\r\nreturn NULL;\r\n}\r\nif (flags & PARPORT_DEV_LURK) {\r\nif (!pf || !kf) {\r\nprintk(KERN_INFO "%s: refused to register lurking device (%s) without callbacks\n", port->name, name);\r\nreturn NULL;\r\n}\r\n}\r\nif (!try_module_get(port->ops->owner)) {\r\nreturn NULL;\r\n}\r\nparport_get_port (port);\r\ntmp = kmalloc(sizeof(struct pardevice), GFP_KERNEL);\r\nif (tmp == NULL) {\r\nprintk(KERN_WARNING "%s: memory squeeze, couldn't register %s.\n", port->name, name);\r\ngoto out;\r\n}\r\ntmp->state = kmalloc(sizeof(struct parport_state), GFP_KERNEL);\r\nif (tmp->state == NULL) {\r\nprintk(KERN_WARNING "%s: memory squeeze, couldn't register %s.\n", port->name, name);\r\ngoto out_free_pardevice;\r\n}\r\ntmp->name = name;\r\ntmp->port = port;\r\ntmp->daisy = -1;\r\ntmp->preempt = pf;\r\ntmp->wakeup = kf;\r\ntmp->private = handle;\r\ntmp->flags = flags;\r\ntmp->irq_func = irq_func;\r\ntmp->waiting = 0;\r\ntmp->timeout = 5 * HZ;\r\ntmp->prev = NULL;\r\nspin_lock(&port->physport->pardevice_lock);\r\nif (flags & PARPORT_DEV_EXCL) {\r\nif (port->physport->devices) {\r\nspin_unlock (&port->physport->pardevice_lock);\r\nprintk (KERN_DEBUG\r\n"%s: cannot grant exclusive access for "\r\n"device %s\n", port->name, name);\r\ngoto out_free_all;\r\n}\r\nport->flags |= PARPORT_FLAG_EXCL;\r\n}\r\ntmp->next = port->physport->devices;\r\nwmb();\r\nif (port->physport->devices)\r\nport->physport->devices->prev = tmp;\r\nport->physport->devices = tmp;\r\nspin_unlock(&port->physport->pardevice_lock);\r\ninit_waitqueue_head(&tmp->wait_q);\r\ntmp->timeslice = parport_default_timeslice;\r\ntmp->waitnext = tmp->waitprev = NULL;\r\nport->ops->init_state(tmp, tmp->state);\r\nif (!test_and_set_bit(PARPORT_DEVPROC_REGISTERED, &port->devflags)) {\r\nport->proc_device = tmp;\r\nparport_device_proc_register(tmp);\r\n}\r\nreturn tmp;\r\nout_free_all:\r\nkfree(tmp->state);\r\nout_free_pardevice:\r\nkfree(tmp);\r\nout:\r\nparport_put_port (port);\r\nmodule_put(port->ops->owner);\r\nreturn NULL;\r\n}\r\nvoid parport_unregister_device(struct pardevice *dev)\r\n{\r\nstruct parport *port;\r\n#ifdef PARPORT_PARANOID\r\nif (dev == NULL) {\r\nprintk(KERN_ERR "parport_unregister_device: passed NULL\n");\r\nreturn;\r\n}\r\n#endif\r\nport = dev->port->physport;\r\nif (port->proc_device == dev) {\r\nport->proc_device = NULL;\r\nclear_bit(PARPORT_DEVPROC_REGISTERED, &port->devflags);\r\nparport_device_proc_unregister(dev);\r\n}\r\nif (port->cad == dev) {\r\nprintk(KERN_DEBUG "%s: %s forgot to release port\n",\r\nport->name, dev->name);\r\nparport_release (dev);\r\n}\r\nspin_lock(&port->pardevice_lock);\r\nif (dev->next)\r\ndev->next->prev = dev->prev;\r\nif (dev->prev)\r\ndev->prev->next = dev->next;\r\nelse\r\nport->devices = dev->next;\r\nif (dev->flags & PARPORT_DEV_EXCL)\r\nport->flags &= ~PARPORT_FLAG_EXCL;\r\nspin_unlock(&port->pardevice_lock);\r\nspin_lock_irq(&port->waitlist_lock);\r\nif (dev->waitprev || dev->waitnext || port->waithead == dev) {\r\nif (dev->waitprev)\r\ndev->waitprev->waitnext = dev->waitnext;\r\nelse\r\nport->waithead = dev->waitnext;\r\nif (dev->waitnext)\r\ndev->waitnext->waitprev = dev->waitprev;\r\nelse\r\nport->waittail = dev->waitprev;\r\n}\r\nspin_unlock_irq(&port->waitlist_lock);\r\nkfree(dev->state);\r\nkfree(dev);\r\nmodule_put(port->ops->owner);\r\nparport_put_port (port);\r\n}\r\nstruct parport *parport_find_number (int number)\r\n{\r\nstruct parport *port, *result = NULL;\r\nif (list_empty(&portlist))\r\nget_lowlevel_driver ();\r\nspin_lock (&parportlist_lock);\r\nlist_for_each_entry(port, &portlist, list) {\r\nif (port->number == number) {\r\nresult = parport_get_port (port);\r\nbreak;\r\n}\r\n}\r\nspin_unlock (&parportlist_lock);\r\nreturn result;\r\n}\r\nstruct parport *parport_find_base (unsigned long base)\r\n{\r\nstruct parport *port, *result = NULL;\r\nif (list_empty(&portlist))\r\nget_lowlevel_driver ();\r\nspin_lock (&parportlist_lock);\r\nlist_for_each_entry(port, &portlist, list) {\r\nif (port->base == base) {\r\nresult = parport_get_port (port);\r\nbreak;\r\n}\r\n}\r\nspin_unlock (&parportlist_lock);\r\nreturn result;\r\n}\r\nint parport_claim(struct pardevice *dev)\r\n{\r\nstruct pardevice *oldcad;\r\nstruct parport *port = dev->port->physport;\r\nunsigned long flags;\r\nif (port->cad == dev) {\r\nprintk(KERN_INFO "%s: %s already owner\n",\r\ndev->port->name,dev->name);\r\nreturn 0;\r\n}\r\nwrite_lock_irqsave (&port->cad_lock, flags);\r\nif ((oldcad = port->cad) != NULL) {\r\nif (oldcad->preempt) {\r\nif (oldcad->preempt(oldcad->private))\r\ngoto blocked;\r\nport->ops->save_state(port, dev->state);\r\n} else\r\ngoto blocked;\r\nif (port->cad != oldcad) {\r\nprintk(KERN_WARNING\r\n"%s: %s released port when preempted!\n",\r\nport->name, oldcad->name);\r\nif (port->cad)\r\ngoto blocked;\r\n}\r\n}\r\nif (dev->waiting & 1) {\r\ndev->waiting = 0;\r\nspin_lock_irq (&port->waitlist_lock);\r\nif (dev->waitprev)\r\ndev->waitprev->waitnext = dev->waitnext;\r\nelse\r\nport->waithead = dev->waitnext;\r\nif (dev->waitnext)\r\ndev->waitnext->waitprev = dev->waitprev;\r\nelse\r\nport->waittail = dev->waitprev;\r\nspin_unlock_irq (&port->waitlist_lock);\r\ndev->waitprev = dev->waitnext = NULL;\r\n}\r\nport->cad = dev;\r\n#ifdef CONFIG_PARPORT_1284\r\nif (dev->port->muxport >= 0) {\r\nport->muxsel = dev->port->muxport;\r\n}\r\nif (dev->daisy >= 0) {\r\nif (!parport_daisy_select (port, dev->daisy,\r\nIEEE1284_MODE_COMPAT))\r\nport->daisy = dev->daisy;\r\n}\r\n#endif\r\nport->ops->restore_state(port, dev->state);\r\nwrite_unlock_irqrestore(&port->cad_lock, flags);\r\ndev->time = jiffies;\r\nreturn 0;\r\nblocked:\r\nif (dev->waiting & 2 || dev->wakeup) {\r\nspin_lock (&port->waitlist_lock);\r\nif (test_and_set_bit(0, &dev->waiting) == 0) {\r\ndev->waitnext = NULL;\r\ndev->waitprev = port->waittail;\r\nif (port->waittail) {\r\nport->waittail->waitnext = dev;\r\nport->waittail = dev;\r\n} else\r\nport->waithead = port->waittail = dev;\r\n}\r\nspin_unlock (&port->waitlist_lock);\r\n}\r\nwrite_unlock_irqrestore (&port->cad_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nint parport_claim_or_block(struct pardevice *dev)\r\n{\r\nint r;\r\ndev->waiting = 2;\r\nr = parport_claim(dev);\r\nif (r == -EAGAIN) {\r\n#ifdef PARPORT_DEBUG_SHARING\r\nprintk(KERN_DEBUG "%s: parport_claim() returned -EAGAIN\n", dev->name);\r\n#endif\r\nif (dev->waiting) {\r\ninterruptible_sleep_on (&dev->wait_q);\r\nif (signal_pending (current)) {\r\nreturn -EINTR;\r\n}\r\nr = 1;\r\n} else {\r\nr = 0;\r\n#ifdef PARPORT_DEBUG_SHARING\r\nprintk(KERN_DEBUG "%s: didn't sleep in parport_claim_or_block()\n",\r\ndev->name);\r\n#endif\r\n}\r\n#ifdef PARPORT_DEBUG_SHARING\r\nif (dev->port->physport->cad != dev)\r\nprintk(KERN_DEBUG "%s: exiting parport_claim_or_block "\r\n"but %s owns port!\n", dev->name,\r\ndev->port->physport->cad ?\r\ndev->port->physport->cad->name:"nobody");\r\n#endif\r\n}\r\ndev->waiting = 0;\r\nreturn r;\r\n}\r\nvoid parport_release(struct pardevice *dev)\r\n{\r\nstruct parport *port = dev->port->physport;\r\nstruct pardevice *pd;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&port->cad_lock, flags);\r\nif (port->cad != dev) {\r\nwrite_unlock_irqrestore (&port->cad_lock, flags);\r\nprintk(KERN_WARNING "%s: %s tried to release parport "\r\n"when not owner\n", port->name, dev->name);\r\nreturn;\r\n}\r\n#ifdef CONFIG_PARPORT_1284\r\nif (dev->port->muxport >= 0) {\r\nport->muxsel = -1;\r\n}\r\nif (dev->daisy >= 0) {\r\nparport_daisy_deselect_all (port);\r\nport->daisy = -1;\r\n}\r\n#endif\r\nport->cad = NULL;\r\nwrite_unlock_irqrestore(&port->cad_lock, flags);\r\nport->ops->save_state(port, dev->state);\r\nfor (pd = port->waithead; pd; pd = pd->waitnext) {\r\nif (pd->waiting & 2) {\r\nparport_claim(pd);\r\nif (waitqueue_active(&pd->wait_q))\r\nwake_up_interruptible(&pd->wait_q);\r\nreturn;\r\n} else if (pd->wakeup) {\r\npd->wakeup(pd->private);\r\nif (dev->port->cad)\r\nreturn;\r\n} else {\r\nprintk(KERN_ERR "%s: don't know how to wake %s\n", port->name, pd->name);\r\n}\r\n}\r\nfor (pd = port->devices; (port->cad == NULL) && pd; pd = pd->next) {\r\nif (pd->wakeup && pd != dev)\r\npd->wakeup(pd->private);\r\n}\r\n}\r\nirqreturn_t parport_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct parport *port = dev_id;\r\nparport_generic_irq(port);\r\nreturn IRQ_HANDLED;\r\n}
