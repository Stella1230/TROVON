static inline void enable_parport_interrupts (struct net_device *dev)\r\n{\r\nif (dev->irq != -1)\r\n{\r\nstruct parport *port =\r\n((struct net_local *)netdev_priv(dev))->pardev->port;\r\nport->ops->enable_irq (port);\r\n}\r\n}\r\nstatic inline void disable_parport_interrupts (struct net_device *dev)\r\n{\r\nif (dev->irq != -1)\r\n{\r\nstruct parport *port =\r\n((struct net_local *)netdev_priv(dev))->pardev->port;\r\nport->ops->disable_irq (port);\r\n}\r\n}\r\nstatic inline void write_data (struct net_device *dev, unsigned char data)\r\n{\r\nstruct parport *port =\r\n((struct net_local *)netdev_priv(dev))->pardev->port;\r\nport->ops->write_data (port, data);\r\n}\r\nstatic inline unsigned char read_status (struct net_device *dev)\r\n{\r\nstruct parport *port =\r\n((struct net_local *)netdev_priv(dev))->pardev->port;\r\nreturn port->ops->read_status (port);\r\n}\r\nstatic void\r\nplip_init_netdev(struct net_device *dev)\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\ndev->tx_queue_len = 10;\r\ndev->flags = IFF_POINTOPOINT|IFF_NOARP;\r\nmemset(dev->dev_addr, 0xfc, ETH_ALEN);\r\ndev->netdev_ops = &plip_netdev_ops;\r\ndev->header_ops = &plip_header_ops;\r\nnl->port_owner = 0;\r\nnl->trigger = PLIP_TRIGGER_WAIT;\r\nnl->nibble = PLIP_NIBBLE_WAIT;\r\nINIT_WORK(&nl->immediate, plip_bh);\r\nINIT_DELAYED_WORK(&nl->deferred, plip_kick_bh);\r\nif (dev->irq == -1)\r\nINIT_DELAYED_WORK(&nl->timer, plip_timer_bh);\r\nspin_lock_init(&nl->lock);\r\n}\r\nstatic void\r\nplip_kick_bh(struct work_struct *work)\r\n{\r\nstruct net_local *nl =\r\ncontainer_of(work, struct net_local, deferred.work);\r\nif (nl->is_deferred)\r\nschedule_work(&nl->immediate);\r\n}\r\nstatic void\r\nplip_bh(struct work_struct *work)\r\n{\r\nstruct net_local *nl = container_of(work, struct net_local, immediate);\r\nstruct plip_local *snd = &nl->snd_data;\r\nstruct plip_local *rcv = &nl->rcv_data;\r\nplip_func f;\r\nint r;\r\nnl->is_deferred = 0;\r\nf = connection_state_table[nl->connection];\r\nif ((r = (*f)(nl->dev, nl, snd, rcv)) != OK &&\r\n(r = plip_bh_timeout_error(nl->dev, nl, snd, rcv, r)) != OK) {\r\nnl->is_deferred = 1;\r\nschedule_delayed_work(&nl->deferred, 1);\r\n}\r\n}\r\nstatic void\r\nplip_timer_bh(struct work_struct *work)\r\n{\r\nstruct net_local *nl =\r\ncontainer_of(work, struct net_local, timer.work);\r\nif (!(atomic_read (&nl->kill_timer))) {\r\nplip_interrupt (nl->dev);\r\nschedule_delayed_work(&nl->timer, 1);\r\n}\r\nelse {\r\ncomplete(&nl->killed_timer_cmp);\r\n}\r\n}\r\nstatic int\r\nplip_bh_timeout_error(struct net_device *dev, struct net_local *nl,\r\nstruct plip_local *snd, struct plip_local *rcv,\r\nint error)\r\n{\r\nunsigned char c0;\r\nspin_lock_irq(&nl->lock);\r\nif (nl->connection == PLIP_CN_SEND) {\r\nif (error != ERROR) {\r\nnl->timeout_count++;\r\nif ((error == HS_TIMEOUT && nl->timeout_count <= 10) ||\r\nnl->timeout_count <= 3) {\r\nspin_unlock_irq(&nl->lock);\r\nreturn TIMEOUT;\r\n}\r\nc0 = read_status(dev);\r\nprintk(KERN_WARNING "%s: transmit timeout(%d,%02x)\n",\r\ndev->name, snd->state, c0);\r\n} else\r\nerror = HS_TIMEOUT;\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\n} else if (nl->connection == PLIP_CN_RECEIVE) {\r\nif (rcv->state == PLIP_PK_TRIGGER) {\r\nspin_unlock_irq(&nl->lock);\r\nreturn OK;\r\n}\r\nif (error != ERROR) {\r\nif (++nl->timeout_count <= 3) {\r\nspin_unlock_irq(&nl->lock);\r\nreturn TIMEOUT;\r\n}\r\nc0 = read_status(dev);\r\nprintk(KERN_WARNING "%s: receive timeout(%d,%02x)\n",\r\ndev->name, rcv->state, c0);\r\n}\r\ndev->stats.rx_dropped++;\r\n}\r\nrcv->state = PLIP_PK_DONE;\r\nif (rcv->skb) {\r\nkfree_skb(rcv->skb);\r\nrcv->skb = NULL;\r\n}\r\nsnd->state = PLIP_PK_DONE;\r\nif (snd->skb) {\r\ndev_kfree_skb(snd->skb);\r\nsnd->skb = NULL;\r\n}\r\nspin_unlock_irq(&nl->lock);\r\nif (error == HS_TIMEOUT) {\r\nDISABLE(dev->irq);\r\nsynchronize_irq(dev->irq);\r\n}\r\ndisable_parport_interrupts (dev);\r\nnetif_stop_queue (dev);\r\nnl->connection = PLIP_CN_ERROR;\r\nwrite_data (dev, 0x00);\r\nreturn TIMEOUT;\r\n}\r\nstatic int\r\nplip_none(struct net_device *dev, struct net_local *nl,\r\nstruct plip_local *snd, struct plip_local *rcv)\r\n{\r\nreturn OK;\r\n}\r\nstatic inline int\r\nplip_receive(unsigned short nibble_timeout, struct net_device *dev,\r\nenum plip_nibble_state *ns_p, unsigned char *data_p)\r\n{\r\nunsigned char c0, c1;\r\nunsigned int cx;\r\nswitch (*ns_p) {\r\ncase PLIP_NB_BEGIN:\r\ncx = nibble_timeout;\r\nwhile (1) {\r\nc0 = read_status(dev);\r\nudelay(PLIP_DELAY_UNIT);\r\nif ((c0 & 0x80) == 0) {\r\nc1 = read_status(dev);\r\nif (c0 == c1)\r\nbreak;\r\n}\r\nif (--cx == 0)\r\nreturn TIMEOUT;\r\n}\r\n*data_p = (c0 >> 3) & 0x0f;\r\nwrite_data (dev, 0x10);\r\n*ns_p = PLIP_NB_1;\r\ncase PLIP_NB_1:\r\ncx = nibble_timeout;\r\nwhile (1) {\r\nc0 = read_status(dev);\r\nudelay(PLIP_DELAY_UNIT);\r\nif (c0 & 0x80) {\r\nc1 = read_status(dev);\r\nif (c0 == c1)\r\nbreak;\r\n}\r\nif (--cx == 0)\r\nreturn TIMEOUT;\r\n}\r\n*data_p |= (c0 << 1) & 0xf0;\r\nwrite_data (dev, 0x00);\r\n*ns_p = PLIP_NB_BEGIN;\r\ncase PLIP_NB_2:\r\nbreak;\r\n}\r\nreturn OK;\r\n}\r\nstatic __be16 plip_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ethhdr *eth;\r\nunsigned char *rawp;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb,dev->hard_header_len);\r\neth = eth_hdr(skb);\r\nif(*eth->h_dest&1)\r\n{\r\nif(memcmp(eth->h_dest,dev->broadcast, ETH_ALEN)==0)\r\nskb->pkt_type=PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type=PACKET_MULTICAST;\r\n}\r\nif (ntohs(eth->h_proto) >= 1536)\r\nreturn eth->h_proto;\r\nrawp = skb->data;\r\nif (*(unsigned short *)rawp == 0xFFFF)\r\nreturn htons(ETH_P_802_3);\r\nreturn htons(ETH_P_802_2);\r\n}\r\nstatic int\r\nplip_receive_packet(struct net_device *dev, struct net_local *nl,\r\nstruct plip_local *snd, struct plip_local *rcv)\r\n{\r\nunsigned short nibble_timeout = nl->nibble;\r\nunsigned char *lbuf;\r\nswitch (rcv->state) {\r\ncase PLIP_PK_TRIGGER:\r\nDISABLE(dev->irq);\r\ndisable_parport_interrupts (dev);\r\nwrite_data (dev, 0x01);\r\nif (net_debug > 2)\r\nprintk(KERN_DEBUG "%s: receive start\n", dev->name);\r\nrcv->state = PLIP_PK_LENGTH_LSB;\r\nrcv->nibble = PLIP_NB_BEGIN;\r\ncase PLIP_PK_LENGTH_LSB:\r\nif (snd->state != PLIP_PK_DONE) {\r\nif (plip_receive(nl->trigger, dev,\r\n&rcv->nibble, &rcv->length.b.lsb)) {\r\nrcv->state = PLIP_PK_DONE;\r\nnl->is_deferred = 1;\r\nnl->connection = PLIP_CN_SEND;\r\nschedule_delayed_work(&nl->deferred, 1);\r\nenable_parport_interrupts (dev);\r\nENABLE(dev->irq);\r\nreturn OK;\r\n}\r\n} else {\r\nif (plip_receive(nibble_timeout, dev,\r\n&rcv->nibble, &rcv->length.b.lsb))\r\nreturn TIMEOUT;\r\n}\r\nrcv->state = PLIP_PK_LENGTH_MSB;\r\ncase PLIP_PK_LENGTH_MSB:\r\nif (plip_receive(nibble_timeout, dev,\r\n&rcv->nibble, &rcv->length.b.msb))\r\nreturn TIMEOUT;\r\nif (rcv->length.h > dev->mtu + dev->hard_header_len ||\r\nrcv->length.h < 8) {\r\nprintk(KERN_WARNING "%s: bogus packet size %d.\n", dev->name, rcv->length.h);\r\nreturn ERROR;\r\n}\r\nrcv->skb = dev_alloc_skb(rcv->length.h + 2);\r\nif (rcv->skb == NULL) {\r\nprintk(KERN_ERR "%s: Memory squeeze.\n", dev->name);\r\nreturn ERROR;\r\n}\r\nskb_reserve(rcv->skb, 2);\r\nskb_put(rcv->skb,rcv->length.h);\r\nrcv->skb->dev = dev;\r\nrcv->state = PLIP_PK_DATA;\r\nrcv->byte = 0;\r\nrcv->checksum = 0;\r\ncase PLIP_PK_DATA:\r\nlbuf = rcv->skb->data;\r\ndo {\r\nif (plip_receive(nibble_timeout, dev,\r\n&rcv->nibble, &lbuf[rcv->byte]))\r\nreturn TIMEOUT;\r\n} while (++rcv->byte < rcv->length.h);\r\ndo {\r\nrcv->checksum += lbuf[--rcv->byte];\r\n} while (rcv->byte);\r\nrcv->state = PLIP_PK_CHECKSUM;\r\ncase PLIP_PK_CHECKSUM:\r\nif (plip_receive(nibble_timeout, dev,\r\n&rcv->nibble, &rcv->data))\r\nreturn TIMEOUT;\r\nif (rcv->data != rcv->checksum) {\r\ndev->stats.rx_crc_errors++;\r\nif (net_debug)\r\nprintk(KERN_DEBUG "%s: checksum error\n", dev->name);\r\nreturn ERROR;\r\n}\r\nrcv->state = PLIP_PK_DONE;\r\ncase PLIP_PK_DONE:\r\nrcv->skb->protocol=plip_type_trans(rcv->skb, dev);\r\nnetif_rx_ni(rcv->skb);\r\ndev->stats.rx_bytes += rcv->length.h;\r\ndev->stats.rx_packets++;\r\nrcv->skb = NULL;\r\nif (net_debug > 2)\r\nprintk(KERN_DEBUG "%s: receive end\n", dev->name);\r\nwrite_data (dev, 0x00);\r\nspin_lock_irq(&nl->lock);\r\nif (snd->state != PLIP_PK_DONE) {\r\nnl->connection = PLIP_CN_SEND;\r\nspin_unlock_irq(&nl->lock);\r\nschedule_work(&nl->immediate);\r\nenable_parport_interrupts (dev);\r\nENABLE(dev->irq);\r\nreturn OK;\r\n} else {\r\nnl->connection = PLIP_CN_NONE;\r\nspin_unlock_irq(&nl->lock);\r\nenable_parport_interrupts (dev);\r\nENABLE(dev->irq);\r\nreturn OK;\r\n}\r\n}\r\nreturn OK;\r\n}\r\nstatic inline int\r\nplip_send(unsigned short nibble_timeout, struct net_device *dev,\r\nenum plip_nibble_state *ns_p, unsigned char data)\r\n{\r\nunsigned char c0;\r\nunsigned int cx;\r\nswitch (*ns_p) {\r\ncase PLIP_NB_BEGIN:\r\nwrite_data (dev, data & 0x0f);\r\n*ns_p = PLIP_NB_1;\r\ncase PLIP_NB_1:\r\nwrite_data (dev, 0x10 | (data & 0x0f));\r\ncx = nibble_timeout;\r\nwhile (1) {\r\nc0 = read_status(dev);\r\nif ((c0 & 0x80) == 0)\r\nbreak;\r\nif (--cx == 0)\r\nreturn TIMEOUT;\r\nudelay(PLIP_DELAY_UNIT);\r\n}\r\nwrite_data (dev, 0x10 | (data >> 4));\r\n*ns_p = PLIP_NB_2;\r\ncase PLIP_NB_2:\r\nwrite_data (dev, (data >> 4));\r\ncx = nibble_timeout;\r\nwhile (1) {\r\nc0 = read_status(dev);\r\nif (c0 & 0x80)\r\nbreak;\r\nif (--cx == 0)\r\nreturn TIMEOUT;\r\nudelay(PLIP_DELAY_UNIT);\r\n}\r\n*ns_p = PLIP_NB_BEGIN;\r\nreturn OK;\r\n}\r\nreturn OK;\r\n}\r\nstatic int\r\nplip_send_packet(struct net_device *dev, struct net_local *nl,\r\nstruct plip_local *snd, struct plip_local *rcv)\r\n{\r\nunsigned short nibble_timeout = nl->nibble;\r\nunsigned char *lbuf;\r\nunsigned char c0;\r\nunsigned int cx;\r\nif (snd->skb == NULL || (lbuf = snd->skb->data) == NULL) {\r\nprintk(KERN_DEBUG "%s: send skb lost\n", dev->name);\r\nsnd->state = PLIP_PK_DONE;\r\nsnd->skb = NULL;\r\nreturn ERROR;\r\n}\r\nswitch (snd->state) {\r\ncase PLIP_PK_TRIGGER:\r\nif ((read_status(dev) & 0xf8) != 0x80)\r\nreturn HS_TIMEOUT;\r\nwrite_data (dev, 0x08);\r\ncx = nl->trigger;\r\nwhile (1) {\r\nudelay(PLIP_DELAY_UNIT);\r\nspin_lock_irq(&nl->lock);\r\nif (nl->connection == PLIP_CN_RECEIVE) {\r\nspin_unlock_irq(&nl->lock);\r\ndev->stats.collisions++;\r\nreturn OK;\r\n}\r\nc0 = read_status(dev);\r\nif (c0 & 0x08) {\r\nspin_unlock_irq(&nl->lock);\r\nDISABLE(dev->irq);\r\nsynchronize_irq(dev->irq);\r\nif (nl->connection == PLIP_CN_RECEIVE) {\r\nENABLE(dev->irq);\r\ndev->stats.collisions++;\r\nreturn OK;\r\n}\r\ndisable_parport_interrupts (dev);\r\nif (net_debug > 2)\r\nprintk(KERN_DEBUG "%s: send start\n", dev->name);\r\nsnd->state = PLIP_PK_LENGTH_LSB;\r\nsnd->nibble = PLIP_NB_BEGIN;\r\nnl->timeout_count = 0;\r\nbreak;\r\n}\r\nspin_unlock_irq(&nl->lock);\r\nif (--cx == 0) {\r\nwrite_data (dev, 0x00);\r\nreturn HS_TIMEOUT;\r\n}\r\n}\r\ncase PLIP_PK_LENGTH_LSB:\r\nif (plip_send(nibble_timeout, dev,\r\n&snd->nibble, snd->length.b.lsb))\r\nreturn TIMEOUT;\r\nsnd->state = PLIP_PK_LENGTH_MSB;\r\ncase PLIP_PK_LENGTH_MSB:\r\nif (plip_send(nibble_timeout, dev,\r\n&snd->nibble, snd->length.b.msb))\r\nreturn TIMEOUT;\r\nsnd->state = PLIP_PK_DATA;\r\nsnd->byte = 0;\r\nsnd->checksum = 0;\r\ncase PLIP_PK_DATA:\r\ndo {\r\nif (plip_send(nibble_timeout, dev,\r\n&snd->nibble, lbuf[snd->byte]))\r\nreturn TIMEOUT;\r\n} while (++snd->byte < snd->length.h);\r\ndo {\r\nsnd->checksum += lbuf[--snd->byte];\r\n} while (snd->byte);\r\nsnd->state = PLIP_PK_CHECKSUM;\r\ncase PLIP_PK_CHECKSUM:\r\nif (plip_send(nibble_timeout, dev,\r\n&snd->nibble, snd->checksum))\r\nreturn TIMEOUT;\r\ndev->stats.tx_bytes += snd->skb->len;\r\ndev_kfree_skb(snd->skb);\r\ndev->stats.tx_packets++;\r\nsnd->state = PLIP_PK_DONE;\r\ncase PLIP_PK_DONE:\r\nwrite_data (dev, 0x00);\r\nsnd->skb = NULL;\r\nif (net_debug > 2)\r\nprintk(KERN_DEBUG "%s: send end\n", dev->name);\r\nnl->connection = PLIP_CN_CLOSING;\r\nnl->is_deferred = 1;\r\nschedule_delayed_work(&nl->deferred, 1);\r\nenable_parport_interrupts (dev);\r\nENABLE(dev->irq);\r\nreturn OK;\r\n}\r\nreturn OK;\r\n}\r\nstatic int\r\nplip_connection_close(struct net_device *dev, struct net_local *nl,\r\nstruct plip_local *snd, struct plip_local *rcv)\r\n{\r\nspin_lock_irq(&nl->lock);\r\nif (nl->connection == PLIP_CN_CLOSING) {\r\nnl->connection = PLIP_CN_NONE;\r\nnetif_wake_queue (dev);\r\n}\r\nspin_unlock_irq(&nl->lock);\r\nif (nl->should_relinquish) {\r\nnl->should_relinquish = nl->port_owner = 0;\r\nparport_release(nl->pardev);\r\n}\r\nreturn OK;\r\n}\r\nstatic int\r\nplip_error(struct net_device *dev, struct net_local *nl,\r\nstruct plip_local *snd, struct plip_local *rcv)\r\n{\r\nunsigned char status;\r\nstatus = read_status(dev);\r\nif ((status & 0xf8) == 0x80) {\r\nif (net_debug > 2)\r\nprintk(KERN_DEBUG "%s: reset interface.\n", dev->name);\r\nnl->connection = PLIP_CN_NONE;\r\nnl->should_relinquish = 0;\r\nnetif_start_queue (dev);\r\nenable_parport_interrupts (dev);\r\nENABLE(dev->irq);\r\nnetif_wake_queue (dev);\r\n} else {\r\nnl->is_deferred = 1;\r\nschedule_delayed_work(&nl->deferred, 1);\r\n}\r\nreturn OK;\r\n}\r\nstatic void\r\nplip_interrupt(void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *nl;\r\nstruct plip_local *rcv;\r\nunsigned char c0;\r\nunsigned long flags;\r\nnl = netdev_priv(dev);\r\nrcv = &nl->rcv_data;\r\nspin_lock_irqsave (&nl->lock, flags);\r\nc0 = read_status(dev);\r\nif ((c0 & 0xf8) != 0xc0) {\r\nif ((dev->irq != -1) && (net_debug > 1))\r\nprintk(KERN_DEBUG "%s: spurious interrupt\n", dev->name);\r\nspin_unlock_irqrestore (&nl->lock, flags);\r\nreturn;\r\n}\r\nif (net_debug > 3)\r\nprintk(KERN_DEBUG "%s: interrupt.\n", dev->name);\r\nswitch (nl->connection) {\r\ncase PLIP_CN_CLOSING:\r\nnetif_wake_queue (dev);\r\ncase PLIP_CN_NONE:\r\ncase PLIP_CN_SEND:\r\nrcv->state = PLIP_PK_TRIGGER;\r\nnl->connection = PLIP_CN_RECEIVE;\r\nnl->timeout_count = 0;\r\nschedule_work(&nl->immediate);\r\nbreak;\r\ncase PLIP_CN_RECEIVE:\r\nbreak;\r\ncase PLIP_CN_ERROR:\r\nprintk(KERN_ERR "%s: receive interrupt in error state\n", dev->name);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&nl->lock, flags);\r\n}\r\nstatic int\r\nplip_tx_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct plip_local *snd = &nl->snd_data;\r\nif (netif_queue_stopped(dev))\r\nreturn NETDEV_TX_BUSY;\r\nif (!nl->port_owner) {\r\nif (parport_claim(nl->pardev))\r\nreturn NETDEV_TX_BUSY;\r\nnl->port_owner = 1;\r\n}\r\nnetif_stop_queue (dev);\r\nif (skb->len > dev->mtu + dev->hard_header_len) {\r\nprintk(KERN_WARNING "%s: packet too big, %d.\n", dev->name, (int)skb->len);\r\nnetif_start_queue (dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (net_debug > 2)\r\nprintk(KERN_DEBUG "%s: send request\n", dev->name);\r\nspin_lock_irq(&nl->lock);\r\nsnd->skb = skb;\r\nsnd->length.h = skb->len;\r\nsnd->state = PLIP_PK_TRIGGER;\r\nif (nl->connection == PLIP_CN_NONE) {\r\nnl->connection = PLIP_CN_SEND;\r\nnl->timeout_count = 0;\r\n}\r\nschedule_work(&nl->immediate);\r\nspin_unlock_irq(&nl->lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nplip_rewrite_address(const struct net_device *dev, struct ethhdr *eth)\r\n{\r\nconst struct in_device *in_dev;\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(dev);\r\nif (in_dev) {\r\nconst struct in_ifaddr *ifa = in_dev->ifa_list;\r\nif (ifa) {\r\nmemcpy(eth->h_source, dev->dev_addr, 6);\r\nmemset(eth->h_dest, 0xfc, 2);\r\nmemcpy(eth->h_dest+2, &ifa->ifa_address, 4);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int\r\nplip_hard_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *daddr,\r\nconst void *saddr, unsigned len)\r\n{\r\nint ret;\r\nret = eth_header(skb, dev, type, daddr, saddr, len);\r\nif (ret >= 0)\r\nplip_rewrite_address (dev, (struct ethhdr *)skb->data);\r\nreturn ret;\r\n}\r\nstatic int plip_hard_header_cache(const struct neighbour *neigh,\r\nstruct hh_cache *hh, __be16 type)\r\n{\r\nint ret;\r\nret = eth_header_cache(neigh, hh, type);\r\nif (ret == 0) {\r\nstruct ethhdr *eth;\r\neth = (struct ethhdr*)(((u8*)hh->hh_data) +\r\nHH_DATA_OFF(sizeof(*eth)));\r\nplip_rewrite_address (neigh->dev, eth);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nplip_open(struct net_device *dev)\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct in_device *in_dev;\r\nif (!nl->port_owner) {\r\nif (parport_claim(nl->pardev)) return -EAGAIN;\r\nnl->port_owner = 1;\r\n}\r\nnl->should_relinquish = 0;\r\nwrite_data (dev, 0x00);\r\nenable_parport_interrupts (dev);\r\nif (dev->irq == -1)\r\n{\r\natomic_set (&nl->kill_timer, 0);\r\nschedule_delayed_work(&nl->timer, 1);\r\n}\r\nnl->rcv_data.state = nl->snd_data.state = PLIP_PK_DONE;\r\nnl->rcv_data.skb = nl->snd_data.skb = NULL;\r\nnl->connection = PLIP_CN_NONE;\r\nnl->is_deferred = 0;\r\nin_dev=__in_dev_get_rtnl(dev);\r\nif (in_dev) {\r\nstruct in_ifaddr *ifa=in_dev->ifa_list;\r\nif (ifa != NULL) {\r\nmemcpy(dev->dev_addr+2, &ifa->ifa_local, 4);\r\n}\r\n}\r\nnetif_start_queue (dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nplip_close(struct net_device *dev)\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct plip_local *snd = &nl->snd_data;\r\nstruct plip_local *rcv = &nl->rcv_data;\r\nnetif_stop_queue (dev);\r\nDISABLE(dev->irq);\r\nsynchronize_irq(dev->irq);\r\nif (dev->irq == -1)\r\n{\r\ninit_completion(&nl->killed_timer_cmp);\r\natomic_set (&nl->kill_timer, 1);\r\nwait_for_completion(&nl->killed_timer_cmp);\r\n}\r\n#ifdef NOTDEF\r\noutb(0x00, PAR_DATA(dev));\r\n#endif\r\nnl->is_deferred = 0;\r\nnl->connection = PLIP_CN_NONE;\r\nif (nl->port_owner) {\r\nparport_release(nl->pardev);\r\nnl->port_owner = 0;\r\n}\r\nsnd->state = PLIP_PK_DONE;\r\nif (snd->skb) {\r\ndev_kfree_skb(snd->skb);\r\nsnd->skb = NULL;\r\n}\r\nrcv->state = PLIP_PK_DONE;\r\nif (rcv->skb) {\r\nkfree_skb(rcv->skb);\r\nrcv->skb = NULL;\r\n}\r\n#ifdef NOTDEF\r\noutb(0x00, PAR_CONTROL(dev));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nplip_preempt(void *handle)\r\n{\r\nstruct net_device *dev = (struct net_device *)handle;\r\nstruct net_local *nl = netdev_priv(dev);\r\nif (nl->connection != PLIP_CN_NONE) {\r\nnl->should_relinquish = 1;\r\nreturn 1;\r\n}\r\nnl->port_owner = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nplip_wakeup(void *handle)\r\n{\r\nstruct net_device *dev = (struct net_device *)handle;\r\nstruct net_local *nl = netdev_priv(dev);\r\nif (nl->port_owner) {\r\nprintk(KERN_DEBUG "%s: why am I being woken up?\n", dev->name);\r\nif (!parport_claim(nl->pardev))\r\nprintk(KERN_DEBUG "%s: I'm broken.\n", dev->name);\r\nelse\r\nreturn;\r\n}\r\nif (!(dev->flags & IFF_UP))\r\nreturn;\r\nif (!parport_claim(nl->pardev)) {\r\nnl->port_owner = 1;\r\nwrite_data (dev, 0x00);\r\n}\r\n}\r\nstatic int\r\nplip_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct net_local *nl = netdev_priv(dev);\r\nstruct plipconf *pc = (struct plipconf *) &rq->ifr_ifru;\r\nif (cmd != SIOCDEVPLIP)\r\nreturn -EOPNOTSUPP;\r\nswitch(pc->pcmd) {\r\ncase PLIP_GET_TIMEOUT:\r\npc->trigger = nl->trigger;\r\npc->nibble = nl->nibble;\r\nbreak;\r\ncase PLIP_SET_TIMEOUT:\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nnl->trigger = pc->trigger;\r\nnl->nibble = pc->nibble;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\nplip_searchfor(int list[], int a)\r\n{\r\nint i;\r\nfor (i = 0; i < PLIP_MAX && list[i] != -1; i++) {\r\nif (list[i] == a) return 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void plip_attach (struct parport *port)\r\n{\r\nstatic int unit;\r\nstruct net_device *dev;\r\nstruct net_local *nl;\r\nchar name[IFNAMSIZ];\r\nif ((parport[0] == -1 && (!timid || !port->devices)) ||\r\nplip_searchfor(parport, port->number)) {\r\nif (unit == PLIP_MAX) {\r\nprintk(KERN_ERR "plip: too many devices\n");\r\nreturn;\r\n}\r\nsprintf(name, "plip%d", unit);\r\ndev = alloc_etherdev(sizeof(struct net_local));\r\nif (!dev)\r\nreturn;\r\nstrcpy(dev->name, name);\r\ndev->irq = port->irq;\r\ndev->base_addr = port->base;\r\nif (port->irq == -1) {\r\nprintk(KERN_INFO "plip: %s has no IRQ. Using IRQ-less mode,"\r\n"which is fairly inefficient!\n", port->name);\r\n}\r\nnl = netdev_priv(dev);\r\nnl->dev = dev;\r\nnl->pardev = parport_register_device(port, dev->name, plip_preempt,\r\nplip_wakeup, plip_interrupt,\r\n0, dev);\r\nif (!nl->pardev) {\r\nprintk(KERN_ERR "%s: parport_register failed\n", name);\r\ngoto err_free_dev;\r\n}\r\nplip_init_netdev(dev);\r\nif (register_netdev(dev)) {\r\nprintk(KERN_ERR "%s: network register failed\n", name);\r\ngoto err_parport_unregister;\r\n}\r\nprintk(KERN_INFO "%s", version);\r\nif (dev->irq != -1)\r\nprintk(KERN_INFO "%s: Parallel port at %#3lx, "\r\n"using IRQ %d.\n",\r\ndev->name, dev->base_addr, dev->irq);\r\nelse\r\nprintk(KERN_INFO "%s: Parallel port at %#3lx, "\r\n"not using IRQ.\n",\r\ndev->name, dev->base_addr);\r\ndev_plip[unit++] = dev;\r\n}\r\nreturn;\r\nerr_parport_unregister:\r\nparport_unregister_device(nl->pardev);\r\nerr_free_dev:\r\nfree_netdev(dev);\r\n}\r\nstatic void plip_detach (struct parport *port)\r\n{\r\n}\r\nstatic void __exit plip_cleanup_module (void)\r\n{\r\nstruct net_device *dev;\r\nint i;\r\nparport_unregister_driver (&plip_driver);\r\nfor (i=0; i < PLIP_MAX; i++) {\r\nif ((dev = dev_plip[i])) {\r\nstruct net_local *nl = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nif (nl->port_owner)\r\nparport_release(nl->pardev);\r\nparport_unregister_device(nl->pardev);\r\nfree_netdev(dev);\r\ndev_plip[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int __init plip_setup(char *str)\r\n{\r\nint ints[4];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nif (!strncmp(str, "parport", 7)) {\r\nint n = simple_strtoul(str+7, NULL, 10);\r\nif (parport_ptr < PLIP_MAX)\r\nparport[parport_ptr++] = n;\r\nelse\r\nprintk(KERN_INFO "plip: too many ports, %s ignored.\n",\r\nstr);\r\n} else if (!strcmp(str, "timid")) {\r\ntimid = 1;\r\n} else {\r\nif (ints[0] == 0 || ints[1] == 0) {\r\nparport[0] = -2;\r\n} else {\r\nprintk(KERN_WARNING "warning: 'plip=0x%x' ignored\n",\r\nints[1]);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init plip_init (void)\r\n{\r\nif (parport[0] == -2)\r\nreturn 0;\r\nif (parport[0] != -1 && timid) {\r\nprintk(KERN_WARNING "plip: warning, ignoring `timid' since specific ports given.\n");\r\ntimid = 0;\r\n}\r\nif (parport_register_driver (&plip_driver)) {\r\nprintk (KERN_WARNING "plip: couldn't register driver\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
