static void\r\nnvc0_graph_ctxctl_debug_unit(struct drm_device *dev, u32 base)\r\n{\r\nNV_INFO(dev, "PGRAPH: %06x - done 0x%08x\n", base,\r\nnv_rd32(dev, base + 0x400));\r\nNV_INFO(dev, "PGRAPH: %06x - stat 0x%08x 0x%08x 0x%08x 0x%08x\n", base,\r\nnv_rd32(dev, base + 0x800), nv_rd32(dev, base + 0x804),\r\nnv_rd32(dev, base + 0x808), nv_rd32(dev, base + 0x80c));\r\nNV_INFO(dev, "PGRAPH: %06x - stat 0x%08x 0x%08x 0x%08x 0x%08x\n", base,\r\nnv_rd32(dev, base + 0x810), nv_rd32(dev, base + 0x814),\r\nnv_rd32(dev, base + 0x818), nv_rd32(dev, base + 0x81c));\r\n}\r\nstatic void\r\nnvc0_graph_ctxctl_debug(struct drm_device *dev)\r\n{\r\nu32 gpcnr = nv_rd32(dev, 0x409604) & 0xffff;\r\nu32 gpc;\r\nnvc0_graph_ctxctl_debug_unit(dev, 0x409000);\r\nfor (gpc = 0; gpc < gpcnr; gpc++)\r\nnvc0_graph_ctxctl_debug_unit(dev, 0x502000 + (gpc * 0x8000));\r\n}\r\nstatic int\r\nnvc0_graph_load_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nnv_wr32(dev, 0x409840, 0x00000030);\r\nnv_wr32(dev, 0x409500, 0x80000000 | chan->ramin->vinst >> 12);\r\nnv_wr32(dev, 0x409504, 0x00000003);\r\nif (!nv_wait(dev, 0x409800, 0x00000010, 0x00000010))\r\nNV_ERROR(dev, "PGRAPH: load_ctx timeout\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_graph_unload_context_to(struct drm_device *dev, u64 chan)\r\n{\r\nnv_wr32(dev, 0x409840, 0x00000003);\r\nnv_wr32(dev, 0x409500, 0x80000000 | chan >> 12);\r\nnv_wr32(dev, 0x409504, 0x00000009);\r\nif (!nv_wait(dev, 0x409800, 0x00000001, 0x00000000)) {\r\nNV_ERROR(dev, "PGRAPH: unload_ctx timeout\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_graph_construct_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_nouveau_private *dev_priv = chan->dev->dev_private;\r\nstruct nvc0_graph_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);\r\nstruct nvc0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];\r\nstruct drm_device *dev = chan->dev;\r\nint ret, i;\r\nu32 *ctx;\r\nctx = kmalloc(priv->grctx_size, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nif (!nouveau_ctxfw) {\r\nnv_wr32(dev, 0x409840, 0x80000000);\r\nnv_wr32(dev, 0x409500, 0x80000000 | chan->ramin->vinst >> 12);\r\nnv_wr32(dev, 0x409504, 0x00000001);\r\nif (!nv_wait(dev, 0x409800, 0x80000000, 0x80000000)) {\r\nNV_ERROR(dev, "PGRAPH: HUB_SET_CHAN timeout\n");\r\nnvc0_graph_ctxctl_debug(dev);\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\n} else {\r\nnvc0_graph_load_context(chan);\r\nnv_wo32(grch->grctx, 0x1c, 1);\r\nnv_wo32(grch->grctx, 0x20, 0);\r\nnv_wo32(grch->grctx, 0x28, 0);\r\nnv_wo32(grch->grctx, 0x2c, 0);\r\ndev_priv->engine.instmem.flush(dev);\r\n}\r\nret = nvc0_grctx_generate(chan);\r\nif (ret)\r\ngoto err;\r\nif (!nouveau_ctxfw) {\r\nnv_wr32(dev, 0x409840, 0x80000000);\r\nnv_wr32(dev, 0x409500, 0x80000000 | chan->ramin->vinst >> 12);\r\nnv_wr32(dev, 0x409504, 0x00000002);\r\nif (!nv_wait(dev, 0x409800, 0x80000000, 0x80000000)) {\r\nNV_ERROR(dev, "PGRAPH: HUB_CTX_SAVE timeout\n");\r\nnvc0_graph_ctxctl_debug(dev);\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\n} else {\r\nret = nvc0_graph_unload_context_to(dev, chan->ramin->vinst);\r\nif (ret)\r\ngoto err;\r\n}\r\nfor (i = 0; i < priv->grctx_size; i += 4)\r\nctx[i / 4] = nv_ro32(grch->grctx, i);\r\npriv->grctx_vals = ctx;\r\nreturn 0;\r\nerr:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int\r\nnvc0_graph_create_context_mmio_list(struct nouveau_channel *chan)\r\n{\r\nstruct nvc0_graph_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);\r\nstruct nvc0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint i = 0, gpc, tp, ret;\r\nret = nouveau_gpuobj_new(dev, chan, 0x2000, 256, NVOBJ_FLAG_VM,\r\n&grch->unk408004);\r\nif (ret)\r\nreturn ret;\r\nret = nouveau_gpuobj_new(dev, chan, 0x8000, 256, NVOBJ_FLAG_VM,\r\n&grch->unk40800c);\r\nif (ret)\r\nreturn ret;\r\nret = nouveau_gpuobj_new(dev, chan, 384 * 1024, 4096,\r\nNVOBJ_FLAG_VM | NVOBJ_FLAG_VM_USER,\r\n&grch->unk418810);\r\nif (ret)\r\nreturn ret;\r\nret = nouveau_gpuobj_new(dev, chan, 0x1000, 0, NVOBJ_FLAG_VM,\r\n&grch->mmio);\r\nif (ret)\r\nreturn ret;\r\nnv_wo32(grch->mmio, i++ * 4, 0x00408004);\r\nnv_wo32(grch->mmio, i++ * 4, grch->unk408004->linst >> 8);\r\nnv_wo32(grch->mmio, i++ * 4, 0x00408008);\r\nnv_wo32(grch->mmio, i++ * 4, 0x80000018);\r\nnv_wo32(grch->mmio, i++ * 4, 0x0040800c);\r\nnv_wo32(grch->mmio, i++ * 4, grch->unk40800c->linst >> 8);\r\nnv_wo32(grch->mmio, i++ * 4, 0x00408010);\r\nnv_wo32(grch->mmio, i++ * 4, 0x80000000);\r\nnv_wo32(grch->mmio, i++ * 4, 0x00418810);\r\nnv_wo32(grch->mmio, i++ * 4, 0x80000000 | grch->unk418810->linst >> 12);\r\nnv_wo32(grch->mmio, i++ * 4, 0x00419848);\r\nnv_wo32(grch->mmio, i++ * 4, 0x10000000 | grch->unk418810->linst >> 12);\r\nnv_wo32(grch->mmio, i++ * 4, 0x00419004);\r\nnv_wo32(grch->mmio, i++ * 4, grch->unk40800c->linst >> 8);\r\nnv_wo32(grch->mmio, i++ * 4, 0x00419008);\r\nnv_wo32(grch->mmio, i++ * 4, 0x00000000);\r\nnv_wo32(grch->mmio, i++ * 4, 0x00418808);\r\nnv_wo32(grch->mmio, i++ * 4, grch->unk408004->linst >> 8);\r\nnv_wo32(grch->mmio, i++ * 4, 0x0041880c);\r\nnv_wo32(grch->mmio, i++ * 4, 0x80000018);\r\nif (dev_priv->chipset != 0xc1) {\r\nu32 magic = 0x02180000;\r\nnv_wo32(grch->mmio, i++ * 4, 0x00405830);\r\nnv_wo32(grch->mmio, i++ * 4, magic);\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\nfor (tp = 0; tp < priv->tp_nr[gpc]; tp++) {\r\nu32 reg = TP_UNIT(gpc, tp, 0x520);\r\nnv_wo32(grch->mmio, i++ * 4, reg);\r\nnv_wo32(grch->mmio, i++ * 4, magic);\r\nmagic += 0x0324;\r\n}\r\n}\r\n} else {\r\nu32 magic = 0x02180000;\r\nnv_wo32(grch->mmio, i++ * 4, 0x00405830);\r\nnv_wo32(grch->mmio, i++ * 4, magic | 0x0000218);\r\nnv_wo32(grch->mmio, i++ * 4, 0x004064c4);\r\nnv_wo32(grch->mmio, i++ * 4, 0x0086ffff);\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\nfor (tp = 0; tp < priv->tp_nr[gpc]; tp++) {\r\nu32 reg = TP_UNIT(gpc, tp, 0x520);\r\nnv_wo32(grch->mmio, i++ * 4, reg);\r\nnv_wo32(grch->mmio, i++ * 4, (1 << 28) | magic);\r\nmagic += 0x0324;\r\n}\r\nfor (tp = 0; tp < priv->tp_nr[gpc]; tp++) {\r\nu32 reg = TP_UNIT(gpc, tp, 0x544);\r\nnv_wo32(grch->mmio, i++ * 4, reg);\r\nnv_wo32(grch->mmio, i++ * 4, magic);\r\nmagic += 0x0324;\r\n}\r\n}\r\n}\r\ngrch->mmio_nr = i / 2;\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_graph_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_instmem_engine *pinstmem = &dev_priv->engine.instmem;\r\nstruct nvc0_graph_priv *priv = nv_engine(dev, engine);\r\nstruct nvc0_graph_chan *grch;\r\nstruct nouveau_gpuobj *grctx;\r\nint ret, i;\r\ngrch = kzalloc(sizeof(*grch), GFP_KERNEL);\r\nif (!grch)\r\nreturn -ENOMEM;\r\nchan->engctx[NVOBJ_ENGINE_GR] = grch;\r\nret = nouveau_gpuobj_new(dev, chan, priv->grctx_size, 256,\r\nNVOBJ_FLAG_VM | NVOBJ_FLAG_ZERO_ALLOC,\r\n&grch->grctx);\r\nif (ret)\r\ngoto error;\r\ngrctx = grch->grctx;\r\nret = nvc0_graph_create_context_mmio_list(chan);\r\nif (ret)\r\ngoto error;\r\nnv_wo32(chan->ramin, 0x0210, lower_32_bits(grctx->linst) | 4);\r\nnv_wo32(chan->ramin, 0x0214, upper_32_bits(grctx->linst));\r\npinstmem->flush(dev);\r\nif (!priv->grctx_vals) {\r\nret = nvc0_graph_construct_context(chan);\r\nif (ret)\r\ngoto error;\r\n}\r\nfor (i = 0; i < priv->grctx_size; i += 4)\r\nnv_wo32(grctx, i, priv->grctx_vals[i / 4]);\r\nif (!nouveau_ctxfw) {\r\nnv_wo32(grctx, 0x00, grch->mmio_nr);\r\nnv_wo32(grctx, 0x04, grch->mmio->linst >> 8);\r\n} else {\r\nnv_wo32(grctx, 0xf4, 0);\r\nnv_wo32(grctx, 0xf8, 0);\r\nnv_wo32(grctx, 0x10, grch->mmio_nr);\r\nnv_wo32(grctx, 0x14, lower_32_bits(grch->mmio->linst));\r\nnv_wo32(grctx, 0x18, upper_32_bits(grch->mmio->linst));\r\nnv_wo32(grctx, 0x1c, 1);\r\nnv_wo32(grctx, 0x20, 0);\r\nnv_wo32(grctx, 0x28, 0);\r\nnv_wo32(grctx, 0x2c, 0);\r\n}\r\npinstmem->flush(dev);\r\nreturn 0;\r\nerror:\r\npriv->base.context_del(chan, engine);\r\nreturn ret;\r\n}\r\nstatic void\r\nnvc0_graph_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nvc0_graph_chan *grch = chan->engctx[engine];\r\nnouveau_gpuobj_ref(NULL, &grch->mmio);\r\nnouveau_gpuobj_ref(NULL, &grch->unk418810);\r\nnouveau_gpuobj_ref(NULL, &grch->unk40800c);\r\nnouveau_gpuobj_ref(NULL, &grch->unk408004);\r\nnouveau_gpuobj_ref(NULL, &grch->grctx);\r\nchan->engctx[engine] = NULL;\r\n}\r\nstatic int\r\nnvc0_graph_object_new(struct nouveau_channel *chan, int engine,\r\nu32 handle, u16 class)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_graph_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nnvc0_graph_init_obj418880(struct drm_device *dev)\r\n{\r\nstruct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nint i;\r\nnv_wr32(dev, GPC_BCAST(0x0880), 0x00000000);\r\nnv_wr32(dev, GPC_BCAST(0x08a4), 0x00000000);\r\nfor (i = 0; i < 4; i++)\r\nnv_wr32(dev, GPC_BCAST(0x0888) + (i * 4), 0x00000000);\r\nnv_wr32(dev, GPC_BCAST(0x08b4), priv->unk4188b4->vinst >> 8);\r\nnv_wr32(dev, GPC_BCAST(0x08b8), priv->unk4188b8->vinst >> 8);\r\n}\r\nstatic void\r\nnvc0_graph_init_regs(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, 0x400080, 0x003083c2);\r\nnv_wr32(dev, 0x400088, 0x00006fe7);\r\nnv_wr32(dev, 0x40008c, 0x00000000);\r\nnv_wr32(dev, 0x400090, 0x00000030);\r\nnv_wr32(dev, 0x40013c, 0x013901f7);\r\nnv_wr32(dev, 0x400140, 0x00000100);\r\nnv_wr32(dev, 0x400144, 0x00000000);\r\nnv_wr32(dev, 0x400148, 0x00000110);\r\nnv_wr32(dev, 0x400138, 0x00000000);\r\nnv_wr32(dev, 0x400130, 0x00000000);\r\nnv_wr32(dev, 0x400134, 0x00000000);\r\nnv_wr32(dev, 0x400124, 0x00000002);\r\n}\r\nstatic void\r\nnvc0_graph_init_gpc_0(struct drm_device *dev)\r\n{\r\nstruct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nconst u32 magicgpc918 = DIV_ROUND_UP(0x00800000, priv->tp_total);\r\nu32 data[TP_MAX / 8];\r\nu8 tpnr[GPC_MAX];\r\nint i, gpc, tpc;\r\nnv_wr32(dev, TP_UNIT(0, 0, 0x5c), 1);\r\nmemset(data, 0x00, sizeof(data));\r\nmemcpy(tpnr, priv->tp_nr, sizeof(priv->tp_nr));\r\nfor (i = 0, gpc = -1; i < priv->tp_total; i++) {\r\ndo {\r\ngpc = (gpc + 1) % priv->gpc_nr;\r\n} while (!tpnr[gpc]);\r\ntpc = priv->tp_nr[gpc] - tpnr[gpc]--;\r\ndata[i / 8] |= tpc << ((i % 8) * 4);\r\n}\r\nnv_wr32(dev, GPC_BCAST(0x0980), data[0]);\r\nnv_wr32(dev, GPC_BCAST(0x0984), data[1]);\r\nnv_wr32(dev, GPC_BCAST(0x0988), data[2]);\r\nnv_wr32(dev, GPC_BCAST(0x098c), data[3]);\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0914), priv->magic_not_rop_nr << 8 |\r\npriv->tp_nr[gpc]);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0910), 0x00040000 | priv->tp_total);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0918), magicgpc918);\r\n}\r\nnv_wr32(dev, GPC_BCAST(0x1bd4), magicgpc918);\r\nnv_wr32(dev, GPC_BCAST(0x08ac), nv_rd32(dev, 0x100800));\r\n}\r\nstatic void\r\nnvc0_graph_init_units(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, 0x409c24, 0x000f0000);\r\nnv_wr32(dev, 0x404000, 0xc0000000);\r\nnv_wr32(dev, 0x404600, 0xc0000000);\r\nnv_wr32(dev, 0x408030, 0xc0000000);\r\nnv_wr32(dev, 0x40601c, 0xc0000000);\r\nnv_wr32(dev, 0x404490, 0xc0000000);\r\nnv_wr32(dev, 0x406018, 0xc0000000);\r\nnv_wr32(dev, 0x405840, 0xc0000000);\r\nnv_wr32(dev, 0x405844, 0x00ffffff);\r\nnv_mask(dev, 0x419cc0, 0x00000008, 0x00000008);\r\nnv_mask(dev, 0x419eb4, 0x00001000, 0x00001000);\r\n}\r\nstatic void\r\nnvc0_graph_init_gpc_1(struct drm_device *dev)\r\n{\r\nstruct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nint gpc, tp;\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0420), 0xc0000000);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0900), 0xc0000000);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x1028), 0xc0000000);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0824), 0xc0000000);\r\nfor (tp = 0; tp < priv->tp_nr[gpc]; tp++) {\r\nnv_wr32(dev, TP_UNIT(gpc, tp, 0x508), 0xffffffff);\r\nnv_wr32(dev, TP_UNIT(gpc, tp, 0x50c), 0xffffffff);\r\nnv_wr32(dev, TP_UNIT(gpc, tp, 0x224), 0xc0000000);\r\nnv_wr32(dev, TP_UNIT(gpc, tp, 0x48c), 0xc0000000);\r\nnv_wr32(dev, TP_UNIT(gpc, tp, 0x084), 0xc0000000);\r\nnv_wr32(dev, TP_UNIT(gpc, tp, 0x644), 0x001ffffe);\r\nnv_wr32(dev, TP_UNIT(gpc, tp, 0x64c), 0x0000000f);\r\n}\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x2c90), 0xffffffff);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x2c94), 0xffffffff);\r\n}\r\n}\r\nstatic void\r\nnvc0_graph_init_rop(struct drm_device *dev)\r\n{\r\nstruct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nint rop;\r\nfor (rop = 0; rop < priv->rop_nr; rop++) {\r\nnv_wr32(dev, ROP_UNIT(rop, 0x144), 0xc0000000);\r\nnv_wr32(dev, ROP_UNIT(rop, 0x070), 0xc0000000);\r\nnv_wr32(dev, ROP_UNIT(rop, 0x204), 0xffffffff);\r\nnv_wr32(dev, ROP_UNIT(rop, 0x208), 0xffffffff);\r\n}\r\n}\r\nstatic void\r\nnvc0_graph_init_fuc(struct drm_device *dev, u32 fuc_base,\r\nstruct nvc0_graph_fuc *code, struct nvc0_graph_fuc *data)\r\n{\r\nint i;\r\nnv_wr32(dev, fuc_base + 0x01c0, 0x01000000);\r\nfor (i = 0; i < data->size / 4; i++)\r\nnv_wr32(dev, fuc_base + 0x01c4, data->data[i]);\r\nnv_wr32(dev, fuc_base + 0x0180, 0x01000000);\r\nfor (i = 0; i < code->size / 4; i++) {\r\nif ((i & 0x3f) == 0)\r\nnv_wr32(dev, fuc_base + 0x0188, i >> 6);\r\nnv_wr32(dev, fuc_base + 0x0184, code->data[i]);\r\n}\r\n}\r\nstatic int\r\nnvc0_graph_init_ctxctl(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nu32 r000260;\r\nint i;\r\nif (!nouveau_ctxfw) {\r\nr000260 = nv_mask(dev, 0x000260, 0x00000001, 0x00000000);\r\nnv_wr32(dev, 0x4091c0, 0x01000000);\r\nfor (i = 0; i < sizeof(nvc0_grhub_data) / 4; i++)\r\nnv_wr32(dev, 0x4091c4, nvc0_grhub_data[i]);\r\nnv_wr32(dev, 0x409180, 0x01000000);\r\nfor (i = 0; i < sizeof(nvc0_grhub_code) / 4; i++) {\r\nif ((i & 0x3f) == 0)\r\nnv_wr32(dev, 0x409188, i >> 6);\r\nnv_wr32(dev, 0x409184, nvc0_grhub_code[i]);\r\n}\r\nnv_wr32(dev, 0x41a1c0, 0x01000000);\r\nfor (i = 0; i < sizeof(nvc0_grgpc_data) / 4; i++)\r\nnv_wr32(dev, 0x41a1c4, nvc0_grgpc_data[i]);\r\nnv_wr32(dev, 0x41a180, 0x01000000);\r\nfor (i = 0; i < sizeof(nvc0_grgpc_code) / 4; i++) {\r\nif ((i & 0x3f) == 0)\r\nnv_wr32(dev, 0x41a188, i >> 6);\r\nnv_wr32(dev, 0x41a184, nvc0_grgpc_code[i]);\r\n}\r\nnv_wr32(dev, 0x000260, r000260);\r\nnv_wr32(dev, 0x409800, dev_priv->chipset);\r\nnv_wr32(dev, 0x40910c, 0x00000000);\r\nnv_wr32(dev, 0x409100, 0x00000002);\r\nif (!nv_wait(dev, 0x409800, 0x80000000, 0x80000000)) {\r\nNV_ERROR(dev, "PGRAPH: HUB_INIT timed out\n");\r\nnvc0_graph_ctxctl_debug(dev);\r\nreturn -EBUSY;\r\n}\r\npriv->grctx_size = nv_rd32(dev, 0x409804);\r\nreturn 0;\r\n}\r\nr000260 = nv_mask(dev, 0x000260, 0x00000001, 0x00000000);\r\nnvc0_graph_init_fuc(dev, 0x409000, &priv->fuc409c, &priv->fuc409d);\r\nnvc0_graph_init_fuc(dev, 0x41a000, &priv->fuc41ac, &priv->fuc41ad);\r\nnv_wr32(dev, 0x000260, r000260);\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x41a10c, 0x00000000);\r\nnv_wr32(dev, 0x40910c, 0x00000000);\r\nnv_wr32(dev, 0x41a100, 0x00000002);\r\nnv_wr32(dev, 0x409100, 0x00000002);\r\nif (!nv_wait(dev, 0x409800, 0x00000001, 0x00000001))\r\nNV_INFO(dev, "0x409800 wait failed\n");\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x409500, 0x7fffffff);\r\nnv_wr32(dev, 0x409504, 0x00000021);\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x409500, 0x00000000);\r\nnv_wr32(dev, 0x409504, 0x00000010);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x10 timeout\n");\r\nreturn -EBUSY;\r\n}\r\npriv->grctx_size = nv_rd32(dev, 0x409800);\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x409500, 0x00000000);\r\nnv_wr32(dev, 0x409504, 0x00000016);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x16 timeout\n");\r\nreturn -EBUSY;\r\n}\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x409500, 0x00000000);\r\nnv_wr32(dev, 0x409504, 0x00000025);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x25 timeout\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_graph_init(struct drm_device *dev, int engine)\r\n{\r\nint ret;\r\nnv_mask(dev, 0x000200, 0x18001000, 0x00000000);\r\nnv_mask(dev, 0x000200, 0x18001000, 0x18001000);\r\nnvc0_graph_init_obj418880(dev);\r\nnvc0_graph_init_regs(dev);\r\nnvc0_graph_init_gpc_0(dev);\r\nnv_wr32(dev, 0x400500, 0x00010001);\r\nnv_wr32(dev, 0x400100, 0xffffffff);\r\nnv_wr32(dev, 0x40013c, 0xffffffff);\r\nnvc0_graph_init_units(dev);\r\nnvc0_graph_init_gpc_1(dev);\r\nnvc0_graph_init_rop(dev);\r\nnv_wr32(dev, 0x400108, 0xffffffff);\r\nnv_wr32(dev, 0x400138, 0xffffffff);\r\nnv_wr32(dev, 0x400118, 0xffffffff);\r\nnv_wr32(dev, 0x400130, 0xffffffff);\r\nnv_wr32(dev, 0x40011c, 0xffffffff);\r\nnv_wr32(dev, 0x400134, 0xffffffff);\r\nnv_wr32(dev, 0x400054, 0x34ce3464);\r\nret = nvc0_graph_init_ctxctl(dev);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint\r\nnvc0_graph_isr_chid(struct drm_device *dev, u64 inst)\r\n{\r\nstruct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_channel *chan;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&dev_priv->channels.lock, flags);\r\nfor (i = 0; i < pfifo->channels; i++) {\r\nchan = dev_priv->channels.ptr[i];\r\nif (!chan || !chan->ramin)\r\ncontinue;\r\nif (inst == chan->ramin->vinst)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dev_priv->channels.lock, flags);\r\nreturn i;\r\n}\r\nstatic void\r\nnvc0_graph_ctxctl_isr(struct drm_device *dev)\r\n{\r\nu32 ustat = nv_rd32(dev, 0x409c18);\r\nif (ustat & 0x00000001)\r\nNV_INFO(dev, "PGRAPH: CTXCTRL ucode error\n");\r\nif (ustat & 0x00080000)\r\nNV_INFO(dev, "PGRAPH: CTXCTRL watchdog timeout\n");\r\nif (ustat & ~0x00080001)\r\nNV_INFO(dev, "PGRAPH: CTXCTRL 0x%08x\n", ustat);\r\nnvc0_graph_ctxctl_debug(dev);\r\nnv_wr32(dev, 0x409c20, ustat);\r\n}\r\nstatic void\r\nnvc0_graph_isr(struct drm_device *dev)\r\n{\r\nu64 inst = (u64)(nv_rd32(dev, 0x409b00) & 0x0fffffff) << 12;\r\nu32 chid = nvc0_graph_isr_chid(dev, inst);\r\nu32 stat = nv_rd32(dev, 0x400100);\r\nu32 addr = nv_rd32(dev, 0x400704);\r\nu32 mthd = (addr & 0x00003ffc);\r\nu32 subc = (addr & 0x00070000) >> 16;\r\nu32 data = nv_rd32(dev, 0x400708);\r\nu32 code = nv_rd32(dev, 0x400110);\r\nu32 class = nv_rd32(dev, 0x404200 + (subc * 4));\r\nif (stat & 0x00000010) {\r\nif (nouveau_gpuobj_mthd_call2(dev, chid, class, mthd, data)) {\r\nNV_INFO(dev, "PGRAPH: ILLEGAL_MTHD ch %d [0x%010llx] "\r\n"subc %d class 0x%04x mthd 0x%04x "\r\n"data 0x%08x\n",\r\nchid, inst, subc, class, mthd, data);\r\n}\r\nnv_wr32(dev, 0x400100, 0x00000010);\r\nstat &= ~0x00000010;\r\n}\r\nif (stat & 0x00000020) {\r\nNV_INFO(dev, "PGRAPH: ILLEGAL_CLASS ch %d [0x%010llx] subc %d "\r\n"class 0x%04x mthd 0x%04x data 0x%08x\n",\r\nchid, inst, subc, class, mthd, data);\r\nnv_wr32(dev, 0x400100, 0x00000020);\r\nstat &= ~0x00000020;\r\n}\r\nif (stat & 0x00100000) {\r\nNV_INFO(dev, "PGRAPH: DATA_ERROR [");\r\nnouveau_enum_print(nv50_data_error_names, code);\r\nprintk("] ch %d [0x%010llx] subc %d class 0x%04x "\r\n"mthd 0x%04x data 0x%08x\n",\r\nchid, inst, subc, class, mthd, data);\r\nnv_wr32(dev, 0x400100, 0x00100000);\r\nstat &= ~0x00100000;\r\n}\r\nif (stat & 0x00200000) {\r\nu32 trap = nv_rd32(dev, 0x400108);\r\nNV_INFO(dev, "PGRAPH: TRAP ch %d status 0x%08x\n", chid, trap);\r\nnv_wr32(dev, 0x400108, trap);\r\nnv_wr32(dev, 0x400100, 0x00200000);\r\nstat &= ~0x00200000;\r\n}\r\nif (stat & 0x00080000) {\r\nnvc0_graph_ctxctl_isr(dev);\r\nnv_wr32(dev, 0x400100, 0x00080000);\r\nstat &= ~0x00080000;\r\n}\r\nif (stat) {\r\nNV_INFO(dev, "PGRAPH: unknown stat 0x%08x\n", stat);\r\nnv_wr32(dev, 0x400100, stat);\r\n}\r\nnv_wr32(dev, 0x400500, 0x00010001);\r\n}\r\nstatic int\r\nnvc0_graph_create_fw(struct drm_device *dev, const char *fwname,\r\nstruct nvc0_graph_fuc *fuc)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nconst struct firmware *fw;\r\nchar f[32];\r\nint ret;\r\nsnprintf(f, sizeof(f), "nouveau/nv%02x_%s", dev_priv->chipset, fwname);\r\nret = request_firmware(&fw, f, &dev->pdev->dev);\r\nif (ret) {\r\nsnprintf(f, sizeof(f), "nouveau/%s", fwname);\r\nret = request_firmware(&fw, f, &dev->pdev->dev);\r\nif (ret) {\r\nNV_ERROR(dev, "failed to load %s\n", fwname);\r\nreturn ret;\r\n}\r\n}\r\nfuc->size = fw->size;\r\nfuc->data = kmemdup(fw->data, fuc->size, GFP_KERNEL);\r\nrelease_firmware(fw);\r\nreturn (fuc->data != NULL) ? 0 : -ENOMEM;\r\n}\r\nstatic void\r\nnvc0_graph_destroy_fw(struct nvc0_graph_fuc *fuc)\r\n{\r\nif (fuc->data) {\r\nkfree(fuc->data);\r\nfuc->data = NULL;\r\n}\r\n}\r\nstatic void\r\nnvc0_graph_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nvc0_graph_priv *priv = nv_engine(dev, engine);\r\nif (nouveau_ctxfw) {\r\nnvc0_graph_destroy_fw(&priv->fuc409c);\r\nnvc0_graph_destroy_fw(&priv->fuc409d);\r\nnvc0_graph_destroy_fw(&priv->fuc41ac);\r\nnvc0_graph_destroy_fw(&priv->fuc41ad);\r\n}\r\nnouveau_irq_unregister(dev, 12);\r\nnouveau_gpuobj_ref(NULL, &priv->unk4188b8);\r\nnouveau_gpuobj_ref(NULL, &priv->unk4188b4);\r\nif (priv->grctx_vals)\r\nkfree(priv->grctx_vals);\r\nNVOBJ_ENGINE_DEL(dev, GR);\r\nkfree(priv);\r\n}\r\nint\r\nnvc0_graph_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nvc0_graph_priv *priv;\r\nint ret, gpc, i;\r\nu32 fermi;\r\nfermi = nvc0_graph_class(dev);\r\nif (!fermi) {\r\nNV_ERROR(dev, "PGRAPH: unsupported chipset, please report!\n");\r\nreturn 0;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.destroy = nvc0_graph_destroy;\r\npriv->base.init = nvc0_graph_init;\r\npriv->base.fini = nvc0_graph_fini;\r\npriv->base.context_new = nvc0_graph_context_new;\r\npriv->base.context_del = nvc0_graph_context_del;\r\npriv->base.object_new = nvc0_graph_object_new;\r\nNVOBJ_ENGINE_ADD(dev, GR, &priv->base);\r\nnouveau_irq_register(dev, 12, nvc0_graph_isr);\r\nif (nouveau_ctxfw) {\r\nNV_INFO(dev, "PGRAPH: using external firmware\n");\r\nif (nvc0_graph_create_fw(dev, "fuc409c", &priv->fuc409c) ||\r\nnvc0_graph_create_fw(dev, "fuc409d", &priv->fuc409d) ||\r\nnvc0_graph_create_fw(dev, "fuc41ac", &priv->fuc41ac) ||\r\nnvc0_graph_create_fw(dev, "fuc41ad", &priv->fuc41ad)) {\r\nret = 0;\r\ngoto error;\r\n}\r\n}\r\nret = nouveau_gpuobj_new(dev, NULL, 0x1000, 256, 0, &priv->unk4188b4);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_gpuobj_new(dev, NULL, 0x1000, 256, 0, &priv->unk4188b8);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < 0x1000; i += 4) {\r\nnv_wo32(priv->unk4188b4, i, 0x00000010);\r\nnv_wo32(priv->unk4188b8, i, 0x00000010);\r\n}\r\npriv->gpc_nr = nv_rd32(dev, 0x409604) & 0x0000001f;\r\npriv->rop_nr = (nv_rd32(dev, 0x409604) & 0x001f0000) >> 16;\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\npriv->tp_nr[gpc] = nv_rd32(dev, GPC_UNIT(gpc, 0x2608));\r\npriv->tp_total += priv->tp_nr[gpc];\r\n}\r\nswitch (dev_priv->chipset) {\r\ncase 0xc0:\r\nif (priv->tp_total == 11) {\r\npriv->magic_not_rop_nr = 0x07;\r\n} else\r\nif (priv->tp_total == 14) {\r\npriv->magic_not_rop_nr = 0x05;\r\n} else\r\nif (priv->tp_total == 15) {\r\npriv->magic_not_rop_nr = 0x06;\r\n}\r\nbreak;\r\ncase 0xc3:\r\npriv->magic_not_rop_nr = 0x03;\r\nbreak;\r\ncase 0xc4:\r\npriv->magic_not_rop_nr = 0x01;\r\nbreak;\r\ncase 0xc1:\r\npriv->magic_not_rop_nr = 0x01;\r\nbreak;\r\ncase 0xc8:\r\npriv->magic_not_rop_nr = 0x06;\r\nbreak;\r\ncase 0xce:\r\npriv->magic_not_rop_nr = 0x03;\r\nbreak;\r\ncase 0xcf:\r\npriv->magic_not_rop_nr = 0x03;\r\nbreak;\r\ncase 0xd9:\r\npriv->magic_not_rop_nr = 0x01;\r\nbreak;\r\n}\r\nif (!priv->magic_not_rop_nr) {\r\nNV_ERROR(dev, "PGRAPH: unknown config: %d/%d/%d/%d, %d\n",\r\npriv->tp_nr[0], priv->tp_nr[1], priv->tp_nr[2],\r\npriv->tp_nr[3], priv->rop_nr);\r\npriv->magic_not_rop_nr = 0x00;\r\n}\r\nNVOBJ_CLASS(dev, 0x902d, GR);\r\nNVOBJ_CLASS(dev, 0x9039, GR);\r\nNVOBJ_CLASS(dev, 0x9097, GR);\r\nif (fermi >= 0x9197)\r\nNVOBJ_CLASS(dev, 0x9197, GR);\r\nif (fermi >= 0x9297)\r\nNVOBJ_CLASS(dev, 0x9297, GR);\r\nNVOBJ_CLASS(dev, 0x90c0, GR);\r\nreturn 0;\r\nerror:\r\nnvc0_graph_destroy(dev, NVOBJ_ENGINE_GR);\r\nreturn ret;\r\n}
