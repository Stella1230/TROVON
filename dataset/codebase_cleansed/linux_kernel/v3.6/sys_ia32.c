asmlinkage long sys32_truncate64(const char __user *filename,\r\nunsigned long offset_low,\r\nunsigned long offset_high)\r\n{\r\nreturn sys_truncate(filename, ((loff_t) offset_high << 32) | offset_low);\r\n}\r\nasmlinkage long sys32_ftruncate64(unsigned int fd, unsigned long offset_low,\r\nunsigned long offset_high)\r\n{\r\nreturn sys_ftruncate(fd, ((loff_t) offset_high << 32) | offset_low);\r\n}\r\nstatic int cp_stat64(struct stat64 __user *ubuf, struct kstat *stat)\r\n{\r\ntypeof(ubuf->st_uid) uid = 0;\r\ntypeof(ubuf->st_gid) gid = 0;\r\nSET_UID(uid, from_kuid_munged(current_user_ns(), stat->uid));\r\nSET_GID(gid, from_kgid_munged(current_user_ns(), stat->gid));\r\nif (!access_ok(VERIFY_WRITE, ubuf, sizeof(struct stat64)) ||\r\n__put_user(huge_encode_dev(stat->dev), &ubuf->st_dev) ||\r\n__put_user(stat->ino, &ubuf->__st_ino) ||\r\n__put_user(stat->ino, &ubuf->st_ino) ||\r\n__put_user(stat->mode, &ubuf->st_mode) ||\r\n__put_user(stat->nlink, &ubuf->st_nlink) ||\r\n__put_user(uid, &ubuf->st_uid) ||\r\n__put_user(gid, &ubuf->st_gid) ||\r\n__put_user(huge_encode_dev(stat->rdev), &ubuf->st_rdev) ||\r\n__put_user(stat->size, &ubuf->st_size) ||\r\n__put_user(stat->atime.tv_sec, &ubuf->st_atime) ||\r\n__put_user(stat->atime.tv_nsec, &ubuf->st_atime_nsec) ||\r\n__put_user(stat->mtime.tv_sec, &ubuf->st_mtime) ||\r\n__put_user(stat->mtime.tv_nsec, &ubuf->st_mtime_nsec) ||\r\n__put_user(stat->ctime.tv_sec, &ubuf->st_ctime) ||\r\n__put_user(stat->ctime.tv_nsec, &ubuf->st_ctime_nsec) ||\r\n__put_user(stat->blksize, &ubuf->st_blksize) ||\r\n__put_user(stat->blocks, &ubuf->st_blocks))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nasmlinkage long sys32_stat64(const char __user *filename,\r\nstruct stat64 __user *statbuf)\r\n{\r\nstruct kstat stat;\r\nint ret = vfs_stat(filename, &stat);\r\nif (!ret)\r\nret = cp_stat64(statbuf, &stat);\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_lstat64(const char __user *filename,\r\nstruct stat64 __user *statbuf)\r\n{\r\nstruct kstat stat;\r\nint ret = vfs_lstat(filename, &stat);\r\nif (!ret)\r\nret = cp_stat64(statbuf, &stat);\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_fstat64(unsigned int fd, struct stat64 __user *statbuf)\r\n{\r\nstruct kstat stat;\r\nint ret = vfs_fstat(fd, &stat);\r\nif (!ret)\r\nret = cp_stat64(statbuf, &stat);\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_fstatat(unsigned int dfd, const char __user *filename,\r\nstruct stat64 __user *statbuf, int flag)\r\n{\r\nstruct kstat stat;\r\nint error;\r\nerror = vfs_fstatat(dfd, filename, &stat, flag);\r\nif (error)\r\nreturn error;\r\nreturn cp_stat64(statbuf, &stat);\r\n}\r\nasmlinkage long sys32_mmap(struct mmap_arg_struct32 __user *arg)\r\n{\r\nstruct mmap_arg_struct32 a;\r\nif (copy_from_user(&a, arg, sizeof(a)))\r\nreturn -EFAULT;\r\nif (a.offset & ~PAGE_MASK)\r\nreturn -EINVAL;\r\nreturn sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\r\na.offset>>PAGE_SHIFT);\r\n}\r\nasmlinkage long sys32_mprotect(unsigned long start, size_t len,\r\nunsigned long prot)\r\n{\r\nreturn sys_mprotect(start, len, prot);\r\n}\r\nasmlinkage long sys32_rt_sigaction(int sig, struct sigaction32 __user *act,\r\nstruct sigaction32 __user *oact,\r\nunsigned int sigsetsize)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\ncompat_sigset_t set32;\r\nif (sigsetsize != sizeof(compat_sigset_t))\r\nreturn -EINVAL;\r\nif (act) {\r\ncompat_uptr_t handler, restorer;\r\nif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\r\n__get_user(handler, &act->sa_handler) ||\r\n__get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\r\n__get_user(restorer, &act->sa_restorer) ||\r\n__copy_from_user(&set32, &act->sa_mask,\r\nsizeof(compat_sigset_t)))\r\nreturn -EFAULT;\r\nnew_ka.sa.sa_handler = compat_ptr(handler);\r\nnew_ka.sa.sa_restorer = compat_ptr(restorer);\r\nswitch (_NSIG_WORDS) {\r\ncase 4: new_ka.sa.sa_mask.sig[3] = set32.sig[6]\r\n| (((long)set32.sig[7]) << 32);\r\ncase 3: new_ka.sa.sa_mask.sig[2] = set32.sig[4]\r\n| (((long)set32.sig[5]) << 32);\r\ncase 2: new_ka.sa.sa_mask.sig[1] = set32.sig[2]\r\n| (((long)set32.sig[3]) << 32);\r\ncase 1: new_ka.sa.sa_mask.sig[0] = set32.sig[0]\r\n| (((long)set32.sig[1]) << 32);\r\n}\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nswitch (_NSIG_WORDS) {\r\ncase 4:\r\nset32.sig[7] = (old_ka.sa.sa_mask.sig[3] >> 32);\r\nset32.sig[6] = old_ka.sa.sa_mask.sig[3];\r\ncase 3:\r\nset32.sig[5] = (old_ka.sa.sa_mask.sig[2] >> 32);\r\nset32.sig[4] = old_ka.sa.sa_mask.sig[2];\r\ncase 2:\r\nset32.sig[3] = (old_ka.sa.sa_mask.sig[1] >> 32);\r\nset32.sig[2] = old_ka.sa.sa_mask.sig[1];\r\ncase 1:\r\nset32.sig[1] = (old_ka.sa.sa_mask.sig[0] >> 32);\r\nset32.sig[0] = old_ka.sa.sa_mask.sig[0];\r\n}\r\nif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\r\n__put_user(ptr_to_compat(old_ka.sa.sa_handler),\r\n&oact->sa_handler) ||\r\n__put_user(ptr_to_compat(old_ka.sa.sa_restorer),\r\n&oact->sa_restorer) ||\r\n__put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\r\n__copy_to_user(&oact->sa_mask, &set32,\r\nsizeof(compat_sigset_t)))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_sigaction(int sig, struct old_sigaction32 __user *act,\r\nstruct old_sigaction32 __user *oact)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\nif (act) {\r\ncompat_old_sigset_t mask;\r\ncompat_uptr_t handler, restorer;\r\nif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\r\n__get_user(handler, &act->sa_handler) ||\r\n__get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\r\n__get_user(restorer, &act->sa_restorer) ||\r\n__get_user(mask, &act->sa_mask))\r\nreturn -EFAULT;\r\nnew_ka.sa.sa_handler = compat_ptr(handler);\r\nnew_ka.sa.sa_restorer = compat_ptr(restorer);\r\nsiginitset(&new_ka.sa.sa_mask, mask);\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\r\n__put_user(ptr_to_compat(old_ka.sa.sa_handler),\r\n&oact->sa_handler) ||\r\n__put_user(ptr_to_compat(old_ka.sa.sa_restorer),\r\n&oact->sa_restorer) ||\r\n__put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\r\n__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_waitpid(compat_pid_t pid, unsigned int *stat_addr,\r\nint options)\r\n{\r\nreturn compat_sys_wait4(pid, stat_addr, options, NULL);\r\n}\r\nasmlinkage long sys32_sched_rr_get_interval(compat_pid_t pid,\r\nstruct compat_timespec __user *interval)\r\n{\r\nstruct timespec t;\r\nint ret;\r\nmm_segment_t old_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = sys_sched_rr_get_interval(pid, (struct timespec __user *)&t);\r\nset_fs(old_fs);\r\nif (put_compat_timespec(&t, interval))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_rt_sigpending(compat_sigset_t __user *set,\r\ncompat_size_t sigsetsize)\r\n{\r\nsigset_t s;\r\ncompat_sigset_t s32;\r\nint ret;\r\nmm_segment_t old_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = sys_rt_sigpending((sigset_t __user *)&s, sigsetsize);\r\nset_fs(old_fs);\r\nif (!ret) {\r\nswitch (_NSIG_WORDS) {\r\ncase 4: s32.sig[7] = (s.sig[3] >> 32); s32.sig[6] = s.sig[3];\r\ncase 3: s32.sig[5] = (s.sig[2] >> 32); s32.sig[4] = s.sig[2];\r\ncase 2: s32.sig[3] = (s.sig[1] >> 32); s32.sig[2] = s.sig[1];\r\ncase 1: s32.sig[1] = (s.sig[0] >> 32); s32.sig[0] = s.sig[0];\r\n}\r\nif (copy_to_user(set, &s32, sizeof(compat_sigset_t)))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_rt_sigqueueinfo(int pid, int sig,\r\ncompat_siginfo_t __user *uinfo)\r\n{\r\nsiginfo_t info;\r\nint ret;\r\nmm_segment_t old_fs = get_fs();\r\nif (copy_siginfo_from_user32(&info, uinfo))\r\nreturn -EFAULT;\r\nset_fs(KERNEL_DS);\r\nret = sys_rt_sigqueueinfo(pid, sig, (siginfo_t __user *)&info);\r\nset_fs(old_fs);\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_pread(unsigned int fd, char __user *ubuf, u32 count,\r\nu32 poslo, u32 poshi)\r\n{\r\nreturn sys_pread64(fd, ubuf, count,\r\n((loff_t)AA(poshi) << 32) | AA(poslo));\r\n}\r\nasmlinkage long sys32_pwrite(unsigned int fd, const char __user *ubuf,\r\nu32 count, u32 poslo, u32 poshi)\r\n{\r\nreturn sys_pwrite64(fd, ubuf, count,\r\n((loff_t)AA(poshi) << 32) | AA(poslo));\r\n}\r\nasmlinkage long sys32_sendfile(int out_fd, int in_fd,\r\ncompat_off_t __user *offset, s32 count)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nint ret;\r\noff_t of;\r\nif (offset && get_user(of, offset))\r\nreturn -EFAULT;\r\nset_fs(KERNEL_DS);\r\nret = sys_sendfile(out_fd, in_fd, offset ? (off_t __user *)&of : NULL,\r\ncount);\r\nset_fs(old_fs);\r\nif (offset && put_user(of, offset))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nasmlinkage long sys32_execve(const char __user *name, compat_uptr_t __user *argv,\r\ncompat_uptr_t __user *envp, struct pt_regs *regs)\r\n{\r\nlong error;\r\nchar *filename;\r\nfilename = getname(name);\r\nerror = PTR_ERR(filename);\r\nif (IS_ERR(filename))\r\nreturn error;\r\nerror = compat_do_execve(filename, argv, envp, regs);\r\nputname(filename);\r\nreturn error;\r\n}\r\nasmlinkage long sys32_clone(unsigned int clone_flags, unsigned int newsp,\r\nstruct pt_regs *regs)\r\n{\r\nvoid __user *parent_tid = (void __user *)regs->dx;\r\nvoid __user *child_tid = (void __user *)regs->di;\r\nif (!newsp)\r\nnewsp = regs->sp;\r\nreturn do_fork(clone_flags, newsp, regs, 0, parent_tid, child_tid);\r\n}\r\nlong sys32_lseek(unsigned int fd, int offset, unsigned int whence)\r\n{\r\nreturn sys_lseek(fd, offset, whence);\r\n}\r\nlong sys32_kill(int pid, int sig)\r\n{\r\nreturn sys_kill(pid, sig);\r\n}\r\nlong sys32_fadvise64_64(int fd, __u32 offset_low, __u32 offset_high,\r\n__u32 len_low, __u32 len_high, int advice)\r\n{\r\nreturn sys_fadvise64_64(fd,\r\n(((u64)offset_high)<<32) | offset_low,\r\n(((u64)len_high)<<32) | len_low,\r\nadvice);\r\n}\r\nlong sys32_vm86_warning(void)\r\n{\r\nstruct task_struct *me = current;\r\nstatic char lastcomm[sizeof(me->comm)];\r\nif (strncmp(lastcomm, me->comm, sizeof(lastcomm))) {\r\ncompat_printk(KERN_INFO\r\n"%s: vm86 mode not supported on 64 bit kernel\n",\r\nme->comm);\r\nstrncpy(lastcomm, me->comm, sizeof(lastcomm));\r\n}\r\nreturn -ENOSYS;\r\n}\r\nlong sys32_lookup_dcookie(u32 addr_low, u32 addr_high,\r\nchar __user *buf, size_t len)\r\n{\r\nreturn sys_lookup_dcookie(((u64)addr_high << 32) | addr_low, buf, len);\r\n}\r\nasmlinkage ssize_t sys32_readahead(int fd, unsigned off_lo, unsigned off_hi,\r\nsize_t count)\r\n{\r\nreturn sys_readahead(fd, ((u64)off_hi << 32) | off_lo, count);\r\n}\r\nasmlinkage long sys32_sync_file_range(int fd, unsigned off_low, unsigned off_hi,\r\nunsigned n_low, unsigned n_hi, int flags)\r\n{\r\nreturn sys_sync_file_range(fd,\r\n((u64)off_hi << 32) | off_low,\r\n((u64)n_hi << 32) | n_low, flags);\r\n}\r\nasmlinkage long sys32_fadvise64(int fd, unsigned offset_lo, unsigned offset_hi,\r\nsize_t len, int advice)\r\n{\r\nreturn sys_fadvise64_64(fd, ((u64)offset_hi << 32) | offset_lo,\r\nlen, advice);\r\n}\r\nasmlinkage long sys32_fallocate(int fd, int mode, unsigned offset_lo,\r\nunsigned offset_hi, unsigned len_lo,\r\nunsigned len_hi)\r\n{\r\nreturn sys_fallocate(fd, mode, ((u64)offset_hi << 32) | offset_lo,\r\n((u64)len_hi << 32) | len_lo);\r\n}\r\nasmlinkage long sys32_fanotify_mark(int fanotify_fd, unsigned int flags,\r\nu32 mask_lo, u32 mask_hi,\r\nint fd, const char __user *pathname)\r\n{\r\nreturn sys_fanotify_mark(fanotify_fd, flags,\r\n((u64)mask_hi << 32) | mask_lo,\r\nfd, pathname);\r\n}
