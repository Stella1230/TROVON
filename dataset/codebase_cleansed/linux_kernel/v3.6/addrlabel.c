static inline\r\nstruct net *ip6addrlbl_net(const struct ip6addrlbl_entry *lbl)\r\n{\r\nreturn read_pnet(&lbl->lbl_net);\r\n}\r\nstatic inline void ip6addrlbl_free(struct ip6addrlbl_entry *p)\r\n{\r\n#ifdef CONFIG_NET_NS\r\nrelease_net(p->lbl_net);\r\n#endif\r\nkfree(p);\r\n}\r\nstatic void ip6addrlbl_free_rcu(struct rcu_head *h)\r\n{\r\nip6addrlbl_free(container_of(h, struct ip6addrlbl_entry, rcu));\r\n}\r\nstatic bool ip6addrlbl_hold(struct ip6addrlbl_entry *p)\r\n{\r\nreturn atomic_inc_not_zero(&p->refcnt);\r\n}\r\nstatic inline void ip6addrlbl_put(struct ip6addrlbl_entry *p)\r\n{\r\nif (atomic_dec_and_test(&p->refcnt))\r\ncall_rcu(&p->rcu, ip6addrlbl_free_rcu);\r\n}\r\nstatic bool __ip6addrlbl_match(struct net *net,\r\nconst struct ip6addrlbl_entry *p,\r\nconst struct in6_addr *addr,\r\nint addrtype, int ifindex)\r\n{\r\nif (!net_eq(ip6addrlbl_net(p), net))\r\nreturn false;\r\nif (p->ifindex && p->ifindex != ifindex)\r\nreturn false;\r\nif (p->addrtype && p->addrtype != addrtype)\r\nreturn false;\r\nif (!ipv6_prefix_equal(addr, &p->prefix, p->prefixlen))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct ip6addrlbl_entry *__ipv6_addr_label(struct net *net,\r\nconst struct in6_addr *addr,\r\nint type, int ifindex)\r\n{\r\nstruct hlist_node *pos;\r\nstruct ip6addrlbl_entry *p;\r\nhlist_for_each_entry_rcu(p, pos, &ip6addrlbl_table.head, list) {\r\nif (__ip6addrlbl_match(net, p, addr, type, ifindex))\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nu32 ipv6_addr_label(struct net *net,\r\nconst struct in6_addr *addr, int type, int ifindex)\r\n{\r\nu32 label;\r\nstruct ip6addrlbl_entry *p;\r\ntype &= IPV6_ADDR_MAPPED | IPV6_ADDR_COMPATv4 | IPV6_ADDR_LOOPBACK;\r\nrcu_read_lock();\r\np = __ipv6_addr_label(net, addr, type, ifindex);\r\nlabel = p ? p->label : IPV6_ADDR_LABEL_DEFAULT;\r\nrcu_read_unlock();\r\nADDRLABEL(KERN_DEBUG "%s(addr=%pI6, type=%d, ifindex=%d) => %08x\n",\r\n__func__, addr, type, ifindex, label);\r\nreturn label;\r\n}\r\nstatic struct ip6addrlbl_entry *ip6addrlbl_alloc(struct net *net,\r\nconst struct in6_addr *prefix,\r\nint prefixlen, int ifindex,\r\nu32 label)\r\n{\r\nstruct ip6addrlbl_entry *newp;\r\nint addrtype;\r\nADDRLABEL(KERN_DEBUG "%s(prefix=%pI6, prefixlen=%d, ifindex=%d, label=%u)\n",\r\n__func__, prefix, prefixlen, ifindex, (unsigned int)label);\r\naddrtype = ipv6_addr_type(prefix) & (IPV6_ADDR_MAPPED | IPV6_ADDR_COMPATv4 | IPV6_ADDR_LOOPBACK);\r\nswitch (addrtype) {\r\ncase IPV6_ADDR_MAPPED:\r\nif (prefixlen > 96)\r\nreturn ERR_PTR(-EINVAL);\r\nif (prefixlen < 96)\r\naddrtype = 0;\r\nbreak;\r\ncase IPV6_ADDR_COMPATv4:\r\nif (prefixlen != 96)\r\naddrtype = 0;\r\nbreak;\r\ncase IPV6_ADDR_LOOPBACK:\r\nif (prefixlen != 128)\r\naddrtype = 0;\r\nbreak;\r\n}\r\nnewp = kmalloc(sizeof(*newp), GFP_KERNEL);\r\nif (!newp)\r\nreturn ERR_PTR(-ENOMEM);\r\nipv6_addr_prefix(&newp->prefix, prefix, prefixlen);\r\nnewp->prefixlen = prefixlen;\r\nnewp->ifindex = ifindex;\r\nnewp->addrtype = addrtype;\r\nnewp->label = label;\r\nINIT_HLIST_NODE(&newp->list);\r\n#ifdef CONFIG_NET_NS\r\nnewp->lbl_net = hold_net(net);\r\n#endif\r\natomic_set(&newp->refcnt, 1);\r\nreturn newp;\r\n}\r\nstatic int __ip6addrlbl_add(struct ip6addrlbl_entry *newp, int replace)\r\n{\r\nint ret = 0;\r\nADDRLABEL(KERN_DEBUG "%s(newp=%p, replace=%d)\n",\r\n__func__,\r\nnewp, replace);\r\nif (hlist_empty(&ip6addrlbl_table.head)) {\r\nhlist_add_head_rcu(&newp->list, &ip6addrlbl_table.head);\r\n} else {\r\nstruct hlist_node *pos, *n;\r\nstruct ip6addrlbl_entry *p = NULL;\r\nhlist_for_each_entry_safe(p, pos, n,\r\n&ip6addrlbl_table.head, list) {\r\nif (p->prefixlen == newp->prefixlen &&\r\nnet_eq(ip6addrlbl_net(p), ip6addrlbl_net(newp)) &&\r\np->ifindex == newp->ifindex &&\r\nipv6_addr_equal(&p->prefix, &newp->prefix)) {\r\nif (!replace) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nhlist_replace_rcu(&p->list, &newp->list);\r\nip6addrlbl_put(p);\r\ngoto out;\r\n} else if ((p->prefixlen == newp->prefixlen && !p->ifindex) ||\r\n(p->prefixlen < newp->prefixlen)) {\r\nhlist_add_before_rcu(&newp->list, &p->list);\r\ngoto out;\r\n}\r\n}\r\nhlist_add_after_rcu(&p->list, &newp->list);\r\n}\r\nout:\r\nif (!ret)\r\nip6addrlbl_table.seq++;\r\nreturn ret;\r\n}\r\nstatic int ip6addrlbl_add(struct net *net,\r\nconst struct in6_addr *prefix, int prefixlen,\r\nint ifindex, u32 label, int replace)\r\n{\r\nstruct ip6addrlbl_entry *newp;\r\nint ret = 0;\r\nADDRLABEL(KERN_DEBUG "%s(prefix=%pI6, prefixlen=%d, ifindex=%d, label=%u, replace=%d)\n",\r\n__func__, prefix, prefixlen, ifindex, (unsigned int)label,\r\nreplace);\r\nnewp = ip6addrlbl_alloc(net, prefix, prefixlen, ifindex, label);\r\nif (IS_ERR(newp))\r\nreturn PTR_ERR(newp);\r\nspin_lock(&ip6addrlbl_table.lock);\r\nret = __ip6addrlbl_add(newp, replace);\r\nspin_unlock(&ip6addrlbl_table.lock);\r\nif (ret)\r\nip6addrlbl_free(newp);\r\nreturn ret;\r\n}\r\nstatic int __ip6addrlbl_del(struct net *net,\r\nconst struct in6_addr *prefix, int prefixlen,\r\nint ifindex)\r\n{\r\nstruct ip6addrlbl_entry *p = NULL;\r\nstruct hlist_node *pos, *n;\r\nint ret = -ESRCH;\r\nADDRLABEL(KERN_DEBUG "%s(prefix=%pI6, prefixlen=%d, ifindex=%d)\n",\r\n__func__, prefix, prefixlen, ifindex);\r\nhlist_for_each_entry_safe(p, pos, n, &ip6addrlbl_table.head, list) {\r\nif (p->prefixlen == prefixlen &&\r\nnet_eq(ip6addrlbl_net(p), net) &&\r\np->ifindex == ifindex &&\r\nipv6_addr_equal(&p->prefix, prefix)) {\r\nhlist_del_rcu(&p->list);\r\nip6addrlbl_put(p);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ip6addrlbl_del(struct net *net,\r\nconst struct in6_addr *prefix, int prefixlen,\r\nint ifindex)\r\n{\r\nstruct in6_addr prefix_buf;\r\nint ret;\r\nADDRLABEL(KERN_DEBUG "%s(prefix=%pI6, prefixlen=%d, ifindex=%d)\n",\r\n__func__, prefix, prefixlen, ifindex);\r\nipv6_addr_prefix(&prefix_buf, prefix, prefixlen);\r\nspin_lock(&ip6addrlbl_table.lock);\r\nret = __ip6addrlbl_del(net, &prefix_buf, prefixlen, ifindex);\r\nspin_unlock(&ip6addrlbl_table.lock);\r\nreturn ret;\r\n}\r\nstatic int __net_init ip6addrlbl_net_init(struct net *net)\r\n{\r\nint err = 0;\r\nint i;\r\nADDRLABEL(KERN_DEBUG "%s\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(ip6addrlbl_init_table); i++) {\r\nint ret = ip6addrlbl_add(net,\r\nip6addrlbl_init_table[i].prefix,\r\nip6addrlbl_init_table[i].prefixlen,\r\n0,\r\nip6addrlbl_init_table[i].label, 0);\r\nif (ret && (!err || err != -ENOMEM))\r\nerr = ret;\r\n}\r\nreturn err;\r\n}\r\nstatic void __net_exit ip6addrlbl_net_exit(struct net *net)\r\n{\r\nstruct ip6addrlbl_entry *p = NULL;\r\nstruct hlist_node *pos, *n;\r\nspin_lock(&ip6addrlbl_table.lock);\r\nhlist_for_each_entry_safe(p, pos, n, &ip6addrlbl_table.head, list) {\r\nif (net_eq(ip6addrlbl_net(p), net)) {\r\nhlist_del_rcu(&p->list);\r\nip6addrlbl_put(p);\r\n}\r\n}\r\nspin_unlock(&ip6addrlbl_table.lock);\r\n}\r\nint __init ipv6_addr_label_init(void)\r\n{\r\nspin_lock_init(&ip6addrlbl_table.lock);\r\nreturn register_pernet_subsys(&ipv6_addr_label_ops);\r\n}\r\nvoid ipv6_addr_label_cleanup(void)\r\n{\r\nunregister_pernet_subsys(&ipv6_addr_label_ops);\r\n}\r\nstatic int ip6addrlbl_newdel(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nvoid *arg)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct ifaddrlblmsg *ifal;\r\nstruct nlattr *tb[IFAL_MAX+1];\r\nstruct in6_addr *pfx;\r\nu32 label;\r\nint err = 0;\r\nerr = nlmsg_parse(nlh, sizeof(*ifal), tb, IFAL_MAX, ifal_policy);\r\nif (err < 0)\r\nreturn err;\r\nifal = nlmsg_data(nlh);\r\nif (ifal->ifal_family != AF_INET6 ||\r\nifal->ifal_prefixlen > 128)\r\nreturn -EINVAL;\r\nif (!tb[IFAL_ADDRESS])\r\nreturn -EINVAL;\r\npfx = nla_data(tb[IFAL_ADDRESS]);\r\nif (!pfx)\r\nreturn -EINVAL;\r\nif (!tb[IFAL_LABEL])\r\nreturn -EINVAL;\r\nlabel = nla_get_u32(tb[IFAL_LABEL]);\r\nif (label == IPV6_ADDR_LABEL_DEFAULT)\r\nreturn -EINVAL;\r\nswitch(nlh->nlmsg_type) {\r\ncase RTM_NEWADDRLABEL:\r\nif (ifal->ifal_index &&\r\n!__dev_get_by_index(net, ifal->ifal_index))\r\nreturn -EINVAL;\r\nerr = ip6addrlbl_add(net, pfx, ifal->ifal_prefixlen,\r\nifal->ifal_index, label,\r\nnlh->nlmsg_flags & NLM_F_REPLACE);\r\nbreak;\r\ncase RTM_DELADDRLABEL:\r\nerr = ip6addrlbl_del(net, pfx, ifal->ifal_prefixlen,\r\nifal->ifal_index);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\n}\r\nreturn err;\r\n}\r\nstatic void ip6addrlbl_putmsg(struct nlmsghdr *nlh,\r\nint prefixlen, int ifindex, u32 lseq)\r\n{\r\nstruct ifaddrlblmsg *ifal = nlmsg_data(nlh);\r\nifal->ifal_family = AF_INET6;\r\nifal->ifal_prefixlen = prefixlen;\r\nifal->ifal_flags = 0;\r\nifal->ifal_index = ifindex;\r\nifal->ifal_seq = lseq;\r\n}\r\nstatic int ip6addrlbl_fill(struct sk_buff *skb,\r\nstruct ip6addrlbl_entry *p,\r\nu32 lseq,\r\nu32 pid, u32 seq, int event,\r\nunsigned int flags)\r\n{\r\nstruct nlmsghdr *nlh = nlmsg_put(skb, pid, seq, event,\r\nsizeof(struct ifaddrlblmsg), flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nip6addrlbl_putmsg(nlh, p->prefixlen, p->ifindex, lseq);\r\nif (nla_put(skb, IFAL_ADDRESS, 16, &p->prefix) < 0 ||\r\nnla_put_u32(skb, IFAL_LABEL, p->label) < 0) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int ip6addrlbl_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct ip6addrlbl_entry *p;\r\nstruct hlist_node *pos;\r\nint idx = 0, s_idx = cb->args[0];\r\nint err;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(p, pos, &ip6addrlbl_table.head, list) {\r\nif (idx >= s_idx &&\r\nnet_eq(ip6addrlbl_net(p), net)) {\r\nif ((err = ip6addrlbl_fill(skb, p,\r\nip6addrlbl_table.seq,\r\nNETLINK_CB(cb->skb).pid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWADDRLABEL,\r\nNLM_F_MULTI)) <= 0)\r\nbreak;\r\n}\r\nidx++;\r\n}\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic inline int ip6addrlbl_msgsize(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ifaddrlblmsg))\r\n+ nla_total_size(16)\r\n+ nla_total_size(4);\r\n}\r\nstatic int ip6addrlbl_get(struct sk_buff *in_skb, struct nlmsghdr* nlh,\r\nvoid *arg)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct ifaddrlblmsg *ifal;\r\nstruct nlattr *tb[IFAL_MAX+1];\r\nstruct in6_addr *addr;\r\nu32 lseq;\r\nint err = 0;\r\nstruct ip6addrlbl_entry *p;\r\nstruct sk_buff *skb;\r\nerr = nlmsg_parse(nlh, sizeof(*ifal), tb, IFAL_MAX, ifal_policy);\r\nif (err < 0)\r\nreturn err;\r\nifal = nlmsg_data(nlh);\r\nif (ifal->ifal_family != AF_INET6 ||\r\nifal->ifal_prefixlen != 128)\r\nreturn -EINVAL;\r\nif (ifal->ifal_index &&\r\n!__dev_get_by_index(net, ifal->ifal_index))\r\nreturn -EINVAL;\r\nif (!tb[IFAL_ADDRESS])\r\nreturn -EINVAL;\r\naddr = nla_data(tb[IFAL_ADDRESS]);\r\nif (!addr)\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\np = __ipv6_addr_label(net, addr, ipv6_addr_type(addr), ifal->ifal_index);\r\nif (p && ip6addrlbl_hold(p))\r\np = NULL;\r\nlseq = ip6addrlbl_table.seq;\r\nrcu_read_unlock();\r\nif (!p) {\r\nerr = -ESRCH;\r\ngoto out;\r\n}\r\nif (!(skb = nlmsg_new(ip6addrlbl_msgsize(), GFP_KERNEL))) {\r\nip6addrlbl_put(p);\r\nreturn -ENOBUFS;\r\n}\r\nerr = ip6addrlbl_fill(skb, p, lseq,\r\nNETLINK_CB(in_skb).pid, nlh->nlmsg_seq,\r\nRTM_NEWADDRLABEL, 0);\r\nip6addrlbl_put(p);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nerr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).pid);\r\nout:\r\nreturn err;\r\n}\r\nvoid __init ipv6_addr_label_rtnl_register(void)\r\n{\r\n__rtnl_register(PF_INET6, RTM_NEWADDRLABEL, ip6addrlbl_newdel,\r\nNULL, NULL);\r\n__rtnl_register(PF_INET6, RTM_DELADDRLABEL, ip6addrlbl_newdel,\r\nNULL, NULL);\r\n__rtnl_register(PF_INET6, RTM_GETADDRLABEL, ip6addrlbl_get,\r\nip6addrlbl_dump, NULL);\r\n}
