static void cpu_max_all_fans(void)\r\n{\r\nint i;\r\nif (cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nfor (i = 0; i < nr_chips; i++) {\r\nif (cpu_front_fans[i])\r\nwf_control_set_max(cpu_front_fans[i]);\r\nif (cpu_rear_fans[i])\r\nwf_control_set_max(cpu_rear_fans[i]);\r\nif (cpu_pumps[i])\r\nwf_control_set_max(cpu_pumps[i]);\r\n}\r\n}\r\nstatic int cpu_check_overtemp(s32 temp)\r\n{\r\nint new_state = 0;\r\ns32 t_avg, t_old;\r\nstatic bool first = true;\r\nif (temp >= (cpu_all_tmax + LOW_OVER_IMMEDIATE)) {\r\nnew_state |= FAILURE_LOW_OVERTEMP;\r\nif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Overtemp due to immediate CPU"\r\n" temperature !\n");\r\n}\r\nif (temp >= (cpu_all_tmax + HIGH_OVER_IMMEDIATE)) {\r\nnew_state |= FAILURE_HIGH_OVERTEMP;\r\nif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Critical overtemp due to"\r\n" immediate CPU temperature !\n");\r\n}\r\nif (first) {\r\nint i;\r\ncpu_thist_total = 0;\r\nfor (i = 0; i < CPU_TEMP_HIST_SIZE; i++) {\r\ncpu_thist[i] = temp;\r\ncpu_thist_total += temp;\r\n}\r\nfirst = false;\r\n}\r\nt_old = cpu_thist[cpu_thist_pt];\r\ncpu_thist[cpu_thist_pt] = temp;\r\ncpu_thist_pt = (cpu_thist_pt + 1) % CPU_TEMP_HIST_SIZE;\r\ncpu_thist_total -= t_old;\r\ncpu_thist_total += temp;\r\nt_avg = cpu_thist_total / CPU_TEMP_HIST_SIZE;\r\nDBG_LOTS(" t_avg = %d.%03d (out: %d.%03d, in: %d.%03d)\n",\r\nFIX32TOPRINT(t_avg), FIX32TOPRINT(t_old), FIX32TOPRINT(temp));\r\nif (t_avg >= (cpu_all_tmax + LOW_OVER_AVERAGE)) {\r\nnew_state |= FAILURE_LOW_OVERTEMP;\r\nif ((failure_state & FAILURE_LOW_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Overtemp due to average CPU"\r\n" temperature !\n");\r\n}\r\nif (t_avg >= (cpu_all_tmax + HIGH_OVER_AVERAGE)) {\r\nnew_state |= FAILURE_HIGH_OVERTEMP;\r\nif ((failure_state & FAILURE_HIGH_OVERTEMP) == 0)\r\nprintk(KERN_ERR "windfarm: Critical overtemp due to"\r\n" average CPU temperature !\n");\r\n}\r\nif (new_state) {\r\nif (new_state & FAILURE_HIGH_OVERTEMP)\r\nmachine_power_off();\r\nif ((failure_state & new_state) != new_state)\r\ncpu_max_all_fans();\r\nfailure_state |= new_state;\r\n} else if ((failure_state & FAILURE_LOW_OVERTEMP) &&\r\n(temp < (cpu_all_tmax + LOW_OVER_CLEAR))) {\r\nprintk(KERN_ERR "windfarm: Overtemp condition cleared !\n");\r\nfailure_state &= ~FAILURE_LOW_OVERTEMP;\r\n}\r\nreturn failure_state & (FAILURE_LOW_OVERTEMP | FAILURE_HIGH_OVERTEMP);\r\n}\r\nstatic int read_one_cpu_vals(int cpu, s32 *temp, s32 *power)\r\n{\r\ns32 dtemp, volts, amps;\r\nint rc;\r\nrc = wf_sensor_get(sens_cpu_temp[cpu], &dtemp);\r\nif (rc) {\r\nDBG(" CPU%d: temp reading error !\n", cpu);\r\nreturn -EIO;\r\n}\r\nDBG_LOTS(" CPU%d: temp = %d.%03d\n", cpu, FIX32TOPRINT((dtemp)));\r\n*temp = dtemp;\r\nrc = wf_sensor_get(sens_cpu_volts[cpu], &volts);\r\nif (rc) {\r\nDBG(" CPU%d, volts reading error !\n", cpu);\r\nreturn -EIO;\r\n}\r\nDBG_LOTS(" CPU%d: volts = %d.%03d\n", cpu, FIX32TOPRINT((volts)));\r\nrc = wf_sensor_get(sens_cpu_amps[cpu], &amps);\r\nif (rc) {\r\nDBG(" CPU%d, current reading error !\n", cpu);\r\nreturn -EIO;\r\n}\r\nDBG_LOTS(" CPU%d: amps = %d.%03d\n", cpu, FIX32TOPRINT((amps)));\r\n*power = (((u64)volts) * ((u64)amps)) >> 16;\r\nDBG_LOTS(" CPU%d: power = %d.%03d\n", cpu, FIX32TOPRINT((*power)));\r\nreturn 0;\r\n}\r\nstatic void cpu_fans_tick_split(void)\r\n{\r\nint err, cpu;\r\ns32 intake, temp, power, t_max = 0;\r\nDBG_LOTS("* cpu fans_tick_split()\n");\r\nfor (cpu = 0; cpu < nr_chips; ++cpu) {\r\nstruct wf_cpu_pid_state *sp = &cpu_pid[cpu];\r\nwf_control_get(cpu_rear_fans[cpu], &sp->target);\r\nDBG_LOTS(" CPU%d: cur_target = %d RPM\n", cpu, sp->target);\r\nerr = read_one_cpu_vals(cpu, &temp, &power);\r\nif (err) {\r\nfailure_state |= FAILURE_SENSOR;\r\ncpu_max_all_fans();\r\nreturn;\r\n}\r\nt_max = max(t_max, temp);\r\nif (cpu_check_overtemp(t_max))\r\nreturn;\r\nwf_cpu_pid_run(sp, power, temp);\r\nDBG_LOTS(" CPU%d: target = %d RPM\n", cpu, sp->target);\r\nerr = wf_control_set(cpu_rear_fans[cpu], sp->target);\r\nif (err) {\r\npr_warning("wf_pm72: Fan %s reports error %d\n",\r\ncpu_rear_fans[cpu]->name, err);\r\nfailure_state |= FAILURE_FAN;\r\nbreak;\r\n}\r\nintake = (sp->target * CPU_INTAKE_SCALE) >> 16;\r\nDBG_LOTS(" CPU%d: intake = %d RPM\n", cpu, intake);\r\nerr = wf_control_set(cpu_front_fans[cpu], intake);\r\nif (err) {\r\npr_warning("wf_pm72: Fan %s reports error %d\n",\r\ncpu_front_fans[cpu]->name, err);\r\nfailure_state |= FAILURE_FAN;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void cpu_fans_tick_combined(void)\r\n{\r\ns32 temp0, power0, temp1, power1, t_max = 0;\r\ns32 temp, power, intake, pump;\r\nstruct wf_control *pump0, *pump1;\r\nstruct wf_cpu_pid_state *sp = &cpu_pid[0];\r\nint err, cpu;\r\nDBG_LOTS("* cpu fans_tick_combined()\n");\r\nwf_control_get(cpu_rear_fans[0], &sp->target);\r\nDBG_LOTS(" CPUs: cur_target = %d RPM\n", sp->target);\r\nerr = read_one_cpu_vals(0, &temp0, &power0);\r\nif (err) {\r\nfailure_state |= FAILURE_SENSOR;\r\ncpu_max_all_fans();\r\nreturn;\r\n}\r\nerr = read_one_cpu_vals(1, &temp1, &power1);\r\nif (err) {\r\nfailure_state |= FAILURE_SENSOR;\r\ncpu_max_all_fans();\r\nreturn;\r\n}\r\nt_max = max(t_max, max(temp0, temp1));\r\nif (cpu_check_overtemp(t_max))\r\nreturn;\r\ntemp = max(temp0, temp1);\r\npower = max(power0, power1);\r\nwf_cpu_pid_run(sp, power, temp);\r\nintake = (sp->target * CPU_INTAKE_SCALE) >> 16;\r\npump0 = cpu_pumps[0];\r\npump1 = cpu_pumps[1];\r\nif (!pump0) {\r\npump0 = pump1;\r\npump1 = NULL;\r\n}\r\npump = (sp->target * wf_control_get_max(pump0)) /\r\ncpu_mpu_data[0]->rmaxn_exhaust_fan;\r\nDBG_LOTS(" CPUs: target = %d RPM\n", sp->target);\r\nDBG_LOTS(" CPUs: intake = %d RPM\n", intake);\r\nDBG_LOTS(" CPUs: pump = %d RPM\n", pump);\r\nfor (cpu = 0; cpu < nr_chips; cpu++) {\r\nerr = wf_control_set(cpu_rear_fans[cpu], sp->target);\r\nif (err) {\r\npr_warning("wf_pm72: Fan %s reports error %d\n",\r\ncpu_rear_fans[cpu]->name, err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\nerr = wf_control_set(cpu_front_fans[cpu], intake);\r\nif (err) {\r\npr_warning("wf_pm72: Fan %s reports error %d\n",\r\ncpu_front_fans[cpu]->name, err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\nerr = 0;\r\nif (cpu_pumps[cpu])\r\nerr = wf_control_set(cpu_pumps[cpu], pump);\r\nif (err) {\r\npr_warning("wf_pm72: Pump %s reports error %d\n",\r\ncpu_pumps[cpu]->name, err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\nstatic int cpu_setup_pid(int cpu)\r\n{\r\nstruct wf_cpu_pid_param pid;\r\nconst struct mpu_data *mpu = cpu_mpu_data[cpu];\r\ns32 tmax, ttarget, ptarget;\r\nint fmin, fmax, hsize;\r\ntmax = mpu->tmax << 16;\r\nttarget = mpu->ttarget << 16;\r\nptarget = ((s32)(mpu->pmaxh - mpu->padjmax)) << 16;\r\nDBG("wf_72: CPU%d ttarget = %d.%03d, tmax = %d.%03d\n",\r\ncpu, FIX32TOPRINT(ttarget), FIX32TOPRINT(tmax));\r\nif (tmax < cpu_all_tmax)\r\ncpu_all_tmax = tmax;\r\nfmin = wf_control_get_min(cpu_rear_fans[cpu]);\r\nfmax = wf_control_get_max(cpu_rear_fans[cpu]);\r\nDBG("wf_72: CPU%d max RPM range = [%d..%d]\n", cpu, fmin, fmax);\r\nhsize = min_t(int, mpu->tguardband, WF_PID_MAX_HISTORY);\r\nDBG("wf_72: CPU%d history size = %d\n", cpu, hsize);\r\npid.interval = 1;\r\npid.history_len = hsize;\r\npid.gd = mpu->pid_gd;\r\npid.gp = mpu->pid_gp;\r\npid.gr = mpu->pid_gr;\r\npid.tmax = tmax;\r\npid.ttarget = ttarget;\r\npid.pmaxadj = ptarget;\r\npid.min = fmin;\r\npid.max = fmax;\r\nwf_cpu_pid_init(&cpu_pid[cpu], &pid);\r\ncpu_pid[cpu].target = 1000;\r\nreturn 0;\r\n}\r\nstatic void backside_fan_tick(void)\r\n{\r\ns32 temp;\r\nint speed;\r\nint err;\r\nif (!backside_fan || !backside_temp || !backside_tick)\r\nreturn;\r\nif (--backside_tick > 0)\r\nreturn;\r\nbackside_tick = backside_pid.param.interval;\r\nDBG_LOTS("* backside fans tick\n");\r\nerr = wf_control_get(backside_fan, &speed);\r\nif (!err)\r\nbackside_pid.target = speed;\r\nerr = wf_sensor_get(backside_temp, &temp);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: U4 temp sensor error %d\n",\r\nerr);\r\nfailure_state |= FAILURE_SENSOR;\r\nwf_control_set_max(backside_fan);\r\nreturn;\r\n}\r\nspeed = wf_pid_run(&backside_pid, temp);\r\nDBG_LOTS("backside PID temp=%d.%.3d speed=%d\n",\r\nFIX32TOPRINT(temp), speed);\r\nerr = wf_control_set(backside_fan, speed);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: backside fan error %d\n", err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\nstatic void backside_setup_pid(void)\r\n{\r\ns32 fmin = wf_control_get_min(backside_fan);\r\ns32 fmax = wf_control_get_max(backside_fan);\r\nstruct wf_pid_param param;\r\nstruct device_node *u3;\r\nint u3h = 1;\r\nu3 = of_find_node_by_path("/u3@0,f8000000");\r\nif (u3 != NULL) {\r\nconst u32 *vers = of_get_property(u3, "device-rev", NULL);\r\nif (vers)\r\nif (((*vers) & 0x3f) < 0x34)\r\nu3h = 0;\r\nof_node_put(u3);\r\n}\r\nparam = u3h ? backside_u3h_param : backside_u3_param;\r\nparam.min = max(param.min, fmin);\r\nparam.max = min(param.max, fmax);\r\nwf_pid_init(&backside_pid, &param);\r\nbackside_tick = 1;\r\npr_info("wf_pm72: Backside control loop started.\n");\r\n}\r\nstatic void drives_fan_tick(void)\r\n{\r\ns32 temp;\r\nint speed;\r\nint err;\r\nif (!drives_fan || !drives_temp || !drives_tick)\r\nreturn;\r\nif (--drives_tick > 0)\r\nreturn;\r\ndrives_tick = drives_pid.param.interval;\r\nDBG_LOTS("* drives fans tick\n");\r\nerr = wf_control_get(drives_fan, &speed);\r\nif (!err)\r\ndrives_pid.target = speed;\r\nerr = wf_sensor_get(drives_temp, &temp);\r\nif (err) {\r\npr_warning("wf_pm72: drive bay temp sensor error %d\n", err);\r\nfailure_state |= FAILURE_SENSOR;\r\nwf_control_set_max(drives_fan);\r\nreturn;\r\n}\r\nspeed = wf_pid_run(&drives_pid, temp);\r\nDBG_LOTS("drives PID temp=%d.%.3d speed=%d\n",\r\nFIX32TOPRINT(temp), speed);\r\nerr = wf_control_set(drives_fan, speed);\r\nif (err) {\r\nprintk(KERN_WARNING "windfarm: drive bay fan error %d\n", err);\r\nfailure_state |= FAILURE_FAN;\r\n}\r\n}\r\nstatic void drives_setup_pid(void)\r\n{\r\ns32 fmin = wf_control_get_min(drives_fan);\r\ns32 fmax = wf_control_get_max(drives_fan);\r\nstruct wf_pid_param param = drives_param;\r\nparam.min = max(param.min, fmin);\r\nparam.max = min(param.max, fmax);\r\nwf_pid_init(&drives_pid, &param);\r\ndrives_tick = 1;\r\npr_info("wf_pm72: Drive bay control loop started.\n");\r\n}\r\nstatic void set_fail_state(void)\r\n{\r\ncpu_max_all_fans();\r\nif (backside_fan)\r\nwf_control_set_max(backside_fan);\r\nif (slots_fan)\r\nwf_control_set_max(slots_fan);\r\nif (drives_fan)\r\nwf_control_set_max(drives_fan);\r\n}\r\nstatic void pm72_tick(void)\r\n{\r\nint i, last_failure;\r\nif (!started) {\r\nstarted = 1;\r\nprintk(KERN_INFO "windfarm: CPUs control loops started.\n");\r\nfor (i = 0; i < nr_chips; ++i) {\r\nif (cpu_setup_pid(i) < 0) {\r\nfailure_state = FAILURE_PERM;\r\nset_fail_state();\r\nbreak;\r\n}\r\n}\r\nDBG_LOTS("cpu_all_tmax=%d.%03d\n", FIX32TOPRINT(cpu_all_tmax));\r\nbackside_setup_pid();\r\ndrives_setup_pid();\r\nwf_control_set(slots_fan, SLOTS_FAN_DEFAULT_PWM);\r\n#ifdef HACKED_OVERTEMP\r\ncpu_all_tmax = 60 << 16;\r\n#endif\r\n}\r\nif (failure_state & FAILURE_PERM)\r\nreturn;\r\nlast_failure = failure_state;\r\nfailure_state &= FAILURE_LOW_OVERTEMP;\r\nif (cpu_pid_combined)\r\ncpu_fans_tick_combined();\r\nelse\r\ncpu_fans_tick_split();\r\nbackside_fan_tick();\r\ndrives_fan_tick();\r\nDBG_LOTS(" last_failure: 0x%x, failure_state: %x\n",\r\nlast_failure, failure_state);\r\nif (failure_state && last_failure == 0 && cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nif (failure_state == 0 && last_failure && cpufreq_clamp)\r\nwf_control_set_min(cpufreq_clamp);\r\n}\r\nstatic void pm72_new_control(struct wf_control *ct)\r\n{\r\nbool all_controls;\r\nbool had_pump = cpu_pumps[0] || cpu_pumps[1];\r\nif (!strcmp(ct->name, "cpu-front-fan-0"))\r\ncpu_front_fans[0] = ct;\r\nelse if (!strcmp(ct->name, "cpu-front-fan-1"))\r\ncpu_front_fans[1] = ct;\r\nelse if (!strcmp(ct->name, "cpu-rear-fan-0"))\r\ncpu_rear_fans[0] = ct;\r\nelse if (!strcmp(ct->name, "cpu-rear-fan-1"))\r\ncpu_rear_fans[1] = ct;\r\nelse if (!strcmp(ct->name, "cpu-pump-0"))\r\ncpu_pumps[0] = ct;\r\nelse if (!strcmp(ct->name, "cpu-pump-1"))\r\ncpu_pumps[1] = ct;\r\nelse if (!strcmp(ct->name, "backside-fan"))\r\nbackside_fan = ct;\r\nelse if (!strcmp(ct->name, "slots-fan"))\r\nslots_fan = ct;\r\nelse if (!strcmp(ct->name, "drive-bay-fan"))\r\ndrives_fan = ct;\r\nelse if (!strcmp(ct->name, "cpufreq-clamp"))\r\ncpufreq_clamp = ct;\r\nall_controls =\r\ncpu_front_fans[0] &&\r\ncpu_rear_fans[0] &&\r\nbackside_fan &&\r\nslots_fan &&\r\ndrives_fan;\r\nif (nr_chips > 1)\r\nall_controls &=\r\ncpu_front_fans[1] &&\r\ncpu_rear_fans[1];\r\nhave_all_controls = all_controls;\r\nif ((cpu_pumps[0] || cpu_pumps[1]) && !had_pump) {\r\npr_info("wf_pm72: Liquid cooling pump(s) detected,"\r\n" using new algorithm !\n");\r\ncpu_pid_combined = true;\r\n}\r\n}\r\nstatic void pm72_new_sensor(struct wf_sensor *sr)\r\n{\r\nbool all_sensors;\r\nif (!strcmp(sr->name, "cpu-diode-temp-0"))\r\nsens_cpu_temp[0] = sr;\r\nelse if (!strcmp(sr->name, "cpu-diode-temp-1"))\r\nsens_cpu_temp[1] = sr;\r\nelse if (!strcmp(sr->name, "cpu-voltage-0"))\r\nsens_cpu_volts[0] = sr;\r\nelse if (!strcmp(sr->name, "cpu-voltage-1"))\r\nsens_cpu_volts[1] = sr;\r\nelse if (!strcmp(sr->name, "cpu-current-0"))\r\nsens_cpu_amps[0] = sr;\r\nelse if (!strcmp(sr->name, "cpu-current-1"))\r\nsens_cpu_amps[1] = sr;\r\nelse if (!strcmp(sr->name, "backside-temp"))\r\nbackside_temp = sr;\r\nelse if (!strcmp(sr->name, "hd-temp"))\r\ndrives_temp = sr;\r\nall_sensors =\r\nsens_cpu_temp[0] &&\r\nsens_cpu_volts[0] &&\r\nsens_cpu_amps[0] &&\r\nbackside_temp &&\r\ndrives_temp;\r\nif (nr_chips > 1)\r\nall_sensors &=\r\nsens_cpu_temp[1] &&\r\nsens_cpu_volts[1] &&\r\nsens_cpu_amps[1];\r\nhave_all_sensors = all_sensors;\r\n}\r\nstatic int pm72_wf_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nswitch (event) {\r\ncase WF_EVENT_NEW_SENSOR:\r\npm72_new_sensor(data);\r\nbreak;\r\ncase WF_EVENT_NEW_CONTROL:\r\npm72_new_control(data);\r\nbreak;\r\ncase WF_EVENT_TICK:\r\nif (have_all_controls && have_all_sensors)\r\npm72_tick();\r\n}\r\nreturn 0;\r\n}\r\nstatic int wf_pm72_probe(struct platform_device *dev)\r\n{\r\nwf_register_client(&pm72_events);\r\nreturn 0;\r\n}\r\nstatic int __devexit wf_pm72_remove(struct platform_device *dev)\r\n{\r\nwf_unregister_client(&pm72_events);\r\nreturn 0;\r\n}\r\nstatic int __init wf_pm72_init(void)\r\n{\r\nstruct device_node *cpu;\r\nint i;\r\nif (!of_machine_is_compatible("PowerMac7,2") &&\r\n!of_machine_is_compatible("PowerMac7,3"))\r\nreturn -ENODEV;\r\nnr_chips = 0;\r\nfor (cpu = NULL; (cpu = of_find_node_by_type(cpu, "cpu")) != NULL; )\r\n++nr_chips;\r\nif (nr_chips > NR_CHIPS)\r\nnr_chips = NR_CHIPS;\r\npr_info("windfarm: Initializing for desktop G5 with %d chips\n",\r\nnr_chips);\r\nfor (i = 0; i < nr_chips; i++) {\r\ncpu_mpu_data[i] = wf_get_mpu(i);\r\nif (!cpu_mpu_data[i]) {\r\npr_err("wf_pm72: Failed to find MPU data for CPU %d\n", i);\r\nreturn -ENXIO;\r\n}\r\n}\r\n#ifdef MODULE\r\nrequest_module("windfarm_fcu_controls");\r\nrequest_module("windfarm_lm75_sensor");\r\nrequest_module("windfarm_ad7417_sensor");\r\nrequest_module("windfarm_max6690_sensor");\r\nrequest_module("windfarm_cpufreq_clamp");\r\n#endif\r\nplatform_driver_register(&wf_pm72_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit wf_pm72_exit(void)\r\n{\r\nplatform_driver_unregister(&wf_pm72_driver);\r\n}
