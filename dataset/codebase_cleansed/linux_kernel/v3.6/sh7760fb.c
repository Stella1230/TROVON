static irqreturn_t sh7760fb_irq(int irq, void *data)\r\n{\r\nstruct completion *c = data;\r\ncomplete(c);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wait_for_lps(struct sh7760fb_par *par, int val)\r\n{\r\nint i = 100;\r\nwhile (--i && ((ioread16(par->base + LDPMMR) & 3) != val))\r\nmsleep(1);\r\nif (i <= 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int sh7760fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct sh7760fb_par *par = info->par;\r\nstruct sh7760fb_platdata *pd = par->pd;\r\nunsigned short cntr = ioread16(par->base + LDCNTR);\r\nunsigned short intr = ioread16(par->base + LDINTR);\r\nint lps;\r\nif (blank == FB_BLANK_UNBLANK) {\r\nintr |= VINT_START;\r\ncntr = LDCNTR_DON2 | LDCNTR_DON;\r\nlps = 3;\r\n} else {\r\nintr &= ~VINT_START;\r\ncntr = LDCNTR_DON2;\r\nlps = 0;\r\n}\r\nif (pd->blank)\r\npd->blank(blank);\r\niowrite16(intr, par->base + LDINTR);\r\niowrite16(cntr, par->base + LDCNTR);\r\nreturn wait_for_lps(par, lps);\r\n}\r\nstatic int sh7760_setcolreg (u_int regno,\r\nu_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nu32 *palette = info->pseudo_palette;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nred >>= 16 - info->var.red.length;\r\ngreen >>= 16 - info->var.green.length;\r\nblue >>= 16 - info->var.blue.length;\r\ntransp >>= 16 - info->var.transp.length;\r\npalette[regno] = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\nreturn 0;\r\n}\r\nstatic int sh7760fb_get_color_info(struct device *dev,\r\nu16 lddfr, int *bpp, int *gray)\r\n{\r\nint lbpp, lgray;\r\nlgray = lbpp = 0;\r\nswitch (lddfr & LDDFR_COLOR_MASK) {\r\ncase LDDFR_1BPP_MONO:\r\nlgray = 1;\r\nlbpp = 1;\r\nbreak;\r\ncase LDDFR_2BPP_MONO:\r\nlgray = 1;\r\nlbpp = 2;\r\nbreak;\r\ncase LDDFR_4BPP_MONO:\r\nlgray = 1;\r\ncase LDDFR_4BPP:\r\nlbpp = 4;\r\nbreak;\r\ncase LDDFR_6BPP_MONO:\r\nlgray = 1;\r\ncase LDDFR_8BPP:\r\nlbpp = 8;\r\nbreak;\r\ncase LDDFR_16BPP_RGB555:\r\ncase LDDFR_16BPP_RGB565:\r\nlbpp = 16;\r\nlgray = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "unsupported LDDFR bit depth.\n");\r\nreturn -EINVAL;\r\n}\r\nif (bpp)\r\n*bpp = lbpp;\r\nif (gray)\r\n*gray = lgray;\r\nreturn 0;\r\n}\r\nstatic int sh7760fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nstruct sh7760fb_par *par = info->par;\r\nint ret, bpp;\r\nret = sh7760fb_get_color_info(info->dev, par->pd->lddfr, &bpp, NULL);\r\nif (ret)\r\nreturn ret;\r\nvar->bits_per_pixel = bpp;\r\nif ((var->grayscale) && (var->bits_per_pixel == 1))\r\nfix->visual = FB_VISUAL_MONO10;\r\nelse if (var->bits_per_pixel >= 15)\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nelse\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nreturn 0;\r\n}\r\nstatic int sh7760fb_set_par(struct fb_info *info)\r\n{\r\nstruct sh7760fb_par *par = info->par;\r\nstruct fb_videomode *vm = par->pd->def_mode;\r\nunsigned long sbase, dstn_off, ldsarl, stride;\r\nunsigned short hsynp, hsynw, htcn, hdcn;\r\nunsigned short vsynp, vsynw, vtln, vdln;\r\nunsigned short lddfr, ldmtr;\r\nint ret, bpp, gray;\r\npar->rot = par->pd->rotate;\r\nif (par->rot && (vm->xres > 320)) {\r\ndev_dbg(info->dev, "rotation disabled due to display size\n");\r\npar->rot = 0;\r\n}\r\nhsynp = vm->right_margin + vm->xres;\r\nhsynw = vm->hsync_len;\r\nhtcn = vm->left_margin + hsynp + hsynw;\r\nhdcn = vm->xres;\r\nvsynp = vm->lower_margin + vm->yres;\r\nvsynw = vm->vsync_len;\r\nvtln = vm->upper_margin + vsynp + vsynw;\r\nvdln = vm->yres;\r\nret = sh7760fb_get_color_info(info->dev, par->pd->lddfr, &bpp, &gray);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(info->dev, "%dx%d %dbpp %s (orientation %s)\n", hdcn,\r\nvdln, bpp, gray ? "grayscale" : "color",\r\npar->rot ? "rotated" : "normal");\r\n#ifdef CONFIG_CPU_LITTLE_ENDIAN\r\nlddfr = par->pd->lddfr | (1 << 8);\r\n#else\r\nlddfr = par->pd->lddfr & ~(1 << 8);\r\n#endif\r\nldmtr = par->pd->ldmtr;\r\nif (!(vm->sync & FB_SYNC_HOR_HIGH_ACT))\r\nldmtr |= LDMTR_CL1POL;\r\nif (!(vm->sync & FB_SYNC_VERT_HIGH_ACT))\r\nldmtr |= LDMTR_FLMPOL;\r\nsh7760fb_blank(FB_BLANK_POWERDOWN, info);\r\niowrite16(par->pd->ldickr, par->base + LDICKR);\r\niowrite16(ldmtr, par->base + LDMTR);\r\niowrite16(lddfr, par->base + LDDFR);\r\niowrite16((par->rot ? 1 << 13 : 0), par->base + LDSMR);\r\niowrite16(par->pd->ldpmmr, par->base + LDPMMR);\r\niowrite16(par->pd->ldpspr, par->base + LDPSPR);\r\niowrite16(((htcn >> 3) - 1) | (((hdcn >> 3) - 1) << 8),\r\npar->base + LDHCNR);\r\niowrite16(vdln - 1, par->base + LDVDLNR);\r\niowrite16(vtln - 1, par->base + LDVTLNR);\r\niowrite16((vsynp - 1) | ((vsynw - 1) << 12), par->base + LDVSYNR);\r\niowrite16(((hsynp >> 3) - 1) | (((hsynw >> 3) - 1) << 12),\r\npar->base + LDHSYNR);\r\niowrite16(par->pd->ldaclnr, par->base + LDACLNR);\r\nstride = (par->rot) ? vtln : hdcn;\r\nif (!gray)\r\nstride *= (bpp + 7) >> 3;\r\nelse {\r\nif (bpp == 1)\r\nstride >>= 3;\r\nelse if (bpp == 2)\r\nstride >>= 2;\r\nelse if (bpp == 4)\r\nstride >>= 1;\r\n}\r\nif (par->rot) {\r\nunsigned long bit = 1 << 31;\r\nwhile (bit) {\r\nif (stride & bit)\r\nbreak;\r\nbit >>= 1;\r\n}\r\nif (stride & ~bit)\r\nstride = bit << 1;\r\n}\r\niowrite16(stride, par->base + LDLAOR);\r\nsbase = (unsigned long)par->fbdma;\r\nif (par->rot)\r\nsbase += (hdcn - 1) * stride;\r\niowrite32(sbase, par->base + LDSARU);\r\nif (((ldmtr & 0x003f) >= LDMTR_DSTN_MONO_8) &&\r\n((ldmtr & 0x003f) <= LDMTR_DSTN_COLOR_16)) {\r\ndev_dbg(info->dev, " ***** DSTN untested! *****\n");\r\ndstn_off = stride;\r\nif (par->rot)\r\ndstn_off *= hdcn >> 1;\r\nelse\r\ndstn_off *= vdln >> 1;\r\nldsarl = sbase + dstn_off;\r\n} else\r\nldsarl = 0;\r\niowrite32(ldsarl, par->base + LDSARL);\r\ninfo->fix.line_length = stride;\r\nsh7760fb_check_var(&info->var, info);\r\nsh7760fb_blank(FB_BLANK_UNBLANK, info);\r\ndev_dbg(info->dev, "hdcn : %6d htcn : %6d\n", hdcn, htcn);\r\ndev_dbg(info->dev, "hsynw : %6d hsynp : %6d\n", hsynw, hsynp);\r\ndev_dbg(info->dev, "vdln : %6d vtln : %6d\n", vdln, vtln);\r\ndev_dbg(info->dev, "vsynw : %6d vsynp : %6d\n", vsynw, vsynp);\r\ndev_dbg(info->dev, "clksrc: %6d clkdiv: %6d\n",\r\n(par->pd->ldickr >> 12) & 3, par->pd->ldickr & 0x1f);\r\ndev_dbg(info->dev, "ldpmmr: 0x%04x ldpspr: 0x%04x\n", par->pd->ldpmmr,\r\npar->pd->ldpspr);\r\ndev_dbg(info->dev, "ldmtr : 0x%04x lddfr : 0x%04x\n", ldmtr, lddfr);\r\ndev_dbg(info->dev, "ldlaor: %ld\n", stride);\r\ndev_dbg(info->dev, "ldsaru: 0x%08lx ldsarl: 0x%08lx\n", sbase, ldsarl);\r\nreturn 0;\r\n}\r\nstatic void sh7760fb_free_mem(struct fb_info *info)\r\n{\r\nstruct sh7760fb_par *par = info->par;\r\nif (!info->screen_base)\r\nreturn;\r\ndma_free_coherent(info->dev, info->screen_size,\r\ninfo->screen_base, par->fbdma);\r\npar->fbdma = 0;\r\ninfo->screen_base = NULL;\r\ninfo->screen_size = 0;\r\n}\r\nstatic int sh7760fb_alloc_mem(struct fb_info *info)\r\n{\r\nstruct sh7760fb_par *par = info->par;\r\nvoid *fbmem;\r\nunsigned long vram;\r\nint ret, bpp;\r\nif (info->screen_base)\r\nreturn 0;\r\nret = sh7760fb_get_color_info(info->dev, par->pd->lddfr, &bpp, NULL);\r\nif (ret) {\r\nprintk(KERN_ERR "colinfo\n");\r\nreturn ret;\r\n}\r\nvram = info->var.xres * info->var.yres;\r\nif (info->var.grayscale) {\r\nif (bpp == 1)\r\nvram >>= 3;\r\nelse if (bpp == 2)\r\nvram >>= 2;\r\nelse if (bpp == 4)\r\nvram >>= 1;\r\n} else if (bpp > 8)\r\nvram *= 2;\r\nif ((vram < 1) || (vram > 1024 * 2048)) {\r\ndev_dbg(info->dev, "too much VRAM required. Check settings\n");\r\nreturn -ENODEV;\r\n}\r\nif (vram < PAGE_SIZE)\r\nvram = PAGE_SIZE;\r\nfbmem = dma_alloc_coherent(info->dev, vram, &par->fbdma, GFP_KERNEL);\r\nif (!fbmem)\r\nreturn -ENOMEM;\r\nif ((par->fbdma & SH7760FB_DMA_MASK) != SH7760FB_DMA_MASK) {\r\nsh7760fb_free_mem(info);\r\ndev_err(info->dev, "kernel gave me memory at 0x%08lx, which is"\r\n"unusable for the LCDC\n", (unsigned long)par->fbdma);\r\nreturn -ENOMEM;\r\n}\r\ninfo->screen_base = fbmem;\r\ninfo->screen_size = vram;\r\ninfo->fix.smem_start = (unsigned long)info->screen_base;\r\ninfo->fix.smem_len = info->screen_size;\r\nreturn 0;\r\n}\r\nstatic int __devinit sh7760fb_probe(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info;\r\nstruct resource *res;\r\nstruct sh7760fb_par *par;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(res == NULL)) {\r\ndev_err(&pdev->dev, "invalid resource\n");\r\nreturn -EINVAL;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct sh7760fb_par), &pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\npar->dev = pdev;\r\npar->pd = pdev->dev.platform_data;\r\nif (!par->pd) {\r\ndev_dbg(info->dev, "no display setup data!\n");\r\nret = -ENODEV;\r\ngoto out_fb;\r\n}\r\npar->ioarea = request_mem_region(res->start,\r\nresource_size(res), pdev->name);\r\nif (!par->ioarea) {\r\ndev_err(&pdev->dev, "mmio area busy\n");\r\nret = -EBUSY;\r\ngoto out_fb;\r\n}\r\npar->base = ioremap_nocache(res->start, resource_size(res));\r\nif (!par->base) {\r\ndev_err(&pdev->dev, "cannot remap\n");\r\nret = -ENODEV;\r\ngoto out_res;\r\n}\r\niowrite16(0, par->base + LDINTR);\r\npar->irq = platform_get_irq(pdev, 0);\r\nif (par->irq >= 0) {\r\nret = request_irq(par->irq, sh7760fb_irq, 0,\r\n"sh7760-lcdc", &par->vsync);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot grab IRQ\n");\r\npar->irq = -ENXIO;\r\n} else\r\ndisable_irq_nosync(par->irq);\r\n}\r\nfb_videomode_to_var(&info->var, par->pd->def_mode);\r\nret = sh7760fb_alloc_mem(info);\r\nif (ret) {\r\ndev_dbg(info->dev, "framebuffer memory allocation failed!\n");\r\ngoto out_unmap;\r\n}\r\ninfo->pseudo_palette = par->pseudo_palette;\r\ninfo->var.red.offset = 11;\r\ninfo->var.red.length = 5;\r\ninfo->var.red.msb_right = 0;\r\ninfo->var.green.offset = 5;\r\ninfo->var.green.length = 6;\r\ninfo->var.green.msb_right = 0;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.blue.length = 5;\r\ninfo->var.blue.msb_right = 0;\r\ninfo->var.transp.offset = 0;\r\ninfo->var.transp.length = 0;\r\ninfo->var.transp.msb_right = 0;\r\nstrcpy(info->fix.id, "sh7760-lcdc");\r\niowrite16(LDCNTR_DON2, par->base + LDCNTR);\r\ninfo->fbops = &sh7760fb_ops;\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\ndev_dbg(info->dev, "Unable to allocate cmap memory\n");\r\ngoto out_mem;\r\n}\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\ndev_dbg(info->dev, "cannot register fb!\n");\r\ngoto out_cmap;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nprintk(KERN_INFO "%s: memory at phys 0x%08lx-0x%08lx, size %ld KiB\n",\r\npdev->name,\r\n(unsigned long)par->fbdma,\r\n(unsigned long)(par->fbdma + info->screen_size - 1),\r\ninfo->screen_size >> 10);\r\nreturn 0;\r\nout_cmap:\r\nsh7760fb_blank(FB_BLANK_POWERDOWN, info);\r\nfb_dealloc_cmap(&info->cmap);\r\nout_mem:\r\nsh7760fb_free_mem(info);\r\nout_unmap:\r\nif (par->irq >= 0)\r\nfree_irq(par->irq, &par->vsync);\r\niounmap(par->base);\r\nout_res:\r\nrelease_mem_region(res->start, resource_size(res));\r\nout_fb:\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int __devexit sh7760fb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct sh7760fb_par *par = info->par;\r\nsh7760fb_blank(FB_BLANK_POWERDOWN, info);\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nsh7760fb_free_mem(info);\r\nif (par->irq >= 0)\r\nfree_irq(par->irq, par);\r\niounmap(par->base);\r\nrelease_mem_region(par->ioarea->start, resource_size(par->ioarea));\r\nframebuffer_release(info);\r\nplatform_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}
