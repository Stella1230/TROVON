static int regget(struct usb_device *pusb_device,\r\nu16 index, void *reg, int reg_size)\r\n{\r\nint rc;\r\nif (!pusb_device)\r\nreturn -ENODEV;\r\nrc = usb_control_msg(pusb_device, usb_rcvctrlpipe(pusb_device, 0),\r\n0x00,\r\n(USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE),\r\n0x00,\r\nindex, reg, reg_size, 50000);\r\nreturn rc;\r\n}\r\nstatic int regset(struct usb_device *pusb_device, u16 index, u16 value)\r\n{\r\nint rc;\r\nif (!pusb_device)\r\nreturn -ENODEV;\r\nrc = usb_control_msg(pusb_device, usb_sndctrlpipe(pusb_device, 0),\r\n0x01,\r\n(USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE),\r\nvalue, index, NULL, 0, 500);\r\nif (rc < 0)\r\nreturn rc;\r\nif (easycap_readback) {\r\nu16 igot = 0;\r\nrc = regget(pusb_device, index, &igot, sizeof(igot));\r\nigot = 0xFF & igot;\r\nswitch (index) {\r\ncase 0x000:\r\ncase 0x500:\r\ncase 0x502:\r\ncase 0x503:\r\ncase 0x504:\r\ncase 0x506:\r\ncase 0x507:\r\nbreak;\r\ncase 0x204:\r\ncase 0x205:\r\ncase 0x350:\r\ncase 0x351:\r\nif (igot)\r\nJOT(8, "unexpected 0x%02X "\r\n"for STK register 0x%03X\n",\r\nigot, index);\r\nbreak;\r\ndefault:\r\nif ((0xFF & value) != igot)\r\nJOT(8, "unexpected 0x%02X != 0x%02X "\r\n"for STK register 0x%03X\n",\r\nigot, value, index);\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int wait_i2c(struct usb_device *p)\r\n{\r\nu16 get0;\r\nu8 igot;\r\nconst int max = 2;\r\nint k;\r\nif (!p)\r\nreturn -ENODEV;\r\nfor (k = 0; k < max; k++) {\r\nGET(p, 0x0201, &igot); get0 = igot;\r\nswitch (get0) {\r\ncase 0x04:\r\ncase 0x01:\r\nreturn 0;\r\ncase 0x00:\r\nmsleep(20);\r\ncontinue;\r\ndefault:\r\nreturn get0 - 1;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint write_saa(struct usb_device *p, u16 reg0, u16 set0)\r\n{\r\nif (!p)\r\nreturn -ENODEV;\r\nSET(p, 0x200, 0x00);\r\nSET(p, 0x204, reg0);\r\nSET(p, 0x205, set0);\r\nSET(p, 0x200, 0x01);\r\nreturn wait_i2c(p);\r\n}\r\nstatic int write_vt(struct usb_device *p, u16 reg0, u16 set0)\r\n{\r\nu8 igot;\r\nu16 got502, got503;\r\nu16 set502, set503;\r\nif (!p)\r\nreturn -ENODEV;\r\nSET(p, 0x0504, reg0);\r\nSET(p, 0x0500, 0x008B);\r\nGET(p, 0x0502, &igot); got502 = (0xFF & igot);\r\nGET(p, 0x0503, &igot); got503 = (0xFF & igot);\r\nJOT(16, "write_vt(., 0x%04X, 0x%04X): was 0x%04X\n",\r\nreg0, set0, ((got503 << 8) | got502));\r\nset502 = (0x00FF & set0);\r\nset503 = ((0xFF00 & set0) >> 8);\r\nSET(p, 0x0504, reg0);\r\nSET(p, 0x0502, set502);\r\nSET(p, 0x0503, set503);\r\nSET(p, 0x0500, 0x008C);\r\nreturn 0;\r\n}\r\nstatic int read_vt(struct usb_device *p, u16 reg0)\r\n{\r\nu8 igot;\r\nu16 got502, got503;\r\nif (!p)\r\nreturn -ENODEV;\r\nSET(p, 0x0504, reg0);\r\nSET(p, 0x0500, 0x008B);\r\nGET(p, 0x0502, &igot); got502 = (0xFF & igot);\r\nGET(p, 0x0503, &igot); got503 = (0xFF & igot);\r\nJOT(16, "read_vt(., 0x%04X): has 0x%04X\n",\r\nreg0, ((got503 << 8) | got502));\r\nreturn (got503 << 8) | got502;\r\n}\r\nstatic int write_300(struct usb_device *p)\r\n{\r\nif (!p)\r\nreturn -ENODEV;\r\nSET(p, 0x300, 0x0012);\r\nSET(p, 0x350, 0x002D);\r\nSET(p, 0x351, 0x0001);\r\nSET(p, 0x352, 0x0000);\r\nSET(p, 0x353, 0x0000);\r\nSET(p, 0x300, 0x0080);\r\nreturn 0;\r\n}\r\nint setup_stk(struct usb_device *p, bool ntsc)\r\n{\r\nint i;\r\nconst struct stk1160config *cfg;\r\nif (!p)\r\nreturn -ENODEV;\r\ncfg = (ntsc) ? stk1160configNTSC : stk1160configPAL;\r\nfor (i = 0; cfg[i].reg != 0xFFF; i++)\r\nSET(p, cfg[i].reg, cfg[i].set);\r\nwrite_300(p);\r\nreturn 0;\r\n}\r\nint setup_saa(struct usb_device *p, bool ntsc)\r\n{\r\nint i, rc;\r\nconst struct saa7113config *cfg;\r\nif (!p)\r\nreturn -ENODEV;\r\ncfg = (ntsc) ? saa7113configNTSC : saa7113configPAL;\r\nfor (i = 0; cfg[i].reg != 0xFF; i++) {\r\nrc = write_saa(p, cfg[i].reg, cfg[i].set);\r\nif (rc)\r\ndev_err(&p->dev,\r\n"Failed to set SAA register %d", cfg[i].reg);\r\n}\r\nreturn 0;\r\n}\r\nint merit_saa(struct usb_device *p)\r\n{\r\nint rc;\r\nif (!p)\r\nreturn -ENODEV;\r\nrc = read_saa(p, 0x1F);\r\nreturn ((0 > rc) || (0x02 & rc)) ? 1 : 0;\r\n}\r\nint ready_saa(struct usb_device *p)\r\n{\r\nint j, rc, rate;\r\nconst int max = 5, marktime = PATIENCE/5;\r\nif (!p)\r\nreturn -ENODEV;\r\nj = 0;\r\nwhile (max > j) {\r\nrc = read_saa(p, 0x1F);\r\nif (0 <= rc) {\r\nif (0 == (0x40 & rc))\r\nbreak;\r\nif (1 == (0x01 & rc))\r\nbreak;\r\n}\r\nmsleep(marktime);\r\nj++;\r\n}\r\nif (max == j)\r\nreturn -1;\r\nif (0x20 & rc) {\r\nrate = 2;\r\nJOT(8, "hardware detects 60 Hz\n");\r\n} else {\r\nrate = 0;\r\nJOT(8, "hardware detects 50 Hz\n");\r\n}\r\nif (0x80 & rc)\r\nJOT(8, "hardware detects interlacing\n");\r\nelse {\r\nrate++;\r\nJOT(8, "hardware detects no interlacing\n");\r\n}\r\nreturn 0;\r\n}\r\nint read_saa(struct usb_device *p, u16 reg0)\r\n{\r\nu8 igot;\r\nif (!p)\r\nreturn -ENODEV;\r\nSET(p, 0x208, reg0);\r\nSET(p, 0x200, 0x20);\r\nif (0 != wait_i2c(p))\r\nreturn -1;\r\nigot = 0;\r\nGET(p, 0x0209, &igot);\r\nreturn igot;\r\n}\r\nstatic int read_stk(struct usb_device *p, u32 reg0)\r\n{\r\nu8 igot;\r\nif (!p)\r\nreturn -ENODEV;\r\nigot = 0;\r\nGET(p, reg0, &igot);\r\nreturn igot;\r\n}\r\nint select_input(struct usb_device *p, int input, int mode)\r\n{\r\nint ir;\r\nif (!p)\r\nreturn -ENODEV;\r\nstop_100(p);\r\nswitch (input) {\r\ncase 0:\r\ncase 1: {\r\nif (0 != write_saa(p, 0x02, 0x80))\r\nSAY("ERROR: failed to set SAA register 0x02 "\r\n"for input %i\n", input);\r\nSET(p, 0x0000, 0x0098);\r\nSET(p, 0x0002, 0x0078);\r\nbreak;\r\n}\r\ncase 2: {\r\nif (0 != write_saa(p, 0x02, 0x80))\r\nSAY("ERROR: failed to set SAA register 0x02 "\r\n"for input %i\n", input);\r\nSET(p, 0x0000, 0x0090);\r\nSET(p, 0x0002, 0x0078);\r\nbreak;\r\n}\r\ncase 3: {\r\nif (0 != write_saa(p, 0x02, 0x80))\r\nSAY("ERROR: failed to set SAA register 0x02 "\r\n" for input %i\n", input);\r\nSET(p, 0x0000, 0x0088);\r\nSET(p, 0x0002, 0x0078);\r\nbreak;\r\n}\r\ncase 4: {\r\nif (0 != write_saa(p, 0x02, 0x80)) {\r\nSAY("ERROR: failed to set SAA register 0x02 "\r\n"for input %i\n", input);\r\n}\r\nSET(p, 0x0000, 0x0080);\r\nSET(p, 0x0002, 0x0078);\r\nbreak;\r\n}\r\ncase 5: {\r\nif (9 != mode)\r\nmode = 7;\r\nswitch (mode) {\r\ncase 7: {\r\nif (0 != write_saa(p, 0x02, 0x87))\r\nSAY("ERROR: failed to set SAA register 0x02 "\r\n"for input %i\n", input);\r\nif (0 != write_saa(p, 0x05, 0xFF))\r\nSAY("ERROR: failed to set SAA register 0x05 "\r\n"for input %i\n", input);\r\nbreak;\r\n}\r\ncase 9: {\r\nif (0 != write_saa(p, 0x02, 0x89))\r\nSAY("ERROR: failed to set SAA register 0x02 "\r\n"for input %i\n", input);\r\nif (0 != write_saa(p, 0x05, 0x00))\r\nSAY("ERROR: failed to set SAA register 0x05 "\r\n"for input %i\n", input);\r\nbreak;\r\n}\r\ndefault:\r\nSAY("MISTAKE: bad mode: %i\n", mode);\r\nreturn -1;\r\n}\r\nif (0 != write_saa(p, 0x04, 0x00))\r\nSAY("ERROR: failed to set SAA register 0x04 "\r\n"for input %i\n", input);\r\nif (0 != write_saa(p, 0x09, 0x80))\r\nSAY("ERROR: failed to set SAA register 0x09 "\r\n"for input %i\n", input);\r\nSET(p, 0x0002, 0x0093);\r\nbreak;\r\n}\r\ndefault:\r\nSAY("ERROR: bad input: %i\n", input);\r\nreturn -1;\r\n}\r\nir = read_stk(p, 0x00);\r\nJOT(8, "STK register 0x00 has 0x%02X\n", ir);\r\nir = read_saa(p, 0x02);\r\nJOT(8, "SAA register 0x02 has 0x%02X\n", ir);\r\nstart_100(p);\r\nreturn 0;\r\n}\r\nint set_resolution(struct usb_device *p,\r\nu16 set0, u16 set1, u16 set2, u16 set3)\r\n{\r\nu16 u0x0111, u0x0113, u0x0115, u0x0117;\r\nif (!p)\r\nreturn -ENODEV;\r\nu0x0111 = ((0xFF00 & set0) >> 8);\r\nu0x0113 = ((0xFF00 & set1) >> 8);\r\nu0x0115 = ((0xFF00 & set2) >> 8);\r\nu0x0117 = ((0xFF00 & set3) >> 8);\r\nSET(p, 0x0110, (0x00FF & set0));\r\nSET(p, 0x0111, u0x0111);\r\nSET(p, 0x0112, (0x00FF & set1));\r\nSET(p, 0x0113, u0x0113);\r\nSET(p, 0x0114, (0x00FF & set2));\r\nSET(p, 0x0115, u0x0115);\r\nSET(p, 0x0116, (0x00FF & set3));\r\nSET(p, 0x0117, u0x0117);\r\nreturn 0;\r\n}\r\nint start_100(struct usb_device *p)\r\n{\r\nu16 get116, get117, get0;\r\nu8 igot116, igot117, igot;\r\nif (!p)\r\nreturn -ENODEV;\r\nGET(p, 0x0116, &igot116);\r\nget116 = igot116;\r\nGET(p, 0x0117, &igot117);\r\nget117 = igot117;\r\nSET(p, 0x0116, 0x0000);\r\nSET(p, 0x0117, 0x0000);\r\nGET(p, 0x0100, &igot);\r\nget0 = igot;\r\nSET(p, 0x0100, (0x80 | get0));\r\nSET(p, 0x0116, get116);\r\nSET(p, 0x0117, get117);\r\nreturn 0;\r\n}\r\nint stop_100(struct usb_device *p)\r\n{\r\nu16 get0;\r\nu8 igot;\r\nif (!p)\r\nreturn -ENODEV;\r\nGET(p, 0x0100, &igot);\r\nget0 = igot;\r\nSET(p, 0x0100, (0x7F & get0));\r\nreturn 0;\r\n}\r\nint easycap_wakeup_device(struct usb_device *pusb_device)\r\n{\r\nif (!pusb_device)\r\nreturn -ENODEV;\r\nreturn usb_control_msg(pusb_device, usb_sndctrlpipe(pusb_device, 0),\r\nUSB_REQ_SET_FEATURE,\r\nUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\r\nUSB_DEVICE_REMOTE_WAKEUP,\r\n0, NULL, 0, 50000);\r\n}\r\nint easycap_audio_setup(struct easycap *peasycap)\r\n{\r\nstruct usb_device *pusb_device;\r\nu8 buffer[1];\r\nint rc, id1, id2;\r\nconst u8 request = 0x01;\r\nconst u8 requesttype = USB_DIR_OUT |\r\nUSB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE;\r\nconst u16 value_unmute = 0x0200;\r\nconst u16 index = 0x0301;\r\nconst u16 length = 1;\r\nif (!peasycap)\r\nreturn -EFAULT;\r\npusb_device = peasycap->pusb_device;\r\nif (!pusb_device)\r\nreturn -ENODEV;\r\nJOM(8, "%02X %02X %02X %02X %02X %02X %02X %02X\n",\r\nrequesttype, request,\r\n(0x00FF & value_unmute),\r\n(0xFF00 & value_unmute) >> 8,\r\n(0x00FF & index),\r\n(0xFF00 & index) >> 8,\r\n(0x00FF & length),\r\n(0xFF00 & length) >> 8);\r\nbuffer[0] = 0x01;\r\nrc = usb_control_msg(pusb_device, usb_sndctrlpipe(pusb_device, 0),\r\nrequest, requesttype, value_unmute,\r\nindex, &buffer[0], length, 50000);\r\nJOT(8, "0x%02X=buffer\n", buffer[0]);\r\nif (rc != (int)length) {\r\nswitch (rc) {\r\ncase -EPIPE:\r\nSAY("usb_control_msg returned -EPIPE\n");\r\nbreak;\r\ndefault:\r\nSAY("ERROR: usb_control_msg returned %i\n", rc);\r\nbreak;\r\n}\r\n}\r\nSET(pusb_device, 0x0500, 0x0094);\r\nSET(pusb_device, 0x0500, 0x008C);\r\nSET(pusb_device, 0x0506, 0x0001);\r\nSET(pusb_device, 0x0507, 0x0000);\r\nid1 = read_vt(pusb_device, 0x007C);\r\nid2 = read_vt(pusb_device, 0x007E);\r\nSAM("0x%04X:0x%04X is audio vendor id\n", id1, id2);\r\nif (easycap_audio_gainset(pusb_device, peasycap->gain))\r\nSAY("ERROR: audio_gainset() failed\n");\r\ncheck_vt(pusb_device);\r\nreturn 0;\r\n}\r\nint check_vt(struct usb_device *pusb_device)\r\n{\r\nint igot;\r\nif (!pusb_device)\r\nreturn -ENODEV;\r\nigot = read_vt(pusb_device, 0x0002);\r\nif (0 > igot)\r\nSAY("ERROR: failed to read VT1612A register 0x02\n");\r\nif (0x8000 & igot)\r\nSAY("register 0x%02X muted\n", 0x02);\r\nigot = read_vt(pusb_device, 0x000E);\r\nif (0 > igot)\r\nSAY("ERROR: failed to read VT1612A register 0x0E\n");\r\nif (0x8000 & igot)\r\nSAY("register 0x%02X muted\n", 0x0E);\r\nigot = read_vt(pusb_device, 0x0010);\r\nif (0 > igot)\r\nSAY("ERROR: failed to read VT1612A register 0x10\n");\r\nif (0x8000 & igot)\r\nSAY("register 0x%02X muted\n", 0x10);\r\nigot = read_vt(pusb_device, 0x0012);\r\nif (0 > igot)\r\nSAY("ERROR: failed to read VT1612A register 0x12\n");\r\nif (0x8000 & igot)\r\nSAY("register 0x%02X muted\n", 0x12);\r\nigot = read_vt(pusb_device, 0x0014);\r\nif (0 > igot)\r\nSAY("ERROR: failed to read VT1612A register 0x14\n");\r\nif (0x8000 & igot)\r\nSAY("register 0x%02X muted\n", 0x14);\r\nigot = read_vt(pusb_device, 0x0016);\r\nif (0 > igot)\r\nSAY("ERROR: failed to read VT1612A register 0x16\n");\r\nif (0x8000 & igot)\r\nSAY("register 0x%02X muted\n", 0x16);\r\nigot = read_vt(pusb_device, 0x0018);\r\nif (0 > igot)\r\nSAY("ERROR: failed to read VT1612A register 0x18\n");\r\nif (0x8000 & igot)\r\nSAY("register 0x%02X muted\n", 0x18);\r\nigot = read_vt(pusb_device, 0x001C);\r\nif (0 > igot)\r\nSAY("ERROR: failed to read VT1612A register 0x1C\n");\r\nif (0x8000 & igot)\r\nSAY("register 0x%02X muted\n", 0x1C);\r\nreturn 0;\r\n}\r\nint easycap_audio_gainset(struct usb_device *pusb_device, s8 loud)\r\n{\r\nint igot;\r\nu8 tmp;\r\nu16 mute;\r\nif (!pusb_device)\r\nreturn -ENODEV;\r\nif (0 > loud)\r\nloud = 0;\r\nif (31 < loud)\r\nloud = 31;\r\nwrite_vt(pusb_device, 0x0002, 0x8000);\r\nigot = read_vt(pusb_device, 0x000E);\r\nif (0 > igot) {\r\nSAY("ERROR: failed to read VT1612A register 0x0E\n");\r\nmute = 0x0000;\r\n} else\r\nmute = 0x8000 & ((unsigned int)igot);\r\nmute = 0;\r\nif (16 > loud)\r\ntmp = 0x01 | (0x001F & (((u8)(15 - loud)) << 1));\r\nelse\r\ntmp = 0;\r\nJOT(8, "0x%04X=(mute|tmp) for VT1612A register 0x0E\n", mute | tmp);\r\nwrite_vt(pusb_device, 0x000E, (mute | tmp));\r\nigot = read_vt(pusb_device, 0x0010);\r\nif (0 > igot) {\r\nSAY("ERROR: failed to read VT1612A register 0x10\n");\r\nmute = 0x0000;\r\n} else\r\nmute = 0x8000 & ((unsigned int)igot);\r\nmute = 0;\r\nJOT(8, "0x%04X=(mute|tmp|(tmp<<8)) for VT1612A register 0x10,...0x18\n",\r\nmute | tmp | (tmp << 8));\r\nwrite_vt(pusb_device, 0x0010, (mute | tmp | (tmp << 8)));\r\nwrite_vt(pusb_device, 0x0012, (mute | tmp | (tmp << 8)));\r\nwrite_vt(pusb_device, 0x0014, (mute | tmp | (tmp << 8)));\r\nwrite_vt(pusb_device, 0x0016, (mute | tmp | (tmp << 8)));\r\nwrite_vt(pusb_device, 0x0018, (mute | tmp | (tmp << 8)));\r\nigot = read_vt(pusb_device, 0x001C);\r\nif (0 > igot) {\r\nSAY("ERROR: failed to read VT1612A register 0x1C\n");\r\nmute = 0x0000;\r\n} else\r\nmute = 0x8000 & ((unsigned int)igot);\r\nmute = 0;\r\nif (16 <= loud)\r\ntmp = 0x000F & (u8)(loud - 16);\r\nelse\r\ntmp = 0;\r\nJOT(8, "0x%04X=(mute|tmp|(tmp<<8)) for VT1612A register 0x1C\n",\r\nmute | tmp | (tmp << 8));\r\nwrite_vt(pusb_device, 0x001C, (mute | tmp | (tmp << 8)));\r\nwrite_vt(pusb_device, 0x001A, 0x0404);\r\nwrite_vt(pusb_device, 0x0002, 0x0000);\r\nreturn 0;\r\n}
