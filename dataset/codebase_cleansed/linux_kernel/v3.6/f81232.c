static void f81232_update_line_status(struct usb_serial_port *port,\r\nunsigned char *data,\r\nunsigned int actual_length)\r\n{\r\n}\r\nstatic void f81232_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned int actual_length = urb->actual_length;\r\nint status = urb->status;\r\nint retval;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(debug, &port->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\nf81232_update_line_status(port, data, actual_length);\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&urb->dev->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic void f81232_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nchar tty_flag = TTY_NORMAL;\r\nunsigned long flags;\r\nu8 line_status;\r\nint i;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nline_status = priv->line_status;\r\npriv->line_status &= ~UART_STATE_TRANSIENT_MASK;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\nif (!urb->actual_length)\r\nreturn;\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn;\r\nif (line_status & UART_BREAK_ERROR)\r\ntty_flag = TTY_BREAK;\r\nelse if (line_status & UART_PARITY_ERROR)\r\ntty_flag = TTY_PARITY;\r\nelse if (line_status & UART_FRAME_ERROR)\r\ntty_flag = TTY_FRAME;\r\ndev_dbg(&port->dev, "%s - tty_flag = %d\n", __func__, tty_flag);\r\nif (line_status & UART_OVERRUN_ERROR)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\nif (port->port.console && port->sysrq) {\r\nfor (i = 0; i < urb->actual_length; ++i)\r\nif (!usb_serial_handle_sysrq_char(port, data[i]))\r\ntty_insert_flip_char(tty, data[i], tty_flag);\r\n} else {\r\ntty_insert_flip_string_fixed_flag(tty, data, tty_flag,\r\nurb->actual_length);\r\n}\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int set_control_lines(struct usb_device *dev, u8 value)\r\n{\r\nreturn 0;\r\n}\r\nstatic void f81232_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\n}\r\nstatic void f81232_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nif (!tty_termios_hw_change(tty->termios, old_termios))\r\nreturn;\r\n}\r\nstatic int f81232_tiocmget(struct tty_struct *tty)\r\n{\r\nreturn 0;\r\n}\r\nstatic int f81232_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nreturn 0;\r\n}\r\nstatic int f81232_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct ktermios tmp_termios;\r\nint result;\r\nif (tty)\r\nf81232_set_termios(tty, port, &tmp_termios);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev, "%s - failed submitting interrupt urb,"\r\n" error %d\n", __func__, result);\r\nreturn result;\r\n}\r\nresult = usb_serial_generic_open(tty, port);\r\nif (result) {\r\nusb_kill_urb(port->interrupt_in_urb);\r\nreturn result;\r\n}\r\nport->port.drain_delay = 256;\r\nreturn 0;\r\n}\r\nstatic void f81232_close(struct usb_serial_port *port)\r\n{\r\nusb_serial_generic_close(port);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic void f81232_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nu8 control;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (on)\r\npriv->line_control |= (CONTROL_DTR | CONTROL_RTS);\r\nelse\r\npriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\r\ncontrol = priv->line_control;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nset_control_lines(port->serial->dev, control);\r\n}\r\nstatic int f81232_carrier_raised(struct usb_serial_port *port)\r\n{\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nif (priv->line_status & UART_DCD)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int wait_modem_info(struct usb_serial_port *port, unsigned int arg)\r\n{\r\nstruct f81232_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nunsigned int prevstatus;\r\nunsigned int status;\r\nunsigned int changed;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nprevstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwhile (1) {\r\ninterruptible_sleep_on(&priv->delta_msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = priv->line_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nchanged = prevstatus ^ status;\r\nif (((arg & TIOCM_RNG) && (changed & UART_RING)) ||\r\n((arg & TIOCM_DSR) && (changed & UART_DSR)) ||\r\n((arg & TIOCM_CD) && (changed & UART_DCD)) ||\r\n((arg & TIOCM_CTS) && (changed & UART_CTS))) {\r\nreturn 0;\r\n}\r\nprevstatus = status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int f81232_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct serial_struct ser;\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndev_dbg(&port->dev, "%s (%d) cmd = 0x%04x\n", __func__,\r\nport->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmemset(&ser, 0, sizeof ser);\r\nser.type = PORT_16654;\r\nser.line = port->serial->minor;\r\nser.port = port->number;\r\nser.baud_base = 460800;\r\nif (copy_to_user((void __user *)arg, &ser, sizeof ser))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase TIOCMIWAIT:\r\ndev_dbg(&port->dev, "%s (%d) TIOCMIWAIT\n", __func__,\r\nport->number);\r\nreturn wait_modem_info(port, arg);\r\ndefault:\r\ndev_dbg(&port->dev, "%s not supported = 0x%04x\n",\r\n__func__, cmd);\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int f81232_startup(struct usb_serial *serial)\r\n{\r\nstruct f81232_private *priv;\r\nint i;\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\npriv = kzalloc(sizeof(struct f81232_private), GFP_KERNEL);\r\nif (!priv)\r\ngoto cleanup;\r\nspin_lock_init(&priv->lock);\r\ninit_waitqueue_head(&priv->delta_msr_wait);\r\nusb_set_serial_port_data(serial->port[i], priv);\r\n}\r\nreturn 0;\r\ncleanup:\r\nfor (--i; i >= 0; --i) {\r\npriv = usb_get_serial_port_data(serial->port[i]);\r\nkfree(priv);\r\nusb_set_serial_port_data(serial->port[i], NULL);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void f81232_release(struct usb_serial *serial)\r\n{\r\nint i;\r\nstruct f81232_private *priv;\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\npriv = usb_get_serial_port_data(serial->port[i]);\r\nkfree(priv);\r\n}\r\n}
