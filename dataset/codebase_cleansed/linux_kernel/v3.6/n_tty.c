static inline int tty_put_user(struct tty_struct *tty, unsigned char x,\r\nunsigned char __user *ptr)\r\n{\r\ntty_audit_add_data(tty, &x, 1);\r\nreturn put_user(x, ptr);\r\n}\r\nstatic void n_tty_set_room(struct tty_struct *tty)\r\n{\r\nint left = N_TTY_BUF_SIZE - tty->read_cnt - 1;\r\nint old_left;\r\nif (left <= 0)\r\nleft = tty->icanon && !tty->canon_data;\r\nold_left = tty->receive_room;\r\ntty->receive_room = left;\r\nif (left && !old_left)\r\nschedule_work(&tty->buf.work);\r\n}\r\nstatic void put_tty_queue_nolock(unsigned char c, struct tty_struct *tty)\r\n{\r\nif (tty->read_cnt < N_TTY_BUF_SIZE) {\r\ntty->read_buf[tty->read_head] = c;\r\ntty->read_head = (tty->read_head + 1) & (N_TTY_BUF_SIZE-1);\r\ntty->read_cnt++;\r\n}\r\n}\r\nstatic void put_tty_queue(unsigned char c, struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\nput_tty_queue_nolock(c, tty);\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\n}\r\nstatic void check_unthrottle(struct tty_struct *tty)\r\n{\r\nif (tty->count)\r\ntty_unthrottle(tty);\r\n}\r\nstatic void reset_buffer_flags(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\ntty->read_head = tty->read_tail = tty->read_cnt = 0;\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\nmutex_lock(&tty->echo_lock);\r\ntty->echo_pos = tty->echo_cnt = tty->echo_overrun = 0;\r\nmutex_unlock(&tty->echo_lock);\r\ntty->canon_head = tty->canon_data = tty->erasing = 0;\r\nmemset(&tty->read_flags, 0, sizeof tty->read_flags);\r\nn_tty_set_room(tty);\r\n}\r\nstatic void n_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nreset_buffer_flags(tty);\r\nif (!tty->link)\r\nreturn;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nif (tty->link->packet) {\r\ntty->ctrl_status |= TIOCPKT_FLUSHREAD;\r\nwake_up_interruptible(&tty->link->read_wait);\r\n}\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\n}\r\nstatic ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nssize_t n = 0;\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\nif (!tty->icanon) {\r\nn = tty->read_cnt;\r\n} else if (tty->canon_data) {\r\nn = (tty->canon_head > tty->read_tail) ?\r\ntty->canon_head - tty->read_tail :\r\ntty->canon_head + (N_TTY_BUF_SIZE - tty->read_tail);\r\n}\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\nreturn n;\r\n}\r\nstatic inline int is_utf8_continuation(unsigned char c)\r\n{\r\nreturn (c & 0xc0) == 0x80;\r\n}\r\nstatic inline int is_continuation(unsigned char c, struct tty_struct *tty)\r\n{\r\nreturn I_IUTF8(tty) && is_utf8_continuation(c);\r\n}\r\nstatic int do_output_char(unsigned char c, struct tty_struct *tty, int space)\r\n{\r\nint spaces;\r\nif (!space)\r\nreturn -1;\r\nswitch (c) {\r\ncase '\n':\r\nif (O_ONLRET(tty))\r\ntty->column = 0;\r\nif (O_ONLCR(tty)) {\r\nif (space < 2)\r\nreturn -1;\r\ntty->canon_column = tty->column = 0;\r\ntty->ops->write(tty, "\r\n", 2);\r\nreturn 2;\r\n}\r\ntty->canon_column = tty->column;\r\nbreak;\r\ncase '\r':\r\nif (O_ONOCR(tty) && tty->column == 0)\r\nreturn 0;\r\nif (O_OCRNL(tty)) {\r\nc = '\n';\r\nif (O_ONLRET(tty))\r\ntty->canon_column = tty->column = 0;\r\nbreak;\r\n}\r\ntty->canon_column = tty->column = 0;\r\nbreak;\r\ncase '\t':\r\nspaces = 8 - (tty->column & 7);\r\nif (O_TABDLY(tty) == XTABS) {\r\nif (space < spaces)\r\nreturn -1;\r\ntty->column += spaces;\r\ntty->ops->write(tty, " ", spaces);\r\nreturn spaces;\r\n}\r\ntty->column += spaces;\r\nbreak;\r\ncase '\b':\r\nif (tty->column > 0)\r\ntty->column--;\r\nbreak;\r\ndefault:\r\nif (!iscntrl(c)) {\r\nif (O_OLCUC(tty))\r\nc = toupper(c);\r\nif (!is_continuation(c, tty))\r\ntty->column++;\r\n}\r\nbreak;\r\n}\r\ntty_put_char(tty, c);\r\nreturn 1;\r\n}\r\nstatic int process_output(unsigned char c, struct tty_struct *tty)\r\n{\r\nint space, retval;\r\nmutex_lock(&tty->output_lock);\r\nspace = tty_write_room(tty);\r\nretval = do_output_char(c, tty, space);\r\nmutex_unlock(&tty->output_lock);\r\nif (retval < 0)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t process_output_block(struct tty_struct *tty,\r\nconst unsigned char *buf, unsigned int nr)\r\n{\r\nint space;\r\nint i;\r\nconst unsigned char *cp;\r\nmutex_lock(&tty->output_lock);\r\nspace = tty_write_room(tty);\r\nif (!space) {\r\nmutex_unlock(&tty->output_lock);\r\nreturn 0;\r\n}\r\nif (nr > space)\r\nnr = space;\r\nfor (i = 0, cp = buf; i < nr; i++, cp++) {\r\nunsigned char c = *cp;\r\nswitch (c) {\r\ncase '\n':\r\nif (O_ONLRET(tty))\r\ntty->column = 0;\r\nif (O_ONLCR(tty))\r\ngoto break_out;\r\ntty->canon_column = tty->column;\r\nbreak;\r\ncase '\r':\r\nif (O_ONOCR(tty) && tty->column == 0)\r\ngoto break_out;\r\nif (O_OCRNL(tty))\r\ngoto break_out;\r\ntty->canon_column = tty->column = 0;\r\nbreak;\r\ncase '\t':\r\ngoto break_out;\r\ncase '\b':\r\nif (tty->column > 0)\r\ntty->column--;\r\nbreak;\r\ndefault:\r\nif (!iscntrl(c)) {\r\nif (O_OLCUC(tty))\r\ngoto break_out;\r\nif (!is_continuation(c, tty))\r\ntty->column++;\r\n}\r\nbreak;\r\n}\r\n}\r\nbreak_out:\r\ni = tty->ops->write(tty, buf, i);\r\nmutex_unlock(&tty->output_lock);\r\nreturn i;\r\n}\r\nstatic void process_echoes(struct tty_struct *tty)\r\n{\r\nint space, nr;\r\nunsigned char c;\r\nunsigned char *cp, *buf_end;\r\nif (!tty->echo_cnt)\r\nreturn;\r\nmutex_lock(&tty->output_lock);\r\nmutex_lock(&tty->echo_lock);\r\nspace = tty_write_room(tty);\r\nbuf_end = tty->echo_buf + N_TTY_BUF_SIZE;\r\ncp = tty->echo_buf + tty->echo_pos;\r\nnr = tty->echo_cnt;\r\nwhile (nr > 0) {\r\nc = *cp;\r\nif (c == ECHO_OP_START) {\r\nunsigned char op;\r\nunsigned char *opp;\r\nint no_space_left = 0;\r\nopp = cp + 1;\r\nif (opp == buf_end)\r\nopp -= N_TTY_BUF_SIZE;\r\nop = *opp;\r\nswitch (op) {\r\nunsigned int num_chars, num_bs;\r\ncase ECHO_OP_ERASE_TAB:\r\nif (++opp == buf_end)\r\nopp -= N_TTY_BUF_SIZE;\r\nnum_chars = *opp;\r\nif (!(num_chars & 0x80))\r\nnum_chars += tty->canon_column;\r\nnum_bs = 8 - (num_chars & 7);\r\nif (num_bs > space) {\r\nno_space_left = 1;\r\nbreak;\r\n}\r\nspace -= num_bs;\r\nwhile (num_bs--) {\r\ntty_put_char(tty, '\b');\r\nif (tty->column > 0)\r\ntty->column--;\r\n}\r\ncp += 3;\r\nnr -= 3;\r\nbreak;\r\ncase ECHO_OP_SET_CANON_COL:\r\ntty->canon_column = tty->column;\r\ncp += 2;\r\nnr -= 2;\r\nbreak;\r\ncase ECHO_OP_MOVE_BACK_COL:\r\nif (tty->column > 0)\r\ntty->column--;\r\ncp += 2;\r\nnr -= 2;\r\nbreak;\r\ncase ECHO_OP_START:\r\nif (!space) {\r\nno_space_left = 1;\r\nbreak;\r\n}\r\ntty_put_char(tty, ECHO_OP_START);\r\ntty->column++;\r\nspace--;\r\ncp += 2;\r\nnr -= 2;\r\nbreak;\r\ndefault:\r\nif (space < 2) {\r\nno_space_left = 1;\r\nbreak;\r\n}\r\ntty_put_char(tty, '^');\r\ntty_put_char(tty, op ^ 0100);\r\ntty->column += 2;\r\nspace -= 2;\r\ncp += 2;\r\nnr -= 2;\r\n}\r\nif (no_space_left)\r\nbreak;\r\n} else {\r\nif (O_OPOST(tty) &&\r\n!(test_bit(TTY_HW_COOK_OUT, &tty->flags))) {\r\nint retval = do_output_char(c, tty, space);\r\nif (retval < 0)\r\nbreak;\r\nspace -= retval;\r\n} else {\r\nif (!space)\r\nbreak;\r\ntty_put_char(tty, c);\r\nspace -= 1;\r\n}\r\ncp += 1;\r\nnr -= 1;\r\n}\r\nif (cp >= buf_end)\r\ncp -= N_TTY_BUF_SIZE;\r\n}\r\nif (nr == 0) {\r\ntty->echo_pos = 0;\r\ntty->echo_cnt = 0;\r\ntty->echo_overrun = 0;\r\n} else {\r\nint num_processed = tty->echo_cnt - nr;\r\ntty->echo_pos += num_processed;\r\ntty->echo_pos &= N_TTY_BUF_SIZE - 1;\r\ntty->echo_cnt = nr;\r\nif (num_processed > 0)\r\ntty->echo_overrun = 0;\r\n}\r\nmutex_unlock(&tty->echo_lock);\r\nmutex_unlock(&tty->output_lock);\r\nif (tty->ops->flush_chars)\r\ntty->ops->flush_chars(tty);\r\n}\r\nstatic void add_echo_byte(unsigned char c, struct tty_struct *tty)\r\n{\r\nint new_byte_pos;\r\nif (tty->echo_cnt == N_TTY_BUF_SIZE) {\r\nnew_byte_pos = tty->echo_pos;\r\nif (tty->echo_buf[tty->echo_pos] == ECHO_OP_START) {\r\nif (tty->echo_buf[(tty->echo_pos + 1) &\r\n(N_TTY_BUF_SIZE - 1)] ==\r\nECHO_OP_ERASE_TAB) {\r\ntty->echo_pos += 3;\r\ntty->echo_cnt -= 2;\r\n} else {\r\ntty->echo_pos += 2;\r\ntty->echo_cnt -= 1;\r\n}\r\n} else {\r\ntty->echo_pos++;\r\n}\r\ntty->echo_pos &= N_TTY_BUF_SIZE - 1;\r\ntty->echo_overrun = 1;\r\n} else {\r\nnew_byte_pos = tty->echo_pos + tty->echo_cnt;\r\nnew_byte_pos &= N_TTY_BUF_SIZE - 1;\r\ntty->echo_cnt++;\r\n}\r\ntty->echo_buf[new_byte_pos] = c;\r\n}\r\nstatic void echo_move_back_col(struct tty_struct *tty)\r\n{\r\nmutex_lock(&tty->echo_lock);\r\nadd_echo_byte(ECHO_OP_START, tty);\r\nadd_echo_byte(ECHO_OP_MOVE_BACK_COL, tty);\r\nmutex_unlock(&tty->echo_lock);\r\n}\r\nstatic void echo_set_canon_col(struct tty_struct *tty)\r\n{\r\nmutex_lock(&tty->echo_lock);\r\nadd_echo_byte(ECHO_OP_START, tty);\r\nadd_echo_byte(ECHO_OP_SET_CANON_COL, tty);\r\nmutex_unlock(&tty->echo_lock);\r\n}\r\nstatic void echo_erase_tab(unsigned int num_chars, int after_tab,\r\nstruct tty_struct *tty)\r\n{\r\nmutex_lock(&tty->echo_lock);\r\nadd_echo_byte(ECHO_OP_START, tty);\r\nadd_echo_byte(ECHO_OP_ERASE_TAB, tty);\r\nnum_chars &= 7;\r\nif (after_tab)\r\nnum_chars |= 0x80;\r\nadd_echo_byte(num_chars, tty);\r\nmutex_unlock(&tty->echo_lock);\r\n}\r\nstatic void echo_char_raw(unsigned char c, struct tty_struct *tty)\r\n{\r\nmutex_lock(&tty->echo_lock);\r\nif (c == ECHO_OP_START) {\r\nadd_echo_byte(ECHO_OP_START, tty);\r\nadd_echo_byte(ECHO_OP_START, tty);\r\n} else {\r\nadd_echo_byte(c, tty);\r\n}\r\nmutex_unlock(&tty->echo_lock);\r\n}\r\nstatic void echo_char(unsigned char c, struct tty_struct *tty)\r\n{\r\nmutex_lock(&tty->echo_lock);\r\nif (c == ECHO_OP_START) {\r\nadd_echo_byte(ECHO_OP_START, tty);\r\nadd_echo_byte(ECHO_OP_START, tty);\r\n} else {\r\nif (L_ECHOCTL(tty) && iscntrl(c) && c != '\t')\r\nadd_echo_byte(ECHO_OP_START, tty);\r\nadd_echo_byte(c, tty);\r\n}\r\nmutex_unlock(&tty->echo_lock);\r\n}\r\nstatic inline void finish_erasing(struct tty_struct *tty)\r\n{\r\nif (tty->erasing) {\r\necho_char_raw('/', tty);\r\ntty->erasing = 0;\r\n}\r\n}\r\nstatic void eraser(unsigned char c, struct tty_struct *tty)\r\n{\r\nenum { ERASE, WERASE, KILL } kill_type;\r\nint head, seen_alnums, cnt;\r\nunsigned long flags;\r\nif (tty->read_head == tty->canon_head) {\r\nreturn;\r\n}\r\nif (c == ERASE_CHAR(tty))\r\nkill_type = ERASE;\r\nelse if (c == WERASE_CHAR(tty))\r\nkill_type = WERASE;\r\nelse {\r\nif (!L_ECHO(tty)) {\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\ntty->read_cnt -= ((tty->read_head - tty->canon_head) &\r\n(N_TTY_BUF_SIZE - 1));\r\ntty->read_head = tty->canon_head;\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\nreturn;\r\n}\r\nif (!L_ECHOK(tty) || !L_ECHOKE(tty) || !L_ECHOE(tty)) {\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\ntty->read_cnt -= ((tty->read_head - tty->canon_head) &\r\n(N_TTY_BUF_SIZE - 1));\r\ntty->read_head = tty->canon_head;\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\nfinish_erasing(tty);\r\necho_char(KILL_CHAR(tty), tty);\r\nif (L_ECHOK(tty))\r\necho_char_raw('\n', tty);\r\nreturn;\r\n}\r\nkill_type = KILL;\r\n}\r\nseen_alnums = 0;\r\nwhile (tty->read_head != tty->canon_head) {\r\nhead = tty->read_head;\r\ndo {\r\nhead = (head - 1) & (N_TTY_BUF_SIZE-1);\r\nc = tty->read_buf[head];\r\n} while (is_continuation(c, tty) && head != tty->canon_head);\r\nif (is_continuation(c, tty))\r\nbreak;\r\nif (kill_type == WERASE) {\r\nif (isalnum(c) || c == '_')\r\nseen_alnums++;\r\nelse if (seen_alnums)\r\nbreak;\r\n}\r\ncnt = (tty->read_head - head) & (N_TTY_BUF_SIZE-1);\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\ntty->read_head = head;\r\ntty->read_cnt -= cnt;\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\nif (L_ECHO(tty)) {\r\nif (L_ECHOPRT(tty)) {\r\nif (!tty->erasing) {\r\necho_char_raw('\\', tty);\r\ntty->erasing = 1;\r\n}\r\necho_char(c, tty);\r\nwhile (--cnt > 0) {\r\nhead = (head+1) & (N_TTY_BUF_SIZE-1);\r\necho_char_raw(tty->read_buf[head], tty);\r\necho_move_back_col(tty);\r\n}\r\n} else if (kill_type == ERASE && !L_ECHOE(tty)) {\r\necho_char(ERASE_CHAR(tty), tty);\r\n} else if (c == '\t') {\r\nunsigned int num_chars = 0;\r\nint after_tab = 0;\r\nunsigned long tail = tty->read_head;\r\nwhile (tail != tty->canon_head) {\r\ntail = (tail-1) & (N_TTY_BUF_SIZE-1);\r\nc = tty->read_buf[tail];\r\nif (c == '\t') {\r\nafter_tab = 1;\r\nbreak;\r\n} else if (iscntrl(c)) {\r\nif (L_ECHOCTL(tty))\r\nnum_chars += 2;\r\n} else if (!is_continuation(c, tty)) {\r\nnum_chars++;\r\n}\r\n}\r\necho_erase_tab(num_chars, after_tab, tty);\r\n} else {\r\nif (iscntrl(c) && L_ECHOCTL(tty)) {\r\necho_char_raw('\b', tty);\r\necho_char_raw(' ', tty);\r\necho_char_raw('\b', tty);\r\n}\r\nif (!iscntrl(c) || L_ECHOCTL(tty)) {\r\necho_char_raw('\b', tty);\r\necho_char_raw(' ', tty);\r\necho_char_raw('\b', tty);\r\n}\r\n}\r\n}\r\nif (kill_type == ERASE)\r\nbreak;\r\n}\r\nif (tty->read_head == tty->canon_head && L_ECHO(tty))\r\nfinish_erasing(tty);\r\n}\r\nstatic inline void isig(int sig, struct tty_struct *tty, int flush)\r\n{\r\nif (tty->pgrp)\r\nkill_pgrp(tty->pgrp, sig, 1);\r\nif (flush || !L_NOFLSH(tty)) {\r\nn_tty_flush_buffer(tty);\r\ntty_driver_flush_buffer(tty);\r\n}\r\n}\r\nstatic inline void n_tty_receive_break(struct tty_struct *tty)\r\n{\r\nif (I_IGNBRK(tty))\r\nreturn;\r\nif (I_BRKINT(tty)) {\r\nisig(SIGINT, tty, 1);\r\nreturn;\r\n}\r\nif (I_PARMRK(tty)) {\r\nput_tty_queue('\377', tty);\r\nput_tty_queue('\0', tty);\r\n}\r\nput_tty_queue('\0', tty);\r\nwake_up_interruptible(&tty->read_wait);\r\n}\r\nstatic inline void n_tty_receive_overrun(struct tty_struct *tty)\r\n{\r\nchar buf[64];\r\ntty->num_overrun++;\r\nif (time_before(tty->overrun_time, jiffies - HZ) ||\r\ntime_after(tty->overrun_time, jiffies)) {\r\nprintk(KERN_WARNING "%s: %d input overrun(s)\n",\r\ntty_name(tty, buf),\r\ntty->num_overrun);\r\ntty->overrun_time = jiffies;\r\ntty->num_overrun = 0;\r\n}\r\n}\r\nstatic inline void n_tty_receive_parity_error(struct tty_struct *tty,\r\nunsigned char c)\r\n{\r\nif (I_IGNPAR(tty))\r\nreturn;\r\nif (I_PARMRK(tty)) {\r\nput_tty_queue('\377', tty);\r\nput_tty_queue('\0', tty);\r\nput_tty_queue(c, tty);\r\n} else if (I_INPCK(tty))\r\nput_tty_queue('\0', tty);\r\nelse\r\nput_tty_queue(c, tty);\r\nwake_up_interruptible(&tty->read_wait);\r\n}\r\nstatic inline void n_tty_receive_char(struct tty_struct *tty, unsigned char c)\r\n{\r\nunsigned long flags;\r\nint parmrk;\r\nif (tty->raw) {\r\nput_tty_queue(c, tty);\r\nreturn;\r\n}\r\nif (I_ISTRIP(tty))\r\nc &= 0x7f;\r\nif (I_IUCLC(tty) && L_IEXTEN(tty))\r\nc = tolower(c);\r\nif (L_EXTPROC(tty)) {\r\nput_tty_queue(c, tty);\r\nreturn;\r\n}\r\nif (tty->stopped && !tty->flow_stopped && I_IXON(tty) &&\r\nI_IXANY(tty) && c != START_CHAR(tty) && c != STOP_CHAR(tty) &&\r\nc != INTR_CHAR(tty) && c != QUIT_CHAR(tty) && c != SUSP_CHAR(tty)) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\n}\r\nif (tty->closing) {\r\nif (I_IXON(tty)) {\r\nif (c == START_CHAR(tty)) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\n} else if (c == STOP_CHAR(tty))\r\nstop_tty(tty);\r\n}\r\nreturn;\r\n}\r\nif (!test_bit(c, tty->process_char_map) || tty->lnext) {\r\ntty->lnext = 0;\r\nparmrk = (c == (unsigned char) '\377' && I_PARMRK(tty)) ? 1 : 0;\r\nif (tty->read_cnt >= (N_TTY_BUF_SIZE - parmrk - 1)) {\r\nif (L_ECHO(tty))\r\nprocess_output('\a', tty);\r\nreturn;\r\n}\r\nif (L_ECHO(tty)) {\r\nfinish_erasing(tty);\r\nif (tty->canon_head == tty->read_head)\r\necho_set_canon_col(tty);\r\necho_char(c, tty);\r\nprocess_echoes(tty);\r\n}\r\nif (parmrk)\r\nput_tty_queue(c, tty);\r\nput_tty_queue(c, tty);\r\nreturn;\r\n}\r\nif (I_IXON(tty)) {\r\nif (c == START_CHAR(tty)) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\nreturn;\r\n}\r\nif (c == STOP_CHAR(tty)) {\r\nstop_tty(tty);\r\nreturn;\r\n}\r\n}\r\nif (L_ISIG(tty)) {\r\nint signal;\r\nsignal = SIGINT;\r\nif (c == INTR_CHAR(tty))\r\ngoto send_signal;\r\nsignal = SIGQUIT;\r\nif (c == QUIT_CHAR(tty))\r\ngoto send_signal;\r\nsignal = SIGTSTP;\r\nif (c == SUSP_CHAR(tty)) {\r\nsend_signal:\r\nif (!L_NOFLSH(tty)) {\r\nn_tty_flush_buffer(tty);\r\ntty_driver_flush_buffer(tty);\r\n}\r\nif (I_IXON(tty))\r\nstart_tty(tty);\r\nif (L_ECHO(tty)) {\r\necho_char(c, tty);\r\nprocess_echoes(tty);\r\n}\r\nif (tty->pgrp)\r\nkill_pgrp(tty->pgrp, signal, 1);\r\nreturn;\r\n}\r\n}\r\nif (c == '\r') {\r\nif (I_IGNCR(tty))\r\nreturn;\r\nif (I_ICRNL(tty))\r\nc = '\n';\r\n} else if (c == '\n' && I_INLCR(tty))\r\nc = '\r';\r\nif (tty->icanon) {\r\nif (c == ERASE_CHAR(tty) || c == KILL_CHAR(tty) ||\r\n(c == WERASE_CHAR(tty) && L_IEXTEN(tty))) {\r\neraser(c, tty);\r\nprocess_echoes(tty);\r\nreturn;\r\n}\r\nif (c == LNEXT_CHAR(tty) && L_IEXTEN(tty)) {\r\ntty->lnext = 1;\r\nif (L_ECHO(tty)) {\r\nfinish_erasing(tty);\r\nif (L_ECHOCTL(tty)) {\r\necho_char_raw('^', tty);\r\necho_char_raw('\b', tty);\r\nprocess_echoes(tty);\r\n}\r\n}\r\nreturn;\r\n}\r\nif (c == REPRINT_CHAR(tty) && L_ECHO(tty) &&\r\nL_IEXTEN(tty)) {\r\nunsigned long tail = tty->canon_head;\r\nfinish_erasing(tty);\r\necho_char(c, tty);\r\necho_char_raw('\n', tty);\r\nwhile (tail != tty->read_head) {\r\necho_char(tty->read_buf[tail], tty);\r\ntail = (tail+1) & (N_TTY_BUF_SIZE-1);\r\n}\r\nprocess_echoes(tty);\r\nreturn;\r\n}\r\nif (c == '\n') {\r\nif (tty->read_cnt >= N_TTY_BUF_SIZE) {\r\nif (L_ECHO(tty))\r\nprocess_output('\a', tty);\r\nreturn;\r\n}\r\nif (L_ECHO(tty) || L_ECHONL(tty)) {\r\necho_char_raw('\n', tty);\r\nprocess_echoes(tty);\r\n}\r\ngoto handle_newline;\r\n}\r\nif (c == EOF_CHAR(tty)) {\r\nif (tty->read_cnt >= N_TTY_BUF_SIZE)\r\nreturn;\r\nif (tty->canon_head != tty->read_head)\r\nset_bit(TTY_PUSH, &tty->flags);\r\nc = __DISABLED_CHAR;\r\ngoto handle_newline;\r\n}\r\nif ((c == EOL_CHAR(tty)) ||\r\n(c == EOL2_CHAR(tty) && L_IEXTEN(tty))) {\r\nparmrk = (c == (unsigned char) '\377' && I_PARMRK(tty))\r\n? 1 : 0;\r\nif (tty->read_cnt >= (N_TTY_BUF_SIZE - parmrk)) {\r\nif (L_ECHO(tty))\r\nprocess_output('\a', tty);\r\nreturn;\r\n}\r\nif (L_ECHO(tty)) {\r\nif (tty->canon_head == tty->read_head)\r\necho_set_canon_col(tty);\r\necho_char(c, tty);\r\nprocess_echoes(tty);\r\n}\r\nif (parmrk)\r\nput_tty_queue(c, tty);\r\nhandle_newline:\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\nset_bit(tty->read_head, tty->read_flags);\r\nput_tty_queue_nolock(c, tty);\r\ntty->canon_head = tty->read_head;\r\ntty->canon_data++;\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\nkill_fasync(&tty->fasync, SIGIO, POLL_IN);\r\nif (waitqueue_active(&tty->read_wait))\r\nwake_up_interruptible(&tty->read_wait);\r\nreturn;\r\n}\r\n}\r\nparmrk = (c == (unsigned char) '\377' && I_PARMRK(tty)) ? 1 : 0;\r\nif (tty->read_cnt >= (N_TTY_BUF_SIZE - parmrk - 1)) {\r\nif (L_ECHO(tty))\r\nprocess_output('\a', tty);\r\nreturn;\r\n}\r\nif (L_ECHO(tty)) {\r\nfinish_erasing(tty);\r\nif (c == '\n')\r\necho_char_raw('\n', tty);\r\nelse {\r\nif (tty->canon_head == tty->read_head)\r\necho_set_canon_col(tty);\r\necho_char(c, tty);\r\n}\r\nprocess_echoes(tty);\r\n}\r\nif (parmrk)\r\nput_tty_queue(c, tty);\r\nput_tty_queue(c, tty);\r\n}\r\nstatic void n_tty_write_wakeup(struct tty_struct *tty)\r\n{\r\nif (tty->fasync && test_and_clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags))\r\nkill_fasync(&tty->fasync, SIGIO, POLL_OUT);\r\n}\r\nstatic void n_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nconst unsigned char *p;\r\nchar *f, flags = TTY_NORMAL;\r\nint i;\r\nchar buf[64];\r\nunsigned long cpuflags;\r\nif (!tty->read_buf)\r\nreturn;\r\nif (tty->real_raw) {\r\nspin_lock_irqsave(&tty->read_lock, cpuflags);\r\ni = min(N_TTY_BUF_SIZE - tty->read_cnt,\r\nN_TTY_BUF_SIZE - tty->read_head);\r\ni = min(count, i);\r\nmemcpy(tty->read_buf + tty->read_head, cp, i);\r\ntty->read_head = (tty->read_head + i) & (N_TTY_BUF_SIZE-1);\r\ntty->read_cnt += i;\r\ncp += i;\r\ncount -= i;\r\ni = min(N_TTY_BUF_SIZE - tty->read_cnt,\r\nN_TTY_BUF_SIZE - tty->read_head);\r\ni = min(count, i);\r\nmemcpy(tty->read_buf + tty->read_head, cp, i);\r\ntty->read_head = (tty->read_head + i) & (N_TTY_BUF_SIZE-1);\r\ntty->read_cnt += i;\r\nspin_unlock_irqrestore(&tty->read_lock, cpuflags);\r\n} else {\r\nfor (i = count, p = cp, f = fp; i; i--, p++) {\r\nif (f)\r\nflags = *f++;\r\nswitch (flags) {\r\ncase TTY_NORMAL:\r\nn_tty_receive_char(tty, *p);\r\nbreak;\r\ncase TTY_BREAK:\r\nn_tty_receive_break(tty);\r\nbreak;\r\ncase TTY_PARITY:\r\ncase TTY_FRAME:\r\nn_tty_receive_parity_error(tty, *p);\r\nbreak;\r\ncase TTY_OVERRUN:\r\nn_tty_receive_overrun(tty);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: unknown flag %d\n",\r\ntty_name(tty, buf), flags);\r\nbreak;\r\n}\r\n}\r\nif (tty->ops->flush_chars)\r\ntty->ops->flush_chars(tty);\r\n}\r\nn_tty_set_room(tty);\r\nif ((!tty->icanon && (tty->read_cnt >= tty->minimum_to_wake)) ||\r\nL_EXTPROC(tty)) {\r\nkill_fasync(&tty->fasync, SIGIO, POLL_IN);\r\nif (waitqueue_active(&tty->read_wait))\r\nwake_up_interruptible(&tty->read_wait);\r\n}\r\nif (tty->receive_room < TTY_THRESHOLD_THROTTLE)\r\ntty_throttle(tty);\r\n}\r\nint is_ignored(int sig)\r\n{\r\nreturn (sigismember(&current->blocked, sig) ||\r\ncurrent->sighand->action[sig-1].sa.sa_handler == SIG_IGN);\r\n}\r\nstatic void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\nint canon_change = 1;\r\nBUG_ON(!tty);\r\nif (old)\r\ncanon_change = (old->c_lflag ^ tty->termios->c_lflag) & ICANON;\r\nif (canon_change) {\r\nmemset(&tty->read_flags, 0, sizeof tty->read_flags);\r\ntty->canon_head = tty->read_tail;\r\ntty->canon_data = 0;\r\ntty->erasing = 0;\r\n}\r\nif (canon_change && !L_ICANON(tty) && tty->read_cnt)\r\nwake_up_interruptible(&tty->read_wait);\r\ntty->icanon = (L_ICANON(tty) != 0);\r\nif (test_bit(TTY_HW_COOK_IN, &tty->flags)) {\r\ntty->raw = 1;\r\ntty->real_raw = 1;\r\nn_tty_set_room(tty);\r\nreturn;\r\n}\r\nif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\r\nI_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\r\nI_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\r\nI_PARMRK(tty)) {\r\nmemset(tty->process_char_map, 0, 256/8);\r\nif (I_IGNCR(tty) || I_ICRNL(tty))\r\nset_bit('\r', tty->process_char_map);\r\nif (I_INLCR(tty))\r\nset_bit('\n', tty->process_char_map);\r\nif (L_ICANON(tty)) {\r\nset_bit(ERASE_CHAR(tty), tty->process_char_map);\r\nset_bit(KILL_CHAR(tty), tty->process_char_map);\r\nset_bit(EOF_CHAR(tty), tty->process_char_map);\r\nset_bit('\n', tty->process_char_map);\r\nset_bit(EOL_CHAR(tty), tty->process_char_map);\r\nif (L_IEXTEN(tty)) {\r\nset_bit(WERASE_CHAR(tty),\r\ntty->process_char_map);\r\nset_bit(LNEXT_CHAR(tty),\r\ntty->process_char_map);\r\nset_bit(EOL2_CHAR(tty),\r\ntty->process_char_map);\r\nif (L_ECHO(tty))\r\nset_bit(REPRINT_CHAR(tty),\r\ntty->process_char_map);\r\n}\r\n}\r\nif (I_IXON(tty)) {\r\nset_bit(START_CHAR(tty), tty->process_char_map);\r\nset_bit(STOP_CHAR(tty), tty->process_char_map);\r\n}\r\nif (L_ISIG(tty)) {\r\nset_bit(INTR_CHAR(tty), tty->process_char_map);\r\nset_bit(QUIT_CHAR(tty), tty->process_char_map);\r\nset_bit(SUSP_CHAR(tty), tty->process_char_map);\r\n}\r\nclear_bit(__DISABLED_CHAR, tty->process_char_map);\r\ntty->raw = 0;\r\ntty->real_raw = 0;\r\n} else {\r\ntty->raw = 1;\r\nif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\r\n(I_IGNPAR(tty) || !I_INPCK(tty)) &&\r\n(tty->driver->flags & TTY_DRIVER_REAL_RAW))\r\ntty->real_raw = 1;\r\nelse\r\ntty->real_raw = 0;\r\n}\r\nn_tty_set_room(tty);\r\nwake_up_interruptible(&tty->write_wait);\r\nwake_up_interruptible(&tty->read_wait);\r\n}\r\nstatic void n_tty_close(struct tty_struct *tty)\r\n{\r\nn_tty_flush_buffer(tty);\r\nif (tty->read_buf) {\r\nkfree(tty->read_buf);\r\ntty->read_buf = NULL;\r\n}\r\nif (tty->echo_buf) {\r\nkfree(tty->echo_buf);\r\ntty->echo_buf = NULL;\r\n}\r\n}\r\nstatic int n_tty_open(struct tty_struct *tty)\r\n{\r\nif (!tty)\r\nreturn -EINVAL;\r\nif (!tty->read_buf) {\r\ntty->read_buf = kzalloc(N_TTY_BUF_SIZE, GFP_KERNEL);\r\nif (!tty->read_buf)\r\nreturn -ENOMEM;\r\n}\r\nif (!tty->echo_buf) {\r\ntty->echo_buf = kzalloc(N_TTY_BUF_SIZE, GFP_KERNEL);\r\nif (!tty->echo_buf)\r\nreturn -ENOMEM;\r\n}\r\nreset_buffer_flags(tty);\r\ntty_unthrottle(tty);\r\ntty->column = 0;\r\nn_tty_set_termios(tty, NULL);\r\ntty->minimum_to_wake = 1;\r\ntty->closing = 0;\r\nreturn 0;\r\n}\r\nstatic inline int input_available_p(struct tty_struct *tty, int amt)\r\n{\r\ntty_flush_to_ldisc(tty);\r\nif (tty->icanon && !L_EXTPROC(tty)) {\r\nif (tty->canon_data)\r\nreturn 1;\r\n} else if (tty->read_cnt >= (amt ? amt : 1))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int copy_from_read_buf(struct tty_struct *tty,\r\nunsigned char __user **b,\r\nsize_t *nr)\r\n{\r\nint retval;\r\nsize_t n;\r\nunsigned long flags;\r\nbool is_eof;\r\nretval = 0;\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\nn = min(tty->read_cnt, N_TTY_BUF_SIZE - tty->read_tail);\r\nn = min(*nr, n);\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\nif (n) {\r\nretval = copy_to_user(*b, &tty->read_buf[tty->read_tail], n);\r\nn -= retval;\r\nis_eof = n == 1 &&\r\ntty->read_buf[tty->read_tail] == EOF_CHAR(tty);\r\ntty_audit_add_data(tty, &tty->read_buf[tty->read_tail], n);\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\ntty->read_tail = (tty->read_tail + n) & (N_TTY_BUF_SIZE-1);\r\ntty->read_cnt -= n;\r\nif (L_EXTPROC(tty) && tty->icanon && is_eof && !tty->read_cnt)\r\nn = 0;\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\n*b += n;\r\n*nr -= n;\r\n}\r\nreturn retval;\r\n}\r\nstatic int job_control(struct tty_struct *tty, struct file *file)\r\n{\r\nif (file->f_op->write != redirected_tty_write &&\r\ncurrent->signal->tty == tty) {\r\nif (!tty->pgrp)\r\nprintk(KERN_ERR "n_tty_read: no tty->pgrp!\n");\r\nelse if (task_pgrp(current) != tty->pgrp) {\r\nif (is_ignored(SIGTTIN) ||\r\nis_current_pgrp_orphaned())\r\nreturn -EIO;\r\nkill_pgrp(task_pgrp(current), SIGTTIN, 1);\r\nset_thread_flag(TIF_SIGPENDING);\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\r\nunsigned char __user *buf, size_t nr)\r\n{\r\nunsigned char __user *b = buf;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint c;\r\nint minimum, time;\r\nssize_t retval = 0;\r\nssize_t size;\r\nlong timeout;\r\nunsigned long flags;\r\nint packet;\r\ndo_it_again:\r\nBUG_ON(!tty->read_buf);\r\nc = job_control(tty, file);\r\nif (c < 0)\r\nreturn c;\r\nminimum = time = 0;\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\nif (!tty->icanon) {\r\ntime = (HZ / 10) * TIME_CHAR(tty);\r\nminimum = MIN_CHAR(tty);\r\nif (minimum) {\r\nif (time)\r\ntty->minimum_to_wake = 1;\r\nelse if (!waitqueue_active(&tty->read_wait) ||\r\n(tty->minimum_to_wake > minimum))\r\ntty->minimum_to_wake = minimum;\r\n} else {\r\ntimeout = 0;\r\nif (time) {\r\ntimeout = time;\r\ntime = 0;\r\n}\r\ntty->minimum_to_wake = minimum = 1;\r\n}\r\n}\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (!mutex_trylock(&tty->atomic_read_lock))\r\nreturn -EAGAIN;\r\n} else {\r\nif (mutex_lock_interruptible(&tty->atomic_read_lock))\r\nreturn -ERESTARTSYS;\r\n}\r\npacket = tty->packet;\r\nadd_wait_queue(&tty->read_wait, &wait);\r\nwhile (nr) {\r\nif (packet && tty->link->ctrl_status) {\r\nunsigned char cs;\r\nif (b != buf)\r\nbreak;\r\nspin_lock_irqsave(&tty->link->ctrl_lock, flags);\r\ncs = tty->link->ctrl_status;\r\ntty->link->ctrl_status = 0;\r\nspin_unlock_irqrestore(&tty->link->ctrl_lock, flags);\r\nif (tty_put_user(tty, cs, b++)) {\r\nretval = -EFAULT;\r\nb--;\r\nbreak;\r\n}\r\nnr--;\r\nbreak;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (((minimum - (b - buf)) < tty->minimum_to_wake) &&\r\n((minimum - (b - buf)) >= 1))\r\ntty->minimum_to_wake = (minimum - (b - buf));\r\nif (!input_available_p(tty, 0)) {\r\nif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nif (tty_hung_up_p(file))\r\nbreak;\r\nif (!timeout)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nn_tty_set_room(tty);\r\ntimeout = schedule_timeout(timeout);\r\nBUG_ON(!tty->read_buf);\r\ncontinue;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nif (packet && b == buf) {\r\nif (tty_put_user(tty, TIOCPKT_DATA, b++)) {\r\nretval = -EFAULT;\r\nb--;\r\nbreak;\r\n}\r\nnr--;\r\n}\r\nif (tty->icanon && !L_EXTPROC(tty)) {\r\nwhile (nr && tty->read_cnt) {\r\nint eol;\r\neol = test_and_clear_bit(tty->read_tail,\r\ntty->read_flags);\r\nc = tty->read_buf[tty->read_tail];\r\nspin_lock_irqsave(&tty->read_lock, flags);\r\ntty->read_tail = ((tty->read_tail+1) &\r\n(N_TTY_BUF_SIZE-1));\r\ntty->read_cnt--;\r\nif (eol) {\r\nif (--tty->canon_data < 0)\r\ntty->canon_data = 0;\r\n}\r\nspin_unlock_irqrestore(&tty->read_lock, flags);\r\nif (!eol || (c != __DISABLED_CHAR)) {\r\nif (tty_put_user(tty, c, b++)) {\r\nretval = -EFAULT;\r\nb--;\r\nbreak;\r\n}\r\nnr--;\r\n}\r\nif (eol) {\r\ntty_audit_push(tty);\r\nbreak;\r\n}\r\n}\r\nif (retval)\r\nbreak;\r\n} else {\r\nint uncopied;\r\nuncopied = copy_from_read_buf(tty, &b, &nr);\r\nuncopied += copy_from_read_buf(tty, &b, &nr);\r\nif (uncopied) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nif (n_tty_chars_in_buffer(tty) <= TTY_THRESHOLD_UNTHROTTLE) {\r\nn_tty_set_room(tty);\r\ncheck_unthrottle(tty);\r\n}\r\nif (b - buf >= minimum)\r\nbreak;\r\nif (time)\r\ntimeout = time;\r\n}\r\nmutex_unlock(&tty->atomic_read_lock);\r\nremove_wait_queue(&tty->read_wait, &wait);\r\nif (!waitqueue_active(&tty->read_wait))\r\ntty->minimum_to_wake = minimum;\r\n__set_current_state(TASK_RUNNING);\r\nsize = b - buf;\r\nif (size) {\r\nretval = size;\r\nif (nr)\r\nclear_bit(TTY_PUSH, &tty->flags);\r\n} else if (test_and_clear_bit(TTY_PUSH, &tty->flags))\r\ngoto do_it_again;\r\nn_tty_set_room(tty);\r\nreturn retval;\r\n}\r\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *buf, size_t nr)\r\n{\r\nconst unsigned char *b = buf;\r\nDECLARE_WAITQUEUE(wait, current);\r\nint c;\r\nssize_t retval = 0;\r\nif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\n}\r\nprocess_echoes(tty);\r\nadd_wait_queue(&tty->write_wait, &wait);\r\nwhile (1) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nif (O_OPOST(tty) && !(test_bit(TTY_HW_COOK_OUT, &tty->flags))) {\r\nwhile (nr > 0) {\r\nssize_t num = process_output_block(tty, b, nr);\r\nif (num < 0) {\r\nif (num == -EAGAIN)\r\nbreak;\r\nretval = num;\r\ngoto break_out;\r\n}\r\nb += num;\r\nnr -= num;\r\nif (nr == 0)\r\nbreak;\r\nc = *b;\r\nif (process_output(c, tty) < 0)\r\nbreak;\r\nb++; nr--;\r\n}\r\nif (tty->ops->flush_chars)\r\ntty->ops->flush_chars(tty);\r\n} else {\r\nwhile (nr > 0) {\r\nc = tty->ops->write(tty, b, nr);\r\nif (c < 0) {\r\nretval = c;\r\ngoto break_out;\r\n}\r\nif (!c)\r\nbreak;\r\nb += c;\r\nnr -= c;\r\n}\r\n}\r\nif (!nr)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nbreak_out:\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&tty->write_wait, &wait);\r\nif (b - buf != nr && tty->fasync)\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nreturn (b - buf) ? b - buf : retval;\r\n}\r\nstatic unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,\r\npoll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\npoll_wait(file, &tty->read_wait, wait);\r\npoll_wait(file, &tty->write_wait, wait);\r\nif (input_available_p(tty, TIME_CHAR(tty) ? 0 : MIN_CHAR(tty)))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (tty->packet && tty->link->ctrl_status)\r\nmask |= POLLPRI | POLLIN | POLLRDNORM;\r\nif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\r\nmask |= POLLHUP;\r\nif (tty_hung_up_p(file))\r\nmask |= POLLHUP;\r\nif (!(mask & (POLLHUP | POLLIN | POLLRDNORM))) {\r\nif (MIN_CHAR(tty) && !TIME_CHAR(tty))\r\ntty->minimum_to_wake = MIN_CHAR(tty);\r\nelse\r\ntty->minimum_to_wake = 1;\r\n}\r\nif (tty->ops->write && !tty_is_writelocked(tty) &&\r\ntty_chars_in_buffer(tty) < WAKEUP_CHARS &&\r\ntty_write_room(tty) > 0)\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic unsigned long inq_canon(struct tty_struct *tty)\r\n{\r\nint nr, head, tail;\r\nif (!tty->canon_data)\r\nreturn 0;\r\nhead = tty->canon_head;\r\ntail = tty->read_tail;\r\nnr = (head - tail) & (N_TTY_BUF_SIZE-1);\r\nwhile (head != tail) {\r\nif (test_bit(tail, tty->read_flags) &&\r\ntty->read_buf[tail] == __DISABLED_CHAR)\r\nnr--;\r\ntail = (tail+1) & (N_TTY_BUF_SIZE-1);\r\n}\r\nreturn nr;\r\n}\r\nstatic int n_tty_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint retval;\r\nswitch (cmd) {\r\ncase TIOCOUTQ:\r\nreturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\r\ncase TIOCINQ:\r\nretval = tty->read_cnt;\r\nif (L_ICANON(tty))\r\nretval = inq_canon(tty);\r\nreturn put_user(retval, (unsigned int __user *) arg);\r\ndefault:\r\nreturn n_tty_ioctl_helper(tty, file, cmd, arg);\r\n}\r\n}\r\nvoid n_tty_inherit_ops(struct tty_ldisc_ops *ops)\r\n{\r\n*ops = tty_ldisc_N_TTY;\r\nops->owner = NULL;\r\nops->refcount = ops->flags = 0;\r\n}
