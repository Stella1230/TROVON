static int hvterm_raw_get_chars(uint32_t vtermno, char *buf, int count)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[vtermno];\r\nunsigned long i;\r\nunsigned long flags;\r\nint got;\r\nif (WARN_ON(!pv))\r\nreturn 0;\r\nspin_lock_irqsave(&pv->buf_lock, flags);\r\nif (pv->left == 0) {\r\npv->offset = 0;\r\npv->left = hvc_get_chars(pv->termno, pv->buf, count);\r\nfor (i = 1; i < pv->left; ++i) {\r\nif (pv->buf[i] == 0 && pv->buf[i-1] == '\r') {\r\n--pv->left;\r\nif (i < pv->left) {\r\nmemmove(&pv->buf[i], &pv->buf[i+1],\r\npv->left - i);\r\n}\r\n}\r\n}\r\n}\r\ngot = min(count, pv->left);\r\nmemcpy(buf, &pv->buf[pv->offset], got);\r\npv->offset += got;\r\npv->left -= got;\r\nspin_unlock_irqrestore(&pv->buf_lock, flags);\r\nreturn got;\r\n}\r\nstatic int hvterm_raw_put_chars(uint32_t vtermno, const char *buf, int count)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[vtermno];\r\nif (WARN_ON(!pv))\r\nreturn 0;\r\nreturn hvc_put_chars(pv->termno, buf, count);\r\n}\r\nstatic int hvterm_hvsi_get_chars(uint32_t vtermno, char *buf, int count)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[vtermno];\r\nif (WARN_ON(!pv))\r\nreturn 0;\r\nreturn hvsilib_get_chars(&pv->hvsi, buf, count);\r\n}\r\nstatic int hvterm_hvsi_put_chars(uint32_t vtermno, const char *buf, int count)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[vtermno];\r\nif (WARN_ON(!pv))\r\nreturn 0;\r\nreturn hvsilib_put_chars(&pv->hvsi, buf, count);\r\n}\r\nstatic int hvterm_hvsi_open(struct hvc_struct *hp, int data)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\r\nint rc;\r\npr_devel("HVSI@%x: open !\n", pv->termno);\r\nrc = notifier_add_irq(hp, data);\r\nif (rc)\r\nreturn rc;\r\nreturn hvsilib_open(&pv->hvsi, hp);\r\n}\r\nstatic void hvterm_hvsi_close(struct hvc_struct *hp, int data)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\r\npr_devel("HVSI@%x: do close !\n", pv->termno);\r\nhvsilib_close(&pv->hvsi, hp);\r\nnotifier_del_irq(hp, data);\r\n}\r\nvoid hvterm_hvsi_hangup(struct hvc_struct *hp, int data)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\r\npr_devel("HVSI@%x: do hangup !\n", pv->termno);\r\nhvsilib_close(&pv->hvsi, hp);\r\nnotifier_hangup_irq(hp, data);\r\n}\r\nstatic int hvterm_hvsi_tiocmget(struct hvc_struct *hp)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\r\nif (!pv)\r\nreturn -EINVAL;\r\nreturn pv->hvsi.mctrl;\r\n}\r\nstatic int hvterm_hvsi_tiocmset(struct hvc_struct *hp, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct hvterm_priv *pv = hvterm_privs[hp->vtermno];\r\npr_devel("HVSI@%x: Set modem control, set=%x,clr=%x\n",\r\npv->termno, set, clear);\r\nif (set & TIOCM_DTR)\r\nhvsilib_write_mctrl(&pv->hvsi, 1);\r\nelse if (clear & TIOCM_DTR)\r\nhvsilib_write_mctrl(&pv->hvsi, 0);\r\nreturn 0;\r\n}\r\nstatic int __devinit hvc_vio_probe(struct vio_dev *vdev,\r\nconst struct vio_device_id *id)\r\n{\r\nconst struct hv_ops *ops;\r\nstruct hvc_struct *hp;\r\nstruct hvterm_priv *pv;\r\nhv_protocol_t proto;\r\nint i, termno = -1;\r\nif (!vdev || !id)\r\nreturn -EPERM;\r\nif (of_device_is_compatible(vdev->dev.of_node, "hvterm1")) {\r\nproto = HV_PROTOCOL_RAW;\r\nops = &hvterm_raw_ops;\r\n} else if (of_device_is_compatible(vdev->dev.of_node, "hvterm-protocol")) {\r\nproto = HV_PROTOCOL_HVSI;\r\nops = &hvterm_hvsi_ops;\r\n} else {\r\npr_err("hvc_vio: Unkown protocol for %s\n", vdev->dev.of_node->full_name);\r\nreturn -ENXIO;\r\n}\r\npr_devel("hvc_vio_probe() device %s, using %s protocol\n",\r\nvdev->dev.of_node->full_name,\r\nproto == HV_PROTOCOL_RAW ? "raw" : "hvsi");\r\nif (hvterm_privs[0] == &hvterm_priv0 &&\r\nvdev->unit_address == hvterm_priv0.termno) {\r\npv = hvterm_privs[0];\r\ntermno = 0;\r\npr_devel("->boot console, using termno 0\n");\r\n}\r\nelse {\r\nfor (i = 0; i < MAX_NR_HVC_CONSOLES && termno < 0; i++)\r\nif (!hvterm_privs[i])\r\ntermno = i;\r\npr_devel("->non-boot console, using termno %d\n", termno);\r\nif (termno < 0)\r\nreturn -ENODEV;\r\npv = kzalloc(sizeof(struct hvterm_priv), GFP_KERNEL);\r\nif (!pv)\r\nreturn -ENOMEM;\r\npv->termno = vdev->unit_address;\r\npv->proto = proto;\r\nspin_lock_init(&pv->buf_lock);\r\nhvterm_privs[termno] = pv;\r\nhvsilib_init(&pv->hvsi, hvc_get_chars, hvc_put_chars,\r\npv->termno, 0);\r\n}\r\nhp = hvc_alloc(termno, vdev->irq, ops, MAX_VIO_PUT_CHARS);\r\nif (IS_ERR(hp))\r\nreturn PTR_ERR(hp);\r\ndev_set_drvdata(&vdev->dev, hp);\r\nreturn 0;\r\n}\r\nstatic int __devexit hvc_vio_remove(struct vio_dev *vdev)\r\n{\r\nstruct hvc_struct *hp = dev_get_drvdata(&vdev->dev);\r\nint rc, termno;\r\ntermno = hp->vtermno;\r\nrc = hvc_remove(hp);\r\nif (rc == 0) {\r\nif (hvterm_privs[termno] != &hvterm_priv0)\r\nkfree(hvterm_privs[termno]);\r\nhvterm_privs[termno] = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init hvc_vio_init(void)\r\n{\r\nint rc;\r\nrc = vio_register_driver(&hvc_vio_driver);\r\nreturn rc;\r\n}\r\nstatic void __exit hvc_vio_exit(void)\r\n{\r\nvio_unregister_driver(&hvc_vio_driver);\r\n}\r\nstatic void udbg_hvc_putc(char c)\r\n{\r\nint count = -1;\r\nif (c == '\n')\r\nudbg_hvc_putc('\r');\r\ndo {\r\nswitch(hvterm_priv0.proto) {\r\ncase HV_PROTOCOL_RAW:\r\ncount = hvterm_raw_put_chars(0, &c, 1);\r\nbreak;\r\ncase HV_PROTOCOL_HVSI:\r\ncount = hvterm_hvsi_put_chars(0, &c, 1);\r\nbreak;\r\n}\r\n} while(count == 0);\r\n}\r\nstatic int udbg_hvc_getc_poll(void)\r\n{\r\nint rc = 0;\r\nchar c;\r\nswitch(hvterm_priv0.proto) {\r\ncase HV_PROTOCOL_RAW:\r\nrc = hvterm_raw_get_chars(0, &c, 1);\r\nbreak;\r\ncase HV_PROTOCOL_HVSI:\r\nrc = hvterm_hvsi_get_chars(0, &c, 1);\r\nbreak;\r\n}\r\nif (!rc)\r\nreturn -1;\r\nreturn c;\r\n}\r\nstatic int udbg_hvc_getc(void)\r\n{\r\nint ch;\r\nfor (;;) {\r\nch = udbg_hvc_getc_poll();\r\nif (ch == -1) {\r\nvolatile unsigned long delay;\r\nfor (delay=0; delay < 2000000; delay++)\r\n;\r\n} else {\r\nreturn ch;\r\n}\r\n}\r\n}\r\nvoid __init hvc_vio_init_early(void)\r\n{\r\nstruct device_node *stdout_node;\r\nconst u32 *termno;\r\nconst char *name;\r\nconst struct hv_ops *ops;\r\nif (!of_chosen)\r\nreturn;\r\nname = of_get_property(of_chosen, "linux,stdout-path", NULL);\r\nif (name == NULL)\r\nreturn;\r\nstdout_node = of_find_node_by_path(name);\r\nif (!stdout_node)\r\nreturn;\r\nname = of_get_property(stdout_node, "name", NULL);\r\nif (!name) {\r\nprintk(KERN_WARNING "stdout node missing 'name' property!\n");\r\ngoto out;\r\n}\r\nif (strncmp(name, "vty", 3) != 0)\r\ngoto out;\r\ntermno = of_get_property(stdout_node, "reg", NULL);\r\nif (termno == NULL)\r\ngoto out;\r\nhvterm_priv0.termno = *termno;\r\nspin_lock_init(&hvterm_priv0.buf_lock);\r\nhvterm_privs[0] = &hvterm_priv0;\r\nif (of_device_is_compatible(stdout_node, "hvterm1")) {\r\nhvterm_priv0.proto = HV_PROTOCOL_RAW;\r\nops = &hvterm_raw_ops;\r\n}\r\nelse if (of_device_is_compatible(stdout_node, "hvterm-protocol")) {\r\nhvterm_priv0.proto = HV_PROTOCOL_HVSI;\r\nops = &hvterm_hvsi_ops;\r\nhvsilib_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,\r\nhvterm_priv0.termno, 1);\r\nhvsilib_establish(&hvterm_priv0.hvsi);\r\n} else\r\ngoto out;\r\nudbg_putc = udbg_hvc_putc;\r\nudbg_getc = udbg_hvc_getc;\r\nudbg_getc_poll = udbg_hvc_getc_poll;\r\n#ifdef HVC_OLD_HVSI\r\nif (hvterm_priv0.proto == HV_PROTOCOL_HVSI)\r\ngoto out;\r\n#endif\r\nadd_preferred_console("hvc", 0, NULL);\r\nhvc_instantiate(0, 0, ops);\r\nout:\r\nof_node_put(stdout_node);\r\n}\r\nvoid __init udbg_init_debug_lpar(void)\r\n{\r\nhvterm_privs[0] = &hvterm_priv0;\r\nhvterm_priv0.termno = 0;\r\nhvterm_priv0.proto = HV_PROTOCOL_RAW;\r\nspin_lock_init(&hvterm_priv0.buf_lock);\r\nudbg_putc = udbg_hvc_putc;\r\nudbg_getc = udbg_hvc_getc;\r\nudbg_getc_poll = udbg_hvc_getc_poll;\r\n}\r\nvoid __init udbg_init_debug_lpar_hvsi(void)\r\n{\r\nhvterm_privs[0] = &hvterm_priv0;\r\nhvterm_priv0.termno = CONFIG_PPC_EARLY_DEBUG_HVSI_VTERMNO;\r\nhvterm_priv0.proto = HV_PROTOCOL_HVSI;\r\nspin_lock_init(&hvterm_priv0.buf_lock);\r\nudbg_putc = udbg_hvc_putc;\r\nudbg_getc = udbg_hvc_getc;\r\nudbg_getc_poll = udbg_hvc_getc_poll;\r\nhvsilib_init(&hvterm_priv0.hvsi, hvc_get_chars, hvc_put_chars,\r\nhvterm_priv0.termno, 1);\r\nhvsilib_establish(&hvterm_priv0.hvsi);\r\n}
