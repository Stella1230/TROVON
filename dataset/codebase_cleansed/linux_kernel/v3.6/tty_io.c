struct tty_struct *alloc_tty_struct(void)\r\n{\r\nreturn kzalloc(sizeof(struct tty_struct), GFP_KERNEL);\r\n}\r\nvoid free_tty_struct(struct tty_struct *tty)\r\n{\r\nif (tty->dev)\r\nput_device(tty->dev);\r\nkfree(tty->write_buf);\r\ntty_buffer_free_all(tty);\r\nkfree(tty);\r\n}\r\nstatic inline struct tty_struct *file_tty(struct file *file)\r\n{\r\nreturn ((struct tty_file_private *)file->private_data)->tty;\r\n}\r\nint tty_alloc_file(struct file *file)\r\n{\r\nstruct tty_file_private *priv;\r\npriv = kmalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nfile->private_data = priv;\r\nreturn 0;\r\n}\r\nvoid tty_add_file(struct tty_struct *tty, struct file *file)\r\n{\r\nstruct tty_file_private *priv = file->private_data;\r\npriv->tty = tty;\r\npriv->file = file;\r\nspin_lock(&tty_files_lock);\r\nlist_add(&priv->list, &tty->tty_files);\r\nspin_unlock(&tty_files_lock);\r\n}\r\nvoid tty_free_file(struct file *file)\r\n{\r\nstruct tty_file_private *priv = file->private_data;\r\nfile->private_data = NULL;\r\nkfree(priv);\r\n}\r\nvoid tty_del_file(struct file *file)\r\n{\r\nstruct tty_file_private *priv = file->private_data;\r\nspin_lock(&tty_files_lock);\r\nlist_del(&priv->list);\r\nspin_unlock(&tty_files_lock);\r\ntty_free_file(file);\r\n}\r\nchar *tty_name(struct tty_struct *tty, char *buf)\r\n{\r\nif (!tty)\r\nstrcpy(buf, "NULL tty");\r\nelse\r\nstrcpy(buf, tty->name);\r\nreturn buf;\r\n}\r\nint tty_paranoia_check(struct tty_struct *tty, struct inode *inode,\r\nconst char *routine)\r\n{\r\n#ifdef TTY_PARANOIA_CHECK\r\nif (!tty) {\r\nprintk(KERN_WARNING\r\n"null TTY for (%d:%d) in %s\n",\r\nimajor(inode), iminor(inode), routine);\r\nreturn 1;\r\n}\r\nif (tty->magic != TTY_MAGIC) {\r\nprintk(KERN_WARNING\r\n"bad magic number for tty struct (%d:%d) in %s\n",\r\nimajor(inode), iminor(inode), routine);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int check_tty_count(struct tty_struct *tty, const char *routine)\r\n{\r\n#ifdef CHECK_TTY_COUNT\r\nstruct list_head *p;\r\nint count = 0;\r\nspin_lock(&tty_files_lock);\r\nlist_for_each(p, &tty->tty_files) {\r\ncount++;\r\n}\r\nspin_unlock(&tty_files_lock);\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_SLAVE &&\r\ntty->link && tty->link->count)\r\ncount++;\r\nif (tty->count != count) {\r\nprintk(KERN_WARNING "Warning: dev (%s) tty->count(%d) "\r\n"!= #fd's(%d) in %s\n",\r\ntty->name, tty->count, count, routine);\r\nreturn count;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic struct tty_driver *get_tty_driver(dev_t device, int *index)\r\n{\r\nstruct tty_driver *p;\r\nlist_for_each_entry(p, &tty_drivers, tty_drivers) {\r\ndev_t base = MKDEV(p->major, p->minor_start);\r\nif (device < base || device >= base + p->num)\r\ncontinue;\r\n*index = device - base;\r\nreturn tty_driver_kref_get(p);\r\n}\r\nreturn NULL;\r\n}\r\nstruct tty_driver *tty_find_polling_driver(char *name, int *line)\r\n{\r\nstruct tty_driver *p, *res = NULL;\r\nint tty_line = 0;\r\nint len;\r\nchar *str, *stp;\r\nfor (str = name; *str; str++)\r\nif ((*str >= '0' && *str <= '9') || *str == ',')\r\nbreak;\r\nif (!*str)\r\nreturn NULL;\r\nlen = str - name;\r\ntty_line = simple_strtoul(str, &str, 10);\r\nmutex_lock(&tty_mutex);\r\nlist_for_each_entry(p, &tty_drivers, tty_drivers) {\r\nif (strncmp(name, p->name, len) != 0)\r\ncontinue;\r\nstp = str;\r\nif (*stp == ',')\r\nstp++;\r\nif (*stp == '\0')\r\nstp = NULL;\r\nif (tty_line >= 0 && tty_line < p->num && p->ops &&\r\np->ops->poll_init && !p->ops->poll_init(p, tty_line, stp)) {\r\nres = tty_driver_kref_get(p);\r\n*line = tty_line;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&tty_mutex);\r\nreturn res;\r\n}\r\nint tty_check_change(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (current->signal->tty != tty)\r\nreturn 0;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nif (!tty->pgrp) {\r\nprintk(KERN_WARNING "tty_check_change: tty->pgrp == NULL!\n");\r\ngoto out_unlock;\r\n}\r\nif (task_pgrp(current) == tty->pgrp)\r\ngoto out_unlock;\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nif (is_ignored(SIGTTOU))\r\ngoto out;\r\nif (is_current_pgrp_orphaned()) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nkill_pgrp(task_pgrp(current), SIGTTOU, 1);\r\nset_thread_flag(TIF_SIGPENDING);\r\nret = -ERESTARTSYS;\r\nout:\r\nreturn ret;\r\nout_unlock:\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t hung_up_tty_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t hung_up_tty_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn -EIO;\r\n}\r\nstatic unsigned int hung_up_tty_poll(struct file *filp, poll_table *wait)\r\n{\r\nreturn POLLIN | POLLOUT | POLLERR | POLLHUP | POLLRDNORM | POLLWRNORM;\r\n}\r\nstatic long hung_up_tty_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn cmd == TIOCSPGRP ? -ENOTTY : -EIO;\r\n}\r\nstatic long hung_up_tty_compat_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn cmd == TIOCSPGRP ? -ENOTTY : -EIO;\r\n}\r\nvoid tty_wakeup(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld;\r\nif (test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) {\r\nld = tty_ldisc_ref(tty);\r\nif (ld) {\r\nif (ld->ops->write_wakeup)\r\nld->ops->write_wakeup(tty);\r\ntty_ldisc_deref(ld);\r\n}\r\n}\r\nwake_up_interruptible_poll(&tty->write_wait, POLLOUT);\r\n}\r\nvoid __tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct file *cons_filp = NULL;\r\nstruct file *filp, *f = NULL;\r\nstruct task_struct *p;\r\nstruct tty_file_private *priv;\r\nint closecount = 0, n;\r\nunsigned long flags;\r\nint refs = 0;\r\nif (!tty)\r\nreturn;\r\nspin_lock(&redirect_lock);\r\nif (redirect && file_tty(redirect) == tty) {\r\nf = redirect;\r\nredirect = NULL;\r\n}\r\nspin_unlock(&redirect_lock);\r\ntty_lock();\r\nset_bit(TTY_HUPPING, &tty->flags);\r\ncheck_tty_count(tty, "tty_hangup");\r\nspin_lock(&tty_files_lock);\r\nlist_for_each_entry(priv, &tty->tty_files, list) {\r\nfilp = priv->file;\r\nif (filp->f_op->write == redirected_tty_write)\r\ncons_filp = filp;\r\nif (filp->f_op->write != tty_write)\r\ncontinue;\r\nclosecount++;\r\n__tty_fasync(-1, filp, 0);\r\nfilp->f_op = &hung_up_tty_fops;\r\n}\r\nspin_unlock(&tty_files_lock);\r\ntty_ldisc_hangup(tty);\r\nread_lock(&tasklist_lock);\r\nif (tty->session) {\r\ndo_each_pid_task(tty->session, PIDTYPE_SID, p) {\r\nspin_lock_irq(&p->sighand->siglock);\r\nif (p->signal->tty == tty) {\r\np->signal->tty = NULL;\r\nrefs++;\r\n}\r\nif (!p->signal->leader) {\r\nspin_unlock_irq(&p->sighand->siglock);\r\ncontinue;\r\n}\r\n__group_send_sig_info(SIGHUP, SEND_SIG_PRIV, p);\r\n__group_send_sig_info(SIGCONT, SEND_SIG_PRIV, p);\r\nput_pid(p->signal->tty_old_pgrp);\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nif (tty->pgrp)\r\np->signal->tty_old_pgrp = get_pid(tty->pgrp);\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nspin_unlock_irq(&p->sighand->siglock);\r\n} while_each_pid_task(tty->session, PIDTYPE_SID, p);\r\n}\r\nread_unlock(&tasklist_lock);\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nclear_bit(TTY_THROTTLED, &tty->flags);\r\nclear_bit(TTY_PUSH, &tty->flags);\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nput_pid(tty->session);\r\nput_pid(tty->pgrp);\r\ntty->session = NULL;\r\ntty->pgrp = NULL;\r\ntty->ctrl_status = 0;\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nwhile (refs--)\r\ntty_kref_put(tty);\r\nif (cons_filp) {\r\nif (tty->ops->close)\r\nfor (n = 0; n < closecount; n++)\r\ntty->ops->close(tty, cons_filp);\r\n} else if (tty->ops->hangup)\r\n(tty->ops->hangup)(tty);\r\nset_bit(TTY_HUPPED, &tty->flags);\r\nclear_bit(TTY_HUPPING, &tty->flags);\r\ntty_ldisc_enable(tty);\r\ntty_unlock();\r\nif (f)\r\nfput(f);\r\n}\r\nstatic void do_tty_hangup(struct work_struct *work)\r\n{\r\nstruct tty_struct *tty =\r\ncontainer_of(work, struct tty_struct, hangup_work);\r\n__tty_hangup(tty);\r\n}\r\nvoid tty_hangup(struct tty_struct *tty)\r\n{\r\n#ifdef TTY_DEBUG_HANGUP\r\nchar buf[64];\r\nprintk(KERN_DEBUG "%s hangup...\n", tty_name(tty, buf));\r\n#endif\r\nschedule_work(&tty->hangup_work);\r\n}\r\nvoid tty_vhangup(struct tty_struct *tty)\r\n{\r\n#ifdef TTY_DEBUG_HANGUP\r\nchar buf[64];\r\nprintk(KERN_DEBUG "%s vhangup...\n", tty_name(tty, buf));\r\n#endif\r\n__tty_hangup(tty);\r\n}\r\nvoid tty_vhangup_self(void)\r\n{\r\nstruct tty_struct *tty;\r\ntty = get_current_tty();\r\nif (tty) {\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nint tty_hung_up_p(struct file *filp)\r\n{\r\nreturn (filp->f_op == &hung_up_tty_fops);\r\n}\r\nstatic void session_clear_tty(struct pid *session)\r\n{\r\nstruct task_struct *p;\r\ndo_each_pid_task(session, PIDTYPE_SID, p) {\r\nproc_clear_tty(p);\r\n} while_each_pid_task(session, PIDTYPE_SID, p);\r\n}\r\nvoid disassociate_ctty(int on_exit)\r\n{\r\nstruct tty_struct *tty;\r\nif (!current->signal->leader)\r\nreturn;\r\ntty = get_current_tty();\r\nif (tty) {\r\nstruct pid *tty_pgrp = get_pid(tty->pgrp);\r\nif (on_exit) {\r\nif (tty->driver->type != TTY_DRIVER_TYPE_PTY)\r\ntty_vhangup(tty);\r\n}\r\ntty_kref_put(tty);\r\nif (tty_pgrp) {\r\nkill_pgrp(tty_pgrp, SIGHUP, on_exit);\r\nif (!on_exit)\r\nkill_pgrp(tty_pgrp, SIGCONT, on_exit);\r\nput_pid(tty_pgrp);\r\n}\r\n} else if (on_exit) {\r\nstruct pid *old_pgrp;\r\nspin_lock_irq(&current->sighand->siglock);\r\nold_pgrp = current->signal->tty_old_pgrp;\r\ncurrent->signal->tty_old_pgrp = NULL;\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (old_pgrp) {\r\nkill_pgrp(old_pgrp, SIGHUP, on_exit);\r\nkill_pgrp(old_pgrp, SIGCONT, on_exit);\r\nput_pid(old_pgrp);\r\n}\r\nreturn;\r\n}\r\nspin_lock_irq(&current->sighand->siglock);\r\nput_pid(current->signal->tty_old_pgrp);\r\ncurrent->signal->tty_old_pgrp = NULL;\r\nspin_unlock_irq(&current->sighand->siglock);\r\ntty = get_current_tty();\r\nif (tty) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nput_pid(tty->session);\r\nput_pid(tty->pgrp);\r\ntty->session = NULL;\r\ntty->pgrp = NULL;\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\ntty_kref_put(tty);\r\n} else {\r\n#ifdef TTY_DEBUG_HANGUP\r\nprintk(KERN_DEBUG "error attempted to write to tty [0x%p]"\r\n" = NULL", tty);\r\n#endif\r\n}\r\nread_lock(&tasklist_lock);\r\nsession_clear_tty(task_session(current));\r\nread_unlock(&tasklist_lock);\r\n}\r\nvoid no_tty(void)\r\n{\r\nstruct task_struct *tsk = current;\r\ndisassociate_ctty(0);\r\nproc_clear_tty(tsk);\r\n}\r\nvoid stop_tty(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nif (tty->stopped) {\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nreturn;\r\n}\r\ntty->stopped = 1;\r\nif (tty->link && tty->link->packet) {\r\ntty->ctrl_status &= ~TIOCPKT_START;\r\ntty->ctrl_status |= TIOCPKT_STOP;\r\nwake_up_interruptible_poll(&tty->link->read_wait, POLLIN);\r\n}\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nif (tty->ops->stop)\r\n(tty->ops->stop)(tty);\r\n}\r\nvoid start_tty(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nif (!tty->stopped || tty->flow_stopped) {\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nreturn;\r\n}\r\ntty->stopped = 0;\r\nif (tty->link && tty->link->packet) {\r\ntty->ctrl_status &= ~TIOCPKT_STOP;\r\ntty->ctrl_status |= TIOCPKT_START;\r\nwake_up_interruptible_poll(&tty->link->read_wait, POLLIN);\r\n}\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nif (tty->ops->start)\r\n(tty->ops->start)(tty);\r\ntty_wakeup(tty);\r\n}\r\nstatic ssize_t tty_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint i;\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nstruct tty_struct *tty = file_tty(file);\r\nstruct tty_ldisc *ld;\r\nif (tty_paranoia_check(tty, inode, "tty_read"))\r\nreturn -EIO;\r\nif (!tty || (test_bit(TTY_IO_ERROR, &tty->flags)))\r\nreturn -EIO;\r\nld = tty_ldisc_ref_wait(tty);\r\nif (ld->ops->read)\r\ni = (ld->ops->read)(tty, file, buf, count);\r\nelse\r\ni = -EIO;\r\ntty_ldisc_deref(ld);\r\nif (i > 0)\r\ninode->i_atime = current_fs_time(inode->i_sb);\r\nreturn i;\r\n}\r\nvoid tty_write_unlock(struct tty_struct *tty)\r\n__releases(&tty->atomic_write_lock\r\nint tty_write_lock(struct tty_struct *tty, int ndelay)\r\n__acquires(&tty->atomic_write_lock\r\nstatic inline ssize_t do_tty_write(\r\nssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t),\r\nstruct tty_struct *tty,\r\nstruct file *file,\r\nconst char __user *buf,\r\nsize_t count)\r\n{\r\nssize_t ret, written = 0;\r\nunsigned int chunk;\r\nret = tty_write_lock(tty, file->f_flags & O_NDELAY);\r\nif (ret < 0)\r\nreturn ret;\r\nchunk = 2048;\r\nif (test_bit(TTY_NO_WRITE_SPLIT, &tty->flags))\r\nchunk = 65536;\r\nif (count < chunk)\r\nchunk = count;\r\nif (tty->write_cnt < chunk) {\r\nunsigned char *buf_chunk;\r\nif (chunk < 1024)\r\nchunk = 1024;\r\nbuf_chunk = kmalloc(chunk, GFP_KERNEL);\r\nif (!buf_chunk) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nkfree(tty->write_buf);\r\ntty->write_cnt = chunk;\r\ntty->write_buf = buf_chunk;\r\n}\r\nfor (;;) {\r\nsize_t size = count;\r\nif (size > chunk)\r\nsize = chunk;\r\nret = -EFAULT;\r\nif (copy_from_user(tty->write_buf, buf, size))\r\nbreak;\r\nret = write(tty, file, tty->write_buf, size);\r\nif (ret <= 0)\r\nbreak;\r\nwritten += ret;\r\nbuf += ret;\r\ncount -= ret;\r\nif (!count)\r\nbreak;\r\nret = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\ncond_resched();\r\n}\r\nif (written) {\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\ninode->i_mtime = current_fs_time(inode->i_sb);\r\nret = written;\r\n}\r\nout:\r\ntty_write_unlock(tty);\r\nreturn ret;\r\n}\r\nvoid tty_write_message(struct tty_struct *tty, char *msg)\r\n{\r\nif (tty) {\r\nmutex_lock(&tty->atomic_write_lock);\r\ntty_lock();\r\nif (tty->ops->write && !test_bit(TTY_CLOSING, &tty->flags)) {\r\ntty_unlock();\r\ntty->ops->write(tty, msg, strlen(msg));\r\n} else\r\ntty_unlock();\r\ntty_write_unlock(tty);\r\n}\r\nreturn;\r\n}\r\nstatic ssize_t tty_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nstruct tty_struct *tty = file_tty(file);\r\nstruct tty_ldisc *ld;\r\nssize_t ret;\r\nif (tty_paranoia_check(tty, inode, "tty_write"))\r\nreturn -EIO;\r\nif (!tty || !tty->ops->write ||\r\n(test_bit(TTY_IO_ERROR, &tty->flags)))\r\nreturn -EIO;\r\nif (tty->ops->write_room == NULL)\r\nprintk(KERN_ERR "tty driver %s lacks a write_room method.\n",\r\ntty->driver->name);\r\nld = tty_ldisc_ref_wait(tty);\r\nif (!ld->ops->write)\r\nret = -EIO;\r\nelse\r\nret = do_tty_write(ld->ops->write, tty, file, buf, count);\r\ntty_ldisc_deref(ld);\r\nreturn ret;\r\n}\r\nssize_t redirected_tty_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct file *p = NULL;\r\nspin_lock(&redirect_lock);\r\nif (redirect) {\r\nget_file(redirect);\r\np = redirect;\r\n}\r\nspin_unlock(&redirect_lock);\r\nif (p) {\r\nssize_t res;\r\nres = vfs_write(p, buf, count, &p->f_pos);\r\nfput(p);\r\nreturn res;\r\n}\r\nreturn tty_write(file, buf, count, ppos);\r\n}\r\nstatic void pty_line_name(struct tty_driver *driver, int index, char *p)\r\n{\r\nint i = index + driver->name_base;\r\nsprintf(p, "%s%c%x",\r\ndriver->subtype == PTY_TYPE_SLAVE ? "tty" : driver->name,\r\nptychar[i >> 4 & 0xf], i & 0xf);\r\n}\r\nstatic void tty_line_name(struct tty_driver *driver, int index, char *p)\r\n{\r\nsprintf(p, "%s%d", driver->name, index + driver->name_base);\r\n}\r\nstatic struct tty_struct *tty_driver_lookup_tty(struct tty_driver *driver,\r\nstruct inode *inode, int idx)\r\n{\r\nif (driver->ops->lookup)\r\nreturn driver->ops->lookup(driver, inode, idx);\r\nreturn driver->ttys[idx];\r\n}\r\nint tty_init_termios(struct tty_struct *tty)\r\n{\r\nstruct ktermios *tp;\r\nint idx = tty->index;\r\ntp = tty->driver->termios[idx];\r\nif (tp == NULL) {\r\ntp = kzalloc(sizeof(struct ktermios[2]), GFP_KERNEL);\r\nif (tp == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(tp, &tty->driver->init_termios,\r\nsizeof(struct ktermios));\r\ntty->driver->termios[idx] = tp;\r\n}\r\ntty->termios = tp;\r\ntty->termios_locked = tp + 1;\r\ntty->termios->c_ispeed = tty_termios_input_baud_rate(tty->termios);\r\ntty->termios->c_ospeed = tty_termios_baud_rate(tty->termios);\r\nreturn 0;\r\n}\r\nint tty_standard_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nint ret = tty_init_termios(tty);\r\nif (ret)\r\nreturn ret;\r\ntty_driver_kref_get(driver);\r\ntty->count++;\r\ndriver->ttys[tty->index] = tty;\r\nreturn 0;\r\n}\r\nstatic int tty_driver_install_tty(struct tty_driver *driver,\r\nstruct tty_struct *tty)\r\n{\r\nreturn driver->ops->install ? driver->ops->install(driver, tty) :\r\ntty_standard_install(driver, tty);\r\n}\r\nvoid tty_driver_remove_tty(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nif (driver->ops->remove)\r\ndriver->ops->remove(driver, tty);\r\nelse\r\ndriver->ttys[tty->index] = NULL;\r\n}\r\nstatic int tty_reopen(struct tty_struct *tty)\r\n{\r\nstruct tty_driver *driver = tty->driver;\r\nif (test_bit(TTY_CLOSING, &tty->flags) ||\r\ntest_bit(TTY_HUPPING, &tty->flags) ||\r\ntest_bit(TTY_LDISC_CHANGING, &tty->flags))\r\nreturn -EIO;\r\nif (driver->type == TTY_DRIVER_TYPE_PTY &&\r\ndriver->subtype == PTY_TYPE_MASTER) {\r\nif (tty->count)\r\nreturn -EIO;\r\ntty->link->count++;\r\n}\r\ntty->count++;\r\nmutex_lock(&tty->ldisc_mutex);\r\nWARN_ON(!test_bit(TTY_LDISC, &tty->flags));\r\nmutex_unlock(&tty->ldisc_mutex);\r\nreturn 0;\r\n}\r\nstruct tty_struct *tty_init_dev(struct tty_driver *driver, int idx)\r\n{\r\nstruct tty_struct *tty;\r\nint retval;\r\nif (!try_module_get(driver->owner))\r\nreturn ERR_PTR(-ENODEV);\r\ntty = alloc_tty_struct();\r\nif (!tty) {\r\nretval = -ENOMEM;\r\ngoto err_module_put;\r\n}\r\ninitialize_tty_struct(tty, driver, idx);\r\nretval = tty_driver_install_tty(driver, tty);\r\nif (retval < 0)\r\ngoto err_deinit_tty;\r\nretval = tty_ldisc_setup(tty, tty->link);\r\nif (retval)\r\ngoto err_release_tty;\r\nreturn tty;\r\nerr_deinit_tty:\r\ndeinitialize_tty_struct(tty);\r\nfree_tty_struct(tty);\r\nerr_module_put:\r\nmodule_put(driver->owner);\r\nreturn ERR_PTR(retval);\r\nerr_release_tty:\r\nprintk_ratelimited(KERN_INFO "tty_init_dev: ldisc open failed, "\r\n"clearing slot %d\n", idx);\r\nrelease_tty(tty, idx);\r\nreturn ERR_PTR(retval);\r\n}\r\nvoid tty_free_termios(struct tty_struct *tty)\r\n{\r\nstruct ktermios *tp;\r\nint idx = tty->index;\r\nif (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS) {\r\ntp = tty->termios;\r\ntty->driver->termios[idx] = NULL;\r\nkfree(tp);\r\n}\r\n}\r\nvoid tty_shutdown(struct tty_struct *tty)\r\n{\r\ntty_driver_remove_tty(tty->driver, tty);\r\ntty_free_termios(tty);\r\n}\r\nstatic void release_one_tty(struct work_struct *work)\r\n{\r\nstruct tty_struct *tty =\r\ncontainer_of(work, struct tty_struct, hangup_work);\r\nstruct tty_driver *driver = tty->driver;\r\nif (tty->ops->cleanup)\r\ntty->ops->cleanup(tty);\r\ntty->magic = 0;\r\ntty_driver_kref_put(driver);\r\nmodule_put(driver->owner);\r\nspin_lock(&tty_files_lock);\r\nlist_del_init(&tty->tty_files);\r\nspin_unlock(&tty_files_lock);\r\nput_pid(tty->pgrp);\r\nput_pid(tty->session);\r\nfree_tty_struct(tty);\r\n}\r\nstatic void queue_release_one_tty(struct kref *kref)\r\n{\r\nstruct tty_struct *tty = container_of(kref, struct tty_struct, kref);\r\nif (tty->ops->shutdown)\r\ntty->ops->shutdown(tty);\r\nelse\r\ntty_shutdown(tty);\r\nINIT_WORK(&tty->hangup_work, release_one_tty);\r\nschedule_work(&tty->hangup_work);\r\n}\r\nvoid tty_kref_put(struct tty_struct *tty)\r\n{\r\nif (tty)\r\nkref_put(&tty->kref, queue_release_one_tty);\r\n}\r\nstatic void release_tty(struct tty_struct *tty, int idx)\r\n{\r\nWARN_ON(tty->index != idx);\r\nif (tty->link)\r\ntty_kref_put(tty->link);\r\ntty_kref_put(tty);\r\n}\r\nstatic int tty_release_checks(struct tty_struct *tty, struct tty_struct *o_tty,\r\nint idx)\r\n{\r\n#ifdef TTY_PARANOIA_CHECK\r\nif (idx < 0 || idx >= tty->driver->num) {\r\nprintk(KERN_DEBUG "%s: bad idx when trying to free (%s)\n",\r\n__func__, tty->name);\r\nreturn -1;\r\n}\r\nif (tty->driver->flags & TTY_DRIVER_DEVPTS_MEM)\r\nreturn 0;\r\nif (tty != tty->driver->ttys[idx]) {\r\nprintk(KERN_DEBUG "%s: driver.table[%d] not tty for (%s)\n",\r\n__func__, idx, tty->name);\r\nreturn -1;\r\n}\r\nif (tty->termios != tty->driver->termios[idx]) {\r\nprintk(KERN_DEBUG "%s: driver.termios[%d] not termios for (%s)\n",\r\n__func__, idx, tty->name);\r\nreturn -1;\r\n}\r\nif (tty->driver->other) {\r\nif (o_tty != tty->driver->other->ttys[idx]) {\r\nprintk(KERN_DEBUG "%s: other->table[%d] not o_tty for (%s)\n",\r\n__func__, idx, tty->name);\r\nreturn -1;\r\n}\r\nif (o_tty->termios != tty->driver->other->termios[idx]) {\r\nprintk(KERN_DEBUG "%s: other->termios[%d] not o_termios for (%s)\n",\r\n__func__, idx, tty->name);\r\nreturn -1;\r\n}\r\nif (o_tty->link != tty) {\r\nprintk(KERN_DEBUG "%s: bad pty pointers\n", __func__);\r\nreturn -1;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint tty_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct tty_struct *tty = file_tty(filp);\r\nstruct tty_struct *o_tty;\r\nint pty_master, tty_closing, o_tty_closing, do_sleep;\r\nint devpts;\r\nint idx;\r\nchar buf[64];\r\nif (tty_paranoia_check(tty, inode, __func__))\r\nreturn 0;\r\ntty_lock();\r\ncheck_tty_count(tty, __func__);\r\n__tty_fasync(-1, filp, 0);\r\nidx = tty->index;\r\npty_master = (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_MASTER);\r\ndevpts = (tty->driver->flags & TTY_DRIVER_DEVPTS_MEM) != 0;\r\no_tty = tty->link;\r\nif (tty_release_checks(tty, o_tty, idx)) {\r\ntty_unlock();\r\nreturn 0;\r\n}\r\n#ifdef TTY_DEBUG_HANGUP\r\nprintk(KERN_DEBUG "%s: %s (tty count=%d)...\n", __func__,\r\ntty_name(tty, buf), tty->count);\r\n#endif\r\nif (tty->ops->close)\r\ntty->ops->close(tty, filp);\r\ntty_unlock();\r\nwhile (1) {\r\nmutex_lock(&tty_mutex);\r\ntty_lock();\r\ntty_closing = tty->count <= 1;\r\no_tty_closing = o_tty &&\r\n(o_tty->count <= (pty_master ? 1 : 0));\r\ndo_sleep = 0;\r\nif (tty_closing) {\r\nif (waitqueue_active(&tty->read_wait)) {\r\nwake_up_poll(&tty->read_wait, POLLIN);\r\ndo_sleep++;\r\n}\r\nif (waitqueue_active(&tty->write_wait)) {\r\nwake_up_poll(&tty->write_wait, POLLOUT);\r\ndo_sleep++;\r\n}\r\n}\r\nif (o_tty_closing) {\r\nif (waitqueue_active(&o_tty->read_wait)) {\r\nwake_up_poll(&o_tty->read_wait, POLLIN);\r\ndo_sleep++;\r\n}\r\nif (waitqueue_active(&o_tty->write_wait)) {\r\nwake_up_poll(&o_tty->write_wait, POLLOUT);\r\ndo_sleep++;\r\n}\r\n}\r\nif (!do_sleep)\r\nbreak;\r\nprintk(KERN_WARNING "%s: %s: read/write wait queue active!\n",\r\n__func__, tty_name(tty, buf));\r\ntty_unlock();\r\nmutex_unlock(&tty_mutex);\r\nschedule();\r\n}\r\nif (pty_master) {\r\nif (--o_tty->count < 0) {\r\nprintk(KERN_WARNING "%s: bad pty slave count (%d) for %s\n",\r\n__func__, o_tty->count, tty_name(o_tty, buf));\r\no_tty->count = 0;\r\n}\r\n}\r\nif (--tty->count < 0) {\r\nprintk(KERN_WARNING "%s: bad tty->count (%d) for %s\n",\r\n__func__, tty->count, tty_name(tty, buf));\r\ntty->count = 0;\r\n}\r\ntty_del_file(filp);\r\nif (tty_closing)\r\nset_bit(TTY_CLOSING, &tty->flags);\r\nif (o_tty_closing)\r\nset_bit(TTY_CLOSING, &o_tty->flags);\r\nif (tty_closing || o_tty_closing) {\r\nread_lock(&tasklist_lock);\r\nsession_clear_tty(tty->session);\r\nif (o_tty)\r\nsession_clear_tty(o_tty->session);\r\nread_unlock(&tasklist_lock);\r\n}\r\nmutex_unlock(&tty_mutex);\r\nif (!tty_closing || (o_tty && !o_tty_closing)) {\r\ntty_unlock();\r\nreturn 0;\r\n}\r\n#ifdef TTY_DEBUG_HANGUP\r\nprintk(KERN_DEBUG "%s: freeing tty structure...\n", __func__);\r\n#endif\r\ntty_ldisc_release(tty, o_tty);\r\nrelease_tty(tty, idx);\r\nif (devpts)\r\ndevpts_kill_index(inode, idx);\r\ntty_unlock();\r\nreturn 0;\r\n}\r\nstatic struct tty_struct *tty_open_current_tty(dev_t device, struct file *filp)\r\n{\r\nstruct tty_struct *tty;\r\nif (device != MKDEV(TTYAUX_MAJOR, 0))\r\nreturn NULL;\r\ntty = get_current_tty();\r\nif (!tty)\r\nreturn ERR_PTR(-ENXIO);\r\nfilp->f_flags |= O_NONBLOCK;\r\ntty_kref_put(tty);\r\nreturn tty;\r\n}\r\nstatic struct tty_driver *tty_lookup_driver(dev_t device, struct file *filp,\r\nint *noctty, int *index)\r\n{\r\nstruct tty_driver *driver;\r\nswitch (device) {\r\n#ifdef CONFIG_VT\r\ncase MKDEV(TTY_MAJOR, 0): {\r\nextern struct tty_driver *console_driver;\r\ndriver = tty_driver_kref_get(console_driver);\r\n*index = fg_console;\r\n*noctty = 1;\r\nbreak;\r\n}\r\n#endif\r\ncase MKDEV(TTYAUX_MAJOR, 1): {\r\nstruct tty_driver *console_driver = console_device(index);\r\nif (console_driver) {\r\ndriver = tty_driver_kref_get(console_driver);\r\nif (driver) {\r\nfilp->f_flags |= O_NONBLOCK;\r\n*noctty = 1;\r\nbreak;\r\n}\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ndefault:\r\ndriver = get_tty_driver(device, index);\r\nif (!driver)\r\nreturn ERR_PTR(-ENODEV);\r\nbreak;\r\n}\r\nreturn driver;\r\n}\r\nstatic int tty_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct tty_struct *tty;\r\nint noctty, retval;\r\nstruct tty_driver *driver = NULL;\r\nint index;\r\ndev_t device = inode->i_rdev;\r\nunsigned saved_flags = filp->f_flags;\r\nnonseekable_open(inode, filp);\r\nretry_open:\r\nretval = tty_alloc_file(filp);\r\nif (retval)\r\nreturn -ENOMEM;\r\nnoctty = filp->f_flags & O_NOCTTY;\r\nindex = -1;\r\nretval = 0;\r\nmutex_lock(&tty_mutex);\r\ntty_lock();\r\ntty = tty_open_current_tty(device, filp);\r\nif (IS_ERR(tty)) {\r\nretval = PTR_ERR(tty);\r\ngoto err_unlock;\r\n} else if (!tty) {\r\ndriver = tty_lookup_driver(device, filp, &noctty, &index);\r\nif (IS_ERR(driver)) {\r\nretval = PTR_ERR(driver);\r\ngoto err_unlock;\r\n}\r\ntty = tty_driver_lookup_tty(driver, inode, index);\r\nif (IS_ERR(tty)) {\r\nretval = PTR_ERR(tty);\r\ngoto err_unlock;\r\n}\r\n}\r\nif (tty) {\r\nretval = tty_reopen(tty);\r\nif (retval)\r\ntty = ERR_PTR(retval);\r\n} else\r\ntty = tty_init_dev(driver, index);\r\nmutex_unlock(&tty_mutex);\r\nif (driver)\r\ntty_driver_kref_put(driver);\r\nif (IS_ERR(tty)) {\r\ntty_unlock();\r\nretval = PTR_ERR(tty);\r\ngoto err_file;\r\n}\r\ntty_add_file(tty, filp);\r\ncheck_tty_count(tty, __func__);\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_MASTER)\r\nnoctty = 1;\r\n#ifdef TTY_DEBUG_HANGUP\r\nprintk(KERN_DEBUG "%s: opening %s...\n", __func__, tty->name);\r\n#endif\r\nif (tty->ops->open)\r\nretval = tty->ops->open(tty, filp);\r\nelse\r\nretval = -ENODEV;\r\nfilp->f_flags = saved_flags;\r\nif (!retval && test_bit(TTY_EXCLUSIVE, &tty->flags) &&\r\n!capable(CAP_SYS_ADMIN))\r\nretval = -EBUSY;\r\nif (retval) {\r\n#ifdef TTY_DEBUG_HANGUP\r\nprintk(KERN_DEBUG "%s: error %d in opening %s...\n", __func__,\r\nretval, tty->name);\r\n#endif\r\ntty_unlock();\r\ntty_release(inode, filp);\r\nif (retval != -ERESTARTSYS)\r\nreturn retval;\r\nif (signal_pending(current))\r\nreturn retval;\r\nschedule();\r\ntty_lock();\r\nif (filp->f_op == &hung_up_tty_fops)\r\nfilp->f_op = &tty_fops;\r\ntty_unlock();\r\ngoto retry_open;\r\n}\r\ntty_unlock();\r\nmutex_lock(&tty_mutex);\r\ntty_lock();\r\nspin_lock_irq(&current->sighand->siglock);\r\nif (!noctty &&\r\ncurrent->signal->leader &&\r\n!current->signal->tty &&\r\ntty->session == NULL)\r\n__proc_set_tty(current, tty);\r\nspin_unlock_irq(&current->sighand->siglock);\r\ntty_unlock();\r\nmutex_unlock(&tty_mutex);\r\nreturn 0;\r\nerr_unlock:\r\ntty_unlock();\r\nmutex_unlock(&tty_mutex);\r\nif (!IS_ERR_OR_NULL(driver))\r\ntty_driver_kref_put(driver);\r\nerr_file:\r\ntty_free_file(filp);\r\nreturn retval;\r\n}\r\nstatic unsigned int tty_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct tty_struct *tty = file_tty(filp);\r\nstruct tty_ldisc *ld;\r\nint ret = 0;\r\nif (tty_paranoia_check(tty, filp->f_path.dentry->d_inode, "tty_poll"))\r\nreturn 0;\r\nld = tty_ldisc_ref_wait(tty);\r\nif (ld->ops->poll)\r\nret = (ld->ops->poll)(tty, filp, wait);\r\ntty_ldisc_deref(ld);\r\nreturn ret;\r\n}\r\nstatic int __tty_fasync(int fd, struct file *filp, int on)\r\n{\r\nstruct tty_struct *tty = file_tty(filp);\r\nunsigned long flags;\r\nint retval = 0;\r\nif (tty_paranoia_check(tty, filp->f_path.dentry->d_inode, "tty_fasync"))\r\ngoto out;\r\nretval = fasync_helper(fd, filp, on, &tty->fasync);\r\nif (retval <= 0)\r\ngoto out;\r\nif (on) {\r\nenum pid_type type;\r\nstruct pid *pid;\r\nif (!waitqueue_active(&tty->read_wait))\r\ntty->minimum_to_wake = 1;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nif (tty->pgrp) {\r\npid = tty->pgrp;\r\ntype = PIDTYPE_PGID;\r\n} else {\r\npid = task_pid(current);\r\ntype = PIDTYPE_PID;\r\n}\r\nget_pid(pid);\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nretval = __f_setown(filp, pid, type, 0);\r\nput_pid(pid);\r\nif (retval)\r\ngoto out;\r\n} else {\r\nif (!tty->fasync && !waitqueue_active(&tty->read_wait))\r\ntty->minimum_to_wake = N_TTY_BUF_SIZE;\r\n}\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int tty_fasync(int fd, struct file *filp, int on)\r\n{\r\nint retval;\r\ntty_lock();\r\nretval = __tty_fasync(fd, filp, on);\r\ntty_unlock();\r\nreturn retval;\r\n}\r\nstatic int tiocsti(struct tty_struct *tty, char __user *p)\r\n{\r\nchar ch, mbz = 0;\r\nstruct tty_ldisc *ld;\r\nif ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (get_user(ch, p))\r\nreturn -EFAULT;\r\ntty_audit_tiocsti(tty, ch);\r\nld = tty_ldisc_ref_wait(tty);\r\nld->ops->receive_buf(tty, &ch, &mbz, 1);\r\ntty_ldisc_deref(ld);\r\nreturn 0;\r\n}\r\nstatic int tiocgwinsz(struct tty_struct *tty, struct winsize __user *arg)\r\n{\r\nint err;\r\nmutex_lock(&tty->termios_mutex);\r\nerr = copy_to_user(arg, &tty->winsize, sizeof(*arg));\r\nmutex_unlock(&tty->termios_mutex);\r\nreturn err ? -EFAULT: 0;\r\n}\r\nint tty_do_resize(struct tty_struct *tty, struct winsize *ws)\r\n{\r\nstruct pid *pgrp;\r\nunsigned long flags;\r\nmutex_lock(&tty->termios_mutex);\r\nif (!memcmp(ws, &tty->winsize, sizeof(*ws)))\r\ngoto done;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\npgrp = get_pid(tty->pgrp);\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nif (pgrp)\r\nkill_pgrp(pgrp, SIGWINCH, 1);\r\nput_pid(pgrp);\r\ntty->winsize = *ws;\r\ndone:\r\nmutex_unlock(&tty->termios_mutex);\r\nreturn 0;\r\n}\r\nstatic int tiocswinsz(struct tty_struct *tty, struct winsize __user *arg)\r\n{\r\nstruct winsize tmp_ws;\r\nif (copy_from_user(&tmp_ws, arg, sizeof(*arg)))\r\nreturn -EFAULT;\r\nif (tty->ops->resize)\r\nreturn tty->ops->resize(tty, &tmp_ws);\r\nelse\r\nreturn tty_do_resize(tty, &tmp_ws);\r\n}\r\nstatic int tioccons(struct file *file)\r\n{\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (file->f_op->write == redirected_tty_write) {\r\nstruct file *f;\r\nspin_lock(&redirect_lock);\r\nf = redirect;\r\nredirect = NULL;\r\nspin_unlock(&redirect_lock);\r\nif (f)\r\nfput(f);\r\nreturn 0;\r\n}\r\nspin_lock(&redirect_lock);\r\nif (redirect) {\r\nspin_unlock(&redirect_lock);\r\nreturn -EBUSY;\r\n}\r\nget_file(file);\r\nredirect = file;\r\nspin_unlock(&redirect_lock);\r\nreturn 0;\r\n}\r\nstatic int fionbio(struct file *file, int __user *p)\r\n{\r\nint nonblock;\r\nif (get_user(nonblock, p))\r\nreturn -EFAULT;\r\nspin_lock(&file->f_lock);\r\nif (nonblock)\r\nfile->f_flags |= O_NONBLOCK;\r\nelse\r\nfile->f_flags &= ~O_NONBLOCK;\r\nspin_unlock(&file->f_lock);\r\nreturn 0;\r\n}\r\nstatic int tiocsctty(struct tty_struct *tty, int arg)\r\n{\r\nint ret = 0;\r\nif (current->signal->leader && (task_session(current) == tty->session))\r\nreturn ret;\r\nmutex_lock(&tty_mutex);\r\nif (!current->signal->leader || current->signal->tty) {\r\nret = -EPERM;\r\ngoto unlock;\r\n}\r\nif (tty->session) {\r\nif (arg == 1 && capable(CAP_SYS_ADMIN)) {\r\nread_lock(&tasklist_lock);\r\nsession_clear_tty(tty->session);\r\nread_unlock(&tasklist_lock);\r\n} else {\r\nret = -EPERM;\r\ngoto unlock;\r\n}\r\n}\r\nproc_set_tty(current, tty);\r\nunlock:\r\nmutex_unlock(&tty_mutex);\r\nreturn ret;\r\n}\r\nstruct pid *tty_get_pgrp(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct pid *pgrp;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\npgrp = get_pid(tty->pgrp);\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nreturn pgrp;\r\n}\r\nstatic int tiocgpgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nstruct pid *pid;\r\nint ret;\r\nif (tty == real_tty && current->signal->tty != real_tty)\r\nreturn -ENOTTY;\r\npid = tty_get_pgrp(real_tty);\r\nret = put_user(pid_vnr(pid), p);\r\nput_pid(pid);\r\nreturn ret;\r\n}\r\nstatic int tiocspgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nstruct pid *pgrp;\r\npid_t pgrp_nr;\r\nint retval = tty_check_change(real_tty);\r\nunsigned long flags;\r\nif (retval == -EIO)\r\nreturn -ENOTTY;\r\nif (retval)\r\nreturn retval;\r\nif (!current->signal->tty ||\r\n(current->signal->tty != real_tty) ||\r\n(real_tty->session != task_session(current)))\r\nreturn -ENOTTY;\r\nif (get_user(pgrp_nr, p))\r\nreturn -EFAULT;\r\nif (pgrp_nr < 0)\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\npgrp = find_vpid(pgrp_nr);\r\nretval = -ESRCH;\r\nif (!pgrp)\r\ngoto out_unlock;\r\nretval = -EPERM;\r\nif (session_of_pgrp(pgrp) != task_session(current))\r\ngoto out_unlock;\r\nretval = 0;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nput_pid(real_tty->pgrp);\r\nreal_tty->pgrp = get_pid(pgrp);\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn retval;\r\n}\r\nstatic int tiocgsid(struct tty_struct *tty, struct tty_struct *real_tty, pid_t __user *p)\r\n{\r\nif (tty == real_tty && current->signal->tty != real_tty)\r\nreturn -ENOTTY;\r\nif (!real_tty->session)\r\nreturn -ENOTTY;\r\nreturn put_user(pid_vnr(real_tty->session), p);\r\n}\r\nstatic int tiocsetd(struct tty_struct *tty, int __user *p)\r\n{\r\nint ldisc;\r\nint ret;\r\nif (get_user(ldisc, p))\r\nreturn -EFAULT;\r\nret = tty_set_ldisc(tty, ldisc);\r\nreturn ret;\r\n}\r\nstatic int send_break(struct tty_struct *tty, unsigned int duration)\r\n{\r\nint retval;\r\nif (tty->ops->break_ctl == NULL)\r\nreturn 0;\r\nif (tty->driver->flags & TTY_DRIVER_HARDWARE_BREAK)\r\nretval = tty->ops->break_ctl(tty, duration);\r\nelse {\r\nif (tty_write_lock(tty, 0) < 0)\r\nreturn -EINTR;\r\nretval = tty->ops->break_ctl(tty, -1);\r\nif (retval)\r\ngoto out;\r\nif (!signal_pending(current))\r\nmsleep_interruptible(duration);\r\nretval = tty->ops->break_ctl(tty, 0);\r\nout:\r\ntty_write_unlock(tty);\r\nif (signal_pending(current))\r\nretval = -EINTR;\r\n}\r\nreturn retval;\r\n}\r\nstatic int tty_tiocmget(struct tty_struct *tty, int __user *p)\r\n{\r\nint retval = -EINVAL;\r\nif (tty->ops->tiocmget) {\r\nretval = tty->ops->tiocmget(tty);\r\nif (retval >= 0)\r\nretval = put_user(retval, p);\r\n}\r\nreturn retval;\r\n}\r\nstatic int tty_tiocmset(struct tty_struct *tty, unsigned int cmd,\r\nunsigned __user *p)\r\n{\r\nint retval;\r\nunsigned int set, clear, val;\r\nif (tty->ops->tiocmset == NULL)\r\nreturn -EINVAL;\r\nretval = get_user(val, p);\r\nif (retval)\r\nreturn retval;\r\nset = clear = 0;\r\nswitch (cmd) {\r\ncase TIOCMBIS:\r\nset = val;\r\nbreak;\r\ncase TIOCMBIC:\r\nclear = val;\r\nbreak;\r\ncase TIOCMSET:\r\nset = val;\r\nclear = ~val;\r\nbreak;\r\n}\r\nset &= TIOCM_DTR|TIOCM_RTS|TIOCM_OUT1|TIOCM_OUT2|TIOCM_LOOP;\r\nclear &= TIOCM_DTR|TIOCM_RTS|TIOCM_OUT1|TIOCM_OUT2|TIOCM_LOOP;\r\nreturn tty->ops->tiocmset(tty, set, clear);\r\n}\r\nstatic int tty_tiocgicount(struct tty_struct *tty, void __user *arg)\r\n{\r\nint retval = -EINVAL;\r\nstruct serial_icounter_struct icount;\r\nmemset(&icount, 0, sizeof(icount));\r\nif (tty->ops->get_icount)\r\nretval = tty->ops->get_icount(tty, &icount);\r\nif (retval != 0)\r\nreturn retval;\r\nif (copy_to_user(arg, &icount, sizeof(icount)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstruct tty_struct *tty_pair_get_tty(struct tty_struct *tty)\r\n{\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_MASTER)\r\ntty = tty->link;\r\nreturn tty;\r\n}\r\nstruct tty_struct *tty_pair_get_pty(struct tty_struct *tty)\r\n{\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\r\ntty->driver->subtype == PTY_TYPE_MASTER)\r\nreturn tty;\r\nreturn tty->link;\r\n}\r\nlong tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct tty_struct *tty = file_tty(file);\r\nstruct tty_struct *real_tty;\r\nvoid __user *p = (void __user *)arg;\r\nint retval;\r\nstruct tty_ldisc *ld;\r\nstruct inode *inode = file->f_dentry->d_inode;\r\nif (tty_paranoia_check(tty, inode, "tty_ioctl"))\r\nreturn -EINVAL;\r\nreal_tty = tty_pair_get_tty(tty);\r\nswitch (cmd) {\r\ncase TIOCSETD:\r\ncase TIOCSBRK:\r\ncase TIOCCBRK:\r\ncase TCSBRK:\r\ncase TCSBRKP:\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\nif (cmd != TIOCCBRK) {\r\ntty_wait_until_sent(tty, 0);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n}\r\nbreak;\r\n}\r\nswitch (cmd) {\r\ncase TIOCSTI:\r\nreturn tiocsti(tty, p);\r\ncase TIOCGWINSZ:\r\nreturn tiocgwinsz(real_tty, p);\r\ncase TIOCSWINSZ:\r\nreturn tiocswinsz(real_tty, p);\r\ncase TIOCCONS:\r\nreturn real_tty != tty ? -EINVAL : tioccons(file);\r\ncase FIONBIO:\r\nreturn fionbio(file, p);\r\ncase TIOCEXCL:\r\nset_bit(TTY_EXCLUSIVE, &tty->flags);\r\nreturn 0;\r\ncase TIOCNXCL:\r\nclear_bit(TTY_EXCLUSIVE, &tty->flags);\r\nreturn 0;\r\ncase TIOCNOTTY:\r\nif (current->signal->tty != tty)\r\nreturn -ENOTTY;\r\nno_tty();\r\nreturn 0;\r\ncase TIOCSCTTY:\r\nreturn tiocsctty(tty, arg);\r\ncase TIOCGPGRP:\r\nreturn tiocgpgrp(tty, real_tty, p);\r\ncase TIOCSPGRP:\r\nreturn tiocspgrp(tty, real_tty, p);\r\ncase TIOCGSID:\r\nreturn tiocgsid(tty, real_tty, p);\r\ncase TIOCGETD:\r\nreturn put_user(tty->ldisc->ops->num, (int __user *)p);\r\ncase TIOCSETD:\r\nreturn tiocsetd(tty, p);\r\ncase TIOCVHANGUP:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\ntty_vhangup(tty);\r\nreturn 0;\r\ncase TIOCGDEV:\r\n{\r\nunsigned int ret = new_encode_dev(tty_devnum(real_tty));\r\nreturn put_user(ret, (unsigned int __user *)p);\r\n}\r\ncase TIOCSBRK:\r\nif (tty->ops->break_ctl)\r\nreturn tty->ops->break_ctl(tty, -1);\r\nreturn 0;\r\ncase TIOCCBRK:\r\nif (tty->ops->break_ctl)\r\nreturn tty->ops->break_ctl(tty, 0);\r\nreturn 0;\r\ncase TCSBRK:\r\nif (!arg)\r\nreturn send_break(tty, 250);\r\nreturn 0;\r\ncase TCSBRKP:\r\nreturn send_break(tty, arg ? arg*100 : 250);\r\ncase TIOCMGET:\r\nreturn tty_tiocmget(tty, p);\r\ncase TIOCMSET:\r\ncase TIOCMBIC:\r\ncase TIOCMBIS:\r\nreturn tty_tiocmset(tty, cmd, p);\r\ncase TIOCGICOUNT:\r\nretval = tty_tiocgicount(tty, p);\r\nif (retval != -EINVAL)\r\nreturn retval;\r\nbreak;\r\ncase TCFLSH:\r\nswitch (arg) {\r\ncase TCIFLUSH:\r\ncase TCIOFLUSH:\r\ntty_buffer_flush(tty);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (tty->ops->ioctl) {\r\nretval = (tty->ops->ioctl)(tty, cmd, arg);\r\nif (retval != -ENOIOCTLCMD)\r\nreturn retval;\r\n}\r\nld = tty_ldisc_ref_wait(tty);\r\nretval = -EINVAL;\r\nif (ld->ops->ioctl) {\r\nretval = ld->ops->ioctl(tty, file, cmd, arg);\r\nif (retval == -ENOIOCTLCMD)\r\nretval = -EINVAL;\r\n}\r\ntty_ldisc_deref(ld);\r\nreturn retval;\r\n}\r\nstatic long tty_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct inode *inode = file->f_dentry->d_inode;\r\nstruct tty_struct *tty = file_tty(file);\r\nstruct tty_ldisc *ld;\r\nint retval = -ENOIOCTLCMD;\r\nif (tty_paranoia_check(tty, inode, "tty_ioctl"))\r\nreturn -EINVAL;\r\nif (tty->ops->compat_ioctl) {\r\nretval = (tty->ops->compat_ioctl)(tty, cmd, arg);\r\nif (retval != -ENOIOCTLCMD)\r\nreturn retval;\r\n}\r\nld = tty_ldisc_ref_wait(tty);\r\nif (ld->ops->compat_ioctl)\r\nretval = ld->ops->compat_ioctl(tty, file, cmd, arg);\r\nelse\r\nretval = n_tty_compat_ioctl_helper(tty, file, cmd, arg);\r\ntty_ldisc_deref(ld);\r\nreturn retval;\r\n}\r\nvoid __do_SAK(struct tty_struct *tty)\r\n{\r\n#ifdef TTY_SOFT_SAK\r\ntty_hangup(tty);\r\n#else\r\nstruct task_struct *g, *p;\r\nstruct pid *session;\r\nint i;\r\nstruct file *filp;\r\nstruct fdtable *fdt;\r\nif (!tty)\r\nreturn;\r\nsession = tty->session;\r\ntty_ldisc_flush(tty);\r\ntty_driver_flush_buffer(tty);\r\nread_lock(&tasklist_lock);\r\ndo_each_pid_task(session, PIDTYPE_SID, p) {\r\nprintk(KERN_NOTICE "SAK: killed process %d"\r\n" (%s): task_session(p)==tty->session\n",\r\ntask_pid_nr(p), p->comm);\r\nsend_sig(SIGKILL, p, 1);\r\n} while_each_pid_task(session, PIDTYPE_SID, p);\r\ndo_each_thread(g, p) {\r\nif (p->signal->tty == tty) {\r\nprintk(KERN_NOTICE "SAK: killed process %d"\r\n" (%s): task_session(p)==tty->session\n",\r\ntask_pid_nr(p), p->comm);\r\nsend_sig(SIGKILL, p, 1);\r\ncontinue;\r\n}\r\ntask_lock(p);\r\nif (p->files) {\r\nspin_lock(&p->files->file_lock);\r\nfdt = files_fdtable(p->files);\r\nfor (i = 0; i < fdt->max_fds; i++) {\r\nfilp = fcheck_files(p->files, i);\r\nif (!filp)\r\ncontinue;\r\nif (filp->f_op->read == tty_read &&\r\nfile_tty(filp) == tty) {\r\nprintk(KERN_NOTICE "SAK: killed process %d"\r\n" (%s): fd#%d opened to the tty\n",\r\ntask_pid_nr(p), p->comm, i);\r\nforce_sig(SIGKILL, p);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&p->files->file_lock);\r\n}\r\ntask_unlock(p);\r\n} while_each_thread(g, p);\r\nread_unlock(&tasklist_lock);\r\n#endif\r\n}\r\nstatic void do_SAK_work(struct work_struct *work)\r\n{\r\nstruct tty_struct *tty =\r\ncontainer_of(work, struct tty_struct, SAK_work);\r\n__do_SAK(tty);\r\n}\r\nvoid do_SAK(struct tty_struct *tty)\r\n{\r\nif (!tty)\r\nreturn;\r\nschedule_work(&tty->SAK_work);\r\n}\r\nstatic int dev_match_devt(struct device *dev, void *data)\r\n{\r\ndev_t *devt = data;\r\nreturn dev->devt == *devt;\r\n}\r\nstatic struct device *tty_get_device(struct tty_struct *tty)\r\n{\r\ndev_t devt = tty_devnum(tty);\r\nreturn class_find_device(tty_class, NULL, &devt, dev_match_devt);\r\n}\r\nvoid initialize_tty_struct(struct tty_struct *tty,\r\nstruct tty_driver *driver, int idx)\r\n{\r\nmemset(tty, 0, sizeof(struct tty_struct));\r\nkref_init(&tty->kref);\r\ntty->magic = TTY_MAGIC;\r\ntty_ldisc_init(tty);\r\ntty->session = NULL;\r\ntty->pgrp = NULL;\r\ntty->overrun_time = jiffies;\r\ntty_buffer_init(tty);\r\nmutex_init(&tty->termios_mutex);\r\nmutex_init(&tty->ldisc_mutex);\r\ninit_waitqueue_head(&tty->write_wait);\r\ninit_waitqueue_head(&tty->read_wait);\r\nINIT_WORK(&tty->hangup_work, do_tty_hangup);\r\nmutex_init(&tty->atomic_read_lock);\r\nmutex_init(&tty->atomic_write_lock);\r\nmutex_init(&tty->output_lock);\r\nmutex_init(&tty->echo_lock);\r\nspin_lock_init(&tty->read_lock);\r\nspin_lock_init(&tty->ctrl_lock);\r\nINIT_LIST_HEAD(&tty->tty_files);\r\nINIT_WORK(&tty->SAK_work, do_SAK_work);\r\ntty->driver = driver;\r\ntty->ops = driver->ops;\r\ntty->index = idx;\r\ntty_line_name(driver, idx, tty->name);\r\ntty->dev = tty_get_device(tty);\r\n}\r\nvoid deinitialize_tty_struct(struct tty_struct *tty)\r\n{\r\ntty_ldisc_deinit(tty);\r\n}\r\nint tty_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nif (tty->ops->put_char)\r\nreturn tty->ops->put_char(tty, ch);\r\nreturn tty->ops->write(tty, &ch, 1);\r\n}\r\nstruct device *tty_register_device(struct tty_driver *driver, unsigned index,\r\nstruct device *device)\r\n{\r\nchar name[64];\r\ndev_t dev = MKDEV(driver->major, driver->minor_start) + index;\r\nif (index >= driver->num) {\r\nprintk(KERN_ERR "Attempt to register invalid tty line number "\r\n" (%d).\n", index);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (driver->type == TTY_DRIVER_TYPE_PTY)\r\npty_line_name(driver, index, name);\r\nelse\r\ntty_line_name(driver, index, name);\r\nreturn device_create(tty_class, device, dev, NULL, name);\r\n}\r\nvoid tty_unregister_device(struct tty_driver *driver, unsigned index)\r\n{\r\ndevice_destroy(tty_class,\r\nMKDEV(driver->major, driver->minor_start) + index);\r\n}\r\nstruct tty_driver *__alloc_tty_driver(int lines, struct module *owner)\r\n{\r\nstruct tty_driver *driver;\r\ndriver = kzalloc(sizeof(struct tty_driver), GFP_KERNEL);\r\nif (driver) {\r\nkref_init(&driver->kref);\r\ndriver->magic = TTY_DRIVER_MAGIC;\r\ndriver->num = lines;\r\ndriver->owner = owner;\r\n}\r\nreturn driver;\r\n}\r\nstatic void destruct_tty_driver(struct kref *kref)\r\n{\r\nstruct tty_driver *driver = container_of(kref, struct tty_driver, kref);\r\nint i;\r\nstruct ktermios *tp;\r\nvoid *p;\r\nif (driver->flags & TTY_DRIVER_INSTALLED) {\r\nfor (i = 0; i < driver->num; i++) {\r\ntp = driver->termios[i];\r\nif (tp) {\r\ndriver->termios[i] = NULL;\r\nkfree(tp);\r\n}\r\nif (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV))\r\ntty_unregister_device(driver, i);\r\n}\r\np = driver->ttys;\r\nproc_tty_unregister_driver(driver);\r\ndriver->ttys = NULL;\r\ndriver->termios = NULL;\r\nkfree(p);\r\ncdev_del(&driver->cdev);\r\n}\r\nkfree(driver);\r\n}\r\nvoid tty_driver_kref_put(struct tty_driver *driver)\r\n{\r\nkref_put(&driver->kref, destruct_tty_driver);\r\n}\r\nvoid tty_set_operations(struct tty_driver *driver,\r\nconst struct tty_operations *op)\r\n{\r\ndriver->ops = op;\r\n}\r\nvoid put_tty_driver(struct tty_driver *d)\r\n{\r\ntty_driver_kref_put(d);\r\n}\r\nint tty_register_driver(struct tty_driver *driver)\r\n{\r\nint error;\r\nint i;\r\ndev_t dev;\r\nvoid **p = NULL;\r\nstruct device *d;\r\nif (!(driver->flags & TTY_DRIVER_DEVPTS_MEM) && driver->num) {\r\np = kzalloc(driver->num * 2 * sizeof(void *), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\n}\r\nif (!driver->major) {\r\nerror = alloc_chrdev_region(&dev, driver->minor_start,\r\ndriver->num, driver->name);\r\nif (!error) {\r\ndriver->major = MAJOR(dev);\r\ndriver->minor_start = MINOR(dev);\r\n}\r\n} else {\r\ndev = MKDEV(driver->major, driver->minor_start);\r\nerror = register_chrdev_region(dev, driver->num, driver->name);\r\n}\r\nif (error < 0) {\r\nkfree(p);\r\nreturn error;\r\n}\r\nif (p) {\r\ndriver->ttys = (struct tty_struct **)p;\r\ndriver->termios = (struct ktermios **)(p + driver->num);\r\n} else {\r\ndriver->ttys = NULL;\r\ndriver->termios = NULL;\r\n}\r\ncdev_init(&driver->cdev, &tty_fops);\r\ndriver->cdev.owner = driver->owner;\r\nerror = cdev_add(&driver->cdev, dev, driver->num);\r\nif (error) {\r\nunregister_chrdev_region(dev, driver->num);\r\ndriver->ttys = NULL;\r\ndriver->termios = NULL;\r\nkfree(p);\r\nreturn error;\r\n}\r\nmutex_lock(&tty_mutex);\r\nlist_add(&driver->tty_drivers, &tty_drivers);\r\nmutex_unlock(&tty_mutex);\r\nif (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV)) {\r\nfor (i = 0; i < driver->num; i++) {\r\nd = tty_register_device(driver, i, NULL);\r\nif (IS_ERR(d)) {\r\nerror = PTR_ERR(d);\r\ngoto err;\r\n}\r\n}\r\n}\r\nproc_tty_register_driver(driver);\r\ndriver->flags |= TTY_DRIVER_INSTALLED;\r\nreturn 0;\r\nerr:\r\nfor (i--; i >= 0; i--)\r\ntty_unregister_device(driver, i);\r\nmutex_lock(&tty_mutex);\r\nlist_del(&driver->tty_drivers);\r\nmutex_unlock(&tty_mutex);\r\nunregister_chrdev_region(dev, driver->num);\r\ndriver->ttys = NULL;\r\ndriver->termios = NULL;\r\nkfree(p);\r\nreturn error;\r\n}\r\nint tty_unregister_driver(struct tty_driver *driver)\r\n{\r\n#if 0\r\nif (driver->refcount)\r\nreturn -EBUSY;\r\n#endif\r\nunregister_chrdev_region(MKDEV(driver->major, driver->minor_start),\r\ndriver->num);\r\nmutex_lock(&tty_mutex);\r\nlist_del(&driver->tty_drivers);\r\nmutex_unlock(&tty_mutex);\r\nreturn 0;\r\n}\r\ndev_t tty_devnum(struct tty_struct *tty)\r\n{\r\nreturn MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;\r\n}\r\nvoid proc_clear_tty(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nstruct tty_struct *tty;\r\nspin_lock_irqsave(&p->sighand->siglock, flags);\r\ntty = p->signal->tty;\r\np->signal->tty = NULL;\r\nspin_unlock_irqrestore(&p->sighand->siglock, flags);\r\ntty_kref_put(tty);\r\n}\r\nstatic void __proc_set_tty(struct task_struct *tsk, struct tty_struct *tty)\r\n{\r\nif (tty) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\nput_pid(tty->session);\r\nput_pid(tty->pgrp);\r\ntty->pgrp = get_pid(task_pgrp(tsk));\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\ntty->session = get_pid(task_session(tsk));\r\nif (tsk->signal->tty) {\r\nprintk(KERN_DEBUG "tty not NULL!!\n");\r\ntty_kref_put(tsk->signal->tty);\r\n}\r\n}\r\nput_pid(tsk->signal->tty_old_pgrp);\r\ntsk->signal->tty = tty_kref_get(tty);\r\ntsk->signal->tty_old_pgrp = NULL;\r\n}\r\nstatic void proc_set_tty(struct task_struct *tsk, struct tty_struct *tty)\r\n{\r\nspin_lock_irq(&tsk->sighand->siglock);\r\n__proc_set_tty(tsk, tty);\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\n}\r\nstruct tty_struct *get_current_tty(void)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nspin_lock_irqsave(&current->sighand->siglock, flags);\r\ntty = tty_kref_get(current->signal->tty);\r\nspin_unlock_irqrestore(&current->sighand->siglock, flags);\r\nreturn tty;\r\n}\r\nvoid tty_default_fops(struct file_operations *fops)\r\n{\r\n*fops = tty_fops;\r\n}\r\nvoid __init console_init(void)\r\n{\r\ninitcall_t *call;\r\ntty_ldisc_begin();\r\ncall = __con_initcall_start;\r\nwhile (call < __con_initcall_end) {\r\n(*call)();\r\ncall++;\r\n}\r\n}\r\nstatic char *tty_devnode(struct device *dev, umode_t *mode)\r\n{\r\nif (!mode)\r\nreturn NULL;\r\nif (dev->devt == MKDEV(TTYAUX_MAJOR, 0) ||\r\ndev->devt == MKDEV(TTYAUX_MAJOR, 2))\r\n*mode = 0666;\r\nreturn NULL;\r\n}\r\nstatic int __init tty_class_init(void)\r\n{\r\ntty_class = class_create(THIS_MODULE, "tty");\r\nif (IS_ERR(tty_class))\r\nreturn PTR_ERR(tty_class);\r\ntty_class->devnode = tty_devnode;\r\nreturn 0;\r\n}\r\nstatic ssize_t show_cons_active(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct console *cs[16];\r\nint i = 0;\r\nstruct console *c;\r\nssize_t count = 0;\r\nconsole_lock();\r\nfor_each_console(c) {\r\nif (!c->device)\r\ncontinue;\r\nif (!c->write)\r\ncontinue;\r\nif ((c->flags & CON_ENABLED) == 0)\r\ncontinue;\r\ncs[i++] = c;\r\nif (i >= ARRAY_SIZE(cs))\r\nbreak;\r\n}\r\nwhile (i--)\r\ncount += sprintf(buf + count, "%s%d%c",\r\ncs[i]->name, cs[i]->index, i ? ' ':'\n');\r\nconsole_unlock();\r\nreturn count;\r\n}\r\nvoid console_sysfs_notify(void)\r\n{\r\nif (consdev)\r\nsysfs_notify(&consdev->kobj, NULL, "active");\r\n}\r\nint __init tty_init(void)\r\n{\r\ncdev_init(&tty_cdev, &tty_fops);\r\nif (cdev_add(&tty_cdev, MKDEV(TTYAUX_MAJOR, 0), 1) ||\r\nregister_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, "/dev/tty") < 0)\r\npanic("Couldn't register /dev/tty driver\n");\r\ndevice_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 0), NULL, "tty");\r\ncdev_init(&console_cdev, &console_fops);\r\nif (cdev_add(&console_cdev, MKDEV(TTYAUX_MAJOR, 1), 1) ||\r\nregister_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, "/dev/console") < 0)\r\npanic("Couldn't register /dev/console driver\n");\r\nconsdev = device_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 1), NULL,\r\n"console");\r\nif (IS_ERR(consdev))\r\nconsdev = NULL;\r\nelse\r\nWARN_ON(device_create_file(consdev, &dev_attr_active) < 0);\r\n#ifdef CONFIG_VT\r\nvty_init(&console_fops);\r\n#endif\r\nreturn 0;\r\n}
