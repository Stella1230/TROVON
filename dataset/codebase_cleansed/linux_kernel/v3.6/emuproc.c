static void snd_emu10k1_proc_spdif_status(struct snd_emu10k1 * emu,\r\nstruct snd_info_buffer *buffer,\r\nchar *title,\r\nint status_reg,\r\nint rate_reg)\r\n{\r\nstatic char *clkaccy[4] = { "1000ppm", "50ppm", "variable", "unknown" };\r\nstatic int samplerate[16] = { 44100, 1, 48000, 32000, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\r\nstatic char *channel[16] = { "unspec", "left", "right", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15" };\r\nstatic char *emphasis[8] = { "none", "50/15 usec 2 channel", "2", "3", "4", "5", "6", "7" };\r\nunsigned int status, rate = 0;\r\nstatus = snd_emu10k1_ptr_read(emu, status_reg, 0);\r\nsnd_iprintf(buffer, "\n%s\n", title);\r\nif (status != 0xffffffff) {\r\nsnd_iprintf(buffer, "Professional Mode : %s\n", (status & SPCS_PROFESSIONAL) ? "yes" : "no");\r\nsnd_iprintf(buffer, "Not Audio Data : %s\n", (status & SPCS_NOTAUDIODATA) ? "yes" : "no");\r\nsnd_iprintf(buffer, "Copyright : %s\n", (status & SPCS_COPYRIGHT) ? "yes" : "no");\r\nsnd_iprintf(buffer, "Emphasis : %s\n", emphasis[(status & SPCS_EMPHASISMASK) >> 3]);\r\nsnd_iprintf(buffer, "Mode : %i\n", (status & SPCS_MODEMASK) >> 6);\r\nsnd_iprintf(buffer, "Category Code : 0x%x\n", (status & SPCS_CATEGORYCODEMASK) >> 8);\r\nsnd_iprintf(buffer, "Generation Status : %s\n", status & SPCS_GENERATIONSTATUS ? "original" : "copy");\r\nsnd_iprintf(buffer, "Source Mask : %i\n", (status & SPCS_SOURCENUMMASK) >> 16);\r\nsnd_iprintf(buffer, "Channel Number : %s\n", channel[(status & SPCS_CHANNELNUMMASK) >> 20]);\r\nsnd_iprintf(buffer, "Sample Rate : %iHz\n", samplerate[(status & SPCS_SAMPLERATEMASK) >> 24]);\r\nsnd_iprintf(buffer, "Clock Accuracy : %s\n", clkaccy[(status & SPCS_CLKACCYMASK) >> 28]);\r\nif (rate_reg > 0) {\r\nrate = snd_emu10k1_ptr_read(emu, rate_reg, 0);\r\nsnd_iprintf(buffer, "S/PDIF Valid : %s\n", rate & SRCS_SPDIFVALID ? "on" : "off");\r\nsnd_iprintf(buffer, "S/PDIF Locked : %s\n", rate & SRCS_SPDIFLOCKED ? "on" : "off");\r\nsnd_iprintf(buffer, "Rate Locked : %s\n", rate & SRCS_RATELOCKED ? "on" : "off");\r\nsnd_iprintf(buffer, "Estimated Sample Rate : %d\n", ((rate & 0xFFFFF ) * 375) >> 11);\r\n}\r\n} else {\r\nsnd_iprintf(buffer, "No signal detected.\n");\r\n}\r\n}\r\nstatic void snd_emu10k1_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstatic char *creative_outs[32] = {\r\n"AC97 Left",\r\n"AC97 Right",\r\n"Optical IEC958 Left",\r\n"Optical IEC958 Right",\r\n"Center",\r\n"LFE",\r\n"Headphone Left",\r\n"Headphone Right",\r\n"Surround Left",\r\n"Surround Right",\r\n"PCM Capture Left",\r\n"PCM Capture Right",\r\n"MIC Capture",\r\n"AC97 Surround Left",\r\n"AC97 Surround Right",\r\n"???",\r\n"???",\r\n"Analog Center",\r\n"Analog LFE",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???"\r\n};\r\nstatic char *audigy_outs[64] = {\r\n"Digital Front Left",\r\n"Digital Front Right",\r\n"Digital Center",\r\n"Digital LEF",\r\n"Headphone Left",\r\n"Headphone Right",\r\n"Digital Rear Left",\r\n"Digital Rear Right",\r\n"Front Left",\r\n"Front Right",\r\n"Center",\r\n"LFE",\r\n"???",\r\n"???",\r\n"Rear Left",\r\n"Rear Right",\r\n"AC97 Front Left",\r\n"AC97 Front Right",\r\n"ADC Caputre Left",\r\n"ADC Capture Right",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"???",\r\n"FXBUS2_0",\r\n"FXBUS2_1",\r\n"FXBUS2_2",\r\n"FXBUS2_3",\r\n"FXBUS2_4",\r\n"FXBUS2_5",\r\n"FXBUS2_6",\r\n"FXBUS2_7",\r\n"FXBUS2_8",\r\n"FXBUS2_9",\r\n"FXBUS2_10",\r\n"FXBUS2_11",\r\n"FXBUS2_12",\r\n"FXBUS2_13",\r\n"FXBUS2_14",\r\n"FXBUS2_15",\r\n"FXBUS2_16",\r\n"FXBUS2_17",\r\n"FXBUS2_18",\r\n"FXBUS2_19",\r\n"FXBUS2_20",\r\n"FXBUS2_21",\r\n"FXBUS2_22",\r\n"FXBUS2_23",\r\n"FXBUS2_24",\r\n"FXBUS2_25",\r\n"FXBUS2_26",\r\n"FXBUS2_27",\r\n"FXBUS2_28",\r\n"FXBUS2_29",\r\n"FXBUS2_30",\r\n"FXBUS2_31"\r\n};\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nunsigned int val, val1;\r\nint nefx = emu->audigy ? 64 : 32;\r\nchar **outputs = emu->audigy ? audigy_outs : creative_outs;\r\nint idx;\r\nsnd_iprintf(buffer, "EMU10K1\n\n");\r\nsnd_iprintf(buffer, "Card : %s\n",\r\nemu->audigy ? "Audigy" : (emu->card_capabilities->ecard ? "EMU APS" : "Creative"));\r\nsnd_iprintf(buffer, "Internal TRAM (words) : 0x%x\n", emu->fx8010.itram_size);\r\nsnd_iprintf(buffer, "External TRAM (words) : 0x%x\n", (int)emu->fx8010.etram_pages.bytes / 2);\r\nsnd_iprintf(buffer, "\n");\r\nsnd_iprintf(buffer, "Effect Send Routing :\n");\r\nfor (idx = 0; idx < NUM_G; idx++) {\r\nval = emu->audigy ?\r\nsnd_emu10k1_ptr_read(emu, A_FXRT1, idx) :\r\nsnd_emu10k1_ptr_read(emu, FXRT, idx);\r\nval1 = emu->audigy ?\r\nsnd_emu10k1_ptr_read(emu, A_FXRT2, idx) :\r\n0;\r\nif (emu->audigy) {\r\nsnd_iprintf(buffer, "Ch%i: A=%i, B=%i, C=%i, D=%i, ",\r\nidx,\r\nval & 0x3f,\r\n(val >> 8) & 0x3f,\r\n(val >> 16) & 0x3f,\r\n(val >> 24) & 0x3f);\r\nsnd_iprintf(buffer, "E=%i, F=%i, G=%i, H=%i\n",\r\nval1 & 0x3f,\r\n(val1 >> 8) & 0x3f,\r\n(val1 >> 16) & 0x3f,\r\n(val1 >> 24) & 0x3f);\r\n} else {\r\nsnd_iprintf(buffer, "Ch%i: A=%i, B=%i, C=%i, D=%i\n",\r\nidx,\r\n(val >> 16) & 0x0f,\r\n(val >> 20) & 0x0f,\r\n(val >> 24) & 0x0f,\r\n(val >> 28) & 0x0f);\r\n}\r\n}\r\nsnd_iprintf(buffer, "\nCaptured FX Outputs :\n");\r\nfor (idx = 0; idx < nefx; idx++) {\r\nif (emu->efx_voices_mask[idx/32] & (1 << (idx%32)))\r\nsnd_iprintf(buffer, " Output %02i [%s]\n", idx, outputs[idx]);\r\n}\r\nsnd_iprintf(buffer, "\nAll FX Outputs :\n");\r\nfor (idx = 0; idx < (emu->audigy ? 64 : 32); idx++)\r\nsnd_iprintf(buffer, " Output %02i [%s]\n", idx, outputs[idx]);\r\n}\r\nstatic void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nu32 value;\r\nu32 value2;\r\nunsigned long flags;\r\nu32 rate;\r\nif (emu->card_capabilities->emu_model) {\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nsnd_emu1010_fpga_read(emu, 0x38, &value);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nif ((value & 0x1) == 0) {\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nsnd_emu1010_fpga_read(emu, 0x2a, &value);\r\nsnd_emu1010_fpga_read(emu, 0x2b, &value2);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nrate = 0x1770000 / (((value << 5) | value2)+1);\r\nsnd_iprintf(buffer, "ADAT Locked : %u\n", rate);\r\n} else {\r\nsnd_iprintf(buffer, "ADAT Unlocked\n");\r\n}\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nsnd_emu1010_fpga_read(emu, 0x20, &value);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nif ((value & 0x4) == 0) {\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nsnd_emu1010_fpga_read(emu, 0x28, &value);\r\nsnd_emu1010_fpga_read(emu, 0x29, &value2);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nrate = 0x1770000 / (((value << 5) | value2)+1);\r\nsnd_iprintf(buffer, "SPDIF Locked : %d\n", rate);\r\n} else {\r\nsnd_iprintf(buffer, "SPDIF Unlocked\n");\r\n}\r\n} else {\r\nsnd_emu10k1_proc_spdif_status(emu, buffer, "CD-ROM S/PDIF In", CDCS, CDSRCS);\r\nsnd_emu10k1_proc_spdif_status(emu, buffer, "Optical or Coax S/PDIF In", GPSCS, GPSRCS);\r\n}\r\n#if 0\r\nval = snd_emu10k1_ptr_read(emu, ZVSRCS, 0);\r\nsnd_iprintf(buffer, "\nZoomed Video\n");\r\nsnd_iprintf(buffer, "Rate Locked : %s\n", val & SRCS_RATELOCKED ? "on" : "off");\r\nsnd_iprintf(buffer, "Estimated Sample Rate : 0x%x\n", val & SRCS_ESTSAMPLERATE);\r\n#endif\r\n}\r\nstatic void snd_emu10k1_proc_rates_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstatic int samplerate[8] = { 44100, 48000, 96000, 192000, 4, 5, 6, 7 };\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nunsigned int val, tmp, n;\r\nval = snd_emu10k1_ptr20_read(emu, CAPTURE_RATE_STATUS, 0);\r\ntmp = (val >> 16) & 0x8;\r\nfor (n = 0; n < 4; n++) {\r\ntmp = val >> (16 + (n*4));\r\nif (tmp & 0x8) snd_iprintf(buffer, "Channel %d: Rate=%d\n", n, samplerate[tmp & 0x7]);\r\nelse snd_iprintf(buffer, "Channel %d: No input\n", n);\r\n}\r\n}\r\nstatic void snd_emu10k1_proc_acode_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nu32 pc;\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nsnd_iprintf(buffer, "FX8010 Instruction List '%s'\n", emu->fx8010.name);\r\nsnd_iprintf(buffer, " Code dump :\n");\r\nfor (pc = 0; pc < (emu->audigy ? 1024 : 512); pc++) {\r\nu32 low, high;\r\nlow = snd_emu10k1_efx_read(emu, pc * 2);\r\nhigh = snd_emu10k1_efx_read(emu, pc * 2 + 1);\r\nif (emu->audigy)\r\nsnd_iprintf(buffer, " OP(0x%02x, 0x%03x, 0x%03x, 0x%03x, 0x%03x) /* 0x%04x: 0x%08x%08x */\n",\r\n(high >> 24) & 0x0f,\r\n(high >> 12) & 0x7ff,\r\n(high >> 0) & 0x7ff,\r\n(low >> 12) & 0x7ff,\r\n(low >> 0) & 0x7ff,\r\npc,\r\nhigh, low);\r\nelse\r\nsnd_iprintf(buffer, " OP(0x%02x, 0x%03x, 0x%03x, 0x%03x, 0x%03x) /* 0x%04x: 0x%08x%08x */\n",\r\n(high >> 20) & 0x0f,\r\n(high >> 10) & 0x3ff,\r\n(high >> 0) & 0x3ff,\r\n(low >> 10) & 0x3ff,\r\n(low >> 0) & 0x3ff,\r\npc,\r\nhigh, low);\r\n}\r\n}\r\nstatic ssize_t snd_emu10k1_fx8010_read(struct snd_info_entry *entry,\r\nvoid *file_private_data,\r\nstruct file *file, char __user *buf,\r\nsize_t count, loff_t pos)\r\n{\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nunsigned int offset;\r\nint tram_addr = 0;\r\nunsigned int *tmp;\r\nlong res;\r\nunsigned int idx;\r\nif (!strcmp(entry->name, "fx8010_tram_addr")) {\r\noffset = TANKMEMADDRREGBASE;\r\ntram_addr = 1;\r\n} else if (!strcmp(entry->name, "fx8010_tram_data")) {\r\noffset = TANKMEMDATAREGBASE;\r\n} else if (!strcmp(entry->name, "fx8010_code")) {\r\noffset = emu->audigy ? A_MICROCODEBASE : MICROCODEBASE;\r\n} else {\r\noffset = emu->audigy ? A_FXGPREGBASE : FXGPREGBASE;\r\n}\r\ntmp = kmalloc(count + 8, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nfor (idx = 0; idx < ((pos & 3) + count + 3) >> 2; idx++) {\r\nunsigned int val;\r\nval = snd_emu10k1_ptr_read(emu, offset + idx + (pos >> 2), 0);\r\nif (tram_addr && emu->audigy) {\r\nval >>= 11;\r\nval |= snd_emu10k1_ptr_read(emu, 0x100 + idx + (pos >> 2), 0) << 20;\r\n}\r\ntmp[idx] = val;\r\n}\r\nif (copy_to_user(buf, ((char *)tmp) + (pos & 3), count))\r\nres = -EFAULT;\r\nelse\r\nres = count;\r\nkfree(tmp);\r\nreturn res;\r\n}\r\nstatic void snd_emu10k1_proc_voices_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nstruct snd_emu10k1_voice *voice;\r\nint idx;\r\nsnd_iprintf(buffer, "ch\tuse\tpcm\tefx\tsynth\tmidi\n");\r\nfor (idx = 0; idx < NUM_G; idx++) {\r\nvoice = &emu->voices[idx];\r\nsnd_iprintf(buffer, "%i\t%i\t%i\t%i\t%i\t%i\n",\r\nidx,\r\nvoice->use,\r\nvoice->pcm,\r\nvoice->efx,\r\nvoice->synth,\r\nvoice->midi);\r\n}\r\n}\r\nstatic void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nu32 value;\r\nunsigned long flags;\r\nint i;\r\nsnd_iprintf(buffer, "EMU1010 Registers:\n\n");\r\nfor(i = 0; i < 0x40; i+=1) {\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nsnd_emu1010_fpga_read(emu, i, &value);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nsnd_iprintf(buffer, "%02X: %08X, %02X\n", i, value, (value >> 8) & 0x7f);\r\n}\r\n}\r\nstatic void snd_emu_proc_io_reg_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nunsigned long value;\r\nunsigned long flags;\r\nint i;\r\nsnd_iprintf(buffer, "IO Registers:\n\n");\r\nfor(i = 0; i < 0x40; i+=4) {\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nvalue = inl(emu->port + i);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nsnd_iprintf(buffer, "%02X: %08lX\n", i, value);\r\n}\r\n}\r\nstatic void snd_emu_proc_io_reg_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nunsigned long flags;\r\nchar line[64];\r\nu32 reg, val;\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nif (sscanf(line, "%x %x", &reg, &val) != 2)\r\ncontinue;\r\nif (reg < 0x40 && val <= 0xffffffff) {\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutl(val, emu->port + (reg & 0xfffffffc));\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\n}\r\n}\r\nstatic unsigned int snd_ptr_read(struct snd_emu10k1 * emu,\r\nunsigned int iobase,\r\nunsigned int reg,\r\nunsigned int chn)\r\n{\r\nunsigned long flags;\r\nunsigned int regptr, val;\r\nregptr = (reg << 16) | chn;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutl(regptr, emu->port + iobase + PTR);\r\nval = inl(emu->port + iobase + DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nreturn val;\r\n}\r\nstatic void snd_ptr_write(struct snd_emu10k1 *emu,\r\nunsigned int iobase,\r\nunsigned int reg,\r\nunsigned int chn,\r\nunsigned int data)\r\n{\r\nunsigned int regptr;\r\nunsigned long flags;\r\nregptr = (reg << 16) | chn;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutl(regptr, emu->port + iobase + PTR);\r\noutl(data, emu->port + iobase + DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic void snd_emu_proc_ptr_reg_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer, int iobase, int offset, int length, int voices)\r\n{\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nunsigned long value;\r\nint i,j;\r\nif (offset+length > 0xa0) {\r\nsnd_iprintf(buffer, "Input values out of range\n");\r\nreturn;\r\n}\r\nsnd_iprintf(buffer, "Registers 0x%x\n", iobase);\r\nfor(i = offset; i < offset+length; i++) {\r\nsnd_iprintf(buffer, "%02X: ",i);\r\nfor (j = 0; j < voices; j++) {\r\nif(iobase == 0)\r\nvalue = snd_ptr_read(emu, 0, i, j);\r\nelse\r\nvalue = snd_ptr_read(emu, 0x20, i, j);\r\nsnd_iprintf(buffer, "%08lX ", value);\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nstatic void snd_emu_proc_ptr_reg_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer, int iobase)\r\n{\r\nstruct snd_emu10k1 *emu = entry->private_data;\r\nchar line[64];\r\nunsigned int reg, channel_id , val;\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nif (sscanf(line, "%x %x %x", &reg, &channel_id, &val) != 3)\r\ncontinue;\r\nif (reg < 0xa0 && val <= 0xffffffff && channel_id <= 3)\r\nsnd_ptr_write(emu, iobase, reg, channel_id, val);\r\n}\r\n}\r\nstatic void snd_emu_proc_ptr_reg_write00(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nsnd_emu_proc_ptr_reg_write(entry, buffer, 0);\r\n}\r\nstatic void snd_emu_proc_ptr_reg_write20(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nsnd_emu_proc_ptr_reg_write(entry, buffer, 0x20);\r\n}\r\nstatic void snd_emu_proc_ptr_reg_read00a(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nsnd_emu_proc_ptr_reg_read(entry, buffer, 0, 0, 0x40, 64);\r\n}\r\nstatic void snd_emu_proc_ptr_reg_read00b(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nsnd_emu_proc_ptr_reg_read(entry, buffer, 0, 0x40, 0x40, 64);\r\n}\r\nstatic void snd_emu_proc_ptr_reg_read20a(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nsnd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0, 0x40, 4);\r\n}\r\nstatic void snd_emu_proc_ptr_reg_read20b(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nsnd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0x40, 0x40, 4);\r\n}\r\nstatic void snd_emu_proc_ptr_reg_read20c(struct snd_info_entry *entry,\r\nstruct snd_info_buffer * buffer)\r\n{\r\nsnd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0x80, 0x20, 4);\r\n}\r\nint __devinit snd_emu10k1_proc_init(struct snd_emu10k1 * emu)\r\n{\r\nstruct snd_info_entry *entry;\r\n#ifdef CONFIG_SND_DEBUG\r\nif (emu->card_capabilities->emu_model) {\r\nif (! snd_card_proc_new(emu->card, "emu1010_regs", &entry))\r\nsnd_info_set_text_ops(entry, emu, snd_emu_proc_emu1010_reg_read);\r\n}\r\nif (! snd_card_proc_new(emu->card, "io_regs", &entry)) {\r\nsnd_info_set_text_ops(entry, emu, snd_emu_proc_io_reg_read);\r\nentry->c.text.write = snd_emu_proc_io_reg_write;\r\nentry->mode |= S_IWUSR;\r\n}\r\nif (! snd_card_proc_new(emu->card, "ptr_regs00a", &entry)) {\r\nsnd_info_set_text_ops(entry, emu, snd_emu_proc_ptr_reg_read00a);\r\nentry->c.text.write = snd_emu_proc_ptr_reg_write00;\r\nentry->mode |= S_IWUSR;\r\n}\r\nif (! snd_card_proc_new(emu->card, "ptr_regs00b", &entry)) {\r\nsnd_info_set_text_ops(entry, emu, snd_emu_proc_ptr_reg_read00b);\r\nentry->c.text.write = snd_emu_proc_ptr_reg_write00;\r\nentry->mode |= S_IWUSR;\r\n}\r\nif (! snd_card_proc_new(emu->card, "ptr_regs20a", &entry)) {\r\nsnd_info_set_text_ops(entry, emu, snd_emu_proc_ptr_reg_read20a);\r\nentry->c.text.write = snd_emu_proc_ptr_reg_write20;\r\nentry->mode |= S_IWUSR;\r\n}\r\nif (! snd_card_proc_new(emu->card, "ptr_regs20b", &entry)) {\r\nsnd_info_set_text_ops(entry, emu, snd_emu_proc_ptr_reg_read20b);\r\nentry->c.text.write = snd_emu_proc_ptr_reg_write20;\r\nentry->mode |= S_IWUSR;\r\n}\r\nif (! snd_card_proc_new(emu->card, "ptr_regs20c", &entry)) {\r\nsnd_info_set_text_ops(entry, emu, snd_emu_proc_ptr_reg_read20c);\r\nentry->c.text.write = snd_emu_proc_ptr_reg_write20;\r\nentry->mode |= S_IWUSR;\r\n}\r\n#endif\r\nif (! snd_card_proc_new(emu->card, "emu10k1", &entry))\r\nsnd_info_set_text_ops(entry, emu, snd_emu10k1_proc_read);\r\nif (emu->card_capabilities->emu10k2_chip) {\r\nif (! snd_card_proc_new(emu->card, "spdif-in", &entry))\r\nsnd_info_set_text_ops(entry, emu, snd_emu10k1_proc_spdif_read);\r\n}\r\nif (emu->card_capabilities->ca0151_chip) {\r\nif (! snd_card_proc_new(emu->card, "capture-rates", &entry))\r\nsnd_info_set_text_ops(entry, emu, snd_emu10k1_proc_rates_read);\r\n}\r\nif (! snd_card_proc_new(emu->card, "voices", &entry))\r\nsnd_info_set_text_ops(entry, emu, snd_emu10k1_proc_voices_read);\r\nif (! snd_card_proc_new(emu->card, "fx8010_gpr", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = emu;\r\nentry->mode = S_IFREG | S_IRUGO ;\r\nentry->size = emu->audigy ? A_TOTAL_SIZE_GPR : TOTAL_SIZE_GPR;\r\nentry->c.ops = &snd_emu10k1_proc_ops_fx8010;\r\n}\r\nif (! snd_card_proc_new(emu->card, "fx8010_tram_data", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = emu;\r\nentry->mode = S_IFREG | S_IRUGO ;\r\nentry->size = emu->audigy ? A_TOTAL_SIZE_TANKMEM_DATA : TOTAL_SIZE_TANKMEM_DATA ;\r\nentry->c.ops = &snd_emu10k1_proc_ops_fx8010;\r\n}\r\nif (! snd_card_proc_new(emu->card, "fx8010_tram_addr", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = emu;\r\nentry->mode = S_IFREG | S_IRUGO ;\r\nentry->size = emu->audigy ? A_TOTAL_SIZE_TANKMEM_ADDR : TOTAL_SIZE_TANKMEM_ADDR ;\r\nentry->c.ops = &snd_emu10k1_proc_ops_fx8010;\r\n}\r\nif (! snd_card_proc_new(emu->card, "fx8010_code", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_DATA;\r\nentry->private_data = emu;\r\nentry->mode = S_IFREG | S_IRUGO ;\r\nentry->size = emu->audigy ? A_TOTAL_SIZE_CODE : TOTAL_SIZE_CODE;\r\nentry->c.ops = &snd_emu10k1_proc_ops_fx8010;\r\n}\r\nif (! snd_card_proc_new(emu->card, "fx8010_acode", &entry)) {\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = emu;\r\nentry->mode = S_IFREG | S_IRUGO ;\r\nentry->c.text.read = snd_emu10k1_proc_acode_read;\r\n}\r\nreturn 0;\r\n}
