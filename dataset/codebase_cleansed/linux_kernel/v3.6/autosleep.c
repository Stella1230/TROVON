static void try_to_suspend(struct work_struct *work)\r\n{\r\nunsigned int initial_count, final_count;\r\nif (!pm_get_wakeup_count(&initial_count, true))\r\ngoto out;\r\nmutex_lock(&autosleep_lock);\r\nif (!pm_save_wakeup_count(initial_count)) {\r\nmutex_unlock(&autosleep_lock);\r\ngoto out;\r\n}\r\nif (autosleep_state == PM_SUSPEND_ON) {\r\nmutex_unlock(&autosleep_lock);\r\nreturn;\r\n}\r\nif (autosleep_state >= PM_SUSPEND_MAX)\r\nhibernate();\r\nelse\r\npm_suspend(autosleep_state);\r\nmutex_unlock(&autosleep_lock);\r\nif (!pm_get_wakeup_count(&final_count, false))\r\ngoto out;\r\nif (final_count == initial_count)\r\nschedule_timeout_uninterruptible(HZ / 2);\r\nout:\r\nqueue_up_suspend_work();\r\n}\r\nvoid queue_up_suspend_work(void)\r\n{\r\nif (!work_pending(&suspend_work) && autosleep_state > PM_SUSPEND_ON)\r\nqueue_work(autosleep_wq, &suspend_work);\r\n}\r\nsuspend_state_t pm_autosleep_state(void)\r\n{\r\nreturn autosleep_state;\r\n}\r\nint pm_autosleep_lock(void)\r\n{\r\nreturn mutex_lock_interruptible(&autosleep_lock);\r\n}\r\nvoid pm_autosleep_unlock(void)\r\n{\r\nmutex_unlock(&autosleep_lock);\r\n}\r\nint pm_autosleep_set_state(suspend_state_t state)\r\n{\r\n#ifndef CONFIG_HIBERNATION\r\nif (state >= PM_SUSPEND_MAX)\r\nreturn -EINVAL;\r\n#endif\r\n__pm_stay_awake(autosleep_ws);\r\nmutex_lock(&autosleep_lock);\r\nautosleep_state = state;\r\n__pm_relax(autosleep_ws);\r\nif (state > PM_SUSPEND_ON) {\r\npm_wakep_autosleep_enabled(true);\r\nqueue_up_suspend_work();\r\n} else {\r\npm_wakep_autosleep_enabled(false);\r\n}\r\nmutex_unlock(&autosleep_lock);\r\nreturn 0;\r\n}\r\nint __init pm_autosleep_init(void)\r\n{\r\nautosleep_ws = wakeup_source_register("autosleep");\r\nif (!autosleep_ws)\r\nreturn -ENOMEM;\r\nautosleep_wq = alloc_ordered_workqueue("autosleep", 0);\r\nif (autosleep_wq)\r\nreturn 0;\r\nwakeup_source_unregister(autosleep_ws);\r\nreturn -ENOMEM;\r\n}
