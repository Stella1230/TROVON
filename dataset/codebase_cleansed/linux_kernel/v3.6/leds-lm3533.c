static inline struct lm3533_led *to_lm3533_led(struct led_classdev *cdev)\r\n{\r\nreturn container_of(cdev, struct lm3533_led, cdev);\r\n}\r\nstatic inline int lm3533_led_get_ctrlbank_id(struct lm3533_led *led)\r\n{\r\nreturn led->id + 2;\r\n}\r\nstatic inline u8 lm3533_led_get_lv_reg(struct lm3533_led *led, u8 base)\r\n{\r\nreturn base + led->id;\r\n}\r\nstatic inline u8 lm3533_led_get_pattern(struct lm3533_led *led)\r\n{\r\nreturn led->id;\r\n}\r\nstatic inline u8 lm3533_led_get_pattern_reg(struct lm3533_led *led,\r\nu8 base)\r\n{\r\nreturn base + lm3533_led_get_pattern(led) * LM3533_REG_PATTERN_STEP;\r\n}\r\nstatic int lm3533_led_pattern_enable(struct lm3533_led *led, int enable)\r\n{\r\nu8 mask;\r\nu8 val;\r\nint pattern;\r\nint state;\r\nint ret = 0;\r\ndev_dbg(led->cdev.dev, "%s - %d\n", __func__, enable);\r\nmutex_lock(&led->mutex);\r\nstate = test_bit(LM3533_LED_FLAG_PATTERN_ENABLE, &led->flags);\r\nif ((enable && state) || (!enable && !state))\r\ngoto out;\r\npattern = lm3533_led_get_pattern(led);\r\nmask = 1 << (2 * pattern);\r\nif (enable)\r\nval = mask;\r\nelse\r\nval = 0;\r\nret = lm3533_update(led->lm3533, LM3533_REG_PATTERN_ENABLE, val, mask);\r\nif (ret) {\r\ndev_err(led->cdev.dev, "failed to enable pattern %d (%d)\n",\r\npattern, enable);\r\ngoto out;\r\n}\r\n__change_bit(LM3533_LED_FLAG_PATTERN_ENABLE, &led->flags);\r\nout:\r\nmutex_unlock(&led->mutex);\r\nreturn ret;\r\n}\r\nstatic void lm3533_led_work(struct work_struct *work)\r\n{\r\nstruct lm3533_led *led = container_of(work, struct lm3533_led, work);\r\ndev_dbg(led->cdev.dev, "%s - %u\n", __func__, led->new_brightness);\r\nif (led->new_brightness == 0)\r\nlm3533_led_pattern_enable(led, 0);\r\nlm3533_ctrlbank_set_brightness(&led->cb, led->new_brightness);\r\n}\r\nstatic void lm3533_led_set(struct led_classdev *cdev,\r\nenum led_brightness value)\r\n{\r\nstruct lm3533_led *led = to_lm3533_led(cdev);\r\ndev_dbg(led->cdev.dev, "%s - %d\n", __func__, value);\r\nled->new_brightness = value;\r\nschedule_work(&led->work);\r\n}\r\nstatic enum led_brightness lm3533_led_get(struct led_classdev *cdev)\r\n{\r\nstruct lm3533_led *led = to_lm3533_led(cdev);\r\nu8 val;\r\nint ret;\r\nret = lm3533_ctrlbank_get_brightness(&led->cb, &val);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(led->cdev.dev, "%s - %u\n", __func__, val);\r\nreturn val;\r\n}\r\nstatic u8 time_to_val(unsigned *t, unsigned t_min, unsigned t_step,\r\nu8 v_min, u8 v_max)\r\n{\r\nunsigned val;\r\nval = (*t + t_step / 2 - t_min) / t_step + v_min;\r\n*t = t_step * (val - v_min) + t_min;\r\nreturn (u8)val;\r\n}\r\nstatic u8 lm3533_led_get_hw_delay(unsigned *delay)\r\n{\r\nunsigned t;\r\nu8 val;\r\nt = *delay * 1000;\r\nif (t >= (LM3533_LED_DELAY2_TMAX + LM3533_LED_DELAY3_TMIN) / 2) {\r\nt = clamp(t, LM3533_LED_DELAY3_TMIN, LM3533_LED_DELAY3_TMAX);\r\nval = time_to_val(&t, LM3533_LED_DELAY3_TMIN,\r\nLM3533_LED_DELAY3_TSTEP,\r\nLM3533_LED_DELAY3_VMIN,\r\nLM3533_LED_DELAY3_VMAX);\r\n} else if (t >= (LM3533_LED_DELAY1_TMAX + LM3533_LED_DELAY2_TMIN) / 2) {\r\nt = clamp(t, LM3533_LED_DELAY2_TMIN, LM3533_LED_DELAY2_TMAX);\r\nval = time_to_val(&t, LM3533_LED_DELAY2_TMIN,\r\nLM3533_LED_DELAY2_TSTEP,\r\nLM3533_LED_DELAY2_VMIN,\r\nLM3533_LED_DELAY2_VMAX);\r\n} else {\r\nt = clamp(t, LM3533_LED_DELAY1_TMIN, LM3533_LED_DELAY1_TMAX);\r\nval = time_to_val(&t, LM3533_LED_DELAY1_TMIN,\r\nLM3533_LED_DELAY1_TSTEP,\r\nLM3533_LED_DELAY1_VMIN,\r\nLM3533_LED_DELAY1_VMAX);\r\n}\r\n*delay = (t + 500) / 1000;\r\nreturn val;\r\n}\r\nstatic u8 lm3533_led_delay_set(struct lm3533_led *led, u8 base,\r\nunsigned long *delay)\r\n{\r\nunsigned t;\r\nu8 val;\r\nu8 reg;\r\nint ret;\r\nt = (unsigned)*delay;\r\nif (base != LM3533_REG_PATTERN_LOW_TIME_BASE)\r\nt = min(t, LM3533_LED_DELAY2_TMAX / 1000);\r\nval = lm3533_led_get_hw_delay(&t);\r\ndev_dbg(led->cdev.dev, "%s - %lu: %u (0x%02x)\n", __func__,\r\n*delay, t, val);\r\nreg = lm3533_led_get_pattern_reg(led, base);\r\nret = lm3533_write(led->lm3533, reg, val);\r\nif (ret)\r\ndev_err(led->cdev.dev, "failed to set delay (%02x)\n", reg);\r\n*delay = t;\r\nreturn ret;\r\n}\r\nstatic int lm3533_led_delay_on_set(struct lm3533_led *led, unsigned long *t)\r\n{\r\nreturn lm3533_led_delay_set(led, LM3533_REG_PATTERN_HIGH_TIME_BASE, t);\r\n}\r\nstatic int lm3533_led_delay_off_set(struct lm3533_led *led, unsigned long *t)\r\n{\r\nreturn lm3533_led_delay_set(led, LM3533_REG_PATTERN_LOW_TIME_BASE, t);\r\n}\r\nstatic int lm3533_led_blink_set(struct led_classdev *cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct lm3533_led *led = to_lm3533_led(cdev);\r\nint ret;\r\ndev_dbg(led->cdev.dev, "%s - on = %lu, off = %lu\n", __func__,\r\n*delay_on, *delay_off);\r\nif (*delay_on > LM3533_LED_DELAY_ON_MAX ||\r\n*delay_off > LM3533_LED_DELAY_OFF_MAX)\r\nreturn -EINVAL;\r\nif (*delay_on == 0 && *delay_off == 0) {\r\n*delay_on = 500;\r\n*delay_off = 500;\r\n}\r\nret = lm3533_led_delay_on_set(led, delay_on);\r\nif (ret)\r\nreturn ret;\r\nret = lm3533_led_delay_off_set(led, delay_off);\r\nif (ret)\r\nreturn ret;\r\nreturn lm3533_led_pattern_enable(led, 1);\r\n}\r\nstatic ssize_t show_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", led->id);\r\n}\r\nstatic ssize_t show_risefalltime(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf, u8 base)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nssize_t ret;\r\nu8 reg;\r\nu8 val;\r\nreg = lm3533_led_get_pattern_reg(led, base);\r\nret = lm3533_read(led->lm3533, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%x\n", val);\r\n}\r\nstatic ssize_t show_risetime(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn show_risefalltime(dev, attr, buf,\r\nLM3533_REG_PATTERN_RISETIME_BASE);\r\n}\r\nstatic ssize_t show_falltime(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn show_risefalltime(dev, attr, buf,\r\nLM3533_REG_PATTERN_FALLTIME_BASE);\r\n}\r\nstatic ssize_t store_risefalltime(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len, u8 base)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nu8 val;\r\nu8 reg;\r\nint ret;\r\nif (kstrtou8(buf, 0, &val) || val > LM3533_RISEFALLTIME_MAX)\r\nreturn -EINVAL;\r\nreg = lm3533_led_get_pattern_reg(led, base);\r\nret = lm3533_write(led->lm3533, reg, val);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t store_risetime(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn store_risefalltime(dev, attr, buf, len,\r\nLM3533_REG_PATTERN_RISETIME_BASE);\r\n}\r\nstatic ssize_t store_falltime(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nreturn store_risefalltime(dev, attr, buf, len,\r\nLM3533_REG_PATTERN_FALLTIME_BASE);\r\n}\r\nstatic ssize_t show_als_channel(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nunsigned channel;\r\nu8 reg;\r\nu8 val;\r\nint ret;\r\nreg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\r\nret = lm3533_read(led->lm3533, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nchannel = (val & LM3533_REG_CTRLBANK_BCONF_ALS_CHANNEL_MASK) + 1;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", channel);\r\n}\r\nstatic ssize_t store_als_channel(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nunsigned channel;\r\nu8 reg;\r\nu8 val;\r\nu8 mask;\r\nint ret;\r\nif (kstrtouint(buf, 0, &channel))\r\nreturn -EINVAL;\r\nif (channel < LM3533_ALS_CHANNEL_LV_MIN ||\r\nchannel > LM3533_ALS_CHANNEL_LV_MAX)\r\nreturn -EINVAL;\r\nreg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\r\nmask = LM3533_REG_CTRLBANK_BCONF_ALS_CHANNEL_MASK;\r\nval = channel - 1;\r\nret = lm3533_update(led->lm3533, reg, val, mask);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t show_als_en(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nbool enable;\r\nu8 reg;\r\nu8 val;\r\nint ret;\r\nreg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\r\nret = lm3533_read(led->lm3533, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nenable = val & LM3533_REG_CTRLBANK_BCONF_ALS_EN_MASK;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", enable);\r\n}\r\nstatic ssize_t store_als_en(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nunsigned enable;\r\nu8 reg;\r\nu8 mask;\r\nu8 val;\r\nint ret;\r\nif (kstrtouint(buf, 0, &enable))\r\nreturn -EINVAL;\r\nreg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\r\nmask = LM3533_REG_CTRLBANK_BCONF_ALS_EN_MASK;\r\nif (enable)\r\nval = mask;\r\nelse\r\nval = 0;\r\nret = lm3533_update(led->lm3533, reg, val, mask);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t show_linear(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nu8 reg;\r\nu8 val;\r\nint linear;\r\nint ret;\r\nreg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\r\nret = lm3533_read(led->lm3533, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val & LM3533_REG_CTRLBANK_BCONF_MAPPING_MASK)\r\nlinear = 1;\r\nelse\r\nlinear = 0;\r\nreturn scnprintf(buf, PAGE_SIZE, "%x\n", linear);\r\n}\r\nstatic ssize_t store_linear(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nunsigned long linear;\r\nu8 reg;\r\nu8 mask;\r\nu8 val;\r\nint ret;\r\nif (kstrtoul(buf, 0, &linear))\r\nreturn -EINVAL;\r\nreg = lm3533_led_get_lv_reg(led, LM3533_REG_CTRLBANK_BCONF_BASE);\r\nmask = LM3533_REG_CTRLBANK_BCONF_MAPPING_MASK;\r\nif (linear)\r\nval = mask;\r\nelse\r\nval = 0;\r\nret = lm3533_update(led->lm3533, reg, val, mask);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nu8 val;\r\nint ret;\r\nret = lm3533_ctrlbank_get_pwm(&led->cb, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", val);\r\n}\r\nstatic ssize_t store_pwm(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\nu8 val;\r\nint ret;\r\nif (kstrtou8(buf, 0, &val))\r\nreturn -EINVAL;\r\nret = lm3533_ctrlbank_set_pwm(&led->cb, val);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic umode_t lm3533_led_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct lm3533_led *led = to_lm3533_led(led_cdev);\r\numode_t mode = attr->mode;\r\nif (attr == &dev_attr_als_channel.attr ||\r\nattr == &dev_attr_als_en.attr) {\r\nif (!led->lm3533->have_als)\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic int __devinit lm3533_led_setup(struct lm3533_led *led,\r\nstruct lm3533_led_platform_data *pdata)\r\n{\r\nint ret;\r\nret = lm3533_ctrlbank_set_max_current(&led->cb, pdata->max_current);\r\nif (ret)\r\nreturn ret;\r\nreturn lm3533_ctrlbank_set_pwm(&led->cb, pdata->pwm);\r\n}\r\nstatic int __devinit lm3533_led_probe(struct platform_device *pdev)\r\n{\r\nstruct lm3533 *lm3533;\r\nstruct lm3533_led_platform_data *pdata;\r\nstruct lm3533_led *led;\r\nint ret;\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nlm3533 = dev_get_drvdata(pdev->dev.parent);\r\nif (!lm3533)\r\nreturn -EINVAL;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdev->id < 0 || pdev->id >= LM3533_LVCTRLBANK_COUNT) {\r\ndev_err(&pdev->dev, "illegal LED id %d\n", pdev->id);\r\nreturn -EINVAL;\r\n}\r\nled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nled->lm3533 = lm3533;\r\nled->cdev.name = pdata->name;\r\nled->cdev.default_trigger = pdata->default_trigger;\r\nled->cdev.brightness_set = lm3533_led_set;\r\nled->cdev.brightness_get = lm3533_led_get;\r\nled->cdev.blink_set = lm3533_led_blink_set;\r\nled->cdev.brightness = LED_OFF;\r\nled->id = pdev->id;\r\nmutex_init(&led->mutex);\r\nINIT_WORK(&led->work, lm3533_led_work);\r\nled->cb.lm3533 = lm3533;\r\nled->cb.id = lm3533_led_get_ctrlbank_id(led);\r\nled->cb.dev = lm3533->dev;\r\nplatform_set_drvdata(pdev, led);\r\nret = led_classdev_register(pdev->dev.parent, &led->cdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register LED %d\n", pdev->id);\r\nreturn ret;\r\n}\r\nled->cb.dev = led->cdev.dev;\r\nret = sysfs_create_group(&led->cdev.dev->kobj,\r\n&lm3533_led_attribute_group);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to create sysfs attributes\n");\r\ngoto err_unregister;\r\n}\r\nret = lm3533_led_setup(led, pdata);\r\nif (ret)\r\ngoto err_sysfs_remove;\r\nret = lm3533_ctrlbank_enable(&led->cb);\r\nif (ret)\r\ngoto err_sysfs_remove;\r\nreturn 0;\r\nerr_sysfs_remove:\r\nsysfs_remove_group(&led->cdev.dev->kobj, &lm3533_led_attribute_group);\r\nerr_unregister:\r\nled_classdev_unregister(&led->cdev);\r\nflush_work_sync(&led->work);\r\nreturn ret;\r\n}\r\nstatic int __devexit lm3533_led_remove(struct platform_device *pdev)\r\n{\r\nstruct lm3533_led *led = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nlm3533_ctrlbank_disable(&led->cb);\r\nsysfs_remove_group(&led->cdev.dev->kobj, &lm3533_led_attribute_group);\r\nled_classdev_unregister(&led->cdev);\r\nflush_work_sync(&led->work);\r\nreturn 0;\r\n}\r\nstatic void lm3533_led_shutdown(struct platform_device *pdev)\r\n{\r\nstruct lm3533_led *led = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nlm3533_ctrlbank_disable(&led->cb);\r\nlm3533_led_set(&led->cdev, LED_OFF);\r\nflush_work_sync(&led->work);\r\n}
