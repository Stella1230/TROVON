static unsigned int snd_emu10k1x_ptr_read(struct emu10k1x * emu,\r\nunsigned int reg,\r\nunsigned int chn)\r\n{\r\nunsigned long flags;\r\nunsigned int regptr, val;\r\nregptr = (reg << 16) | chn;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutl(regptr, emu->port + PTR);\r\nval = inl(emu->port + DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nreturn val;\r\n}\r\nstatic void snd_emu10k1x_ptr_write(struct emu10k1x *emu,\r\nunsigned int reg,\r\nunsigned int chn,\r\nunsigned int data)\r\n{\r\nunsigned int regptr;\r\nunsigned long flags;\r\nregptr = (reg << 16) | chn;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutl(regptr, emu->port + PTR);\r\noutl(data, emu->port + DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic void snd_emu10k1x_intr_enable(struct emu10k1x *emu, unsigned int intrenb)\r\n{\r\nunsigned long flags;\r\nunsigned int intr_enable;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nintr_enable = inl(emu->port + INTE) | intrenb;\r\noutl(intr_enable, emu->port + INTE);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic void snd_emu10k1x_intr_disable(struct emu10k1x *emu, unsigned int intrenb)\r\n{\r\nunsigned long flags;\r\nunsigned int intr_enable;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nintr_enable = inl(emu->port + INTE) & ~intrenb;\r\noutl(intr_enable, emu->port + INTE);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic void snd_emu10k1x_gpio_write(struct emu10k1x *emu, unsigned int value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutl(value, emu->port + GPIO);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic void snd_emu10k1x_pcm_free_substream(struct snd_pcm_runtime *runtime)\r\n{\r\nkfree(runtime->private_data);\r\n}\r\nstatic void snd_emu10k1x_pcm_interrupt(struct emu10k1x *emu, struct emu10k1x_voice *voice)\r\n{\r\nstruct emu10k1x_pcm *epcm;\r\nif ((epcm = voice->epcm) == NULL)\r\nreturn;\r\nif (epcm->substream == NULL)\r\nreturn;\r\n#if 0\r\nsnd_printk(KERN_INFO "IRQ: position = 0x%x, period = 0x%x, size = 0x%x\n",\r\nepcm->substream->ops->pointer(epcm->substream),\r\nsnd_pcm_lib_period_bytes(epcm->substream),\r\nsnd_pcm_lib_buffer_bytes(epcm->substream));\r\n#endif\r\nsnd_pcm_period_elapsed(epcm->substream);\r\n}\r\nstatic int snd_emu10k1x_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct emu10k1x *chip = snd_pcm_substream_chip(substream);\r\nstruct emu10k1x_pcm *epcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0) {\r\nreturn err;\r\n}\r\nif ((err = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64)) < 0)\r\nreturn err;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = chip;\r\nepcm->substream = substream;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_emu10k1x_pcm_free_substream;\r\nruntime->hw = snd_emu10k1x_playback_hw;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm = runtime->private_data;\r\nif (! epcm->voice) {\r\nepcm->voice = &epcm->emu->voices[substream->pcm->device];\r\nepcm->voice->use = 1;\r\nepcm->voice->epcm = epcm;\r\n}\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_emu10k1x_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm;\r\nif (runtime->private_data == NULL)\r\nreturn 0;\r\nepcm = runtime->private_data;\r\nif (epcm->voice) {\r\nepcm->voice->use = 0;\r\nepcm->voice->epcm = NULL;\r\nepcm->voice = NULL;\r\n}\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_emu10k1x_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm = runtime->private_data;\r\nint voice = epcm->voice->number;\r\nu32 *table_base = (u32 *)(emu->dma_buffer.area+1024*voice);\r\nu32 period_size_bytes = frames_to_bytes(runtime, runtime->period_size);\r\nint i;\r\nfor(i = 0; i < runtime->periods; i++) {\r\n*table_base++=runtime->dma_addr+(i*period_size_bytes);\r\n*table_base++=period_size_bytes<<16;\r\n}\r\nsnd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_ADDR, voice, emu->dma_buffer.addr+1024*voice);\r\nsnd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_SIZE, voice, (runtime->periods - 1) << 19);\r\nsnd_emu10k1x_ptr_write(emu, PLAYBACK_LIST_PTR, voice, 0);\r\nsnd_emu10k1x_ptr_write(emu, PLAYBACK_POINTER, voice, 0);\r\nsnd_emu10k1x_ptr_write(emu, PLAYBACK_UNKNOWN1, voice, 0);\r\nsnd_emu10k1x_ptr_write(emu, PLAYBACK_UNKNOWN2, voice, 0);\r\nsnd_emu10k1x_ptr_write(emu, PLAYBACK_DMA_ADDR, voice, runtime->dma_addr);\r\nsnd_emu10k1x_ptr_write(emu, PLAYBACK_PERIOD_SIZE, voice, frames_to_bytes(runtime, runtime->period_size)<<16);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_pcm_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm = runtime->private_data;\r\nint channel = epcm->voice->number;\r\nint result = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif(runtime->periods == 2)\r\nsnd_emu10k1x_intr_enable(emu, (INTE_CH_0_LOOP | INTE_CH_0_HALF_LOOP) << channel);\r\nelse\r\nsnd_emu10k1x_intr_enable(emu, INTE_CH_0_LOOP << channel);\r\nepcm->running = 1;\r\nsnd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0)|(TRIGGER_CHANNEL_0<<channel));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nepcm->running = 0;\r\nsnd_emu10k1x_intr_disable(emu, (INTE_CH_0_LOOP | INTE_CH_0_HALF_LOOP) << channel);\r\nsnd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0) & ~(TRIGGER_CHANNEL_0<<channel));\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_emu10k1x_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm = runtime->private_data;\r\nint channel = epcm->voice->number;\r\nsnd_pcm_uframes_t ptr = 0, ptr1 = 0, ptr2= 0,ptr3 = 0,ptr4 = 0;\r\nif (!epcm->running)\r\nreturn 0;\r\nptr3 = snd_emu10k1x_ptr_read(emu, PLAYBACK_LIST_PTR, channel);\r\nptr1 = snd_emu10k1x_ptr_read(emu, PLAYBACK_POINTER, channel);\r\nptr4 = snd_emu10k1x_ptr_read(emu, PLAYBACK_LIST_PTR, channel);\r\nif(ptr4 == 0 && ptr1 == frames_to_bytes(runtime, runtime->buffer_size))\r\nreturn 0;\r\nif (ptr3 != ptr4)\r\nptr1 = snd_emu10k1x_ptr_read(emu, PLAYBACK_POINTER, channel);\r\nptr2 = bytes_to_frames(runtime, ptr1);\r\nptr2 += (ptr4 >> 3) * runtime->period_size;\r\nptr = ptr2;\r\nif (ptr >= runtime->buffer_size)\r\nptr -= runtime->buffer_size;\r\nreturn ptr;\r\n}\r\nstatic int snd_emu10k1x_pcm_open_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct emu10k1x *chip = snd_pcm_substream_chip(substream);\r\nstruct emu10k1x_pcm *epcm;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64)) < 0)\r\nreturn err;\r\nepcm = kzalloc(sizeof(*epcm), GFP_KERNEL);\r\nif (epcm == NULL)\r\nreturn -ENOMEM;\r\nepcm->emu = chip;\r\nepcm->substream = substream;\r\nruntime->private_data = epcm;\r\nruntime->private_free = snd_emu10k1x_pcm_free_substream;\r\nruntime->hw = snd_emu10k1x_capture_hw;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_pcm_close_capture(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_pcm_hw_params_capture(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm = runtime->private_data;\r\nif (! epcm->voice) {\r\nif (epcm->emu->capture_voice.use)\r\nreturn -EBUSY;\r\nepcm->voice = &epcm->emu->capture_voice;\r\nepcm->voice->epcm = epcm;\r\nepcm->voice->use = 1;\r\n}\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_emu10k1x_pcm_hw_free_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm;\r\nif (runtime->private_data == NULL)\r\nreturn 0;\r\nepcm = runtime->private_data;\r\nif (epcm->voice) {\r\nepcm->voice->use = 0;\r\nepcm->voice->epcm = NULL;\r\nepcm->voice = NULL;\r\n}\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_emu10k1x_pcm_prepare_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_emu10k1x_ptr_write(emu, CAPTURE_DMA_ADDR, 0, runtime->dma_addr);\r\nsnd_emu10k1x_ptr_write(emu, CAPTURE_BUFFER_SIZE, 0, frames_to_bytes(runtime, runtime->buffer_size)<<16);\r\nsnd_emu10k1x_ptr_write(emu, CAPTURE_POINTER, 0, 0);\r\nsnd_emu10k1x_ptr_write(emu, CAPTURE_UNKNOWN, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_pcm_trigger_capture(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm = runtime->private_data;\r\nint result = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsnd_emu10k1x_intr_enable(emu, INTE_CAP_0_LOOP |\r\nINTE_CAP_0_HALF_LOOP);\r\nsnd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0)|TRIGGER_CAPTURE);\r\nepcm->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nepcm->running = 0;\r\nsnd_emu10k1x_intr_disable(emu, INTE_CAP_0_LOOP |\r\nINTE_CAP_0_HALF_LOOP);\r\nsnd_emu10k1x_ptr_write(emu, TRIGGER_CHANNEL, 0, snd_emu10k1x_ptr_read(emu, TRIGGER_CHANNEL, 0) & ~(TRIGGER_CAPTURE));\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_emu10k1x_pcm_pointer_capture(struct snd_pcm_substream *substream)\r\n{\r\nstruct emu10k1x *emu = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct emu10k1x_pcm *epcm = runtime->private_data;\r\nsnd_pcm_uframes_t ptr;\r\nif (!epcm->running)\r\nreturn 0;\r\nptr = bytes_to_frames(runtime, snd_emu10k1x_ptr_read(emu, CAPTURE_POINTER, 0));\r\nif (ptr >= runtime->buffer_size)\r\nptr -= runtime->buffer_size;\r\nreturn ptr;\r\n}\r\nstatic unsigned short snd_emu10k1x_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct emu10k1x *emu = ac97->private_data;\r\nunsigned long flags;\r\nunsigned short val;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutb(reg, emu->port + AC97ADDRESS);\r\nval = inw(emu->port + AC97DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nreturn val;\r\n}\r\nstatic void snd_emu10k1x_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg, unsigned short val)\r\n{\r\nstruct emu10k1x *emu = ac97->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\noutb(reg, emu->port + AC97ADDRESS);\r\noutw(val, emu->port + AC97DATA);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\n}\r\nstatic int snd_emu10k1x_ac97(struct emu10k1x *chip)\r\n{\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_emu10k1x_ac97_write,\r\n.read = snd_emu10k1x_ac97_read,\r\n};\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)\r\nreturn err;\r\npbus->no_vra = 1;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.scaps = AC97_SCAP_NO_SPDIF;\r\nreturn snd_ac97_mixer(pbus, &ac97, &chip->ac97);\r\n}\r\nstatic int snd_emu10k1x_free(struct emu10k1x *chip)\r\n{\r\nsnd_emu10k1x_ptr_write(chip, TRIGGER_CHANNEL, 0, 0);\r\noutl(0, chip->port + INTE);\r\noutl(HCFG_LOCKSOUNDCACHE, chip->port + HCFG);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nrelease_and_free_resource(chip->res_port);\r\nif (chip->dma_buffer.area) {\r\nsnd_dma_free_pages(&chip->dma_buffer);\r\n}\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_dev_free(struct snd_device *device)\r\n{\r\nstruct emu10k1x *chip = device->device_data;\r\nreturn snd_emu10k1x_free(chip);\r\n}\r\nstatic irqreturn_t snd_emu10k1x_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned int status;\r\nstruct emu10k1x *chip = dev_id;\r\nstruct emu10k1x_voice *pvoice = chip->voices;\r\nint i;\r\nint mask;\r\nstatus = inl(chip->port + IPR);\r\nif (! status)\r\nreturn IRQ_NONE;\r\nif (status & (IPR_CAP_0_LOOP | IPR_CAP_0_HALF_LOOP)) {\r\nstruct emu10k1x_voice *cap_voice = &chip->capture_voice;\r\nif (cap_voice->use)\r\nsnd_emu10k1x_pcm_interrupt(chip, cap_voice);\r\nelse\r\nsnd_emu10k1x_intr_disable(chip,\r\nINTE_CAP_0_LOOP |\r\nINTE_CAP_0_HALF_LOOP);\r\n}\r\nmask = IPR_CH_0_LOOP|IPR_CH_0_HALF_LOOP;\r\nfor (i = 0; i < 3; i++) {\r\nif (status & mask) {\r\nif (pvoice->use)\r\nsnd_emu10k1x_pcm_interrupt(chip, pvoice);\r\nelse\r\nsnd_emu10k1x_intr_disable(chip, mask);\r\n}\r\npvoice++;\r\nmask <<= 1;\r\n}\r\nif (status & (IPR_MIDITRANSBUFEMPTY|IPR_MIDIRECVBUFEMPTY)) {\r\nif (chip->midi.interrupt)\r\nchip->midi.interrupt(chip, status);\r\nelse\r\nsnd_emu10k1x_intr_disable(chip, INTE_MIDITXENABLE|INTE_MIDIRXENABLE);\r\n}\r\noutl(status, chip->port + IPR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit snd_emu10k1x_pcm(struct emu10k1x *emu, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nint capture = 0;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif (device == 0)\r\ncapture = 1;\r\nif ((err = snd_pcm_new(emu->card, "emu10k1x", device, 1, capture, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = emu;\r\nswitch(device) {\r\ncase 0:\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1x_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_emu10k1x_capture_ops);\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_emu10k1x_playback_ops);\r\nbreak;\r\n}\r\npcm->info_flags = 0;\r\nswitch(device) {\r\ncase 0:\r\nstrcpy(pcm->name, "EMU10K1X Front");\r\nbreak;\r\ncase 1:\r\nstrcpy(pcm->name, "EMU10K1X Rear");\r\nbreak;\r\ncase 2:\r\nstrcpy(pcm->name, "EMU10K1X Center/LFE");\r\nbreak;\r\n}\r\nemu->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(emu->pci),\r\n32*1024, 32*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_emu10k1x_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct emu10k1x **rchip)\r\n{\r\nstruct emu10k1x *chip;\r\nint err;\r\nint ch;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_emu10k1x_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {\r\nsnd_printk(KERN_ERR "error to set 28bit mask DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nspin_lock_init(&chip->emu_lock);\r\nspin_lock_init(&chip->voice_lock);\r\nchip->port = pci_resource_start(pci, 0);\r\nif ((chip->res_port = request_region(chip->port, 8,\r\n"EMU10K1X")) == NULL) {\r\nsnd_printk(KERN_ERR "emu10k1x: cannot allocate the port 0x%lx\n", chip->port);\r\nsnd_emu10k1x_free(chip);\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(pci->irq, snd_emu10k1x_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip)) {\r\nsnd_printk(KERN_ERR "emu10k1x: cannot grab irq %d\n", pci->irq);\r\nsnd_emu10k1x_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nif(snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\n4 * 1024, &chip->dma_buffer) < 0) {\r\nsnd_emu10k1x_free(chip);\r\nreturn -ENOMEM;\r\n}\r\npci_set_master(pci);\r\nchip->revision = pci->revision;\r\npci_read_config_dword(pci, PCI_SUBSYSTEM_VENDOR_ID, &chip->serial);\r\npci_read_config_word(pci, PCI_SUBSYSTEM_ID, &chip->model);\r\nsnd_printk(KERN_INFO "Model %04x Rev %08x Serial %08x\n", chip->model,\r\nchip->revision, chip->serial);\r\noutl(0, chip->port + INTE);\r\nfor(ch = 0; ch < 3; ch++) {\r\nchip->voices[ch].emu = chip;\r\nchip->voices[ch].number = ch;\r\n}\r\nsnd_emu10k1x_ptr_write(chip, SPCS0, 0,\r\nchip->spdif_bits[0] =\r\nSPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\r\nSPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\r\nSPCS_GENERATIONSTATUS | 0x00001200 |\r\n0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);\r\nsnd_emu10k1x_ptr_write(chip, SPCS1, 0,\r\nchip->spdif_bits[1] =\r\nSPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\r\nSPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\r\nSPCS_GENERATIONSTATUS | 0x00001200 |\r\n0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);\r\nsnd_emu10k1x_ptr_write(chip, SPCS2, 0,\r\nchip->spdif_bits[2] =\r\nSPCS_CLKACCY_1000PPM | SPCS_SAMPLERATE_48 |\r\nSPCS_CHANNELNUM_LEFT | SPCS_SOURCENUM_UNSPEC |\r\nSPCS_GENERATIONSTATUS | 0x00001200 |\r\n0x00000000 | SPCS_EMPHASIS_NONE | SPCS_COPYRIGHT);\r\nsnd_emu10k1x_ptr_write(chip, SPDIF_SELECT, 0, 0x700);\r\nsnd_emu10k1x_ptr_write(chip, ROUTING, 0, 0x1003F);\r\nsnd_emu10k1x_gpio_write(chip, 0x1080);\r\noutl(HCFG_LOCKSOUNDCACHE|HCFG_AUDIOENABLE, chip->port+HCFG);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,\r\nchip, &ops)) < 0) {\r\nsnd_emu10k1x_free(chip);\r\nreturn err;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic void snd_emu10k1x_proc_reg_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct emu10k1x *emu = entry->private_data;\r\nunsigned long value,value1,value2;\r\nunsigned long flags;\r\nint i;\r\nsnd_iprintf(buffer, "Registers:\n\n");\r\nfor(i = 0; i < 0x20; i+=4) {\r\nspin_lock_irqsave(&emu->emu_lock, flags);\r\nvalue = inl(emu->port + i);\r\nspin_unlock_irqrestore(&emu->emu_lock, flags);\r\nsnd_iprintf(buffer, "Register %02X: %08lX\n", i, value);\r\n}\r\nsnd_iprintf(buffer, "\nRegisters\n\n");\r\nfor(i = 0; i <= 0x48; i++) {\r\nvalue = snd_emu10k1x_ptr_read(emu, i, 0);\r\nif(i < 0x10 || (i >= 0x20 && i < 0x40)) {\r\nvalue1 = snd_emu10k1x_ptr_read(emu, i, 1);\r\nvalue2 = snd_emu10k1x_ptr_read(emu, i, 2);\r\nsnd_iprintf(buffer, "%02X: %08lX %08lX %08lX\n", i, value, value1, value2);\r\n} else {\r\nsnd_iprintf(buffer, "%02X: %08lX\n", i, value);\r\n}\r\n}\r\n}\r\nstatic void snd_emu10k1x_proc_reg_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct emu10k1x *emu = entry->private_data;\r\nchar line[64];\r\nunsigned int reg, channel_id , val;\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nif (sscanf(line, "%x %x %x", &reg, &channel_id, &val) != 3)\r\ncontinue;\r\nif (reg < 0x49 && val <= 0xffffffff && channel_id <= 2)\r\nsnd_emu10k1x_ptr_write(emu, reg, channel_id, val);\r\n}\r\n}\r\nstatic int __devinit snd_emu10k1x_proc_init(struct emu10k1x * emu)\r\n{\r\nstruct snd_info_entry *entry;\r\nif(! snd_card_proc_new(emu->card, "emu10k1x_regs", &entry)) {\r\nsnd_info_set_text_ops(entry, emu, snd_emu10k1x_proc_reg_read);\r\nentry->c.text.write = snd_emu10k1x_proc_reg_write;\r\nentry->mode |= S_IWUSR;\r\nentry->private_data = emu;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_shared_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct emu10k1x *emu = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = (snd_emu10k1x_ptr_read(emu, SPDIF_SELECT, 0) == 0x700) ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_shared_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct emu10k1x *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change = 0;\r\nval = ucontrol->value.integer.value[0] ;\r\nif (val) {\r\nsnd_emu10k1x_ptr_write(emu, SPDIF_SELECT, 0, 0x000);\r\nsnd_emu10k1x_ptr_write(emu, ROUTING, 0, 0x700);\r\nsnd_emu10k1x_gpio_write(emu, 0x1000);\r\n} else {\r\nsnd_emu10k1x_ptr_write(emu, SPDIF_SELECT, 0, 0x700);\r\nsnd_emu10k1x_ptr_write(emu, ROUTING, 0, 0x1003F);\r\nsnd_emu10k1x_gpio_write(emu, 0x1080);\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_emu10k1x_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct emu10k1x *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nucontrol->value.iec958.status[0] = (emu->spdif_bits[idx] >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (emu->spdif_bits[idx] >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (emu->spdif_bits[idx] >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (emu->spdif_bits[idx] >> 24) & 0xff;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_spdif_get_mask(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct emu10k1x *emu = snd_kcontrol_chip(kcontrol);\r\nunsigned int idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nint change;\r\nunsigned int val;\r\nval = (ucontrol->value.iec958.status[0] << 0) |\r\n(ucontrol->value.iec958.status[1] << 8) |\r\n(ucontrol->value.iec958.status[2] << 16) |\r\n(ucontrol->value.iec958.status[3] << 24);\r\nchange = val != emu->spdif_bits[idx];\r\nif (change) {\r\nsnd_emu10k1x_ptr_write(emu, SPCS0 + idx, 0, val);\r\nemu->spdif_bits[idx] = val;\r\n}\r\nreturn change;\r\n}\r\nstatic int __devinit snd_emu10k1x_mixer(struct emu10k1x *emu)\r\n{\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_card *card = emu->card;\r\nif ((kctl = snd_ctl_new1(&snd_emu10k1x_spdif_mask_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nif ((kctl = snd_ctl_new1(&snd_emu10k1x_shared_spdif, emu)) == NULL)\r\nreturn -ENOMEM;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nif ((kctl = snd_ctl_new1(&snd_emu10k1x_spdif_control, emu)) == NULL)\r\nreturn -ENOMEM;\r\nif ((err = snd_ctl_add(card, kctl)))\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic inline unsigned char mpu401_read(struct emu10k1x *emu, struct emu10k1x_midi *mpu, int idx)\r\n{\r\nreturn (unsigned char)snd_emu10k1x_ptr_read(emu, mpu->port + idx, 0);\r\n}\r\nstatic inline void mpu401_write(struct emu10k1x *emu, struct emu10k1x_midi *mpu, int data, int idx)\r\n{\r\nsnd_emu10k1x_ptr_write(emu, mpu->port + idx, 0, data);\r\n}\r\nstatic void mpu401_clear_rx(struct emu10k1x *emu, struct emu10k1x_midi *mpu)\r\n{\r\nint timeout = 100000;\r\nfor (; timeout > 0 && mpu401_input_avail(emu, mpu); timeout--)\r\nmpu401_read_data(emu, mpu);\r\n#ifdef CONFIG_SND_DEBUG\r\nif (timeout <= 0)\r\nsnd_printk(KERN_ERR "cmd: clear rx timeout (status = 0x%x)\n", mpu401_read_stat(emu, mpu));\r\n#endif\r\n}\r\nstatic void do_emu10k1x_midi_interrupt(struct emu10k1x *emu,\r\nstruct emu10k1x_midi *midi, unsigned int status)\r\n{\r\nunsigned char byte;\r\nif (midi->rmidi == NULL) {\r\nsnd_emu10k1x_intr_disable(emu, midi->tx_enable | midi->rx_enable);\r\nreturn;\r\n}\r\nspin_lock(&midi->input_lock);\r\nif ((status & midi->ipr_rx) && mpu401_input_avail(emu, midi)) {\r\nif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {\r\nmpu401_clear_rx(emu, midi);\r\n} else {\r\nbyte = mpu401_read_data(emu, midi);\r\nif (midi->substream_input)\r\nsnd_rawmidi_receive(midi->substream_input, &byte, 1);\r\n}\r\n}\r\nspin_unlock(&midi->input_lock);\r\nspin_lock(&midi->output_lock);\r\nif ((status & midi->ipr_tx) && mpu401_output_ready(emu, midi)) {\r\nif (midi->substream_output &&\r\nsnd_rawmidi_transmit(midi->substream_output, &byte, 1) == 1) {\r\nmpu401_write_data(emu, midi, byte);\r\n} else {\r\nsnd_emu10k1x_intr_disable(emu, midi->tx_enable);\r\n}\r\n}\r\nspin_unlock(&midi->output_lock);\r\n}\r\nstatic void snd_emu10k1x_midi_interrupt(struct emu10k1x *emu, unsigned int status)\r\n{\r\ndo_emu10k1x_midi_interrupt(emu, &emu->midi, status);\r\n}\r\nstatic int snd_emu10k1x_midi_cmd(struct emu10k1x * emu,\r\nstruct emu10k1x_midi *midi, unsigned char cmd, int ack)\r\n{\r\nunsigned long flags;\r\nint timeout, ok;\r\nspin_lock_irqsave(&midi->input_lock, flags);\r\nmpu401_write_data(emu, midi, 0x00);\r\nmpu401_write_cmd(emu, midi, cmd);\r\nif (ack) {\r\nok = 0;\r\ntimeout = 10000;\r\nwhile (!ok && timeout-- > 0) {\r\nif (mpu401_input_avail(emu, midi)) {\r\nif (mpu401_read_data(emu, midi) == MPU401_ACK)\r\nok = 1;\r\n}\r\n}\r\nif (!ok && mpu401_read_data(emu, midi) == MPU401_ACK)\r\nok = 1;\r\n} else {\r\nok = 1;\r\n}\r\nspin_unlock_irqrestore(&midi->input_lock, flags);\r\nif (!ok) {\r\nsnd_printk(KERN_ERR "midi_cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)!!!\n",\r\ncmd, emu->port,\r\nmpu401_read_stat(emu, midi),\r\nmpu401_read_data(emu, midi));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_emu10k1x_midi_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct emu10k1x *emu;\r\nstruct emu10k1x_midi *midi = substream->rmidi->private_data;\r\nunsigned long flags;\r\nemu = midi->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&midi->open_lock, flags);\r\nmidi->midi_mode |= EMU10K1X_MIDI_MODE_INPUT;\r\nmidi->substream_input = substream;\r\nif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT)) {\r\nspin_unlock_irqrestore(&midi->open_lock, flags);\r\nif (snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 1))\r\ngoto error_out;\r\nif (snd_emu10k1x_midi_cmd(emu, midi, MPU401_ENTER_UART, 1))\r\ngoto error_out;\r\n} else {\r\nspin_unlock_irqrestore(&midi->open_lock, flags);\r\n}\r\nreturn 0;\r\nerror_out:\r\nreturn -EIO;\r\n}\r\nstatic int snd_emu10k1x_midi_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct emu10k1x *emu;\r\nstruct emu10k1x_midi *midi = substream->rmidi->private_data;\r\nunsigned long flags;\r\nemu = midi->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&midi->open_lock, flags);\r\nmidi->midi_mode |= EMU10K1X_MIDI_MODE_OUTPUT;\r\nmidi->substream_output = substream;\r\nif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {\r\nspin_unlock_irqrestore(&midi->open_lock, flags);\r\nif (snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 1))\r\ngoto error_out;\r\nif (snd_emu10k1x_midi_cmd(emu, midi, MPU401_ENTER_UART, 1))\r\ngoto error_out;\r\n} else {\r\nspin_unlock_irqrestore(&midi->open_lock, flags);\r\n}\r\nreturn 0;\r\nerror_out:\r\nreturn -EIO;\r\n}\r\nstatic int snd_emu10k1x_midi_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct emu10k1x *emu;\r\nstruct emu10k1x_midi *midi = substream->rmidi->private_data;\r\nunsigned long flags;\r\nint err = 0;\r\nemu = midi->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&midi->open_lock, flags);\r\nsnd_emu10k1x_intr_disable(emu, midi->rx_enable);\r\nmidi->midi_mode &= ~EMU10K1X_MIDI_MODE_INPUT;\r\nmidi->substream_input = NULL;\r\nif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT)) {\r\nspin_unlock_irqrestore(&midi->open_lock, flags);\r\nerr = snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 0);\r\n} else {\r\nspin_unlock_irqrestore(&midi->open_lock, flags);\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_emu10k1x_midi_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct emu10k1x *emu;\r\nstruct emu10k1x_midi *midi = substream->rmidi->private_data;\r\nunsigned long flags;\r\nint err = 0;\r\nemu = midi->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&midi->open_lock, flags);\r\nsnd_emu10k1x_intr_disable(emu, midi->tx_enable);\r\nmidi->midi_mode &= ~EMU10K1X_MIDI_MODE_OUTPUT;\r\nmidi->substream_output = NULL;\r\nif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_INPUT)) {\r\nspin_unlock_irqrestore(&midi->open_lock, flags);\r\nerr = snd_emu10k1x_midi_cmd(emu, midi, MPU401_RESET, 0);\r\n} else {\r\nspin_unlock_irqrestore(&midi->open_lock, flags);\r\n}\r\nreturn err;\r\n}\r\nstatic void snd_emu10k1x_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct emu10k1x *emu;\r\nstruct emu10k1x_midi *midi = substream->rmidi->private_data;\r\nemu = midi->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn;\r\nif (up)\r\nsnd_emu10k1x_intr_enable(emu, midi->rx_enable);\r\nelse\r\nsnd_emu10k1x_intr_disable(emu, midi->rx_enable);\r\n}\r\nstatic void snd_emu10k1x_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct emu10k1x *emu;\r\nstruct emu10k1x_midi *midi = substream->rmidi->private_data;\r\nunsigned long flags;\r\nemu = midi->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn;\r\nif (up) {\r\nint max = 4;\r\nunsigned char byte;\r\nspin_lock_irqsave(&midi->output_lock, flags);\r\nwhile (max > 0) {\r\nif (mpu401_output_ready(emu, midi)) {\r\nif (!(midi->midi_mode & EMU10K1X_MIDI_MODE_OUTPUT) ||\r\nsnd_rawmidi_transmit(substream, &byte, 1) != 1) {\r\nspin_unlock_irqrestore(&midi->output_lock, flags);\r\nreturn;\r\n}\r\nmpu401_write_data(emu, midi, byte);\r\nmax--;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&midi->output_lock, flags);\r\nsnd_emu10k1x_intr_enable(emu, midi->tx_enable);\r\n} else {\r\nsnd_emu10k1x_intr_disable(emu, midi->tx_enable);\r\n}\r\n}\r\nstatic void snd_emu10k1x_midi_free(struct snd_rawmidi *rmidi)\r\n{\r\nstruct emu10k1x_midi *midi = rmidi->private_data;\r\nmidi->interrupt = NULL;\r\nmidi->rmidi = NULL;\r\n}\r\nstatic int __devinit emu10k1x_midi_init(struct emu10k1x *emu,\r\nstruct emu10k1x_midi *midi, int device, char *name)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nif ((err = snd_rawmidi_new(emu->card, name, device, 1, 1, &rmidi)) < 0)\r\nreturn err;\r\nmidi->emu = emu;\r\nspin_lock_init(&midi->open_lock);\r\nspin_lock_init(&midi->input_lock);\r\nspin_lock_init(&midi->output_lock);\r\nstrcpy(rmidi->name, name);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_emu10k1x_midi_output);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_emu10k1x_midi_input);\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nrmidi->private_data = midi;\r\nrmidi->private_free = snd_emu10k1x_midi_free;\r\nmidi->rmidi = rmidi;\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_emu10k1x_midi(struct emu10k1x *emu)\r\n{\r\nstruct emu10k1x_midi *midi = &emu->midi;\r\nint err;\r\nif ((err = emu10k1x_midi_init(emu, midi, 0, "EMU10K1X MPU-401 (UART)")) < 0)\r\nreturn err;\r\nmidi->tx_enable = INTE_MIDITXENABLE;\r\nmidi->rx_enable = INTE_MIDIRXENABLE;\r\nmidi->port = MUDATA;\r\nmidi->ipr_tx = IPR_MIDITRANSBUFEMPTY;\r\nmidi->ipr_rx = IPR_MIDIRECVBUFEMPTY;\r\nmidi->interrupt = snd_emu10k1x_midi_interrupt;\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_emu10k1x_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct emu10k1x *chip;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_emu10k1x_create(card, pci, &chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_emu10k1x_pcm(chip, 0, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_emu10k1x_pcm(chip, 1, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_emu10k1x_pcm(chip, 2, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_emu10k1x_ac97(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_emu10k1x_mixer(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_emu10k1x_midi(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_emu10k1x_proc_init(chip);\r\nstrcpy(card->driver, "EMU10K1X");\r\nstrcpy(card->shortname, "Dell Sound Blaster Live!");\r\nsprintf(card->longname, "%s at 0x%lx irq %i",\r\ncard->shortname, chip->port, chip->irq);\r\nsnd_card_set_dev(card, &pci->dev);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void __devexit snd_emu10k1x_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
