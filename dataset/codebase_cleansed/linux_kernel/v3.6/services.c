static int selinux_set_mapping(struct policydb *pol,\r\nstruct security_class_mapping *map,\r\nstruct selinux_mapping **out_map_p,\r\nu16 *out_map_size)\r\n{\r\nstruct selinux_mapping *out_map = NULL;\r\nsize_t size = sizeof(struct selinux_mapping);\r\nu16 i, j;\r\nunsigned k;\r\nbool print_unknown_handle = false;\r\nif (!map)\r\nreturn -EINVAL;\r\ni = 0;\r\nwhile (map[i].name)\r\ni++;\r\nout_map = kcalloc(++i, size, GFP_ATOMIC);\r\nif (!out_map)\r\nreturn -ENOMEM;\r\nj = 0;\r\nwhile (map[j].name) {\r\nstruct security_class_mapping *p_in = map + (j++);\r\nstruct selinux_mapping *p_out = out_map + j;\r\nif (!strcmp(p_in->name, "")) {\r\np_out->num_perms = 0;\r\ncontinue;\r\n}\r\np_out->value = string_to_security_class(pol, p_in->name);\r\nif (!p_out->value) {\r\nprintk(KERN_INFO\r\n"SELinux: Class %s not defined in policy.\n",\r\np_in->name);\r\nif (pol->reject_unknown)\r\ngoto err;\r\np_out->num_perms = 0;\r\nprint_unknown_handle = true;\r\ncontinue;\r\n}\r\nk = 0;\r\nwhile (p_in->perms && p_in->perms[k]) {\r\nif (!*p_in->perms[k]) {\r\nk++;\r\ncontinue;\r\n}\r\np_out->perms[k] = string_to_av_perm(pol, p_out->value,\r\np_in->perms[k]);\r\nif (!p_out->perms[k]) {\r\nprintk(KERN_INFO\r\n"SELinux: Permission %s in class %s not defined in policy.\n",\r\np_in->perms[k], p_in->name);\r\nif (pol->reject_unknown)\r\ngoto err;\r\nprint_unknown_handle = true;\r\n}\r\nk++;\r\n}\r\np_out->num_perms = k;\r\n}\r\nif (print_unknown_handle)\r\nprintk(KERN_INFO "SELinux: the above unknown classes and permissions will be %s\n",\r\npol->allow_unknown ? "allowed" : "denied");\r\n*out_map_p = out_map;\r\n*out_map_size = i;\r\nreturn 0;\r\nerr:\r\nkfree(out_map);\r\nreturn -EINVAL;\r\n}\r\nstatic u16 unmap_class(u16 tclass)\r\n{\r\nif (tclass < current_mapping_size)\r\nreturn current_mapping[tclass].value;\r\nreturn tclass;\r\n}\r\nstatic u16 map_class(u16 pol_value)\r\n{\r\nu16 i;\r\nfor (i = 1; i < current_mapping_size; i++) {\r\nif (current_mapping[i].value == pol_value)\r\nreturn i;\r\n}\r\nreturn SECCLASS_NULL;\r\n}\r\nstatic void map_decision(u16 tclass, struct av_decision *avd,\r\nint allow_unknown)\r\n{\r\nif (tclass < current_mapping_size) {\r\nunsigned i, n = current_mapping[tclass].num_perms;\r\nu32 result;\r\nfor (i = 0, result = 0; i < n; i++) {\r\nif (avd->allowed & current_mapping[tclass].perms[i])\r\nresult |= 1<<i;\r\nif (allow_unknown && !current_mapping[tclass].perms[i])\r\nresult |= 1<<i;\r\n}\r\navd->allowed = result;\r\nfor (i = 0, result = 0; i < n; i++)\r\nif (avd->auditallow & current_mapping[tclass].perms[i])\r\nresult |= 1<<i;\r\navd->auditallow = result;\r\nfor (i = 0, result = 0; i < n; i++) {\r\nif (avd->auditdeny & current_mapping[tclass].perms[i])\r\nresult |= 1<<i;\r\nif (!allow_unknown && !current_mapping[tclass].perms[i])\r\nresult |= 1<<i;\r\n}\r\nfor (; i < (sizeof(u32)*8); i++)\r\nresult |= 1<<i;\r\navd->auditdeny = result;\r\n}\r\n}\r\nint security_mls_enabled(void)\r\n{\r\nreturn policydb.mls_enabled;\r\n}\r\nstatic int constraint_expr_eval(struct context *scontext,\r\nstruct context *tcontext,\r\nstruct context *xcontext,\r\nstruct constraint_expr *cexpr)\r\n{\r\nu32 val1, val2;\r\nstruct context *c;\r\nstruct role_datum *r1, *r2;\r\nstruct mls_level *l1, *l2;\r\nstruct constraint_expr *e;\r\nint s[CEXPR_MAXDEPTH];\r\nint sp = -1;\r\nfor (e = cexpr; e; e = e->next) {\r\nswitch (e->expr_type) {\r\ncase CEXPR_NOT:\r\nBUG_ON(sp < 0);\r\ns[sp] = !s[sp];\r\nbreak;\r\ncase CEXPR_AND:\r\nBUG_ON(sp < 1);\r\nsp--;\r\ns[sp] &= s[sp + 1];\r\nbreak;\r\ncase CEXPR_OR:\r\nBUG_ON(sp < 1);\r\nsp--;\r\ns[sp] |= s[sp + 1];\r\nbreak;\r\ncase CEXPR_ATTR:\r\nif (sp == (CEXPR_MAXDEPTH - 1))\r\nreturn 0;\r\nswitch (e->attr) {\r\ncase CEXPR_USER:\r\nval1 = scontext->user;\r\nval2 = tcontext->user;\r\nbreak;\r\ncase CEXPR_TYPE:\r\nval1 = scontext->type;\r\nval2 = tcontext->type;\r\nbreak;\r\ncase CEXPR_ROLE:\r\nval1 = scontext->role;\r\nval2 = tcontext->role;\r\nr1 = policydb.role_val_to_struct[val1 - 1];\r\nr2 = policydb.role_val_to_struct[val2 - 1];\r\nswitch (e->op) {\r\ncase CEXPR_DOM:\r\ns[++sp] = ebitmap_get_bit(&r1->dominates,\r\nval2 - 1);\r\ncontinue;\r\ncase CEXPR_DOMBY:\r\ns[++sp] = ebitmap_get_bit(&r2->dominates,\r\nval1 - 1);\r\ncontinue;\r\ncase CEXPR_INCOMP:\r\ns[++sp] = (!ebitmap_get_bit(&r1->dominates,\r\nval2 - 1) &&\r\n!ebitmap_get_bit(&r2->dominates,\r\nval1 - 1));\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase CEXPR_L1L2:\r\nl1 = &(scontext->range.level[0]);\r\nl2 = &(tcontext->range.level[0]);\r\ngoto mls_ops;\r\ncase CEXPR_L1H2:\r\nl1 = &(scontext->range.level[0]);\r\nl2 = &(tcontext->range.level[1]);\r\ngoto mls_ops;\r\ncase CEXPR_H1L2:\r\nl1 = &(scontext->range.level[1]);\r\nl2 = &(tcontext->range.level[0]);\r\ngoto mls_ops;\r\ncase CEXPR_H1H2:\r\nl1 = &(scontext->range.level[1]);\r\nl2 = &(tcontext->range.level[1]);\r\ngoto mls_ops;\r\ncase CEXPR_L1H1:\r\nl1 = &(scontext->range.level[0]);\r\nl2 = &(scontext->range.level[1]);\r\ngoto mls_ops;\r\ncase CEXPR_L2H2:\r\nl1 = &(tcontext->range.level[0]);\r\nl2 = &(tcontext->range.level[1]);\r\ngoto mls_ops;\r\nmls_ops:\r\nswitch (e->op) {\r\ncase CEXPR_EQ:\r\ns[++sp] = mls_level_eq(l1, l2);\r\ncontinue;\r\ncase CEXPR_NEQ:\r\ns[++sp] = !mls_level_eq(l1, l2);\r\ncontinue;\r\ncase CEXPR_DOM:\r\ns[++sp] = mls_level_dom(l1, l2);\r\ncontinue;\r\ncase CEXPR_DOMBY:\r\ns[++sp] = mls_level_dom(l2, l1);\r\ncontinue;\r\ncase CEXPR_INCOMP:\r\ns[++sp] = mls_level_incomp(l2, l1);\r\ncontinue;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nswitch (e->op) {\r\ncase CEXPR_EQ:\r\ns[++sp] = (val1 == val2);\r\nbreak;\r\ncase CEXPR_NEQ:\r\ns[++sp] = (val1 != val2);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nbreak;\r\ncase CEXPR_NAMES:\r\nif (sp == (CEXPR_MAXDEPTH-1))\r\nreturn 0;\r\nc = scontext;\r\nif (e->attr & CEXPR_TARGET)\r\nc = tcontext;\r\nelse if (e->attr & CEXPR_XTARGET) {\r\nc = xcontext;\r\nif (!c) {\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nif (e->attr & CEXPR_USER)\r\nval1 = c->user;\r\nelse if (e->attr & CEXPR_ROLE)\r\nval1 = c->role;\r\nelse if (e->attr & CEXPR_TYPE)\r\nval1 = c->type;\r\nelse {\r\nBUG();\r\nreturn 0;\r\n}\r\nswitch (e->op) {\r\ncase CEXPR_EQ:\r\ns[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\r\nbreak;\r\ncase CEXPR_NEQ:\r\ns[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nBUG_ON(sp != 0);\r\nreturn s[0];\r\n}\r\nstatic int dump_masked_av_helper(void *k, void *d, void *args)\r\n{\r\nstruct perm_datum *pdatum = d;\r\nchar **permission_names = args;\r\nBUG_ON(pdatum->value < 1 || pdatum->value > 32);\r\npermission_names[pdatum->value - 1] = (char *)k;\r\nreturn 0;\r\n}\r\nstatic void security_dump_masked_av(struct context *scontext,\r\nstruct context *tcontext,\r\nu16 tclass,\r\nu32 permissions,\r\nconst char *reason)\r\n{\r\nstruct common_datum *common_dat;\r\nstruct class_datum *tclass_dat;\r\nstruct audit_buffer *ab;\r\nchar *tclass_name;\r\nchar *scontext_name = NULL;\r\nchar *tcontext_name = NULL;\r\nchar *permission_names[32];\r\nint index;\r\nu32 length;\r\nbool need_comma = false;\r\nif (!permissions)\r\nreturn;\r\ntclass_name = sym_name(&policydb, SYM_CLASSES, tclass - 1);\r\ntclass_dat = policydb.class_val_to_struct[tclass - 1];\r\ncommon_dat = tclass_dat->comdatum;\r\nif (common_dat &&\r\nhashtab_map(common_dat->permissions.table,\r\ndump_masked_av_helper, permission_names) < 0)\r\ngoto out;\r\nif (hashtab_map(tclass_dat->permissions.table,\r\ndump_masked_av_helper, permission_names) < 0)\r\ngoto out;\r\nif (context_struct_to_string(scontext,\r\n&scontext_name, &length) < 0)\r\ngoto out;\r\nif (context_struct_to_string(tcontext,\r\n&tcontext_name, &length) < 0)\r\ngoto out;\r\nab = audit_log_start(current->audit_context,\r\nGFP_ATOMIC, AUDIT_SELINUX_ERR);\r\nif (!ab)\r\ngoto out;\r\naudit_log_format(ab, "op=security_compute_av reason=%s "\r\n"scontext=%s tcontext=%s tclass=%s perms=",\r\nreason, scontext_name, tcontext_name, tclass_name);\r\nfor (index = 0; index < 32; index++) {\r\nu32 mask = (1 << index);\r\nif ((mask & permissions) == 0)\r\ncontinue;\r\naudit_log_format(ab, "%s%s",\r\nneed_comma ? "," : "",\r\npermission_names[index]\r\n? permission_names[index] : "????");\r\nneed_comma = true;\r\n}\r\naudit_log_end(ab);\r\nout:\r\nkfree(tcontext_name);\r\nkfree(scontext_name);\r\nreturn;\r\n}\r\nstatic void type_attribute_bounds_av(struct context *scontext,\r\nstruct context *tcontext,\r\nu16 tclass,\r\nstruct av_decision *avd)\r\n{\r\nstruct context lo_scontext;\r\nstruct context lo_tcontext;\r\nstruct av_decision lo_avd;\r\nstruct type_datum *source;\r\nstruct type_datum *target;\r\nu32 masked = 0;\r\nsource = flex_array_get_ptr(policydb.type_val_to_struct_array,\r\nscontext->type - 1);\r\nBUG_ON(!source);\r\ntarget = flex_array_get_ptr(policydb.type_val_to_struct_array,\r\ntcontext->type - 1);\r\nBUG_ON(!target);\r\nif (source->bounds) {\r\nmemset(&lo_avd, 0, sizeof(lo_avd));\r\nmemcpy(&lo_scontext, scontext, sizeof(lo_scontext));\r\nlo_scontext.type = source->bounds;\r\ncontext_struct_compute_av(&lo_scontext,\r\ntcontext,\r\ntclass,\r\n&lo_avd);\r\nif ((lo_avd.allowed & avd->allowed) == avd->allowed)\r\nreturn;\r\nmasked = ~lo_avd.allowed & avd->allowed;\r\n}\r\nif (target->bounds) {\r\nmemset(&lo_avd, 0, sizeof(lo_avd));\r\nmemcpy(&lo_tcontext, tcontext, sizeof(lo_tcontext));\r\nlo_tcontext.type = target->bounds;\r\ncontext_struct_compute_av(scontext,\r\n&lo_tcontext,\r\ntclass,\r\n&lo_avd);\r\nif ((lo_avd.allowed & avd->allowed) == avd->allowed)\r\nreturn;\r\nmasked = ~lo_avd.allowed & avd->allowed;\r\n}\r\nif (source->bounds && target->bounds) {\r\nmemset(&lo_avd, 0, sizeof(lo_avd));\r\ncontext_struct_compute_av(&lo_scontext,\r\n&lo_tcontext,\r\ntclass,\r\n&lo_avd);\r\nif ((lo_avd.allowed & avd->allowed) == avd->allowed)\r\nreturn;\r\nmasked = ~lo_avd.allowed & avd->allowed;\r\n}\r\nif (masked) {\r\navd->allowed &= ~masked;\r\nsecurity_dump_masked_av(scontext, tcontext,\r\ntclass, masked, "bounds");\r\n}\r\n}\r\nstatic void context_struct_compute_av(struct context *scontext,\r\nstruct context *tcontext,\r\nu16 tclass,\r\nstruct av_decision *avd)\r\n{\r\nstruct constraint_node *constraint;\r\nstruct role_allow *ra;\r\nstruct avtab_key avkey;\r\nstruct avtab_node *node;\r\nstruct class_datum *tclass_datum;\r\nstruct ebitmap *sattr, *tattr;\r\nstruct ebitmap_node *snode, *tnode;\r\nunsigned int i, j;\r\navd->allowed = 0;\r\navd->auditallow = 0;\r\navd->auditdeny = 0xffffffff;\r\nif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\r\nif (printk_ratelimit())\r\nprintk(KERN_WARNING "SELinux: Invalid class %hu\n", tclass);\r\nreturn;\r\n}\r\ntclass_datum = policydb.class_val_to_struct[tclass - 1];\r\navkey.target_class = tclass;\r\navkey.specified = AVTAB_AV;\r\nsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\r\nBUG_ON(!sattr);\r\ntattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\r\nBUG_ON(!tattr);\r\nebitmap_for_each_positive_bit(sattr, snode, i) {\r\nebitmap_for_each_positive_bit(tattr, tnode, j) {\r\navkey.source_type = i + 1;\r\navkey.target_type = j + 1;\r\nfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\r\nnode;\r\nnode = avtab_search_node_next(node, avkey.specified)) {\r\nif (node->key.specified == AVTAB_ALLOWED)\r\navd->allowed |= node->datum.data;\r\nelse if (node->key.specified == AVTAB_AUDITALLOW)\r\navd->auditallow |= node->datum.data;\r\nelse if (node->key.specified == AVTAB_AUDITDENY)\r\navd->auditdeny &= node->datum.data;\r\n}\r\ncond_compute_av(&policydb.te_cond_avtab, &avkey, avd);\r\n}\r\n}\r\nconstraint = tclass_datum->constraints;\r\nwhile (constraint) {\r\nif ((constraint->permissions & (avd->allowed)) &&\r\n!constraint_expr_eval(scontext, tcontext, NULL,\r\nconstraint->expr)) {\r\navd->allowed &= ~(constraint->permissions);\r\n}\r\nconstraint = constraint->next;\r\n}\r\nif (tclass == policydb.process_class &&\r\n(avd->allowed & policydb.process_trans_perms) &&\r\nscontext->role != tcontext->role) {\r\nfor (ra = policydb.role_allow; ra; ra = ra->next) {\r\nif (scontext->role == ra->role &&\r\ntcontext->role == ra->new_role)\r\nbreak;\r\n}\r\nif (!ra)\r\navd->allowed &= ~policydb.process_trans_perms;\r\n}\r\ntype_attribute_bounds_av(scontext, tcontext,\r\ntclass, avd);\r\n}\r\nstatic int security_validtrans_handle_fail(struct context *ocontext,\r\nstruct context *ncontext,\r\nstruct context *tcontext,\r\nu16 tclass)\r\n{\r\nchar *o = NULL, *n = NULL, *t = NULL;\r\nu32 olen, nlen, tlen;\r\nif (context_struct_to_string(ocontext, &o, &olen))\r\ngoto out;\r\nif (context_struct_to_string(ncontext, &n, &nlen))\r\ngoto out;\r\nif (context_struct_to_string(tcontext, &t, &tlen))\r\ngoto out;\r\naudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\r\n"security_validate_transition: denied for"\r\n" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s",\r\no, n, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\r\nout:\r\nkfree(o);\r\nkfree(n);\r\nkfree(t);\r\nif (!selinux_enforcing)\r\nreturn 0;\r\nreturn -EPERM;\r\n}\r\nint security_validate_transition(u32 oldsid, u32 newsid, u32 tasksid,\r\nu16 orig_tclass)\r\n{\r\nstruct context *ocontext;\r\nstruct context *ncontext;\r\nstruct context *tcontext;\r\nstruct class_datum *tclass_datum;\r\nstruct constraint_node *constraint;\r\nu16 tclass;\r\nint rc = 0;\r\nif (!ss_initialized)\r\nreturn 0;\r\nread_lock(&policy_rwlock);\r\ntclass = unmap_class(orig_tclass);\r\nif (!tclass || tclass > policydb.p_classes.nprim) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized class %d\n",\r\n__func__, tclass);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ntclass_datum = policydb.class_val_to_struct[tclass - 1];\r\nocontext = sidtab_search(&sidtab, oldsid);\r\nif (!ocontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, oldsid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nncontext = sidtab_search(&sidtab, newsid);\r\nif (!ncontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, newsid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ntcontext = sidtab_search(&sidtab, tasksid);\r\nif (!tcontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, tasksid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nconstraint = tclass_datum->validatetrans;\r\nwhile (constraint) {\r\nif (!constraint_expr_eval(ocontext, ncontext, tcontext,\r\nconstraint->expr)) {\r\nrc = security_validtrans_handle_fail(ocontext, ncontext,\r\ntcontext, tclass);\r\ngoto out;\r\n}\r\nconstraint = constraint->next;\r\n}\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nint security_bounded_transition(u32 old_sid, u32 new_sid)\r\n{\r\nstruct context *old_context, *new_context;\r\nstruct type_datum *type;\r\nint index;\r\nint rc;\r\nread_lock(&policy_rwlock);\r\nrc = -EINVAL;\r\nold_context = sidtab_search(&sidtab, old_sid);\r\nif (!old_context) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %u\n",\r\n__func__, old_sid);\r\ngoto out;\r\n}\r\nrc = -EINVAL;\r\nnew_context = sidtab_search(&sidtab, new_sid);\r\nif (!new_context) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %u\n",\r\n__func__, new_sid);\r\ngoto out;\r\n}\r\nrc = 0;\r\nif (old_context->type == new_context->type)\r\ngoto out;\r\nindex = new_context->type;\r\nwhile (true) {\r\ntype = flex_array_get_ptr(policydb.type_val_to_struct_array,\r\nindex - 1);\r\nBUG_ON(!type);\r\nrc = -EPERM;\r\nif (!type->bounds)\r\nbreak;\r\nrc = 0;\r\nif (type->bounds == old_context->type)\r\nbreak;\r\nindex = type->bounds;\r\n}\r\nif (rc) {\r\nchar *old_name = NULL;\r\nchar *new_name = NULL;\r\nu32 length;\r\nif (!context_struct_to_string(old_context,\r\n&old_name, &length) &&\r\n!context_struct_to_string(new_context,\r\n&new_name, &length)) {\r\naudit_log(current->audit_context,\r\nGFP_ATOMIC, AUDIT_SELINUX_ERR,\r\n"op=security_bounded_transition "\r\n"result=denied "\r\n"oldcontext=%s newcontext=%s",\r\nold_name, new_name);\r\n}\r\nkfree(new_name);\r\nkfree(old_name);\r\n}\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nstatic void avd_init(struct av_decision *avd)\r\n{\r\navd->allowed = 0;\r\navd->auditallow = 0;\r\navd->auditdeny = 0xffffffff;\r\navd->seqno = latest_granting;\r\navd->flags = 0;\r\n}\r\nvoid security_compute_av(u32 ssid,\r\nu32 tsid,\r\nu16 orig_tclass,\r\nstruct av_decision *avd)\r\n{\r\nu16 tclass;\r\nstruct context *scontext = NULL, *tcontext = NULL;\r\nread_lock(&policy_rwlock);\r\navd_init(avd);\r\nif (!ss_initialized)\r\ngoto allow;\r\nscontext = sidtab_search(&sidtab, ssid);\r\nif (!scontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, ssid);\r\ngoto out;\r\n}\r\nif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\r\navd->flags |= AVD_FLAGS_PERMISSIVE;\r\ntcontext = sidtab_search(&sidtab, tsid);\r\nif (!tcontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, tsid);\r\ngoto out;\r\n}\r\ntclass = unmap_class(orig_tclass);\r\nif (unlikely(orig_tclass && !tclass)) {\r\nif (policydb.allow_unknown)\r\ngoto allow;\r\ngoto out;\r\n}\r\ncontext_struct_compute_av(scontext, tcontext, tclass, avd);\r\nmap_decision(orig_tclass, avd, policydb.allow_unknown);\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn;\r\nallow:\r\navd->allowed = 0xffffffff;\r\ngoto out;\r\n}\r\nvoid security_compute_av_user(u32 ssid,\r\nu32 tsid,\r\nu16 tclass,\r\nstruct av_decision *avd)\r\n{\r\nstruct context *scontext = NULL, *tcontext = NULL;\r\nread_lock(&policy_rwlock);\r\navd_init(avd);\r\nif (!ss_initialized)\r\ngoto allow;\r\nscontext = sidtab_search(&sidtab, ssid);\r\nif (!scontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, ssid);\r\ngoto out;\r\n}\r\nif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\r\navd->flags |= AVD_FLAGS_PERMISSIVE;\r\ntcontext = sidtab_search(&sidtab, tsid);\r\nif (!tcontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, tsid);\r\ngoto out;\r\n}\r\nif (unlikely(!tclass)) {\r\nif (policydb.allow_unknown)\r\ngoto allow;\r\ngoto out;\r\n}\r\ncontext_struct_compute_av(scontext, tcontext, tclass, avd);\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn;\r\nallow:\r\navd->allowed = 0xffffffff;\r\ngoto out;\r\n}\r\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\r\n{\r\nchar *scontextp;\r\nif (scontext)\r\n*scontext = NULL;\r\n*scontext_len = 0;\r\nif (context->len) {\r\n*scontext_len = context->len;\r\nif (scontext) {\r\n*scontext = kstrdup(context->str, GFP_ATOMIC);\r\nif (!(*scontext))\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\n*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\r\n*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\r\n*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\r\n*scontext_len += mls_compute_context_len(context);\r\nif (!scontext)\r\nreturn 0;\r\nscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\r\nif (!scontextp)\r\nreturn -ENOMEM;\r\n*scontext = scontextp;\r\nsprintf(scontextp, "%s:%s:%s",\r\nsym_name(&policydb, SYM_USERS, context->user - 1),\r\nsym_name(&policydb, SYM_ROLES, context->role - 1),\r\nsym_name(&policydb, SYM_TYPES, context->type - 1));\r\nscontextp += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) +\r\n1 + strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) +\r\n1 + strlen(sym_name(&policydb, SYM_TYPES, context->type - 1));\r\nmls_sid_to_context(context, &scontextp);\r\n*scontextp = 0;\r\nreturn 0;\r\n}\r\nconst char *security_get_initial_sid_context(u32 sid)\r\n{\r\nif (unlikely(sid > SECINITSID_NUM))\r\nreturn NULL;\r\nreturn initial_sid_to_string[sid];\r\n}\r\nstatic int security_sid_to_context_core(u32 sid, char **scontext,\r\nu32 *scontext_len, int force)\r\n{\r\nstruct context *context;\r\nint rc = 0;\r\nif (scontext)\r\n*scontext = NULL;\r\n*scontext_len = 0;\r\nif (!ss_initialized) {\r\nif (sid <= SECINITSID_NUM) {\r\nchar *scontextp;\r\n*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\r\nif (!scontext)\r\ngoto out;\r\nscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\r\nif (!scontextp) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nstrcpy(scontextp, initial_sid_to_string[sid]);\r\n*scontext = scontextp;\r\ngoto out;\r\n}\r\nprintk(KERN_ERR "SELinux: %s: called before initial "\r\n"load_policy on unknown SID %d\n", __func__, sid);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nread_lock(&policy_rwlock);\r\nif (force)\r\ncontext = sidtab_search_force(&sidtab, sid);\r\nelse\r\ncontext = sidtab_search(&sidtab, sid);\r\nif (!context) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, sid);\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nrc = context_struct_to_string(context, scontext, scontext_len);\r\nout_unlock:\r\nread_unlock(&policy_rwlock);\r\nout:\r\nreturn rc;\r\n}\r\nint security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)\r\n{\r\nreturn security_sid_to_context_core(sid, scontext, scontext_len, 0);\r\n}\r\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\r\n{\r\nreturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\r\n}\r\nstatic int string_to_context_struct(struct policydb *pol,\r\nstruct sidtab *sidtabp,\r\nchar *scontext,\r\nu32 scontext_len,\r\nstruct context *ctx,\r\nu32 def_sid)\r\n{\r\nstruct role_datum *role;\r\nstruct type_datum *typdatum;\r\nstruct user_datum *usrdatum;\r\nchar *scontextp, *p, oldc;\r\nint rc = 0;\r\ncontext_init(ctx);\r\nrc = -EINVAL;\r\nscontextp = (char *) scontext;\r\np = scontextp;\r\nwhile (*p && *p != ':')\r\np++;\r\nif (*p == 0)\r\ngoto out;\r\n*p++ = 0;\r\nusrdatum = hashtab_search(pol->p_users.table, scontextp);\r\nif (!usrdatum)\r\ngoto out;\r\nctx->user = usrdatum->value;\r\nscontextp = p;\r\nwhile (*p && *p != ':')\r\np++;\r\nif (*p == 0)\r\ngoto out;\r\n*p++ = 0;\r\nrole = hashtab_search(pol->p_roles.table, scontextp);\r\nif (!role)\r\ngoto out;\r\nctx->role = role->value;\r\nscontextp = p;\r\nwhile (*p && *p != ':')\r\np++;\r\noldc = *p;\r\n*p++ = 0;\r\ntypdatum = hashtab_search(pol->p_types.table, scontextp);\r\nif (!typdatum || typdatum->attribute)\r\ngoto out;\r\nctx->type = typdatum->value;\r\nrc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\r\nif (rc)\r\ngoto out;\r\nrc = -EINVAL;\r\nif ((p - scontext) < scontext_len)\r\ngoto out;\r\nif (!policydb_context_isvalid(pol, ctx))\r\ngoto out;\r\nrc = 0;\r\nout:\r\nif (rc)\r\ncontext_destroy(ctx);\r\nreturn rc;\r\n}\r\nstatic int security_context_to_sid_core(const char *scontext, u32 scontext_len,\r\nu32 *sid, u32 def_sid, gfp_t gfp_flags,\r\nint force)\r\n{\r\nchar *scontext2, *str = NULL;\r\nstruct context context;\r\nint rc = 0;\r\nif (!ss_initialized) {\r\nint i;\r\nfor (i = 1; i < SECINITSID_NUM; i++) {\r\nif (!strcmp(initial_sid_to_string[i], scontext)) {\r\n*sid = i;\r\nreturn 0;\r\n}\r\n}\r\n*sid = SECINITSID_KERNEL;\r\nreturn 0;\r\n}\r\n*sid = SECSID_NULL;\r\nscontext2 = kmalloc(scontext_len + 1, gfp_flags);\r\nif (!scontext2)\r\nreturn -ENOMEM;\r\nmemcpy(scontext2, scontext, scontext_len);\r\nscontext2[scontext_len] = 0;\r\nif (force) {\r\nrc = -ENOMEM;\r\nstr = kstrdup(scontext2, gfp_flags);\r\nif (!str)\r\ngoto out;\r\n}\r\nread_lock(&policy_rwlock);\r\nrc = string_to_context_struct(&policydb, &sidtab, scontext2,\r\nscontext_len, &context, def_sid);\r\nif (rc == -EINVAL && force) {\r\ncontext.str = str;\r\ncontext.len = scontext_len;\r\nstr = NULL;\r\n} else if (rc)\r\ngoto out_unlock;\r\nrc = sidtab_context_to_sid(&sidtab, &context, sid);\r\ncontext_destroy(&context);\r\nout_unlock:\r\nread_unlock(&policy_rwlock);\r\nout:\r\nkfree(scontext2);\r\nkfree(str);\r\nreturn rc;\r\n}\r\nint security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid)\r\n{\r\nreturn security_context_to_sid_core(scontext, scontext_len,\r\nsid, SECSID_NULL, GFP_KERNEL, 0);\r\n}\r\nint security_context_to_sid_default(const char *scontext, u32 scontext_len,\r\nu32 *sid, u32 def_sid, gfp_t gfp_flags)\r\n{\r\nreturn security_context_to_sid_core(scontext, scontext_len,\r\nsid, def_sid, gfp_flags, 1);\r\n}\r\nint security_context_to_sid_force(const char *scontext, u32 scontext_len,\r\nu32 *sid)\r\n{\r\nreturn security_context_to_sid_core(scontext, scontext_len,\r\nsid, SECSID_NULL, GFP_KERNEL, 1);\r\n}\r\nstatic int compute_sid_handle_invalid_context(\r\nstruct context *scontext,\r\nstruct context *tcontext,\r\nu16 tclass,\r\nstruct context *newcontext)\r\n{\r\nchar *s = NULL, *t = NULL, *n = NULL;\r\nu32 slen, tlen, nlen;\r\nif (context_struct_to_string(scontext, &s, &slen))\r\ngoto out;\r\nif (context_struct_to_string(tcontext, &t, &tlen))\r\ngoto out;\r\nif (context_struct_to_string(newcontext, &n, &nlen))\r\ngoto out;\r\naudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\r\n"security_compute_sid: invalid context %s"\r\n" for scontext=%s"\r\n" tcontext=%s"\r\n" tclass=%s",\r\nn, s, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\r\nout:\r\nkfree(s);\r\nkfree(t);\r\nkfree(n);\r\nif (!selinux_enforcing)\r\nreturn 0;\r\nreturn -EACCES;\r\n}\r\nstatic void filename_compute_type(struct policydb *p, struct context *newcontext,\r\nu32 stype, u32 ttype, u16 tclass,\r\nconst char *objname)\r\n{\r\nstruct filename_trans ft;\r\nstruct filename_trans_datum *otype;\r\nif (!ebitmap_get_bit(&p->filename_trans_ttypes, ttype))\r\nreturn;\r\nft.stype = stype;\r\nft.ttype = ttype;\r\nft.tclass = tclass;\r\nft.name = objname;\r\notype = hashtab_search(p->filename_trans, &ft);\r\nif (otype)\r\nnewcontext->type = otype->otype;\r\n}\r\nstatic int security_compute_sid(u32 ssid,\r\nu32 tsid,\r\nu16 orig_tclass,\r\nu32 specified,\r\nconst char *objname,\r\nu32 *out_sid,\r\nbool kern)\r\n{\r\nstruct class_datum *cladatum = NULL;\r\nstruct context *scontext = NULL, *tcontext = NULL, newcontext;\r\nstruct role_trans *roletr = NULL;\r\nstruct avtab_key avkey;\r\nstruct avtab_datum *avdatum;\r\nstruct avtab_node *node;\r\nu16 tclass;\r\nint rc = 0;\r\nbool sock;\r\nif (!ss_initialized) {\r\nswitch (orig_tclass) {\r\ncase SECCLASS_PROCESS:\r\n*out_sid = ssid;\r\nbreak;\r\ndefault:\r\n*out_sid = tsid;\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\ncontext_init(&newcontext);\r\nread_lock(&policy_rwlock);\r\nif (kern) {\r\ntclass = unmap_class(orig_tclass);\r\nsock = security_is_socket_class(orig_tclass);\r\n} else {\r\ntclass = orig_tclass;\r\nsock = security_is_socket_class(map_class(tclass));\r\n}\r\nscontext = sidtab_search(&sidtab, ssid);\r\nif (!scontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, ssid);\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\ntcontext = sidtab_search(&sidtab, tsid);\r\nif (!tcontext) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, tsid);\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (tclass && tclass <= policydb.p_classes.nprim)\r\ncladatum = policydb.class_val_to_struct[tclass - 1];\r\nswitch (specified) {\r\ncase AVTAB_TRANSITION:\r\ncase AVTAB_CHANGE:\r\nif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\r\nnewcontext.user = tcontext->user;\r\n} else {\r\nnewcontext.user = scontext->user;\r\n}\r\nbreak;\r\ncase AVTAB_MEMBER:\r\nnewcontext.user = tcontext->user;\r\nbreak;\r\n}\r\nif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\r\nnewcontext.role = scontext->role;\r\n} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\r\nnewcontext.role = tcontext->role;\r\n} else {\r\nif ((tclass == policydb.process_class) || (sock == true))\r\nnewcontext.role = scontext->role;\r\nelse\r\nnewcontext.role = OBJECT_R_VAL;\r\n}\r\nif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\r\nnewcontext.type = scontext->type;\r\n} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\r\nnewcontext.type = tcontext->type;\r\n} else {\r\nif ((tclass == policydb.process_class) || (sock == true)) {\r\nnewcontext.type = scontext->type;\r\n} else {\r\nnewcontext.type = tcontext->type;\r\n}\r\n}\r\navkey.source_type = scontext->type;\r\navkey.target_type = tcontext->type;\r\navkey.target_class = tclass;\r\navkey.specified = specified;\r\navdatum = avtab_search(&policydb.te_avtab, &avkey);\r\nif (!avdatum) {\r\nnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\r\nfor (; node; node = avtab_search_node_next(node, specified)) {\r\nif (node->key.specified & AVTAB_ENABLED) {\r\navdatum = &node->datum;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (avdatum) {\r\nnewcontext.type = avdatum->data;\r\n}\r\nif (objname)\r\nfilename_compute_type(&policydb, &newcontext, scontext->type,\r\ntcontext->type, tclass, objname);\r\nif (specified & AVTAB_TRANSITION) {\r\nfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\r\nif ((roletr->role == scontext->role) &&\r\n(roletr->type == tcontext->type) &&\r\n(roletr->tclass == tclass)) {\r\nnewcontext.role = roletr->new_role;\r\nbreak;\r\n}\r\n}\r\n}\r\nrc = mls_compute_sid(scontext, tcontext, tclass, specified,\r\n&newcontext, sock);\r\nif (rc)\r\ngoto out_unlock;\r\nif (!policydb_context_isvalid(&policydb, &newcontext)) {\r\nrc = compute_sid_handle_invalid_context(scontext,\r\ntcontext,\r\ntclass,\r\n&newcontext);\r\nif (rc)\r\ngoto out_unlock;\r\n}\r\nrc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\r\nout_unlock:\r\nread_unlock(&policy_rwlock);\r\ncontext_destroy(&newcontext);\r\nout:\r\nreturn rc;\r\n}\r\nint security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\r\nconst struct qstr *qstr, u32 *out_sid)\r\n{\r\nreturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\r\nqstr ? qstr->name : NULL, out_sid, true);\r\n}\r\nint security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\r\nconst char *objname, u32 *out_sid)\r\n{\r\nreturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\r\nobjname, out_sid, false);\r\n}\r\nint security_member_sid(u32 ssid,\r\nu32 tsid,\r\nu16 tclass,\r\nu32 *out_sid)\r\n{\r\nreturn security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, NULL,\r\nout_sid, false);\r\n}\r\nint security_change_sid(u32 ssid,\r\nu32 tsid,\r\nu16 tclass,\r\nu32 *out_sid)\r\n{\r\nreturn security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, NULL,\r\nout_sid, false);\r\n}\r\nstatic int clone_sid(u32 sid,\r\nstruct context *context,\r\nvoid *arg)\r\n{\r\nstruct sidtab *s = arg;\r\nif (sid > SECINITSID_NUM)\r\nreturn sidtab_insert(s, sid, context);\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int convert_context_handle_invalid_context(struct context *context)\r\n{\r\nchar *s;\r\nu32 len;\r\nif (selinux_enforcing)\r\nreturn -EINVAL;\r\nif (!context_struct_to_string(context, &s, &len)) {\r\nprintk(KERN_WARNING "SELinux: Context %s would be invalid if enforcing\n", s);\r\nkfree(s);\r\n}\r\nreturn 0;\r\n}\r\nstatic int convert_context(u32 key,\r\nstruct context *c,\r\nvoid *p)\r\n{\r\nstruct convert_context_args *args;\r\nstruct context oldc;\r\nstruct ocontext *oc;\r\nstruct mls_range *range;\r\nstruct role_datum *role;\r\nstruct type_datum *typdatum;\r\nstruct user_datum *usrdatum;\r\nchar *s;\r\nu32 len;\r\nint rc = 0;\r\nif (key <= SECINITSID_NUM)\r\ngoto out;\r\nargs = p;\r\nif (c->str) {\r\nstruct context ctx;\r\nrc = -ENOMEM;\r\ns = kstrdup(c->str, GFP_KERNEL);\r\nif (!s)\r\ngoto out;\r\nrc = string_to_context_struct(args->newp, NULL, s,\r\nc->len, &ctx, SECSID_NULL);\r\nkfree(s);\r\nif (!rc) {\r\nprintk(KERN_INFO "SELinux: Context %s became valid (mapped).\n",\r\nc->str);\r\nkfree(c->str);\r\nmemcpy(c, &ctx, sizeof(*c));\r\ngoto out;\r\n} else if (rc == -EINVAL) {\r\nrc = 0;\r\ngoto out;\r\n} else {\r\nprintk(KERN_ERR "SELinux: Unable to map context %s, rc = %d.\n",\r\nc->str, -rc);\r\ngoto out;\r\n}\r\n}\r\nrc = context_cpy(&oldc, c);\r\nif (rc)\r\ngoto out;\r\nrc = -EINVAL;\r\nusrdatum = hashtab_search(args->newp->p_users.table,\r\nsym_name(args->oldp, SYM_USERS, c->user - 1));\r\nif (!usrdatum)\r\ngoto bad;\r\nc->user = usrdatum->value;\r\nrc = -EINVAL;\r\nrole = hashtab_search(args->newp->p_roles.table,\r\nsym_name(args->oldp, SYM_ROLES, c->role - 1));\r\nif (!role)\r\ngoto bad;\r\nc->role = role->value;\r\nrc = -EINVAL;\r\ntypdatum = hashtab_search(args->newp->p_types.table,\r\nsym_name(args->oldp, SYM_TYPES, c->type - 1));\r\nif (!typdatum)\r\ngoto bad;\r\nc->type = typdatum->value;\r\nif (args->oldp->mls_enabled && args->newp->mls_enabled) {\r\nrc = mls_convert_context(args->oldp, args->newp, c);\r\nif (rc)\r\ngoto bad;\r\n} else if (args->oldp->mls_enabled && !args->newp->mls_enabled) {\r\nmls_context_destroy(c);\r\n} else if (!args->oldp->mls_enabled && args->newp->mls_enabled) {\r\noc = args->newp->ocontexts[OCON_ISID];\r\nwhile (oc && oc->sid[0] != SECINITSID_UNLABELED)\r\noc = oc->next;\r\nrc = -EINVAL;\r\nif (!oc) {\r\nprintk(KERN_ERR "SELinux: unable to look up"\r\n" the initial SIDs list\n");\r\ngoto bad;\r\n}\r\nrange = &oc->context[0].range;\r\nrc = mls_range_set(c, range);\r\nif (rc)\r\ngoto bad;\r\n}\r\nif (!policydb_context_isvalid(args->newp, c)) {\r\nrc = convert_context_handle_invalid_context(&oldc);\r\nif (rc)\r\ngoto bad;\r\n}\r\ncontext_destroy(&oldc);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nbad:\r\nrc = context_struct_to_string(&oldc, &s, &len);\r\nif (rc)\r\nreturn rc;\r\ncontext_destroy(&oldc);\r\ncontext_destroy(c);\r\nc->str = s;\r\nc->len = len;\r\nprintk(KERN_INFO "SELinux: Context %s became invalid (unmapped).\n",\r\nc->str);\r\nrc = 0;\r\ngoto out;\r\n}\r\nstatic void security_load_policycaps(void)\r\n{\r\nselinux_policycap_netpeer = ebitmap_get_bit(&policydb.policycaps,\r\nPOLICYDB_CAPABILITY_NETPEER);\r\nselinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,\r\nPOLICYDB_CAPABILITY_OPENPERM);\r\n}\r\nint security_load_policy(void *data, size_t len)\r\n{\r\nstruct policydb oldpolicydb, newpolicydb;\r\nstruct sidtab oldsidtab, newsidtab;\r\nstruct selinux_mapping *oldmap, *map = NULL;\r\nstruct convert_context_args args;\r\nu32 seqno;\r\nu16 map_size;\r\nint rc = 0;\r\nstruct policy_file file = { data, len }, *fp = &file;\r\nif (!ss_initialized) {\r\navtab_cache_init();\r\nrc = policydb_read(&policydb, fp);\r\nif (rc) {\r\navtab_cache_destroy();\r\nreturn rc;\r\n}\r\npolicydb.len = len;\r\nrc = selinux_set_mapping(&policydb, secclass_map,\r\n&current_mapping,\r\n&current_mapping_size);\r\nif (rc) {\r\npolicydb_destroy(&policydb);\r\navtab_cache_destroy();\r\nreturn rc;\r\n}\r\nrc = policydb_load_isids(&policydb, &sidtab);\r\nif (rc) {\r\npolicydb_destroy(&policydb);\r\navtab_cache_destroy();\r\nreturn rc;\r\n}\r\nsecurity_load_policycaps();\r\nss_initialized = 1;\r\nseqno = ++latest_granting;\r\nselinux_complete_init();\r\navc_ss_reset(seqno);\r\nselnl_notify_policyload(seqno);\r\nselinux_status_update_policyload(seqno);\r\nselinux_netlbl_cache_invalidate();\r\nselinux_xfrm_notify_policyload();\r\nreturn 0;\r\n}\r\n#if 0\r\nsidtab_hash_eval(&sidtab, "sids");\r\n#endif\r\nrc = policydb_read(&newpolicydb, fp);\r\nif (rc)\r\nreturn rc;\r\nnewpolicydb.len = len;\r\nif (policydb.mls_enabled && !newpolicydb.mls_enabled)\r\nprintk(KERN_INFO "SELinux: Disabling MLS support...\n");\r\nelse if (!policydb.mls_enabled && newpolicydb.mls_enabled)\r\nprintk(KERN_INFO "SELinux: Enabling MLS support...\n");\r\nrc = policydb_load_isids(&newpolicydb, &newsidtab);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: unable to load the initial SIDs\n");\r\npolicydb_destroy(&newpolicydb);\r\nreturn rc;\r\n}\r\nrc = selinux_set_mapping(&newpolicydb, secclass_map, &map, &map_size);\r\nif (rc)\r\ngoto err;\r\nrc = security_preserve_bools(&newpolicydb);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: unable to preserve booleans\n");\r\ngoto err;\r\n}\r\nsidtab_shutdown(&sidtab);\r\nrc = sidtab_map(&sidtab, clone_sid, &newsidtab);\r\nif (rc)\r\ngoto err;\r\nargs.oldp = &policydb;\r\nargs.newp = &newpolicydb;\r\nrc = sidtab_map(&newsidtab, convert_context, &args);\r\nif (rc) {\r\nprintk(KERN_ERR "SELinux: unable to convert the internal"\r\n" representation of contexts in the new SID"\r\n" table\n");\r\ngoto err;\r\n}\r\nmemcpy(&oldpolicydb, &policydb, sizeof policydb);\r\nsidtab_set(&oldsidtab, &sidtab);\r\nwrite_lock_irq(&policy_rwlock);\r\nmemcpy(&policydb, &newpolicydb, sizeof policydb);\r\nsidtab_set(&sidtab, &newsidtab);\r\nsecurity_load_policycaps();\r\noldmap = current_mapping;\r\ncurrent_mapping = map;\r\ncurrent_mapping_size = map_size;\r\nseqno = ++latest_granting;\r\nwrite_unlock_irq(&policy_rwlock);\r\npolicydb_destroy(&oldpolicydb);\r\nsidtab_destroy(&oldsidtab);\r\nkfree(oldmap);\r\navc_ss_reset(seqno);\r\nselnl_notify_policyload(seqno);\r\nselinux_status_update_policyload(seqno);\r\nselinux_netlbl_cache_invalidate();\r\nselinux_xfrm_notify_policyload();\r\nreturn 0;\r\nerr:\r\nkfree(map);\r\nsidtab_destroy(&newsidtab);\r\npolicydb_destroy(&newpolicydb);\r\nreturn rc;\r\n}\r\nsize_t security_policydb_len(void)\r\n{\r\nsize_t len;\r\nread_lock(&policy_rwlock);\r\nlen = policydb.len;\r\nread_unlock(&policy_rwlock);\r\nreturn len;\r\n}\r\nint security_port_sid(u8 protocol, u16 port, u32 *out_sid)\r\n{\r\nstruct ocontext *c;\r\nint rc = 0;\r\nread_lock(&policy_rwlock);\r\nc = policydb.ocontexts[OCON_PORT];\r\nwhile (c) {\r\nif (c->u.port.protocol == protocol &&\r\nc->u.port.low_port <= port &&\r\nc->u.port.high_port >= port)\r\nbreak;\r\nc = c->next;\r\n}\r\nif (c) {\r\nif (!c->sid[0]) {\r\nrc = sidtab_context_to_sid(&sidtab,\r\n&c->context[0],\r\n&c->sid[0]);\r\nif (rc)\r\ngoto out;\r\n}\r\n*out_sid = c->sid[0];\r\n} else {\r\n*out_sid = SECINITSID_PORT;\r\n}\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nint security_netif_sid(char *name, u32 *if_sid)\r\n{\r\nint rc = 0;\r\nstruct ocontext *c;\r\nread_lock(&policy_rwlock);\r\nc = policydb.ocontexts[OCON_NETIF];\r\nwhile (c) {\r\nif (strcmp(name, c->u.name) == 0)\r\nbreak;\r\nc = c->next;\r\n}\r\nif (c) {\r\nif (!c->sid[0] || !c->sid[1]) {\r\nrc = sidtab_context_to_sid(&sidtab,\r\n&c->context[0],\r\n&c->sid[0]);\r\nif (rc)\r\ngoto out;\r\nrc = sidtab_context_to_sid(&sidtab,\r\n&c->context[1],\r\n&c->sid[1]);\r\nif (rc)\r\ngoto out;\r\n}\r\n*if_sid = c->sid[0];\r\n} else\r\n*if_sid = SECINITSID_NETIF;\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nstatic int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)\r\n{\r\nint i, fail = 0;\r\nfor (i = 0; i < 4; i++)\r\nif (addr[i] != (input[i] & mask[i])) {\r\nfail = 1;\r\nbreak;\r\n}\r\nreturn !fail;\r\n}\r\nint security_node_sid(u16 domain,\r\nvoid *addrp,\r\nu32 addrlen,\r\nu32 *out_sid)\r\n{\r\nint rc;\r\nstruct ocontext *c;\r\nread_lock(&policy_rwlock);\r\nswitch (domain) {\r\ncase AF_INET: {\r\nu32 addr;\r\nrc = -EINVAL;\r\nif (addrlen != sizeof(u32))\r\ngoto out;\r\naddr = *((u32 *)addrp);\r\nc = policydb.ocontexts[OCON_NODE];\r\nwhile (c) {\r\nif (c->u.node.addr == (addr & c->u.node.mask))\r\nbreak;\r\nc = c->next;\r\n}\r\nbreak;\r\n}\r\ncase AF_INET6:\r\nrc = -EINVAL;\r\nif (addrlen != sizeof(u64) * 2)\r\ngoto out;\r\nc = policydb.ocontexts[OCON_NODE6];\r\nwhile (c) {\r\nif (match_ipv6_addrmask(addrp, c->u.node6.addr,\r\nc->u.node6.mask))\r\nbreak;\r\nc = c->next;\r\n}\r\nbreak;\r\ndefault:\r\nrc = 0;\r\n*out_sid = SECINITSID_NODE;\r\ngoto out;\r\n}\r\nif (c) {\r\nif (!c->sid[0]) {\r\nrc = sidtab_context_to_sid(&sidtab,\r\n&c->context[0],\r\n&c->sid[0]);\r\nif (rc)\r\ngoto out;\r\n}\r\n*out_sid = c->sid[0];\r\n} else {\r\n*out_sid = SECINITSID_NODE;\r\n}\r\nrc = 0;\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nint security_get_user_sids(u32 fromsid,\r\nchar *username,\r\nu32 **sids,\r\nu32 *nel)\r\n{\r\nstruct context *fromcon, usercon;\r\nu32 *mysids = NULL, *mysids2, sid;\r\nu32 mynel = 0, maxnel = SIDS_NEL;\r\nstruct user_datum *user;\r\nstruct role_datum *role;\r\nstruct ebitmap_node *rnode, *tnode;\r\nint rc = 0, i, j;\r\n*sids = NULL;\r\n*nel = 0;\r\nif (!ss_initialized)\r\ngoto out;\r\nread_lock(&policy_rwlock);\r\ncontext_init(&usercon);\r\nrc = -EINVAL;\r\nfromcon = sidtab_search(&sidtab, fromsid);\r\nif (!fromcon)\r\ngoto out_unlock;\r\nrc = -EINVAL;\r\nuser = hashtab_search(policydb.p_users.table, username);\r\nif (!user)\r\ngoto out_unlock;\r\nusercon.user = user->value;\r\nrc = -ENOMEM;\r\nmysids = kcalloc(maxnel, sizeof(*mysids), GFP_ATOMIC);\r\nif (!mysids)\r\ngoto out_unlock;\r\nebitmap_for_each_positive_bit(&user->roles, rnode, i) {\r\nrole = policydb.role_val_to_struct[i];\r\nusercon.role = i + 1;\r\nebitmap_for_each_positive_bit(&role->types, tnode, j) {\r\nusercon.type = j + 1;\r\nif (mls_setup_user_range(fromcon, user, &usercon))\r\ncontinue;\r\nrc = sidtab_context_to_sid(&sidtab, &usercon, &sid);\r\nif (rc)\r\ngoto out_unlock;\r\nif (mynel < maxnel) {\r\nmysids[mynel++] = sid;\r\n} else {\r\nrc = -ENOMEM;\r\nmaxnel += SIDS_NEL;\r\nmysids2 = kcalloc(maxnel, sizeof(*mysids2), GFP_ATOMIC);\r\nif (!mysids2)\r\ngoto out_unlock;\r\nmemcpy(mysids2, mysids, mynel * sizeof(*mysids2));\r\nkfree(mysids);\r\nmysids = mysids2;\r\nmysids[mynel++] = sid;\r\n}\r\n}\r\n}\r\nrc = 0;\r\nout_unlock:\r\nread_unlock(&policy_rwlock);\r\nif (rc || !mynel) {\r\nkfree(mysids);\r\ngoto out;\r\n}\r\nrc = -ENOMEM;\r\nmysids2 = kcalloc(mynel, sizeof(*mysids2), GFP_KERNEL);\r\nif (!mysids2) {\r\nkfree(mysids);\r\ngoto out;\r\n}\r\nfor (i = 0, j = 0; i < mynel; i++) {\r\nstruct av_decision dummy_avd;\r\nrc = avc_has_perm_noaudit(fromsid, mysids[i],\r\nSECCLASS_PROCESS,\r\nPROCESS__TRANSITION, AVC_STRICT,\r\n&dummy_avd);\r\nif (!rc)\r\nmysids2[j++] = mysids[i];\r\ncond_resched();\r\n}\r\nrc = 0;\r\nkfree(mysids);\r\n*sids = mysids2;\r\n*nel = j;\r\nout:\r\nreturn rc;\r\n}\r\nint security_genfs_sid(const char *fstype,\r\nchar *path,\r\nu16 orig_sclass,\r\nu32 *sid)\r\n{\r\nint len;\r\nu16 sclass;\r\nstruct genfs *genfs;\r\nstruct ocontext *c;\r\nint rc, cmp = 0;\r\nwhile (path[0] == '/' && path[1] == '/')\r\npath++;\r\nread_lock(&policy_rwlock);\r\nsclass = unmap_class(orig_sclass);\r\n*sid = SECINITSID_UNLABELED;\r\nfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\r\ncmp = strcmp(fstype, genfs->fstype);\r\nif (cmp <= 0)\r\nbreak;\r\n}\r\nrc = -ENOENT;\r\nif (!genfs || cmp)\r\ngoto out;\r\nfor (c = genfs->head; c; c = c->next) {\r\nlen = strlen(c->u.name);\r\nif ((!c->v.sclass || sclass == c->v.sclass) &&\r\n(strncmp(c->u.name, path, len) == 0))\r\nbreak;\r\n}\r\nrc = -ENOENT;\r\nif (!c)\r\ngoto out;\r\nif (!c->sid[0]) {\r\nrc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\r\nif (rc)\r\ngoto out;\r\n}\r\n*sid = c->sid[0];\r\nrc = 0;\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nint security_fs_use(\r\nconst char *fstype,\r\nunsigned int *behavior,\r\nu32 *sid)\r\n{\r\nint rc = 0;\r\nstruct ocontext *c;\r\nread_lock(&policy_rwlock);\r\nc = policydb.ocontexts[OCON_FSUSE];\r\nwhile (c) {\r\nif (strcmp(fstype, c->u.name) == 0)\r\nbreak;\r\nc = c->next;\r\n}\r\nif (c) {\r\n*behavior = c->v.behavior;\r\nif (!c->sid[0]) {\r\nrc = sidtab_context_to_sid(&sidtab, &c->context[0],\r\n&c->sid[0]);\r\nif (rc)\r\ngoto out;\r\n}\r\n*sid = c->sid[0];\r\n} else {\r\nrc = security_genfs_sid(fstype, "/", SECCLASS_DIR, sid);\r\nif (rc) {\r\n*behavior = SECURITY_FS_USE_NONE;\r\nrc = 0;\r\n} else {\r\n*behavior = SECURITY_FS_USE_GENFS;\r\n}\r\n}\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nint security_get_bools(int *len, char ***names, int **values)\r\n{\r\nint i, rc;\r\nread_lock(&policy_rwlock);\r\n*names = NULL;\r\n*values = NULL;\r\nrc = 0;\r\n*len = policydb.p_bools.nprim;\r\nif (!*len)\r\ngoto out;\r\nrc = -ENOMEM;\r\n*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\r\nif (!*names)\r\ngoto err;\r\nrc = -ENOMEM;\r\n*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\r\nif (!*values)\r\ngoto err;\r\nfor (i = 0; i < *len; i++) {\r\nsize_t name_len;\r\n(*values)[i] = policydb.bool_val_to_struct[i]->state;\r\nname_len = strlen(sym_name(&policydb, SYM_BOOLS, i)) + 1;\r\nrc = -ENOMEM;\r\n(*names)[i] = kmalloc(sizeof(char) * name_len, GFP_ATOMIC);\r\nif (!(*names)[i])\r\ngoto err;\r\nstrncpy((*names)[i], sym_name(&policydb, SYM_BOOLS, i), name_len);\r\n(*names)[i][name_len - 1] = 0;\r\n}\r\nrc = 0;\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\nerr:\r\nif (*names) {\r\nfor (i = 0; i < *len; i++)\r\nkfree((*names)[i]);\r\n}\r\nkfree(*values);\r\ngoto out;\r\n}\r\nint security_set_bools(int len, int *values)\r\n{\r\nint i, rc;\r\nint lenp, seqno = 0;\r\nstruct cond_node *cur;\r\nwrite_lock_irq(&policy_rwlock);\r\nrc = -EFAULT;\r\nlenp = policydb.p_bools.nprim;\r\nif (len != lenp)\r\ngoto out;\r\nfor (i = 0; i < len; i++) {\r\nif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\r\naudit_log(current->audit_context, GFP_ATOMIC,\r\nAUDIT_MAC_CONFIG_CHANGE,\r\n"bool=%s val=%d old_val=%d auid=%u ses=%u",\r\nsym_name(&policydb, SYM_BOOLS, i),\r\n!!values[i],\r\npolicydb.bool_val_to_struct[i]->state,\r\naudit_get_loginuid(current),\r\naudit_get_sessionid(current));\r\n}\r\nif (values[i])\r\npolicydb.bool_val_to_struct[i]->state = 1;\r\nelse\r\npolicydb.bool_val_to_struct[i]->state = 0;\r\n}\r\nfor (cur = policydb.cond_list; cur; cur = cur->next) {\r\nrc = evaluate_cond_node(&policydb, cur);\r\nif (rc)\r\ngoto out;\r\n}\r\nseqno = ++latest_granting;\r\nrc = 0;\r\nout:\r\nwrite_unlock_irq(&policy_rwlock);\r\nif (!rc) {\r\navc_ss_reset(seqno);\r\nselnl_notify_policyload(seqno);\r\nselinux_status_update_policyload(seqno);\r\nselinux_xfrm_notify_policyload();\r\n}\r\nreturn rc;\r\n}\r\nint security_get_bool_value(int bool)\r\n{\r\nint rc;\r\nint len;\r\nread_lock(&policy_rwlock);\r\nrc = -EFAULT;\r\nlen = policydb.p_bools.nprim;\r\nif (bool >= len)\r\ngoto out;\r\nrc = policydb.bool_val_to_struct[bool]->state;\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nstatic int security_preserve_bools(struct policydb *p)\r\n{\r\nint rc, nbools = 0, *bvalues = NULL, i;\r\nchar **bnames = NULL;\r\nstruct cond_bool_datum *booldatum;\r\nstruct cond_node *cur;\r\nrc = security_get_bools(&nbools, &bnames, &bvalues);\r\nif (rc)\r\ngoto out;\r\nfor (i = 0; i < nbools; i++) {\r\nbooldatum = hashtab_search(p->p_bools.table, bnames[i]);\r\nif (booldatum)\r\nbooldatum->state = bvalues[i];\r\n}\r\nfor (cur = p->cond_list; cur; cur = cur->next) {\r\nrc = evaluate_cond_node(p, cur);\r\nif (rc)\r\ngoto out;\r\n}\r\nout:\r\nif (bnames) {\r\nfor (i = 0; i < nbools; i++)\r\nkfree(bnames[i]);\r\n}\r\nkfree(bnames);\r\nkfree(bvalues);\r\nreturn rc;\r\n}\r\nint security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)\r\n{\r\nstruct context *context1;\r\nstruct context *context2;\r\nstruct context newcon;\r\nchar *s;\r\nu32 len;\r\nint rc;\r\nrc = 0;\r\nif (!ss_initialized || !policydb.mls_enabled) {\r\n*new_sid = sid;\r\ngoto out;\r\n}\r\ncontext_init(&newcon);\r\nread_lock(&policy_rwlock);\r\nrc = -EINVAL;\r\ncontext1 = sidtab_search(&sidtab, sid);\r\nif (!context1) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, sid);\r\ngoto out_unlock;\r\n}\r\nrc = -EINVAL;\r\ncontext2 = sidtab_search(&sidtab, mls_sid);\r\nif (!context2) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, mls_sid);\r\ngoto out_unlock;\r\n}\r\nnewcon.user = context1->user;\r\nnewcon.role = context1->role;\r\nnewcon.type = context1->type;\r\nrc = mls_context_cpy(&newcon, context2);\r\nif (rc)\r\ngoto out_unlock;\r\nif (!policydb_context_isvalid(&policydb, &newcon)) {\r\nrc = convert_context_handle_invalid_context(&newcon);\r\nif (rc) {\r\nif (!context_struct_to_string(&newcon, &s, &len)) {\r\naudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\r\n"security_sid_mls_copy: invalid context %s", s);\r\nkfree(s);\r\n}\r\ngoto out_unlock;\r\n}\r\n}\r\nrc = sidtab_context_to_sid(&sidtab, &newcon, new_sid);\r\nout_unlock:\r\nread_unlock(&policy_rwlock);\r\ncontext_destroy(&newcon);\r\nout:\r\nreturn rc;\r\n}\r\nint security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type,\r\nu32 xfrm_sid,\r\nu32 *peer_sid)\r\n{\r\nint rc;\r\nstruct context *nlbl_ctx;\r\nstruct context *xfrm_ctx;\r\n*peer_sid = SECSID_NULL;\r\nif (xfrm_sid == SECSID_NULL) {\r\n*peer_sid = nlbl_sid;\r\nreturn 0;\r\n}\r\nif (nlbl_sid == SECSID_NULL || nlbl_type == NETLBL_NLTYPE_UNLABELED) {\r\n*peer_sid = xfrm_sid;\r\nreturn 0;\r\n}\r\nif (!policydb.mls_enabled)\r\nreturn 0;\r\nread_lock(&policy_rwlock);\r\nrc = -EINVAL;\r\nnlbl_ctx = sidtab_search(&sidtab, nlbl_sid);\r\nif (!nlbl_ctx) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, nlbl_sid);\r\ngoto out;\r\n}\r\nrc = -EINVAL;\r\nxfrm_ctx = sidtab_search(&sidtab, xfrm_sid);\r\nif (!xfrm_ctx) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized SID %d\n",\r\n__func__, xfrm_sid);\r\ngoto out;\r\n}\r\nrc = (mls_context_cmp(nlbl_ctx, xfrm_ctx) ? 0 : -EACCES);\r\nif (rc)\r\ngoto out;\r\n*peer_sid = xfrm_sid;\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nstatic int get_classes_callback(void *k, void *d, void *args)\r\n{\r\nstruct class_datum *datum = d;\r\nchar *name = k, **classes = args;\r\nint value = datum->value - 1;\r\nclasses[value] = kstrdup(name, GFP_ATOMIC);\r\nif (!classes[value])\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint security_get_classes(char ***classes, int *nclasses)\r\n{\r\nint rc;\r\nread_lock(&policy_rwlock);\r\nrc = -ENOMEM;\r\n*nclasses = policydb.p_classes.nprim;\r\n*classes = kcalloc(*nclasses, sizeof(**classes), GFP_ATOMIC);\r\nif (!*classes)\r\ngoto out;\r\nrc = hashtab_map(policydb.p_classes.table, get_classes_callback,\r\n*classes);\r\nif (rc) {\r\nint i;\r\nfor (i = 0; i < *nclasses; i++)\r\nkfree((*classes)[i]);\r\nkfree(*classes);\r\n}\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nstatic int get_permissions_callback(void *k, void *d, void *args)\r\n{\r\nstruct perm_datum *datum = d;\r\nchar *name = k, **perms = args;\r\nint value = datum->value - 1;\r\nperms[value] = kstrdup(name, GFP_ATOMIC);\r\nif (!perms[value])\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint security_get_permissions(char *class, char ***perms, int *nperms)\r\n{\r\nint rc, i;\r\nstruct class_datum *match;\r\nread_lock(&policy_rwlock);\r\nrc = -EINVAL;\r\nmatch = hashtab_search(policydb.p_classes.table, class);\r\nif (!match) {\r\nprintk(KERN_ERR "SELinux: %s: unrecognized class %s\n",\r\n__func__, class);\r\ngoto out;\r\n}\r\nrc = -ENOMEM;\r\n*nperms = match->permissions.nprim;\r\n*perms = kcalloc(*nperms, sizeof(**perms), GFP_ATOMIC);\r\nif (!*perms)\r\ngoto out;\r\nif (match->comdatum) {\r\nrc = hashtab_map(match->comdatum->permissions.table,\r\nget_permissions_callback, *perms);\r\nif (rc)\r\ngoto err;\r\n}\r\nrc = hashtab_map(match->permissions.table, get_permissions_callback,\r\n*perms);\r\nif (rc)\r\ngoto err;\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\nerr:\r\nread_unlock(&policy_rwlock);\r\nfor (i = 0; i < *nperms; i++)\r\nkfree((*perms)[i]);\r\nkfree(*perms);\r\nreturn rc;\r\n}\r\nint security_get_reject_unknown(void)\r\n{\r\nreturn policydb.reject_unknown;\r\n}\r\nint security_get_allow_unknown(void)\r\n{\r\nreturn policydb.allow_unknown;\r\n}\r\nint security_policycap_supported(unsigned int req_cap)\r\n{\r\nint rc;\r\nread_lock(&policy_rwlock);\r\nrc = ebitmap_get_bit(&policydb.policycaps, req_cap);\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nvoid selinux_audit_rule_free(void *vrule)\r\n{\r\nstruct selinux_audit_rule *rule = vrule;\r\nif (rule) {\r\ncontext_destroy(&rule->au_ctxt);\r\nkfree(rule);\r\n}\r\n}\r\nint selinux_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\r\n{\r\nstruct selinux_audit_rule *tmprule;\r\nstruct role_datum *roledatum;\r\nstruct type_datum *typedatum;\r\nstruct user_datum *userdatum;\r\nstruct selinux_audit_rule **rule = (struct selinux_audit_rule **)vrule;\r\nint rc = 0;\r\n*rule = NULL;\r\nif (!ss_initialized)\r\nreturn -EOPNOTSUPP;\r\nswitch (field) {\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\nif (op != Audit_equal && op != Audit_not_equal)\r\nreturn -EINVAL;\r\nbreak;\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nif (strchr(rulestr, '-'))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntmprule = kzalloc(sizeof(struct selinux_audit_rule), GFP_KERNEL);\r\nif (!tmprule)\r\nreturn -ENOMEM;\r\ncontext_init(&tmprule->au_ctxt);\r\nread_lock(&policy_rwlock);\r\ntmprule->au_seqno = latest_granting;\r\nswitch (field) {\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_OBJ_USER:\r\nrc = -EINVAL;\r\nuserdatum = hashtab_search(policydb.p_users.table, rulestr);\r\nif (!userdatum)\r\ngoto out;\r\ntmprule->au_ctxt.user = userdatum->value;\r\nbreak;\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_OBJ_ROLE:\r\nrc = -EINVAL;\r\nroledatum = hashtab_search(policydb.p_roles.table, rulestr);\r\nif (!roledatum)\r\ngoto out;\r\ntmprule->au_ctxt.role = roledatum->value;\r\nbreak;\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_OBJ_TYPE:\r\nrc = -EINVAL;\r\ntypedatum = hashtab_search(policydb.p_types.table, rulestr);\r\nif (!typedatum)\r\ngoto out;\r\ntmprule->au_ctxt.type = typedatum->value;\r\nbreak;\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nrc = mls_from_string(rulestr, &tmprule->au_ctxt, GFP_ATOMIC);\r\nif (rc)\r\ngoto out;\r\nbreak;\r\n}\r\nrc = 0;\r\nout:\r\nread_unlock(&policy_rwlock);\r\nif (rc) {\r\nselinux_audit_rule_free(tmprule);\r\ntmprule = NULL;\r\n}\r\n*rule = tmprule;\r\nreturn rc;\r\n}\r\nint selinux_audit_rule_known(struct audit_krule *rule)\r\n{\r\nint i;\r\nfor (i = 0; i < rule->field_count; i++) {\r\nstruct audit_field *f = &rule->fields[i];\r\nswitch (f->type) {\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule,\r\nstruct audit_context *actx)\r\n{\r\nstruct context *ctxt;\r\nstruct mls_level *level;\r\nstruct selinux_audit_rule *rule = vrule;\r\nint match = 0;\r\nif (!rule) {\r\naudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\r\n"selinux_audit_rule_match: missing rule\n");\r\nreturn -ENOENT;\r\n}\r\nread_lock(&policy_rwlock);\r\nif (rule->au_seqno < latest_granting) {\r\naudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\r\n"selinux_audit_rule_match: stale rule\n");\r\nmatch = -ESTALE;\r\ngoto out;\r\n}\r\nctxt = sidtab_search(&sidtab, sid);\r\nif (!ctxt) {\r\naudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\r\n"selinux_audit_rule_match: unrecognized SID %d\n",\r\nsid);\r\nmatch = -ENOENT;\r\ngoto out;\r\n}\r\nswitch (field) {\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_OBJ_USER:\r\nswitch (op) {\r\ncase Audit_equal:\r\nmatch = (ctxt->user == rule->au_ctxt.user);\r\nbreak;\r\ncase Audit_not_equal:\r\nmatch = (ctxt->user != rule->au_ctxt.user);\r\nbreak;\r\n}\r\nbreak;\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_OBJ_ROLE:\r\nswitch (op) {\r\ncase Audit_equal:\r\nmatch = (ctxt->role == rule->au_ctxt.role);\r\nbreak;\r\ncase Audit_not_equal:\r\nmatch = (ctxt->role != rule->au_ctxt.role);\r\nbreak;\r\n}\r\nbreak;\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_OBJ_TYPE:\r\nswitch (op) {\r\ncase Audit_equal:\r\nmatch = (ctxt->type == rule->au_ctxt.type);\r\nbreak;\r\ncase Audit_not_equal:\r\nmatch = (ctxt->type != rule->au_ctxt.type);\r\nbreak;\r\n}\r\nbreak;\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nlevel = ((field == AUDIT_SUBJ_SEN ||\r\nfield == AUDIT_OBJ_LEV_LOW) ?\r\n&ctxt->range.level[0] : &ctxt->range.level[1]);\r\nswitch (op) {\r\ncase Audit_equal:\r\nmatch = mls_level_eq(&rule->au_ctxt.range.level[0],\r\nlevel);\r\nbreak;\r\ncase Audit_not_equal:\r\nmatch = !mls_level_eq(&rule->au_ctxt.range.level[0],\r\nlevel);\r\nbreak;\r\ncase Audit_lt:\r\nmatch = (mls_level_dom(&rule->au_ctxt.range.level[0],\r\nlevel) &&\r\n!mls_level_eq(&rule->au_ctxt.range.level[0],\r\nlevel));\r\nbreak;\r\ncase Audit_le:\r\nmatch = mls_level_dom(&rule->au_ctxt.range.level[0],\r\nlevel);\r\nbreak;\r\ncase Audit_gt:\r\nmatch = (mls_level_dom(level,\r\n&rule->au_ctxt.range.level[0]) &&\r\n!mls_level_eq(level,\r\n&rule->au_ctxt.range.level[0]));\r\nbreak;\r\ncase Audit_ge:\r\nmatch = mls_level_dom(level,\r\n&rule->au_ctxt.range.level[0]);\r\nbreak;\r\n}\r\n}\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn match;\r\n}\r\nstatic int aurule_avc_callback(u32 event)\r\n{\r\nint err = 0;\r\nif (event == AVC_CALLBACK_RESET && aurule_callback)\r\nerr = aurule_callback();\r\nreturn err;\r\n}\r\nstatic int __init aurule_init(void)\r\n{\r\nint err;\r\nerr = avc_add_callback(aurule_avc_callback, AVC_CALLBACK_RESET);\r\nif (err)\r\npanic("avc_add_callback() failed, error %d\n", err);\r\nreturn err;\r\n}\r\nstatic void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,\r\nu32 sid)\r\n{\r\nu32 *sid_cache;\r\nsid_cache = kmalloc(sizeof(*sid_cache), GFP_ATOMIC);\r\nif (sid_cache == NULL)\r\nreturn;\r\nsecattr->cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\r\nif (secattr->cache == NULL) {\r\nkfree(sid_cache);\r\nreturn;\r\n}\r\n*sid_cache = sid;\r\nsecattr->cache->free = kfree;\r\nsecattr->cache->data = sid_cache;\r\nsecattr->flags |= NETLBL_SECATTR_CACHE;\r\n}\r\nint security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\r\nu32 *sid)\r\n{\r\nint rc;\r\nstruct context *ctx;\r\nstruct context ctx_new;\r\nif (!ss_initialized) {\r\n*sid = SECSID_NULL;\r\nreturn 0;\r\n}\r\nread_lock(&policy_rwlock);\r\nif (secattr->flags & NETLBL_SECATTR_CACHE)\r\n*sid = *(u32 *)secattr->cache->data;\r\nelse if (secattr->flags & NETLBL_SECATTR_SECID)\r\n*sid = secattr->attr.secid;\r\nelse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\r\nrc = -EIDRM;\r\nctx = sidtab_search(&sidtab, SECINITSID_NETMSG);\r\nif (ctx == NULL)\r\ngoto out;\r\ncontext_init(&ctx_new);\r\nctx_new.user = ctx->user;\r\nctx_new.role = ctx->role;\r\nctx_new.type = ctx->type;\r\nmls_import_netlbl_lvl(&ctx_new, secattr);\r\nif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\r\nrc = ebitmap_netlbl_import(&ctx_new.range.level[0].cat,\r\nsecattr->attr.mls.cat);\r\nif (rc)\r\ngoto out;\r\nmemcpy(&ctx_new.range.level[1].cat,\r\n&ctx_new.range.level[0].cat,\r\nsizeof(ctx_new.range.level[0].cat));\r\n}\r\nrc = -EIDRM;\r\nif (!mls_context_isvalid(&policydb, &ctx_new))\r\ngoto out_free;\r\nrc = sidtab_context_to_sid(&sidtab, &ctx_new, sid);\r\nif (rc)\r\ngoto out_free;\r\nsecurity_netlbl_cache_add(secattr, *sid);\r\nebitmap_destroy(&ctx_new.range.level[0].cat);\r\n} else\r\n*sid = SECSID_NULL;\r\nread_unlock(&policy_rwlock);\r\nreturn 0;\r\nout_free:\r\nebitmap_destroy(&ctx_new.range.level[0].cat);\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nint security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\r\n{\r\nint rc;\r\nstruct context *ctx;\r\nif (!ss_initialized)\r\nreturn 0;\r\nread_lock(&policy_rwlock);\r\nrc = -ENOENT;\r\nctx = sidtab_search(&sidtab, sid);\r\nif (ctx == NULL)\r\ngoto out;\r\nrc = -ENOMEM;\r\nsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\r\nGFP_ATOMIC);\r\nif (secattr->domain == NULL)\r\ngoto out;\r\nsecattr->attr.secid = sid;\r\nsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\r\nmls_export_netlbl_lvl(ctx, secattr);\r\nrc = mls_export_netlbl_cat(ctx, secattr);\r\nout:\r\nread_unlock(&policy_rwlock);\r\nreturn rc;\r\n}\r\nint security_read_policy(void **data, size_t *len)\r\n{\r\nint rc;\r\nstruct policy_file fp;\r\nif (!ss_initialized)\r\nreturn -EINVAL;\r\n*len = security_policydb_len();\r\n*data = vmalloc_user(*len);\r\nif (!*data)\r\nreturn -ENOMEM;\r\nfp.data = *data;\r\nfp.len = *len;\r\nread_lock(&policy_rwlock);\r\nrc = policydb_write(&policydb, &fp);\r\nread_unlock(&policy_rwlock);\r\nif (rc)\r\nreturn rc;\r\n*len = (unsigned long)fp.data - (unsigned long)*data;\r\nreturn 0;\r\n}
