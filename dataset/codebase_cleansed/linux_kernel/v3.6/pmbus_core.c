int pmbus_set_page(struct i2c_client *client, u8 page)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nint rv = 0;\r\nint newpage;\r\nif (page != data->currpage) {\r\nrv = i2c_smbus_write_byte_data(client, PMBUS_PAGE, page);\r\nnewpage = i2c_smbus_read_byte_data(client, PMBUS_PAGE);\r\nif (newpage != page)\r\nrv = -EIO;\r\nelse\r\ndata->currpage = page;\r\n}\r\nreturn rv;\r\n}\r\nint pmbus_write_byte(struct i2c_client *client, int page, u8 value)\r\n{\r\nint rv;\r\nif (page >= 0) {\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\n}\r\nreturn i2c_smbus_write_byte(client, value);\r\n}\r\nstatic int _pmbus_write_byte(struct i2c_client *client, int page, u8 value)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nint status;\r\nif (info->write_byte) {\r\nstatus = info->write_byte(client, page, value);\r\nif (status != -ENODATA)\r\nreturn status;\r\n}\r\nreturn pmbus_write_byte(client, page, value);\r\n}\r\nint pmbus_write_word_data(struct i2c_client *client, u8 page, u8 reg, u16 word)\r\n{\r\nint rv;\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\nreturn i2c_smbus_write_word_data(client, reg, word);\r\n}\r\nstatic int _pmbus_write_word_data(struct i2c_client *client, int page, int reg,\r\nu16 word)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nint status;\r\nif (info->write_word_data) {\r\nstatus = info->write_word_data(client, page, reg, word);\r\nif (status != -ENODATA)\r\nreturn status;\r\n}\r\nif (reg >= PMBUS_VIRT_BASE)\r\nreturn -ENXIO;\r\nreturn pmbus_write_word_data(client, page, reg, word);\r\n}\r\nint pmbus_read_word_data(struct i2c_client *client, u8 page, u8 reg)\r\n{\r\nint rv;\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\nreturn i2c_smbus_read_word_data(client, reg);\r\n}\r\nstatic int _pmbus_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nint status;\r\nif (info->read_word_data) {\r\nstatus = info->read_word_data(client, page, reg);\r\nif (status != -ENODATA)\r\nreturn status;\r\n}\r\nif (reg >= PMBUS_VIRT_BASE)\r\nreturn -ENXIO;\r\nreturn pmbus_read_word_data(client, page, reg);\r\n}\r\nint pmbus_read_byte_data(struct i2c_client *client, int page, u8 reg)\r\n{\r\nint rv;\r\nif (page >= 0) {\r\nrv = pmbus_set_page(client, page);\r\nif (rv < 0)\r\nreturn rv;\r\n}\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int _pmbus_read_byte_data(struct i2c_client *client, int page, int reg)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nint status;\r\nif (info->read_byte_data) {\r\nstatus = info->read_byte_data(client, page, reg);\r\nif (status != -ENODATA)\r\nreturn status;\r\n}\r\nreturn pmbus_read_byte_data(client, page, reg);\r\n}\r\nstatic void pmbus_clear_fault_page(struct i2c_client *client, int page)\r\n{\r\n_pmbus_write_byte(client, page, PMBUS_CLEAR_FAULTS);\r\n}\r\nvoid pmbus_clear_faults(struct i2c_client *client)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < data->info->pages; i++)\r\npmbus_clear_fault_page(client, i);\r\n}\r\nstatic int pmbus_check_status_cml(struct i2c_client *client)\r\n{\r\nint status, status2;\r\nstatus = _pmbus_read_byte_data(client, -1, PMBUS_STATUS_BYTE);\r\nif (status < 0 || (status & PB_STATUS_CML)) {\r\nstatus2 = _pmbus_read_byte_data(client, -1, PMBUS_STATUS_CML);\r\nif (status2 < 0 || (status2 & PB_CML_FAULT_INVALID_COMMAND))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nbool pmbus_check_byte_register(struct i2c_client *client, int page, int reg)\r\n{\r\nint rv;\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nrv = _pmbus_read_byte_data(client, page, reg);\r\nif (rv >= 0 && !(data->flags & PMBUS_SKIP_STATUS_CHECK))\r\nrv = pmbus_check_status_cml(client);\r\npmbus_clear_fault_page(client, -1);\r\nreturn rv >= 0;\r\n}\r\nbool pmbus_check_word_register(struct i2c_client *client, int page, int reg)\r\n{\r\nint rv;\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nrv = _pmbus_read_word_data(client, page, reg);\r\nif (rv >= 0 && !(data->flags & PMBUS_SKIP_STATUS_CHECK))\r\nrv = pmbus_check_status_cml(client);\r\npmbus_clear_fault_page(client, -1);\r\nreturn rv >= 0;\r\n}\r\nconst struct pmbus_driver_info *pmbus_get_driver_info(struct i2c_client *client)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nreturn data->info;\r\n}\r\nstatic struct pmbus_data *pmbus_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nconst struct pmbus_driver_info *info = data->info;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\nint i;\r\nfor (i = 0; i < info->pages; i++)\r\ndata->status[PB_STATUS_BASE + i]\r\n= _pmbus_read_byte_data(client, i,\r\nPMBUS_STATUS_BYTE);\r\nfor (i = 0; i < info->pages; i++) {\r\nif (!(info->func[i] & PMBUS_HAVE_STATUS_VOUT))\r\ncontinue;\r\ndata->status[PB_STATUS_VOUT_BASE + i]\r\n= _pmbus_read_byte_data(client, i, PMBUS_STATUS_VOUT);\r\n}\r\nfor (i = 0; i < info->pages; i++) {\r\nif (!(info->func[i] & PMBUS_HAVE_STATUS_IOUT))\r\ncontinue;\r\ndata->status[PB_STATUS_IOUT_BASE + i]\r\n= _pmbus_read_byte_data(client, i, PMBUS_STATUS_IOUT);\r\n}\r\nfor (i = 0; i < info->pages; i++) {\r\nif (!(info->func[i] & PMBUS_HAVE_STATUS_TEMP))\r\ncontinue;\r\ndata->status[PB_STATUS_TEMP_BASE + i]\r\n= _pmbus_read_byte_data(client, i,\r\nPMBUS_STATUS_TEMPERATURE);\r\n}\r\nfor (i = 0; i < info->pages; i++) {\r\nif (!(info->func[i] & PMBUS_HAVE_STATUS_FAN12))\r\ncontinue;\r\ndata->status[PB_STATUS_FAN_BASE + i]\r\n= _pmbus_read_byte_data(client, i,\r\nPMBUS_STATUS_FAN_12);\r\n}\r\nfor (i = 0; i < info->pages; i++) {\r\nif (!(info->func[i] & PMBUS_HAVE_STATUS_FAN34))\r\ncontinue;\r\ndata->status[PB_STATUS_FAN34_BASE + i]\r\n= _pmbus_read_byte_data(client, i,\r\nPMBUS_STATUS_FAN_34);\r\n}\r\nif (info->func[0] & PMBUS_HAVE_STATUS_INPUT)\r\ndata->status[PB_STATUS_INPUT_BASE]\r\n= _pmbus_read_byte_data(client, 0,\r\nPMBUS_STATUS_INPUT);\r\nfor (i = 0; i < data->num_sensors; i++) {\r\nstruct pmbus_sensor *sensor = &data->sensors[i];\r\nif (!data->valid || sensor->update)\r\nsensor->data\r\n= _pmbus_read_word_data(client,\r\nsensor->page,\r\nsensor->reg);\r\n}\r\npmbus_clear_faults(client);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic long pmbus_reg2data_linear(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor)\r\n{\r\ns16 exponent;\r\ns32 mantissa;\r\nlong val;\r\nif (sensor->class == PSC_VOLTAGE_OUT) {\r\nexponent = data->exponent;\r\nmantissa = (u16) sensor->data;\r\n} else {\r\nexponent = ((s16)sensor->data) >> 11;\r\nmantissa = ((s16)((sensor->data & 0x7ff) << 5)) >> 5;\r\n}\r\nval = mantissa;\r\nif (sensor->class != PSC_FAN)\r\nval = val * 1000L;\r\nif (sensor->class == PSC_POWER)\r\nval = val * 1000L;\r\nif (exponent >= 0)\r\nval <<= exponent;\r\nelse\r\nval >>= -exponent;\r\nreturn val;\r\n}\r\nstatic long pmbus_reg2data_direct(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor)\r\n{\r\nlong val = (s16) sensor->data;\r\nlong m, b, R;\r\nm = data->info->m[sensor->class];\r\nb = data->info->b[sensor->class];\r\nR = data->info->R[sensor->class];\r\nif (m == 0)\r\nreturn 0;\r\nR = -R;\r\nif (sensor->class != PSC_FAN) {\r\nR += 3;\r\nb *= 1000;\r\n}\r\nif (sensor->class == PSC_POWER) {\r\nR += 3;\r\nb *= 1000;\r\n}\r\nwhile (R > 0) {\r\nval *= 10;\r\nR--;\r\n}\r\nwhile (R < 0) {\r\nval = DIV_ROUND_CLOSEST(val, 10);\r\nR++;\r\n}\r\nreturn (val - b) / m;\r\n}\r\nstatic long pmbus_reg2data_vid(struct pmbus_data *data,\r\nstruct pmbus_sensor *sensor)\r\n{\r\nlong val = sensor->data;\r\nif (val < 0x02 || val > 0xb2)\r\nreturn 0;\r\nreturn DIV_ROUND_CLOSEST(160000 - (val - 2) * 625, 100);\r\n}\r\nstatic long pmbus_reg2data(struct pmbus_data *data, struct pmbus_sensor *sensor)\r\n{\r\nlong val;\r\nswitch (data->info->format[sensor->class]) {\r\ncase direct:\r\nval = pmbus_reg2data_direct(data, sensor);\r\nbreak;\r\ncase vid:\r\nval = pmbus_reg2data_vid(data, sensor);\r\nbreak;\r\ncase linear:\r\ndefault:\r\nval = pmbus_reg2data_linear(data, sensor);\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic u16 pmbus_data2reg_linear(struct pmbus_data *data,\r\nenum pmbus_sensor_classes class, long val)\r\n{\r\ns16 exponent = 0, mantissa;\r\nbool negative = false;\r\nif (val == 0)\r\nreturn 0;\r\nif (class == PSC_VOLTAGE_OUT) {\r\nif (val < 0)\r\nreturn 0;\r\nif (data->exponent < 0)\r\nval <<= -data->exponent;\r\nelse\r\nval >>= data->exponent;\r\nval = DIV_ROUND_CLOSEST(val, 1000);\r\nreturn val & 0xffff;\r\n}\r\nif (val < 0) {\r\nnegative = true;\r\nval = -val;\r\n}\r\nif (class == PSC_POWER)\r\nval = DIV_ROUND_CLOSEST(val, 1000L);\r\nif (class == PSC_FAN)\r\nval = val * 1000;\r\nwhile (val >= MAX_MANTISSA && exponent < 15) {\r\nexponent++;\r\nval >>= 1;\r\n}\r\nwhile (val < MIN_MANTISSA && exponent > -15) {\r\nexponent--;\r\nval <<= 1;\r\n}\r\nmantissa = DIV_ROUND_CLOSEST(val, 1000);\r\nif (mantissa > 0x3ff)\r\nmantissa = 0x3ff;\r\nif (negative)\r\nmantissa = -mantissa;\r\nreturn (mantissa & 0x7ff) | ((exponent << 11) & 0xf800);\r\n}\r\nstatic u16 pmbus_data2reg_direct(struct pmbus_data *data,\r\nenum pmbus_sensor_classes class, long val)\r\n{\r\nlong m, b, R;\r\nm = data->info->m[class];\r\nb = data->info->b[class];\r\nR = data->info->R[class];\r\nif (class == PSC_POWER) {\r\nR -= 3;\r\nb *= 1000;\r\n}\r\nif (class != PSC_FAN) {\r\nR -= 3;\r\nb *= 1000;\r\n}\r\nval = val * m + b;\r\nwhile (R > 0) {\r\nval *= 10;\r\nR--;\r\n}\r\nwhile (R < 0) {\r\nval = DIV_ROUND_CLOSEST(val, 10);\r\nR++;\r\n}\r\nreturn val;\r\n}\r\nstatic u16 pmbus_data2reg_vid(struct pmbus_data *data,\r\nenum pmbus_sensor_classes class, long val)\r\n{\r\nval = SENSORS_LIMIT(val, 500, 1600);\r\nreturn 2 + DIV_ROUND_CLOSEST((1600 - val) * 100, 625);\r\n}\r\nstatic u16 pmbus_data2reg(struct pmbus_data *data,\r\nenum pmbus_sensor_classes class, long val)\r\n{\r\nu16 regval;\r\nswitch (data->info->format[class]) {\r\ncase direct:\r\nregval = pmbus_data2reg_direct(data, class, val);\r\nbreak;\r\ncase vid:\r\nregval = pmbus_data2reg_vid(data, class, val);\r\nbreak;\r\ncase linear:\r\ndefault:\r\nregval = pmbus_data2reg_linear(data, class, val);\r\nbreak;\r\n}\r\nreturn regval;\r\n}\r\nstatic int pmbus_get_boolean(struct pmbus_data *data, int index)\r\n{\r\nu8 s1 = (index >> 24) & 0xff;\r\nu8 s2 = (index >> 16) & 0xff;\r\nu8 reg = (index >> 8) & 0xff;\r\nu8 mask = index & 0xff;\r\nint ret, status;\r\nu8 regval;\r\nstatus = data->status[reg];\r\nif (status < 0)\r\nreturn status;\r\nregval = status & mask;\r\nif (!s1 && !s2)\r\nret = !!regval;\r\nelse {\r\nlong v1, v2;\r\nstruct pmbus_sensor *sensor1, *sensor2;\r\nsensor1 = &data->sensors[s1];\r\nif (sensor1->data < 0)\r\nreturn sensor1->data;\r\nsensor2 = &data->sensors[s2];\r\nif (sensor2->data < 0)\r\nreturn sensor2->data;\r\nv1 = pmbus_reg2data(data, sensor1);\r\nv2 = pmbus_reg2data(data, sensor2);\r\nret = !!(regval && v1 >= v2);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t pmbus_show_boolean(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct pmbus_data *data = pmbus_update_device(dev);\r\nint val;\r\nval = pmbus_get_boolean(data, attr->index);\r\nif (val < 0)\r\nreturn val;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", val);\r\n}\r\nstatic ssize_t pmbus_show_sensor(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct pmbus_data *data = pmbus_update_device(dev);\r\nstruct pmbus_sensor *sensor;\r\nsensor = &data->sensors[attr->index];\r\nif (sensor->data < 0)\r\nreturn sensor->data;\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", pmbus_reg2data(data, sensor));\r\n}\r\nstatic ssize_t pmbus_set_sensor(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nstruct pmbus_sensor *sensor = &data->sensors[attr->index];\r\nssize_t rv = count;\r\nlong val = 0;\r\nint ret;\r\nu16 regval;\r\nif (kstrtol(buf, 10, &val) < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nregval = pmbus_data2reg(data, sensor->class, val);\r\nret = _pmbus_write_word_data(client, sensor->page, sensor->reg, regval);\r\nif (ret < 0)\r\nrv = ret;\r\nelse\r\ndata->sensors[attr->index].data = regval;\r\nmutex_unlock(&data->update_lock);\r\nreturn rv;\r\n}\r\nstatic ssize_t pmbus_show_label(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\ndata->labels[attr->index].label);\r\n}\r\nstatic void pmbus_add_boolean(struct pmbus_data *data,\r\nconst char *name, const char *type, int seq,\r\nint idx)\r\n{\r\nstruct pmbus_boolean *boolean;\r\nBUG_ON(data->num_booleans >= data->max_booleans);\r\nboolean = &data->booleans[data->num_booleans];\r\nsnprintf(boolean->name, sizeof(boolean->name), "%s%d_%s",\r\nname, seq, type);\r\nPMBUS_ADD_GET_ATTR(data, boolean->name, boolean, idx);\r\ndata->num_booleans++;\r\n}\r\nstatic void pmbus_add_boolean_reg(struct pmbus_data *data,\r\nconst char *name, const char *type,\r\nint seq, int reg, int bit)\r\n{\r\npmbus_add_boolean(data, name, type, seq, (reg << 8) | bit);\r\n}\r\nstatic void pmbus_add_boolean_cmp(struct pmbus_data *data,\r\nconst char *name, const char *type,\r\nint seq, int i1, int i2, int reg, int mask)\r\n{\r\npmbus_add_boolean(data, name, type, seq,\r\n(i1 << 24) | (i2 << 16) | (reg << 8) | mask);\r\n}\r\nstatic void pmbus_add_sensor(struct pmbus_data *data,\r\nconst char *name, const char *type, int seq,\r\nint page, int reg, enum pmbus_sensor_classes class,\r\nbool update, bool readonly)\r\n{\r\nstruct pmbus_sensor *sensor;\r\nBUG_ON(data->num_sensors >= data->max_sensors);\r\nsensor = &data->sensors[data->num_sensors];\r\nsnprintf(sensor->name, sizeof(sensor->name), "%s%d_%s",\r\nname, seq, type);\r\nsensor->page = page;\r\nsensor->reg = reg;\r\nsensor->class = class;\r\nsensor->update = update;\r\nif (readonly)\r\nPMBUS_ADD_GET_ATTR(data, sensor->name, sensor,\r\ndata->num_sensors);\r\nelse\r\nPMBUS_ADD_SET_ATTR(data, sensor->name, sensor,\r\ndata->num_sensors);\r\ndata->num_sensors++;\r\n}\r\nstatic void pmbus_add_label(struct pmbus_data *data,\r\nconst char *name, int seq,\r\nconst char *lstring, int index)\r\n{\r\nstruct pmbus_label *label;\r\nBUG_ON(data->num_labels >= data->max_labels);\r\nlabel = &data->labels[data->num_labels];\r\nsnprintf(label->name, sizeof(label->name), "%s%d_label", name, seq);\r\nif (!index)\r\nstrncpy(label->label, lstring, sizeof(label->label) - 1);\r\nelse\r\nsnprintf(label->label, sizeof(label->label), "%s%d", lstring,\r\nindex);\r\nPMBUS_ADD_GET_ATTR(data, label->name, label, data->num_labels);\r\ndata->num_labels++;\r\n}\r\nstatic void pmbus_find_max_attr(struct i2c_client *client,\r\nstruct pmbus_data *data)\r\n{\r\nconst struct pmbus_driver_info *info = data->info;\r\nint page, max_sensors, max_booleans, max_labels;\r\nmax_sensors = PMBUS_MAX_INPUT_SENSORS;\r\nmax_booleans = PMBUS_MAX_INPUT_BOOLEANS;\r\nmax_labels = PMBUS_MAX_INPUT_LABELS;\r\nfor (page = 0; page < info->pages; page++) {\r\nif (info->func[page] & PMBUS_HAVE_VOUT) {\r\nmax_sensors += PMBUS_VOUT_SENSORS_PER_PAGE;\r\nmax_booleans += PMBUS_VOUT_BOOLEANS_PER_PAGE;\r\nmax_labels++;\r\n}\r\nif (info->func[page] & PMBUS_HAVE_IOUT) {\r\nmax_sensors += PMBUS_IOUT_SENSORS_PER_PAGE;\r\nmax_booleans += PMBUS_IOUT_BOOLEANS_PER_PAGE;\r\nmax_labels++;\r\n}\r\nif (info->func[page] & PMBUS_HAVE_POUT) {\r\nmax_sensors += PMBUS_POUT_SENSORS_PER_PAGE;\r\nmax_booleans += PMBUS_POUT_BOOLEANS_PER_PAGE;\r\nmax_labels++;\r\n}\r\nif (info->func[page] & PMBUS_HAVE_FAN12) {\r\nmax_sensors += 2 * PMBUS_MAX_SENSORS_PER_FAN;\r\nmax_booleans += 2 * PMBUS_MAX_BOOLEANS_PER_FAN;\r\n}\r\nif (info->func[page] & PMBUS_HAVE_FAN34) {\r\nmax_sensors += 2 * PMBUS_MAX_SENSORS_PER_FAN;\r\nmax_booleans += 2 * PMBUS_MAX_BOOLEANS_PER_FAN;\r\n}\r\nif (info->func[page] & PMBUS_HAVE_TEMP) {\r\nmax_sensors += PMBUS_MAX_SENSORS_PER_TEMP;\r\nmax_booleans += PMBUS_MAX_BOOLEANS_PER_TEMP;\r\n}\r\nif (info->func[page] & PMBUS_HAVE_TEMP2) {\r\nmax_sensors += PMBUS_MAX_SENSORS_PER_TEMP;\r\nmax_booleans += PMBUS_MAX_BOOLEANS_PER_TEMP;\r\n}\r\nif (info->func[page] & PMBUS_HAVE_TEMP3) {\r\nmax_sensors += PMBUS_MAX_SENSORS_PER_TEMP;\r\nmax_booleans += PMBUS_MAX_BOOLEANS_PER_TEMP;\r\n}\r\n}\r\ndata->max_sensors = max_sensors;\r\ndata->max_booleans = max_booleans;\r\ndata->max_labels = max_labels;\r\ndata->max_attributes = max_sensors + max_booleans + max_labels;\r\n}\r\nstatic bool pmbus_add_limit_attrs(struct i2c_client *client,\r\nstruct pmbus_data *data,\r\nconst struct pmbus_driver_info *info,\r\nconst char *name, int index, int page,\r\nint cbase,\r\nconst struct pmbus_sensor_attr *attr)\r\n{\r\nconst struct pmbus_limit_attr *l = attr->limit;\r\nint nlimit = attr->nlimit;\r\nbool have_alarm = false;\r\nint i, cindex;\r\nfor (i = 0; i < nlimit; i++) {\r\nif (pmbus_check_word_register(client, page, l->reg)) {\r\ncindex = data->num_sensors;\r\npmbus_add_sensor(data, name, l->attr, index, page,\r\nl->reg, attr->class,\r\nattr->update || l->update,\r\nfalse);\r\nif (l->sbit && (info->func[page] & attr->sfunc)) {\r\nif (attr->compare) {\r\npmbus_add_boolean_cmp(data, name,\r\nl->alarm, index,\r\nl->low ? cindex : cbase,\r\nl->low ? cbase : cindex,\r\nattr->sbase + page, l->sbit);\r\n} else {\r\npmbus_add_boolean_reg(data, name,\r\nl->alarm, index,\r\nattr->sbase + page, l->sbit);\r\n}\r\nhave_alarm = true;\r\n}\r\n}\r\nl++;\r\n}\r\nreturn have_alarm;\r\n}\r\nstatic void pmbus_add_sensor_attrs_one(struct i2c_client *client,\r\nstruct pmbus_data *data,\r\nconst struct pmbus_driver_info *info,\r\nconst char *name,\r\nint index, int page,\r\nconst struct pmbus_sensor_attr *attr)\r\n{\r\nbool have_alarm;\r\nint cbase = data->num_sensors;\r\nif (attr->label)\r\npmbus_add_label(data, name, index, attr->label,\r\nattr->paged ? page + 1 : 0);\r\npmbus_add_sensor(data, name, "input", index, page, attr->reg,\r\nattr->class, true, true);\r\nif (attr->sfunc) {\r\nhave_alarm = pmbus_add_limit_attrs(client, data, info, name,\r\nindex, page, cbase, attr);\r\nif (!have_alarm && attr->gbit &&\r\npmbus_check_byte_register(client, page, PMBUS_STATUS_BYTE))\r\npmbus_add_boolean_reg(data, name, "alarm", index,\r\nPB_STATUS_BASE + page,\r\nattr->gbit);\r\n}\r\n}\r\nstatic void pmbus_add_sensor_attrs(struct i2c_client *client,\r\nstruct pmbus_data *data,\r\nconst char *name,\r\nconst struct pmbus_sensor_attr *attrs,\r\nint nattrs)\r\n{\r\nconst struct pmbus_driver_info *info = data->info;\r\nint index, i;\r\nindex = 1;\r\nfor (i = 0; i < nattrs; i++) {\r\nint page, pages;\r\npages = attrs->paged ? info->pages : 1;\r\nfor (page = 0; page < pages; page++) {\r\nif (!(info->func[page] & attrs->func))\r\ncontinue;\r\npmbus_add_sensor_attrs_one(client, data, info, name,\r\nindex, page, attrs);\r\nindex++;\r\n}\r\nattrs++;\r\n}\r\n}\r\nstatic void pmbus_add_fan_attributes(struct i2c_client *client,\r\nstruct pmbus_data *data)\r\n{\r\nconst struct pmbus_driver_info *info = data->info;\r\nint index = 1;\r\nint page;\r\nfor (page = 0; page < info->pages; page++) {\r\nint f;\r\nfor (f = 0; f < ARRAY_SIZE(pmbus_fan_registers); f++) {\r\nint regval;\r\nif (!(info->func[page] & pmbus_fan_flags[f]))\r\nbreak;\r\nif (!pmbus_check_word_register(client, page,\r\npmbus_fan_registers[f]))\r\nbreak;\r\nregval = _pmbus_read_byte_data(client, page,\r\npmbus_fan_config_registers[f]);\r\nif (regval < 0 ||\r\n(!(regval & (PB_FAN_1_INSTALLED >> ((f & 1) * 4)))))\r\ncontinue;\r\npmbus_add_sensor(data, "fan", "input", index, page,\r\npmbus_fan_registers[f], PSC_FAN, true,\r\ntrue);\r\nif ((info->func[page] & pmbus_fan_status_flags[f]) &&\r\npmbus_check_byte_register(client,\r\npage, pmbus_fan_status_registers[f])) {\r\nint base;\r\nif (f > 1)\r\nbase = PB_STATUS_FAN34_BASE + page;\r\nelse\r\nbase = PB_STATUS_FAN_BASE + page;\r\npmbus_add_boolean_reg(data, "fan", "alarm",\r\nindex, base,\r\nPB_FAN_FAN1_WARNING >> (f & 1));\r\npmbus_add_boolean_reg(data, "fan", "fault",\r\nindex, base,\r\nPB_FAN_FAN1_FAULT >> (f & 1));\r\n}\r\nindex++;\r\n}\r\n}\r\n}\r\nstatic void pmbus_find_attributes(struct i2c_client *client,\r\nstruct pmbus_data *data)\r\n{\r\npmbus_add_sensor_attrs(client, data, "in", voltage_attributes,\r\nARRAY_SIZE(voltage_attributes));\r\npmbus_add_sensor_attrs(client, data, "curr", current_attributes,\r\nARRAY_SIZE(current_attributes));\r\npmbus_add_sensor_attrs(client, data, "power", power_attributes,\r\nARRAY_SIZE(power_attributes));\r\npmbus_add_sensor_attrs(client, data, "temp", temp_attributes,\r\nARRAY_SIZE(temp_attributes));\r\npmbus_add_fan_attributes(client, data);\r\n}\r\nstatic int pmbus_identify_common(struct i2c_client *client,\r\nstruct pmbus_data *data)\r\n{\r\nint vout_mode = -1;\r\nif (pmbus_check_byte_register(client, 0, PMBUS_VOUT_MODE))\r\nvout_mode = _pmbus_read_byte_data(client, 0, PMBUS_VOUT_MODE);\r\nif (vout_mode >= 0 && vout_mode != 0xff) {\r\nswitch (vout_mode >> 5) {\r\ncase 0:\r\nif (data->info->format[PSC_VOLTAGE_OUT] != linear)\r\nreturn -ENODEV;\r\ndata->exponent = ((s8)(vout_mode << 3)) >> 3;\r\nbreak;\r\ncase 1:\r\nif (data->info->format[PSC_VOLTAGE_OUT] != vid)\r\nreturn -ENODEV;\r\nbreak;\r\ncase 2:\r\nif (data->info->format[PSC_VOLTAGE_OUT] != direct)\r\nreturn -ENODEV;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\npmbus_find_max_attr(client, data);\r\npmbus_clear_fault_page(client, 0);\r\nreturn 0;\r\n}\r\nint pmbus_do_probe(struct i2c_client *client, const struct i2c_device_id *id,\r\nstruct pmbus_driver_info *info)\r\n{\r\nconst struct pmbus_platform_data *pdata = client->dev.platform_data;\r\nstruct pmbus_data *data;\r\nint ret;\r\nif (!info) {\r\ndev_err(&client->dev, "Missing chip information");\r\nreturn -ENODEV;\r\n}\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WRITE_BYTE\r\n| I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&client->dev, "No memory to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nif (i2c_smbus_read_byte_data(client, PMBUS_STATUS_BYTE) < 0) {\r\ndev_err(&client->dev, "PMBus status register not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdata)\r\ndata->flags = pdata->flags;\r\ndata->info = info;\r\npmbus_clear_faults(client);\r\nif (info->identify) {\r\nret = (*info->identify)(client, info);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Chip identification failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (info->pages <= 0 || info->pages > PMBUS_PAGES) {\r\ndev_err(&client->dev, "Bad number of PMBus pages: %d\n",\r\ninfo->pages);\r\nreturn -ENODEV;\r\n}\r\nret = pmbus_identify_common(client, data);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to identify chip capabilities\n");\r\nreturn ret;\r\n}\r\nret = -ENOMEM;\r\ndata->sensors = devm_kzalloc(&client->dev, sizeof(struct pmbus_sensor)\r\n* data->max_sensors, GFP_KERNEL);\r\nif (!data->sensors) {\r\ndev_err(&client->dev, "No memory to allocate sensor data\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->booleans = devm_kzalloc(&client->dev, sizeof(struct pmbus_boolean)\r\n* data->max_booleans, GFP_KERNEL);\r\nif (!data->booleans) {\r\ndev_err(&client->dev, "No memory to allocate boolean data\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->labels = devm_kzalloc(&client->dev, sizeof(struct pmbus_label)\r\n* data->max_labels, GFP_KERNEL);\r\nif (!data->labels) {\r\ndev_err(&client->dev, "No memory to allocate label data\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->attributes = devm_kzalloc(&client->dev, sizeof(struct attribute *)\r\n* data->max_attributes, GFP_KERNEL);\r\nif (!data->attributes) {\r\ndev_err(&client->dev, "No memory to allocate attribute data\n");\r\nreturn -ENOMEM;\r\n}\r\npmbus_find_attributes(client, data);\r\nif (!data->num_attributes) {\r\ndev_err(&client->dev, "No attributes found\n");\r\nreturn -ENODEV;\r\n}\r\ndata->group.attrs = data->attributes;\r\nret = sysfs_create_group(&client->dev.kobj, &data->group);\r\nif (ret) {\r\ndev_err(&client->dev, "Failed to create sysfs entries\n");\r\nreturn ret;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ndev_err(&client->dev, "Failed to register hwmon device\n");\r\ngoto out_hwmon_device_register;\r\n}\r\nreturn 0;\r\nout_hwmon_device_register:\r\nsysfs_remove_group(&client->dev.kobj, &data->group);\r\nreturn ret;\r\n}\r\nint pmbus_do_remove(struct i2c_client *client)\r\n{\r\nstruct pmbus_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &data->group);\r\nreturn 0;\r\n}
