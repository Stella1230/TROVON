static void clps711xuart_stop_tx(struct uart_port *port)\r\n{\r\nif (tx_enabled(port)) {\r\ndisable_irq(TX_IRQ(port));\r\ntx_enabled(port) = 0;\r\n}\r\n}\r\nstatic void clps711xuart_start_tx(struct uart_port *port)\r\n{\r\nif (!tx_enabled(port)) {\r\nenable_irq(TX_IRQ(port));\r\ntx_enabled(port) = 1;\r\n}\r\n}\r\nstatic void clps711xuart_stop_rx(struct uart_port *port)\r\n{\r\ndisable_irq(RX_IRQ(port));\r\n}\r\nstatic void clps711xuart_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic irqreturn_t clps711xuart_int_rx(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct tty_struct *tty = port->state->port.tty;\r\nunsigned int status, ch, flg;\r\nstatus = clps_readl(SYSFLG(port));\r\nwhile (!(status & SYSFLG_URXFE)) {\r\nch = clps_readl(UARTDR(port));\r\nport->icount.rx++;\r\nflg = TTY_NORMAL;\r\nif (unlikely(ch & UART_ANY_ERR)) {\r\nif (ch & UARTDR_PARERR)\r\nport->icount.parity++;\r\nelse if (ch & UARTDR_FRMERR)\r\nport->icount.frame++;\r\nif (ch & UARTDR_OVERR)\r\nport->icount.overrun++;\r\nch &= port->read_status_mask;\r\nif (ch & UARTDR_PARERR)\r\nflg = TTY_PARITY;\r\nelse if (ch & UARTDR_FRMERR)\r\nflg = TTY_FRAME;\r\n#ifdef SUPPORT_SYSRQ\r\nport->sysrq = 0;\r\n#endif\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(port, ch, UARTDR_OVERR, ch, flg);\r\nignore_char:\r\nstatus = clps_readl(SYSFLG(port));\r\n}\r\ntty_flip_buffer_push(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t clps711xuart_int_tx(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nint count;\r\nif (port->x_char) {\r\nclps_writel(port->x_char, UARTDR(port));\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\ngoto disable_tx_irq;\r\ncount = port->fifosize >> 1;\r\ndo {\r\nclps_writel(xmit->buf[xmit->tail], UARTDR(port));\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit)) {\r\ndisable_tx_irq:\r\ndisable_irq_nosync(TX_IRQ(port));\r\ntx_enabled(port) = 0;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int clps711xuart_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int status = clps_readl(SYSFLG(port));\r\nreturn status & SYSFLG_UBUSY ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int clps711xuart_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int port_addr;\r\nunsigned int result = 0;\r\nunsigned int status;\r\nport_addr = SYSFLG(port);\r\nif (port_addr == SYSFLG1) {\r\nstatus = clps_readl(SYSFLG1);\r\nif (status & SYSFLG1_DCD)\r\nresult |= TIOCM_CAR;\r\nif (status & SYSFLG1_DSR)\r\nresult |= TIOCM_DSR;\r\nif (status & SYSFLG1_CTS)\r\nresult |= TIOCM_CTS;\r\n}\r\nreturn result;\r\n}\r\nstatic void\r\nclps711xuart_set_mctrl_null(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void clps711xuart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned long flags;\r\nunsigned int ubrlcr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nubrlcr = clps_readl(UBRLCR(port));\r\nif (break_state == -1)\r\nubrlcr |= UBRLCR_BREAK;\r\nelse\r\nubrlcr &= ~UBRLCR_BREAK;\r\nclps_writel(ubrlcr, UBRLCR(port));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int clps711xuart_startup(struct uart_port *port)\r\n{\r\nunsigned int syscon;\r\nint retval;\r\ntx_enabled(port) = 1;\r\nretval = request_irq(TX_IRQ(port), clps711xuart_int_tx, 0,\r\n"clps711xuart_tx", port);\r\nif (retval)\r\nreturn retval;\r\nretval = request_irq(RX_IRQ(port), clps711xuart_int_rx, 0,\r\n"clps711xuart_rx", port);\r\nif (retval) {\r\nfree_irq(TX_IRQ(port), port);\r\nreturn retval;\r\n}\r\nsyscon = clps_readl(SYSCON(port));\r\nsyscon |= SYSCON_UARTEN;\r\nclps_writel(syscon, SYSCON(port));\r\nreturn 0;\r\n}\r\nstatic void clps711xuart_shutdown(struct uart_port *port)\r\n{\r\nunsigned int ubrlcr, syscon;\r\nfree_irq(TX_IRQ(port), port);\r\nfree_irq(RX_IRQ(port), port);\r\nsyscon = clps_readl(SYSCON(port));\r\nsyscon &= ~SYSCON_UARTEN;\r\nclps_writel(syscon, SYSCON(port));\r\nubrlcr = clps_readl(UBRLCR(port));\r\nubrlcr &= ~(UBRLCR_FIFOEN | UBRLCR_BREAK);\r\nclps_writel(ubrlcr, UBRLCR(port));\r\n}\r\nstatic void\r\nclps711xuart_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int ubrlcr, baud, quot;\r\nunsigned long flags;\r\ntermios->c_cflag |= CREAD;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nubrlcr = UBRLCR_WRDLEN5;\r\nbreak;\r\ncase CS6:\r\nubrlcr = UBRLCR_WRDLEN6;\r\nbreak;\r\ncase CS7:\r\nubrlcr = UBRLCR_WRDLEN7;\r\nbreak;\r\ndefault:\r\nubrlcr = UBRLCR_WRDLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nubrlcr |= UBRLCR_XSTOP;\r\nif (termios->c_cflag & PARENB) {\r\nubrlcr |= UBRLCR_PRTEN;\r\nif (!(termios->c_cflag & PARODD))\r\nubrlcr |= UBRLCR_EVENPRT;\r\n}\r\nif (port->fifosize > 1)\r\nubrlcr |= UBRLCR_FIFOEN;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nport->read_status_mask = UARTDR_OVERR;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UARTDR_PARERR | UARTDR_FRMERR;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UARTDR_FRMERR | UARTDR_PARERR;\r\nif (termios->c_iflag & IGNBRK) {\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UARTDR_OVERR;\r\n}\r\nquot -= 1;\r\nclps_writel(ubrlcr | quot, UBRLCR(port));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *clps711xuart_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_CLPS711X ? "CLPS711x" : NULL;\r\n}\r\nstatic void clps711xuart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_CLPS711X;\r\n}\r\nstatic void clps711xuart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int clps711xuart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void clps711xuart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (clps_readl(SYSFLG(port)) & SYSFLG_UTXFF)\r\nbarrier();\r\nclps_writel(ch, UARTDR(port));\r\n}\r\nstatic void\r\nclps711xuart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = clps711x_ports + co->index;\r\nunsigned int status, syscon;\r\nsyscon = clps_readl(SYSCON(port));\r\nclps_writel(syscon | SYSCON_UARTEN, SYSCON(port));\r\nuart_console_write(port, s, count, clps711xuart_console_putchar);\r\ndo {\r\nstatus = clps_readl(SYSFLG(port));\r\n} while (status & SYSFLG_UBUSY);\r\nclps_writel(syscon, SYSCON(port));\r\n}\r\nstatic void __init\r\nclps711xuart_console_get_options(struct uart_port *port, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (clps_readl(SYSCON(port)) & SYSCON_UARTEN) {\r\nunsigned int ubrlcr, quot;\r\nubrlcr = clps_readl(UBRLCR(port));\r\n*parity = 'n';\r\nif (ubrlcr & UBRLCR_PRTEN) {\r\nif (ubrlcr & UBRLCR_EVENPRT)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\nif ((ubrlcr & UBRLCR_WRDLEN_MASK) == UBRLCR_WRDLEN7)\r\n*bits = 7;\r\nelse\r\n*bits = 8;\r\nquot = ubrlcr & UBRLCR_BAUD_MASK;\r\n*baud = port->uartclk / (16 * (quot + 1));\r\n}\r\n}\r\nstatic int __init clps711xuart_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 38400;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nport = uart_get_console(clps711x_ports, UART_NR, co);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nclps711xuart_console_get_options(port, &baud, &parity, &bits);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init clps711xuart_console_init(void)\r\n{\r\nregister_console(&clps711x_console);\r\nreturn 0;\r\n}\r\nstatic int __init clps711xuart_init(void)\r\n{\r\nint ret, i;\r\nprintk(KERN_INFO "Serial: CLPS711x driver\n");\r\nret = uart_register_driver(&clps711x_reg);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < UART_NR; i++)\r\nuart_add_one_port(&clps711x_reg, &clps711x_ports[i]);\r\nreturn 0;\r\n}\r\nstatic void __exit clps711xuart_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++)\r\nuart_remove_one_port(&clps711x_reg, &clps711x_ports[i]);\r\nuart_unregister_driver(&clps711x_reg);\r\n}
