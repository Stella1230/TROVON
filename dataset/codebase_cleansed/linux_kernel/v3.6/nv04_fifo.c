bool\r\nnv04_fifo_cache_pull(struct drm_device *dev, bool enable)\r\n{\r\nint pull = nv_mask(dev, NV04_PFIFO_CACHE1_PULL0, 1, enable);\r\nif (!enable) {\r\nif (!nv_wait(dev, NV04_PFIFO_CACHE1_PULL0,\r\nNV04_PFIFO_CACHE1_PULL0_HASH_BUSY, 0))\r\nNV_ERROR(dev, "Timeout idling the PFIFO puller.\n");\r\nif (nv_rd32(dev, NV04_PFIFO_CACHE1_PULL0) &\r\nNV04_PFIFO_CACHE1_PULL0_HASH_FAILED)\r\nnv_wr32(dev, NV03_PFIFO_INTR_0,\r\nNV_PFIFO_INTR_CACHE_ERROR);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_HASH, 0);\r\n}\r\nreturn pull & 1;\r\n}\r\nstatic int\r\nnv04_fifo_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_fifo_priv *priv = nv_engine(dev, engine);\r\nstruct nv04_fifo_chan *fctx;\r\nunsigned long flags;\r\nint ret;\r\nfctx = chan->engctx[engine] = kzalloc(sizeof(*fctx), GFP_KERNEL);\r\nif (!fctx)\r\nreturn -ENOMEM;\r\nchan->user = ioremap(pci_resource_start(dev->pdev, 0) +\r\nNV03_USER(chan->id), PAGE_SIZE);\r\nif (!chan->user) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = nouveau_gpuobj_new_fake(dev, dev_priv->ramfc->pinst +\r\nchan->id * 32, ~0, 32,\r\nNVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);\r\nif (ret)\r\ngoto error;\r\nnv_wo32(fctx->ramfc, 0x00, chan->pushbuf_base);\r\nnv_wo32(fctx->ramfc, 0x04, chan->pushbuf_base);\r\nnv_wo32(fctx->ramfc, 0x08, chan->pushbuf->pinst >> 4);\r\nnv_wo32(fctx->ramfc, 0x0c, 0x00000000);\r\nnv_wo32(fctx->ramfc, 0x10, NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |\r\nNV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |\r\n#ifdef __BIG_ENDIAN\r\nNV_PFIFO_CACHE1_BIG_ENDIAN |\r\n#endif\r\nNV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);\r\nnv_wo32(fctx->ramfc, 0x14, 0x00000000);\r\nnv_wo32(fctx->ramfc, 0x18, 0x00000000);\r\nnv_wo32(fctx->ramfc, 0x1c, 0x00000000);\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_mask(dev, NV04_PFIFO_MODE, (1 << chan->id), (1 << chan->id));\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nerror:\r\nif (ret)\r\npriv->base.base.context_del(chan, engine);\r\nreturn ret;\r\n}\r\nvoid\r\nnv04_fifo_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_fifo_priv *priv = nv_engine(chan->dev, engine);\r\nstruct nv04_fifo_chan *fctx = chan->engctx[engine];\r\nstruct ramfc_desc *c = priv->ramfc_desc;\r\nunsigned long flags;\r\nint chid;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_wr32(dev, NV03_PFIFO_CACHES, 0);\r\nchid = nv_rd32(dev, NV03_PFIFO_CACHE1_PUSH1) & priv->base.channels;\r\nif (chid == chan->id) {\r\nnv_mask(dev, NV04_PFIFO_CACHE1_DMA_PUSH, 0x00000001, 0);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0, 0);\r\nnv_mask(dev, NV04_PFIFO_CACHE1_PULL0, 0x00000001, 0);\r\ndo {\r\nu32 mask = ((1ULL << c->bits) - 1) << c->regs;\r\nnv_mask(dev, c->regp, mask, 0x00000000);\r\n} while ((++c)->bits);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_GET, 0);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUT, 0);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH1, priv->base.channels);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0, 1);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, 1);\r\n}\r\nnv_mask(dev, NV04_PFIFO_MODE, 1 << chan->id, 0);\r\nnv_wr32(dev, NV03_PFIFO_CACHES, 1);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nnouveau_gpuobj_ref(NULL, &fctx->ramfc);\r\nnouveau_gpuobj_ref(NULL, &chan->ramfc);\r\nif (chan->user) {\r\niounmap(chan->user);\r\nchan->user = NULL;\r\n}\r\n}\r\nint\r\nnv04_fifo_init(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_fifo_priv *priv = nv_engine(dev, engine);\r\nint i;\r\nnv_mask(dev, NV03_PMC_ENABLE, NV_PMC_ENABLE_PFIFO, 0);\r\nnv_mask(dev, NV03_PMC_ENABLE, NV_PMC_ENABLE_PFIFO, NV_PMC_ENABLE_PFIFO);\r\nnv_wr32(dev, NV04_PFIFO_DELAY_0, 0x000000ff);\r\nnv_wr32(dev, NV04_PFIFO_DMA_TIMESLICE, 0x0101ffff);\r\nnv_wr32(dev, NV03_PFIFO_RAMHT, (0x03 << 24) |\r\n((dev_priv->ramht->bits - 9) << 16) |\r\n(dev_priv->ramht->gpuobj->pinst >> 8));\r\nnv_wr32(dev, NV03_PFIFO_RAMRO, dev_priv->ramro->pinst >> 8);\r\nnv_wr32(dev, NV03_PFIFO_RAMFC, dev_priv->ramfc->pinst >> 8);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH1, priv->base.channels);\r\nnv_wr32(dev, NV03_PFIFO_INTR_0, 0xffffffff);\r\nnv_wr32(dev, NV03_PFIFO_INTR_EN_0, 0xffffffff);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0, 1);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, 1);\r\nnv_wr32(dev, NV03_PFIFO_CACHES, 1);\r\nfor (i = 0; i < priv->base.channels; i++) {\r\nif (dev_priv->channels.ptr[i])\r\nnv_mask(dev, NV04_PFIFO_MODE, (1 << i), (1 << i));\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnv04_fifo_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_fifo_priv *priv = nv_engine(dev, engine);\r\nstruct nouveau_channel *chan;\r\nint chid;\r\nnv_wr32(dev, NV03_PFIFO_CACHES, 0);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_PUSH, 0);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0, 0);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, 0);\r\nchid = nv_rd32(dev, NV03_PFIFO_CACHE1_PUSH1) & priv->base.channels;\r\nchan = dev_priv->channels.ptr[chid];\r\nif (suspend && chid != priv->base.channels && chan) {\r\nstruct nv04_fifo_chan *fctx = chan->engctx[engine];\r\nstruct nouveau_gpuobj *ctx = fctx->ramfc;\r\nstruct ramfc_desc *c = priv->ramfc_desc;\r\ndo {\r\nu32 rm = ((1ULL << c->bits) - 1) << c->regs;\r\nu32 cm = ((1ULL << c->bits) - 1) << c->ctxs;\r\nu32 rv = (nv_rd32(dev, c->regp) & rm) >> c->regs;\r\nu32 cv = (nv_ro32(ctx, c->ctxp) & ~cm);\r\nnv_wo32(ctx, c->ctxp, cv | (rv << c->ctxs));\r\n} while ((++c)->bits);\r\n}\r\nnv_wr32(dev, NV03_PFIFO_INTR_EN_0, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic bool\r\nnouveau_fifo_swmthd(struct drm_device *dev, u32 chid, u32 addr, u32 data)\r\n{\r\nstruct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_channel *chan = NULL;\r\nstruct nouveau_gpuobj *obj;\r\nunsigned long flags;\r\nconst int subc = (addr >> 13) & 0x7;\r\nconst int mthd = addr & 0x1ffc;\r\nbool handled = false;\r\nu32 engine;\r\nspin_lock_irqsave(&dev_priv->channels.lock, flags);\r\nif (likely(chid >= 0 && chid < pfifo->channels))\r\nchan = dev_priv->channels.ptr[chid];\r\nif (unlikely(!chan))\r\ngoto out;\r\nswitch (mthd) {\r\ncase 0x0000:\r\nobj = nouveau_ramht_find(chan, data);\r\nif (unlikely(!obj || obj->engine != NVOBJ_ENGINE_SW))\r\nbreak;\r\nengine = 0x0000000f << (subc * 4);\r\nnv_mask(dev, NV04_PFIFO_CACHE1_ENGINE, engine, 0x00000000);\r\nhandled = true;\r\nbreak;\r\ndefault:\r\nengine = nv_rd32(dev, NV04_PFIFO_CACHE1_ENGINE);\r\nif (unlikely(((engine >> (subc * 4)) & 0xf) != 0))\r\nbreak;\r\nif (!nouveau_gpuobj_mthd_call(chan, nouveau_software_class(dev),\r\nmthd, data))\r\nhandled = true;\r\nbreak;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&dev_priv->channels.lock, flags);\r\nreturn handled;\r\n}\r\nstatic const char *nv_dma_state_err(u32 state)\r\n{\r\nstatic const char * const desc[] = {\r\n"NONE", "CALL_SUBR_ACTIVE", "INVALID_MTHD", "RET_SUBR_INACTIVE",\r\n"INVALID_CMD", "IB_EMPTY", "MEM_FAULT", "UNK"\r\n};\r\nreturn desc[(state >> 29) & 0x7];\r\n}\r\nvoid\r\nnv04_fifo_isr(struct drm_device *dev)\r\n{\r\nstruct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nuint32_t status, reassign;\r\nint cnt = 0;\r\nreassign = nv_rd32(dev, NV03_PFIFO_CACHES) & 1;\r\nwhile ((status = nv_rd32(dev, NV03_PFIFO_INTR_0)) && (cnt++ < 100)) {\r\nuint32_t chid, get;\r\nnv_wr32(dev, NV03_PFIFO_CACHES, 0);\r\nchid = nv_rd32(dev, NV03_PFIFO_CACHE1_PUSH1) & pfifo->channels;\r\nget = nv_rd32(dev, NV03_PFIFO_CACHE1_GET);\r\nif (status & NV_PFIFO_INTR_CACHE_ERROR) {\r\nuint32_t mthd, data;\r\nint ptr;\r\nptr = (get & 0x7ff) >> 2;\r\nif (dev_priv->card_type < NV_40) {\r\nmthd = nv_rd32(dev,\r\nNV04_PFIFO_CACHE1_METHOD(ptr));\r\ndata = nv_rd32(dev,\r\nNV04_PFIFO_CACHE1_DATA(ptr));\r\n} else {\r\nmthd = nv_rd32(dev,\r\nNV40_PFIFO_CACHE1_METHOD(ptr));\r\ndata = nv_rd32(dev,\r\nNV40_PFIFO_CACHE1_DATA(ptr));\r\n}\r\nif (!nouveau_fifo_swmthd(dev, chid, mthd, data)) {\r\nNV_INFO(dev, "PFIFO_CACHE_ERROR - Ch %d/%d "\r\n"Mthd 0x%04x Data 0x%08x\n",\r\nchid, (mthd >> 13) & 7, mthd & 0x1ffc,\r\ndata);\r\n}\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_PUSH, 0);\r\nnv_wr32(dev, NV03_PFIFO_INTR_0,\r\nNV_PFIFO_INTR_CACHE_ERROR);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0,\r\nnv_rd32(dev, NV03_PFIFO_CACHE1_PUSH0) & ~1);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_GET, get + 4);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_PUSH0,\r\nnv_rd32(dev, NV03_PFIFO_CACHE1_PUSH0) | 1);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_HASH, 0);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_DMA_PUSH,\r\nnv_rd32(dev, NV04_PFIFO_CACHE1_DMA_PUSH) | 1);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, 1);\r\nstatus &= ~NV_PFIFO_INTR_CACHE_ERROR;\r\n}\r\nif (status & NV_PFIFO_INTR_DMA_PUSHER) {\r\nu32 dma_get = nv_rd32(dev, 0x003244);\r\nu32 dma_put = nv_rd32(dev, 0x003240);\r\nu32 push = nv_rd32(dev, 0x003220);\r\nu32 state = nv_rd32(dev, 0x003228);\r\nif (dev_priv->card_type == NV_50) {\r\nu32 ho_get = nv_rd32(dev, 0x003328);\r\nu32 ho_put = nv_rd32(dev, 0x003320);\r\nu32 ib_get = nv_rd32(dev, 0x003334);\r\nu32 ib_put = nv_rd32(dev, 0x003330);\r\nif (nouveau_ratelimit())\r\nNV_INFO(dev, "PFIFO_DMA_PUSHER - Ch %d Get 0x%02x%08x "\r\n"Put 0x%02x%08x IbGet 0x%08x IbPut 0x%08x "\r\n"State 0x%08x (err: %s) Push 0x%08x\n",\r\nchid, ho_get, dma_get, ho_put,\r\ndma_put, ib_get, ib_put, state,\r\nnv_dma_state_err(state),\r\npush);\r\nnv_wr32(dev, 0x003364, 0x00000000);\r\nif (dma_get != dma_put || ho_get != ho_put) {\r\nnv_wr32(dev, 0x003244, dma_put);\r\nnv_wr32(dev, 0x003328, ho_put);\r\n} else\r\nif (ib_get != ib_put) {\r\nnv_wr32(dev, 0x003334, ib_put);\r\n}\r\n} else {\r\nNV_INFO(dev, "PFIFO_DMA_PUSHER - Ch %d Get 0x%08x "\r\n"Put 0x%08x State 0x%08x (err: %s) Push 0x%08x\n",\r\nchid, dma_get, dma_put, state,\r\nnv_dma_state_err(state), push);\r\nif (dma_get != dma_put)\r\nnv_wr32(dev, 0x003244, dma_put);\r\n}\r\nnv_wr32(dev, 0x003228, 0x00000000);\r\nnv_wr32(dev, 0x003220, 0x00000001);\r\nnv_wr32(dev, 0x002100, NV_PFIFO_INTR_DMA_PUSHER);\r\nstatus &= ~NV_PFIFO_INTR_DMA_PUSHER;\r\n}\r\nif (status & NV_PFIFO_INTR_SEMAPHORE) {\r\nuint32_t sem;\r\nstatus &= ~NV_PFIFO_INTR_SEMAPHORE;\r\nnv_wr32(dev, NV03_PFIFO_INTR_0,\r\nNV_PFIFO_INTR_SEMAPHORE);\r\nsem = nv_rd32(dev, NV10_PFIFO_CACHE1_SEMAPHORE);\r\nnv_wr32(dev, NV10_PFIFO_CACHE1_SEMAPHORE, sem | 0x1);\r\nnv_wr32(dev, NV03_PFIFO_CACHE1_GET, get + 4);\r\nnv_wr32(dev, NV04_PFIFO_CACHE1_PULL0, 1);\r\n}\r\nif (dev_priv->card_type == NV_50) {\r\nif (status & 0x00000010) {\r\nnv50_fb_vm_trap(dev, nouveau_ratelimit());\r\nstatus &= ~0x00000010;\r\nnv_wr32(dev, 0x002100, 0x00000010);\r\n}\r\n}\r\nif (status) {\r\nif (nouveau_ratelimit())\r\nNV_INFO(dev, "PFIFO_INTR 0x%08x - Ch %d\n",\r\nstatus, chid);\r\nnv_wr32(dev, NV03_PFIFO_INTR_0, status);\r\nstatus = 0;\r\n}\r\nnv_wr32(dev, NV03_PFIFO_CACHES, reassign);\r\n}\r\nif (status) {\r\nNV_INFO(dev, "PFIFO still angry after %d spins, halt\n", cnt);\r\nnv_wr32(dev, 0x2140, 0);\r\nnv_wr32(dev, 0x140, 0);\r\n}\r\nnv_wr32(dev, NV03_PMC_INTR_0, NV_PMC_INTR_0_PFIFO_PENDING);\r\n}\r\nvoid\r\nnv04_fifo_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_fifo_priv *priv = nv_engine(dev, engine);\r\nnouveau_irq_unregister(dev, 8);\r\ndev_priv->eng[engine] = NULL;\r\nkfree(priv);\r\n}\r\nint\r\nnv04_fifo_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv04_fifo_priv *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.base.destroy = nv04_fifo_destroy;\r\npriv->base.base.init = nv04_fifo_init;\r\npriv->base.base.fini = nv04_fifo_fini;\r\npriv->base.base.context_new = nv04_fifo_context_new;\r\npriv->base.base.context_del = nv04_fifo_context_del;\r\npriv->base.channels = 15;\r\npriv->ramfc_desc = nv04_ramfc;\r\ndev_priv->eng[NVOBJ_ENGINE_FIFO] = &priv->base.base;\r\nnouveau_irq_register(dev, 8, nv04_fifo_isr);\r\nreturn 0;\r\n}
