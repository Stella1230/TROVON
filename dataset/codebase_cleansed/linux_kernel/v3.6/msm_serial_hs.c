static unsigned int use_low_power_rx_wakeup(struct msm_hs_port\r\n*msm_uport)\r\n{\r\nreturn (msm_uport->rx_wakeup.irq >= 0);\r\n}\r\nstatic unsigned int msm_hs_read(struct uart_port *uport,\r\nunsigned int offset)\r\n{\r\nreturn ioread32(uport->membase + offset);\r\n}\r\nstatic void msm_hs_write(struct uart_port *uport, unsigned int offset,\r\nunsigned int value)\r\n{\r\niowrite32(value, uport->membase + offset);\r\n}\r\nstatic void msm_hs_release_port(struct uart_port *port)\r\n{\r\niounmap(port->membase);\r\n}\r\nstatic int msm_hs_request_port(struct uart_port *port)\r\n{\r\nport->membase = ioremap(port->mapbase, PAGE_SIZE);\r\nif (unlikely(!port->membase))\r\nreturn -ENOMEM;\r\nmsm_hs_write(port, UARTDM_CR_ADDR, CR_PROTECTION_EN);\r\nreturn 0;\r\n}\r\nstatic int __devexit msm_hs_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_hs_port *msm_uport;\r\nstruct device *dev;\r\nif (pdev->id < 0 || pdev->id >= UARTDM_NR) {\r\nprintk(KERN_ERR "Invalid plaform device ID = %d\n", pdev->id);\r\nreturn -EINVAL;\r\n}\r\nmsm_uport = &q_uart_port[pdev->id];\r\ndev = msm_uport->uport.dev;\r\ndma_unmap_single(dev, msm_uport->rx.mapped_cmd_ptr, sizeof(dmov_box),\r\nDMA_TO_DEVICE);\r\ndma_pool_free(msm_uport->rx.pool, msm_uport->rx.buffer,\r\nmsm_uport->rx.rbuffer);\r\ndma_pool_destroy(msm_uport->rx.pool);\r\ndma_unmap_single(dev, msm_uport->rx.cmdptr_dmaaddr, sizeof(u32),\r\nDMA_TO_DEVICE);\r\ndma_unmap_single(dev, msm_uport->tx.mapped_cmd_ptr_ptr, sizeof(u32),\r\nDMA_TO_DEVICE);\r\ndma_unmap_single(dev, msm_uport->tx.mapped_cmd_ptr, sizeof(dmov_box),\r\nDMA_TO_DEVICE);\r\nuart_remove_one_port(&msm_hs_driver, &msm_uport->uport);\r\nclk_put(msm_uport->clk);\r\nkfree(msm_uport->tx.command_ptr);\r\nkfree(msm_uport->tx.command_ptr_ptr);\r\nkfree(msm_uport->rx.command_ptr);\r\nkfree(msm_uport->rx.command_ptr_ptr);\r\niounmap(msm_uport->uport.membase);\r\nreturn 0;\r\n}\r\nstatic int msm_hs_init_clk_locked(struct uart_port *uport)\r\n{\r\nint ret;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nret = clk_enable(msm_uport->clk);\r\nif (ret) {\r\nprintk(KERN_ERR "Error could not turn on UART clk\n");\r\nreturn ret;\r\n}\r\nret = clk_set_rate(msm_uport->clk, uport->uartclk);\r\nif (ret) {\r\nprintk(KERN_WARNING "Error setting clock rate on UART\n");\r\nclk_disable(msm_uport->clk);\r\nreturn ret;\r\n}\r\nmsm_uport->clk_state = MSM_HS_CLK_ON;\r\nreturn 0;\r\n}\r\nstatic void msm_hs_pm(struct uart_port *uport, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nif (use_low_power_rx_wakeup(msm_uport) ||\r\nmsm_uport->exit_lpm_cb)\r\nreturn;\r\nswitch (state) {\r\ncase 0:\r\nclk_enable(msm_uport->clk);\r\nbreak;\r\ncase 3:\r\nclk_disable(msm_uport->clk);\r\nbreak;\r\ndefault:\r\ndev_err(uport->dev, "msm_serial: Unknown PM state %d\n",\r\nstate);\r\n}\r\n}\r\nstatic void msm_hs_set_bps_locked(struct uart_port *uport,\r\nunsigned int bps)\r\n{\r\nunsigned long rxstale;\r\nunsigned long data;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nswitch (bps) {\r\ncase 300:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_75);\r\nrxstale = 1;\r\nbreak;\r\ncase 600:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_150);\r\nrxstale = 1;\r\nbreak;\r\ncase 1200:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_300);\r\nrxstale = 1;\r\nbreak;\r\ncase 2400:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_600);\r\nrxstale = 1;\r\nbreak;\r\ncase 4800:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_1200);\r\nrxstale = 1;\r\nbreak;\r\ncase 9600:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_2400);\r\nrxstale = 2;\r\nbreak;\r\ncase 14400:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_3600);\r\nrxstale = 3;\r\nbreak;\r\ncase 19200:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_4800);\r\nrxstale = 4;\r\nbreak;\r\ncase 28800:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_7200);\r\nrxstale = 6;\r\nbreak;\r\ncase 38400:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_9600);\r\nrxstale = 8;\r\nbreak;\r\ncase 57600:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_14400);\r\nrxstale = 16;\r\nbreak;\r\ncase 76800:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_19200);\r\nrxstale = 16;\r\nbreak;\r\ncase 115200:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_28800);\r\nrxstale = 31;\r\nbreak;\r\ncase 230400:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_57600);\r\nrxstale = 31;\r\nbreak;\r\ncase 460800:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_115200);\r\nrxstale = 31;\r\nbreak;\r\ncase 4000000:\r\ncase 3686400:\r\ncase 3200000:\r\ncase 3500000:\r\ncase 3000000:\r\ncase 2500000:\r\ncase 1500000:\r\ncase 1152000:\r\ncase 1000000:\r\ncase 921600:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_115200);\r\nrxstale = 31;\r\nbreak;\r\ndefault:\r\nmsm_hs_write(uport, UARTDM_CSR_ADDR, UARTDM_CSR_2400);\r\nbps = 9600;\r\nrxstale = 2;\r\nbreak;\r\n}\r\nif (bps > 460800)\r\nuport->uartclk = bps * 16;\r\nelse\r\nuport->uartclk = UARTCLK;\r\nif (clk_set_rate(msm_uport->clk, uport->uartclk)) {\r\nprintk(KERN_WARNING "Error setting clock rate on UART\n");\r\nreturn;\r\n}\r\ndata = rxstale & UARTDM_IPR_STALE_LSB_BMSK;\r\ndata |= UARTDM_IPR_STALE_TIMEOUT_MSB_BMSK & (rxstale << 2);\r\nmsm_hs_write(uport, UARTDM_IPR_ADDR, data);\r\n}\r\nstatic void msm_hs_set_termios(struct uart_port *uport,\r\nstruct ktermios *termios,\r\nstruct ktermios *oldtermios)\r\n{\r\nunsigned int bps;\r\nunsigned long data;\r\nunsigned long flags;\r\nunsigned int c_cflag = termios->c_cflag;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nspin_lock_irqsave(&uport->lock, flags);\r\nclk_enable(msm_uport->clk);\r\nbps = uart_get_baud_rate(uport, termios, oldtermios, 200, 4000000);\r\nif (bps == 200)\r\nbps = 3200000;\r\nmsm_hs_set_bps_locked(uport, bps);\r\ndata = msm_hs_read(uport, UARTDM_MR2_ADDR);\r\ndata &= ~UARTDM_MR2_PARITY_MODE_BMSK;\r\nif (PARENB == (c_cflag & PARENB)) {\r\nif (PARODD == (c_cflag & PARODD))\r\ndata |= ODD_PARITY;\r\nelse if (CMSPAR == (c_cflag & CMSPAR))\r\ndata |= SPACE_PARITY;\r\nelse\r\ndata |= EVEN_PARITY;\r\n}\r\ndata &= ~UARTDM_MR2_BITS_PER_CHAR_BMSK;\r\nswitch (c_cflag & CSIZE) {\r\ncase CS5:\r\ndata |= FIVE_BPC;\r\nbreak;\r\ncase CS6:\r\ndata |= SIX_BPC;\r\nbreak;\r\ncase CS7:\r\ndata |= SEVEN_BPC;\r\nbreak;\r\ndefault:\r\ndata |= EIGHT_BPC;\r\nbreak;\r\n}\r\nif (c_cflag & CSTOPB) {\r\ndata |= STOP_BIT_TWO;\r\n} else {\r\ndata |= STOP_BIT_ONE;\r\n}\r\ndata |= UARTDM_MR2_ERROR_MODE_BMSK;\r\nmsm_hs_write(uport, UARTDM_MR2_ADDR, data);\r\ndata = msm_hs_read(uport, UARTDM_MR1_ADDR);\r\ndata &= ~(UARTDM_MR1_CTS_CTL_BMSK | UARTDM_MR1_RX_RDY_CTL_BMSK);\r\nif (c_cflag & CRTSCTS) {\r\ndata |= UARTDM_MR1_CTS_CTL_BMSK;\r\ndata |= UARTDM_MR1_RX_RDY_CTL_BMSK;\r\n}\r\nmsm_hs_write(uport, UARTDM_MR1_ADDR, data);\r\nuport->ignore_status_mask = termios->c_iflag & INPCK;\r\nuport->ignore_status_mask |= termios->c_iflag & IGNPAR;\r\nuport->read_status_mask = (termios->c_cflag & CREAD);\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, 0);\r\nuart_update_timeout(uport, c_cflag, bps);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_RX);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_TX);\r\nif (msm_uport->rx.flush == FLUSH_NONE) {\r\nmsm_uport->rx.flush = FLUSH_IGNORE;\r\nmsm_dmov_stop_cmd(msm_uport->dma_rx_channel, NULL, 1);\r\n}\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\nclk_disable(msm_uport->clk);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\n}\r\nstatic unsigned int msm_hs_tx_empty(struct uart_port *uport)\r\n{\r\nunsigned int data;\r\nunsigned int ret = 0;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nclk_enable(msm_uport->clk);\r\ndata = msm_hs_read(uport, UARTDM_SR_ADDR);\r\nif (data & UARTDM_SR_TXEMT_BMSK)\r\nret = TIOCSER_TEMT;\r\nclk_disable(msm_uport->clk);\r\nreturn ret;\r\n}\r\nstatic void msm_hs_stop_tx_locked(struct uart_port *uport)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nmsm_uport->tx.tx_ready_int_en = 0;\r\n}\r\nstatic void msm_hs_stop_rx_locked(struct uart_port *uport)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nunsigned int data;\r\nclk_enable(msm_uport->clk);\r\ndata = msm_hs_read(uport, UARTDM_DMEN_ADDR);\r\ndata &= ~UARTDM_RX_DM_EN_BMSK;\r\nmsm_hs_write(uport, UARTDM_DMEN_ADDR, data);\r\nif (msm_uport->rx.flush == FLUSH_NONE)\r\nmsm_dmov_stop_cmd(msm_uport->dma_rx_channel, NULL, 1);\r\nif (msm_uport->rx.flush != FLUSH_SHUTDOWN)\r\nmsm_uport->rx.flush = FLUSH_STOP;\r\nclk_disable(msm_uport->clk);\r\n}\r\nstatic void msm_hs_submit_tx_locked(struct uart_port *uport)\r\n{\r\nint left;\r\nint tx_count;\r\ndma_addr_t src_addr;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nstruct msm_hs_tx *tx = &msm_uport->tx;\r\nstruct circ_buf *tx_buf = &msm_uport->uport.state->xmit;\r\nif (uart_circ_empty(tx_buf) || uport->state->port.tty->stopped) {\r\nmsm_hs_stop_tx_locked(uport);\r\nreturn;\r\n}\r\ntx->dma_in_flight = 1;\r\ntx_count = uart_circ_chars_pending(tx_buf);\r\nif (UARTDM_TX_BUF_SIZE < tx_count)\r\ntx_count = UARTDM_TX_BUF_SIZE;\r\nleft = UART_XMIT_SIZE - tx_buf->tail;\r\nif (tx_count > left)\r\ntx_count = left;\r\nsrc_addr = tx->dma_base + tx_buf->tail;\r\ndma_sync_single_for_device(uport->dev, src_addr, tx_count,\r\nDMA_TO_DEVICE);\r\ntx->command_ptr->num_rows = (((tx_count + 15) >> 4) << 16) |\r\n((tx_count + 15) >> 4);\r\ntx->command_ptr->src_row_addr = src_addr;\r\ndma_sync_single_for_device(uport->dev, tx->mapped_cmd_ptr,\r\nsizeof(dmov_box), DMA_TO_DEVICE);\r\n*tx->command_ptr_ptr = CMD_PTR_LP | DMOV_CMD_ADDR(tx->mapped_cmd_ptr);\r\ndma_sync_single_for_device(uport->dev, tx->mapped_cmd_ptr_ptr,\r\nsizeof(u32), DMA_TO_DEVICE);\r\ntx->tx_count = tx_count;\r\nmsm_hs_write(uport, UARTDM_NCF_TX_ADDR, tx_count);\r\nmsm_uport->imr_reg &= ~UARTDM_ISR_TX_READY_BMSK;\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\nmsm_dmov_enqueue_cmd(msm_uport->dma_tx_channel, &tx->xfer);\r\n}\r\nstatic void msm_hs_start_rx_locked(struct uart_port *uport)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_STALE_INT);\r\nmsm_hs_write(uport, UARTDM_DMRX_ADDR, UARTDM_RX_BUF_SIZE);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, STALE_EVENT_ENABLE);\r\nmsm_uport->imr_reg |= UARTDM_ISR_RXLEV_BMSK;\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\nmsm_uport->rx.flush = FLUSH_NONE;\r\nmsm_dmov_enqueue_cmd(msm_uport->dma_rx_channel, &msm_uport->rx.xfer);\r\nhrtimer_start(&msm_uport->clk_off_timer, msm_uport->clk_off_delay,\r\nHRTIMER_MODE_REL);\r\n}\r\nstatic void msm_hs_start_tx_locked(struct uart_port *uport)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nclk_enable(msm_uport->clk);\r\nif (msm_uport->exit_lpm_cb)\r\nmsm_uport->exit_lpm_cb(uport);\r\nif (msm_uport->tx.tx_ready_int_en == 0) {\r\nmsm_uport->tx.tx_ready_int_en = 1;\r\nmsm_hs_submit_tx_locked(uport);\r\n}\r\nclk_disable(msm_uport->clk);\r\n}\r\nstatic void msm_hs_dmov_tx_callback(struct msm_dmov_cmd *cmd_ptr,\r\nunsigned int result,\r\nstruct msm_dmov_errdata *err)\r\n{\r\nunsigned long flags;\r\nstruct msm_hs_port *msm_uport;\r\nWARN_ON((((result & RSLT_FIFO_CNTR_BMSK) >> 28) == 1) &&\r\n!(result & RSLT_VLD));\r\nmsm_uport = container_of(cmd_ptr, struct msm_hs_port, tx.xfer);\r\nspin_lock_irqsave(&msm_uport->uport.lock, flags);\r\nclk_enable(msm_uport->clk);\r\nmsm_uport->imr_reg |= UARTDM_ISR_TX_READY_BMSK;\r\nmsm_hs_write(&msm_uport->uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\nclk_disable(msm_uport->clk);\r\nspin_unlock_irqrestore(&msm_uport->uport.lock, flags);\r\n}\r\nstatic void msm_hs_dmov_rx_callback(struct msm_dmov_cmd *cmd_ptr,\r\nunsigned int result,\r\nstruct msm_dmov_errdata *err)\r\n{\r\nint retval;\r\nint rx_count;\r\nunsigned long status;\r\nunsigned int error_f = 0;\r\nunsigned long flags;\r\nunsigned int flush;\r\nstruct tty_struct *tty;\r\nstruct uart_port *uport;\r\nstruct msm_hs_port *msm_uport;\r\nmsm_uport = container_of(cmd_ptr, struct msm_hs_port, rx.xfer);\r\nuport = &msm_uport->uport;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nclk_enable(msm_uport->clk);\r\ntty = uport->state->port.tty;\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, STALE_EVENT_DISABLE);\r\nstatus = msm_hs_read(uport, UARTDM_SR_ADDR);\r\nif (unlikely((status & UARTDM_SR_OVERRUN_BMSK) &&\r\n(uport->read_status_mask & CREAD))) {\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\nuport->icount.buf_overrun++;\r\nerror_f = 1;\r\n}\r\nif (!(uport->ignore_status_mask & INPCK))\r\nstatus = status & ~(UARTDM_SR_PAR_FRAME_BMSK);\r\nif (unlikely(status & UARTDM_SR_PAR_FRAME_BMSK)) {\r\nuport->icount.parity++;\r\nerror_f = 1;\r\nif (uport->ignore_status_mask & IGNPAR)\r\ntty_insert_flip_char(tty, 0, TTY_PARITY);\r\n}\r\nif (error_f)\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_ERROR_STATUS);\r\nif (msm_uport->clk_req_off_state == CLK_REQ_OFF_FLUSH_ISSUED)\r\nmsm_uport->clk_req_off_state = CLK_REQ_OFF_RXSTALE_FLUSHED;\r\nflush = msm_uport->rx.flush;\r\nif (flush == FLUSH_IGNORE)\r\nmsm_hs_start_rx_locked(uport);\r\nif (flush == FLUSH_STOP)\r\nmsm_uport->rx.flush = FLUSH_SHUTDOWN;\r\nif (flush >= FLUSH_DATA_INVALID)\r\ngoto out;\r\nrx_count = msm_hs_read(uport, UARTDM_RX_TOTAL_SNAP_ADDR);\r\nif (0 != (uport->read_status_mask & CREAD)) {\r\nretval = tty_insert_flip_string(tty, msm_uport->rx.buffer,\r\nrx_count);\r\nBUG_ON(retval != rx_count);\r\n}\r\nmsm_hs_start_rx_locked(uport);\r\nout:\r\nclk_disable(msm_uport->clk);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\nif (flush < FLUSH_DATA_INVALID)\r\nqueue_work(msm_hs_workqueue, &msm_uport->rx.tty_work);\r\n}\r\nstatic void msm_hs_tty_flip_buffer_work(struct work_struct *work)\r\n{\r\nstruct msm_hs_port *msm_uport =\r\ncontainer_of(work, struct msm_hs_port, rx.tty_work);\r\nstruct tty_struct *tty = msm_uport->uport.state->port.tty;\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic unsigned int msm_hs_get_mctrl_locked(struct uart_port *uport)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR | TIOCM_CTS;\r\n}\r\nstatic void set_rfr_locked(struct uart_port *uport, int auto_rfr)\r\n{\r\nunsigned int data;\r\ndata = msm_hs_read(uport, UARTDM_MR1_ADDR);\r\nif (auto_rfr) {\r\ndata |= UARTDM_MR1_RX_RDY_CTL_BMSK;\r\nmsm_hs_write(uport, UARTDM_MR1_ADDR, data);\r\n} else {\r\ndata &= ~UARTDM_MR1_RX_RDY_CTL_BMSK;\r\nmsm_hs_write(uport, UARTDM_MR1_ADDR, data);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RFR_HIGH);\r\n}\r\n}\r\nstatic void msm_hs_set_mctrl_locked(struct uart_port *uport,\r\nunsigned int mctrl)\r\n{\r\nunsigned int auto_rfr;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nclk_enable(msm_uport->clk);\r\nauto_rfr = TIOCM_RTS & mctrl ? 1 : 0;\r\nset_rfr_locked(uport, auto_rfr);\r\nclk_disable(msm_uport->clk);\r\n}\r\nstatic void msm_hs_enable_ms_locked(struct uart_port *uport)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nclk_enable(msm_uport->clk);\r\nmsm_uport->imr_reg |= UARTDM_ISR_DELTA_CTS_BMSK;\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\nclk_disable(msm_uport->clk);\r\n}\r\nstatic void msm_hs_break_ctl(struct uart_port *uport, int ctl)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nclk_enable(msm_uport->clk);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, ctl ? START_BREAK : STOP_BREAK);\r\nclk_disable(msm_uport->clk);\r\n}\r\nstatic void msm_hs_config_port(struct uart_port *uport, int cfg_flags)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nif (cfg_flags & UART_CONFIG_TYPE) {\r\nuport->type = PORT_MSM;\r\nmsm_hs_request_port(uport);\r\n}\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\n}\r\nstatic void msm_hs_handle_delta_cts_locked(struct uart_port *uport)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nclk_enable(msm_uport->clk);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_CTS);\r\nuport->icount.cts++;\r\nclk_disable(msm_uport->clk);\r\nwake_up_interruptible(&uport->state->port.delta_msr_wait);\r\n}\r\nstatic int msm_hs_check_clock_off_locked(struct uart_port *uport)\r\n{\r\nunsigned long sr_status;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nstruct circ_buf *tx_buf = &uport->state->xmit;\r\nif (msm_uport->clk_state != MSM_HS_CLK_REQUEST_OFF ||\r\n!uart_circ_empty(tx_buf) || msm_uport->tx.dma_in_flight ||\r\n(msm_uport->imr_reg & UARTDM_ISR_TXLEV_BMSK) ||\r\n!(msm_uport->imr_reg & UARTDM_ISR_RXLEV_BMSK)) {\r\nreturn -1;\r\n}\r\nsr_status = msm_hs_read(uport, UARTDM_SR_ADDR);\r\nif (!(sr_status & UARTDM_SR_TXEMT_BMSK))\r\nreturn 0;\r\nswitch (msm_uport->clk_req_off_state) {\r\ncase CLK_REQ_OFF_START:\r\nmsm_uport->clk_req_off_state = CLK_REQ_OFF_RXSTALE_ISSUED;\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, FORCE_STALE_EVENT);\r\nreturn 0;\r\ncase CLK_REQ_OFF_RXSTALE_ISSUED:\r\ncase CLK_REQ_OFF_FLUSH_ISSUED:\r\nreturn 0;\r\ncase CLK_REQ_OFF_RXSTALE_FLUSHED:\r\nbreak;\r\n}\r\nif (msm_uport->rx.flush != FLUSH_SHUTDOWN) {\r\nif (msm_uport->rx.flush == FLUSH_NONE)\r\nmsm_hs_stop_rx_locked(uport);\r\nreturn 0;\r\n}\r\nclk_disable(msm_uport->clk);\r\nmsm_uport->clk_state = MSM_HS_CLK_OFF;\r\nif (use_low_power_rx_wakeup(msm_uport)) {\r\nmsm_uport->rx_wakeup.ignore = 1;\r\nenable_irq(msm_uport->rx_wakeup.irq);\r\n}\r\nreturn 1;\r\n}\r\nstatic enum hrtimer_restart msm_hs_clk_off_retry(struct hrtimer *timer)\r\n{\r\nunsigned long flags;\r\nint ret = HRTIMER_NORESTART;\r\nstruct msm_hs_port *msm_uport = container_of(timer, struct msm_hs_port,\r\nclk_off_timer);\r\nstruct uart_port *uport = &msm_uport->uport;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nif (!msm_hs_check_clock_off_locked(uport)) {\r\nhrtimer_forward_now(timer, msm_uport->clk_off_delay);\r\nret = HRTIMER_RESTART;\r\n}\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t msm_hs_isr(int irq, void *dev)\r\n{\r\nunsigned long flags;\r\nunsigned long isr_status;\r\nstruct msm_hs_port *msm_uport = dev;\r\nstruct uart_port *uport = &msm_uport->uport;\r\nstruct circ_buf *tx_buf = &uport->state->xmit;\r\nstruct msm_hs_tx *tx = &msm_uport->tx;\r\nstruct msm_hs_rx *rx = &msm_uport->rx;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nisr_status = msm_hs_read(uport, UARTDM_MISR_ADDR);\r\nif (isr_status & UARTDM_ISR_RXLEV_BMSK) {\r\nmsm_uport->imr_reg &= ~UARTDM_ISR_RXLEV_BMSK;\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\n}\r\nif (isr_status & UARTDM_ISR_RXSTALE_BMSK) {\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, STALE_EVENT_DISABLE);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_STALE_INT);\r\nif (msm_uport->clk_req_off_state == CLK_REQ_OFF_RXSTALE_ISSUED)\r\nmsm_uport->clk_req_off_state =\r\nCLK_REQ_OFF_FLUSH_ISSUED;\r\nif (rx->flush == FLUSH_NONE) {\r\nrx->flush = FLUSH_DATA_READY;\r\nmsm_dmov_stop_cmd(msm_uport->dma_rx_channel, NULL, 1);\r\n}\r\n}\r\nif (isr_status & UARTDM_ISR_TX_READY_BMSK) {\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, CLEAR_TX_READY);\r\nif (msm_uport->clk_state == MSM_HS_CLK_REQUEST_OFF) {\r\nmsm_uport->imr_reg |= UARTDM_ISR_TXLEV_BMSK;\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR,\r\nmsm_uport->imr_reg);\r\n}\r\ntx_buf->tail = (tx_buf->tail + tx->tx_count) & ~UART_XMIT_SIZE;\r\ntx->dma_in_flight = 0;\r\nuport->icount.tx += tx->tx_count;\r\nif (tx->tx_ready_int_en)\r\nmsm_hs_submit_tx_locked(uport);\r\nif (uart_circ_chars_pending(tx_buf) < WAKEUP_CHARS)\r\nuart_write_wakeup(uport);\r\n}\r\nif (isr_status & UARTDM_ISR_TXLEV_BMSK) {\r\nmsm_uport->imr_reg &= ~UARTDM_ISR_TXLEV_BMSK;\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\nif (!msm_hs_check_clock_off_locked(uport))\r\nhrtimer_start(&msm_uport->clk_off_timer,\r\nmsm_uport->clk_off_delay,\r\nHRTIMER_MODE_REL);\r\n}\r\nif (isr_status & UARTDM_ISR_DELTA_CTS_BMSK)\r\nmsm_hs_handle_delta_cts_locked(uport);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid msm_hs_request_clock_off_locked(struct uart_port *uport)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nif (msm_uport->clk_state == MSM_HS_CLK_ON) {\r\nmsm_uport->clk_state = MSM_HS_CLK_REQUEST_OFF;\r\nmsm_uport->clk_req_off_state = CLK_REQ_OFF_START;\r\nif (!use_low_power_rx_wakeup(msm_uport))\r\nset_rfr_locked(uport, 0);\r\nmsm_uport->imr_reg |= UARTDM_ISR_TXLEV_BMSK;\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\n}\r\n}\r\nvoid msm_hs_request_clock_off(struct uart_port *uport)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nmsm_hs_request_clock_off_locked(uport);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\n}\r\nvoid msm_hs_request_clock_on_locked(struct uart_port *uport)\r\n{\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nunsigned int data;\r\nswitch (msm_uport->clk_state) {\r\ncase MSM_HS_CLK_OFF:\r\nclk_enable(msm_uport->clk);\r\ndisable_irq_nosync(msm_uport->rx_wakeup.irq);\r\ncase MSM_HS_CLK_REQUEST_OFF:\r\nif (msm_uport->rx.flush == FLUSH_STOP ||\r\nmsm_uport->rx.flush == FLUSH_SHUTDOWN) {\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_RX);\r\ndata = msm_hs_read(uport, UARTDM_DMEN_ADDR);\r\ndata |= UARTDM_RX_DM_EN_BMSK;\r\nmsm_hs_write(uport, UARTDM_DMEN_ADDR, data);\r\n}\r\nhrtimer_try_to_cancel(&msm_uport->clk_off_timer);\r\nif (msm_uport->rx.flush == FLUSH_SHUTDOWN)\r\nmsm_hs_start_rx_locked(uport);\r\nif (!use_low_power_rx_wakeup(msm_uport))\r\nset_rfr_locked(uport, 1);\r\nif (msm_uport->rx.flush == FLUSH_STOP)\r\nmsm_uport->rx.flush = FLUSH_IGNORE;\r\nmsm_uport->clk_state = MSM_HS_CLK_ON;\r\nbreak;\r\ncase MSM_HS_CLK_ON:\r\nbreak;\r\ncase MSM_HS_CLK_PORT_OFF:\r\nbreak;\r\n}\r\n}\r\nvoid msm_hs_request_clock_on(struct uart_port *uport)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nmsm_hs_request_clock_on_locked(uport);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\n}\r\nstatic irqreturn_t msm_hs_rx_wakeup_isr(int irq, void *dev)\r\n{\r\nunsigned int wakeup = 0;\r\nunsigned long flags;\r\nstruct msm_hs_port *msm_uport = dev;\r\nstruct uart_port *uport = &msm_uport->uport;\r\nstruct tty_struct *tty = NULL;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nif (msm_uport->clk_state == MSM_HS_CLK_OFF) {\r\nif (msm_uport->rx_wakeup.ignore)\r\nmsm_uport->rx_wakeup.ignore = 0;\r\nelse\r\nwakeup = 1;\r\n}\r\nif (wakeup) {\r\nmsm_hs_request_clock_on_locked(uport);\r\nif (msm_uport->rx_wakeup.inject_rx) {\r\ntty = uport->state->port.tty;\r\ntty_insert_flip_char(tty,\r\nmsm_uport->rx_wakeup.rx_to_inject,\r\nTTY_NORMAL);\r\nqueue_work(msm_hs_workqueue, &msm_uport->rx.tty_work);\r\n}\r\n}\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic const char *msm_hs_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_MSM) ? "MSM_HS_UART" : NULL;\r\n}\r\nstatic int msm_hs_startup(struct uart_port *uport)\r\n{\r\nint ret;\r\nint rfr_level;\r\nunsigned long flags;\r\nunsigned int data;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nstruct circ_buf *tx_buf = &uport->state->xmit;\r\nstruct msm_hs_tx *tx = &msm_uport->tx;\r\nstruct msm_hs_rx *rx = &msm_uport->rx;\r\nrfr_level = uport->fifosize;\r\nif (rfr_level > 16)\r\nrfr_level -= 16;\r\ntx->dma_base = dma_map_single(uport->dev, tx_buf->buf, UART_XMIT_SIZE,\r\nDMA_TO_DEVICE);\r\nuport->state->port.tty->low_latency = 1;\r\nret = msm_hs_init_clk_locked(uport);\r\nif (unlikely(ret)) {\r\nprintk(KERN_ERR "Turning uartclk failed!\n");\r\ngoto err_msm_hs_init_clk;\r\n}\r\ndata = msm_hs_read(uport, UARTDM_MR1_ADDR);\r\ndata &= ~UARTDM_MR1_AUTO_RFR_LEVEL1_BMSK;\r\ndata &= ~UARTDM_MR1_AUTO_RFR_LEVEL0_BMSK;\r\ndata |= (UARTDM_MR1_AUTO_RFR_LEVEL1_BMSK & (rfr_level << 2));\r\ndata |= (UARTDM_MR1_AUTO_RFR_LEVEL0_BMSK & rfr_level);\r\nmsm_hs_write(uport, UARTDM_MR1_ADDR, data);\r\ndata = msm_hs_read(uport, UARTDM_IPR_ADDR);\r\nif (!data) {\r\ndata |= 0x1f & UARTDM_IPR_STALE_LSB_BMSK;\r\nmsm_hs_write(uport, UARTDM_IPR_ADDR, data);\r\n}\r\ndata = UARTDM_TX_DM_EN_BMSK | UARTDM_RX_DM_EN_BMSK;\r\nmsm_hs_write(uport, UARTDM_DMEN_ADDR, data);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_TX);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_RX);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_ERROR_STATUS);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_BREAK_INT);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_STALE_INT);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RESET_CTS);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, RFR_LOW);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, UARTDM_CR_RX_EN_BMSK);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, UARTDM_CR_TX_EN_BMSK);\r\ntx->tx_ready_int_en = 0;\r\ntx->dma_in_flight = 0;\r\ntx->xfer.complete_func = msm_hs_dmov_tx_callback;\r\ntx->xfer.execute_func = NULL;\r\ntx->command_ptr->cmd = CMD_LC |\r\nCMD_DST_CRCI(msm_uport->dma_tx_crci) | CMD_MODE_BOX;\r\ntx->command_ptr->src_dst_len = (MSM_UARTDM_BURST_SIZE << 16)\r\n| (MSM_UARTDM_BURST_SIZE);\r\ntx->command_ptr->row_offset = (MSM_UARTDM_BURST_SIZE << 16);\r\ntx->command_ptr->dst_row_addr =\r\nmsm_uport->uport.mapbase + UARTDM_TF_ADDR;\r\nrx->xfer.complete_func = msm_hs_dmov_rx_callback;\r\nrx->xfer.execute_func = NULL;\r\nrx->command_ptr->cmd = CMD_LC |\r\nCMD_SRC_CRCI(msm_uport->dma_rx_crci) | CMD_MODE_BOX;\r\nrx->command_ptr->src_dst_len = (MSM_UARTDM_BURST_SIZE << 16)\r\n| (MSM_UARTDM_BURST_SIZE);\r\nrx->command_ptr->row_offset = MSM_UARTDM_BURST_SIZE;\r\nrx->command_ptr->src_row_addr = uport->mapbase + UARTDM_RF_ADDR;\r\nmsm_uport->imr_reg |= UARTDM_ISR_RXSTALE_BMSK;\r\nmsm_uport->imr_reg |= UARTDM_ISR_CURRENT_CTS_BMSK;\r\nmsm_hs_write(uport, UARTDM_TFWR_ADDR, 0);\r\nret = request_irq(uport->irq, msm_hs_isr, IRQF_TRIGGER_HIGH,\r\n"msm_hs_uart", msm_uport);\r\nif (unlikely(ret)) {\r\nprintk(KERN_ERR "Request msm_hs_uart IRQ failed!\n");\r\ngoto err_request_irq;\r\n}\r\nif (use_low_power_rx_wakeup(msm_uport)) {\r\nret = request_irq(msm_uport->rx_wakeup.irq,\r\nmsm_hs_rx_wakeup_isr,\r\nIRQF_TRIGGER_FALLING,\r\n"msm_hs_rx_wakeup", msm_uport);\r\nif (unlikely(ret)) {\r\nprintk(KERN_ERR "Request msm_hs_rx_wakeup IRQ failed!\n");\r\nfree_irq(uport->irq, msm_uport);\r\ngoto err_request_irq;\r\n}\r\ndisable_irq(msm_uport->rx_wakeup.irq);\r\n}\r\nspin_lock_irqsave(&uport->lock, flags);\r\nmsm_hs_write(uport, UARTDM_RFWR_ADDR, 0);\r\nmsm_hs_start_rx_locked(uport);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\nret = pm_runtime_set_active(uport->dev);\r\nif (ret)\r\ndev_err(uport->dev, "set active error:%d\n", ret);\r\npm_runtime_enable(uport->dev);\r\nreturn 0;\r\nerr_request_irq:\r\nerr_msm_hs_init_clk:\r\ndma_unmap_single(uport->dev, tx->dma_base,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\nreturn ret;\r\n}\r\nstatic int __devinit uartdm_init_port(struct uart_port *uport)\r\n{\r\nint ret = 0;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nstruct msm_hs_tx *tx = &msm_uport->tx;\r\nstruct msm_hs_rx *rx = &msm_uport->rx;\r\ntx->command_ptr = kmalloc(sizeof(dmov_box), GFP_KERNEL | __GFP_DMA);\r\nif (!tx->command_ptr)\r\nreturn -ENOMEM;\r\ntx->command_ptr_ptr = kmalloc(sizeof(u32), GFP_KERNEL | __GFP_DMA);\r\nif (!tx->command_ptr_ptr) {\r\nret = -ENOMEM;\r\ngoto err_tx_command_ptr_ptr;\r\n}\r\ntx->mapped_cmd_ptr = dma_map_single(uport->dev, tx->command_ptr,\r\nsizeof(dmov_box), DMA_TO_DEVICE);\r\ntx->mapped_cmd_ptr_ptr = dma_map_single(uport->dev,\r\ntx->command_ptr_ptr,\r\nsizeof(u32), DMA_TO_DEVICE);\r\ntx->xfer.cmdptr = DMOV_CMD_ADDR(tx->mapped_cmd_ptr_ptr);\r\ninit_waitqueue_head(&rx->wait);\r\nrx->pool = dma_pool_create("rx_buffer_pool", uport->dev,\r\nUARTDM_RX_BUF_SIZE, 16, 0);\r\nif (!rx->pool) {\r\npr_err("%s(): cannot allocate rx_buffer_pool", __func__);\r\nret = -ENOMEM;\r\ngoto err_dma_pool_create;\r\n}\r\nrx->buffer = dma_pool_alloc(rx->pool, GFP_KERNEL, &rx->rbuffer);\r\nif (!rx->buffer) {\r\npr_err("%s(): cannot allocate rx->buffer", __func__);\r\nret = -ENOMEM;\r\ngoto err_dma_pool_alloc;\r\n}\r\nrx->command_ptr = kmalloc(sizeof(dmov_box), GFP_KERNEL | __GFP_DMA);\r\nif (!rx->command_ptr) {\r\npr_err("%s(): cannot allocate rx->command_ptr", __func__);\r\nret = -ENOMEM;\r\ngoto err_rx_command_ptr;\r\n}\r\nrx->command_ptr_ptr = kmalloc(sizeof(u32), GFP_KERNEL | __GFP_DMA);\r\nif (!rx->command_ptr_ptr) {\r\npr_err("%s(): cannot allocate rx->command_ptr_ptr", __func__);\r\nret = -ENOMEM;\r\ngoto err_rx_command_ptr_ptr;\r\n}\r\nrx->command_ptr->num_rows = ((UARTDM_RX_BUF_SIZE >> 4) << 16) |\r\n(UARTDM_RX_BUF_SIZE >> 4);\r\nrx->command_ptr->dst_row_addr = rx->rbuffer;\r\nrx->mapped_cmd_ptr = dma_map_single(uport->dev, rx->command_ptr,\r\nsizeof(dmov_box), DMA_TO_DEVICE);\r\n*rx->command_ptr_ptr = CMD_PTR_LP | DMOV_CMD_ADDR(rx->mapped_cmd_ptr);\r\nrx->cmdptr_dmaaddr = dma_map_single(uport->dev, rx->command_ptr_ptr,\r\nsizeof(u32), DMA_TO_DEVICE);\r\nrx->xfer.cmdptr = DMOV_CMD_ADDR(rx->cmdptr_dmaaddr);\r\nINIT_WORK(&rx->tty_work, msm_hs_tty_flip_buffer_work);\r\nreturn ret;\r\nerr_rx_command_ptr_ptr:\r\nkfree(rx->command_ptr);\r\nerr_rx_command_ptr:\r\ndma_pool_free(msm_uport->rx.pool, msm_uport->rx.buffer,\r\nmsm_uport->rx.rbuffer);\r\nerr_dma_pool_alloc:\r\ndma_pool_destroy(msm_uport->rx.pool);\r\nerr_dma_pool_create:\r\ndma_unmap_single(uport->dev, msm_uport->tx.mapped_cmd_ptr_ptr,\r\nsizeof(u32), DMA_TO_DEVICE);\r\ndma_unmap_single(uport->dev, msm_uport->tx.mapped_cmd_ptr,\r\nsizeof(dmov_box), DMA_TO_DEVICE);\r\nkfree(msm_uport->tx.command_ptr_ptr);\r\nerr_tx_command_ptr_ptr:\r\nkfree(msm_uport->tx.command_ptr);\r\nreturn ret;\r\n}\r\nstatic int __devinit msm_hs_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct uart_port *uport;\r\nstruct msm_hs_port *msm_uport;\r\nstruct resource *resource;\r\nconst struct msm_serial_hs_platform_data *pdata =\r\npdev->dev.platform_data;\r\nif (pdev->id < 0 || pdev->id >= UARTDM_NR) {\r\nprintk(KERN_ERR "Invalid plaform device ID = %d\n", pdev->id);\r\nreturn -EINVAL;\r\n}\r\nmsm_uport = &q_uart_port[pdev->id];\r\nuport = &msm_uport->uport;\r\nuport->dev = &pdev->dev;\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!resource))\r\nreturn -ENXIO;\r\nuport->mapbase = resource->start;\r\nuport->irq = platform_get_irq(pdev, 0);\r\nif (unlikely(uport->irq < 0))\r\nreturn -ENXIO;\r\nif (unlikely(irq_set_irq_wake(uport->irq, 1)))\r\nreturn -ENXIO;\r\nif (pdata == NULL || pdata->rx_wakeup_irq < 0)\r\nmsm_uport->rx_wakeup.irq = -1;\r\nelse {\r\nmsm_uport->rx_wakeup.irq = pdata->rx_wakeup_irq;\r\nmsm_uport->rx_wakeup.ignore = 1;\r\nmsm_uport->rx_wakeup.inject_rx = pdata->inject_rx_on_wakeup;\r\nmsm_uport->rx_wakeup.rx_to_inject = pdata->rx_to_inject;\r\nif (unlikely(msm_uport->rx_wakeup.irq < 0))\r\nreturn -ENXIO;\r\nif (unlikely(irq_set_irq_wake(msm_uport->rx_wakeup.irq, 1)))\r\nreturn -ENXIO;\r\n}\r\nif (pdata == NULL)\r\nmsm_uport->exit_lpm_cb = NULL;\r\nelse\r\nmsm_uport->exit_lpm_cb = pdata->exit_lpm_cb;\r\nresource = platform_get_resource_byname(pdev, IORESOURCE_DMA,\r\n"uartdm_channels");\r\nif (unlikely(!resource))\r\nreturn -ENXIO;\r\nmsm_uport->dma_tx_channel = resource->start;\r\nmsm_uport->dma_rx_channel = resource->end;\r\nresource = platform_get_resource_byname(pdev, IORESOURCE_DMA,\r\n"uartdm_crci");\r\nif (unlikely(!resource))\r\nreturn -ENXIO;\r\nmsm_uport->dma_tx_crci = resource->start;\r\nmsm_uport->dma_rx_crci = resource->end;\r\nuport->iotype = UPIO_MEM;\r\nuport->fifosize = UART_FIFOSIZE;\r\nuport->ops = &msm_hs_ops;\r\nuport->flags = UPF_BOOT_AUTOCONF;\r\nuport->uartclk = UARTCLK;\r\nmsm_uport->imr_reg = 0x0;\r\nmsm_uport->clk = clk_get(&pdev->dev, "uartdm_clk");\r\nif (IS_ERR(msm_uport->clk))\r\nreturn PTR_ERR(msm_uport->clk);\r\nret = uartdm_init_port(uport);\r\nif (unlikely(ret))\r\nreturn ret;\r\nmsm_uport->clk_state = MSM_HS_CLK_PORT_OFF;\r\nhrtimer_init(&msm_uport->clk_off_timer, CLOCK_MONOTONIC,\r\nHRTIMER_MODE_REL);\r\nmsm_uport->clk_off_timer.function = msm_hs_clk_off_retry;\r\nmsm_uport->clk_off_delay = ktime_set(0, 1000000);\r\nuport->line = pdev->id;\r\nreturn uart_add_one_port(&msm_hs_driver, uport);\r\n}\r\nstatic int __init msm_serial_hs_init(void)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < UARTDM_NR; i++)\r\nq_uart_port[i].uport.type = PORT_UNKNOWN;\r\nmsm_hs_workqueue = create_singlethread_workqueue("msm_serial_hs");\r\nif (unlikely(!msm_hs_workqueue))\r\nreturn -ENOMEM;\r\nret = uart_register_driver(&msm_hs_driver);\r\nif (unlikely(ret)) {\r\nprintk(KERN_ERR "%s failed to load\n", __func__);\r\ngoto err_uart_register_driver;\r\n}\r\nret = platform_driver_register(&msm_serial_hs_platform_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "%s failed to load\n", __func__);\r\ngoto err_platform_driver_register;\r\n}\r\nreturn ret;\r\nerr_platform_driver_register:\r\nuart_unregister_driver(&msm_hs_driver);\r\nerr_uart_register_driver:\r\ndestroy_workqueue(msm_hs_workqueue);\r\nreturn ret;\r\n}\r\nstatic void msm_hs_shutdown(struct uart_port *uport)\r\n{\r\nunsigned long flags;\r\nstruct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);\r\nBUG_ON(msm_uport->rx.flush < FLUSH_STOP);\r\nspin_lock_irqsave(&uport->lock, flags);\r\nclk_enable(msm_uport->clk);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, UARTDM_CR_TX_DISABLE_BMSK);\r\nmsm_hs_write(uport, UARTDM_CR_ADDR, UARTDM_CR_RX_DISABLE_BMSK);\r\npm_runtime_disable(uport->dev);\r\npm_runtime_set_suspended(uport->dev);\r\nfree_irq(uport->irq, msm_uport);\r\nif (use_low_power_rx_wakeup(msm_uport))\r\nfree_irq(msm_uport->rx_wakeup.irq, msm_uport);\r\nmsm_uport->imr_reg = 0;\r\nmsm_hs_write(uport, UARTDM_IMR_ADDR, msm_uport->imr_reg);\r\nwait_event(msm_uport->rx.wait, msm_uport->rx.flush == FLUSH_SHUTDOWN);\r\nclk_disable(msm_uport->clk);\r\nif (msm_uport->clk_state != MSM_HS_CLK_OFF)\r\nclk_disable(msm_uport->clk);\r\nmsm_uport->clk_state = MSM_HS_CLK_PORT_OFF;\r\ndma_unmap_single(uport->dev, msm_uport->tx.dma_base,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\nif (cancel_work_sync(&msm_uport->rx.tty_work))\r\nmsm_hs_tty_flip_buffer_work(&msm_uport->rx.tty_work);\r\n}\r\nstatic void __exit msm_serial_hs_exit(void)\r\n{\r\nflush_workqueue(msm_hs_workqueue);\r\ndestroy_workqueue(msm_hs_workqueue);\r\nplatform_driver_unregister(&msm_serial_hs_platform_driver);\r\nuart_unregister_driver(&msm_hs_driver);\r\n}\r\nstatic int msm_hs_runtime_idle(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int msm_hs_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = container_of(dev, struct\r\nplatform_device, dev);\r\nstruct msm_hs_port *msm_uport = &q_uart_port[pdev->id];\r\nmsm_hs_request_clock_on(&msm_uport->uport);\r\nreturn 0;\r\n}\r\nstatic int msm_hs_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = container_of(dev, struct\r\nplatform_device, dev);\r\nstruct msm_hs_port *msm_uport = &q_uart_port[pdev->id];\r\nmsm_hs_request_clock_off(&msm_uport->uport);\r\nreturn 0;\r\n}
