void __init vr41xx_pciu_setup(struct pci_controller_unit_setup *setup)\r\n{\r\nvr41xx_pci_controller_unit_setup = *setup;\r\n}\r\nstatic int __init vr41xx_pciu_init(void)\r\n{\r\nstruct pci_controller_unit_setup *setup;\r\nstruct pci_master_address_conversion *master;\r\nstruct pci_target_address_conversion *target;\r\nstruct pci_mailbox_address *mailbox;\r\nstruct pci_target_address_window *window;\r\nunsigned long vtclock, pci_clock_max;\r\nuint32_t val;\r\nsetup = &vr41xx_pci_controller_unit_setup;\r\nif (request_mem_region(PCIU_BASE, PCIU_SIZE, "PCIU") == NULL)\r\nreturn -EBUSY;\r\npciu_base = ioremap(PCIU_BASE, PCIU_SIZE);\r\nif (pciu_base == NULL) {\r\nrelease_mem_region(PCIU_BASE, PCIU_SIZE);\r\nreturn -EBUSY;\r\n}\r\nvr41xx_disable_pciint();\r\nvr41xx_supply_clock(PCIU_CLOCK);\r\nvr41xx_disable_pciint();\r\nif (setup->pci_clock_max != 0)\r\npci_clock_max = setup->pci_clock_max;\r\nelse\r\npci_clock_max = PCI_CLOCK_MAX;\r\nvtclock = vr41xx_get_vtclock_frequency();\r\nif (vtclock < pci_clock_max)\r\npciu_write(PCICLKSELREG, EQUAL_VTCLOCK);\r\nelse if ((vtclock / 2) < pci_clock_max)\r\npciu_write(PCICLKSELREG, HALF_VTCLOCK);\r\nelse if (current_cpu_data.processor_id >= PRID_VR4131_REV2_1 &&\r\n(vtclock / 3) < pci_clock_max)\r\npciu_write(PCICLKSELREG, ONE_THIRD_VTCLOCK);\r\nelse if ((vtclock / 4) < pci_clock_max)\r\npciu_write(PCICLKSELREG, QUARTER_VTCLOCK);\r\nelse {\r\nprintk(KERN_ERR "PCI Clock is over 33MHz.\n");\r\niounmap(pciu_base);\r\nreturn -EINVAL;\r\n}\r\nvr41xx_supply_clock(PCI_CLOCK);\r\nif (setup->master_memory1 != NULL) {\r\nmaster = setup->master_memory1;\r\nval = IBA(master->bus_base_address) |\r\nMASTER_MSK(master->address_mask) |\r\nWINEN |\r\nPCIA(master->pci_base_address);\r\npciu_write(PCIMMAW1REG, val);\r\n} else {\r\nval = pciu_read(PCIMMAW1REG);\r\nval &= ~WINEN;\r\npciu_write(PCIMMAW1REG, val);\r\n}\r\nif (setup->master_memory2 != NULL) {\r\nmaster = setup->master_memory2;\r\nval = IBA(master->bus_base_address) |\r\nMASTER_MSK(master->address_mask) |\r\nWINEN |\r\nPCIA(master->pci_base_address);\r\npciu_write(PCIMMAW2REG, val);\r\n} else {\r\nval = pciu_read(PCIMMAW2REG);\r\nval &= ~WINEN;\r\npciu_write(PCIMMAW2REG, val);\r\n}\r\nif (setup->target_memory1 != NULL) {\r\ntarget = setup->target_memory1;\r\nval = TARGET_MSK(target->address_mask) |\r\nWINEN |\r\nITA(target->bus_base_address);\r\npciu_write(PCITAW1REG, val);\r\n} else {\r\nval = pciu_read(PCITAW1REG);\r\nval &= ~WINEN;\r\npciu_write(PCITAW1REG, val);\r\n}\r\nif (setup->target_memory2 != NULL) {\r\ntarget = setup->target_memory2;\r\nval = TARGET_MSK(target->address_mask) |\r\nWINEN |\r\nITA(target->bus_base_address);\r\npciu_write(PCITAW2REG, val);\r\n} else {\r\nval = pciu_read(PCITAW2REG);\r\nval &= ~WINEN;\r\npciu_write(PCITAW2REG, val);\r\n}\r\nif (setup->master_io != NULL) {\r\nmaster = setup->master_io;\r\nval = IBA(master->bus_base_address) |\r\nMASTER_MSK(master->address_mask) |\r\nWINEN |\r\nPCIIA(master->pci_base_address);\r\npciu_write(PCIMIOAWREG, val);\r\n} else {\r\nval = pciu_read(PCIMIOAWREG);\r\nval &= ~WINEN;\r\npciu_write(PCIMIOAWREG, val);\r\n}\r\nif (setup->exclusive_access == CANNOT_LOCK_FROM_DEVICE)\r\npciu_write(PCIEXACCREG, UNLOCK);\r\nelse\r\npciu_write(PCIEXACCREG, 0);\r\nif (current_cpu_type() == CPU_VR4122)\r\npciu_write(PCITRDYVREG, TRDYV(setup->wait_time_limit_from_irdy_to_trdy));\r\npciu_write(LATTIMEREG, MLTIM(setup->master_latency_timer));\r\nif (setup->mailbox != NULL) {\r\nmailbox = setup->mailbox;\r\nval = MBADD(mailbox->base_address) | TYPE_32BITSPACE |\r\nMSI_MEMORY | PREF_APPROVAL;\r\npciu_write(MAILBAREG, val);\r\n}\r\nif (setup->target_window1) {\r\nwindow = setup->target_window1;\r\nval = PMBA(window->base_address) | TYPE_32BITSPACE |\r\nMSI_MEMORY | PREF_APPROVAL;\r\npciu_write(PCIMBA1REG, val);\r\n}\r\nif (setup->target_window2) {\r\nwindow = setup->target_window2;\r\nval = PMBA(window->base_address) | TYPE_32BITSPACE |\r\nMSI_MEMORY | PREF_APPROVAL;\r\npciu_write(PCIMBA2REG, val);\r\n}\r\nval = pciu_read(RETVALREG);\r\nval &= ~RTYVAL_MASK;\r\nval |= RTYVAL(setup->retry_limit);\r\npciu_write(RETVALREG, val);\r\nval = pciu_read(PCIAPCNTREG);\r\nval &= ~(TKYGNT | PAPC);\r\nswitch (setup->arbiter_priority_control) {\r\ncase PCI_ARBITRATION_MODE_ALTERNATE_0:\r\nval |= PAPC_ALTERNATE_0;\r\nbreak;\r\ncase PCI_ARBITRATION_MODE_ALTERNATE_B:\r\nval |= PAPC_ALTERNATE_B;\r\nbreak;\r\ndefault:\r\nval |= PAPC_FAIR;\r\nbreak;\r\n}\r\nif (setup->take_away_gnt_mode == PCI_TAKE_AWAY_GNT_ENABLE)\r\nval |= TKYGNT_ENABLE;\r\npciu_write(PCIAPCNTREG, val);\r\npciu_write(COMMANDREG, PCI_COMMAND_IO | PCI_COMMAND_MEMORY |\r\nPCI_COMMAND_MASTER | PCI_COMMAND_PARITY |\r\nPCI_COMMAND_SERR);\r\npciu_read(BUSERRADREG);\r\npciu_write(PCIENREG, PCIU_CONFIG_DONE);\r\nif (setup->mem_resource != NULL)\r\nvr41xx_pci_controller.mem_resource = setup->mem_resource;\r\nif (setup->io_resource != NULL) {\r\nvr41xx_pci_controller.io_resource = setup->io_resource;\r\n} else {\r\nset_io_port_base(IO_PORT_BASE);\r\nioport_resource.start = IO_PORT_RESOURCE_START;\r\nioport_resource.end = IO_PORT_RESOURCE_END;\r\n}\r\nif (setup->master_io) {\r\nvoid __iomem *io_map_base;\r\nstruct resource *res = vr41xx_pci_controller.io_resource;\r\nmaster = setup->master_io;\r\nio_map_base = ioremap(master->bus_base_address,\r\nresource_size(res));\r\nif (!io_map_base)\r\nreturn -EBUSY;\r\nvr41xx_pci_controller.io_map_base = (unsigned long)io_map_base;\r\n}\r\nregister_pci_controller(&vr41xx_pci_controller);\r\nreturn 0;\r\n}
