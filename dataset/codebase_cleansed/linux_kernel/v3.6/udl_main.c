static int udl_parse_vendor_descriptor(struct drm_device *dev,\r\nstruct usb_device *usbdev)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nchar *desc;\r\nchar *buf;\r\nchar *desc_end;\r\nu8 total_len = 0;\r\nbuf = kzalloc(MAX_VENDOR_DESCRIPTOR_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn false;\r\ndesc = buf;\r\ntotal_len = usb_get_descriptor(usbdev, 0x5f,\r\n0, desc, MAX_VENDOR_DESCRIPTOR_SIZE);\r\nif (total_len > 5) {\r\nDRM_INFO("vendor descriptor length:%x data:%02x %02x %02x %02x" \\r\n"%02x %02x %02x %02x %02x %02x %02x\n",\r\ntotal_len, desc[0],\r\ndesc[1], desc[2], desc[3], desc[4], desc[5], desc[6],\r\ndesc[7], desc[8], desc[9], desc[10]);\r\nif ((desc[0] != total_len) ||\r\n(desc[1] != 0x5f) ||\r\n(desc[2] != 0x01) ||\r\n(desc[3] != 0x00) ||\r\n(desc[4] != total_len - 2))\r\ngoto unrecognized;\r\ndesc_end = desc + total_len;\r\ndesc += 5;\r\nwhile (desc < desc_end) {\r\nu8 length;\r\nu16 key;\r\nkey = le16_to_cpu(*((u16 *) desc));\r\ndesc += sizeof(u16);\r\nlength = *desc;\r\ndesc++;\r\nswitch (key) {\r\ncase 0x0200: {\r\nu32 max_area;\r\nmax_area = le32_to_cpu(*((u32 *)desc));\r\nDRM_DEBUG("DL chip limited to %d pixel modes\n",\r\nmax_area);\r\nudl->sku_pixel_limit = max_area;\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\ndesc += length;\r\n}\r\n}\r\ngoto success;\r\nunrecognized:\r\nDRM_ERROR("Unrecognized vendor firmware descriptor\n");\r\nsuccess:\r\nkfree(buf);\r\nreturn true;\r\n}\r\nstatic void udl_release_urb_work(struct work_struct *work)\r\n{\r\nstruct urb_node *unode = container_of(work, struct urb_node,\r\nrelease_urb_work.work);\r\nup(&unode->dev->urbs.limit_sem);\r\n}\r\nvoid udl_urb_completion(struct urb *urb)\r\n{\r\nstruct urb_node *unode = urb->context;\r\nstruct udl_device *udl = unode->dev;\r\nunsigned long flags;\r\nif (urb->status) {\r\nif (!(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN)) {\r\nDRM_ERROR("%s - nonzero write bulk status received: %d\n",\r\n__func__, urb->status);\r\natomic_set(&udl->lost_pixels, 1);\r\n}\r\n}\r\nurb->transfer_buffer_length = udl->urbs.size;\r\nspin_lock_irqsave(&udl->urbs.lock, flags);\r\nlist_add_tail(&unode->entry, &udl->urbs.list);\r\nudl->urbs.available++;\r\nspin_unlock_irqrestore(&udl->urbs.lock, flags);\r\n#if 0\r\nif (fb_defio)\r\nschedule_delayed_work(&unode->release_urb_work, 0);\r\nelse\r\n#endif\r\nup(&udl->urbs.limit_sem);\r\n}\r\nstatic void udl_free_urb_list(struct drm_device *dev)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nint count = udl->urbs.count;\r\nstruct list_head *node;\r\nstruct urb_node *unode;\r\nstruct urb *urb;\r\nint ret;\r\nunsigned long flags;\r\nDRM_DEBUG("Waiting for completes and freeing all render urbs\n");\r\nwhile (count--) {\r\nret = down_interruptible(&udl->urbs.limit_sem);\r\nif (ret)\r\nbreak;\r\nspin_lock_irqsave(&udl->urbs.lock, flags);\r\nnode = udl->urbs.list.next;\r\nlist_del_init(node);\r\nspin_unlock_irqrestore(&udl->urbs.lock, flags);\r\nunode = list_entry(node, struct urb_node, entry);\r\nurb = unode->urb;\r\nusb_free_coherent(urb->dev, udl->urbs.size,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nkfree(node);\r\n}\r\nudl->urbs.count = 0;\r\n}\r\nstatic int udl_alloc_urb_list(struct drm_device *dev, int count, size_t size)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nint i = 0;\r\nstruct urb *urb;\r\nstruct urb_node *unode;\r\nchar *buf;\r\nspin_lock_init(&udl->urbs.lock);\r\nudl->urbs.size = size;\r\nINIT_LIST_HEAD(&udl->urbs.list);\r\nwhile (i < count) {\r\nunode = kzalloc(sizeof(struct urb_node), GFP_KERNEL);\r\nif (!unode)\r\nbreak;\r\nunode->dev = udl;\r\nINIT_DELAYED_WORK(&unode->release_urb_work,\r\nudl_release_urb_work);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nkfree(unode);\r\nbreak;\r\n}\r\nunode->urb = urb;\r\nbuf = usb_alloc_coherent(udl->ddev->usbdev, MAX_TRANSFER, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nkfree(unode);\r\nusb_free_urb(urb);\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, udl->ddev->usbdev, usb_sndbulkpipe(udl->ddev->usbdev, 1),\r\nbuf, size, udl_urb_completion, unode);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nlist_add_tail(&unode->entry, &udl->urbs.list);\r\ni++;\r\n}\r\nsema_init(&udl->urbs.limit_sem, i);\r\nudl->urbs.count = i;\r\nudl->urbs.available = i;\r\nDRM_DEBUG("allocated %d %d byte urbs\n", i, (int) size);\r\nreturn i;\r\n}\r\nstruct urb *udl_get_urb(struct drm_device *dev)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nint ret = 0;\r\nstruct list_head *entry;\r\nstruct urb_node *unode;\r\nstruct urb *urb = NULL;\r\nunsigned long flags;\r\nret = down_timeout(&udl->urbs.limit_sem, GET_URB_TIMEOUT);\r\nif (ret) {\r\natomic_set(&udl->lost_pixels, 1);\r\nDRM_INFO("wait for urb interrupted: %x available: %d\n",\r\nret, udl->urbs.available);\r\ngoto error;\r\n}\r\nspin_lock_irqsave(&udl->urbs.lock, flags);\r\nBUG_ON(list_empty(&udl->urbs.list));\r\nentry = udl->urbs.list.next;\r\nlist_del_init(entry);\r\nudl->urbs.available--;\r\nspin_unlock_irqrestore(&udl->urbs.lock, flags);\r\nunode = list_entry(entry, struct urb_node, entry);\r\nurb = unode->urb;\r\nerror:\r\nreturn urb;\r\n}\r\nint udl_submit_urb(struct drm_device *dev, struct urb *urb, size_t len)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nint ret;\r\nBUG_ON(len > udl->urbs.size);\r\nurb->transfer_buffer_length = len;\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret) {\r\nudl_urb_completion(urb);\r\natomic_set(&udl->lost_pixels, 1);\r\nDRM_ERROR("usb_submit_urb error %x\n", ret);\r\n}\r\nreturn ret;\r\n}\r\nint udl_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct udl_device *udl;\r\nint ret;\r\nDRM_DEBUG("\n");\r\nudl = kzalloc(sizeof(struct udl_device), GFP_KERNEL);\r\nif (!udl)\r\nreturn -ENOMEM;\r\nudl->ddev = dev;\r\ndev->dev_private = udl;\r\nif (!udl_parse_vendor_descriptor(dev, dev->usbdev)) {\r\nDRM_ERROR("firmware not recognized. Assume incompatible device\n");\r\ngoto err;\r\n}\r\nif (!udl_alloc_urb_list(dev, WRITES_IN_FLIGHT, MAX_TRANSFER)) {\r\nret = -ENOMEM;\r\nDRM_ERROR("udl_alloc_urb_list failed\n");\r\ngoto err;\r\n}\r\nDRM_DEBUG("\n");\r\nret = udl_modeset_init(dev);\r\nret = udl_fbdev_init(dev);\r\nreturn 0;\r\nerr:\r\nkfree(udl);\r\nDRM_ERROR("%d\n", ret);\r\nreturn ret;\r\n}\r\nint udl_drop_usb(struct drm_device *dev)\r\n{\r\nudl_free_urb_list(dev);\r\nreturn 0;\r\n}\r\nint udl_driver_unload(struct drm_device *dev)\r\n{\r\nstruct udl_device *udl = dev->dev_private;\r\nif (udl->urbs.count)\r\nudl_free_urb_list(dev);\r\nudl_fbdev_cleanup(dev);\r\nudl_modeset_cleanup(dev);\r\nkfree(udl);\r\nreturn 0;\r\n}
