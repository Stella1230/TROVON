static int kxtj9_i2c_read(struct kxtj9_data *tj9, u8 addr, u8 *data, int len)\r\n{\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = tj9->client->addr,\r\n.flags = tj9->client->flags,\r\n.len = 1,\r\n.buf = &addr,\r\n},\r\n{\r\n.addr = tj9->client->addr,\r\n.flags = tj9->client->flags | I2C_M_RD,\r\n.len = len,\r\n.buf = data,\r\n},\r\n};\r\nreturn i2c_transfer(tj9->client->adapter, msgs, 2);\r\n}\r\nstatic void kxtj9_report_acceleration_data(struct kxtj9_data *tj9)\r\n{\r\ns16 acc_data[3];\r\ns16 x, y, z;\r\nint err;\r\nerr = kxtj9_i2c_read(tj9, XOUT_L, (u8 *)acc_data, 6);\r\nif (err < 0)\r\ndev_err(&tj9->client->dev, "accelerometer data read failed\n");\r\nx = le16_to_cpu(acc_data[tj9->pdata.axis_map_x]);\r\ny = le16_to_cpu(acc_data[tj9->pdata.axis_map_y]);\r\nz = le16_to_cpu(acc_data[tj9->pdata.axis_map_z]);\r\nx >>= tj9->shift;\r\ny >>= tj9->shift;\r\nz >>= tj9->shift;\r\ninput_report_abs(tj9->input_dev, ABS_X, tj9->pdata.negate_x ? -x : x);\r\ninput_report_abs(tj9->input_dev, ABS_Y, tj9->pdata.negate_y ? -y : y);\r\ninput_report_abs(tj9->input_dev, ABS_Z, tj9->pdata.negate_z ? -z : z);\r\ninput_sync(tj9->input_dev);\r\n}\r\nstatic irqreturn_t kxtj9_isr(int irq, void *dev)\r\n{\r\nstruct kxtj9_data *tj9 = dev;\r\nint err;\r\nkxtj9_report_acceleration_data(tj9);\r\nerr = i2c_smbus_read_byte_data(tj9->client, INT_REL);\r\nif (err < 0)\r\ndev_err(&tj9->client->dev,\r\n"error clearing interrupt status: %d\n", err);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int kxtj9_update_g_range(struct kxtj9_data *tj9, u8 new_g_range)\r\n{\r\nswitch (new_g_range) {\r\ncase KXTJ9_G_2G:\r\ntj9->shift = 4;\r\nbreak;\r\ncase KXTJ9_G_4G:\r\ntj9->shift = 3;\r\nbreak;\r\ncase KXTJ9_G_8G:\r\ntj9->shift = 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntj9->ctrl_reg1 &= 0xe7;\r\ntj9->ctrl_reg1 |= new_g_range;\r\nreturn 0;\r\n}\r\nstatic int kxtj9_update_odr(struct kxtj9_data *tj9, unsigned int poll_interval)\r\n{\r\nint err;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(kxtj9_odr_table); i++) {\r\ntj9->data_ctrl = kxtj9_odr_table[i].mask;\r\nif (poll_interval < kxtj9_odr_table[i].cutoff)\r\nbreak;\r\n}\r\nerr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(tj9->client, DATA_CTRL, tj9->data_ctrl);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, tj9->ctrl_reg1);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int kxtj9_device_power_on(struct kxtj9_data *tj9)\r\n{\r\nif (tj9->pdata.power_on)\r\nreturn tj9->pdata.power_on();\r\nreturn 0;\r\n}\r\nstatic void kxtj9_device_power_off(struct kxtj9_data *tj9)\r\n{\r\nint err;\r\ntj9->ctrl_reg1 &= PC1_OFF;\r\nerr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, tj9->ctrl_reg1);\r\nif (err < 0)\r\ndev_err(&tj9->client->dev, "soft power off failed\n");\r\nif (tj9->pdata.power_off)\r\ntj9->pdata.power_off();\r\n}\r\nstatic int kxtj9_enable(struct kxtj9_data *tj9)\r\n{\r\nint err;\r\nerr = kxtj9_device_power_on(tj9);\r\nif (err < 0)\r\nreturn err;\r\nerr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, 0);\r\nif (err < 0)\r\nreturn err;\r\nif (tj9->client->irq) {\r\nerr = i2c_smbus_write_byte_data(tj9->client,\r\nINT_CTRL1, tj9->int_ctrl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = kxtj9_update_g_range(tj9, tj9->pdata.g_range);\r\nif (err < 0)\r\nreturn err;\r\ntj9->ctrl_reg1 |= PC1_ON;\r\nerr = i2c_smbus_write_byte_data(tj9->client, CTRL_REG1, tj9->ctrl_reg1);\r\nif (err < 0)\r\nreturn err;\r\nerr = kxtj9_update_odr(tj9, tj9->last_poll_interval);\r\nif (err < 0)\r\nreturn err;\r\nif (tj9->client->irq) {\r\nerr = i2c_smbus_read_byte_data(tj9->client, INT_REL);\r\nif (err < 0) {\r\ndev_err(&tj9->client->dev,\r\n"error clearing interrupt: %d\n", err);\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nkxtj9_device_power_off(tj9);\r\nreturn err;\r\n}\r\nstatic void kxtj9_disable(struct kxtj9_data *tj9)\r\n{\r\nkxtj9_device_power_off(tj9);\r\n}\r\nstatic int kxtj9_input_open(struct input_dev *input)\r\n{\r\nstruct kxtj9_data *tj9 = input_get_drvdata(input);\r\nreturn kxtj9_enable(tj9);\r\n}\r\nstatic void kxtj9_input_close(struct input_dev *dev)\r\n{\r\nstruct kxtj9_data *tj9 = input_get_drvdata(dev);\r\nkxtj9_disable(tj9);\r\n}\r\nstatic void __devinit kxtj9_init_input_device(struct kxtj9_data *tj9,\r\nstruct input_dev *input_dev)\r\n{\r\n__set_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_X, -G_MAX, G_MAX, FUZZ, FLAT);\r\ninput_set_abs_params(input_dev, ABS_Y, -G_MAX, G_MAX, FUZZ, FLAT);\r\ninput_set_abs_params(input_dev, ABS_Z, -G_MAX, G_MAX, FUZZ, FLAT);\r\ninput_dev->name = "kxtj9_accel";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &tj9->client->dev;\r\n}\r\nstatic int __devinit kxtj9_setup_input_device(struct kxtj9_data *tj9)\r\n{\r\nstruct input_dev *input_dev;\r\nint err;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\ndev_err(&tj9->client->dev, "input device allocate failed\n");\r\nreturn -ENOMEM;\r\n}\r\ntj9->input_dev = input_dev;\r\ninput_dev->open = kxtj9_input_open;\r\ninput_dev->close = kxtj9_input_close;\r\ninput_set_drvdata(input_dev, tj9);\r\nkxtj9_init_input_device(tj9, input_dev);\r\nerr = input_register_device(tj9->input_dev);\r\nif (err) {\r\ndev_err(&tj9->client->dev,\r\n"unable to register input polled device %s: %d\n",\r\ntj9->input_dev->name, err);\r\ninput_free_device(tj9->input_dev);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t kxtj9_get_poll(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d\n", tj9->last_poll_interval);\r\n}\r\nstatic ssize_t kxtj9_set_poll(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = tj9->input_dev;\r\nunsigned int interval;\r\nint error;\r\nerror = kstrtouint(buf, 10, &interval);\r\nif (error < 0)\r\nreturn error;\r\nmutex_lock(&input_dev->mutex);\r\ndisable_irq(client->irq);\r\ntj9->last_poll_interval = max(interval, tj9->pdata.min_interval);\r\nkxtj9_update_odr(tj9, tj9->last_poll_interval);\r\nenable_irq(client->irq);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn count;\r\n}\r\nstatic void kxtj9_poll(struct input_polled_dev *dev)\r\n{\r\nstruct kxtj9_data *tj9 = dev->private;\r\nunsigned int poll_interval = dev->poll_interval;\r\nkxtj9_report_acceleration_data(tj9);\r\nif (poll_interval != tj9->last_poll_interval) {\r\nkxtj9_update_odr(tj9, poll_interval);\r\ntj9->last_poll_interval = poll_interval;\r\n}\r\n}\r\nstatic void kxtj9_polled_input_open(struct input_polled_dev *dev)\r\n{\r\nstruct kxtj9_data *tj9 = dev->private;\r\nkxtj9_enable(tj9);\r\n}\r\nstatic void kxtj9_polled_input_close(struct input_polled_dev *dev)\r\n{\r\nstruct kxtj9_data *tj9 = dev->private;\r\nkxtj9_disable(tj9);\r\n}\r\nstatic int __devinit kxtj9_setup_polled_device(struct kxtj9_data *tj9)\r\n{\r\nint err;\r\nstruct input_polled_dev *poll_dev;\r\npoll_dev = input_allocate_polled_device();\r\nif (!poll_dev) {\r\ndev_err(&tj9->client->dev,\r\n"Failed to allocate polled device\n");\r\nreturn -ENOMEM;\r\n}\r\ntj9->poll_dev = poll_dev;\r\ntj9->input_dev = poll_dev->input;\r\npoll_dev->private = tj9;\r\npoll_dev->poll = kxtj9_poll;\r\npoll_dev->open = kxtj9_polled_input_open;\r\npoll_dev->close = kxtj9_polled_input_close;\r\nkxtj9_init_input_device(tj9, poll_dev->input);\r\nerr = input_register_polled_device(poll_dev);\r\nif (err) {\r\ndev_err(&tj9->client->dev,\r\n"Unable to register polled device, err=%d\n", err);\r\ninput_free_polled_device(poll_dev);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devexit kxtj9_teardown_polled_device(struct kxtj9_data *tj9)\r\n{\r\ninput_unregister_polled_device(tj9->poll_dev);\r\ninput_free_polled_device(tj9->poll_dev);\r\n}\r\nstatic inline int kxtj9_setup_polled_device(struct kxtj9_data *tj9)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic inline void kxtj9_teardown_polled_device(struct kxtj9_data *tj9)\r\n{\r\n}\r\nstatic int __devinit kxtj9_verify(struct kxtj9_data *tj9)\r\n{\r\nint retval;\r\nretval = kxtj9_device_power_on(tj9);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = i2c_smbus_read_byte_data(tj9->client, WHO_AM_I);\r\nif (retval < 0) {\r\ndev_err(&tj9->client->dev, "read err int source\n");\r\ngoto out;\r\n}\r\nretval = (retval != 0x07 && retval != 0x08) ? -EIO : 0;\r\nout:\r\nkxtj9_device_power_off(tj9);\r\nreturn retval;\r\n}\r\nstatic int __devinit kxtj9_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct kxtj9_platform_data *pdata = client->dev.platform_data;\r\nstruct kxtj9_data *tj9;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "client is not i2c capable\n");\r\nreturn -ENXIO;\r\n}\r\nif (!pdata) {\r\ndev_err(&client->dev, "platform data is NULL; exiting\n");\r\nreturn -EINVAL;\r\n}\r\ntj9 = kzalloc(sizeof(*tj9), GFP_KERNEL);\r\nif (!tj9) {\r\ndev_err(&client->dev,\r\n"failed to allocate memory for module data\n");\r\nreturn -ENOMEM;\r\n}\r\ntj9->client = client;\r\ntj9->pdata = *pdata;\r\nif (pdata->init) {\r\nerr = pdata->init();\r\nif (err < 0)\r\ngoto err_free_mem;\r\n}\r\nerr = kxtj9_verify(tj9);\r\nif (err < 0) {\r\ndev_err(&client->dev, "device not recognized\n");\r\ngoto err_pdata_exit;\r\n}\r\ni2c_set_clientdata(client, tj9);\r\ntj9->ctrl_reg1 = tj9->pdata.res_12bit | tj9->pdata.g_range;\r\ntj9->last_poll_interval = tj9->pdata.init_interval;\r\nif (client->irq) {\r\ntj9->int_ctrl |= KXTJ9_IEN | KXTJ9_IEA | KXTJ9_IEL;\r\ntj9->ctrl_reg1 |= DRDYE;\r\nerr = kxtj9_setup_input_device(tj9);\r\nif (err)\r\ngoto err_pdata_exit;\r\nerr = request_threaded_irq(client->irq, NULL, kxtj9_isr,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"kxtj9-irq", tj9);\r\nif (err) {\r\ndev_err(&client->dev, "request irq failed: %d\n", err);\r\ngoto err_destroy_input;\r\n}\r\nerr = sysfs_create_group(&client->dev.kobj, &kxtj9_attribute_group);\r\nif (err) {\r\ndev_err(&client->dev, "sysfs create failed: %d\n", err);\r\ngoto err_free_irq;\r\n}\r\n} else {\r\nerr = kxtj9_setup_polled_device(tj9);\r\nif (err)\r\ngoto err_pdata_exit;\r\n}\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, tj9);\r\nerr_destroy_input:\r\ninput_unregister_device(tj9->input_dev);\r\nerr_pdata_exit:\r\nif (tj9->pdata.exit)\r\ntj9->pdata.exit();\r\nerr_free_mem:\r\nkfree(tj9);\r\nreturn err;\r\n}\r\nstatic int __devexit kxtj9_remove(struct i2c_client *client)\r\n{\r\nstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\r\nif (client->irq) {\r\nsysfs_remove_group(&client->dev.kobj, &kxtj9_attribute_group);\r\nfree_irq(client->irq, tj9);\r\ninput_unregister_device(tj9->input_dev);\r\n} else {\r\nkxtj9_teardown_polled_device(tj9);\r\n}\r\nif (tj9->pdata.exit)\r\ntj9->pdata.exit();\r\nkfree(tj9);\r\nreturn 0;\r\n}\r\nstatic int kxtj9_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = tj9->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nkxtj9_disable(tj9);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int kxtj9_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct kxtj9_data *tj9 = i2c_get_clientdata(client);\r\nstruct input_dev *input_dev = tj9->input_dev;\r\nint retval = 0;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nkxtj9_enable(tj9);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn retval;\r\n}
