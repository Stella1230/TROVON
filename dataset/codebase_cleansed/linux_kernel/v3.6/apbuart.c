static void apbuart_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int cr;\r\ncr = UART_GET_CTRL(port);\r\ncr &= ~UART_CTRL_TI;\r\nUART_PUT_CTRL(port, cr);\r\n}\r\nstatic void apbuart_start_tx(struct uart_port *port)\r\n{\r\nunsigned int cr;\r\ncr = UART_GET_CTRL(port);\r\ncr |= UART_CTRL_TI;\r\nUART_PUT_CTRL(port, cr);\r\nif (UART_GET_STATUS(port) & UART_STATUS_THE)\r\napbuart_tx_chars(port);\r\n}\r\nstatic void apbuart_stop_rx(struct uart_port *port)\r\n{\r\nunsigned int cr;\r\ncr = UART_GET_CTRL(port);\r\ncr &= ~(UART_CTRL_RI);\r\nUART_PUT_CTRL(port, cr);\r\n}\r\nstatic void apbuart_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void apbuart_rx_chars(struct uart_port *port)\r\n{\r\nstruct tty_struct *tty = port->state->port.tty;\r\nunsigned int status, ch, rsr, flag;\r\nunsigned int max_chars = port->fifosize;\r\nstatus = UART_GET_STATUS(port);\r\nwhile (UART_RX_DATA(status) && (max_chars--)) {\r\nch = UART_GET_CHAR(port);\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nrsr = UART_GET_STATUS(port) | UART_DUMMY_RSR_RX;\r\nUART_PUT_STATUS(port, 0);\r\nif (rsr & UART_STATUS_ERR) {\r\nif (rsr & UART_STATUS_BR) {\r\nrsr &= ~(UART_STATUS_FE | UART_STATUS_PE);\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ngoto ignore_char;\r\n} else if (rsr & UART_STATUS_PE) {\r\nport->icount.parity++;\r\n} else if (rsr & UART_STATUS_FE) {\r\nport->icount.frame++;\r\n}\r\nif (rsr & UART_STATUS_OE)\r\nport->icount.overrun++;\r\nrsr &= port->read_status_mask;\r\nif (rsr & UART_STATUS_PE)\r\nflag = TTY_PARITY;\r\nelse if (rsr & UART_STATUS_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(port, rsr, UART_STATUS_OE, ch, flag);\r\nignore_char:\r\nstatus = UART_GET_STATUS(port);\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic void apbuart_tx_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nint count;\r\nif (port->x_char) {\r\nUART_PUT_CHAR(port, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\napbuart_stop_tx(port);\r\nreturn;\r\n}\r\ncount = port->fifosize >> 1;\r\ndo {\r\nUART_PUT_CHAR(port, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\napbuart_stop_tx(port);\r\n}\r\nstatic irqreturn_t apbuart_int(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nunsigned int status;\r\nspin_lock(&port->lock);\r\nstatus = UART_GET_STATUS(port);\r\nif (status & UART_STATUS_DR)\r\napbuart_rx_chars(port);\r\nif (status & UART_STATUS_THE)\r\napbuart_tx_chars(port);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int apbuart_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int status = UART_GET_STATUS(port);\r\nreturn status & UART_STATUS_THE ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int apbuart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void apbuart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void apbuart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic int apbuart_startup(struct uart_port *port)\r\n{\r\nint retval;\r\nunsigned int cr;\r\nretval = request_irq(port->irq, apbuart_int, 0, "apbuart", port);\r\nif (retval)\r\nreturn retval;\r\ncr = UART_GET_CTRL(port);\r\nUART_PUT_CTRL(port,\r\ncr | UART_CTRL_RE | UART_CTRL_TE |\r\nUART_CTRL_RI | UART_CTRL_TI);\r\nreturn 0;\r\n}\r\nstatic void apbuart_shutdown(struct uart_port *port)\r\n{\r\nunsigned int cr;\r\ncr = UART_GET_CTRL(port);\r\nUART_PUT_CTRL(port,\r\ncr & ~(UART_CTRL_RE | UART_CTRL_TE |\r\nUART_CTRL_RI | UART_CTRL_TI));\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void apbuart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nunsigned int cr;\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\r\nif (baud == 0)\r\npanic("invalid baudrate %i\n", port->uartclk / 16);\r\nquot = (uart_get_divisor(port, baud)) * 2;\r\ncr = UART_GET_CTRL(port);\r\ncr &= ~(UART_CTRL_PE | UART_CTRL_PS);\r\nif (termios->c_cflag & PARENB) {\r\ncr |= UART_CTRL_PE;\r\nif ((termios->c_cflag & PARODD))\r\ncr |= UART_CTRL_PS;\r\n}\r\nif (termios->c_cflag & CRTSCTS)\r\ncr |= UART_CTRL_FL;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nport->read_status_mask = UART_STATUS_OE;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UART_STATUS_FE | UART_STATUS_PE;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART_STATUS_FE | UART_STATUS_PE;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= UART_DUMMY_RSR_RX;\r\nquot -= 1;\r\nUART_PUT_SCAL(port, quot);\r\nUART_PUT_CTRL(port, cr);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *apbuart_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_APBUART ? "GRLIB/APBUART" : NULL;\r\n}\r\nstatic void apbuart_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, 0x100);\r\n}\r\nstatic int apbuart_request_port(struct uart_port *port)\r\n{\r\nreturn request_mem_region(port->mapbase, 0x100, "grlib-apbuart")\r\n!= NULL ? 0 : -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void apbuart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_APBUART;\r\napbuart_request_port(port);\r\n}\r\n}\r\nstatic int apbuart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_APBUART)\r\nret = -EINVAL;\r\nif (ser->irq < 0 || ser->irq >= NR_IRQS)\r\nret = -EINVAL;\r\nif (ser->baud_base < 9600)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int apbuart_scan_fifo_size(struct uart_port *port, int portnumber)\r\n{\r\nint ctrl, loop = 0;\r\nint status;\r\nint fifosize;\r\nunsigned long flags;\r\nctrl = UART_GET_CTRL(port);\r\nlocal_irq_save(flags);\r\nUART_PUT_CTRL(port, ctrl | UART_CTRL_TE);\r\nwhile (!UART_TX_READY(UART_GET_STATUS(port)))\r\nloop++;\r\nUART_PUT_CTRL(port, ctrl & ~(UART_CTRL_TE));\r\nfifosize = 1;\r\nUART_PUT_CHAR(port, 0);\r\nstatus = UART_GET_STATUS(port);\r\nwhile (((status >> 20) & 0x3F) == fifosize) {\r\nfifosize++;\r\nUART_PUT_CHAR(port, 0);\r\nstatus = UART_GET_STATUS(port);\r\n}\r\nfifosize--;\r\nUART_PUT_CTRL(port, ctrl);\r\nlocal_irq_restore(flags);\r\nif (fifosize == 0)\r\nfifosize = 1;\r\nreturn fifosize;\r\n}\r\nstatic void apbuart_flush_fifo(struct uart_port *port)\r\n{\r\nint i;\r\nfor (i = 0; i < port->fifosize; i++)\r\nUART_GET_CHAR(port);\r\n}\r\nstatic void apbuart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nunsigned int status;\r\ndo {\r\nstatus = UART_GET_STATUS(port);\r\n} while (!UART_TX_READY(status));\r\nUART_PUT_CHAR(port, ch);\r\n}\r\nstatic void\r\napbuart_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_port *port = &grlib_apbuart_ports[co->index];\r\nunsigned int status, old_cr, new_cr;\r\nold_cr = UART_GET_CTRL(port);\r\nnew_cr = old_cr & ~(UART_CTRL_RI | UART_CTRL_TI);\r\nUART_PUT_CTRL(port, new_cr);\r\nuart_console_write(port, s, count, apbuart_console_putchar);\r\ndo {\r\nstatus = UART_GET_STATUS(port);\r\n} while (!UART_TX_READY(status));\r\nUART_PUT_CTRL(port, old_cr);\r\n}\r\nstatic void __init\r\napbuart_console_get_options(struct uart_port *port, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (UART_GET_CTRL(port) & (UART_CTRL_RE | UART_CTRL_TE)) {\r\nunsigned int quot, status;\r\nstatus = UART_GET_STATUS(port);\r\n*parity = 'n';\r\nif (status & UART_CTRL_PE) {\r\nif ((status & UART_CTRL_PS) == 0)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\n*bits = 8;\r\nquot = UART_GET_SCAL(port) / 8;\r\n*baud = port->uartclk / (16 * (quot + 1));\r\n}\r\n}\r\nstatic int __init apbuart_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 38400;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\npr_debug("apbuart_console_setup co=%p, co->index=%i, options=%s\n",\r\nco, co->index, options);\r\nif (co->index >= grlib_apbuart_port_nr)\r\nco->index = 0;\r\nport = &grlib_apbuart_ports[co->index];\r\nspin_lock_init(&port->lock);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\napbuart_console_get_options(port, &baud, &parity, &bits);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init apbuart_console_init(void)\r\n{\r\nif (grlib_apbuart_configure())\r\nreturn -ENODEV;\r\nregister_console(&grlib_apbuart_console);\r\nreturn 0;\r\n}\r\nstatic int __devinit apbuart_probe(struct platform_device *op)\r\n{\r\nint i;\r\nstruct uart_port *port = NULL;\r\nfor (i = 0; i < grlib_apbuart_port_nr; i++) {\r\nif (op->dev.of_node == grlib_apbuart_nodes[i])\r\nbreak;\r\n}\r\nport = &grlib_apbuart_ports[i];\r\nport->dev = &op->dev;\r\nport->irq = op->archdata.irqs[0];\r\nuart_add_one_port(&grlib_apbuart_driver, (struct uart_port *) port);\r\napbuart_flush_fifo((struct uart_port *) port);\r\nprintk(KERN_INFO "grlib-apbuart at 0x%llx, irq %d\n",\r\n(unsigned long long) port->mapbase, port->irq);\r\nreturn 0;\r\n}\r\nstatic int __init grlib_apbuart_configure(void)\r\n{\r\nstruct device_node *np;\r\nint line = 0;\r\nfor_each_matching_node(np, apbuart_match) {\r\nconst int *ampopts;\r\nconst u32 *freq_hz;\r\nconst struct amba_prom_registers *regs;\r\nstruct uart_port *port;\r\nunsigned long addr;\r\nampopts = of_get_property(np, "ampopts", NULL);\r\nif (ampopts && (*ampopts == 0))\r\ncontinue;\r\nregs = of_get_property(np, "reg", NULL);\r\nfreq_hz = of_get_property(np, "freq", NULL);\r\nif (!regs || !freq_hz || (*freq_hz == 0))\r\ncontinue;\r\ngrlib_apbuart_nodes[line] = np;\r\naddr = regs->phys_addr;\r\nport = &grlib_apbuart_ports[line];\r\nport->mapbase = addr;\r\nport->membase = ioremap(addr, sizeof(struct grlib_apbuart_regs_map));\r\nport->irq = 0;\r\nport->iotype = UPIO_MEM;\r\nport->ops = &grlib_apbuart_ops;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->line = line;\r\nport->uartclk = *freq_hz;\r\nport->fifosize = apbuart_scan_fifo_size((struct uart_port *) port, line);\r\nline++;\r\nif (line == UART_NR)\r\nbreak;\r\n}\r\ngrlib_apbuart_driver.nr = grlib_apbuart_port_nr = line;\r\nreturn line ? 0 : -ENODEV;\r\n}\r\nstatic int __init grlib_apbuart_init(void)\r\n{\r\nint ret;\r\nret = grlib_apbuart_configure();\r\nif (ret)\r\nreturn ret;\r\nprintk(KERN_INFO "Serial: GRLIB APBUART driver\n");\r\nret = uart_register_driver(&grlib_apbuart_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: uart_register_driver failed (%i)\n",\r\n__FILE__, ret);\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&grlib_apbuart_of_driver);\r\nif (ret) {\r\nprintk(KERN_ERR\r\n"%s: platform_driver_register failed (%i)\n",\r\n__FILE__, ret);\r\nuart_unregister_driver(&grlib_apbuart_driver);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit grlib_apbuart_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < grlib_apbuart_port_nr; i++)\r\nuart_remove_one_port(&grlib_apbuart_driver,\r\n&grlib_apbuart_ports[i]);\r\nuart_unregister_driver(&grlib_apbuart_driver);\r\nplatform_driver_unregister(&grlib_apbuart_of_driver);\r\n}
