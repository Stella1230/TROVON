static void s3c_ac97_activate(struct snd_ac97 *ac97)\r\n{\r\nu32 ac_glbctrl, stat;\r\nstat = readl(s3c_ac97.regs + S3C_AC97_GLBSTAT) & 0x7;\r\nif (stat == S3C_AC97_GLBSTAT_MAINSTATE_ACTIVE)\r\nreturn;\r\nINIT_COMPLETION(s3c_ac97.done);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl = S3C_AC97_GLBCTRL_ACLINKON;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\nac_glbctrl |= S3C_AC97_GLBCTRL_TRANSFERDATAENABLE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl |= S3C_AC97_GLBCTRL_CODECREADYIE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (!wait_for_completion_timeout(&s3c_ac97.done, HZ))\r\npr_err("AC97: Unable to activate!");\r\n}\r\nstatic unsigned short s3c_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nu32 ac_glbctrl, ac_codec_cmd;\r\nu32 stat, addr, data;\r\nmutex_lock(&s3c_ac97.lock);\r\ns3c_ac97_activate(ac97);\r\nINIT_COMPLETION(s3c_ac97.done);\r\nac_codec_cmd = readl(s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nac_codec_cmd = S3C_AC97_CODEC_CMD_READ | AC_CMD_ADDR(reg);\r\nwritel(ac_codec_cmd, s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nudelay(50);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl |= S3C_AC97_GLBCTRL_CODECREADYIE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (!wait_for_completion_timeout(&s3c_ac97.done, HZ))\r\npr_err("AC97: Unable to read!");\r\nstat = readl(s3c_ac97.regs + S3C_AC97_STAT);\r\naddr = (stat >> 16) & 0x7f;\r\ndata = (stat & 0xffff);\r\nif (addr != reg)\r\npr_err("ac97: req addr = %02x, rep addr = %02x\n",\r\nreg, addr);\r\nmutex_unlock(&s3c_ac97.lock);\r\nreturn (unsigned short)data;\r\n}\r\nstatic void s3c_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nu32 ac_glbctrl, ac_codec_cmd;\r\nmutex_lock(&s3c_ac97.lock);\r\ns3c_ac97_activate(ac97);\r\nINIT_COMPLETION(s3c_ac97.done);\r\nac_codec_cmd = readl(s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nac_codec_cmd = AC_CMD_ADDR(reg) | AC_CMD_DATA(val);\r\nwritel(ac_codec_cmd, s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nudelay(50);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl |= S3C_AC97_GLBCTRL_CODECREADYIE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (!wait_for_completion_timeout(&s3c_ac97.done, HZ))\r\npr_err("AC97: Unable to write!");\r\nac_codec_cmd = readl(s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nac_codec_cmd |= S3C_AC97_CODEC_CMD_READ;\r\nwritel(ac_codec_cmd, s3c_ac97.regs + S3C_AC97_CODEC_CMD);\r\nmutex_unlock(&s3c_ac97.lock);\r\n}\r\nstatic void s3c_ac97_cold_reset(struct snd_ac97 *ac97)\r\n{\r\npr_debug("AC97: Cold reset\n");\r\nwritel(S3C_AC97_GLBCTRL_COLDRESET,\r\ns3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\nwritel(0, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\n}\r\nstatic void s3c_ac97_warm_reset(struct snd_ac97 *ac97)\r\n{\r\nu32 stat;\r\nstat = readl(s3c_ac97.regs + S3C_AC97_GLBSTAT) & 0x7;\r\nif (stat == S3C_AC97_GLBSTAT_MAINSTATE_ACTIVE)\r\nreturn;\r\npr_debug("AC97: Warm reset\n");\r\nwritel(S3C_AC97_GLBCTRL_WARMRESET, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\nwritel(0, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nmsleep(1);\r\ns3c_ac97_activate(ac97);\r\n}\r\nstatic irqreturn_t s3c_ac97_irq(int irq, void *dev_id)\r\n{\r\nu32 ac_glbctrl, ac_glbstat;\r\nac_glbstat = readl(s3c_ac97.regs + S3C_AC97_GLBSTAT);\r\nif (ac_glbstat & S3C_AC97_GLBSTAT_CODECREADY) {\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl &= ~S3C_AC97_GLBCTRL_CODECREADYIE;\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\ncomplete(&s3c_ac97.done);\r\n}\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl |= (1<<30);\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_ac97_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct s3c_dma_params *dma_data;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndma_data = &s3c_ac97_pcm_out;\r\nelse\r\ndma_data = &s3c_ac97_pcm_in;\r\nsnd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);\r\nreturn 0;\r\n}\r\nstatic int s3c_ac97_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nu32 ac_glbctrl;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct s3c_dma_params *dma_data =\r\nsnd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nac_glbctrl &= ~S3C_AC97_GLBCTRL_PCMINTM_MASK;\r\nelse\r\nac_glbctrl &= ~S3C_AC97_GLBCTRL_PCMOUTTM_MASK;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nac_glbctrl |= S3C_AC97_GLBCTRL_PCMINTM_DMA;\r\nelse\r\nac_glbctrl |= S3C_AC97_GLBCTRL_PCMOUTTM_DMA;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nbreak;\r\n}\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (!dma_data->ops)\r\ndma_data->ops = samsung_dma_get_ops();\r\ndma_data->ops->started(dma_data->channel);\r\nreturn 0;\r\n}\r\nstatic int s3c_ac97_hw_mic_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn -ENODEV;\r\nelse\r\nsnd_soc_dai_set_dma_data(cpu_dai, substream, &s3c_ac97_mic_in);\r\nreturn 0;\r\n}\r\nstatic int s3c_ac97_mic_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nu32 ac_glbctrl;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct s3c_dma_params *dma_data =\r\nsnd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nac_glbctrl = readl(s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nac_glbctrl &= ~S3C_AC97_GLBCTRL_MICINTM_MASK;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nac_glbctrl |= S3C_AC97_GLBCTRL_MICINTM_DMA;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nbreak;\r\n}\r\nwritel(ac_glbctrl, s3c_ac97.regs + S3C_AC97_GLBCTRL);\r\nif (!dma_data->ops)\r\ndma_data->ops = samsung_dma_get_ops();\r\ndma_data->ops->started(dma_data->channel);\r\nreturn 0;\r\n}\r\nstatic __devinit int s3c_ac97_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem_res, *dmatx_res, *dmarx_res, *dmamic_res, *irq_res;\r\nstruct s3c_audio_pdata *ac97_pdata;\r\nint ret;\r\nac97_pdata = pdev->dev.platform_data;\r\nif (!ac97_pdata || !ac97_pdata->cfg_gpio) {\r\ndev_err(&pdev->dev, "cfg_gpio callback not provided!\n");\r\nreturn -EINVAL;\r\n}\r\ndmatx_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!dmatx_res) {\r\ndev_err(&pdev->dev, "Unable to get AC97-TX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ndmarx_res = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!dmarx_res) {\r\ndev_err(&pdev->dev, "Unable to get AC97-RX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ndmamic_res = platform_get_resource(pdev, IORESOURCE_DMA, 2);\r\nif (!dmamic_res) {\r\ndev_err(&pdev->dev, "Unable to get AC97-MIC dma resource\n");\r\nreturn -ENXIO;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_res) {\r\ndev_err(&pdev->dev, "Unable to get register resource\n");\r\nreturn -ENXIO;\r\n}\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq_res) {\r\ndev_err(&pdev->dev, "AC97 IRQ not provided!\n");\r\nreturn -ENXIO;\r\n}\r\nif (!request_mem_region(mem_res->start,\r\nresource_size(mem_res), "ac97")) {\r\ndev_err(&pdev->dev, "Unable to request register region\n");\r\nreturn -EBUSY;\r\n}\r\ns3c_ac97_pcm_out.channel = dmatx_res->start;\r\ns3c_ac97_pcm_out.dma_addr = mem_res->start + S3C_AC97_PCM_DATA;\r\ns3c_ac97_pcm_in.channel = dmarx_res->start;\r\ns3c_ac97_pcm_in.dma_addr = mem_res->start + S3C_AC97_PCM_DATA;\r\ns3c_ac97_mic_in.channel = dmamic_res->start;\r\ns3c_ac97_mic_in.dma_addr = mem_res->start + S3C_AC97_MIC_DATA;\r\ninit_completion(&s3c_ac97.done);\r\nmutex_init(&s3c_ac97.lock);\r\ns3c_ac97.regs = ioremap(mem_res->start, resource_size(mem_res));\r\nif (s3c_ac97.regs == NULL) {\r\ndev_err(&pdev->dev, "Unable to ioremap register region\n");\r\nret = -ENXIO;\r\ngoto err1;\r\n}\r\ns3c_ac97.ac97_clk = clk_get(&pdev->dev, "ac97");\r\nif (IS_ERR(s3c_ac97.ac97_clk)) {\r\ndev_err(&pdev->dev, "ac97 failed to get ac97_clock\n");\r\nret = -ENODEV;\r\ngoto err2;\r\n}\r\nclk_enable(s3c_ac97.ac97_clk);\r\nif (ac97_pdata->cfg_gpio(pdev)) {\r\ndev_err(&pdev->dev, "Unable to configure gpio\n");\r\nret = -EINVAL;\r\ngoto err3;\r\n}\r\nret = request_irq(irq_res->start, s3c_ac97_irq,\r\n0, "AC97", NULL);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "ac97: interrupt request failed.\n");\r\ngoto err4;\r\n}\r\nret = snd_soc_register_dais(&pdev->dev, s3c_ac97_dai,\r\nARRAY_SIZE(s3c_ac97_dai));\r\nif (ret)\r\ngoto err5;\r\nreturn 0;\r\nerr5:\r\nfree_irq(irq_res->start, NULL);\r\nerr4:\r\nerr3:\r\nclk_disable(s3c_ac97.ac97_clk);\r\nclk_put(s3c_ac97.ac97_clk);\r\nerr2:\r\niounmap(s3c_ac97.regs);\r\nerr1:\r\nrelease_mem_region(mem_res->start, resource_size(mem_res));\r\nreturn ret;\r\n}\r\nstatic __devexit int s3c_ac97_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *mem_res, *irq_res;\r\nsnd_soc_unregister_dais(&pdev->dev, ARRAY_SIZE(s3c_ac97_dai));\r\nirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (irq_res)\r\nfree_irq(irq_res->start, NULL);\r\nclk_disable(s3c_ac97.ac97_clk);\r\nclk_put(s3c_ac97.ac97_clk);\r\niounmap(s3c_ac97.regs);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (mem_res)\r\nrelease_mem_region(mem_res->start, resource_size(mem_res));\r\nreturn 0;\r\n}
