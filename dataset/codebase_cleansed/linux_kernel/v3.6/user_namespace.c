int create_user_ns(struct cred *new)\r\n{\r\nstruct user_namespace *ns, *parent_ns = new->user_ns;\r\nkuid_t owner = new->euid;\r\nkgid_t group = new->egid;\r\nif (!kuid_has_mapping(parent_ns, owner) ||\r\n!kgid_has_mapping(parent_ns, group))\r\nreturn -EPERM;\r\nns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\r\nif (!ns)\r\nreturn -ENOMEM;\r\nkref_init(&ns->kref);\r\nns->parent = parent_ns;\r\nns->owner = owner;\r\nns->group = group;\r\nnew->securebits = SECUREBITS_DEFAULT;\r\nnew->cap_inheritable = CAP_EMPTY_SET;\r\nnew->cap_permitted = CAP_FULL_SET;\r\nnew->cap_effective = CAP_FULL_SET;\r\nnew->cap_bset = CAP_FULL_SET;\r\n#ifdef CONFIG_KEYS\r\nkey_put(new->request_key_auth);\r\nnew->request_key_auth = NULL;\r\n#endif\r\nnew->user_ns = ns;\r\nreturn 0;\r\n}\r\nvoid free_user_ns(struct kref *kref)\r\n{\r\nstruct user_namespace *parent, *ns =\r\ncontainer_of(kref, struct user_namespace, kref);\r\nparent = ns->parent;\r\nkmem_cache_free(user_ns_cachep, ns);\r\nput_user_ns(parent);\r\n}\r\nstatic u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last, id2;\r\nid2 = id + count - 1;\r\nextents = map->nr_extents;\r\nsmp_read_barrier_depends();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last &&\r\n(id2 >= first && id2 <= last))\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].lower_first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nstatic u32 map_id_down(struct uid_gid_map *map, u32 id)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last;\r\nextents = map->nr_extents;\r\nsmp_read_barrier_depends();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last)\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].lower_first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nstatic u32 map_id_up(struct uid_gid_map *map, u32 id)\r\n{\r\nunsigned idx, extents;\r\nu32 first, last;\r\nextents = map->nr_extents;\r\nsmp_read_barrier_depends();\r\nfor (idx = 0; idx < extents; idx++) {\r\nfirst = map->extent[idx].lower_first;\r\nlast = first + map->extent[idx].count - 1;\r\nif (id >= first && id <= last)\r\nbreak;\r\n}\r\nif (idx < extents)\r\nid = (id - first) + map->extent[idx].first;\r\nelse\r\nid = (u32) -1;\r\nreturn id;\r\n}\r\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\r\n{\r\nreturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\r\n}\r\nuid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\r\n{\r\nreturn map_id_up(&targ->uid_map, __kuid_val(kuid));\r\n}\r\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\r\n{\r\nuid_t uid;\r\nuid = from_kuid(targ, kuid);\r\nif (uid == (uid_t) -1)\r\nuid = overflowuid;\r\nreturn uid;\r\n}\r\nkgid_t make_kgid(struct user_namespace *ns, gid_t gid)\r\n{\r\nreturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\r\n}\r\ngid_t from_kgid(struct user_namespace *targ, kgid_t kgid)\r\n{\r\nreturn map_id_up(&targ->gid_map, __kgid_val(kgid));\r\n}\r\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\r\n{\r\ngid_t gid;\r\ngid = from_kgid(targ, kgid);\r\nif (gid == (gid_t) -1)\r\ngid = overflowgid;\r\nreturn gid;\r\n}\r\nstatic int uid_m_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_extent *extent = v;\r\nstruct user_namespace *lower_ns;\r\nuid_t lower;\r\nlower_ns = current_user_ns();\r\nif ((lower_ns == ns) && lower_ns->parent)\r\nlower_ns = lower_ns->parent;\r\nlower = from_kuid(lower_ns, KUIDT_INIT(extent->lower_first));\r\nseq_printf(seq, "%10u %10u %10u\n",\r\nextent->first,\r\nlower,\r\nextent->count);\r\nreturn 0;\r\n}\r\nstatic int gid_m_show(struct seq_file *seq, void *v)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_extent *extent = v;\r\nstruct user_namespace *lower_ns;\r\ngid_t lower;\r\nlower_ns = current_user_ns();\r\nif ((lower_ns == ns) && lower_ns->parent)\r\nlower_ns = lower_ns->parent;\r\nlower = from_kgid(lower_ns, KGIDT_INIT(extent->lower_first));\r\nseq_printf(seq, "%10u %10u %10u\n",\r\nextent->first,\r\nlower,\r\nextent->count);\r\nreturn 0;\r\n}\r\nstatic void *m_start(struct seq_file *seq, loff_t *ppos, struct uid_gid_map *map)\r\n{\r\nstruct uid_gid_extent *extent = NULL;\r\nloff_t pos = *ppos;\r\nif (pos < map->nr_extents)\r\nextent = &map->extent[pos];\r\nreturn extent;\r\n}\r\nstatic void *uid_m_start(struct seq_file *seq, loff_t *ppos)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nreturn m_start(seq, ppos, &ns->uid_map);\r\n}\r\nstatic void *gid_m_start(struct seq_file *seq, loff_t *ppos)\r\n{\r\nstruct user_namespace *ns = seq->private;\r\nreturn m_start(seq, ppos, &ns->gid_map);\r\n}\r\nstatic void *m_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn seq->op->start(seq, pos);\r\n}\r\nstatic void m_stop(struct seq_file *seq, void *v)\r\n{\r\nreturn;\r\n}\r\nstatic ssize_t map_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos,\r\nint cap_setid,\r\nstruct uid_gid_map *map,\r\nstruct uid_gid_map *parent_map)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nstruct uid_gid_map new_map;\r\nunsigned idx;\r\nstruct uid_gid_extent *extent, *last = NULL;\r\nunsigned long page = 0;\r\nchar *kbuf, *pos, *next_line;\r\nssize_t ret = -EINVAL;\r\nmutex_lock(&id_map_mutex);\r\nret = -EPERM;\r\nif (map->nr_extents != 0)\r\ngoto out;\r\nif (!ns_capable(ns, cap_setid))\r\ngoto out;\r\nret = -ENOMEM;\r\npage = __get_free_page(GFP_TEMPORARY);\r\nkbuf = (char *) page;\r\nif (!page)\r\ngoto out;\r\nret = -EINVAL;\r\nif ((*ppos != 0) || (count >= PAGE_SIZE))\r\ngoto out;\r\nret = -EFAULT;\r\nif (copy_from_user(kbuf, buf, count))\r\ngoto out;\r\nkbuf[count] = '\0';\r\nret = -EINVAL;\r\npos = kbuf;\r\nnew_map.nr_extents = 0;\r\nfor (;pos; pos = next_line) {\r\nextent = &new_map.extent[new_map.nr_extents];\r\nnext_line = strchr(pos, '\n');\r\nif (next_line) {\r\n*next_line = '\0';\r\nnext_line++;\r\nif (*next_line == '\0')\r\nnext_line = NULL;\r\n}\r\npos = skip_spaces(pos);\r\nextent->first = simple_strtoul(pos, &pos, 10);\r\nif (!isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nextent->lower_first = simple_strtoul(pos, &pos, 10);\r\nif (!isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nextent->count = simple_strtoul(pos, &pos, 10);\r\nif (*pos && !isspace(*pos))\r\ngoto out;\r\npos = skip_spaces(pos);\r\nif (*pos != '\0')\r\ngoto out;\r\nif ((extent->first == (u32) -1) ||\r\n(extent->lower_first == (u32) -1 ))\r\ngoto out;\r\nif ((extent->first + extent->count) <= extent->first)\r\ngoto out;\r\nif ((extent->lower_first + extent->count) <= extent->lower_first)\r\ngoto out;\r\nif (last &&\r\n(((last->first + last->count) > extent->first) ||\r\n((last->lower_first + last->count) > extent->lower_first)))\r\ngoto out;\r\nnew_map.nr_extents++;\r\nlast = extent;\r\nif ((new_map.nr_extents == UID_GID_MAP_MAX_EXTENTS) &&\r\n(next_line != NULL))\r\ngoto out;\r\n}\r\nif (new_map.nr_extents == 0)\r\ngoto out;\r\nret = -EPERM;\r\nif (!new_idmap_permitted(ns, cap_setid, &new_map))\r\ngoto out;\r\nfor (idx = 0; idx < new_map.nr_extents; idx++) {\r\nu32 lower_first;\r\nextent = &new_map.extent[idx];\r\nlower_first = map_id_range_down(parent_map,\r\nextent->lower_first,\r\nextent->count);\r\nif (lower_first == (u32) -1)\r\ngoto out;\r\nextent->lower_first = lower_first;\r\n}\r\nmemcpy(map->extent, new_map.extent,\r\nnew_map.nr_extents*sizeof(new_map.extent[0]));\r\nsmp_wmb();\r\nmap->nr_extents = new_map.nr_extents;\r\n*ppos = count;\r\nret = count;\r\nout:\r\nmutex_unlock(&id_map_mutex);\r\nif (page)\r\nfree_page(page);\r\nreturn ret;\r\n}\r\nssize_t proc_uid_map_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nif (!ns->parent)\r\nreturn -EPERM;\r\nreturn map_write(file, buf, size, ppos, CAP_SETUID,\r\n&ns->uid_map, &ns->parent->uid_map);\r\n}\r\nssize_t proc_gid_map_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct user_namespace *ns = seq->private;\r\nif (!ns->parent)\r\nreturn -EPERM;\r\nreturn map_write(file, buf, size, ppos, CAP_SETGID,\r\n&ns->gid_map, &ns->parent->gid_map);\r\n}\r\nstatic bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\r\nstruct uid_gid_map *new_map)\r\n{\r\nif (ns_capable(ns->parent, cap_setid))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic __init int user_namespaces_init(void)\r\n{\r\nuser_ns_cachep = KMEM_CACHE(user_namespace, SLAB_PANIC);\r\nreturn 0;\r\n}
