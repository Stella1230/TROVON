static void mvs_94xx_detect_porttype(struct mvs_info *mvi, int i)\r\n{\r\nu32 reg;\r\nstruct mvs_phy *phy = &mvi->phy[i];\r\nu32 phy_status;\r\nmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE3);\r\nreg = mvs_read_port_vsr_data(mvi, i);\r\nphy_status = ((reg & 0x3f0000) >> 16) & 0xff;\r\nphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\r\nswitch (phy_status) {\r\ncase 0x10:\r\nphy->phy_type |= PORT_TYPE_SAS;\r\nbreak;\r\ncase 0x1d:\r\ndefault:\r\nphy->phy_type |= PORT_TYPE_SATA;\r\nbreak;\r\n}\r\n}\r\nvoid set_phy_tuning(struct mvs_info *mvi, int phy_id,\r\nstruct phy_tuning phy_tuning)\r\n{\r\nu32 tmp, setting_0 = 0, setting_1 = 0;\r\nu8 i;\r\nif (mvi->pdev->revision == VANIR_A0_REV)\r\nreturn;\r\nfor (i = 0; i < 3; i++) {\r\nswitch (i) {\r\ncase 0:\r\nsetting_0 = GENERATION_1_SETTING;\r\nsetting_1 = GENERATION_1_2_SETTING;\r\nbreak;\r\ncase 1:\r\nsetting_0 = GENERATION_1_2_SETTING;\r\nsetting_1 = GENERATION_2_3_SETTING;\r\nbreak;\r\ncase 2:\r\nsetting_0 = GENERATION_2_3_SETTING;\r\nsetting_1 = GENERATION_3_4_SETTING;\r\nbreak;\r\n}\r\nmvs_write_port_vsr_addr(mvi, phy_id, setting_0);\r\ntmp = mvs_read_port_vsr_data(mvi, phy_id);\r\ntmp &= ~(0xFBE << 16);\r\ntmp |= (((phy_tuning.trans_emp_en << 11) |\r\n(phy_tuning.trans_emp_amp << 7) |\r\n(phy_tuning.trans_amp << 1)) << 16);\r\nmvs_write_port_vsr_data(mvi, phy_id, tmp);\r\nmvs_write_port_vsr_addr(mvi, phy_id, setting_1);\r\ntmp = mvs_read_port_vsr_data(mvi, phy_id);\r\ntmp &= ~(0xC000);\r\ntmp |= (phy_tuning.trans_amp_adj << 14);\r\nmvs_write_port_vsr_data(mvi, phy_id, tmp);\r\n}\r\n}\r\nvoid set_phy_ffe_tuning(struct mvs_info *mvi, int phy_id,\r\nstruct ffe_control ffe)\r\n{\r\nu32 tmp;\r\nif ((mvi->pdev->revision == VANIR_A0_REV)\r\n|| (mvi->pdev->revision == VANIR_B0_REV))\r\nreturn;\r\nmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_FFE_CONTROL);\r\ntmp = mvs_read_port_vsr_data(mvi, phy_id);\r\ntmp &= ~0xFF;\r\ntmp |= ((0x1 << 7) |\r\n(ffe.ffe_rss_sel << 4) |\r\n(ffe.ffe_cap_sel << 0));\r\nmvs_write_port_vsr_data(mvi, phy_id, tmp);\r\nmvs_write_port_vsr_addr(mvi, phy_id, VSR_REF_CLOCK_CRTL);\r\ntmp = mvs_read_port_vsr_data(mvi, phy_id);\r\ntmp &= ~0x40001;\r\ntmp |= (0 << 18);\r\nmvs_write_port_vsr_data(mvi, phy_id, tmp);\r\nmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_DFE_UPDATE_CRTL);\r\ntmp = mvs_read_port_vsr_data(mvi, phy_id);\r\ntmp &= ~0xFFF;\r\ntmp |= ((0x3F << 6) | (0x0 << 0));\r\nmvs_write_port_vsr_data(mvi, phy_id, tmp);\r\nmvs_write_port_vsr_addr(mvi, phy_id, VSR_REF_CLOCK_CRTL);\r\ntmp = mvs_read_port_vsr_data(mvi, phy_id);\r\ntmp &= ~0x8;\r\ntmp |= (0 << 3);\r\nmvs_write_port_vsr_data(mvi, phy_id, tmp);\r\n}\r\nvoid set_phy_rate(struct mvs_info *mvi, int phy_id, u8 rate)\r\n{\r\nunion reg_phy_cfg phy_cfg, phy_cfg_tmp;\r\nmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_MODE2);\r\nphy_cfg_tmp.v = mvs_read_port_vsr_data(mvi, phy_id);\r\nphy_cfg.v = 0;\r\nphy_cfg.u.disable_phy = phy_cfg_tmp.u.disable_phy;\r\nphy_cfg.u.sas_support = 1;\r\nphy_cfg.u.sata_support = 1;\r\nphy_cfg.u.sata_host_mode = 1;\r\nswitch (rate) {\r\ncase 0x0:\r\nphy_cfg.u.speed_support = 1;\r\nphy_cfg.u.snw_3_support = 0;\r\nphy_cfg.u.tx_lnk_parity = 1;\r\nphy_cfg.u.tx_spt_phs_lnk_rate = 0x30;\r\nbreak;\r\ncase 0x1:\r\nphy_cfg.u.speed_support = 3;\r\nphy_cfg.u.tx_spt_phs_lnk_rate = 0x3c;\r\nphy_cfg.u.tx_lgcl_lnk_rate = 0x08;\r\nbreak;\r\ncase 0x2:\r\ndefault:\r\nphy_cfg.u.speed_support = 7;\r\nphy_cfg.u.snw_3_support = 1;\r\nphy_cfg.u.tx_lnk_parity = 1;\r\nphy_cfg.u.tx_spt_phs_lnk_rate = 0x3f;\r\nphy_cfg.u.tx_lgcl_lnk_rate = 0x09;\r\nbreak;\r\n}\r\nmvs_write_port_vsr_data(mvi, phy_id, phy_cfg.v);\r\n}\r\nstatic void __devinit\r\nmvs_94xx_config_reg_from_hba(struct mvs_info *mvi, int phy_id)\r\n{\r\nu32 temp;\r\ntemp = (u32)(*(u32 *)&mvi->hba_info_param.phy_tuning[phy_id]);\r\nif (temp == 0xFFFFFFFFL) {\r\nmvi->hba_info_param.phy_tuning[phy_id].trans_emp_amp = 0x6;\r\nmvi->hba_info_param.phy_tuning[phy_id].trans_amp = 0x1A;\r\nmvi->hba_info_param.phy_tuning[phy_id].trans_amp_adj = 0x3;\r\n}\r\ntemp = (u8)(*(u8 *)&mvi->hba_info_param.ffe_ctl[phy_id]);\r\nif (temp == 0xFFL) {\r\nswitch (mvi->pdev->revision) {\r\ncase VANIR_A0_REV:\r\ncase VANIR_B0_REV:\r\nmvi->hba_info_param.ffe_ctl[phy_id].ffe_rss_sel = 0x7;\r\nmvi->hba_info_param.ffe_ctl[phy_id].ffe_cap_sel = 0x7;\r\nbreak;\r\ncase VANIR_C0_REV:\r\ncase VANIR_C1_REV:\r\ncase VANIR_C2_REV:\r\ndefault:\r\nmvi->hba_info_param.ffe_ctl[phy_id].ffe_rss_sel = 0x7;\r\nmvi->hba_info_param.ffe_ctl[phy_id].ffe_cap_sel = 0xC;\r\nbreak;\r\n}\r\n}\r\ntemp = (u8)(*(u8 *)&mvi->hba_info_param.phy_rate[phy_id]);\r\nif (temp == 0xFFL)\r\nmvi->hba_info_param.phy_rate[phy_id] = 0x2;\r\nset_phy_tuning(mvi, phy_id,\r\nmvi->hba_info_param.phy_tuning[phy_id]);\r\nset_phy_ffe_tuning(mvi, phy_id,\r\nmvi->hba_info_param.ffe_ctl[phy_id]);\r\nset_phy_rate(mvi, phy_id,\r\nmvi->hba_info_param.phy_rate[phy_id]);\r\n}\r\nstatic void __devinit mvs_94xx_enable_xmt(struct mvs_info *mvi, int phy_id)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\ntmp = mr32(MVS_PCS);\r\ntmp |= 1 << (phy_id + PCS_EN_PORT_XMT_SHIFT2);\r\nmw32(MVS_PCS, tmp);\r\n}\r\nstatic void mvs_94xx_phy_reset(struct mvs_info *mvi, u32 phy_id, int hard)\r\n{\r\nu32 tmp;\r\nu32 delay = 5000;\r\nif (hard == MVS_PHY_TUNE) {\r\nmvs_write_port_cfg_addr(mvi, phy_id, PHYR_SATA_CTL);\r\ntmp = mvs_read_port_cfg_data(mvi, phy_id);\r\nmvs_write_port_cfg_data(mvi, phy_id, tmp|0x20000000);\r\nmvs_write_port_cfg_data(mvi, phy_id, tmp|0x100000);\r\nreturn;\r\n}\r\ntmp = mvs_read_port_irq_stat(mvi, phy_id);\r\ntmp &= ~PHYEV_RDY_CH;\r\nmvs_write_port_irq_stat(mvi, phy_id, tmp);\r\nif (hard) {\r\ntmp = mvs_read_phy_ctl(mvi, phy_id);\r\ntmp |= PHY_RST_HARD;\r\nmvs_write_phy_ctl(mvi, phy_id, tmp);\r\ndo {\r\ntmp = mvs_read_phy_ctl(mvi, phy_id);\r\nudelay(10);\r\ndelay--;\r\n} while ((tmp & PHY_RST_HARD) && delay);\r\nif (!delay)\r\nmv_dprintk("phy hard reset failed.\n");\r\n} else {\r\ntmp = mvs_read_phy_ctl(mvi, phy_id);\r\ntmp |= PHY_RST;\r\nmvs_write_phy_ctl(mvi, phy_id, tmp);\r\n}\r\n}\r\nstatic void mvs_94xx_phy_disable(struct mvs_info *mvi, u32 phy_id)\r\n{\r\nu32 tmp;\r\nmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_MODE2);\r\ntmp = mvs_read_port_vsr_data(mvi, phy_id);\r\nmvs_write_port_vsr_data(mvi, phy_id, tmp | 0x00800000);\r\n}\r\nstatic void mvs_94xx_phy_enable(struct mvs_info *mvi, u32 phy_id)\r\n{\r\nu32 tmp;\r\nu8 revision = 0;\r\nrevision = mvi->pdev->revision;\r\nif (revision == VANIR_A0_REV) {\r\nmvs_write_port_vsr_addr(mvi, phy_id, CMD_HOST_RD_DATA);\r\nmvs_write_port_vsr_data(mvi, phy_id, 0x8300ffc1);\r\n}\r\nif (revision == VANIR_B0_REV) {\r\nmvs_write_port_vsr_addr(mvi, phy_id, CMD_APP_MEM_CTL);\r\nmvs_write_port_vsr_data(mvi, phy_id, 0x08001006);\r\nmvs_write_port_vsr_addr(mvi, phy_id, CMD_HOST_RD_DATA);\r\nmvs_write_port_vsr_data(mvi, phy_id, 0x0000705f);\r\n}\r\nmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_MODE2);\r\ntmp = mvs_read_port_vsr_data(mvi, phy_id);\r\ntmp |= bit(0);\r\nmvs_write_port_vsr_data(mvi, phy_id, tmp & 0xfd7fffff);\r\n}\r\nstatic int __devinit mvs_94xx_init(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nint i;\r\nu32 tmp, cctl;\r\nu8 revision;\r\nrevision = mvi->pdev->revision;\r\nmvs_show_pcie_usage(mvi);\r\nif (mvi->flags & MVF_FLAG_SOC) {\r\ntmp = mr32(MVS_PHY_CTL);\r\ntmp &= ~PCTL_PWR_OFF;\r\ntmp |= PCTL_PHY_DSBL;\r\nmw32(MVS_PHY_CTL, tmp);\r\n}\r\ncctl = mr32(MVS_CTL) & 0xFFFF;\r\nif (cctl & CCTL_RST)\r\ncctl &= ~CCTL_RST;\r\nelse\r\nmw32_f(MVS_CTL, cctl | CCTL_RST);\r\nif (mvi->flags & MVF_FLAG_SOC) {\r\ntmp = mr32(MVS_PHY_CTL);\r\ntmp &= ~PCTL_PWR_OFF;\r\ntmp |= PCTL_COM_ON;\r\ntmp &= ~PCTL_PHY_DSBL;\r\ntmp |= PCTL_LINK_RST;\r\nmw32(MVS_PHY_CTL, tmp);\r\nmsleep(100);\r\ntmp &= ~PCTL_LINK_RST;\r\nmw32(MVS_PHY_CTL, tmp);\r\nmsleep(100);\r\n}\r\nmw32(MVS_PORTS_IMP, 0xFF);\r\nif (revision == VANIR_A0_REV) {\r\nmw32(MVS_PA_VSR_ADDR, CMD_CMWK_OOB_DET);\r\nmw32(MVS_PA_VSR_PORT, 0x00018080);\r\n}\r\nmw32(MVS_PA_VSR_ADDR, VSR_PHY_MODE2);\r\nif (revision == VANIR_A0_REV || revision == VANIR_B0_REV)\r\nmw32(MVS_PA_VSR_PORT, 0x0084d4fe);\r\nelse\r\nmw32(MVS_PA_VSR_PORT, 0x0084fffe);\r\nif (revision == VANIR_B0_REV) {\r\nmw32(MVS_PA_VSR_ADDR, CMD_APP_MEM_CTL);\r\nmw32(MVS_PA_VSR_PORT, 0x08001006);\r\nmw32(MVS_PA_VSR_ADDR, CMD_HOST_RD_DATA);\r\nmw32(MVS_PA_VSR_PORT, 0x0000705f);\r\n}\r\nmw32(MVS_PCS, 0);\r\nmw32(MVS_STP_REG_SET_0, 0);\r\nmw32(MVS_STP_REG_SET_1, 0);\r\nmvs_phy_hacks(mvi);\r\ntmp = mvs_cr32(mvi, CMD_SAS_CTL1);\r\nif ((revision == VANIR_A0_REV) ||\r\n(revision == VANIR_B0_REV) ||\r\n(revision == VANIR_C0_REV)) {\r\ntmp &= ~0xffff;\r\ntmp |= 0x007f;\r\nmvs_cw32(mvi, CMD_SAS_CTL1, tmp);\r\n}\r\nmw32(MVS_PA_VSR_ADDR, VSR_PHY_ACT_LED);\r\ntmp = mr32(MVS_PA_VSR_PORT);\r\ntmp &= 0xFFFF00FF;\r\ntmp |= 0x00003300;\r\nmw32(MVS_PA_VSR_PORT, tmp);\r\nmw32(MVS_CMD_LIST_LO, mvi->slot_dma);\r\nmw32(MVS_CMD_LIST_HI, (mvi->slot_dma >> 16) >> 16);\r\nmw32(MVS_RX_FIS_LO, mvi->rx_fis_dma);\r\nmw32(MVS_RX_FIS_HI, (mvi->rx_fis_dma >> 16) >> 16);\r\nmw32(MVS_TX_CFG, MVS_CHIP_SLOT_SZ);\r\nmw32(MVS_TX_LO, mvi->tx_dma);\r\nmw32(MVS_TX_HI, (mvi->tx_dma >> 16) >> 16);\r\nmw32(MVS_RX_CFG, MVS_RX_RING_SZ);\r\nmw32(MVS_RX_LO, mvi->rx_dma);\r\nmw32(MVS_RX_HI, (mvi->rx_dma >> 16) >> 16);\r\nfor (i = 0; i < mvi->chip->n_phy; i++) {\r\nmvs_94xx_phy_disable(mvi, i);\r\nmvs_set_sas_addr(mvi, i, CONFIG_ID_FRAME3, CONFIG_ID_FRAME4,\r\ncpu_to_le64(mvi->phy[i].dev_sas_addr));\r\nmvs_94xx_enable_xmt(mvi, i);\r\nmvs_94xx_config_reg_from_hba(mvi, i);\r\nmvs_94xx_phy_enable(mvi, i);\r\nmvs_94xx_phy_reset(mvi, i, PHY_RST_HARD);\r\nmsleep(500);\r\nmvs_94xx_detect_porttype(mvi, i);\r\n}\r\nif (mvi->flags & MVF_FLAG_SOC) {\r\nwritel(0x0E008000, regs + 0x000);\r\nwritel(0x59000008, regs + 0x004);\r\nwritel(0x20, regs + 0x008);\r\nwritel(0x20, regs + 0x00c);\r\nwritel(0x20, regs + 0x010);\r\nwritel(0x20, regs + 0x014);\r\nwritel(0x20, regs + 0x018);\r\nwritel(0x20, regs + 0x01c);\r\n}\r\nfor (i = 0; i < mvi->chip->n_phy; i++) {\r\ntmp = mvs_read_port_irq_stat(mvi, i);\r\ntmp &= ~PHYEV_SIG_FIS;\r\nmvs_write_port_irq_stat(mvi, i, tmp);\r\ntmp = PHYEV_RDY_CH | PHYEV_BROAD_CH |\r\nPHYEV_ID_DONE | PHYEV_DCDR_ERR | PHYEV_CRC_ERR ;\r\nmvs_write_port_irq_mask(mvi, i, tmp);\r\nmsleep(100);\r\nmvs_update_phyinfo(mvi, i, 1);\r\n}\r\ncctl = mr32(MVS_CTL);\r\ncctl |= CCTL_ENDIAN_CMD;\r\ncctl &= ~CCTL_ENDIAN_OPEN;\r\ncctl |= CCTL_ENDIAN_RSP;\r\nmw32_f(MVS_CTL, cctl);\r\ntmp = mr32(MVS_PCS);\r\ntmp |= PCS_CMD_RST;\r\ntmp &= ~PCS_SELF_CLEAR;\r\nmw32(MVS_PCS, tmp);\r\ntmp = 0;\r\nif (MVS_CHIP_SLOT_SZ > 0x1ff)\r\nmw32(MVS_INT_COAL, 0x1ff | COAL_EN);\r\nelse\r\nmw32(MVS_INT_COAL, MVS_CHIP_SLOT_SZ | COAL_EN);\r\ntmp = 0x10000 | interrupt_coalescing;\r\nmw32(MVS_INT_COAL_TMOUT, tmp);\r\nmw32(MVS_TX_CFG, 0);\r\nmw32(MVS_TX_CFG, MVS_CHIP_SLOT_SZ | TX_EN);\r\nmw32(MVS_RX_CFG, MVS_RX_RING_SZ | RX_EN);\r\nmw32(MVS_PCS, PCS_SATA_RETRY_2 | PCS_FIS_RX_EN |\r\nPCS_CMD_EN | PCS_CMD_STOP_ERR);\r\ntmp = (CINT_PORT_MASK | CINT_DONE | CINT_MEM | CINT_SRS | CINT_CI_STOP |\r\nCINT_DMA_PCIE | CINT_NON_SPEC_NCQ_ERROR);\r\ntmp |= CINT_PHY_MASK;\r\nmw32(MVS_INT_MASK, tmp);\r\ntmp = mvs_cr32(mvi, CMD_LINK_TIMER);\r\ntmp |= 0xFFFF0000;\r\nmvs_cw32(mvi, CMD_LINK_TIMER, tmp);\r\ntmp = 0x003F003F;\r\nmvs_cw32(mvi, CMD_PL_TIMER, tmp);\r\ntmp = mvs_cr32(mvi, CMD_PORT_LAYER_TIMER1);\r\ntmp |= 0xFFFF007F;\r\nmvs_cw32(mvi, CMD_PORT_LAYER_TIMER1, tmp);\r\ntmp = mvs_cr32(mvi, CMD_SL_MODE0);\r\ntmp |= 0x00000300;\r\ntmp &= 0xFFFFFFFE;\r\nmvs_cw32(mvi, CMD_SL_MODE0, tmp);\r\nmw32(MVS_INT_MASK_SRS_0, 0xFFFF);\r\nreturn 0;\r\n}\r\nstatic int mvs_94xx_ioremap(struct mvs_info *mvi)\r\n{\r\nif (!mvs_ioremap(mvi, 2, -1)) {\r\nmvi->regs_ex = mvi->regs + 0x10200;\r\nmvi->regs += 0x20000;\r\nif (mvi->id == 1)\r\nmvi->regs += 0x4000;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic void mvs_94xx_iounmap(struct mvs_info *mvi)\r\n{\r\nif (mvi->regs) {\r\nmvi->regs -= 0x20000;\r\nif (mvi->id == 1)\r\nmvi->regs -= 0x4000;\r\nmvs_iounmap(mvi->regs);\r\n}\r\n}\r\nstatic void mvs_94xx_interrupt_enable(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex;\r\nu32 tmp;\r\ntmp = mr32(MVS_GBL_CTL);\r\ntmp |= (IRQ_SAS_A | IRQ_SAS_B);\r\nmw32(MVS_GBL_INT_STAT, tmp);\r\nwritel(tmp, regs + 0x0C);\r\nwritel(tmp, regs + 0x10);\r\nwritel(tmp, regs + 0x14);\r\nwritel(tmp, regs + 0x18);\r\nmw32(MVS_GBL_CTL, tmp);\r\n}\r\nstatic void mvs_94xx_interrupt_disable(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex;\r\nu32 tmp;\r\ntmp = mr32(MVS_GBL_CTL);\r\ntmp &= ~(IRQ_SAS_A | IRQ_SAS_B);\r\nmw32(MVS_GBL_INT_STAT, tmp);\r\nwritel(tmp, regs + 0x0C);\r\nwritel(tmp, regs + 0x10);\r\nwritel(tmp, regs + 0x14);\r\nwritel(tmp, regs + 0x18);\r\nmw32(MVS_GBL_CTL, tmp);\r\n}\r\nstatic u32 mvs_94xx_isr_status(struct mvs_info *mvi, int irq)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex;\r\nu32 stat = 0;\r\nif (!(mvi->flags & MVF_FLAG_SOC)) {\r\nstat = mr32(MVS_GBL_INT_STAT);\r\nif (!(stat & (IRQ_SAS_A | IRQ_SAS_B)))\r\nreturn 0;\r\n}\r\nreturn stat;\r\n}\r\nstatic irqreturn_t mvs_94xx_isr(struct mvs_info *mvi, int irq, u32 stat)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nif (((stat & IRQ_SAS_A) && mvi->id == 0) ||\r\n((stat & IRQ_SAS_B) && mvi->id == 1)) {\r\nmw32_f(MVS_INT_STAT, CINT_DONE);\r\nspin_lock(&mvi->lock);\r\nmvs_int_full(mvi);\r\nspin_unlock(&mvi->lock);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mvs_94xx_command_active(struct mvs_info *mvi, u32 slot_idx)\r\n{\r\nu32 tmp;\r\ntmp = mvs_cr32(mvi, MVS_COMMAND_ACTIVE+(slot_idx >> 3));\r\nif (tmp && 1 << (slot_idx % 32)) {\r\nmv_printk("command active %08X, slot [%x].\n", tmp, slot_idx);\r\nmvs_cw32(mvi, MVS_COMMAND_ACTIVE + (slot_idx >> 3),\r\n1 << (slot_idx % 32));\r\ndo {\r\ntmp = mvs_cr32(mvi,\r\nMVS_COMMAND_ACTIVE + (slot_idx >> 3));\r\n} while (tmp & 1 << (slot_idx % 32));\r\n}\r\n}\r\nvoid mvs_94xx_clear_srs_irq(struct mvs_info *mvi, u8 reg_set, u8 clear_all)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\nif (clear_all) {\r\ntmp = mr32(MVS_INT_STAT_SRS_0);\r\nif (tmp) {\r\nmv_dprintk("check SRS 0 %08X.\n", tmp);\r\nmw32(MVS_INT_STAT_SRS_0, tmp);\r\n}\r\ntmp = mr32(MVS_INT_STAT_SRS_1);\r\nif (tmp) {\r\nmv_dprintk("check SRS 1 %08X.\n", tmp);\r\nmw32(MVS_INT_STAT_SRS_1, tmp);\r\n}\r\n} else {\r\nif (reg_set > 31)\r\ntmp = mr32(MVS_INT_STAT_SRS_1);\r\nelse\r\ntmp = mr32(MVS_INT_STAT_SRS_0);\r\nif (tmp & (1 << (reg_set % 32))) {\r\nmv_dprintk("register set 0x%x was stopped.\n", reg_set);\r\nif (reg_set > 31)\r\nmw32(MVS_INT_STAT_SRS_1, 1 << (reg_set % 32));\r\nelse\r\nmw32(MVS_INT_STAT_SRS_0, 1 << (reg_set % 32));\r\n}\r\n}\r\n}\r\nstatic void mvs_94xx_issue_stop(struct mvs_info *mvi, enum mvs_port_type type,\r\nu32 tfs)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp;\r\nmvs_94xx_clear_srs_irq(mvi, 0, 1);\r\ntmp = mr32(MVS_INT_STAT);\r\nmw32(MVS_INT_STAT, tmp | CINT_CI_STOP);\r\ntmp = mr32(MVS_PCS) | 0xFF00;\r\nmw32(MVS_PCS, tmp);\r\n}\r\nstatic void mvs_94xx_non_spec_ncq_error(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 err_0, err_1;\r\nu8 i;\r\nstruct mvs_device *device;\r\nerr_0 = mr32(MVS_NON_NCQ_ERR_0);\r\nerr_1 = mr32(MVS_NON_NCQ_ERR_1);\r\nmv_dprintk("non specific ncq error err_0:%x,err_1:%x.\n",\r\nerr_0, err_1);\r\nfor (i = 0; i < 32; i++) {\r\nif (err_0 & bit(i)) {\r\ndevice = mvs_find_dev_by_reg_set(mvi, i);\r\nif (device)\r\nmvs_release_task(mvi, device->sas_device);\r\n}\r\nif (err_1 & bit(i)) {\r\ndevice = mvs_find_dev_by_reg_set(mvi, i+32);\r\nif (device)\r\nmvs_release_task(mvi, device->sas_device);\r\n}\r\n}\r\nmw32(MVS_NON_NCQ_ERR_0, err_0);\r\nmw32(MVS_NON_NCQ_ERR_1, err_1);\r\n}\r\nstatic void mvs_94xx_free_reg_set(struct mvs_info *mvi, u8 *tfs)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu8 reg_set = *tfs;\r\nif (*tfs == MVS_ID_NOT_MAPPED)\r\nreturn;\r\nmvi->sata_reg_set &= ~bit(reg_set);\r\nif (reg_set < 32)\r\nw_reg_set_enable(reg_set, (u32)mvi->sata_reg_set);\r\nelse\r\nw_reg_set_enable(reg_set, (u32)(mvi->sata_reg_set >> 32));\r\n*tfs = MVS_ID_NOT_MAPPED;\r\nreturn;\r\n}\r\nstatic u8 mvs_94xx_assign_reg_set(struct mvs_info *mvi, u8 *tfs)\r\n{\r\nint i;\r\nvoid __iomem *regs = mvi->regs;\r\nif (*tfs != MVS_ID_NOT_MAPPED)\r\nreturn 0;\r\ni = mv_ffc64(mvi->sata_reg_set);\r\nif (i >= 32) {\r\nmvi->sata_reg_set |= bit(i);\r\nw_reg_set_enable(i, (u32)(mvi->sata_reg_set >> 32));\r\n*tfs = i;\r\nreturn 0;\r\n} else if (i >= 0) {\r\nmvi->sata_reg_set |= bit(i);\r\nw_reg_set_enable(i, (u32)mvi->sata_reg_set);\r\n*tfs = i;\r\nreturn 0;\r\n}\r\nreturn MVS_ID_NOT_MAPPED;\r\n}\r\nstatic void mvs_94xx_make_prd(struct scatterlist *scatter, int nr, void *prd)\r\n{\r\nint i;\r\nstruct scatterlist *sg;\r\nstruct mvs_prd *buf_prd = prd;\r\nstruct mvs_prd_imt im_len;\r\n*(u32 *)&im_len = 0;\r\nfor_each_sg(scatter, sg, nr, i) {\r\nbuf_prd->addr = cpu_to_le64(sg_dma_address(sg));\r\nim_len.len = sg_dma_len(sg);\r\nbuf_prd->im_len = cpu_to_le32(*(u32 *)&im_len);\r\nbuf_prd++;\r\n}\r\n}\r\nstatic int mvs_94xx_oob_done(struct mvs_info *mvi, int i)\r\n{\r\nu32 phy_st;\r\nphy_st = mvs_read_phy_ctl(mvi, i);\r\nif (phy_st & PHY_READY_MASK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void mvs_94xx_get_dev_identify_frame(struct mvs_info *mvi, int port_id,\r\nstruct sas_identify_frame *id)\r\n{\r\nint i;\r\nu32 id_frame[7];\r\nfor (i = 0; i < 7; i++) {\r\nmvs_write_port_cfg_addr(mvi, port_id,\r\nCONFIG_ID_FRAME0 + i * 4);\r\nid_frame[i] = cpu_to_le32(mvs_read_port_cfg_data(mvi, port_id));\r\n}\r\nmemcpy(id, id_frame, 28);\r\n}\r\nstatic void mvs_94xx_get_att_identify_frame(struct mvs_info *mvi, int port_id,\r\nstruct sas_identify_frame *id)\r\n{\r\nint i;\r\nu32 id_frame[7];\r\nfor (i = 0; i < 7; i++) {\r\nmvs_write_port_cfg_addr(mvi, port_id,\r\nCONFIG_ATT_ID_FRAME0 + i * 4);\r\nid_frame[i] = cpu_to_le32(mvs_read_port_cfg_data(mvi, port_id));\r\nmv_dprintk("94xx phy %d atta frame %d %x.\n",\r\nport_id + mvi->id * mvi->chip->n_phy, i, id_frame[i]);\r\n}\r\nmemcpy(id, id_frame, 28);\r\n}\r\nstatic u32 mvs_94xx_make_dev_info(struct sas_identify_frame *id)\r\n{\r\nu32 att_dev_info = 0;\r\natt_dev_info |= id->dev_type;\r\nif (id->stp_iport)\r\natt_dev_info |= PORT_DEV_STP_INIT;\r\nif (id->smp_iport)\r\natt_dev_info |= PORT_DEV_SMP_INIT;\r\nif (id->ssp_iport)\r\natt_dev_info |= PORT_DEV_SSP_INIT;\r\nif (id->stp_tport)\r\natt_dev_info |= PORT_DEV_STP_TRGT;\r\nif (id->smp_tport)\r\natt_dev_info |= PORT_DEV_SMP_TRGT;\r\nif (id->ssp_tport)\r\natt_dev_info |= PORT_DEV_SSP_TRGT;\r\natt_dev_info |= (u32)id->phy_id<<24;\r\nreturn att_dev_info;\r\n}\r\nstatic u32 mvs_94xx_make_att_info(struct sas_identify_frame *id)\r\n{\r\nreturn mvs_94xx_make_dev_info(id);\r\n}\r\nstatic void mvs_94xx_fix_phy_info(struct mvs_info *mvi, int i,\r\nstruct sas_identify_frame *id)\r\n{\r\nstruct mvs_phy *phy = &mvi->phy[i];\r\nstruct asd_sas_phy *sas_phy = &phy->sas_phy;\r\nmv_dprintk("get all reg link rate is 0x%x\n", phy->phy_status);\r\nsas_phy->linkrate =\r\n(phy->phy_status & PHY_NEG_SPP_PHYS_LINK_RATE_MASK) >>\r\nPHY_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET;\r\nsas_phy->linkrate += 0x8;\r\nmv_dprintk("get link rate is %d\n", sas_phy->linkrate);\r\nphy->minimum_linkrate = SAS_LINK_RATE_1_5_GBPS;\r\nphy->maximum_linkrate = SAS_LINK_RATE_6_0_GBPS;\r\nmvs_94xx_get_dev_identify_frame(mvi, i, id);\r\nphy->dev_info = mvs_94xx_make_dev_info(id);\r\nif (phy->phy_type & PORT_TYPE_SAS) {\r\nmvs_94xx_get_att_identify_frame(mvi, i, id);\r\nphy->att_dev_info = mvs_94xx_make_att_info(id);\r\nphy->att_dev_sas_addr = *(u64 *)id->sas_addr;\r\n} else {\r\nphy->att_dev_info = PORT_DEV_STP_TRGT | 1;\r\n}\r\nmvs_write_port_cfg_addr(mvi, i, PHYR_PHY_STAT);\r\nmvs_write_port_cfg_data(mvi, i, 0x04);\r\n}\r\nvoid mvs_94xx_phy_set_link_rate(struct mvs_info *mvi, u32 phy_id,\r\nstruct sas_phy_linkrates *rates)\r\n{\r\nu32 lrmax = 0;\r\nu32 tmp;\r\ntmp = mvs_read_phy_ctl(mvi, phy_id);\r\nlrmax = (rates->maximum_linkrate - SAS_LINK_RATE_1_5_GBPS) << 12;\r\nif (lrmax) {\r\ntmp &= ~(0x3 << 12);\r\ntmp |= lrmax;\r\n}\r\nmvs_write_phy_ctl(mvi, phy_id, tmp);\r\nmvs_94xx_phy_reset(mvi, phy_id, PHY_RST_HARD);\r\n}\r\nstatic void mvs_94xx_clear_active_cmds(struct mvs_info *mvi)\r\n{\r\nu32 tmp;\r\nvoid __iomem *regs = mvi->regs;\r\ntmp = mr32(MVS_STP_REG_SET_0);\r\nmw32(MVS_STP_REG_SET_0, 0);\r\nmw32(MVS_STP_REG_SET_0, tmp);\r\ntmp = mr32(MVS_STP_REG_SET_1);\r\nmw32(MVS_STP_REG_SET_1, 0);\r\nmw32(MVS_STP_REG_SET_1, tmp);\r\n}\r\nu32 mvs_94xx_spi_read_data(struct mvs_info *mvi)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex - 0x10200;\r\nreturn mr32(SPI_RD_DATA_REG_94XX);\r\n}\r\nvoid mvs_94xx_spi_write_data(struct mvs_info *mvi, u32 data)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex - 0x10200;\r\nmw32(SPI_RD_DATA_REG_94XX, data);\r\n}\r\nint mvs_94xx_spi_buildcmd(struct mvs_info *mvi,\r\nu32 *dwCmd,\r\nu8 cmd,\r\nu8 read,\r\nu8 length,\r\nu32 addr\r\n)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex - 0x10200;\r\nu32 dwTmp;\r\ndwTmp = ((u32)cmd << 8) | ((u32)length << 4);\r\nif (read)\r\ndwTmp |= SPI_CTRL_READ_94XX;\r\nif (addr != MV_MAX_U32) {\r\nmw32(SPI_ADDR_REG_94XX, (addr & 0x0003FFFFL));\r\ndwTmp |= SPI_ADDR_VLD_94XX;\r\n}\r\n*dwCmd = dwTmp;\r\nreturn 0;\r\n}\r\nint mvs_94xx_spi_issuecmd(struct mvs_info *mvi, u32 cmd)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex - 0x10200;\r\nmw32(SPI_CTRL_REG_94XX, cmd | SPI_CTRL_SpiStart_94XX);\r\nreturn 0;\r\n}\r\nint mvs_94xx_spi_waitdataready(struct mvs_info *mvi, u32 timeout)\r\n{\r\nvoid __iomem *regs = mvi->regs_ex - 0x10200;\r\nu32 i, dwTmp;\r\nfor (i = 0; i < timeout; i++) {\r\ndwTmp = mr32(SPI_CTRL_REG_94XX);\r\nif (!(dwTmp & SPI_CTRL_SpiStart_94XX))\r\nreturn 0;\r\nmsleep(10);\r\n}\r\nreturn -1;\r\n}\r\nvoid mvs_94xx_fix_dma(struct mvs_info *mvi, u32 phy_mask,\r\nint buf_len, int from, void *prd)\r\n{\r\nint i;\r\nstruct mvs_prd *buf_prd = prd;\r\ndma_addr_t buf_dma;\r\nstruct mvs_prd_imt im_len;\r\n*(u32 *)&im_len = 0;\r\nbuf_prd += from;\r\n#define PRD_CHAINED_ENTRY 0x01\r\nif ((mvi->pdev->revision == VANIR_A0_REV) ||\r\n(mvi->pdev->revision == VANIR_B0_REV))\r\nbuf_dma = (phy_mask <= 0x08) ?\r\nmvi->bulk_buffer_dma : mvi->bulk_buffer_dma1;\r\nelse\r\nreturn;\r\nfor (i = from; i < MAX_SG_ENTRY; i++, ++buf_prd) {\r\nif (i == MAX_SG_ENTRY - 1) {\r\nbuf_prd->addr = cpu_to_le64(virt_to_phys(buf_prd - 1));\r\nim_len.len = 2;\r\nim_len.misc_ctl = PRD_CHAINED_ENTRY;\r\n} else {\r\nbuf_prd->addr = cpu_to_le64(buf_dma);\r\nim_len.len = buf_len;\r\n}\r\nbuf_prd->im_len = cpu_to_le32(*(u32 *)&im_len);\r\n}\r\n}\r\nstatic void mvs_94xx_tune_interrupt(struct mvs_info *mvi, u32 time)\r\n{\r\nvoid __iomem *regs = mvi->regs;\r\nu32 tmp = 0;\r\nif (time == 0) {\r\nmw32(MVS_INT_COAL, 0);\r\nmw32(MVS_INT_COAL_TMOUT, 0x10000);\r\n} else {\r\nif (MVS_CHIP_SLOT_SZ > 0x1ff)\r\nmw32(MVS_INT_COAL, 0x1ff|COAL_EN);\r\nelse\r\nmw32(MVS_INT_COAL, MVS_CHIP_SLOT_SZ|COAL_EN);\r\ntmp = 0x10000 | time;\r\nmw32(MVS_INT_COAL_TMOUT, tmp);\r\n}\r\n}
