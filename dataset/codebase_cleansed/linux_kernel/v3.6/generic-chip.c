static inline struct irq_chip_regs *cur_regs(struct irq_data *d)\r\n{\r\nreturn &container_of(d->chip, struct irq_chip_type, chip)->regs;\r\n}\r\nvoid irq_gc_noop(struct irq_data *d)\r\n{\r\n}\r\nvoid irq_gc_mask_disable_reg(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nirq_reg_writel(mask, gc->reg_base + cur_regs(d)->disable);\r\ngc->mask_cache &= ~mask;\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_mask_set_bit(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\ngc->mask_cache |= mask;\r\nirq_reg_writel(gc->mask_cache, gc->reg_base + cur_regs(d)->mask);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_mask_clr_bit(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\ngc->mask_cache &= ~mask;\r\nirq_reg_writel(gc->mask_cache, gc->reg_base + cur_regs(d)->mask);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_unmask_enable_reg(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nirq_reg_writel(mask, gc->reg_base + cur_regs(d)->enable);\r\ngc->mask_cache |= mask;\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_ack_set_bit(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nirq_reg_writel(mask, gc->reg_base + cur_regs(d)->ack);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_ack_clr_bit(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = ~(1 << (d->irq - gc->irq_base));\r\nirq_gc_lock(gc);\r\nirq_reg_writel(mask, gc->reg_base + cur_regs(d)->ack);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_mask_disable_reg_and_ack(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nirq_reg_writel(mask, gc->reg_base + cur_regs(d)->mask);\r\nirq_reg_writel(mask, gc->reg_base + cur_regs(d)->ack);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_eoi(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nirq_gc_lock(gc);\r\nirq_reg_writel(mask, gc->reg_base + cur_regs(d)->eoi);\r\nirq_gc_unlock(gc);\r\n}\r\nint irq_gc_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << (d->irq - gc->irq_base);\r\nif (!(mask & gc->wake_enabled))\r\nreturn -EINVAL;\r\nirq_gc_lock(gc);\r\nif (on)\r\ngc->wake_active |= mask;\r\nelse\r\ngc->wake_active &= ~mask;\r\nirq_gc_unlock(gc);\r\nreturn 0;\r\n}\r\nstruct irq_chip_generic *\r\nirq_alloc_generic_chip(const char *name, int num_ct, unsigned int irq_base,\r\nvoid __iomem *reg_base, irq_flow_handler_t handler)\r\n{\r\nstruct irq_chip_generic *gc;\r\nunsigned long sz = sizeof(*gc) + num_ct * sizeof(struct irq_chip_type);\r\ngc = kzalloc(sz, GFP_KERNEL);\r\nif (gc) {\r\nraw_spin_lock_init(&gc->lock);\r\ngc->num_ct = num_ct;\r\ngc->irq_base = irq_base;\r\ngc->reg_base = reg_base;\r\ngc->chip_types->chip.name = name;\r\ngc->chip_types->handler = handler;\r\n}\r\nreturn gc;\r\n}\r\nvoid irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,\r\nenum irq_gc_flags flags, unsigned int clr,\r\nunsigned int set)\r\n{\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nunsigned int i;\r\nraw_spin_lock(&gc_lock);\r\nlist_add_tail(&gc->list, &gc_list);\r\nraw_spin_unlock(&gc_lock);\r\nif (flags & IRQ_GC_INIT_MASK_CACHE)\r\ngc->mask_cache = irq_reg_readl(gc->reg_base + ct->regs.mask);\r\nfor (i = gc->irq_base; msk; msk >>= 1, i++) {\r\nif (!(msk & 0x01))\r\ncontinue;\r\nif (flags & IRQ_GC_INIT_NESTED_LOCK)\r\nirq_set_lockdep_class(i, &irq_nested_lock_class);\r\nirq_set_chip_and_handler(i, &ct->chip, ct->handler);\r\nirq_set_chip_data(i, gc);\r\nirq_modify_status(i, clr, set);\r\n}\r\ngc->irq_cnt = i - gc->irq_base;\r\n}\r\nint irq_setup_alt_chip(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nunsigned int i;\r\nfor (i = 0; i < gc->num_ct; i++, ct++) {\r\nif (ct->type & type) {\r\nd->chip = &ct->chip;\r\nirq_data_to_desc(d)->handle_irq = ct->handler;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,\r\nunsigned int clr, unsigned int set)\r\n{\r\nunsigned int i = gc->irq_base;\r\nraw_spin_lock(&gc_lock);\r\nlist_del(&gc->list);\r\nraw_spin_unlock(&gc_lock);\r\nfor (; msk; msk >>= 1, i++) {\r\nif (!(msk & 0x01))\r\ncontinue;\r\nirq_set_handler(i, NULL);\r\nirq_set_chip(i, &no_irq_chip);\r\nirq_set_chip_data(i, NULL);\r\nirq_modify_status(i, clr, set);\r\n}\r\n}\r\nstatic int irq_gc_suspend(void)\r\n{\r\nstruct irq_chip_generic *gc;\r\nlist_for_each_entry(gc, &gc_list, list) {\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nif (ct->chip.irq_suspend)\r\nct->chip.irq_suspend(irq_get_irq_data(gc->irq_base));\r\n}\r\nreturn 0;\r\n}\r\nstatic void irq_gc_resume(void)\r\n{\r\nstruct irq_chip_generic *gc;\r\nlist_for_each_entry(gc, &gc_list, list) {\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nif (ct->chip.irq_resume)\r\nct->chip.irq_resume(irq_get_irq_data(gc->irq_base));\r\n}\r\n}\r\nstatic void irq_gc_shutdown(void)\r\n{\r\nstruct irq_chip_generic *gc;\r\nlist_for_each_entry(gc, &gc_list, list) {\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nif (ct->chip.irq_pm_shutdown)\r\nct->chip.irq_pm_shutdown(irq_get_irq_data(gc->irq_base));\r\n}\r\n}\r\nstatic int __init irq_gc_init_ops(void)\r\n{\r\nregister_syscore_ops(&irq_gc_syscore_ops);\r\nreturn 0;\r\n}
