static void srom_clk_write(struct uli526x_board_info *db, u32 data)\r\n{\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nuw32(DCR9, data | CR9_SROM_READ | CR9_SRCS);\r\nudelay(5);\r\nuw32(DCR9, data | CR9_SROM_READ | CR9_SRCS | CR9_SRCLK);\r\nudelay(5);\r\nuw32(DCR9, data | CR9_SROM_READ | CR9_SRCS);\r\nudelay(5);\r\n}\r\nstatic int __devinit uli526x_init_one (struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct uli526x_board_info *db;\r\nstruct net_device *dev;\r\nvoid __iomem *ioaddr;\r\nint i, err;\r\nULI526X_DBUG(0, "uli526x_init_one()", 0);\r\nif (!printed_version++)\r\npr_info("%s\n", version);\r\ndev = alloc_etherdev(sizeof(*db));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\npr_warn("32-bit PCI DMA not available\n");\r\nerr = -ENODEV;\r\ngoto err_out_free;\r\n}\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto err_out_free;\r\nif (!pci_resource_start(pdev, 0)) {\r\npr_err("I/O base is zero\n");\r\nerr = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\nif (pci_resource_len(pdev, 0) < (ULI526X_IO_SIZE) ) {\r\npr_err("Allocated I/O size too small\n");\r\nerr = -ENODEV;\r\ngoto err_out_disable;\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err < 0) {\r\npr_err("Failed to request PCI regions\n");\r\ngoto err_out_disable;\r\n}\r\ndb = netdev_priv(dev);\r\nerr = -ENOMEM;\r\ndb->desc_pool_ptr = pci_alloc_consistent(pdev, sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20, &db->desc_pool_dma_ptr);\r\nif (!db->desc_pool_ptr)\r\ngoto err_out_release;\r\ndb->buf_pool_ptr = pci_alloc_consistent(pdev, TX_BUF_ALLOC * TX_DESC_CNT + 4, &db->buf_pool_dma_ptr);\r\nif (!db->buf_pool_ptr)\r\ngoto err_out_free_tx_desc;\r\ndb->first_tx_desc = (struct tx_desc *) db->desc_pool_ptr;\r\ndb->first_tx_desc_dma = db->desc_pool_dma_ptr;\r\ndb->buf_pool_start = db->buf_pool_ptr;\r\ndb->buf_pool_dma_start = db->buf_pool_dma_ptr;\r\nswitch (ent->driver_data) {\r\ncase PCI_ULI5263_ID:\r\ndb->phy.write = phy_writeby_cr10;\r\ndb->phy.read = phy_readby_cr10;\r\nbreak;\r\ndefault:\r\ndb->phy.write = phy_writeby_cr9;\r\ndb->phy.read = phy_readby_cr9;\r\nbreak;\r\n}\r\nioaddr = pci_iomap(pdev, 0, 0);\r\nif (!ioaddr)\r\ngoto err_out_free_tx_buf;\r\ndb->ioaddr = ioaddr;\r\ndb->pdev = pdev;\r\ndb->init = 1;\r\npci_set_drvdata(pdev, dev);\r\ndev->netdev_ops = &netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\nspin_lock_init(&db->lock);\r\nfor (i = 0; i < 64; i++)\r\n((__le16 *) db->srom)[i] = cpu_to_le16(read_srom_word(db, i));\r\nif(((u16 *) db->srom)[0] == 0xffff || ((u16 *) db->srom)[0] == 0)\r\n{\r\nuw32(DCR0, 0x10000);\r\nuw32(DCR13, 0x1c0);\r\nuw32(DCR14, 0);\r\nuw32(DCR14, 0x10);\r\nuw32(DCR14, 0);\r\nuw32(DCR13, 0);\r\nuw32(DCR13, 0x1b0);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = ur32(DCR14);\r\nuw32(DCR13, 0);\r\nuw32(DCR0, 0);\r\nudelay(10);\r\n}\r\nelse\r\n{\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = db->srom[20 + i];\r\n}\r\nerr = register_netdev (dev);\r\nif (err)\r\ngoto err_out_unmap;\r\nnetdev_info(dev, "ULi M%04lx at pci%s, %pM, irq %d\n",\r\nent->driver_data >> 16, pci_name(pdev),\r\ndev->dev_addr, pdev->irq);\r\npci_set_master(pdev);\r\nreturn 0;\r\nerr_out_unmap:\r\npci_iounmap(pdev, db->ioaddr);\r\nerr_out_free_tx_buf:\r\npci_free_consistent(pdev, TX_BUF_ALLOC * TX_DESC_CNT + 4,\r\ndb->buf_pool_ptr, db->buf_pool_dma_ptr);\r\nerr_out_free_tx_desc:\r\npci_free_consistent(pdev, sizeof(struct tx_desc) * DESC_ALL_CNT + 0x20,\r\ndb->desc_pool_ptr, db->desc_pool_dma_ptr);\r\nerr_out_release:\r\npci_release_regions(pdev);\r\nerr_out_disable:\r\npci_disable_device(pdev);\r\nerr_out_free:\r\npci_set_drvdata(pdev, NULL);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void __devexit uli526x_remove_one (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nunregister_netdev(dev);\r\npci_iounmap(pdev, db->ioaddr);\r\npci_free_consistent(db->pdev, sizeof(struct tx_desc) *\r\nDESC_ALL_CNT + 0x20, db->desc_pool_ptr,\r\ndb->desc_pool_dma_ptr);\r\npci_free_consistent(db->pdev, TX_BUF_ALLOC * TX_DESC_CNT + 4,\r\ndb->buf_pool_ptr, db->buf_pool_dma_ptr);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nfree_netdev(dev);\r\n}\r\nstatic int uli526x_open(struct net_device *dev)\r\n{\r\nint ret;\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nULI526X_DBUG(0, "uli526x_open", 0);\r\ndb->cr6_data = CR6_DEFAULT | uli526x_cr6_user_set;\r\ndb->tx_packet_cnt = 0;\r\ndb->rx_avail_cnt = 0;\r\ndb->link_failed = 1;\r\nnetif_carrier_off(dev);\r\ndb->wait_reset = 0;\r\ndb->NIC_capability = 0xf;\r\ndb->PHY_reg4 = 0x1e0;\r\ndb->cr6_data |= ULI526X_TXTH_256;\r\ndb->cr0_data = CR0_DEFAULT;\r\nuli526x_init(dev);\r\nret = request_irq(db->pdev->irq, uli526x_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (ret)\r\nreturn ret;\r\nnetif_wake_queue(dev);\r\ninit_timer(&db->timer);\r\ndb->timer.expires = ULI526X_TIMER_WUT + HZ * 2;\r\ndb->timer.data = (unsigned long)dev;\r\ndb->timer.function = uli526x_timer;\r\nadd_timer(&db->timer);\r\nreturn 0;\r\n}\r\nstatic void uli526x_init(struct net_device *dev)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nstruct uli_phy_ops *phy = &db->phy;\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu8 phy_tmp;\r\nu8 timeout;\r\nu16 phy_reg_reset;\r\nULI526X_DBUG(0, "uli526x_init()", 0);\r\nuw32(DCR0, ULI526X_RESET);\r\nudelay(100);\r\nuw32(DCR0, db->cr0_data);\r\nudelay(5);\r\ndb->phy_addr = 1;\r\nfor (phy_tmp = 0; phy_tmp < 32; phy_tmp++) {\r\nu16 phy_value;\r\nphy_value = phy->read(db, phy_tmp, 3);\r\nif (phy_value != 0xffff && phy_value != 0) {\r\ndb->phy_addr = phy_tmp;\r\nbreak;\r\n}\r\n}\r\nif (phy_tmp == 32)\r\npr_warn("Can not find the phy address!!!\n");\r\ndb->media_mode = uli526x_media_mode;\r\nphy_reg_reset = phy->read(db, db->phy_addr, 0);\r\nphy_reg_reset = (phy_reg_reset | 0x8000);\r\nphy->write(db, db->phy_addr, 0, phy_reg_reset);\r\nudelay(500);\r\ntimeout = 10;\r\nwhile (timeout-- && phy->read(db, db->phy_addr, 0) & 0x8000)\r\nudelay(100);\r\nuli526x_set_phyxcer(db);\r\nif ( !(db->media_mode & ULI526X_AUTO) )\r\ndb->op_mode = db->media_mode;\r\nuli526x_descriptor_init(dev, ioaddr);\r\nupdate_cr6(db->cr6_data, ioaddr);\r\nsend_filter_frame(dev, netdev_mc_count(dev));\r\ndb->cr7_data = CR7_DEFAULT;\r\nuw32(DCR7, db->cr7_data);\r\nuw32(DCR15, db->cr15_data);\r\ndb->cr6_data |= CR6_RXSC | CR6_TXSC;\r\nupdate_cr6(db->cr6_data, ioaddr);\r\n}\r\nstatic netdev_tx_t uli526x_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nstruct tx_desc *txptr;\r\nunsigned long flags;\r\nULI526X_DBUG(0, "uli526x_start_xmit", 0);\r\nnetif_stop_queue(dev);\r\nif (skb->len > MAX_PACKET_SIZE) {\r\nnetdev_err(dev, "big packet = %d\n", (u16)skb->len);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nspin_lock_irqsave(&db->lock, flags);\r\nif (db->tx_packet_cnt >= TX_FREE_DESC_CNT) {\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nnetdev_err(dev, "No Tx resource %ld\n", db->tx_packet_cnt);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nuw32(DCR7, 0);\r\ntxptr = db->tx_insert_ptr;\r\nskb_copy_from_linear_data(skb, txptr->tx_buf_ptr, skb->len);\r\ntxptr->tdes1 = cpu_to_le32(0xe1000000 | skb->len);\r\ndb->tx_insert_ptr = txptr->next_tx_desc;\r\nif (db->tx_packet_cnt < TX_DESC_CNT) {\r\ntxptr->tdes0 = cpu_to_le32(0x80000000);\r\ndb->tx_packet_cnt++;\r\nuw32(DCR1, 0x1);\r\ndev->trans_start = jiffies;\r\n}\r\nif ( db->tx_packet_cnt < TX_FREE_DESC_CNT )\r\nnetif_wake_queue(dev);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nuw32(DCR7, db->cr7_data);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int uli526x_stop(struct net_device *dev)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&db->timer);\r\nuw32(DCR0, ULI526X_RESET);\r\nudelay(5);\r\ndb->phy.write(db, db->phy_addr, 0, 0x8000);\r\nfree_irq(db->pdev->irq, dev);\r\nuli526x_free_rxbuffer(db);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t uli526x_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&db->lock, flags);\r\nuw32(DCR7, 0);\r\ndb->cr5_data = ur32(DCR5);\r\nuw32(DCR5, db->cr5_data);\r\nif ( !(db->cr5_data & 0x180c1) ) {\r\nuw32(DCR7, db->cr7_data);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (db->cr5_data & 0x2000) {\r\nULI526X_DBUG(1, "System bus error happen. CR5=", db->cr5_data);\r\ndb->reset_fatal++;\r\ndb->wait_reset = 1;\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif ( (db->cr5_data & 0x40) && db->rx_avail_cnt )\r\nuli526x_rx_packet(dev, db);\r\nif (db->rx_avail_cnt<RX_DESC_CNT)\r\nallocate_rx_buffer(dev);\r\nif ( db->cr5_data & 0x01)\r\nuli526x_free_tx_pkt(dev, db);\r\nuw32(DCR7, db->cr7_data);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void uli526x_poll(struct net_device *dev)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nuli526x_interrupt(db->pdev->irq, dev);\r\n}\r\nstatic void uli526x_free_tx_pkt(struct net_device *dev,\r\nstruct uli526x_board_info * db)\r\n{\r\nstruct tx_desc *txptr;\r\nu32 tdes0;\r\ntxptr = db->tx_remove_ptr;\r\nwhile(db->tx_packet_cnt) {\r\ntdes0 = le32_to_cpu(txptr->tdes0);\r\nif (tdes0 & 0x80000000)\r\nbreak;\r\ndb->tx_packet_cnt--;\r\ndev->stats.tx_packets++;\r\nif ( tdes0 != 0x7fffffff ) {\r\ndev->stats.collisions += (tdes0 >> 3) & 0xf;\r\ndev->stats.tx_bytes += le32_to_cpu(txptr->tdes1) & 0x7ff;\r\nif (tdes0 & TDES0_ERR_MASK) {\r\ndev->stats.tx_errors++;\r\nif (tdes0 & 0x0002) {\r\ndb->tx_fifo_underrun++;\r\nif ( !(db->cr6_data & CR6_SFT) ) {\r\ndb->cr6_data = db->cr6_data | CR6_SFT;\r\nupdate_cr6(db->cr6_data, db->ioaddr);\r\n}\r\n}\r\nif (tdes0 & 0x0100)\r\ndb->tx_excessive_collision++;\r\nif (tdes0 & 0x0200)\r\ndb->tx_late_collision++;\r\nif (tdes0 & 0x0400)\r\ndb->tx_no_carrier++;\r\nif (tdes0 & 0x0800)\r\ndb->tx_loss_carrier++;\r\nif (tdes0 & 0x4000)\r\ndb->tx_jabber_timeout++;\r\n}\r\n}\r\ntxptr = txptr->next_tx_desc;\r\n}\r\ndb->tx_remove_ptr = txptr;\r\nif ( db->tx_packet_cnt < TX_WAKE_DESC_CNT )\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void uli526x_rx_packet(struct net_device *dev, struct uli526x_board_info * db)\r\n{\r\nstruct rx_desc *rxptr;\r\nstruct sk_buff *skb;\r\nint rxlen;\r\nu32 rdes0;\r\nrxptr = db->rx_ready_ptr;\r\nwhile(db->rx_avail_cnt) {\r\nrdes0 = le32_to_cpu(rxptr->rdes0);\r\nif (rdes0 & 0x80000000)\r\n{\r\nbreak;\r\n}\r\ndb->rx_avail_cnt--;\r\ndb->interval_rx_cnt++;\r\npci_unmap_single(db->pdev, le32_to_cpu(rxptr->rdes2), RX_ALLOC_SIZE, PCI_DMA_FROMDEVICE);\r\nif ( (rdes0 & 0x300) != 0x300) {\r\nULI526X_DBUG(0, "Reuse SK buffer, rdes0", rdes0);\r\nuli526x_reuse_skb(db, rxptr->rx_skb_ptr);\r\n} else {\r\nrxlen = ( (rdes0 >> 16) & 0x3fff) - 4;\r\nif (rdes0 & 0x8000) {\r\ndev->stats.rx_errors++;\r\nif (rdes0 & 1)\r\ndev->stats.rx_fifo_errors++;\r\nif (rdes0 & 2)\r\ndev->stats.rx_crc_errors++;\r\nif (rdes0 & 0x80)\r\ndev->stats.rx_length_errors++;\r\n}\r\nif ( !(rdes0 & 0x8000) ||\r\n((db->cr6_data & CR6_PM) && (rxlen>6)) ) {\r\nstruct sk_buff *new_skb = NULL;\r\nskb = rxptr->rx_skb_ptr;\r\nif ((rxlen < RX_COPY_SIZE) &&\r\n(((new_skb = netdev_alloc_skb(dev, rxlen + 2)) != NULL))) {\r\nskb = new_skb;\r\nskb_reserve(skb, 2);\r\nmemcpy(skb_put(skb, rxlen),\r\nskb_tail_pointer(rxptr->rx_skb_ptr),\r\nrxlen);\r\nuli526x_reuse_skb(db, rxptr->rx_skb_ptr);\r\n} else\r\nskb_put(skb, rxlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += rxlen;\r\n} else {\r\nULI526X_DBUG(0, "Reuse SK buffer, rdes0", rdes0);\r\nuli526x_reuse_skb(db, rxptr->rx_skb_ptr);\r\n}\r\n}\r\nrxptr = rxptr->next_rx_desc;\r\n}\r\ndb->rx_ready_ptr = rxptr;\r\n}\r\nstatic void uli526x_set_filter_mode(struct net_device * dev)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nunsigned long flags;\r\nULI526X_DBUG(0, "uli526x_set_filter_mode()", 0);\r\nspin_lock_irqsave(&db->lock, flags);\r\nif (dev->flags & IFF_PROMISC) {\r\nULI526X_DBUG(0, "Enable PROM Mode", 0);\r\ndb->cr6_data |= CR6_PM | CR6_PBF;\r\nupdate_cr6(db->cr6_data, db->ioaddr);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn;\r\n}\r\nif (dev->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(dev) > ULI5261_MAX_MULTICAST) {\r\nULI526X_DBUG(0, "Pass all multicast address",\r\nnetdev_mc_count(dev));\r\ndb->cr6_data &= ~(CR6_PM | CR6_PBF);\r\ndb->cr6_data |= CR6_PAM;\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn;\r\n}\r\nULI526X_DBUG(0, "Set multicast address", netdev_mc_count(dev));\r\nsend_filter_frame(dev, netdev_mc_count(dev));\r\nspin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic void\r\nULi_ethtool_gset(struct uli526x_board_info *db, struct ethtool_cmd *ecmd)\r\n{\r\necmd->supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_MII);\r\necmd->advertising = (ADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_Autoneg |\r\nADVERTISED_MII);\r\necmd->port = PORT_MII;\r\necmd->phy_address = db->phy_addr;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nethtool_cmd_speed_set(ecmd, SPEED_10);\r\necmd->duplex = DUPLEX_HALF;\r\nif(db->op_mode==ULI526X_100MHF || db->op_mode==ULI526X_100MFD)\r\n{\r\nethtool_cmd_speed_set(ecmd, SPEED_100);\r\n}\r\nif(db->op_mode==ULI526X_10MFD || db->op_mode==ULI526X_100MFD)\r\n{\r\necmd->duplex = DUPLEX_FULL;\r\n}\r\nif(db->link_failed)\r\n{\r\nethtool_cmd_speed_set(ecmd, -1);\r\necmd->duplex = -1;\r\n}\r\nif (db->media_mode & ULI526X_AUTO)\r\n{\r\necmd->autoneg = AUTONEG_ENABLE;\r\n}\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct uli526x_board_info *np = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(np->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd) {\r\nstruct uli526x_board_info *np = netdev_priv(dev);\r\nULi_ethtool_gset(np, cmd);\r\nreturn 0;\r\n}\r\nstatic u32 netdev_get_link(struct net_device *dev) {\r\nstruct uli526x_board_info *np = netdev_priv(dev);\r\nif(np->link_failed)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic void uli526x_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nwol->supported = WAKE_PHY | WAKE_MAGIC;\r\nwol->wolopts = 0;\r\n}\r\nstatic void uli526x_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *) data;\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nstruct uli_phy_ops *phy = &db->phy;\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nunsigned long flags;\r\nu8 tmp_cr12 = 0;\r\nu32 tmp_cr8;\r\nspin_lock_irqsave(&db->lock, flags);\r\ntmp_cr8 = ur32(DCR8);\r\nif ( (db->interval_rx_cnt==0) && (tmp_cr8) ) {\r\ndb->reset_cr8++;\r\ndb->wait_reset = 1;\r\n}\r\ndb->interval_rx_cnt = 0;\r\nif ( db->tx_packet_cnt &&\r\ntime_after(jiffies, dev_trans_start(dev) + ULI526X_TX_KICK) ) {\r\nuw32(DCR1, 0x1);\r\nif ( time_after(jiffies, dev_trans_start(dev) + ULI526X_TX_TIMEOUT) ) {\r\ndb->reset_TXtimeout++;\r\ndb->wait_reset = 1;\r\nnetdev_err(dev, " Tx timeout - resetting\n");\r\n}\r\n}\r\nif (db->wait_reset) {\r\nULI526X_DBUG(0, "Dynamic Reset device", db->tx_packet_cnt);\r\ndb->reset_count++;\r\nuli526x_dynamic_reset(dev);\r\ndb->timer.expires = ULI526X_TIMER_WUT;\r\nadd_timer(&db->timer);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\nreturn;\r\n}\r\nif ((phy->read(db, db->phy_addr, 5) & 0x01e0)!=0)\r\ntmp_cr12 = 3;\r\nif ( !(tmp_cr12 & 0x3) && !db->link_failed ) {\r\nULI526X_DBUG(0, "Link Failed", tmp_cr12);\r\nnetif_carrier_off(dev);\r\nnetdev_info(dev, "NIC Link is Down\n");\r\ndb->link_failed = 1;\r\nif ( !(db->media_mode & 0x8) )\r\nphy->write(db, db->phy_addr, 0, 0x1000);\r\nif (db->media_mode & ULI526X_AUTO) {\r\ndb->cr6_data&=~0x00000200;\r\nupdate_cr6(db->cr6_data, db->ioaddr);\r\n}\r\n} else\r\nif ((tmp_cr12 & 0x3) && db->link_failed) {\r\nULI526X_DBUG(0, "Link link OK", tmp_cr12);\r\ndb->link_failed = 0;\r\nif ( (db->media_mode & ULI526X_AUTO) &&\r\nuli526x_sense_speed(db) )\r\ndb->link_failed = 1;\r\nuli526x_process_mode(db);\r\nif(db->link_failed==0)\r\n{\r\nnetdev_info(dev, "NIC Link is Up %d Mbps %s duplex\n",\r\n(db->op_mode == ULI526X_100MHF ||\r\ndb->op_mode == ULI526X_100MFD)\r\n? 100 : 10,\r\n(db->op_mode == ULI526X_10MFD ||\r\ndb->op_mode == ULI526X_100MFD)\r\n? "Full" : "Half");\r\nnetif_carrier_on(dev);\r\n}\r\n}\r\nelse if(!(tmp_cr12 & 0x3) && db->link_failed)\r\n{\r\nif(db->init==1)\r\n{\r\nnetdev_info(dev, "NIC Link is Down\n");\r\nnetif_carrier_off(dev);\r\n}\r\n}\r\ndb->init=0;\r\ndb->timer.expires = ULI526X_TIMER_WUT;\r\nadd_timer(&db->timer);\r\nspin_unlock_irqrestore(&db->lock, flags);\r\n}\r\nstatic void uli526x_reset_prepare(struct net_device *dev)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\ndb->cr6_data &= ~(CR6_RXSC | CR6_TXSC);\r\nupdate_cr6(db->cr6_data, ioaddr);\r\nuw32(DCR7, 0);\r\nuw32(DCR5, ur32(DCR5));\r\nnetif_stop_queue(dev);\r\nuli526x_free_rxbuffer(db);\r\ndb->tx_packet_cnt = 0;\r\ndb->rx_avail_cnt = 0;\r\ndb->link_failed = 1;\r\ndb->init=1;\r\ndb->wait_reset = 0;\r\n}\r\nstatic void uli526x_dynamic_reset(struct net_device *dev)\r\n{\r\nULI526X_DBUG(0, "uli526x_dynamic_reset()", 0);\r\nuli526x_reset_prepare(dev);\r\nuli526x_init(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int uli526x_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\npci_power_t power_state;\r\nint err;\r\nULI526X_DBUG(0, "uli526x_suspend", 0);\r\nif (!netdev_priv(dev))\r\nreturn 0;\r\npci_save_state(pdev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nnetif_device_detach(dev);\r\nuli526x_reset_prepare(dev);\r\npower_state = pci_choose_state(pdev, state);\r\npci_enable_wake(pdev, power_state, 0);\r\nerr = pci_set_power_state(pdev, power_state);\r\nif (err) {\r\nnetif_device_attach(dev);\r\nuli526x_init(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nreturn err;\r\n}\r\nstatic int uli526x_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nint err;\r\nULI526X_DBUG(0, "uli526x_resume", 0);\r\nif (!netdev_priv(dev))\r\nreturn 0;\r\npci_restore_state(pdev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nerr = pci_set_power_state(pdev, PCI_D0);\r\nif (err) {\r\nnetdev_warn(dev, "Could not put device into D0\n");\r\nreturn err;\r\n}\r\nnetif_device_attach(dev);\r\nuli526x_init(dev);\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void uli526x_free_rxbuffer(struct uli526x_board_info * db)\r\n{\r\nULI526X_DBUG(0, "uli526x_free_rxbuffer()", 0);\r\nwhile (db->rx_avail_cnt) {\r\ndev_kfree_skb(db->rx_ready_ptr->rx_skb_ptr);\r\ndb->rx_ready_ptr = db->rx_ready_ptr->next_rx_desc;\r\ndb->rx_avail_cnt--;\r\n}\r\n}\r\nstatic void uli526x_reuse_skb(struct uli526x_board_info *db, struct sk_buff * skb)\r\n{\r\nstruct rx_desc *rxptr = db->rx_insert_ptr;\r\nif (!(rxptr->rdes0 & cpu_to_le32(0x80000000))) {\r\nrxptr->rx_skb_ptr = skb;\r\nrxptr->rdes2 = cpu_to_le32(pci_map_single(db->pdev,\r\nskb_tail_pointer(skb),\r\nRX_ALLOC_SIZE,\r\nPCI_DMA_FROMDEVICE));\r\nwmb();\r\nrxptr->rdes0 = cpu_to_le32(0x80000000);\r\ndb->rx_avail_cnt++;\r\ndb->rx_insert_ptr = rxptr->next_rx_desc;\r\n} else\r\nULI526X_DBUG(0, "SK Buffer reuse method error", db->rx_avail_cnt);\r\n}\r\nstatic void uli526x_descriptor_init(struct net_device *dev, void __iomem *ioaddr)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nstruct tx_desc *tmp_tx;\r\nstruct rx_desc *tmp_rx;\r\nunsigned char *tmp_buf;\r\ndma_addr_t tmp_tx_dma, tmp_rx_dma;\r\ndma_addr_t tmp_buf_dma;\r\nint i;\r\nULI526X_DBUG(0, "uli526x_descriptor_init()", 0);\r\ndb->tx_insert_ptr = db->first_tx_desc;\r\ndb->tx_remove_ptr = db->first_tx_desc;\r\nuw32(DCR4, db->first_tx_desc_dma);\r\ndb->first_rx_desc = (void *)db->first_tx_desc + sizeof(struct tx_desc) * TX_DESC_CNT;\r\ndb->first_rx_desc_dma = db->first_tx_desc_dma + sizeof(struct tx_desc) * TX_DESC_CNT;\r\ndb->rx_insert_ptr = db->first_rx_desc;\r\ndb->rx_ready_ptr = db->first_rx_desc;\r\nuw32(DCR3, db->first_rx_desc_dma);\r\ntmp_buf = db->buf_pool_start;\r\ntmp_buf_dma = db->buf_pool_dma_start;\r\ntmp_tx_dma = db->first_tx_desc_dma;\r\nfor (tmp_tx = db->first_tx_desc, i = 0; i < TX_DESC_CNT; i++, tmp_tx++) {\r\ntmp_tx->tx_buf_ptr = tmp_buf;\r\ntmp_tx->tdes0 = cpu_to_le32(0);\r\ntmp_tx->tdes1 = cpu_to_le32(0x81000000);\r\ntmp_tx->tdes2 = cpu_to_le32(tmp_buf_dma);\r\ntmp_tx_dma += sizeof(struct tx_desc);\r\ntmp_tx->tdes3 = cpu_to_le32(tmp_tx_dma);\r\ntmp_tx->next_tx_desc = tmp_tx + 1;\r\ntmp_buf = tmp_buf + TX_BUF_ALLOC;\r\ntmp_buf_dma = tmp_buf_dma + TX_BUF_ALLOC;\r\n}\r\n(--tmp_tx)->tdes3 = cpu_to_le32(db->first_tx_desc_dma);\r\ntmp_tx->next_tx_desc = db->first_tx_desc;\r\ntmp_rx_dma=db->first_rx_desc_dma;\r\nfor (tmp_rx = db->first_rx_desc, i = 0; i < RX_DESC_CNT; i++, tmp_rx++) {\r\ntmp_rx->rdes0 = cpu_to_le32(0);\r\ntmp_rx->rdes1 = cpu_to_le32(0x01000600);\r\ntmp_rx_dma += sizeof(struct rx_desc);\r\ntmp_rx->rdes3 = cpu_to_le32(tmp_rx_dma);\r\ntmp_rx->next_rx_desc = tmp_rx + 1;\r\n}\r\n(--tmp_rx)->rdes3 = cpu_to_le32(db->first_rx_desc_dma);\r\ntmp_rx->next_rx_desc = db->first_rx_desc;\r\nallocate_rx_buffer(dev);\r\n}\r\nstatic void update_cr6(u32 cr6_data, void __iomem *ioaddr)\r\n{\r\nuw32(DCR6, cr6_data);\r\nudelay(5);\r\n}\r\nstatic void send_filter_frame(struct net_device *dev, int mc_cnt)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nstruct netdev_hw_addr *ha;\r\nstruct tx_desc *txptr;\r\nu16 * addrptr;\r\nu32 * suptr;\r\nint i;\r\nULI526X_DBUG(0, "send_filter_frame()", 0);\r\ntxptr = db->tx_insert_ptr;\r\nsuptr = (u32 *) txptr->tx_buf_ptr;\r\naddrptr = (u16 *) dev->dev_addr;\r\n*suptr++ = addrptr[0] << FLT_SHIFT;\r\n*suptr++ = addrptr[1] << FLT_SHIFT;\r\n*suptr++ = addrptr[2] << FLT_SHIFT;\r\n*suptr++ = 0xffff << FLT_SHIFT;\r\n*suptr++ = 0xffff << FLT_SHIFT;\r\n*suptr++ = 0xffff << FLT_SHIFT;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\naddrptr = (u16 *) ha->addr;\r\n*suptr++ = addrptr[0] << FLT_SHIFT;\r\n*suptr++ = addrptr[1] << FLT_SHIFT;\r\n*suptr++ = addrptr[2] << FLT_SHIFT;\r\n}\r\nfor (i = netdev_mc_count(dev); i < 14; i++) {\r\n*suptr++ = 0xffff << FLT_SHIFT;\r\n*suptr++ = 0xffff << FLT_SHIFT;\r\n*suptr++ = 0xffff << FLT_SHIFT;\r\n}\r\ndb->tx_insert_ptr = txptr->next_tx_desc;\r\ntxptr->tdes1 = cpu_to_le32(0x890000c0);\r\nif (db->tx_packet_cnt < TX_DESC_CNT) {\r\ndb->tx_packet_cnt++;\r\ntxptr->tdes0 = cpu_to_le32(0x80000000);\r\nupdate_cr6(db->cr6_data | 0x2000, ioaddr);\r\nuw32(DCR1, 0x1);\r\nupdate_cr6(db->cr6_data, ioaddr);\r\ndev->trans_start = jiffies;\r\n} else\r\nnetdev_err(dev, "No Tx resource - Send_filter_frame!\n");\r\n}\r\nstatic void allocate_rx_buffer(struct net_device *dev)\r\n{\r\nstruct uli526x_board_info *db = netdev_priv(dev);\r\nstruct rx_desc *rxptr;\r\nstruct sk_buff *skb;\r\nrxptr = db->rx_insert_ptr;\r\nwhile(db->rx_avail_cnt < RX_DESC_CNT) {\r\nskb = netdev_alloc_skb(dev, RX_ALLOC_SIZE);\r\nif (skb == NULL)\r\nbreak;\r\nrxptr->rx_skb_ptr = skb;\r\nrxptr->rdes2 = cpu_to_le32(pci_map_single(db->pdev,\r\nskb_tail_pointer(skb),\r\nRX_ALLOC_SIZE,\r\nPCI_DMA_FROMDEVICE));\r\nwmb();\r\nrxptr->rdes0 = cpu_to_le32(0x80000000);\r\nrxptr = rxptr->next_rx_desc;\r\ndb->rx_avail_cnt++;\r\n}\r\ndb->rx_insert_ptr = rxptr;\r\n}\r\nstatic u16 read_srom_word(struct uli526x_board_info *db, int offset)\r\n{\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu16 srom_data = 0;\r\nint i;\r\nuw32(DCR9, CR9_SROM_READ);\r\nuw32(DCR9, CR9_SROM_READ | CR9_SRCS);\r\nsrom_clk_write(db, SROM_DATA_1);\r\nsrom_clk_write(db, SROM_DATA_1);\r\nsrom_clk_write(db, SROM_DATA_0);\r\nfor (i = 5; i >= 0; i--) {\r\nsrom_data = (offset & (1 << i)) ? SROM_DATA_1 : SROM_DATA_0;\r\nsrom_clk_write(db, srom_data);\r\n}\r\nuw32(DCR9, CR9_SROM_READ | CR9_SRCS);\r\nfor (i = 16; i > 0; i--) {\r\nuw32(DCR9, CR9_SROM_READ | CR9_SRCS | CR9_SRCLK);\r\nudelay(5);\r\nsrom_data = (srom_data << 1) |\r\n((ur32(DCR9) & CR9_CRDOUT) ? 1 : 0);\r\nuw32(DCR9, CR9_SROM_READ | CR9_SRCS);\r\nudelay(5);\r\n}\r\nuw32(DCR9, CR9_SROM_READ);\r\nreturn srom_data;\r\n}\r\nstatic u8 uli526x_sense_speed(struct uli526x_board_info * db)\r\n{\r\nstruct uli_phy_ops *phy = &db->phy;\r\nu8 ErrFlag = 0;\r\nu16 phy_mode;\r\nphy_mode = phy->read(db, db->phy_addr, 1);\r\nphy_mode = phy->read(db, db->phy_addr, 1);\r\nif ( (phy_mode & 0x24) == 0x24 ) {\r\nphy_mode = ((phy->read(db, db->phy_addr, 5) & 0x01e0)<<7);\r\nif(phy_mode&0x8000)\r\nphy_mode = 0x8000;\r\nelse if(phy_mode&0x4000)\r\nphy_mode = 0x4000;\r\nelse if(phy_mode&0x2000)\r\nphy_mode = 0x2000;\r\nelse\r\nphy_mode = 0x1000;\r\nswitch (phy_mode) {\r\ncase 0x1000: db->op_mode = ULI526X_10MHF; break;\r\ncase 0x2000: db->op_mode = ULI526X_10MFD; break;\r\ncase 0x4000: db->op_mode = ULI526X_100MHF; break;\r\ncase 0x8000: db->op_mode = ULI526X_100MFD; break;\r\ndefault: db->op_mode = ULI526X_10MHF; ErrFlag = 1; break;\r\n}\r\n} else {\r\ndb->op_mode = ULI526X_10MHF;\r\nULI526X_DBUG(0, "Link Failed :", phy_mode);\r\nErrFlag = 1;\r\n}\r\nreturn ErrFlag;\r\n}\r\nstatic void uli526x_set_phyxcer(struct uli526x_board_info *db)\r\n{\r\nstruct uli_phy_ops *phy = &db->phy;\r\nu16 phy_reg;\r\nphy_reg = phy->read(db, db->phy_addr, 4) & ~0x01e0;\r\nif (db->media_mode & ULI526X_AUTO) {\r\nphy_reg |= db->PHY_reg4;\r\n} else {\r\nswitch(db->media_mode) {\r\ncase ULI526X_10MHF: phy_reg |= 0x20; break;\r\ncase ULI526X_10MFD: phy_reg |= 0x40; break;\r\ncase ULI526X_100MHF: phy_reg |= 0x80; break;\r\ncase ULI526X_100MFD: phy_reg |= 0x100; break;\r\n}\r\n}\r\nif ( !(phy_reg & 0x01e0)) {\r\nphy_reg|=db->PHY_reg4;\r\ndb->media_mode|=ULI526X_AUTO;\r\n}\r\nphy->write(db, db->phy_addr, 4, phy_reg);\r\nphy->write(db, db->phy_addr, 0, 0x1200);\r\nudelay(50);\r\n}\r\nstatic void uli526x_process_mode(struct uli526x_board_info *db)\r\n{\r\nstruct uli_phy_ops *phy = &db->phy;\r\nu16 phy_reg;\r\nif (db->op_mode & 0x4)\r\ndb->cr6_data |= CR6_FDM;\r\nelse\r\ndb->cr6_data &= ~CR6_FDM;\r\nupdate_cr6(db->cr6_data, db->ioaddr);\r\nif (!(db->media_mode & 0x8)) {\r\nphy_reg = phy->read(db, db->phy_addr, 6);\r\nif (!(phy_reg & 0x1)) {\r\nphy_reg = 0x0;\r\nswitch(db->op_mode) {\r\ncase ULI526X_10MHF: phy_reg = 0x0; break;\r\ncase ULI526X_10MFD: phy_reg = 0x100; break;\r\ncase ULI526X_100MHF: phy_reg = 0x2000; break;\r\ncase ULI526X_100MFD: phy_reg = 0x2100; break;\r\n}\r\nphy->write(db, db->phy_addr, 0, phy_reg);\r\n}\r\n}\r\n}\r\nstatic void phy_writeby_cr9(struct uli526x_board_info *db, u8 phy_addr,\r\nu8 offset, u16 phy_data)\r\n{\r\nu16 i;\r\nfor (i = 0; i < 35; i++)\r\nphy_write_1bit(db, PHY_DATA_1);\r\nphy_write_1bit(db, PHY_DATA_0);\r\nphy_write_1bit(db, PHY_DATA_1);\r\nphy_write_1bit(db, PHY_DATA_0);\r\nphy_write_1bit(db, PHY_DATA_1);\r\nfor (i = 0x10; i > 0; i = i >> 1)\r\nphy_write_1bit(db, phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);\r\nfor (i = 0x10; i > 0; i = i >> 1)\r\nphy_write_1bit(db, offset & i ? PHY_DATA_1 : PHY_DATA_0);\r\nphy_write_1bit(db, PHY_DATA_1);\r\nphy_write_1bit(db, PHY_DATA_0);\r\nfor (i = 0x8000; i > 0; i >>= 1)\r\nphy_write_1bit(db, phy_data & i ? PHY_DATA_1 : PHY_DATA_0);\r\n}\r\nstatic u16 phy_readby_cr9(struct uli526x_board_info *db, u8 phy_addr, u8 offset)\r\n{\r\nu16 phy_data;\r\nint i;\r\nfor (i = 0; i < 35; i++)\r\nphy_write_1bit(db, PHY_DATA_1);\r\nphy_write_1bit(db, PHY_DATA_0);\r\nphy_write_1bit(db, PHY_DATA_1);\r\nphy_write_1bit(db, PHY_DATA_1);\r\nphy_write_1bit(db, PHY_DATA_0);\r\nfor (i = 0x10; i > 0; i = i >> 1)\r\nphy_write_1bit(db, phy_addr & i ? PHY_DATA_1 : PHY_DATA_0);\r\nfor (i = 0x10; i > 0; i = i >> 1)\r\nphy_write_1bit(db, offset & i ? PHY_DATA_1 : PHY_DATA_0);\r\nphy_read_1bit(db);\r\nfor (phy_data = 0, i = 0; i < 16; i++) {\r\nphy_data <<= 1;\r\nphy_data |= phy_read_1bit(db);\r\n}\r\nreturn phy_data;\r\n}\r\nstatic u16 phy_readby_cr10(struct uli526x_board_info *db, u8 phy_addr,\r\nu8 offset)\r\n{\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu32 cr10_value = phy_addr;\r\ncr10_value = (cr10_value << 5) + offset;\r\ncr10_value = (cr10_value << 16) + 0x08000000;\r\nuw32(DCR10, cr10_value);\r\nudelay(1);\r\nwhile (1) {\r\ncr10_value = ur32(DCR10);\r\nif (cr10_value & 0x10000000)\r\nbreak;\r\n}\r\nreturn cr10_value & 0x0ffff;\r\n}\r\nstatic void phy_writeby_cr10(struct uli526x_board_info *db, u8 phy_addr,\r\nu8 offset, u16 phy_data)\r\n{\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu32 cr10_value = phy_addr;\r\ncr10_value = (cr10_value << 5) + offset;\r\ncr10_value = (cr10_value << 16) + 0x04000000 + phy_data;\r\nuw32(DCR10, cr10_value);\r\nudelay(1);\r\n}\r\nstatic void phy_write_1bit(struct uli526x_board_info *db, u32 data)\r\n{\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nuw32(DCR9, data);\r\nudelay(1);\r\nuw32(DCR9, data | MDCLKH);\r\nudelay(1);\r\nuw32(DCR9, data);\r\nudelay(1);\r\n}\r\nstatic u16 phy_read_1bit(struct uli526x_board_info *db)\r\n{\r\nvoid __iomem *ioaddr = db->ioaddr;\r\nu16 phy_data;\r\nuw32(DCR9, 0x50000);\r\nudelay(1);\r\nphy_data = (ur32(DCR9) >> 19) & 0x1;\r\nuw32(DCR9, 0x40000);\r\nudelay(1);\r\nreturn phy_data;\r\n}\r\nstatic int __init uli526x_init_module(void)\r\n{\r\npr_info("%s\n", version);\r\nprinted_version = 1;\r\nULI526X_DBUG(0, "init_module() ", debug);\r\nif (debug)\r\nuli526x_debug = debug;\r\nif (cr6set)\r\nuli526x_cr6_user_set = cr6set;\r\nswitch (mode) {\r\ncase ULI526X_10MHF:\r\ncase ULI526X_100MHF:\r\ncase ULI526X_10MFD:\r\ncase ULI526X_100MFD:\r\nuli526x_media_mode = mode;\r\nbreak;\r\ndefault:\r\nuli526x_media_mode = ULI526X_AUTO;\r\nbreak;\r\n}\r\nreturn pci_register_driver(&uli526x_driver);\r\n}\r\nstatic void __exit uli526x_cleanup_module(void)\r\n{\r\nULI526X_DBUG(0, "uli526x_clean_module() ", debug);\r\npci_unregister_driver(&uli526x_driver);\r\n}
