static void serial21285_stop_tx(struct uart_port *port)\r\n{\r\nif (tx_enabled(port)) {\r\ndisable_irq_nosync(IRQ_CONTX);\r\ntx_enabled(port) = 0;\r\n}\r\n}\r\nstatic void serial21285_start_tx(struct uart_port *port)\r\n{\r\nif (!tx_enabled(port)) {\r\nenable_irq(IRQ_CONTX);\r\ntx_enabled(port) = 1;\r\n}\r\n}\r\nstatic void serial21285_stop_rx(struct uart_port *port)\r\n{\r\nif (rx_enabled(port)) {\r\ndisable_irq_nosync(IRQ_CONRX);\r\nrx_enabled(port) = 0;\r\n}\r\n}\r\nstatic void serial21285_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic irqreturn_t serial21285_rx_chars(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct tty_struct *tty = port->state->port.tty;\r\nunsigned int status, ch, flag, rxs, max_count = 256;\r\nstatus = *CSR_UARTFLG;\r\nwhile (!(status & 0x10) && max_count--) {\r\nch = *CSR_UARTDR;\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nrxs = *CSR_RXSTAT | RXSTAT_DUMMY_READ;\r\nif (unlikely(rxs & RXSTAT_ANYERR)) {\r\nif (rxs & RXSTAT_PARITY)\r\nport->icount.parity++;\r\nelse if (rxs & RXSTAT_FRAME)\r\nport->icount.frame++;\r\nif (rxs & RXSTAT_OVERRUN)\r\nport->icount.overrun++;\r\nrxs &= port->read_status_mask;\r\nif (rxs & RXSTAT_PARITY)\r\nflag = TTY_PARITY;\r\nelse if (rxs & RXSTAT_FRAME)\r\nflag = TTY_FRAME;\r\n}\r\nuart_insert_char(port, rxs, RXSTAT_OVERRUN, ch, flag);\r\nstatus = *CSR_UARTFLG;\r\n}\r\ntty_flip_buffer_push(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t serial21285_tx_chars(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nint count = 256;\r\nif (port->x_char) {\r\n*CSR_UARTDR = port->x_char;\r\nport->icount.tx++;\r\nport->x_char = 0;\r\ngoto out;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nserial21285_stop_tx(port);\r\ngoto out;\r\n}\r\ndo {\r\n*CSR_UARTDR = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0 && !(*CSR_UARTFLG & 0x20));\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nserial21285_stop_tx(port);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int serial21285_tx_empty(struct uart_port *port)\r\n{\r\nreturn (*CSR_UARTFLG & 8) ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int serial21285_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void serial21285_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void serial21285_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned long flags;\r\nunsigned int h_lcr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nh_lcr = *CSR_H_UBRLCR;\r\nif (break_state)\r\nh_lcr |= H_UBRLCR_BREAK;\r\nelse\r\nh_lcr &= ~H_UBRLCR_BREAK;\r\n*CSR_H_UBRLCR = h_lcr;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int serial21285_startup(struct uart_port *port)\r\n{\r\nint ret;\r\ntx_enabled(port) = 1;\r\nrx_enabled(port) = 1;\r\nret = request_irq(IRQ_CONRX, serial21285_rx_chars, 0,\r\nserial21285_name, port);\r\nif (ret == 0) {\r\nret = request_irq(IRQ_CONTX, serial21285_tx_chars, 0,\r\nserial21285_name, port);\r\nif (ret)\r\nfree_irq(IRQ_CONRX, port);\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial21285_shutdown(struct uart_port *port)\r\n{\r\nfree_irq(IRQ_CONTX, port);\r\nfree_irq(IRQ_CONRX, port);\r\n}\r\nstatic void\r\nserial21285_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int baud, quot, h_lcr, b;\r\ntermios->c_cflag &= ~(HUPCL | CRTSCTS | CMSPAR);\r\ntermios->c_cflag |= CLOCAL;\r\ntermios->c_iflag &= ~(IGNBRK | BRKINT);\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nb = port->uartclk / (16 * quot);\r\ntty_termios_encode_baud_rate(termios, b, b);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nh_lcr = 0x00;\r\nbreak;\r\ncase CS6:\r\nh_lcr = 0x20;\r\nbreak;\r\ncase CS7:\r\nh_lcr = 0x40;\r\nbreak;\r\ndefault:\r\nh_lcr = 0x60;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nh_lcr |= H_UBRLCR_STOPB;\r\nif (termios->c_cflag & PARENB) {\r\nh_lcr |= H_UBRLCR_PARENB;\r\nif (!(termios->c_cflag & PARODD))\r\nh_lcr |= H_UBRLCR_PAREVN;\r\n}\r\nif (port->fifosize)\r\nh_lcr |= H_UBRLCR_FIFO;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nport->read_status_mask = RXSTAT_OVERRUN;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= RXSTAT_FRAME | RXSTAT_PARITY;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= RXSTAT_FRAME | RXSTAT_PARITY;\r\nif (termios->c_iflag & IGNBRK && termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= RXSTAT_OVERRUN;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= RXSTAT_DUMMY_READ;\r\nquot -= 1;\r\n*CSR_UARTCON = 0;\r\n*CSR_L_UBRLCR = quot & 0xff;\r\n*CSR_M_UBRLCR = (quot >> 8) & 0x0f;\r\n*CSR_H_UBRLCR = h_lcr;\r\n*CSR_UARTCON = 1;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *serial21285_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_21285 ? "DC21285" : NULL;\r\n}\r\nstatic void serial21285_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, 32);\r\n}\r\nstatic int serial21285_request_port(struct uart_port *port)\r\n{\r\nreturn request_mem_region(port->mapbase, 32, serial21285_name)\r\n!= NULL ? 0 : -EBUSY;\r\n}\r\nstatic void serial21285_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE && serial21285_request_port(port) == 0)\r\nport->type = PORT_21285;\r\n}\r\nstatic int serial21285_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_21285)\r\nret = -EINVAL;\r\nif (ser->irq <= 0)\r\nret = -EINVAL;\r\nif (ser->baud_base != port->uartclk / 16)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void serial21285_setup_ports(void)\r\n{\r\nserial21285_port.uartclk = mem_fclk_21285 / 4;\r\n}\r\nstatic void serial21285_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (*CSR_UARTFLG & 0x20)\r\nbarrier();\r\n*CSR_UARTDR = ch;\r\n}\r\nstatic void\r\nserial21285_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nuart_console_write(&serial21285_port, s, count, serial21285_console_putchar);\r\n}\r\nstatic void __init\r\nserial21285_get_options(struct uart_port *port, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (*CSR_UARTCON == 1) {\r\nunsigned int tmp;\r\ntmp = *CSR_H_UBRLCR;\r\nswitch (tmp & 0x60) {\r\ncase 0x00:\r\n*bits = 5;\r\nbreak;\r\ncase 0x20:\r\n*bits = 6;\r\nbreak;\r\ncase 0x40:\r\n*bits = 7;\r\nbreak;\r\ndefault:\r\ncase 0x60:\r\n*bits = 8;\r\nbreak;\r\n}\r\nif (tmp & H_UBRLCR_PARENB) {\r\n*parity = 'o';\r\nif (tmp & H_UBRLCR_PAREVN)\r\n*parity = 'e';\r\n}\r\ntmp = *CSR_L_UBRLCR | (*CSR_M_UBRLCR << 8);\r\n*baud = port->uartclk / (16 * (tmp + 1));\r\n}\r\n}\r\nstatic int __init serial21285_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port = &serial21285_port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (machine_is_personal_server())\r\nbaud = 57600;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nserial21285_get_options(port, &baud, &parity, &bits);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init rs285_console_init(void)\r\n{\r\nserial21285_setup_ports();\r\nregister_console(&serial21285_console);\r\nreturn 0;\r\n}\r\nstatic int __init serial21285_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Serial: 21285 driver\n");\r\nserial21285_setup_ports();\r\nret = uart_register_driver(&serial21285_reg);\r\nif (ret == 0)\r\nuart_add_one_port(&serial21285_reg, &serial21285_port);\r\nreturn ret;\r\n}\r\nstatic void __exit serial21285_exit(void)\r\n{\r\nuart_remove_one_port(&serial21285_reg, &serial21285_port);\r\nuart_unregister_driver(&serial21285_reg);\r\n}
