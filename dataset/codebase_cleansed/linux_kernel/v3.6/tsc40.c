static void tsc_process_data(struct tsc_ser *ptsc)\r\n{\r\nstruct input_dev *dev = ptsc->dev;\r\nu8 *data = ptsc->data;\r\nu32 x;\r\nu32 y;\r\nx = ((data[1] & 0x03) << 8) | data[2];\r\ny = ((data[3] & 0x03) << 8) | data[4];\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\ninput_report_key(dev, BTN_TOUCH, 1);\r\ninput_sync(dev);\r\n}\r\nstatic irqreturn_t tsc_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct tsc_ser *ptsc = serio_get_drvdata(serio);\r\nstruct input_dev *dev = ptsc->dev;\r\nptsc->data[ptsc->idx] = data;\r\nswitch (ptsc->idx++) {\r\ncase 0:\r\nif (unlikely((data & 0x3e) != 0x10)) {\r\ndev_dbg(&serio->dev,\r\n"unsynchronized packet start (0x%02x)\n", data);\r\nptsc->idx = 0;\r\n} else if (!(data & 0x01)) {\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\ninput_sync(dev);\r\nptsc->idx = 0;\r\n}\r\nbreak;\r\ncase 1:\r\ncase 3:\r\nif (unlikely(data & 0xfc)) {\r\ndev_dbg(&serio->dev,\r\n"unsynchronized data 0x%02x at offset %d\n",\r\ndata, ptsc->idx - 1);\r\nptsc->idx = 0;\r\n}\r\nbreak;\r\ncase 4:\r\ntsc_process_data(ptsc);\r\nptsc->idx = 0;\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tsc_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct tsc_ser *ptsc;\r\nstruct input_dev *input_dev;\r\nint error;\r\nptsc = kzalloc(sizeof(struct tsc_ser), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ptsc || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nptsc->serio = serio;\r\nptsc->dev = input_dev;\r\nsnprintf(ptsc->phys, sizeof(ptsc->phys), "%s/input0", serio->phys);\r\ninput_dev->name = "TSC-10/25/40 Serial TouchScreen";\r\ninput_dev->phys = ptsc->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_TSC40;\r\ninput_dev->id.product = 40;\r\ninput_dev->id.version = 0x0001;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(ptsc->dev, ABS_X, 0, 0x3ff, 0, 0);\r\ninput_set_abs_params(ptsc->dev, ABS_Y, 0, 0x3ff, 0, 0);\r\ninput_set_abs_params(ptsc->dev, ABS_PRESSURE, 0, 0, 0, 0);\r\nserio_set_drvdata(serio, ptsc);\r\nerror = serio_open(serio, drv);\r\nif (error)\r\ngoto fail2;\r\nerror = input_register_device(ptsc->dev);\r\nif (error)\r\ngoto fail3;\r\nreturn 0;\r\nfail3:\r\nserio_close(serio);\r\nfail2:\r\nserio_set_drvdata(serio, NULL);\r\nfail1:\r\ninput_free_device(input_dev);\r\nkfree(ptsc);\r\nreturn error;\r\n}\r\nstatic void tsc_disconnect(struct serio *serio)\r\n{\r\nstruct tsc_ser *ptsc = serio_get_drvdata(serio);\r\nserio_close(serio);\r\ninput_unregister_device(ptsc->dev);\r\nkfree(ptsc);\r\nserio_set_drvdata(serio, NULL);\r\n}
