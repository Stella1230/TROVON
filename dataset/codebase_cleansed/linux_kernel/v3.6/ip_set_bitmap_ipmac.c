static inline void *\r\nbitmap_ipmac_elem(const struct bitmap_ipmac *map, u32 id)\r\n{\r\nreturn (void *)((char *)map->members + id * map->dsize);\r\n}\r\nstatic inline bool\r\nbitmap_timeout(const struct bitmap_ipmac *map, u32 id)\r\n{\r\nconst struct ipmac_telem *elem = bitmap_ipmac_elem(map, id);\r\nreturn ip_set_timeout_test(elem->timeout);\r\n}\r\nstatic inline bool\r\nbitmap_expired(const struct bitmap_ipmac *map, u32 id)\r\n{\r\nconst struct ipmac_telem *elem = bitmap_ipmac_elem(map, id);\r\nreturn ip_set_timeout_expired(elem->timeout);\r\n}\r\nstatic inline int\r\nbitmap_ipmac_exist(const struct ipmac_telem *elem)\r\n{\r\nreturn elem->match == MAC_UNSET ||\r\n(elem->match == MAC_FILLED &&\r\n!ip_set_timeout_expired(elem->timeout));\r\n}\r\nstatic int\r\nbitmap_ipmac_test(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nconst struct bitmap_ipmac *map = set->data;\r\nconst struct ipmac *data = value;\r\nconst struct ipmac_elem *elem = bitmap_ipmac_elem(map, data->id);\r\nswitch (elem->match) {\r\ncase MAC_UNSET:\r\nreturn -EAGAIN;\r\ncase MAC_FILLED:\r\nreturn data->ether == NULL ||\r\nether_addr_equal(data->ether, elem->ether);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ipmac_add(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\nconst struct ipmac *data = value;\r\nstruct ipmac_elem *elem = bitmap_ipmac_elem(map, data->id);\r\nswitch (elem->match) {\r\ncase MAC_UNSET:\r\nif (!data->ether)\r\nreturn -IPSET_ERR_EXIST;\r\nmemcpy(elem->ether, data->ether, ETH_ALEN);\r\nelem->match = MAC_FILLED;\r\nbreak;\r\ncase MAC_FILLED:\r\nreturn -IPSET_ERR_EXIST;\r\ncase MAC_EMPTY:\r\nif (data->ether) {\r\nmemcpy(elem->ether, data->ether, ETH_ALEN);\r\nelem->match = MAC_FILLED;\r\n} else\r\nelem->match = MAC_UNSET;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ipmac_del(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\nconst struct ipmac *data = value;\r\nstruct ipmac_elem *elem = bitmap_ipmac_elem(map, data->id);\r\nif (elem->match == MAC_EMPTY)\r\nreturn -IPSET_ERR_EXIST;\r\nelem->match = MAC_EMPTY;\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ipmac_list(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct bitmap_ipmac *map = set->data;\r\nconst struct ipmac_elem *elem;\r\nstruct nlattr *atd, *nested;\r\nu32 id, first = cb->args[2];\r\nu32 last = map->last_ip - map->first_ip;\r\natd = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!atd)\r\nreturn -EMSGSIZE;\r\nfor (; cb->args[2] <= last; cb->args[2]++) {\r\nid = cb->args[2];\r\nelem = bitmap_ipmac_elem(map, id);\r\nif (elem->match == MAC_EMPTY)\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (id == first) {\r\nnla_nest_cancel(skb, atd);\r\nreturn -EMSGSIZE;\r\n} else\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP,\r\nhtonl(map->first_ip + id)) ||\r\n(elem->match == MAC_FILLED &&\r\nnla_put(skb, IPSET_ATTR_ETHER, ETH_ALEN,\r\nelem->ether)))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\n}\r\nipset_nest_end(skb, atd);\r\ncb->args[2] = 0;\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nipset_nest_end(skb, atd);\r\nif (unlikely(id == first)) {\r\ncb->args[2] = 0;\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ipmac_ttest(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nconst struct bitmap_ipmac *map = set->data;\r\nconst struct ipmac *data = value;\r\nconst struct ipmac_elem *elem = bitmap_ipmac_elem(map, data->id);\r\nswitch (elem->match) {\r\ncase MAC_UNSET:\r\nreturn -EAGAIN;\r\ncase MAC_FILLED:\r\nreturn (data->ether == NULL ||\r\nether_addr_equal(data->ether, elem->ether)) &&\r\n!bitmap_expired(map, data->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ipmac_tadd(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\nconst struct ipmac *data = value;\r\nstruct ipmac_telem *elem = bitmap_ipmac_elem(map, data->id);\r\nbool flag_exist = flags & IPSET_FLAG_EXIST;\r\nswitch (elem->match) {\r\ncase MAC_UNSET:\r\nif (!(data->ether || flag_exist))\r\nreturn -IPSET_ERR_EXIST;\r\nmemcpy(elem->ether, data->ether, ETH_ALEN);\r\nelem->match = MAC_FILLED;\r\nif (timeout == map->timeout)\r\ntimeout = elem->timeout;\r\nelem->timeout = ip_set_timeout_set(timeout);\r\nbreak;\r\ncase MAC_FILLED:\r\nif (!(bitmap_expired(map, data->id) || flag_exist))\r\nreturn -IPSET_ERR_EXIST;\r\ncase MAC_EMPTY:\r\nif (data->ether) {\r\nmemcpy(elem->ether, data->ether, ETH_ALEN);\r\nelem->match = MAC_FILLED;\r\n} else\r\nelem->match = MAC_UNSET;\r\nelem->timeout = data->ether ? ip_set_timeout_set(timeout)\r\n: timeout;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ipmac_tdel(struct ip_set *set, void *value, u32 timeout, u32 flags)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\nconst struct ipmac *data = value;\r\nstruct ipmac_telem *elem = bitmap_ipmac_elem(map, data->id);\r\nif (elem->match == MAC_EMPTY || bitmap_expired(map, data->id))\r\nreturn -IPSET_ERR_EXIST;\r\nelem->match = MAC_EMPTY;\r\nreturn 0;\r\n}\r\nstatic int\r\nbitmap_ipmac_tlist(const struct ip_set *set,\r\nstruct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nconst struct bitmap_ipmac *map = set->data;\r\nconst struct ipmac_telem *elem;\r\nstruct nlattr *atd, *nested;\r\nu32 id, first = cb->args[2];\r\nu32 timeout, last = map->last_ip - map->first_ip;\r\natd = ipset_nest_start(skb, IPSET_ATTR_ADT);\r\nif (!atd)\r\nreturn -EMSGSIZE;\r\nfor (; cb->args[2] <= last; cb->args[2]++) {\r\nid = cb->args[2];\r\nelem = bitmap_ipmac_elem(map, id);\r\nif (!bitmap_ipmac_exist(elem))\r\ncontinue;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested) {\r\nif (id == first) {\r\nnla_nest_cancel(skb, atd);\r\nreturn -EMSGSIZE;\r\n} else\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP,\r\nhtonl(map->first_ip + id)) ||\r\n(elem->match == MAC_FILLED &&\r\nnla_put(skb, IPSET_ATTR_ETHER, ETH_ALEN,\r\nelem->ether)))\r\ngoto nla_put_failure;\r\ntimeout = elem->match == MAC_UNSET ? elem->timeout\r\n: ip_set_timeout_get(elem->timeout);\r\nif (nla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(timeout)))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\n}\r\nipset_nest_end(skb, atd);\r\ncb->args[2] = 0;\r\nreturn 0;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nested);\r\nipset_nest_end(skb, atd);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nbitmap_ipmac_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, const struct ip_set_adt_opt *opt)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct ipmac data;\r\nif (!(opt->flags & IPSET_DIM_TWO_SRC))\r\nreturn 0;\r\ndata.id = ntohl(ip4addr(skb, opt->flags & IPSET_DIM_ONE_SRC));\r\nif (data.id < map->first_ip || data.id > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nif (skb_mac_header(skb) < skb->head ||\r\n(skb_mac_header(skb) + ETH_HLEN) > skb->data)\r\nreturn -EINVAL;\r\ndata.id -= map->first_ip;\r\ndata.ether = eth_hdr(skb)->h_source;\r\nreturn adtfn(set, &data, opt_timeout(opt, map), opt->cmdflags);\r\n}\r\nstatic int\r\nbitmap_ipmac_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nconst struct bitmap_ipmac *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct ipmac data;\r\nu32 timeout = map->timeout;\r\nint ret = 0;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &data.id);\r\nif (ret)\r\nreturn ret;\r\nif (data.id < map->first_ip || data.id > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nif (tb[IPSET_ATTR_ETHER])\r\ndata.ether = nla_data(tb[IPSET_ATTR_ETHER]);\r\nelse\r\ndata.ether = NULL;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nif (!with_timeout(map->timeout))\r\nreturn -IPSET_ERR_TIMEOUT;\r\ntimeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\n}\r\ndata.id -= map->first_ip;\r\nret = adtfn(set, &data, timeout, flags);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nstatic void\r\nbitmap_ipmac_destroy(struct ip_set *set)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\nif (with_timeout(map->timeout))\r\ndel_timer_sync(&map->gc);\r\nip_set_free(map->members);\r\nkfree(map);\r\nset->data = NULL;\r\n}\r\nstatic void\r\nbitmap_ipmac_flush(struct ip_set *set)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\nmemset(map->members, 0,\r\n(map->last_ip - map->first_ip + 1) * map->dsize);\r\n}\r\nstatic int\r\nbitmap_ipmac_head(struct ip_set *set, struct sk_buff *skb)\r\n{\r\nconst struct bitmap_ipmac *map = set->data;\r\nstruct nlattr *nested;\r\nnested = ipset_nest_start(skb, IPSET_ATTR_DATA);\r\nif (!nested)\r\ngoto nla_put_failure;\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, htonl(map->first_ip)) ||\r\nnla_put_ipaddr4(skb, IPSET_ATTR_IP_TO, htonl(map->last_ip)) ||\r\nnla_put_net32(skb, IPSET_ATTR_REFERENCES, htonl(set->ref - 1)) ||\r\nnla_put_net32(skb, IPSET_ATTR_MEMSIZE,\r\nhtonl(sizeof(*map) +\r\n((map->last_ip - map->first_ip + 1) *\r\nmap->dsize))) ||\r\n(with_timeout(map->timeout) &&\r\nnla_put_net32(skb, IPSET_ATTR_TIMEOUT, htonl(map->timeout))))\r\ngoto nla_put_failure;\r\nipset_nest_end(skb, nested);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic bool\r\nbitmap_ipmac_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct bitmap_ipmac *x = a->data;\r\nconst struct bitmap_ipmac *y = b->data;\r\nreturn x->first_ip == y->first_ip &&\r\nx->last_ip == y->last_ip &&\r\nx->timeout == y->timeout;\r\n}\r\nstatic void\r\nbitmap_ipmac_gc(unsigned long ul_set)\r\n{\r\nstruct ip_set *set = (struct ip_set *) ul_set;\r\nstruct bitmap_ipmac *map = set->data;\r\nstruct ipmac_telem *elem;\r\nu32 id, last = map->last_ip - map->first_ip;\r\nread_lock_bh(&set->lock);\r\nfor (id = 0; id <= last; id++) {\r\nelem = bitmap_ipmac_elem(map, id);\r\nif (elem->match == MAC_FILLED &&\r\nip_set_timeout_expired(elem->timeout))\r\nelem->match = MAC_EMPTY;\r\n}\r\nread_unlock_bh(&set->lock);\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic void\r\nbitmap_ipmac_gc_init(struct ip_set *set)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\ninit_timer(&map->gc);\r\nmap->gc.data = (unsigned long) set;\r\nmap->gc.function = bitmap_ipmac_gc;\r\nmap->gc.expires = jiffies + IPSET_GC_PERIOD(map->timeout) * HZ;\r\nadd_timer(&map->gc);\r\n}\r\nstatic bool\r\ninit_map_ipmac(struct ip_set *set, struct bitmap_ipmac *map,\r\nu32 first_ip, u32 last_ip)\r\n{\r\nmap->members = ip_set_alloc((last_ip - first_ip + 1) * map->dsize);\r\nif (!map->members)\r\nreturn false;\r\nmap->first_ip = first_ip;\r\nmap->last_ip = last_ip;\r\nmap->timeout = IPSET_NO_TIMEOUT;\r\nset->data = map;\r\nset->family = NFPROTO_IPV4;\r\nreturn true;\r\n}\r\nstatic int\r\nbitmap_ipmac_create(struct ip_set *set, struct nlattr *tb[],\r\nu32 flags)\r\n{\r\nu32 first_ip, last_ip, elements;\r\nstruct bitmap_ipmac *map;\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &first_ip);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &last_ip);\r\nif (ret)\r\nreturn ret;\r\nif (first_ip > last_ip) {\r\nu32 tmp = first_ip;\r\nfirst_ip = last_ip;\r\nlast_ip = tmp;\r\n}\r\n} else if (tb[IPSET_ATTR_CIDR]) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (cidr >= 32)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip_set_mask_from_to(first_ip, last_ip, cidr);\r\n} else\r\nreturn -IPSET_ERR_PROTOCOL;\r\nelements = last_ip - first_ip + 1;\r\nif (elements > IPSET_BITMAP_MAX_RANGE + 1)\r\nreturn -IPSET_ERR_BITMAP_RANGE_SIZE;\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nmap->dsize = sizeof(struct ipmac_telem);\r\nif (!init_map_ipmac(set, map, first_ip, last_ip)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nmap->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nset->variant = &bitmap_tipmac;\r\nbitmap_ipmac_gc_init(set);\r\n} else {\r\nmap->dsize = sizeof(struct ipmac_elem);\r\nif (!init_map_ipmac(set, map, first_ip, last_ip)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nset->variant = &bitmap_ipmac;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nbitmap_ipmac_init(void)\r\n{\r\nreturn ip_set_type_register(&bitmap_ipmac_type);\r\n}\r\nstatic void __exit\r\nbitmap_ipmac_fini(void)\r\n{\r\nip_set_type_unregister(&bitmap_ipmac_type);\r\n}
