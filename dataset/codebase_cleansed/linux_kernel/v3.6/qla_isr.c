irqreturn_t\r\nqla2100_intr_handler(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct device_reg_2xxx __iomem *reg;\r\nint status;\r\nunsigned long iter;\r\nuint16_t hccr;\r\nuint16_t mb[4];\r\nstruct rsp_que *rsp;\r\nunsigned long flags;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0x505d,\r\n"%s: NULL response queue pointer.\n", __func__);\r\nreturn (IRQ_NONE);\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->isp;\r\nstatus = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\nfor (iter = 50; iter--; ) {\r\nhccr = RD_REG_WORD(&reg->hccr);\r\nif (hccr & HCCR_RISC_PAUSE) {\r\nif (pci_channel_offline(ha->pdev))\r\nbreak;\r\nWRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);\r\nRD_REG_WORD(&reg->hccr);\r\nha->isp_ops->fw_dump(vha, 1);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\n} else if ((RD_REG_WORD(&reg->istatus) & ISR_RISC_INT) == 0)\r\nbreak;\r\nif (RD_REG_WORD(&reg->semaphore) & BIT_0) {\r\nWRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);\r\nRD_REG_WORD(&reg->hccr);\r\nmb[0] = RD_MAILBOX_REG(ha, reg, 0);\r\nif (mb[0] > 0x3fff && mb[0] < 0x8000) {\r\nqla2x00_mbx_completion(vha, mb[0]);\r\nstatus |= MBX_INTERRUPT;\r\n} else if (mb[0] > 0x7fff && mb[0] < 0xc000) {\r\nmb[1] = RD_MAILBOX_REG(ha, reg, 1);\r\nmb[2] = RD_MAILBOX_REG(ha, reg, 2);\r\nmb[3] = RD_MAILBOX_REG(ha, reg, 3);\r\nqla2x00_async_event(vha, rsp, mb);\r\n} else {\r\nql_dbg(ql_dbg_async, vha, 0x5025,\r\n"Unrecognized interrupt type (%d).\n",\r\nmb[0]);\r\n}\r\nWRT_REG_WORD(&reg->semaphore, 0);\r\nRD_REG_WORD(&reg->semaphore);\r\n} else {\r\nqla2x00_process_response_queue(rsp);\r\nWRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);\r\nRD_REG_WORD(&reg->hccr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (test_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags) &&\r\n(status & MBX_INTERRUPT) && ha->flags.mbox_int) {\r\nset_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\ncomplete(&ha->mbx_intr_comp);\r\n}\r\nreturn (IRQ_HANDLED);\r\n}\r\nirqreturn_t\r\nqla2300_intr_handler(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct device_reg_2xxx __iomem *reg;\r\nint status;\r\nunsigned long iter;\r\nuint32_t stat;\r\nuint16_t hccr;\r\nuint16_t mb[4];\r\nstruct rsp_que *rsp;\r\nstruct qla_hw_data *ha;\r\nunsigned long flags;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0x5058,\r\n"%s: NULL response queue pointer.\n", __func__);\r\nreturn (IRQ_NONE);\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->isp;\r\nstatus = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\nfor (iter = 50; iter--; ) {\r\nstat = RD_REG_DWORD(&reg->u.isp2300.host_status);\r\nif (stat & HSR_RISC_PAUSED) {\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nbreak;\r\nhccr = RD_REG_WORD(&reg->hccr);\r\nif (hccr & (BIT_15 | BIT_13 | BIT_11 | BIT_8))\r\nql_log(ql_log_warn, vha, 0x5026,\r\n"Parity error -- HCCR=%x, Dumping "\r\n"firmware.\n", hccr);\r\nelse\r\nql_log(ql_log_warn, vha, 0x5027,\r\n"RISC paused -- HCCR=%x, Dumping "\r\n"firmware.\n", hccr);\r\nWRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);\r\nRD_REG_WORD(&reg->hccr);\r\nha->isp_ops->fw_dump(vha, 1);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\n} else if ((stat & HSR_RISC_INT) == 0)\r\nbreak;\r\nswitch (stat & 0xff) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x10:\r\ncase 0x11:\r\nqla2x00_mbx_completion(vha, MSW(stat));\r\nstatus |= MBX_INTERRUPT;\r\nWRT_REG_WORD(&reg->semaphore, 0);\r\nbreak;\r\ncase 0x12:\r\nmb[0] = MSW(stat);\r\nmb[1] = RD_MAILBOX_REG(ha, reg, 1);\r\nmb[2] = RD_MAILBOX_REG(ha, reg, 2);\r\nmb[3] = RD_MAILBOX_REG(ha, reg, 3);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ncase 0x13:\r\nqla2x00_process_response_queue(rsp);\r\nbreak;\r\ncase 0x15:\r\nmb[0] = MBA_CMPLT_1_16BIT;\r\nmb[1] = MSW(stat);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ncase 0x16:\r\nmb[0] = MBA_SCSI_COMPLETION;\r\nmb[1] = MSW(stat);\r\nmb[2] = RD_MAILBOX_REG(ha, reg, 2);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_async, vha, 0x5028,\r\n"Unrecognized interrupt type (%d).\n", stat & 0xff);\r\nbreak;\r\n}\r\nWRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);\r\nRD_REG_WORD_RELAXED(&reg->hccr);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (test_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags) &&\r\n(status & MBX_INTERRUPT) && ha->flags.mbox_int) {\r\nset_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\ncomplete(&ha->mbx_intr_comp);\r\n}\r\nreturn (IRQ_HANDLED);\r\n}\r\nstatic void\r\nqla2x00_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)\r\n{\r\nuint16_t cnt;\r\nuint32_t mboxes;\r\nuint16_t __iomem *wptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nmboxes = (1 << ha->mbx_count) - 1;\r\nif (!ha->mcp)\r\nql_dbg(ql_dbg_async, vha, 0x5001, "MBX pointer ERRROR.\n");\r\nelse\r\nmboxes = ha->mcp->in_mb;\r\nha->flags.mbox_int = 1;\r\nha->mailbox_out[0] = mb0;\r\nmboxes >>= 1;\r\nwptr = (uint16_t __iomem *)MAILBOX_REG(ha, reg, 1);\r\nfor (cnt = 1; cnt < ha->mbx_count; cnt++) {\r\nif (IS_QLA2200(ha) && cnt == 8)\r\nwptr = (uint16_t __iomem *)MAILBOX_REG(ha, reg, 8);\r\nif ((cnt == 4 || cnt == 5) && (mboxes & BIT_0))\r\nha->mailbox_out[cnt] = qla2x00_debounce_register(wptr);\r\nelse if (mboxes & BIT_0)\r\nha->mailbox_out[cnt] = RD_REG_WORD(wptr);\r\nwptr++;\r\nmboxes >>= 1;\r\n}\r\n}\r\nstatic void\r\nqla81xx_idc_event(scsi_qla_host_t *vha, uint16_t aen, uint16_t descr)\r\n{\r\nstatic char *event[] =\r\n{ "Complete", "Request Notification", "Time Extension" };\r\nint rval;\r\nstruct device_reg_24xx __iomem *reg24 = &vha->hw->iobase->isp24;\r\nuint16_t __iomem *wptr;\r\nuint16_t cnt, timeout, mb[QLA_IDC_ACK_REGS];\r\nwptr = (uint16_t __iomem *)&reg24->mailbox1;\r\nfor (cnt = 0; cnt < QLA_IDC_ACK_REGS; cnt++, wptr++)\r\nmb[cnt] = RD_REG_WORD(wptr);\r\nql_dbg(ql_dbg_async, vha, 0x5021,\r\n"Inter-Driver Communication %s -- "\r\n"%04x %04x %04x %04x %04x %04x %04x.\n",\r\nevent[aen & 0xff], mb[0], mb[1], mb[2], mb[3],\r\nmb[4], mb[5], mb[6]);\r\ntimeout = (descr >> 8) & 0xf;\r\nif (aen != MBA_IDC_NOTIFY || !timeout)\r\nreturn;\r\nql_dbg(ql_dbg_async, vha, 0x5022,\r\n"%lu Inter-Driver Communication %s -- ACK timeout=%d.\n",\r\nvha->host_no, event[aen & 0xff], timeout);\r\nrval = qla2x00_post_idc_ack_work(vha, mb);\r\nif (rval != QLA_SUCCESS)\r\nql_log(ql_log_warn, vha, 0x5023,\r\n"IDC failed to post ACK.\n");\r\n}\r\nchar *\r\nqla2x00_get_link_speed_str(struct qla_hw_data *ha)\r\n{\r\nstatic char *link_speeds[] = {"1", "2", "?", "4", "8", "16", "10"};\r\nchar *link_speed;\r\nint fw_speed = ha->link_data_rate;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nlink_speed = link_speeds[0];\r\nelse if (fw_speed == 0x13)\r\nlink_speed = link_speeds[6];\r\nelse {\r\nlink_speed = link_speeds[LS_UNKNOWN];\r\nif (fw_speed < 6)\r\nlink_speed =\r\nlink_speeds[fw_speed];\r\n}\r\nreturn link_speed;\r\n}\r\nvoid\r\nqla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)\r\n{\r\nuint16_t handle_cnt;\r\nuint16_t cnt, mbx;\r\nuint32_t handles[5];\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nstruct device_reg_24xx __iomem *reg24 = &ha->iobase->isp24;\r\nstruct device_reg_82xx __iomem *reg82 = &ha->iobase->isp82;\r\nuint32_t rscn_entry, host_pid;\r\nunsigned long flags;\r\nhandle_cnt = 0;\r\nif (IS_CNA_CAPABLE(ha))\r\ngoto skip_rio;\r\nswitch (mb[0]) {\r\ncase MBA_SCSI_COMPLETION:\r\nhandles[0] = le32_to_cpu((uint32_t)((mb[2] << 16) | mb[1]));\r\nhandle_cnt = 1;\r\nbreak;\r\ncase MBA_CMPLT_1_16BIT:\r\nhandles[0] = mb[1];\r\nhandle_cnt = 1;\r\nmb[0] = MBA_SCSI_COMPLETION;\r\nbreak;\r\ncase MBA_CMPLT_2_16BIT:\r\nhandles[0] = mb[1];\r\nhandles[1] = mb[2];\r\nhandle_cnt = 2;\r\nmb[0] = MBA_SCSI_COMPLETION;\r\nbreak;\r\ncase MBA_CMPLT_3_16BIT:\r\nhandles[0] = mb[1];\r\nhandles[1] = mb[2];\r\nhandles[2] = mb[3];\r\nhandle_cnt = 3;\r\nmb[0] = MBA_SCSI_COMPLETION;\r\nbreak;\r\ncase MBA_CMPLT_4_16BIT:\r\nhandles[0] = mb[1];\r\nhandles[1] = mb[2];\r\nhandles[2] = mb[3];\r\nhandles[3] = (uint32_t)RD_MAILBOX_REG(ha, reg, 6);\r\nhandle_cnt = 4;\r\nmb[0] = MBA_SCSI_COMPLETION;\r\nbreak;\r\ncase MBA_CMPLT_5_16BIT:\r\nhandles[0] = mb[1];\r\nhandles[1] = mb[2];\r\nhandles[2] = mb[3];\r\nhandles[3] = (uint32_t)RD_MAILBOX_REG(ha, reg, 6);\r\nhandles[4] = (uint32_t)RD_MAILBOX_REG(ha, reg, 7);\r\nhandle_cnt = 5;\r\nmb[0] = MBA_SCSI_COMPLETION;\r\nbreak;\r\ncase MBA_CMPLT_2_32BIT:\r\nhandles[0] = le32_to_cpu((uint32_t)((mb[2] << 16) | mb[1]));\r\nhandles[1] = le32_to_cpu(\r\n((uint32_t)(RD_MAILBOX_REG(ha, reg, 7) << 16)) |\r\nRD_MAILBOX_REG(ha, reg, 6));\r\nhandle_cnt = 2;\r\nmb[0] = MBA_SCSI_COMPLETION;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nskip_rio:\r\nswitch (mb[0]) {\r\ncase MBA_SCSI_COMPLETION:\r\nif (!vha->flags.online)\r\nbreak;\r\nfor (cnt = 0; cnt < handle_cnt; cnt++)\r\nqla2x00_process_completed_request(vha, rsp->req,\r\nhandles[cnt]);\r\nbreak;\r\ncase MBA_RESET:\r\nql_dbg(ql_dbg_async, vha, 0x5002,\r\n"Asynchronous RESET.\n");\r\nset_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\r\nbreak;\r\ncase MBA_SYSTEM_ERR:\r\nmbx = (IS_QLA81XX(ha) || IS_QLA83XX(ha)) ?\r\nRD_REG_WORD(&reg24->mailbox7) : 0;\r\nql_log(ql_log_warn, vha, 0x5003,\r\n"ISP System Error - mbx1=%xh mbx2=%xh mbx3=%xh "\r\n"mbx7=%xh.\n", mb[1], mb[2], mb[3], mbx);\r\nha->isp_ops->fw_dump(vha, 1);\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nif (mb[1] == 0 && mb[2] == 0) {\r\nql_log(ql_log_fatal, vha, 0x5004,\r\n"Unrecoverable Hardware Error: adapter "\r\n"marked OFFLINE!\n");\r\nvha->flags.online = 0;\r\nvha->device_flags |= DFLG_DEV_FAILED;\r\n} else {\r\nif ((mbx & MBX_3) && (ha->flags.port0))\r\nset_bit(MPI_RESET_NEEDED,\r\n&vha->dpc_flags);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\n}\r\n} else if (mb[1] == 0) {\r\nql_log(ql_log_fatal, vha, 0x5005,\r\n"Unrecoverable Hardware Error: adapter marked "\r\n"OFFLINE!\n");\r\nvha->flags.online = 0;\r\nvha->device_flags |= DFLG_DEV_FAILED;\r\n} else\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\ncase MBA_REQ_TRANSFER_ERR:\r\nql_log(ql_log_warn, vha, 0x5006,\r\n"ISP Request Transfer Error (%x).\n", mb[1]);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\ncase MBA_RSP_TRANSFER_ERR:\r\nql_log(ql_log_warn, vha, 0x5007,\r\n"ISP Response Transfer Error.\n");\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\ncase MBA_WAKEUP_THRES:\r\nql_dbg(ql_dbg_async, vha, 0x5008,\r\n"Asynchronous WAKEUP_THRES.\n");\r\nbreak;\r\ncase MBA_LIP_OCCURRED:\r\nql_dbg(ql_dbg_async, vha, 0x5009,\r\n"LIP occurred (%x).\n", mb[1]);\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\natomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\n}\r\nif (vha->vp_idx) {\r\natomic_set(&vha->vp_state, VP_FAILED);\r\nfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\r\n}\r\nset_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags);\r\nset_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);\r\nvha->flags.management_server_logged_in = 0;\r\nqla2x00_post_aen_work(vha, FCH_EVT_LIP, mb[1]);\r\nbreak;\r\ncase MBA_LOOP_UP:\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha))\r\nha->link_data_rate = PORT_SPEED_1GB;\r\nelse\r\nha->link_data_rate = mb[1];\r\nql_dbg(ql_dbg_async, vha, 0x500a,\r\n"LOOP UP detected (%s Gbps).\n",\r\nqla2x00_get_link_speed_str(ha));\r\nvha->flags.management_server_logged_in = 0;\r\nqla2x00_post_aen_work(vha, FCH_EVT_LINKUP, ha->link_data_rate);\r\nbreak;\r\ncase MBA_LOOP_DOWN:\r\nmbx = (IS_QLA81XX(ha) || IS_QLA8031(ha))\r\n? RD_REG_WORD(&reg24->mailbox4) : 0;\r\nmbx = IS_QLA82XX(ha) ? RD_REG_WORD(&reg82->mailbox_out[4]) : mbx;\r\nql_dbg(ql_dbg_async, vha, 0x500b,\r\n"LOOP DOWN detected (%x %x %x %x).\n",\r\nmb[1], mb[2], mb[3], mbx);\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\natomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\r\nvha->device_flags |= DFLG_NO_CABLE;\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\n}\r\nif (vha->vp_idx) {\r\natomic_set(&vha->vp_state, VP_FAILED);\r\nfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\r\n}\r\nvha->flags.management_server_logged_in = 0;\r\nha->link_data_rate = PORT_SPEED_UNKNOWN;\r\nqla2x00_post_aen_work(vha, FCH_EVT_LINKDOWN, 0);\r\nbreak;\r\ncase MBA_LIP_RESET:\r\nql_dbg(ql_dbg_async, vha, 0x500c,\r\n"LIP reset occurred (%x).\n", mb[1]);\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\natomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\n}\r\nif (vha->vp_idx) {\r\natomic_set(&vha->vp_state, VP_FAILED);\r\nfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\r\n}\r\nset_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\r\nha->operating_mode = LOOP;\r\nvha->flags.management_server_logged_in = 0;\r\nqla2x00_post_aen_work(vha, FCH_EVT_LIPRESET, mb[1]);\r\nbreak;\r\ncase MBA_POINT_TO_POINT:\r\nif (IS_QLA2100(ha))\r\nbreak;\r\nif (IS_QLA81XX(ha) || IS_QLA82XX(ha) || IS_QLA8031(ha)) {\r\nql_dbg(ql_dbg_async, vha, 0x500d,\r\n"DCBX Completed -- %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nif (ha->notify_dcbx_comp)\r\ncomplete(&ha->dcbx_comp);\r\n} else\r\nql_dbg(ql_dbg_async, vha, 0x500e,\r\n"Asynchronous P2P MODE received.\n");\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\nif (!atomic_read(&vha->loop_down_timer))\r\natomic_set(&vha->loop_down_timer,\r\nLOOP_DOWN_TIME);\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\n}\r\nif (vha->vp_idx) {\r\natomic_set(&vha->vp_state, VP_FAILED);\r\nfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\r\n}\r\nif (!(test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)))\r\nset_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\r\nset_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags);\r\nset_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);\r\nha->flags.gpsc_supported = 1;\r\nvha->flags.management_server_logged_in = 0;\r\nbreak;\r\ncase MBA_CHG_IN_CONNECTION:\r\nif (IS_QLA2100(ha))\r\nbreak;\r\nql_dbg(ql_dbg_async, vha, 0x500f,\r\n"Configuration change detected: value=%x.\n", mb[1]);\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\nif (!atomic_read(&vha->loop_down_timer))\r\natomic_set(&vha->loop_down_timer,\r\nLOOP_DOWN_TIME);\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\n}\r\nif (vha->vp_idx) {\r\natomic_set(&vha->vp_state, VP_FAILED);\r\nfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\r\n}\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\r\nbreak;\r\ncase MBA_PORT_UPDATE:\r\nif (IS_QLA2XXX_MIDTYPE(ha) &&\r\n((mb[1] == 0xffff && (mb[3] & 0xff) != 0xff) ||\r\n(mb[1] != 0xffff)) && vha->vp_idx != (mb[3] & 0xff))\r\nbreak;\r\nif (mb[1] == 0xffff && mb[2] == 0x7) {\r\nql_dbg(ql_dbg_async, vha, 0x5010,\r\n"Port unavailable %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nql_log(ql_log_warn, vha, 0x505e,\r\n"Link is offline.\n");\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\natomic_set(&vha->loop_down_timer,\r\nLOOP_DOWN_TIME);\r\nvha->device_flags |= DFLG_NO_CABLE;\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\n}\r\nif (vha->vp_idx) {\r\natomic_set(&vha->vp_state, VP_FAILED);\r\nfc_vport_set_state(vha->fc_vport,\r\nFC_VPORT_FAILED);\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\n}\r\nvha->flags.management_server_logged_in = 0;\r\nha->link_data_rate = PORT_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\natomic_set(&vha->loop_down_timer, 0);\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN &&\r\natomic_read(&vha->loop_state) != LOOP_DEAD) {\r\nql_dbg(ql_dbg_async, vha, 0x5011,\r\n"Asynchronous PORT UPDATE ignored %04x/%04x/%04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nqlt_async_event(mb[0], vha, mb);\r\nbreak;\r\n}\r\nql_dbg(ql_dbg_async, vha, 0x5012,\r\n"Port database changed %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nql_log(ql_log_warn, vha, 0x505f,\r\n"Link is operational (%s Gbps).\n",\r\nqla2x00_get_link_speed_str(ha));\r\natomic_set(&vha->loop_state, LOOP_UP);\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\nif (vha->vp_idx == 0 && !qla_ini_mode_enabled(vha))\r\nset_bit(SCR_PENDING, &vha->dpc_flags);\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\r\nqlt_async_event(mb[0], vha, mb);\r\nbreak;\r\ncase MBA_RSCN_UPDATE:\r\nif (vha->vp_idx && test_bit(VP_SCR_NEEDED, &vha->vp_flags))\r\nbreak;\r\nif (ha->flags.npiv_supported && vha->vp_idx != (mb[3] & 0xff))\r\nbreak;\r\nql_dbg(ql_dbg_async, vha, 0x5013,\r\n"RSCN database changed -- %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nrscn_entry = ((mb[1] & 0xff) << 16) | mb[2];\r\nhost_pid = (vha->d_id.b.domain << 16) | (vha->d_id.b.area << 8)\r\n| vha->d_id.b.al_pa;\r\nif (rscn_entry == host_pid) {\r\nql_dbg(ql_dbg_async, vha, 0x5014,\r\n"Ignoring RSCN update to local host "\r\n"port ID (%06x).\n", host_pid);\r\nbreak;\r\n}\r\nrscn_entry = ((mb[1] & 0x3ff) << 16) | mb[2];\r\natomic_set(&vha->loop_down_timer, 0);\r\nvha->flags.management_server_logged_in = 0;\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nset_bit(RSCN_UPDATE, &vha->dpc_flags);\r\nqla2x00_post_aen_work(vha, FCH_EVT_RSCN, rscn_entry);\r\nbreak;\r\ncase MBA_ZIO_RESPONSE:\r\nql_dbg(ql_dbg_async, vha, 0x5015,\r\n"[R|Z]IO update completion.\n");\r\nif (IS_FWI2_CAPABLE(ha))\r\nqla24xx_process_response_queue(vha, rsp);\r\nelse\r\nqla2x00_process_response_queue(rsp);\r\nbreak;\r\ncase MBA_DISCARD_RND_FRAME:\r\nql_dbg(ql_dbg_async, vha, 0x5016,\r\n"Discard RND Frame -- %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nbreak;\r\ncase MBA_TRACE_NOTIFICATION:\r\nql_dbg(ql_dbg_async, vha, 0x5017,\r\n"Trace Notification -- %04x %04x.\n", mb[1], mb[2]);\r\nbreak;\r\ncase MBA_ISP84XX_ALERT:\r\nql_dbg(ql_dbg_async, vha, 0x5018,\r\n"ISP84XX Alert Notification -- %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nspin_lock_irqsave(&ha->cs84xx->access_lock, flags);\r\nswitch (mb[1]) {\r\ncase A84_PANIC_RECOVERY:\r\nql_log(ql_log_info, vha, 0x5019,\r\n"Alert 84XX: panic recovery %04x %04x.\n",\r\nmb[2], mb[3]);\r\nbreak;\r\ncase A84_OP_LOGIN_COMPLETE:\r\nha->cs84xx->op_fw_version = mb[3] << 16 | mb[2];\r\nql_log(ql_log_info, vha, 0x501a,\r\n"Alert 84XX: firmware version %x.\n",\r\nha->cs84xx->op_fw_version);\r\nbreak;\r\ncase A84_DIAG_LOGIN_COMPLETE:\r\nha->cs84xx->diag_fw_version = mb[3] << 16 | mb[2];\r\nql_log(ql_log_info, vha, 0x501b,\r\n"Alert 84XX: diagnostic firmware version %x.\n",\r\nha->cs84xx->diag_fw_version);\r\nbreak;\r\ncase A84_GOLD_LOGIN_COMPLETE:\r\nha->cs84xx->diag_fw_version = mb[3] << 16 | mb[2];\r\nha->cs84xx->fw_update = 1;\r\nql_log(ql_log_info, vha, 0x501c,\r\n"Alert 84XX: gold firmware version %x.\n",\r\nha->cs84xx->gold_fw_version);\r\nbreak;\r\ndefault:\r\nql_log(ql_log_warn, vha, 0x501d,\r\n"Alert 84xx: Invalid Alert %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\n}\r\nspin_unlock_irqrestore(&ha->cs84xx->access_lock, flags);\r\nbreak;\r\ncase MBA_DCBX_START:\r\nql_dbg(ql_dbg_async, vha, 0x501e,\r\n"DCBX Started -- %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nbreak;\r\ncase MBA_DCBX_PARAM_UPDATE:\r\nql_dbg(ql_dbg_async, vha, 0x501f,\r\n"DCBX Parameters Updated -- %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nbreak;\r\ncase MBA_FCF_CONF_ERR:\r\nql_dbg(ql_dbg_async, vha, 0x5020,\r\n"FCF Configuration Error -- %04x %04x %04x.\n",\r\nmb[1], mb[2], mb[3]);\r\nbreak;\r\ncase MBA_IDC_COMPLETE:\r\ncase MBA_IDC_NOTIFY:\r\ncase MBA_IDC_TIME_EXT:\r\nqla81xx_idc_event(vha, mb[0], mb[1]);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_async, vha, 0x5057,\r\n"Unknown AEN:%04x %04x %04x %04x\n",\r\nmb[0], mb[1], mb[2], mb[3]);\r\n}\r\nqlt_async_event(mb[0], vha, mb);\r\nif (!vha->vp_idx && ha->num_vhosts)\r\nqla2x00_alert_all_vps(rsp, mb);\r\n}\r\nstatic void\r\nqla2x00_process_completed_request(struct scsi_qla_host *vha,\r\nstruct req_que *req, uint32_t index)\r\n{\r\nsrb_t *sp;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (index >= MAX_OUTSTANDING_COMMANDS) {\r\nql_log(ql_log_warn, vha, 0x3014,\r\n"Invalid SCSI command index (%x).\n", index);\r\nif (IS_QLA82XX(ha))\r\nset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\r\nelse\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nreturn;\r\n}\r\nsp = req->outstanding_cmds[index];\r\nif (sp) {\r\nreq->outstanding_cmds[index] = NULL;\r\nsp->done(ha, sp, DID_OK << 16);\r\n} else {\r\nql_log(ql_log_warn, vha, 0x3016, "Invalid SCSI SRB.\n");\r\nif (IS_QLA82XX(ha))\r\nset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\r\nelse\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\n}\r\n}\r\nstatic srb_t *\r\nqla2x00_get_sp_from_handle(scsi_qla_host_t *vha, const char *func,\r\nstruct req_que *req, void *iocb)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nsts_entry_t *pkt = iocb;\r\nsrb_t *sp = NULL;\r\nuint16_t index;\r\nindex = LSW(pkt->handle);\r\nif (index >= MAX_OUTSTANDING_COMMANDS) {\r\nql_log(ql_log_warn, vha, 0x5031,\r\n"Invalid command index (%x).\n", index);\r\nif (IS_QLA82XX(ha))\r\nset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\r\nelse\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\ngoto done;\r\n}\r\nsp = req->outstanding_cmds[index];\r\nif (!sp) {\r\nql_log(ql_log_warn, vha, 0x5032,\r\n"Invalid completion handle (%x) -- timed-out.\n", index);\r\nreturn sp;\r\n}\r\nif (sp->handle != index) {\r\nql_log(ql_log_warn, vha, 0x5033,\r\n"SRB handle (%x) mismatch %x.\n", sp->handle, index);\r\nreturn NULL;\r\n}\r\nreq->outstanding_cmds[index] = NULL;\r\ndone:\r\nreturn sp;\r\n}\r\nstatic void\r\nqla2x00_mbx_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\r\nstruct mbx_entry *mbx)\r\n{\r\nconst char func[] = "MBX-IOCB";\r\nconst char *type;\r\nfc_port_t *fcport;\r\nsrb_t *sp;\r\nstruct srb_iocb *lio;\r\nuint16_t *data;\r\nuint16_t status;\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, mbx);\r\nif (!sp)\r\nreturn;\r\nlio = &sp->u.iocb_cmd;\r\ntype = sp->name;\r\nfcport = sp->fcport;\r\ndata = lio->u.logio.data;\r\ndata[0] = MBS_COMMAND_ERROR;\r\ndata[1] = lio->u.logio.flags & SRB_LOGIN_RETRIED ?\r\nQLA_LOGIO_LOGIN_RETRIED : 0;\r\nif (mbx->entry_status) {\r\nql_dbg(ql_dbg_async, vha, 0x5043,\r\n"Async-%s error entry - hdl=%x portid=%02x%02x%02x "\r\n"entry-status=%x status=%x state-flag=%x "\r\n"status-flags=%x.\n", type, sp->handle,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa, mbx->entry_status,\r\nle16_to_cpu(mbx->status), le16_to_cpu(mbx->state_flags),\r\nle16_to_cpu(mbx->status_flags));\r\nql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5029,\r\n(uint8_t *)mbx, sizeof(*mbx));\r\ngoto logio_done;\r\n}\r\nstatus = le16_to_cpu(mbx->status);\r\nif (status == 0x30 && sp->type == SRB_LOGIN_CMD &&\r\nle16_to_cpu(mbx->mb0) == MBS_COMMAND_COMPLETE)\r\nstatus = 0;\r\nif (!status && le16_to_cpu(mbx->mb0) == MBS_COMMAND_COMPLETE) {\r\nql_dbg(ql_dbg_async, vha, 0x5045,\r\n"Async-%s complete - hdl=%x portid=%02x%02x%02x mbx1=%x.\n",\r\ntype, sp->handle, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa,\r\nle16_to_cpu(mbx->mb1));\r\ndata[0] = MBS_COMMAND_COMPLETE;\r\nif (sp->type == SRB_LOGIN_CMD) {\r\nfcport->port_type = FCT_TARGET;\r\nif (le16_to_cpu(mbx->mb1) & BIT_0)\r\nfcport->port_type = FCT_INITIATOR;\r\nelse if (le16_to_cpu(mbx->mb1) & BIT_1)\r\nfcport->flags |= FCF_FCP2_DEVICE;\r\n}\r\ngoto logio_done;\r\n}\r\ndata[0] = le16_to_cpu(mbx->mb0);\r\nswitch (data[0]) {\r\ncase MBS_PORT_ID_USED:\r\ndata[1] = le16_to_cpu(mbx->mb1);\r\nbreak;\r\ncase MBS_LOOP_ID_USED:\r\nbreak;\r\ndefault:\r\ndata[0] = MBS_COMMAND_ERROR;\r\nbreak;\r\n}\r\nql_log(ql_log_warn, vha, 0x5046,\r\n"Async-%s failed - hdl=%x portid=%02x%02x%02x status=%x "\r\n"mb0=%x mb1=%x mb2=%x mb6=%x mb7=%x.\n", type, sp->handle,\r\nfcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa,\r\nstatus, le16_to_cpu(mbx->mb0), le16_to_cpu(mbx->mb1),\r\nle16_to_cpu(mbx->mb2), le16_to_cpu(mbx->mb6),\r\nle16_to_cpu(mbx->mb7));\r\nlogio_done:\r\nsp->done(vha, sp, 0);\r\n}\r\nstatic void\r\nqla2x00_ct_entry(scsi_qla_host_t *vha, struct req_que *req,\r\nsts_entry_t *pkt, int iocb_type)\r\n{\r\nconst char func[] = "CT_IOCB";\r\nconst char *type;\r\nsrb_t *sp;\r\nstruct fc_bsg_job *bsg_job;\r\nuint16_t comp_status;\r\nint res;\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\r\nif (!sp)\r\nreturn;\r\nbsg_job = sp->u.bsg_job;\r\ntype = "ct pass-through";\r\ncomp_status = le16_to_cpu(pkt->comp_status);\r\nbsg_job->reply->reply_data.ctels_reply.status = FC_CTELS_STATUS_OK;\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply);\r\nif (comp_status != CS_COMPLETE) {\r\nif (comp_status == CS_DATA_UNDERRUN) {\r\nres = DID_OK << 16;\r\nbsg_job->reply->reply_payload_rcv_len =\r\nle16_to_cpu(((sts_entry_t *)pkt)->rsp_info_len);\r\nql_log(ql_log_warn, vha, 0x5048,\r\n"CT pass-through-%s error "\r\n"comp_status-status=0x%x total_byte = 0x%x.\n",\r\ntype, comp_status,\r\nbsg_job->reply->reply_payload_rcv_len);\r\n} else {\r\nql_log(ql_log_warn, vha, 0x5049,\r\n"CT pass-through-%s error "\r\n"comp_status-status=0x%x.\n", type, comp_status);\r\nres = DID_ERROR << 16;\r\nbsg_job->reply->reply_payload_rcv_len = 0;\r\n}\r\nql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5035,\r\n(uint8_t *)pkt, sizeof(*pkt));\r\n} else {\r\nres = DID_OK << 16;\r\nbsg_job->reply->reply_payload_rcv_len =\r\nbsg_job->reply_payload.payload_len;\r\nbsg_job->reply_len = 0;\r\n}\r\nsp->done(vha, sp, res);\r\n}\r\nstatic void\r\nqla24xx_els_ct_entry(scsi_qla_host_t *vha, struct req_que *req,\r\nstruct sts_entry_24xx *pkt, int iocb_type)\r\n{\r\nconst char func[] = "ELS_CT_IOCB";\r\nconst char *type;\r\nsrb_t *sp;\r\nstruct fc_bsg_job *bsg_job;\r\nuint16_t comp_status;\r\nuint32_t fw_status[3];\r\nuint8_t* fw_sts_ptr;\r\nint res;\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\r\nif (!sp)\r\nreturn;\r\nbsg_job = sp->u.bsg_job;\r\ntype = NULL;\r\nswitch (sp->type) {\r\ncase SRB_ELS_CMD_RPT:\r\ncase SRB_ELS_CMD_HST:\r\ntype = "els";\r\nbreak;\r\ncase SRB_CT_CMD:\r\ntype = "ct pass-through";\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_user, vha, 0x503e,\r\n"Unrecognized SRB: (%p) type=%d.\n", sp, sp->type);\r\nreturn;\r\n}\r\ncomp_status = fw_status[0] = le16_to_cpu(pkt->comp_status);\r\nfw_status[1] = le16_to_cpu(((struct els_sts_entry_24xx*)pkt)->error_subcode_1);\r\nfw_status[2] = le16_to_cpu(((struct els_sts_entry_24xx*)pkt)->error_subcode_2);\r\nbsg_job->reply->reply_data.ctels_reply.status = FC_CTELS_STATUS_OK;\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply) + sizeof(fw_status);\r\nif (comp_status != CS_COMPLETE) {\r\nif (comp_status == CS_DATA_UNDERRUN) {\r\nres = DID_OK << 16;\r\nbsg_job->reply->reply_payload_rcv_len =\r\nle16_to_cpu(((struct els_sts_entry_24xx *)pkt)->total_byte_count);\r\nql_dbg(ql_dbg_user, vha, 0x503f,\r\n"ELS-CT pass-through-%s error hdl=%x comp_status-status=0x%x "\r\n"error subcode 1=0x%x error subcode 2=0x%x total_byte = 0x%x.\n",\r\ntype, sp->handle, comp_status, fw_status[1], fw_status[2],\r\nle16_to_cpu(((struct els_sts_entry_24xx *)\r\npkt)->total_byte_count));\r\nfw_sts_ptr = ((uint8_t*)bsg_job->req->sense) + sizeof(struct fc_bsg_reply);\r\nmemcpy( fw_sts_ptr, fw_status, sizeof(fw_status));\r\n}\r\nelse {\r\nql_dbg(ql_dbg_user, vha, 0x5040,\r\n"ELS-CT pass-through-%s error hdl=%x comp_status-status=0x%x "\r\n"error subcode 1=0x%x error subcode 2=0x%x.\n",\r\ntype, sp->handle, comp_status,\r\nle16_to_cpu(((struct els_sts_entry_24xx *)\r\npkt)->error_subcode_1),\r\nle16_to_cpu(((struct els_sts_entry_24xx *)\r\npkt)->error_subcode_2));\r\nres = DID_ERROR << 16;\r\nbsg_job->reply->reply_payload_rcv_len = 0;\r\nfw_sts_ptr = ((uint8_t*)bsg_job->req->sense) + sizeof(struct fc_bsg_reply);\r\nmemcpy( fw_sts_ptr, fw_status, sizeof(fw_status));\r\n}\r\nql_dump_buffer(ql_dbg_user + ql_dbg_buffer, vha, 0x5056,\r\n(uint8_t *)pkt, sizeof(*pkt));\r\n}\r\nelse {\r\nres = DID_OK << 16;\r\nbsg_job->reply->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;\r\nbsg_job->reply_len = 0;\r\n}\r\nsp->done(vha, sp, res);\r\n}\r\nstatic void\r\nqla24xx_logio_entry(scsi_qla_host_t *vha, struct req_que *req,\r\nstruct logio_entry_24xx *logio)\r\n{\r\nconst char func[] = "LOGIO-IOCB";\r\nconst char *type;\r\nfc_port_t *fcport;\r\nsrb_t *sp;\r\nstruct srb_iocb *lio;\r\nuint16_t *data;\r\nuint32_t iop[2];\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, logio);\r\nif (!sp)\r\nreturn;\r\nlio = &sp->u.iocb_cmd;\r\ntype = sp->name;\r\nfcport = sp->fcport;\r\ndata = lio->u.logio.data;\r\ndata[0] = MBS_COMMAND_ERROR;\r\ndata[1] = lio->u.logio.flags & SRB_LOGIN_RETRIED ?\r\nQLA_LOGIO_LOGIN_RETRIED : 0;\r\nif (logio->entry_status) {\r\nql_log(ql_log_warn, fcport->vha, 0x5034,\r\n"Async-%s error entry - hdl=%x"\r\n"portid=%02x%02x%02x entry-status=%x.\n",\r\ntype, sp->handle, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa,\r\nlogio->entry_status);\r\nql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x504d,\r\n(uint8_t *)logio, sizeof(*logio));\r\ngoto logio_done;\r\n}\r\nif (le16_to_cpu(logio->comp_status) == CS_COMPLETE) {\r\nql_dbg(ql_dbg_async, fcport->vha, 0x5036,\r\n"Async-%s complete - hdl=%x portid=%02x%02x%02x "\r\n"iop0=%x.\n", type, sp->handle, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa,\r\nle32_to_cpu(logio->io_parameter[0]));\r\ndata[0] = MBS_COMMAND_COMPLETE;\r\nif (sp->type != SRB_LOGIN_CMD)\r\ngoto logio_done;\r\niop[0] = le32_to_cpu(logio->io_parameter[0]);\r\nif (iop[0] & BIT_4) {\r\nfcport->port_type = FCT_TARGET;\r\nif (iop[0] & BIT_8)\r\nfcport->flags |= FCF_FCP2_DEVICE;\r\n} else if (iop[0] & BIT_5)\r\nfcport->port_type = FCT_INITIATOR;\r\nif (iop[0] & BIT_7)\r\nfcport->flags |= FCF_CONF_COMP_SUPPORTED;\r\nif (logio->io_parameter[7] || logio->io_parameter[8])\r\nfcport->supported_classes |= FC_COS_CLASS2;\r\nif (logio->io_parameter[9] || logio->io_parameter[10])\r\nfcport->supported_classes |= FC_COS_CLASS3;\r\ngoto logio_done;\r\n}\r\niop[0] = le32_to_cpu(logio->io_parameter[0]);\r\niop[1] = le32_to_cpu(logio->io_parameter[1]);\r\nswitch (iop[0]) {\r\ncase LSC_SCODE_PORTID_USED:\r\ndata[0] = MBS_PORT_ID_USED;\r\ndata[1] = LSW(iop[1]);\r\nbreak;\r\ncase LSC_SCODE_NPORT_USED:\r\ndata[0] = MBS_LOOP_ID_USED;\r\nbreak;\r\ndefault:\r\ndata[0] = MBS_COMMAND_ERROR;\r\nbreak;\r\n}\r\nql_dbg(ql_dbg_async, fcport->vha, 0x5037,\r\n"Async-%s failed - hdl=%x portid=%02x%02x%02x comp=%x "\r\n"iop0=%x iop1=%x.\n", type, sp->handle, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa,\r\nle16_to_cpu(logio->comp_status),\r\nle32_to_cpu(logio->io_parameter[0]),\r\nle32_to_cpu(logio->io_parameter[1]));\r\nlogio_done:\r\nsp->done(vha, sp, 0);\r\n}\r\nstatic void\r\nqla24xx_tm_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\r\nstruct tsk_mgmt_entry *tsk)\r\n{\r\nconst char func[] = "TMF-IOCB";\r\nconst char *type;\r\nfc_port_t *fcport;\r\nsrb_t *sp;\r\nstruct srb_iocb *iocb;\r\nstruct sts_entry_24xx *sts = (struct sts_entry_24xx *)tsk;\r\nint error = 1;\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, tsk);\r\nif (!sp)\r\nreturn;\r\niocb = &sp->u.iocb_cmd;\r\ntype = sp->name;\r\nfcport = sp->fcport;\r\nif (sts->entry_status) {\r\nql_log(ql_log_warn, fcport->vha, 0x5038,\r\n"Async-%s error - hdl=%x entry-status(%x).\n",\r\ntype, sp->handle, sts->entry_status);\r\n} else if (sts->comp_status != __constant_cpu_to_le16(CS_COMPLETE)) {\r\nql_log(ql_log_warn, fcport->vha, 0x5039,\r\n"Async-%s error - hdl=%x completion status(%x).\n",\r\ntype, sp->handle, sts->comp_status);\r\n} else if (!(le16_to_cpu(sts->scsi_status) &\r\nSS_RESPONSE_INFO_LEN_VALID)) {\r\nql_log(ql_log_warn, fcport->vha, 0x503a,\r\n"Async-%s error - hdl=%x no response info(%x).\n",\r\ntype, sp->handle, sts->scsi_status);\r\n} else if (le32_to_cpu(sts->rsp_data_len) < 4) {\r\nql_log(ql_log_warn, fcport->vha, 0x503b,\r\n"Async-%s error - hdl=%x not enough response(%d).\n",\r\ntype, sp->handle, sts->rsp_data_len);\r\n} else if (sts->data[3]) {\r\nql_log(ql_log_warn, fcport->vha, 0x503c,\r\n"Async-%s error - hdl=%x response(%x).\n",\r\ntype, sp->handle, sts->data[3]);\r\n} else {\r\nerror = 0;\r\n}\r\nif (error) {\r\niocb->u.tmf.data = error;\r\nql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5055,\r\n(uint8_t *)sts, sizeof(*sts));\r\n}\r\nsp->done(vha, sp, 0);\r\n}\r\nvoid\r\nqla2x00_process_response_queue(struct rsp_que *rsp)\r\n{\r\nstruct scsi_qla_host *vha;\r\nstruct qla_hw_data *ha = rsp->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nsts_entry_t *pkt;\r\nuint16_t handle_cnt;\r\nuint16_t cnt;\r\nvha = pci_get_drvdata(ha->pdev);\r\nif (!vha->flags.online)\r\nreturn;\r\nwhile (rsp->ring_ptr->signature != RESPONSE_PROCESSED) {\r\npkt = (sts_entry_t *)rsp->ring_ptr;\r\nrsp->ring_index++;\r\nif (rsp->ring_index == rsp->length) {\r\nrsp->ring_index = 0;\r\nrsp->ring_ptr = rsp->ring;\r\n} else {\r\nrsp->ring_ptr++;\r\n}\r\nif (pkt->entry_status != 0) {\r\nqla2x00_error_entry(vha, rsp, pkt);\r\n((response_t *)pkt)->signature = RESPONSE_PROCESSED;\r\nwmb();\r\ncontinue;\r\n}\r\nswitch (pkt->entry_type) {\r\ncase STATUS_TYPE:\r\nqla2x00_status_entry(vha, rsp, pkt);\r\nbreak;\r\ncase STATUS_TYPE_21:\r\nhandle_cnt = ((sts21_entry_t *)pkt)->handle_count;\r\nfor (cnt = 0; cnt < handle_cnt; cnt++) {\r\nqla2x00_process_completed_request(vha, rsp->req,\r\n((sts21_entry_t *)pkt)->handle[cnt]);\r\n}\r\nbreak;\r\ncase STATUS_TYPE_22:\r\nhandle_cnt = ((sts22_entry_t *)pkt)->handle_count;\r\nfor (cnt = 0; cnt < handle_cnt; cnt++) {\r\nqla2x00_process_completed_request(vha, rsp->req,\r\n((sts22_entry_t *)pkt)->handle[cnt]);\r\n}\r\nbreak;\r\ncase STATUS_CONT_TYPE:\r\nqla2x00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);\r\nbreak;\r\ncase MBX_IOCB_TYPE:\r\nqla2x00_mbx_iocb_entry(vha, rsp->req,\r\n(struct mbx_entry *)pkt);\r\nbreak;\r\ncase CT_IOCB_TYPE:\r\nqla2x00_ct_entry(vha, rsp->req, pkt, CT_IOCB_TYPE);\r\nbreak;\r\ndefault:\r\nql_log(ql_log_warn, vha, 0x504a,\r\n"Received unknown response pkt type %x "\r\n"entry status=%x.\n",\r\npkt->entry_type, pkt->entry_status);\r\nbreak;\r\n}\r\n((response_t *)pkt)->signature = RESPONSE_PROCESSED;\r\nwmb();\r\n}\r\nWRT_REG_WORD(ISP_RSP_Q_OUT(ha, reg), rsp->ring_index);\r\n}\r\nstatic inline void\r\nqla2x00_handle_sense(srb_t *sp, uint8_t *sense_data, uint32_t par_sense_len,\r\nuint32_t sense_len, struct rsp_que *rsp, int res)\r\n{\r\nstruct scsi_qla_host *vha = sp->fcport->vha;\r\nstruct scsi_cmnd *cp = GET_CMD_SP(sp);\r\nuint32_t track_sense_len;\r\nif (sense_len >= SCSI_SENSE_BUFFERSIZE)\r\nsense_len = SCSI_SENSE_BUFFERSIZE;\r\nSET_CMD_SENSE_LEN(sp, sense_len);\r\nSET_CMD_SENSE_PTR(sp, cp->sense_buffer);\r\ntrack_sense_len = sense_len;\r\nif (sense_len > par_sense_len)\r\nsense_len = par_sense_len;\r\nmemcpy(cp->sense_buffer, sense_data, sense_len);\r\nSET_CMD_SENSE_PTR(sp, cp->sense_buffer + sense_len);\r\ntrack_sense_len -= sense_len;\r\nSET_CMD_SENSE_LEN(sp, track_sense_len);\r\nif (track_sense_len != 0) {\r\nrsp->status_srb = sp;\r\ncp->result = res;\r\n}\r\nif (sense_len) {\r\nql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x301c,\r\n"Check condition Sense data, nexus%ld:%d:%d cmd=%p.\n",\r\nsp->fcport->vha->host_no, cp->device->id, cp->device->lun,\r\ncp);\r\nql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x302b,\r\ncp->sense_buffer, sense_len);\r\n}\r\n}\r\nstatic inline int\r\nqla2x00_handle_dif_error(srb_t *sp, struct sts_entry_24xx *sts24)\r\n{\r\nstruct scsi_qla_host *vha = sp->fcport->vha;\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nuint8_t *ap = &sts24->data[12];\r\nuint8_t *ep = &sts24->data[20];\r\nuint32_t e_ref_tag, a_ref_tag;\r\nuint16_t e_app_tag, a_app_tag;\r\nuint16_t e_guard, a_guard;\r\na_guard = le16_to_cpu(*(uint16_t *)(ap + 2));\r\na_app_tag = le16_to_cpu(*(uint16_t *)(ap + 0));\r\na_ref_tag = le32_to_cpu(*(uint32_t *)(ap + 4));\r\ne_guard = le16_to_cpu(*(uint16_t *)(ep + 2));\r\ne_app_tag = le16_to_cpu(*(uint16_t *)(ep + 0));\r\ne_ref_tag = le32_to_cpu(*(uint32_t *)(ep + 4));\r\nql_dbg(ql_dbg_io, vha, 0x3023,\r\n"iocb(s) %p Returned STATUS.\n", sts24);\r\nql_dbg(ql_dbg_io, vha, 0x3024,\r\n"DIF ERROR in cmd 0x%x lba 0x%llx act ref"\r\n" tag=0x%x, exp ref_tag=0x%x, act app tag=0x%x, exp app"\r\n" tag=0x%x, act guard=0x%x, exp guard=0x%x.\n",\r\ncmd->cmnd[0], (u64)scsi_get_lba(cmd), a_ref_tag, e_ref_tag,\r\na_app_tag, e_app_tag, a_guard, e_guard);\r\nif ((a_app_tag == 0xffff) &&\r\n((scsi_get_prot_type(cmd) != SCSI_PROT_DIF_TYPE3) ||\r\n(a_ref_tag == 0xffffffff))) {\r\nuint32_t blocks_done, resid;\r\nsector_t lba_s = scsi_get_lba(cmd);\r\nblocks_done = e_ref_tag - (uint32_t)lba_s + 1;\r\nresid = scsi_bufflen(cmd) - (blocks_done *\r\ncmd->device->sector_size);\r\nscsi_set_resid(cmd, resid);\r\ncmd->result = DID_OK << 16;\r\nif (scsi_prot_sg_count(cmd)) {\r\nuint32_t i, j = 0, k = 0, num_ent;\r\nstruct scatterlist *sg;\r\nstruct sd_dif_tuple *spt;\r\nscsi_for_each_prot_sg(cmd, sg,\r\nscsi_prot_sg_count(cmd), i) {\r\nnum_ent = sg_dma_len(sg) / 8;\r\nif (k + num_ent < blocks_done) {\r\nk += num_ent;\r\ncontinue;\r\n}\r\nj = blocks_done - k - 1;\r\nk = blocks_done;\r\nbreak;\r\n}\r\nif (k != blocks_done) {\r\nql_log(ql_log_warn, vha, 0x302f,\r\n"unexpected tag values tag:lba=%x:%llx)\n",\r\ne_ref_tag, (unsigned long long)lba_s);\r\nreturn 1;\r\n}\r\nspt = page_address(sg_page(sg)) + sg->offset;\r\nspt += j;\r\nspt->app_tag = 0xffff;\r\nif (scsi_get_prot_type(cmd) == SCSI_PROT_DIF_TYPE3)\r\nspt->ref_tag = 0xffffffff;\r\n}\r\nreturn 0;\r\n}\r\nif (e_guard != a_guard) {\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x1);\r\nset_driver_byte(cmd, DRIVER_SENSE);\r\nset_host_byte(cmd, DID_ABORT);\r\ncmd->result |= SAM_STAT_CHECK_CONDITION << 1;\r\nreturn 1;\r\n}\r\nif (e_ref_tag != a_ref_tag) {\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x3);\r\nset_driver_byte(cmd, DRIVER_SENSE);\r\nset_host_byte(cmd, DID_ABORT);\r\ncmd->result |= SAM_STAT_CHECK_CONDITION << 1;\r\nreturn 1;\r\n}\r\nif (e_app_tag != a_app_tag) {\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x2);\r\nset_driver_byte(cmd, DRIVER_SENSE);\r\nset_host_byte(cmd, DID_ABORT);\r\ncmd->result |= SAM_STAT_CHECK_CONDITION << 1;\r\nreturn 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nqla2x00_status_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, void *pkt)\r\n{\r\nsrb_t *sp;\r\nfc_port_t *fcport;\r\nstruct scsi_cmnd *cp;\r\nsts_entry_t *sts;\r\nstruct sts_entry_24xx *sts24;\r\nuint16_t comp_status;\r\nuint16_t scsi_status;\r\nuint16_t ox_id;\r\nuint8_t lscsi_status;\r\nint32_t resid;\r\nuint32_t sense_len, par_sense_len, rsp_info_len, resid_len,\r\nfw_resid_len;\r\nuint8_t *rsp_info, *sense_data;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t handle;\r\nuint16_t que;\r\nstruct req_que *req;\r\nint logit = 1;\r\nint res = 0;\r\nsts = (sts_entry_t *) pkt;\r\nsts24 = (struct sts_entry_24xx *) pkt;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\ncomp_status = le16_to_cpu(sts24->comp_status);\r\nscsi_status = le16_to_cpu(sts24->scsi_status) & SS_MASK;\r\n} else {\r\ncomp_status = le16_to_cpu(sts->comp_status);\r\nscsi_status = le16_to_cpu(sts->scsi_status) & SS_MASK;\r\n}\r\nhandle = (uint32_t) LSW(sts->handle);\r\nque = MSW(sts->handle);\r\nreq = ha->req_q_map[que];\r\nif (comp_status == CS_COMPLETE && scsi_status == 0) {\r\nqla2x00_process_completed_request(vha, req, handle);\r\nreturn;\r\n}\r\nif (handle < MAX_OUTSTANDING_COMMANDS) {\r\nsp = req->outstanding_cmds[handle];\r\nreq->outstanding_cmds[handle] = NULL;\r\n} else\r\nsp = NULL;\r\nif (sp == NULL) {\r\nql_dbg(ql_dbg_io, vha, 0x3017,\r\n"Invalid status handle (0x%x).\n", sts->handle);\r\nif (IS_QLA82XX(ha))\r\nset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\r\nelse\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nreturn;\r\n}\r\ncp = GET_CMD_SP(sp);\r\nif (cp == NULL) {\r\nql_dbg(ql_dbg_io, vha, 0x3018,\r\n"Command already returned (0x%x/%p).\n",\r\nsts->handle, sp);\r\nreturn;\r\n}\r\nlscsi_status = scsi_status & STATUS_MASK;\r\nfcport = sp->fcport;\r\nox_id = 0;\r\nsense_len = par_sense_len = rsp_info_len = resid_len =\r\nfw_resid_len = 0;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nif (scsi_status & SS_SENSE_LEN_VALID)\r\nsense_len = le32_to_cpu(sts24->sense_len);\r\nif (scsi_status & SS_RESPONSE_INFO_LEN_VALID)\r\nrsp_info_len = le32_to_cpu(sts24->rsp_data_len);\r\nif (scsi_status & (SS_RESIDUAL_UNDER | SS_RESIDUAL_OVER))\r\nresid_len = le32_to_cpu(sts24->rsp_residual_count);\r\nif (comp_status == CS_DATA_UNDERRUN)\r\nfw_resid_len = le32_to_cpu(sts24->residual_len);\r\nrsp_info = sts24->data;\r\nsense_data = sts24->data;\r\nhost_to_fcp_swap(sts24->data, sizeof(sts24->data));\r\nox_id = le16_to_cpu(sts24->ox_id);\r\npar_sense_len = sizeof(sts24->data);\r\n} else {\r\nif (scsi_status & SS_SENSE_LEN_VALID)\r\nsense_len = le16_to_cpu(sts->req_sense_length);\r\nif (scsi_status & SS_RESPONSE_INFO_LEN_VALID)\r\nrsp_info_len = le16_to_cpu(sts->rsp_info_len);\r\nresid_len = le32_to_cpu(sts->residual_length);\r\nrsp_info = sts->rsp_info;\r\nsense_data = sts->req_sense_data;\r\npar_sense_len = sizeof(sts->req_sense_data);\r\n}\r\nif (scsi_status & SS_RESPONSE_INFO_LEN_VALID) {\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nsense_data += rsp_info_len;\r\npar_sense_len -= rsp_info_len;\r\n}\r\nif (rsp_info_len > 3 && rsp_info[3]) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3019,\r\n"FCP I/O protocol failure (0x%x/0x%x).\n",\r\nrsp_info_len, rsp_info[3]);\r\nres = DID_BUS_BUSY << 16;\r\ngoto out;\r\n}\r\n}\r\nif (IS_FWI2_CAPABLE(ha) && comp_status == CS_COMPLETE &&\r\nscsi_status & SS_RESIDUAL_OVER)\r\ncomp_status = CS_DATA_OVERRUN;\r\nswitch (comp_status) {\r\ncase CS_COMPLETE:\r\ncase CS_QUEUE_FULL:\r\nif (scsi_status == 0) {\r\nres = DID_OK << 16;\r\nbreak;\r\n}\r\nif (scsi_status & (SS_RESIDUAL_UNDER | SS_RESIDUAL_OVER)) {\r\nresid = resid_len;\r\nscsi_set_resid(cp, resid);\r\nif (!lscsi_status &&\r\n((unsigned)(scsi_bufflen(cp) - resid) <\r\ncp->underflow)) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x301a,\r\n"Mid-layer underflow "\r\n"detected (0x%x of 0x%x bytes).\n",\r\nresid, scsi_bufflen(cp));\r\nres = DID_ERROR << 16;\r\nbreak;\r\n}\r\n}\r\nres = DID_OK << 16 | lscsi_status;\r\nif (lscsi_status == SAM_STAT_TASK_SET_FULL) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x301b,\r\n"QUEUE FULL detected.\n");\r\nbreak;\r\n}\r\nlogit = 0;\r\nif (lscsi_status != SS_CHECK_CONDITION)\r\nbreak;\r\nmemset(cp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nif (!(scsi_status & SS_SENSE_LEN_VALID))\r\nbreak;\r\nqla2x00_handle_sense(sp, sense_data, par_sense_len, sense_len,\r\nrsp, res);\r\nbreak;\r\ncase CS_DATA_UNDERRUN:\r\nresid = IS_FWI2_CAPABLE(ha) ? fw_resid_len : resid_len;\r\nscsi_set_resid(cp, resid);\r\nif (scsi_status & SS_RESIDUAL_UNDER) {\r\nif (IS_FWI2_CAPABLE(ha) && fw_resid_len != resid_len) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x301d,\r\n"Dropped frame(s) detected "\r\n"(0x%x of 0x%x bytes).\n",\r\nresid, scsi_bufflen(cp));\r\nres = DID_ERROR << 16 | lscsi_status;\r\ngoto check_scsi_status;\r\n}\r\nif (!lscsi_status &&\r\n((unsigned)(scsi_bufflen(cp) - resid) <\r\ncp->underflow)) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x301e,\r\n"Mid-layer underflow "\r\n"detected (0x%x of 0x%x bytes).\n",\r\nresid, scsi_bufflen(cp));\r\nres = DID_ERROR << 16;\r\nbreak;\r\n}\r\n} else if (lscsi_status != SAM_STAT_TASK_SET_FULL &&\r\nlscsi_status != SAM_STAT_BUSY) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x301f,\r\n"Dropped frame(s) detected (0x%x "\r\n"of 0x%x bytes).\n", resid,\r\nscsi_bufflen(cp));\r\nres = DID_ERROR << 16 | lscsi_status;\r\ngoto check_scsi_status;\r\n} else {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3030,\r\n"scsi_status: 0x%x, lscsi_status: 0x%x\n",\r\nscsi_status, lscsi_status);\r\n}\r\nres = DID_OK << 16 | lscsi_status;\r\nlogit = 0;\r\ncheck_scsi_status:\r\nif (lscsi_status != 0) {\r\nif (lscsi_status == SAM_STAT_TASK_SET_FULL) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3020,\r\n"QUEUE FULL detected.\n");\r\nlogit = 1;\r\nbreak;\r\n}\r\nif (lscsi_status != SS_CHECK_CONDITION)\r\nbreak;\r\nmemset(cp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nif (!(scsi_status & SS_SENSE_LEN_VALID))\r\nbreak;\r\nqla2x00_handle_sense(sp, sense_data, par_sense_len,\r\nsense_len, rsp, res);\r\n}\r\nbreak;\r\ncase CS_PORT_LOGGED_OUT:\r\ncase CS_PORT_CONFIG_CHG:\r\ncase CS_PORT_BUSY:\r\ncase CS_INCOMPLETE:\r\ncase CS_PORT_UNAVAILABLE:\r\ncase CS_TIMEOUT:\r\ncase CS_RESET:\r\nres = DID_TRANSPORT_DISRUPTED << 16;\r\nif (comp_status == CS_TIMEOUT) {\r\nif (IS_FWI2_CAPABLE(ha))\r\nbreak;\r\nelse if ((le16_to_cpu(sts->status_flags) &\r\nSF_LOGOUT_SENT) == 0)\r\nbreak;\r\n}\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3021,\r\n"Port down status: port-state=0x%x.\n",\r\natomic_read(&fcport->state));\r\nif (atomic_read(&fcport->state) == FCS_ONLINE)\r\nqla2x00_mark_device_lost(fcport->vha, fcport, 1, 1);\r\nbreak;\r\ncase CS_ABORTED:\r\nres = DID_RESET << 16;\r\nbreak;\r\ncase CS_DIF_ERROR:\r\nlogit = qla2x00_handle_dif_error(sp, sts24);\r\nbreak;\r\ndefault:\r\nres = DID_ERROR << 16;\r\nbreak;\r\n}\r\nout:\r\nif (logit)\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3022,\r\n"FCP command status: 0x%x-0x%x (0x%x) "\r\n"nexus=%ld:%d:%d portid=%02x%02x%02x oxid=0x%x "\r\n"cdb=%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x len=0x%x "\r\n"rsp_info=0x%x resid=0x%x fw_resid=0x%x.\n",\r\ncomp_status, scsi_status, res, vha->host_no,\r\ncp->device->id, cp->device->lun, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa, ox_id,\r\ncp->cmnd[0], cp->cmnd[1], cp->cmnd[2], cp->cmnd[3],\r\ncp->cmnd[4], cp->cmnd[5], cp->cmnd[6], cp->cmnd[7],\r\ncp->cmnd[8], cp->cmnd[9], scsi_bufflen(cp), rsp_info_len,\r\nresid_len, fw_resid_len);\r\nif (rsp->status_srb == NULL)\r\nsp->done(ha, sp, res);\r\n}\r\nstatic void\r\nqla2x00_status_cont_entry(struct rsp_que *rsp, sts_cont_entry_t *pkt)\r\n{\r\nuint8_t sense_sz = 0;\r\nstruct qla_hw_data *ha = rsp->hw;\r\nstruct scsi_qla_host *vha = pci_get_drvdata(ha->pdev);\r\nsrb_t *sp = rsp->status_srb;\r\nstruct scsi_cmnd *cp;\r\nuint32_t sense_len;\r\nuint8_t *sense_ptr;\r\nif (!sp || !GET_CMD_SENSE_LEN(sp))\r\nreturn;\r\nsense_len = GET_CMD_SENSE_LEN(sp);\r\nsense_ptr = GET_CMD_SENSE_PTR(sp);\r\ncp = GET_CMD_SP(sp);\r\nif (cp == NULL) {\r\nql_log(ql_log_warn, vha, 0x3025,\r\n"cmd is NULL: already returned to OS (sp=%p).\n", sp);\r\nrsp->status_srb = NULL;\r\nreturn;\r\n}\r\nif (sense_len > sizeof(pkt->data))\r\nsense_sz = sizeof(pkt->data);\r\nelse\r\nsense_sz = sense_len;\r\nif (IS_FWI2_CAPABLE(ha))\r\nhost_to_fcp_swap(pkt->data, sizeof(pkt->data));\r\nmemcpy(sense_ptr, pkt->data, sense_sz);\r\nql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x302c,\r\nsense_ptr, sense_sz);\r\nsense_len -= sense_sz;\r\nsense_ptr += sense_sz;\r\nSET_CMD_SENSE_PTR(sp, sense_ptr);\r\nSET_CMD_SENSE_LEN(sp, sense_len);\r\nif (sense_len == 0) {\r\nrsp->status_srb = NULL;\r\nsp->done(ha, sp, cp->result);\r\n}\r\n}\r\nstatic void\r\nqla2x00_error_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, sts_entry_t *pkt)\r\n{\r\nsrb_t *sp;\r\nstruct qla_hw_data *ha = vha->hw;\r\nconst char func[] = "ERROR-IOCB";\r\nuint16_t que = MSW(pkt->handle);\r\nstruct req_que *req = NULL;\r\nint res = DID_ERROR << 16;\r\nql_dbg(ql_dbg_async, vha, 0x502a,\r\n"type of error status in response: 0x%x\n", pkt->entry_status);\r\nif (que >= ha->max_req_queues || !ha->req_q_map[que])\r\ngoto fatal;\r\nreq = ha->req_q_map[que];\r\nif (pkt->entry_status & RF_BUSY)\r\nres = DID_BUS_BUSY << 16;\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\r\nif (sp) {\r\nsp->done(ha, sp, res);\r\nreturn;\r\n}\r\nfatal:\r\nql_log(ql_log_warn, vha, 0x5030,\r\n"Error entry - invalid handle/queue.\n");\r\nif (IS_QLA82XX(ha))\r\nset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\r\nelse\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n}\r\nstatic void\r\nqla24xx_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)\r\n{\r\nuint16_t cnt;\r\nuint32_t mboxes;\r\nuint16_t __iomem *wptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nmboxes = (1 << ha->mbx_count) - 1;\r\nif (!ha->mcp)\r\nql_dbg(ql_dbg_async, vha, 0x504e, "MBX pointer ERRROR.\n");\r\nelse\r\nmboxes = ha->mcp->in_mb;\r\nha->flags.mbox_int = 1;\r\nha->mailbox_out[0] = mb0;\r\nmboxes >>= 1;\r\nwptr = (uint16_t __iomem *)&reg->mailbox1;\r\nfor (cnt = 1; cnt < ha->mbx_count; cnt++) {\r\nif (mboxes & BIT_0)\r\nha->mailbox_out[cnt] = RD_REG_WORD(wptr);\r\nmboxes >>= 1;\r\nwptr++;\r\n}\r\n}\r\nvoid qla24xx_process_response_queue(struct scsi_qla_host *vha,\r\nstruct rsp_que *rsp)\r\n{\r\nstruct sts_entry_24xx *pkt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!vha->flags.online)\r\nreturn;\r\nwhile (rsp->ring_ptr->signature != RESPONSE_PROCESSED) {\r\npkt = (struct sts_entry_24xx *)rsp->ring_ptr;\r\nrsp->ring_index++;\r\nif (rsp->ring_index == rsp->length) {\r\nrsp->ring_index = 0;\r\nrsp->ring_ptr = rsp->ring;\r\n} else {\r\nrsp->ring_ptr++;\r\n}\r\nif (pkt->entry_status != 0) {\r\nqla2x00_error_entry(vha, rsp, (sts_entry_t *) pkt);\r\n(void)qlt_24xx_process_response_error(vha, pkt);\r\n((response_t *)pkt)->signature = RESPONSE_PROCESSED;\r\nwmb();\r\ncontinue;\r\n}\r\nswitch (pkt->entry_type) {\r\ncase STATUS_TYPE:\r\nqla2x00_status_entry(vha, rsp, pkt);\r\nbreak;\r\ncase STATUS_CONT_TYPE:\r\nqla2x00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);\r\nbreak;\r\ncase VP_RPT_ID_IOCB_TYPE:\r\nqla24xx_report_id_acquisition(vha,\r\n(struct vp_rpt_id_entry_24xx *)pkt);\r\nbreak;\r\ncase LOGINOUT_PORT_IOCB_TYPE:\r\nqla24xx_logio_entry(vha, rsp->req,\r\n(struct logio_entry_24xx *)pkt);\r\nbreak;\r\ncase TSK_MGMT_IOCB_TYPE:\r\nqla24xx_tm_iocb_entry(vha, rsp->req,\r\n(struct tsk_mgmt_entry *)pkt);\r\nbreak;\r\ncase CT_IOCB_TYPE:\r\nqla24xx_els_ct_entry(vha, rsp->req, pkt, CT_IOCB_TYPE);\r\nbreak;\r\ncase ELS_IOCB_TYPE:\r\nqla24xx_els_ct_entry(vha, rsp->req, pkt, ELS_IOCB_TYPE);\r\nbreak;\r\ncase ABTS_RECV_24XX:\r\nqlt_24xx_process_atio_queue(vha);\r\ncase ABTS_RESP_24XX:\r\ncase CTIO_TYPE7:\r\ncase NOTIFY_ACK_TYPE:\r\nqlt_response_pkt_all_vps(vha, (response_t *)pkt);\r\nbreak;\r\ncase MARKER_TYPE:\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_async, vha, 0x5042,\r\n"Received unknown response pkt type %x "\r\n"entry status=%x.\n",\r\npkt->entry_type, pkt->entry_status);\r\nbreak;\r\n}\r\n((response_t *)pkt)->signature = RESPONSE_PROCESSED;\r\nwmb();\r\n}\r\nif (IS_QLA82XX(ha)) {\r\nstruct device_reg_82xx __iomem *reg = &ha->iobase->isp82;\r\nWRT_REG_DWORD(&reg->rsp_q_out[0], rsp->ring_index);\r\n} else\r\nWRT_REG_DWORD(rsp->rsp_q_out, rsp->ring_index);\r\n}\r\nstatic void\r\nqla2xxx_check_risc_status(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint32_t cnt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nif (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha))\r\nreturn;\r\nrval = QLA_SUCCESS;\r\nWRT_REG_DWORD(&reg->iobase_addr, 0x7C00);\r\nRD_REG_DWORD(&reg->iobase_addr);\r\nWRT_REG_DWORD(&reg->iobase_window, 0x0001);\r\nfor (cnt = 10000; (RD_REG_DWORD(&reg->iobase_window) & BIT_0) == 0 &&\r\nrval == QLA_SUCCESS; cnt--) {\r\nif (cnt) {\r\nWRT_REG_DWORD(&reg->iobase_window, 0x0001);\r\nudelay(10);\r\n} else\r\nrval = QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (rval == QLA_SUCCESS)\r\ngoto next_test;\r\nWRT_REG_DWORD(&reg->iobase_window, 0x0003);\r\nfor (cnt = 100; (RD_REG_DWORD(&reg->iobase_window) & BIT_0) == 0 &&\r\nrval == QLA_SUCCESS; cnt--) {\r\nif (cnt) {\r\nWRT_REG_DWORD(&reg->iobase_window, 0x0003);\r\nudelay(10);\r\n} else\r\nrval = QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (rval != QLA_SUCCESS)\r\ngoto done;\r\nnext_test:\r\nif (RD_REG_DWORD(&reg->iobase_c8) & BIT_3)\r\nql_log(ql_log_info, vha, 0x504c,\r\n"Additional code -- 0x55AA.\n");\r\ndone:\r\nWRT_REG_DWORD(&reg->iobase_window, 0x0000);\r\nRD_REG_DWORD(&reg->iobase_window);\r\n}\r\nirqreturn_t\r\nqla24xx_intr_handler(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct device_reg_24xx __iomem *reg;\r\nint status;\r\nunsigned long iter;\r\nuint32_t stat;\r\nuint32_t hccr;\r\nuint16_t mb[4];\r\nstruct rsp_que *rsp;\r\nunsigned long flags;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0x5059,\r\n"%s: NULL response queue pointer.\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->isp24;\r\nstatus = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn IRQ_HANDLED;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\nfor (iter = 50; iter--; ) {\r\nstat = RD_REG_DWORD(&reg->host_status);\r\nif (stat & HSRX_RISC_PAUSED) {\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nbreak;\r\nhccr = RD_REG_DWORD(&reg->hccr);\r\nql_log(ql_log_warn, vha, 0x504b,\r\n"RISC paused -- HCCR=%x, Dumping firmware.\n",\r\nhccr);\r\nqla2xxx_check_risc_status(vha);\r\nha->isp_ops->fw_dump(vha, 1);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\n} else if ((stat & HSRX_RISC_INT) == 0)\r\nbreak;\r\nswitch (stat & 0xff) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x10:\r\ncase 0x11:\r\nqla24xx_mbx_completion(vha, MSW(stat));\r\nstatus |= MBX_INTERRUPT;\r\nbreak;\r\ncase 0x12:\r\nmb[0] = MSW(stat);\r\nmb[1] = RD_REG_WORD(&reg->mailbox1);\r\nmb[2] = RD_REG_WORD(&reg->mailbox2);\r\nmb[3] = RD_REG_WORD(&reg->mailbox3);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ncase 0x13:\r\ncase 0x14:\r\nqla24xx_process_response_queue(vha, rsp);\r\nbreak;\r\ncase 0x1C:\r\nqlt_24xx_process_atio_queue(vha);\r\nbreak;\r\ncase 0x1D:\r\nqlt_24xx_process_atio_queue(vha);\r\nqla24xx_process_response_queue(vha, rsp);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_async, vha, 0x504f,\r\n"Unrecognized interrupt type (%d).\n", stat * 0xff);\r\nbreak;\r\n}\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);\r\nRD_REG_DWORD_RELAXED(&reg->hccr);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (test_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags) &&\r\n(status & MBX_INTERRUPT) && ha->flags.mbox_int) {\r\nset_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\ncomplete(&ha->mbx_intr_comp);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nqla24xx_msix_rsp_q(int irq, void *dev_id)\r\n{\r\nstruct qla_hw_data *ha;\r\nstruct rsp_que *rsp;\r\nstruct device_reg_24xx __iomem *reg;\r\nstruct scsi_qla_host *vha;\r\nunsigned long flags;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0x505a,\r\n"%s: NULL response queue pointer.\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->isp24;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\nqla24xx_process_response_queue(vha, rsp);\r\nif (!ha->flags.disable_msix_handshake) {\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);\r\nRD_REG_DWORD_RELAXED(&reg->hccr);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nqla25xx_msix_rsp_q(int irq, void *dev_id)\r\n{\r\nstruct qla_hw_data *ha;\r\nstruct rsp_que *rsp;\r\nstruct device_reg_24xx __iomem *reg;\r\nunsigned long flags;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0x505b,\r\n"%s: NULL response queue pointer.\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nif (!ha->flags.disable_msix_handshake) {\r\nreg = &ha->iobase->isp24;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);\r\nRD_REG_DWORD_RELAXED(&reg->hccr);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nqueue_work_on((int) (rsp->id - 1), ha->wq, &rsp->q_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nqla24xx_msix_default(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct rsp_que *rsp;\r\nstruct device_reg_24xx __iomem *reg;\r\nint status;\r\nuint32_t stat;\r\nuint32_t hccr;\r\nuint16_t mb[4];\r\nunsigned long flags;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0x505c,\r\n"%s: NULL response queue pointer.\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->isp24;\r\nstatus = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\ndo {\r\nstat = RD_REG_DWORD(&reg->host_status);\r\nif (stat & HSRX_RISC_PAUSED) {\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nbreak;\r\nhccr = RD_REG_DWORD(&reg->hccr);\r\nql_log(ql_log_info, vha, 0x5050,\r\n"RISC paused -- HCCR=%x, Dumping firmware.\n",\r\nhccr);\r\nqla2xxx_check_risc_status(vha);\r\nha->isp_ops->fw_dump(vha, 1);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\n} else if ((stat & HSRX_RISC_INT) == 0)\r\nbreak;\r\nswitch (stat & 0xff) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x10:\r\ncase 0x11:\r\nqla24xx_mbx_completion(vha, MSW(stat));\r\nstatus |= MBX_INTERRUPT;\r\nbreak;\r\ncase 0x12:\r\nmb[0] = MSW(stat);\r\nmb[1] = RD_REG_WORD(&reg->mailbox1);\r\nmb[2] = RD_REG_WORD(&reg->mailbox2);\r\nmb[3] = RD_REG_WORD(&reg->mailbox3);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ncase 0x13:\r\ncase 0x14:\r\nqla24xx_process_response_queue(vha, rsp);\r\nbreak;\r\ncase 0x1C:\r\nqlt_24xx_process_atio_queue(vha);\r\nbreak;\r\ncase 0x1D:\r\nqlt_24xx_process_atio_queue(vha);\r\nqla24xx_process_response_queue(vha, rsp);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_async, vha, 0x5051,\r\n"Unrecognized interrupt type (%d).\n", stat & 0xff);\r\nbreak;\r\n}\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);\r\n} while (0);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (test_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags) &&\r\n(status & MBX_INTERRUPT) && ha->flags.mbox_int) {\r\nset_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\ncomplete(&ha->mbx_intr_comp);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nqla24xx_disable_msix(struct qla_hw_data *ha)\r\n{\r\nint i;\r\nstruct qla_msix_entry *qentry;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nfor (i = 0; i < ha->msix_count; i++) {\r\nqentry = &ha->msix_entries[i];\r\nif (qentry->have_irq)\r\nfree_irq(qentry->vector, qentry->rsp);\r\n}\r\npci_disable_msix(ha->pdev);\r\nkfree(ha->msix_entries);\r\nha->msix_entries = NULL;\r\nha->flags.msix_enabled = 0;\r\nql_dbg(ql_dbg_init, vha, 0x0042,\r\n"Disabled the MSI.\n");\r\n}\r\nstatic int\r\nqla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que *rsp)\r\n{\r\n#define MIN_MSIX_COUNT 2\r\nint i, ret;\r\nstruct msix_entry *entries;\r\nstruct qla_msix_entry *qentry;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nentries = kzalloc(sizeof(struct msix_entry) * ha->msix_count,\r\nGFP_KERNEL);\r\nif (!entries) {\r\nql_log(ql_log_warn, vha, 0x00bc,\r\n"Failed to allocate memory for msix_entry.\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ha->msix_count; i++)\r\nentries[i].entry = i;\r\nret = pci_enable_msix(ha->pdev, entries, ha->msix_count);\r\nif (ret) {\r\nif (ret < MIN_MSIX_COUNT)\r\ngoto msix_failed;\r\nql_log(ql_log_warn, vha, 0x00c6,\r\n"MSI-X: Failed to enable support "\r\n"-- %d/%d\n Retry with %d vectors.\n",\r\nha->msix_count, ret, ret);\r\nha->msix_count = ret;\r\nret = pci_enable_msix(ha->pdev, entries, ha->msix_count);\r\nif (ret) {\r\nmsix_failed:\r\nql_log(ql_log_fatal, vha, 0x00c7,\r\n"MSI-X: Failed to enable support, "\r\n"giving up -- %d/%d.\n",\r\nha->msix_count, ret);\r\ngoto msix_out;\r\n}\r\nha->max_rsp_queues = ha->msix_count - 1;\r\n}\r\nha->msix_entries = kzalloc(sizeof(struct qla_msix_entry) *\r\nha->msix_count, GFP_KERNEL);\r\nif (!ha->msix_entries) {\r\nql_log(ql_log_fatal, vha, 0x00c8,\r\n"Failed to allocate memory for ha->msix_entries.\n");\r\nret = -ENOMEM;\r\ngoto msix_out;\r\n}\r\nha->flags.msix_enabled = 1;\r\nfor (i = 0; i < ha->msix_count; i++) {\r\nqentry = &ha->msix_entries[i];\r\nqentry->vector = entries[i].vector;\r\nqentry->entry = entries[i].entry;\r\nqentry->have_irq = 0;\r\nqentry->rsp = NULL;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nqentry = &ha->msix_entries[i];\r\nif (IS_QLA82XX(ha)) {\r\nret = request_irq(qentry->vector,\r\nqla82xx_msix_entries[i].handler,\r\n0, qla82xx_msix_entries[i].name, rsp);\r\n} else {\r\nret = request_irq(qentry->vector,\r\nmsix_entries[i].handler,\r\n0, msix_entries[i].name, rsp);\r\n}\r\nif (ret) {\r\nql_log(ql_log_fatal, vha, 0x00cb,\r\n"MSI-X: unable to register handler -- %x/%d.\n",\r\nqentry->vector, ret);\r\nqla24xx_disable_msix(ha);\r\nha->mqenable = 0;\r\ngoto msix_out;\r\n}\r\nqentry->have_irq = 1;\r\nqentry->rsp = rsp;\r\nrsp->msix = qentry;\r\n}\r\nif (IS_QLA83XX(ha)) {\r\nif (ha->msixbase && ha->mqiobase &&\r\n(ha->max_rsp_queues > 1 || ha->max_req_queues > 1))\r\nha->mqenable = 1;\r\n} else\r\nif (ha->mqiobase\r\n&& (ha->max_rsp_queues > 1 || ha->max_req_queues > 1))\r\nha->mqenable = 1;\r\nql_dbg(ql_dbg_multiq, vha, 0xc005,\r\n"mqiobase=%p, max_rsp_queues=%d, max_req_queues=%d.\n",\r\nha->mqiobase, ha->max_rsp_queues, ha->max_req_queues);\r\nql_dbg(ql_dbg_init, vha, 0x0055,\r\n"mqiobase=%p, max_rsp_queues=%d, max_req_queues=%d.\n",\r\nha->mqiobase, ha->max_rsp_queues, ha->max_req_queues);\r\nmsix_out:\r\nkfree(entries);\r\nreturn ret;\r\n}\r\nint\r\nqla2x00_request_irqs(struct qla_hw_data *ha, struct rsp_que *rsp)\r\n{\r\nint ret;\r\ndevice_reg_t __iomem *reg = ha->iobase;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nif (!IS_QLA2432(ha) && !IS_QLA2532(ha) && !IS_QLA8432(ha) &&\r\n!IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha))\r\ngoto skip_msi;\r\nif (ha->pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&\r\n(ha->pdev->subsystem_device == 0x7040 ||\r\nha->pdev->subsystem_device == 0x7041 ||\r\nha->pdev->subsystem_device == 0x1705)) {\r\nql_log(ql_log_warn, vha, 0x0034,\r\n"MSI-X: Unsupported ISP 2432 SSVID/SSDID (0x%X,0x%X).\n",\r\nha->pdev->subsystem_vendor,\r\nha->pdev->subsystem_device);\r\ngoto skip_msi;\r\n}\r\nif (IS_QLA2432(ha) && (ha->pdev->revision < QLA_MSIX_CHIP_REV_24XX)) {\r\nql_log(ql_log_warn, vha, 0x0035,\r\n"MSI-X; Unsupported ISP2432 (0x%X, 0x%X).\n",\r\nha->pdev->revision, QLA_MSIX_CHIP_REV_24XX);\r\ngoto skip_msix;\r\n}\r\nret = qla24xx_enable_msix(ha, rsp);\r\nif (!ret) {\r\nql_dbg(ql_dbg_init, vha, 0x0036,\r\n"MSI-X: Enabled (0x%X, 0x%X).\n",\r\nha->chip_revision, ha->fw_attributes);\r\ngoto clear_risc_ints;\r\n}\r\nql_log(ql_log_info, vha, 0x0037,\r\n"MSI-X Falling back-to MSI mode -%d.\n", ret);\r\nskip_msix:\r\nif (!IS_QLA24XX(ha) && !IS_QLA2532(ha) && !IS_QLA8432(ha) &&\r\n!IS_QLA8001(ha))\r\ngoto skip_msi;\r\nret = pci_enable_msi(ha->pdev);\r\nif (!ret) {\r\nql_dbg(ql_dbg_init, vha, 0x0038,\r\n"MSI: Enabled.\n");\r\nha->flags.msi_enabled = 1;\r\n} else\r\nql_log(ql_log_warn, vha, 0x0039,\r\n"MSI-X; Falling back-to INTa mode -- %d.\n", ret);\r\nskip_msi:\r\nret = request_irq(ha->pdev->irq, ha->isp_ops->intr_handler,\r\nha->flags.msi_enabled ? 0 : IRQF_SHARED,\r\nQLA2XXX_DRIVER_NAME, rsp);\r\nif (ret) {\r\nql_log(ql_log_warn, vha, 0x003a,\r\n"Failed to reserve interrupt %d already in use.\n",\r\nha->pdev->irq);\r\ngoto fail;\r\n}\r\nclear_risc_ints:\r\nif (IS_QLA81XX(ha) || IS_QLA82XX(ha) || IS_QLA83XX(ha))\r\ngoto fail;\r\nspin_lock_irq(&ha->hardware_lock);\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nWRT_REG_DWORD(&reg->isp24.hccr, HCCRX_CLR_HOST_INT);\r\nWRT_REG_DWORD(&reg->isp24.hccr, HCCRX_CLR_RISC_INT);\r\n} else {\r\nWRT_REG_WORD(&reg->isp.semaphore, 0);\r\nWRT_REG_WORD(&reg->isp.hccr, HCCR_CLR_RISC_INT);\r\nWRT_REG_WORD(&reg->isp.hccr, HCCR_CLR_HOST_INT);\r\n}\r\nspin_unlock_irq(&ha->hardware_lock);\r\nfail:\r\nreturn ret;\r\n}\r\nvoid\r\nqla2x00_free_irqs(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct rsp_que *rsp;\r\nif (!ha->rsp_q_map || !ha->rsp_q_map[0])\r\nreturn;\r\nrsp = ha->rsp_q_map[0];\r\nif (ha->flags.msix_enabled)\r\nqla24xx_disable_msix(ha);\r\nelse if (ha->flags.msi_enabled) {\r\nfree_irq(ha->pdev->irq, rsp);\r\npci_disable_msi(ha->pdev);\r\n} else\r\nfree_irq(ha->pdev->irq, rsp);\r\n}\r\nint qla25xx_request_irq(struct rsp_que *rsp)\r\n{\r\nstruct qla_hw_data *ha = rsp->hw;\r\nstruct qla_init_msix_entry *intr = &msix_entries[2];\r\nstruct qla_msix_entry *msix = rsp->msix;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nint ret;\r\nret = request_irq(msix->vector, intr->handler, 0, intr->name, rsp);\r\nif (ret) {\r\nql_log(ql_log_fatal, vha, 0x00e6,\r\n"MSI-X: Unable to register handler -- %x/%d.\n",\r\nmsix->vector, ret);\r\nreturn ret;\r\n}\r\nmsix->have_irq = 1;\r\nmsix->rsp = rsp;\r\nreturn ret;\r\n}
