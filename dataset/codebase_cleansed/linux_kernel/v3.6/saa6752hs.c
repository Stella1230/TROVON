static inline struct saa6752hs_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa6752hs_state, sd);\r\n}\r\nstatic int saa6752hs_chip_command(struct i2c_client *client,\r\nenum saa6752hs_command command)\r\n{\r\nunsigned char buf[3];\r\nunsigned long timeout;\r\nint status = 0;\r\nswitch(command) {\r\ncase SAA6752HS_COMMAND_RESET:\r\nbuf[0] = 0x00;\r\nbreak;\r\ncase SAA6752HS_COMMAND_STOP:\r\nbuf[0] = 0x03;\r\nbreak;\r\ncase SAA6752HS_COMMAND_START:\r\nbuf[0] = 0x02;\r\nbreak;\r\ncase SAA6752HS_COMMAND_PAUSE:\r\nbuf[0] = 0x04;\r\nbreak;\r\ncase SAA6752HS_COMMAND_RECONFIGURE:\r\nbuf[0] = 0x05;\r\nbreak;\r\ncase SAA6752HS_COMMAND_SLEEP:\r\nbuf[0] = 0x06;\r\nbreak;\r\ncase SAA6752HS_COMMAND_RECONFIGURE_FORCE:\r\nbuf[0] = 0x07;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni2c_master_send(client, buf, 1);\r\ntimeout = jiffies + HZ * 3;\r\nfor (;;) {\r\nbuf[0] = 0x10;\r\ni2c_master_send(client, buf, 1);\r\ni2c_master_recv(client, buf, 1);\r\nif (!(buf[0] & 0x20))\r\nbreak;\r\nif (time_after(jiffies,timeout)) {\r\nstatus = -ETIMEDOUT;\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\nmsleep(50);\r\nreturn status;\r\n}\r\nstatic inline void set_reg8(struct i2c_client *client, uint8_t reg, uint8_t val)\r\n{\r\nu8 buf[2];\r\nbuf[0] = reg;\r\nbuf[1] = val;\r\ni2c_master_send(client, buf, 2);\r\n}\r\nstatic inline void set_reg16(struct i2c_client *client, uint8_t reg, uint16_t val)\r\n{\r\nu8 buf[3];\r\nbuf[0] = reg;\r\nbuf[1] = val >> 8;\r\nbuf[2] = val & 0xff;\r\ni2c_master_send(client, buf, 3);\r\n}\r\nstatic int saa6752hs_set_bitrate(struct i2c_client *client,\r\nstruct saa6752hs_state *h)\r\n{\r\nstruct saa6752hs_mpeg_params *params = &h->params;\r\nint tot_bitrate;\r\nint is_384k;\r\nset_reg8(client, 0x71,\r\nparams->vi_bitrate_mode != V4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\r\nif (params->vi_bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR) {\r\nset_reg16(client, 0x80, params->vi_bitrate);\r\nset_reg16(client, 0x81, params->vi_bitrate_peak);\r\ntot_bitrate = params->vi_bitrate_peak;\r\n} else {\r\nset_reg16(client, 0x81, params->vi_bitrate);\r\ntot_bitrate = params->vi_bitrate;\r\n}\r\nset_reg8(client, 0x93,\r\nparams->au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3);\r\nif (params->au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3)\r\nis_384k = V4L2_MPEG_AUDIO_AC3_BITRATE_384K == params->au_ac3_bitrate;\r\nelse\r\nis_384k = V4L2_MPEG_AUDIO_L2_BITRATE_384K == params->au_l2_bitrate;\r\nset_reg8(client, 0x94, is_384k);\r\ntot_bitrate += is_384k ? 384 : 256;\r\ntot_bitrate += 768;\r\nif (tot_bitrate > MPEG_TOTAL_TARGET_BITRATE_MAX)\r\ntot_bitrate = MPEG_TOTAL_TARGET_BITRATE_MAX;\r\nset_reg16(client, 0xb1, tot_bitrate);\r\nreturn 0;\r\n}\r\nstatic int get_ctrl(int has_ac3, struct saa6752hs_mpeg_params *params,\r\nstruct v4l2_ext_control *ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nctrl->value = V4L2_MPEG_STREAM_TYPE_MPEG2_TS;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_PMT:\r\nctrl->value = params->ts_pid_pmt;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_AUDIO:\r\nctrl->value = params->ts_pid_audio;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_VIDEO:\r\nctrl->value = params->ts_pid_video;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_PCR:\r\nctrl->value = params->ts_pid_pcr;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nctrl->value = params->au_encoding;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\nctrl->value = params->au_l2_bitrate;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\nif (!has_ac3)\r\nreturn -EINVAL;\r\nctrl->value = params->au_ac3_bitrate;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\r\nctrl->value = V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nctrl->value = V4L2_MPEG_VIDEO_ENCODING_MPEG_2;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nctrl->value = params->vi_aspect;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nctrl->value = params->vi_bitrate * 1000;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:\r\nctrl->value = params->vi_bitrate_peak * 1000;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nctrl->value = params->vi_bitrate_mode;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_ctrl(int has_ac3, struct saa6752hs_mpeg_params *params,\r\nstruct v4l2_ext_control *ctrl, int set)\r\n{\r\nint old = 0, new;\r\nnew = ctrl->value;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nold = V4L2_MPEG_STREAM_TYPE_MPEG2_TS;\r\nif (set && new != old)\r\nreturn -ERANGE;\r\nnew = old;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_PMT:\r\nold = params->ts_pid_pmt;\r\nif (set && new > MPEG_PID_MAX)\r\nreturn -ERANGE;\r\nif (new > MPEG_PID_MAX)\r\nnew = MPEG_PID_MAX;\r\nparams->ts_pid_pmt = new;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_AUDIO:\r\nold = params->ts_pid_audio;\r\nif (set && new > MPEG_PID_MAX)\r\nreturn -ERANGE;\r\nif (new > MPEG_PID_MAX)\r\nnew = MPEG_PID_MAX;\r\nparams->ts_pid_audio = new;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_VIDEO:\r\nold = params->ts_pid_video;\r\nif (set && new > MPEG_PID_MAX)\r\nreturn -ERANGE;\r\nif (new > MPEG_PID_MAX)\r\nnew = MPEG_PID_MAX;\r\nparams->ts_pid_video = new;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_PID_PCR:\r\nold = params->ts_pid_pcr;\r\nif (set && new > MPEG_PID_MAX)\r\nreturn -ERANGE;\r\nif (new > MPEG_PID_MAX)\r\nnew = MPEG_PID_MAX;\r\nparams->ts_pid_pcr = new;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nold = params->au_encoding;\r\nif (set && new != V4L2_MPEG_AUDIO_ENCODING_LAYER_2 &&\r\n(!has_ac3 || new != V4L2_MPEG_AUDIO_ENCODING_AC3))\r\nreturn -ERANGE;\r\nparams->au_encoding = new;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\nold = params->au_l2_bitrate;\r\nif (set && new != V4L2_MPEG_AUDIO_L2_BITRATE_256K &&\r\nnew != V4L2_MPEG_AUDIO_L2_BITRATE_384K)\r\nreturn -ERANGE;\r\nif (new <= V4L2_MPEG_AUDIO_L2_BITRATE_256K)\r\nnew = V4L2_MPEG_AUDIO_L2_BITRATE_256K;\r\nelse\r\nnew = V4L2_MPEG_AUDIO_L2_BITRATE_384K;\r\nparams->au_l2_bitrate = new;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\nif (!has_ac3)\r\nreturn -EINVAL;\r\nold = params->au_ac3_bitrate;\r\nif (set && new != V4L2_MPEG_AUDIO_AC3_BITRATE_256K &&\r\nnew != V4L2_MPEG_AUDIO_AC3_BITRATE_384K)\r\nreturn -ERANGE;\r\nif (new <= V4L2_MPEG_AUDIO_AC3_BITRATE_256K)\r\nnew = V4L2_MPEG_AUDIO_AC3_BITRATE_256K;\r\nelse\r\nnew = V4L2_MPEG_AUDIO_AC3_BITRATE_384K;\r\nparams->au_ac3_bitrate = new;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\r\nold = V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000;\r\nif (set && new != old)\r\nreturn -ERANGE;\r\nnew = old;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nold = V4L2_MPEG_VIDEO_ENCODING_MPEG_2;\r\nif (set && new != old)\r\nreturn -ERANGE;\r\nnew = old;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nold = params->vi_aspect;\r\nif (set && new != V4L2_MPEG_VIDEO_ASPECT_16x9 &&\r\nnew != V4L2_MPEG_VIDEO_ASPECT_4x3)\r\nreturn -ERANGE;\r\nif (new != V4L2_MPEG_VIDEO_ASPECT_16x9)\r\nnew = V4L2_MPEG_VIDEO_ASPECT_4x3;\r\nparams->vi_aspect = new;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nold = params->vi_bitrate * 1000;\r\nnew = 1000 * (new / 1000);\r\nif (set && new > MPEG_VIDEO_TARGET_BITRATE_MAX * 1000)\r\nreturn -ERANGE;\r\nif (new > MPEG_VIDEO_TARGET_BITRATE_MAX * 1000)\r\nnew = MPEG_VIDEO_TARGET_BITRATE_MAX * 1000;\r\nparams->vi_bitrate = new / 1000;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:\r\nold = params->vi_bitrate_peak * 1000;\r\nnew = 1000 * (new / 1000);\r\nif (set && new > MPEG_VIDEO_TARGET_BITRATE_MAX * 1000)\r\nreturn -ERANGE;\r\nif (new > MPEG_VIDEO_TARGET_BITRATE_MAX * 1000)\r\nnew = MPEG_VIDEO_TARGET_BITRATE_MAX * 1000;\r\nparams->vi_bitrate_peak = new / 1000;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nold = params->vi_bitrate_mode;\r\nparams->vi_bitrate_mode = new;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl->value = new;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qctrl)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nstruct saa6752hs_mpeg_params *params = &h->params;\r\nint err;\r\nswitch (qctrl->id) {\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nreturn v4l2_ctrl_query_fill(qctrl,\r\nV4L2_MPEG_AUDIO_ENCODING_LAYER_2,\r\nh->has_ac3 ? V4L2_MPEG_AUDIO_ENCODING_AC3 :\r\nV4L2_MPEG_AUDIO_ENCODING_LAYER_2,\r\n1, V4L2_MPEG_AUDIO_ENCODING_LAYER_2);\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\nreturn v4l2_ctrl_query_fill(qctrl,\r\nV4L2_MPEG_AUDIO_L2_BITRATE_256K,\r\nV4L2_MPEG_AUDIO_L2_BITRATE_384K, 1,\r\nV4L2_MPEG_AUDIO_L2_BITRATE_256K);\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\nif (!h->has_ac3)\r\nreturn -EINVAL;\r\nreturn v4l2_ctrl_query_fill(qctrl,\r\nV4L2_MPEG_AUDIO_AC3_BITRATE_256K,\r\nV4L2_MPEG_AUDIO_AC3_BITRATE_384K, 1,\r\nV4L2_MPEG_AUDIO_AC3_BITRATE_256K);\r\ncase V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ:\r\nreturn v4l2_ctrl_query_fill(qctrl,\r\nV4L2_MPEG_AUDIO_SAMPLING_FREQ_48000,\r\nV4L2_MPEG_AUDIO_SAMPLING_FREQ_48000, 1,\r\nV4L2_MPEG_AUDIO_SAMPLING_FREQ_48000);\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nreturn v4l2_ctrl_query_fill(qctrl,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_2,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_2, 1,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_2);\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nreturn v4l2_ctrl_query_fill(qctrl,\r\nV4L2_MPEG_VIDEO_ASPECT_4x3,\r\nV4L2_MPEG_VIDEO_ASPECT_16x9, 1,\r\nV4L2_MPEG_VIDEO_ASPECT_4x3);\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:\r\nerr = v4l2_ctrl_query_fill(qctrl, 0, 27000000, 1, 8000000);\r\nif (err == 0 &&\r\nparams->vi_bitrate_mode ==\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR)\r\nqctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;\r\nreturn err;\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nreturn v4l2_ctrl_query_fill(qctrl,\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_TS,\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_TS, 1,\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_TS);\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nreturn v4l2_ctrl_query_fill(qctrl,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_VBR,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 1,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_VBR);\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nreturn v4l2_ctrl_query_fill(qctrl, 0, 27000000, 1, 6000000);\r\ncase V4L2_CID_MPEG_STREAM_PID_PMT:\r\nreturn v4l2_ctrl_query_fill(qctrl, 0, (1 << 14) - 1, 1, 16);\r\ncase V4L2_CID_MPEG_STREAM_PID_AUDIO:\r\nreturn v4l2_ctrl_query_fill(qctrl, 0, (1 << 14) - 1, 1, 260);\r\ncase V4L2_CID_MPEG_STREAM_PID_VIDEO:\r\nreturn v4l2_ctrl_query_fill(qctrl, 0, (1 << 14) - 1, 1, 256);\r\ncase V4L2_CID_MPEG_STREAM_PID_PCR:\r\nreturn v4l2_ctrl_query_fill(qctrl, 0, (1 << 14) - 1, 1, 259);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int saa6752hs_querymenu(struct v4l2_subdev *sd, struct v4l2_querymenu *qmenu)\r\n{\r\nstatic const u32 mpeg_audio_encoding[] = {\r\nV4L2_MPEG_AUDIO_ENCODING_LAYER_2,\r\nV4L2_CTRL_MENU_IDS_END\r\n};\r\nstatic const u32 mpeg_audio_ac3_encoding[] = {\r\nV4L2_MPEG_AUDIO_ENCODING_LAYER_2,\r\nV4L2_MPEG_AUDIO_ENCODING_AC3,\r\nV4L2_CTRL_MENU_IDS_END\r\n};\r\nstatic u32 mpeg_audio_l2_bitrate[] = {\r\nV4L2_MPEG_AUDIO_L2_BITRATE_256K,\r\nV4L2_MPEG_AUDIO_L2_BITRATE_384K,\r\nV4L2_CTRL_MENU_IDS_END\r\n};\r\nstatic u32 mpeg_audio_ac3_bitrate[] = {\r\nV4L2_MPEG_AUDIO_AC3_BITRATE_256K,\r\nV4L2_MPEG_AUDIO_AC3_BITRATE_384K,\r\nV4L2_CTRL_MENU_IDS_END\r\n};\r\nstruct saa6752hs_state *h = to_state(sd);\r\nstruct v4l2_queryctrl qctrl;\r\nint err;\r\nqctrl.id = qmenu->id;\r\nerr = saa6752hs_queryctrl(sd, &qctrl);\r\nif (err)\r\nreturn err;\r\nswitch (qmenu->id) {\r\ncase V4L2_CID_MPEG_AUDIO_L2_BITRATE:\r\nreturn v4l2_ctrl_query_menu_valid_items(qmenu,\r\nmpeg_audio_l2_bitrate);\r\ncase V4L2_CID_MPEG_AUDIO_AC3_BITRATE:\r\nif (!h->has_ac3)\r\nreturn -EINVAL;\r\nreturn v4l2_ctrl_query_menu_valid_items(qmenu,\r\nmpeg_audio_ac3_bitrate);\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nreturn v4l2_ctrl_query_menu_valid_items(qmenu,\r\nh->has_ac3 ? mpeg_audio_ac3_encoding :\r\nmpeg_audio_encoding);\r\n}\r\nreturn v4l2_ctrl_query_menu(qmenu, &qctrl, NULL);\r\n}\r\nstatic int saa6752hs_init(struct v4l2_subdev *sd, u32 leading_null_bytes)\r\n{\r\nunsigned char buf[9], buf2[4];\r\nstruct saa6752hs_state *h = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nunsigned size;\r\nu32 crc;\r\nunsigned char localPAT[256];\r\nunsigned char localPMT[256];\r\nset_reg8(client, 0x41, h->video_format);\r\nset_reg8(client, 0x40, (h->standard & V4L2_STD_525_60) ? 1 : 0);\r\nsaa6752hs_set_bitrate(client, h);\r\nset_reg16(client, 0x72, 0x030d);\r\nset_reg8(client, 0x82, 0x04);\r\nset_reg8(client, 0x83, 0x0c);\r\nset_reg8(client, 0xd0, 0x81);\r\nset_reg8(client, 0xb0, 0x05);\r\nset_reg16(client, 0xf6, leading_null_bytes);\r\nmemcpy(localPAT, PAT, sizeof(PAT));\r\nlocalPAT[17] = 0xe0 | ((h->params.ts_pid_pmt >> 8) & 0x0f);\r\nlocalPAT[18] = h->params.ts_pid_pmt & 0xff;\r\ncrc = crc32_be(~0, &localPAT[7], sizeof(PAT) - 7 - 4);\r\nlocalPAT[sizeof(PAT) - 4] = (crc >> 24) & 0xFF;\r\nlocalPAT[sizeof(PAT) - 3] = (crc >> 16) & 0xFF;\r\nlocalPAT[sizeof(PAT) - 2] = (crc >> 8) & 0xFF;\r\nlocalPAT[sizeof(PAT) - 1] = crc & 0xFF;\r\nif (h->params.au_encoding == V4L2_MPEG_AUDIO_ENCODING_AC3) {\r\nsize = sizeof(PMT_AC3);\r\nmemcpy(localPMT, PMT_AC3, size);\r\n} else {\r\nsize = sizeof(PMT);\r\nmemcpy(localPMT, PMT, size);\r\n}\r\nlocalPMT[3] = 0x40 | ((h->params.ts_pid_pmt >> 8) & 0x0f);\r\nlocalPMT[4] = h->params.ts_pid_pmt & 0xff;\r\nlocalPMT[15] = 0xE0 | ((h->params.ts_pid_pcr >> 8) & 0x0F);\r\nlocalPMT[16] = h->params.ts_pid_pcr & 0xFF;\r\nlocalPMT[20] = 0xE0 | ((h->params.ts_pid_video >> 8) & 0x0F);\r\nlocalPMT[21] = h->params.ts_pid_video & 0xFF;\r\nlocalPMT[25] = 0xE0 | ((h->params.ts_pid_audio >> 8) & 0x0F);\r\nlocalPMT[26] = h->params.ts_pid_audio & 0xFF;\r\ncrc = crc32_be(~0, &localPMT[7], size - 7 - 4);\r\nlocalPMT[size - 4] = (crc >> 24) & 0xFF;\r\nlocalPMT[size - 3] = (crc >> 16) & 0xFF;\r\nlocalPMT[size - 2] = (crc >> 8) & 0xFF;\r\nlocalPMT[size - 1] = crc & 0xFF;\r\nset_reg16(client, 0xc1, h->params.ts_pid_audio);\r\nset_reg16(client, 0xc0, h->params.ts_pid_video);\r\nset_reg16(client, 0xc4, h->params.ts_pid_pcr);\r\ni2c_master_send(client, localPAT, sizeof(PAT));\r\ni2c_master_send(client, localPMT, size);\r\nset_reg8(client, 0xa4, 1);\r\nset_reg8(client, 0xa4, 0);\r\nsaa6752hs_chip_command(client, SAA6752HS_COMMAND_START);\r\nbuf[0] = 0xE1;\r\nbuf[1] = 0xA7;\r\nbuf[2] = 0xFE;\r\nbuf[3] = 0x82;\r\nbuf[4] = 0xB0;\r\ni2c_master_send(client, buf, 5);\r\ni2c_master_recv(client, buf2, 4);\r\nbuf[0] = 0xE0;\r\nbuf[1] = 0xA7;\r\nbuf[2] = 0xFE;\r\nbuf[3] = 0x82;\r\nbuf[4] = 0xB0;\r\nbuf[5] = buf2[0];\r\nswitch (h->params.vi_aspect) {\r\ncase V4L2_MPEG_VIDEO_ASPECT_16x9:\r\nbuf[6] = buf2[1] | 0x40;\r\nbreak;\r\ncase V4L2_MPEG_VIDEO_ASPECT_4x3:\r\ndefault:\r\nbuf[6] = buf2[1] & 0xBF;\r\nbreak;\r\n}\r\nbuf[7] = buf2[2];\r\nbuf[8] = buf2[3];\r\ni2c_master_send(client, buf, 9);\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_do_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls, int set)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nstruct saa6752hs_mpeg_params params;\r\nint i;\r\nif (ctrls->ctrl_class != V4L2_CTRL_CLASS_MPEG)\r\nreturn -EINVAL;\r\nparams = h->params;\r\nfor (i = 0; i < ctrls->count; i++) {\r\nint err = handle_ctrl(h->has_ac3, &params, ctrls->controls + i, set);\r\nif (err) {\r\nctrls->error_idx = i;\r\nreturn err;\r\n}\r\n}\r\nif (set)\r\nh->params = params;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_s_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)\r\n{\r\nreturn saa6752hs_do_ext_ctrls(sd, ctrls, 1);\r\n}\r\nstatic int saa6752hs_try_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)\r\n{\r\nreturn saa6752hs_do_ext_ctrls(sd, ctrls, 0);\r\n}\r\nstatic int saa6752hs_g_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nint i;\r\nif (ctrls->ctrl_class != V4L2_CTRL_CLASS_MPEG)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ctrls->count; i++) {\r\nint err = get_ctrl(h->has_ac3, &h->params, ctrls->controls + i);\r\nif (err) {\r\nctrls->error_idx = i;\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_g_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nif (h->video_format == SAA6752HS_VF_UNKNOWN)\r\nh->video_format = SAA6752HS_VF_D1;\r\nf->width = v4l2_format_table[h->video_format].fmt.pix.width;\r\nf->height = v4l2_format_table[h->video_format].fmt.pix.height;\r\nf->code = V4L2_MBUS_FMT_FIXED;\r\nf->field = V4L2_FIELD_INTERLACED;\r\nf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_s_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nint dist_352, dist_480, dist_720;\r\nif (f->code != V4L2_MBUS_FMT_FIXED)\r\nreturn -EINVAL;\r\ndist_352 = abs(f->width - 352);\r\ndist_480 = abs(f->width - 480);\r\ndist_720 = abs(f->width - 720);\r\nif (dist_720 < dist_480) {\r\nf->width = 720;\r\nf->height = 576;\r\nh->video_format = SAA6752HS_VF_D1;\r\n} else if (dist_480 < dist_352) {\r\nf->width = 480;\r\nf->height = 576;\r\nh->video_format = SAA6752HS_VF_2_3_D1;\r\n} else {\r\nf->width = 352;\r\nif (abs(f->height - 576) <\r\nabs(f->height - 288)) {\r\nf->height = 576;\r\nh->video_format = SAA6752HS_VF_1_2_D1;\r\n} else {\r\nf->height = 288;\r\nh->video_format = SAA6752HS_VF_SIF;\r\n}\r\n}\r\nf->field = V4L2_FIELD_INTERLACED;\r\nf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa6752hs_state *h = to_state(sd);\r\nh->standard = std;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct saa6752hs_state *h = to_state(sd);\r\nreturn v4l2_chip_ident_i2c_client(client,\r\nchip, h->chip, h->revision);\r\n}\r\nstatic int saa6752hs_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct saa6752hs_state *h = kzalloc(sizeof(*h), GFP_KERNEL);\r\nstruct v4l2_subdev *sd;\r\nu8 addr = 0x13;\r\nu8 data[12];\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nif (h == NULL)\r\nreturn -ENOMEM;\r\nsd = &h->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa6752hs_ops);\r\ni2c_master_send(client, &addr, 1);\r\ni2c_master_recv(client, data, sizeof(data));\r\nh->chip = V4L2_IDENT_SAA6752HS;\r\nh->revision = (data[8] << 8) | data[9];\r\nh->has_ac3 = 0;\r\nif (h->revision == 0x0206) {\r\nh->chip = V4L2_IDENT_SAA6752HS_AC3;\r\nh->has_ac3 = 1;\r\nv4l_info(client, "support AC-3\n");\r\n}\r\nh->params = param_defaults;\r\nh->standard = 0;\r\nreturn 0;\r\n}\r\nstatic int saa6752hs_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}
