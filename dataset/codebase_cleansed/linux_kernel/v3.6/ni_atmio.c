static void ni_atmio_win_out(struct comedi_device *dev, uint16_t data, int addr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nif ((addr) < 8) {\r\nni_writew(data, addr * 2);\r\n} else {\r\nni_writew(addr, Window_Address);\r\nni_writew(data, Window_Data);\r\n}\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\nstatic uint16_t ni_atmio_win_in(struct comedi_device *dev, int addr)\r\n{\r\nunsigned long flags;\r\nuint16_t ret;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nif (addr < 8) {\r\nret = ni_readw(addr * 2);\r\n} else {\r\nni_writew(addr, Window_Address);\r\nret = ni_readw(Window_Data);\r\n}\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ni_isapnp_find_board(struct pnp_dev **dev)\r\n{\r\nstruct pnp_dev *isapnp_dev = NULL;\r\nint i;\r\nfor (i = 0; i < n_ni_boards; i++) {\r\nisapnp_dev = pnp_find_dev(NULL,\r\nISAPNP_VENDOR('N', 'I', 'C'),\r\nISAPNP_FUNCTION(ni_boards[i].\r\nisapnp_id), NULL);\r\nif (isapnp_dev == NULL || isapnp_dev->card == NULL)\r\ncontinue;\r\nif (pnp_device_attach(isapnp_dev) < 0) {\r\nprintk\r\n("ni_atmio: %s found but already active, skipping.\n",\r\nni_boards[i].name);\r\ncontinue;\r\n}\r\nif (pnp_activate_dev(isapnp_dev) < 0) {\r\npnp_device_detach(isapnp_dev);\r\nreturn -EAGAIN;\r\n}\r\nif (!pnp_port_valid(isapnp_dev, 0)\r\n|| !pnp_irq_valid(isapnp_dev, 0)) {\r\npnp_device_detach(isapnp_dev);\r\nprintk("ni_atmio: pnp invalid port or irq, aborting\n");\r\nreturn -ENOMEM;\r\n}\r\nbreak;\r\n}\r\nif (i == n_ni_boards)\r\nreturn -ENODEV;\r\n*dev = isapnp_dev;\r\nreturn 0;\r\n}\r\nstatic int ni_getboardtype(struct comedi_device *dev)\r\n{\r\nint device_id = ni_read_eeprom(dev, 511);\r\nint i;\r\nfor (i = 0; i < n_ni_boards; i++) {\r\nif (ni_boards[i].device_id == device_id)\r\nreturn i;\r\n}\r\nif (device_id == 255)\r\nprintk(" can't find board\n");\r\nelse if (device_id == 0)\r\nprintk(" EEPROM read error (?) or device not found\n");\r\nelse\r\nprintk(" unknown device ID %d -- contact author\n", device_id);\r\nreturn -1;\r\n}\r\nstatic int ni_atmio_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct pnp_dev *isapnp_dev;\r\nint ret;\r\nunsigned long iobase;\r\nint board;\r\nunsigned int irq;\r\nret = ni_alloc_private(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndevpriv->stc_writew = &ni_atmio_win_out;\r\ndevpriv->stc_readw = &ni_atmio_win_in;\r\ndevpriv->stc_writel = &win_out2;\r\ndevpriv->stc_readl = &win_in2;\r\niobase = it->options[0];\r\nirq = it->options[1];\r\nisapnp_dev = NULL;\r\nif (iobase == 0) {\r\nret = ni_isapnp_find_board(&isapnp_dev);\r\nif (ret < 0)\r\nreturn ret;\r\niobase = pnp_port_start(isapnp_dev, 0);\r\nirq = pnp_irq(isapnp_dev, 0);\r\ndevpriv->isapnp_dev = isapnp_dev;\r\n}\r\nprintk("comedi%d: ni_atmio: 0x%04lx", dev->minor, iobase);\r\nif (!request_region(iobase, NI_SIZE, "ni_atmio")) {\r\nprintk(" I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\n#ifdef DEBUG\r\n{\r\nint i;\r\nprintk(" board fingerprint:");\r\nfor (i = 0; i < 16; i += 2) {\r\nprintk(" %04x %02x", inw(dev->iobase + i),\r\ninb(dev->iobase + i + 1));\r\n}\r\n}\r\n#endif\r\nboard = ni_getboardtype(dev);\r\nif (board < 0)\r\nreturn -EIO;\r\ndev->board_ptr = ni_boards + board;\r\nprintk(" %s", boardtype.name);\r\ndev->board_name = boardtype.name;\r\nif (irq != 0) {\r\nif (irq > 15 || ni_irqpin[irq] == -1) {\r\nprintk(" invalid irq %u\n", irq);\r\nreturn -EINVAL;\r\n}\r\nprintk(" ( irq = %u )", irq);\r\nret = request_irq(irq, ni_E_interrupt, NI_E_IRQ_FLAGS,\r\n"ni_atmio", dev);\r\nif (ret < 0) {\r\nprintk(" irq not available\n");\r\nreturn -EINVAL;\r\n}\r\ndev->irq = irq;\r\n}\r\nret = ni_E_init(dev, it);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void ni_atmio_detach(struct comedi_device *dev)\r\n{\r\nmio_common_detach(dev);\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, NI_SIZE);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv->isapnp_dev)\r\npnp_device_detach(devpriv->isapnp_dev);\r\n}
