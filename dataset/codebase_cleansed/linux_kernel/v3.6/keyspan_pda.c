static void keyspan_pda_wakeup_write(struct work_struct *work)\r\n{\r\nstruct keyspan_pda_private *priv =\r\ncontainer_of(work, struct keyspan_pda_private, wakeup_work);\r\nstruct usb_serial_port *port = priv->port;\r\nstruct tty_struct *tty = tty_port_tty_get(&port->port);\r\nif (tty)\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic void keyspan_pda_request_unthrottle(struct work_struct *work)\r\n{\r\nstruct keyspan_pda_private *priv =\r\ncontainer_of(work, struct keyspan_pda_private, unthrottle_work);\r\nstruct usb_serial *serial = priv->serial;\r\nint result;\r\nresult = usb_control_msg(serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\n7,\r\nUSB_TYPE_VENDOR | USB_RECIP_INTERFACE\r\n| USB_DIR_OUT,\r\n16,\r\n0,\r\nNULL,\r\n0,\r\n2000);\r\nif (result < 0)\r\ndbg("%s - error %d from usb_control_msg",\r\n__func__, result);\r\n}\r\nstatic void keyspan_pda_rx_interrupt(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint retval;\r\nint status = urb->status;\r\nstruct keyspan_pda_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nswitch (data[0]) {\r\ncase 0:\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && urb->actual_length) {\r\ntty_insert_flip_string(tty, data + 1,\r\nurb->actual_length - 1);\r\ntty_flip_buffer_push(tty);\r\n}\r\ntty_kref_put(tty);\r\nbreak;\r\ncase 1:\r\ndbg(" rx int, d1=%d, d2=%d", data[1], data[2]);\r\nswitch (data[1]) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\npriv->tx_throttled = 0;\r\nschedule_work(&priv->wakeup_work);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&port->dev,\r\n"%s - usb_submit_urb failed with result %d",\r\n__func__, retval);\r\n}\r\nstatic void keyspan_pda_rx_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\nstatic void keyspan_pda_rx_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nif (usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL))\r\ndbg(" usb_submit_urb(read urb) failed");\r\n}\r\nstatic speed_t keyspan_pda_setbaud(struct usb_serial *serial, speed_t baud)\r\n{\r\nint rc;\r\nint bindex;\r\nswitch (baud) {\r\ncase 110:\r\nbindex = 0;\r\nbreak;\r\ncase 300:\r\nbindex = 1;\r\nbreak;\r\ncase 1200:\r\nbindex = 2;\r\nbreak;\r\ncase 2400:\r\nbindex = 3;\r\nbreak;\r\ncase 4800:\r\nbindex = 4;\r\nbreak;\r\ncase 9600:\r\nbindex = 5;\r\nbreak;\r\ncase 19200:\r\nbindex = 6;\r\nbreak;\r\ncase 38400:\r\nbindex = 7;\r\nbreak;\r\ncase 57600:\r\nbindex = 8;\r\nbreak;\r\ncase 115200:\r\nbindex = 9;\r\nbreak;\r\ndefault:\r\nbindex = 5;\r\nbaud = 9600;\r\n}\r\nrc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\n0,\r\nUSB_TYPE_VENDOR\r\n| USB_RECIP_INTERFACE\r\n| USB_DIR_OUT,\r\nbindex,\r\n0,\r\nNULL,\r\n0,\r\n2000);\r\nif (rc < 0)\r\nreturn 0;\r\nreturn baud;\r\n}\r\nstatic void keyspan_pda_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nint value;\r\nint result;\r\nif (break_state == -1)\r\nvalue = 1;\r\nelse\r\nvalue = 0;\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\n4,\r\nUSB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,\r\nvalue, 0, NULL, 0, 2000);\r\nif (result < 0)\r\ndbg("%s - error %d from usb_control_msg",\r\n__func__, result);\r\n}\r\nstatic void keyspan_pda_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nspeed_t speed;\r\nspeed = tty_get_baud_rate(tty);\r\nspeed = keyspan_pda_setbaud(serial, speed);\r\nif (speed == 0) {\r\ndbg("can't handle requested baud rate");\r\nspeed = tty_termios_baud_rate(old_termios);\r\n}\r\ntty_termios_copy_hw(tty->termios, old_termios);\r\ntty_encode_baud_rate(tty, speed, speed);\r\n}\r\nstatic int keyspan_pda_get_modem_info(struct usb_serial *serial,\r\nunsigned char *value)\r\n{\r\nint rc;\r\nu8 *data;\r\ndata = kmalloc(1, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nrc = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\n3,\r\nUSB_TYPE_VENDOR|USB_RECIP_INTERFACE|USB_DIR_IN,\r\n0, 0, data, 1, 2000);\r\nif (rc >= 0)\r\n*value = *data;\r\nkfree(data);\r\nreturn rc;\r\n}\r\nstatic int keyspan_pda_set_modem_info(struct usb_serial *serial,\r\nunsigned char value)\r\n{\r\nint rc;\r\nrc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\n3,\r\nUSB_TYPE_VENDOR|USB_RECIP_INTERFACE|USB_DIR_OUT,\r\nvalue, 0, NULL, 0, 2000);\r\nreturn rc;\r\n}\r\nstatic int keyspan_pda_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nint rc;\r\nunsigned char status;\r\nint value;\r\nrc = keyspan_pda_get_modem_info(serial, &status);\r\nif (rc < 0)\r\nreturn rc;\r\nvalue =\r\n((status & (1<<7)) ? TIOCM_DTR : 0) |\r\n((status & (1<<6)) ? TIOCM_CAR : 0) |\r\n((status & (1<<5)) ? TIOCM_RNG : 0) |\r\n((status & (1<<4)) ? TIOCM_DSR : 0) |\r\n((status & (1<<3)) ? TIOCM_CTS : 0) |\r\n((status & (1<<2)) ? TIOCM_RTS : 0);\r\nreturn value;\r\n}\r\nstatic int keyspan_pda_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_serial *serial = port->serial;\r\nint rc;\r\nunsigned char status;\r\nrc = keyspan_pda_get_modem_info(serial, &status);\r\nif (rc < 0)\r\nreturn rc;\r\nif (set & TIOCM_RTS)\r\nstatus |= (1<<2);\r\nif (set & TIOCM_DTR)\r\nstatus |= (1<<7);\r\nif (clear & TIOCM_RTS)\r\nstatus &= ~(1<<2);\r\nif (clear & TIOCM_DTR)\r\nstatus &= ~(1<<7);\r\nrc = keyspan_pda_set_modem_info(serial, status);\r\nreturn rc;\r\n}\r\nstatic int keyspan_pda_write(struct tty_struct *tty,\r\nstruct usb_serial_port *port, const unsigned char *buf, int count)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nint request_unthrottle = 0;\r\nint rc = 0;\r\nstruct keyspan_pda_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nif (count == 0) {\r\ndbg(" write request of 0 bytes");\r\nreturn 0;\r\n}\r\nspin_lock_bh(&port->lock);\r\nif (!test_bit(0, &port->write_urbs_free) || priv->tx_throttled) {\r\nspin_unlock_bh(&port->lock);\r\nreturn 0;\r\n}\r\nclear_bit(0, &port->write_urbs_free);\r\nspin_unlock_bh(&port->lock);\r\ncount = (count > port->bulk_out_size) ? port->bulk_out_size : count;\r\nif (count > priv->tx_room && !in_interrupt()) {\r\nu8 *room;\r\nroom = kmalloc(1, GFP_KERNEL);\r\nif (!room) {\r\nrc = -ENOMEM;\r\ngoto exit;\r\n}\r\nrc = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\n6,\r\nUSB_TYPE_VENDOR | USB_RECIP_INTERFACE\r\n| USB_DIR_IN,\r\n0,\r\n0,\r\nroom,\r\n1,\r\n2000);\r\nif (rc > 0) {\r\ndbg(" roomquery says %d", *room);\r\npriv->tx_room = *room;\r\n}\r\nkfree(room);\r\nif (rc < 0) {\r\ndbg(" roomquery failed");\r\ngoto exit;\r\n}\r\nif (rc == 0) {\r\ndbg(" roomquery returned 0 bytes");\r\nrc = -EIO;\r\ngoto exit;\r\n}\r\n}\r\nif (count > priv->tx_room) {\r\ncount = priv->tx_room;\r\nrequest_unthrottle = 1;\r\n}\r\nif (count) {\r\nmemcpy(port->write_urb->transfer_buffer, buf, count);\r\nport->write_urb->transfer_buffer_length = count;\r\npriv->tx_room -= count;\r\nrc = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (rc) {\r\ndbg(" usb_submit_urb(write bulk) failed");\r\ngoto exit;\r\n}\r\n} else {\r\nrequest_unthrottle = 1;\r\n}\r\nif (request_unthrottle) {\r\npriv->tx_throttled = 1;\r\nschedule_work(&priv->unthrottle_work);\r\n}\r\nrc = count;\r\nexit:\r\nif (rc < 0)\r\nset_bit(0, &port->write_urbs_free);\r\nreturn rc;\r\n}\r\nstatic void keyspan_pda_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct keyspan_pda_private *priv;\r\nset_bit(0, &port->write_urbs_free);\r\npriv = usb_get_serial_port_data(port);\r\nschedule_work(&priv->wakeup_work);\r\n}\r\nstatic int keyspan_pda_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct keyspan_pda_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nreturn priv->tx_room;\r\n}\r\nstatic int keyspan_pda_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct keyspan_pda_private *priv;\r\nunsigned long flags;\r\nint ret = 0;\r\npriv = usb_get_serial_port_data(port);\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (!test_bit(0, &port->write_urbs_free) || priv->tx_throttled)\r\nret = 256;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void keyspan_pda_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nif (serial->dev) {\r\nif (on)\r\nkeyspan_pda_set_modem_info(serial, (1<<7) | (1<< 2));\r\nelse\r\nkeyspan_pda_set_modem_info(serial, 0);\r\n}\r\n}\r\nstatic int keyspan_pda_open(struct tty_struct *tty,\r\nstruct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nu8 *room;\r\nint rc = 0;\r\nstruct keyspan_pda_private *priv;\r\nroom = kmalloc(1, GFP_KERNEL);\r\nif (!room)\r\nreturn -ENOMEM;\r\nrc = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\n6,\r\nUSB_TYPE_VENDOR | USB_RECIP_INTERFACE\r\n| USB_DIR_IN,\r\n0,\r\n0,\r\nroom,\r\n1,\r\n2000);\r\nif (rc < 0) {\r\ndbg("%s - roomquery failed", __func__);\r\ngoto error;\r\n}\r\nif (rc == 0) {\r\ndbg("%s - roomquery returned 0 bytes", __func__);\r\nrc = -EIO;\r\ngoto error;\r\n}\r\npriv = usb_get_serial_port_data(port);\r\npriv->tx_room = *room;\r\npriv->tx_throttled = *room ? 0 : 1;\r\nrc = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (rc) {\r\ndbg("%s - usb_submit_urb(read int) failed", __func__);\r\ngoto error;\r\n}\r\nerror:\r\nkfree(room);\r\nreturn rc;\r\n}\r\nstatic void keyspan_pda_close(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nif (serial->dev) {\r\nusb_kill_urb(port->write_urb);\r\nusb_kill_urb(port->interrupt_in_urb);\r\n}\r\n}\r\nstatic int keyspan_pda_fake_startup(struct usb_serial *serial)\r\n{\r\nint response;\r\nconst char *fw_name;\r\nconst struct ihex_binrec *record;\r\nconst struct firmware *fw;\r\nresponse = ezusb_set_reset(serial, 1);\r\nif (0) { ; }\r\n#ifdef KEYSPAN\r\nelse if (le16_to_cpu(serial->dev->descriptor.idVendor) == KEYSPAN_VENDOR_ID)\r\nfw_name = "keyspan_pda/keyspan_pda.fw";\r\n#endif\r\n#ifdef XIRCOM\r\nelse if ((le16_to_cpu(serial->dev->descriptor.idVendor) == XIRCOM_VENDOR_ID) ||\r\n(le16_to_cpu(serial->dev->descriptor.idVendor) == ENTREGRA_VENDOR_ID))\r\nfw_name = "keyspan_pda/xircom_pgs.fw";\r\n#endif\r\nelse {\r\ndev_err(&serial->dev->dev, "%s: unknown vendor, aborting.\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nif (request_ihex_firmware(&fw, fw_name, &serial->dev->dev)) {\r\ndev_err(&serial->dev->dev, "failed to load firmware \"%s\"\n",\r\nfw_name);\r\nreturn -ENOENT;\r\n}\r\nrecord = (const struct ihex_binrec *)fw->data;\r\nwhile (record) {\r\nresponse = ezusb_writememory(serial, be32_to_cpu(record->addr),\r\n(unsigned char *)record->data,\r\nbe16_to_cpu(record->len), 0xa0);\r\nif (response < 0) {\r\ndev_err(&serial->dev->dev, "ezusb_writememory failed "\r\n"for Keyspan PDA firmware (%d %04X %p %d)\n",\r\nresponse, be32_to_cpu(record->addr),\r\nrecord->data, be16_to_cpu(record->len));\r\nbreak;\r\n}\r\nrecord = ihex_next_binrec(record);\r\n}\r\nrelease_firmware(fw);\r\nresponse = ezusb_set_reset(serial, 0);\r\nreturn 1;\r\n}\r\nstatic int keyspan_pda_startup(struct usb_serial *serial)\r\n{\r\nstruct keyspan_pda_private *priv;\r\npriv = kmalloc(sizeof(struct keyspan_pda_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn 1;\r\nusb_set_serial_port_data(serial->port[0], priv);\r\ninit_waitqueue_head(&serial->port[0]->write_wait);\r\nINIT_WORK(&priv->wakeup_work, keyspan_pda_wakeup_write);\r\nINIT_WORK(&priv->unthrottle_work, keyspan_pda_request_unthrottle);\r\npriv->serial = serial;\r\npriv->port = serial->port[0];\r\nreturn 0;\r\n}\r\nstatic void keyspan_pda_release(struct usb_serial *serial)\r\n{\r\nkfree(usb_get_serial_port_data(serial->port[0]));\r\n}
