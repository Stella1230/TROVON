static inline int\r\nrix_to_ndx(struct minstrel_sta_info *mi, int rix)\r\n{\r\nint i = rix;\r\nfor (i = rix; i >= 0; i--)\r\nif (mi->r[i].rix == rix)\r\nbreak;\r\nreturn i;\r\n}\r\nstatic void\r\nminstrel_update_stats(struct minstrel_priv *mp, struct minstrel_sta_info *mi)\r\n{\r\nu32 max_tp = 0, index_max_tp = 0, index_max_tp2 = 0;\r\nu32 max_prob = 0, index_max_prob = 0;\r\nu32 usecs;\r\nu32 p;\r\nint i;\r\nmi->stats_update = jiffies;\r\nfor (i = 0; i < mi->n_rates; i++) {\r\nstruct minstrel_rate *mr = &mi->r[i];\r\nusecs = mr->perfect_tx_time;\r\nif (!usecs)\r\nusecs = 1000000;\r\nif (mr->attempts) {\r\np = (mr->success * 18000) / mr->attempts;\r\nmr->succ_hist += mr->success;\r\nmr->att_hist += mr->attempts;\r\nmr->cur_prob = p;\r\np = ((p * (100 - mp->ewma_level)) + (mr->probability *\r\nmp->ewma_level)) / 100;\r\nmr->probability = p;\r\nmr->cur_tp = p * (1000000 / usecs);\r\n}\r\nmr->last_success = mr->success;\r\nmr->last_attempts = mr->attempts;\r\nmr->success = 0;\r\nmr->attempts = 0;\r\nif ((mr->probability > 17100) || (mr->probability < 1800)) {\r\nmr->adjusted_retry_count = mr->retry_count >> 1;\r\nif (mr->adjusted_retry_count > 2)\r\nmr->adjusted_retry_count = 2;\r\nmr->sample_limit = 4;\r\n} else {\r\nmr->sample_limit = -1;\r\nmr->adjusted_retry_count = mr->retry_count;\r\n}\r\nif (!mr->adjusted_retry_count)\r\nmr->adjusted_retry_count = 2;\r\n}\r\nfor (i = 0; i < mi->n_rates; i++) {\r\nstruct minstrel_rate *mr = &mi->r[i];\r\nif (max_tp < mr->cur_tp) {\r\nindex_max_tp = i;\r\nmax_tp = mr->cur_tp;\r\n}\r\nif (max_prob < mr->probability) {\r\nindex_max_prob = i;\r\nmax_prob = mr->probability;\r\n}\r\n}\r\nmax_tp = 0;\r\nfor (i = 0; i < mi->n_rates; i++) {\r\nstruct minstrel_rate *mr = &mi->r[i];\r\nif (i == index_max_tp)\r\ncontinue;\r\nif (max_tp < mr->cur_tp) {\r\nindex_max_tp2 = i;\r\nmax_tp = mr->cur_tp;\r\n}\r\n}\r\nmi->max_tp_rate = index_max_tp;\r\nmi->max_tp_rate2 = index_max_tp2;\r\nmi->max_prob_rate = index_max_prob;\r\n}\r\nstatic void\r\nminstrel_tx_status(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_tx_rate *ar = info->status.rates;\r\nint i, ndx;\r\nint success;\r\nsuccess = !!(info->flags & IEEE80211_TX_STAT_ACK);\r\nfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\r\nif (ar[i].idx < 0)\r\nbreak;\r\nndx = rix_to_ndx(mi, ar[i].idx);\r\nif (ndx < 0)\r\ncontinue;\r\nmi->r[ndx].attempts += ar[i].count;\r\nif ((i != IEEE80211_TX_MAX_RATES - 1) && (ar[i + 1].idx < 0))\r\nmi->r[ndx].success += success;\r\n}\r\nif ((info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE) && (i >= 0))\r\nmi->sample_count++;\r\nif (mi->sample_deferred > 0)\r\nmi->sample_deferred--;\r\n}\r\nstatic inline unsigned int\r\nminstrel_get_retry_count(struct minstrel_rate *mr,\r\nstruct ieee80211_tx_info *info)\r\n{\r\nunsigned int retry = mr->adjusted_retry_count;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)\r\nretry = max(2U, min(mr->retry_count_rtscts, retry));\r\nelse if (info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\r\nretry = max(2U, min(mr->retry_count_cts, retry));\r\nreturn retry;\r\n}\r\nstatic int\r\nminstrel_get_next_sample(struct minstrel_sta_info *mi)\r\n{\r\nunsigned int sample_ndx;\r\nsample_ndx = SAMPLE_TBL(mi, mi->sample_idx, mi->sample_column);\r\nmi->sample_idx++;\r\nif ((int) mi->sample_idx > (mi->n_rates - 2)) {\r\nmi->sample_idx = 0;\r\nmi->sample_column++;\r\nif (mi->sample_column >= SAMPLE_COLUMNS)\r\nmi->sample_column = 0;\r\n}\r\nreturn sample_ndx;\r\n}\r\nstatic void\r\nminstrel_get_rate(void *priv, struct ieee80211_sta *sta,\r\nvoid *priv_sta, struct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct sk_buff *skb = txrc->skb;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_tx_rate *ar = info->control.rates;\r\nunsigned int ndx, sample_ndx = 0;\r\nbool mrr;\r\nbool sample_slower = false;\r\nbool sample = false;\r\nint i, delta;\r\nint mrr_ndx[3];\r\nint sample_rate;\r\nif (rate_control_send_low(sta, priv_sta, txrc))\r\nreturn;\r\nmrr = mp->has_mrr && !txrc->rts && !txrc->bss_conf->use_cts_prot;\r\nif (time_after(jiffies, mi->stats_update + (mp->update_interval *\r\nHZ) / 1000))\r\nminstrel_update_stats(mp, mi);\r\nndx = mi->max_tp_rate;\r\nif (mrr)\r\nsample_rate = mp->lookaround_rate_mrr;\r\nelse\r\nsample_rate = mp->lookaround_rate;\r\nmi->packet_count++;\r\ndelta = (mi->packet_count * sample_rate / 100) -\r\n(mi->sample_count + mi->sample_deferred / 2);\r\nif ((delta > 0) && (mrr || !mi->prev_sample)) {\r\nstruct minstrel_rate *msr;\r\nif (mi->packet_count >= 10000) {\r\nmi->sample_deferred = 0;\r\nmi->sample_count = 0;\r\nmi->packet_count = 0;\r\n} else if (delta > mi->n_rates * 2) {\r\nmi->sample_count += (delta - mi->n_rates * 2);\r\n}\r\nsample_ndx = minstrel_get_next_sample(mi);\r\nmsr = &mi->r[sample_ndx];\r\nsample = true;\r\nsample_slower = mrr && (msr->perfect_tx_time >\r\nmi->r[ndx].perfect_tx_time);\r\nif (!sample_slower) {\r\nif (msr->sample_limit != 0) {\r\nndx = sample_ndx;\r\nmi->sample_count++;\r\nif (msr->sample_limit > 0)\r\nmsr->sample_limit--;\r\n} else {\r\nsample = false;\r\n}\r\n} else {\r\ninfo->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;\r\nmi->sample_deferred++;\r\n}\r\n}\r\nmi->prev_sample = sample;\r\nif (!mrr && sample && (mi->r[ndx].probability > 17100))\r\nndx = mi->max_tp_rate;\r\nar[0].idx = mi->r[ndx].rix;\r\nar[0].count = minstrel_get_retry_count(&mi->r[ndx], info);\r\nif (!mrr) {\r\nif (!sample)\r\nar[0].count = mp->max_retry;\r\nar[1].idx = mi->lowest_rix;\r\nar[1].count = mp->max_retry;\r\nreturn;\r\n}\r\nif (sample) {\r\nif (sample_slower)\r\nmrr_ndx[0] = sample_ndx;\r\nelse\r\nmrr_ndx[0] = mi->max_tp_rate;\r\n} else {\r\nmrr_ndx[0] = mi->max_tp_rate2;\r\n}\r\nmrr_ndx[1] = mi->max_prob_rate;\r\nmrr_ndx[2] = 0;\r\nfor (i = 1; i < 4; i++) {\r\nar[i].idx = mi->r[mrr_ndx[i - 1]].rix;\r\nar[i].count = mi->r[mrr_ndx[i - 1]].adjusted_retry_count;\r\n}\r\n}\r\nstatic void\r\ncalc_rate_durations(enum ieee80211_band band,\r\nstruct minstrel_rate *d,\r\nstruct ieee80211_rate *rate)\r\n{\r\nint erp = !!(rate->flags & IEEE80211_RATE_ERP_G);\r\nd->perfect_tx_time = ieee80211_frame_duration(band, 1200,\r\nrate->bitrate, erp, 1);\r\nd->ack_time = ieee80211_frame_duration(band, 10,\r\nrate->bitrate, erp, 1);\r\n}\r\nstatic void\r\ninit_sample_table(struct minstrel_sta_info *mi)\r\n{\r\nunsigned int i, col, new_idx;\r\nunsigned int n_srates = mi->n_rates - 1;\r\nu8 rnd[8];\r\nmi->sample_column = 0;\r\nmi->sample_idx = 0;\r\nmemset(mi->sample_table, 0, SAMPLE_COLUMNS * mi->n_rates);\r\nfor (col = 0; col < SAMPLE_COLUMNS; col++) {\r\nfor (i = 0; i < n_srates; i++) {\r\nget_random_bytes(rnd, sizeof(rnd));\r\nnew_idx = (i + rnd[i & 7]) % n_srates;\r\nwhile (SAMPLE_TBL(mi, new_idx, col) != 0)\r\nnew_idx = (new_idx + 1) % n_srates;\r\nSAMPLE_TBL(mi, new_idx, col) = i + 1;\r\n}\r\n}\r\n}\r\nstatic void\r\nminstrel_rate_init(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_rate *ctl_rate;\r\nunsigned int i, n = 0;\r\nunsigned int t_slot = 9;\r\nmi->lowest_rix = rate_lowest_index(sband, sta);\r\nctl_rate = &sband->bitrates[mi->lowest_rix];\r\nmi->sp_ack_dur = ieee80211_frame_duration(sband->band, 10,\r\nctl_rate->bitrate,\r\n!!(ctl_rate->flags & IEEE80211_RATE_ERP_G), 1);\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nstruct minstrel_rate *mr = &mi->r[n];\r\nunsigned int tx_time = 0, tx_time_cts = 0, tx_time_rtscts = 0;\r\nunsigned int tx_time_single;\r\nunsigned int cw = mp->cw_min;\r\nif (!rate_supported(sta, sband->band, i))\r\ncontinue;\r\nn++;\r\nmemset(mr, 0, sizeof(*mr));\r\nmr->rix = i;\r\nmr->bitrate = sband->bitrates[i].bitrate / 5;\r\ncalc_rate_durations(sband->band, mr, &sband->bitrates[i]);\r\nmr->sample_limit = -1;\r\nmr->retry_count = 1;\r\nmr->retry_count_cts = 1;\r\nmr->retry_count_rtscts = 1;\r\ntx_time = mr->perfect_tx_time + mi->sp_ack_dur;\r\ndo {\r\ntx_time_single = mr->ack_time + mr->perfect_tx_time;\r\ntx_time_single += (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\ntx_time += tx_time_single;\r\ntx_time_cts += tx_time_single + mi->sp_ack_dur;\r\ntx_time_rtscts += tx_time_single + 2 * mi->sp_ack_dur;\r\nif ((tx_time_cts < mp->segment_size) &&\r\n(mr->retry_count_cts < mp->max_retry))\r\nmr->retry_count_cts++;\r\nif ((tx_time_rtscts < mp->segment_size) &&\r\n(mr->retry_count_rtscts < mp->max_retry))\r\nmr->retry_count_rtscts++;\r\n} while ((tx_time < mp->segment_size) &&\r\n(++mr->retry_count < mp->max_retry));\r\nmr->adjusted_retry_count = mr->retry_count;\r\n}\r\nfor (i = n; i < sband->n_bitrates; i++) {\r\nstruct minstrel_rate *mr = &mi->r[i];\r\nmr->rix = -1;\r\n}\r\nmi->n_rates = n;\r\nmi->stats_update = jiffies;\r\ninit_sample_table(mi);\r\n}\r\nstatic void *\r\nminstrel_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct minstrel_sta_info *mi;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_hw *hw = mp->hw;\r\nint max_rates = 0;\r\nint i;\r\nmi = kzalloc(sizeof(struct minstrel_sta_info), gfp);\r\nif (!mi)\r\nreturn NULL;\r\nfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\r\nsband = hw->wiphy->bands[i];\r\nif (sband && sband->n_bitrates > max_rates)\r\nmax_rates = sband->n_bitrates;\r\n}\r\nmi->r = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);\r\nif (!mi->r)\r\ngoto error;\r\nmi->sample_table = kmalloc(SAMPLE_COLUMNS * max_rates, gfp);\r\nif (!mi->sample_table)\r\ngoto error1;\r\nmi->stats_update = jiffies;\r\nreturn mi;\r\nerror1:\r\nkfree(mi->r);\r\nerror:\r\nkfree(mi);\r\nreturn NULL;\r\n}\r\nstatic void\r\nminstrel_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_sta_info *mi = priv_sta;\r\nkfree(mi->sample_table);\r\nkfree(mi->r);\r\nkfree(mi);\r\n}\r\nstatic void *\r\nminstrel_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nstruct minstrel_priv *mp;\r\nmp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);\r\nif (!mp)\r\nreturn NULL;\r\nmp->cw_min = 15;\r\nmp->cw_max = 1023;\r\nmp->lookaround_rate = 5;\r\nmp->lookaround_rate_mrr = 10;\r\nmp->ewma_level = 75;\r\nmp->segment_size = 6000;\r\nif (hw->max_rate_tries > 0)\r\nmp->max_retry = hw->max_rate_tries;\r\nelse\r\nmp->max_retry = 7;\r\nif (hw->max_rates >= 4)\r\nmp->has_mrr = true;\r\nmp->hw = hw;\r\nmp->update_interval = 100;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nmp->fixed_rate_idx = (u32) -1;\r\nmp->dbg_fixed_rate = debugfs_create_u32("fixed_rate_idx",\r\nS_IRUGO | S_IWUGO, debugfsdir, &mp->fixed_rate_idx);\r\n#endif\r\nreturn mp;\r\n}\r\nstatic void\r\nminstrel_free(void *priv)\r\n{\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\ndebugfs_remove(((struct minstrel_priv *)priv)->dbg_fixed_rate);\r\n#endif\r\nkfree(priv);\r\n}\r\nint __init\r\nrc80211_minstrel_init(void)\r\n{\r\nreturn ieee80211_rate_control_register(&mac80211_minstrel);\r\n}\r\nvoid\r\nrc80211_minstrel_exit(void)\r\n{\r\nieee80211_rate_control_unregister(&mac80211_minstrel);\r\n}
