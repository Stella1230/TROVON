static inline unsigned long efficeon_mask_memory(struct page *page)\r\n{\r\nunsigned long addr = page_to_phys(page);\r\nreturn addr | 0x00000001;\r\n}\r\nstatic int efficeon_fetch_size(void)\r\n{\r\nint i;\r\nu16 temp;\r\nstruct aper_size_info_lvl2 *values;\r\npci_read_config_word(agp_bridge->dev, INTEL_APSIZE, &temp);\r\nvalues = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (temp == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void efficeon_tlbflush(struct agp_memory * mem)\r\n{\r\nprintk(KERN_DEBUG PFX "efficeon_tlbflush()\n");\r\npci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, 0x2200);\r\npci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, 0x2280);\r\n}\r\nstatic void efficeon_cleanup(void)\r\n{\r\nu16 temp;\r\nstruct aper_size_info_lvl2 *previous_size;\r\nprintk(KERN_DEBUG PFX "efficeon_cleanup()\n");\r\nprevious_size = A_SIZE_LVL2(agp_bridge->previous_size);\r\npci_read_config_word(agp_bridge->dev, INTEL_NBXCFG, &temp);\r\npci_write_config_word(agp_bridge->dev, INTEL_NBXCFG, temp & ~(1 << 9));\r\npci_write_config_word(agp_bridge->dev, INTEL_APSIZE,\r\nprevious_size->size_value);\r\n}\r\nstatic int efficeon_configure(void)\r\n{\r\nu32 temp;\r\nu16 temp2;\r\nstruct aper_size_info_lvl2 *current_size;\r\nprintk(KERN_DEBUG PFX "efficeon_configure()\n");\r\ncurrent_size = A_SIZE_LVL2(agp_bridge->current_size);\r\npci_write_config_word(agp_bridge->dev, INTEL_APSIZE,\r\ncurrent_size->size_value);\r\npci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);\r\nagp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\npci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, 0x2280);\r\npci_read_config_word(agp_bridge->dev, INTEL_NBXCFG, &temp2);\r\npci_write_config_word(agp_bridge->dev, INTEL_NBXCFG,\r\n(temp2 & ~(1 << 10)) | (1 << 9) | (1 << 11));\r\npci_write_config_byte(agp_bridge->dev, INTEL_ERRSTS + 1, 7);\r\nreturn 0;\r\n}\r\nstatic int efficeon_free_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nint index, freed = 0;\r\nfor (index = 0; index < EFFICEON_L1_SIZE; index++) {\r\nunsigned long page = efficeon_private.l1_table[index];\r\nif (page) {\r\nefficeon_private.l1_table[index] = 0;\r\nClearPageReserved(virt_to_page((char *)page));\r\nfree_page(page);\r\nfreed++;\r\n}\r\nprintk(KERN_DEBUG PFX "efficeon_free_gatt_table(%p, %02x, %08x)\n",\r\nagp_bridge->dev, EFFICEON_ATTPAGE, index);\r\npci_write_config_dword(agp_bridge->dev,\r\nEFFICEON_ATTPAGE, index);\r\n}\r\nprintk(KERN_DEBUG PFX "efficeon_free_gatt_table() freed %d pages\n", freed);\r\nreturn 0;\r\n}\r\nstatic int efficeon_create_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nint index;\r\nconst int pati = EFFICEON_PATI;\r\nconst int present = EFFICEON_PRESENT;\r\nconst int clflush_chunk = ((cpuid_ebx(1) >> 8) & 0xff) << 3;\r\nint num_entries, l1_pages;\r\nnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\r\nprintk(KERN_DEBUG PFX "efficeon_create_gatt_table(%d)\n", num_entries);\r\nBUG_ON(num_entries & 0x3ff);\r\nl1_pages = num_entries >> 10;\r\nfor (index = 0 ; index < l1_pages ; index++) {\r\nint offset;\r\nunsigned long page;\r\nunsigned long value;\r\npage = efficeon_private.l1_table[index];\r\nBUG_ON(page);\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page) {\r\nefficeon_free_gatt_table(agp_bridge);\r\nreturn -ENOMEM;\r\n}\r\nSetPageReserved(virt_to_page((char *)page));\r\nfor (offset = 0; offset < PAGE_SIZE; offset += clflush_chunk)\r\nclflush((char *)page+offset);\r\nefficeon_private.l1_table[index] = page;\r\nvalue = virt_to_phys((unsigned long *)page) | pati | present | index;\r\npci_write_config_dword(agp_bridge->dev,\r\nEFFICEON_ATTPAGE, value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int efficeon_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\r\n{\r\nint i, count = mem->page_count, num_entries;\r\nunsigned int *page, *last_page;\r\nconst int clflush_chunk = ((cpuid_ebx(1) >> 8) & 0xff) << 3;\r\nconst unsigned long clflush_mask = ~(clflush_chunk-1);\r\nprintk(KERN_DEBUG PFX "efficeon_insert_memory(%lx, %d)\n", pg_start, count);\r\nnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\r\nif ((pg_start + mem->page_count) > num_entries)\r\nreturn -EINVAL;\r\nif (type != 0 || mem->type != 0)\r\nreturn -EINVAL;\r\nif (!mem->is_flushed) {\r\nglobal_cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nlast_page = NULL;\r\nfor (i = 0; i < count; i++) {\r\nint index = pg_start + i;\r\nunsigned long insert = efficeon_mask_memory(mem->pages[i]);\r\npage = (unsigned int *) efficeon_private.l1_table[index >> 10];\r\nif (!page)\r\ncontinue;\r\npage += (index & 0x3ff);\r\n*page = insert;\r\nif (last_page &&\r\n(((unsigned long)page^(unsigned long)last_page) &\r\nclflush_mask))\r\nclflush(last_page);\r\nlast_page = page;\r\n}\r\nif ( last_page )\r\nclflush(last_page);\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic int efficeon_remove_memory(struct agp_memory * mem, off_t pg_start, int type)\r\n{\r\nint i, count = mem->page_count, num_entries;\r\nprintk(KERN_DEBUG PFX "efficeon_remove_memory(%lx, %d)\n", pg_start, count);\r\nnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\r\nif ((pg_start + mem->page_count) > num_entries)\r\nreturn -EINVAL;\r\nif (type != 0 || mem->type != 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < count; i++) {\r\nint index = pg_start + i;\r\nunsigned int *page = (unsigned int *) efficeon_private.l1_table[index >> 10];\r\nif (!page)\r\ncontinue;\r\npage += (index & 0x3ff);\r\n*page = 0;\r\n}\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic int __devinit agp_efficeon_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nu8 cap_ptr;\r\nstruct resource *r;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\nif (pdev->device != PCI_DEVICE_ID_EFFICEON) {\r\nprintk(KERN_ERR PFX "Unsupported Efficeon chipset (device id: %04x)\n",\r\npdev->device);\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO PFX "Detected Transmeta Efficeon TM8000 series chipset\n");\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->driver = &efficeon_driver;\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\nif (pci_enable_device(pdev)) {\r\nprintk(KERN_ERR PFX "Unable to Enable PCI device\n");\r\nagp_put_bridge(bridge);\r\nreturn -ENODEV;\r\n}\r\nr = &pdev->resource[0];\r\nif (!r->start && r->end) {\r\nif (pci_assign_resource(pdev, 0)) {\r\nprintk(KERN_ERR PFX "could not assign resource 0\n");\r\nagp_put_bridge(bridge);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (cap_ptr) {\r\npci_read_config_dword(pdev,\r\nbridge->capndx+PCI_AGP_STATUS,\r\n&bridge->mode);\r\n}\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void __devexit agp_efficeon_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int agp_efficeon_suspend(struct pci_dev *dev, pm_message_t state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int agp_efficeon_resume(struct pci_dev *pdev)\r\n{\r\nprintk(KERN_DEBUG PFX "agp_efficeon_resume()\n");\r\nreturn efficeon_configure();\r\n}\r\nstatic int __init agp_efficeon_init(void)\r\n{\r\nstatic int agp_initialised=0;\r\nif (agp_off)\r\nreturn -EINVAL;\r\nif (agp_initialised == 1)\r\nreturn 0;\r\nagp_initialised=1;\r\nreturn pci_register_driver(&agp_efficeon_pci_driver);\r\n}\r\nstatic void __exit agp_efficeon_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_efficeon_pci_driver);\r\n}
