static void kvp_acquire_lock(int pool)\r\n{\r\nstruct flock fl = {F_WRLCK, SEEK_SET, 0, 0, 0};\r\nfl.l_pid = getpid();\r\nif (fcntl(kvp_file_info[pool].fd, F_SETLKW, &fl) == -1) {\r\nsyslog(LOG_ERR, "Failed to acquire the lock pool: %d", pool);\r\nexit(-1);\r\n}\r\n}\r\nstatic void kvp_release_lock(int pool)\r\n{\r\nstruct flock fl = {F_UNLCK, SEEK_SET, 0, 0, 0};\r\nfl.l_pid = getpid();\r\nif (fcntl(kvp_file_info[pool].fd, F_SETLK, &fl) == -1) {\r\nperror("fcntl");\r\nsyslog(LOG_ERR, "Failed to release the lock pool: %d", pool);\r\nexit(-1);\r\n}\r\n}\r\nstatic void kvp_update_file(int pool)\r\n{\r\nFILE *filep;\r\nsize_t bytes_written;\r\nkvp_acquire_lock(pool);\r\nfilep = fopen(kvp_file_info[pool].fname, "w");\r\nif (!filep) {\r\nkvp_release_lock(pool);\r\nsyslog(LOG_ERR, "Failed to open file, pool: %d", pool);\r\nexit(-1);\r\n}\r\nbytes_written = fwrite(kvp_file_info[pool].records,\r\nsizeof(struct kvp_record),\r\nkvp_file_info[pool].num_records, filep);\r\nfflush(filep);\r\nkvp_release_lock(pool);\r\n}\r\nstatic void kvp_update_mem_state(int pool)\r\n{\r\nFILE *filep;\r\nsize_t records_read = 0;\r\nstruct kvp_record *record = kvp_file_info[pool].records;\r\nstruct kvp_record *readp;\r\nint num_blocks = kvp_file_info[pool].num_blocks;\r\nint alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;\r\nkvp_acquire_lock(pool);\r\nfilep = fopen(kvp_file_info[pool].fname, "r");\r\nif (!filep) {\r\nkvp_release_lock(pool);\r\nsyslog(LOG_ERR, "Failed to open file, pool: %d", pool);\r\nexit(-1);\r\n}\r\nwhile (!feof(filep)) {\r\nreadp = &record[records_read];\r\nrecords_read += fread(readp, sizeof(struct kvp_record),\r\nENTRIES_PER_BLOCK * num_blocks,\r\nfilep);\r\nif (!feof(filep)) {\r\nnum_blocks++;\r\nrecord = realloc(record, alloc_unit * num_blocks);\r\nif (record == NULL) {\r\nsyslog(LOG_ERR, "malloc failed");\r\nexit(-1);\r\n}\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nkvp_file_info[pool].num_blocks = num_blocks;\r\nkvp_file_info[pool].records = record;\r\nkvp_file_info[pool].num_records = records_read;\r\nkvp_release_lock(pool);\r\n}\r\nstatic int kvp_file_init(void)\r\n{\r\nint ret, fd;\r\nFILE *filep;\r\nsize_t records_read;\r\n__u8 *fname;\r\nstruct kvp_record *record;\r\nstruct kvp_record *readp;\r\nint num_blocks;\r\nint i;\r\nint alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;\r\nif (access("/var/opt/hyperv", F_OK)) {\r\nif (mkdir("/var/opt/hyperv", S_IRUSR | S_IWUSR | S_IROTH)) {\r\nsyslog(LOG_ERR, " Failed to create /var/opt/hyperv");\r\nexit(-1);\r\n}\r\n}\r\nfor (i = 0; i < KVP_POOL_COUNT; i++) {\r\nfname = kvp_file_info[i].fname;\r\nrecords_read = 0;\r\nnum_blocks = 1;\r\nsprintf(fname, "/var/opt/hyperv/.kvp_pool_%d", i);\r\nfd = open(fname, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IROTH);\r\nif (fd == -1)\r\nreturn 1;\r\nfilep = fopen(fname, "r");\r\nif (!filep)\r\nreturn 1;\r\nrecord = malloc(alloc_unit * num_blocks);\r\nif (record == NULL) {\r\nfclose(filep);\r\nreturn 1;\r\n}\r\nwhile (!feof(filep)) {\r\nreadp = &record[records_read];\r\nrecords_read += fread(readp, sizeof(struct kvp_record),\r\nENTRIES_PER_BLOCK,\r\nfilep);\r\nif (!feof(filep)) {\r\nnum_blocks++;\r\nrecord = realloc(record, alloc_unit *\r\nnum_blocks);\r\nif (record == NULL) {\r\nfclose(filep);\r\nreturn 1;\r\n}\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nkvp_file_info[i].fd = fd;\r\nkvp_file_info[i].num_blocks = num_blocks;\r\nkvp_file_info[i].records = record;\r\nkvp_file_info[i].num_records = records_read;\r\nfclose(filep);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvp_key_delete(int pool, __u8 *key, int key_size)\r\n{\r\nint i;\r\nint j, k;\r\nint num_records;\r\nstruct kvp_record *record;\r\nkvp_update_mem_state(pool);\r\nnum_records = kvp_file_info[pool].num_records;\r\nrecord = kvp_file_info[pool].records;\r\nfor (i = 0; i < num_records; i++) {\r\nif (memcmp(key, record[i].key, key_size))\r\ncontinue;\r\nif (i == num_records) {\r\nkvp_file_info[pool].num_records--;\r\nkvp_update_file(pool);\r\nreturn 0;\r\n}\r\nj = i;\r\nk = j + 1;\r\nfor (; k < num_records; k++) {\r\nstrcpy(record[j].key, record[k].key);\r\nstrcpy(record[j].value, record[k].value);\r\nj++;\r\n}\r\nkvp_file_info[pool].num_records--;\r\nkvp_update_file(pool);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int kvp_key_add_or_modify(int pool, __u8 *key, int key_size, __u8 *value,\r\nint value_size)\r\n{\r\nint i;\r\nint j, k;\r\nint num_records;\r\nstruct kvp_record *record;\r\nint num_blocks;\r\nif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\r\n(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\r\nreturn 1;\r\nkvp_update_mem_state(pool);\r\nnum_records = kvp_file_info[pool].num_records;\r\nrecord = kvp_file_info[pool].records;\r\nnum_blocks = kvp_file_info[pool].num_blocks;\r\nfor (i = 0; i < num_records; i++) {\r\nif (memcmp(key, record[i].key, key_size))\r\ncontinue;\r\nmemcpy(record[i].value, value, value_size);\r\nkvp_update_file(pool);\r\nreturn 0;\r\n}\r\nif (num_records == (ENTRIES_PER_BLOCK * num_blocks)) {\r\nrecord = realloc(record, sizeof(struct kvp_record) *\r\nENTRIES_PER_BLOCK * (num_blocks + 1));\r\nif (record == NULL)\r\nreturn 1;\r\nkvp_file_info[pool].num_blocks++;\r\n}\r\nmemcpy(record[i].value, value, value_size);\r\nmemcpy(record[i].key, key, key_size);\r\nkvp_file_info[pool].records = record;\r\nkvp_file_info[pool].num_records++;\r\nkvp_update_file(pool);\r\nreturn 0;\r\n}\r\nstatic int kvp_get_value(int pool, __u8 *key, int key_size, __u8 *value,\r\nint value_size)\r\n{\r\nint i;\r\nint num_records;\r\nstruct kvp_record *record;\r\nif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\r\n(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\r\nreturn 1;\r\nkvp_update_mem_state(pool);\r\nnum_records = kvp_file_info[pool].num_records;\r\nrecord = kvp_file_info[pool].records;\r\nfor (i = 0; i < num_records; i++) {\r\nif (memcmp(key, record[i].key, key_size))\r\ncontinue;\r\nmemcpy(value, record[i].value, value_size);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void kvp_pool_enumerate(int pool, int index, __u8 *key, int key_size,\r\n__u8 *value, int value_size)\r\n{\r\nstruct kvp_record *record;\r\nkvp_update_mem_state(pool);\r\nrecord = kvp_file_info[pool].records;\r\nif (index >= kvp_file_info[pool].num_records) {\r\nstrcpy(value, "");\r\nreturn;\r\n}\r\nmemcpy(key, record[index].key, key_size);\r\nmemcpy(value, record[index].value, value_size);\r\n}\r\nvoid kvp_get_os_info(void)\r\n{\r\nFILE *file;\r\nchar *p, buf[512];\r\nuname(&uts_buf);\r\nos_build = uts_buf.release;\r\nprocessor_arch = uts_buf.machine;\r\np = strchr(os_build, '-');\r\nif (p)\r\n*p = '\0';\r\nfile = fopen("/etc/SuSE-release", "r");\r\nif (file != NULL)\r\ngoto kvp_osinfo_found;\r\nfile = fopen("/etc/redhat-release", "r");\r\nif (file != NULL)\r\ngoto kvp_osinfo_found;\r\nos_name = uts_buf.sysname;\r\nreturn;\r\nkvp_osinfo_found:\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (!p)\r\ngoto done;\r\nos_name = p;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (!p)\r\ngoto done;\r\nos_major = p;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (p)\r\nos_minor = p;\r\n}\r\n}\r\n}\r\ndone:\r\nfclose(file);\r\nreturn;\r\n}\r\nstatic int\r\nkvp_get_ip_address(int family, char *buffer, int length)\r\n{\r\nstruct ifaddrs *ifap;\r\nstruct ifaddrs *curp;\r\nint ipv4_len = strlen("255.255.255.255") + 1;\r\nint ipv6_len = strlen("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff")+1;\r\nint offset = 0;\r\nconst char *str;\r\nchar tmp[50];\r\nint error = 0;\r\nif (getifaddrs(&ifap)) {\r\nstrcpy(buffer, "getifaddrs failed\n");\r\nreturn 1;\r\n}\r\ncurp = ifap;\r\nwhile (curp != NULL) {\r\nif ((curp->ifa_addr != NULL) &&\r\n(curp->ifa_addr->sa_family == family)) {\r\nif (family == AF_INET) {\r\nstruct sockaddr_in *addr =\r\n(struct sockaddr_in *) curp->ifa_addr;\r\nstr = inet_ntop(family, &addr->sin_addr,\r\ntmp, 50);\r\nif (str == NULL) {\r\nstrcpy(buffer, "inet_ntop failed\n");\r\nerror = 1;\r\ngoto getaddr_done;\r\n}\r\nif (offset == 0)\r\nstrcpy(buffer, tmp);\r\nelse\r\nstrcat(buffer, tmp);\r\nstrcat(buffer, ";");\r\noffset += strlen(str) + 1;\r\nif ((length - offset) < (ipv4_len + 1))\r\ngoto getaddr_done;\r\n} else {\r\nstruct sockaddr_in6 *addr =\r\n(struct sockaddr_in6 *) curp->ifa_addr;\r\nstr = inet_ntop(family,\r\n&addr->sin6_addr.s6_addr,\r\ntmp, 50);\r\nif (str == NULL) {\r\nstrcpy(buffer, "inet_ntop failed\n");\r\nerror = 1;\r\ngoto getaddr_done;\r\n}\r\nif (offset == 0)\r\nstrcpy(buffer, tmp);\r\nelse\r\nstrcat(buffer, tmp);\r\nstrcat(buffer, ";");\r\noffset += strlen(str) + 1;\r\nif ((length - offset) < (ipv6_len + 1))\r\ngoto getaddr_done;\r\n}\r\n}\r\ncurp = curp->ifa_next;\r\n}\r\ngetaddr_done:\r\nfreeifaddrs(ifap);\r\nreturn error;\r\n}\r\nstatic int\r\nkvp_get_domain_name(char *buffer, int length)\r\n{\r\nstruct addrinfo hints, *info ;\r\nint error = 0;\r\ngethostname(buffer, length);\r\nmemset(&hints, 0, sizeof(hints));\r\nhints.ai_family = AF_INET;\r\nhints.ai_socktype = SOCK_STREAM;\r\nhints.ai_flags = AI_CANONNAME;\r\nerror = getaddrinfo(buffer, NULL, &hints, &info);\r\nif (error != 0) {\r\nstrcpy(buffer, "getaddrinfo failed\n");\r\nreturn error;\r\n}\r\nstrcpy(buffer, info->ai_canonname);\r\nfreeaddrinfo(info);\r\nreturn error;\r\n}\r\nstatic int\r\nnetlink_send(int fd, struct cn_msg *msg)\r\n{\r\nstruct nlmsghdr *nlh;\r\nunsigned int size;\r\nstruct msghdr message;\r\nchar buffer[64];\r\nstruct iovec iov[2];\r\nsize = NLMSG_SPACE(sizeof(struct cn_msg) + msg->len);\r\nnlh = (struct nlmsghdr *)buffer;\r\nnlh->nlmsg_seq = 0;\r\nnlh->nlmsg_pid = getpid();\r\nnlh->nlmsg_type = NLMSG_DONE;\r\nnlh->nlmsg_len = NLMSG_LENGTH(size - sizeof(*nlh));\r\nnlh->nlmsg_flags = 0;\r\niov[0].iov_base = nlh;\r\niov[0].iov_len = sizeof(*nlh);\r\niov[1].iov_base = msg;\r\niov[1].iov_len = size;\r\nmemset(&message, 0, sizeof(message));\r\nmessage.msg_name = &addr;\r\nmessage.msg_namelen = sizeof(addr);\r\nmessage.msg_iov = iov;\r\nmessage.msg_iovlen = 2;\r\nreturn sendmsg(fd, &message, 0);\r\n}\r\nint main(void)\r\n{\r\nint fd, len, sock_opt;\r\nint error;\r\nstruct cn_msg *message;\r\nstruct pollfd pfd;\r\nstruct nlmsghdr *incoming_msg;\r\nstruct cn_msg *incoming_cn_msg;\r\nstruct hv_kvp_msg *hv_msg;\r\nchar *p;\r\nchar *key_value;\r\nchar *key_name;\r\ndaemon(1, 0);\r\nopenlog("KVP", 0, LOG_USER);\r\nsyslog(LOG_INFO, "KVP starting; pid is:%d", getpid());\r\nkvp_get_os_info();\r\nif (kvp_file_init()) {\r\nsyslog(LOG_ERR, "Failed to initialize the pools");\r\nexit(-1);\r\n}\r\nfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\r\nif (fd < 0) {\r\nsyslog(LOG_ERR, "netlink socket creation failed; error:%d", fd);\r\nexit(-1);\r\n}\r\naddr.nl_family = AF_NETLINK;\r\naddr.nl_pad = 0;\r\naddr.nl_pid = 0;\r\naddr.nl_groups = CN_KVP_IDX;\r\nerror = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\r\nif (error < 0) {\r\nsyslog(LOG_ERR, "bind failed; error:%d", error);\r\nclose(fd);\r\nexit(-1);\r\n}\r\nsock_opt = addr.nl_groups;\r\nsetsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt));\r\nmessage = (struct cn_msg *)kvp_send_buffer;\r\nmessage->id.idx = CN_KVP_IDX;\r\nmessage->id.val = CN_KVP_VAL;\r\nhv_msg = (struct hv_kvp_msg *)message->data;\r\nhv_msg->kvp_hdr.operation = KVP_OP_REGISTER;\r\nmessage->ack = 0;\r\nmessage->len = sizeof(struct hv_kvp_msg);\r\nlen = netlink_send(fd, message);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "netlink_send failed; error:%d", len);\r\nclose(fd);\r\nexit(-1);\r\n}\r\npfd.fd = fd;\r\nwhile (1) {\r\nstruct sockaddr *addr_p = (struct sockaddr *) &addr;\r\nsocklen_t addr_l = sizeof(addr);\r\npfd.events = POLLIN;\r\npfd.revents = 0;\r\npoll(&pfd, 1, -1);\r\nlen = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,\r\naddr_p, &addr_l);\r\nif (len < 0 || addr.nl_pid) {\r\nsyslog(LOG_ERR, "recvfrom failed; pid:%u error:%d %s",\r\naddr.nl_pid, errno, strerror(errno));\r\nclose(fd);\r\nreturn -1;\r\n}\r\nincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\r\nincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\r\nhv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\r\nswitch (hv_msg->kvp_hdr.operation) {\r\ncase KVP_OP_REGISTER:\r\np = (char *)hv_msg->body.kvp_register.version;\r\nlic_version = malloc(strlen(p) + 1);\r\nif (lic_version) {\r\nstrcpy(lic_version, p);\r\nsyslog(LOG_INFO, "KVP LIC Version: %s",\r\nlic_version);\r\n} else {\r\nsyslog(LOG_ERR, "malloc failed");\r\n}\r\ncontinue;\r\ncase KVP_OP_SET:\r\nif (kvp_key_add_or_modify(hv_msg->kvp_hdr.pool,\r\nhv_msg->body.kvp_set.data.key,\r\nhv_msg->body.kvp_set.data.key_size,\r\nhv_msg->body.kvp_set.data.value,\r\nhv_msg->body.kvp_set.data.value_size))\r\nstrcpy(hv_msg->body.kvp_set.data.key, "");\r\nbreak;\r\ncase KVP_OP_GET:\r\nif (kvp_get_value(hv_msg->kvp_hdr.pool,\r\nhv_msg->body.kvp_set.data.key,\r\nhv_msg->body.kvp_set.data.key_size,\r\nhv_msg->body.kvp_set.data.value,\r\nhv_msg->body.kvp_set.data.value_size))\r\nstrcpy(hv_msg->body.kvp_set.data.key, "");\r\nbreak;\r\ncase KVP_OP_DELETE:\r\nif (kvp_key_delete(hv_msg->kvp_hdr.pool,\r\nhv_msg->body.kvp_delete.key,\r\nhv_msg->body.kvp_delete.key_size))\r\nstrcpy(hv_msg->body.kvp_delete.key, "");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hv_msg->kvp_hdr.operation != KVP_OP_ENUMERATE)\r\ngoto kvp_done;\r\nif (hv_msg->kvp_hdr.pool != KVP_POOL_AUTO) {\r\nkvp_pool_enumerate(hv_msg->kvp_hdr.pool,\r\nhv_msg->body.kvp_enum_data.index,\r\nhv_msg->body.kvp_enum_data.data.key,\r\nHV_KVP_EXCHANGE_MAX_KEY_SIZE,\r\nhv_msg->body.kvp_enum_data.data.value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\ngoto kvp_done;\r\n}\r\nhv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\r\nkey_name = (char *)hv_msg->body.kvp_enum_data.data.key;\r\nkey_value = (char *)hv_msg->body.kvp_enum_data.data.value;\r\nswitch (hv_msg->body.kvp_enum_data.index) {\r\ncase FullyQualifiedDomainName:\r\nkvp_get_domain_name(key_value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\nstrcpy(key_name, "FullyQualifiedDomainName");\r\nbreak;\r\ncase IntegrationServicesVersion:\r\nstrcpy(key_name, "IntegrationServicesVersion");\r\nstrcpy(key_value, lic_version);\r\nbreak;\r\ncase NetworkAddressIPv4:\r\nkvp_get_ip_address(AF_INET, key_value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\nstrcpy(key_name, "NetworkAddressIPv4");\r\nbreak;\r\ncase NetworkAddressIPv6:\r\nkvp_get_ip_address(AF_INET6, key_value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\nstrcpy(key_name, "NetworkAddressIPv6");\r\nbreak;\r\ncase OSBuildNumber:\r\nstrcpy(key_value, os_build);\r\nstrcpy(key_name, "OSBuildNumber");\r\nbreak;\r\ncase OSName:\r\nstrcpy(key_value, os_name);\r\nstrcpy(key_name, "OSName");\r\nbreak;\r\ncase OSMajorVersion:\r\nstrcpy(key_value, os_major);\r\nstrcpy(key_name, "OSMajorVersion");\r\nbreak;\r\ncase OSMinorVersion:\r\nstrcpy(key_value, os_minor);\r\nstrcpy(key_name, "OSMinorVersion");\r\nbreak;\r\ncase OSVersion:\r\nstrcpy(key_value, os_build);\r\nstrcpy(key_name, "OSVersion");\r\nbreak;\r\ncase ProcessorArchitecture:\r\nstrcpy(key_value, processor_arch);\r\nstrcpy(key_name, "ProcessorArchitecture");\r\nbreak;\r\ndefault:\r\nstrcpy(key_value, "Unknown Key");\r\nstrcpy(key_name, "");\r\nbreak;\r\n}\r\nkvp_done:\r\nincoming_cn_msg->id.idx = CN_KVP_IDX;\r\nincoming_cn_msg->id.val = CN_KVP_VAL;\r\nincoming_cn_msg->ack = 0;\r\nincoming_cn_msg->len = sizeof(struct hv_kvp_msg);\r\nlen = netlink_send(fd, incoming_cn_msg);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "net_link send failed; error:%d", len);\r\nexit(-1);\r\n}\r\n}\r\n}
