static inline void close_pair(int fd[2])\r\n{\r\nclose(fd[0]);\r\nclose(fd[1]);\r\n}\r\nstatic inline void dup_devnull(int to)\r\n{\r\nint fd = open("/dev/null", O_RDWR);\r\ndup2(fd, to);\r\nclose(fd);\r\n}\r\nint start_command(struct child_process *cmd)\r\n{\r\nint need_in, need_out, need_err;\r\nint fdin[2], fdout[2], fderr[2];\r\nneed_in = !cmd->no_stdin && cmd->in < 0;\r\nif (need_in) {\r\nif (pipe(fdin) < 0) {\r\nif (cmd->out > 0)\r\nclose(cmd->out);\r\nreturn -ERR_RUN_COMMAND_PIPE;\r\n}\r\ncmd->in = fdin[1];\r\n}\r\nneed_out = !cmd->no_stdout\r\n&& !cmd->stdout_to_stderr\r\n&& cmd->out < 0;\r\nif (need_out) {\r\nif (pipe(fdout) < 0) {\r\nif (need_in)\r\nclose_pair(fdin);\r\nelse if (cmd->in)\r\nclose(cmd->in);\r\nreturn -ERR_RUN_COMMAND_PIPE;\r\n}\r\ncmd->out = fdout[0];\r\n}\r\nneed_err = !cmd->no_stderr && cmd->err < 0;\r\nif (need_err) {\r\nif (pipe(fderr) < 0) {\r\nif (need_in)\r\nclose_pair(fdin);\r\nelse if (cmd->in)\r\nclose(cmd->in);\r\nif (need_out)\r\nclose_pair(fdout);\r\nelse if (cmd->out)\r\nclose(cmd->out);\r\nreturn -ERR_RUN_COMMAND_PIPE;\r\n}\r\ncmd->err = fderr[0];\r\n}\r\nfflush(NULL);\r\ncmd->pid = fork();\r\nif (!cmd->pid) {\r\nif (cmd->no_stdin)\r\ndup_devnull(0);\r\nelse if (need_in) {\r\ndup2(fdin[0], 0);\r\nclose_pair(fdin);\r\n} else if (cmd->in) {\r\ndup2(cmd->in, 0);\r\nclose(cmd->in);\r\n}\r\nif (cmd->no_stderr)\r\ndup_devnull(2);\r\nelse if (need_err) {\r\ndup2(fderr[1], 2);\r\nclose_pair(fderr);\r\n}\r\nif (cmd->no_stdout)\r\ndup_devnull(1);\r\nelse if (cmd->stdout_to_stderr)\r\ndup2(2, 1);\r\nelse if (need_out) {\r\ndup2(fdout[1], 1);\r\nclose_pair(fdout);\r\n} else if (cmd->out > 1) {\r\ndup2(cmd->out, 1);\r\nclose(cmd->out);\r\n}\r\nif (cmd->dir && chdir(cmd->dir))\r\ndie("exec %s: cd to %s failed (%s)", cmd->argv[0],\r\ncmd->dir, strerror(errno));\r\nif (cmd->env) {\r\nfor (; *cmd->env; cmd->env++) {\r\nif (strchr(*cmd->env, '='))\r\nputenv((char*)*cmd->env);\r\nelse\r\nunsetenv(*cmd->env);\r\n}\r\n}\r\nif (cmd->preexec_cb)\r\ncmd->preexec_cb();\r\nif (cmd->perf_cmd) {\r\nexecv_perf_cmd(cmd->argv);\r\n} else {\r\nexecvp(cmd->argv[0], (char *const*) cmd->argv);\r\n}\r\nexit(127);\r\n}\r\nif (cmd->pid < 0) {\r\nint err = errno;\r\nif (need_in)\r\nclose_pair(fdin);\r\nelse if (cmd->in)\r\nclose(cmd->in);\r\nif (need_out)\r\nclose_pair(fdout);\r\nelse if (cmd->out)\r\nclose(cmd->out);\r\nif (need_err)\r\nclose_pair(fderr);\r\nreturn err == ENOENT ?\r\n-ERR_RUN_COMMAND_EXEC :\r\n-ERR_RUN_COMMAND_FORK;\r\n}\r\nif (need_in)\r\nclose(fdin[0]);\r\nelse if (cmd->in)\r\nclose(cmd->in);\r\nif (need_out)\r\nclose(fdout[1]);\r\nelse if (cmd->out)\r\nclose(cmd->out);\r\nif (need_err)\r\nclose(fderr[1]);\r\nreturn 0;\r\n}\r\nstatic int wait_or_whine(pid_t pid)\r\n{\r\nfor (;;) {\r\nint status, code;\r\npid_t waiting = waitpid(pid, &status, 0);\r\nif (waiting < 0) {\r\nif (errno == EINTR)\r\ncontinue;\r\nerror("waitpid failed (%s)", strerror(errno));\r\nreturn -ERR_RUN_COMMAND_WAITPID;\r\n}\r\nif (waiting != pid)\r\nreturn -ERR_RUN_COMMAND_WAITPID_WRONG_PID;\r\nif (WIFSIGNALED(status))\r\nreturn -ERR_RUN_COMMAND_WAITPID_SIGNAL;\r\nif (!WIFEXITED(status))\r\nreturn -ERR_RUN_COMMAND_WAITPID_NOEXIT;\r\ncode = WEXITSTATUS(status);\r\nswitch (code) {\r\ncase 127:\r\nreturn -ERR_RUN_COMMAND_EXEC;\r\ncase 0:\r\nreturn 0;\r\ndefault:\r\nreturn -code;\r\n}\r\n}\r\n}\r\nint finish_command(struct child_process *cmd)\r\n{\r\nreturn wait_or_whine(cmd->pid);\r\n}\r\nint run_command(struct child_process *cmd)\r\n{\r\nint code = start_command(cmd);\r\nif (code)\r\nreturn code;\r\nreturn finish_command(cmd);\r\n}\r\nstatic void prepare_run_command_v_opt(struct child_process *cmd,\r\nconst char **argv,\r\nint opt)\r\n{\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->argv = argv;\r\ncmd->no_stdin = opt & RUN_COMMAND_NO_STDIN ? 1 : 0;\r\ncmd->perf_cmd = opt & RUN_PERF_CMD ? 1 : 0;\r\ncmd->stdout_to_stderr = opt & RUN_COMMAND_STDOUT_TO_STDERR ? 1 : 0;\r\n}\r\nint run_command_v_opt(const char **argv, int opt)\r\n{\r\nstruct child_process cmd;\r\nprepare_run_command_v_opt(&cmd, argv, opt);\r\nreturn run_command(&cmd);\r\n}
