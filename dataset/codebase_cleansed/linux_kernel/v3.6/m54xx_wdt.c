static void wdt_enable(void)\r\n{\r\nunsigned int gms0;\r\ngms0 = __raw_readl(MCF_MBAR + MCF_GPT_GMS0);\r\nif (gms0 & MCF_GPT_GMS_TMS_GPIO)\r\ngms0 &= (MCF_GPT_GMS_TMS_GPIO | MCF_GPT_GMS_GPIO_MASK\r\n| MCF_GPT_GMS_OD);\r\nelse\r\ngms0 = MCF_GPT_GMS_TMS_GPIO | MCF_GPT_GMS_OD;\r\n__raw_writel(gms0, MCF_MBAR + MCF_GPT_GMS0);\r\n__raw_writel(MCF_GPT_GCIR_PRE(heartbeat*(MCF_BUSCLK/0xffff)) |\r\nMCF_GPT_GCIR_CNT(0xffff), MCF_MBAR + MCF_GPT_GCIR0);\r\ngms0 |= MCF_GPT_GMS_OCPW(0xA5) | MCF_GPT_GMS_WDEN | MCF_GPT_GMS_CE;\r\n__raw_writel(gms0, MCF_MBAR + MCF_GPT_GMS0);\r\n}\r\nstatic void wdt_disable(void)\r\n{\r\nunsigned int gms0;\r\ngms0 = __raw_readl(MCF_MBAR + MCF_GPT_GMS0);\r\ngms0 &= ~(MCF_GPT_GMS_WDEN | MCF_GPT_GMS_CE);\r\n__raw_writel(gms0, MCF_MBAR + MCF_GPT_GMS0);\r\n}\r\nstatic void wdt_keepalive(void)\r\n{\r\nunsigned int gms0;\r\ngms0 = __raw_readl(MCF_MBAR + MCF_GPT_GMS0);\r\ngms0 |= MCF_GPT_GMS_OCPW(0xA5);\r\n__raw_writel(gms0, MCF_MBAR + MCF_GPT_GMS0);\r\n}\r\nstatic int m54xx_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(WDT_IN_USE, &wdt_status))\r\nreturn -EBUSY;\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nwdt_enable();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t m54xx_wdt_write(struct file *file, const char *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\n}\r\n}\r\nwdt_keepalive();\r\n}\r\nreturn len;\r\n}\r\nstatic long m54xx_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret = -ENOTTY;\r\nint time;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nret = copy_to_user((struct watchdog_info *)arg, &ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nret = put_user(0, (int *)arg);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(0, (int *)arg);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nwdt_keepalive();\r\nret = 0;\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nret = get_user(time, (int *)arg);\r\nif (ret)\r\nbreak;\r\nif (time <= 0 || time > 30) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nheartbeat = time;\r\nwdt_enable();\r\ncase WDIOC_GETTIMEOUT:\r\nret = put_user(heartbeat, (int *)arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int m54xx_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (test_bit(WDT_OK_TO_CLOSE, &wdt_status))\r\nwdt_disable();\r\nelse {\r\npr_crit("Device closed unexpectedly - timer will not stop\n");\r\nwdt_keepalive();\r\n}\r\nclear_bit(WDT_IN_USE, &wdt_status);\r\nclear_bit(WDT_OK_TO_CLOSE, &wdt_status);\r\nreturn 0;\r\n}\r\nstatic int __init m54xx_wdt_init(void)\r\n{\r\nif (!request_mem_region(MCF_MBAR + MCF_GPT_GCIR0, 4,\r\n"Coldfire M54xx Watchdog")) {\r\npr_warn("I/O region busy\n");\r\nreturn -EBUSY;\r\n}\r\npr_info("driver is loaded\n");\r\nreturn misc_register(&m54xx_wdt_miscdev);\r\n}\r\nstatic void __exit m54xx_wdt_exit(void)\r\n{\r\nmisc_deregister(&m54xx_wdt_miscdev);\r\nrelease_mem_region(MCF_MBAR + MCF_GPT_GCIR0, 4);\r\n}
