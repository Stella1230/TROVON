static int ak4671_out2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, AK4671_LOUT2_POWER_MANAGERMENT,\r\nAK4671_MUTEN, AK4671_MUTEN);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, AK4671_LOUT2_POWER_MANAGERMENT,\r\nAK4671_MUTEN, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak4671_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 fs;\r\nfs = snd_soc_read(codec, AK4671_PLL_MODE_SELECT0);\r\nfs &= ~AK4671_FS;\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nfs |= AK4671_FS_8KHZ;\r\nbreak;\r\ncase 12000:\r\nfs |= AK4671_FS_12KHZ;\r\nbreak;\r\ncase 16000:\r\nfs |= AK4671_FS_16KHZ;\r\nbreak;\r\ncase 24000:\r\nfs |= AK4671_FS_24KHZ;\r\nbreak;\r\ncase 11025:\r\nfs |= AK4671_FS_11_025KHZ;\r\nbreak;\r\ncase 22050:\r\nfs |= AK4671_FS_22_05KHZ;\r\nbreak;\r\ncase 32000:\r\nfs |= AK4671_FS_32KHZ;\r\nbreak;\r\ncase 44100:\r\nfs |= AK4671_FS_44_1KHZ;\r\nbreak;\r\ncase 48000:\r\nfs |= AK4671_FS_48KHZ;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, AK4671_PLL_MODE_SELECT0, fs);\r\nreturn 0;\r\n}\r\nstatic int ak4671_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 pll;\r\npll = snd_soc_read(codec, AK4671_PLL_MODE_SELECT0);\r\npll &= ~AK4671_PLL;\r\nswitch (freq) {\r\ncase 11289600:\r\npll |= AK4671_PLL_11_2896MHZ;\r\nbreak;\r\ncase 12000000:\r\npll |= AK4671_PLL_12MHZ;\r\nbreak;\r\ncase 12288000:\r\npll |= AK4671_PLL_12_288MHZ;\r\nbreak;\r\ncase 13000000:\r\npll |= AK4671_PLL_13MHZ;\r\nbreak;\r\ncase 13500000:\r\npll |= AK4671_PLL_13_5MHZ;\r\nbreak;\r\ncase 19200000:\r\npll |= AK4671_PLL_19_2MHZ;\r\nbreak;\r\ncase 24000000:\r\npll |= AK4671_PLL_24MHZ;\r\nbreak;\r\ncase 26000000:\r\npll |= AK4671_PLL_26MHZ;\r\nbreak;\r\ncase 27000000:\r\npll |= AK4671_PLL_27MHZ;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, AK4671_PLL_MODE_SELECT0, pll);\r\nreturn 0;\r\n}\r\nstatic int ak4671_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 mode;\r\nu8 format;\r\nmode = snd_soc_read(codec, AK4671_PLL_MODE_SELECT1);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmode |= AK4671_M_S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nmode &= ~(AK4671_M_S);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nformat = snd_soc_read(codec, AK4671_FORMAT_SELECT);\r\nformat &= ~AK4671_DIF;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nformat |= AK4671_DIF_I2S_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nformat |= AK4671_DIF_MSB_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nformat |= AK4671_DIF_DSP_MODE;\r\nformat |= AK4671_BCKP;\r\nformat |= AK4671_MSBS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, AK4671_PLL_MODE_SELECT1, mode);\r\nsnd_soc_write(codec, AK4671_FORMAT_SELECT, format);\r\nreturn 0;\r\n}\r\nstatic int ak4671_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, AK4671_AD_DA_POWER_MANAGEMENT,\r\nAK4671_PMVCM, AK4671_PMVCM);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, AK4671_AD_DA_POWER_MANAGEMENT, 0x00);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int ak4671_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4671_priv *ak4671 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, ak4671->control_type);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_add_codec_controls(codec, ak4671_snd_controls,\r\nARRAY_SIZE(ak4671_snd_controls));\r\nak4671_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn ret;\r\n}\r\nstatic int ak4671_remove(struct snd_soc_codec *codec)\r\n{\r\nak4671_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int __devinit ak4671_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ak4671_priv *ak4671;\r\nint ret;\r\nak4671 = devm_kzalloc(&client->dev, sizeof(struct ak4671_priv),\r\nGFP_KERNEL);\r\nif (ak4671 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, ak4671);\r\nak4671->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&client->dev,\r\n&soc_codec_dev_ak4671, &ak4671_dai, 1);\r\nreturn ret;\r\n}\r\nstatic __devexit int ak4671_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init ak4671_modinit(void)\r\n{\r\nreturn i2c_add_driver(&ak4671_i2c_driver);\r\n}\r\nstatic void __exit ak4671_exit(void)\r\n{\r\ni2c_del_driver(&ak4671_i2c_driver);\r\n}
