static u8 bcma_host_soc_read8(struct bcma_device *core, u16 offset)\r\n{\r\nreturn readb(core->io_addr + offset);\r\n}\r\nstatic u16 bcma_host_soc_read16(struct bcma_device *core, u16 offset)\r\n{\r\nreturn readw(core->io_addr + offset);\r\n}\r\nstatic u32 bcma_host_soc_read32(struct bcma_device *core, u16 offset)\r\n{\r\nreturn readl(core->io_addr + offset);\r\n}\r\nstatic void bcma_host_soc_write8(struct bcma_device *core, u16 offset,\r\nu8 value)\r\n{\r\nwriteb(value, core->io_addr + offset);\r\n}\r\nstatic void bcma_host_soc_write16(struct bcma_device *core, u16 offset,\r\nu16 value)\r\n{\r\nwritew(value, core->io_addr + offset);\r\n}\r\nstatic void bcma_host_soc_write32(struct bcma_device *core, u16 offset,\r\nu32 value)\r\n{\r\nwritel(value, core->io_addr + offset);\r\n}\r\nstatic void bcma_host_soc_block_read(struct bcma_device *core, void *buffer,\r\nsize_t count, u16 offset, u8 reg_width)\r\n{\r\nvoid __iomem *addr = core->io_addr + offset;\r\nswitch (reg_width) {\r\ncase sizeof(u8): {\r\nu8 *buf = buffer;\r\nwhile (count) {\r\n*buf = __raw_readb(addr);\r\nbuf++;\r\ncount--;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u16): {\r\n__le16 *buf = buffer;\r\nWARN_ON(count & 1);\r\nwhile (count) {\r\n*buf = (__force __le16)__raw_readw(addr);\r\nbuf++;\r\ncount -= 2;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u32): {\r\n__le32 *buf = buffer;\r\nWARN_ON(count & 3);\r\nwhile (count) {\r\n*buf = (__force __le32)__raw_readl(addr);\r\nbuf++;\r\ncount -= 4;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic void bcma_host_soc_block_write(struct bcma_device *core,\r\nconst void *buffer,\r\nsize_t count, u16 offset, u8 reg_width)\r\n{\r\nvoid __iomem *addr = core->io_addr + offset;\r\nswitch (reg_width) {\r\ncase sizeof(u8): {\r\nconst u8 *buf = buffer;\r\nwhile (count) {\r\n__raw_writeb(*buf, addr);\r\nbuf++;\r\ncount--;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u16): {\r\nconst __le16 *buf = buffer;\r\nWARN_ON(count & 1);\r\nwhile (count) {\r\n__raw_writew((__force u16)(*buf), addr);\r\nbuf++;\r\ncount -= 2;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u32): {\r\nconst __le32 *buf = buffer;\r\nWARN_ON(count & 3);\r\nwhile (count) {\r\n__raw_writel((__force u32)(*buf), addr);\r\nbuf++;\r\ncount -= 4;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic u32 bcma_host_soc_aread32(struct bcma_device *core, u16 offset)\r\n{\r\nreturn readl(core->io_wrap + offset);\r\n}\r\nstatic void bcma_host_soc_awrite32(struct bcma_device *core, u16 offset,\r\nu32 value)\r\n{\r\nwritel(value, core->io_wrap + offset);\r\n}\r\nint __init bcma_host_soc_register(struct bcma_soc *soc)\r\n{\r\nstruct bcma_bus *bus = &soc->bus;\r\nint err;\r\nbus->mmio = ioremap_nocache(BCMA_ADDR_BASE, BCMA_CORE_SIZE * 1);\r\nif (!bus->mmio)\r\nreturn -ENOMEM;\r\nbus->hosttype = BCMA_HOSTTYPE_SOC;\r\nbus->ops = &bcma_host_soc_ops;\r\nerr = bcma_bus_early_register(bus, &soc->core_cc, &soc->core_mips);\r\nif (err)\r\niounmap(bus->mmio);\r\nreturn err;\r\n}
