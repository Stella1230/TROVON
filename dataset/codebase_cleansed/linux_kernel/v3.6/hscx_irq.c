static inline void\r\nwaitforCEC(struct IsdnCardState *cs, int hscx)\r\n{\r\nint to = 50;\r\nwhile ((READHSCX(cs, hscx, HSCX_STAR) & 0x04) && to) {\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to)\r\nprintk(KERN_WARNING "HiSax: waitforCEC timeout\n");\r\n}\r\nstatic inline void\r\nwaitforXFW(struct IsdnCardState *cs, int hscx)\r\n{\r\nint to = 50;\r\nwhile (((READHSCX(cs, hscx, HSCX_STAR) & 0x44) != 0x40) && to) {\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to)\r\nprintk(KERN_WARNING "HiSax: waitforXFW timeout\n");\r\n}\r\nstatic inline void\r\nWriteHSCXCMDR(struct IsdnCardState *cs, int hscx, u_char data)\r\n{\r\nwaitforCEC(cs, hscx);\r\nWRITEHSCX(cs, hscx, HSCX_CMDR, data);\r\n}\r\nstatic void\r\nhscx_empty_fifo(struct BCState *bcs, int count)\r\n{\r\nu_char *ptr;\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hscx_empty_fifo");\r\nif (bcs->hw.hscx.rcvidx + count > HSCX_BUFMAX) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hscx_empty_fifo: incoming packet too large");\r\nWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, 0x80);\r\nbcs->hw.hscx.rcvidx = 0;\r\nreturn;\r\n}\r\nptr = bcs->hw.hscx.rcvbuf + bcs->hw.hscx.rcvidx;\r\nbcs->hw.hscx.rcvidx += count;\r\nREADHSCXFIFO(cs, bcs->hw.hscx.hscx, ptr, count);\r\nWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, 0x80);\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nt += sprintf(t, "hscx_empty_fifo %c cnt %d",\r\nbcs->hw.hscx.hscx ? 'B' : 'A', count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, bcs->blog);\r\n}\r\n}\r\nstatic void\r\nhscx_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint more, count;\r\nint fifo_size = test_bit(HW_IPAC, &cs->HW_Flags) ? 64 : 32;\r\nu_char *ptr;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hscx_fill_fifo");\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\nmore = (bcs->mode == L1_MODE_TRANS) ? 1 : 0;\r\nif (bcs->tx_skb->len > fifo_size) {\r\nmore = !0;\r\ncount = fifo_size;\r\n} else\r\ncount = bcs->tx_skb->len;\r\nwaitforXFW(cs, bcs->hw.hscx.hscx);\r\nptr = bcs->tx_skb->data;\r\nskb_pull(bcs->tx_skb, count);\r\nbcs->tx_cnt -= count;\r\nbcs->hw.hscx.count += count;\r\nWRITEHSCXFIFO(cs, bcs->hw.hscx.hscx, ptr, count);\r\nWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, more ? 0x8 : 0xa);\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nt += sprintf(t, "hscx_fill_fifo %c cnt %d",\r\nbcs->hw.hscx.hscx ? 'B' : 'A', count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, bcs->blog);\r\n}\r\n}\r\nstatic void\r\nhscx_interrupt(struct IsdnCardState *cs, u_char val, u_char hscx)\r\n{\r\nu_char r;\r\nstruct BCState *bcs = cs->bcs + hscx;\r\nstruct sk_buff *skb;\r\nint fifo_size = test_bit(HW_IPAC, &cs->HW_Flags) ? 64 : 32;\r\nint count;\r\nif (!test_bit(BC_FLG_INIT, &bcs->Flag))\r\nreturn;\r\nif (val & 0x80) {\r\nr = READHSCX(cs, hscx, HSCX_RSTA);\r\nif ((r & 0xf0) != 0xa0) {\r\nif (!(r & 0x80)) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX invalid frame");\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_inv++;\r\n#endif\r\n}\r\nif ((r & 0x40) && bcs->mode) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX RDO mode=%d",\r\nbcs->mode);\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_rdo++;\r\n#endif\r\n}\r\nif (!(r & 0x20)) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX CRC error");\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_crc++;\r\n#endif\r\n}\r\nWriteHSCXCMDR(cs, hscx, 0x80);\r\n} else {\r\ncount = READHSCX(cs, hscx, HSCX_RBCL) & (\r\ntest_bit(HW_IPAC, &cs->HW_Flags) ? 0x3f : 0x1f);\r\nif (count == 0)\r\ncount = fifo_size;\r\nhscx_empty_fifo(bcs, count);\r\nif ((count = bcs->hw.hscx.rcvidx - 1) > 0) {\r\nif (cs->debug & L1_DEB_HSCX_FIFO)\r\ndebugl1(cs, "HX Frame %d", count);\r\nif (!(skb = dev_alloc_skb(count)))\r\nprintk(KERN_WARNING "HSCX: receive out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, count), bcs->hw.hscx.rcvbuf, count);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\n}\r\n}\r\nbcs->hw.hscx.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\nif (val & 0x40) {\r\nhscx_empty_fifo(bcs, fifo_size);\r\nif (bcs->mode == L1_MODE_TRANS) {\r\nif (!(skb = dev_alloc_skb(fifo_size)))\r\nprintk(KERN_WARNING "HiSax: receive out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, fifo_size), bcs->hw.hscx.rcvbuf, fifo_size);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\nbcs->hw.hscx.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\n}\r\nif (val & 0x10) {\r\nif (bcs->tx_skb) {\r\nif (bcs->tx_skb->len) {\r\nhscx_fill_fifo(bcs);\r\nreturn;\r\n} else {\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->hw.hscx.count;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_irq(bcs->tx_skb);\r\nbcs->hw.hscx.count = 0;\r\nbcs->tx_skb = NULL;\r\n}\r\n}\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nbcs->hw.hscx.count = 0;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nhscx_fill_fifo(bcs);\r\n} else {\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\nstatic void\r\nhscx_int_main(struct IsdnCardState *cs, u_char val)\r\n{\r\nu_char exval;\r\nstruct BCState *bcs;\r\nif (val & 0x01) {\r\nbcs = cs->bcs + 1;\r\nexval = READHSCX(cs, 1, HSCX_EXIR);\r\nif (exval & 0x40) {\r\nif (bcs->mode == 1)\r\nhscx_fill_fifo(bcs);\r\nelse {\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_tx++;\r\n#endif\r\nif (bcs->tx_skb) {\r\nskb_push(bcs->tx_skb, bcs->hw.hscx.count);\r\nbcs->tx_cnt += bcs->hw.hscx.count;\r\nbcs->hw.hscx.count = 0;\r\n}\r\nWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, 0x01);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX B EXIR %x Lost TX", exval);\r\n}\r\n} else if (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX B EXIR %x", exval);\r\n}\r\nif (val & 0xf8) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX B interrupt %x", val);\r\nhscx_interrupt(cs, val, 1);\r\n}\r\nif (val & 0x02) {\r\nbcs = cs->bcs;\r\nexval = READHSCX(cs, 0, HSCX_EXIR);\r\nif (exval & 0x40) {\r\nif (bcs->mode == L1_MODE_TRANS)\r\nhscx_fill_fifo(bcs);\r\nelse {\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_tx++;\r\n#endif\r\nif (bcs->tx_skb) {\r\nskb_push(bcs->tx_skb, bcs->hw.hscx.count);\r\nbcs->tx_cnt += bcs->hw.hscx.count;\r\nbcs->hw.hscx.count = 0;\r\n}\r\nWriteHSCXCMDR(cs, bcs->hw.hscx.hscx, 0x01);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "HSCX A EXIR %x Lost TX", exval);\r\n}\r\n} else if (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX A EXIR %x", exval);\r\n}\r\nif (val & 0x04) {\r\nexval = READHSCX(cs, 0, HSCX_ISTA);\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX A interrupt %x", exval);\r\nhscx_interrupt(cs, exval, 0);\r\n}\r\n}
