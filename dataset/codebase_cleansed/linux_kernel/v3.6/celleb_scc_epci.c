static inline PCI_IO_ADDR celleb_epci_get_epci_base(\r\nstruct pci_controller *hose)\r\n{\r\nreturn hose->cfg_addr;\r\n}\r\nstatic inline PCI_IO_ADDR celleb_epci_get_epci_cfg(\r\nstruct pci_controller *hose)\r\n{\r\nreturn hose->cfg_data;\r\n}\r\nstatic inline void clear_and_disable_master_abort_interrupt(\r\nstruct pci_controller *hose)\r\n{\r\nPCI_IO_ADDR epci_base;\r\nPCI_IO_ADDR reg;\r\nepci_base = celleb_epci_get_epci_base(hose);\r\nreg = epci_base + PCI_COMMAND;\r\nout_be32(reg, in_be32(reg) | (PCI_STATUS_REC_MASTER_ABORT << 16));\r\n}\r\nstatic int celleb_epci_check_abort(struct pci_controller *hose,\r\nPCI_IO_ADDR addr)\r\n{\r\nPCI_IO_ADDR reg;\r\nPCI_IO_ADDR epci_base;\r\nu32 val;\r\niob();\r\nepci_base = celleb_epci_get_epci_base(hose);\r\nreg = epci_base + PCI_COMMAND;\r\nval = in_be32(reg);\r\nif (val & (PCI_STATUS_REC_MASTER_ABORT << 16)) {\r\nout_be32(reg,\r\n(val & 0xffff) | (PCI_STATUS_REC_MASTER_ABORT << 16));\r\nreg = epci_base + SCC_EPCI_STATUS;\r\nout_be32(reg, SCC_EPCI_INT_PAI);\r\nreg = epci_base + SCC_EPCI_VCSR;\r\nval = in_be32(reg) & 0xffff;\r\nval |= SCC_EPCI_VCSR_FRE;\r\nout_be32(reg, val);\r\nreg = epci_base + SCC_EPCI_VISTAT;\r\nout_be32(reg, SCC_EPCI_VISTAT_PMFE);\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic PCI_IO_ADDR celleb_epci_make_config_addr(struct pci_bus *bus,\r\nstruct pci_controller *hose, unsigned int devfn, int where)\r\n{\r\nPCI_IO_ADDR addr;\r\nif (bus != hose->bus)\r\naddr = celleb_epci_get_epci_cfg(hose) +\r\n(((bus->number & 0xff) << 16)\r\n| ((devfn & 0xff) << 8)\r\n| (where & 0xff)\r\n| 0x01000000);\r\nelse\r\naddr = celleb_epci_get_epci_cfg(hose) +\r\n(((devfn & 0xff) << 8) | (where & 0xff));\r\npr_debug("EPCI: config_addr = 0x%p\n", addr);\r\nreturn addr;\r\n}\r\nstatic int celleb_epci_read_config(struct pci_bus *bus,\r\nunsigned int devfn, int where, int size, u32 *val)\r\n{\r\nPCI_IO_ADDR epci_base;\r\nPCI_IO_ADDR addr;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nBUG_ON(where % size);\r\nif (!celleb_epci_get_epci_cfg(hose))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == hose->first_busno && devfn == 0) {\r\nepci_base = celleb_epci_get_epci_base(hose);\r\naddr = epci_base + where;\r\nswitch (size) {\r\ncase 1:\r\n*val = in_8(addr);\r\nbreak;\r\ncase 2:\r\n*val = in_be16(addr);\r\nbreak;\r\ncase 4:\r\n*val = in_be32(addr);\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\n} else {\r\nclear_and_disable_master_abort_interrupt(hose);\r\naddr = celleb_epci_make_config_addr(bus, hose, devfn, where);\r\nswitch (size) {\r\ncase 1:\r\n*val = in_8(addr);\r\nbreak;\r\ncase 2:\r\n*val = in_le16(addr);\r\nbreak;\r\ncase 4:\r\n*val = in_le32(addr);\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\n}\r\npr_debug("EPCI: "\r\n"addr=0x%p, devfn=0x%x, where=0x%x, size=0x%x, val=0x%x\n",\r\naddr, devfn, where, size, *val);\r\nreturn celleb_epci_check_abort(hose, NULL);\r\n}\r\nstatic int celleb_epci_write_config(struct pci_bus *bus,\r\nunsigned int devfn, int where, int size, u32 val)\r\n{\r\nPCI_IO_ADDR epci_base;\r\nPCI_IO_ADDR addr;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nBUG_ON(where % size);\r\nif (!celleb_epci_get_epci_cfg(hose))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == hose->first_busno && devfn == 0) {\r\nepci_base = celleb_epci_get_epci_base(hose);\r\naddr = epci_base + where;\r\nswitch (size) {\r\ncase 1:\r\nout_8(addr, val);\r\nbreak;\r\ncase 2:\r\nout_be16(addr, val);\r\nbreak;\r\ncase 4:\r\nout_be32(addr, val);\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\n} else {\r\nclear_and_disable_master_abort_interrupt(hose);\r\naddr = celleb_epci_make_config_addr(bus, hose, devfn, where);\r\nswitch (size) {\r\ncase 1:\r\nout_8(addr, val);\r\nbreak;\r\ncase 2:\r\nout_le16(addr, val);\r\nbreak;\r\ncase 4:\r\nout_le32(addr, val);\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\n}\r\nreturn celleb_epci_check_abort(hose, addr);\r\n}\r\nstatic int __init celleb_epci_init(struct pci_controller *hose)\r\n{\r\nu32 val;\r\nPCI_IO_ADDR reg;\r\nPCI_IO_ADDR epci_base;\r\nint hwres = 0;\r\nepci_base = celleb_epci_get_epci_base(hose);\r\nreg = epci_base + SCC_EPCI_CKCTRL;\r\nval = in_be32(reg);\r\nif (val == 0x00030101)\r\nhwres = 1;\r\nelse {\r\nval &= ~(SCC_EPCI_CKCTRL_CRST0 | SCC_EPCI_CKCTRL_CRST1);\r\nout_be32(reg, val);\r\nval = in_be32(reg);\r\nval |= (SCC_EPCI_CKCTRL_OCLKEN | SCC_EPCI_CKCTRL_LCLKEN);\r\nout_be32(reg, val);\r\nval = in_be32(reg);\r\nval |= SCC_EPCI_CKCTRL_CRST0;\r\nout_be32(reg, val);\r\nreg = epci_base + SCC_EPCI_CLKRST;\r\nval = in_be32(reg);\r\nval &= ~SCC_EPCI_CLKRST_CKS_MASK;\r\nval |= SCC_EPCI_CLKRST_CKS_2;\r\nout_be32(reg, val);\r\nreg = epci_base + SCC_EPCI_ABTSET;\r\nout_be32(reg, 0x0f1f001f);\r\nreg = epci_base + SCC_EPCI_CLKRST;\r\nval = in_be32(reg);\r\nval |= SCC_EPCI_CLKRST_BC;\r\nout_be32(reg, val);\r\nval = in_be32(reg);\r\nval |= SCC_EPCI_CLKRST_PCKEN;\r\nout_be32(reg, val);\r\nreg = epci_base + SCC_EPCI_CKCTRL;\r\nval = in_be32(reg);\r\nval |= (SCC_EPCI_CKCTRL_CRST0 | SCC_EPCI_CKCTRL_CRST1);\r\nout_be32(reg, val);\r\n}\r\nreg = epci_base + SCC_EPCI_INTSET;\r\nout_be32(reg, 0x013f011f);\r\nreg = epci_base + SCC_EPCI_VIENAB;\r\nval = SCC_EPCI_VIENAB_PMPEE | SCC_EPCI_VIENAB_PMFEE;\r\nout_be32(reg, val);\r\nreg = epci_base + SCC_EPCI_STATUS;\r\nout_be32(reg, 0xffffffff);\r\nreg = epci_base + SCC_EPCI_VISTAT;\r\nout_be32(reg, 0xffffffff);\r\nreg = epci_base + SCC_EPCI_VCSR;\r\nval = in_be32(reg);\r\nval &= ~(SCC_EPCI_VCSR_DR | SCC_EPCI_VCSR_AT);\r\nout_be32(reg, val);\r\nreg = epci_base + PCI_COMMAND;\r\nval = PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\r\nout_be32(reg, val);\r\nreg = epci_base + SCC_EPCI_ECMODE;\r\nval = 0x00550155;\r\nout_be32(reg, val);\r\nreg = epci_base + SCC_EPCI_CNTOPT;\r\nval = in_be32(reg);\r\nval |= SCC_EPCI_CNTOPT_O2PMB;\r\nout_be32(reg, val);\r\nreg = epci_base + SCC_EPCI_CNF10_REG;\r\nout_be32(reg, 0x80000008);\r\nreg = epci_base + SCC_EPCI_CNF14_REG;\r\nout_be32(reg, 0x40000008);\r\nreg = epci_base + SCC_EPCI_BAM0;\r\nout_be32(reg, 0x80000000);\r\nreg = epci_base + SCC_EPCI_BAM1;\r\nout_be32(reg, 0xe0000000);\r\nreg = epci_base + SCC_EPCI_PVBAT;\r\nout_be32(reg, 0x80000000);\r\nif (!hwres) {\r\nreg = epci_base + SCC_EPCI_CLKRST;\r\nval = in_be32(reg);\r\nval |= SCC_EPCI_CLKRST_PCIRST;\r\nout_be32(reg, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init celleb_setup_epci(struct device_node *node,\r\nstruct pci_controller *hose)\r\n{\r\nstruct resource r;\r\npr_debug("PCI: celleb_setup_epci()\n");\r\nif (of_address_to_resource(node, 0, &r))\r\ngoto error;\r\nhose->cfg_addr = ioremap(r.start, resource_size(&r));\r\nif (!hose->cfg_addr)\r\ngoto error;\r\npr_debug("EPCI: cfg_addr map 0x%016llx->0x%016lx + 0x%016llx\n",\r\nr.start, (unsigned long)hose->cfg_addr, resource_size(&r));\r\nif (of_address_to_resource(node, 2, &r))\r\ngoto error;\r\nhose->cfg_data = ioremap(r.start, resource_size(&r));\r\nif (!hose->cfg_data)\r\ngoto error;\r\npr_debug("EPCI: cfg_data map 0x%016llx->0x%016lx + 0x%016llx\n",\r\nr.start, (unsigned long)hose->cfg_data, resource_size(&r));\r\nhose->ops = &celleb_epci_ops;\r\ncelleb_epci_init(hose);\r\nreturn 0;\r\nerror:\r\nif (hose->cfg_addr)\r\niounmap(hose->cfg_addr);\r\nif (hose->cfg_data)\r\niounmap(hose->cfg_data);\r\nreturn 1;\r\n}
