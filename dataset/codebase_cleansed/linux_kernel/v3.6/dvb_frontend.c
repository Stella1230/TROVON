static bool has_get_frontend(struct dvb_frontend *fe)\r\n{\r\nreturn fe->ops.get_frontend != NULL;\r\n}\r\nstatic enum dvbv3_emulation_type dvbv3_type(u32 delivery_system)\r\n{\r\nswitch (delivery_system) {\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\nreturn DVBV3_QAM;\r\ncase SYS_DVBS:\r\ncase SYS_DVBS2:\r\ncase SYS_TURBO:\r\ncase SYS_ISDBS:\r\ncase SYS_DSS:\r\nreturn DVBV3_QPSK;\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\ncase SYS_ISDBT:\r\ncase SYS_DMBTH:\r\nreturn DVBV3_OFDM;\r\ncase SYS_ATSC:\r\ncase SYS_ATSCMH:\r\ncase SYS_DVBC_ANNEX_B:\r\nreturn DVBV3_ATSC;\r\ncase SYS_UNDEFINED:\r\ncase SYS_ISDBC:\r\ncase SYS_DVBH:\r\ncase SYS_DAB:\r\ndefault:\r\nreturn DVBV3_UNKNOWN;\r\n}\r\n}\r\nstatic void dvb_frontend_add_event(struct dvb_frontend *fe, fe_status_t status)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dvb_fe_events *events = &fepriv->events;\r\nstruct dvb_frontend_event *e;\r\nint wp;\r\ndprintk ("%s\n", __func__);\r\nif ((status & FE_HAS_LOCK) && has_get_frontend(fe))\r\ndtv_get_frontend(fe, &fepriv->parameters_out);\r\nmutex_lock(&events->mtx);\r\nwp = (events->eventw + 1) % MAX_EVENT;\r\nif (wp == events->eventr) {\r\nevents->overflow = 1;\r\nevents->eventr = (events->eventr + 1) % MAX_EVENT;\r\n}\r\ne = &events->events[events->eventw];\r\ne->status = status;\r\ne->parameters = fepriv->parameters_out;\r\nevents->eventw = wp;\r\nmutex_unlock(&events->mtx);\r\nwake_up_interruptible (&events->wait_queue);\r\n}\r\nstatic int dvb_frontend_get_event(struct dvb_frontend *fe,\r\nstruct dvb_frontend_event *event, int flags)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dvb_fe_events *events = &fepriv->events;\r\ndprintk ("%s\n", __func__);\r\nif (events->overflow) {\r\nevents->overflow = 0;\r\nreturn -EOVERFLOW;\r\n}\r\nif (events->eventw == events->eventr) {\r\nint ret;\r\nif (flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nup(&fepriv->sem);\r\nret = wait_event_interruptible (events->wait_queue,\r\nevents->eventw != events->eventr);\r\nif (down_interruptible (&fepriv->sem))\r\nreturn -ERESTARTSYS;\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmutex_lock(&events->mtx);\r\n*event = events->events[events->eventr];\r\nevents->eventr = (events->eventr + 1) % MAX_EVENT;\r\nmutex_unlock(&events->mtx);\r\nreturn 0;\r\n}\r\nstatic void dvb_frontend_clear_events(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dvb_fe_events *events = &fepriv->events;\r\nmutex_lock(&events->mtx);\r\nevents->eventr = events->eventw;\r\nmutex_unlock(&events->mtx);\r\n}\r\nstatic void dvb_frontend_init(struct dvb_frontend *fe)\r\n{\r\ndprintk ("DVB: initialising adapter %i frontend %i (%s)...\n",\r\nfe->dvb->num,\r\nfe->id,\r\nfe->ops.info.name);\r\nif (fe->ops.init)\r\nfe->ops.init(fe);\r\nif (fe->ops.tuner_ops.init) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.init(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\n}\r\nvoid dvb_frontend_reinitialise(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nfepriv->reinitialise = 1;\r\ndvb_frontend_wakeup(fe);\r\n}\r\nstatic void dvb_frontend_swzigzag_update_delay(struct dvb_frontend_private *fepriv, int locked)\r\n{\r\nint q2;\r\ndprintk ("%s\n", __func__);\r\nif (locked)\r\n(fepriv->quality) = (fepriv->quality * 220 + 36*256) / 256;\r\nelse\r\n(fepriv->quality) = (fepriv->quality * 220 + 0) / 256;\r\nq2 = fepriv->quality - 128;\r\nq2 *= q2;\r\nfepriv->delay = fepriv->min_delay + q2 * HZ / (128*128);\r\n}\r\nstatic int dvb_frontend_swzigzag_autotune(struct dvb_frontend *fe, int check_wrapped)\r\n{\r\nint autoinversion;\r\nint ready = 0;\r\nint fe_set_err = 0;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;\r\nint original_inversion = c->inversion;\r\nu32 original_frequency = c->frequency;\r\nautoinversion = ((!(fe->ops.info.caps & FE_CAN_INVERSION_AUTO)) &&\r\n(c->inversion == INVERSION_AUTO));\r\nwhile(!ready) {\r\nfepriv->lnb_drift = fepriv->auto_step * fepriv->step_size;\r\nif (fepriv->lnb_drift > fepriv->max_drift) {\r\nfepriv->auto_step = 0;\r\nfepriv->auto_sub_step = 0;\r\nfepriv->lnb_drift = 0;\r\n}\r\nswitch(fepriv->auto_sub_step) {\r\ncase 0:\r\nready = 1;\r\nbreak;\r\ncase 1:\r\nif (!autoinversion) break;\r\nfepriv->inversion = (fepriv->inversion == INVERSION_OFF) ? INVERSION_ON : INVERSION_OFF;\r\nready = 1;\r\nbreak;\r\ncase 2:\r\nif (fepriv->lnb_drift == 0) break;\r\nfepriv->lnb_drift = -fepriv->lnb_drift;\r\nready = 1;\r\nbreak;\r\ncase 3:\r\nif (fepriv->lnb_drift == 0) break;\r\nif (!autoinversion) break;\r\nfepriv->inversion = (fepriv->inversion == INVERSION_OFF) ? INVERSION_ON : INVERSION_OFF;\r\nfepriv->lnb_drift = -fepriv->lnb_drift;\r\nready = 1;\r\nbreak;\r\ndefault:\r\nfepriv->auto_step++;\r\nfepriv->auto_sub_step = -1;\r\nbreak;\r\n}\r\nif (!ready) fepriv->auto_sub_step++;\r\n}\r\nif ((fepriv->auto_step == fepriv->started_auto_step) &&\r\n(fepriv->auto_sub_step == 0) && check_wrapped) {\r\nreturn 1;\r\n}\r\ndprintk("%s: drift:%i inversion:%i auto_step:%i "\r\n"auto_sub_step:%i started_auto_step:%i\n",\r\n__func__, fepriv->lnb_drift, fepriv->inversion,\r\nfepriv->auto_step, fepriv->auto_sub_step, fepriv->started_auto_step);\r\nc->frequency += fepriv->lnb_drift;\r\nif (autoinversion)\r\nc->inversion = fepriv->inversion;\r\ntmp = *c;\r\nif (fe->ops.set_frontend)\r\nfe_set_err = fe->ops.set_frontend(fe);\r\n*c = tmp;\r\nif (fe_set_err < 0) {\r\nfepriv->state = FESTATE_ERROR;\r\nreturn fe_set_err;\r\n}\r\nc->frequency = original_frequency;\r\nc->inversion = original_inversion;\r\nfepriv->auto_sub_step++;\r\nreturn 0;\r\n}\r\nstatic void dvb_frontend_swzigzag(struct dvb_frontend *fe)\r\n{\r\nfe_status_t s = 0;\r\nint retval = 0;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache, tmp;\r\nif (fepriv->state & FESTATE_IDLE) {\r\nfepriv->delay = 3*HZ;\r\nfepriv->quality = 0;\r\nreturn;\r\n}\r\nif (fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT) {\r\nif (fepriv->state & FESTATE_RETUNE) {\r\ntmp = *c;\r\nif (fe->ops.set_frontend)\r\nretval = fe->ops.set_frontend(fe);\r\n*c = tmp;\r\nif (retval < 0)\r\nfepriv->state = FESTATE_ERROR;\r\nelse\r\nfepriv->state = FESTATE_TUNED;\r\n}\r\nfepriv->delay = 3*HZ;\r\nfepriv->quality = 0;\r\nreturn;\r\n}\r\nif (fepriv->state & FESTATE_RETUNE) {\r\ns = 0;\r\n} else {\r\nif (fe->ops.read_status)\r\nfe->ops.read_status(fe, &s);\r\nif (s != fepriv->status) {\r\ndvb_frontend_add_event(fe, s);\r\nfepriv->status = s;\r\n}\r\n}\r\nif ((fepriv->state & FESTATE_WAITFORLOCK) && (s & FE_HAS_LOCK)) {\r\ndvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\r\nfepriv->state = FESTATE_TUNED;\r\nif ((!(fe->ops.info.caps & FE_CAN_INVERSION_AUTO)) &&\r\n(c->inversion == INVERSION_AUTO)) {\r\nc->inversion = fepriv->inversion;\r\n}\r\nreturn;\r\n}\r\nif (fepriv->state & FESTATE_TUNED) {\r\ndvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\r\nif (s & FE_HAS_LOCK) {\r\nreturn;\r\n} else {\r\nfepriv->state = FESTATE_ZIGZAG_FAST;\r\nfepriv->started_auto_step = fepriv->auto_step;\r\nfepriv->check_wrapped = 0;\r\n}\r\n}\r\nif ((fepriv->state & FESTATE_LOSTLOCK) &&\r\n(fe->ops.info.caps & FE_CAN_RECOVER) && (fepriv->max_drift == 0)) {\r\ndvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\r\nreturn;\r\n}\r\nif (fepriv->state & FESTATE_DISEQC) {\r\ndvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\r\nreturn;\r\n}\r\nif (fepriv->state & FESTATE_RETUNE) {\r\nfepriv->lnb_drift = 0;\r\nfepriv->auto_step = 0;\r\nfepriv->auto_sub_step = 0;\r\nfepriv->started_auto_step = 0;\r\nfepriv->check_wrapped = 0;\r\n}\r\nif ((fepriv->state & FESTATE_SEARCHING_FAST) || (fepriv->state & FESTATE_RETUNE)) {\r\nfepriv->delay = fepriv->min_delay;\r\nretval = dvb_frontend_swzigzag_autotune(fe,\r\nfepriv->check_wrapped);\r\nif (retval < 0) {\r\nreturn;\r\n} else if (retval) {\r\nfepriv->state = FESTATE_SEARCHING_SLOW;\r\nfepriv->started_auto_step = fepriv->auto_step;\r\nreturn;\r\n}\r\nfepriv->check_wrapped = 1;\r\nif (fepriv->state & FESTATE_RETUNE) {\r\nfepriv->state = FESTATE_TUNING_FAST;\r\n}\r\n}\r\nif (fepriv->state & FESTATE_SEARCHING_SLOW) {\r\ndvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);\r\ndvb_frontend_swzigzag_autotune(fe, 0);\r\n}\r\n}\r\nstatic int dvb_frontend_is_exiting(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nif (fepriv->exit != DVB_FE_NO_EXIT)\r\nreturn 1;\r\nif (fepriv->dvbdev->writers == 1)\r\nif (time_after_eq(jiffies, fepriv->release_jiffies +\r\ndvb_shutdown_timeout * HZ))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int dvb_frontend_should_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nif (fepriv->wakeup) {\r\nfepriv->wakeup = 0;\r\nreturn 1;\r\n}\r\nreturn dvb_frontend_is_exiting(fe);\r\n}\r\nstatic void dvb_frontend_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nfepriv->wakeup = 1;\r\nwake_up_interruptible(&fepriv->wait_queue);\r\n}\r\nstatic int dvb_frontend_thread(void *data)\r\n{\r\nstruct dvb_frontend *fe = data;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nfe_status_t s;\r\nenum dvbfe_algo algo;\r\nbool re_tune = false;\r\ndprintk("%s\n", __func__);\r\nfepriv->check_wrapped = 0;\r\nfepriv->quality = 0;\r\nfepriv->delay = 3*HZ;\r\nfepriv->status = 0;\r\nfepriv->wakeup = 0;\r\nfepriv->reinitialise = 0;\r\ndvb_frontend_init(fe);\r\nset_freezable();\r\nwhile (1) {\r\nup(&fepriv->sem);\r\nrestart:\r\nwait_event_interruptible_timeout(fepriv->wait_queue,\r\ndvb_frontend_should_wakeup(fe) || kthread_should_stop()\r\n|| freezing(current),\r\nfepriv->delay);\r\nif (kthread_should_stop() || dvb_frontend_is_exiting(fe)) {\r\nfepriv->exit = DVB_FE_NORMAL_EXIT;\r\nbreak;\r\n}\r\nif (try_to_freeze())\r\ngoto restart;\r\nif (down_interruptible(&fepriv->sem))\r\nbreak;\r\nif (fepriv->reinitialise) {\r\ndvb_frontend_init(fe);\r\nif (fe->ops.set_tone && fepriv->tone != -1)\r\nfe->ops.set_tone(fe, fepriv->tone);\r\nif (fe->ops.set_voltage && fepriv->voltage != -1)\r\nfe->ops.set_voltage(fe, fepriv->voltage);\r\nfepriv->reinitialise = 0;\r\n}\r\nif (fe->ops.get_frontend_algo) {\r\nalgo = fe->ops.get_frontend_algo(fe);\r\nswitch (algo) {\r\ncase DVBFE_ALGO_HW:\r\ndprintk("%s: Frontend ALGO = DVBFE_ALGO_HW\n", __func__);\r\nif (fepriv->state & FESTATE_RETUNE) {\r\ndprintk("%s: Retune requested, FESTATE_RETUNE\n", __func__);\r\nre_tune = true;\r\nfepriv->state = FESTATE_TUNED;\r\n} else {\r\nre_tune = false;\r\n}\r\nif (fe->ops.tune)\r\nfe->ops.tune(fe, re_tune, fepriv->tune_mode_flags, &fepriv->delay, &s);\r\nif (s != fepriv->status && !(fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT)) {\r\ndprintk("%s: state changed, adding current state\n", __func__);\r\ndvb_frontend_add_event(fe, s);\r\nfepriv->status = s;\r\n}\r\nbreak;\r\ncase DVBFE_ALGO_SW:\r\ndprintk("%s: Frontend ALGO = DVBFE_ALGO_SW\n", __func__);\r\ndvb_frontend_swzigzag(fe);\r\nbreak;\r\ncase DVBFE_ALGO_CUSTOM:\r\ndprintk("%s: Frontend ALGO = DVBFE_ALGO_CUSTOM, state=%d\n", __func__, fepriv->state);\r\nif (fepriv->state & FESTATE_RETUNE) {\r\ndprintk("%s: Retune requested, FESTAT_RETUNE\n", __func__);\r\nfepriv->state = FESTATE_TUNED;\r\n}\r\nif (fepriv->algo_status & DVBFE_ALGO_SEARCH_AGAIN) {\r\nif (fe->ops.search) {\r\nfepriv->algo_status = fe->ops.search(fe);\r\n} else {\r\nfepriv->algo_status &= ~DVBFE_ALGO_SEARCH_AGAIN;\r\n}\r\n}\r\nif (fepriv->algo_status != DVBFE_ALGO_SEARCH_SUCCESS) {\r\nfepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;\r\nfepriv->delay = HZ / 2;\r\n}\r\ndtv_property_legacy_params_sync(fe, &fepriv->parameters_out);\r\nfe->ops.read_status(fe, &s);\r\nif (s != fepriv->status) {\r\ndvb_frontend_add_event(fe, s);\r\nfepriv->status = s;\r\nif (!(s & FE_HAS_LOCK)) {\r\nfepriv->delay = HZ / 10;\r\nfepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;\r\n} else {\r\nfepriv->delay = 60 * HZ;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ndprintk("%s: UNDEFINED ALGO !\n", __func__);\r\nbreak;\r\n}\r\n} else {\r\ndvb_frontend_swzigzag(fe);\r\n}\r\n}\r\nif (dvb_powerdown_on_sleep) {\r\nif (fe->ops.set_voltage)\r\nfe->ops.set_voltage(fe, SEC_VOLTAGE_OFF);\r\nif (fe->ops.tuner_ops.sleep) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.sleep(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (fe->ops.sleep)\r\nfe->ops.sleep(fe);\r\n}\r\nfepriv->thread = NULL;\r\nif (kthread_should_stop())\r\nfepriv->exit = DVB_FE_DEVICE_REMOVED;\r\nelse\r\nfepriv->exit = DVB_FE_NO_EXIT;\r\nmb();\r\ndvb_frontend_wakeup(fe);\r\nreturn 0;\r\n}\r\nstatic void dvb_frontend_stop(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\ndprintk ("%s\n", __func__);\r\nfepriv->exit = DVB_FE_NORMAL_EXIT;\r\nmb();\r\nif (!fepriv->thread)\r\nreturn;\r\nkthread_stop(fepriv->thread);\r\nsema_init(&fepriv->sem, 1);\r\nfepriv->state = FESTATE_IDLE;\r\nif (fepriv->thread)\r\nprintk("dvb_frontend_stop: warning: thread %p won't exit\n",\r\nfepriv->thread);\r\n}\r\ns32 timeval_usec_diff(struct timeval lasttime, struct timeval curtime)\r\n{\r\nreturn ((curtime.tv_usec < lasttime.tv_usec) ?\r\n1000000 - lasttime.tv_usec + curtime.tv_usec :\r\ncurtime.tv_usec - lasttime.tv_usec);\r\n}\r\nstatic inline void timeval_usec_add(struct timeval *curtime, u32 add_usec)\r\n{\r\ncurtime->tv_usec += add_usec;\r\nif (curtime->tv_usec >= 1000000) {\r\ncurtime->tv_usec -= 1000000;\r\ncurtime->tv_sec++;\r\n}\r\n}\r\nvoid dvb_frontend_sleep_until(struct timeval *waketime, u32 add_usec)\r\n{\r\nstruct timeval lasttime;\r\ns32 delta, newdelta;\r\ntimeval_usec_add(waketime, add_usec);\r\ndo_gettimeofday(&lasttime);\r\ndelta = timeval_usec_diff(lasttime, *waketime);\r\nif (delta > 2500) {\r\nmsleep((delta - 1500) / 1000);\r\ndo_gettimeofday(&lasttime);\r\nnewdelta = timeval_usec_diff(lasttime, *waketime);\r\ndelta = (newdelta > delta) ? 0 : newdelta;\r\n}\r\nif (delta > 0)\r\nudelay(delta);\r\n}\r\nstatic int dvb_frontend_start(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct task_struct *fe_thread;\r\ndprintk ("%s\n", __func__);\r\nif (fepriv->thread) {\r\nif (fepriv->exit == DVB_FE_NO_EXIT)\r\nreturn 0;\r\nelse\r\ndvb_frontend_stop (fe);\r\n}\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (down_interruptible (&fepriv->sem))\r\nreturn -EINTR;\r\nfepriv->state = FESTATE_IDLE;\r\nfepriv->exit = DVB_FE_NO_EXIT;\r\nfepriv->thread = NULL;\r\nmb();\r\nfe_thread = kthread_run(dvb_frontend_thread, fe,\r\n"kdvb-ad-%i-fe-%i", fe->dvb->num,fe->id);\r\nif (IS_ERR(fe_thread)) {\r\nret = PTR_ERR(fe_thread);\r\nprintk("dvb_frontend_start: failed to start kthread (%d)\n", ret);\r\nup(&fepriv->sem);\r\nreturn ret;\r\n}\r\nfepriv->thread = fe_thread;\r\nreturn 0;\r\n}\r\nstatic void dvb_frontend_get_frequency_limits(struct dvb_frontend *fe,\r\nu32 *freq_min, u32 *freq_max)\r\n{\r\n*freq_min = max(fe->ops.info.frequency_min, fe->ops.tuner_ops.info.frequency_min);\r\nif (fe->ops.info.frequency_max == 0)\r\n*freq_max = fe->ops.tuner_ops.info.frequency_max;\r\nelse if (fe->ops.tuner_ops.info.frequency_max == 0)\r\n*freq_max = fe->ops.info.frequency_max;\r\nelse\r\n*freq_max = min(fe->ops.info.frequency_max, fe->ops.tuner_ops.info.frequency_max);\r\nif (*freq_min == 0 || *freq_max == 0)\r\nprintk(KERN_WARNING "DVB: adapter %i frontend %u frequency limits undefined - fix the driver\n",\r\nfe->dvb->num,fe->id);\r\n}\r\nstatic int dvb_frontend_check_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 freq_min;\r\nu32 freq_max;\r\ndvb_frontend_get_frequency_limits(fe, &freq_min, &freq_max);\r\nif ((freq_min && c->frequency < freq_min) ||\r\n(freq_max && c->frequency > freq_max)) {\r\nprintk(KERN_WARNING "DVB: adapter %i frontend %i frequency %u out of range (%u..%u)\n",\r\nfe->dvb->num, fe->id, c->frequency, freq_min, freq_max);\r\nreturn -EINVAL;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\ncase SYS_DVBS2:\r\ncase SYS_TURBO:\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\nif ((fe->ops.info.symbol_rate_min &&\r\nc->symbol_rate < fe->ops.info.symbol_rate_min) ||\r\n(fe->ops.info.symbol_rate_max &&\r\nc->symbol_rate > fe->ops.info.symbol_rate_max)) {\r\nprintk(KERN_WARNING "DVB: adapter %i frontend %i symbol rate %u out of range (%u..%u)\n",\r\nfe->dvb->num, fe->id, c->symbol_rate,\r\nfe->ops.info.symbol_rate_min,\r\nfe->ops.info.symbol_rate_max);\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_frontend_clear_cache(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint i;\r\nu32 delsys;\r\ndelsys = c->delivery_system;\r\nmemset(c, 0, sizeof(struct dtv_frontend_properties));\r\nc->delivery_system = delsys;\r\nc->state = DTV_CLEAR;\r\ndprintk("%s() Clearing cache for delivery system %d\n", __func__,\r\nc->delivery_system);\r\nc->transmission_mode = TRANSMISSION_MODE_AUTO;\r\nc->bandwidth_hz = 0;\r\nc->guard_interval = GUARD_INTERVAL_AUTO;\r\nc->hierarchy = HIERARCHY_AUTO;\r\nc->symbol_rate = 0;\r\nc->code_rate_HP = FEC_AUTO;\r\nc->code_rate_LP = FEC_AUTO;\r\nc->fec_inner = FEC_AUTO;\r\nc->rolloff = ROLLOFF_AUTO;\r\nc->voltage = SEC_VOLTAGE_OFF;\r\nc->sectone = SEC_TONE_OFF;\r\nc->pilot = PILOT_AUTO;\r\nc->isdbt_partial_reception = 0;\r\nc->isdbt_sb_mode = 0;\r\nc->isdbt_sb_subchannel = 0;\r\nc->isdbt_sb_segment_idx = 0;\r\nc->isdbt_sb_segment_count = 0;\r\nc->isdbt_layer_enabled = 0;\r\nfor (i = 0; i < 3; i++) {\r\nc->layer[i].fec = FEC_AUTO;\r\nc->layer[i].modulation = QAM_AUTO;\r\nc->layer[i].interleaving = 0;\r\nc->layer[i].segment_count = 0;\r\n}\r\nc->isdbs_ts_id = 0;\r\nc->dvbt2_plp_id = 0;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\ncase SYS_DVBS2:\r\ncase SYS_TURBO:\r\nc->modulation = QPSK;\r\nc->rolloff = ROLLOFF_35;\r\nbreak;\r\ncase SYS_ATSC:\r\nc->modulation = VSB_8;\r\nbreak;\r\ndefault:\r\nc->modulation = QAM_AUTO;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dtv_property_dump(struct dtv_property *tvp)\r\n{\r\nint i;\r\nif (tvp->cmd <= 0 || tvp->cmd > DTV_MAX_COMMAND) {\r\nprintk(KERN_WARNING "%s: tvp.cmd = 0x%08x undefined\n",\r\n__func__, tvp->cmd);\r\nreturn;\r\n}\r\ndprintk("%s() tvp.cmd = 0x%08x (%s)\n"\r\n,__func__\r\n,tvp->cmd\r\n,dtv_cmds[ tvp->cmd ].name);\r\nif(dtv_cmds[ tvp->cmd ].buffer) {\r\ndprintk("%s() tvp.u.buffer.len = 0x%02x\n"\r\n,__func__\r\n,tvp->u.buffer.len);\r\nfor(i = 0; i < tvp->u.buffer.len; i++)\r\ndprintk("%s() tvp.u.buffer.data[0x%02x] = 0x%02x\n"\r\n,__func__\r\n,i\r\n,tvp->u.buffer.data[i]);\r\n} else\r\ndprintk("%s() tvp.u.data = 0x%08x\n", __func__, tvp->u.data);\r\n}\r\nstatic int dtv_property_cache_sync(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c,\r\nconst struct dvb_frontend_parameters *p)\r\n{\r\nc->frequency = p->frequency;\r\nc->inversion = p->inversion;\r\nswitch (dvbv3_type(c->delivery_system)) {\r\ncase DVBV3_QPSK:\r\ndprintk("%s() Preparing QPSK req\n", __func__);\r\nc->symbol_rate = p->u.qpsk.symbol_rate;\r\nc->fec_inner = p->u.qpsk.fec_inner;\r\nbreak;\r\ncase DVBV3_QAM:\r\ndprintk("%s() Preparing QAM req\n", __func__);\r\nc->symbol_rate = p->u.qam.symbol_rate;\r\nc->fec_inner = p->u.qam.fec_inner;\r\nc->modulation = p->u.qam.modulation;\r\nbreak;\r\ncase DVBV3_OFDM:\r\ndprintk("%s() Preparing OFDM req\n", __func__);\r\nswitch (p->u.ofdm.bandwidth) {\r\ncase BANDWIDTH_10_MHZ:\r\nc->bandwidth_hz = 10000000;\r\nbreak;\r\ncase BANDWIDTH_8_MHZ:\r\nc->bandwidth_hz = 8000000;\r\nbreak;\r\ncase BANDWIDTH_7_MHZ:\r\nc->bandwidth_hz = 7000000;\r\nbreak;\r\ncase BANDWIDTH_6_MHZ:\r\nc->bandwidth_hz = 6000000;\r\nbreak;\r\ncase BANDWIDTH_5_MHZ:\r\nc->bandwidth_hz = 5000000;\r\nbreak;\r\ncase BANDWIDTH_1_712_MHZ:\r\nc->bandwidth_hz = 1712000;\r\nbreak;\r\ncase BANDWIDTH_AUTO:\r\nc->bandwidth_hz = 0;\r\n}\r\nc->code_rate_HP = p->u.ofdm.code_rate_HP;\r\nc->code_rate_LP = p->u.ofdm.code_rate_LP;\r\nc->modulation = p->u.ofdm.constellation;\r\nc->transmission_mode = p->u.ofdm.transmission_mode;\r\nc->guard_interval = p->u.ofdm.guard_interval;\r\nc->hierarchy = p->u.ofdm.hierarchy_information;\r\nbreak;\r\ncase DVBV3_ATSC:\r\ndprintk("%s() Preparing ATSC req\n", __func__);\r\nc->modulation = p->u.vsb.modulation;\r\nif (c->delivery_system == SYS_ATSCMH)\r\nbreak;\r\nif ((c->modulation == VSB_8) || (c->modulation == VSB_16))\r\nc->delivery_system = SYS_ATSC;\r\nelse\r\nc->delivery_system = SYS_DVBC_ANNEX_B;\r\nbreak;\r\ncase DVBV3_UNKNOWN:\r\nprintk(KERN_ERR\r\n"%s: doesn't know how to handle a DVBv3 call to delivery system %i\n",\r\n__func__, c->delivery_system);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dtv_property_legacy_params_sync(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p)\r\n{\r\nconst struct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\np->frequency = c->frequency;\r\np->inversion = c->inversion;\r\nswitch (dvbv3_type(c->delivery_system)) {\r\ncase DVBV3_UNKNOWN:\r\nprintk(KERN_ERR\r\n"%s: doesn't know how to handle a DVBv3 call to delivery system %i\n",\r\n__func__, c->delivery_system);\r\nreturn -EINVAL;\r\ncase DVBV3_QPSK:\r\ndprintk("%s() Preparing QPSK req\n", __func__);\r\np->u.qpsk.symbol_rate = c->symbol_rate;\r\np->u.qpsk.fec_inner = c->fec_inner;\r\nbreak;\r\ncase DVBV3_QAM:\r\ndprintk("%s() Preparing QAM req\n", __func__);\r\np->u.qam.symbol_rate = c->symbol_rate;\r\np->u.qam.fec_inner = c->fec_inner;\r\np->u.qam.modulation = c->modulation;\r\nbreak;\r\ncase DVBV3_OFDM:\r\ndprintk("%s() Preparing OFDM req\n", __func__);\r\nswitch (c->bandwidth_hz) {\r\ncase 10000000:\r\np->u.ofdm.bandwidth = BANDWIDTH_10_MHZ;\r\nbreak;\r\ncase 8000000:\r\np->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;\r\nbreak;\r\ncase 7000000:\r\np->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;\r\nbreak;\r\ncase 6000000:\r\np->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;\r\nbreak;\r\ncase 5000000:\r\np->u.ofdm.bandwidth = BANDWIDTH_5_MHZ;\r\nbreak;\r\ncase 1712000:\r\np->u.ofdm.bandwidth = BANDWIDTH_1_712_MHZ;\r\nbreak;\r\ncase 0:\r\ndefault:\r\np->u.ofdm.bandwidth = BANDWIDTH_AUTO;\r\n}\r\np->u.ofdm.code_rate_HP = c->code_rate_HP;\r\np->u.ofdm.code_rate_LP = c->code_rate_LP;\r\np->u.ofdm.constellation = c->modulation;\r\np->u.ofdm.transmission_mode = c->transmission_mode;\r\np->u.ofdm.guard_interval = c->guard_interval;\r\np->u.ofdm.hierarchy_information = c->hierarchy;\r\nbreak;\r\ncase DVBV3_ATSC:\r\ndprintk("%s() Preparing VSB req\n", __func__);\r\np->u.vsb.modulation = c->modulation;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dtv_get_frontend(struct dvb_frontend *fe,\r\nstruct dvb_frontend_parameters *p_out)\r\n{\r\nint r;\r\nif (fe->ops.get_frontend) {\r\nr = fe->ops.get_frontend(fe);\r\nif (unlikely(r < 0))\r\nreturn r;\r\nif (p_out)\r\ndtv_property_legacy_params_sync(fe, p_out);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dtv_property_process_get(struct dvb_frontend *fe,\r\nconst struct dtv_frontend_properties *c,\r\nstruct dtv_property *tvp,\r\nstruct file *file)\r\n{\r\nint r, ncaps;\r\nswitch(tvp->cmd) {\r\ncase DTV_ENUM_DELSYS:\r\nncaps = 0;\r\nwhile (fe->ops.delsys[ncaps] && ncaps < MAX_DELSYS) {\r\ntvp->u.buffer.data[ncaps] = fe->ops.delsys[ncaps];\r\nncaps++;\r\n}\r\ntvp->u.buffer.len = ncaps;\r\nbreak;\r\ncase DTV_FREQUENCY:\r\ntvp->u.data = c->frequency;\r\nbreak;\r\ncase DTV_MODULATION:\r\ntvp->u.data = c->modulation;\r\nbreak;\r\ncase DTV_BANDWIDTH_HZ:\r\ntvp->u.data = c->bandwidth_hz;\r\nbreak;\r\ncase DTV_INVERSION:\r\ntvp->u.data = c->inversion;\r\nbreak;\r\ncase DTV_SYMBOL_RATE:\r\ntvp->u.data = c->symbol_rate;\r\nbreak;\r\ncase DTV_INNER_FEC:\r\ntvp->u.data = c->fec_inner;\r\nbreak;\r\ncase DTV_PILOT:\r\ntvp->u.data = c->pilot;\r\nbreak;\r\ncase DTV_ROLLOFF:\r\ntvp->u.data = c->rolloff;\r\nbreak;\r\ncase DTV_DELIVERY_SYSTEM:\r\ntvp->u.data = c->delivery_system;\r\nbreak;\r\ncase DTV_VOLTAGE:\r\ntvp->u.data = c->voltage;\r\nbreak;\r\ncase DTV_TONE:\r\ntvp->u.data = c->sectone;\r\nbreak;\r\ncase DTV_API_VERSION:\r\ntvp->u.data = (DVB_API_VERSION << 8) | DVB_API_VERSION_MINOR;\r\nbreak;\r\ncase DTV_CODE_RATE_HP:\r\ntvp->u.data = c->code_rate_HP;\r\nbreak;\r\ncase DTV_CODE_RATE_LP:\r\ntvp->u.data = c->code_rate_LP;\r\nbreak;\r\ncase DTV_GUARD_INTERVAL:\r\ntvp->u.data = c->guard_interval;\r\nbreak;\r\ncase DTV_TRANSMISSION_MODE:\r\ntvp->u.data = c->transmission_mode;\r\nbreak;\r\ncase DTV_HIERARCHY:\r\ntvp->u.data = c->hierarchy;\r\nbreak;\r\ncase DTV_ISDBT_PARTIAL_RECEPTION:\r\ntvp->u.data = c->isdbt_partial_reception;\r\nbreak;\r\ncase DTV_ISDBT_SOUND_BROADCASTING:\r\ntvp->u.data = c->isdbt_sb_mode;\r\nbreak;\r\ncase DTV_ISDBT_SB_SUBCHANNEL_ID:\r\ntvp->u.data = c->isdbt_sb_subchannel;\r\nbreak;\r\ncase DTV_ISDBT_SB_SEGMENT_IDX:\r\ntvp->u.data = c->isdbt_sb_segment_idx;\r\nbreak;\r\ncase DTV_ISDBT_SB_SEGMENT_COUNT:\r\ntvp->u.data = c->isdbt_sb_segment_count;\r\nbreak;\r\ncase DTV_ISDBT_LAYER_ENABLED:\r\ntvp->u.data = c->isdbt_layer_enabled;\r\nbreak;\r\ncase DTV_ISDBT_LAYERA_FEC:\r\ntvp->u.data = c->layer[0].fec;\r\nbreak;\r\ncase DTV_ISDBT_LAYERA_MODULATION:\r\ntvp->u.data = c->layer[0].modulation;\r\nbreak;\r\ncase DTV_ISDBT_LAYERA_SEGMENT_COUNT:\r\ntvp->u.data = c->layer[0].segment_count;\r\nbreak;\r\ncase DTV_ISDBT_LAYERA_TIME_INTERLEAVING:\r\ntvp->u.data = c->layer[0].interleaving;\r\nbreak;\r\ncase DTV_ISDBT_LAYERB_FEC:\r\ntvp->u.data = c->layer[1].fec;\r\nbreak;\r\ncase DTV_ISDBT_LAYERB_MODULATION:\r\ntvp->u.data = c->layer[1].modulation;\r\nbreak;\r\ncase DTV_ISDBT_LAYERB_SEGMENT_COUNT:\r\ntvp->u.data = c->layer[1].segment_count;\r\nbreak;\r\ncase DTV_ISDBT_LAYERB_TIME_INTERLEAVING:\r\ntvp->u.data = c->layer[1].interleaving;\r\nbreak;\r\ncase DTV_ISDBT_LAYERC_FEC:\r\ntvp->u.data = c->layer[2].fec;\r\nbreak;\r\ncase DTV_ISDBT_LAYERC_MODULATION:\r\ntvp->u.data = c->layer[2].modulation;\r\nbreak;\r\ncase DTV_ISDBT_LAYERC_SEGMENT_COUNT:\r\ntvp->u.data = c->layer[2].segment_count;\r\nbreak;\r\ncase DTV_ISDBT_LAYERC_TIME_INTERLEAVING:\r\ntvp->u.data = c->layer[2].interleaving;\r\nbreak;\r\ncase DTV_ISDBS_TS_ID:\r\ntvp->u.data = c->isdbs_ts_id;\r\nbreak;\r\ncase DTV_DVBT2_PLP_ID:\r\ntvp->u.data = c->dvbt2_plp_id;\r\nbreak;\r\ncase DTV_ATSCMH_FIC_VER:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_fic_ver;\r\nbreak;\r\ncase DTV_ATSCMH_PARADE_ID:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_parade_id;\r\nbreak;\r\ncase DTV_ATSCMH_NOG:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_nog;\r\nbreak;\r\ncase DTV_ATSCMH_TNOG:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_tnog;\r\nbreak;\r\ncase DTV_ATSCMH_SGN:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_sgn;\r\nbreak;\r\ncase DTV_ATSCMH_PRC:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_prc;\r\nbreak;\r\ncase DTV_ATSCMH_RS_FRAME_MODE:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_rs_frame_mode;\r\nbreak;\r\ncase DTV_ATSCMH_RS_FRAME_ENSEMBLE:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_rs_frame_ensemble;\r\nbreak;\r\ncase DTV_ATSCMH_RS_CODE_MODE_PRI:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_rs_code_mode_pri;\r\nbreak;\r\ncase DTV_ATSCMH_RS_CODE_MODE_SEC:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_rs_code_mode_sec;\r\nbreak;\r\ncase DTV_ATSCMH_SCCC_BLOCK_MODE:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_sccc_block_mode;\r\nbreak;\r\ncase DTV_ATSCMH_SCCC_CODE_MODE_A:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_sccc_code_mode_a;\r\nbreak;\r\ncase DTV_ATSCMH_SCCC_CODE_MODE_B:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_sccc_code_mode_b;\r\nbreak;\r\ncase DTV_ATSCMH_SCCC_CODE_MODE_C:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_sccc_code_mode_c;\r\nbreak;\r\ncase DTV_ATSCMH_SCCC_CODE_MODE_D:\r\ntvp->u.data = fe->dtv_property_cache.atscmh_sccc_code_mode_d;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (fe->ops.get_property) {\r\nr = fe->ops.get_property(fe, tvp);\r\nif (r < 0)\r\nreturn r;\r\n}\r\ndtv_property_dump(tvp);\r\nreturn 0;\r\n}\r\nstatic bool is_dvbv3_delsys(u32 delsys)\r\n{\r\nbool status;\r\nstatus = (delsys == SYS_DVBT) || (delsys == SYS_DVBC_ANNEX_A) ||\r\n(delsys == SYS_DVBS) || (delsys == SYS_ATSC);\r\nreturn status;\r\n}\r\nstatic int set_delivery_system(struct dvb_frontend *fe, u32 desired_system)\r\n{\r\nint ncaps, i;\r\nu32 delsys = SYS_UNDEFINED;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nenum dvbv3_emulation_type type;\r\nif (c->delivery_system == SYS_UNDEFINED)\r\nc->delivery_system = fe->ops.delsys[0];\r\nif (desired_system == SYS_UNDEFINED) {\r\nif (is_dvbv3_delsys(c->delivery_system)) {\r\ndprintk("%s() Using delivery system to %d\n",\r\n__func__, c->delivery_system);\r\nreturn 0;\r\n}\r\ntype = dvbv3_type(c->delivery_system);\r\nswitch (type) {\r\ncase DVBV3_QPSK:\r\ndesired_system = SYS_DVBS;\r\nbreak;\r\ncase DVBV3_QAM:\r\ndesired_system = SYS_DVBC_ANNEX_A;\r\nbreak;\r\ncase DVBV3_ATSC:\r\ndesired_system = SYS_ATSC;\r\nbreak;\r\ncase DVBV3_OFDM:\r\ndesired_system = SYS_DVBT;\r\nbreak;\r\ndefault:\r\ndprintk("%s(): This frontend doesn't support DVBv3 calls\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nncaps = 0;\r\nwhile (fe->ops.delsys[ncaps] && ncaps < MAX_DELSYS) {\r\nif (fe->ops.delsys[ncaps] == desired_system) {\r\ndelsys = desired_system;\r\nbreak;\r\n}\r\nncaps++;\r\n}\r\nif (delsys == SYS_UNDEFINED) {\r\ndprintk("%s() Couldn't find a delivery system that matches %d\n",\r\n__func__, desired_system);\r\n}\r\n} else {\r\nncaps = 0;\r\nwhile (fe->ops.delsys[ncaps] && ncaps < MAX_DELSYS) {\r\nif (fe->ops.delsys[ncaps] == desired_system) {\r\nc->delivery_system = desired_system;\r\ndprintk("%s() Changing delivery system to %d\n",\r\n__func__, desired_system);\r\nreturn 0;\r\n}\r\nncaps++;\r\n}\r\ntype = dvbv3_type(desired_system);\r\nif (!is_dvbv3_delsys(desired_system)) {\r\ndprintk("%s() can't use a DVBv3 FE_SET_FRONTEND call on this frontend\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nncaps = 0;\r\nwhile (fe->ops.delsys[ncaps] && ncaps < MAX_DELSYS) {\r\nif ((dvbv3_type(fe->ops.delsys[ncaps]) == type) &&\r\n!is_dvbv3_delsys(fe->ops.delsys[ncaps]))\r\ndelsys = fe->ops.delsys[ncaps];\r\nncaps++;\r\n}\r\nif (delsys == SYS_UNDEFINED) {\r\ndprintk("%s() Incompatible DVBv3 FE_SET_FRONTEND call for this frontend\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nc->delivery_system = delsys;\r\ndprintk("%s() Using delivery system %d emulated as if it were a %d\n",\r\n__func__, delsys, desired_system);\r\nif (type == DVBV3_OFDM) {\r\nif (c->delivery_system == SYS_ISDBT) {\r\ndprintk("%s() Using defaults for SYS_ISDBT\n",\r\n__func__);\r\nif (!c->bandwidth_hz)\r\nc->bandwidth_hz = 6000000;\r\nc->isdbt_partial_reception = 0;\r\nc->isdbt_sb_mode = 0;\r\nc->isdbt_sb_subchannel = 0;\r\nc->isdbt_sb_segment_idx = 0;\r\nc->isdbt_sb_segment_count = 0;\r\nc->isdbt_layer_enabled = 0;\r\nfor (i = 0; i < 3; i++) {\r\nc->layer[i].fec = FEC_AUTO;\r\nc->layer[i].modulation = QAM_AUTO;\r\nc->layer[i].interleaving = 0;\r\nc->layer[i].segment_count = 0;\r\n}\r\n}\r\n}\r\ndprintk("change delivery system on cache to %d\n", c->delivery_system);\r\nreturn 0;\r\n}\r\nstatic int dtv_property_process_set(struct dvb_frontend *fe,\r\nstruct dtv_property *tvp,\r\nstruct file *file)\r\n{\r\nint r = 0;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (fe->ops.set_property) {\r\nr = fe->ops.set_property(fe, tvp);\r\nif (r < 0)\r\nreturn r;\r\n}\r\nswitch(tvp->cmd) {\r\ncase DTV_CLEAR:\r\ndvb_frontend_clear_cache(fe);\r\nbreak;\r\ncase DTV_TUNE:\r\nc->state = tvp->cmd;\r\ndprintk("%s() Finalised property cache\n", __func__);\r\nr = dtv_set_frontend(fe);\r\nbreak;\r\ncase DTV_FREQUENCY:\r\nc->frequency = tvp->u.data;\r\nbreak;\r\ncase DTV_MODULATION:\r\nc->modulation = tvp->u.data;\r\nbreak;\r\ncase DTV_BANDWIDTH_HZ:\r\nc->bandwidth_hz = tvp->u.data;\r\nbreak;\r\ncase DTV_INVERSION:\r\nc->inversion = tvp->u.data;\r\nbreak;\r\ncase DTV_SYMBOL_RATE:\r\nc->symbol_rate = tvp->u.data;\r\nbreak;\r\ncase DTV_INNER_FEC:\r\nc->fec_inner = tvp->u.data;\r\nbreak;\r\ncase DTV_PILOT:\r\nc->pilot = tvp->u.data;\r\nbreak;\r\ncase DTV_ROLLOFF:\r\nc->rolloff = tvp->u.data;\r\nbreak;\r\ncase DTV_DELIVERY_SYSTEM:\r\nr = set_delivery_system(fe, tvp->u.data);\r\nbreak;\r\ncase DTV_VOLTAGE:\r\nc->voltage = tvp->u.data;\r\nr = dvb_frontend_ioctl_legacy(file, FE_SET_VOLTAGE,\r\n(void *)c->voltage);\r\nbreak;\r\ncase DTV_TONE:\r\nc->sectone = tvp->u.data;\r\nr = dvb_frontend_ioctl_legacy(file, FE_SET_TONE,\r\n(void *)c->sectone);\r\nbreak;\r\ncase DTV_CODE_RATE_HP:\r\nc->code_rate_HP = tvp->u.data;\r\nbreak;\r\ncase DTV_CODE_RATE_LP:\r\nc->code_rate_LP = tvp->u.data;\r\nbreak;\r\ncase DTV_GUARD_INTERVAL:\r\nc->guard_interval = tvp->u.data;\r\nbreak;\r\ncase DTV_TRANSMISSION_MODE:\r\nc->transmission_mode = tvp->u.data;\r\nbreak;\r\ncase DTV_HIERARCHY:\r\nc->hierarchy = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_PARTIAL_RECEPTION:\r\nc->isdbt_partial_reception = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_SOUND_BROADCASTING:\r\nc->isdbt_sb_mode = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_SB_SUBCHANNEL_ID:\r\nc->isdbt_sb_subchannel = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_SB_SEGMENT_IDX:\r\nc->isdbt_sb_segment_idx = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_SB_SEGMENT_COUNT:\r\nc->isdbt_sb_segment_count = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYER_ENABLED:\r\nc->isdbt_layer_enabled = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERA_FEC:\r\nc->layer[0].fec = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERA_MODULATION:\r\nc->layer[0].modulation = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERA_SEGMENT_COUNT:\r\nc->layer[0].segment_count = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERA_TIME_INTERLEAVING:\r\nc->layer[0].interleaving = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERB_FEC:\r\nc->layer[1].fec = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERB_MODULATION:\r\nc->layer[1].modulation = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERB_SEGMENT_COUNT:\r\nc->layer[1].segment_count = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERB_TIME_INTERLEAVING:\r\nc->layer[1].interleaving = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERC_FEC:\r\nc->layer[2].fec = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERC_MODULATION:\r\nc->layer[2].modulation = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERC_SEGMENT_COUNT:\r\nc->layer[2].segment_count = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBT_LAYERC_TIME_INTERLEAVING:\r\nc->layer[2].interleaving = tvp->u.data;\r\nbreak;\r\ncase DTV_ISDBS_TS_ID:\r\nc->isdbs_ts_id = tvp->u.data;\r\nbreak;\r\ncase DTV_DVBT2_PLP_ID:\r\nc->dvbt2_plp_id = tvp->u.data;\r\nbreak;\r\ncase DTV_ATSCMH_PARADE_ID:\r\nfe->dtv_property_cache.atscmh_parade_id = tvp->u.data;\r\nbreak;\r\ncase DTV_ATSCMH_RS_FRAME_ENSEMBLE:\r\nfe->dtv_property_cache.atscmh_rs_frame_ensemble = tvp->u.data;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn r;\r\n}\r\nstatic int dvb_frontend_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_frontend *fe = dvbdev->priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nint err = -EOPNOTSUPP;\r\ndprintk("%s (%d)\n", __func__, _IOC_NR(cmd));\r\nif (fepriv->exit != DVB_FE_NO_EXIT)\r\nreturn -ENODEV;\r\nif ((file->f_flags & O_ACCMODE) == O_RDONLY &&\r\n(_IOC_DIR(cmd) != _IOC_READ || cmd == FE_GET_EVENT ||\r\ncmd == FE_DISEQC_RECV_SLAVE_REPLY))\r\nreturn -EPERM;\r\nif (down_interruptible (&fepriv->sem))\r\nreturn -ERESTARTSYS;\r\nif ((cmd == FE_SET_PROPERTY) || (cmd == FE_GET_PROPERTY))\r\nerr = dvb_frontend_ioctl_properties(file, cmd, parg);\r\nelse {\r\nc->state = DTV_UNDEFINED;\r\nerr = dvb_frontend_ioctl_legacy(file, cmd, parg);\r\n}\r\nup(&fepriv->sem);\r\nreturn err;\r\n}\r\nstatic int dvb_frontend_ioctl_properties(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_frontend *fe = dvbdev->priv;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint err = 0;\r\nstruct dtv_properties *tvps = NULL;\r\nstruct dtv_property *tvp = NULL;\r\nint i;\r\ndprintk("%s\n", __func__);\r\nif(cmd == FE_SET_PROPERTY) {\r\ntvps = (struct dtv_properties __user *)parg;\r\ndprintk("%s() properties.num = %d\n", __func__, tvps->num);\r\ndprintk("%s() properties.props = %p\n", __func__, tvps->props);\r\nif ((tvps->num == 0) || (tvps->num > DTV_IOCTL_MAX_MSGS))\r\nreturn -EINVAL;\r\ntvp = kmalloc(tvps->num * sizeof(struct dtv_property), GFP_KERNEL);\r\nif (!tvp) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(tvp, tvps->props, tvps->num * sizeof(struct dtv_property))) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nfor (i = 0; i < tvps->num; i++) {\r\nerr = dtv_property_process_set(fe, tvp + i, file);\r\nif (err < 0)\r\ngoto out;\r\n(tvp + i)->result = err;\r\n}\r\nif (c->state == DTV_TUNE)\r\ndprintk("%s() Property cache is full, tuning\n", __func__);\r\n} else\r\nif(cmd == FE_GET_PROPERTY) {\r\ntvps = (struct dtv_properties __user *)parg;\r\ndprintk("%s() properties.num = %d\n", __func__, tvps->num);\r\ndprintk("%s() properties.props = %p\n", __func__, tvps->props);\r\nif ((tvps->num == 0) || (tvps->num > DTV_IOCTL_MAX_MSGS))\r\nreturn -EINVAL;\r\ntvp = kmalloc(tvps->num * sizeof(struct dtv_property), GFP_KERNEL);\r\nif (!tvp) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(tvp, tvps->props, tvps->num * sizeof(struct dtv_property))) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (fepriv->state != FESTATE_IDLE) {\r\nerr = dtv_get_frontend(fe, NULL);\r\nif (err < 0)\r\ngoto out;\r\n}\r\nfor (i = 0; i < tvps->num; i++) {\r\nerr = dtv_property_process_get(fe, c, tvp + i, file);\r\nif (err < 0)\r\ngoto out;\r\n(tvp + i)->result = err;\r\n}\r\nif (copy_to_user(tvps->props, tvp, tvps->num * sizeof(struct dtv_property))) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\n} else\r\nerr = -EOPNOTSUPP;\r\nout:\r\nkfree(tvp);\r\nreturn err;\r\n}\r\nstatic int dtv_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct dvb_frontend_tune_settings fetunesettings;\r\nu32 rolloff = 0;\r\nif (dvb_frontend_check_parameters(fe) < 0)\r\nreturn -EINVAL;\r\ndtv_property_legacy_params_sync(fe, &fepriv->parameters_out);\r\nswitch (c->delivery_system) {\r\ncase SYS_ATSC:\r\ncase SYS_DVBC_ANNEX_B:\r\nc->bandwidth_hz = 6000000;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nrolloff = 115;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_C:\r\nrolloff = 113;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (rolloff)\r\nc->bandwidth_hz = (c->symbol_rate * rolloff) / 100;\r\nif (dvb_force_auto_inversion)\r\nc->inversion = INVERSION_AUTO;\r\nif (c->hierarchy == HIERARCHY_NONE && c->code_rate_LP == FEC_NONE)\r\nc->code_rate_LP = FEC_AUTO;\r\nmemset(&fetunesettings, 0, sizeof(struct dvb_frontend_tune_settings));\r\nif (fe->ops.get_tune_settings && (fe->ops.get_tune_settings(fe, &fetunesettings) == 0)) {\r\nfepriv->min_delay = (fetunesettings.min_delay_ms * HZ) / 1000;\r\nfepriv->max_drift = fetunesettings.max_drift;\r\nfepriv->step_size = fetunesettings.step_size;\r\n} else {\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\ncase SYS_DVBS2:\r\ncase SYS_ISDBS:\r\ncase SYS_TURBO:\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\nfepriv->min_delay = HZ / 20;\r\nfepriv->step_size = c->symbol_rate / 16000;\r\nfepriv->max_drift = c->symbol_rate / 2000;\r\nbreak;\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\ncase SYS_ISDBT:\r\ncase SYS_DMBTH:\r\nfepriv->min_delay = HZ / 20;\r\nfepriv->step_size = fe->ops.info.frequency_stepsize * 2;\r\nfepriv->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;\r\nbreak;\r\ndefault:\r\nfepriv->min_delay = HZ / 20;\r\nfepriv->step_size = 0;\r\nfepriv->max_drift = 0;\r\nbreak;\r\n}\r\n}\r\nif (dvb_override_tune_delay > 0)\r\nfepriv->min_delay = (dvb_override_tune_delay * HZ) / 1000;\r\nfepriv->state = FESTATE_RETUNE;\r\nfepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;\r\ndvb_frontend_clear_events(fe);\r\ndvb_frontend_add_event(fe, 0);\r\ndvb_frontend_wakeup(fe);\r\nfepriv->status = 0;\r\nreturn 0;\r\n}\r\nstatic int dvb_frontend_ioctl_legacy(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_frontend *fe = dvbdev->priv;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint cb_err, err = -EOPNOTSUPP;\r\nif (fe->dvb->fe_ioctl_override) {\r\ncb_err = fe->dvb->fe_ioctl_override(fe, cmd, parg,\r\nDVB_FE_IOCTL_PRE);\r\nif (cb_err < 0)\r\nreturn cb_err;\r\nif (cb_err > 0)\r\nreturn 0;\r\n}\r\nswitch (cmd) {\r\ncase FE_GET_INFO: {\r\nstruct dvb_frontend_info* info = parg;\r\nmemcpy(info, &fe->ops.info, sizeof(struct dvb_frontend_info));\r\ndvb_frontend_get_frequency_limits(fe, &info->frequency_min, &info->frequency_max);\r\nswitch (dvbv3_type(c->delivery_system)) {\r\ncase DVBV3_QPSK:\r\ninfo->type = FE_QPSK;\r\nbreak;\r\ncase DVBV3_ATSC:\r\ninfo->type = FE_ATSC;\r\nbreak;\r\ncase DVBV3_QAM:\r\ninfo->type = FE_QAM;\r\nbreak;\r\ncase DVBV3_OFDM:\r\ninfo->type = FE_OFDM;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"%s: doesn't know how to handle a DVBv3 call to delivery system %i\n",\r\n__func__, c->delivery_system);\r\nfe->ops.info.type = FE_OFDM;\r\n}\r\ndprintk("current delivery system on cache: %d, V3 type: %d\n",\r\nc->delivery_system, fe->ops.info.type);\r\ninfo->caps |= FE_CAN_INVERSION_AUTO;\r\nerr = 0;\r\nbreak;\r\n}\r\ncase FE_READ_STATUS: {\r\nfe_status_t* status = parg;\r\nif (fepriv->state == FESTATE_RETUNE ||\r\nfepriv->state == FESTATE_ERROR) {\r\nerr=0;\r\n*status = 0;\r\nbreak;\r\n}\r\nif (fe->ops.read_status)\r\nerr = fe->ops.read_status(fe, status);\r\nbreak;\r\n}\r\ncase FE_READ_BER:\r\nif (fe->ops.read_ber)\r\nerr = fe->ops.read_ber(fe, (__u32*) parg);\r\nbreak;\r\ncase FE_READ_SIGNAL_STRENGTH:\r\nif (fe->ops.read_signal_strength)\r\nerr = fe->ops.read_signal_strength(fe, (__u16*) parg);\r\nbreak;\r\ncase FE_READ_SNR:\r\nif (fe->ops.read_snr)\r\nerr = fe->ops.read_snr(fe, (__u16*) parg);\r\nbreak;\r\ncase FE_READ_UNCORRECTED_BLOCKS:\r\nif (fe->ops.read_ucblocks)\r\nerr = fe->ops.read_ucblocks(fe, (__u32*) parg);\r\nbreak;\r\ncase FE_DISEQC_RESET_OVERLOAD:\r\nif (fe->ops.diseqc_reset_overload) {\r\nerr = fe->ops.diseqc_reset_overload(fe);\r\nfepriv->state = FESTATE_DISEQC;\r\nfepriv->status = 0;\r\n}\r\nbreak;\r\ncase FE_DISEQC_SEND_MASTER_CMD:\r\nif (fe->ops.diseqc_send_master_cmd) {\r\nerr = fe->ops.diseqc_send_master_cmd(fe, (struct dvb_diseqc_master_cmd*) parg);\r\nfepriv->state = FESTATE_DISEQC;\r\nfepriv->status = 0;\r\n}\r\nbreak;\r\ncase FE_DISEQC_SEND_BURST:\r\nif (fe->ops.diseqc_send_burst) {\r\nerr = fe->ops.diseqc_send_burst(fe, (fe_sec_mini_cmd_t) parg);\r\nfepriv->state = FESTATE_DISEQC;\r\nfepriv->status = 0;\r\n}\r\nbreak;\r\ncase FE_SET_TONE:\r\nif (fe->ops.set_tone) {\r\nerr = fe->ops.set_tone(fe, (fe_sec_tone_mode_t) parg);\r\nfepriv->tone = (fe_sec_tone_mode_t) parg;\r\nfepriv->state = FESTATE_DISEQC;\r\nfepriv->status = 0;\r\n}\r\nbreak;\r\ncase FE_SET_VOLTAGE:\r\nif (fe->ops.set_voltage) {\r\nerr = fe->ops.set_voltage(fe, (fe_sec_voltage_t) parg);\r\nfepriv->voltage = (fe_sec_voltage_t) parg;\r\nfepriv->state = FESTATE_DISEQC;\r\nfepriv->status = 0;\r\n}\r\nbreak;\r\ncase FE_DISHNETWORK_SEND_LEGACY_CMD:\r\nif (fe->ops.dishnetwork_send_legacy_command) {\r\nerr = fe->ops.dishnetwork_send_legacy_command(fe, (unsigned long) parg);\r\nfepriv->state = FESTATE_DISEQC;\r\nfepriv->status = 0;\r\n} else if (fe->ops.set_voltage) {\r\nunsigned long swcmd = ((unsigned long) parg) << 1;\r\nstruct timeval nexttime;\r\nstruct timeval tv[10];\r\nint i;\r\nu8 last = 1;\r\nif (dvb_frontend_debug)\r\nprintk("%s switch command: 0x%04lx\n", __func__, swcmd);\r\ndo_gettimeofday(&nexttime);\r\nif (dvb_frontend_debug)\r\nmemcpy(&tv[0], &nexttime, sizeof(struct timeval));\r\nfe->ops.set_voltage(fe, SEC_VOLTAGE_18);\r\ndvb_frontend_sleep_until(&nexttime, 32000);\r\nfor (i = 0; i < 9; i++) {\r\nif (dvb_frontend_debug)\r\ndo_gettimeofday(&tv[i + 1]);\r\nif ((swcmd & 0x01) != last) {\r\nfe->ops.set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);\r\nlast = (last) ? 0 : 1;\r\n}\r\nswcmd = swcmd >> 1;\r\nif (i != 8)\r\ndvb_frontend_sleep_until(&nexttime, 8000);\r\n}\r\nif (dvb_frontend_debug) {\r\nprintk("%s(%d): switch delay (should be 32k followed by all 8k\n",\r\n__func__, fe->dvb->num);\r\nfor (i = 1; i < 10; i++)\r\nprintk("%d: %d\n", i, timeval_usec_diff(tv[i-1] , tv[i]));\r\n}\r\nerr = 0;\r\nfepriv->state = FESTATE_DISEQC;\r\nfepriv->status = 0;\r\n}\r\nbreak;\r\ncase FE_DISEQC_RECV_SLAVE_REPLY:\r\nif (fe->ops.diseqc_recv_slave_reply)\r\nerr = fe->ops.diseqc_recv_slave_reply(fe, (struct dvb_diseqc_slave_reply*) parg);\r\nbreak;\r\ncase FE_ENABLE_HIGH_LNB_VOLTAGE:\r\nif (fe->ops.enable_high_lnb_voltage)\r\nerr = fe->ops.enable_high_lnb_voltage(fe, (long) parg);\r\nbreak;\r\ncase FE_SET_FRONTEND:\r\nerr = set_delivery_system(fe, SYS_UNDEFINED);\r\nif (err)\r\nbreak;\r\nerr = dtv_property_cache_sync(fe, c, parg);\r\nif (err)\r\nbreak;\r\nerr = dtv_set_frontend(fe);\r\nbreak;\r\ncase FE_GET_EVENT:\r\nerr = dvb_frontend_get_event (fe, parg, file->f_flags);\r\nbreak;\r\ncase FE_GET_FRONTEND:\r\nerr = dtv_get_frontend(fe, parg);\r\nbreak;\r\ncase FE_SET_FRONTEND_TUNE_MODE:\r\nfepriv->tune_mode_flags = (unsigned long) parg;\r\nerr = 0;\r\nbreak;\r\n};\r\nif (fe->dvb->fe_ioctl_override) {\r\ncb_err = fe->dvb->fe_ioctl_override(fe, cmd, parg,\r\nDVB_FE_IOCTL_POST);\r\nif (cb_err < 0)\r\nreturn cb_err;\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned int dvb_frontend_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_frontend *fe = dvbdev->priv;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\ndprintk ("%s\n", __func__);\r\npoll_wait (file, &fepriv->events.wait_queue, wait);\r\nif (fepriv->events.eventw != fepriv->events.eventr)\r\nreturn (POLLIN | POLLRDNORM | POLLPRI);\r\nreturn 0;\r\n}\r\nstatic int dvb_frontend_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_frontend *fe = dvbdev->priv;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nstruct dvb_adapter *adapter = fe->dvb;\r\nint ret;\r\ndprintk ("%s\n", __func__);\r\nif (fepriv->exit == DVB_FE_DEVICE_REMOVED)\r\nreturn -ENODEV;\r\nif (adapter->mfe_shared) {\r\nmutex_lock (&adapter->mfe_lock);\r\nif (adapter->mfe_dvbdev == NULL)\r\nadapter->mfe_dvbdev = dvbdev;\r\nelse if (adapter->mfe_dvbdev != dvbdev) {\r\nstruct dvb_device\r\n*mfedev = adapter->mfe_dvbdev;\r\nstruct dvb_frontend\r\n*mfe = mfedev->priv;\r\nstruct dvb_frontend_private\r\n*mfepriv = mfe->frontend_priv;\r\nint mferetry = (dvb_mfe_wait_time << 1);\r\nmutex_unlock (&adapter->mfe_lock);\r\nwhile (mferetry-- && (mfedev->users != -1 ||\r\nmfepriv->thread != NULL)) {\r\nif(msleep_interruptible(500)) {\r\nif(signal_pending(current))\r\nreturn -EINTR;\r\n}\r\n}\r\nmutex_lock (&adapter->mfe_lock);\r\nif(adapter->mfe_dvbdev != dvbdev) {\r\nmfedev = adapter->mfe_dvbdev;\r\nmfe = mfedev->priv;\r\nmfepriv = mfe->frontend_priv;\r\nif (mfedev->users != -1 ||\r\nmfepriv->thread != NULL) {\r\nmutex_unlock (&adapter->mfe_lock);\r\nreturn -EBUSY;\r\n}\r\nadapter->mfe_dvbdev = dvbdev;\r\n}\r\n}\r\n}\r\nif (dvbdev->users == -1 && fe->ops.ts_bus_ctrl) {\r\nif ((ret = fe->ops.ts_bus_ctrl(fe, 1)) < 0)\r\ngoto err0;\r\nfepriv->reinitialise = 1;\r\n}\r\nif ((ret = dvb_generic_open (inode, file)) < 0)\r\ngoto err1;\r\nif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\r\nfepriv->tune_mode_flags &= ~FE_TUNE_MODE_ONESHOT;\r\nfepriv->tone = -1;\r\nfepriv->voltage = -1;\r\nret = dvb_frontend_start (fe);\r\nif (ret)\r\ngoto err2;\r\nfepriv->events.eventr = fepriv->events.eventw = 0;\r\n}\r\nif (adapter->mfe_shared)\r\nmutex_unlock (&adapter->mfe_lock);\r\nreturn ret;\r\nerr2:\r\ndvb_generic_release(inode, file);\r\nerr1:\r\nif (dvbdev->users == -1 && fe->ops.ts_bus_ctrl)\r\nfe->ops.ts_bus_ctrl(fe, 0);\r\nerr0:\r\nif (adapter->mfe_shared)\r\nmutex_unlock (&adapter->mfe_lock);\r\nreturn ret;\r\n}\r\nstatic int dvb_frontend_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_frontend *fe = dvbdev->priv;\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\nint ret;\r\ndprintk ("%s\n", __func__);\r\nif ((file->f_flags & O_ACCMODE) != O_RDONLY) {\r\nfepriv->release_jiffies = jiffies;\r\nmb();\r\n}\r\nret = dvb_generic_release (inode, file);\r\nif (dvbdev->users == -1) {\r\nwake_up(&fepriv->wait_queue);\r\nif (fepriv->exit != DVB_FE_NO_EXIT) {\r\nfops_put(file->f_op);\r\nfile->f_op = NULL;\r\nwake_up(&dvbdev->wait_queue);\r\n}\r\nif (fe->ops.ts_bus_ctrl)\r\nfe->ops.ts_bus_ctrl(fe, 0);\r\n}\r\nreturn ret;\r\n}\r\nint dvb_register_frontend(struct dvb_adapter* dvb,\r\nstruct dvb_frontend* fe)\r\n{\r\nstruct dvb_frontend_private *fepriv;\r\nstatic const struct dvb_device dvbdev_template = {\r\n.users = ~0,\r\n.writers = 1,\r\n.readers = (~0)-1,\r\n.fops = &dvb_frontend_fops,\r\n.kernel_ioctl = dvb_frontend_ioctl\r\n};\r\ndprintk ("%s\n", __func__);\r\nif (mutex_lock_interruptible(&frontend_mutex))\r\nreturn -ERESTARTSYS;\r\nfe->frontend_priv = kzalloc(sizeof(struct dvb_frontend_private), GFP_KERNEL);\r\nif (fe->frontend_priv == NULL) {\r\nmutex_unlock(&frontend_mutex);\r\nreturn -ENOMEM;\r\n}\r\nfepriv = fe->frontend_priv;\r\nsema_init(&fepriv->sem, 1);\r\ninit_waitqueue_head (&fepriv->wait_queue);\r\ninit_waitqueue_head (&fepriv->events.wait_queue);\r\nmutex_init(&fepriv->events.mtx);\r\nfe->dvb = dvb;\r\nfepriv->inversion = INVERSION_OFF;\r\nprintk ("DVB: registering adapter %i frontend %i (%s)...\n",\r\nfe->dvb->num,\r\nfe->id,\r\nfe->ops.info.name);\r\ndvb_register_device (fe->dvb, &fepriv->dvbdev, &dvbdev_template,\r\nfe, DVB_DEVICE_FRONTEND);\r\nfe->dtv_property_cache.delivery_system = fe->ops.delsys[0];\r\ndvb_frontend_clear_cache(fe);\r\nmutex_unlock(&frontend_mutex);\r\nreturn 0;\r\n}\r\nint dvb_unregister_frontend(struct dvb_frontend* fe)\r\n{\r\nstruct dvb_frontend_private *fepriv = fe->frontend_priv;\r\ndprintk ("%s\n", __func__);\r\nmutex_lock(&frontend_mutex);\r\ndvb_frontend_stop (fe);\r\nmutex_unlock(&frontend_mutex);\r\nif (fepriv->dvbdev->users < -1)\r\nwait_event(fepriv->dvbdev->wait_queue,\r\nfepriv->dvbdev->users==-1);\r\nmutex_lock(&frontend_mutex);\r\ndvb_unregister_device (fepriv->dvbdev);\r\nkfree(fepriv);\r\nmutex_unlock(&frontend_mutex);\r\nreturn 0;\r\n}\r\nvoid dvb_frontend_detach(struct dvb_frontend* fe)\r\n{\r\nvoid *ptr;\r\nif (fe->ops.release_sec) {\r\nfe->ops.release_sec(fe);\r\nsymbol_put_addr(fe->ops.release_sec);\r\n}\r\nif (fe->ops.tuner_ops.release) {\r\nfe->ops.tuner_ops.release(fe);\r\nsymbol_put_addr(fe->ops.tuner_ops.release);\r\n}\r\nif (fe->ops.analog_ops.release) {\r\nfe->ops.analog_ops.release(fe);\r\nsymbol_put_addr(fe->ops.analog_ops.release);\r\n}\r\nptr = (void*)fe->ops.release;\r\nif (ptr) {\r\nfe->ops.release(fe);\r\nsymbol_put_addr(ptr);\r\n}\r\n}\r\nvoid dvb_frontend_detach(struct dvb_frontend* fe)\r\n{\r\nif (fe->ops.release_sec)\r\nfe->ops.release_sec(fe);\r\nif (fe->ops.tuner_ops.release)\r\nfe->ops.tuner_ops.release(fe);\r\nif (fe->ops.analog_ops.release)\r\nfe->ops.analog_ops.release(fe);\r\nif (fe->ops.release)\r\nfe->ops.release(fe);\r\n}
