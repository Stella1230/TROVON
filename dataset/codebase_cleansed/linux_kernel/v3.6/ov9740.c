static int ov9740_reg_read(struct i2c_client *client, u16 reg, u8 *val)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = (u8 *)&reg,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = val,\r\n},\r\n};\r\nreg = swab16(reg);\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed reading register 0x%04x!\n", reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov9740_reg_write(struct i2c_client *client, u16 reg, u8 val)\r\n{\r\nstruct i2c_msg msg;\r\nstruct {\r\nu16 reg;\r\nu8 val;\r\n} __packed buf;\r\nint ret;\r\nreg = swab16(reg);\r\nbuf.reg = reg;\r\nbuf.val = val;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 3;\r\nmsg.buf = (u8 *)&buf;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed writing register 0x%04x!\n", reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov9740_reg_rmw(struct i2c_client *client, u16 reg, u8 set, u8 unset)\r\n{\r\nu8 val;\r\nint ret;\r\nret = ov9740_reg_read(client, reg, &val);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"[Read]-Modify-Write of register 0x%04x failed!\n",\r\nreg);\r\nreturn ret;\r\n}\r\nval |= set;\r\nval &= ~unset;\r\nret = ov9740_reg_write(client, reg, val);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Read-Modify-[Write] of register 0x%04x failed!\n",\r\nreg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov9740_reg_write_array(struct i2c_client *client,\r\nconst struct ov9740_reg *regarray,\r\nint regarraylen)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < regarraylen; i++) {\r\nret = ov9740_reg_write(client,\r\nregarray[i].reg, regarray[i].val);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov9740_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov9740_priv *priv = to_ov9740(sd);\r\nint ret;\r\nif (priv->flag_vflip)\r\nret = ov9740_reg_rmw(client, OV9740_IMAGE_ORT, 0x2, 0);\r\nelse\r\nret = ov9740_reg_rmw(client, OV9740_IMAGE_ORT, 0, 0x2);\r\nif (ret < 0)\r\nreturn ret;\r\nif (priv->flag_hflip)\r\nret = ov9740_reg_rmw(client, OV9740_IMAGE_ORT, 0x1, 0);\r\nelse\r\nret = ov9740_reg_rmw(client, OV9740_IMAGE_ORT, 0, 0x1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enable) {\r\ndev_dbg(&client->dev, "Enabling Streaming\n");\r\nret = ov9740_reg_write(client, OV9740_MODE_SELECT, 0x01);\r\n} else {\r\ndev_dbg(&client->dev, "Disabling Streaming\n");\r\nret = ov9740_reg_write(client, OV9740_SOFTWARE_RESET, 0x01);\r\nif (!ret)\r\nret = ov9740_reg_write(client, OV9740_MODE_SELECT,\r\n0x00);\r\n}\r\npriv->current_enable = enable;\r\nreturn ret;\r\n}\r\nstatic void ov9740_res_roundup(u32 *width, u32 *height)\r\n{\r\n*width = ALIGN(*width, 4);\r\nif (*width > OV9740_MAX_WIDTH)\r\n*width = OV9740_MAX_WIDTH;\r\nif (*height > OV9740_MAX_HEIGHT)\r\n*height = OV9740_MAX_HEIGHT;\r\n}\r\nstatic int ov9740_set_res(struct i2c_client *client, u32 width, u32 height)\r\n{\r\nu32 x_start;\r\nu32 y_start;\r\nu32 x_end;\r\nu32 y_end;\r\nbool scaling = 0;\r\nu32 scale_input_x;\r\nu32 scale_input_y;\r\nint ret;\r\nif ((width != OV9740_MAX_WIDTH) || (height != OV9740_MAX_HEIGHT))\r\nscaling = 1;\r\nif ((OV9740_MAX_WIDTH * height) > (OV9740_MAX_HEIGHT * width)) {\r\nscale_input_x = (OV9740_MAX_HEIGHT * width) / height;\r\nscale_input_y = OV9740_MAX_HEIGHT;\r\n} else {\r\nscale_input_x = OV9740_MAX_WIDTH;\r\nscale_input_y = (OV9740_MAX_WIDTH * height) / width;\r\n}\r\nx_start = (OV9740_MAX_WIDTH - scale_input_x) / 2;\r\ny_start = (OV9740_MAX_HEIGHT - scale_input_y) / 2;\r\nx_end = x_start + scale_input_x - 1;\r\ny_end = y_start + scale_input_y - 1;\r\nret = ov9740_reg_write(client, OV9740_X_ADDR_START_HI, x_start >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_X_ADDR_START_LO, x_start & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_Y_ADDR_START_HI, y_start >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_Y_ADDR_START_LO, y_start & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_X_ADDR_END_HI, x_end >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_X_ADDR_END_LO, x_end & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_Y_ADDR_END_HI, y_end >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_Y_ADDR_END_LO, y_end & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_X_OUTPUT_SIZE_HI, width >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_X_OUTPUT_SIZE_LO, width & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_Y_OUTPUT_SIZE_HI, height >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_Y_OUTPUT_SIZE_LO, height & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_ISP_CTRL1E, scale_input_x >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_ISP_CTRL1F, scale_input_x & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_ISP_CTRL20, scale_input_y >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_ISP_CTRL21, scale_input_y & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_VFIFO_READ_START_HI,\r\n(scale_input_x - width) >> 8);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_VFIFO_READ_START_LO,\r\n(scale_input_x - width) & 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_ISP_CTRL00, 0xff);\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_ISP_CTRL01, 0xef |\r\n(scaling << 4));\r\nif (ret)\r\ngoto done;\r\nret = ov9740_reg_write(client, OV9740_ISP_CTRL03, 0xff);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int ov9740_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov9740_priv *priv = to_ov9740(sd);\r\nenum v4l2_colorspace cspace;\r\nenum v4l2_mbus_pixelcode code = mf->code;\r\nint ret;\r\nov9740_res_roundup(&mf->width, &mf->height);\r\nswitch (code) {\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\ncspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = ov9740_reg_write_array(client, ov9740_defaults,\r\nARRAY_SIZE(ov9740_defaults));\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov9740_set_res(client, mf->width, mf->height);\r\nif (ret < 0)\r\nreturn ret;\r\nmf->code = code;\r\nmf->colorspace = cspace;\r\nmemcpy(&priv->current_mf, mf, sizeof(struct v4l2_mbus_framefmt));\r\nreturn ret;\r\n}\r\nstatic int ov9740_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nov9740_res_roundup(&mf->width, &mf->height);\r\nmf->field = V4L2_FIELD_NONE;\r\nmf->code = V4L2_MBUS_FMT_YUYV8_2X8;\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn 0;\r\n}\r\nstatic int ov9740_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(ov9740_codes))\r\nreturn -EINVAL;\r\n*code = ov9740_codes[index];\r\nreturn 0;\r\n}\r\nstatic int ov9740_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = OV9740_MAX_WIDTH;\r\na->bounds.height = OV9740_MAX_HEIGHT;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int ov9740_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\na->c.left = 0;\r\na->c.top = 0;\r\na->c.width = OV9740_MAX_WIDTH;\r\na->c.height = OV9740_MAX_HEIGHT;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int ov9740_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ov9740_priv *priv =\r\ncontainer_of(ctrl->handler, struct ov9740_priv, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\npriv->flag_vflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\npriv->flag_hflip = ctrl->val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov9740_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct ov9740_priv *priv = to_ov9740(sd);\r\nid->ident = priv->ident;\r\nid->revision = priv->revision;\r\nreturn 0;\r\n}\r\nstatic int ov9740_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct ov9740_priv *priv = to_ov9740(sd);\r\nif (!priv->current_enable)\r\nreturn 0;\r\nif (on) {\r\nov9740_s_fmt(sd, &priv->current_mf);\r\nov9740_s_stream(sd, priv->current_enable);\r\n} else {\r\nov9740_s_stream(sd, 0);\r\npriv->current_enable = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov9740_get_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nu8 val;\r\nif (reg->reg & ~0xffff)\r\nreturn -EINVAL;\r\nreg->size = 2;\r\nret = ov9740_reg_read(client, reg->reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreg->val = (__u64)val;\r\nreturn ret;\r\n}\r\nstatic int ov9740_set_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg & ~0xffff || reg->val & ~0xff)\r\nreturn -EINVAL;\r\nreturn ov9740_reg_write(client, reg->reg, reg->val);\r\n}\r\nstatic int ov9740_video_probe(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ov9740_priv *priv = to_ov9740(sd);\r\nu8 modelhi, modello;\r\nint ret;\r\nret = ov9740_reg_read(client, OV9740_MODEL_ID_HI, &modelhi);\r\nif (ret < 0)\r\ngoto err;\r\nret = ov9740_reg_read(client, OV9740_MODEL_ID_LO, &modello);\r\nif (ret < 0)\r\ngoto err;\r\npriv->model = (modelhi << 8) | modello;\r\nret = ov9740_reg_read(client, OV9740_REVISION_NUMBER, &priv->revision);\r\nif (ret < 0)\r\ngoto err;\r\nret = ov9740_reg_read(client, OV9740_MANUFACTURER_ID, &priv->manid);\r\nif (ret < 0)\r\ngoto err;\r\nret = ov9740_reg_read(client, OV9740_SMIA_VERSION, &priv->smiaver);\r\nif (ret < 0)\r\ngoto err;\r\nif (priv->model != 0x9740) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\npriv->ident = V4L2_IDENT_OV9740;\r\ndev_info(&client->dev, "ov9740 Model ID 0x%04x, Revision 0x%02x, "\r\n"Manufacturer 0x%02x, SMIA Version 0x%02x\n",\r\npriv->model, priv->revision, priv->manid, priv->smiaver);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int ov9740_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\ncfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(icl, cfg);\r\nreturn 0;\r\n}\r\nstatic int ov9740_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ov9740_priv *priv;\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nint ret;\r\nif (!icl) {\r\ndev_err(&client->dev, "Missing platform_data for driver\n");\r\nreturn -EINVAL;\r\n}\r\npriv = kzalloc(sizeof(struct ov9740_priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&client->dev, "Failed to allocate private data!\n");\r\nreturn -ENOMEM;\r\n}\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &ov9740_subdev_ops);\r\nv4l2_ctrl_handler_init(&priv->hdl, 13);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov9740_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov9740_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\npriv->subdev.ctrl_handler = &priv->hdl;\r\nif (priv->hdl.error) {\r\nint err = priv->hdl.error;\r\nkfree(priv);\r\nreturn err;\r\n}\r\nret = ov9740_video_probe(client);\r\nif (!ret)\r\nret = v4l2_ctrl_handler_setup(&priv->hdl);\r\nif (ret < 0) {\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nkfree(priv);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov9740_remove(struct i2c_client *client)\r\n{\r\nstruct ov9740_priv *priv = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(&priv->subdev);\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nkfree(priv);\r\nreturn 0;\r\n}
