static inline int superio_inb(int base, int reg)\r\n{\r\noutb(reg, base);\r\nreturn inb(base + 1);\r\n}\r\nstatic int superio_inw(int base, int reg)\r\n{\r\nint val;\r\nval = superio_inb(base, reg) << 8;\r\nval |= superio_inb(base, reg + 1);\r\nreturn val;\r\n}\r\nstatic inline int superio_enter(int base)\r\n{\r\nif (!request_muxed_region(base, 2, DRVNAME)) {\r\npr_err("I/O address 0x%04x already in use\n", base);\r\nreturn -EBUSY;\r\n}\r\noutb(SIO_UNLOCK_KEY, base);\r\noutb(SIO_UNLOCK_KEY, base);\r\nreturn 0;\r\n}\r\nstatic inline void superio_select(int base, int ld)\r\n{\r\noutb(SIO_REG_LDSEL, base);\r\noutb(ld, base + 1);\r\n}\r\nstatic inline void superio_exit(int base)\r\n{\r\noutb(SIO_LOCK_KEY, base);\r\nrelease_region(base, 2);\r\n}\r\nstatic inline int fan_from_reg(u16 reg)\r\n{\r\nreturn reg ? (1500000 / reg) : 0;\r\n}\r\nstatic inline u16 fan_to_reg(int fan)\r\n{\r\nreturn fan ? (1500000 / fan) : 0;\r\n}\r\nstatic u8 f71882fg_read8(struct f71882fg_data *data, u8 reg)\r\n{\r\nu8 val;\r\noutb(reg, data->addr + ADDR_REG_OFFSET);\r\nval = inb(data->addr + DATA_REG_OFFSET);\r\nreturn val;\r\n}\r\nstatic u16 f71882fg_read16(struct f71882fg_data *data, u8 reg)\r\n{\r\nu16 val;\r\nval = f71882fg_read8(data, reg) << 8;\r\nval |= f71882fg_read8(data, reg + 1);\r\nreturn val;\r\n}\r\nstatic void f71882fg_write8(struct f71882fg_data *data, u8 reg, u8 val)\r\n{\r\noutb(reg, data->addr + ADDR_REG_OFFSET);\r\noutb(val, data->addr + DATA_REG_OFFSET);\r\n}\r\nstatic void f71882fg_write16(struct f71882fg_data *data, u8 reg, u16 val)\r\n{\r\nf71882fg_write8(data, reg, val >> 8);\r\nf71882fg_write8(data, reg + 1, val & 0xff);\r\n}\r\nstatic u16 f71882fg_read_temp(struct f71882fg_data *data, int nr)\r\n{\r\nif (data->type == f71858fg)\r\nreturn f71882fg_read16(data, F71882FG_REG_TEMP(nr));\r\nelse\r\nreturn f71882fg_read8(data, F71882FG_REG_TEMP(nr));\r\n}\r\nstatic struct f71882fg_data *f71882fg_update_device(struct device *dev)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint nr_fans = f71882fg_nr_fans[data->type];\r\nint nr_temps = f71882fg_nr_temps[data->type];\r\nint nr, reg, point;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_limits + 60 * HZ) ||\r\n!data->valid) {\r\nif (f71882fg_has_in1_alarm[data->type]) {\r\ndata->in1_max =\r\nf71882fg_read8(data, F71882FG_REG_IN1_HIGH);\r\ndata->in_beep =\r\nf71882fg_read8(data, F71882FG_REG_IN_BEEP);\r\n}\r\nfor (nr = data->temp_start; nr < nr_temps + data->temp_start;\r\nnr++) {\r\ndata->temp_ovt[nr] = f71882fg_read8(data,\r\nF71882FG_REG_TEMP_OVT(nr));\r\ndata->temp_high[nr] = f71882fg_read8(data,\r\nF71882FG_REG_TEMP_HIGH(nr));\r\n}\r\nif (data->type != f8000) {\r\ndata->temp_hyst[0] = f71882fg_read8(data,\r\nF71882FG_REG_TEMP_HYST(0));\r\ndata->temp_hyst[1] = f71882fg_read8(data,\r\nF71882FG_REG_TEMP_HYST(1));\r\n}\r\nif ((data->type != f71858fg) && (data->type != f8000)) {\r\nreg = f71882fg_read8(data, F71882FG_REG_TEMP_TYPE);\r\ndata->temp_type[1] = (reg & 0x02) ? 2 : 4;\r\ndata->temp_type[2] = (reg & 0x04) ? 2 : 4;\r\ndata->temp_type[3] = (reg & 0x08) ? 2 : 4;\r\n}\r\nif (f71882fg_fan_has_beep[data->type])\r\ndata->fan_beep = f71882fg_read8(data,\r\nF71882FG_REG_FAN_BEEP);\r\nif (f71882fg_temp_has_beep[data->type])\r\ndata->temp_beep = f71882fg_read8(data,\r\nF71882FG_REG_TEMP_BEEP);\r\ndata->pwm_enable = f71882fg_read8(data,\r\nF71882FG_REG_PWM_ENABLE);\r\ndata->pwm_auto_point_hyst[0] =\r\nf71882fg_read8(data, F71882FG_REG_FAN_HYST(0));\r\ndata->pwm_auto_point_hyst[1] =\r\nf71882fg_read8(data, F71882FG_REG_FAN_HYST(1));\r\nfor (nr = 0; nr < nr_fans; nr++) {\r\ndata->pwm_auto_point_mapping[nr] =\r\nf71882fg_read8(data,\r\nF71882FG_REG_POINT_MAPPING(nr));\r\nswitch (data->type) {\r\ndefault:\r\nfor (point = 0; point < 5; point++) {\r\ndata->pwm_auto_point_pwm[nr][point] =\r\nf71882fg_read8(data,\r\nF71882FG_REG_POINT_PWM\r\n(nr, point));\r\n}\r\nfor (point = 0; point < 4; point++) {\r\ndata->pwm_auto_point_temp[nr][point] =\r\nf71882fg_read8(data,\r\nF71882FG_REG_POINT_TEMP\r\n(nr, point));\r\n}\r\nbreak;\r\ncase f71808e:\r\ncase f71869:\r\ndata->pwm_auto_point_pwm[nr][0] =\r\nf71882fg_read8(data,\r\nF71882FG_REG_POINT_PWM(nr, 0));\r\ncase f71862fg:\r\ndata->pwm_auto_point_pwm[nr][1] =\r\nf71882fg_read8(data,\r\nF71882FG_REG_POINT_PWM\r\n(nr, 1));\r\ndata->pwm_auto_point_pwm[nr][4] =\r\nf71882fg_read8(data,\r\nF71882FG_REG_POINT_PWM\r\n(nr, 4));\r\ndata->pwm_auto_point_temp[nr][0] =\r\nf71882fg_read8(data,\r\nF71882FG_REG_POINT_TEMP\r\n(nr, 0));\r\ndata->pwm_auto_point_temp[nr][3] =\r\nf71882fg_read8(data,\r\nF71882FG_REG_POINT_TEMP\r\n(nr, 3));\r\nbreak;\r\n}\r\n}\r\ndata->last_limits = jiffies;\r\n}\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\ndata->temp_status = f71882fg_read8(data,\r\nF71882FG_REG_TEMP_STATUS);\r\ndata->temp_diode_open = f71882fg_read8(data,\r\nF71882FG_REG_TEMP_DIODE_OPEN);\r\nfor (nr = data->temp_start; nr < nr_temps + data->temp_start;\r\nnr++)\r\ndata->temp[nr] = f71882fg_read_temp(data, nr);\r\ndata->fan_status = f71882fg_read8(data,\r\nF71882FG_REG_FAN_STATUS);\r\nfor (nr = 0; nr < nr_fans; nr++) {\r\ndata->fan[nr] = f71882fg_read16(data,\r\nF71882FG_REG_FAN(nr));\r\ndata->fan_target[nr] =\r\nf71882fg_read16(data, F71882FG_REG_FAN_TARGET(nr));\r\ndata->fan_full_speed[nr] =\r\nf71882fg_read16(data,\r\nF71882FG_REG_FAN_FULL_SPEED(nr));\r\ndata->pwm[nr] =\r\nf71882fg_read8(data, F71882FG_REG_PWM(nr));\r\n}\r\nif (data->type == f71808a) {\r\ndata->fan[2] = f71882fg_read16(data,\r\nF71882FG_REG_FAN(2));\r\ndata->pwm[2] = f71882fg_read8(data,\r\nF71882FG_REG_PWM(2));\r\n}\r\nif (data->type == f8000)\r\ndata->fan[3] = f71882fg_read16(data,\r\nF71882FG_REG_FAN(3));\r\nif (f71882fg_has_in1_alarm[data->type])\r\ndata->in_status = f71882fg_read8(data,\r\nF71882FG_REG_IN_STATUS);\r\nfor (nr = 0; nr < F71882FG_MAX_INS; nr++)\r\nif (f71882fg_has_in[data->type][nr])\r\ndata->in[nr] = f71882fg_read8(data,\r\nF71882FG_REG_IN(nr));\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nint speed = fan_from_reg(data->fan[nr]);\r\nif (speed == FAN_MIN_DETECT)\r\nspeed = 0;\r\nreturn sprintf(buf, "%d\n", speed);\r\n}\r\nstatic ssize_t show_fan_full_speed(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nint speed = fan_from_reg(data->fan_full_speed[nr]);\r\nreturn sprintf(buf, "%d\n", speed);\r\n}\r\nstatic ssize_t store_fan_full_speed(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = SENSORS_LIMIT(val, 23, 1500000);\r\nval = fan_to_reg(val);\r\nmutex_lock(&data->update_lock);\r\nf71882fg_write16(data, F71882FG_REG_FAN_FULL_SPEED(nr), val);\r\ndata->fan_full_speed[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_beep(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nif (data->fan_beep & (1 << nr))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t store_fan_beep(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nunsigned long val;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_beep = f71882fg_read8(data, F71882FG_REG_FAN_BEEP);\r\nif (val)\r\ndata->fan_beep |= 1 << nr;\r\nelse\r\ndata->fan_beep &= ~(1 << nr);\r\nf71882fg_write8(data, F71882FG_REG_FAN_BEEP, data->fan_beep);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nif (data->fan_status & (1 << nr))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nreturn sprintf(buf, "%d\n", data->in[nr] * 8);\r\n}\r\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->in1_max * 8);\r\n}\r\nstatic ssize_t store_in_max(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval /= 8;\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\nf71882fg_write8(data, F71882FG_REG_IN1_HIGH, val);\r\ndata->in1_max = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in_beep(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nif (data->in_beep & (1 << nr))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t store_in_beep(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nunsigned long val;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_beep = f71882fg_read8(data, F71882FG_REG_IN_BEEP);\r\nif (val)\r\ndata->in_beep |= 1 << nr;\r\nelse\r\ndata->in_beep &= ~(1 << nr);\r\nf71882fg_write8(data, F71882FG_REG_IN_BEEP, data->in_beep);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nif (data->in_status & (1 << nr))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nint sign, temp;\r\nif (data->type == f71858fg) {\r\nif (data->temp_config & 1) {\r\nsign = data->temp[nr] & 0x0001;\r\ntemp = (data->temp[nr] >> 5) & 0x7ff;\r\n} else {\r\nsign = data->temp[nr] & 0x8000;\r\ntemp = (data->temp[nr] >> 5) & 0x3ff;\r\n}\r\ntemp *= 125;\r\nif (sign)\r\ntemp -= 128000;\r\n} else\r\ntemp = data->temp[nr] * 1000;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nreturn sprintf(buf, "%d\n", data->temp_high[nr] * 1000);\r\n}\r\nstatic ssize_t store_temp_max(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval /= 1000;\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\nf71882fg_write8(data, F71882FG_REG_TEMP_HIGH(nr), val);\r\ndata->temp_high[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_max_hyst(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nint temp_max_hyst;\r\nmutex_lock(&data->update_lock);\r\nif (nr & 1)\r\ntemp_max_hyst = data->temp_hyst[nr / 2] >> 4;\r\nelse\r\ntemp_max_hyst = data->temp_hyst[nr / 2] & 0x0f;\r\ntemp_max_hyst = (data->temp_high[nr] - temp_max_hyst) * 1000;\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", temp_max_hyst);\r\n}\r\nstatic ssize_t store_temp_max_hyst(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nssize_t ret = count;\r\nu8 reg;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval /= 1000;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_high[nr] = f71882fg_read8(data, F71882FG_REG_TEMP_HIGH(nr));\r\nval = SENSORS_LIMIT(val, data->temp_high[nr] - 15,\r\ndata->temp_high[nr]);\r\nval = data->temp_high[nr] - val;\r\nreg = f71882fg_read8(data, F71882FG_REG_TEMP_HYST(nr / 2));\r\nif (nr & 1)\r\nreg = (reg & 0x0f) | (val << 4);\r\nelse\r\nreg = (reg & 0xf0) | val;\r\nf71882fg_write8(data, F71882FG_REG_TEMP_HYST(nr / 2), reg);\r\ndata->temp_hyst[nr / 2] = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_temp_crit(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nreturn sprintf(buf, "%d\n", data->temp_ovt[nr] * 1000);\r\n}\r\nstatic ssize_t store_temp_crit(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval /= 1000;\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\nf71882fg_write8(data, F71882FG_REG_TEMP_OVT(nr), val);\r\ndata->temp_ovt[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_crit_hyst(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nint temp_crit_hyst;\r\nmutex_lock(&data->update_lock);\r\nif (nr & 1)\r\ntemp_crit_hyst = data->temp_hyst[nr / 2] >> 4;\r\nelse\r\ntemp_crit_hyst = data->temp_hyst[nr / 2] & 0x0f;\r\ntemp_crit_hyst = (data->temp_ovt[nr] - temp_crit_hyst) * 1000;\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", temp_crit_hyst);\r\n}\r\nstatic ssize_t show_temp_type(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nreturn sprintf(buf, "%d\n", data->temp_type[nr]);\r\n}\r\nstatic ssize_t show_temp_beep(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nif (data->temp_beep & (1 << nr))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t store_temp_beep(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nunsigned long val;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_beep = f71882fg_read8(data, F71882FG_REG_TEMP_BEEP);\r\nif (val)\r\ndata->temp_beep |= 1 << nr;\r\nelse\r\ndata->temp_beep &= ~(1 << nr);\r\nf71882fg_write8(data, F71882FG_REG_TEMP_BEEP, data->temp_beep);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nif (data->temp_status & (1 << nr))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_temp_fault(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nif (data->temp_diode_open & (1 << nr))\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_pwm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint val, nr = to_sensor_dev_attr_2(devattr)->index;\r\nmutex_lock(&data->update_lock);\r\nif (data->pwm_enable & (1 << (2 * nr)))\r\nval = data->pwm[nr];\r\nelse {\r\nval = 255 * fan_from_reg(data->fan_target[nr])\r\n/ fan_from_reg(data->fan_full_speed[nr]);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t store_pwm(struct device *dev,\r\nstruct device_attribute *devattr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_enable = f71882fg_read8(data, F71882FG_REG_PWM_ENABLE);\r\nif ((data->type == f8000 && ((data->pwm_enable >> 2 * nr) & 3) != 2) ||\r\n(data->type != f8000 && !((data->pwm_enable >> 2 * nr) & 2))) {\r\ncount = -EROFS;\r\ngoto leave;\r\n}\r\nif (data->pwm_enable & (1 << (2 * nr))) {\r\nf71882fg_write8(data, F71882FG_REG_PWM(nr), val);\r\ndata->pwm[nr] = val;\r\n} else {\r\nint target, full_speed;\r\nfull_speed = f71882fg_read16(data,\r\nF71882FG_REG_FAN_FULL_SPEED(nr));\r\ntarget = fan_to_reg(val * fan_from_reg(full_speed) / 255);\r\nf71882fg_write16(data, F71882FG_REG_FAN_TARGET(nr), target);\r\ndata->fan_target[nr] = target;\r\ndata->fan_full_speed[nr] = full_speed;\r\n}\r\nleave:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_simple_pwm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint val, nr = to_sensor_dev_attr_2(devattr)->index;\r\nval = data->pwm[nr];\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t store_simple_pwm(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\nf71882fg_write8(data, F71882FG_REG_PWM(nr), val);\r\ndata->pwm[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint result = 0;\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nswitch ((data->pwm_enable >> 2 * nr) & 3) {\r\ncase 0:\r\ncase 1:\r\nresult = 2;\r\nbreak;\r\ncase 2:\r\nresult = 1;\r\nbreak;\r\ncase 3:\r\nif (data->type == f8000)\r\nresult = 3;\r\nelse\r\nresult = 1;\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%d\n", result);\r\n}\r\nstatic ssize_t store_pwm_enable(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (data->type == f8000 && nr == 2 && val != 2)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_enable = f71882fg_read8(data, F71882FG_REG_PWM_ENABLE);\r\nif (data->type == f8000 && ((data->pwm_enable >> 2 * nr) & 1)) {\r\nswitch (val) {\r\ncase 2:\r\ndata->pwm_enable &= ~(2 << (2 * nr));\r\nbreak;\r\ncase 3:\r\ndata->pwm_enable |= 2 << (2 * nr);\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\ngoto leave;\r\n}\r\n} else {\r\nswitch (val) {\r\ncase 1:\r\nif (data->type == f71858fg &&\r\n((data->pwm_enable >> (2 * nr)) & 1)) {\r\ncount = -EINVAL;\r\ngoto leave;\r\n}\r\ndata->pwm_enable |= 2 << (2 * nr);\r\nbreak;\r\ncase 2:\r\ndata->pwm_enable &= ~(2 << (2 * nr));\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\ngoto leave;\r\n}\r\n}\r\nf71882fg_write8(data, F71882FG_REG_PWM_ENABLE, data->pwm_enable);\r\nleave:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_point_pwm(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nint result;\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint pwm = to_sensor_dev_attr_2(devattr)->index;\r\nint point = to_sensor_dev_attr_2(devattr)->nr;\r\nmutex_lock(&data->update_lock);\r\nif (data->pwm_enable & (1 << (2 * pwm))) {\r\nresult = data->pwm_auto_point_pwm[pwm][point];\r\n} else {\r\nresult = 32 * 255 / (32 + data->pwm_auto_point_pwm[pwm][point]);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", result);\r\n}\r\nstatic ssize_t store_pwm_auto_point_pwm(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, pwm = to_sensor_dev_attr_2(devattr)->index;\r\nint point = to_sensor_dev_attr_2(devattr)->nr;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_enable = f71882fg_read8(data, F71882FG_REG_PWM_ENABLE);\r\nif (data->pwm_enable & (1 << (2 * pwm))) {\r\n} else {\r\nif (val < 29)\r\nval = 255;\r\nelse\r\nval = (255 - val) * 32 / val;\r\n}\r\nf71882fg_write8(data, F71882FG_REG_POINT_PWM(pwm, point), val);\r\ndata->pwm_auto_point_pwm[pwm][point] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_point_temp_hyst(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nint result = 0;\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nint point = to_sensor_dev_attr_2(devattr)->nr;\r\nmutex_lock(&data->update_lock);\r\nif (nr & 1)\r\nresult = data->pwm_auto_point_hyst[nr / 2] >> 4;\r\nelse\r\nresult = data->pwm_auto_point_hyst[nr / 2] & 0x0f;\r\nresult = 1000 * (data->pwm_auto_point_temp[nr][point] - result);\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", result);\r\n}\r\nstatic ssize_t store_pwm_auto_point_temp_hyst(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nint point = to_sensor_dev_attr_2(devattr)->nr;\r\nu8 reg;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval /= 1000;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_auto_point_temp[nr][point] =\r\nf71882fg_read8(data, F71882FG_REG_POINT_TEMP(nr, point));\r\nval = SENSORS_LIMIT(val, data->pwm_auto_point_temp[nr][point] - 15,\r\ndata->pwm_auto_point_temp[nr][point]);\r\nval = data->pwm_auto_point_temp[nr][point] - val;\r\nreg = f71882fg_read8(data, F71882FG_REG_FAN_HYST(nr / 2));\r\nif (nr & 1)\r\nreg = (reg & 0x0f) | (val << 4);\r\nelse\r\nreg = (reg & 0xf0) | val;\r\nf71882fg_write8(data, F71882FG_REG_FAN_HYST(nr / 2), reg);\r\ndata->pwm_auto_point_hyst[nr / 2] = reg;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_interpolate(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint result;\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nresult = (data->pwm_auto_point_mapping[nr] >> 4) & 1;\r\nreturn sprintf(buf, "%d\n", result);\r\n}\r\nstatic ssize_t store_pwm_interpolate(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nunsigned long val;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_auto_point_mapping[nr] =\r\nf71882fg_read8(data, F71882FG_REG_POINT_MAPPING(nr));\r\nif (val)\r\nval = data->pwm_auto_point_mapping[nr] | (1 << 4);\r\nelse\r\nval = data->pwm_auto_point_mapping[nr] & (~(1 << 4));\r\nf71882fg_write8(data, F71882FG_REG_POINT_MAPPING(nr), val);\r\ndata->pwm_auto_point_mapping[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_point_channel(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nint result;\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint nr = to_sensor_dev_attr_2(devattr)->index;\r\nresult = 1 << ((data->pwm_auto_point_mapping[nr] & 3) -\r\ndata->temp_start);\r\nreturn sprintf(buf, "%d\n", result);\r\n}\r\nstatic ssize_t store_pwm_auto_point_channel(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, nr = to_sensor_dev_attr_2(devattr)->index;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nswitch (val) {\r\ncase 1:\r\nval = 0;\r\nbreak;\r\ncase 2:\r\nval = 1;\r\nbreak;\r\ncase 4:\r\nval = 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval += data->temp_start;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_auto_point_mapping[nr] =\r\nf71882fg_read8(data, F71882FG_REG_POINT_MAPPING(nr));\r\nval = (data->pwm_auto_point_mapping[nr] & 0xfc) | val;\r\nf71882fg_write8(data, F71882FG_REG_POINT_MAPPING(nr), val);\r\ndata->pwm_auto_point_mapping[nr] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_point_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nint result;\r\nstruct f71882fg_data *data = f71882fg_update_device(dev);\r\nint pwm = to_sensor_dev_attr_2(devattr)->index;\r\nint point = to_sensor_dev_attr_2(devattr)->nr;\r\nresult = data->pwm_auto_point_temp[pwm][point];\r\nreturn sprintf(buf, "%d\n", 1000 * result);\r\n}\r\nstatic ssize_t store_pwm_auto_point_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nint err, pwm = to_sensor_dev_attr_2(devattr)->index;\r\nint point = to_sensor_dev_attr_2(devattr)->nr;\r\nlong val;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval /= 1000;\r\nif (data->auto_point_temp_signed)\r\nval = SENSORS_LIMIT(val, -128, 127);\r\nelse\r\nval = SENSORS_LIMIT(val, 0, 127);\r\nmutex_lock(&data->update_lock);\r\nf71882fg_write8(data, F71882FG_REG_POINT_TEMP(pwm, point), val);\r\ndata->pwm_auto_point_temp[pwm][point] = val;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71882fg_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", f71882fg_names[data->type]);\r\n}\r\nstatic int __devinit f71882fg_create_sysfs_files(struct platform_device *pdev,\r\nstruct sensor_device_attribute_2 *attr, int count)\r\n{\r\nint err, i;\r\nfor (i = 0; i < count; i++) {\r\nerr = device_create_file(&pdev->dev, &attr[i].dev_attr);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void f71882fg_remove_sysfs_files(struct platform_device *pdev,\r\nstruct sensor_device_attribute_2 *attr, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\ndevice_remove_file(&pdev->dev, &attr[i].dev_attr);\r\n}\r\nstatic int __devinit f71882fg_create_fan_sysfs_files(\r\nstruct platform_device *pdev, int idx)\r\n{\r\nstruct f71882fg_data *data = platform_get_drvdata(pdev);\r\nint err;\r\nerr = 0;\r\nswitch (data->type) {\r\ncase f71858fg:\r\nif (((data->pwm_enable >> (idx * 2)) & 3) == 3)\r\nerr = 1;\r\nbreak;\r\ncase f71862fg:\r\nif (((data->pwm_enable >> (idx * 2)) & 1) != 1)\r\nerr = 1;\r\nbreak;\r\ncase f8000:\r\nif (idx == 2)\r\nerr = data->pwm_enable & 0x20;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Invalid (reserved) pwm settings: 0x%02x, "\r\n"skipping fan %d\n",\r\n(data->pwm_enable >> (idx * 2)) & 3, idx + 1);\r\nreturn 0;\r\n}\r\nerr = f71882fg_create_sysfs_files(pdev, &fxxxx_fan_attr[idx][0],\r\nARRAY_SIZE(fxxxx_fan_attr[0]));\r\nif (err)\r\nreturn err;\r\nif (f71882fg_fan_has_beep[data->type]) {\r\nerr = f71882fg_create_sysfs_files(pdev,\r\n&fxxxx_fan_beep_attr[idx],\r\n1);\r\nif (err)\r\nreturn err;\r\n}\r\ndev_info(&pdev->dev, "Fan: %d is in %s mode\n", idx + 1,\r\n(data->pwm_enable & (1 << (2 * idx))) ? "duty-cycle" : "RPM");\r\nswitch (data->type) {\r\ncase f71808e:\r\ncase f71808a:\r\ncase f71869:\r\ncase f71869a:\r\ncase f71889fg:\r\ncase f71889ed:\r\ncase f71889a:\r\ndata->pwm_auto_point_mapping[idx] =\r\nf71882fg_read8(data, F71882FG_REG_POINT_MAPPING(idx));\r\nif ((data->pwm_auto_point_mapping[idx] & 0x80) ||\r\n(data->pwm_auto_point_mapping[idx] & 3) == 0) {\r\ndev_warn(&pdev->dev,\r\n"Auto pwm controlled by raw digital "\r\n"data, disabling pwm auto_point "\r\n"sysfs attributes for fan %d\n", idx + 1);\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (data->type) {\r\ncase f71862fg:\r\nerr = f71882fg_create_sysfs_files(pdev,\r\n&f71862fg_auto_pwm_attr[idx][0],\r\nARRAY_SIZE(f71862fg_auto_pwm_attr[0]));\r\nbreak;\r\ncase f71808e:\r\ncase f71869:\r\nerr = f71882fg_create_sysfs_files(pdev,\r\n&f71869_auto_pwm_attr[idx][0],\r\nARRAY_SIZE(f71869_auto_pwm_attr[0]));\r\nbreak;\r\ncase f8000:\r\nerr = f71882fg_create_sysfs_files(pdev,\r\n&f8000_auto_pwm_attr[idx][0],\r\nARRAY_SIZE(f8000_auto_pwm_attr[0]));\r\nbreak;\r\ndefault:\r\nerr = f71882fg_create_sysfs_files(pdev,\r\n&fxxxx_auto_pwm_attr[idx][0],\r\nARRAY_SIZE(fxxxx_auto_pwm_attr[0]));\r\n}\r\nreturn err;\r\n}\r\nstatic int __devinit f71882fg_probe(struct platform_device *pdev)\r\n{\r\nstruct f71882fg_data *data;\r\nstruct f71882fg_sio_data *sio_data = pdev->dev.platform_data;\r\nint nr_fans = f71882fg_nr_fans[sio_data->type];\r\nint nr_temps = f71882fg_nr_temps[sio_data->type];\r\nint err, i;\r\nu8 start_reg, reg;\r\ndata = kzalloc(sizeof(struct f71882fg_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->addr = platform_get_resource(pdev, IORESOURCE_IO, 0)->start;\r\ndata->type = sio_data->type;\r\ndata->temp_start =\r\n(data->type == f71858fg || data->type == f8000) ? 0 : 1;\r\nmutex_init(&data->update_lock);\r\nplatform_set_drvdata(pdev, data);\r\nstart_reg = f71882fg_read8(data, F71882FG_REG_START);\r\nif (start_reg & 0x04) {\r\ndev_warn(&pdev->dev, "Hardware monitor is powered down\n");\r\nerr = -ENODEV;\r\ngoto exit_free;\r\n}\r\nif (!(start_reg & 0x03)) {\r\ndev_warn(&pdev->dev, "Hardware monitoring not activated\n");\r\nerr = -ENODEV;\r\ngoto exit_free;\r\n}\r\nerr = device_create_file(&pdev->dev, &dev_attr_name);\r\nif (err)\r\ngoto exit_unregister_sysfs;\r\nif (start_reg & 0x01) {\r\nswitch (data->type) {\r\ncase f71858fg:\r\ndata->temp_config =\r\nf71882fg_read8(data, F71882FG_REG_TEMP_CONFIG);\r\nif (data->temp_config & 0x10)\r\nerr = f71882fg_create_sysfs_files(pdev,\r\nf8000_temp_attr,\r\nARRAY_SIZE(f8000_temp_attr));\r\nelse\r\nerr = f71882fg_create_sysfs_files(pdev,\r\nf71858fg_temp_attr,\r\nARRAY_SIZE(f71858fg_temp_attr));\r\nbreak;\r\ncase f8000:\r\nerr = f71882fg_create_sysfs_files(pdev,\r\nf8000_temp_attr,\r\nARRAY_SIZE(f8000_temp_attr));\r\nbreak;\r\ndefault:\r\nerr = f71882fg_create_sysfs_files(pdev,\r\n&fxxxx_temp_attr[0][0],\r\nARRAY_SIZE(fxxxx_temp_attr[0]) * nr_temps);\r\n}\r\nif (err)\r\ngoto exit_unregister_sysfs;\r\nif (f71882fg_temp_has_beep[data->type]) {\r\nerr = f71882fg_create_sysfs_files(pdev,\r\n&fxxxx_temp_beep_attr[0][0],\r\nARRAY_SIZE(fxxxx_temp_beep_attr[0])\r\n* nr_temps);\r\nif (err)\r\ngoto exit_unregister_sysfs;\r\n}\r\nfor (i = 0; i < F71882FG_MAX_INS; i++) {\r\nif (f71882fg_has_in[data->type][i]) {\r\nerr = device_create_file(&pdev->dev,\r\n&fxxxx_in_attr[i].dev_attr);\r\nif (err)\r\ngoto exit_unregister_sysfs;\r\n}\r\n}\r\nif (f71882fg_has_in1_alarm[data->type]) {\r\nerr = f71882fg_create_sysfs_files(pdev,\r\nfxxxx_in1_alarm_attr,\r\nARRAY_SIZE(fxxxx_in1_alarm_attr));\r\nif (err)\r\ngoto exit_unregister_sysfs;\r\n}\r\n}\r\nif (start_reg & 0x02) {\r\nswitch (data->type) {\r\ncase f71808e:\r\ncase f71808a:\r\ncase f71869:\r\ncase f71869a:\r\ndata->auto_point_temp_signed = 1;\r\ncase f71889fg:\r\ncase f71889ed:\r\ncase f71889a:\r\nreg = f71882fg_read8(data, F71882FG_REG_FAN_FAULT_T);\r\nif (reg & F71882FG_FAN_NEG_TEMP_EN)\r\ndata->auto_point_temp_signed = 1;\r\nreg &= ~F71882FG_FAN_PROG_SEL;\r\nf71882fg_write8(data, F71882FG_REG_FAN_FAULT_T, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndata->pwm_enable =\r\nf71882fg_read8(data, F71882FG_REG_PWM_ENABLE);\r\nfor (i = 0; i < nr_fans; i++) {\r\nerr = f71882fg_create_fan_sysfs_files(pdev, i);\r\nif (err)\r\ngoto exit_unregister_sysfs;\r\n}\r\nswitch (data->type) {\r\ncase f71808a:\r\nerr = f71882fg_create_sysfs_files(pdev,\r\nf71808a_fan3_attr,\r\nARRAY_SIZE(f71808a_fan3_attr));\r\nbreak;\r\ncase f8000:\r\nerr = f71882fg_create_sysfs_files(pdev,\r\nf8000_fan_attr,\r\nARRAY_SIZE(f8000_fan_attr));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\ngoto exit_unregister_sysfs;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndata->hwmon_dev = NULL;\r\ngoto exit_unregister_sysfs;\r\n}\r\nreturn 0;\r\nexit_unregister_sysfs:\r\nf71882fg_remove(pdev);\r\nreturn err;\r\nexit_free:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int f71882fg_remove(struct platform_device *pdev)\r\n{\r\nstruct f71882fg_data *data = platform_get_drvdata(pdev);\r\nint nr_fans = f71882fg_nr_fans[data->type];\r\nint nr_temps = f71882fg_nr_temps[data->type];\r\nint i;\r\nu8 start_reg = f71882fg_read8(data, F71882FG_REG_START);\r\nif (data->hwmon_dev)\r\nhwmon_device_unregister(data->hwmon_dev);\r\ndevice_remove_file(&pdev->dev, &dev_attr_name);\r\nif (start_reg & 0x01) {\r\nswitch (data->type) {\r\ncase f71858fg:\r\nif (data->temp_config & 0x10)\r\nf71882fg_remove_sysfs_files(pdev,\r\nf8000_temp_attr,\r\nARRAY_SIZE(f8000_temp_attr));\r\nelse\r\nf71882fg_remove_sysfs_files(pdev,\r\nf71858fg_temp_attr,\r\nARRAY_SIZE(f71858fg_temp_attr));\r\nbreak;\r\ncase f8000:\r\nf71882fg_remove_sysfs_files(pdev,\r\nf8000_temp_attr,\r\nARRAY_SIZE(f8000_temp_attr));\r\nbreak;\r\ndefault:\r\nf71882fg_remove_sysfs_files(pdev,\r\n&fxxxx_temp_attr[0][0],\r\nARRAY_SIZE(fxxxx_temp_attr[0]) * nr_temps);\r\n}\r\nif (f71882fg_temp_has_beep[data->type]) {\r\nf71882fg_remove_sysfs_files(pdev,\r\n&fxxxx_temp_beep_attr[0][0],\r\nARRAY_SIZE(fxxxx_temp_beep_attr[0]) * nr_temps);\r\n}\r\nfor (i = 0; i < F71882FG_MAX_INS; i++) {\r\nif (f71882fg_has_in[data->type][i]) {\r\ndevice_remove_file(&pdev->dev,\r\n&fxxxx_in_attr[i].dev_attr);\r\n}\r\n}\r\nif (f71882fg_has_in1_alarm[data->type]) {\r\nf71882fg_remove_sysfs_files(pdev,\r\nfxxxx_in1_alarm_attr,\r\nARRAY_SIZE(fxxxx_in1_alarm_attr));\r\n}\r\n}\r\nif (start_reg & 0x02) {\r\nf71882fg_remove_sysfs_files(pdev, &fxxxx_fan_attr[0][0],\r\nARRAY_SIZE(fxxxx_fan_attr[0]) * nr_fans);\r\nif (f71882fg_fan_has_beep[data->type]) {\r\nf71882fg_remove_sysfs_files(pdev,\r\nfxxxx_fan_beep_attr, nr_fans);\r\n}\r\nswitch (data->type) {\r\ncase f71808a:\r\nf71882fg_remove_sysfs_files(pdev,\r\n&fxxxx_auto_pwm_attr[0][0],\r\nARRAY_SIZE(fxxxx_auto_pwm_attr[0]) * nr_fans);\r\nf71882fg_remove_sysfs_files(pdev,\r\nf71808a_fan3_attr,\r\nARRAY_SIZE(f71808a_fan3_attr));\r\nbreak;\r\ncase f71862fg:\r\nf71882fg_remove_sysfs_files(pdev,\r\n&f71862fg_auto_pwm_attr[0][0],\r\nARRAY_SIZE(f71862fg_auto_pwm_attr[0]) *\r\nnr_fans);\r\nbreak;\r\ncase f71808e:\r\ncase f71869:\r\nf71882fg_remove_sysfs_files(pdev,\r\n&f71869_auto_pwm_attr[0][0],\r\nARRAY_SIZE(f71869_auto_pwm_attr[0]) * nr_fans);\r\nbreak;\r\ncase f8000:\r\nf71882fg_remove_sysfs_files(pdev,\r\nf8000_fan_attr,\r\nARRAY_SIZE(f8000_fan_attr));\r\nf71882fg_remove_sysfs_files(pdev,\r\n&f8000_auto_pwm_attr[0][0],\r\nARRAY_SIZE(f8000_auto_pwm_attr[0]) * nr_fans);\r\nbreak;\r\ndefault:\r\nf71882fg_remove_sysfs_files(pdev,\r\n&fxxxx_auto_pwm_attr[0][0],\r\nARRAY_SIZE(fxxxx_auto_pwm_attr[0]) * nr_fans);\r\n}\r\n}\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init f71882fg_find(int sioaddr, unsigned short *address,\r\nstruct f71882fg_sio_data *sio_data)\r\n{\r\nu16 devid;\r\nint err = superio_enter(sioaddr);\r\nif (err)\r\nreturn err;\r\ndevid = superio_inw(sioaddr, SIO_REG_MANID);\r\nif (devid != SIO_FINTEK_ID) {\r\npr_debug("Not a Fintek device\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ndevid = force_id ? force_id : superio_inw(sioaddr, SIO_REG_DEVID);\r\nswitch (devid) {\r\ncase SIO_F71808E_ID:\r\nsio_data->type = f71808e;\r\nbreak;\r\ncase SIO_F71808A_ID:\r\nsio_data->type = f71808a;\r\nbreak;\r\ncase SIO_F71858_ID:\r\nsio_data->type = f71858fg;\r\nbreak;\r\ncase SIO_F71862_ID:\r\nsio_data->type = f71862fg;\r\nbreak;\r\ncase SIO_F71869_ID:\r\nsio_data->type = f71869;\r\nbreak;\r\ncase SIO_F71869A_ID:\r\nsio_data->type = f71869a;\r\nbreak;\r\ncase SIO_F71882_ID:\r\nsio_data->type = f71882fg;\r\nbreak;\r\ncase SIO_F71889_ID:\r\nsio_data->type = f71889fg;\r\nbreak;\r\ncase SIO_F71889E_ID:\r\nsio_data->type = f71889ed;\r\nbreak;\r\ncase SIO_F71889A_ID:\r\nsio_data->type = f71889a;\r\nbreak;\r\ncase SIO_F8000_ID:\r\nsio_data->type = f8000;\r\nbreak;\r\ncase SIO_F81865_ID:\r\nsio_data->type = f81865f;\r\nbreak;\r\ndefault:\r\npr_info("Unsupported Fintek device: %04x\n",\r\n(unsigned int)devid);\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nif (sio_data->type == f71858fg)\r\nsuperio_select(sioaddr, SIO_F71858FG_LD_HWM);\r\nelse\r\nsuperio_select(sioaddr, SIO_F71882FG_LD_HWM);\r\nif (!(superio_inb(sioaddr, SIO_REG_ENABLE) & 0x01)) {\r\npr_warn("Device not activated\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\n*address = superio_inw(sioaddr, SIO_REG_ADDR);\r\nif (*address == 0) {\r\npr_warn("Base address not set\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\n*address &= ~(REGION_LENGTH - 1);\r\nerr = 0;\r\npr_info("Found %s chip at %#x, revision %d\n",\r\nf71882fg_names[sio_data->type], (unsigned int)*address,\r\n(int)superio_inb(sioaddr, SIO_REG_DEVREV));\r\nexit:\r\nsuperio_exit(sioaddr);\r\nreturn err;\r\n}\r\nstatic int __init f71882fg_device_add(unsigned short address,\r\nconst struct f71882fg_sio_data *sio_data)\r\n{\r\nstruct resource res = {\r\n.start = address,\r\n.end = address + REGION_LENGTH - 1,\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\nf71882fg_pdev = platform_device_alloc(DRVNAME, address);\r\nif (!f71882fg_pdev)\r\nreturn -ENOMEM;\r\nres.name = f71882fg_pdev->name;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err)\r\ngoto exit_device_put;\r\nerr = platform_device_add_resources(f71882fg_pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed\n");\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add_data(f71882fg_pdev, sio_data,\r\nsizeof(struct f71882fg_sio_data));\r\nif (err) {\r\npr_err("Platform data allocation failed\n");\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(f71882fg_pdev);\r\nif (err) {\r\npr_err("Device addition failed\n");\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(f71882fg_pdev);\r\nreturn err;\r\n}\r\nstatic int __init f71882fg_init(void)\r\n{\r\nint err = -ENODEV;\r\nunsigned short address;\r\nstruct f71882fg_sio_data sio_data;\r\nmemset(&sio_data, 0, sizeof(sio_data));\r\nif (f71882fg_find(0x2e, &address, &sio_data) &&\r\nf71882fg_find(0x4e, &address, &sio_data))\r\ngoto exit;\r\nerr = platform_driver_register(&f71882fg_driver);\r\nif (err)\r\ngoto exit;\r\nerr = f71882fg_device_add(address, &sio_data);\r\nif (err)\r\ngoto exit_driver;\r\nreturn 0;\r\nexit_driver:\r\nplatform_driver_unregister(&f71882fg_driver);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __exit f71882fg_exit(void)\r\n{\r\nplatform_device_unregister(f71882fg_pdev);\r\nplatform_driver_unregister(&f71882fg_driver);\r\n}
