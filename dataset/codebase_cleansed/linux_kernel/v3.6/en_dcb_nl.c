static int mlx4_en_dcbnl_ieee_getets(struct net_device *dev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct ieee_ets *my_ets = &priv->ets;\r\nif (!my_ets)\r\nreturn -EINVAL;\r\nets->ets_cap = IEEE_8021QAZ_MAX_TCS;\r\nets->cbs = my_ets->cbs;\r\nmemcpy(ets->tc_tx_bw, my_ets->tc_tx_bw, sizeof(ets->tc_tx_bw));\r\nmemcpy(ets->tc_tsa, my_ets->tc_tsa, sizeof(ets->tc_tsa));\r\nmemcpy(ets->prio_tc, my_ets->prio_tc, sizeof(ets->prio_tc));\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_ets_validate(struct mlx4_en_priv *priv, struct ieee_ets *ets)\r\n{\r\nint i;\r\nint total_ets_bw = 0;\r\nint has_ets_tc = 0;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nif (ets->prio_tc[i] > MLX4_EN_NUM_UP) {\r\nen_err(priv, "Bad priority in UP <=> TC mapping. TC: %d, UP: %d\n",\r\ni, ets->prio_tc[i]);\r\nreturn -EINVAL;\r\n}\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\nhas_ets_tc = 1;\r\ntotal_ets_bw += ets->tc_tx_bw[i];\r\nbreak;\r\ndefault:\r\nen_err(priv, "TC[%d]: Not supported TSA: %d\n",\r\ni, ets->tc_tsa[i]);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nif (has_ets_tc && total_ets_bw != MLX4_EN_BW_MAX) {\r\nen_err(priv, "Bad ETS BW sum: %d. Should be exactly 100%%\n",\r\ntotal_ets_bw);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_config_port_scheduler(struct mlx4_en_priv *priv,\r\nstruct ieee_ets *ets, u16 *ratelimit)\r\n{\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint num_strict = 0;\r\nint i;\r\n__u8 tc_tx_bw[IEEE_8021QAZ_MAX_TCS] = { 0 };\r\n__u8 pg[IEEE_8021QAZ_MAX_TCS] = { 0 };\r\nets = ets ?: &priv->ets;\r\nratelimit = ratelimit ?: priv->maxrate;\r\nfor (i = IEEE_8021QAZ_MAX_TCS - 1; i >= 0; i--) {\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\npg[i] = num_strict++;\r\ntc_tx_bw[i] = MLX4_EN_BW_MAX;\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\npg[i] = MLX4_EN_TC_ETS;\r\ntc_tx_bw[i] = ets->tc_tx_bw[i] ?: MLX4_EN_BW_MIN;\r\nbreak;\r\n}\r\n}\r\nreturn mlx4_SET_PORT_SCHEDULER(mdev->dev, priv->port, tc_tx_bw, pg,\r\nratelimit);\r\n}\r\nstatic int\r\nmlx4_en_dcbnl_ieee_setets(struct net_device *dev, struct ieee_ets *ets)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err;\r\nerr = mlx4_en_ets_validate(priv, ets);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_SET_PORT_PRIO2TC(mdev->dev, priv->port, ets->prio_tc);\r\nif (err)\r\nreturn err;\r\nerr = mlx4_en_config_port_scheduler(priv, ets, NULL);\r\nif (err)\r\nreturn err;\r\nmemcpy(&priv->ets, ets, sizeof(priv->ets));\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_getpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\npfc->pfc_cap = IEEE_8021QAZ_MAX_TCS;\r\npfc->pfc_en = priv->prof->tx_ppp;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_setpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err;\r\nen_dbg(DRV, priv, "cap: 0x%x en: 0x%x mbc: 0x%x delay: %d\n",\r\npfc->pfc_cap,\r\npfc->pfc_en,\r\npfc->mbc,\r\npfc->delay);\r\npriv->prof->rx_pause = priv->prof->tx_pause = !!pfc->pfc_en;\r\npriv->prof->rx_ppp = priv->prof->tx_ppp = pfc->pfc_en;\r\nerr = mlx4_SET_PORT_general(mdev->dev, priv->port,\r\npriv->rx_skb_size + ETH_FCS_LEN,\r\npriv->prof->tx_pause,\r\npriv->prof->tx_ppp,\r\npriv->prof->rx_pause,\r\npriv->prof->rx_ppp);\r\nif (err)\r\nen_err(priv, "Failed setting pause params\n");\r\nreturn err;\r\n}\r\nstatic u8 mlx4_en_dcbnl_getdcbx(struct net_device *dev)\r\n{\r\nreturn DCB_CAP_DCBX_VER_IEEE;\r\n}\r\nstatic u8 mlx4_en_dcbnl_setdcbx(struct net_device *dev, u8 mode)\r\n{\r\nif ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||\r\n(mode & DCB_CAP_DCBX_VER_CEE) ||\r\n!(mode & DCB_CAP_DCBX_VER_IEEE) ||\r\n!(mode & DCB_CAP_DCBX_HOST))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_getmaxrate(struct net_device *dev,\r\nstruct ieee_maxrate *maxrate)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint i;\r\nif (!priv->maxrate)\r\nreturn -EINVAL;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\r\nmaxrate->tc_maxrate[i] =\r\npriv->maxrate[i] * MLX4_RATELIMIT_UNITS_IN_KB;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_dcbnl_ieee_setmaxrate(struct net_device *dev,\r\nstruct ieee_maxrate *maxrate)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nu16 tmp[IEEE_8021QAZ_MAX_TCS];\r\nint i, err;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\ntmp[i] = div_u64(maxrate->tc_maxrate[i] +\r\nMLX4_RATELIMIT_UNITS_IN_KB - 1,\r\nMLX4_RATELIMIT_UNITS_IN_KB);\r\n}\r\nerr = mlx4_en_config_port_scheduler(priv, NULL, tmp);\r\nif (err)\r\nreturn err;\r\nmemcpy(priv->maxrate, tmp, sizeof(*priv->maxrate));\r\nreturn 0;\r\n}
