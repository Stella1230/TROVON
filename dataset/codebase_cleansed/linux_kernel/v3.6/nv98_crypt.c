static int\r\nnv98_crypt_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv98_crypt_priv *priv = nv_engine(dev, engine);\r\nstruct nv98_crypt_chan *cctx;\r\nint ret;\r\ncctx = chan->engctx[engine] = kzalloc(sizeof(*cctx), GFP_KERNEL);\r\nif (!cctx)\r\nreturn -ENOMEM;\r\natomic_inc(&chan->vm->engref[engine]);\r\nret = nouveau_gpuobj_new(dev, chan, 256, 0, NVOBJ_FLAG_ZERO_ALLOC |\r\nNVOBJ_FLAG_ZERO_FREE, &cctx->mem);\r\nif (ret)\r\ngoto error;\r\nnv_wo32(chan->ramin, 0xa0, 0x00190000);\r\nnv_wo32(chan->ramin, 0xa4, cctx->mem->vinst + cctx->mem->size - 1);\r\nnv_wo32(chan->ramin, 0xa8, cctx->mem->vinst);\r\nnv_wo32(chan->ramin, 0xac, 0x00000000);\r\nnv_wo32(chan->ramin, 0xb0, 0x00000000);\r\nnv_wo32(chan->ramin, 0xb4, 0x00000000);\r\ndev_priv->engine.instmem.flush(dev);\r\nerror:\r\nif (ret)\r\npriv->base.context_del(chan, engine);\r\nreturn ret;\r\n}\r\nstatic void\r\nnv98_crypt_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nv98_crypt_chan *cctx = chan->engctx[engine];\r\nint i;\r\nfor (i = 0xa0; i < 0xb4; i += 4)\r\nnv_wo32(chan->ramin, i, 0x00000000);\r\nnouveau_gpuobj_ref(NULL, &cctx->mem);\r\natomic_dec(&chan->vm->engref[engine]);\r\nchan->engctx[engine] = NULL;\r\nkfree(cctx);\r\n}\r\nstatic int\r\nnv98_crypt_object_new(struct nouveau_channel *chan, int engine,\r\nu32 handle, u16 class)\r\n{\r\nstruct nv98_crypt_chan *cctx = chan->engctx[engine];\r\ncctx->mem->engine = 5;\r\ncctx->mem->class = class;\r\nreturn nouveau_ramht_insert(chan, handle, cctx->mem);\r\n}\r\nstatic void\r\nnv98_crypt_tlb_flush(struct drm_device *dev, int engine)\r\n{\r\nnv50_vm_flush_engine(dev, 0x0a);\r\n}\r\nstatic int\r\nnv98_crypt_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nnv_mask(dev, 0x000200, 0x00004000, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv98_crypt_init(struct drm_device *dev, int engine)\r\n{\r\nint i;\r\nnv_mask(dev, 0x000200, 0x00004000, 0x00000000);\r\nnv_mask(dev, 0x000200, 0x00004000, 0x00004000);\r\nnv_wait(dev, 0x087008, 0x00000010, 0x00000010);\r\nnv_wr32(dev, 0x087004, 0x00000010);\r\nnv_wr32(dev, 0x087ff8, 0x00100000);\r\nfor (i = 0; i < ARRAY_SIZE(nv98_pcrypt_code); i++)\r\nnv_wr32(dev, 0x087ff4, nv98_pcrypt_code[i]);\r\nnv_wr32(dev, 0x087ff8, 0x00000000);\r\nfor (i = 0; i < ARRAY_SIZE(nv98_pcrypt_data); i++)\r\nnv_wr32(dev, 0x087ff4, nv98_pcrypt_data[i]);\r\nnv_wr32(dev, 0x08710c, 0x00000000);\r\nnv_wr32(dev, 0x087104, 0x00000000);\r\nnv_wr32(dev, 0x087100, 0x00000002);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv98_crypt_isr(struct drm_device *dev)\r\n{\r\nu32 disp = nv_rd32(dev, 0x08701c);\r\nu32 stat = nv_rd32(dev, 0x087008) & disp & ~(disp >> 16);\r\nu32 inst = nv_rd32(dev, 0x087050) & 0x3fffffff;\r\nu32 ssta = nv_rd32(dev, 0x087040) & 0x0000ffff;\r\nu32 addr = nv_rd32(dev, 0x087040) >> 16;\r\nu32 mthd = (addr & 0x07ff) << 2;\r\nu32 subc = (addr & 0x3800) >> 11;\r\nu32 data = nv_rd32(dev, 0x087044);\r\nint chid = nv50_graph_isr_chid(dev, inst);\r\nif (stat & 0x00000040) {\r\nNV_INFO(dev, "PCRYPT: DISPATCH_ERROR [");\r\nnouveau_enum_print(nv98_crypt_isr_error_name, ssta);\r\nprintk("] ch %d [0x%08x] subc %d mthd 0x%04x data 0x%08x\n",\r\nchid, inst, subc, mthd, data);\r\nnv_wr32(dev, 0x087004, 0x00000040);\r\nstat &= ~0x00000040;\r\n}\r\nif (stat) {\r\nNV_INFO(dev, "PCRYPT: unhandled intr 0x%08x\n", stat);\r\nnv_wr32(dev, 0x087004, stat);\r\n}\r\nnv50_fb_vm_trap(dev, 1);\r\n}\r\nstatic void\r\nnv98_crypt_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nv98_crypt_priv *priv = nv_engine(dev, engine);\r\nnouveau_irq_unregister(dev, 14);\r\nNVOBJ_ENGINE_DEL(dev, CRYPT);\r\nkfree(priv);\r\n}\r\nint\r\nnv98_crypt_create(struct drm_device *dev)\r\n{\r\nstruct nv98_crypt_priv *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.destroy = nv98_crypt_destroy;\r\npriv->base.init = nv98_crypt_init;\r\npriv->base.fini = nv98_crypt_fini;\r\npriv->base.context_new = nv98_crypt_context_new;\r\npriv->base.context_del = nv98_crypt_context_del;\r\npriv->base.object_new = nv98_crypt_object_new;\r\npriv->base.tlb_flush = nv98_crypt_tlb_flush;\r\nnouveau_irq_register(dev, 14, nv98_crypt_isr);\r\nNVOBJ_ENGINE_ADD(dev, CRYPT, &priv->base);\r\nNVOBJ_CLASS(dev, 0x88b4, CRYPT);\r\nreturn 0;\r\n}
