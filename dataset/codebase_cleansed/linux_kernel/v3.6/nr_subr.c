void nr_clear_queues(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nskb_queue_purge(&sk->sk_write_queue);\r\nskb_queue_purge(&nr->ack_queue);\r\nskb_queue_purge(&nr->reseq_queue);\r\nskb_queue_purge(&nr->frag_queue);\r\n}\r\nvoid nr_frames_acked(struct sock *sk, unsigned short nr)\r\n{\r\nstruct nr_sock *nrom = nr_sk(sk);\r\nstruct sk_buff *skb;\r\nif (nrom->va != nr) {\r\nwhile (skb_peek(&nrom->ack_queue) != NULL && nrom->va != nr) {\r\nskb = skb_dequeue(&nrom->ack_queue);\r\nkfree_skb(skb);\r\nnrom->va = (nrom->va + 1) % NR_MODULUS;\r\n}\r\n}\r\n}\r\nvoid nr_requeue_frames(struct sock *sk)\r\n{\r\nstruct sk_buff *skb, *skb_prev = NULL;\r\nwhile ((skb = skb_dequeue(&nr_sk(sk)->ack_queue)) != NULL) {\r\nif (skb_prev == NULL)\r\nskb_queue_head(&sk->sk_write_queue, skb);\r\nelse\r\nskb_append(skb_prev, skb, &sk->sk_write_queue);\r\nskb_prev = skb;\r\n}\r\n}\r\nint nr_validate_nr(struct sock *sk, unsigned short nr)\r\n{\r\nstruct nr_sock *nrom = nr_sk(sk);\r\nunsigned short vc = nrom->va;\r\nwhile (vc != nrom->vs) {\r\nif (nr == vc) return 1;\r\nvc = (vc + 1) % NR_MODULUS;\r\n}\r\nreturn nr == nrom->vs;\r\n}\r\nint nr_in_rx_window(struct sock *sk, unsigned short ns)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nunsigned short vc = nr->vr;\r\nunsigned short vt = (nr->vl + nr->window) % NR_MODULUS;\r\nwhile (vc != vt) {\r\nif (ns == vc) return 1;\r\nvc = (vc + 1) % NR_MODULUS;\r\n}\r\nreturn 0;\r\n}\r\nvoid nr_write_internal(struct sock *sk, int frametype)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nstruct sk_buff *skb;\r\nunsigned char *dptr;\r\nint len, timeout;\r\nlen = NR_NETWORK_LEN + NR_TRANSPORT_LEN;\r\nswitch (frametype & 0x0F) {\r\ncase NR_CONNREQ:\r\nlen += 17;\r\nbreak;\r\ncase NR_CONNACK:\r\nlen += (nr->bpqext) ? 2 : 1;\r\nbreak;\r\ncase NR_DISCREQ:\r\ncase NR_DISCACK:\r\ncase NR_INFOACK:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "NET/ROM: nr_write_internal - invalid frame type %d\n", frametype);\r\nreturn;\r\n}\r\nif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skb, NR_NETWORK_LEN);\r\ndptr = skb_put(skb, skb_tailroom(skb));\r\nswitch (frametype & 0x0F) {\r\ncase NR_CONNREQ:\r\ntimeout = nr->t1 / HZ;\r\n*dptr++ = nr->my_index;\r\n*dptr++ = nr->my_id;\r\n*dptr++ = 0;\r\n*dptr++ = 0;\r\n*dptr++ = frametype;\r\n*dptr++ = nr->window;\r\nmemcpy(dptr, &nr->user_addr, AX25_ADDR_LEN);\r\ndptr[6] &= ~AX25_CBIT;\r\ndptr[6] &= ~AX25_EBIT;\r\ndptr[6] |= AX25_SSSID_SPARE;\r\ndptr += AX25_ADDR_LEN;\r\nmemcpy(dptr, &nr->source_addr, AX25_ADDR_LEN);\r\ndptr[6] &= ~AX25_CBIT;\r\ndptr[6] &= ~AX25_EBIT;\r\ndptr[6] |= AX25_SSSID_SPARE;\r\ndptr += AX25_ADDR_LEN;\r\n*dptr++ = timeout % 256;\r\n*dptr++ = timeout / 256;\r\nbreak;\r\ncase NR_CONNACK:\r\n*dptr++ = nr->your_index;\r\n*dptr++ = nr->your_id;\r\n*dptr++ = nr->my_index;\r\n*dptr++ = nr->my_id;\r\n*dptr++ = frametype;\r\n*dptr++ = nr->window;\r\nif (nr->bpqext) *dptr++ = sysctl_netrom_network_ttl_initialiser;\r\nbreak;\r\ncase NR_DISCREQ:\r\ncase NR_DISCACK:\r\n*dptr++ = nr->your_index;\r\n*dptr++ = nr->your_id;\r\n*dptr++ = 0;\r\n*dptr++ = 0;\r\n*dptr++ = frametype;\r\nbreak;\r\ncase NR_INFOACK:\r\n*dptr++ = nr->your_index;\r\n*dptr++ = nr->your_id;\r\n*dptr++ = 0;\r\n*dptr++ = nr->vr;\r\n*dptr++ = frametype;\r\nbreak;\r\n}\r\nnr_transmit_buffer(sk, skb);\r\n}\r\nvoid __nr_transmit_reply(struct sk_buff *skb, int mine, unsigned char cmdflags)\r\n{\r\nstruct sk_buff *skbn;\r\nunsigned char *dptr;\r\nint len;\r\nlen = NR_NETWORK_LEN + NR_TRANSPORT_LEN + 1;\r\nif ((skbn = alloc_skb(len, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb_reserve(skbn, 0);\r\ndptr = skb_put(skbn, NR_NETWORK_LEN + NR_TRANSPORT_LEN);\r\nskb_copy_from_linear_data_offset(skb, 7, dptr, AX25_ADDR_LEN);\r\ndptr[6] &= ~AX25_CBIT;\r\ndptr[6] &= ~AX25_EBIT;\r\ndptr[6] |= AX25_SSSID_SPARE;\r\ndptr += AX25_ADDR_LEN;\r\nskb_copy_from_linear_data(skb, dptr, AX25_ADDR_LEN);\r\ndptr[6] &= ~AX25_CBIT;\r\ndptr[6] |= AX25_EBIT;\r\ndptr[6] |= AX25_SSSID_SPARE;\r\ndptr += AX25_ADDR_LEN;\r\n*dptr++ = sysctl_netrom_network_ttl_initialiser;\r\nif (mine) {\r\n*dptr++ = 0;\r\n*dptr++ = 0;\r\n*dptr++ = skb->data[15];\r\n*dptr++ = skb->data[16];\r\n} else {\r\n*dptr++ = skb->data[15];\r\n*dptr++ = skb->data[16];\r\n*dptr++ = 0;\r\n*dptr++ = 0;\r\n}\r\n*dptr++ = cmdflags;\r\n*dptr++ = 0;\r\nif (!nr_route_frame(skbn, NULL))\r\nkfree_skb(skbn);\r\n}\r\nvoid nr_disconnect(struct sock *sk, int reason)\r\n{\r\nnr_stop_t1timer(sk);\r\nnr_stop_t2timer(sk);\r\nnr_stop_t4timer(sk);\r\nnr_stop_idletimer(sk);\r\nnr_clear_queues(sk);\r\nnr_sk(sk)->state = NR_STATE_0;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_err = reason;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\n}\r\n}
