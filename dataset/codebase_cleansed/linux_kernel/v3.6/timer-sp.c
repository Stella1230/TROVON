static long __init sp804_get_clock_rate(const char *name)\r\n{\r\nstruct clk *clk;\r\nlong rate;\r\nint err;\r\nclk = clk_get_sys("sp804", name);\r\nif (IS_ERR(clk)) {\r\npr_err("sp804: %s clock not found: %d\n", name,\r\n(int)PTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nerr = clk_prepare(clk);\r\nif (err) {\r\npr_err("sp804: %s clock failed to prepare: %d\n", name, err);\r\nclk_put(clk);\r\nreturn err;\r\n}\r\nerr = clk_enable(clk);\r\nif (err) {\r\npr_err("sp804: %s clock failed to enable: %d\n", name, err);\r\nclk_unprepare(clk);\r\nclk_put(clk);\r\nreturn err;\r\n}\r\nrate = clk_get_rate(clk);\r\nif (rate < 0) {\r\npr_err("sp804: %s clock failed to get rate: %ld\n", name, rate);\r\nclk_disable(clk);\r\nclk_unprepare(clk);\r\nclk_put(clk);\r\n}\r\nreturn rate;\r\n}\r\nstatic u32 sp804_read(void)\r\n{\r\nreturn ~readl_relaxed(sched_clock_base + TIMER_VALUE);\r\n}\r\nvoid __init __sp804_clocksource_and_sched_clock_init(void __iomem *base,\r\nconst char *name,\r\nint use_sched_clock)\r\n{\r\nlong rate = sp804_get_clock_rate(name);\r\nif (rate < 0)\r\nreturn;\r\nwritel(0, base + TIMER_CTRL);\r\nwritel(0xffffffff, base + TIMER_LOAD);\r\nwritel(0xffffffff, base + TIMER_VALUE);\r\nwritel(TIMER_CTRL_32BIT | TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC,\r\nbase + TIMER_CTRL);\r\nclocksource_mmio_init(base + TIMER_VALUE, name,\r\nrate, 200, 32, clocksource_mmio_readl_down);\r\nif (use_sched_clock) {\r\nsched_clock_base = base;\r\nsetup_sched_clock(sp804_read, 32, rate);\r\n}\r\n}\r\nstatic irqreturn_t sp804_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nwritel(1, clkevt_base + TIMER_INTCLR);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sp804_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long ctrl = TIMER_CTRL_32BIT | TIMER_CTRL_IE;\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nwritel(clkevt_reload, clkevt_base + TIMER_LOAD);\r\nctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nctrl |= TIMER_CTRL_ONESHOT;\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ndefault:\r\nbreak;\r\n}\r\nwritel(ctrl, clkevt_base + TIMER_CTRL);\r\n}\r\nstatic int sp804_set_next_event(unsigned long next,\r\nstruct clock_event_device *evt)\r\n{\r\nunsigned long ctrl = readl(clkevt_base + TIMER_CTRL);\r\nwritel(next, clkevt_base + TIMER_LOAD);\r\nwritel(ctrl | TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);\r\nreturn 0;\r\n}\r\nvoid __init sp804_clockevents_init(void __iomem *base, unsigned int irq,\r\nconst char *name)\r\n{\r\nstruct clock_event_device *evt = &sp804_clockevent;\r\nlong rate = sp804_get_clock_rate(name);\r\nif (rate < 0)\r\nreturn;\r\nclkevt_base = base;\r\nclkevt_reload = DIV_ROUND_CLOSEST(rate, HZ);\r\nevt->name = name;\r\nevt->irq = irq;\r\nsetup_irq(irq, &sp804_timer_irq);\r\nclockevents_config_and_register(evt, rate, 0xf, 0xffffffff);\r\n}
