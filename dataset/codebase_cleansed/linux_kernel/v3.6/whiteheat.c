static int whiteheat_firmware_download(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nint response, ret = -ENOENT;\r\nconst struct firmware *loader_fw = NULL, *firmware_fw = NULL;\r\nconst struct ihex_binrec *record;\r\nif (request_ihex_firmware(&firmware_fw, "whiteheat.fw",\r\n&serial->dev->dev)) {\r\ndev_err(&serial->dev->dev,\r\n"%s - request \"whiteheat.fw\" failed\n", __func__);\r\ngoto out;\r\n}\r\nif (request_ihex_firmware(&loader_fw, "whiteheat_loader.fw",\r\n&serial->dev->dev)) {\r\ndev_err(&serial->dev->dev,\r\n"%s - request \"whiteheat_loader.fw\" failed\n",\r\n__func__);\r\ngoto out;\r\n}\r\nret = 0;\r\nresponse = ezusb_set_reset (serial, 1);\r\nrecord = (const struct ihex_binrec *)loader_fw->data;\r\nwhile (record) {\r\nresponse = ezusb_writememory (serial, be32_to_cpu(record->addr),\r\n(unsigned char *)record->data,\r\nbe16_to_cpu(record->len), 0xa0);\r\nif (response < 0) {\r\ndev_err(&serial->dev->dev, "%s - ezusb_writememory "\r\n"failed for loader (%d %04X %p %d)\n",\r\n__func__, response, be32_to_cpu(record->addr),\r\nrecord->data, be16_to_cpu(record->len));\r\nbreak;\r\n}\r\nrecord = ihex_next_binrec(record);\r\n}\r\nresponse = ezusb_set_reset(serial, 0);\r\nrecord = (const struct ihex_binrec *)firmware_fw->data;\r\nwhile (record && be32_to_cpu(record->addr) < 0x1b40)\r\nrecord = ihex_next_binrec(record);\r\nwhile (record) {\r\nresponse = ezusb_writememory (serial, be32_to_cpu(record->addr),\r\n(unsigned char *)record->data,\r\nbe16_to_cpu(record->len), 0xa3);\r\nif (response < 0) {\r\ndev_err(&serial->dev->dev, "%s - ezusb_writememory "\r\n"failed for first firmware step "\r\n"(%d %04X %p %d)\n", __func__, response,\r\nbe32_to_cpu(record->addr), record->data,\r\nbe16_to_cpu(record->len));\r\nbreak;\r\n}\r\n++record;\r\n}\r\nresponse = ezusb_set_reset(serial, 1);\r\nrecord = (const struct ihex_binrec *)firmware_fw->data;\r\nwhile (record && be32_to_cpu(record->addr) < 0x1b40) {\r\nresponse = ezusb_writememory (serial, be32_to_cpu(record->addr),\r\n(unsigned char *)record->data,\r\nbe16_to_cpu(record->len), 0xa0);\r\nif (response < 0) {\r\ndev_err(&serial->dev->dev, "%s - ezusb_writememory "\r\n"failed for second firmware step "\r\n"(%d %04X %p %d)\n", __func__, response,\r\nbe32_to_cpu(record->addr), record->data,\r\nbe16_to_cpu(record->len));\r\nbreak;\r\n}\r\n++record;\r\n}\r\nret = 0;\r\nresponse = ezusb_set_reset (serial, 0);\r\nout:\r\nrelease_firmware(loader_fw);\r\nrelease_firmware(firmware_fw);\r\nreturn ret;\r\n}\r\nstatic int whiteheat_firmware_attach(struct usb_serial *serial)\r\n{\r\nreturn 1;\r\n}\r\nstatic int whiteheat_attach(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_command_private *command_info;\r\nstruct usb_serial_port *port;\r\nstruct whiteheat_private *info;\r\nstruct whiteheat_hw_info *hw_info;\r\nint pipe;\r\nint ret;\r\nint alen;\r\n__u8 *command;\r\n__u8 *result;\r\nint i;\r\ncommand_port = serial->port[COMMAND_PORT];\r\npipe = usb_sndbulkpipe(serial->dev,\r\ncommand_port->bulk_out_endpointAddress);\r\ncommand = kmalloc(2, GFP_KERNEL);\r\nif (!command)\r\ngoto no_command_buffer;\r\ncommand[0] = WHITEHEAT_GET_HW_INFO;\r\ncommand[1] = 0;\r\nresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\r\nif (!result)\r\ngoto no_result_buffer;\r\nusb_clear_halt(serial->dev, pipe);\r\nret = usb_bulk_msg(serial->dev, pipe, command, 2,\r\n&alen, COMMAND_TIMEOUT_MS);\r\nif (ret) {\r\ndev_err(&serial->dev->dev, "%s: Couldn't send command [%d]\n",\r\nserial->type->description, ret);\r\ngoto no_firmware;\r\n} else if (alen != 2) {\r\ndev_err(&serial->dev->dev, "%s: Send command incomplete [%d]\n",\r\nserial->type->description, alen);\r\ngoto no_firmware;\r\n}\r\npipe = usb_rcvbulkpipe(serial->dev,\r\ncommand_port->bulk_in_endpointAddress);\r\nusb_clear_halt(serial->dev, pipe);\r\nret = usb_bulk_msg(serial->dev, pipe, result,\r\nsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\r\nif (ret) {\r\ndev_err(&serial->dev->dev, "%s: Couldn't get results [%d]\n",\r\nserial->type->description, ret);\r\ngoto no_firmware;\r\n} else if (alen != sizeof(*hw_info) + 1) {\r\ndev_err(&serial->dev->dev, "%s: Get results incomplete [%d]\n",\r\nserial->type->description, alen);\r\ngoto no_firmware;\r\n} else if (result[0] != command[0]) {\r\ndev_err(&serial->dev->dev, "%s: Command failed [%d]\n",\r\nserial->type->description, result[0]);\r\ngoto no_firmware;\r\n}\r\nhw_info = (struct whiteheat_hw_info *)&result[1];\r\ndev_info(&serial->dev->dev, "%s: Firmware v%d.%02d\n",\r\nserial->type->description,\r\nhw_info->sw_major_rev, hw_info->sw_minor_rev);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\ninfo = kmalloc(sizeof(struct whiteheat_private), GFP_KERNEL);\r\nif (info == NULL) {\r\ndev_err(&port->dev,\r\n"%s: Out of memory for port structures\n",\r\nserial->type->description);\r\ngoto no_private;\r\n}\r\ninfo->mcr = 0;\r\nusb_set_serial_port_data(port, info);\r\n}\r\ncommand_info = kmalloc(sizeof(struct whiteheat_command_private),\r\nGFP_KERNEL);\r\nif (command_info == NULL) {\r\ndev_err(&serial->dev->dev,\r\n"%s: Out of memory for port structures\n",\r\nserial->type->description);\r\ngoto no_command_private;\r\n}\r\nmutex_init(&command_info->mutex);\r\ncommand_info->port_running = 0;\r\ninit_waitqueue_head(&command_info->wait_command);\r\nusb_set_serial_port_data(command_port, command_info);\r\ncommand_port->write_urb->complete = command_port_write_callback;\r\ncommand_port->read_urb->complete = command_port_read_callback;\r\nkfree(result);\r\nkfree(command);\r\nreturn 0;\r\nno_firmware:\r\ndev_err(&serial->dev->dev,\r\n"%s: Unable to retrieve firmware version, try replugging\n",\r\nserial->type->description);\r\ndev_err(&serial->dev->dev,\r\n"%s: If the firmware is not running (status led not blinking)\n",\r\nserial->type->description);\r\ndev_err(&serial->dev->dev,\r\n"%s: please contact support@connecttech.com\n",\r\nserial->type->description);\r\nkfree(result);\r\nreturn -ENODEV;\r\nno_command_private:\r\nfor (i = serial->num_ports - 1; i >= 0; i--) {\r\nport = serial->port[i];\r\ninfo = usb_get_serial_port_data(port);\r\nkfree(info);\r\nno_private:\r\n;\r\n}\r\nkfree(result);\r\nno_result_buffer:\r\nkfree(command);\r\nno_command_buffer:\r\nreturn -ENOMEM;\r\n}\r\nstatic void whiteheat_release(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_private *info;\r\nint i;\r\ncommand_port = serial->port[COMMAND_PORT];\r\nkfree(usb_get_serial_port_data(command_port));\r\nfor (i = 0; i < serial->num_ports; i++) {\r\ninfo = usb_get_serial_port_data(serial->port[i]);\r\nkfree(info);\r\n}\r\n}\r\nstatic int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint retval;\r\nretval = start_command_port(port->serial);\r\nif (retval)\r\ngoto exit;\r\nretval = firm_open(port);\r\nif (retval) {\r\nstop_command_port(port->serial);\r\ngoto exit;\r\n}\r\nretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\r\nif (retval) {\r\nfirm_close(port);\r\nstop_command_port(port->serial);\r\ngoto exit;\r\n}\r\nif (tty)\r\nfirm_setup_port(tty);\r\nusb_clear_halt(port->serial->dev, port->read_urb->pipe);\r\nusb_clear_halt(port->serial->dev, port->write_urb->pipe);\r\nretval = usb_serial_generic_open(tty, port);\r\nif (retval) {\r\nfirm_close(port);\r\nstop_command_port(port->serial);\r\ngoto exit;\r\n}\r\nexit:\r\nreturn retval;\r\n}\r\nstatic void whiteheat_close(struct usb_serial_port *port)\r\n{\r\nfirm_report_tx_done(port);\r\nfirm_close(port);\r\nusb_serial_generic_close(port);\r\nstop_command_port(port->serial);\r\n}\r\nstatic int whiteheat_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nunsigned int modem_signals = 0;\r\nfirm_get_dtr_rts(port);\r\nif (info->mcr & UART_MCR_DTR)\r\nmodem_signals |= TIOCM_DTR;\r\nif (info->mcr & UART_MCR_RTS)\r\nmodem_signals |= TIOCM_RTS;\r\nreturn modem_signals;\r\n}\r\nstatic int whiteheat_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_private *info = usb_get_serial_port_data(port);\r\nif (set & TIOCM_RTS)\r\ninfo->mcr |= UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->mcr |= UART_MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->mcr &= ~UART_MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->mcr &= ~UART_MCR_DTR;\r\nfirm_set_dtr(port, info->mcr & UART_MCR_DTR);\r\nfirm_set_rts(port, info->mcr & UART_MCR_RTS);\r\nreturn 0;\r\n}\r\nstatic int whiteheat_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct serial_struct serstruct;\r\nvoid __user *user_arg = (void __user *)arg;\r\ndbg("%s - port %d, cmd 0x%.4x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nmemset(&serstruct, 0, sizeof(serstruct));\r\nserstruct.type = PORT_16654;\r\nserstruct.line = port->serial->minor;\r\nserstruct.port = port->number;\r\nserstruct.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\nserstruct.xmit_fifo_size = kfifo_size(&port->write_fifo);\r\nserstruct.custom_divisor = 0;\r\nserstruct.baud_base = 460800;\r\nserstruct.close_delay = CLOSING_DELAY;\r\nserstruct.closing_wait = CLOSING_DELAY;\r\nif (copy_to_user(user_arg, &serstruct, sizeof(serstruct)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void whiteheat_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nfirm_setup_port(tty);\r\n}\r\nstatic void whiteheat_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nfirm_set_break(port, break_state);\r\n}\r\nstatic void command_port_write_callback(struct urb *urb)\r\n{\r\nint status = urb->status;\r\nif (status) {\r\ndbg("nonzero urb status: %d", status);\r\nreturn;\r\n}\r\n}\r\nstatic void command_port_read_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *command_port = urb->context;\r\nstruct whiteheat_command_private *command_info;\r\nint status = urb->status;\r\nunsigned char *data = urb->transfer_buffer;\r\nint result;\r\ncommand_info = usb_get_serial_port_data(command_port);\r\nif (!command_info) {\r\ndbg("%s - command_info is NULL, exiting.", __func__);\r\nreturn;\r\n}\r\nif (status) {\r\ndbg("%s - nonzero urb status: %d", __func__, status);\r\nif (status != -ENOENT)\r\ncommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\r\nwake_up(&command_info->wait_command);\r\nreturn;\r\n}\r\nusb_serial_debug_data(debug, &command_port->dev,\r\n__func__, urb->actual_length, data);\r\nif (data[0] == WHITEHEAT_CMD_COMPLETE) {\r\ncommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\r\nwake_up(&command_info->wait_command);\r\n} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\r\ncommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\r\nwake_up(&command_info->wait_command);\r\n} else if (data[0] == WHITEHEAT_EVENT) {\r\ndbg("%s - event received", __func__);\r\n} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\r\nmemcpy(command_info->result_buffer, &data[1],\r\nurb->actual_length - 1);\r\ncommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\r\nwake_up(&command_info->wait_command);\r\n} else\r\ndbg("%s - bad reply from firmware", __func__);\r\nresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\r\nif (result)\r\ndbg("%s - failed resubmitting read urb, error %d",\r\n__func__, result);\r\n}\r\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\r\n__u8 *data, __u8 datasize)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_command_private *command_info;\r\nstruct whiteheat_private *info;\r\n__u8 *transfer_buffer;\r\nint retval = 0;\r\nint t;\r\ndbg("%s - command %d", __func__, command);\r\ncommand_port = port->serial->port[COMMAND_PORT];\r\ncommand_info = usb_get_serial_port_data(command_port);\r\nmutex_lock(&command_info->mutex);\r\ncommand_info->command_finished = false;\r\ntransfer_buffer = (__u8 *)command_port->write_urb->transfer_buffer;\r\ntransfer_buffer[0] = command;\r\nmemcpy(&transfer_buffer[1], data, datasize);\r\ncommand_port->write_urb->transfer_buffer_length = datasize + 1;\r\nretval = usb_submit_urb(command_port->write_urb, GFP_NOIO);\r\nif (retval) {\r\ndbg("%s - submit urb failed", __func__);\r\ngoto exit;\r\n}\r\nt = wait_event_timeout(command_info->wait_command,\r\n(bool)command_info->command_finished, COMMAND_TIMEOUT);\r\nif (!t)\r\nusb_kill_urb(command_port->write_urb);\r\nif (command_info->command_finished == false) {\r\ndbg("%s - command timed out.", __func__);\r\nretval = -ETIMEDOUT;\r\ngoto exit;\r\n}\r\nif (command_info->command_finished == WHITEHEAT_CMD_FAILURE) {\r\ndbg("%s - command failed.", __func__);\r\nretval = -EIO;\r\ngoto exit;\r\n}\r\nif (command_info->command_finished == WHITEHEAT_CMD_COMPLETE) {\r\ndbg("%s - command completed.", __func__);\r\nswitch (command) {\r\ncase WHITEHEAT_GET_DTR_RTS:\r\ninfo = usb_get_serial_port_data(port);\r\nmemcpy(&info->mcr, command_info->result_buffer,\r\nsizeof(struct whiteheat_dr_info));\r\nbreak;\r\n}\r\n}\r\nexit:\r\nmutex_unlock(&command_info->mutex);\r\nreturn retval;\r\n}\r\nstatic int firm_open(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_simple open_command;\r\nopen_command.port = port->number - port->serial->minor + 1;\r\nreturn firm_send_command(port, WHITEHEAT_OPEN,\r\n(__u8 *)&open_command, sizeof(open_command));\r\n}\r\nstatic int firm_close(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_simple close_command;\r\nclose_command.port = port->number - port->serial->minor + 1;\r\nreturn firm_send_command(port, WHITEHEAT_CLOSE,\r\n(__u8 *)&close_command, sizeof(close_command));\r\n}\r\nstatic void firm_setup_port(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct whiteheat_port_settings port_settings;\r\nunsigned int cflag = tty->termios->c_cflag;\r\nport_settings.port = port->number + 1;\r\nswitch (cflag & CSIZE) {\r\ncase CS5: port_settings.bits = 5; break;\r\ncase CS6: port_settings.bits = 6; break;\r\ncase CS7: port_settings.bits = 7; break;\r\ndefault:\r\ncase CS8: port_settings.bits = 8; break;\r\n}\r\ndbg("%s - data bits = %d", __func__, port_settings.bits);\r\nif (cflag & PARENB)\r\nif (cflag & CMSPAR)\r\nif (cflag & PARODD)\r\nport_settings.parity = WHITEHEAT_PAR_MARK;\r\nelse\r\nport_settings.parity = WHITEHEAT_PAR_SPACE;\r\nelse\r\nif (cflag & PARODD)\r\nport_settings.parity = WHITEHEAT_PAR_ODD;\r\nelse\r\nport_settings.parity = WHITEHEAT_PAR_EVEN;\r\nelse\r\nport_settings.parity = WHITEHEAT_PAR_NONE;\r\ndbg("%s - parity = %c", __func__, port_settings.parity);\r\nif (cflag & CSTOPB)\r\nport_settings.stop = 2;\r\nelse\r\nport_settings.stop = 1;\r\ndbg("%s - stop bits = %d", __func__, port_settings.stop);\r\nif (cflag & CRTSCTS)\r\nport_settings.hflow = (WHITEHEAT_HFLOW_CTS |\r\nWHITEHEAT_HFLOW_RTS);\r\nelse\r\nport_settings.hflow = WHITEHEAT_HFLOW_NONE;\r\ndbg("%s - hardware flow control = %s %s %s %s", __func__,\r\n(port_settings.hflow & WHITEHEAT_HFLOW_CTS) ? "CTS" : "",\r\n(port_settings.hflow & WHITEHEAT_HFLOW_RTS) ? "RTS" : "",\r\n(port_settings.hflow & WHITEHEAT_HFLOW_DSR) ? "DSR" : "",\r\n(port_settings.hflow & WHITEHEAT_HFLOW_DTR) ? "DTR" : "");\r\nif (I_IXOFF(tty))\r\nport_settings.sflow = WHITEHEAT_SFLOW_RXTX;\r\nelse\r\nport_settings.sflow = WHITEHEAT_SFLOW_NONE;\r\ndbg("%s - software flow control = %c", __func__, port_settings.sflow);\r\nport_settings.xon = START_CHAR(tty);\r\nport_settings.xoff = STOP_CHAR(tty);\r\ndbg("%s - XON = %2x, XOFF = %2x",\r\n__func__, port_settings.xon, port_settings.xoff);\r\nport_settings.baud = tty_get_baud_rate(tty);\r\ndbg("%s - baud rate = %d", __func__, port_settings.baud);\r\ntty_encode_baud_rate(tty, port_settings.baud, port_settings.baud);\r\nport_settings.lloop = 0;\r\nfirm_send_command(port, WHITEHEAT_SETUP_PORT,\r\n(__u8 *)&port_settings, sizeof(port_settings));\r\n}\r\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\r\n{\r\nstruct whiteheat_set_rdb rts_command;\r\nrts_command.port = port->number - port->serial->minor + 1;\r\nrts_command.state = onoff;\r\nreturn firm_send_command(port, WHITEHEAT_SET_RTS,\r\n(__u8 *)&rts_command, sizeof(rts_command));\r\n}\r\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff)\r\n{\r\nstruct whiteheat_set_rdb dtr_command;\r\ndtr_command.port = port->number - port->serial->minor + 1;\r\ndtr_command.state = onoff;\r\nreturn firm_send_command(port, WHITEHEAT_SET_DTR,\r\n(__u8 *)&dtr_command, sizeof(dtr_command));\r\n}\r\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff)\r\n{\r\nstruct whiteheat_set_rdb break_command;\r\nbreak_command.port = port->number - port->serial->minor + 1;\r\nbreak_command.state = onoff;\r\nreturn firm_send_command(port, WHITEHEAT_SET_BREAK,\r\n(__u8 *)&break_command, sizeof(break_command));\r\n}\r\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx)\r\n{\r\nstruct whiteheat_purge purge_command;\r\npurge_command.port = port->number - port->serial->minor + 1;\r\npurge_command.what = rxtx;\r\nreturn firm_send_command(port, WHITEHEAT_PURGE,\r\n(__u8 *)&purge_command, sizeof(purge_command));\r\n}\r\nstatic int firm_get_dtr_rts(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_simple get_dr_command;\r\nget_dr_command.port = port->number - port->serial->minor + 1;\r\nreturn firm_send_command(port, WHITEHEAT_GET_DTR_RTS,\r\n(__u8 *)&get_dr_command, sizeof(get_dr_command));\r\n}\r\nstatic int firm_report_tx_done(struct usb_serial_port *port)\r\n{\r\nstruct whiteheat_simple close_command;\r\nclose_command.port = port->number - port->serial->minor + 1;\r\nreturn firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,\r\n(__u8 *)&close_command, sizeof(close_command));\r\n}\r\nstatic int start_command_port(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_command_private *command_info;\r\nint retval = 0;\r\ncommand_port = serial->port[COMMAND_PORT];\r\ncommand_info = usb_get_serial_port_data(command_port);\r\nmutex_lock(&command_info->mutex);\r\nif (!command_info->port_running) {\r\nusb_clear_halt(serial->dev, command_port->read_urb->pipe);\r\nretval = usb_submit_urb(command_port->read_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&serial->dev->dev,\r\n"%s - failed submitting read urb, error %d\n",\r\n__func__, retval);\r\ngoto exit;\r\n}\r\n}\r\ncommand_info->port_running++;\r\nexit:\r\nmutex_unlock(&command_info->mutex);\r\nreturn retval;\r\n}\r\nstatic void stop_command_port(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *command_port;\r\nstruct whiteheat_command_private *command_info;\r\ncommand_port = serial->port[COMMAND_PORT];\r\ncommand_info = usb_get_serial_port_data(command_port);\r\nmutex_lock(&command_info->mutex);\r\ncommand_info->port_running--;\r\nif (!command_info->port_running)\r\nusb_kill_urb(command_port->read_urb);\r\nmutex_unlock(&command_info->mutex);\r\n}
