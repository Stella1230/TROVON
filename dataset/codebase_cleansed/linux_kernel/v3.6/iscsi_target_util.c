int iscsit_add_r2t_to_list(\r\nstruct iscsi_cmd *cmd,\r\nu32 offset,\r\nu32 xfer_len,\r\nint recovery,\r\nu32 r2t_sn)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nr2t = kmem_cache_zalloc(lio_r2t_cache, GFP_ATOMIC);\r\nif (!r2t) {\r\npr_err("Unable to allocate memory for struct iscsi_r2t.\n");\r\nreturn -1;\r\n}\r\nINIT_LIST_HEAD(&r2t->r2t_list);\r\nr2t->recovery_r2t = recovery;\r\nr2t->r2t_sn = (!r2t_sn) ? cmd->r2t_sn++ : r2t_sn;\r\nr2t->offset = offset;\r\nr2t->xfer_len = xfer_len;\r\nlist_add_tail(&r2t->r2t_list, &cmd->cmd_r2t_list);\r\nspin_unlock_bh(&cmd->r2t_lock);\r\niscsit_add_cmd_to_immediate_queue(cmd, cmd->conn, ISTATE_SEND_R2T);\r\nspin_lock_bh(&cmd->r2t_lock);\r\nreturn 0;\r\n}\r\nstruct iscsi_r2t *iscsit_get_r2t_for_eos(\r\nstruct iscsi_cmd *cmd,\r\nu32 offset,\r\nu32 length)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\r\nif ((r2t->offset <= offset) &&\r\n(r2t->offset + r2t->xfer_len) >= (offset + length)) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn r2t;\r\n}\r\n}\r\nspin_unlock_bh(&cmd->r2t_lock);\r\npr_err("Unable to locate R2T for Offset: %u, Length:"\r\n" %u\n", offset, length);\r\nreturn NULL;\r\n}\r\nstruct iscsi_r2t *iscsit_get_r2t_from_list(struct iscsi_cmd *cmd)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\r\nif (!r2t->sent_r2t) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn r2t;\r\n}\r\n}\r\nspin_unlock_bh(&cmd->r2t_lock);\r\npr_err("Unable to locate next R2T to send for ITT:"\r\n" 0x%08x.\n", cmd->init_task_tag);\r\nreturn NULL;\r\n}\r\nvoid iscsit_free_r2t(struct iscsi_r2t *r2t, struct iscsi_cmd *cmd)\r\n{\r\nlist_del(&r2t->r2t_list);\r\nkmem_cache_free(lio_r2t_cache, r2t);\r\n}\r\nvoid iscsit_free_r2ts_from_list(struct iscsi_cmd *cmd)\r\n{\r\nstruct iscsi_r2t *r2t, *r2t_tmp;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nlist_for_each_entry_safe(r2t, r2t_tmp, &cmd->cmd_r2t_list, r2t_list)\r\niscsit_free_r2t(r2t, cmd);\r\nspin_unlock_bh(&cmd->r2t_lock);\r\n}\r\nstruct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *conn, gfp_t gfp_mask)\r\n{\r\nstruct iscsi_cmd *cmd;\r\ncmd = kmem_cache_zalloc(lio_cmd_cache, gfp_mask);\r\nif (!cmd) {\r\npr_err("Unable to allocate memory for struct iscsi_cmd.\n");\r\nreturn NULL;\r\n}\r\ncmd->conn = conn;\r\nINIT_LIST_HEAD(&cmd->i_conn_node);\r\nINIT_LIST_HEAD(&cmd->datain_list);\r\nINIT_LIST_HEAD(&cmd->cmd_r2t_list);\r\ninit_completion(&cmd->reject_comp);\r\nspin_lock_init(&cmd->datain_lock);\r\nspin_lock_init(&cmd->dataout_timeout_lock);\r\nspin_lock_init(&cmd->istate_lock);\r\nspin_lock_init(&cmd->error_lock);\r\nspin_lock_init(&cmd->r2t_lock);\r\nreturn cmd;\r\n}\r\nstruct iscsi_seq *iscsit_get_seq_holder_for_datain(\r\nstruct iscsi_cmd *cmd,\r\nu32 seq_send_order)\r\n{\r\nu32 i;\r\nfor (i = 0; i < cmd->seq_count; i++)\r\nif (cmd->seq_list[i].seq_send_order == seq_send_order)\r\nreturn &cmd->seq_list[i];\r\nreturn NULL;\r\n}\r\nstruct iscsi_seq *iscsit_get_seq_holder_for_r2t(struct iscsi_cmd *cmd)\r\n{\r\nu32 i;\r\nif (!cmd->seq_list) {\r\npr_err("struct iscsi_cmd->seq_list is NULL!\n");\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < cmd->seq_count; i++) {\r\nif (cmd->seq_list[i].type != SEQTYPE_NORMAL)\r\ncontinue;\r\nif (cmd->seq_list[i].seq_send_order == cmd->seq_send_order) {\r\ncmd->seq_send_order++;\r\nreturn &cmd->seq_list[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct iscsi_r2t *iscsit_get_holder_for_r2tsn(\r\nstruct iscsi_cmd *cmd,\r\nu32 r2t_sn)\r\n{\r\nstruct iscsi_r2t *r2t;\r\nspin_lock_bh(&cmd->r2t_lock);\r\nlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\r\nif (r2t->r2t_sn == r2t_sn) {\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn r2t;\r\n}\r\n}\r\nspin_unlock_bh(&cmd->r2t_lock);\r\nreturn NULL;\r\n}\r\nstatic inline int iscsit_check_received_cmdsn(struct iscsi_session *sess, u32 cmdsn)\r\n{\r\nint ret;\r\nif (iscsi_sna_gt(cmdsn, sess->max_cmd_sn)) {\r\npr_err("Received CmdSN: 0x%08x is greater than"\r\n" MaxCmdSN: 0x%08x, protocol error.\n", cmdsn,\r\nsess->max_cmd_sn);\r\nret = CMDSN_ERROR_CANNOT_RECOVER;\r\n} else if (cmdsn == sess->exp_cmd_sn) {\r\nsess->exp_cmd_sn++;\r\npr_debug("Received CmdSN matches ExpCmdSN,"\r\n" incremented ExpCmdSN to: 0x%08x\n",\r\nsess->exp_cmd_sn);\r\nret = CMDSN_NORMAL_OPERATION;\r\n} else if (iscsi_sna_gt(cmdsn, sess->exp_cmd_sn)) {\r\npr_debug("Received CmdSN: 0x%08x is greater"\r\n" than ExpCmdSN: 0x%08x, not acknowledging.\n",\r\ncmdsn, sess->exp_cmd_sn);\r\nret = CMDSN_HIGHER_THAN_EXP;\r\n} else {\r\npr_err("Received CmdSN: 0x%08x is less than"\r\n" ExpCmdSN: 0x%08x, ignoring.\n", cmdsn,\r\nsess->exp_cmd_sn);\r\nret = CMDSN_LOWER_THAN_EXP;\r\n}\r\nreturn ret;\r\n}\r\nint iscsit_sequence_cmd(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_cmd *cmd,\r\nu32 cmdsn)\r\n{\r\nint ret;\r\nint cmdsn_ret;\r\nmutex_lock(&conn->sess->cmdsn_mutex);\r\ncmdsn_ret = iscsit_check_received_cmdsn(conn->sess, cmdsn);\r\nswitch (cmdsn_ret) {\r\ncase CMDSN_NORMAL_OPERATION:\r\nret = iscsit_execute_cmd(cmd, 0);\r\nif ((ret >= 0) && !list_empty(&conn->sess->sess_ooo_cmdsn_list))\r\niscsit_execute_ooo_cmdsns(conn->sess);\r\nbreak;\r\ncase CMDSN_HIGHER_THAN_EXP:\r\nret = iscsit_handle_ooo_cmdsn(conn->sess, cmd, cmdsn);\r\nbreak;\r\ncase CMDSN_LOWER_THAN_EXP:\r\ncmd->i_state = ISTATE_REMOVE;\r\niscsit_add_cmd_to_immediate_queue(cmd, conn, cmd->i_state);\r\nret = cmdsn_ret;\r\nbreak;\r\ndefault:\r\nret = cmdsn_ret;\r\nbreak;\r\n}\r\nmutex_unlock(&conn->sess->cmdsn_mutex);\r\nreturn ret;\r\n}\r\nint iscsit_check_unsolicited_dataout(struct iscsi_cmd *cmd, unsigned char *buf)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct iscsi_data *hdr = (struct iscsi_data *) buf;\r\nu32 payload_length = ntoh24(hdr->dlength);\r\nif (conn->sess->sess_ops->InitialR2T) {\r\npr_err("Received unexpected unsolicited data"\r\n" while InitialR2T=Yes, protocol error.\n");\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_UNEXPECTED_UNSOLICITED_DATA, 0);\r\nreturn -1;\r\n}\r\nif ((cmd->first_burst_len + payload_length) >\r\nconn->sess->sess_ops->FirstBurstLength) {\r\npr_err("Total %u bytes exceeds FirstBurstLength: %u"\r\n" for this Unsolicited DataOut Burst.\n",\r\n(cmd->first_burst_len + payload_length),\r\nconn->sess->sess_ops->FirstBurstLength);\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_INCORRECT_AMOUNT_OF_DATA, 0);\r\nreturn -1;\r\n}\r\nif (!(hdr->flags & ISCSI_FLAG_CMD_FINAL))\r\nreturn 0;\r\nif (((cmd->first_burst_len + payload_length) != cmd->se_cmd.data_length) &&\r\n((cmd->first_burst_len + payload_length) !=\r\nconn->sess->sess_ops->FirstBurstLength)) {\r\npr_err("Unsolicited non-immediate data received %u"\r\n" does not equal FirstBurstLength: %u, and does"\r\n" not equal ExpXferLen %u.\n",\r\n(cmd->first_burst_len + payload_length),\r\nconn->sess->sess_ops->FirstBurstLength, cmd->se_cmd.data_length);\r\ntransport_send_check_condition_and_sense(se_cmd,\r\nTCM_INCORRECT_AMOUNT_OF_DATA, 0);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstruct iscsi_cmd *iscsit_find_cmd_from_itt(\r\nstruct iscsi_conn *conn,\r\nu32 init_task_tag)\r\n{\r\nstruct iscsi_cmd *cmd;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\r\nif (cmd->init_task_tag == init_task_tag) {\r\nspin_unlock_bh(&conn->cmd_lock);\r\nreturn cmd;\r\n}\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\npr_err("Unable to locate ITT: 0x%08x on CID: %hu",\r\ninit_task_tag, conn->cid);\r\nreturn NULL;\r\n}\r\nstruct iscsi_cmd *iscsit_find_cmd_from_itt_or_dump(\r\nstruct iscsi_conn *conn,\r\nu32 init_task_tag,\r\nu32 length)\r\n{\r\nstruct iscsi_cmd *cmd;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\r\nif (cmd->init_task_tag == init_task_tag) {\r\nspin_unlock_bh(&conn->cmd_lock);\r\nreturn cmd;\r\n}\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\npr_err("Unable to locate ITT: 0x%08x on CID: %hu,"\r\n" dumping payload\n", init_task_tag, conn->cid);\r\nif (length)\r\niscsit_dump_data_payload(conn, length, 1);\r\nreturn NULL;\r\n}\r\nstruct iscsi_cmd *iscsit_find_cmd_from_ttt(\r\nstruct iscsi_conn *conn,\r\nu32 targ_xfer_tag)\r\n{\r\nstruct iscsi_cmd *cmd = NULL;\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\r\nif (cmd->targ_xfer_tag == targ_xfer_tag) {\r\nspin_unlock_bh(&conn->cmd_lock);\r\nreturn cmd;\r\n}\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\npr_err("Unable to locate TTT: 0x%08x on CID: %hu\n",\r\ntarg_xfer_tag, conn->cid);\r\nreturn NULL;\r\n}\r\nint iscsit_find_cmd_for_recovery(\r\nstruct iscsi_session *sess,\r\nstruct iscsi_cmd **cmd_ptr,\r\nstruct iscsi_conn_recovery **cr_ptr,\r\nu32 init_task_tag)\r\n{\r\nstruct iscsi_cmd *cmd = NULL;\r\nstruct iscsi_conn_recovery *cr;\r\nspin_lock(&sess->cr_i_lock);\r\nlist_for_each_entry(cr, &sess->cr_inactive_list, cr_list) {\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\nlist_for_each_entry(cmd, &cr->conn_recovery_cmd_list, i_conn_node) {\r\nif (cmd->init_task_tag == init_task_tag) {\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\nspin_unlock(&sess->cr_i_lock);\r\n*cr_ptr = cr;\r\n*cmd_ptr = cmd;\r\nreturn -2;\r\n}\r\n}\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\n}\r\nspin_unlock(&sess->cr_i_lock);\r\nspin_lock(&sess->cr_a_lock);\r\nlist_for_each_entry(cr, &sess->cr_active_list, cr_list) {\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\nlist_for_each_entry(cmd, &cr->conn_recovery_cmd_list, i_conn_node) {\r\nif (cmd->init_task_tag == init_task_tag) {\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\nspin_unlock(&sess->cr_a_lock);\r\n*cr_ptr = cr;\r\n*cmd_ptr = cmd;\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\n}\r\nspin_unlock(&sess->cr_a_lock);\r\nreturn -1;\r\n}\r\nvoid iscsit_add_cmd_to_immediate_queue(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn,\r\nu8 state)\r\n{\r\nstruct iscsi_queue_req *qr;\r\nqr = kmem_cache_zalloc(lio_qr_cache, GFP_ATOMIC);\r\nif (!qr) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_queue_req\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&qr->qr_list);\r\nqr->cmd = cmd;\r\nqr->state = state;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nlist_add_tail(&qr->qr_list, &conn->immed_queue_list);\r\natomic_inc(&cmd->immed_queue_count);\r\natomic_set(&conn->check_immediate_queue, 1);\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nwake_up_process(conn->thread_set->tx_thread);\r\n}\r\nstruct iscsi_queue_req *iscsit_get_cmd_from_immediate_queue(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nif (list_empty(&conn->immed_queue_list)) {\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(qr, &conn->immed_queue_list, qr_list)\r\nbreak;\r\nlist_del(&qr->qr_list);\r\nif (qr->cmd)\r\natomic_dec(&qr->cmd->immed_queue_count);\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nreturn qr;\r\n}\r\nstatic void iscsit_remove_cmd_from_immediate_queue(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr, *qr_tmp;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nif (!atomic_read(&cmd->immed_queue_count)) {\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(qr, qr_tmp, &conn->immed_queue_list, qr_list) {\r\nif (qr->cmd != cmd)\r\ncontinue;\r\natomic_dec(&qr->cmd->immed_queue_count);\r\nlist_del(&qr->qr_list);\r\nkmem_cache_free(lio_qr_cache, qr);\r\n}\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nif (atomic_read(&cmd->immed_queue_count)) {\r\npr_err("ITT: 0x%08x immed_queue_count: %d\n",\r\ncmd->init_task_tag,\r\natomic_read(&cmd->immed_queue_count));\r\n}\r\n}\r\nvoid iscsit_add_cmd_to_response_queue(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn,\r\nu8 state)\r\n{\r\nstruct iscsi_queue_req *qr;\r\nqr = kmem_cache_zalloc(lio_qr_cache, GFP_ATOMIC);\r\nif (!qr) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_queue_req\n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&qr->qr_list);\r\nqr->cmd = cmd;\r\nqr->state = state;\r\nspin_lock_bh(&conn->response_queue_lock);\r\nlist_add_tail(&qr->qr_list, &conn->response_queue_list);\r\natomic_inc(&cmd->response_queue_count);\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nwake_up_process(conn->thread_set->tx_thread);\r\n}\r\nstruct iscsi_queue_req *iscsit_get_cmd_from_response_queue(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr;\r\nspin_lock_bh(&conn->response_queue_lock);\r\nif (list_empty(&conn->response_queue_list)) {\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(qr, &conn->response_queue_list, qr_list)\r\nbreak;\r\nlist_del(&qr->qr_list);\r\nif (qr->cmd)\r\natomic_dec(&qr->cmd->response_queue_count);\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nreturn qr;\r\n}\r\nstatic void iscsit_remove_cmd_from_response_queue(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr, *qr_tmp;\r\nspin_lock_bh(&conn->response_queue_lock);\r\nif (!atomic_read(&cmd->response_queue_count)) {\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(qr, qr_tmp, &conn->response_queue_list,\r\nqr_list) {\r\nif (qr->cmd != cmd)\r\ncontinue;\r\natomic_dec(&qr->cmd->response_queue_count);\r\nlist_del(&qr->qr_list);\r\nkmem_cache_free(lio_qr_cache, qr);\r\n}\r\nspin_unlock_bh(&conn->response_queue_lock);\r\nif (atomic_read(&cmd->response_queue_count)) {\r\npr_err("ITT: 0x%08x response_queue_count: %d\n",\r\ncmd->init_task_tag,\r\natomic_read(&cmd->response_queue_count));\r\n}\r\n}\r\nvoid iscsit_free_queue_reqs_for_conn(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_queue_req *qr, *qr_tmp;\r\nspin_lock_bh(&conn->immed_queue_lock);\r\nlist_for_each_entry_safe(qr, qr_tmp, &conn->immed_queue_list, qr_list) {\r\nlist_del(&qr->qr_list);\r\nif (qr->cmd)\r\natomic_dec(&qr->cmd->immed_queue_count);\r\nkmem_cache_free(lio_qr_cache, qr);\r\n}\r\nspin_unlock_bh(&conn->immed_queue_lock);\r\nspin_lock_bh(&conn->response_queue_lock);\r\nlist_for_each_entry_safe(qr, qr_tmp, &conn->response_queue_list,\r\nqr_list) {\r\nlist_del(&qr->qr_list);\r\nif (qr->cmd)\r\natomic_dec(&qr->cmd->response_queue_count);\r\nkmem_cache_free(lio_qr_cache, qr);\r\n}\r\nspin_unlock_bh(&conn->response_queue_lock);\r\n}\r\nvoid iscsit_release_cmd(struct iscsi_cmd *cmd)\r\n{\r\nstruct iscsi_conn *conn = cmd->conn;\r\niscsit_free_r2ts_from_list(cmd);\r\niscsit_free_all_datain_reqs(cmd);\r\nkfree(cmd->buf_ptr);\r\nkfree(cmd->pdu_list);\r\nkfree(cmd->seq_list);\r\nkfree(cmd->tmr_req);\r\nkfree(cmd->iov_data);\r\nif (conn) {\r\niscsit_remove_cmd_from_immediate_queue(cmd, conn);\r\niscsit_remove_cmd_from_response_queue(cmd, conn);\r\n}\r\nkmem_cache_free(lio_cmd_cache, cmd);\r\n}\r\nvoid iscsit_free_cmd(struct iscsi_cmd *cmd)\r\n{\r\nswitch (cmd->iscsi_opcode) {\r\ncase ISCSI_OP_SCSI_CMD:\r\ncase ISCSI_OP_SCSI_TMFUNC:\r\ntransport_generic_free_cmd(&cmd->se_cmd, 1);\r\nbreak;\r\ncase ISCSI_OP_REJECT:\r\nif (cmd->se_cmd.se_tfo != NULL) {\r\ntransport_generic_free_cmd(&cmd->se_cmd, 1);\r\nbreak;\r\n}\r\ndefault:\r\niscsit_release_cmd(cmd);\r\nbreak;\r\n}\r\n}\r\nint iscsit_check_session_usage_count(struct iscsi_session *sess)\r\n{\r\nspin_lock_bh(&sess->session_usage_lock);\r\nif (sess->session_usage_count != 0) {\r\nsess->session_waiting_on_uc = 1;\r\nspin_unlock_bh(&sess->session_usage_lock);\r\nif (in_interrupt())\r\nreturn 2;\r\nwait_for_completion(&sess->session_waiting_on_uc_comp);\r\nreturn 1;\r\n}\r\nspin_unlock_bh(&sess->session_usage_lock);\r\nreturn 0;\r\n}\r\nvoid iscsit_dec_session_usage_count(struct iscsi_session *sess)\r\n{\r\nspin_lock_bh(&sess->session_usage_lock);\r\nsess->session_usage_count--;\r\nif (!sess->session_usage_count && sess->session_waiting_on_uc)\r\ncomplete(&sess->session_waiting_on_uc_comp);\r\nspin_unlock_bh(&sess->session_usage_lock);\r\n}\r\nvoid iscsit_inc_session_usage_count(struct iscsi_session *sess)\r\n{\r\nspin_lock_bh(&sess->session_usage_lock);\r\nsess->session_usage_count++;\r\nspin_unlock_bh(&sess->session_usage_lock);\r\n}\r\nint iscsit_set_sync_and_steering_values(struct iscsi_conn *conn)\r\n{\r\nint login_ifmarker_count = 0, login_ofmarker_count = 0, next_marker = 0;\r\nu32 IFMarkInt = (conn->conn_ops->IFMarkInt * 4);\r\nu32 OFMarkInt = (conn->conn_ops->OFMarkInt * 4);\r\nif (conn->conn_ops->OFMarker) {\r\nconn->of_marker += ISCSI_HDR_LEN;\r\nif (conn->of_marker <= OFMarkInt) {\r\nconn->of_marker = (OFMarkInt - conn->of_marker);\r\n} else {\r\nlogin_ofmarker_count = (conn->of_marker / OFMarkInt);\r\nnext_marker = (OFMarkInt * (login_ofmarker_count + 1)) +\r\n(login_ofmarker_count * MARKER_SIZE);\r\nconn->of_marker = (next_marker - conn->of_marker);\r\n}\r\nconn->of_marker_offset = 0;\r\npr_debug("Setting OFMarker value to %u based on Initial"\r\n" Markerless Interval.\n", conn->of_marker);\r\n}\r\nif (conn->conn_ops->IFMarker) {\r\nif (conn->if_marker <= IFMarkInt) {\r\nconn->if_marker = (IFMarkInt - conn->if_marker);\r\n} else {\r\nlogin_ifmarker_count = (conn->if_marker / IFMarkInt);\r\nnext_marker = (IFMarkInt * (login_ifmarker_count + 1)) +\r\n(login_ifmarker_count * MARKER_SIZE);\r\nconn->if_marker = (next_marker - conn->if_marker);\r\n}\r\npr_debug("Setting IFMarker value to %u based on Initial"\r\n" Markerless Interval.\n", conn->if_marker);\r\n}\r\nreturn 0;\r\n}\r\nstruct iscsi_conn *iscsit_get_conn_from_cid(struct iscsi_session *sess, u16 cid)\r\n{\r\nstruct iscsi_conn *conn;\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\r\nif ((conn->cid == cid) &&\r\n(conn->conn_state == TARG_CONN_STATE_LOGGED_IN)) {\r\niscsit_inc_conn_usage_count(conn);\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn conn;\r\n}\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn NULL;\r\n}\r\nstruct iscsi_conn *iscsit_get_conn_from_cid_rcfr(struct iscsi_session *sess, u16 cid)\r\n{\r\nstruct iscsi_conn *conn;\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\r\nif (conn->cid == cid) {\r\niscsit_inc_conn_usage_count(conn);\r\nspin_lock(&conn->state_lock);\r\natomic_set(&conn->connection_wait_rcfr, 1);\r\nspin_unlock(&conn->state_lock);\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn conn;\r\n}\r\n}\r\nspin_unlock_bh(&sess->conn_lock);\r\nreturn NULL;\r\n}\r\nvoid iscsit_check_conn_usage_count(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->conn_usage_lock);\r\nif (conn->conn_usage_count != 0) {\r\nconn->conn_waiting_on_uc = 1;\r\nspin_unlock_bh(&conn->conn_usage_lock);\r\nwait_for_completion(&conn->conn_waiting_on_uc_comp);\r\nreturn;\r\n}\r\nspin_unlock_bh(&conn->conn_usage_lock);\r\n}\r\nvoid iscsit_dec_conn_usage_count(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->conn_usage_lock);\r\nconn->conn_usage_count--;\r\nif (!conn->conn_usage_count && conn->conn_waiting_on_uc)\r\ncomplete(&conn->conn_waiting_on_uc_comp);\r\nspin_unlock_bh(&conn->conn_usage_lock);\r\n}\r\nvoid iscsit_inc_conn_usage_count(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->conn_usage_lock);\r\nconn->conn_usage_count++;\r\nspin_unlock_bh(&conn->conn_usage_lock);\r\n}\r\nstatic int iscsit_add_nopin(struct iscsi_conn *conn, int want_response)\r\n{\r\nu8 state;\r\nstruct iscsi_cmd *cmd;\r\ncmd = iscsit_allocate_cmd(conn, GFP_ATOMIC);\r\nif (!cmd)\r\nreturn -1;\r\ncmd->iscsi_opcode = ISCSI_OP_NOOP_IN;\r\nstate = (want_response) ? ISTATE_SEND_NOPIN_WANT_RESPONSE :\r\nISTATE_SEND_NOPIN_NO_RESPONSE;\r\ncmd->init_task_tag = 0xFFFFFFFF;\r\nspin_lock_bh(&conn->sess->ttt_lock);\r\ncmd->targ_xfer_tag = (want_response) ? conn->sess->targ_xfer_tag++ :\r\n0xFFFFFFFF;\r\nif (want_response && (cmd->targ_xfer_tag == 0xFFFFFFFF))\r\ncmd->targ_xfer_tag = conn->sess->targ_xfer_tag++;\r\nspin_unlock_bh(&conn->sess->ttt_lock);\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\r\nspin_unlock_bh(&conn->cmd_lock);\r\nif (want_response)\r\niscsit_start_nopin_response_timer(conn);\r\niscsit_add_cmd_to_immediate_queue(cmd, conn, state);\r\nreturn 0;\r\n}\r\nstatic void iscsit_handle_nopin_response_timeout(unsigned long data)\r\n{\r\nstruct iscsi_conn *conn = (struct iscsi_conn *) data;\r\niscsit_inc_conn_usage_count(conn);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (conn->nopin_response_timer_flags & ISCSI_TF_STOP) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\niscsit_dec_conn_usage_count(conn);\r\nreturn;\r\n}\r\npr_debug("Did not receive response to NOPIN on CID: %hu on"\r\n" SID: %u, failing connection.\n", conn->cid,\r\nconn->sess->sid);\r\nconn->nopin_response_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n{\r\nstruct iscsi_portal_group *tpg = conn->sess->tpg;\r\nstruct iscsi_tiqn *tiqn = tpg->tpg_tiqn;\r\nif (tiqn) {\r\nspin_lock_bh(&tiqn->sess_err_stats.lock);\r\nstrcpy(tiqn->sess_err_stats.last_sess_fail_rem_name,\r\nconn->sess->sess_ops->InitiatorName);\r\ntiqn->sess_err_stats.last_sess_failure_type =\r\nISCSI_SESS_ERR_CXN_TIMEOUT;\r\ntiqn->sess_err_stats.cxn_timeout_errors++;\r\nconn->sess->conn_timeout_errors++;\r\nspin_unlock_bh(&tiqn->sess_err_stats.lock);\r\n}\r\n}\r\niscsit_cause_connection_reinstatement(conn, 0);\r\niscsit_dec_conn_usage_count(conn);\r\n}\r\nvoid iscsit_mod_nopin_response_timer(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (!(conn->nopin_response_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\nmod_timer(&conn->nopin_response_timer,\r\n(get_jiffies_64() + na->nopin_response_timeout * HZ));\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nvoid iscsit_start_nopin_response_timer(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (conn->nopin_response_timer_flags & ISCSI_TF_RUNNING) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\ninit_timer(&conn->nopin_response_timer);\r\nconn->nopin_response_timer.expires =\r\n(get_jiffies_64() + na->nopin_response_timeout * HZ);\r\nconn->nopin_response_timer.data = (unsigned long)conn;\r\nconn->nopin_response_timer.function = iscsit_handle_nopin_response_timeout;\r\nconn->nopin_response_timer_flags &= ~ISCSI_TF_STOP;\r\nconn->nopin_response_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&conn->nopin_response_timer);\r\npr_debug("Started NOPIN Response Timer on CID: %d to %u"\r\n" seconds\n", conn->cid, na->nopin_response_timeout);\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nvoid iscsit_stop_nopin_response_timer(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (!(conn->nopin_response_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\nconn->nopin_response_timer_flags |= ISCSI_TF_STOP;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\ndel_timer_sync(&conn->nopin_response_timer);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nconn->nopin_response_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nstatic void iscsit_handle_nopin_timeout(unsigned long data)\r\n{\r\nstruct iscsi_conn *conn = (struct iscsi_conn *) data;\r\niscsit_inc_conn_usage_count(conn);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (conn->nopin_timer_flags & ISCSI_TF_STOP) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\niscsit_dec_conn_usage_count(conn);\r\nreturn;\r\n}\r\nconn->nopin_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\niscsit_add_nopin(conn, 1);\r\niscsit_dec_conn_usage_count(conn);\r\n}\r\nvoid __iscsit_start_nopin_timer(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nif (!na->nopin_timeout)\r\nreturn;\r\nif (conn->nopin_timer_flags & ISCSI_TF_RUNNING)\r\nreturn;\r\ninit_timer(&conn->nopin_timer);\r\nconn->nopin_timer.expires = (get_jiffies_64() + na->nopin_timeout * HZ);\r\nconn->nopin_timer.data = (unsigned long)conn;\r\nconn->nopin_timer.function = iscsit_handle_nopin_timeout;\r\nconn->nopin_timer_flags &= ~ISCSI_TF_STOP;\r\nconn->nopin_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&conn->nopin_timer);\r\npr_debug("Started NOPIN Timer on CID: %d at %u second"\r\n" interval\n", conn->cid, na->nopin_timeout);\r\n}\r\nvoid iscsit_start_nopin_timer(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *sess = conn->sess;\r\nstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\r\nif (!na->nopin_timeout)\r\nreturn;\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (conn->nopin_timer_flags & ISCSI_TF_RUNNING) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\ninit_timer(&conn->nopin_timer);\r\nconn->nopin_timer.expires = (get_jiffies_64() + na->nopin_timeout * HZ);\r\nconn->nopin_timer.data = (unsigned long)conn;\r\nconn->nopin_timer.function = iscsit_handle_nopin_timeout;\r\nconn->nopin_timer_flags &= ~ISCSI_TF_STOP;\r\nconn->nopin_timer_flags |= ISCSI_TF_RUNNING;\r\nadd_timer(&conn->nopin_timer);\r\npr_debug("Started NOPIN Timer on CID: %d at %u second"\r\n" interval\n", conn->cid, na->nopin_timeout);\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nvoid iscsit_stop_nopin_timer(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nif (!(conn->nopin_timer_flags & ISCSI_TF_RUNNING)) {\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\nreturn;\r\n}\r\nconn->nopin_timer_flags |= ISCSI_TF_STOP;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\ndel_timer_sync(&conn->nopin_timer);\r\nspin_lock_bh(&conn->nopin_timer_lock);\r\nconn->nopin_timer_flags &= ~ISCSI_TF_RUNNING;\r\nspin_unlock_bh(&conn->nopin_timer_lock);\r\n}\r\nint iscsit_send_tx_data(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn,\r\nint use_misc)\r\n{\r\nint tx_sent, tx_size;\r\nu32 iov_count;\r\nstruct kvec *iov;\r\nsend_data:\r\ntx_size = cmd->tx_size;\r\nif (!use_misc) {\r\niov = &cmd->iov_data[0];\r\niov_count = cmd->iov_data_count;\r\n} else {\r\niov = &cmd->iov_misc[0];\r\niov_count = cmd->iov_misc_count;\r\n}\r\ntx_sent = tx_data(conn, &iov[0], iov_count, tx_size);\r\nif (tx_size != tx_sent) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tx_data() returned -EAGAIN\n");\r\ngoto send_data;\r\n} else\r\nreturn -1;\r\n}\r\ncmd->tx_size = 0;\r\nreturn 0;\r\n}\r\nint iscsit_fe_sendpage_sg(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_conn *conn)\r\n{\r\nstruct scatterlist *sg = cmd->first_data_sg;\r\nstruct kvec iov;\r\nu32 tx_hdr_size, data_len;\r\nu32 offset = cmd->first_data_sg_off;\r\nint tx_sent, iov_off;\r\nsend_hdr:\r\ntx_hdr_size = ISCSI_HDR_LEN;\r\nif (conn->conn_ops->HeaderDigest)\r\ntx_hdr_size += ISCSI_CRC_LEN;\r\niov.iov_base = cmd->pdu;\r\niov.iov_len = tx_hdr_size;\r\ntx_sent = tx_data(conn, &iov, 1, tx_hdr_size);\r\nif (tx_hdr_size != tx_sent) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tx_data() returned -EAGAIN\n");\r\ngoto send_hdr;\r\n}\r\nreturn -1;\r\n}\r\ndata_len = cmd->tx_size - tx_hdr_size - cmd->padding;\r\nif (conn->conn_ops->DataDigest) {\r\ndata_len -= ISCSI_CRC_LEN;\r\nif (cmd->padding)\r\niov_off = (cmd->iov_data_count - 2);\r\nelse\r\niov_off = (cmd->iov_data_count - 1);\r\n} else {\r\niov_off = (cmd->iov_data_count - 1);\r\n}\r\nwhile (data_len) {\r\nu32 space = (sg->length - offset);\r\nu32 sub_len = min_t(u32, data_len, space);\r\nsend_pg:\r\ntx_sent = conn->sock->ops->sendpage(conn->sock,\r\nsg_page(sg), sg->offset + offset, sub_len, 0);\r\nif (tx_sent != sub_len) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tcp_sendpage() returned"\r\n" -EAGAIN\n");\r\ngoto send_pg;\r\n}\r\npr_err("tcp_sendpage() failure: %d\n",\r\ntx_sent);\r\nreturn -1;\r\n}\r\ndata_len -= sub_len;\r\noffset = 0;\r\nsg = sg_next(sg);\r\n}\r\nsend_padding:\r\nif (cmd->padding) {\r\nstruct kvec *iov_p = &cmd->iov_data[iov_off++];\r\ntx_sent = tx_data(conn, iov_p, 1, cmd->padding);\r\nif (cmd->padding != tx_sent) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tx_data() returned -EAGAIN\n");\r\ngoto send_padding;\r\n}\r\nreturn -1;\r\n}\r\n}\r\nsend_datacrc:\r\nif (conn->conn_ops->DataDigest) {\r\nstruct kvec *iov_d = &cmd->iov_data[iov_off];\r\ntx_sent = tx_data(conn, iov_d, 1, ISCSI_CRC_LEN);\r\nif (ISCSI_CRC_LEN != tx_sent) {\r\nif (tx_sent == -EAGAIN) {\r\npr_err("tx_data() returned -EAGAIN\n");\r\ngoto send_datacrc;\r\n}\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_tx_login_rsp(struct iscsi_conn *conn, u8 status_class, u8 status_detail)\r\n{\r\nu8 iscsi_hdr[ISCSI_HDR_LEN];\r\nint err;\r\nstruct kvec iov;\r\nstruct iscsi_login_rsp *hdr;\r\niscsit_collect_login_stats(conn, status_class, status_detail);\r\nmemset(&iov, 0, sizeof(struct kvec));\r\nmemset(&iscsi_hdr, 0x0, ISCSI_HDR_LEN);\r\nhdr = (struct iscsi_login_rsp *)&iscsi_hdr;\r\nhdr->opcode = ISCSI_OP_LOGIN_RSP;\r\nhdr->status_class = status_class;\r\nhdr->status_detail = status_detail;\r\nhdr->itt = cpu_to_be32(conn->login_itt);\r\niov.iov_base = &iscsi_hdr;\r\niov.iov_len = ISCSI_HDR_LEN;\r\nPRINT_BUFF(iscsi_hdr, ISCSI_HDR_LEN);\r\nerr = tx_data(conn, &iov, 1, ISCSI_HDR_LEN);\r\nif (err != ISCSI_HDR_LEN) {\r\npr_err("tx_data returned less than expected\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid iscsit_print_session_params(struct iscsi_session *sess)\r\n{\r\nstruct iscsi_conn *conn;\r\npr_debug("-----------------------------[Session Params for"\r\n" SID: %u]-----------------------------\n", sess->sid);\r\nspin_lock_bh(&sess->conn_lock);\r\nlist_for_each_entry(conn, &sess->sess_conn_list, conn_list)\r\niscsi_dump_conn_ops(conn->conn_ops);\r\nspin_unlock_bh(&sess->conn_lock);\r\niscsi_dump_sess_ops(sess->sess_ops);\r\n}\r\nstatic int iscsit_do_rx_data(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_data_count *count)\r\n{\r\nint data = count->data_length, rx_loop = 0, total_rx = 0, iov_len;\r\nstruct kvec *iov_p;\r\nstruct msghdr msg;\r\nif (!conn || !conn->sock || !conn->conn_ops)\r\nreturn -1;\r\nmemset(&msg, 0, sizeof(struct msghdr));\r\niov_p = count->iov;\r\niov_len = count->iov_count;\r\nwhile (total_rx < data) {\r\nrx_loop = kernel_recvmsg(conn->sock, &msg, iov_p, iov_len,\r\n(data - total_rx), MSG_WAITALL);\r\nif (rx_loop <= 0) {\r\npr_debug("rx_loop: %d total_rx: %d\n",\r\nrx_loop, total_rx);\r\nreturn rx_loop;\r\n}\r\ntotal_rx += rx_loop;\r\npr_debug("rx_loop: %d, total_rx: %d, data: %d\n",\r\nrx_loop, total_rx, data);\r\n}\r\nreturn total_rx;\r\n}\r\nstatic int iscsit_do_tx_data(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_data_count *count)\r\n{\r\nint data = count->data_length, total_tx = 0, tx_loop = 0, iov_len;\r\nstruct kvec *iov_p;\r\nstruct msghdr msg;\r\nif (!conn || !conn->sock || !conn->conn_ops)\r\nreturn -1;\r\nif (data <= 0) {\r\npr_err("Data length is: %d\n", data);\r\nreturn -1;\r\n}\r\nmemset(&msg, 0, sizeof(struct msghdr));\r\niov_p = count->iov;\r\niov_len = count->iov_count;\r\nwhile (total_tx < data) {\r\ntx_loop = kernel_sendmsg(conn->sock, &msg, iov_p, iov_len,\r\n(data - total_tx));\r\nif (tx_loop <= 0) {\r\npr_debug("tx_loop: %d total_tx %d\n",\r\ntx_loop, total_tx);\r\nreturn tx_loop;\r\n}\r\ntotal_tx += tx_loop;\r\npr_debug("tx_loop: %d, total_tx: %d, data: %d\n",\r\ntx_loop, total_tx, data);\r\n}\r\nreturn total_tx;\r\n}\r\nint rx_data(\r\nstruct iscsi_conn *conn,\r\nstruct kvec *iov,\r\nint iov_count,\r\nint data)\r\n{\r\nstruct iscsi_data_count c;\r\nif (!conn || !conn->sock || !conn->conn_ops)\r\nreturn -1;\r\nmemset(&c, 0, sizeof(struct iscsi_data_count));\r\nc.iov = iov;\r\nc.iov_count = iov_count;\r\nc.data_length = data;\r\nc.type = ISCSI_RX_DATA;\r\nreturn iscsit_do_rx_data(conn, &c);\r\n}\r\nint tx_data(\r\nstruct iscsi_conn *conn,\r\nstruct kvec *iov,\r\nint iov_count,\r\nint data)\r\n{\r\nstruct iscsi_data_count c;\r\nif (!conn || !conn->sock || !conn->conn_ops)\r\nreturn -1;\r\nmemset(&c, 0, sizeof(struct iscsi_data_count));\r\nc.iov = iov;\r\nc.iov_count = iov_count;\r\nc.data_length = data;\r\nc.type = ISCSI_TX_DATA;\r\nreturn iscsit_do_tx_data(conn, &c);\r\n}\r\nvoid iscsit_collect_login_stats(\r\nstruct iscsi_conn *conn,\r\nu8 status_class,\r\nu8 status_detail)\r\n{\r\nstruct iscsi_param *intrname = NULL;\r\nstruct iscsi_tiqn *tiqn;\r\nstruct iscsi_login_stats *ls;\r\ntiqn = iscsit_snmp_get_tiqn(conn);\r\nif (!tiqn)\r\nreturn;\r\nls = &tiqn->login_stats;\r\nspin_lock(&ls->lock);\r\nif (!strcmp(conn->login_ip, ls->last_intr_fail_ip_addr) &&\r\n((get_jiffies_64() - ls->last_fail_time) < 10)) {\r\nspin_unlock(&ls->lock);\r\nreturn;\r\n}\r\nif (status_class == ISCSI_STATUS_CLS_SUCCESS)\r\nls->accepts++;\r\nelse if (status_class == ISCSI_STATUS_CLS_REDIRECT) {\r\nls->redirects++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_REDIRECT;\r\n} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR) &&\r\n(status_detail == ISCSI_LOGIN_STATUS_AUTH_FAILED)) {\r\nls->authenticate_fails++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_AUTHENTICATE;\r\n} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR) &&\r\n(status_detail == ISCSI_LOGIN_STATUS_TGT_FORBIDDEN)) {\r\nls->authorize_fails++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_AUTHORIZE;\r\n} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR) &&\r\n(status_detail == ISCSI_LOGIN_STATUS_INIT_ERR)) {\r\nls->negotiate_fails++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_NEGOTIATE;\r\n} else {\r\nls->other_fails++;\r\nls->last_fail_type = ISCSI_LOGIN_FAIL_OTHER;\r\n}\r\nif (status_class != ISCSI_STATUS_CLS_SUCCESS) {\r\nif (conn->param_list)\r\nintrname = iscsi_find_param_from_key(INITIATORNAME,\r\nconn->param_list);\r\nstrcpy(ls->last_intr_fail_name,\r\n(intrname ? intrname->value : "Unknown"));\r\nls->last_intr_fail_ip_family = conn->sock->sk->sk_family;\r\nsnprintf(ls->last_intr_fail_ip_addr, IPV6_ADDRESS_SPACE,\r\n"%s", conn->login_ip);\r\nls->last_fail_time = get_jiffies_64();\r\n}\r\nspin_unlock(&ls->lock);\r\n}\r\nstruct iscsi_tiqn *iscsit_snmp_get_tiqn(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_portal_group *tpg;\r\nif (!conn || !conn->sess)\r\nreturn NULL;\r\ntpg = conn->sess->tpg;\r\nif (!tpg)\r\nreturn NULL;\r\nif (!tpg->tpg_tiqn)\r\nreturn NULL;\r\nreturn tpg->tpg_tiqn;\r\n}
