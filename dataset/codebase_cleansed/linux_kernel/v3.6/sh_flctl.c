static void empty_fifo(struct sh_flctl *flctl)\r\n{\r\nwritel(0x000c0000, FLINTDMACR(flctl));\r\nwritel(0x00000000, FLINTDMACR(flctl));\r\n}\r\nstatic void start_translation(struct sh_flctl *flctl)\r\n{\r\nwriteb(TRSTRT, FLTRCR(flctl));\r\n}\r\nstatic void timeout_error(struct sh_flctl *flctl, const char *str)\r\n{\r\ndev_err(&flctl->pdev->dev, "Timeout occurred in %s\n", str);\r\n}\r\nstatic void wait_completion(struct sh_flctl *flctl)\r\n{\r\nuint32_t timeout = LOOP_TIMEOUT_MAX;\r\nwhile (timeout--) {\r\nif (readb(FLTRCR(flctl)) & TREND) {\r\nwriteb(0x0, FLTRCR(flctl));\r\nreturn;\r\n}\r\nudelay(1);\r\n}\r\ntimeout_error(flctl, __func__);\r\nwriteb(0x0, FLTRCR(flctl));\r\n}\r\nstatic void set_addr(struct mtd_info *mtd, int column, int page_addr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nuint32_t addr = 0;\r\nif (column == -1) {\r\naddr = page_addr;\r\n} else if (page_addr != -1) {\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nif (flctl->page_size) {\r\naddr = column & 0x0FFF;\r\naddr |= (page_addr & 0xff) << 16;\r\naddr |= ((page_addr >> 8) & 0xff) << 24;\r\nif (flctl->rw_ADRCNT == ADRCNT2_E) {\r\nuint32_t addr2;\r\naddr2 = (page_addr >> 16) & 0xff;\r\nwritel(addr2, FLADR2(flctl));\r\n}\r\n} else {\r\naddr = column;\r\naddr |= (page_addr & 0xff) << 8;\r\naddr |= ((page_addr >> 8) & 0xff) << 16;\r\naddr |= ((page_addr >> 16) & 0xff) << 24;\r\n}\r\n}\r\nwritel(addr, FLADR(flctl));\r\n}\r\nstatic void wait_rfifo_ready(struct sh_flctl *flctl)\r\n{\r\nuint32_t timeout = LOOP_TIMEOUT_MAX;\r\nwhile (timeout--) {\r\nuint32_t val;\r\nval = readl(FLDTCNTR(flctl)) >> 16;\r\nif (val & 0xFF)\r\nreturn;\r\nudelay(1);\r\n}\r\ntimeout_error(flctl, __func__);\r\n}\r\nstatic void wait_wfifo_ready(struct sh_flctl *flctl)\r\n{\r\nuint32_t len, timeout = LOOP_TIMEOUT_MAX;\r\nwhile (timeout--) {\r\nlen = (readl(FLDTCNTR(flctl)) >> 16) & 0xFF;\r\nif (len >= 4)\r\nreturn;\r\nudelay(1);\r\n}\r\ntimeout_error(flctl, __func__);\r\n}\r\nstatic int wait_recfifo_ready(struct sh_flctl *flctl, int sector_number)\r\n{\r\nuint32_t timeout = LOOP_TIMEOUT_MAX;\r\nint checked[4];\r\nvoid __iomem *ecc_reg[4];\r\nint i;\r\nuint32_t data, size;\r\nmemset(checked, 0, sizeof(checked));\r\nwhile (timeout--) {\r\nsize = readl(FLDTCNTR(flctl)) >> 24;\r\nif (size & 0xFF)\r\nreturn 0;\r\nif (readl(FL4ECCCR(flctl)) & _4ECCFA)\r\nreturn 1;\r\nudelay(1);\r\nif (!(readl(FL4ECCCR(flctl)) & _4ECCEND))\r\ncontinue;\r\necc_reg[0] = FL4ECCRESULT0(flctl);\r\necc_reg[1] = FL4ECCRESULT1(flctl);\r\necc_reg[2] = FL4ECCRESULT2(flctl);\r\necc_reg[3] = FL4ECCRESULT3(flctl);\r\nfor (i = 0; i < 3; i++) {\r\ndata = readl(ecc_reg[i]);\r\nif (data != INIT_FL4ECCRESULT_VAL && !checked[i]) {\r\nuint8_t org;\r\nint index;\r\nif (flctl->page_size)\r\nindex = (512 * sector_number) +\r\n(data >> 16);\r\nelse\r\nindex = data >> 16;\r\norg = flctl->done_buff[index];\r\nflctl->done_buff[index] = org ^ (data & 0xFF);\r\nchecked[i] = 1;\r\n}\r\n}\r\nwritel(0, FL4ECCCR(flctl));\r\n}\r\ntimeout_error(flctl, __func__);\r\nreturn 1;\r\n}\r\nstatic void wait_wecfifo_ready(struct sh_flctl *flctl)\r\n{\r\nuint32_t timeout = LOOP_TIMEOUT_MAX;\r\nuint32_t len;\r\nwhile (timeout--) {\r\nlen = (readl(FLDTCNTR(flctl)) >> 24) & 0xFF;\r\nif (len >= 4)\r\nreturn;\r\nudelay(1);\r\n}\r\ntimeout_error(flctl, __func__);\r\n}\r\nstatic void read_datareg(struct sh_flctl *flctl, int offset)\r\n{\r\nunsigned long data;\r\nunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\r\nwait_completion(flctl);\r\ndata = readl(FLDATAR(flctl));\r\n*buf = le32_to_cpu(data);\r\n}\r\nstatic void read_fiforeg(struct sh_flctl *flctl, int rlen, int offset)\r\n{\r\nint i, len_4align;\r\nunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\r\nvoid *fifo_addr = (void *)FLDTFIFO(flctl);\r\nlen_4align = (rlen + 3) / 4;\r\nfor (i = 0; i < len_4align; i++) {\r\nwait_rfifo_ready(flctl);\r\nbuf[i] = readl(fifo_addr);\r\nbuf[i] = be32_to_cpu(buf[i]);\r\n}\r\n}\r\nstatic int read_ecfiforeg(struct sh_flctl *flctl, uint8_t *buff, int sector)\r\n{\r\nint i;\r\nunsigned long *ecc_buf = (unsigned long *)buff;\r\nvoid *fifo_addr = (void *)FLECFIFO(flctl);\r\nfor (i = 0; i < 4; i++) {\r\nif (wait_recfifo_ready(flctl , sector))\r\nreturn 1;\r\necc_buf[i] = readl(fifo_addr);\r\necc_buf[i] = be32_to_cpu(ecc_buf[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void write_fiforeg(struct sh_flctl *flctl, int rlen, int offset)\r\n{\r\nint i, len_4align;\r\nunsigned long *data = (unsigned long *)&flctl->done_buff[offset];\r\nvoid *fifo_addr = (void *)FLDTFIFO(flctl);\r\nlen_4align = (rlen + 3) / 4;\r\nfor (i = 0; i < len_4align; i++) {\r\nwait_wfifo_ready(flctl);\r\nwritel(cpu_to_be32(data[i]), fifo_addr);\r\n}\r\n}\r\nstatic void set_cmd_regs(struct mtd_info *mtd, uint32_t cmd, uint32_t flcmcdr_val)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nuint32_t flcmncr_val = flctl->flcmncr_base & ~SEL_16BIT;\r\nuint32_t flcmdcr_val, addr_len_bytes = 0;\r\nif (flctl->page_size)\r\nflcmncr_val |= SNAND_E;\r\nelse\r\nflcmncr_val &= ~SNAND_E;\r\nflcmdcr_val = DOCMD1_E | DOADR_E;\r\nswitch (cmd) {\r\ncase NAND_CMD_ERASE1:\r\naddr_len_bytes = flctl->erase_ADRCNT;\r\nflcmdcr_val |= DOCMD2_E;\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\ncase NAND_CMD_RNDOUT:\r\naddr_len_bytes = flctl->rw_ADRCNT;\r\nflcmdcr_val |= CDSRC_E;\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\nflcmncr_val |= SEL_16BIT;\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nflcmdcr_val &= ~DOADR_E;\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\naddr_len_bytes = flctl->rw_ADRCNT;\r\nflcmdcr_val |= DOCMD2_E | CDSRC_E | SELRW;\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\nflcmncr_val |= SEL_16BIT;\r\nbreak;\r\ncase NAND_CMD_READID:\r\nflcmncr_val &= ~SNAND_E;\r\nflcmdcr_val |= CDSRC_E;\r\naddr_len_bytes = ADRCNT_1;\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\ncase NAND_CMD_RESET:\r\nflcmncr_val &= ~SNAND_E;\r\nflcmdcr_val &= ~(DOADR_E | DOSR_E);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nflcmdcr_val |= addr_len_bytes;\r\nwritel(flcmncr_val, FLCMNCR(flctl));\r\nwritel(flcmdcr_val, FLCMDCR(flctl));\r\nwritel(flcmcdr_val, FLCMCDR(flctl));\r\n}\r\nstatic int flctl_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nuint8_t *p = buf;\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\r\nchip->read_buf(mtd, p, eccsize);\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\r\nif (flctl->hwecc_cant_correct[i])\r\nmtd->ecc_stats.failed++;\r\nelse\r\nmtd->ecc_stats.corrected += 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void flctl_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nint i, eccsize = chip->ecc.size;\r\nint eccbytes = chip->ecc.bytes;\r\nint eccsteps = chip->ecc.steps;\r\nconst uint8_t *p = buf;\r\nfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\r\nchip->write_buf(mtd, p, eccsize);\r\n}\r\nstatic void execmd_read_page_sector(struct mtd_info *mtd, int page_addr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint sector, page_sectors;\r\nif (flctl->page_size)\r\npage_sectors = 4;\r\nelse\r\npage_sectors = 1;\r\nwritel(readl(FLCMNCR(flctl)) | ACM_SACCES_MODE | _4ECCCORRECT,\r\nFLCMNCR(flctl));\r\nset_cmd_regs(mtd, NAND_CMD_READ0,\r\n(NAND_CMD_READSTART << 8) | NAND_CMD_READ0);\r\nfor (sector = 0; sector < page_sectors; sector++) {\r\nint ret;\r\nempty_fifo(flctl);\r\nwritel(readl(FLCMDCR(flctl)) | 1, FLCMDCR(flctl));\r\nwritel(page_addr << 2 | sector, FLADR(flctl));\r\nstart_translation(flctl);\r\nread_fiforeg(flctl, 512, 512 * sector);\r\nret = read_ecfiforeg(flctl,\r\n&flctl->done_buff[mtd->writesize + 16 * sector],\r\nsector);\r\nif (ret)\r\nflctl->hwecc_cant_correct[sector] = 1;\r\nwritel(0x0, FL4ECCCR(flctl));\r\nwait_completion(flctl);\r\n}\r\nwritel(readl(FLCMNCR(flctl)) & ~(ACM_SACCES_MODE | _4ECCCORRECT),\r\nFLCMNCR(flctl));\r\n}\r\nstatic void execmd_read_oob(struct mtd_info *mtd, int page_addr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nset_cmd_regs(mtd, NAND_CMD_READ0,\r\n(NAND_CMD_READSTART << 8) | NAND_CMD_READ0);\r\nempty_fifo(flctl);\r\nif (flctl->page_size) {\r\nint i;\r\nfor (i = 0; i < 16 * 3; i++)\r\nflctl->done_buff[i] = 0xFF;\r\nset_addr(mtd, 3 * 528 + 512, page_addr);\r\nwritel(16, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nread_fiforeg(flctl, 16, 16 * 3);\r\nwait_completion(flctl);\r\n} else {\r\nset_addr(mtd, 512, page_addr);\r\nwritel(16, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nread_fiforeg(flctl, 16, 0);\r\nwait_completion(flctl);\r\n}\r\n}\r\nstatic void execmd_write_page_sector(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint i, page_addr = flctl->seqin_page_addr;\r\nint sector, page_sectors;\r\nif (flctl->page_size)\r\npage_sectors = 4;\r\nelse\r\npage_sectors = 1;\r\nwritel(readl(FLCMNCR(flctl)) | ACM_SACCES_MODE, FLCMNCR(flctl));\r\nset_cmd_regs(mtd, NAND_CMD_PAGEPROG,\r\n(NAND_CMD_PAGEPROG << 8) | NAND_CMD_SEQIN);\r\nfor (sector = 0; sector < page_sectors; sector++) {\r\nempty_fifo(flctl);\r\nwritel(readl(FLCMDCR(flctl)) | 1, FLCMDCR(flctl));\r\nwritel(page_addr << 2 | sector, FLADR(flctl));\r\nstart_translation(flctl);\r\nwrite_fiforeg(flctl, 512, 512 * sector);\r\nfor (i = 0; i < 4; i++) {\r\nwait_wecfifo_ready(flctl);\r\nwritel(0xFFFFFFFF, FLECFIFO(flctl));\r\n}\r\nwait_completion(flctl);\r\n}\r\nwritel(readl(FLCMNCR(flctl)) & ~ACM_SACCES_MODE, FLCMNCR(flctl));\r\n}\r\nstatic void execmd_write_oob(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint page_addr = flctl->seqin_page_addr;\r\nint sector, page_sectors;\r\nif (flctl->page_size) {\r\nsector = 3;\r\npage_sectors = 4;\r\n} else {\r\nsector = 0;\r\npage_sectors = 1;\r\n}\r\nset_cmd_regs(mtd, NAND_CMD_PAGEPROG,\r\n(NAND_CMD_PAGEPROG << 8) | NAND_CMD_SEQIN);\r\nfor (; sector < page_sectors; sector++) {\r\nempty_fifo(flctl);\r\nset_addr(mtd, sector * 528 + 512, page_addr);\r\nwritel(16, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nwrite_fiforeg(flctl, 16, 16 * sector);\r\nwait_completion(flctl);\r\n}\r\n}\r\nstatic void flctl_cmdfunc(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nuint32_t read_cmd = 0;\r\npm_runtime_get_sync(&flctl->pdev->dev);\r\nflctl->read_bytes = 0;\r\nif (command != NAND_CMD_PAGEPROG)\r\nflctl->index = 0;\r\nswitch (command) {\r\ncase NAND_CMD_READ1:\r\ncase NAND_CMD_READ0:\r\nif (flctl->hwecc) {\r\nexecmd_read_page_sector(mtd, page_addr);\r\nbreak;\r\n}\r\nif (flctl->page_size)\r\nset_cmd_regs(mtd, command, (NAND_CMD_READSTART << 8)\r\n| command);\r\nelse\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, 0, page_addr);\r\nflctl->read_bytes = mtd->writesize + mtd->oobsize;\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nflctl->index += column;\r\ngoto read_normal_exit;\r\ncase NAND_CMD_READOOB:\r\nif (flctl->hwecc) {\r\nexecmd_read_oob(mtd, page_addr);\r\nbreak;\r\n}\r\nif (flctl->page_size) {\r\nset_cmd_regs(mtd, command, (NAND_CMD_READSTART << 8)\r\n| NAND_CMD_READ0);\r\nset_addr(mtd, mtd->writesize, page_addr);\r\n} else {\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, 0, page_addr);\r\n}\r\nflctl->read_bytes = mtd->oobsize;\r\ngoto read_normal_exit;\r\ncase NAND_CMD_RNDOUT:\r\nif (flctl->hwecc)\r\nbreak;\r\nif (flctl->page_size)\r\nset_cmd_regs(mtd, command, (NAND_CMD_RNDOUTSTART << 8)\r\n| command);\r\nelse\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, column, 0);\r\nflctl->read_bytes = mtd->writesize + mtd->oobsize - column;\r\ngoto read_normal_exit;\r\ncase NAND_CMD_READID:\r\nset_cmd_regs(mtd, command, command);\r\nif (flctl->chip.options & NAND_BUSWIDTH_16)\r\ncolumn <<= 1;\r\nset_addr(mtd, column, 0);\r\nflctl->read_bytes = 8;\r\nwritel(flctl->read_bytes, FLDTCNTR(flctl));\r\nempty_fifo(flctl);\r\nstart_translation(flctl);\r\nread_fiforeg(flctl, flctl->read_bytes, 0);\r\nwait_completion(flctl);\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\nflctl->erase1_page_addr = page_addr;\r\nbreak;\r\ncase NAND_CMD_ERASE2:\r\nset_cmd_regs(mtd, NAND_CMD_ERASE1,\r\n(command << 8) | NAND_CMD_ERASE1);\r\nset_addr(mtd, -1, flctl->erase1_page_addr);\r\nstart_translation(flctl);\r\nwait_completion(flctl);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nif (!flctl->page_size) {\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nread_cmd = NAND_CMD_READOOB;\r\n} else if (column < 256) {\r\nread_cmd = NAND_CMD_READ0;\r\n} else {\r\ncolumn -= 256;\r\nread_cmd = NAND_CMD_READ1;\r\n}\r\n}\r\nflctl->seqin_column = column;\r\nflctl->seqin_page_addr = page_addr;\r\nflctl->seqin_read_cmd = read_cmd;\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nempty_fifo(flctl);\r\nif (!flctl->page_size) {\r\nset_cmd_regs(mtd, NAND_CMD_SEQIN,\r\nflctl->seqin_read_cmd);\r\nset_addr(mtd, -1, -1);\r\nwritel(0, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nwait_completion(flctl);\r\n}\r\nif (flctl->hwecc) {\r\nif (flctl->seqin_column == mtd->writesize)\r\nexecmd_write_oob(mtd);\r\nelse if (!flctl->seqin_column)\r\nexecmd_write_page_sector(mtd);\r\nelse\r\nprintk(KERN_ERR "Invalid address !?\n");\r\nbreak;\r\n}\r\nset_cmd_regs(mtd, command, (command << 8) | NAND_CMD_SEQIN);\r\nset_addr(mtd, flctl->seqin_column, flctl->seqin_page_addr);\r\nwritel(flctl->index, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nwrite_fiforeg(flctl, flctl->index, 0);\r\nwait_completion(flctl);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, -1, -1);\r\nflctl->read_bytes = 1;\r\nwritel(flctl->read_bytes, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nread_datareg(flctl, 0);\r\nbreak;\r\ncase NAND_CMD_RESET:\r\nset_cmd_regs(mtd, command, command);\r\nset_addr(mtd, -1, -1);\r\nwritel(0, FLDTCNTR(flctl));\r\nstart_translation(flctl);\r\nwait_completion(flctl);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ngoto runtime_exit;\r\nread_normal_exit:\r\nwritel(flctl->read_bytes, FLDTCNTR(flctl));\r\nempty_fifo(flctl);\r\nstart_translation(flctl);\r\nread_fiforeg(flctl, flctl->read_bytes, 0);\r\nwait_completion(flctl);\r\nruntime_exit:\r\npm_runtime_put_sync(&flctl->pdev->dev);\r\nreturn;\r\n}\r\nstatic void flctl_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint ret;\r\nswitch (chipnr) {\r\ncase -1:\r\nflctl->flcmncr_base &= ~CE0_ENABLE;\r\npm_runtime_get_sync(&flctl->pdev->dev);\r\nwritel(flctl->flcmncr_base, FLCMNCR(flctl));\r\nif (flctl->qos_request) {\r\ndev_pm_qos_remove_request(&flctl->pm_qos);\r\nflctl->qos_request = 0;\r\n}\r\npm_runtime_put_sync(&flctl->pdev->dev);\r\nbreak;\r\ncase 0:\r\nflctl->flcmncr_base |= CE0_ENABLE;\r\nif (!flctl->qos_request) {\r\nret = dev_pm_qos_add_request(&flctl->pdev->dev,\r\n&flctl->pm_qos, 100);\r\nif (ret < 0)\r\ndev_err(&flctl->pdev->dev,\r\n"PM QoS request failed: %d\n", ret);\r\nflctl->qos_request = 1;\r\n}\r\nif (flctl->holden) {\r\npm_runtime_get_sync(&flctl->pdev->dev);\r\nwritel(HOLDEN, FLHOLDCR(flctl));\r\npm_runtime_put_sync(&flctl->pdev->dev);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void flctl_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint i, index = flctl->index;\r\nfor (i = 0; i < len; i++)\r\nflctl->done_buff[index + i] = buf[i];\r\nflctl->index += len;\r\n}\r\nstatic uint8_t flctl_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint index = flctl->index;\r\nuint8_t data;\r\ndata = flctl->done_buff[index];\r\nflctl->index++;\r\nreturn data;\r\n}\r\nstatic uint16_t flctl_read_word(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nint index = flctl->index;\r\nuint16_t data;\r\nuint16_t *buf = (uint16_t *)&flctl->done_buff[index];\r\ndata = *buf;\r\nflctl->index += 2;\r\nreturn data;\r\n}\r\nstatic void flctl_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = flctl_read_byte(mtd);\r\n}\r\nstatic int flctl_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (buf[i] != flctl_read_byte(mtd))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int flctl_chip_init_tail(struct mtd_info *mtd)\r\n{\r\nstruct sh_flctl *flctl = mtd_to_flctl(mtd);\r\nstruct nand_chip *chip = &flctl->chip;\r\nif (mtd->writesize == 512) {\r\nflctl->page_size = 0;\r\nif (chip->chipsize > (32 << 20)) {\r\nflctl->rw_ADRCNT = ADRCNT_4;\r\nflctl->erase_ADRCNT = ADRCNT_3;\r\n} else if (chip->chipsize > (2 << 16)) {\r\nflctl->rw_ADRCNT = ADRCNT_3;\r\nflctl->erase_ADRCNT = ADRCNT_2;\r\n} else {\r\nflctl->rw_ADRCNT = ADRCNT_2;\r\nflctl->erase_ADRCNT = ADRCNT_1;\r\n}\r\n} else {\r\nflctl->page_size = 1;\r\nif (chip->chipsize > (128 << 20)) {\r\nflctl->rw_ADRCNT = ADRCNT2_E;\r\nflctl->erase_ADRCNT = ADRCNT_3;\r\n} else if (chip->chipsize > (8 << 16)) {\r\nflctl->rw_ADRCNT = ADRCNT_4;\r\nflctl->erase_ADRCNT = ADRCNT_2;\r\n} else {\r\nflctl->rw_ADRCNT = ADRCNT_3;\r\nflctl->erase_ADRCNT = ADRCNT_1;\r\n}\r\n}\r\nif (flctl->hwecc) {\r\nif (mtd->writesize == 512) {\r\nchip->ecc.layout = &flctl_4secc_oob_16;\r\nchip->badblock_pattern = &flctl_4secc_smallpage;\r\n} else {\r\nchip->ecc.layout = &flctl_4secc_oob_64;\r\nchip->badblock_pattern = &flctl_4secc_largepage;\r\n}\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 10;\r\nchip->ecc.strength = 4;\r\nchip->ecc.read_page = flctl_read_page_hwecc;\r\nchip->ecc.write_page = flctl_write_page_hwecc;\r\nchip->ecc.mode = NAND_ECC_HW;\r\nflctl->flcmncr_base |= _4ECCEN | ECCPOS2 | ECCPOS_02;\r\n} else {\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit flctl_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct sh_flctl *flctl;\r\nstruct mtd_info *flctl_mtd;\r\nstruct nand_chip *nand;\r\nstruct sh_flctl_platform_data *pdata;\r\nint ret = -ENXIO;\r\npdata = pdev->dev.platform_data;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nflctl = kzalloc(sizeof(struct sh_flctl), GFP_KERNEL);\r\nif (!flctl) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to get I/O memory\n");\r\ngoto err_iomap;\r\n}\r\nflctl->reg = ioremap(res->start, resource_size(res));\r\nif (flctl->reg == NULL) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\ngoto err_iomap;\r\n}\r\nplatform_set_drvdata(pdev, flctl);\r\nflctl_mtd = &flctl->mtd;\r\nnand = &flctl->chip;\r\nflctl_mtd->priv = nand;\r\nflctl->pdev = pdev;\r\nflctl->flcmncr_base = pdata->flcmncr_val;\r\nflctl->hwecc = pdata->has_hwecc;\r\nflctl->holden = pdata->use_holden;\r\nnand->chip_delay = 20;\r\nnand->read_byte = flctl_read_byte;\r\nnand->write_buf = flctl_write_buf;\r\nnand->read_buf = flctl_read_buf;\r\nnand->verify_buf = flctl_verify_buf;\r\nnand->select_chip = flctl_select_chip;\r\nnand->cmdfunc = flctl_cmdfunc;\r\nif (pdata->flcmncr_val & SEL_16BIT) {\r\nnand->options |= NAND_BUSWIDTH_16;\r\nnand->read_word = flctl_read_word;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_resume(&pdev->dev);\r\nret = nand_scan_ident(flctl_mtd, 1, NULL);\r\nif (ret)\r\ngoto err_chip;\r\nret = flctl_chip_init_tail(flctl_mtd);\r\nif (ret)\r\ngoto err_chip;\r\nret = nand_scan_tail(flctl_mtd);\r\nif (ret)\r\ngoto err_chip;\r\nmtd_device_register(flctl_mtd, pdata->parts, pdata->nr_parts);\r\nreturn 0;\r\nerr_chip:\r\npm_runtime_disable(&pdev->dev);\r\nerr_iomap:\r\nkfree(flctl);\r\nreturn ret;\r\n}\r\nstatic int __devexit flctl_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_flctl *flctl = platform_get_drvdata(pdev);\r\nnand_release(&flctl->mtd);\r\npm_runtime_disable(&pdev->dev);\r\nkfree(flctl);\r\nreturn 0;\r\n}\r\nstatic int __init flctl_nand_init(void)\r\n{\r\nreturn platform_driver_probe(&flctl_driver, flctl_probe);\r\n}\r\nstatic void __exit flctl_nand_cleanup(void)\r\n{\r\nplatform_driver_unregister(&flctl_driver);\r\n}
