static inline int ttm_mem_type_from_flags(uint32_t flags, uint32_t *mem_type)\r\n{\r\nint i;\r\nfor (i = 0; i <= TTM_PL_PRIV5; i++)\r\nif (flags & (1 << i)) {\r\n*mem_type = i;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ttm_mem_type_debug(struct ttm_bo_device *bdev, int mem_type)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem_type];\r\npr_err(" has_type: %d\n", man->has_type);\r\npr_err(" use_type: %d\n", man->use_type);\r\npr_err(" flags: 0x%08X\n", man->flags);\r\npr_err(" gpu_offset: 0x%08lX\n", man->gpu_offset);\r\npr_err(" size: %llu\n", man->size);\r\npr_err(" available_caching: 0x%08X\n", man->available_caching);\r\npr_err(" default_caching: 0x%08X\n", man->default_caching);\r\nif (mem_type != TTM_PL_SYSTEM)\r\n(*man->func->debug)(man, TTM_PFX);\r\n}\r\nstatic void ttm_bo_mem_space_debug(struct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement)\r\n{\r\nint i, ret, mem_type;\r\npr_err("No space for %p (%lu pages, %luK, %luM)\n",\r\nbo, bo->mem.num_pages, bo->mem.size >> 10,\r\nbo->mem.size >> 20);\r\nfor (i = 0; i < placement->num_placement; i++) {\r\nret = ttm_mem_type_from_flags(placement->placement[i],\r\n&mem_type);\r\nif (ret)\r\nreturn;\r\npr_err(" placement[%d]=0x%08X (%d)\n",\r\ni, placement->placement[i], mem_type);\r\nttm_mem_type_debug(bo->bdev, mem_type);\r\n}\r\n}\r\nstatic ssize_t ttm_bo_global_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct ttm_bo_global *glob =\r\ncontainer_of(kobj, struct ttm_bo_global, kobj);\r\nreturn snprintf(buffer, PAGE_SIZE, "%lu\n",\r\n(unsigned long) atomic_read(&glob->bo_count));\r\n}\r\nstatic inline uint32_t ttm_bo_type_flags(unsigned type)\r\n{\r\nreturn 1 << (type);\r\n}\r\nstatic void ttm_bo_release_list(struct kref *list_kref)\r\n{\r\nstruct ttm_buffer_object *bo =\r\ncontainer_of(list_kref, struct ttm_buffer_object, list_kref);\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nsize_t acc_size = bo->acc_size;\r\nBUG_ON(atomic_read(&bo->list_kref.refcount));\r\nBUG_ON(atomic_read(&bo->kref.refcount));\r\nBUG_ON(atomic_read(&bo->cpu_writers));\r\nBUG_ON(bo->sync_obj != NULL);\r\nBUG_ON(bo->mem.mm_node != NULL);\r\nBUG_ON(!list_empty(&bo->lru));\r\nBUG_ON(!list_empty(&bo->ddestroy));\r\nif (bo->ttm)\r\nttm_tt_destroy(bo->ttm);\r\natomic_dec(&bo->glob->bo_count);\r\nif (bo->destroy)\r\nbo->destroy(bo);\r\nelse {\r\nkfree(bo);\r\n}\r\nttm_mem_global_free(bdev->glob->mem_glob, acc_size);\r\n}\r\nint ttm_bo_wait_unreserved(struct ttm_buffer_object *bo, bool interruptible)\r\n{\r\nif (interruptible) {\r\nreturn wait_event_interruptible(bo->event_queue,\r\natomic_read(&bo->reserved) == 0);\r\n} else {\r\nwait_event(bo->event_queue, atomic_read(&bo->reserved) == 0);\r\nreturn 0;\r\n}\r\n}\r\nvoid ttm_bo_add_to_lru(struct ttm_buffer_object *bo)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_mem_type_manager *man;\r\nBUG_ON(!atomic_read(&bo->reserved));\r\nif (!(bo->mem.placement & TTM_PL_FLAG_NO_EVICT)) {\r\nBUG_ON(!list_empty(&bo->lru));\r\nman = &bdev->man[bo->mem.mem_type];\r\nlist_add_tail(&bo->lru, &man->lru);\r\nkref_get(&bo->list_kref);\r\nif (bo->ttm != NULL) {\r\nlist_add_tail(&bo->swap, &bo->glob->swap_lru);\r\nkref_get(&bo->list_kref);\r\n}\r\n}\r\n}\r\nint ttm_bo_del_from_lru(struct ttm_buffer_object *bo)\r\n{\r\nint put_count = 0;\r\nif (!list_empty(&bo->swap)) {\r\nlist_del_init(&bo->swap);\r\n++put_count;\r\n}\r\nif (!list_empty(&bo->lru)) {\r\nlist_del_init(&bo->lru);\r\n++put_count;\r\n}\r\nreturn put_count;\r\n}\r\nint ttm_bo_reserve_locked(struct ttm_buffer_object *bo,\r\nbool interruptible,\r\nbool no_wait, bool use_sequence, uint32_t sequence)\r\n{\r\nstruct ttm_bo_global *glob = bo->glob;\r\nint ret;\r\nwhile (unlikely(atomic_cmpxchg(&bo->reserved, 0, 1) != 0)) {\r\nif (use_sequence && bo->seq_valid) {\r\nif (unlikely(sequence == bo->val_seq))\r\nreturn -EDEADLK;\r\nif (unlikely(sequence - bo->val_seq < (1 << 31)))\r\nreturn -EAGAIN;\r\n}\r\nif (no_wait)\r\nreturn -EBUSY;\r\nspin_unlock(&glob->lru_lock);\r\nret = ttm_bo_wait_unreserved(bo, interruptible);\r\nspin_lock(&glob->lru_lock);\r\nif (unlikely(ret))\r\nreturn ret;\r\n}\r\nif (use_sequence) {\r\nif (unlikely((bo->val_seq - sequence < (1 << 31))\r\n|| !bo->seq_valid))\r\nwake_up_all(&bo->event_queue);\r\nbo->val_seq = sequence;\r\nbo->seq_valid = true;\r\n} else {\r\nbo->seq_valid = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ttm_bo_ref_bug(struct kref *list_kref)\r\n{\r\nBUG();\r\n}\r\nvoid ttm_bo_list_ref_sub(struct ttm_buffer_object *bo, int count,\r\nbool never_free)\r\n{\r\nkref_sub(&bo->list_kref, count,\r\n(never_free) ? ttm_bo_ref_bug : ttm_bo_release_list);\r\n}\r\nint ttm_bo_reserve(struct ttm_buffer_object *bo,\r\nbool interruptible,\r\nbool no_wait, bool use_sequence, uint32_t sequence)\r\n{\r\nstruct ttm_bo_global *glob = bo->glob;\r\nint put_count = 0;\r\nint ret;\r\nspin_lock(&glob->lru_lock);\r\nret = ttm_bo_reserve_locked(bo, interruptible, no_wait, use_sequence,\r\nsequence);\r\nif (likely(ret == 0))\r\nput_count = ttm_bo_del_from_lru(bo);\r\nspin_unlock(&glob->lru_lock);\r\nttm_bo_list_ref_sub(bo, put_count, true);\r\nreturn ret;\r\n}\r\nvoid ttm_bo_unreserve_locked(struct ttm_buffer_object *bo)\r\n{\r\nttm_bo_add_to_lru(bo);\r\natomic_set(&bo->reserved, 0);\r\nwake_up_all(&bo->event_queue);\r\n}\r\nvoid ttm_bo_unreserve(struct ttm_buffer_object *bo)\r\n{\r\nstruct ttm_bo_global *glob = bo->glob;\r\nspin_lock(&glob->lru_lock);\r\nttm_bo_unreserve_locked(bo);\r\nspin_unlock(&glob->lru_lock);\r\n}\r\nstatic int ttm_bo_add_ttm(struct ttm_buffer_object *bo, bool zero_alloc)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_bo_global *glob = bo->glob;\r\nint ret = 0;\r\nuint32_t page_flags = 0;\r\nTTM_ASSERT_LOCKED(&bo->mutex);\r\nbo->ttm = NULL;\r\nif (bdev->need_dma32)\r\npage_flags |= TTM_PAGE_FLAG_DMA32;\r\nswitch (bo->type) {\r\ncase ttm_bo_type_device:\r\nif (zero_alloc)\r\npage_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;\r\ncase ttm_bo_type_kernel:\r\nbo->ttm = bdev->driver->ttm_tt_create(bdev, bo->num_pages << PAGE_SHIFT,\r\npage_flags, glob->dummy_read_page);\r\nif (unlikely(bo->ttm == NULL))\r\nret = -ENOMEM;\r\nbreak;\r\ncase ttm_bo_type_sg:\r\nbo->ttm = bdev->driver->ttm_tt_create(bdev, bo->num_pages << PAGE_SHIFT,\r\npage_flags | TTM_PAGE_FLAG_SG,\r\nglob->dummy_read_page);\r\nif (unlikely(bo->ttm == NULL)) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nbo->ttm->sg = bo->sg;\r\nbreak;\r\ndefault:\r\npr_err("Illegal buffer object type\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ttm_bo_handle_move_mem(struct ttm_buffer_object *bo,\r\nstruct ttm_mem_reg *mem,\r\nbool evict, bool interruptible,\r\nbool no_wait_reserve, bool no_wait_gpu)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nbool old_is_pci = ttm_mem_reg_is_pci(bdev, &bo->mem);\r\nbool new_is_pci = ttm_mem_reg_is_pci(bdev, mem);\r\nstruct ttm_mem_type_manager *old_man = &bdev->man[bo->mem.mem_type];\r\nstruct ttm_mem_type_manager *new_man = &bdev->man[mem->mem_type];\r\nint ret = 0;\r\nif (old_is_pci || new_is_pci ||\r\n((mem->placement & bo->mem.placement & TTM_PL_MASK_CACHING) == 0)) {\r\nret = ttm_mem_io_lock(old_man, true);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\nttm_bo_unmap_virtual_locked(bo);\r\nttm_mem_io_unlock(old_man);\r\n}\r\nif (!(new_man->flags & TTM_MEMTYPE_FLAG_FIXED)) {\r\nif (bo->ttm == NULL) {\r\nbool zero = !(old_man->flags & TTM_MEMTYPE_FLAG_FIXED);\r\nret = ttm_bo_add_ttm(bo, zero);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nret = ttm_tt_set_placement_caching(bo->ttm, mem->placement);\r\nif (ret)\r\ngoto out_err;\r\nif (mem->mem_type != TTM_PL_SYSTEM) {\r\nret = ttm_tt_bind(bo->ttm, mem);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nif (bo->mem.mem_type == TTM_PL_SYSTEM) {\r\nif (bdev->driver->move_notify)\r\nbdev->driver->move_notify(bo, mem);\r\nbo->mem = *mem;\r\nmem->mm_node = NULL;\r\ngoto moved;\r\n}\r\n}\r\nif (bdev->driver->move_notify)\r\nbdev->driver->move_notify(bo, mem);\r\nif (!(old_man->flags & TTM_MEMTYPE_FLAG_FIXED) &&\r\n!(new_man->flags & TTM_MEMTYPE_FLAG_FIXED))\r\nret = ttm_bo_move_ttm(bo, evict, no_wait_reserve, no_wait_gpu, mem);\r\nelse if (bdev->driver->move)\r\nret = bdev->driver->move(bo, evict, interruptible,\r\nno_wait_reserve, no_wait_gpu, mem);\r\nelse\r\nret = ttm_bo_move_memcpy(bo, evict, no_wait_reserve, no_wait_gpu, mem);\r\nif (ret) {\r\nif (bdev->driver->move_notify) {\r\nstruct ttm_mem_reg tmp_mem = *mem;\r\n*mem = bo->mem;\r\nbo->mem = tmp_mem;\r\nbdev->driver->move_notify(bo, mem);\r\nbo->mem = *mem;\r\n}\r\ngoto out_err;\r\n}\r\nmoved:\r\nif (bo->evicted) {\r\nret = bdev->driver->invalidate_caches(bdev, bo->mem.placement);\r\nif (ret)\r\npr_err("Can not flush read caches\n");\r\nbo->evicted = false;\r\n}\r\nif (bo->mem.mm_node) {\r\nbo->offset = (bo->mem.start << PAGE_SHIFT) +\r\nbdev->man[bo->mem.mem_type].gpu_offset;\r\nbo->cur_placement = bo->mem.placement;\r\n} else\r\nbo->offset = 0;\r\nreturn 0;\r\nout_err:\r\nnew_man = &bdev->man[bo->mem.mem_type];\r\nif ((new_man->flags & TTM_MEMTYPE_FLAG_FIXED) && bo->ttm) {\r\nttm_tt_unbind(bo->ttm);\r\nttm_tt_destroy(bo->ttm);\r\nbo->ttm = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ttm_bo_cleanup_memtype_use(struct ttm_buffer_object *bo)\r\n{\r\nif (bo->bdev->driver->move_notify)\r\nbo->bdev->driver->move_notify(bo, NULL);\r\nif (bo->ttm) {\r\nttm_tt_unbind(bo->ttm);\r\nttm_tt_destroy(bo->ttm);\r\nbo->ttm = NULL;\r\n}\r\nttm_bo_mem_put(bo, &bo->mem);\r\natomic_set(&bo->reserved, 0);\r\nsmp_mb__after_atomic_dec();\r\nwake_up_all(&bo->event_queue);\r\n}\r\nstatic void ttm_bo_cleanup_refs_or_queue(struct ttm_buffer_object *bo)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_bo_global *glob = bo->glob;\r\nstruct ttm_bo_driver *driver;\r\nvoid *sync_obj = NULL;\r\nvoid *sync_obj_arg;\r\nint put_count;\r\nint ret;\r\nspin_lock(&bdev->fence_lock);\r\n(void) ttm_bo_wait(bo, false, false, true);\r\nif (!bo->sync_obj) {\r\nspin_lock(&glob->lru_lock);\r\nret = ttm_bo_reserve_locked(bo, false, true, false, 0);\r\nif (unlikely(ret == -EBUSY))\r\ngoto queue;\r\nspin_unlock(&bdev->fence_lock);\r\nput_count = ttm_bo_del_from_lru(bo);\r\nspin_unlock(&glob->lru_lock);\r\nttm_bo_cleanup_memtype_use(bo);\r\nttm_bo_list_ref_sub(bo, put_count, true);\r\nreturn;\r\n} else {\r\nspin_lock(&glob->lru_lock);\r\n}\r\nqueue:\r\ndriver = bdev->driver;\r\nif (bo->sync_obj)\r\nsync_obj = driver->sync_obj_ref(bo->sync_obj);\r\nsync_obj_arg = bo->sync_obj_arg;\r\nkref_get(&bo->list_kref);\r\nlist_add_tail(&bo->ddestroy, &bdev->ddestroy);\r\nspin_unlock(&glob->lru_lock);\r\nspin_unlock(&bdev->fence_lock);\r\nif (sync_obj) {\r\ndriver->sync_obj_flush(sync_obj, sync_obj_arg);\r\ndriver->sync_obj_unref(&sync_obj);\r\n}\r\nschedule_delayed_work(&bdev->wq,\r\n((HZ / 100) < 1) ? 1 : HZ / 100);\r\n}\r\nstatic int ttm_bo_cleanup_refs(struct ttm_buffer_object *bo,\r\nbool interruptible,\r\nbool no_wait_reserve,\r\nbool no_wait_gpu)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_bo_global *glob = bo->glob;\r\nint put_count;\r\nint ret = 0;\r\nretry:\r\nspin_lock(&bdev->fence_lock);\r\nret = ttm_bo_wait(bo, false, interruptible, no_wait_gpu);\r\nspin_unlock(&bdev->fence_lock);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nspin_lock(&glob->lru_lock);\r\nif (unlikely(list_empty(&bo->ddestroy))) {\r\nspin_unlock(&glob->lru_lock);\r\nreturn 0;\r\n}\r\nret = ttm_bo_reserve_locked(bo, interruptible,\r\nno_wait_reserve, false, 0);\r\nif (unlikely(ret != 0)) {\r\nspin_unlock(&glob->lru_lock);\r\nreturn ret;\r\n}\r\nif (unlikely(bo->sync_obj)) {\r\natomic_set(&bo->reserved, 0);\r\nwake_up_all(&bo->event_queue);\r\nspin_unlock(&glob->lru_lock);\r\ngoto retry;\r\n}\r\nput_count = ttm_bo_del_from_lru(bo);\r\nlist_del_init(&bo->ddestroy);\r\n++put_count;\r\nspin_unlock(&glob->lru_lock);\r\nttm_bo_cleanup_memtype_use(bo);\r\nttm_bo_list_ref_sub(bo, put_count, true);\r\nreturn 0;\r\n}\r\nstatic int ttm_bo_delayed_delete(struct ttm_bo_device *bdev, bool remove_all)\r\n{\r\nstruct ttm_bo_global *glob = bdev->glob;\r\nstruct ttm_buffer_object *entry = NULL;\r\nint ret = 0;\r\nspin_lock(&glob->lru_lock);\r\nif (list_empty(&bdev->ddestroy))\r\ngoto out_unlock;\r\nentry = list_first_entry(&bdev->ddestroy,\r\nstruct ttm_buffer_object, ddestroy);\r\nkref_get(&entry->list_kref);\r\nfor (;;) {\r\nstruct ttm_buffer_object *nentry = NULL;\r\nif (entry->ddestroy.next != &bdev->ddestroy) {\r\nnentry = list_first_entry(&entry->ddestroy,\r\nstruct ttm_buffer_object, ddestroy);\r\nkref_get(&nentry->list_kref);\r\n}\r\nspin_unlock(&glob->lru_lock);\r\nret = ttm_bo_cleanup_refs(entry, false, !remove_all,\r\n!remove_all);\r\nkref_put(&entry->list_kref, ttm_bo_release_list);\r\nentry = nentry;\r\nif (ret || !entry)\r\ngoto out;\r\nspin_lock(&glob->lru_lock);\r\nif (list_empty(&entry->ddestroy))\r\nbreak;\r\n}\r\nout_unlock:\r\nspin_unlock(&glob->lru_lock);\r\nout:\r\nif (entry)\r\nkref_put(&entry->list_kref, ttm_bo_release_list);\r\nreturn ret;\r\n}\r\nstatic void ttm_bo_delayed_workqueue(struct work_struct *work)\r\n{\r\nstruct ttm_bo_device *bdev =\r\ncontainer_of(work, struct ttm_bo_device, wq.work);\r\nif (ttm_bo_delayed_delete(bdev, false)) {\r\nschedule_delayed_work(&bdev->wq,\r\n((HZ / 100) < 1) ? 1 : HZ / 100);\r\n}\r\n}\r\nstatic void ttm_bo_release(struct kref *kref)\r\n{\r\nstruct ttm_buffer_object *bo =\r\ncontainer_of(kref, struct ttm_buffer_object, kref);\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_mem_type_manager *man = &bdev->man[bo->mem.mem_type];\r\nif (likely(bo->vm_node != NULL)) {\r\nrb_erase(&bo->vm_rb, &bdev->addr_space_rb);\r\ndrm_mm_put_block(bo->vm_node);\r\nbo->vm_node = NULL;\r\n}\r\nwrite_unlock(&bdev->vm_lock);\r\nttm_mem_io_lock(man, false);\r\nttm_mem_io_free_vm(bo);\r\nttm_mem_io_unlock(man);\r\nttm_bo_cleanup_refs_or_queue(bo);\r\nkref_put(&bo->list_kref, ttm_bo_release_list);\r\nwrite_lock(&bdev->vm_lock);\r\n}\r\nvoid ttm_bo_unref(struct ttm_buffer_object **p_bo)\r\n{\r\nstruct ttm_buffer_object *bo = *p_bo;\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\n*p_bo = NULL;\r\nwrite_lock(&bdev->vm_lock);\r\nkref_put(&bo->kref, ttm_bo_release);\r\nwrite_unlock(&bdev->vm_lock);\r\n}\r\nint ttm_bo_lock_delayed_workqueue(struct ttm_bo_device *bdev)\r\n{\r\nreturn cancel_delayed_work_sync(&bdev->wq);\r\n}\r\nvoid ttm_bo_unlock_delayed_workqueue(struct ttm_bo_device *bdev, int resched)\r\n{\r\nif (resched)\r\nschedule_delayed_work(&bdev->wq,\r\n((HZ / 100) < 1) ? 1 : HZ / 100);\r\n}\r\nstatic int ttm_bo_evict(struct ttm_buffer_object *bo, bool interruptible,\r\nbool no_wait_reserve, bool no_wait_gpu)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_mem_reg evict_mem;\r\nstruct ttm_placement placement;\r\nint ret = 0;\r\nspin_lock(&bdev->fence_lock);\r\nret = ttm_bo_wait(bo, false, interruptible, no_wait_gpu);\r\nspin_unlock(&bdev->fence_lock);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS) {\r\npr_err("Failed to expire sync object before buffer eviction\n");\r\n}\r\ngoto out;\r\n}\r\nBUG_ON(!atomic_read(&bo->reserved));\r\nevict_mem = bo->mem;\r\nevict_mem.mm_node = NULL;\r\nevict_mem.bus.io_reserved_vm = false;\r\nevict_mem.bus.io_reserved_count = 0;\r\nplacement.fpfn = 0;\r\nplacement.lpfn = 0;\r\nplacement.num_placement = 0;\r\nplacement.num_busy_placement = 0;\r\nbdev->driver->evict_flags(bo, &placement);\r\nret = ttm_bo_mem_space(bo, &placement, &evict_mem, interruptible,\r\nno_wait_reserve, no_wait_gpu);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS) {\r\npr_err("Failed to find memory space for buffer 0x%p eviction\n",\r\nbo);\r\nttm_bo_mem_space_debug(bo, &placement);\r\n}\r\ngoto out;\r\n}\r\nret = ttm_bo_handle_move_mem(bo, &evict_mem, true, interruptible,\r\nno_wait_reserve, no_wait_gpu);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\npr_err("Buffer eviction failed\n");\r\nttm_bo_mem_put(bo, &evict_mem);\r\ngoto out;\r\n}\r\nbo->evicted = true;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ttm_mem_evict_first(struct ttm_bo_device *bdev,\r\nuint32_t mem_type,\r\nbool interruptible, bool no_wait_reserve,\r\nbool no_wait_gpu)\r\n{\r\nstruct ttm_bo_global *glob = bdev->glob;\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem_type];\r\nstruct ttm_buffer_object *bo;\r\nint ret, put_count = 0;\r\nretry:\r\nspin_lock(&glob->lru_lock);\r\nif (list_empty(&man->lru)) {\r\nspin_unlock(&glob->lru_lock);\r\nreturn -EBUSY;\r\n}\r\nbo = list_first_entry(&man->lru, struct ttm_buffer_object, lru);\r\nkref_get(&bo->list_kref);\r\nif (!list_empty(&bo->ddestroy)) {\r\nspin_unlock(&glob->lru_lock);\r\nret = ttm_bo_cleanup_refs(bo, interruptible,\r\nno_wait_reserve, no_wait_gpu);\r\nkref_put(&bo->list_kref, ttm_bo_release_list);\r\nif (likely(ret == 0 || ret == -ERESTARTSYS))\r\nreturn ret;\r\ngoto retry;\r\n}\r\nret = ttm_bo_reserve_locked(bo, false, no_wait_reserve, false, 0);\r\nif (unlikely(ret == -EBUSY)) {\r\nspin_unlock(&glob->lru_lock);\r\nif (likely(!no_wait_gpu))\r\nret = ttm_bo_wait_unreserved(bo, interruptible);\r\nkref_put(&bo->list_kref, ttm_bo_release_list);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\ngoto retry;\r\n}\r\nput_count = ttm_bo_del_from_lru(bo);\r\nspin_unlock(&glob->lru_lock);\r\nBUG_ON(ret != 0);\r\nttm_bo_list_ref_sub(bo, put_count, true);\r\nret = ttm_bo_evict(bo, interruptible, no_wait_reserve, no_wait_gpu);\r\nttm_bo_unreserve(bo);\r\nkref_put(&bo->list_kref, ttm_bo_release_list);\r\nreturn ret;\r\n}\r\nvoid ttm_bo_mem_put(struct ttm_buffer_object *bo, struct ttm_mem_reg *mem)\r\n{\r\nstruct ttm_mem_type_manager *man = &bo->bdev->man[mem->mem_type];\r\nif (mem->mm_node)\r\n(*man->func->put_node)(man, mem);\r\n}\r\nstatic int ttm_bo_mem_force_space(struct ttm_buffer_object *bo,\r\nuint32_t mem_type,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem,\r\nbool interruptible,\r\nbool no_wait_reserve,\r\nbool no_wait_gpu)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem_type];\r\nint ret;\r\ndo {\r\nret = (*man->func->get_node)(man, bo, placement, mem);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nif (mem->mm_node)\r\nbreak;\r\nret = ttm_mem_evict_first(bdev, mem_type, interruptible,\r\nno_wait_reserve, no_wait_gpu);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\n} while (1);\r\nif (mem->mm_node == NULL)\r\nreturn -ENOMEM;\r\nmem->mem_type = mem_type;\r\nreturn 0;\r\n}\r\nstatic uint32_t ttm_bo_select_caching(struct ttm_mem_type_manager *man,\r\nuint32_t cur_placement,\r\nuint32_t proposed_placement)\r\n{\r\nuint32_t caching = proposed_placement & TTM_PL_MASK_CACHING;\r\nuint32_t result = proposed_placement & ~TTM_PL_MASK_CACHING;\r\nif ((cur_placement & caching) != 0)\r\nresult |= (cur_placement & caching);\r\nelse if ((man->default_caching & caching) != 0)\r\nresult |= man->default_caching;\r\nelse if ((TTM_PL_FLAG_CACHED & caching) != 0)\r\nresult |= TTM_PL_FLAG_CACHED;\r\nelse if ((TTM_PL_FLAG_WC & caching) != 0)\r\nresult |= TTM_PL_FLAG_WC;\r\nelse if ((TTM_PL_FLAG_UNCACHED & caching) != 0)\r\nresult |= TTM_PL_FLAG_UNCACHED;\r\nreturn result;\r\n}\r\nstatic bool ttm_bo_mt_compatible(struct ttm_mem_type_manager *man,\r\nuint32_t mem_type,\r\nuint32_t proposed_placement,\r\nuint32_t *masked_placement)\r\n{\r\nuint32_t cur_flags = ttm_bo_type_flags(mem_type);\r\nif ((cur_flags & proposed_placement & TTM_PL_MASK_MEM) == 0)\r\nreturn false;\r\nif ((proposed_placement & man->available_caching) == 0)\r\nreturn false;\r\ncur_flags |= (proposed_placement & man->available_caching);\r\n*masked_placement = cur_flags;\r\nreturn true;\r\n}\r\nint ttm_bo_mem_space(struct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem,\r\nbool interruptible, bool no_wait_reserve,\r\nbool no_wait_gpu)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_mem_type_manager *man;\r\nuint32_t mem_type = TTM_PL_SYSTEM;\r\nuint32_t cur_flags = 0;\r\nbool type_found = false;\r\nbool type_ok = false;\r\nbool has_erestartsys = false;\r\nint i, ret;\r\nmem->mm_node = NULL;\r\nfor (i = 0; i < placement->num_placement; ++i) {\r\nret = ttm_mem_type_from_flags(placement->placement[i],\r\n&mem_type);\r\nif (ret)\r\nreturn ret;\r\nman = &bdev->man[mem_type];\r\ntype_ok = ttm_bo_mt_compatible(man,\r\nmem_type,\r\nplacement->placement[i],\r\n&cur_flags);\r\nif (!type_ok)\r\ncontinue;\r\ncur_flags = ttm_bo_select_caching(man, bo->mem.placement,\r\ncur_flags);\r\nttm_flag_masked(&cur_flags, placement->placement[i],\r\n~TTM_PL_MASK_MEMTYPE);\r\nif (mem_type == TTM_PL_SYSTEM)\r\nbreak;\r\nif (man->has_type && man->use_type) {\r\ntype_found = true;\r\nret = (*man->func->get_node)(man, bo, placement, mem);\r\nif (unlikely(ret))\r\nreturn ret;\r\n}\r\nif (mem->mm_node)\r\nbreak;\r\n}\r\nif ((type_ok && (mem_type == TTM_PL_SYSTEM)) || mem->mm_node) {\r\nmem->mem_type = mem_type;\r\nmem->placement = cur_flags;\r\nreturn 0;\r\n}\r\nif (!type_found)\r\nreturn -EINVAL;\r\nfor (i = 0; i < placement->num_busy_placement; ++i) {\r\nret = ttm_mem_type_from_flags(placement->busy_placement[i],\r\n&mem_type);\r\nif (ret)\r\nreturn ret;\r\nman = &bdev->man[mem_type];\r\nif (!man->has_type)\r\ncontinue;\r\nif (!ttm_bo_mt_compatible(man,\r\nmem_type,\r\nplacement->busy_placement[i],\r\n&cur_flags))\r\ncontinue;\r\ncur_flags = ttm_bo_select_caching(man, bo->mem.placement,\r\ncur_flags);\r\nttm_flag_masked(&cur_flags, placement->busy_placement[i],\r\n~TTM_PL_MASK_MEMTYPE);\r\nif (mem_type == TTM_PL_SYSTEM) {\r\nmem->mem_type = mem_type;\r\nmem->placement = cur_flags;\r\nmem->mm_node = NULL;\r\nreturn 0;\r\n}\r\nret = ttm_bo_mem_force_space(bo, mem_type, placement, mem,\r\ninterruptible, no_wait_reserve, no_wait_gpu);\r\nif (ret == 0 && mem->mm_node) {\r\nmem->placement = cur_flags;\r\nreturn 0;\r\n}\r\nif (ret == -ERESTARTSYS)\r\nhas_erestartsys = true;\r\n}\r\nret = (has_erestartsys) ? -ERESTARTSYS : -ENOMEM;\r\nreturn ret;\r\n}\r\nint ttm_bo_wait_cpu(struct ttm_buffer_object *bo, bool no_wait)\r\n{\r\nif ((atomic_read(&bo->cpu_writers) > 0) && no_wait)\r\nreturn -EBUSY;\r\nreturn wait_event_interruptible(bo->event_queue,\r\natomic_read(&bo->cpu_writers) == 0);\r\n}\r\nint ttm_bo_move_buffer(struct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nbool interruptible, bool no_wait_reserve,\r\nbool no_wait_gpu)\r\n{\r\nint ret = 0;\r\nstruct ttm_mem_reg mem;\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nBUG_ON(!atomic_read(&bo->reserved));\r\nspin_lock(&bdev->fence_lock);\r\nret = ttm_bo_wait(bo, false, interruptible, no_wait_gpu);\r\nspin_unlock(&bdev->fence_lock);\r\nif (ret)\r\nreturn ret;\r\nmem.num_pages = bo->num_pages;\r\nmem.size = mem.num_pages << PAGE_SHIFT;\r\nmem.page_alignment = bo->mem.page_alignment;\r\nmem.bus.io_reserved_vm = false;\r\nmem.bus.io_reserved_count = 0;\r\nret = ttm_bo_mem_space(bo, placement, &mem, interruptible, no_wait_reserve, no_wait_gpu);\r\nif (ret)\r\ngoto out_unlock;\r\nret = ttm_bo_handle_move_mem(bo, &mem, false, interruptible, no_wait_reserve, no_wait_gpu);\r\nout_unlock:\r\nif (ret && mem.mm_node)\r\nttm_bo_mem_put(bo, &mem);\r\nreturn ret;\r\n}\r\nstatic int ttm_bo_mem_compat(struct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nint i;\r\nif (mem->mm_node && placement->lpfn != 0 &&\r\n(mem->start < placement->fpfn ||\r\nmem->start + mem->num_pages > placement->lpfn))\r\nreturn -1;\r\nfor (i = 0; i < placement->num_placement; i++) {\r\nif ((placement->placement[i] & mem->placement &\r\nTTM_PL_MASK_CACHING) &&\r\n(placement->placement[i] & mem->placement &\r\nTTM_PL_MASK_MEM))\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nint ttm_bo_validate(struct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nbool interruptible, bool no_wait_reserve,\r\nbool no_wait_gpu)\r\n{\r\nint ret;\r\nBUG_ON(!atomic_read(&bo->reserved));\r\nif (placement->lpfn || placement->fpfn)\r\nif (placement->fpfn > placement->lpfn ||\r\n(placement->lpfn - placement->fpfn) < bo->num_pages)\r\nreturn -EINVAL;\r\nret = ttm_bo_mem_compat(placement, &bo->mem);\r\nif (ret < 0) {\r\nret = ttm_bo_move_buffer(bo, placement, interruptible, no_wait_reserve, no_wait_gpu);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nttm_flag_masked(&bo->mem.placement, placement->placement[ret],\r\n~TTM_PL_MASK_MEMTYPE);\r\n}\r\nif (bo->mem.mem_type == TTM_PL_SYSTEM && bo->ttm == NULL) {\r\nret = ttm_bo_add_ttm(bo, true);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ttm_bo_check_placement(struct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement)\r\n{\r\nBUG_ON((placement->fpfn || placement->lpfn) &&\r\n(bo->mem.num_pages > (placement->lpfn - placement->fpfn)));\r\nreturn 0;\r\n}\r\nint ttm_bo_init(struct ttm_bo_device *bdev,\r\nstruct ttm_buffer_object *bo,\r\nunsigned long size,\r\nenum ttm_bo_type type,\r\nstruct ttm_placement *placement,\r\nuint32_t page_alignment,\r\nunsigned long buffer_start,\r\nbool interruptible,\r\nstruct file *persistent_swap_storage,\r\nsize_t acc_size,\r\nstruct sg_table *sg,\r\nvoid (*destroy) (struct ttm_buffer_object *))\r\n{\r\nint ret = 0;\r\nunsigned long num_pages;\r\nstruct ttm_mem_global *mem_glob = bdev->glob->mem_glob;\r\nret = ttm_mem_global_alloc(mem_glob, acc_size, false, false);\r\nif (ret) {\r\npr_err("Out of kernel memory\n");\r\nif (destroy)\r\n(*destroy)(bo);\r\nelse\r\nkfree(bo);\r\nreturn -ENOMEM;\r\n}\r\nsize += buffer_start & ~PAGE_MASK;\r\nnum_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nif (num_pages == 0) {\r\npr_err("Illegal buffer object size\n");\r\nif (destroy)\r\n(*destroy)(bo);\r\nelse\r\nkfree(bo);\r\nttm_mem_global_free(mem_glob, acc_size);\r\nreturn -EINVAL;\r\n}\r\nbo->destroy = destroy;\r\nkref_init(&bo->kref);\r\nkref_init(&bo->list_kref);\r\natomic_set(&bo->cpu_writers, 0);\r\natomic_set(&bo->reserved, 1);\r\ninit_waitqueue_head(&bo->event_queue);\r\nINIT_LIST_HEAD(&bo->lru);\r\nINIT_LIST_HEAD(&bo->ddestroy);\r\nINIT_LIST_HEAD(&bo->swap);\r\nINIT_LIST_HEAD(&bo->io_reserve_lru);\r\nbo->bdev = bdev;\r\nbo->glob = bdev->glob;\r\nbo->type = type;\r\nbo->num_pages = num_pages;\r\nbo->mem.size = num_pages << PAGE_SHIFT;\r\nbo->mem.mem_type = TTM_PL_SYSTEM;\r\nbo->mem.num_pages = bo->num_pages;\r\nbo->mem.mm_node = NULL;\r\nbo->mem.page_alignment = page_alignment;\r\nbo->mem.bus.io_reserved_vm = false;\r\nbo->mem.bus.io_reserved_count = 0;\r\nbo->buffer_start = buffer_start & PAGE_MASK;\r\nbo->priv_flags = 0;\r\nbo->mem.placement = (TTM_PL_FLAG_SYSTEM | TTM_PL_FLAG_CACHED);\r\nbo->seq_valid = false;\r\nbo->persistent_swap_storage = persistent_swap_storage;\r\nbo->acc_size = acc_size;\r\nbo->sg = sg;\r\natomic_inc(&bo->glob->bo_count);\r\nret = ttm_bo_check_placement(bo, placement);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\nif (bo->type == ttm_bo_type_device ||\r\nbo->type == ttm_bo_type_sg) {\r\nret = ttm_bo_setup_vm(bo);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nret = ttm_bo_validate(bo, placement, interruptible, false, false);\r\nif (ret)\r\ngoto out_err;\r\nttm_bo_unreserve(bo);\r\nreturn 0;\r\nout_err:\r\nttm_bo_unreserve(bo);\r\nttm_bo_unref(&bo);\r\nreturn ret;\r\n}\r\nsize_t ttm_bo_acc_size(struct ttm_bo_device *bdev,\r\nunsigned long bo_size,\r\nunsigned struct_size)\r\n{\r\nunsigned npages = (PAGE_ALIGN(bo_size)) >> PAGE_SHIFT;\r\nsize_t size = 0;\r\nsize += ttm_round_pot(struct_size);\r\nsize += PAGE_ALIGN(npages * sizeof(void *));\r\nsize += ttm_round_pot(sizeof(struct ttm_tt));\r\nreturn size;\r\n}\r\nsize_t ttm_bo_dma_acc_size(struct ttm_bo_device *bdev,\r\nunsigned long bo_size,\r\nunsigned struct_size)\r\n{\r\nunsigned npages = (PAGE_ALIGN(bo_size)) >> PAGE_SHIFT;\r\nsize_t size = 0;\r\nsize += ttm_round_pot(struct_size);\r\nsize += PAGE_ALIGN(npages * sizeof(void *));\r\nsize += PAGE_ALIGN(npages * sizeof(dma_addr_t));\r\nsize += ttm_round_pot(sizeof(struct ttm_dma_tt));\r\nreturn size;\r\n}\r\nint ttm_bo_create(struct ttm_bo_device *bdev,\r\nunsigned long size,\r\nenum ttm_bo_type type,\r\nstruct ttm_placement *placement,\r\nuint32_t page_alignment,\r\nunsigned long buffer_start,\r\nbool interruptible,\r\nstruct file *persistent_swap_storage,\r\nstruct ttm_buffer_object **p_bo)\r\n{\r\nstruct ttm_buffer_object *bo;\r\nsize_t acc_size;\r\nint ret;\r\nbo = kzalloc(sizeof(*bo), GFP_KERNEL);\r\nif (unlikely(bo == NULL))\r\nreturn -ENOMEM;\r\nacc_size = ttm_bo_acc_size(bdev, size, sizeof(struct ttm_buffer_object));\r\nret = ttm_bo_init(bdev, bo, size, type, placement, page_alignment,\r\nbuffer_start, interruptible,\r\npersistent_swap_storage, acc_size, NULL, NULL);\r\nif (likely(ret == 0))\r\n*p_bo = bo;\r\nreturn ret;\r\n}\r\nstatic int ttm_bo_force_list_clean(struct ttm_bo_device *bdev,\r\nunsigned mem_type, bool allow_errors)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem_type];\r\nstruct ttm_bo_global *glob = bdev->glob;\r\nint ret;\r\nspin_lock(&glob->lru_lock);\r\nwhile (!list_empty(&man->lru)) {\r\nspin_unlock(&glob->lru_lock);\r\nret = ttm_mem_evict_first(bdev, mem_type, false, false, false);\r\nif (ret) {\r\nif (allow_errors) {\r\nreturn ret;\r\n} else {\r\npr_err("Cleanup eviction failed\n");\r\n}\r\n}\r\nspin_lock(&glob->lru_lock);\r\n}\r\nspin_unlock(&glob->lru_lock);\r\nreturn 0;\r\n}\r\nint ttm_bo_clean_mm(struct ttm_bo_device *bdev, unsigned mem_type)\r\n{\r\nstruct ttm_mem_type_manager *man;\r\nint ret = -EINVAL;\r\nif (mem_type >= TTM_NUM_MEM_TYPES) {\r\npr_err("Illegal memory type %d\n", mem_type);\r\nreturn ret;\r\n}\r\nman = &bdev->man[mem_type];\r\nif (!man->has_type) {\r\npr_err("Trying to take down uninitialized memory manager type %u\n",\r\nmem_type);\r\nreturn ret;\r\n}\r\nman->use_type = false;\r\nman->has_type = false;\r\nret = 0;\r\nif (mem_type > 0) {\r\nttm_bo_force_list_clean(bdev, mem_type, false);\r\nret = (*man->func->takedown)(man);\r\n}\r\nreturn ret;\r\n}\r\nint ttm_bo_evict_mm(struct ttm_bo_device *bdev, unsigned mem_type)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem_type];\r\nif (mem_type == 0 || mem_type >= TTM_NUM_MEM_TYPES) {\r\npr_err("Illegal memory manager memory type %u\n", mem_type);\r\nreturn -EINVAL;\r\n}\r\nif (!man->has_type) {\r\npr_err("Memory type %u has not been initialized\n", mem_type);\r\nreturn 0;\r\n}\r\nreturn ttm_bo_force_list_clean(bdev, mem_type, true);\r\n}\r\nint ttm_bo_init_mm(struct ttm_bo_device *bdev, unsigned type,\r\nunsigned long p_size)\r\n{\r\nint ret = -EINVAL;\r\nstruct ttm_mem_type_manager *man;\r\nBUG_ON(type >= TTM_NUM_MEM_TYPES);\r\nman = &bdev->man[type];\r\nBUG_ON(man->has_type);\r\nman->io_reserve_fastpath = true;\r\nman->use_io_reserve_lru = false;\r\nmutex_init(&man->io_reserve_mutex);\r\nINIT_LIST_HEAD(&man->io_reserve_lru);\r\nret = bdev->driver->init_mem_type(bdev, type, man);\r\nif (ret)\r\nreturn ret;\r\nman->bdev = bdev;\r\nret = 0;\r\nif (type != TTM_PL_SYSTEM) {\r\nret = (*man->func->init)(man, p_size);\r\nif (ret)\r\nreturn ret;\r\n}\r\nman->has_type = true;\r\nman->use_type = true;\r\nman->size = p_size;\r\nINIT_LIST_HEAD(&man->lru);\r\nreturn 0;\r\n}\r\nstatic void ttm_bo_global_kobj_release(struct kobject *kobj)\r\n{\r\nstruct ttm_bo_global *glob =\r\ncontainer_of(kobj, struct ttm_bo_global, kobj);\r\nttm_mem_unregister_shrink(glob->mem_glob, &glob->shrink);\r\n__free_page(glob->dummy_read_page);\r\nkfree(glob);\r\n}\r\nvoid ttm_bo_global_release(struct drm_global_reference *ref)\r\n{\r\nstruct ttm_bo_global *glob = ref->object;\r\nkobject_del(&glob->kobj);\r\nkobject_put(&glob->kobj);\r\n}\r\nint ttm_bo_global_init(struct drm_global_reference *ref)\r\n{\r\nstruct ttm_bo_global_ref *bo_ref =\r\ncontainer_of(ref, struct ttm_bo_global_ref, ref);\r\nstruct ttm_bo_global *glob = ref->object;\r\nint ret;\r\nmutex_init(&glob->device_list_mutex);\r\nspin_lock_init(&glob->lru_lock);\r\nglob->mem_glob = bo_ref->mem_glob;\r\nglob->dummy_read_page = alloc_page(__GFP_ZERO | GFP_DMA32);\r\nif (unlikely(glob->dummy_read_page == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_no_drp;\r\n}\r\nINIT_LIST_HEAD(&glob->swap_lru);\r\nINIT_LIST_HEAD(&glob->device_list);\r\nttm_mem_init_shrink(&glob->shrink, ttm_bo_swapout);\r\nret = ttm_mem_register_shrink(glob->mem_glob, &glob->shrink);\r\nif (unlikely(ret != 0)) {\r\npr_err("Could not register buffer object swapout\n");\r\ngoto out_no_shrink;\r\n}\r\natomic_set(&glob->bo_count, 0);\r\nret = kobject_init_and_add(\r\n&glob->kobj, &ttm_bo_glob_kobj_type, ttm_get_kobj(), "buffer_objects");\r\nif (unlikely(ret != 0))\r\nkobject_put(&glob->kobj);\r\nreturn ret;\r\nout_no_shrink:\r\n__free_page(glob->dummy_read_page);\r\nout_no_drp:\r\nkfree(glob);\r\nreturn ret;\r\n}\r\nint ttm_bo_device_release(struct ttm_bo_device *bdev)\r\n{\r\nint ret = 0;\r\nunsigned i = TTM_NUM_MEM_TYPES;\r\nstruct ttm_mem_type_manager *man;\r\nstruct ttm_bo_global *glob = bdev->glob;\r\nwhile (i--) {\r\nman = &bdev->man[i];\r\nif (man->has_type) {\r\nman->use_type = false;\r\nif ((i != TTM_PL_SYSTEM) && ttm_bo_clean_mm(bdev, i)) {\r\nret = -EBUSY;\r\npr_err("DRM memory manager type %d is not clean\n",\r\ni);\r\n}\r\nman->has_type = false;\r\n}\r\n}\r\nmutex_lock(&glob->device_list_mutex);\r\nlist_del(&bdev->device_list);\r\nmutex_unlock(&glob->device_list_mutex);\r\ncancel_delayed_work_sync(&bdev->wq);\r\nwhile (ttm_bo_delayed_delete(bdev, true))\r\n;\r\nspin_lock(&glob->lru_lock);\r\nif (list_empty(&bdev->ddestroy))\r\nTTM_DEBUG("Delayed destroy list was clean\n");\r\nif (list_empty(&bdev->man[0].lru))\r\nTTM_DEBUG("Swap list was clean\n");\r\nspin_unlock(&glob->lru_lock);\r\nBUG_ON(!drm_mm_clean(&bdev->addr_space_mm));\r\nwrite_lock(&bdev->vm_lock);\r\ndrm_mm_takedown(&bdev->addr_space_mm);\r\nwrite_unlock(&bdev->vm_lock);\r\nreturn ret;\r\n}\r\nint ttm_bo_device_init(struct ttm_bo_device *bdev,\r\nstruct ttm_bo_global *glob,\r\nstruct ttm_bo_driver *driver,\r\nuint64_t file_page_offset,\r\nbool need_dma32)\r\n{\r\nint ret = -EINVAL;\r\nrwlock_init(&bdev->vm_lock);\r\nbdev->driver = driver;\r\nmemset(bdev->man, 0, sizeof(bdev->man));\r\nret = ttm_bo_init_mm(bdev, TTM_PL_SYSTEM, 0);\r\nif (unlikely(ret != 0))\r\ngoto out_no_sys;\r\nbdev->addr_space_rb = RB_ROOT;\r\nret = drm_mm_init(&bdev->addr_space_mm, file_page_offset, 0x10000000);\r\nif (unlikely(ret != 0))\r\ngoto out_no_addr_mm;\r\nINIT_DELAYED_WORK(&bdev->wq, ttm_bo_delayed_workqueue);\r\nbdev->nice_mode = true;\r\nINIT_LIST_HEAD(&bdev->ddestroy);\r\nbdev->dev_mapping = NULL;\r\nbdev->glob = glob;\r\nbdev->need_dma32 = need_dma32;\r\nbdev->val_seq = 0;\r\nspin_lock_init(&bdev->fence_lock);\r\nmutex_lock(&glob->device_list_mutex);\r\nlist_add_tail(&bdev->device_list, &glob->device_list);\r\nmutex_unlock(&glob->device_list_mutex);\r\nreturn 0;\r\nout_no_addr_mm:\r\nttm_bo_clean_mm(bdev, 0);\r\nout_no_sys:\r\nreturn ret;\r\n}\r\nbool ttm_mem_reg_is_pci(struct ttm_bo_device *bdev, struct ttm_mem_reg *mem)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem->mem_type];\r\nif (!(man->flags & TTM_MEMTYPE_FLAG_FIXED)) {\r\nif (mem->mem_type == TTM_PL_SYSTEM)\r\nreturn false;\r\nif (man->flags & TTM_MEMTYPE_FLAG_CMA)\r\nreturn false;\r\nif (mem->placement & TTM_PL_FLAG_CACHED)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid ttm_bo_unmap_virtual_locked(struct ttm_buffer_object *bo)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nloff_t offset = (loff_t) bo->addr_space_offset;\r\nloff_t holelen = ((loff_t) bo->mem.num_pages) << PAGE_SHIFT;\r\nif (!bdev->dev_mapping)\r\nreturn;\r\nunmap_mapping_range(bdev->dev_mapping, offset, holelen, 1);\r\nttm_mem_io_free_vm(bo);\r\n}\r\nvoid ttm_bo_unmap_virtual(struct ttm_buffer_object *bo)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct ttm_mem_type_manager *man = &bdev->man[bo->mem.mem_type];\r\nttm_mem_io_lock(man, false);\r\nttm_bo_unmap_virtual_locked(bo);\r\nttm_mem_io_unlock(man);\r\n}\r\nstatic void ttm_bo_vm_insert_rb(struct ttm_buffer_object *bo)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nstruct rb_node **cur = &bdev->addr_space_rb.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct ttm_buffer_object *cur_bo;\r\nunsigned long offset = bo->vm_node->start;\r\nunsigned long cur_offset;\r\nwhile (*cur) {\r\nparent = *cur;\r\ncur_bo = rb_entry(parent, struct ttm_buffer_object, vm_rb);\r\ncur_offset = cur_bo->vm_node->start;\r\nif (offset < cur_offset)\r\ncur = &parent->rb_left;\r\nelse if (offset > cur_offset)\r\ncur = &parent->rb_right;\r\nelse\r\nBUG();\r\n}\r\nrb_link_node(&bo->vm_rb, parent, cur);\r\nrb_insert_color(&bo->vm_rb, &bdev->addr_space_rb);\r\n}\r\nstatic int ttm_bo_setup_vm(struct ttm_buffer_object *bo)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nint ret;\r\nretry_pre_get:\r\nret = drm_mm_pre_get(&bdev->addr_space_mm);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nwrite_lock(&bdev->vm_lock);\r\nbo->vm_node = drm_mm_search_free(&bdev->addr_space_mm,\r\nbo->mem.num_pages, 0, 0);\r\nif (unlikely(bo->vm_node == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nbo->vm_node = drm_mm_get_block_atomic(bo->vm_node,\r\nbo->mem.num_pages, 0);\r\nif (unlikely(bo->vm_node == NULL)) {\r\nwrite_unlock(&bdev->vm_lock);\r\ngoto retry_pre_get;\r\n}\r\nttm_bo_vm_insert_rb(bo);\r\nwrite_unlock(&bdev->vm_lock);\r\nbo->addr_space_offset = ((uint64_t) bo->vm_node->start) << PAGE_SHIFT;\r\nreturn 0;\r\nout_unlock:\r\nwrite_unlock(&bdev->vm_lock);\r\nreturn ret;\r\n}\r\nint ttm_bo_wait(struct ttm_buffer_object *bo,\r\nbool lazy, bool interruptible, bool no_wait)\r\n{\r\nstruct ttm_bo_driver *driver = bo->bdev->driver;\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nvoid *sync_obj;\r\nvoid *sync_obj_arg;\r\nint ret = 0;\r\nif (likely(bo->sync_obj == NULL))\r\nreturn 0;\r\nwhile (bo->sync_obj) {\r\nif (driver->sync_obj_signaled(bo->sync_obj, bo->sync_obj_arg)) {\r\nvoid *tmp_obj = bo->sync_obj;\r\nbo->sync_obj = NULL;\r\nclear_bit(TTM_BO_PRIV_FLAG_MOVING, &bo->priv_flags);\r\nspin_unlock(&bdev->fence_lock);\r\ndriver->sync_obj_unref(&tmp_obj);\r\nspin_lock(&bdev->fence_lock);\r\ncontinue;\r\n}\r\nif (no_wait)\r\nreturn -EBUSY;\r\nsync_obj = driver->sync_obj_ref(bo->sync_obj);\r\nsync_obj_arg = bo->sync_obj_arg;\r\nspin_unlock(&bdev->fence_lock);\r\nret = driver->sync_obj_wait(sync_obj, sync_obj_arg,\r\nlazy, interruptible);\r\nif (unlikely(ret != 0)) {\r\ndriver->sync_obj_unref(&sync_obj);\r\nspin_lock(&bdev->fence_lock);\r\nreturn ret;\r\n}\r\nspin_lock(&bdev->fence_lock);\r\nif (likely(bo->sync_obj == sync_obj &&\r\nbo->sync_obj_arg == sync_obj_arg)) {\r\nvoid *tmp_obj = bo->sync_obj;\r\nbo->sync_obj = NULL;\r\nclear_bit(TTM_BO_PRIV_FLAG_MOVING,\r\n&bo->priv_flags);\r\nspin_unlock(&bdev->fence_lock);\r\ndriver->sync_obj_unref(&sync_obj);\r\ndriver->sync_obj_unref(&tmp_obj);\r\nspin_lock(&bdev->fence_lock);\r\n} else {\r\nspin_unlock(&bdev->fence_lock);\r\ndriver->sync_obj_unref(&sync_obj);\r\nspin_lock(&bdev->fence_lock);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint ttm_bo_synccpu_write_grab(struct ttm_buffer_object *bo, bool no_wait)\r\n{\r\nstruct ttm_bo_device *bdev = bo->bdev;\r\nint ret = 0;\r\nret = ttm_bo_reserve(bo, true, no_wait, false, 0);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nspin_lock(&bdev->fence_lock);\r\nret = ttm_bo_wait(bo, false, true, no_wait);\r\nspin_unlock(&bdev->fence_lock);\r\nif (likely(ret == 0))\r\natomic_inc(&bo->cpu_writers);\r\nttm_bo_unreserve(bo);\r\nreturn ret;\r\n}\r\nvoid ttm_bo_synccpu_write_release(struct ttm_buffer_object *bo)\r\n{\r\nif (atomic_dec_and_test(&bo->cpu_writers))\r\nwake_up_all(&bo->event_queue);\r\n}\r\nstatic int ttm_bo_swapout(struct ttm_mem_shrink *shrink)\r\n{\r\nstruct ttm_bo_global *glob =\r\ncontainer_of(shrink, struct ttm_bo_global, shrink);\r\nstruct ttm_buffer_object *bo;\r\nint ret = -EBUSY;\r\nint put_count;\r\nuint32_t swap_placement = (TTM_PL_FLAG_CACHED | TTM_PL_FLAG_SYSTEM);\r\nspin_lock(&glob->lru_lock);\r\nwhile (ret == -EBUSY) {\r\nif (unlikely(list_empty(&glob->swap_lru))) {\r\nspin_unlock(&glob->lru_lock);\r\nreturn -EBUSY;\r\n}\r\nbo = list_first_entry(&glob->swap_lru,\r\nstruct ttm_buffer_object, swap);\r\nkref_get(&bo->list_kref);\r\nif (!list_empty(&bo->ddestroy)) {\r\nspin_unlock(&glob->lru_lock);\r\n(void) ttm_bo_cleanup_refs(bo, false, false, false);\r\nkref_put(&bo->list_kref, ttm_bo_release_list);\r\nspin_lock(&glob->lru_lock);\r\ncontinue;\r\n}\r\nret = ttm_bo_reserve_locked(bo, false, true, false, 0);\r\nif (unlikely(ret == -EBUSY)) {\r\nspin_unlock(&glob->lru_lock);\r\nttm_bo_wait_unreserved(bo, false);\r\nkref_put(&bo->list_kref, ttm_bo_release_list);\r\nspin_lock(&glob->lru_lock);\r\n}\r\n}\r\nBUG_ON(ret != 0);\r\nput_count = ttm_bo_del_from_lru(bo);\r\nspin_unlock(&glob->lru_lock);\r\nttm_bo_list_ref_sub(bo, put_count, true);\r\nspin_lock(&bo->bdev->fence_lock);\r\nret = ttm_bo_wait(bo, false, false, false);\r\nspin_unlock(&bo->bdev->fence_lock);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\nif ((bo->mem.placement & swap_placement) != swap_placement) {\r\nstruct ttm_mem_reg evict_mem;\r\nevict_mem = bo->mem;\r\nevict_mem.mm_node = NULL;\r\nevict_mem.placement = TTM_PL_FLAG_SYSTEM | TTM_PL_FLAG_CACHED;\r\nevict_mem.mem_type = TTM_PL_SYSTEM;\r\nret = ttm_bo_handle_move_mem(bo, &evict_mem, true,\r\nfalse, false, false);\r\nif (unlikely(ret != 0))\r\ngoto out;\r\n}\r\nttm_bo_unmap_virtual(bo);\r\nif (bo->bdev->driver->swap_notify)\r\nbo->bdev->driver->swap_notify(bo);\r\nret = ttm_tt_swapout(bo->ttm, bo->persistent_swap_storage);\r\nout:\r\natomic_set(&bo->reserved, 0);\r\nwake_up_all(&bo->event_queue);\r\nkref_put(&bo->list_kref, ttm_bo_release_list);\r\nreturn ret;\r\n}\r\nvoid ttm_bo_swapout_all(struct ttm_bo_device *bdev)\r\n{\r\nwhile (ttm_bo_swapout(&bdev->glob->shrink) == 0)\r\n;\r\n}
