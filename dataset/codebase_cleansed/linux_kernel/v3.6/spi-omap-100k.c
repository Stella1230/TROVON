static void spi100k_enable_clock(struct spi_master *master)\r\n{\r\nunsigned int val;\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nval = readw(spi100k->base + SPI_SETUP1);\r\nval |= SPI_SETUP1_CLOCK_ENABLE;\r\nwritew(val, spi100k->base + SPI_SETUP1);\r\n}\r\nstatic void spi100k_disable_clock(struct spi_master *master)\r\n{\r\nunsigned int val;\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nval = readw(spi100k->base + SPI_SETUP1);\r\nval &= ~SPI_SETUP1_CLOCK_ENABLE;\r\nwritew(val, spi100k->base + SPI_SETUP1);\r\n}\r\nstatic void spi100k_write_data(struct spi_master *master, int len, int data)\r\n{\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nif (len <= 8) {\r\ndata <<= 8;\r\nlen = 16;\r\n}\r\nspi100k_enable_clock(master);\r\nwritew( data , spi100k->base + SPI_TX_MSB);\r\nwritew(SPI_CTRL_SEN(0) |\r\nSPI_CTRL_WORD_SIZE(len) |\r\nSPI_CTRL_WR,\r\nspi100k->base + SPI_CTRL);\r\nwhile((readw(spi100k->base + SPI_STATUS) & SPI_STATUS_WE) != SPI_STATUS_WE);\r\nudelay(1000);\r\nspi100k_disable_clock(master);\r\n}\r\nstatic int spi100k_read_data(struct spi_master *master, int len)\r\n{\r\nint dataH,dataL;\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nif (len <= 8)\r\nlen = 16;\r\nspi100k_enable_clock(master);\r\nwritew(SPI_CTRL_SEN(0) |\r\nSPI_CTRL_WORD_SIZE(len) |\r\nSPI_CTRL_RD,\r\nspi100k->base + SPI_CTRL);\r\nwhile((readw(spi100k->base + SPI_STATUS) & SPI_STATUS_RD) != SPI_STATUS_RD);\r\nudelay(1000);\r\ndataL = readw(spi100k->base + SPI_RX_LSB);\r\ndataH = readw(spi100k->base + SPI_RX_MSB);\r\nspi100k_disable_clock(master);\r\nreturn dataL;\r\n}\r\nstatic void spi100k_open(struct spi_master *master)\r\n{\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(master);\r\nwritew(SPI_SETUP1_INT_READ_ENABLE |\r\nSPI_SETUP1_INT_WRITE_ENABLE |\r\nSPI_SETUP1_CLOCK_DIVISOR(0), spi100k->base + SPI_SETUP1);\r\nwritew(SPI_SETUP2_ACTIVE_EDGE_FALLING |\r\nSPI_SETUP2_NEGATIVE_LEVEL |\r\nSPI_SETUP2_LEVEL_TRIGGER, spi100k->base + SPI_SETUP2);\r\n}\r\nstatic void omap1_spi100k_force_cs(struct omap1_spi100k *spi100k, int enable)\r\n{\r\nif (enable)\r\nwritew(0x05fc, spi100k->base + SPI_CTRL);\r\nelse\r\nwritew(0x05fd, spi100k->base + SPI_CTRL);\r\n}\r\nstatic unsigned\r\nomap1_spi100k_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nstruct omap1_spi100k *spi100k;\r\nstruct omap1_spi100k_cs *cs = spi->controller_state;\r\nunsigned int count, c;\r\nint word_len;\r\nspi100k = spi_master_get_devdata(spi->master);\r\ncount = xfer->len;\r\nc = count;\r\nword_len = cs->word_len;\r\nif (word_len <= 8) {\r\nu8 *rx;\r\nconst u8 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc-=1;\r\nif (xfer->tx_buf != NULL)\r\nspi100k_write_data(spi->master, word_len, *tx++);\r\nif (xfer->rx_buf != NULL)\r\n*rx++ = spi100k_read_data(spi->master, word_len);\r\n} while(c);\r\n} else if (word_len <= 16) {\r\nu16 *rx;\r\nconst u16 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc-=2;\r\nif (xfer->tx_buf != NULL)\r\nspi100k_write_data(spi->master,word_len, *tx++);\r\nif (xfer->rx_buf != NULL)\r\n*rx++ = spi100k_read_data(spi->master,word_len);\r\n} while(c);\r\n} else if (word_len <= 32) {\r\nu32 *rx;\r\nconst u32 *tx;\r\nrx = xfer->rx_buf;\r\ntx = xfer->tx_buf;\r\ndo {\r\nc-=4;\r\nif (xfer->tx_buf != NULL)\r\nspi100k_write_data(spi->master,word_len, *tx);\r\nif (xfer->rx_buf != NULL)\r\n*rx = spi100k_read_data(spi->master,word_len);\r\n} while(c);\r\n}\r\nreturn count - c;\r\n}\r\nstatic int omap1_spi100k_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct omap1_spi100k *spi100k = spi_master_get_devdata(spi->master);\r\nstruct omap1_spi100k_cs *cs = spi->controller_state;\r\nu8 word_len = spi->bits_per_word;\r\nif (t != NULL && t->bits_per_word)\r\nword_len = t->bits_per_word;\r\nif (!word_len)\r\nword_len = 8;\r\nif (spi->bits_per_word > 32)\r\nreturn -EINVAL;\r\ncs->word_len = word_len;\r\nwritew(0x3e , spi100k->base + SPI_SETUP1);\r\nwritew(0x00 , spi100k->base + SPI_STATUS);\r\nwritew(0x3e , spi100k->base + SPI_CTRL);\r\nreturn 0;\r\n}\r\nstatic int omap1_spi100k_setup(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct omap1_spi100k *spi100k;\r\nstruct omap1_spi100k_cs *cs = spi->controller_state;\r\nif (spi->bits_per_word < 4 || spi->bits_per_word > 32) {\r\ndev_dbg(&spi->dev, "setup: unsupported %d bit words\n",\r\nspi->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nspi100k = spi_master_get_devdata(spi->master);\r\nif (!cs) {\r\ncs = kzalloc(sizeof *cs, GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\ncs->base = spi100k->base + spi->chip_select * 0x14;\r\nspi->controller_state = cs;\r\n}\r\nspi100k_open(spi->master);\r\nclk_enable(spi100k->ick);\r\nclk_enable(spi100k->fck);\r\nret = omap1_spi100k_setup_transfer(spi, NULL);\r\nclk_disable(spi100k->ick);\r\nclk_disable(spi100k->fck);\r\nreturn ret;\r\n}\r\nstatic void omap1_spi100k_work(struct work_struct *work)\r\n{\r\nstruct omap1_spi100k *spi100k;\r\nint status = 0;\r\nspi100k = container_of(work, struct omap1_spi100k, work);\r\nspin_lock_irq(&spi100k->lock);\r\nclk_enable(spi100k->ick);\r\nclk_enable(spi100k->fck);\r\nwhile (!list_empty(&spi100k->msg_queue)) {\r\nstruct spi_message *m;\r\nstruct spi_device *spi;\r\nstruct spi_transfer *t = NULL;\r\nint cs_active = 0;\r\nstruct omap1_spi100k_cs *cs;\r\nint par_override = 0;\r\nm = container_of(spi100k->msg_queue.next, struct spi_message,\r\nqueue);\r\nlist_del_init(&m->queue);\r\nspin_unlock_irq(&spi100k->lock);\r\nspi = m->spi;\r\ncs = spi->controller_state;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->tx_buf == NULL && t->rx_buf == NULL && t->len) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nif (par_override || t->speed_hz || t->bits_per_word) {\r\npar_override = 1;\r\nstatus = omap1_spi100k_setup_transfer(spi, t);\r\nif (status < 0)\r\nbreak;\r\nif (!t->speed_hz && !t->bits_per_word)\r\npar_override = 0;\r\n}\r\nif (!cs_active) {\r\nomap1_spi100k_force_cs(spi100k, 1);\r\ncs_active = 1;\r\n}\r\nif (t->len) {\r\nunsigned count;\r\ncount = omap1_spi100k_txrx_pio(spi, t);\r\nm->actual_length += count;\r\nif (count != t->len) {\r\nstatus = -EIO;\r\nbreak;\r\n}\r\n}\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (t->cs_change) {\r\nomap1_spi100k_force_cs(spi100k, 0);\r\ncs_active = 0;\r\n}\r\n}\r\nif (par_override) {\r\npar_override = 0;\r\nstatus = omap1_spi100k_setup_transfer(spi, NULL);\r\n}\r\nif (cs_active)\r\nomap1_spi100k_force_cs(spi100k, 0);\r\nm->status = status;\r\nm->complete(m->context);\r\nspin_lock_irq(&spi100k->lock);\r\n}\r\nclk_disable(spi100k->ick);\r\nclk_disable(spi100k->fck);\r\nspin_unlock_irq(&spi100k->lock);\r\nif (status < 0)\r\nprintk(KERN_WARNING "spi transfer failed with %d\n", status);\r\n}\r\nstatic int omap1_spi100k_transfer(struct spi_device *spi, struct spi_message *m)\r\n{\r\nstruct omap1_spi100k *spi100k;\r\nunsigned long flags;\r\nstruct spi_transfer *t;\r\nm->actual_length = 0;\r\nm->status = -EINPROGRESS;\r\nspi100k = spi_master_get_devdata(spi->master);\r\nif (spi100k->state == SPI_SHUTDOWN)\r\nreturn -ESHUTDOWN;\r\nif (list_empty(&m->transfers) || !m->complete)\r\nreturn -EINVAL;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nconst void *tx_buf = t->tx_buf;\r\nvoid *rx_buf = t->rx_buf;\r\nunsigned len = t->len;\r\nif (t->speed_hz > OMAP1_SPI100K_MAX_FREQ\r\n|| (len && !(rx_buf || tx_buf))\r\n|| (t->bits_per_word &&\r\n( t->bits_per_word < 4\r\n|| t->bits_per_word > 32))) {\r\ndev_dbg(&spi->dev, "transfer: %d Hz, %d %s%s, %d bpw\n",\r\nt->speed_hz,\r\nlen,\r\ntx_buf ? "tx" : "",\r\nrx_buf ? "rx" : "",\r\nt->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nif (t->speed_hz && t->speed_hz < OMAP1_SPI100K_MAX_FREQ/(1<<16)) {\r\ndev_dbg(&spi->dev, "%d Hz max exceeds %d\n",\r\nt->speed_hz,\r\nOMAP1_SPI100K_MAX_FREQ/(1<<16));\r\nreturn -EINVAL;\r\n}\r\n}\r\nspin_lock_irqsave(&spi100k->lock, flags);\r\nlist_add_tail(&m->queue, &spi100k->msg_queue);\r\nqueue_work(omap1_spi100k_wq, &spi100k->work);\r\nspin_unlock_irqrestore(&spi100k->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init omap1_spi100k_reset(struct omap1_spi100k *spi100k)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __devinit omap1_spi100k_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct omap1_spi100k *spi100k;\r\nint status = 0;\r\nif (!pdev->id)\r\nreturn -EINVAL;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof *spi100k);\r\nif (master == NULL) {\r\ndev_dbg(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (pdev->id != -1)\r\nmaster->bus_num = pdev->id;\r\nmaster->setup = omap1_spi100k_setup;\r\nmaster->transfer = omap1_spi100k_transfer;\r\nmaster->cleanup = NULL;\r\nmaster->num_chipselect = 2;\r\nmaster->mode_bits = MODEBITS;\r\ndev_set_drvdata(&pdev->dev, master);\r\nspi100k = spi_master_get_devdata(master);\r\nspi100k->master = master;\r\nspi100k->base = (void __iomem *) pdev->dev.platform_data;\r\nINIT_WORK(&spi100k->work, omap1_spi100k_work);\r\nspin_lock_init(&spi100k->lock);\r\nINIT_LIST_HEAD(&spi100k->msg_queue);\r\nspi100k->ick = clk_get(&pdev->dev, "ick");\r\nif (IS_ERR(spi100k->ick)) {\r\ndev_dbg(&pdev->dev, "can't get spi100k_ick\n");\r\nstatus = PTR_ERR(spi100k->ick);\r\ngoto err1;\r\n}\r\nspi100k->fck = clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(spi100k->fck)) {\r\ndev_dbg(&pdev->dev, "can't get spi100k_fck\n");\r\nstatus = PTR_ERR(spi100k->fck);\r\ngoto err2;\r\n}\r\nif (omap1_spi100k_reset(spi100k) < 0)\r\ngoto err3;\r\nstatus = spi_register_master(master);\r\nif (status < 0)\r\ngoto err3;\r\nspi100k->state = SPI_RUNNING;\r\nreturn status;\r\nerr3:\r\nclk_put(spi100k->fck);\r\nerr2:\r\nclk_put(spi100k->ick);\r\nerr1:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int __exit omap1_spi100k_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct omap1_spi100k *spi100k;\r\nstruct resource *r;\r\nunsigned limit = 500;\r\nunsigned long flags;\r\nint status = 0;\r\nmaster = dev_get_drvdata(&pdev->dev);\r\nspi100k = spi_master_get_devdata(master);\r\nspin_lock_irqsave(&spi100k->lock, flags);\r\nspi100k->state = SPI_SHUTDOWN;\r\nwhile (!list_empty(&spi100k->msg_queue) && limit--) {\r\nspin_unlock_irqrestore(&spi100k->lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&spi100k->lock, flags);\r\n}\r\nif (!list_empty(&spi100k->msg_queue))\r\nstatus = -EBUSY;\r\nspin_unlock_irqrestore(&spi100k->lock, flags);\r\nif (status != 0)\r\nreturn status;\r\nclk_put(spi100k->fck);\r\nclk_put(spi100k->ick);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspi_unregister_master(master);\r\nreturn 0;\r\n}\r\nstatic int __init omap1_spi100k_init(void)\r\n{\r\nomap1_spi100k_wq = create_singlethread_workqueue(\r\nomap1_spi100k_driver.driver.name);\r\nif (omap1_spi100k_wq == NULL)\r\nreturn -1;\r\nreturn platform_driver_probe(&omap1_spi100k_driver, omap1_spi100k_probe);\r\n}\r\nstatic void __exit omap1_spi100k_exit(void)\r\n{\r\nplatform_driver_unregister(&omap1_spi100k_driver);\r\ndestroy_workqueue(omap1_spi100k_wq);\r\n}
