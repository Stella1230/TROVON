static int perf_event__repipe_synth(struct perf_tool *tool __used,\r\nunion perf_event *event,\r\nstruct machine *machine __used)\r\n{\r\nuint32_t size;\r\nvoid *buf = event;\r\nsize = event->header.size;\r\nwhile (size) {\r\nint ret = write(STDOUT_FILENO, buf, size);\r\nif (ret < 0)\r\nreturn -errno;\r\nsize -= ret;\r\nbuf += ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_event__repipe_op2_synth(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_session *session __used)\r\n{\r\nreturn perf_event__repipe_synth(tool, event, NULL);\r\n}\r\nstatic int perf_event__repipe_event_type_synth(struct perf_tool *tool,\r\nunion perf_event *event)\r\n{\r\nreturn perf_event__repipe_synth(tool, event, NULL);\r\n}\r\nstatic int perf_event__repipe_tracing_data_synth(union perf_event *event,\r\nstruct perf_session *session __used)\r\n{\r\nreturn perf_event__repipe_synth(NULL, event, NULL);\r\n}\r\nstatic int perf_event__repipe_attr(union perf_event *event,\r\nstruct perf_evlist **pevlist __used)\r\n{\r\nint ret;\r\nret = perf_event__process_attr(event, pevlist);\r\nif (ret)\r\nreturn ret;\r\nreturn perf_event__repipe_synth(NULL, event, NULL);\r\n}\r\nstatic int perf_event__repipe(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __used,\r\nstruct machine *machine)\r\n{\r\nreturn perf_event__repipe_synth(tool, event, machine);\r\n}\r\nstatic int perf_event__repipe_sample(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __used,\r\nstruct perf_evsel *evsel __used,\r\nstruct machine *machine)\r\n{\r\nreturn perf_event__repipe_synth(tool, event, machine);\r\n}\r\nstatic int perf_event__repipe_mmap(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_mmap(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_task(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_task(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_tracing_data(union perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nint err;\r\nperf_event__repipe_synth(NULL, event, NULL);\r\nerr = perf_event__process_tracing_data(event, session);\r\nreturn err;\r\n}\r\nstatic int dso__read_build_id(struct dso *self)\r\n{\r\nif (self->has_build_id)\r\nreturn 0;\r\nif (filename__read_build_id(self->long_name, self->build_id,\r\nsizeof(self->build_id)) > 0) {\r\nself->has_build_id = true;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int dso__inject_build_id(struct dso *self, struct perf_tool *tool,\r\nstruct machine *machine)\r\n{\r\nu16 misc = PERF_RECORD_MISC_USER;\r\nint err;\r\nif (dso__read_build_id(self) < 0) {\r\npr_debug("no build_id found for %s\n", self->long_name);\r\nreturn -1;\r\n}\r\nif (self->kernel)\r\nmisc = PERF_RECORD_MISC_KERNEL;\r\nerr = perf_event__synthesize_build_id(tool, self, misc, perf_event__repipe,\r\nmachine);\r\nif (err) {\r\npr_err("Can't synthesize build_id event for %s\n", self->long_name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_event__inject_buildid(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __used,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nstruct thread *thread;\r\nu8 cpumode;\r\ncpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nthread = machine__findnew_thread(machine, event->ip.pid);\r\nif (thread == NULL) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\ngoto repipe;\r\n}\r\nthread__find_addr_map(thread, machine, cpumode, MAP__FUNCTION,\r\nevent->ip.ip, &al);\r\nif (al.map != NULL) {\r\nif (!al.map->dso->hit) {\r\nal.map->dso->hit = 1;\r\nif (map__load(al.map, NULL) >= 0) {\r\ndso__inject_build_id(al.map->dso, tool, machine);\r\n} else\r\npr_warning("no symbols found in %s, maybe "\r\n"install a debug package?\n",\r\nal.map->dso->long_name);\r\n}\r\n}\r\nrepipe:\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn 0;\r\n}\r\nstatic int __cmd_inject(void)\r\n{\r\nstruct perf_session *session;\r\nint ret = -EINVAL;\r\nsignal(SIGINT, sig_handler);\r\nif (inject_build_ids) {\r\nperf_inject.sample = perf_event__inject_buildid;\r\nperf_inject.mmap = perf_event__repipe_mmap;\r\nperf_inject.fork = perf_event__repipe_task;\r\nperf_inject.tracing_data = perf_event__repipe_tracing_data;\r\n}\r\nsession = perf_session__new(input_name, O_RDONLY, false, true, &perf_inject);\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\nret = perf_session__process_events(session, &perf_inject);\r\nperf_session__delete(session);\r\nreturn ret;\r\n}\r\nint cmd_inject(int argc, const char **argv, const char *prefix __used)\r\n{\r\nargc = parse_options(argc, argv, options, report_usage, 0);\r\nif (argc)\r\nusage_with_options(report_usage, options);\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nreturn __cmd_inject();\r\n}
