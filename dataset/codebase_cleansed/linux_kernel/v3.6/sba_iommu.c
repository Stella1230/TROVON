static void\r\nsba_dump_tlb(char *hpa)\r\n{\r\nDBG_INIT("IO TLB at 0x%p\n", (void *)hpa);\r\nDBG_INIT("IOC_IBASE : %016lx\n", READ_REG(hpa+IOC_IBASE));\r\nDBG_INIT("IOC_IMASK : %016lx\n", READ_REG(hpa+IOC_IMASK));\r\nDBG_INIT("IOC_TCNFG : %016lx\n", READ_REG(hpa+IOC_TCNFG));\r\nDBG_INIT("IOC_PDIR_BASE: %016lx\n", READ_REG(hpa+IOC_PDIR_BASE));\r\nDBG_INIT("\n");\r\n}\r\nstatic void\r\nsba_dump_pdir_entry(struct ioc *ioc, char *msg, uint pide)\r\n{\r\nu64 *ptr = &ioc->pdir_base[pide & ~(BITS_PER_LONG - 1)];\r\nunsigned long *rptr = (unsigned long *) &ioc->res_map[(pide >>3) & -sizeof(unsigned long)];\r\nuint rcnt;\r\nprintk(KERN_DEBUG "SBA: %s rp %p bit %d rval 0x%lx\n",\r\nmsg, rptr, pide & (BITS_PER_LONG - 1), *rptr);\r\nrcnt = 0;\r\nwhile (rcnt < BITS_PER_LONG) {\r\nprintk(KERN_DEBUG "%s %2d %p %016Lx\n",\r\n(rcnt == (pide & (BITS_PER_LONG - 1)))\r\n? " -->" : " ",\r\nrcnt, ptr, (unsigned long long) *ptr );\r\nrcnt++;\r\nptr++;\r\n}\r\nprintk(KERN_DEBUG "%s", msg);\r\n}\r\nstatic int\r\nsba_check_pdir(struct ioc *ioc, char *msg)\r\n{\r\nu64 *rptr_end = (u64 *) &(ioc->res_map[ioc->res_size]);\r\nu64 *rptr = (u64 *) ioc->res_map;\r\nu64 *pptr = ioc->pdir_base;\r\nuint pide = 0;\r\nwhile (rptr < rptr_end) {\r\nu64 rval;\r\nint rcnt;\r\nrval = *rptr;\r\nrcnt = 64;\r\nwhile (rcnt) {\r\nu32 pde = ((u32)((*pptr >> (63)) & 0x1));\r\nif ((rval & 0x1) ^ pde)\r\n{\r\nsba_dump_pdir_entry(ioc, msg, pide);\r\nreturn(1);\r\n}\r\nrcnt--;\r\nrval >>= 1;\r\npptr++;\r\npide++;\r\n}\r\nrptr++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsba_dump_sg( struct ioc *ioc, struct scatterlist *startsg, int nents)\r\n{\r\nwhile (nents-- > 0) {\r\nprintk(KERN_DEBUG " %d : DMA %08lx/%05x CPU %p\n", nents,\r\nstartsg->dma_address, startsg->dma_length,\r\nsba_sg_address(startsg));\r\nstartsg = sg_next(startsg);\r\n}\r\n}\r\nstatic void\r\nsba_check_sg( struct ioc *ioc, struct scatterlist *startsg, int nents)\r\n{\r\nstruct scatterlist *the_sg = startsg;\r\nint the_nents = nents;\r\nwhile (the_nents-- > 0) {\r\nif (sba_sg_address(the_sg) == 0x0UL)\r\nsba_dump_sg(NULL, startsg, nents);\r\nthe_sg = sg_next(the_sg);\r\n}\r\n}\r\nstatic SBA_INLINE int\r\nget_iovp_order (unsigned long size)\r\n{\r\nlong double d = size - 1;\r\nlong order;\r\norder = ia64_getf_exp(d);\r\norder = order - iovp_shift - 0xffff + 1;\r\nif (order < 0)\r\norder = 0;\r\nreturn order;\r\n}\r\nstatic unsigned long ptr_to_pide(struct ioc *ioc, unsigned long *res_ptr,\r\nunsigned int bitshiftcnt)\r\n{\r\nreturn (((unsigned long)res_ptr - (unsigned long)ioc->res_map) << 3)\r\n+ bitshiftcnt;\r\n}\r\nstatic SBA_INLINE unsigned long\r\nsba_search_bitmap(struct ioc *ioc, struct device *dev,\r\nunsigned long bits_wanted, int use_hint)\r\n{\r\nunsigned long *res_ptr;\r\nunsigned long *res_end = (unsigned long *) &(ioc->res_map[ioc->res_size]);\r\nunsigned long flags, pide = ~0UL, tpide;\r\nunsigned long boundary_size;\r\nunsigned long shift;\r\nint ret;\r\nASSERT(((unsigned long) ioc->res_hint & (sizeof(unsigned long) - 1UL)) == 0);\r\nASSERT(res_ptr < res_end);\r\nboundary_size = (unsigned long long)dma_get_seg_boundary(dev) + 1;\r\nboundary_size = ALIGN(boundary_size, 1ULL << iovp_shift) >> iovp_shift;\r\nBUG_ON(ioc->ibase & ~iovp_mask);\r\nshift = ioc->ibase >> iovp_shift;\r\nspin_lock_irqsave(&ioc->res_lock, flags);\r\nif (likely(use_hint)) {\r\nres_ptr = ioc->res_hint;\r\n} else {\r\nres_ptr = (ulong *)ioc->res_map;\r\nioc->res_bitshift = 0;\r\n}\r\nbits_wanted = 1UL << get_iovp_order(bits_wanted << iovp_shift);\r\nif (likely(bits_wanted == 1)) {\r\nunsigned int bitshiftcnt;\r\nfor(; res_ptr < res_end ; res_ptr++) {\r\nif (likely(*res_ptr != ~0UL)) {\r\nbitshiftcnt = ffz(*res_ptr);\r\n*res_ptr |= (1UL << bitshiftcnt);\r\npide = ptr_to_pide(ioc, res_ptr, bitshiftcnt);\r\nioc->res_bitshift = bitshiftcnt + bits_wanted;\r\ngoto found_it;\r\n}\r\n}\r\ngoto not_found;\r\n}\r\nif (likely(bits_wanted <= BITS_PER_LONG/2)) {\r\nunsigned long o = 1 << get_iovp_order(bits_wanted << iovp_shift);\r\nuint bitshiftcnt = ROUNDUP(ioc->res_bitshift, o);\r\nunsigned long mask, base_mask;\r\nbase_mask = RESMAP_MASK(bits_wanted);\r\nmask = base_mask << bitshiftcnt;\r\nDBG_RES("%s() o %ld %p", __func__, o, res_ptr);\r\nfor(; res_ptr < res_end ; res_ptr++)\r\n{\r\nDBG_RES(" %p %lx %lx\n", res_ptr, mask, *res_ptr);\r\nASSERT(0 != mask);\r\nfor (; mask ; mask <<= o, bitshiftcnt += o) {\r\ntpide = ptr_to_pide(ioc, res_ptr, bitshiftcnt);\r\nret = iommu_is_span_boundary(tpide, bits_wanted,\r\nshift,\r\nboundary_size);\r\nif ((0 == ((*res_ptr) & mask)) && !ret) {\r\n*res_ptr |= mask;\r\npide = tpide;\r\nioc->res_bitshift = bitshiftcnt + bits_wanted;\r\ngoto found_it;\r\n}\r\n}\r\nbitshiftcnt = 0;\r\nmask = base_mask;\r\n}\r\n} else {\r\nint qwords, bits, i;\r\nunsigned long *end;\r\nqwords = bits_wanted >> 6;\r\nbits = bits_wanted - (qwords * BITS_PER_LONG);\r\nend = res_end - qwords;\r\nfor (; res_ptr < end; res_ptr++) {\r\ntpide = ptr_to_pide(ioc, res_ptr, 0);\r\nret = iommu_is_span_boundary(tpide, bits_wanted,\r\nshift, boundary_size);\r\nif (ret)\r\ngoto next_ptr;\r\nfor (i = 0 ; i < qwords ; i++) {\r\nif (res_ptr[i] != 0)\r\ngoto next_ptr;\r\n}\r\nif (bits && res_ptr[i] && (__ffs(res_ptr[i]) < bits))\r\ncontinue;\r\nfor (i = 0 ; i < qwords ; i++)\r\nres_ptr[i] = ~0UL;\r\nres_ptr[i] |= RESMAP_MASK(bits);\r\npide = tpide;\r\nres_ptr += qwords;\r\nioc->res_bitshift = bits;\r\ngoto found_it;\r\nnext_ptr:\r\n;\r\n}\r\n}\r\nnot_found:\r\nprefetch(ioc->res_map);\r\nioc->res_hint = (unsigned long *) ioc->res_map;\r\nioc->res_bitshift = 0;\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\nreturn (pide);\r\nfound_it:\r\nioc->res_hint = res_ptr;\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\nreturn (pide);\r\n}\r\nstatic int\r\nsba_alloc_range(struct ioc *ioc, struct device *dev, size_t size)\r\n{\r\nunsigned int pages_needed = size >> iovp_shift;\r\n#ifdef PDIR_SEARCH_TIMING\r\nunsigned long itc_start;\r\n#endif\r\nunsigned long pide;\r\nASSERT(pages_needed);\r\nASSERT(0 == (size & ~iovp_mask));\r\n#ifdef PDIR_SEARCH_TIMING\r\nitc_start = ia64_get_itc();\r\n#endif\r\npide = sba_search_bitmap(ioc, dev, pages_needed, 1);\r\nif (unlikely(pide >= (ioc->res_size << 3))) {\r\npide = sba_search_bitmap(ioc, dev, pages_needed, 0);\r\nif (unlikely(pide >= (ioc->res_size << 3))) {\r\n#if DELAYED_RESOURCE_CNT > 0\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->saved_lock, flags);\r\nif (ioc->saved_cnt > 0) {\r\nstruct sba_dma_pair *d;\r\nint cnt = ioc->saved_cnt;\r\nd = &(ioc->saved[ioc->saved_cnt - 1]);\r\nspin_lock(&ioc->res_lock);\r\nwhile (cnt--) {\r\nsba_mark_invalid(ioc, d->iova, d->size);\r\nsba_free_range(ioc, d->iova, d->size);\r\nd--;\r\n}\r\nioc->saved_cnt = 0;\r\nREAD_REG(ioc->ioc_hpa+IOC_PCOM);\r\nspin_unlock(&ioc->res_lock);\r\n}\r\nspin_unlock_irqrestore(&ioc->saved_lock, flags);\r\npide = sba_search_bitmap(ioc, dev, pages_needed, 0);\r\nif (unlikely(pide >= (ioc->res_size << 3))) {\r\nprintk(KERN_WARNING "%s: I/O MMU @ %p is"\r\n"out of mapping resources, %u %u %lx\n",\r\n__func__, ioc->ioc_hpa, ioc->res_size,\r\npages_needed, dma_get_seg_boundary(dev));\r\nreturn -1;\r\n}\r\n#else\r\nprintk(KERN_WARNING "%s: I/O MMU @ %p is"\r\n"out of mapping resources, %u %u %lx\n",\r\n__func__, ioc->ioc_hpa, ioc->res_size,\r\npages_needed, dma_get_seg_boundary(dev));\r\nreturn -1;\r\n#endif\r\n}\r\n}\r\n#ifdef PDIR_SEARCH_TIMING\r\nioc->avg_search[ioc->avg_idx++] = (ia64_get_itc() - itc_start) / pages_needed;\r\nioc->avg_idx &= SBA_SEARCH_SAMPLE - 1;\r\n#endif\r\nprefetchw(&(ioc->pdir_base[pide]));\r\n#ifdef ASSERT_PDIR_SANITY\r\nif(0x00 != ((u8 *) ioc->pdir_base)[pide*PDIR_ENTRY_SIZE + 7]) {\r\nsba_dump_pdir_entry(ioc, "sba_search_bitmap() botched it?", pide);\r\n}\r\n#endif\r\nDBG_RES("%s(%x) %d -> %lx hint %x/%x\n",\r\n__func__, size, pages_needed, pide,\r\n(uint) ((unsigned long) ioc->res_hint - (unsigned long) ioc->res_map),\r\nioc->res_bitshift );\r\nreturn (pide);\r\n}\r\nstatic SBA_INLINE void\r\nsba_free_range(struct ioc *ioc, dma_addr_t iova, size_t size)\r\n{\r\nunsigned long iovp = SBA_IOVP(ioc, iova);\r\nunsigned int pide = PDIR_INDEX(iovp);\r\nunsigned int ridx = pide >> 3;\r\nunsigned long *res_ptr = (unsigned long *) &((ioc)->res_map[ridx & ~RESMAP_IDX_MASK]);\r\nint bits_not_wanted = size >> iovp_shift;\r\nunsigned long m;\r\nbits_not_wanted = 1UL << get_iovp_order(bits_not_wanted << iovp_shift);\r\nfor (; bits_not_wanted > 0 ; res_ptr++) {\r\nif (unlikely(bits_not_wanted > BITS_PER_LONG)) {\r\n*res_ptr = 0UL;\r\nbits_not_wanted -= BITS_PER_LONG;\r\npide += BITS_PER_LONG;\r\n} else {\r\nm = RESMAP_MASK(bits_not_wanted) << (pide & (BITS_PER_LONG - 1));\r\nbits_not_wanted = 0;\r\nDBG_RES("%s( ,%x,%x) %x/%lx %x %p %lx\n", __func__, (uint) iova, size,\r\nbits_not_wanted, m, pide, res_ptr, *res_ptr);\r\nASSERT(m != 0);\r\nASSERT(bits_not_wanted);\r\nASSERT((*res_ptr & m) == m);\r\n*res_ptr &= ~m;\r\n}\r\n}\r\n}\r\nvoid SBA_INLINE\r\nsba_io_pdir_entry(u64 *pdir_ptr, unsigned long vba)\r\n{\r\n*pdir_ptr = ((vba & ~0xE000000000000FFFULL) | 0x80000000000000FFULL);\r\n}\r\nstatic void\r\nmark_clean (void *addr, size_t size)\r\n{\r\nunsigned long pg_addr, end;\r\npg_addr = PAGE_ALIGN((unsigned long) addr);\r\nend = (unsigned long) addr + size;\r\nwhile (pg_addr + PAGE_SIZE <= end) {\r\nstruct page *page = virt_to_page((void *)pg_addr);\r\nset_bit(PG_arch_1, &page->flags);\r\npg_addr += PAGE_SIZE;\r\n}\r\n}\r\nstatic SBA_INLINE void\r\nsba_mark_invalid(struct ioc *ioc, dma_addr_t iova, size_t byte_cnt)\r\n{\r\nu32 iovp = (u32) SBA_IOVP(ioc,iova);\r\nint off = PDIR_INDEX(iovp);\r\nASSERT(byte_cnt > 0);\r\nASSERT(0 == (byte_cnt & ~iovp_mask));\r\n#ifdef ASSERT_PDIR_SANITY\r\nif (!(ioc->pdir_base[off] >> 60)) {\r\nsba_dump_pdir_entry(ioc,"sba_mark_invalid()", PDIR_INDEX(iovp));\r\n}\r\n#endif\r\nif (byte_cnt <= iovp_size)\r\n{\r\nASSERT(off < ioc->pdir_size);\r\niovp |= iovp_shift;\r\n#ifndef FULL_VALID_PDIR\r\nioc->pdir_base[off] &= ~(0x80000000000000FFULL);\r\n#else\r\nioc->pdir_base[off] = (0x80000000000000FFULL | prefetch_spill_page);\r\n#endif\r\n} else {\r\nu32 t = get_iovp_order(byte_cnt) + iovp_shift;\r\niovp |= t;\r\nASSERT(t <= 31);\r\ndo {\r\nASSERT(ioc->pdir_base[off] >> 63);\r\n#ifndef FULL_VALID_PDIR\r\nioc->pdir_base[off] &= ~(0x80000000000000FFULL);\r\n#else\r\nioc->pdir_base[off] = (0x80000000000000FFULL | prefetch_spill_page);\r\n#endif\r\noff++;\r\nbyte_cnt -= iovp_size;\r\n} while (byte_cnt > 0);\r\n}\r\nWRITE_REG(iovp | ioc->ibase, ioc->ioc_hpa+IOC_PCOM);\r\n}\r\nstatic dma_addr_t sba_map_page(struct device *dev, struct page *page,\r\nunsigned long poff, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct ioc *ioc;\r\nvoid *addr = page_address(page) + poff;\r\ndma_addr_t iovp;\r\ndma_addr_t offset;\r\nu64 *pdir_start;\r\nint pide;\r\n#ifdef ASSERT_PDIR_SANITY\r\nunsigned long flags;\r\n#endif\r\n#ifdef ALLOW_IOV_BYPASS\r\nunsigned long pci_addr = virt_to_phys(addr);\r\n#endif\r\n#ifdef ALLOW_IOV_BYPASS\r\nASSERT(to_pci_dev(dev)->dma_mask);\r\nif (likely((pci_addr & ~to_pci_dev(dev)->dma_mask) == 0)) {\r\nDBG_BYPASS("sba_map_single_attrs() bypass mask/addr: "\r\n"0x%lx/0x%lx\n",\r\nto_pci_dev(dev)->dma_mask, pci_addr);\r\nreturn pci_addr;\r\n}\r\n#endif\r\nioc = GET_IOC(dev);\r\nASSERT(ioc);\r\nprefetch(ioc->res_hint);\r\nASSERT(size > 0);\r\nASSERT(size <= DMA_CHUNK_SIZE);\r\noffset = ((dma_addr_t) (long) addr) & ~iovp_mask;\r\nsize = (size + offset + ~iovp_mask) & iovp_mask;\r\n#ifdef ASSERT_PDIR_SANITY\r\nspin_lock_irqsave(&ioc->res_lock, flags);\r\nif (sba_check_pdir(ioc,"Check before sba_map_single_attrs()"))\r\npanic("Sanity check failed");\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\n#endif\r\npide = sba_alloc_range(ioc, dev, size);\r\nif (pide < 0)\r\nreturn 0;\r\niovp = (dma_addr_t) pide << iovp_shift;\r\nDBG_RUN("%s() 0x%p -> 0x%lx\n", __func__, addr, (long) iovp | offset);\r\npdir_start = &(ioc->pdir_base[pide]);\r\nwhile (size > 0) {\r\nASSERT(((u8 *)pdir_start)[7] == 0);\r\nsba_io_pdir_entry(pdir_start, (unsigned long) addr);\r\nDBG_RUN(" pdir 0x%p %lx\n", pdir_start, *pdir_start);\r\naddr += iovp_size;\r\nsize -= iovp_size;\r\npdir_start++;\r\n}\r\nwmb();\r\n#ifdef ASSERT_PDIR_SANITY\r\nspin_lock_irqsave(&ioc->res_lock, flags);\r\nsba_check_pdir(ioc,"Check after sba_map_single_attrs()");\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\n#endif\r\nreturn SBA_IOVA(ioc, iovp, offset);\r\n}\r\nstatic dma_addr_t sba_map_single_attrs(struct device *dev, void *addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn sba_map_page(dev, virt_to_page(addr),\r\n(unsigned long)addr & ~PAGE_MASK, size, dir, attrs);\r\n}\r\nstatic SBA_INLINE void\r\nsba_mark_clean(struct ioc *ioc, dma_addr_t iova, size_t size)\r\n{\r\nu32 iovp = (u32) SBA_IOVP(ioc,iova);\r\nint off = PDIR_INDEX(iovp);\r\nvoid *addr;\r\nif (size <= iovp_size) {\r\naddr = phys_to_virt(ioc->pdir_base[off] &\r\n~0xE000000000000FFFULL);\r\nmark_clean(addr, size);\r\n} else {\r\ndo {\r\naddr = phys_to_virt(ioc->pdir_base[off] &\r\n~0xE000000000000FFFULL);\r\nmark_clean(addr, min(size, iovp_size));\r\noff++;\r\nsize -= iovp_size;\r\n} while (size > 0);\r\n}\r\n}\r\nstatic void sba_unmap_page(struct device *dev, dma_addr_t iova, size_t size,\r\nenum dma_data_direction dir, struct dma_attrs *attrs)\r\n{\r\nstruct ioc *ioc;\r\n#if DELAYED_RESOURCE_CNT > 0\r\nstruct sba_dma_pair *d;\r\n#endif\r\nunsigned long flags;\r\ndma_addr_t offset;\r\nioc = GET_IOC(dev);\r\nASSERT(ioc);\r\n#ifdef ALLOW_IOV_BYPASS\r\nif (likely((iova & ioc->imask) != ioc->ibase)) {\r\nDBG_BYPASS("sba_unmap_single_attrs() bypass addr: 0x%lx\n",\r\niova);\r\n#ifdef ENABLE_MARK_CLEAN\r\nif (dir == DMA_FROM_DEVICE) {\r\nmark_clean(phys_to_virt(iova), size);\r\n}\r\n#endif\r\nreturn;\r\n}\r\n#endif\r\noffset = iova & ~iovp_mask;\r\nDBG_RUN("%s() iovp 0x%lx/%x\n", __func__, (long) iova, size);\r\niova ^= offset;\r\nsize += offset;\r\nsize = ROUNDUP(size, iovp_size);\r\n#ifdef ENABLE_MARK_CLEAN\r\nif (dir == DMA_FROM_DEVICE)\r\nsba_mark_clean(ioc, iova, size);\r\n#endif\r\n#if DELAYED_RESOURCE_CNT > 0\r\nspin_lock_irqsave(&ioc->saved_lock, flags);\r\nd = &(ioc->saved[ioc->saved_cnt]);\r\nd->iova = iova;\r\nd->size = size;\r\nif (unlikely(++(ioc->saved_cnt) >= DELAYED_RESOURCE_CNT)) {\r\nint cnt = ioc->saved_cnt;\r\nspin_lock(&ioc->res_lock);\r\nwhile (cnt--) {\r\nsba_mark_invalid(ioc, d->iova, d->size);\r\nsba_free_range(ioc, d->iova, d->size);\r\nd--;\r\n}\r\nioc->saved_cnt = 0;\r\nREAD_REG(ioc->ioc_hpa+IOC_PCOM);\r\nspin_unlock(&ioc->res_lock);\r\n}\r\nspin_unlock_irqrestore(&ioc->saved_lock, flags);\r\n#else\r\nspin_lock_irqsave(&ioc->res_lock, flags);\r\nsba_mark_invalid(ioc, iova, size);\r\nsba_free_range(ioc, iova, size);\r\nREAD_REG(ioc->ioc_hpa+IOC_PCOM);\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\n#endif\r\n}\r\nvoid sba_unmap_single_attrs(struct device *dev, dma_addr_t iova, size_t size,\r\nenum dma_data_direction dir, struct dma_attrs *attrs)\r\n{\r\nsba_unmap_page(dev, iova, size, dir, attrs);\r\n}\r\nstatic void *\r\nsba_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle,\r\ngfp_t flags, struct dma_attrs *attrs)\r\n{\r\nstruct ioc *ioc;\r\nvoid *addr;\r\nioc = GET_IOC(dev);\r\nASSERT(ioc);\r\n#ifdef CONFIG_NUMA\r\n{\r\nstruct page *page;\r\npage = alloc_pages_exact_node(ioc->node == MAX_NUMNODES ?\r\nnuma_node_id() : ioc->node, flags,\r\nget_order(size));\r\nif (unlikely(!page))\r\nreturn NULL;\r\naddr = page_address(page);\r\n}\r\n#else\r\naddr = (void *) __get_free_pages(flags, get_order(size));\r\n#endif\r\nif (unlikely(!addr))\r\nreturn NULL;\r\nmemset(addr, 0, size);\r\n*dma_handle = virt_to_phys(addr);\r\n#ifdef ALLOW_IOV_BYPASS\r\nASSERT(dev->coherent_dma_mask);\r\nif (likely((*dma_handle & ~dev->coherent_dma_mask) == 0)) {\r\nDBG_BYPASS("sba_alloc_coherent() bypass mask/addr: 0x%lx/0x%lx\n",\r\ndev->coherent_dma_mask, *dma_handle);\r\nreturn addr;\r\n}\r\n#endif\r\n*dma_handle = sba_map_single_attrs(&ioc->sac_only_dev->dev, addr,\r\nsize, 0, NULL);\r\nreturn addr;\r\n}\r\nstatic void sba_free_coherent(struct device *dev, size_t size, void *vaddr,\r\ndma_addr_t dma_handle, struct dma_attrs *attrs)\r\n{\r\nsba_unmap_single_attrs(dev, dma_handle, size, 0, NULL);\r\nfree_pages((unsigned long) vaddr, get_order(size));\r\n}\r\nstatic SBA_INLINE int\r\nsba_fill_pdir(\r\nstruct ioc *ioc,\r\nstruct scatterlist *startsg,\r\nint nents)\r\n{\r\nstruct scatterlist *dma_sg = startsg;\r\nint n_mappings = 0;\r\nu64 *pdirp = NULL;\r\nunsigned long dma_offset = 0;\r\nwhile (nents-- > 0) {\r\nint cnt = startsg->dma_length;\r\nstartsg->dma_length = 0;\r\n#ifdef DEBUG_LARGE_SG_ENTRIES\r\nif (dump_run_sg)\r\nprintk(" %2d : %08lx/%05x %p\n",\r\nnents, startsg->dma_address, cnt,\r\nsba_sg_address(startsg));\r\n#else\r\nDBG_RUN_SG(" %d : %08lx/%05x %p\n",\r\nnents, startsg->dma_address, cnt,\r\nsba_sg_address(startsg));\r\n#endif\r\nif (startsg->dma_address & PIDE_FLAG) {\r\nu32 pide = startsg->dma_address & ~PIDE_FLAG;\r\ndma_offset = (unsigned long) pide & ~iovp_mask;\r\nstartsg->dma_address = 0;\r\nif (n_mappings)\r\ndma_sg = sg_next(dma_sg);\r\ndma_sg->dma_address = pide | ioc->ibase;\r\npdirp = &(ioc->pdir_base[pide >> iovp_shift]);\r\nn_mappings++;\r\n}\r\nif (cnt) {\r\nunsigned long vaddr = (unsigned long) sba_sg_address(startsg);\r\nASSERT(pdirp);\r\ndma_sg->dma_length += cnt;\r\ncnt += dma_offset;\r\ndma_offset=0;\r\ncnt = ROUNDUP(cnt, iovp_size);\r\ndo {\r\nsba_io_pdir_entry(pdirp, vaddr);\r\nvaddr += iovp_size;\r\ncnt -= iovp_size;\r\npdirp++;\r\n} while (cnt > 0);\r\n}\r\nstartsg = sg_next(startsg);\r\n}\r\nwmb();\r\n#ifdef DEBUG_LARGE_SG_ENTRIES\r\ndump_run_sg = 0;\r\n#endif\r\nreturn(n_mappings);\r\n}\r\nstatic SBA_INLINE int\r\nsba_coalesce_chunks(struct ioc *ioc, struct device *dev,\r\nstruct scatterlist *startsg,\r\nint nents)\r\n{\r\nstruct scatterlist *vcontig_sg;\r\nunsigned long vcontig_len;\r\nunsigned long vcontig_end;\r\nstruct scatterlist *dma_sg;\r\nunsigned long dma_offset, dma_len;\r\nint n_mappings = 0;\r\nunsigned int max_seg_size = dma_get_max_seg_size(dev);\r\nint idx;\r\nwhile (nents > 0) {\r\nunsigned long vaddr = (unsigned long) sba_sg_address(startsg);\r\ndma_sg = vcontig_sg = startsg;\r\ndma_len = vcontig_len = vcontig_end = startsg->length;\r\nvcontig_end += vaddr;\r\ndma_offset = vaddr & ~iovp_mask;\r\nstartsg->dma_address = startsg->dma_length = 0;\r\nwhile (--nents > 0) {\r\nunsigned long vaddr;\r\nstartsg = sg_next(startsg);\r\nstartsg->dma_address = startsg->dma_length = 0;\r\nASSERT(startsg->length <= DMA_CHUNK_SIZE);\r\nif (((dma_len + dma_offset + startsg->length + ~iovp_mask) & iovp_mask)\r\n> DMA_CHUNK_SIZE)\r\nbreak;\r\nif (dma_len + startsg->length > max_seg_size)\r\nbreak;\r\nvaddr = (unsigned long) sba_sg_address(startsg);\r\nif (vcontig_end == vaddr)\r\n{\r\nvcontig_len += startsg->length;\r\nvcontig_end += startsg->length;\r\ndma_len += startsg->length;\r\ncontinue;\r\n}\r\n#ifdef DEBUG_LARGE_SG_ENTRIES\r\ndump_run_sg = (vcontig_len > iovp_size);\r\n#endif\r\nvcontig_sg->dma_length = vcontig_len;\r\nvcontig_sg = startsg;\r\nvcontig_len = startsg->length;\r\nif (DMA_CONTIG(vcontig_end, vaddr))\r\n{\r\nvcontig_end = vcontig_len + vaddr;\r\ndma_len += vcontig_len;\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nvcontig_sg->dma_length = vcontig_len;\r\ndma_len = (dma_len + dma_offset + ~iovp_mask) & iovp_mask;\r\nASSERT(dma_len <= DMA_CHUNK_SIZE);\r\nidx = sba_alloc_range(ioc, dev, dma_len);\r\nif (idx < 0) {\r\ndma_sg->dma_length = 0;\r\nreturn -1;\r\n}\r\ndma_sg->dma_address = (dma_addr_t)(PIDE_FLAG | (idx << iovp_shift)\r\n| dma_offset);\r\nn_mappings++;\r\n}\r\nreturn n_mappings;\r\n}\r\nstatic int sba_map_sg_attrs(struct device *dev, struct scatterlist *sglist,\r\nint nents, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct ioc *ioc;\r\nint coalesced, filled = 0;\r\n#ifdef ASSERT_PDIR_SANITY\r\nunsigned long flags;\r\n#endif\r\n#ifdef ALLOW_IOV_BYPASS_SG\r\nstruct scatterlist *sg;\r\n#endif\r\nDBG_RUN_SG("%s() START %d entries\n", __func__, nents);\r\nioc = GET_IOC(dev);\r\nASSERT(ioc);\r\n#ifdef ALLOW_IOV_BYPASS_SG\r\nASSERT(to_pci_dev(dev)->dma_mask);\r\nif (likely((ioc->dma_mask & ~to_pci_dev(dev)->dma_mask) == 0)) {\r\nfor_each_sg(sglist, sg, nents, filled) {\r\nsg->dma_length = sg->length;\r\nsg->dma_address = virt_to_phys(sba_sg_address(sg));\r\n}\r\nreturn filled;\r\n}\r\n#endif\r\nif (nents == 1) {\r\nsglist->dma_length = sglist->length;\r\nsglist->dma_address = sba_map_single_attrs(dev, sba_sg_address(sglist), sglist->length, dir, attrs);\r\nreturn 1;\r\n}\r\n#ifdef ASSERT_PDIR_SANITY\r\nspin_lock_irqsave(&ioc->res_lock, flags);\r\nif (sba_check_pdir(ioc,"Check before sba_map_sg_attrs()"))\r\n{\r\nsba_dump_sg(ioc, sglist, nents);\r\npanic("Check before sba_map_sg_attrs()");\r\n}\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\n#endif\r\nprefetch(ioc->res_hint);\r\ncoalesced = sba_coalesce_chunks(ioc, dev, sglist, nents);\r\nif (coalesced < 0) {\r\nsba_unmap_sg_attrs(dev, sglist, nents, dir, attrs);\r\nreturn 0;\r\n}\r\nfilled = sba_fill_pdir(ioc, sglist, nents);\r\n#ifdef ASSERT_PDIR_SANITY\r\nspin_lock_irqsave(&ioc->res_lock, flags);\r\nif (sba_check_pdir(ioc,"Check after sba_map_sg_attrs()"))\r\n{\r\nsba_dump_sg(ioc, sglist, nents);\r\npanic("Check after sba_map_sg_attrs()\n");\r\n}\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\n#endif\r\nASSERT(coalesced == filled);\r\nDBG_RUN_SG("%s() DONE %d mappings\n", __func__, filled);\r\nreturn filled;\r\n}\r\nstatic void sba_unmap_sg_attrs(struct device *dev, struct scatterlist *sglist,\r\nint nents, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\n#ifdef ASSERT_PDIR_SANITY\r\nstruct ioc *ioc;\r\nunsigned long flags;\r\n#endif\r\nDBG_RUN_SG("%s() START %d entries, %p,%x\n",\r\n__func__, nents, sba_sg_address(sglist), sglist->length);\r\n#ifdef ASSERT_PDIR_SANITY\r\nioc = GET_IOC(dev);\r\nASSERT(ioc);\r\nspin_lock_irqsave(&ioc->res_lock, flags);\r\nsba_check_pdir(ioc,"Check before sba_unmap_sg_attrs()");\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\n#endif\r\nwhile (nents && sglist->dma_length) {\r\nsba_unmap_single_attrs(dev, sglist->dma_address,\r\nsglist->dma_length, dir, attrs);\r\nsglist = sg_next(sglist);\r\nnents--;\r\n}\r\nDBG_RUN_SG("%s() DONE (nents %d)\n", __func__, nents);\r\n#ifdef ASSERT_PDIR_SANITY\r\nspin_lock_irqsave(&ioc->res_lock, flags);\r\nsba_check_pdir(ioc,"Check after sba_unmap_sg_attrs()");\r\nspin_unlock_irqrestore(&ioc->res_lock, flags);\r\n#endif\r\n}\r\nstatic void __init\r\nioc_iova_init(struct ioc *ioc)\r\n{\r\nint tcnfg;\r\nint agp_found = 0;\r\nstruct pci_dev *device = NULL;\r\n#ifdef FULL_VALID_PDIR\r\nunsigned long index;\r\n#endif\r\nioc->ibase = READ_REG(ioc->ioc_hpa + IOC_IBASE) & ~0x1UL;\r\nioc->imask = READ_REG(ioc->ioc_hpa + IOC_IMASK) | 0xFFFFFFFF00000000UL;\r\nioc->iov_size = ~ioc->imask + 1;\r\nDBG_INIT("%s() hpa %p IOV base 0x%lx mask 0x%lx (%dMB)\n",\r\n__func__, ioc->ioc_hpa, ioc->ibase, ioc->imask,\r\nioc->iov_size >> 20);\r\nswitch (iovp_size) {\r\ncase 4*1024: tcnfg = 0; break;\r\ncase 8*1024: tcnfg = 1; break;\r\ncase 16*1024: tcnfg = 2; break;\r\ncase 64*1024: tcnfg = 3; break;\r\ndefault:\r\npanic(PFX "Unsupported IOTLB page size %ldK",\r\niovp_size >> 10);\r\nbreak;\r\n}\r\nWRITE_REG(tcnfg, ioc->ioc_hpa + IOC_TCNFG);\r\nioc->pdir_size = (ioc->iov_size / iovp_size) * PDIR_ENTRY_SIZE;\r\nioc->pdir_base = (void *) __get_free_pages(GFP_KERNEL,\r\nget_order(ioc->pdir_size));\r\nif (!ioc->pdir_base)\r\npanic(PFX "Couldn't allocate I/O Page Table\n");\r\nmemset(ioc->pdir_base, 0, ioc->pdir_size);\r\nDBG_INIT("%s() IOV page size %ldK pdir %p size %x\n", __func__,\r\niovp_size >> 10, ioc->pdir_base, ioc->pdir_size);\r\nASSERT(ALIGN((unsigned long) ioc->pdir_base, 4*1024) == (unsigned long) ioc->pdir_base);\r\nWRITE_REG(virt_to_phys(ioc->pdir_base), ioc->ioc_hpa + IOC_PDIR_BASE);\r\nfor_each_pci_dev(device)\r\nagp_found |= pci_find_capability(device, PCI_CAP_ID_AGP);\r\nif (agp_found && reserve_sba_gart) {\r\nprintk(KERN_INFO PFX "reserving %dMb of IOVA space at 0x%lx for agpgart\n",\r\nioc->iov_size/2 >> 20, ioc->ibase + ioc->iov_size/2);\r\nioc->pdir_size /= 2;\r\n((u64 *)ioc->pdir_base)[PDIR_INDEX(ioc->iov_size/2)] = ZX1_SBA_IOMMU_COOKIE;\r\n}\r\n#ifdef FULL_VALID_PDIR\r\nif (!prefetch_spill_page) {\r\nchar *spill_poison = "SBAIOMMU POISON";\r\nint poison_size = 16;\r\nvoid *poison_addr, *addr;\r\naddr = (void *)__get_free_pages(GFP_KERNEL, get_order(iovp_size));\r\nif (!addr)\r\npanic(PFX "Couldn't allocate PDIR spill page\n");\r\npoison_addr = addr;\r\nfor ( ; (u64) poison_addr < addr + iovp_size; poison_addr += poison_size)\r\nmemcpy(poison_addr, spill_poison, poison_size);\r\nprefetch_spill_page = virt_to_phys(addr);\r\nDBG_INIT("%s() prefetch spill addr: 0x%lx\n", __func__, prefetch_spill_page);\r\n}\r\nfor (index = 0 ; index < (ioc->pdir_size / PDIR_ENTRY_SIZE) ; index++)\r\n((u64 *)ioc->pdir_base)[index] = (0x80000000000000FF | prefetch_spill_page);\r\n#endif\r\nWRITE_REG(ioc->ibase | (get_iovp_order(ioc->iov_size) + iovp_shift), ioc->ioc_hpa + IOC_PCOM);\r\nREAD_REG(ioc->ioc_hpa + IOC_PCOM);\r\nWRITE_REG(ioc->ibase | 1, ioc->ioc_hpa + IOC_IBASE);\r\nREAD_REG(ioc->ioc_hpa + IOC_IBASE);\r\n}\r\nstatic void __init\r\nioc_resource_init(struct ioc *ioc)\r\n{\r\nspin_lock_init(&ioc->res_lock);\r\n#if DELAYED_RESOURCE_CNT > 0\r\nspin_lock_init(&ioc->saved_lock);\r\n#endif\r\nioc->res_size = ioc->pdir_size / PDIR_ENTRY_SIZE;\r\nioc->res_size >>= 3;\r\nDBG_INIT("%s() res_size 0x%x\n", __func__, ioc->res_size);\r\nioc->res_map = (char *) __get_free_pages(GFP_KERNEL,\r\nget_order(ioc->res_size));\r\nif (!ioc->res_map)\r\npanic(PFX "Couldn't allocate resource map\n");\r\nmemset(ioc->res_map, 0, ioc->res_size);\r\nioc->res_hint = (unsigned long *) ioc->res_map;\r\n#ifdef ASSERT_PDIR_SANITY\r\nioc->res_map[0] = 0x1;\r\nioc->pdir_base[0] = 0x8000000000000000ULL | ZX1_SBA_IOMMU_COOKIE;\r\n#endif\r\n#ifdef FULL_VALID_PDIR\r\nioc->res_map[ioc->res_size - 1] |= 0x80UL;\r\nioc->pdir_base[(ioc->pdir_size / PDIR_ENTRY_SIZE) - 1] = (0x80000000000000FF\r\n| prefetch_spill_page);\r\n#endif\r\nDBG_INIT("%s() res_map %x %p\n", __func__,\r\nioc->res_size, (void *) ioc->res_map);\r\n}\r\nstatic void __init\r\nioc_sac_init(struct ioc *ioc)\r\n{\r\nstruct pci_dev *sac = NULL;\r\nstruct pci_controller *controller = NULL;\r\nsac = kzalloc(sizeof(*sac), GFP_KERNEL);\r\nif (!sac)\r\npanic(PFX "Couldn't allocate struct pci_dev");\r\ncontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\r\nif (!controller)\r\npanic(PFX "Couldn't allocate struct pci_controller");\r\ncontroller->iommu = ioc;\r\nsac->sysdata = controller;\r\nsac->dma_mask = 0xFFFFFFFFUL;\r\n#ifdef CONFIG_PCI\r\nsac->dev.bus = &pci_bus_type;\r\n#endif\r\nioc->sac_only_dev = sac;\r\n}\r\nstatic void __init\r\nioc_zx1_init(struct ioc *ioc)\r\n{\r\nunsigned long rope_config;\r\nunsigned int i;\r\nif (ioc->rev < 0x20)\r\npanic(PFX "IOC 2.0 or later required for IOMMU support\n");\r\nioc->dma_mask = (0x1UL << 39) - 1;\r\nfor (i=0; i<(8*8); i+=8) {\r\nrope_config = READ_REG(ioc->ioc_hpa + IOC_ROPE0_CFG + i);\r\nrope_config &= ~IOC_ROPE_AO;\r\nWRITE_REG(rope_config, ioc->ioc_hpa + IOC_ROPE0_CFG + i);\r\n}\r\n}\r\nstatic struct ioc * __init\r\nioc_init(unsigned long hpa, void *handle)\r\n{\r\nstruct ioc *ioc;\r\nstruct ioc_iommu *info;\r\nioc = kzalloc(sizeof(*ioc), GFP_KERNEL);\r\nif (!ioc)\r\nreturn NULL;\r\nioc->next = ioc_list;\r\nioc_list = ioc;\r\nioc->handle = handle;\r\nioc->ioc_hpa = ioremap(hpa, 0x1000);\r\nioc->func_id = READ_REG(ioc->ioc_hpa + IOC_FUNC_ID);\r\nioc->rev = READ_REG(ioc->ioc_hpa + IOC_FCLASS) & 0xFFUL;\r\nioc->dma_mask = 0xFFFFFFFFFFFFFFFFUL;\r\nfor (info = ioc_iommu_info; info < ioc_iommu_info + ARRAY_SIZE(ioc_iommu_info); info++) {\r\nif (ioc->func_id == info->func_id) {\r\nioc->name = info->name;\r\nif (info->init)\r\n(info->init)(ioc);\r\n}\r\n}\r\niovp_size = (1 << iovp_shift);\r\niovp_mask = ~(iovp_size - 1);\r\nDBG_INIT("%s: PAGE_SIZE %ldK, iovp_size %ldK\n", __func__,\r\nPAGE_SIZE >> 10, iovp_size >> 10);\r\nif (!ioc->name) {\r\nioc->name = kmalloc(24, GFP_KERNEL);\r\nif (ioc->name)\r\nsprintf((char *) ioc->name, "Unknown (%04x:%04x)",\r\nioc->func_id & 0xFFFF, (ioc->func_id >> 16) & 0xFFFF);\r\nelse\r\nioc->name = "Unknown";\r\n}\r\nioc_iova_init(ioc);\r\nioc_resource_init(ioc);\r\nioc_sac_init(ioc);\r\nif ((long) ~iovp_mask > (long) ia64_max_iommu_merge_mask)\r\nia64_max_iommu_merge_mask = ~iovp_mask;\r\nprintk(KERN_INFO PFX\r\n"%s %d.%d HPA 0x%lx IOVA space %dMb at 0x%lx\n",\r\nioc->name, (ioc->rev >> 4) & 0xF, ioc->rev & 0xF,\r\nhpa, ioc->iov_size >> 20, ioc->ibase);\r\nreturn ioc;\r\n}\r\nstatic void *\r\nioc_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct ioc *ioc;\r\nloff_t n = *pos;\r\nfor (ioc = ioc_list; ioc; ioc = ioc->next)\r\nif (!n--)\r\nreturn ioc;\r\nreturn NULL;\r\n}\r\nstatic void *\r\nioc_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct ioc *ioc = v;\r\n++*pos;\r\nreturn ioc->next;\r\n}\r\nstatic void\r\nioc_stop(struct seq_file *s, void *v)\r\n{\r\n}\r\nstatic int\r\nioc_show(struct seq_file *s, void *v)\r\n{\r\nstruct ioc *ioc = v;\r\nunsigned long *res_ptr = (unsigned long *)ioc->res_map;\r\nint i, used = 0;\r\nseq_printf(s, "Hewlett Packard %s IOC rev %d.%d\n",\r\nioc->name, ((ioc->rev >> 4) & 0xF), (ioc->rev & 0xF));\r\n#ifdef CONFIG_NUMA\r\nif (ioc->node != MAX_NUMNODES)\r\nseq_printf(s, "NUMA node : %d\n", ioc->node);\r\n#endif\r\nseq_printf(s, "IOVA size : %ld MB\n", ((ioc->pdir_size >> 3) * iovp_size)/(1024*1024));\r\nseq_printf(s, "IOVA page size : %ld kb\n", iovp_size/1024);\r\nfor (i = 0; i < (ioc->res_size / sizeof(unsigned long)); ++i, ++res_ptr)\r\nused += hweight64(*res_ptr);\r\nseq_printf(s, "PDIR size : %d entries\n", ioc->pdir_size >> 3);\r\nseq_printf(s, "PDIR used : %d entries\n", used);\r\n#ifdef PDIR_SEARCH_TIMING\r\n{\r\nunsigned long i = 0, avg = 0, min, max;\r\nmin = max = ioc->avg_search[0];\r\nfor (i = 0; i < SBA_SEARCH_SAMPLE; i++) {\r\navg += ioc->avg_search[i];\r\nif (ioc->avg_search[i] > max) max = ioc->avg_search[i];\r\nif (ioc->avg_search[i] < min) min = ioc->avg_search[i];\r\n}\r\navg /= SBA_SEARCH_SAMPLE;\r\nseq_printf(s, "Bitmap search : %ld/%ld/%ld (min/avg/max CPU Cycles/IOVA page)\n",\r\nmin, avg, max);\r\n}\r\n#endif\r\n#ifndef ALLOW_IOV_BYPASS\r\nseq_printf(s, "IOVA bypass disabled\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int\r\nioc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ioc_seq_ops);\r\n}\r\nstatic void __init\r\nioc_proc_init(void)\r\n{\r\nstruct proc_dir_entry *dir;\r\ndir = proc_mkdir("bus/mckinley", NULL);\r\nif (!dir)\r\nreturn;\r\nproc_create(ioc_list->name, 0, dir, &ioc_fops);\r\n}\r\nstatic void\r\nsba_connect_bus(struct pci_bus *bus)\r\n{\r\nacpi_handle handle, parent;\r\nacpi_status status;\r\nstruct ioc *ioc;\r\nif (!PCI_CONTROLLER(bus))\r\npanic(PFX "no sysdata on bus %d!\n", bus->number);\r\nif (PCI_CONTROLLER(bus)->iommu)\r\nreturn;\r\nhandle = PCI_CONTROLLER(bus)->acpi_handle;\r\nif (!handle)\r\nreturn;\r\ndo {\r\nfor (ioc = ioc_list; ioc; ioc = ioc->next)\r\nif (ioc->handle == handle) {\r\nPCI_CONTROLLER(bus)->iommu = ioc;\r\nreturn;\r\n}\r\nstatus = acpi_get_parent(handle, &parent);\r\nhandle = parent;\r\n} while (ACPI_SUCCESS(status));\r\nprintk(KERN_WARNING "No IOC for PCI Bus %04x:%02x in ACPI\n", pci_domain_nr(bus), bus->number);\r\n}\r\nstatic void __init\r\nsba_map_ioc_to_node(struct ioc *ioc, acpi_handle handle)\r\n{\r\nunsigned int node;\r\nint pxm;\r\nioc->node = MAX_NUMNODES;\r\npxm = acpi_get_pxm(handle);\r\nif (pxm < 0)\r\nreturn;\r\nnode = pxm_to_node(pxm);\r\nif (node >= MAX_NUMNODES || !node_online(node))\r\nreturn;\r\nioc->node = node;\r\nreturn;\r\n}\r\nstatic int __init\r\nacpi_sba_ioc_add(struct acpi_device *device)\r\n{\r\nstruct ioc *ioc;\r\nacpi_status status;\r\nu64 hpa, length;\r\nstruct acpi_device_info *adi;\r\nstatus = hp_acpi_csr_space(device->handle, &hpa, &length);\r\nif (ACPI_FAILURE(status))\r\nreturn 1;\r\nstatus = acpi_get_object_info(device->handle, &adi);\r\nif (ACPI_FAILURE(status))\r\nreturn 1;\r\nif (strncmp("HWP0001", adi->hardware_id.string, 7) == 0) {\r\nhpa += ZX1_IOC_OFFSET;\r\nif (!iovp_shift)\r\niovp_shift = min(PAGE_SHIFT, 16);\r\n}\r\nkfree(adi);\r\nif (!iovp_shift)\r\niovp_shift = 12;\r\nioc = ioc_init(hpa, device->handle);\r\nif (!ioc)\r\nreturn 1;\r\nsba_map_ioc_to_node(ioc, device->handle);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nsba_init(void)\r\n{\r\nif (!ia64_platform_is("hpzx1") && !ia64_platform_is("hpzx1_swiotlb"))\r\nreturn 0;\r\n#if defined(CONFIG_IA64_GENERIC)\r\nif (is_kdump_kernel()) {\r\ndma_ops = &swiotlb_dma_ops;\r\nif (swiotlb_late_init_with_default_size(64 * (1<<20)) != 0)\r\npanic("Unable to initialize software I/O TLB:"\r\n" Try machvec=dig boot option");\r\nmachvec_init("dig");\r\nreturn 0;\r\n}\r\n#endif\r\nacpi_bus_register_driver(&acpi_sba_ioc_driver);\r\nif (!ioc_list) {\r\n#ifdef CONFIG_IA64_GENERIC\r\ndma_ops = &swiotlb_dma_ops;\r\nif (swiotlb_late_init_with_default_size(64 * (1<<20)) != 0)\r\npanic("Unable to find SBA IOMMU or initialize "\r\n"software I/O TLB: Try machvec=dig boot option");\r\nmachvec_init("dig");\r\n#else\r\npanic("Unable to find SBA IOMMU: Try a generic or DIG kernel");\r\n#endif\r\nreturn 0;\r\n}\r\n#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_HP_ZX1_SWIOTLB)\r\nif (ia64_platform_is("hpzx1_swiotlb")) {\r\nextern void hwsw_init(void);\r\nhwsw_init();\r\n}\r\n#endif\r\n#ifdef CONFIG_PCI\r\n{\r\nstruct pci_bus *b = NULL;\r\nwhile ((b = pci_find_next_bus(b)) != NULL)\r\nsba_connect_bus(b);\r\n}\r\n#endif\r\n#ifdef CONFIG_PROC_FS\r\nioc_proc_init();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int __init\r\nnosbagart(char *str)\r\n{\r\nreserve_sba_gart = 0;\r\nreturn 1;\r\n}\r\nstatic int sba_dma_supported (struct device *dev, u64 mask)\r\n{\r\nreturn ((mask & 0xFFFFFFFFUL) == 0xFFFFFFFFUL);\r\n}\r\nstatic int sba_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init\r\nsba_page_override(char *str)\r\n{\r\nunsigned long page_size;\r\npage_size = memparse(str, &str);\r\nswitch (page_size) {\r\ncase 4096:\r\ncase 8192:\r\ncase 16384:\r\ncase 65536:\r\niovp_shift = ffs(page_size) - 1;\r\nbreak;\r\ndefault:\r\nprintk("%s: unknown/unsupported iommu page size %ld\n",\r\n__func__, page_size);\r\n}\r\nreturn 1;\r\n}\r\nvoid sba_dma_init(void)\r\n{\r\ndma_ops = &sba_dma_ops;\r\n}
