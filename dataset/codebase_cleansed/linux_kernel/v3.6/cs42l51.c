static int cs42l51_fill_cache(struct snd_soc_codec *codec)\r\n{\r\nu8 *cache = codec->reg_cache + 1;\r\nstruct i2c_client *i2c_client = to_i2c_client(codec->dev);\r\ns32 length;\r\nlength = i2c_smbus_read_i2c_block_data(i2c_client,\r\nCS42L51_FIRSTREG | 0x80, CS42L51_NUMREGS, cache);\r\nif (length != CS42L51_NUMREGS) {\r\ndev_err(&i2c_client->dev,\r\n"I2C read failure, addr=0x%x (ret=%d vs %d)\n",\r\ni2c_client->addr, length, CS42L51_NUMREGS);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l51_get_chan_mix(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned long value = snd_soc_read(codec, CS42L51_PCM_MIXER)&3;\r\nswitch (value) {\r\ndefault:\r\ncase 0:\r\nucontrol->value.integer.value[0] = 0;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nucontrol->value.integer.value[0] = 1;\r\nbreak;\r\ncase 3:\r\nucontrol->value.integer.value[0] = 2;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l51_set_chan_mix(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned char val;\r\nswitch (ucontrol->value.integer.value[0]) {\r\ndefault:\r\ncase 0:\r\nval = CHAN_MIX_NORMAL;\r\nbreak;\r\ncase 1:\r\nval = CHAN_MIX_BOTH;\r\nbreak;\r\ncase 2:\r\nval = CHAN_MIX_SWAP;\r\nbreak;\r\n}\r\nsnd_soc_write(codec, CS42L51_PCM_MIXER, val);\r\nreturn 1;\r\n}\r\nstatic int cs42l51_pdn_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(w->codec, CS42L51_POWER_CTL1,\r\nCS42L51_POWER_CTL1_PDN,\r\nCS42L51_POWER_CTL1_PDN);\r\nbreak;\r\ndefault:\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(w->codec, CS42L51_POWER_CTL1,\r\nCS42L51_POWER_CTL1_PDN, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l51_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l51_private *cs42l51 = snd_soc_codec_get_drvdata(codec);\r\nswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncs42l51->audio_mode = format & SND_SOC_DAIFMT_FORMAT_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "invalid DAI format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncs42l51->func = MODE_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncs42l51->func = MODE_SLAVE_AUTO;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l51_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l51_private *cs42l51 = snd_soc_codec_get_drvdata(codec);\r\ncs42l51->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int cs42l51_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l51_private *cs42l51 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nunsigned int i;\r\nunsigned int rate;\r\nunsigned int ratio;\r\nstruct cs42l51_ratios *ratios = NULL;\r\nint nr_ratios = 0;\r\nint intf_ctl, power_ctl, fmt;\r\nswitch (cs42l51->func) {\r\ncase MODE_MASTER:\r\nreturn -EINVAL;\r\ncase MODE_SLAVE:\r\nratios = slave_ratios;\r\nnr_ratios = ARRAY_SIZE(slave_ratios);\r\nbreak;\r\ncase MODE_SLAVE_AUTO:\r\nratios = slave_auto_ratios;\r\nnr_ratios = ARRAY_SIZE(slave_auto_ratios);\r\nbreak;\r\n}\r\nrate = params_rate(params);\r\nratio = cs42l51->mclk / rate;\r\nfor (i = 0; i < nr_ratios; i++) {\r\nif (ratios[i].ratio == ratio)\r\nbreak;\r\n}\r\nif (i == nr_ratios) {\r\ndev_err(codec->dev, "could not find matching ratio\n");\r\nreturn -EINVAL;\r\n}\r\nintf_ctl = snd_soc_read(codec, CS42L51_INTF_CTL);\r\npower_ctl = snd_soc_read(codec, CS42L51_MIC_POWER_CTL);\r\nintf_ctl &= ~(CS42L51_INTF_CTL_MASTER | CS42L51_INTF_CTL_ADC_I2S\r\n| CS42L51_INTF_CTL_DAC_FORMAT(7));\r\npower_ctl &= ~(CS42L51_MIC_POWER_CTL_SPEED(3)\r\n| CS42L51_MIC_POWER_CTL_MCLK_DIV2);\r\nswitch (cs42l51->func) {\r\ncase MODE_MASTER:\r\nintf_ctl |= CS42L51_INTF_CTL_MASTER;\r\npower_ctl |= CS42L51_MIC_POWER_CTL_SPEED(ratios[i].speed_mode);\r\nbreak;\r\ncase MODE_SLAVE:\r\npower_ctl |= CS42L51_MIC_POWER_CTL_SPEED(ratios[i].speed_mode);\r\nbreak;\r\ncase MODE_SLAVE_AUTO:\r\npower_ctl |= CS42L51_MIC_POWER_CTL_AUTO;\r\nbreak;\r\n}\r\nswitch (cs42l51->audio_mode) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nintf_ctl |= CS42L51_INTF_CTL_ADC_I2S;\r\nintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(CS42L51_DAC_DIF_I2S);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(CS42L51_DAC_DIF_LJ24);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nfmt = CS42L51_DAC_DIF_RJ16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S18_3LE:\r\ncase SNDRV_PCM_FORMAT_S18_3BE:\r\nfmt = CS42L51_DAC_DIF_RJ18;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ncase SNDRV_PCM_FORMAT_S20_3BE:\r\nfmt = CS42L51_DAC_DIF_RJ20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ncase SNDRV_PCM_FORMAT_S24_BE:\r\nfmt = CS42L51_DAC_DIF_RJ24;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unknown format\n");\r\nreturn -EINVAL;\r\n}\r\nintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(fmt);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unknown format\n");\r\nreturn -EINVAL;\r\n}\r\nif (ratios[i].mclk)\r\npower_ctl |= CS42L51_MIC_POWER_CTL_MCLK_DIV2;\r\nret = snd_soc_write(codec, CS42L51_INTF_CTL, intf_ctl);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_write(codec, CS42L51_MIC_POWER_CTL, power_ctl);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cs42l51_dai_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint reg;\r\nint mask = CS42L51_DAC_OUT_CTL_DACA_MUTE|CS42L51_DAC_OUT_CTL_DACB_MUTE;\r\nreg = snd_soc_read(codec, CS42L51_DAC_OUT_CTL);\r\nif (mute)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\nreturn snd_soc_write(codec, CS42L51_DAC_OUT_CTL, reg);\r\n}\r\nstatic int cs42l51_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l51_private *cs42l51 = snd_soc_codec_get_drvdata(codec);\r\nint ret, reg;\r\nret = cs42l51_fill_cache(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "failed to fill register cache\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, cs42l51->control_type);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nreg = CS42L51_DAC_CTL_DATA_SEL(1)\r\n| CS42L51_DAC_CTL_AMUTE | CS42L51_DAC_CTL_DACSZ(0);\r\nret = snd_soc_write(codec, CS42L51_DAC_CTL, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cs42l51_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs42l51_private *cs42l51;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(i2c_client, CS42L51_CHIP_REV_ID);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "failed to read I2C\n");\r\ngoto error;\r\n}\r\nif ((ret != CS42L51_MK_CHIP_REV(CS42L51_CHIP_ID, CS42L51_CHIP_REV_A)) &&\r\n(ret != CS42L51_MK_CHIP_REV(CS42L51_CHIP_ID, CS42L51_CHIP_REV_B))) {\r\ndev_err(&i2c_client->dev, "Invalid chip id\n");\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\ndev_info(&i2c_client->dev, "found device cs42l51 rev %d\n",\r\nret & 7);\r\ncs42l51 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs42l51_private),\r\nGFP_KERNEL);\r\nif (!cs42l51) {\r\ndev_err(&i2c_client->dev, "could not allocate codec\n");\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(i2c_client, cs42l51);\r\ncs42l51->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_device_cs42l51, &cs42l51_dai, 1);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int cs42l51_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init cs42l51_init(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&cs42l51_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "%s: can't add i2c driver\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cs42l51_exit(void)\r\n{\r\ni2c_del_driver(&cs42l51_i2c_driver);\r\n}
