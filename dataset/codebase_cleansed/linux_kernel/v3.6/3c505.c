static unsigned long dma_mem_alloc(int size)\r\n{\r\nint order = get_order(size);\r\nreturn __get_dma_pages(GFP_KERNEL, order);\r\n}\r\nstatic inline unsigned char inb_status(unsigned int base_addr)\r\n{\r\nreturn inb(base_addr + PORT_STATUS);\r\n}\r\nstatic inline int inb_command(unsigned int base_addr)\r\n{\r\nreturn inb(base_addr + PORT_COMMAND);\r\n}\r\nstatic inline void outb_control(unsigned char val, struct net_device *dev)\r\n{\r\noutb(val, dev->base_addr + PORT_CONTROL);\r\n((elp_device *)(netdev_priv(dev)))->hcr_val = val;\r\n}\r\nstatic inline void outb_command(unsigned char val, unsigned int base_addr)\r\n{\r\noutb(val, base_addr + PORT_COMMAND);\r\n}\r\nstatic inline unsigned int backlog_next(unsigned int n)\r\n{\r\nreturn (n + 1) % BACKLOG_SIZE;\r\n}\r\nstatic inline int get_status(unsigned int base_addr)\r\n{\r\nunsigned long timeout = jiffies + 10*HZ/100;\r\nregister int stat1;\r\ndo {\r\nstat1 = inb_status(base_addr);\r\n} while (stat1 != inb_status(base_addr) && time_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout))\r\nTIMEOUT_MSG(__LINE__);\r\nreturn stat1;\r\n}\r\nstatic inline void set_hsf(struct net_device *dev, int hsf)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\noutb_control((HCR_VAL(dev) & ~HSF_PCB_MASK) | hsf, dev);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\n}\r\nstatic inline void adapter_reset(struct net_device *dev)\r\n{\r\nunsigned long timeout;\r\nelp_device *adapter = netdev_priv(dev);\r\nunsigned char orig_hcr = adapter->hcr_val;\r\noutb_control(0, dev);\r\nif (inb_status(dev->base_addr) & ACRF) {\r\ndo {\r\ninb_command(dev->base_addr);\r\ntimeout = jiffies + 2*HZ/100;\r\nwhile (time_before_eq(jiffies, timeout) && !(inb_status(dev->base_addr) & ACRF));\r\n} while (inb_status(dev->base_addr) & ACRF);\r\nset_hsf(dev, HSF_PCB_NAK);\r\n}\r\noutb_control(adapter->hcr_val | ATTN | DIR, dev);\r\nmdelay(10);\r\noutb_control(adapter->hcr_val & ~ATTN, dev);\r\nmdelay(10);\r\noutb_control(adapter->hcr_val | FLSH, dev);\r\nmdelay(10);\r\noutb_control(adapter->hcr_val & ~FLSH, dev);\r\nmdelay(10);\r\noutb_control(orig_hcr, dev);\r\nif (!start_receive(dev, &adapter->tx_pcb))\r\npr_err("%s: start receive command failed\n", dev->name);\r\n}\r\nstatic inline void check_3c505_dma(struct net_device *dev)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nif (adapter->dmaing && time_after(jiffies, adapter->current_dma.start_time + 10)) {\r\nunsigned long flags, f;\r\npr_err("%s: DMA %s timed out, %d bytes left\n", dev->name,\r\nadapter->current_dma.direction ? "download" : "upload",\r\nget_dma_residue(dev->dma));\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nadapter->dmaing = 0;\r\nadapter->busy = 0;\r\nf=claim_dma_lock();\r\ndisable_dma(dev->dma);\r\nrelease_dma_lock(f);\r\nif (adapter->rx_active)\r\nadapter->rx_active--;\r\noutb_control(adapter->hcr_val & ~(DMAE | TCEN | DIR), dev);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\n}\r\n}\r\nstatic inline bool send_pcb_slow(unsigned int base_addr, unsigned char byte)\r\n{\r\nunsigned long timeout;\r\noutb_command(byte, base_addr);\r\nfor (timeout = jiffies + 5*HZ/100; time_before(jiffies, timeout);) {\r\nif (inb_status(base_addr) & HCRE)\r\nreturn false;\r\n}\r\npr_warning("3c505: send_pcb_slow timed out\n");\r\nreturn true;\r\n}\r\nstatic inline bool send_pcb_fast(unsigned int base_addr, unsigned char byte)\r\n{\r\nunsigned int timeout;\r\noutb_command(byte, base_addr);\r\nfor (timeout = 0; timeout < 40000; timeout++) {\r\nif (inb_status(base_addr) & HCRE)\r\nreturn false;\r\n}\r\npr_warning("3c505: send_pcb_fast timed out\n");\r\nreturn true;\r\n}\r\nstatic inline void prime_rx(struct net_device *dev)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nwhile (adapter->rx_active < ELP_RX_PCBS && netif_running(dev)) {\r\nif (!start_receive(dev, &adapter->itx_pcb))\r\nbreak;\r\n}\r\n}\r\nstatic bool send_pcb(struct net_device *dev, pcb_struct * pcb)\r\n{\r\nint i;\r\nunsigned long timeout;\r\nelp_device *adapter = netdev_priv(dev);\r\nunsigned long flags;\r\ncheck_3c505_dma(dev);\r\nif (adapter->dmaing && adapter->current_dma.direction == 0)\r\nreturn false;\r\nif (test_and_set_bit(1, &adapter->send_pcb_semaphore)) {\r\nif (elp_debug >= 3) {\r\npr_debug("%s: send_pcb entered while threaded\n", dev->name);\r\n}\r\nreturn false;\r\n}\r\nset_hsf(dev, 0);\r\nif (send_pcb_slow(dev->base_addr, pcb->command))\r\ngoto abort;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nif (send_pcb_fast(dev->base_addr, pcb->length))\r\ngoto sti_abort;\r\nfor (i = 0; i < pcb->length; i++) {\r\nif (send_pcb_fast(dev->base_addr, pcb->data.raw[i]))\r\ngoto sti_abort;\r\n}\r\noutb_control(adapter->hcr_val | 3, dev);\r\noutb_command(2 + pcb->length, dev->base_addr);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nfor (timeout = jiffies + 5*HZ/100; time_before(jiffies, timeout);) {\r\nswitch (GET_ASF(dev->base_addr)) {\r\ncase ASF_PCB_ACK:\r\nadapter->send_pcb_semaphore = 0;\r\nreturn true;\r\ncase ASF_PCB_NAK:\r\n#ifdef ELP_DEBUG\r\npr_debug("%s: send_pcb got NAK\n", dev->name);\r\n#endif\r\ngoto abort;\r\n}\r\n}\r\nif (elp_debug >= 1)\r\npr_debug("%s: timeout waiting for PCB acknowledge (status %02x)\n",\r\ndev->name, inb_status(dev->base_addr));\r\ngoto abort;\r\nsti_abort:\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nabort:\r\nadapter->send_pcb_semaphore = 0;\r\nreturn false;\r\n}\r\nstatic bool receive_pcb(struct net_device *dev, pcb_struct * pcb)\r\n{\r\nint i, j;\r\nint total_length;\r\nint stat;\r\nunsigned long timeout;\r\nunsigned long flags;\r\nelp_device *adapter = netdev_priv(dev);\r\nset_hsf(dev, 0);\r\ntimeout = jiffies + 2*HZ/100;\r\nwhile (((stat = get_status(dev->base_addr)) & ACRF) == 0 && time_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout)) {\r\nTIMEOUT_MSG(__LINE__);\r\nreturn false;\r\n}\r\npcb->command = inb_command(dev->base_addr);\r\ntimeout = jiffies + 3*HZ/100;\r\nwhile (((stat = get_status(dev->base_addr)) & ACRF) == 0 && time_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout)) {\r\nTIMEOUT_MSG(__LINE__);\r\npr_info("%s: status %02x\n", dev->name, stat);\r\nreturn false;\r\n}\r\npcb->length = inb_command(dev->base_addr);\r\nif (pcb->length > MAX_PCB_DATA) {\r\nINVALID_PCB_MSG(pcb->length);\r\nadapter_reset(dev);\r\nreturn false;\r\n}\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nfor (i = 0; i < MAX_PCB_DATA; i++) {\r\nfor (j = 0; j < 20000; j++) {\r\nstat = get_status(dev->base_addr);\r\nif (stat & ACRF)\r\nbreak;\r\n}\r\npcb->data.raw[i] = inb_command(dev->base_addr);\r\nif ((stat & ASF_PCB_MASK) == ASF_PCB_END || j >= 20000)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nif (i >= MAX_PCB_DATA) {\r\nINVALID_PCB_MSG(i);\r\nreturn false;\r\n}\r\nif (j >= 20000) {\r\nTIMEOUT_MSG(__LINE__);\r\nreturn false;\r\n}\r\ntotal_length = pcb->data.raw[i];\r\nif (total_length != (pcb->length + 2)) {\r\nif (elp_debug >= 2)\r\npr_warning("%s: mangled PCB received\n", dev->name);\r\nset_hsf(dev, HSF_PCB_NAK);\r\nreturn false;\r\n}\r\nif (pcb->command == CMD_RECEIVE_PACKET_COMPLETE) {\r\nif (test_and_set_bit(0, (void *) &adapter->busy)) {\r\nif (backlog_next(adapter->rx_backlog.in) == adapter->rx_backlog.out) {\r\nset_hsf(dev, HSF_PCB_NAK);\r\npr_warning("%s: PCB rejected, transfer in progress and backlog full\n", dev->name);\r\npcb->command = 0;\r\nreturn true;\r\n} else {\r\npcb->command = 0xff;\r\n}\r\n}\r\n}\r\nset_hsf(dev, HSF_PCB_ACK);\r\nreturn true;\r\n}\r\nstatic bool start_receive(struct net_device *dev, pcb_struct * tx_pcb)\r\n{\r\nbool status;\r\nelp_device *adapter = netdev_priv(dev);\r\nif (elp_debug >= 3)\r\npr_debug("%s: restarting receiver\n", dev->name);\r\ntx_pcb->command = CMD_RECEIVE_PACKET;\r\ntx_pcb->length = sizeof(struct Rcv_pkt);\r\ntx_pcb->data.rcv_pkt.buf_seg\r\n= tx_pcb->data.rcv_pkt.buf_ofs = 0;\r\ntx_pcb->data.rcv_pkt.buf_len = 1600;\r\ntx_pcb->data.rcv_pkt.timeout = 0;\r\nstatus = send_pcb(dev, tx_pcb);\r\nif (status)\r\nadapter->rx_active++;\r\nreturn status;\r\n}\r\nstatic void receive_packet(struct net_device *dev, int len)\r\n{\r\nint rlen;\r\nelp_device *adapter = netdev_priv(dev);\r\nvoid *target;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nrlen = (len + 1) & ~1;\r\nskb = netdev_alloc_skb(dev, rlen + 2);\r\nif (!skb) {\r\npr_warning("%s: memory squeeze, dropping packet\n", dev->name);\r\ntarget = adapter->dma_buffer;\r\nadapter->current_dma.target = NULL;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\ntarget = skb_put(skb, rlen);\r\nif ((unsigned long)(target + rlen) >= MAX_DMA_ADDRESS) {\r\nadapter->current_dma.target = target;\r\ntarget = adapter->dma_buffer;\r\n} else {\r\nadapter->current_dma.target = NULL;\r\n}\r\nif (test_and_set_bit(0, (void *) &adapter->dmaing))\r\npr_err("%s: rx blocked, DMA in progress, dir %d\n",\r\ndev->name, adapter->current_dma.direction);\r\nadapter->current_dma.direction = 0;\r\nadapter->current_dma.length = rlen;\r\nadapter->current_dma.skb = skb;\r\nadapter->current_dma.start_time = jiffies;\r\noutb_control(adapter->hcr_val | DIR | TCEN | DMAE, dev);\r\nflags=claim_dma_lock();\r\ndisable_dma(dev->dma);\r\nclear_dma_ff(dev->dma);\r\nset_dma_mode(dev->dma, 0x04);\r\nset_dma_addr(dev->dma, isa_virt_to_bus(target));\r\nset_dma_count(dev->dma, rlen);\r\nenable_dma(dev->dma);\r\nrelease_dma_lock(flags);\r\nif (elp_debug >= 3) {\r\npr_debug("%s: rx DMA transfer started\n", dev->name);\r\n}\r\nif (adapter->rx_active)\r\nadapter->rx_active--;\r\nif (!adapter->busy)\r\npr_warning("%s: receive_packet called, busy not set.\n", dev->name);\r\n}\r\nstatic irqreturn_t elp_interrupt(int irq, void *dev_id)\r\n{\r\nint len;\r\nint dlen;\r\nint icount = 0;\r\nstruct net_device *dev = dev_id;\r\nelp_device *adapter = netdev_priv(dev);\r\nunsigned long timeout;\r\nspin_lock(&adapter->lock);\r\ndo {\r\nif (inb_status(dev->base_addr) & DONE) {\r\nif (!adapter->dmaing)\r\npr_warning("%s: phantom DMA completed\n", dev->name);\r\nif (elp_debug >= 3)\r\npr_debug("%s: %s DMA complete, status %02x\n", dev->name,\r\nadapter->current_dma.direction ? "tx" : "rx",\r\ninb_status(dev->base_addr));\r\noutb_control(adapter->hcr_val & ~(DMAE | TCEN | DIR), dev);\r\nif (adapter->current_dma.direction) {\r\ndev_kfree_skb_irq(adapter->current_dma.skb);\r\n} else {\r\nstruct sk_buff *skb = adapter->current_dma.skb;\r\nif (skb) {\r\nif (adapter->current_dma.target) {\r\nmemcpy(adapter->current_dma.target, adapter->dma_buffer, adapter->current_dma.length);\r\n}\r\nskb->protocol = eth_type_trans(skb,dev);\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\n}\r\n}\r\nadapter->dmaing = 0;\r\nif (adapter->rx_backlog.in != adapter->rx_backlog.out) {\r\nint t = adapter->rx_backlog.length[adapter->rx_backlog.out];\r\nadapter->rx_backlog.out = backlog_next(adapter->rx_backlog.out);\r\nif (elp_debug >= 2)\r\npr_debug("%s: receiving backlogged packet (%d)\n", dev->name, t);\r\nreceive_packet(dev, t);\r\n} else {\r\nadapter->busy = 0;\r\n}\r\n} else {\r\ncheck_3c505_dma(dev);\r\n}\r\ntimeout = jiffies + 3*HZ/100;\r\nwhile ((inb_status(dev->base_addr) & ACRF) != 0 && time_before(jiffies, timeout)) {\r\nif (receive_pcb(dev, &adapter->irx_pcb)) {\r\nswitch (adapter->irx_pcb.command)\r\n{\r\ncase 0:\r\nbreak;\r\ncase 0xff:\r\ncase CMD_RECEIVE_PACKET_COMPLETE:\r\nif (!netif_running(dev))\r\nbreak;\r\nlen = adapter->irx_pcb.data.rcv_resp.pkt_len;\r\ndlen = adapter->irx_pcb.data.rcv_resp.buf_len;\r\nif (adapter->irx_pcb.data.rcv_resp.timeout != 0) {\r\npr_err("%s: interrupt - packet not received correctly\n", dev->name);\r\n} else {\r\nif (elp_debug >= 3) {\r\npr_debug("%s: interrupt - packet received of length %i (%i)\n",\r\ndev->name, len, dlen);\r\n}\r\nif (adapter->irx_pcb.command == 0xff) {\r\nif (elp_debug >= 2)\r\npr_debug("%s: adding packet to backlog (len = %d)\n",\r\ndev->name, dlen);\r\nadapter->rx_backlog.length[adapter->rx_backlog.in] = dlen;\r\nadapter->rx_backlog.in = backlog_next(adapter->rx_backlog.in);\r\n} else {\r\nreceive_packet(dev, dlen);\r\n}\r\nif (elp_debug >= 3)\r\npr_debug("%s: packet received\n", dev->name);\r\n}\r\nbreak;\r\ncase CMD_CONFIGURE_82586_RESPONSE:\r\nadapter->got[CMD_CONFIGURE_82586] = 1;\r\nif (elp_debug >= 3)\r\npr_debug("%s: interrupt - configure response received\n", dev->name);\r\nbreak;\r\ncase CMD_CONFIGURE_ADAPTER_RESPONSE:\r\nadapter->got[CMD_CONFIGURE_ADAPTER_MEMORY] = 1;\r\nif (elp_debug >= 3)\r\npr_debug("%s: Adapter memory configuration %s.\n", dev->name,\r\nadapter->irx_pcb.data.failed ? "failed" : "succeeded");\r\nbreak;\r\ncase CMD_LOAD_MULTICAST_RESPONSE:\r\nadapter->got[CMD_LOAD_MULTICAST_LIST] = 1;\r\nif (elp_debug >= 3)\r\npr_debug("%s: Multicast address list loading %s.\n", dev->name,\r\nadapter->irx_pcb.data.failed ? "failed" : "succeeded");\r\nbreak;\r\ncase CMD_SET_ADDRESS_RESPONSE:\r\nadapter->got[CMD_SET_STATION_ADDRESS] = 1;\r\nif (elp_debug >= 3)\r\npr_debug("%s: Ethernet address setting %s.\n", dev->name,\r\nadapter->irx_pcb.data.failed ? "failed" : "succeeded");\r\nbreak;\r\ncase CMD_NETWORK_STATISTICS_RESPONSE:\r\ndev->stats.rx_packets += adapter->irx_pcb.data.netstat.tot_recv;\r\ndev->stats.tx_packets += adapter->irx_pcb.data.netstat.tot_xmit;\r\ndev->stats.rx_crc_errors += adapter->irx_pcb.data.netstat.err_CRC;\r\ndev->stats.rx_frame_errors += adapter->irx_pcb.data.netstat.err_align;\r\ndev->stats.rx_fifo_errors += adapter->irx_pcb.data.netstat.err_ovrrun;\r\ndev->stats.rx_over_errors += adapter->irx_pcb.data.netstat.err_res;\r\nadapter->got[CMD_NETWORK_STATISTICS] = 1;\r\nif (elp_debug >= 3)\r\npr_debug("%s: interrupt - statistics response received\n", dev->name);\r\nbreak;\r\ncase CMD_TRANSMIT_PACKET_COMPLETE:\r\nif (elp_debug >= 3)\r\npr_debug("%s: interrupt - packet sent\n", dev->name);\r\nif (!netif_running(dev))\r\nbreak;\r\nswitch (adapter->irx_pcb.data.xmit_resp.c_stat) {\r\ncase 0xffff:\r\ndev->stats.tx_aborted_errors++;\r\npr_info("%s: transmit timed out, network cable problem?\n", dev->name);\r\nbreak;\r\ncase 0xfffe:\r\ndev->stats.tx_fifo_errors++;\r\npr_info("%s: transmit timed out, FIFO underrun\n", dev->name);\r\nbreak;\r\n}\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\npr_debug("%s: unknown PCB received - %2.2x\n",\r\ndev->name, adapter->irx_pcb.command);\r\nbreak;\r\n}\r\n} else {\r\npr_warning("%s: failed to read PCB on interrupt\n", dev->name);\r\nadapter_reset(dev);\r\n}\r\n}\r\n} while (icount++ < 5 && (inb_status(dev->base_addr) & (ACRF | DONE)));\r\nprime_rx(dev);\r\nspin_unlock(&adapter->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int elp_open(struct net_device *dev)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nint retval;\r\nif (elp_debug >= 3)\r\npr_debug("%s: request to open device\n", dev->name);\r\nif (adapter == NULL) {\r\npr_err("%s: Opening a non-existent physical device\n", dev->name);\r\nreturn -EAGAIN;\r\n}\r\noutb_control(0, dev);\r\ninb_command(dev->base_addr);\r\nadapter_reset(dev);\r\nadapter->rx_active = 0;\r\nadapter->busy = 0;\r\nadapter->send_pcb_semaphore = 0;\r\nadapter->rx_backlog.in = 0;\r\nadapter->rx_backlog.out = 0;\r\nspin_lock_init(&adapter->lock);\r\nif ((retval = request_irq(dev->irq, elp_interrupt, 0, dev->name, dev))) {\r\npr_err("%s: could not allocate IRQ%d\n", dev->name, dev->irq);\r\nreturn retval;\r\n}\r\nif ((retval = request_dma(dev->dma, dev->name))) {\r\nfree_irq(dev->irq, dev);\r\npr_err("%s: could not allocate DMA%d channel\n", dev->name, dev->dma);\r\nreturn retval;\r\n}\r\nadapter->dma_buffer = (void *) dma_mem_alloc(DMA_BUFFER_SIZE);\r\nif (!adapter->dma_buffer) {\r\npr_err("%s: could not allocate DMA buffer\n", dev->name);\r\nfree_dma(dev->dma);\r\nfree_irq(dev->irq, dev);\r\nreturn -ENOMEM;\r\n}\r\nadapter->dmaing = 0;\r\noutb_control(CMDE, dev);\r\nif (elp_debug >= 3)\r\npr_debug("%s: sending 3c505 memory configuration command\n", dev->name);\r\nadapter->tx_pcb.command = CMD_CONFIGURE_ADAPTER_MEMORY;\r\nadapter->tx_pcb.data.memconf.cmd_q = 10;\r\nadapter->tx_pcb.data.memconf.rcv_q = 20;\r\nadapter->tx_pcb.data.memconf.mcast = 10;\r\nadapter->tx_pcb.data.memconf.frame = 20;\r\nadapter->tx_pcb.data.memconf.rcv_b = 20;\r\nadapter->tx_pcb.data.memconf.progs = 0;\r\nadapter->tx_pcb.length = sizeof(struct Memconf);\r\nadapter->got[CMD_CONFIGURE_ADAPTER_MEMORY] = 0;\r\nif (!send_pcb(dev, &adapter->tx_pcb))\r\npr_err("%s: couldn't send memory configuration command\n", dev->name);\r\nelse {\r\nunsigned long timeout = jiffies + TIMEOUT;\r\nwhile (adapter->got[CMD_CONFIGURE_ADAPTER_MEMORY] == 0 && time_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout))\r\nTIMEOUT_MSG(__LINE__);\r\n}\r\nif (elp_debug >= 3)\r\npr_debug("%s: sending 82586 configure command\n", dev->name);\r\nadapter->tx_pcb.command = CMD_CONFIGURE_82586;\r\nadapter->tx_pcb.data.configure = NO_LOOPBACK | RECV_BROAD;\r\nadapter->tx_pcb.length = 2;\r\nadapter->got[CMD_CONFIGURE_82586] = 0;\r\nif (!send_pcb(dev, &adapter->tx_pcb))\r\npr_err("%s: couldn't send 82586 configure command\n", dev->name);\r\nelse {\r\nunsigned long timeout = jiffies + TIMEOUT;\r\nwhile (adapter->got[CMD_CONFIGURE_82586] == 0 && time_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout))\r\nTIMEOUT_MSG(__LINE__);\r\n}\r\nprime_rx(dev);\r\nif (elp_debug >= 3)\r\npr_debug("%s: %d receive PCBs active\n", dev->name, adapter->rx_active);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t send_packet(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nunsigned long target;\r\nunsigned long flags;\r\nunsigned int nlen = (((skb->len < 60) ? 60 : skb->len) + 1) & (~1);\r\nif (test_and_set_bit(0, (void *) &adapter->busy)) {\r\nif (elp_debug >= 2)\r\npr_debug("%s: transmit blocked\n", dev->name);\r\nreturn false;\r\n}\r\ndev->stats.tx_bytes += nlen;\r\nadapter->tx_pcb.command = CMD_TRANSMIT_PACKET;\r\nadapter->tx_pcb.length = sizeof(struct Xmit_pkt);\r\nadapter->tx_pcb.data.xmit_pkt.buf_ofs\r\n= adapter->tx_pcb.data.xmit_pkt.buf_seg = 0;\r\nadapter->tx_pcb.data.xmit_pkt.pkt_len = nlen;\r\nif (!send_pcb(dev, &adapter->tx_pcb)) {\r\nadapter->busy = 0;\r\nreturn false;\r\n}\r\nif (test_and_set_bit(0, (void *) &adapter->dmaing))\r\npr_debug("%s: tx: DMA %d in progress\n", dev->name, adapter->current_dma.direction);\r\nadapter->current_dma.direction = 1;\r\nadapter->current_dma.start_time = jiffies;\r\nif ((unsigned long)(skb->data + nlen) >= MAX_DMA_ADDRESS || nlen != skb->len) {\r\nskb_copy_from_linear_data(skb, adapter->dma_buffer, nlen);\r\nmemset(adapter->dma_buffer+skb->len, 0, nlen-skb->len);\r\ntarget = isa_virt_to_bus(adapter->dma_buffer);\r\n}\r\nelse {\r\ntarget = isa_virt_to_bus(skb->data);\r\n}\r\nadapter->current_dma.skb = skb;\r\nflags=claim_dma_lock();\r\ndisable_dma(dev->dma);\r\nclear_dma_ff(dev->dma);\r\nset_dma_mode(dev->dma, 0x48);\r\nset_dma_addr(dev->dma, target);\r\nset_dma_count(dev->dma, nlen);\r\noutb_control(adapter->hcr_val | DMAE | TCEN, dev);\r\nenable_dma(dev->dma);\r\nrelease_dma_lock(flags);\r\nif (elp_debug >= 3)\r\npr_debug("%s: DMA transfer started\n", dev->name);\r\nreturn true;\r\n}\r\nstatic void elp_timeout(struct net_device *dev)\r\n{\r\nint stat;\r\nstat = inb_status(dev->base_addr);\r\npr_warning("%s: transmit timed out, lost %s?\n", dev->name,\r\n(stat & ACRF) ? "interrupt" : "command");\r\nif (elp_debug >= 1)\r\npr_debug("%s: status %#02x\n", dev->name, stat);\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_dropped++;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t elp_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nelp_device *adapter = netdev_priv(dev);\r\nspin_lock_irqsave(&adapter->lock, flags);\r\ncheck_3c505_dma(dev);\r\nif (elp_debug >= 3)\r\npr_debug("%s: request to send packet of length %d\n", dev->name, (int) skb->len);\r\nnetif_stop_queue(dev);\r\nif (!send_packet(dev, skb)) {\r\nif (elp_debug >= 2) {\r\npr_debug("%s: failed to transmit packet\n", dev->name);\r\n}\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (elp_debug >= 3)\r\npr_debug("%s: packet of length %d sent\n", dev->name, (int) skb->len);\r\nprime_rx(dev);\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nnetif_start_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *elp_get_stats(struct net_device *dev)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nif (elp_debug >= 3)\r\npr_debug("%s: request for stats\n", dev->name);\r\nif (!netif_running(dev))\r\nreturn &dev->stats;\r\nadapter->tx_pcb.command = CMD_NETWORK_STATISTICS;\r\nadapter->tx_pcb.length = 0;\r\nadapter->got[CMD_NETWORK_STATISTICS] = 0;\r\nif (!send_pcb(dev, &adapter->tx_pcb))\r\npr_err("%s: couldn't send get statistics command\n", dev->name);\r\nelse {\r\nunsigned long timeout = jiffies + TIMEOUT;\r\nwhile (adapter->got[CMD_NETWORK_STATISTICS] == 0 && time_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout)) {\r\nTIMEOUT_MSG(__LINE__);\r\nreturn &dev->stats;\r\n}\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->bus_info, "ISA 0x%lx", dev->base_addr);\r\n}\r\nstatic u32 netdev_get_msglevel(struct net_device *dev)\r\n{\r\nreturn debug;\r\n}\r\nstatic void netdev_set_msglevel(struct net_device *dev, u32 level)\r\n{\r\ndebug = level;\r\n}\r\nstatic int elp_close(struct net_device *dev)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nif (elp_debug >= 3)\r\npr_debug("%s: request to close device\n", dev->name);\r\nnetif_stop_queue(dev);\r\n(void) elp_get_stats(dev);\r\noutb_control(0, dev);\r\nfree_irq(dev->irq, dev);\r\nfree_dma(dev->dma);\r\nfree_pages((unsigned long) adapter->dma_buffer, get_order(DMA_BUFFER_SIZE));\r\nreturn 0;\r\n}\r\nstatic void elp_set_mc_list(struct net_device *dev)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nunsigned long flags;\r\nif (elp_debug >= 3)\r\npr_debug("%s: request to set multicast list\n", dev->name);\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nif (!(dev->flags & (IFF_PROMISC | IFF_ALLMULTI))) {\r\nadapter->tx_pcb.command = CMD_LOAD_MULTICAST_LIST;\r\nadapter->tx_pcb.length = 6 * netdev_mc_count(dev);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nmemcpy(adapter->tx_pcb.data.multicast[i++],\r\nha->addr, 6);\r\nadapter->got[CMD_LOAD_MULTICAST_LIST] = 0;\r\nif (!send_pcb(dev, &adapter->tx_pcb))\r\npr_err("%s: couldn't send set_multicast command\n", dev->name);\r\nelse {\r\nunsigned long timeout = jiffies + TIMEOUT;\r\nwhile (adapter->got[CMD_LOAD_MULTICAST_LIST] == 0 && time_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout)) {\r\nTIMEOUT_MSG(__LINE__);\r\n}\r\n}\r\nif (!netdev_mc_empty(dev))\r\nadapter->tx_pcb.data.configure = NO_LOOPBACK | RECV_BROAD | RECV_MULTI;\r\nelse\r\nadapter->tx_pcb.data.configure = NO_LOOPBACK | RECV_BROAD;\r\n} else\r\nadapter->tx_pcb.data.configure = NO_LOOPBACK | RECV_PROMISC;\r\nif (elp_debug >= 3)\r\npr_debug("%s: sending 82586 configure command\n", dev->name);\r\nadapter->tx_pcb.command = CMD_CONFIGURE_82586;\r\nadapter->tx_pcb.length = 2;\r\nadapter->got[CMD_CONFIGURE_82586] = 0;\r\nif (!send_pcb(dev, &adapter->tx_pcb))\r\n{\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\npr_err("%s: couldn't send 82586 configure command\n", dev->name);\r\n}\r\nelse {\r\nunsigned long timeout = jiffies + TIMEOUT;\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nwhile (adapter->got[CMD_CONFIGURE_82586] == 0 && time_before(jiffies, timeout));\r\nif (time_after_eq(jiffies, timeout))\r\nTIMEOUT_MSG(__LINE__);\r\n}\r\n}\r\nstatic int __init elp_sense(struct net_device *dev)\r\n{\r\nint addr = dev->base_addr;\r\nconst char *name = dev->name;\r\nbyte orig_HSR;\r\nif (!request_region(addr, ELP_IO_EXTENT, "3c505"))\r\nreturn -ENODEV;\r\norig_HSR = inb_status(addr);\r\nif (elp_debug > 0)\r\npr_debug(search_msg, name, addr);\r\nif (orig_HSR == 0xff) {\r\nif (elp_debug > 0)\r\npr_cont(notfound_msg, 1);\r\ngoto out;\r\n}\r\nif (elp_debug > 0)\r\npr_cont(stilllooking_msg);\r\nif (orig_HSR & DIR) {\r\noutb(0, dev->base_addr + PORT_CONTROL);\r\nmsleep(300);\r\nif (inb_status(addr) & DIR) {\r\nif (elp_debug > 0)\r\npr_cont(notfound_msg, 2);\r\ngoto out;\r\n}\r\n} else {\r\noutb(DIR, dev->base_addr + PORT_CONTROL);\r\nmsleep(300);\r\nif (!(inb_status(addr) & DIR)) {\r\nif (elp_debug > 0)\r\npr_cont(notfound_msg, 3);\r\ngoto out;\r\n}\r\n}\r\nif (elp_debug > 0)\r\npr_cont(found_msg);\r\nreturn 0;\r\nout:\r\nrelease_region(addr, ELP_IO_EXTENT);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init elp_autodetect(struct net_device *dev)\r\n{\r\nint idx = 0;\r\nif (dev->base_addr != 0) {\r\nif (elp_sense(dev) == 0)\r\nreturn dev->base_addr;\r\n} else\r\nwhile ((dev->base_addr = addr_list[idx++])) {\r\nif (elp_sense(dev) == 0)\r\nreturn dev->base_addr;\r\n}\r\nif (elp_debug > 0)\r\npr_debug(couldnot_msg, dev->name);\r\nreturn 0;\r\n}\r\nstatic int __init elplus_setup(struct net_device *dev)\r\n{\r\nelp_device *adapter = netdev_priv(dev);\r\nint i, tries, tries1, okay;\r\nunsigned long timeout;\r\nunsigned long cookie = 0;\r\nint err = -ENODEV;\r\ndev->base_addr = elp_autodetect(dev);\r\nif (!dev->base_addr)\r\nreturn -ENODEV;\r\nadapter->send_pcb_semaphore = 0;\r\nfor (tries1 = 0; tries1 < 3; tries1++) {\r\noutb_control((adapter->hcr_val | CMDE) & ~DIR, dev);\r\ntimeout = jiffies + 5*HZ/100;\r\nokay = 0;\r\nwhile (time_before(jiffies, timeout) && !(inb_status(dev->base_addr) & HCRE));\r\nif ((inb_status(dev->base_addr) & HCRE)) {\r\noutb_command(0, dev->base_addr);\r\ntimeout = jiffies + 5*HZ/100;\r\nwhile (time_before(jiffies, timeout) && !(inb_status(dev->base_addr) & HCRE));\r\nif (inb_status(dev->base_addr) & HCRE)\r\nokay = 1;\r\n}\r\nif (!okay) {\r\npr_err("%s: command register wouldn't drain, ", dev->name);\r\nif ((inb_status(dev->base_addr) & 7) == 3) {\r\npr_cont("assuming 3c505 still starting\n");\r\ntimeout = jiffies + 10*HZ;\r\nwhile (time_before(jiffies, timeout) && (inb_status(dev->base_addr) & 7));\r\nif (inb_status(dev->base_addr) & 7) {\r\npr_err("%s: 3c505 failed to start\n", dev->name);\r\n} else {\r\nokay = 1;\r\n}\r\n} else {\r\npr_cont("3c505 is sulking\n");\r\n}\r\n}\r\nfor (tries = 0; tries < 5 && okay; tries++) {\r\nadapter->tx_pcb.command = CMD_STATION_ADDRESS;\r\nadapter->tx_pcb.length = 0;\r\ncookie = probe_irq_on();\r\nif (!send_pcb(dev, &adapter->tx_pcb)) {\r\npr_err("%s: could not send first PCB\n", dev->name);\r\nprobe_irq_off(cookie);\r\ncontinue;\r\n}\r\nif (!receive_pcb(dev, &adapter->rx_pcb)) {\r\npr_err("%s: could not read first PCB\n", dev->name);\r\nprobe_irq_off(cookie);\r\ncontinue;\r\n}\r\nif ((adapter->rx_pcb.command != CMD_ADDRESS_RESPONSE) ||\r\n(adapter->rx_pcb.length != 6)) {\r\npr_err("%s: first PCB wrong (%d, %d)\n", dev->name,\r\nadapter->rx_pcb.command, adapter->rx_pcb.length);\r\nprobe_irq_off(cookie);\r\ncontinue;\r\n}\r\ngoto okay;\r\n}\r\npr_info("%s: resetting adapter\n", dev->name);\r\noutb_control(adapter->hcr_val | FLSH | ATTN, dev);\r\noutb_control(adapter->hcr_val & ~(FLSH | ATTN), dev);\r\n}\r\npr_err("%s: failed to initialise 3c505\n", dev->name);\r\ngoto out;\r\nokay:\r\nif (dev->irq) {\r\nint rpt = probe_irq_off(cookie);\r\nif (dev->irq != rpt) {\r\npr_warning("%s: warning, irq %d configured but %d detected\n", dev->name, dev->irq, rpt);\r\n}\r\n} else\r\ndev->irq = probe_irq_off(cookie);\r\nswitch (dev->irq) {\r\ncase 0:\r\npr_err("%s: IRQ probe failed: check 3c505 jumpers.\n",\r\ndev->name);\r\ngoto out;\r\ncase 1:\r\ncase 6:\r\ncase 8:\r\ncase 13:\r\npr_err("%s: Impossible IRQ %d reported by probe_irq_off().\n",\r\ndev->name, dev->irq);\r\ngoto out;\r\n}\r\noutb_control(adapter->hcr_val & ~CMDE, dev);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = adapter->rx_pcb.data.eth_addr[i];\r\nif (!dev->dma) {\r\nif (dev->mem_start) {\r\ndev->dma = dev->mem_start & 7;\r\n}\r\nelse {\r\npr_warning("%s: warning, DMA channel not specified, using default\n", dev->name);\r\ndev->dma = ELP_DMA;\r\n}\r\n}\r\npr_info("%s: 3c505 at %#lx, irq %d, dma %d, addr %pM, ",\r\ndev->name, dev->base_addr, dev->irq, dev->dma, dev->dev_addr);\r\nadapter->tx_pcb.command = CMD_ADAPTER_INFO;\r\nadapter->tx_pcb.length = 0;\r\nif (!send_pcb(dev, &adapter->tx_pcb) ||\r\n!receive_pcb(dev, &adapter->rx_pcb) ||\r\n(adapter->rx_pcb.command != CMD_ADAPTER_INFO_RESPONSE) ||\r\n(adapter->rx_pcb.length != 10)) {\r\npr_cont("not responding to second PCB\n");\r\n}\r\npr_cont("rev %d.%d, %dk\n", adapter->rx_pcb.data.info.major_vers,\r\nadapter->rx_pcb.data.info.minor_vers, adapter->rx_pcb.data.info.RAM_sz);\r\nadapter->tx_pcb.command = CMD_CONFIGURE_ADAPTER_MEMORY;\r\nadapter->tx_pcb.length = 12;\r\nadapter->tx_pcb.data.memconf.cmd_q = 8;\r\nadapter->tx_pcb.data.memconf.rcv_q = 8;\r\nadapter->tx_pcb.data.memconf.mcast = 10;\r\nadapter->tx_pcb.data.memconf.frame = 10;\r\nadapter->tx_pcb.data.memconf.rcv_b = 10;\r\nadapter->tx_pcb.data.memconf.progs = 0;\r\nif (!send_pcb(dev, &adapter->tx_pcb) ||\r\n!receive_pcb(dev, &adapter->rx_pcb) ||\r\n(adapter->rx_pcb.command != CMD_CONFIGURE_ADAPTER_RESPONSE) ||\r\n(adapter->rx_pcb.length != 2)) {\r\npr_err("%s: could not configure adapter memory\n", dev->name);\r\n}\r\nif (adapter->rx_pcb.data.configure) {\r\npr_err("%s: adapter configuration failed\n", dev->name);\r\n}\r\ndev->netdev_ops = &elp_netdev_ops;\r\ndev->watchdog_timeo = 10*HZ;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\ndev->mem_start = dev->mem_end = 0;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nrelease_region(dev->base_addr, ELP_IO_EXTENT);\r\nreturn err;\r\n}\r\nstruct net_device * __init elplus_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(elp_device));\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = elplus_setup(dev);\r\nif (err) {\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn dev;\r\n}\r\nint __init init_module(void)\r\n{\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < ELP_MAX_CARDS; this_dev++) {\r\nstruct net_device *dev = alloc_etherdev(sizeof(elp_device));\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\nif (dma[this_dev]) {\r\ndev->dma = dma[this_dev];\r\n} else {\r\ndev->dma = ELP_DMA;\r\npr_warning("3c505.c: warning, using default DMA channel,\n");\r\n}\r\nif (io[this_dev] == 0) {\r\nif (this_dev) {\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\npr_notice("3c505.c: module autoprobe not recommended, give io=xx.\n");\r\n}\r\nif (elplus_setup(dev) != 0) {\r\npr_warning("3c505.c: Failed to register card at 0x%x.\n", io[this_dev]);\r\nfree_netdev(dev);\r\nbreak;\r\n}\r\ndev_3c505[this_dev] = dev;\r\nfound++;\r\n}\r\nif (!found)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < ELP_MAX_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_3c505[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, ELP_IO_EXTENT);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
