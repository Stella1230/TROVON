static unsigned int\r\nipt_snat_target(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\r\nNF_CT_ASSERT(par->hooknum == NF_INET_POST_ROUTING ||\r\npar->hooknum == NF_INET_LOCAL_IN);\r\nct = nf_ct_get(skb, &ctinfo);\r\nNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\r\nctinfo == IP_CT_RELATED_REPLY));\r\nNF_CT_ASSERT(par->out != NULL);\r\nreturn nf_nat_setup_info(ct, &mr->range[0], NF_NAT_MANIP_SRC);\r\n}\r\nstatic unsigned int\r\nipt_dnat_target(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\r\nNF_CT_ASSERT(par->hooknum == NF_INET_PRE_ROUTING ||\r\npar->hooknum == NF_INET_LOCAL_OUT);\r\nct = nf_ct_get(skb, &ctinfo);\r\nNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\r\nreturn nf_nat_setup_info(ct, &mr->range[0], NF_NAT_MANIP_DST);\r\n}\r\nstatic int ipt_snat_checkentry(const struct xt_tgchk_param *par)\r\n{\r\nconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\r\nif (mr->rangesize != 1) {\r\npr_info("SNAT: multiple ranges no longer supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipt_dnat_checkentry(const struct xt_tgchk_param *par)\r\n{\r\nconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\r\nif (mr->rangesize != 1) {\r\npr_info("DNAT: multiple ranges no longer supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nalloc_null_binding(struct nf_conn *ct, unsigned int hooknum)\r\n{\r\nstruct nf_nat_ipv4_range range;\r\nrange.flags = 0;\r\npr_debug("Allocating NULL binding for %p (%pI4)\n", ct,\r\nHOOK2MANIP(hooknum) == NF_NAT_MANIP_SRC ?\r\n&ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip :\r\n&ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip);\r\nreturn nf_nat_setup_info(ct, &range, HOOK2MANIP(hooknum));\r\n}\r\nint nf_nat_rule_find(struct sk_buff *skb,\r\nunsigned int hooknum,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nstruct nf_conn *ct)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nint ret;\r\nret = ipt_do_table(skb, hooknum, in, out, net->ipv4.nat_table);\r\nif (ret == NF_ACCEPT) {\r\nif (!nf_nat_initialized(ct, HOOK2MANIP(hooknum)))\r\nret = alloc_null_binding(ct, hooknum);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __net_init nf_nat_rule_net_init(struct net *net)\r\n{\r\nstruct ipt_replace *repl;\r\nrepl = ipt_alloc_initial_table(&nat_table);\r\nif (repl == NULL)\r\nreturn -ENOMEM;\r\nnet->ipv4.nat_table = ipt_register_table(net, &nat_table, repl);\r\nkfree(repl);\r\nif (IS_ERR(net->ipv4.nat_table))\r\nreturn PTR_ERR(net->ipv4.nat_table);\r\nreturn 0;\r\n}\r\nstatic void __net_exit nf_nat_rule_net_exit(struct net *net)\r\n{\r\nipt_unregister_table(net, net->ipv4.nat_table);\r\n}\r\nint __init nf_nat_rule_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&nf_nat_rule_net_ops);\r\nif (ret != 0)\r\ngoto out;\r\nret = xt_register_target(&ipt_snat_reg);\r\nif (ret != 0)\r\ngoto unregister_table;\r\nret = xt_register_target(&ipt_dnat_reg);\r\nif (ret != 0)\r\ngoto unregister_snat;\r\nreturn ret;\r\nunregister_snat:\r\nxt_unregister_target(&ipt_snat_reg);\r\nunregister_table:\r\nunregister_pernet_subsys(&nf_nat_rule_net_ops);\r\nout:\r\nreturn ret;\r\n}\r\nvoid nf_nat_rule_cleanup(void)\r\n{\r\nxt_unregister_target(&ipt_dnat_reg);\r\nxt_unregister_target(&ipt_snat_reg);\r\nunregister_pernet_subsys(&nf_nat_rule_net_ops);\r\n}
