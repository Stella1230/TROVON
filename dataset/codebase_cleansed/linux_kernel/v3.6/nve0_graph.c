static void\r\nnve0_graph_ctxctl_debug_unit(struct drm_device *dev, u32 base)\r\n{\r\nNV_INFO(dev, "PGRAPH: %06x - done 0x%08x\n", base,\r\nnv_rd32(dev, base + 0x400));\r\nNV_INFO(dev, "PGRAPH: %06x - stat 0x%08x 0x%08x 0x%08x 0x%08x\n", base,\r\nnv_rd32(dev, base + 0x800), nv_rd32(dev, base + 0x804),\r\nnv_rd32(dev, base + 0x808), nv_rd32(dev, base + 0x80c));\r\nNV_INFO(dev, "PGRAPH: %06x - stat 0x%08x 0x%08x 0x%08x 0x%08x\n", base,\r\nnv_rd32(dev, base + 0x810), nv_rd32(dev, base + 0x814),\r\nnv_rd32(dev, base + 0x818), nv_rd32(dev, base + 0x81c));\r\n}\r\nstatic void\r\nnve0_graph_ctxctl_debug(struct drm_device *dev)\r\n{\r\nu32 gpcnr = nv_rd32(dev, 0x409604) & 0xffff;\r\nu32 gpc;\r\nnve0_graph_ctxctl_debug_unit(dev, 0x409000);\r\nfor (gpc = 0; gpc < gpcnr; gpc++)\r\nnve0_graph_ctxctl_debug_unit(dev, 0x502000 + (gpc * 0x8000));\r\n}\r\nstatic int\r\nnve0_graph_load_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nnv_wr32(dev, 0x409840, 0x00000030);\r\nnv_wr32(dev, 0x409500, 0x80000000 | chan->ramin->vinst >> 12);\r\nnv_wr32(dev, 0x409504, 0x00000003);\r\nif (!nv_wait(dev, 0x409800, 0x00000010, 0x00000010))\r\nNV_ERROR(dev, "PGRAPH: load_ctx timeout\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nnve0_graph_unload_context_to(struct drm_device *dev, u64 chan)\r\n{\r\nnv_wr32(dev, 0x409840, 0x00000003);\r\nnv_wr32(dev, 0x409500, 0x80000000 | chan >> 12);\r\nnv_wr32(dev, 0x409504, 0x00000009);\r\nif (!nv_wait(dev, 0x409800, 0x00000001, 0x00000000)) {\r\nNV_ERROR(dev, "PGRAPH: unload_ctx timeout\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnve0_graph_construct_context(struct nouveau_channel *chan)\r\n{\r\nstruct drm_nouveau_private *dev_priv = chan->dev->dev_private;\r\nstruct nve0_graph_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);\r\nstruct nve0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];\r\nstruct drm_device *dev = chan->dev;\r\nint ret, i;\r\nu32 *ctx;\r\nctx = kmalloc(priv->grctx_size, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nnve0_graph_load_context(chan);\r\nnv_wo32(grch->grctx, 0x1c, 1);\r\nnv_wo32(grch->grctx, 0x20, 0);\r\nnv_wo32(grch->grctx, 0x28, 0);\r\nnv_wo32(grch->grctx, 0x2c, 0);\r\ndev_priv->engine.instmem.flush(dev);\r\nret = nve0_grctx_generate(chan);\r\nif (ret)\r\ngoto err;\r\nret = nve0_graph_unload_context_to(dev, chan->ramin->vinst);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < priv->grctx_size; i += 4)\r\nctx[i / 4] = nv_ro32(grch->grctx, i);\r\npriv->grctx_vals = ctx;\r\nreturn 0;\r\nerr:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int\r\nnve0_graph_create_context_mmio_list(struct nouveau_channel *chan)\r\n{\r\nstruct nve0_graph_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);\r\nstruct nve0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];\r\nstruct drm_device *dev = chan->dev;\r\nu32 magic[GPC_MAX][2];\r\nu16 offset = 0x0000;\r\nint gpc;\r\nint ret;\r\nret = nouveau_gpuobj_new(dev, chan, 0x3000, 256, NVOBJ_FLAG_VM,\r\n&grch->unk408004);\r\nif (ret)\r\nreturn ret;\r\nret = nouveau_gpuobj_new(dev, chan, 0x8000, 256, NVOBJ_FLAG_VM,\r\n&grch->unk40800c);\r\nif (ret)\r\nreturn ret;\r\nret = nouveau_gpuobj_new(dev, chan, 384 * 1024, 4096,\r\nNVOBJ_FLAG_VM | NVOBJ_FLAG_VM_USER,\r\n&grch->unk418810);\r\nif (ret)\r\nreturn ret;\r\nret = nouveau_gpuobj_new(dev, chan, 0x1000, 0, NVOBJ_FLAG_VM,\r\n&grch->mmio);\r\nif (ret)\r\nreturn ret;\r\n#define mmio(r,v) do { \\r\nnv_wo32(grch->mmio, (grch->mmio_nr * 8) + 0, (r)); \\r\nnv_wo32(grch->mmio, (grch->mmio_nr * 8) + 4, (v)); \\r\ngrch->mmio_nr++; \\r\n} while (0)\r\nmmio(0x40800c, grch->unk40800c->linst >> 8);\r\nmmio(0x408010, 0x80000000);\r\nmmio(0x419004, grch->unk40800c->linst >> 8);\r\nmmio(0x419008, 0x00000000);\r\nmmio(0x4064cc, 0x80000000);\r\nmmio(0x408004, grch->unk408004->linst >> 8);\r\nmmio(0x408008, 0x80000030);\r\nmmio(0x418808, grch->unk408004->linst >> 8);\r\nmmio(0x41880c, 0x80000030);\r\nmmio(0x4064c8, 0x01800600);\r\nmmio(0x418810, 0x80000000 | grch->unk418810->linst >> 12);\r\nmmio(0x419848, 0x10000000 | grch->unk418810->linst >> 12);\r\nmmio(0x405830, 0x02180648);\r\nmmio(0x4064c4, 0x0192ffff);\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\nu16 magic0 = 0x0218 * priv->tpc_nr[gpc];\r\nu16 magic1 = 0x0648 * priv->tpc_nr[gpc];\r\nmagic[gpc][0] = 0x10000000 | (magic0 << 16) | offset;\r\nmagic[gpc][1] = 0x00000000 | (magic1 << 16);\r\noffset += 0x0324 * priv->tpc_nr[gpc];\r\n}\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\nmmio(GPC_UNIT(gpc, 0x30c0), magic[gpc][0]);\r\nmmio(GPC_UNIT(gpc, 0x30e4), magic[gpc][1] | offset);\r\noffset += 0x07ff * priv->tpc_nr[gpc];\r\n}\r\nmmio(0x17e91c, 0x06060609);\r\nmmio(0x17e920, 0x00090a05);\r\n#undef mmio\r\nreturn 0;\r\n}\r\nstatic int\r\nnve0_graph_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_instmem_engine *pinstmem = &dev_priv->engine.instmem;\r\nstruct nve0_graph_priv *priv = nv_engine(dev, engine);\r\nstruct nve0_graph_chan *grch;\r\nstruct nouveau_gpuobj *grctx;\r\nint ret, i;\r\ngrch = kzalloc(sizeof(*grch), GFP_KERNEL);\r\nif (!grch)\r\nreturn -ENOMEM;\r\nchan->engctx[NVOBJ_ENGINE_GR] = grch;\r\nret = nouveau_gpuobj_new(dev, chan, priv->grctx_size, 256,\r\nNVOBJ_FLAG_VM | NVOBJ_FLAG_ZERO_ALLOC,\r\n&grch->grctx);\r\nif (ret)\r\ngoto error;\r\ngrctx = grch->grctx;\r\nret = nve0_graph_create_context_mmio_list(chan);\r\nif (ret)\r\ngoto error;\r\nnv_wo32(chan->ramin, 0x0210, lower_32_bits(grctx->linst) | 4);\r\nnv_wo32(chan->ramin, 0x0214, upper_32_bits(grctx->linst));\r\npinstmem->flush(dev);\r\nif (!priv->grctx_vals) {\r\nret = nve0_graph_construct_context(chan);\r\nif (ret)\r\ngoto error;\r\n}\r\nfor (i = 0; i < priv->grctx_size; i += 4)\r\nnv_wo32(grctx, i, priv->grctx_vals[i / 4]);\r\nnv_wo32(grctx, 0xf4, 0);\r\nnv_wo32(grctx, 0xf8, 0);\r\nnv_wo32(grctx, 0x10, grch->mmio_nr);\r\nnv_wo32(grctx, 0x14, lower_32_bits(grch->mmio->linst));\r\nnv_wo32(grctx, 0x18, upper_32_bits(grch->mmio->linst));\r\nnv_wo32(grctx, 0x1c, 1);\r\nnv_wo32(grctx, 0x20, 0);\r\nnv_wo32(grctx, 0x28, 0);\r\nnv_wo32(grctx, 0x2c, 0);\r\npinstmem->flush(dev);\r\nreturn 0;\r\nerror:\r\npriv->base.context_del(chan, engine);\r\nreturn ret;\r\n}\r\nstatic void\r\nnve0_graph_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nve0_graph_chan *grch = chan->engctx[engine];\r\nnouveau_gpuobj_ref(NULL, &grch->mmio);\r\nnouveau_gpuobj_ref(NULL, &grch->unk418810);\r\nnouveau_gpuobj_ref(NULL, &grch->unk40800c);\r\nnouveau_gpuobj_ref(NULL, &grch->unk408004);\r\nnouveau_gpuobj_ref(NULL, &grch->grctx);\r\nchan->engctx[engine] = NULL;\r\n}\r\nstatic int\r\nnve0_graph_object_new(struct nouveau_channel *chan, int engine,\r\nu32 handle, u16 class)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nnve0_graph_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nnve0_graph_init_obj418880(struct drm_device *dev)\r\n{\r\nstruct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nint i;\r\nnv_wr32(dev, GPC_BCAST(0x0880), 0x00000000);\r\nnv_wr32(dev, GPC_BCAST(0x08a4), 0x00000000);\r\nfor (i = 0; i < 4; i++)\r\nnv_wr32(dev, GPC_BCAST(0x0888) + (i * 4), 0x00000000);\r\nnv_wr32(dev, GPC_BCAST(0x08b4), priv->unk4188b4->vinst >> 8);\r\nnv_wr32(dev, GPC_BCAST(0x08b8), priv->unk4188b8->vinst >> 8);\r\n}\r\nstatic void\r\nnve0_graph_init_regs(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, 0x400080, 0x003083c2);\r\nnv_wr32(dev, 0x400088, 0x0001ffe7);\r\nnv_wr32(dev, 0x40008c, 0x00000000);\r\nnv_wr32(dev, 0x400090, 0x00000030);\r\nnv_wr32(dev, 0x40013c, 0x003901f7);\r\nnv_wr32(dev, 0x400140, 0x00000100);\r\nnv_wr32(dev, 0x400144, 0x00000000);\r\nnv_wr32(dev, 0x400148, 0x00000110);\r\nnv_wr32(dev, 0x400138, 0x00000000);\r\nnv_wr32(dev, 0x400130, 0x00000000);\r\nnv_wr32(dev, 0x400134, 0x00000000);\r\nnv_wr32(dev, 0x400124, 0x00000002);\r\n}\r\nstatic void\r\nnve0_graph_init_units(struct drm_device *dev)\r\n{\r\nnv_wr32(dev, 0x409ffc, 0x00000000);\r\nnv_wr32(dev, 0x409c14, 0x00003e3e);\r\nnv_wr32(dev, 0x409c24, 0x000f0000);\r\nnv_wr32(dev, 0x404000, 0xc0000000);\r\nnv_wr32(dev, 0x404600, 0xc0000000);\r\nnv_wr32(dev, 0x408030, 0xc0000000);\r\nnv_wr32(dev, 0x404490, 0xc0000000);\r\nnv_wr32(dev, 0x406018, 0xc0000000);\r\nnv_wr32(dev, 0x407020, 0xc0000000);\r\nnv_wr32(dev, 0x405840, 0xc0000000);\r\nnv_wr32(dev, 0x405844, 0x00ffffff);\r\nnv_mask(dev, 0x419cc0, 0x00000008, 0x00000008);\r\nnv_mask(dev, 0x419eb4, 0x00001000, 0x00001000);\r\n}\r\nstatic void\r\nnve0_graph_init_gpc_0(struct drm_device *dev)\r\n{\r\nstruct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nconst u32 magicgpc918 = DIV_ROUND_UP(0x00800000, priv->tpc_total);\r\nu32 data[TPC_MAX / 8];\r\nu8 tpcnr[GPC_MAX];\r\nint i, gpc, tpc;\r\nnv_wr32(dev, GPC_UNIT(0, 0x3018), 0x00000001);\r\nmemset(data, 0x00, sizeof(data));\r\nmemcpy(tpcnr, priv->tpc_nr, sizeof(priv->tpc_nr));\r\nfor (i = 0, gpc = -1; i < priv->tpc_total; i++) {\r\ndo {\r\ngpc = (gpc + 1) % priv->gpc_nr;\r\n} while (!tpcnr[gpc]);\r\ntpc = priv->tpc_nr[gpc] - tpcnr[gpc]--;\r\ndata[i / 8] |= tpc << ((i % 8) * 4);\r\n}\r\nnv_wr32(dev, GPC_BCAST(0x0980), data[0]);\r\nnv_wr32(dev, GPC_BCAST(0x0984), data[1]);\r\nnv_wr32(dev, GPC_BCAST(0x0988), data[2]);\r\nnv_wr32(dev, GPC_BCAST(0x098c), data[3]);\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0914), priv->magic_not_rop_nr << 8 |\r\npriv->tpc_nr[gpc]);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0910), 0x00040000 | priv->tpc_total);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0918), magicgpc918);\r\n}\r\nnv_wr32(dev, GPC_BCAST(0x1bd4), magicgpc918);\r\nnv_wr32(dev, GPC_BCAST(0x08ac), nv_rd32(dev, 0x100800));\r\n}\r\nstatic void\r\nnve0_graph_init_gpc_1(struct drm_device *dev)\r\n{\r\nstruct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nint gpc, tpc;\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x3038), 0xc0000000);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0420), 0xc0000000);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0900), 0xc0000000);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x1028), 0xc0000000);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x0824), 0xc0000000);\r\nfor (tpc = 0; tpc < priv->tpc_nr[gpc]; tpc++) {\r\nnv_wr32(dev, TPC_UNIT(gpc, tpc, 0x508), 0xffffffff);\r\nnv_wr32(dev, TPC_UNIT(gpc, tpc, 0x50c), 0xffffffff);\r\nnv_wr32(dev, TPC_UNIT(gpc, tpc, 0x224), 0xc0000000);\r\nnv_wr32(dev, TPC_UNIT(gpc, tpc, 0x48c), 0xc0000000);\r\nnv_wr32(dev, TPC_UNIT(gpc, tpc, 0x084), 0xc0000000);\r\nnv_wr32(dev, TPC_UNIT(gpc, tpc, 0x644), 0x001ffffe);\r\nnv_wr32(dev, TPC_UNIT(gpc, tpc, 0x64c), 0x0000000f);\r\n}\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x2c90), 0xffffffff);\r\nnv_wr32(dev, GPC_UNIT(gpc, 0x2c94), 0xffffffff);\r\n}\r\n}\r\nstatic void\r\nnve0_graph_init_rop(struct drm_device *dev)\r\n{\r\nstruct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nint rop;\r\nfor (rop = 0; rop < priv->rop_nr; rop++) {\r\nnv_wr32(dev, ROP_UNIT(rop, 0x144), 0xc0000000);\r\nnv_wr32(dev, ROP_UNIT(rop, 0x070), 0xc0000000);\r\nnv_wr32(dev, ROP_UNIT(rop, 0x204), 0xffffffff);\r\nnv_wr32(dev, ROP_UNIT(rop, 0x208), 0xffffffff);\r\n}\r\n}\r\nstatic void\r\nnve0_graph_init_fuc(struct drm_device *dev, u32 fuc_base,\r\nstruct nve0_graph_fuc *code, struct nve0_graph_fuc *data)\r\n{\r\nint i;\r\nnv_wr32(dev, fuc_base + 0x01c0, 0x01000000);\r\nfor (i = 0; i < data->size / 4; i++)\r\nnv_wr32(dev, fuc_base + 0x01c4, data->data[i]);\r\nnv_wr32(dev, fuc_base + 0x0180, 0x01000000);\r\nfor (i = 0; i < code->size / 4; i++) {\r\nif ((i & 0x3f) == 0)\r\nnv_wr32(dev, fuc_base + 0x0188, i >> 6);\r\nnv_wr32(dev, fuc_base + 0x0184, code->data[i]);\r\n}\r\n}\r\nstatic int\r\nnve0_graph_init_ctxctl(struct drm_device *dev)\r\n{\r\nstruct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nu32 r000260;\r\nr000260 = nv_mask(dev, 0x000260, 0x00000001, 0x00000000);\r\nnve0_graph_init_fuc(dev, 0x409000, &priv->fuc409c, &priv->fuc409d);\r\nnve0_graph_init_fuc(dev, 0x41a000, &priv->fuc41ac, &priv->fuc41ad);\r\nnv_wr32(dev, 0x000260, r000260);\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x41a10c, 0x00000000);\r\nnv_wr32(dev, 0x40910c, 0x00000000);\r\nnv_wr32(dev, 0x41a100, 0x00000002);\r\nnv_wr32(dev, 0x409100, 0x00000002);\r\nif (!nv_wait(dev, 0x409800, 0x00000001, 0x00000001))\r\nNV_INFO(dev, "0x409800 wait failed\n");\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x409500, 0x7fffffff);\r\nnv_wr32(dev, 0x409504, 0x00000021);\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x409500, 0x00000000);\r\nnv_wr32(dev, 0x409504, 0x00000010);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x10 timeout\n");\r\nreturn -EBUSY;\r\n}\r\npriv->grctx_size = nv_rd32(dev, 0x409800);\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x409500, 0x00000000);\r\nnv_wr32(dev, 0x409504, 0x00000016);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x16 timeout\n");\r\nreturn -EBUSY;\r\n}\r\nnv_wr32(dev, 0x409840, 0xffffffff);\r\nnv_wr32(dev, 0x409500, 0x00000000);\r\nnv_wr32(dev, 0x409504, 0x00000025);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x25 timeout\n");\r\nreturn -EBUSY;\r\n}\r\nnv_wr32(dev, 0x409800, 0x00000000);\r\nnv_wr32(dev, 0x409500, 0x00000001);\r\nnv_wr32(dev, 0x409504, 0x00000030);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x30 timeout\n");\r\nreturn -EBUSY;\r\n}\r\nnv_wr32(dev, 0x409810, 0xb00095c8);\r\nnv_wr32(dev, 0x409800, 0x00000000);\r\nnv_wr32(dev, 0x409500, 0x00000001);\r\nnv_wr32(dev, 0x409504, 0x00000031);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x31 timeout\n");\r\nreturn -EBUSY;\r\n}\r\nnv_wr32(dev, 0x409810, 0x00080420);\r\nnv_wr32(dev, 0x409800, 0x00000000);\r\nnv_wr32(dev, 0x409500, 0x00000001);\r\nnv_wr32(dev, 0x409504, 0x00000032);\r\nif (!nv_wait_ne(dev, 0x409800, 0xffffffff, 0x00000000)) {\r\nNV_ERROR(dev, "fuc09 req 0x32 timeout\n");\r\nreturn -EBUSY;\r\n}\r\nnv_wr32(dev, 0x409614, 0x00000070);\r\nnv_wr32(dev, 0x409614, 0x00000770);\r\nnv_wr32(dev, 0x40802c, 0x00000001);\r\nreturn 0;\r\n}\r\nstatic int\r\nnve0_graph_init(struct drm_device *dev, int engine)\r\n{\r\nint ret;\r\nnv_mask(dev, 0x000200, 0x18001000, 0x00000000);\r\nnv_mask(dev, 0x000200, 0x18001000, 0x18001000);\r\nnve0_graph_init_obj418880(dev);\r\nnve0_graph_init_regs(dev);\r\nnve0_graph_init_gpc_0(dev);\r\nnv_wr32(dev, 0x400500, 0x00010001);\r\nnv_wr32(dev, 0x400100, 0xffffffff);\r\nnv_wr32(dev, 0x40013c, 0xffffffff);\r\nnve0_graph_init_units(dev);\r\nnve0_graph_init_gpc_1(dev);\r\nnve0_graph_init_rop(dev);\r\nnv_wr32(dev, 0x400108, 0xffffffff);\r\nnv_wr32(dev, 0x400138, 0xffffffff);\r\nnv_wr32(dev, 0x400118, 0xffffffff);\r\nnv_wr32(dev, 0x400130, 0xffffffff);\r\nnv_wr32(dev, 0x40011c, 0xffffffff);\r\nnv_wr32(dev, 0x400134, 0xffffffff);\r\nnv_wr32(dev, 0x400054, 0x34ce3464);\r\nret = nve0_graph_init_ctxctl(dev);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint\r\nnve0_graph_isr_chid(struct drm_device *dev, u64 inst)\r\n{\r\nstruct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_channel *chan;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&dev_priv->channels.lock, flags);\r\nfor (i = 0; i < pfifo->channels; i++) {\r\nchan = dev_priv->channels.ptr[i];\r\nif (!chan || !chan->ramin)\r\ncontinue;\r\nif (inst == chan->ramin->vinst)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dev_priv->channels.lock, flags);\r\nreturn i;\r\n}\r\nstatic void\r\nnve0_graph_ctxctl_isr(struct drm_device *dev)\r\n{\r\nu32 ustat = nv_rd32(dev, 0x409c18);\r\nif (ustat & 0x00000001)\r\nNV_INFO(dev, "PGRAPH: CTXCTRL ucode error\n");\r\nif (ustat & 0x00080000)\r\nNV_INFO(dev, "PGRAPH: CTXCTRL watchdog timeout\n");\r\nif (ustat & ~0x00080001)\r\nNV_INFO(dev, "PGRAPH: CTXCTRL 0x%08x\n", ustat);\r\nnve0_graph_ctxctl_debug(dev);\r\nnv_wr32(dev, 0x409c20, ustat);\r\n}\r\nstatic void\r\nnve0_graph_trap_isr(struct drm_device *dev, int chid)\r\n{\r\nstruct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);\r\nu32 trap = nv_rd32(dev, 0x400108);\r\nint rop;\r\nif (trap & 0x00000001) {\r\nu32 stat = nv_rd32(dev, 0x404000);\r\nNV_INFO(dev, "PGRAPH: DISPATCH ch %d 0x%08x\n", chid, stat);\r\nnv_wr32(dev, 0x404000, 0xc0000000);\r\nnv_wr32(dev, 0x400108, 0x00000001);\r\ntrap &= ~0x00000001;\r\n}\r\nif (trap & 0x00000010) {\r\nu32 stat = nv_rd32(dev, 0x405840);\r\nNV_INFO(dev, "PGRAPH: SHADER ch %d 0x%08x\n", chid, stat);\r\nnv_wr32(dev, 0x405840, 0xc0000000);\r\nnv_wr32(dev, 0x400108, 0x00000010);\r\ntrap &= ~0x00000010;\r\n}\r\nif (trap & 0x02000000) {\r\nfor (rop = 0; rop < priv->rop_nr; rop++) {\r\nu32 statz = nv_rd32(dev, ROP_UNIT(rop, 0x070));\r\nu32 statc = nv_rd32(dev, ROP_UNIT(rop, 0x144));\r\nNV_INFO(dev, "PGRAPH: ROP%d ch %d 0x%08x 0x%08x\n",\r\nrop, chid, statz, statc);\r\nnv_wr32(dev, ROP_UNIT(rop, 0x070), 0xc0000000);\r\nnv_wr32(dev, ROP_UNIT(rop, 0x144), 0xc0000000);\r\n}\r\nnv_wr32(dev, 0x400108, 0x02000000);\r\ntrap &= ~0x02000000;\r\n}\r\nif (trap) {\r\nNV_INFO(dev, "PGRAPH: TRAP ch %d 0x%08x\n", chid, trap);\r\nnv_wr32(dev, 0x400108, trap);\r\n}\r\n}\r\nstatic void\r\nnve0_graph_isr(struct drm_device *dev)\r\n{\r\nu64 inst = (u64)(nv_rd32(dev, 0x409b00) & 0x0fffffff) << 12;\r\nu32 chid = nve0_graph_isr_chid(dev, inst);\r\nu32 stat = nv_rd32(dev, 0x400100);\r\nu32 addr = nv_rd32(dev, 0x400704);\r\nu32 mthd = (addr & 0x00003ffc);\r\nu32 subc = (addr & 0x00070000) >> 16;\r\nu32 data = nv_rd32(dev, 0x400708);\r\nu32 code = nv_rd32(dev, 0x400110);\r\nu32 class = nv_rd32(dev, 0x404200 + (subc * 4));\r\nif (stat & 0x00000010) {\r\nif (nouveau_gpuobj_mthd_call2(dev, chid, class, mthd, data)) {\r\nNV_INFO(dev, "PGRAPH: ILLEGAL_MTHD ch %d [0x%010llx] "\r\n"subc %d class 0x%04x mthd 0x%04x "\r\n"data 0x%08x\n",\r\nchid, inst, subc, class, mthd, data);\r\n}\r\nnv_wr32(dev, 0x400100, 0x00000010);\r\nstat &= ~0x00000010;\r\n}\r\nif (stat & 0x00000020) {\r\nNV_INFO(dev, "PGRAPH: ILLEGAL_CLASS ch %d [0x%010llx] subc %d "\r\n"class 0x%04x mthd 0x%04x data 0x%08x\n",\r\nchid, inst, subc, class, mthd, data);\r\nnv_wr32(dev, 0x400100, 0x00000020);\r\nstat &= ~0x00000020;\r\n}\r\nif (stat & 0x00100000) {\r\nNV_INFO(dev, "PGRAPH: DATA_ERROR [");\r\nnouveau_enum_print(nv50_data_error_names, code);\r\nprintk("] ch %d [0x%010llx] subc %d class 0x%04x "\r\n"mthd 0x%04x data 0x%08x\n",\r\nchid, inst, subc, class, mthd, data);\r\nnv_wr32(dev, 0x400100, 0x00100000);\r\nstat &= ~0x00100000;\r\n}\r\nif (stat & 0x00200000) {\r\nnve0_graph_trap_isr(dev, chid);\r\nnv_wr32(dev, 0x400100, 0x00200000);\r\nstat &= ~0x00200000;\r\n}\r\nif (stat & 0x00080000) {\r\nnve0_graph_ctxctl_isr(dev);\r\nnv_wr32(dev, 0x400100, 0x00080000);\r\nstat &= ~0x00080000;\r\n}\r\nif (stat) {\r\nNV_INFO(dev, "PGRAPH: unknown stat 0x%08x\n", stat);\r\nnv_wr32(dev, 0x400100, stat);\r\n}\r\nnv_wr32(dev, 0x400500, 0x00010001);\r\n}\r\nstatic int\r\nnve0_graph_create_fw(struct drm_device *dev, const char *fwname,\r\nstruct nve0_graph_fuc *fuc)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nconst struct firmware *fw;\r\nchar f[32];\r\nint ret;\r\nsnprintf(f, sizeof(f), "nouveau/nv%02x_%s", dev_priv->chipset, fwname);\r\nret = request_firmware(&fw, f, &dev->pdev->dev);\r\nif (ret)\r\nreturn ret;\r\nfuc->size = fw->size;\r\nfuc->data = kmemdup(fw->data, fuc->size, GFP_KERNEL);\r\nrelease_firmware(fw);\r\nreturn (fuc->data != NULL) ? 0 : -ENOMEM;\r\n}\r\nstatic void\r\nnve0_graph_destroy_fw(struct nve0_graph_fuc *fuc)\r\n{\r\nif (fuc->data) {\r\nkfree(fuc->data);\r\nfuc->data = NULL;\r\n}\r\n}\r\nstatic void\r\nnve0_graph_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nve0_graph_priv *priv = nv_engine(dev, engine);\r\nnve0_graph_destroy_fw(&priv->fuc409c);\r\nnve0_graph_destroy_fw(&priv->fuc409d);\r\nnve0_graph_destroy_fw(&priv->fuc41ac);\r\nnve0_graph_destroy_fw(&priv->fuc41ad);\r\nnouveau_irq_unregister(dev, 12);\r\nnouveau_gpuobj_ref(NULL, &priv->unk4188b8);\r\nnouveau_gpuobj_ref(NULL, &priv->unk4188b4);\r\nif (priv->grctx_vals)\r\nkfree(priv->grctx_vals);\r\nNVOBJ_ENGINE_DEL(dev, GR);\r\nkfree(priv);\r\n}\r\nint\r\nnve0_graph_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nve0_graph_priv *priv;\r\nint ret, gpc, i;\r\nu32 kepler;\r\nkepler = nve0_graph_class(dev);\r\nif (!kepler) {\r\nNV_ERROR(dev, "PGRAPH: unsupported chipset, please report!\n");\r\nreturn 0;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->base.destroy = nve0_graph_destroy;\r\npriv->base.init = nve0_graph_init;\r\npriv->base.fini = nve0_graph_fini;\r\npriv->base.context_new = nve0_graph_context_new;\r\npriv->base.context_del = nve0_graph_context_del;\r\npriv->base.object_new = nve0_graph_object_new;\r\nNVOBJ_ENGINE_ADD(dev, GR, &priv->base);\r\nnouveau_irq_register(dev, 12, nve0_graph_isr);\r\nNV_INFO(dev, "PGRAPH: using external firmware\n");\r\nif (nve0_graph_create_fw(dev, "fuc409c", &priv->fuc409c) ||\r\nnve0_graph_create_fw(dev, "fuc409d", &priv->fuc409d) ||\r\nnve0_graph_create_fw(dev, "fuc41ac", &priv->fuc41ac) ||\r\nnve0_graph_create_fw(dev, "fuc41ad", &priv->fuc41ad)) {\r\nret = 0;\r\ngoto error;\r\n}\r\nret = nouveau_gpuobj_new(dev, NULL, 0x1000, 256, 0, &priv->unk4188b4);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_gpuobj_new(dev, NULL, 0x1000, 256, 0, &priv->unk4188b8);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < 0x1000; i += 4) {\r\nnv_wo32(priv->unk4188b4, i, 0x00000010);\r\nnv_wo32(priv->unk4188b8, i, 0x00000010);\r\n}\r\npriv->gpc_nr = nv_rd32(dev, 0x409604) & 0x0000001f;\r\npriv->rop_nr = (nv_rd32(dev, 0x409604) & 0x001f0000) >> 16;\r\nfor (gpc = 0; gpc < priv->gpc_nr; gpc++) {\r\npriv->tpc_nr[gpc] = nv_rd32(dev, GPC_UNIT(gpc, 0x2608));\r\npriv->tpc_total += priv->tpc_nr[gpc];\r\n}\r\nswitch (dev_priv->chipset) {\r\ncase 0xe4:\r\nif (priv->tpc_total == 8)\r\npriv->magic_not_rop_nr = 3;\r\nelse\r\nif (priv->tpc_total == 7)\r\npriv->magic_not_rop_nr = 1;\r\nbreak;\r\ncase 0xe7:\r\npriv->magic_not_rop_nr = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!priv->magic_not_rop_nr) {\r\nNV_ERROR(dev, "PGRAPH: unknown config: %d/%d/%d/%d, %d\n",\r\npriv->tpc_nr[0], priv->tpc_nr[1], priv->tpc_nr[2],\r\npriv->tpc_nr[3], priv->rop_nr);\r\npriv->magic_not_rop_nr = 0x00;\r\n}\r\nNVOBJ_CLASS(dev, 0xa097, GR);\r\nNVOBJ_CLASS(dev, 0xa0c0, GR);\r\nNVOBJ_CLASS(dev, 0xa040, GR);\r\nNVOBJ_CLASS(dev, 0x902d, GR);\r\nNVOBJ_CLASS(dev, 0xa0b5, GR);\r\nreturn 0;\r\nerror:\r\nnve0_graph_destroy(dev, NVOBJ_ENGINE_GR);\r\nreturn ret;\r\n}
