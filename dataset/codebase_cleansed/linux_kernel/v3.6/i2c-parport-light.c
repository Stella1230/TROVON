static inline void port_write(unsigned char p, unsigned char d)\r\n{\r\noutb(d, base+p);\r\n}\r\nstatic inline unsigned char port_read(unsigned char p)\r\n{\r\nreturn inb(base+p);\r\n}\r\nstatic inline void line_set(int state, const struct lineop *op)\r\n{\r\nu8 oldval = port_read(op->port);\r\nif ((op->inverted && !state) || (!op->inverted && state))\r\nport_write(op->port, oldval | op->val);\r\nelse\r\nport_write(op->port, oldval & ~op->val);\r\n}\r\nstatic inline int line_get(const struct lineop *op)\r\n{\r\nu8 oldval = port_read(op->port);\r\nreturn ((op->inverted && (oldval & op->val) != op->val)\r\n|| (!op->inverted && (oldval & op->val) == op->val));\r\n}\r\nstatic void parport_setscl(void *data, int state)\r\n{\r\nline_set(state, &adapter_parm[type].setscl);\r\n}\r\nstatic void parport_setsda(void *data, int state)\r\n{\r\nline_set(state, &adapter_parm[type].setsda);\r\n}\r\nstatic int parport_getscl(void *data)\r\n{\r\nreturn line_get(&adapter_parm[type].getscl);\r\n}\r\nstatic int parport_getsda(void *data)\r\n{\r\nreturn line_get(&adapter_parm[type].getsda);\r\n}\r\nstatic int __devinit i2c_parport_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nparport_setsda(NULL, 1);\r\nparport_setscl(NULL, 1);\r\nif (adapter_parm[type].init.val) {\r\nline_set(1, &adapter_parm[type].init);\r\nmsleep(100);\r\n}\r\nparport_adapter.dev.parent = &pdev->dev;\r\nerr = i2c_bit_add_bus(&parport_adapter);\r\nif (err) {\r\ndev_err(&pdev->dev, "Unable to register with I2C\n");\r\nreturn err;\r\n}\r\nif (adapter_parm[type].smbus_alert && irq) {\r\nalert_data.irq = irq;\r\nara = i2c_setup_smbus_alert(&parport_adapter, &alert_data);\r\nif (ara)\r\nline_set(1, &parport_ctrl_irq);\r\nelse\r\ndev_warn(&pdev->dev, "Failed to register ARA client\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit i2c_parport_remove(struct platform_device *pdev)\r\n{\r\nif (ara) {\r\nline_set(0, &parport_ctrl_irq);\r\ni2c_unregister_device(ara);\r\nara = NULL;\r\n}\r\ni2c_del_adapter(&parport_adapter);\r\nif (adapter_parm[type].init.val)\r\nline_set(0, &adapter_parm[type].init);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_parport_device_add(u16 address)\r\n{\r\nint err;\r\npdev = platform_device_alloc(DRVNAME, -1);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\nprintk(KERN_ERR DRVNAME ": Device allocation failed\n");\r\ngoto exit;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\nprintk(KERN_ERR DRVNAME ": Device addition failed (%d)\n",\r\nerr);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __init i2c_parport_init(void)\r\n{\r\nint err;\r\nif (type < 0) {\r\nprintk(KERN_ERR DRVNAME ": adapter type unspecified\n");\r\nreturn -ENODEV;\r\n}\r\nif (type >= ARRAY_SIZE(adapter_parm)) {\r\nprintk(KERN_ERR DRVNAME ": invalid type (%d)\n", type);\r\nreturn -ENODEV;\r\n}\r\nif (base == 0) {\r\npr_info(DRVNAME ": using default base 0x%x\n", DEFAULT_BASE);\r\nbase = DEFAULT_BASE;\r\n}\r\nif (!request_region(base, 3, DRVNAME))\r\nreturn -EBUSY;\r\nif (irq != 0)\r\npr_info(DRVNAME ": using irq %d\n", irq);\r\nif (!adapter_parm[type].getscl.val)\r\nparport_algo_data.getscl = NULL;\r\nerr = i2c_parport_device_add(base);\r\nif (err)\r\ngoto exit_release;\r\nerr = platform_driver_register(&i2c_parport_driver);\r\nif (err)\r\ngoto exit_device;\r\nreturn 0;\r\nexit_device:\r\nplatform_device_unregister(pdev);\r\nexit_release:\r\nrelease_region(base, 3);\r\nreturn err;\r\n}\r\nstatic void __exit i2c_parport_exit(void)\r\n{\r\nplatform_driver_unregister(&i2c_parport_driver);\r\nplatform_device_unregister(pdev);\r\nrelease_region(base, 3);\r\n}
