static int tsc_read_sample(struct tsc_data *ts, struct sample* sample)\r\n{\r\nint x, y, z1, z2, t, p = 0;\r\nu32 val;\r\nval = tsc_read(ts, chval[0]);\r\nif (val & DATA_VALID)\r\nx = val & 0xffff;\r\nelse\r\nreturn -EINVAL;\r\ny = tsc_read(ts, chval[1]) & 0xffff;\r\nz1 = tsc_read(ts, chval[2]) & 0xffff;\r\nz2 = tsc_read(ts, chval[3]) & 0xffff;\r\nif (z1) {\r\nt = ((600 * x) * (z2 - z1));\r\np = t / (u32) (z1 << 12);\r\nif (p < 0)\r\np = 0;\r\n}\r\nsample->x = x;\r\nsample->y = y;\r\nsample->p = p;\r\nreturn 0;\r\n}\r\nstatic void tsc_poll(unsigned long data)\r\n{\r\nstruct tsc_data *ts = (struct tsc_data *)data;\r\nunsigned long flags;\r\nint i, val, x, y, p;\r\nspin_lock_irqsave(&ts->lock, flags);\r\nif (ts->sample_count >= TSC_SKIP) {\r\ninput_report_abs(ts->input_dev, ABS_PRESSURE, 0);\r\ninput_report_key(ts->input_dev, BTN_TOUCH, 0);\r\ninput_sync(ts->input_dev);\r\n} else if (ts->sample_count > 0) {\r\nfor (i = 0, val = 0; i < ts->sample_count; i++)\r\nval += ts->samples[i].x;\r\nx = val / ts->sample_count;\r\nfor (i = 0, val = 0; i < ts->sample_count; i++)\r\nval += ts->samples[i].y;\r\ny = val / ts->sample_count;\r\nfor (i = 0, val = 0; i < ts->sample_count; i++)\r\nval += ts->samples[i].p;\r\np = val / ts->sample_count;\r\ninput_report_abs(ts->input_dev, ABS_X, x);\r\ninput_report_abs(ts->input_dev, ABS_Y, y);\r\ninput_report_abs(ts->input_dev, ABS_PRESSURE, p);\r\ninput_report_key(ts->input_dev, BTN_TOUCH, 1);\r\ninput_sync(ts->input_dev);\r\n}\r\nts->sample_count = 0;\r\nspin_unlock_irqrestore(&ts->lock, flags);\r\n}\r\nstatic irqreturn_t tsc_irq(int irq, void *dev_id)\r\n{\r\nstruct tsc_data *ts = (struct tsc_data *)dev_id;\r\nstruct sample *sample;\r\nint index;\r\nspin_lock(&ts->lock);\r\nindex = ts->sample_count % TSC_SAMPLES;\r\nsample = &ts->samples[index];\r\nif (tsc_read_sample(ts, sample) < 0)\r\ngoto out;\r\nif (++ts->sample_count >= TSC_SKIP) {\r\nindex = (ts->sample_count - TSC_TAIL_SKIP - 1) % TSC_SAMPLES;\r\nsample = &ts->samples[index];\r\ninput_report_abs(ts->input_dev, ABS_X, sample->x);\r\ninput_report_abs(ts->input_dev, ABS_Y, sample->y);\r\ninput_report_abs(ts->input_dev, ABS_PRESSURE, sample->p);\r\nif (ts->sample_count == TSC_SKIP)\r\ninput_report_key(ts->input_dev, BTN_TOUCH, 1);\r\ninput_sync(ts->input_dev);\r\n}\r\nmod_timer(&ts->timer, jiffies + TSC_PENUP_POLL);\r\nout:\r\nspin_unlock(&ts->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tsc_start(struct input_dev *dev)\r\n{\r\nstruct tsc_data *ts = input_get_drvdata(dev);\r\nunsigned long timeout = jiffies + msecs_to_jiffies(IDLE_TIMEOUT);\r\nu32 val;\r\nclk_enable(ts->clk);\r\nwhile (time_after(timeout, jiffies)) {\r\nif (tsc_read(ts, tscm) & IDLE)\r\nbreak;\r\n}\r\nif (time_before(timeout, jiffies)) {\r\ndev_warn(ts->dev, "timeout waiting for idle\n");\r\nclk_disable(ts->clk);\r\nreturn -EIO;\r\n}\r\nval = (PONBG | PON | PVSTC(4) | ONE_SHOT | ZMEASURE_EN);\r\ntsc_write(ts, tscm, val);\r\nval &= ~(AFERST);\r\ntsc_write(ts, tscm, val);\r\ntsc_write(ts, bwcm, 0);\r\ntsc_set_bits(ts, tscm, TSC_EN);\r\nreturn 0;\r\n}\r\nstatic void tsc_stop(struct input_dev *dev)\r\n{\r\nstruct tsc_data *ts = input_get_drvdata(dev);\r\ntsc_clr_bits(ts, tscm, TSC_EN);\r\nsynchronize_irq(ts->tsc_irq);\r\ndel_timer_sync(&ts->timer);\r\nclk_disable(ts->clk);\r\n}\r\nstatic int __devinit tsc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct tsc_data *ts;\r\nint error = 0;\r\nu32 rev = 0;\r\nts = kzalloc(sizeof(struct tsc_data), GFP_KERNEL);\r\nif (!ts) {\r\ndev_err(dev, "cannot allocate device info\n");\r\nreturn -ENOMEM;\r\n}\r\nts->dev = dev;\r\nspin_lock_init(&ts->lock);\r\nsetup_timer(&ts->timer, tsc_poll, (unsigned long)ts);\r\nplatform_set_drvdata(pdev, ts);\r\nts->tsc_irq = platform_get_irq(pdev, 0);\r\nif (ts->tsc_irq < 0) {\r\ndev_err(dev, "cannot determine device interrupt\n");\r\nerror = -ENODEV;\r\ngoto error_res;\r\n}\r\nts->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!ts->res) {\r\ndev_err(dev, "cannot determine register area\n");\r\nerror = -ENODEV;\r\ngoto error_res;\r\n}\r\nif (!request_mem_region(ts->res->start, resource_size(ts->res),\r\npdev->name)) {\r\ndev_err(dev, "cannot claim register memory\n");\r\nts->res = NULL;\r\nerror = -EINVAL;\r\ngoto error_res;\r\n}\r\nts->regs = ioremap(ts->res->start, resource_size(ts->res));\r\nif (!ts->regs) {\r\ndev_err(dev, "cannot map register memory\n");\r\nerror = -ENOMEM;\r\ngoto error_map;\r\n}\r\nts->clk = clk_get(dev, NULL);\r\nif (IS_ERR(ts->clk)) {\r\ndev_err(dev, "cannot claim device clock\n");\r\nerror = PTR_ERR(ts->clk);\r\ngoto error_clk;\r\n}\r\nerror = request_threaded_irq(ts->tsc_irq, NULL, tsc_irq, IRQF_ONESHOT,\r\ndev_name(dev), ts);\r\nif (error < 0) {\r\ndev_err(ts->dev, "Could not allocate ts irq\n");\r\ngoto error_irq;\r\n}\r\nts->input_dev = input_allocate_device();\r\nif (!ts->input_dev) {\r\ndev_err(dev, "cannot allocate input device\n");\r\nerror = -ENOMEM;\r\ngoto error_input;\r\n}\r\ninput_set_drvdata(ts->input_dev, ts);\r\nts->input_dev->name = pdev->name;\r\nts->input_dev->id.bustype = BUS_HOST;\r\nts->input_dev->dev.parent = &pdev->dev;\r\nts->input_dev->open = tsc_start;\r\nts->input_dev->close = tsc_stop;\r\nclk_enable(ts->clk);\r\nrev = tsc_read(ts, rev);\r\nts->input_dev->id.product = ((rev >> 8) & 0x07);\r\nts->input_dev->id.version = ((rev >> 16) & 0xfff);\r\nclk_disable(ts->clk);\r\n__set_bit(EV_KEY, ts->input_dev->evbit);\r\n__set_bit(EV_ABS, ts->input_dev->evbit);\r\n__set_bit(BTN_TOUCH, ts->input_dev->keybit);\r\ninput_set_abs_params(ts->input_dev, ABS_X, 0, 0xffff, 5, 0);\r\ninput_set_abs_params(ts->input_dev, ABS_Y, 0, 0xffff, 5, 0);\r\ninput_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 4095, 128, 0);\r\nerror = input_register_device(ts->input_dev);\r\nif (error < 0) {\r\ndev_err(dev, "failed input device registration\n");\r\ngoto error_reg;\r\n}\r\nreturn 0;\r\nerror_reg:\r\ninput_free_device(ts->input_dev);\r\nerror_input:\r\nfree_irq(ts->tsc_irq, ts);\r\nerror_irq:\r\nclk_put(ts->clk);\r\nerror_clk:\r\niounmap(ts->regs);\r\nerror_map:\r\nrelease_mem_region(ts->res->start, resource_size(ts->res));\r\nerror_res:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(ts);\r\nreturn error;\r\n}\r\nstatic int __devexit tsc_remove(struct platform_device *pdev)\r\n{\r\nstruct tsc_data *ts = platform_get_drvdata(pdev);\r\ninput_unregister_device(ts->input_dev);\r\nfree_irq(ts->tsc_irq, ts);\r\nclk_put(ts->clk);\r\niounmap(ts->regs);\r\nrelease_mem_region(ts->res->start, resource_size(ts->res));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(ts);\r\nreturn 0;\r\n}
