static void recovery_delay(void)\r\n{\r\nudelay(2);\r\n}\r\nstatic u8 read_zsreg(struct zs_port *zport, int reg)\r\n{\r\nvoid __iomem *control = zport->port.membase + ZS_CHAN_IO_OFFSET;\r\nu8 retval;\r\nif (reg != 0) {\r\nwriteb(reg & 0xf, control);\r\nfast_iob();\r\nrecovery_delay();\r\n}\r\nretval = readb(control);\r\nrecovery_delay();\r\nreturn retval;\r\n}\r\nstatic void write_zsreg(struct zs_port *zport, int reg, u8 value)\r\n{\r\nvoid __iomem *control = zport->port.membase + ZS_CHAN_IO_OFFSET;\r\nif (reg != 0) {\r\nwriteb(reg & 0xf, control);\r\nfast_iob(); recovery_delay();\r\n}\r\nwriteb(value, control);\r\nfast_iob();\r\nrecovery_delay();\r\nreturn;\r\n}\r\nstatic u8 read_zsdata(struct zs_port *zport)\r\n{\r\nvoid __iomem *data = zport->port.membase +\r\nZS_CHAN_IO_STRIDE + ZS_CHAN_IO_OFFSET;\r\nu8 retval;\r\nretval = readb(data);\r\nrecovery_delay();\r\nreturn retval;\r\n}\r\nstatic void write_zsdata(struct zs_port *zport, u8 value)\r\n{\r\nvoid __iomem *data = zport->port.membase +\r\nZS_CHAN_IO_STRIDE + ZS_CHAN_IO_OFFSET;\r\nwriteb(value, data);\r\nfast_iob();\r\nrecovery_delay();\r\nreturn;\r\n}\r\nvoid zs_dump(void)\r\n{\r\nstruct zs_port *zport;\r\nint i, j;\r\nfor (i = 0; i < ZS_NUM_SCCS * ZS_NUM_CHAN; i++) {\r\nzport = &zs_sccs[i / ZS_NUM_CHAN].zport[i % ZS_NUM_CHAN];\r\nif (!zport->scc)\r\ncontinue;\r\nfor (j = 0; j < 16; j++)\r\nprintk("W%-2d = 0x%02x\t", j, zport->regs[j]);\r\nprintk("\n");\r\nfor (j = 0; j < 16; j++)\r\nprintk("R%-2d = 0x%02x\t", j, read_zsreg(zport, j));\r\nprintk("\n\n");\r\n}\r\n}\r\nstatic void zs_spin_lock_cond_irq(spinlock_t *lock, int irq)\r\n{\r\nif (irq)\r\nspin_lock_irq(lock);\r\nelse\r\nspin_lock(lock);\r\n}\r\nstatic void zs_spin_unlock_cond_irq(spinlock_t *lock, int irq)\r\n{\r\nif (irq)\r\nspin_unlock_irq(lock);\r\nelse\r\nspin_unlock(lock);\r\n}\r\nstatic int zs_receive_drain(struct zs_port *zport)\r\n{\r\nint loops = 10000;\r\nwhile ((read_zsreg(zport, R0) & Rx_CH_AV) && --loops)\r\nread_zsdata(zport);\r\nreturn loops;\r\n}\r\nstatic int zs_transmit_drain(struct zs_port *zport, int irq)\r\n{\r\nstruct zs_scc *scc = zport->scc;\r\nint loops = 10000;\r\nwhile (!(read_zsreg(zport, R0) & Tx_BUF_EMP) && --loops) {\r\nzs_spin_unlock_cond_irq(&scc->zlock, irq);\r\nudelay(2);\r\nzs_spin_lock_cond_irq(&scc->zlock, irq);\r\n}\r\nreturn loops;\r\n}\r\nstatic int zs_line_drain(struct zs_port *zport, int irq)\r\n{\r\nstruct zs_scc *scc = zport->scc;\r\nint loops = 10000;\r\nwhile (!(read_zsreg(zport, R1) & ALL_SNT) && --loops) {\r\nzs_spin_unlock_cond_irq(&scc->zlock, irq);\r\nudelay(2);\r\nzs_spin_lock_cond_irq(&scc->zlock, irq);\r\n}\r\nreturn loops;\r\n}\r\nstatic void load_zsregs(struct zs_port *zport, u8 *regs, int irq)\r\n{\r\nzs_line_drain(zport, irq);\r\nwrite_zsreg(zport, R3, regs[3] & ~RxENABLE);\r\nwrite_zsreg(zport, R5, regs[5] & ~TxENAB);\r\nwrite_zsreg(zport, R4, regs[4]);\r\nwrite_zsreg(zport, R9, regs[9]);\r\nwrite_zsreg(zport, R1, regs[1]);\r\nwrite_zsreg(zport, R2, regs[2]);\r\nwrite_zsreg(zport, R10, regs[10]);\r\nwrite_zsreg(zport, R14, regs[14] & ~BRENABL);\r\nwrite_zsreg(zport, R11, regs[11]);\r\nwrite_zsreg(zport, R12, regs[12]);\r\nwrite_zsreg(zport, R13, regs[13]);\r\nwrite_zsreg(zport, R14, regs[14]);\r\nwrite_zsreg(zport, R15, regs[15]);\r\nif (regs[3] & RxENABLE)\r\nwrite_zsreg(zport, R3, regs[3]);\r\nif (regs[5] & TxENAB)\r\nwrite_zsreg(zport, R5, regs[5]);\r\nreturn;\r\n}\r\nstatic unsigned int zs_tx_empty(struct uart_port *uport)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nunsigned long flags;\r\nu8 status;\r\nspin_lock_irqsave(&scc->zlock, flags);\r\nstatus = read_zsreg(zport, R1);\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\nreturn status & ALL_SNT ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int zs_raw_get_ab_mctrl(struct zs_port *zport_a,\r\nstruct zs_port *zport_b)\r\n{\r\nu8 status_a, status_b;\r\nunsigned int mctrl;\r\nstatus_a = read_zsreg(zport_a, R0);\r\nstatus_b = read_zsreg(zport_b, R0);\r\nmctrl = ((status_b & CTS) ? TIOCM_CTS : 0) |\r\n((status_b & DCD) ? TIOCM_CAR : 0) |\r\n((status_a & DCD) ? TIOCM_RNG : 0) |\r\n((status_a & SYNC_HUNT) ? TIOCM_DSR : 0);\r\nreturn mctrl;\r\n}\r\nstatic unsigned int zs_raw_get_mctrl(struct zs_port *zport)\r\n{\r\nstruct zs_port *zport_a = &zport->scc->zport[ZS_CHAN_A];\r\nreturn zport != zport_a ? zs_raw_get_ab_mctrl(zport_a, zport) : 0;\r\n}\r\nstatic unsigned int zs_raw_xor_mctrl(struct zs_port *zport)\r\n{\r\nstruct zs_port *zport_a = &zport->scc->zport[ZS_CHAN_A];\r\nunsigned int mmask, mctrl, delta;\r\nu8 mask_a, mask_b;\r\nif (zport == zport_a)\r\nreturn 0;\r\nmask_a = zport_a->regs[15];\r\nmask_b = zport->regs[15];\r\nmmask = ((mask_b & CTSIE) ? TIOCM_CTS : 0) |\r\n((mask_b & DCDIE) ? TIOCM_CAR : 0) |\r\n((mask_a & DCDIE) ? TIOCM_RNG : 0) |\r\n((mask_a & SYNCIE) ? TIOCM_DSR : 0);\r\nmctrl = zport->mctrl;\r\nif (mmask) {\r\nmctrl &= ~mmask;\r\nmctrl |= zs_raw_get_ab_mctrl(zport_a, zport) & mmask;\r\n}\r\ndelta = mctrl ^ zport->mctrl;\r\nif (delta)\r\nzport->mctrl = mctrl;\r\nreturn delta;\r\n}\r\nstatic unsigned int zs_get_mctrl(struct uart_port *uport)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nunsigned int mctrl;\r\nspin_lock(&scc->zlock);\r\nmctrl = zs_raw_get_mctrl(zport);\r\nspin_unlock(&scc->zlock);\r\nreturn mctrl;\r\n}\r\nstatic void zs_set_mctrl(struct uart_port *uport, unsigned int mctrl)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\r\nu8 oldloop, newloop;\r\nspin_lock(&scc->zlock);\r\nif (zport != zport_a) {\r\nif (mctrl & TIOCM_DTR)\r\nzport_a->regs[5] |= DTR;\r\nelse\r\nzport_a->regs[5] &= ~DTR;\r\nif (mctrl & TIOCM_RTS)\r\nzport_a->regs[5] |= RTS;\r\nelse\r\nzport_a->regs[5] &= ~RTS;\r\nwrite_zsreg(zport_a, R5, zport_a->regs[5]);\r\n}\r\noldloop = zport->regs[14];\r\nnewloop = oldloop;\r\nif (mctrl & TIOCM_LOOP)\r\nnewloop |= LOOPBAK;\r\nelse\r\nnewloop &= ~LOOPBAK;\r\nif (newloop != oldloop) {\r\nzport->regs[14] = newloop;\r\nwrite_zsreg(zport, R14, zport->regs[14]);\r\n}\r\nspin_unlock(&scc->zlock);\r\n}\r\nstatic void zs_raw_stop_tx(struct zs_port *zport)\r\n{\r\nwrite_zsreg(zport, R0, RES_Tx_P);\r\nzport->tx_stopped = 1;\r\n}\r\nstatic void zs_stop_tx(struct uart_port *uport)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nspin_lock(&scc->zlock);\r\nzs_raw_stop_tx(zport);\r\nspin_unlock(&scc->zlock);\r\n}\r\nstatic void zs_start_tx(struct uart_port *uport)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nspin_lock(&scc->zlock);\r\nif (zport->tx_stopped) {\r\nzs_transmit_drain(zport, 0);\r\nzport->tx_stopped = 0;\r\nzs_raw_transmit_chars(zport);\r\n}\r\nspin_unlock(&scc->zlock);\r\n}\r\nstatic void zs_stop_rx(struct uart_port *uport)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\r\nspin_lock(&scc->zlock);\r\nzport->regs[15] &= ~BRKIE;\r\nzport->regs[1] &= ~(RxINT_MASK | TxINT_ENAB);\r\nzport->regs[1] |= RxINT_DISAB;\r\nif (zport != zport_a) {\r\nzport_a->regs[15] &= ~(DCDIE | SYNCIE);\r\nwrite_zsreg(zport_a, R15, zport_a->regs[15]);\r\nif (!(zport_a->regs[15] & BRKIE)) {\r\nzport_a->regs[1] &= ~EXT_INT_ENAB;\r\nwrite_zsreg(zport_a, R1, zport_a->regs[1]);\r\n}\r\nzport->regs[15] &= ~(DCDIE | CTSIE);\r\nzport->regs[1] &= ~EXT_INT_ENAB;\r\n} else {\r\nif (!(zport->regs[15] & (DCDIE | SYNCIE)))\r\nzport->regs[1] &= ~EXT_INT_ENAB;\r\n}\r\nwrite_zsreg(zport, R15, zport->regs[15]);\r\nwrite_zsreg(zport, R1, zport->regs[1]);\r\nspin_unlock(&scc->zlock);\r\n}\r\nstatic void zs_enable_ms(struct uart_port *uport)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\r\nif (zport == zport_a)\r\nreturn;\r\nspin_lock(&scc->zlock);\r\nif (!(zport_a->regs[1] & EXT_INT_ENAB))\r\nwrite_zsreg(zport_a, R0, RES_EXT_INT);\r\nzport_a->regs[1] |= EXT_INT_ENAB;\r\nzport_a->regs[15] |= DCDIE | SYNCIE;\r\nzport->regs[15] |= DCDIE | CTSIE;\r\nzs_raw_xor_mctrl(zport);\r\nwrite_zsreg(zport_a, R1, zport_a->regs[1]);\r\nwrite_zsreg(zport_a, R15, zport_a->regs[15]);\r\nwrite_zsreg(zport, R15, zport->regs[15]);\r\nspin_unlock(&scc->zlock);\r\n}\r\nstatic void zs_break_ctl(struct uart_port *uport, int break_state)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->zlock, flags);\r\nif (break_state == -1)\r\nzport->regs[5] |= SND_BRK;\r\nelse\r\nzport->regs[5] &= ~SND_BRK;\r\nwrite_zsreg(zport, R5, zport->regs[5]);\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\n}\r\nstatic void zs_receive_chars(struct zs_port *zport)\r\n{\r\nstruct uart_port *uport = &zport->port;\r\nstruct zs_scc *scc = zport->scc;\r\nstruct uart_icount *icount;\r\nunsigned int avail, status, ch, flag;\r\nint count;\r\nfor (count = 16; count; count--) {\r\nspin_lock(&scc->zlock);\r\navail = read_zsreg(zport, R0) & Rx_CH_AV;\r\nspin_unlock(&scc->zlock);\r\nif (!avail)\r\nbreak;\r\nspin_lock(&scc->zlock);\r\nstatus = read_zsreg(zport, R1) & (Rx_OVR | FRM_ERR | PAR_ERR);\r\nch = read_zsdata(zport);\r\nspin_unlock(&scc->zlock);\r\nflag = TTY_NORMAL;\r\nicount = &uport->icount;\r\nicount->rx++;\r\nif (!ch)\r\nstatus |= zport->tty_break;\r\nif (unlikely(status &\r\n(Rx_OVR | FRM_ERR | PAR_ERR | Rx_SYS | Rx_BRK))) {\r\nzport->tty_break = 0;\r\nif (status & (Rx_OVR | FRM_ERR | PAR_ERR)) {\r\nspin_lock(&scc->zlock);\r\nwrite_zsreg(zport, R0, ERR_RES);\r\nspin_unlock(&scc->zlock);\r\n}\r\nif (status & (Rx_SYS | Rx_BRK)) {\r\nicount->brk++;\r\nif (status & Rx_SYS)\r\ncontinue;\r\n} else if (status & FRM_ERR)\r\nicount->frame++;\r\nelse if (status & PAR_ERR)\r\nicount->parity++;\r\nif (status & Rx_OVR)\r\nicount->overrun++;\r\nstatus &= uport->read_status_mask;\r\nif (status & Rx_BRK)\r\nflag = TTY_BREAK;\r\nelse if (status & FRM_ERR)\r\nflag = TTY_FRAME;\r\nelse if (status & PAR_ERR)\r\nflag = TTY_PARITY;\r\n}\r\nif (uart_handle_sysrq_char(uport, ch))\r\ncontinue;\r\nuart_insert_char(uport, status, Rx_OVR, ch, flag);\r\n}\r\ntty_flip_buffer_push(uport->state->port.tty);\r\n}\r\nstatic void zs_raw_transmit_chars(struct zs_port *zport)\r\n{\r\nstruct circ_buf *xmit = &zport->port.state->xmit;\r\nif (zport->port.x_char) {\r\nwrite_zsdata(zport, zport->port.x_char);\r\nzport->port.icount.tx++;\r\nzport->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&zport->port)) {\r\nzs_raw_stop_tx(zport);\r\nreturn;\r\n}\r\nwrite_zsdata(zport, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nzport->port.icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&zport->port);\r\nif (uart_circ_empty(xmit))\r\nzs_raw_stop_tx(zport);\r\n}\r\nstatic void zs_transmit_chars(struct zs_port *zport)\r\n{\r\nstruct zs_scc *scc = zport->scc;\r\nspin_lock(&scc->zlock);\r\nzs_raw_transmit_chars(zport);\r\nspin_unlock(&scc->zlock);\r\n}\r\nstatic void zs_status_handle(struct zs_port *zport, struct zs_port *zport_a)\r\n{\r\nstruct uart_port *uport = &zport->port;\r\nstruct zs_scc *scc = zport->scc;\r\nunsigned int delta;\r\nu8 status, brk;\r\nspin_lock(&scc->zlock);\r\nstatus = read_zsreg(zport, R0);\r\nif (zport->regs[15] & BRKIE) {\r\nbrk = status & BRK_ABRT;\r\nif (brk && !zport->brk) {\r\nspin_unlock(&scc->zlock);\r\nif (uart_handle_break(uport))\r\nzport->tty_break = Rx_SYS;\r\nelse\r\nzport->tty_break = Rx_BRK;\r\nspin_lock(&scc->zlock);\r\n}\r\nzport->brk = brk;\r\n}\r\nif (zport != zport_a) {\r\ndelta = zs_raw_xor_mctrl(zport);\r\nspin_unlock(&scc->zlock);\r\nif (delta & TIOCM_CTS)\r\nuart_handle_cts_change(uport,\r\nzport->mctrl & TIOCM_CTS);\r\nif (delta & TIOCM_CAR)\r\nuart_handle_dcd_change(uport,\r\nzport->mctrl & TIOCM_CAR);\r\nif (delta & TIOCM_RNG)\r\nuport->icount.dsr++;\r\nif (delta & TIOCM_DSR)\r\nuport->icount.rng++;\r\nif (delta)\r\nwake_up_interruptible(&uport->state->port.delta_msr_wait);\r\nspin_lock(&scc->zlock);\r\n}\r\nwrite_zsreg(zport, R0, RES_EXT_INT);\r\nspin_unlock(&scc->zlock);\r\n}\r\nstatic irqreturn_t zs_interrupt(int irq, void *dev_id)\r\n{\r\nstruct zs_scc *scc = dev_id;\r\nstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\r\nstruct zs_port *zport_b = &scc->zport[ZS_CHAN_B];\r\nirqreturn_t status = IRQ_NONE;\r\nu8 zs_intreg;\r\nint count;\r\nfor (count = 16; count; count--) {\r\nspin_lock(&scc->zlock);\r\nzs_intreg = read_zsreg(zport_a, R3);\r\nspin_unlock(&scc->zlock);\r\nif (!zs_intreg)\r\nbreak;\r\nif (zs_intreg & CHBRxIP)\r\nzs_receive_chars(zport_b);\r\nif (zs_intreg & CHARxIP)\r\nzs_receive_chars(zport_a);\r\nif (zs_intreg & CHBEXT)\r\nzs_status_handle(zport_b, zport_a);\r\nif (zs_intreg & CHAEXT)\r\nzs_status_handle(zport_a, zport_a);\r\nif (zs_intreg & CHBTxIP)\r\nzs_transmit_chars(zport_b);\r\nif (zs_intreg & CHATxIP)\r\nzs_transmit_chars(zport_a);\r\nstatus = IRQ_HANDLED;\r\n}\r\nreturn status;\r\n}\r\nstatic int zs_startup(struct uart_port *uport)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nunsigned long flags;\r\nint irq_guard;\r\nint ret;\r\nirq_guard = atomic_add_return(1, &scc->irq_guard);\r\nif (irq_guard == 1) {\r\nret = request_irq(zport->port.irq, zs_interrupt,\r\nIRQF_SHARED, "scc", scc);\r\nif (ret) {\r\natomic_add(-1, &scc->irq_guard);\r\nprintk(KERN_ERR "zs: can't get irq %d\n",\r\nzport->port.irq);\r\nreturn ret;\r\n}\r\n}\r\nspin_lock_irqsave(&scc->zlock, flags);\r\nzs_receive_drain(zport);\r\nwrite_zsreg(zport, R0, ERR_RES);\r\nwrite_zsreg(zport, R0, RES_Tx_P);\r\nif (!(zport->regs[1] & EXT_INT_ENAB))\r\nwrite_zsreg(zport, R0, RES_EXT_INT);\r\nzport->regs[1] &= ~RxINT_MASK;\r\nzport->regs[1] |= RxINT_ALL | TxINT_ENAB | EXT_INT_ENAB;\r\nzport->regs[3] |= RxENABLE;\r\nzport->regs[15] |= BRKIE;\r\nwrite_zsreg(zport, R1, zport->regs[1]);\r\nwrite_zsreg(zport, R3, zport->regs[3]);\r\nwrite_zsreg(zport, R5, zport->regs[5]);\r\nwrite_zsreg(zport, R15, zport->regs[15]);\r\nzport->mctrl = zs_raw_get_mctrl(zport);\r\nzport->brk = read_zsreg(zport, R0) & BRK_ABRT;\r\nzport->tx_stopped = 1;\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\nreturn 0;\r\n}\r\nstatic void zs_shutdown(struct uart_port *uport)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nunsigned long flags;\r\nint irq_guard;\r\nspin_lock_irqsave(&scc->zlock, flags);\r\nzport->regs[3] &= ~RxENABLE;\r\nwrite_zsreg(zport, R5, zport->regs[5]);\r\nwrite_zsreg(zport, R3, zport->regs[3]);\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\nirq_guard = atomic_add_return(-1, &scc->irq_guard);\r\nif (!irq_guard)\r\nfree_irq(zport->port.irq, scc);\r\n}\r\nstatic void zs_reset(struct zs_port *zport)\r\n{\r\nstruct zs_scc *scc = zport->scc;\r\nint irq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->zlock, flags);\r\nirq = !irqs_disabled_flags(flags);\r\nif (!scc->initialised) {\r\nread_zsreg(zport, R0);\r\nzs_line_drain(zport, irq);\r\nwrite_zsreg(zport, R9, FHWRES);\r\nudelay(10);\r\nwrite_zsreg(zport, R9, 0);\r\nscc->initialised = 1;\r\n}\r\nload_zsregs(zport, zport->regs, irq);\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\n}\r\nstatic void zs_set_termios(struct uart_port *uport, struct ktermios *termios,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nstruct zs_port *zport_a = &scc->zport[ZS_CHAN_A];\r\nint irq;\r\nunsigned int baud, brg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->zlock, flags);\r\nirq = !irqs_disabled_flags(flags);\r\nzport->regs[3] &= ~RxNBITS_MASK;\r\nzport->regs[5] &= ~TxNBITS_MASK;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nzport->regs[3] |= Rx5;\r\nzport->regs[5] |= Tx5;\r\nbreak;\r\ncase CS6:\r\nzport->regs[3] |= Rx6;\r\nzport->regs[5] |= Tx6;\r\nbreak;\r\ncase CS7:\r\nzport->regs[3] |= Rx7;\r\nzport->regs[5] |= Tx7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nzport->regs[3] |= Rx8;\r\nzport->regs[5] |= Tx8;\r\nbreak;\r\n}\r\nzport->regs[4] &= ~(XCLK_MASK | SB_MASK | PAR_ENA | PAR_EVEN);\r\nif (termios->c_cflag & CSTOPB)\r\nzport->regs[4] |= SB2;\r\nelse\r\nzport->regs[4] |= SB1;\r\nif (termios->c_cflag & PARENB)\r\nzport->regs[4] |= PAR_ENA;\r\nif (!(termios->c_cflag & PARODD))\r\nzport->regs[4] |= PAR_EVEN;\r\nswitch (zport->clk_mode) {\r\ncase 64:\r\nzport->regs[4] |= X64CLK;\r\nbreak;\r\ncase 32:\r\nzport->regs[4] |= X32CLK;\r\nbreak;\r\ncase 16:\r\nzport->regs[4] |= X16CLK;\r\nbreak;\r\ncase 1:\r\nzport->regs[4] |= X1CLK;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbaud = uart_get_baud_rate(uport, termios, old_termios, 0,\r\nuport->uartclk / zport->clk_mode / 4);\r\nbrg = ZS_BPS_TO_BRG(baud, uport->uartclk / zport->clk_mode);\r\nzport->regs[12] = brg & 0xff;\r\nzport->regs[13] = (brg >> 8) & 0xff;\r\nuart_update_timeout(uport, termios->c_cflag, baud);\r\nuport->read_status_mask = Rx_OVR;\r\nif (termios->c_iflag & INPCK)\r\nuport->read_status_mask |= FRM_ERR | PAR_ERR;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nuport->read_status_mask |= Rx_BRK;\r\nuport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nuport->ignore_status_mask |= FRM_ERR | PAR_ERR;\r\nif (termios->c_iflag & IGNBRK) {\r\nuport->ignore_status_mask |= Rx_BRK;\r\nif (termios->c_iflag & IGNPAR)\r\nuport->ignore_status_mask |= Rx_OVR;\r\n}\r\nif (termios->c_cflag & CREAD)\r\nzport->regs[3] |= RxENABLE;\r\nelse\r\nzport->regs[3] &= ~RxENABLE;\r\nif (zport != zport_a) {\r\nif (!(termios->c_cflag & CLOCAL)) {\r\nzport->regs[15] |= DCDIE;\r\n} else\r\nzport->regs[15] &= ~DCDIE;\r\nif (termios->c_cflag & CRTSCTS) {\r\nzport->regs[15] |= CTSIE;\r\n} else\r\nzport->regs[15] &= ~CTSIE;\r\nzs_raw_xor_mctrl(zport);\r\n}\r\nload_zsregs(zport, zport->regs, irq);\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\n}\r\nstatic void zs_pm(struct uart_port *uport, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nif (state < 3)\r\nzport->regs[5] |= TxENAB;\r\nelse\r\nzport->regs[5] &= ~TxENAB;\r\nwrite_zsreg(zport, R5, zport->regs[5]);\r\n}\r\nstatic const char *zs_type(struct uart_port *uport)\r\n{\r\nreturn "Z85C30 SCC";\r\n}\r\nstatic void zs_release_port(struct uart_port *uport)\r\n{\r\niounmap(uport->membase);\r\nuport->membase = 0;\r\nrelease_mem_region(uport->mapbase, ZS_CHAN_IO_SIZE);\r\n}\r\nstatic int zs_map_port(struct uart_port *uport)\r\n{\r\nif (!uport->membase)\r\nuport->membase = ioremap_nocache(uport->mapbase,\r\nZS_CHAN_IO_SIZE);\r\nif (!uport->membase) {\r\nprintk(KERN_ERR "zs: Cannot map MMIO\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zs_request_port(struct uart_port *uport)\r\n{\r\nint ret;\r\nif (!request_mem_region(uport->mapbase, ZS_CHAN_IO_SIZE, "scc")) {\r\nprintk(KERN_ERR "zs: Unable to reserve MMIO resource\n");\r\nreturn -EBUSY;\r\n}\r\nret = zs_map_port(uport);\r\nif (ret) {\r\nrelease_mem_region(uport->mapbase, ZS_CHAN_IO_SIZE);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void zs_config_port(struct uart_port *uport, int flags)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nif (flags & UART_CONFIG_TYPE) {\r\nif (zs_request_port(uport))\r\nreturn;\r\nuport->type = PORT_ZS;\r\nzs_reset(zport);\r\n}\r\n}\r\nstatic int zs_verify_port(struct uart_port *uport, struct serial_struct *ser)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_ZS)\r\nret = -EINVAL;\r\nif (ser->irq != uport->irq)\r\nret = -EINVAL;\r\nif (ser->baud_base != uport->uartclk / zport->clk_mode / 4)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int __init zs_probe_sccs(void)\r\n{\r\nstatic int probed;\r\nstruct zs_parms zs_parms;\r\nint chip, side, irq;\r\nint n_chips = 0;\r\nint i;\r\nif (probed)\r\nreturn 0;\r\nirq = dec_interrupt[DEC_IRQ_SCC0];\r\nif (irq >= 0) {\r\nzs_parms.scc[n_chips] = IOASIC_SCC0;\r\nzs_parms.irq[n_chips] = dec_interrupt[DEC_IRQ_SCC0];\r\nn_chips++;\r\n}\r\nirq = dec_interrupt[DEC_IRQ_SCC1];\r\nif (irq >= 0) {\r\nzs_parms.scc[n_chips] = IOASIC_SCC1;\r\nzs_parms.irq[n_chips] = dec_interrupt[DEC_IRQ_SCC1];\r\nn_chips++;\r\n}\r\nif (!n_chips)\r\nreturn -ENXIO;\r\nprobed = 1;\r\nfor (chip = 0; chip < n_chips; chip++) {\r\nspin_lock_init(&zs_sccs[chip].zlock);\r\nfor (side = 0; side < ZS_NUM_CHAN; side++) {\r\nstruct zs_port *zport = &zs_sccs[chip].zport[side];\r\nstruct uart_port *uport = &zport->port;\r\nzport->scc = &zs_sccs[chip];\r\nzport->clk_mode = 16;\r\nuport->irq = zs_parms.irq[chip];\r\nuport->uartclk = ZS_CLOCK;\r\nuport->fifosize = 1;\r\nuport->iotype = UPIO_MEM;\r\nuport->flags = UPF_BOOT_AUTOCONF;\r\nuport->ops = &zs_ops;\r\nuport->line = chip * ZS_NUM_CHAN + side;\r\nuport->mapbase = dec_kn_slot_base +\r\nzs_parms.scc[chip] +\r\n(side ^ ZS_CHAN_B) * ZS_CHAN_IO_SIZE;\r\nfor (i = 0; i < ZS_NUM_REGS; i++)\r\nzport->regs[i] = zs_init_regs[i];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void zs_console_putchar(struct uart_port *uport, int ch)\r\n{\r\nstruct zs_port *zport = to_zport(uport);\r\nstruct zs_scc *scc = zport->scc;\r\nint irq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&scc->zlock, flags);\r\nirq = !irqs_disabled_flags(flags);\r\nif (zs_transmit_drain(zport, irq))\r\nwrite_zsdata(zport, ch);\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\n}\r\nstatic void zs_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nint chip = co->index / ZS_NUM_CHAN, side = co->index % ZS_NUM_CHAN;\r\nstruct zs_port *zport = &zs_sccs[chip].zport[side];\r\nstruct zs_scc *scc = zport->scc;\r\nunsigned long flags;\r\nu8 txint, txenb;\r\nint irq;\r\nspin_lock_irqsave(&scc->zlock, flags);\r\ntxint = zport->regs[1];\r\ntxenb = zport->regs[5];\r\nif (txint & TxINT_ENAB) {\r\nzport->regs[1] = txint & ~TxINT_ENAB;\r\nwrite_zsreg(zport, R1, zport->regs[1]);\r\n}\r\nif (!(txenb & TxENAB)) {\r\nzport->regs[5] = txenb | TxENAB;\r\nwrite_zsreg(zport, R5, zport->regs[5]);\r\n}\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\nuart_console_write(&zport->port, s, count, zs_console_putchar);\r\nspin_lock_irqsave(&scc->zlock, flags);\r\nirq = !irqs_disabled_flags(flags);\r\nzs_line_drain(zport, irq);\r\nif (!(txenb & TxENAB)) {\r\nzport->regs[5] &= ~TxENAB;\r\nwrite_zsreg(zport, R5, zport->regs[5]);\r\n}\r\nif (txint & TxINT_ENAB) {\r\nzport->regs[1] |= TxINT_ENAB;\r\nwrite_zsreg(zport, R1, zport->regs[1]);\r\n}\r\nspin_unlock_irqrestore(&scc->zlock, flags);\r\n}\r\nstatic int __init zs_console_setup(struct console *co, char *options)\r\n{\r\nint chip = co->index / ZS_NUM_CHAN, side = co->index % ZS_NUM_CHAN;\r\nstruct zs_port *zport = &zs_sccs[chip].zport[side];\r\nstruct uart_port *uport = &zport->port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nret = zs_map_port(uport);\r\nif (ret)\r\nreturn ret;\r\nzs_reset(zport);\r\nzs_pm(uport, 0, -1);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(uport, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init zs_serial_console_init(void)\r\n{\r\nint ret;\r\nret = zs_probe_sccs();\r\nif (ret)\r\nreturn ret;\r\nregister_console(&zs_console);\r\nreturn 0;\r\n}\r\nstatic int __init zs_init(void)\r\n{\r\nint i, ret;\r\npr_info("%s%s\n", zs_name, zs_version);\r\nret = zs_probe_sccs();\r\nif (ret)\r\nreturn ret;\r\nret = uart_register_driver(&zs_reg);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ZS_NUM_SCCS * ZS_NUM_CHAN; i++) {\r\nstruct zs_scc *scc = &zs_sccs[i / ZS_NUM_CHAN];\r\nstruct zs_port *zport = &scc->zport[i % ZS_NUM_CHAN];\r\nstruct uart_port *uport = &zport->port;\r\nif (zport->scc)\r\nuart_add_one_port(&zs_reg, uport);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit zs_exit(void)\r\n{\r\nint i;\r\nfor (i = ZS_NUM_SCCS * ZS_NUM_CHAN - 1; i >= 0; i--) {\r\nstruct zs_scc *scc = &zs_sccs[i / ZS_NUM_CHAN];\r\nstruct zs_port *zport = &scc->zport[i % ZS_NUM_CHAN];\r\nstruct uart_port *uport = &zport->port;\r\nif (zport->scc)\r\nuart_remove_one_port(&zs_reg, uport);\r\n}\r\nuart_unregister_driver(&zs_reg);\r\n}
