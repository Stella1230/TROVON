static int erst_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nint rc, *pos;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\npos = (int *)&file->private_data;\r\nrc = erst_get_record_id_begin(pos);\r\nif (rc)\r\nreturn rc;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int erst_dbg_release(struct inode *inode, struct file *file)\r\n{\r\nerst_get_record_id_end();\r\nreturn 0;\r\n}\r\nstatic long erst_dbg_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\r\n{\r\nint rc;\r\nu64 record_id;\r\nu32 record_count;\r\nswitch (cmd) {\r\ncase APEI_ERST_CLEAR_RECORD:\r\nrc = copy_from_user(&record_id, (void __user *)arg,\r\nsizeof(record_id));\r\nif (rc)\r\nreturn -EFAULT;\r\nreturn erst_clear(record_id);\r\ncase APEI_ERST_GET_RECORD_COUNT:\r\nrc = erst_get_record_count();\r\nif (rc < 0)\r\nreturn rc;\r\nrecord_count = rc;\r\nrc = put_user(record_count, (u32 __user *)arg);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic ssize_t erst_dbg_read(struct file *filp, char __user *ubuf,\r\nsize_t usize, loff_t *off)\r\n{\r\nint rc, *pos;\r\nssize_t len = 0;\r\nu64 id;\r\nif (*off)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&erst_dbg_mutex) != 0)\r\nreturn -EINTR;\r\npos = (int *)&filp->private_data;\r\nretry_next:\r\nrc = erst_get_record_id_next(pos, &id);\r\nif (rc)\r\ngoto out;\r\nif (id == APEI_ERST_INVALID_RECORD_ID)\r\ngoto out;\r\nretry:\r\nrc = len = erst_read(id, erst_dbg_buf, erst_dbg_buf_len);\r\nif (rc == -ENOENT)\r\ngoto retry_next;\r\nif (rc < 0)\r\ngoto out;\r\nif (len > ERST_DBG_RECORD_LEN_MAX) {\r\npr_warning(ERST_DBG_PFX\r\n"Record (ID: 0x%llx) length is too long: %zd\n",\r\nid, len);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif (len > erst_dbg_buf_len) {\r\nvoid *p;\r\nrc = -ENOMEM;\r\np = kmalloc(len, GFP_KERNEL);\r\nif (!p)\r\ngoto out;\r\nkfree(erst_dbg_buf);\r\nerst_dbg_buf = p;\r\nerst_dbg_buf_len = len;\r\ngoto retry;\r\n}\r\nrc = -EINVAL;\r\nif (len > usize)\r\ngoto out;\r\nrc = -EFAULT;\r\nif (copy_to_user(ubuf, erst_dbg_buf, len))\r\ngoto out;\r\nrc = 0;\r\nout:\r\nmutex_unlock(&erst_dbg_mutex);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t erst_dbg_write(struct file *filp, const char __user *ubuf,\r\nsize_t usize, loff_t *off)\r\n{\r\nint rc;\r\nstruct cper_record_header *rcd;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (usize > ERST_DBG_RECORD_LEN_MAX) {\r\npr_err(ERST_DBG_PFX "Too long record to be written\n");\r\nreturn -EINVAL;\r\n}\r\nif (mutex_lock_interruptible(&erst_dbg_mutex))\r\nreturn -EINTR;\r\nif (usize > erst_dbg_buf_len) {\r\nvoid *p;\r\nrc = -ENOMEM;\r\np = kmalloc(usize, GFP_KERNEL);\r\nif (!p)\r\ngoto out;\r\nkfree(erst_dbg_buf);\r\nerst_dbg_buf = p;\r\nerst_dbg_buf_len = usize;\r\n}\r\nrc = copy_from_user(erst_dbg_buf, ubuf, usize);\r\nif (rc) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nrcd = erst_dbg_buf;\r\nrc = -EINVAL;\r\nif (rcd->record_length != usize)\r\ngoto out;\r\nrc = erst_write(erst_dbg_buf);\r\nout:\r\nmutex_unlock(&erst_dbg_mutex);\r\nreturn rc < 0 ? rc : usize;\r\n}\r\nstatic __init int erst_dbg_init(void)\r\n{\r\nif (erst_disable) {\r\npr_info(ERST_DBG_PFX "ERST support is disabled.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn misc_register(&erst_dbg_dev);\r\n}\r\nstatic __exit void erst_dbg_exit(void)\r\n{\r\nmisc_deregister(&erst_dbg_dev);\r\nkfree(erst_dbg_buf);\r\n}
