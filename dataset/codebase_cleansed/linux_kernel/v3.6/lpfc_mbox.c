int\r\nlpfc_dump_static_vport(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb,\r\nuint16_t offset)\r\n{\r\nMAILBOX_t *mb;\r\nstruct lpfc_dmabuf *mp;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_DUMP_MEMORY;\r\nmb->un.varDmp.type = DMP_NV_PARAMS;\r\nmb->un.varDmp.entry_index = offset;\r\nmb->un.varDmp.region_id = DMP_REGION_VPORT;\r\nmb->mbxOwner = OWN_HOST;\r\nif (phba->sli_rev != LPFC_SLI_REV4) {\r\nmb->un.varDmp.cv = 1;\r\nmb->un.varDmp.word_cnt = DMP_RSP_SIZE/sizeof(uint32_t);\r\nreturn 0;\r\n}\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (mp)\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\r\nif (!mp || !mp->virt) {\r\nkfree(mp);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\r\n"2605 lpfc_dump_static_vport: memory"\r\n" allocation failed\n");\r\nreturn 1;\r\n}\r\nmemset(mp->virt, 0, LPFC_BPL_SIZE);\r\nINIT_LIST_HEAD(&mp->list);\r\npmb->context2 = (uint8_t *) mp;\r\nmb->un.varWords[3] = putPaddrLow(mp->phys);\r\nmb->un.varWords[4] = putPaddrHigh(mp->phys);\r\nmb->un.varDmp.sli4_length = sizeof(struct static_vport_info);\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_down_link(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t *mb;\r\nmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\r\nmb = &pmb->u.mb;\r\nmb->mbxCommand = MBX_DOWN_LINK;\r\nmb->mbxOwner = OWN_HOST;\r\n}\r\nvoid\r\nlpfc_dump_mem(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb, uint16_t offset,\r\nuint16_t region_id)\r\n{\r\nMAILBOX_t *mb;\r\nvoid *ctx;\r\nmb = &pmb->u.mb;\r\nctx = pmb->context2;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_DUMP_MEMORY;\r\nmb->un.varDmp.cv = 1;\r\nmb->un.varDmp.type = DMP_NV_PARAMS;\r\nmb->un.varDmp.entry_index = offset;\r\nmb->un.varDmp.region_id = region_id;\r\nmb->un.varDmp.word_cnt = (DMP_RSP_SIZE / sizeof (uint32_t));\r\nmb->un.varDmp.co = 0;\r\nmb->un.varDmp.resp_offset = 0;\r\npmb->context2 = ctx;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_dump_wakeup_param(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t *mb;\r\nvoid *ctx;\r\nmb = &pmb->u.mb;\r\nctx = pmb->context2;\r\nmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_DUMP_MEMORY;\r\nmb->mbxOwner = OWN_HOST;\r\nmb->un.varDmp.cv = 1;\r\nmb->un.varDmp.type = DMP_NV_PARAMS;\r\nmb->un.varDmp.entry_index = 0;\r\nmb->un.varDmp.region_id = WAKE_UP_PARMS_REGION_ID;\r\nmb->un.varDmp.word_cnt = WAKE_UP_PARMS_WORD_SIZE;\r\nmb->un.varDmp.co = 0;\r\nmb->un.varDmp.resp_offset = 0;\r\npmb->context2 = ctx;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_read_nv(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_READ_NV;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_config_async(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb,\r\nuint32_t ring)\r\n{\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_ASYNCEVT_ENABLE;\r\nmb->un.varCfgAsyncEvent.ring = ring;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_heart_beat(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_HEARTBEAT;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nint\r\nlpfc_read_topology(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb,\r\nstruct lpfc_dmabuf *mp)\r\n{\r\nMAILBOX_t *mb;\r\nstruct lpfc_sli *psli;\r\npsli = &phba->sli;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nINIT_LIST_HEAD(&mp->list);\r\nmb->mbxCommand = MBX_READ_TOPOLOGY;\r\nmb->un.varReadTop.lilpBde64.tus.f.bdeSize = LPFC_ALPA_MAP_SIZE;\r\nmb->un.varReadTop.lilpBde64.addrHigh = putPaddrHigh(mp->phys);\r\nmb->un.varReadTop.lilpBde64.addrLow = putPaddrLow(mp->phys);\r\npmb->context1 = (uint8_t *)mp;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn (0);\r\n}\r\nvoid\r\nlpfc_clear_la(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->un.varClearLA.eventTag = phba->fc_eventTag;\r\nmb->mbxCommand = MBX_CLEAR_LA;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_config_link(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\r\n{\r\nstruct lpfc_vport *vport = phba->pport;\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nif (phba->cfg_cr_delay) {\r\nmb->un.varCfgLnk.cr = 1;\r\nmb->un.varCfgLnk.ci = 1;\r\nmb->un.varCfgLnk.cr_delay = phba->cfg_cr_delay;\r\nmb->un.varCfgLnk.cr_count = phba->cfg_cr_count;\r\n}\r\nmb->un.varCfgLnk.myId = vport->fc_myDID;\r\nmb->un.varCfgLnk.edtov = phba->fc_edtov;\r\nmb->un.varCfgLnk.arbtov = phba->fc_arbtov;\r\nmb->un.varCfgLnk.ratov = phba->fc_ratov;\r\nmb->un.varCfgLnk.rttov = phba->fc_rttov;\r\nmb->un.varCfgLnk.altov = phba->fc_altov;\r\nmb->un.varCfgLnk.crtov = phba->fc_crtov;\r\nmb->un.varCfgLnk.citov = phba->fc_citov;\r\nif (phba->cfg_ack0)\r\nmb->un.varCfgLnk.ack0_enable = 1;\r\nmb->mbxCommand = MBX_CONFIG_LINK;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nint\r\nlpfc_config_msi(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nuint32_t attentionConditions[2];\r\nif (phba->cfg_use_msi != 2) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0475 Not configured for supporting MSI-X "\r\n"cfg_use_msi: 0x%x\n", phba->cfg_use_msi);\r\nreturn -EINVAL;\r\n}\r\nif (phba->sli_rev < 3) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"0476 HBA not supporting SLI-3 or later "\r\n"SLI Revision: 0x%x\n", phba->sli_rev);\r\nreturn -EINVAL;\r\n}\r\nmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\r\nattentionConditions[0] = (HA_R0ATT | HA_R1ATT | HA_R2ATT | HA_ERATT |\r\nHA_LATT | HA_MBATT);\r\nattentionConditions[1] = 0;\r\nmb->un.varCfgMSI.attentionConditions[0] = attentionConditions[0];\r\nmb->un.varCfgMSI.attentionConditions[1] = attentionConditions[1];\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\nmb->un.varCfgMSI.messageNumberByHA[HA_R0_POS] = 1;\r\nmb->un.varCfgMSI.messageNumberByHA[HA_R1_POS] = 1;\r\n#else\r\nmb->un.varCfgMSI.messageNumberByHA[HA_R0_POS^3] = 1;\r\nmb->un.varCfgMSI.messageNumberByHA[HA_R1_POS^3] = 1;\r\n#endif\r\nmb->un.varCfgMSI.autoClearHA[0] = attentionConditions[0];\r\nmb->un.varCfgMSI.autoClearHA[1] = attentionConditions[1];\r\nmb->un.varCfgMSI.autoClearHA[0] = 0;\r\nmb->un.varCfgMSI.autoClearHA[1] = 0;\r\nmb->mbxCommand = MBX_CONFIG_MSI;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_init_link(struct lpfc_hba * phba,\r\nLPFC_MBOXQ_t * pmb, uint32_t topology, uint32_t linkspeed)\r\n{\r\nlpfc_vpd_t *vpd;\r\nstruct lpfc_sli *psli;\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\npsli = &phba->sli;\r\nswitch (topology) {\r\ncase FLAGS_TOPOLOGY_MODE_LOOP_PT:\r\nmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_LOOP;\r\nmb->un.varInitLnk.link_flags |= FLAGS_TOPOLOGY_FAILOVER;\r\nbreak;\r\ncase FLAGS_TOPOLOGY_MODE_PT_PT:\r\nmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_PT_PT;\r\nbreak;\r\ncase FLAGS_TOPOLOGY_MODE_LOOP:\r\nmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_LOOP;\r\nbreak;\r\ncase FLAGS_TOPOLOGY_MODE_PT_LOOP:\r\nmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_PT_PT;\r\nmb->un.varInitLnk.link_flags |= FLAGS_TOPOLOGY_FAILOVER;\r\nbreak;\r\ncase FLAGS_LOCAL_LB:\r\nmb->un.varInitLnk.link_flags = FLAGS_LOCAL_LB;\r\nbreak;\r\n}\r\nmb->un.varInitLnk.link_flags |= FLAGS_IMED_ABORT;\r\nvpd = &phba->vpd;\r\nif (vpd->rev.feaLevelHigh >= 0x02){\r\nswitch(linkspeed){\r\ncase LPFC_USER_LINK_SPEED_1G:\r\nmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\r\nmb->un.varInitLnk.link_speed = LINK_SPEED_1G;\r\nbreak;\r\ncase LPFC_USER_LINK_SPEED_2G:\r\nmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\r\nmb->un.varInitLnk.link_speed = LINK_SPEED_2G;\r\nbreak;\r\ncase LPFC_USER_LINK_SPEED_4G:\r\nmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\r\nmb->un.varInitLnk.link_speed = LINK_SPEED_4G;\r\nbreak;\r\ncase LPFC_USER_LINK_SPEED_8G:\r\nmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\r\nmb->un.varInitLnk.link_speed = LINK_SPEED_8G;\r\nbreak;\r\ncase LPFC_USER_LINK_SPEED_10G:\r\nmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\r\nmb->un.varInitLnk.link_speed = LINK_SPEED_10G;\r\nbreak;\r\ncase LPFC_USER_LINK_SPEED_16G:\r\nmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\r\nmb->un.varInitLnk.link_speed = LINK_SPEED_16G;\r\nbreak;\r\ncase LPFC_USER_LINK_SPEED_AUTO:\r\ndefault:\r\nmb->un.varInitLnk.link_speed = LINK_SPEED_AUTO;\r\nbreak;\r\n}\r\n}\r\nelse\r\nmb->un.varInitLnk.link_speed = LINK_SPEED_AUTO;\r\nmb->mbxCommand = (volatile uint8_t)MBX_INIT_LINK;\r\nmb->mbxOwner = OWN_HOST;\r\nmb->un.varInitLnk.fabric_AL_PA = phba->fc_pref_ALPA;\r\nreturn;\r\n}\r\nint\r\nlpfc_read_sparam(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb, int vpi)\r\n{\r\nstruct lpfc_dmabuf *mp;\r\nMAILBOX_t *mb;\r\nstruct lpfc_sli *psli;\r\npsli = &phba->sli;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->mbxOwner = OWN_HOST;\r\nmp = kmalloc(sizeof (struct lpfc_dmabuf), GFP_KERNEL);\r\nif (mp)\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\r\nif (!mp || !mp->virt) {\r\nkfree(mp);\r\nmb->mbxCommand = MBX_READ_SPARM64;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\r\n"0301 READ_SPARAM: no buffers\n");\r\nreturn (1);\r\n}\r\nINIT_LIST_HEAD(&mp->list);\r\nmb->mbxCommand = MBX_READ_SPARM64;\r\nmb->un.varRdSparm.un.sp64.tus.f.bdeSize = sizeof (struct serv_parm);\r\nmb->un.varRdSparm.un.sp64.addrHigh = putPaddrHigh(mp->phys);\r\nmb->un.varRdSparm.un.sp64.addrLow = putPaddrLow(mp->phys);\r\nif (phba->sli_rev >= LPFC_SLI_REV3)\r\nmb->un.varRdSparm.vpi = phba->vpi_ids[vpi];\r\npmb->context1 = mp;\r\nreturn (0);\r\n}\r\nvoid\r\nlpfc_unreg_did(struct lpfc_hba * phba, uint16_t vpi, uint32_t did,\r\nLPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->un.varUnregDID.did = did;\r\nmb->un.varUnregDID.vpi = vpi;\r\nif ((vpi != 0xffff) &&\r\n(phba->sli_rev == LPFC_SLI_REV4))\r\nmb->un.varUnregDID.vpi = phba->vpi_ids[vpi];\r\nmb->mbxCommand = MBX_UNREG_D_ID;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_read_config(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_READ_CONFIG;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_read_lnk_stat(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_READ_LNK_STAT;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nint\r\nlpfc_reg_rpi(struct lpfc_hba *phba, uint16_t vpi, uint32_t did,\r\nuint8_t *param, LPFC_MBOXQ_t *pmb, uint16_t rpi)\r\n{\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nuint8_t *sparam;\r\nstruct lpfc_dmabuf *mp;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->un.varRegLogin.rpi = 0;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nmb->un.varRegLogin.rpi = phba->sli4_hba.rpi_ids[rpi];\r\nif (phba->sli_rev >= LPFC_SLI_REV3)\r\nmb->un.varRegLogin.vpi = phba->vpi_ids[vpi];\r\nmb->un.varRegLogin.did = did;\r\nmb->mbxOwner = OWN_HOST;\r\nmp = kmalloc(sizeof (struct lpfc_dmabuf), GFP_KERNEL);\r\nif (mp)\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\r\nif (!mp || !mp->virt) {\r\nkfree(mp);\r\nmb->mbxCommand = MBX_REG_LOGIN64;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\r\n"0302 REG_LOGIN: no buffers, VPI:%d DID:x%x, "\r\n"rpi x%x\n", vpi, did, rpi);\r\nreturn 1;\r\n}\r\nINIT_LIST_HEAD(&mp->list);\r\nsparam = mp->virt;\r\nmemcpy(sparam, param, sizeof (struct serv_parm));\r\npmb->context1 = (uint8_t *) mp;\r\nmb->mbxCommand = MBX_REG_LOGIN64;\r\nmb->un.varRegLogin.un.sp64.tus.f.bdeSize = sizeof (struct serv_parm);\r\nmb->un.varRegLogin.un.sp64.addrHigh = putPaddrHigh(mp->phys);\r\nmb->un.varRegLogin.un.sp64.addrLow = putPaddrLow(mp->phys);\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_unreg_login(struct lpfc_hba *phba, uint16_t vpi, uint32_t rpi,\r\nLPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb;\r\nmb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->un.varUnregLogin.rpi = rpi;\r\nmb->un.varUnregLogin.rsvd1 = 0;\r\nif (phba->sli_rev >= LPFC_SLI_REV3)\r\nmb->un.varUnregLogin.vpi = phba->vpi_ids[vpi];\r\nmb->mbxCommand = MBX_UNREG_LOGIN;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_sli4_unreg_all_rpis(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nLPFC_MBOXQ_t *mbox;\r\nint rc;\r\nmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\r\nif (mbox) {\r\nlpfc_unreg_login(phba, vport->vpi, phba->vpi_ids[vport->vpi],\r\nmbox);\r\nmbox->u.mb.un.varUnregLogin.rsvd1 = 0x4000;\r\nmbox->vport = vport;\r\nmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\r\nmbox->context1 = NULL;\r\nrc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\r\nif (rc == MBX_NOT_FINISHED)\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\n}\r\n}\r\nvoid\r\nlpfc_reg_vpi(struct lpfc_vport *vport, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nstruct lpfc_hba *phba = vport->phba;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nif ((phba->sli_rev == LPFC_SLI_REV4) &&\r\n!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI))\r\nmb->un.varRegVpi.upd = 1;\r\nmb->un.varRegVpi.vpi = phba->vpi_ids[vport->vpi];\r\nmb->un.varRegVpi.sid = vport->fc_myDID;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nmb->un.varRegVpi.vfi = phba->sli4_hba.vfi_ids[vport->vfi];\r\nelse\r\nmb->un.varRegVpi.vfi = vport->vfi + vport->phba->vfi_base;\r\nmemcpy(mb->un.varRegVpi.wwn, &vport->fc_portname,\r\nsizeof(struct lpfc_name));\r\nmb->un.varRegVpi.wwn[0] = cpu_to_le32(mb->un.varRegVpi.wwn[0]);\r\nmb->un.varRegVpi.wwn[1] = cpu_to_le32(mb->un.varRegVpi.wwn[1]);\r\nmb->mbxCommand = MBX_REG_VPI;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_unreg_vpi(struct lpfc_hba *phba, uint16_t vpi, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nif (phba->sli_rev == LPFC_SLI_REV3)\r\nmb->un.varUnregVpi.vpi = phba->vpi_ids[vpi];\r\nelse if (phba->sli_rev >= LPFC_SLI_REV4)\r\nmb->un.varUnregVpi.sli4_vpi = phba->vpi_ids[vpi];\r\nmb->mbxCommand = MBX_UNREG_VPI;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_config_pcb_setup(struct lpfc_hba * phba)\r\n{\r\nstruct lpfc_sli *psli = &phba->sli;\r\nstruct lpfc_sli_ring *pring;\r\nPCB_t *pcbp = phba->pcb;\r\ndma_addr_t pdma_addr;\r\nuint32_t offset;\r\nuint32_t iocbCnt = 0;\r\nint i;\r\npcbp->maxRing = (psli->num_rings - 1);\r\nfor (i = 0; i < psli->num_rings; i++) {\r\npring = &psli->ring[i];\r\npring->sizeCiocb = phba->sli_rev == 3 ? SLI3_IOCB_CMD_SIZE:\r\nSLI2_IOCB_CMD_SIZE;\r\npring->sizeRiocb = phba->sli_rev == 3 ? SLI3_IOCB_RSP_SIZE:\r\nSLI2_IOCB_RSP_SIZE;\r\nif ((pring->numCiocb == 0) || (pring->numRiocb == 0)) {\r\npcbp->rdsc[i].cmdEntries = 0;\r\npcbp->rdsc[i].rspEntries = 0;\r\npcbp->rdsc[i].cmdAddrHigh = 0;\r\npcbp->rdsc[i].rspAddrHigh = 0;\r\npcbp->rdsc[i].cmdAddrLow = 0;\r\npcbp->rdsc[i].rspAddrLow = 0;\r\npring->cmdringaddr = NULL;\r\npring->rspringaddr = NULL;\r\ncontinue;\r\n}\r\npring->cmdringaddr = (void *)&phba->IOCBs[iocbCnt];\r\npcbp->rdsc[i].cmdEntries = pring->numCiocb;\r\noffset = (uint8_t *) &phba->IOCBs[iocbCnt] -\r\n(uint8_t *) phba->slim2p.virt;\r\npdma_addr = phba->slim2p.phys + offset;\r\npcbp->rdsc[i].cmdAddrHigh = putPaddrHigh(pdma_addr);\r\npcbp->rdsc[i].cmdAddrLow = putPaddrLow(pdma_addr);\r\niocbCnt += pring->numCiocb;\r\npring->rspringaddr = (void *) &phba->IOCBs[iocbCnt];\r\npcbp->rdsc[i].rspEntries = pring->numRiocb;\r\noffset = (uint8_t *)&phba->IOCBs[iocbCnt] -\r\n(uint8_t *)phba->slim2p.virt;\r\npdma_addr = phba->slim2p.phys + offset;\r\npcbp->rdsc[i].rspAddrHigh = putPaddrHigh(pdma_addr);\r\npcbp->rdsc[i].rspAddrLow = putPaddrLow(pdma_addr);\r\niocbCnt += pring->numRiocb;\r\n}\r\n}\r\nvoid\r\nlpfc_read_rev(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->un.varRdRev.cv = 1;\r\nmb->un.varRdRev.v3req = 1;\r\nmb->mbxCommand = MBX_READ_REV;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_sli4_swap_str(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nstruct lpfc_mqe *mqe;\r\nswitch (mb->mbxCommand) {\r\ncase MBX_READ_REV:\r\nmqe = &pmb->u.mqe;\r\nlpfc_sli_pcimem_bcopy(mqe->un.read_rev.fw_name,\r\nmqe->un.read_rev.fw_name, 16);\r\nlpfc_sli_pcimem_bcopy(mqe->un.read_rev.ulp_fw_name,\r\nmqe->un.read_rev.ulp_fw_name, 16);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_build_hbq_profile2(struct config_hbq_var *hbqmb,\r\nstruct lpfc_hbq_init *hbq_desc)\r\n{\r\nhbqmb->profiles.profile2.seqlenbcnt = hbq_desc->seqlenbcnt;\r\nhbqmb->profiles.profile2.maxlen = hbq_desc->maxlen;\r\nhbqmb->profiles.profile2.seqlenoff = hbq_desc->seqlenoff;\r\n}\r\nstatic void\r\nlpfc_build_hbq_profile3(struct config_hbq_var *hbqmb,\r\nstruct lpfc_hbq_init *hbq_desc)\r\n{\r\nhbqmb->profiles.profile3.seqlenbcnt = hbq_desc->seqlenbcnt;\r\nhbqmb->profiles.profile3.maxlen = hbq_desc->maxlen;\r\nhbqmb->profiles.profile3.cmdcodeoff = hbq_desc->cmdcodeoff;\r\nhbqmb->profiles.profile3.seqlenoff = hbq_desc->seqlenoff;\r\nmemcpy(&hbqmb->profiles.profile3.cmdmatch, hbq_desc->cmdmatch,\r\nsizeof(hbqmb->profiles.profile3.cmdmatch));\r\n}\r\nstatic void\r\nlpfc_build_hbq_profile5(struct config_hbq_var *hbqmb,\r\nstruct lpfc_hbq_init *hbq_desc)\r\n{\r\nhbqmb->profiles.profile5.seqlenbcnt = hbq_desc->seqlenbcnt;\r\nhbqmb->profiles.profile5.maxlen = hbq_desc->maxlen;\r\nhbqmb->profiles.profile5.cmdcodeoff = hbq_desc->cmdcodeoff;\r\nhbqmb->profiles.profile5.seqlenoff = hbq_desc->seqlenoff;\r\nmemcpy(&hbqmb->profiles.profile5.cmdmatch, hbq_desc->cmdmatch,\r\nsizeof(hbqmb->profiles.profile5.cmdmatch));\r\n}\r\nvoid\r\nlpfc_config_hbq(struct lpfc_hba *phba, uint32_t id,\r\nstruct lpfc_hbq_init *hbq_desc,\r\nuint32_t hbq_entry_index, LPFC_MBOXQ_t *pmb)\r\n{\r\nint i;\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nstruct config_hbq_var *hbqmb = &mb->un.varCfgHbq;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nhbqmb->hbqId = id;\r\nhbqmb->entry_count = hbq_desc->entry_count;\r\nhbqmb->recvNotify = hbq_desc->rn;\r\nhbqmb->numMask = hbq_desc->mask_count;\r\nhbqmb->profile = hbq_desc->profile;\r\nhbqmb->ringMask = hbq_desc->ring_mask;\r\nhbqmb->headerLen = hbq_desc->headerLen;\r\nhbqmb->logEntry = hbq_desc->logEntry;\r\nhbqmb->hbqaddrLow = putPaddrLow(phba->hbqslimp.phys) +\r\nhbq_entry_index * sizeof(struct lpfc_hbq_entry);\r\nhbqmb->hbqaddrHigh = putPaddrHigh(phba->hbqslimp.phys);\r\nmb->mbxCommand = MBX_CONFIG_HBQ;\r\nmb->mbxOwner = OWN_HOST;\r\nif (hbq_desc->profile == 2)\r\nlpfc_build_hbq_profile2(hbqmb, hbq_desc);\r\nelse if (hbq_desc->profile == 3)\r\nlpfc_build_hbq_profile3(hbqmb, hbq_desc);\r\nelse if (hbq_desc->profile == 5)\r\nlpfc_build_hbq_profile5(hbqmb, hbq_desc);\r\nif (!hbq_desc->mask_count)\r\nreturn;\r\nfor (i = 0; i < hbq_desc->mask_count; i++) {\r\nhbqmb->hbqMasks[i].tmatch = hbq_desc->hbqMasks[i].tmatch;\r\nhbqmb->hbqMasks[i].tmask = hbq_desc->hbqMasks[i].tmask;\r\nhbqmb->hbqMasks[i].rctlmatch = hbq_desc->hbqMasks[i].rctlmatch;\r\nhbqmb->hbqMasks[i].rctlmask = hbq_desc->hbqMasks[i].rctlmask;\r\n}\r\nreturn;\r\n}\r\nvoid\r\nlpfc_config_ring(struct lpfc_hba * phba, int ring, LPFC_MBOXQ_t * pmb)\r\n{\r\nint i;\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nstruct lpfc_sli *psli;\r\nstruct lpfc_sli_ring *pring;\r\nmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\r\nmb->un.varCfgRing.ring = ring;\r\nmb->un.varCfgRing.maxOrigXchg = 0;\r\nmb->un.varCfgRing.maxRespXchg = 0;\r\nmb->un.varCfgRing.recvNotify = 1;\r\npsli = &phba->sli;\r\npring = &psli->ring[ring];\r\nmb->un.varCfgRing.numMask = pring->num_mask;\r\nmb->mbxCommand = MBX_CONFIG_RING;\r\nmb->mbxOwner = OWN_HOST;\r\nif (pring->prt[0].profile) {\r\nmb->un.varCfgRing.profile = pring->prt[0].profile;\r\nreturn;\r\n}\r\nfor (i = 0; i < pring->num_mask; i++) {\r\nmb->un.varCfgRing.rrRegs[i].rval = pring->prt[i].rctl;\r\nif (mb->un.varCfgRing.rrRegs[i].rval != FC_RCTL_ELS_REQ)\r\nmb->un.varCfgRing.rrRegs[i].rmask = 0xff;\r\nelse\r\nmb->un.varCfgRing.rrRegs[i].rmask = 0xfe;\r\nmb->un.varCfgRing.rrRegs[i].tval = pring->prt[i].type;\r\nmb->un.varCfgRing.rrRegs[i].tmask = 0xff;\r\n}\r\nreturn;\r\n}\r\nvoid\r\nlpfc_config_port(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\r\n{\r\nMAILBOX_t __iomem *mb_slim = (MAILBOX_t __iomem *) phba->MBslimaddr;\r\nMAILBOX_t *mb = &pmb->u.mb;\r\ndma_addr_t pdma_addr;\r\nuint32_t bar_low, bar_high;\r\nsize_t offset;\r\nstruct lpfc_hgp hgp;\r\nint i;\r\nuint32_t pgp_offset;\r\nmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_CONFIG_PORT;\r\nmb->mbxOwner = OWN_HOST;\r\nmb->un.varCfgPort.pcbLen = sizeof(PCB_t);\r\noffset = (uint8_t *)phba->pcb - (uint8_t *)phba->slim2p.virt;\r\npdma_addr = phba->slim2p.phys + offset;\r\nmb->un.varCfgPort.pcbLow = putPaddrLow(pdma_addr);\r\nmb->un.varCfgPort.pcbHigh = putPaddrHigh(pdma_addr);\r\nmb->un.varCfgPort.hps = 1;\r\nif (phba->sli_rev == LPFC_SLI_REV3 && phba->vpd.sli3Feat.cerbm) {\r\nif (phba->cfg_enable_bg)\r\nmb->un.varCfgPort.cbg = 1;\r\nif (phba->cfg_enable_dss)\r\nmb->un.varCfgPort.cdss = 1;\r\nmb->un.varCfgPort.cerbm = 1;\r\nmb->un.varCfgPort.ccrp = 1;\r\nmb->un.varCfgPort.max_hbq = lpfc_sli_hbq_count();\r\nif (phba->max_vpi && phba->cfg_enable_npiv &&\r\nphba->vpd.sli3Feat.cmv) {\r\nmb->un.varCfgPort.max_vpi = LPFC_MAX_VPI;\r\nmb->un.varCfgPort.cmv = 1;\r\n} else\r\nmb->un.varCfgPort.max_vpi = phba->max_vpi = 0;\r\n} else\r\nphba->sli_rev = LPFC_SLI_REV2;\r\nmb->un.varCfgPort.sli_mode = phba->sli_rev;\r\nif (phba->sli_rev == LPFC_SLI_REV3)\r\nmb->un.varCfgPort.casabt = 1;\r\nphba->pcb->type = TYPE_NATIVE_SLI2;\r\nphba->pcb->feature = FEATURE_INITIAL_SLI2;\r\nphba->pcb->mailBoxSize = sizeof(MAILBOX_t) + MAILBOX_EXT_SIZE;\r\noffset = (uint8_t *)phba->mbox - (uint8_t *)phba->slim2p.virt;\r\npdma_addr = phba->slim2p.phys + offset;\r\nphba->pcb->mbAddrHigh = putPaddrHigh(pdma_addr);\r\nphba->pcb->mbAddrLow = putPaddrLow(pdma_addr);\r\npci_read_config_dword(phba->pcidev, PCI_BASE_ADDRESS_0, &bar_low);\r\npci_read_config_dword(phba->pcidev, PCI_BASE_ADDRESS_1, &bar_high);\r\nif (phba->cfg_hostmem_hgp && phba->sli_rev != 3) {\r\nphba->host_gp = &phba->mbox->us.s2.host[0];\r\nphba->hbq_put = NULL;\r\noffset = (uint8_t *)&phba->mbox->us.s2.host -\r\n(uint8_t *)phba->slim2p.virt;\r\npdma_addr = phba->slim2p.phys + offset;\r\nphba->pcb->hgpAddrHigh = putPaddrHigh(pdma_addr);\r\nphba->pcb->hgpAddrLow = putPaddrLow(pdma_addr);\r\n} else {\r\nmb->un.varCfgPort.hps = 1;\r\nif (phba->sli_rev == 3) {\r\nphba->host_gp = &mb_slim->us.s3.host[0];\r\nphba->hbq_put = &mb_slim->us.s3.hbq_put[0];\r\n} else {\r\nphba->host_gp = &mb_slim->us.s2.host[0];\r\nphba->hbq_put = NULL;\r\n}\r\nphba->pcb->hgpAddrLow = (bar_low & PCI_BASE_ADDRESS_MEM_MASK) +\r\n(void __iomem *)phba->host_gp -\r\n(void __iomem *)phba->MBslimaddr;\r\nif (bar_low & PCI_BASE_ADDRESS_MEM_TYPE_64)\r\nphba->pcb->hgpAddrHigh = bar_high;\r\nelse\r\nphba->pcb->hgpAddrHigh = 0;\r\nmemset(&hgp, 0, sizeof(struct lpfc_hgp));\r\nfor (i = 0; i < phba->sli.num_rings; i++) {\r\nlpfc_memcpy_to_slim(phba->host_gp + i, &hgp,\r\nsizeof(*phba->host_gp));\r\n}\r\n}\r\nif (phba->sli_rev == 3)\r\npgp_offset = offsetof(struct lpfc_sli2_slim,\r\nmbx.us.s3_pgp.port);\r\nelse\r\npgp_offset = offsetof(struct lpfc_sli2_slim, mbx.us.s2.port);\r\npdma_addr = phba->slim2p.phys + pgp_offset;\r\nphba->pcb->pgpAddrHigh = putPaddrHigh(pdma_addr);\r\nphba->pcb->pgpAddrLow = putPaddrLow(pdma_addr);\r\nlpfc_config_pcb_setup(phba);\r\nif (lpfc_is_LC_HBA(phba->pcidev->device)) {\r\nuint32_t hbainit[5];\r\nlpfc_hba_init(phba, hbainit);\r\nmemcpy(&mb->un.varCfgPort.hbainit, hbainit, 20);\r\n}\r\nlpfc_sli_pcimem_bcopy(phba->pcb, phba->pcb, sizeof(PCB_t));\r\n}\r\nvoid\r\nlpfc_kill_board(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\r\n{\r\nMAILBOX_t *mb = &pmb->u.mb;\r\nmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\r\nmb->mbxCommand = MBX_KILL_BOARD;\r\nmb->mbxOwner = OWN_HOST;\r\nreturn;\r\n}\r\nvoid\r\nlpfc_mbox_put(struct lpfc_hba * phba, LPFC_MBOXQ_t * mbq)\r\n{\r\nstruct lpfc_sli *psli;\r\npsli = &phba->sli;\r\nlist_add_tail(&mbq->list, &psli->mboxq);\r\npsli->mboxq_cnt++;\r\nreturn;\r\n}\r\nLPFC_MBOXQ_t *\r\nlpfc_mbox_get(struct lpfc_hba * phba)\r\n{\r\nLPFC_MBOXQ_t *mbq = NULL;\r\nstruct lpfc_sli *psli = &phba->sli;\r\nlist_remove_head((&psli->mboxq), mbq, LPFC_MBOXQ_t, list);\r\nif (mbq)\r\npsli->mboxq_cnt--;\r\nreturn mbq;\r\n}\r\nvoid\r\n__lpfc_mbox_cmpl_put(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbq)\r\n{\r\nlist_add_tail(&mbq->list, &phba->sli.mboxq_cmpl);\r\n}\r\nvoid\r\nlpfc_mbox_cmpl_put(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbq)\r\n{\r\nunsigned long iflag;\r\nspin_lock_irqsave(&phba->hbalock, iflag);\r\n__lpfc_mbox_cmpl_put(phba, mbq);\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nreturn;\r\n}\r\nint\r\nlpfc_mbox_cmd_check(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\r\n{\r\nif (mboxq->mbox_cmpl && mboxq->mbox_cmpl != lpfc_sli_def_mbox_cmpl &&\r\nmboxq->mbox_cmpl != lpfc_sli_wake_mbox_wait) {\r\nif (!mboxq->vport) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_VPORT,\r\n"1814 Mbox x%x failed, no vport\n",\r\nmboxq->u.mb.mbxCommand);\r\ndump_stack();\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlpfc_mbox_dev_check(struct lpfc_hba *phba)\r\n{\r\nif (unlikely(pci_channel_offline(phba->pcidev)))\r\nreturn -ENODEV;\r\nif (phba->link_state == LPFC_HBA_ERROR)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nint\r\nlpfc_mbox_tmo_val(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\r\n{\r\nMAILBOX_t *mbox = &mboxq->u.mb;\r\nuint8_t subsys, opcode;\r\nswitch (mbox->mbxCommand) {\r\ncase MBX_WRITE_NV:\r\ncase MBX_UPDATE_CFG:\r\ncase MBX_DOWN_LOAD:\r\ncase MBX_DEL_LD_ENTRY:\r\ncase MBX_LOAD_AREA:\r\ncase MBX_WRITE_WWN:\r\ncase MBX_LOAD_EXP_ROM:\r\nreturn LPFC_MBOX_TMO_FLASH_CMD;\r\ncase MBX_SLI4_CONFIG:\r\nsubsys = lpfc_sli_config_mbox_subsys_get(phba, mboxq);\r\nopcode = lpfc_sli_config_mbox_opcode_get(phba, mboxq);\r\nif (subsys == LPFC_MBOX_SUBSYSTEM_COMMON) {\r\nswitch (opcode) {\r\ncase LPFC_MBOX_OPCODE_READ_OBJECT:\r\ncase LPFC_MBOX_OPCODE_WRITE_OBJECT:\r\ncase LPFC_MBOX_OPCODE_READ_OBJECT_LIST:\r\ncase LPFC_MBOX_OPCODE_DELETE_OBJECT:\r\ncase LPFC_MBOX_OPCODE_GET_FUNCTION_CONFIG:\r\ncase LPFC_MBOX_OPCODE_GET_PROFILE_LIST:\r\ncase LPFC_MBOX_OPCODE_SET_ACT_PROFILE:\r\ncase LPFC_MBOX_OPCODE_SET_PROFILE_CONFIG:\r\ncase LPFC_MBOX_OPCODE_GET_FACTORY_PROFILE_CONFIG:\r\nreturn LPFC_MBOX_SLI4_CONFIG_EXTENDED_TMO;\r\n}\r\n}\r\nif (subsys == LPFC_MBOX_SUBSYSTEM_FCOE) {\r\nswitch (opcode) {\r\ncase LPFC_MBOX_OPCODE_FCOE_SET_FCLINK_SETTINGS:\r\nreturn LPFC_MBOX_SLI4_CONFIG_EXTENDED_TMO;\r\n}\r\n}\r\nreturn LPFC_MBOX_SLI4_CONFIG_TMO;\r\n}\r\nreturn LPFC_MBOX_TMO;\r\n}\r\nvoid\r\nlpfc_sli4_mbx_sge_set(struct lpfcMboxq *mbox, uint32_t sgentry,\r\ndma_addr_t phyaddr, uint32_t length)\r\n{\r\nstruct lpfc_mbx_nembed_cmd *nembed_sge;\r\nnembed_sge = (struct lpfc_mbx_nembed_cmd *)\r\n&mbox->u.mqe.un.nembed_cmd;\r\nnembed_sge->sge[sgentry].pa_lo = putPaddrLow(phyaddr);\r\nnembed_sge->sge[sgentry].pa_hi = putPaddrHigh(phyaddr);\r\nnembed_sge->sge[sgentry].length = length;\r\n}\r\nvoid\r\nlpfc_sli4_mbx_sge_get(struct lpfcMboxq *mbox, uint32_t sgentry,\r\nstruct lpfc_mbx_sge *sge)\r\n{\r\nstruct lpfc_mbx_nembed_cmd *nembed_sge;\r\nnembed_sge = (struct lpfc_mbx_nembed_cmd *)\r\n&mbox->u.mqe.un.nembed_cmd;\r\nsge->pa_lo = nembed_sge->sge[sgentry].pa_lo;\r\nsge->pa_hi = nembed_sge->sge[sgentry].pa_hi;\r\nsge->length = nembed_sge->sge[sgentry].length;\r\n}\r\nvoid\r\nlpfc_sli4_mbox_cmd_free(struct lpfc_hba *phba, struct lpfcMboxq *mbox)\r\n{\r\nstruct lpfc_mbx_sli4_config *sli4_cfg;\r\nstruct lpfc_mbx_sge sge;\r\ndma_addr_t phyaddr;\r\nuint32_t sgecount, sgentry;\r\nsli4_cfg = &mbox->u.mqe.un.sli4_config;\r\nif (bf_get(lpfc_mbox_hdr_emb, &sli4_cfg->header.cfg_mhdr)) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nsgecount = bf_get(lpfc_mbox_hdr_sge_cnt, &sli4_cfg->header.cfg_mhdr);\r\nif (unlikely(!mbox->sge_array)) {\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\nreturn;\r\n}\r\nfor (sgentry = 0; sgentry < sgecount; sgentry++) {\r\nlpfc_sli4_mbx_sge_get(mbox, sgentry, &sge);\r\nphyaddr = getPaddr(sge.pa_hi, sge.pa_lo);\r\ndma_free_coherent(&phba->pcidev->dev, SLI4_PAGE_SIZE,\r\nmbox->sge_array->addr[sgentry], phyaddr);\r\n}\r\nkfree(mbox->sge_array);\r\nmempool_free(mbox, phba->mbox_mem_pool);\r\n}\r\nint\r\nlpfc_sli4_config(struct lpfc_hba *phba, struct lpfcMboxq *mbox,\r\nuint8_t subsystem, uint8_t opcode, uint32_t length, bool emb)\r\n{\r\nstruct lpfc_mbx_sli4_config *sli4_config;\r\nunion lpfc_sli4_cfg_shdr *cfg_shdr = NULL;\r\nuint32_t alloc_len;\r\nuint32_t resid_len;\r\nuint32_t pagen, pcount;\r\nvoid *viraddr;\r\ndma_addr_t phyaddr;\r\nmemset(mbox, 0, sizeof(*mbox));\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_SLI4_CONFIG);\r\nsli4_config = &mbox->u.mqe.un.sli4_config;\r\nif (emb) {\r\nbf_set(lpfc_mbox_hdr_emb, &sli4_config->header.cfg_mhdr, 1);\r\nsli4_config->header.cfg_mhdr.payload_length = length;\r\nbf_set(lpfc_mbox_hdr_opcode,\r\n&sli4_config->header.cfg_shdr.request, opcode);\r\nbf_set(lpfc_mbox_hdr_subsystem,\r\n&sli4_config->header.cfg_shdr.request, subsystem);\r\nsli4_config->header.cfg_shdr.request.request_length =\r\nlength - LPFC_MBX_CMD_HDR_LENGTH;\r\nreturn length;\r\n}\r\npcount = (SLI4_PAGE_ALIGN(length))/SLI4_PAGE_SIZE;\r\npcount = (pcount > LPFC_SLI4_MBX_SGE_MAX_PAGES) ?\r\nLPFC_SLI4_MBX_SGE_MAX_PAGES : pcount;\r\nmbox->sge_array = kzalloc(sizeof(struct lpfc_mbx_nembed_sge_virt),\r\nGFP_KERNEL);\r\nif (!mbox->sge_array) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\r\n"2527 Failed to allocate non-embedded SGE "\r\n"array.\n");\r\nreturn 0;\r\n}\r\nfor (pagen = 0, alloc_len = 0; pagen < pcount; pagen++) {\r\nviraddr = dma_alloc_coherent(&phba->pcidev->dev, SLI4_PAGE_SIZE,\r\n&phyaddr, GFP_KERNEL);\r\nif (!viraddr)\r\nbreak;\r\nmemset(viraddr, 0, SLI4_PAGE_SIZE);\r\nmbox->sge_array->addr[pagen] = viraddr;\r\nif (pagen == 0)\r\ncfg_shdr = (union lpfc_sli4_cfg_shdr *)viraddr;\r\nresid_len = length - alloc_len;\r\nif (resid_len > SLI4_PAGE_SIZE) {\r\nlpfc_sli4_mbx_sge_set(mbox, pagen, phyaddr,\r\nSLI4_PAGE_SIZE);\r\nalloc_len += SLI4_PAGE_SIZE;\r\n} else {\r\nlpfc_sli4_mbx_sge_set(mbox, pagen, phyaddr,\r\nresid_len);\r\nalloc_len = length;\r\n}\r\n}\r\nsli4_config->header.cfg_mhdr.payload_length = alloc_len;\r\nbf_set(lpfc_mbox_hdr_sge_cnt, &sli4_config->header.cfg_mhdr, pagen);\r\nif (pagen > 0) {\r\nbf_set(lpfc_mbox_hdr_opcode, &cfg_shdr->request, opcode);\r\nbf_set(lpfc_mbox_hdr_subsystem, &cfg_shdr->request, subsystem);\r\ncfg_shdr->request.request_length =\r\nalloc_len - sizeof(union lpfc_sli4_cfg_shdr);\r\n}\r\nif (cfg_shdr)\r\nlpfc_sli_pcimem_bcopy(cfg_shdr, cfg_shdr,\r\nsizeof(union lpfc_sli4_cfg_shdr));\r\nreturn alloc_len;\r\n}\r\nint\r\nlpfc_sli4_mbox_rsrc_extent(struct lpfc_hba *phba, struct lpfcMboxq *mbox,\r\nuint16_t exts_count, uint16_t rsrc_type, bool emb)\r\n{\r\nuint8_t opcode = 0;\r\nstruct lpfc_mbx_nembed_rsrc_extent *n_rsrc_extnt = NULL;\r\nvoid *virtaddr = NULL;\r\nif (emb == LPFC_SLI4_MBX_NEMBED) {\r\nvirtaddr = mbox->sge_array->addr[0];\r\nif (virtaddr == NULL)\r\nreturn 1;\r\nn_rsrc_extnt = (struct lpfc_mbx_nembed_rsrc_extent *) virtaddr;\r\n}\r\nif (emb == LPFC_SLI4_MBX_EMBED)\r\nbf_set(lpfc_mbx_alloc_rsrc_extents_type,\r\n&mbox->u.mqe.un.alloc_rsrc_extents.u.req,\r\nrsrc_type);\r\nelse {\r\nbf_set(lpfc_mbx_alloc_rsrc_extents_type,\r\nn_rsrc_extnt, rsrc_type);\r\nlpfc_sli_pcimem_bcopy(&n_rsrc_extnt->word4,\r\n&n_rsrc_extnt->word4,\r\nsizeof(uint32_t));\r\n}\r\nopcode = lpfc_sli_config_mbox_opcode_get(phba, mbox);\r\nswitch (opcode) {\r\ncase LPFC_MBOX_OPCODE_ALLOC_RSRC_EXTENT:\r\nif (emb == LPFC_SLI4_MBX_EMBED)\r\nbf_set(lpfc_mbx_alloc_rsrc_extents_cnt,\r\n&mbox->u.mqe.un.alloc_rsrc_extents.u.req,\r\nexts_count);\r\nelse\r\nbf_set(lpfc_mbx_alloc_rsrc_extents_cnt,\r\nn_rsrc_extnt, exts_count);\r\nbreak;\r\ncase LPFC_MBOX_OPCODE_GET_ALLOC_RSRC_EXTENT:\r\ncase LPFC_MBOX_OPCODE_GET_RSRC_EXTENT_INFO:\r\ncase LPFC_MBOX_OPCODE_DEALLOC_RSRC_EXTENT:\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\r\n"2929 Resource Extent Opcode x%x is "\r\n"unsupported\n", opcode);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nuint8_t\r\nlpfc_sli_config_mbox_subsys_get(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbox)\r\n{\r\nstruct lpfc_mbx_sli4_config *sli4_cfg;\r\nunion lpfc_sli4_cfg_shdr *cfg_shdr;\r\nif (mbox->u.mb.mbxCommand != MBX_SLI4_CONFIG)\r\nreturn LPFC_MBOX_SUBSYSTEM_NA;\r\nsli4_cfg = &mbox->u.mqe.un.sli4_config;\r\nif (bf_get(lpfc_mbox_hdr_emb, &sli4_cfg->header.cfg_mhdr)) {\r\ncfg_shdr = &mbox->u.mqe.un.sli4_config.header.cfg_shdr;\r\nreturn bf_get(lpfc_mbox_hdr_subsystem, &cfg_shdr->request);\r\n}\r\nif (unlikely(!mbox->sge_array))\r\nreturn LPFC_MBOX_SUBSYSTEM_NA;\r\ncfg_shdr = (union lpfc_sli4_cfg_shdr *)mbox->sge_array->addr[0];\r\nreturn bf_get(lpfc_mbox_hdr_subsystem, &cfg_shdr->request);\r\n}\r\nuint8_t\r\nlpfc_sli_config_mbox_opcode_get(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbox)\r\n{\r\nstruct lpfc_mbx_sli4_config *sli4_cfg;\r\nunion lpfc_sli4_cfg_shdr *cfg_shdr;\r\nif (mbox->u.mb.mbxCommand != MBX_SLI4_CONFIG)\r\nreturn LPFC_MBOX_OPCODE_NA;\r\nsli4_cfg = &mbox->u.mqe.un.sli4_config;\r\nif (bf_get(lpfc_mbox_hdr_emb, &sli4_cfg->header.cfg_mhdr)) {\r\ncfg_shdr = &mbox->u.mqe.un.sli4_config.header.cfg_shdr;\r\nreturn bf_get(lpfc_mbox_hdr_opcode, &cfg_shdr->request);\r\n}\r\nif (unlikely(!mbox->sge_array))\r\nreturn LPFC_MBOX_OPCODE_NA;\r\ncfg_shdr = (union lpfc_sli4_cfg_shdr *)mbox->sge_array->addr[0];\r\nreturn bf_get(lpfc_mbox_hdr_opcode, &cfg_shdr->request);\r\n}\r\nint\r\nlpfc_sli4_mbx_read_fcf_rec(struct lpfc_hba *phba,\r\nstruct lpfcMboxq *mboxq,\r\nuint16_t fcf_index)\r\n{\r\nvoid *virt_addr;\r\ndma_addr_t phys_addr;\r\nuint8_t *bytep;\r\nstruct lpfc_mbx_sge sge;\r\nuint32_t alloc_len, req_len;\r\nstruct lpfc_mbx_read_fcf_tbl *read_fcf;\r\nif (!mboxq)\r\nreturn -ENOMEM;\r\nreq_len = sizeof(struct fcf_record) +\r\nsizeof(union lpfc_sli4_cfg_shdr) + 2 * sizeof(uint32_t);\r\nalloc_len = lpfc_sli4_config(phba, mboxq, LPFC_MBOX_SUBSYSTEM_FCOE,\r\nLPFC_MBOX_OPCODE_FCOE_READ_FCF_TABLE, req_len,\r\nLPFC_SLI4_MBX_NEMBED);\r\nif (alloc_len < req_len) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\r\n"0291 Allocated DMA memory size (x%x) is "\r\n"less than the requested DMA memory "\r\n"size (x%x)\n", alloc_len, req_len);\r\nreturn -ENOMEM;\r\n}\r\nlpfc_sli4_mbx_sge_get(mboxq, 0, &sge);\r\nphys_addr = getPaddr(sge.pa_hi, sge.pa_lo);\r\nvirt_addr = mboxq->sge_array->addr[0];\r\nread_fcf = (struct lpfc_mbx_read_fcf_tbl *)virt_addr;\r\nbf_set(lpfc_mbx_read_fcf_tbl_indx, &read_fcf->u.request, fcf_index);\r\nbytep = virt_addr + sizeof(union lpfc_sli4_cfg_shdr);\r\nlpfc_sli_pcimem_bcopy(bytep, bytep, sizeof(uint32_t));\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_request_features(struct lpfc_hba *phba, struct lpfcMboxq *mboxq)\r\n{\r\nmemset(mboxq, 0, sizeof(LPFC_MBOXQ_t));\r\nbf_set(lpfc_mqe_command, &mboxq->u.mqe, MBX_SLI4_REQ_FTRS);\r\nbf_set(lpfc_mbx_rq_ftr_rq_fcpi, &mboxq->u.mqe.un.req_ftrs, 1);\r\nbf_set(lpfc_mbx_rq_ftr_rq_perfh, &mboxq->u.mqe.un.req_ftrs, 1);\r\nif (phba->cfg_enable_bg)\r\nbf_set(lpfc_mbx_rq_ftr_rq_dif, &mboxq->u.mqe.un.req_ftrs, 1);\r\nif (phba->max_vpi && phba->cfg_enable_npiv)\r\nbf_set(lpfc_mbx_rq_ftr_rq_npiv, &mboxq->u.mqe.un.req_ftrs, 1);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_init_vfi(struct lpfcMboxq *mbox, struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_mbx_init_vfi *init_vfi;\r\nmemset(mbox, 0, sizeof(*mbox));\r\nmbox->vport = vport;\r\ninit_vfi = &mbox->u.mqe.un.init_vfi;\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_INIT_VFI);\r\nbf_set(lpfc_init_vfi_vr, init_vfi, 1);\r\nbf_set(lpfc_init_vfi_vt, init_vfi, 1);\r\nbf_set(lpfc_init_vfi_vp, init_vfi, 1);\r\nbf_set(lpfc_init_vfi_vfi, init_vfi,\r\nvport->phba->sli4_hba.vfi_ids[vport->vfi]);\r\nbf_set(lpfc_init_vfi_vpi, init_vfi,\r\nvport->phba->vpi_ids[vport->vpi]);\r\nbf_set(lpfc_init_vfi_fcfi, init_vfi,\r\nvport->phba->fcf.fcfi);\r\n}\r\nvoid\r\nlpfc_reg_vfi(struct lpfcMboxq *mbox, struct lpfc_vport *vport, dma_addr_t phys)\r\n{\r\nstruct lpfc_mbx_reg_vfi *reg_vfi;\r\nmemset(mbox, 0, sizeof(*mbox));\r\nreg_vfi = &mbox->u.mqe.un.reg_vfi;\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_REG_VFI);\r\nbf_set(lpfc_reg_vfi_vp, reg_vfi, 1);\r\nbf_set(lpfc_reg_vfi_vfi, reg_vfi,\r\nvport->phba->sli4_hba.vfi_ids[vport->vfi]);\r\nbf_set(lpfc_reg_vfi_fcfi, reg_vfi, vport->phba->fcf.fcfi);\r\nbf_set(lpfc_reg_vfi_vpi, reg_vfi, vport->phba->vpi_ids[vport->vpi]);\r\nmemcpy(reg_vfi->wwn, &vport->fc_portname, sizeof(struct lpfc_name));\r\nreg_vfi->wwn[0] = cpu_to_le32(reg_vfi->wwn[0]);\r\nreg_vfi->wwn[1] = cpu_to_le32(reg_vfi->wwn[1]);\r\nreg_vfi->e_d_tov = vport->phba->fc_edtov;\r\nreg_vfi->r_a_tov = vport->phba->fc_ratov;\r\nreg_vfi->bde.addrHigh = putPaddrHigh(phys);\r\nreg_vfi->bde.addrLow = putPaddrLow(phys);\r\nreg_vfi->bde.tus.f.bdeSize = sizeof(vport->fc_sparam);\r\nreg_vfi->bde.tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nbf_set(lpfc_reg_vfi_nport_id, reg_vfi, vport->fc_myDID);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_MBOX,\r\n"3134 Register VFI, mydid:x%x, fcfi:%d, "\r\n" vfi:%d, vpi:%d, fc_pname:%x%x\n",\r\nvport->fc_myDID,\r\nvport->phba->fcf.fcfi,\r\nvport->phba->sli4_hba.vfi_ids[vport->vfi],\r\nvport->phba->vpi_ids[vport->vpi],\r\nreg_vfi->wwn[0], reg_vfi->wwn[1]);\r\n}\r\nvoid\r\nlpfc_init_vpi(struct lpfc_hba *phba, struct lpfcMboxq *mbox, uint16_t vpi)\r\n{\r\nmemset(mbox, 0, sizeof(*mbox));\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_INIT_VPI);\r\nbf_set(lpfc_init_vpi_vpi, &mbox->u.mqe.un.init_vpi,\r\nphba->vpi_ids[vpi]);\r\nbf_set(lpfc_init_vpi_vfi, &mbox->u.mqe.un.init_vpi,\r\nphba->sli4_hba.vfi_ids[phba->pport->vfi]);\r\n}\r\nvoid\r\nlpfc_unreg_vfi(struct lpfcMboxq *mbox, struct lpfc_vport *vport)\r\n{\r\nmemset(mbox, 0, sizeof(*mbox));\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_UNREG_VFI);\r\nbf_set(lpfc_unreg_vfi_vfi, &mbox->u.mqe.un.unreg_vfi,\r\nvport->phba->sli4_hba.vfi_ids[vport->vfi]);\r\n}\r\nint\r\nlpfc_sli4_dump_cfg_rg23(struct lpfc_hba *phba, struct lpfcMboxq *mbox)\r\n{\r\nstruct lpfc_dmabuf *mp = NULL;\r\nMAILBOX_t *mb;\r\nmemset(mbox, 0, sizeof(*mbox));\r\nmb = &mbox->u.mb;\r\nmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\r\nif (mp)\r\nmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\r\nif (!mp || !mp->virt) {\r\nkfree(mp);\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\r\n"2569 lpfc dump config region 23: memory"\r\n" allocation failed\n");\r\nreturn 1;\r\n}\r\nmemset(mp->virt, 0, LPFC_BPL_SIZE);\r\nINIT_LIST_HEAD(&mp->list);\r\nmbox->context1 = (uint8_t *) mp;\r\nmb->mbxCommand = MBX_DUMP_MEMORY;\r\nmb->un.varDmp.type = DMP_NV_PARAMS;\r\nmb->un.varDmp.region_id = DMP_REGION_23;\r\nmb->un.varDmp.sli4_length = DMP_RGN23_SIZE;\r\nmb->un.varWords[3] = putPaddrLow(mp->phys);\r\nmb->un.varWords[4] = putPaddrHigh(mp->phys);\r\nreturn 0;\r\n}\r\nvoid\r\nlpfc_reg_fcfi(struct lpfc_hba *phba, struct lpfcMboxq *mbox)\r\n{\r\nstruct lpfc_mbx_reg_fcfi *reg_fcfi;\r\nmemset(mbox, 0, sizeof(*mbox));\r\nreg_fcfi = &mbox->u.mqe.un.reg_fcfi;\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_REG_FCFI);\r\nbf_set(lpfc_reg_fcfi_rq_id0, reg_fcfi, phba->sli4_hba.hdr_rq->queue_id);\r\nbf_set(lpfc_reg_fcfi_rq_id1, reg_fcfi, REG_FCF_INVALID_QID);\r\nbf_set(lpfc_reg_fcfi_rq_id2, reg_fcfi, REG_FCF_INVALID_QID);\r\nbf_set(lpfc_reg_fcfi_rq_id3, reg_fcfi, REG_FCF_INVALID_QID);\r\nbf_set(lpfc_reg_fcfi_info_index, reg_fcfi,\r\nphba->fcf.current_rec.fcf_indx);\r\nbf_set(lpfc_reg_fcfi_mam, reg_fcfi, (~phba->fcf.addr_mode) & 0x3);\r\nif (phba->fcf.current_rec.vlan_id != LPFC_FCOE_NULL_VID) {\r\nbf_set(lpfc_reg_fcfi_vv, reg_fcfi, 1);\r\nbf_set(lpfc_reg_fcfi_vlan_tag, reg_fcfi,\r\nphba->fcf.current_rec.vlan_id);\r\n}\r\n}\r\nvoid\r\nlpfc_unreg_fcfi(struct lpfcMboxq *mbox, uint16_t fcfi)\r\n{\r\nmemset(mbox, 0, sizeof(*mbox));\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_UNREG_FCFI);\r\nbf_set(lpfc_unreg_fcfi, &mbox->u.mqe.un.unreg_fcfi, fcfi);\r\n}\r\nvoid\r\nlpfc_resume_rpi(struct lpfcMboxq *mbox, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_hba *phba = ndlp->phba;\r\nstruct lpfc_mbx_resume_rpi *resume_rpi;\r\nmemset(mbox, 0, sizeof(*mbox));\r\nresume_rpi = &mbox->u.mqe.un.resume_rpi;\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_RESUME_RPI);\r\nbf_set(lpfc_resume_rpi_index, resume_rpi,\r\nphba->sli4_hba.rpi_ids[ndlp->nlp_rpi]);\r\nbf_set(lpfc_resume_rpi_ii, resume_rpi, RESUME_INDEX_RPI);\r\nresume_rpi->event_tag = ndlp->phba->fc_eventTag;\r\n}\r\nvoid\r\nlpfc_supported_pages(struct lpfcMboxq *mbox)\r\n{\r\nstruct lpfc_mbx_supp_pages *supp_pages;\r\nmemset(mbox, 0, sizeof(*mbox));\r\nsupp_pages = &mbox->u.mqe.un.supp_pages;\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_PORT_CAPABILITIES);\r\nbf_set(cpn, supp_pages, LPFC_SUPP_PAGES);\r\n}\r\nvoid\r\nlpfc_pc_sli4_params(struct lpfcMboxq *mbox)\r\n{\r\nstruct lpfc_mbx_pc_sli4_params *sli4_params;\r\nmemset(mbox, 0, sizeof(*mbox));\r\nsli4_params = &mbox->u.mqe.un.sli4_params;\r\nbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_PORT_CAPABILITIES);\r\nbf_set(cpn, sli4_params, LPFC_SLI4_PARAMETERS);\r\n}
