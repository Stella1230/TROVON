static int ppc4xx_msi_init_allocator(struct platform_device *dev,\r\nstruct ppc4xx_msi *msi_data)\r\n{\r\nint err;\r\nerr = msi_bitmap_alloc(&msi_data->bitmap, msi_irqs,\r\ndev->dev.of_node);\r\nif (err)\r\nreturn err;\r\nerr = msi_bitmap_reserve_dt_hwirqs(&msi_data->bitmap);\r\nif (err < 0) {\r\nmsi_bitmap_free(&msi_data->bitmap);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ppc4xx_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)\r\n{\r\nint int_no = -ENOMEM;\r\nunsigned int virq;\r\nstruct msi_msg msg;\r\nstruct msi_desc *entry;\r\nstruct ppc4xx_msi *msi_data = &ppc4xx_msi;\r\nmsi_data->msi_virqs = kmalloc((msi_irqs) * sizeof(int),\r\nGFP_KERNEL);\r\nif (!msi_data->msi_virqs)\r\nreturn -ENOMEM;\r\nlist_for_each_entry(entry, &dev->msi_list, list) {\r\nint_no = msi_bitmap_alloc_hwirqs(&msi_data->bitmap, 1);\r\nif (int_no >= 0)\r\nbreak;\r\nif (int_no < 0) {\r\npr_debug("%s: fail allocating msi interrupt\n",\r\n__func__);\r\n}\r\nvirq = irq_of_parse_and_map(msi_data->msi_dev, int_no);\r\nif (virq == NO_IRQ) {\r\ndev_err(&dev->dev, "%s: fail mapping irq\n", __func__);\r\nmsi_bitmap_free_hwirqs(&msi_data->bitmap, int_no, 1);\r\nreturn -ENOSPC;\r\n}\r\ndev_dbg(&dev->dev, "%s: virq = %d\n", __func__, virq);\r\nmsg.address_hi = msi_data->msi_addr_hi;\r\nmsg.address_lo = msi_data->msi_addr_lo;\r\nirq_set_msi_desc(virq, entry);\r\nmsg.data = int_no;\r\nwrite_msi_msg(virq, &msg);\r\n}\r\nreturn 0;\r\n}\r\nvoid ppc4xx_teardown_msi_irqs(struct pci_dev *dev)\r\n{\r\nstruct msi_desc *entry;\r\nstruct ppc4xx_msi *msi_data = &ppc4xx_msi;\r\ndev_dbg(&dev->dev, "PCIE-MSI: tearing down msi irqs\n");\r\nlist_for_each_entry(entry, &dev->msi_list, list) {\r\nif (entry->irq == NO_IRQ)\r\ncontinue;\r\nirq_set_msi_desc(entry->irq, NULL);\r\nmsi_bitmap_free_hwirqs(&msi_data->bitmap,\r\nvirq_to_hw(entry->irq), 1);\r\nirq_dispose_mapping(entry->irq);\r\n}\r\n}\r\nstatic int ppc4xx_msi_check_device(struct pci_dev *pdev, int nvec, int type)\r\n{\r\ndev_dbg(&pdev->dev, "PCIE-MSI:%s called. vec %x type %d\n",\r\n__func__, nvec, type);\r\nif (type == PCI_CAP_ID_MSIX)\r\npr_debug("ppc4xx msi: MSI-X untested, trying anyway.\n");\r\nreturn 0;\r\n}\r\nstatic int ppc4xx_setup_pcieh_hw(struct platform_device *dev,\r\nstruct resource res, struct ppc4xx_msi *msi)\r\n{\r\nconst u32 *msi_data;\r\nconst u32 *msi_mask;\r\nconst u32 *sdr_addr;\r\ndma_addr_t msi_phys;\r\nvoid *msi_virt;\r\nsdr_addr = of_get_property(dev->dev.of_node, "sdr-base", NULL);\r\nif (!sdr_addr)\r\nreturn -1;\r\nmtdcri(SDR0, *sdr_addr, upper_32_bits(res.start));\r\nmtdcri(SDR0, *sdr_addr + 1, lower_32_bits(res.start));\r\nmsi->msi_dev = of_find_node_by_name(NULL, "ppc4xx-msi");\r\nif (!msi->msi_dev)\r\nreturn -ENODEV;\r\nmsi->msi_regs = of_iomap(msi->msi_dev, 0);\r\nif (!msi->msi_regs) {\r\ndev_err(&dev->dev, "of_iomap problem failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(&dev->dev, "PCIE-MSI: msi register mapped 0x%x 0x%x\n",\r\n(u32) (msi->msi_regs + PEIH_TERMADH), (u32) (msi->msi_regs));\r\nmsi_virt = dma_alloc_coherent(&dev->dev, 64, &msi_phys, GFP_KERNEL);\r\nif (!msi_virt)\r\nreturn -ENOMEM;\r\nmsi->msi_addr_hi = upper_32_bits(msi_phys);\r\nmsi->msi_addr_lo = lower_32_bits(msi_phys & 0xffffffff);\r\ndev_dbg(&dev->dev, "PCIE-MSI: msi address high 0x%x, low 0x%x\n",\r\nmsi->msi_addr_hi, msi->msi_addr_lo);\r\nout_be32(msi->msi_regs + PEIH_TERMADH, msi->msi_addr_hi);\r\nout_be32(msi->msi_regs + PEIH_TERMADL, msi->msi_addr_lo);\r\nmsi_data = of_get_property(dev->dev.of_node, "msi-data", NULL);\r\nif (!msi_data)\r\nreturn -1;\r\nmsi_mask = of_get_property(dev->dev.of_node, "msi-mask", NULL);\r\nif (!msi_mask)\r\nreturn -1;\r\nout_be32(msi->msi_regs + PEIH_MSIED, *msi_data);\r\nout_be32(msi->msi_regs + PEIH_MSIMK, *msi_mask);\r\ndma_free_coherent(&dev->dev, 64, msi_virt, msi_phys);\r\nreturn 0;\r\n}\r\nstatic int ppc4xx_of_msi_remove(struct platform_device *dev)\r\n{\r\nstruct ppc4xx_msi *msi = dev->dev.platform_data;\r\nint i;\r\nint virq;\r\nfor (i = 0; i < msi_irqs; i++) {\r\nvirq = msi->msi_virqs[i];\r\nif (virq != NO_IRQ)\r\nirq_dispose_mapping(virq);\r\n}\r\nif (msi->bitmap.bitmap)\r\nmsi_bitmap_free(&msi->bitmap);\r\niounmap(msi->msi_regs);\r\nof_node_put(msi->msi_dev);\r\nkfree(msi);\r\nreturn 0;\r\n}\r\nstatic int __devinit ppc4xx_msi_probe(struct platform_device *dev)\r\n{\r\nstruct ppc4xx_msi *msi;\r\nstruct resource res;\r\nint err = 0;\r\ndev_dbg(&dev->dev, "PCIE-MSI: Setting up MSI support...\n");\r\nmsi = kzalloc(sizeof(struct ppc4xx_msi), GFP_KERNEL);\r\nif (!msi) {\r\ndev_err(&dev->dev, "No memory for MSI structure\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dev.platform_data = msi;\r\nerr = of_address_to_resource(dev->dev.of_node, 0, &res);\r\nif (err) {\r\ndev_err(&dev->dev, "%s resource error!\n",\r\ndev->dev.of_node->full_name);\r\ngoto error_out;\r\n}\r\nmsi_irqs = of_irq_count(dev->dev.of_node);\r\nif (!msi_irqs)\r\nreturn -ENODEV;\r\nif (ppc4xx_setup_pcieh_hw(dev, res, msi))\r\ngoto error_out;\r\nerr = ppc4xx_msi_init_allocator(dev, msi);\r\nif (err) {\r\ndev_err(&dev->dev, "Error allocating MSI bitmap\n");\r\ngoto error_out;\r\n}\r\nppc4xx_msi = *msi;\r\nppc_md.setup_msi_irqs = ppc4xx_setup_msi_irqs;\r\nppc_md.teardown_msi_irqs = ppc4xx_teardown_msi_irqs;\r\nppc_md.msi_check_device = ppc4xx_msi_check_device;\r\nreturn err;\r\nerror_out:\r\nppc4xx_of_msi_remove(dev);\r\nreturn err;\r\n}\r\nstatic __init int ppc4xx_msi_init(void)\r\n{\r\nreturn platform_driver_register(&ppc4xx_msi_driver);\r\n}
