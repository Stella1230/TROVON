static int smiapp_write_8(struct smiapp_sensor *sensor, u16 reg, u8 val)\r\n{\r\nreturn smiapp_write(sensor, (SMIA_REG_8BIT << 16) | reg, val);\r\n}\r\nstatic int smiapp_write_8s(struct smiapp_sensor *sensor,\r\nstruct smiapp_reg_8 *regs, int len)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nfor (; len > 0; len--, regs++) {\r\nrval = smiapp_write_8(sensor, regs->reg, regs->val);\r\nif (rval < 0) {\r\ndev_err(&client->dev,\r\n"error %d writing reg 0x%4.4x, val 0x%2.2x",\r\nrval, regs->reg, regs->val);\r\nreturn rval;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid smiapp_replace_limit(struct smiapp_sensor *sensor,\r\nu32 limit, u32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\ndev_dbg(&client->dev, "quirk: 0x%8.8x \"%s\" = %d, 0x%x\n",\r\nsmiapp_reg_limits[limit].addr,\r\nsmiapp_reg_limits[limit].what, val, val);\r\nsensor->limits[limit] = val;\r\n}\r\nint smiapp_replace_limit_at(struct smiapp_sensor *sensor,\r\nu32 reg, u32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint i;\r\nfor (i = 0; smiapp_reg_limits[i].addr; i++) {\r\nif ((smiapp_reg_limits[i].addr & 0xffff) != reg)\r\ncontinue;\r\nsmiapp_replace_limit(sensor, i, val);\r\nreturn 0;\r\n}\r\ndev_dbg(&client->dev, "quirk: bad register 0x%4.4x\n", reg);\r\nreturn -EINVAL;\r\n}\r\nbool smiapp_quirk_reg(struct smiapp_sensor *sensor,\r\nu32 reg, u32 *val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nconst struct smia_reg *sreg;\r\nif (!sensor->minfo.quirk)\r\nreturn false;\r\nsreg = sensor->minfo.quirk->regs;\r\nif (!sreg)\r\nreturn false;\r\nwhile (sreg->type) {\r\nu16 type = reg >> 16;\r\nu16 reg16 = reg;\r\nif (sreg->type != type || sreg->reg != reg16) {\r\nsreg++;\r\ncontinue;\r\n}\r\nswitch ((u8)type) {\r\ncase SMIA_REG_8BIT:\r\ndev_dbg(&client->dev, "quirk: 0x%8.8x: 0x%2.2x\n",\r\nreg, sreg->val);\r\nbreak;\r\ncase SMIA_REG_16BIT:\r\ndev_dbg(&client->dev, "quirk: 0x%8.8x: 0x%4.4x\n",\r\nreg, sreg->val);\r\nbreak;\r\ncase SMIA_REG_32BIT:\r\ndev_dbg(&client->dev, "quirk: 0x%8.8x: 0x%8.8x\n",\r\nreg, sreg->val);\r\nbreak;\r\n}\r\n*val = sreg->val;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int jt8ew9_limits(struct smiapp_sensor *sensor)\r\n{\r\nif (sensor->minfo.revision_number_major < 0x03)\r\nsensor->frame_skip = 1;\r\nsmiapp_replace_limit(sensor, SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_MIN, 59);\r\nsmiapp_replace_limit(\r\nsensor, SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_MAX, 6000);\r\nreturn 0;\r\n}\r\nstatic int jt8ew9_post_poweron(struct smiapp_sensor *sensor)\r\n{\r\nstruct smiapp_reg_8 regs[] = {\r\n{ 0x30a3, 0xd8 },\r\n{ 0x30ae, 0x00 },\r\n{ 0x30af, 0xd0 },\r\n{ 0x322d, 0x04 },\r\n{ 0x3255, 0x0f },\r\n{ 0x3256, 0x15 },\r\n{ 0x3258, 0x70 },\r\n{ 0x3259, 0x70 },\r\n{ 0x325f, 0x7c },\r\n{ 0x3302, 0x06 },\r\n{ 0x3304, 0x00 },\r\n{ 0x3307, 0x22 },\r\n{ 0x3308, 0x8d },\r\n{ 0x331e, 0x0f },\r\n{ 0x3320, 0x30 },\r\n{ 0x3321, 0x11 },\r\n{ 0x3322, 0x98 },\r\n{ 0x3323, 0x64 },\r\n{ 0x3325, 0x83 },\r\n{ 0x3330, 0x18 },\r\n{ 0x333c, 0x01 },\r\n{ 0x3345, 0x2f },\r\n{ 0x33de, 0x38 },\r\n{ 0x32e0, 0x05 },\r\n{ 0x32e1, 0x05 },\r\n{ 0x32e2, 0x04 },\r\n{ 0x32e5, 0x04 },\r\n{ 0x32e6, 0x04 },\r\n};\r\nreturn smiapp_write_8s(sensor, regs, ARRAY_SIZE(regs));\r\n}\r\nstatic int imx125es_post_poweron(struct smiapp_sensor *sensor)\r\n{\r\nstruct smiapp_reg_8 regs[] = {\r\n{ 0x3302, 0x01 },\r\n{ 0x302d, 0x00 },\r\n{ 0x3b08, 0x8c },\r\n};\r\nreturn smiapp_write_8s(sensor, regs, ARRAY_SIZE(regs));\r\n}\r\nstatic int jt8ev1_limits(struct smiapp_sensor *sensor)\r\n{\r\nsmiapp_replace_limit(sensor, SMIAPP_LIMIT_X_ADDR_MAX, 4271);\r\nsmiapp_replace_limit(sensor,\r\nSMIAPP_LIMIT_MIN_LINE_BLANKING_PCK_BIN, 184);\r\nreturn 0;\r\n}\r\nstatic int jt8ev1_post_poweron(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nstruct smiapp_reg_8 regs[] = {\r\n{ 0x3031, 0xcd },\r\n{ 0x30a3, 0xd0 },\r\n{ 0x3237, 0x00 },\r\n{ 0x3238, 0x43 },\r\n{ 0x3301, 0x06 },\r\n{ 0x3302, 0x06 },\r\n{ 0x3304, 0x00 },\r\n{ 0x3305, 0x88 },\r\n{ 0x332a, 0x14 },\r\n{ 0x332c, 0x6b },\r\n{ 0x3336, 0x01 },\r\n{ 0x333f, 0x1f },\r\n{ 0x3355, 0x00 },\r\n{ 0x3356, 0x20 },\r\n{ 0x33bf, 0x20 },\r\n{ 0x33c9, 0x20 },\r\n{ 0x33ce, 0x30 },\r\n{ 0x33cf, 0xec },\r\n{ 0x3328, 0x80 },\r\n};\r\nstruct smiapp_reg_8 regs_96[] = {\r\n{ 0x30ae, 0x00 },\r\n{ 0x30af, 0xd0 },\r\n{ 0x30b0, 0x01 },\r\n};\r\nrval = smiapp_write_8s(sensor, regs, ARRAY_SIZE(regs));\r\nif (rval < 0)\r\nreturn rval;\r\nswitch (sensor->platform_data->ext_clk) {\r\ncase 9600000:\r\nreturn smiapp_write_8s(sensor, regs_96,\r\nARRAY_SIZE(regs_96));\r\ndefault:\r\ndev_warn(&client->dev, "no MSRs for %d Hz ext_clk\n",\r\nsensor->platform_data->ext_clk);\r\nreturn 0;\r\n}\r\n}\r\nstatic int jt8ev1_pre_streamon(struct smiapp_sensor *sensor)\r\n{\r\nreturn smiapp_write_8(sensor, 0x3328, 0x00);\r\n}\r\nstatic int jt8ev1_post_streamoff(struct smiapp_sensor *sensor)\r\n{\r\nint rval;\r\nrval = smiapp_write_8(sensor, 0x3205, 0x04);\r\nif (rval < 0)\r\nreturn rval;\r\nusleep_range(2000, 2000);\r\nrval = smiapp_write_8(sensor, 0x3205, 0x00);\r\nif (rval < 0)\r\nreturn rval;\r\nreturn smiapp_write_8(sensor, 0x3328, 0x80);\r\n}\r\nstatic int tcm8500md_limits(struct smiapp_sensor *sensor)\r\n{\r\nsmiapp_replace_limit(sensor, SMIAPP_LIMIT_MIN_PLL_IP_FREQ_HZ, 2700000);\r\nreturn 0;\r\n}
