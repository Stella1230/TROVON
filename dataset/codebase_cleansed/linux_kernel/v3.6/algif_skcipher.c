static inline int skcipher_sndbuf(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nreturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\r\nctx->used, 0);\r\n}\r\nstatic inline bool skcipher_writable(struct sock *sk)\r\n{\r\nreturn PAGE_SIZE <= skcipher_sndbuf(sk);\r\n}\r\nstatic int skcipher_alloc_sgl(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_sg_list *sgl;\r\nstruct scatterlist *sg = NULL;\r\nsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\r\nif (!list_empty(&ctx->tsgl))\r\nsg = sgl->sg;\r\nif (!sg || sgl->cur >= MAX_SGL_ENTS) {\r\nsgl = sock_kmalloc(sk, sizeof(*sgl) +\r\nsizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),\r\nGFP_KERNEL);\r\nif (!sgl)\r\nreturn -ENOMEM;\r\nsg_init_table(sgl->sg, MAX_SGL_ENTS + 1);\r\nsgl->cur = 0;\r\nif (sg)\r\nscatterwalk_sg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);\r\nlist_add_tail(&sgl->list, &ctx->tsgl);\r\n}\r\nreturn 0;\r\n}\r\nstatic void skcipher_pull_sgl(struct sock *sk, int used)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_sg_list *sgl;\r\nstruct scatterlist *sg;\r\nint i;\r\nwhile (!list_empty(&ctx->tsgl)) {\r\nsgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,\r\nlist);\r\nsg = sgl->sg;\r\nfor (i = 0; i < sgl->cur; i++) {\r\nint plen = min_t(int, used, sg[i].length);\r\nif (!sg_page(sg + i))\r\ncontinue;\r\nsg[i].length -= plen;\r\nsg[i].offset += plen;\r\nused -= plen;\r\nctx->used -= plen;\r\nif (sg[i].length)\r\nreturn;\r\nput_page(sg_page(sg + i));\r\nsg_assign_page(sg + i, NULL);\r\n}\r\nlist_del(&sgl->list);\r\nsock_kfree_s(sk, sgl,\r\nsizeof(*sgl) + sizeof(sgl->sg[0]) *\r\n(MAX_SGL_ENTS + 1));\r\n}\r\nif (!ctx->used)\r\nctx->merge = 0;\r\n}\r\nstatic void skcipher_free_sgl(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nskcipher_pull_sgl(sk, ctx->used);\r\n}\r\nstatic int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\r\n{\r\nlong timeout;\r\nDEFINE_WAIT(wait);\r\nint err = -ERESTARTSYS;\r\nif (flags & MSG_DONTWAIT)\r\nreturn -EAGAIN;\r\nset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\r\nfor (;;) {\r\nif (signal_pending(current))\r\nbreak;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\nif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nreturn err;\r\n}\r\nstatic void skcipher_wmem_wakeup(struct sock *sk)\r\n{\r\nstruct socket_wq *wq;\r\nif (!skcipher_writable(sk))\r\nreturn;\r\nrcu_read_lock();\r\nwq = rcu_dereference(sk->sk_wq);\r\nif (wq_has_sleeper(wq))\r\nwake_up_interruptible_sync_poll(&wq->wait, POLLIN |\r\nPOLLRDNORM |\r\nPOLLRDBAND);\r\nsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\r\nrcu_read_unlock();\r\n}\r\nstatic int skcipher_wait_for_data(struct sock *sk, unsigned flags)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nlong timeout;\r\nDEFINE_WAIT(wait);\r\nint err = -ERESTARTSYS;\r\nif (flags & MSG_DONTWAIT) {\r\nreturn -EAGAIN;\r\n}\r\nset_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\nfor (;;) {\r\nif (signal_pending(current))\r\nbreak;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\nif (sk_wait_event(sk, &timeout, ctx->used)) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nclear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\nreturn err;\r\n}\r\nstatic void skcipher_data_wakeup(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct socket_wq *wq;\r\nif (!ctx->used)\r\nreturn;\r\nrcu_read_lock();\r\nwq = rcu_dereference(sk->sk_wq);\r\nif (wq_has_sleeper(wq))\r\nwake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\r\nPOLLRDNORM |\r\nPOLLRDBAND);\r\nsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\r\nrcu_read_unlock();\r\n}\r\nstatic int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,\r\nstruct msghdr *msg, size_t size)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\r\nunsigned ivsize = crypto_ablkcipher_ivsize(tfm);\r\nstruct skcipher_sg_list *sgl;\r\nstruct af_alg_control con = {};\r\nlong copied = 0;\r\nbool enc = 0;\r\nint err;\r\nint i;\r\nif (msg->msg_controllen) {\r\nerr = af_alg_cmsg_send(msg, &con);\r\nif (err)\r\nreturn err;\r\nswitch (con.op) {\r\ncase ALG_OP_ENCRYPT:\r\nenc = 1;\r\nbreak;\r\ncase ALG_OP_DECRYPT:\r\nenc = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (con.iv && con.iv->ivlen != ivsize)\r\nreturn -EINVAL;\r\n}\r\nerr = -EINVAL;\r\nlock_sock(sk);\r\nif (!ctx->more && ctx->used)\r\ngoto unlock;\r\nif (!ctx->used) {\r\nctx->enc = enc;\r\nif (con.iv)\r\nmemcpy(ctx->iv, con.iv->iv, ivsize);\r\n}\r\nwhile (size) {\r\nstruct scatterlist *sg;\r\nunsigned long len = size;\r\nint plen;\r\nif (ctx->merge) {\r\nsgl = list_entry(ctx->tsgl.prev,\r\nstruct skcipher_sg_list, list);\r\nsg = sgl->sg + sgl->cur - 1;\r\nlen = min_t(unsigned long, len,\r\nPAGE_SIZE - sg->offset - sg->length);\r\nerr = memcpy_fromiovec(page_address(sg_page(sg)) +\r\nsg->offset + sg->length,\r\nmsg->msg_iov, len);\r\nif (err)\r\ngoto unlock;\r\nsg->length += len;\r\nctx->merge = (sg->offset + sg->length) &\r\n(PAGE_SIZE - 1);\r\nctx->used += len;\r\ncopied += len;\r\nsize -= len;\r\ncontinue;\r\n}\r\nif (!skcipher_writable(sk)) {\r\nerr = skcipher_wait_for_wmem(sk, msg->msg_flags);\r\nif (err)\r\ngoto unlock;\r\n}\r\nlen = min_t(unsigned long, len, skcipher_sndbuf(sk));\r\nerr = skcipher_alloc_sgl(sk);\r\nif (err)\r\ngoto unlock;\r\nsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\r\nsg = sgl->sg;\r\ndo {\r\ni = sgl->cur;\r\nplen = min_t(int, len, PAGE_SIZE);\r\nsg_assign_page(sg + i, alloc_page(GFP_KERNEL));\r\nerr = -ENOMEM;\r\nif (!sg_page(sg + i))\r\ngoto unlock;\r\nerr = memcpy_fromiovec(page_address(sg_page(sg + i)),\r\nmsg->msg_iov, plen);\r\nif (err) {\r\n__free_page(sg_page(sg + i));\r\nsg_assign_page(sg + i, NULL);\r\ngoto unlock;\r\n}\r\nsg[i].length = plen;\r\nlen -= plen;\r\nctx->used += plen;\r\ncopied += plen;\r\nsize -= plen;\r\nsgl->cur++;\r\n} while (len && sgl->cur < MAX_SGL_ENTS);\r\nctx->merge = plen & (PAGE_SIZE - 1);\r\n}\r\nerr = 0;\r\nctx->more = msg->msg_flags & MSG_MORE;\r\nif (!ctx->more && !list_empty(&ctx->tsgl))\r\nsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\r\nunlock:\r\nskcipher_data_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn copied ?: err;\r\n}\r\nstatic ssize_t skcipher_sendpage(struct socket *sock, struct page *page,\r\nint offset, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct skcipher_sg_list *sgl;\r\nint err = -EINVAL;\r\nlock_sock(sk);\r\nif (!ctx->more && ctx->used)\r\ngoto unlock;\r\nif (!size)\r\ngoto done;\r\nif (!skcipher_writable(sk)) {\r\nerr = skcipher_wait_for_wmem(sk, flags);\r\nif (err)\r\ngoto unlock;\r\n}\r\nerr = skcipher_alloc_sgl(sk);\r\nif (err)\r\ngoto unlock;\r\nctx->merge = 0;\r\nsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\r\nget_page(page);\r\nsg_set_page(sgl->sg + sgl->cur, page, size, offset);\r\nsgl->cur++;\r\nctx->used += size;\r\ndone:\r\nctx->more = flags & MSG_MORE;\r\nif (!ctx->more && !list_empty(&ctx->tsgl))\r\nsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\r\nunlock:\r\nskcipher_data_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn err ?: size;\r\n}\r\nstatic int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\r\nstruct msghdr *msg, size_t ignored, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\r\n&ctx->req));\r\nstruct skcipher_sg_list *sgl;\r\nstruct scatterlist *sg;\r\nunsigned long iovlen;\r\nstruct iovec *iov;\r\nint err = -EAGAIN;\r\nint used;\r\nlong copied = 0;\r\nlock_sock(sk);\r\nfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\r\niovlen--, iov++) {\r\nunsigned long seglen = iov->iov_len;\r\nchar __user *from = iov->iov_base;\r\nwhile (seglen) {\r\nsgl = list_first_entry(&ctx->tsgl,\r\nstruct skcipher_sg_list, list);\r\nsg = sgl->sg;\r\nwhile (!sg->length)\r\nsg++;\r\nused = ctx->used;\r\nif (!used) {\r\nerr = skcipher_wait_for_data(sk, flags);\r\nif (err)\r\ngoto unlock;\r\n}\r\nused = min_t(unsigned long, used, seglen);\r\nused = af_alg_make_sg(&ctx->rsgl, from, used, 1);\r\nerr = used;\r\nif (err < 0)\r\ngoto unlock;\r\nif (ctx->more || used < ctx->used)\r\nused -= used % bs;\r\nerr = -EINVAL;\r\nif (!used)\r\ngoto free;\r\nablkcipher_request_set_crypt(&ctx->req, sg,\r\nctx->rsgl.sg, used,\r\nctx->iv);\r\nerr = af_alg_wait_for_completion(\r\nctx->enc ?\r\ncrypto_ablkcipher_encrypt(&ctx->req) :\r\ncrypto_ablkcipher_decrypt(&ctx->req),\r\n&ctx->completion);\r\nfree:\r\naf_alg_free_sg(&ctx->rsgl);\r\nif (err)\r\ngoto unlock;\r\ncopied += used;\r\nfrom += used;\r\nseglen -= used;\r\nskcipher_pull_sgl(sk, used);\r\n}\r\n}\r\nerr = 0;\r\nunlock:\r\nskcipher_wmem_wakeup(sk);\r\nrelease_sock(sk);\r\nreturn copied ?: err;\r\n}\r\nstatic unsigned int skcipher_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nunsigned int mask;\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (ctx->used)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (skcipher_writable(sk))\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nreturn mask;\r\n}\r\nstatic void *skcipher_bind(const char *name, u32 type, u32 mask)\r\n{\r\nreturn crypto_alloc_ablkcipher(name, type, mask);\r\n}\r\nstatic void skcipher_release(void *private)\r\n{\r\ncrypto_free_ablkcipher(private);\r\n}\r\nstatic int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\r\n{\r\nreturn crypto_ablkcipher_setkey(private, key, keylen);\r\n}\r\nstatic void skcipher_sock_destruct(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct skcipher_ctx *ctx = ask->private;\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\r\nskcipher_free_sgl(sk);\r\nsock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));\r\nsock_kfree_s(sk, ctx, ctx->len);\r\naf_alg_release_parent(sk);\r\n}\r\nstatic int skcipher_accept_parent(void *private, struct sock *sk)\r\n{\r\nstruct skcipher_ctx *ctx;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nunsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);\r\nctx = sock_kmalloc(sk, len, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),\r\nGFP_KERNEL);\r\nif (!ctx->iv) {\r\nsock_kfree_s(sk, ctx, len);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));\r\nINIT_LIST_HEAD(&ctx->tsgl);\r\nctx->len = len;\r\nctx->used = 0;\r\nctx->more = 0;\r\nctx->merge = 0;\r\nctx->enc = 0;\r\naf_alg_init_completion(&ctx->completion);\r\nask->private = ctx;\r\nablkcipher_request_set_tfm(&ctx->req, private);\r\nablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\naf_alg_complete, &ctx->completion);\r\nsk->sk_destruct = skcipher_sock_destruct;\r\nreturn 0;\r\n}\r\nstatic int __init algif_skcipher_init(void)\r\n{\r\nreturn af_alg_register_type(&algif_type_skcipher);\r\n}\r\nstatic void __exit algif_skcipher_exit(void)\r\n{\r\nint err = af_alg_unregister_type(&algif_type_skcipher);\r\nBUG_ON(err);\r\n}
