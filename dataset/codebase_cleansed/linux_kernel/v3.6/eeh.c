static size_t eeh_gather_pci_data(struct eeh_dev *edev, char * buf, size_t len)\r\n{\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nu32 cfg;\r\nint cap, i;\r\nint n = 0;\r\nn += scnprintf(buf+n, len-n, "%s\n", dn->full_name);\r\nprintk(KERN_WARNING "EEH: of node=%s\n", dn->full_name);\r\neeh_ops->read_config(dn, PCI_VENDOR_ID, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "dev/vend:%08x\n", cfg);\r\nprintk(KERN_WARNING "EEH: PCI device/vendor: %08x\n", cfg);\r\neeh_ops->read_config(dn, PCI_COMMAND, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "cmd/stat:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: PCI cmd/status register: %08x\n", cfg);\r\nif (!dev) {\r\nprintk(KERN_WARNING "EEH: no PCI device for this of node\n");\r\nreturn n;\r\n}\r\nif (dev->class >> 16 == PCI_BASE_CLASS_BRIDGE) {\r\neeh_ops->read_config(dn, PCI_SEC_STATUS, 2, &cfg);\r\nn += scnprintf(buf+n, len-n, "sec stat:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: Bridge secondary status: %04x\n", cfg);\r\neeh_ops->read_config(dn, PCI_BRIDGE_CONTROL, 2, &cfg);\r\nn += scnprintf(buf+n, len-n, "brdg ctl:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: Bridge control: %04x\n", cfg);\r\n}\r\ncap = pci_find_capability(dev, PCI_CAP_ID_PCIX);\r\nif (cap) {\r\neeh_ops->read_config(dn, cap, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "pcix-cmd:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: PCI-X cmd: %08x\n", cfg);\r\neeh_ops->read_config(dn, cap+4, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "pcix-stat:%x\n", cfg);\r\nprintk(KERN_WARNING "EEH: PCI-X status: %08x\n", cfg);\r\n}\r\ncap = pci_find_capability(dev, PCI_CAP_ID_EXP);\r\nif (cap) {\r\nn += scnprintf(buf+n, len-n, "pci-e cap10:\n");\r\nprintk(KERN_WARNING\r\n"EEH: PCI-E capabilities and status follow:\n");\r\nfor (i=0; i<=8; i++) {\r\neeh_ops->read_config(dn, cap+4*i, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "%02x:%x\n", 4*i, cfg);\r\nprintk(KERN_WARNING "EEH: PCI-E %02x: %08x\n", i, cfg);\r\n}\r\ncap = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\nif (cap) {\r\nn += scnprintf(buf+n, len-n, "pci-e AER:\n");\r\nprintk(KERN_WARNING\r\n"EEH: PCI-E AER capability register set follows:\n");\r\nfor (i=0; i<14; i++) {\r\neeh_ops->read_config(dn, cap+4*i, 4, &cfg);\r\nn += scnprintf(buf+n, len-n, "%02x:%x\n", 4*i, cfg);\r\nprintk(KERN_WARNING "EEH: PCI-E AER %02x: %08x\n", i, cfg);\r\n}\r\n}\r\n}\r\nif (dev->class >> 16 == PCI_BASE_CLASS_BRIDGE) {\r\nstruct device_node *child;\r\nfor_each_child_of_node(dn, child) {\r\nif (of_node_to_eeh_dev(child))\r\nn += eeh_gather_pci_data(of_node_to_eeh_dev(child), buf+n, len-n);\r\n}\r\n}\r\nreturn n;\r\n}\r\nvoid eeh_slot_error_detail(struct eeh_dev *edev, int severity)\r\n{\r\nsize_t loglen = 0;\r\npci_regs_buf[0] = 0;\r\neeh_pci_enable(edev, EEH_OPT_THAW_MMIO);\r\neeh_ops->configure_bridge(eeh_dev_to_of_node(edev));\r\neeh_restore_bars(edev);\r\nloglen = eeh_gather_pci_data(edev, pci_regs_buf, EEH_PCI_REGS_LOG_LEN);\r\neeh_ops->get_log(eeh_dev_to_of_node(edev), severity, pci_regs_buf, loglen);\r\n}\r\nstatic inline unsigned long eeh_token_to_phys(unsigned long token)\r\n{\r\npte_t *ptep;\r\nunsigned long pa;\r\nptep = find_linux_pte(init_mm.pgd, token);\r\nif (!ptep)\r\nreturn token;\r\npa = pte_pfn(*ptep) << PAGE_SHIFT;\r\nreturn pa | (token & (PAGE_SIZE-1));\r\n}\r\nstruct device_node *eeh_find_device_pe(struct device_node *dn)\r\n{\r\nwhile (dn->parent && of_node_to_eeh_dev(dn->parent) &&\r\n(of_node_to_eeh_dev(dn->parent)->mode & EEH_MODE_SUPPORTED)) {\r\ndn = dn->parent;\r\n}\r\nreturn dn;\r\n}\r\nstatic void __eeh_mark_slot(struct device_node *parent, int mode_flag)\r\n{\r\nstruct device_node *dn;\r\nfor_each_child_of_node(parent, dn) {\r\nif (of_node_to_eeh_dev(dn)) {\r\nstruct pci_dev *dev = of_node_to_eeh_dev(dn)->pdev;\r\nof_node_to_eeh_dev(dn)->mode |= mode_flag;\r\nif (dev && dev->driver)\r\ndev->error_state = pci_channel_io_frozen;\r\n__eeh_mark_slot(dn, mode_flag);\r\n}\r\n}\r\n}\r\nvoid eeh_mark_slot(struct device_node *dn, int mode_flag)\r\n{\r\nstruct pci_dev *dev;\r\ndn = eeh_find_device_pe(dn);\r\nif (!pcibios_find_pci_bus(dn) && of_node_to_eeh_dev(dn->parent))\r\ndn = dn->parent;\r\nof_node_to_eeh_dev(dn)->mode |= mode_flag;\r\ndev = of_node_to_eeh_dev(dn)->pdev;\r\nif (dev)\r\ndev->error_state = pci_channel_io_frozen;\r\n__eeh_mark_slot(dn, mode_flag);\r\n}\r\nstatic void __eeh_clear_slot(struct device_node *parent, int mode_flag)\r\n{\r\nstruct device_node *dn;\r\nfor_each_child_of_node(parent, dn) {\r\nif (of_node_to_eeh_dev(dn)) {\r\nof_node_to_eeh_dev(dn)->mode &= ~mode_flag;\r\nof_node_to_eeh_dev(dn)->check_count = 0;\r\n__eeh_clear_slot(dn, mode_flag);\r\n}\r\n}\r\n}\r\nvoid eeh_clear_slot(struct device_node *dn, int mode_flag)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&confirm_error_lock, flags);\r\ndn = eeh_find_device_pe(dn);\r\nif (!pcibios_find_pci_bus(dn) && of_node_to_eeh_dev(dn->parent))\r\ndn = dn->parent;\r\nof_node_to_eeh_dev(dn)->mode &= ~mode_flag;\r\nof_node_to_eeh_dev(dn)->check_count = 0;\r\n__eeh_clear_slot(dn, mode_flag);\r\nraw_spin_unlock_irqrestore(&confirm_error_lock, flags);\r\n}\r\nint eeh_dn_check_failure(struct device_node *dn, struct pci_dev *dev)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct eeh_dev *edev;\r\nint rc = 0;\r\nconst char *location;\r\neeh_stats.total_mmio_ffs++;\r\nif (!eeh_subsystem_enabled)\r\nreturn 0;\r\nif (!dn) {\r\neeh_stats.no_dn++;\r\nreturn 0;\r\n}\r\ndn = eeh_find_device_pe(dn);\r\nedev = of_node_to_eeh_dev(dn);\r\nif (!(edev->mode & EEH_MODE_SUPPORTED) ||\r\nedev->mode & EEH_MODE_NOCHECK) {\r\neeh_stats.ignored_check++;\r\npr_debug("EEH: Ignored check (%x) for %s %s\n",\r\nedev->mode, eeh_pci_name(dev), dn->full_name);\r\nreturn 0;\r\n}\r\nif (!edev->config_addr && !edev->pe_config_addr) {\r\neeh_stats.no_cfg_addr++;\r\nreturn 0;\r\n}\r\nraw_spin_lock_irqsave(&confirm_error_lock, flags);\r\nrc = 1;\r\nif (edev->mode & EEH_MODE_ISOLATED) {\r\nedev->check_count++;\r\nif (edev->check_count % EEH_MAX_FAILS == 0) {\r\nlocation = of_get_property(dn, "ibm,loc-code", NULL);\r\nprintk(KERN_ERR "EEH: %d reads ignored for recovering device at "\r\n"location=%s driver=%s pci addr=%s\n",\r\nedev->check_count, location,\r\neeh_driver_name(dev), eeh_pci_name(dev));\r\nprintk(KERN_ERR "EEH: Might be infinite loop in %s driver\n",\r\neeh_driver_name(dev));\r\ndump_stack();\r\n}\r\ngoto dn_unlock;\r\n}\r\nret = eeh_ops->get_state(dn, NULL);\r\nif ((ret < 0) ||\r\n(ret == EEH_STATE_NOT_SUPPORT) ||\r\n(ret & (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) ==\r\n(EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE)) {\r\neeh_stats.false_positives++;\r\nedev->false_positives ++;\r\nrc = 0;\r\ngoto dn_unlock;\r\n}\r\neeh_stats.slot_resets++;\r\neeh_mark_slot(dn, EEH_MODE_ISOLATED);\r\nraw_spin_unlock_irqrestore(&confirm_error_lock, flags);\r\neeh_send_failure_event(edev);\r\nWARN(1, "EEH: failure detected\n");\r\nreturn 1;\r\ndn_unlock:\r\nraw_spin_unlock_irqrestore(&confirm_error_lock, flags);\r\nreturn rc;\r\n}\r\nunsigned long eeh_check_failure(const volatile void __iomem *token, unsigned long val)\r\n{\r\nunsigned long addr;\r\nstruct pci_dev *dev;\r\nstruct device_node *dn;\r\naddr = eeh_token_to_phys((unsigned long __force) token);\r\ndev = pci_addr_cache_get_device(addr);\r\nif (!dev) {\r\neeh_stats.no_device++;\r\nreturn val;\r\n}\r\ndn = pci_device_to_OF_node(dev);\r\neeh_dn_check_failure(dn, dev);\r\npci_dev_put(dev);\r\nreturn val;\r\n}\r\nint eeh_pci_enable(struct eeh_dev *edev, int function)\r\n{\r\nint rc;\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\nrc = eeh_ops->set_option(dn, function);\r\nif (rc)\r\nprintk(KERN_WARNING "EEH: Unexpected state change %d, err=%d dn=%s\n",\r\nfunction, rc, dn->full_name);\r\nrc = eeh_ops->wait_state(dn, PCI_BUS_RESET_WAIT_MSEC);\r\nif (rc > 0 && (rc & EEH_STATE_MMIO_ENABLED) &&\r\n(function == EEH_OPT_THAW_MMIO))\r\nreturn 0;\r\nreturn rc;\r\n}\r\nint pcibios_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)\r\n{\r\nstruct device_node *dn = pci_device_to_OF_node(dev);\r\nswitch (state) {\r\ncase pcie_deassert_reset:\r\neeh_ops->reset(dn, EEH_RESET_DEACTIVATE);\r\nbreak;\r\ncase pcie_hot_reset:\r\neeh_ops->reset(dn, EEH_RESET_HOT);\r\nbreak;\r\ncase pcie_warm_reset:\r\neeh_ops->reset(dn, EEH_RESET_FUNDAMENTAL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nreturn 0;\r\n}\r\nvoid __eeh_set_pe_freset(struct device_node *parent, unsigned int *freset)\r\n{\r\nstruct device_node *dn;\r\nfor_each_child_of_node(parent, dn) {\r\nif (of_node_to_eeh_dev(dn)) {\r\nstruct pci_dev *dev = of_node_to_eeh_dev(dn)->pdev;\r\nif (dev && dev->driver)\r\n*freset |= dev->needs_freset;\r\n__eeh_set_pe_freset(dn, freset);\r\n}\r\n}\r\n}\r\nvoid eeh_set_pe_freset(struct device_node *dn, unsigned int *freset)\r\n{\r\nstruct pci_dev *dev;\r\ndn = eeh_find_device_pe(dn);\r\nif (!pcibios_find_pci_bus(dn) && of_node_to_eeh_dev(dn->parent))\r\ndn = dn->parent;\r\ndev = of_node_to_eeh_dev(dn)->pdev;\r\nif (dev)\r\n*freset |= dev->needs_freset;\r\n__eeh_set_pe_freset(dn, freset);\r\n}\r\nstatic void eeh_reset_pe_once(struct eeh_dev *edev)\r\n{\r\nunsigned int freset = 0;\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\neeh_set_pe_freset(dn, &freset);\r\nif (freset)\r\neeh_ops->reset(dn, EEH_RESET_FUNDAMENTAL);\r\nelse\r\neeh_ops->reset(dn, EEH_RESET_HOT);\r\n#define PCI_BUS_RST_HOLD_TIME_MSEC 250\r\nmsleep(PCI_BUS_RST_HOLD_TIME_MSEC);\r\neeh_clear_slot(dn, EEH_MODE_ISOLATED);\r\neeh_ops->reset(dn, EEH_RESET_DEACTIVATE);\r\n#define PCI_BUS_SETTLE_TIME_MSEC 1800\r\nmsleep(PCI_BUS_SETTLE_TIME_MSEC);\r\n}\r\nint eeh_reset_pe(struct eeh_dev *edev)\r\n{\r\nint i, rc;\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\nfor (i=0; i<3; i++) {\r\neeh_reset_pe_once(edev);\r\nrc = eeh_ops->wait_state(dn, PCI_BUS_RESET_WAIT_MSEC);\r\nif (rc == (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE))\r\nreturn 0;\r\nif (rc < 0) {\r\nprintk(KERN_ERR "EEH: unrecoverable slot failure %s\n",\r\ndn->full_name);\r\nreturn -1;\r\n}\r\nprintk(KERN_ERR "EEH: bus reset %d failed on slot %s, rc=%d\n",\r\ni+1, dn->full_name, rc);\r\n}\r\nreturn -1;\r\n}\r\nstatic inline void eeh_restore_one_device_bars(struct eeh_dev *edev)\r\n{\r\nint i;\r\nu32 cmd;\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\nif (!edev->phb)\r\nreturn;\r\nfor (i=4; i<10; i++) {\r\neeh_ops->write_config(dn, i*4, 4, edev->config_space[i]);\r\n}\r\neeh_ops->write_config(dn, 12*4, 4, edev->config_space[12]);\r\n#define BYTE_SWAP(OFF) (8*((OFF)/4)+3-(OFF))\r\n#define SAVED_BYTE(OFF) (((u8 *)(edev->config_space))[BYTE_SWAP(OFF)])\r\neeh_ops->write_config(dn, PCI_CACHE_LINE_SIZE, 1,\r\nSAVED_BYTE(PCI_CACHE_LINE_SIZE));\r\neeh_ops->write_config(dn, PCI_LATENCY_TIMER, 1,\r\nSAVED_BYTE(PCI_LATENCY_TIMER));\r\neeh_ops->write_config(dn, 15*4, 4, edev->config_space[15]);\r\neeh_ops->read_config(dn, PCI_COMMAND, 4, &cmd);\r\nif (edev->config_space[1] & PCI_COMMAND_PARITY)\r\ncmd |= PCI_COMMAND_PARITY;\r\nelse\r\ncmd &= ~PCI_COMMAND_PARITY;\r\nif (edev->config_space[1] & PCI_COMMAND_SERR)\r\ncmd |= PCI_COMMAND_SERR;\r\nelse\r\ncmd &= ~PCI_COMMAND_SERR;\r\neeh_ops->write_config(dn, PCI_COMMAND, 4, cmd);\r\n}\r\nvoid eeh_restore_bars(struct eeh_dev *edev)\r\n{\r\nstruct device_node *dn;\r\nif (!edev)\r\nreturn;\r\nif ((edev->mode & EEH_MODE_SUPPORTED) && !IS_BRIDGE(edev->class_code))\r\neeh_restore_one_device_bars(edev);\r\nfor_each_child_of_node(eeh_dev_to_of_node(edev), dn)\r\neeh_restore_bars(of_node_to_eeh_dev(dn));\r\n}\r\nstatic void eeh_save_bars(struct eeh_dev *edev)\r\n{\r\nint i;\r\nstruct device_node *dn;\r\nif (!edev)\r\nreturn;\r\ndn = eeh_dev_to_of_node(edev);\r\nfor (i = 0; i < 16; i++)\r\neeh_ops->read_config(dn, i * 4, 4, &edev->config_space[i]);\r\n}\r\nstatic void *eeh_early_enable(struct device_node *dn, void *data)\r\n{\r\nint ret;\r\nconst u32 *class_code = of_get_property(dn, "class-code", NULL);\r\nconst u32 *vendor_id = of_get_property(dn, "vendor-id", NULL);\r\nconst u32 *device_id = of_get_property(dn, "device-id", NULL);\r\nconst u32 *regs;\r\nint enable;\r\nstruct eeh_dev *edev = of_node_to_eeh_dev(dn);\r\nedev->class_code = 0;\r\nedev->mode = 0;\r\nedev->check_count = 0;\r\nedev->freeze_count = 0;\r\nedev->false_positives = 0;\r\nif (!of_device_is_available(dn))\r\nreturn NULL;\r\nif (!class_code || !vendor_id || !device_id)\r\nreturn NULL;\r\nif (dn->type && !strcmp(dn->type, "isa")) {\r\nedev->mode |= EEH_MODE_NOCHECK;\r\nreturn NULL;\r\n}\r\nedev->class_code = *class_code;\r\nregs = of_get_property(dn, "reg", NULL);\r\nif (regs) {\r\nret = eeh_ops->set_option(dn, EEH_OPT_ENABLE);\r\nenable = 0;\r\nif (ret == 0) {\r\nedev->config_addr = regs[0];\r\nedev->pe_config_addr = eeh_ops->get_pe_addr(dn);\r\nret = eeh_ops->get_state(dn, NULL);\r\nif (ret > 0 && ret != EEH_STATE_NOT_SUPPORT)\r\nenable = 1;\r\n}\r\nif (enable) {\r\neeh_subsystem_enabled = 1;\r\nedev->mode |= EEH_MODE_SUPPORTED;\r\npr_debug("EEH: %s: eeh enabled, config=%x pe_config=%x\n",\r\ndn->full_name, edev->config_addr,\r\nedev->pe_config_addr);\r\n} else {\r\nif (dn->parent && of_node_to_eeh_dev(dn->parent) &&\r\n(of_node_to_eeh_dev(dn->parent)->mode & EEH_MODE_SUPPORTED)) {\r\nedev->mode |= EEH_MODE_SUPPORTED;\r\nedev->config_addr = of_node_to_eeh_dev(dn->parent)->config_addr;\r\nreturn NULL;\r\n}\r\n}\r\n} else {\r\nprintk(KERN_WARNING "EEH: %s: unable to get reg property.\n",\r\ndn->full_name);\r\n}\r\neeh_save_bars(edev);\r\nreturn NULL;\r\n}\r\nint __init eeh_ops_register(struct eeh_ops *ops)\r\n{\r\nif (!ops->name) {\r\npr_warning("%s: Invalid EEH ops name for %p\n",\r\n__func__, ops);\r\nreturn -EINVAL;\r\n}\r\nif (eeh_ops && eeh_ops != ops) {\r\npr_warning("%s: EEH ops of platform %s already existing (%s)\n",\r\n__func__, eeh_ops->name, ops->name);\r\nreturn -EEXIST;\r\n}\r\neeh_ops = ops;\r\nreturn 0;\r\n}\r\nint __exit eeh_ops_unregister(const char *name)\r\n{\r\nif (!name || !strlen(name)) {\r\npr_warning("%s: Invalid EEH ops name\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (eeh_ops && !strcmp(eeh_ops->name, name)) {\r\neeh_ops = NULL;\r\nreturn 0;\r\n}\r\nreturn -EEXIST;\r\n}\r\nvoid __init eeh_init(void)\r\n{\r\nstruct pci_controller *hose, *tmp;\r\nstruct device_node *phb;\r\nint ret;\r\nif (!eeh_ops) {\r\npr_warning("%s: Platform EEH operation not found\n",\r\n__func__);\r\nreturn;\r\n} else if ((ret = eeh_ops->init())) {\r\npr_warning("%s: Failed to call platform init function (%d)\n",\r\n__func__, ret);\r\nreturn;\r\n}\r\nraw_spin_lock_init(&confirm_error_lock);\r\nlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\r\nphb = hose->dn;\r\ntraverse_pci_devices(phb, eeh_early_enable, NULL);\r\n}\r\nif (eeh_subsystem_enabled)\r\nprintk(KERN_INFO "EEH: PCI Enhanced I/O Error Handling Enabled\n");\r\nelse\r\nprintk(KERN_WARNING "EEH: No capable adapters found\n");\r\n}\r\nstatic void eeh_add_device_early(struct device_node *dn)\r\n{\r\nstruct pci_controller *phb;\r\nif (!dn || !of_node_to_eeh_dev(dn))\r\nreturn;\r\nphb = of_node_to_eeh_dev(dn)->phb;\r\nif (NULL == phb || 0 == phb->buid)\r\nreturn;\r\neeh_early_enable(dn, NULL);\r\n}\r\nvoid eeh_add_device_tree_early(struct device_node *dn)\r\n{\r\nstruct device_node *sib;\r\nfor_each_child_of_node(dn, sib)\r\neeh_add_device_tree_early(sib);\r\neeh_add_device_early(dn);\r\n}\r\nstatic void eeh_add_device_late(struct pci_dev *dev)\r\n{\r\nstruct device_node *dn;\r\nstruct eeh_dev *edev;\r\nif (!dev || !eeh_subsystem_enabled)\r\nreturn;\r\npr_debug("EEH: Adding device %s\n", pci_name(dev));\r\ndn = pci_device_to_OF_node(dev);\r\nedev = of_node_to_eeh_dev(dn);\r\nif (edev->pdev == dev) {\r\npr_debug("EEH: Already referenced !\n");\r\nreturn;\r\n}\r\nWARN_ON(edev->pdev);\r\npci_dev_get(dev);\r\nedev->pdev = dev;\r\ndev->dev.archdata.edev = edev;\r\npci_addr_cache_insert_device(dev);\r\neeh_sysfs_add_device(dev);\r\n}\r\nvoid eeh_add_device_tree_late(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\neeh_add_device_late(dev);\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\nstruct pci_bus *subbus = dev->subordinate;\r\nif (subbus)\r\neeh_add_device_tree_late(subbus);\r\n}\r\n}\r\n}\r\nstatic void eeh_remove_device(struct pci_dev *dev)\r\n{\r\nstruct eeh_dev *edev;\r\nif (!dev || !eeh_subsystem_enabled)\r\nreturn;\r\nedev = pci_dev_to_eeh_dev(dev);\r\npr_debug("EEH: Removing device %s\n", pci_name(dev));\r\nif (!edev || !edev->pdev) {\r\npr_debug("EEH: Not referenced !\n");\r\nreturn;\r\n}\r\nedev->pdev = NULL;\r\ndev->dev.archdata.edev = NULL;\r\npci_dev_put(dev);\r\npci_addr_cache_remove_device(dev);\r\neeh_sysfs_remove_device(dev);\r\n}\r\nvoid eeh_remove_bus_device(struct pci_dev *dev)\r\n{\r\nstruct pci_bus *bus = dev->subordinate;\r\nstruct pci_dev *child, *tmp;\r\neeh_remove_device(dev);\r\nif (bus && dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\nlist_for_each_entry_safe(child, tmp, &bus->devices, bus_list)\r\neeh_remove_bus_device(child);\r\n}\r\n}\r\nstatic int proc_eeh_show(struct seq_file *m, void *v)\r\n{\r\nif (0 == eeh_subsystem_enabled) {\r\nseq_printf(m, "EEH Subsystem is globally disabled\n");\r\nseq_printf(m, "eeh_total_mmio_ffs=%llu\n", eeh_stats.total_mmio_ffs);\r\n} else {\r\nseq_printf(m, "EEH Subsystem is enabled\n");\r\nseq_printf(m,\r\n"no device=%llu\n"\r\n"no device node=%llu\n"\r\n"no config address=%llu\n"\r\n"check not wanted=%llu\n"\r\n"eeh_total_mmio_ffs=%llu\n"\r\n"eeh_false_positives=%llu\n"\r\n"eeh_slot_resets=%llu\n",\r\neeh_stats.no_device,\r\neeh_stats.no_dn,\r\neeh_stats.no_cfg_addr,\r\neeh_stats.ignored_check,\r\neeh_stats.total_mmio_ffs,\r\neeh_stats.false_positives,\r\neeh_stats.slot_resets);\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_eeh_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_eeh_show, NULL);\r\n}\r\nstatic int __init eeh_init_proc(void)\r\n{\r\nif (machine_is(pseries))\r\nproc_create("powerpc/eeh", 0, NULL, &proc_eeh_operations);\r\nreturn 0;\r\n}
