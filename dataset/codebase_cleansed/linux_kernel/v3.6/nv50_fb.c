static void\r\nnv50_fb_destroy(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fb_engine *pfb = &dev_priv->engine.fb;\r\nstruct nv50_fb_priv *priv = pfb->priv;\r\nif (drm_mm_initialized(&pfb->tag_heap))\r\ndrm_mm_takedown(&pfb->tag_heap);\r\nif (priv->r100c08_page) {\r\npci_unmap_page(dev->pdev, priv->r100c08, PAGE_SIZE,\r\nPCI_DMA_BIDIRECTIONAL);\r\n__free_page(priv->r100c08_page);\r\n}\r\nkfree(priv);\r\npfb->priv = NULL;\r\n}\r\nstatic int\r\nnv50_fb_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fb_engine *pfb = &dev_priv->engine.fb;\r\nstruct nv50_fb_priv *priv;\r\nu32 tagmem;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npfb->priv = priv;\r\npriv->r100c08_page = alloc_page(GFP_KERNEL | __GFP_ZERO);\r\nif (!priv->r100c08_page) {\r\nnv50_fb_destroy(dev);\r\nreturn -ENOMEM;\r\n}\r\npriv->r100c08 = pci_map_page(dev->pdev, priv->r100c08_page, 0,\r\nPAGE_SIZE, PCI_DMA_BIDIRECTIONAL);\r\nif (pci_dma_mapping_error(dev->pdev, priv->r100c08)) {\r\nnv50_fb_destroy(dev);\r\nreturn -EFAULT;\r\n}\r\ntagmem = nv_rd32(dev, 0x100320);\r\nNV_DEBUG(dev, "%d tags available\n", tagmem);\r\nret = drm_mm_init(&pfb->tag_heap, 0, tagmem);\r\nif (ret) {\r\nnv50_fb_destroy(dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnv50_fb_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_fb_priv *priv;\r\nint ret;\r\nif (!dev_priv->engine.fb.priv) {\r\nret = nv50_fb_create(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\npriv = dev_priv->engine.fb.priv;\r\nnv_wr32(dev, 0x100c08, priv->r100c08 >> 8);\r\nswitch (dev_priv->chipset) {\r\ncase 0x50:\r\nnv_wr32(dev, 0x100c90, 0x000707ff);\r\nbreak;\r\ncase 0xa3:\r\ncase 0xa5:\r\ncase 0xa8:\r\nnv_wr32(dev, 0x100c90, 0x000d0fff);\r\nbreak;\r\ncase 0xaf:\r\nnv_wr32(dev, 0x100c90, 0x089d1fff);\r\nbreak;\r\ndefault:\r\nnv_wr32(dev, 0x100c90, 0x001d07ff);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_fb_takedown(struct drm_device *dev)\r\n{\r\nnv50_fb_destroy(dev);\r\n}\r\nvoid\r\nnv50_fb_vm_trap(struct drm_device *dev, int display)\r\n{\r\nstruct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nconst struct nouveau_enum *en, *cl;\r\nunsigned long flags;\r\nu32 trap[6], idx, chinst;\r\nu8 st0, st1, st2, st3;\r\nint i, ch;\r\nidx = nv_rd32(dev, 0x100c90);\r\nif (!(idx & 0x80000000))\r\nreturn;\r\nidx &= 0x00ffffff;\r\nfor (i = 0; i < 6; i++) {\r\nnv_wr32(dev, 0x100c90, idx | i << 24);\r\ntrap[i] = nv_rd32(dev, 0x100c94);\r\n}\r\nnv_wr32(dev, 0x100c90, idx | 0x80000000);\r\nif (!display)\r\nreturn;\r\nchinst = (trap[2] << 16) | trap[1];\r\nspin_lock_irqsave(&dev_priv->channels.lock, flags);\r\nfor (ch = 0; ch < pfifo->channels; ch++) {\r\nstruct nouveau_channel *chan = dev_priv->channels.ptr[ch];\r\nif (!chan || !chan->ramin)\r\ncontinue;\r\nif (chinst == chan->ramin->vinst >> 12)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dev_priv->channels.lock, flags);\r\nif (dev_priv->chipset < 0xa3 ||\r\ndev_priv->chipset == 0xaa || dev_priv->chipset == 0xac) {\r\nst0 = (trap[0] & 0x0000000f) >> 0;\r\nst1 = (trap[0] & 0x000000f0) >> 4;\r\nst2 = (trap[0] & 0x00000f00) >> 8;\r\nst3 = (trap[0] & 0x0000f000) >> 12;\r\n} else {\r\nst0 = (trap[0] & 0x000000ff) >> 0;\r\nst1 = (trap[0] & 0x0000ff00) >> 8;\r\nst2 = (trap[0] & 0x00ff0000) >> 16;\r\nst3 = (trap[0] & 0xff000000) >> 24;\r\n}\r\nNV_INFO(dev, "VM: trapped %s at 0x%02x%04x%04x on ch %d [0x%08x] ",\r\n(trap[5] & 0x00000100) ? "read" : "write",\r\ntrap[5] & 0xff, trap[4] & 0xffff, trap[3] & 0xffff, ch, chinst);\r\nen = nouveau_enum_find(vm_engine, st0);\r\nif (en)\r\nprintk("%s/", en->name);\r\nelse\r\nprintk("%02x/", st0);\r\ncl = nouveau_enum_find(vm_client, st2);\r\nif (cl)\r\nprintk("%s/", cl->name);\r\nelse\r\nprintk("%02x/", st2);\r\nif (cl && cl->data) cl = nouveau_enum_find(cl->data, st3);\r\nelse if (en && en->data) cl = nouveau_enum_find(en->data, st3);\r\nelse cl = NULL;\r\nif (cl)\r\nprintk("%s", cl->name);\r\nelse\r\nprintk("%02x", st3);\r\nprintk(" reason: ");\r\nen = nouveau_enum_find(vm_fault, st1);\r\nif (en)\r\nprintk("%s\n", en->name);\r\nelse\r\nprintk("0x%08x\n", st1);\r\n}
