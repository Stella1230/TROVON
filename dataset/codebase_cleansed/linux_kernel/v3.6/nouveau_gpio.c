static u8 *\r\ndcb_gpio_table(struct drm_device *dev)\r\n{\r\nu8 *dcb = dcb_table(dev);\r\nif (dcb) {\r\nif (dcb[0] >= 0x30 && dcb[1] >= 0x0c)\r\nreturn ROMPTR(dev, dcb[0x0a]);\r\nif (dcb[0] >= 0x22 && dcb[-1] >= 0x13)\r\nreturn ROMPTR(dev, dcb[-15]);\r\n}\r\nreturn NULL;\r\n}\r\nstatic u8 *\r\ndcb_gpio_entry(struct drm_device *dev, int idx, int ent, u8 *version)\r\n{\r\nu8 *table = dcb_gpio_table(dev);\r\nif (table) {\r\n*version = table[0];\r\nif (*version < 0x30 && ent < table[2])\r\nreturn table + 3 + (ent * table[1]);\r\nelse if (ent < table[2])\r\nreturn table + table[1] + (ent * table[3]);\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nnouveau_gpio_drive(struct drm_device *dev, int idx, int line, int dir, int out)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nreturn pgpio->drive ? pgpio->drive(dev, line, dir, out) : -ENODEV;\r\n}\r\nint\r\nnouveau_gpio_sense(struct drm_device *dev, int idx, int line)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nreturn pgpio->sense ? pgpio->sense(dev, line) : -ENODEV;\r\n}\r\nint\r\nnouveau_gpio_find(struct drm_device *dev, int idx, u8 func, u8 line,\r\nstruct gpio_func *gpio)\r\n{\r\nu8 *table, *entry, version;\r\nint i = -1;\r\nif (line == 0xff && func == 0xff)\r\nreturn -EINVAL;\r\nwhile ((entry = dcb_gpio_entry(dev, idx, ++i, &version))) {\r\nif (version < 0x40) {\r\nu16 data = ROM16(entry[0]);\r\n*gpio = (struct gpio_func) {\r\n.line = (data & 0x001f) >> 0,\r\n.func = (data & 0x07e0) >> 5,\r\n.log[0] = (data & 0x1800) >> 11,\r\n.log[1] = (data & 0x6000) >> 13,\r\n};\r\n} else\r\nif (version < 0x41) {\r\n*gpio = (struct gpio_func) {\r\n.line = entry[0] & 0x1f,\r\n.func = entry[1],\r\n.log[0] = (entry[3] & 0x18) >> 3,\r\n.log[1] = (entry[3] & 0x60) >> 5,\r\n};\r\n} else {\r\n*gpio = (struct gpio_func) {\r\n.line = entry[0] & 0x3f,\r\n.func = entry[1],\r\n.log[0] = (entry[4] & 0x30) >> 4,\r\n.log[1] = (entry[4] & 0xc0) >> 6,\r\n};\r\n}\r\nif ((line == 0xff || line == gpio->line) &&\r\n(func == 0xff || func == gpio->func))\r\nreturn 0;\r\n}\r\nif ((table = dcb_table(dev)) && table[0] >= 0x22) {\r\nif (func == DCB_GPIO_TVDAC0) {\r\n*gpio = (struct gpio_func) {\r\n.func = DCB_GPIO_TVDAC0,\r\n.line = table[-4] >> 4,\r\n.log[0] = !!(table[-5] & 2),\r\n.log[1] = !(table[-5] & 2),\r\n};\r\nreturn 0;\r\n}\r\n}\r\nif (nv_match_device(dev, 0x0189, 0x10de, 0x0010)) {\r\nif (func == DCB_GPIO_TVDAC0) {\r\n*gpio = (struct gpio_func) {\r\n.func = DCB_GPIO_TVDAC0,\r\n.line = 4,\r\n.log[0] = 0,\r\n.log[1] = 1,\r\n};\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint\r\nnouveau_gpio_set(struct drm_device *dev, int idx, u8 tag, u8 line, int state)\r\n{\r\nstruct gpio_func gpio;\r\nint ret;\r\nret = nouveau_gpio_find(dev, idx, tag, line, &gpio);\r\nif (ret == 0) {\r\nint dir = !!(gpio.log[state] & 0x02);\r\nint out = !!(gpio.log[state] & 0x01);\r\nret = nouveau_gpio_drive(dev, idx, gpio.line, dir, out);\r\n}\r\nreturn ret;\r\n}\r\nint\r\nnouveau_gpio_get(struct drm_device *dev, int idx, u8 tag, u8 line)\r\n{\r\nstruct gpio_func gpio;\r\nint ret;\r\nret = nouveau_gpio_find(dev, idx, tag, line, &gpio);\r\nif (ret == 0) {\r\nret = nouveau_gpio_sense(dev, idx, gpio.line);\r\nif (ret >= 0)\r\nret = (ret == (gpio.log[1] & 1));\r\n}\r\nreturn ret;\r\n}\r\nint\r\nnouveau_gpio_irq(struct drm_device *dev, int idx, u8 tag, u8 line, bool on)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct gpio_func gpio;\r\nint ret;\r\nret = nouveau_gpio_find(dev, idx, tag, line, &gpio);\r\nif (ret == 0) {\r\nif (idx == 0 && pgpio->irq_enable)\r\npgpio->irq_enable(dev, gpio.line, on);\r\nelse\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nnouveau_gpio_isr_bh(struct work_struct *work)\r\n{\r\nstruct gpio_isr *isr = container_of(work, struct gpio_isr, work);\r\nstruct drm_device *dev = isr->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nunsigned long flags;\r\nint state;\r\nstate = nouveau_gpio_get(dev, isr->idx, isr->func.func, isr->func.line);\r\nif (state >= 0)\r\nisr->handler(isr->data, state);\r\nspin_lock_irqsave(&pgpio->lock, flags);\r\nisr->inhibit = false;\r\nspin_unlock_irqrestore(&pgpio->lock, flags);\r\n}\r\nvoid\r\nnouveau_gpio_isr(struct drm_device *dev, int idx, u32 line_mask)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct gpio_isr *isr;\r\nif (idx != 0)\r\nreturn;\r\nspin_lock(&pgpio->lock);\r\nlist_for_each_entry(isr, &pgpio->isr, head) {\r\nif (line_mask & (1 << isr->func.line)) {\r\nif (isr->inhibit)\r\ncontinue;\r\nisr->inhibit = true;\r\nschedule_work(&isr->work);\r\n}\r\n}\r\nspin_unlock(&pgpio->lock);\r\n}\r\nint\r\nnouveau_gpio_isr_add(struct drm_device *dev, int idx, u8 tag, u8 line,\r\nvoid (*handler)(void *, int), void *data)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct gpio_isr *isr;\r\nunsigned long flags;\r\nint ret;\r\nisr = kzalloc(sizeof(*isr), GFP_KERNEL);\r\nif (!isr)\r\nreturn -ENOMEM;\r\nret = nouveau_gpio_find(dev, idx, tag, line, &isr->func);\r\nif (ret) {\r\nkfree(isr);\r\nreturn ret;\r\n}\r\nINIT_WORK(&isr->work, nouveau_gpio_isr_bh);\r\nisr->dev = dev;\r\nisr->handler = handler;\r\nisr->data = data;\r\nisr->idx = idx;\r\nspin_lock_irqsave(&pgpio->lock, flags);\r\nlist_add(&isr->head, &pgpio->isr);\r\nspin_unlock_irqrestore(&pgpio->lock, flags);\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_gpio_isr_del(struct drm_device *dev, int idx, u8 tag, u8 line,\r\nvoid (*handler)(void *, int), void *data)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nstruct gpio_isr *isr, *tmp;\r\nstruct gpio_func func;\r\nunsigned long flags;\r\nLIST_HEAD(tofree);\r\nint ret;\r\nret = nouveau_gpio_find(dev, idx, tag, line, &func);\r\nif (ret == 0) {\r\nspin_lock_irqsave(&pgpio->lock, flags);\r\nlist_for_each_entry_safe(isr, tmp, &pgpio->isr, head) {\r\nif (memcmp(&isr->func, &func, sizeof(func)) ||\r\nisr->idx != idx ||\r\nisr->handler != handler || isr->data != data)\r\ncontinue;\r\nlist_move(&isr->head, &tofree);\r\n}\r\nspin_unlock_irqrestore(&pgpio->lock, flags);\r\nlist_for_each_entry_safe(isr, tmp, &tofree, head) {\r\nflush_work_sync(&isr->work);\r\nkfree(isr);\r\n}\r\n}\r\n}\r\nint\r\nnouveau_gpio_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nINIT_LIST_HEAD(&pgpio->isr);\r\nspin_lock_init(&pgpio->lock);\r\nreturn nouveau_gpio_init(dev);\r\n}\r\nvoid\r\nnouveau_gpio_destroy(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nnouveau_gpio_fini(dev);\r\nBUG_ON(!list_empty(&pgpio->isr));\r\n}\r\nint\r\nnouveau_gpio_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nint ret = 0;\r\nif (pgpio->init)\r\nret = pgpio->init(dev);\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_gpio_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;\r\nif (pgpio->fini)\r\npgpio->fini(dev);\r\n}\r\nvoid\r\nnouveau_gpio_reset(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu8 *entry, version;\r\nint ent = -1;\r\nwhile ((entry = dcb_gpio_entry(dev, 0, ++ent, &version))) {\r\nu8 func = 0xff, line, defs, unk0, unk1;\r\nif (version >= 0x41) {\r\ndefs = !!(entry[0] & 0x80);\r\nline = entry[0] & 0x3f;\r\nfunc = entry[1];\r\nunk0 = entry[2];\r\nunk1 = entry[3] & 0x1f;\r\n} else\r\nif (version >= 0x40) {\r\nline = entry[0] & 0x1f;\r\nfunc = entry[1];\r\ndefs = !!(entry[3] & 0x01);\r\nunk0 = !!(entry[3] & 0x02);\r\nunk1 = !!(entry[3] & 0x04);\r\n} else {\r\nbreak;\r\n}\r\nif (func == 0xff)\r\ncontinue;\r\nnouveau_gpio_func_set(dev, func, defs);\r\nif (dev_priv->card_type >= NV_D0) {\r\nnv_mask(dev, 0x00d610 + (line * 4), 0xff, unk0);\r\nif (unk1--)\r\nnv_mask(dev, 0x00d740 + (unk1 * 4), 0xff, line);\r\n} else\r\nif (dev_priv->card_type >= NV_50) {\r\nstatic const u32 regs[] = { 0xe100, 0xe28c };\r\nu32 val = (unk1 << 16) | unk0;\r\nu32 reg = regs[line >> 4]; line &= 0x0f;\r\nnv_mask(dev, reg, 0x00010001 << line, val << line);\r\n}\r\n}\r\n}
