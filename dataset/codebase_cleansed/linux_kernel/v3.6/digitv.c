static int digitv_ctrl_msg(struct dvb_usb_device *d,\r\nu8 cmd, u8 vv, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nint wo = (rbuf == NULL || rlen == 0);\r\nu8 sndbuf[7],rcvbuf[7];\r\nmemset(sndbuf,0,7); memset(rcvbuf,0,7);\r\nsndbuf[0] = cmd;\r\nsndbuf[1] = vv;\r\nsndbuf[2] = wo ? wlen : rlen;\r\nif (wo) {\r\nmemcpy(&sndbuf[3],wbuf,wlen);\r\ndvb_usb_generic_write(d,sndbuf,7);\r\n} else {\r\ndvb_usb_generic_rw(d,sndbuf,7,rcvbuf,7,10);\r\nmemcpy(rbuf,&rcvbuf[3],rlen);\r\n}\r\nreturn 0;\r\n}\r\nstatic int digitv_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (num > 2)\r\nwarn("more than 2 i2c messages at a time is not handled yet. TODO.");\r\nfor (i = 0; i < num; i++) {\r\nif (i+1 < num && (msg[i+1].flags & I2C_M_RD)) {\r\nif (digitv_ctrl_msg(d, USB_READ_COFDM, msg[i].buf[0], NULL, 0,\r\nmsg[i+1].buf,msg[i+1].len) < 0)\r\nbreak;\r\ni++;\r\n} else\r\nif (digitv_ctrl_msg(d,USB_WRITE_COFDM, msg[i].buf[0],\r\n&msg[i].buf[1],msg[i].len-1,NULL,0) < 0)\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic u32 digitv_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int digitv_identify_state (struct usb_device *udev, struct\r\ndvb_usb_device_properties *props, struct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\n*cold = udev->descriptor.iManufacturer == 0 && udev->descriptor.iProduct == 0;\r\nreturn 0;\r\n}\r\nstatic int digitv_mt352_demod_init(struct dvb_frontend *fe)\r\n{\r\nstatic u8 reset_buf[] = { 0x89, 0x38, 0x8a, 0x2d, 0x50, 0x80 };\r\nstatic u8 init_buf[] = { 0x68, 0xa0, 0x8e, 0x40, 0x53, 0x50,\r\n0x67, 0x20, 0x7d, 0x01, 0x7c, 0x00, 0x7a, 0x00,\r\n0x79, 0x20, 0x57, 0x05, 0x56, 0x31, 0x88, 0x0f,\r\n0x75, 0x32 };\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reset_buf); i += 2)\r\nmt352_write(fe, &reset_buf[i], 2);\r\nmsleep(1);\r\nfor (i = 0; i < ARRAY_SIZE(init_buf); i += 2)\r\nmt352_write(fe, &init_buf[i], 2);\r\nreturn 0;\r\n}\r\nstatic int digitv_nxt6000_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nu8 b[5];\r\nfe->ops.tuner_ops.calc_regs(fe, b, sizeof(b));\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nreturn digitv_ctrl_msg(adap->dev, USB_WRITE_TUNER, 0, &b[1], 4, NULL, 0);\r\n}\r\nstatic int digitv_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct digitv_state *st = adap->dev->priv;\r\nadap->fe_adap[0].fe = dvb_attach(mt352_attach, &digitv_mt352_config,\r\n&adap->dev->i2c_adap);\r\nif ((adap->fe_adap[0].fe) != NULL) {\r\nst->is_nxt6000 = 0;\r\nreturn 0;\r\n}\r\nadap->fe_adap[0].fe = dvb_attach(nxt6000_attach,\r\n&digitv_nxt6000_config,\r\n&adap->dev->i2c_adap);\r\nif ((adap->fe_adap[0].fe) != NULL) {\r\nst->is_nxt6000 = 1;\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int digitv_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct digitv_state *st = adap->dev->priv;\r\nif (!dvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60, NULL, DVB_PLL_TDED4))\r\nreturn -ENODEV;\r\nif (st->is_nxt6000)\r\nadap->fe_adap[0].fe->ops.tuner_ops.set_params = digitv_nxt6000_tuner_set_params;\r\nreturn 0;\r\n}\r\nstatic int digitv_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nint i;\r\nu8 key[5];\r\nu8 b[4] = { 0 };\r\n*event = 0;\r\n*state = REMOTE_NO_KEY_PRESSED;\r\ndigitv_ctrl_msg(d,USB_READ_REMOTE,0,NULL,0,&key[1],4);\r\ndigitv_ctrl_msg(d,USB_WRITE_REMOTE,0,b,4,NULL,0);\r\nif (key[1] != 0)\r\n{\r\nfor (i = 0; i < d->props.rc.legacy.rc_map_size; i++) {\r\nif (rc5_custom(&d->props.rc.legacy.rc_map_table[i]) == key[1] &&\r\nrc5_data(&d->props.rc.legacy.rc_map_table[i]) == key[2]) {\r\n*event = d->props.rc.legacy.rc_map_table[i].keycode;\r\n*state = REMOTE_KEY_PRESSED;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (key[0] != 0)\r\ndeb_rc("key: %x %x %x %x %x\n",key[0],key[1],key[2],key[3],key[4]);\r\nreturn 0;\r\n}\r\nstatic int digitv_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct dvb_usb_device *d;\r\nint ret = dvb_usb_device_init(intf, &digitv_properties, THIS_MODULE, &d,\r\nadapter_nr);\r\nif (ret == 0) {\r\nu8 b[4] = { 0 };\r\nif (d != NULL) {\r\nb[0] = 1;\r\ndigitv_ctrl_msg(d,USB_WRITE_REMOTE_TYPE,0,b,4,NULL,0);\r\nb[0] = 0;\r\ndigitv_ctrl_msg(d,USB_WRITE_REMOTE,0,b,4,NULL,0);\r\n}\r\n}\r\nreturn ret;\r\n}
