rt_status\r\nSendTxCommandPacket(\r\nstruct net_device *dev,\r\nvoid* pData,\r\nu32 DataLen\r\n)\r\n{\r\nrt_status rtStatus = RT_STATUS_SUCCESS;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct sk_buff *skb;\r\ncb_desc *tcb_desc;\r\nunsigned char *ptr_buf;\r\nskb = dev_alloc_skb(USB_HWDESC_HEADER_LEN + DataLen + 4);\r\nmemcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));\r\ntcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;\r\ntcb_desc->bLastIniPkt = 0;\r\nskb_reserve(skb, USB_HWDESC_HEADER_LEN);\r\nptr_buf = skb_put(skb, DataLen);\r\nmemcpy(ptr_buf,pData,DataLen);\r\ntcb_desc->txbuf_size= (u16)DataLen;\r\nif(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||\r\n(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\\r\n(priv->ieee80211->queue_stop) ) {\r\nRT_TRACE(COMP_FIRMWARE,"===================NULL packet==================================> tx full!\n");\r\nskb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);\r\n} else {\r\npriv->ieee80211->softmac_hard_start_xmit(skb,dev);\r\n}\r\nreturn rtStatus;\r\n}\r\nextern rt_status cmpk_message_handle_tx(\r\nstruct net_device *dev,\r\nu8* codevirtualaddress,\r\nu32 packettype,\r\nu32 buffer_len)\r\n{\r\nbool rt_status = true;\r\n#ifdef RTL8192U\r\nreturn rt_status;\r\n#else\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu16 frag_threshold;\r\nu16 frag_length, frag_offset = 0;\r\nrt_firmware *pfirmware = priv->pFirmware;\r\nstruct sk_buff *skb;\r\nunsigned char *seg_ptr;\r\ncb_desc *tcb_desc;\r\nu8 bLastIniPkt;\r\nfirmware_init_param(dev);\r\nfrag_threshold = pfirmware->cmdpacket_frag_thresold;\r\ndo {\r\nif((buffer_len - frag_offset) > frag_threshold) {\r\nfrag_length = frag_threshold ;\r\nbLastIniPkt = 0;\r\n} else {\r\nfrag_length = buffer_len - frag_offset;\r\nbLastIniPkt = 1;\r\n}\r\n#ifdef RTL8192U\r\nskb = dev_alloc_skb(USB_HWDESC_HEADER_LEN + frag_length + 4);\r\n#else\r\nskb = dev_alloc_skb(frag_length + 4);\r\n#endif\r\nmemcpy((unsigned char *)(skb->cb),&dev,sizeof(dev));\r\ntcb_desc = (cb_desc*)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->bCmdOrInit = packettype;\r\ntcb_desc->bLastIniPkt = bLastIniPkt;\r\n#ifdef RTL8192U\r\nskb_reserve(skb, USB_HWDESC_HEADER_LEN);\r\n#endif\r\nseg_ptr = skb_put(skb, buffer_len);\r\nmemcpy(seg_ptr,codevirtualaddress,buffer_len);\r\ntcb_desc->txbuf_size= (u16)buffer_len;\r\nif(!priv->ieee80211->check_nic_enough_desc(dev,tcb_desc->queue_index)||\r\n(!skb_queue_empty(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index]))||\\r\n(priv->ieee80211->queue_stop) ) {\r\nRT_TRACE(COMP_FIRMWARE,"=====================================================> tx full!\n");\r\nskb_queue_tail(&priv->ieee80211->skb_waitQ[tcb_desc->queue_index], skb);\r\n} else {\r\npriv->ieee80211->softmac_hard_start_xmit(skb,dev);\r\n}\r\ncodevirtualaddress += frag_length;\r\nfrag_offset += frag_length;\r\n}while(frag_offset < buffer_len);\r\nreturn rt_status;\r\n#endif\r\n}\r\nstatic void\r\ncmpk_count_txstatistic(\r\nstruct net_device *dev,\r\ncmpk_txfb_t *pstx_fb)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\n#ifdef ENABLE_PS\r\nRT_RF_POWER_STATE rtState;\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\n{\r\nreturn;\r\n}\r\n#endif\r\n#ifdef TODO\r\nif(pAdapter->bInHctTest)\r\nreturn;\r\n#endif\r\nif (pstx_fb->tok)\r\n{\r\npriv->stats.txfeedbackok++;\r\npriv->stats.txoktotal++;\r\npriv->stats.txokbytestotal += pstx_fb->pkt_length;\r\npriv->stats.txokinperiod++;\r\nif (pstx_fb->pkt_type == PACKET_MULTICAST)\r\n{\r\npriv->stats.txmulticast++;\r\npriv->stats.txbytesmulticast += pstx_fb->pkt_length;\r\n}\r\nelse if (pstx_fb->pkt_type == PACKET_BROADCAST)\r\n{\r\npriv->stats.txbroadcast++;\r\npriv->stats.txbytesbroadcast += pstx_fb->pkt_length;\r\n}\r\nelse\r\n{\r\npriv->stats.txunicast++;\r\npriv->stats.txbytesunicast += pstx_fb->pkt_length;\r\n}\r\n}\r\nelse\r\n{\r\npriv->stats.txfeedbackfail++;\r\npriv->stats.txerrtotal++;\r\npriv->stats.txerrbytestotal += pstx_fb->pkt_length;\r\nif (pstx_fb->pkt_type == PACKET_MULTICAST)\r\n{\r\npriv->stats.txerrmulticast++;\r\n}\r\nelse if (pstx_fb->pkt_type == PACKET_BROADCAST)\r\n{\r\npriv->stats.txerrbroadcast++;\r\n}\r\nelse\r\n{\r\npriv->stats.txerrunicast++;\r\n}\r\n}\r\npriv->stats.txretrycount += pstx_fb->retry_cnt;\r\npriv->stats.txfeedbackretry += pstx_fb->retry_cnt;\r\n}\r\nstatic void\r\ncmpk_handle_tx_feedback(\r\nstruct net_device *dev,\r\nu8 * pmsg)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\ncmpk_txfb_t rx_tx_fb;\r\npriv->stats.txfeedback++;\r\nmemcpy((u8*)&rx_tx_fb, pmsg, sizeof(cmpk_txfb_t));\r\ncmpk_count_txstatistic(dev, &rx_tx_fb);\r\n}\r\nvoid\r\ncmdpkt_beacontimerinterrupt_819xusb(\r\nstruct net_device *dev\r\n)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu16 tx_rate;\r\n{\r\nif(priv->ieee80211->current_network.mode == IEEE_A ||\r\npriv->ieee80211->current_network.mode == IEEE_N_5G ||\r\n(priv->ieee80211->current_network.mode == IEEE_N_24G && (!priv->ieee80211->pHTInfo->bCurSuppCCK)))\r\n{\r\ntx_rate = 60;\r\nDMESG("send beacon frame tx rate is 6Mbpm\n");\r\n}\r\nelse\r\n{\r\ntx_rate =10;\r\nDMESG("send beacon frame tx rate is 1Mbpm\n");\r\n}\r\nrtl819xusb_beacon_tx(dev,tx_rate);\r\n}\r\n}\r\nstatic void\r\ncmpk_handle_interrupt_status(\r\nstruct net_device *dev,\r\nu8* pmsg)\r\n{\r\ncmpk_intr_sta_t rx_intr_status;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nDMESG("---> cmpk_Handle_Interrupt_Status()\n");\r\nrx_intr_status.length = pmsg[1];\r\nif (rx_intr_status.length != (sizeof(cmpk_intr_sta_t) - 2))\r\n{\r\nDMESG("cmpk_Handle_Interrupt_Status: wrong length!\n");\r\nreturn;\r\n}\r\nif( priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\n{\r\nrx_intr_status.interrupt_status = *((u32 *)(pmsg + 4));\r\nDMESG("interrupt status = 0x%x\n", rx_intr_status.interrupt_status);\r\nif (rx_intr_status.interrupt_status & ISR_TxBcnOk)\r\n{\r\npriv->ieee80211->bibsscoordinator = true;\r\npriv->stats.txbeaconokint++;\r\n}\r\nelse if (rx_intr_status.interrupt_status & ISR_TxBcnErr)\r\n{\r\npriv->ieee80211->bibsscoordinator = false;\r\npriv->stats.txbeaconerr++;\r\n}\r\nif (rx_intr_status.interrupt_status & ISR_BcnTimerIntr)\r\n{\r\ncmdpkt_beacontimerinterrupt_819xusb(dev);\r\n}\r\n}\r\nDMESG("<---- cmpk_handle_interrupt_status()\n");\r\n}\r\nstatic void\r\ncmpk_handle_query_config_rx(\r\nstruct net_device *dev,\r\nu8* pmsg)\r\n{\r\ncmpk_query_cfg_t rx_query_cfg;\r\nrx_query_cfg.cfg_action = (pmsg[4] & 0x80000000)>>31;\r\nrx_query_cfg.cfg_type = (pmsg[4] & 0x60) >> 5;\r\nrx_query_cfg.cfg_size = (pmsg[4] & 0x18) >> 3;\r\nrx_query_cfg.cfg_page = (pmsg[6] & 0x0F) >> 0;\r\nrx_query_cfg.cfg_offset = pmsg[7];\r\nrx_query_cfg.value = (pmsg[8] << 24) | (pmsg[9] << 16) |\r\n(pmsg[10] << 8) | (pmsg[11] << 0);\r\nrx_query_cfg.mask = (pmsg[12] << 24) | (pmsg[13] << 16) |\r\n(pmsg[14] << 8) | (pmsg[15] << 0);\r\n}\r\nstatic void cmpk_count_tx_status( struct net_device *dev,\r\ncmpk_tx_status_t *pstx_status)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\n#ifdef ENABLE_PS\r\nRT_RF_POWER_STATE rtstate;\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\n{\r\nreturn;\r\n}\r\n#endif\r\npriv->stats.txfeedbackok += pstx_status->txok;\r\npriv->stats.txoktotal += pstx_status->txok;\r\npriv->stats.txfeedbackfail += pstx_status->txfail;\r\npriv->stats.txerrtotal += pstx_status->txfail;\r\npriv->stats.txretrycount += pstx_status->txretry;\r\npriv->stats.txfeedbackretry += pstx_status->txretry;\r\npriv->stats.txmulticast += pstx_status->txmcok;\r\npriv->stats.txbroadcast += pstx_status->txbcok;\r\npriv->stats.txunicast += pstx_status->txucok;\r\npriv->stats.txerrmulticast += pstx_status->txmcfail;\r\npriv->stats.txerrbroadcast += pstx_status->txbcfail;\r\npriv->stats.txerrunicast += pstx_status->txucfail;\r\npriv->stats.txbytesmulticast += pstx_status->txmclength;\r\npriv->stats.txbytesbroadcast += pstx_status->txbclength;\r\npriv->stats.txbytesunicast += pstx_status->txuclength;\r\npriv->stats.last_packet_rate = pstx_status->rate;\r\n}\r\nstatic void\r\ncmpk_handle_tx_status(\r\nstruct net_device *dev,\r\nu8* pmsg)\r\n{\r\ncmpk_tx_status_t rx_tx_sts;\r\nmemcpy((void*)&rx_tx_sts, (void*)pmsg, sizeof(cmpk_tx_status_t));\r\ncmpk_count_tx_status(dev, &rx_tx_sts);\r\n}\r\nstatic void\r\ncmpk_handle_tx_rate_history(\r\nstruct net_device *dev,\r\nu8* pmsg)\r\n{\r\ncmpk_tx_rahis_t *ptxrate;\r\nu8 i, j;\r\nu16 length = sizeof(cmpk_tx_rahis_t);\r\nu32 *ptemp;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\n#ifdef ENABLE_PS\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\n{\r\nreturn;\r\n}\r\n#endif\r\nptemp = (u32 *)pmsg;\r\nfor (i = 0; i < (length/4); i++)\r\n{\r\nu16 temp1, temp2;\r\ntemp1 = ptemp[i]&0x0000FFFF;\r\ntemp2 = ptemp[i]>>16;\r\nptemp[i] = (temp1<<16)|temp2;\r\n}\r\nptxrate = (cmpk_tx_rahis_t *)pmsg;\r\nif (ptxrate == NULL )\r\n{\r\nreturn;\r\n}\r\nfor (i = 0; i < 16; i++)\r\n{\r\nif (i < 4)\r\npriv->stats.txrate.cck[i] += ptxrate->cck[i];\r\nif (i< 8)\r\npriv->stats.txrate.ofdm[i] += ptxrate->ofdm[i];\r\nfor (j = 0; j < 4; j++)\r\npriv->stats.txrate.ht_mcs[j][i] += ptxrate->ht_mcs[j][i];\r\n}\r\n}\r\nextern u32\r\ncmpk_message_handle_rx(\r\nstruct net_device *dev,\r\nstruct ieee80211_rx_stats *pstats)\r\n{\r\nint total_length;\r\nu8 cmd_length, exe_cnt = 0;\r\nu8 element_id;\r\nu8 *pcmd_buff;\r\nif ((pstats== NULL))\r\n{\r\nreturn 0;\r\n}\r\ntotal_length = pstats->Length;\r\npcmd_buff = pstats->virtual_address;\r\nelement_id = pcmd_buff[0];\r\nwhile (total_length > 0 || exe_cnt++ >100)\r\n{\r\nelement_id = pcmd_buff[0];\r\nswitch(element_id)\r\n{\r\ncase RX_TX_FEEDBACK:\r\ncmpk_handle_tx_feedback (dev, pcmd_buff);\r\ncmd_length = CMPK_RX_TX_FB_SIZE;\r\nbreak;\r\ncase RX_INTERRUPT_STATUS:\r\ncmpk_handle_interrupt_status(dev, pcmd_buff);\r\ncmd_length = sizeof(cmpk_intr_sta_t);\r\nbreak;\r\ncase BOTH_QUERY_CONFIG:\r\ncmpk_handle_query_config_rx(dev, pcmd_buff);\r\ncmd_length = CMPK_BOTH_QUERY_CONFIG_SIZE;\r\nbreak;\r\ncase RX_TX_STATUS:\r\ncmpk_handle_tx_status(dev, pcmd_buff);\r\ncmd_length = CMPK_RX_TX_STS_SIZE;\r\nbreak;\r\ncase RX_TX_PER_PKT_FEEDBACK:\r\ncmd_length = CMPK_RX_TX_FB_SIZE;\r\nbreak;\r\ncase RX_TX_RATE_HISTORY:\r\ncmpk_handle_tx_rate_history(dev, pcmd_buff);\r\ncmd_length = CMPK_TX_RAHIS_SIZE;\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "---->cmpk_message_handle_rx():unknow CMD Element\n");\r\nreturn 1;\r\n}\r\ntotal_length -= cmd_length;\r\npcmd_buff += cmd_length;\r\n}\r\nreturn 1;\r\n}
