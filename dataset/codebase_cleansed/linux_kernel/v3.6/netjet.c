u_char\r\nNETjet_ReadIC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nu_char ret;\r\ncs->hw.njet.auxd &= 0xfc;\r\ncs->hw.njet.auxd |= (offset >> 4) & 3;\r\nbyteout(cs->hw.njet.auxa, cs->hw.njet.auxd);\r\nret = bytein(cs->hw.njet.isac + ((offset & 0xf) << 2));\r\nreturn (ret);\r\n}\r\nvoid\r\nNETjet_WriteIC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\ncs->hw.njet.auxd &= 0xfc;\r\ncs->hw.njet.auxd |= (offset >> 4) & 3;\r\nbyteout(cs->hw.njet.auxa, cs->hw.njet.auxd);\r\nbyteout(cs->hw.njet.isac + ((offset & 0xf) << 2), value);\r\n}\r\nvoid\r\nNETjet_ReadICfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\ncs->hw.njet.auxd &= 0xfc;\r\nbyteout(cs->hw.njet.auxa, cs->hw.njet.auxd);\r\ninsb(cs->hw.njet.isac, data, size);\r\n}\r\nvoid\r\nNETjet_WriteICfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\ncs->hw.njet.auxd &= 0xfc;\r\nbyteout(cs->hw.njet.auxa, cs->hw.njet.auxd);\r\noutsb(cs->hw.njet.isac, data, size);\r\n}\r\nstatic void fill_mem(struct BCState *bcs, u_int *pos, u_int cnt, int chan, u_char fill)\r\n{\r\nu_int mask = 0x000000ff, val = 0, *p = pos;\r\nu_int i;\r\nval |= fill;\r\nif (chan) {\r\nval <<= 8;\r\nmask <<= 8;\r\n}\r\nmask ^= 0xffffffff;\r\nfor (i = 0; i < cnt; i++) {\r\n*p &= mask;\r\n*p++ |= val;\r\nif (p > bcs->hw.tiger.s_end)\r\np = bcs->hw.tiger.send;\r\n}\r\n}\r\nstatic void\r\nmode_tiger(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nu_char led;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "Tiger mode %d bchan %d/%d",\r\nmode, bc, bcs->channel);\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\nswitch (mode) {\r\ncase (L1_MODE_NULL):\r\nfill_mem(bcs, bcs->hw.tiger.send,\r\nNETJET_DMA_TXSIZE, bc, 0xff);\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "Tiger stat rec %d/%d send %d",\r\nbcs->hw.tiger.r_tot, bcs->hw.tiger.r_err,\r\nbcs->hw.tiger.s_tot);\r\nif ((cs->bcs[0].mode == L1_MODE_NULL) &&\r\n(cs->bcs[1].mode == L1_MODE_NULL)) {\r\ncs->hw.njet.dmactrl = 0;\r\nbyteout(cs->hw.njet.base + NETJET_DMACTRL,\r\ncs->hw.njet.dmactrl);\r\nbyteout(cs->hw.njet.base + NETJET_IRQMASK0, 0);\r\n}\r\nif (cs->typ == ISDN_CTYPE_NETJET_S)\r\n{\r\nled = bc & 0x01;\r\nled = 0x01 << (6 + led);\r\nled = ~led;\r\ncs->hw.njet.auxd &= led;\r\nbyteout(cs->hw.njet.auxa, cs->hw.njet.auxd);\r\n}\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\nbreak;\r\ncase (L1_MODE_HDLC_56K):\r\ncase (L1_MODE_HDLC):\r\nfill_mem(bcs, bcs->hw.tiger.send,\r\nNETJET_DMA_TXSIZE, bc, 0xff);\r\nbcs->hw.tiger.r_state = HDLC_ZERO_SEARCH;\r\nbcs->hw.tiger.r_tot = 0;\r\nbcs->hw.tiger.r_bitcnt = 0;\r\nbcs->hw.tiger.r_one = 0;\r\nbcs->hw.tiger.r_err = 0;\r\nbcs->hw.tiger.s_tot = 0;\r\nif (!cs->hw.njet.dmactrl) {\r\nfill_mem(bcs, bcs->hw.tiger.send,\r\nNETJET_DMA_TXSIZE, !bc, 0xff);\r\ncs->hw.njet.dmactrl = 1;\r\nbyteout(cs->hw.njet.base + NETJET_DMACTRL,\r\ncs->hw.njet.dmactrl);\r\nbyteout(cs->hw.njet.base + NETJET_IRQMASK0, 0x0f);\r\n}\r\nbcs->hw.tiger.sendp = bcs->hw.tiger.send;\r\nbcs->hw.tiger.free = NETJET_DMA_TXSIZE;\r\ntest_and_set_bit(BC_FLG_EMPTY, &bcs->Flag);\r\nif (cs->typ == ISDN_CTYPE_NETJET_S)\r\n{\r\nled = bc & 0x01;\r\nled = 0x01 << (6 + led);\r\ncs->hw.njet.auxd |= led;\r\nbyteout(cs->hw.njet.auxa, cs->hw.njet.auxd);\r\n}\r\nbreak;\r\n}\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "tiger: set %x %x %x %x/%x pulse=%d",\r\nbytein(cs->hw.njet.base + NETJET_DMACTRL),\r\nbytein(cs->hw.njet.base + NETJET_IRQMASK0),\r\nbytein(cs->hw.njet.base + NETJET_IRQSTAT0),\r\ninl(cs->hw.njet.base + NETJET_DMA_READ_ADR),\r\ninl(cs->hw.njet.base + NETJET_DMA_WRITE_ADR),\r\nbytein(cs->hw.njet.base + NETJET_PULSE_CNT));\r\n}\r\nstatic void printframe(struct IsdnCardState *cs, u_char *buf, int count, char *s) {\r\nchar tmp[128];\r\nchar *t = tmp;\r\nint i = count, j;\r\nu_char *p = buf;\r\nt += sprintf(t, "tiger %s(%4d)", s, count);\r\nwhile (i > 0) {\r\nif (i > 16)\r\nj = 16;\r\nelse\r\nj = i;\r\nQuickHex(t, p, j);\r\ndebugl1(cs, tmp);\r\np += j;\r\ni -= j;\r\nt = tmp;\r\nt += sprintf(t, "tiger %s ", s);\r\n}\r\n}\r\nstatic int make_raw_data(struct BCState *bcs) {\r\nregister u_int i, s_cnt = 0;\r\nregister u_char j;\r\nregister u_char val;\r\nregister u_char s_one = 0;\r\nregister u_char s_val = 0;\r\nregister u_char bitcnt = 0;\r\nu_int fcs;\r\nif (!bcs->tx_skb) {\r\ndebugl1(bcs->cs, "tiger make_raw: NULL skb");\r\nreturn (1);\r\n}\r\nbcs->hw.tiger.sendbuf[s_cnt++] = HDLC_FLAG_VALUE;\r\nfcs = PPP_INITFCS;\r\nfor (i = 0; i < bcs->tx_skb->len; i++) {\r\nval = bcs->tx_skb->data[i];\r\nfcs = PPP_FCS(fcs, val);\r\nMAKE_RAW_BYTE;\r\n}\r\nfcs ^= 0xffff;\r\nval = fcs & 0xff;\r\nMAKE_RAW_BYTE;\r\nval = (fcs >> 8) & 0xff;\r\nMAKE_RAW_BYTE;\r\nval = HDLC_FLAG_VALUE;\r\nfor (j = 0; j < 8; j++) {\r\nbitcnt++;\r\ns_val >>= 1;\r\nif (val & 1)\r\ns_val |= 0x80;\r\nelse\r\ns_val &= 0x7f;\r\nif (bitcnt == 8) {\r\nbcs->hw.tiger.sendbuf[s_cnt++] = s_val;\r\nbitcnt = 0;\r\n}\r\nval >>= 1;\r\n}\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger make_raw: in %u out %d.%d",\r\nbcs->tx_skb->len, s_cnt, bitcnt);\r\nif (bitcnt) {\r\nwhile (8 > bitcnt++) {\r\ns_val >>= 1;\r\ns_val |= 0x80;\r\n}\r\nbcs->hw.tiger.sendbuf[s_cnt++] = s_val;\r\nbcs->hw.tiger.sendbuf[s_cnt++] = 0xff;\r\n}\r\nbcs->hw.tiger.sendcnt = s_cnt;\r\nbcs->tx_cnt -= bcs->tx_skb->len;\r\nbcs->hw.tiger.sp = bcs->hw.tiger.sendbuf;\r\nreturn (0);\r\n}\r\nstatic int make_raw_data_56k(struct BCState *bcs) {\r\nregister u_int i, s_cnt = 0;\r\nregister u_char j;\r\nregister u_char val;\r\nregister u_char s_one = 0;\r\nregister u_char s_val = 0;\r\nregister u_char bitcnt = 0;\r\nu_int fcs;\r\nif (!bcs->tx_skb) {\r\ndebugl1(bcs->cs, "tiger make_raw_56k: NULL skb");\r\nreturn (1);\r\n}\r\nval = HDLC_FLAG_VALUE;\r\nfor (j = 0; j < 8; j++) {\r\nbitcnt++;\r\ns_val >>= 1;\r\nif (val & 1)\r\ns_val |= 0x80;\r\nelse\r\ns_val &= 0x7f;\r\nif (bitcnt == 7) {\r\ns_val >>= 1;\r\ns_val |= 0x80;\r\nbcs->hw.tiger.sendbuf[s_cnt++] = s_val;\r\nbitcnt = 0;\r\n}\r\nval >>= 1;\r\n};\r\nfcs = PPP_INITFCS;\r\nfor (i = 0; i < bcs->tx_skb->len; i++) {\r\nval = bcs->tx_skb->data[i];\r\nfcs = PPP_FCS(fcs, val);\r\nMAKE_RAW_BYTE_56K;\r\n}\r\nfcs ^= 0xffff;\r\nval = fcs & 0xff;\r\nMAKE_RAW_BYTE_56K;\r\nval = (fcs >> 8) & 0xff;\r\nMAKE_RAW_BYTE_56K;\r\nval = HDLC_FLAG_VALUE;\r\nfor (j = 0; j < 8; j++) {\r\nbitcnt++;\r\ns_val >>= 1;\r\nif (val & 1)\r\ns_val |= 0x80;\r\nelse\r\ns_val &= 0x7f;\r\nif (bitcnt == 7) {\r\ns_val >>= 1;\r\ns_val |= 0x80;\r\nbcs->hw.tiger.sendbuf[s_cnt++] = s_val;\r\nbitcnt = 0;\r\n}\r\nval >>= 1;\r\n}\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger make_raw_56k: in %u out %d.%d",\r\nbcs->tx_skb->len, s_cnt, bitcnt);\r\nif (bitcnt) {\r\nwhile (8 > bitcnt++) {\r\ns_val >>= 1;\r\ns_val |= 0x80;\r\n}\r\nbcs->hw.tiger.sendbuf[s_cnt++] = s_val;\r\nbcs->hw.tiger.sendbuf[s_cnt++] = 0xff;\r\n}\r\nbcs->hw.tiger.sendcnt = s_cnt;\r\nbcs->tx_cnt -= bcs->tx_skb->len;\r\nbcs->hw.tiger.sp = bcs->hw.tiger.sendbuf;\r\nreturn (0);\r\n}\r\nstatic void got_frame(struct BCState *bcs, int count) {\r\nstruct sk_buff *skb;\r\nif (!(skb = dev_alloc_skb(count)))\r\nprintk(KERN_WARNING "TIGER: receive out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, count), bcs->hw.tiger.rcvbuf, count);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\ntest_and_set_bit(B_RCVBUFREADY, &bcs->event);\r\nschedule_work(&bcs->tqueue);\r\nif (bcs->cs->debug & L1_DEB_RECEIVE_FRAME)\r\nprintframe(bcs->cs, bcs->hw.tiger.rcvbuf, count, "rec");\r\n}\r\nstatic void read_raw(struct BCState *bcs, u_int *buf, int cnt) {\r\nint i;\r\nregister u_char j;\r\nregister u_char val;\r\nu_int *pend = bcs->hw.tiger.rec + NETJET_DMA_RXSIZE - 1;\r\nregister u_char state = bcs->hw.tiger.r_state;\r\nregister u_char r_one = bcs->hw.tiger.r_one;\r\nregister u_char r_val = bcs->hw.tiger.r_val;\r\nregister u_int bitcnt = bcs->hw.tiger.r_bitcnt;\r\nu_int *p = buf;\r\nint bits;\r\nu_char mask;\r\nif (bcs->mode == L1_MODE_HDLC) {\r\nmask = 0xff;\r\nbits = 8;\r\n}\r\nelse {\r\nmask = 0x7f;\r\nbits = 7;\r\n};\r\nfor (i = 0; i < cnt; i++) {\r\nval = bcs->channel ? ((*p >> 8) & 0xff) : (*p & 0xff);\r\np++;\r\nif (p > pend)\r\np = bcs->hw.tiger.rec;\r\nif ((val & mask) == mask) {\r\nstate = HDLC_ZERO_SEARCH;\r\nbcs->hw.tiger.r_tot++;\r\nbitcnt = 0;\r\nr_one = 0;\r\ncontinue;\r\n}\r\nfor (j = 0; j < bits; j++) {\r\nif (state == HDLC_ZERO_SEARCH) {\r\nif (val & 1) {\r\nr_one++;\r\n} else {\r\nr_one = 0;\r\nstate = HDLC_FLAG_SEARCH;\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger read_raw: zBit(%d,%d,%d) %x",\r\nbcs->hw.tiger.r_tot, i, j, val);\r\n}\r\n} else if (state == HDLC_FLAG_SEARCH) {\r\nif (val & 1) {\r\nr_one++;\r\nif (r_one > 6) {\r\nstate = HDLC_ZERO_SEARCH;\r\n}\r\n} else {\r\nif (r_one == 6) {\r\nbitcnt = 0;\r\nr_val = 0;\r\nstate = HDLC_FLAG_FOUND;\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger read_raw: flag(%d,%d,%d) %x",\r\nbcs->hw.tiger.r_tot, i, j, val);\r\n}\r\nr_one = 0;\r\n}\r\n} else if (state == HDLC_FLAG_FOUND) {\r\nif (val & 1) {\r\nr_one++;\r\nif (r_one > 6) {\r\nstate = HDLC_ZERO_SEARCH;\r\n} else {\r\nr_val >>= 1;\r\nr_val |= 0x80;\r\nbitcnt++;\r\n}\r\n} else {\r\nif (r_one == 6) {\r\nbitcnt = 0;\r\nr_val = 0;\r\nr_one = 0;\r\nval >>= 1;\r\ncontinue;\r\n} else if (r_one != 5) {\r\nr_val >>= 1;\r\nr_val &= 0x7f;\r\nbitcnt++;\r\n}\r\nr_one = 0;\r\n}\r\nif ((state != HDLC_ZERO_SEARCH) &&\r\n!(bitcnt & 7)) {\r\nstate = HDLC_FRAME_FOUND;\r\nbcs->hw.tiger.r_fcs = PPP_INITFCS;\r\nbcs->hw.tiger.rcvbuf[0] = r_val;\r\nbcs->hw.tiger.r_fcs = PPP_FCS(bcs->hw.tiger.r_fcs, r_val);\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger read_raw: byte1(%d,%d,%d) rval %x val %x i %x",\r\nbcs->hw.tiger.r_tot, i, j, r_val, val,\r\nbcs->cs->hw.njet.irqstat0);\r\n}\r\n} else if (state == HDLC_FRAME_FOUND) {\r\nif (val & 1) {\r\nr_one++;\r\nif (r_one > 6) {\r\nstate = HDLC_ZERO_SEARCH;\r\nbitcnt = 0;\r\n} else {\r\nr_val >>= 1;\r\nr_val |= 0x80;\r\nbitcnt++;\r\n}\r\n} else {\r\nif (r_one == 6) {\r\nr_val = 0;\r\nr_one = 0;\r\nbitcnt++;\r\nif (bitcnt & 7) {\r\ndebugl1(bcs->cs, "tiger: frame not byte aligned");\r\nstate = HDLC_FLAG_SEARCH;\r\nbcs->hw.tiger.r_err++;\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_inv++;\r\n#endif\r\n} else {\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger frame end(%d,%d): fcs(%x) i %x",\r\ni, j, bcs->hw.tiger.r_fcs, bcs->cs->hw.njet.irqstat0);\r\nif (bcs->hw.tiger.r_fcs == PPP_GOODFCS) {\r\ngot_frame(bcs, (bitcnt >> 3) - 3);\r\n} else {\r\nif (bcs->cs->debug) {\r\ndebugl1(bcs->cs, "tiger FCS error");\r\nprintframe(bcs->cs, bcs->hw.tiger.rcvbuf,\r\n(bitcnt >> 3) - 1, "rec");\r\nbcs->hw.tiger.r_err++;\r\n}\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_crc++;\r\n#endif\r\n}\r\nstate = HDLC_FLAG_FOUND;\r\n}\r\nbitcnt = 0;\r\n} else if (r_one == 5) {\r\nval >>= 1;\r\nr_one = 0;\r\ncontinue;\r\n} else {\r\nr_val >>= 1;\r\nr_val &= 0x7f;\r\nbitcnt++;\r\n}\r\nr_one = 0;\r\n}\r\nif ((state == HDLC_FRAME_FOUND) &&\r\n!(bitcnt & 7)) {\r\nif ((bitcnt >> 3) >= HSCX_BUFMAX) {\r\ndebugl1(bcs->cs, "tiger: frame too big");\r\nr_val = 0;\r\nstate = HDLC_FLAG_SEARCH;\r\nbcs->hw.tiger.r_err++;\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_inv++;\r\n#endif\r\n} else {\r\nbcs->hw.tiger.rcvbuf[(bitcnt >> 3) - 1] = r_val;\r\nbcs->hw.tiger.r_fcs =\r\nPPP_FCS(bcs->hw.tiger.r_fcs, r_val);\r\n}\r\n}\r\n}\r\nval >>= 1;\r\n}\r\nbcs->hw.tiger.r_tot++;\r\n}\r\nbcs->hw.tiger.r_state = state;\r\nbcs->hw.tiger.r_one = r_one;\r\nbcs->hw.tiger.r_val = r_val;\r\nbcs->hw.tiger.r_bitcnt = bitcnt;\r\n}\r\nvoid read_tiger(struct IsdnCardState *cs) {\r\nu_int *p;\r\nint cnt = NETJET_DMA_RXSIZE / 2;\r\nif ((cs->hw.njet.irqstat0 & cs->hw.njet.last_is0) & NETJET_IRQM0_READ) {\r\ndebugl1(cs, "tiger warn read double dma %x/%x",\r\ncs->hw.njet.irqstat0, cs->hw.njet.last_is0);\r\n#ifdef ERROR_STATISTIC\r\nif (cs->bcs[0].mode)\r\ncs->bcs[0].err_rdo++;\r\nif (cs->bcs[1].mode)\r\ncs->bcs[1].err_rdo++;\r\n#endif\r\nreturn;\r\n} else {\r\ncs->hw.njet.last_is0 &= ~NETJET_IRQM0_READ;\r\ncs->hw.njet.last_is0 |= (cs->hw.njet.irqstat0 & NETJET_IRQM0_READ);\r\n}\r\nif (cs->hw.njet.irqstat0 & NETJET_IRQM0_READ_1)\r\np = cs->bcs[0].hw.tiger.rec + NETJET_DMA_RXSIZE - 1;\r\nelse\r\np = cs->bcs[0].hw.tiger.rec + cnt - 1;\r\nif ((cs->bcs[0].mode == L1_MODE_HDLC) || (cs->bcs[0].mode == L1_MODE_HDLC_56K))\r\nread_raw(cs->bcs, p, cnt);\r\nif ((cs->bcs[1].mode == L1_MODE_HDLC) || (cs->bcs[1].mode == L1_MODE_HDLC_56K))\r\nread_raw(cs->bcs + 1, p, cnt);\r\ncs->hw.njet.irqstat0 &= ~NETJET_IRQM0_READ;\r\n}\r\nvoid netjet_fill_dma(struct BCState *bcs)\r\n{\r\nregister u_int *p, *sp;\r\nregister int cnt;\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger fill_dma1: c%d %4lx", bcs->channel,\r\nbcs->Flag);\r\nif (test_and_set_bit(BC_FLG_BUSY, &bcs->Flag))\r\nreturn;\r\nif (bcs->mode == L1_MODE_HDLC) {\r\nif (make_raw_data(bcs))\r\nreturn;\r\n}\r\nelse {\r\nif (make_raw_data_56k(bcs))\r\nreturn;\r\n};\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger fill_dma2: c%d %4lx", bcs->channel,\r\nbcs->Flag);\r\nif (test_and_clear_bit(BC_FLG_NOFRAME, &bcs->Flag)) {\r\nwrite_raw(bcs, bcs->hw.tiger.sendp, bcs->hw.tiger.free);\r\n} else if (test_and_clear_bit(BC_FLG_HALF, &bcs->Flag)) {\r\np = bus_to_virt(inl(bcs->cs->hw.njet.base + NETJET_DMA_READ_ADR));\r\nsp = bcs->hw.tiger.sendp;\r\nif (p == bcs->hw.tiger.s_end)\r\np = bcs->hw.tiger.send - 1;\r\nif (sp == bcs->hw.tiger.s_end)\r\nsp = bcs->hw.tiger.send - 1;\r\ncnt = p - sp;\r\nif (cnt < 0) {\r\nwrite_raw(bcs, bcs->hw.tiger.sendp, bcs->hw.tiger.free);\r\n} else {\r\np++;\r\ncnt++;\r\nif (p > bcs->hw.tiger.s_end)\r\np = bcs->hw.tiger.send;\r\np++;\r\ncnt++;\r\nif (p > bcs->hw.tiger.s_end)\r\np = bcs->hw.tiger.send;\r\nwrite_raw(bcs, p, bcs->hw.tiger.free - cnt);\r\n}\r\n} else if (test_and_clear_bit(BC_FLG_EMPTY, &bcs->Flag)) {\r\np = bus_to_virt(inl(bcs->cs->hw.njet.base + NETJET_DMA_READ_ADR));\r\ncnt = bcs->hw.tiger.s_end - p;\r\nif (cnt < 2) {\r\np = bcs->hw.tiger.send + 1;\r\ncnt = NETJET_DMA_TXSIZE / 2 - 2;\r\n} else {\r\np++;\r\np++;\r\nif (cnt <= (NETJET_DMA_TXSIZE / 2))\r\ncnt += NETJET_DMA_TXSIZE / 2;\r\ncnt--;\r\ncnt--;\r\n}\r\nwrite_raw(bcs, p, cnt);\r\n}\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger fill_dma3: c%d %4lx", bcs->channel,\r\nbcs->Flag);\r\n}\r\nstatic void write_raw(struct BCState *bcs, u_int *buf, int cnt) {\r\nu_int mask, val, *p = buf;\r\nu_int i, s_cnt;\r\nif (cnt <= 0)\r\nreturn;\r\nif (test_bit(BC_FLG_BUSY, &bcs->Flag)) {\r\nif (bcs->hw.tiger.sendcnt > cnt) {\r\ns_cnt = cnt;\r\nbcs->hw.tiger.sendcnt -= cnt;\r\n} else {\r\ns_cnt = bcs->hw.tiger.sendcnt;\r\nbcs->hw.tiger.sendcnt = 0;\r\n}\r\nif (bcs->channel)\r\nmask = 0xffff00ff;\r\nelse\r\nmask = 0xffffff00;\r\nfor (i = 0; i < s_cnt; i++) {\r\nval = bcs->channel ? ((bcs->hw.tiger.sp[i] << 8) & 0xff00) :\r\n(bcs->hw.tiger.sp[i]);\r\n*p &= mask;\r\n*p++ |= val;\r\nif (p > bcs->hw.tiger.s_end)\r\np = bcs->hw.tiger.send;\r\n}\r\nbcs->hw.tiger.s_tot += s_cnt;\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger write_raw: c%d %p-%p %d/%d %d %x", bcs->channel,\r\nbuf, p, s_cnt, cnt,\r\nbcs->hw.tiger.sendcnt, bcs->cs->hw.njet.irqstat0);\r\nif (bcs->cs->debug & L1_DEB_HSCX_FIFO)\r\nprintframe(bcs->cs, bcs->hw.tiger.sp, s_cnt, "snd");\r\nbcs->hw.tiger.sp += s_cnt;\r\nbcs->hw.tiger.sendp = p;\r\nif (!bcs->hw.tiger.sendcnt) {\r\nif (!bcs->tx_skb) {\r\ndebugl1(bcs->cs, "tiger write_raw: NULL skb s_cnt %d", s_cnt);\r\n} else {\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->tx_skb->len;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\n}\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->hw.tiger.free = cnt - s_cnt;\r\nif (bcs->hw.tiger.free > (NETJET_DMA_TXSIZE / 2))\r\ntest_and_set_bit(BC_FLG_HALF, &bcs->Flag);\r\nelse {\r\ntest_and_clear_bit(BC_FLG_HALF, &bcs->Flag);\r\ntest_and_set_bit(BC_FLG_NOFRAME, &bcs->Flag);\r\n}\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nnetjet_fill_dma(bcs);\r\n} else {\r\nmask ^= 0xffffffff;\r\nif (s_cnt < cnt) {\r\nfor (i = s_cnt; i < cnt; i++) {\r\n*p++ |= mask;\r\nif (p > bcs->hw.tiger.s_end)\r\np = bcs->hw.tiger.send;\r\n}\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger write_raw: fill rest %d",\r\ncnt - s_cnt);\r\n}\r\ntest_and_set_bit(B_XMTBUFREADY, &bcs->event);\r\nschedule_work(&bcs->tqueue);\r\n}\r\n}\r\n} else if (test_and_clear_bit(BC_FLG_NOFRAME, &bcs->Flag)) {\r\ntest_and_set_bit(BC_FLG_HALF, &bcs->Flag);\r\nfill_mem(bcs, buf, cnt, bcs->channel, 0xff);\r\nbcs->hw.tiger.free += cnt;\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger write_raw: fill half");\r\n} else if (test_and_clear_bit(BC_FLG_HALF, &bcs->Flag)) {\r\ntest_and_set_bit(BC_FLG_EMPTY, &bcs->Flag);\r\nfill_mem(bcs, buf, cnt, bcs->channel, 0xff);\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "tiger write_raw: fill full");\r\n}\r\n}\r\nvoid write_tiger(struct IsdnCardState *cs) {\r\nu_int *p, cnt = NETJET_DMA_TXSIZE / 2;\r\nif ((cs->hw.njet.irqstat0 & cs->hw.njet.last_is0) & NETJET_IRQM0_WRITE) {\r\ndebugl1(cs, "tiger warn write double dma %x/%x",\r\ncs->hw.njet.irqstat0, cs->hw.njet.last_is0);\r\n#ifdef ERROR_STATISTIC\r\nif (cs->bcs[0].mode)\r\ncs->bcs[0].err_tx++;\r\nif (cs->bcs[1].mode)\r\ncs->bcs[1].err_tx++;\r\n#endif\r\nreturn;\r\n} else {\r\ncs->hw.njet.last_is0 &= ~NETJET_IRQM0_WRITE;\r\ncs->hw.njet.last_is0 |= (cs->hw.njet.irqstat0 & NETJET_IRQM0_WRITE);\r\n}\r\nif (cs->hw.njet.irqstat0 & NETJET_IRQM0_WRITE_1)\r\np = cs->bcs[0].hw.tiger.send + NETJET_DMA_TXSIZE - 1;\r\nelse\r\np = cs->bcs[0].hw.tiger.send + cnt - 1;\r\nif ((cs->bcs[0].mode == L1_MODE_HDLC) || (cs->bcs[0].mode == L1_MODE_HDLC_56K))\r\nwrite_raw(cs->bcs, p, cnt);\r\nif ((cs->bcs[1].mode == L1_MODE_HDLC) || (cs->bcs[1].mode == L1_MODE_HDLC_56K))\r\nwrite_raw(cs->bcs + 1, p, cnt);\r\ncs->hw.njet.irqstat0 &= ~NETJET_IRQM0_WRITE;\r\n}\r\nstatic void\r\ntiger_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "tiger_l2l1: this shouldn't happen\n");\r\n} else {\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nmode_tiger(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbcs->cs->cardmsg(bcs->cs, MDL_BC_ASSIGN, (void *)(&st->l1.bc));\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nbcs->cs->cardmsg(bcs->cs, MDL_BC_RELEASE, (void *)(&st->l1.bc));\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nmode_tiger(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_tigerstate(struct BCState *bcs)\r\n{\r\nmode_tiger(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nkfree(bcs->hw.tiger.rcvbuf);\r\nbcs->hw.tiger.rcvbuf = NULL;\r\nkfree(bcs->hw.tiger.sendbuf);\r\nbcs->hw.tiger.sendbuf = NULL;\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nstatic int\r\nopen_tigerstate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nif (!(bcs->hw.tiger.rcvbuf = kmalloc(HSCX_BUFMAX, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for tiger.rcvbuf\n");\r\nreturn (1);\r\n}\r\nif (!(bcs->hw.tiger.sendbuf = kmalloc(RAW_BUFMAX, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for tiger.sendbuf\n");\r\nreturn (1);\r\n}\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\nbcs->hw.tiger.sendcnt = 0;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_tiger(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_tigerstate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = tiger_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nvoid\r\ninittiger(struct IsdnCardState *cs)\r\n{\r\nif (!(cs->bcs[0].hw.tiger.send = kmalloc(NETJET_DMA_TXSIZE * sizeof(unsigned int),\r\nGFP_KERNEL | GFP_DMA))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for tiger.send\n");\r\nreturn;\r\n}\r\ncs->bcs[0].hw.tiger.s_irq = cs->bcs[0].hw.tiger.send + NETJET_DMA_TXSIZE / 2 - 1;\r\ncs->bcs[0].hw.tiger.s_end = cs->bcs[0].hw.tiger.send + NETJET_DMA_TXSIZE - 1;\r\ncs->bcs[1].hw.tiger.send = cs->bcs[0].hw.tiger.send;\r\ncs->bcs[1].hw.tiger.s_irq = cs->bcs[0].hw.tiger.s_irq;\r\ncs->bcs[1].hw.tiger.s_end = cs->bcs[0].hw.tiger.s_end;\r\nmemset(cs->bcs[0].hw.tiger.send, 0xff, NETJET_DMA_TXSIZE * sizeof(unsigned int));\r\ndebugl1(cs, "tiger: send buf %p - %p", cs->bcs[0].hw.tiger.send,\r\ncs->bcs[0].hw.tiger.send + NETJET_DMA_TXSIZE - 1);\r\noutl(virt_to_bus(cs->bcs[0].hw.tiger.send),\r\ncs->hw.njet.base + NETJET_DMA_READ_START);\r\noutl(virt_to_bus(cs->bcs[0].hw.tiger.s_irq),\r\ncs->hw.njet.base + NETJET_DMA_READ_IRQ);\r\noutl(virt_to_bus(cs->bcs[0].hw.tiger.s_end),\r\ncs->hw.njet.base + NETJET_DMA_READ_END);\r\nif (!(cs->bcs[0].hw.tiger.rec = kmalloc(NETJET_DMA_RXSIZE * sizeof(unsigned int),\r\nGFP_KERNEL | GFP_DMA))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for tiger.rec\n");\r\nreturn;\r\n}\r\ndebugl1(cs, "tiger: rec buf %p - %p", cs->bcs[0].hw.tiger.rec,\r\ncs->bcs[0].hw.tiger.rec + NETJET_DMA_RXSIZE - 1);\r\ncs->bcs[1].hw.tiger.rec = cs->bcs[0].hw.tiger.rec;\r\nmemset(cs->bcs[0].hw.tiger.rec, 0xff, NETJET_DMA_RXSIZE * sizeof(unsigned int));\r\noutl(virt_to_bus(cs->bcs[0].hw.tiger.rec),\r\ncs->hw.njet.base + NETJET_DMA_WRITE_START);\r\noutl(virt_to_bus(cs->bcs[0].hw.tiger.rec + NETJET_DMA_RXSIZE / 2 - 1),\r\ncs->hw.njet.base + NETJET_DMA_WRITE_IRQ);\r\noutl(virt_to_bus(cs->bcs[0].hw.tiger.rec + NETJET_DMA_RXSIZE - 1),\r\ncs->hw.njet.base + NETJET_DMA_WRITE_END);\r\ndebugl1(cs, "tiger: dmacfg %x/%x pulse=%d",\r\ninl(cs->hw.njet.base + NETJET_DMA_WRITE_ADR),\r\ninl(cs->hw.njet.base + NETJET_DMA_READ_ADR),\r\nbytein(cs->hw.njet.base + NETJET_PULSE_CNT));\r\ncs->hw.njet.last_is0 = 0;\r\ncs->bcs[0].BC_SetStack = setstack_tiger;\r\ncs->bcs[1].BC_SetStack = setstack_tiger;\r\ncs->bcs[0].BC_Close = close_tigerstate;\r\ncs->bcs[1].BC_Close = close_tigerstate;\r\n}\r\nstatic void\r\nreleasetiger(struct IsdnCardState *cs)\r\n{\r\nkfree(cs->bcs[0].hw.tiger.send);\r\ncs->bcs[0].hw.tiger.send = NULL;\r\ncs->bcs[1].hw.tiger.send = NULL;\r\nkfree(cs->bcs[0].hw.tiger.rec);\r\ncs->bcs[0].hw.tiger.rec = NULL;\r\ncs->bcs[1].hw.tiger.rec = NULL;\r\n}\r\nvoid\r\nrelease_io_netjet(struct IsdnCardState *cs)\r\n{\r\nbyteout(cs->hw.njet.base + NETJET_IRQMASK0, 0);\r\nbyteout(cs->hw.njet.base + NETJET_IRQMASK1, 0);\r\nreleasetiger(cs);\r\nrelease_region(cs->hw.njet.base, 256);\r\n}
