int tap_open_common(void *dev, char *gate_addr)\r\n{\r\nint tap_addr[4];\r\nif (gate_addr == NULL)\r\nreturn 0;\r\nif (sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0],\r\n&tap_addr[1], &tap_addr[2], &tap_addr[3]) != 4) {\r\nprintk(UM_KERN_ERR "Invalid tap IP address - '%s'\n",\r\ngate_addr);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid tap_check_ips(char *gate_addr, unsigned char *eth_addr)\r\n{\r\nint tap_addr[4];\r\nif ((gate_addr != NULL) &&\r\n(sscanf(gate_addr, "%d.%d.%d.%d", &tap_addr[0],\r\n&tap_addr[1], &tap_addr[2], &tap_addr[3]) == 4) &&\r\n(eth_addr[0] == tap_addr[0]) &&\r\n(eth_addr[1] == tap_addr[1]) &&\r\n(eth_addr[2] == tap_addr[2]) &&\r\n(eth_addr[3] == tap_addr[3])) {\r\nprintk(UM_KERN_ERR "The tap IP address and the UML eth IP "\r\n"address must be different\n");\r\n}\r\n}\r\nvoid read_output(int fd, char *output, int len)\r\n{\r\nint remain, ret, expected;\r\nchar c;\r\nchar *str;\r\nif (output == NULL) {\r\noutput = &c;\r\nlen = sizeof(c);\r\n}\r\n*output = '\0';\r\nret = read(fd, &remain, sizeof(remain));\r\nif (ret != sizeof(remain)) {\r\nif (ret < 0)\r\nret = -errno;\r\nexpected = sizeof(remain);\r\nstr = "length";\r\ngoto err;\r\n}\r\nwhile (remain != 0) {\r\nexpected = (remain < len) ? remain : len;\r\nret = read(fd, output, expected);\r\nif (ret != expected) {\r\nif (ret < 0)\r\nret = -errno;\r\nstr = "data";\r\ngoto err;\r\n}\r\nremain -= ret;\r\n}\r\nreturn;\r\nerr:\r\nif (ret < 0)\r\nprintk(UM_KERN_ERR "read_output - read of %s failed, "\r\n"errno = %d\n", str, -ret);\r\nelse\r\nprintk(UM_KERN_ERR "read_output - read of %s failed, read only "\r\n"%d of %d bytes\n", str, ret, expected);\r\n}\r\nint net_read(int fd, void *buf, int len)\r\n{\r\nint n;\r\nn = read(fd, buf, len);\r\nif ((n < 0) && (errno == EAGAIN))\r\nreturn 0;\r\nelse if (n == 0)\r\nreturn -ENOTCONN;\r\nreturn n;\r\n}\r\nint net_recvfrom(int fd, void *buf, int len)\r\n{\r\nint n;\r\nCATCH_EINTR(n = recvfrom(fd, buf, len, 0, NULL, NULL));\r\nif (n < 0) {\r\nif (errno == EAGAIN)\r\nreturn 0;\r\nreturn -errno;\r\n}\r\nelse if (n == 0)\r\nreturn -ENOTCONN;\r\nreturn n;\r\n}\r\nint net_write(int fd, void *buf, int len)\r\n{\r\nint n;\r\nn = write(fd, buf, len);\r\nif ((n < 0) && (errno == EAGAIN))\r\nreturn 0;\r\nelse if (n == 0)\r\nreturn -ENOTCONN;\r\nreturn n;\r\n}\r\nint net_send(int fd, void *buf, int len)\r\n{\r\nint n;\r\nCATCH_EINTR(n = send(fd, buf, len, 0));\r\nif (n < 0) {\r\nif (errno == EAGAIN)\r\nreturn 0;\r\nreturn -errno;\r\n}\r\nelse if (n == 0)\r\nreturn -ENOTCONN;\r\nreturn n;\r\n}\r\nint net_sendto(int fd, void *buf, int len, void *to, int sock_len)\r\n{\r\nint n;\r\nCATCH_EINTR(n = sendto(fd, buf, len, 0, (struct sockaddr *) to,\r\nsock_len));\r\nif (n < 0) {\r\nif (errno == EAGAIN)\r\nreturn 0;\r\nreturn -errno;\r\n}\r\nelse if (n == 0)\r\nreturn -ENOTCONN;\r\nreturn n;\r\n}\r\nstatic void change_pre_exec(void *arg)\r\n{\r\nstruct change_pre_exec_data *data = arg;\r\nclose(data->close_me);\r\ndup2(data->stdout, 1);\r\n}\r\nstatic int change_tramp(char **argv, char *output, int output_len)\r\n{\r\nint pid, fds[2], err;\r\nstruct change_pre_exec_data pe_data;\r\nerr = os_pipe(fds, 1, 0);\r\nif (err < 0) {\r\nprintk(UM_KERN_ERR "change_tramp - pipe failed, err = %d\n",\r\n-err);\r\nreturn err;\r\n}\r\npe_data.close_me = fds[0];\r\npe_data.stdout = fds[1];\r\npid = run_helper(change_pre_exec, &pe_data, argv);\r\nif (pid > 0)\r\nread_output(fds[0], output, output_len);\r\nclose(fds[0]);\r\nclose(fds[1]);\r\nif (pid > 0)\r\nhelper_wait(pid);\r\nreturn pid;\r\n}\r\nstatic void change(char *dev, char *what, unsigned char *addr,\r\nunsigned char *netmask)\r\n{\r\nchar addr_buf[sizeof("255.255.255.255\0")];\r\nchar netmask_buf[sizeof("255.255.255.255\0")];\r\nchar version[sizeof("nnnnn\0")];\r\nchar *argv[] = { "uml_net", version, what, dev, addr_buf,\r\nnetmask_buf, NULL };\r\nchar *output;\r\nint output_len, pid;\r\nsprintf(version, "%d", UML_NET_VERSION);\r\nsprintf(addr_buf, "%d.%d.%d.%d", addr[0], addr[1], addr[2], addr[3]);\r\nsprintf(netmask_buf, "%d.%d.%d.%d", netmask[0], netmask[1],\r\nnetmask[2], netmask[3]);\r\noutput_len = UM_KERN_PAGE_SIZE;\r\noutput = uml_kmalloc(output_len, UM_GFP_KERNEL);\r\nif (output == NULL)\r\nprintk(UM_KERN_ERR "change : failed to allocate output "\r\n"buffer\n");\r\npid = change_tramp(argv, output, output_len);\r\nif (pid < 0) {\r\nkfree(output);\r\nreturn;\r\n}\r\nif (output != NULL) {\r\nprintk("%s", output);\r\nkfree(output);\r\n}\r\n}\r\nvoid open_addr(unsigned char *addr, unsigned char *netmask, void *arg)\r\n{\r\nchange(arg, "add", addr, netmask);\r\n}\r\nvoid close_addr(unsigned char *addr, unsigned char *netmask, void *arg)\r\n{\r\nchange(arg, "del", addr, netmask);\r\n}\r\nchar *split_if_spec(char *str, ...)\r\n{\r\nchar **arg, *end;\r\nva_list ap;\r\nva_start(ap, str);\r\nwhile ((arg = va_arg(ap, char **)) != NULL) {\r\nif (*str == '\0')\r\nreturn NULL;\r\nend = strchr(str, ',');\r\nif (end != str)\r\n*arg = str;\r\nif (end == NULL)\r\nreturn NULL;\r\n*end++ = '\0';\r\nstr = end;\r\n}\r\nva_end(ap);\r\nreturn str;\r\n}
