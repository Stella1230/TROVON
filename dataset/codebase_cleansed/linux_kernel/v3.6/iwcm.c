static struct iwcm_work *get_work(struct iwcm_id_private *cm_id_priv)\r\n{\r\nstruct iwcm_work *work;\r\nif (list_empty(&cm_id_priv->work_free_list))\r\nreturn NULL;\r\nwork = list_entry(cm_id_priv->work_free_list.next, struct iwcm_work,\r\nfree_list);\r\nlist_del_init(&work->free_list);\r\nreturn work;\r\n}\r\nstatic void put_work(struct iwcm_work *work)\r\n{\r\nlist_add(&work->free_list, &work->cm_id->work_free_list);\r\n}\r\nstatic void dealloc_work_entries(struct iwcm_id_private *cm_id_priv)\r\n{\r\nstruct list_head *e, *tmp;\r\nlist_for_each_safe(e, tmp, &cm_id_priv->work_free_list)\r\nkfree(list_entry(e, struct iwcm_work, free_list));\r\n}\r\nstatic int alloc_work_entries(struct iwcm_id_private *cm_id_priv, int count)\r\n{\r\nstruct iwcm_work *work;\r\nBUG_ON(!list_empty(&cm_id_priv->work_free_list));\r\nwhile (count--) {\r\nwork = kmalloc(sizeof(struct iwcm_work), GFP_KERNEL);\r\nif (!work) {\r\ndealloc_work_entries(cm_id_priv);\r\nreturn -ENOMEM;\r\n}\r\nwork->cm_id = cm_id_priv;\r\nINIT_LIST_HEAD(&work->list);\r\nput_work(work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int copy_private_data(struct iw_cm_event *event)\r\n{\r\nvoid *p;\r\np = kmemdup(event->private_data, event->private_data_len, GFP_ATOMIC);\r\nif (!p)\r\nreturn -ENOMEM;\r\nevent->private_data = p;\r\nreturn 0;\r\n}\r\nstatic void free_cm_id(struct iwcm_id_private *cm_id_priv)\r\n{\r\ndealloc_work_entries(cm_id_priv);\r\nkfree(cm_id_priv);\r\n}\r\nstatic int iwcm_deref_id(struct iwcm_id_private *cm_id_priv)\r\n{\r\nBUG_ON(atomic_read(&cm_id_priv->refcount)==0);\r\nif (atomic_dec_and_test(&cm_id_priv->refcount)) {\r\nBUG_ON(!list_empty(&cm_id_priv->work_list));\r\ncomplete(&cm_id_priv->destroy_comp);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void add_ref(struct iw_cm_id *cm_id)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\natomic_inc(&cm_id_priv->refcount);\r\n}\r\nstatic void rem_ref(struct iw_cm_id *cm_id)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nif (iwcm_deref_id(cm_id_priv) &&\r\ntest_bit(IWCM_F_CALLBACK_DESTROY, &cm_id_priv->flags)) {\r\nBUG_ON(!list_empty(&cm_id_priv->work_list));\r\nfree_cm_id(cm_id_priv);\r\n}\r\n}\r\nstruct iw_cm_id *iw_create_cm_id(struct ib_device *device,\r\niw_cm_handler cm_handler,\r\nvoid *context)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\ncm_id_priv = kzalloc(sizeof(*cm_id_priv), GFP_KERNEL);\r\nif (!cm_id_priv)\r\nreturn ERR_PTR(-ENOMEM);\r\ncm_id_priv->state = IW_CM_STATE_IDLE;\r\ncm_id_priv->id.device = device;\r\ncm_id_priv->id.cm_handler = cm_handler;\r\ncm_id_priv->id.context = context;\r\ncm_id_priv->id.event_handler = cm_event_handler;\r\ncm_id_priv->id.add_ref = add_ref;\r\ncm_id_priv->id.rem_ref = rem_ref;\r\nspin_lock_init(&cm_id_priv->lock);\r\natomic_set(&cm_id_priv->refcount, 1);\r\ninit_waitqueue_head(&cm_id_priv->connect_wait);\r\ninit_completion(&cm_id_priv->destroy_comp);\r\nINIT_LIST_HEAD(&cm_id_priv->work_list);\r\nINIT_LIST_HEAD(&cm_id_priv->work_free_list);\r\nreturn &cm_id_priv->id;\r\n}\r\nstatic int iwcm_modify_qp_err(struct ib_qp *qp)\r\n{\r\nstruct ib_qp_attr qp_attr;\r\nif (!qp)\r\nreturn -EINVAL;\r\nqp_attr.qp_state = IB_QPS_ERR;\r\nreturn ib_modify_qp(qp, &qp_attr, IB_QP_STATE);\r\n}\r\nstatic int iwcm_modify_qp_sqd(struct ib_qp *qp)\r\n{\r\nstruct ib_qp_attr qp_attr;\r\nBUG_ON(qp == NULL);\r\nqp_attr.qp_state = IB_QPS_SQD;\r\nreturn ib_modify_qp(qp, &qp_attr, IB_QP_STATE);\r\n}\r\nint iw_cm_disconnect(struct iw_cm_id *cm_id, int abrupt)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\nunsigned long flags;\r\nint ret = 0;\r\nstruct ib_qp *qp = NULL;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nwait_event(cm_id_priv->connect_wait,\r\n!test_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags));\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id_priv->state) {\r\ncase IW_CM_STATE_ESTABLISHED:\r\ncm_id_priv->state = IW_CM_STATE_CLOSING;\r\nif (cm_id_priv->qp)\r\nqp = cm_id_priv->qp;\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_CM_STATE_LISTEN:\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_CM_STATE_CLOSING:\r\ncase IW_CM_STATE_IDLE:\r\nbreak;\r\ncase IW_CM_STATE_CONN_RECV:\r\nbreak;\r\ncase IW_CM_STATE_CONN_SENT:\r\ndefault:\r\nBUG();\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nif (qp) {\r\nif (abrupt)\r\nret = iwcm_modify_qp_err(qp);\r\nelse\r\nret = iwcm_modify_qp_sqd(qp);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void destroy_cm_id(struct iw_cm_id *cm_id)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\nunsigned long flags;\r\nint ret;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nwait_event(cm_id_priv->connect_wait,\r\n!test_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags));\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id_priv->state) {\r\ncase IW_CM_STATE_LISTEN:\r\ncm_id_priv->state = IW_CM_STATE_DESTROYING;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = cm_id->device->iwcm->destroy_listen(cm_id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nbreak;\r\ncase IW_CM_STATE_ESTABLISHED:\r\ncm_id_priv->state = IW_CM_STATE_DESTROYING;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\n(void)iwcm_modify_qp_err(cm_id_priv->qp);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nbreak;\r\ncase IW_CM_STATE_IDLE:\r\ncase IW_CM_STATE_CLOSING:\r\ncm_id_priv->state = IW_CM_STATE_DESTROYING;\r\nbreak;\r\ncase IW_CM_STATE_CONN_RECV:\r\ncm_id_priv->state = IW_CM_STATE_DESTROYING;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\ncm_id->device->iwcm->reject(cm_id, NULL, 0);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nbreak;\r\ncase IW_CM_STATE_CONN_SENT:\r\ncase IW_CM_STATE_DESTROYING:\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (cm_id_priv->qp) {\r\ncm_id_priv->id.device->iwcm->rem_ref(cm_id_priv->qp);\r\ncm_id_priv->qp = NULL;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\n(void)iwcm_deref_id(cm_id_priv);\r\n}\r\nvoid iw_destroy_cm_id(struct iw_cm_id *cm_id)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nBUG_ON(test_bit(IWCM_F_CALLBACK_DESTROY, &cm_id_priv->flags));\r\ndestroy_cm_id(cm_id);\r\nwait_for_completion(&cm_id_priv->destroy_comp);\r\nfree_cm_id(cm_id_priv);\r\n}\r\nint iw_cm_listen(struct iw_cm_id *cm_id, int backlog)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\nunsigned long flags;\r\nint ret;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nret = alloc_work_entries(cm_id_priv, backlog);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id_priv->state) {\r\ncase IW_CM_STATE_IDLE:\r\ncm_id_priv->state = IW_CM_STATE_LISTEN;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = cm_id->device->iwcm->create_listen(cm_id, backlog);\r\nif (ret)\r\ncm_id_priv->state = IW_CM_STATE_IDLE;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nint iw_cm_reject(struct iw_cm_id *cm_id,\r\nconst void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\nunsigned long flags;\r\nint ret;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nset_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id_priv->state != IW_CM_STATE_CONN_RECV) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\nreturn -EINVAL;\r\n}\r\ncm_id_priv->state = IW_CM_STATE_IDLE;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = cm_id->device->iwcm->reject(cm_id, private_data,\r\nprivate_data_len);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\nreturn ret;\r\n}\r\nint iw_cm_accept(struct iw_cm_id *cm_id,\r\nstruct iw_cm_conn_param *iw_param)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\nstruct ib_qp *qp;\r\nunsigned long flags;\r\nint ret;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nset_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id_priv->state != IW_CM_STATE_CONN_RECV) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\nreturn -EINVAL;\r\n}\r\nqp = cm_id->device->iwcm->get_qp(cm_id->device, iw_param->qpn);\r\nif (!qp) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\nreturn -EINVAL;\r\n}\r\ncm_id->device->iwcm->add_ref(qp);\r\ncm_id_priv->qp = qp;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = cm_id->device->iwcm->accept(cm_id, iw_param);\r\nif (ret) {\r\nBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_RECV);\r\ncm_id_priv->state = IW_CM_STATE_IDLE;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id_priv->qp) {\r\ncm_id->device->iwcm->rem_ref(qp);\r\ncm_id_priv->qp = NULL;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\n}\r\nreturn ret;\r\n}\r\nint iw_cm_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *iw_param)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\nint ret;\r\nunsigned long flags;\r\nstruct ib_qp *qp;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nret = alloc_work_entries(cm_id_priv, 4);\r\nif (ret)\r\nreturn ret;\r\nset_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id_priv->state != IW_CM_STATE_IDLE) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\nreturn -EINVAL;\r\n}\r\nqp = cm_id->device->iwcm->get_qp(cm_id->device, iw_param->qpn);\r\nif (!qp) {\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\nreturn -EINVAL;\r\n}\r\ncm_id->device->iwcm->add_ref(qp);\r\ncm_id_priv->qp = qp;\r\ncm_id_priv->state = IW_CM_STATE_CONN_SENT;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = cm_id->device->iwcm->connect(cm_id, iw_param);\r\nif (ret) {\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id_priv->qp) {\r\ncm_id->device->iwcm->rem_ref(qp);\r\ncm_id_priv->qp = NULL;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_SENT);\r\ncm_id_priv->state = IW_CM_STATE_IDLE;\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\n}\r\nreturn ret;\r\n}\r\nstatic void cm_conn_req_handler(struct iwcm_id_private *listen_id_priv,\r\nstruct iw_cm_event *iw_event)\r\n{\r\nunsigned long flags;\r\nstruct iw_cm_id *cm_id;\r\nstruct iwcm_id_private *cm_id_priv;\r\nint ret;\r\nBUG_ON(iw_event->status);\r\ncm_id = iw_create_cm_id(listen_id_priv->id.device,\r\nlisten_id_priv->id.cm_handler,\r\nlisten_id_priv->id.context);\r\nif (IS_ERR(cm_id))\r\ngoto out;\r\ncm_id->provider_data = iw_event->provider_data;\r\ncm_id->local_addr = iw_event->local_addr;\r\ncm_id->remote_addr = iw_event->remote_addr;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\ncm_id_priv->state = IW_CM_STATE_CONN_RECV;\r\nspin_lock_irqsave(&listen_id_priv->lock, flags);\r\nif (listen_id_priv->state != IW_CM_STATE_LISTEN) {\r\nspin_unlock_irqrestore(&listen_id_priv->lock, flags);\r\niw_cm_reject(cm_id, NULL, 0);\r\niw_destroy_cm_id(cm_id);\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&listen_id_priv->lock, flags);\r\nret = alloc_work_entries(cm_id_priv, 3);\r\nif (ret) {\r\niw_cm_reject(cm_id, NULL, 0);\r\niw_destroy_cm_id(cm_id);\r\ngoto out;\r\n}\r\nret = cm_id->cm_handler(cm_id, iw_event);\r\nif (ret) {\r\niw_cm_reject(cm_id, NULL, 0);\r\nset_bit(IWCM_F_CALLBACK_DESTROY, &cm_id_priv->flags);\r\ndestroy_cm_id(cm_id);\r\nif (atomic_read(&cm_id_priv->refcount)==0)\r\nfree_cm_id(cm_id_priv);\r\n}\r\nout:\r\nif (iw_event->private_data_len)\r\nkfree(iw_event->private_data);\r\n}\r\nstatic int cm_conn_est_handler(struct iwcm_id_private *cm_id_priv,\r\nstruct iw_cm_event *iw_event)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_RECV);\r\ncm_id_priv->state = IW_CM_STATE_ESTABLISHED;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = cm_id_priv->id.cm_handler(&cm_id_priv->id, iw_event);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\nreturn ret;\r\n}\r\nstatic int cm_conn_rep_handler(struct iwcm_id_private *cm_id_priv,\r\nstruct iw_cm_event *iw_event)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\r\nBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_SENT);\r\nif (iw_event->status == 0) {\r\ncm_id_priv->id.local_addr = iw_event->local_addr;\r\ncm_id_priv->id.remote_addr = iw_event->remote_addr;\r\ncm_id_priv->state = IW_CM_STATE_ESTABLISHED;\r\n} else {\r\ncm_id_priv->id.device->iwcm->rem_ref(cm_id_priv->qp);\r\ncm_id_priv->qp = NULL;\r\ncm_id_priv->state = IW_CM_STATE_IDLE;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = cm_id_priv->id.cm_handler(&cm_id_priv->id, iw_event);\r\nif (iw_event->private_data_len)\r\nkfree(iw_event->private_data);\r\nwake_up_all(&cm_id_priv->connect_wait);\r\nreturn ret;\r\n}\r\nstatic void cm_disconnect_handler(struct iwcm_id_private *cm_id_priv,\r\nstruct iw_cm_event *iw_event)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id_priv->state == IW_CM_STATE_ESTABLISHED)\r\ncm_id_priv->state = IW_CM_STATE_CLOSING;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\n}\r\nstatic int cm_close_handler(struct iwcm_id_private *cm_id_priv,\r\nstruct iw_cm_event *iw_event)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nif (cm_id_priv->qp) {\r\ncm_id_priv->id.device->iwcm->rem_ref(cm_id_priv->qp);\r\ncm_id_priv->qp = NULL;\r\n}\r\nswitch (cm_id_priv->state) {\r\ncase IW_CM_STATE_ESTABLISHED:\r\ncase IW_CM_STATE_CLOSING:\r\ncm_id_priv->state = IW_CM_STATE_IDLE;\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = cm_id_priv->id.cm_handler(&cm_id_priv->id, iw_event);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nbreak;\r\ncase IW_CM_STATE_DESTROYING:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int process_event(struct iwcm_id_private *cm_id_priv,\r\nstruct iw_cm_event *iw_event)\r\n{\r\nint ret = 0;\r\nswitch (iw_event->event) {\r\ncase IW_CM_EVENT_CONNECT_REQUEST:\r\ncm_conn_req_handler(cm_id_priv, iw_event);\r\nbreak;\r\ncase IW_CM_EVENT_CONNECT_REPLY:\r\nret = cm_conn_rep_handler(cm_id_priv, iw_event);\r\nbreak;\r\ncase IW_CM_EVENT_ESTABLISHED:\r\nret = cm_conn_est_handler(cm_id_priv, iw_event);\r\nbreak;\r\ncase IW_CM_EVENT_DISCONNECT:\r\ncm_disconnect_handler(cm_id_priv, iw_event);\r\nbreak;\r\ncase IW_CM_EVENT_CLOSE:\r\nret = cm_close_handler(cm_id_priv, iw_event);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn ret;\r\n}\r\nstatic void cm_work_handler(struct work_struct *_work)\r\n{\r\nstruct iwcm_work *work = container_of(_work, struct iwcm_work, work);\r\nstruct iw_cm_event levent;\r\nstruct iwcm_id_private *cm_id_priv = work->cm_id;\r\nunsigned long flags;\r\nint empty;\r\nint ret = 0;\r\nint destroy_id;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nempty = list_empty(&cm_id_priv->work_list);\r\nwhile (!empty) {\r\nwork = list_entry(cm_id_priv->work_list.next,\r\nstruct iwcm_work, list);\r\nlist_del_init(&work->list);\r\nempty = list_empty(&cm_id_priv->work_list);\r\nlevent = work->event;\r\nput_work(work);\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nret = process_event(cm_id_priv, &levent);\r\nif (ret) {\r\nset_bit(IWCM_F_CALLBACK_DESTROY, &cm_id_priv->flags);\r\ndestroy_cm_id(&cm_id_priv->id);\r\n}\r\nBUG_ON(atomic_read(&cm_id_priv->refcount)==0);\r\ndestroy_id = test_bit(IWCM_F_CALLBACK_DESTROY, &cm_id_priv->flags);\r\nif (iwcm_deref_id(cm_id_priv)) {\r\nif (destroy_id) {\r\nBUG_ON(!list_empty(&cm_id_priv->work_list));\r\nfree_cm_id(cm_id_priv);\r\n}\r\nreturn;\r\n}\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\n}\r\nstatic int cm_event_handler(struct iw_cm_id *cm_id,\r\nstruct iw_cm_event *iw_event)\r\n{\r\nstruct iwcm_work *work;\r\nstruct iwcm_id_private *cm_id_priv;\r\nunsigned long flags;\r\nint ret = 0;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nwork = get_work(cm_id_priv);\r\nif (!work) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nINIT_WORK(&work->work, cm_work_handler);\r\nwork->cm_id = cm_id_priv;\r\nwork->event = *iw_event;\r\nif ((work->event.event == IW_CM_EVENT_CONNECT_REQUEST ||\r\nwork->event.event == IW_CM_EVENT_CONNECT_REPLY) &&\r\nwork->event.private_data_len) {\r\nret = copy_private_data(&work->event);\r\nif (ret) {\r\nput_work(work);\r\ngoto out;\r\n}\r\n}\r\natomic_inc(&cm_id_priv->refcount);\r\nif (list_empty(&cm_id_priv->work_list)) {\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nqueue_work(iwcm_wq, &work->work);\r\n} else\r\nlist_add_tail(&work->list, &cm_id_priv->work_list);\r\nout:\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int iwcm_init_qp_init_attr(struct iwcm_id_private *cm_id_priv,\r\nstruct ib_qp_attr *qp_attr,\r\nint *qp_attr_mask)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id_priv->state) {\r\ncase IW_CM_STATE_IDLE:\r\ncase IW_CM_STATE_CONN_SENT:\r\ncase IW_CM_STATE_CONN_RECV:\r\ncase IW_CM_STATE_ESTABLISHED:\r\n*qp_attr_mask = IB_QP_STATE | IB_QP_ACCESS_FLAGS;\r\nqp_attr->qp_access_flags = IB_ACCESS_REMOTE_WRITE|\r\nIB_ACCESS_REMOTE_READ;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int iwcm_init_qp_rts_attr(struct iwcm_id_private *cm_id_priv,\r\nstruct ib_qp_attr *qp_attr,\r\nint *qp_attr_mask)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&cm_id_priv->lock, flags);\r\nswitch (cm_id_priv->state) {\r\ncase IW_CM_STATE_IDLE:\r\ncase IW_CM_STATE_CONN_SENT:\r\ncase IW_CM_STATE_CONN_RECV:\r\ncase IW_CM_STATE_ESTABLISHED:\r\n*qp_attr_mask = 0;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&cm_id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nint iw_cm_init_qp_attr(struct iw_cm_id *cm_id,\r\nstruct ib_qp_attr *qp_attr,\r\nint *qp_attr_mask)\r\n{\r\nstruct iwcm_id_private *cm_id_priv;\r\nint ret;\r\ncm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\r\nswitch (qp_attr->qp_state) {\r\ncase IB_QPS_INIT:\r\ncase IB_QPS_RTR:\r\nret = iwcm_init_qp_init_attr(cm_id_priv,\r\nqp_attr, qp_attr_mask);\r\nbreak;\r\ncase IB_QPS_RTS:\r\nret = iwcm_init_qp_rts_attr(cm_id_priv,\r\nqp_attr, qp_attr_mask);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init iw_cm_init(void)\r\n{\r\niwcm_wq = create_singlethread_workqueue("iw_cm_wq");\r\nif (!iwcm_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __exit iw_cm_cleanup(void)\r\n{\r\ndestroy_workqueue(iwcm_wq);\r\n}
