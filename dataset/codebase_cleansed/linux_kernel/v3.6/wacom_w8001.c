static void parse_pen_data(u8 *data, struct w8001_coord *coord)\r\n{\r\nmemset(coord, 0, sizeof(*coord));\r\ncoord->rdy = data[0] & 0x20;\r\ncoord->tsw = data[0] & 0x01;\r\ncoord->f1 = data[0] & 0x02;\r\ncoord->f2 = data[0] & 0x04;\r\ncoord->x = (data[1] & 0x7F) << 9;\r\ncoord->x |= (data[2] & 0x7F) << 2;\r\ncoord->x |= (data[6] & 0x60) >> 5;\r\ncoord->y = (data[3] & 0x7F) << 9;\r\ncoord->y |= (data[4] & 0x7F) << 2;\r\ncoord->y |= (data[6] & 0x18) >> 3;\r\ncoord->pen_pressure = data[5] & 0x7F;\r\ncoord->pen_pressure |= (data[6] & 0x07) << 7 ;\r\ncoord->tilt_x = data[7] & 0x7F;\r\ncoord->tilt_y = data[8] & 0x7F;\r\n}\r\nstatic void parse_single_touch(u8 *data, struct w8001_coord *coord)\r\n{\r\ncoord->x = (data[1] << 7) | data[2];\r\ncoord->y = (data[3] << 7) | data[4];\r\ncoord->tsw = data[0] & 0x01;\r\n}\r\nstatic void scale_touch_coordinates(struct w8001 *w8001,\r\nunsigned int *x, unsigned int *y)\r\n{\r\nif (w8001->max_pen_x && w8001->max_touch_x)\r\n*x = *x * w8001->max_pen_x / w8001->max_touch_x;\r\nif (w8001->max_pen_y && w8001->max_touch_y)\r\n*y = *y * w8001->max_pen_y / w8001->max_touch_y;\r\n}\r\nstatic void parse_multi_touch(struct w8001 *w8001)\r\n{\r\nstruct input_dev *dev = w8001->dev;\r\nunsigned char *data = w8001->data;\r\nunsigned int x, y;\r\nint i;\r\nint count = 0;\r\nfor (i = 0; i < 2; i++) {\r\nbool touch = data[0] & (1 << i);\r\ninput_mt_slot(dev, i);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, touch);\r\nif (touch) {\r\nx = (data[6 * i + 1] << 7) | data[6 * i + 2];\r\ny = (data[6 * i + 3] << 7) | data[6 * i + 4];\r\nscale_touch_coordinates(w8001, &x, &y);\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, y);\r\ncount++;\r\n}\r\n}\r\nif (w8001->type != BTN_TOOL_PEN &&\r\nw8001->type != BTN_TOOL_RUBBER) {\r\nw8001->type = count == 1 ? BTN_TOOL_FINGER : KEY_RESERVED;\r\ninput_mt_report_pointer_emulation(dev, true);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void parse_touchquery(u8 *data, struct w8001_touch_query *query)\r\n{\r\nmemset(query, 0, sizeof(*query));\r\nquery->panel_res = data[1];\r\nquery->sensor_id = data[2] & 0x7;\r\nquery->capacity_res = data[7];\r\nquery->x = data[3] << 9;\r\nquery->x |= data[4] << 2;\r\nquery->x |= (data[2] >> 5) & 0x3;\r\nquery->y = data[5] << 9;\r\nquery->y |= data[6] << 2;\r\nquery->y |= (data[2] >> 3) & 0x3;\r\nif (!query->x && !query->y) {\r\nquery->x = 1024;\r\nquery->y = 1024;\r\nif (query->panel_res)\r\nquery->x = query->y = (1 << query->panel_res);\r\nquery->panel_res = W8001_TOUCH_RESOLUTION;\r\n}\r\n}\r\nstatic void report_pen_events(struct w8001 *w8001, struct w8001_coord *coord)\r\n{\r\nstruct input_dev *dev = w8001->dev;\r\nswitch (w8001->type) {\r\ncase BTN_TOOL_RUBBER:\r\nif (!coord->f2) {\r\ninput_report_abs(dev, ABS_PRESSURE, 0);\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\ninput_report_key(dev, BTN_STYLUS, 0);\r\ninput_report_key(dev, BTN_STYLUS2, 0);\r\ninput_report_key(dev, BTN_TOOL_RUBBER, 0);\r\ninput_sync(dev);\r\nw8001->type = BTN_TOOL_PEN;\r\n}\r\nbreak;\r\ncase BTN_TOOL_FINGER:\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\ninput_report_key(dev, BTN_TOOL_FINGER, 0);\r\ninput_sync(dev);\r\ncase KEY_RESERVED:\r\nw8001->type = coord->f2 ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\r\nbreak;\r\ndefault:\r\ninput_report_key(dev, BTN_STYLUS2, coord->f2);\r\nbreak;\r\n}\r\ninput_report_abs(dev, ABS_X, coord->x);\r\ninput_report_abs(dev, ABS_Y, coord->y);\r\ninput_report_abs(dev, ABS_PRESSURE, coord->pen_pressure);\r\ninput_report_key(dev, BTN_TOUCH, coord->tsw);\r\ninput_report_key(dev, BTN_STYLUS, coord->f1);\r\ninput_report_key(dev, w8001->type, coord->rdy);\r\ninput_sync(dev);\r\nif (!coord->rdy)\r\nw8001->type = KEY_RESERVED;\r\n}\r\nstatic void report_single_touch(struct w8001 *w8001, struct w8001_coord *coord)\r\n{\r\nstruct input_dev *dev = w8001->dev;\r\nunsigned int x = coord->x;\r\nunsigned int y = coord->y;\r\nscale_touch_coordinates(w8001, &x, &y);\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\ninput_report_key(dev, BTN_TOUCH, coord->tsw);\r\ninput_report_key(dev, BTN_TOOL_FINGER, coord->tsw);\r\ninput_sync(dev);\r\nw8001->type = coord->tsw ? BTN_TOOL_FINGER : KEY_RESERVED;\r\n}\r\nstatic irqreturn_t w8001_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct w8001 *w8001 = serio_get_drvdata(serio);\r\nstruct w8001_coord coord;\r\nunsigned char tmp;\r\nw8001->data[w8001->idx] = data;\r\nswitch (w8001->idx++) {\r\ncase 0:\r\nif ((data & W8001_LEAD_MASK) != W8001_LEAD_BYTE) {\r\npr_debug("w8001: unsynchronized data: 0x%02x\n", data);\r\nw8001->idx = 0;\r\n}\r\nbreak;\r\ncase W8001_PKTLEN_TOUCH93 - 1:\r\ncase W8001_PKTLEN_TOUCH9A - 1:\r\ntmp = w8001->data[0] & W8001_TOUCH_BYTE;\r\nif (tmp != W8001_TOUCH_BYTE)\r\nbreak;\r\nif (w8001->pktlen == w8001->idx) {\r\nw8001->idx = 0;\r\nif (w8001->type != BTN_TOOL_PEN &&\r\nw8001->type != BTN_TOOL_RUBBER) {\r\nparse_single_touch(w8001->data, &coord);\r\nreport_single_touch(w8001, &coord);\r\n}\r\n}\r\nbreak;\r\ncase W8001_PKTLEN_TPCPEN - 1:\r\ntmp = w8001->data[0] & W8001_TAB_MASK;\r\nif (unlikely(tmp == W8001_TAB_BYTE))\r\nbreak;\r\ntmp = w8001->data[0] & W8001_TOUCH_BYTE;\r\nif (tmp == W8001_TOUCH_BYTE)\r\nbreak;\r\nw8001->idx = 0;\r\nparse_pen_data(w8001->data, &coord);\r\nreport_pen_events(w8001, &coord);\r\nbreak;\r\ncase W8001_PKTLEN_TPCCTL - 1:\r\ntmp = w8001->data[0] & W8001_TOUCH_MASK;\r\nif (tmp == W8001_TOUCH_BYTE)\r\nbreak;\r\nw8001->idx = 0;\r\nmemcpy(w8001->response, w8001->data, W8001_MAX_LENGTH);\r\nw8001->response_type = W8001_QUERY_PACKET;\r\ncomplete(&w8001->cmd_done);\r\nbreak;\r\ncase W8001_PKTLEN_TOUCH2FG - 1:\r\nw8001->idx = 0;\r\nparse_multi_touch(w8001);\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int w8001_command(struct w8001 *w8001, unsigned char command,\r\nbool wait_response)\r\n{\r\nint rc;\r\nw8001->response_type = 0;\r\ninit_completion(&w8001->cmd_done);\r\nrc = serio_write(w8001->serio, command);\r\nif (rc == 0 && wait_response) {\r\nwait_for_completion_timeout(&w8001->cmd_done, HZ);\r\nif (w8001->response_type != W8001_QUERY_PACKET)\r\nrc = -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic int w8001_open(struct input_dev *dev)\r\n{\r\nstruct w8001 *w8001 = input_get_drvdata(dev);\r\nreturn w8001_command(w8001, W8001_CMD_START, false);\r\n}\r\nstatic void w8001_close(struct input_dev *dev)\r\n{\r\nstruct w8001 *w8001 = input_get_drvdata(dev);\r\nw8001_command(w8001, W8001_CMD_STOP, false);\r\n}\r\nstatic int w8001_setup(struct w8001 *w8001)\r\n{\r\nstruct input_dev *dev = w8001->dev;\r\nstruct w8001_coord coord;\r\nstruct w8001_touch_query touch;\r\nint error;\r\nerror = w8001_command(w8001, W8001_CMD_STOP, false);\r\nif (error)\r\nreturn error;\r\nmsleep(250);\r\ndev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nstrlcat(w8001->name, "Wacom Serial", sizeof(w8001->name));\r\n__set_bit(INPUT_PROP_DIRECT, dev->propbit);\r\nerror = w8001_command(w8001, W8001_CMD_QUERY, true);\r\nif (!error) {\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(BTN_TOOL_PEN, dev->keybit);\r\n__set_bit(BTN_TOOL_RUBBER, dev->keybit);\r\n__set_bit(BTN_STYLUS, dev->keybit);\r\n__set_bit(BTN_STYLUS2, dev->keybit);\r\nparse_pen_data(w8001->response, &coord);\r\nw8001->max_pen_x = coord.x;\r\nw8001->max_pen_y = coord.y;\r\ninput_set_abs_params(dev, ABS_X, 0, coord.x, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, 0, coord.y, 0, 0);\r\ninput_abs_set_res(dev, ABS_X, W8001_PEN_RESOLUTION);\r\ninput_abs_set_res(dev, ABS_Y, W8001_PEN_RESOLUTION);\r\ninput_set_abs_params(dev, ABS_PRESSURE, 0, coord.pen_pressure, 0, 0);\r\nif (coord.tilt_x && coord.tilt_y) {\r\ninput_set_abs_params(dev, ABS_TILT_X, 0, coord.tilt_x, 0, 0);\r\ninput_set_abs_params(dev, ABS_TILT_Y, 0, coord.tilt_y, 0, 0);\r\n}\r\nw8001->id = 0x90;\r\nstrlcat(w8001->name, " Penabled", sizeof(w8001->name));\r\n}\r\nerror = w8001_command(w8001, W8001_CMD_TOUCHQUERY, true);\r\nif (!error && w8001->response[1]) {\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(BTN_TOOL_FINGER, dev->keybit);\r\nparse_touchquery(w8001->response, &touch);\r\nw8001->max_touch_x = touch.x;\r\nw8001->max_touch_y = touch.y;\r\nif (w8001->max_pen_x && w8001->max_pen_y) {\r\ntouch.x = w8001->max_pen_x;\r\ntouch.y = w8001->max_pen_y;\r\ntouch.panel_res = W8001_PEN_RESOLUTION;\r\n}\r\ninput_set_abs_params(dev, ABS_X, 0, touch.x, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, 0, touch.y, 0, 0);\r\ninput_abs_set_res(dev, ABS_X, touch.panel_res);\r\ninput_abs_set_res(dev, ABS_Y, touch.panel_res);\r\nswitch (touch.sensor_id) {\r\ncase 0:\r\ncase 2:\r\nw8001->pktlen = W8001_PKTLEN_TOUCH93;\r\nw8001->id = 0x93;\r\nstrlcat(w8001->name, " 1FG", sizeof(w8001->name));\r\nbreak;\r\ncase 1:\r\ncase 3:\r\ncase 4:\r\nw8001->pktlen = W8001_PKTLEN_TOUCH9A;\r\nstrlcat(w8001->name, " 1FG", sizeof(w8001->name));\r\nw8001->id = 0x9a;\r\nbreak;\r\ncase 5:\r\nw8001->pktlen = W8001_PKTLEN_TOUCH2FG;\r\ninput_mt_init_slots(dev, 2);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_X,\r\n0, touch.x, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_Y,\r\n0, touch.y, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_TOOL_TYPE,\r\n0, MT_TOOL_MAX, 0, 0);\r\nstrlcat(w8001->name, " 2FG", sizeof(w8001->name));\r\nif (w8001->max_pen_x && w8001->max_pen_y)\r\nw8001->id = 0xE3;\r\nelse\r\nw8001->id = 0xE2;\r\nbreak;\r\n}\r\n}\r\nstrlcat(w8001->name, " Touchscreen", sizeof(w8001->name));\r\nreturn 0;\r\n}\r\nstatic void w8001_disconnect(struct serio *serio)\r\n{\r\nstruct w8001 *w8001 = serio_get_drvdata(serio);\r\nserio_close(serio);\r\ninput_unregister_device(w8001->dev);\r\nkfree(w8001);\r\nserio_set_drvdata(serio, NULL);\r\n}\r\nstatic int w8001_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct w8001 *w8001;\r\nstruct input_dev *input_dev;\r\nint err;\r\nw8001 = kzalloc(sizeof(struct w8001), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!w8001 || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nw8001->serio = serio;\r\nw8001->dev = input_dev;\r\ninit_completion(&w8001->cmd_done);\r\nsnprintf(w8001->phys, sizeof(w8001->phys), "%s/input0", serio->phys);\r\nserio_set_drvdata(serio, w8001);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = w8001_setup(w8001);\r\nif (err)\r\ngoto fail3;\r\ninput_dev->name = w8001->name;\r\ninput_dev->phys = w8001->phys;\r\ninput_dev->id.product = w8001->id;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = 0x056a;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->open = w8001_open;\r\ninput_dev->close = w8001_close;\r\ninput_set_drvdata(input_dev, w8001);\r\nerr = input_register_device(w8001->dev);\r\nif (err)\r\ngoto fail3;\r\nreturn 0;\r\nfail3:\r\nserio_close(serio);\r\nfail2:\r\nserio_set_drvdata(serio, NULL);\r\nfail1:\r\ninput_free_device(input_dev);\r\nkfree(w8001);\r\nreturn err;\r\n}
