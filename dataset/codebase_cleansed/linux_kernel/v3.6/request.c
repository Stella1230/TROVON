const char *req_state_name(enum sci_base_request_states state)\r\n{\r\nstatic const char * const strings[] = REQUEST_STATES;\r\nreturn strings[state];\r\n}\r\nstatic struct scu_sgl_element_pair *to_sgl_element_pair(struct isci_request *ireq,\r\nint idx)\r\n{\r\nif (idx == 0)\r\nreturn &ireq->tc->sgl_pair_ab;\r\nelse if (idx == 1)\r\nreturn &ireq->tc->sgl_pair_cd;\r\nelse if (idx < 0)\r\nreturn NULL;\r\nelse\r\nreturn &ireq->sg_table[idx - 2];\r\n}\r\nstatic dma_addr_t to_sgl_element_pair_dma(struct isci_host *ihost,\r\nstruct isci_request *ireq, u32 idx)\r\n{\r\nu32 offset;\r\nif (idx == 0) {\r\noffset = (void *) &ireq->tc->sgl_pair_ab -\r\n(void *) &ihost->task_context_table[0];\r\nreturn ihost->tc_dma + offset;\r\n} else if (idx == 1) {\r\noffset = (void *) &ireq->tc->sgl_pair_cd -\r\n(void *) &ihost->task_context_table[0];\r\nreturn ihost->tc_dma + offset;\r\n}\r\nreturn sci_io_request_get_dma_addr(ireq, &ireq->sg_table[idx - 2]);\r\n}\r\nstatic void init_sgl_element(struct scu_sgl_element *e, struct scatterlist *sg)\r\n{\r\ne->length = sg_dma_len(sg);\r\ne->address_upper = upper_32_bits(sg_dma_address(sg));\r\ne->address_lower = lower_32_bits(sg_dma_address(sg));\r\ne->address_modifier = 0;\r\n}\r\nstatic void sci_request_build_sgl(struct isci_request *ireq)\r\n{\r\nstruct isci_host *ihost = ireq->isci_host;\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstruct scatterlist *sg = NULL;\r\ndma_addr_t dma_addr;\r\nu32 sg_idx = 0;\r\nstruct scu_sgl_element_pair *scu_sg = NULL;\r\nstruct scu_sgl_element_pair *prev_sg = NULL;\r\nif (task->num_scatter > 0) {\r\nsg = task->scatter;\r\nwhile (sg) {\r\nscu_sg = to_sgl_element_pair(ireq, sg_idx);\r\ninit_sgl_element(&scu_sg->A, sg);\r\nsg = sg_next(sg);\r\nif (sg) {\r\ninit_sgl_element(&scu_sg->B, sg);\r\nsg = sg_next(sg);\r\n} else\r\nmemset(&scu_sg->B, 0, sizeof(scu_sg->B));\r\nif (prev_sg) {\r\ndma_addr = to_sgl_element_pair_dma(ihost,\r\nireq,\r\nsg_idx);\r\nprev_sg->next_pair_upper =\r\nupper_32_bits(dma_addr);\r\nprev_sg->next_pair_lower =\r\nlower_32_bits(dma_addr);\r\n}\r\nprev_sg = scu_sg;\r\nsg_idx++;\r\n}\r\n} else {\r\nscu_sg = to_sgl_element_pair(ireq, sg_idx);\r\ndma_addr = dma_map_single(&ihost->pdev->dev,\r\ntask->scatter,\r\ntask->total_xfer_len,\r\ntask->data_dir);\r\nireq->zero_scatter_daddr = dma_addr;\r\nscu_sg->A.length = task->total_xfer_len;\r\nscu_sg->A.address_upper = upper_32_bits(dma_addr);\r\nscu_sg->A.address_lower = lower_32_bits(dma_addr);\r\n}\r\nif (scu_sg) {\r\nscu_sg->next_pair_upper = 0;\r\nscu_sg->next_pair_lower = 0;\r\n}\r\n}\r\nstatic void sci_io_request_build_ssp_command_iu(struct isci_request *ireq)\r\n{\r\nstruct ssp_cmd_iu *cmd_iu;\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\ncmd_iu = &ireq->ssp.cmd;\r\nmemcpy(cmd_iu->LUN, task->ssp_task.LUN, 8);\r\ncmd_iu->add_cdb_len = 0;\r\ncmd_iu->_r_a = 0;\r\ncmd_iu->_r_b = 0;\r\ncmd_iu->en_fburst = 0;\r\ncmd_iu->task_prio = task->ssp_task.task_prio;\r\ncmd_iu->task_attr = task->ssp_task.task_attr;\r\ncmd_iu->_r_c = 0;\r\nsci_swab32_cpy(&cmd_iu->cdb, task->ssp_task.cdb,\r\nsizeof(task->ssp_task.cdb) / sizeof(u32));\r\n}\r\nstatic void sci_task_request_build_ssp_task_iu(struct isci_request *ireq)\r\n{\r\nstruct ssp_task_iu *task_iu;\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstruct isci_tmf *isci_tmf = isci_request_access_tmf(ireq);\r\ntask_iu = &ireq->ssp.tmf;\r\nmemset(task_iu, 0, sizeof(struct ssp_task_iu));\r\nmemcpy(task_iu->LUN, task->ssp_task.LUN, 8);\r\ntask_iu->task_func = isci_tmf->tmf_code;\r\ntask_iu->task_tag =\r\n(test_bit(IREQ_TMF, &ireq->flags)) ?\r\nisci_tmf->io_tag :\r\nSCI_CONTROLLER_INVALID_IO_TAG;\r\n}\r\nstatic void scu_ssp_reqeust_construct_task_context(\r\nstruct isci_request *ireq,\r\nstruct scu_task_context *task_context)\r\n{\r\ndma_addr_t dma_addr;\r\nstruct isci_remote_device *idev;\r\nstruct isci_port *iport;\r\nidev = ireq->target_device;\r\niport = idev->owning_port;\r\ntask_context->abort = 0;\r\ntask_context->priority = 0;\r\ntask_context->initiator_request = 1;\r\ntask_context->connection_rate = idev->connection_rate;\r\ntask_context->protocol_engine_index = ISCI_PEG;\r\ntask_context->logical_port_index = iport->physical_port_index;\r\ntask_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;\r\ntask_context->valid = SCU_TASK_CONTEXT_VALID;\r\ntask_context->context_type = SCU_TASK_CONTEXT_TYPE;\r\ntask_context->remote_node_index = idev->rnc.remote_node_index;\r\ntask_context->command_code = 0;\r\ntask_context->link_layer_control = 0;\r\ntask_context->do_not_dma_ssp_good_response = 1;\r\ntask_context->strict_ordering = 0;\r\ntask_context->control_frame = 0;\r\ntask_context->timeout_enable = 0;\r\ntask_context->block_guard_enable = 0;\r\ntask_context->address_modifier = 0;\r\ntask_context->task_phase = 0x01;\r\nireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |\r\n(ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\r\n(iport->physical_port_index <<\r\nSCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\r\nISCI_TAG_TCI(ireq->io_tag));\r\ndma_addr = sci_io_request_get_dma_addr(ireq, &ireq->ssp.cmd);\r\ntask_context->command_iu_upper = upper_32_bits(dma_addr);\r\ntask_context->command_iu_lower = lower_32_bits(dma_addr);\r\ndma_addr = sci_io_request_get_dma_addr(ireq, &ireq->ssp.rsp);\r\ntask_context->response_iu_upper = upper_32_bits(dma_addr);\r\ntask_context->response_iu_lower = lower_32_bits(dma_addr);\r\n}\r\nstatic u8 scu_bg_blk_size(struct scsi_device *sdp)\r\n{\r\nswitch (sdp->sector_size) {\r\ncase 512:\r\nreturn 0;\r\ncase 1024:\r\nreturn 1;\r\ncase 4096:\r\nreturn 3;\r\ndefault:\r\nreturn 0xff;\r\n}\r\n}\r\nstatic u32 scu_dif_bytes(u32 len, u32 sector_size)\r\n{\r\nreturn (len >> ilog2(sector_size)) * 8;\r\n}\r\nstatic void scu_ssp_ireq_dif_insert(struct isci_request *ireq, u8 type, u8 op)\r\n{\r\nstruct scu_task_context *tc = ireq->tc;\r\nstruct scsi_cmnd *scmd = ireq->ttype_ptr.io_task_ptr->uldd_task;\r\nu8 blk_sz = scu_bg_blk_size(scmd->device);\r\ntc->block_guard_enable = 1;\r\ntc->blk_prot_en = 1;\r\ntc->blk_sz = blk_sz;\r\ntc->blk_prot_func = 0x2;\r\ntc->transfer_length_bytes += scu_dif_bytes(tc->transfer_length_bytes,\r\nscmd->device->sector_size);\r\ntc->interm_crc_val = 0;\r\ntc->init_crc_seed = 0;\r\ntc->app_tag_verify = 0;\r\ntc->app_tag_gen = 0;\r\ntc->ref_tag_seed_verify = 0;\r\ntc->UD_bytes_immed_val = scmd->device->sector_size;\r\ntc->reserved_DC_0 = 0;\r\ntc->DIF_bytes_immed_val = 8;\r\ntc->reserved_DC_1 = 0;\r\ntc->bgc_blk_sz = scmd->device->sector_size;\r\ntc->reserved_E0_0 = 0;\r\ntc->app_tag_gen_mask = 0;\r\ntc->bgctl = 0;\r\ntc->bgctl_f.op = 0x2;\r\ntc->app_tag_verify_mask = 0;\r\ntc->blk_guard_err = 0;\r\ntc->reserved_E8_0 = 0;\r\nif ((type & SCSI_PROT_DIF_TYPE1) || (type & SCSI_PROT_DIF_TYPE2))\r\ntc->ref_tag_seed_gen = scsi_get_lba(scmd) & 0xffffffff;\r\nelse if (type & SCSI_PROT_DIF_TYPE3)\r\ntc->ref_tag_seed_gen = 0;\r\n}\r\nstatic void scu_ssp_ireq_dif_strip(struct isci_request *ireq, u8 type, u8 op)\r\n{\r\nstruct scu_task_context *tc = ireq->tc;\r\nstruct scsi_cmnd *scmd = ireq->ttype_ptr.io_task_ptr->uldd_task;\r\nu8 blk_sz = scu_bg_blk_size(scmd->device);\r\ntc->block_guard_enable = 1;\r\ntc->blk_prot_en = 1;\r\ntc->blk_sz = blk_sz;\r\ntc->blk_prot_func = 0x1;\r\ntc->transfer_length_bytes += scu_dif_bytes(tc->transfer_length_bytes,\r\nscmd->device->sector_size);\r\ntc->interm_crc_val = 0;\r\ntc->init_crc_seed = 0;\r\ntc->app_tag_verify = 0;\r\ntc->app_tag_gen = 0;\r\nif ((type & SCSI_PROT_DIF_TYPE1) || (type & SCSI_PROT_DIF_TYPE2))\r\ntc->ref_tag_seed_verify = scsi_get_lba(scmd) & 0xffffffff;\r\nelse if (type & SCSI_PROT_DIF_TYPE3)\r\ntc->ref_tag_seed_verify = 0;\r\ntc->UD_bytes_immed_val = scmd->device->sector_size;\r\ntc->reserved_DC_0 = 0;\r\ntc->DIF_bytes_immed_val = 8;\r\ntc->reserved_DC_1 = 0;\r\ntc->bgc_blk_sz = scmd->device->sector_size;\r\ntc->reserved_E0_0 = 0;\r\ntc->app_tag_gen_mask = 0;\r\ntc->bgctl = 0;\r\ntc->bgctl_f.crc_verify = 1;\r\ntc->bgctl_f.op = 0x1;\r\nif ((type & SCSI_PROT_DIF_TYPE1) || (type & SCSI_PROT_DIF_TYPE2)) {\r\ntc->bgctl_f.ref_tag_chk = 1;\r\ntc->bgctl_f.app_f_detect = 1;\r\n} else if (type & SCSI_PROT_DIF_TYPE3)\r\ntc->bgctl_f.app_ref_f_detect = 1;\r\ntc->app_tag_verify_mask = 0;\r\ntc->blk_guard_err = 0;\r\ntc->reserved_E8_0 = 0;\r\ntc->ref_tag_seed_gen = 0;\r\n}\r\nstatic void scu_ssp_io_request_construct_task_context(struct isci_request *ireq,\r\nenum dma_data_direction dir,\r\nu32 len)\r\n{\r\nstruct scu_task_context *task_context = ireq->tc;\r\nstruct sas_task *sas_task = ireq->ttype_ptr.io_task_ptr;\r\nstruct scsi_cmnd *scmd = sas_task->uldd_task;\r\nu8 prot_type = scsi_get_prot_type(scmd);\r\nu8 prot_op = scsi_get_prot_op(scmd);\r\nscu_ssp_reqeust_construct_task_context(ireq, task_context);\r\ntask_context->ssp_command_iu_length =\r\nsizeof(struct ssp_cmd_iu) / sizeof(u32);\r\ntask_context->type.ssp.frame_type = SSP_COMMAND;\r\nswitch (dir) {\r\ncase DMA_FROM_DEVICE:\r\ncase DMA_NONE:\r\ndefault:\r\ntask_context->task_type = SCU_TASK_TYPE_IOREAD;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\ntask_context->task_type = SCU_TASK_TYPE_IOWRITE;\r\nbreak;\r\n}\r\ntask_context->transfer_length_bytes = len;\r\nif (task_context->transfer_length_bytes > 0)\r\nsci_request_build_sgl(ireq);\r\nif (prot_type != SCSI_PROT_DIF_TYPE0) {\r\nif (prot_op == SCSI_PROT_READ_STRIP)\r\nscu_ssp_ireq_dif_strip(ireq, prot_type, prot_op);\r\nelse if (prot_op == SCSI_PROT_WRITE_INSERT)\r\nscu_ssp_ireq_dif_insert(ireq, prot_type, prot_op);\r\n}\r\n}\r\nstatic void scu_ssp_task_request_construct_task_context(struct isci_request *ireq)\r\n{\r\nstruct scu_task_context *task_context = ireq->tc;\r\nscu_ssp_reqeust_construct_task_context(ireq, task_context);\r\ntask_context->control_frame = 1;\r\ntask_context->priority = SCU_TASK_PRIORITY_HIGH;\r\ntask_context->task_type = SCU_TASK_TYPE_RAW_FRAME;\r\ntask_context->transfer_length_bytes = 0;\r\ntask_context->type.ssp.frame_type = SSP_TASK;\r\ntask_context->ssp_command_iu_length =\r\nsizeof(struct ssp_task_iu) / sizeof(u32);\r\n}\r\nstatic void scu_sata_reqeust_construct_task_context(\r\nstruct isci_request *ireq,\r\nstruct scu_task_context *task_context)\r\n{\r\ndma_addr_t dma_addr;\r\nstruct isci_remote_device *idev;\r\nstruct isci_port *iport;\r\nidev = ireq->target_device;\r\niport = idev->owning_port;\r\ntask_context->abort = 0;\r\ntask_context->priority = SCU_TASK_PRIORITY_NORMAL;\r\ntask_context->initiator_request = 1;\r\ntask_context->connection_rate = idev->connection_rate;\r\ntask_context->protocol_engine_index = ISCI_PEG;\r\ntask_context->logical_port_index = iport->physical_port_index;\r\ntask_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_STP;\r\ntask_context->valid = SCU_TASK_CONTEXT_VALID;\r\ntask_context->context_type = SCU_TASK_CONTEXT_TYPE;\r\ntask_context->remote_node_index = idev->rnc.remote_node_index;\r\ntask_context->command_code = 0;\r\ntask_context->link_layer_control = 0;\r\ntask_context->do_not_dma_ssp_good_response = 1;\r\ntask_context->strict_ordering = 0;\r\ntask_context->control_frame = 0;\r\ntask_context->timeout_enable = 0;\r\ntask_context->block_guard_enable = 0;\r\ntask_context->address_modifier = 0;\r\ntask_context->task_phase = 0x01;\r\ntask_context->ssp_command_iu_length =\r\n(sizeof(struct host_to_dev_fis) - sizeof(u32)) / sizeof(u32);\r\ntask_context->type.words[0] = *(u32 *)&ireq->stp.cmd;\r\nireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |\r\n(ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\r\n(iport->physical_port_index <<\r\nSCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\r\nISCI_TAG_TCI(ireq->io_tag));\r\ndma_addr = sci_io_request_get_dma_addr(ireq,\r\n((char *) &ireq->stp.cmd) +\r\nsizeof(u32));\r\ntask_context->command_iu_upper = upper_32_bits(dma_addr);\r\ntask_context->command_iu_lower = lower_32_bits(dma_addr);\r\ntask_context->response_iu_upper = 0;\r\ntask_context->response_iu_lower = 0;\r\n}\r\nstatic void scu_stp_raw_request_construct_task_context(struct isci_request *ireq)\r\n{\r\nstruct scu_task_context *task_context = ireq->tc;\r\nscu_sata_reqeust_construct_task_context(ireq, task_context);\r\ntask_context->control_frame = 0;\r\ntask_context->priority = SCU_TASK_PRIORITY_NORMAL;\r\ntask_context->task_type = SCU_TASK_TYPE_SATA_RAW_FRAME;\r\ntask_context->type.stp.fis_type = FIS_REGH2D;\r\ntask_context->transfer_length_bytes = sizeof(struct host_to_dev_fis) - sizeof(u32);\r\n}\r\nstatic enum sci_status sci_stp_pio_request_construct(struct isci_request *ireq,\r\nbool copy_rx_frame)\r\n{\r\nstruct isci_stp_request *stp_req = &ireq->stp.req;\r\nscu_stp_raw_request_construct_task_context(ireq);\r\nstp_req->status = 0;\r\nstp_req->sgl.offset = 0;\r\nstp_req->sgl.set = SCU_SGL_ELEMENT_PAIR_A;\r\nif (copy_rx_frame) {\r\nsci_request_build_sgl(ireq);\r\nstp_req->sgl.index = 0;\r\n} else {\r\nstp_req->sgl.index = -1;\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic void sci_stp_optimized_request_construct(struct isci_request *ireq,\r\nu8 optimized_task_type,\r\nu32 len,\r\nenum dma_data_direction dir)\r\n{\r\nstruct scu_task_context *task_context = ireq->tc;\r\nscu_sata_reqeust_construct_task_context(ireq, task_context);\r\nsci_request_build_sgl(ireq);\r\ntask_context->transfer_length_bytes = len;\r\nif (dir == DMA_TO_DEVICE) {\r\ntask_context->task_type = optimized_task_type + (SCU_TASK_TYPE_DMA_OUT\r\n- SCU_TASK_TYPE_DMA_IN);\r\n} else {\r\ntask_context->task_type = optimized_task_type;\r\n}\r\n}\r\nstatic void sci_atapi_construct(struct isci_request *ireq)\r\n{\r\nstruct host_to_dev_fis *h2d_fis = &ireq->stp.cmd;\r\nstruct sas_task *task;\r\nh2d_fis->features |= ATAPI_PKT_DMA;\r\nscu_stp_raw_request_construct_task_context(ireq);\r\ntask = isci_request_access_task(ireq);\r\nif (task->data_dir == DMA_NONE)\r\ntask->total_xfer_len = 0;\r\nireq->stp.rsp.fis_type = 0;\r\n}\r\nstatic enum sci_status\r\nsci_io_request_construct_sata(struct isci_request *ireq,\r\nu32 len,\r\nenum dma_data_direction dir,\r\nbool copy)\r\n{\r\nenum sci_status status = SCI_SUCCESS;\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstruct domain_device *dev = ireq->target_device->domain_dev;\r\nif (test_bit(IREQ_TMF, &ireq->flags)) {\r\nstruct isci_tmf *tmf = isci_request_access_tmf(ireq);\r\ndev_err(&ireq->owning_controller->pdev->dev,\r\n"%s: Request 0x%p received un-handled SAT "\r\n"management protocol 0x%x.\n",\r\n__func__, ireq, tmf->tmf_code);\r\nreturn SCI_FAILURE;\r\n}\r\nif (!sas_protocol_ata(task->task_proto)) {\r\ndev_err(&ireq->owning_controller->pdev->dev,\r\n"%s: Non-ATA protocol in SATA path: 0x%x\n",\r\n__func__,\r\ntask->task_proto);\r\nreturn SCI_FAILURE;\r\n}\r\nif (dev->sata_dev.command_set == ATAPI_COMMAND_SET &&\r\ntask->ata_task.fis.command == ATA_CMD_PACKET) {\r\nsci_atapi_construct(ireq);\r\nreturn SCI_SUCCESS;\r\n}\r\nif (task->data_dir == DMA_NONE) {\r\nscu_stp_raw_request_construct_task_context(ireq);\r\nreturn SCI_SUCCESS;\r\n}\r\nif (task->ata_task.use_ncq) {\r\nsci_stp_optimized_request_construct(ireq,\r\nSCU_TASK_TYPE_FPDMAQ_READ,\r\nlen, dir);\r\nreturn SCI_SUCCESS;\r\n}\r\nif (task->ata_task.dma_xfer) {\r\nsci_stp_optimized_request_construct(ireq,\r\nSCU_TASK_TYPE_DMA_IN,\r\nlen, dir);\r\nreturn SCI_SUCCESS;\r\n} else\r\nreturn sci_stp_pio_request_construct(ireq, copy);\r\nreturn status;\r\n}\r\nstatic enum sci_status sci_io_request_construct_basic_ssp(struct isci_request *ireq)\r\n{\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nireq->protocol = SAS_PROTOCOL_SSP;\r\nscu_ssp_io_request_construct_task_context(ireq,\r\ntask->data_dir,\r\ntask->total_xfer_len);\r\nsci_io_request_build_ssp_command_iu(ireq);\r\nsci_change_state(&ireq->sm, SCI_REQ_CONSTRUCTED);\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status sci_task_request_construct_ssp(\r\nstruct isci_request *ireq)\r\n{\r\nscu_ssp_task_request_construct_task_context(ireq);\r\nsci_task_request_build_ssp_task_iu(ireq);\r\nsci_change_state(&ireq->sm, SCI_REQ_CONSTRUCTED);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status sci_io_request_construct_basic_sata(struct isci_request *ireq)\r\n{\r\nenum sci_status status;\r\nbool copy = false;\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nireq->protocol = SAS_PROTOCOL_STP;\r\ncopy = (task->data_dir == DMA_NONE) ? false : true;\r\nstatus = sci_io_request_construct_sata(ireq,\r\ntask->total_xfer_len,\r\ntask->data_dir,\r\ncopy);\r\nif (status == SCI_SUCCESS)\r\nsci_change_state(&ireq->sm, SCI_REQ_CONSTRUCTED);\r\nreturn status;\r\n}\r\nstatic u32 sci_req_tx_bytes(struct isci_request *ireq)\r\n{\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nu32 ret_val = 0;\r\nif (readl(&ihost->smu_registers->address_modifier) == 0) {\r\nvoid __iomem *scu_reg_base = ihost->scu_registers;\r\nret_val = readl(scu_reg_base +\r\n(SCU_TASK_CONTEXT_SRAM + offsetof(struct scu_task_context, type.ssp.data_offset)) +\r\n((sizeof(struct scu_task_context)) * ISCI_TAG_TCI(ireq->io_tag)));\r\n}\r\nreturn ret_val;\r\n}\r\nenum sci_status sci_request_start(struct isci_request *ireq)\r\n{\r\nenum sci_base_request_states state;\r\nstruct scu_task_context *tc = ireq->tc;\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nstate = ireq->sm.current_state_id;\r\nif (state != SCI_REQ_CONSTRUCTED) {\r\ndev_warn(&ihost->pdev->dev,\r\n"%s: SCIC IO Request requested to start while in wrong "\r\n"state %d\n", __func__, state);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\ntc->task_index = ISCI_TAG_TCI(ireq->io_tag);\r\nswitch (tc->protocol_type) {\r\ncase SCU_TASK_CONTEXT_PROTOCOL_SMP:\r\ncase SCU_TASK_CONTEXT_PROTOCOL_SSP:\r\ntc->type.ssp.tag = ireq->io_tag;\r\ntc->type.ssp.target_port_transfer_tag = 0xFFFF;\r\nbreak;\r\ncase SCU_TASK_CONTEXT_PROTOCOL_STP:\r\nbreak;\r\ncase SCU_TASK_CONTEXT_PROTOCOL_NONE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nireq->post_context |= ISCI_TAG_TCI(ireq->io_tag);\r\nsci_change_state(&ireq->sm, SCI_REQ_STARTED);\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status\r\nsci_io_request_terminate(struct isci_request *ireq)\r\n{\r\nenum sci_base_request_states state;\r\nstate = ireq->sm.current_state_id;\r\nswitch (state) {\r\ncase SCI_REQ_CONSTRUCTED:\r\nset_bit(IREQ_TC_ABORT_POSTED, &ireq->flags);\r\nireq->scu_status = SCU_TASK_DONE_TASK_ABORT;\r\nireq->sci_status = SCI_FAILURE_IO_TERMINATED;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nreturn SCI_SUCCESS;\r\ncase SCI_REQ_STARTED:\r\ncase SCI_REQ_TASK_WAIT_TC_COMP:\r\ncase SCI_REQ_SMP_WAIT_RESP:\r\ncase SCI_REQ_SMP_WAIT_TC_COMP:\r\ncase SCI_REQ_STP_UDMA_WAIT_TC_COMP:\r\ncase SCI_REQ_STP_UDMA_WAIT_D2H:\r\ncase SCI_REQ_STP_NON_DATA_WAIT_H2D:\r\ncase SCI_REQ_STP_NON_DATA_WAIT_D2H:\r\ncase SCI_REQ_STP_PIO_WAIT_H2D:\r\ncase SCI_REQ_STP_PIO_WAIT_FRAME:\r\ncase SCI_REQ_STP_PIO_DATA_IN:\r\ncase SCI_REQ_STP_PIO_DATA_OUT:\r\ncase SCI_REQ_ATAPI_WAIT_H2D:\r\ncase SCI_REQ_ATAPI_WAIT_PIO_SETUP:\r\ncase SCI_REQ_ATAPI_WAIT_D2H:\r\ncase SCI_REQ_ATAPI_WAIT_TC_COMP:\r\ncase SCI_REQ_TASK_WAIT_TC_RESP:\r\nsci_change_state(&ireq->sm, SCI_REQ_ABORTING);\r\ncase SCI_REQ_ABORTING:\r\nif (!isci_remote_device_is_safe_to_abort(ireq->target_device))\r\nset_bit(IREQ_PENDING_ABORT, &ireq->flags);\r\nelse\r\nclear_bit(IREQ_PENDING_ABORT, &ireq->flags);\r\nreturn SCI_SUCCESS;\r\ncase SCI_REQ_COMPLETED:\r\ndefault:\r\ndev_warn(&ireq->owning_controller->pdev->dev,\r\n"%s: SCIC IO Request requested to abort while in wrong "\r\n"state %d\n", __func__, ireq->sm.current_state_id);\r\nbreak;\r\n}\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nenum sci_status sci_request_complete(struct isci_request *ireq)\r\n{\r\nenum sci_base_request_states state;\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nstate = ireq->sm.current_state_id;\r\nif (WARN_ONCE(state != SCI_REQ_COMPLETED,\r\n"isci: request completion from wrong state (%s)\n",\r\nreq_state_name(state)))\r\nreturn SCI_FAILURE_INVALID_STATE;\r\nif (ireq->saved_rx_frame_index != SCU_INVALID_FRAME_INDEX)\r\nsci_controller_release_frame(ihost,\r\nireq->saved_rx_frame_index);\r\nsci_change_state(&ireq->sm, SCI_REQ_FINAL);\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status sci_io_request_event_handler(struct isci_request *ireq,\r\nu32 event_code)\r\n{\r\nenum sci_base_request_states state;\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nstate = ireq->sm.current_state_id;\r\nif (state != SCI_REQ_STP_PIO_DATA_IN) {\r\ndev_warn(&ihost->pdev->dev, "%s: (%x) in wrong state %s\n",\r\n__func__, event_code, req_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nswitch (scu_get_event_specifier(event_code)) {\r\ncase SCU_TASK_DONE_CRC_ERR << SCU_EVENT_SPECIFIC_CODE_SHIFT:\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\r\nreturn SCI_SUCCESS;\r\ndefault:\r\ndev_err(&ihost->pdev->dev,\r\n"%s: pio request unexpected event %#x\n",\r\n__func__, event_code);\r\nreturn SCI_FAILURE;\r\n}\r\n}\r\nstatic void sci_io_request_copy_response(struct isci_request *ireq)\r\n{\r\nvoid *resp_buf;\r\nu32 len;\r\nstruct ssp_response_iu *ssp_response;\r\nstruct isci_tmf *isci_tmf = isci_request_access_tmf(ireq);\r\nssp_response = &ireq->ssp.rsp;\r\nresp_buf = &isci_tmf->resp.resp_iu;\r\nlen = min_t(u32,\r\nSSP_RESP_IU_MAX_SIZE,\r\nbe32_to_cpu(ssp_response->response_data_len));\r\nmemcpy(resp_buf, ssp_response->resp_data, len);\r\n}\r\nstatic enum sci_status\r\nrequest_started_state_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nstruct ssp_response_iu *resp_iu;\r\nu8 datapres;\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nbreak;\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_EARLY_RESP): {\r\nstruct ssp_response_iu *resp = &ireq->ssp.rsp;\r\nssize_t word_cnt = SSP_RESP_IU_MAX_SIZE / sizeof(u32);\r\nsci_swab32_cpy(&ireq->ssp.rsp,\r\n&ireq->ssp.rsp,\r\nword_cnt);\r\nif (resp->status == 0) {\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS_IO_DONE_EARLY;\r\n} else {\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\n}\r\nbreak;\r\n}\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_CHECK_RESPONSE): {\r\nssize_t word_cnt = SSP_RESP_IU_MAX_SIZE / sizeof(u32);\r\nsci_swab32_cpy(&ireq->ssp.rsp,\r\n&ireq->ssp.rsp,\r\nword_cnt);\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\nbreak;\r\n}\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_RESP_LEN_ERR):\r\nresp_iu = &ireq->ssp.rsp;\r\ndatapres = resp_iu->datapres;\r\nif (datapres == 1 || datapres == 2) {\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\n} else {\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\n}\r\nbreak;\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_ACK_NAK_TO):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_LL_PERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_NAK_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_DATA_LEN_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_LL_ABORT_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_XR_WD_LEN):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_MAX_PLD_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_RESP):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_SDBFIS):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_REG_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SDB_ERR):\r\nif (ireq->protocol == SAS_PROTOCOL_STP) {\r\nireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>\r\nSCU_COMPLETION_TL_STATUS_SHIFT;\r\nireq->sci_status = SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;\r\n} else {\r\nireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>\r\nSCU_COMPLETION_TL_STATUS_SHIFT;\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\n}\r\nbreak;\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_LF_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_WRONG_DESTINATION):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_BAD_DESTINATION):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_ZONE_VIOLATION):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED):\r\nireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>\r\nSCU_COMPLETION_TL_STATUS_SHIFT;\r\nireq->sci_status = SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;\r\nbreak;\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_NAK_CMD_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_XR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_XR_IU_LEN_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SDMA_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_OFFSET_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_EXCESS_DATA):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_RESP_TO_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_UFI_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_FRM_TYPE_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_LL_RX_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_DATA):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_OPEN_FAIL):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_VIIT_ENTRY_NV):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_IIT_ENTRY_NV):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_RNCNV_OUTBOUND):\r\ndefault:\r\nireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>\r\nSCU_COMPLETION_TL_STATUS_SHIFT;\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nbreak;\r\n}\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status\r\nrequest_aborting_state_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase (SCU_TASK_DONE_GOOD << SCU_COMPLETION_TL_STATUS_SHIFT):\r\ncase (SCU_TASK_DONE_TASK_ABORT << SCU_COMPLETION_TL_STATUS_SHIFT):\r\nireq->scu_status = SCU_TASK_DONE_TASK_ABORT;\r\nireq->sci_status = SCI_FAILURE_IO_TERMINATED;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status ssp_task_request_await_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, SCI_REQ_TASK_WAIT_TC_RESP);\r\nbreak;\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_ACK_NAK_TO):\r\ndev_warn(&ireq->owning_controller->pdev->dev,\r\n"%s: TaskRequest:0x%p CompletionCode:%x - "\r\n"ACK/NAK timeout\n", __func__, ireq,\r\ncompletion_code);\r\nsci_change_state(&ireq->sm, SCI_REQ_TASK_WAIT_TC_RESP);\r\nbreak;\r\ndefault:\r\nireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status\r\nsmp_request_await_response_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_RESP_TO_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_UFI_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_FRM_TYPE_ERR):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_LL_RX_ERR):\r\nireq->scu_status = SCU_TASK_DONE_SMP_RESP_TO_ERR;\r\nireq->sci_status = SCI_FAILURE_RETRY_REQUIRED;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\ndefault:\r\nireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status\r\nsmp_request_await_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\ndefault:\r\nireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic struct scu_sgl_element *pio_sgl_next(struct isci_stp_request *stp_req)\r\n{\r\nstruct scu_sgl_element *sgl;\r\nstruct scu_sgl_element_pair *sgl_pair;\r\nstruct isci_request *ireq = to_ireq(stp_req);\r\nstruct isci_stp_pio_sgl *pio_sgl = &stp_req->sgl;\r\nsgl_pair = to_sgl_element_pair(ireq, pio_sgl->index);\r\nif (!sgl_pair)\r\nsgl = NULL;\r\nelse if (pio_sgl->set == SCU_SGL_ELEMENT_PAIR_A) {\r\nif (sgl_pair->B.address_lower == 0 &&\r\nsgl_pair->B.address_upper == 0) {\r\nsgl = NULL;\r\n} else {\r\npio_sgl->set = SCU_SGL_ELEMENT_PAIR_B;\r\nsgl = &sgl_pair->B;\r\n}\r\n} else {\r\nif (sgl_pair->next_pair_lower == 0 &&\r\nsgl_pair->next_pair_upper == 0) {\r\nsgl = NULL;\r\n} else {\r\npio_sgl->index++;\r\npio_sgl->set = SCU_SGL_ELEMENT_PAIR_A;\r\nsgl_pair = to_sgl_element_pair(ireq, pio_sgl->index);\r\nsgl = &sgl_pair->A;\r\n}\r\n}\r\nreturn sgl;\r\n}\r\nstatic enum sci_status\r\nstp_request_non_data_await_h2d_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_NON_DATA_WAIT_D2H);\r\nbreak;\r\ndefault:\r\nireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status sci_stp_request_pio_data_out_trasmit_data_frame(\r\nstruct isci_request *ireq,\r\nu32 length)\r\n{\r\nstruct isci_stp_request *stp_req = &ireq->stp.req;\r\nstruct scu_task_context *task_context = ireq->tc;\r\nstruct scu_sgl_element_pair *sgl_pair;\r\nstruct scu_sgl_element *current_sgl;\r\nsgl_pair = to_sgl_element_pair(ireq, stp_req->sgl.index);\r\nif (stp_req->sgl.set == SCU_SGL_ELEMENT_PAIR_A)\r\ncurrent_sgl = &sgl_pair->A;\r\nelse\r\ncurrent_sgl = &sgl_pair->B;\r\ntask_context->command_iu_upper = current_sgl->address_upper;\r\ntask_context->command_iu_lower = current_sgl->address_lower;\r\ntask_context->transfer_length_bytes = length;\r\ntask_context->type.stp.fis_type = FIS_DATA;\r\nreturn sci_controller_continue_io(ireq);\r\n}\r\nstatic enum sci_status sci_stp_request_pio_data_out_transmit_data(struct isci_request *ireq)\r\n{\r\nstruct isci_stp_request *stp_req = &ireq->stp.req;\r\nstruct scu_sgl_element_pair *sgl_pair;\r\nenum sci_status status = SCI_SUCCESS;\r\nstruct scu_sgl_element *sgl;\r\nu32 offset;\r\nu32 len = 0;\r\noffset = stp_req->sgl.offset;\r\nsgl_pair = to_sgl_element_pair(ireq, stp_req->sgl.index);\r\nif (WARN_ONCE(!sgl_pair, "%s: null sgl element", __func__))\r\nreturn SCI_FAILURE;\r\nif (stp_req->sgl.set == SCU_SGL_ELEMENT_PAIR_A) {\r\nsgl = &sgl_pair->A;\r\nlen = sgl_pair->A.length - offset;\r\n} else {\r\nsgl = &sgl_pair->B;\r\nlen = sgl_pair->B.length - offset;\r\n}\r\nif (stp_req->pio_len == 0)\r\nreturn SCI_SUCCESS;\r\nif (stp_req->pio_len >= len) {\r\nstatus = sci_stp_request_pio_data_out_trasmit_data_frame(ireq, len);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstp_req->pio_len -= len;\r\nsgl = pio_sgl_next(stp_req);\r\noffset = 0;\r\n} else if (stp_req->pio_len < len) {\r\nsci_stp_request_pio_data_out_trasmit_data_frame(ireq, stp_req->pio_len);\r\noffset += stp_req->pio_len;\r\nsgl->address_lower += stp_req->pio_len;\r\nstp_req->pio_len = 0;\r\n}\r\nstp_req->sgl.offset = offset;\r\nreturn status;\r\n}\r\nstatic enum sci_status\r\nsci_stp_request_pio_data_in_copy_data_buffer(struct isci_stp_request *stp_req,\r\nu8 *data_buf, u32 len)\r\n{\r\nstruct isci_request *ireq;\r\nu8 *src_addr;\r\nint copy_len;\r\nstruct sas_task *task;\r\nstruct scatterlist *sg;\r\nvoid *kaddr;\r\nint total_len = len;\r\nireq = to_ireq(stp_req);\r\ntask = isci_request_access_task(ireq);\r\nsrc_addr = data_buf;\r\nif (task->num_scatter > 0) {\r\nsg = task->scatter;\r\nwhile (total_len > 0) {\r\nstruct page *page = sg_page(sg);\r\ncopy_len = min_t(int, total_len, sg_dma_len(sg));\r\nkaddr = kmap_atomic(page);\r\nmemcpy(kaddr + sg->offset, src_addr, copy_len);\r\nkunmap_atomic(kaddr);\r\ntotal_len -= copy_len;\r\nsrc_addr += copy_len;\r\nsg = sg_next(sg);\r\n}\r\n} else {\r\nBUG_ON(task->total_xfer_len < total_len);\r\nmemcpy(task->scatter, src_addr, total_len);\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status sci_stp_request_pio_data_in_copy_data(\r\nstruct isci_stp_request *stp_req,\r\nu8 *data_buffer)\r\n{\r\nenum sci_status status;\r\nif (stp_req->pio_len < SCU_MAX_FRAME_BUFFER_SIZE) {\r\nstatus = sci_stp_request_pio_data_in_copy_data_buffer(\r\nstp_req, data_buffer, stp_req->pio_len);\r\nif (status == SCI_SUCCESS)\r\nstp_req->pio_len = 0;\r\n} else {\r\nstatus = sci_stp_request_pio_data_in_copy_data_buffer(\r\nstp_req, data_buffer, SCU_MAX_FRAME_BUFFER_SIZE);\r\nif (status == SCI_SUCCESS)\r\nstp_req->pio_len -= SCU_MAX_FRAME_BUFFER_SIZE;\r\n}\r\nreturn status;\r\n}\r\nstatic enum sci_status\r\nstp_request_pio_await_h2d_completion_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nenum sci_status status = SCI_SUCCESS;\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\r\nbreak;\r\ndefault:\r\nireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum sci_status\r\npio_data_out_tx_done_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nenum sci_status status = SCI_SUCCESS;\r\nbool all_frames_transferred = false;\r\nstruct isci_stp_request *stp_req = &ireq->stp.req;\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nif (stp_req->pio_len != 0) {\r\nstatus = sci_stp_request_pio_data_out_transmit_data(ireq);\r\nif (status == SCI_SUCCESS) {\r\nif (stp_req->pio_len == 0)\r\nall_frames_transferred = true;\r\n}\r\n} else if (stp_req->pio_len == 0) {\r\nall_frames_transferred = true;\r\n}\r\nif (all_frames_transferred) {\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\r\n}\r\nbreak;\r\ndefault:\r\nireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum sci_status sci_stp_request_udma_general_frame_handler(struct isci_request *ireq,\r\nu32 frame_index)\r\n{\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nstruct dev_to_host_fis *frame_header;\r\nenum sci_status status;\r\nu32 *frame_buffer;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_header);\r\nif ((status == SCI_SUCCESS) &&\r\n(frame_header->fis_type == FIS_REGD2H)) {\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_buffer);\r\nsci_controller_copy_sata_response(&ireq->stp.rsp,\r\nframe_header,\r\nframe_buffer);\r\n}\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn status;\r\n}\r\nstatic enum sci_status process_unsolicited_fis(struct isci_request *ireq,\r\nu32 frame_index)\r\n{\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nenum sci_status status;\r\nstruct dev_to_host_fis *frame_header;\r\nu32 *frame_buffer;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_header);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nif (frame_header->fis_type != FIS_REGD2H) {\r\ndev_err(&ireq->isci_host->pdev->dev,\r\n"%s ERROR: invalid fis type 0x%X\n",\r\n__func__, frame_header->fis_type);\r\nreturn SCI_FAILURE;\r\n}\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_buffer);\r\nsci_controller_copy_sata_response(&ireq->stp.rsp,\r\n(u32 *)frame_header,\r\nframe_buffer);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn status;\r\n}\r\nstatic enum sci_status atapi_d2h_reg_frame_handler(struct isci_request *ireq,\r\nu32 frame_index)\r\n{\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nenum sci_status status;\r\nstatus = process_unsolicited_fis(ireq, frame_index);\r\nif (status == SCI_SUCCESS) {\r\nif (ireq->stp.rsp.status & ATA_ERR)\r\nstatus = SCI_IO_FAILURE_RESPONSE_VALID;\r\n} else {\r\nstatus = SCI_IO_FAILURE_RESPONSE_VALID;\r\n}\r\nif (status != SCI_SUCCESS) {\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = status;\r\n} else {\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\n}\r\nif (task->data_dir == DMA_NONE)\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nreturn status;\r\n}\r\nstatic void scu_atapi_reconstruct_raw_frame_task_context(struct isci_request *ireq)\r\n{\r\nstruct ata_device *dev = sas_to_ata_dev(ireq->target_device->domain_dev);\r\nvoid *atapi_cdb = ireq->ttype_ptr.io_task_ptr->ata_task.atapi_packet;\r\nstruct scu_task_context *task_context = ireq->tc;\r\nmemset(&ireq->stp.cmd, 0, sizeof(struct host_to_dev_fis));\r\nmemcpy(((u8 *)&ireq->stp.cmd + sizeof(u32)), atapi_cdb, ATAPI_CDB_LEN);\r\nmemset(&(task_context->type.stp), 0, sizeof(struct stp_task_context));\r\ntask_context->type.stp.fis_type = FIS_DATA;\r\ntask_context->transfer_length_bytes = dev->cdb_len;\r\n}\r\nstatic void scu_atapi_construct_task_context(struct isci_request *ireq)\r\n{\r\nstruct ata_device *dev = sas_to_ata_dev(ireq->target_device->domain_dev);\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstruct scu_task_context *task_context = ireq->tc;\r\nint cdb_len = dev->cdb_len;\r\nif (task->data_dir == DMA_TO_DEVICE) {\r\ntask_context->task_type = SCU_TASK_TYPE_PACKET_DMA_OUT;\r\ntask_context->sata_direction = 0;\r\n} else {\r\ntask_context->task_type = SCU_TASK_TYPE_PACKET_DMA_IN;\r\ntask_context->sata_direction = 1;\r\n}\r\nmemset(&task_context->type.stp, 0, sizeof(task_context->type.stp));\r\ntask_context->type.stp.fis_type = FIS_DATA;\r\nmemset(&ireq->stp.cmd, 0, sizeof(ireq->stp.cmd));\r\nmemcpy(&ireq->stp.cmd.lbal, task->ata_task.atapi_packet, cdb_len);\r\ntask_context->ssp_command_iu_length = cdb_len / sizeof(u32);\r\ntask_context->task_phase = 0x1;\r\ntask_context->stp_retry_count = 0;\r\ntask_context->transfer_length_bytes = task->total_xfer_len;\r\nsci_request_build_sgl(ireq);\r\n}\r\nenum sci_status\r\nsci_io_request_frame_handler(struct isci_request *ireq,\r\nu32 frame_index)\r\n{\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nstruct isci_stp_request *stp_req = &ireq->stp.req;\r\nenum sci_base_request_states state;\r\nenum sci_status status;\r\nssize_t word_cnt;\r\nstate = ireq->sm.current_state_id;\r\nswitch (state) {\r\ncase SCI_REQ_STARTED: {\r\nstruct ssp_frame_hdr ssp_hdr;\r\nvoid *frame_header;\r\nsci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n&frame_header);\r\nword_cnt = sizeof(struct ssp_frame_hdr) / sizeof(u32);\r\nsci_swab32_cpy(&ssp_hdr, frame_header, word_cnt);\r\nif (ssp_hdr.frame_type == SSP_RESPONSE) {\r\nstruct ssp_response_iu *resp_iu;\r\nssize_t word_cnt = SSP_RESP_IU_MAX_SIZE / sizeof(u32);\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n(void **)&resp_iu);\r\nsci_swab32_cpy(&ireq->ssp.rsp, resp_iu, word_cnt);\r\nresp_iu = &ireq->ssp.rsp;\r\nif (resp_iu->datapres == 0x01 ||\r\nresp_iu->datapres == 0x02) {\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\n} else {\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\n}\r\n} else {\r\ndev_err(&ihost->pdev->dev,\r\n"%s: SCIC IO Request 0x%p received unexpected "\r\n"frame %d type 0x%02x\n", __func__, ireq,\r\nframe_index, ssp_hdr.frame_type);\r\n}\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn SCI_SUCCESS;\r\n}\r\ncase SCI_REQ_TASK_WAIT_TC_RESP:\r\nsci_io_request_copy_response(ireq);\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn SCI_SUCCESS;\r\ncase SCI_REQ_SMP_WAIT_RESP: {\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstruct scatterlist *sg = &task->smp_task.smp_resp;\r\nvoid *frame_header, *kaddr;\r\nu8 *rsp;\r\nsci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n&frame_header);\r\nkaddr = kmap_atomic(sg_page(sg));\r\nrsp = kaddr + sg->offset;\r\nsci_swab32_cpy(rsp, frame_header, 1);\r\nif (rsp[0] == SMP_RESPONSE) {\r\nvoid *smp_resp;\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n&smp_resp);\r\nword_cnt = (sg->length/4)-1;\r\nif (word_cnt > 0)\r\nword_cnt = min_t(unsigned int, word_cnt,\r\nSCU_UNSOLICITED_FRAME_BUFFER_SIZE/4);\r\nsci_swab32_cpy(rsp + 4, smp_resp, word_cnt);\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, SCI_REQ_SMP_WAIT_TC_COMP);\r\n} else {\r\ndev_err(&ihost->pdev->dev,\r\n"%s: SCIC SMP Request 0x%p received unexpected "\r\n"frame %d type 0x%02x\n",\r\n__func__,\r\nireq,\r\nframe_index,\r\nrsp[0]);\r\nireq->scu_status = SCU_TASK_DONE_SMP_FRM_TYPE_ERR;\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\n}\r\nkunmap_atomic(kaddr);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn SCI_SUCCESS;\r\n}\r\ncase SCI_REQ_STP_UDMA_WAIT_TC_COMP:\r\nreturn sci_stp_request_udma_general_frame_handler(ireq,\r\nframe_index);\r\ncase SCI_REQ_STP_UDMA_WAIT_D2H:\r\nstatus = sci_stp_request_udma_general_frame_handler(ireq, frame_index);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nreturn SCI_SUCCESS;\r\ncase SCI_REQ_STP_NON_DATA_WAIT_D2H: {\r\nstruct dev_to_host_fis *frame_header;\r\nu32 *frame_buffer;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_header);\r\nif (status != SCI_SUCCESS) {\r\ndev_err(&ihost->pdev->dev,\r\n"%s: SCIC IO Request 0x%p could not get frame "\r\n"header for frame index %d, status %x\n",\r\n__func__,\r\nstp_req,\r\nframe_index,\r\nstatus);\r\nreturn status;\r\n}\r\nswitch (frame_header->fis_type) {\r\ncase FIS_REGD2H:\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_buffer);\r\nsci_controller_copy_sata_response(&ireq->stp.rsp,\r\nframe_header,\r\nframe_buffer);\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\nbreak;\r\ndefault:\r\ndev_warn(&ihost->pdev->dev,\r\n"%s: IO Request:0x%p Frame Id:%d protocol "\r\n"violation occurred\n", __func__, stp_req,\r\nframe_index);\r\nireq->scu_status = SCU_TASK_DONE_UNEXP_FIS;\r\nireq->sci_status = SCI_FAILURE_PROTOCOL_VIOLATION;\r\nbreak;\r\n}\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn status;\r\n}\r\ncase SCI_REQ_STP_PIO_WAIT_FRAME: {\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstruct dev_to_host_fis *frame_header;\r\nu32 *frame_buffer;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_header);\r\nif (status != SCI_SUCCESS) {\r\ndev_err(&ihost->pdev->dev,\r\n"%s: SCIC IO Request 0x%p could not get frame "\r\n"header for frame index %d, status %x\n",\r\n__func__, stp_req, frame_index, status);\r\nreturn status;\r\n}\r\nswitch (frame_header->fis_type) {\r\ncase FIS_PIO_SETUP:\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_buffer);\r\nstp_req->pio_len = frame_buffer[3] & 0xffff;\r\nstp_req->status = (frame_buffer[2] >> 24) & 0xff;\r\nsci_controller_copy_sata_response(&ireq->stp.rsp,\r\nframe_header,\r\nframe_buffer);\r\nireq->stp.rsp.status = stp_req->status;\r\nif (task->data_dir == DMA_FROM_DEVICE) {\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_DATA_IN);\r\n} else if (task->data_dir == DMA_TO_DEVICE) {\r\nstatus = sci_stp_request_pio_data_out_transmit_data(ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_DATA_OUT);\r\n}\r\nbreak;\r\ncase FIS_SETDEVBITS:\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\r\nbreak;\r\ncase FIS_REGD2H:\r\nif (frame_header->status & ATA_BUSY) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: SCIC PIO Request 0x%p received "\r\n"D2H Register FIS with BSY status "\r\n"0x%x\n",\r\n__func__,\r\nstp_req,\r\nframe_header->status);\r\nbreak;\r\n}\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_buffer);\r\nsci_controller_copy_sata_response(&ireq->stp.req,\r\nframe_header,\r\nframe_buffer);\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn status;\r\n}\r\ncase SCI_REQ_STP_PIO_DATA_IN: {\r\nstruct dev_to_host_fis *frame_header;\r\nstruct sata_fis_data *frame_buffer;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_header);\r\nif (status != SCI_SUCCESS) {\r\ndev_err(&ihost->pdev->dev,\r\n"%s: SCIC IO Request 0x%p could not get frame "\r\n"header for frame index %d, status %x\n",\r\n__func__,\r\nstp_req,\r\nframe_index,\r\nstatus);\r\nreturn status;\r\n}\r\nif (frame_header->fis_type != FIS_DATA) {\r\ndev_err(&ihost->pdev->dev,\r\n"%s: SCIC PIO Request 0x%p received frame %d "\r\n"with fis type 0x%02x when expecting a data "\r\n"fis.\n",\r\n__func__,\r\nstp_req,\r\nframe_index,\r\nframe_header->fis_type);\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_FAILURE_IO_REQUIRES_SCSI_ABORT;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn status;\r\n}\r\nif (stp_req->sgl.index < 0) {\r\nireq->saved_rx_frame_index = frame_index;\r\nstp_req->pio_len = 0;\r\n} else {\r\nsci_unsolicited_frame_control_get_buffer(&ihost->uf_control,\r\nframe_index,\r\n(void **)&frame_buffer);\r\nstatus = sci_stp_request_pio_data_in_copy_data(stp_req,\r\n(u8 *)frame_buffer);\r\nsci_controller_release_frame(ihost, frame_index);\r\n}\r\nif (status != SCI_SUCCESS || stp_req->pio_len != 0)\r\nreturn status;\r\nif ((stp_req->status & ATA_BUSY) == 0) {\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\n} else {\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);\r\n}\r\nreturn status;\r\n}\r\ncase SCI_REQ_ATAPI_WAIT_PIO_SETUP: {\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nsci_controller_release_frame(ihost, frame_index);\r\nireq->target_device->working_request = ireq;\r\nif (task->data_dir == DMA_NONE) {\r\nsci_change_state(&ireq->sm, SCI_REQ_ATAPI_WAIT_TC_COMP);\r\nscu_atapi_reconstruct_raw_frame_task_context(ireq);\r\n} else {\r\nsci_change_state(&ireq->sm, SCI_REQ_ATAPI_WAIT_D2H);\r\nscu_atapi_construct_task_context(ireq);\r\n}\r\nsci_controller_continue_io(ireq);\r\nreturn SCI_SUCCESS;\r\n}\r\ncase SCI_REQ_ATAPI_WAIT_D2H:\r\nreturn atapi_d2h_reg_frame_handler(ireq, frame_index);\r\ncase SCI_REQ_ABORTING:\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn SCI_SUCCESS;\r\ndefault:\r\ndev_warn(&ihost->pdev->dev,\r\n"%s: SCIC IO Request given unexpected frame %x while "\r\n"in state %d\n",\r\n__func__,\r\nframe_index,\r\nstate);\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\n}\r\nstatic enum sci_status stp_request_udma_await_tc_event(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nenum sci_status status = SCI_SUCCESS;\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_FIS):\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_REG_ERR):\r\nif (ireq->stp.rsp.fis_type == FIS_REGD2H) {\r\nsci_remote_device_suspend(ireq->target_device,\r\nSCI_SW_SUSPEND_NORMAL);\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\n} else {\r\nsci_change_state(&ireq->sm, SCI_REQ_STP_UDMA_WAIT_D2H);\r\n}\r\nbreak;\r\ndefault:\r\nireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum sci_status atapi_raw_completion(struct isci_request *ireq, u32 completion_code,\r\nenum sci_base_request_states next)\r\n{\r\nenum sci_status status = SCI_SUCCESS;\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, next);\r\nbreak;\r\ndefault:\r\nireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);\r\nireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum sci_status atapi_data_tc_completion_handler(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nstruct isci_remote_device *idev = ireq->target_device;\r\nstruct dev_to_host_fis *d2h = &ireq->stp.rsp;\r\nenum sci_status status = SCI_SUCCESS;\r\nswitch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {\r\ncase (SCU_TASK_DONE_GOOD << SCU_COMPLETION_TL_STATUS_SHIFT):\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\ncase (SCU_TASK_DONE_UNEXP_FIS << SCU_COMPLETION_TL_STATUS_SHIFT): {\r\nu16 len = sci_req_tx_bytes(ireq);\r\nif (d2h->fis_type != FIS_REGD2H) {\r\nd2h->fis_type = FIS_REGD2H;\r\nd2h->flags = (1 << 6);\r\nd2h->status = 0x50;\r\nd2h->error = 0;\r\nd2h->lbal = 0;\r\nd2h->byte_count_low = len & 0xff;\r\nd2h->byte_count_high = len >> 8;\r\nd2h->device = 0xa0;\r\nd2h->lbal_exp = 0;\r\nd2h->lbam_exp = 0;\r\nd2h->lbah_exp = 0;\r\nd2h->_r_a = 0;\r\nd2h->sector_count = 0x3;\r\nd2h->sector_count_exp = 0;\r\nd2h->_r_b = 0;\r\nd2h->_r_c = 0;\r\nd2h->_r_d = 0;\r\n}\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS_IO_DONE_EARLY;\r\nstatus = ireq->sci_status;\r\nsci_change_state(&idev->sm, SCI_STP_DEV_ATAPI_ERROR);\r\nbreak;\r\n}\r\ncase (SCU_TASK_DONE_EXCESS_DATA << SCU_COMPLETION_TL_STATUS_SHIFT):\r\nireq->scu_status = SCU_TASK_DONE_GOOD;\r\nireq->sci_status = SCI_SUCCESS;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\nbreak;\r\ndefault:\r\nif (d2h->fis_type == FIS_REGD2H) {\r\nstatus = ireq->sci_status;\r\nsci_change_state(&idev->sm, SCI_STP_DEV_ATAPI_ERROR);\r\n} else {\r\nireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;\r\nireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;\r\nsci_change_state(&ireq->sm, SCI_REQ_ATAPI_WAIT_D2H);\r\n}\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic int sci_request_smp_completion_status_is_tx_suspend(\r\nunsigned int completion_status)\r\n{\r\nswitch (completion_status) {\r\ncase SCU_TASK_OPEN_REJECT_WRONG_DESTINATION:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3:\r\ncase SCU_TASK_OPEN_REJECT_BAD_DESTINATION:\r\ncase SCU_TASK_OPEN_REJECT_ZONE_VIOLATION:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sci_request_smp_completion_status_is_tx_rx_suspend(\r\nunsigned int completion_status)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sci_request_ssp_completion_status_is_tx_suspend(\r\nunsigned int completion_status)\r\n{\r\nswitch (completion_status) {\r\ncase SCU_TASK_DONE_TX_RAW_CMD_ERR:\r\ncase SCU_TASK_DONE_LF_ERR:\r\ncase SCU_TASK_OPEN_REJECT_WRONG_DESTINATION:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3:\r\ncase SCU_TASK_OPEN_REJECT_BAD_DESTINATION:\r\ncase SCU_TASK_OPEN_REJECT_ZONE_VIOLATION:\r\ncase SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY:\r\ncase SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED:\r\ncase SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sci_request_ssp_completion_status_is_tx_rx_suspend(\r\nunsigned int completion_status)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sci_request_stpsata_completion_status_is_tx_suspend(\r\nunsigned int completion_status)\r\n{\r\nswitch (completion_status) {\r\ncase SCU_TASK_DONE_TX_RAW_CMD_ERR:\r\ncase SCU_TASK_DONE_LL_R_ERR:\r\ncase SCU_TASK_DONE_LL_PERR:\r\ncase SCU_TASK_DONE_REG_ERR:\r\ncase SCU_TASK_DONE_SDB_ERR:\r\ncase SCU_TASK_OPEN_REJECT_WRONG_DESTINATION:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2:\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3:\r\ncase SCU_TASK_OPEN_REJECT_BAD_DESTINATION:\r\ncase SCU_TASK_OPEN_REJECT_ZONE_VIOLATION:\r\ncase SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY:\r\ncase SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED:\r\ncase SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sci_request_stpsata_completion_status_is_tx_rx_suspend(\r\nunsigned int completion_status)\r\n{\r\nswitch (completion_status) {\r\ncase SCU_TASK_DONE_LF_ERR:\r\ncase SCU_TASK_DONE_LL_SY_TERM:\r\ncase SCU_TASK_DONE_LL_LF_TERM:\r\ncase SCU_TASK_DONE_BREAK_RCVD:\r\ncase SCU_TASK_DONE_INV_FIS_LEN:\r\ncase SCU_TASK_DONE_UNEXP_FIS:\r\ncase SCU_TASK_DONE_UNEXP_SDBFIS:\r\ncase SCU_TASK_DONE_MAX_PLD_ERR:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sci_request_handle_suspending_completions(\r\nstruct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nint is_tx = 0;\r\nint is_tx_rx = 0;\r\nswitch (ireq->protocol) {\r\ncase SAS_PROTOCOL_SMP:\r\nis_tx = sci_request_smp_completion_status_is_tx_suspend(\r\ncompletion_code);\r\nis_tx_rx = sci_request_smp_completion_status_is_tx_rx_suspend(\r\ncompletion_code);\r\nbreak;\r\ncase SAS_PROTOCOL_SSP:\r\nis_tx = sci_request_ssp_completion_status_is_tx_suspend(\r\ncompletion_code);\r\nis_tx_rx = sci_request_ssp_completion_status_is_tx_rx_suspend(\r\ncompletion_code);\r\nbreak;\r\ncase SAS_PROTOCOL_STP:\r\nis_tx = sci_request_stpsata_completion_status_is_tx_suspend(\r\ncompletion_code);\r\nis_tx_rx =\r\nsci_request_stpsata_completion_status_is_tx_rx_suspend(\r\ncompletion_code);\r\nbreak;\r\ndefault:\r\ndev_warn(&ireq->isci_host->pdev->dev,\r\n"%s: request %p has no valid protocol\n",\r\n__func__, ireq);\r\nbreak;\r\n}\r\nif (is_tx || is_tx_rx) {\r\nBUG_ON(is_tx && is_tx_rx);\r\nsci_remote_node_context_suspend(\r\n&ireq->target_device->rnc,\r\nSCI_HW_SUSPEND,\r\n(is_tx_rx) ? SCU_EVENT_TL_RNC_SUSPEND_TX_RX\r\n: SCU_EVENT_TL_RNC_SUSPEND_TX);\r\n}\r\n}\r\nenum sci_status\r\nsci_io_request_tc_completion(struct isci_request *ireq,\r\nu32 completion_code)\r\n{\r\nenum sci_base_request_states state;\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nstate = ireq->sm.current_state_id;\r\nsci_request_handle_suspending_completions(\r\nireq, SCU_GET_COMPLETION_TL_STATUS(completion_code));\r\nswitch (state) {\r\ncase SCI_REQ_STARTED:\r\nreturn request_started_state_tc_event(ireq, completion_code);\r\ncase SCI_REQ_TASK_WAIT_TC_COMP:\r\nreturn ssp_task_request_await_tc_event(ireq,\r\ncompletion_code);\r\ncase SCI_REQ_SMP_WAIT_RESP:\r\nreturn smp_request_await_response_tc_event(ireq,\r\ncompletion_code);\r\ncase SCI_REQ_SMP_WAIT_TC_COMP:\r\nreturn smp_request_await_tc_event(ireq, completion_code);\r\ncase SCI_REQ_STP_UDMA_WAIT_TC_COMP:\r\nreturn stp_request_udma_await_tc_event(ireq,\r\ncompletion_code);\r\ncase SCI_REQ_STP_NON_DATA_WAIT_H2D:\r\nreturn stp_request_non_data_await_h2d_tc_event(ireq,\r\ncompletion_code);\r\ncase SCI_REQ_STP_PIO_WAIT_H2D:\r\nreturn stp_request_pio_await_h2d_completion_tc_event(ireq,\r\ncompletion_code);\r\ncase SCI_REQ_STP_PIO_DATA_OUT:\r\nreturn pio_data_out_tx_done_tc_event(ireq, completion_code);\r\ncase SCI_REQ_ABORTING:\r\nreturn request_aborting_state_tc_event(ireq,\r\ncompletion_code);\r\ncase SCI_REQ_ATAPI_WAIT_H2D:\r\nreturn atapi_raw_completion(ireq, completion_code,\r\nSCI_REQ_ATAPI_WAIT_PIO_SETUP);\r\ncase SCI_REQ_ATAPI_WAIT_TC_COMP:\r\nreturn atapi_raw_completion(ireq, completion_code,\r\nSCI_REQ_ATAPI_WAIT_D2H);\r\ncase SCI_REQ_ATAPI_WAIT_D2H:\r\nreturn atapi_data_tc_completion_handler(ireq, completion_code);\r\ndefault:\r\ndev_warn(&ihost->pdev->dev, "%s: %x in wrong state %s\n",\r\n__func__, completion_code, req_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\n}\r\nstatic void isci_request_process_response_iu(\r\nstruct sas_task *task,\r\nstruct ssp_response_iu *resp_iu,\r\nstruct device *dev)\r\n{\r\ndev_dbg(dev,\r\n"%s: resp_iu = %p "\r\n"resp_iu->status = 0x%x,\nresp_iu->datapres = %d "\r\n"resp_iu->response_data_len = %x, "\r\n"resp_iu->sense_data_len = %x\nrepsonse data: ",\r\n__func__,\r\nresp_iu,\r\nresp_iu->status,\r\nresp_iu->datapres,\r\nresp_iu->response_data_len,\r\nresp_iu->sense_data_len);\r\ntask->task_status.stat = resp_iu->status;\r\nsas_ssp_task_response(dev, task, resp_iu);\r\n}\r\nstatic void isci_request_set_open_reject_status(\r\nstruct isci_request *request,\r\nstruct sas_task *task,\r\nenum service_response *response_ptr,\r\nenum exec_status *status_ptr,\r\nenum sas_open_rej_reason open_rej_reason)\r\n{\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\n*response_ptr = SAS_TASK_UNDELIVERED;\r\n*status_ptr = SAS_OPEN_REJECT;\r\ntask->task_status.open_rej_reason = open_rej_reason;\r\n}\r\nstatic void isci_request_handle_controller_specific_errors(\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *request,\r\nstruct sas_task *task,\r\nenum service_response *response_ptr,\r\nenum exec_status *status_ptr)\r\n{\r\nunsigned int cstatus;\r\ncstatus = request->scu_status;\r\ndev_dbg(&request->isci_host->pdev->dev,\r\n"%s: %p SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR "\r\n"- controller status = 0x%x\n",\r\n__func__, request, cstatus);\r\nswitch (cstatus) {\r\ncase SCU_TASK_DONE_DMASETUP_DIRERR:\r\ncase SCU_TASK_DONE_XFERCNT_ERR:\r\nif (task->task_proto == SAS_PROTOCOL_SMP) {\r\n*response_ptr = SAS_TASK_COMPLETE;\r\nif (!idev)\r\n*status_ptr = SAS_DEVICE_UNKNOWN;\r\nelse\r\n*status_ptr = SAS_ABORTED_TASK;\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\n} else {\r\n*response_ptr = SAS_TASK_UNDELIVERED;\r\nif (!idev)\r\n*status_ptr = SAS_DEVICE_UNKNOWN;\r\nelse\r\n*status_ptr = SAM_STAT_TASK_ABORTED;\r\nclear_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\n}\r\nbreak;\r\ncase SCU_TASK_DONE_CRC_ERR:\r\ncase SCU_TASK_DONE_NAK_CMD_ERR:\r\ncase SCU_TASK_DONE_EXCESS_DATA:\r\ncase SCU_TASK_DONE_UNEXP_FIS:\r\ncase SCU_TASK_DONE_VIIT_ENTRY_NV:\r\ncase SCU_TASK_DONE_IIT_ENTRY_NV:\r\ncase SCU_TASK_DONE_RNCNV_OUTBOUND:\r\n*response_ptr = SAS_TASK_COMPLETE;\r\nif (!idev)\r\n*status_ptr = SAS_DEVICE_UNKNOWN;\r\nelse\r\n*status_ptr = SAS_ABORTED_TASK;\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_WRONG_DESTINATION:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_WRONG_DEST);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_ZONE_VIOLATION:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_RESV_AB0);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_RESV_AB1);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_RESV_AB2);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_RESV_AB3);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_BAD_DESTINATION:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_BAD_DEST);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_STP_NORES);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_EPROTO);\r\nbreak;\r\ncase SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED:\r\nisci_request_set_open_reject_status(\r\nrequest, task, response_ptr, status_ptr,\r\nSAS_OREJ_CONN_RATE);\r\nbreak;\r\ncase SCU_TASK_DONE_LL_R_ERR:\r\ncase SCU_TASK_DONE_LL_PERR:\r\ncase SCU_TASK_DONE_LL_SY_TERM:\r\ncase SCU_TASK_DONE_LL_LF_TERM:\r\ncase SCU_TASK_DONE_LL_ABORT_ERR:\r\ncase SCU_TASK_DONE_SEQ_INV_TYPE:\r\ncase SCU_TASK_DONE_XR_IU_LEN_ERR:\r\ncase SCU_TASK_DONE_INV_FIS_LEN:\r\ncase SCU_TASK_DONE_SDMA_ERR:\r\ncase SCU_TASK_DONE_OFFSET_ERR:\r\ncase SCU_TASK_DONE_MAX_PLD_ERR:\r\ncase SCU_TASK_DONE_LF_ERR:\r\ncase SCU_TASK_DONE_SMP_RESP_TO_ERR:\r\ncase SCU_TASK_DONE_SMP_LL_RX_ERR:\r\ncase SCU_TASK_DONE_UNEXP_DATA:\r\ncase SCU_TASK_DONE_UNEXP_SDBFIS:\r\ncase SCU_TASK_DONE_REG_ERR:\r\ncase SCU_TASK_DONE_SDB_ERR:\r\ncase SCU_TASK_DONE_TASK_ABORT:\r\ndefault:\r\n*response_ptr = SAS_TASK_UNDELIVERED;\r\n*status_ptr = SAM_STAT_TASK_ABORTED;\r\nif (task->task_proto == SAS_PROTOCOL_SMP)\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nelse\r\nclear_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nbreak;\r\n}\r\n}\r\nstatic void isci_process_stp_response(struct sas_task *task, struct dev_to_host_fis *fis)\r\n{\r\nstruct task_status_struct *ts = &task->task_status;\r\nstruct ata_task_resp *resp = (void *)&ts->buf[0];\r\nresp->frame_len = sizeof(*fis);\r\nmemcpy(resp->ending_fis, fis, sizeof(*fis));\r\nts->buf_valid_size = sizeof(*resp);\r\nif (fis->status & ATA_DF)\r\nts->stat = SAS_PROTO_RESPONSE;\r\nelse if (fis->status & ATA_ERR)\r\nts->stat = SAM_STAT_CHECK_CONDITION;\r\nelse\r\nts->stat = SAM_STAT_GOOD;\r\nts->resp = SAS_TASK_COMPLETE;\r\n}\r\nstatic void isci_request_io_request_complete(struct isci_host *ihost,\r\nstruct isci_request *request,\r\nenum sci_io_status completion_status)\r\n{\r\nstruct sas_task *task = isci_request_access_task(request);\r\nstruct ssp_response_iu *resp_iu;\r\nunsigned long task_flags;\r\nstruct isci_remote_device *idev = request->target_device;\r\nenum service_response response = SAS_TASK_UNDELIVERED;\r\nenum exec_status status = SAS_ABORTED_TASK;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: request = %p, task = %p, "\r\n"task->data_dir = %d completion_status = 0x%x\n",\r\n__func__, request, task, task->data_dir, completion_status);\r\nswitch (completion_status) {\r\ncase SCI_IO_FAILURE_RESPONSE_VALID:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: SCI_IO_FAILURE_RESPONSE_VALID (%p/%p)\n",\r\n__func__, request, task);\r\nif (sas_protocol_ata(task->task_proto)) {\r\nisci_process_stp_response(task, &request->stp.rsp);\r\n} else if (SAS_PROTOCOL_SSP == task->task_proto) {\r\nresp_iu = &request->ssp.rsp;\r\nisci_request_process_response_iu(task, resp_iu,\r\n&ihost->pdev->dev);\r\n} else if (SAS_PROTOCOL_SMP == task->task_proto) {\r\ndev_err(&ihost->pdev->dev,\r\n"%s: SCI_IO_FAILURE_RESPONSE_VALID: "\r\n"SAS_PROTOCOL_SMP protocol\n",\r\n__func__);\r\n} else\r\ndev_err(&ihost->pdev->dev,\r\n"%s: unknown protocol\n", __func__);\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nresponse = task->task_status.resp;\r\nstatus = task->task_status.stat;\r\nbreak;\r\ncase SCI_IO_SUCCESS:\r\ncase SCI_IO_SUCCESS_IO_DONE_EARLY:\r\nresponse = SAS_TASK_COMPLETE;\r\nstatus = SAM_STAT_GOOD;\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nif (completion_status == SCI_IO_SUCCESS_IO_DONE_EARLY) {\r\nu32 transferred_length = sci_req_tx_bytes(request);\r\ntask->task_status.residual\r\n= task->total_xfer_len - transferred_length;\r\nif (task->task_status.residual != 0)\r\nstatus = SAS_DATA_UNDERRUN;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: SCI_IO_SUCCESS_IO_DONE_EARLY %d\n",\r\n__func__, status);\r\n} else\r\ndev_dbg(&ihost->pdev->dev, "%s: SCI_IO_SUCCESS\n",\r\n__func__);\r\nbreak;\r\ncase SCI_IO_FAILURE_TERMINATED:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: SCI_IO_FAILURE_TERMINATED (%p/%p)\n",\r\n__func__, request, task);\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nresponse = SAS_TASK_UNDELIVERED;\r\nif (!idev)\r\nstatus = SAS_DEVICE_UNKNOWN;\r\nelse\r\nstatus = SAS_ABORTED_TASK;\r\nbreak;\r\ncase SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR:\r\nisci_request_handle_controller_specific_errors(idev, request,\r\ntask, &response,\r\n&status);\r\nbreak;\r\ncase SCI_IO_FAILURE_REMOTE_DEVICE_RESET_REQUIRED:\r\nspin_lock_irqsave(&task->task_state_lock, task_flags);\r\ntask->task_state_flags |= SAS_TASK_NEED_DEV_RESET;\r\nspin_unlock_irqrestore(&task->task_state_lock, task_flags);\r\nresponse = SAS_TASK_UNDELIVERED;\r\nstatus = SAM_STAT_TASK_ABORTED;\r\nclear_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nbreak;\r\ncase SCI_FAILURE_RETRY_REQUIRED:\r\nresponse = SAS_TASK_UNDELIVERED;\r\nif (!idev)\r\nstatus = SAS_DEVICE_UNKNOWN;\r\nelse\r\nstatus = SAS_ABORTED_TASK;\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nbreak;\r\ndefault:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: invalid completion code: 0x%x - "\r\n"isci_request = %p\n",\r\n__func__, completion_status, request);\r\nresponse = SAS_TASK_UNDELIVERED;\r\nif (!idev)\r\nstatus = SAS_DEVICE_UNKNOWN;\r\nelse\r\nstatus = SAS_ABORTED_TASK;\r\nif (SAS_PROTOCOL_SMP == task->task_proto)\r\nset_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nelse\r\nclear_bit(IREQ_COMPLETE_IN_TARGET, &request->flags);\r\nbreak;\r\n}\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SSP:\r\nif (task->data_dir == DMA_NONE)\r\nbreak;\r\nif (task->num_scatter == 0)\r\ndma_unmap_single(&ihost->pdev->dev,\r\nrequest->zero_scatter_daddr,\r\ntask->total_xfer_len, task->data_dir);\r\nelse\r\ndma_unmap_sg(&ihost->pdev->dev, task->scatter,\r\nrequest->num_sg_entries, task->data_dir);\r\nbreak;\r\ncase SAS_PROTOCOL_SMP: {\r\nstruct scatterlist *sg = &task->smp_task.smp_req;\r\nstruct smp_req *smp_req;\r\nvoid *kaddr;\r\ndma_unmap_sg(&ihost->pdev->dev, sg, 1, DMA_TO_DEVICE);\r\nkaddr = kmap_atomic(sg_page(sg));\r\nsmp_req = kaddr + sg->offset;\r\nsci_swab32_cpy(smp_req, smp_req, sg->length / sizeof(u32));\r\nkunmap_atomic(kaddr);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&task->task_state_lock, task_flags);\r\ntask->task_status.resp = response;\r\ntask->task_status.stat = status;\r\nif (test_bit(IREQ_COMPLETE_IN_TARGET, &request->flags)) {\r\ntask->task_state_flags |= SAS_TASK_STATE_DONE;\r\ntask->task_state_flags &= ~(SAS_TASK_AT_INITIATOR |\r\nSAS_TASK_STATE_PENDING);\r\n}\r\nspin_unlock_irqrestore(&task->task_state_lock, task_flags);\r\nsci_controller_complete_io(ihost, request->target_device, request);\r\nset_bit(IREQ_TERMINATED, &request->flags);\r\nireq_done(ihost, request, task);\r\n}\r\nstatic void sci_request_started_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\r\nstruct domain_device *dev = ireq->target_device->domain_dev;\r\nenum sci_base_request_states state;\r\nstruct sas_task *task;\r\ntask = (test_bit(IREQ_TMF, &ireq->flags)) ? NULL : isci_request_access_task(ireq);\r\nif (!task && dev->dev_type == SAS_END_DEV) {\r\nstate = SCI_REQ_TASK_WAIT_TC_COMP;\r\n} else if (task && task->task_proto == SAS_PROTOCOL_SMP) {\r\nstate = SCI_REQ_SMP_WAIT_RESP;\r\n} else if (task && sas_protocol_ata(task->task_proto) &&\r\n!task->ata_task.use_ncq) {\r\nif (dev->sata_dev.command_set == ATAPI_COMMAND_SET &&\r\ntask->ata_task.fis.command == ATA_CMD_PACKET) {\r\nstate = SCI_REQ_ATAPI_WAIT_H2D;\r\n} else if (task->data_dir == DMA_NONE) {\r\nstate = SCI_REQ_STP_NON_DATA_WAIT_H2D;\r\n} else if (task->ata_task.dma_xfer) {\r\nstate = SCI_REQ_STP_UDMA_WAIT_TC_COMP;\r\n} else {\r\nstate = SCI_REQ_STP_PIO_WAIT_H2D;\r\n}\r\n} else {\r\nreturn;\r\n}\r\nsci_change_state(sm, state);\r\n}\r\nstatic void sci_request_completed_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\r\nstruct isci_host *ihost = ireq->owning_controller;\r\nif (!test_bit(IREQ_TMF, &ireq->flags))\r\nisci_request_io_request_complete(ihost, ireq,\r\nireq->sci_status);\r\nelse\r\nisci_task_request_complete(ihost, ireq, ireq->sci_status);\r\n}\r\nstatic void sci_request_aborting_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\r\nireq->tc->abort = 1;\r\n}\r\nstatic void sci_stp_request_started_non_data_await_h2d_completion_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\r\nireq->target_device->working_request = ireq;\r\n}\r\nstatic void sci_stp_request_started_pio_await_h2d_completion_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_request *ireq = container_of(sm, typeof(*ireq), sm);\r\nireq->target_device->working_request = ireq;\r\n}\r\nstatic void\r\nsci_general_request_construct(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nsci_init_sm(&ireq->sm, sci_request_state_table, SCI_REQ_INIT);\r\nireq->target_device = idev;\r\nireq->protocol = SAS_PROTOCOL_NONE;\r\nireq->saved_rx_frame_index = SCU_INVALID_FRAME_INDEX;\r\nireq->sci_status = SCI_SUCCESS;\r\nireq->scu_status = 0;\r\nireq->post_context = 0xFFFFFFFF;\r\n}\r\nstatic enum sci_status\r\nsci_io_request_construct(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nstruct domain_device *dev = idev->domain_dev;\r\nenum sci_status status = SCI_SUCCESS;\r\nsci_general_request_construct(ihost, idev, ireq);\r\nif (idev->rnc.remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)\r\nreturn SCI_FAILURE_INVALID_REMOTE_DEVICE;\r\nif (dev->dev_type == SAS_END_DEV)\r\n;\r\nelse if (dev_is_sata(dev))\r\nmemset(&ireq->stp.cmd, 0, sizeof(ireq->stp.cmd));\r\nelse if (dev_is_expander(dev))\r\n;\r\nelse\r\nreturn SCI_FAILURE_UNSUPPORTED_PROTOCOL;\r\nmemset(ireq->tc, 0, offsetof(struct scu_task_context, sgl_pair_ab));\r\nreturn status;\r\n}\r\nenum sci_status sci_task_request_construct(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nu16 io_tag, struct isci_request *ireq)\r\n{\r\nstruct domain_device *dev = idev->domain_dev;\r\nenum sci_status status = SCI_SUCCESS;\r\nsci_general_request_construct(ihost, idev, ireq);\r\nif (dev->dev_type == SAS_END_DEV || dev_is_sata(dev)) {\r\nset_bit(IREQ_TMF, &ireq->flags);\r\nmemset(ireq->tc, 0, sizeof(struct scu_task_context));\r\nif (dev_is_sata(dev))\r\nireq->protocol = SAS_PROTOCOL_STP;\r\nelse\r\nireq->protocol = SAS_PROTOCOL_SSP;\r\n} else\r\nstatus = SCI_FAILURE_UNSUPPORTED_PROTOCOL;\r\nreturn status;\r\n}\r\nstatic enum sci_status isci_request_ssp_request_construct(\r\nstruct isci_request *request)\r\n{\r\nenum sci_status status;\r\ndev_dbg(&request->isci_host->pdev->dev,\r\n"%s: request = %p\n",\r\n__func__,\r\nrequest);\r\nstatus = sci_io_request_construct_basic_ssp(request);\r\nreturn status;\r\n}\r\nstatic enum sci_status isci_request_stp_request_construct(struct isci_request *ireq)\r\n{\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstruct host_to_dev_fis *fis = &ireq->stp.cmd;\r\nstruct ata_queued_cmd *qc = task->uldd_task;\r\nenum sci_status status;\r\ndev_dbg(&ireq->isci_host->pdev->dev,\r\n"%s: ireq = %p\n",\r\n__func__,\r\nireq);\r\nmemcpy(fis, &task->ata_task.fis, sizeof(struct host_to_dev_fis));\r\nif (!task->ata_task.device_control_reg_update)\r\nfis->flags |= 0x80;\r\nfis->flags &= 0xF0;\r\nstatus = sci_io_request_construct_basic_sata(ireq);\r\nif (qc && (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\r\nqc->tf.command == ATA_CMD_FPDMA_READ)) {\r\nfis->sector_count = qc->tag << 3;\r\nireq->tc->type.stp.ncq_tag = qc->tag;\r\n}\r\nreturn status;\r\n}\r\nstatic enum sci_status\r\nsci_io_request_construct_smp(struct device *dev,\r\nstruct isci_request *ireq,\r\nstruct sas_task *task)\r\n{\r\nstruct scatterlist *sg = &task->smp_task.smp_req;\r\nstruct isci_remote_device *idev;\r\nstruct scu_task_context *task_context;\r\nstruct isci_port *iport;\r\nstruct smp_req *smp_req;\r\nvoid *kaddr;\r\nu8 req_len;\r\nu32 cmd;\r\nkaddr = kmap_atomic(sg_page(sg));\r\nsmp_req = kaddr + sg->offset;\r\nif (smp_req->req_len == 0) {\r\nswitch (smp_req->func) {\r\ncase SMP_DISCOVER:\r\ncase SMP_REPORT_PHY_ERR_LOG:\r\ncase SMP_REPORT_PHY_SATA:\r\ncase SMP_REPORT_ROUTE_INFO:\r\nsmp_req->req_len = 2;\r\nbreak;\r\ncase SMP_CONF_ROUTE_INFO:\r\ncase SMP_PHY_CONTROL:\r\ncase SMP_PHY_TEST_FUNCTION:\r\nsmp_req->req_len = 9;\r\nbreak;\r\n}\r\n}\r\nreq_len = smp_req->req_len;\r\nsci_swab32_cpy(smp_req, smp_req, sg->length / sizeof(u32));\r\ncmd = *(u32 *) smp_req;\r\nkunmap_atomic(kaddr);\r\nif (!dma_map_sg(dev, sg, 1, DMA_TO_DEVICE))\r\nreturn SCI_FAILURE;\r\nireq->protocol = SAS_PROTOCOL_SMP;\r\ntask_context = ireq->tc;\r\nidev = ireq->target_device;\r\niport = idev->owning_port;\r\ntask_context->priority = 0;\r\ntask_context->initiator_request = 1;\r\ntask_context->connection_rate = idev->connection_rate;\r\ntask_context->protocol_engine_index = ISCI_PEG;\r\ntask_context->logical_port_index = iport->physical_port_index;\r\ntask_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SMP;\r\ntask_context->abort = 0;\r\ntask_context->valid = SCU_TASK_CONTEXT_VALID;\r\ntask_context->context_type = SCU_TASK_CONTEXT_TYPE;\r\ntask_context->remote_node_index = idev->rnc.remote_node_index;\r\ntask_context->command_code = 0;\r\ntask_context->task_type = SCU_TASK_TYPE_SMP_REQUEST;\r\ntask_context->link_layer_control = 0;\r\ntask_context->do_not_dma_ssp_good_response = 1;\r\ntask_context->strict_ordering = 0;\r\ntask_context->control_frame = 1;\r\ntask_context->timeout_enable = 0;\r\ntask_context->block_guard_enable = 0;\r\ntask_context->address_modifier = 0;\r\ntask_context->ssp_command_iu_length = req_len;\r\ntask_context->transfer_length_bytes = 0;\r\nmemcpy(&task_context->type.smp, &cmd, sizeof(u32));\r\ntask_context->task_phase = 0;\r\nireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |\r\n(ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\r\n(iport->physical_port_index <<\r\nSCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\r\nISCI_TAG_TCI(ireq->io_tag));\r\ntask_context->command_iu_upper = upper_32_bits(sg_dma_address(sg));\r\ntask_context->command_iu_lower = lower_32_bits(sg_dma_address(sg) + sizeof(u32));\r\ntask_context->response_iu_upper = 0;\r\ntask_context->response_iu_lower = 0;\r\nsci_change_state(&ireq->sm, SCI_REQ_CONSTRUCTED);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status isci_smp_request_build(struct isci_request *ireq)\r\n{\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstruct device *dev = &ireq->isci_host->pdev->dev;\r\nenum sci_status status = SCI_FAILURE;\r\nstatus = sci_io_request_construct_smp(dev, ireq, task);\r\nif (status != SCI_SUCCESS)\r\ndev_dbg(&ireq->isci_host->pdev->dev,\r\n"%s: failed with status = %d\n",\r\n__func__,\r\nstatus);\r\nreturn status;\r\n}\r\nstatic enum sci_status isci_io_request_build(struct isci_host *ihost,\r\nstruct isci_request *request,\r\nstruct isci_remote_device *idev)\r\n{\r\nenum sci_status status = SCI_SUCCESS;\r\nstruct sas_task *task = isci_request_access_task(request);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev = 0x%p; request = %p, "\r\n"num_scatter = %d\n",\r\n__func__,\r\nidev,\r\nrequest,\r\ntask->num_scatter);\r\nif (task->num_scatter &&\r\n!sas_protocol_ata(task->task_proto) &&\r\n!(SAS_PROTOCOL_SMP & task->task_proto)) {\r\nrequest->num_sg_entries = dma_map_sg(\r\n&ihost->pdev->dev,\r\ntask->scatter,\r\ntask->num_scatter,\r\ntask->data_dir\r\n);\r\nif (request->num_sg_entries == 0)\r\nreturn SCI_FAILURE_INSUFFICIENT_RESOURCES;\r\n}\r\nstatus = sci_io_request_construct(ihost, idev, request);\r\nif (status != SCI_SUCCESS) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: failed request construct\n",\r\n__func__);\r\nreturn SCI_FAILURE;\r\n}\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SMP:\r\nstatus = isci_smp_request_build(request);\r\nbreak;\r\ncase SAS_PROTOCOL_SSP:\r\nstatus = isci_request_ssp_request_construct(request);\r\nbreak;\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\ncase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\r\nstatus = isci_request_stp_request_construct(request);\r\nbreak;\r\ndefault:\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: unknown protocol\n", __func__);\r\nreturn SCI_FAILURE;\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic struct isci_request *isci_request_from_tag(struct isci_host *ihost, u16 tag)\r\n{\r\nstruct isci_request *ireq;\r\nireq = ihost->reqs[ISCI_TAG_TCI(tag)];\r\nireq->io_tag = tag;\r\nireq->io_request_completion = NULL;\r\nireq->flags = 0;\r\nireq->num_sg_entries = 0;\r\nreturn ireq;\r\n}\r\nstatic struct isci_request *isci_io_request_from_tag(struct isci_host *ihost,\r\nstruct sas_task *task,\r\nu16 tag)\r\n{\r\nstruct isci_request *ireq;\r\nireq = isci_request_from_tag(ihost, tag);\r\nireq->ttype_ptr.io_task_ptr = task;\r\nclear_bit(IREQ_TMF, &ireq->flags);\r\ntask->lldd_task = ireq;\r\nreturn ireq;\r\n}\r\nstruct isci_request *isci_tmf_request_from_tag(struct isci_host *ihost,\r\nstruct isci_tmf *isci_tmf,\r\nu16 tag)\r\n{\r\nstruct isci_request *ireq;\r\nireq = isci_request_from_tag(ihost, tag);\r\nireq->ttype_ptr.tmf_task_ptr = isci_tmf;\r\nset_bit(IREQ_TMF, &ireq->flags);\r\nreturn ireq;\r\n}\r\nint isci_request_execute(struct isci_host *ihost, struct isci_remote_device *idev,\r\nstruct sas_task *task, u16 tag)\r\n{\r\nenum sci_status status = SCI_FAILURE_UNSUPPORTED_PROTOCOL;\r\nstruct isci_request *ireq;\r\nunsigned long flags;\r\nint ret = 0;\r\nireq = isci_io_request_from_tag(ihost, task, tag);\r\nstatus = isci_io_request_build(ihost, ireq, idev);\r\nif (status != SCI_SUCCESS) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: request_construct failed - status = 0x%x\n",\r\n__func__,\r\nstatus);\r\nreturn status;\r\n}\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nif (test_bit(IDEV_IO_NCQERROR, &idev->flags)) {\r\nif (isci_task_is_ncq_recovery(task)) {\r\nstatus = sci_controller_start_task(ihost,\r\nidev,\r\nireq);\r\n} else {\r\nstatus = SCI_FAILURE;\r\n}\r\n} else {\r\nstatus = sci_controller_start_io(ihost, idev,\r\nireq);\r\n}\r\nif (status != SCI_SUCCESS &&\r\nstatus != SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: failed request start (0x%x)\n",\r\n__func__, status);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nreturn status;\r\n}\r\nif (status != SCI_SUCCESS) {\r\nset_bit(IREQ_TERMINATED, &ireq->flags);\r\n}\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (status ==\r\nSCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\ntask->task_state_flags |= SAS_TASK_NEED_DEV_RESET;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nsas_task_abort(task);\r\nstatus = SCI_SUCCESS;\r\n}\r\nreturn ret;\r\n}
