static void set_col_gpio_val(struct omap_kp *omap_kp, u8 value)\r\n{\r\nint col;\r\nfor (col = 0; col < omap_kp->cols; col++)\r\ngpio_set_value(col_gpios[col], value & (1 << col));\r\n}\r\nstatic u8 get_row_gpio_val(struct omap_kp *omap_kp)\r\n{\r\nint row;\r\nu8 value = 0;\r\nfor (row = 0; row < omap_kp->rows; row++) {\r\nif (gpio_get_value(row_gpios[row]))\r\nvalue |= (1 << row);\r\n}\r\nreturn value;\r\n}\r\nstatic irqreturn_t omap_kp_interrupt(int irq, void *dev_id)\r\n{\r\nstruct omap_kp *omap_kp = dev_id;\r\nif (cpu_is_omap24xx()) {\r\nint i;\r\nfor (i = 0; i < omap_kp->rows; i++) {\r\nint gpio_irq = gpio_to_irq(row_gpios[i]);\r\nif (gpio_irq == irq)\r\ndisable_irq_nosync(gpio_irq);\r\nelse\r\ndisable_irq(gpio_irq);\r\n}\r\n} else\r\nomap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\r\ntasklet_schedule(&kp_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void omap_kp_timer(unsigned long data)\r\n{\r\ntasklet_schedule(&kp_tasklet);\r\n}\r\nstatic void omap_kp_scan_keypad(struct omap_kp *omap_kp, unsigned char *state)\r\n{\r\nint col = 0;\r\nif (cpu_is_omap24xx()) {\r\nfor (col = 0; col < omap_kp->cols; col++) {\r\nset_col_gpio_val(omap_kp, ~(1 << col));\r\nstate[col] = ~(get_row_gpio_val(omap_kp)) & 0xff;\r\n}\r\nset_col_gpio_val(omap_kp, 0);\r\n} else {\r\nomap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\r\nomap_writew(0xff, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);\r\nfor (col = 0; col < omap_kp->cols; col++) {\r\nomap_writew(~(1 << col) & 0xff,\r\nOMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);\r\nudelay(omap_kp->delay);\r\nstate[col] = ~omap_readw(OMAP1_MPUIO_BASE +\r\nOMAP_MPUIO_KBR_LATCH) & 0xff;\r\n}\r\nomap_writew(0x00, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBC);\r\nudelay(2);\r\n}\r\n}\r\nstatic void omap_kp_tasklet(unsigned long data)\r\n{\r\nstruct omap_kp *omap_kp_data = (struct omap_kp *) data;\r\nunsigned short *keycodes = omap_kp_data->input->keycode;\r\nunsigned int row_shift = get_count_order(omap_kp_data->cols);\r\nunsigned char new_state[8], changed, key_down = 0;\r\nint col, row;\r\nint spurious = 0;\r\nomap_kp_scan_keypad(omap_kp_data, new_state);\r\nfor (col = 0; col < omap_kp_data->cols; col++) {\r\nchanged = new_state[col] ^ keypad_state[col];\r\nkey_down |= new_state[col];\r\nif (changed == 0)\r\ncontinue;\r\nfor (row = 0; row < omap_kp_data->rows; row++) {\r\nint key;\r\nif (!(changed & (1 << row)))\r\ncontinue;\r\n#ifdef NEW_BOARD_LEARNING_MODE\r\nprintk(KERN_INFO "omap-keypad: key %d-%d %s\n", col,\r\nrow, (new_state[col] & (1 << row)) ?\r\n"pressed" : "released");\r\n#else\r\nkey = keycodes[MATRIX_SCAN_CODE(row, col, row_shift)];\r\nif (key < 0) {\r\nprintk(KERN_WARNING\r\n"omap-keypad: Spurious key event %d-%d\n",\r\ncol, row);\r\nspurious = 1;\r\ncontinue;\r\n}\r\nif (!(kp_cur_group == (key & GROUP_MASK) ||\r\nkp_cur_group == -1))\r\ncontinue;\r\nkp_cur_group = key & GROUP_MASK;\r\ninput_report_key(omap_kp_data->input, key & ~GROUP_MASK,\r\nnew_state[col] & (1 << row));\r\n#endif\r\n}\r\n}\r\ninput_sync(omap_kp_data->input);\r\nmemcpy(keypad_state, new_state, sizeof(keypad_state));\r\nif (key_down) {\r\nint delay = HZ / 20;\r\nif (spurious)\r\ndelay = 2 * HZ;\r\nmod_timer(&omap_kp_data->timer, jiffies + delay);\r\n} else {\r\nif (cpu_is_omap24xx()) {\r\nint i;\r\nfor (i = 0; i < omap_kp_data->rows; i++)\r\nenable_irq(gpio_to_irq(row_gpios[i]));\r\n} else {\r\nomap_writew(0, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\r\nkp_cur_group = -1;\r\n}\r\n}\r\n}\r\nstatic ssize_t omap_kp_enable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", kp_enable);\r\n}\r\nstatic ssize_t omap_kp_enable_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint state;\r\nif (sscanf(buf, "%u", &state) != 1)\r\nreturn -EINVAL;\r\nif ((state != 1) && (state != 0))\r\nreturn -EINVAL;\r\nmutex_lock(&kp_enable_mutex);\r\nif (state != kp_enable) {\r\nif (state)\r\nenable_irq(INT_KEYBOARD);\r\nelse\r\ndisable_irq(INT_KEYBOARD);\r\nkp_enable = state;\r\n}\r\nmutex_unlock(&kp_enable_mutex);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic int omap_kp_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int omap_kp_resume(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __devinit omap_kp_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_kp *omap_kp;\r\nstruct input_dev *input_dev;\r\nstruct omap_kp_platform_data *pdata = pdev->dev.platform_data;\r\nint i, col_idx, row_idx, irq_idx, ret;\r\nunsigned int row_shift, keycodemax;\r\nif (!pdata->rows || !pdata->cols || !pdata->keymap_data) {\r\nprintk(KERN_ERR "No rows, cols or keymap_data from pdata\n");\r\nreturn -EINVAL;\r\n}\r\nrow_shift = get_count_order(pdata->cols);\r\nkeycodemax = pdata->rows << row_shift;\r\nomap_kp = kzalloc(sizeof(struct omap_kp) +\r\nkeycodemax * sizeof(unsigned short), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!omap_kp || !input_dev) {\r\nkfree(omap_kp);\r\ninput_free_device(input_dev);\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, omap_kp);\r\nomap_kp->input = input_dev;\r\nif (!cpu_is_omap24xx())\r\nomap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\r\nif (pdata->delay)\r\nomap_kp->delay = pdata->delay;\r\nif (pdata->row_gpios && pdata->col_gpios) {\r\nrow_gpios = pdata->row_gpios;\r\ncol_gpios = pdata->col_gpios;\r\n}\r\nomap_kp->rows = pdata->rows;\r\nomap_kp->cols = pdata->cols;\r\nif (cpu_is_omap24xx()) {\r\nfor (col_idx = 0; col_idx < omap_kp->cols; col_idx++) {\r\nif (gpio_request(col_gpios[col_idx], "omap_kp_col") < 0) {\r\nprintk(KERN_ERR "Failed to request"\r\n"GPIO%d for keypad\n",\r\ncol_gpios[col_idx]);\r\ngoto err1;\r\n}\r\ngpio_direction_output(col_gpios[col_idx], 0);\r\n}\r\nfor (row_idx = 0; row_idx < omap_kp->rows; row_idx++) {\r\nif (gpio_request(row_gpios[row_idx], "omap_kp_row") < 0) {\r\nprintk(KERN_ERR "Failed to request"\r\n"GPIO%d for keypad\n",\r\nrow_gpios[row_idx]);\r\ngoto err2;\r\n}\r\ngpio_direction_input(row_gpios[row_idx]);\r\n}\r\n} else {\r\ncol_idx = 0;\r\nrow_idx = 0;\r\n}\r\nsetup_timer(&omap_kp->timer, omap_kp_timer, (unsigned long)omap_kp);\r\ntasklet_enable(&kp_tasklet);\r\nkp_tasklet.data = (unsigned long) omap_kp;\r\nret = device_create_file(&pdev->dev, &dev_attr_enable);\r\nif (ret < 0)\r\ngoto err2;\r\ninput_dev->name = "omap-keypad";\r\ninput_dev->phys = "omap-keypad/input0";\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\nif (pdata->rep)\r\n__set_bit(EV_REP, input_dev->evbit);\r\nret = matrix_keypad_build_keymap(pdata->keymap_data, NULL,\r\npdata->rows, pdata->cols,\r\nomap_kp->keymap, input_dev);\r\nif (ret < 0)\r\ngoto err3;\r\nret = input_register_device(omap_kp->input);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Unable to register omap-keypad input device\n");\r\ngoto err3;\r\n}\r\nif (pdata->dbounce)\r\nomap_writew(0xff, OMAP1_MPUIO_BASE + OMAP_MPUIO_GPIO_DEBOUNCING);\r\nomap_kp_scan_keypad(omap_kp, keypad_state);\r\nif (!cpu_is_omap24xx()) {\r\nomap_kp->irq = platform_get_irq(pdev, 0);\r\nif (omap_kp->irq >= 0) {\r\nif (request_irq(omap_kp->irq, omap_kp_interrupt, 0,\r\n"omap-keypad", omap_kp) < 0)\r\ngoto err4;\r\n}\r\nomap_writew(0, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\r\n} else {\r\nfor (irq_idx = 0; irq_idx < omap_kp->rows; irq_idx++) {\r\nif (request_irq(gpio_to_irq(row_gpios[irq_idx]),\r\nomap_kp_interrupt,\r\nIRQF_TRIGGER_FALLING,\r\n"omap-keypad", omap_kp) < 0)\r\ngoto err5;\r\n}\r\n}\r\nreturn 0;\r\nerr5:\r\nfor (i = irq_idx - 1; i >=0; i--)\r\nfree_irq(row_gpios[i], omap_kp);\r\nerr4:\r\ninput_unregister_device(omap_kp->input);\r\ninput_dev = NULL;\r\nerr3:\r\ndevice_remove_file(&pdev->dev, &dev_attr_enable);\r\nerr2:\r\nfor (i = row_idx - 1; i >=0; i--)\r\ngpio_free(row_gpios[i]);\r\nerr1:\r\nfor (i = col_idx - 1; i >=0; i--)\r\ngpio_free(col_gpios[i]);\r\nkfree(omap_kp);\r\ninput_free_device(input_dev);\r\nreturn -EINVAL;\r\n}\r\nstatic int __devexit omap_kp_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_kp *omap_kp = platform_get_drvdata(pdev);\r\ntasklet_disable(&kp_tasklet);\r\nif (cpu_is_omap24xx()) {\r\nint i;\r\nfor (i = 0; i < omap_kp->cols; i++)\r\ngpio_free(col_gpios[i]);\r\nfor (i = 0; i < omap_kp->rows; i++) {\r\ngpio_free(row_gpios[i]);\r\nfree_irq(gpio_to_irq(row_gpios[i]), omap_kp);\r\n}\r\n} else {\r\nomap_writew(1, OMAP1_MPUIO_BASE + OMAP_MPUIO_KBD_MASKIT);\r\nfree_irq(omap_kp->irq, omap_kp);\r\n}\r\ndel_timer_sync(&omap_kp->timer);\r\ntasklet_kill(&kp_tasklet);\r\ninput_unregister_device(omap_kp->input);\r\nkfree(omap_kp);\r\nreturn 0;\r\n}
