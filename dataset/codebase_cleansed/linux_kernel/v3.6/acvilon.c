static void bfin_plat_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, this->IO_ADDR_W + (1 << BFIN_NAND_PLAT_CLE));\r\nelse\r\nwriteb(cmd, this->IO_ADDR_W + (1 << BFIN_NAND_PLAT_ALE));\r\n}\r\nstatic int bfin_plat_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nreturn gpio_get_value(BFIN_NAND_PLAT_READY);\r\n}\r\nstatic void bfin_plat_nand_init(void)\r\n{\r\ngpio_request(BFIN_NAND_PLAT_READY, "bfin_nand_plat");\r\n}\r\nstatic void bfin_plat_nand_init(void)\r\n{\r\n}\r\nstatic int __init acvilon_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "%s(): registering device resources\n", __func__);\r\nbfin_plat_nand_init();\r\nret =\r\nplatform_add_devices(acvilon_devices, ARRAY_SIZE(acvilon_devices));\r\nif (ret < 0)\r\nreturn ret;\r\ni2c_register_board_info(0, acvilon_i2c_devs,\r\nARRAY_SIZE(acvilon_i2c_devs));\r\nbfin_write_FIO0_FLAG_C(1 << 14);\r\nmsleep(5);\r\nbfin_write_FIO0_FLAG_S(1 << 14);\r\nspi_register_board_info(bfin_spi_board_info,\r\nARRAY_SIZE(bfin_spi_board_info));\r\nreturn 0;\r\n}\r\nvoid __init native_machine_early_platform_add_devices(void)\r\n{\r\nprintk(KERN_INFO "register early platform devices\n");\r\nearly_platform_add_devices(acvilon_early_devices,\r\nARRAY_SIZE(acvilon_early_devices));\r\n}
