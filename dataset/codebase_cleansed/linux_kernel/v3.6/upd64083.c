static inline struct upd64083_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct upd64083_state, sd);\r\n}\r\nstatic void upd64083_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 buf[2];\r\nbuf[0] = reg;\r\nbuf[1] = val;\r\nv4l2_dbg(1, debug, sd, "write reg: %02x val: %02x\n", reg, val);\r\nif (i2c_master_send(client, buf, 2) != 2)\r\nv4l2_err(sd, "I/O error write 0x%02x/0x%02x\n", reg, val);\r\n}\r\nstatic u8 upd64083_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 buf[7];\r\nif (reg >= sizeof(buf))\r\nreturn 0xff;\r\ni2c_master_recv(client, buf, sizeof(buf));\r\nreturn buf[reg];\r\n}\r\nstatic int upd64083_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct upd64083_state *state = to_state(sd);\r\nu8 r00, r02;\r\nif (input > 7 || (input & 6) == 6)\r\nreturn -EINVAL;\r\nstate->mode = (input & 3) << 6;\r\nstate->ext_y_adc = (input & UPD64083_EXT_Y_ADC) << 3;\r\nr00 = (state->regs[R00] & ~(3 << 6)) | state->mode;\r\nr02 = (state->regs[R02] & ~(1 << 5)) | state->ext_y_adc;\r\nupd64083_write(sd, R00, r00);\r\nupd64083_write(sd, R02, r02);\r\nreturn 0;\r\n}\r\nstatic int upd64083_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->val = upd64083_read(sd, reg->reg & 0xff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int upd64083_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nupd64083_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int upd64083_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_UPD64083, 0);\r\n}\r\nstatic int upd64083_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 buf[7];\r\ni2c_master_recv(client, buf, 7);\r\nv4l2_info(sd, "Status: SA00=%02x SA01=%02x SA02=%02x SA03=%02x "\r\n"SA04=%02x SA05=%02x SA06=%02x\n",\r\nbuf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);\r\nreturn 0;\r\n}\r\nstatic int upd64083_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct upd64083_state *state;\r\nstruct v4l2_subdev *sd;\r\nint i;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nstate = kzalloc(sizeof(struct upd64083_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &upd64083_ops);\r\nstate->mode = 0;\r\nstate->ext_y_adc = (1 << 5);\r\nmemcpy(state->regs, upd64083_init, TOT_REGS);\r\nfor (i = 0; i < TOT_REGS; i++)\r\nupd64083_write(sd, i, state->regs[i]);\r\nreturn 0;\r\n}\r\nstatic int upd64083_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}
