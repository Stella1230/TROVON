static void barf(const char *msg)\r\n{\r\nfprintf(stderr, "%s (error: %s)\n", msg, strerror(errno));\r\nexit(1);\r\n}\r\nstatic void fdpair(int fds[2])\r\n{\r\nif (use_pipes) {\r\nif (pipe(fds) == 0)\r\nreturn;\r\n} else {\r\nif (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) == 0)\r\nreturn;\r\n}\r\nbarf(use_pipes ? "pipe()" : "socketpair()");\r\n}\r\nstatic void ready(int ready_out, int wakefd)\r\n{\r\nchar dummy;\r\nstruct pollfd pollfd = { .fd = wakefd, .events = POLLIN };\r\nif (write(ready_out, &dummy, 1) != 1)\r\nbarf("CLIENT: ready write");\r\nif (poll(&pollfd, 1, -1) != 1)\r\nbarf("poll");\r\n}\r\nstatic void *sender(struct sender_context *ctx)\r\n{\r\nchar data[DATASIZE];\r\nunsigned int i, j;\r\nready(ctx->ready_out, ctx->wakefd);\r\nfor (i = 0; i < loops; i++) {\r\nfor (j = 0; j < ctx->num_fds; j++) {\r\nint ret, done = 0;\r\nagain:\r\nret = write(ctx->out_fds[j], data + done,\r\nsizeof(data)-done);\r\nif (ret < 0)\r\nbarf("SENDER: write");\r\ndone += ret;\r\nif (done < DATASIZE)\r\ngoto again;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *receiver(struct receiver_context* ctx)\r\n{\r\nunsigned int i;\r\nif (!thread_mode)\r\nclose(ctx->in_fds[1]);\r\nready(ctx->ready_out, ctx->wakefd);\r\nfor (i = 0; i < ctx->num_packets; i++) {\r\nchar data[DATASIZE];\r\nint ret, done = 0;\r\nagain:\r\nret = read(ctx->in_fds[0], data + done, DATASIZE - done);\r\nif (ret < 0)\r\nbarf("SERVER: read");\r\ndone += ret;\r\nif (done < DATASIZE)\r\ngoto again;\r\n}\r\nreturn NULL;\r\n}\r\nstatic pthread_t create_worker(void *ctx, void *(*func)(void *))\r\n{\r\npthread_attr_t attr;\r\npthread_t childid;\r\nint err;\r\nif (!thread_mode) {\r\nswitch (fork()) {\r\ncase -1:\r\nbarf("fork()");\r\nbreak;\r\ncase 0:\r\n(*func) (ctx);\r\nexit(0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn (pthread_t)0;\r\n}\r\nif (pthread_attr_init(&attr) != 0)\r\nbarf("pthread_attr_init:");\r\n#ifndef __ia64__\r\nif (pthread_attr_setstacksize(&attr, PTHREAD_STACK_MIN) != 0)\r\nbarf("pthread_attr_setstacksize");\r\n#endif\r\nerr = pthread_create(&childid, &attr, func, ctx);\r\nif (err != 0) {\r\nfprintf(stderr, "pthread_create failed: %s (%d)\n",\r\nstrerror(err), err);\r\nexit(-1);\r\n}\r\nreturn childid;\r\n}\r\nstatic void reap_worker(pthread_t id)\r\n{\r\nint proc_status;\r\nvoid *thread_status;\r\nif (!thread_mode) {\r\nwait(&proc_status);\r\nif (!WIFEXITED(proc_status))\r\nexit(1);\r\n} else {\r\npthread_join(id, &thread_status);\r\n}\r\n}\r\nstatic unsigned int group(pthread_t *pth,\r\nunsigned int num_fds,\r\nint ready_out,\r\nint wakefd)\r\n{\r\nunsigned int i;\r\nstruct sender_context *snd_ctx = malloc(sizeof(struct sender_context)\r\n+ num_fds * sizeof(int));\r\nif (!snd_ctx)\r\nbarf("malloc()");\r\nfor (i = 0; i < num_fds; i++) {\r\nint fds[2];\r\nstruct receiver_context *ctx = malloc(sizeof(*ctx));\r\nif (!ctx)\r\nbarf("malloc()");\r\nfdpair(fds);\r\nctx->num_packets = num_fds * loops;\r\nctx->in_fds[0] = fds[0];\r\nctx->in_fds[1] = fds[1];\r\nctx->ready_out = ready_out;\r\nctx->wakefd = wakefd;\r\npth[i] = create_worker(ctx, (void *)receiver);\r\nsnd_ctx->out_fds[i] = fds[1];\r\nif (!thread_mode)\r\nclose(fds[0]);\r\n}\r\nfor (i = 0; i < num_fds; i++) {\r\nsnd_ctx->ready_out = ready_out;\r\nsnd_ctx->wakefd = wakefd;\r\nsnd_ctx->num_fds = num_fds;\r\npth[num_fds+i] = create_worker(snd_ctx, (void *)sender);\r\n}\r\nif (!thread_mode)\r\nfor (i = 0; i < num_fds; i++)\r\nclose(snd_ctx->out_fds[i]);\r\nreturn num_fds * 2;\r\n}\r\nint bench_sched_messaging(int argc, const char **argv,\r\nconst char *prefix __used)\r\n{\r\nunsigned int i, total_children;\r\nstruct timeval start, stop, diff;\r\nunsigned int num_fds = 20;\r\nint readyfds[2], wakefds[2];\r\nchar dummy;\r\npthread_t *pth_tab;\r\nargc = parse_options(argc, argv, options,\r\nbench_sched_message_usage, 0);\r\npth_tab = malloc(num_fds * 2 * num_groups * sizeof(pthread_t));\r\nif (!pth_tab)\r\nbarf("main:malloc()");\r\nfdpair(readyfds);\r\nfdpair(wakefds);\r\ntotal_children = 0;\r\nfor (i = 0; i < num_groups; i++)\r\ntotal_children += group(pth_tab+total_children, num_fds,\r\nreadyfds[1], wakefds[0]);\r\nfor (i = 0; i < total_children; i++)\r\nif (read(readyfds[0], &dummy, 1) != 1)\r\nbarf("Reading for readyfds");\r\ngettimeofday(&start, NULL);\r\nif (write(wakefds[1], &dummy, 1) != 1)\r\nbarf("Writing to start them");\r\nfor (i = 0; i < total_children; i++)\r\nreap_worker(pth_tab[i]);\r\ngettimeofday(&stop, NULL);\r\ntimersub(&stop, &start, &diff);\r\nswitch (bench_format) {\r\ncase BENCH_FORMAT_DEFAULT:\r\nprintf("# %d sender and receiver %s per group\n",\r\nnum_fds, thread_mode ? "threads" : "processes");\r\nprintf("# %d groups == %d %s run\n\n",\r\nnum_groups, num_groups * 2 * num_fds,\r\nthread_mode ? "threads" : "processes");\r\nprintf(" %14s: %lu.%03lu [sec]\n", "Total time",\r\ndiff.tv_sec,\r\n(unsigned long) (diff.tv_usec/1000));\r\nbreak;\r\ncase BENCH_FORMAT_SIMPLE:\r\nprintf("%lu.%03lu\n", diff.tv_sec,\r\n(unsigned long) (diff.tv_usec/1000));\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "Unknown format:%d\n", bench_format);\r\nexit(1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}
