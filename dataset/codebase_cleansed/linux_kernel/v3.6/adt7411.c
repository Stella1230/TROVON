static int adt7411_read_10_bit(struct i2c_client *client, u8 lsb_reg,\r\nu8 msb_reg, u8 lsb_shift)\r\n{\r\nstruct adt7411_data *data = i2c_get_clientdata(client);\r\nint val, tmp;\r\nmutex_lock(&data->device_lock);\r\nval = i2c_smbus_read_byte_data(client, lsb_reg);\r\nif (val < 0)\r\ngoto exit_unlock;\r\ntmp = (val >> lsb_shift) & 3;\r\nval = i2c_smbus_read_byte_data(client, msb_reg);\r\nif (val >= 0)\r\nval = (val << 2) | tmp;\r\nexit_unlock:\r\nmutex_unlock(&data->device_lock);\r\nreturn val;\r\n}\r\nstatic int adt7411_modify_bit(struct i2c_client *client, u8 reg, u8 bit,\r\nbool flag)\r\n{\r\nstruct adt7411_data *data = i2c_get_clientdata(client);\r\nint ret, val;\r\nmutex_lock(&data->device_lock);\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\ngoto exit_unlock;\r\nif (flag)\r\nval = ret | bit;\r\nelse\r\nval = ret & ~bit;\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nexit_unlock:\r\nmutex_unlock(&data->device_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t adt7411_show_vdd(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint ret = adt7411_read_10_bit(client, ADT7411_REG_INT_TEMP_VDD_LSB,\r\nADT7411_REG_VDD_MSB, 2);\r\nreturn ret < 0 ? ret : sprintf(buf, "%u\n", ret * 7000 / 1024);\r\n}\r\nstatic ssize_t adt7411_show_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint val = adt7411_read_10_bit(client, ADT7411_REG_INT_TEMP_VDD_LSB,\r\nADT7411_REG_INT_TEMP_MSB, 0);\r\nif (val < 0)\r\nreturn val;\r\nval = val & 0x200 ? val - 0x400 : val;\r\nreturn sprintf(buf, "%d\n", val * 250);\r\n}\r\nstatic ssize_t adt7411_show_input(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7411_data *data = i2c_get_clientdata(client);\r\nint val;\r\nu8 lsb_reg, lsb_shift;\r\nmutex_lock(&data->update_lock);\r\nif (time_after_eq(jiffies, data->next_update)) {\r\nval = i2c_smbus_read_byte_data(client, ADT7411_REG_CFG3);\r\nif (val < 0)\r\ngoto exit_unlock;\r\nif (val & ADT7411_CFG3_REF_VDD) {\r\nval = adt7411_read_10_bit(client,\r\nADT7411_REG_INT_TEMP_VDD_LSB,\r\nADT7411_REG_VDD_MSB, 2);\r\nif (val < 0)\r\ngoto exit_unlock;\r\ndata->vref_cached = val * 7000 / 1024;\r\n} else {\r\ndata->vref_cached = 2250;\r\n}\r\ndata->next_update = jiffies + HZ;\r\n}\r\nlsb_reg = ADT7411_REG_EXT_TEMP_AIN14_LSB + (nr >> 2);\r\nlsb_shift = 2 * (nr & 0x03);\r\nval = adt7411_read_10_bit(client, lsb_reg,\r\nADT7411_REG_EXT_TEMP_AIN1_MSB + nr, lsb_shift);\r\nif (val < 0)\r\ngoto exit_unlock;\r\nval = sprintf(buf, "%u\n", val * data->vref_cached / 1024);\r\nexit_unlock:\r\nmutex_unlock(&data->update_lock);\r\nreturn val;\r\n}\r\nstatic ssize_t adt7411_show_bit(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint ret = i2c_smbus_read_byte_data(client, attr2->index);\r\nreturn ret < 0 ? ret : sprintf(buf, "%u\n", !!(ret & attr2->nr));\r\n}\r\nstatic ssize_t adt7411_set_bit(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute_2 *s_attr2 = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7411_data *data = i2c_get_clientdata(client);\r\nint ret;\r\nunsigned long flag;\r\nret = kstrtoul(buf, 0, &flag);\r\nif (ret || flag > 1)\r\nreturn -EINVAL;\r\nret = adt7411_modify_bit(client, s_attr2->index, s_attr2->nr, flag);\r\nmutex_lock(&data->update_lock);\r\ndata->next_update = jiffies;\r\nmutex_unlock(&data->update_lock);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic int adt7411_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nint val;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nval = i2c_smbus_read_byte_data(client, ADT7411_REG_MANUFACTURER_ID);\r\nif (val < 0 || val != ADT7411_MANUFACTURER_ID) {\r\ndev_dbg(&client->dev, "Wrong manufacturer ID. Got %d, "\r\n"expected %d\n", val, ADT7411_MANUFACTURER_ID);\r\nreturn -ENODEV;\r\n}\r\nval = i2c_smbus_read_byte_data(client, ADT7411_REG_DEVICE_ID);\r\nif (val < 0 || val != ADT7411_DEVICE_ID) {\r\ndev_dbg(&client->dev, "Wrong device ID. Got %d, "\r\n"expected %d\n", val, ADT7411_DEVICE_ID);\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, "adt7411", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int __devinit adt7411_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adt7411_data *data;\r\nint ret;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->device_lock);\r\nmutex_init(&data->update_lock);\r\nret = adt7411_modify_bit(client, ADT7411_REG_CFG1,\r\nADT7411_CFG1_START_MONITOR, 1);\r\nif (ret < 0)\r\ngoto exit_free;\r\ndata->next_update = jiffies;\r\nret = sysfs_create_group(&client->dev.kobj, &adt7411_attr_grp);\r\nif (ret)\r\ngoto exit_free;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\ndev_info(&client->dev, "successfully registered\n");\r\nreturn 0;\r\nexit_remove:\r\nsysfs_remove_group(&client->dev.kobj, &adt7411_attr_grp);\r\nexit_free:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int __devexit adt7411_remove(struct i2c_client *client)\r\n{\r\nstruct adt7411_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &adt7411_attr_grp);\r\nkfree(data);\r\nreturn 0;\r\n}
