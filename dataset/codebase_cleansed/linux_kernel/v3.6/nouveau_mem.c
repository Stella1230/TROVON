static void\r\nnv10_mem_update_tile_region(struct drm_device *dev,\r\nstruct nouveau_tile_reg *tile, uint32_t addr,\r\nuint32_t size, uint32_t pitch, uint32_t flags)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fb_engine *pfb = &dev_priv->engine.fb;\r\nint i = tile - dev_priv->tile.reg, j;\r\nunsigned long save;\r\nnouveau_fence_unref(&tile->fence);\r\nif (tile->pitch)\r\npfb->free_tile_region(dev, i);\r\nif (pitch)\r\npfb->init_tile_region(dev, i, addr, size, pitch, flags);\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, save);\r\nnv_wr32(dev, NV03_PFIFO_CACHES, 0);\r\nnv04_fifo_cache_pull(dev, false);\r\nnouveau_wait_for_idle(dev);\r\npfb->set_tile_region(dev, i);\r\nfor (j = 0; j < NVOBJ_ENGINE_NR; j++) {\r\nif (dev_priv->eng[j] && dev_priv->eng[j]->set_tile_region)\r\ndev_priv->eng[j]->set_tile_region(dev, i);\r\n}\r\nnv04_fifo_cache_pull(dev, true);\r\nnv_wr32(dev, NV03_PFIFO_CACHES, 1);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, save);\r\n}\r\nstatic struct nouveau_tile_reg *\r\nnv10_mem_get_tile_region(struct drm_device *dev, int i)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_tile_reg *tile = &dev_priv->tile.reg[i];\r\nspin_lock(&dev_priv->tile.lock);\r\nif (!tile->used &&\r\n(!tile->fence || nouveau_fence_done(tile->fence)))\r\ntile->used = true;\r\nelse\r\ntile = NULL;\r\nspin_unlock(&dev_priv->tile.lock);\r\nreturn tile;\r\n}\r\nvoid\r\nnv10_mem_put_tile_region(struct drm_device *dev, struct nouveau_tile_reg *tile,\r\nstruct nouveau_fence *fence)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (tile) {\r\nspin_lock(&dev_priv->tile.lock);\r\nif (fence) {\r\ntile->fence = fence;\r\nnouveau_fence_ref(fence);\r\n}\r\ntile->used = false;\r\nspin_unlock(&dev_priv->tile.lock);\r\n}\r\n}\r\nstruct nouveau_tile_reg *\r\nnv10_mem_set_tiling(struct drm_device *dev, uint32_t addr, uint32_t size,\r\nuint32_t pitch, uint32_t flags)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fb_engine *pfb = &dev_priv->engine.fb;\r\nstruct nouveau_tile_reg *tile, *found = NULL;\r\nint i;\r\nfor (i = 0; i < pfb->num_tiles; i++) {\r\ntile = nv10_mem_get_tile_region(dev, i);\r\nif (pitch && !found) {\r\nfound = tile;\r\ncontinue;\r\n} else if (tile && tile->pitch) {\r\nnv10_mem_update_tile_region(dev, tile, 0, 0, 0, 0);\r\n}\r\nnv10_mem_put_tile_region(dev, tile, NULL);\r\n}\r\nif (found)\r\nnv10_mem_update_tile_region(dev, found, addr, size,\r\npitch, flags);\r\nreturn found;\r\n}\r\nvoid\r\nnouveau_mem_vram_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nttm_bo_device_release(&dev_priv->ttm.bdev);\r\nnouveau_ttm_global_release(dev_priv);\r\nif (dev_priv->fb_mtrr >= 0) {\r\ndrm_mtrr_del(dev_priv->fb_mtrr,\r\npci_resource_start(dev->pdev, 1),\r\npci_resource_len(dev->pdev, 1), DRM_MTRR_WC);\r\ndev_priv->fb_mtrr = -1;\r\n}\r\n}\r\nvoid\r\nnouveau_mem_gart_fini(struct drm_device *dev)\r\n{\r\nnouveau_sgdma_takedown(dev);\r\nif (drm_core_has_AGP(dev) && dev->agp) {\r\nstruct drm_agp_mem *entry, *tempe;\r\nlist_for_each_entry_safe(entry, tempe, &dev->agp->memory, head) {\r\nif (entry->bound)\r\ndrm_unbind_agp(entry->memory);\r\ndrm_free_agp(entry->memory, entry->pages);\r\nkfree(entry);\r\n}\r\nINIT_LIST_HEAD(&dev->agp->memory);\r\nif (dev->agp->acquired)\r\ndrm_agp_release(dev);\r\ndev->agp->acquired = 0;\r\ndev->agp->enabled = 0;\r\n}\r\n}\r\nbool\r\nnouveau_mem_flags_valid(struct drm_device *dev, u32 tile_flags)\r\n{\r\nif (!(tile_flags & NOUVEAU_GEM_TILE_LAYOUT_MASK))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic unsigned long\r\nget_agp_mode(struct drm_device *dev, unsigned long mode)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->chipset == 0x18)\r\nmode &= ~PCI_AGP_COMMAND_FW;\r\nif (nouveau_agpmode > 0) {\r\nbool agpv3 = mode & 0x8;\r\nint rate = agpv3 ? nouveau_agpmode / 4 : nouveau_agpmode;\r\nmode = (mode & ~0x7) | (rate & 0x7);\r\n}\r\nreturn mode;\r\n}\r\nint\r\nnouveau_mem_reset_agp(struct drm_device *dev)\r\n{\r\n#if __OS_HAS_AGP\r\nuint32_t saved_pci_nv_1, pmc_enable;\r\nint ret;\r\nif ((nv_rd32(dev, NV04_PBUS_PCI_NV_19) |\r\ndev->agp->mode) & PCI_AGP_COMMAND_FW) {\r\nstruct drm_agp_info info;\r\nstruct drm_agp_mode mode;\r\nret = drm_agp_info(dev, &info);\r\nif (ret)\r\nreturn ret;\r\nmode.mode = get_agp_mode(dev, info.mode) & ~PCI_AGP_COMMAND_FW;\r\nret = drm_agp_enable(dev, mode);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsaved_pci_nv_1 = nv_rd32(dev, NV04_PBUS_PCI_NV_1);\r\nnv_wr32(dev, NV04_PBUS_PCI_NV_1, saved_pci_nv_1 & ~0x4);\r\nnv_wr32(dev, NV04_PBUS_PCI_NV_19, 0);\r\npmc_enable = nv_rd32(dev, NV03_PMC_ENABLE);\r\nif (pmc_enable & NV_PMC_ENABLE_PGRAPH) {\r\nnv_wr32(dev, NV03_PMC_ENABLE,\r\npmc_enable & ~NV_PMC_ENABLE_PGRAPH);\r\nnv_wr32(dev, NV03_PMC_ENABLE, nv_rd32(dev, NV03_PMC_ENABLE) |\r\nNV_PMC_ENABLE_PGRAPH);\r\n}\r\nnv_wr32(dev, NV04_PBUS_PCI_NV_1, saved_pci_nv_1);\r\n#endif\r\nreturn 0;\r\n}\r\nint\r\nnouveau_mem_init_agp(struct drm_device *dev)\r\n{\r\n#if __OS_HAS_AGP\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct drm_agp_info info;\r\nstruct drm_agp_mode mode;\r\nint ret;\r\nif (!dev->agp->acquired) {\r\nret = drm_agp_acquire(dev);\r\nif (ret) {\r\nNV_ERROR(dev, "Unable to acquire AGP: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nnouveau_mem_reset_agp(dev);\r\nret = drm_agp_info(dev, &info);\r\nif (ret) {\r\nNV_ERROR(dev, "Unable to get AGP info: %d\n", ret);\r\nreturn ret;\r\n}\r\nmode.mode = get_agp_mode(dev, info.mode);\r\nret = drm_agp_enable(dev, mode);\r\nif (ret) {\r\nNV_ERROR(dev, "Unable to enable AGP: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_priv->gart_info.type = NOUVEAU_GART_AGP;\r\ndev_priv->gart_info.aper_base = info.aperture_base;\r\ndev_priv->gart_info.aper_size = info.aperture_size;\r\n#endif\r\nreturn 0;\r\n}\r\nint\r\nnouveau_mem_vram_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct ttm_bo_device *bdev = &dev_priv->ttm.bdev;\r\nconst struct vram_types *vram_type;\r\nint ret, dma_bits;\r\ndma_bits = 32;\r\nif (dev_priv->card_type >= NV_50) {\r\nif (pci_dma_supported(dev->pdev, DMA_BIT_MASK(40)))\r\ndma_bits = 40;\r\n} else\r\nif (0 && pci_is_pcie(dev->pdev) &&\r\ndev_priv->chipset > 0x40 &&\r\ndev_priv->chipset != 0x45) {\r\nif (pci_dma_supported(dev->pdev, DMA_BIT_MASK(39)))\r\ndma_bits = 39;\r\n}\r\nret = pci_set_dma_mask(dev->pdev, DMA_BIT_MASK(dma_bits));\r\nif (ret)\r\nreturn ret;\r\nret = pci_set_consistent_dma_mask(dev->pdev, DMA_BIT_MASK(dma_bits));\r\nif (ret) {\r\npci_set_consistent_dma_mask(dev->pdev, DMA_BIT_MASK(32));\r\n}\r\nret = nouveau_ttm_global_init(dev_priv);\r\nif (ret)\r\nreturn ret;\r\nret = ttm_bo_device_init(&dev_priv->ttm.bdev,\r\ndev_priv->ttm.bo_global_ref.ref.object,\r\n&nouveau_bo_driver, DRM_FILE_PAGE_OFFSET,\r\ndma_bits <= 32 ? true : false);\r\nif (ret) {\r\nNV_ERROR(dev, "Error initialising bo driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nvram_type = vram_type_map;\r\nwhile (vram_type->value != NV_MEM_TYPE_UNKNOWN) {\r\nif (nouveau_vram_type) {\r\nif (!strcasecmp(nouveau_vram_type, vram_type->name))\r\nbreak;\r\ndev_priv->vram_type = vram_type->value;\r\n} else {\r\nif (vram_type->value == dev_priv->vram_type)\r\nbreak;\r\n}\r\nvram_type++;\r\n}\r\nNV_INFO(dev, "Detected %dMiB VRAM (%s)\n",\r\n(int)(dev_priv->vram_size >> 20), vram_type->name);\r\nif (dev_priv->vram_sys_base) {\r\nNV_INFO(dev, "Stolen system memory at: 0x%010llx\n",\r\ndev_priv->vram_sys_base);\r\n}\r\ndev_priv->fb_available_size = dev_priv->vram_size;\r\ndev_priv->fb_mappable_pages = dev_priv->fb_available_size;\r\nif (dev_priv->fb_mappable_pages > pci_resource_len(dev->pdev, 1))\r\ndev_priv->fb_mappable_pages = pci_resource_len(dev->pdev, 1);\r\ndev_priv->fb_mappable_pages >>= PAGE_SHIFT;\r\ndev_priv->fb_available_size -= dev_priv->ramin_rsvd_vram;\r\ndev_priv->fb_aper_free = dev_priv->fb_available_size;\r\nret = ttm_bo_init_mm(bdev, TTM_PL_VRAM,\r\ndev_priv->fb_available_size >> PAGE_SHIFT);\r\nif (ret) {\r\nNV_ERROR(dev, "Failed VRAM mm init: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (dev_priv->card_type < NV_50) {\r\nret = nouveau_bo_new(dev, 256*1024, 0, TTM_PL_FLAG_VRAM,\r\n0, 0, NULL, &dev_priv->vga_ram);\r\nif (ret == 0)\r\nret = nouveau_bo_pin(dev_priv->vga_ram,\r\nTTM_PL_FLAG_VRAM);\r\nif (ret) {\r\nNV_WARN(dev, "failed to reserve VGA memory\n");\r\nnouveau_bo_ref(NULL, &dev_priv->vga_ram);\r\n}\r\n}\r\ndev_priv->fb_mtrr = drm_mtrr_add(pci_resource_start(dev->pdev, 1),\r\npci_resource_len(dev->pdev, 1),\r\nDRM_MTRR_WC);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_mem_gart_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct ttm_bo_device *bdev = &dev_priv->ttm.bdev;\r\nint ret;\r\ndev_priv->gart_info.type = NOUVEAU_GART_NONE;\r\n#if !defined(__powerpc__) && !defined(__ia64__)\r\nif (drm_pci_device_is_agp(dev) && dev->agp && nouveau_agpmode) {\r\nret = nouveau_mem_init_agp(dev);\r\nif (ret)\r\nNV_ERROR(dev, "Error initialising AGP: %d\n", ret);\r\n}\r\n#endif\r\nif (dev_priv->gart_info.type == NOUVEAU_GART_NONE) {\r\nret = nouveau_sgdma_init(dev);\r\nif (ret) {\r\nNV_ERROR(dev, "Error initialising PCI(E): %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nNV_INFO(dev, "%d MiB GART (aperture)\n",\r\n(int)(dev_priv->gart_info.aper_size >> 20));\r\ndev_priv->gart_info.aper_free = dev_priv->gart_info.aper_size;\r\nret = ttm_bo_init_mm(bdev, TTM_PL_TT,\r\ndev_priv->gart_info.aper_size >> PAGE_SHIFT);\r\nif (ret) {\r\nNV_ERROR(dev, "Failed TT mm init: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv40_mem_timing_calc(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nt->reg[0] = (e->tRP << 24 | e->tRAS << 16 | e->tRFC << 8 | e->tRC);\r\nt->reg[1] = (e->tWR + 2 + (t->tCWL - 1)) << 24 |\r\n1 << 16 |\r\n(e->tWTR + 2 + (t->tCWL - 1)) << 8 |\r\n(e->tCL + 2 - (t->tCWL - 1));\r\nt->reg[2] = 0x20200000 |\r\n((t->tCWL - 1) << 24 |\r\ne->tRRD << 16 |\r\ne->tRCDWR << 8 |\r\ne->tRCDRD);\r\nNV_DEBUG(dev, "Entry %d: 220: %08x %08x %08x\n", t->id,\r\nt->reg[0], t->reg[1], t->reg[2]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_mem_timing_calc(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct bit_entry P;\r\nuint8_t unk18 = 1, unk20 = 0, unk21 = 0, tmp7_3;\r\nif (bit_table(dev, 'P', &P))\r\nreturn -EINVAL;\r\nswitch (min(len, (u8) 22)) {\r\ncase 22:\r\nunk21 = e->tUNK_21;\r\ncase 21:\r\nunk20 = e->tUNK_20;\r\ncase 20:\r\nif (e->tCWL > 0)\r\nt->tCWL = e->tCWL;\r\ncase 19:\r\nunk18 = e->tUNK_18;\r\nbreak;\r\n}\r\nt->reg[0] = (e->tRP << 24 | e->tRAS << 16 | e->tRFC << 8 | e->tRC);\r\nt->reg[1] = (e->tWR + 2 + (t->tCWL - 1)) << 24 |\r\nmax(unk18, (u8) 1) << 16 |\r\n(e->tWTR + 2 + (t->tCWL - 1)) << 8;\r\nt->reg[2] = ((t->tCWL - 1) << 24 |\r\ne->tRRD << 16 |\r\ne->tRCDWR << 8 |\r\ne->tRCDRD);\r\nt->reg[4] = e->tUNK_13 << 8 | e->tUNK_13;\r\nt->reg[5] = (e->tRFC << 24 | max(e->tRCDRD, e->tRCDWR) << 16 | e->tRP);\r\nt->reg[8] = boot->reg[8] & 0xffffff00;\r\nif (P.version == 1) {\r\nt->reg[1] |= (e->tCL + 2 - (t->tCWL - 1));\r\nt->reg[3] = (0x14 + e->tCL) << 24 |\r\n0x16 << 16 |\r\n(e->tCL - 1) << 8 |\r\n(e->tCL - 1);\r\nt->reg[4] |= boot->reg[4] & 0xffff0000;\r\nt->reg[6] = (0x33 - t->tCWL) << 16 |\r\nt->tCWL << 8 |\r\n(0x2e + e->tCL - t->tCWL);\r\nt->reg[7] = 0x4000202 | (e->tCL - 1) << 16;\r\nif (dev_priv->vram_type == NV_MEM_TYPE_DDR2) {\r\nt->reg[5] |= (e->tCL + 3) << 8;\r\nt->reg[6] |= (t->tCWL - 2) << 8;\r\nt->reg[8] |= (e->tCL - 4);\r\n} else {\r\nt->reg[5] |= (e->tCL + 2) << 8;\r\nt->reg[6] |= t->tCWL << 8;\r\nt->reg[8] |= (e->tCL - 2);\r\n}\r\n} else {\r\nt->reg[1] |= (5 + e->tCL - (t->tCWL));\r\nt->reg[3] = (0x30 + e->tCL) << 24 |\r\n(boot->reg[3] & 0x00ff0000)|\r\n(0xb + e->tCL) << 8 |\r\n(e->tCL - 1);\r\nt->reg[4] |= (unk20 << 24 | unk21 << 16);\r\nt->reg[5] |= (t->tCWL + 6) << 8;\r\nt->reg[6] = (0x5a + e->tCL) << 16 |\r\n(6 - e->tCL + t->tCWL) << 8 |\r\n(0x50 + e->tCL - t->tCWL);\r\ntmp7_3 = (boot->reg[7] & 0xff000000) >> 24;\r\nt->reg[7] = (tmp7_3 << 24) |\r\n((tmp7_3 - 6 + e->tCL) << 16) |\r\n0x202;\r\n}\r\nNV_DEBUG(dev, "Entry %d: 220: %08x %08x %08x %08x\n", t->id,\r\nt->reg[0], t->reg[1], t->reg[2], t->reg[3]);\r\nNV_DEBUG(dev, " 230: %08x %08x %08x %08x\n",\r\nt->reg[4], t->reg[5], t->reg[6], t->reg[7]);\r\nNV_DEBUG(dev, " 240: %08x\n", t->reg[8]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_mem_timing_calc(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nif (e->tCWL > 0)\r\nt->tCWL = e->tCWL;\r\nt->reg[0] = (e->tRP << 24 | (e->tRAS & 0x7f) << 17 |\r\ne->tRFC << 8 | e->tRC);\r\nt->reg[1] = (boot->reg[1] & 0xff000000) |\r\n(e->tRCDWR & 0x0f) << 20 |\r\n(e->tRCDRD & 0x0f) << 14 |\r\n(t->tCWL << 7) |\r\n(e->tCL & 0x0f);\r\nt->reg[2] = (boot->reg[2] & 0xff0000ff) |\r\ne->tWR << 16 | e->tWTR << 8;\r\nt->reg[3] = (e->tUNK_20 & 0x1f) << 9 |\r\n(e->tUNK_21 & 0xf) << 5 |\r\n(e->tUNK_13 & 0x1f);\r\nt->reg[4] = (boot->reg[4] & 0xfff00fff) |\r\n(e->tRRD&0x1f) << 15;\r\nNV_DEBUG(dev, "Entry %d: 290: %08x %08x %08x %08x\n", t->id,\r\nt->reg[0], t->reg[1], t->reg[2], t->reg[3]);\r\nNV_DEBUG(dev, " 2a0: %08x\n", t->reg[4]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_mem_ddr2_mr(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nt->drive_strength = 0;\r\nif (len < 15) {\r\nt->odt = boot->odt;\r\n} else {\r\nt->odt = e->RAM_FT1 & 0x07;\r\n}\r\nif (e->tCL >= NV_MEM_CL_DDR2_MAX) {\r\nNV_WARN(dev, "(%u) Invalid tCL: %u", t->id, e->tCL);\r\nreturn -ERANGE;\r\n}\r\nif (e->tWR >= NV_MEM_WR_DDR2_MAX) {\r\nNV_WARN(dev, "(%u) Invalid tWR: %u", t->id, e->tWR);\r\nreturn -ERANGE;\r\n}\r\nif (t->odt > 3) {\r\nNV_WARN(dev, "(%u) Invalid odt value, assuming disabled: %x",\r\nt->id, t->odt);\r\nt->odt = 0;\r\n}\r\nt->mr[0] = (boot->mr[0] & 0x100f) |\r\n(e->tCL) << 4 |\r\n(e->tWR - 1) << 9;\r\nt->mr[1] = (boot->mr[1] & 0x101fbb) |\r\n(t->odt & 0x1) << 2 |\r\n(t->odt & 0x2) << 5;\r\nNV_DEBUG(dev, "(%u) MR: %08x", t->id, t->mr[0]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_mem_ddr3_mr(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nu8 cl = e->tCL - 4;\r\nt->drive_strength = 0;\r\nif (len < 15) {\r\nt->odt = boot->odt;\r\n} else {\r\nt->odt = e->RAM_FT1 & 0x07;\r\n}\r\nif (e->tCL >= NV_MEM_CL_DDR3_MAX || e->tCL < 4) {\r\nNV_WARN(dev, "(%u) Invalid tCL: %u", t->id, e->tCL);\r\nreturn -ERANGE;\r\n}\r\nif (e->tWR >= NV_MEM_WR_DDR3_MAX || e->tWR < 4) {\r\nNV_WARN(dev, "(%u) Invalid tWR: %u", t->id, e->tWR);\r\nreturn -ERANGE;\r\n}\r\nif (e->tCWL < 5) {\r\nNV_WARN(dev, "(%u) Invalid tCWL: %u", t->id, e->tCWL);\r\nreturn -ERANGE;\r\n}\r\nt->mr[0] = (boot->mr[0] & 0x180b) |\r\n(cl & 0x7) << 4 |\r\n(cl & 0x8) >> 1 |\r\n(nv_mem_wr_lut_ddr3[e->tWR]) << 9;\r\nt->mr[1] = (boot->mr[1] & 0x101dbb) |\r\n(t->odt & 0x1) << 2 |\r\n(t->odt & 0x2) << 5 |\r\n(t->odt & 0x4) << 7;\r\nt->mr[2] = (boot->mr[2] & 0x20ffb7) | (e->tCWL - 5) << 3;\r\nNV_DEBUG(dev, "(%u) MR: %08x %08x", t->id, t->mr[0], t->mr[2]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_mem_gddr3_mr(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nif (len < 15) {\r\nt->drive_strength = boot->drive_strength;\r\nt->odt = boot->odt;\r\n} else {\r\nt->drive_strength = (e->RAM_FT1 & 0x30) >> 4;\r\nt->odt = e->RAM_FT1 & 0x07;\r\n}\r\nif (e->tCL >= NV_MEM_CL_GDDR3_MAX) {\r\nNV_WARN(dev, "(%u) Invalid tCL: %u", t->id, e->tCL);\r\nreturn -ERANGE;\r\n}\r\nif (e->tWR >= NV_MEM_WR_GDDR3_MAX) {\r\nNV_WARN(dev, "(%u) Invalid tWR: %u", t->id, e->tWR);\r\nreturn -ERANGE;\r\n}\r\nif (t->odt > 3) {\r\nNV_WARN(dev, "(%u) Invalid odt value, assuming autocal: %x",\r\nt->id, t->odt);\r\nt->odt = 0;\r\n}\r\nt->mr[0] = (boot->mr[0] & 0xe0b) |\r\n((nv_mem_cl_lut_gddr3[e->tCL] & 0x7) << 4) |\r\n((nv_mem_cl_lut_gddr3[e->tCL] & 0x8) >> 2);\r\nt->mr[1] = (boot->mr[1] & 0x100f40) | t->drive_strength |\r\n(t->odt << 2) |\r\n(nv_mem_wr_lut_gddr3[e->tWR] & 0xf) << 4;\r\nt->mr[2] = boot->mr[2];\r\nNV_DEBUG(dev, "(%u) MR: %08x %08x %08x", t->id,\r\nt->mr[0], t->mr[1], t->mr[2]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_mem_gddr5_mr(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nif (len < 15) {\r\nt->drive_strength = boot->drive_strength;\r\nt->odt = boot->odt;\r\n} else {\r\nt->drive_strength = (e->RAM_FT1 & 0x30) >> 4;\r\nt->odt = e->RAM_FT1 & 0x03;\r\n}\r\nif (e->tCL >= NV_MEM_CL_GDDR5_MAX) {\r\nNV_WARN(dev, "(%u) Invalid tCL: %u", t->id, e->tCL);\r\nreturn -ERANGE;\r\n}\r\nif (e->tWR >= NV_MEM_WR_GDDR5_MAX) {\r\nNV_WARN(dev, "(%u) Invalid tWR: %u", t->id, e->tWR);\r\nreturn -ERANGE;\r\n}\r\nif (t->odt > 3) {\r\nNV_WARN(dev, "(%u) Invalid odt value, assuming autocal: %x",\r\nt->id, t->odt);\r\nt->odt = 0;\r\n}\r\nt->mr[0] = (boot->mr[0] & 0x007) |\r\n((e->tCL - 5) << 3) |\r\n((e->tWR - 4) << 8);\r\nt->mr[1] = (boot->mr[1] & 0x1007f0) |\r\nt->drive_strength |\r\n(t->odt << 2);\r\nNV_DEBUG(dev, "(%u) MR: %08x %08x", t->id, t->mr[0], t->mr[1]);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_mem_timing_calc(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_memtiming *boot = &pm->boot.timing;\r\nstruct nouveau_pm_tbl_entry *e;\r\nu8 ver, len, *ptr, *ramcfg;\r\nint ret;\r\nptr = nouveau_perf_timing(dev, freq, &ver, &len);\r\nif (!ptr || ptr[0] == 0x00) {\r\n*t = *boot;\r\nreturn 0;\r\n}\r\ne = (struct nouveau_pm_tbl_entry *)ptr;\r\nt->tCWL = boot->tCWL;\r\nswitch (dev_priv->card_type) {\r\ncase NV_40:\r\nret = nv40_mem_timing_calc(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_50:\r\nret = nv50_mem_timing_calc(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_C0:\r\ncase NV_D0:\r\nret = nvc0_mem_timing_calc(dev, freq, e, len, boot, t);\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nswitch (dev_priv->vram_type * !ret) {\r\ncase NV_MEM_TYPE_GDDR3:\r\nret = nouveau_mem_gddr3_mr(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR5:\r\nret = nouveau_mem_gddr5_mr(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_MEM_TYPE_DDR2:\r\nret = nouveau_mem_ddr2_mr(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_MEM_TYPE_DDR3:\r\nret = nouveau_mem_ddr3_mr(dev, freq, e, len, boot, t);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nramcfg = nouveau_perf_ramcfg(dev, freq, &ver, &len);\r\nif (ramcfg) {\r\nint dll_off;\r\nif (ver == 0x00)\r\ndll_off = !!(ramcfg[3] & 0x04);\r\nelse\r\ndll_off = !!(ramcfg[2] & 0x40);\r\nswitch (dev_priv->vram_type) {\r\ncase NV_MEM_TYPE_GDDR3:\r\nt->mr[1] &= ~0x00000040;\r\nt->mr[1] |= 0x00000040 * dll_off;\r\nbreak;\r\ndefault:\r\nt->mr[1] &= ~0x00000001;\r\nt->mr[1] |= 0x00000001 * dll_off;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_mem_timing_read(struct drm_device *dev, struct nouveau_pm_memtiming *t)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 timing_base, timing_regs, mr_base;\r\nint i;\r\nif (dev_priv->card_type >= 0xC0) {\r\ntiming_base = 0x10f290;\r\nmr_base = 0x10f300;\r\n} else {\r\ntiming_base = 0x100220;\r\nmr_base = 0x1002c0;\r\n}\r\nt->id = -1;\r\nswitch (dev_priv->card_type) {\r\ncase NV_50:\r\ntiming_regs = 9;\r\nbreak;\r\ncase NV_C0:\r\ncase NV_D0:\r\ntiming_regs = 5;\r\nbreak;\r\ncase NV_30:\r\ncase NV_40:\r\ntiming_regs = 3;\r\nbreak;\r\ndefault:\r\ntiming_regs = 0;\r\nreturn;\r\n}\r\nfor(i = 0; i < timing_regs; i++)\r\nt->reg[i] = nv_rd32(dev, timing_base + (0x04 * i));\r\nt->tCWL = 0;\r\nif (dev_priv->card_type < NV_C0) {\r\nt->tCWL = ((nv_rd32(dev, 0x100228) & 0x0f000000) >> 24) + 1;\r\n} else if (dev_priv->card_type <= NV_D0) {\r\nt->tCWL = ((nv_rd32(dev, 0x10f294) & 0x00000f80) >> 7);\r\n}\r\nt->mr[0] = nv_rd32(dev, mr_base);\r\nt->mr[1] = nv_rd32(dev, mr_base + 0x04);\r\nt->mr[2] = nv_rd32(dev, mr_base + 0x20);\r\nt->mr[3] = nv_rd32(dev, mr_base + 0x24);\r\nt->odt = 0;\r\nt->drive_strength = 0;\r\nswitch (dev_priv->vram_type) {\r\ncase NV_MEM_TYPE_DDR3:\r\nt->odt |= (t->mr[1] & 0x200) >> 7;\r\ncase NV_MEM_TYPE_DDR2:\r\nt->odt |= (t->mr[1] & 0x04) >> 2 |\r\n(t->mr[1] & 0x40) >> 5;\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR3:\r\ncase NV_MEM_TYPE_GDDR5:\r\nt->drive_strength = t->mr[1] & 0x03;\r\nt->odt = (t->mr[1] & 0x0c) >> 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint\r\nnouveau_mem_exec(struct nouveau_mem_exec_func *exec,\r\nstruct nouveau_pm_level *perflvl)\r\n{\r\nstruct drm_nouveau_private *dev_priv = exec->dev->dev_private;\r\nstruct nouveau_pm_memtiming *info = &perflvl->timing;\r\nu32 tMRD = 1000, tCKSRE = 0, tCKSRX = 0, tXS = 0, tDLLK = 0;\r\nu32 mr[3] = { info->mr[0], info->mr[1], info->mr[2] };\r\nu32 mr1_dlloff;\r\nswitch (dev_priv->vram_type) {\r\ncase NV_MEM_TYPE_DDR2:\r\ntDLLK = 2000;\r\nmr1_dlloff = 0x00000001;\r\nbreak;\r\ncase NV_MEM_TYPE_DDR3:\r\ntDLLK = 12000;\r\ntCKSRE = 2000;\r\ntXS = 1000;\r\nmr1_dlloff = 0x00000001;\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR3:\r\ntDLLK = 40000;\r\nmr1_dlloff = 0x00000040;\r\nbreak;\r\ndefault:\r\nNV_ERROR(exec->dev, "cannot reclock unsupported memtype\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (dev_priv->vram_type) {\r\ncase NV_MEM_TYPE_GDDR3:\r\ncase NV_MEM_TYPE_DDR3:\r\nmr[2] = exec->mrg(exec, 2);\r\ndefault:\r\nmr[1] = exec->mrg(exec, 1);\r\nmr[0] = exec->mrg(exec, 0);\r\nbreak;\r\n}\r\nif (!(mr[1] & mr1_dlloff) && (info->mr[1] & mr1_dlloff)) {\r\nexec->precharge(exec);\r\nexec->mrs (exec, 1, mr[1] | mr1_dlloff);\r\nexec->wait(exec, tMRD);\r\n}\r\nexec->precharge(exec);\r\nexec->refresh(exec);\r\nexec->refresh(exec);\r\nexec->refresh_auto(exec, false);\r\nexec->refresh_self(exec, true);\r\nexec->wait(exec, tCKSRE);\r\nexec->clock_set(exec);\r\nexec->wait(exec, tCKSRX);\r\nexec->precharge(exec);\r\nexec->refresh_self(exec, false);\r\nexec->refresh_auto(exec, true);\r\nexec->wait(exec, tXS);\r\nexec->wait(exec, tXS);\r\nif (mr[2] != info->mr[2]) {\r\nexec->mrs (exec, 2, info->mr[2]);\r\nexec->wait(exec, tMRD);\r\n}\r\nif (mr[1] != info->mr[1]) {\r\nexec->mrs (exec, 1, info->mr[1] | (mr[1] & mr1_dlloff));\r\nexec->wait(exec, tMRD);\r\n}\r\nif (mr[0] != info->mr[0]) {\r\nexec->mrs (exec, 0, info->mr[0]);\r\nexec->wait(exec, tMRD);\r\n}\r\nexec->timing_set(exec);\r\nif (!(info->mr[1] & mr1_dlloff)) {\r\nif (mr[1] & mr1_dlloff) {\r\nexec->mrs (exec, 1, info->mr[1]);\r\nexec->wait(exec, tMRD);\r\n}\r\nexec->mrs (exec, 0, info->mr[0] | 0x00000100);\r\nexec->wait(exec, tMRD);\r\nexec->mrs (exec, 0, info->mr[0] | 0x00000000);\r\nexec->wait(exec, tMRD);\r\nexec->wait(exec, tDLLK);\r\nif (dev_priv->vram_type == NV_MEM_TYPE_GDDR3)\r\nexec->precharge(exec);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_mem_vbios_type(struct drm_device *dev)\r\n{\r\nstruct bit_entry M;\r\nu8 ramcfg = (nv_rd32(dev, 0x101000) & 0x0000003c) >> 2;\r\nif (!bit_table(dev, 'M', &M) || M.version != 2 || M.length < 5) {\r\nu8 *table = ROMPTR(dev, M.data[3]);\r\nif (table && table[0] == 0x10 && ramcfg < table[3]) {\r\nu8 *entry = table + table[1] + (ramcfg * table[2]);\r\nswitch (entry[0] & 0x0f) {\r\ncase 0: return NV_MEM_TYPE_DDR2;\r\ncase 1: return NV_MEM_TYPE_DDR3;\r\ncase 2: return NV_MEM_TYPE_GDDR3;\r\ncase 3: return NV_MEM_TYPE_GDDR5;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn NV_MEM_TYPE_UNKNOWN;\r\n}\r\nstatic int\r\nnouveau_vram_manager_init(struct ttm_mem_type_manager *man, unsigned long psize)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_vram_manager_fini(struct ttm_mem_type_manager *man)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void\r\nnouveau_mem_node_cleanup(struct nouveau_mem *node)\r\n{\r\nif (node->vma[0].node) {\r\nnouveau_vm_unmap(&node->vma[0]);\r\nnouveau_vm_put(&node->vma[0]);\r\n}\r\nif (node->vma[1].node) {\r\nnouveau_vm_unmap(&node->vma[1]);\r\nnouveau_vm_put(&node->vma[1]);\r\n}\r\n}\r\nstatic void\r\nnouveau_vram_manager_del(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct drm_nouveau_private *dev_priv = nouveau_bdev(man->bdev);\r\nstruct nouveau_vram_engine *vram = &dev_priv->engine.vram;\r\nstruct drm_device *dev = dev_priv->dev;\r\nnouveau_mem_node_cleanup(mem->mm_node);\r\nvram->put(dev, (struct nouveau_mem **)&mem->mm_node);\r\n}\r\nstatic int\r\nnouveau_vram_manager_new(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct drm_nouveau_private *dev_priv = nouveau_bdev(man->bdev);\r\nstruct nouveau_vram_engine *vram = &dev_priv->engine.vram;\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct nouveau_bo *nvbo = nouveau_bo(bo);\r\nstruct nouveau_mem *node;\r\nu32 size_nc = 0;\r\nint ret;\r\nif (nvbo->tile_flags & NOUVEAU_GEM_TILE_NONCONTIG)\r\nsize_nc = 1 << nvbo->page_shift;\r\nret = vram->get(dev, mem->num_pages << PAGE_SHIFT,\r\nmem->page_alignment << PAGE_SHIFT, size_nc,\r\n(nvbo->tile_flags >> 8) & 0x3ff, &node);\r\nif (ret) {\r\nmem->mm_node = NULL;\r\nreturn (ret == -ENOSPC) ? 0 : ret;\r\n}\r\nnode->page_shift = nvbo->page_shift;\r\nmem->mm_node = node;\r\nmem->start = node->offset >> PAGE_SHIFT;\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_vram_manager_debug(struct ttm_mem_type_manager *man, const char *prefix)\r\n{\r\nstruct nouveau_mm *mm = man->priv;\r\nstruct nouveau_mm_node *r;\r\nu32 total = 0, free = 0;\r\nmutex_lock(&mm->mutex);\r\nlist_for_each_entry(r, &mm->nodes, nl_entry) {\r\nprintk(KERN_DEBUG "%s %d: 0x%010llx 0x%010llx\n",\r\nprefix, r->type, ((u64)r->offset << 12),\r\n(((u64)r->offset + r->length) << 12));\r\ntotal += r->length;\r\nif (!r->type)\r\nfree += r->length;\r\n}\r\nmutex_unlock(&mm->mutex);\r\nprintk(KERN_DEBUG "%s total: 0x%010llx free: 0x%010llx\n",\r\nprefix, (u64)total << 12, (u64)free << 12);\r\nprintk(KERN_DEBUG "%s block: 0x%08x\n",\r\nprefix, mm->block_size << 12);\r\n}\r\nstatic int\r\nnouveau_gart_manager_init(struct ttm_mem_type_manager *man, unsigned long psize)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_gart_manager_fini(struct ttm_mem_type_manager *man)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_gart_manager_del(struct ttm_mem_type_manager *man,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nnouveau_mem_node_cleanup(mem->mm_node);\r\nkfree(mem->mm_node);\r\nmem->mm_node = NULL;\r\n}\r\nstatic int\r\nnouveau_gart_manager_new(struct ttm_mem_type_manager *man,\r\nstruct ttm_buffer_object *bo,\r\nstruct ttm_placement *placement,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct drm_nouveau_private *dev_priv = nouveau_bdev(bo->bdev);\r\nstruct nouveau_mem *node;\r\nif (unlikely((mem->num_pages << PAGE_SHIFT) >=\r\ndev_priv->gart_info.aper_size))\r\nreturn -ENOMEM;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->page_shift = 12;\r\nmem->mm_node = node;\r\nmem->start = 0;\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_gart_manager_debug(struct ttm_mem_type_manager *man, const char *prefix)\r\n{\r\n}
