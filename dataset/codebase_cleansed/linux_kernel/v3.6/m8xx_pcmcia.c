static int voltage_set(int slot, int vcc, int vpp)\r\n{\r\nu32 reg = 0;\r\nswitch (vcc) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\nreg |= BCSR1_PCVCTL4;\r\nbreak;\r\ncase 50:\r\nreg |= BCSR1_PCVCTL5;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nswitch (vpp) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\ncase 50:\r\nif (vcc == vpp)\r\nreg |= BCSR1_PCVCTL6;\r\nelse\r\nreturn 1;\r\nbreak;\r\ncase 120:\r\nreg |= BCSR1_PCVCTL7;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (!((vcc == 50) || (vcc == 0)))\r\nreturn 1;\r\nout_be32(((u32 *) RPX_CSR_ADDR),\r\nin_be32(((u32 *) RPX_CSR_ADDR)) & ~(BCSR1_PCVCTL4 |\r\nBCSR1_PCVCTL5 |\r\nBCSR1_PCVCTL6 |\r\nBCSR1_PCVCTL7));\r\nout_be32(((u32 *) RPX_CSR_ADDR), in_be32(((u32 *) RPX_CSR_ADDR)) | reg);\r\nreturn 0;\r\n}\r\nstatic int voltage_set(int slot, int vcc, int vpp)\r\n{\r\nu32 reg = 0;\r\nswitch (vcc) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\nreg |= BCSR1_PCCVCC0;\r\nbreak;\r\ncase 50:\r\nreg |= BCSR1_PCCVCC1;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nswitch (vpp) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\ncase 50:\r\nif (vcc == vpp)\r\nreg |= BCSR1_PCCVPP1;\r\nelse\r\nreturn 1;\r\nbreak;\r\ncase 120:\r\nif ((vcc == 33) || (vcc == 50))\r\nreg |= BCSR1_PCCVPP0;\r\nelse\r\nreturn 1;\r\ndefault:\r\nreturn 1;\r\n}\r\nout_be32((u32 *) BCSR1,\r\nin_be32((u32 *) BCSR1) & ~(BCSR1_PCCVCC_MASK |\r\nBCSR1_PCCVPP_MASK));\r\nout_be32((u32 *) BCSR1, in_be32((u32 *) BCSR1) | reg);\r\nreturn 0;\r\n}\r\nstatic void hardware_enable(int slot)\r\n{\r\nout_be32((u32 *) BCSR1, in_be32((u32 *) BCSR1) & ~BCSR1_PCCEN);\r\n}\r\nstatic void hardware_disable(int slot)\r\n{\r\nout_be32((u32 *) BCSR1, in_be32((u32 *) BCSR1) | BCSR1_PCCEN);\r\n}\r\nstatic inline void hardware_enable(int slot)\r\n{\r\nm8xx_pcmcia_ops.hw_ctrl(slot, 1);\r\n}\r\nstatic inline void hardware_disable(int slot)\r\n{\r\nm8xx_pcmcia_ops.hw_ctrl(slot, 0);\r\n}\r\nstatic inline int voltage_set(int slot, int vcc, int vpp)\r\n{\r\nreturn m8xx_pcmcia_ops.voltage_set(slot, vcc, vpp);\r\n}\r\nstatic int voltage_set(int slot, int vcc, int vpp)\r\n{\r\nu8 reg = 0;\r\nswitch (vcc) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\nreg |= CSR2_VCC_33;\r\nbreak;\r\ncase 50:\r\nreg |= CSR2_VCC_50;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nswitch (vpp) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\ncase 50:\r\nif (vcc == vpp)\r\nreg |= CSR2_VPP_VCC;\r\nelse\r\nreturn 1;\r\nbreak;\r\ncase 120:\r\nif ((vcc == 33) || (vcc == 50))\r\nreg |= CSR2_VPP_12;\r\nelse\r\nreturn 1;\r\ndefault:\r\nreturn 1;\r\n}\r\nout_8((u8 *) MBX_CSR2_ADDR,\r\nin_8((u8 *) MBX_CSR2_ADDR) & ~(CSR2_VCC_MASK | CSR2_VPP_MASK));\r\nout_8((u8 *) MBX_CSR2_ADDR, in_8((u8 *) MBX_CSR2_ADDR) | reg);\r\nreturn 0;\r\n}\r\nstatic int voltage_set(int slot, int vcc, int vpp)\r\n{\r\nu8 reg = 0;\r\nu8 regread;\r\ncpld_regs *ccpld = get_cpld();\r\nswitch (vcc) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\nreg |= PCMCIA_VCC_33;\r\nbreak;\r\ncase 50:\r\nreg |= PCMCIA_VCC_50;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nswitch (vpp) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\ncase 50:\r\nif (vcc == vpp)\r\nreg |= PCMCIA_VPP_VCC;\r\nelse\r\nreturn 1;\r\nbreak;\r\ncase 120:\r\nif ((vcc == 33) || (vcc == 50))\r\nreg |= PCMCIA_VPP_12;\r\nelse\r\nreturn 1;\r\ndefault:\r\nreturn 1;\r\n}\r\nreg = reg >> (slot << 2);\r\nregread = in_8(&ccpld->fpga_pc_ctl);\r\nif (reg !=\r\n(regread & ((PCMCIA_VCC_MASK | PCMCIA_VPP_MASK) >> (slot << 2)))) {\r\nregread =\r\nregread & ~((PCMCIA_VCC_MASK | PCMCIA_VPP_MASK) >>\r\n(slot << 2));\r\nout_8(&ccpld->fpga_pc_ctl, reg | regread);\r\nmsleep(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t m8xx_interrupt(int irq, void *dev)\r\n{\r\nstruct socket_info *s;\r\nstruct event_table *e;\r\nunsigned int i, events, pscr, pipr, per;\r\npcmconf8xx_t *pcmcia = socket[0].pcmcia;\r\npr_debug("m8xx_pcmcia: Interrupt!\n");\r\npscr = in_be32(&pcmcia->pcmc_pscr);\r\npipr = in_be32(&pcmcia->pcmc_pipr);\r\nper = in_be32(&pcmcia->pcmc_per);\r\nfor (i = 0; i < PCMCIA_SOCKETS_NO; i++) {\r\ns = &socket[i];\r\ne = &s->events[0];\r\nevents = 0;\r\nwhile (e->regbit) {\r\nif (pscr & e->regbit)\r\nevents |= e->eventbit;\r\ne++;\r\n}\r\nif (events & SS_DETECT)\r\nif (((pipr & M8XX_PCMCIA_CD2(i)) >> 1) ^\r\n(pipr & M8XX_PCMCIA_CD1(i))) {\r\nevents &= ~SS_DETECT;\r\n}\r\n#ifdef PCMCIA_GLITCHY_CD\r\nif ((events & SS_DETECT) &&\r\n((pipr &\r\n(M8XX_PCMCIA_CD2(i) | M8XX_PCMCIA_CD1(i))) == 0) &&\r\n(s->state.Vcc | s->state.Vpp)) {\r\nevents &= ~SS_DETECT;\r\n}\r\n#endif\r\npr_debug("m8xx_pcmcia: slot %u: events = 0x%02x, pscr = 0x%08x, "\r\n"pipr = 0x%08x\n", i, events, pscr, pipr);\r\nif (events) {\r\nspin_lock(&pending_event_lock);\r\npending_events[i] |= events;\r\nspin_unlock(&pending_event_lock);\r\nper &= ~M8XX_PCMCIA_RDY_L(0);\r\nper &= ~M8XX_PCMCIA_RDY_L(1);\r\nout_be32(&pcmcia->pcmc_per, per);\r\nif (events)\r\npcmcia_parse_events(&socket[i].socket, events);\r\n}\r\n}\r\nout_be32(&pcmcia->pcmc_pscr, pscr);\r\npr_debug("m8xx_pcmcia: Interrupt done.\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32 m8xx_get_graycode(u32 size)\r\n{\r\nu32 k;\r\nfor (k = 0; k < M8XX_SIZES_NO; k++)\r\nif (m8xx_size_to_gray[k] == size)\r\nbreak;\r\nif ((k == M8XX_SIZES_NO) || (m8xx_size_to_gray[k] == -1))\r\nk = -1;\r\nreturn k;\r\n}\r\nstatic u32 m8xx_get_speed(u32 ns, u32 is_io, u32 bus_freq)\r\n{\r\nu32 reg, clocks, psst, psl, psht;\r\nif (!ns) {\r\nif (is_io)\r\nns = 255;\r\nelse\r\nns = 100;\r\n}\r\n#define ADJ 180\r\nclocks = ((bus_freq / 1000) * ns) / 1000;\r\nclocks = (clocks * ADJ) / (100 * 1000);\r\nif (clocks >= PCMCIA_BMT_LIMIT) {\r\nprintk("Max access time limit reached\n");\r\nclocks = PCMCIA_BMT_LIMIT - 1;\r\n}\r\npsst = clocks / 7;\r\npsht = clocks / 7;\r\npsl = (clocks * 5) / 7;\r\npsst += clocks - (psst + psht + psl);\r\nreg = psst << 12;\r\nreg |= psl << 7;\r\nreg |= psht << 16;\r\nreturn reg;\r\n}\r\nstatic int m8xx_get_status(struct pcmcia_socket *sock, unsigned int *value)\r\n{\r\nint lsock = container_of(sock, struct socket_info, socket)->slot;\r\nstruct socket_info *s = &socket[lsock];\r\nunsigned int pipr, reg;\r\npcmconf8xx_t *pcmcia = s->pcmcia;\r\npipr = in_be32(&pcmcia->pcmc_pipr);\r\n*value = ((pipr & (M8XX_PCMCIA_CD1(lsock)\r\n| M8XX_PCMCIA_CD2(lsock))) == 0) ? SS_DETECT : 0;\r\n*value |= (pipr & M8XX_PCMCIA_WP(lsock)) ? SS_WRPROT : 0;\r\nif (s->state.flags & SS_IOCARD)\r\n*value |= (pipr & M8XX_PCMCIA_BVD1(lsock)) ? SS_STSCHG : 0;\r\nelse {\r\n*value |= (pipr & M8XX_PCMCIA_RDY(lsock)) ? SS_READY : 0;\r\n*value |= (pipr & M8XX_PCMCIA_BVD1(lsock)) ? SS_BATDEAD : 0;\r\n*value |= (pipr & M8XX_PCMCIA_BVD2(lsock)) ? SS_BATWARN : 0;\r\n}\r\nif (s->state.Vcc | s->state.Vpp)\r\n*value |= SS_POWERON;\r\nreg = (pipr & M8XX_PCMCIA_VS_MASK(lsock))\r\n>> M8XX_PCMCIA_VS_SHIFT(lsock);\r\nif (socket_get(lsock) == PCMCIA_SOCKET_KEY_LV) {\r\nswitch (reg) {\r\ncase 1:\r\n*value |= SS_3VCARD;\r\nbreak;\r\ncase 2:\r\n*value |= SS_XVCARD;\r\nbreak;\r\n};\r\n}\r\npr_debug("m8xx_pcmcia: GetStatus(%d) = %#2.2x\n", lsock, *value);\r\nreturn 0;\r\n}\r\nstatic int m8xx_set_socket(struct pcmcia_socket *sock, socket_state_t * state)\r\n{\r\nint lsock = container_of(sock, struct socket_info, socket)->slot;\r\nstruct socket_info *s = &socket[lsock];\r\nstruct event_table *e;\r\nunsigned int reg;\r\nunsigned long flags;\r\npcmconf8xx_t *pcmcia = socket[0].pcmcia;\r\npr_debug("m8xx_pcmcia: SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "\r\n"io_irq %d, csc_mask %#2.2x)\n", lsock, state->flags,\r\nstate->Vcc, state->Vpp, state->io_irq, state->csc_mask);\r\nif (voltage_set(lsock, state->Vcc, state->Vpp))\r\nreturn -EINVAL;\r\nif (state->flags & SS_RESET)\r\nout_be32(M8XX_PGCRX(lsock), in_be32(M8XX_PGCRX(lsock)) | M8XX_PGCRX_CXRESET);\r\nelse\r\nout_be32(M8XX_PGCRX(lsock),\r\nin_be32(M8XX_PGCRX(lsock)) & ~M8XX_PGCRX_CXRESET);\r\nif (state->Vcc || state->Vpp)\r\nout_be32(M8XX_PGCRX(lsock), in_be32(M8XX_PGCRX(lsock)) & ~M8XX_PGCRX_CXOE);\r\nelse\r\nout_be32(M8XX_PGCRX(lsock),\r\nin_be32(M8XX_PGCRX(lsock)) | M8XX_PGCRX_CXOE);\r\nspin_lock_irqsave(&events_lock, flags);\r\ne = &s->events[0];\r\nreg = 0;\r\nif (state->csc_mask & SS_DETECT) {\r\ne->eventbit = SS_DETECT;\r\nreg |= e->regbit = (M8XX_PCMCIA_CD2(lsock)\r\n| M8XX_PCMCIA_CD1(lsock));\r\ne++;\r\n}\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG) {\r\ne->eventbit = SS_STSCHG;\r\nreg |= e->regbit = M8XX_PCMCIA_BVD1(lsock);\r\ne++;\r\n}\r\nif (state->io_irq) {\r\nout_be32(M8XX_PGCRX(lsock),\r\nin_be32(M8XX_PGCRX(lsock)) |\r\nmk_int_int_mask(s->hwirq) << 24);\r\nreg |= M8XX_PCMCIA_RDY_L(lsock);\r\n} else\r\nout_be32(M8XX_PGCRX(lsock),\r\nin_be32(M8XX_PGCRX(lsock)) & 0x00ffffff);\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD) {\r\ne->eventbit = SS_BATDEAD;\r\nreg |= e->regbit = M8XX_PCMCIA_BVD1(lsock);\r\ne++;\r\n}\r\nif (state->csc_mask & SS_BATWARN) {\r\ne->eventbit = SS_BATWARN;\r\nreg |= e->regbit = M8XX_PCMCIA_BVD2(lsock);\r\ne++;\r\n}\r\nif (state->csc_mask & SS_READY) {\r\ne->eventbit = SS_READY;\r\nreg |= e->regbit = 0;\r\ne++;\r\n}\r\n}\r\ne->regbit = 0;\r\nout_be32(&pcmcia->pcmc_pscr, reg);\r\nreg |=\r\nin_be32(&pcmcia->\r\npcmc_per) & (M8XX_PCMCIA_MASK(0) | M8XX_PCMCIA_MASK(1));\r\nout_be32(&pcmcia->pcmc_per, reg);\r\nspin_unlock_irqrestore(&events_lock, flags);\r\ns->state = *state;\r\nreturn 0;\r\n}\r\nstatic int m8xx_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *io)\r\n{\r\nint lsock = container_of(sock, struct socket_info, socket)->slot;\r\nstruct socket_info *s = &socket[lsock];\r\nstruct pcmcia_win *w;\r\nunsigned int reg, winnr;\r\npcmconf8xx_t *pcmcia = s->pcmcia;\r\n#define M8XX_SIZE (io->stop - io->start + 1)\r\n#define M8XX_BASE (PCMCIA_IO_WIN_BASE + io->start)\r\npr_debug("m8xx_pcmcia: SetIOMap(%d, %d, %#2.2x, %d ns, "\r\n"%#4.4llx-%#4.4llx)\n", lsock, io->map, io->flags,\r\nio->speed, (unsigned long long)io->start,\r\n(unsigned long long)io->stop);\r\nif ((io->map >= PCMCIA_IO_WIN_NO) || (io->start > 0xffff)\r\n|| (io->stop > 0xffff) || (io->stop < io->start))\r\nreturn -EINVAL;\r\nif ((reg = m8xx_get_graycode(M8XX_SIZE)) == -1)\r\nreturn -EINVAL;\r\nif (io->flags & MAP_ACTIVE) {\r\npr_debug("m8xx_pcmcia: io->flags & MAP_ACTIVE\n");\r\nwinnr = (PCMCIA_MEM_WIN_NO * PCMCIA_SOCKETS_NO)\r\n+ (lsock * PCMCIA_IO_WIN_NO) + io->map;\r\nw = (void *)&pcmcia->pcmc_pbr0;\r\nw += winnr;\r\nout_be32(&w->or, 0);\r\nout_be32(&w->br, M8XX_BASE);\r\nreg <<= 27;\r\nreg |= M8XX_PCMCIA_POR_IO | (lsock << 2);\r\nreg |= m8xx_get_speed(io->speed, 1, s->bus_freq);\r\nif (io->flags & MAP_WRPROT)\r\nreg |= M8XX_PCMCIA_POR_WRPROT;\r\nif (io->flags & MAP_16BIT)\r\nreg |= M8XX_PCMCIA_POR_16BIT;\r\nif (io->flags & MAP_ACTIVE)\r\nreg |= M8XX_PCMCIA_POR_VALID;\r\nout_be32(&w->or, reg);\r\npr_debug("m8xx_pcmcia: Socket %u: Mapped io window %u at "\r\n"%#8.8x, OR = %#8.8x.\n", lsock, io->map, w->br, w->or);\r\n} else {\r\nwinnr = (PCMCIA_MEM_WIN_NO * PCMCIA_SOCKETS_NO)\r\n+ (lsock * PCMCIA_IO_WIN_NO) + io->map;\r\nw = (void *)&pcmcia->pcmc_pbr0;\r\nw += winnr;\r\nout_be32(&w->or, 0);\r\nout_be32(&w->br, 0);\r\npr_debug("m8xx_pcmcia: Socket %u: Unmapped io window %u at "\r\n"%#8.8x, OR = %#8.8x.\n", lsock, io->map, w->br, w->or);\r\n}\r\ns->io_win[io->map] = *io;\r\ns->io_win[io->map].flags &= (MAP_WRPROT | MAP_16BIT | MAP_ACTIVE);\r\npr_debug("m8xx_pcmcia: SetIOMap exit\n");\r\nreturn 0;\r\n}\r\nstatic int m8xx_set_mem_map(struct pcmcia_socket *sock,\r\nstruct pccard_mem_map *mem)\r\n{\r\nint lsock = container_of(sock, struct socket_info, socket)->slot;\r\nstruct socket_info *s = &socket[lsock];\r\nstruct pcmcia_win *w;\r\nstruct pccard_mem_map *old;\r\nunsigned int reg, winnr;\r\npcmconf8xx_t *pcmcia = s->pcmcia;\r\npr_debug("m8xx_pcmcia: SetMemMap(%d, %d, %#2.2x, %d ns, "\r\n"%#5.5llx, %#5.5x)\n", lsock, mem->map, mem->flags,\r\nmem->speed, (unsigned long long)mem->static_start,\r\nmem->card_start);\r\nif ((mem->map >= PCMCIA_MEM_WIN_NO)\r\n|| (mem->card_start >= 0x04000000)\r\n|| (mem->static_start & 0xfff)\r\n||(mem->card_start & 0xfff))\r\nreturn -EINVAL;\r\nif ((reg = m8xx_get_graycode(PCMCIA_MEM_WIN_SIZE)) == -1) {\r\nprintk("Cannot set size to 0x%08x.\n", PCMCIA_MEM_WIN_SIZE);\r\nreturn -EINVAL;\r\n}\r\nreg <<= 27;\r\nwinnr = (lsock * PCMCIA_MEM_WIN_NO) + mem->map;\r\nw = (void *)&pcmcia->pcmc_pbr0;\r\nw += winnr;\r\nreg |= lsock << 2;\r\nreg |= m8xx_get_speed(mem->speed, 0, s->bus_freq);\r\nif (mem->flags & MAP_ATTRIB)\r\nreg |= M8XX_PCMCIA_POR_ATTRMEM;\r\nif (mem->flags & MAP_WRPROT)\r\nreg |= M8XX_PCMCIA_POR_WRPROT;\r\nif (mem->flags & MAP_16BIT)\r\nreg |= M8XX_PCMCIA_POR_16BIT;\r\nif (mem->flags & MAP_ACTIVE)\r\nreg |= M8XX_PCMCIA_POR_VALID;\r\nout_be32(&w->or, reg);\r\npr_debug("m8xx_pcmcia: Socket %u: Mapped memory window %u at %#8.8x, "\r\n"OR = %#8.8x.\n", lsock, mem->map, w->br, w->or);\r\nif (mem->flags & MAP_ACTIVE) {\r\nmem->static_start = PCMCIA_MEM_WIN_BASE +\r\n(PCMCIA_MEM_WIN_SIZE * winnr)\r\n+ mem->card_start;\r\n}\r\npr_debug("m8xx_pcmcia: SetMemMap(%d, %d, %#2.2x, %d ns, "\r\n"%#5.5llx, %#5.5x)\n", lsock, mem->map, mem->flags,\r\nmem->speed, (unsigned long long)mem->static_start,\r\nmem->card_start);\r\nold = &s->mem_win[mem->map];\r\n*old = *mem;\r\nold->flags &= (MAP_ATTRIB | MAP_WRPROT | MAP_16BIT | MAP_ACTIVE);\r\nreturn 0;\r\n}\r\nstatic int m8xx_sock_init(struct pcmcia_socket *sock)\r\n{\r\nint i;\r\npccard_io_map io = { 0, 0, 0, 0, 1 };\r\npccard_mem_map mem = { 0, 0, 0, 0, 0, 0 };\r\npr_debug("m8xx_pcmcia: sock_init(%d)\n", s);\r\nm8xx_set_socket(sock, &dead_socket);\r\nfor (i = 0; i < PCMCIA_IO_WIN_NO; i++) {\r\nio.map = i;\r\nm8xx_set_io_map(sock, &io);\r\n}\r\nfor (i = 0; i < PCMCIA_MEM_WIN_NO; i++) {\r\nmem.map = i;\r\nm8xx_set_mem_map(sock, &mem);\r\n}\r\nreturn 0;\r\n}\r\nstatic int m8xx_sock_suspend(struct pcmcia_socket *sock)\r\n{\r\nreturn m8xx_set_socket(sock, &dead_socket);\r\n}\r\nstatic int __init m8xx_probe(struct platform_device *ofdev)\r\n{\r\nstruct pcmcia_win *w;\r\nunsigned int i, m, hwirq;\r\npcmconf8xx_t *pcmcia;\r\nint status;\r\nstruct device_node *np = ofdev->dev.of_node;\r\npcmcia_info("%s\n", version);\r\npcmcia = of_iomap(np, 0);\r\nif (pcmcia == NULL)\r\nreturn -EINVAL;\r\npcmcia_schlvl = irq_of_parse_and_map(np, 0);\r\nhwirq = irq_map[pcmcia_schlvl].hwirq;\r\nif (pcmcia_schlvl < 0) {\r\niounmap(pcmcia);\r\nreturn -EINVAL;\r\n}\r\nm8xx_pgcrx[0] = &pcmcia->pcmc_pgcra;\r\nm8xx_pgcrx[1] = &pcmcia->pcmc_pgcrb;\r\npcmcia_info(PCMCIA_BOARD_MSG " using " PCMCIA_SLOT_MSG\r\n" with IRQ %u (%d). \n", pcmcia_schlvl, hwirq);\r\nif (request_irq(pcmcia_schlvl, m8xx_interrupt, IRQF_SHARED,\r\ndriver_name, socket)) {\r\npcmcia_error("Cannot allocate IRQ %u for SCHLVL!\n",\r\npcmcia_schlvl);\r\niounmap(pcmcia);\r\nreturn -1;\r\n}\r\nw = (void *)&pcmcia->pcmc_pbr0;\r\nout_be32(&pcmcia->pcmc_pscr, M8XX_PCMCIA_MASK(0) | M8XX_PCMCIA_MASK(1));\r\nclrbits32(&pcmcia->pcmc_per, M8XX_PCMCIA_MASK(0) | M8XX_PCMCIA_MASK(1));\r\nout_be32(M8XX_PGCRX(0),\r\nM8XX_PGCRX_CXOE | (mk_int_int_mask(hwirq) << 16));\r\nout_be32(M8XX_PGCRX(1),\r\nM8XX_PGCRX_CXOE | (mk_int_int_mask(hwirq) << 16));\r\nfor (i = 0; i < PCMCIA_SOCKETS_NO; i++) {\r\nfor (m = 0; m < PCMCIA_MEM_WIN_NO; m++) {\r\nout_be32(&w->br, PCMCIA_MEM_WIN_BASE +\r\n(PCMCIA_MEM_WIN_SIZE\r\n* (m + i * PCMCIA_MEM_WIN_NO)));\r\nout_be32(&w->or, 0);\r\nw++;\r\n}\r\n}\r\nvoltage_set(0, 0, 0);\r\nvoltage_set(1, 0, 0);\r\nhardware_enable(0);\r\nhardware_enable(1);\r\nfor (i = 0; i < PCMCIA_SOCKETS_NO; i++) {\r\nsocket[i].slot = i;\r\nsocket[i].socket.owner = THIS_MODULE;\r\nsocket[i].socket.features =\r\nSS_CAP_PCCARD | SS_CAP_MEM_ALIGN | SS_CAP_STATIC_MAP;\r\nsocket[i].socket.irq_mask = 0x000;\r\nsocket[i].socket.map_size = 0x1000;\r\nsocket[i].socket.io_offset = 0;\r\nsocket[i].socket.pci_irq = pcmcia_schlvl;\r\nsocket[i].socket.ops = &m8xx_services;\r\nsocket[i].socket.resource_ops = &pccard_iodyn_ops;\r\nsocket[i].socket.cb_dev = NULL;\r\nsocket[i].socket.dev.parent = &ofdev->dev;\r\nsocket[i].pcmcia = pcmcia;\r\nsocket[i].bus_freq = ppc_proc_freq;\r\nsocket[i].hwirq = hwirq;\r\n}\r\nfor (i = 0; i < PCMCIA_SOCKETS_NO; i++) {\r\nstatus = pcmcia_register_socket(&socket[i].socket);\r\nif (status < 0)\r\npcmcia_error("Socket register failed\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int m8xx_remove(struct platform_device *ofdev)\r\n{\r\nu32 m, i;\r\nstruct pcmcia_win *w;\r\npcmconf8xx_t *pcmcia = socket[0].pcmcia;\r\nfor (i = 0; i < PCMCIA_SOCKETS_NO; i++) {\r\nw = (void *)&pcmcia->pcmc_pbr0;\r\nout_be32(&pcmcia->pcmc_pscr, M8XX_PCMCIA_MASK(i));\r\nout_be32(&pcmcia->pcmc_per,\r\nin_be32(&pcmcia->pcmc_per) & ~M8XX_PCMCIA_MASK(i));\r\nout_be32(M8XX_PGCRX(i), M8XX_PGCRX_CXOE);\r\nfor (m = 0; m < PCMCIA_MEM_WIN_NO; m++) {\r\nout_be32(&w->or, 0);\r\nw++;\r\n}\r\nvoltage_set(i, 0, 0);\r\nhardware_disable(i);\r\n}\r\nfor (i = 0; i < PCMCIA_SOCKETS_NO; i++)\r\npcmcia_unregister_socket(&socket[i].socket);\r\niounmap(pcmcia);\r\nfree_irq(pcmcia_schlvl, NULL);\r\nreturn 0;\r\n}
