static int int51x1_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nint len;\r\nif (!(pskb_may_pull(skb, INT51X1_HEADER_SIZE))) {\r\nnetdev_err(dev->net, "unexpected tiny rx frame\n");\r\nreturn 0;\r\n}\r\nlen = le16_to_cpu(*(__le16 *)&skb->data[skb->len - 2]);\r\nskb_trim(skb, len);\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *int51x1_tx_fixup(struct usbnet *dev,\r\nstruct sk_buff *skb, gfp_t flags)\r\n{\r\nint pack_len = skb->len;\r\nint pack_with_header_len = pack_len + INT51X1_HEADER_SIZE;\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nint need_tail = 0;\r\n__le16 *len;\r\nif ((pack_with_header_len) < dev->maxpacket)\r\nneed_tail = dev->maxpacket - pack_with_header_len + 1;\r\nelse if (!(pack_with_header_len % dev->maxpacket))\r\nneed_tail = 1;\r\nif (!skb_cloned(skb) &&\r\n(headroom + tailroom >= need_tail + INT51X1_HEADER_SIZE)) {\r\nif (headroom < INT51X1_HEADER_SIZE || tailroom < need_tail) {\r\nskb->data = memmove(skb->head + INT51X1_HEADER_SIZE,\r\nskb->data, skb->len);\r\nskb_set_tail_pointer(skb, skb->len);\r\n}\r\n} else {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_copy_expand(skb,\r\nINT51X1_HEADER_SIZE,\r\nneed_tail,\r\nflags);\r\ndev_kfree_skb_any(skb);\r\nif (!skb2)\r\nreturn NULL;\r\nskb = skb2;\r\n}\r\npack_len += need_tail;\r\npack_len &= 0x07ff;\r\nlen = (__le16 *) __skb_push(skb, INT51X1_HEADER_SIZE);\r\n*len = cpu_to_le16(pack_len);\r\nif(need_tail)\r\nmemset(__skb_put(skb, need_tail), 0, need_tail);\r\nreturn skb;\r\n}\r\nstatic void int51x1_async_cmd_callback(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;\r\nint status = urb->status;\r\nif (status < 0)\r\ndev_warn(&urb->dev->dev, "async callback failed with %d\n", status);\r\nkfree(req);\r\nusb_free_urb(urb);\r\n}\r\nstatic void int51x1_set_multicast(struct net_device *netdev)\r\n{\r\nstruct usb_ctrlrequest *req;\r\nint status;\r\nstruct urb *urb;\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nu16 filter = PACKET_TYPE_DIRECTED | PACKET_TYPE_BROADCAST;\r\nif (netdev->flags & IFF_PROMISC) {\r\nfilter |= PACKET_TYPE_PROMISCUOUS;\r\nnetdev_info(dev->net, "promiscuous mode enabled\n");\r\n} else if (!netdev_mc_empty(netdev) ||\r\n(netdev->flags & IFF_ALLMULTI)) {\r\nfilter |= PACKET_TYPE_ALL_MULTICAST;\r\nnetdev_dbg(dev->net, "receive all multicast enabled\n");\r\n} else {\r\nnetdev_dbg(dev->net, "receive own packets only\n");\r\n}\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_warn(dev->net, "Error allocating URB\n");\r\nreturn;\r\n}\r\nreq = kmalloc(sizeof(*req), GFP_ATOMIC);\r\nif (!req) {\r\nnetdev_warn(dev->net, "Error allocating control msg\n");\r\ngoto out;\r\n}\r\nreq->bRequestType = USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE;\r\nreq->bRequest = SET_ETHERNET_PACKET_FILTER;\r\nreq->wValue = cpu_to_le16(filter);\r\nreq->wIndex = 0;\r\nreq->wLength = 0;\r\nusb_fill_control_urb(urb, dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\n(void *)req, NULL, 0,\r\nint51x1_async_cmd_callback,\r\n(void *)req);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status < 0) {\r\nnetdev_warn(dev->net, "Error submitting control msg, sts=%d\n",\r\nstatus);\r\ngoto out1;\r\n}\r\nreturn;\r\nout1:\r\nkfree(req);\r\nout:\r\nusb_free_urb(urb);\r\n}\r\nstatic int int51x1_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint status = usbnet_get_ethernet_addr(dev, 3);\r\nif (status)\r\nreturn status;\r\ndev->net->hard_header_len += INT51X1_HEADER_SIZE;\r\ndev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\r\ndev->net->netdev_ops = &int51x1_netdev_ops;\r\nreturn usbnet_get_endpoints(dev, intf);\r\n}
