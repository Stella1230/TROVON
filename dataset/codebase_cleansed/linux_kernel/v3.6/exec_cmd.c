const char *system_path(const char *path)\r\n{\r\nstatic const char *prefix = PREFIX;\r\nstruct strbuf d = STRBUF_INIT;\r\nif (is_absolute_path(path))\r\nreturn path;\r\nstrbuf_addf(&d, "%s/%s", prefix, path);\r\npath = strbuf_detach(&d, NULL);\r\nreturn path;\r\n}\r\nconst char *perf_extract_argv0_path(const char *argv0)\r\n{\r\nconst char *slash;\r\nif (!argv0 || !*argv0)\r\nreturn NULL;\r\nslash = argv0 + strlen(argv0);\r\nwhile (argv0 <= slash && !is_dir_sep(*slash))\r\nslash--;\r\nif (slash >= argv0) {\r\nargv0_path = strndup(argv0, slash - argv0);\r\nreturn argv0_path ? slash + 1 : NULL;\r\n}\r\nreturn argv0;\r\n}\r\nvoid perf_set_argv_exec_path(const char *exec_path)\r\n{\r\nargv_exec_path = exec_path;\r\nsetenv(EXEC_PATH_ENVIRONMENT, exec_path, 1);\r\n}\r\nconst char *perf_exec_path(void)\r\n{\r\nconst char *env;\r\nif (argv_exec_path)\r\nreturn argv_exec_path;\r\nenv = getenv(EXEC_PATH_ENVIRONMENT);\r\nif (env && *env) {\r\nreturn env;\r\n}\r\nreturn system_path(PERF_EXEC_PATH);\r\n}\r\nstatic void add_path(struct strbuf *out, const char *path)\r\n{\r\nif (path && *path) {\r\nif (is_absolute_path(path))\r\nstrbuf_addstr(out, path);\r\nelse\r\nstrbuf_addstr(out, make_nonrelative_path(path));\r\nstrbuf_addch(out, PATH_SEP);\r\n}\r\n}\r\nvoid setup_path(void)\r\n{\r\nconst char *old_path = getenv("PATH");\r\nstruct strbuf new_path = STRBUF_INIT;\r\nadd_path(&new_path, perf_exec_path());\r\nadd_path(&new_path, argv0_path);\r\nif (old_path)\r\nstrbuf_addstr(&new_path, old_path);\r\nelse\r\nstrbuf_addstr(&new_path, "/usr/local/bin:/usr/bin:/bin");\r\nsetenv("PATH", new_path.buf, 1);\r\nstrbuf_release(&new_path);\r\n}\r\nstatic const char **prepare_perf_cmd(const char **argv)\r\n{\r\nint argc;\r\nconst char **nargv;\r\nfor (argc = 0; argv[argc]; argc++)\r\n;\r\nnargv = malloc(sizeof(*nargv) * (argc + 2));\r\nnargv[0] = "perf";\r\nfor (argc = 0; argv[argc]; argc++)\r\nnargv[argc + 1] = argv[argc];\r\nnargv[argc + 1] = NULL;\r\nreturn nargv;\r\n}\r\nint execv_perf_cmd(const char **argv) {\r\nconst char **nargv = prepare_perf_cmd(argv);\r\nexecvp("perf", (char **)nargv);\r\nfree(nargv);\r\nreturn -1;\r\n}\r\nint execl_perf_cmd(const char *cmd,...)\r\n{\r\nint argc;\r\nconst char *argv[MAX_ARGS + 1];\r\nconst char *arg;\r\nva_list param;\r\nva_start(param, cmd);\r\nargv[0] = cmd;\r\nargc = 1;\r\nwhile (argc < MAX_ARGS) {\r\narg = argv[argc++] = va_arg(param, char *);\r\nif (!arg)\r\nbreak;\r\n}\r\nva_end(param);\r\nif (MAX_ARGS <= argc)\r\nreturn error("too many args to run %s", cmd);\r\nargv[argc] = NULL;\r\nreturn execv_perf_cmd(argv);\r\n}
