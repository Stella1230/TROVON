static u32\r\nnouveau_ramht_hash_handle(struct nouveau_channel *chan, u32 handle)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_ramht *ramht = chan->ramht;\r\nu32 hash = 0;\r\nint i;\r\nNV_DEBUG(dev, "ch%d handle=0x%08x\n", chan->id, handle);\r\nfor (i = 32; i > 0; i -= ramht->bits) {\r\nhash ^= (handle & ((1 << ramht->bits) - 1));\r\nhandle >>= ramht->bits;\r\n}\r\nif (dev_priv->card_type < NV_50)\r\nhash ^= chan->id << (ramht->bits - 4);\r\nhash <<= 3;\r\nNV_DEBUG(dev, "hash=0x%08x\n", hash);\r\nreturn hash;\r\n}\r\nstatic int\r\nnouveau_ramht_entry_valid(struct drm_device *dev, struct nouveau_gpuobj *ramht,\r\nu32 offset)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 ctx = nv_ro32(ramht, offset + 4);\r\nif (dev_priv->card_type < NV_40)\r\nreturn ((ctx & NV_RAMHT_CONTEXT_VALID) != 0);\r\nreturn (ctx != 0);\r\n}\r\nstatic int\r\nnouveau_ramht_entry_same_channel(struct nouveau_channel *chan,\r\nstruct nouveau_gpuobj *ramht, u32 offset)\r\n{\r\nstruct drm_nouveau_private *dev_priv = chan->dev->dev_private;\r\nu32 ctx = nv_ro32(ramht, offset + 4);\r\nif (dev_priv->card_type >= NV_50)\r\nreturn true;\r\nelse if (dev_priv->card_type >= NV_40)\r\nreturn chan->id ==\r\n((ctx >> NV40_RAMHT_CONTEXT_CHANNEL_SHIFT) & 0x1f);\r\nelse\r\nreturn chan->id ==\r\n((ctx >> NV_RAMHT_CONTEXT_CHANNEL_SHIFT) & 0x1f);\r\n}\r\nint\r\nnouveau_ramht_insert(struct nouveau_channel *chan, u32 handle,\r\nstruct nouveau_gpuobj *gpuobj)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_instmem_engine *instmem = &dev_priv->engine.instmem;\r\nstruct nouveau_ramht_entry *entry;\r\nstruct nouveau_gpuobj *ramht = chan->ramht->gpuobj;\r\nunsigned long flags;\r\nu32 ctx, co, ho;\r\nif (nouveau_ramht_find(chan, handle))\r\nreturn -EEXIST;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->channel = chan;\r\nentry->gpuobj = NULL;\r\nentry->handle = handle;\r\nnouveau_gpuobj_ref(gpuobj, &entry->gpuobj);\r\nif (dev_priv->card_type < NV_40) {\r\nctx = NV_RAMHT_CONTEXT_VALID | (gpuobj->pinst >> 4) |\r\n(chan->id << NV_RAMHT_CONTEXT_CHANNEL_SHIFT) |\r\n(gpuobj->engine << NV_RAMHT_CONTEXT_ENGINE_SHIFT);\r\n} else\r\nif (dev_priv->card_type < NV_50) {\r\nctx = (gpuobj->pinst >> 4) |\r\n(chan->id << NV40_RAMHT_CONTEXT_CHANNEL_SHIFT) |\r\n(gpuobj->engine << NV40_RAMHT_CONTEXT_ENGINE_SHIFT);\r\n} else {\r\nif (gpuobj->engine == NVOBJ_ENGINE_DISPLAY) {\r\nctx = (gpuobj->cinst << 10) |\r\n(chan->id << 28) |\r\nchan->id;\r\n} else {\r\nctx = (gpuobj->cinst >> 4) |\r\n((gpuobj->engine <<\r\nNV40_RAMHT_CONTEXT_ENGINE_SHIFT));\r\n}\r\n}\r\nspin_lock_irqsave(&chan->ramht->lock, flags);\r\nlist_add(&entry->head, &chan->ramht->entries);\r\nco = ho = nouveau_ramht_hash_handle(chan, handle);\r\ndo {\r\nif (!nouveau_ramht_entry_valid(dev, ramht, co)) {\r\nNV_DEBUG(dev,\r\n"insert ch%d 0x%08x: h=0x%08x, c=0x%08x\n",\r\nchan->id, co, handle, ctx);\r\nnv_wo32(ramht, co + 0, handle);\r\nnv_wo32(ramht, co + 4, ctx);\r\nspin_unlock_irqrestore(&chan->ramht->lock, flags);\r\ninstmem->flush(dev);\r\nreturn 0;\r\n}\r\nNV_DEBUG(dev, "collision ch%d 0x%08x: h=0x%08x\n",\r\nchan->id, co, nv_ro32(ramht, co));\r\nco += 8;\r\nif (co >= ramht->size)\r\nco = 0;\r\n} while (co != ho);\r\nNV_ERROR(dev, "RAMHT space exhausted. ch=%d\n", chan->id);\r\nlist_del(&entry->head);\r\nspin_unlock_irqrestore(&chan->ramht->lock, flags);\r\nkfree(entry);\r\nreturn -ENOMEM;\r\n}\r\nstatic struct nouveau_ramht_entry *\r\nnouveau_ramht_remove_entry(struct nouveau_channel *chan, u32 handle)\r\n{\r\nstruct nouveau_ramht *ramht = chan ? chan->ramht : NULL;\r\nstruct nouveau_ramht_entry *entry;\r\nunsigned long flags;\r\nif (!ramht)\r\nreturn NULL;\r\nspin_lock_irqsave(&ramht->lock, flags);\r\nlist_for_each_entry(entry, &ramht->entries, head) {\r\nif (entry->channel == chan &&\r\n(!handle || entry->handle == handle)) {\r\nlist_del(&entry->head);\r\nspin_unlock_irqrestore(&ramht->lock, flags);\r\nreturn entry;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ramht->lock, flags);\r\nreturn NULL;\r\n}\r\nstatic void\r\nnouveau_ramht_remove_hash(struct nouveau_channel *chan, u32 handle)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_instmem_engine *instmem = &dev_priv->engine.instmem;\r\nstruct nouveau_gpuobj *ramht = chan->ramht->gpuobj;\r\nunsigned long flags;\r\nu32 co, ho;\r\nspin_lock_irqsave(&chan->ramht->lock, flags);\r\nco = ho = nouveau_ramht_hash_handle(chan, handle);\r\ndo {\r\nif (nouveau_ramht_entry_valid(dev, ramht, co) &&\r\nnouveau_ramht_entry_same_channel(chan, ramht, co) &&\r\n(handle == nv_ro32(ramht, co))) {\r\nNV_DEBUG(dev,\r\n"remove ch%d 0x%08x: h=0x%08x, c=0x%08x\n",\r\nchan->id, co, handle, nv_ro32(ramht, co + 4));\r\nnv_wo32(ramht, co + 0, 0x00000000);\r\nnv_wo32(ramht, co + 4, 0x00000000);\r\ninstmem->flush(dev);\r\ngoto out;\r\n}\r\nco += 8;\r\nif (co >= ramht->size)\r\nco = 0;\r\n} while (co != ho);\r\nNV_ERROR(dev, "RAMHT entry not found. ch=%d, handle=0x%08x\n",\r\nchan->id, handle);\r\nout:\r\nspin_unlock_irqrestore(&chan->ramht->lock, flags);\r\n}\r\nint\r\nnouveau_ramht_remove(struct nouveau_channel *chan, u32 handle)\r\n{\r\nstruct nouveau_ramht_entry *entry;\r\nentry = nouveau_ramht_remove_entry(chan, handle);\r\nif (!entry)\r\nreturn -ENOENT;\r\nnouveau_ramht_remove_hash(chan, entry->handle);\r\nnouveau_gpuobj_ref(NULL, &entry->gpuobj);\r\nkfree(entry);\r\nreturn 0;\r\n}\r\nstruct nouveau_gpuobj *\r\nnouveau_ramht_find(struct nouveau_channel *chan, u32 handle)\r\n{\r\nstruct nouveau_ramht *ramht = chan->ramht;\r\nstruct nouveau_ramht_entry *entry;\r\nstruct nouveau_gpuobj *gpuobj = NULL;\r\nunsigned long flags;\r\nif (unlikely(!chan->ramht))\r\nreturn NULL;\r\nspin_lock_irqsave(&ramht->lock, flags);\r\nlist_for_each_entry(entry, &chan->ramht->entries, head) {\r\nif (entry->channel == chan && entry->handle == handle) {\r\ngpuobj = entry->gpuobj;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ramht->lock, flags);\r\nreturn gpuobj;\r\n}\r\nint\r\nnouveau_ramht_new(struct drm_device *dev, struct nouveau_gpuobj *gpuobj,\r\nstruct nouveau_ramht **pramht)\r\n{\r\nstruct nouveau_ramht *ramht;\r\nramht = kzalloc(sizeof(*ramht), GFP_KERNEL);\r\nif (!ramht)\r\nreturn -ENOMEM;\r\nramht->dev = dev;\r\nkref_init(&ramht->refcount);\r\nramht->bits = drm_order(gpuobj->size / 8);\r\nINIT_LIST_HEAD(&ramht->entries);\r\nspin_lock_init(&ramht->lock);\r\nnouveau_gpuobj_ref(gpuobj, &ramht->gpuobj);\r\n*pramht = ramht;\r\nreturn 0;\r\n}\r\nstatic void\r\nnouveau_ramht_del(struct kref *ref)\r\n{\r\nstruct nouveau_ramht *ramht =\r\ncontainer_of(ref, struct nouveau_ramht, refcount);\r\nnouveau_gpuobj_ref(NULL, &ramht->gpuobj);\r\nkfree(ramht);\r\n}\r\nvoid\r\nnouveau_ramht_ref(struct nouveau_ramht *ref, struct nouveau_ramht **ptr,\r\nstruct nouveau_channel *chan)\r\n{\r\nstruct nouveau_ramht_entry *entry;\r\nstruct nouveau_ramht *ramht;\r\nif (ref)\r\nkref_get(&ref->refcount);\r\nramht = *ptr;\r\nif (ramht) {\r\nwhile ((entry = nouveau_ramht_remove_entry(chan, 0))) {\r\nnouveau_ramht_remove_hash(chan, entry->handle);\r\nnouveau_gpuobj_ref(NULL, &entry->gpuobj);\r\nkfree(entry);\r\n}\r\nkref_put(&ramht->refcount, nouveau_ramht_del);\r\n}\r\n*ptr = ref;\r\n}
