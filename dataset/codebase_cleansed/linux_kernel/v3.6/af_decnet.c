static struct hlist_head *dn_find_list(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (scp->addr.sdn_flags & SDF_WILD)\r\nreturn hlist_empty(&dn_wild_sk) ? &dn_wild_sk : NULL;\r\nreturn &dn_sk_hash[le16_to_cpu(scp->addrloc) & DN_SK_HASH_MASK];\r\n}\r\nstatic int check_port(__le16 port)\r\n{\r\nstruct sock *sk;\r\nstruct hlist_node *node;\r\nif (port == 0)\r\nreturn -1;\r\nsk_for_each(sk, node, &dn_sk_hash[le16_to_cpu(port) & DN_SK_HASH_MASK]) {\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (scp->addrloc == port)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned short port_alloc(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstatic unsigned short port = 0x2000;\r\nunsigned short i_port = port;\r\nwhile(check_port(cpu_to_le16(++port)) != 0) {\r\nif (port == i_port)\r\nreturn 0;\r\n}\r\nscp->addrloc = cpu_to_le16(port);\r\nreturn 1;\r\n}\r\nstatic int dn_hash_sock(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct hlist_head *list;\r\nint rv = -EUSERS;\r\nBUG_ON(sk_hashed(sk));\r\nwrite_lock_bh(&dn_hash_lock);\r\nif (!scp->addrloc && !port_alloc(sk))\r\ngoto out;\r\nrv = -EADDRINUSE;\r\nif ((list = dn_find_list(sk)) == NULL)\r\ngoto out;\r\nsk_add_node(sk, list);\r\nrv = 0;\r\nout:\r\nwrite_unlock_bh(&dn_hash_lock);\r\nreturn rv;\r\n}\r\nstatic void dn_unhash_sock(struct sock *sk)\r\n{\r\nwrite_lock(&dn_hash_lock);\r\nsk_del_node_init(sk);\r\nwrite_unlock(&dn_hash_lock);\r\n}\r\nstatic void dn_unhash_sock_bh(struct sock *sk)\r\n{\r\nwrite_lock_bh(&dn_hash_lock);\r\nsk_del_node_init(sk);\r\nwrite_unlock_bh(&dn_hash_lock);\r\n}\r\nstatic struct hlist_head *listen_hash(struct sockaddr_dn *addr)\r\n{\r\nint i;\r\nunsigned int hash = addr->sdn_objnum;\r\nif (hash == 0) {\r\nhash = addr->sdn_objnamel;\r\nfor(i = 0; i < le16_to_cpu(addr->sdn_objnamel); i++) {\r\nhash ^= addr->sdn_objname[i];\r\nhash ^= (hash << 3);\r\n}\r\n}\r\nreturn &dn_sk_hash[hash & DN_SK_HASH_MASK];\r\n}\r\nstatic void dn_rehash_sock(struct sock *sk)\r\n{\r\nstruct hlist_head *list;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (scp->addr.sdn_flags & SDF_WILD)\r\nreturn;\r\nwrite_lock_bh(&dn_hash_lock);\r\nsk_del_node_init(sk);\r\nDN_SK(sk)->addrloc = 0;\r\nlist = listen_hash(&DN_SK(sk)->addr);\r\nsk_add_node(sk, list);\r\nwrite_unlock_bh(&dn_hash_lock);\r\n}\r\nint dn_sockaddr2username(struct sockaddr_dn *sdn, unsigned char *buf, unsigned char type)\r\n{\r\nint len = 2;\r\n*buf++ = type;\r\nswitch (type) {\r\ncase 0:\r\n*buf++ = sdn->sdn_objnum;\r\nbreak;\r\ncase 1:\r\n*buf++ = 0;\r\n*buf++ = le16_to_cpu(sdn->sdn_objnamel);\r\nmemcpy(buf, sdn->sdn_objname, le16_to_cpu(sdn->sdn_objnamel));\r\nlen = 3 + le16_to_cpu(sdn->sdn_objnamel);\r\nbreak;\r\ncase 2:\r\nmemset(buf, 0, 5);\r\nbuf += 5;\r\n*buf++ = le16_to_cpu(sdn->sdn_objnamel);\r\nmemcpy(buf, sdn->sdn_objname, le16_to_cpu(sdn->sdn_objnamel));\r\nlen = 7 + le16_to_cpu(sdn->sdn_objnamel);\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nint dn_username2sockaddr(unsigned char *data, int len, struct sockaddr_dn *sdn, unsigned char *fmt)\r\n{\r\nunsigned char type;\r\nint size = len;\r\nint namel = 12;\r\nsdn->sdn_objnum = 0;\r\nsdn->sdn_objnamel = cpu_to_le16(0);\r\nmemset(sdn->sdn_objname, 0, DN_MAXOBJL);\r\nif (len < 2)\r\nreturn -1;\r\nlen -= 2;\r\n*fmt = *data++;\r\ntype = *data++;\r\nswitch (*fmt) {\r\ncase 0:\r\nsdn->sdn_objnum = type;\r\nreturn 2;\r\ncase 1:\r\nnamel = 16;\r\nbreak;\r\ncase 2:\r\nlen -= 4;\r\ndata += 4;\r\nbreak;\r\ncase 4:\r\nlen -= 8;\r\ndata += 8;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nlen -= 1;\r\nif (len < 0)\r\nreturn -1;\r\nsdn->sdn_objnamel = cpu_to_le16(*data++);\r\nlen -= le16_to_cpu(sdn->sdn_objnamel);\r\nif ((len < 0) || (le16_to_cpu(sdn->sdn_objnamel) > namel))\r\nreturn -1;\r\nmemcpy(sdn->sdn_objname, data, le16_to_cpu(sdn->sdn_objnamel));\r\nreturn size - len;\r\n}\r\nstruct sock *dn_sklist_find_listener(struct sockaddr_dn *addr)\r\n{\r\nstruct hlist_head *list = listen_hash(addr);\r\nstruct hlist_node *node;\r\nstruct sock *sk;\r\nread_lock(&dn_hash_lock);\r\nsk_for_each(sk, node, list) {\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (sk->sk_state != TCP_LISTEN)\r\ncontinue;\r\nif (scp->addr.sdn_objnum) {\r\nif (scp->addr.sdn_objnum != addr->sdn_objnum)\r\ncontinue;\r\n} else {\r\nif (addr->sdn_objnum)\r\ncontinue;\r\nif (scp->addr.sdn_objnamel != addr->sdn_objnamel)\r\ncontinue;\r\nif (memcmp(scp->addr.sdn_objname, addr->sdn_objname, le16_to_cpu(addr->sdn_objnamel)) != 0)\r\ncontinue;\r\n}\r\nsock_hold(sk);\r\nread_unlock(&dn_hash_lock);\r\nreturn sk;\r\n}\r\nsk = sk_head(&dn_wild_sk);\r\nif (sk) {\r\nif (sk->sk_state == TCP_LISTEN)\r\nsock_hold(sk);\r\nelse\r\nsk = NULL;\r\n}\r\nread_unlock(&dn_hash_lock);\r\nreturn sk;\r\n}\r\nstruct sock *dn_find_by_skb(struct sk_buff *skb)\r\n{\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nstruct sock *sk;\r\nstruct hlist_node *node;\r\nstruct dn_scp *scp;\r\nread_lock(&dn_hash_lock);\r\nsk_for_each(sk, node, &dn_sk_hash[le16_to_cpu(cb->dst_port) & DN_SK_HASH_MASK]) {\r\nscp = DN_SK(sk);\r\nif (cb->src != dn_saddr2dn(&scp->peer))\r\ncontinue;\r\nif (cb->dst_port != scp->addrloc)\r\ncontinue;\r\nif (scp->addrrem && (cb->src_port != scp->addrrem))\r\ncontinue;\r\nsock_hold(sk);\r\ngoto found;\r\n}\r\nsk = NULL;\r\nfound:\r\nread_unlock(&dn_hash_lock);\r\nreturn sk;\r\n}\r\nstatic void dn_destruct(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nskb_queue_purge(&scp->data_xmit_queue);\r\nskb_queue_purge(&scp->other_xmit_queue);\r\nskb_queue_purge(&scp->other_receive_queue);\r\ndst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\r\n}\r\nstatic void dn_enter_memory_pressure(struct sock *sk)\r\n{\r\nif (!dn_memory_pressure) {\r\ndn_memory_pressure = 1;\r\n}\r\n}\r\nstatic struct sock *dn_alloc_sock(struct net *net, struct socket *sock, gfp_t gfp)\r\n{\r\nstruct dn_scp *scp;\r\nstruct sock *sk = sk_alloc(net, PF_DECnet, gfp, &dn_proto);\r\nif (!sk)\r\ngoto out;\r\nif (sock)\r\nsock->ops = &dn_proto_ops;\r\nsock_init_data(sock, sk);\r\nsk->sk_backlog_rcv = dn_nsp_backlog_rcv;\r\nsk->sk_destruct = dn_destruct;\r\nsk->sk_no_check = 1;\r\nsk->sk_family = PF_DECnet;\r\nsk->sk_protocol = 0;\r\nsk->sk_allocation = gfp;\r\nsk->sk_sndbuf = sysctl_decnet_wmem[1];\r\nsk->sk_rcvbuf = sysctl_decnet_rmem[1];\r\nscp = DN_SK(sk);\r\nscp->state = DN_O;\r\nscp->numdat = 1;\r\nscp->numoth = 1;\r\nscp->ackxmt_dat = 0;\r\nscp->ackxmt_oth = 0;\r\nscp->ackrcv_dat = 0;\r\nscp->ackrcv_oth = 0;\r\nscp->flowrem_sw = DN_SEND;\r\nscp->flowloc_sw = DN_SEND;\r\nscp->flowrem_dat = 0;\r\nscp->flowrem_oth = 1;\r\nscp->flowloc_dat = 0;\r\nscp->flowloc_oth = 1;\r\nscp->services_rem = 0;\r\nscp->services_loc = 1 | NSP_FC_NONE;\r\nscp->info_rem = 0;\r\nscp->info_loc = 0x03;\r\nscp->segsize_rem = 230 - DN_MAX_NSP_DATA_HEADER;\r\nscp->nonagle = 0;\r\nscp->multi_ireq = 1;\r\nscp->accept_mode = ACC_IMMED;\r\nscp->addr.sdn_family = AF_DECnet;\r\nscp->peer.sdn_family = AF_DECnet;\r\nscp->accessdata.acc_accl = 5;\r\nmemcpy(scp->accessdata.acc_acc, "LINUX", 5);\r\nscp->max_window = NSP_MAX_WINDOW;\r\nscp->snd_window = NSP_MIN_WINDOW;\r\nscp->nsp_srtt = NSP_INITIAL_SRTT;\r\nscp->nsp_rttvar = NSP_INITIAL_RTTVAR;\r\nscp->nsp_rxtshift = 0;\r\nskb_queue_head_init(&scp->data_xmit_queue);\r\nskb_queue_head_init(&scp->other_xmit_queue);\r\nskb_queue_head_init(&scp->other_receive_queue);\r\nscp->persist = 0;\r\nscp->persist_fxn = NULL;\r\nscp->keepalive = 10 * HZ;\r\nscp->keepalive_fxn = dn_keepalive;\r\ninit_timer(&scp->delack_timer);\r\nscp->delack_pending = 0;\r\nscp->delack_fxn = dn_nsp_delayed_ack;\r\ndn_start_slow_timer(sk);\r\nout:\r\nreturn sk;\r\n}\r\nstatic void dn_keepalive(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nif (skb_queue_empty(&scp->other_xmit_queue))\r\ndn_nsp_send_link(sk, DN_NOCHANGE, 0);\r\n}\r\nint dn_destroy_timer(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nscp->persist = dn_nsp_persist(sk);\r\nswitch (scp->state) {\r\ncase DN_DI:\r\ndn_nsp_send_disc(sk, NSP_DISCINIT, 0, GFP_ATOMIC);\r\nif (scp->nsp_rxtshift >= decnet_di_count)\r\nscp->state = DN_CN;\r\nreturn 0;\r\ncase DN_DR:\r\ndn_nsp_send_disc(sk, NSP_DISCINIT, 0, GFP_ATOMIC);\r\nif (scp->nsp_rxtshift >= decnet_dr_count)\r\nscp->state = DN_DRC;\r\nreturn 0;\r\ncase DN_DN:\r\nif (scp->nsp_rxtshift < decnet_dn_count) {\r\ndn_nsp_send_disc(sk, NSP_DISCCONF, NSP_REASON_DC,\r\nGFP_ATOMIC);\r\nreturn 0;\r\n}\r\n}\r\nscp->persist = (HZ * decnet_time_wait);\r\nif (sk->sk_socket)\r\nreturn 0;\r\nif ((jiffies - scp->stamp) >= (HZ * decnet_time_wait)) {\r\ndn_unhash_sock(sk);\r\nsock_put(sk);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dn_destroy_sock(struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nscp->nsp_rxtshift = 0;\r\nif (sk->sk_socket) {\r\nif (sk->sk_socket->state != SS_UNCONNECTED)\r\nsk->sk_socket->state = SS_DISCONNECTING;\r\n}\r\nsk->sk_state = TCP_CLOSE;\r\nswitch (scp->state) {\r\ncase DN_DN:\r\ndn_nsp_send_disc(sk, NSP_DISCCONF, NSP_REASON_DC,\r\nsk->sk_allocation);\r\nscp->persist_fxn = dn_destroy_timer;\r\nscp->persist = dn_nsp_persist(sk);\r\nbreak;\r\ncase DN_CR:\r\nscp->state = DN_DR;\r\ngoto disc_reject;\r\ncase DN_RUN:\r\nscp->state = DN_DI;\r\ncase DN_DI:\r\ncase DN_DR:\r\ndisc_reject:\r\ndn_nsp_send_disc(sk, NSP_DISCINIT, 0, sk->sk_allocation);\r\ncase DN_NC:\r\ncase DN_NR:\r\ncase DN_RJ:\r\ncase DN_DIC:\r\ncase DN_CN:\r\ncase DN_DRC:\r\ncase DN_CI:\r\ncase DN_CD:\r\nscp->persist_fxn = dn_destroy_timer;\r\nscp->persist = dn_nsp_persist(sk);\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "DECnet: dn_destroy_sock passed socket in invalid state\n");\r\ncase DN_O:\r\ndn_stop_slow_timer(sk);\r\ndn_unhash_sock_bh(sk);\r\nsock_put(sk);\r\nbreak;\r\n}\r\n}\r\nchar *dn_addr2asc(__u16 addr, char *buf)\r\n{\r\nunsigned short node, area;\r\nnode = addr & 0x03ff;\r\narea = addr >> 10;\r\nsprintf(buf, "%hd.%hd", area, node);\r\nreturn buf;\r\n}\r\nstatic int dn_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nswitch (sock->type) {\r\ncase SOCK_SEQPACKET:\r\nif (protocol != DNPROTO_NSP)\r\nreturn -EPROTONOSUPPORT;\r\nbreak;\r\ncase SOCK_STREAM:\r\nbreak;\r\ndefault:\r\nreturn -ESOCKTNOSUPPORT;\r\n}\r\nif ((sk = dn_alloc_sock(net, sock, GFP_KERNEL)) == NULL)\r\nreturn -ENOBUFS;\r\nsk->sk_protocol = protocol;\r\nreturn 0;\r\n}\r\nstatic int\r\ndn_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk) {\r\nsock_orphan(sk);\r\nsock_hold(sk);\r\nlock_sock(sk);\r\ndn_destroy_sock(sk);\r\nrelease_sock(sk);\r\nsock_put(sk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dn_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct sockaddr_dn *saddr = (struct sockaddr_dn *)uaddr;\r\nstruct net_device *dev, *ldev;\r\nint rv;\r\nif (addr_len != sizeof(struct sockaddr_dn))\r\nreturn -EINVAL;\r\nif (saddr->sdn_family != AF_DECnet)\r\nreturn -EINVAL;\r\nif (le16_to_cpu(saddr->sdn_nodeaddrl) && (le16_to_cpu(saddr->sdn_nodeaddrl) != 2))\r\nreturn -EINVAL;\r\nif (le16_to_cpu(saddr->sdn_objnamel) > DN_MAXOBJL)\r\nreturn -EINVAL;\r\nif (saddr->sdn_flags & ~SDF_WILD)\r\nreturn -EINVAL;\r\nif (!capable(CAP_NET_BIND_SERVICE) && (saddr->sdn_objnum ||\r\n(saddr->sdn_flags & SDF_WILD)))\r\nreturn -EACCES;\r\nif (!(saddr->sdn_flags & SDF_WILD)) {\r\nif (le16_to_cpu(saddr->sdn_nodeaddrl)) {\r\nrcu_read_lock();\r\nldev = NULL;\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif (!dev->dn_ptr)\r\ncontinue;\r\nif (dn_dev_islocal(dev, dn_saddr2dn(saddr))) {\r\nldev = dev;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (ldev == NULL)\r\nreturn -EADDRNOTAVAIL;\r\n}\r\n}\r\nrv = -EINVAL;\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nmemcpy(&scp->addr, saddr, addr_len);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nrv = dn_hash_sock(sk);\r\nif (rv)\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\n}\r\nrelease_sock(sk);\r\nreturn rv;\r\n}\r\nstatic int dn_auto_bind(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nint rv;\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nscp->addr.sdn_flags = 0;\r\nscp->addr.sdn_objnum = 0;\r\nif ((scp->accessdata.acc_accl != 0) &&\r\n(scp->accessdata.acc_accl <= 12)) {\r\nscp->addr.sdn_objnamel = cpu_to_le16(scp->accessdata.acc_accl);\r\nmemcpy(scp->addr.sdn_objname, scp->accessdata.acc_acc, le16_to_cpu(scp->addr.sdn_objnamel));\r\nscp->accessdata.acc_accl = 0;\r\nmemset(scp->accessdata.acc_acc, 0, 40);\r\n}\r\nscp->addr.sdn_add.a_len = cpu_to_le16(2);\r\nrv = dn_dev_bind_default((__le16 *)scp->addr.sdn_add.a_addr);\r\nif (rv == 0) {\r\nrv = dn_hash_sock(sk);\r\nif (rv)\r\nsock_set_flag(sk, SOCK_ZAPPED);\r\n}\r\nreturn rv;\r\n}\r\nstatic int dn_confirm_accept(struct sock *sk, long *timeo, gfp_t allocation)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nDEFINE_WAIT(wait);\r\nint err;\r\nif (scp->state != DN_CR)\r\nreturn -EINVAL;\r\nscp->state = DN_CC;\r\nscp->segsize_loc = dst_metric_advmss(__sk_dst_get(sk));\r\ndn_send_conn_conf(sk, allocation);\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nfor(;;) {\r\nrelease_sock(sk);\r\nif (scp->state == DN_CC)\r\n*timeo = schedule_timeout(*timeo);\r\nlock_sock(sk);\r\nerr = 0;\r\nif (scp->state == DN_RUN)\r\nbreak;\r\nerr = sock_error(sk);\r\nif (err)\r\nbreak;\r\nerr = sock_intr_errno(*timeo);\r\nif (signal_pending(current))\r\nbreak;\r\nerr = -EAGAIN;\r\nif (!*timeo)\r\nbreak;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (err == 0) {\r\nsk->sk_socket->state = SS_CONNECTED;\r\n} else if (scp->state != DN_CC) {\r\nsk->sk_socket->state = SS_UNCONNECTED;\r\n}\r\nreturn err;\r\n}\r\nstatic int dn_wait_run(struct sock *sk, long *timeo)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nDEFINE_WAIT(wait);\r\nint err = 0;\r\nif (scp->state == DN_RUN)\r\ngoto out;\r\nif (!*timeo)\r\nreturn -EALREADY;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nfor(;;) {\r\nrelease_sock(sk);\r\nif (scp->state == DN_CI || scp->state == DN_CC)\r\n*timeo = schedule_timeout(*timeo);\r\nlock_sock(sk);\r\nerr = 0;\r\nif (scp->state == DN_RUN)\r\nbreak;\r\nerr = sock_error(sk);\r\nif (err)\r\nbreak;\r\nerr = sock_intr_errno(*timeo);\r\nif (signal_pending(current))\r\nbreak;\r\nerr = -ETIMEDOUT;\r\nif (!*timeo)\r\nbreak;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nout:\r\nif (err == 0) {\r\nsk->sk_socket->state = SS_CONNECTED;\r\n} else if (scp->state != DN_CI && scp->state != DN_CC) {\r\nsk->sk_socket->state = SS_UNCONNECTED;\r\n}\r\nreturn err;\r\n}\r\nstatic int __dn_connect(struct sock *sk, struct sockaddr_dn *addr, int addrlen, long *timeo, int flags)\r\n{\r\nstruct socket *sock = sk->sk_socket;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nint err = -EISCONN;\r\nstruct flowidn fld;\r\nif (sock->state == SS_CONNECTED)\r\ngoto out;\r\nif (sock->state == SS_CONNECTING) {\r\nerr = 0;\r\nif (scp->state == DN_RUN) {\r\nsock->state = SS_CONNECTED;\r\ngoto out;\r\n}\r\nerr = -ECONNREFUSED;\r\nif (scp->state != DN_CI && scp->state != DN_CC) {\r\nsock->state = SS_UNCONNECTED;\r\ngoto out;\r\n}\r\nreturn dn_wait_run(sk, timeo);\r\n}\r\nerr = -EINVAL;\r\nif (scp->state != DN_O)\r\ngoto out;\r\nif (addr == NULL || addrlen != sizeof(struct sockaddr_dn))\r\ngoto out;\r\nif (addr->sdn_family != AF_DECnet)\r\ngoto out;\r\nif (addr->sdn_flags & SDF_WILD)\r\ngoto out;\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nerr = dn_auto_bind(sk->sk_socket);\r\nif (err)\r\ngoto out;\r\n}\r\nmemcpy(&scp->peer, addr, sizeof(struct sockaddr_dn));\r\nerr = -EHOSTUNREACH;\r\nmemset(&fld, 0, sizeof(fld));\r\nfld.flowidn_oif = sk->sk_bound_dev_if;\r\nfld.daddr = dn_saddr2dn(&scp->peer);\r\nfld.saddr = dn_saddr2dn(&scp->addr);\r\ndn_sk_ports_copy(&fld, scp);\r\nfld.flowidn_proto = DNPROTO_NSP;\r\nif (dn_route_output_sock(&sk->sk_dst_cache, &fld, sk, flags) < 0)\r\ngoto out;\r\nsk->sk_route_caps = sk->sk_dst_cache->dev->features;\r\nsock->state = SS_CONNECTING;\r\nscp->state = DN_CI;\r\nscp->segsize_loc = dst_metric_advmss(sk->sk_dst_cache);\r\ndn_nsp_send_conninit(sk, NSP_CI);\r\nerr = -EINPROGRESS;\r\nif (*timeo) {\r\nerr = dn_wait_run(sk, timeo);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int dn_connect(struct socket *sock, struct sockaddr *uaddr, int addrlen, int flags)\r\n{\r\nstruct sockaddr_dn *addr = (struct sockaddr_dn *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nint err;\r\nlong timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\r\nlock_sock(sk);\r\nerr = __dn_connect(sk, addr, addrlen, &timeo, 0);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic inline int dn_check_state(struct sock *sk, struct sockaddr_dn *addr, int addrlen, long *timeo, int flags)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nswitch (scp->state) {\r\ncase DN_RUN:\r\nreturn 0;\r\ncase DN_CR:\r\nreturn dn_confirm_accept(sk, timeo, sk->sk_allocation);\r\ncase DN_CI:\r\ncase DN_CC:\r\nreturn dn_wait_run(sk, timeo);\r\ncase DN_O:\r\nreturn __dn_connect(sk, addr, addrlen, timeo, flags);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void dn_access_copy(struct sk_buff *skb, struct accessdata_dn *acc)\r\n{\r\nunsigned char *ptr = skb->data;\r\nacc->acc_userl = *ptr++;\r\nmemcpy(&acc->acc_user, ptr, acc->acc_userl);\r\nptr += acc->acc_userl;\r\nacc->acc_passl = *ptr++;\r\nmemcpy(&acc->acc_pass, ptr, acc->acc_passl);\r\nptr += acc->acc_passl;\r\nacc->acc_accl = *ptr++;\r\nmemcpy(&acc->acc_acc, ptr, acc->acc_accl);\r\nskb_pull(skb, acc->acc_accl + acc->acc_passl + acc->acc_userl + 3);\r\n}\r\nstatic void dn_user_copy(struct sk_buff *skb, struct optdata_dn *opt)\r\n{\r\nunsigned char *ptr = skb->data;\r\nu16 len = *ptr++;\r\nBUG_ON(len > 16);\r\nopt->opt_optl = cpu_to_le16(len);\r\nopt->opt_status = 0;\r\nmemcpy(opt->opt_data, ptr, len);\r\nskb_pull(skb, len + 1);\r\n}\r\nstatic struct sk_buff *dn_wait_for_connect(struct sock *sk, long *timeo)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct sk_buff *skb = NULL;\r\nint err = 0;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nfor(;;) {\r\nrelease_sock(sk);\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nif (skb == NULL) {\r\n*timeo = schedule_timeout(*timeo);\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\n}\r\nlock_sock(sk);\r\nif (skb != NULL)\r\nbreak;\r\nerr = -EINVAL;\r\nif (sk->sk_state != TCP_LISTEN)\r\nbreak;\r\nerr = sock_intr_errno(*timeo);\r\nif (signal_pending(current))\r\nbreak;\r\nerr = -EAGAIN;\r\nif (!*timeo)\r\nbreak;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nreturn skb == NULL ? ERR_PTR(err) : skb;\r\n}\r\nstatic int dn_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sock *sk = sock->sk, *newsk;\r\nstruct sk_buff *skb = NULL;\r\nstruct dn_skb_cb *cb;\r\nunsigned char menuver;\r\nint err = 0;\r\nunsigned char type;\r\nlong timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\r\nstruct dst_entry *dst;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_LISTEN || DN_SK(sk)->state != DN_O) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nif (skb == NULL) {\r\nskb = dn_wait_for_connect(sk, &timeo);\r\nif (IS_ERR(skb)) {\r\nrelease_sock(sk);\r\nreturn PTR_ERR(skb);\r\n}\r\n}\r\ncb = DN_SKB_CB(skb);\r\nsk->sk_ack_backlog--;\r\nnewsk = dn_alloc_sock(sock_net(sk), newsock, sk->sk_allocation);\r\nif (newsk == NULL) {\r\nrelease_sock(sk);\r\nkfree_skb(skb);\r\nreturn -ENOBUFS;\r\n}\r\nrelease_sock(sk);\r\ndst = skb_dst(skb);\r\nsk_dst_set(newsk, dst);\r\nskb_dst_set(skb, NULL);\r\nDN_SK(newsk)->state = DN_CR;\r\nDN_SK(newsk)->addrrem = cb->src_port;\r\nDN_SK(newsk)->services_rem = cb->services;\r\nDN_SK(newsk)->info_rem = cb->info;\r\nDN_SK(newsk)->segsize_rem = cb->segsize;\r\nDN_SK(newsk)->accept_mode = DN_SK(sk)->accept_mode;\r\nif (DN_SK(newsk)->segsize_rem < 230)\r\nDN_SK(newsk)->segsize_rem = 230;\r\nif ((DN_SK(newsk)->services_rem & NSP_FC_MASK) == NSP_FC_NONE)\r\nDN_SK(newsk)->max_window = decnet_no_fc_max_cwnd;\r\nnewsk->sk_state = TCP_LISTEN;\r\nmemcpy(&(DN_SK(newsk)->addr), &(DN_SK(sk)->addr), sizeof(struct sockaddr_dn));\r\nDN_SK(newsk)->addr.sdn_flags &= ~SDF_WILD;\r\nskb_pull(skb, dn_username2sockaddr(skb->data, skb->len, &(DN_SK(newsk)->addr), &type));\r\nskb_pull(skb, dn_username2sockaddr(skb->data, skb->len, &(DN_SK(newsk)->peer), &type));\r\n*(__le16 *)(DN_SK(newsk)->peer.sdn_add.a_addr) = cb->src;\r\n*(__le16 *)(DN_SK(newsk)->addr.sdn_add.a_addr) = cb->dst;\r\nmenuver = *skb->data;\r\nskb_pull(skb, 1);\r\nif (menuver & DN_MENUVER_ACC)\r\ndn_access_copy(skb, &(DN_SK(newsk)->accessdata));\r\nif (menuver & DN_MENUVER_USR)\r\ndn_user_copy(skb, &(DN_SK(newsk)->conndata_in));\r\nif (menuver & DN_MENUVER_PRX)\r\nDN_SK(newsk)->peer.sdn_flags |= SDF_PROXY;\r\nif (menuver & DN_MENUVER_UIC)\r\nDN_SK(newsk)->peer.sdn_flags |= SDF_UICPROXY;\r\nkfree_skb(skb);\r\nmemcpy(&(DN_SK(newsk)->conndata_out), &(DN_SK(sk)->conndata_out),\r\nsizeof(struct optdata_dn));\r\nmemcpy(&(DN_SK(newsk)->discdata_out), &(DN_SK(sk)->discdata_out),\r\nsizeof(struct optdata_dn));\r\nlock_sock(newsk);\r\nerr = dn_hash_sock(newsk);\r\nif (err == 0) {\r\nsock_reset_flag(newsk, SOCK_ZAPPED);\r\ndn_send_conn_ack(newsk);\r\nif (DN_SK(newsk)->accept_mode == ACC_IMMED)\r\nerr = dn_confirm_accept(newsk, &timeo,\r\nsk->sk_allocation);\r\n}\r\nrelease_sock(newsk);\r\nreturn err;\r\n}\r\nstatic int dn_getname(struct socket *sock, struct sockaddr *uaddr,int *uaddr_len,int peer)\r\n{\r\nstruct sockaddr_dn *sa = (struct sockaddr_dn *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\n*uaddr_len = sizeof(struct sockaddr_dn);\r\nlock_sock(sk);\r\nif (peer) {\r\nif ((sock->state != SS_CONNECTED &&\r\nsock->state != SS_CONNECTING) &&\r\nscp->accept_mode == ACC_IMMED) {\r\nrelease_sock(sk);\r\nreturn -ENOTCONN;\r\n}\r\nmemcpy(sa, &scp->peer, sizeof(struct sockaddr_dn));\r\n} else {\r\nmemcpy(sa, &scp->addr, sizeof(struct sockaddr_dn));\r\n}\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nstatic unsigned int dn_poll(struct file *file, struct socket *sock, poll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nint mask = datagram_poll(file, sock, wait);\r\nif (!skb_queue_empty(&scp->other_receive_queue))\r\nmask |= POLLRDBAND;\r\nreturn mask;\r\n}\r\nstatic int dn_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nint err = -EOPNOTSUPP;\r\nlong amount = 0;\r\nstruct sk_buff *skb;\r\nint val;\r\nswitch(cmd)\r\n{\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\nreturn dn_dev_ioctl(cmd, (void __user *)arg);\r\ncase SIOCATMARK:\r\nlock_sock(sk);\r\nval = !skb_queue_empty(&scp->other_receive_queue);\r\nif (scp->state != DN_RUN)\r\nval = -ENOTCONN;\r\nrelease_sock(sk);\r\nreturn val;\r\ncase TIOCOUTQ:\r\namount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nerr = put_user(amount, (int __user *)arg);\r\nbreak;\r\ncase TIOCINQ:\r\nlock_sock(sk);\r\nskb = skb_peek(&scp->other_receive_queue);\r\nif (skb) {\r\namount = skb->len;\r\n} else {\r\nskb_queue_walk(&sk->sk_receive_queue, skb)\r\namount += skb->len;\r\n}\r\nrelease_sock(sk);\r\nerr = put_user(amount, (int __user *)arg);\r\nbreak;\r\ndefault:\r\nerr = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int dn_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = -EINVAL;\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\ngoto out;\r\nif ((DN_SK(sk)->state != DN_O) || (sk->sk_state == TCP_LISTEN))\r\ngoto out;\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_ack_backlog = 0;\r\nsk->sk_state = TCP_LISTEN;\r\nerr = 0;\r\ndn_rehash_sock(sk);\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int dn_shutdown(struct socket *sock, int how)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nint err = -ENOTCONN;\r\nlock_sock(sk);\r\nif (sock->state == SS_UNCONNECTED)\r\ngoto out;\r\nerr = 0;\r\nif (sock->state == SS_DISCONNECTING)\r\ngoto out;\r\nerr = -EINVAL;\r\nif (scp->state == DN_O)\r\ngoto out;\r\nif (how != SHUTDOWN_MASK)\r\ngoto out;\r\nsk->sk_shutdown = how;\r\ndn_destroy_sock(sk);\r\nerr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int dn_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err;\r\nlock_sock(sk);\r\nerr = __dn_setsockopt(sock, level, optname, optval, optlen, 0);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int __dn_setsockopt(struct socket *sock, int level,int optname, char __user *optval, unsigned int optlen, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nlong timeo;\r\nunion {\r\nstruct optdata_dn opt;\r\nstruct accessdata_dn acc;\r\nint mode;\r\nunsigned long win;\r\nint val;\r\nunsigned char services;\r\nunsigned char info;\r\n} u;\r\nint err;\r\nif (optlen && !optval)\r\nreturn -EINVAL;\r\nif (optlen > sizeof(u))\r\nreturn -EINVAL;\r\nif (copy_from_user(&u, optval, optlen))\r\nreturn -EFAULT;\r\nswitch (optname) {\r\ncase DSO_CONDATA:\r\nif (sock->state == SS_CONNECTED)\r\nreturn -EISCONN;\r\nif ((scp->state != DN_O) && (scp->state != DN_CR))\r\nreturn -EINVAL;\r\nif (optlen != sizeof(struct optdata_dn))\r\nreturn -EINVAL;\r\nif (le16_to_cpu(u.opt.opt_optl) > 16)\r\nreturn -EINVAL;\r\nmemcpy(&scp->conndata_out, &u.opt, optlen);\r\nbreak;\r\ncase DSO_DISDATA:\r\nif (sock->state != SS_CONNECTED &&\r\nscp->accept_mode == ACC_IMMED)\r\nreturn -ENOTCONN;\r\nif (optlen != sizeof(struct optdata_dn))\r\nreturn -EINVAL;\r\nif (le16_to_cpu(u.opt.opt_optl) > 16)\r\nreturn -EINVAL;\r\nmemcpy(&scp->discdata_out, &u.opt, optlen);\r\nbreak;\r\ncase DSO_CONACCESS:\r\nif (sock->state == SS_CONNECTED)\r\nreturn -EISCONN;\r\nif (scp->state != DN_O)\r\nreturn -EINVAL;\r\nif (optlen != sizeof(struct accessdata_dn))\r\nreturn -EINVAL;\r\nif ((u.acc.acc_accl > DN_MAXACCL) ||\r\n(u.acc.acc_passl > DN_MAXACCL) ||\r\n(u.acc.acc_userl > DN_MAXACCL))\r\nreturn -EINVAL;\r\nmemcpy(&scp->accessdata, &u.acc, optlen);\r\nbreak;\r\ncase DSO_ACCEPTMODE:\r\nif (sock->state == SS_CONNECTED)\r\nreturn -EISCONN;\r\nif (scp->state != DN_O)\r\nreturn -EINVAL;\r\nif (optlen != sizeof(int))\r\nreturn -EINVAL;\r\nif ((u.mode != ACC_IMMED) && (u.mode != ACC_DEFER))\r\nreturn -EINVAL;\r\nscp->accept_mode = (unsigned char)u.mode;\r\nbreak;\r\ncase DSO_CONACCEPT:\r\nif (scp->state != DN_CR)\r\nreturn -EINVAL;\r\ntimeo = sock_rcvtimeo(sk, 0);\r\nerr = dn_confirm_accept(sk, &timeo, sk->sk_allocation);\r\nreturn err;\r\ncase DSO_CONREJECT:\r\nif (scp->state != DN_CR)\r\nreturn -EINVAL;\r\nscp->state = DN_DR;\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\ndn_nsp_send_disc(sk, 0x38, 0, sk->sk_allocation);\r\nbreak;\r\ndefault:\r\n#ifdef CONFIG_NETFILTER\r\nreturn nf_setsockopt(sk, PF_DECnet, optname, optval, optlen);\r\n#endif\r\ncase DSO_LINKINFO:\r\ncase DSO_STREAM:\r\ncase DSO_SEQPACKET:\r\nreturn -ENOPROTOOPT;\r\ncase DSO_MAXWINDOW:\r\nif (optlen != sizeof(unsigned long))\r\nreturn -EINVAL;\r\nif (u.win > NSP_MAX_WINDOW)\r\nu.win = NSP_MAX_WINDOW;\r\nif (u.win == 0)\r\nreturn -EINVAL;\r\nscp->max_window = u.win;\r\nif (scp->snd_window > u.win)\r\nscp->snd_window = u.win;\r\nbreak;\r\ncase DSO_NODELAY:\r\nif (optlen != sizeof(int))\r\nreturn -EINVAL;\r\nif (scp->nonagle == 2)\r\nreturn -EINVAL;\r\nscp->nonagle = (u.val == 0) ? 0 : 1;\r\nbreak;\r\ncase DSO_CORK:\r\nif (optlen != sizeof(int))\r\nreturn -EINVAL;\r\nif (scp->nonagle == 1)\r\nreturn -EINVAL;\r\nscp->nonagle = (u.val == 0) ? 0 : 2;\r\nbreak;\r\ncase DSO_SERVICES:\r\nif (optlen != sizeof(unsigned char))\r\nreturn -EINVAL;\r\nif ((u.services & ~NSP_FC_MASK) != 0x01)\r\nreturn -EINVAL;\r\nif ((u.services & NSP_FC_MASK) == NSP_FC_MASK)\r\nreturn -EINVAL;\r\nscp->services_loc = u.services;\r\nbreak;\r\ncase DSO_INFO:\r\nif (optlen != sizeof(unsigned char))\r\nreturn -EINVAL;\r\nif (u.info & 0xfc)\r\nreturn -EINVAL;\r\nscp->info_loc = u.info;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dn_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err;\r\nlock_sock(sk);\r\nerr = __dn_getsockopt(sock, level, optname, optval, optlen, 0);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int __dn_getsockopt(struct socket *sock, int level,int optname, char __user *optval,int __user *optlen, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct linkinfo_dn link;\r\nunsigned int r_len;\r\nvoid *r_data = NULL;\r\nunsigned int val;\r\nif(get_user(r_len , optlen))\r\nreturn -EFAULT;\r\nswitch (optname) {\r\ncase DSO_CONDATA:\r\nif (r_len > sizeof(struct optdata_dn))\r\nr_len = sizeof(struct optdata_dn);\r\nr_data = &scp->conndata_in;\r\nbreak;\r\ncase DSO_DISDATA:\r\nif (r_len > sizeof(struct optdata_dn))\r\nr_len = sizeof(struct optdata_dn);\r\nr_data = &scp->discdata_in;\r\nbreak;\r\ncase DSO_CONACCESS:\r\nif (r_len > sizeof(struct accessdata_dn))\r\nr_len = sizeof(struct accessdata_dn);\r\nr_data = &scp->accessdata;\r\nbreak;\r\ncase DSO_ACCEPTMODE:\r\nif (r_len > sizeof(unsigned char))\r\nr_len = sizeof(unsigned char);\r\nr_data = &scp->accept_mode;\r\nbreak;\r\ncase DSO_LINKINFO:\r\nif (r_len > sizeof(struct linkinfo_dn))\r\nr_len = sizeof(struct linkinfo_dn);\r\nmemset(&link, 0, sizeof(link));\r\nswitch (sock->state) {\r\ncase SS_CONNECTING:\r\nlink.idn_linkstate = LL_CONNECTING;\r\nbreak;\r\ncase SS_DISCONNECTING:\r\nlink.idn_linkstate = LL_DISCONNECTING;\r\nbreak;\r\ncase SS_CONNECTED:\r\nlink.idn_linkstate = LL_RUNNING;\r\nbreak;\r\ndefault:\r\nlink.idn_linkstate = LL_INACTIVE;\r\n}\r\nlink.idn_segsize = scp->segsize_rem;\r\nr_data = &link;\r\nbreak;\r\ndefault:\r\n#ifdef CONFIG_NETFILTER\r\n{\r\nint ret, len;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nret = nf_getsockopt(sk, PF_DECnet, optname, optval, &len);\r\nif (ret >= 0)\r\nret = put_user(len, optlen);\r\nreturn ret;\r\n}\r\n#endif\r\ncase DSO_STREAM:\r\ncase DSO_SEQPACKET:\r\ncase DSO_CONACCEPT:\r\ncase DSO_CONREJECT:\r\nreturn -ENOPROTOOPT;\r\ncase DSO_MAXWINDOW:\r\nif (r_len > sizeof(unsigned long))\r\nr_len = sizeof(unsigned long);\r\nr_data = &scp->max_window;\r\nbreak;\r\ncase DSO_NODELAY:\r\nif (r_len > sizeof(int))\r\nr_len = sizeof(int);\r\nval = (scp->nonagle == 1);\r\nr_data = &val;\r\nbreak;\r\ncase DSO_CORK:\r\nif (r_len > sizeof(int))\r\nr_len = sizeof(int);\r\nval = (scp->nonagle == 2);\r\nr_data = &val;\r\nbreak;\r\ncase DSO_SERVICES:\r\nif (r_len > sizeof(unsigned char))\r\nr_len = sizeof(unsigned char);\r\nr_data = &scp->services_rem;\r\nbreak;\r\ncase DSO_INFO:\r\nif (r_len > sizeof(unsigned char))\r\nr_len = sizeof(unsigned char);\r\nr_data = &scp->info_rem;\r\nbreak;\r\n}\r\nif (r_data) {\r\nif (copy_to_user(optval, r_data, r_len))\r\nreturn -EFAULT;\r\nif (put_user(r_len, optlen))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dn_data_ready(struct sock *sk, struct sk_buff_head *q, int flags, int target)\r\n{\r\nstruct sk_buff *skb;\r\nint len = 0;\r\nif (flags & MSG_OOB)\r\nreturn !skb_queue_empty(q) ? 1 : 0;\r\nskb_queue_walk(q, skb) {\r\nstruct dn_skb_cb *cb = DN_SKB_CB(skb);\r\nlen += skb->len;\r\nif (cb->nsp_flags & 0x40) {\r\nif (sk->sk_type == SOCK_SEQPACKET)\r\nreturn 1;\r\nif (!(flags & MSG_WAITALL))\r\nreturn 1;\r\n}\r\nif (len >= target)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dn_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nstruct sk_buff_head *queue = &sk->sk_receive_queue;\r\nsize_t target = size > 1 ? 1 : 0;\r\nsize_t copied = 0;\r\nint rv = 0;\r\nstruct sk_buff *skb, *n;\r\nstruct dn_skb_cb *cb = NULL;\r\nunsigned char eor = 0;\r\nlong timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nrv = -EADDRNOTAVAIL;\r\ngoto out;\r\n}\r\nif (sk->sk_shutdown & RCV_SHUTDOWN) {\r\nrv = 0;\r\ngoto out;\r\n}\r\nrv = dn_check_state(sk, NULL, 0, &timeo, flags);\r\nif (rv)\r\ngoto out;\r\nif (flags & ~(MSG_CMSG_COMPAT|MSG_PEEK|MSG_OOB|MSG_WAITALL|MSG_DONTWAIT|MSG_NOSIGNAL)) {\r\nrv = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (flags & MSG_OOB)\r\nqueue = &scp->other_receive_queue;\r\nif (flags & MSG_WAITALL)\r\ntarget = size;\r\nfor(;;) {\r\nDEFINE_WAIT(wait);\r\nif (sk->sk_err)\r\ngoto out;\r\nif (!skb_queue_empty(&scp->other_receive_queue)) {\r\nif (!(flags & MSG_OOB)) {\r\nmsg->msg_flags |= MSG_OOB;\r\nif (!scp->other_report) {\r\nscp->other_report = 1;\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (scp->state != DN_RUN)\r\ngoto out;\r\nif (signal_pending(current)) {\r\nrv = sock_intr_errno(timeo);\r\ngoto out;\r\n}\r\nif (dn_data_ready(sk, queue, flags, target))\r\nbreak;\r\nif (flags & MSG_DONTWAIT) {\r\nrv = -EWOULDBLOCK;\r\ngoto out;\r\n}\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nset_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\nsk_wait_event(sk, &timeo, dn_data_ready(sk, queue, flags, target));\r\nclear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\nfinish_wait(sk_sleep(sk), &wait);\r\n}\r\nskb_queue_walk_safe(queue, skb, n) {\r\nunsigned int chunk = skb->len;\r\ncb = DN_SKB_CB(skb);\r\nif ((chunk + copied) > size)\r\nchunk = size - copied;\r\nif (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {\r\nrv = -EFAULT;\r\nbreak;\r\n}\r\ncopied += chunk;\r\nif (!(flags & MSG_PEEK))\r\nskb_pull(skb, chunk);\r\neor = cb->nsp_flags & 0x40;\r\nif (skb->len == 0) {\r\nskb_unlink(skb, queue);\r\nkfree_skb(skb);\r\nif ((scp->flowloc_sw == DN_DONTSEND) && !dn_congested(sk)) {\r\nscp->flowloc_sw = DN_SEND;\r\ndn_nsp_send_link(sk, DN_SEND, 0);\r\n}\r\n}\r\nif (eor) {\r\nif (sk->sk_type == SOCK_SEQPACKET)\r\nbreak;\r\nif (!(flags & MSG_WAITALL))\r\nbreak;\r\n}\r\nif (flags & MSG_OOB)\r\nbreak;\r\nif (copied >= target)\r\nbreak;\r\n}\r\nrv = copied;\r\nif (eor && (sk->sk_type == SOCK_SEQPACKET))\r\nmsg->msg_flags |= MSG_EOR;\r\nout:\r\nif (rv == 0)\r\nrv = (flags & MSG_PEEK) ? -sk->sk_err : sock_error(sk);\r\nif ((rv >= 0) && msg->msg_name) {\r\nmemcpy(msg->msg_name, &scp->peer, sizeof(struct sockaddr_dn));\r\nmsg->msg_namelen = sizeof(struct sockaddr_dn);\r\n}\r\nrelease_sock(sk);\r\nreturn rv;\r\n}\r\nstatic inline int dn_queue_too_long(struct dn_scp *scp, struct sk_buff_head *queue, int flags)\r\n{\r\nunsigned char fctype = scp->services_rem & NSP_FC_MASK;\r\nif (skb_queue_len(queue) >= scp->snd_window)\r\nreturn 1;\r\nif (fctype != NSP_FC_NONE) {\r\nif (flags & MSG_OOB) {\r\nif (scp->flowrem_oth == 0)\r\nreturn 1;\r\n} else {\r\nif (scp->flowrem_dat == 0)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nunsigned int dn_mss_from_pmtu(struct net_device *dev, int mtu)\r\n{\r\nunsigned int mss = 230 - DN_MAX_NSP_DATA_HEADER;\r\nif (dev) {\r\nstruct dn_dev *dn_db = rcu_dereference_raw(dev->dn_ptr);\r\nmtu -= LL_RESERVED_SPACE(dev);\r\nif (dn_db->use_long)\r\nmtu -= 21;\r\nelse\r\nmtu -= 6;\r\nmtu -= DN_MAX_NSP_DATA_HEADER;\r\n} else {\r\nmtu -= (21 + DN_MAX_NSP_DATA_HEADER + 16);\r\n}\r\nif (mtu > mss)\r\nmss = mtu;\r\nreturn mss;\r\n}\r\nstatic inline unsigned int dn_current_mss(struct sock *sk, int flags)\r\n{\r\nstruct dst_entry *dst = __sk_dst_get(sk);\r\nstruct dn_scp *scp = DN_SK(sk);\r\nint mss_now = min_t(int, scp->segsize_loc, scp->segsize_rem);\r\nif (flags & MSG_OOB)\r\nreturn 16;\r\nif (dst) {\r\nu32 mtu = dst_mtu(dst);\r\nmss_now = min_t(int, dn_mss_from_pmtu(dst->dev, mtu), mss_now);\r\n}\r\nreturn mss_now;\r\n}\r\nstatic inline struct sk_buff *dn_alloc_send_pskb(struct sock *sk,\r\nunsigned long datalen, int noblock,\r\nint *errcode)\r\n{\r\nstruct sk_buff *skb = sock_alloc_send_skb(sk, datalen,\r\nnoblock, errcode);\r\nif (skb) {\r\nskb->protocol = htons(ETH_P_DNA_RT);\r\nskb->pkt_type = PACKET_OUTGOING;\r\n}\r\nreturn skb;\r\n}\r\nstatic int dn_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct dn_scp *scp = DN_SK(sk);\r\nsize_t mss;\r\nstruct sk_buff_head *queue = &scp->data_xmit_queue;\r\nint flags = msg->msg_flags;\r\nint err = 0;\r\nsize_t sent = 0;\r\nint addr_len = msg->msg_namelen;\r\nstruct sockaddr_dn *addr = (struct sockaddr_dn *)msg->msg_name;\r\nstruct sk_buff *skb = NULL;\r\nstruct dn_skb_cb *cb;\r\nsize_t len;\r\nunsigned char fctype;\r\nlong timeo;\r\nif (flags & ~(MSG_TRYHARD|MSG_OOB|MSG_DONTWAIT|MSG_EOR|MSG_NOSIGNAL|MSG_MORE|MSG_CMSG_COMPAT))\r\nreturn -EOPNOTSUPP;\r\nif (addr_len && (addr_len != sizeof(struct sockaddr_dn)))\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\ntimeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);\r\nif (sock->type == SOCK_STREAM) {\r\nif (flags & MSG_EOR) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nflags |= MSG_EOR;\r\n}\r\nerr = dn_check_state(sk, addr, addr_len, &timeo, flags);\r\nif (err)\r\ngoto out_err;\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nerr = -EPIPE;\r\nif (!(flags & MSG_NOSIGNAL))\r\nsend_sig(SIGPIPE, current, 0);\r\ngoto out_err;\r\n}\r\nif ((flags & MSG_TRYHARD) && sk->sk_dst_cache)\r\ndst_negative_advice(sk);\r\nmss = scp->segsize_rem;\r\nfctype = scp->services_rem & NSP_FC_MASK;\r\nmss = dn_current_mss(sk, flags);\r\nif (flags & MSG_OOB) {\r\nqueue = &scp->other_xmit_queue;\r\nif (size > mss) {\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\n}\r\nscp->persist_fxn = dn_nsp_xmit_timeout;\r\nwhile(sent < size) {\r\nerr = sock_error(sk);\r\nif (err)\r\ngoto out;\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\ngoto out;\r\n}\r\nlen = size - sent;\r\nif (len > mss)\r\nlen = mss;\r\nif (dn_queue_too_long(scp, queue, flags)) {\r\nDEFINE_WAIT(wait);\r\nif (flags & MSG_DONTWAIT) {\r\nerr = -EWOULDBLOCK;\r\ngoto out;\r\n}\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nset_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\nsk_wait_event(sk, &timeo,\r\n!dn_queue_too_long(scp, queue, flags));\r\nclear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\nfinish_wait(sk_sleep(sk), &wait);\r\ncontinue;\r\n}\r\nskb = dn_alloc_send_pskb(sk, len + 64 + DN_MAX_NSP_DATA_HEADER,\r\nflags & MSG_DONTWAIT, &err);\r\nif (err)\r\nbreak;\r\nif (!skb)\r\ncontinue;\r\ncb = DN_SKB_CB(skb);\r\nskb_reserve(skb, 64 + DN_MAX_NSP_DATA_HEADER);\r\nif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (flags & MSG_OOB) {\r\ncb->nsp_flags = 0x30;\r\nif (fctype != NSP_FC_NONE)\r\nscp->flowrem_oth--;\r\n} else {\r\ncb->nsp_flags = 0x00;\r\nif (scp->seg_total == 0)\r\ncb->nsp_flags |= 0x20;\r\nscp->seg_total += len;\r\nif (((sent + len) == size) && (flags & MSG_EOR)) {\r\ncb->nsp_flags |= 0x40;\r\nscp->seg_total = 0;\r\nif (fctype == NSP_FC_SCMC)\r\nscp->flowrem_dat--;\r\n}\r\nif (fctype == NSP_FC_SRC)\r\nscp->flowrem_dat--;\r\n}\r\nsent += len;\r\ndn_nsp_queue_xmit(sk, skb, sk->sk_allocation, flags & MSG_OOB);\r\nskb = NULL;\r\nscp->persist = dn_nsp_persist(sk);\r\n}\r\nout:\r\nkfree_skb(skb);\r\nrelease_sock(sk);\r\nreturn sent ? sent : err;\r\nout_err:\r\nerr = sk_stream_error(sk, flags, err);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int dn_device_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)ptr;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\ndn_dev_up(dev);\r\nbreak;\r\ncase NETDEV_DOWN:\r\ndn_dev_down(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic struct sock *dn_socket_get_first(struct seq_file *seq)\r\n{\r\nstruct dn_iter_state *state = seq->private;\r\nstruct sock *n = NULL;\r\nfor(state->bucket = 0;\r\nstate->bucket < DN_SK_HASH_SIZE;\r\n++state->bucket) {\r\nn = sk_head(&dn_sk_hash[state->bucket]);\r\nif (n)\r\nbreak;\r\n}\r\nreturn n;\r\n}\r\nstatic struct sock *dn_socket_get_next(struct seq_file *seq,\r\nstruct sock *n)\r\n{\r\nstruct dn_iter_state *state = seq->private;\r\nn = sk_next(n);\r\ntry_again:\r\nif (n)\r\ngoto out;\r\nif (++state->bucket >= DN_SK_HASH_SIZE)\r\ngoto out;\r\nn = sk_head(&dn_sk_hash[state->bucket]);\r\ngoto try_again;\r\nout:\r\nreturn n;\r\n}\r\nstatic struct sock *socket_get_idx(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct sock *sk = dn_socket_get_first(seq);\r\nif (sk) {\r\nwhile(*pos && (sk = dn_socket_get_next(seq, sk)))\r\n--*pos;\r\n}\r\nreturn *pos ? NULL : sk;\r\n}\r\nstatic void *dn_socket_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nvoid *rc;\r\nread_lock_bh(&dn_hash_lock);\r\nrc = socket_get_idx(seq, &pos);\r\nif (!rc) {\r\nread_unlock_bh(&dn_hash_lock);\r\n}\r\nreturn rc;\r\n}\r\nstatic void *dn_socket_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn *pos ? dn_socket_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *dn_socket_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nvoid *rc;\r\nif (v == SEQ_START_TOKEN) {\r\nrc = dn_socket_get_idx(seq, 0);\r\ngoto out;\r\n}\r\nrc = dn_socket_get_next(seq, v);\r\nif (rc)\r\ngoto out;\r\nread_unlock_bh(&dn_hash_lock);\r\nout:\r\n++*pos;\r\nreturn rc;\r\n}\r\nstatic void dn_socket_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nif (v && v != SEQ_START_TOKEN)\r\nread_unlock_bh(&dn_hash_lock);\r\n}\r\nstatic void dn_printable_object(struct sockaddr_dn *dn, unsigned char *buf)\r\n{\r\nint i;\r\nswitch (le16_to_cpu(dn->sdn_objnamel)) {\r\ncase 0:\r\nsprintf(buf, "%d", dn->sdn_objnum);\r\nbreak;\r\ndefault:\r\nfor (i = 0; i < le16_to_cpu(dn->sdn_objnamel); i++) {\r\nbuf[i] = dn->sdn_objname[i];\r\nif (IS_NOT_PRINTABLE(buf[i]))\r\nbuf[i] = '.';\r\n}\r\nbuf[i] = 0;\r\n}\r\n}\r\nstatic char *dn_state2asc(unsigned char state)\r\n{\r\nswitch (state) {\r\ncase DN_O:\r\nreturn "OPEN";\r\ncase DN_CR:\r\nreturn " CR";\r\ncase DN_DR:\r\nreturn " DR";\r\ncase DN_DRC:\r\nreturn " DRC";\r\ncase DN_CC:\r\nreturn " CC";\r\ncase DN_CI:\r\nreturn " CI";\r\ncase DN_NR:\r\nreturn " NR";\r\ncase DN_NC:\r\nreturn " NC";\r\ncase DN_CD:\r\nreturn " CD";\r\ncase DN_RJ:\r\nreturn " RJ";\r\ncase DN_RUN:\r\nreturn " RUN";\r\ncase DN_DI:\r\nreturn " DI";\r\ncase DN_DIC:\r\nreturn " DIC";\r\ncase DN_DN:\r\nreturn " DN";\r\ncase DN_CL:\r\nreturn " CL";\r\ncase DN_CN:\r\nreturn " CN";\r\n}\r\nreturn "????";\r\n}\r\nstatic inline void dn_socket_format_entry(struct seq_file *seq, struct sock *sk)\r\n{\r\nstruct dn_scp *scp = DN_SK(sk);\r\nchar buf1[DN_ASCBUF_LEN];\r\nchar buf2[DN_ASCBUF_LEN];\r\nchar local_object[DN_MAXOBJL+3];\r\nchar remote_object[DN_MAXOBJL+3];\r\ndn_printable_object(&scp->addr, local_object);\r\ndn_printable_object(&scp->peer, remote_object);\r\nseq_printf(seq,\r\n"%6s/%04X %04d:%04d %04d:%04d %01d %-16s "\r\n"%6s/%04X %04d:%04d %04d:%04d %01d %-16s %4s %s\n",\r\ndn_addr2asc(le16_to_cpu(dn_saddr2dn(&scp->addr)), buf1),\r\nscp->addrloc,\r\nscp->numdat,\r\nscp->numoth,\r\nscp->ackxmt_dat,\r\nscp->ackxmt_oth,\r\nscp->flowloc_sw,\r\nlocal_object,\r\ndn_addr2asc(le16_to_cpu(dn_saddr2dn(&scp->peer)), buf2),\r\nscp->addrrem,\r\nscp->numdat_rcv,\r\nscp->numoth_rcv,\r\nscp->ackrcv_dat,\r\nscp->ackrcv_oth,\r\nscp->flowrem_sw,\r\nremote_object,\r\ndn_state2asc(scp->state),\r\n((scp->accept_mode == ACC_IMMED) ? "IMMED" : "DEFER"));\r\n}\r\nstatic int dn_socket_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Local Remote\n");\r\n} else {\r\ndn_socket_format_entry(seq, v);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dn_socket_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_private(file, &dn_socket_seq_ops,\r\nsizeof(struct dn_iter_state));\r\n}\r\nstatic int __init decnet_init(void)\r\n{\r\nint rc;\r\nprintk(banner);\r\nrc = proto_register(&dn_proto, 1);\r\nif (rc != 0)\r\ngoto out;\r\ndn_neigh_init();\r\ndn_dev_init();\r\ndn_route_init();\r\ndn_fib_init();\r\nsock_register(&dn_family_ops);\r\ndev_add_pack(&dn_dix_packet_type);\r\nregister_netdevice_notifier(&dn_dev_notifier);\r\nproc_net_fops_create(&init_net, "decnet", S_IRUGO, &dn_socket_seq_fops);\r\ndn_register_sysctl();\r\nout:\r\nreturn rc;\r\n}
