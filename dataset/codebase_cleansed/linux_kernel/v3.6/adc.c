static inline void s3c_adc_convert(struct adc_device *adc)\r\n{\r\nunsigned con = readl(adc->regs + S3C2410_ADCCON);\r\ncon |= S3C2410_ADCCON_ENABLE_START;\r\nwritel(con, adc->regs + S3C2410_ADCCON);\r\n}\r\nstatic inline void s3c_adc_select(struct adc_device *adc,\r\nstruct s3c_adc_client *client)\r\n{\r\nunsigned con = readl(adc->regs + S3C2410_ADCCON);\r\nenum s3c_cpu_type cpu = platform_get_device_id(adc->pdev)->driver_data;\r\nclient->select_cb(client, 1);\r\nif (cpu == TYPE_ADCV1 || cpu == TYPE_ADCV2)\r\ncon &= ~S3C2410_ADCCON_MUXMASK;\r\ncon &= ~S3C2410_ADCCON_STDBM;\r\ncon &= ~S3C2410_ADCCON_STARTMASK;\r\nif (!client->is_ts) {\r\nif (cpu == TYPE_ADCV3)\r\nwritel(client->channel & 0xf, adc->regs + S5P_ADCMUX);\r\nelse if (cpu == TYPE_ADCV11 || cpu == TYPE_ADCV12)\r\nwritel(client->channel & 0xf,\r\nadc->regs + S3C2443_ADCMUX);\r\nelse\r\ncon |= S3C2410_ADCCON_SELMUX(client->channel);\r\n}\r\nwritel(con, adc->regs + S3C2410_ADCCON);\r\n}\r\nstatic void s3c_adc_dbgshow(struct adc_device *adc)\r\n{\r\nadc_dbg(adc, "CON=%08x, TSC=%08x, DLY=%08x\n",\r\nreadl(adc->regs + S3C2410_ADCCON),\r\nreadl(adc->regs + S3C2410_ADCTSC),\r\nreadl(adc->regs + S3C2410_ADCDLY));\r\n}\r\nstatic void s3c_adc_try(struct adc_device *adc)\r\n{\r\nstruct s3c_adc_client *next = adc->ts_pend;\r\nif (!next && !list_empty(&adc_pending)) {\r\nnext = list_first_entry(&adc_pending,\r\nstruct s3c_adc_client, pend);\r\nlist_del(&next->pend);\r\n} else\r\nadc->ts_pend = NULL;\r\nif (next) {\r\nadc_dbg(adc, "new client is %p\n", next);\r\nadc->cur = next;\r\ns3c_adc_select(adc, next);\r\ns3c_adc_convert(adc);\r\ns3c_adc_dbgshow(adc);\r\n}\r\n}\r\nint s3c_adc_start(struct s3c_adc_client *client,\r\nunsigned int channel, unsigned int nr_samples)\r\n{\r\nstruct adc_device *adc = adc_dev;\r\nunsigned long flags;\r\nif (!adc) {\r\nprintk(KERN_ERR "%s: failed to find adc\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&adc->lock, flags);\r\nif (client->is_ts && adc->ts_pend) {\r\nspin_unlock_irqrestore(&adc->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nclient->channel = channel;\r\nclient->nr_samples = nr_samples;\r\nif (client->is_ts)\r\nadc->ts_pend = client;\r\nelse\r\nlist_add_tail(&client->pend, &adc_pending);\r\nif (!adc->cur)\r\ns3c_adc_try(adc);\r\nspin_unlock_irqrestore(&adc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void s3c_convert_done(struct s3c_adc_client *client,\r\nunsigned v, unsigned u, unsigned *left)\r\n{\r\nclient->result = v;\r\nwake_up(client->wait);\r\n}\r\nint s3c_adc_read(struct s3c_adc_client *client, unsigned int ch)\r\n{\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wake);\r\nint ret;\r\nclient->convert_cb = s3c_convert_done;\r\nclient->wait = &wake;\r\nclient->result = -1;\r\nret = s3c_adc_start(client, ch, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = wait_event_timeout(wake, client->result >= 0, HZ / 2);\r\nif (client->result < 0) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nclient->convert_cb = NULL;\r\nreturn client->result;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void s3c_adc_default_select(struct s3c_adc_client *client,\r\nunsigned select)\r\n{\r\n}\r\nstruct s3c_adc_client *s3c_adc_register(struct platform_device *pdev,\r\nvoid (*select)(struct s3c_adc_client *client,\r\nunsigned int selected),\r\nvoid (*conv)(struct s3c_adc_client *client,\r\nunsigned d0, unsigned d1,\r\nunsigned *samples_left),\r\nunsigned int is_ts)\r\n{\r\nstruct s3c_adc_client *client;\r\nWARN_ON(!pdev);\r\nif (!select)\r\nselect = s3c_adc_default_select;\r\nif (!pdev)\r\nreturn ERR_PTR(-EINVAL);\r\nclient = kzalloc(sizeof(struct s3c_adc_client), GFP_KERNEL);\r\nif (!client) {\r\ndev_err(&pdev->dev, "no memory for adc client\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nclient->pdev = pdev;\r\nclient->is_ts = is_ts;\r\nclient->select_cb = select;\r\nclient->convert_cb = conv;\r\nreturn client;\r\n}\r\nvoid s3c_adc_release(struct s3c_adc_client *client)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&adc_dev->lock, flags);\r\nif (adc_dev->cur == client)\r\nadc_dev->cur = NULL;\r\nif (adc_dev->ts_pend == client)\r\nadc_dev->ts_pend = NULL;\r\nelse {\r\nstruct list_head *p, *n;\r\nstruct s3c_adc_client *tmp;\r\nlist_for_each_safe(p, n, &adc_pending) {\r\ntmp = list_entry(p, struct s3c_adc_client, pend);\r\nif (tmp == client)\r\nlist_del(&tmp->pend);\r\n}\r\n}\r\nif (adc_dev->cur == NULL)\r\ns3c_adc_try(adc_dev);\r\nspin_unlock_irqrestore(&adc_dev->lock, flags);\r\nkfree(client);\r\n}\r\nstatic irqreturn_t s3c_adc_irq(int irq, void *pw)\r\n{\r\nstruct adc_device *adc = pw;\r\nstruct s3c_adc_client *client = adc->cur;\r\nenum s3c_cpu_type cpu = platform_get_device_id(adc->pdev)->driver_data;\r\nunsigned data0, data1;\r\nif (!client) {\r\ndev_warn(&adc->pdev->dev, "%s: no adc pending\n", __func__);\r\ngoto exit;\r\n}\r\ndata0 = readl(adc->regs + S3C2410_ADCDAT0);\r\ndata1 = readl(adc->regs + S3C2410_ADCDAT1);\r\nadc_dbg(adc, "read %d: 0x%04x, 0x%04x\n", client->nr_samples, data0, data1);\r\nclient->nr_samples--;\r\nif (cpu == TYPE_ADCV1 || cpu == TYPE_ADCV11) {\r\ndata0 &= 0x3ff;\r\ndata1 &= 0x3ff;\r\n} else {\r\ndata0 &= 0xfff;\r\ndata1 &= 0xfff;\r\n}\r\nif (client->convert_cb)\r\n(client->convert_cb)(client, data0, data1, &client->nr_samples);\r\nif (client->nr_samples > 0) {\r\nclient->select_cb(client, 1);\r\ns3c_adc_convert(adc);\r\n} else {\r\nspin_lock(&adc->lock);\r\n(client->select_cb)(client, 0);\r\nadc->cur = NULL;\r\ns3c_adc_try(adc);\r\nspin_unlock(&adc->lock);\r\n}\r\nexit:\r\nif (cpu == TYPE_ADCV2 || cpu == TYPE_ADCV3) {\r\nwritel(0, adc->regs + S3C64XX_ADCCLRINT);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct adc_device *adc;\r\nstruct resource *regs;\r\nenum s3c_cpu_type cpu = platform_get_device_id(pdev)->driver_data;\r\nint ret;\r\nunsigned tmp;\r\nadc = kzalloc(sizeof(struct adc_device), GFP_KERNEL);\r\nif (adc == NULL) {\r\ndev_err(dev, "failed to allocate adc_device\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&adc->lock);\r\nadc->pdev = pdev;\r\nadc->prescale = S3C2410_ADCCON_PRSCVL(49);\r\nadc->vdd = regulator_get(dev, "vdd");\r\nif (IS_ERR(adc->vdd)) {\r\ndev_err(dev, "operating without regulator \"vdd\" .\n");\r\nret = PTR_ERR(adc->vdd);\r\ngoto err_alloc;\r\n}\r\nadc->irq = platform_get_irq(pdev, 1);\r\nif (adc->irq <= 0) {\r\ndev_err(dev, "failed to get adc irq\n");\r\nret = -ENOENT;\r\ngoto err_reg;\r\n}\r\nret = request_irq(adc->irq, s3c_adc_irq, 0, dev_name(dev), adc);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to attach adc irq\n");\r\ngoto err_reg;\r\n}\r\nadc->clk = clk_get(dev, "adc");\r\nif (IS_ERR(adc->clk)) {\r\ndev_err(dev, "failed to get adc clock\n");\r\nret = PTR_ERR(adc->clk);\r\ngoto err_irq;\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_err(dev, "failed to find registers\n");\r\nret = -ENXIO;\r\ngoto err_clk;\r\n}\r\nadc->regs = ioremap(regs->start, resource_size(regs));\r\nif (!adc->regs) {\r\ndev_err(dev, "failed to map registers\n");\r\nret = -ENXIO;\r\ngoto err_clk;\r\n}\r\nret = regulator_enable(adc->vdd);\r\nif (ret)\r\ngoto err_ioremap;\r\nclk_enable(adc->clk);\r\ntmp = adc->prescale | S3C2410_ADCCON_PRSCEN;\r\nif (cpu == TYPE_ADCV12)\r\ntmp |= S3C2416_ADCCON_RESSEL;\r\nif (cpu == TYPE_ADCV2 || cpu == TYPE_ADCV3)\r\ntmp |= S3C64XX_ADCCON_RESSEL;\r\nwritel(tmp, adc->regs + S3C2410_ADCCON);\r\ndev_info(dev, "attached adc driver\n");\r\nplatform_set_drvdata(pdev, adc);\r\nadc_dev = adc;\r\nreturn 0;\r\nerr_ioremap:\r\niounmap(adc->regs);\r\nerr_clk:\r\nclk_put(adc->clk);\r\nerr_irq:\r\nfree_irq(adc->irq, adc);\r\nerr_reg:\r\nregulator_put(adc->vdd);\r\nerr_alloc:\r\nkfree(adc);\r\nreturn ret;\r\n}\r\nstatic int __devexit s3c_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct adc_device *adc = platform_get_drvdata(pdev);\r\niounmap(adc->regs);\r\nfree_irq(adc->irq, adc);\r\nclk_disable(adc->clk);\r\nregulator_disable(adc->vdd);\r\nregulator_put(adc->vdd);\r\nclk_put(adc->clk);\r\nkfree(adc);\r\nreturn 0;\r\n}\r\nstatic int s3c_adc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = container_of(dev,\r\nstruct platform_device, dev);\r\nstruct adc_device *adc = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nu32 con;\r\nspin_lock_irqsave(&adc->lock, flags);\r\ncon = readl(adc->regs + S3C2410_ADCCON);\r\ncon |= S3C2410_ADCCON_STDBM;\r\nwritel(con, adc->regs + S3C2410_ADCCON);\r\ndisable_irq(adc->irq);\r\nspin_unlock_irqrestore(&adc->lock, flags);\r\nclk_disable(adc->clk);\r\nregulator_disable(adc->vdd);\r\nreturn 0;\r\n}\r\nstatic int s3c_adc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = container_of(dev,\r\nstruct platform_device, dev);\r\nstruct adc_device *adc = platform_get_drvdata(pdev);\r\nenum s3c_cpu_type cpu = platform_get_device_id(pdev)->driver_data;\r\nint ret;\r\nunsigned long tmp;\r\nret = regulator_enable(adc->vdd);\r\nif (ret)\r\nreturn ret;\r\nclk_enable(adc->clk);\r\nenable_irq(adc->irq);\r\ntmp = adc->prescale | S3C2410_ADCCON_PRSCEN;\r\nif (cpu == TYPE_ADCV12)\r\ntmp |= S3C2416_ADCCON_RESSEL;\r\nif (cpu == TYPE_ADCV2 || cpu == TYPE_ADCV3)\r\ntmp |= S3C64XX_ADCCON_RESSEL;\r\nwritel(tmp, adc->regs + S3C2410_ADCCON);\r\nreturn 0;\r\n}\r\nstatic int __init adc_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&s3c_adc_driver);\r\nif (ret)\r\nprintk(KERN_ERR "%s: failed to add adc driver\n", __func__);\r\nreturn ret;\r\n}
