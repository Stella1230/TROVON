static unsigned long aux_calc_rate(struct clk_hw *hw, unsigned long prate,\r\nint index)\r\n{\r\nstruct clk_aux *aux = to_clk_aux(hw);\r\nstruct aux_rate_tbl *rtbl = aux->rtbl;\r\nu8 eq = rtbl[index].eq ? 1 : 2;\r\nreturn (((prate / 10000) * rtbl[index].xscale) /\r\n(rtbl[index].yscale * eq)) * 10000;\r\n}\r\nstatic long clk_aux_round_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_aux *aux = to_clk_aux(hw);\r\nint unused;\r\nreturn clk_round_rate_index(hw, drate, *prate, aux_calc_rate,\r\naux->rtbl_cnt, &unused);\r\n}\r\nstatic unsigned long clk_aux_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_aux *aux = to_clk_aux(hw);\r\nunsigned int num = 1, den = 1, val, eqn;\r\nunsigned long flags = 0;\r\nif (aux->lock)\r\nspin_lock_irqsave(aux->lock, flags);\r\nval = readl_relaxed(aux->reg);\r\nif (aux->lock)\r\nspin_unlock_irqrestore(aux->lock, flags);\r\neqn = (val >> aux->masks->eq_sel_shift) & aux->masks->eq_sel_mask;\r\nif (eqn == aux->masks->eq1_mask)\r\nden = 2;\r\nnum = (val >> aux->masks->xscale_sel_shift) &\r\naux->masks->xscale_sel_mask;\r\nden *= (val >> aux->masks->yscale_sel_shift) &\r\naux->masks->yscale_sel_mask;\r\nif (!den)\r\nreturn 0;\r\nreturn (((parent_rate / 10000) * num) / den) * 10000;\r\n}\r\nstatic int clk_aux_set_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long prate)\r\n{\r\nstruct clk_aux *aux = to_clk_aux(hw);\r\nstruct aux_rate_tbl *rtbl = aux->rtbl;\r\nunsigned long val, flags = 0;\r\nint i;\r\nclk_round_rate_index(hw, drate, prate, aux_calc_rate, aux->rtbl_cnt,\r\n&i);\r\nif (aux->lock)\r\nspin_lock_irqsave(aux->lock, flags);\r\nval = readl_relaxed(aux->reg) &\r\n~(aux->masks->eq_sel_mask << aux->masks->eq_sel_shift);\r\nval |= (rtbl[i].eq & aux->masks->eq_sel_mask) <<\r\naux->masks->eq_sel_shift;\r\nval &= ~(aux->masks->xscale_sel_mask << aux->masks->xscale_sel_shift);\r\nval |= (rtbl[i].xscale & aux->masks->xscale_sel_mask) <<\r\naux->masks->xscale_sel_shift;\r\nval &= ~(aux->masks->yscale_sel_mask << aux->masks->yscale_sel_shift);\r\nval |= (rtbl[i].yscale & aux->masks->yscale_sel_mask) <<\r\naux->masks->yscale_sel_shift;\r\nwritel_relaxed(val, aux->reg);\r\nif (aux->lock)\r\nspin_unlock_irqrestore(aux->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *clk_register_aux(const char *aux_name, const char *gate_name,\r\nconst char *parent_name, unsigned long flags, void __iomem *reg,\r\nstruct aux_clk_masks *masks, struct aux_rate_tbl *rtbl,\r\nu8 rtbl_cnt, spinlock_t *lock, struct clk **gate_clk)\r\n{\r\nstruct clk_aux *aux;\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nif (!aux_name || !parent_name || !reg || !rtbl || !rtbl_cnt) {\r\npr_err("Invalid arguments passed");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\naux = kzalloc(sizeof(*aux), GFP_KERNEL);\r\nif (!aux) {\r\npr_err("could not allocate aux clk\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (!masks)\r\naux->masks = &default_aux_masks;\r\nelse\r\naux->masks = masks;\r\naux->reg = reg;\r\naux->rtbl = rtbl;\r\naux->rtbl_cnt = rtbl_cnt;\r\naux->lock = lock;\r\naux->hw.init = &init;\r\ninit.name = aux_name;\r\ninit.ops = &clk_aux_ops;\r\ninit.flags = flags;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclk = clk_register(NULL, &aux->hw);\r\nif (IS_ERR_OR_NULL(clk))\r\ngoto free_aux;\r\nif (gate_name) {\r\nstruct clk *tgate_clk;\r\ntgate_clk = clk_register_gate(NULL, gate_name, aux_name, 0, reg,\r\naux->masks->enable_bit, 0, lock);\r\nif (IS_ERR_OR_NULL(tgate_clk))\r\ngoto free_aux;\r\nif (gate_clk)\r\n*gate_clk = tgate_clk;\r\n}\r\nreturn clk;\r\nfree_aux:\r\nkfree(aux);\r\npr_err("clk register failed\n");\r\nreturn NULL;\r\n}
