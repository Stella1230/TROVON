static void hspi_write(struct hspi_priv *hspi, int reg, u32 val)\r\n{\r\niowrite32(val, hspi->addr + reg);\r\n}\r\nstatic u32 hspi_read(struct hspi_priv *hspi, int reg)\r\n{\r\nreturn ioread32(hspi->addr + reg);\r\n}\r\nstatic int hspi_status_check_timeout(struct hspi_priv *hspi, u32 mask, u32 val)\r\n{\r\nint t = 256;\r\nwhile (t--) {\r\nif ((mask & hspi_read(hspi, SPSR)) == val)\r\nreturn 0;\r\nmsleep(20);\r\n}\r\ndev_err(hspi->dev, "timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int hspi_prepare_transfer(struct spi_master *master)\r\n{\r\nstruct hspi_priv *hspi = spi_master_get_devdata(master);\r\npm_runtime_get_sync(hspi->dev);\r\nreturn 0;\r\n}\r\nstatic int hspi_unprepare_transfer(struct spi_master *master)\r\n{\r\nstruct hspi_priv *hspi = spi_master_get_devdata(master);\r\npm_runtime_put_sync(hspi->dev);\r\nreturn 0;\r\n}\r\nstatic void hspi_hw_setup(struct hspi_priv *hspi,\r\nstruct spi_message *msg,\r\nstruct spi_transfer *t)\r\n{\r\nstruct spi_device *spi = msg->spi;\r\nstruct device *dev = hspi->dev;\r\nu32 target_rate;\r\nu32 spcr, idiv_clk;\r\nu32 rate, best_rate, min, tmp;\r\ntarget_rate = t ? t->speed_hz : 0;\r\nif (!target_rate)\r\ntarget_rate = spi->max_speed_hz;\r\nmin = ~0;\r\nbest_rate = 0;\r\nspcr = 0;\r\nfor (idiv_clk = 0x00; idiv_clk <= 0x3F; idiv_clk++) {\r\nrate = clk_get_rate(hspi->clk);\r\nif (idiv_clk & (1 << 5))\r\nrate /= 128;\r\nelse\r\nrate /= 16;\r\nrate /= (((idiv_clk & 0x1F) + 1) * 2) ;\r\ntmp = abs(target_rate - rate);\r\nif (tmp < min) {\r\nmin = tmp;\r\nspcr = idiv_clk;\r\nbest_rate = rate;\r\n}\r\n}\r\nif (spi->mode & SPI_CPHA)\r\nspcr |= 1 << 7;\r\nif (spi->mode & SPI_CPOL)\r\nspcr |= 1 << 6;\r\ndev_dbg(dev, "speed %d/%d\n", target_rate, best_rate);\r\nhspi_write(hspi, SPCR, spcr);\r\nhspi_write(hspi, SPSR, 0x0);\r\nhspi_write(hspi, SPSCR, 0x1);\r\n}\r\nstatic int hspi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct hspi_priv *hspi = spi_master_get_devdata(master);\r\nstruct spi_transfer *t;\r\nu32 tx;\r\nu32 rx;\r\nint ret, i;\r\ndev_dbg(hspi->dev, "%s\n", __func__);\r\nret = 0;\r\nlist_for_each_entry(t, &msg->transfers, transfer_list) {\r\nhspi_hw_setup(hspi, msg, t);\r\nfor (i = 0; i < t->len; i++) {\r\nret = hspi_status_check_timeout(hspi, 0x1, 0);\r\nif (ret < 0)\r\nbreak;\r\ntx = 0;\r\nif (t->tx_buf)\r\ntx = (u32)((u8 *)t->tx_buf)[i];\r\nhspi_write(hspi, SPTBR, tx);\r\nret = hspi_status_check_timeout(hspi, 0x4, 0x4);\r\nif (ret < 0)\r\nbreak;\r\nrx = hspi_read(hspi, SPRBR);\r\nif (t->rx_buf)\r\n((u8 *)t->rx_buf)[i] = (u8)rx;\r\n}\r\nmsg->actual_length += t->len;\r\n}\r\nmsg->status = ret;\r\nspi_finalize_current_message(master);\r\nreturn ret;\r\n}\r\nstatic int hspi_setup(struct spi_device *spi)\r\n{\r\nstruct hspi_priv *hspi = spi_master_get_devdata(spi->master);\r\nstruct device *dev = hspi->dev;\r\nif (8 != spi->bits_per_word) {\r\ndev_err(dev, "bits_per_word should be 8\n");\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "%s setup\n", spi->modalias);\r\nreturn 0;\r\n}\r\nstatic void hspi_cleanup(struct spi_device *spi)\r\n{\r\nstruct hspi_priv *hspi = spi_master_get_devdata(spi->master);\r\nstruct device *dev = hspi->dev;\r\ndev_dbg(dev, "%s cleanup\n", spi->modalias);\r\n}\r\nstatic int __devinit hspi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct spi_master *master;\r\nstruct hspi_priv *hspi;\r\nstruct clk *clk;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "invalid resource\n");\r\nreturn -EINVAL;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*hspi));\r\nif (!master) {\r\ndev_err(&pdev->dev, "spi_alloc_master error.\n");\r\nreturn -ENOMEM;\r\n}\r\nclk = clk_get(NULL, "shyway_clk");\r\nif (!clk) {\r\ndev_err(&pdev->dev, "shyway_clk is required\n");\r\nret = -EINVAL;\r\ngoto error0;\r\n}\r\nhspi = spi_master_get_devdata(master);\r\ndev_set_drvdata(&pdev->dev, hspi);\r\nhspi->master = master;\r\nhspi->dev = &pdev->dev;\r\nhspi->clk = clk;\r\nhspi->addr = devm_ioremap(hspi->dev,\r\nres->start, resource_size(res));\r\nif (!hspi->addr) {\r\ndev_err(&pdev->dev, "ioremap error.\n");\r\nret = -ENOMEM;\r\ngoto error1;\r\n}\r\nmaster->num_chipselect = 1;\r\nmaster->bus_num = pdev->id;\r\nmaster->setup = hspi_setup;\r\nmaster->cleanup = hspi_cleanup;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->prepare_transfer_hardware = hspi_prepare_transfer;\r\nmaster->transfer_one_message = hspi_transfer_one_message;\r\nmaster->unprepare_transfer_hardware = hspi_unprepare_transfer;\r\nret = spi_register_master(master);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "spi_register_master error.\n");\r\ngoto error2;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\ndev_info(&pdev->dev, "probed\n");\r\nreturn 0;\r\nerror2:\r\ndevm_iounmap(hspi->dev, hspi->addr);\r\nerror1:\r\nclk_put(clk);\r\nerror0:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int __devexit hspi_remove(struct platform_device *pdev)\r\n{\r\nstruct hspi_priv *hspi = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nclk_put(hspi->clk);\r\nspi_unregister_master(hspi->master);\r\ndevm_iounmap(hspi->dev, hspi->addr);\r\nreturn 0;\r\n}
