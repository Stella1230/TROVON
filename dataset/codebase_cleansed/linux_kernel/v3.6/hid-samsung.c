static inline void samsung_irda_dev_trace(struct hid_device *hdev,\r\nunsigned int rsize)\r\n{\r\nhid_info(hdev, "fixing up Samsung IrDA %d byte report descriptor\n",\r\nrsize);\r\n}\r\nstatic __u8 *samsung_irda_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nif (*rsize == 184 && rdesc[175] == 0x25 && rdesc[176] == 0x40 &&\r\nrdesc[177] == 0x75 && rdesc[178] == 0x30 &&\r\nrdesc[179] == 0x95 && rdesc[180] == 0x01 &&\r\nrdesc[182] == 0x40) {\r\nsamsung_irda_dev_trace(hdev, 184);\r\nrdesc[176] = 0xff;\r\nrdesc[178] = 0x08;\r\nrdesc[180] = 0x06;\r\nrdesc[182] = 0x42;\r\n} else\r\nif (*rsize == 203 && rdesc[192] == 0x15 && rdesc[193] == 0x0 &&\r\nrdesc[194] == 0x25 && rdesc[195] == 0x12) {\r\nsamsung_irda_dev_trace(hdev, 203);\r\nrdesc[193] = 0x1;\r\nrdesc[195] = 0xf;\r\n} else\r\nif (*rsize == 135 && rdesc[124] == 0x15 && rdesc[125] == 0x0 &&\r\nrdesc[126] == 0x25 && rdesc[127] == 0x11) {\r\nsamsung_irda_dev_trace(hdev, 135);\r\nrdesc[125] = 0x1;\r\nrdesc[127] = 0xe;\r\n} else\r\nif (*rsize == 171 && rdesc[160] == 0x15 && rdesc[161] == 0x0 &&\r\nrdesc[162] == 0x25 && rdesc[163] == 0x01) {\r\nsamsung_irda_dev_trace(hdev, 171);\r\nrdesc[161] = 0x1;\r\nrdesc[163] = 0x3;\r\n}\r\nreturn rdesc;\r\n}\r\nstatic int samsung_kbd_mouse_input_mapping(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nunsigned short ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nif (1 != ifnum || HID_UP_CONSUMER != (usage->hid & HID_USAGE_PAGE))\r\nreturn 0;\r\ndbg_hid("samsung wireless keyboard/mouse input mapping event [0x%x]\n",\r\nusage->hid & HID_USAGE);\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x183: samsung_kbd_mouse_map_key_clear(KEY_MEDIA); break;\r\ncase 0x195: samsung_kbd_mouse_map_key_clear(KEY_EMAIL); break;\r\ncase 0x196: samsung_kbd_mouse_map_key_clear(KEY_CALC); break;\r\ncase 0x197: samsung_kbd_mouse_map_key_clear(KEY_COMPUTER); break;\r\ncase 0x22b: samsung_kbd_mouse_map_key_clear(KEY_SEARCH); break;\r\ncase 0x22c: samsung_kbd_mouse_map_key_clear(KEY_WWW); break;\r\ncase 0x22d: samsung_kbd_mouse_map_key_clear(KEY_BACK); break;\r\ncase 0x22e: samsung_kbd_mouse_map_key_clear(KEY_FORWARD); break;\r\ncase 0x22f: samsung_kbd_mouse_map_key_clear(KEY_FAVORITES); break;\r\ncase 0x230: samsung_kbd_mouse_map_key_clear(KEY_REFRESH); break;\r\ncase 0x231: samsung_kbd_mouse_map_key_clear(KEY_STOP); break;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic __u8 *samsung_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nif (USB_DEVICE_ID_SAMSUNG_IR_REMOTE == hdev->product)\r\nrdesc = samsung_irda_report_fixup(hdev, rdesc, rsize);\r\nreturn rdesc;\r\n}\r\nstatic int samsung_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nint ret = 0;\r\nif (USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE == hdev->product)\r\nret = samsung_kbd_mouse_input_mapping(hdev,\r\nhi, field, usage, bit, max);\r\nreturn ret;\r\n}\r\nstatic int samsung_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint ret;\r\nunsigned int cmask = HID_CONNECT_DEFAULT;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto err_free;\r\n}\r\nif (USB_DEVICE_ID_SAMSUNG_IR_REMOTE == hdev->product) {\r\nif (hdev->rsize == 184) {\r\ncmask = (cmask & ~HID_CONNECT_HIDINPUT) |\r\nHID_CONNECT_HIDDEV_FORCE;\r\n}\r\n}\r\nret = hid_hw_start(hdev, cmask);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nreturn 0;\r\nerr_free:\r\nreturn ret;\r\n}\r\nstatic int __init samsung_init(void)\r\n{\r\nreturn hid_register_driver(&samsung_driver);\r\n}\r\nstatic void __exit samsung_exit(void)\r\n{\r\nhid_unregister_driver(&samsung_driver);\r\n}
