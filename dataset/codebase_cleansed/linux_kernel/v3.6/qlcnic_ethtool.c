static int qlcnic_get_regs_len(struct net_device *dev)\r\n{\r\nreturn sizeof(diag_registers) + QLCNIC_RING_REGS_LEN +\r\nQLCNIC_DEV_INFO_SIZE + 1;\r\n}\r\nstatic int qlcnic_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn QLCNIC_FLASH_TOTAL_SIZE;\r\n}\r\nstatic void\r\nqlcnic_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 fw_major, fw_minor, fw_build;\r\nfw_major = QLCRD32(adapter, QLCNIC_FW_VERSION_MAJOR);\r\nfw_minor = QLCRD32(adapter, QLCNIC_FW_VERSION_MINOR);\r\nfw_build = QLCRD32(adapter, QLCNIC_FW_VERSION_SUB);\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%d.%d.%d", fw_major, fw_minor, fw_build);\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\nstrlcpy(drvinfo->driver, qlcnic_driver_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, QLCNIC_LINUX_VERSIONID,\r\nsizeof(drvinfo->version));\r\n}\r\nstatic int\r\nqlcnic_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint check_sfp_module = 0;\r\nif (adapter->ahw->port_type == QLCNIC_GBE) {\r\necmd->supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Half |\r\nSUPPORTED_1000baseT_Full);\r\necmd->advertising = (ADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full);\r\nethtool_cmd_speed_set(ecmd, adapter->link_speed);\r\necmd->duplex = adapter->link_duplex;\r\necmd->autoneg = adapter->link_autoneg;\r\n} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\r\nu32 val;\r\nval = QLCRD32(adapter, QLCNIC_PORT_MODE_ADDR);\r\nif (val == QLCNIC_PORT_MODE_802_3_AP) {\r\necmd->supported = SUPPORTED_1000baseT_Full;\r\necmd->advertising = ADVERTISED_1000baseT_Full;\r\n} else {\r\necmd->supported = SUPPORTED_10000baseT_Full;\r\necmd->advertising = ADVERTISED_10000baseT_Full;\r\n}\r\nif (netif_running(dev) && adapter->has_link_events) {\r\nethtool_cmd_speed_set(ecmd, adapter->link_speed);\r\necmd->autoneg = adapter->link_autoneg;\r\necmd->duplex = adapter->link_duplex;\r\ngoto skip;\r\n}\r\nethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);\r\necmd->duplex = DUPLEX_UNKNOWN;\r\necmd->autoneg = AUTONEG_DISABLE;\r\n} else\r\nreturn -EIO;\r\nskip:\r\necmd->phy_address = adapter->physical_port;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nswitch (adapter->ahw->board_type) {\r\ncase QLCNIC_BRDTYPE_P3P_REF_QG:\r\ncase QLCNIC_BRDTYPE_P3P_4_GB:\r\ncase QLCNIC_BRDTYPE_P3P_4_GB_MM:\r\necmd->supported |= SUPPORTED_Autoneg;\r\necmd->advertising |= ADVERTISED_Autoneg;\r\ncase QLCNIC_BRDTYPE_P3P_10G_CX4:\r\ncase QLCNIC_BRDTYPE_P3P_10G_CX4_LP:\r\ncase QLCNIC_BRDTYPE_P3P_10000_BASE_T:\r\necmd->supported |= SUPPORTED_TP;\r\necmd->advertising |= ADVERTISED_TP;\r\necmd->port = PORT_TP;\r\necmd->autoneg = adapter->link_autoneg;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_IMEZ:\r\ncase QLCNIC_BRDTYPE_P3P_XG_LOM:\r\ncase QLCNIC_BRDTYPE_P3P_HMEZ:\r\necmd->supported |= SUPPORTED_MII;\r\necmd->advertising |= ADVERTISED_MII;\r\necmd->port = PORT_MII;\r\necmd->autoneg = AUTONEG_DISABLE;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_PLUS:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_CT:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_QT:\r\necmd->advertising |= ADVERTISED_TP;\r\necmd->supported |= SUPPORTED_TP;\r\ncheck_sfp_module = netif_running(dev) &&\r\nadapter->has_link_events;\r\ncase QLCNIC_BRDTYPE_P3P_10G_XFP:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_FIBRE;\r\necmd->autoneg = AUTONEG_DISABLE;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_10G_TP:\r\nif (adapter->ahw->port_type == QLCNIC_XGBE) {\r\necmd->autoneg = AUTONEG_DISABLE;\r\necmd->supported |= (SUPPORTED_FIBRE | SUPPORTED_TP);\r\necmd->advertising |=\r\n(ADVERTISED_FIBRE | ADVERTISED_TP);\r\necmd->port = PORT_FIBRE;\r\ncheck_sfp_module = netif_running(dev) &&\r\nadapter->has_link_events;\r\n} else {\r\necmd->autoneg = AUTONEG_ENABLE;\r\necmd->supported |= (SUPPORTED_TP | SUPPORTED_Autoneg);\r\necmd->advertising |=\r\n(ADVERTISED_TP | ADVERTISED_Autoneg);\r\necmd->port = PORT_TP;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->pdev->dev, "Unsupported board model %d\n",\r\nadapter->ahw->board_type);\r\nreturn -EIO;\r\n}\r\nif (check_sfp_module) {\r\nswitch (adapter->module_type) {\r\ncase LINKEVENT_MODULE_OPTICAL_UNKNOWN:\r\ncase LINKEVENT_MODULE_OPTICAL_SRLR:\r\ncase LINKEVENT_MODULE_OPTICAL_LRM:\r\ncase LINKEVENT_MODULE_OPTICAL_SFP_1G:\r\necmd->port = PORT_FIBRE;\r\nbreak;\r\ncase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLE:\r\ncase LINKEVENT_MODULE_TWINAX_UNSUPPORTED_CABLELEN:\r\ncase LINKEVENT_MODULE_TWINAX:\r\necmd->port = PORT_TP;\r\nbreak;\r\ndefault:\r\necmd->port = PORT_OTHER;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nu32 config = 0;\r\nu32 ret = 0;\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nif (adapter->ahw->port_type != QLCNIC_GBE)\r\nreturn -EOPNOTSUPP;\r\nif (ecmd->duplex)\r\nconfig |= 0x1;\r\nif (ecmd->autoneg)\r\nconfig |= 0x2;\r\nswitch (ethtool_cmd_speed(ecmd)) {\r\ncase SPEED_10:\r\nconfig |= (0 << 8);\r\nbreak;\r\ncase SPEED_100:\r\nconfig |= (1 << 8);\r\nbreak;\r\ncase SPEED_1000:\r\nconfig |= (10 << 8);\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nret = qlcnic_fw_cmd_set_port(adapter, config);\r\nif (ret == QLCNIC_RCODE_NOT_SUPPORTED)\r\nreturn -EOPNOTSUPP;\r\nelse if (ret)\r\nreturn -EIO;\r\nadapter->link_speed = ethtool_cmd_speed(ecmd);\r\nadapter->link_duplex = ecmd->duplex;\r\nadapter->link_autoneg = ecmd->autoneg;\r\nif (!netif_running(dev))\r\nreturn 0;\r\ndev->netdev_ops->ndo_stop(dev);\r\nreturn dev->netdev_ops->ndo_open(dev);\r\n}\r\nstatic void\r\nqlcnic_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nu32 *regs_buff = p;\r\nint ring, i = 0, j = 0;\r\nmemset(p, 0, qlcnic_get_regs_len(dev));\r\nregs->version = (QLCNIC_ETHTOOL_REGS_VER << 24) |\r\n(adapter->ahw->revision_id << 16) | (adapter->pdev)->device;\r\nregs_buff[0] = (0xcafe0000 | (QLCNIC_DEV_INFO_SIZE & 0xffff));\r\nregs_buff[1] = QLCNIC_MGMT_API_VERSION;\r\nfor (i = QLCNIC_DEV_INFO_SIZE + 1; diag_registers[j] != -1; j++, i++)\r\nregs_buff[i] = QLCRD32(adapter, diag_registers[j]);\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\nreturn;\r\nregs_buff[i++] = 0xFFEFCDAB;\r\nregs_buff[i++] = 1;\r\nregs_buff[i++] = le32_to_cpu(*(adapter->tx_ring->hw_consumer));\r\nregs_buff[i++] = readl(adapter->tx_ring->crb_cmd_producer);\r\nregs_buff[i++] = 2;\r\nregs_buff[i++] = readl(recv_ctx->rds_rings[0].crb_rcv_producer);\r\nregs_buff[i++] = readl(recv_ctx->rds_rings[1].crb_rcv_producer);\r\nregs_buff[i++] = adapter->max_sds_rings;\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &(recv_ctx->sds_rings[ring]);\r\nregs_buff[i++] = readl(sds_ring->crb_sts_consumer);\r\n}\r\n}\r\nstatic u32 qlcnic_test_link(struct net_device *dev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 val;\r\nval = QLCRD32(adapter, CRB_XG_STATE_P3P);\r\nval = XG_LINK_STATE_P3P(adapter->ahw->pci_func, val);\r\nreturn (val == XG_LINK_UP_P3P) ? 0 : 1;\r\n}\r\nstatic int\r\nqlcnic_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\r\nu8 *bytes)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint offset;\r\nint ret;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\neeprom->magic = (adapter->pdev)->vendor |\r\n((adapter->pdev)->device << 16);\r\noffset = eeprom->offset;\r\nret = qlcnic_rom_fast_read_words(adapter, offset, bytes,\r\neeprom->len);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void\r\nqlcnic_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nring->rx_pending = adapter->num_rxd;\r\nring->rx_jumbo_pending = adapter->num_jumbo_rxd;\r\nring->tx_pending = adapter->num_txd;\r\nring->rx_max_pending = adapter->max_rxd;\r\nring->rx_jumbo_max_pending = adapter->max_jumbo_rxd;\r\nring->tx_max_pending = MAX_CMD_DESCRIPTORS;\r\n}\r\nstatic u32\r\nqlcnic_validate_ringparam(u32 val, u32 min, u32 max, char *r_name)\r\n{\r\nu32 num_desc;\r\nnum_desc = max(val, min);\r\nnum_desc = min(num_desc, max);\r\nnum_desc = roundup_pow_of_two(num_desc);\r\nif (val != num_desc) {\r\nprintk(KERN_INFO "%s: setting %s ring size %d instead of %d\n",\r\nqlcnic_driver_name, r_name, num_desc, val);\r\n}\r\nreturn num_desc;\r\n}\r\nstatic int\r\nqlcnic_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu16 num_rxd, num_jumbo_rxd, num_txd;\r\nif (ring->rx_mini_pending)\r\nreturn -EOPNOTSUPP;\r\nnum_rxd = qlcnic_validate_ringparam(ring->rx_pending,\r\nMIN_RCV_DESCRIPTORS, adapter->max_rxd, "rx");\r\nnum_jumbo_rxd = qlcnic_validate_ringparam(ring->rx_jumbo_pending,\r\nMIN_JUMBO_DESCRIPTORS, adapter->max_jumbo_rxd,\r\n"rx jumbo");\r\nnum_txd = qlcnic_validate_ringparam(ring->tx_pending,\r\nMIN_CMD_DESCRIPTORS, MAX_CMD_DESCRIPTORS, "tx");\r\nif (num_rxd == adapter->num_rxd && num_txd == adapter->num_txd &&\r\nnum_jumbo_rxd == adapter->num_jumbo_rxd)\r\nreturn 0;\r\nadapter->num_rxd = num_rxd;\r\nadapter->num_jumbo_rxd = num_jumbo_rxd;\r\nadapter->num_txd = num_txd;\r\nreturn qlcnic_reset_context(adapter);\r\n}\r\nstatic void qlcnic_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nchannel->max_rx = rounddown_pow_of_two(min_t(int,\r\nadapter->max_rx_ques, num_online_cpus()));\r\nchannel->max_tx = adapter->max_tx_ques;\r\nchannel->rx_count = adapter->max_sds_rings;\r\nchannel->tx_count = adapter->max_tx_ques;\r\n}\r\nstatic int qlcnic_set_channels(struct net_device *dev,\r\nstruct ethtool_channels *channel)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint err;\r\nif (channel->other_count || channel->combined_count ||\r\nchannel->tx_count != channel->max_tx)\r\nreturn -EINVAL;\r\nerr = qlcnic_validate_max_rss(dev, channel->max_rx, channel->rx_count);\r\nif (err)\r\nreturn err;\r\nerr = qlcnic_set_max_rss(adapter, channel->rx_count);\r\nnetdev_info(dev, "allocated 0x%x sds rings\n",\r\nadapter->max_sds_rings);\r\nreturn err;\r\n}\r\nstatic void\r\nqlcnic_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint port = adapter->physical_port;\r\n__u32 val;\r\nif (adapter->ahw->port_type == QLCNIC_GBE) {\r\nif ((port < 0) || (port > QLCNIC_NIU_MAX_GBE_PORTS))\r\nreturn;\r\nval = QLCRD32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port));\r\npause->rx_pause = qlcnic_gb_get_rx_flowctl(val);\r\nval = QLCRD32(adapter, QLCNIC_NIU_GB_PAUSE_CTL);\r\nswitch (port) {\r\ncase 0:\r\npause->tx_pause = !(qlcnic_gb_get_gb0_mask(val));\r\nbreak;\r\ncase 1:\r\npause->tx_pause = !(qlcnic_gb_get_gb1_mask(val));\r\nbreak;\r\ncase 2:\r\npause->tx_pause = !(qlcnic_gb_get_gb2_mask(val));\r\nbreak;\r\ncase 3:\r\ndefault:\r\npause->tx_pause = !(qlcnic_gb_get_gb3_mask(val));\r\nbreak;\r\n}\r\n} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\r\nif ((port < 0) || (port > QLCNIC_NIU_MAX_XG_PORTS))\r\nreturn;\r\npause->rx_pause = 1;\r\nval = QLCRD32(adapter, QLCNIC_NIU_XG_PAUSE_CTL);\r\nif (port == 0)\r\npause->tx_pause = !(qlcnic_xg_get_xg0_mask(val));\r\nelse\r\npause->tx_pause = !(qlcnic_xg_get_xg1_mask(val));\r\n} else {\r\ndev_err(&netdev->dev, "Unknown board type: %x\n",\r\nadapter->ahw->port_type);\r\n}\r\n}\r\nstatic int\r\nqlcnic_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint port = adapter->physical_port;\r\n__u32 val;\r\nif (adapter->ahw->port_type == QLCNIC_GBE) {\r\nif ((port < 0) || (port > QLCNIC_NIU_MAX_GBE_PORTS))\r\nreturn -EIO;\r\nval = QLCRD32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port));\r\nif (pause->rx_pause)\r\nqlcnic_gb_rx_flowctl(val);\r\nelse\r\nqlcnic_gb_unset_rx_flowctl(val);\r\nQLCWR32(adapter, QLCNIC_NIU_GB_MAC_CONFIG_0(port),\r\nval);\r\nval = QLCRD32(adapter, QLCNIC_NIU_GB_PAUSE_CTL);\r\nswitch (port) {\r\ncase 0:\r\nif (pause->tx_pause)\r\nqlcnic_gb_unset_gb0_mask(val);\r\nelse\r\nqlcnic_gb_set_gb0_mask(val);\r\nbreak;\r\ncase 1:\r\nif (pause->tx_pause)\r\nqlcnic_gb_unset_gb1_mask(val);\r\nelse\r\nqlcnic_gb_set_gb1_mask(val);\r\nbreak;\r\ncase 2:\r\nif (pause->tx_pause)\r\nqlcnic_gb_unset_gb2_mask(val);\r\nelse\r\nqlcnic_gb_set_gb2_mask(val);\r\nbreak;\r\ncase 3:\r\ndefault:\r\nif (pause->tx_pause)\r\nqlcnic_gb_unset_gb3_mask(val);\r\nelse\r\nqlcnic_gb_set_gb3_mask(val);\r\nbreak;\r\n}\r\nQLCWR32(adapter, QLCNIC_NIU_GB_PAUSE_CTL, val);\r\n} else if (adapter->ahw->port_type == QLCNIC_XGBE) {\r\nif (!pause->rx_pause || pause->autoneg)\r\nreturn -EOPNOTSUPP;\r\nif ((port < 0) || (port > QLCNIC_NIU_MAX_XG_PORTS))\r\nreturn -EIO;\r\nval = QLCRD32(adapter, QLCNIC_NIU_XG_PAUSE_CTL);\r\nif (port == 0) {\r\nif (pause->tx_pause)\r\nqlcnic_xg_unset_xg0_mask(val);\r\nelse\r\nqlcnic_xg_set_xg0_mask(val);\r\n} else {\r\nif (pause->tx_pause)\r\nqlcnic_xg_unset_xg1_mask(val);\r\nelse\r\nqlcnic_xg_set_xg1_mask(val);\r\n}\r\nQLCWR32(adapter, QLCNIC_NIU_XG_PAUSE_CTL, val);\r\n} else {\r\ndev_err(&netdev->dev, "Unknown board type: %x\n",\r\nadapter->ahw->port_type);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_reg_test(struct net_device *dev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 data_read;\r\ndata_read = QLCRD32(adapter, QLCNIC_PCIX_PH_REG(0));\r\nif ((data_read & 0xffff) != adapter->pdev->vendor)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn QLCNIC_TEST_LEN;\r\ncase ETH_SS_STATS:\r\nif (adapter->flags & QLCNIC_ESWITCH_ENABLED)\r\nreturn QLCNIC_TOTAL_STATS_LEN + QLCNIC_DEVICE_STATS_LEN;\r\nreturn QLCNIC_TOTAL_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int qlcnic_irq_test(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint max_sds_rings = adapter->max_sds_rings;\r\nint ret;\r\nstruct qlcnic_cmd_args cmd;\r\nif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EIO;\r\nret = qlcnic_diag_alloc_res(netdev, QLCNIC_INTERRUPT_TEST);\r\nif (ret)\r\ngoto clear_it;\r\nadapter->diag_cnt = 0;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = QLCNIC_CDRP_CMD_INTRPT_TEST;\r\ncmd.req.arg1 = adapter->ahw->pci_func;\r\nqlcnic_issue_cmd(adapter, &cmd);\r\nret = cmd.rsp.cmd;\r\nif (ret)\r\ngoto done;\r\nmsleep(10);\r\nret = !adapter->diag_cnt;\r\ndone:\r\nqlcnic_diag_free_res(netdev, max_sds_rings);\r\nclear_it:\r\nadapter->max_sds_rings = max_sds_rings;\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn ret;\r\n}\r\nstatic void qlcnic_create_loopback_buff(unsigned char *data, u8 mac[])\r\n{\r\nunsigned char random_data[] = {0xa8, 0x06, 0x45, 0x00};\r\nmemset(data, 0x4e, QLCNIC_ILB_PKT_SIZE);\r\nmemcpy(data, mac, ETH_ALEN);\r\nmemcpy(data + ETH_ALEN, mac, ETH_ALEN);\r\nmemcpy(data + 2 * ETH_ALEN, random_data, sizeof(random_data));\r\n}\r\nint qlcnic_check_loopback_buff(unsigned char *data, u8 mac[])\r\n{\r\nunsigned char buff[QLCNIC_ILB_PKT_SIZE];\r\nqlcnic_create_loopback_buff(buff, mac);\r\nreturn memcmp(data, buff, QLCNIC_ILB_PKT_SIZE);\r\n}\r\nstatic int qlcnic_do_lb_test(struct qlcnic_adapter *adapter, u8 mode)\r\n{\r\nstruct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;\r\nstruct qlcnic_host_sds_ring *sds_ring = &recv_ctx->sds_rings[0];\r\nstruct sk_buff *skb;\r\nint i, loop, cnt = 0;\r\nfor (i = 0; i < QLCNIC_NUM_ILB_PKT; i++) {\r\nskb = netdev_alloc_skb(adapter->netdev, QLCNIC_ILB_PKT_SIZE);\r\nqlcnic_create_loopback_buff(skb->data, adapter->mac_addr);\r\nskb_put(skb, QLCNIC_ILB_PKT_SIZE);\r\nadapter->diag_cnt = 0;\r\nqlcnic_xmit_frame(skb, adapter->netdev);\r\nloop = 0;\r\ndo {\r\nmsleep(1);\r\nqlcnic_process_rcv_ring_diag(sds_ring);\r\nif (loop++ > QLCNIC_ILB_MAX_RCV_LOOP)\r\nbreak;\r\n} while (!adapter->diag_cnt);\r\ndev_kfree_skb_any(skb);\r\nif (!adapter->diag_cnt)\r\nQLCDB(adapter, DRV,\r\n"LB Test: packet #%d was not received\n", i + 1);\r\nelse\r\ncnt++;\r\n}\r\nif (cnt != i) {\r\ndev_warn(&adapter->pdev->dev, "LB Test failed\n");\r\nif (mode != QLCNIC_ILB_MODE) {\r\ndev_warn(&adapter->pdev->dev,\r\n"WARNING: Please make sure external"\r\n"loopback connector is plugged in\n");\r\n}\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_loopback_test(struct net_device *netdev, u8 mode)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint max_sds_rings = adapter->max_sds_rings;\r\nstruct qlcnic_host_sds_ring *sds_ring;\r\nint loop = 0;\r\nint ret;\r\nif (!(adapter->capabilities & QLCNIC_FW_CAPABILITY_MULTI_LOOPBACK)) {\r\nnetdev_info(netdev, "Firmware is not loopback test capable\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nQLCDB(adapter, DRV, "%s loopback test in progress\n",\r\nmode == QLCNIC_ILB_MODE ? "internal" : "external");\r\nif (adapter->op_mode == QLCNIC_NON_PRIV_FUNC) {\r\nnetdev_warn(netdev, "Loopback test not supported for non "\r\n"privilege function\n");\r\nreturn 0;\r\n}\r\nif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EBUSY;\r\nret = qlcnic_diag_alloc_res(netdev, QLCNIC_LOOPBACK_TEST);\r\nif (ret)\r\ngoto clear_it;\r\nsds_ring = &adapter->recv_ctx->sds_rings[0];\r\nret = qlcnic_set_lb_mode(adapter, mode);\r\nif (ret)\r\ngoto free_res;\r\nadapter->diag_cnt = 0;\r\ndo {\r\nmsleep(500);\r\nqlcnic_process_rcv_ring_diag(sds_ring);\r\nif (loop++ > QLCNIC_ILB_MAX_RCV_LOOP) {\r\nnetdev_info(netdev, "firmware didnt respond to loopback"\r\n" configure request\n");\r\nret = -QLCNIC_FW_NOT_RESPOND;\r\ngoto free_res;\r\n} else if (adapter->diag_cnt) {\r\nret = adapter->diag_cnt;\r\ngoto free_res;\r\n}\r\n} while (!QLCNIC_IS_LB_CONFIGURED(adapter->ahw->loopback_state));\r\nret = qlcnic_do_lb_test(adapter, mode);\r\nqlcnic_clear_lb_mode(adapter);\r\nfree_res:\r\nqlcnic_diag_free_res(netdev, max_sds_rings);\r\nclear_it:\r\nadapter->max_sds_rings = max_sds_rings;\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn ret;\r\n}\r\nstatic void\r\nqlcnic_diag_test(struct net_device *dev, struct ethtool_test *eth_test,\r\nu64 *data)\r\n{\r\nmemset(data, 0, sizeof(u64) * QLCNIC_TEST_LEN);\r\ndata[0] = qlcnic_reg_test(dev);\r\nif (data[0])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ndata[1] = (u64) qlcnic_test_link(dev);\r\nif (data[1])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif (eth_test->flags & ETH_TEST_FL_OFFLINE) {\r\ndata[2] = qlcnic_irq_test(dev);\r\nif (data[2])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ndata[3] = qlcnic_loopback_test(dev, QLCNIC_ILB_MODE);\r\nif (data[3])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif (eth_test->flags & ETH_TEST_FL_EXTERNAL_LB) {\r\ndata[4] = qlcnic_loopback_test(dev, QLCNIC_ELB_MODE);\r\nif (data[4])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\neth_test->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\r\n}\r\n}\r\n}\r\nstatic void\r\nqlcnic_get_strings(struct net_device *dev, u32 stringset, u8 * data)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint index, i, j;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nmemcpy(data, *qlcnic_gstrings_test,\r\nQLCNIC_TEST_LEN * ETH_GSTRING_LEN);\r\nbreak;\r\ncase ETH_SS_STATS:\r\nfor (index = 0; index < QLCNIC_STATS_LEN; index++) {\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_gstrings_stats[index].stat_string,\r\nETH_GSTRING_LEN);\r\n}\r\nfor (j = 0; j < QLCNIC_MAC_STATS_LEN; index++, j++) {\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_mac_stats_strings[j],\r\nETH_GSTRING_LEN);\r\n}\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\r\nreturn;\r\nfor (i = 0; i < QLCNIC_DEVICE_STATS_LEN; index++, i++) {\r\nmemcpy(data + index * ETH_GSTRING_LEN,\r\nqlcnic_device_gstrings_stats[i],\r\nETH_GSTRING_LEN);\r\n}\r\n}\r\n}\r\nstatic void\r\nqlcnic_fill_stats(int *index, u64 *data, void *stats, int type)\r\n{\r\nint ind = *index;\r\nif (type == QLCNIC_MAC_STATS) {\r\nstruct qlcnic_mac_statistics *mac_stats =\r\n(struct qlcnic_mac_statistics *)stats;\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_frames);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_bytes);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_mcast_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_bcast_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_pause_cnt);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_ctrl_pkt);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_64b_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_127b_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_255b_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_tx_lt_511b_pkts);\r\ndata[ind++] =\r\nQLCNIC_FILL_STATS(mac_stats->mac_tx_lt_1023b_pkts);\r\ndata[ind++] =\r\nQLCNIC_FILL_STATS(mac_stats->mac_tx_lt_1518b_pkts);\r\ndata[ind++] =\r\nQLCNIC_FILL_STATS(mac_stats->mac_tx_gt_1518b_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_frames);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_bytes);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_mcast_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_bcast_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_pause_cnt);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_ctrl_pkt);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_64b_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_127b_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_255b_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_lt_511b_pkts);\r\ndata[ind++] =\r\nQLCNIC_FILL_STATS(mac_stats->mac_rx_lt_1023b_pkts);\r\ndata[ind++] =\r\nQLCNIC_FILL_STATS(mac_stats->mac_rx_lt_1518b_pkts);\r\ndata[ind++] =\r\nQLCNIC_FILL_STATS(mac_stats->mac_rx_gt_1518b_pkts);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_error);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_small);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_length_large);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_jabber);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_dropped);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_rx_crc_error);\r\ndata[ind++] = QLCNIC_FILL_STATS(mac_stats->mac_align_error);\r\n} else if (type == QLCNIC_ESW_STATS) {\r\nstruct __qlcnic_esw_statistics *esw_stats =\r\n(struct __qlcnic_esw_statistics *)stats;\r\ndata[ind++] = QLCNIC_FILL_STATS(esw_stats->unicast_frames);\r\ndata[ind++] = QLCNIC_FILL_STATS(esw_stats->multicast_frames);\r\ndata[ind++] = QLCNIC_FILL_STATS(esw_stats->broadcast_frames);\r\ndata[ind++] = QLCNIC_FILL_STATS(esw_stats->dropped_frames);\r\ndata[ind++] = QLCNIC_FILL_STATS(esw_stats->errors);\r\ndata[ind++] = QLCNIC_FILL_STATS(esw_stats->local_frames);\r\ndata[ind++] = QLCNIC_FILL_STATS(esw_stats->numbytes);\r\n}\r\n*index = ind;\r\n}\r\nstatic void\r\nqlcnic_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 * data)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nstruct qlcnic_esw_statistics port_stats;\r\nstruct qlcnic_mac_statistics mac_stats;\r\nint index, ret;\r\nfor (index = 0; index < QLCNIC_STATS_LEN; index++) {\r\nchar *p =\r\n(char *)adapter +\r\nqlcnic_gstrings_stats[index].stat_offset;\r\ndata[index] =\r\n(qlcnic_gstrings_stats[index].sizeof_stat ==\r\nsizeof(u64)) ? *(u64 *)p:(*(u32 *)p);\r\n}\r\nmemset(&mac_stats, 0, sizeof(struct qlcnic_mac_statistics));\r\nqlcnic_get_mac_stats(adapter, &mac_stats);\r\nqlcnic_fill_stats(&index, data, &mac_stats, QLCNIC_MAC_STATS);\r\nif (!(adapter->flags & QLCNIC_ESWITCH_ENABLED))\r\nreturn;\r\nmemset(&port_stats, 0, sizeof(struct qlcnic_esw_statistics));\r\nret = qlcnic_get_port_stats(adapter, adapter->ahw->pci_func,\r\nQLCNIC_QUERY_RX_COUNTER, &port_stats.rx);\r\nif (ret)\r\nreturn;\r\nqlcnic_fill_stats(&index, data, &port_stats.rx, QLCNIC_ESW_STATS);\r\nret = qlcnic_get_port_stats(adapter, adapter->ahw->pci_func,\r\nQLCNIC_QUERY_TX_COUNTER, &port_stats.tx);\r\nif (ret)\r\nreturn;\r\nqlcnic_fill_stats(&index, data, &port_stats.tx, QLCNIC_ESW_STATS);\r\n}\r\nstatic int qlcnic_set_led(struct net_device *dev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nint max_sds_rings = adapter->max_sds_rings;\r\nint err = -EIO, active = 1;\r\nif (adapter->op_mode == QLCNIC_NON_PRIV_FUNC) {\r\nnetdev_warn(dev, "LED test not supported for non "\r\n"privilege function\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nif (test_and_set_bit(__QLCNIC_LED_ENABLE, &adapter->state))\r\nreturn -EBUSY;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nbreak;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\r\nif (qlcnic_diag_alloc_res(dev, QLCNIC_LED_TEST))\r\nbreak;\r\nset_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state);\r\n}\r\nif (adapter->nic_ops->config_led(adapter, 1, 0xf) == 0) {\r\nerr = 0;\r\nbreak;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to set LED blink state.\n");\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nactive = 0;\r\nif (test_bit(__QLCNIC_RESETTING, &adapter->state))\r\nbreak;\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state)) {\r\nif (qlcnic_diag_alloc_res(dev, QLCNIC_LED_TEST))\r\nbreak;\r\nset_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state);\r\n}\r\nif (adapter->nic_ops->config_led(adapter, 0, 0xf))\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to reset LED blink state.\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (test_and_clear_bit(__QLCNIC_DIAG_RES_ALLOC, &adapter->state))\r\nqlcnic_diag_free_res(dev, max_sds_rings);\r\nif (!active || err)\r\nclear_bit(__QLCNIC_LED_ENABLE, &adapter->state);\r\nreturn err;\r\n}\r\nstatic void\r\nqlcnic_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 wol_cfg;\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV);\r\nif (wol_cfg & (1UL << adapter->portnum))\r\nwol->supported |= WAKE_MAGIC;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG);\r\nif (wol_cfg & (1UL << adapter->portnum))\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int\r\nqlcnic_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(dev);\r\nu32 wol_cfg;\r\nif (wol->wolopts & ~WAKE_MAGIC)\r\nreturn -EOPNOTSUPP;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV);\r\nif (!(wol_cfg & (1 << adapter->portnum)))\r\nreturn -EOPNOTSUPP;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG);\r\nif (wol->wolopts & WAKE_MAGIC)\r\nwol_cfg |= 1UL << adapter->portnum;\r\nelse\r\nwol_cfg &= ~(1UL << adapter->portnum);\r\nQLCWR32(adapter, QLCNIC_WOL_CONFIG, wol_cfg);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_set_intr_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ethcoal)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nif (!test_bit(__QLCNIC_DEV_UP, &adapter->state))\r\nreturn -EINVAL;\r\nif (ethcoal->rx_coalesce_usecs > 0xffff ||\r\nethcoal->rx_max_coalesced_frames > 0xffff ||\r\nethcoal->tx_coalesce_usecs ||\r\nethcoal->tx_max_coalesced_frames ||\r\nethcoal->rx_coalesce_usecs_irq ||\r\nethcoal->rx_max_coalesced_frames_irq ||\r\nethcoal->tx_coalesce_usecs_irq ||\r\nethcoal->tx_max_coalesced_frames_irq ||\r\nethcoal->stats_block_coalesce_usecs ||\r\nethcoal->use_adaptive_rx_coalesce ||\r\nethcoal->use_adaptive_tx_coalesce ||\r\nethcoal->pkt_rate_low ||\r\nethcoal->rx_coalesce_usecs_low ||\r\nethcoal->rx_max_coalesced_frames_low ||\r\nethcoal->tx_coalesce_usecs_low ||\r\nethcoal->tx_max_coalesced_frames_low ||\r\nethcoal->pkt_rate_high ||\r\nethcoal->rx_coalesce_usecs_high ||\r\nethcoal->rx_max_coalesced_frames_high ||\r\nethcoal->tx_coalesce_usecs_high ||\r\nethcoal->tx_max_coalesced_frames_high)\r\nreturn -EINVAL;\r\nif (!ethcoal->rx_coalesce_usecs ||\r\n!ethcoal->rx_max_coalesced_frames) {\r\nadapter->ahw->coal.flag = QLCNIC_INTR_DEFAULT;\r\nadapter->ahw->coal.rx_time_us =\r\nQLCNIC_DEFAULT_INTR_COALESCE_RX_TIME_US;\r\nadapter->ahw->coal.rx_packets =\r\nQLCNIC_DEFAULT_INTR_COALESCE_RX_PACKETS;\r\n} else {\r\nadapter->ahw->coal.flag = 0;\r\nadapter->ahw->coal.rx_time_us = ethcoal->rx_coalesce_usecs;\r\nadapter->ahw->coal.rx_packets =\r\nethcoal->rx_max_coalesced_frames;\r\n}\r\nqlcnic_config_intr_coalesce(adapter);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_get_intr_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ethcoal)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->is_up != QLCNIC_ADAPTER_UP_MAGIC)\r\nreturn -EINVAL;\r\nethcoal->rx_coalesce_usecs = adapter->ahw->coal.rx_time_us;\r\nethcoal->rx_max_coalesced_frames = adapter->ahw->coal.rx_packets;\r\nreturn 0;\r\n}\r\nstatic u32 qlcnic_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void qlcnic_set_msglevel(struct net_device *netdev, u32 msglvl)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nadapter->msg_enable = msglvl;\r\n}\r\nstatic int\r\nqlcnic_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(adapter->netdev, "FW Dump not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (fw_dump->clr)\r\ndump->len = fw_dump->tmpl_hdr->size + fw_dump->size;\r\nelse\r\ndump->len = 0;\r\nif (!fw_dump->enable)\r\ndump->flag = ETH_FW_DUMP_DISABLE;\r\nelse\r\ndump->flag = fw_dump->tmpl_hdr->drv_cap_mask;\r\ndump->version = adapter->fw_version;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,\r\nvoid *buffer)\r\n{\r\nint i, copy_sz;\r\nu32 *hdr_ptr, *data;\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW Dump not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (!fw_dump->clr) {\r\nnetdev_info(netdev, "Dump not available\n");\r\nreturn -EINVAL;\r\n}\r\ncopy_sz = fw_dump->tmpl_hdr->size;\r\nhdr_ptr = (u32 *) fw_dump->tmpl_hdr;\r\ndata = buffer;\r\nfor (i = 0; i < copy_sz/sizeof(u32); i++)\r\n*data++ = cpu_to_le32(*hdr_ptr++);\r\nmemcpy(buffer + copy_sz, fw_dump->data, fw_dump->size);\r\ndump->len = copy_sz + fw_dump->size;\r\ndump->flag = fw_dump->tmpl_hdr->drv_cap_mask;\r\nvfree(fw_dump->data);\r\nfw_dump->data = NULL;\r\nfw_dump->clr = 0;\r\nnetdev_info(netdev, "extracted the FW dump Successfully\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_set_dump(struct net_device *netdev, struct ethtool_dump *val)\r\n{\r\nint i;\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nu32 state;\r\nswitch (val->flag) {\r\ncase QLCNIC_FORCE_FW_DUMP_KEY:\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW dump not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (!fw_dump->enable) {\r\nnetdev_info(netdev, "FW dump not enabled\n");\r\nreturn 0;\r\n}\r\nif (fw_dump->clr) {\r\nnetdev_info(netdev,\r\n"Previous dump not cleared, not forcing dump\n");\r\nreturn 0;\r\n}\r\nnetdev_info(netdev, "Forcing a FW dump\n");\r\nqlcnic_dev_request_reset(adapter);\r\nbreak;\r\ncase QLCNIC_DISABLE_FW_DUMP:\r\nif (fw_dump->enable && fw_dump->tmpl_hdr) {\r\nnetdev_info(netdev, "Disabling FW dump\n");\r\nfw_dump->enable = 0;\r\n}\r\nreturn 0;\r\ncase QLCNIC_ENABLE_FW_DUMP:\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW dump not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (!fw_dump->enable) {\r\nnetdev_info(netdev, "Enabling FW dump\n");\r\nfw_dump->enable = 1;\r\n}\r\nreturn 0;\r\ncase QLCNIC_FORCE_FW_RESET:\r\nnetdev_info(netdev, "Forcing a FW reset\n");\r\nqlcnic_dev_request_reset(adapter);\r\nadapter->flags &= ~QLCNIC_FW_RESET_OWNER;\r\nreturn 0;\r\ncase QLCNIC_SET_QUIESCENT:\r\ncase QLCNIC_RESET_QUIESCENT:\r\nstate = QLCRD32(adapter, QLCNIC_CRB_DEV_STATE);\r\nif (state == QLCNIC_DEV_FAILED || (state == QLCNIC_DEV_BADBAD))\r\nnetdev_info(netdev, "Device in FAILED state\n");\r\nreturn 0;\r\ndefault:\r\nif (!fw_dump->tmpl_hdr) {\r\nnetdev_err(netdev, "FW dump not supported\n");\r\nreturn -ENOTSUPP;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(FW_DUMP_LEVELS); i++) {\r\nif (val->flag == FW_DUMP_LEVELS[i]) {\r\nfw_dump->tmpl_hdr->drv_cap_mask =\r\nval->flag;\r\nnetdev_info(netdev, "Driver mask changed to: 0x%x\n",\r\nfw_dump->tmpl_hdr->drv_cap_mask);\r\nreturn 0;\r\n}\r\n}\r\nnetdev_info(netdev, "Invalid dump level: 0x%x\n", val->flag);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
