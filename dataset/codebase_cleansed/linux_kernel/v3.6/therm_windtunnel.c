static void\r\nprint_temp( const char *s, int temp )\r\n{\r\nprintk("%s%d.%d C", s ? s : "", temp>>8, (temp & 255)*10/256 );\r\n}\r\nstatic ssize_t\r\nshow_cpu_temperature( struct device *dev, struct device_attribute *attr, char *buf )\r\n{\r\nreturn sprintf(buf, "%d.%d\n", x.temp>>8, (x.temp & 255)*10/256 );\r\n}\r\nstatic ssize_t\r\nshow_case_temperature( struct device *dev, struct device_attribute *attr, char *buf )\r\n{\r\nreturn sprintf(buf, "%d.%d\n", x.casetemp>>8, (x.casetemp & 255)*10/256 );\r\n}\r\nstatic int\r\nwrite_reg( struct i2c_client *cl, int reg, int data, int len )\r\n{\r\nu8 tmp[3];\r\nif( len < 1 || len > 2 || data < 0 )\r\nreturn -EINVAL;\r\ntmp[0] = reg;\r\ntmp[1] = (len == 1) ? data : (data >> 8);\r\ntmp[2] = data;\r\nlen++;\r\nif( i2c_master_send(cl, tmp, len) != len )\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int\r\nread_reg( struct i2c_client *cl, int reg, int len )\r\n{\r\nu8 buf[2];\r\nif( len != 1 && len != 2 )\r\nreturn -EINVAL;\r\nbuf[0] = reg;\r\nif( i2c_master_send(cl, buf, 1) != 1 )\r\nreturn -ENODEV;\r\nif( i2c_master_recv(cl, buf, len) != len )\r\nreturn -ENODEV;\r\nreturn (len == 2)? ((unsigned int)buf[0] << 8) | buf[1] : buf[0];\r\n}\r\nstatic void\r\ntune_fan( int fan_setting )\r\n{\r\nint val = (fan_setting << 3) | 7;\r\nwrite_reg( x.fan, 0x25, val, 1 );\r\nwrite_reg( x.fan, 0x20, 0, 1 );\r\nprint_temp("CPU-temp: ", x.temp );\r\nif( x.casetemp )\r\nprint_temp(", Case: ", x.casetemp );\r\nprintk(", Fan: %d (tuned %+d)\n", 11-fan_setting, x.fan_level-fan_setting );\r\nx.fan_level = fan_setting;\r\n}\r\nstatic void\r\npoll_temp( void )\r\n{\r\nint temp, i, level, casetemp;\r\ntemp = read_reg( x.thermostat, 0, 2 );\r\nif( temp < 0 )\r\nreturn;\r\ncasetemp = read_reg(x.fan, 0x0b, 1) << 8;\r\ncasetemp |= (read_reg(x.fan, 0x06, 1) & 0x7) << 5;\r\nif( LOG_TEMP && x.temp != temp ) {\r\nprint_temp("CPU-temp: ", temp );\r\nprint_temp(", Case: ", casetemp );\r\nprintk(", Fan: %d\n", 11-x.fan_level );\r\n}\r\nx.temp = temp;\r\nx.casetemp = casetemp;\r\nlevel = -1;\r\nfor( i=0; (temp & 0xffff) > fan_table[i].temp ; i++ )\r\n;\r\nif( i < x.downind )\r\nlevel = fan_table[i].fan_down_setting;\r\nx.downind = i;\r\nfor( i=0; (temp & 0xffff) >= fan_table[i+1].temp ; i++ )\r\n;\r\nif( x.upind < i )\r\nlevel = fan_table[i].fan_up_setting;\r\nx.upind = i;\r\nif( level >= 0 )\r\ntune_fan( level );\r\n}\r\nstatic void\r\nsetup_hardware( void )\r\n{\r\nint val;\r\nint err;\r\nx.r0 = read_reg( x.fan, 0x00, 1 );\r\nx.r1 = read_reg( x.fan, 0x01, 1 );\r\nx.r20 = read_reg( x.fan, 0x20, 1 );\r\nx.r23 = read_reg( x.fan, 0x23, 1 );\r\nx.r25 = read_reg( x.fan, 0x25, 1 );\r\nif( (val=read_reg(x.thermostat, 1, 1)) >= 0 ) {\r\nval |= 0x60;\r\nif( write_reg( x.thermostat, 1, val, 1 ) )\r\nprintk("Failed writing config register\n");\r\n}\r\nwrite_reg( x.fan, 0x01, 0x01, 1 );\r\nwrite_reg( x.fan, 0x23, 0x91, 1 );\r\nwrite_reg( x.fan, 0x00, 0x95, 1 );\r\nif( x.overheat_temp == (80 << 8) ) {\r\nx.overheat_temp = 75 << 8;\r\nx.overheat_hyst = 70 << 8;\r\nwrite_reg( x.thermostat, 2, x.overheat_hyst, 2 );\r\nwrite_reg( x.thermostat, 3, x.overheat_temp, 2 );\r\nprint_temp("Reducing overheating limit to ", x.overheat_temp );\r\nprint_temp(" (Hyst: ", x.overheat_hyst );\r\nprintk(")\n");\r\n}\r\nx.downind = 0xffff;\r\nx.upind = -1;\r\nerr = device_create_file( &x.of_dev->dev, &dev_attr_cpu_temperature );\r\nerr |= device_create_file( &x.of_dev->dev, &dev_attr_case_temperature );\r\nif (err)\r\nprintk(KERN_WARNING\r\n"Failed to create temperature attribute file(s).\n");\r\n}\r\nstatic void\r\nrestore_regs( void )\r\n{\r\ndevice_remove_file( &x.of_dev->dev, &dev_attr_cpu_temperature );\r\ndevice_remove_file( &x.of_dev->dev, &dev_attr_case_temperature );\r\nwrite_reg( x.fan, 0x01, x.r1, 1 );\r\nwrite_reg( x.fan, 0x20, x.r20, 1 );\r\nwrite_reg( x.fan, 0x23, x.r23, 1 );\r\nwrite_reg( x.fan, 0x25, x.r25, 1 );\r\nwrite_reg( x.fan, 0x00, x.r0, 1 );\r\n}\r\nstatic int control_loop(void *dummy)\r\n{\r\nmutex_lock(&x.lock);\r\nsetup_hardware();\r\nmutex_unlock(&x.lock);\r\nfor (;;) {\r\nmsleep_interruptible(8000);\r\nif (kthread_should_stop())\r\nbreak;\r\nmutex_lock(&x.lock);\r\npoll_temp();\r\nmutex_unlock(&x.lock);\r\n}\r\nmutex_lock(&x.lock);\r\nrestore_regs();\r\nmutex_unlock(&x.lock);\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_attach( struct i2c_adapter *adapter )\r\n{\r\nstatic const unsigned short scan_ds1775[] = {\r\n0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\r\nI2C_CLIENT_END\r\n};\r\nstatic const unsigned short scan_adm1030[] = {\r\n0x2c, 0x2d, 0x2e, 0x2f,\r\nI2C_CLIENT_END\r\n};\r\nif( strncmp(adapter->name, "uni-n", 5) )\r\nreturn 0;\r\nif( !x.running ) {\r\nstruct i2c_board_info info;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "therm_ds1775", I2C_NAME_SIZE);\r\ni2c_new_probed_device(adapter, &info, scan_ds1775, NULL);\r\nstrlcpy(info.type, "therm_adm1030", I2C_NAME_SIZE);\r\ni2c_new_probed_device(adapter, &info, scan_adm1030, NULL);\r\nif( x.thermostat && x.fan ) {\r\nx.running = 1;\r\nx.poll_task = kthread_run(control_loop, NULL, "g4fand");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_remove(struct i2c_client *client)\r\n{\r\nif (x.running) {\r\nx.running = 0;\r\nkthread_stop(x.poll_task);\r\nx.poll_task = NULL;\r\n}\r\nif (client == x.thermostat)\r\nx.thermostat = NULL;\r\nelse if (client == x.fan)\r\nx.fan = NULL;\r\nelse\r\nprintk(KERN_ERR "g4fan: bad client\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nattach_fan( struct i2c_client *cl )\r\n{\r\nif( x.fan )\r\ngoto out;\r\nif( read_reg(cl, 0x3d, 1) != 0x30 || read_reg(cl, 0x3e, 1) != 0x41 )\r\ngoto out;\r\nprintk("ADM1030 fan controller [@%02x]\n", cl->addr );\r\nx.fan = cl;\r\nout:\r\nreturn 0;\r\n}\r\nstatic int\r\nattach_thermostat( struct i2c_client *cl )\r\n{\r\nint hyst_temp, os_temp, temp;\r\nif( x.thermostat )\r\ngoto out;\r\nif( (temp=read_reg(cl, 0, 2)) < 0 )\r\ngoto out;\r\nif( temp < 0x1600 || temp > 0x3c00 )\r\ngoto out;\r\nhyst_temp = read_reg(cl, 2, 2);\r\nos_temp = read_reg(cl, 3, 2);\r\nif( hyst_temp < 0 || os_temp < 0 )\r\ngoto out;\r\nprintk("DS1775 digital thermometer [@%02x]\n", cl->addr );\r\nprint_temp("Temp: ", temp );\r\nprint_temp(" Hyst: ", hyst_temp );\r\nprint_temp(" OS: ", os_temp );\r\nprintk("\n");\r\nx.temp = temp;\r\nx.overheat_temp = os_temp;\r\nx.overheat_hyst = hyst_temp;\r\nx.thermostat = cl;\r\nout:\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_probe(struct i2c_client *cl, const struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = cl->adapter;\r\nif( !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA\r\n| I2C_FUNC_SMBUS_WRITE_BYTE) )\r\nreturn 0;\r\nswitch (id->driver_data) {\r\ncase adm1030:\r\nreturn attach_fan( cl );\r\ncase ds1775:\r\nreturn attach_thermostat(cl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int therm_of_probe(struct platform_device *dev)\r\n{\r\nreturn i2c_add_driver( &g4fan_driver );\r\n}\r\nstatic int\r\ntherm_of_remove( struct platform_device *dev )\r\n{\r\ni2c_del_driver( &g4fan_driver );\r\nreturn 0;\r\n}\r\nstatic int __init\r\ng4fan_init( void )\r\n{\r\nconst struct apple_thermal_info *info;\r\nstruct device_node *np;\r\nmutex_init(&x.lock);\r\nif( !(np=of_find_node_by_name(NULL, "power-mgt")) )\r\nreturn -ENODEV;\r\ninfo = of_get_property(np, "thermal-info", NULL);\r\nof_node_put(np);\r\nif( !info || !of_machine_is_compatible("PowerMac3,6") )\r\nreturn -ENODEV;\r\nif( info->id != 3 ) {\r\nprintk(KERN_ERR "therm_windtunnel: unsupported thermal design %d\n", info->id );\r\nreturn -ENODEV;\r\n}\r\nif( !(np=of_find_node_by_name(NULL, "fan")) )\r\nreturn -ENODEV;\r\nx.of_dev = of_platform_device_create(np, "temperature", NULL);\r\nof_node_put( np );\r\nif( !x.of_dev ) {\r\nprintk(KERN_ERR "Can't register fan controller!\n");\r\nreturn -ENODEV;\r\n}\r\nplatform_driver_register( &therm_of_driver );\r\nreturn 0;\r\n}\r\nstatic void __exit\r\ng4fan_exit( void )\r\n{\r\nplatform_driver_unregister( &therm_of_driver );\r\nif( x.of_dev )\r\nof_device_unregister( x.of_dev );\r\n}
