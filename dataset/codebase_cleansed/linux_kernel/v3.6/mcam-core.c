static struct mcam_format_struct *mcam_find_format(u32 pixelformat)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < N_MCAM_FMTS; i++)\r\nif (mcam_formats[i].pixelformat == pixelformat)\r\nreturn mcam_formats + i;\r\nreturn mcam_formats;\r\n}\r\nstatic inline struct mcam_vb_buffer *vb_to_mvb(struct vb2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct mcam_vb_buffer, vb_buf);\r\n}\r\nstatic void mcam_buffer_done(struct mcam_camera *cam, int frame,\r\nstruct vb2_buffer *vbuf)\r\n{\r\nvbuf->v4l2_buf.bytesused = cam->pix_format.sizeimage;\r\nvbuf->v4l2_buf.sequence = cam->buf_seq[frame];\r\nvb2_set_plane_payload(vbuf, 0, cam->pix_format.sizeimage);\r\nvb2_buffer_done(vbuf, VB2_BUF_STATE_DONE);\r\n}\r\nstatic void mcam_reset_buffers(struct mcam_camera *cam)\r\n{\r\nint i;\r\ncam->next_buf = -1;\r\nfor (i = 0; i < cam->nbufs; i++)\r\nclear_bit(i, &cam->flags);\r\n}\r\nstatic inline int mcam_needs_config(struct mcam_camera *cam)\r\n{\r\nreturn test_bit(CF_CONFIG_NEEDED, &cam->flags);\r\n}\r\nstatic void mcam_set_config_needed(struct mcam_camera *cam, int needed)\r\n{\r\nif (needed)\r\nset_bit(CF_CONFIG_NEEDED, &cam->flags);\r\nelse\r\nclear_bit(CF_CONFIG_NEEDED, &cam->flags);\r\n}\r\nstatic void mcam_ctlr_start(struct mcam_camera *cam)\r\n{\r\nmcam_reg_set_bit(cam, REG_CTRL0, C0_ENABLE);\r\n}\r\nstatic void mcam_ctlr_stop(struct mcam_camera *cam)\r\n{\r\nmcam_reg_clear_bit(cam, REG_CTRL0, C0_ENABLE);\r\n}\r\nstatic int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)\r\n{\r\nint i;\r\nmcam_set_config_needed(cam, 1);\r\nif (loadtime)\r\ncam->dma_buf_size = dma_buf_size;\r\nelse\r\ncam->dma_buf_size = cam->pix_format.sizeimage;\r\nif (n_dma_bufs > 3)\r\nn_dma_bufs = 3;\r\ncam->nbufs = 0;\r\nfor (i = 0; i < n_dma_bufs; i++) {\r\ncam->dma_bufs[i] = dma_alloc_coherent(cam->dev,\r\ncam->dma_buf_size, cam->dma_handles + i,\r\nGFP_KERNEL);\r\nif (cam->dma_bufs[i] == NULL) {\r\ncam_warn(cam, "Failed to allocate DMA buffer\n");\r\nbreak;\r\n}\r\n(cam->nbufs)++;\r\n}\r\nswitch (cam->nbufs) {\r\ncase 1:\r\ndma_free_coherent(cam->dev, cam->dma_buf_size,\r\ncam->dma_bufs[0], cam->dma_handles[0]);\r\ncam->nbufs = 0;\r\ncase 0:\r\ncam_err(cam, "Insufficient DMA buffers, cannot operate\n");\r\nreturn -ENOMEM;\r\ncase 2:\r\nif (n_dma_bufs > 2)\r\ncam_warn(cam, "Will limp along with only 2 buffers\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mcam_free_dma_bufs(struct mcam_camera *cam)\r\n{\r\nint i;\r\nfor (i = 0; i < cam->nbufs; i++) {\r\ndma_free_coherent(cam->dev, cam->dma_buf_size,\r\ncam->dma_bufs[i], cam->dma_handles[i]);\r\ncam->dma_bufs[i] = NULL;\r\n}\r\ncam->nbufs = 0;\r\n}\r\nstatic void mcam_ctlr_dma_vmalloc(struct mcam_camera *cam)\r\n{\r\nmcam_reg_write(cam, REG_Y0BAR, cam->dma_handles[0]);\r\nmcam_reg_write(cam, REG_Y1BAR, cam->dma_handles[1]);\r\nif (cam->nbufs > 2) {\r\nmcam_reg_write(cam, REG_Y2BAR, cam->dma_handles[2]);\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_TWOBUFS);\r\n} else\r\nmcam_reg_set_bit(cam, REG_CTRL1, C1_TWOBUFS);\r\nif (cam->chip_id == V4L2_IDENT_CAFE)\r\nmcam_reg_write(cam, REG_UBAR, 0);\r\n}\r\nstatic void mcam_frame_tasklet(unsigned long data)\r\n{\r\nstruct mcam_camera *cam = (struct mcam_camera *) data;\r\nint i;\r\nunsigned long flags;\r\nstruct mcam_vb_buffer *buf;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nfor (i = 0; i < cam->nbufs; i++) {\r\nint bufno = cam->next_buf;\r\nif (cam->state != S_STREAMING || bufno < 0)\r\nbreak;\r\nif (++(cam->next_buf) >= cam->nbufs)\r\ncam->next_buf = 0;\r\nif (!test_bit(bufno, &cam->flags))\r\ncontinue;\r\nif (list_empty(&cam->buffers)) {\r\nsingles++;\r\nbreak;\r\n}\r\ndelivered++;\r\nclear_bit(bufno, &cam->flags);\r\nbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer,\r\nqueue);\r\nlist_del_init(&buf->queue);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nmemcpy(vb2_plane_vaddr(&buf->vb_buf, 0), cam->dma_bufs[bufno],\r\ncam->pix_format.sizeimage);\r\nmcam_buffer_done(cam, bufno, &buf->vb_buf);\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\n}\r\nstatic int mcam_check_dma_buffers(struct mcam_camera *cam)\r\n{\r\nif (cam->nbufs > 0 && cam->dma_buf_size < cam->pix_format.sizeimage)\r\nmcam_free_dma_bufs(cam);\r\nif (cam->nbufs == 0)\r\nreturn mcam_alloc_dma_bufs(cam, 0);\r\nreturn 0;\r\n}\r\nstatic void mcam_vmalloc_done(struct mcam_camera *cam, int frame)\r\n{\r\ntasklet_schedule(&cam->s_tasklet);\r\n}\r\nstatic inline int mcam_alloc_dma_bufs(struct mcam_camera *cam, int loadtime)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void mcam_free_dma_bufs(struct mcam_camera *cam)\r\n{\r\nreturn;\r\n}\r\nstatic inline int mcam_check_dma_buffers(struct mcam_camera *cam)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mcam_set_contig_buffer(struct mcam_camera *cam, int frame)\r\n{\r\nstruct mcam_vb_buffer *buf;\r\nif (list_empty(&cam->buffers)) {\r\nbuf = cam->vb_bufs[frame ^ 0x1];\r\ncam->vb_bufs[frame] = buf;\r\nmcam_reg_write(cam, frame == 0 ? REG_Y0BAR : REG_Y1BAR,\r\nvb2_dma_contig_plane_dma_addr(&buf->vb_buf, 0));\r\nset_bit(CF_SINGLE_BUFFER, &cam->flags);\r\nsingles++;\r\nreturn;\r\n}\r\nbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer, queue);\r\nlist_del_init(&buf->queue);\r\nmcam_reg_write(cam, frame == 0 ? REG_Y0BAR : REG_Y1BAR,\r\nvb2_dma_contig_plane_dma_addr(&buf->vb_buf, 0));\r\ncam->vb_bufs[frame] = buf;\r\nclear_bit(CF_SINGLE_BUFFER, &cam->flags);\r\n}\r\nstatic void mcam_ctlr_dma_contig(struct mcam_camera *cam)\r\n{\r\nmcam_reg_set_bit(cam, REG_CTRL1, C1_TWOBUFS);\r\ncam->nbufs = 2;\r\nmcam_set_contig_buffer(cam, 0);\r\nmcam_set_contig_buffer(cam, 1);\r\n}\r\nstatic void mcam_dma_contig_done(struct mcam_camera *cam, int frame)\r\n{\r\nstruct mcam_vb_buffer *buf = cam->vb_bufs[frame];\r\nif (!test_bit(CF_SINGLE_BUFFER, &cam->flags)) {\r\ndelivered++;\r\nmcam_buffer_done(cam, frame, &buf->vb_buf);\r\n}\r\nmcam_set_contig_buffer(cam, frame);\r\n}\r\nstatic void mcam_sg_next_buffer(struct mcam_camera *cam)\r\n{\r\nstruct mcam_vb_buffer *buf;\r\nbuf = list_first_entry(&cam->buffers, struct mcam_vb_buffer, queue);\r\nlist_del_init(&buf->queue);\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_DESC_ENA);\r\nmcam_reg_write(cam, REG_DMA_DESC_Y, buf->dma_desc_pa);\r\nmcam_reg_write(cam, REG_DESC_LEN_Y,\r\nbuf->dma_desc_nent*sizeof(struct mcam_dma_desc));\r\nmcam_reg_write(cam, REG_DESC_LEN_U, 0);\r\nmcam_reg_write(cam, REG_DESC_LEN_V, 0);\r\nmcam_reg_set_bit(cam, REG_CTRL1, C1_DESC_ENA);\r\ncam->vb_bufs[0] = buf;\r\n}\r\nstatic void mcam_ctlr_dma_sg(struct mcam_camera *cam)\r\n{\r\nif (list_empty(&cam->buffers)) {\r\nset_bit(CF_SG_RESTART, &cam->flags);\r\nreturn;\r\n}\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_DESC_3WORD);\r\nmcam_sg_next_buffer(cam);\r\ncam->nbufs = 3;\r\n}\r\nstatic void mcam_dma_sg_done(struct mcam_camera *cam, int frame)\r\n{\r\nstruct mcam_vb_buffer *buf = cam->vb_bufs[0];\r\nif (cam->state != S_STREAMING)\r\nreturn;\r\nif (!list_empty(&cam->buffers)) {\r\nmcam_sg_next_buffer(cam);\r\nmcam_ctlr_start(cam);\r\n} else {\r\nset_bit(CF_SG_RESTART, &cam->flags);\r\nsingles++;\r\ncam->vb_bufs[0] = NULL;\r\n}\r\ndelivered++;\r\nmcam_buffer_done(cam, frame, &buf->vb_buf);\r\n}\r\nstatic void mcam_sg_restart(struct mcam_camera *cam)\r\n{\r\nmcam_ctlr_dma_sg(cam);\r\nmcam_ctlr_start(cam);\r\nclear_bit(CF_SG_RESTART, &cam->flags);\r\n}\r\nstatic inline void mcam_sg_restart(struct mcam_camera *cam)\r\n{\r\nreturn;\r\n}\r\nstatic void mcam_ctlr_image(struct mcam_camera *cam)\r\n{\r\nint imgsz;\r\nstruct v4l2_pix_format *fmt = &cam->pix_format;\r\nimgsz = ((fmt->height << IMGSZ_V_SHIFT) & IMGSZ_V_MASK) |\r\n(fmt->bytesperline & IMGSZ_H_MASK);\r\nmcam_reg_write(cam, REG_IMGSIZE, imgsz);\r\nmcam_reg_write(cam, REG_IMGOFFSET, 0);\r\nmcam_reg_write_mask(cam, REG_IMGPITCH, fmt->bytesperline,\r\nIMGP_YP_MASK);\r\nswitch (cam->pix_format.pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_YUV|C0_YUV_PACKED|C0_YUVE_YUYV,\r\nC0_DF_MASK);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB444:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_RGB|C0_RGBF_444|C0_RGB4_XRGB,\r\nC0_DF_MASK);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\nmcam_reg_write_mask(cam, REG_CTRL0,\r\nC0_DF_RGB|C0_RGBF_565|C0_RGB5_BGGR,\r\nC0_DF_MASK);\r\nbreak;\r\ndefault:\r\ncam_err(cam, "Unknown format %x\n", cam->pix_format.pixelformat);\r\nbreak;\r\n}\r\nmcam_reg_write_mask(cam, REG_CTRL0, C0_SIF_HVSYNC,\r\nC0_SIFM_MASK);\r\n}\r\nstatic int mcam_ctlr_configure(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nclear_bit(CF_SG_RESTART, &cam->flags);\r\ncam->dma_setup(cam);\r\nmcam_ctlr_image(cam);\r\nmcam_set_config_needed(cam, 0);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mcam_ctlr_irq_enable(struct mcam_camera *cam)\r\n{\r\nmcam_reg_write(cam, REG_IRQSTAT, FRAMEIRQS);\r\nmcam_reg_set_bit(cam, REG_IRQMASK, FRAMEIRQS);\r\n}\r\nstatic void mcam_ctlr_irq_disable(struct mcam_camera *cam)\r\n{\r\nmcam_reg_clear_bit(cam, REG_IRQMASK, FRAMEIRQS);\r\n}\r\nstatic void mcam_ctlr_init(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_PWRDWN);\r\nmcam_reg_clear_bit(cam, REG_CTRL0, C0_ENABLE);\r\nmcam_reg_write_mask(cam, REG_CLKCTRL, 2, CLK_DIV_MASK);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\n}\r\nstatic void mcam_ctlr_stop_dma(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nclear_bit(CF_SG_RESTART, &cam->flags);\r\nmcam_ctlr_stop(cam);\r\ncam->state = S_IDLE;\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nmsleep(150);\r\nif (test_bit(CF_DMA_ACTIVE, &cam->flags))\r\ncam_err(cam, "Timeout waiting for DMA to end\n");\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nmcam_ctlr_irq_disable(cam);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\n}\r\nstatic void mcam_ctlr_power_up(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\ncam->plat_power_up(cam);\r\nmcam_reg_clear_bit(cam, REG_CTRL1, C1_PWRDWN);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nmsleep(5);\r\n}\r\nstatic void mcam_ctlr_power_down(struct mcam_camera *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nmcam_reg_set_bit(cam, REG_CTRL1, C1_PWRDWN);\r\ncam->plat_power_down(cam);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\n}\r\nstatic int __mcam_cam_reset(struct mcam_camera *cam)\r\n{\r\nreturn sensor_call(cam, core, reset, 0);\r\n}\r\nstatic int mcam_cam_init(struct mcam_camera *cam)\r\n{\r\nstruct v4l2_dbg_chip_ident chip;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nif (cam->state != S_NOTREADY)\r\ncam_warn(cam, "Cam init with device in funky state %d",\r\ncam->state);\r\nret = __mcam_cam_reset(cam);\r\nif (ret)\r\ngoto out;\r\nchip.ident = V4L2_IDENT_NONE;\r\nchip.match.type = V4L2_CHIP_MATCH_I2C_ADDR;\r\nchip.match.addr = cam->sensor_addr;\r\nret = sensor_call(cam, core, g_chip_ident, &chip);\r\nif (ret)\r\ngoto out;\r\ncam->sensor_type = chip.ident;\r\nif (cam->sensor_type != V4L2_IDENT_OV7670) {\r\ncam_err(cam, "Unsupported sensor type 0x%x", cam->sensor_type);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = 0;\r\ncam->state = S_IDLE;\r\nout:\r\nmcam_ctlr_power_down(cam);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_cam_set_flip(struct mcam_camera *cam)\r\n{\r\nstruct v4l2_control ctrl;\r\nmemset(&ctrl, 0, sizeof(ctrl));\r\nctrl.id = V4L2_CID_VFLIP;\r\nctrl.value = flip;\r\nreturn sensor_call(cam, core, s_ctrl, &ctrl);\r\n}\r\nstatic int mcam_cam_configure(struct mcam_camera *cam)\r\n{\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint ret;\r\nv4l2_fill_mbus_format(&mbus_fmt, &cam->pix_format, cam->mbus_code);\r\nret = sensor_call(cam, core, init, 0);\r\nif (ret == 0)\r\nret = sensor_call(cam, video, s_mbus_fmt, &mbus_fmt);\r\nret += mcam_cam_set_flip(cam);\r\nreturn ret;\r\n}\r\nstatic int mcam_read_setup(struct mcam_camera *cam)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nif (cam->buffer_mode == B_vmalloc && cam->nbufs == 0 &&\r\nmcam_alloc_dma_bufs(cam, 0))\r\nreturn -ENOMEM;\r\nif (mcam_needs_config(cam)) {\r\nmcam_cam_configure(cam);\r\nret = mcam_ctlr_configure(cam);\r\nif (ret)\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nclear_bit(CF_DMA_ACTIVE, &cam->flags);\r\nmcam_reset_buffers(cam);\r\nmcam_ctlr_irq_enable(cam);\r\ncam->state = S_STREAMING;\r\nif (!test_bit(CF_SG_RESTART, &cam->flags))\r\nmcam_ctlr_start(cam);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mcam_vb_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt, unsigned int *nbufs,\r\nunsigned int *num_planes, unsigned int sizes[],\r\nvoid *alloc_ctxs[])\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nint minbufs = (cam->buffer_mode == B_DMA_contig) ? 3 : 2;\r\nsizes[0] = cam->pix_format.sizeimage;\r\n*num_planes = 1;\r\nif (*nbufs < minbufs)\r\n*nbufs = minbufs;\r\nif (cam->buffer_mode == B_DMA_contig)\r\nalloc_ctxs[0] = cam->vb_alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic void mcam_vb_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_vb_buffer *mvb = vb_to_mvb(vb);\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long flags;\r\nint start;\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nstart = (cam->state == S_BUFWAIT) && !list_empty(&cam->buffers);\r\nlist_add(&mvb->queue, &cam->buffers);\r\nif (cam->state == S_STREAMING && test_bit(CF_SG_RESTART, &cam->flags))\r\nmcam_sg_restart(cam);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nif (start)\r\nmcam_read_setup(cam);\r\n}\r\nstatic void mcam_vb_wait_prepare(struct vb2_queue *vq)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nmutex_unlock(&cam->s_mutex);\r\n}\r\nstatic void mcam_vb_wait_finish(struct vb2_queue *vq)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nmutex_lock(&cam->s_mutex);\r\n}\r\nstatic int mcam_vb_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nif (cam->state != S_IDLE) {\r\nINIT_LIST_HEAD(&cam->buffers);\r\nreturn -EINVAL;\r\n}\r\ncam->sequence = 0;\r\nif (cam->buffer_mode != B_vmalloc && list_empty(&cam->buffers)) {\r\ncam->state = S_BUFWAIT;\r\nreturn 0;\r\n}\r\nreturn mcam_read_setup(cam);\r\n}\r\nstatic int mcam_vb_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vq);\r\nunsigned long flags;\r\nif (cam->state == S_BUFWAIT) {\r\ncam->state = S_IDLE;\r\nreturn 0;\r\n}\r\nif (cam->state != S_STREAMING)\r\nreturn -EINVAL;\r\nmcam_ctlr_stop_dma(cam);\r\nspin_lock_irqsave(&cam->dev_lock, flags);\r\nINIT_LIST_HEAD(&cam->buffers);\r\nspin_unlock_irqrestore(&cam->dev_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mcam_vb_sg_buf_init(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_vb_buffer *mvb = vb_to_mvb(vb);\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nint ndesc = cam->pix_format.sizeimage/PAGE_SIZE + 1;\r\nmvb->dma_desc = dma_alloc_coherent(cam->dev,\r\nndesc * sizeof(struct mcam_dma_desc),\r\n&mvb->dma_desc_pa, GFP_KERNEL);\r\nif (mvb->dma_desc == NULL) {\r\ncam_err(cam, "Unable to get DMA descriptor array\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcam_vb_sg_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_vb_buffer *mvb = vb_to_mvb(vb);\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_dma_sg_desc *sgd = vb2_dma_sg_plane_desc(vb, 0);\r\nstruct mcam_dma_desc *desc = mvb->dma_desc;\r\nstruct scatterlist *sg;\r\nint i;\r\nmvb->dma_desc_nent = dma_map_sg(cam->dev, sgd->sglist, sgd->num_pages,\r\nDMA_FROM_DEVICE);\r\nif (mvb->dma_desc_nent <= 0)\r\nreturn -EIO;\r\nfor_each_sg(sgd->sglist, sg, mvb->dma_desc_nent, i) {\r\ndesc->dma_addr = sg_dma_address(sg);\r\ndesc->segment_len = sg_dma_len(sg);\r\ndesc++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcam_vb_sg_buf_finish(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_dma_sg_desc *sgd = vb2_dma_sg_plane_desc(vb, 0);\r\ndma_unmap_sg(cam->dev, sgd->sglist, sgd->num_pages, DMA_FROM_DEVICE);\r\nreturn 0;\r\n}\r\nstatic void mcam_vb_sg_buf_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct mcam_camera *cam = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct mcam_vb_buffer *mvb = vb_to_mvb(vb);\r\nint ndesc = cam->pix_format.sizeimage/PAGE_SIZE + 1;\r\ndma_free_coherent(cam->dev, ndesc * sizeof(struct mcam_dma_desc),\r\nmvb->dma_desc, mvb->dma_desc_pa);\r\n}\r\nstatic int mcam_setup_vb2(struct mcam_camera *cam)\r\n{\r\nstruct vb2_queue *vq = &cam->vb_queue;\r\nmemset(vq, 0, sizeof(*vq));\r\nvq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvq->drv_priv = cam;\r\nINIT_LIST_HEAD(&cam->buffers);\r\nswitch (cam->buffer_mode) {\r\ncase B_DMA_contig:\r\n#ifdef MCAM_MODE_DMA_CONTIG\r\nvq->ops = &mcam_vb2_ops;\r\nvq->mem_ops = &vb2_dma_contig_memops;\r\ncam->vb_alloc_ctx = vb2_dma_contig_init_ctx(cam->dev);\r\nvq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ncam->dma_setup = mcam_ctlr_dma_contig;\r\ncam->frame_complete = mcam_dma_contig_done;\r\n#endif\r\nbreak;\r\ncase B_DMA_sg:\r\n#ifdef MCAM_MODE_DMA_SG\r\nvq->ops = &mcam_vb2_sg_ops;\r\nvq->mem_ops = &vb2_dma_sg_memops;\r\nvq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ncam->dma_setup = mcam_ctlr_dma_sg;\r\ncam->frame_complete = mcam_dma_sg_done;\r\n#endif\r\nbreak;\r\ncase B_vmalloc:\r\n#ifdef MCAM_MODE_VMALLOC\r\ntasklet_init(&cam->s_tasklet, mcam_frame_tasklet,\r\n(unsigned long) cam);\r\nvq->ops = &mcam_vb2_ops;\r\nvq->mem_ops = &vb2_vmalloc_memops;\r\nvq->buf_struct_size = sizeof(struct mcam_vb_buffer);\r\nvq->io_modes = VB2_MMAP;\r\ncam->dma_setup = mcam_ctlr_dma_vmalloc;\r\ncam->frame_complete = mcam_vmalloc_done;\r\n#endif\r\nbreak;\r\n}\r\nreturn vb2_queue_init(vq);\r\n}\r\nstatic void mcam_cleanup_vb2(struct mcam_camera *cam)\r\n{\r\nvb2_queue_release(&cam->vb_queue);\r\n#ifdef MCAM_MODE_DMA_CONTIG\r\nif (cam->buffer_mode == B_DMA_contig)\r\nvb2_dma_contig_cleanup_ctx(cam->vb_alloc_ctx);\r\n#endif\r\n}\r\nstatic int mcam_vidioc_streamon(struct file *filp, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_streamon(&cam->vb_queue, type);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_streamoff(struct file *filp, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_streamoff(&cam->vb_queue, type);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_reqbufs(struct file *filp, void *priv,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_reqbufs(&cam->vb_queue, req);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_querybuf(struct file *filp, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_querybuf(&cam->vb_queue, buf);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_qbuf(struct file *filp, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_qbuf(&cam->vb_queue, buf);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_dqbuf(struct file *filp, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_dqbuf(&cam->vb_queue, buf, filp->f_flags & O_NONBLOCK);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_queryctrl(struct file *filp, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, core, queryctrl, qc);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_g_ctrl(struct file *filp, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, core, g_ctrl, ctrl);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_s_ctrl(struct file *filp, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, core, s_ctrl, ctrl);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrcpy(cap->driver, "marvell_ccic");\r\nstrcpy(cap->card, "marvell_ccic");\r\ncap->version = 1;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_enum_fmt_vid_cap(struct file *filp,\r\nvoid *priv, struct v4l2_fmtdesc *fmt)\r\n{\r\nif (fmt->index >= N_MCAM_FMTS)\r\nreturn -EINVAL;\r\nstrlcpy(fmt->description, mcam_formats[fmt->index].desc,\r\nsizeof(fmt->description));\r\nfmt->pixelformat = mcam_formats[fmt->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_try_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nstruct mcam_format_struct *f;\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint ret;\r\nf = mcam_find_format(pix->pixelformat);\r\npix->pixelformat = f->pixelformat;\r\nv4l2_fill_mbus_format(&mbus_fmt, pix, f->mbus_code);\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, try_mbus_fmt, &mbus_fmt);\r\nmutex_unlock(&cam->s_mutex);\r\nv4l2_fill_pix_format(pix, &mbus_fmt);\r\npix->bytesperline = pix->width * f->bpp;\r\npix->sizeimage = pix->height * pix->bytesperline;\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_s_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nstruct mcam_format_struct *f;\r\nint ret;\r\nif (cam->state != S_IDLE || cam->vb_queue.num_buffers > 0)\r\nreturn -EBUSY;\r\nf = mcam_find_format(fmt->fmt.pix.pixelformat);\r\nret = mcam_vidioc_try_fmt_vid_cap(filp, priv, fmt);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&cam->s_mutex);\r\ncam->pix_format = fmt->fmt.pix;\r\ncam->mbus_code = f->mbus_code;\r\nif (cam->buffer_mode == B_vmalloc) {\r\nret = mcam_check_dma_buffers(cam);\r\nif (ret)\r\ngoto out;\r\n}\r\nmcam_set_config_needed(cam, 1);\r\nout:\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_g_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nf->fmt.pix = cam->pix_format;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_enum_input(struct file *filp, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nif (input->index != 0)\r\nreturn -EINVAL;\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\ninput->std = V4L2_STD_ALL;\r\nstrcpy(input->name, "Camera");\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nif (i != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_s_std(struct file *filp, void *priv, v4l2_std_id *a)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mcam_vidioc_g_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parms)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, g_parm, parms);\r\nmutex_unlock(&cam->s_mutex);\r\nparms->parm.capture.readbuffers = n_dma_bufs;\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_s_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parms)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, s_parm, parms);\r\nmutex_unlock(&cam->s_mutex);\r\nparms->parm.capture.readbuffers = n_dma_bufs;\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_g_chip_ident(struct file *file, void *priv,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nchip->ident = V4L2_IDENT_NONE;\r\nchip->revision = 0;\r\nif (v4l2_chip_match_host(&chip->match)) {\r\nchip->ident = cam->chip_id;\r\nreturn 0;\r\n}\r\nreturn sensor_call(cam, core, g_chip_ident, chip);\r\n}\r\nstatic int mcam_vidioc_enum_framesizes(struct file *filp, void *priv,\r\nstruct v4l2_frmsizeenum *sizes)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, enum_framesizes, sizes);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_enum_frameintervals(struct file *filp, void *priv,\r\nstruct v4l2_frmivalenum *interval)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = sensor_call(cam, video, enum_frameintervals, interval);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nif (v4l2_chip_match_host(&reg->match)) {\r\nreg->val = mcam_reg_read(cam, reg->reg);\r\nreg->size = 4;\r\nreturn 0;\r\n}\r\nreturn sensor_call(cam, core, g_register, reg);\r\n}\r\nstatic int mcam_vidioc_s_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct mcam_camera *cam = priv;\r\nif (v4l2_chip_match_host(&reg->match)) {\r\nmcam_reg_write(cam, reg->reg, reg->val);\r\nreturn 0;\r\n}\r\nreturn sensor_call(cam, core, s_register, reg);\r\n}\r\nstatic int mcam_v4l_open(struct file *filp)\r\n{\r\nstruct mcam_camera *cam = video_drvdata(filp);\r\nint ret = 0;\r\nfilp->private_data = cam;\r\nframes = singles = delivered = 0;\r\nmutex_lock(&cam->s_mutex);\r\nif (cam->users == 0) {\r\nret = mcam_setup_vb2(cam);\r\nif (ret)\r\ngoto out;\r\nmcam_ctlr_power_up(cam);\r\n__mcam_cam_reset(cam);\r\nmcam_set_config_needed(cam, 1);\r\n}\r\n(cam->users)++;\r\nout:\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_v4l_release(struct file *filp)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\ncam_dbg(cam, "Release, %d frames, %d singles, %d delivered\n", frames,\r\nsingles, delivered);\r\nmutex_lock(&cam->s_mutex);\r\n(cam->users)--;\r\nif (cam->users == 0) {\r\nmcam_ctlr_stop_dma(cam);\r\nmcam_cleanup_vb2(cam);\r\nmcam_ctlr_power_down(cam);\r\nif (cam->buffer_mode == B_vmalloc && alloc_bufs_at_read)\r\nmcam_free_dma_bufs(cam);\r\n}\r\nmutex_unlock(&cam->s_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t mcam_v4l_read(struct file *filp,\r\nchar __user *buffer, size_t len, loff_t *pos)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_read(&cam->vb_queue, buffer, len, pos,\r\nfilp->f_flags & O_NONBLOCK);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int mcam_v4l_poll(struct file *filp,\r\nstruct poll_table_struct *pt)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_poll(&cam->vb_queue, filp, pt);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic int mcam_v4l_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct mcam_camera *cam = filp->private_data;\r\nint ret;\r\nmutex_lock(&cam->s_mutex);\r\nret = vb2_mmap(&cam->vb_queue, vma);\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\n}\r\nstatic void mcam_frame_complete(struct mcam_camera *cam, int frame)\r\n{\r\nset_bit(frame, &cam->flags);\r\nclear_bit(CF_DMA_ACTIVE, &cam->flags);\r\ncam->next_buf = frame;\r\ncam->buf_seq[frame] = ++(cam->sequence);\r\nframes++;\r\nif (cam->state != S_STREAMING)\r\nreturn;\r\ncam->frame_complete(cam, frame);\r\n}\r\nint mccic_irq(struct mcam_camera *cam, unsigned int irqs)\r\n{\r\nunsigned int frame, handled = 0;\r\nmcam_reg_write(cam, REG_IRQSTAT, FRAMEIRQS);\r\nfor (frame = 0; frame < cam->nbufs; frame++)\r\nif (irqs & (IRQ_EOF0 << frame)) {\r\nmcam_frame_complete(cam, frame);\r\nhandled = 1;\r\nif (cam->buffer_mode == B_DMA_sg)\r\nbreak;\r\n}\r\nif (irqs & (IRQ_SOF0 | IRQ_SOF1 | IRQ_SOF2)) {\r\nset_bit(CF_DMA_ACTIVE, &cam->flags);\r\nhandled = 1;\r\nif (cam->buffer_mode == B_DMA_sg)\r\nmcam_ctlr_stop(cam);\r\n}\r\nreturn handled;\r\n}\r\nint mccic_register(struct mcam_camera *cam)\r\n{\r\nstruct i2c_board_info ov7670_info = {\r\n.type = "ov7670",\r\n.addr = 0x42 >> 1,\r\n.platform_data = &sensor_cfg,\r\n};\r\nint ret;\r\nif (buffer_mode >= 0)\r\ncam->buffer_mode = buffer_mode;\r\nif (cam->buffer_mode == B_DMA_sg &&\r\ncam->chip_id == V4L2_IDENT_CAFE) {\r\nprintk(KERN_ERR "marvell-cam: Cafe can't do S/G I/O, "\r\n"attempting vmalloc mode instead\n");\r\ncam->buffer_mode = B_vmalloc;\r\n}\r\nif (!mcam_buffer_mode_supported(cam->buffer_mode)) {\r\nprintk(KERN_ERR "marvell-cam: buffer mode %d unsupported\n",\r\ncam->buffer_mode);\r\nreturn -EINVAL;\r\n}\r\nret = v4l2_device_register(cam->dev, &cam->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&cam->s_mutex);\r\ncam->state = S_NOTREADY;\r\nmcam_set_config_needed(cam, 1);\r\ncam->pix_format = mcam_def_pix_format;\r\ncam->mbus_code = mcam_def_mbus_code;\r\nINIT_LIST_HEAD(&cam->buffers);\r\nmcam_ctlr_init(cam);\r\nsensor_cfg.clock_speed = cam->clock_speed;\r\nsensor_cfg.use_smbus = cam->use_smbus;\r\ncam->sensor_addr = ov7670_info.addr;\r\ncam->sensor = v4l2_i2c_new_subdev_board(&cam->v4l2_dev,\r\ncam->i2c_adapter, &ov7670_info, NULL);\r\nif (cam->sensor == NULL) {\r\nret = -ENODEV;\r\ngoto out_unregister;\r\n}\r\nret = mcam_cam_init(cam);\r\nif (ret)\r\ngoto out_unregister;\r\nmutex_lock(&cam->s_mutex);\r\ncam->vdev = mcam_v4l_template;\r\ncam->vdev.debug = 0;\r\ncam->vdev.v4l2_dev = &cam->v4l2_dev;\r\nret = video_register_device(&cam->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto out;\r\nvideo_set_drvdata(&cam->vdev, cam);\r\nif (cam->buffer_mode == B_vmalloc && !alloc_bufs_at_read) {\r\nif (mcam_alloc_dma_bufs(cam, 1))\r\ncam_warn(cam, "Unable to alloc DMA buffers at load"\r\n" will try again later.");\r\n}\r\nout:\r\nmutex_unlock(&cam->s_mutex);\r\nreturn ret;\r\nout_unregister:\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nreturn ret;\r\n}\r\nvoid mccic_shutdown(struct mcam_camera *cam)\r\n{\r\nif (cam->users > 0) {\r\ncam_warn(cam, "Removing a device with users!\n");\r\nmcam_ctlr_power_down(cam);\r\n}\r\nvb2_queue_release(&cam->vb_queue);\r\nif (cam->buffer_mode == B_vmalloc)\r\nmcam_free_dma_bufs(cam);\r\nvideo_unregister_device(&cam->vdev);\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\n}\r\nvoid mccic_suspend(struct mcam_camera *cam)\r\n{\r\nmutex_lock(&cam->s_mutex);\r\nif (cam->users > 0) {\r\nenum mcam_state cstate = cam->state;\r\nmcam_ctlr_stop_dma(cam);\r\nmcam_ctlr_power_down(cam);\r\ncam->state = cstate;\r\n}\r\nmutex_unlock(&cam->s_mutex);\r\n}\r\nint mccic_resume(struct mcam_camera *cam)\r\n{\r\nint ret = 0;\r\nmutex_lock(&cam->s_mutex);\r\nif (cam->users > 0) {\r\nmcam_ctlr_power_up(cam);\r\n__mcam_cam_reset(cam);\r\n} else {\r\nmcam_ctlr_power_down(cam);\r\n}\r\nmutex_unlock(&cam->s_mutex);\r\nset_bit(CF_CONFIG_NEEDED, &cam->flags);\r\nif (cam->state == S_STREAMING) {\r\nif (cam->buffer_mode == B_DMA_sg && cam->vb_bufs[0])\r\nlist_add(&cam->vb_bufs[0]->queue, &cam->buffers);\r\nret = mcam_read_setup(cam);\r\n}\r\nreturn ret;\r\n}
