static void navpoint_packet(struct navpoint *navpoint)\r\n{\r\nint finger;\r\nint gesture;\r\nint x, y, z;\r\nswitch (navpoint->data[0]) {\r\ncase 0xff:\r\ncase 0x00:\r\nbreak;\r\ncase 0x0e:\r\nfinger = (navpoint->data[1] & 0x01);\r\ngesture = (navpoint->data[1] & 0x02);\r\nx = ((navpoint->data[2] & 0x1f) << 8) | navpoint->data[3];\r\ny = ((navpoint->data[4] & 0x1f) << 8) | navpoint->data[5];\r\nz = navpoint->data[6];\r\ninput_report_key(navpoint->input, BTN_TOUCH, finger);\r\ninput_report_abs(navpoint->input, ABS_X, x);\r\ninput_report_abs(navpoint->input, ABS_Y, y);\r\ninput_report_abs(navpoint->input, ABS_PRESSURE, z);\r\ninput_report_key(navpoint->input, BTN_TOOL_FINGER, finger);\r\ninput_report_key(navpoint->input, BTN_LEFT, gesture);\r\ninput_sync(navpoint->input);\r\nbreak;\r\ncase 0x19:\r\nif ((navpoint->data[1] & 0xf0) == 0x10)\r\nbreak;\r\ndefault:\r\ndev_warn(navpoint->dev,\r\n"spurious packet: data=0x%02x,0x%02x,...\n",\r\nnavpoint->data[0], navpoint->data[1]);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t navpoint_irq(int irq, void *dev_id)\r\n{\r\nstruct navpoint *navpoint = dev_id;\r\nstruct ssp_device *ssp = navpoint->ssp;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 status;\r\nstatus = pxa_ssp_read_reg(ssp, SSSR);\r\nif (status & sssr) {\r\ndev_warn(navpoint->dev,\r\n"unexpected interrupt: status=0x%08x\n", status);\r\npxa_ssp_write_reg(ssp, SSSR, (status & sssr));\r\nret = IRQ_HANDLED;\r\n}\r\nwhile (status & SSSR_RNE) {\r\nu32 data;\r\ndata = pxa_ssp_read_reg(ssp, SSDR);\r\nnavpoint->data[navpoint->index + 0] = (data >> 8);\r\nnavpoint->data[navpoint->index + 1] = data;\r\nnavpoint->index += 2;\r\nif (HEADER_LENGTH(navpoint->data[0]) < navpoint->index) {\r\nnavpoint_packet(navpoint);\r\nnavpoint->index = 0;\r\n}\r\nstatus = pxa_ssp_read_reg(ssp, SSSR);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic void navpoint_up(struct navpoint *navpoint)\r\n{\r\nstruct ssp_device *ssp = navpoint->ssp;\r\nint timeout;\r\nclk_prepare_enable(ssp->clk);\r\npxa_ssp_write_reg(ssp, SSCR1, sscr1);\r\npxa_ssp_write_reg(ssp, SSSR, sssr);\r\npxa_ssp_write_reg(ssp, SSTO, 0);\r\npxa_ssp_write_reg(ssp, SSCR0, sscr0);\r\nfor (timeout = 100; timeout != 0; --timeout) {\r\nif (!(pxa_ssp_read_reg(ssp, SSSR) & SSSR_CSS))\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (timeout == 0)\r\ndev_err(navpoint->dev,\r\n"timeout waiting for SSSR[CSS] to clear\n");\r\nif (gpio_is_valid(navpoint->gpio))\r\ngpio_set_value(navpoint->gpio, 1);\r\n}\r\nstatic void navpoint_down(struct navpoint *navpoint)\r\n{\r\nstruct ssp_device *ssp = navpoint->ssp;\r\nif (gpio_is_valid(navpoint->gpio))\r\ngpio_set_value(navpoint->gpio, 0);\r\npxa_ssp_write_reg(ssp, SSCR0, 0);\r\nclk_disable_unprepare(ssp->clk);\r\n}\r\nstatic int navpoint_open(struct input_dev *input)\r\n{\r\nstruct navpoint *navpoint = input_get_drvdata(input);\r\nnavpoint_up(navpoint);\r\nreturn 0;\r\n}\r\nstatic void navpoint_close(struct input_dev *input)\r\n{\r\nstruct navpoint *navpoint = input_get_drvdata(input);\r\nnavpoint_down(navpoint);\r\n}\r\nstatic int __devinit navpoint_probe(struct platform_device *pdev)\r\n{\r\nconst struct navpoint_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct ssp_device *ssp;\r\nstruct input_dev *input;\r\nstruct navpoint *navpoint;\r\nint error;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (gpio_is_valid(pdata->gpio)) {\r\nerror = gpio_request_one(pdata->gpio, GPIOF_OUT_INIT_LOW,\r\n"SYNAPTICS_ON");\r\nif (error)\r\nreturn error;\r\n}\r\nssp = pxa_ssp_request(pdata->port, pdev->name);\r\nif (!ssp) {\r\nerror = -ENODEV;\r\ngoto err_free_gpio;\r\n}\r\nif (pxa_ssp_read_reg(ssp, SSCR0) & SSCR0_SSE) {\r\npxa_ssp_write_reg(ssp, SSCR0, 0);\r\ndev_warn(&pdev->dev, "ssp%d already enabled\n", pdata->port);\r\n}\r\nnavpoint = kzalloc(sizeof(*navpoint), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!navpoint || !input) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nnavpoint->ssp = ssp;\r\nnavpoint->input = input;\r\nnavpoint->dev = &pdev->dev;\r\nnavpoint->gpio = pdata->gpio;\r\ninput->name = pdev->name;\r\ninput->dev.parent = &pdev->dev;\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(EV_ABS, input->evbit);\r\n__set_bit(BTN_LEFT, input->keybit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\n__set_bit(BTN_TOOL_FINGER, input->keybit);\r\ninput_set_abs_params(input, ABS_X,\r\nNAVPOINT_X_MIN, NAVPOINT_X_MAX, 0, 0);\r\ninput_set_abs_params(input, ABS_Y,\r\nNAVPOINT_Y_MIN, NAVPOINT_Y_MAX, 0, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE,\r\nNAVPOINT_PRESSURE_MIN, NAVPOINT_PRESSURE_MAX,\r\n0, 0);\r\ninput->open = navpoint_open;\r\ninput->close = navpoint_close;\r\ninput_set_drvdata(input, navpoint);\r\nerror = request_irq(ssp->irq, navpoint_irq, 0, pdev->name, navpoint);\r\nif (error)\r\ngoto err_free_mem;\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_free_irq;\r\nplatform_set_drvdata(pdev, navpoint);\r\ndev_dbg(&pdev->dev, "ssp%d, irq %d\n", pdata->port, ssp->irq);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(ssp->irq, &pdev->dev);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(navpoint);\r\npxa_ssp_free(ssp);\r\nerr_free_gpio:\r\nif (gpio_is_valid(pdata->gpio))\r\ngpio_free(pdata->gpio);\r\nreturn error;\r\n}\r\nstatic int __devexit navpoint_remove(struct platform_device *pdev)\r\n{\r\nconst struct navpoint_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct navpoint *navpoint = platform_get_drvdata(pdev);\r\nstruct ssp_device *ssp = navpoint->ssp;\r\nfree_irq(ssp->irq, navpoint);\r\ninput_unregister_device(navpoint->input);\r\nkfree(navpoint);\r\npxa_ssp_free(ssp);\r\nif (gpio_is_valid(pdata->gpio))\r\ngpio_free(pdata->gpio);\r\nreturn 0;\r\n}\r\nstatic int navpoint_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct navpoint *navpoint = platform_get_drvdata(pdev);\r\nstruct input_dev *input = navpoint->input;\r\nmutex_lock(&input->mutex);\r\nif (input->users)\r\nnavpoint_down(navpoint);\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}\r\nstatic int navpoint_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct navpoint *navpoint = platform_get_drvdata(pdev);\r\nstruct input_dev *input = navpoint->input;\r\nmutex_lock(&input->mutex);\r\nif (input->users)\r\nnavpoint_up(navpoint);\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}
