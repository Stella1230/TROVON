static inline int open_arg(int flags, int mask)\r\n{\r\nint n = ACC_MODE(flags);\r\nif (flags & (O_TRUNC | O_CREAT))\r\nn |= AUDIT_PERM_WRITE;\r\nreturn n & mask;\r\n}\r\nstatic int audit_match_perm(struct audit_context *ctx, int mask)\r\n{\r\nunsigned n;\r\nif (unlikely(!ctx))\r\nreturn 0;\r\nn = ctx->major;\r\nswitch (audit_classify_syscall(ctx->arch, n)) {\r\ncase 0:\r\nif ((mask & AUDIT_PERM_WRITE) &&\r\naudit_match_class(AUDIT_CLASS_WRITE, n))\r\nreturn 1;\r\nif ((mask & AUDIT_PERM_READ) &&\r\naudit_match_class(AUDIT_CLASS_READ, n))\r\nreturn 1;\r\nif ((mask & AUDIT_PERM_ATTR) &&\r\naudit_match_class(AUDIT_CLASS_CHATTR, n))\r\nreturn 1;\r\nreturn 0;\r\ncase 1:\r\nif ((mask & AUDIT_PERM_WRITE) &&\r\naudit_match_class(AUDIT_CLASS_WRITE_32, n))\r\nreturn 1;\r\nif ((mask & AUDIT_PERM_READ) &&\r\naudit_match_class(AUDIT_CLASS_READ_32, n))\r\nreturn 1;\r\nif ((mask & AUDIT_PERM_ATTR) &&\r\naudit_match_class(AUDIT_CLASS_CHATTR_32, n))\r\nreturn 1;\r\nreturn 0;\r\ncase 2:\r\nreturn mask & ACC_MODE(ctx->argv[1]);\r\ncase 3:\r\nreturn mask & ACC_MODE(ctx->argv[2]);\r\ncase 4:\r\nreturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\r\ncase 5:\r\nreturn mask & AUDIT_PERM_EXEC;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int audit_match_filetype(struct audit_context *ctx, int val)\r\n{\r\nstruct audit_names *n;\r\numode_t mode = (umode_t)val;\r\nif (unlikely(!ctx))\r\nreturn 0;\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\nif ((n->ino != -1) &&\r\n((n->mode & S_IFMT) == mode))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void audit_set_auditable(struct audit_context *ctx)\r\n{\r\nif (!ctx->prio) {\r\nctx->prio = 1;\r\nctx->current_state = AUDIT_RECORD_CONTEXT;\r\n}\r\n}\r\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\r\n{\r\nstruct audit_tree_refs *p = ctx->trees;\r\nint left = ctx->tree_count;\r\nif (likely(left)) {\r\np->c[--left] = chunk;\r\nctx->tree_count = left;\r\nreturn 1;\r\n}\r\nif (!p)\r\nreturn 0;\r\np = p->next;\r\nif (p) {\r\np->c[30] = chunk;\r\nctx->trees = p;\r\nctx->tree_count = 30;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int grow_tree_refs(struct audit_context *ctx)\r\n{\r\nstruct audit_tree_refs *p = ctx->trees;\r\nctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\r\nif (!ctx->trees) {\r\nctx->trees = p;\r\nreturn 0;\r\n}\r\nif (p)\r\np->next = ctx->trees;\r\nelse\r\nctx->first_trees = ctx->trees;\r\nctx->tree_count = 31;\r\nreturn 1;\r\n}\r\nstatic void unroll_tree_refs(struct audit_context *ctx,\r\nstruct audit_tree_refs *p, int count)\r\n{\r\n#ifdef CONFIG_AUDIT_TREE\r\nstruct audit_tree_refs *q;\r\nint n;\r\nif (!p) {\r\np = ctx->first_trees;\r\ncount = 31;\r\nif (!p)\r\nreturn;\r\n}\r\nn = count;\r\nfor (q = p; q != ctx->trees; q = q->next, n = 31) {\r\nwhile (n--) {\r\naudit_put_chunk(q->c[n]);\r\nq->c[n] = NULL;\r\n}\r\n}\r\nwhile (n-- > ctx->tree_count) {\r\naudit_put_chunk(q->c[n]);\r\nq->c[n] = NULL;\r\n}\r\nctx->trees = p;\r\nctx->tree_count = count;\r\n#endif\r\n}\r\nstatic void free_tree_refs(struct audit_context *ctx)\r\n{\r\nstruct audit_tree_refs *p, *q;\r\nfor (p = ctx->first_trees; p; p = q) {\r\nq = p->next;\r\nkfree(p);\r\n}\r\n}\r\nstatic int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\r\n{\r\n#ifdef CONFIG_AUDIT_TREE\r\nstruct audit_tree_refs *p;\r\nint n;\r\nif (!tree)\r\nreturn 0;\r\nfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\r\nfor (n = 0; n < 31; n++)\r\nif (audit_tree_match(p->c[n], tree))\r\nreturn 1;\r\n}\r\nif (p) {\r\nfor (n = ctx->tree_count; n < 31; n++)\r\nif (audit_tree_match(p->c[n], tree))\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int audit_compare_id(uid_t uid1,\r\nstruct audit_names *name,\r\nunsigned long name_offset,\r\nstruct audit_field *f,\r\nstruct audit_context *ctx)\r\n{\r\nstruct audit_names *n;\r\nunsigned long addr;\r\nuid_t uid2;\r\nint rc;\r\nBUILD_BUG_ON(sizeof(uid_t) != sizeof(gid_t));\r\nif (name) {\r\naddr = (unsigned long)name;\r\naddr += name_offset;\r\nuid2 = *(uid_t *)addr;\r\nrc = audit_comparator(uid1, f->op, uid2);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (ctx) {\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\naddr = (unsigned long)n;\r\naddr += name_offset;\r\nuid2 = *(uid_t *)addr;\r\nrc = audit_comparator(uid1, f->op, uid2);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int audit_field_compare(struct task_struct *tsk,\r\nconst struct cred *cred,\r\nstruct audit_field *f,\r\nstruct audit_context *ctx,\r\nstruct audit_names *name)\r\n{\r\nswitch (f->val) {\r\ncase AUDIT_COMPARE_UID_TO_OBJ_UID:\r\nreturn audit_compare_id(cred->uid,\r\nname, offsetof(struct audit_names, uid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_GID_TO_OBJ_GID:\r\nreturn audit_compare_id(cred->gid,\r\nname, offsetof(struct audit_names, gid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_EUID_TO_OBJ_UID:\r\nreturn audit_compare_id(cred->euid,\r\nname, offsetof(struct audit_names, uid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_EGID_TO_OBJ_GID:\r\nreturn audit_compare_id(cred->egid,\r\nname, offsetof(struct audit_names, gid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_AUID_TO_OBJ_UID:\r\nreturn audit_compare_id(tsk->loginuid,\r\nname, offsetof(struct audit_names, uid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_SUID_TO_OBJ_UID:\r\nreturn audit_compare_id(cred->suid,\r\nname, offsetof(struct audit_names, uid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_SGID_TO_OBJ_GID:\r\nreturn audit_compare_id(cred->sgid,\r\nname, offsetof(struct audit_names, gid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\r\nreturn audit_compare_id(cred->fsuid,\r\nname, offsetof(struct audit_names, uid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\r\nreturn audit_compare_id(cred->fsgid,\r\nname, offsetof(struct audit_names, gid),\r\nf, ctx);\r\ncase AUDIT_COMPARE_UID_TO_AUID:\r\nreturn audit_comparator(cred->uid, f->op, tsk->loginuid);\r\ncase AUDIT_COMPARE_UID_TO_EUID:\r\nreturn audit_comparator(cred->uid, f->op, cred->euid);\r\ncase AUDIT_COMPARE_UID_TO_SUID:\r\nreturn audit_comparator(cred->uid, f->op, cred->suid);\r\ncase AUDIT_COMPARE_UID_TO_FSUID:\r\nreturn audit_comparator(cred->uid, f->op, cred->fsuid);\r\ncase AUDIT_COMPARE_AUID_TO_EUID:\r\nreturn audit_comparator(tsk->loginuid, f->op, cred->euid);\r\ncase AUDIT_COMPARE_AUID_TO_SUID:\r\nreturn audit_comparator(tsk->loginuid, f->op, cred->suid);\r\ncase AUDIT_COMPARE_AUID_TO_FSUID:\r\nreturn audit_comparator(tsk->loginuid, f->op, cred->fsuid);\r\ncase AUDIT_COMPARE_EUID_TO_SUID:\r\nreturn audit_comparator(cred->euid, f->op, cred->suid);\r\ncase AUDIT_COMPARE_EUID_TO_FSUID:\r\nreturn audit_comparator(cred->euid, f->op, cred->fsuid);\r\ncase AUDIT_COMPARE_SUID_TO_FSUID:\r\nreturn audit_comparator(cred->suid, f->op, cred->fsuid);\r\ncase AUDIT_COMPARE_GID_TO_EGID:\r\nreturn audit_comparator(cred->gid, f->op, cred->egid);\r\ncase AUDIT_COMPARE_GID_TO_SGID:\r\nreturn audit_comparator(cred->gid, f->op, cred->sgid);\r\ncase AUDIT_COMPARE_GID_TO_FSGID:\r\nreturn audit_comparator(cred->gid, f->op, cred->fsgid);\r\ncase AUDIT_COMPARE_EGID_TO_SGID:\r\nreturn audit_comparator(cred->egid, f->op, cred->sgid);\r\ncase AUDIT_COMPARE_EGID_TO_FSGID:\r\nreturn audit_comparator(cred->egid, f->op, cred->fsgid);\r\ncase AUDIT_COMPARE_SGID_TO_FSGID:\r\nreturn audit_comparator(cred->sgid, f->op, cred->fsgid);\r\ndefault:\r\nWARN(1, "Missing AUDIT_COMPARE define. Report as a bug\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int audit_filter_rules(struct task_struct *tsk,\r\nstruct audit_krule *rule,\r\nstruct audit_context *ctx,\r\nstruct audit_names *name,\r\nenum audit_state *state,\r\nbool task_creation)\r\n{\r\nconst struct cred *cred;\r\nint i, need_sid = 1;\r\nu32 sid;\r\ncred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\r\nfor (i = 0; i < rule->field_count; i++) {\r\nstruct audit_field *f = &rule->fields[i];\r\nstruct audit_names *n;\r\nint result = 0;\r\nswitch (f->type) {\r\ncase AUDIT_PID:\r\nresult = audit_comparator(tsk->pid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_PPID:\r\nif (ctx) {\r\nif (!ctx->ppid)\r\nctx->ppid = sys_getppid();\r\nresult = audit_comparator(ctx->ppid, f->op, f->val);\r\n}\r\nbreak;\r\ncase AUDIT_UID:\r\nresult = audit_comparator(cred->uid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_EUID:\r\nresult = audit_comparator(cred->euid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_SUID:\r\nresult = audit_comparator(cred->suid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_FSUID:\r\nresult = audit_comparator(cred->fsuid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_GID:\r\nresult = audit_comparator(cred->gid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_EGID:\r\nresult = audit_comparator(cred->egid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_SGID:\r\nresult = audit_comparator(cred->sgid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_FSGID:\r\nresult = audit_comparator(cred->fsgid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_PERS:\r\nresult = audit_comparator(tsk->personality, f->op, f->val);\r\nbreak;\r\ncase AUDIT_ARCH:\r\nif (ctx)\r\nresult = audit_comparator(ctx->arch, f->op, f->val);\r\nbreak;\r\ncase AUDIT_EXIT:\r\nif (ctx && ctx->return_valid)\r\nresult = audit_comparator(ctx->return_code, f->op, f->val);\r\nbreak;\r\ncase AUDIT_SUCCESS:\r\nif (ctx && ctx->return_valid) {\r\nif (f->val)\r\nresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\r\nelse\r\nresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\r\n}\r\nbreak;\r\ncase AUDIT_DEVMAJOR:\r\nif (name) {\r\nif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\r\naudit_comparator(MAJOR(name->rdev), f->op, f->val))\r\n++result;\r\n} else if (ctx) {\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\nif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\r\naudit_comparator(MAJOR(n->rdev), f->op, f->val)) {\r\n++result;\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase AUDIT_DEVMINOR:\r\nif (name) {\r\nif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\r\naudit_comparator(MINOR(name->rdev), f->op, f->val))\r\n++result;\r\n} else if (ctx) {\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\nif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\r\naudit_comparator(MINOR(n->rdev), f->op, f->val)) {\r\n++result;\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase AUDIT_INODE:\r\nif (name)\r\nresult = (name->ino == f->val);\r\nelse if (ctx) {\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\nif (audit_comparator(n->ino, f->op, f->val)) {\r\n++result;\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase AUDIT_OBJ_UID:\r\nif (name) {\r\nresult = audit_comparator(name->uid, f->op, f->val);\r\n} else if (ctx) {\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\nif (audit_comparator(n->uid, f->op, f->val)) {\r\n++result;\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase AUDIT_OBJ_GID:\r\nif (name) {\r\nresult = audit_comparator(name->gid, f->op, f->val);\r\n} else if (ctx) {\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\nif (audit_comparator(n->gid, f->op, f->val)) {\r\n++result;\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase AUDIT_WATCH:\r\nif (name)\r\nresult = audit_watch_compare(rule->watch, name->ino, name->dev);\r\nbreak;\r\ncase AUDIT_DIR:\r\nif (ctx)\r\nresult = match_tree_refs(ctx, rule->tree);\r\nbreak;\r\ncase AUDIT_LOGINUID:\r\nresult = 0;\r\nif (ctx)\r\nresult = audit_comparator(tsk->loginuid, f->op, f->val);\r\nbreak;\r\ncase AUDIT_SUBJ_USER:\r\ncase AUDIT_SUBJ_ROLE:\r\ncase AUDIT_SUBJ_TYPE:\r\ncase AUDIT_SUBJ_SEN:\r\ncase AUDIT_SUBJ_CLR:\r\nif (f->lsm_rule) {\r\nif (need_sid) {\r\nsecurity_task_getsecid(tsk, &sid);\r\nneed_sid = 0;\r\n}\r\nresult = security_audit_rule_match(sid, f->type,\r\nf->op,\r\nf->lsm_rule,\r\nctx);\r\n}\r\nbreak;\r\ncase AUDIT_OBJ_USER:\r\ncase AUDIT_OBJ_ROLE:\r\ncase AUDIT_OBJ_TYPE:\r\ncase AUDIT_OBJ_LEV_LOW:\r\ncase AUDIT_OBJ_LEV_HIGH:\r\nif (f->lsm_rule) {\r\nif (name) {\r\nresult = security_audit_rule_match(\r\nname->osid, f->type, f->op,\r\nf->lsm_rule, ctx);\r\n} else if (ctx) {\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\nif (security_audit_rule_match(n->osid, f->type,\r\nf->op, f->lsm_rule,\r\nctx)) {\r\n++result;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!ctx || ctx->type != AUDIT_IPC)\r\nbreak;\r\nif (security_audit_rule_match(ctx->ipc.osid,\r\nf->type, f->op,\r\nf->lsm_rule, ctx))\r\n++result;\r\n}\r\nbreak;\r\ncase AUDIT_ARG0:\r\ncase AUDIT_ARG1:\r\ncase AUDIT_ARG2:\r\ncase AUDIT_ARG3:\r\nif (ctx)\r\nresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\r\nbreak;\r\ncase AUDIT_FILTERKEY:\r\nresult = 1;\r\nbreak;\r\ncase AUDIT_PERM:\r\nresult = audit_match_perm(ctx, f->val);\r\nbreak;\r\ncase AUDIT_FILETYPE:\r\nresult = audit_match_filetype(ctx, f->val);\r\nbreak;\r\ncase AUDIT_FIELD_COMPARE:\r\nresult = audit_field_compare(tsk, cred, f, ctx, name);\r\nbreak;\r\n}\r\nif (!result)\r\nreturn 0;\r\n}\r\nif (ctx) {\r\nif (rule->prio <= ctx->prio)\r\nreturn 0;\r\nif (rule->filterkey) {\r\nkfree(ctx->filterkey);\r\nctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\r\n}\r\nctx->prio = rule->prio;\r\n}\r\nswitch (rule->action) {\r\ncase AUDIT_NEVER: *state = AUDIT_DISABLED; break;\r\ncase AUDIT_ALWAYS: *state = AUDIT_RECORD_CONTEXT; break;\r\n}\r\nreturn 1;\r\n}\r\nstatic enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\r\n{\r\nstruct audit_entry *e;\r\nenum audit_state state;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\r\nif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\r\n&state, true)) {\r\nif (state == AUDIT_RECORD_CONTEXT)\r\n*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\r\nrcu_read_unlock();\r\nreturn state;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn AUDIT_BUILD_CONTEXT;\r\n}\r\nstatic enum audit_state audit_filter_syscall(struct task_struct *tsk,\r\nstruct audit_context *ctx,\r\nstruct list_head *list)\r\n{\r\nstruct audit_entry *e;\r\nenum audit_state state;\r\nif (audit_pid && tsk->tgid == audit_pid)\r\nreturn AUDIT_DISABLED;\r\nrcu_read_lock();\r\nif (!list_empty(list)) {\r\nint word = AUDIT_WORD(ctx->major);\r\nint bit = AUDIT_BIT(ctx->major);\r\nlist_for_each_entry_rcu(e, list, list) {\r\nif ((e->rule.mask[word] & bit) == bit &&\r\naudit_filter_rules(tsk, &e->rule, ctx, NULL,\r\n&state, false)) {\r\nrcu_read_unlock();\r\nctx->current_state = state;\r\nreturn state;\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn AUDIT_BUILD_CONTEXT;\r\n}\r\nstatic int audit_filter_inode_name(struct task_struct *tsk,\r\nstruct audit_names *n,\r\nstruct audit_context *ctx) {\r\nint word, bit;\r\nint h = audit_hash_ino((u32)n->ino);\r\nstruct list_head *list = &audit_inode_hash[h];\r\nstruct audit_entry *e;\r\nenum audit_state state;\r\nword = AUDIT_WORD(ctx->major);\r\nbit = AUDIT_BIT(ctx->major);\r\nif (list_empty(list))\r\nreturn 0;\r\nlist_for_each_entry_rcu(e, list, list) {\r\nif ((e->rule.mask[word] & bit) == bit &&\r\naudit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\r\nctx->current_state = state;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\r\n{\r\nstruct audit_names *n;\r\nif (audit_pid && tsk->tgid == audit_pid)\r\nreturn;\r\nrcu_read_lock();\r\nlist_for_each_entry(n, &ctx->names_list, list) {\r\nif (audit_filter_inode_name(tsk, n, ctx))\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic inline struct audit_context *audit_get_context(struct task_struct *tsk,\r\nint return_valid,\r\nlong return_code)\r\n{\r\nstruct audit_context *context = tsk->audit_context;\r\nif (!context)\r\nreturn NULL;\r\ncontext->return_valid = return_valid;\r\nif (unlikely(return_code <= -ERESTARTSYS) &&\r\n(return_code >= -ERESTART_RESTARTBLOCK) &&\r\n(return_code != -ENOIOCTLCMD))\r\ncontext->return_code = -EINTR;\r\nelse\r\ncontext->return_code = return_code;\r\nif (context->in_syscall && !context->dummy) {\r\naudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\r\naudit_filter_inodes(tsk, context);\r\n}\r\ntsk->audit_context = NULL;\r\nreturn context;\r\n}\r\nstatic inline void audit_free_names(struct audit_context *context)\r\n{\r\nstruct audit_names *n, *next;\r\n#if AUDIT_DEBUG == 2\r\nif (context->put_count + context->ino_count != context->name_count) {\r\nprintk(KERN_ERR "%s:%d(:%d): major=%d in_syscall=%d"\r\n" name_count=%d put_count=%d"\r\n" ino_count=%d [NOT freeing]\n",\r\n__FILE__, __LINE__,\r\ncontext->serial, context->major, context->in_syscall,\r\ncontext->name_count, context->put_count,\r\ncontext->ino_count);\r\nlist_for_each_entry(n, &context->names_list, list) {\r\nprintk(KERN_ERR "names[%d] = %p = %s\n", i,\r\nn->name, n->name ?: "(null)");\r\n}\r\ndump_stack();\r\nreturn;\r\n}\r\n#endif\r\n#if AUDIT_DEBUG\r\ncontext->put_count = 0;\r\ncontext->ino_count = 0;\r\n#endif\r\nlist_for_each_entry_safe(n, next, &context->names_list, list) {\r\nlist_del(&n->list);\r\nif (n->name && n->name_put)\r\n__putname(n->name);\r\nif (n->should_free)\r\nkfree(n);\r\n}\r\ncontext->name_count = 0;\r\npath_put(&context->pwd);\r\ncontext->pwd.dentry = NULL;\r\ncontext->pwd.mnt = NULL;\r\n}\r\nstatic inline void audit_free_aux(struct audit_context *context)\r\n{\r\nstruct audit_aux_data *aux;\r\nwhile ((aux = context->aux)) {\r\ncontext->aux = aux->next;\r\nkfree(aux);\r\n}\r\nwhile ((aux = context->aux_pids)) {\r\ncontext->aux_pids = aux->next;\r\nkfree(aux);\r\n}\r\n}\r\nstatic inline void audit_zero_context(struct audit_context *context,\r\nenum audit_state state)\r\n{\r\nmemset(context, 0, sizeof(*context));\r\ncontext->state = state;\r\ncontext->prio = state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\r\n}\r\nstatic inline struct audit_context *audit_alloc_context(enum audit_state state)\r\n{\r\nstruct audit_context *context;\r\nif (!(context = kmalloc(sizeof(*context), GFP_KERNEL)))\r\nreturn NULL;\r\naudit_zero_context(context, state);\r\nINIT_LIST_HEAD(&context->killed_trees);\r\nINIT_LIST_HEAD(&context->names_list);\r\nreturn context;\r\n}\r\nint audit_alloc(struct task_struct *tsk)\r\n{\r\nstruct audit_context *context;\r\nenum audit_state state;\r\nchar *key = NULL;\r\nif (likely(!audit_ever_enabled))\r\nreturn 0;\r\nstate = audit_filter_task(tsk, &key);\r\nif (state == AUDIT_DISABLED)\r\nreturn 0;\r\nif (!(context = audit_alloc_context(state))) {\r\nkfree(key);\r\naudit_log_lost("out of memory in audit_alloc");\r\nreturn -ENOMEM;\r\n}\r\ncontext->filterkey = key;\r\ntsk->audit_context = context;\r\nset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\r\nreturn 0;\r\n}\r\nstatic inline void audit_free_context(struct audit_context *context)\r\n{\r\nstruct audit_context *previous;\r\nint count = 0;\r\ndo {\r\nprevious = context->previous;\r\nif (previous || (count && count < 10)) {\r\n++count;\r\nprintk(KERN_ERR "audit(:%d): major=%d name_count=%d:"\r\n" freeing multiple contexts (%d)\n",\r\ncontext->serial, context->major,\r\ncontext->name_count, count);\r\n}\r\naudit_free_names(context);\r\nunroll_tree_refs(context, NULL, 0);\r\nfree_tree_refs(context);\r\naudit_free_aux(context);\r\nkfree(context->filterkey);\r\nkfree(context->sockaddr);\r\nkfree(context);\r\ncontext = previous;\r\n} while (context);\r\nif (count >= 10)\r\nprintk(KERN_ERR "audit: freed %d contexts\n", count);\r\n}\r\nvoid audit_log_task_context(struct audit_buffer *ab)\r\n{\r\nchar *ctx = NULL;\r\nunsigned len;\r\nint error;\r\nu32 sid;\r\nsecurity_task_getsecid(current, &sid);\r\nif (!sid)\r\nreturn;\r\nerror = security_secid_to_secctx(sid, &ctx, &len);\r\nif (error) {\r\nif (error != -EINVAL)\r\ngoto error_path;\r\nreturn;\r\n}\r\naudit_log_format(ab, " subj=%s", ctx);\r\nsecurity_release_secctx(ctx, len);\r\nreturn;\r\nerror_path:\r\naudit_panic("error in audit_log_task_context");\r\nreturn;\r\n}\r\nstatic void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\r\n{\r\nchar name[sizeof(tsk->comm)];\r\nstruct mm_struct *mm = tsk->mm;\r\nstruct vm_area_struct *vma;\r\nget_task_comm(name, tsk);\r\naudit_log_format(ab, " comm=");\r\naudit_log_untrustedstring(ab, name);\r\nif (mm) {\r\ndown_read(&mm->mmap_sem);\r\nvma = mm->mmap;\r\nwhile (vma) {\r\nif ((vma->vm_flags & VM_EXECUTABLE) &&\r\nvma->vm_file) {\r\naudit_log_d_path(ab, " exe=",\r\n&vma->vm_file->f_path);\r\nbreak;\r\n}\r\nvma = vma->vm_next;\r\n}\r\nup_read(&mm->mmap_sem);\r\n}\r\naudit_log_task_context(ab);\r\n}\r\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\r\nuid_t auid, uid_t uid, unsigned int sessionid,\r\nu32 sid, char *comm)\r\n{\r\nstruct audit_buffer *ab;\r\nchar *ctx = NULL;\r\nu32 len;\r\nint rc = 0;\r\nab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\r\nif (!ab)\r\nreturn rc;\r\naudit_log_format(ab, "opid=%d oauid=%d ouid=%d oses=%d", pid, auid,\r\nuid, sessionid);\r\nif (security_secid_to_secctx(sid, &ctx, &len)) {\r\naudit_log_format(ab, " obj=(none)");\r\nrc = 1;\r\n} else {\r\naudit_log_format(ab, " obj=%s", ctx);\r\nsecurity_release_secctx(ctx, len);\r\n}\r\naudit_log_format(ab, " ocomm=");\r\naudit_log_untrustedstring(ab, comm);\r\naudit_log_end(ab);\r\nreturn rc;\r\n}\r\nstatic int audit_log_single_execve_arg(struct audit_context *context,\r\nstruct audit_buffer **ab,\r\nint arg_num,\r\nsize_t *len_sent,\r\nconst char __user *p,\r\nchar *buf)\r\n{\r\nchar arg_num_len_buf[12];\r\nconst char __user *tmp_p = p;\r\nsize_t arg_num_len = snprintf(arg_num_len_buf, 12, "%d", arg_num) + 5;\r\nsize_t len, len_left, to_send;\r\nsize_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;\r\nunsigned int i, has_cntl = 0, too_long = 0;\r\nint ret;\r\nlen_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;\r\nif (unlikely((len == -1) || len > MAX_ARG_STRLEN - 1)) {\r\nWARN_ON(1);\r\nsend_sig(SIGKILL, current, 0);\r\nreturn -1;\r\n}\r\ndo {\r\nif (len_left > MAX_EXECVE_AUDIT_LEN)\r\nto_send = MAX_EXECVE_AUDIT_LEN;\r\nelse\r\nto_send = len_left;\r\nret = copy_from_user(buf, tmp_p, to_send);\r\nif (ret) {\r\nWARN_ON(1);\r\nsend_sig(SIGKILL, current, 0);\r\nreturn -1;\r\n}\r\nbuf[to_send] = '\0';\r\nhas_cntl = audit_string_contains_control(buf, to_send);\r\nif (has_cntl) {\r\nmax_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;\r\nbreak;\r\n}\r\nlen_left -= to_send;\r\ntmp_p += to_send;\r\n} while (len_left > 0);\r\nlen_left = len;\r\nif (len > max_execve_audit_len)\r\ntoo_long = 1;\r\nfor (i = 0; len_left > 0; i++) {\r\nint room_left;\r\nif (len_left > max_execve_audit_len)\r\nto_send = max_execve_audit_len;\r\nelse\r\nto_send = len_left;\r\nroom_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;\r\nif (has_cntl)\r\nroom_left -= (to_send * 2);\r\nelse\r\nroom_left -= to_send;\r\nif (room_left < 0) {\r\n*len_sent = 0;\r\naudit_log_end(*ab);\r\n*ab = audit_log_start(context, GFP_KERNEL, AUDIT_EXECVE);\r\nif (!*ab)\r\nreturn 0;\r\n}\r\nif ((i == 0) && (too_long))\r\naudit_log_format(*ab, " a%d_len=%zu", arg_num,\r\nhas_cntl ? 2*len : len);\r\nif (len >= max_execve_audit_len)\r\nret = copy_from_user(buf, p, to_send);\r\nelse\r\nret = 0;\r\nif (ret) {\r\nWARN_ON(1);\r\nsend_sig(SIGKILL, current, 0);\r\nreturn -1;\r\n}\r\nbuf[to_send] = '\0';\r\naudit_log_format(*ab, " a%d", arg_num);\r\nif (too_long)\r\naudit_log_format(*ab, "[%d]", i);\r\naudit_log_format(*ab, "=");\r\nif (has_cntl)\r\naudit_log_n_hex(*ab, buf, to_send);\r\nelse\r\naudit_log_string(*ab, buf);\r\np += to_send;\r\nlen_left -= to_send;\r\n*len_sent += arg_num_len;\r\nif (has_cntl)\r\n*len_sent += to_send * 2;\r\nelse\r\n*len_sent += to_send;\r\n}\r\nreturn len + 1;\r\n}\r\nstatic void audit_log_execve_info(struct audit_context *context,\r\nstruct audit_buffer **ab,\r\nstruct audit_aux_data_execve *axi)\r\n{\r\nint i, len;\r\nsize_t len_sent = 0;\r\nconst char __user *p;\r\nchar *buf;\r\nif (axi->mm != current->mm)\r\nreturn;\r\np = (const char __user *)axi->mm->arg_start;\r\naudit_log_format(*ab, "argc=%d", axi->argc);\r\nbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\r\nif (!buf) {\r\naudit_panic("out of memory for argv string\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < axi->argc; i++) {\r\nlen = audit_log_single_execve_arg(context, ab, i,\r\n&len_sent, p, buf);\r\nif (len <= 0)\r\nbreak;\r\np += len;\r\n}\r\nkfree(buf);\r\n}\r\nstatic void audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\r\n{\r\nint i;\r\naudit_log_format(ab, " %s=", prefix);\r\nCAP_FOR_EACH_U32(i) {\r\naudit_log_format(ab, "%08x", cap->cap[(_KERNEL_CAPABILITY_U32S-1) - i]);\r\n}\r\n}\r\nstatic void audit_log_fcaps(struct audit_buffer *ab, struct audit_names *name)\r\n{\r\nkernel_cap_t *perm = &name->fcap.permitted;\r\nkernel_cap_t *inh = &name->fcap.inheritable;\r\nint log = 0;\r\nif (!cap_isclear(*perm)) {\r\naudit_log_cap(ab, "cap_fp", perm);\r\nlog = 1;\r\n}\r\nif (!cap_isclear(*inh)) {\r\naudit_log_cap(ab, "cap_fi", inh);\r\nlog = 1;\r\n}\r\nif (log)\r\naudit_log_format(ab, " cap_fe=%d cap_fver=%x", name->fcap.fE, name->fcap_ver);\r\n}\r\nstatic void show_special(struct audit_context *context, int *call_panic)\r\n{\r\nstruct audit_buffer *ab;\r\nint i;\r\nab = audit_log_start(context, GFP_KERNEL, context->type);\r\nif (!ab)\r\nreturn;\r\nswitch (context->type) {\r\ncase AUDIT_SOCKETCALL: {\r\nint nargs = context->socketcall.nargs;\r\naudit_log_format(ab, "nargs=%d", nargs);\r\nfor (i = 0; i < nargs; i++)\r\naudit_log_format(ab, " a%d=%lx", i,\r\ncontext->socketcall.args[i]);\r\nbreak; }\r\ncase AUDIT_IPC: {\r\nu32 osid = context->ipc.osid;\r\naudit_log_format(ab, "ouid=%u ogid=%u mode=%#ho",\r\ncontext->ipc.uid, context->ipc.gid, context->ipc.mode);\r\nif (osid) {\r\nchar *ctx = NULL;\r\nu32 len;\r\nif (security_secid_to_secctx(osid, &ctx, &len)) {\r\naudit_log_format(ab, " osid=%u", osid);\r\n*call_panic = 1;\r\n} else {\r\naudit_log_format(ab, " obj=%s", ctx);\r\nsecurity_release_secctx(ctx, len);\r\n}\r\n}\r\nif (context->ipc.has_perm) {\r\naudit_log_end(ab);\r\nab = audit_log_start(context, GFP_KERNEL,\r\nAUDIT_IPC_SET_PERM);\r\naudit_log_format(ab,\r\n"qbytes=%lx ouid=%u ogid=%u mode=%#ho",\r\ncontext->ipc.qbytes,\r\ncontext->ipc.perm_uid,\r\ncontext->ipc.perm_gid,\r\ncontext->ipc.perm_mode);\r\nif (!ab)\r\nreturn;\r\n}\r\nbreak; }\r\ncase AUDIT_MQ_OPEN: {\r\naudit_log_format(ab,\r\n"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld "\r\n"mq_msgsize=%ld mq_curmsgs=%ld",\r\ncontext->mq_open.oflag, context->mq_open.mode,\r\ncontext->mq_open.attr.mq_flags,\r\ncontext->mq_open.attr.mq_maxmsg,\r\ncontext->mq_open.attr.mq_msgsize,\r\ncontext->mq_open.attr.mq_curmsgs);\r\nbreak; }\r\ncase AUDIT_MQ_SENDRECV: {\r\naudit_log_format(ab,\r\n"mqdes=%d msg_len=%zd msg_prio=%u "\r\n"abs_timeout_sec=%ld abs_timeout_nsec=%ld",\r\ncontext->mq_sendrecv.mqdes,\r\ncontext->mq_sendrecv.msg_len,\r\ncontext->mq_sendrecv.msg_prio,\r\ncontext->mq_sendrecv.abs_timeout.tv_sec,\r\ncontext->mq_sendrecv.abs_timeout.tv_nsec);\r\nbreak; }\r\ncase AUDIT_MQ_NOTIFY: {\r\naudit_log_format(ab, "mqdes=%d sigev_signo=%d",\r\ncontext->mq_notify.mqdes,\r\ncontext->mq_notify.sigev_signo);\r\nbreak; }\r\ncase AUDIT_MQ_GETSETATTR: {\r\nstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\r\naudit_log_format(ab,\r\n"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld "\r\n"mq_curmsgs=%ld ",\r\ncontext->mq_getsetattr.mqdes,\r\nattr->mq_flags, attr->mq_maxmsg,\r\nattr->mq_msgsize, attr->mq_curmsgs);\r\nbreak; }\r\ncase AUDIT_CAPSET: {\r\naudit_log_format(ab, "pid=%d", context->capset.pid);\r\naudit_log_cap(ab, "cap_pi", &context->capset.cap.inheritable);\r\naudit_log_cap(ab, "cap_pp", &context->capset.cap.permitted);\r\naudit_log_cap(ab, "cap_pe", &context->capset.cap.effective);\r\nbreak; }\r\ncase AUDIT_MMAP: {\r\naudit_log_format(ab, "fd=%d flags=0x%x", context->mmap.fd,\r\ncontext->mmap.flags);\r\nbreak; }\r\n}\r\naudit_log_end(ab);\r\n}\r\nstatic void audit_log_name(struct audit_context *context, struct audit_names *n,\r\nint record_num, int *call_panic)\r\n{\r\nstruct audit_buffer *ab;\r\nab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\r\nif (!ab)\r\nreturn;\r\naudit_log_format(ab, "item=%d", record_num);\r\nif (n->name) {\r\nswitch (n->name_len) {\r\ncase AUDIT_NAME_FULL:\r\naudit_log_format(ab, " name=");\r\naudit_log_untrustedstring(ab, n->name);\r\nbreak;\r\ncase 0:\r\naudit_log_d_path(ab, " name=", &context->pwd);\r\nbreak;\r\ndefault:\r\naudit_log_format(ab, " name=");\r\naudit_log_n_untrustedstring(ab, n->name,\r\nn->name_len);\r\n}\r\n} else\r\naudit_log_format(ab, " name=(null)");\r\nif (n->ino != (unsigned long)-1) {\r\naudit_log_format(ab, " inode=%lu"\r\n" dev=%02x:%02x mode=%#ho"\r\n" ouid=%u ogid=%u rdev=%02x:%02x",\r\nn->ino,\r\nMAJOR(n->dev),\r\nMINOR(n->dev),\r\nn->mode,\r\nn->uid,\r\nn->gid,\r\nMAJOR(n->rdev),\r\nMINOR(n->rdev));\r\n}\r\nif (n->osid != 0) {\r\nchar *ctx = NULL;\r\nu32 len;\r\nif (security_secid_to_secctx(\r\nn->osid, &ctx, &len)) {\r\naudit_log_format(ab, " osid=%u", n->osid);\r\n*call_panic = 2;\r\n} else {\r\naudit_log_format(ab, " obj=%s", ctx);\r\nsecurity_release_secctx(ctx, len);\r\n}\r\n}\r\naudit_log_fcaps(ab, n);\r\naudit_log_end(ab);\r\n}\r\nstatic void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\r\n{\r\nconst struct cred *cred;\r\nint i, call_panic = 0;\r\nstruct audit_buffer *ab;\r\nstruct audit_aux_data *aux;\r\nconst char *tty;\r\nstruct audit_names *n;\r\ncontext->pid = tsk->pid;\r\nif (!context->ppid)\r\ncontext->ppid = sys_getppid();\r\ncred = current_cred();\r\ncontext->uid = cred->uid;\r\ncontext->gid = cred->gid;\r\ncontext->euid = cred->euid;\r\ncontext->suid = cred->suid;\r\ncontext->fsuid = cred->fsuid;\r\ncontext->egid = cred->egid;\r\ncontext->sgid = cred->sgid;\r\ncontext->fsgid = cred->fsgid;\r\ncontext->personality = tsk->personality;\r\nab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\r\nif (!ab)\r\nreturn;\r\naudit_log_format(ab, "arch=%x syscall=%d",\r\ncontext->arch, context->major);\r\nif (context->personality != PER_LINUX)\r\naudit_log_format(ab, " per=%lx", context->personality);\r\nif (context->return_valid)\r\naudit_log_format(ab, " success=%s exit=%ld",\r\n(context->return_valid==AUDITSC_SUCCESS)?"yes":"no",\r\ncontext->return_code);\r\nspin_lock_irq(&tsk->sighand->siglock);\r\nif (tsk->signal && tsk->signal->tty && tsk->signal->tty->name)\r\ntty = tsk->signal->tty->name;\r\nelse\r\ntty = "(none)";\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\naudit_log_format(ab,\r\n" a0=%lx a1=%lx a2=%lx a3=%lx items=%d"\r\n" ppid=%d pid=%d auid=%u uid=%u gid=%u"\r\n" euid=%u suid=%u fsuid=%u"\r\n" egid=%u sgid=%u fsgid=%u tty=%s ses=%u",\r\ncontext->argv[0],\r\ncontext->argv[1],\r\ncontext->argv[2],\r\ncontext->argv[3],\r\ncontext->name_count,\r\ncontext->ppid,\r\ncontext->pid,\r\ntsk->loginuid,\r\ncontext->uid,\r\ncontext->gid,\r\ncontext->euid, context->suid, context->fsuid,\r\ncontext->egid, context->sgid, context->fsgid, tty,\r\ntsk->sessionid);\r\naudit_log_task_info(ab, tsk);\r\naudit_log_key(ab, context->filterkey);\r\naudit_log_end(ab);\r\nfor (aux = context->aux; aux; aux = aux->next) {\r\nab = audit_log_start(context, GFP_KERNEL, aux->type);\r\nif (!ab)\r\ncontinue;\r\nswitch (aux->type) {\r\ncase AUDIT_EXECVE: {\r\nstruct audit_aux_data_execve *axi = (void *)aux;\r\naudit_log_execve_info(context, &ab, axi);\r\nbreak; }\r\ncase AUDIT_BPRM_FCAPS: {\r\nstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\r\naudit_log_format(ab, "fver=%x", axs->fcap_ver);\r\naudit_log_cap(ab, "fp", &axs->fcap.permitted);\r\naudit_log_cap(ab, "fi", &axs->fcap.inheritable);\r\naudit_log_format(ab, " fe=%d", axs->fcap.fE);\r\naudit_log_cap(ab, "old_pp", &axs->old_pcap.permitted);\r\naudit_log_cap(ab, "old_pi", &axs->old_pcap.inheritable);\r\naudit_log_cap(ab, "old_pe", &axs->old_pcap.effective);\r\naudit_log_cap(ab, "new_pp", &axs->new_pcap.permitted);\r\naudit_log_cap(ab, "new_pi", &axs->new_pcap.inheritable);\r\naudit_log_cap(ab, "new_pe", &axs->new_pcap.effective);\r\nbreak; }\r\n}\r\naudit_log_end(ab);\r\n}\r\nif (context->type)\r\nshow_special(context, &call_panic);\r\nif (context->fds[0] >= 0) {\r\nab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\r\nif (ab) {\r\naudit_log_format(ab, "fd0=%d fd1=%d",\r\ncontext->fds[0], context->fds[1]);\r\naudit_log_end(ab);\r\n}\r\n}\r\nif (context->sockaddr_len) {\r\nab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\r\nif (ab) {\r\naudit_log_format(ab, "saddr=");\r\naudit_log_n_hex(ab, (void *)context->sockaddr,\r\ncontext->sockaddr_len);\r\naudit_log_end(ab);\r\n}\r\n}\r\nfor (aux = context->aux_pids; aux; aux = aux->next) {\r\nstruct audit_aux_data_pids *axs = (void *)aux;\r\nfor (i = 0; i < axs->pid_count; i++)\r\nif (audit_log_pid_context(context, axs->target_pid[i],\r\naxs->target_auid[i],\r\naxs->target_uid[i],\r\naxs->target_sessionid[i],\r\naxs->target_sid[i],\r\naxs->target_comm[i]))\r\ncall_panic = 1;\r\n}\r\nif (context->target_pid &&\r\naudit_log_pid_context(context, context->target_pid,\r\ncontext->target_auid, context->target_uid,\r\ncontext->target_sessionid,\r\ncontext->target_sid, context->target_comm))\r\ncall_panic = 1;\r\nif (context->pwd.dentry && context->pwd.mnt) {\r\nab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\r\nif (ab) {\r\naudit_log_d_path(ab, " cwd=", &context->pwd);\r\naudit_log_end(ab);\r\n}\r\n}\r\ni = 0;\r\nlist_for_each_entry(n, &context->names_list, list)\r\naudit_log_name(context, n, i++, &call_panic);\r\nab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\r\nif (ab)\r\naudit_log_end(ab);\r\nif (call_panic)\r\naudit_panic("error converting sid to string");\r\n}\r\nvoid __audit_free(struct task_struct *tsk)\r\n{\r\nstruct audit_context *context;\r\ncontext = audit_get_context(tsk, 0, 0);\r\nif (!context)\r\nreturn;\r\nif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\r\naudit_log_exit(context, tsk);\r\nif (!list_empty(&context->killed_trees))\r\naudit_kill_trees(&context->killed_trees);\r\naudit_free_context(context);\r\n}\r\nvoid __audit_syscall_entry(int arch, int major,\r\nunsigned long a1, unsigned long a2,\r\nunsigned long a3, unsigned long a4)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct audit_context *context = tsk->audit_context;\r\nenum audit_state state;\r\nif (!context)\r\nreturn;\r\nif (context->in_syscall) {\r\nstruct audit_context *newctx;\r\n#if AUDIT_DEBUG\r\nprintk(KERN_ERR\r\n"audit(:%d) pid=%d in syscall=%d;"\r\n" entering syscall=%d\n",\r\ncontext->serial, tsk->pid, context->major, major);\r\n#endif\r\nnewctx = audit_alloc_context(context->state);\r\nif (newctx) {\r\nnewctx->previous = context;\r\ncontext = newctx;\r\ntsk->audit_context = newctx;\r\n} else {\r\naudit_zero_context(context, context->state);\r\n}\r\n}\r\nBUG_ON(context->in_syscall || context->name_count);\r\nif (!audit_enabled)\r\nreturn;\r\ncontext->arch = arch;\r\ncontext->major = major;\r\ncontext->argv[0] = a1;\r\ncontext->argv[1] = a2;\r\ncontext->argv[2] = a3;\r\ncontext->argv[3] = a4;\r\nstate = context->state;\r\ncontext->dummy = !audit_n_rules;\r\nif (!context->dummy && state == AUDIT_BUILD_CONTEXT) {\r\ncontext->prio = 0;\r\nstate = audit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_ENTRY]);\r\n}\r\nif (state == AUDIT_DISABLED)\r\nreturn;\r\ncontext->serial = 0;\r\ncontext->ctime = CURRENT_TIME;\r\ncontext->in_syscall = 1;\r\ncontext->current_state = state;\r\ncontext->ppid = 0;\r\n}\r\nvoid __audit_syscall_exit(int success, long return_code)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct audit_context *context;\r\nif (success)\r\nsuccess = AUDITSC_SUCCESS;\r\nelse\r\nsuccess = AUDITSC_FAILURE;\r\ncontext = audit_get_context(tsk, success, return_code);\r\nif (!context)\r\nreturn;\r\nif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\r\naudit_log_exit(context, tsk);\r\ncontext->in_syscall = 0;\r\ncontext->prio = context->state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\r\nif (!list_empty(&context->killed_trees))\r\naudit_kill_trees(&context->killed_trees);\r\nif (context->previous) {\r\nstruct audit_context *new_context = context->previous;\r\ncontext->previous = NULL;\r\naudit_free_context(context);\r\ntsk->audit_context = new_context;\r\n} else {\r\naudit_free_names(context);\r\nunroll_tree_refs(context, NULL, 0);\r\naudit_free_aux(context);\r\ncontext->aux = NULL;\r\ncontext->aux_pids = NULL;\r\ncontext->target_pid = 0;\r\ncontext->target_sid = 0;\r\ncontext->sockaddr_len = 0;\r\ncontext->type = 0;\r\ncontext->fds[0] = -1;\r\nif (context->state != AUDIT_RECORD_CONTEXT) {\r\nkfree(context->filterkey);\r\ncontext->filterkey = NULL;\r\n}\r\ntsk->audit_context = context;\r\n}\r\n}\r\nstatic inline void handle_one(const struct inode *inode)\r\n{\r\n#ifdef CONFIG_AUDIT_TREE\r\nstruct audit_context *context;\r\nstruct audit_tree_refs *p;\r\nstruct audit_chunk *chunk;\r\nint count;\r\nif (likely(hlist_empty(&inode->i_fsnotify_marks)))\r\nreturn;\r\ncontext = current->audit_context;\r\np = context->trees;\r\ncount = context->tree_count;\r\nrcu_read_lock();\r\nchunk = audit_tree_lookup(inode);\r\nrcu_read_unlock();\r\nif (!chunk)\r\nreturn;\r\nif (likely(put_tree_ref(context, chunk)))\r\nreturn;\r\nif (unlikely(!grow_tree_refs(context))) {\r\nprintk(KERN_WARNING "out of memory, audit has lost a tree reference\n");\r\naudit_set_auditable(context);\r\naudit_put_chunk(chunk);\r\nunroll_tree_refs(context, p, count);\r\nreturn;\r\n}\r\nput_tree_ref(context, chunk);\r\n#endif\r\n}\r\nstatic void handle_path(const struct dentry *dentry)\r\n{\r\n#ifdef CONFIG_AUDIT_TREE\r\nstruct audit_context *context;\r\nstruct audit_tree_refs *p;\r\nconst struct dentry *d, *parent;\r\nstruct audit_chunk *drop;\r\nunsigned long seq;\r\nint count;\r\ncontext = current->audit_context;\r\np = context->trees;\r\ncount = context->tree_count;\r\nretry:\r\ndrop = NULL;\r\nd = dentry;\r\nrcu_read_lock();\r\nseq = read_seqbegin(&rename_lock);\r\nfor(;;) {\r\nstruct inode *inode = d->d_inode;\r\nif (inode && unlikely(!hlist_empty(&inode->i_fsnotify_marks))) {\r\nstruct audit_chunk *chunk;\r\nchunk = audit_tree_lookup(inode);\r\nif (chunk) {\r\nif (unlikely(!put_tree_ref(context, chunk))) {\r\ndrop = chunk;\r\nbreak;\r\n}\r\n}\r\n}\r\nparent = d->d_parent;\r\nif (parent == d)\r\nbreak;\r\nd = parent;\r\n}\r\nif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {\r\nrcu_read_unlock();\r\nif (!drop) {\r\nunroll_tree_refs(context, p, count);\r\ngoto retry;\r\n}\r\naudit_put_chunk(drop);\r\nif (grow_tree_refs(context)) {\r\nunroll_tree_refs(context, p, count);\r\ngoto retry;\r\n}\r\nprintk(KERN_WARNING\r\n"out of memory, audit has lost a tree reference\n");\r\nunroll_tree_refs(context, p, count);\r\naudit_set_auditable(context);\r\nreturn;\r\n}\r\nrcu_read_unlock();\r\n#endif\r\n}\r\nstatic struct audit_names *audit_alloc_name(struct audit_context *context)\r\n{\r\nstruct audit_names *aname;\r\nif (context->name_count < AUDIT_NAMES) {\r\naname = &context->preallocated_names[context->name_count];\r\nmemset(aname, 0, sizeof(*aname));\r\n} else {\r\naname = kzalloc(sizeof(*aname), GFP_NOFS);\r\nif (!aname)\r\nreturn NULL;\r\naname->should_free = true;\r\n}\r\naname->ino = (unsigned long)-1;\r\nlist_add_tail(&aname->list, &context->names_list);\r\ncontext->name_count++;\r\n#if AUDIT_DEBUG\r\ncontext->ino_count++;\r\n#endif\r\nreturn aname;\r\n}\r\nvoid __audit_getname(const char *name)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\nstruct audit_names *n;\r\nif (!context->in_syscall) {\r\n#if AUDIT_DEBUG == 2\r\nprintk(KERN_ERR "%s:%d(:%d): ignoring getname(%p)\n",\r\n__FILE__, __LINE__, context->serial, name);\r\ndump_stack();\r\n#endif\r\nreturn;\r\n}\r\nn = audit_alloc_name(context);\r\nif (!n)\r\nreturn;\r\nn->name = name;\r\nn->name_len = AUDIT_NAME_FULL;\r\nn->name_put = true;\r\nif (!context->pwd.dentry)\r\nget_fs_pwd(current->fs, &context->pwd);\r\n}\r\nvoid audit_putname(const char *name)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\nBUG_ON(!context);\r\nif (!context->in_syscall) {\r\n#if AUDIT_DEBUG == 2\r\nprintk(KERN_ERR "%s:%d(:%d): __putname(%p)\n",\r\n__FILE__, __LINE__, context->serial, name);\r\nif (context->name_count) {\r\nstruct audit_names *n;\r\nint i;\r\nlist_for_each_entry(n, &context->names_list, list)\r\nprintk(KERN_ERR "name[%d] = %p = %s\n", i,\r\nn->name, n->name ?: "(null)");\r\n}\r\n#endif\r\n__putname(name);\r\n}\r\n#if AUDIT_DEBUG\r\nelse {\r\n++context->put_count;\r\nif (context->put_count > context->name_count) {\r\nprintk(KERN_ERR "%s:%d(:%d): major=%d"\r\n" in_syscall=%d putname(%p) name_count=%d"\r\n" put_count=%d\n",\r\n__FILE__, __LINE__,\r\ncontext->serial, context->major,\r\ncontext->in_syscall, name, context->name_count,\r\ncontext->put_count);\r\ndump_stack();\r\n}\r\n}\r\n#endif\r\n}\r\nstatic inline int audit_copy_fcaps(struct audit_names *name, const struct dentry *dentry)\r\n{\r\nstruct cpu_vfs_cap_data caps;\r\nint rc;\r\nif (!dentry)\r\nreturn 0;\r\nrc = get_vfs_caps_from_disk(dentry, &caps);\r\nif (rc)\r\nreturn rc;\r\nname->fcap.permitted = caps.permitted;\r\nname->fcap.inheritable = caps.inheritable;\r\nname->fcap.fE = !!(caps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\r\nname->fcap_ver = (caps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\r\nreturn 0;\r\n}\r\nstatic void audit_copy_inode(struct audit_names *name, const struct dentry *dentry,\r\nconst struct inode *inode)\r\n{\r\nname->ino = inode->i_ino;\r\nname->dev = inode->i_sb->s_dev;\r\nname->mode = inode->i_mode;\r\nname->uid = inode->i_uid;\r\nname->gid = inode->i_gid;\r\nname->rdev = inode->i_rdev;\r\nsecurity_inode_getsecid(inode, &name->osid);\r\naudit_copy_fcaps(name, dentry);\r\n}\r\nvoid __audit_inode(const char *name, const struct dentry *dentry)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\nconst struct inode *inode = dentry->d_inode;\r\nstruct audit_names *n;\r\nif (!context->in_syscall)\r\nreturn;\r\nlist_for_each_entry_reverse(n, &context->names_list, list) {\r\nif (n->name && (n->name == name))\r\ngoto out;\r\n}\r\nn = audit_alloc_name(context);\r\nif (!n)\r\nreturn;\r\nout:\r\nhandle_path(dentry);\r\naudit_copy_inode(n, dentry, inode);\r\n}\r\nvoid __audit_inode_child(const struct dentry *dentry,\r\nconst struct inode *parent)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\nconst char *found_parent = NULL, *found_child = NULL;\r\nconst struct inode *inode = dentry->d_inode;\r\nconst char *dname = dentry->d_name.name;\r\nstruct audit_names *n;\r\nint dirlen = 0;\r\nif (!context->in_syscall)\r\nreturn;\r\nif (inode)\r\nhandle_one(inode);\r\nlist_for_each_entry(n, &context->names_list, list) {\r\nif (!n->name)\r\ncontinue;\r\nif (n->ino == parent->i_ino &&\r\n!audit_compare_dname_path(dname, n->name, &dirlen)) {\r\nn->name_len = dirlen;\r\nfound_parent = n->name;\r\ngoto add_names;\r\n}\r\n}\r\nlist_for_each_entry(n, &context->names_list, list) {\r\nif (!n->name)\r\ncontinue;\r\nif (!strcmp(dname, n->name) ||\r\n!audit_compare_dname_path(dname, n->name, &dirlen)) {\r\nif (inode)\r\naudit_copy_inode(n, NULL, inode);\r\nelse\r\nn->ino = (unsigned long)-1;\r\nfound_child = n->name;\r\ngoto add_names;\r\n}\r\n}\r\nadd_names:\r\nif (!found_parent) {\r\nn = audit_alloc_name(context);\r\nif (!n)\r\nreturn;\r\naudit_copy_inode(n, NULL, parent);\r\n}\r\nif (!found_child) {\r\nn = audit_alloc_name(context);\r\nif (!n)\r\nreturn;\r\nif (found_parent) {\r\nn->name = found_parent;\r\nn->name_len = AUDIT_NAME_FULL;\r\nn->name_put = false;\r\n}\r\nif (inode)\r\naudit_copy_inode(n, NULL, inode);\r\n}\r\n}\r\nint auditsc_get_stamp(struct audit_context *ctx,\r\nstruct timespec *t, unsigned int *serial)\r\n{\r\nif (!ctx->in_syscall)\r\nreturn 0;\r\nif (!ctx->serial)\r\nctx->serial = audit_serial();\r\nt->tv_sec = ctx->ctime.tv_sec;\r\nt->tv_nsec = ctx->ctime.tv_nsec;\r\n*serial = ctx->serial;\r\nif (!ctx->prio) {\r\nctx->prio = 1;\r\nctx->current_state = AUDIT_RECORD_CONTEXT;\r\n}\r\nreturn 1;\r\n}\r\nint audit_set_loginuid(uid_t loginuid)\r\n{\r\nstruct task_struct *task = current;\r\nstruct audit_context *context = task->audit_context;\r\nunsigned int sessionid;\r\n#ifdef CONFIG_AUDIT_LOGINUID_IMMUTABLE\r\nif (task->loginuid != -1)\r\nreturn -EPERM;\r\n#else\r\nif (!capable(CAP_AUDIT_CONTROL))\r\nreturn -EPERM;\r\n#endif\r\nsessionid = atomic_inc_return(&session_id);\r\nif (context && context->in_syscall) {\r\nstruct audit_buffer *ab;\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\r\nif (ab) {\r\naudit_log_format(ab, "login pid=%d uid=%u "\r\n"old auid=%u new auid=%u"\r\n" old ses=%u new ses=%u",\r\ntask->pid, task_uid(task),\r\ntask->loginuid, loginuid,\r\ntask->sessionid, sessionid);\r\naudit_log_end(ab);\r\n}\r\n}\r\ntask->sessionid = sessionid;\r\ntask->loginuid = loginuid;\r\nreturn 0;\r\n}\r\nvoid __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\nif (attr)\r\nmemcpy(&context->mq_open.attr, attr, sizeof(struct mq_attr));\r\nelse\r\nmemset(&context->mq_open.attr, 0, sizeof(struct mq_attr));\r\ncontext->mq_open.oflag = oflag;\r\ncontext->mq_open.mode = mode;\r\ncontext->type = AUDIT_MQ_OPEN;\r\n}\r\nvoid __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,\r\nconst struct timespec *abs_timeout)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\nstruct timespec *p = &context->mq_sendrecv.abs_timeout;\r\nif (abs_timeout)\r\nmemcpy(p, abs_timeout, sizeof(struct timespec));\r\nelse\r\nmemset(p, 0, sizeof(struct timespec));\r\ncontext->mq_sendrecv.mqdes = mqdes;\r\ncontext->mq_sendrecv.msg_len = msg_len;\r\ncontext->mq_sendrecv.msg_prio = msg_prio;\r\ncontext->type = AUDIT_MQ_SENDRECV;\r\n}\r\nvoid __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\nif (notification)\r\ncontext->mq_notify.sigev_signo = notification->sigev_signo;\r\nelse\r\ncontext->mq_notify.sigev_signo = 0;\r\ncontext->mq_notify.mqdes = mqdes;\r\ncontext->type = AUDIT_MQ_NOTIFY;\r\n}\r\nvoid __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\ncontext->mq_getsetattr.mqdes = mqdes;\r\ncontext->mq_getsetattr.mqstat = *mqstat;\r\ncontext->type = AUDIT_MQ_GETSETATTR;\r\n}\r\nvoid __audit_ipc_obj(struct kern_ipc_perm *ipcp)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\ncontext->ipc.uid = ipcp->uid;\r\ncontext->ipc.gid = ipcp->gid;\r\ncontext->ipc.mode = ipcp->mode;\r\ncontext->ipc.has_perm = 0;\r\nsecurity_ipc_getsecid(ipcp, &context->ipc.osid);\r\ncontext->type = AUDIT_IPC;\r\n}\r\nvoid __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\ncontext->ipc.qbytes = qbytes;\r\ncontext->ipc.perm_uid = uid;\r\ncontext->ipc.perm_gid = gid;\r\ncontext->ipc.perm_mode = mode;\r\ncontext->ipc.has_perm = 1;\r\n}\r\nint __audit_bprm(struct linux_binprm *bprm)\r\n{\r\nstruct audit_aux_data_execve *ax;\r\nstruct audit_context *context = current->audit_context;\r\nax = kmalloc(sizeof(*ax), GFP_KERNEL);\r\nif (!ax)\r\nreturn -ENOMEM;\r\nax->argc = bprm->argc;\r\nax->envc = bprm->envc;\r\nax->mm = bprm->mm;\r\nax->d.type = AUDIT_EXECVE;\r\nax->d.next = context->aux;\r\ncontext->aux = (void *)ax;\r\nreturn 0;\r\n}\r\nvoid __audit_socketcall(int nargs, unsigned long *args)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\ncontext->type = AUDIT_SOCKETCALL;\r\ncontext->socketcall.nargs = nargs;\r\nmemcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));\r\n}\r\nvoid __audit_fd_pair(int fd1, int fd2)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\ncontext->fds[0] = fd1;\r\ncontext->fds[1] = fd2;\r\n}\r\nint __audit_sockaddr(int len, void *a)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\nif (!context->sockaddr) {\r\nvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\ncontext->sockaddr = p;\r\n}\r\ncontext->sockaddr_len = len;\r\nmemcpy(context->sockaddr, a, len);\r\nreturn 0;\r\n}\r\nvoid __audit_ptrace(struct task_struct *t)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\ncontext->target_pid = t->pid;\r\ncontext->target_auid = audit_get_loginuid(t);\r\ncontext->target_uid = task_uid(t);\r\ncontext->target_sessionid = audit_get_sessionid(t);\r\nsecurity_task_getsecid(t, &context->target_sid);\r\nmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\r\n}\r\nint __audit_signal_info(int sig, struct task_struct *t)\r\n{\r\nstruct audit_aux_data_pids *axp;\r\nstruct task_struct *tsk = current;\r\nstruct audit_context *ctx = tsk->audit_context;\r\nuid_t uid = current_uid(), t_uid = task_uid(t);\r\nif (audit_pid && t->tgid == audit_pid) {\r\nif (sig == SIGTERM || sig == SIGHUP || sig == SIGUSR1 || sig == SIGUSR2) {\r\naudit_sig_pid = tsk->pid;\r\nif (tsk->loginuid != -1)\r\naudit_sig_uid = tsk->loginuid;\r\nelse\r\naudit_sig_uid = uid;\r\nsecurity_task_getsecid(tsk, &audit_sig_sid);\r\n}\r\nif (!audit_signals || audit_dummy_context())\r\nreturn 0;\r\n}\r\nif (!ctx->target_pid) {\r\nctx->target_pid = t->tgid;\r\nctx->target_auid = audit_get_loginuid(t);\r\nctx->target_uid = t_uid;\r\nctx->target_sessionid = audit_get_sessionid(t);\r\nsecurity_task_getsecid(t, &ctx->target_sid);\r\nmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\r\nreturn 0;\r\n}\r\naxp = (void *)ctx->aux_pids;\r\nif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\r\naxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\r\nif (!axp)\r\nreturn -ENOMEM;\r\naxp->d.type = AUDIT_OBJ_PID;\r\naxp->d.next = ctx->aux_pids;\r\nctx->aux_pids = (void *)axp;\r\n}\r\nBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\r\naxp->target_pid[axp->pid_count] = t->tgid;\r\naxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\r\naxp->target_uid[axp->pid_count] = t_uid;\r\naxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\r\nsecurity_task_getsecid(t, &axp->target_sid[axp->pid_count]);\r\nmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\r\naxp->pid_count++;\r\nreturn 0;\r\n}\r\nint __audit_log_bprm_fcaps(struct linux_binprm *bprm,\r\nconst struct cred *new, const struct cred *old)\r\n{\r\nstruct audit_aux_data_bprm_fcaps *ax;\r\nstruct audit_context *context = current->audit_context;\r\nstruct cpu_vfs_cap_data vcaps;\r\nstruct dentry *dentry;\r\nax = kmalloc(sizeof(*ax), GFP_KERNEL);\r\nif (!ax)\r\nreturn -ENOMEM;\r\nax->d.type = AUDIT_BPRM_FCAPS;\r\nax->d.next = context->aux;\r\ncontext->aux = (void *)ax;\r\ndentry = dget(bprm->file->f_dentry);\r\nget_vfs_caps_from_disk(dentry, &vcaps);\r\ndput(dentry);\r\nax->fcap.permitted = vcaps.permitted;\r\nax->fcap.inheritable = vcaps.inheritable;\r\nax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\r\nax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\r\nax->old_pcap.permitted = old->cap_permitted;\r\nax->old_pcap.inheritable = old->cap_inheritable;\r\nax->old_pcap.effective = old->cap_effective;\r\nax->new_pcap.permitted = new->cap_permitted;\r\nax->new_pcap.inheritable = new->cap_inheritable;\r\nax->new_pcap.effective = new->cap_effective;\r\nreturn 0;\r\n}\r\nvoid __audit_log_capset(pid_t pid,\r\nconst struct cred *new, const struct cred *old)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\ncontext->capset.pid = pid;\r\ncontext->capset.cap.effective = new->cap_effective;\r\ncontext->capset.cap.inheritable = new->cap_effective;\r\ncontext->capset.cap.permitted = new->cap_permitted;\r\ncontext->type = AUDIT_CAPSET;\r\n}\r\nvoid __audit_mmap_fd(int fd, int flags)\r\n{\r\nstruct audit_context *context = current->audit_context;\r\ncontext->mmap.fd = fd;\r\ncontext->mmap.flags = flags;\r\ncontext->type = AUDIT_MMAP;\r\n}\r\nstatic void audit_log_abend(struct audit_buffer *ab, char *reason, long signr)\r\n{\r\nuid_t auid, uid;\r\ngid_t gid;\r\nunsigned int sessionid;\r\nauid = audit_get_loginuid(current);\r\nsessionid = audit_get_sessionid(current);\r\ncurrent_uid_gid(&uid, &gid);\r\naudit_log_format(ab, "auid=%u uid=%u gid=%u ses=%u",\r\nauid, uid, gid, sessionid);\r\naudit_log_task_context(ab);\r\naudit_log_format(ab, " pid=%d comm=", current->pid);\r\naudit_log_untrustedstring(ab, current->comm);\r\naudit_log_format(ab, " reason=");\r\naudit_log_string(ab, reason);\r\naudit_log_format(ab, " sig=%ld", signr);\r\n}\r\nvoid audit_core_dumps(long signr)\r\n{\r\nstruct audit_buffer *ab;\r\nif (!audit_enabled)\r\nreturn;\r\nif (signr == SIGQUIT)\r\nreturn;\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_ANOM_ABEND);\r\naudit_log_abend(ab, "memory violation", signr);\r\naudit_log_end(ab);\r\n}\r\nvoid __audit_seccomp(unsigned long syscall, long signr, int code)\r\n{\r\nstruct audit_buffer *ab;\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_ANOM_ABEND);\r\naudit_log_abend(ab, "seccomp", signr);\r\naudit_log_format(ab, " syscall=%ld", syscall);\r\naudit_log_format(ab, " compat=%d", is_compat_task());\r\naudit_log_format(ab, " ip=0x%lx", KSTK_EIP(current));\r\naudit_log_format(ab, " code=0x%x", code);\r\naudit_log_end(ab);\r\n}\r\nstruct list_head *audit_killed_trees(void)\r\n{\r\nstruct audit_context *ctx = current->audit_context;\r\nif (likely(!ctx || !ctx->in_syscall))\r\nreturn NULL;\r\nreturn &ctx->killed_trees;\r\n}
