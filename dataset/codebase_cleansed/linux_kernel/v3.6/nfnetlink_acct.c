static int\r\nnfnl_acct_new(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nstruct nf_acct *nfacct, *matching = NULL;\r\nchar *acct_name;\r\nif (!tb[NFACCT_NAME])\r\nreturn -EINVAL;\r\nacct_name = nla_data(tb[NFACCT_NAME]);\r\nlist_for_each_entry(nfacct, &nfnl_acct_list, head) {\r\nif (strncmp(nfacct->name, acct_name, NFACCT_NAME_MAX) != 0)\r\ncontinue;\r\nif (nlh->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nmatching = nfacct;\r\nbreak;\r\n}\r\nif (matching) {\r\nif (nlh->nlmsg_flags & NLM_F_REPLACE) {\r\natomic64_set(&matching->pkts, 0);\r\natomic64_set(&matching->bytes, 0);\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nnfacct = kzalloc(sizeof(struct nf_acct), GFP_KERNEL);\r\nif (nfacct == NULL)\r\nreturn -ENOMEM;\r\nstrncpy(nfacct->name, nla_data(tb[NFACCT_NAME]), NFACCT_NAME_MAX);\r\nif (tb[NFACCT_BYTES]) {\r\natomic64_set(&nfacct->bytes,\r\nbe64_to_cpu(nla_get_u64(tb[NFACCT_BYTES])));\r\n}\r\nif (tb[NFACCT_PKTS]) {\r\natomic64_set(&nfacct->pkts,\r\nbe64_to_cpu(nla_get_u64(tb[NFACCT_PKTS])));\r\n}\r\natomic_set(&nfacct->refcnt, 1);\r\nlist_add_tail_rcu(&nfacct->head, &nfnl_acct_list);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfnl_acct_fill_info(struct sk_buff *skb, u32 pid, u32 seq, u32 type,\r\nint event, struct nf_acct *acct)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nunsigned int flags = pid ? NLM_F_MULTI : 0;\r\nu64 pkts, bytes;\r\nevent |= NFNL_SUBSYS_ACCT << 8;\r\nnlh = nlmsg_put(skb, pid, seq, event, sizeof(*nfmsg), flags);\r\nif (nlh == NULL)\r\ngoto nlmsg_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = AF_UNSPEC;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (nla_put_string(skb, NFACCT_NAME, acct->name))\r\ngoto nla_put_failure;\r\nif (type == NFNL_MSG_ACCT_GET_CTRZERO) {\r\npkts = atomic64_xchg(&acct->pkts, 0);\r\nbytes = atomic64_xchg(&acct->bytes, 0);\r\n} else {\r\npkts = atomic64_read(&acct->pkts);\r\nbytes = atomic64_read(&acct->bytes);\r\n}\r\nif (nla_put_be64(skb, NFACCT_PKTS, cpu_to_be64(pkts)) ||\r\nnla_put_be64(skb, NFACCT_BYTES, cpu_to_be64(bytes)) ||\r\nnla_put_be32(skb, NFACCT_USE, htonl(atomic_read(&acct->refcnt))))\r\ngoto nla_put_failure;\r\nnlmsg_end(skb, nlh);\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -1;\r\n}\r\nstatic int\r\nnfnl_acct_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct nf_acct *cur, *last;\r\nif (cb->args[2])\r\nreturn 0;\r\nlast = (struct nf_acct *)cb->args[1];\r\nif (cb->args[1])\r\ncb->args[1] = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(cur, &nfnl_acct_list, head) {\r\nif (last && cur != last)\r\ncontinue;\r\nif (nfnl_acct_fill_info(skb, NETLINK_CB(cb->skb).pid,\r\ncb->nlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(cb->nlh->nlmsg_type),\r\nNFNL_MSG_ACCT_NEW, cur) < 0) {\r\ncb->args[1] = (unsigned long)cur;\r\nbreak;\r\n}\r\n}\r\nif (!cb->args[1])\r\ncb->args[2] = 1;\r\nrcu_read_unlock();\r\nreturn skb->len;\r\n}\r\nstatic int\r\nnfnl_acct_get(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nint ret = -ENOENT;\r\nstruct nf_acct *cur;\r\nchar *acct_name;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nstruct netlink_dump_control c = {\r\n.dump = nfnl_acct_dump,\r\n};\r\nreturn netlink_dump_start(nfnl, skb, nlh, &c);\r\n}\r\nif (!tb[NFACCT_NAME])\r\nreturn -EINVAL;\r\nacct_name = nla_data(tb[NFACCT_NAME]);\r\nlist_for_each_entry(cur, &nfnl_acct_list, head) {\r\nstruct sk_buff *skb2;\r\nif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX)!= 0)\r\ncontinue;\r\nskb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (skb2 == NULL) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = nfnl_acct_fill_info(skb2, NETLINK_CB(skb).pid,\r\nnlh->nlmsg_seq,\r\nNFNL_MSG_TYPE(nlh->nlmsg_type),\r\nNFNL_MSG_ACCT_NEW, cur);\r\nif (ret <= 0) {\r\nkfree_skb(skb2);\r\nbreak;\r\n}\r\nret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).pid,\r\nMSG_DONTWAIT);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret == -EAGAIN ? -ENOBUFS : ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int nfnl_acct_try_del(struct nf_acct *cur)\r\n{\r\nint ret = 0;\r\nif (atomic_dec_and_test(&cur->refcnt)) {\r\nlist_del_rcu(&cur->head);\r\nkfree_rcu(cur, rcu_head);\r\n} else {\r\natomic_inc(&cur->refcnt);\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnfnl_acct_del(struct sock *nfnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh, const struct nlattr * const tb[])\r\n{\r\nchar *acct_name;\r\nstruct nf_acct *cur;\r\nint ret = -ENOENT;\r\nif (!tb[NFACCT_NAME]) {\r\nlist_for_each_entry(cur, &nfnl_acct_list, head)\r\nnfnl_acct_try_del(cur);\r\nreturn 0;\r\n}\r\nacct_name = nla_data(tb[NFACCT_NAME]);\r\nlist_for_each_entry(cur, &nfnl_acct_list, head) {\r\nif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX) != 0)\r\ncontinue;\r\nret = nfnl_acct_try_del(cur);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstruct nf_acct *nfnl_acct_find_get(const char *acct_name)\r\n{\r\nstruct nf_acct *cur, *acct = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(cur, &nfnl_acct_list, head) {\r\nif (strncmp(cur->name, acct_name, NFACCT_NAME_MAX)!= 0)\r\ncontinue;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto err;\r\nif (!atomic_inc_not_zero(&cur->refcnt)) {\r\nmodule_put(THIS_MODULE);\r\ngoto err;\r\n}\r\nacct = cur;\r\nbreak;\r\n}\r\nerr:\r\nrcu_read_unlock();\r\nreturn acct;\r\n}\r\nvoid nfnl_acct_put(struct nf_acct *acct)\r\n{\r\natomic_dec(&acct->refcnt);\r\nmodule_put(THIS_MODULE);\r\n}\r\nvoid nfnl_acct_update(const struct sk_buff *skb, struct nf_acct *nfacct)\r\n{\r\natomic64_inc(&nfacct->pkts);\r\natomic64_add(skb->len, &nfacct->bytes);\r\n}\r\nstatic int __init nfnl_acct_init(void)\r\n{\r\nint ret;\r\npr_info("nfnl_acct: registering with nfnetlink.\n");\r\nret = nfnetlink_subsys_register(&nfnl_acct_subsys);\r\nif (ret < 0) {\r\npr_err("nfnl_acct_init: cannot register with nfnetlink.\n");\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void __exit nfnl_acct_exit(void)\r\n{\r\nstruct nf_acct *cur, *tmp;\r\npr_info("nfnl_acct: unregistering from nfnetlink.\n");\r\nnfnetlink_subsys_unregister(&nfnl_acct_subsys);\r\nlist_for_each_entry_safe(cur, tmp, &nfnl_acct_list, head) {\r\nlist_del_rcu(&cur->head);\r\nkfree_rcu(cur, rcu_head);\r\n}\r\n}
