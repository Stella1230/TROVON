static void\r\nsclp_vt220_process_queue(struct sclp_vt220_request *request)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nvoid *page;\r\ndo {\r\npage = request->sclp_req.sccb;\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\nlist_del(&request->list);\r\nlist_add_tail((struct list_head *) page, &sclp_vt220_empty);\r\nrequest = NULL;\r\nif (!list_empty(&sclp_vt220_outqueue))\r\nrequest = list_entry(sclp_vt220_outqueue.next,\r\nstruct sclp_vt220_request, list);\r\nif (!request || sclp_vt220_suspended) {\r\nsclp_vt220_queue_running = 0;\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\n} while (__sclp_vt220_emit(request));\r\nif (request == NULL && sclp_vt220_flush_later)\r\nsclp_vt220_emit_current();\r\ntty = tty_port_tty_get(&sclp_vt220_port);\r\nif (tty) {\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic void\r\nsclp_vt220_callback(struct sclp_req *request, void *data)\r\n{\r\nstruct sclp_vt220_request *vt220_request;\r\nstruct sclp_vt220_sccb *sccb;\r\nvt220_request = (struct sclp_vt220_request *) data;\r\nif (request->status == SCLP_REQ_FAILED) {\r\nsclp_vt220_process_queue(vt220_request);\r\nreturn;\r\n}\r\nsccb = (struct sclp_vt220_sccb *) vt220_request->sclp_req.sccb;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020 :\r\nbreak;\r\ncase 0x05f0:\r\nbreak;\r\ncase 0x0340:\r\nif (++vt220_request->retry_count > SCLP_BUFFER_MAX_RETRY)\r\nbreak;\r\nif (sclp_remove_processed((struct sccb_header *) sccb) > 0) {\r\nsccb->header.response_code = 0x0000;\r\nvt220_request->sclp_req.status = SCLP_REQ_FILLED;\r\nif (sclp_add_request(request) == 0)\r\nreturn;\r\n}\r\nbreak;\r\ncase 0x0040:\r\nif (++vt220_request->retry_count > SCLP_BUFFER_MAX_RETRY)\r\nbreak;\r\nsccb->header.response_code = 0x0000;\r\nvt220_request->sclp_req.status = SCLP_REQ_FILLED;\r\nif (sclp_add_request(request) == 0)\r\nreturn;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsclp_vt220_process_queue(vt220_request);\r\n}\r\nstatic int\r\n__sclp_vt220_emit(struct sclp_vt220_request *request)\r\n{\r\nif (!(sclp_vt220_register.sclp_receive_mask & EVTYP_VT220MSG_MASK)) {\r\nrequest->sclp_req.status = SCLP_REQ_FAILED;\r\nreturn -EIO;\r\n}\r\nrequest->sclp_req.command = SCLP_CMDW_WRITE_EVENT_DATA;\r\nrequest->sclp_req.status = SCLP_REQ_FILLED;\r\nrequest->sclp_req.callback = sclp_vt220_callback;\r\nrequest->sclp_req.callback_data = (void *) request;\r\nreturn sclp_add_request(&request->sclp_req);\r\n}\r\nstatic void\r\nsclp_vt220_emit_current(void)\r\n{\r\nunsigned long flags;\r\nstruct sclp_vt220_request *request;\r\nstruct sclp_vt220_sccb *sccb;\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\nif (sclp_vt220_current_request) {\r\nsccb = (struct sclp_vt220_sccb *)\r\nsclp_vt220_current_request->sclp_req.sccb;\r\nif (sccb->header.length != sizeof(struct sclp_vt220_sccb)) {\r\nlist_add_tail(&sclp_vt220_current_request->list,\r\n&sclp_vt220_outqueue);\r\nsclp_vt220_current_request = NULL;\r\nif (timer_pending(&sclp_vt220_timer))\r\ndel_timer(&sclp_vt220_timer);\r\n}\r\nsclp_vt220_flush_later = 0;\r\n}\r\nif (sclp_vt220_queue_running || sclp_vt220_suspended)\r\ngoto out_unlock;\r\nif (list_empty(&sclp_vt220_outqueue))\r\ngoto out_unlock;\r\nrequest = list_first_entry(&sclp_vt220_outqueue,\r\nstruct sclp_vt220_request, list);\r\nsclp_vt220_queue_running = 1;\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nif (__sclp_vt220_emit(request))\r\nsclp_vt220_process_queue(request);\r\nreturn;\r\nout_unlock:\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\n}\r\nstatic struct sclp_vt220_request *\r\nsclp_vt220_initialize_page(void *page)\r\n{\r\nstruct sclp_vt220_request *request;\r\nstruct sclp_vt220_sccb *sccb;\r\nrequest = ((struct sclp_vt220_request *)\r\n((addr_t) page + PAGE_SIZE)) - 1;\r\nrequest->retry_count = 0;\r\nrequest->sclp_req.sccb = page;\r\nsccb = (struct sclp_vt220_sccb *) page;\r\nmemset((void *) sccb, 0, sizeof(struct sclp_vt220_sccb));\r\nsccb->header.length = sizeof(struct sclp_vt220_sccb);\r\nsccb->header.function_code = SCLP_NORMAL_WRITE;\r\nsccb->header.response_code = 0x0000;\r\nsccb->evbuf.type = EVTYP_VT220MSG;\r\nsccb->evbuf.length = sizeof(struct evbuf_header);\r\nreturn request;\r\n}\r\nstatic inline unsigned int\r\nsclp_vt220_space_left(struct sclp_vt220_request *request)\r\n{\r\nstruct sclp_vt220_sccb *sccb;\r\nsccb = (struct sclp_vt220_sccb *) request->sclp_req.sccb;\r\nreturn PAGE_SIZE - sizeof(struct sclp_vt220_request) -\r\nsccb->header.length;\r\n}\r\nstatic inline unsigned int\r\nsclp_vt220_chars_stored(struct sclp_vt220_request *request)\r\n{\r\nstruct sclp_vt220_sccb *sccb;\r\nsccb = (struct sclp_vt220_sccb *) request->sclp_req.sccb;\r\nreturn sccb->evbuf.length - sizeof(struct evbuf_header);\r\n}\r\nstatic int\r\nsclp_vt220_add_msg(struct sclp_vt220_request *request,\r\nconst unsigned char *msg, int count, int convertlf)\r\n{\r\nstruct sclp_vt220_sccb *sccb;\r\nvoid *buffer;\r\nunsigned char c;\r\nint from;\r\nint to;\r\nif (count > sclp_vt220_space_left(request))\r\ncount = sclp_vt220_space_left(request);\r\nif (count <= 0)\r\nreturn 0;\r\nsccb = (struct sclp_vt220_sccb *) request->sclp_req.sccb;\r\nbuffer = (void *) ((addr_t) sccb + sccb->header.length);\r\nif (convertlf) {\r\nfor (from=0, to=0;\r\n(from < count) && (to < sclp_vt220_space_left(request));\r\nfrom++) {\r\nc = msg[from];\r\nif (c == 0x0a) {\r\nif (to + 1 < sclp_vt220_space_left(request)) {\r\n((unsigned char *) buffer)[to++] = c;\r\n((unsigned char *) buffer)[to++] = 0x0d;\r\n} else\r\nbreak;\r\n} else\r\n((unsigned char *) buffer)[to++] = c;\r\n}\r\nsccb->header.length += to;\r\nsccb->evbuf.length += to;\r\nreturn from;\r\n} else {\r\nmemcpy(buffer, (const void *) msg, count);\r\nsccb->header.length += count;\r\nsccb->evbuf.length += count;\r\nreturn count;\r\n}\r\n}\r\nstatic void\r\nsclp_vt220_timeout(unsigned long data)\r\n{\r\nsclp_vt220_emit_current();\r\n}\r\nstatic int\r\n__sclp_vt220_write(const unsigned char *buf, int count, int do_schedule,\r\nint convertlf, int may_fail)\r\n{\r\nunsigned long flags;\r\nvoid *page;\r\nint written;\r\nint overall_written;\r\nif (count <= 0)\r\nreturn 0;\r\noverall_written = 0;\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\ndo {\r\nif (sclp_vt220_current_request == NULL) {\r\nwhile (list_empty(&sclp_vt220_empty)) {\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nif (may_fail || sclp_vt220_suspended)\r\ngoto out;\r\nelse\r\nsclp_sync_wait();\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\n}\r\npage = (void *) sclp_vt220_empty.next;\r\nlist_del((struct list_head *) page);\r\nsclp_vt220_current_request =\r\nsclp_vt220_initialize_page(page);\r\n}\r\nwritten = sclp_vt220_add_msg(sclp_vt220_current_request,\r\nbuf, count, convertlf);\r\noverall_written += written;\r\nif (written == count)\r\nbreak;\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nsclp_vt220_emit_current();\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\nbuf += written;\r\ncount -= written;\r\n} while (count > 0);\r\nif (sclp_vt220_current_request != NULL &&\r\n!timer_pending(&sclp_vt220_timer) && do_schedule) {\r\nsclp_vt220_timer.function = sclp_vt220_timeout;\r\nsclp_vt220_timer.data = 0UL;\r\nsclp_vt220_timer.expires = jiffies + BUFFER_MAX_DELAY;\r\nadd_timer(&sclp_vt220_timer);\r\n}\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nout:\r\nreturn overall_written;\r\n}\r\nstatic int\r\nsclp_vt220_write(struct tty_struct *tty, const unsigned char *buf, int count)\r\n{\r\nreturn __sclp_vt220_write(buf, count, 1, 0, 1);\r\n}\r\nstatic void\r\nsclp_vt220_receiver_fn(struct evbuf_header *evbuf)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&sclp_vt220_port);\r\nchar *buffer;\r\nunsigned int count;\r\nif (tty == NULL)\r\nreturn;\r\nbuffer = (char *) ((addr_t) evbuf + sizeof(struct evbuf_header));\r\ncount = evbuf->length - sizeof(struct evbuf_header);\r\nswitch (*buffer) {\r\ncase SCLP_VT220_SESSION_ENDED:\r\ncase SCLP_VT220_SESSION_STARTED:\r\nbreak;\r\ncase SCLP_VT220_SESSION_DATA:\r\nbuffer++;\r\ncount--;\r\ntty_insert_flip_string(tty, buffer, count);\r\ntty_flip_buffer_push(tty);\r\nbreak;\r\n}\r\ntty_kref_put(tty);\r\n}\r\nstatic int\r\nsclp_vt220_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nif (tty->count == 1) {\r\ntty_port_tty_set(&sclp_vt220_port, tty);\r\ntty->low_latency = 0;\r\nif (!tty->winsize.ws_row && !tty->winsize.ws_col) {\r\ntty->winsize.ws_row = 24;\r\ntty->winsize.ws_col = 80;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsclp_vt220_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nif (tty->count == 1)\r\ntty_port_tty_set(&sclp_vt220_port, NULL);\r\n}\r\nstatic int\r\nsclp_vt220_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nreturn __sclp_vt220_write(&ch, 1, 0, 0, 1);\r\n}\r\nstatic void\r\nsclp_vt220_flush_chars(struct tty_struct *tty)\r\n{\r\nif (!sclp_vt220_queue_running)\r\nsclp_vt220_emit_current();\r\nelse\r\nsclp_vt220_flush_later = 1;\r\n}\r\nstatic int\r\nsclp_vt220_write_room(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct list_head *l;\r\nint count;\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\ncount = 0;\r\nif (sclp_vt220_current_request != NULL)\r\ncount = sclp_vt220_space_left(sclp_vt220_current_request);\r\nlist_for_each(l, &sclp_vt220_empty)\r\ncount += SCLP_VT220_MAX_CHARS_PER_BUFFER;\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nreturn count;\r\n}\r\nstatic int\r\nsclp_vt220_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct list_head *l;\r\nstruct sclp_vt220_request *r;\r\nint count;\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\ncount = 0;\r\nif (sclp_vt220_current_request != NULL)\r\ncount = sclp_vt220_chars_stored(sclp_vt220_current_request);\r\nlist_for_each(l, &sclp_vt220_outqueue) {\r\nr = list_entry(l, struct sclp_vt220_request, list);\r\ncount += sclp_vt220_chars_stored(r);\r\n}\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nreturn count;\r\n}\r\nstatic void\r\nsclp_vt220_flush_buffer(struct tty_struct *tty)\r\n{\r\nsclp_vt220_emit_current();\r\n}\r\nstatic void __init __sclp_vt220_free_pages(void)\r\n{\r\nstruct list_head *page, *p;\r\nlist_for_each_safe(page, p, &sclp_vt220_empty) {\r\nlist_del(page);\r\nfree_page((unsigned long) page);\r\n}\r\n}\r\nstatic void __init __sclp_vt220_cleanup(void)\r\n{\r\nsclp_vt220_init_count--;\r\nif (sclp_vt220_init_count != 0)\r\nreturn;\r\nsclp_unregister(&sclp_vt220_register);\r\n__sclp_vt220_free_pages();\r\n}\r\nstatic int __init __sclp_vt220_init(int num_pages)\r\n{\r\nvoid *page;\r\nint i;\r\nint rc;\r\nsclp_vt220_init_count++;\r\nif (sclp_vt220_init_count != 1)\r\nreturn 0;\r\nspin_lock_init(&sclp_vt220_lock);\r\nINIT_LIST_HEAD(&sclp_vt220_empty);\r\nINIT_LIST_HEAD(&sclp_vt220_outqueue);\r\ninit_timer(&sclp_vt220_timer);\r\ntty_port_init(&sclp_vt220_port);\r\nsclp_vt220_current_request = NULL;\r\nsclp_vt220_buffered_chars = 0;\r\nsclp_vt220_flush_later = 0;\r\nrc = -ENOMEM;\r\nfor (i = 0; i < num_pages; i++) {\r\npage = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!page)\r\ngoto out;\r\nlist_add_tail(page, &sclp_vt220_empty);\r\n}\r\nrc = sclp_register(&sclp_vt220_register);\r\nout:\r\nif (rc) {\r\n__sclp_vt220_free_pages();\r\nsclp_vt220_init_count--;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init sclp_vt220_tty_init(void)\r\n{\r\nstruct tty_driver *driver;\r\nint rc;\r\ndriver = alloc_tty_driver(1);\r\nif (!driver)\r\nreturn -ENOMEM;\r\nrc = __sclp_vt220_init(MAX_KMEM_PAGES);\r\nif (rc)\r\ngoto out_driver;\r\ndriver->driver_name = SCLP_VT220_DRIVER_NAME;\r\ndriver->name = SCLP_VT220_DEVICE_NAME;\r\ndriver->major = SCLP_VT220_MAJOR;\r\ndriver->minor_start = SCLP_VT220_MINOR;\r\ndriver->type = TTY_DRIVER_TYPE_SYSTEM;\r\ndriver->subtype = SYSTEM_TYPE_TTY;\r\ndriver->init_termios = tty_std_termios;\r\ndriver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(driver, &sclp_vt220_ops);\r\nrc = tty_register_driver(driver);\r\nif (rc)\r\ngoto out_init;\r\nsclp_vt220_driver = driver;\r\nreturn 0;\r\nout_init:\r\n__sclp_vt220_cleanup();\r\nout_driver:\r\nput_tty_driver(driver);\r\nreturn rc;\r\n}\r\nstatic void __sclp_vt220_flush_buffer(void)\r\n{\r\nunsigned long flags;\r\nsclp_vt220_emit_current();\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\nif (timer_pending(&sclp_vt220_timer))\r\ndel_timer(&sclp_vt220_timer);\r\nwhile (sclp_vt220_queue_running) {\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nsclp_sync_wait();\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\n}\r\nstatic void sclp_vt220_resume(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\nsclp_vt220_suspended = 0;\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\nsclp_vt220_emit_current();\r\n}\r\nstatic void sclp_vt220_suspend(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sclp_vt220_lock, flags);\r\nsclp_vt220_suspended = 1;\r\nspin_unlock_irqrestore(&sclp_vt220_lock, flags);\r\n__sclp_vt220_flush_buffer();\r\n}\r\nstatic void sclp_vt220_pm_event_fn(struct sclp_register *reg,\r\nenum sclp_pm_event sclp_pm_event)\r\n{\r\nswitch (sclp_pm_event) {\r\ncase SCLP_PM_EVENT_FREEZE:\r\nsclp_vt220_suspend();\r\nbreak;\r\ncase SCLP_PM_EVENT_RESTORE:\r\ncase SCLP_PM_EVENT_THAW:\r\nsclp_vt220_resume();\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nsclp_vt220_con_write(struct console *con, const char *buf, unsigned int count)\r\n{\r\n__sclp_vt220_write((const unsigned char *) buf, count, 1, 1, 0);\r\n}\r\nstatic struct tty_driver *\r\nsclp_vt220_con_device(struct console *c, int *index)\r\n{\r\n*index = 0;\r\nreturn sclp_vt220_driver;\r\n}\r\nstatic int\r\nsclp_vt220_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\n__sclp_vt220_flush_buffer();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init\r\nsclp_vt220_con_init(void)\r\n{\r\nint rc;\r\nif (!CONSOLE_IS_SCLP)\r\nreturn 0;\r\nrc = __sclp_vt220_init(MAX_CONSOLE_PAGES);\r\nif (rc)\r\nreturn rc;\r\natomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\r\nregister_reboot_notifier(&on_reboot_nb);\r\nregister_console(&sclp_vt220_console);\r\nreturn 0;\r\n}
