static void\r\nnv50_channel_del(struct nouveau_channel **pchan)\r\n{\r\nstruct nouveau_channel *chan;\r\nchan = *pchan;\r\n*pchan = NULL;\r\nif (!chan)\r\nreturn;\r\nnouveau_gpuobj_ref(NULL, &chan->ramfc);\r\nnouveau_vm_ref(NULL, &chan->vm, chan->vm_pd);\r\nnouveau_gpuobj_ref(NULL, &chan->vm_pd);\r\nif (drm_mm_initialized(&chan->ramin_heap))\r\ndrm_mm_takedown(&chan->ramin_heap);\r\nnouveau_gpuobj_ref(NULL, &chan->ramin);\r\nkfree(chan);\r\n}\r\nstatic int\r\nnv50_channel_new(struct drm_device *dev, u32 size, struct nouveau_vm *vm,\r\nstruct nouveau_channel **pchan)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 pgd = (dev_priv->chipset == 0x50) ? 0x1400 : 0x0200;\r\nu32 fc = (dev_priv->chipset == 0x50) ? 0x0000 : 0x4200;\r\nstruct nouveau_channel *chan;\r\nint ret, i;\r\nchan = kzalloc(sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn -ENOMEM;\r\nchan->dev = dev;\r\nret = nouveau_gpuobj_new(dev, NULL, size, 0x1000, 0, &chan->ramin);\r\nif (ret) {\r\nnv50_channel_del(&chan);\r\nreturn ret;\r\n}\r\nret = drm_mm_init(&chan->ramin_heap, 0x6000, chan->ramin->size - 0x6000);\r\nif (ret) {\r\nnv50_channel_del(&chan);\r\nreturn ret;\r\n}\r\nret = nouveau_gpuobj_new_fake(dev, chan->ramin->pinst == ~0 ? ~0 :\r\nchan->ramin->pinst + pgd,\r\nchan->ramin->vinst + pgd,\r\n0x4000, NVOBJ_FLAG_ZERO_ALLOC,\r\n&chan->vm_pd);\r\nif (ret) {\r\nnv50_channel_del(&chan);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < 0x4000; i += 8) {\r\nnv_wo32(chan->vm_pd, i + 0, 0x00000000);\r\nnv_wo32(chan->vm_pd, i + 4, 0xdeadcafe);\r\n}\r\nret = nouveau_vm_ref(vm, &chan->vm, chan->vm_pd);\r\nif (ret) {\r\nnv50_channel_del(&chan);\r\nreturn ret;\r\n}\r\nret = nouveau_gpuobj_new_fake(dev, chan->ramin->pinst == ~0 ? ~0 :\r\nchan->ramin->pinst + fc,\r\nchan->ramin->vinst + fc, 0x100,\r\nNVOBJ_FLAG_ZERO_ALLOC, &chan->ramfc);\r\nif (ret) {\r\nnv50_channel_del(&chan);\r\nreturn ret;\r\n}\r\n*pchan = chan;\r\nreturn 0;\r\n}\r\nint\r\nnv50_instmem_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_instmem_priv *priv;\r\nstruct nouveau_channel *chan;\r\nstruct nouveau_vm *vm;\r\nint ret, i;\r\nu32 tmp;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ndev_priv->engine.instmem.priv = priv;\r\nfor (i = 0x1700; i <= 0x1710; i += 4)\r\npriv->save1700[(i-0x1700)/4] = nv_rd32(dev, i);\r\nret = drm_mm_init(&dev_priv->ramin_heap, 0, dev_priv->ramin_size);\r\nif (ret) {\r\nNV_ERROR(dev, "Failed to init RAMIN heap\n");\r\ngoto error;\r\n}\r\nret = nouveau_vm_new(dev, BAR3_VM_BASE, BAR3_VM_SIZE, BAR3_VM_BASE,\r\n&dev_priv->bar3_vm);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_gpuobj_new(dev, NULL, (BAR3_VM_SIZE >> 12) * 8,\r\n0x1000, NVOBJ_FLAG_DONT_MAP |\r\nNVOBJ_FLAG_ZERO_ALLOC,\r\n&dev_priv->bar3_vm->pgt[0].obj[0]);\r\nif (ret)\r\ngoto error;\r\ndev_priv->bar3_vm->pgt[0].refcount[0] = 1;\r\nnv50_instmem_map(dev_priv->bar3_vm->pgt[0].obj[0]);\r\nret = nv50_channel_new(dev, 128 * 1024, dev_priv->bar3_vm, &chan);\r\nif (ret)\r\ngoto error;\r\ndev_priv->channels.ptr[0] = dev_priv->channels.ptr[127] = chan;\r\nret = nv50_gpuobj_dma_new(chan, 0x0000, BAR3_VM_BASE, BAR3_VM_SIZE,\r\nNV_MEM_TARGET_VM, NV_MEM_ACCESS_VM,\r\nNV_MEM_TYPE_VM, NV_MEM_COMP_VM,\r\n&priv->bar3_dmaobj);\r\nif (ret)\r\ngoto error;\r\nnv_wr32(dev, 0x001704, 0x00000000 | (chan->ramin->vinst >> 12));\r\nnv_wr32(dev, 0x001704, 0x40000000 | (chan->ramin->vinst >> 12));\r\nnv_wr32(dev, 0x00170c, 0x80000000 | (priv->bar3_dmaobj->cinst >> 4));\r\ndev_priv->engine.instmem.flush(dev);\r\ndev_priv->ramin_available = true;\r\ntmp = nv_ro32(chan->ramin, 0);\r\nnv_wo32(chan->ramin, 0, ~tmp);\r\nif (nv_ro32(chan->ramin, 0) != ~tmp) {\r\nNV_ERROR(dev, "PRAMIN readback failed\n");\r\nret = -EIO;\r\ngoto error;\r\n}\r\nnv_wo32(chan->ramin, 0, tmp);\r\nret = nouveau_vm_new(dev, BAR1_VM_BASE, BAR1_VM_SIZE, BAR1_VM_BASE, &vm);\r\nif (ret)\r\ngoto error;\r\nret = nouveau_vm_ref(vm, &dev_priv->bar1_vm, chan->vm_pd);\r\nif (ret)\r\ngoto error;\r\nnouveau_vm_ref(NULL, &vm, NULL);\r\nret = nv50_gpuobj_dma_new(chan, 0x0000, BAR1_VM_BASE, BAR1_VM_SIZE,\r\nNV_MEM_TARGET_VM, NV_MEM_ACCESS_VM,\r\nNV_MEM_TYPE_VM, NV_MEM_COMP_VM,\r\n&priv->bar1_dmaobj);\r\nif (ret)\r\ngoto error;\r\nnv_wr32(dev, 0x001708, 0x80000000 | (priv->bar1_dmaobj->cinst >> 4));\r\nfor (i = 0; i < 8; i++)\r\nnv_wr32(dev, 0x1900 + (i*4), 0);\r\nret = nouveau_vm_new(dev, 0, (1ULL << 40), 0x0020000000ULL,\r\n&dev_priv->chan_vm);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\nerror:\r\nnv50_instmem_takedown(dev);\r\nreturn ret;\r\n}\r\nvoid\r\nnv50_instmem_takedown(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_instmem_priv *priv = dev_priv->engine.instmem.priv;\r\nstruct nouveau_channel *chan = dev_priv->channels.ptr[0];\r\nint i;\r\nNV_DEBUG(dev, "\n");\r\nif (!priv)\r\nreturn;\r\ndev_priv->ramin_available = false;\r\nnouveau_vm_ref(NULL, &dev_priv->chan_vm, NULL);\r\nfor (i = 0x1700; i <= 0x1710; i += 4)\r\nnv_wr32(dev, i, priv->save1700[(i - 0x1700) / 4]);\r\nnouveau_gpuobj_ref(NULL, &priv->bar3_dmaobj);\r\nnouveau_gpuobj_ref(NULL, &priv->bar1_dmaobj);\r\nnouveau_vm_ref(NULL, &dev_priv->bar1_vm, chan->vm_pd);\r\ndev_priv->channels.ptr[127] = 0;\r\nnv50_channel_del(&dev_priv->channels.ptr[0]);\r\nnouveau_gpuobj_ref(NULL, &dev_priv->bar3_vm->pgt[0].obj[0]);\r\nnouveau_vm_ref(NULL, &dev_priv->bar3_vm, NULL);\r\nif (drm_mm_initialized(&dev_priv->ramin_heap))\r\ndrm_mm_takedown(&dev_priv->ramin_heap);\r\ndev_priv->engine.instmem.priv = NULL;\r\nkfree(priv);\r\n}\r\nint\r\nnv50_instmem_suspend(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\ndev_priv->ramin_available = false;\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_instmem_resume(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_instmem_priv *priv = dev_priv->engine.instmem.priv;\r\nstruct nouveau_channel *chan = dev_priv->channels.ptr[0];\r\nint i;\r\nnv_wr32(dev, NV50_PUNK_BAR_CFG_BASE, (chan->ramin->vinst >> 12));\r\nnv_wr32(dev, NV50_PUNK_UNK1710, 0);\r\nnv_wr32(dev, NV50_PUNK_BAR_CFG_BASE, (chan->ramin->vinst >> 12) |\r\nNV50_PUNK_BAR_CFG_BASE_VALID);\r\nnv_wr32(dev, NV50_PUNK_BAR1_CTXDMA, (priv->bar1_dmaobj->cinst >> 4) |\r\nNV50_PUNK_BAR1_CTXDMA_VALID);\r\nnv_wr32(dev, NV50_PUNK_BAR3_CTXDMA, (priv->bar3_dmaobj->cinst >> 4) |\r\nNV50_PUNK_BAR3_CTXDMA_VALID);\r\nfor (i = 0; i < 8; i++)\r\nnv_wr32(dev, 0x1900 + (i*4), 0);\r\ndev_priv->ramin_available = true;\r\n}\r\nint\r\nnv50_instmem_get(struct nouveau_gpuobj *gpuobj, struct nouveau_channel *chan,\r\nu32 size, u32 align)\r\n{\r\nstruct drm_device *dev = gpuobj->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_vram_engine *vram = &dev_priv->engine.vram;\r\nstruct nv50_gpuobj_node *node = NULL;\r\nint ret;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->align = align;\r\nsize = (size + 4095) & ~4095;\r\nalign = max(align, (u32)4096);\r\nret = vram->get(dev, size, align, 0, 0, &node->vram);\r\nif (ret) {\r\nkfree(node);\r\nreturn ret;\r\n}\r\ngpuobj->vinst = node->vram->offset;\r\nif (gpuobj->flags & NVOBJ_FLAG_VM) {\r\nu32 flags = NV_MEM_ACCESS_RW;\r\nif (!(gpuobj->flags & NVOBJ_FLAG_VM_USER))\r\nflags |= NV_MEM_ACCESS_SYS;\r\nret = nouveau_vm_get(chan->vm, size, 12, flags,\r\n&node->chan_vma);\r\nif (ret) {\r\nvram->put(dev, &node->vram);\r\nkfree(node);\r\nreturn ret;\r\n}\r\nnouveau_vm_map(&node->chan_vma, node->vram);\r\ngpuobj->linst = node->chan_vma.offset;\r\n}\r\ngpuobj->size = size;\r\ngpuobj->node = node;\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_instmem_put(struct nouveau_gpuobj *gpuobj)\r\n{\r\nstruct drm_device *dev = gpuobj->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_vram_engine *vram = &dev_priv->engine.vram;\r\nstruct nv50_gpuobj_node *node;\r\nnode = gpuobj->node;\r\ngpuobj->node = NULL;\r\nif (node->chan_vma.node) {\r\nnouveau_vm_unmap(&node->chan_vma);\r\nnouveau_vm_put(&node->chan_vma);\r\n}\r\nvram->put(dev, &node->vram);\r\nkfree(node);\r\n}\r\nint\r\nnv50_instmem_map(struct nouveau_gpuobj *gpuobj)\r\n{\r\nstruct drm_nouveau_private *dev_priv = gpuobj->dev->dev_private;\r\nstruct nv50_gpuobj_node *node = gpuobj->node;\r\nint ret;\r\nret = nouveau_vm_get(dev_priv->bar3_vm, gpuobj->size, 12,\r\nNV_MEM_ACCESS_RW, &node->vram->bar_vma);\r\nif (ret)\r\nreturn ret;\r\nnouveau_vm_map(&node->vram->bar_vma, node->vram);\r\ngpuobj->pinst = node->vram->bar_vma.offset;\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_instmem_unmap(struct nouveau_gpuobj *gpuobj)\r\n{\r\nstruct nv50_gpuobj_node *node = gpuobj->node;\r\nif (node->vram->bar_vma.node) {\r\nnouveau_vm_unmap(&node->vram->bar_vma);\r\nnouveau_vm_put(&node->vram->bar_vma);\r\n}\r\n}\r\nvoid\r\nnv50_instmem_flush(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_priv->vm_lock, flags);\r\nnv_wr32(dev, 0x00330c, 0x00000001);\r\nif (!nv_wait(dev, 0x00330c, 0x00000002, 0x00000000))\r\nNV_ERROR(dev, "PRAMIN flush timeout\n");\r\nspin_unlock_irqrestore(&dev_priv->vm_lock, flags);\r\n}\r\nvoid\r\nnv84_instmem_flush(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_priv->vm_lock, flags);\r\nnv_wr32(dev, 0x070000, 0x00000001);\r\nif (!nv_wait(dev, 0x070000, 0x00000002, 0x00000000))\r\nNV_ERROR(dev, "PRAMIN flush timeout\n");\r\nspin_unlock_irqrestore(&dev_priv->vm_lock, flags);\r\n}
