static int uea_send_modem_cmd(struct usb_device *usb,\r\nu16 addr, u16 size, const u8 *buff)\r\n{\r\nint ret = -ENOMEM;\r\nu8 *xfer_buff;\r\nxfer_buff = kmemdup(buff, size, GFP_KERNEL);\r\nif (xfer_buff) {\r\nret = usb_control_msg(usb,\r\nusb_sndctrlpipe(usb, 0),\r\nLOAD_INTERNAL,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, addr, 0, xfer_buff,\r\nsize, CTRL_TIMEOUT);\r\nkfree(xfer_buff);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (ret == size) ? 0 : -EIO;\r\n}\r\nstatic void uea_upload_pre_firmware(const struct firmware *fw_entry,\r\nvoid *context)\r\n{\r\nstruct usb_device *usb = context;\r\nconst u8 *pfw;\r\nu8 value;\r\nu32 crc = 0;\r\nint ret, size;\r\nuea_enters(usb);\r\nif (!fw_entry) {\r\nuea_err(usb, "firmware is not available\n");\r\ngoto err;\r\n}\r\npfw = fw_entry->data;\r\nsize = fw_entry->size;\r\nif (size < 4)\r\ngoto err_fw_corrupted;\r\ncrc = get_unaligned_le32(pfw);\r\npfw += 4;\r\nsize -= 4;\r\nif (crc32_be(0, pfw, size) != crc)\r\ngoto err_fw_corrupted;\r\nvalue = 1;\r\nret = uea_send_modem_cmd(usb, F8051_USBCS, sizeof(value), &value);\r\nif (ret < 0) {\r\nuea_err(usb, "modem reset failed with error %d\n", ret);\r\ngoto err;\r\n}\r\nwhile (size > 3) {\r\nu8 len = FW_GET_BYTE(pfw);\r\nu16 add = get_unaligned_le16(pfw + 1);\r\nsize -= len + 3;\r\nif (size < 0)\r\ngoto err_fw_corrupted;\r\nret = uea_send_modem_cmd(usb, add, len, pfw + 3);\r\nif (ret < 0) {\r\nuea_err(usb, "uploading firmware data failed "\r\n"with error %d\n", ret);\r\ngoto err;\r\n}\r\npfw += len + 3;\r\n}\r\nif (size != 0)\r\ngoto err_fw_corrupted;\r\nvalue = 0;\r\nret = uea_send_modem_cmd(usb, F8051_USBCS, 1, &value);\r\nif (ret < 0)\r\nuea_err(usb, "modem de-assert failed with error %d\n", ret);\r\nelse\r\nuea_info(usb, "firmware uploaded\n");\r\ngoto err;\r\nerr_fw_corrupted:\r\nuea_err(usb, "firmware is corrupted\n");\r\nerr:\r\nrelease_firmware(fw_entry);\r\nuea_leaves(usb);\r\n}\r\nstatic int uea_load_firmware(struct usb_device *usb, unsigned int ver)\r\n{\r\nint ret;\r\nchar *fw_name = FW_DIR "eagle.fw";\r\nuea_enters(usb);\r\nuea_info(usb, "pre-firmware device, uploading firmware\n");\r\nswitch (ver) {\r\ncase ADI930:\r\nfw_name = FW_DIR "adi930.fw";\r\nbreak;\r\ncase EAGLE_I:\r\nfw_name = FW_DIR "eagleI.fw";\r\nbreak;\r\ncase EAGLE_II:\r\nfw_name = FW_DIR "eagleII.fw";\r\nbreak;\r\ncase EAGLE_III:\r\nfw_name = FW_DIR "eagleIII.fw";\r\nbreak;\r\ncase EAGLE_IV:\r\nfw_name = FW_DIR "eagleIV.fw";\r\nbreak;\r\n}\r\nret = request_firmware_nowait(THIS_MODULE, 1, fw_name, &usb->dev,\r\nGFP_KERNEL, usb,\r\nuea_upload_pre_firmware);\r\nif (ret)\r\nuea_err(usb, "firmware %s is not available\n", fw_name);\r\nelse\r\nuea_info(usb, "loading firmware %s\n", fw_name);\r\nuea_leaves(usb);\r\nreturn ret;\r\n}\r\nstatic int check_dsp_e1(const u8 *dsp, unsigned int len)\r\n{\r\nu8 pagecount, blockcount;\r\nu16 blocksize;\r\nu32 pageoffset;\r\nunsigned int i, j, p, pp;\r\npagecount = FW_GET_BYTE(dsp);\r\np = 1;\r\nif (p + 4 * pagecount > len)\r\nreturn 1;\r\nfor (i = 0; i < pagecount; i++) {\r\npageoffset = get_unaligned_le32(dsp + p);\r\np += 4;\r\nif (pageoffset == 0)\r\ncontinue;\r\nif (pageoffset >= len)\r\nreturn 1;\r\npp = pageoffset;\r\nblockcount = FW_GET_BYTE(dsp + pp);\r\npp += 1;\r\nfor (j = 0; j < blockcount; j++) {\r\nif (pp + 4 > len)\r\nreturn 1;\r\npp += 2;\r\nblocksize = get_unaligned_le16(dsp + pp);\r\npp += 2;\r\nif (pp + blocksize > len)\r\nreturn 1;\r\npp += blocksize;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_dsp_e4(const u8 *dsp, int len)\r\n{\r\nint i;\r\nstruct l1_code *p = (struct l1_code *) dsp;\r\nunsigned int sum = p->code - dsp;\r\nif (len < sum)\r\nreturn 1;\r\nif (strcmp("STRATIPHY ANEXA", p->string_header) != 0 &&\r\nstrcmp("STRATIPHY ANEXB", p->string_header) != 0)\r\nreturn 1;\r\nfor (i = 0; i < E4_MAX_PAGE_NUMBER; i++) {\r\nstruct block_index *blockidx;\r\nu8 blockno = p->page_number_to_block_index[i];\r\nif (blockno >= E4_NO_SWAPPAGE_HEADERS)\r\ncontinue;\r\ndo {\r\nu64 l;\r\nif (blockno >= E4_NO_SWAPPAGE_HEADERS)\r\nreturn 1;\r\nblockidx = &p->page_header[blockno++];\r\nif ((u8 *)(blockidx + 1) - dsp >= len)\r\nreturn 1;\r\nif (le16_to_cpu(blockidx->PageNumber) != i)\r\nreturn 1;\r\nl = E4_PAGE_BYTES(blockidx->PageSize);\r\nsum += l;\r\nl += le32_to_cpu(blockidx->PageOffset);\r\nif (l > len)\r\nreturn 1;\r\n} while (blockidx->NotLastBlock);\r\n}\r\nreturn (sum == len) ? 0 : 1;\r\n}\r\nstatic int uea_idma_write(struct uea_softc *sc, const void *data, u32 size)\r\n{\r\nint ret = -ENOMEM;\r\nu8 *xfer_buff;\r\nint bytes_read;\r\nxfer_buff = kmemdup(data, size, GFP_KERNEL);\r\nif (!xfer_buff) {\r\nuea_err(INS_TO_USBDEV(sc), "can't allocate xfer_buff\n");\r\nreturn ret;\r\n}\r\nret = usb_bulk_msg(sc->usb_dev,\r\nusb_sndbulkpipe(sc->usb_dev, UEA_IDMA_PIPE),\r\nxfer_buff, size, &bytes_read, BULK_TIMEOUT);\r\nkfree(xfer_buff);\r\nif (ret < 0)\r\nreturn ret;\r\nif (size != bytes_read) {\r\nuea_err(INS_TO_USBDEV(sc), "size != bytes_read %d %d\n", size,\r\nbytes_read);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int request_dsp(struct uea_softc *sc)\r\n{\r\nint ret;\r\nchar *dsp_name;\r\nif (UEA_CHIP_VERSION(sc) == EAGLE_IV) {\r\nif (IS_ISDN(sc))\r\ndsp_name = FW_DIR "DSP4i.bin";\r\nelse\r\ndsp_name = FW_DIR "DSP4p.bin";\r\n} else if (UEA_CHIP_VERSION(sc) == ADI930) {\r\nif (IS_ISDN(sc))\r\ndsp_name = FW_DIR "DSP9i.bin";\r\nelse\r\ndsp_name = FW_DIR "DSP9p.bin";\r\n} else {\r\nif (IS_ISDN(sc))\r\ndsp_name = FW_DIR "DSPei.bin";\r\nelse\r\ndsp_name = FW_DIR "DSPep.bin";\r\n}\r\nret = request_firmware(&sc->dsp_firm, dsp_name, &sc->usb_dev->dev);\r\nif (ret < 0) {\r\nuea_err(INS_TO_USBDEV(sc),\r\n"requesting firmware %s failed with error %d\n",\r\ndsp_name, ret);\r\nreturn ret;\r\n}\r\nif (UEA_CHIP_VERSION(sc) == EAGLE_IV)\r\nret = check_dsp_e4(sc->dsp_firm->data, sc->dsp_firm->size);\r\nelse\r\nret = check_dsp_e1(sc->dsp_firm->data, sc->dsp_firm->size);\r\nif (ret) {\r\nuea_err(INS_TO_USBDEV(sc), "firmware %s is corrupted\n",\r\ndsp_name);\r\nrelease_firmware(sc->dsp_firm);\r\nsc->dsp_firm = NULL;\r\nreturn -EILSEQ;\r\n}\r\nreturn 0;\r\n}\r\nstatic void uea_load_page_e1(struct work_struct *work)\r\n{\r\nstruct uea_softc *sc = container_of(work, struct uea_softc, task);\r\nu16 pageno = sc->pageno;\r\nu16 ovl = sc->ovl;\r\nstruct block_info_e1 bi;\r\nconst u8 *p;\r\nu8 pagecount, blockcount;\r\nu16 blockaddr, blocksize;\r\nu32 pageoffset;\r\nint i;\r\nif (ovl == 0 && pageno == 0 && sc->dsp_firm) {\r\nrelease_firmware(sc->dsp_firm);\r\nsc->dsp_firm = NULL;\r\n}\r\nif (sc->dsp_firm == NULL && request_dsp(sc) < 0)\r\nreturn;\r\np = sc->dsp_firm->data;\r\npagecount = FW_GET_BYTE(p);\r\np += 1;\r\nif (pageno >= pagecount)\r\ngoto bad1;\r\np += 4 * pageno;\r\npageoffset = get_unaligned_le32(p);\r\nif (pageoffset == 0)\r\ngoto bad1;\r\np = sc->dsp_firm->data + pageoffset;\r\nblockcount = FW_GET_BYTE(p);\r\np += 1;\r\nuea_dbg(INS_TO_USBDEV(sc),\r\n"sending %u blocks for DSP page %u\n", blockcount, pageno);\r\nbi.wHdr = cpu_to_le16(UEA_BIHDR);\r\nbi.wOvl = cpu_to_le16(ovl);\r\nbi.wOvlOffset = cpu_to_le16(ovl | 0x8000);\r\nfor (i = 0; i < blockcount; i++) {\r\nblockaddr = get_unaligned_le16(p);\r\np += 2;\r\nblocksize = get_unaligned_le16(p);\r\np += 2;\r\nbi.wSize = cpu_to_le16(blocksize);\r\nbi.wAddress = cpu_to_le16(blockaddr);\r\nbi.wLast = cpu_to_le16((i == blockcount - 1) ? 1 : 0);\r\nif (uea_idma_write(sc, &bi, E1_BLOCK_INFO_SIZE))\r\ngoto bad2;\r\nif (uea_idma_write(sc, p, blocksize))\r\ngoto bad2;\r\np += blocksize;\r\n}\r\nreturn;\r\nbad2:\r\nuea_err(INS_TO_USBDEV(sc), "sending DSP block %u failed\n", i);\r\nreturn;\r\nbad1:\r\nuea_err(INS_TO_USBDEV(sc), "invalid DSP page %u requested\n", pageno);\r\n}\r\nstatic void __uea_load_page_e4(struct uea_softc *sc, u8 pageno, int boot)\r\n{\r\nstruct block_info_e4 bi;\r\nstruct block_index *blockidx;\r\nstruct l1_code *p = (struct l1_code *) sc->dsp_firm->data;\r\nu8 blockno = p->page_number_to_block_index[pageno];\r\nbi.wHdr = cpu_to_be16(UEA_BIHDR);\r\nbi.bBootPage = boot;\r\nbi.bPageNumber = pageno;\r\nbi.wReserved = cpu_to_be16(UEA_RESERVED);\r\ndo {\r\nconst u8 *blockoffset;\r\nunsigned int blocksize;\r\nblockidx = &p->page_header[blockno];\r\nblocksize = E4_PAGE_BYTES(blockidx->PageSize);\r\nblockoffset = sc->dsp_firm->data + le32_to_cpu(\r\nblockidx->PageOffset);\r\nbi.dwSize = cpu_to_be32(blocksize);\r\nbi.dwAddress = cpu_to_be32(le32_to_cpu(blockidx->PageAddress));\r\nuea_dbg(INS_TO_USBDEV(sc),\r\n"sending block %u for DSP page "\r\n"%u size %u address %x\n",\r\nblockno, pageno, blocksize,\r\nle32_to_cpu(blockidx->PageAddress));\r\nif (uea_idma_write(sc, &bi, E4_BLOCK_INFO_SIZE))\r\ngoto bad;\r\nif (uea_idma_write(sc, blockoffset, blocksize))\r\ngoto bad;\r\nblockno++;\r\n} while (blockidx->NotLastBlock);\r\nreturn;\r\nbad:\r\nuea_err(INS_TO_USBDEV(sc), "sending DSP block %u failed\n", blockno);\r\nreturn;\r\n}\r\nstatic void uea_load_page_e4(struct work_struct *work)\r\n{\r\nstruct uea_softc *sc = container_of(work, struct uea_softc, task);\r\nu8 pageno = sc->pageno;\r\nint i;\r\nstruct block_info_e4 bi;\r\nstruct l1_code *p;\r\nuea_dbg(INS_TO_USBDEV(sc), "sending DSP page %u\n", pageno);\r\nif (pageno == 0 && sc->dsp_firm) {\r\nrelease_firmware(sc->dsp_firm);\r\nsc->dsp_firm = NULL;\r\n}\r\nif (sc->dsp_firm == NULL && request_dsp(sc) < 0)\r\nreturn;\r\np = (struct l1_code *) sc->dsp_firm->data;\r\nif (pageno >= le16_to_cpu(p->page_header[0].PageNumber)) {\r\nuea_err(INS_TO_USBDEV(sc), "invalid DSP "\r\n"page %u requested\n", pageno);\r\nreturn;\r\n}\r\nif (pageno != 0) {\r\n__uea_load_page_e4(sc, pageno, 0);\r\nreturn;\r\n}\r\nuea_dbg(INS_TO_USBDEV(sc),\r\n"sending Main DSP page %u\n", p->page_header[0].PageNumber);\r\nfor (i = 0; i < le16_to_cpu(p->page_header[0].PageNumber); i++) {\r\nif (E4_IS_BOOT_PAGE(p->page_header[i].PageSize))\r\n__uea_load_page_e4(sc, i, 1);\r\n}\r\nuea_dbg(INS_TO_USBDEV(sc) , "sending start bi\n");\r\nbi.wHdr = cpu_to_be16(UEA_BIHDR);\r\nbi.bBootPage = 0;\r\nbi.bPageNumber = 0xff;\r\nbi.wReserved = cpu_to_be16(UEA_RESERVED);\r\nbi.dwSize = cpu_to_be32(E4_PAGE_BYTES(p->page_header[0].PageSize));\r\nbi.dwAddress = cpu_to_be32(le32_to_cpu(p->page_header[0].PageAddress));\r\nif (uea_idma_write(sc, &bi, E4_BLOCK_INFO_SIZE))\r\nuea_err(INS_TO_USBDEV(sc), "sending DSP start bi failed\n");\r\n}\r\nstatic inline void wake_up_cmv_ack(struct uea_softc *sc)\r\n{\r\nBUG_ON(sc->cmv_ack);\r\nsc->cmv_ack = 1;\r\nwake_up(&sc->sync_q);\r\n}\r\nstatic inline int wait_cmv_ack(struct uea_softc *sc)\r\n{\r\nint ret = uea_wait(sc, sc->cmv_ack , ACK_TIMEOUT);\r\nsc->cmv_ack = 0;\r\nuea_dbg(INS_TO_USBDEV(sc), "wait_event_timeout : %d ms\n",\r\njiffies_to_msecs(ret));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (ret == 0) ? -ETIMEDOUT : 0;\r\n}\r\nstatic int uea_request(struct uea_softc *sc,\r\nu16 value, u16 index, u16 size, const void *data)\r\n{\r\nu8 *xfer_buff;\r\nint ret = -ENOMEM;\r\nxfer_buff = kmemdup(data, size, GFP_KERNEL);\r\nif (!xfer_buff) {\r\nuea_err(INS_TO_USBDEV(sc), "can't allocate xfer_buff\n");\r\nreturn ret;\r\n}\r\nret = usb_control_msg(sc->usb_dev, usb_sndctrlpipe(sc->usb_dev, 0),\r\nUCDC_SEND_ENCAPSULATED_COMMAND,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, xfer_buff, size, CTRL_TIMEOUT);\r\nkfree(xfer_buff);\r\nif (ret < 0) {\r\nuea_err(INS_TO_USBDEV(sc), "usb_control_msg error %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ret != size) {\r\nuea_err(INS_TO_USBDEV(sc),\r\n"usb_control_msg send only %d bytes (instead of %d)\n",\r\nret, size);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uea_cmv_e1(struct uea_softc *sc,\r\nu8 function, u32 address, u16 offset, u32 data)\r\n{\r\nstruct cmv_e1 cmv;\r\nint ret;\r\nuea_enters(INS_TO_USBDEV(sc));\r\nuea_vdbg(INS_TO_USBDEV(sc), "Function : %d-%d, Address : %c%c%c%c, "\r\n"offset : 0x%04x, data : 0x%08x\n",\r\nE1_FUNCTION_TYPE(function),\r\nE1_FUNCTION_SUBTYPE(function),\r\nE1_GETSA1(address), E1_GETSA2(address),\r\nE1_GETSA3(address),\r\nE1_GETSA4(address), offset, data);\r\nsc->cmv_dsc.e1.function = function | 0x2;\r\nsc->cmv_dsc.e1.idx++;\r\nsc->cmv_dsc.e1.address = address;\r\nsc->cmv_dsc.e1.offset = offset;\r\ncmv.wPreamble = cpu_to_le16(E1_PREAMBLE);\r\ncmv.bDirection = E1_HOSTTOMODEM;\r\ncmv.bFunction = function;\r\ncmv.wIndex = cpu_to_le16(sc->cmv_dsc.e1.idx);\r\nput_unaligned_le32(address, &cmv.dwSymbolicAddress);\r\ncmv.wOffsetAddress = cpu_to_le16(offset);\r\nput_unaligned_le32(data >> 16 | data << 16, &cmv.dwData);\r\nret = uea_request(sc, UEA_E1_SET_BLOCK, UEA_MPTX_START,\r\nsizeof(cmv), &cmv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wait_cmv_ack(sc);\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn ret;\r\n}\r\nstatic int uea_cmv_e4(struct uea_softc *sc,\r\nu16 function, u16 group, u16 address, u16 offset, u32 data)\r\n{\r\nstruct cmv_e4 cmv;\r\nint ret;\r\nuea_enters(INS_TO_USBDEV(sc));\r\nmemset(&cmv, 0, sizeof(cmv));\r\nuea_vdbg(INS_TO_USBDEV(sc), "Function : %d-%d, Group : 0x%04x, "\r\n"Address : 0x%04x, offset : 0x%04x, data : 0x%08x\n",\r\nE4_FUNCTION_TYPE(function), E4_FUNCTION_SUBTYPE(function),\r\ngroup, address, offset, data);\r\nsc->cmv_dsc.e4.function = function | (0x1 << 4);\r\nsc->cmv_dsc.e4.offset = offset;\r\nsc->cmv_dsc.e4.address = address;\r\nsc->cmv_dsc.e4.group = group;\r\ncmv.wFunction = cpu_to_be16(function);\r\ncmv.wGroup = cpu_to_be16(group);\r\ncmv.wAddress = cpu_to_be16(address);\r\ncmv.wOffset = cpu_to_be16(offset);\r\ncmv.dwData[0] = cpu_to_be32(data);\r\nret = uea_request(sc, UEA_E4_SET_BLOCK, UEA_MPTX_START,\r\nsizeof(cmv), &cmv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wait_cmv_ack(sc);\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn ret;\r\n}\r\nstatic inline int uea_read_cmv_e1(struct uea_softc *sc,\r\nu32 address, u16 offset, u32 *data)\r\n{\r\nint ret = uea_cmv_e1(sc, E1_MAKEFUNCTION(E1_MEMACCESS, E1_REQUESTREAD),\r\naddress, offset, 0);\r\nif (ret < 0)\r\nuea_err(INS_TO_USBDEV(sc),\r\n"reading cmv failed with error %d\n", ret);\r\nelse\r\n*data = sc->data;\r\nreturn ret;\r\n}\r\nstatic inline int uea_read_cmv_e4(struct uea_softc *sc,\r\nu8 size, u16 group, u16 address, u16 offset, u32 *data)\r\n{\r\nint ret = uea_cmv_e4(sc, E4_MAKEFUNCTION(E4_MEMACCESS,\r\nE4_REQUESTREAD, size),\r\ngroup, address, offset, 0);\r\nif (ret < 0)\r\nuea_err(INS_TO_USBDEV(sc),\r\n"reading cmv failed with error %d\n", ret);\r\nelse {\r\n*data = sc->data;\r\nif (size > 2)\r\n*(data + 1) = sc->data1;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int uea_write_cmv_e1(struct uea_softc *sc,\r\nu32 address, u16 offset, u32 data)\r\n{\r\nint ret = uea_cmv_e1(sc, E1_MAKEFUNCTION(E1_MEMACCESS, E1_REQUESTWRITE),\r\naddress, offset, data);\r\nif (ret < 0)\r\nuea_err(INS_TO_USBDEV(sc),\r\n"writing cmv failed with error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic inline int uea_write_cmv_e4(struct uea_softc *sc,\r\nu8 size, u16 group, u16 address, u16 offset, u32 data)\r\n{\r\nint ret = uea_cmv_e4(sc, E4_MAKEFUNCTION(E4_MEMACCESS,\r\nE4_REQUESTWRITE, size),\r\ngroup, address, offset, data);\r\nif (ret < 0)\r\nuea_err(INS_TO_USBDEV(sc),\r\n"writing cmv failed with error %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void uea_set_bulk_timeout(struct uea_softc *sc, u32 dsrate)\r\n{\r\nint ret;\r\nu16 timeout;\r\nif (UEA_CHIP_VERSION(sc) == ADI930 ||\r\naltsetting[sc->modem_index] > 0 ||\r\nsc->stats.phy.dsrate == dsrate)\r\nreturn;\r\ntimeout = (dsrate <= 1024*1024) ? 0 : 1;\r\nret = uea_request(sc, UEA_SET_TIMEOUT, timeout, 0, NULL);\r\nuea_info(INS_TO_USBDEV(sc), "setting new timeout %d%s\n",\r\ntimeout, ret < 0 ? " failed" : "");\r\n}\r\nstatic int uea_stat_e1(struct uea_softc *sc)\r\n{\r\nu32 data;\r\nint ret;\r\nuea_enters(INS_TO_USBDEV(sc));\r\ndata = sc->stats.phy.state;\r\nret = uea_read_cmv_e1(sc, E1_SA_STAT, 0, &sc->stats.phy.state);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (GET_STATUS(sc->stats.phy.state)) {\r\ncase 0:\r\nuea_dbg(INS_TO_USBDEV(sc),\r\n"modem not yet synchronized\n");\r\nreturn 0;\r\ncase 1:\r\nuea_dbg(INS_TO_USBDEV(sc), "modem initializing\n");\r\nreturn 0;\r\ncase 2:\r\nuea_vdbg(INS_TO_USBDEV(sc), "modem operational\n");\r\nbreak;\r\ncase 3:\r\nuea_info(INS_TO_USBDEV(sc), "modem synchronization failed"\r\n" (may be try other cmv/dsp)\n");\r\nreturn -EAGAIN;\r\ncase 4 ... 6:\r\nuea_warn(INS_TO_USBDEV(sc),\r\n"modem in test mode - not supported\n");\r\nreturn -EAGAIN;\r\ncase 7:\r\nuea_info(INS_TO_USBDEV(sc), "modem in fast-retain mode\n");\r\nreturn 0;\r\ndefault:\r\nuea_err(INS_TO_USBDEV(sc), "modem invalid SW mode %d\n",\r\nGET_STATUS(sc->stats.phy.state));\r\nreturn -EAGAIN;\r\n}\r\nif (GET_STATUS(data) != 2) {\r\nuea_request(sc, UEA_SET_MODE, UEA_LOOPBACK_OFF, 0, NULL);\r\nuea_info(INS_TO_USBDEV(sc), "modem operational\n");\r\nrelease_firmware(sc->dsp_firm);\r\nsc->dsp_firm = NULL;\r\n}\r\nUPDATE_ATM_SIGNAL(ATM_PHY_SIG_FOUND);\r\nwake_up(&sc->sync_q);\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 2, &sc->stats.phy.flags);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->stats.phy.mflags |= sc->stats.phy.flags;\r\nif (sc->stats.phy.flags) {\r\nuea_dbg(INS_TO_USBDEV(sc), "Stat flag = 0x%x\n",\r\nsc->stats.phy.flags);\r\nreturn 0;\r\n}\r\nret = uea_read_cmv_e1(sc, E1_SA_RATE, 0, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nuea_set_bulk_timeout(sc, (data >> 16) * 32);\r\nsc->stats.phy.dsrate = (data >> 16) * 32;\r\nsc->stats.phy.usrate = (data & 0xffff) * 32;\r\nUPDATE_ATM_STAT(link_rate, sc->stats.phy.dsrate * 1000 / 424);\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 23, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->stats.phy.dsattenuation = (data & 0xff) / 2;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 47, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->stats.phy.usattenuation = (data & 0xff) / 2;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 25, &sc->stats.phy.dsmargin);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 49, &sc->stats.phy.usmargin);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 51, &sc->stats.phy.rxflow);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 52, &sc->stats.phy.txflow);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 54, &sc->stats.phy.dsunc);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 58, &sc->stats.phy.usunc);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 53, &sc->stats.phy.dscorr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_DIAG, 57, &sc->stats.phy.uscorr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_INFO, 8, &sc->stats.phy.vidco);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_INFO, 13, &sc->stats.phy.vidcpe);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int uea_stat_e4(struct uea_softc *sc)\r\n{\r\nu32 data;\r\nu32 tmp_arr[2];\r\nint ret;\r\nuea_enters(INS_TO_USBDEV(sc));\r\ndata = sc->stats.phy.state;\r\nret = uea_read_cmv_e4(sc, 1, E4_SA_STAT, 0, 0, &sc->stats.phy.state);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (sc->stats.phy.state) {\r\ncase 0x0:\r\ncase 0x1:\r\ncase 0x3:\r\ncase 0x4:\r\nuea_dbg(INS_TO_USBDEV(sc), "modem not yet "\r\n"synchronized\n");\r\nreturn 0;\r\ncase 0x5:\r\ncase 0x6:\r\ncase 0x9:\r\ncase 0xa:\r\nuea_dbg(INS_TO_USBDEV(sc), "modem initializing\n");\r\nreturn 0;\r\ncase 0x2:\r\nuea_info(INS_TO_USBDEV(sc), "modem synchronization "\r\n"failed (may be try other cmv/dsp)\n");\r\nreturn -EAGAIN;\r\ncase 0x7:\r\nbreak;\r\ndefault:\r\nuea_warn(INS_TO_USBDEV(sc), "unknown state: %x\n",\r\nsc->stats.phy.state);\r\nreturn 0;\r\n}\r\nif (data != 7) {\r\nuea_request(sc, UEA_SET_MODE, UEA_LOOPBACK_OFF, 0, NULL);\r\nuea_info(INS_TO_USBDEV(sc), "modem operational\n");\r\nrelease_firmware(sc->dsp_firm);\r\nsc->dsp_firm = NULL;\r\n}\r\nUPDATE_ATM_SIGNAL(ATM_PHY_SIG_FOUND);\r\nwake_up(&sc->sync_q);\r\nret = uea_read_cmv_e4(sc, 1, E4_SA_DIAG, 0, 0, &sc->stats.phy.flags);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->stats.phy.mflags |= sc->stats.phy.flags;\r\nif (sc->stats.phy.flags) {\r\nuea_dbg(INS_TO_USBDEV(sc), "Stat flag = 0x%x\n",\r\nsc->stats.phy.flags);\r\nif (sc->stats.phy.flags & 1)\r\nreturn -EAGAIN;\r\nif (sc->stats.phy.flags & 0x4000)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nret = uea_read_cmv_e4(sc, 4, E4_SA_RATE, 0, 0, tmp_arr);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = (tmp_arr[0]) ? tmp_arr[0] : tmp_arr[1];\r\nsc->stats.phy.usrate = data / 1000;\r\nret = uea_read_cmv_e4(sc, 4, E4_SA_RATE, 1, 0, tmp_arr);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = (tmp_arr[0]) ? tmp_arr[0] : tmp_arr[1];\r\nuea_set_bulk_timeout(sc, data / 1000);\r\nsc->stats.phy.dsrate = data / 1000;\r\nUPDATE_ATM_STAT(link_rate, sc->stats.phy.dsrate * 1000 / 424);\r\nret = uea_read_cmv_e4(sc, 1, E4_SA_INFO, 68, 1, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->stats.phy.dsattenuation = data / 10;\r\nret = uea_read_cmv_e4(sc, 1, E4_SA_INFO, 69, 1, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->stats.phy.usattenuation = data / 10;\r\nret = uea_read_cmv_e4(sc, 1, E4_SA_INFO, 68, 3, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->stats.phy.dsmargin = data / 2;\r\nret = uea_read_cmv_e4(sc, 1, E4_SA_INFO, 69, 3, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->stats.phy.usmargin = data / 10;\r\nreturn 0;\r\n}\r\nstatic void cmvs_file_name(struct uea_softc *sc, char *const cmv_name, int ver)\r\n{\r\nchar file_arr[] = "CMVxy.bin";\r\nchar *file;\r\nkparam_block_sysfs_write(cmv_file);\r\nif (cmv_file[sc->modem_index] == NULL) {\r\nif (UEA_CHIP_VERSION(sc) == ADI930)\r\nfile_arr[3] = '9';\r\nelse if (UEA_CHIP_VERSION(sc) == EAGLE_IV)\r\nfile_arr[3] = '4';\r\nelse\r\nfile_arr[3] = 'e';\r\nfile_arr[4] = IS_ISDN(sc) ? 'i' : 'p';\r\nfile = file_arr;\r\n} else\r\nfile = cmv_file[sc->modem_index];\r\nstrcpy(cmv_name, FW_DIR);\r\nstrlcat(cmv_name, file, UEA_FW_NAME_MAX);\r\nif (ver == 2)\r\nstrlcat(cmv_name, ".v2", UEA_FW_NAME_MAX);\r\nkparam_unblock_sysfs_write(cmv_file);\r\n}\r\nstatic int request_cmvs_old(struct uea_softc *sc,\r\nvoid **cmvs, const struct firmware **fw)\r\n{\r\nint ret, size;\r\nu8 *data;\r\nchar cmv_name[UEA_FW_NAME_MAX];\r\ncmvs_file_name(sc, cmv_name, 1);\r\nret = request_firmware(fw, cmv_name, &sc->usb_dev->dev);\r\nif (ret < 0) {\r\nuea_err(INS_TO_USBDEV(sc),\r\n"requesting firmware %s failed with error %d\n",\r\ncmv_name, ret);\r\nreturn ret;\r\n}\r\ndata = (u8 *) (*fw)->data;\r\nsize = (*fw)->size;\r\nif (size < 1)\r\ngoto err_fw_corrupted;\r\nif (size != *data * sizeof(struct uea_cmvs_v1) + 1)\r\ngoto err_fw_corrupted;\r\n*cmvs = (void *)(data + 1);\r\nreturn *data;\r\nerr_fw_corrupted:\r\nuea_err(INS_TO_USBDEV(sc), "firmware %s is corrupted\n", cmv_name);\r\nrelease_firmware(*fw);\r\nreturn -EILSEQ;\r\n}\r\nstatic int request_cmvs(struct uea_softc *sc,\r\nvoid **cmvs, const struct firmware **fw, int *ver)\r\n{\r\nint ret, size;\r\nu32 crc;\r\nu8 *data;\r\nchar cmv_name[UEA_FW_NAME_MAX];\r\ncmvs_file_name(sc, cmv_name, 2);\r\nret = request_firmware(fw, cmv_name, &sc->usb_dev->dev);\r\nif (ret < 0) {\r\nif (*ver == 1) {\r\nuea_warn(INS_TO_USBDEV(sc), "requesting "\r\n"firmware %s failed, "\r\n"try to get older cmvs\n", cmv_name);\r\nreturn request_cmvs_old(sc, cmvs, fw);\r\n}\r\nuea_err(INS_TO_USBDEV(sc),\r\n"requesting firmware %s failed with error %d\n",\r\ncmv_name, ret);\r\nreturn ret;\r\n}\r\nsize = (*fw)->size;\r\ndata = (u8 *) (*fw)->data;\r\nif (size < 4 || strncmp(data, "cmv2", 4) != 0) {\r\nif (*ver == 1) {\r\nuea_warn(INS_TO_USBDEV(sc), "firmware %s is corrupted,"\r\n" try to get older cmvs\n", cmv_name);\r\nrelease_firmware(*fw);\r\nreturn request_cmvs_old(sc, cmvs, fw);\r\n}\r\ngoto err_fw_corrupted;\r\n}\r\n*ver = 2;\r\ndata += 4;\r\nsize -= 4;\r\nif (size < 5)\r\ngoto err_fw_corrupted;\r\ncrc = get_unaligned_le32(data);\r\ndata += 4;\r\nsize -= 4;\r\nif (crc32_be(0, data, size) != crc)\r\ngoto err_fw_corrupted;\r\nif (size != *data * sizeof(struct uea_cmvs_v2) + 1)\r\ngoto err_fw_corrupted;\r\n*cmvs = (void *) (data + 1);\r\nreturn *data;\r\nerr_fw_corrupted:\r\nuea_err(INS_TO_USBDEV(sc), "firmware %s is corrupted\n", cmv_name);\r\nrelease_firmware(*fw);\r\nreturn -EILSEQ;\r\n}\r\nstatic int uea_send_cmvs_e1(struct uea_softc *sc)\r\n{\r\nint i, ret, len;\r\nvoid *cmvs_ptr;\r\nconst struct firmware *cmvs_fw;\r\nint ver = 1;\r\nret = uea_write_cmv_e1(sc, E1_SA_CNTL, 0, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e1(sc, E1_SA_INFO, 10, &sc->stats.phy.firmid);\r\nif (ret < 0)\r\nreturn ret;\r\nuea_info(INS_TO_USBDEV(sc), "ATU-R firmware version : %x\n",\r\nsc->stats.phy.firmid);\r\nret = len = request_cmvs(sc, &cmvs_ptr, &cmvs_fw, &ver);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ver == 1) {\r\nstruct uea_cmvs_v1 *cmvs_v1 = cmvs_ptr;\r\nuea_warn(INS_TO_USBDEV(sc), "use deprecated cmvs version, "\r\n"please update your firmware\n");\r\nfor (i = 0; i < len; i++) {\r\nret = uea_write_cmv_e1(sc,\r\nget_unaligned_le32(&cmvs_v1[i].address),\r\nget_unaligned_le16(&cmvs_v1[i].offset),\r\nget_unaligned_le32(&cmvs_v1[i].data));\r\nif (ret < 0)\r\ngoto out;\r\n}\r\n} else if (ver == 2) {\r\nstruct uea_cmvs_v2 *cmvs_v2 = cmvs_ptr;\r\nfor (i = 0; i < len; i++) {\r\nret = uea_write_cmv_e1(sc,\r\nget_unaligned_le32(&cmvs_v2[i].address),\r\n(u16) get_unaligned_le32(&cmvs_v2[i].offset),\r\nget_unaligned_le32(&cmvs_v2[i].data));\r\nif (ret < 0)\r\ngoto out;\r\n}\r\n} else {\r\nuea_err(INS_TO_USBDEV(sc), "bad cmvs version %d\n", ver);\r\ngoto out;\r\n}\r\nret = uea_write_cmv_e1(sc, E1_SA_CNTL, 0, 2);\r\nuea_vdbg(INS_TO_USBDEV(sc), "Entering in R-ACT-REQ state\n");\r\nuea_info(INS_TO_USBDEV(sc), "modem started, waiting "\r\n"synchronization...\n");\r\nout:\r\nrelease_firmware(cmvs_fw);\r\nreturn ret;\r\n}\r\nstatic int uea_send_cmvs_e4(struct uea_softc *sc)\r\n{\r\nint i, ret, len;\r\nvoid *cmvs_ptr;\r\nconst struct firmware *cmvs_fw;\r\nint ver = 2;\r\nret = uea_write_cmv_e4(sc, 1, E4_SA_CNTL, 0, 0, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uea_read_cmv_e4(sc, 2, E4_SA_INFO, 55, 0, &sc->stats.phy.firmid);\r\nif (ret < 0)\r\nreturn ret;\r\nuea_info(INS_TO_USBDEV(sc), "ATU-R firmware version : %x\n",\r\nsc->stats.phy.firmid);\r\nret = len = request_cmvs(sc, &cmvs_ptr, &cmvs_fw, &ver);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ver == 2) {\r\nstruct uea_cmvs_v2 *cmvs_v2 = cmvs_ptr;\r\nfor (i = 0; i < len; i++) {\r\nret = uea_write_cmv_e4(sc, 1,\r\nget_unaligned_le32(&cmvs_v2[i].group),\r\nget_unaligned_le32(&cmvs_v2[i].address),\r\nget_unaligned_le32(&cmvs_v2[i].offset),\r\nget_unaligned_le32(&cmvs_v2[i].data));\r\nif (ret < 0)\r\ngoto out;\r\n}\r\n} else {\r\nuea_err(INS_TO_USBDEV(sc), "bad cmvs version %d\n", ver);\r\ngoto out;\r\n}\r\nret = uea_write_cmv_e4(sc, 1, E4_SA_CNTL, 0, 0, 2);\r\nuea_vdbg(INS_TO_USBDEV(sc), "Entering in R-ACT-REQ state\n");\r\nuea_info(INS_TO_USBDEV(sc), "modem started, waiting "\r\n"synchronization...\n");\r\nout:\r\nrelease_firmware(cmvs_fw);\r\nreturn ret;\r\n}\r\nstatic int uea_start_reset(struct uea_softc *sc)\r\n{\r\nu16 zero = 0;\r\nint ret;\r\nuea_enters(INS_TO_USBDEV(sc));\r\nuea_info(INS_TO_USBDEV(sc), "(re)booting started\n");\r\nsc->booting = 1;\r\nsc->cmv_ack = 0;\r\nUPDATE_ATM_SIGNAL(ATM_PHY_SIG_LOST);\r\nmemset(&sc->stats, 0, sizeof(struct uea_stats));\r\nuea_request(sc, UEA_SET_MODE, UEA_LOOPBACK_ON, 0, NULL);\r\nuea_request(sc, UEA_SET_MODE, UEA_BOOT_IDMA, 0, NULL);\r\nuea_request(sc, UEA_SET_MODE, UEA_START_RESET, 0, NULL);\r\nret = uea_wait(sc, 0, msecs_to_jiffies(100));\r\nif (ret < 0)\r\nreturn ret;\r\nuea_request(sc, UEA_SET_MODE, UEA_END_RESET, 0, NULL);\r\nif (UEA_CHIP_VERSION(sc) != EAGLE_IV) {\r\nuea_request(sc, UEA_SET_2183_DATA, UEA_MPTX_MAILBOX, 2, &zero);\r\nuea_request(sc, UEA_SET_2183_DATA, UEA_MPRX_MAILBOX, 2, &zero);\r\nuea_request(sc, UEA_SET_2183_DATA, UEA_SWAP_MAILBOX, 2, &zero);\r\n}\r\nret = uea_wait(sc, 0, msecs_to_jiffies(1000));\r\nif (ret < 0)\r\nreturn ret;\r\nif (UEA_CHIP_VERSION(sc) == EAGLE_IV)\r\nsc->cmv_dsc.e4.function = E4_MAKEFUNCTION(E4_ADSLDIRECTIVE,\r\nE4_MODEMREADY, 1);\r\nelse\r\nsc->cmv_dsc.e1.function = E1_MAKEFUNCTION(E1_ADSLDIRECTIVE,\r\nE1_MODEMREADY);\r\nsc->booting = 0;\r\nsc->pageno = 0;\r\nsc->ovl = 0;\r\nschedule_work(&sc->task);\r\nret = wait_cmv_ack(sc);\r\nif (ret < 0)\r\nreturn ret;\r\nuea_vdbg(INS_TO_USBDEV(sc), "Ready CMV received\n");\r\nret = sc->send_cmvs(sc);\r\nif (ret < 0)\r\nreturn ret;\r\nsc->reset = 0;\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn ret;\r\n}\r\nstatic int uea_kthread(void *data)\r\n{\r\nstruct uea_softc *sc = data;\r\nint ret = -EAGAIN;\r\nset_freezable();\r\nuea_enters(INS_TO_USBDEV(sc));\r\nwhile (!kthread_should_stop()) {\r\nif (ret < 0 || sc->reset)\r\nret = uea_start_reset(sc);\r\nif (!ret)\r\nret = sc->stat(sc);\r\nif (ret != -EAGAIN)\r\nuea_wait(sc, 0, msecs_to_jiffies(1000));\r\ntry_to_freeze();\r\n}\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn ret;\r\n}\r\nstatic int load_XILINX_firmware(struct uea_softc *sc)\r\n{\r\nconst struct firmware *fw_entry;\r\nint ret, size, u, ln;\r\nconst u8 *pfw;\r\nu8 value;\r\nchar *fw_name = FW_DIR "930-fpga.bin";\r\nuea_enters(INS_TO_USBDEV(sc));\r\nret = request_firmware(&fw_entry, fw_name, &sc->usb_dev->dev);\r\nif (ret) {\r\nuea_err(INS_TO_USBDEV(sc), "firmware %s is not available\n",\r\nfw_name);\r\ngoto err0;\r\n}\r\npfw = fw_entry->data;\r\nsize = fw_entry->size;\r\nif (size != 0x577B) {\r\nuea_err(INS_TO_USBDEV(sc), "firmware %s is corrupted\n",\r\nfw_name);\r\nret = -EILSEQ;\r\ngoto err1;\r\n}\r\nfor (u = 0; u < size; u += ln) {\r\nln = min(size - u, 64);\r\nret = uea_request(sc, 0xe, 0, ln, pfw + u);\r\nif (ret < 0) {\r\nuea_err(INS_TO_USBDEV(sc),\r\n"elsa download data failed (%d)\n", ret);\r\ngoto err1;\r\n}\r\n}\r\nret = uea_request(sc, 0xe, 1, 0, NULL);\r\nif (ret < 0) {\r\nuea_err(INS_TO_USBDEV(sc),\r\n"elsa download data failed (%d)\n", ret);\r\ngoto err1;\r\n}\r\nvalue = 0;\r\nret = uea_send_modem_cmd(sc->usb_dev, 0xe, 1, &value);\r\nif (ret < 0)\r\nuea_err(sc->usb_dev, "elsa de-assert failed with error"\r\n" %d\n", ret);\r\nerr1:\r\nrelease_firmware(fw_entry);\r\nerr0:\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn ret;\r\n}\r\nstatic void uea_dispatch_cmv_e1(struct uea_softc *sc, struct intr_pkt *intr)\r\n{\r\nstruct cmv_dsc_e1 *dsc = &sc->cmv_dsc.e1;\r\nstruct cmv_e1 *cmv = &intr->u.e1.s2.cmv;\r\nuea_enters(INS_TO_USBDEV(sc));\r\nif (le16_to_cpu(cmv->wPreamble) != E1_PREAMBLE)\r\ngoto bad1;\r\nif (cmv->bDirection != E1_MODEMTOHOST)\r\ngoto bad1;\r\nif (cmv->bFunction != dsc->function) {\r\nif (UEA_CHIP_VERSION(sc) == ADI930\r\n&& cmv->bFunction == E1_MAKEFUNCTION(2, 2)) {\r\ncmv->wIndex = cpu_to_le16(dsc->idx);\r\nput_unaligned_le32(dsc->address,\r\n&cmv->dwSymbolicAddress);\r\ncmv->wOffsetAddress = cpu_to_le16(dsc->offset);\r\n} else\r\ngoto bad2;\r\n}\r\nif (cmv->bFunction == E1_MAKEFUNCTION(E1_ADSLDIRECTIVE,\r\nE1_MODEMREADY)) {\r\nwake_up_cmv_ack(sc);\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn;\r\n}\r\nif (le16_to_cpu(cmv->wIndex) != dsc->idx ||\r\nget_unaligned_le32(&cmv->dwSymbolicAddress) != dsc->address ||\r\nle16_to_cpu(cmv->wOffsetAddress) != dsc->offset)\r\ngoto bad2;\r\nsc->data = get_unaligned_le32(&cmv->dwData);\r\nsc->data = sc->data << 16 | sc->data >> 16;\r\nwake_up_cmv_ack(sc);\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn;\r\nbad2:\r\nuea_err(INS_TO_USBDEV(sc), "unexpected cmv received, "\r\n"Function : %d, Subfunction : %d\n",\r\nE1_FUNCTION_TYPE(cmv->bFunction),\r\nE1_FUNCTION_SUBTYPE(cmv->bFunction));\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn;\r\nbad1:\r\nuea_err(INS_TO_USBDEV(sc), "invalid cmv received, "\r\n"wPreamble %d, bDirection %d\n",\r\nle16_to_cpu(cmv->wPreamble), cmv->bDirection);\r\nuea_leaves(INS_TO_USBDEV(sc));\r\n}\r\nstatic void uea_dispatch_cmv_e4(struct uea_softc *sc, struct intr_pkt *intr)\r\n{\r\nstruct cmv_dsc_e4 *dsc = &sc->cmv_dsc.e4;\r\nstruct cmv_e4 *cmv = &intr->u.e4.s2.cmv;\r\nuea_enters(INS_TO_USBDEV(sc));\r\nuea_dbg(INS_TO_USBDEV(sc), "cmv %x %x %x %x %x %x\n",\r\nbe16_to_cpu(cmv->wGroup), be16_to_cpu(cmv->wFunction),\r\nbe16_to_cpu(cmv->wOffset), be16_to_cpu(cmv->wAddress),\r\nbe32_to_cpu(cmv->dwData[0]), be32_to_cpu(cmv->dwData[1]));\r\nif (be16_to_cpu(cmv->wFunction) != dsc->function)\r\ngoto bad2;\r\nif (be16_to_cpu(cmv->wFunction) == E4_MAKEFUNCTION(E4_ADSLDIRECTIVE,\r\nE4_MODEMREADY, 1)) {\r\nwake_up_cmv_ack(sc);\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn;\r\n}\r\nif (be16_to_cpu(cmv->wOffset) != dsc->offset ||\r\nbe16_to_cpu(cmv->wGroup) != dsc->group ||\r\nbe16_to_cpu(cmv->wAddress) != dsc->address)\r\ngoto bad2;\r\nsc->data = be32_to_cpu(cmv->dwData[0]);\r\nsc->data1 = be32_to_cpu(cmv->dwData[1]);\r\nwake_up_cmv_ack(sc);\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn;\r\nbad2:\r\nuea_err(INS_TO_USBDEV(sc), "unexpected cmv received, "\r\n"Function : %d, Subfunction : %d\n",\r\nE4_FUNCTION_TYPE(cmv->wFunction),\r\nE4_FUNCTION_SUBTYPE(cmv->wFunction));\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn;\r\n}\r\nstatic void uea_schedule_load_page_e1(struct uea_softc *sc,\r\nstruct intr_pkt *intr)\r\n{\r\nsc->pageno = intr->e1_bSwapPageNo;\r\nsc->ovl = intr->e1_bOvl >> 4 | intr->e1_bOvl << 4;\r\nschedule_work(&sc->task);\r\n}\r\nstatic void uea_schedule_load_page_e4(struct uea_softc *sc,\r\nstruct intr_pkt *intr)\r\n{\r\nsc->pageno = intr->e4_bSwapPageNo;\r\nschedule_work(&sc->task);\r\n}\r\nstatic void uea_intr(struct urb *urb)\r\n{\r\nstruct uea_softc *sc = urb->context;\r\nstruct intr_pkt *intr = urb->transfer_buffer;\r\nint status = urb->status;\r\nuea_enters(INS_TO_USBDEV(sc));\r\nif (unlikely(status < 0)) {\r\nuea_err(INS_TO_USBDEV(sc), "uea_intr() failed with %d\n",\r\nstatus);\r\nreturn;\r\n}\r\nif (intr->bType != 0x08 || sc->booting) {\r\nuea_err(INS_TO_USBDEV(sc), "wrong interrupt\n");\r\ngoto resubmit;\r\n}\r\nswitch (le16_to_cpu(intr->wInterrupt)) {\r\ncase INT_LOADSWAPPAGE:\r\nsc->schedule_load_page(sc, intr);\r\nbreak;\r\ncase INT_INCOMINGCMV:\r\nsc->dispatch_cmv(sc, intr);\r\nbreak;\r\ndefault:\r\nuea_err(INS_TO_USBDEV(sc), "unknown interrupt %u\n",\r\nle16_to_cpu(intr->wInterrupt));\r\n}\r\nresubmit:\r\nusb_submit_urb(sc->urb_int, GFP_ATOMIC);\r\n}\r\nstatic int uea_boot(struct uea_softc *sc)\r\n{\r\nint ret, size;\r\nstruct intr_pkt *intr;\r\nuea_enters(INS_TO_USBDEV(sc));\r\nif (UEA_CHIP_VERSION(sc) == EAGLE_IV) {\r\nsize = E4_INTR_PKT_SIZE;\r\nsc->dispatch_cmv = uea_dispatch_cmv_e4;\r\nsc->schedule_load_page = uea_schedule_load_page_e4;\r\nsc->stat = uea_stat_e4;\r\nsc->send_cmvs = uea_send_cmvs_e4;\r\nINIT_WORK(&sc->task, uea_load_page_e4);\r\n} else {\r\nsize = E1_INTR_PKT_SIZE;\r\nsc->dispatch_cmv = uea_dispatch_cmv_e1;\r\nsc->schedule_load_page = uea_schedule_load_page_e1;\r\nsc->stat = uea_stat_e1;\r\nsc->send_cmvs = uea_send_cmvs_e1;\r\nINIT_WORK(&sc->task, uea_load_page_e1);\r\n}\r\ninit_waitqueue_head(&sc->sync_q);\r\nif (UEA_CHIP_VERSION(sc) == ADI930)\r\nload_XILINX_firmware(sc);\r\nintr = kmalloc(size, GFP_KERNEL);\r\nif (!intr) {\r\nuea_err(INS_TO_USBDEV(sc),\r\n"cannot allocate interrupt package\n");\r\ngoto err0;\r\n}\r\nsc->urb_int = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!sc->urb_int) {\r\nuea_err(INS_TO_USBDEV(sc), "cannot allocate interrupt URB\n");\r\ngoto err1;\r\n}\r\nusb_fill_int_urb(sc->urb_int, sc->usb_dev,\r\nusb_rcvintpipe(sc->usb_dev, UEA_INTR_PIPE),\r\nintr, size, uea_intr, sc,\r\nsc->usb_dev->actconfig->interface[0]->altsetting[0].\r\nendpoint[0].desc.bInterval);\r\nret = usb_submit_urb(sc->urb_int, GFP_KERNEL);\r\nif (ret < 0) {\r\nuea_err(INS_TO_USBDEV(sc),\r\n"urb submition failed with error %d\n", ret);\r\ngoto err1;\r\n}\r\nsc->kthread = kthread_create(uea_kthread, sc, "ueagle-atm");\r\nif (IS_ERR(sc->kthread)) {\r\nuea_err(INS_TO_USBDEV(sc), "failed to create thread\n");\r\ngoto err2;\r\n}\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn 0;\r\nerr2:\r\nusb_kill_urb(sc->urb_int);\r\nerr1:\r\nusb_free_urb(sc->urb_int);\r\nsc->urb_int = NULL;\r\nkfree(intr);\r\nerr0:\r\nuea_leaves(INS_TO_USBDEV(sc));\r\nreturn -ENOMEM;\r\n}\r\nstatic void uea_stop(struct uea_softc *sc)\r\n{\r\nint ret;\r\nuea_enters(INS_TO_USBDEV(sc));\r\nret = kthread_stop(sc->kthread);\r\nuea_dbg(INS_TO_USBDEV(sc), "kthread finish with status %d\n", ret);\r\nuea_request(sc, UEA_SET_MODE, UEA_LOOPBACK_ON, 0, NULL);\r\nusb_kill_urb(sc->urb_int);\r\nkfree(sc->urb_int->transfer_buffer);\r\nusb_free_urb(sc->urb_int);\r\nflush_work_sync(&sc->task);\r\nrelease_firmware(sc->dsp_firm);\r\nuea_leaves(INS_TO_USBDEV(sc));\r\n}\r\nstatic struct uea_softc *dev_to_uea(struct device *dev)\r\n{\r\nstruct usb_interface *intf;\r\nstruct usbatm_data *usbatm;\r\nintf = to_usb_interface(dev);\r\nif (!intf)\r\nreturn NULL;\r\nusbatm = usb_get_intfdata(intf);\r\nif (!usbatm)\r\nreturn NULL;\r\nreturn usbatm->driver_data;\r\n}\r\nstatic ssize_t read_status(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret = -ENODEV;\r\nstruct uea_softc *sc;\r\nmutex_lock(&uea_mutex);\r\nsc = dev_to_uea(dev);\r\nif (!sc)\r\ngoto out;\r\nret = snprintf(buf, 10, "%08x\n", sc->stats.phy.state);\r\nout:\r\nmutex_unlock(&uea_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t reboot(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret = -ENODEV;\r\nstruct uea_softc *sc;\r\nmutex_lock(&uea_mutex);\r\nsc = dev_to_uea(dev);\r\nif (!sc)\r\ngoto out;\r\nsc->reset = 1;\r\nret = count;\r\nout:\r\nmutex_unlock(&uea_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t read_human_status(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret = -ENODEV;\r\nint modem_state;\r\nstruct uea_softc *sc;\r\nmutex_lock(&uea_mutex);\r\nsc = dev_to_uea(dev);\r\nif (!sc)\r\ngoto out;\r\nif (UEA_CHIP_VERSION(sc) == EAGLE_IV) {\r\nswitch (sc->stats.phy.state) {\r\ncase 0x0:\r\ncase 0x1:\r\ncase 0x3:\r\ncase 0x4:\r\nmodem_state = 0;\r\nbreak;\r\ncase 0x5:\r\ncase 0x6:\r\ncase 0x9:\r\ncase 0xa:\r\nmodem_state = 1;\r\nbreak;\r\ncase 0x7:\r\nmodem_state = 2;\r\nbreak;\r\ncase 0x2:\r\nmodem_state = 3;\r\nbreak;\r\ndefault:\r\nmodem_state = 4;\r\nbreak;\r\n}\r\n} else\r\nmodem_state = GET_STATUS(sc->stats.phy.state);\r\nswitch (modem_state) {\r\ncase 0:\r\nret = sprintf(buf, "Modem is booting\n");\r\nbreak;\r\ncase 1:\r\nret = sprintf(buf, "Modem is initializing\n");\r\nbreak;\r\ncase 2:\r\nret = sprintf(buf, "Modem is operational\n");\r\nbreak;\r\ncase 3:\r\nret = sprintf(buf, "Modem synchronization failed\n");\r\nbreak;\r\ndefault:\r\nret = sprintf(buf, "Modem state is unknown\n");\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&uea_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t read_delin(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret = -ENODEV;\r\nstruct uea_softc *sc;\r\nchar *delin = "GOOD";\r\nmutex_lock(&uea_mutex);\r\nsc = dev_to_uea(dev);\r\nif (!sc)\r\ngoto out;\r\nif (UEA_CHIP_VERSION(sc) == EAGLE_IV) {\r\nif (sc->stats.phy.flags & 0x4000)\r\ndelin = "RESET";\r\nelse if (sc->stats.phy.flags & 0x0001)\r\ndelin = "LOSS";\r\n} else {\r\nif (sc->stats.phy.flags & 0x0C00)\r\ndelin = "ERROR";\r\nelse if (sc->stats.phy.flags & 0x0030)\r\ndelin = "LOSS";\r\n}\r\nret = sprintf(buf, "%s\n", delin);\r\nout:\r\nmutex_unlock(&uea_mutex);\r\nreturn ret;\r\n}\r\nstatic int uea_getesi(struct uea_softc *sc, u_char * esi)\r\n{\r\nunsigned char mac_str[2 * ETH_ALEN + 1];\r\nint i;\r\nif (usb_string\r\n(sc->usb_dev, sc->usb_dev->descriptor.iSerialNumber, mac_str,\r\nsizeof(mac_str)) != 2 * ETH_ALEN)\r\nreturn 1;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nesi[i] = hex_to_bin(mac_str[2 * i]) * 16 +\r\nhex_to_bin(mac_str[2 * i + 1]);\r\nreturn 0;\r\n}\r\nstatic int uea_atm_open(struct usbatm_data *usbatm, struct atm_dev *atm_dev)\r\n{\r\nstruct uea_softc *sc = usbatm->driver_data;\r\nreturn uea_getesi(sc, atm_dev->esi);\r\n}\r\nstatic int uea_heavy(struct usbatm_data *usbatm, struct usb_interface *intf)\r\n{\r\nstruct uea_softc *sc = usbatm->driver_data;\r\nwait_event_interruptible(sc->sync_q, IS_OPERATIONAL(sc));\r\nreturn 0;\r\n}\r\nstatic int claim_interface(struct usb_device *usb_dev,\r\nstruct usbatm_data *usbatm, int ifnum)\r\n{\r\nint ret;\r\nstruct usb_interface *intf = usb_ifnum_to_if(usb_dev, ifnum);\r\nif (!intf) {\r\nuea_err(usb_dev, "interface %d not found\n", ifnum);\r\nreturn -ENODEV;\r\n}\r\nret = usb_driver_claim_interface(&uea_driver, intf, usbatm);\r\nif (ret != 0)\r\nuea_err(usb_dev, "can't claim interface %d, error %d\n", ifnum,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int uea_bind(struct usbatm_data *usbatm, struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usb = interface_to_usbdev(intf);\r\nstruct uea_softc *sc;\r\nint ret, ifnum = intf->altsetting->desc.bInterfaceNumber;\r\nunsigned int alt;\r\nuea_enters(usb);\r\nif (ifnum != UEA_INTR_IFACE_NO)\r\nreturn -ENODEV;\r\nusbatm->flags = (sync_wait[modem_index] ? 0 : UDSL_SKIP_HEAVY_INIT);\r\nret = claim_interface(usb, usbatm, UEA_US_IFACE_NO);\r\nif (ret < 0)\r\nreturn ret;\r\nif (UEA_CHIP_VERSION(id) != ADI930) {\r\nret = claim_interface(usb, usbatm, UEA_DS_IFACE_NO);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nsc = kzalloc(sizeof(struct uea_softc), GFP_KERNEL);\r\nif (!sc) {\r\nuea_err(usb, "uea_init: not enough memory !\n");\r\nreturn -ENOMEM;\r\n}\r\nsc->usb_dev = usb;\r\nusbatm->driver_data = sc;\r\nsc->usbatm = usbatm;\r\nsc->modem_index = (modem_index < NB_MODEM) ? modem_index++ : 0;\r\nsc->driver_info = id->driver_info;\r\nif (annex[sc->modem_index] == 1)\r\nsc->annex = ANNEXA;\r\nelse if (annex[sc->modem_index] == 2)\r\nsc->annex = ANNEXB;\r\nelse if (sc->driver_info & AUTO_ANNEX_A)\r\nsc->annex = ANNEXA;\r\nelse if (sc->driver_info & AUTO_ANNEX_B)\r\nsc->annex = ANNEXB;\r\nelse\r\nsc->annex = (le16_to_cpu\r\n(sc->usb_dev->descriptor.bcdDevice) & 0x80) ? ANNEXB : ANNEXA;\r\nalt = altsetting[sc->modem_index];\r\nif (UEA_CHIP_VERSION(id) != ADI930 && alt > 0) {\r\nif (alt <= 8 &&\r\nusb_set_interface(usb, UEA_DS_IFACE_NO, alt) == 0) {\r\nuea_dbg(usb, "set alternate %u for 2 interface\n", alt);\r\nuea_info(usb, "using iso mode\n");\r\nusbatm->flags |= UDSL_USE_ISOC | UDSL_IGNORE_EILSEQ;\r\n} else {\r\nuea_err(usb, "setting alternate %u failed for "\r\n"2 interface, using bulk mode\n", alt);\r\n}\r\n}\r\nret = sysfs_create_group(&intf->dev.kobj, &attr_grp);\r\nif (ret < 0)\r\ngoto error;\r\nret = uea_boot(sc);\r\nif (ret < 0)\r\ngoto error_rm_grp;\r\nreturn 0;\r\nerror_rm_grp:\r\nsysfs_remove_group(&intf->dev.kobj, &attr_grp);\r\nerror:\r\nkfree(sc);\r\nreturn ret;\r\n}\r\nstatic void uea_unbind(struct usbatm_data *usbatm, struct usb_interface *intf)\r\n{\r\nstruct uea_softc *sc = usbatm->driver_data;\r\nsysfs_remove_group(&intf->dev.kobj, &attr_grp);\r\nuea_stop(sc);\r\nkfree(sc);\r\n}\r\nstatic int uea_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *usb = interface_to_usbdev(intf);\r\nint ret;\r\nuea_enters(usb);\r\nuea_info(usb, "ADSL device founded vid (%#X) pid (%#X) Rev (%#X): %s\n",\r\nle16_to_cpu(usb->descriptor.idVendor),\r\nle16_to_cpu(usb->descriptor.idProduct),\r\nle16_to_cpu(usb->descriptor.bcdDevice),\r\nchip_name[UEA_CHIP_VERSION(id)]);\r\nusb_reset_device(usb);\r\nif (UEA_IS_PREFIRM(id))\r\nreturn uea_load_firmware(usb, UEA_CHIP_VERSION(id));\r\nret = usbatm_usb_probe(intf, id, &uea_usbatm_driver);\r\nif (ret == 0) {\r\nstruct usbatm_data *usbatm = usb_get_intfdata(intf);\r\nstruct uea_softc *sc = usbatm->driver_data;\r\nUPDATE_ATM_SIGNAL(ATM_PHY_SIG_LOST);\r\nwake_up_process(sc->kthread);\r\n}\r\nreturn ret;\r\n}\r\nstatic void uea_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usb_device *usb = interface_to_usbdev(intf);\r\nint ifnum = intf->altsetting->desc.bInterfaceNumber;\r\nuea_enters(usb);\r\nif (usb->config->desc.bNumInterfaces != 1 && ifnum == 0) {\r\nmutex_lock(&uea_mutex);\r\nusbatm_usb_disconnect(intf);\r\nmutex_unlock(&uea_mutex);\r\nuea_info(usb, "ADSL device removed\n");\r\n}\r\nuea_leaves(usb);\r\n}
