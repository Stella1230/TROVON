int rxrpc_queue_rcv_skb(struct rxrpc_call *call, struct sk_buff *skb,\r\nbool force, bool terminal)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nstruct rxrpc_sock *rx = call->socket;\r\nstruct sock *sk;\r\nint skb_len, ret;\r\n_enter(",,%d,%d", force, terminal);\r\nASSERT(!irqs_disabled());\r\nsp = rxrpc_skb(skb);\r\nASSERTCMP(sp->call, ==, call);\r\nif (test_bit(RXRPC_CALL_TERMINAL_MSG, &call->flags)) {\r\n_debug("already terminated");\r\nASSERTCMP(call->state, >=, RXRPC_CALL_COMPLETE);\r\nskb->destructor = NULL;\r\nsp->call = NULL;\r\nrxrpc_put_call(call);\r\nrxrpc_free_skb(skb);\r\nreturn 0;\r\n}\r\nsk = &rx->sk;\r\nif (!force) {\r\nret = sk_filter(sk, skb);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nspin_lock_bh(&sk->sk_receive_queue.lock);\r\nif (!test_bit(RXRPC_CALL_TERMINAL_MSG, &call->flags) &&\r\n!test_bit(RXRPC_CALL_RELEASED, &call->flags) &&\r\ncall->socket->sk.sk_state != RXRPC_CLOSE) {\r\nskb->destructor = rxrpc_packet_destructor;\r\nskb->dev = NULL;\r\nskb->sk = sk;\r\natomic_add(skb->truesize, &sk->sk_rmem_alloc);\r\nif (terminal) {\r\n_debug("<<<< TERMINAL MESSAGE >>>>");\r\nset_bit(RXRPC_CALL_TERMINAL_MSG, &call->flags);\r\n}\r\nif (rx->interceptor) {\r\nrx->interceptor(sk, call->user_call_ID, skb);\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\n} else {\r\nskb_len = skb->len;\r\n_net("post skb %p", skb);\r\n__skb_queue_tail(&sk->sk_receive_queue, skb);\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk, skb_len);\r\n}\r\nskb = NULL;\r\n} else {\r\nspin_unlock_bh(&sk->sk_receive_queue.lock);\r\n}\r\nret = 0;\r\nout:\r\nif (skb) {\r\nskb->destructor = NULL;\r\nsp->call = NULL;\r\nrxrpc_put_call(call);\r\nrxrpc_free_skb(skb);\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_fast_process_data(struct rxrpc_call *call,\r\nstruct sk_buff *skb, u32 seq)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nbool terminal;\r\nint ret, ackbit, ack;\r\n_enter("{%u,%u},,{%u}", call->rx_data_post, call->rx_first_oos, seq);\r\nsp = rxrpc_skb(skb);\r\nASSERTCMP(sp->call, ==, NULL);\r\nspin_lock(&call->lock);\r\nif (call->state > RXRPC_CALL_COMPLETE)\r\ngoto discard;\r\nASSERTCMP(call->rx_data_expect, >=, call->rx_data_post);\r\nASSERTCMP(call->rx_data_post, >=, call->rx_data_recv);\r\nASSERTCMP(call->rx_data_recv, >=, call->rx_data_eaten);\r\nif (seq < call->rx_data_post) {\r\n_debug("dup #%u [-%u]", seq, call->rx_data_post);\r\nack = RXRPC_ACK_DUPLICATE;\r\nret = -ENOBUFS;\r\ngoto discard_and_ack;\r\n}\r\nackbit = seq - (call->rx_data_eaten + 1);\r\nASSERTCMP(ackbit, >=, 0);\r\nif (__test_and_set_bit(ackbit, call->ackr_window)) {\r\n_debug("dup oos #%u [%u,%u]",\r\nseq, call->rx_data_eaten, call->rx_data_post);\r\nack = RXRPC_ACK_DUPLICATE;\r\ngoto discard_and_ack;\r\n}\r\nif (seq >= call->ackr_win_top) {\r\n_debug("exceed #%u [%u]", seq, call->ackr_win_top);\r\n__clear_bit(ackbit, call->ackr_window);\r\nack = RXRPC_ACK_EXCEEDS_WINDOW;\r\ngoto discard_and_ack;\r\n}\r\nif (seq == call->rx_data_expect) {\r\nclear_bit(RXRPC_CALL_EXPECT_OOS, &call->flags);\r\ncall->rx_data_expect++;\r\n} else if (seq > call->rx_data_expect) {\r\n_debug("oos #%u [%u]", seq, call->rx_data_expect);\r\ncall->rx_data_expect = seq + 1;\r\nif (test_and_set_bit(RXRPC_CALL_EXPECT_OOS, &call->flags)) {\r\nack = RXRPC_ACK_OUT_OF_SEQUENCE;\r\ngoto enqueue_and_ack;\r\n}\r\ngoto enqueue_packet;\r\n}\r\nif (seq != call->rx_data_post) {\r\n_debug("ahead #%u [%u]", seq, call->rx_data_post);\r\ngoto enqueue_packet;\r\n}\r\nif (test_bit(RXRPC_CALL_RCVD_LAST, &call->flags))\r\ngoto protocol_error;\r\nif (call->conn->security)\r\ngoto enqueue_packet;\r\nsp->call = call;\r\nrxrpc_get_call(call);\r\nterminal = ((sp->hdr.flags & RXRPC_LAST_PACKET) &&\r\n!(sp->hdr.flags & RXRPC_CLIENT_INITIATED));\r\nret = rxrpc_queue_rcv_skb(call, skb, false, terminal);\r\nif (ret < 0) {\r\nif (ret == -ENOMEM || ret == -ENOBUFS) {\r\n__clear_bit(ackbit, call->ackr_window);\r\nack = RXRPC_ACK_NOSPACE;\r\ngoto discard_and_ack;\r\n}\r\ngoto out;\r\n}\r\nskb = NULL;\r\n_debug("post #%u", seq);\r\nASSERTCMP(call->rx_data_post, ==, seq);\r\ncall->rx_data_post++;\r\nif (sp->hdr.flags & RXRPC_LAST_PACKET)\r\nset_bit(RXRPC_CALL_RCVD_LAST, &call->flags);\r\nif (call->rx_data_post == call->rx_first_oos) {\r\n_debug("drain rx oos now");\r\nread_lock(&call->state_lock);\r\nif (call->state < RXRPC_CALL_COMPLETE &&\r\n!test_and_set_bit(RXRPC_CALL_DRAIN_RX_OOS, &call->events))\r\nrxrpc_queue_call(call);\r\nread_unlock(&call->state_lock);\r\n}\r\nspin_unlock(&call->lock);\r\natomic_inc(&call->ackr_not_idle);\r\nrxrpc_propose_ACK(call, RXRPC_ACK_DELAY, sp->hdr.serial, false);\r\n_leave(" = 0 [posted]");\r\nreturn 0;\r\nprotocol_error:\r\nret = -EBADMSG;\r\nout:\r\nspin_unlock(&call->lock);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\ndiscard_and_ack:\r\n_debug("discard and ACK packet %p", skb);\r\n__rxrpc_propose_ACK(call, ack, sp->hdr.serial, true);\r\ndiscard:\r\nspin_unlock(&call->lock);\r\nrxrpc_free_skb(skb);\r\n_leave(" = 0 [discarded]");\r\nreturn 0;\r\nenqueue_and_ack:\r\n__rxrpc_propose_ACK(call, ack, sp->hdr.serial, true);\r\nenqueue_packet:\r\n_net("defer skb %p", skb);\r\nspin_unlock(&call->lock);\r\nskb_queue_tail(&call->rx_queue, skb);\r\natomic_inc(&call->ackr_not_idle);\r\nread_lock(&call->state_lock);\r\nif (call->state < RXRPC_CALL_DEAD)\r\nrxrpc_queue_call(call);\r\nread_unlock(&call->state_lock);\r\n_leave(" = 0 [queued]");\r\nreturn 0;\r\n}\r\nstatic void rxrpc_assume_implicit_ackall(struct rxrpc_call *call, u32 serial)\r\n{\r\nwrite_lock_bh(&call->state_lock);\r\nswitch (call->state) {\r\ncase RXRPC_CALL_CLIENT_AWAIT_REPLY:\r\ncall->state = RXRPC_CALL_CLIENT_RECV_REPLY;\r\ncall->acks_latest = serial;\r\n_debug("implicit ACKALL %%%u", call->acks_latest);\r\nset_bit(RXRPC_CALL_RCVD_ACKALL, &call->events);\r\nwrite_unlock_bh(&call->state_lock);\r\nif (try_to_del_timer_sync(&call->resend_timer) >= 0) {\r\nclear_bit(RXRPC_CALL_RESEND_TIMER, &call->events);\r\nclear_bit(RXRPC_CALL_RESEND, &call->events);\r\nclear_bit(RXRPC_CALL_RUN_RTIMER, &call->flags);\r\n}\r\nbreak;\r\ndefault:\r\nwrite_unlock_bh(&call->state_lock);\r\nbreak;\r\n}\r\n}\r\nvoid rxrpc_fast_process_packet(struct rxrpc_call *call, struct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\n__be32 _abort_code;\r\nu32 serial, hi_serial, seq, abort_code;\r\n_enter("%p,%p", call, skb);\r\nASSERT(!irqs_disabled());\r\n#if 0\r\nif (sp->hdr.type == RXRPC_PACKET_TYPE_DATA) {\r\nstatic int skip = 0;\r\nif (++skip == 3) {\r\nprintk("DROPPED 3RD PACKET!!!!!!!!!!!!!\n");\r\nskip = 0;\r\ngoto free_packet;\r\n}\r\n}\r\n#endif\r\nserial = ntohl(sp->hdr.serial);\r\nhi_serial = atomic_read(&call->conn->hi_serial);\r\nwhile (serial > hi_serial)\r\nhi_serial = atomic_cmpxchg(&call->conn->hi_serial, hi_serial,\r\nserial);\r\nif (sp->hdr.flags & RXRPC_REQUEST_ACK) {\r\n_proto("ACK Requested on %%%u", serial);\r\nrxrpc_propose_ACK(call, RXRPC_ACK_REQUESTED, sp->hdr.serial,\r\n!(sp->hdr.flags & RXRPC_MORE_PACKETS));\r\n}\r\nswitch (sp->hdr.type) {\r\ncase RXRPC_PACKET_TYPE_ABORT:\r\n_debug("abort");\r\nif (skb_copy_bits(skb, 0, &_abort_code,\r\nsizeof(_abort_code)) < 0)\r\ngoto protocol_error;\r\nabort_code = ntohl(_abort_code);\r\n_proto("Rx ABORT %%%u { %x }", serial, abort_code);\r\nwrite_lock_bh(&call->state_lock);\r\nif (call->state < RXRPC_CALL_COMPLETE) {\r\ncall->state = RXRPC_CALL_REMOTELY_ABORTED;\r\ncall->abort_code = abort_code;\r\nset_bit(RXRPC_CALL_RCVD_ABORT, &call->events);\r\nrxrpc_queue_call(call);\r\n}\r\ngoto free_packet_unlock;\r\ncase RXRPC_PACKET_TYPE_BUSY:\r\n_proto("Rx BUSY %%%u", serial);\r\nif (call->conn->out_clientflag)\r\ngoto protocol_error;\r\nwrite_lock_bh(&call->state_lock);\r\nswitch (call->state) {\r\ncase RXRPC_CALL_CLIENT_SEND_REQUEST:\r\ncall->state = RXRPC_CALL_SERVER_BUSY;\r\nset_bit(RXRPC_CALL_RCVD_BUSY, &call->events);\r\nrxrpc_queue_call(call);\r\ncase RXRPC_CALL_SERVER_BUSY:\r\ngoto free_packet_unlock;\r\ndefault:\r\ngoto protocol_error_locked;\r\n}\r\ndefault:\r\n_proto("Rx %s %%%u", rxrpc_pkts[sp->hdr.type], serial);\r\ngoto protocol_error;\r\ncase RXRPC_PACKET_TYPE_DATA:\r\nseq = ntohl(sp->hdr.seq);\r\n_proto("Rx DATA %%%u { #%u }", serial, seq);\r\nif (seq == 0)\r\ngoto protocol_error;\r\ncall->ackr_prev_seq = sp->hdr.seq;\r\nif (call->state == RXRPC_CALL_CLIENT_AWAIT_REPLY)\r\nrxrpc_assume_implicit_ackall(call, serial);\r\nswitch (rxrpc_fast_process_data(call, skb, seq)) {\r\ncase 0:\r\nskb = NULL;\r\ngoto done;\r\ndefault:\r\nBUG();\r\ncase -EBADMSG:\r\ngoto protocol_error;\r\n}\r\ncase RXRPC_PACKET_TYPE_ACKALL:\r\ncase RXRPC_PACKET_TYPE_ACK:\r\nread_lock_bh(&call->state_lock);\r\nif (call->state < RXRPC_CALL_DEAD) {\r\nskb_queue_tail(&call->rx_queue, skb);\r\nrxrpc_queue_call(call);\r\nskb = NULL;\r\n}\r\nread_unlock_bh(&call->state_lock);\r\ngoto free_packet;\r\n}\r\nprotocol_error:\r\n_debug("protocol error");\r\nwrite_lock_bh(&call->state_lock);\r\nprotocol_error_locked:\r\nif (call->state <= RXRPC_CALL_COMPLETE) {\r\ncall->state = RXRPC_CALL_LOCALLY_ABORTED;\r\ncall->abort_code = RX_PROTOCOL_ERROR;\r\nset_bit(RXRPC_CALL_ABORT, &call->events);\r\nrxrpc_queue_call(call);\r\n}\r\nfree_packet_unlock:\r\nwrite_unlock_bh(&call->state_lock);\r\nfree_packet:\r\nrxrpc_free_skb(skb);\r\ndone:\r\n_leave("");\r\n}\r\nstatic void rxrpc_process_jumbo_packet(struct rxrpc_call *call,\r\nstruct sk_buff *jumbo)\r\n{\r\nstruct rxrpc_jumbo_header jhdr;\r\nstruct rxrpc_skb_priv *sp;\r\nstruct sk_buff *part;\r\n_enter(",{%u,%u}", jumbo->data_len, jumbo->len);\r\nsp = rxrpc_skb(jumbo);\r\ndo {\r\nsp->hdr.flags &= ~RXRPC_JUMBO_PACKET;\r\npart = skb_clone(jumbo, GFP_ATOMIC);\r\nif (!part) {\r\npskb_trim(jumbo, RXRPC_JUMBO_DATALEN);\r\nbreak;\r\n}\r\nrxrpc_new_skb(part);\r\npskb_trim(part, RXRPC_JUMBO_DATALEN);\r\nif (!pskb_pull(jumbo, RXRPC_JUMBO_DATALEN))\r\ngoto protocol_error;\r\nif (skb_copy_bits(jumbo, 0, &jhdr, sizeof(jhdr)) < 0)\r\ngoto protocol_error;\r\nif (!pskb_pull(jumbo, sizeof(jhdr)))\r\nBUG();\r\nsp->hdr.seq = htonl(ntohl(sp->hdr.seq) + 1);\r\nsp->hdr.serial = htonl(ntohl(sp->hdr.serial) + 1);\r\nsp->hdr.flags = jhdr.flags;\r\nsp->hdr._rsvd = jhdr._rsvd;\r\n_proto("Rx DATA Jumbo %%%u", ntohl(sp->hdr.serial) - 1);\r\nrxrpc_fast_process_packet(call, part);\r\npart = NULL;\r\n} while (sp->hdr.flags & RXRPC_JUMBO_PACKET);\r\nrxrpc_fast_process_packet(call, jumbo);\r\n_leave("");\r\nreturn;\r\nprotocol_error:\r\n_debug("protocol error");\r\nrxrpc_free_skb(part);\r\nrxrpc_free_skb(jumbo);\r\nwrite_lock_bh(&call->state_lock);\r\nif (call->state <= RXRPC_CALL_COMPLETE) {\r\ncall->state = RXRPC_CALL_LOCALLY_ABORTED;\r\ncall->abort_code = RX_PROTOCOL_ERROR;\r\nset_bit(RXRPC_CALL_ABORT, &call->events);\r\nrxrpc_queue_call(call);\r\n}\r\nwrite_unlock_bh(&call->state_lock);\r\n_leave("");\r\n}\r\nstatic void rxrpc_post_packet_to_call(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nstruct rxrpc_call *call;\r\nstruct rb_node *p;\r\n__be32 call_id;\r\n_enter("%p,%p", conn, skb);\r\nread_lock_bh(&conn->lock);\r\nsp = rxrpc_skb(skb);\r\ncall = conn->channels[ntohl(sp->hdr.cid) & RXRPC_CHANNELMASK];\r\nif (!call || call->call_id != sp->hdr.callNumber)\r\ngoto call_not_extant;\r\n_debug("extant call [%d]", call->state);\r\nASSERTCMP(call->conn, ==, conn);\r\nread_lock(&call->state_lock);\r\nswitch (call->state) {\r\ncase RXRPC_CALL_LOCALLY_ABORTED:\r\nif (!test_and_set_bit(RXRPC_CALL_ABORT, &call->events))\r\nrxrpc_queue_call(call);\r\ncase RXRPC_CALL_REMOTELY_ABORTED:\r\ncase RXRPC_CALL_NETWORK_ERROR:\r\ncase RXRPC_CALL_DEAD:\r\ngoto free_unlock;\r\ndefault:\r\nbreak;\r\n}\r\nread_unlock(&call->state_lock);\r\nrxrpc_get_call(call);\r\nread_unlock_bh(&conn->lock);\r\nif (sp->hdr.type == RXRPC_PACKET_TYPE_DATA &&\r\nsp->hdr.flags & RXRPC_JUMBO_PACKET)\r\nrxrpc_process_jumbo_packet(call, skb);\r\nelse\r\nrxrpc_fast_process_packet(call, skb);\r\nrxrpc_put_call(call);\r\ngoto done;\r\ncall_not_extant:\r\n_debug("call not extant");\r\ncall_id = sp->hdr.callNumber;\r\np = conn->calls.rb_node;\r\nwhile (p) {\r\ncall = rb_entry(p, struct rxrpc_call, conn_node);\r\nif (call_id < call->call_id)\r\np = p->rb_left;\r\nelse if (call_id > call->call_id)\r\np = p->rb_right;\r\nelse\r\ngoto found_completed_call;\r\n}\r\ndead_call:\r\nread_unlock_bh(&conn->lock);\r\nif (sp->hdr.flags & RXRPC_CLIENT_INITIATED &&\r\nsp->hdr.seq == cpu_to_be32(1)) {\r\n_debug("incoming call");\r\nskb_queue_tail(&conn->trans->local->accept_queue, skb);\r\nrxrpc_queue_work(&conn->trans->local->acceptor);\r\ngoto done;\r\n}\r\n_debug("dead call");\r\nskb->priority = RX_CALL_DEAD;\r\nrxrpc_reject_packet(conn->trans->local, skb);\r\ngoto done;\r\nfound_completed_call:\r\n_debug("completed call");\r\nif (atomic_read(&call->usage) == 0)\r\ngoto dead_call;\r\nread_lock(&call->state_lock);\r\nASSERTIFCMP(call->state != RXRPC_CALL_CLIENT_FINAL_ACK,\r\ncall->state, >=, RXRPC_CALL_COMPLETE);\r\nif (call->state == RXRPC_CALL_LOCALLY_ABORTED ||\r\ncall->state == RXRPC_CALL_REMOTELY_ABORTED ||\r\ncall->state == RXRPC_CALL_DEAD) {\r\nread_unlock(&call->state_lock);\r\ngoto dead_call;\r\n}\r\nif (call->conn->in_clientflag) {\r\nread_unlock(&call->state_lock);\r\ngoto dead_call;\r\n}\r\n_debug("final ack again");\r\nrxrpc_get_call(call);\r\nset_bit(RXRPC_CALL_ACK_FINAL, &call->events);\r\nrxrpc_queue_call(call);\r\nfree_unlock:\r\nread_unlock(&call->state_lock);\r\nread_unlock_bh(&conn->lock);\r\nrxrpc_free_skb(skb);\r\ndone:\r\n_leave("");\r\n}\r\nstatic void rxrpc_post_packet_to_conn(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb)\r\n{\r\n_enter("%p,%p", conn, skb);\r\natomic_inc(&conn->usage);\r\nskb_queue_tail(&conn->rx_queue, skb);\r\nrxrpc_queue_conn(conn);\r\n}\r\nvoid rxrpc_data_ready(struct sock *sk, int count)\r\n{\r\nstruct rxrpc_connection *conn;\r\nstruct rxrpc_transport *trans;\r\nstruct rxrpc_skb_priv *sp;\r\nstruct rxrpc_local *local;\r\nstruct rxrpc_peer *peer;\r\nstruct sk_buff *skb;\r\nint ret;\r\n_enter("%p, %d", sk, count);\r\nASSERT(!irqs_disabled());\r\nread_lock_bh(&rxrpc_local_lock);\r\nlocal = sk->sk_user_data;\r\nif (local && atomic_read(&local->usage) > 0)\r\nrxrpc_get_local(local);\r\nelse\r\nlocal = NULL;\r\nread_unlock_bh(&rxrpc_local_lock);\r\nif (!local) {\r\n_leave(" [local dead]");\r\nreturn;\r\n}\r\nskb = skb_recv_datagram(sk, 0, 1, &ret);\r\nif (!skb) {\r\nrxrpc_put_local(local);\r\nif (ret == -EAGAIN)\r\nreturn;\r\n_debug("UDP socket error %d", ret);\r\nreturn;\r\n}\r\nrxrpc_new_skb(skb);\r\n_net("recv skb %p", skb);\r\nif (skb_checksum_complete(skb)) {\r\nrxrpc_free_skb(skb);\r\nrxrpc_put_local(local);\r\nUDP_INC_STATS_BH(&init_net, UDP_MIB_INERRORS, 0);\r\n_leave(" [CSUM failed]");\r\nreturn;\r\n}\r\nUDP_INC_STATS_BH(&init_net, UDP_MIB_INDATAGRAMS, 0);\r\nskb_orphan(skb);\r\nsp = rxrpc_skb(skb);\r\nmemset(sp, 0, sizeof(*sp));\r\n_net("Rx UDP packet from %08x:%04hu",\r\nntohl(ip_hdr(skb)->saddr), ntohs(udp_hdr(skb)->source));\r\nif (skb_copy_bits(skb, sizeof(struct udphdr), &sp->hdr,\r\nsizeof(sp->hdr)) < 0)\r\ngoto bad_message;\r\nif (!pskb_pull(skb, sizeof(struct udphdr) + sizeof(sp->hdr)))\r\nBUG();\r\n_net("Rx RxRPC %s ep=%x call=%x:%x",\r\nsp->hdr.flags & RXRPC_CLIENT_INITIATED ? "ToServer" : "ToClient",\r\nntohl(sp->hdr.epoch),\r\nntohl(sp->hdr.cid),\r\nntohl(sp->hdr.callNumber));\r\nif (sp->hdr.type == 0 || sp->hdr.type >= RXRPC_N_PACKET_TYPES) {\r\n_proto("Rx Bad Packet Type %u", sp->hdr.type);\r\ngoto bad_message;\r\n}\r\nif (sp->hdr.type == RXRPC_PACKET_TYPE_DATA &&\r\n(sp->hdr.callNumber == 0 || sp->hdr.seq == 0))\r\ngoto bad_message;\r\npeer = rxrpc_find_peer(local, ip_hdr(skb)->saddr, udp_hdr(skb)->source);\r\nif (IS_ERR(peer))\r\ngoto cant_route_call;\r\ntrans = rxrpc_find_transport(local, peer);\r\nrxrpc_put_peer(peer);\r\nif (!trans)\r\ngoto cant_route_call;\r\nconn = rxrpc_find_connection(trans, &sp->hdr);\r\nrxrpc_put_transport(trans);\r\nif (!conn)\r\ngoto cant_route_call;\r\n_debug("CONN %p {%d}", conn, conn->debug_id);\r\nif (sp->hdr.callNumber == 0)\r\nrxrpc_post_packet_to_conn(conn, skb);\r\nelse\r\nrxrpc_post_packet_to_call(conn, skb);\r\nrxrpc_put_connection(conn);\r\nrxrpc_put_local(local);\r\nreturn;\r\ncant_route_call:\r\n_debug("can't route call");\r\nif (sp->hdr.flags & RXRPC_CLIENT_INITIATED &&\r\nsp->hdr.type == RXRPC_PACKET_TYPE_DATA) {\r\nif (sp->hdr.seq == cpu_to_be32(1)) {\r\n_debug("first packet");\r\nskb_queue_tail(&local->accept_queue, skb);\r\nrxrpc_queue_work(&local->acceptor);\r\nrxrpc_put_local(local);\r\n_leave(" [incoming]");\r\nreturn;\r\n}\r\nskb->priority = RX_INVALID_OPERATION;\r\n} else {\r\nskb->priority = RX_CALL_DEAD;\r\n}\r\n_debug("reject");\r\nrxrpc_reject_packet(local, skb);\r\nrxrpc_put_local(local);\r\n_leave(" [no call]");\r\nreturn;\r\nbad_message:\r\nskb->priority = RX_PROTOCOL_ERROR;\r\nrxrpc_reject_packet(local, skb);\r\nrxrpc_put_local(local);\r\n_leave(" [badmsg]");\r\n}
