int uwb_rsv_reason_code(struct uwb_rsv *rsv)\r\n{\r\nstatic const int reason_codes[] = {\r\n[UWB_RSV_STATE_O_INITIATED] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_O_PENDING] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_O_MODIFIED] = UWB_DRP_REASON_MODIFIED,\r\n[UWB_RSV_STATE_O_ESTABLISHED] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_O_TO_BE_MOVED] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_O_MOVE_COMBINING] = UWB_DRP_REASON_MODIFIED,\r\n[UWB_RSV_STATE_O_MOVE_REDUCING] = UWB_DRP_REASON_MODIFIED,\r\n[UWB_RSV_STATE_O_MOVE_EXPANDING] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_T_ACCEPTED] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_T_CONFLICT] = UWB_DRP_REASON_CONFLICT,\r\n[UWB_RSV_STATE_T_PENDING] = UWB_DRP_REASON_PENDING,\r\n[UWB_RSV_STATE_T_DENIED] = UWB_DRP_REASON_DENIED,\r\n[UWB_RSV_STATE_T_RESIZED] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_T_EXPANDING_ACCEPTED] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_T_EXPANDING_CONFLICT] = UWB_DRP_REASON_CONFLICT,\r\n[UWB_RSV_STATE_T_EXPANDING_PENDING] = UWB_DRP_REASON_PENDING,\r\n[UWB_RSV_STATE_T_EXPANDING_DENIED] = UWB_DRP_REASON_DENIED,\r\n};\r\nreturn reason_codes[rsv->state];\r\n}\r\nint uwb_rsv_companion_reason_code(struct uwb_rsv *rsv)\r\n{\r\nstatic const int companion_reason_codes[] = {\r\n[UWB_RSV_STATE_O_MOVE_EXPANDING] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_T_EXPANDING_ACCEPTED] = UWB_DRP_REASON_ACCEPTED,\r\n[UWB_RSV_STATE_T_EXPANDING_CONFLICT] = UWB_DRP_REASON_CONFLICT,\r\n[UWB_RSV_STATE_T_EXPANDING_PENDING] = UWB_DRP_REASON_PENDING,\r\n[UWB_RSV_STATE_T_EXPANDING_DENIED] = UWB_DRP_REASON_DENIED,\r\n};\r\nreturn companion_reason_codes[rsv->state];\r\n}\r\nint uwb_rsv_status(struct uwb_rsv *rsv)\r\n{\r\nstatic const int statuses[] = {\r\n[UWB_RSV_STATE_O_INITIATED] = 0,\r\n[UWB_RSV_STATE_O_PENDING] = 0,\r\n[UWB_RSV_STATE_O_MODIFIED] = 1,\r\n[UWB_RSV_STATE_O_ESTABLISHED] = 1,\r\n[UWB_RSV_STATE_O_TO_BE_MOVED] = 0,\r\n[UWB_RSV_STATE_O_MOVE_COMBINING] = 1,\r\n[UWB_RSV_STATE_O_MOVE_REDUCING] = 1,\r\n[UWB_RSV_STATE_O_MOVE_EXPANDING] = 1,\r\n[UWB_RSV_STATE_T_ACCEPTED] = 1,\r\n[UWB_RSV_STATE_T_CONFLICT] = 0,\r\n[UWB_RSV_STATE_T_PENDING] = 0,\r\n[UWB_RSV_STATE_T_DENIED] = 0,\r\n[UWB_RSV_STATE_T_RESIZED] = 1,\r\n[UWB_RSV_STATE_T_EXPANDING_ACCEPTED] = 1,\r\n[UWB_RSV_STATE_T_EXPANDING_CONFLICT] = 1,\r\n[UWB_RSV_STATE_T_EXPANDING_PENDING] = 1,\r\n[UWB_RSV_STATE_T_EXPANDING_DENIED] = 1,\r\n};\r\nreturn statuses[rsv->state];\r\n}\r\nint uwb_rsv_companion_status(struct uwb_rsv *rsv)\r\n{\r\nstatic const int companion_statuses[] = {\r\n[UWB_RSV_STATE_O_MOVE_EXPANDING] = 0,\r\n[UWB_RSV_STATE_T_EXPANDING_ACCEPTED] = 1,\r\n[UWB_RSV_STATE_T_EXPANDING_CONFLICT] = 0,\r\n[UWB_RSV_STATE_T_EXPANDING_PENDING] = 0,\r\n[UWB_RSV_STATE_T_EXPANDING_DENIED] = 0,\r\n};\r\nreturn companion_statuses[rsv->state];\r\n}\r\nstatic struct uwb_ie_drp *uwb_drp_ie_alloc(void)\r\n{\r\nstruct uwb_ie_drp *drp_ie;\r\ndrp_ie = kzalloc(sizeof(struct uwb_ie_drp) +\r\nUWB_NUM_ZONES * sizeof(struct uwb_drp_alloc),\r\nGFP_KERNEL);\r\nif (drp_ie) {\r\ndrp_ie->hdr.element_id = UWB_IE_DRP;\r\n}\r\nreturn drp_ie;\r\n}\r\nstatic void uwb_drp_ie_from_bm(struct uwb_ie_drp *drp_ie,\r\nstruct uwb_mas_bm *mas)\r\n{\r\nint z, i, num_fields = 0, next = 0;\r\nstruct uwb_drp_alloc *zones;\r\n__le16 current_bmp;\r\nDECLARE_BITMAP(tmp_bmp, UWB_NUM_MAS);\r\nDECLARE_BITMAP(tmp_mas_bm, UWB_MAS_PER_ZONE);\r\nzones = drp_ie->allocs;\r\nbitmap_copy(tmp_bmp, mas->bm, UWB_NUM_MAS);\r\nfor (z = 0; z < UWB_NUM_ZONES; z++) {\r\nbitmap_copy(tmp_mas_bm, tmp_bmp, UWB_MAS_PER_ZONE);\r\nif (bitmap_weight(tmp_mas_bm, UWB_MAS_PER_ZONE) > 0) {\r\nbool found = false;\r\ncurrent_bmp = (__le16) *tmp_mas_bm;\r\nfor (i = 0; i < next; i++) {\r\nif (current_bmp == zones[i].mas_bm) {\r\nzones[i].zone_bm |= 1 << z;\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nnum_fields++;\r\nzones[next].zone_bm = 1 << z;\r\nzones[next].mas_bm = current_bmp;\r\nnext++;\r\n}\r\n}\r\nbitmap_shift_right(tmp_bmp, tmp_bmp, UWB_MAS_PER_ZONE, UWB_NUM_MAS);\r\n}\r\nfor (i = 0; i < num_fields; i++) {\r\ndrp_ie->allocs[i].zone_bm = cpu_to_le16(zones[i].zone_bm);\r\ndrp_ie->allocs[i].mas_bm = cpu_to_le16(zones[i].mas_bm);\r\n}\r\ndrp_ie->hdr.length = sizeof(struct uwb_ie_drp) - sizeof(struct uwb_ie_hdr)\r\n+ num_fields * sizeof(struct uwb_drp_alloc);\r\n}\r\nint uwb_drp_ie_update(struct uwb_rsv *rsv)\r\n{\r\nstruct uwb_ie_drp *drp_ie;\r\nstruct uwb_rsv_move *mv;\r\nint unsafe;\r\nif (rsv->state == UWB_RSV_STATE_NONE) {\r\nkfree(rsv->drp_ie);\r\nrsv->drp_ie = NULL;\r\nreturn 0;\r\n}\r\nunsafe = rsv->mas.unsafe ? 1 : 0;\r\nif (rsv->drp_ie == NULL) {\r\nrsv->drp_ie = uwb_drp_ie_alloc();\r\nif (rsv->drp_ie == NULL)\r\nreturn -ENOMEM;\r\n}\r\ndrp_ie = rsv->drp_ie;\r\nuwb_ie_drp_set_unsafe(drp_ie, unsafe);\r\nuwb_ie_drp_set_tiebreaker(drp_ie, rsv->tiebreaker);\r\nuwb_ie_drp_set_owner(drp_ie, uwb_rsv_is_owner(rsv));\r\nuwb_ie_drp_set_status(drp_ie, uwb_rsv_status(rsv));\r\nuwb_ie_drp_set_reason_code(drp_ie, uwb_rsv_reason_code(rsv));\r\nuwb_ie_drp_set_stream_index(drp_ie, rsv->stream);\r\nuwb_ie_drp_set_type(drp_ie, rsv->type);\r\nif (uwb_rsv_is_owner(rsv)) {\r\nswitch (rsv->target.type) {\r\ncase UWB_RSV_TARGET_DEV:\r\ndrp_ie->dev_addr = rsv->target.dev->dev_addr;\r\nbreak;\r\ncase UWB_RSV_TARGET_DEVADDR:\r\ndrp_ie->dev_addr = rsv->target.devaddr;\r\nbreak;\r\n}\r\n} else\r\ndrp_ie->dev_addr = rsv->owner->dev_addr;\r\nuwb_drp_ie_from_bm(drp_ie, &rsv->mas);\r\nif (uwb_rsv_has_two_drp_ies(rsv)) {\r\nmv = &rsv->mv;\r\nif (mv->companion_drp_ie == NULL) {\r\nmv->companion_drp_ie = uwb_drp_ie_alloc();\r\nif (mv->companion_drp_ie == NULL)\r\nreturn -ENOMEM;\r\n}\r\ndrp_ie = mv->companion_drp_ie;\r\nmemcpy(drp_ie, rsv->drp_ie, sizeof(struct uwb_ie_drp));\r\nuwb_ie_drp_set_unsafe(drp_ie, 1);\r\nuwb_ie_drp_set_status(drp_ie, uwb_rsv_companion_status(rsv));\r\nuwb_ie_drp_set_reason_code(drp_ie, uwb_rsv_companion_reason_code(rsv));\r\nuwb_drp_ie_from_bm(drp_ie, &mv->companion_mas);\r\n}\r\nrsv->ie_valid = true;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid uwb_drp_ie_single_zone_to_bm(struct uwb_mas_bm *bm, u8 zone, u16 mas_bm)\r\n{\r\nint mas;\r\nu16 mas_mask;\r\nfor (mas = 0; mas < UWB_MAS_PER_ZONE; mas++) {\r\nmas_mask = 1 << mas;\r\nif (mas_bm & mas_mask)\r\nset_bit(zone * UWB_NUM_ZONES + mas, bm->bm);\r\n}\r\n}\r\nvoid uwb_drp_ie_to_bm(struct uwb_mas_bm *bm, const struct uwb_ie_drp *drp_ie)\r\n{\r\nint numallocs = (drp_ie->hdr.length - 4) / 4;\r\nconst struct uwb_drp_alloc *alloc;\r\nint cnt;\r\nu16 zone_bm, mas_bm;\r\nu8 zone;\r\nu16 zone_mask;\r\nbitmap_zero(bm->bm, UWB_NUM_MAS);\r\nfor (cnt = 0; cnt < numallocs; cnt++) {\r\nalloc = &drp_ie->allocs[cnt];\r\nzone_bm = le16_to_cpu(alloc->zone_bm);\r\nmas_bm = le16_to_cpu(alloc->mas_bm);\r\nfor (zone = 0; zone < UWB_NUM_ZONES; zone++) {\r\nzone_mask = 1 << zone;\r\nif (zone_bm & zone_mask)\r\nuwb_drp_ie_single_zone_to_bm(bm, zone, mas_bm);\r\n}\r\n}\r\n}
