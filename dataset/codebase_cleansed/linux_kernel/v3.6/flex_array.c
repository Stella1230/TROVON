static inline int elements_fit_in_base(struct flex_array *fa)\r\n{\r\nint data_size = fa->element_size * fa->total_nr_elements;\r\nif (data_size <= FLEX_ARRAY_BASE_BYTES_LEFT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstruct flex_array *flex_array_alloc(int element_size, unsigned int total,\r\ngfp_t flags)\r\n{\r\nstruct flex_array *ret;\r\nint elems_per_part = 0;\r\nint reciprocal_elems = 0;\r\nint max_size = 0;\r\nif (element_size) {\r\nelems_per_part = FLEX_ARRAY_ELEMENTS_PER_PART(element_size);\r\nreciprocal_elems = reciprocal_value(elems_per_part);\r\nmax_size = FLEX_ARRAY_NR_BASE_PTRS * elems_per_part;\r\n}\r\nif (total > max_size)\r\nreturn NULL;\r\nret = kzalloc(sizeof(struct flex_array), flags);\r\nif (!ret)\r\nreturn NULL;\r\nret->element_size = element_size;\r\nret->total_nr_elements = total;\r\nret->elems_per_part = elems_per_part;\r\nret->reciprocal_elems = reciprocal_elems;\r\nif (elements_fit_in_base(ret) && !(flags & __GFP_ZERO))\r\nmemset(&ret->parts[0], FLEX_ARRAY_FREE,\r\nFLEX_ARRAY_BASE_BYTES_LEFT);\r\nreturn ret;\r\n}\r\nstatic int fa_element_to_part_nr(struct flex_array *fa,\r\nunsigned int element_nr)\r\n{\r\nreturn reciprocal_divide(element_nr, fa->reciprocal_elems);\r\n}\r\nvoid flex_array_free_parts(struct flex_array *fa)\r\n{\r\nint part_nr;\r\nif (elements_fit_in_base(fa))\r\nreturn;\r\nfor (part_nr = 0; part_nr < FLEX_ARRAY_NR_BASE_PTRS; part_nr++)\r\nkfree(fa->parts[part_nr]);\r\n}\r\nvoid flex_array_free(struct flex_array *fa)\r\n{\r\nflex_array_free_parts(fa);\r\nkfree(fa);\r\n}\r\nstatic unsigned int index_inside_part(struct flex_array *fa,\r\nunsigned int element_nr,\r\nunsigned int part_nr)\r\n{\r\nunsigned int part_offset;\r\npart_offset = element_nr - part_nr * fa->elems_per_part;\r\nreturn part_offset * fa->element_size;\r\n}\r\nstatic struct flex_array_part *\r\n__fa_get_part(struct flex_array *fa, int part_nr, gfp_t flags)\r\n{\r\nstruct flex_array_part *part = fa->parts[part_nr];\r\nif (!part) {\r\npart = kmalloc(sizeof(struct flex_array_part), flags);\r\nif (!part)\r\nreturn NULL;\r\nif (!(flags & __GFP_ZERO))\r\nmemset(part, FLEX_ARRAY_FREE,\r\nsizeof(struct flex_array_part));\r\nfa->parts[part_nr] = part;\r\n}\r\nreturn part;\r\n}\r\nint flex_array_put(struct flex_array *fa, unsigned int element_nr, void *src,\r\ngfp_t flags)\r\n{\r\nint part_nr = 0;\r\nstruct flex_array_part *part;\r\nvoid *dst;\r\nif (element_nr >= fa->total_nr_elements)\r\nreturn -ENOSPC;\r\nif (!fa->element_size)\r\nreturn 0;\r\nif (elements_fit_in_base(fa))\r\npart = (struct flex_array_part *)&fa->parts[0];\r\nelse {\r\npart_nr = fa_element_to_part_nr(fa, element_nr);\r\npart = __fa_get_part(fa, part_nr, flags);\r\nif (!part)\r\nreturn -ENOMEM;\r\n}\r\ndst = &part->elements[index_inside_part(fa, element_nr, part_nr)];\r\nmemcpy(dst, src, fa->element_size);\r\nreturn 0;\r\n}\r\nint flex_array_clear(struct flex_array *fa, unsigned int element_nr)\r\n{\r\nint part_nr = 0;\r\nstruct flex_array_part *part;\r\nvoid *dst;\r\nif (element_nr >= fa->total_nr_elements)\r\nreturn -ENOSPC;\r\nif (!fa->element_size)\r\nreturn 0;\r\nif (elements_fit_in_base(fa))\r\npart = (struct flex_array_part *)&fa->parts[0];\r\nelse {\r\npart_nr = fa_element_to_part_nr(fa, element_nr);\r\npart = fa->parts[part_nr];\r\nif (!part)\r\nreturn -EINVAL;\r\n}\r\ndst = &part->elements[index_inside_part(fa, element_nr, part_nr)];\r\nmemset(dst, FLEX_ARRAY_FREE, fa->element_size);\r\nreturn 0;\r\n}\r\nint flex_array_prealloc(struct flex_array *fa, unsigned int start,\r\nunsigned int nr_elements, gfp_t flags)\r\n{\r\nint start_part;\r\nint end_part;\r\nint part_nr;\r\nunsigned int end;\r\nstruct flex_array_part *part;\r\nif (!start && !nr_elements)\r\nreturn 0;\r\nif (start >= fa->total_nr_elements)\r\nreturn -ENOSPC;\r\nif (!nr_elements)\r\nreturn 0;\r\nend = start + nr_elements - 1;\r\nif (end >= fa->total_nr_elements)\r\nreturn -ENOSPC;\r\nif (!fa->element_size)\r\nreturn 0;\r\nif (elements_fit_in_base(fa))\r\nreturn 0;\r\nstart_part = fa_element_to_part_nr(fa, start);\r\nend_part = fa_element_to_part_nr(fa, end);\r\nfor (part_nr = start_part; part_nr <= end_part; part_nr++) {\r\npart = __fa_get_part(fa, part_nr, flags);\r\nif (!part)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid *flex_array_get(struct flex_array *fa, unsigned int element_nr)\r\n{\r\nint part_nr = 0;\r\nstruct flex_array_part *part;\r\nif (!fa->element_size)\r\nreturn NULL;\r\nif (element_nr >= fa->total_nr_elements)\r\nreturn NULL;\r\nif (elements_fit_in_base(fa))\r\npart = (struct flex_array_part *)&fa->parts[0];\r\nelse {\r\npart_nr = fa_element_to_part_nr(fa, element_nr);\r\npart = fa->parts[part_nr];\r\nif (!part)\r\nreturn NULL;\r\n}\r\nreturn &part->elements[index_inside_part(fa, element_nr, part_nr)];\r\n}\r\nvoid *flex_array_get_ptr(struct flex_array *fa, unsigned int element_nr)\r\n{\r\nvoid **tmp;\r\ntmp = flex_array_get(fa, element_nr);\r\nif (!tmp)\r\nreturn NULL;\r\nreturn *tmp;\r\n}\r\nstatic int part_is_free(struct flex_array_part *part)\r\n{\r\nint i;\r\nfor (i = 0; i < sizeof(struct flex_array_part); i++)\r\nif (part->elements[i] != FLEX_ARRAY_FREE)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint flex_array_shrink(struct flex_array *fa)\r\n{\r\nstruct flex_array_part *part;\r\nint part_nr;\r\nint ret = 0;\r\nif (!fa->total_nr_elements || !fa->element_size)\r\nreturn 0;\r\nif (elements_fit_in_base(fa))\r\nreturn ret;\r\nfor (part_nr = 0; part_nr < FLEX_ARRAY_NR_BASE_PTRS; part_nr++) {\r\npart = fa->parts[part_nr];\r\nif (!part)\r\ncontinue;\r\nif (part_is_free(part)) {\r\nfa->parts[part_nr] = NULL;\r\nkfree(part);\r\nret++;\r\n}\r\n}\r\nreturn ret;\r\n}
