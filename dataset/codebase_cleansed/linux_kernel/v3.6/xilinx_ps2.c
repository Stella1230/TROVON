static int xps2_recv(struct xps2data *drvdata, u8 *byte)\r\n{\r\nu32 sr;\r\nint status = -1;\r\nsr = in_be32(drvdata->base_address + XPS2_STATUS_OFFSET);\r\nif (sr & XPS2_STATUS_RX_FULL) {\r\n*byte = in_be32(drvdata->base_address + XPS2_RX_DATA_OFFSET);\r\nstatus = 0;\r\n}\r\nreturn status;\r\n}\r\nstatic irqreturn_t xps2_interrupt(int irq, void *dev_id)\r\n{\r\nstruct xps2data *drvdata = dev_id;\r\nu32 intr_sr;\r\nu8 c;\r\nint status;\r\nintr_sr = in_be32(drvdata->base_address + XPS2_IPISR_OFFSET);\r\nout_be32(drvdata->base_address + XPS2_IPISR_OFFSET, intr_sr);\r\nif (intr_sr & XPS2_IPIXR_RX_OVF)\r\ndev_warn(drvdata->dev, "receive overrun error\n");\r\nif (intr_sr & XPS2_IPIXR_RX_ERR)\r\ndrvdata->flags |= SERIO_PARITY;\r\nif (intr_sr & (XPS2_IPIXR_TX_NOACK | XPS2_IPIXR_WDT_TOUT))\r\ndrvdata->flags |= SERIO_TIMEOUT;\r\nif (intr_sr & XPS2_IPIXR_RX_FULL) {\r\nstatus = xps2_recv(drvdata, &c);\r\nif (status) {\r\ndev_err(drvdata->dev,\r\n"wrong rcvd byte count (%d)\n", status);\r\n} else {\r\nserio_interrupt(drvdata->serio, c, drvdata->flags);\r\ndrvdata->flags = 0;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sxps2_write(struct serio *pserio, unsigned char c)\r\n{\r\nstruct xps2data *drvdata = pserio->port_data;\r\nunsigned long flags;\r\nu32 sr;\r\nint status = -1;\r\nspin_lock_irqsave(&drvdata->lock, flags);\r\nsr = in_be32(drvdata->base_address + XPS2_STATUS_OFFSET);\r\nif (!(sr & XPS2_STATUS_TX_FULL)) {\r\nout_be32(drvdata->base_address + XPS2_TX_DATA_OFFSET, c);\r\nstatus = 0;\r\n}\r\nspin_unlock_irqrestore(&drvdata->lock, flags);\r\nreturn status;\r\n}\r\nstatic int sxps2_open(struct serio *pserio)\r\n{\r\nstruct xps2data *drvdata = pserio->port_data;\r\nint error;\r\nu8 c;\r\nerror = request_irq(drvdata->irq, &xps2_interrupt, 0,\r\nDRIVER_NAME, drvdata);\r\nif (error) {\r\ndev_err(drvdata->dev,\r\n"Couldn't allocate interrupt %d\n", drvdata->irq);\r\nreturn error;\r\n}\r\nout_be32(drvdata->base_address + XPS2_GIER_OFFSET, XPS2_GIER_GIE_MASK);\r\nout_be32(drvdata->base_address + XPS2_IPIER_OFFSET, XPS2_IPIXR_RX_ALL);\r\n(void)xps2_recv(drvdata, &c);\r\nreturn 0;\r\n}\r\nstatic void sxps2_close(struct serio *pserio)\r\n{\r\nstruct xps2data *drvdata = pserio->port_data;\r\nout_be32(drvdata->base_address + XPS2_GIER_OFFSET, 0x00);\r\nout_be32(drvdata->base_address + XPS2_IPIER_OFFSET, 0x00);\r\nfree_irq(drvdata->irq, drvdata);\r\n}\r\nstatic int __devinit xps2_of_probe(struct platform_device *ofdev)\r\n{\r\nstruct resource r_irq;\r\nstruct resource r_mem;\r\nstruct xps2data *drvdata;\r\nstruct serio *serio;\r\nstruct device *dev = &ofdev->dev;\r\nresource_size_t remap_size, phys_addr;\r\nint error;\r\ndev_info(dev, "Device Tree Probing \'%s\'\n",\r\nofdev->dev.of_node->name);\r\nerror = of_address_to_resource(ofdev->dev.of_node, 0, &r_mem);\r\nif (error) {\r\ndev_err(dev, "invalid address\n");\r\nreturn error;\r\n}\r\nif (!of_irq_to_resource(ofdev->dev.of_node, 0, &r_irq)) {\r\ndev_err(dev, "no IRQ found\n");\r\nreturn -ENODEV;\r\n}\r\ndrvdata = kzalloc(sizeof(struct xps2data), GFP_KERNEL);\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!drvdata || !serio) {\r\nerror = -ENOMEM;\r\ngoto failed1;\r\n}\r\nspin_lock_init(&drvdata->lock);\r\ndrvdata->irq = r_irq.start;\r\ndrvdata->serio = serio;\r\ndrvdata->dev = dev;\r\nphys_addr = r_mem.start;\r\nremap_size = resource_size(&r_mem);\r\nif (!request_mem_region(phys_addr, remap_size, DRIVER_NAME)) {\r\ndev_err(dev, "Couldn't lock memory region at 0x%08llX\n",\r\n(unsigned long long)phys_addr);\r\nerror = -EBUSY;\r\ngoto failed1;\r\n}\r\ndrvdata->base_address = ioremap(phys_addr, remap_size);\r\nif (drvdata->base_address == NULL) {\r\ndev_err(dev, "Couldn't ioremap memory at 0x%08llX\n",\r\n(unsigned long long)phys_addr);\r\nerror = -EFAULT;\r\ngoto failed2;\r\n}\r\nout_be32(drvdata->base_address + XPS2_IPIER_OFFSET, 0);\r\nout_be32(drvdata->base_address + XPS2_SRST_OFFSET, XPS2_SRST_RESET);\r\ndev_info(dev, "Xilinx PS2 at 0x%08llX mapped to 0x%p, irq=%d\n",\r\n(unsigned long long)phys_addr, drvdata->base_address,\r\ndrvdata->irq);\r\nserio->id.type = SERIO_8042;\r\nserio->write = sxps2_write;\r\nserio->open = sxps2_open;\r\nserio->close = sxps2_close;\r\nserio->port_data = drvdata;\r\nserio->dev.parent = dev;\r\nsnprintf(serio->name, sizeof(serio->name),\r\n"Xilinx XPS PS/2 at %08llX", (unsigned long long)phys_addr);\r\nsnprintf(serio->phys, sizeof(serio->phys),\r\n"xilinxps2/serio at %08llX", (unsigned long long)phys_addr);\r\nserio_register_port(serio);\r\nplatform_set_drvdata(ofdev, drvdata);\r\nreturn 0;\r\nfailed2:\r\nrelease_mem_region(phys_addr, remap_size);\r\nfailed1:\r\nkfree(serio);\r\nkfree(drvdata);\r\nreturn error;\r\n}\r\nstatic int __devexit xps2_of_remove(struct platform_device *of_dev)\r\n{\r\nstruct xps2data *drvdata = platform_get_drvdata(of_dev);\r\nstruct resource r_mem;\r\nserio_unregister_port(drvdata->serio);\r\niounmap(drvdata->base_address);\r\nif (of_address_to_resource(of_dev->dev.of_node, 0, &r_mem))\r\ndev_err(drvdata->dev, "invalid address\n");\r\nelse\r\nrelease_mem_region(r_mem.start, resource_size(&r_mem));\r\nkfree(drvdata);\r\nplatform_set_drvdata(of_dev, NULL);\r\nreturn 0;\r\n}
