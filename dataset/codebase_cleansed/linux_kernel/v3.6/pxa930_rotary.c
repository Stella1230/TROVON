static void clear_sbcr(struct pxa930_rotary *r)\r\n{\r\nuint32_t sbcr = __raw_readl(r->mmio_base + SBCR);\r\n__raw_writel(sbcr | SBCR_ERSB, r->mmio_base + SBCR);\r\n__raw_writel(sbcr & ~SBCR_ERSB, r->mmio_base + SBCR);\r\n}\r\nstatic irqreturn_t rotary_irq(int irq, void *dev_id)\r\n{\r\nstruct pxa930_rotary *r = dev_id;\r\nstruct pxa930_rotary_platform_data *pdata = r->pdata;\r\nint ercr, delta, key;\r\nercr = __raw_readl(r->mmio_base + ERCR) & 0xf;\r\nclear_sbcr(r);\r\ndelta = ercr - r->last_ercr;\r\nif (delta == 0)\r\nreturn IRQ_HANDLED;\r\nr->last_ercr = ercr;\r\nif (pdata->up_key && pdata->down_key) {\r\nkey = (delta > 0) ? pdata->up_key : pdata->down_key;\r\ninput_report_key(r->input_dev, key, 1);\r\ninput_sync(r->input_dev);\r\ninput_report_key(r->input_dev, key, 0);\r\n} else\r\ninput_report_rel(r->input_dev, pdata->rel_code, delta);\r\ninput_sync(r->input_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pxa930_rotary_open(struct input_dev *dev)\r\n{\r\nstruct pxa930_rotary *r = input_get_drvdata(dev);\r\nclear_sbcr(r);\r\nreturn 0;\r\n}\r\nstatic void pxa930_rotary_close(struct input_dev *dev)\r\n{\r\nstruct pxa930_rotary *r = input_get_drvdata(dev);\r\nclear_sbcr(r);\r\n}\r\nstatic int __devinit pxa930_rotary_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa930_rotary_platform_data *pdata = pdev->dev.platform_data;\r\nstruct pxa930_rotary *r;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint irq;\r\nint err;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq for rotary controller\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no I/O memory defined\n");\r\nreturn -ENXIO;\r\n}\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nr = kzalloc(sizeof(struct pxa930_rotary), GFP_KERNEL);\r\nif (!r)\r\nreturn -ENOMEM;\r\nr->mmio_base = ioremap_nocache(res->start, resource_size(res));\r\nif (r->mmio_base == NULL) {\r\ndev_err(&pdev->dev, "failed to remap IO memory\n");\r\nerr = -ENXIO;\r\ngoto failed_free;\r\n}\r\nr->pdata = pdata;\r\nplatform_set_drvdata(pdev, r);\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nerr = -ENOMEM;\r\ngoto failed_free_io;\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->open = pxa930_rotary_open;\r\ninput_dev->close = pxa930_rotary_close;\r\ninput_dev->dev.parent = &pdev->dev;\r\nif (pdata->up_key && pdata->down_key) {\r\n__set_bit(pdata->up_key, input_dev->keybit);\r\n__set_bit(pdata->down_key, input_dev->keybit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n} else {\r\n__set_bit(pdata->rel_code, input_dev->relbit);\r\n__set_bit(EV_REL, input_dev->evbit);\r\n}\r\nr->input_dev = input_dev;\r\ninput_set_drvdata(input_dev, r);\r\nerr = request_irq(irq, rotary_irq, 0,\r\n"enhanced rotary", r);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\ngoto failed_free_input;\r\n}\r\nerr = input_register_device(input_dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ngoto failed_free_irq;\r\n}\r\nreturn 0;\r\nfailed_free_irq:\r\nfree_irq(irq, r);\r\nfailed_free_input:\r\ninput_free_device(input_dev);\r\nfailed_free_io:\r\niounmap(r->mmio_base);\r\nfailed_free:\r\nkfree(r);\r\nreturn err;\r\n}\r\nstatic int __devexit pxa930_rotary_remove(struct platform_device *pdev)\r\n{\r\nstruct pxa930_rotary *r = platform_get_drvdata(pdev);\r\nfree_irq(platform_get_irq(pdev, 0), r);\r\ninput_unregister_device(r->input_dev);\r\niounmap(r->mmio_base);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(r);\r\nreturn 0;\r\n}
