static int\r\ndiscover(void)\r\n{\r\naoecmd_cfg(0xffff, 0xff);\r\nreturn 0;\r\n}\r\nstatic int\r\ninterfaces(const char __user *str, size_t size)\r\n{\r\nif (set_aoe_iflist(str, size)) {\r\nprintk(KERN_ERR\r\n"aoe: could not set interface list: too many interfaces\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nrevalidate(const char __user *str, size_t size)\r\n{\r\nint major, minor, n;\r\nulong flags;\r\nstruct aoedev *d;\r\nstruct sk_buff *skb;\r\nchar buf[16];\r\nif (size >= sizeof buf)\r\nreturn -EINVAL;\r\nbuf[sizeof buf - 1] = '\0';\r\nif (copy_from_user(buf, str, size))\r\nreturn -EFAULT;\r\nn = sscanf(buf, "e%d.%d", &major, &minor);\r\nif (n != 2) {\r\nprintk(KERN_ERR "aoe: invalid device specification\n");\r\nreturn -EINVAL;\r\n}\r\nd = aoedev_by_aoeaddr(major, minor);\r\nif (!d)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&d->lock, flags);\r\naoecmd_cleanslate(d);\r\nloop:\r\nskb = aoecmd_ata_id(d);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nif (!skb && !msleep_interruptible(200)) {\r\nspin_lock_irqsave(&d->lock, flags);\r\ngoto loop;\r\n}\r\nif (skb) {\r\nstruct sk_buff_head queue;\r\n__skb_queue_head_init(&queue);\r\n__skb_queue_tail(&queue, skb);\r\naoenet_xmit(&queue);\r\n}\r\naoecmd_cfg(major, minor);\r\nreturn 0;\r\n}\r\nvoid\r\naoechr_error(char *msg)\r\n{\r\nstruct ErrMsg *em;\r\nchar *mp;\r\nulong flags, n;\r\nn = strlen(msg);\r\nspin_lock_irqsave(&emsgs_lock, flags);\r\nem = emsgs + emsgs_tail_idx;\r\nif ((em->flags & EMFL_VALID)) {\r\nbail: spin_unlock_irqrestore(&emsgs_lock, flags);\r\nreturn;\r\n}\r\nmp = kmalloc(n, GFP_ATOMIC);\r\nif (mp == NULL) {\r\nprintk(KERN_ERR "aoe: allocation failure, len=%ld\n", n);\r\ngoto bail;\r\n}\r\nmemcpy(mp, msg, n);\r\nem->msg = mp;\r\nem->flags |= EMFL_VALID;\r\nem->len = n;\r\nemsgs_tail_idx++;\r\nemsgs_tail_idx %= ARRAY_SIZE(emsgs);\r\nspin_unlock_irqrestore(&emsgs_lock, flags);\r\nif (nblocked_emsgs_readers)\r\ncomplete(&emsgs_comp);\r\n}\r\nstatic ssize_t\r\naoechr_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offp)\r\n{\r\nint ret = -EINVAL;\r\nswitch ((unsigned long) filp->private_data) {\r\ndefault:\r\nprintk(KERN_INFO "aoe: can't write to that file.\n");\r\nbreak;\r\ncase MINOR_DISCOVER:\r\nret = discover();\r\nbreak;\r\ncase MINOR_INTERFACES:\r\nret = interfaces(buf, cnt);\r\nbreak;\r\ncase MINOR_REVALIDATE:\r\nret = revalidate(buf, cnt);\r\nbreak;\r\ncase MINOR_FLUSH:\r\nret = aoedev_flush(buf, cnt);\r\n}\r\nif (ret == 0)\r\nret = cnt;\r\nreturn ret;\r\n}\r\nstatic int\r\naoechr_open(struct inode *inode, struct file *filp)\r\n{\r\nint n, i;\r\nmutex_lock(&aoechr_mutex);\r\nn = iminor(inode);\r\nfilp->private_data = (void *) (unsigned long) n;\r\nfor (i = 0; i < ARRAY_SIZE(chardevs); ++i)\r\nif (chardevs[i].minor == n) {\r\nmutex_unlock(&aoechr_mutex);\r\nreturn 0;\r\n}\r\nmutex_unlock(&aoechr_mutex);\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\naoechr_rel(struct inode *inode, struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\naoechr_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)\r\n{\r\nunsigned long n;\r\nchar *mp;\r\nstruct ErrMsg *em;\r\nssize_t len;\r\nulong flags;\r\nn = (unsigned long) filp->private_data;\r\nif (n != MINOR_ERR)\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&emsgs_lock, flags);\r\nfor (;;) {\r\nem = emsgs + emsgs_head_idx;\r\nif ((em->flags & EMFL_VALID) != 0)\r\nbreak;\r\nif (filp->f_flags & O_NDELAY) {\r\nspin_unlock_irqrestore(&emsgs_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nnblocked_emsgs_readers++;\r\nspin_unlock_irqrestore(&emsgs_lock, flags);\r\nn = wait_for_completion_interruptible(&emsgs_comp);\r\nspin_lock_irqsave(&emsgs_lock, flags);\r\nnblocked_emsgs_readers--;\r\nif (n) {\r\nspin_unlock_irqrestore(&emsgs_lock, flags);\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nif (em->len > cnt) {\r\nspin_unlock_irqrestore(&emsgs_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nmp = em->msg;\r\nlen = em->len;\r\nem->msg = NULL;\r\nem->flags &= ~EMFL_VALID;\r\nemsgs_head_idx++;\r\nemsgs_head_idx %= ARRAY_SIZE(emsgs);\r\nspin_unlock_irqrestore(&emsgs_lock, flags);\r\nn = copy_to_user(buf, mp, len);\r\nkfree(mp);\r\nreturn n == 0 ? len : -EFAULT;\r\n}\r\nstatic char *aoe_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "etherd/%s", dev_name(dev));\r\n}\r\nint __init\r\naoechr_init(void)\r\n{\r\nint n, i;\r\nn = register_chrdev(AOE_MAJOR, "aoechr", &aoe_fops);\r\nif (n < 0) {\r\nprintk(KERN_ERR "aoe: can't register char device\n");\r\nreturn n;\r\n}\r\ninit_completion(&emsgs_comp);\r\nspin_lock_init(&emsgs_lock);\r\naoe_class = class_create(THIS_MODULE, "aoe");\r\nif (IS_ERR(aoe_class)) {\r\nunregister_chrdev(AOE_MAJOR, "aoechr");\r\nreturn PTR_ERR(aoe_class);\r\n}\r\naoe_class->devnode = aoe_devnode;\r\nfor (i = 0; i < ARRAY_SIZE(chardevs); ++i)\r\ndevice_create(aoe_class, NULL,\r\nMKDEV(AOE_MAJOR, chardevs[i].minor), NULL,\r\nchardevs[i].name);\r\nreturn 0;\r\n}\r\nvoid\r\naoechr_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(chardevs); ++i)\r\ndevice_destroy(aoe_class, MKDEV(AOE_MAJOR, chardevs[i].minor));\r\nclass_destroy(aoe_class);\r\nunregister_chrdev(AOE_MAJOR, "aoechr");\r\n}
