static int __sh_rtc_interrupt(struct sh_rtc *rtc)\r\n{\r\nunsigned int tmp, pending;\r\ntmp = readb(rtc->regbase + RCR1);\r\npending = tmp & RCR1_CF;\r\ntmp &= ~RCR1_CF;\r\nwriteb(tmp, rtc->regbase + RCR1);\r\nif (pending && rtc->periodic_freq & PF_OXS)\r\nrtc_update_irq(rtc->rtc_dev, 1, RTC_UF | RTC_IRQF);\r\nreturn pending;\r\n}\r\nstatic int __sh_rtc_alarm(struct sh_rtc *rtc)\r\n{\r\nunsigned int tmp, pending;\r\ntmp = readb(rtc->regbase + RCR1);\r\npending = tmp & RCR1_AF;\r\ntmp &= ~(RCR1_AF | RCR1_AIE);\r\nwriteb(tmp, rtc->regbase + RCR1);\r\nif (pending)\r\nrtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);\r\nreturn pending;\r\n}\r\nstatic int __sh_rtc_periodic(struct sh_rtc *rtc)\r\n{\r\nstruct rtc_device *rtc_dev = rtc->rtc_dev;\r\nstruct rtc_task *irq_task;\r\nunsigned int tmp, pending;\r\ntmp = readb(rtc->regbase + RCR2);\r\npending = tmp & RCR2_PEF;\r\ntmp &= ~RCR2_PEF;\r\nwriteb(tmp, rtc->regbase + RCR2);\r\nif (!pending)\r\nreturn 0;\r\nif ((rtc->periodic_freq & PF_HP) && (rtc->periodic_freq & PF_COUNT))\r\nrtc->periodic_freq &= ~PF_COUNT;\r\nelse {\r\nif (rtc->periodic_freq & PF_HP)\r\nrtc->periodic_freq |= PF_COUNT;\r\nif (rtc->periodic_freq & PF_KOU) {\r\nspin_lock(&rtc_dev->irq_task_lock);\r\nirq_task = rtc_dev->irq_task;\r\nif (irq_task)\r\nirq_task->func(irq_task->private_data);\r\nspin_unlock(&rtc_dev->irq_task_lock);\r\n} else\r\nrtc_update_irq(rtc->rtc_dev, 1, RTC_PF | RTC_IRQF);\r\n}\r\nreturn pending;\r\n}\r\nstatic irqreturn_t sh_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sh_rtc *rtc = dev_id;\r\nint ret;\r\nspin_lock(&rtc->lock);\r\nret = __sh_rtc_interrupt(rtc);\r\nspin_unlock(&rtc->lock);\r\nreturn IRQ_RETVAL(ret);\r\n}\r\nstatic irqreturn_t sh_rtc_alarm(int irq, void *dev_id)\r\n{\r\nstruct sh_rtc *rtc = dev_id;\r\nint ret;\r\nspin_lock(&rtc->lock);\r\nret = __sh_rtc_alarm(rtc);\r\nspin_unlock(&rtc->lock);\r\nreturn IRQ_RETVAL(ret);\r\n}\r\nstatic irqreturn_t sh_rtc_periodic(int irq, void *dev_id)\r\n{\r\nstruct sh_rtc *rtc = dev_id;\r\nint ret;\r\nspin_lock(&rtc->lock);\r\nret = __sh_rtc_periodic(rtc);\r\nspin_unlock(&rtc->lock);\r\nreturn IRQ_RETVAL(ret);\r\n}\r\nstatic irqreturn_t sh_rtc_shared(int irq, void *dev_id)\r\n{\r\nstruct sh_rtc *rtc = dev_id;\r\nint ret;\r\nspin_lock(&rtc->lock);\r\nret = __sh_rtc_interrupt(rtc);\r\nret |= __sh_rtc_alarm(rtc);\r\nret |= __sh_rtc_periodic(rtc);\r\nspin_unlock(&rtc->lock);\r\nreturn IRQ_RETVAL(ret);\r\n}\r\nstatic int sh_rtc_irq_set_state(struct device *dev, int enable)\r\n{\r\nstruct sh_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int tmp;\r\nspin_lock_irq(&rtc->lock);\r\ntmp = readb(rtc->regbase + RCR2);\r\nif (enable) {\r\nrtc->periodic_freq |= PF_KOU;\r\ntmp &= ~RCR2_PEF;\r\ntmp |= (rtc->periodic_freq & ~PF_HP);\r\n} else {\r\nrtc->periodic_freq &= ~PF_KOU;\r\ntmp &= ~(RCR2_PESMASK | RCR2_PEF);\r\n}\r\nwriteb(tmp, rtc->regbase + RCR2);\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic int sh_rtc_irq_set_freq(struct device *dev, int freq)\r\n{\r\nstruct sh_rtc *rtc = dev_get_drvdata(dev);\r\nint tmp, ret = 0;\r\nspin_lock_irq(&rtc->lock);\r\ntmp = rtc->periodic_freq & PF_MASK;\r\nswitch (freq) {\r\ncase 0:\r\nrtc->periodic_freq = 0x00;\r\nbreak;\r\ncase 1:\r\nrtc->periodic_freq = 0x60;\r\nbreak;\r\ncase 2:\r\nrtc->periodic_freq = 0x50;\r\nbreak;\r\ncase 4:\r\nrtc->periodic_freq = 0x40;\r\nbreak;\r\ncase 8:\r\nrtc->periodic_freq = 0x30 | PF_HP;\r\nbreak;\r\ncase 16:\r\nrtc->periodic_freq = 0x30;\r\nbreak;\r\ncase 32:\r\nrtc->periodic_freq = 0x20 | PF_HP;\r\nbreak;\r\ncase 64:\r\nrtc->periodic_freq = 0x20;\r\nbreak;\r\ncase 128:\r\nrtc->periodic_freq = 0x10 | PF_HP;\r\nbreak;\r\ncase 256:\r\nrtc->periodic_freq = 0x10;\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\n}\r\nif (ret == 0)\r\nrtc->periodic_freq |= tmp;\r\nspin_unlock_irq(&rtc->lock);\r\nreturn ret;\r\n}\r\nstatic inline void sh_rtc_setaie(struct device *dev, unsigned int enable)\r\n{\r\nstruct sh_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int tmp;\r\nspin_lock_irq(&rtc->lock);\r\ntmp = readb(rtc->regbase + RCR1);\r\nif (enable)\r\ntmp |= RCR1_AIE;\r\nelse\r\ntmp &= ~RCR1_AIE;\r\nwriteb(tmp, rtc->regbase + RCR1);\r\nspin_unlock_irq(&rtc->lock);\r\n}\r\nstatic int sh_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct sh_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int tmp;\r\ntmp = readb(rtc->regbase + RCR1);\r\nseq_printf(seq, "carry_IRQ\t: %s\n", (tmp & RCR1_CIE) ? "yes" : "no");\r\ntmp = readb(rtc->regbase + RCR2);\r\nseq_printf(seq, "periodic_IRQ\t: %s\n",\r\n(tmp & RCR2_PESMASK) ? "yes" : "no");\r\nreturn 0;\r\n}\r\nstatic inline void sh_rtc_setcie(struct device *dev, unsigned int enable)\r\n{\r\nstruct sh_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned int tmp;\r\nspin_lock_irq(&rtc->lock);\r\ntmp = readb(rtc->regbase + RCR1);\r\nif (!enable)\r\ntmp &= ~RCR1_CIE;\r\nelse\r\ntmp |= RCR1_CIE;\r\nwriteb(tmp, rtc->regbase + RCR1);\r\nspin_unlock_irq(&rtc->lock);\r\n}\r\nstatic int sh_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nsh_rtc_setaie(dev, enabled);\r\nreturn 0;\r\n}\r\nstatic int sh_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_rtc *rtc = platform_get_drvdata(pdev);\r\nunsigned int sec128, sec2, yr, yr100, cf_bit;\r\ndo {\r\nunsigned int tmp;\r\nspin_lock_irq(&rtc->lock);\r\ntmp = readb(rtc->regbase + RCR1);\r\ntmp &= ~RCR1_CF;\r\ntmp |= RCR1_CIE;\r\nwriteb(tmp, rtc->regbase + RCR1);\r\nsec128 = readb(rtc->regbase + R64CNT);\r\ntm->tm_sec = bcd2bin(readb(rtc->regbase + RSECCNT));\r\ntm->tm_min = bcd2bin(readb(rtc->regbase + RMINCNT));\r\ntm->tm_hour = bcd2bin(readb(rtc->regbase + RHRCNT));\r\ntm->tm_wday = bcd2bin(readb(rtc->regbase + RWKCNT));\r\ntm->tm_mday = bcd2bin(readb(rtc->regbase + RDAYCNT));\r\ntm->tm_mon = bcd2bin(readb(rtc->regbase + RMONCNT)) - 1;\r\nif (rtc->capabilities & RTC_CAP_4_DIGIT_YEAR) {\r\nyr = readw(rtc->regbase + RYRCNT);\r\nyr100 = bcd2bin(yr >> 8);\r\nyr &= 0xff;\r\n} else {\r\nyr = readb(rtc->regbase + RYRCNT);\r\nyr100 = bcd2bin((yr == 0x99) ? 0x19 : 0x20);\r\n}\r\ntm->tm_year = (yr100 * 100 + bcd2bin(yr)) - 1900;\r\nsec2 = readb(rtc->regbase + R64CNT);\r\ncf_bit = readb(rtc->regbase + RCR1) & RCR1_CF;\r\nspin_unlock_irq(&rtc->lock);\r\n} while (cf_bit != 0 || ((sec128 ^ sec2) & RTC_BIT_INVERTED) != 0);\r\n#if RTC_BIT_INVERTED != 0\r\nif ((sec128 & RTC_BIT_INVERTED))\r\ntm->tm_sec--;\r\n#endif\r\nif (!(rtc->periodic_freq & PF_OXS))\r\nsh_rtc_setcie(dev, 0);\r\ndev_dbg(dev, "%s: tm is secs=%d, mins=%d, hours=%d, "\r\n"mday=%d, mon=%d, year=%d, wday=%d\n",\r\n__func__,\r\ntm->tm_sec, tm->tm_min, tm->tm_hour,\r\ntm->tm_mday, tm->tm_mon + 1, tm->tm_year, tm->tm_wday);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int sh_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_rtc *rtc = platform_get_drvdata(pdev);\r\nunsigned int tmp;\r\nint year;\r\nspin_lock_irq(&rtc->lock);\r\ntmp = readb(rtc->regbase + RCR2);\r\ntmp |= RCR2_RESET;\r\ntmp &= ~RCR2_START;\r\nwriteb(tmp, rtc->regbase + RCR2);\r\nwriteb(bin2bcd(tm->tm_sec), rtc->regbase + RSECCNT);\r\nwriteb(bin2bcd(tm->tm_min), rtc->regbase + RMINCNT);\r\nwriteb(bin2bcd(tm->tm_hour), rtc->regbase + RHRCNT);\r\nwriteb(bin2bcd(tm->tm_wday), rtc->regbase + RWKCNT);\r\nwriteb(bin2bcd(tm->tm_mday), rtc->regbase + RDAYCNT);\r\nwriteb(bin2bcd(tm->tm_mon + 1), rtc->regbase + RMONCNT);\r\nif (rtc->capabilities & RTC_CAP_4_DIGIT_YEAR) {\r\nyear = (bin2bcd((tm->tm_year + 1900) / 100) << 8) |\r\nbin2bcd(tm->tm_year % 100);\r\nwritew(year, rtc->regbase + RYRCNT);\r\n} else {\r\nyear = tm->tm_year % 100;\r\nwriteb(bin2bcd(year), rtc->regbase + RYRCNT);\r\n}\r\ntmp = readb(rtc->regbase + RCR2);\r\ntmp &= ~RCR2_RESET;\r\ntmp |= RCR2_RTCEN | RCR2_START;\r\nwriteb(tmp, rtc->regbase + RCR2);\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic inline int sh_rtc_read_alarm_value(struct sh_rtc *rtc, int reg_off)\r\n{\r\nunsigned int byte;\r\nint value = 0xff;\r\nbyte = readb(rtc->regbase + reg_off);\r\nif (byte & AR_ENB) {\r\nbyte &= ~AR_ENB;\r\nvalue = bcd2bin(byte);\r\n}\r\nreturn value;\r\n}\r\nstatic int sh_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_rtc *rtc = platform_get_drvdata(pdev);\r\nstruct rtc_time *tm = &wkalrm->time;\r\nspin_lock_irq(&rtc->lock);\r\ntm->tm_sec = sh_rtc_read_alarm_value(rtc, RSECAR);\r\ntm->tm_min = sh_rtc_read_alarm_value(rtc, RMINAR);\r\ntm->tm_hour = sh_rtc_read_alarm_value(rtc, RHRAR);\r\ntm->tm_wday = sh_rtc_read_alarm_value(rtc, RWKAR);\r\ntm->tm_mday = sh_rtc_read_alarm_value(rtc, RDAYAR);\r\ntm->tm_mon = sh_rtc_read_alarm_value(rtc, RMONAR);\r\nif (tm->tm_mon > 0)\r\ntm->tm_mon -= 1;\r\ntm->tm_year = 0xffff;\r\nwkalrm->enabled = (readb(rtc->regbase + RCR1) & RCR1_AIE) ? 1 : 0;\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic inline void sh_rtc_write_alarm_value(struct sh_rtc *rtc,\r\nint value, int reg_off)\r\n{\r\nif (value < 0)\r\nwriteb(0, rtc->regbase + reg_off);\r\nelse\r\nwriteb(bin2bcd(value) | AR_ENB, rtc->regbase + reg_off);\r\n}\r\nstatic int sh_rtc_check_alarm(struct rtc_time *tm)\r\n{\r\nif (tm->tm_year == 0xffff)\r\ntm->tm_year = -1;\r\nif (tm->tm_mon >= 0xff)\r\ntm->tm_mon = -1;\r\nif (tm->tm_mday >= 0xff)\r\ntm->tm_mday = -1;\r\nif (tm->tm_wday >= 0xff)\r\ntm->tm_wday = -1;\r\nif (tm->tm_hour >= 0xff)\r\ntm->tm_hour = -1;\r\nif (tm->tm_min >= 0xff)\r\ntm->tm_min = -1;\r\nif (tm->tm_sec >= 0xff)\r\ntm->tm_sec = -1;\r\nif (tm->tm_year > 9999 ||\r\ntm->tm_mon >= 12 ||\r\ntm->tm_mday == 0 || tm->tm_mday >= 32 ||\r\ntm->tm_wday >= 7 ||\r\ntm->tm_hour >= 24 ||\r\ntm->tm_min >= 60 ||\r\ntm->tm_sec >= 60)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sh_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_rtc *rtc = platform_get_drvdata(pdev);\r\nunsigned int rcr1;\r\nstruct rtc_time *tm = &wkalrm->time;\r\nint mon, err;\r\nerr = sh_rtc_check_alarm(tm);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nspin_lock_irq(&rtc->lock);\r\nrcr1 = readb(rtc->regbase + RCR1);\r\nrcr1 &= ~(RCR1_AF | RCR1_AIE);\r\nwriteb(rcr1, rtc->regbase + RCR1);\r\nsh_rtc_write_alarm_value(rtc, tm->tm_sec, RSECAR);\r\nsh_rtc_write_alarm_value(rtc, tm->tm_min, RMINAR);\r\nsh_rtc_write_alarm_value(rtc, tm->tm_hour, RHRAR);\r\nsh_rtc_write_alarm_value(rtc, tm->tm_wday, RWKAR);\r\nsh_rtc_write_alarm_value(rtc, tm->tm_mday, RDAYAR);\r\nmon = tm->tm_mon;\r\nif (mon >= 0)\r\nmon += 1;\r\nsh_rtc_write_alarm_value(rtc, mon, RMONAR);\r\nif (wkalrm->enabled) {\r\nrcr1 |= RCR1_AIE;\r\nwriteb(rcr1, rtc->regbase + RCR1);\r\n}\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic int __init sh_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_rtc *rtc;\r\nstruct resource *res;\r\nstruct rtc_time r;\r\nchar clk_name[6];\r\nint clk_id, ret;\r\nrtc = kzalloc(sizeof(struct sh_rtc), GFP_KERNEL);\r\nif (unlikely(!rtc))\r\nreturn -ENOMEM;\r\nspin_lock_init(&rtc->lock);\r\nret = platform_get_irq(pdev, 0);\r\nif (unlikely(ret <= 0)) {\r\nret = -ENOENT;\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\ngoto err_badres;\r\n}\r\nrtc->periodic_irq = ret;\r\nrtc->carry_irq = platform_get_irq(pdev, 1);\r\nrtc->alarm_irq = platform_get_irq(pdev, 2);\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (unlikely(res == NULL)) {\r\nret = -ENOENT;\r\ndev_err(&pdev->dev, "No IO resource\n");\r\ngoto err_badres;\r\n}\r\nrtc->regsize = resource_size(res);\r\nrtc->res = request_mem_region(res->start, rtc->regsize, pdev->name);\r\nif (unlikely(!rtc->res)) {\r\nret = -EBUSY;\r\ngoto err_badres;\r\n}\r\nrtc->regbase = ioremap_nocache(rtc->res->start, rtc->regsize);\r\nif (unlikely(!rtc->regbase)) {\r\nret = -EINVAL;\r\ngoto err_badmap;\r\n}\r\nclk_id = pdev->id;\r\nif (clk_id < 0)\r\nclk_id = 0;\r\nsnprintf(clk_name, sizeof(clk_name), "rtc%d", clk_id);\r\nrtc->clk = clk_get(&pdev->dev, clk_name);\r\nif (IS_ERR(rtc->clk)) {\r\nrtc->clk = NULL;\r\n}\r\nclk_enable(rtc->clk);\r\nrtc->capabilities = RTC_DEF_CAPABILITIES;\r\nif (pdev->dev.platform_data) {\r\nstruct sh_rtc_platform_info *pinfo = pdev->dev.platform_data;\r\nrtc->capabilities |= pinfo->capabilities;\r\n}\r\nif (rtc->carry_irq <= 0) {\r\nret = request_irq(rtc->periodic_irq, sh_rtc_shared,\r\n0, "sh-rtc", rtc);\r\nif (unlikely(ret)) {\r\ndev_err(&pdev->dev,\r\n"request IRQ failed with %d, IRQ %d\n", ret,\r\nrtc->periodic_irq);\r\ngoto err_unmap;\r\n}\r\n} else {\r\nret = request_irq(rtc->periodic_irq, sh_rtc_periodic,\r\n0, "sh-rtc period", rtc);\r\nif (unlikely(ret)) {\r\ndev_err(&pdev->dev,\r\n"request period IRQ failed with %d, IRQ %d\n",\r\nret, rtc->periodic_irq);\r\ngoto err_unmap;\r\n}\r\nret = request_irq(rtc->carry_irq, sh_rtc_interrupt,\r\n0, "sh-rtc carry", rtc);\r\nif (unlikely(ret)) {\r\ndev_err(&pdev->dev,\r\n"request carry IRQ failed with %d, IRQ %d\n",\r\nret, rtc->carry_irq);\r\nfree_irq(rtc->periodic_irq, rtc);\r\ngoto err_unmap;\r\n}\r\nret = request_irq(rtc->alarm_irq, sh_rtc_alarm,\r\n0, "sh-rtc alarm", rtc);\r\nif (unlikely(ret)) {\r\ndev_err(&pdev->dev,\r\n"request alarm IRQ failed with %d, IRQ %d\n",\r\nret, rtc->alarm_irq);\r\nfree_irq(rtc->carry_irq, rtc);\r\nfree_irq(rtc->periodic_irq, rtc);\r\ngoto err_unmap;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nsh_rtc_irq_set_freq(&pdev->dev, 0);\r\nsh_rtc_irq_set_state(&pdev->dev, 0);\r\nsh_rtc_setaie(&pdev->dev, 0);\r\nsh_rtc_setcie(&pdev->dev, 0);\r\nrtc->rtc_dev = rtc_device_register("sh", &pdev->dev,\r\n&sh_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc_dev)) {\r\nret = PTR_ERR(rtc->rtc_dev);\r\nfree_irq(rtc->periodic_irq, rtc);\r\nfree_irq(rtc->carry_irq, rtc);\r\nfree_irq(rtc->alarm_irq, rtc);\r\ngoto err_unmap;\r\n}\r\nrtc->rtc_dev->max_user_freq = 256;\r\nif (rtc_read_time(rtc->rtc_dev, &r) < 0) {\r\nrtc_time_to_tm(0, &r);\r\nrtc_set_time(rtc->rtc_dev, &r);\r\n}\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\nerr_unmap:\r\nclk_disable(rtc->clk);\r\nclk_put(rtc->clk);\r\niounmap(rtc->regbase);\r\nerr_badmap:\r\nrelease_mem_region(rtc->res->start, rtc->regsize);\r\nerr_badres:\r\nkfree(rtc);\r\nreturn ret;\r\n}\r\nstatic int __exit sh_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_rtc *rtc = platform_get_drvdata(pdev);\r\nrtc_device_unregister(rtc->rtc_dev);\r\nsh_rtc_irq_set_state(&pdev->dev, 0);\r\nsh_rtc_setaie(&pdev->dev, 0);\r\nsh_rtc_setcie(&pdev->dev, 0);\r\nfree_irq(rtc->periodic_irq, rtc);\r\nif (rtc->carry_irq > 0) {\r\nfree_irq(rtc->carry_irq, rtc);\r\nfree_irq(rtc->alarm_irq, rtc);\r\n}\r\niounmap(rtc->regbase);\r\nrelease_mem_region(rtc->res->start, rtc->regsize);\r\nclk_disable(rtc->clk);\r\nclk_put(rtc->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(rtc);\r\nreturn 0;\r\n}\r\nstatic void sh_rtc_set_irq_wake(struct device *dev, int enabled)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_rtc *rtc = platform_get_drvdata(pdev);\r\nirq_set_irq_wake(rtc->periodic_irq, enabled);\r\nif (rtc->carry_irq > 0) {\r\nirq_set_irq_wake(rtc->carry_irq, enabled);\r\nirq_set_irq_wake(rtc->alarm_irq, enabled);\r\n}\r\n}\r\nstatic int sh_rtc_suspend(struct device *dev)\r\n{\r\nif (device_may_wakeup(dev))\r\nsh_rtc_set_irq_wake(dev, 1);\r\nreturn 0;\r\n}\r\nstatic int sh_rtc_resume(struct device *dev)\r\n{\r\nif (device_may_wakeup(dev))\r\nsh_rtc_set_irq_wake(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __init sh_rtc_init(void)\r\n{\r\nreturn platform_driver_probe(&sh_rtc_platform_driver, sh_rtc_probe);\r\n}\r\nstatic void __exit sh_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_rtc_platform_driver);\r\n}
