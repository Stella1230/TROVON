static inline byte\r\nde620_ready(struct net_device *dev)\r\n{\r\nbyte value;\r\nregister short int cnt = 0;\r\nwhile ((((value = inb(STATUS_PORT)) & READY) == 0) && (cnt <= 1000))\r\n++cnt;\r\n#ifdef COUNT_LOOPS\r\ntot_cnt += cnt;\r\n#endif\r\nreturn value & 0xf0;\r\n}\r\nstatic inline void\r\nde620_send_command(struct net_device *dev, byte cmd)\r\n{\r\nde620_ready(dev);\r\nif (cmd == W_DUMMY)\r\noutb(NIC_Cmd, COMMAND_PORT);\r\noutb(cmd, DATA_PORT);\r\noutb(NIC_Cmd ^ CS0, COMMAND_PORT);\r\nde620_ready(dev);\r\noutb(NIC_Cmd, COMMAND_PORT);\r\n}\r\nstatic inline void\r\nde620_put_byte(struct net_device *dev, byte value)\r\n{\r\nde620_ready(dev);\r\noutb(value, DATA_PORT);\r\nde620_flip_ds(dev);\r\n}\r\nstatic inline byte\r\nde620_read_byte(struct net_device *dev)\r\n{\r\nbyte value;\r\nvalue = de620_ready(dev);\r\nde620_flip_ds(dev);\r\nvalue |= de620_ready(dev) >> 4;\r\nreturn value;\r\n}\r\nstatic inline void\r\nde620_write_block(struct net_device *dev, byte *buffer, int count, int pad)\r\n{\r\n#ifndef LOWSPEED\r\nbyte uflip = NIC_Cmd ^ (DS0 | DS1);\r\nbyte dflip = NIC_Cmd;\r\n#else\r\n#ifdef COUNT_LOOPS\r\nint bytes = count;\r\n#endif\r\n#endif\r\n#ifdef LOWSPEED\r\n#ifdef COUNT_LOOPS\r\ntot_cnt = 0;\r\n#endif\r\nfor ( ; count > 0; --count, ++buffer) {\r\nde620_put_byte(dev,*buffer);\r\n}\r\nfor ( count = pad ; count > 0; --count, ++buffer) {\r\nde620_put_byte(dev, 0);\r\n}\r\nde620_send_command(dev,W_DUMMY);\r\n#ifdef COUNT_LOOPS\r\nprintk("WRITE(%d)\n", tot_cnt/((bytes?bytes:1)));\r\n#endif\r\n#else\r\nfor ( ; count > 0; count -=2) {\r\noutb(*buffer++, DATA_PORT);\r\noutb(uflip, COMMAND_PORT);\r\noutb(*buffer++, DATA_PORT);\r\noutb(dflip, COMMAND_PORT);\r\n}\r\nde620_send_command(dev,W_DUMMY);\r\n#endif\r\n}\r\nstatic inline void\r\nde620_read_block(struct net_device *dev, byte *data, int count)\r\n{\r\n#ifndef LOWSPEED\r\nbyte value;\r\nbyte uflip = NIC_Cmd ^ (DS0 | DS1);\r\nbyte dflip = NIC_Cmd;\r\n#else\r\n#ifdef COUNT_LOOPS\r\nint bytes = count;\r\ntot_cnt = 0;\r\n#endif\r\n#endif\r\n#ifdef LOWSPEED\r\nwhile (count-- > 0) {\r\n*data++ = de620_read_byte(dev);\r\nde620_flip_ds(dev);\r\n}\r\n#ifdef COUNT_LOOPS\r\nprintk("READ(%d)\n", tot_cnt/(2*(bytes?bytes:1)));\r\n#endif\r\n#else\r\nwhile (count-- > 0) {\r\nvalue = inb(STATUS_PORT) & 0xf0;\r\noutb(uflip, COMMAND_PORT);\r\n*data++ = value | inb(STATUS_PORT) >> 4;\r\noutb(dflip , COMMAND_PORT);\r\n}\r\n#endif\r\n}\r\nstatic inline void\r\nde620_set_delay(struct net_device *dev)\r\n{\r\nde620_ready(dev);\r\noutb(W_DFR, DATA_PORT);\r\noutb(NIC_Cmd ^ CS0, COMMAND_PORT);\r\nde620_ready(dev);\r\n#ifdef LOWSPEED\r\noutb(WRITE_DELAY, DATA_PORT);\r\n#else\r\noutb(0, DATA_PORT);\r\n#endif\r\nde620_flip_ds(dev);\r\nde620_ready(dev);\r\n#ifdef LOWSPEED\r\noutb(READ_DELAY, DATA_PORT);\r\n#else\r\noutb(0, DATA_PORT);\r\n#endif\r\nde620_flip_ds(dev);\r\n}\r\nstatic inline void\r\nde620_set_register(struct net_device *dev, byte reg, byte value)\r\n{\r\nde620_ready(dev);\r\noutb(reg, DATA_PORT);\r\noutb(NIC_Cmd ^ CS0, COMMAND_PORT);\r\nde620_put_byte(dev, value);\r\n}\r\nstatic inline byte\r\nde620_get_register(struct net_device *dev, byte reg)\r\n{\r\nbyte value;\r\nde620_send_command(dev,reg);\r\nvalue = de620_read_byte(dev);\r\nde620_send_command(dev,W_DUMMY);\r\nreturn value;\r\n}\r\nstatic int de620_open(struct net_device *dev)\r\n{\r\nint ret = request_irq(dev->irq, de620_interrupt, 0, dev->name, dev);\r\nif (ret) {\r\nprintk (KERN_ERR "%s: unable to get IRQ %d\n", dev->name, dev->irq);\r\nreturn ret;\r\n}\r\nif (adapter_init(dev)) {\r\nret = -EIO;\r\ngoto out_free_irq;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_free_irq:\r\nfree_irq(dev->irq, dev);\r\nreturn ret;\r\n}\r\nstatic int de620_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nde620_set_register(dev, W_TCR, RXOFF);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void de620_set_multicast_list(struct net_device *dev)\r\n{\r\nif (!netdev_mc_empty(dev) || dev->flags&(IFF_ALLMULTI|IFF_PROMISC))\r\n{\r\nde620_set_register(dev, W_TCR, (TCR_DEF & ~RXPBM) | RXALL);\r\n}\r\nelse\r\n{\r\nde620_set_register(dev, W_TCR, TCR_DEF);\r\n}\r\n}\r\nstatic void de620_timeout(struct net_device *dev)\r\n{\r\nprintk(KERN_WARNING "%s: transmit timed out, %s?\n", dev->name, "network cable problem");\r\nif (!adapter_init(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int de620_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nint len;\r\nbyte *buffer = skb->data;\r\nbyte using_txbuf;\r\nusing_txbuf = de620_tx_buffs(dev);\r\nnetif_stop_queue(dev);\r\nif ((len = skb->len) < RUNT)\r\nlen = RUNT;\r\nif (len & 1)\r\n++len;\r\nspin_lock_irqsave(&de620_lock, flags);\r\npr_debug("de620_start_xmit: len=%d, bufs 0x%02x\n",\r\n(int)skb->len, using_txbuf);\r\nswitch (using_txbuf) {\r\ndefault:\r\ncase TXBF1:\r\nde620_send_command(dev,W_CR | RW0);\r\nusing_txbuf |= TXBF0;\r\nbreak;\r\ncase TXBF0:\r\nde620_send_command(dev,W_CR | RW1);\r\nusing_txbuf |= TXBF1;\r\nbreak;\r\ncase (TXBF0 | TXBF1):\r\nprintk(KERN_WARNING "%s: No tx-buffer available!\n", dev->name);\r\nspin_unlock_irqrestore(&de620_lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nde620_write_block(dev, buffer, skb->len, len-skb->len);\r\nif(!(using_txbuf == (TXBF0 | TXBF1)))\r\nnetif_wake_queue(dev);\r\ndev->stats.tx_packets++;\r\nspin_unlock_irqrestore(&de620_lock, flags);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\nde620_interrupt(int irq_in, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nbyte irq_status;\r\nint bogus_count = 0;\r\nint again = 0;\r\nspin_lock(&de620_lock);\r\nirq_status = de620_get_register(dev, R_STS);\r\npr_debug("de620_interrupt (%2.2X)\n", irq_status);\r\nif (irq_status & RXGOOD) {\r\ndo {\r\nagain = de620_rx_intr(dev);\r\npr_debug("again=%d\n", again);\r\n}\r\nwhile (again && (++bogus_count < 100));\r\n}\r\nif(de620_tx_buffs(dev) != (TXBF0 | TXBF1))\r\nnetif_wake_queue(dev);\r\nspin_unlock(&de620_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int de620_rx_intr(struct net_device *dev)\r\n{\r\nstruct header_buf {\r\nbyte status;\r\nbyte Rx_NextPage;\r\nunsigned short Rx_ByteCount;\r\n} header_buf;\r\nstruct sk_buff *skb;\r\nint size;\r\nbyte *buffer;\r\nbyte pagelink;\r\nbyte curr_page;\r\npr_debug("de620_rx_intr: next_rx_page = %d\n", next_rx_page);\r\nde620_send_command(dev, W_CR | RRN);\r\nde620_set_register(dev, W_RSA1, next_rx_page);\r\nde620_set_register(dev, W_RSA0, 0);\r\nde620_read_block(dev, (byte *)&header_buf, sizeof(struct header_buf));\r\npr_debug("page status=0x%02x, nextpage=%d, packetsize=%d\n",\r\nheader_buf.status, header_buf.Rx_NextPage,\r\nheader_buf.Rx_ByteCount);\r\npagelink = header_buf.Rx_NextPage;\r\nif ((pagelink < first_rx_page) || (last_rx_page < pagelink)) {\r\nprintk(KERN_WARNING "%s: Ring overrun? Restoring...\n", dev->name);\r\nadapter_init(dev);\r\nnetif_wake_queue(dev);\r\ndev->stats.rx_over_errors++;\r\nreturn 0;\r\n}\r\npagelink = next_rx_page +\r\n((header_buf.Rx_ByteCount + (4 - 1 + 0x100)) >> 8);\r\nif (pagelink > last_rx_page)\r\npagelink -= (last_rx_page - first_rx_page + 1);\r\nif (pagelink != header_buf.Rx_NextPage) {\r\nprintk(KERN_WARNING "%s: Page link out of sync! Restoring...\n", dev->name);\r\nnext_rx_page = header_buf.Rx_NextPage;\r\nde620_send_command(dev, W_DUMMY);\r\nde620_set_register(dev, W_NPRF, next_rx_page);\r\ndev->stats.rx_over_errors++;\r\nreturn 0;\r\n}\r\nnext_rx_page = pagelink;\r\nsize = header_buf.Rx_ByteCount - 4;\r\nif ((size < RUNT) || (GIANT < size)) {\r\nprintk(KERN_WARNING "%s: Illegal packet size: %d!\n", dev->name, size);\r\n}\r\nelse {\r\nskb = netdev_alloc_skb(dev, size + 2);\r\nif (skb == NULL) {\r\nprintk(KERN_WARNING "%s: Couldn't allocate a sk_buff of size %d.\n", dev->name, size);\r\ndev->stats.rx_dropped++;\r\n}\r\nelse {\r\nskb_reserve(skb,2);\r\nbuffer = skb_put(skb,size);\r\nde620_read_block(dev, buffer, size);\r\npr_debug("Read %d bytes\n", size);\r\nskb->protocol=eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += size;\r\n}\r\n}\r\ncurr_page = de620_get_register(dev, R_CPR);\r\nde620_set_register(dev, W_NPRF, next_rx_page);\r\npr_debug("next_rx_page=%d CPR=%d\n", next_rx_page, curr_page);\r\nreturn next_rx_page != curr_page;\r\n}\r\nstatic int adapter_init(struct net_device *dev)\r\n{\r\nint i;\r\nstatic int was_down;\r\nif ((nic_data.Model == 3) || (nic_data.Model == 0)) {\r\nEIPRegister = NCTL0;\r\nif (nic_data.Media != 1)\r\nEIPRegister |= NIS0;\r\n}\r\nelse if (nic_data.Model == 2) {\r\nEIPRegister = NCTL0 | NIS0;\r\n}\r\nif (utp)\r\nEIPRegister = NCTL0 | NIS0;\r\nif (bnc)\r\nEIPRegister = NCTL0;\r\nde620_send_command(dev, W_CR | RNOP | CLEAR);\r\nde620_send_command(dev, W_CR | RNOP);\r\nde620_set_register(dev, W_SCR, SCR_DEF);\r\nde620_set_register(dev, W_TCR, RXOFF);\r\nfor (i = 0; i < 6; ++i) {\r\nde620_set_register(dev, W_PAR0 + i, dev->dev_addr[i]);\r\n}\r\nde620_set_register(dev, W_EIP, EIPRegister);\r\nnext_rx_page = first_rx_page = DE620_RX_START_PAGE;\r\nif (nic_data.RAM_Size)\r\nlast_rx_page = nic_data.RAM_Size - 1;\r\nelse\r\nlast_rx_page = 255;\r\nde620_set_register(dev, W_SPR, first_rx_page);\r\nde620_set_register(dev, W_EPR, last_rx_page);\r\nde620_set_register(dev, W_CPR, first_rx_page);\r\nde620_send_command(dev, W_NPR | first_rx_page);\r\nde620_send_command(dev, W_DUMMY);\r\nde620_set_delay(dev);\r\n#define CHECK_MASK ( 0 | TXSUC | T16 | 0 | RXCRC | RXSHORT | 0 | 0 )\r\n#define CHECK_OK ( 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 )\r\nif (((i = de620_get_register(dev, R_STS)) & CHECK_MASK) != CHECK_OK) {\r\nprintk(KERN_ERR "%s: Something has happened to the DE-620! Please check it"\r\n#ifdef SHUTDOWN_WHEN_LOST\r\n" and do a new ifconfig"\r\n#endif\r\n"! (%02x)\n", dev->name, i);\r\n#ifdef SHUTDOWN_WHEN_LOST\r\ndev->flags &= ~IFF_UP;\r\nde620_close(dev);\r\n#endif\r\nwas_down = 1;\r\nreturn 1;\r\n}\r\nif (was_down) {\r\nprintk(KERN_WARNING "%s: Thanks, I feel much better now!\n", dev->name);\r\nwas_down = 0;\r\n}\r\nde620_set_register(dev, W_TCR, TCR_DEF);\r\nreturn 0;\r\n}\r\nstruct net_device * __init de620_probe(int unit)\r\n{\r\nbyte checkbyte = 0xa5;\r\nstruct net_device *dev;\r\nint err = -ENOMEM;\r\nint i;\r\ndev = alloc_etherdev(0);\r\nif (!dev)\r\ngoto out;\r\nspin_lock_init(&de620_lock);\r\ndev->base_addr = io;\r\ndev->irq = irq;\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\npr_debug("%s", version);\r\nprintk(KERN_INFO "D-Link DE-620 pocket adapter");\r\nif (!request_region(dev->base_addr, 3, "de620")) {\r\nprintk(" io 0x%3lX, which is busy.\n", dev->base_addr);\r\nerr = -EBUSY;\r\ngoto out1;\r\n}\r\nNIC_Cmd = DEF_NIC_CMD;\r\nde620_set_register(dev, W_EIP, EIPRegister);\r\nde620_set_register(dev, W_CPR, checkbyte);\r\ncheckbyte = de620_get_register(dev, R_CPR);\r\nif ((checkbyte != 0xa5) || (read_eeprom(dev) != 0)) {\r\nprintk(" not identified in the printer port\n");\r\nerr = -ENODEV;\r\ngoto out2;\r\n}\r\ndev->dev_addr[0] = nic_data.NodeID[0];\r\nfor (i = 1; i < ETH_ALEN; i++) {\r\ndev->dev_addr[i] = nic_data.NodeID[i];\r\ndev->broadcast[i] = 0xff;\r\n}\r\nprintk(", Ethernet Address: %pM", dev->dev_addr);\r\nprintk(" (%dk RAM,",\r\n(nic_data.RAM_Size) ? (nic_data.RAM_Size >> 2) : 64);\r\nif (nic_data.Media == 1)\r\nprintk(" BNC)\n");\r\nelse\r\nprintk(" UTP)\n");\r\ndev->netdev_ops = &de620_netdev_ops;\r\ndev->watchdog_timeo = HZ*2;\r\npr_debug("\nEEPROM contents:\n"\r\n"RAM_Size = 0x%02X\n"\r\n"NodeID = %pM\n"\r\n"Model = %d\n"\r\n"Media = %d\n"\r\n"SCR = 0x%02x\n", nic_data.RAM_Size, nic_data.NodeID,\r\nnic_data.Model, nic_data.Media, nic_data.SCR);\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out2;\r\nreturn dev;\r\nout2:\r\nrelease_region(dev->base_addr, 3);\r\nout1:\r\nfree_netdev(dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic unsigned short __init ReadAWord(struct net_device *dev, int from)\r\n{\r\nunsigned short data;\r\nint nbits;\r\nsendit(dev, 0); sendit(dev, 1); sendit(dev, 5); sendit(dev, 4);\r\nfor (nbits = 9; nbits > 0; --nbits, from <<= 1) {\r\nif (from & 0x0100) {\r\nsendit(dev, 6); sendit(dev, 7); sendit(dev, 7); sendit(dev, 6);\r\n}\r\nelse {\r\nsendit(dev, 4); sendit(dev, 5); sendit(dev, 5); sendit(dev, 4);\r\n}\r\n}\r\nfor (data = 0, nbits = 16; nbits > 0; --nbits) {\r\nsendit(dev, 4); sendit(dev, 5); sendit(dev, 5); sendit(dev, 4);\r\ndata = (data << 1) | ((de620_get_register(dev, R_STS) & EEDI) >> 7);\r\n}\r\nsendit(dev, 0); sendit(dev, 1); sendit(dev, 1); sendit(dev, 0);\r\nreturn data;\r\n}\r\nstatic int __init read_eeprom(struct net_device *dev)\r\n{\r\nunsigned short wrd;\r\nwrd = ReadAWord(dev, 0x1aa);\r\nif (!clone && (wrd != htons(0x0080)))\r\nreturn -1;\r\nnic_data.NodeID[0] = wrd & 0xff;\r\nnic_data.NodeID[1] = wrd >> 8;\r\nwrd = ReadAWord(dev, 0x1ab);\r\nif (!clone && ((wrd & 0xff) != 0xc8))\r\nreturn -1;\r\nnic_data.NodeID[2] = wrd & 0xff;\r\nnic_data.NodeID[3] = wrd >> 8;\r\nwrd = ReadAWord(dev, 0x1ac);\r\nnic_data.NodeID[4] = wrd & 0xff;\r\nnic_data.NodeID[5] = wrd >> 8;\r\nwrd = ReadAWord(dev, 0x1ad);\r\nnic_data.RAM_Size = (wrd >> 8);\r\nwrd = ReadAWord(dev, 0x1ae);\r\nnic_data.Model = (wrd & 0xff);\r\nwrd = ReadAWord(dev, 0x1af);\r\nnic_data.Media = (wrd & 0xff);\r\nwrd = ReadAWord(dev, 0x1a8);\r\nnic_data.SCR = (wrd >> 8);\r\nreturn 0;\r\n}\r\nint __init init_module(void)\r\n{\r\nde620_dev = de620_probe(-1);\r\nif (IS_ERR(de620_dev))\r\nreturn PTR_ERR(de620_dev);\r\nreturn 0;\r\n}\r\nvoid cleanup_module(void)\r\n{\r\nunregister_netdev(de620_dev);\r\nrelease_region(de620_dev->base_addr, 3);\r\nfree_netdev(de620_dev);\r\n}
