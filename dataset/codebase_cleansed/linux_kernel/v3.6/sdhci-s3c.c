static inline struct sdhci_s3c *to_s3c(struct sdhci_host *host)\r\n{\r\nreturn sdhci_priv(host);\r\n}\r\nstatic u32 get_curclk(u32 ctrl2)\r\n{\r\nctrl2 &= S3C_SDHCI_CTRL2_SELBASECLK_MASK;\r\nctrl2 >>= S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;\r\nreturn ctrl2;\r\n}\r\nstatic void sdhci_s3c_check_sclk(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nu32 tmp = readl(host->ioaddr + S3C_SDHCI_CONTROL2);\r\nif (get_curclk(tmp) != ourhost->cur_clk) {\r\ndev_dbg(&ourhost->pdev->dev, "restored ctrl2 clock setting\n");\r\ntmp &= ~S3C_SDHCI_CTRL2_SELBASECLK_MASK;\r\ntmp |= ourhost->cur_clk << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;\r\nwritel(tmp, host->ioaddr + S3C_SDHCI_CONTROL2);\r\n}\r\n}\r\nstatic unsigned int sdhci_s3c_get_max_clk(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nstruct clk *busclk;\r\nunsigned int rate, max;\r\nint clk;\r\nsdhci_s3c_check_sclk(host);\r\nfor (max = 0, clk = 0; clk < MAX_BUS_CLK; clk++) {\r\nbusclk = ourhost->clk_bus[clk];\r\nif (!busclk)\r\ncontinue;\r\nrate = clk_get_rate(busclk);\r\nif (rate > max)\r\nmax = rate;\r\n}\r\nreturn max;\r\n}\r\nstatic unsigned int sdhci_s3c_consider_clock(struct sdhci_s3c *ourhost,\r\nunsigned int src,\r\nunsigned int wanted)\r\n{\r\nunsigned long rate;\r\nstruct clk *clksrc = ourhost->clk_bus[src];\r\nint div;\r\nif (!clksrc)\r\nreturn UINT_MAX;\r\nif (ourhost->host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK) {\r\nrate = clk_round_rate(clksrc, wanted);\r\nreturn wanted - rate;\r\n}\r\nrate = clk_get_rate(clksrc);\r\nfor (div = 1; div < 256; div *= 2) {\r\nif ((rate / div) <= wanted)\r\nbreak;\r\n}\r\ndev_dbg(&ourhost->pdev->dev, "clk %d: rate %ld, want %d, got %ld\n",\r\nsrc, rate, wanted, rate / div);\r\nreturn (wanted - (rate / div));\r\n}\r\nstatic void sdhci_s3c_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nunsigned int best = UINT_MAX;\r\nunsigned int delta;\r\nint best_src = 0;\r\nint src;\r\nu32 ctrl;\r\nif (clock == 0)\r\nreturn;\r\nfor (src = 0; src < MAX_BUS_CLK; src++) {\r\ndelta = sdhci_s3c_consider_clock(ourhost, src, clock);\r\nif (delta < best) {\r\nbest = delta;\r\nbest_src = src;\r\n}\r\n}\r\ndev_dbg(&ourhost->pdev->dev,\r\n"selected source %d, clock %d, delta %d\n",\r\nbest_src, clock, best);\r\nif (ourhost->cur_clk != best_src) {\r\nstruct clk *clk = ourhost->clk_bus[best_src];\r\nwritew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);\r\nourhost->cur_clk = best_src;\r\nhost->max_clk = clk_get_rate(clk);\r\nctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);\r\nctrl &= ~S3C_SDHCI_CTRL2_SELBASECLK_MASK;\r\nctrl |= best_src << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;\r\nwritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);\r\n}\r\nwritel(S3C64XX_SDHCI_CONTROL4_DRIVE_9mA,\r\nhost->ioaddr + S3C64XX_SDHCI_CONTROL4);\r\nctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);\r\nctrl |= (S3C64XX_SDHCI_CTRL2_ENSTAASYNCCLR |\r\nS3C64XX_SDHCI_CTRL2_ENCMDCNFMSK |\r\nS3C_SDHCI_CTRL2_ENFBCLKRX |\r\nS3C_SDHCI_CTRL2_DFCNT_NONE |\r\nS3C_SDHCI_CTRL2_ENCLKOUTHOLD);\r\nwritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);\r\nctrl = (S3C_SDHCI_CTRL3_FCSEL1 | S3C_SDHCI_CTRL3_FCSEL0);\r\nif (clock < 25 * 1000000)\r\nctrl |= (S3C_SDHCI_CTRL3_FCSEL3 | S3C_SDHCI_CTRL3_FCSEL2);\r\nwritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL3);\r\n}\r\nstatic unsigned int sdhci_s3c_get_min_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nunsigned int delta, min = UINT_MAX;\r\nint src;\r\nfor (src = 0; src < MAX_BUS_CLK; src++) {\r\ndelta = sdhci_s3c_consider_clock(ourhost, src, 0);\r\nif (delta == UINT_MAX)\r\ncontinue;\r\nif (-delta < min)\r\nmin = -delta;\r\n}\r\nreturn min;\r\n}\r\nstatic unsigned int sdhci_cmu_get_max_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nreturn clk_round_rate(ourhost->clk_bus[ourhost->cur_clk], UINT_MAX);\r\n}\r\nstatic unsigned int sdhci_cmu_get_min_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nreturn clk_round_rate(ourhost->clk_bus[ourhost->cur_clk], 400000);\r\n}\r\nstatic void sdhci_cmu_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nunsigned long timeout;\r\nu16 clk = 0;\r\nif (clock == 0)\r\nreturn;\r\nsdhci_s3c_set_clock(host, clock);\r\nclk_set_rate(ourhost->clk_bus[ourhost->cur_clk], clock);\r\nhost->clock = clock;\r\nclk = SDHCI_CLOCK_INT_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\ntimeout = 20;\r\nwhile (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))\r\n& SDHCI_CLOCK_INT_STABLE)) {\r\nif (timeout == 0) {\r\nprintk(KERN_ERR "%s: Internal clock never "\r\n"stabilised.\n", mmc_hostname(host->mmc));\r\nreturn;\r\n}\r\ntimeout--;\r\nmdelay(1);\r\n}\r\nclk |= SDHCI_CLOCK_CARD_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\n}\r\nstatic int sdhci_s3c_platform_8bit_width(struct sdhci_host *host, int width)\r\n{\r\nu8 ctrl;\r\nctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\r\nswitch (width) {\r\ncase MMC_BUS_WIDTH_8:\r\nctrl |= SDHCI_CTRL_8BITBUS;\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nctrl |= SDHCI_CTRL_4BITBUS;\r\nctrl &= ~SDHCI_CTRL_8BITBUS;\r\nbreak;\r\ndefault:\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\nctrl &= ~SDHCI_CTRL_8BITBUS;\r\nbreak;\r\n}\r\nsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\r\nreturn 0;\r\n}\r\nstatic void sdhci_s3c_notify_change(struct platform_device *dev, int state)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(dev);\r\nunsigned long flags;\r\nif (host) {\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (state) {\r\ndev_dbg(&dev->dev, "card inserted.\n");\r\nhost->flags &= ~SDHCI_DEVICE_DEAD;\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\n} else {\r\ndev_dbg(&dev->dev, "card removed.\n");\r\nhost->flags |= SDHCI_DEVICE_DEAD;\r\nhost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\n}\r\ntasklet_schedule(&host->card_tasklet);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\n}\r\nstatic irqreturn_t sdhci_s3c_gpio_card_detect_thread(int irq, void *dev_id)\r\n{\r\nstruct sdhci_s3c *sc = dev_id;\r\nint status = gpio_get_value(sc->ext_cd_gpio);\r\nif (sc->pdata->ext_cd_gpio_invert)\r\nstatus = !status;\r\nsdhci_s3c_notify_change(sc->pdev, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sdhci_s3c_setup_card_detect_gpio(struct sdhci_s3c *sc)\r\n{\r\nstruct s3c_sdhci_platdata *pdata = sc->pdata;\r\nstruct device *dev = &sc->pdev->dev;\r\nif (gpio_request(pdata->ext_cd_gpio, "SDHCI EXT CD") == 0) {\r\nsc->ext_cd_gpio = pdata->ext_cd_gpio;\r\nsc->ext_cd_irq = gpio_to_irq(pdata->ext_cd_gpio);\r\nif (sc->ext_cd_irq &&\r\nrequest_threaded_irq(sc->ext_cd_irq, NULL,\r\nsdhci_s3c_gpio_card_detect_thread,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(dev), sc) == 0) {\r\nint status = gpio_get_value(sc->ext_cd_gpio);\r\nif (pdata->ext_cd_gpio_invert)\r\nstatus = !status;\r\nsdhci_s3c_notify_change(sc->pdev, status);\r\n} else {\r\ndev_warn(dev, "cannot request irq for card detect\n");\r\nsc->ext_cd_irq = 0;\r\n}\r\n} else {\r\ndev_err(dev, "cannot request gpio for card detect\n");\r\n}\r\n}\r\nstatic inline struct sdhci_s3c_drv_data *sdhci_s3c_get_driver_data(\r\nstruct platform_device *pdev)\r\n{\r\nreturn (struct sdhci_s3c_drv_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nstatic int __devinit sdhci_s3c_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c_sdhci_platdata *pdata;\r\nstruct sdhci_s3c_drv_data *drv_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct sdhci_host *host;\r\nstruct sdhci_s3c *sc;\r\nstruct resource *res;\r\nint ret, irq, ptr, clks;\r\nif (!pdev->dev.platform_data) {\r\ndev_err(dev, "no device data specified\n");\r\nreturn -ENOENT;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "no irq specified\n");\r\nreturn irq;\r\n}\r\nhost = sdhci_alloc_host(dev, sizeof(struct sdhci_s3c));\r\nif (IS_ERR(host)) {\r\ndev_err(dev, "sdhci_alloc_host() failed\n");\r\nreturn PTR_ERR(host);\r\n}\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\nret = -ENOMEM;\r\ngoto err_io_clk;\r\n}\r\nmemcpy(pdata, pdev->dev.platform_data, sizeof(*pdata));\r\ndrv_data = sdhci_s3c_get_driver_data(pdev);\r\nsc = sdhci_priv(host);\r\nsc->host = host;\r\nsc->pdev = pdev;\r\nsc->pdata = pdata;\r\nsc->ext_cd_gpio = -1;\r\nplatform_set_drvdata(pdev, host);\r\nsc->clk_io = clk_get(dev, "hsmmc");\r\nif (IS_ERR(sc->clk_io)) {\r\ndev_err(dev, "failed to get io clock\n");\r\nret = PTR_ERR(sc->clk_io);\r\ngoto err_io_clk;\r\n}\r\nclk_enable(sc->clk_io);\r\nfor (clks = 0, ptr = 0; ptr < MAX_BUS_CLK; ptr++) {\r\nstruct clk *clk;\r\nchar name[14];\r\nsnprintf(name, 14, "mmc_busclk.%d", ptr);\r\nclk = clk_get(dev, name);\r\nif (IS_ERR(clk)) {\r\ncontinue;\r\n}\r\nclks++;\r\nsc->clk_bus[ptr] = clk;\r\nsc->cur_clk = ptr;\r\nclk_enable(clk);\r\ndev_info(dev, "clock source %d: %s (%ld Hz)\n",\r\nptr, name, clk_get_rate(clk));\r\n}\r\nif (clks == 0) {\r\ndev_err(dev, "failed to find any bus clocks\n");\r\nret = -ENOENT;\r\ngoto err_no_busclks;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->ioaddr = devm_request_and_ioremap(&pdev->dev, res);\r\nif (!host->ioaddr) {\r\ndev_err(dev, "failed to map registers\n");\r\nret = -ENXIO;\r\ngoto err_req_regs;\r\n}\r\nif (pdata->cfg_gpio)\r\npdata->cfg_gpio(pdev, pdata->max_width);\r\nhost->hw_name = "samsung-hsmmc";\r\nhost->ops = &sdhci_s3c_ops;\r\nhost->quirks = 0;\r\nhost->irq = irq;\r\nhost->quirks |= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC;\r\nhost->quirks |= SDHCI_QUIRK_NO_HISPD_BIT;\r\nif (drv_data)\r\nhost->quirks |= drv_data->sdhci_quirks;\r\n#ifndef CONFIG_MMC_SDHCI_S3C_DMA\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_DMA;\r\n#endif\r\nhost->quirks |= SDHCI_QUIRK_NO_BUSY_IRQ;\r\nhost->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC;\r\nif (pdata->cd_type == S3C_SDHCI_CD_NONE ||\r\npdata->cd_type == S3C_SDHCI_CD_PERMANENT)\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nif (pdata->cd_type == S3C_SDHCI_CD_PERMANENT)\r\nhost->mmc->caps = MMC_CAP_NONREMOVABLE;\r\nswitch (pdata->max_width) {\r\ncase 8:\r\nhost->mmc->caps |= MMC_CAP_8_BIT_DATA;\r\ncase 4:\r\nhost->mmc->caps |= MMC_CAP_4_BIT_DATA;\r\nbreak;\r\n}\r\nif (pdata->pm_caps)\r\nhost->mmc->pm_caps |= pdata->pm_caps;\r\nhost->quirks |= (SDHCI_QUIRK_32BIT_DMA_ADDR |\r\nSDHCI_QUIRK_32BIT_DMA_SIZE);\r\nhost->quirks |= SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK;\r\nif (host->quirks & SDHCI_QUIRK_NONSTANDARD_CLOCK) {\r\nsdhci_s3c_ops.set_clock = sdhci_cmu_set_clock;\r\nsdhci_s3c_ops.get_min_clock = sdhci_cmu_get_min_clock;\r\nsdhci_s3c_ops.get_max_clock = sdhci_cmu_get_max_clock;\r\n}\r\nif (pdata->host_caps)\r\nhost->mmc->caps |= pdata->host_caps;\r\nif (pdata->host_caps2)\r\nhost->mmc->caps2 |= pdata->host_caps2;\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 50);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_suspend_ignore_children(&pdev->dev, 1);\r\nret = sdhci_add_host(host);\r\nif (ret) {\r\ndev_err(dev, "sdhci_add_host() failed\n");\r\npm_runtime_forbid(&pdev->dev);\r\npm_runtime_get_noresume(&pdev->dev);\r\ngoto err_req_regs;\r\n}\r\nif (pdata->cd_type == S3C_SDHCI_CD_EXTERNAL && pdata->ext_cd_init)\r\npdata->ext_cd_init(&sdhci_s3c_notify_change);\r\nif (pdata->cd_type == S3C_SDHCI_CD_GPIO &&\r\ngpio_is_valid(pdata->ext_cd_gpio))\r\nsdhci_s3c_setup_card_detect_gpio(sc);\r\nreturn 0;\r\nerr_req_regs:\r\nfor (ptr = 0; ptr < MAX_BUS_CLK; ptr++) {\r\nif (sc->clk_bus[ptr]) {\r\nclk_disable(sc->clk_bus[ptr]);\r\nclk_put(sc->clk_bus[ptr]);\r\n}\r\n}\r\nerr_no_busclks:\r\nclk_disable(sc->clk_io);\r\nclk_put(sc->clk_io);\r\nerr_io_clk:\r\nsdhci_free_host(host);\r\nreturn ret;\r\n}\r\nstatic int __devexit sdhci_s3c_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c_sdhci_platdata *pdata = pdev->dev.platform_data;\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_s3c *sc = sdhci_priv(host);\r\nint ptr;\r\nif (pdata->cd_type == S3C_SDHCI_CD_EXTERNAL && pdata->ext_cd_cleanup)\r\npdata->ext_cd_cleanup(&sdhci_s3c_notify_change);\r\nif (sc->ext_cd_irq)\r\nfree_irq(sc->ext_cd_irq, sc);\r\nif (gpio_is_valid(sc->ext_cd_gpio))\r\ngpio_free(sc->ext_cd_gpio);\r\nsdhci_remove_host(host, 1);\r\npm_runtime_disable(&pdev->dev);\r\nfor (ptr = 0; ptr < 3; ptr++) {\r\nif (sc->clk_bus[ptr]) {\r\nclk_disable(sc->clk_bus[ptr]);\r\nclk_put(sc->clk_bus[ptr]);\r\n}\r\n}\r\nclk_disable(sc->clk_io);\r\nclk_put(sc->clk_io);\r\nsdhci_free_host(host);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int sdhci_s3c_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nreturn sdhci_suspend_host(host);\r\n}\r\nstatic int sdhci_s3c_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nreturn sdhci_resume_host(host);\r\n}\r\nstatic int sdhci_s3c_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nreturn sdhci_runtime_suspend_host(host);\r\n}\r\nstatic int sdhci_s3c_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nreturn sdhci_runtime_resume_host(host);\r\n}
