static void wake_up_event_readers(struct service_processor *sp)\r\n{\r\nstruct event_reader *reader;\r\nlist_for_each_entry(reader, &sp->event_buffer->readers, node)\r\nwake_up_interruptible(&reader->wait);\r\n}\r\nvoid ibmasm_receive_event(struct service_processor *sp, void *data, unsigned int data_size)\r\n{\r\nstruct event_buffer *buffer = sp->event_buffer;\r\nstruct ibmasm_event *event;\r\nunsigned long flags;\r\ndata_size = min(data_size, IBMASM_EVENT_MAX_SIZE);\r\nspin_lock_irqsave(&sp->lock, flags);\r\nevent = &buffer->events[buffer->next_index];\r\nmemcpy_fromio(event->data, data, data_size);\r\nevent->data_size = data_size;\r\nevent->serial_number = buffer->next_serial_number;\r\nbuffer->next_index = (buffer->next_index + 1) % IBMASM_NUM_EVENTS;\r\nbuffer->next_serial_number++;\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\nwake_up_event_readers(sp);\r\n}\r\nstatic inline int event_available(struct event_buffer *b, struct event_reader *r)\r\n{\r\nreturn (r->next_serial_number < b->next_serial_number);\r\n}\r\nint ibmasm_get_next_event(struct service_processor *sp, struct event_reader *reader)\r\n{\r\nstruct event_buffer *buffer = sp->event_buffer;\r\nstruct ibmasm_event *event;\r\nunsigned int index;\r\nunsigned long flags;\r\nreader->cancelled = 0;\r\nif (wait_event_interruptible(reader->wait,\r\nevent_available(buffer, reader) || reader->cancelled))\r\nreturn -ERESTARTSYS;\r\nif (!event_available(buffer, reader))\r\nreturn 0;\r\nspin_lock_irqsave(&sp->lock, flags);\r\nindex = buffer->next_index;\r\nevent = &buffer->events[index];\r\nwhile (event->serial_number < reader->next_serial_number) {\r\nindex = (index + 1) % IBMASM_NUM_EVENTS;\r\nevent = &buffer->events[index];\r\n}\r\nmemcpy(reader->data, event->data, event->data_size);\r\nreader->data_size = event->data_size;\r\nreader->next_serial_number = event->serial_number + 1;\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\nreturn event->data_size;\r\n}\r\nvoid ibmasm_cancel_next_event(struct event_reader *reader)\r\n{\r\nreader->cancelled = 1;\r\nwake_up_interruptible(&reader->wait);\r\n}\r\nvoid ibmasm_event_reader_register(struct service_processor *sp, struct event_reader *reader)\r\n{\r\nunsigned long flags;\r\nreader->next_serial_number = sp->event_buffer->next_serial_number;\r\ninit_waitqueue_head(&reader->wait);\r\nspin_lock_irqsave(&sp->lock, flags);\r\nlist_add(&reader->node, &sp->event_buffer->readers);\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\n}\r\nvoid ibmasm_event_reader_unregister(struct service_processor *sp, struct event_reader *reader)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sp->lock, flags);\r\nlist_del(&reader->node);\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\n}\r\nint ibmasm_event_buffer_init(struct service_processor *sp)\r\n{\r\nstruct event_buffer *buffer;\r\nstruct ibmasm_event *event;\r\nint i;\r\nbuffer = kmalloc(sizeof(struct event_buffer), GFP_KERNEL);\r\nif (!buffer)\r\nreturn 1;\r\nbuffer->next_index = 0;\r\nbuffer->next_serial_number = 1;\r\nevent = buffer->events;\r\nfor (i=0; i<IBMASM_NUM_EVENTS; i++, event++)\r\nevent->serial_number = 0;\r\nINIT_LIST_HEAD(&buffer->readers);\r\nsp->event_buffer = buffer;\r\nreturn 0;\r\n}\r\nvoid ibmasm_event_buffer_exit(struct service_processor *sp)\r\n{\r\nkfree(sp->event_buffer);\r\n}
