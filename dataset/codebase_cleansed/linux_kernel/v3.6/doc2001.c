static void DoC_Delay(void __iomem * docptr, unsigned short cycles)\r\n{\r\nvolatile char dummy;\r\nint i;\r\nfor (i = 0; i < cycles; i++)\r\ndummy = ReadDOC(docptr, NOP);\r\n}\r\nstatic int _DoC_WaitReady(void __iomem * docptr)\r\n{\r\nunsigned short c = 0xffff;\r\npr_debug("_DoC_WaitReady called for out-of-line wait\n");\r\nwhile (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B) && --c)\r\n;\r\nif (c == 0)\r\npr_debug("_DoC_WaitReady timed out.\n");\r\nreturn (c == 0);\r\n}\r\nstatic inline int DoC_WaitReady(void __iomem * docptr)\r\n{\r\nint ret = 0;\r\nDoC_Delay(docptr, 4);\r\nif (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B))\r\nret = _DoC_WaitReady(docptr);\r\nDoC_Delay(docptr, 2);\r\nreturn ret;\r\n}\r\nstatic void DoC_Command(void __iomem * docptr, unsigned char command,\r\nunsigned char xtraflags)\r\n{\r\nWriteDOC(xtraflags | CDSN_CTRL_CLE | CDSN_CTRL_CE, docptr, CDSNControl);\r\nDoC_Delay(docptr, 4);\r\nWriteDOC(command, docptr, Mil_CDSN_IO);\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\nWriteDOC(xtraflags | CDSN_CTRL_CE, docptr, CDSNControl);\r\nDoC_Delay(docptr, 4);\r\n}\r\nstatic inline void DoC_Address(void __iomem * docptr, int numbytes, unsigned long ofs,\r\nunsigned char xtraflags1, unsigned char xtraflags2)\r\n{\r\nWriteDOC(xtraflags1 | CDSN_CTRL_ALE | CDSN_CTRL_CE, docptr, CDSNControl);\r\nDoC_Delay(docptr, 4);\r\nswitch (numbytes)\r\n{\r\ncase 1:\r\nWriteDOC(ofs & 0xff, docptr, Mil_CDSN_IO);\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\nbreak;\r\ncase 2:\r\nWriteDOC((ofs >> 9) & 0xff, docptr, Mil_CDSN_IO);\r\nWriteDOC((ofs >> 17) & 0xff, docptr, Mil_CDSN_IO);\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\nbreak;\r\ncase 3:\r\nWriteDOC(ofs & 0xff, docptr, Mil_CDSN_IO);\r\nWriteDOC((ofs >> 9) & 0xff, docptr, Mil_CDSN_IO);\r\nWriteDOC((ofs >> 17) & 0xff, docptr, Mil_CDSN_IO);\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nWriteDOC(xtraflags1 | xtraflags2 | CDSN_CTRL_CE, docptr, CDSNControl);\r\nDoC_Delay(docptr, 4);\r\n}\r\nstatic int DoC_SelectChip(void __iomem * docptr, int chip)\r\n{\r\nWriteDOC(chip, docptr, CDSNDeviceSelect);\r\nDoC_Delay(docptr, 4);\r\nreturn DoC_WaitReady(docptr);\r\n}\r\nstatic int DoC_SelectFloor(void __iomem * docptr, int floor)\r\n{\r\nWriteDOC(floor, docptr, FloorSelect);\r\nreturn DoC_WaitReady(docptr);\r\n}\r\nstatic int DoC_IdentChip(struct DiskOnChip *doc, int floor, int chip)\r\n{\r\nint mfr, id, i, j;\r\nvolatile char dummy;\r\nDoC_SelectFloor(doc->virtadr, floor);\r\nDoC_SelectChip(doc->virtadr, chip);\r\nDoC_Command(doc->virtadr, NAND_CMD_RESET, CDSN_CTRL_WP);\r\nDoC_WaitReady(doc->virtadr);\r\nDoC_Command(doc->virtadr, NAND_CMD_READID, CDSN_CTRL_WP);\r\nDoC_Address(doc->virtadr, 1, 0x00, CDSN_CTRL_WP, 0x00);\r\ndummy = ReadDOC(doc->virtadr, ReadPipeInit);\r\nDoC_Delay(doc->virtadr, 2);\r\nmfr = ReadDOC(doc->virtadr, Mil_CDSN_IO);\r\nDoC_Delay(doc->virtadr, 2);\r\nid = ReadDOC(doc->virtadr, Mil_CDSN_IO);\r\ndummy = ReadDOC(doc->virtadr, LastDataRead);\r\nif (mfr == 0xff || mfr == 0)\r\nreturn 0;\r\nfor (i = 0; nand_flash_ids[i].name != NULL; i++) {\r\nif ( id == nand_flash_ids[i].id) {\r\nfor (j = 0; nand_manuf_ids[j].id != 0x0; j++) {\r\nif (nand_manuf_ids[j].id == mfr)\r\nbreak;\r\n}\r\nprintk(KERN_INFO "Flash chip found: Manufacturer ID: %2.2X, "\r\n"Chip ID: %2.2X (%s:%s)\n",\r\nmfr, id, nand_manuf_ids[j].name, nand_flash_ids[i].name);\r\ndoc->mfr = mfr;\r\ndoc->id = id;\r\ndoc->chipshift = ffs((nand_flash_ids[i].chipsize << 20)) - 1;\r\nbreak;\r\n}\r\n}\r\nif (nand_flash_ids[i].name == NULL)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic void DoC_ScanChips(struct DiskOnChip *this)\r\n{\r\nint floor, chip;\r\nint numchips[MAX_FLOORS_MIL];\r\nint ret;\r\nthis->numchips = 0;\r\nthis->mfr = 0;\r\nthis->id = 0;\r\nfor (floor = 0,ret = 1; floor < MAX_FLOORS_MIL; floor++) {\r\nnumchips[floor] = 0;\r\nfor (chip = 0; chip < MAX_CHIPS_MIL && ret != 0; chip++) {\r\nret = DoC_IdentChip(this, floor, chip);\r\nif (ret) {\r\nnumchips[floor]++;\r\nthis->numchips++;\r\n}\r\n}\r\n}\r\nif (!this->numchips) {\r\nprintk("No flash chips recognised.\n");\r\nreturn;\r\n}\r\nthis->chips = kmalloc(sizeof(struct Nand) * this->numchips, GFP_KERNEL);\r\nif (!this->chips){\r\nprintk("No memory for allocating chip info structures\n");\r\nreturn;\r\n}\r\nfor (floor = 0, ret = 0; floor < MAX_FLOORS_MIL; floor++) {\r\nfor (chip = 0 ; chip < numchips[floor] ; chip++) {\r\nthis->chips[ret].floor = floor;\r\nthis->chips[ret].chip = chip;\r\nthis->chips[ret].curadr = 0;\r\nthis->chips[ret].curmode = 0x50;\r\nret++;\r\n}\r\n}\r\nthis->totlen = this->numchips * (1 << this->chipshift);\r\nprintk(KERN_INFO "%d flash chips found. Total DiskOnChip size: %ld MiB\n",\r\nthis->numchips ,this->totlen >> 20);\r\n}\r\nstatic int DoCMil_is_alias(struct DiskOnChip *doc1, struct DiskOnChip *doc2)\r\n{\r\nint tmp1, tmp2, retval;\r\nif (doc1->physadr == doc2->physadr)\r\nreturn 1;\r\ntmp1 = ReadDOC(doc1->virtadr, AliasResolution);\r\ntmp2 = ReadDOC(doc2->virtadr, AliasResolution);\r\nif (tmp1 != tmp2)\r\nreturn 0;\r\nWriteDOC((tmp1+1) % 0xff, doc1->virtadr, AliasResolution);\r\ntmp2 = ReadDOC(doc2->virtadr, AliasResolution);\r\nif (tmp2 == (tmp1+1) % 0xff)\r\nretval = 1;\r\nelse\r\nretval = 0;\r\nWriteDOC(tmp1, doc1->virtadr, AliasResolution);\r\nreturn retval;\r\n}\r\nvoid DoCMil_init(struct mtd_info *mtd)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nstruct DiskOnChip *old = NULL;\r\nif (docmillist)\r\nold = docmillist->priv;\r\nwhile (old) {\r\nif (DoCMil_is_alias(this, old)) {\r\nprintk(KERN_NOTICE "Ignoring DiskOnChip Millennium at "\r\n"0x%lX - already configured\n", this->physadr);\r\niounmap(this->virtadr);\r\nkfree(mtd);\r\nreturn;\r\n}\r\nif (old->nextdoc)\r\nold = old->nextdoc->priv;\r\nelse\r\nold = NULL;\r\n}\r\nmtd->name = "DiskOnChip Millennium";\r\nprintk(KERN_NOTICE "DiskOnChip Millennium found at address 0x%lX\n",\r\nthis->physadr);\r\nmtd->type = MTD_NANDFLASH;\r\nmtd->flags = MTD_CAP_NANDFLASH;\r\nmtd->erasesize = 0x2000;\r\nmtd->writebufsize = mtd->writesize = 512;\r\nmtd->oobsize = 16;\r\nmtd->ecc_strength = 2;\r\nmtd->owner = THIS_MODULE;\r\nmtd->_erase = doc_erase;\r\nmtd->_read = doc_read;\r\nmtd->_write = doc_write;\r\nmtd->_read_oob = doc_read_oob;\r\nmtd->_write_oob = doc_write_oob;\r\nthis->curfloor = -1;\r\nthis->curchip = -1;\r\nDoC_ScanChips(this);\r\nif (!this->totlen) {\r\nkfree(mtd);\r\niounmap(this->virtadr);\r\n} else {\r\nthis->nextdoc = docmillist;\r\ndocmillist = mtd;\r\nmtd->size = this->totlen;\r\nmtd_device_register(mtd, NULL, 0);\r\nreturn;\r\n}\r\n}\r\nstatic int doc_read (struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nint i, ret;\r\nvolatile char dummy;\r\nunsigned char syndrome[6], eccbuf[6];\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem *docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[from >> (this->chipshift)];\r\nif (from + len > ((from | 0x1ff) + 1))\r\nlen = ((from | 0x1ff) + 1) - from;\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nDoC_Command(docptr, (from >> 8) & 1, CDSN_CTRL_WP);\r\nDoC_Address(docptr, 3, from, CDSN_CTRL_WP, 0x00);\r\nDoC_WaitReady(docptr);\r\nWriteDOC (DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC (DOC_ECC_EN, docptr, ECCConf);\r\ndummy = ReadDOC(docptr, ReadPipeInit);\r\n#ifndef USE_MEMCPY\r\nfor (i = 0; i < len-1; i++) {\r\nbuf[i] = ReadDOC(docptr, Mil_CDSN_IO + (i & 0xff));\r\n}\r\n#else\r\nmemcpy_fromio(buf, docptr + DoC_Mil_CDSN_IO, len - 1);\r\n#endif\r\nbuf[len - 1] = ReadDOC(docptr, LastDataRead);\r\n*retlen = len;\r\nret = 0;\r\ndummy = ReadDOC(docptr, ReadPipeInit);\r\n#ifndef USE_MEMCPY\r\nfor (i = 0; i < 5; i++) {\r\neccbuf[i] = ReadDOC(docptr, Mil_CDSN_IO + i);\r\n}\r\n#else\r\nmemcpy_fromio(eccbuf, docptr + DoC_Mil_CDSN_IO, 5);\r\n#endif\r\neccbuf[5] = ReadDOC(docptr, LastDataRead);\r\ndummy = ReadDOC(docptr, ECCConf);\r\ndummy = ReadDOC(docptr, ECCConf);\r\nif (ReadDOC(docptr, ECCConf) & 0x80) {\r\nint nb_errors;\r\n#ifdef ECC_DEBUG\r\nprintk("DiskOnChip ECC Error: Read at %lx\n", (long)from);\r\n#endif\r\nfor (i = 0; i < 6; i++) {\r\nsyndrome[i] = ReadDOC(docptr, ECCSyndrome0 + i);\r\n}\r\nnb_errors = doc_decode_ecc(buf, syndrome);\r\n#ifdef ECC_DEBUG\r\nprintk("ECC Errors corrected: %x\n", nb_errors);\r\n#endif\r\nif (nb_errors < 0) {\r\nret = -EIO;\r\n}\r\n}\r\n#ifdef PSYCHO_DEBUG\r\nprintk("ECC DATA at %lx: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",\r\n(long)from, eccbuf[0], eccbuf[1], eccbuf[2], eccbuf[3],\r\neccbuf[4], eccbuf[5]);\r\n#endif\r\nWriteDOC(DOC_ECC_DIS, docptr , ECCConf);\r\nreturn ret;\r\n}\r\nstatic int doc_write (struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nint i,ret = 0;\r\nchar eccbuf[6];\r\nvolatile char dummy;\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem *docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[to >> (this->chipshift)];\r\n#if 0\r\nif (to + len > ( (to | 0x1ff) + 1))\r\nlen = ((to | 0x1ff) + 1) - to;\r\n#else\r\nif (to & 0x1ff || len != 0x200)\r\nreturn -EINVAL;\r\n#endif\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nDoC_Command(docptr, NAND_CMD_RESET, 0x00);\r\nDoC_WaitReady(docptr);\r\nDoC_Command(docptr, NAND_CMD_READ0, 0x00);\r\nDoC_Command(docptr, NAND_CMD_SEQIN, 0x00);\r\nDoC_Address(docptr, 3, to, 0x00, 0x00);\r\nDoC_WaitReady(docptr);\r\nWriteDOC (DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC (DOC_ECC_EN | DOC_ECC_RW, docptr, ECCConf);\r\n#ifndef USE_MEMCPY\r\nfor (i = 0; i < len; i++) {\r\nWriteDOC(buf[i], docptr, Mil_CDSN_IO + i);\r\n}\r\n#else\r\nmemcpy_toio(docptr + DoC_Mil_CDSN_IO, buf, len);\r\n#endif\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\nWriteDOC(0, docptr, NOP);\r\nWriteDOC(0, docptr, NOP);\r\nWriteDOC(0, docptr, NOP);\r\nfor (i = 0; i < 6; i++) {\r\neccbuf[i] = ReadDOC(docptr, ECCSyndrome0 + i);\r\n}\r\nWriteDOC(DOC_ECC_DIS, docptr , ECCConf);\r\n#ifndef USE_MEMCPY\r\nfor (i = 0; i < 6; i++) {\r\nWriteDOC(eccbuf[i], docptr, Mil_CDSN_IO + i);\r\n}\r\n#else\r\nmemcpy_toio(docptr + DoC_Mil_CDSN_IO, eccbuf, 6);\r\n#endif\r\nWriteDOC(0x55, docptr, Mil_CDSN_IO);\r\nWriteDOC(0x55, docptr, Mil_CDSN_IO + 1);\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\n#ifdef PSYCHO_DEBUG\r\nprintk("OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",\r\n(long) to, eccbuf[0], eccbuf[1], eccbuf[2], eccbuf[3],\r\neccbuf[4], eccbuf[5]);\r\n#endif\r\nDoC_Command(docptr, NAND_CMD_PAGEPROG, 0x00);\r\nDoC_WaitReady(docptr);\r\nDoC_Command(docptr, NAND_CMD_STATUS, CDSN_CTRL_WP);\r\ndummy = ReadDOC(docptr, ReadPipeInit);\r\nDoC_Delay(docptr, 2);\r\nif (ReadDOC(docptr, Mil_CDSN_IO) & 1) {\r\nprintk("Error programming flash\n");\r\nret = -EIO;\r\n}\r\ndummy = ReadDOC(docptr, LastDataRead);\r\n*retlen = len;\r\nreturn ret;\r\n}\r\nstatic int doc_read_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\n#ifndef USE_MEMCPY\r\nint i;\r\n#endif\r\nvolatile char dummy;\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem *docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[ofs >> this->chipshift];\r\nuint8_t *buf = ops->oobbuf;\r\nsize_t len = ops->len;\r\nBUG_ON(ops->mode != MTD_OPS_PLACE_OOB);\r\nofs += ops->ooboffs;\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nWriteDOC (DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC (DOC_ECC_DIS, docptr, ECCConf);\r\nDoC_Command(docptr, NAND_CMD_READOOB, CDSN_CTRL_WP);\r\nDoC_Address(docptr, 3, ofs, CDSN_CTRL_WP, 0x00);\r\nDoC_WaitReady(docptr);\r\ndummy = ReadDOC(docptr, ReadPipeInit);\r\n#ifndef USE_MEMCPY\r\nfor (i = 0; i < len-1; i++) {\r\nbuf[i] = ReadDOC(docptr, Mil_CDSN_IO + i);\r\n}\r\n#else\r\nmemcpy_fromio(buf, docptr + DoC_Mil_CDSN_IO, len - 1);\r\n#endif\r\nbuf[len - 1] = ReadDOC(docptr, LastDataRead);\r\nops->retlen = len;\r\nreturn 0;\r\n}\r\nstatic int doc_write_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\n#ifndef USE_MEMCPY\r\nint i;\r\n#endif\r\nvolatile char dummy;\r\nint ret = 0;\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem *docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[ofs >> this->chipshift];\r\nuint8_t *buf = ops->oobbuf;\r\nsize_t len = ops->len;\r\nBUG_ON(ops->mode != MTD_OPS_PLACE_OOB);\r\nofs += ops->ooboffs;\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nWriteDOC (DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC (DOC_ECC_DIS, docptr, ECCConf);\r\nDoC_Command(docptr, NAND_CMD_RESET, CDSN_CTRL_WP);\r\nDoC_WaitReady(docptr);\r\nDoC_Command(docptr, NAND_CMD_READOOB, CDSN_CTRL_WP);\r\nDoC_Command(docptr, NAND_CMD_SEQIN, 0x00);\r\nDoC_Address(docptr, 3, ofs, 0x00, 0x00);\r\n#ifndef USE_MEMCPY\r\nfor (i = 0; i < len; i++) {\r\nWriteDOC(buf[i], docptr, Mil_CDSN_IO + i);\r\n}\r\n#else\r\nmemcpy_toio(docptr + DoC_Mil_CDSN_IO, buf, len);\r\n#endif\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\nDoC_Command(docptr, NAND_CMD_PAGEPROG, 0x00);\r\nDoC_WaitReady(docptr);\r\nDoC_Command(docptr, NAND_CMD_STATUS, 0x00);\r\ndummy = ReadDOC(docptr, ReadPipeInit);\r\nDoC_Delay(docptr, 2);\r\nif (ReadDOC(docptr, Mil_CDSN_IO) & 1) {\r\nprintk("Error programming oob data\n");\r\nops->retlen = 0;\r\nret = -EIO;\r\n}\r\ndummy = ReadDOC(docptr, LastDataRead);\r\nops->retlen = len;\r\nreturn ret;\r\n}\r\nint doc_erase (struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nvolatile char dummy;\r\nstruct DiskOnChip *this = mtd->priv;\r\n__u32 ofs = instr->addr;\r\n__u32 len = instr->len;\r\nvoid __iomem *docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[ofs >> this->chipshift];\r\nif (len != mtd->erasesize)\r\nprintk(KERN_WARNING "Erase not right size (%x != %x)n",\r\nlen, mtd->erasesize);\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(docptr, mychip->floor);\r\nDoC_SelectChip(docptr, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(docptr, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\ninstr->state = MTD_ERASE_PENDING;\r\nDoC_Command(docptr, NAND_CMD_ERASE1, 0x00);\r\nDoC_Address(docptr, 2, ofs, 0x00, 0x00);\r\nDoC_Command(docptr, NAND_CMD_ERASE2, 0x00);\r\nDoC_WaitReady(docptr);\r\ninstr->state = MTD_ERASING;\r\nDoC_Command(docptr, NAND_CMD_STATUS, CDSN_CTRL_WP);\r\ndummy = ReadDOC(docptr, ReadPipeInit);\r\nDoC_Delay(docptr, 2);\r\nif (ReadDOC(docptr, Mil_CDSN_IO) & 1) {\r\nprintk("Error Erasing at 0x%x\n", ofs);\r\ninstr->state = MTD_ERASE_FAILED;\r\n} else\r\ninstr->state = MTD_ERASE_DONE;\r\ndummy = ReadDOC(docptr, LastDataRead);\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_doc2001(void)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct DiskOnChip *this;\r\nwhile ((mtd=docmillist)) {\r\nthis = mtd->priv;\r\ndocmillist = this->nextdoc;\r\nmtd_device_unregister(mtd);\r\niounmap(this->virtadr);\r\nkfree(this->chips);\r\nkfree(mtd);\r\n}\r\n}
