int\r\nsgl_to_sgl_fcnvfu(\r\nsgl_floating_point *srcptr,\r\nunsigned int *nullptr,\r\nunsigned int *dstptr,\r\nunsigned int *status)\r\n{\r\nregister unsigned int src, result;\r\nregister int src_exponent;\r\nregister boolean inexact = FALSE;\r\nsrc = *srcptr;\r\nsrc_exponent = Sgl_exponent(src) - SGL_BIAS;\r\nif (src_exponent > SGL_FX_MAX_EXP + 1) {\r\nif (Sgl_isone_sign(src)) {\r\nresult = 0;\r\n} else {\r\nresult = 0xffffffff;\r\n}\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nif (src_exponent >= 0) {\r\nif (Sgl_isone_sign(src)) {\r\nresult = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nSgl_clear_signexponent_set_hidden(src);\r\nSuint_from_sgl_mantissa(src,src_exponent,result);\r\nif (Sgl_isinexact_to_unsigned(src,src_exponent)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nresult++;\r\nbreak;\r\ncase ROUNDMINUS:\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (Sgl_isone_roundbit(src,src_exponent) &&\r\n(Sgl_isone_stickybit(src,src_exponent) ||\r\n(result & 1))) {\r\nresult++;\r\n}\r\nbreak;\r\n}\r\n}\r\n} else {\r\nresult = 0;\r\nif (Sgl_isnotzero_exponentmantissa(src)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(src)) {\r\nresult++;\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(src)) {\r\nresult = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\ninexact = FALSE;\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (src_exponent == -1 &&\r\nSgl_isnotzero_mantissa(src)) {\r\nif (Sgl_isone_sign(src)) {\r\nresult = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\ninexact = FALSE;\r\n}\r\nelse result++;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n*dstptr = result;\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\nsgl_to_dbl_fcnvfu(\r\nsgl_floating_point *srcptr,\r\nunsigned int *nullptr,\r\ndbl_unsigned *dstptr,\r\nunsigned int *status)\r\n{\r\nregister int src_exponent;\r\nregister unsigned int src, resultp1, resultp2;\r\nregister boolean inexact = FALSE;\r\nsrc = *srcptr;\r\nsrc_exponent = Sgl_exponent(src) - SGL_BIAS;\r\nif (src_exponent > DBL_FX_MAX_EXP + 1) {\r\nif (Sgl_isone_sign(src)) {\r\nresultp1 = resultp2 = 0;\r\n} else {\r\nresultp1 = resultp2 = 0xffffffff;\r\n}\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\nDuint_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\nif (src_exponent >= 0) {\r\nif (Sgl_isone_sign(src)) {\r\nresultp1 = resultp2 = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\nDuint_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\nSgl_clear_signexponent_set_hidden(src);\r\nDuint_from_sgl_mantissa(src,src_exponent,resultp1,resultp2);\r\nif (Sgl_isinexact_to_unsigned(src,src_exponent)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nDuint_increment(resultp1,resultp2);\r\nbreak;\r\ncase ROUNDMINUS:\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (Sgl_isone_roundbit(src,src_exponent) &&\r\n(Sgl_isone_stickybit(src,src_exponent) ||\r\nDuint_isone_lowp2(resultp2))) {\r\nDuint_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\n}\r\n}\r\n} else {\r\nDuint_setzero(resultp1,resultp2);\r\nif (Sgl_isnotzero_exponentmantissa(src)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(src)) {\r\nDuint_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(src)) {\r\nresultp1 = resultp2 = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\ninexact = FALSE;\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (src_exponent == -1 &&\r\nSgl_isnotzero_mantissa(src)) {\r\nif (Sgl_isone_sign(src)) {\r\nresultp1 = 0;\r\nresultp2 = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\ninexact = FALSE;\r\n}\r\nelse Duint_increment(resultp1,resultp2);\r\n}\r\n}\r\n}\r\n}\r\nDuint_copytoptr(resultp1,resultp2,dstptr);\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\ndbl_to_sgl_fcnvfu (dbl_floating_point * srcptr, unsigned int *nullptr,\r\nunsigned int *dstptr, unsigned int *status)\r\n{\r\nregister unsigned int srcp1, srcp2, result;\r\nregister int src_exponent;\r\nregister boolean inexact = FALSE;\r\nDbl_copyfromptr(srcptr,srcp1,srcp2);\r\nsrc_exponent = Dbl_exponent(srcp1) - DBL_BIAS;\r\nif (src_exponent > SGL_FX_MAX_EXP + 1) {\r\nif (Dbl_isone_sign(srcp1)) {\r\nresult = 0;\r\n} else {\r\nresult = 0xffffffff;\r\n}\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nif (src_exponent >= 0) {\r\nif (Dbl_isone_sign(srcp1)) {\r\nresult = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nDbl_clear_signexponent_set_hidden(srcp1);\r\nSuint_from_dbl_mantissa(srcp1,srcp2,src_exponent,result);\r\nif (Dbl_isinexact_to_unsigned(srcp1,srcp2,src_exponent)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nresult++;\r\nbreak;\r\ncase ROUNDMINUS:\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif(Dbl_isone_roundbit(srcp1,srcp2,src_exponent) &&\r\n(Dbl_isone_stickybit(srcp1,srcp2,src_exponent)||\r\nresult&1))\r\nresult++;\r\nbreak;\r\n}\r\nif (result == 0) {\r\nresult = 0xffffffff;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\n} else {\r\nresult = 0;\r\nif (Dbl_isnotzero_exponentmantissa(srcp1,srcp2)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Dbl_iszero_sign(srcp1)) result++;\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Dbl_isone_sign(srcp1)) {\r\nresult = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\ninexact = FALSE;\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (src_exponent == -1 &&\r\nDbl_isnotzero_mantissa(srcp1,srcp2))\r\nif (Dbl_isone_sign(srcp1)) {\r\nresult = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\ninexact = FALSE;\r\n}\r\nelse result++;\r\n}\r\n}\r\n}\r\n*dstptr = result;\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\ndbl_to_dbl_fcnvfu (dbl_floating_point * srcptr, unsigned int *nullptr,\r\ndbl_unsigned * dstptr, unsigned int *status)\r\n{\r\nregister int src_exponent;\r\nregister unsigned int srcp1, srcp2, resultp1, resultp2;\r\nregister boolean inexact = FALSE;\r\nDbl_copyfromptr(srcptr,srcp1,srcp2);\r\nsrc_exponent = Dbl_exponent(srcp1) - DBL_BIAS;\r\nif (src_exponent > DBL_FX_MAX_EXP + 1) {\r\nif (Dbl_isone_sign(srcp1)) {\r\nresultp1 = resultp2 = 0;\r\n} else {\r\nresultp1 = resultp2 = 0xffffffff;\r\n}\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\nDuint_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\nif (src_exponent >= 0) {\r\nif (Dbl_isone_sign(srcp1)) {\r\nresultp1 = resultp2 = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\nDuint_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\nDbl_clear_signexponent_set_hidden(srcp1);\r\nDuint_from_dbl_mantissa(srcp1,srcp2,src_exponent,resultp1,\r\nresultp2);\r\nif (Dbl_isinexact_to_unsigned(srcp1,srcp2,src_exponent)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nDuint_increment(resultp1,resultp2);\r\nbreak;\r\ncase ROUNDMINUS:\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif(Dbl_isone_roundbit(srcp1,srcp2,src_exponent))\r\nif(Dbl_isone_stickybit(srcp1,srcp2,src_exponent) ||\r\nDuint_isone_lowp2(resultp2))\r\nDuint_increment(resultp1,resultp2);\r\n}\r\n}\r\n} else {\r\nDuint_setzero(resultp1,resultp2);\r\nif (Dbl_isnotzero_exponentmantissa(srcp1,srcp2)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Dbl_iszero_sign(srcp1)) {\r\nDuint_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Dbl_isone_sign(srcp1)) {\r\nresultp1 = resultp2 = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\ninexact = FALSE;\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (src_exponent == -1 &&\r\nDbl_isnotzero_mantissa(srcp1,srcp2))\r\nif (Dbl_iszero_sign(srcp1)) {\r\nDuint_increment(resultp1,resultp2);\r\n} else {\r\nresultp1 = 0;\r\nresultp2 = 0;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\ninexact = FALSE;\r\n}\r\n}\r\n}\r\n}\r\nDuint_copytoptr(resultp1,resultp2,dstptr);\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}
