static inline bool synth_writable(void)\r\n{\r\nreturn inb_p(synth_port_control) & SYNTH_WRITABLE;\r\n}\r\nstatic inline bool synth_full(void)\r\n{\r\nreturn inb_p(speakup_info.port_tts + UART_RX) == 'F';\r\n}\r\nstatic const char *synth_immediate(struct spk_synth *synth, const char *buf)\r\n{\r\nu_char ch;\r\nwhile ((ch = *buf)) {\r\nint timeout = SPK_XMITR_TIMEOUT;\r\nif (ch == '\n')\r\nch = PROCSPEECH;\r\nif (synth_full())\r\nreturn buf;\r\nwhile (synth_writable()) {\r\nif (!--timeout)\r\nreturn buf;\r\nudelay(1);\r\n}\r\noutb_p(ch, speakup_info.port_tts);\r\nbuf++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_catch_up(struct spk_synth *synth)\r\n{\r\nu_char ch;\r\nunsigned long flags;\r\nunsigned long jiff_max;\r\nint timeout;\r\nint delay_time_val;\r\nint jiffy_delta_val;\r\nint full_time_val;\r\nstruct var_t *delay_time;\r\nstruct var_t *full_time;\r\nstruct var_t *jiffy_delta;\r\njiffy_delta = get_var(JIFFY);\r\ndelay_time = get_var(DELAY);\r\nfull_time = get_var(FULL);\r\nspk_lock(flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nspk_unlock(flags);\r\njiff_max = jiffies + jiffy_delta_val;\r\nwhile (!kthread_should_stop()) {\r\nspk_lock(flags);\r\nif (speakup_info.flushing) {\r\nspeakup_info.flushing = 0;\r\nspk_unlock(flags);\r\nsynth->flush(synth);\r\ncontinue;\r\n}\r\nif (synth_buffer_empty()) {\r\nspk_unlock(flags);\r\nbreak;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nfull_time_val = full_time->u.n.value;\r\nspk_unlock(flags);\r\nif (synth_full()) {\r\nschedule_timeout(msecs_to_jiffies(full_time_val));\r\ncontinue;\r\n}\r\nset_current_state(TASK_RUNNING);\r\ntimeout = SPK_XMITR_TIMEOUT;\r\nwhile (synth_writable()) {\r\nif (!--timeout)\r\nbreak;\r\nudelay(1);\r\n}\r\nspk_lock(flags);\r\nch = synth_buffer_getc();\r\nspk_unlock(flags);\r\nif (ch == '\n')\r\nch = PROCSPEECH;\r\noutb_p(ch, speakup_info.port_tts);\r\nif (jiffies >= jiff_max && ch == SPACE) {\r\ntimeout = SPK_XMITR_TIMEOUT;\r\nwhile (synth_writable()) {\r\nif (!--timeout)\r\nbreak;\r\nudelay(1);\r\n}\r\noutb_p(PROCSPEECH, speakup_info.port_tts);\r\nspk_lock(flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\ndelay_time_val = delay_time->u.n.value;\r\nspk_unlock(flags);\r\nschedule_timeout(msecs_to_jiffies(delay_time_val));\r\njiff_max = jiffies+jiffy_delta_val;\r\n}\r\n}\r\ntimeout = SPK_XMITR_TIMEOUT;\r\nwhile (synth_writable()) {\r\nif (!--timeout)\r\nbreak;\r\nudelay(1);\r\n}\r\noutb_p(PROCSPEECH, speakup_info.port_tts);\r\n}\r\nstatic void synth_flush(struct spk_synth *synth)\r\n{\r\noutb_p(SYNTH_CLEAR, speakup_info.port_tts);\r\n}\r\nstatic int synth_probe(struct spk_synth *synth)\r\n{\r\nunsigned int port_val = 0;\r\nint i = 0;\r\npr_info("Probing for %s.\n", synth->long_name);\r\nif (port_forced) {\r\nspeakup_info.port_tts = port_forced;\r\npr_info("probe forced to %x by kernel command line\n",\r\nspeakup_info.port_tts);\r\nif (synth_request_region(speakup_info.port_tts-1,\r\nSYNTH_IO_EXTENT)) {\r\npr_warn("sorry, port already reserved\n");\r\nreturn -EBUSY;\r\n}\r\nport_val = inw(speakup_info.port_tts-1);\r\nsynth_port_control = speakup_info.port_tts-1;\r\n} else {\r\nfor (i = 0; synth_portlist[i]; i++) {\r\nif (synth_request_region(synth_portlist[i],\r\nSYNTH_IO_EXTENT)) {\r\npr_warn\r\n("request_region: failed with 0x%x, %d\n",\r\nsynth_portlist[i], SYNTH_IO_EXTENT);\r\ncontinue;\r\n}\r\nport_val = inw(synth_portlist[i]) & 0xfffc;\r\nif (port_val == 0x53fc) {\r\nsynth_port_control = synth_portlist[i];\r\nspeakup_info.port_tts = synth_port_control+1;\r\nbreak;\r\n}\r\n}\r\n}\r\nport_val &= 0xfffc;\r\nif (port_val != 0x53fc) {\r\npr_info("%s: not found\n", synth->long_name);\r\nsynth_release_region(synth_port_control, SYNTH_IO_EXTENT);\r\nsynth_port_control = 0;\r\nreturn -ENODEV;\r\n}\r\npr_info("%s: %03x-%03x, driver version %s,\n", synth->long_name,\r\nsynth_port_control, synth_port_control+SYNTH_IO_EXTENT-1,\r\nsynth->version);\r\nsynth->alive = 1;\r\nreturn 0;\r\n}\r\nstatic void accent_release(void)\r\n{\r\nif (speakup_info.port_tts)\r\nsynth_release_region(speakup_info.port_tts-1, SYNTH_IO_EXTENT);\r\nspeakup_info.port_tts = 0;\r\n}\r\nstatic int __init acntpc_init(void)\r\n{\r\nreturn synth_add(&synth_acntpc);\r\n}\r\nstatic void __exit acntpc_exit(void)\r\n{\r\nsynth_remove(&synth_acntpc);\r\n}
