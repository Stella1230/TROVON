static struct uts_namespace *create_uts_ns(void)\r\n{\r\nstruct uts_namespace *uts_ns;\r\nuts_ns = kmalloc(sizeof(struct uts_namespace), GFP_KERNEL);\r\nif (uts_ns)\r\nkref_init(&uts_ns->kref);\r\nreturn uts_ns;\r\n}\r\nstatic struct uts_namespace *clone_uts_ns(struct task_struct *tsk,\r\nstruct uts_namespace *old_ns)\r\n{\r\nstruct uts_namespace *ns;\r\nns = create_uts_ns();\r\nif (!ns)\r\nreturn ERR_PTR(-ENOMEM);\r\ndown_read(&uts_sem);\r\nmemcpy(&ns->name, &old_ns->name, sizeof(ns->name));\r\nns->user_ns = get_user_ns(task_cred_xxx(tsk, user_ns));\r\nup_read(&uts_sem);\r\nreturn ns;\r\n}\r\nstruct uts_namespace *copy_utsname(unsigned long flags,\r\nstruct task_struct *tsk)\r\n{\r\nstruct uts_namespace *old_ns = tsk->nsproxy->uts_ns;\r\nstruct uts_namespace *new_ns;\r\nBUG_ON(!old_ns);\r\nget_uts_ns(old_ns);\r\nif (!(flags & CLONE_NEWUTS))\r\nreturn old_ns;\r\nnew_ns = clone_uts_ns(tsk, old_ns);\r\nput_uts_ns(old_ns);\r\nreturn new_ns;\r\n}\r\nvoid free_uts_ns(struct kref *kref)\r\n{\r\nstruct uts_namespace *ns;\r\nns = container_of(kref, struct uts_namespace, kref);\r\nput_user_ns(ns->user_ns);\r\nkfree(ns);\r\n}\r\nstatic void *utsns_get(struct task_struct *task)\r\n{\r\nstruct uts_namespace *ns = NULL;\r\nstruct nsproxy *nsproxy;\r\nrcu_read_lock();\r\nnsproxy = task_nsproxy(task);\r\nif (nsproxy) {\r\nns = nsproxy->uts_ns;\r\nget_uts_ns(ns);\r\n}\r\nrcu_read_unlock();\r\nreturn ns;\r\n}\r\nstatic void utsns_put(void *ns)\r\n{\r\nput_uts_ns(ns);\r\n}\r\nstatic int utsns_install(struct nsproxy *nsproxy, void *ns)\r\n{\r\nget_uts_ns(ns);\r\nput_uts_ns(nsproxy->uts_ns);\r\nnsproxy->uts_ns = ns;\r\nreturn 0;\r\n}
