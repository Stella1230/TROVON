static struct scsi_tape *scsi_tape_get(int dev)\r\n{\r\nstruct scsi_tape *STp = NULL;\r\nmutex_lock(&st_ref_mutex);\r\nwrite_lock(&st_dev_arr_lock);\r\nif (dev < st_dev_max && scsi_tapes != NULL)\r\nSTp = scsi_tapes[dev];\r\nif (!STp) goto out;\r\nkref_get(&STp->kref);\r\nif (!STp->device)\r\ngoto out_put;\r\nif (scsi_device_get(STp->device))\r\ngoto out_put;\r\ngoto out;\r\nout_put:\r\nkref_put(&STp->kref, scsi_tape_release);\r\nSTp = NULL;\r\nout:\r\nwrite_unlock(&st_dev_arr_lock);\r\nmutex_unlock(&st_ref_mutex);\r\nreturn STp;\r\n}\r\nstatic void scsi_tape_put(struct scsi_tape *STp)\r\n{\r\nstruct scsi_device *sdev = STp->device;\r\nmutex_lock(&st_ref_mutex);\r\nkref_put(&STp->kref, scsi_tape_release);\r\nscsi_device_put(sdev);\r\nmutex_unlock(&st_ref_mutex);\r\n}\r\nstatic char * st_incompatible(struct scsi_device* SDp)\r\n{\r\nstruct st_reject_data *rp;\r\nfor (rp=&(reject_list[0]); rp->vendor != NULL; rp++)\r\nif (!strncmp(rp->vendor, SDp->vendor, strlen(rp->vendor)) &&\r\n!strncmp(rp->model, SDp->model, strlen(rp->model)) &&\r\n!strncmp(rp->rev, SDp->rev, strlen(rp->rev))) {\r\nif (rp->driver_hint)\r\nreturn rp->driver_hint;\r\nelse\r\nreturn "unknown";\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline char *tape_name(struct scsi_tape *tape)\r\n{\r\nreturn tape->disk->disk_name;\r\n}\r\nstatic void st_analyze_sense(struct st_request *SRpnt, struct st_cmdstatus *s)\r\n{\r\nconst u8 *ucp;\r\nconst u8 *sense = SRpnt->sense;\r\ns->have_sense = scsi_normalize_sense(SRpnt->sense,\r\nSCSI_SENSE_BUFFERSIZE, &s->sense_hdr);\r\ns->flags = 0;\r\nif (s->have_sense) {\r\ns->deferred = 0;\r\ns->remainder_valid =\r\nscsi_get_sense_info_fld(sense, SCSI_SENSE_BUFFERSIZE, &s->uremainder64);\r\nswitch (sense[0] & 0x7f) {\r\ncase 0x71:\r\ns->deferred = 1;\r\ncase 0x70:\r\ns->fixed_format = 1;\r\ns->flags = sense[2] & 0xe0;\r\nbreak;\r\ncase 0x73:\r\ns->deferred = 1;\r\ncase 0x72:\r\ns->fixed_format = 0;\r\nucp = scsi_sense_desc_find(sense, SCSI_SENSE_BUFFERSIZE, 4);\r\ns->flags = ucp ? (ucp[3] & 0xe0) : 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int st_chk_result(struct scsi_tape *STp, struct st_request * SRpnt)\r\n{\r\nint result = SRpnt->result;\r\nu8 scode;\r\nDEB(const char *stp;)\r\nchar *name = tape_name(STp);\r\nstruct st_cmdstatus *cmdstatp;\r\nif (!result)\r\nreturn 0;\r\ncmdstatp = &STp->buffer->cmdstat;\r\nst_analyze_sense(SRpnt, cmdstatp);\r\nif (cmdstatp->have_sense)\r\nscode = STp->buffer->cmdstat.sense_hdr.sense_key;\r\nelse\r\nscode = 0;\r\nDEB(\r\nif (debugging) {\r\nprintk(ST_DEB_MSG "%s: Error: %x, cmd: %x %x %x %x %x %x\n",\r\nname, result,\r\nSRpnt->cmd[0], SRpnt->cmd[1], SRpnt->cmd[2],\r\nSRpnt->cmd[3], SRpnt->cmd[4], SRpnt->cmd[5]);\r\nif (cmdstatp->have_sense)\r\n__scsi_print_sense(name, SRpnt->sense, SCSI_SENSE_BUFFERSIZE);\r\n} )\r\nif (!debugging) {\r\nif (!cmdstatp->have_sense)\r\nprintk(KERN_WARNING\r\n"%s: Error %x (driver bt 0x%x, host bt 0x%x).\n",\r\nname, result, driver_byte(result),\r\nhost_byte(result));\r\nelse if (cmdstatp->have_sense &&\r\nscode != NO_SENSE &&\r\nscode != RECOVERED_ERROR &&\r\nscode != BLANK_CHECK &&\r\nscode != VOLUME_OVERFLOW &&\r\nSRpnt->cmd[0] != MODE_SENSE &&\r\nSRpnt->cmd[0] != TEST_UNIT_READY) {\r\n__scsi_print_sense(name, SRpnt->sense, SCSI_SENSE_BUFFERSIZE);\r\n}\r\n}\r\nif (cmdstatp->fixed_format &&\r\nSTp->cln_mode >= EXTENDED_SENSE_START) {\r\nif (STp->cln_sense_value)\r\nSTp->cleaning_req |= ((SRpnt->sense[STp->cln_mode] &\r\nSTp->cln_sense_mask) == STp->cln_sense_value);\r\nelse\r\nSTp->cleaning_req |= ((SRpnt->sense[STp->cln_mode] &\r\nSTp->cln_sense_mask) != 0);\r\n}\r\nif (cmdstatp->have_sense &&\r\ncmdstatp->sense_hdr.asc == 0 && cmdstatp->sense_hdr.ascq == 0x17)\r\nSTp->cleaning_req = 1;\r\nSTp->pos_unknown |= STp->device->was_reset;\r\nif (cmdstatp->have_sense &&\r\nscode == RECOVERED_ERROR\r\n#if ST_RECOVERED_WRITE_FATAL\r\n&& SRpnt->cmd[0] != WRITE_6\r\n&& SRpnt->cmd[0] != WRITE_FILEMARKS\r\n#endif\r\n) {\r\nSTp->recover_count++;\r\nSTp->recover_reg++;\r\nDEB(\r\nif (debugging) {\r\nif (SRpnt->cmd[0] == READ_6)\r\nstp = "read";\r\nelse if (SRpnt->cmd[0] == WRITE_6)\r\nstp = "write";\r\nelse\r\nstp = "ioctl";\r\nprintk(ST_DEB_MSG "%s: Recovered %s error (%d).\n", name, stp,\r\nSTp->recover_count);\r\n} )\r\nif (cmdstatp->flags == 0)\r\nreturn 0;\r\n}\r\nreturn (-EIO);\r\n}\r\nstatic struct st_request *st_allocate_request(struct scsi_tape *stp)\r\n{\r\nstruct st_request *streq;\r\nstreq = kzalloc(sizeof(*streq), GFP_KERNEL);\r\nif (streq)\r\nstreq->stp = stp;\r\nelse {\r\nDEBC(printk(KERN_ERR "%s: Can't get SCSI request.\n",\r\ntape_name(stp)););\r\nif (signal_pending(current))\r\nstp->buffer->syscall_result = -EINTR;\r\nelse\r\nstp->buffer->syscall_result = -EBUSY;\r\n}\r\nreturn streq;\r\n}\r\nstatic void st_release_request(struct st_request *streq)\r\n{\r\nkfree(streq);\r\n}\r\nstatic void st_scsi_execute_end(struct request *req, int uptodate)\r\n{\r\nstruct st_request *SRpnt = req->end_io_data;\r\nstruct scsi_tape *STp = SRpnt->stp;\r\nstruct bio *tmp;\r\nSTp->buffer->cmdstat.midlevel_result = SRpnt->result = req->errors;\r\nSTp->buffer->cmdstat.residual = req->resid_len;\r\ntmp = SRpnt->bio;\r\nif (SRpnt->waiting)\r\ncomplete(SRpnt->waiting);\r\nblk_rq_unmap_user(tmp);\r\n__blk_put_request(req->q, req);\r\n}\r\nstatic int st_scsi_execute(struct st_request *SRpnt, const unsigned char *cmd,\r\nint data_direction, void *buffer, unsigned bufflen,\r\nint timeout, int retries)\r\n{\r\nstruct request *req;\r\nstruct rq_map_data *mdata = &SRpnt->stp->buffer->map_data;\r\nint err = 0;\r\nint write = (data_direction == DMA_TO_DEVICE);\r\nreq = blk_get_request(SRpnt->stp->device->request_queue, write,\r\nGFP_KERNEL);\r\nif (!req)\r\nreturn DRIVER_ERROR << 24;\r\nreq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nreq->cmd_flags |= REQ_QUIET;\r\nmdata->null_mapped = 1;\r\nif (bufflen) {\r\nerr = blk_rq_map_user(req->q, req, mdata, NULL, bufflen,\r\nGFP_KERNEL);\r\nif (err) {\r\nblk_put_request(req);\r\nreturn DRIVER_ERROR << 24;\r\n}\r\n}\r\nSRpnt->bio = req->bio;\r\nreq->cmd_len = COMMAND_SIZE(cmd[0]);\r\nmemset(req->cmd, 0, BLK_MAX_CDB);\r\nmemcpy(req->cmd, cmd, req->cmd_len);\r\nreq->sense = SRpnt->sense;\r\nreq->sense_len = 0;\r\nreq->timeout = timeout;\r\nreq->retries = retries;\r\nreq->end_io_data = SRpnt;\r\nblk_execute_rq_nowait(req->q, NULL, req, 1, st_scsi_execute_end);\r\nreturn 0;\r\n}\r\nstatic struct st_request *\r\nst_do_scsi(struct st_request * SRpnt, struct scsi_tape * STp, unsigned char *cmd,\r\nint bytes, int direction, int timeout, int retries, int do_wait)\r\n{\r\nstruct completion *waiting;\r\nstruct rq_map_data *mdata = &STp->buffer->map_data;\r\nint ret;\r\nif (!do_wait && ((STp->buffer)->last_SRpnt)) {\r\nprintk(KERN_ERR "%s: Async command already active.\n",\r\ntape_name(STp));\r\nif (signal_pending(current))\r\n(STp->buffer)->syscall_result = (-EINTR);\r\nelse\r\n(STp->buffer)->syscall_result = (-EBUSY);\r\nreturn NULL;\r\n}\r\nif (!SRpnt) {\r\nSRpnt = st_allocate_request(STp);\r\nif (!SRpnt)\r\nreturn NULL;\r\n}\r\nif (!do_wait)\r\n(STp->buffer)->last_SRpnt = SRpnt;\r\nwaiting = &STp->wait;\r\ninit_completion(waiting);\r\nSRpnt->waiting = waiting;\r\nif (STp->buffer->do_dio) {\r\nmdata->page_order = 0;\r\nmdata->nr_entries = STp->buffer->sg_segs;\r\nmdata->pages = STp->buffer->mapped_pages;\r\n} else {\r\nmdata->page_order = STp->buffer->reserved_page_order;\r\nmdata->nr_entries =\r\nDIV_ROUND_UP(bytes, PAGE_SIZE << mdata->page_order);\r\nmdata->pages = STp->buffer->reserved_pages;\r\nmdata->offset = 0;\r\n}\r\nmemcpy(SRpnt->cmd, cmd, sizeof(SRpnt->cmd));\r\nSTp->buffer->cmdstat.have_sense = 0;\r\nSTp->buffer->syscall_result = 0;\r\nret = st_scsi_execute(SRpnt, cmd, direction, NULL, bytes, timeout,\r\nretries);\r\nif (ret) {\r\n(STp->buffer)->syscall_result = (-EBUSY);\r\n(STp->buffer)->last_SRpnt = NULL;\r\n} else if (do_wait) {\r\nwait_for_completion(waiting);\r\nSRpnt->waiting = NULL;\r\n(STp->buffer)->syscall_result = st_chk_result(STp, SRpnt);\r\n}\r\nreturn SRpnt;\r\n}\r\nstatic int write_behind_check(struct scsi_tape * STp)\r\n{\r\nint retval = 0;\r\nstruct st_buffer *STbuffer;\r\nstruct st_partstat *STps;\r\nstruct st_cmdstatus *cmdstatp;\r\nstruct st_request *SRpnt;\r\nSTbuffer = STp->buffer;\r\nif (!STbuffer->writing)\r\nreturn 0;\r\nDEB(\r\nif (STp->write_pending)\r\nSTp->nbr_waits++;\r\nelse\r\nSTp->nbr_finished++;\r\n)\r\nwait_for_completion(&(STp->wait));\r\nSRpnt = STbuffer->last_SRpnt;\r\nSTbuffer->last_SRpnt = NULL;\r\nSRpnt->waiting = NULL;\r\n(STp->buffer)->syscall_result = st_chk_result(STp, SRpnt);\r\nst_release_request(SRpnt);\r\nSTbuffer->buffer_bytes -= STbuffer->writing;\r\nSTps = &(STp->ps[STp->partition]);\r\nif (STps->drv_block >= 0) {\r\nif (STp->block_size == 0)\r\nSTps->drv_block++;\r\nelse\r\nSTps->drv_block += STbuffer->writing / STp->block_size;\r\n}\r\ncmdstatp = &STbuffer->cmdstat;\r\nif (STbuffer->syscall_result) {\r\nretval = -EIO;\r\nif (cmdstatp->have_sense && !cmdstatp->deferred &&\r\n(cmdstatp->flags & SENSE_EOM) &&\r\n(cmdstatp->sense_hdr.sense_key == NO_SENSE ||\r\ncmdstatp->sense_hdr.sense_key == RECOVERED_ERROR)) {\r\nif (!cmdstatp->remainder_valid ||\r\ncmdstatp->uremainder64 == 0)\r\nretval = -ENOSPC;\r\n}\r\nif (retval == -EIO)\r\nSTps->drv_block = -1;\r\n}\r\nSTbuffer->writing = 0;\r\nDEB(if (debugging && retval)\r\nprintk(ST_DEB_MSG "%s: Async write error %x, return value %d.\n",\r\ntape_name(STp), STbuffer->cmdstat.midlevel_result, retval);)\r\nreturn retval;\r\n}\r\nstatic int cross_eof(struct scsi_tape * STp, int forward)\r\n{\r\nstruct st_request *SRpnt;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x01;\r\nif (forward) {\r\ncmd[2] = cmd[3] = 0;\r\ncmd[4] = 1;\r\n} else\r\ncmd[2] = cmd[3] = cmd[4] = 0xff;\r\ncmd[5] = 0;\r\nDEBC(printk(ST_DEB_MSG "%s: Stepping over filemark %s.\n",\r\ntape_name(STp), forward ? "forward" : "backward"));\r\nSRpnt = st_do_scsi(NULL, STp, cmd, 0, DMA_NONE,\r\nSTp->device->request_queue->rq_timeout,\r\nMAX_RETRIES, 1);\r\nif (!SRpnt)\r\nreturn (STp->buffer)->syscall_result;\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nif ((STp->buffer)->cmdstat.midlevel_result != 0)\r\nprintk(KERN_ERR "%s: Stepping over filemark %s failed.\n",\r\ntape_name(STp), forward ? "forward" : "backward");\r\nreturn (STp->buffer)->syscall_result;\r\n}\r\nstatic int st_flush_write_buffer(struct scsi_tape * STp)\r\n{\r\nint transfer, blks;\r\nint result;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt;\r\nstruct st_partstat *STps;\r\nresult = write_behind_check(STp);\r\nif (result)\r\nreturn result;\r\nresult = 0;\r\nif (STp->dirty == 1) {\r\ntransfer = STp->buffer->buffer_bytes;\r\nDEBC(printk(ST_DEB_MSG "%s: Flushing %d bytes.\n",\r\ntape_name(STp), transfer));\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_6;\r\ncmd[1] = 1;\r\nblks = transfer / STp->block_size;\r\ncmd[2] = blks >> 16;\r\ncmd[3] = blks >> 8;\r\ncmd[4] = blks;\r\nSRpnt = st_do_scsi(NULL, STp, cmd, transfer, DMA_TO_DEVICE,\r\nSTp->device->request_queue->rq_timeout,\r\nMAX_WRITE_RETRIES, 1);\r\nif (!SRpnt)\r\nreturn (STp->buffer)->syscall_result;\r\nSTps = &(STp->ps[STp->partition]);\r\nif ((STp->buffer)->syscall_result != 0) {\r\nstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\r\nif (cmdstatp->have_sense && !cmdstatp->deferred &&\r\n(cmdstatp->flags & SENSE_EOM) &&\r\n(cmdstatp->sense_hdr.sense_key == NO_SENSE ||\r\ncmdstatp->sense_hdr.sense_key == RECOVERED_ERROR) &&\r\n(!cmdstatp->remainder_valid ||\r\ncmdstatp->uremainder64 == 0)) {\r\nSTp->dirty = 0;\r\n(STp->buffer)->buffer_bytes = 0;\r\nif (STps->drv_block >= 0)\r\nSTps->drv_block += blks;\r\nresult = (-ENOSPC);\r\n} else {\r\nprintk(KERN_ERR "%s: Error on flush.\n",\r\ntape_name(STp));\r\nSTps->drv_block = (-1);\r\nresult = (-EIO);\r\n}\r\n} else {\r\nif (STps->drv_block >= 0)\r\nSTps->drv_block += blks;\r\nSTp->dirty = 0;\r\n(STp->buffer)->buffer_bytes = 0;\r\n}\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\n}\r\nreturn result;\r\n}\r\nstatic int flush_buffer(struct scsi_tape *STp, int seek_next)\r\n{\r\nint backspace, result;\r\nstruct st_buffer *STbuffer;\r\nstruct st_partstat *STps;\r\nSTbuffer = STp->buffer;\r\nif (STp->pos_unknown)\r\nreturn (-EIO);\r\nif (STp->ready != ST_READY)\r\nreturn 0;\r\nSTps = &(STp->ps[STp->partition]);\r\nif (STps->rw == ST_WRITING)\r\nreturn st_flush_write_buffer(STp);\r\nif (STp->block_size == 0)\r\nreturn 0;\r\nbackspace = ((STp->buffer)->buffer_bytes +\r\n(STp->buffer)->read_pointer) / STp->block_size -\r\n((STp->buffer)->read_pointer + STp->block_size - 1) /\r\nSTp->block_size;\r\n(STp->buffer)->buffer_bytes = 0;\r\n(STp->buffer)->read_pointer = 0;\r\nresult = 0;\r\nif (!seek_next) {\r\nif (STps->eof == ST_FM_HIT) {\r\nresult = cross_eof(STp, 0);\r\nif (!result)\r\nSTps->eof = ST_NOEOF;\r\nelse {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\n}\r\n}\r\nif (!result && backspace > 0)\r\nresult = st_int_ioctl(STp, MTBSR, backspace);\r\n} else if (STps->eof == ST_FM_HIT) {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\nSTps->eof = ST_NOEOF;\r\n}\r\nreturn result;\r\n}\r\nstatic int set_mode_densblk(struct scsi_tape * STp, struct st_modedef * STm)\r\n{\r\nint set_it = 0;\r\nunsigned long arg;\r\nchar *name = tape_name(STp);\r\nif (!STp->density_changed &&\r\nSTm->default_density >= 0 &&\r\nSTm->default_density != STp->density) {\r\narg = STm->default_density;\r\nset_it = 1;\r\n} else\r\narg = STp->density;\r\narg <<= MT_ST_DENSITY_SHIFT;\r\nif (!STp->blksize_changed &&\r\nSTm->default_blksize >= 0 &&\r\nSTm->default_blksize != STp->block_size) {\r\narg |= STm->default_blksize;\r\nset_it = 1;\r\n} else\r\narg |= STp->block_size;\r\nif (set_it &&\r\nst_int_ioctl(STp, SET_DENS_AND_BLK, arg)) {\r\nprintk(KERN_WARNING\r\n"%s: Can't set default block size to %d bytes and density %x.\n",\r\nname, STm->default_blksize, STm->default_density);\r\nif (modes_defined)\r\nreturn (-EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_door_lock(struct scsi_tape * STp, int do_lock)\r\n{\r\nint retval, cmd;\r\nDEB(char *name = tape_name(STp);)\r\ncmd = do_lock ? SCSI_IOCTL_DOORLOCK : SCSI_IOCTL_DOORUNLOCK;\r\nDEBC(printk(ST_DEB_MSG "%s: %socking drive door.\n", name,\r\ndo_lock ? "L" : "Unl"));\r\nretval = scsi_ioctl(STp->device, cmd, NULL);\r\nif (!retval) {\r\nSTp->door_locked = do_lock ? ST_LOCKED_EXPLICIT : ST_UNLOCKED;\r\n}\r\nelse {\r\nSTp->door_locked = ST_LOCK_FAILS;\r\n}\r\nreturn retval;\r\n}\r\nstatic void reset_state(struct scsi_tape *STp)\r\n{\r\nint i;\r\nstruct st_partstat *STps;\r\nSTp->pos_unknown = 0;\r\nfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\r\nSTps = &(STp->ps[i]);\r\nSTps->rw = ST_IDLE;\r\nSTps->eof = ST_NOEOF;\r\nSTps->at_sm = 0;\r\nSTps->last_block_valid = 0;\r\nSTps->drv_block = -1;\r\nSTps->drv_file = -1;\r\n}\r\nif (STp->can_partitions) {\r\nSTp->partition = find_partition(STp);\r\nif (STp->partition < 0)\r\nSTp->partition = 0;\r\nSTp->new_partition = STp->partition;\r\n}\r\n}\r\nstatic int test_ready(struct scsi_tape *STp, int do_wait)\r\n{\r\nint attentions, waits, max_wait, scode;\r\nint retval = CHKRES_READY, new_session = 0;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt = NULL;\r\nstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\r\nmax_wait = do_wait ? ST_BLOCK_SECONDS : 0;\r\nfor (attentions=waits=0; ; ) {\r\nmemset((void *) &cmd[0], 0, MAX_COMMAND_SIZE);\r\ncmd[0] = TEST_UNIT_READY;\r\nSRpnt = st_do_scsi(SRpnt, STp, cmd, 0, DMA_NONE,\r\nSTp->long_timeout, MAX_READY_RETRIES, 1);\r\nif (!SRpnt) {\r\nretval = (STp->buffer)->syscall_result;\r\nbreak;\r\n}\r\nif (cmdstatp->have_sense) {\r\nscode = cmdstatp->sense_hdr.sense_key;\r\nif (scode == UNIT_ATTENTION) {\r\nnew_session = 1;\r\nif (attentions < MAX_ATTENTIONS) {\r\nattentions++;\r\ncontinue;\r\n}\r\nelse {\r\nretval = (-EIO);\r\nbreak;\r\n}\r\n}\r\nif (scode == NOT_READY) {\r\nif (waits < max_wait) {\r\nif (msleep_interruptible(1000)) {\r\nretval = (-EINTR);\r\nbreak;\r\n}\r\nwaits++;\r\ncontinue;\r\n}\r\nelse {\r\nif ((STp->device)->scsi_level >= SCSI_2 &&\r\ncmdstatp->sense_hdr.asc == 0x3a)\r\nretval = CHKRES_NO_TAPE;\r\nelse\r\nretval = CHKRES_NOT_READY;\r\nbreak;\r\n}\r\n}\r\n}\r\nretval = (STp->buffer)->syscall_result;\r\nif (!retval)\r\nretval = new_session ? CHKRES_NEW_SESSION : CHKRES_READY;\r\nbreak;\r\n}\r\nif (SRpnt != NULL)\r\nst_release_request(SRpnt);\r\nreturn retval;\r\n}\r\nstatic int check_tape(struct scsi_tape *STp, struct file *filp)\r\n{\r\nint i, retval, new_session = 0, do_wait;\r\nunsigned char cmd[MAX_COMMAND_SIZE], saved_cleaning;\r\nunsigned short st_flags = filp->f_flags;\r\nstruct st_request *SRpnt = NULL;\r\nstruct st_modedef *STm;\r\nstruct st_partstat *STps;\r\nchar *name = tape_name(STp);\r\nstruct inode *inode = filp->f_path.dentry->d_inode;\r\nint mode = TAPE_MODE(inode);\r\nSTp->ready = ST_READY;\r\nif (mode != STp->current_mode) {\r\nDEBC(printk(ST_DEB_MSG "%s: Mode change from %d to %d.\n",\r\nname, STp->current_mode, mode));\r\nnew_session = 1;\r\nSTp->current_mode = mode;\r\n}\r\nSTm = &(STp->modes[STp->current_mode]);\r\nsaved_cleaning = STp->cleaning_req;\r\nSTp->cleaning_req = 0;\r\ndo_wait = ((filp->f_flags & O_NONBLOCK) == 0);\r\nretval = test_ready(STp, do_wait);\r\nif (retval < 0)\r\ngoto err_out;\r\nif (retval == CHKRES_NEW_SESSION) {\r\nSTp->pos_unknown = 0;\r\nSTp->partition = STp->new_partition = 0;\r\nif (STp->can_partitions)\r\nSTp->nbr_partitions = 1;\r\nfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\r\nSTps = &(STp->ps[i]);\r\nSTps->rw = ST_IDLE;\r\nSTps->eof = ST_NOEOF;\r\nSTps->at_sm = 0;\r\nSTps->last_block_valid = 0;\r\nSTps->drv_block = 0;\r\nSTps->drv_file = 0;\r\n}\r\nnew_session = 1;\r\n}\r\nelse {\r\nSTp->cleaning_req |= saved_cleaning;\r\nif (retval == CHKRES_NOT_READY || retval == CHKRES_NO_TAPE) {\r\nif (retval == CHKRES_NO_TAPE)\r\nSTp->ready = ST_NO_TAPE;\r\nelse\r\nSTp->ready = ST_NOT_READY;\r\nSTp->density = 0;\r\nSTp->write_prot = 0;\r\nSTp->block_size = 0;\r\nSTp->ps[0].drv_file = STp->ps[0].drv_block = (-1);\r\nSTp->partition = STp->new_partition = 0;\r\nSTp->door_locked = ST_UNLOCKED;\r\nreturn CHKRES_NOT_READY;\r\n}\r\n}\r\nif (STp->omit_blklims)\r\nSTp->min_block = STp->max_block = (-1);\r\nelse {\r\nmemset((void *) &cmd[0], 0, MAX_COMMAND_SIZE);\r\ncmd[0] = READ_BLOCK_LIMITS;\r\nSRpnt = st_do_scsi(SRpnt, STp, cmd, 6, DMA_FROM_DEVICE,\r\nSTp->device->request_queue->rq_timeout,\r\nMAX_READY_RETRIES, 1);\r\nif (!SRpnt) {\r\nretval = (STp->buffer)->syscall_result;\r\ngoto err_out;\r\n}\r\nif (!SRpnt->result && !STp->buffer->cmdstat.have_sense) {\r\nSTp->max_block = ((STp->buffer)->b_data[1] << 16) |\r\n((STp->buffer)->b_data[2] << 8) | (STp->buffer)->b_data[3];\r\nSTp->min_block = ((STp->buffer)->b_data[4] << 8) |\r\n(STp->buffer)->b_data[5];\r\nif ( DEB( debugging || ) !STp->inited)\r\nprintk(KERN_INFO\r\n"%s: Block limits %d - %d bytes.\n", name,\r\nSTp->min_block, STp->max_block);\r\n} else {\r\nSTp->min_block = STp->max_block = (-1);\r\nDEBC(printk(ST_DEB_MSG "%s: Can't read block limits.\n",\r\nname));\r\n}\r\n}\r\nmemset((void *) &cmd[0], 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SENSE;\r\ncmd[4] = 12;\r\nSRpnt = st_do_scsi(SRpnt, STp, cmd, 12, DMA_FROM_DEVICE,\r\nSTp->device->request_queue->rq_timeout,\r\nMAX_READY_RETRIES, 1);\r\nif (!SRpnt) {\r\nretval = (STp->buffer)->syscall_result;\r\ngoto err_out;\r\n}\r\nif ((STp->buffer)->syscall_result != 0) {\r\nDEBC(printk(ST_DEB_MSG "%s: No Mode Sense.\n", name));\r\nSTp->block_size = ST_DEFAULT_BLOCK;\r\n(STp->buffer)->syscall_result = 0;\r\nSTp->drv_write_prot = 0;\r\n} else {\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Mode sense. Length %d, medium %x, WBS %x, BLL %d\n",\r\nname,\r\n(STp->buffer)->b_data[0], (STp->buffer)->b_data[1],\r\n(STp->buffer)->b_data[2], (STp->buffer)->b_data[3]));\r\nif ((STp->buffer)->b_data[3] >= 8) {\r\nSTp->drv_buffer = ((STp->buffer)->b_data[2] >> 4) & 7;\r\nSTp->density = (STp->buffer)->b_data[4];\r\nSTp->block_size = (STp->buffer)->b_data[9] * 65536 +\r\n(STp->buffer)->b_data[10] * 256 + (STp->buffer)->b_data[11];\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Density %x, tape length: %x, drv buffer: %d\n",\r\nname, STp->density, (STp->buffer)->b_data[5] * 65536 +\r\n(STp->buffer)->b_data[6] * 256 + (STp->buffer)->b_data[7],\r\nSTp->drv_buffer));\r\n}\r\nSTp->drv_write_prot = ((STp->buffer)->b_data[2] & 0x80) != 0;\r\nif (!STp->drv_buffer && STp->immediate_filemark) {\r\nprintk(KERN_WARNING\r\n"%s: non-buffered tape: disabling writing immediate filemarks\n",\r\nname);\r\nSTp->immediate_filemark = 0;\r\n}\r\n}\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nSTp->inited = 1;\r\nif (STp->block_size > 0)\r\n(STp->buffer)->buffer_blocks =\r\n(STp->buffer)->buffer_size / STp->block_size;\r\nelse\r\n(STp->buffer)->buffer_blocks = 1;\r\n(STp->buffer)->buffer_bytes = (STp->buffer)->read_pointer = 0;\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Block size: %d, buffer size: %d (%d blocks).\n", name,\r\nSTp->block_size, (STp->buffer)->buffer_size,\r\n(STp->buffer)->buffer_blocks));\r\nif (STp->drv_write_prot) {\r\nSTp->write_prot = 1;\r\nDEBC(printk(ST_DEB_MSG "%s: Write protected\n", name));\r\nif (do_wait &&\r\n((st_flags & O_ACCMODE) == O_WRONLY ||\r\n(st_flags & O_ACCMODE) == O_RDWR)) {\r\nretval = (-EROFS);\r\ngoto err_out;\r\n}\r\n}\r\nif (STp->can_partitions && STp->nbr_partitions < 1) {\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Updating partition number in status.\n", name));\r\nif ((STp->partition = find_partition(STp)) < 0) {\r\nretval = STp->partition;\r\ngoto err_out;\r\n}\r\nSTp->new_partition = STp->partition;\r\nSTp->nbr_partitions = 1;\r\n}\r\nif (new_session) {\r\nSTp->density_changed = STp->blksize_changed = 0;\r\nSTp->compression_changed = 0;\r\nif (!(STm->defaults_for_writes) &&\r\n(retval = set_mode_densblk(STp, STm)) < 0)\r\ngoto err_out;\r\nif (STp->default_drvbuffer != 0xff) {\r\nif (st_int_ioctl(STp, MTSETDRVBUFFER, STp->default_drvbuffer))\r\nprintk(KERN_WARNING\r\n"%s: Can't set default drive buffering to %d.\n",\r\nname, STp->default_drvbuffer);\r\n}\r\n}\r\nreturn CHKRES_READY;\r\nerr_out:\r\nreturn retval;\r\n}\r\nstatic int st_open(struct inode *inode, struct file *filp)\r\n{\r\nint i, retval = (-EIO);\r\nint resumed = 0;\r\nstruct scsi_tape *STp;\r\nstruct st_partstat *STps;\r\nint dev = TAPE_NR(inode);\r\nchar *name;\r\nmutex_lock(&st_mutex);\r\nfilp->f_mode &= ~(FMODE_PREAD | FMODE_PWRITE);\r\nif (!(STp = scsi_tape_get(dev))) {\r\nmutex_unlock(&st_mutex);\r\nreturn -ENXIO;\r\n}\r\nwrite_lock(&st_dev_arr_lock);\r\nfilp->private_data = STp;\r\nname = tape_name(STp);\r\nif (STp->in_use) {\r\nwrite_unlock(&st_dev_arr_lock);\r\nscsi_tape_put(STp);\r\nmutex_unlock(&st_mutex);\r\nDEB( printk(ST_DEB_MSG "%s: Device already in use.\n", name); )\r\nreturn (-EBUSY);\r\n}\r\nSTp->in_use = 1;\r\nwrite_unlock(&st_dev_arr_lock);\r\nSTp->rew_at_close = STp->autorew_dev = (iminor(inode) & 0x80) == 0;\r\nif (scsi_autopm_get_device(STp->device) < 0) {\r\nretval = -EIO;\r\ngoto err_out;\r\n}\r\nresumed = 1;\r\nif (!scsi_block_when_processing_errors(STp->device)) {\r\nretval = (-ENXIO);\r\ngoto err_out;\r\n}\r\nif (!enlarge_buffer(STp->buffer, PAGE_SIZE, STp->restr_dma)) {\r\nprintk(KERN_WARNING "%s: Can't allocate one page tape buffer.\n",\r\nname);\r\nretval = (-EOVERFLOW);\r\ngoto err_out;\r\n}\r\n(STp->buffer)->cleared = 0;\r\n(STp->buffer)->writing = 0;\r\n(STp->buffer)->syscall_result = 0;\r\nSTp->write_prot = ((filp->f_flags & O_ACCMODE) == O_RDONLY);\r\nSTp->dirty = 0;\r\nfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\r\nSTps = &(STp->ps[i]);\r\nSTps->rw = ST_IDLE;\r\n}\r\nSTp->try_dio_now = STp->try_dio;\r\nSTp->recover_count = 0;\r\nDEB( STp->nbr_waits = STp->nbr_finished = 0;\r\nSTp->nbr_requests = STp->nbr_dio = STp->nbr_pages = 0; )\r\nretval = check_tape(STp, filp);\r\nif (retval < 0)\r\ngoto err_out;\r\nif ((filp->f_flags & O_NONBLOCK) == 0 &&\r\nretval != CHKRES_READY) {\r\nif (STp->ready == NO_TAPE)\r\nretval = (-ENOMEDIUM);\r\nelse\r\nretval = (-EIO);\r\ngoto err_out;\r\n}\r\nmutex_unlock(&st_mutex);\r\nreturn 0;\r\nerr_out:\r\nnormalize_buffer(STp->buffer);\r\nSTp->in_use = 0;\r\nscsi_tape_put(STp);\r\nif (resumed)\r\nscsi_autopm_put_device(STp->device);\r\nmutex_unlock(&st_mutex);\r\nreturn retval;\r\n}\r\nstatic int st_flush(struct file *filp, fl_owner_t id)\r\n{\r\nint result = 0, result2;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt;\r\nstruct scsi_tape *STp = filp->private_data;\r\nstruct st_modedef *STm = &(STp->modes[STp->current_mode]);\r\nstruct st_partstat *STps = &(STp->ps[STp->partition]);\r\nchar *name = tape_name(STp);\r\nif (file_count(filp) > 1)\r\nreturn 0;\r\nif (STps->rw == ST_WRITING && !STp->pos_unknown) {\r\nresult = st_flush_write_buffer(STp);\r\nif (result != 0 && result != (-ENOSPC))\r\ngoto out;\r\n}\r\nif (STp->can_partitions &&\r\n(result2 = switch_partition(STp)) < 0) {\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: switch_partition at close failed.\n", name));\r\nif (result == 0)\r\nresult = result2;\r\ngoto out;\r\n}\r\nDEBC( if (STp->nbr_requests)\r\nprintk(KERN_DEBUG "%s: Number of r/w requests %d, dio used in %d, pages %d.\n",\r\nname, STp->nbr_requests, STp->nbr_dio, STp->nbr_pages));\r\nif (STps->rw == ST_WRITING && !STp->pos_unknown) {\r\nstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\r\nDEBC(printk(ST_DEB_MSG "%s: Async write waits %d, finished %d.\n",\r\nname, STp->nbr_waits, STp->nbr_finished);\r\n)\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_FILEMARKS;\r\nif (STp->immediate_filemark)\r\ncmd[1] = 1;\r\ncmd[4] = 1 + STp->two_fm;\r\nSRpnt = st_do_scsi(NULL, STp, cmd, 0, DMA_NONE,\r\nSTp->device->request_queue->rq_timeout,\r\nMAX_WRITE_RETRIES, 1);\r\nif (!SRpnt) {\r\nresult = (STp->buffer)->syscall_result;\r\ngoto out;\r\n}\r\nif (STp->buffer->syscall_result == 0 ||\r\n(cmdstatp->have_sense && !cmdstatp->deferred &&\r\n(cmdstatp->flags & SENSE_EOM) &&\r\n(cmdstatp->sense_hdr.sense_key == NO_SENSE ||\r\ncmdstatp->sense_hdr.sense_key == RECOVERED_ERROR) &&\r\n(!cmdstatp->remainder_valid || cmdstatp->uremainder64 == 0))) {\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\nif (STp->two_fm)\r\ncross_eof(STp, 0);\r\nSTps->eof = ST_FM;\r\n}\r\nelse {\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nprintk(KERN_ERR "%s: Error on write filemark.\n", name);\r\nif (result == 0)\r\nresult = (-EIO);\r\n}\r\nDEBC(printk(ST_DEB_MSG "%s: Buffer flushed, %d EOF(s) written\n",\r\nname, cmd[4]));\r\n} else if (!STp->rew_at_close) {\r\nSTps = &(STp->ps[STp->partition]);\r\nif (!STm->sysv || STps->rw != ST_READING) {\r\nif (STp->can_bsr)\r\nresult = flush_buffer(STp, 0);\r\nelse if (STps->eof == ST_FM_HIT) {\r\nresult = cross_eof(STp, 0);\r\nif (result) {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\nSTps->eof = ST_FM;\r\n} else\r\nSTps->eof = ST_NOEOF;\r\n}\r\n} else if ((STps->eof == ST_NOEOF &&\r\n!(result = cross_eof(STp, 1))) ||\r\nSTps->eof == ST_FM_HIT) {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\nSTps->eof = ST_FM;\r\n}\r\n}\r\nout:\r\nif (STp->rew_at_close) {\r\nresult2 = st_int_ioctl(STp, MTREW, 1);\r\nif (result == 0)\r\nresult = result2;\r\n}\r\nreturn result;\r\n}\r\nstatic int st_release(struct inode *inode, struct file *filp)\r\n{\r\nint result = 0;\r\nstruct scsi_tape *STp = filp->private_data;\r\nif (STp->door_locked == ST_LOCKED_AUTO)\r\ndo_door_lock(STp, 0);\r\nnormalize_buffer(STp->buffer);\r\nwrite_lock(&st_dev_arr_lock);\r\nSTp->in_use = 0;\r\nwrite_unlock(&st_dev_arr_lock);\r\nscsi_autopm_put_device(STp->device);\r\nscsi_tape_put(STp);\r\nreturn result;\r\n}\r\nstatic ssize_t rw_checks(struct scsi_tape *STp, struct file *filp, size_t count)\r\n{\r\nssize_t retval = 0;\r\nif (!scsi_block_when_processing_errors(STp->device)) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif (STp->ready != ST_READY) {\r\nif (STp->ready == ST_NO_TAPE)\r\nretval = (-ENOMEDIUM);\r\nelse\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif (! STp->modes[STp->current_mode].defined) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif (STp->pos_unknown) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif (count == 0)\r\ngoto out;\r\nDEB(\r\nif (!STp->in_use) {\r\nprintk(ST_DEB_MSG "%s: Incorrect device.\n", tape_name(STp));\r\nretval = (-EIO);\r\ngoto out;\r\n} )\r\nif (STp->can_partitions &&\r\n(retval = switch_partition(STp)) < 0)\r\ngoto out;\r\nif (STp->block_size == 0 && STp->max_block > 0 &&\r\n(count < STp->min_block || count > STp->max_block)) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nif (STp->do_auto_lock && STp->door_locked == ST_UNLOCKED &&\r\n!do_door_lock(STp, 1))\r\nSTp->door_locked = ST_LOCKED_AUTO;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int setup_buffering(struct scsi_tape *STp, const char __user *buf,\r\nsize_t count, int is_read)\r\n{\r\nint i, bufsize, retval = 0;\r\nstruct st_buffer *STbp = STp->buffer;\r\nif (is_read)\r\ni = STp->try_dio_now && try_rdio;\r\nelse\r\ni = STp->try_dio_now && try_wdio;\r\nif (i && ((unsigned long)buf & queue_dma_alignment(\r\nSTp->device->request_queue)) == 0) {\r\ni = sgl_map_user_pages(STbp, STbp->use_sg, (unsigned long)buf,\r\ncount, (is_read ? READ : WRITE));\r\nif (i > 0) {\r\nSTbp->do_dio = i;\r\nSTbp->buffer_bytes = 0;\r\n}\r\nelse\r\nSTbp->do_dio = 0;\r\nSTbp->sg_segs = STbp->do_dio;\r\nDEB(\r\nif (STbp->do_dio) {\r\nSTp->nbr_dio++;\r\nSTp->nbr_pages += STbp->do_dio;\r\n}\r\n)\r\n} else\r\nSTbp->do_dio = 0;\r\nDEB( STp->nbr_requests++; )\r\nif (!STbp->do_dio) {\r\nif (STp->block_size)\r\nbufsize = STp->block_size > st_fixed_buffer_size ?\r\nSTp->block_size : st_fixed_buffer_size;\r\nelse {\r\nbufsize = count;\r\nif (is_read && STp->sili && !STbp->cleared)\r\nclear_buffer(STbp);\r\n}\r\nif (bufsize > STbp->buffer_size &&\r\n!enlarge_buffer(STbp, bufsize, STp->restr_dma)) {\r\nprintk(KERN_WARNING "%s: Can't allocate %d byte tape buffer.\n",\r\ntape_name(STp), bufsize);\r\nretval = (-EOVERFLOW);\r\ngoto out;\r\n}\r\nif (STp->block_size)\r\nSTbp->buffer_blocks = bufsize / STp->block_size;\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nstatic void release_buffering(struct scsi_tape *STp, int is_read)\r\n{\r\nstruct st_buffer *STbp;\r\nSTbp = STp->buffer;\r\nif (STbp->do_dio) {\r\nsgl_unmap_user_pages(STbp, STbp->do_dio, is_read);\r\nSTbp->do_dio = 0;\r\nSTbp->sg_segs = 0;\r\n}\r\n}\r\nstatic ssize_t\r\nst_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\r\n{\r\nssize_t total;\r\nssize_t i, do_count, blks, transfer;\r\nssize_t retval;\r\nint undone, retry_eot = 0, scode;\r\nint async_write;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nconst char __user *b_point;\r\nstruct st_request *SRpnt = NULL;\r\nstruct scsi_tape *STp = filp->private_data;\r\nstruct st_modedef *STm;\r\nstruct st_partstat *STps;\r\nstruct st_buffer *STbp;\r\nchar *name = tape_name(STp);\r\nif (mutex_lock_interruptible(&STp->lock))\r\nreturn -ERESTARTSYS;\r\nretval = rw_checks(STp, filp, count);\r\nif (retval || count == 0)\r\ngoto out;\r\nif (STp->block_size != 0 && (count % STp->block_size) != 0) {\r\nprintk(KERN_WARNING "%s: Write not multiple of tape block size.\n",\r\nname);\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nSTm = &(STp->modes[STp->current_mode]);\r\nSTps = &(STp->ps[STp->partition]);\r\nif (STp->write_prot) {\r\nretval = (-EACCES);\r\ngoto out;\r\n}\r\nif (STps->rw == ST_READING) {\r\nretval = flush_buffer(STp, 0);\r\nif (retval)\r\ngoto out;\r\nSTps->rw = ST_WRITING;\r\n} else if (STps->rw != ST_WRITING &&\r\nSTps->drv_file == 0 && STps->drv_block == 0) {\r\nif ((retval = set_mode_densblk(STp, STm)) < 0)\r\ngoto out;\r\nif (STm->default_compression != ST_DONT_TOUCH &&\r\n!(STp->compression_changed)) {\r\nif (st_compression(STp, (STm->default_compression == ST_YES))) {\r\nprintk(KERN_WARNING "%s: Can't set default compression.\n",\r\nname);\r\nif (modes_defined) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\n}\r\n}\r\n}\r\nSTbp = STp->buffer;\r\ni = write_behind_check(STp);\r\nif (i) {\r\nif (i == -ENOSPC)\r\nSTps->eof = ST_EOM_OK;\r\nelse\r\nSTps->eof = ST_EOM_ERROR;\r\n}\r\nif (STps->eof == ST_EOM_OK) {\r\nSTps->eof = ST_EOD_1;\r\nretval = (-ENOSPC);\r\ngoto out;\r\n}\r\nelse if (STps->eof == ST_EOM_ERROR) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif (STp->block_size != 0 &&\r\n!STbp->do_dio &&\r\n(copy_from_user(&i, buf, 1) != 0 ||\r\ncopy_from_user(&i, buf + count - 1, 1) != 0)) {\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\nretval = setup_buffering(STp, buf, count, 0);\r\nif (retval)\r\ngoto out;\r\ntotal = count;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = WRITE_6;\r\ncmd[1] = (STp->block_size != 0);\r\nSTps->rw = ST_WRITING;\r\nb_point = buf;\r\nwhile (count > 0 && !retry_eot) {\r\nif (STbp->do_dio) {\r\ndo_count = count;\r\n}\r\nelse {\r\nif (STp->block_size == 0)\r\ndo_count = count;\r\nelse {\r\ndo_count = STbp->buffer_blocks * STp->block_size -\r\nSTbp->buffer_bytes;\r\nif (do_count > count)\r\ndo_count = count;\r\n}\r\ni = append_to_buffer(b_point, STbp, do_count);\r\nif (i) {\r\nretval = i;\r\ngoto out;\r\n}\r\n}\r\ncount -= do_count;\r\nb_point += do_count;\r\nasync_write = STp->block_size == 0 && !STbp->do_dio &&\r\nSTm->do_async_writes && STps->eof < ST_EOM_OK;\r\nif (STp->block_size != 0 && STm->do_buffer_writes &&\r\n!(STp->try_dio_now && try_wdio) && STps->eof < ST_EOM_OK &&\r\nSTbp->buffer_bytes < STbp->buffer_size) {\r\nSTp->dirty = 1;\r\nif (!async_write && count == 0)\r\nbreak;\r\n}\r\nretry_write:\r\nif (STp->block_size == 0)\r\nblks = transfer = do_count;\r\nelse {\r\nif (!STbp->do_dio)\r\nblks = STbp->buffer_bytes;\r\nelse\r\nblks = do_count;\r\nblks /= STp->block_size;\r\ntransfer = blks * STp->block_size;\r\n}\r\ncmd[2] = blks >> 16;\r\ncmd[3] = blks >> 8;\r\ncmd[4] = blks;\r\nSRpnt = st_do_scsi(SRpnt, STp, cmd, transfer, DMA_TO_DEVICE,\r\nSTp->device->request_queue->rq_timeout,\r\nMAX_WRITE_RETRIES, !async_write);\r\nif (!SRpnt) {\r\nretval = STbp->syscall_result;\r\ngoto out;\r\n}\r\nif (async_write && !STbp->syscall_result) {\r\nSTbp->writing = transfer;\r\nSTp->dirty = !(STbp->writing ==\r\nSTbp->buffer_bytes);\r\nSRpnt = NULL;\r\nDEB( STp->write_pending = 1; )\r\nbreak;\r\n}\r\nif (STbp->syscall_result != 0) {\r\nstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\r\nDEBC(printk(ST_DEB_MSG "%s: Error on write:\n", name));\r\nif (cmdstatp->have_sense && (cmdstatp->flags & SENSE_EOM)) {\r\nscode = cmdstatp->sense_hdr.sense_key;\r\nif (cmdstatp->remainder_valid)\r\nundone = (int)cmdstatp->uremainder64;\r\nelse if (STp->block_size == 0 &&\r\nscode == VOLUME_OVERFLOW)\r\nundone = transfer;\r\nelse\r\nundone = 0;\r\nif (STp->block_size != 0)\r\nundone *= STp->block_size;\r\nif (undone <= do_count) {\r\ncount += undone;\r\nb_point -= undone;\r\ndo_count -= undone;\r\nif (STp->block_size)\r\nblks = (transfer - undone) / STp->block_size;\r\nSTps->eof = ST_EOM_OK;\r\nif (STp->block_size == 0 ||\r\nundone > 0 || count == 0)\r\nretval = (-ENOSPC);\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: EOM with %d bytes unwritten.\n",\r\nname, (int)count));\r\n} else {\r\nif (!retry_eot && !cmdstatp->deferred &&\r\n(scode == NO_SENSE || scode == RECOVERED_ERROR)) {\r\nmove_buffer_data(STp->buffer, transfer - undone);\r\nretry_eot = 1;\r\nif (STps->drv_block >= 0) {\r\nSTps->drv_block += (transfer - undone) /\r\nSTp->block_size;\r\n}\r\nSTps->eof = ST_EOM_OK;\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Retry write of %d bytes at EOM.\n",\r\nname, STp->buffer->buffer_bytes));\r\ngoto retry_write;\r\n}\r\nelse {\r\ncount -= do_count;\r\nblks = do_count = 0;\r\nSTps->eof = ST_EOM_ERROR;\r\nSTps->drv_block = (-1);\r\nretval = (-EIO);\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: EOM with lost data.\n",\r\nname));\r\n}\r\n}\r\n} else {\r\ncount += do_count;\r\nSTps->drv_block = (-1);\r\nretval = STbp->syscall_result;\r\n}\r\n}\r\nif (STps->drv_block >= 0) {\r\nif (STp->block_size == 0)\r\nSTps->drv_block += (do_count > 0);\r\nelse\r\nSTps->drv_block += blks;\r\n}\r\nSTbp->buffer_bytes = 0;\r\nSTp->dirty = 0;\r\nif (retval || retry_eot) {\r\nif (count < total)\r\nretval = total - count;\r\ngoto out;\r\n}\r\n}\r\nif (STps->eof == ST_EOD_1)\r\nSTps->eof = ST_EOM_OK;\r\nelse if (STps->eof != ST_EOM_OK)\r\nSTps->eof = ST_NOEOF;\r\nretval = total - count;\r\nout:\r\nif (SRpnt != NULL)\r\nst_release_request(SRpnt);\r\nrelease_buffering(STp, 0);\r\nmutex_unlock(&STp->lock);\r\nreturn retval;\r\n}\r\nstatic long read_tape(struct scsi_tape *STp, long count,\r\nstruct st_request ** aSRpnt)\r\n{\r\nint transfer, blks, bytes;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt;\r\nstruct st_modedef *STm;\r\nstruct st_partstat *STps;\r\nstruct st_buffer *STbp;\r\nint retval = 0;\r\nchar *name = tape_name(STp);\r\nif (count == 0)\r\nreturn 0;\r\nSTm = &(STp->modes[STp->current_mode]);\r\nSTps = &(STp->ps[STp->partition]);\r\nif (STps->eof == ST_FM_HIT)\r\nreturn 1;\r\nSTbp = STp->buffer;\r\nif (STp->block_size == 0)\r\nblks = bytes = count;\r\nelse {\r\nif (!(STp->try_dio_now && try_rdio) && STm->do_read_ahead) {\r\nblks = (STp->buffer)->buffer_blocks;\r\nbytes = blks * STp->block_size;\r\n} else {\r\nbytes = count;\r\nif (!STbp->do_dio && bytes > (STp->buffer)->buffer_size)\r\nbytes = (STp->buffer)->buffer_size;\r\nblks = bytes / STp->block_size;\r\nbytes = blks * STp->block_size;\r\n}\r\n}\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = READ_6;\r\ncmd[1] = (STp->block_size != 0);\r\nif (!cmd[1] && STp->sili)\r\ncmd[1] |= 2;\r\ncmd[2] = blks >> 16;\r\ncmd[3] = blks >> 8;\r\ncmd[4] = blks;\r\nSRpnt = *aSRpnt;\r\nSRpnt = st_do_scsi(SRpnt, STp, cmd, bytes, DMA_FROM_DEVICE,\r\nSTp->device->request_queue->rq_timeout,\r\nMAX_RETRIES, 1);\r\nrelease_buffering(STp, 1);\r\n*aSRpnt = SRpnt;\r\nif (!SRpnt)\r\nreturn STbp->syscall_result;\r\nSTbp->read_pointer = 0;\r\nSTps->at_sm = 0;\r\nif (STbp->syscall_result) {\r\nstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\r\nretval = 1;\r\nDEBC(printk(ST_DEB_MSG "%s: Sense: %2x %2x %2x %2x %2x %2x %2x %2x\n",\r\nname,\r\nSRpnt->sense[0], SRpnt->sense[1],\r\nSRpnt->sense[2], SRpnt->sense[3],\r\nSRpnt->sense[4], SRpnt->sense[5],\r\nSRpnt->sense[6], SRpnt->sense[7]));\r\nif (cmdstatp->have_sense) {\r\nif (cmdstatp->sense_hdr.sense_key == BLANK_CHECK)\r\ncmdstatp->flags &= 0xcf;\r\nif (cmdstatp->flags != 0) {\r\nif (cmdstatp->remainder_valid)\r\ntransfer = (int)cmdstatp->uremainder64;\r\nelse\r\ntransfer = 0;\r\nif (STp->block_size == 0 &&\r\ncmdstatp->sense_hdr.sense_key == MEDIUM_ERROR)\r\ntransfer = bytes;\r\nif (cmdstatp->flags & SENSE_ILI) {\r\nif (STp->block_size == 0) {\r\nif (transfer <= 0) {\r\nif (transfer < 0)\r\nprintk(KERN_NOTICE\r\n"%s: Failed to read %d byte block with %d byte transfer.\n",\r\nname, bytes - transfer, bytes);\r\nif (STps->drv_block >= 0)\r\nSTps->drv_block += 1;\r\nSTbp->buffer_bytes = 0;\r\nreturn (-ENOMEM);\r\n}\r\nSTbp->buffer_bytes = bytes - transfer;\r\n} else {\r\nst_release_request(SRpnt);\r\nSRpnt = *aSRpnt = NULL;\r\nif (transfer == blks) {\r\nprintk(KERN_NOTICE "%s: Incorrect block size.\n", name);\r\nif (STps->drv_block >= 0)\r\nSTps->drv_block += blks - transfer + 1;\r\nst_int_ioctl(STp, MTBSR, 1);\r\nreturn (-EIO);\r\n}\r\nSTbp->buffer_bytes = (blks - transfer) *\r\nSTp->block_size;\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: ILI but enough data received %ld %d.\n",\r\nname, count, STbp->buffer_bytes));\r\nif (STps->drv_block >= 0)\r\nSTps->drv_block += 1;\r\nif (st_int_ioctl(STp, MTBSR, 1))\r\nreturn (-EIO);\r\n}\r\n} else if (cmdstatp->flags & SENSE_FMK) {\r\nif (STps->eof != ST_FM_HIT)\r\nSTps->eof = ST_FM_HIT;\r\nelse\r\nSTps->eof = ST_EOD_2;\r\nif (STp->block_size == 0)\r\nSTbp->buffer_bytes = 0;\r\nelse\r\nSTbp->buffer_bytes =\r\nbytes - transfer * STp->block_size;\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: EOF detected (%d bytes read).\n",\r\nname, STbp->buffer_bytes));\r\n} else if (cmdstatp->flags & SENSE_EOM) {\r\nif (STps->eof == ST_FM)\r\nSTps->eof = ST_EOD_1;\r\nelse\r\nSTps->eof = ST_EOM_OK;\r\nif (STp->block_size == 0)\r\nSTbp->buffer_bytes = bytes - transfer;\r\nelse\r\nSTbp->buffer_bytes =\r\nbytes - transfer * STp->block_size;\r\nDEBC(printk(ST_DEB_MSG "%s: EOM detected (%d bytes read).\n",\r\nname, STbp->buffer_bytes));\r\n}\r\n}\r\nelse {\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Tape error while reading.\n", name));\r\nSTps->drv_block = (-1);\r\nif (STps->eof == ST_FM &&\r\ncmdstatp->sense_hdr.sense_key == BLANK_CHECK) {\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Zero returned for first BLANK CHECK after EOF.\n",\r\nname));\r\nSTps->eof = ST_EOD_2;\r\n} else\r\nretval = (-EIO);\r\n}\r\nif (STbp->buffer_bytes < 0)\r\nSTbp->buffer_bytes = 0;\r\n}\r\nelse {\r\nretval = STbp->syscall_result;\r\n}\r\n}\r\nelse {\r\nSTbp->buffer_bytes = bytes;\r\nif (STp->sili)\r\nSTbp->buffer_bytes -= STp->buffer->cmdstat.residual;\r\n}\r\nif (STps->drv_block >= 0) {\r\nif (STp->block_size == 0)\r\nSTps->drv_block++;\r\nelse\r\nSTps->drv_block += STbp->buffer_bytes / STp->block_size;\r\n}\r\nreturn retval;\r\n}\r\nstatic ssize_t\r\nst_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)\r\n{\r\nssize_t total;\r\nssize_t retval = 0;\r\nssize_t i, transfer;\r\nint special, do_dio = 0;\r\nstruct st_request *SRpnt = NULL;\r\nstruct scsi_tape *STp = filp->private_data;\r\nstruct st_modedef *STm;\r\nstruct st_partstat *STps;\r\nstruct st_buffer *STbp = STp->buffer;\r\nDEB( char *name = tape_name(STp); )\r\nif (mutex_lock_interruptible(&STp->lock))\r\nreturn -ERESTARTSYS;\r\nretval = rw_checks(STp, filp, count);\r\nif (retval || count == 0)\r\ngoto out;\r\nSTm = &(STp->modes[STp->current_mode]);\r\nif (STp->block_size != 0 && (count % STp->block_size) != 0) {\r\nif (!STm->do_read_ahead) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nSTp->try_dio_now = 0;\r\n}\r\nSTps = &(STp->ps[STp->partition]);\r\nif (STps->rw == ST_WRITING) {\r\nretval = flush_buffer(STp, 0);\r\nif (retval)\r\ngoto out;\r\nSTps->rw = ST_READING;\r\n}\r\nDEB(\r\nif (debugging && STps->eof != ST_NOEOF)\r\nprintk(ST_DEB_MSG "%s: EOF/EOM flag up (%d). Bytes %d\n", name,\r\nSTps->eof, STbp->buffer_bytes);\r\n)\r\nretval = setup_buffering(STp, buf, count, 1);\r\nif (retval)\r\ngoto out;\r\ndo_dio = STbp->do_dio;\r\nif (STbp->buffer_bytes == 0 &&\r\nSTps->eof >= ST_EOD_1) {\r\nif (STps->eof < ST_EOD) {\r\nSTps->eof += 1;\r\nretval = 0;\r\ngoto out;\r\n}\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif (do_dio) {\r\nif (copy_from_user(&i, buf, 1) != 0 ||\r\ncopy_to_user(buf, &i, 1) != 0 ||\r\ncopy_from_user(&i, buf + count - 1, 1) != 0 ||\r\ncopy_to_user(buf + count - 1, &i, 1) != 0) {\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\n}\r\nSTps->rw = ST_READING;\r\nfor (total = 0, special = 0; total < count && !special;) {\r\nif (STbp->buffer_bytes == 0) {\r\nspecial = read_tape(STp, count - total, &SRpnt);\r\nif (special < 0) {\r\nretval = special;\r\ngoto out;\r\n}\r\n}\r\nif (STbp->buffer_bytes > 0) {\r\nDEB(\r\nif (debugging && STps->eof != ST_NOEOF)\r\nprintk(ST_DEB_MSG\r\n"%s: EOF up (%d). Left %d, needed %d.\n", name,\r\nSTps->eof, STbp->buffer_bytes,\r\n(int)(count - total));\r\n)\r\ntransfer = STbp->buffer_bytes < count - total ?\r\nSTbp->buffer_bytes : count - total;\r\nif (!do_dio) {\r\ni = from_buffer(STbp, buf, transfer);\r\nif (i) {\r\nretval = i;\r\ngoto out;\r\n}\r\n}\r\nbuf += transfer;\r\ntotal += transfer;\r\n}\r\nif (STp->block_size == 0)\r\nbreak;\r\n}\r\nif (total == 0) {\r\nif (STps->eof == ST_FM_HIT) {\r\nSTps->eof = ST_FM;\r\nSTps->drv_block = 0;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\n} else if (STps->eof == ST_EOD_1) {\r\nSTps->eof = ST_EOD_2;\r\nSTps->drv_block = 0;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\n} else if (STps->eof == ST_EOD_2)\r\nSTps->eof = ST_EOD;\r\n} else if (STps->eof == ST_FM)\r\nSTps->eof = ST_NOEOF;\r\nretval = total;\r\nout:\r\nif (SRpnt != NULL) {\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\n}\r\nif (do_dio) {\r\nrelease_buffering(STp, 1);\r\nSTbp->buffer_bytes = 0;\r\n}\r\nmutex_unlock(&STp->lock);\r\nreturn retval;\r\n}\r\nstatic int st_set_options(struct scsi_tape *STp, long options)\r\n{\r\nint value;\r\nlong code;\r\nstruct st_modedef *STm;\r\nchar *name = tape_name(STp);\r\nstruct cdev *cd0, *cd1;\r\nSTm = &(STp->modes[STp->current_mode]);\r\nif (!STm->defined) {\r\ncd0 = STm->cdevs[0]; cd1 = STm->cdevs[1];\r\nmemcpy(STm, &(STp->modes[0]), sizeof(struct st_modedef));\r\nSTm->cdevs[0] = cd0; STm->cdevs[1] = cd1;\r\nmodes_defined = 1;\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Initialized mode %d definition from mode 0\n",\r\nname, STp->current_mode));\r\n}\r\ncode = options & MT_ST_OPTIONS;\r\nif (code == MT_ST_BOOLEANS) {\r\nSTm->do_buffer_writes = (options & MT_ST_BUFFER_WRITES) != 0;\r\nSTm->do_async_writes = (options & MT_ST_ASYNC_WRITES) != 0;\r\nSTm->defaults_for_writes = (options & MT_ST_DEF_WRITES) != 0;\r\nSTm->do_read_ahead = (options & MT_ST_READ_AHEAD) != 0;\r\nSTp->two_fm = (options & MT_ST_TWO_FM) != 0;\r\nSTp->fast_mteom = (options & MT_ST_FAST_MTEOM) != 0;\r\nSTp->do_auto_lock = (options & MT_ST_AUTO_LOCK) != 0;\r\nSTp->can_bsr = (options & MT_ST_CAN_BSR) != 0;\r\nSTp->omit_blklims = (options & MT_ST_NO_BLKLIMS) != 0;\r\nif ((STp->device)->scsi_level >= SCSI_2)\r\nSTp->can_partitions = (options & MT_ST_CAN_PARTITIONS) != 0;\r\nSTp->scsi2_logical = (options & MT_ST_SCSI2LOGICAL) != 0;\r\nSTp->immediate = (options & MT_ST_NOWAIT) != 0;\r\nSTp->immediate_filemark = (options & MT_ST_NOWAIT_EOF) != 0;\r\nSTm->sysv = (options & MT_ST_SYSV) != 0;\r\nSTp->sili = (options & MT_ST_SILI) != 0;\r\nDEB( debugging = (options & MT_ST_DEBUGGING) != 0;\r\nst_log_options(STp, STm, name); )\r\n} else if (code == MT_ST_SETBOOLEANS || code == MT_ST_CLEARBOOLEANS) {\r\nvalue = (code == MT_ST_SETBOOLEANS);\r\nif ((options & MT_ST_BUFFER_WRITES) != 0)\r\nSTm->do_buffer_writes = value;\r\nif ((options & MT_ST_ASYNC_WRITES) != 0)\r\nSTm->do_async_writes = value;\r\nif ((options & MT_ST_DEF_WRITES) != 0)\r\nSTm->defaults_for_writes = value;\r\nif ((options & MT_ST_READ_AHEAD) != 0)\r\nSTm->do_read_ahead = value;\r\nif ((options & MT_ST_TWO_FM) != 0)\r\nSTp->two_fm = value;\r\nif ((options & MT_ST_FAST_MTEOM) != 0)\r\nSTp->fast_mteom = value;\r\nif ((options & MT_ST_AUTO_LOCK) != 0)\r\nSTp->do_auto_lock = value;\r\nif ((options & MT_ST_CAN_BSR) != 0)\r\nSTp->can_bsr = value;\r\nif ((options & MT_ST_NO_BLKLIMS) != 0)\r\nSTp->omit_blklims = value;\r\nif ((STp->device)->scsi_level >= SCSI_2 &&\r\n(options & MT_ST_CAN_PARTITIONS) != 0)\r\nSTp->can_partitions = value;\r\nif ((options & MT_ST_SCSI2LOGICAL) != 0)\r\nSTp->scsi2_logical = value;\r\nif ((options & MT_ST_NOWAIT) != 0)\r\nSTp->immediate = value;\r\nif ((options & MT_ST_NOWAIT_EOF) != 0)\r\nSTp->immediate_filemark = value;\r\nif ((options & MT_ST_SYSV) != 0)\r\nSTm->sysv = value;\r\nif ((options & MT_ST_SILI) != 0)\r\nSTp->sili = value;\r\nDEB(\r\nif ((options & MT_ST_DEBUGGING) != 0)\r\ndebugging = value;\r\nst_log_options(STp, STm, name); )\r\n} else if (code == MT_ST_WRITE_THRESHOLD) {\r\n} else if (code == MT_ST_DEF_BLKSIZE) {\r\nvalue = (options & ~MT_ST_OPTIONS);\r\nif (value == ~MT_ST_OPTIONS) {\r\nSTm->default_blksize = (-1);\r\nDEBC( printk(KERN_INFO "%s: Default block size disabled.\n", name));\r\n} else {\r\nSTm->default_blksize = value;\r\nDEBC( printk(KERN_INFO "%s: Default block size set to %d bytes.\n",\r\nname, STm->default_blksize));\r\nif (STp->ready == ST_READY) {\r\nSTp->blksize_changed = 0;\r\nset_mode_densblk(STp, STm);\r\n}\r\n}\r\n} else if (code == MT_ST_TIMEOUTS) {\r\nvalue = (options & ~MT_ST_OPTIONS);\r\nif ((value & MT_ST_SET_LONG_TIMEOUT) != 0) {\r\nSTp->long_timeout = (value & ~MT_ST_SET_LONG_TIMEOUT) * HZ;\r\nDEBC( printk(KERN_INFO "%s: Long timeout set to %d seconds.\n", name,\r\n(value & ~MT_ST_SET_LONG_TIMEOUT)));\r\n} else {\r\nblk_queue_rq_timeout(STp->device->request_queue,\r\nvalue * HZ);\r\nDEBC( printk(KERN_INFO "%s: Normal timeout set to %d seconds.\n",\r\nname, value) );\r\n}\r\n} else if (code == MT_ST_SET_CLN) {\r\nvalue = (options & ~MT_ST_OPTIONS) & 0xff;\r\nif (value != 0 &&\r\n(value < EXTENDED_SENSE_START ||\r\nvalue >= SCSI_SENSE_BUFFERSIZE))\r\nreturn (-EINVAL);\r\nSTp->cln_mode = value;\r\nSTp->cln_sense_mask = (options >> 8) & 0xff;\r\nSTp->cln_sense_value = (options >> 16) & 0xff;\r\nprintk(KERN_INFO\r\n"%s: Cleaning request mode %d, mask %02x, value %02x\n",\r\nname, value, STp->cln_sense_mask, STp->cln_sense_value);\r\n} else if (code == MT_ST_DEF_OPTIONS) {\r\ncode = (options & ~MT_ST_CLEAR_DEFAULT);\r\nvalue = (options & MT_ST_CLEAR_DEFAULT);\r\nif (code == MT_ST_DEF_DENSITY) {\r\nif (value == MT_ST_CLEAR_DEFAULT) {\r\nSTm->default_density = (-1);\r\nDEBC( printk(KERN_INFO "%s: Density default disabled.\n",\r\nname));\r\n} else {\r\nSTm->default_density = value & 0xff;\r\nDEBC( printk(KERN_INFO "%s: Density default set to %x\n",\r\nname, STm->default_density));\r\nif (STp->ready == ST_READY) {\r\nSTp->density_changed = 0;\r\nset_mode_densblk(STp, STm);\r\n}\r\n}\r\n} else if (code == MT_ST_DEF_DRVBUFFER) {\r\nif (value == MT_ST_CLEAR_DEFAULT) {\r\nSTp->default_drvbuffer = 0xff;\r\nDEBC( printk(KERN_INFO\r\n"%s: Drive buffer default disabled.\n", name));\r\n} else {\r\nSTp->default_drvbuffer = value & 7;\r\nDEBC( printk(KERN_INFO\r\n"%s: Drive buffer default set to %x\n",\r\nname, STp->default_drvbuffer));\r\nif (STp->ready == ST_READY)\r\nst_int_ioctl(STp, MTSETDRVBUFFER, STp->default_drvbuffer);\r\n}\r\n} else if (code == MT_ST_DEF_COMPRESSION) {\r\nif (value == MT_ST_CLEAR_DEFAULT) {\r\nSTm->default_compression = ST_DONT_TOUCH;\r\nDEBC( printk(KERN_INFO\r\n"%s: Compression default disabled.\n", name));\r\n} else {\r\nif ((value & 0xff00) != 0) {\r\nSTp->c_algo = (value & 0xff00) >> 8;\r\nDEBC( printk(KERN_INFO "%s: Compression algorithm set to 0x%x.\n",\r\nname, STp->c_algo));\r\n}\r\nif ((value & 0xff) != 0xff) {\r\nSTm->default_compression = (value & 1 ? ST_YES : ST_NO);\r\nDEBC( printk(KERN_INFO "%s: Compression default set to %x\n",\r\nname, (value & 1)));\r\nif (STp->ready == ST_READY) {\r\nSTp->compression_changed = 0;\r\nst_compression(STp, (STm->default_compression == ST_YES));\r\n}\r\n}\r\n}\r\n}\r\n} else\r\nreturn (-EIO);\r\nreturn 0;\r\n}\r\nstatic int read_mode_page(struct scsi_tape *STp, int page, int omit_block_descs)\r\n{\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SENSE;\r\nif (omit_block_descs)\r\ncmd[1] = MODE_SENSE_OMIT_BDESCS;\r\ncmd[2] = page;\r\ncmd[4] = 255;\r\nSRpnt = st_do_scsi(NULL, STp, cmd, cmd[4], DMA_FROM_DEVICE,\r\nSTp->device->request_queue->rq_timeout, 0, 1);\r\nif (SRpnt == NULL)\r\nreturn (STp->buffer)->syscall_result;\r\nst_release_request(SRpnt);\r\nreturn STp->buffer->syscall_result;\r\n}\r\nstatic int write_mode_page(struct scsi_tape *STp, int page, int slow)\r\n{\r\nint pgo;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt;\r\nint timeout;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = MODE_SELECT;\r\ncmd[1] = MODE_SELECT_PAGE_FORMAT;\r\npgo = MODE_HEADER_LENGTH + (STp->buffer)->b_data[MH_OFF_BDESCS_LENGTH];\r\ncmd[4] = pgo + (STp->buffer)->b_data[pgo + MP_OFF_PAGE_LENGTH] + 2;\r\n(STp->buffer)->b_data[MH_OFF_DATA_LENGTH] = 0;\r\n(STp->buffer)->b_data[MH_OFF_MEDIUM_TYPE] = 0;\r\n(STp->buffer)->b_data[MH_OFF_DEV_SPECIFIC] &= ~MH_BIT_WP;\r\n(STp->buffer)->b_data[pgo + MP_OFF_PAGE_NBR] &= MP_MSK_PAGE_NBR;\r\ntimeout = slow ?\r\nSTp->long_timeout : STp->device->request_queue->rq_timeout;\r\nSRpnt = st_do_scsi(NULL, STp, cmd, cmd[4], DMA_TO_DEVICE,\r\ntimeout, 0, 1);\r\nif (SRpnt == NULL)\r\nreturn (STp->buffer)->syscall_result;\r\nst_release_request(SRpnt);\r\nreturn STp->buffer->syscall_result;\r\n}\r\nstatic int st_compression(struct scsi_tape * STp, int state)\r\n{\r\nint retval;\r\nint mpoffs;\r\nunsigned char *b_data = (STp->buffer)->b_data;\r\nDEB( char *name = tape_name(STp); )\r\nif (STp->ready != ST_READY)\r\nreturn (-EIO);\r\nretval = read_mode_page(STp, COMPRESSION_PAGE, 0);\r\nif (retval) {\r\nDEBC(printk(ST_DEB_MSG "%s: Compression mode page not supported.\n",\r\nname));\r\nreturn (-EIO);\r\n}\r\nmpoffs = MODE_HEADER_LENGTH + b_data[MH_OFF_BDESCS_LENGTH];\r\nDEBC(printk(ST_DEB_MSG "%s: Compression state is %d.\n", name,\r\n(b_data[mpoffs + CP_OFF_DCE_DCC] & DCE_MASK ? 1 : 0)));\r\nif ((b_data[mpoffs + CP_OFF_DCE_DCC] & DCC_MASK) == 0) {\r\nDEBC(printk(ST_DEB_MSG "%s: Compression not supported.\n", name));\r\nreturn (-EIO);\r\n}\r\nif (state) {\r\nb_data[mpoffs + CP_OFF_DCE_DCC] |= DCE_MASK;\r\nif (STp->c_algo != 0)\r\nb_data[mpoffs + CP_OFF_C_ALGO] = STp->c_algo;\r\n}\r\nelse {\r\nb_data[mpoffs + CP_OFF_DCE_DCC] &= ~DCE_MASK;\r\nif (STp->c_algo != 0)\r\nb_data[mpoffs + CP_OFF_C_ALGO] = 0;\r\n}\r\nretval = write_mode_page(STp, COMPRESSION_PAGE, 0);\r\nif (retval) {\r\nDEBC(printk(ST_DEB_MSG "%s: Compression change failed.\n", name));\r\nreturn (-EIO);\r\n}\r\nDEBC(printk(ST_DEB_MSG "%s: Compression state changed to %d.\n",\r\nname, state));\r\nSTp->compression_changed = 1;\r\nreturn 0;\r\n}\r\nstatic int do_load_unload(struct scsi_tape *STp, struct file *filp, int load_code)\r\n{\r\nint retval = (-EIO), timeout;\r\nDEB( char *name = tape_name(STp); )\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct st_partstat *STps;\r\nstruct st_request *SRpnt;\r\nif (STp->ready != ST_READY && !load_code) {\r\nif (STp->ready == ST_NO_TAPE)\r\nreturn (-ENOMEDIUM);\r\nelse\r\nreturn (-EIO);\r\n}\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\ncmd[0] = START_STOP;\r\nif (load_code)\r\ncmd[4] |= 1;\r\nif (load_code >= 1 + MT_ST_HPLOADER_OFFSET\r\n&& load_code <= 6 + MT_ST_HPLOADER_OFFSET) {\r\nDEBC(printk(ST_DEB_MSG "%s: Enhanced %sload slot %2d.\n",\r\nname, (cmd[4]) ? "" : "un",\r\nload_code - MT_ST_HPLOADER_OFFSET));\r\ncmd[3] = load_code - MT_ST_HPLOADER_OFFSET;\r\n}\r\nif (STp->immediate) {\r\ncmd[1] = 1;\r\ntimeout = STp->device->request_queue->rq_timeout;\r\n}\r\nelse\r\ntimeout = STp->long_timeout;\r\nDEBC(\r\nif (!load_code)\r\nprintk(ST_DEB_MSG "%s: Unloading tape.\n", name);\r\nelse\r\nprintk(ST_DEB_MSG "%s: Loading tape.\n", name);\r\n);\r\nSRpnt = st_do_scsi(NULL, STp, cmd, 0, DMA_NONE,\r\ntimeout, MAX_RETRIES, 1);\r\nif (!SRpnt)\r\nreturn (STp->buffer)->syscall_result;\r\nretval = (STp->buffer)->syscall_result;\r\nst_release_request(SRpnt);\r\nif (!retval) {\r\nif (!load_code) {\r\nSTp->rew_at_close = 0;\r\nSTp->ready = ST_NO_TAPE;\r\n}\r\nelse {\r\nSTp->rew_at_close = STp->autorew_dev;\r\nretval = check_tape(STp, filp);\r\nif (retval > 0)\r\nretval = 0;\r\n}\r\n}\r\nelse {\r\nSTps = &(STp->ps[STp->partition]);\r\nSTps->drv_file = STps->drv_block = (-1);\r\n}\r\nreturn retval;\r\n}\r\nstatic void deb_space_print(char *name, int direction, char *units, unsigned char *cmd)\r\n{\r\ns32 sc;\r\nsc = cmd[2] & 0x80 ? 0xff000000 : 0;\r\nsc |= (cmd[2] << 16) | (cmd[3] << 8) | cmd[4];\r\nif (direction)\r\nsc = -sc;\r\nprintk(ST_DEB_MSG "%s: Spacing tape %s over %d %s.\n", name,\r\ndirection ? "backward" : "forward", sc, units);\r\n}\r\nstatic int st_int_ioctl(struct scsi_tape *STp, unsigned int cmd_in, unsigned long arg)\r\n{\r\nint timeout;\r\nlong ltmp;\r\nint ioctl_result;\r\nint chg_eof = 1;\r\nunsigned char cmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt;\r\nstruct st_partstat *STps;\r\nint fileno, blkno, at_sm, undone;\r\nint datalen = 0, direction = DMA_NONE;\r\nchar *name = tape_name(STp);\r\nWARN_ON(STp->buffer->do_dio != 0);\r\nif (STp->ready != ST_READY) {\r\nif (STp->ready == ST_NO_TAPE)\r\nreturn (-ENOMEDIUM);\r\nelse\r\nreturn (-EIO);\r\n}\r\ntimeout = STp->long_timeout;\r\nSTps = &(STp->ps[STp->partition]);\r\nfileno = STps->drv_file;\r\nblkno = STps->drv_block;\r\nat_sm = STps->at_sm;\r\nmemset(cmd, 0, MAX_COMMAND_SIZE);\r\nswitch (cmd_in) {\r\ncase MTFSFM:\r\nchg_eof = 0;\r\ncase MTFSF:\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x01;\r\ncmd[2] = (arg >> 16);\r\ncmd[3] = (arg >> 8);\r\ncmd[4] = arg;\r\nDEBC(deb_space_print(name, ST_DEB_FORWARD, "filemarks", cmd);)\r\nif (fileno >= 0)\r\nfileno += arg;\r\nblkno = 0;\r\nat_sm &= (arg == 0);\r\nbreak;\r\ncase MTBSFM:\r\nchg_eof = 0;\r\ncase MTBSF:\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x01;\r\nltmp = (-arg);\r\ncmd[2] = (ltmp >> 16);\r\ncmd[3] = (ltmp >> 8);\r\ncmd[4] = ltmp;\r\nDEBC(deb_space_print(name, ST_DEB_BACKWARD, "filemarks", cmd);)\r\nif (fileno >= 0)\r\nfileno -= arg;\r\nblkno = (-1);\r\nat_sm &= (arg == 0);\r\nbreak;\r\ncase MTFSR:\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x00;\r\ncmd[2] = (arg >> 16);\r\ncmd[3] = (arg >> 8);\r\ncmd[4] = arg;\r\nDEBC(deb_space_print(name, ST_DEB_FORWARD, "blocks", cmd);)\r\nif (blkno >= 0)\r\nblkno += arg;\r\nat_sm &= (arg == 0);\r\nbreak;\r\ncase MTBSR:\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x00;\r\nltmp = (-arg);\r\ncmd[2] = (ltmp >> 16);\r\ncmd[3] = (ltmp >> 8);\r\ncmd[4] = ltmp;\r\nDEBC(deb_space_print(name, ST_DEB_BACKWARD, "blocks", cmd);)\r\nif (blkno >= 0)\r\nblkno -= arg;\r\nat_sm &= (arg == 0);\r\nbreak;\r\ncase MTFSS:\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x04;\r\ncmd[2] = (arg >> 16);\r\ncmd[3] = (arg >> 8);\r\ncmd[4] = arg;\r\nDEBC(deb_space_print(name, ST_DEB_FORWARD, "setmarks", cmd);)\r\nif (arg != 0) {\r\nblkno = fileno = (-1);\r\nat_sm = 1;\r\n}\r\nbreak;\r\ncase MTBSS:\r\ncmd[0] = SPACE;\r\ncmd[1] = 0x04;\r\nltmp = (-arg);\r\ncmd[2] = (ltmp >> 16);\r\ncmd[3] = (ltmp >> 8);\r\ncmd[4] = ltmp;\r\nDEBC(deb_space_print(name, ST_DEB_BACKWARD, "setmarks", cmd);)\r\nif (arg != 0) {\r\nblkno = fileno = (-1);\r\nat_sm = 1;\r\n}\r\nbreak;\r\ncase MTWEOF:\r\ncase MTWEOFI:\r\ncase MTWSM:\r\nif (STp->write_prot)\r\nreturn (-EACCES);\r\ncmd[0] = WRITE_FILEMARKS;\r\nif (cmd_in == MTWSM)\r\ncmd[1] = 2;\r\nif (cmd_in == MTWEOFI ||\r\n(cmd_in == MTWEOF && STp->immediate_filemark))\r\ncmd[1] |= 1;\r\ncmd[2] = (arg >> 16);\r\ncmd[3] = (arg >> 8);\r\ncmd[4] = arg;\r\ntimeout = STp->device->request_queue->rq_timeout;\r\nDEBC(\r\nif (cmd_in != MTWSM)\r\nprintk(ST_DEB_MSG "%s: Writing %d filemarks.\n", name,\r\ncmd[2] * 65536 + cmd[3] * 256 + cmd[4]);\r\nelse\r\nprintk(ST_DEB_MSG "%s: Writing %d setmarks.\n", name,\r\ncmd[2] * 65536 + cmd[3] * 256 + cmd[4]);\r\n)\r\nif (fileno >= 0)\r\nfileno += arg;\r\nblkno = 0;\r\nat_sm = (cmd_in == MTWSM);\r\nbreak;\r\ncase MTREW:\r\ncmd[0] = REZERO_UNIT;\r\nif (STp->immediate) {\r\ncmd[1] = 1;\r\ntimeout = STp->device->request_queue->rq_timeout;\r\n}\r\nDEBC(printk(ST_DEB_MSG "%s: Rewinding tape.\n", name));\r\nfileno = blkno = at_sm = 0;\r\nbreak;\r\ncase MTNOP:\r\nDEBC(printk(ST_DEB_MSG "%s: No op on tape.\n", name));\r\nreturn 0;\r\nbreak;\r\ncase MTRETEN:\r\ncmd[0] = START_STOP;\r\nif (STp->immediate) {\r\ncmd[1] = 1;\r\ntimeout = STp->device->request_queue->rq_timeout;\r\n}\r\ncmd[4] = 3;\r\nDEBC(printk(ST_DEB_MSG "%s: Retensioning tape.\n", name));\r\nfileno = blkno = at_sm = 0;\r\nbreak;\r\ncase MTEOM:\r\nif (!STp->fast_mteom) {\r\nioctl_result = st_int_ioctl(STp, MTFSF, 0x7fffff);\r\nfileno = STps->drv_file;\r\nif (STps->eof >= ST_EOD_1)\r\nreturn 0;\r\n} else\r\nfileno = (-1);\r\ncmd[0] = SPACE;\r\ncmd[1] = 3;\r\nDEBC(printk(ST_DEB_MSG "%s: Spacing to end of recorded medium.\n",\r\nname));\r\nblkno = -1;\r\nat_sm = 0;\r\nbreak;\r\ncase MTERASE:\r\nif (STp->write_prot)\r\nreturn (-EACCES);\r\ncmd[0] = ERASE;\r\ncmd[1] = (arg ? 1 : 0);\r\nif (STp->immediate) {\r\ncmd[1] |= 2;\r\ntimeout = STp->device->request_queue->rq_timeout;\r\n}\r\nelse\r\ntimeout = STp->long_timeout * 8;\r\nDEBC(printk(ST_DEB_MSG "%s: Erasing tape.\n", name));\r\nfileno = blkno = at_sm = 0;\r\nbreak;\r\ncase MTSETBLK:\r\ncase MTSETDENSITY:\r\ncase MTSETDRVBUFFER:\r\ncase SET_DENS_AND_BLK:\r\nchg_eof = 0;\r\nif (STp->dirty || (STp->buffer)->buffer_bytes != 0)\r\nreturn (-EIO);\r\nif ((cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK) &&\r\n(arg & MT_ST_BLKSIZE_MASK) != 0 &&\r\nSTp->max_block > 0 &&\r\n((arg & MT_ST_BLKSIZE_MASK) < STp->min_block ||\r\n(arg & MT_ST_BLKSIZE_MASK) > STp->max_block)) {\r\nprintk(KERN_WARNING "%s: Illegal block size.\n", name);\r\nreturn (-EINVAL);\r\n}\r\ncmd[0] = MODE_SELECT;\r\nif ((STp->use_pf & USE_PF))\r\ncmd[1] = MODE_SELECT_PAGE_FORMAT;\r\ncmd[4] = datalen = 12;\r\ndirection = DMA_TO_DEVICE;\r\nmemset((STp->buffer)->b_data, 0, 12);\r\nif (cmd_in == MTSETDRVBUFFER)\r\n(STp->buffer)->b_data[2] = (arg & 7) << 4;\r\nelse\r\n(STp->buffer)->b_data[2] =\r\nSTp->drv_buffer << 4;\r\n(STp->buffer)->b_data[3] = 8;\r\nif (cmd_in == MTSETDENSITY) {\r\n(STp->buffer)->b_data[4] = arg;\r\nSTp->density_changed = 1;\r\n} else if (cmd_in == SET_DENS_AND_BLK)\r\n(STp->buffer)->b_data[4] = arg >> 24;\r\nelse\r\n(STp->buffer)->b_data[4] = STp->density;\r\nif (cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK) {\r\nltmp = arg & MT_ST_BLKSIZE_MASK;\r\nif (cmd_in == MTSETBLK)\r\nSTp->blksize_changed = 1;\r\n} else\r\nltmp = STp->block_size;\r\n(STp->buffer)->b_data[9] = (ltmp >> 16);\r\n(STp->buffer)->b_data[10] = (ltmp >> 8);\r\n(STp->buffer)->b_data[11] = ltmp;\r\ntimeout = STp->device->request_queue->rq_timeout;\r\nDEBC(\r\nif (cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK)\r\nprintk(ST_DEB_MSG\r\n"%s: Setting block size to %d bytes.\n", name,\r\n(STp->buffer)->b_data[9] * 65536 +\r\n(STp->buffer)->b_data[10] * 256 +\r\n(STp->buffer)->b_data[11]);\r\nif (cmd_in == MTSETDENSITY || cmd_in == SET_DENS_AND_BLK)\r\nprintk(ST_DEB_MSG\r\n"%s: Setting density code to %x.\n", name,\r\n(STp->buffer)->b_data[4]);\r\nif (cmd_in == MTSETDRVBUFFER)\r\nprintk(ST_DEB_MSG\r\n"%s: Setting drive buffer code to %d.\n", name,\r\n((STp->buffer)->b_data[2] >> 4) & 7);\r\n)\r\nbreak;\r\ndefault:\r\nreturn (-ENOSYS);\r\n}\r\nSRpnt = st_do_scsi(NULL, STp, cmd, datalen, direction,\r\ntimeout, MAX_RETRIES, 1);\r\nif (!SRpnt)\r\nreturn (STp->buffer)->syscall_result;\r\nioctl_result = (STp->buffer)->syscall_result;\r\nif (!ioctl_result) {\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nSTps->drv_block = blkno;\r\nSTps->drv_file = fileno;\r\nSTps->at_sm = at_sm;\r\nif (cmd_in == MTBSFM)\r\nioctl_result = st_int_ioctl(STp, MTFSF, 1);\r\nelse if (cmd_in == MTFSFM)\r\nioctl_result = st_int_ioctl(STp, MTBSF, 1);\r\nif (cmd_in == MTSETBLK || cmd_in == SET_DENS_AND_BLK) {\r\nSTp->block_size = arg & MT_ST_BLKSIZE_MASK;\r\nif (STp->block_size != 0) {\r\n(STp->buffer)->buffer_blocks =\r\n(STp->buffer)->buffer_size / STp->block_size;\r\n}\r\n(STp->buffer)->buffer_bytes = (STp->buffer)->read_pointer = 0;\r\nif (cmd_in == SET_DENS_AND_BLK)\r\nSTp->density = arg >> MT_ST_DENSITY_SHIFT;\r\n} else if (cmd_in == MTSETDRVBUFFER)\r\nSTp->drv_buffer = (arg & 7);\r\nelse if (cmd_in == MTSETDENSITY)\r\nSTp->density = arg;\r\nif (cmd_in == MTEOM)\r\nSTps->eof = ST_EOD;\r\nelse if (cmd_in == MTFSF)\r\nSTps->eof = ST_FM;\r\nelse if (chg_eof)\r\nSTps->eof = ST_NOEOF;\r\nif (cmd_in == MTWEOF || cmd_in == MTWEOFI)\r\nSTps->rw = ST_IDLE;\r\n} else {\r\nstruct st_cmdstatus *cmdstatp = &STp->buffer->cmdstat;\r\nif (cmdstatp->flags & SENSE_EOM) {\r\nif (cmd_in != MTBSF && cmd_in != MTBSFM &&\r\ncmd_in != MTBSR && cmd_in != MTBSS)\r\nSTps->eof = ST_EOM_OK;\r\nSTps->drv_block = 0;\r\n}\r\nif (cmdstatp->remainder_valid)\r\nundone = (int)cmdstatp->uremainder64;\r\nelse\r\nundone = 0;\r\nif ((cmd_in == MTWEOF || cmd_in == MTWEOFI) &&\r\ncmdstatp->have_sense &&\r\n(cmdstatp->flags & SENSE_EOM)) {\r\nif (cmdstatp->sense_hdr.sense_key == NO_SENSE ||\r\ncmdstatp->sense_hdr.sense_key == RECOVERED_ERROR) {\r\nioctl_result = 0;\r\nSTps->eof = ST_NOEOF;\r\n} else {\r\nif (fileno >= 0)\r\nfileno -= undone;\r\nif (undone < arg)\r\nSTps->eof = ST_NOEOF;\r\n}\r\nSTps->drv_file = fileno;\r\n} else if ((cmd_in == MTFSF) || (cmd_in == MTFSFM)) {\r\nif (fileno >= 0)\r\nSTps->drv_file = fileno - undone;\r\nelse\r\nSTps->drv_file = fileno;\r\nSTps->drv_block = -1;\r\nSTps->eof = ST_NOEOF;\r\n} else if ((cmd_in == MTBSF) || (cmd_in == MTBSFM)) {\r\nif (arg > 0 && undone < 0)\r\nundone = (-undone);\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file = fileno + undone;\r\nSTps->drv_block = 0;\r\nSTps->eof = ST_NOEOF;\r\n} else if (cmd_in == MTFSR) {\r\nif (cmdstatp->flags & SENSE_FMK) {\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file++;\r\nSTps->drv_block = 0;\r\nSTps->eof = ST_FM;\r\n} else {\r\nif (blkno >= undone)\r\nSTps->drv_block = blkno - undone;\r\nelse\r\nSTps->drv_block = (-1);\r\nSTps->eof = ST_NOEOF;\r\n}\r\n} else if (cmd_in == MTBSR) {\r\nif (cmdstatp->flags & SENSE_FMK) {\r\nSTps->drv_file--;\r\nSTps->drv_block = (-1);\r\n} else {\r\nif (arg > 0 && undone < 0)\r\nundone = (-undone);\r\nif (STps->drv_block >= 0)\r\nSTps->drv_block = blkno + undone;\r\n}\r\nSTps->eof = ST_NOEOF;\r\n} else if (cmd_in == MTEOM) {\r\nSTps->drv_file = (-1);\r\nSTps->drv_block = (-1);\r\nSTps->eof = ST_EOD;\r\n} else if (cmd_in == MTSETBLK ||\r\ncmd_in == MTSETDENSITY ||\r\ncmd_in == MTSETDRVBUFFER ||\r\ncmd_in == SET_DENS_AND_BLK) {\r\nif (cmdstatp->sense_hdr.sense_key == ILLEGAL_REQUEST &&\r\n!(STp->use_pf & PF_TESTED)) {\r\nSTp->use_pf = (STp->use_pf ^ USE_PF) | PF_TESTED;\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nreturn st_int_ioctl(STp, cmd_in, arg);\r\n}\r\n} else if (chg_eof)\r\nSTps->eof = ST_NOEOF;\r\nif (cmdstatp->sense_hdr.sense_key == BLANK_CHECK)\r\nSTps->eof = ST_EOD;\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\n}\r\nreturn ioctl_result;\r\n}\r\nstatic int get_location(struct scsi_tape *STp, unsigned int *block, int *partition,\r\nint logical)\r\n{\r\nint result;\r\nunsigned char scmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt;\r\nDEB( char *name = tape_name(STp); )\r\nif (STp->ready != ST_READY)\r\nreturn (-EIO);\r\nmemset(scmd, 0, MAX_COMMAND_SIZE);\r\nif ((STp->device)->scsi_level < SCSI_2) {\r\nscmd[0] = QFA_REQUEST_BLOCK;\r\nscmd[4] = 3;\r\n} else {\r\nscmd[0] = READ_POSITION;\r\nif (!logical && !STp->scsi2_logical)\r\nscmd[1] = 1;\r\n}\r\nSRpnt = st_do_scsi(NULL, STp, scmd, 20, DMA_FROM_DEVICE,\r\nSTp->device->request_queue->rq_timeout,\r\nMAX_READY_RETRIES, 1);\r\nif (!SRpnt)\r\nreturn (STp->buffer)->syscall_result;\r\nif ((STp->buffer)->syscall_result != 0 ||\r\n(STp->device->scsi_level >= SCSI_2 &&\r\n((STp->buffer)->b_data[0] & 4) != 0)) {\r\n*block = *partition = 0;\r\nDEBC(printk(ST_DEB_MSG "%s: Can't read tape position.\n", name));\r\nresult = (-EIO);\r\n} else {\r\nresult = 0;\r\nif ((STp->device)->scsi_level < SCSI_2) {\r\n*block = ((STp->buffer)->b_data[0] << 16)\r\n+ ((STp->buffer)->b_data[1] << 8)\r\n+ (STp->buffer)->b_data[2];\r\n*partition = 0;\r\n} else {\r\n*block = ((STp->buffer)->b_data[4] << 24)\r\n+ ((STp->buffer)->b_data[5] << 16)\r\n+ ((STp->buffer)->b_data[6] << 8)\r\n+ (STp->buffer)->b_data[7];\r\n*partition = (STp->buffer)->b_data[1];\r\nif (((STp->buffer)->b_data[0] & 0x80) &&\r\n(STp->buffer)->b_data[1] == 0)\r\nSTp->ps[0].drv_block = STp->ps[0].drv_file = 0;\r\n}\r\nDEBC(printk(ST_DEB_MSG "%s: Got tape pos. blk %d part %d.\n", name,\r\n*block, *partition));\r\n}\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nreturn result;\r\n}\r\nstatic int set_location(struct scsi_tape *STp, unsigned int block, int partition,\r\nint logical)\r\n{\r\nstruct st_partstat *STps;\r\nint result, p;\r\nunsigned int blk;\r\nint timeout;\r\nunsigned char scmd[MAX_COMMAND_SIZE];\r\nstruct st_request *SRpnt;\r\nDEB( char *name = tape_name(STp); )\r\nif (STp->ready != ST_READY)\r\nreturn (-EIO);\r\ntimeout = STp->long_timeout;\r\nSTps = &(STp->ps[STp->partition]);\r\nDEBC(printk(ST_DEB_MSG "%s: Setting block to %d and partition to %d.\n",\r\nname, block, partition));\r\nDEB(if (partition < 0)\r\nreturn (-EIO); )\r\nif ((!STp->can_partitions && partition != 0) ||\r\npartition >= ST_NBR_PARTITIONS)\r\nreturn (-EINVAL);\r\nif (partition != STp->partition) {\r\nif (get_location(STp, &blk, &p, 1))\r\nSTps->last_block_valid = 0;\r\nelse {\r\nSTps->last_block_valid = 1;\r\nSTps->last_block_visited = blk;\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Visited block %d for partition %d saved.\n",\r\nname, blk, STp->partition));\r\n}\r\n}\r\nmemset(scmd, 0, MAX_COMMAND_SIZE);\r\nif ((STp->device)->scsi_level < SCSI_2) {\r\nscmd[0] = QFA_SEEK_BLOCK;\r\nscmd[2] = (block >> 16);\r\nscmd[3] = (block >> 8);\r\nscmd[4] = block;\r\nscmd[5] = 0;\r\n} else {\r\nscmd[0] = SEEK_10;\r\nscmd[3] = (block >> 24);\r\nscmd[4] = (block >> 16);\r\nscmd[5] = (block >> 8);\r\nscmd[6] = block;\r\nif (!logical && !STp->scsi2_logical)\r\nscmd[1] = 4;\r\nif (STp->partition != partition) {\r\nscmd[1] |= 2;\r\nscmd[8] = partition;\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Trying to change partition from %d to %d\n",\r\nname, STp->partition, partition));\r\n}\r\n}\r\nif (STp->immediate) {\r\nscmd[1] |= 1;\r\ntimeout = STp->device->request_queue->rq_timeout;\r\n}\r\nSRpnt = st_do_scsi(NULL, STp, scmd, 0, DMA_NONE,\r\ntimeout, MAX_READY_RETRIES, 1);\r\nif (!SRpnt)\r\nreturn (STp->buffer)->syscall_result;\r\nSTps->drv_block = STps->drv_file = (-1);\r\nSTps->eof = ST_NOEOF;\r\nif ((STp->buffer)->syscall_result != 0) {\r\nresult = (-EIO);\r\nif (STp->can_partitions &&\r\n(STp->device)->scsi_level >= SCSI_2 &&\r\n(p = find_partition(STp)) >= 0)\r\nSTp->partition = p;\r\n} else {\r\nif (STp->can_partitions) {\r\nSTp->partition = partition;\r\nSTps = &(STp->ps[partition]);\r\nif (!STps->last_block_valid ||\r\nSTps->last_block_visited != block) {\r\nSTps->at_sm = 0;\r\nSTps->rw = ST_IDLE;\r\n}\r\n} else\r\nSTps->at_sm = 0;\r\nif (block == 0)\r\nSTps->drv_block = STps->drv_file = 0;\r\nresult = 0;\r\n}\r\nst_release_request(SRpnt);\r\nSRpnt = NULL;\r\nreturn result;\r\n}\r\nstatic int find_partition(struct scsi_tape *STp)\r\n{\r\nint i, partition;\r\nunsigned int block;\r\nif ((i = get_location(STp, &block, &partition, 1)) < 0)\r\nreturn i;\r\nif (partition >= ST_NBR_PARTITIONS)\r\nreturn (-EIO);\r\nreturn partition;\r\n}\r\nstatic int switch_partition(struct scsi_tape *STp)\r\n{\r\nstruct st_partstat *STps;\r\nif (STp->partition == STp->new_partition)\r\nreturn 0;\r\nSTps = &(STp->ps[STp->new_partition]);\r\nif (!STps->last_block_valid)\r\nSTps->last_block_visited = 0;\r\nreturn set_location(STp, STps->last_block_visited, STp->new_partition, 1);\r\n}\r\nstatic int nbr_partitions(struct scsi_tape *STp)\r\n{\r\nint result;\r\nDEB( char *name = tape_name(STp); )\r\nif (STp->ready != ST_READY)\r\nreturn (-EIO);\r\nresult = read_mode_page(STp, PART_PAGE, 1);\r\nif (result) {\r\nDEBC(printk(ST_DEB_MSG "%s: Can't read medium partition page.\n",\r\nname));\r\nresult = (-EIO);\r\n} else {\r\nresult = (STp->buffer)->b_data[MODE_HEADER_LENGTH +\r\nPP_OFF_NBR_ADD_PARTS] + 1;\r\nDEBC(printk(ST_DEB_MSG "%s: Number of partitions %d.\n", name, result));\r\n}\r\nreturn result;\r\n}\r\nstatic int partition_tape(struct scsi_tape *STp, int size)\r\n{\r\nchar *name = tape_name(STp);\r\nint result;\r\nint pgo, psd_cnt, psdo;\r\nunsigned char *bp;\r\nresult = read_mode_page(STp, PART_PAGE, 0);\r\nif (result) {\r\nDEBC(printk(ST_DEB_MSG "%s: Can't read partition mode page.\n", name));\r\nreturn result;\r\n}\r\nbp = (STp->buffer)->b_data;\r\npgo = MODE_HEADER_LENGTH + bp[MH_OFF_BDESCS_LENGTH];\r\nDEBC(printk(ST_DEB_MSG "%s: Partition page length is %d bytes.\n",\r\nname, bp[pgo + MP_OFF_PAGE_LENGTH] + 2));\r\npsd_cnt = (bp[pgo + MP_OFF_PAGE_LENGTH] + 2 - PART_PAGE_FIXED_LENGTH) / 2;\r\npsdo = pgo + PART_PAGE_FIXED_LENGTH;\r\nif (psd_cnt > bp[pgo + PP_OFF_MAX_ADD_PARTS]) {\r\nbp[psdo] = bp[psdo + 1] = 0xff;\r\npsdo += 2;\r\n}\r\nmemset(bp + psdo, 0, bp[pgo + PP_OFF_NBR_ADD_PARTS] * 2);\r\nDEBC(printk("%s: psd_cnt %d, max.parts %d, nbr_parts %d\n", name,\r\npsd_cnt, bp[pgo + PP_OFF_MAX_ADD_PARTS],\r\nbp[pgo + PP_OFF_NBR_ADD_PARTS]));\r\nif (size <= 0) {\r\nbp[pgo + PP_OFF_NBR_ADD_PARTS] = 0;\r\nif (psd_cnt <= bp[pgo + PP_OFF_MAX_ADD_PARTS])\r\nbp[pgo + MP_OFF_PAGE_LENGTH] = 6;\r\nDEBC(printk(ST_DEB_MSG "%s: Formatting tape with one partition.\n",\r\nname));\r\n} else {\r\nbp[psdo] = (size >> 8) & 0xff;\r\nbp[psdo + 1] = size & 0xff;\r\nbp[pgo + 3] = 1;\r\nif (bp[pgo + MP_OFF_PAGE_LENGTH] < 8)\r\nbp[pgo + MP_OFF_PAGE_LENGTH] = 8;\r\nDEBC(printk(ST_DEB_MSG\r\n"%s: Formatting tape with two partitions (1 = %d MB).\n",\r\nname, size));\r\n}\r\nbp[pgo + PP_OFF_PART_UNITS] = 0;\r\nbp[pgo + PP_OFF_RESERVED] = 0;\r\nbp[pgo + PP_OFF_FLAGS] = PP_BIT_IDP | PP_MSK_PSUM_MB;\r\nresult = write_mode_page(STp, PART_PAGE, 1);\r\nif (result) {\r\nprintk(KERN_INFO "%s: Partitioning of tape failed.\n", name);\r\nresult = (-EIO);\r\n}\r\nreturn result;\r\n}\r\nstatic long st_ioctl(struct file *file, unsigned int cmd_in, unsigned long arg)\r\n{\r\nint i, cmd_nr, cmd_type, bt;\r\nint retval = 0;\r\nunsigned int blk;\r\nstruct scsi_tape *STp = file->private_data;\r\nstruct st_modedef *STm;\r\nstruct st_partstat *STps;\r\nchar *name = tape_name(STp);\r\nvoid __user *p = (void __user *)arg;\r\nif (mutex_lock_interruptible(&STp->lock))\r\nreturn -ERESTARTSYS;\r\nDEB(\r\nif (debugging && !STp->in_use) {\r\nprintk(ST_DEB_MSG "%s: Incorrect device.\n", name);\r\nretval = (-EIO);\r\ngoto out;\r\n} )\r\nSTm = &(STp->modes[STp->current_mode]);\r\nSTps = &(STp->ps[STp->partition]);\r\nretval = scsi_nonblockable_ioctl(STp->device, cmd_in, p,\r\nfile->f_flags & O_NDELAY);\r\nif (!scsi_block_when_processing_errors(STp->device) || retval != -ENODEV)\r\ngoto out;\r\nretval = 0;\r\ncmd_type = _IOC_TYPE(cmd_in);\r\ncmd_nr = _IOC_NR(cmd_in);\r\nif (cmd_type == _IOC_TYPE(MTIOCTOP) && cmd_nr == _IOC_NR(MTIOCTOP)) {\r\nstruct mtop mtc;\r\nif (_IOC_SIZE(cmd_in) != sizeof(mtc)) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\ni = copy_from_user(&mtc, p, sizeof(struct mtop));\r\nif (i) {\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTSETDRVBUFFER && !capable(CAP_SYS_ADMIN)) {\r\nprintk(KERN_WARNING\r\n"%s: MTSETDRVBUFFER only allowed for root.\n", name);\r\nretval = (-EPERM);\r\ngoto out;\r\n}\r\nif (!STm->defined &&\r\n(mtc.mt_op != MTSETDRVBUFFER &&\r\n(mtc.mt_count & MT_ST_OPTIONS) == 0)) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif (!STp->pos_unknown) {\r\nif (STps->eof == ST_FM_HIT) {\r\nif (mtc.mt_op == MTFSF || mtc.mt_op == MTFSFM ||\r\nmtc.mt_op == MTEOM) {\r\nmtc.mt_count -= 1;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file += 1;\r\n} else if (mtc.mt_op == MTBSF || mtc.mt_op == MTBSFM) {\r\nmtc.mt_count += 1;\r\nif (STps->drv_file >= 0)\r\nSTps->drv_file += 1;\r\n}\r\n}\r\nif (mtc.mt_op == MTSEEK) {\r\ni = !STp->can_partitions ||\r\n(STp->new_partition != STp->partition);\r\n} else {\r\ni = mtc.mt_op == MTREW || mtc.mt_op == MTOFFL ||\r\nmtc.mt_op == MTRETEN || mtc.mt_op == MTEOM ||\r\nmtc.mt_op == MTLOCK || mtc.mt_op == MTLOAD ||\r\nmtc.mt_op == MTFSF || mtc.mt_op == MTFSFM ||\r\nmtc.mt_op == MTBSF || mtc.mt_op == MTBSFM ||\r\nmtc.mt_op == MTCOMPRESSION;\r\n}\r\ni = flush_buffer(STp, i);\r\nif (i < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\nif (STps->rw == ST_WRITING &&\r\n(mtc.mt_op == MTREW || mtc.mt_op == MTOFFL ||\r\nmtc.mt_op == MTSEEK ||\r\nmtc.mt_op == MTBSF || mtc.mt_op == MTBSFM)) {\r\ni = st_int_ioctl(STp, MTWEOF, 1);\r\nif (i < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTBSF || mtc.mt_op == MTBSFM)\r\nmtc.mt_count++;\r\nSTps->rw = ST_IDLE;\r\n}\r\n} else {\r\nif (mtc.mt_op != MTREW &&\r\nmtc.mt_op != MTOFFL &&\r\nmtc.mt_op != MTRETEN &&\r\nmtc.mt_op != MTERASE &&\r\nmtc.mt_op != MTSEEK &&\r\nmtc.mt_op != MTEOM) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nreset_state(STp);\r\nSTp->device->was_reset = 0;\r\n}\r\nif (mtc.mt_op != MTNOP && mtc.mt_op != MTSETBLK &&\r\nmtc.mt_op != MTSETDENSITY && mtc.mt_op != MTWSM &&\r\nmtc.mt_op != MTSETDRVBUFFER && mtc.mt_op != MTSETPART)\r\nSTps->rw = ST_IDLE;\r\nif (mtc.mt_op == MTOFFL && STp->door_locked != ST_UNLOCKED)\r\ndo_door_lock(STp, 0);\r\nif (mtc.mt_op == MTSETDRVBUFFER &&\r\n(mtc.mt_count & MT_ST_OPTIONS) != 0) {\r\nretval = st_set_options(STp, mtc.mt_count);\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTSETPART) {\r\nif (!STp->can_partitions ||\r\nmtc.mt_count < 0 || mtc.mt_count >= ST_NBR_PARTITIONS) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nif (mtc.mt_count >= STp->nbr_partitions &&\r\n(STp->nbr_partitions = nbr_partitions(STp)) < 0) {\r\nretval = (-EIO);\r\ngoto out;\r\n}\r\nif (mtc.mt_count >= STp->nbr_partitions) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nSTp->new_partition = mtc.mt_count;\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTMKPART) {\r\nif (!STp->can_partitions) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nif ((i = st_int_ioctl(STp, MTREW, 0)) < 0 ||\r\n(i = partition_tape(STp, mtc.mt_count)) < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\r\nSTp->ps[i].rw = ST_IDLE;\r\nSTp->ps[i].at_sm = 0;\r\nSTp->ps[i].last_block_valid = 0;\r\n}\r\nSTp->partition = STp->new_partition = 0;\r\nSTp->nbr_partitions = 1;\r\nSTps->drv_block = STps->drv_file = 0;\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTSEEK) {\r\ni = set_location(STp, mtc.mt_count, STp->new_partition, 0);\r\nif (!STp->can_partitions)\r\nSTp->ps[0].rw = ST_IDLE;\r\nretval = i;\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTUNLOAD || mtc.mt_op == MTOFFL) {\r\nretval = do_load_unload(STp, file, 0);\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTLOAD) {\r\nretval = do_load_unload(STp, file, max(1, mtc.mt_count));\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTLOCK || mtc.mt_op == MTUNLOCK) {\r\nretval = do_door_lock(STp, (mtc.mt_op == MTLOCK));\r\ngoto out;\r\n}\r\nif (STp->can_partitions && STp->ready == ST_READY &&\r\n(i = switch_partition(STp)) < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\nif (mtc.mt_op == MTCOMPRESSION)\r\nretval = st_compression(STp, (mtc.mt_count & 1));\r\nelse\r\nretval = st_int_ioctl(STp, mtc.mt_op, mtc.mt_count);\r\ngoto out;\r\n}\r\nif (!STm->defined) {\r\nretval = (-ENXIO);\r\ngoto out;\r\n}\r\nif ((i = flush_buffer(STp, 0)) < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\nif (STp->can_partitions &&\r\n(i = switch_partition(STp)) < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\nif (cmd_type == _IOC_TYPE(MTIOCGET) && cmd_nr == _IOC_NR(MTIOCGET)) {\r\nstruct mtget mt_status;\r\nif (_IOC_SIZE(cmd_in) != sizeof(struct mtget)) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nmt_status.mt_type = STp->tape_type;\r\nmt_status.mt_dsreg =\r\n((STp->block_size << MT_ST_BLKSIZE_SHIFT) & MT_ST_BLKSIZE_MASK) |\r\n((STp->density << MT_ST_DENSITY_SHIFT) & MT_ST_DENSITY_MASK);\r\nmt_status.mt_blkno = STps->drv_block;\r\nmt_status.mt_fileno = STps->drv_file;\r\nif (STp->block_size != 0) {\r\nif (STps->rw == ST_WRITING)\r\nmt_status.mt_blkno +=\r\n(STp->buffer)->buffer_bytes / STp->block_size;\r\nelse if (STps->rw == ST_READING)\r\nmt_status.mt_blkno -=\r\n((STp->buffer)->buffer_bytes +\r\nSTp->block_size - 1) / STp->block_size;\r\n}\r\nmt_status.mt_gstat = 0;\r\nif (STp->drv_write_prot)\r\nmt_status.mt_gstat |= GMT_WR_PROT(0xffffffff);\r\nif (mt_status.mt_blkno == 0) {\r\nif (mt_status.mt_fileno == 0)\r\nmt_status.mt_gstat |= GMT_BOT(0xffffffff);\r\nelse\r\nmt_status.mt_gstat |= GMT_EOF(0xffffffff);\r\n}\r\nmt_status.mt_erreg = (STp->recover_reg << MT_ST_SOFTERR_SHIFT);\r\nmt_status.mt_resid = STp->partition;\r\nif (STps->eof == ST_EOM_OK || STps->eof == ST_EOM_ERROR)\r\nmt_status.mt_gstat |= GMT_EOT(0xffffffff);\r\nelse if (STps->eof >= ST_EOM_OK)\r\nmt_status.mt_gstat |= GMT_EOD(0xffffffff);\r\nif (STp->density == 1)\r\nmt_status.mt_gstat |= GMT_D_800(0xffffffff);\r\nelse if (STp->density == 2)\r\nmt_status.mt_gstat |= GMT_D_1600(0xffffffff);\r\nelse if (STp->density == 3)\r\nmt_status.mt_gstat |= GMT_D_6250(0xffffffff);\r\nif (STp->ready == ST_READY)\r\nmt_status.mt_gstat |= GMT_ONLINE(0xffffffff);\r\nif (STp->ready == ST_NO_TAPE)\r\nmt_status.mt_gstat |= GMT_DR_OPEN(0xffffffff);\r\nif (STps->at_sm)\r\nmt_status.mt_gstat |= GMT_SM(0xffffffff);\r\nif (STm->do_async_writes ||\r\n(STm->do_buffer_writes && STp->block_size != 0) ||\r\nSTp->drv_buffer != 0)\r\nmt_status.mt_gstat |= GMT_IM_REP_EN(0xffffffff);\r\nif (STp->cleaning_req)\r\nmt_status.mt_gstat |= GMT_CLN(0xffffffff);\r\ni = copy_to_user(p, &mt_status, sizeof(struct mtget));\r\nif (i) {\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\nSTp->recover_reg = 0;\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (cmd_type == _IOC_TYPE(MTIOCPOS) && cmd_nr == _IOC_NR(MTIOCPOS)) {\r\nstruct mtpos mt_pos;\r\nif (_IOC_SIZE(cmd_in) != sizeof(struct mtpos)) {\r\nretval = (-EINVAL);\r\ngoto out;\r\n}\r\nif ((i = get_location(STp, &blk, &bt, 0)) < 0) {\r\nretval = i;\r\ngoto out;\r\n}\r\nmt_pos.mt_blkno = blk;\r\ni = copy_to_user(p, &mt_pos, sizeof(struct mtpos));\r\nif (i)\r\nretval = (-EFAULT);\r\ngoto out;\r\n}\r\nmutex_unlock(&STp->lock);\r\nswitch (cmd_in) {\r\ncase SCSI_IOCTL_GET_IDLUN:\r\ncase SCSI_IOCTL_GET_BUS_NUMBER:\r\nbreak;\r\ndefault:\r\nif ((cmd_in == SG_IO ||\r\ncmd_in == SCSI_IOCTL_SEND_COMMAND ||\r\ncmd_in == CDROM_SEND_PACKET) &&\r\n!capable(CAP_SYS_RAWIO))\r\ni = -EPERM;\r\nelse\r\ni = scsi_cmd_ioctl(STp->disk->queue, STp->disk,\r\nfile->f_mode, cmd_in, p);\r\nif (i != -ENOTTY)\r\nreturn i;\r\nbreak;\r\n}\r\nretval = scsi_ioctl(STp->device, cmd_in, p);\r\nif (!retval && cmd_in == SCSI_IOCTL_STOP_UNIT) {\r\nSTp->rew_at_close = 0;\r\nSTp->ready = ST_NO_TAPE;\r\n}\r\nreturn retval;\r\nout:\r\nmutex_unlock(&STp->lock);\r\nreturn retval;\r\n}\r\nstatic long st_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct scsi_tape *STp = file->private_data;\r\nstruct scsi_device *sdev = STp->device;\r\nint ret = -ENOIOCTLCMD;\r\nif (sdev->host->hostt->compat_ioctl) {\r\nret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct st_buffer *new_tape_buffer(int need_dma, int max_sg)\r\n{\r\nstruct st_buffer *tb;\r\ntb = kzalloc(sizeof(struct st_buffer), GFP_ATOMIC);\r\nif (!tb) {\r\nprintk(KERN_NOTICE "st: Can't allocate new tape buffer.\n");\r\nreturn NULL;\r\n}\r\ntb->frp_segs = 0;\r\ntb->use_sg = max_sg;\r\ntb->dma = need_dma;\r\ntb->buffer_size = 0;\r\ntb->reserved_pages = kzalloc(max_sg * sizeof(struct page *),\r\nGFP_ATOMIC);\r\nif (!tb->reserved_pages) {\r\nkfree(tb);\r\nreturn NULL;\r\n}\r\nreturn tb;\r\n}\r\nstatic int enlarge_buffer(struct st_buffer * STbuffer, int new_size, int need_dma)\r\n{\r\nint segs, nbr, max_segs, b_size, order, got;\r\ngfp_t priority;\r\nif (new_size <= STbuffer->buffer_size)\r\nreturn 1;\r\nif (STbuffer->buffer_size <= PAGE_SIZE)\r\nnormalize_buffer(STbuffer);\r\nmax_segs = STbuffer->use_sg;\r\nnbr = max_segs - STbuffer->frp_segs;\r\nif (nbr <= 0)\r\nreturn 0;\r\npriority = GFP_KERNEL | __GFP_NOWARN;\r\nif (need_dma)\r\npriority |= GFP_DMA;\r\nif (STbuffer->cleared)\r\npriority |= __GFP_ZERO;\r\nif (STbuffer->frp_segs) {\r\norder = STbuffer->reserved_page_order;\r\nb_size = PAGE_SIZE << order;\r\n} else {\r\nfor (b_size = PAGE_SIZE, order = 0;\r\norder < ST_MAX_ORDER &&\r\nmax_segs * (PAGE_SIZE << order) < new_size;\r\norder++, b_size *= 2)\r\n;\r\nSTbuffer->reserved_page_order = order;\r\n}\r\nif (max_segs * (PAGE_SIZE << order) < new_size) {\r\nif (order == ST_MAX_ORDER)\r\nreturn 0;\r\nnormalize_buffer(STbuffer);\r\nreturn enlarge_buffer(STbuffer, new_size, need_dma);\r\n}\r\nfor (segs = STbuffer->frp_segs, got = STbuffer->buffer_size;\r\nsegs < max_segs && got < new_size;) {\r\nstruct page *page;\r\npage = alloc_pages(priority, order);\r\nif (!page) {\r\nDEB(STbuffer->buffer_size = got);\r\nnormalize_buffer(STbuffer);\r\nreturn 0;\r\n}\r\nSTbuffer->frp_segs += 1;\r\ngot += b_size;\r\nSTbuffer->buffer_size = got;\r\nSTbuffer->reserved_pages[segs] = page;\r\nsegs++;\r\n}\r\nSTbuffer->b_data = page_address(STbuffer->reserved_pages[0]);\r\nreturn 1;\r\n}\r\nstatic void clear_buffer(struct st_buffer * st_bp)\r\n{\r\nint i;\r\nfor (i=0; i < st_bp->frp_segs; i++)\r\nmemset(page_address(st_bp->reserved_pages[i]), 0,\r\nPAGE_SIZE << st_bp->reserved_page_order);\r\nst_bp->cleared = 1;\r\n}\r\nstatic void normalize_buffer(struct st_buffer * STbuffer)\r\n{\r\nint i, order = STbuffer->reserved_page_order;\r\nfor (i = 0; i < STbuffer->frp_segs; i++) {\r\n__free_pages(STbuffer->reserved_pages[i], order);\r\nSTbuffer->buffer_size -= (PAGE_SIZE << order);\r\n}\r\nSTbuffer->frp_segs = 0;\r\nSTbuffer->sg_segs = 0;\r\nSTbuffer->reserved_page_order = 0;\r\nSTbuffer->map_data.offset = 0;\r\n}\r\nstatic int append_to_buffer(const char __user *ubp, struct st_buffer * st_bp, int do_count)\r\n{\r\nint i, cnt, res, offset;\r\nint length = PAGE_SIZE << st_bp->reserved_page_order;\r\nfor (i = 0, offset = st_bp->buffer_bytes;\r\ni < st_bp->frp_segs && offset >= length; i++)\r\noffset -= length;\r\nif (i == st_bp->frp_segs) {\r\nprintk(KERN_WARNING "st: append_to_buffer offset overflow.\n");\r\nreturn (-EIO);\r\n}\r\nfor (; i < st_bp->frp_segs && do_count > 0; i++) {\r\nstruct page *page = st_bp->reserved_pages[i];\r\ncnt = length - offset < do_count ? length - offset : do_count;\r\nres = copy_from_user(page_address(page) + offset, ubp, cnt);\r\nif (res)\r\nreturn (-EFAULT);\r\ndo_count -= cnt;\r\nst_bp->buffer_bytes += cnt;\r\nubp += cnt;\r\noffset = 0;\r\n}\r\nif (do_count)\r\nreturn (-EIO);\r\nreturn 0;\r\n}\r\nstatic int from_buffer(struct st_buffer * st_bp, char __user *ubp, int do_count)\r\n{\r\nint i, cnt, res, offset;\r\nint length = PAGE_SIZE << st_bp->reserved_page_order;\r\nfor (i = 0, offset = st_bp->read_pointer;\r\ni < st_bp->frp_segs && offset >= length; i++)\r\noffset -= length;\r\nif (i == st_bp->frp_segs) {\r\nprintk(KERN_WARNING "st: from_buffer offset overflow.\n");\r\nreturn (-EIO);\r\n}\r\nfor (; i < st_bp->frp_segs && do_count > 0; i++) {\r\nstruct page *page = st_bp->reserved_pages[i];\r\ncnt = length - offset < do_count ? length - offset : do_count;\r\nres = copy_to_user(ubp, page_address(page) + offset, cnt);\r\nif (res)\r\nreturn (-EFAULT);\r\ndo_count -= cnt;\r\nst_bp->buffer_bytes -= cnt;\r\nst_bp->read_pointer += cnt;\r\nubp += cnt;\r\noffset = 0;\r\n}\r\nif (do_count)\r\nreturn (-EIO);\r\nreturn 0;\r\n}\r\nstatic void move_buffer_data(struct st_buffer * st_bp, int offset)\r\n{\r\nint src_seg, dst_seg, src_offset = 0, dst_offset;\r\nint count, total;\r\nint length = PAGE_SIZE << st_bp->reserved_page_order;\r\nif (offset == 0)\r\nreturn;\r\ntotal=st_bp->buffer_bytes - offset;\r\nfor (src_seg=0; src_seg < st_bp->frp_segs; src_seg++) {\r\nsrc_offset = offset;\r\nif (src_offset < length)\r\nbreak;\r\noffset -= length;\r\n}\r\nst_bp->buffer_bytes = st_bp->read_pointer = total;\r\nfor (dst_seg=dst_offset=0; total > 0; ) {\r\nstruct page *dpage = st_bp->reserved_pages[dst_seg];\r\nstruct page *spage = st_bp->reserved_pages[src_seg];\r\ncount = min(length - dst_offset, length - src_offset);\r\nmemmove(page_address(dpage) + dst_offset,\r\npage_address(spage) + src_offset, count);\r\nsrc_offset += count;\r\nif (src_offset >= length) {\r\nsrc_seg++;\r\nsrc_offset = 0;\r\n}\r\ndst_offset += count;\r\nif (dst_offset >= length) {\r\ndst_seg++;\r\ndst_offset = 0;\r\n}\r\ntotal -= count;\r\n}\r\n}\r\nstatic void validate_options(void)\r\n{\r\nif (buffer_kbs > 0)\r\nst_fixed_buffer_size = buffer_kbs * ST_KILOBYTE;\r\nif (max_sg_segs >= ST_FIRST_SG)\r\nst_max_sg_segs = max_sg_segs;\r\n}\r\nstatic int __init st_setup(char *str)\r\n{\r\nint i, len, ints[5];\r\nchar *stp;\r\nstp = get_options(str, ARRAY_SIZE(ints), ints);\r\nif (ints[0] > 0) {\r\nfor (i = 0; i < ints[0] && i < ARRAY_SIZE(parms); i++)\r\nif (parms[i].val)\r\n*parms[i].val = ints[i + 1];\r\n} else {\r\nwhile (stp != NULL) {\r\nfor (i = 0; i < ARRAY_SIZE(parms); i++) {\r\nlen = strlen(parms[i].name);\r\nif (!strncmp(stp, parms[i].name, len) &&\r\n(*(stp + len) == ':' || *(stp + len) == '=')) {\r\nif (parms[i].val)\r\n*parms[i].val =\r\nsimple_strtoul(stp + len + 1, NULL, 0);\r\nelse\r\nprintk(KERN_WARNING "st: Obsolete parameter %s\n",\r\nparms[i].name);\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(parms))\r\nprintk(KERN_WARNING "st: invalid parameter in '%s'\n",\r\nstp);\r\nstp = strchr(stp, ',');\r\nif (stp)\r\nstp++;\r\n}\r\n}\r\nvalidate_options();\r\nreturn 1;\r\n}\r\nstatic int st_probe(struct device *dev)\r\n{\r\nstruct scsi_device *SDp = to_scsi_device(dev);\r\nstruct gendisk *disk = NULL;\r\nstruct cdev *cdev = NULL;\r\nstruct scsi_tape *tpnt = NULL;\r\nstruct st_modedef *STm;\r\nstruct st_partstat *STps;\r\nstruct st_buffer *buffer;\r\nint i, j, mode, dev_num, error;\r\nchar *stp;\r\nif (SDp->type != TYPE_TAPE)\r\nreturn -ENODEV;\r\nif ((stp = st_incompatible(SDp))) {\r\nsdev_printk(KERN_INFO, SDp, "Found incompatible tape\n");\r\nprintk(KERN_INFO "st: The suggested driver is %s.\n", stp);\r\nreturn -ENODEV;\r\n}\r\ni = queue_max_segments(SDp->request_queue);\r\nif (st_max_sg_segs < i)\r\ni = st_max_sg_segs;\r\nbuffer = new_tape_buffer((SDp->host)->unchecked_isa_dma, i);\r\nif (buffer == NULL) {\r\nprintk(KERN_ERR\r\n"st: Can't allocate new tape buffer. Device not attached.\n");\r\ngoto out;\r\n}\r\ndisk = alloc_disk(1);\r\nif (!disk) {\r\nprintk(KERN_ERR "st: out of memory. Device not attached.\n");\r\ngoto out_buffer_free;\r\n}\r\nwrite_lock(&st_dev_arr_lock);\r\nif (st_nr_dev >= st_dev_max) {\r\nstruct scsi_tape **tmp_da;\r\nint tmp_dev_max;\r\ntmp_dev_max = max(st_nr_dev * 2, 8);\r\nif (tmp_dev_max > ST_MAX_TAPES)\r\ntmp_dev_max = ST_MAX_TAPES;\r\nif (tmp_dev_max <= st_nr_dev) {\r\nwrite_unlock(&st_dev_arr_lock);\r\nprintk(KERN_ERR "st: Too many tape devices (max. %d).\n",\r\nST_MAX_TAPES);\r\ngoto out_put_disk;\r\n}\r\ntmp_da = kzalloc(tmp_dev_max * sizeof(struct scsi_tape *), GFP_ATOMIC);\r\nif (tmp_da == NULL) {\r\nwrite_unlock(&st_dev_arr_lock);\r\nprintk(KERN_ERR "st: Can't extend device array.\n");\r\ngoto out_put_disk;\r\n}\r\nif (scsi_tapes != NULL) {\r\nmemcpy(tmp_da, scsi_tapes,\r\nst_dev_max * sizeof(struct scsi_tape *));\r\nkfree(scsi_tapes);\r\n}\r\nscsi_tapes = tmp_da;\r\nst_dev_max = tmp_dev_max;\r\n}\r\nfor (i = 0; i < st_dev_max; i++)\r\nif (scsi_tapes[i] == NULL)\r\nbreak;\r\nif (i >= st_dev_max)\r\npanic("scsi_devices corrupt (st)");\r\ntpnt = kzalloc(sizeof(struct scsi_tape), GFP_ATOMIC);\r\nif (tpnt == NULL) {\r\nwrite_unlock(&st_dev_arr_lock);\r\nprintk(KERN_ERR "st: Can't allocate device descriptor.\n");\r\ngoto out_put_disk;\r\n}\r\nkref_init(&tpnt->kref);\r\ntpnt->disk = disk;\r\nsprintf(disk->disk_name, "st%d", i);\r\ndisk->private_data = &tpnt->driver;\r\ndisk->queue = SDp->request_queue;\r\ntpnt->driver = &st_template;\r\nscsi_tapes[i] = tpnt;\r\ndev_num = i;\r\ntpnt->device = SDp;\r\nif (SDp->scsi_level <= 2)\r\ntpnt->tape_type = MT_ISSCSI1;\r\nelse\r\ntpnt->tape_type = MT_ISSCSI2;\r\ntpnt->buffer = buffer;\r\ntpnt->buffer->last_SRpnt = NULL;\r\ntpnt->inited = 0;\r\ntpnt->dirty = 0;\r\ntpnt->in_use = 0;\r\ntpnt->drv_buffer = 1;\r\ntpnt->restr_dma = (SDp->host)->unchecked_isa_dma;\r\ntpnt->use_pf = (SDp->scsi_level >= SCSI_2);\r\ntpnt->density = 0;\r\ntpnt->do_auto_lock = ST_AUTO_LOCK;\r\ntpnt->can_bsr = (SDp->scsi_level > 2 ? 1 : ST_IN_FILE_POS);\r\ntpnt->can_partitions = 0;\r\ntpnt->two_fm = ST_TWO_FM;\r\ntpnt->fast_mteom = ST_FAST_MTEOM;\r\ntpnt->scsi2_logical = ST_SCSI2LOGICAL;\r\ntpnt->sili = ST_SILI;\r\ntpnt->immediate = ST_NOWAIT;\r\ntpnt->immediate_filemark = 0;\r\ntpnt->default_drvbuffer = 0xff;\r\ntpnt->partition = 0;\r\ntpnt->new_partition = 0;\r\ntpnt->nbr_partitions = 0;\r\nblk_queue_rq_timeout(tpnt->device->request_queue, ST_TIMEOUT);\r\ntpnt->long_timeout = ST_LONG_TIMEOUT;\r\ntpnt->try_dio = try_direct_io && !SDp->host->unchecked_isa_dma;\r\nfor (i = 0; i < ST_NBR_MODES; i++) {\r\nSTm = &(tpnt->modes[i]);\r\nSTm->defined = 0;\r\nSTm->sysv = ST_SYSV;\r\nSTm->defaults_for_writes = 0;\r\nSTm->do_async_writes = ST_ASYNC_WRITES;\r\nSTm->do_buffer_writes = ST_BUFFER_WRITES;\r\nSTm->do_read_ahead = ST_READ_AHEAD;\r\nSTm->default_compression = ST_DONT_TOUCH;\r\nSTm->default_blksize = (-1);\r\nSTm->default_density = (-1);\r\n}\r\nfor (i = 0; i < ST_NBR_PARTITIONS; i++) {\r\nSTps = &(tpnt->ps[i]);\r\nSTps->rw = ST_IDLE;\r\nSTps->eof = ST_NOEOF;\r\nSTps->at_sm = 0;\r\nSTps->last_block_valid = 0;\r\nSTps->drv_block = (-1);\r\nSTps->drv_file = (-1);\r\n}\r\ntpnt->current_mode = 0;\r\ntpnt->modes[0].defined = 1;\r\ntpnt->density_changed = tpnt->compression_changed =\r\ntpnt->blksize_changed = 0;\r\nmutex_init(&tpnt->lock);\r\nst_nr_dev++;\r\nwrite_unlock(&st_dev_arr_lock);\r\nfor (mode = 0; mode < ST_NBR_MODES; ++mode) {\r\nSTm = &(tpnt->modes[mode]);\r\nfor (j=0; j < 2; j++) {\r\ncdev = cdev_alloc();\r\nif (!cdev) {\r\nprintk(KERN_ERR\r\n"st%d: out of memory. Device not attached.\n",\r\ndev_num);\r\ngoto out_free_tape;\r\n}\r\ncdev->owner = THIS_MODULE;\r\ncdev->ops = &st_fops;\r\nerror = cdev_add(cdev,\r\nMKDEV(SCSI_TAPE_MAJOR, TAPE_MINOR(dev_num, mode, j)),\r\n1);\r\nif (error) {\r\nprintk(KERN_ERR "st%d: Can't add %s-rewind mode %d\n",\r\ndev_num, j ? "non" : "auto", mode);\r\nprintk(KERN_ERR "st%d: Device not attached.\n", dev_num);\r\ngoto out_free_tape;\r\n}\r\nSTm->cdevs[j] = cdev;\r\n}\r\nerror = do_create_class_files(tpnt, dev_num, mode);\r\nif (error)\r\ngoto out_free_tape;\r\n}\r\nscsi_autopm_put_device(SDp);\r\nsdev_printk(KERN_NOTICE, SDp,\r\n"Attached scsi tape %s\n", tape_name(tpnt));\r\nsdev_printk(KERN_INFO, SDp, "%s: try direct i/o: %s (alignment %d B)\n",\r\ntape_name(tpnt), tpnt->try_dio ? "yes" : "no",\r\nqueue_dma_alignment(SDp->request_queue) + 1);\r\nreturn 0;\r\nout_free_tape:\r\nfor (mode=0; mode < ST_NBR_MODES; mode++) {\r\nSTm = &(tpnt->modes[mode]);\r\nsysfs_remove_link(&tpnt->device->sdev_gendev.kobj,\r\n"tape");\r\nfor (j=0; j < 2; j++) {\r\nif (STm->cdevs[j]) {\r\nif (cdev == STm->cdevs[j])\r\ncdev = NULL;\r\ndevice_destroy(st_sysfs_class,\r\nMKDEV(SCSI_TAPE_MAJOR,\r\nTAPE_MINOR(i, mode, j)));\r\ncdev_del(STm->cdevs[j]);\r\n}\r\n}\r\n}\r\nif (cdev)\r\ncdev_del(cdev);\r\nwrite_lock(&st_dev_arr_lock);\r\nscsi_tapes[dev_num] = NULL;\r\nst_nr_dev--;\r\nwrite_unlock(&st_dev_arr_lock);\r\nout_put_disk:\r\nput_disk(disk);\r\nkfree(tpnt);\r\nout_buffer_free:\r\nkfree(buffer);\r\nout:\r\nreturn -ENODEV;\r\n}\r\nstatic int st_remove(struct device *dev)\r\n{\r\nstruct scsi_device *SDp = to_scsi_device(dev);\r\nstruct scsi_tape *tpnt;\r\nint i, j, mode;\r\nscsi_autopm_get_device(SDp);\r\nwrite_lock(&st_dev_arr_lock);\r\nfor (i = 0; i < st_dev_max; i++) {\r\ntpnt = scsi_tapes[i];\r\nif (tpnt != NULL && tpnt->device == SDp) {\r\nscsi_tapes[i] = NULL;\r\nst_nr_dev--;\r\nwrite_unlock(&st_dev_arr_lock);\r\nsysfs_remove_link(&tpnt->device->sdev_gendev.kobj,\r\n"tape");\r\nfor (mode = 0; mode < ST_NBR_MODES; ++mode) {\r\nfor (j=0; j < 2; j++) {\r\ndevice_destroy(st_sysfs_class,\r\nMKDEV(SCSI_TAPE_MAJOR,\r\nTAPE_MINOR(i, mode, j)));\r\ncdev_del(tpnt->modes[mode].cdevs[j]);\r\ntpnt->modes[mode].cdevs[j] = NULL;\r\n}\r\n}\r\nmutex_lock(&st_ref_mutex);\r\nkref_put(&tpnt->kref, scsi_tape_release);\r\nmutex_unlock(&st_ref_mutex);\r\nreturn 0;\r\n}\r\n}\r\nwrite_unlock(&st_dev_arr_lock);\r\nreturn 0;\r\n}\r\nstatic void scsi_tape_release(struct kref *kref)\r\n{\r\nstruct scsi_tape *tpnt = to_scsi_tape(kref);\r\nstruct gendisk *disk = tpnt->disk;\r\ntpnt->device = NULL;\r\nif (tpnt->buffer) {\r\nnormalize_buffer(tpnt->buffer);\r\nkfree(tpnt->buffer->reserved_pages);\r\nkfree(tpnt->buffer);\r\n}\r\ndisk->private_data = NULL;\r\nput_disk(disk);\r\nkfree(tpnt);\r\nreturn;\r\n}\r\nstatic int __init init_st(void)\r\n{\r\nint err;\r\nvalidate_options();\r\nprintk(KERN_INFO "st: Version %s, fixed bufsize %d, s/g segs %d\n",\r\nverstr, st_fixed_buffer_size, st_max_sg_segs);\r\nst_sysfs_class = class_create(THIS_MODULE, "scsi_tape");\r\nif (IS_ERR(st_sysfs_class)) {\r\nprintk(KERN_ERR "Unable create sysfs class for SCSI tapes\n");\r\nreturn PTR_ERR(st_sysfs_class);\r\n}\r\nerr = register_chrdev_region(MKDEV(SCSI_TAPE_MAJOR, 0),\r\nST_MAX_TAPE_ENTRIES, "st");\r\nif (err) {\r\nprintk(KERN_ERR "Unable to get major %d for SCSI tapes\n",\r\nSCSI_TAPE_MAJOR);\r\ngoto err_class;\r\n}\r\nerr = scsi_register_driver(&st_template.gendrv);\r\nif (err)\r\ngoto err_chrdev;\r\nerr = do_create_sysfs_files();\r\nif (err)\r\ngoto err_scsidrv;\r\nreturn 0;\r\nerr_scsidrv:\r\nscsi_unregister_driver(&st_template.gendrv);\r\nerr_chrdev:\r\nunregister_chrdev_region(MKDEV(SCSI_TAPE_MAJOR, 0),\r\nST_MAX_TAPE_ENTRIES);\r\nerr_class:\r\nclass_destroy(st_sysfs_class);\r\nreturn err;\r\n}\r\nstatic void __exit exit_st(void)\r\n{\r\ndo_remove_sysfs_files();\r\nscsi_unregister_driver(&st_template.gendrv);\r\nunregister_chrdev_region(MKDEV(SCSI_TAPE_MAJOR, 0),\r\nST_MAX_TAPE_ENTRIES);\r\nclass_destroy(st_sysfs_class);\r\nkfree(scsi_tapes);\r\nprintk(KERN_INFO "st: Unloaded.\n");\r\n}\r\nstatic ssize_t st_try_direct_io_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", try_direct_io);\r\n}\r\nstatic ssize_t st_fixed_buffer_size_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", st_fixed_buffer_size);\r\n}\r\nstatic ssize_t st_max_sg_segs_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", st_max_sg_segs);\r\n}\r\nstatic ssize_t st_version_show(struct device_driver *ddd, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "[%s]\n", verstr);\r\n}\r\nstatic int do_create_sysfs_files(void)\r\n{\r\nstruct device_driver *sysfs = &st_template.gendrv;\r\nint err;\r\nerr = driver_create_file(sysfs, &driver_attr_try_direct_io);\r\nif (err)\r\nreturn err;\r\nerr = driver_create_file(sysfs, &driver_attr_fixed_buffer_size);\r\nif (err)\r\ngoto err_try_direct_io;\r\nerr = driver_create_file(sysfs, &driver_attr_max_sg_segs);\r\nif (err)\r\ngoto err_attr_fixed_buf;\r\nerr = driver_create_file(sysfs, &driver_attr_version);\r\nif (err)\r\ngoto err_attr_max_sg;\r\nreturn 0;\r\nerr_attr_max_sg:\r\ndriver_remove_file(sysfs, &driver_attr_max_sg_segs);\r\nerr_attr_fixed_buf:\r\ndriver_remove_file(sysfs, &driver_attr_fixed_buffer_size);\r\nerr_try_direct_io:\r\ndriver_remove_file(sysfs, &driver_attr_try_direct_io);\r\nreturn err;\r\n}\r\nstatic void do_remove_sysfs_files(void)\r\n{\r\nstruct device_driver *sysfs = &st_template.gendrv;\r\ndriver_remove_file(sysfs, &driver_attr_version);\r\ndriver_remove_file(sysfs, &driver_attr_max_sg_segs);\r\ndriver_remove_file(sysfs, &driver_attr_fixed_buffer_size);\r\ndriver_remove_file(sysfs, &driver_attr_try_direct_io);\r\n}\r\nstatic ssize_t\r\nst_defined_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct st_modedef *STm = dev_get_drvdata(dev);\r\nssize_t l = 0;\r\nl = snprintf(buf, PAGE_SIZE, "%d\n", STm->defined);\r\nreturn l;\r\n}\r\nstatic ssize_t\r\nst_defblk_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct st_modedef *STm = dev_get_drvdata(dev);\r\nssize_t l = 0;\r\nl = snprintf(buf, PAGE_SIZE, "%d\n", STm->default_blksize);\r\nreturn l;\r\n}\r\nstatic ssize_t\r\nst_defdensity_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct st_modedef *STm = dev_get_drvdata(dev);\r\nssize_t l = 0;\r\nchar *fmt;\r\nfmt = STm->default_density >= 0 ? "0x%02x\n" : "%d\n";\r\nl = snprintf(buf, PAGE_SIZE, fmt, STm->default_density);\r\nreturn l;\r\n}\r\nstatic ssize_t\r\nst_defcompression_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct st_modedef *STm = dev_get_drvdata(dev);\r\nssize_t l = 0;\r\nl = snprintf(buf, PAGE_SIZE, "%d\n", STm->default_compression - 1);\r\nreturn l;\r\n}\r\nstatic ssize_t\r\nst_options_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct st_modedef *STm = dev_get_drvdata(dev);\r\nstruct scsi_tape *STp;\r\nint i, j, options;\r\nssize_t l = 0;\r\nfor (i=0; i < st_dev_max; i++) {\r\nfor (j=0; j < ST_NBR_MODES; j++)\r\nif (&scsi_tapes[i]->modes[j] == STm)\r\nbreak;\r\nif (j < ST_NBR_MODES)\r\nbreak;\r\n}\r\nif (i == st_dev_max)\r\nreturn 0;\r\nSTp = scsi_tapes[i];\r\noptions = STm->do_buffer_writes ? MT_ST_BUFFER_WRITES : 0;\r\noptions |= STm->do_async_writes ? MT_ST_ASYNC_WRITES : 0;\r\noptions |= STm->do_read_ahead ? MT_ST_READ_AHEAD : 0;\r\nDEB( options |= debugging ? MT_ST_DEBUGGING : 0 );\r\noptions |= STp->two_fm ? MT_ST_TWO_FM : 0;\r\noptions |= STp->fast_mteom ? MT_ST_FAST_MTEOM : 0;\r\noptions |= STm->defaults_for_writes ? MT_ST_DEF_WRITES : 0;\r\noptions |= STp->can_bsr ? MT_ST_CAN_BSR : 0;\r\noptions |= STp->omit_blklims ? MT_ST_NO_BLKLIMS : 0;\r\noptions |= STp->can_partitions ? MT_ST_CAN_PARTITIONS : 0;\r\noptions |= STp->scsi2_logical ? MT_ST_SCSI2LOGICAL : 0;\r\noptions |= STm->sysv ? MT_ST_SYSV : 0;\r\noptions |= STp->immediate ? MT_ST_NOWAIT : 0;\r\noptions |= STp->immediate_filemark ? MT_ST_NOWAIT_EOF : 0;\r\noptions |= STp->sili ? MT_ST_SILI : 0;\r\nl = snprintf(buf, PAGE_SIZE, "0x%08x\n", options);\r\nreturn l;\r\n}\r\nstatic int do_create_class_files(struct scsi_tape *STp, int dev_num, int mode)\r\n{\r\nint i, rew, error;\r\nchar name[10];\r\nstruct device *st_class_member;\r\nfor (rew=0; rew < 2; rew++) {\r\ni = mode << (4 - ST_NBR_MODE_BITS);\r\nsnprintf(name, 10, "%s%s%s", rew ? "n" : "",\r\nSTp->disk->disk_name, st_formats[i]);\r\nst_class_member =\r\ndevice_create(st_sysfs_class, &STp->device->sdev_gendev,\r\nMKDEV(SCSI_TAPE_MAJOR,\r\nTAPE_MINOR(dev_num, mode, rew)),\r\n&STp->modes[mode], "%s", name);\r\nif (IS_ERR(st_class_member)) {\r\nprintk(KERN_WARNING "st%d: device_create failed\n",\r\ndev_num);\r\nerror = PTR_ERR(st_class_member);\r\ngoto out;\r\n}\r\nerror = device_create_file(st_class_member,\r\n&dev_attr_defined);\r\nif (error) goto out;\r\nerror = device_create_file(st_class_member,\r\n&dev_attr_default_blksize);\r\nif (error) goto out;\r\nerror = device_create_file(st_class_member,\r\n&dev_attr_default_density);\r\nif (error) goto out;\r\nerror = device_create_file(st_class_member,\r\n&dev_attr_default_compression);\r\nif (error) goto out;\r\nerror = device_create_file(st_class_member,\r\n&dev_attr_options);\r\nif (error) goto out;\r\nif (mode == 0 && rew == 0) {\r\nerror = sysfs_create_link(&STp->device->sdev_gendev.kobj,\r\n&st_class_member->kobj,\r\n"tape");\r\nif (error) {\r\nprintk(KERN_ERR\r\n"st%d: Can't create sysfs link from SCSI device.\n",\r\ndev_num);\r\ngoto out;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nout:\r\nreturn error;\r\n}\r\nstatic int sgl_map_user_pages(struct st_buffer *STbp,\r\nconst unsigned int max_pages, unsigned long uaddr,\r\nsize_t count, int rw)\r\n{\r\nunsigned long end = (uaddr + count + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nunsigned long start = uaddr >> PAGE_SHIFT;\r\nconst int nr_pages = end - start;\r\nint res, i, j;\r\nstruct page **pages;\r\nstruct rq_map_data *mdata = &STbp->map_data;\r\nif ((uaddr + count) < uaddr)\r\nreturn -EINVAL;\r\nif (nr_pages > max_pages)\r\nreturn -ENOMEM;\r\nif (count == 0)\r\nreturn 0;\r\nif ((pages = kmalloc(max_pages * sizeof(*pages), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ndown_read(&current->mm->mmap_sem);\r\nres = get_user_pages(\r\ncurrent,\r\ncurrent->mm,\r\nuaddr,\r\nnr_pages,\r\nrw == READ,\r\n0,\r\npages,\r\nNULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (res < nr_pages)\r\ngoto out_unmap;\r\nfor (i=0; i < nr_pages; i++) {\r\nflush_dcache_page(pages[i]);\r\n}\r\nmdata->offset = uaddr & ~PAGE_MASK;\r\nSTbp->mapped_pages = pages;\r\nreturn nr_pages;\r\nout_unmap:\r\nif (res > 0) {\r\nfor (j=0; j < res; j++)\r\npage_cache_release(pages[j]);\r\nres = 0;\r\n}\r\nkfree(pages);\r\nreturn res;\r\n}\r\nstatic int sgl_unmap_user_pages(struct st_buffer *STbp,\r\nconst unsigned int nr_pages, int dirtied)\r\n{\r\nint i;\r\nfor (i=0; i < nr_pages; i++) {\r\nstruct page *page = STbp->mapped_pages[i];\r\nif (dirtied)\r\nSetPageDirty(page);\r\npage_cache_release(page);\r\n}\r\nkfree(STbp->mapped_pages);\r\nSTbp->mapped_pages = NULL;\r\nreturn 0;\r\n}
