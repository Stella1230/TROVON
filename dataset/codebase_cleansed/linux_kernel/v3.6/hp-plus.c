static int __init do_hpp_probe(struct net_device *dev)\r\n{\r\nint i;\r\nint base_addr = dev->base_addr;\r\nint irq = dev->irq;\r\nif (base_addr > 0x1ff)\r\nreturn hpp_probe1(dev, base_addr);\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\nfor (i = 0; hpplus_portlist[i]; i++) {\r\nif (hpp_probe1(dev, hpplus_portlist[i]) == 0)\r\nreturn 0;\r\ndev->irq = irq;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init hp_plus_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_eip_netdev();\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_hpp_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init hpp_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i, retval;\r\nunsigned char checksum = 0;\r\nconst char name[] = "HP-PC-LAN+";\r\nint mem_start;\r\nstatic unsigned version_printed;\r\nif (!request_region(ioaddr, HP_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\nif (inw(ioaddr + HP_ID) != 0x4850 ||\r\n(inw(ioaddr + HP_PAGING) & 0xfff0) != 0x5300) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (ei_debug && version_printed++ == 0)\r\nprintk(version);\r\nprintk("%s: %s at %#3x, ", dev->name, name, ioaddr);\r\noutw(MAC_Page, ioaddr + HP_PAGING);\r\nfor(i = 0; i < ETH_ALEN; i++) {\r\nunsigned char inval = inb(ioaddr + 8 + i);\r\ndev->dev_addr[i] = inval;\r\nchecksum += inval;\r\n}\r\nchecksum += inb(ioaddr + 14);\r\nprintk("%pM", dev->dev_addr);\r\nif (checksum != 0xff) {\r\nprintk(" bad checksum %2.2x.\n", checksum);\r\nretval = -ENODEV;\r\ngoto out;\r\n} else {\r\noutw(ID_Page, ioaddr + HP_PAGING);\r\nprintk(" ID %4.4x", inw(ioaddr + 12));\r\n}\r\noutw(HW_Page, ioaddr + HP_PAGING);\r\n{\r\nint irq = inb(ioaddr + 13) & 0x0f;\r\nint option = inw(ioaddr + HPP_OPTION);\r\ndev->irq = irq;\r\nif (option & MemEnable) {\r\nmem_start = inw(ioaddr + 9) << 8;\r\nprintk(", IRQ %d, memory address %#x.\n", irq, mem_start);\r\n} else {\r\nmem_start = 0;\r\nprintk(", IRQ %d, programmed-I/O mode.\n", irq);\r\n}\r\n}\r\noutw((HP_START_PG + TX_PAGES/2) | ((HP_STOP_PG - 1) << 8), ioaddr + 14);\r\ndev->base_addr = ioaddr + NIC_OFFSET;\r\ndev->netdev_ops = &hpp_netdev_ops;\r\nei_status.name = name;\r\nei_status.word16 = 0;\r\nei_status.tx_start_page = HP_START_PG;\r\nei_status.rx_start_page = HP_START_PG + TX_PAGES/2;\r\nei_status.stop_page = HP_STOP_PG;\r\nei_status.reset_8390 = &hpp_reset_8390;\r\nei_status.block_input = &hpp_io_block_input;\r\nei_status.block_output = &hpp_io_block_output;\r\nei_status.get_8390_hdr = &hpp_io_get_8390_hdr;\r\nif (mem_start) {\r\nei_status.block_input = &hpp_mem_block_input;\r\nei_status.block_output = &hpp_mem_block_output;\r\nei_status.get_8390_hdr = &hpp_mem_get_8390_hdr;\r\ndev->mem_start = mem_start;\r\nei_status.mem = ioremap(mem_start,\r\n(HP_STOP_PG - HP_START_PG)*256);\r\nif (!ei_status.mem) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nei_status.rmem_start = dev->mem_start + TX_PAGES/2*256;\r\ndev->mem_end = ei_status.rmem_end\r\n= dev->mem_start + (HP_STOP_PG - HP_START_PG)*256;\r\n}\r\noutw(Perf_Page, ioaddr + HP_PAGING);\r\nNS8390p_init(dev, 0);\r\noutw(inw(ioaddr + HPP_OPTION) & ~EnableIRQ, ioaddr + HPP_OPTION);\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out1;\r\nreturn 0;\r\nout1:\r\niounmap(ei_status.mem);\r\nout:\r\nrelease_region(ioaddr, HP_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic int\r\nhpp_open(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\nint option_reg;\r\nint retval;\r\nif ((retval = request_irq(dev->irq, eip_interrupt, 0, dev->name, dev))) {\r\nreturn retval;\r\n}\r\noption_reg = inw(ioaddr + HPP_OPTION);\r\noutw(option_reg & ~(NICReset + ChipReset), ioaddr + HPP_OPTION);\r\nudelay(5);\r\noutw(option_reg | (EnableIRQ + NICReset + ChipReset), ioaddr + HPP_OPTION);\r\noutw(HW_Page, ioaddr + HP_PAGING);\r\noutw((HP_START_PG + TX_PAGES/2) | ((HP_STOP_PG - 1) << 8), ioaddr + 14);\r\noutw(Perf_Page, ioaddr + HP_PAGING);\r\nreturn eip_open(dev);\r\n}\r\nstatic int\r\nhpp_close(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\nint option_reg = inw(ioaddr + HPP_OPTION);\r\nfree_irq(dev->irq, dev);\r\neip_close(dev);\r\noutw((option_reg & ~EnableIRQ) | MemDisable | NICReset | ChipReset,\r\nioaddr + HPP_OPTION);\r\nreturn 0;\r\n}\r\nstatic void\r\nhpp_reset_8390(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\nint option_reg = inw(ioaddr + HPP_OPTION);\r\nif (ei_debug > 1) printk("resetting the 8390 time=%ld...", jiffies);\r\noutw(option_reg & ~(NICReset + ChipReset), ioaddr + HPP_OPTION);\r\nudelay(5);\r\nei_status.txing = 0;\r\noutw(option_reg | (EnableIRQ + NICReset + ChipReset), ioaddr + HPP_OPTION);\r\nudelay(5);\r\nif ((inb_p(ioaddr+NIC_OFFSET+EN0_ISR) & ENISR_RESET) == 0)\r\nprintk("%s: hp_reset_8390() did not complete.\n", dev->name);\r\nif (ei_debug > 1) printk("8390 reset done (%ld).", jiffies);\r\n}\r\nstatic void\r\nhpp_io_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\noutw((ring_page<<8), ioaddr + HPP_IN_ADDR);\r\ninsw(ioaddr + HP_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);\r\n}\r\nstatic void\r\nhpp_io_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\nchar *buf = skb->data;\r\noutw(ring_offset, ioaddr + HPP_IN_ADDR);\r\ninsw(ioaddr + HP_DATAPORT, buf, count>>1);\r\nif (count & 0x01)\r\nbuf[count-1] = inw(ioaddr + HP_DATAPORT);\r\n}\r\nstatic void\r\nhpp_mem_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\nint option_reg = inw(ioaddr + HPP_OPTION);\r\noutw((ring_page<<8), ioaddr + HPP_IN_ADDR);\r\noutw(option_reg & ~(MemDisable + BootROMEnb), ioaddr + HPP_OPTION);\r\nmemcpy_fromio(hdr, ei_status.mem, sizeof(struct e8390_pkt_hdr));\r\noutw(option_reg, ioaddr + HPP_OPTION);\r\nhdr->count = (le16_to_cpu(hdr->count) + 3) & ~3;\r\n}\r\nstatic void\r\nhpp_mem_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\nint option_reg = inw(ioaddr + HPP_OPTION);\r\noutw(ring_offset, ioaddr + HPP_IN_ADDR);\r\noutw(option_reg & ~(MemDisable + BootROMEnb), ioaddr + HPP_OPTION);\r\nmemcpy_fromio(skb->data, ei_status.mem, count);\r\noutw(option_reg, ioaddr + HPP_OPTION);\r\n}\r\nstatic void\r\nhpp_io_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\noutw(start_page << 8, ioaddr + HPP_OUT_ADDR);\r\noutsl(ioaddr + HP_DATAPORT, buf, (count+3)>>2);\r\n}\r\nstatic void\r\nhpp_mem_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nint ioaddr = dev->base_addr - NIC_OFFSET;\r\nint option_reg = inw(ioaddr + HPP_OPTION);\r\noutw(start_page << 8, ioaddr + HPP_OUT_ADDR);\r\noutw(option_reg & ~(MemDisable + BootROMEnb), ioaddr + HPP_OPTION);\r\nmemcpy_toio(ei_status.mem, buf, (count + 3) & ~3);\r\noutw(option_reg, ioaddr + HPP_OPTION);\r\n}\r\nint __init\r\ninit_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_HPP_CARDS; this_dev++) {\r\nif (io[this_dev] == 0) {\r\nif (this_dev != 0) break;\r\nprintk(KERN_NOTICE "hp-plus.c: Presently autoprobing (not recommended) for a single card.\n");\r\n}\r\ndev = alloc_eip_netdev();\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\nif (do_hpp_probe(dev) == 0) {\r\ndev_hpp[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nprintk(KERN_WARNING "hp-plus.c: No HP-Plus card found (i/o = 0x%x).\n", io[this_dev]);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\niounmap(ei_status.mem);\r\nrelease_region(dev->base_addr - NIC_OFFSET, HP_IO_EXTENT);\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_HPP_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_hpp[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
