static void qla4xxx_copy_sense(struct scsi_qla_host *ha,\r\nstruct status_entry *sts_entry,\r\nstruct srb *srb)\r\n{\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nuint16_t sense_len;\r\nmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nsense_len = le16_to_cpu(sts_entry->senseDataByteCnt);\r\nif (sense_len == 0) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "scsi%ld:%d:%d:%d: %s:"\r\n" sense len 0\n", ha->host_no,\r\ncmd->device->channel, cmd->device->id,\r\ncmd->device->lun, __func__));\r\nha->status_srb = NULL;\r\nreturn;\r\n}\r\nsense_len = min_t(uint16_t, sense_len, SCSI_SENSE_BUFFERSIZE);\r\nsrb->req_sense_ptr = cmd->sense_buffer;\r\nsrb->req_sense_len = sense_len;\r\nsense_len = min_t(uint16_t, sense_len, IOCB_MAX_SENSEDATA_LEN);\r\nmemcpy(cmd->sense_buffer, sts_entry->senseData, sense_len);\r\nDEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: %s: sense key = %x, "\r\n"ASL= %02x, ASC/ASCQ = %02x/%02x\n", ha->host_no,\r\ncmd->device->channel, cmd->device->id,\r\ncmd->device->lun, __func__,\r\nsts_entry->senseData[2] & 0x0f,\r\nsts_entry->senseData[7],\r\nsts_entry->senseData[12],\r\nsts_entry->senseData[13]));\r\nDEBUG5(qla4xxx_dump_buffer(cmd->sense_buffer, sense_len));\r\nsrb->flags |= SRB_GOT_SENSE;\r\nsrb->req_sense_ptr += sense_len;\r\nsrb->req_sense_len -= sense_len;\r\nif (srb->req_sense_len != 0)\r\nha->status_srb = srb;\r\nelse\r\nha->status_srb = NULL;\r\n}\r\nstatic void\r\nqla4xxx_status_cont_entry(struct scsi_qla_host *ha,\r\nstruct status_cont_entry *sts_cont)\r\n{\r\nstruct srb *srb = ha->status_srb;\r\nstruct scsi_cmnd *cmd;\r\nuint16_t sense_len;\r\nif (srb == NULL)\r\nreturn;\r\ncmd = srb->cmd;\r\nif (cmd == NULL) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: %s: Cmd already returned "\r\n"back to OS srb=%p srb->state:%d\n", ha->host_no,\r\n__func__, srb, srb->state));\r\nha->status_srb = NULL;\r\nreturn;\r\n}\r\nsense_len = min_t(uint16_t, srb->req_sense_len,\r\nIOCB_MAX_EXT_SENSEDATA_LEN);\r\nmemcpy(srb->req_sense_ptr, sts_cont->ext_sense_data, sense_len);\r\nDEBUG5(qla4xxx_dump_buffer(srb->req_sense_ptr, sense_len));\r\nsrb->req_sense_ptr += sense_len;\r\nsrb->req_sense_len -= sense_len;\r\nif (srb->req_sense_len == 0) {\r\nkref_put(&srb->srb_ref, qla4xxx_srb_compl);\r\nha->status_srb = NULL;\r\n}\r\n}\r\nstatic void qla4xxx_status_entry(struct scsi_qla_host *ha,\r\nstruct status_entry *sts_entry)\r\n{\r\nuint8_t scsi_status;\r\nstruct scsi_cmnd *cmd;\r\nstruct srb *srb;\r\nstruct ddb_entry *ddb_entry;\r\nuint32_t residual;\r\nsrb = qla4xxx_del_from_active_array(ha, le32_to_cpu(sts_entry->handle));\r\nif (!srb) {\r\nql4_printk(KERN_WARNING, ha, "%s invalid status entry: "\r\n"handle=0x%0x, srb=%p\n", __func__,\r\nsts_entry->handle, srb);\r\nif (is_qla8022(ha))\r\nset_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\r\nelse\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nreturn;\r\n}\r\ncmd = srb->cmd;\r\nif (cmd == NULL) {\r\nDEBUG2(printk("scsi%ld: %s: Command already returned back to "\r\n"OS pkt->handle=%d srb=%p srb->state:%d\n",\r\nha->host_no, __func__, sts_entry->handle,\r\nsrb, srb->state));\r\nql4_printk(KERN_WARNING, ha, "Command is NULL:"\r\n" already returned to OS (srb=%p)\n", srb);\r\nreturn;\r\n}\r\nddb_entry = srb->ddb;\r\nif (ddb_entry == NULL) {\r\ncmd->result = DID_NO_CONNECT << 16;\r\ngoto status_entry_exit;\r\n}\r\nresidual = le32_to_cpu(sts_entry->residualByteCnt);\r\nscsi_status = sts_entry->scsiStatus;\r\nswitch (sts_entry->completionStatus) {\r\ncase SCS_COMPLETE:\r\nif (sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_OVER) {\r\ncmd->result = DID_ERROR << 16;\r\nbreak;\r\n}\r\nif (sts_entry->iscsiFlags &ISCSI_FLAG_RESIDUAL_UNDER) {\r\nscsi_set_resid(cmd, residual);\r\nif (!scsi_status && ((scsi_bufflen(cmd) - residual) <\r\ncmd->underflow)) {\r\ncmd->result = DID_ERROR << 16;\r\nDEBUG2(printk("scsi%ld:%d:%d:%d: %s: "\r\n"Mid-layer Data underrun0, "\r\n"xferlen = 0x%x, "\r\n"residual = 0x%x\n", ha->host_no,\r\ncmd->device->channel,\r\ncmd->device->id,\r\ncmd->device->lun, __func__,\r\nscsi_bufflen(cmd), residual));\r\nbreak;\r\n}\r\n}\r\ncmd->result = DID_OK << 16 | scsi_status;\r\nif (scsi_status != SCSI_CHECK_CONDITION)\r\nbreak;\r\nqla4xxx_copy_sense(ha, sts_entry, srb);\r\nbreak;\r\ncase SCS_INCOMPLETE:\r\ncmd->result = DID_ERROR << 16;\r\nbreak;\r\ncase SCS_RESET_OCCURRED:\r\nDEBUG2(printk("scsi%ld:%d:%d:%d: %s: Device RESET occurred\n",\r\nha->host_no, cmd->device->channel,\r\ncmd->device->id, cmd->device->lun, __func__));\r\ncmd->result = DID_RESET << 16;\r\nbreak;\r\ncase SCS_ABORTED:\r\nDEBUG2(printk("scsi%ld:%d:%d:%d: %s: Abort occurred\n",\r\nha->host_no, cmd->device->channel,\r\ncmd->device->id, cmd->device->lun, __func__));\r\ncmd->result = DID_RESET << 16;\r\nbreak;\r\ncase SCS_TIMEOUT:\r\nDEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: Timeout\n",\r\nha->host_no, cmd->device->channel,\r\ncmd->device->id, cmd->device->lun));\r\ncmd->result = DID_TRANSPORT_DISRUPTED << 16;\r\nif (iscsi_is_session_online(ddb_entry->sess))\r\nqla4xxx_mark_device_missing(ddb_entry->sess);\r\nbreak;\r\ncase SCS_DATA_UNDERRUN:\r\ncase SCS_DATA_OVERRUN:\r\nif ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_OVER) ||\r\n(sts_entry->completionStatus == SCS_DATA_OVERRUN)) {\r\nDEBUG2(printk("scsi%ld:%d:%d:%d: %s: " "Data overrun\n",\r\nha->host_no,\r\ncmd->device->channel, cmd->device->id,\r\ncmd->device->lun, __func__));\r\ncmd->result = DID_ERROR << 16;\r\nbreak;\r\n}\r\nscsi_set_resid(cmd, residual);\r\nif (scsi_status != 0) {\r\ncmd->result = DID_OK << 16 | scsi_status;\r\nif (scsi_status != SCSI_CHECK_CONDITION)\r\nbreak;\r\nqla4xxx_copy_sense(ha, sts_entry, srb);\r\n} else {\r\nif ((sts_entry->iscsiFlags &\r\nISCSI_FLAG_RESIDUAL_UNDER) == 0) {\r\ncmd->result = DID_BUS_BUSY << 16;\r\n} else if ((scsi_bufflen(cmd) - residual) <\r\ncmd->underflow) {\r\nDEBUG2(printk("scsi%ld:%d:%d:%d: %s: "\r\n"Mid-layer Data underrun1, "\r\n"xferlen = 0x%x, "\r\n"residual = 0x%x\n", ha->host_no,\r\ncmd->device->channel,\r\ncmd->device->id,\r\ncmd->device->lun, __func__,\r\nscsi_bufflen(cmd), residual));\r\ncmd->result = DID_ERROR << 16;\r\n} else {\r\ncmd->result = DID_OK << 16;\r\n}\r\n}\r\nbreak;\r\ncase SCS_DEVICE_LOGGED_OUT:\r\ncase SCS_DEVICE_UNAVAILABLE:\r\nDEBUG2(printk(KERN_INFO "scsi%ld:%d:%d:%d: SCS_DEVICE "\r\n"state: 0x%x\n", ha->host_no,\r\ncmd->device->channel, cmd->device->id,\r\ncmd->device->lun, sts_entry->completionStatus));\r\nif (iscsi_is_session_online(ddb_entry->sess))\r\nqla4xxx_mark_device_missing(ddb_entry->sess);\r\ncmd->result = DID_TRANSPORT_DISRUPTED << 16;\r\nbreak;\r\ncase SCS_QUEUE_FULL:\r\ncmd->result = DID_OK << 16 | sts_entry->scsiStatus;\r\nDEBUG2(printk("scsi%ld:%d:%d: %s: QUEUE FULL detected "\r\n"compl=%02x, scsi=%02x, state=%02x, iFlags=%02x,"\r\n" iResp=%02x\n", ha->host_no, cmd->device->id,\r\ncmd->device->lun, __func__,\r\nsts_entry->completionStatus,\r\nsts_entry->scsiStatus, sts_entry->state_flags,\r\nsts_entry->iscsiFlags,\r\nsts_entry->iscsiResponse));\r\nbreak;\r\ndefault:\r\ncmd->result = DID_ERROR << 16;\r\nbreak;\r\n}\r\nstatus_entry_exit:\r\nsrb->cc_stat = sts_entry->completionStatus;\r\nif (ha->status_srb == NULL)\r\nkref_put(&srb->srb_ref, qla4xxx_srb_compl);\r\n}\r\nstatic void qla4xxx_passthru_status_entry(struct scsi_qla_host *ha,\r\nstruct passthru_status *sts_entry)\r\n{\r\nstruct iscsi_task *task;\r\nstruct ddb_entry *ddb_entry;\r\nstruct ql4_task_data *task_data;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_conn *conn;\r\nitt_t itt;\r\nuint32_t fw_ddb_index;\r\nitt = sts_entry->handle;\r\nfw_ddb_index = le32_to_cpu(sts_entry->target);\r\nddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);\r\nif (ddb_entry == NULL) {\r\nql4_printk(KERN_ERR, ha, "%s: Invalid target index = 0x%x\n",\r\n__func__, sts_entry->target);\r\nreturn;\r\n}\r\ncls_conn = ddb_entry->conn;\r\nconn = cls_conn->dd_data;\r\nspin_lock(&conn->session->lock);\r\ntask = iscsi_itt_to_task(conn, itt);\r\nspin_unlock(&conn->session->lock);\r\nif (task == NULL) {\r\nql4_printk(KERN_ERR, ha, "%s: Task is NULL\n", __func__);\r\nreturn;\r\n}\r\ntask_data = task->dd_data;\r\nmemcpy(&task_data->sts, sts_entry, sizeof(struct passthru_status));\r\nha->req_q_count += task_data->iocb_req_cnt;\r\nha->iocb_cnt -= task_data->iocb_req_cnt;\r\nqueue_work(ha->task_wq, &task_data->task_work);\r\n}\r\nstatic struct mrb *qla4xxx_del_mrb_from_active_array(struct scsi_qla_host *ha,\r\nuint32_t index)\r\n{\r\nstruct mrb *mrb = NULL;\r\nif (index >= MAX_MRB)\r\nreturn mrb;\r\nmrb = ha->active_mrb_array[index];\r\nha->active_mrb_array[index] = NULL;\r\nif (!mrb)\r\nreturn mrb;\r\nha->req_q_count += mrb->iocb_cnt;\r\nha->iocb_cnt -= mrb->iocb_cnt;\r\nreturn mrb;\r\n}\r\nstatic void qla4xxx_mbox_status_entry(struct scsi_qla_host *ha,\r\nstruct mbox_status_iocb *mbox_sts_entry)\r\n{\r\nstruct mrb *mrb;\r\nuint32_t status;\r\nuint32_t data_size;\r\nmrb = qla4xxx_del_mrb_from_active_array(ha,\r\nle32_to_cpu(mbox_sts_entry->handle));\r\nif (mrb == NULL) {\r\nql4_printk(KERN_WARNING, ha, "%s: mrb[%d] is null\n", __func__,\r\nmbox_sts_entry->handle);\r\nreturn;\r\n}\r\nswitch (mrb->mbox_cmd) {\r\ncase MBOX_CMD_PING:\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: mbox_cmd = 0x%x, "\r\n"mbox_sts[0] = 0x%x, mbox_sts[6] = 0x%x\n",\r\n__func__, mrb->mbox_cmd,\r\nmbox_sts_entry->out_mbox[0],\r\nmbox_sts_entry->out_mbox[6]));\r\nif (mbox_sts_entry->out_mbox[0] == MBOX_STS_COMMAND_COMPLETE)\r\nstatus = ISCSI_PING_SUCCESS;\r\nelse\r\nstatus = mbox_sts_entry->out_mbox[6];\r\ndata_size = sizeof(mbox_sts_entry->out_mbox);\r\nqla4xxx_post_ping_evt_work(ha, status, mrb->pid, data_size,\r\n(uint8_t *) mbox_sts_entry->out_mbox);\r\nbreak;\r\ndefault:\r\nDEBUG2(ql4_printk(KERN_WARNING, ha, "%s: invalid mbox_cmd = "\r\n"0x%x\n", __func__, mrb->mbox_cmd));\r\n}\r\nkfree(mrb);\r\nreturn;\r\n}\r\nvoid qla4xxx_process_response_queue(struct scsi_qla_host *ha)\r\n{\r\nuint32_t count = 0;\r\nstruct srb *srb = NULL;\r\nstruct status_entry *sts_entry;\r\nwhile ((ha->response_ptr->signature != RESPONSE_PROCESSED)) {\r\nsts_entry = (struct status_entry *) ha->response_ptr;\r\ncount++;\r\nif (ha->response_out == (RESPONSE_QUEUE_DEPTH - 1)) {\r\nha->response_out = 0;\r\nha->response_ptr = ha->response_ring;\r\n} else {\r\nha->response_out++;\r\nha->response_ptr++;\r\n}\r\nswitch (sts_entry->hdr.entryType) {\r\ncase ET_STATUS:\r\nqla4xxx_status_entry(ha, sts_entry);\r\nbreak;\r\ncase ET_PASSTHRU_STATUS:\r\nif (sts_entry->hdr.systemDefined == SD_ISCSI_PDU)\r\nqla4xxx_passthru_status_entry(ha,\r\n(struct passthru_status *)sts_entry);\r\nelse\r\nql4_printk(KERN_ERR, ha,\r\n"%s: Invalid status received\n",\r\n__func__);\r\nbreak;\r\ncase ET_STATUS_CONTINUATION:\r\nqla4xxx_status_cont_entry(ha,\r\n(struct status_cont_entry *) sts_entry);\r\nbreak;\r\ncase ET_COMMAND:\r\nsrb = qla4xxx_del_from_active_array(ha,\r\nle32_to_cpu(sts_entry->\r\nhandle));\r\nif (srb == NULL)\r\ngoto exit_prq_invalid_handle;\r\nDEBUG2(printk("scsi%ld: %s: FW device queue full, "\r\n"srb %p\n", ha->host_no, __func__, srb));\r\nsrb->cmd->result = DID_BUS_BUSY << 16;\r\nkref_put(&srb->srb_ref, qla4xxx_srb_compl);\r\nbreak;\r\ncase ET_CONTINUE:\r\nDEBUG2(printk("scsi%ld: %s: Continuation entry - "\r\n"ignoring\n", ha->host_no, __func__));\r\nbreak;\r\ncase ET_MBOX_STATUS:\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: mbox status IOCB\n", __func__));\r\nqla4xxx_mbox_status_entry(ha,\r\n(struct mbox_status_iocb *)sts_entry);\r\nbreak;\r\ndefault:\r\nDEBUG2(printk("scsi%ld: %s: Invalid entry %x in "\r\n"response queue \n", ha->host_no,\r\n__func__,\r\nsts_entry->hdr.entryType));\r\ngoto exit_prq_error;\r\n}\r\n((struct response *)sts_entry)->signature = RESPONSE_PROCESSED;\r\nwmb();\r\n}\r\nha->isp_ops->complete_iocb(ha);\r\nreturn;\r\nexit_prq_invalid_handle:\r\nDEBUG2(printk("scsi%ld: %s: Invalid handle(srb)=%p type=%x IOCS=%x\n",\r\nha->host_no, __func__, srb, sts_entry->hdr.entryType,\r\nsts_entry->completionStatus));\r\nexit_prq_error:\r\nha->isp_ops->complete_iocb(ha);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\nstatic void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,\r\nuint32_t mbox_status)\r\n{\r\nint i;\r\nuint32_t mbox_sts[MBOX_AEN_REG_COUNT];\r\nif ((mbox_status == MBOX_STS_BUSY) ||\r\n(mbox_status == MBOX_STS_INTERMEDIATE_COMPLETION) ||\r\n(mbox_status >> 12 == MBOX_COMPLETION_STATUS)) {\r\nha->mbox_status[0] = mbox_status;\r\nif (test_bit(AF_MBOX_COMMAND, &ha->flags)) {\r\nfor (i = 0; i < ha->mbox_status_count; i++)\r\nha->mbox_status[i] = is_qla8022(ha)\r\n? readl(&ha->qla4_8xxx_reg->mailbox_out[i])\r\n: readl(&ha->reg->mailbox[i]);\r\nset_bit(AF_MBOX_COMMAND_DONE, &ha->flags);\r\nif (test_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags))\r\ncomplete(&ha->mbx_intr_comp);\r\n}\r\n} else if (mbox_status >> 12 == MBOX_ASYNC_EVENT_STATUS) {\r\nfor (i = 0; i < MBOX_AEN_REG_COUNT; i++)\r\nmbox_sts[i] = is_qla8022(ha)\r\n? readl(&ha->qla4_8xxx_reg->mailbox_out[i])\r\n: readl(&ha->reg->mailbox[i]);\r\nif (ha->aen_log.count < MAX_AEN_ENTRIES) {\r\nfor (i = 0; i < MBOX_AEN_REG_COUNT; i++)\r\nha->aen_log.entry[ha->aen_log.count].mbox_sts[i] =\r\nmbox_sts[i];\r\nha->aen_log.count++;\r\n}\r\nswitch (mbox_status) {\r\ncase MBOX_ASTS_SYSTEM_ERROR:\r\nql4_printk(KERN_INFO, ha, "%s: System Err\n", __func__);\r\nqla4xxx_dump_registers(ha);\r\nif (ql4xdontresethba) {\r\nDEBUG2(printk("scsi%ld: %s:Don't Reset HBA\n",\r\nha->host_no, __func__));\r\n} else {\r\nset_bit(AF_GET_CRASH_RECORD, &ha->flags);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n}\r\nbreak;\r\ncase MBOX_ASTS_REQUEST_TRANSFER_ERROR:\r\ncase MBOX_ASTS_RESPONSE_TRANSFER_ERROR:\r\ncase MBOX_ASTS_NVRAM_INVALID:\r\ncase MBOX_ASTS_IP_ADDRESS_CHANGED:\r\ncase MBOX_ASTS_DHCP_LEASE_EXPIRED:\r\nDEBUG2(printk("scsi%ld: AEN %04x, ERROR Status, "\r\n"Reset HA\n", ha->host_no, mbox_status));\r\nif (is_qla8022(ha))\r\nset_bit(DPC_RESET_HA_FW_CONTEXT,\r\n&ha->dpc_flags);\r\nelse\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nbreak;\r\ncase MBOX_ASTS_LINK_UP:\r\nset_bit(AF_LINK_UP, &ha->flags);\r\nif (test_bit(AF_INIT_DONE, &ha->flags))\r\nset_bit(DPC_LINK_CHANGED, &ha->dpc_flags);\r\nql4_printk(KERN_INFO, ha, "%s: LINK UP\n", __func__);\r\nqla4xxx_post_aen_work(ha, ISCSI_EVENT_LINKUP,\r\nsizeof(mbox_sts),\r\n(uint8_t *) mbox_sts);\r\nbreak;\r\ncase MBOX_ASTS_LINK_DOWN:\r\nclear_bit(AF_LINK_UP, &ha->flags);\r\nif (test_bit(AF_INIT_DONE, &ha->flags))\r\nset_bit(DPC_LINK_CHANGED, &ha->dpc_flags);\r\nql4_printk(KERN_INFO, ha, "%s: LINK DOWN\n", __func__);\r\nqla4xxx_post_aen_work(ha, ISCSI_EVENT_LINKDOWN,\r\nsizeof(mbox_sts),\r\n(uint8_t *) mbox_sts);\r\nbreak;\r\ncase MBOX_ASTS_HEARTBEAT:\r\nha->seconds_since_last_heartbeat = 0;\r\nbreak;\r\ncase MBOX_ASTS_DHCP_LEASE_ACQUIRED:\r\nDEBUG2(printk("scsi%ld: AEN %04x DHCP LEASE "\r\n"ACQUIRED\n", ha->host_no, mbox_status));\r\nset_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags);\r\nbreak;\r\ncase MBOX_ASTS_PROTOCOL_STATISTIC_ALARM:\r\ncase MBOX_ASTS_SCSI_COMMAND_PDU_REJECTED:\r\ncase MBOX_ASTS_UNSOLICITED_PDU_RECEIVED:\r\ncase MBOX_ASTS_IPSEC_SYSTEM_FATAL_ERROR:\r\ncase MBOX_ASTS_SUBNET_STATE_CHANGE:\r\ncase MBOX_ASTS_DUPLICATE_IP:\r\nDEBUG2(printk("scsi%ld: AEN %04x\n", ha->host_no,\r\nmbox_status));\r\nbreak;\r\ncase MBOX_ASTS_IP_ADDR_STATE_CHANGED:\r\nprintk("scsi%ld: AEN %04x, mbox_sts[2]=%04x, "\r\n"mbox_sts[3]=%04x\n", ha->host_no, mbox_sts[0],\r\nmbox_sts[2], mbox_sts[3]);\r\nif ((mbox_sts[3] == ACB_STATE_VALID) &&\r\n((mbox_sts[2] == ACB_STATE_TENTATIVE) ||\r\n(mbox_sts[2] == ACB_STATE_ACQUIRING)))\r\nset_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags);\r\nelse if ((mbox_sts[3] == ACB_STATE_ACQUIRING) &&\r\n(mbox_sts[2] == ACB_STATE_VALID)) {\r\nif (is_qla8022(ha))\r\nset_bit(DPC_RESET_HA_FW_CONTEXT,\r\n&ha->dpc_flags);\r\nelse\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\n} else if ((mbox_sts[3] == ACB_STATE_UNCONFIGURED))\r\ncomplete(&ha->disable_acb_comp);\r\nbreak;\r\ncase MBOX_ASTS_MAC_ADDRESS_CHANGED:\r\ncase MBOX_ASTS_DNS:\r\nDEBUG2(printk(KERN_INFO "scsi%ld: AEN %04x, "\r\n"mbox_sts[1]=%04x, mbox_sts[2]=%04x\n",\r\nha->host_no, mbox_sts[0],\r\nmbox_sts[1], mbox_sts[2]));\r\nbreak;\r\ncase MBOX_ASTS_SELF_TEST_FAILED:\r\ncase MBOX_ASTS_LOGIN_FAILED:\r\nDEBUG2(printk("scsi%ld: AEN %04x, mbox_sts[1]=%04x, "\r\n"mbox_sts[2]=%04x, mbox_sts[3]=%04x\n",\r\nha->host_no, mbox_sts[0], mbox_sts[1],\r\nmbox_sts[2], mbox_sts[3]));\r\nbreak;\r\ncase MBOX_ASTS_DATABASE_CHANGED:\r\nif (ha->aen_q_count > 0) {\r\nha->aen_q_count--;\r\nfor (i = 0; i < MBOX_AEN_REG_COUNT; i++)\r\nha->aen_q[ha->aen_in].mbox_sts[i] =\r\nmbox_sts[i];\r\nDEBUG2(printk("scsi%ld: AEN[%d] %04x queued "\r\n"mb1:0x%x mb2:0x%x mb3:0x%x "\r\n"mb4:0x%x mb5:0x%x\n",\r\nha->host_no, ha->aen_in,\r\nmbox_sts[0], mbox_sts[1],\r\nmbox_sts[2], mbox_sts[3],\r\nmbox_sts[4], mbox_sts[5]));\r\nha->aen_in++;\r\nif (ha->aen_in == MAX_AEN_ENTRIES)\r\nha->aen_in = 0;\r\nset_bit(DPC_AEN, &ha->dpc_flags);\r\n} else {\r\nDEBUG2(printk("scsi%ld: %s: aen %04x, queue "\r\n"overflowed! AEN LOST!!\n",\r\nha->host_no, __func__,\r\nmbox_sts[0]));\r\nDEBUG2(printk("scsi%ld: DUMP AEN QUEUE\n",\r\nha->host_no));\r\nfor (i = 0; i < MAX_AEN_ENTRIES; i++) {\r\nDEBUG2(printk("AEN[%d] %04x %04x %04x "\r\n"%04x\n", i, mbox_sts[0],\r\nmbox_sts[1], mbox_sts[2],\r\nmbox_sts[3]));\r\n}\r\n}\r\nbreak;\r\ncase MBOX_ASTS_TXSCVR_INSERTED:\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: AEN %04x Transceiver"\r\n" inserted\n", ha->host_no, mbox_sts[0]));\r\nbreak;\r\ncase MBOX_ASTS_TXSCVR_REMOVED:\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: AEN %04x Transceiver"\r\n" removed\n", ha->host_no, mbox_sts[0]));\r\nbreak;\r\ndefault:\r\nDEBUG2(printk(KERN_WARNING\r\n"scsi%ld: AEN %04x UNKNOWN\n",\r\nha->host_no, mbox_sts[0]));\r\nbreak;\r\n}\r\n} else {\r\nDEBUG2(printk("scsi%ld: Unknown mailbox status %08X\n",\r\nha->host_no, mbox_status));\r\nha->mbox_status[0] = mbox_status;\r\n}\r\n}\r\nvoid qla4_8xxx_interrupt_service_routine(struct scsi_qla_host *ha,\r\nuint32_t intr_status)\r\n{\r\nif (intr_status & HSRX_RISC_IOCB_INT)\r\nqla4xxx_process_response_queue(ha);\r\nif (intr_status & HSRX_RISC_MB_INT)\r\nqla4xxx_isr_decode_mailbox(ha,\r\nreadl(&ha->qla4_8xxx_reg->mailbox_out[0]));\r\nwritel(0, &ha->qla4_8xxx_reg->host_int);\r\nreadl(&ha->qla4_8xxx_reg->host_int);\r\n}\r\nvoid qla4xxx_interrupt_service_routine(struct scsi_qla_host * ha,\r\nuint32_t intr_status)\r\n{\r\nif (intr_status & CSR_SCSI_COMPLETION_INTR)\r\nqla4xxx_process_response_queue(ha);\r\nif (intr_status & CSR_SCSI_PROCESSOR_INTR) {\r\nqla4xxx_isr_decode_mailbox(ha,\r\nreadl(&ha->reg->mailbox[0]));\r\nwritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\r\n&ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\n}\r\n}\r\nstatic void qla4_8xxx_spurious_interrupt(struct scsi_qla_host *ha,\r\nuint8_t reqs_count)\r\n{\r\nif (reqs_count)\r\nreturn;\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "Spurious Interrupt\n"));\r\nif (is_qla8022(ha)) {\r\nwritel(0, &ha->qla4_8xxx_reg->host_int);\r\nif (test_bit(AF_INTx_ENABLED, &ha->flags))\r\nqla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg,\r\n0xfbff);\r\n}\r\nha->spurious_int_count++;\r\n}\r\nirqreturn_t qla4xxx_intr_handler(int irq, void *dev_id)\r\n{\r\nstruct scsi_qla_host *ha;\r\nuint32_t intr_status;\r\nunsigned long flags = 0;\r\nuint8_t reqs_count = 0;\r\nha = (struct scsi_qla_host *) dev_id;\r\nif (!ha) {\r\nDEBUG2(printk(KERN_INFO\r\n"qla4xxx: Interrupt with NULL host ptr\n"));\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->isr_count++;\r\nwhile (1) {\r\nif (ha->isp_ops->rd_shdw_rsp_q_in(ha) !=\r\nha->response_out)\r\nintr_status = CSR_SCSI_COMPLETION_INTR;\r\nelse\r\nintr_status = readl(&ha->reg->ctrl_status);\r\nif ((intr_status &\r\n(CSR_SCSI_RESET_INTR|CSR_FATAL_ERROR|INTR_PENDING)) == 0) {\r\nif (reqs_count == 0)\r\nha->spurious_int_count++;\r\nbreak;\r\n}\r\nif (intr_status & CSR_FATAL_ERROR) {\r\nDEBUG2(printk(KERN_INFO "scsi%ld: Fatal Error, "\r\n"Status 0x%04x\n", ha->host_no,\r\nreadl(isp_port_error_status (ha))));\r\nif ((readl(&ha->reg->ctrl_status) &\r\nCSR_SCSI_RESET_INTR) == 0) {\r\nwritel(set_rmask(CSR_SOFT_RESET),\r\n&ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\n}\r\nwritel(set_rmask(CSR_FATAL_ERROR),\r\n&ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\n__qla4xxx_disable_intrs(ha);\r\nset_bit(DPC_RESET_HA, &ha->dpc_flags);\r\nbreak;\r\n} else if (intr_status & CSR_SCSI_RESET_INTR) {\r\nclear_bit(AF_ONLINE, &ha->flags);\r\n__qla4xxx_disable_intrs(ha);\r\nwritel(set_rmask(CSR_SCSI_RESET_INTR),\r\n&ha->reg->ctrl_status);\r\nreadl(&ha->reg->ctrl_status);\r\nif (!test_bit(AF_HA_REMOVAL, &ha->flags))\r\nset_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\r\nbreak;\r\n} else if (intr_status & INTR_PENDING) {\r\nha->isp_ops->interrupt_service_routine(ha, intr_status);\r\nha->total_io_count++;\r\nif (++reqs_count == MAX_REQS_SERVICED_PER_INTR)\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t qla4_8xxx_intr_handler(int irq, void *dev_id)\r\n{\r\nstruct scsi_qla_host *ha = dev_id;\r\nuint32_t intr_status;\r\nuint32_t status;\r\nunsigned long flags = 0;\r\nuint8_t reqs_count = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn IRQ_HANDLED;\r\nha->isr_count++;\r\nstatus = qla4_8xxx_rd_32(ha, ISR_INT_VECTOR);\r\nif (!(status & ha->nx_legacy_intr.int_vec_bit))\r\nreturn IRQ_NONE;\r\nstatus = qla4_8xxx_rd_32(ha, ISR_INT_STATE_REG);\r\nif (!ISR_IS_LEGACY_INTR_TRIGGERED(status)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s legacy Int not triggered\n", __func__));\r\nreturn IRQ_NONE;\r\n}\r\nqla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);\r\nqla4_8xxx_rd_32(ha, ISR_INT_VECTOR);\r\nqla4_8xxx_rd_32(ha, ISR_INT_VECTOR);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwhile (1) {\r\nif (!(readl(&ha->qla4_8xxx_reg->host_int) &\r\nISRX_82XX_RISC_INT)) {\r\nqla4_8xxx_spurious_interrupt(ha, reqs_count);\r\nbreak;\r\n}\r\nintr_status = readl(&ha->qla4_8xxx_reg->host_status);\r\nif ((intr_status &\r\n(HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0) {\r\nqla4_8xxx_spurious_interrupt(ha, reqs_count);\r\nbreak;\r\n}\r\nha->isp_ops->interrupt_service_routine(ha, intr_status);\r\nqla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\r\nif (++reqs_count == MAX_REQS_SERVICED_PER_INTR)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t\r\nqla4_8xxx_msi_handler(int irq, void *dev_id)\r\n{\r\nstruct scsi_qla_host *ha;\r\nha = (struct scsi_qla_host *) dev_id;\r\nif (!ha) {\r\nDEBUG2(printk(KERN_INFO\r\n"qla4xxx: MSIX: Interrupt with NULL host ptr\n"));\r\nreturn IRQ_NONE;\r\n}\r\nha->isr_count++;\r\nqla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);\r\nqla4_8xxx_rd_32(ha, ISR_INT_VECTOR);\r\nqla4_8xxx_rd_32(ha, ISR_INT_VECTOR);\r\nreturn qla4_8xxx_default_intr_handler(irq, dev_id);\r\n}\r\nirqreturn_t\r\nqla4_8xxx_default_intr_handler(int irq, void *dev_id)\r\n{\r\nstruct scsi_qla_host *ha = dev_id;\r\nunsigned long flags;\r\nuint32_t intr_status;\r\nuint8_t reqs_count = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwhile (1) {\r\nif (!(readl(&ha->qla4_8xxx_reg->host_int) &\r\nISRX_82XX_RISC_INT)) {\r\nqla4_8xxx_spurious_interrupt(ha, reqs_count);\r\nbreak;\r\n}\r\nintr_status = readl(&ha->qla4_8xxx_reg->host_status);\r\nif ((intr_status &\r\n(HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0) {\r\nqla4_8xxx_spurious_interrupt(ha, reqs_count);\r\nbreak;\r\n}\r\nha->isp_ops->interrupt_service_routine(ha, intr_status);\r\nif (++reqs_count == MAX_REQS_SERVICED_PER_INTR)\r\nbreak;\r\n}\r\nha->isr_count++;\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t\r\nqla4_8xxx_msix_rsp_q(int irq, void *dev_id)\r\n{\r\nstruct scsi_qla_host *ha = dev_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqla4xxx_process_response_queue(ha);\r\nwritel(0, &ha->qla4_8xxx_reg->host_int);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nha->isr_count++;\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid qla4xxx_process_aen(struct scsi_qla_host * ha, uint8_t process_aen)\r\n{\r\nuint32_t mbox_sts[MBOX_AEN_REG_COUNT];\r\nstruct aen *aen;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwhile (ha->aen_out != ha->aen_in) {\r\naen = &ha->aen_q[ha->aen_out];\r\nfor (i = 0; i < MBOX_AEN_REG_COUNT; i++)\r\nmbox_sts[i] = aen->mbox_sts[i];\r\nha->aen_q_count++;\r\nha->aen_out++;\r\nif (ha->aen_out == MAX_AEN_ENTRIES)\r\nha->aen_out = 0;\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nDEBUG2(printk("qla4xxx(%ld): AEN[%d]=0x%08x, mbx1=0x%08x mbx2=0x%08x"\r\n" mbx3=0x%08x mbx4=0x%08x\n", ha->host_no,\r\n(ha->aen_out ? (ha->aen_out-1): (MAX_AEN_ENTRIES-1)),\r\nmbox_sts[0], mbox_sts[1], mbox_sts[2],\r\nmbox_sts[3], mbox_sts[4]));\r\nswitch (mbox_sts[0]) {\r\ncase MBOX_ASTS_DATABASE_CHANGED:\r\nswitch (process_aen) {\r\ncase FLUSH_DDB_CHANGED_AENS:\r\nDEBUG2(printk("scsi%ld: AEN[%d] %04x, index "\r\n"[%d] state=%04x FLUSHED!\n",\r\nha->host_no, ha->aen_out,\r\nmbox_sts[0], mbox_sts[2],\r\nmbox_sts[3]));\r\nbreak;\r\ncase PROCESS_ALL_AENS:\r\ndefault:\r\nif (mbox_sts[1] == 1)\r\nqla4xxx_process_ddb_changed(ha,\r\nmbox_sts[2], mbox_sts[3],\r\nmbox_sts[4]);\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nint qla4xxx_request_irqs(struct scsi_qla_host *ha)\r\n{\r\nint ret;\r\nif (!is_qla8022(ha))\r\ngoto try_intx;\r\nif (ql4xenablemsix == 2)\r\ngoto try_msi;\r\nif (ql4xenablemsix == 0 || ql4xenablemsix != 1)\r\ngoto try_intx;\r\nret = qla4_8xxx_enable_msix(ha);\r\nif (!ret) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"MSI-X: Enabled (0x%X).\n", ha->revision_id));\r\ngoto irq_attached;\r\n}\r\nql4_printk(KERN_WARNING, ha,\r\n"MSI-X: Falling back-to MSI mode -- %d.\n", ret);\r\ntry_msi:\r\nret = pci_enable_msi(ha->pdev);\r\nif (!ret) {\r\nret = request_irq(ha->pdev->irq, qla4_8xxx_msi_handler,\r\n0, DRIVER_NAME, ha);\r\nif (!ret) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "MSI: Enabled.\n"));\r\nset_bit(AF_MSI_ENABLED, &ha->flags);\r\ngoto irq_attached;\r\n} else {\r\nql4_printk(KERN_WARNING, ha,\r\n"MSI: Failed to reserve interrupt %d "\r\n"already in use.\n", ha->pdev->irq);\r\npci_disable_msi(ha->pdev);\r\n}\r\n}\r\nql4_printk(KERN_WARNING, ha,\r\n"MSI: Falling back-to INTx mode -- %d.\n", ret);\r\ntry_intx:\r\nret = request_irq(ha->pdev->irq, ha->isp_ops->intr_handler,\r\nIRQF_SHARED, DRIVER_NAME, ha);\r\nif (!ret) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "INTx: Enabled.\n"));\r\nset_bit(AF_INTx_ENABLED, &ha->flags);\r\ngoto irq_attached;\r\n} else {\r\nql4_printk(KERN_WARNING, ha,\r\n"INTx: Failed to reserve interrupt %d already in"\r\n" use.\n", ha->pdev->irq);\r\nreturn ret;\r\n}\r\nirq_attached:\r\nset_bit(AF_IRQ_ATTACHED, &ha->flags);\r\nha->host->irq = ha->pdev->irq;\r\nql4_printk(KERN_INFO, ha, "%s: irq %d attached\n",\r\n__func__, ha->pdev->irq);\r\nreturn ret;\r\n}\r\nvoid qla4xxx_free_irqs(struct scsi_qla_host *ha)\r\n{\r\nif (test_bit(AF_MSIX_ENABLED, &ha->flags))\r\nqla4_8xxx_disable_msix(ha);\r\nelse if (test_and_clear_bit(AF_MSI_ENABLED, &ha->flags)) {\r\nfree_irq(ha->pdev->irq, ha);\r\npci_disable_msi(ha->pdev);\r\n} else if (test_and_clear_bit(AF_INTx_ENABLED, &ha->flags))\r\nfree_irq(ha->pdev->irq, ha);\r\n}
