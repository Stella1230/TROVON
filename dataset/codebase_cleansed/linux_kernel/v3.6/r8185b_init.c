void PlatformIOWrite1Byte(struct net_device *dev, u32 offset, u8 data)\r\n{\r\nwrite_nic_byte(dev, offset, data);\r\nread_nic_byte(dev, offset);\r\n}\r\nvoid PlatformIOWrite2Byte(struct net_device *dev, u32 offset, u16 data)\r\n{\r\nwrite_nic_word(dev, offset, data);\r\nread_nic_word(dev, offset);\r\n}\r\nvoid PlatformIOWrite4Byte(struct net_device *dev, u32 offset, u32 data)\r\n{\r\nif (offset == PhyAddr) {\r\nunsigned char cmdByte;\r\nunsigned long dataBytes;\r\nunsigned char idx;\r\nu8 u1bTmp;\r\ncmdByte = (u8)(data & 0x000000ff);\r\ndataBytes = data>>8;\r\nfor (idx = 0; idx < 30; idx++) {\r\nu1bTmp = PlatformIORead1Byte(dev, PhyAddr);\r\nif ((u1bTmp & BIT7) == 0)\r\nbreak;\r\nelse\r\nmdelay(10);\r\n}\r\nfor (idx = 0; idx < 3; idx++)\r\nPlatformIOWrite1Byte(dev, offset+1+idx, ((u8 *)&dataBytes)[idx]);\r\nwrite_nic_byte(dev, offset, cmdByte);\r\n} else {\r\nwrite_nic_dword(dev, offset, data);\r\nread_nic_dword(dev, offset);\r\n}\r\n}\r\nu8 PlatformIORead1Byte(struct net_device *dev, u32 offset)\r\n{\r\nu8 data = 0;\r\ndata = read_nic_byte(dev, offset);\r\nreturn data;\r\n}\r\nu16 PlatformIORead2Byte(struct net_device *dev, u32 offset)\r\n{\r\nu16 data = 0;\r\ndata = read_nic_word(dev, offset);\r\nreturn data;\r\n}\r\nu32 PlatformIORead4Byte(struct net_device *dev, u32 offset)\r\n{\r\nu32 data = 0;\r\ndata = read_nic_dword(dev, offset);\r\nreturn data;\r\n}\r\nvoid SetOutputEnableOfRfPins(struct net_device *dev)\r\n{\r\nwrite_nic_word(dev, RFPinsEnable, 0x1bff);\r\n}\r\nstatic int HwHSSIThreeWire(struct net_device *dev,\r\nu8 *pDataBuf,\r\nu8 nDataBufBitCnt,\r\nint bSI,\r\nint bWrite)\r\n{\r\nint bResult = 1;\r\nu8 TryCnt;\r\nu8 u1bTmp;\r\ndo {\r\nfor (TryCnt = 0; TryCnt < TC_3W_POLL_MAX_TRY_CNT; TryCnt++) {\r\nu1bTmp = read_nic_byte(dev, SW_3W_CMD1);\r\nif ((u1bTmp & (SW_3W_CMD1_RE|SW_3W_CMD1_WE)) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (TryCnt == TC_3W_POLL_MAX_TRY_CNT) {\r\nprintk(KERN_ERR "rtl8187se: HwThreeWire(): CmdReg:"\r\n" %#X RE|WE bits are not clear!!\n", u1bTmp);\r\ndump_stack();\r\nreturn 0;\r\n}\r\nu1bTmp = read_nic_byte(dev, RF_SW_CONFIG);\r\nif (bSI)\r\nu1bTmp |= RF_SW_CFG_SI;\r\nelse\r\nu1bTmp &= ~RF_SW_CFG_SI;\r\nwrite_nic_byte(dev, RF_SW_CONFIG, u1bTmp);\r\nif (bSI) {\r\nu1bTmp = read_nic_byte(dev, RFPinsSelect);\r\nu1bTmp &= ~BIT3;\r\nwrite_nic_byte(dev, RFPinsSelect, u1bTmp);\r\n}\r\nif (bWrite) {\r\nif (nDataBufBitCnt == 16) {\r\nwrite_nic_word(dev, SW_3W_DB0, *((u16 *)pDataBuf));\r\n} else if (nDataBufBitCnt == 64) {\r\nwrite_nic_dword(dev, SW_3W_DB0, *((u32 *)pDataBuf));\r\nwrite_nic_dword(dev, SW_3W_DB1, *((u32 *)(pDataBuf + 4)));\r\n} else {\r\nint idx;\r\nint ByteCnt = nDataBufBitCnt / 8;\r\nif ((nDataBufBitCnt % 8) != 0) {\r\nprintk(KERN_ERR "rtl8187se: "\r\n"HwThreeWire(): nDataBufBitCnt(%d)"\r\n" should be multiple of 8!!!\n",\r\nnDataBufBitCnt);\r\ndump_stack();\r\nnDataBufBitCnt += 8;\r\nnDataBufBitCnt &= ~7;\r\n}\r\nif (nDataBufBitCnt > 64) {\r\nprintk(KERN_ERR "rtl8187se: HwThreeWire():"\r\n" nDataBufBitCnt(%d) should <= 64!!!\n",\r\nnDataBufBitCnt);\r\ndump_stack();\r\nnDataBufBitCnt = 64;\r\n}\r\nfor (idx = 0; idx < ByteCnt; idx++)\r\nwrite_nic_byte(dev, (SW_3W_DB0+idx), *(pDataBuf+idx));\r\n}\r\n} else {\r\nif (bSI) {\r\nwrite_nic_word(dev, SW_3W_DB0, *((u16 *)pDataBuf));\r\n} else {\r\nwrite_nic_word(dev, SW_3W_DB0, (*((u16 *)pDataBuf)) << 12);\r\n}\r\n}\r\nif (bWrite)\r\nwrite_nic_byte(dev, SW_3W_CMD1, SW_3W_CMD1_WE);\r\nelse\r\nwrite_nic_byte(dev, SW_3W_CMD1, SW_3W_CMD1_RE);\r\nfor (TryCnt = 0; TryCnt < TC_3W_POLL_MAX_TRY_CNT; TryCnt++) {\r\nu1bTmp = read_nic_byte(dev, SW_3W_CMD1);\r\nif ((u1bTmp & SW_3W_CMD1_DONE) != 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nwrite_nic_byte(dev, SW_3W_CMD1, 0);\r\nif (bWrite == 0) {\r\nif (bSI) {\r\n*((u16 *)pDataBuf) = read_nic_word(dev, SI_DATA_READ) ;\r\n} else {\r\n*((u16 *)pDataBuf) = read_nic_word(dev, PI_DATA_READ);\r\n}\r\n*((u16 *)pDataBuf) &= 0x0FFF;\r\n}\r\n} while (0);\r\nreturn bResult;\r\n}\r\nvoid RF_WriteReg(struct net_device *dev, u8 offset, u32 data)\r\n{\r\nu32 data2Write;\r\nu8 len;\r\ndata2Write = (data << 4) | (u32)(offset & 0x0f);\r\nlen = 16;\r\nHwHSSIThreeWire(dev, (u8 *)(&data2Write), len, 1, 1);\r\n}\r\nu32 RF_ReadReg(struct net_device *dev, u8 offset)\r\n{\r\nu32 data2Write;\r\nu8 wlen;\r\nu32 dataRead;\r\ndata2Write = ((u32)(offset & 0x0f));\r\nwlen = 16;\r\nHwHSSIThreeWire(dev, (u8 *)(&data2Write), wlen, 1, 0);\r\ndataRead = data2Write;\r\nreturn dataRead;\r\n}\r\nvoid WriteBBPortUchar(struct net_device *dev, u32 Data)\r\n{\r\nu8 RegisterContent;\r\nu8 UCharData;\r\nUCharData = (u8)((Data & 0x0000ff00) >> 8);\r\nPlatformIOWrite4Byte(dev, PhyAddr, Data);\r\n{\r\nPlatformIOWrite4Byte(dev, PhyAddr, Data & 0xffffff7f);\r\nRegisterContent = PlatformIORead1Byte(dev, PhyDataR);\r\n}\r\n}\r\nu8 ReadBBPortUchar(struct net_device *dev, u32 addr)\r\n{\r\nu8 RegisterContent;\r\nPlatformIOWrite4Byte(dev, PhyAddr, addr & 0xffffff7f);\r\nRegisterContent = PlatformIORead1Byte(dev, PhyDataR);\r\nreturn RegisterContent;\r\n}\r\nbool SetAntennaConfig87SE(struct net_device *dev,\r\nu8 DefaultAnt,\r\nbool bAntDiversity)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nbool bAntennaSwitched = true;\r\nwrite_phy_cck(dev, 0x0c, 0x09);\r\nif (bAntDiversity) {\r\nif (DefaultAnt == 1) {\r\nwrite_nic_byte(dev, ANTSEL, 0x00);\r\nwrite_phy_cck(dev, 0x11, 0xbb);\r\nwrite_phy_cck(dev, 0x01, 0xc7);\r\nwrite_phy_ofdm(dev, 0x0D, 0x54);\r\nwrite_phy_ofdm(dev, 0x18, 0xb2);\r\n} else {\r\nwrite_nic_byte(dev, ANTSEL, 0x03);\r\nwrite_phy_cck(dev, 0x11, 0x9b);\r\nwrite_phy_cck(dev, 0x01, 0xc7);\r\nwrite_phy_ofdm(dev, 0x0d, 0x5c);\r\nwrite_phy_ofdm(dev, 0x18, 0xb2);\r\n}\r\n} else {\r\nif (DefaultAnt == 1) {\r\nwrite_nic_byte(dev, ANTSEL, 0x00);\r\nwrite_phy_cck(dev, 0x11, 0xbb);\r\nwrite_phy_cck(dev, 0x01, 0x47);\r\nwrite_phy_ofdm(dev, 0x0D, 0x54);\r\nwrite_phy_ofdm(dev, 0x18, 0x32);\r\n} else {\r\nwrite_nic_byte(dev, ANTSEL, 0x03);\r\nwrite_phy_cck(dev, 0x11, 0x9b);\r\nwrite_phy_cck(dev, 0x01, 0x47);\r\nwrite_phy_ofdm(dev, 0x0D, 0x5c);\r\nwrite_phy_ofdm(dev, 0x18, 0x32);\r\n}\r\n}\r\npriv->CurrAntennaIndex = DefaultAnt;\r\nreturn bAntennaSwitched;\r\n}\r\nvoid ZEBRA_Config_85BASIC_HardCode(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nu32 i;\r\nu32 addr, data;\r\nu32 u4bRegOffset, u4bRegValue, u4bRF23, u4bRF24;\r\nu8 u1b24E;\r\nint d_cut = 0;\r\nRF_WriteReg(dev, 0x00, 0x013f); mdelay(1);\r\nu4bRF23 = RF_ReadReg(dev, 0x08); mdelay(1);\r\nu4bRF24 = RF_ReadReg(dev, 0x09); mdelay(1);\r\nif (u4bRF23 == 0x818 && u4bRF24 == 0x70C) {\r\nd_cut = 1;\r\nprintk(KERN_INFO "rtl8187se: card type changed from C- to D-cut\n");\r\n}\r\nRF_WriteReg(dev, 0x00, 0x009f); mdelay(1);\r\nRF_WriteReg(dev, 0x01, 0x06e0); mdelay(1);\r\nRF_WriteReg(dev, 0x02, 0x004d); mdelay(1);\r\nRF_WriteReg(dev, 0x03, 0x07f1); mdelay(1);\r\nRF_WriteReg(dev, 0x04, 0x0975); mdelay(1);\r\nRF_WriteReg(dev, 0x05, 0x0c72); mdelay(1);\r\nRF_WriteReg(dev, 0x06, 0x0ae6); mdelay(1);\r\nRF_WriteReg(dev, 0x07, 0x00ca); mdelay(1);\r\nRF_WriteReg(dev, 0x08, 0x0e1c); mdelay(1);\r\nRF_WriteReg(dev, 0x09, 0x02f0); mdelay(1);\r\nRF_WriteReg(dev, 0x0a, 0x09d0); mdelay(1);\r\nRF_WriteReg(dev, 0x0b, 0x01ba); mdelay(1);\r\nRF_WriteReg(dev, 0x0c, 0x0640); mdelay(1);\r\nRF_WriteReg(dev, 0x0d, 0x08df); mdelay(1);\r\nRF_WriteReg(dev, 0x0e, 0x0020); mdelay(1);\r\nRF_WriteReg(dev, 0x0f, 0x0990); mdelay(1);\r\nRF_WriteReg(dev, 0x00, 0x013f); mdelay(1);\r\nRF_WriteReg(dev, 0x03, 0x0806); mdelay(1);\r\nRF_WriteReg(dev, 0x04, 0x03a7); mdelay(1);\r\nRF_WriteReg(dev, 0x05, 0x059b); mdelay(1);\r\nRF_WriteReg(dev, 0x06, 0x0081); mdelay(1);\r\nRF_WriteReg(dev, 0x07, 0x01A0); mdelay(1);\r\nRF_WriteReg(dev, 0x0a, 0x0001); mdelay(1);\r\nRF_WriteReg(dev, 0x0b, 0x0418); mdelay(1);\r\nif (d_cut) {\r\nRF_WriteReg(dev, 0x0c, 0x0fbe); mdelay(1);\r\nRF_WriteReg(dev, 0x0d, 0x0008); mdelay(1);\r\nRF_WriteReg(dev, 0x0e, 0x0807); mdelay(1);\r\n} else {\r\nRF_WriteReg(dev, 0x0c, 0x0fbe); mdelay(1);\r\nRF_WriteReg(dev, 0x0d, 0x0008); mdelay(1);\r\nRF_WriteReg(dev, 0x0e, 0x0806); mdelay(1);\r\n}\r\nRF_WriteReg(dev, 0x0f, 0x0acc); mdelay(1);\r\nRF_WriteReg(dev, 0x00, 0x01d7); mdelay(1);\r\nRF_WriteReg(dev, 0x03, 0x0e00); mdelay(1);\r\nRF_WriteReg(dev, 0x04, 0x0e50); mdelay(1);\r\nfor (i = 0; i <= 36; i++) {\r\nRF_WriteReg(dev, 0x01, i); mdelay(1);\r\nRF_WriteReg(dev, 0x02, ZEBRA_RF_RX_GAIN_TABLE[i]); mdelay(1);\r\n}\r\nRF_WriteReg(dev, 0x05, 0x0203); mdelay(1);\r\nRF_WriteReg(dev, 0x06, 0x0200); mdelay(1);\r\nRF_WriteReg(dev, 0x00, 0x0137); mdelay(1);\r\nmdelay(10);\r\nRF_WriteReg(dev, 0x0d, 0x0008); mdelay(1);\r\nmdelay(10);\r\nRF_WriteReg(dev, 0x00, 0x0037); mdelay(1);\r\nmdelay(10);\r\nRF_WriteReg(dev, 0x04, 0x0160); mdelay(1);\r\nmdelay(10);\r\nRF_WriteReg(dev, 0x07, 0x0080); mdelay(1);\r\nmdelay(10);\r\nRF_WriteReg(dev, 0x02, 0x088D); mdelay(1);\r\nmdelay(200);\r\nmdelay(10);\r\nmdelay(10);\r\nRF_WriteReg(dev, 0x00, 0x0137); mdelay(1);\r\nmdelay(10);\r\nRF_WriteReg(dev, 0x07, 0x0000); mdelay(1);\r\nRF_WriteReg(dev, 0x07, 0x0180); mdelay(1);\r\nRF_WriteReg(dev, 0x07, 0x0220); mdelay(1);\r\nRF_WriteReg(dev, 0x07, 0x03E0); mdelay(1);\r\nRF_WriteReg(dev, 0x06, 0x00c1); mdelay(1);\r\nRF_WriteReg(dev, 0x0a, 0x0001); mdelay(1);\r\nif (priv->bXtalCalibration) {\r\nRF_WriteReg(dev, 0x0f, (priv->XtalCal_Xin<<5) | (priv->XtalCal_Xout<<1) | BIT11 | BIT9); mdelay(1);\r\nprintk("ZEBRA_Config_85BASIC_HardCode(): (%02x)\n",\r\n(priv->XtalCal_Xin<<5) | (priv->XtalCal_Xout<<1) | BIT11 | BIT9);\r\n} else {\r\nRF_WriteReg(dev, 0x0f, 0x0acc); mdelay(1);\r\n}\r\nRF_WriteReg(dev, 0x00, 0x00bf); mdelay(1);\r\nRF_WriteReg(dev, 0x0d, 0x08df); mdelay(1);\r\nRF_WriteReg(dev, 0x02, 0x004d); mdelay(1);\r\nRF_WriteReg(dev, 0x04, 0x0975); mdelay(1);\r\nmdelay(10);\r\nmdelay(10);\r\nmdelay(10);\r\nRF_WriteReg(dev, 0x00, 0x0197); mdelay(1);\r\nRF_WriteReg(dev, 0x05, 0x05ab); mdelay(1);\r\nRF_WriteReg(dev, 0x00, 0x009f); mdelay(1);\r\nRF_WriteReg(dev, 0x01, 0x0000); mdelay(1);\r\nRF_WriteReg(dev, 0x02, 0x0000); mdelay(1);\r\nu1b24E = read_nic_byte(dev, 0x24E);\r\nwrite_nic_byte(dev, 0x24E, (u1b24E & (~(BIT5|BIT6))));\r\nwrite_phy_cck(dev, 0x00, 0xc8);\r\nwrite_phy_cck(dev, 0x06, 0x1c);\r\nwrite_phy_cck(dev, 0x10, 0x78);\r\nwrite_phy_cck(dev, 0x2e, 0xd0);\r\nwrite_phy_cck(dev, 0x2f, 0x06);\r\nwrite_phy_cck(dev, 0x01, 0x46);\r\nwrite_nic_byte(dev, CCK_TXAGC, 0x10);\r\nwrite_nic_byte(dev, OFDM_TXAGC, 0x1B);\r\nwrite_nic_byte(dev, ANTSEL, 0x03);\r\nwrite_phy_ofdm(dev, 0x00, 0x12);\r\nfor (i = 0; i < 128; i++) {\r\ndata = ZEBRA_AGC[i+1];\r\ndata = data << 8;\r\ndata = data | 0x0000008F;\r\naddr = i + 0x80;\r\naddr = addr << 8;\r\naddr = addr | 0x0000008E;\r\nWriteBBPortUchar(dev, data);\r\nWriteBBPortUchar(dev, addr);\r\nWriteBBPortUchar(dev, 0x0000008E);\r\n}\r\nPlatformIOWrite4Byte(dev, PhyAddr, 0x00001080);\r\nfor (i = 0; i < 60; i++) {\r\nu4bRegOffset = i;\r\nu4bRegValue = OFDM_CONFIG[i];\r\nWriteBBPortUchar(dev,\r\n(0x00000080 |\r\n(u4bRegOffset & 0x7f) |\r\n((u4bRegValue & 0xff) << 8)));\r\n}\r\nSetAntennaConfig87SE(dev, priv->bDefaultAntenna1, priv->bSwAntennaDiverity);\r\n}\r\nvoid UpdateInitialGain(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nif (priv->eRFPowerState != eRfOn) {\r\npriv->InitialGain = priv->InitialGainBackUp;\r\nreturn;\r\n}\r\nswitch (priv->InitialGain) {\r\ncase 1:\r\nwrite_phy_ofdm(dev, 0x17, 0x26); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0x86); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfa); mdelay(1);\r\nbreak;\r\ncase 2:\r\nwrite_phy_ofdm(dev, 0x17, 0x36); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0x86); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfa); mdelay(1);\r\nbreak;\r\ncase 3:\r\nwrite_phy_ofdm(dev, 0x17, 0x36); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0x86); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfb); mdelay(1);\r\nbreak;\r\ncase 4:\r\nwrite_phy_ofdm(dev, 0x17, 0x46); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0x86); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfb); mdelay(1);\r\nbreak;\r\ncase 5:\r\nwrite_phy_ofdm(dev, 0x17, 0x46); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0x96); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfb); mdelay(1);\r\nbreak;\r\ncase 6:\r\nwrite_phy_ofdm(dev, 0x17, 0x56); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0x96); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfc); mdelay(1);\r\nbreak;\r\ncase 7:\r\nwrite_phy_ofdm(dev, 0x17, 0x56); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0xa6); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfc); mdelay(1);\r\nbreak;\r\ncase 8:\r\nwrite_phy_ofdm(dev, 0x17, 0x66); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0xb6); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfc); mdelay(1);\r\nbreak;\r\ndefault:\r\nwrite_phy_ofdm(dev, 0x17, 0x26); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x24, 0x86); mdelay(1);\r\nwrite_phy_ofdm(dev, 0x05, 0xfa); mdelay(1);\r\nbreak;\r\n}\r\n}\r\nvoid InitTxPwrTracking87SE(struct net_device *dev)\r\n{\r\nu32 u4bRfReg;\r\nu4bRfReg = RF_ReadReg(dev, 0x02);\r\nRF_WriteReg(dev, 0x02, u4bRfReg|PWR_METER_EN); mdelay(1);\r\n}\r\nvoid PhyConfig8185(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nwrite_nic_dword(dev, RCR, priv->ReceiveConfig);\r\npriv->RFProgType = read_nic_byte(dev, CONFIG4) & 0x03;\r\nZEBRA_Config_85BASIC_HardCode(dev);\r\nif (priv->bDigMechanism) {\r\nif (priv->InitialGain == 0)\r\npriv->InitialGain = 4;\r\n}\r\nif (priv->bTxPowerTrack)\r\nInitTxPwrTracking87SE(dev);\r\npriv->InitialGainBackUp = priv->InitialGain;\r\nUpdateInitialGain(dev);\r\nreturn;\r\n}\r\nvoid HwConfigureRTL8185(struct net_device *dev)\r\n{\r\nu8 bUNIVERSAL_CONTROL_RL = 0;\r\nu8 bUNIVERSAL_CONTROL_AGC = 1;\r\nu8 bUNIVERSAL_CONTROL_ANT = 1;\r\nu8 bAUTO_RATE_FALLBACK_CTL = 1;\r\nu8 val8;\r\nwrite_nic_word(dev, BRSR, 0x0fff);\r\nval8 = read_nic_byte(dev, CW_CONF);\r\nif (bUNIVERSAL_CONTROL_RL)\r\nval8 = val8 & 0xfd;\r\nelse\r\nval8 = val8 | 0x02;\r\nwrite_nic_byte(dev, CW_CONF, val8);\r\nval8 = read_nic_byte(dev, TXAGC_CTL);\r\nif (bUNIVERSAL_CONTROL_AGC) {\r\nwrite_nic_byte(dev, CCK_TXAGC, 128);\r\nwrite_nic_byte(dev, OFDM_TXAGC, 128);\r\nval8 = val8 & 0xfe;\r\n} else {\r\nval8 = val8 | 0x01 ;\r\n}\r\nwrite_nic_byte(dev, TXAGC_CTL, val8);\r\nval8 = read_nic_byte(dev, TXAGC_CTL);\r\nif (bUNIVERSAL_CONTROL_ANT) {\r\nwrite_nic_byte(dev, ANTSEL, 0x00);\r\nval8 = val8 & 0xfd;\r\n} else {\r\nval8 = val8 & (val8|0x02);\r\n}\r\nwrite_nic_byte(dev, TXAGC_CTL, val8);\r\nval8 = read_nic_byte(dev, RATE_FALLBACK);\r\nval8 &= 0x7c;\r\nif (bAUTO_RATE_FALLBACK_CTL) {\r\nval8 |= RATE_FALLBACK_CTL_ENABLE | RATE_FALLBACK_CTL_AUTO_STEP1;\r\nPlatformIOWrite2Byte(dev, ARFR, 0x0fff);\r\n}\r\nwrite_nic_byte(dev, RATE_FALLBACK, val8);\r\n}\r\nstatic void MacConfig_85BASIC_HardCode(struct net_device *dev)\r\n{\r\nint nLinesRead = 0;\r\nu32 u4bRegOffset, u4bRegValue, u4bPageIndex = 0;\r\nint i;\r\nnLinesRead = sizeof(MAC_REG_TABLE)/2;\r\nfor (i = 0; i < nLinesRead; i++) {\r\nu4bRegOffset = MAC_REG_TABLE[i][0];\r\nu4bRegValue = MAC_REG_TABLE[i][1];\r\nif (u4bRegOffset == 0x5e)\r\nu4bPageIndex = u4bRegValue;\r\nelse\r\nu4bRegOffset |= (u4bPageIndex << 8);\r\nwrite_nic_byte(dev, u4bRegOffset, (u8)u4bRegValue);\r\n}\r\n}\r\nstatic void MacConfig_85BASIC(struct net_device *dev)\r\n{\r\nu8 u1DA;\r\nMacConfig_85BASIC_HardCode(dev);\r\nwrite_nic_word(dev, TID_AC_MAP, 0xfa50);\r\nwrite_nic_word(dev, IntMig, 0x0000);\r\nPlatformIOWrite4Byte(dev, 0x1F0, 0x00000000);\r\nPlatformIOWrite4Byte(dev, 0x1F4, 0x00000000);\r\nPlatformIOWrite1Byte(dev, 0x1F8, 0x00);\r\nu1DA = read_nic_byte(dev, PHYPR);\r\nwrite_nic_byte(dev, PHYPR, (u1DA | BIT2));\r\nwrite_nic_word(dev, 0x360, 0x1000);\r\nwrite_nic_word(dev, 0x362, 0x1000);\r\nwrite_nic_word(dev, 0x370, 0x0560);\r\nwrite_nic_word(dev, 0x372, 0x0560);\r\nwrite_nic_word(dev, 0x374, 0x0DA4);\r\nwrite_nic_word(dev, 0x376, 0x0DA4);\r\nwrite_nic_word(dev, 0x378, 0x0560);\r\nwrite_nic_word(dev, 0x37A, 0x0560);\r\nwrite_nic_word(dev, 0x37C, 0x00EC);\r\nwrite_nic_word(dev, 0x37E, 0x00EC);\r\nwrite_nic_byte(dev, 0x24E, 0x01);\r\n}\r\nu8 GetSupportedWirelessMode8185(struct net_device *dev)\r\n{\r\nu8 btSupportedWirelessMode = 0;\r\nbtSupportedWirelessMode = (WIRELESS_MODE_B | WIRELESS_MODE_G);\r\nreturn btSupportedWirelessMode;\r\n}\r\nvoid ActUpdateChannelAccessSetting(struct net_device *dev,\r\nWIRELESS_MODE WirelessMode,\r\nPCHANNEL_ACCESS_SETTING ChnlAccessSetting)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nAC_CODING eACI;\r\nAC_PARAM AcParam;\r\nu8 bFollowLegacySetting = 0;\r\nu8 u1bAIFS;\r\nChnlAccessSetting->SIFS_Timer = 0x22;\r\nChnlAccessSetting->DIFS_Timer = 0x1C;\r\nChnlAccessSetting->SlotTimeTimer = 9;\r\nChnlAccessSetting->EIFS_Timer = 0x5B;\r\nChnlAccessSetting->CWminIndex = 3;\r\nChnlAccessSetting->CWmaxIndex = 7;\r\nwrite_nic_byte(dev, SIFS, ChnlAccessSetting->SIFS_Timer);\r\nwrite_nic_byte(dev, SLOT, ChnlAccessSetting->SlotTimeTimer);\r\nu1bAIFS = aSifsTime + (2 * ChnlAccessSetting->SlotTimeTimer);\r\nwrite_nic_byte(dev, EIFS, ChnlAccessSetting->EIFS_Timer);\r\nwrite_nic_byte(dev, AckTimeOutReg, 0x5B);\r\n{\r\nbFollowLegacySetting = 1;\r\n}\r\nif (bFollowLegacySetting) {\r\nAcParam.longData = 0;\r\nAcParam.f.AciAifsn.f.AIFSN = 2;\r\nAcParam.f.AciAifsn.f.ACM = 0;\r\nAcParam.f.Ecw.f.ECWmin = ChnlAccessSetting->CWminIndex;\r\nAcParam.f.Ecw.f.ECWmax = ChnlAccessSetting->CWmaxIndex;\r\nAcParam.f.TXOPLimit = 0;\r\nif (ieee->current_network.Turbo_Enable == 1)\r\nAcParam.f.TXOPLimit = 0x01FF;\r\nif (ieee->iw_mode == IW_MODE_ADHOC)\r\nAcParam.f.TXOPLimit = 0x0020;\r\nfor (eACI = 0; eACI < AC_MAX; eACI++) {\r\nAcParam.f.AciAifsn.f.ACI = (u8)eACI;\r\n{\r\nPAC_PARAM pAcParam = (PAC_PARAM)(&AcParam);\r\nAC_CODING eACI;\r\nu8 u1bAIFS;\r\nu32 u4bAcParam;\r\neACI = pAcParam->f.AciAifsn.f.ACI;\r\nu1bAIFS = pAcParam->f.AciAifsn.f.AIFSN * ChnlAccessSetting->SlotTimeTimer + aSifsTime;\r\nu4bAcParam = ((((u32)(pAcParam->f.TXOPLimit)) << AC_PARAM_TXOP_LIMIT_OFFSET) |\r\n(((u32)(pAcParam->f.Ecw.f.ECWmax)) << AC_PARAM_ECW_MAX_OFFSET) |\r\n(((u32)(pAcParam->f.Ecw.f.ECWmin)) << AC_PARAM_ECW_MIN_OFFSET) |\r\n(((u32)u1bAIFS) << AC_PARAM_AIFS_OFFSET));\r\nswitch (eACI) {\r\ncase AC1_BK:\r\nbreak;\r\ncase AC0_BE:\r\nbreak;\r\ncase AC2_VI:\r\nbreak;\r\ncase AC3_VO:\r\nbreak;\r\ndefault:\r\nDMESGW("SetHwReg8185(): invalid ACI: %d !\n", eACI);\r\nbreak;\r\n}\r\n{\r\nPACI_AIFSN pAciAifsn = (PACI_AIFSN)(&pAcParam->f.AciAifsn);\r\nAC_CODING eACI = pAciAifsn->f.ACI;\r\nu8 AcmCtrl = 0;\r\nif (pAciAifsn->f.ACM) {\r\nswitch (eACI) {\r\ncase AC0_BE:\r\nAcmCtrl |= (BEQ_ACM_EN|BEQ_ACM_CTL|ACM_HW_EN);\r\nbreak;\r\ncase AC2_VI:\r\nAcmCtrl |= (VIQ_ACM_EN|VIQ_ACM_CTL|ACM_HW_EN);\r\nbreak;\r\ncase AC3_VO:\r\nAcmCtrl |= (VOQ_ACM_EN|VOQ_ACM_CTL|ACM_HW_EN);\r\nbreak;\r\ndefault:\r\nDMESGW("SetHwReg8185(): [HW_VAR_ACM_CTRL] ACM set failed: eACI is %d\n", eACI);\r\nbreak;\r\n}\r\n} else {\r\nswitch (eACI) {\r\ncase AC0_BE:\r\nAcmCtrl &= ((~BEQ_ACM_EN) & (~BEQ_ACM_CTL) & (~ACM_HW_EN));\r\nbreak;\r\ncase AC2_VI:\r\nAcmCtrl &= ((~VIQ_ACM_EN) & (~VIQ_ACM_CTL) & (~ACM_HW_EN));\r\nbreak;\r\ncase AC3_VO:\r\nAcmCtrl &= ((~VOQ_ACM_EN) & (~VOQ_ACM_CTL) & (~ACM_HW_EN));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nwrite_nic_byte(dev, ACM_CONTROL, 0);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nvoid ActSetWirelessMode8185(struct net_device *dev, u8 btWirelessMode)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nu8 btSupportedWirelessMode = GetSupportedWirelessMode8185(dev);\r\nif ((btWirelessMode & btSupportedWirelessMode) == 0) {\r\nDMESGW("ActSetWirelessMode8185(): WirelessMode(%d) is not supported (%d)!\n",\r\nbtWirelessMode, btSupportedWirelessMode);\r\nreturn;\r\n}\r\nif (btWirelessMode == WIRELESS_MODE_AUTO) {\r\nif ((btSupportedWirelessMode & WIRELESS_MODE_A)) {\r\nbtWirelessMode = WIRELESS_MODE_A;\r\n} else if (btSupportedWirelessMode & WIRELESS_MODE_G) {\r\nbtWirelessMode = WIRELESS_MODE_G;\r\n} else if ((btSupportedWirelessMode & WIRELESS_MODE_B)) {\r\nbtWirelessMode = WIRELESS_MODE_B;\r\n} else {\r\nDMESGW("ActSetWirelessMode8185(): No valid wireless mode supported, btSupportedWirelessMode(%x)!!!\n",\r\nbtSupportedWirelessMode);\r\nbtWirelessMode = WIRELESS_MODE_B;\r\n}\r\n}\r\nieee->mode = (WIRELESS_MODE)btWirelessMode;\r\nif( ieee->mode == WIRELESS_MODE_A ) {\r\nDMESG("WIRELESS_MODE_A\n");\r\n} else if( ieee->mode == WIRELESS_MODE_B ) {\r\nDMESG("WIRELESS_MODE_B\n");\r\n} else if( ieee->mode == WIRELESS_MODE_G ) {\r\nDMESG("WIRELESS_MODE_G\n");\r\n}\r\nActUpdateChannelAccessSetting( dev, ieee->mode, &priv->ChannelAccessSetting);\r\n}\r\nvoid rtl8185b_irq_enable(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\npriv->irq_enabled = 1;\r\nwrite_nic_dword(dev, IMR, priv->IntrMask);\r\n}\r\nvoid DrvIFIndicateDisassociation(struct net_device *dev, u16 reason)\r\n{\r\n}\r\nvoid MgntDisconnectIBSS(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nu8 i;\r\nDrvIFIndicateDisassociation(dev, unspec_reason);\r\nfor (i = 0; i < 6 ; i++)\r\npriv->ieee80211->current_network.bssid[i] = 0x55;\r\npriv->ieee80211->state = IEEE80211_NOLINK;\r\nieee80211_stop_send_beacons(priv->ieee80211);\r\npriv->ieee80211->link_change(dev);\r\nnotify_wx_assoc_event(priv->ieee80211);\r\n}\r\nvoid MlmeDisassociateRequest(struct net_device *dev, u8 *asSta, u8 asRsn)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nu8 i;\r\nSendDisassociation(priv->ieee80211, asSta, asRsn);\r\nif (memcmp(priv->ieee80211->current_network.bssid, asSta, 6) == 0) {\r\nDrvIFIndicateDisassociation(dev, unspec_reason);\r\nfor (i = 0; i < 6; i++)\r\npriv->ieee80211->current_network.bssid[i] = 0x22;\r\nieee80211_disassociate(priv->ieee80211);\r\n}\r\n}\r\nvoid MgntDisconnectAP(struct net_device *dev, u8 asRsn)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nMlmeDisassociateRequest(dev, priv->ieee80211->current_network.bssid, asRsn);\r\npriv->ieee80211->state = IEEE80211_NOLINK;\r\n}\r\nbool MgntDisconnect(struct net_device *dev, u8 asRsn)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nif (IS_DOT11D_ENABLE(priv->ieee80211))\r\nDot11d_Reset(priv->ieee80211);\r\nif (priv->ieee80211->state == IEEE80211_LINKED) {\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nMgntDisconnectIBSS(dev);\r\nif (priv->ieee80211->iw_mode == IW_MODE_INFRA) {\r\nMgntDisconnectAP(dev, asRsn);\r\n}\r\n}\r\nreturn true;\r\n}\r\nbool SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerState)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nbool bResult = false;\r\nif (eRFPowerState == priv->eRFPowerState)\r\nreturn bResult;\r\nbResult = SetZebraRFPowerState8185(dev, eRFPowerState);\r\nreturn bResult;\r\n}\r\nvoid HalEnableRx8185Dummy(struct net_device *dev)\r\n{\r\n}\r\nvoid HalDisableRx8185Dummy(struct net_device *dev)\r\n{\r\n}\r\nbool MgntActSet_RF_State(struct net_device *dev, RT_RF_POWER_STATE StateToSet, u32 ChangeSource)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nbool bActionAllowed = false;\r\nbool bConnectBySSID = false;\r\nRT_RF_POWER_STATE rtState;\r\nu16 RFWaitCounter = 0;\r\nunsigned long flag;\r\nwhile (true) {\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\nif (priv->RFChangeInProgress) {\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nwhile (priv->RFChangeInProgress) {\r\nRFWaitCounter++;\r\nudelay(1000);\r\nif (RFWaitCounter > 1000) {\r\nprintk("MgntActSet_RF_State(): Wait too long to set RF\n");\r\nreturn false;\r\n}\r\n}\r\n} else {\r\npriv->RFChangeInProgress = true;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nbreak;\r\n}\r\n}\r\nrtState = priv->eRFPowerState;\r\nswitch (StateToSet) {\r\ncase eRfOn:\r\npriv->RfOffReason &= (~ChangeSource);\r\nif (!priv->RfOffReason) {\r\npriv->RfOffReason = 0;\r\nbActionAllowed = true;\r\nif (rtState == eRfOff && ChangeSource >= RF_CHANGE_BY_HW && !priv->bInHctTest)\r\nbConnectBySSID = true;\r\n} else\r\n;\r\nbreak;\r\ncase eRfOff:\r\nif (priv->RfOffReason > RF_CHANGE_BY_IPS) {\r\nMgntDisconnect(dev, disas_lv_ss);\r\n}\r\npriv->RfOffReason |= ChangeSource;\r\nbActionAllowed = true;\r\nbreak;\r\ncase eRfSleep:\r\npriv->RfOffReason |= ChangeSource;\r\nbActionAllowed = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (bActionAllowed) {\r\nSetRFPowerState(dev, StateToSet);\r\nif (StateToSet == eRfOn) {\r\nHalEnableRx8185Dummy(dev);\r\nif (bConnectBySSID) {\r\n}\r\n}\r\nelse if (StateToSet == eRfOff)\r\nHalDisableRx8185Dummy(dev);\r\n}\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\npriv->RFChangeInProgress = false;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nreturn bActionAllowed;\r\n}\r\nvoid InactivePowerSave(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\npriv->bSwRfProcessing = true;\r\nMgntActSet_RF_State(dev, priv->eInactivePowerState, RF_CHANGE_BY_IPS);\r\npriv->bSwRfProcessing = false;\r\n}\r\nvoid IPSEnter(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nRT_RF_POWER_STATE rtState;\r\nif (priv->bInactivePs) {\r\nrtState = priv->eRFPowerState;\r\nif (rtState == eRfOn && !priv->bSwRfProcessing\r\n&& (priv->ieee80211->state != IEEE80211_LINKED)) {\r\npriv->eInactivePowerState = eRfOff;\r\nInactivePowerSave(dev);\r\n}\r\n}\r\n}\r\nvoid IPSLeave(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nRT_RF_POWER_STATE rtState;\r\nif (priv->bInactivePs) {\r\nrtState = priv->eRFPowerState;\r\nif ((rtState == eRfOff || rtState == eRfSleep) && (!priv->bSwRfProcessing) && priv->RfOffReason <= RF_CHANGE_BY_IPS) {\r\npriv->eInactivePowerState = eRfOn;\r\nInactivePowerSave(dev);\r\n}\r\n}\r\n}\r\nvoid rtl8185b_adapter_start(struct net_device *dev)\r\n{\r\nstruct r8180_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nu8 SupportedWirelessMode;\r\nu8 InitWirelessMode;\r\nu8 bInvalidWirelessMode = 0;\r\nu8 tmpu8;\r\nu8 btCR9346;\r\nu8 TmpU1b;\r\nu8 btPSR;\r\nwrite_nic_byte(dev, 0x24e, (BIT5|BIT6|BIT0));\r\nrtl8180_reset(dev);\r\npriv->dma_poll_mask = 0;\r\npriv->dma_poll_stop_mask = 0;\r\nHwConfigureRTL8185(dev);\r\nwrite_nic_dword(dev, MAC0, ((u32 *)dev->dev_addr)[0]);\r\nwrite_nic_word(dev, MAC4, ((u32 *)dev->dev_addr)[1] & 0xffff);\r\nwrite_nic_byte(dev, MSR, read_nic_byte(dev, MSR) & 0xf3);\r\nwrite_nic_word(dev, BcnItv, 100);\r\nwrite_nic_word(dev, AtimWnd, 2);\r\nPlatformIOWrite2Byte(dev, FEMR, 0xFFFF);\r\nwrite_nic_byte(dev, WPA_CONFIG, 0);\r\nMacConfig_85BASIC(dev);\r\nPlatformIOWrite2Byte(dev, RFSW_CTRL, 0x569a);\r\nwrite_nic_byte(dev, CR9346, 0xc0);\r\ntmpu8 = read_nic_byte(dev, CONFIG3);\r\nwrite_nic_byte(dev, CONFIG3, (tmpu8 | CONFIG3_PARM_En));\r\nwrite_nic_dword(dev, ANAPARAM2, ANAPARM2_ASIC_ON);\r\nwrite_nic_dword(dev, ANAPARAM, ANAPARM_ASIC_ON);\r\nwrite_nic_word(dev, ANAPARAM3, 0x0010);\r\nwrite_nic_byte(dev, CONFIG3, tmpu8);\r\nwrite_nic_byte(dev, CR9346, 0x00);\r\nbtCR9346 = read_nic_byte(dev, CR9346);\r\nwrite_nic_byte(dev, CR9346, (btCR9346 | 0xC0));\r\nTmpU1b = read_nic_byte(dev, CONFIG5);\r\nTmpU1b = TmpU1b & ~BIT3;\r\nwrite_nic_byte(dev, CONFIG5, TmpU1b);\r\nbtCR9346 &= ~(0xC0);\r\nwrite_nic_byte(dev, CR9346, btCR9346);\r\nbtPSR = read_nic_byte(dev, PSR);\r\nwrite_nic_byte(dev, PSR, (btPSR | BIT3));\r\nwrite_nic_word(dev, RFPinsOutput, 0x0480);\r\nSetOutputEnableOfRfPins(dev);\r\nwrite_nic_word(dev, RFPinsSelect, 0x2488);\r\nPhyConfig8185(dev);\r\nSupportedWirelessMode = GetSupportedWirelessMode8185(dev);\r\nif ((ieee->mode != WIRELESS_MODE_B) &&\r\n(ieee->mode != WIRELESS_MODE_G) &&\r\n(ieee->mode != WIRELESS_MODE_A) &&\r\n(ieee->mode != WIRELESS_MODE_AUTO)) {\r\nbInvalidWirelessMode = 1;\r\n} else {\r\nif ((ieee->mode != WIRELESS_MODE_AUTO) &&\r\n(ieee->mode & SupportedWirelessMode) == 0) {\r\nbInvalidWirelessMode = 1;\r\n}\r\n}\r\nif (bInvalidWirelessMode || ieee->mode == WIRELESS_MODE_AUTO) {\r\nif ((SupportedWirelessMode & WIRELESS_MODE_A)) {\r\nInitWirelessMode = WIRELESS_MODE_A;\r\n} else if ((SupportedWirelessMode & WIRELESS_MODE_G)) {\r\nInitWirelessMode = WIRELESS_MODE_G;\r\n} else if ((SupportedWirelessMode & WIRELESS_MODE_B)) {\r\nInitWirelessMode = WIRELESS_MODE_B;\r\n} else {\r\nDMESGW("InitializeAdapter8185(): No valid wireless mode supported, SupportedWirelessMode(%x)!!!\n",\r\nSupportedWirelessMode);\r\nInitWirelessMode = WIRELESS_MODE_B;\r\n}\r\nif (bInvalidWirelessMode)\r\nieee->mode = (WIRELESS_MODE)InitWirelessMode;\r\n} else {\r\nInitWirelessMode = ieee->mode;\r\n}\r\npriv->eRFPowerState = eRfOff;\r\npriv->RfOffReason = 0;\r\n{\r\nMgntActSet_RF_State(dev, eRfOn, 0);\r\n}\r\nif (priv->bInactivePs)\r\nMgntActSet_RF_State(dev , eRfOff, RF_CHANGE_BY_IPS);\r\nActSetWirelessMode8185(dev, (u8)(InitWirelessMode));\r\nrtl8185b_irq_enable(dev);\r\nnetif_start_queue(dev);\r\n}\r\nvoid rtl8185b_rx_enable(struct net_device *dev)\r\n{\r\nu8 cmd;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nif (dev->flags & IFF_PROMISC)\r\nDMESG("NIC in promisc mode");\r\nif (priv->ieee80211->iw_mode == IW_MODE_MONITOR || \\r\ndev->flags & IFF_PROMISC) {\r\npriv->ReceiveConfig = priv->ReceiveConfig & (~RCR_APM);\r\npriv->ReceiveConfig = priv->ReceiveConfig | RCR_AAP;\r\n}\r\nif (priv->ieee80211->iw_mode == IW_MODE_MONITOR)\r\npriv->ReceiveConfig = priv->ReceiveConfig | RCR_ACF | RCR_APWRMGT | RCR_AICV;\r\nif (priv->crcmon == 1 && priv->ieee80211->iw_mode == IW_MODE_MONITOR)\r\npriv->ReceiveConfig = priv->ReceiveConfig | RCR_ACRC32;\r\nwrite_nic_dword(dev, RCR, priv->ReceiveConfig);\r\nfix_rx_fifo(dev);\r\ncmd = read_nic_byte(dev, CMD);\r\nwrite_nic_byte(dev, CMD, cmd | (1<<CMD_RX_ENABLE_SHIFT));\r\n}\r\nvoid rtl8185b_tx_enable(struct net_device *dev)\r\n{\r\nu8 cmd;\r\nu8 byte;\r\nstruct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);\r\nwrite_nic_dword(dev, TCR, priv->TransmitConfig);\r\nbyte = read_nic_byte(dev, MSR);\r\nbyte |= MSR_LINK_ENEDCA;\r\nwrite_nic_byte(dev, MSR, byte);\r\nfix_tx_fifo(dev);\r\ncmd = read_nic_byte(dev, CMD);\r\nwrite_nic_byte(dev, CMD, cmd | (1<<CMD_TX_ENABLE_SHIFT));\r\n}
