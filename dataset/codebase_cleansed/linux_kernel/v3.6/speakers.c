static int firewave_rate_constraint(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstatic unsigned int stereo_rates[] = { 48000, 96000 };\r\nstruct snd_interval *channels =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *rate =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (snd_interval_max(channels) < 6)\r\nreturn snd_interval_list(rate, 2, stereo_rates, 0);\r\nreturn 0;\r\n}\r\nstatic int firewave_channels_constraint(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstatic const struct snd_interval all_channels = { .min = 6, .max = 6 };\r\nstruct snd_interval *rate =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nif (snd_interval_max(rate) < 48000)\r\nreturn snd_interval_refine(channels, &all_channels);\r\nreturn 0;\r\n}\r\nstatic int firewave_constraints(struct snd_pcm_runtime *runtime)\r\n{\r\nstatic unsigned int channels_list[] = { 2, 6 };\r\nstatic struct snd_pcm_hw_constraint_list channels_list_constraint = {\r\n.count = 2,\r\n.list = channels_list,\r\n};\r\nint err;\r\nruntime->hw.rates = SNDRV_PCM_RATE_32000 |\r\nSNDRV_PCM_RATE_44100 |\r\nSNDRV_PCM_RATE_48000 |\r\nSNDRV_PCM_RATE_96000;\r\nruntime->hw.channels_max = 6;\r\nerr = snd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n&channels_list_constraint);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nfirewave_rate_constraint, NULL,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nfirewave_channels_constraint, NULL,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int lacie_speakers_constraints(struct snd_pcm_runtime *runtime)\r\n{\r\nruntime->hw.rates = SNDRV_PCM_RATE_32000 |\r\nSNDRV_PCM_RATE_44100 |\r\nSNDRV_PCM_RATE_48000 |\r\nSNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000;\r\nreturn 0;\r\n}\r\nstatic int fwspk_open(struct snd_pcm_substream *substream)\r\n{\r\nstatic const struct snd_pcm_hardware hardware = {\r\n.info = SNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID |\r\nSNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER,\r\n.formats = AMDTP_OUT_PCM_FORMAT_BITS,\r\n.channels_min = 2,\r\n.channels_max = 2,\r\n.buffer_bytes_max = 4 * 1024 * 1024,\r\n.period_bytes_min = 1,\r\n.period_bytes_max = UINT_MAX,\r\n.periods_min = 1,\r\n.periods_max = UINT_MAX,\r\n};\r\nstruct fwspk *fwspk = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nruntime->hw = hardware;\r\nerr = fwspk->device_info->pcm_constraints(runtime);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_limit_hw_rates(runtime);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\n5000, UINT_MAX);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int fwspk_close(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic void fwspk_stop_stream(struct fwspk *fwspk)\r\n{\r\nif (fwspk->stream_running) {\r\namdtp_out_stream_stop(&fwspk->stream);\r\ncmp_connection_break(&fwspk->connection);\r\nfwspk->stream_running = false;\r\n}\r\n}\r\nstatic int fwspk_set_rate(struct fwspk *fwspk, unsigned int sfc)\r\n{\r\nu8 *buf;\r\nint err;\r\nbuf = kmalloc(8, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = 0x00;\r\nbuf[1] = 0xff;\r\nbuf[2] = 0x19;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x90;\r\nbuf[5] = 0x00 | sfc;\r\nbuf[6] = 0xff;\r\nbuf[7] = 0xff;\r\nerr = fcp_avc_transaction(fwspk->unit, buf, 8, buf, 8,\r\nBIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5));\r\nif (err < 0)\r\ngoto error;\r\nif (err < 6 || buf[0] != 0x09 ) {\r\ndev_err(&fwspk->unit->device, "failed to set sample rate\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nerr = 0;\r\nerror:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int fwspk_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct fwspk *fwspk = substream->private_data;\r\nint err;\r\nmutex_lock(&fwspk->mutex);\r\nfwspk_stop_stream(fwspk);\r\nmutex_unlock(&fwspk->mutex);\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\ngoto error;\r\namdtp_out_stream_set_rate(&fwspk->stream, params_rate(hw_params));\r\namdtp_out_stream_set_pcm(&fwspk->stream, params_channels(hw_params));\r\namdtp_out_stream_set_pcm_format(&fwspk->stream,\r\nparams_format(hw_params));\r\nerr = fwspk_set_rate(fwspk, fwspk->stream.sfc);\r\nif (err < 0)\r\ngoto err_buffer;\r\nreturn 0;\r\nerr_buffer:\r\nsnd_pcm_lib_free_vmalloc_buffer(substream);\r\nerror:\r\nreturn err;\r\n}\r\nstatic int fwspk_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct fwspk *fwspk = substream->private_data;\r\nmutex_lock(&fwspk->mutex);\r\nfwspk_stop_stream(fwspk);\r\nmutex_unlock(&fwspk->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int fwspk_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct fwspk *fwspk = substream->private_data;\r\nint err;\r\nmutex_lock(&fwspk->mutex);\r\nif (amdtp_out_streaming_error(&fwspk->stream))\r\nfwspk_stop_stream(fwspk);\r\nif (!fwspk->stream_running) {\r\nerr = cmp_connection_establish(&fwspk->connection,\r\namdtp_out_stream_get_max_payload(&fwspk->stream));\r\nif (err < 0)\r\ngoto err_mutex;\r\nerr = amdtp_out_stream_start(&fwspk->stream,\r\nfwspk->connection.resources.channel,\r\nfwspk->connection.speed);\r\nif (err < 0)\r\ngoto err_connection;\r\nfwspk->stream_running = true;\r\n}\r\nmutex_unlock(&fwspk->mutex);\r\namdtp_out_stream_pcm_prepare(&fwspk->stream);\r\nreturn 0;\r\nerr_connection:\r\ncmp_connection_break(&fwspk->connection);\r\nerr_mutex:\r\nmutex_unlock(&fwspk->mutex);\r\nreturn err;\r\n}\r\nstatic int fwspk_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct fwspk *fwspk = substream->private_data;\r\nstruct snd_pcm_substream *pcm;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\npcm = substream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\npcm = NULL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\namdtp_out_stream_pcm_trigger(&fwspk->stream, pcm);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t fwspk_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct fwspk *fwspk = substream->private_data;\r\nreturn amdtp_out_stream_pcm_pointer(&fwspk->stream);\r\n}\r\nstatic int fwspk_create_pcm(struct fwspk *fwspk)\r\n{\r\nstatic struct snd_pcm_ops ops = {\r\n.open = fwspk_open,\r\n.close = fwspk_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = fwspk_hw_params,\r\n.hw_free = fwspk_hw_free,\r\n.prepare = fwspk_prepare,\r\n.trigger = fwspk_trigger,\r\n.pointer = fwspk_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(fwspk->card, "OXFW970", 0, 1, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = fwspk;\r\nstrcpy(pcm->name, fwspk->device_info->short_name);\r\nfwspk->pcm = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nfwspk->pcm->ops = &ops;\r\nreturn 0;\r\n}\r\nstatic int fwspk_mute_command(struct fwspk *fwspk, bool *value,\r\nenum control_action action)\r\n{\r\nu8 *buf;\r\nu8 response_ok;\r\nint err;\r\nbuf = kmalloc(11, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (action == CTL_READ) {\r\nbuf[0] = 0x01;\r\nresponse_ok = 0x0c;\r\n} else {\r\nbuf[0] = 0x00;\r\nresponse_ok = 0x09;\r\n}\r\nbuf[1] = 0x08;\r\nbuf[2] = 0xb8;\r\nbuf[3] = 0x81;\r\nbuf[4] = fwspk->device_info->mute_fb_id;\r\nbuf[5] = 0x10;\r\nbuf[6] = 0x02;\r\nbuf[7] = 0x00;\r\nbuf[8] = 0x01;\r\nbuf[9] = 0x01;\r\nif (action == CTL_READ)\r\nbuf[10] = 0xff;\r\nelse\r\nbuf[10] = *value ? 0x70 : 0x60;\r\nerr = fcp_avc_transaction(fwspk->unit, buf, 11, buf, 11, 0x3fe);\r\nif (err < 0)\r\ngoto error;\r\nif (err < 11) {\r\ndev_err(&fwspk->unit->device, "short FCP response\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (buf[0] != response_ok) {\r\ndev_err(&fwspk->unit->device, "mute command failed\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (action == CTL_READ)\r\n*value = buf[10] == 0x70;\r\nerr = 0;\r\nerror:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int fwspk_volume_command(struct fwspk *fwspk, s16 *value,\r\nunsigned int channel,\r\nenum control_attribute attribute,\r\nenum control_action action)\r\n{\r\nu8 *buf;\r\nu8 response_ok;\r\nint err;\r\nbuf = kmalloc(12, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (action == CTL_READ) {\r\nbuf[0] = 0x01;\r\nresponse_ok = 0x0c;\r\n} else {\r\nbuf[0] = 0x00;\r\nresponse_ok = 0x09;\r\n}\r\nbuf[1] = 0x08;\r\nbuf[2] = 0xb8;\r\nbuf[3] = 0x81;\r\nbuf[4] = fwspk->device_info->volume_fb_id;\r\nbuf[5] = attribute;\r\nbuf[6] = 0x02;\r\nbuf[7] = channel;\r\nbuf[8] = 0x02;\r\nbuf[9] = 0x02;\r\nif (action == CTL_READ) {\r\nbuf[10] = 0xff;\r\nbuf[11] = 0xff;\r\n} else {\r\nbuf[10] = *value >> 8;\r\nbuf[11] = *value;\r\n}\r\nerr = fcp_avc_transaction(fwspk->unit, buf, 12, buf, 12, 0x3fe);\r\nif (err < 0)\r\ngoto error;\r\nif (err < 12) {\r\ndev_err(&fwspk->unit->device, "short FCP response\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (buf[0] != response_ok) {\r\ndev_err(&fwspk->unit->device, "volume command failed\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (action == CTL_READ)\r\n*value = (buf[10] << 8) | buf[11];\r\nerr = 0;\r\nerror:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int fwspk_mute_get(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct fwspk *fwspk = control->private_data;\r\nvalue->value.integer.value[0] = !fwspk->mute;\r\nreturn 0;\r\n}\r\nstatic int fwspk_mute_put(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct fwspk *fwspk = control->private_data;\r\nbool mute;\r\nint err;\r\nmute = !value->value.integer.value[0];\r\nif (mute == fwspk->mute)\r\nreturn 0;\r\nerr = fwspk_mute_command(fwspk, &mute, CTL_WRITE);\r\nif (err < 0)\r\nreturn err;\r\nfwspk->mute = mute;\r\nreturn 1;\r\n}\r\nstatic int fwspk_volume_info(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstruct fwspk *fwspk = control->private_data;\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = fwspk->device_info->mixer_channels;\r\ninfo->value.integer.min = fwspk->volume_min;\r\ninfo->value.integer.max = fwspk->volume_max;\r\nreturn 0;\r\n}\r\nstatic int fwspk_volume_get(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct fwspk *fwspk = control->private_data;\r\nunsigned int i;\r\nfor (i = 0; i < fwspk->device_info->mixer_channels; ++i)\r\nvalue->value.integer.value[channel_map[i]] = fwspk->volume[i];\r\nreturn 0;\r\n}\r\nstatic int fwspk_volume_put(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct fwspk *fwspk = control->private_data;\r\nunsigned int i, changed_channels;\r\nbool equal_values = true;\r\ns16 volume;\r\nint err;\r\nfor (i = 0; i < fwspk->device_info->mixer_channels; ++i) {\r\nif (value->value.integer.value[i] < fwspk->volume_min ||\r\nvalue->value.integer.value[i] > fwspk->volume_max)\r\nreturn -EINVAL;\r\nif (value->value.integer.value[i] !=\r\nvalue->value.integer.value[0])\r\nequal_values = false;\r\n}\r\nchanged_channels = 0;\r\nfor (i = 0; i < fwspk->device_info->mixer_channels; ++i)\r\nif (value->value.integer.value[channel_map[i]] !=\r\nfwspk->volume[i])\r\nchanged_channels |= 1 << (i + 1);\r\nif (equal_values && changed_channels != 0)\r\nchanged_channels = 1 << 0;\r\nfor (i = 0; i <= fwspk->device_info->mixer_channels; ++i) {\r\nvolume = value->value.integer.value[channel_map[i ? i - 1 : 0]];\r\nif (changed_channels & (1 << i)) {\r\nerr = fwspk_volume_command(fwspk, &volume, i,\r\nCTL_CURRENT, CTL_WRITE);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (i > 0)\r\nfwspk->volume[i - 1] = volume;\r\n}\r\nreturn changed_channels != 0;\r\n}\r\nstatic int fwspk_create_mixer(struct fwspk *fwspk)\r\n{\r\nstatic const struct snd_kcontrol_new controls[] = {\r\n{\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "PCM Playback Switch",\r\n.info = snd_ctl_boolean_mono_info,\r\n.get = fwspk_mute_get,\r\n.put = fwspk_mute_put,\r\n},\r\n{\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "PCM Playback Volume",\r\n.info = fwspk_volume_info,\r\n.get = fwspk_volume_get,\r\n.put = fwspk_volume_put,\r\n},\r\n};\r\nunsigned int i, first_ch;\r\nint err;\r\nerr = fwspk_volume_command(fwspk, &fwspk->volume_min,\r\n0, CTL_MIN, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nerr = fwspk_volume_command(fwspk, &fwspk->volume_max,\r\n0, CTL_MAX, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nerr = fwspk_mute_command(fwspk, &fwspk->mute, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nfirst_ch = fwspk->device_info->mixer_channels == 1 ? 0 : 1;\r\nfor (i = 0; i < fwspk->device_info->mixer_channels; ++i) {\r\nerr = fwspk_volume_command(fwspk, &fwspk->volume[i],\r\nfirst_ch + i, CTL_CURRENT, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(controls); ++i) {\r\nerr = snd_ctl_add(fwspk->card,\r\nsnd_ctl_new1(&controls[i], fwspk));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 fwspk_read_firmware_version(struct fw_unit *unit)\r\n{\r\n__be32 data;\r\nint err;\r\nerr = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,\r\nOXFORD_FIRMWARE_ID_ADDRESS, &data, 4);\r\nreturn err >= 0 ? be32_to_cpu(data) : 0;\r\n}\r\nstatic void fwspk_card_free(struct snd_card *card)\r\n{\r\nstruct fwspk *fwspk = card->private_data;\r\namdtp_out_stream_destroy(&fwspk->stream);\r\ncmp_connection_destroy(&fwspk->connection);\r\nfw_unit_put(fwspk->unit);\r\nmutex_destroy(&fwspk->mutex);\r\n}\r\nstatic const struct device_info *__devinit fwspk_detect(struct fw_device *dev)\r\n{\r\nstatic const struct device_info griffin_firewave = {\r\n.driver_name = "FireWave",\r\n.short_name = "FireWave",\r\n.long_name = "Griffin FireWave Surround",\r\n.pcm_constraints = firewave_constraints,\r\n.mixer_channels = 6,\r\n.mute_fb_id = 0x01,\r\n.volume_fb_id = 0x02,\r\n};\r\nstatic const struct device_info lacie_speakers = {\r\n.driver_name = "FWSpeakers",\r\n.short_name = "FireWire Speakers",\r\n.long_name = "LaCie FireWire Speakers",\r\n.pcm_constraints = lacie_speakers_constraints,\r\n.mixer_channels = 1,\r\n.mute_fb_id = 0x01,\r\n.volume_fb_id = 0x01,\r\n};\r\nstruct fw_csr_iterator i;\r\nint key, value;\r\nfw_csr_iterator_init(&i, dev->config_rom);\r\nwhile (fw_csr_iterator_next(&i, &key, &value))\r\nif (key == CSR_VENDOR)\r\nswitch (value) {\r\ncase VENDOR_GRIFFIN:\r\nreturn &griffin_firewave;\r\ncase VENDOR_LACIE:\r\nreturn &lacie_speakers;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __devinit fwspk_probe(struct device *unit_dev)\r\n{\r\nstruct fw_unit *unit = fw_unit(unit_dev);\r\nstruct fw_device *fw_dev = fw_parent_device(unit);\r\nstruct snd_card *card;\r\nstruct fwspk *fwspk;\r\nu32 firmware;\r\nint err;\r\nerr = snd_card_create(-1, NULL, THIS_MODULE, sizeof(*fwspk), &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, unit_dev);\r\nfwspk = card->private_data;\r\nfwspk->card = card;\r\nmutex_init(&fwspk->mutex);\r\nfwspk->unit = fw_unit_get(unit);\r\nfwspk->device_info = fwspk_detect(fw_dev);\r\nif (!fwspk->device_info) {\r\nerr = -ENODEV;\r\ngoto err_unit;\r\n}\r\nerr = cmp_connection_init(&fwspk->connection, unit, 0);\r\nif (err < 0)\r\ngoto err_unit;\r\nerr = amdtp_out_stream_init(&fwspk->stream, unit, CIP_NONBLOCKING);\r\nif (err < 0)\r\ngoto err_connection;\r\ncard->private_free = fwspk_card_free;\r\nstrcpy(card->driver, fwspk->device_info->driver_name);\r\nstrcpy(card->shortname, fwspk->device_info->short_name);\r\nfirmware = fwspk_read_firmware_version(unit);\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s (OXFW%x %04x), GUID %08x%08x at %s, S%d",\r\nfwspk->device_info->long_name,\r\nfirmware >> 20, firmware & 0xffff,\r\nfw_dev->config_rom[3], fw_dev->config_rom[4],\r\ndev_name(&unit->device), 100 << fw_dev->max_speed);\r\nstrcpy(card->mixername, "OXFW970");\r\nerr = fwspk_create_pcm(fwspk);\r\nif (err < 0)\r\ngoto error;\r\nerr = fwspk_create_mixer(fwspk);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto error;\r\ndev_set_drvdata(unit_dev, fwspk);\r\nreturn 0;\r\nerr_connection:\r\ncmp_connection_destroy(&fwspk->connection);\r\nerr_unit:\r\nfw_unit_put(fwspk->unit);\r\nmutex_destroy(&fwspk->mutex);\r\nerror:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int __devexit fwspk_remove(struct device *dev)\r\n{\r\nstruct fwspk *fwspk = dev_get_drvdata(dev);\r\namdtp_out_stream_pcm_abort(&fwspk->stream);\r\nsnd_card_disconnect(fwspk->card);\r\nmutex_lock(&fwspk->mutex);\r\nfwspk_stop_stream(fwspk);\r\nmutex_unlock(&fwspk->mutex);\r\nsnd_card_free_when_closed(fwspk->card);\r\nreturn 0;\r\n}\r\nstatic void fwspk_bus_reset(struct fw_unit *unit)\r\n{\r\nstruct fwspk *fwspk = dev_get_drvdata(&unit->device);\r\nfcp_bus_reset(fwspk->unit);\r\nif (cmp_connection_update(&fwspk->connection) < 0) {\r\namdtp_out_stream_pcm_abort(&fwspk->stream);\r\nmutex_lock(&fwspk->mutex);\r\nfwspk_stop_stream(fwspk);\r\nmutex_unlock(&fwspk->mutex);\r\nreturn;\r\n}\r\namdtp_out_stream_update(&fwspk->stream);\r\n}\r\nstatic int __init alsa_fwspk_init(void)\r\n{\r\nreturn driver_register(&fwspk_driver.driver);\r\n}\r\nstatic void __exit alsa_fwspk_exit(void)\r\n{\r\ndriver_unregister(&fwspk_driver.driver);\r\n}
