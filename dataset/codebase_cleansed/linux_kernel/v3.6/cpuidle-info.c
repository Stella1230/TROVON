static void cpuidle_cpu_output(unsigned int cpu, int verbose)\r\n{\r\nint idlestates, idlestate;\r\nchar *tmp;\r\nprintf(_ ("Analyzing CPU %d:\n"), cpu);\r\nidlestates = sysfs_get_idlestate_count(cpu);\r\nif (idlestates == 0) {\r\nprintf(_("CPU %u: No idle states\n"), cpu);\r\nreturn;\r\n} else if (idlestates <= 0) {\r\nprintf(_("CPU %u: Can't read idle state info\n"), cpu);\r\nreturn;\r\n}\r\nprintf(_("Number of idle states: %d\n"), idlestates);\r\nprintf(_("Available idle states:"));\r\nfor (idlestate = 0; idlestate < idlestates; idlestate++) {\r\ntmp = sysfs_get_idlestate_name(cpu, idlestate);\r\nif (!tmp)\r\ncontinue;\r\nprintf(" %s", tmp);\r\nfree(tmp);\r\n}\r\nprintf("\n");\r\nif (!verbose)\r\nreturn;\r\nfor (idlestate = 0; idlestate < idlestates; idlestate++) {\r\ntmp = sysfs_get_idlestate_name(cpu, idlestate);\r\nif (!tmp)\r\ncontinue;\r\nprintf("%s:\n", tmp);\r\nfree(tmp);\r\ntmp = sysfs_get_idlestate_desc(cpu, idlestate);\r\nif (!tmp)\r\ncontinue;\r\nprintf(_("Flags/Description: %s\n"), tmp);\r\nfree(tmp);\r\nprintf(_("Latency: %lu\n"),\r\nsysfs_get_idlestate_latency(cpu, idlestate));\r\nprintf(_("Usage: %lu\n"),\r\nsysfs_get_idlestate_usage(cpu, idlestate));\r\nprintf(_("Duration: %llu\n"),\r\nsysfs_get_idlestate_time(cpu, idlestate));\r\n}\r\nprintf("\n");\r\n}\r\nstatic void cpuidle_general_output(void)\r\n{\r\nchar *tmp;\r\ntmp = sysfs_get_cpuidle_driver();\r\nif (!tmp) {\r\nprintf(_("Could not determine cpuidle driver\n"));\r\nreturn;\r\n}\r\nprintf(_("CPUidle driver: %s\n"), tmp);\r\nfree(tmp);\r\ntmp = sysfs_get_cpuidle_governor();\r\nif (!tmp) {\r\nprintf(_("Could not determine cpuidle governor\n"));\r\nreturn;\r\n}\r\nprintf(_("CPUidle governor: %s\n"), tmp);\r\nfree(tmp);\r\n}\r\nstatic void proc_cpuidle_cpu_output(unsigned int cpu)\r\n{\r\nlong max_allowed_cstate = 2000000000;\r\nint cstates, cstate;\r\ncstates = sysfs_get_idlestate_count(cpu);\r\nif (cstates == 0) {\r\n} else if (cstates <= 0) {\r\nprintf(_("CPU %u: Can't read C-state info\n"), cpu);\r\nreturn;\r\n}\r\nprintf(_("active state: C0\n"));\r\nprintf(_("max_cstate: C%u\n"), cstates-1);\r\nprintf(_("maximum allowed latency: %lu usec\n"), max_allowed_cstate);\r\nprintf(_("states:\t\n"));\r\nfor (cstate = 1; cstate < cstates; cstate++) {\r\nprintf(_(" C%d: "\r\n"type[C%d] "), cstate, cstate);\r\nprintf(_("promotion[--] demotion[--] "));\r\nprintf(_("latency[%03lu] "),\r\nsysfs_get_idlestate_latency(cpu, cstate));\r\nprintf(_("usage[%08lu] "),\r\nsysfs_get_idlestate_usage(cpu, cstate));\r\nprintf(_("duration[%020Lu] \n"),\r\nsysfs_get_idlestate_time(cpu, cstate));\r\n}\r\n}\r\nstatic inline void cpuidle_exit(int fail)\r\n{\r\nexit(EXIT_FAILURE);\r\n}\r\nint cmd_idle_info(int argc, char **argv)\r\n{\r\nextern char *optarg;\r\nextern int optind, opterr, optopt;\r\nint ret = 0, cont = 1, output_param = 0, verbose = 1;\r\nunsigned int cpu = 0;\r\ndo {\r\nret = getopt_long(argc, argv, "os", info_opts, NULL);\r\nif (ret == -1)\r\nbreak;\r\nswitch (ret) {\r\ncase '?':\r\noutput_param = '?';\r\ncont = 0;\r\nbreak;\r\ncase 's':\r\nverbose = 0;\r\nbreak;\r\ncase -1:\r\ncont = 0;\r\nbreak;\r\ncase 'o':\r\nif (output_param) {\r\noutput_param = -1;\r\ncont = 0;\r\nbreak;\r\n}\r\noutput_param = ret;\r\nbreak;\r\n}\r\n} while (cont);\r\nswitch (output_param) {\r\ncase -1:\r\nprintf(_("You can't specify more than one "\r\n"output-specific argument\n"));\r\ncpuidle_exit(EXIT_FAILURE);\r\ncase '?':\r\nprintf(_("invalid or unknown argument\n"));\r\ncpuidle_exit(EXIT_FAILURE);\r\n}\r\nif (bitmask_isallclear(cpus_chosen))\r\nbitmask_setbit(cpus_chosen, 0);\r\nif (output_param == 0)\r\ncpuidle_general_output();\r\nfor (cpu = bitmask_first(cpus_chosen);\r\ncpu <= bitmask_last(cpus_chosen); cpu++) {\r\nif (!bitmask_isbitset(cpus_chosen, cpu) ||\r\ncpufreq_cpu_exists(cpu))\r\ncontinue;\r\nswitch (output_param) {\r\ncase 'o':\r\nproc_cpuidle_cpu_output(cpu);\r\nbreak;\r\ncase 0:\r\nprintf("\n");\r\ncpuidle_cpu_output(cpu, verbose);\r\nbreak;\r\n}\r\n}\r\nreturn EXIT_SUCCESS;\r\n}
