static void rose_set_lockdep_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_unused)\r\n{\r\nlockdep_set_class(&txq->_xmit_lock, &rose_netdev_xmit_lock_key);\r\n}\r\nstatic void rose_set_lockdep_key(struct net_device *dev)\r\n{\r\nlockdep_set_class(&dev->addr_list_lock, &rose_netdev_addr_lock_key);\r\nnetdev_for_each_tx_queue(dev, rose_set_lockdep_one, NULL);\r\n}\r\nchar *rose2asc(char *buf, const rose_address *addr)\r\n{\r\nif (addr->rose_addr[0] == 0x00 && addr->rose_addr[1] == 0x00 &&\r\naddr->rose_addr[2] == 0x00 && addr->rose_addr[3] == 0x00 &&\r\naddr->rose_addr[4] == 0x00) {\r\nstrcpy(buf, "*");\r\n} else {\r\nsprintf(buf, "%02X%02X%02X%02X%02X", addr->rose_addr[0] & 0xFF,\r\naddr->rose_addr[1] & 0xFF,\r\naddr->rose_addr[2] & 0xFF,\r\naddr->rose_addr[3] & 0xFF,\r\naddr->rose_addr[4] & 0xFF);\r\n}\r\nreturn buf;\r\n}\r\nint rosecmp(rose_address *addr1, rose_address *addr2)\r\n{\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\nif (addr1->rose_addr[i] != addr2->rose_addr[i])\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint rosecmpm(rose_address *addr1, rose_address *addr2, unsigned short mask)\r\n{\r\nunsigned int i, j;\r\nif (mask > 10)\r\nreturn 1;\r\nfor (i = 0; i < mask; i++) {\r\nj = i / 2;\r\nif ((i % 2) != 0) {\r\nif ((addr1->rose_addr[j] & 0x0F) != (addr2->rose_addr[j] & 0x0F))\r\nreturn 1;\r\n} else {\r\nif ((addr1->rose_addr[j] & 0xF0) != (addr2->rose_addr[j] & 0xF0))\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rose_remove_socket(struct sock *sk)\r\n{\r\nspin_lock_bh(&rose_list_lock);\r\nsk_del_node_init(sk);\r\nspin_unlock_bh(&rose_list_lock);\r\n}\r\nvoid rose_kill_by_neigh(struct rose_neigh *neigh)\r\n{\r\nstruct sock *s;\r\nstruct hlist_node *node;\r\nspin_lock_bh(&rose_list_lock);\r\nsk_for_each(s, node, &rose_list) {\r\nstruct rose_sock *rose = rose_sk(s);\r\nif (rose->neighbour == neigh) {\r\nrose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);\r\nrose->neighbour->use--;\r\nrose->neighbour = NULL;\r\n}\r\n}\r\nspin_unlock_bh(&rose_list_lock);\r\n}\r\nstatic void rose_kill_by_device(struct net_device *dev)\r\n{\r\nstruct sock *s;\r\nstruct hlist_node *node;\r\nspin_lock_bh(&rose_list_lock);\r\nsk_for_each(s, node, &rose_list) {\r\nstruct rose_sock *rose = rose_sk(s);\r\nif (rose->device == dev) {\r\nrose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);\r\nrose->neighbour->use--;\r\nrose->device = NULL;\r\n}\r\n}\r\nspin_unlock_bh(&rose_list_lock);\r\n}\r\nstatic int rose_device_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)ptr;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (event != NETDEV_DOWN)\r\nreturn NOTIFY_DONE;\r\nswitch (dev->type) {\r\ncase ARPHRD_ROSE:\r\nrose_kill_by_device(dev);\r\nbreak;\r\ncase ARPHRD_AX25:\r\nrose_link_device_down(dev);\r\nrose_rt_device_down(dev);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void rose_insert_socket(struct sock *sk)\r\n{\r\nspin_lock_bh(&rose_list_lock);\r\nsk_add_node(sk, &rose_list);\r\nspin_unlock_bh(&rose_list_lock);\r\n}\r\nstatic struct sock *rose_find_listener(rose_address *addr, ax25_address *call)\r\n{\r\nstruct sock *s;\r\nstruct hlist_node *node;\r\nspin_lock_bh(&rose_list_lock);\r\nsk_for_each(s, node, &rose_list) {\r\nstruct rose_sock *rose = rose_sk(s);\r\nif (!rosecmp(&rose->source_addr, addr) &&\r\n!ax25cmp(&rose->source_call, call) &&\r\n!rose->source_ndigis && s->sk_state == TCP_LISTEN)\r\ngoto found;\r\n}\r\nsk_for_each(s, node, &rose_list) {\r\nstruct rose_sock *rose = rose_sk(s);\r\nif (!rosecmp(&rose->source_addr, addr) &&\r\n!ax25cmp(&rose->source_call, &null_ax25_address) &&\r\ns->sk_state == TCP_LISTEN)\r\ngoto found;\r\n}\r\ns = NULL;\r\nfound:\r\nspin_unlock_bh(&rose_list_lock);\r\nreturn s;\r\n}\r\nstruct sock *rose_find_socket(unsigned int lci, struct rose_neigh *neigh)\r\n{\r\nstruct sock *s;\r\nstruct hlist_node *node;\r\nspin_lock_bh(&rose_list_lock);\r\nsk_for_each(s, node, &rose_list) {\r\nstruct rose_sock *rose = rose_sk(s);\r\nif (rose->lci == lci && rose->neighbour == neigh)\r\ngoto found;\r\n}\r\ns = NULL;\r\nfound:\r\nspin_unlock_bh(&rose_list_lock);\r\nreturn s;\r\n}\r\nunsigned int rose_new_lci(struct rose_neigh *neigh)\r\n{\r\nint lci;\r\nif (neigh->dce_mode) {\r\nfor (lci = 1; lci <= sysctl_rose_maximum_vcs; lci++)\r\nif (rose_find_socket(lci, neigh) == NULL && rose_route_free_lci(lci, neigh) == NULL)\r\nreturn lci;\r\n} else {\r\nfor (lci = sysctl_rose_maximum_vcs; lci > 0; lci--)\r\nif (rose_find_socket(lci, neigh) == NULL && rose_route_free_lci(lci, neigh) == NULL)\r\nreturn lci;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rose_destroy_timer(unsigned long data)\r\n{\r\nrose_destroy_socket((struct sock *)data);\r\n}\r\nvoid rose_destroy_socket(struct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\nrose_remove_socket(sk);\r\nrose_stop_heartbeat(sk);\r\nrose_stop_idletimer(sk);\r\nrose_stop_timer(sk);\r\nrose_clear_queues(sk);\r\nwhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\r\nif (skb->sk != sk) {\r\nsock_set_flag(skb->sk, SOCK_DEAD);\r\nrose_start_heartbeat(skb->sk);\r\nrose_sk(skb->sk)->state = ROSE_STATE_0;\r\n}\r\nkfree_skb(skb);\r\n}\r\nif (sk_has_allocations(sk)) {\r\nsetup_timer(&sk->sk_timer, rose_destroy_timer,\r\n(unsigned long)sk);\r\nsk->sk_timer.expires = jiffies + 10 * HZ;\r\nadd_timer(&sk->sk_timer);\r\n} else\r\nsock_put(sk);\r\n}\r\nstatic int rose_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nint opt;\r\nif (level != SOL_ROSE)\r\nreturn -ENOPROTOOPT;\r\nif (optlen < sizeof(int))\r\nreturn -EINVAL;\r\nif (get_user(opt, (int __user *)optval))\r\nreturn -EFAULT;\r\nswitch (optname) {\r\ncase ROSE_DEFER:\r\nrose->defer = opt ? 1 : 0;\r\nreturn 0;\r\ncase ROSE_T1:\r\nif (opt < 1)\r\nreturn -EINVAL;\r\nrose->t1 = opt * HZ;\r\nreturn 0;\r\ncase ROSE_T2:\r\nif (opt < 1)\r\nreturn -EINVAL;\r\nrose->t2 = opt * HZ;\r\nreturn 0;\r\ncase ROSE_T3:\r\nif (opt < 1)\r\nreturn -EINVAL;\r\nrose->t3 = opt * HZ;\r\nreturn 0;\r\ncase ROSE_HOLDBACK:\r\nif (opt < 1)\r\nreturn -EINVAL;\r\nrose->hb = opt * HZ;\r\nreturn 0;\r\ncase ROSE_IDLE:\r\nif (opt < 0)\r\nreturn -EINVAL;\r\nrose->idle = opt * 60 * HZ;\r\nreturn 0;\r\ncase ROSE_QBITINCL:\r\nrose->qbitincl = opt ? 1 : 0;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\n}\r\nstatic int rose_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nint val = 0;\r\nint len;\r\nif (level != SOL_ROSE)\r\nreturn -ENOPROTOOPT;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nif (len < 0)\r\nreturn -EINVAL;\r\nswitch (optname) {\r\ncase ROSE_DEFER:\r\nval = rose->defer;\r\nbreak;\r\ncase ROSE_T1:\r\nval = rose->t1 / HZ;\r\nbreak;\r\ncase ROSE_T2:\r\nval = rose->t2 / HZ;\r\nbreak;\r\ncase ROSE_T3:\r\nval = rose->t3 / HZ;\r\nbreak;\r\ncase ROSE_HOLDBACK:\r\nval = rose->hb / HZ;\r\nbreak;\r\ncase ROSE_IDLE:\r\nval = rose->idle / (60 * HZ);\r\nbreak;\r\ncase ROSE_QBITINCL:\r\nval = rose->qbitincl;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nlen = min_t(unsigned int, len, sizeof(int));\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nreturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\r\n}\r\nstatic int rose_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk->sk_state != TCP_LISTEN) {\r\nstruct rose_sock *rose = rose_sk(sk);\r\nrose->dest_ndigis = 0;\r\nmemset(&rose->dest_addr, 0, ROSE_ADDR_LEN);\r\nmemset(&rose->dest_call, 0, AX25_ADDR_LEN);\r\nmemset(rose->dest_digis, 0, AX25_ADDR_LEN * ROSE_MAX_DIGIS);\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_state = TCP_LISTEN;\r\nreturn 0;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int rose_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nstruct rose_sock *rose;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\nif (sock->type != SOCK_SEQPACKET || protocol != 0)\r\nreturn -ESOCKTNOSUPPORT;\r\nsk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);\r\nif (sk == NULL)\r\nreturn -ENOMEM;\r\nrose = rose_sk(sk);\r\nsock_init_data(sock, sk);\r\nskb_queue_head_init(&rose->ack_queue);\r\n#ifdef M_BIT\r\nskb_queue_head_init(&rose->frag_queue);\r\nrose->fraglen = 0;\r\n#endif\r\nsock->ops = &rose_proto_ops;\r\nsk->sk_protocol = protocol;\r\ninit_timer(&rose->timer);\r\ninit_timer(&rose->idletimer);\r\nrose->t1 = msecs_to_jiffies(sysctl_rose_call_request_timeout);\r\nrose->t2 = msecs_to_jiffies(sysctl_rose_reset_request_timeout);\r\nrose->t3 = msecs_to_jiffies(sysctl_rose_clear_request_timeout);\r\nrose->hb = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);\r\nrose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);\r\nrose->state = ROSE_STATE_0;\r\nreturn 0;\r\n}\r\nstatic struct sock *rose_make_new(struct sock *osk)\r\n{\r\nstruct sock *sk;\r\nstruct rose_sock *rose, *orose;\r\nif (osk->sk_type != SOCK_SEQPACKET)\r\nreturn NULL;\r\nsk = sk_alloc(sock_net(osk), PF_ROSE, GFP_ATOMIC, &rose_proto);\r\nif (sk == NULL)\r\nreturn NULL;\r\nrose = rose_sk(sk);\r\nsock_init_data(NULL, sk);\r\nskb_queue_head_init(&rose->ack_queue);\r\n#ifdef M_BIT\r\nskb_queue_head_init(&rose->frag_queue);\r\nrose->fraglen = 0;\r\n#endif\r\nsk->sk_type = osk->sk_type;\r\nsk->sk_priority = osk->sk_priority;\r\nsk->sk_protocol = osk->sk_protocol;\r\nsk->sk_rcvbuf = osk->sk_rcvbuf;\r\nsk->sk_sndbuf = osk->sk_sndbuf;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsock_copy_flags(sk, osk);\r\ninit_timer(&rose->timer);\r\ninit_timer(&rose->idletimer);\r\norose = rose_sk(osk);\r\nrose->t1 = orose->t1;\r\nrose->t2 = orose->t2;\r\nrose->t3 = orose->t3;\r\nrose->hb = orose->hb;\r\nrose->idle = orose->idle;\r\nrose->defer = orose->defer;\r\nrose->device = orose->device;\r\nrose->qbitincl = orose->qbitincl;\r\nreturn sk;\r\n}\r\nstatic int rose_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose;\r\nif (sk == NULL) return 0;\r\nsock_hold(sk);\r\nsock_orphan(sk);\r\nlock_sock(sk);\r\nrose = rose_sk(sk);\r\nswitch (rose->state) {\r\ncase ROSE_STATE_0:\r\nrelease_sock(sk);\r\nrose_disconnect(sk, 0, -1, -1);\r\nlock_sock(sk);\r\nrose_destroy_socket(sk);\r\nbreak;\r\ncase ROSE_STATE_2:\r\nrose->neighbour->use--;\r\nrelease_sock(sk);\r\nrose_disconnect(sk, 0, -1, -1);\r\nlock_sock(sk);\r\nrose_destroy_socket(sk);\r\nbreak;\r\ncase ROSE_STATE_1:\r\ncase ROSE_STATE_3:\r\ncase ROSE_STATE_4:\r\ncase ROSE_STATE_5:\r\nrose_clear_queues(sk);\r\nrose_stop_idletimer(sk);\r\nrose_write_internal(sk, ROSE_CLEAR_REQUEST);\r\nrose_start_t3timer(sk);\r\nrose->state = ROSE_STATE_2;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\nsock_set_flag(sk, SOCK_DESTROY);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsock->sk = NULL;\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int rose_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\r\nstruct net_device *dev;\r\nax25_address *source;\r\nax25_uid_assoc *user;\r\nint n;\r\nif (!sock_flag(sk, SOCK_ZAPPED))\r\nreturn -EINVAL;\r\nif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\r\nreturn -EINVAL;\r\nif (addr->srose_family != AF_ROSE)\r\nreturn -EINVAL;\r\nif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\r\nreturn -EINVAL;\r\nif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\r\nreturn -EINVAL;\r\nif ((dev = rose_dev_get(&addr->srose_addr)) == NULL)\r\nreturn -EADDRNOTAVAIL;\r\nsource = &addr->srose_call;\r\nuser = ax25_findbyuid(current_euid());\r\nif (user) {\r\nrose->source_call = user->call;\r\nax25_uid_put(user);\r\n} else {\r\nif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE))\r\nreturn -EACCES;\r\nrose->source_call = *source;\r\n}\r\nrose->source_addr = addr->srose_addr;\r\nrose->device = dev;\r\nrose->source_ndigis = addr->srose_ndigis;\r\nif (addr_len == sizeof(struct full_sockaddr_rose)) {\r\nstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\r\nfor (n = 0 ; n < addr->srose_ndigis ; n++)\r\nrose->source_digis[n] = full_addr->srose_digis[n];\r\n} else {\r\nif (rose->source_ndigis == 1) {\r\nrose->source_digis[0] = addr->srose_digi;\r\n}\r\n}\r\nrose_insert_socket(sk);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nreturn 0;\r\n}\r\nstatic int rose_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\r\nunsigned char cause, diagnostic;\r\nstruct net_device *dev;\r\nax25_uid_assoc *user;\r\nint n, err = 0;\r\nif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\r\nreturn -EINVAL;\r\nif (addr->srose_family != AF_ROSE)\r\nreturn -EINVAL;\r\nif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\r\nreturn -EINVAL;\r\nif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\r\nreturn -EINVAL;\r\nif ((rose->source_ndigis + addr->srose_ndigis) > ROSE_MAX_DIGIS)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\r\nsock->state = SS_CONNECTED;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\r\nsock->state = SS_UNCONNECTED;\r\nerr = -ECONNREFUSED;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state == TCP_ESTABLISHED) {\r\nerr = -EISCONN;\r\ngoto out_release;\r\n}\r\nsk->sk_state = TCP_CLOSE;\r\nsock->state = SS_UNCONNECTED;\r\nrose->neighbour = rose_get_neigh(&addr->srose_addr, &cause,\r\n&diagnostic, 0);\r\nif (!rose->neighbour) {\r\nerr = -ENETUNREACH;\r\ngoto out_release;\r\n}\r\nrose->lci = rose_new_lci(rose->neighbour);\r\nif (!rose->lci) {\r\nerr = -ENETUNREACH;\r\ngoto out_release;\r\n}\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nif ((dev = rose_dev_first()) == NULL) {\r\nerr = -ENETUNREACH;\r\ngoto out_release;\r\n}\r\nuser = ax25_findbyuid(current_euid());\r\nif (!user) {\r\nerr = -EINVAL;\r\ngoto out_release;\r\n}\r\nmemcpy(&rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);\r\nrose->source_call = user->call;\r\nrose->device = dev;\r\nax25_uid_put(user);\r\nrose_insert_socket(sk);\r\n}\r\nrose->dest_addr = addr->srose_addr;\r\nrose->dest_call = addr->srose_call;\r\nrose->rand = ((long)rose & 0xFFFF) + rose->lci;\r\nrose->dest_ndigis = addr->srose_ndigis;\r\nif (addr_len == sizeof(struct full_sockaddr_rose)) {\r\nstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\r\nfor (n = 0 ; n < addr->srose_ndigis ; n++)\r\nrose->dest_digis[n] = full_addr->srose_digis[n];\r\n} else {\r\nif (rose->dest_ndigis == 1) {\r\nrose->dest_digis[0] = addr->srose_digi;\r\n}\r\n}\r\nsock->state = SS_CONNECTING;\r\nsk->sk_state = TCP_SYN_SENT;\r\nrose->state = ROSE_STATE_1;\r\nrose->neighbour->use++;\r\nrose_write_internal(sk, ROSE_CALL_REQUEST);\r\nrose_start_heartbeat(sk);\r\nrose_start_t1timer(sk);\r\nif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\r\nerr = -EINPROGRESS;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state == TCP_SYN_SENT) {\r\nDEFINE_WAIT(wait);\r\nfor (;;) {\r\nprepare_to_wait(sk_sleep(sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\nif (sk->sk_state != TCP_SYN_SENT)\r\nbreak;\r\nif (!signal_pending(current)) {\r\nrelease_sock(sk);\r\nschedule();\r\nlock_sock(sk);\r\ncontinue;\r\n}\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto out_release;\r\n}\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nsock->state = SS_UNCONNECTED;\r\nerr = sock_error(sk);\r\ngoto out_release;\r\n}\r\nsock->state = SS_CONNECTED;\r\nout_release:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int rose_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sock *newsk;\r\nDEFINE_WAIT(wait);\r\nstruct sock *sk;\r\nint err = 0;\r\nif ((sk = sock->sk) == NULL)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_type != SOCK_SEQPACKET) {\r\nerr = -EOPNOTSUPP;\r\ngoto out_release;\r\n}\r\nif (sk->sk_state != TCP_LISTEN) {\r\nerr = -EINVAL;\r\ngoto out_release;\r\n}\r\nfor (;;) {\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nif (skb)\r\nbreak;\r\nif (flags & O_NONBLOCK) {\r\nerr = -EWOULDBLOCK;\r\nbreak;\r\n}\r\nif (!signal_pending(current)) {\r\nrelease_sock(sk);\r\nschedule();\r\nlock_sock(sk);\r\ncontinue;\r\n}\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (err)\r\ngoto out_release;\r\nnewsk = skb->sk;\r\nsock_graft(newsk, newsock);\r\nskb->sk = NULL;\r\nkfree_skb(skb);\r\nsk->sk_ack_backlog--;\r\nout_release:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int rose_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nint n;\r\nmemset(srose, 0, sizeof(*srose));\r\nif (peer != 0) {\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -ENOTCONN;\r\nsrose->srose_family = AF_ROSE;\r\nsrose->srose_addr = rose->dest_addr;\r\nsrose->srose_call = rose->dest_call;\r\nsrose->srose_ndigis = rose->dest_ndigis;\r\nfor (n = 0; n < rose->dest_ndigis; n++)\r\nsrose->srose_digis[n] = rose->dest_digis[n];\r\n} else {\r\nsrose->srose_family = AF_ROSE;\r\nsrose->srose_addr = rose->source_addr;\r\nsrose->srose_call = rose->source_call;\r\nsrose->srose_ndigis = rose->source_ndigis;\r\nfor (n = 0; n < rose->source_ndigis; n++)\r\nsrose->srose_digis[n] = rose->source_digis[n];\r\n}\r\n*uaddr_len = sizeof(struct full_sockaddr_rose);\r\nreturn 0;\r\n}\r\nint rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct rose_neigh *neigh, unsigned int lci)\r\n{\r\nstruct sock *sk;\r\nstruct sock *make;\r\nstruct rose_sock *make_rose;\r\nstruct rose_facilities_struct facilities;\r\nint n;\r\nskb->sk = NULL;\r\nmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\r\nif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\r\nskb->len - ROSE_CALL_REQ_FACILITIES_OFF,\r\n&facilities)) {\r\nrose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76);\r\nreturn 0;\r\n}\r\nsk = rose_find_listener(&facilities.source_addr, &facilities.source_call);\r\nif (sk == NULL || sk_acceptq_is_full(sk) ||\r\n(make = rose_make_new(sk)) == NULL) {\r\nrose_transmit_clear_request(neigh, lci, ROSE_NETWORK_CONGESTION, 120);\r\nreturn 0;\r\n}\r\nskb->sk = make;\r\nmake->sk_state = TCP_ESTABLISHED;\r\nmake_rose = rose_sk(make);\r\nmake_rose->lci = lci;\r\nmake_rose->dest_addr = facilities.dest_addr;\r\nmake_rose->dest_call = facilities.dest_call;\r\nmake_rose->dest_ndigis = facilities.dest_ndigis;\r\nfor (n = 0 ; n < facilities.dest_ndigis ; n++)\r\nmake_rose->dest_digis[n] = facilities.dest_digis[n];\r\nmake_rose->source_addr = facilities.source_addr;\r\nmake_rose->source_call = facilities.source_call;\r\nmake_rose->source_ndigis = facilities.source_ndigis;\r\nfor (n = 0 ; n < facilities.source_ndigis ; n++)\r\nmake_rose->source_digis[n]= facilities.source_digis[n];\r\nmake_rose->neighbour = neigh;\r\nmake_rose->device = dev;\r\nmake_rose->facilities = facilities;\r\nmake_rose->neighbour->use++;\r\nif (rose_sk(sk)->defer) {\r\nmake_rose->state = ROSE_STATE_5;\r\n} else {\r\nrose_write_internal(make, ROSE_CALL_ACCEPTED);\r\nmake_rose->state = ROSE_STATE_3;\r\nrose_start_idletimer(make);\r\n}\r\nmake_rose->condition = 0x00;\r\nmake_rose->vs = 0;\r\nmake_rose->va = 0;\r\nmake_rose->vr = 0;\r\nmake_rose->vl = 0;\r\nsk->sk_ack_backlog++;\r\nrose_insert_socket(make);\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nrose_start_heartbeat(make);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk, skb->len);\r\nreturn 1;\r\n}\r\nstatic int rose_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nstruct sockaddr_rose *usrose = (struct sockaddr_rose *)msg->msg_name;\r\nint err;\r\nstruct full_sockaddr_rose srose;\r\nstruct sk_buff *skb;\r\nunsigned char *asmptr;\r\nint n, size, qbit = 0;\r\nif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\r\nreturn -EINVAL;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\nreturn -EADDRNOTAVAIL;\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nsend_sig(SIGPIPE, current, 0);\r\nreturn -EPIPE;\r\n}\r\nif (rose->neighbour == NULL || rose->device == NULL)\r\nreturn -ENETUNREACH;\r\nif (usrose != NULL) {\r\nif (msg->msg_namelen != sizeof(struct sockaddr_rose) && msg->msg_namelen != sizeof(struct full_sockaddr_rose))\r\nreturn -EINVAL;\r\nmemset(&srose, 0, sizeof(struct full_sockaddr_rose));\r\nmemcpy(&srose, usrose, msg->msg_namelen);\r\nif (rosecmp(&rose->dest_addr, &srose.srose_addr) != 0 ||\r\nax25cmp(&rose->dest_call, &srose.srose_call) != 0)\r\nreturn -EISCONN;\r\nif (srose.srose_ndigis != rose->dest_ndigis)\r\nreturn -EISCONN;\r\nif (srose.srose_ndigis == rose->dest_ndigis) {\r\nfor (n = 0 ; n < srose.srose_ndigis ; n++)\r\nif (ax25cmp(&rose->dest_digis[n],\r\n&srose.srose_digis[n]))\r\nreturn -EISCONN;\r\n}\r\nif (srose.srose_family != AF_ROSE)\r\nreturn -EINVAL;\r\n} else {\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -ENOTCONN;\r\nsrose.srose_family = AF_ROSE;\r\nsrose.srose_addr = rose->dest_addr;\r\nsrose.srose_call = rose->dest_call;\r\nsrose.srose_ndigis = rose->dest_ndigis;\r\nfor (n = 0 ; n < rose->dest_ndigis ; n++)\r\nsrose.srose_digis[n] = rose->dest_digis[n];\r\n}\r\nif (len > 65535)\r\nreturn -EMSGSIZE;\r\nsize = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\r\nif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\r\nreturn err;\r\nskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN);\r\nskb_reset_transport_header(skb);\r\nskb_put(skb, len);\r\nerr = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\r\nif (err) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nif (rose->qbitincl) {\r\nqbit = skb->data[0];\r\nskb_pull(skb, 1);\r\n}\r\nasmptr = skb_push(skb, ROSE_MIN_LEN);\r\nasmptr[0] = ((rose->lci >> 8) & 0x0F) | ROSE_GFI;\r\nasmptr[1] = (rose->lci >> 0) & 0xFF;\r\nasmptr[2] = ROSE_DATA;\r\nif (qbit)\r\nasmptr[0] |= ROSE_Q_BIT;\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nkfree_skb(skb);\r\nreturn -ENOTCONN;\r\n}\r\n#ifdef M_BIT\r\n#define ROSE_PACLEN (256-ROSE_MIN_LEN)\r\nif (skb->len - ROSE_MIN_LEN > ROSE_PACLEN) {\r\nunsigned char header[ROSE_MIN_LEN];\r\nstruct sk_buff *skbn;\r\nint frontlen;\r\nint lg;\r\nskb_copy_from_linear_data(skb, header, ROSE_MIN_LEN);\r\nskb_pull(skb, ROSE_MIN_LEN);\r\nfrontlen = skb_headroom(skb);\r\nwhile (skb->len > 0) {\r\nif ((skbn = sock_alloc_send_skb(sk, frontlen + ROSE_PACLEN, 0, &err)) == NULL) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nskbn->sk = sk;\r\nskbn->free = 1;\r\nskbn->arp = 1;\r\nskb_reserve(skbn, frontlen);\r\nlg = (ROSE_PACLEN > skb->len) ? skb->len : ROSE_PACLEN;\r\nskb_copy_from_linear_data(skb, skb_put(skbn, lg), lg);\r\nskb_pull(skb, lg);\r\nskb_push(skbn, ROSE_MIN_LEN);\r\nskb_copy_to_linear_data(skbn, header, ROSE_MIN_LEN);\r\nif (skb->len > 0)\r\nskbn->data[2] |= M_BIT;\r\nskb_queue_tail(&sk->sk_write_queue, skbn);\r\n}\r\nskb->free = 1;\r\nkfree_skb(skb);\r\n} else {\r\nskb_queue_tail(&sk->sk_write_queue, skb);\r\n}\r\n#else\r\nskb_queue_tail(&sk->sk_write_queue, skb);\r\n#endif\r\nrose_kick(sk);\r\nreturn len;\r\n}\r\nstatic int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\r\nsize_t copied;\r\nunsigned char *asmptr;\r\nstruct sk_buff *skb;\r\nint n, er, qbit;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -ENOTCONN;\r\nif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\r\nreturn er;\r\nqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\r\nskb_pull(skb, ROSE_MIN_LEN);\r\nif (rose->qbitincl) {\r\nasmptr = skb_push(skb, 1);\r\n*asmptr = qbit;\r\n}\r\nskb_reset_transport_header(skb);\r\ncopied = skb->len;\r\nif (copied > size) {\r\ncopied = size;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (srose != NULL) {\r\nsrose->srose_family = AF_ROSE;\r\nsrose->srose_addr = rose->dest_addr;\r\nsrose->srose_call = rose->dest_call;\r\nsrose->srose_ndigis = rose->dest_ndigis;\r\nif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\r\nstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\r\nfor (n = 0 ; n < rose->dest_ndigis ; n++)\r\nfull_srose->srose_digis[n] = rose->dest_digis[n];\r\nmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\r\n} else {\r\nif (rose->dest_ndigis >= 1) {\r\nsrose->srose_ndigis = 1;\r\nsrose->srose_digi = rose->dest_digis[0];\r\n}\r\nmsg->msg_namelen = sizeof(struct sockaddr_rose);\r\n}\r\n}\r\nskb_free_datagram(sk, skb);\r\nreturn copied;\r\n}\r\nstatic int rose_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rose_sock *rose = rose_sk(sk);\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase TIOCOUTQ: {\r\nlong amount;\r\namount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nreturn put_user(amount, (unsigned int __user *) argp);\r\n}\r\ncase TIOCINQ: {\r\nstruct sk_buff *skb;\r\nlong amount = 0L;\r\nif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\r\namount = skb->len;\r\nreturn put_user(amount, (unsigned int __user *) argp);\r\n}\r\ncase SIOCGSTAMP:\r\nreturn sock_get_timestamp(sk, (struct timeval __user *) argp);\r\ncase SIOCGSTAMPNS:\r\nreturn sock_get_timestampns(sk, (struct timespec __user *) argp);\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\ncase SIOCGIFMETRIC:\r\ncase SIOCSIFMETRIC:\r\nreturn -EINVAL;\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\ncase SIOCRSCLRRT:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn rose_rt_ioctl(cmd, argp);\r\ncase SIOCRSGCAUSE: {\r\nstruct rose_cause_struct rose_cause;\r\nrose_cause.cause = rose->cause;\r\nrose_cause.diagnostic = rose->diagnostic;\r\nreturn copy_to_user(argp, &rose_cause, sizeof(struct rose_cause_struct)) ? -EFAULT : 0;\r\n}\r\ncase SIOCRSSCAUSE: {\r\nstruct rose_cause_struct rose_cause;\r\nif (copy_from_user(&rose_cause, argp, sizeof(struct rose_cause_struct)))\r\nreturn -EFAULT;\r\nrose->cause = rose_cause.cause;\r\nrose->diagnostic = rose_cause.diagnostic;\r\nreturn 0;\r\n}\r\ncase SIOCRSSL2CALL:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\r\nax25_listen_release(&rose_callsign, NULL);\r\nif (copy_from_user(&rose_callsign, argp, sizeof(ax25_address)))\r\nreturn -EFAULT;\r\nif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\r\nreturn ax25_listen_register(&rose_callsign, NULL);\r\nreturn 0;\r\ncase SIOCRSGL2CALL:\r\nreturn copy_to_user(argp, &rose_callsign, sizeof(ax25_address)) ? -EFAULT : 0;\r\ncase SIOCRSACCEPT:\r\nif (rose->state == ROSE_STATE_5) {\r\nrose_write_internal(sk, ROSE_CALL_ACCEPTED);\r\nrose_start_idletimer(sk);\r\nrose->condition = 0x00;\r\nrose->vs = 0;\r\nrose->va = 0;\r\nrose->vr = 0;\r\nrose->vl = 0;\r\nrose->state = ROSE_STATE_3;\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *rose_info_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rose_list_lock)\r\n{\r\nspin_lock_bh(&rose_list_lock);\r\nreturn seq_hlist_start_head(&rose_list, *pos);\r\n}\r\nstatic void *rose_info_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_hlist_next(v, &rose_list, pos);\r\n}\r\nstatic void rose_info_stop(struct seq_file *seq, void *v)\r\n__releases(rose_list_lock)\r\n{\r\nspin_unlock_bh(&rose_list_lock);\r\n}\r\nstatic int rose_info_show(struct seq_file *seq, void *v)\r\n{\r\nchar buf[11], rsbuf[11];\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"dest_addr dest_call src_addr src_call dev lci neigh st vs vr va t t1 t2 t3 hb idle Snd-Q Rcv-Q inode\n");\r\nelse {\r\nstruct sock *s = sk_entry(v);\r\nstruct rose_sock *rose = rose_sk(s);\r\nconst char *devname, *callsign;\r\nconst struct net_device *dev = rose->device;\r\nif (!dev)\r\ndevname = "???";\r\nelse\r\ndevname = dev->name;\r\nseq_printf(seq, "%-10s %-9s ",\r\nrose2asc(rsbuf, &rose->dest_addr),\r\nax2asc(buf, &rose->dest_call));\r\nif (ax25cmp(&rose->source_call, &null_ax25_address) == 0)\r\ncallsign = "??????-?";\r\nelse\r\ncallsign = ax2asc(buf, &rose->source_call);\r\nseq_printf(seq,\r\n"%-10s %-9s %-5s %3.3X %05d %d %d %d %d %3lu %3lu %3lu %3lu %3lu %3lu/%03lu %5d %5d %ld\n",\r\nrose2asc(rsbuf, &rose->source_addr),\r\ncallsign,\r\ndevname,\r\nrose->lci & 0x0FFF,\r\n(rose->neighbour) ? rose->neighbour->number : 0,\r\nrose->state,\r\nrose->vs,\r\nrose->vr,\r\nrose->va,\r\nax25_display_timer(&rose->timer) / HZ,\r\nrose->t1 / HZ,\r\nrose->t2 / HZ,\r\nrose->t3 / HZ,\r\nrose->hb / HZ,\r\nax25_display_timer(&rose->idletimer) / (60 * HZ),\r\nrose->idle / (60 * HZ),\r\nsk_wmem_alloc_get(s),\r\nsk_rmem_alloc_get(s),\r\ns->sk_socket ? SOCK_INODE(s->sk_socket)->i_ino : 0L);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rose_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &rose_info_seqops);\r\n}\r\nstatic int __init rose_proto_init(void)\r\n{\r\nint i;\r\nint rc;\r\nif (rose_ndevs > 0x7FFFFFFF/sizeof(struct net_device *)) {\r\nprintk(KERN_ERR "ROSE: rose_proto_init - rose_ndevs parameter to large\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = proto_register(&rose_proto, 0);\r\nif (rc != 0)\r\ngoto out;\r\nrose_callsign = null_ax25_address;\r\ndev_rose = kzalloc(rose_ndevs * sizeof(struct net_device *), GFP_KERNEL);\r\nif (dev_rose == NULL) {\r\nprintk(KERN_ERR "ROSE: rose_proto_init - unable to allocate device structure\n");\r\nrc = -ENOMEM;\r\ngoto out_proto_unregister;\r\n}\r\nfor (i = 0; i < rose_ndevs; i++) {\r\nstruct net_device *dev;\r\nchar name[IFNAMSIZ];\r\nsprintf(name, "rose%d", i);\r\ndev = alloc_netdev(0, name, rose_setup);\r\nif (!dev) {\r\nprintk(KERN_ERR "ROSE: rose_proto_init - unable to allocate memory\n");\r\nrc = -ENOMEM;\r\ngoto fail;\r\n}\r\nrc = register_netdev(dev);\r\nif (rc) {\r\nprintk(KERN_ERR "ROSE: netdevice registration failed\n");\r\nfree_netdev(dev);\r\ngoto fail;\r\n}\r\nrose_set_lockdep_key(dev);\r\ndev_rose[i] = dev;\r\n}\r\nsock_register(&rose_family_ops);\r\nregister_netdevice_notifier(&rose_dev_notifier);\r\nax25_register_pid(&rose_pid);\r\nax25_linkfail_register(&rose_linkfail_notifier);\r\n#ifdef CONFIG_SYSCTL\r\nrose_register_sysctl();\r\n#endif\r\nrose_loopback_init();\r\nrose_add_loopback_neigh();\r\nproc_net_fops_create(&init_net, "rose", S_IRUGO, &rose_info_fops);\r\nproc_net_fops_create(&init_net, "rose_neigh", S_IRUGO, &rose_neigh_fops);\r\nproc_net_fops_create(&init_net, "rose_nodes", S_IRUGO, &rose_nodes_fops);\r\nproc_net_fops_create(&init_net, "rose_routes", S_IRUGO, &rose_routes_fops);\r\nout:\r\nreturn rc;\r\nfail:\r\nwhile (--i >= 0) {\r\nunregister_netdev(dev_rose[i]);\r\nfree_netdev(dev_rose[i]);\r\n}\r\nkfree(dev_rose);\r\nout_proto_unregister:\r\nproto_unregister(&rose_proto);\r\ngoto out;\r\n}\r\nstatic void __exit rose_exit(void)\r\n{\r\nint i;\r\nproc_net_remove(&init_net, "rose");\r\nproc_net_remove(&init_net, "rose_neigh");\r\nproc_net_remove(&init_net, "rose_nodes");\r\nproc_net_remove(&init_net, "rose_routes");\r\nrose_loopback_clear();\r\nrose_rt_free();\r\nax25_protocol_release(AX25_P_ROSE);\r\nax25_linkfail_release(&rose_linkfail_notifier);\r\nif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\r\nax25_listen_release(&rose_callsign, NULL);\r\n#ifdef CONFIG_SYSCTL\r\nrose_unregister_sysctl();\r\n#endif\r\nunregister_netdevice_notifier(&rose_dev_notifier);\r\nsock_unregister(PF_ROSE);\r\nfor (i = 0; i < rose_ndevs; i++) {\r\nstruct net_device *dev = dev_rose[i];\r\nif (dev) {\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nkfree(dev_rose);\r\nproto_unregister(&rose_proto);\r\n}
