static inline int record_exception(struct pt_regs *regs, int eflag)\r\n{\r\nu64 fsr = current_thread_info()->xfsr[0];\r\nint would_trap;\r\nwould_trap = (fsr & ((long)eflag << FSR_TEM_SHIFT)) != 0UL;\r\nif(would_trap != 0) {\r\neflag &= ((fsr & FSR_TEM_MASK) >> FSR_TEM_SHIFT);\r\nif((eflag & (eflag - 1)) != 0) {\r\nif(eflag & FP_EX_INVALID)\r\neflag = FP_EX_INVALID;\r\nelse if(eflag & FP_EX_OVERFLOW)\r\neflag = FP_EX_OVERFLOW;\r\nelse if(eflag & FP_EX_UNDERFLOW)\r\neflag = FP_EX_UNDERFLOW;\r\nelse if(eflag & FP_EX_DIVZERO)\r\neflag = FP_EX_DIVZERO;\r\nelse if(eflag & FP_EX_INEXACT)\r\neflag = FP_EX_INEXACT;\r\n}\r\n}\r\nfsr &= ~(FSR_CEXC_MASK);\r\nfsr |= ((long)eflag << FSR_CEXC_SHIFT);\r\nif(would_trap == 0)\r\nfsr |= ((long)eflag << FSR_AEXC_SHIFT);\r\nif(would_trap != 0)\r\nfsr |= (1UL << 14);\r\ncurrent_thread_info()->xfsr[0] = fsr;\r\nif(would_trap == 0) {\r\nregs->tpc = regs->tnpc;\r\nregs->tnpc += 4;\r\n}\r\nreturn (would_trap ? 0 : 1);\r\n}\r\nint do_mathemu(struct pt_regs *regs, struct fpustate *f, bool illegal_insn_trap)\r\n{\r\nunsigned long pc = regs->tpc;\r\nunsigned long tstate = regs->tstate;\r\nu32 insn = 0;\r\nint type = 0;\r\n#define TYPE(ftt, r, ru, b, bu, a, au) type = (au << 2) | (a << 0) | (bu << 5) | (b << 3) | (ru << 8) | (r << 6) | (ftt << 9)\r\nint freg;\r\nstatic u64 zero[2] = { 0L, 0L };\r\nint flags;\r\nFP_DECL_EX;\r\nFP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);\r\nFP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);\r\nFP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);\r\nint IR;\r\nlong XR, xfsr;\r\nif (tstate & TSTATE_PRIV)\r\ndie_if_kernel("unfinished/unimplemented FPop from kernel", regs);\r\nperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\r\nif (test_thread_flag(TIF_32BIT))\r\npc = (u32)pc;\r\nif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\r\nif ((insn & 0xc1f80000) == 0x81a00000) {\r\nswitch ((insn >> 5) & 0x1ff) {\r\ncase FMOVQ:\r\ncase FNEGQ:\r\ncase FABSQ: TYPE(3,3,0,3,0,0,0); break;\r\ncase FSQRTQ: TYPE(3,3,1,3,1,0,0); break;\r\ncase FADDQ:\r\ncase FSUBQ:\r\ncase FMULQ:\r\ncase FDIVQ: TYPE(3,3,1,3,1,3,1); break;\r\ncase FDMULQ: TYPE(3,3,1,2,1,2,1); break;\r\ncase FQTOX: TYPE(3,2,0,3,1,0,0); break;\r\ncase FXTOQ: TYPE(3,3,1,2,0,0,0); break;\r\ncase FQTOS: TYPE(3,1,1,3,1,0,0); break;\r\ncase FQTOD: TYPE(3,2,1,3,1,0,0); break;\r\ncase FITOQ: TYPE(3,3,1,1,0,0,0); break;\r\ncase FSTOQ: TYPE(3,3,1,1,1,0,0); break;\r\ncase FDTOQ: TYPE(3,3,1,2,1,0,0); break;\r\ncase FQTOI: TYPE(3,1,0,3,1,0,0); break;\r\ncase FSQRTS: {\r\nunsigned long x = current_thread_info()->xfsr[0];\r\nx = (x >> 14) & 0x7;\r\nTYPE(x,1,1,1,1,0,0);\r\nbreak;\r\n}\r\ncase FSQRTD: {\r\nunsigned long x = current_thread_info()->xfsr[0];\r\nx = (x >> 14) & 0x7;\r\nTYPE(x,2,1,2,1,0,0);\r\nbreak;\r\n}\r\ncase FADDD:\r\ncase FSUBD:\r\ncase FMULD:\r\ncase FDIVD: TYPE(2,2,1,2,1,2,1); break;\r\ncase FADDS:\r\ncase FSUBS:\r\ncase FMULS:\r\ncase FDIVS: TYPE(2,1,1,1,1,1,1); break;\r\ncase FSMULD: TYPE(2,2,1,1,1,1,1); break;\r\ncase FSTOX: TYPE(2,2,0,1,1,0,0); break;\r\ncase FDTOX: TYPE(2,2,0,2,1,0,0); break;\r\ncase FDTOS: TYPE(2,1,1,2,1,0,0); break;\r\ncase FSTOD: TYPE(2,2,1,1,1,0,0); break;\r\ncase FSTOI: TYPE(2,1,0,1,1,0,0); break;\r\ncase FDTOI: TYPE(2,1,0,2,1,0,0); break;\r\ncase FXTOS: TYPE(2,1,1,2,0,0,0); break;\r\ncase FXTOD: TYPE(2,2,1,2,0,0,0); break;\r\n#if 0\r\ncase FITOS: TYPE(2,1,1,1,0,0,0); break;\r\n#endif\r\ncase FITOD: TYPE(2,2,1,1,0,0,0); break;\r\n}\r\n}\r\nelse if ((insn & 0xc1f80000) == 0x81a80000) {\r\nIR = 2;\r\nswitch ((insn >> 5) & 0x1ff) {\r\ncase FCMPQ: TYPE(3,0,0,3,1,3,1); break;\r\ncase FCMPEQ: TYPE(3,0,0,3,1,3,1); break;\r\ncase FMOVQ0:\r\ncase FMOVQ1:\r\ncase FMOVQ2:\r\ncase FMOVQ3:\r\nif (!((insn >> 11) & 3))\r\nXR = current_thread_info()->xfsr[0] >> 10;\r\nelse\r\nXR = current_thread_info()->xfsr[0] >> (30 + ((insn >> 10) & 0x6));\r\nXR &= 3;\r\nIR = 0;\r\nswitch ((insn >> 14) & 0x7) {\r\ncase 1: if (XR) IR = 1; break;\r\ncase 2: if (XR == 1 || XR == 2) IR = 1; break;\r\ncase 3: if (XR & 1) IR = 1; break;\r\ncase 4: if (XR == 1) IR = 1; break;\r\ncase 5: if (XR & 2) IR = 1; break;\r\ncase 6: if (XR == 2) IR = 1; break;\r\ncase 7: if (XR == 3) IR = 1; break;\r\n}\r\nif ((insn >> 14) & 8)\r\nIR ^= 1;\r\nbreak;\r\ncase FMOVQI:\r\ncase FMOVQX:\r\nXR = regs->tstate >> 32;\r\nif ((insn >> 5) & 0x80)\r\nXR >>= 4;\r\nXR &= 0xf;\r\nIR = 0;\r\nfreg = ((XR >> 2) ^ XR) & 2;\r\nswitch ((insn >> 14) & 0x7) {\r\ncase 1: if (XR & 4) IR = 1; break;\r\ncase 2: if ((XR & 4) || freg) IR = 1; break;\r\ncase 3: if (freg) IR = 1; break;\r\ncase 4: if (XR & 5) IR = 1; break;\r\ncase 5: if (XR & 1) IR = 1; break;\r\ncase 6: if (XR & 8) IR = 1; break;\r\ncase 7: if (XR & 2) IR = 1; break;\r\n}\r\nif ((insn >> 14) & 8)\r\nIR ^= 1;\r\nbreak;\r\ncase FMOVQZ:\r\ncase FMOVQLE:\r\ncase FMOVQLZ:\r\ncase FMOVQNZ:\r\ncase FMOVQGZ:\r\ncase FMOVQGE:\r\nfreg = (insn >> 14) & 0x1f;\r\nif (!freg)\r\nXR = 0;\r\nelse if (freg < 16)\r\nXR = regs->u_regs[freg];\r\nelse if (test_thread_flag(TIF_32BIT)) {\r\nstruct reg_window32 __user *win32;\r\nflushw_user ();\r\nwin32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP]));\r\nget_user(XR, &win32->locals[freg - 16]);\r\n} else {\r\nstruct reg_window __user *win;\r\nflushw_user ();\r\nwin = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS);\r\nget_user(XR, &win->locals[freg - 16]);\r\n}\r\nIR = 0;\r\nswitch ((insn >> 10) & 3) {\r\ncase 1: if (!XR) IR = 1; break;\r\ncase 2: if (XR <= 0) IR = 1; break;\r\ncase 3: if (XR < 0) IR = 1; break;\r\n}\r\nif ((insn >> 10) & 4)\r\nIR ^= 1;\r\nbreak;\r\n}\r\nif (IR == 0) {\r\ncurrent_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);\r\nregs->tpc = regs->tnpc;\r\nregs->tnpc += 4;\r\nreturn 1;\r\n} else if (IR == 1) {\r\ninsn = (insn & 0x3e00001f) | 0x81a00060;\r\nTYPE(3,3,0,3,0,0,0);\r\n}\r\n}\r\n}\r\nif (type) {\r\nargp rs1 = NULL, rs2 = NULL, rd = NULL;\r\nif (!illegal_insn_trap) {\r\nint ftt = (current_thread_info()->xfsr[0] >> 14) & 0x7;\r\nif (ftt != (type >> 9))\r\ngoto err;\r\n}\r\ncurrent_thread_info()->xfsr[0] &= ~0x1c000;\r\nfreg = ((insn >> 14) & 0x1f);\r\nswitch (type & 0x3) {\r\ncase 3: if (freg & 2) {\r\ncurrent_thread_info()->xfsr[0] |= (6 << 14) ;\r\ngoto err;\r\n}\r\ncase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\r\ncase 1: rs1 = (argp)&f->regs[freg];\r\nflags = (freg < 32) ? FPRS_DL : FPRS_DU;\r\nif (!(current_thread_info()->fpsaved[0] & flags))\r\nrs1 = (argp)&zero;\r\nbreak;\r\n}\r\nswitch (type & 0x7) {\r\ncase 7: FP_UNPACK_QP (QA, rs1); break;\r\ncase 6: FP_UNPACK_DP (DA, rs1); break;\r\ncase 5: FP_UNPACK_SP (SA, rs1); break;\r\n}\r\nfreg = (insn & 0x1f);\r\nswitch ((type >> 3) & 0x3) {\r\ncase 3: if (freg & 2) {\r\ncurrent_thread_info()->xfsr[0] |= (6 << 14) ;\r\ngoto err;\r\n}\r\ncase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\r\ncase 1: rs2 = (argp)&f->regs[freg];\r\nflags = (freg < 32) ? FPRS_DL : FPRS_DU;\r\nif (!(current_thread_info()->fpsaved[0] & flags))\r\nrs2 = (argp)&zero;\r\nbreak;\r\n}\r\nswitch ((type >> 3) & 0x7) {\r\ncase 7: FP_UNPACK_QP (QB, rs2); break;\r\ncase 6: FP_UNPACK_DP (DB, rs2); break;\r\ncase 5: FP_UNPACK_SP (SB, rs2); break;\r\n}\r\nfreg = ((insn >> 25) & 0x1f);\r\nswitch ((type >> 6) & 0x3) {\r\ncase 3: if (freg & 2) {\r\ncurrent_thread_info()->xfsr[0] |= (6 << 14) ;\r\ngoto err;\r\n}\r\ncase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\r\ncase 1: rd = (argp)&f->regs[freg];\r\nflags = (freg < 32) ? FPRS_DL : FPRS_DU;\r\nif (!(current_thread_info()->fpsaved[0] & FPRS_FEF)) {\r\ncurrent_thread_info()->fpsaved[0] = FPRS_FEF;\r\ncurrent_thread_info()->gsr[0] = 0;\r\n}\r\nif (!(current_thread_info()->fpsaved[0] & flags)) {\r\nif (freg < 32)\r\nmemset(f->regs, 0, 32*sizeof(u32));\r\nelse\r\nmemset(f->regs+32, 0, 32*sizeof(u32));\r\n}\r\ncurrent_thread_info()->fpsaved[0] |= flags;\r\nbreak;\r\n}\r\nswitch ((insn >> 5) & 0x1ff) {\r\ncase FADDS: FP_ADD_S (SR, SA, SB); break;\r\ncase FADDD: FP_ADD_D (DR, DA, DB); break;\r\ncase FADDQ: FP_ADD_Q (QR, QA, QB); break;\r\ncase FSUBS: FP_SUB_S (SR, SA, SB); break;\r\ncase FSUBD: FP_SUB_D (DR, DA, DB); break;\r\ncase FSUBQ: FP_SUB_Q (QR, QA, QB); break;\r\ncase FMULS: FP_MUL_S (SR, SA, SB); break;\r\ncase FSMULD: FP_CONV (D, S, 1, 1, DA, SA);\r\nFP_CONV (D, S, 1, 1, DB, SB);\r\ncase FMULD: FP_MUL_D (DR, DA, DB); break;\r\ncase FDMULQ: FP_CONV (Q, D, 2, 1, QA, DA);\r\nFP_CONV (Q, D, 2, 1, QB, DB);\r\ncase FMULQ: FP_MUL_Q (QR, QA, QB); break;\r\ncase FDIVS: FP_DIV_S (SR, SA, SB); break;\r\ncase FDIVD: FP_DIV_D (DR, DA, DB); break;\r\ncase FDIVQ: FP_DIV_Q (QR, QA, QB); break;\r\ncase FSQRTS: FP_SQRT_S (SR, SB); break;\r\ncase FSQRTD: FP_SQRT_D (DR, DB); break;\r\ncase FSQRTQ: FP_SQRT_Q (QR, QB); break;\r\ncase FMOVQ: rd->q[0] = rs2->q[0]; rd->q[1] = rs2->q[1]; break;\r\ncase FABSQ: rd->q[0] = rs2->q[0] & 0x7fffffffffffffffUL; rd->q[1] = rs2->q[1]; break;\r\ncase FNEGQ: rd->q[0] = rs2->q[0] ^ 0x8000000000000000UL; rd->q[1] = rs2->q[1]; break;\r\ncase FSTOI: FP_TO_INT_S (IR, SB, 32, 1); break;\r\ncase FDTOI: FP_TO_INT_D (IR, DB, 32, 1); break;\r\ncase FQTOI: FP_TO_INT_Q (IR, QB, 32, 1); break;\r\ncase FSTOX: FP_TO_INT_S (XR, SB, 64, 1); break;\r\ncase FDTOX: FP_TO_INT_D (XR, DB, 64, 1); break;\r\ncase FQTOX: FP_TO_INT_Q (XR, QB, 64, 1); break;\r\ncase FITOQ: IR = rs2->s; FP_FROM_INT_Q (QR, IR, 32, int); break;\r\ncase FXTOQ: XR = rs2->d; FP_FROM_INT_Q (QR, XR, 64, long); break;\r\ncase FXTOS: XR = rs2->d; FP_FROM_INT_S (SR, XR, 64, long); break;\r\ncase FXTOD: XR = rs2->d; FP_FROM_INT_D (DR, XR, 64, long); break;\r\n#if 0\r\ncase FITOS: IR = rs2->s; FP_FROM_INT_S (SR, IR, 32, int); break;\r\n#endif\r\ncase FITOD: IR = rs2->s; FP_FROM_INT_D (DR, IR, 32, int); break;\r\ncase FSTOD: FP_CONV (D, S, 1, 1, DR, SB); break;\r\ncase FSTOQ: FP_CONV (Q, S, 2, 1, QR, SB); break;\r\ncase FDTOQ: FP_CONV (Q, D, 2, 1, QR, DB); break;\r\ncase FDTOS: FP_CONV (S, D, 1, 1, SR, DB); break;\r\ncase FQTOS: FP_CONV (S, Q, 1, 2, SR, QB); break;\r\ncase FQTOD: FP_CONV (D, Q, 1, 2, DR, QB); break;\r\ncase FCMPQ:\r\ncase FCMPEQ:\r\nFP_CMP_Q(XR, QB, QA, 3);\r\nif (XR == 3 &&\r\n(((insn >> 5) & 0x1ff) == FCMPEQ ||\r\nFP_ISSIGNAN_Q(QA) ||\r\nFP_ISSIGNAN_Q(QB)))\r\nFP_SET_EXCEPTION (FP_EX_INVALID);\r\n}\r\nif (!FP_INHIBIT_RESULTS) {\r\nswitch ((type >> 6) & 0x7) {\r\ncase 0: xfsr = current_thread_info()->xfsr[0];\r\nif (XR == -1) XR = 2;\r\nswitch (freg & 3) {\r\ncase 0: xfsr &= ~0xc00; xfsr |= (XR << 10); break;\r\ncase 1: xfsr &= ~0x300000000UL; xfsr |= (XR << 32); break;\r\ncase 2: xfsr &= ~0xc00000000UL; xfsr |= (XR << 34); break;\r\ncase 3: xfsr &= ~0x3000000000UL; xfsr |= (XR << 36); break;\r\n}\r\ncurrent_thread_info()->xfsr[0] = xfsr;\r\nbreak;\r\ncase 1: rd->s = IR; break;\r\ncase 2: rd->d = XR; break;\r\ncase 5: FP_PACK_SP (rd, SR); break;\r\ncase 6: FP_PACK_DP (rd, DR); break;\r\ncase 7: FP_PACK_QP (rd, QR); break;\r\n}\r\n}\r\nif(_fex != 0)\r\nreturn record_exception(regs, _fex);\r\ncurrent_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);\r\nregs->tpc = regs->tnpc;\r\nregs->tnpc += 4;\r\nreturn 1;\r\n}\r\nerr: return 0;\r\n}
