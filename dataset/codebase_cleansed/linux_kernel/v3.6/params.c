static void *kmalloc_parameter(unsigned int size)\r\n{\r\nstruct kmalloced_param *p;\r\np = kmalloc(sizeof(*p) + size, GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\nlist_add(&p->list, &kmalloced_params);\r\nreturn p->val;\r\n}\r\nstatic void maybe_kfree_parameter(void *param)\r\n{\r\nstruct kmalloced_param *p;\r\nlist_for_each_entry(p, &kmalloced_params, list) {\r\nif (p->val == param) {\r\nlist_del(&p->list);\r\nkfree(p);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic char dash2underscore(char c)\r\n{\r\nif (c == '-')\r\nreturn '_';\r\nreturn c;\r\n}\r\nbool parameqn(const char *a, const char *b, size_t n)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < n; i++) {\r\nif (dash2underscore(a[i]) != dash2underscore(b[i]))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool parameq(const char *a, const char *b)\r\n{\r\nreturn parameqn(a, b, strlen(a)+1);\r\n}\r\nstatic int parse_one(char *param,\r\nchar *val,\r\nconst char *doing,\r\nconst struct kernel_param *params,\r\nunsigned num_params,\r\ns16 min_level,\r\ns16 max_level,\r\nint (*handle_unknown)(char *param, char *val,\r\nconst char *doing))\r\n{\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < num_params; i++) {\r\nif (parameq(param, params[i].name)) {\r\nif (params[i].level < min_level\r\n|| params[i].level > max_level)\r\nreturn 0;\r\nif (!val && params[i].ops->set != param_set_bool\r\n&& params[i].ops->set != param_set_bint)\r\nreturn -EINVAL;\r\npr_debug("handling %s with %p\n", param,\r\nparams[i].ops->set);\r\nmutex_lock(&param_lock);\r\nerr = params[i].ops->set(val, &params[i]);\r\nmutex_unlock(&param_lock);\r\nreturn err;\r\n}\r\n}\r\nif (handle_unknown) {\r\npr_debug("doing %s: %s='%s'\n", doing, param, val);\r\nreturn handle_unknown(param, val, doing);\r\n}\r\npr_debug("Unknown argument '%s'\n", param);\r\nreturn -ENOENT;\r\n}\r\nstatic char *next_arg(char *args, char **param, char **val)\r\n{\r\nunsigned int i, equals = 0;\r\nint in_quote = 0, quoted = 0;\r\nchar *next;\r\nif (*args == '"') {\r\nargs++;\r\nin_quote = 1;\r\nquoted = 1;\r\n}\r\nfor (i = 0; args[i]; i++) {\r\nif (isspace(args[i]) && !in_quote)\r\nbreak;\r\nif (equals == 0) {\r\nif (args[i] == '=')\r\nequals = i;\r\n}\r\nif (args[i] == '"')\r\nin_quote = !in_quote;\r\n}\r\n*param = args;\r\nif (!equals)\r\n*val = NULL;\r\nelse {\r\nargs[equals] = '\0';\r\n*val = args + equals + 1;\r\nif (**val == '"') {\r\n(*val)++;\r\nif (args[i-1] == '"')\r\nargs[i-1] = '\0';\r\n}\r\nif (quoted && args[i-1] == '"')\r\nargs[i-1] = '\0';\r\n}\r\nif (args[i]) {\r\nargs[i] = '\0';\r\nnext = args + i + 1;\r\n} else\r\nnext = args + i;\r\nreturn skip_spaces(next);\r\n}\r\nint parse_args(const char *doing,\r\nchar *args,\r\nconst struct kernel_param *params,\r\nunsigned num,\r\ns16 min_level,\r\ns16 max_level,\r\nint (*unknown)(char *param, char *val, const char *doing))\r\n{\r\nchar *param, *val;\r\nargs = skip_spaces(args);\r\nif (*args)\r\npr_debug("doing %s, parsing ARGS: '%s'\n", doing, args);\r\nwhile (*args) {\r\nint ret;\r\nint irq_was_disabled;\r\nargs = next_arg(args, &param, &val);\r\nirq_was_disabled = irqs_disabled();\r\nret = parse_one(param, val, doing, params, num,\r\nmin_level, max_level, unknown);\r\nif (irq_was_disabled && !irqs_disabled())\r\npr_warn("%s: option '%s' enabled irq's!\n",\r\ndoing, param);\r\nswitch (ret) {\r\ncase -ENOENT:\r\npr_err("%s: Unknown parameter `%s'\n", doing, param);\r\nreturn ret;\r\ncase -ENOSPC:\r\npr_err("%s: `%s' too large for parameter `%s'\n",\r\ndoing, val ?: "", param);\r\nreturn ret;\r\ncase 0:\r\nbreak;\r\ndefault:\r\npr_err("%s: `%s' invalid for parameter `%s'\n",\r\ndoing, val ?: "", param);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint param_set_charp(const char *val, const struct kernel_param *kp)\r\n{\r\nif (strlen(val) > 1024) {\r\npr_err("%s: string parameter too long\n", kp->name);\r\nreturn -ENOSPC;\r\n}\r\nmaybe_kfree_parameter(*(char **)kp->arg);\r\nif (slab_is_available()) {\r\n*(char **)kp->arg = kmalloc_parameter(strlen(val)+1);\r\nif (!*(char **)kp->arg)\r\nreturn -ENOMEM;\r\nstrcpy(*(char **)kp->arg, val);\r\n} else\r\n*(const char **)kp->arg = val;\r\nreturn 0;\r\n}\r\nint param_get_charp(char *buffer, const struct kernel_param *kp)\r\n{\r\nreturn sprintf(buffer, "%s", *((char **)kp->arg));\r\n}\r\nstatic void param_free_charp(void *arg)\r\n{\r\nmaybe_kfree_parameter(*((char **)arg));\r\n}\r\nint param_set_bool(const char *val, const struct kernel_param *kp)\r\n{\r\nif (!val) val = "1";\r\nreturn strtobool(val, kp->arg);\r\n}\r\nint param_get_bool(char *buffer, const struct kernel_param *kp)\r\n{\r\nreturn sprintf(buffer, "%c", *(bool *)kp->arg ? 'Y' : 'N');\r\n}\r\nint param_set_invbool(const char *val, const struct kernel_param *kp)\r\n{\r\nint ret;\r\nbool boolval;\r\nstruct kernel_param dummy;\r\ndummy.arg = &boolval;\r\nret = param_set_bool(val, &dummy);\r\nif (ret == 0)\r\n*(bool *)kp->arg = !boolval;\r\nreturn ret;\r\n}\r\nint param_get_invbool(char *buffer, const struct kernel_param *kp)\r\n{\r\nreturn sprintf(buffer, "%c", (*(bool *)kp->arg) ? 'N' : 'Y');\r\n}\r\nint param_set_bint(const char *val, const struct kernel_param *kp)\r\n{\r\nstruct kernel_param boolkp;\r\nbool v;\r\nint ret;\r\nboolkp = *kp;\r\nboolkp.arg = &v;\r\nret = param_set_bool(val, &boolkp);\r\nif (ret == 0)\r\n*(int *)kp->arg = v;\r\nreturn ret;\r\n}\r\nstatic int param_array(const char *name,\r\nconst char *val,\r\nunsigned int min, unsigned int max,\r\nvoid *elem, int elemsize,\r\nint (*set)(const char *, const struct kernel_param *kp),\r\ns16 level,\r\nunsigned int *num)\r\n{\r\nint ret;\r\nstruct kernel_param kp;\r\nchar save;\r\nkp.name = name;\r\nkp.arg = elem;\r\nkp.level = level;\r\n*num = 0;\r\ndo {\r\nint len;\r\nif (*num == max) {\r\npr_err("%s: can only take %i arguments\n", name, max);\r\nreturn -EINVAL;\r\n}\r\nlen = strcspn(val, ",");\r\nsave = val[len];\r\n((char *)val)[len] = '\0';\r\nBUG_ON(!mutex_is_locked(&param_lock));\r\nret = set(val, &kp);\r\nif (ret != 0)\r\nreturn ret;\r\nkp.arg += elemsize;\r\nval += len+1;\r\n(*num)++;\r\n} while (save == ',');\r\nif (*num < min) {\r\npr_err("%s: needs at least %i arguments\n", name, min);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int param_array_set(const char *val, const struct kernel_param *kp)\r\n{\r\nconst struct kparam_array *arr = kp->arr;\r\nunsigned int temp_num;\r\nreturn param_array(kp->name, val, 1, arr->max, arr->elem,\r\narr->elemsize, arr->ops->set, kp->level,\r\narr->num ?: &temp_num);\r\n}\r\nstatic int param_array_get(char *buffer, const struct kernel_param *kp)\r\n{\r\nint i, off, ret;\r\nconst struct kparam_array *arr = kp->arr;\r\nstruct kernel_param p;\r\np = *kp;\r\nfor (i = off = 0; i < (arr->num ? *arr->num : arr->max); i++) {\r\nif (i)\r\nbuffer[off++] = ',';\r\np.arg = arr->elem + arr->elemsize * i;\r\nBUG_ON(!mutex_is_locked(&param_lock));\r\nret = arr->ops->get(buffer + off, &p);\r\nif (ret < 0)\r\nreturn ret;\r\noff += ret;\r\n}\r\nbuffer[off] = '\0';\r\nreturn off;\r\n}\r\nstatic void param_array_free(void *arg)\r\n{\r\nunsigned int i;\r\nconst struct kparam_array *arr = arg;\r\nif (arr->ops->free)\r\nfor (i = 0; i < (arr->num ? *arr->num : arr->max); i++)\r\narr->ops->free(arr->elem + arr->elemsize * i);\r\n}\r\nint param_set_copystring(const char *val, const struct kernel_param *kp)\r\n{\r\nconst struct kparam_string *kps = kp->str;\r\nif (strlen(val)+1 > kps->maxlen) {\r\npr_err("%s: string doesn't fit in %u chars.\n",\r\nkp->name, kps->maxlen-1);\r\nreturn -ENOSPC;\r\n}\r\nstrcpy(kps->string, val);\r\nreturn 0;\r\n}\r\nint param_get_string(char *buffer, const struct kernel_param *kp)\r\n{\r\nconst struct kparam_string *kps = kp->str;\r\nreturn strlcpy(buffer, kps->string, kps->maxlen);\r\n}\r\nstatic ssize_t param_attr_show(struct module_attribute *mattr,\r\nstruct module_kobject *mk, char *buf)\r\n{\r\nint count;\r\nstruct param_attribute *attribute = to_param_attr(mattr);\r\nif (!attribute->param->ops->get)\r\nreturn -EPERM;\r\nmutex_lock(&param_lock);\r\ncount = attribute->param->ops->get(buf, attribute->param);\r\nmutex_unlock(&param_lock);\r\nif (count > 0) {\r\nstrcat(buf, "\n");\r\n++count;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t param_attr_store(struct module_attribute *mattr,\r\nstruct module_kobject *km,\r\nconst char *buf, size_t len)\r\n{\r\nint err;\r\nstruct param_attribute *attribute = to_param_attr(mattr);\r\nif (!attribute->param->ops->set)\r\nreturn -EPERM;\r\nmutex_lock(&param_lock);\r\nerr = attribute->param->ops->set(buf, attribute->param);\r\nmutex_unlock(&param_lock);\r\nif (!err)\r\nreturn len;\r\nreturn err;\r\n}\r\nvoid __kernel_param_lock(void)\r\n{\r\nmutex_lock(&param_lock);\r\n}\r\nvoid __kernel_param_unlock(void)\r\n{\r\nmutex_unlock(&param_lock);\r\n}\r\nstatic __modinit int add_sysfs_param(struct module_kobject *mk,\r\nconst struct kernel_param *kp,\r\nconst char *name)\r\n{\r\nstruct module_param_attrs *new;\r\nstruct attribute **attrs;\r\nint err, num;\r\nBUG_ON(!kp->perm);\r\nif (!mk->mp) {\r\nnum = 0;\r\nattrs = NULL;\r\n} else {\r\nnum = mk->mp->num;\r\nattrs = mk->mp->grp.attrs;\r\n}\r\nnew = krealloc(mk->mp,\r\nsizeof(*mk->mp) + sizeof(mk->mp->attrs[0]) * (num+1),\r\nGFP_KERNEL);\r\nif (!new) {\r\nkfree(mk->mp);\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nattrs = krealloc(attrs, sizeof(new->grp.attrs[0])*(num+2), GFP_KERNEL);\r\nif (!attrs) {\r\nerr = -ENOMEM;\r\ngoto fail_free_new;\r\n}\r\nmemset(new, 0, sizeof(*new));\r\nmemset(&new->attrs[num], 0, sizeof(new->attrs[num]));\r\nmemset(&attrs[num], 0, sizeof(attrs[num]));\r\nnew->grp.name = "parameters";\r\nnew->grp.attrs = attrs;\r\nsysfs_attr_init(&new->attrs[num].mattr.attr);\r\nnew->attrs[num].param = kp;\r\nnew->attrs[num].mattr.show = param_attr_show;\r\nnew->attrs[num].mattr.store = param_attr_store;\r\nnew->attrs[num].mattr.attr.name = (char *)name;\r\nnew->attrs[num].mattr.attr.mode = kp->perm;\r\nnew->num = num+1;\r\nfor (num = 0; num < new->num; num++)\r\nnew->grp.attrs[num] = &new->attrs[num].mattr.attr;\r\nnew->grp.attrs[num] = NULL;\r\nmk->mp = new;\r\nreturn 0;\r\nfail_free_new:\r\nkfree(new);\r\nfail:\r\nmk->mp = NULL;\r\nreturn err;\r\n}\r\nstatic void free_module_param_attrs(struct module_kobject *mk)\r\n{\r\nkfree(mk->mp->grp.attrs);\r\nkfree(mk->mp);\r\nmk->mp = NULL;\r\n}\r\nint module_param_sysfs_setup(struct module *mod,\r\nconst struct kernel_param *kparam,\r\nunsigned int num_params)\r\n{\r\nint i, err;\r\nbool params = false;\r\nfor (i = 0; i < num_params; i++) {\r\nif (kparam[i].perm == 0)\r\ncontinue;\r\nerr = add_sysfs_param(&mod->mkobj, &kparam[i], kparam[i].name);\r\nif (err)\r\nreturn err;\r\nparams = true;\r\n}\r\nif (!params)\r\nreturn 0;\r\nerr = sysfs_create_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);\r\nif (err)\r\nfree_module_param_attrs(&mod->mkobj);\r\nreturn err;\r\n}\r\nvoid module_param_sysfs_remove(struct module *mod)\r\n{\r\nif (mod->mkobj.mp) {\r\nsysfs_remove_group(&mod->mkobj.kobj, &mod->mkobj.mp->grp);\r\nfree_module_param_attrs(&mod->mkobj);\r\n}\r\n}\r\nvoid destroy_params(const struct kernel_param *params, unsigned num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i++)\r\nif (params[i].ops->free)\r\nparams[i].ops->free(params[i].arg);\r\n}\r\nstatic struct module_kobject * __init locate_module_kobject(const char *name)\r\n{\r\nstruct module_kobject *mk;\r\nstruct kobject *kobj;\r\nint err;\r\nkobj = kset_find_obj(module_kset, name);\r\nif (kobj) {\r\nmk = to_module_kobject(kobj);\r\n} else {\r\nmk = kzalloc(sizeof(struct module_kobject), GFP_KERNEL);\r\nBUG_ON(!mk);\r\nmk->mod = THIS_MODULE;\r\nmk->kobj.kset = module_kset;\r\nerr = kobject_init_and_add(&mk->kobj, &module_ktype, NULL,\r\n"%s", name);\r\n#ifdef CONFIG_MODULES\r\nif (!err)\r\nerr = sysfs_create_file(&mk->kobj, &module_uevent.attr);\r\n#endif\r\nif (err) {\r\nkobject_put(&mk->kobj);\r\npr_crit("Adding module '%s' to sysfs failed (%d), the system may be unstable.\n",\r\nname, err);\r\nreturn NULL;\r\n}\r\nkobject_get(&mk->kobj);\r\n}\r\nreturn mk;\r\n}\r\nstatic void __init kernel_add_sysfs_param(const char *name,\r\nstruct kernel_param *kparam,\r\nunsigned int name_skip)\r\n{\r\nstruct module_kobject *mk;\r\nint err;\r\nmk = locate_module_kobject(name);\r\nif (!mk)\r\nreturn;\r\nif (mk->mp)\r\nsysfs_remove_group(&mk->kobj, &mk->mp->grp);\r\nerr = add_sysfs_param(mk, kparam, kparam->name + name_skip);\r\nBUG_ON(err);\r\nerr = sysfs_create_group(&mk->kobj, &mk->mp->grp);\r\nBUG_ON(err);\r\nkobject_uevent(&mk->kobj, KOBJ_ADD);\r\nkobject_put(&mk->kobj);\r\n}\r\nstatic void __init param_sysfs_builtin(void)\r\n{\r\nstruct kernel_param *kp;\r\nunsigned int name_len;\r\nchar modname[MODULE_NAME_LEN];\r\nfor (kp = __start___param; kp < __stop___param; kp++) {\r\nchar *dot;\r\nif (kp->perm == 0)\r\ncontinue;\r\ndot = strchr(kp->name, '.');\r\nif (!dot) {\r\nstrcpy(modname, "kernel");\r\nname_len = 0;\r\n} else {\r\nname_len = dot - kp->name + 1;\r\nstrlcpy(modname, kp->name, name_len);\r\n}\r\nkernel_add_sysfs_param(modname, kp, name_len);\r\n}\r\n}\r\nssize_t __modver_version_show(struct module_attribute *mattr,\r\nstruct module_kobject *mk, char *buf)\r\n{\r\nstruct module_version_attribute *vattr =\r\ncontainer_of(mattr, struct module_version_attribute, mattr);\r\nreturn sprintf(buf, "%s\n", vattr->version);\r\n}\r\nstatic void __init version_sysfs_builtin(void)\r\n{\r\nconst struct module_version_attribute **p;\r\nstruct module_kobject *mk;\r\nint err;\r\nfor (p = __start___modver; p < __stop___modver; p++) {\r\nconst struct module_version_attribute *vattr = *p;\r\nmk = locate_module_kobject(vattr->module_name);\r\nif (mk) {\r\nerr = sysfs_create_file(&mk->kobj, &vattr->mattr.attr);\r\nkobject_uevent(&mk->kobj, KOBJ_ADD);\r\nkobject_put(&mk->kobj);\r\n}\r\n}\r\n}\r\nstatic ssize_t module_attr_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct module_attribute *attribute;\r\nstruct module_kobject *mk;\r\nint ret;\r\nattribute = to_module_attr(attr);\r\nmk = to_module_kobject(kobj);\r\nif (!attribute->show)\r\nreturn -EIO;\r\nret = attribute->show(attribute, mk, buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t module_attr_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct module_attribute *attribute;\r\nstruct module_kobject *mk;\r\nint ret;\r\nattribute = to_module_attr(attr);\r\nmk = to_module_kobject(kobj);\r\nif (!attribute->store)\r\nreturn -EIO;\r\nret = attribute->store(attribute, mk, buf, len);\r\nreturn ret;\r\n}\r\nstatic int uevent_filter(struct kset *kset, struct kobject *kobj)\r\n{\r\nstruct kobj_type *ktype = get_ktype(kobj);\r\nif (ktype == &module_ktype)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __init param_sysfs_init(void)\r\n{\r\nmodule_kset = kset_create_and_add("module", &module_uevent_ops, NULL);\r\nif (!module_kset) {\r\nprintk(KERN_WARNING "%s (%d): error creating kset\n",\r\n__FILE__, __LINE__);\r\nreturn -ENOMEM;\r\n}\r\nmodule_sysfs_initialized = 1;\r\nversion_sysfs_builtin();\r\nparam_sysfs_builtin();\r\nreturn 0;\r\n}
