static void esb2rom_cleanup(struct esb2rom_window *window)\r\n{\r\nstruct esb2rom_map_info *map, *scratch;\r\nu8 byte;\r\npci_read_config_byte(window->pdev, BIOS_CNTL, &byte);\r\npci_write_config_byte(window->pdev, BIOS_CNTL,\r\nbyte & ~BIOS_WRITE_ENABLE);\r\nlist_for_each_entry_safe(map, scratch, &window->maps, list) {\r\nif (map->rsrc.parent)\r\nrelease_resource(&map->rsrc);\r\nmtd_device_unregister(map->mtd);\r\nmap_destroy(map->mtd);\r\nlist_del(&map->list);\r\nkfree(map);\r\n}\r\nif (window->rsrc.parent)\r\nrelease_resource(&window->rsrc);\r\nif (window->virt) {\r\niounmap(window->virt);\r\nwindow->virt = NULL;\r\nwindow->phys = 0;\r\nwindow->size = 0;\r\n}\r\npci_dev_put(window->pdev);\r\n}\r\nstatic int __devinit esb2rom_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstatic char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };\r\nstruct esb2rom_window *window = &esb2rom_window;\r\nstruct esb2rom_map_info *map = NULL;\r\nunsigned long map_top;\r\nu8 byte;\r\nu16 word;\r\nwindow->pdev = pci_dev_get(pdev);\r\nwindow->phys = 0;\r\npci_read_config_word(pdev, FWH_DEC_EN1, &word);\r\nprintk(KERN_DEBUG "pci_read_config_word : %x\n", word);\r\nif ((word & FWH_8MiB) == FWH_8MiB)\r\nwindow->phys = 0xff400000;\r\nelse if ((word & FWH_7MiB) == FWH_7MiB)\r\nwindow->phys = 0xff500000;\r\nelse if ((word & FWH_6MiB) == FWH_6MiB)\r\nwindow->phys = 0xff600000;\r\nelse if ((word & FWH_5MiB) == FWH_5MiB)\r\nwindow->phys = 0xFF700000;\r\nelse if ((word & FWH_4MiB) == FWH_4MiB)\r\nwindow->phys = 0xffc00000;\r\nelse if ((word & FWH_3_5MiB) == FWH_3_5MiB)\r\nwindow->phys = 0xffc80000;\r\nelse if ((word & FWH_3MiB) == FWH_3MiB)\r\nwindow->phys = 0xffd00000;\r\nelse if ((word & FWH_2_5MiB) == FWH_2_5MiB)\r\nwindow->phys = 0xffd80000;\r\nelse if ((word & FWH_2MiB) == FWH_2MiB)\r\nwindow->phys = 0xffe00000;\r\nelse if ((word & FWH_1_5MiB) == FWH_1_5MiB)\r\nwindow->phys = 0xffe80000;\r\nelse if ((word & FWH_1MiB) == FWH_1MiB)\r\nwindow->phys = 0xfff00000;\r\nelse if ((word & FWH_0_5MiB) == FWH_0_5MiB)\r\nwindow->phys = 0xfff80000;\r\nif (window->phys == 0) {\r\nprintk(KERN_ERR MOD_NAME ": Rom window is closed\n");\r\ngoto out;\r\n}\r\nwindow->phys -= 0x400000UL;\r\nwindow->size = (0xffffffffUL - window->phys) + 1UL;\r\npci_read_config_byte(pdev, BIOS_CNTL, &byte);\r\nif (!(byte & BIOS_WRITE_ENABLE) && (byte & (BIOS_LOCK_ENABLE))) {\r\nprintk(KERN_ERR MOD_NAME ": firmware access control, I can't enable writes\n");\r\ngoto out;\r\n}\r\npci_write_config_byte(pdev, BIOS_CNTL, byte | BIOS_WRITE_ENABLE);\r\nwindow->rsrc.name = MOD_NAME;\r\nwindow->rsrc.start = window->phys;\r\nwindow->rsrc.end = window->phys + window->size - 1;\r\nwindow->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&iomem_resource, &window->rsrc)) {\r\nwindow->rsrc.parent = NULL;\r\nprintk(KERN_DEBUG MOD_NAME ": "\r\n"%s(): Unable to register resource %pR - kernel bug?\n",\r\n__func__, &window->rsrc);\r\n}\r\nwindow->virt = ioremap_nocache(window->phys, window->size);\r\nif (!window->virt) {\r\nprintk(KERN_ERR MOD_NAME ": ioremap(%08lx, %08lx) failed\n",\r\nwindow->phys, window->size);\r\ngoto out;\r\n}\r\nmap_top = window->phys;\r\nif ((window->phys & 0x3fffff) != 0) {\r\nmap_top = window->phys + 0x400000;\r\n}\r\n#if 1\r\nif (map_top < 0xffc00000)\r\nmap_top = 0xffc00000;\r\n#endif\r\nwhile ((map_top - 1) < 0xffffffffUL) {\r\nstruct cfi_private *cfi;\r\nunsigned long offset;\r\nint i;\r\nif (!map)\r\nmap = kmalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map) {\r\nprintk(KERN_ERR MOD_NAME ": kmalloc failed");\r\ngoto out;\r\n}\r\nmemset(map, 0, sizeof(*map));\r\nINIT_LIST_HEAD(&map->list);\r\nmap->map.name = map->map_name;\r\nmap->map.phys = map_top;\r\noffset = map_top - window->phys;\r\nmap->map.virt = (void __iomem *)\r\n(((unsigned long)(window->virt)) + offset);\r\nmap->map.size = 0xffffffffUL - map_top + 1UL;\r\nsprintf(map->map_name, "%s @%08Lx",\r\nMOD_NAME, (unsigned long long)map->map.phys);\r\nfor(map->map.bankwidth = 32; map->map.bankwidth;\r\nmap->map.bankwidth >>= 1) {\r\nchar **probe_type;\r\nif (!map_bankwidth_supported(map->map.bankwidth))\r\ncontinue;\r\nsimple_map_init(&map->map);\r\nprobe_type = rom_probe_types;\r\nfor(; *probe_type; probe_type++) {\r\nmap->mtd = do_map_probe(*probe_type, &map->map);\r\nif (map->mtd)\r\ngoto found;\r\n}\r\n}\r\nmap_top += ROM_PROBE_STEP_SIZE;\r\ncontinue;\r\nfound:\r\nif (map->mtd->size > map->map.size) {\r\nprintk(KERN_WARNING MOD_NAME\r\n" rom(%llu) larger than window(%lu). fixing...\n",\r\n(unsigned long long)map->mtd->size, map->map.size);\r\nmap->mtd->size = map->map.size;\r\n}\r\nif (window->rsrc.parent) {\r\nmap->rsrc.name = map->map_name;\r\nmap->rsrc.start = map->map.phys;\r\nmap->rsrc.end = map->map.phys + map->mtd->size - 1;\r\nmap->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&window->rsrc, &map->rsrc)) {\r\nprintk(KERN_ERR MOD_NAME\r\n": cannot reserve MTD resource\n");\r\nmap->rsrc.parent = NULL;\r\n}\r\n}\r\nmap->map.virt = window->virt;\r\nmap->map.phys = window->phys;\r\ncfi = map->map.fldrv_priv;\r\nfor(i = 0; i < cfi->numchips; i++)\r\ncfi->chips[i].start += offset;\r\nmap->mtd->owner = THIS_MODULE;\r\nif (mtd_device_register(map->mtd, NULL, 0)) {\r\nmap_destroy(map->mtd);\r\nmap->mtd = NULL;\r\ngoto out;\r\n}\r\nmap_top += map->mtd->size;\r\nlist_add(&map->list, &window->maps);\r\nmap = NULL;\r\n}\r\nout:\r\nkfree(map);\r\nif (list_empty(&window->maps)) {\r\nesb2rom_cleanup(window);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devexit esb2rom_remove_one (struct pci_dev *pdev)\r\n{\r\nstruct esb2rom_window *window = &esb2rom_window;\r\nesb2rom_cleanup(window);\r\n}\r\nstatic int __init init_esb2rom(void)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct pci_device_id *id;\r\nint retVal;\r\npdev = NULL;\r\nfor (id = esb2rom_pci_tbl; id->vendor; id++) {\r\nprintk(KERN_DEBUG "device id = %x\n", id->device);\r\npdev = pci_get_device(id->vendor, id->device, NULL);\r\nif (pdev) {\r\nprintk(KERN_DEBUG "matched device = %x\n", id->device);\r\nbreak;\r\n}\r\n}\r\nif (pdev) {\r\nprintk(KERN_DEBUG "matched device id %x\n", id->device);\r\nretVal = esb2rom_init_one(pdev, &esb2rom_pci_tbl[0]);\r\npci_dev_put(pdev);\r\nprintk(KERN_DEBUG "retVal = %d\n", retVal);\r\nreturn retVal;\r\n}\r\nreturn -ENXIO;\r\n#if 0\r\nreturn pci_register_driver(&esb2rom_driver);\r\n#endif\r\n}\r\nstatic void __exit cleanup_esb2rom(void)\r\n{\r\nesb2rom_remove_one(esb2rom_window.pdev);\r\n}
