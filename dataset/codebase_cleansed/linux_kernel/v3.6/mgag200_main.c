static void mga_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct mga_framebuffer *mga_fb = to_mga_framebuffer(fb);\r\nif (mga_fb->obj)\r\ndrm_gem_object_unreference_unlocked(mga_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(fb);\r\n}\r\nstatic int mga_user_framebuffer_create_handle(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nreturn 0;\r\n}\r\nint mgag200_framebuffer_init(struct drm_device *dev,\r\nstruct mga_framebuffer *gfb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret = drm_framebuffer_init(dev, &gfb->base, &mga_fb_funcs);\r\nif (ret) {\r\nDRM_ERROR("drm_framebuffer_init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ndrm_helper_mode_fill_fb_struct(&gfb->base, mode_cmd);\r\ngfb->obj = obj;\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nmgag200_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *filp,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct mga_framebuffer *mga_fb;\r\nint ret;\r\nobj = drm_gem_object_lookup(dev, filp, mode_cmd->handles[0]);\r\nif (obj == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\nmga_fb = kzalloc(sizeof(*mga_fb), GFP_KERNEL);\r\nif (!mga_fb) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nret = mgag200_framebuffer_init(dev, mga_fb, mode_cmd, obj);\r\nif (ret) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nkfree(mga_fb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &mga_fb->base;\r\n}\r\nstatic void mga_vram_fini(struct mga_device *mdev)\r\n{\r\npci_iounmap(mdev->dev->pdev, mdev->rmmio);\r\nmdev->rmmio = NULL;\r\nif (mdev->mc.vram_base)\r\nrelease_mem_region(mdev->mc.vram_base, mdev->mc.vram_window);\r\n}\r\nstatic int mga_probe_vram(struct mga_device *mdev, void __iomem *mem)\r\n{\r\nint offset;\r\nint orig;\r\nint test1, test2;\r\nint orig1, orig2;\r\norig = ioread16(mem);\r\niowrite16(0, mem);\r\nfor (offset = 0x100000; offset < mdev->mc.vram_window; offset += 0x4000) {\r\norig1 = ioread8(mem + offset);\r\norig2 = ioread8(mem + offset + 0x100);\r\niowrite16(0xaa55, mem + offset);\r\niowrite16(0xaa55, mem + offset + 0x100);\r\ntest1 = ioread16(mem + offset);\r\ntest2 = ioread16(mem);\r\niowrite16(orig1, mem + offset);\r\niowrite16(orig2, mem + offset + 0x100);\r\nif (test1 != 0xaa55) {\r\nbreak;\r\n}\r\nif (test2) {\r\nbreak;\r\n}\r\n}\r\niowrite16(orig, mem);\r\nreturn offset - 65536;\r\n}\r\nstatic int mga_vram_init(struct mga_device *mdev)\r\n{\r\nvoid __iomem *mem;\r\nstruct apertures_struct *aper = alloc_apertures(1);\r\nmdev->mc.vram_base = pci_resource_start(mdev->dev->pdev, 0);\r\nmdev->mc.vram_window = pci_resource_len(mdev->dev->pdev, 0);\r\naper->ranges[0].base = mdev->mc.vram_base;\r\naper->ranges[0].size = mdev->mc.vram_window;\r\naper->count = 1;\r\nremove_conflicting_framebuffers(aper, "mgafb", true);\r\nif (!request_mem_region(mdev->mc.vram_base, mdev->mc.vram_window,\r\n"mgadrmfb_vram")) {\r\nDRM_ERROR("can't reserve VRAM\n");\r\nreturn -ENXIO;\r\n}\r\nmem = pci_iomap(mdev->dev->pdev, 0, 0);\r\nmdev->mc.vram_size = mga_probe_vram(mdev, mem);\r\npci_iounmap(mdev->dev->pdev, mem);\r\nreturn 0;\r\n}\r\nstatic int mgag200_device_init(struct drm_device *dev,\r\nuint32_t flags)\r\n{\r\nstruct mga_device *mdev = dev->dev_private;\r\nint ret, option;\r\nmdev->type = flags;\r\nmdev->num_crtc = 1;\r\npci_read_config_dword(dev->pdev, PCI_MGA_OPTION, &option);\r\nmdev->has_sdram = !(option & (1 << 14));\r\nmdev->rmmio_base = pci_resource_start(mdev->dev->pdev, 1);\r\nmdev->rmmio_size = pci_resource_len(mdev->dev->pdev, 1);\r\nif (!request_mem_region(mdev->rmmio_base, mdev->rmmio_size,\r\n"mgadrmfb_mmio")) {\r\nDRM_ERROR("can't reserve mmio registers\n");\r\nreturn -ENOMEM;\r\n}\r\nmdev->rmmio = pci_iomap(dev->pdev, 1, 0);\r\nif (mdev->rmmio == NULL)\r\nreturn -ENOMEM;\r\nif (IS_G200_SE(mdev))\r\nmdev->reg_1e24 = RREG32(0x1e24);\r\nret = mga_vram_init(mdev);\r\nif (ret) {\r\nrelease_mem_region(mdev->rmmio_base, mdev->rmmio_size);\r\nreturn ret;\r\n}\r\nmdev->bpp_shifts[0] = 0;\r\nmdev->bpp_shifts[1] = 1;\r\nmdev->bpp_shifts[2] = 0;\r\nmdev->bpp_shifts[3] = 2;\r\nreturn 0;\r\n}\r\nvoid mgag200_device_fini(struct mga_device *mdev)\r\n{\r\nrelease_mem_region(mdev->rmmio_base, mdev->rmmio_size);\r\nmga_vram_fini(mdev);\r\n}\r\nint mgag200_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct mga_device *mdev;\r\nint r;\r\nmdev = kzalloc(sizeof(struct mga_device), GFP_KERNEL);\r\nif (mdev == NULL)\r\nreturn -ENOMEM;\r\ndev->dev_private = (void *)mdev;\r\nmdev->dev = dev;\r\nr = mgag200_device_init(dev, flags);\r\nif (r) {\r\ndev_err(&dev->pdev->dev, "Fatal error during GPU init: %d\n", r);\r\ngoto out;\r\n}\r\nr = mgag200_mm_init(mdev);\r\nif (r)\r\ngoto out;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.funcs = (void *)&mga_mode_funcs;\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.prefer_shadow = 1;\r\nr = mgag200_modeset_init(mdev);\r\nif (r)\r\ndev_err(&dev->pdev->dev, "Fatal error during modeset init: %d\n", r);\r\nout:\r\nif (r)\r\nmgag200_driver_unload(dev);\r\nreturn r;\r\n}\r\nint mgag200_driver_unload(struct drm_device *dev)\r\n{\r\nstruct mga_device *mdev = dev->dev_private;\r\nif (mdev == NULL)\r\nreturn 0;\r\nmgag200_modeset_fini(mdev);\r\nmgag200_fbdev_fini(mdev);\r\ndrm_mode_config_cleanup(dev);\r\nmgag200_mm_fini(mdev);\r\nmgag200_device_fini(mdev);\r\nkfree(mdev);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nint mgag200_gem_create(struct drm_device *dev,\r\nu32 size, bool iskernel,\r\nstruct drm_gem_object **obj)\r\n{\r\nstruct mgag200_bo *astbo;\r\nint ret;\r\n*obj = NULL;\r\nsize = roundup(size, PAGE_SIZE);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nret = mgag200_bo_create(dev, size, 0, 0, &astbo);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("failed to allocate GEM object\n");\r\nreturn ret;\r\n}\r\n*obj = &astbo->gem;\r\nreturn 0;\r\n}\r\nint mgag200_dumb_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nint ret;\r\nstruct drm_gem_object *gobj;\r\nu32 handle;\r\nargs->pitch = args->width * ((args->bpp + 7) / 8);\r\nargs->size = args->pitch * args->height;\r\nret = mgag200_gem_create(dev, args->size, false,\r\n&gobj);\r\nif (ret)\r\nreturn ret;\r\nret = drm_gem_handle_create(file, gobj, &handle);\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nif (ret)\r\nreturn ret;\r\nargs->handle = handle;\r\nreturn 0;\r\n}\r\nint mgag200_dumb_destroy(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint32_t handle)\r\n{\r\nreturn drm_gem_handle_delete(file, handle);\r\n}\r\nint mgag200_gem_init_object(struct drm_gem_object *obj)\r\n{\r\nBUG();\r\nreturn 0;\r\n}\r\nvoid mgag200_bo_unref(struct mgag200_bo **bo)\r\n{\r\nstruct ttm_buffer_object *tbo;\r\nif ((*bo) == NULL)\r\nreturn;\r\ntbo = &((*bo)->bo);\r\nttm_bo_unref(&tbo);\r\nif (tbo == NULL)\r\n*bo = NULL;\r\n}\r\nvoid mgag200_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct mgag200_bo *mgag200_bo = gem_to_mga_bo(obj);\r\nif (!mgag200_bo)\r\nreturn;\r\nmgag200_bo_unref(&mgag200_bo);\r\n}\r\nstatic inline u64 mgag200_bo_mmap_offset(struct mgag200_bo *bo)\r\n{\r\nreturn bo->bo.addr_space_offset;\r\n}\r\nint\r\nmgag200_dumb_mmap_offset(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nstruct mgag200_bo *bo;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (obj == NULL) {\r\nret = -ENOENT;\r\ngoto out_unlock;\r\n}\r\nbo = gem_to_mga_bo(obj);\r\n*offset = mgag200_bo_mmap_offset(bo);\r\ndrm_gem_object_unreference(obj);\r\nret = 0;\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}
