static int\r\nuvc_send_response(struct uvc_device *uvc, struct uvc_request_data *data)\r\n{\r\nstruct usb_composite_dev *cdev = uvc->func.config->cdev;\r\nstruct usb_request *req = uvc->control_req;\r\nif (data->length < 0)\r\nreturn usb_ep_set_halt(cdev->gadget->ep0);\r\nreq->length = min_t(unsigned int, uvc->event_length, data->length);\r\nreq->zero = data->length < uvc->event_length;\r\nreq->dma = DMA_ADDR_INVALID;\r\nmemcpy(req->buf, data->data, data->length);\r\nreturn usb_ep_queue(cdev->gadget->ep0, req, GFP_KERNEL);\r\n}\r\nstatic int\r\nuvc_v4l2_get_format(struct uvc_video *video, struct v4l2_format *fmt)\r\n{\r\nfmt->fmt.pix.pixelformat = video->fcc;\r\nfmt->fmt.pix.width = video->width;\r\nfmt->fmt.pix.height = video->height;\r\nfmt->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmt->fmt.pix.bytesperline = video->bpp * video->width / 8;\r\nfmt->fmt.pix.sizeimage = video->imagesize;\r\nfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nuvc_v4l2_set_format(struct uvc_video *video, struct v4l2_format *fmt)\r\n{\r\nstruct uvc_format *format;\r\nunsigned int imagesize;\r\nunsigned int bpl;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(uvc_formats); ++i) {\r\nformat = &uvc_formats[i];\r\nif (format->fcc == fmt->fmt.pix.pixelformat)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(uvc_formats)) {\r\nprintk(KERN_INFO "Unsupported format 0x%08x.\n",\r\nfmt->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nbpl = format->bpp * fmt->fmt.pix.width / 8;\r\nimagesize = bpl ? bpl * fmt->fmt.pix.height : fmt->fmt.pix.sizeimage;\r\nvideo->fcc = format->fcc;\r\nvideo->bpp = format->bpp;\r\nvideo->width = fmt->fmt.pix.width;\r\nvideo->height = fmt->fmt.pix.height;\r\nvideo->imagesize = imagesize;\r\nfmt->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmt->fmt.pix.bytesperline = bpl;\r\nfmt->fmt.pix.sizeimage = imagesize;\r\nfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nuvc_v4l2_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct uvc_device *uvc = video_get_drvdata(vdev);\r\nstruct uvc_file_handle *handle;\r\nhandle = kzalloc(sizeof(*handle), GFP_KERNEL);\r\nif (handle == NULL)\r\nreturn -ENOMEM;\r\nv4l2_fh_init(&handle->vfh, vdev);\r\nv4l2_fh_add(&handle->vfh);\r\nhandle->device = &uvc->video;\r\nfile->private_data = &handle->vfh;\r\nuvc_function_connect(uvc);\r\nreturn 0;\r\n}\r\nstatic int\r\nuvc_v4l2_release(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct uvc_device *uvc = video_get_drvdata(vdev);\r\nstruct uvc_file_handle *handle = to_uvc_file_handle(file->private_data);\r\nstruct uvc_video *video = handle->device;\r\nuvc_function_disconnect(uvc);\r\nuvc_video_enable(video, 0);\r\nmutex_lock(&video->queue.mutex);\r\nif (uvc_free_buffers(&video->queue) < 0)\r\nprintk(KERN_ERR "uvc_v4l2_release: Unable to free "\r\n"buffers.\n");\r\nmutex_unlock(&video->queue.mutex);\r\nfile->private_data = NULL;\r\nv4l2_fh_del(&handle->vfh);\r\nv4l2_fh_exit(&handle->vfh);\r\nkfree(handle);\r\nreturn 0;\r\n}\r\nstatic long\r\nuvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct uvc_device *uvc = video_get_drvdata(vdev);\r\nstruct uvc_file_handle *handle = to_uvc_file_handle(file->private_data);\r\nstruct usb_composite_dev *cdev = uvc->func.config->cdev;\r\nstruct uvc_video *video = &uvc->video;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase VIDIOC_QUERYCAP:\r\n{\r\nstruct v4l2_capability *cap = arg;\r\nmemset(cap, 0, sizeof *cap);\r\nstrncpy(cap->driver, "g_uvc", sizeof(cap->driver));\r\nstrncpy(cap->card, cdev->gadget->name, sizeof(cap->card));\r\nstrncpy(cap->bus_info, dev_name(&cdev->gadget->dev),\r\nsizeof cap->bus_info);\r\ncap->version = DRIVER_VERSION_NUMBER;\r\ncap->capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\nbreak;\r\n}\r\ncase VIDIOC_G_FMT:\r\n{\r\nstruct v4l2_format *fmt = arg;\r\nif (fmt->type != video->queue.type)\r\nreturn -EINVAL;\r\nreturn uvc_v4l2_get_format(video, fmt);\r\n}\r\ncase VIDIOC_S_FMT:\r\n{\r\nstruct v4l2_format *fmt = arg;\r\nif (fmt->type != video->queue.type)\r\nreturn -EINVAL;\r\nreturn uvc_v4l2_set_format(video, fmt);\r\n}\r\ncase VIDIOC_REQBUFS:\r\n{\r\nstruct v4l2_requestbuffers *rb = arg;\r\nif (rb->type != video->queue.type ||\r\nrb->memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nret = uvc_alloc_buffers(&video->queue, rb->count,\r\nvideo->imagesize);\r\nif (ret < 0)\r\nreturn ret;\r\nrb->count = ret;\r\nret = 0;\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYBUF:\r\n{\r\nstruct v4l2_buffer *buf = arg;\r\nif (buf->type != video->queue.type)\r\nreturn -EINVAL;\r\nreturn uvc_query_buffer(&video->queue, buf);\r\n}\r\ncase VIDIOC_QBUF:\r\nif ((ret = uvc_queue_buffer(&video->queue, arg)) < 0)\r\nreturn ret;\r\nreturn uvc_video_pump(video);\r\ncase VIDIOC_DQBUF:\r\nreturn uvc_dequeue_buffer(&video->queue, arg,\r\nfile->f_flags & O_NONBLOCK);\r\ncase VIDIOC_STREAMON:\r\n{\r\nint *type = arg;\r\nif (*type != video->queue.type)\r\nreturn -EINVAL;\r\nreturn uvc_video_enable(video, 1);\r\n}\r\ncase VIDIOC_STREAMOFF:\r\n{\r\nint *type = arg;\r\nif (*type != video->queue.type)\r\nreturn -EINVAL;\r\nreturn uvc_video_enable(video, 0);\r\n}\r\ncase VIDIOC_DQEVENT:\r\n{\r\nstruct v4l2_event *event = arg;\r\nret = v4l2_event_dequeue(&handle->vfh, event,\r\nfile->f_flags & O_NONBLOCK);\r\nif (ret == 0 && event->type == UVC_EVENT_SETUP) {\r\nstruct uvc_event *uvc_event = (void *)&event->u.data;\r\nuvc->event_setup_out =\r\n!(uvc_event->req.bRequestType & USB_DIR_IN);\r\nuvc->event_length = uvc_event->req.wLength;\r\n}\r\nreturn ret;\r\n}\r\ncase VIDIOC_SUBSCRIBE_EVENT:\r\n{\r\nstruct v4l2_event_subscription *sub = arg;\r\nif (sub->type < UVC_EVENT_FIRST || sub->type > UVC_EVENT_LAST)\r\nreturn -EINVAL;\r\nreturn v4l2_event_subscribe(&handle->vfh, arg, 2, NULL);\r\n}\r\ncase VIDIOC_UNSUBSCRIBE_EVENT:\r\nreturn v4l2_event_unsubscribe(&handle->vfh, arg);\r\ncase UVCIOC_SEND_RESPONSE:\r\nret = uvc_send_response(uvc, arg);\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}\r\nstatic long\r\nuvc_v4l2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn video_usercopy(file, cmd, arg, uvc_v4l2_do_ioctl);\r\n}\r\nstatic int\r\nuvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct uvc_device *uvc = video_get_drvdata(vdev);\r\nreturn uvc_queue_mmap(&uvc->video.queue, vma);\r\n}\r\nstatic unsigned int\r\nuvc_v4l2_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct uvc_device *uvc = video_get_drvdata(vdev);\r\nstruct uvc_file_handle *handle = to_uvc_file_handle(file->private_data);\r\nunsigned int mask = 0;\r\npoll_wait(file, &handle->vfh.wait, wait);\r\nif (v4l2_event_pending(&handle->vfh))\r\nmask |= POLLPRI;\r\nmask |= uvc_queue_poll(&uvc->video.queue, file, wait);\r\nreturn mask;\r\n}
