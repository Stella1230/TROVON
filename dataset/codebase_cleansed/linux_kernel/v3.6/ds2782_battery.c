static inline int ds278x_read_reg(struct ds278x_info *info, int reg, u8 *val)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(info->client, reg);\r\nif (ret < 0) {\r\ndev_err(&info->client->dev, "register read failed\n");\r\nreturn ret;\r\n}\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic inline int ds278x_read_reg16(struct ds278x_info *info, int reg_msb,\r\ns16 *val)\r\n{\r\nint ret;\r\nret = swab16(i2c_smbus_read_word_data(info->client, reg_msb));\r\nif (ret < 0) {\r\ndev_err(&info->client->dev, "register read failed\n");\r\nreturn ret;\r\n}\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic int ds278x_get_temp(struct ds278x_info *info, int *temp)\r\n{\r\ns16 raw;\r\nint err;\r\nerr = ds278x_read_reg16(info, DS278x_REG_TEMP_MSB, &raw);\r\nif (err)\r\nreturn err;\r\n*temp = ((raw / 32) * 125) / 100;\r\nreturn 0;\r\n}\r\nstatic int ds2782_get_current(struct ds278x_info *info, int *current_uA)\r\n{\r\nint sense_res;\r\nint err;\r\nu8 sense_res_raw;\r\ns16 raw;\r\nerr = ds278x_read_reg(info, DS2782_REG_RSNSP, &sense_res_raw);\r\nif (err)\r\nreturn err;\r\nif (sense_res_raw == 0) {\r\ndev_err(&info->client->dev, "sense resistor value is 0\n");\r\nreturn -ENXIO;\r\n}\r\nsense_res = 1000 / sense_res_raw;\r\ndev_dbg(&info->client->dev, "sense resistor = %d milli-ohms\n",\r\nsense_res);\r\nerr = ds278x_read_reg16(info, DS278x_REG_CURRENT_MSB, &raw);\r\nif (err)\r\nreturn err;\r\n*current_uA = raw * (DS2782_CURRENT_UNITS / sense_res);\r\nreturn 0;\r\n}\r\nstatic int ds2782_get_voltage(struct ds278x_info *info, int *voltage_uV)\r\n{\r\ns16 raw;\r\nint err;\r\nerr = ds278x_read_reg16(info, DS278x_REG_VOLT_MSB, &raw);\r\nif (err)\r\nreturn err;\r\n*voltage_uV = (raw / 32) * 4800;\r\nreturn 0;\r\n}\r\nstatic int ds2782_get_capacity(struct ds278x_info *info, int *capacity)\r\n{\r\nint err;\r\nu8 raw;\r\nerr = ds278x_read_reg(info, DS2782_REG_RARC, &raw);\r\nif (err)\r\nreturn err;\r\n*capacity = raw;\r\nreturn 0;\r\n}\r\nstatic int ds2786_get_current(struct ds278x_info *info, int *current_uA)\r\n{\r\nint err;\r\ns16 raw;\r\nerr = ds278x_read_reg16(info, DS278x_REG_CURRENT_MSB, &raw);\r\nif (err)\r\nreturn err;\r\n*current_uA = (raw / 16) * (DS2786_CURRENT_UNITS / info->rsns);\r\nreturn 0;\r\n}\r\nstatic int ds2786_get_voltage(struct ds278x_info *info, int *voltage_uV)\r\n{\r\ns16 raw;\r\nint err;\r\nerr = ds278x_read_reg16(info, DS278x_REG_VOLT_MSB, &raw);\r\nif (err)\r\nreturn err;\r\n*voltage_uV = (raw / 8) * 1220;\r\nreturn 0;\r\n}\r\nstatic int ds2786_get_capacity(struct ds278x_info *info, int *capacity)\r\n{\r\nint err;\r\nu8 raw;\r\nerr = ds278x_read_reg(info, DS2786_REG_RARC, &raw);\r\nif (err)\r\nreturn err;\r\n*capacity = raw/2 ;\r\nreturn 0;\r\n}\r\nstatic int ds278x_get_status(struct ds278x_info *info, int *status)\r\n{\r\nint err;\r\nint current_uA;\r\nint capacity;\r\nerr = info->ops->get_battery_current(info, &current_uA);\r\nif (err)\r\nreturn err;\r\nerr = info->ops->get_battery_capacity(info, &capacity);\r\nif (err)\r\nreturn err;\r\nif (capacity == 100)\r\n*status = POWER_SUPPLY_STATUS_FULL;\r\nelse if (current_uA == 0)\r\n*status = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (current_uA < 0)\r\n*status = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\n*status = POWER_SUPPLY_STATUS_CHARGING;\r\nreturn 0;\r\n}\r\nstatic int ds278x_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property prop,\r\nunion power_supply_propval *val)\r\n{\r\nstruct ds278x_info *info = to_ds278x_info(psy);\r\nint ret;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nret = ds278x_get_status(info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = info->ops->get_battery_capacity(info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nret = info->ops->get_battery_voltage(info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nret = info->ops->get_battery_current(info, &val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nret = ds278x_get_temp(info, &val->intval);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ds278x_power_supply_init(struct power_supply *battery)\r\n{\r\nbattery->type = POWER_SUPPLY_TYPE_BATTERY;\r\nbattery->properties = ds278x_battery_props;\r\nbattery->num_properties = ARRAY_SIZE(ds278x_battery_props);\r\nbattery->get_property = ds278x_battery_get_property;\r\nbattery->external_power_changed = NULL;\r\n}\r\nstatic int ds278x_battery_remove(struct i2c_client *client)\r\n{\r\nstruct ds278x_info *info = i2c_get_clientdata(client);\r\npower_supply_unregister(&info->battery);\r\nkfree(info->battery.name);\r\nmutex_lock(&battery_lock);\r\nidr_remove(&battery_id, info->id);\r\nmutex_unlock(&battery_lock);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int ds278x_battery_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ds278x_platform_data *pdata = client->dev.platform_data;\r\nstruct ds278x_info *info;\r\nint ret;\r\nint num;\r\nif (id->driver_data == DS2786 && !pdata) {\r\ndev_err(&client->dev, "missing platform data for ds2786\n");\r\nreturn -EINVAL;\r\n}\r\nret = idr_pre_get(&battery_id, GFP_KERNEL);\r\nif (ret == 0) {\r\nret = -ENOMEM;\r\ngoto fail_id;\r\n}\r\nmutex_lock(&battery_lock);\r\nret = idr_get_new(&battery_id, client, &num);\r\nmutex_unlock(&battery_lock);\r\nif (ret < 0)\r\ngoto fail_id;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto fail_info;\r\n}\r\ninfo->battery.name = kasprintf(GFP_KERNEL, "%s-%d", client->name, num);\r\nif (!info->battery.name) {\r\nret = -ENOMEM;\r\ngoto fail_name;\r\n}\r\nif (id->driver_data == DS2786)\r\ninfo->rsns = pdata->rsns;\r\ni2c_set_clientdata(client, info);\r\ninfo->client = client;\r\ninfo->id = num;\r\ninfo->ops = &ds278x_ops[id->driver_data];\r\nds278x_power_supply_init(&info->battery);\r\nret = power_supply_register(&client->dev, &info->battery);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to register battery\n");\r\ngoto fail_register;\r\n}\r\nreturn 0;\r\nfail_register:\r\nkfree(info->battery.name);\r\nfail_name:\r\nkfree(info);\r\nfail_info:\r\nmutex_lock(&battery_lock);\r\nidr_remove(&battery_id, num);\r\nmutex_unlock(&battery_lock);\r\nfail_id:\r\nreturn ret;\r\n}
