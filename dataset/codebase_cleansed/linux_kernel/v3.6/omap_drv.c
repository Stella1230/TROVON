static void omap_fb_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nDBG("dev=%p", dev);\r\nif (priv->fbdev) {\r\ndrm_fb_helper_hotplug_event(priv->fbdev);\r\n}\r\n}\r\nstatic int get_connector_type(struct omap_dss_device *dssdev)\r\n{\r\nswitch (dssdev->type) {\r\ncase OMAP_DISPLAY_TYPE_HDMI:\r\nreturn DRM_MODE_CONNECTOR_HDMIA;\r\ncase OMAP_DISPLAY_TYPE_DPI:\r\nif (!strcmp(dssdev->name, "dvi"))\r\nreturn DRM_MODE_CONNECTOR_DVID;\r\ndefault:\r\nreturn DRM_MODE_CONNECTOR_Unknown;\r\n}\r\n}\r\nstatic void dump_video_chains(void)\r\n{\r\nint i;\r\nDBG("dumping video chains: ");\r\nfor (i = 0; i < omap_dss_get_num_overlays(); i++) {\r\nstruct omap_overlay *ovl = omap_dss_get_overlay(i);\r\nstruct omap_overlay_manager *mgr = ovl->manager;\r\nstruct omap_dss_device *dssdev = mgr ? mgr->device : NULL;\r\nif (dssdev) {\r\nDBG("%d: %s -> %s -> %s", i, ovl->name, mgr->name,\r\ndssdev->name);\r\n} else if (mgr) {\r\nDBG("%d: %s -> %s", i, ovl->name, mgr->name);\r\n} else {\r\nDBG("%d: %s", i, ovl->name);\r\n}\r\n}\r\n}\r\nstatic int create_encoder(struct drm_device *dev,\r\nstruct omap_overlay_manager *mgr)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_encoder *encoder = omap_encoder_init(dev, mgr);\r\nif (!encoder) {\r\ndev_err(dev->dev, "could not create encoder: %s\n",\r\nmgr->name);\r\nreturn -ENOMEM;\r\n}\r\nBUG_ON(priv->num_encoders >= ARRAY_SIZE(priv->encoders));\r\npriv->encoders[priv->num_encoders++] = encoder;\r\nreturn 0;\r\n}\r\nstatic int create_connector(struct drm_device *dev,\r\nstruct omap_dss_device *dssdev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstatic struct notifier_block *notifier;\r\nstruct drm_connector *connector;\r\nint j;\r\nif (!dssdev->driver) {\r\ndev_warn(dev->dev, "%s has no driver.. skipping it\n",\r\ndssdev->name);\r\nreturn 0;\r\n}\r\nif (!(dssdev->driver->get_timings ||\r\ndssdev->driver->read_edid)) {\r\ndev_warn(dev->dev, "%s driver does not support "\r\n"get_timings or read_edid.. skipping it!\n",\r\ndssdev->name);\r\nreturn 0;\r\n}\r\nconnector = omap_connector_init(dev,\r\nget_connector_type(dssdev), dssdev);\r\nif (!connector) {\r\ndev_err(dev->dev, "could not create connector: %s\n",\r\ndssdev->name);\r\nreturn -ENOMEM;\r\n}\r\nBUG_ON(priv->num_connectors >= ARRAY_SIZE(priv->connectors));\r\npriv->connectors[priv->num_connectors++] = connector;\r\n#if 0\r\nnotifier = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);\r\nnotifier->notifier_call = omap_drm_notifier;\r\nomap_dss_add_notify(dssdev, notifier);\r\n#else\r\nnotifier = NULL;\r\n#endif\r\nfor (j = 0; j < priv->num_encoders; j++) {\r\nstruct omap_overlay_manager *mgr =\r\nomap_encoder_get_manager(priv->encoders[j]);\r\nif (mgr->device == dssdev) {\r\ndrm_mode_connector_attach_encoder(connector,\r\npriv->encoders[j]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_crtc(struct drm_device *dev, struct omap_overlay *ovl,\r\nint *j, unsigned int connected_connectors)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_overlay_manager *mgr = NULL;\r\nstruct drm_crtc *crtc;\r\nwhile (*j < priv->num_connectors && !mgr) {\r\nif (connected_connectors & (1 << *j)) {\r\nstruct drm_encoder *encoder =\r\nomap_connector_attached_encoder(\r\npriv->connectors[*j]);\r\nif (encoder) {\r\nmgr = omap_encoder_get_manager(encoder);\r\n}\r\n}\r\n(*j)++;\r\n}\r\nwhile (*j < 2 * priv->num_connectors && !mgr) {\r\nint idx = *j - priv->num_connectors;\r\nif (!(connected_connectors & (1 << idx))) {\r\nstruct drm_encoder *encoder =\r\nomap_connector_attached_encoder(\r\npriv->connectors[idx]);\r\nif (encoder) {\r\nmgr = omap_encoder_get_manager(encoder);\r\n}\r\n}\r\n(*j)++;\r\n}\r\ncrtc = omap_crtc_init(dev, ovl, priv->num_crtcs);\r\nif (!crtc) {\r\ndev_err(dev->dev, "could not create CRTC: %s\n",\r\novl->name);\r\nreturn -ENOMEM;\r\n}\r\nBUG_ON(priv->num_crtcs >= ARRAY_SIZE(priv->crtcs));\r\npriv->crtcs[priv->num_crtcs++] = crtc;\r\nreturn 0;\r\n}\r\nstatic int create_plane(struct drm_device *dev, struct omap_overlay *ovl,\r\nunsigned int possible_crtcs)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_plane *plane =\r\nomap_plane_init(dev, ovl, possible_crtcs, false);\r\nif (!plane) {\r\ndev_err(dev->dev, "could not create plane: %s\n",\r\novl->name);\r\nreturn -ENOMEM;\r\n}\r\nBUG_ON(priv->num_planes >= ARRAY_SIZE(priv->planes));\r\npriv->planes[priv->num_planes++] = plane;\r\nreturn 0;\r\n}\r\nstatic int match_dev_name(struct omap_dss_device *dssdev, void *data)\r\n{\r\nreturn !strcmp(dssdev->name, data);\r\n}\r\nstatic unsigned int detect_connectors(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nunsigned int connected_connectors = 0;\r\nint i;\r\nfor (i = 0; i < priv->num_connectors; i++) {\r\nstruct drm_connector *connector = priv->connectors[i];\r\nif (omap_connector_detect(connector, true) ==\r\nconnector_status_connected) {\r\nconnected_connectors |= (1 << i);\r\n}\r\n}\r\nreturn connected_connectors;\r\n}\r\nstatic int omap_modeset_init(struct drm_device *dev)\r\n{\r\nconst struct omap_drm_platform_data *pdata = dev->dev->platform_data;\r\nstruct omap_kms_platform_data *kms_pdata = NULL;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_dss_device *dssdev = NULL;\r\nint i, j;\r\nunsigned int connected_connectors = 0;\r\ndrm_mode_config_init(dev);\r\nif (pdata && pdata->kms_pdata) {\r\nkms_pdata = pdata->kms_pdata;\r\nfor (i = 0; i < kms_pdata->mgr_cnt; i++) {\r\nstruct omap_overlay_manager *mgr =\r\nomap_dss_get_overlay_manager(\r\nkms_pdata->mgr_ids[i]);\r\ncreate_encoder(dev, mgr);\r\n}\r\nfor (i = 0; i < kms_pdata->dev_cnt; i++) {\r\nstruct omap_dss_device *dssdev =\r\nomap_dss_find_device(\r\n(void *)kms_pdata->dev_names[i],\r\nmatch_dev_name);\r\nif (!dssdev) {\r\ndev_warn(dev->dev, "no such dssdev: %s\n",\r\nkms_pdata->dev_names[i]);\r\ncontinue;\r\n}\r\ncreate_connector(dev, dssdev);\r\n}\r\nconnected_connectors = detect_connectors(dev);\r\nj = 0;\r\nfor (i = 0; i < kms_pdata->ovl_cnt; i++) {\r\nstruct omap_overlay *ovl =\r\nomap_dss_get_overlay(kms_pdata->ovl_ids[i]);\r\ncreate_crtc(dev, ovl, &j, connected_connectors);\r\n}\r\nfor (i = 0; i < kms_pdata->pln_cnt; i++) {\r\nstruct omap_overlay *ovl =\r\nomap_dss_get_overlay(kms_pdata->pln_ids[i]);\r\ncreate_plane(dev, ovl, (1 << priv->num_crtcs) - 1);\r\n}\r\n} else {\r\nint max_overlays = min(omap_dss_get_num_overlays(), num_crtc);\r\nfor (i = 0; i < omap_dss_get_num_overlay_managers(); i++) {\r\ncreate_encoder(dev, omap_dss_get_overlay_manager(i));\r\n}\r\nfor_each_dss_dev(dssdev) {\r\ncreate_connector(dev, dssdev);\r\n}\r\nconnected_connectors = detect_connectors(dev);\r\nj = 0;\r\nfor (i = 0; i < max_overlays; i++) {\r\ncreate_crtc(dev, omap_dss_get_overlay(i),\r\n&j, connected_connectors);\r\n}\r\nfor (; i < omap_dss_get_num_overlays(); i++) {\r\nstruct omap_overlay *ovl = omap_dss_get_overlay(i);\r\ncreate_plane(dev, ovl, (1 << priv->num_crtcs) - 1);\r\n}\r\n}\r\nfor (i = 0; i < priv->num_encoders; i++) {\r\nstruct drm_encoder *encoder = priv->encoders[i];\r\nstruct omap_overlay_manager *mgr =\r\nomap_encoder_get_manager(encoder);\r\nencoder->possible_crtcs = (1 << priv->num_crtcs) - 1;\r\nDBG("%s: possible_crtcs=%08x", mgr->name,\r\nencoder->possible_crtcs);\r\n}\r\ndump_video_chains();\r\ndev->mode_config.min_width = 32;\r\ndev->mode_config.min_height = 32;\r\ndev->mode_config.max_width = 2048;\r\ndev->mode_config.max_height = 2048;\r\ndev->mode_config.funcs = &omap_mode_config_funcs;\r\nreturn 0;\r\n}\r\nstatic void omap_modeset_free(struct drm_device *dev)\r\n{\r\ndrm_mode_config_cleanup(dev);\r\n}\r\nstatic int ioctl_get_param(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_param *args = data;\r\nDBG("%p: param=%llu", dev, args->param);\r\nswitch (args->param) {\r\ncase OMAP_PARAM_CHIPSET_ID:\r\nargs->value = GET_OMAP_TYPE;\r\nbreak;\r\ndefault:\r\nDBG("unknown parameter %lld", args->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioctl_set_param(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_param *args = data;\r\nswitch (args->param) {\r\ndefault:\r\nDBG("unknown parameter %lld", args->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioctl_gem_new(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_gem_new *args = data;\r\nDBG("%p:%p: size=0x%08x, flags=%08x", dev, file_priv,\r\nargs->size.bytes, args->flags);\r\nreturn omap_gem_new_handle(dev, file_priv, args->size,\r\nargs->flags, &args->handle);\r\n}\r\nstatic int ioctl_gem_cpu_prep(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_gem_cpu_prep *args = data;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nVERB("%p:%p: handle=%d, op=%x", dev, file_priv, args->handle, args->op);\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (!obj) {\r\nreturn -ENOENT;\r\n}\r\nret = omap_gem_op_sync(obj, args->op);\r\nif (!ret) {\r\nret = omap_gem_op_start(obj, args->op);\r\n}\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int ioctl_gem_cpu_fini(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_gem_cpu_fini *args = data;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nVERB("%p:%p: handle=%d", dev, file_priv, args->handle);\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (!obj) {\r\nreturn -ENOENT;\r\n}\r\nret = 0;\r\nif (!ret) {\r\nret = omap_gem_op_finish(obj, args->op);\r\n}\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int ioctl_gem_info(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_gem_info *args = data;\r\nstruct drm_gem_object *obj;\r\nint ret = 0;\r\nDBG("%p:%p: handle=%d", dev, file_priv, args->handle);\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (!obj) {\r\nreturn -ENOENT;\r\n}\r\nargs->size = omap_gem_mmap_size(obj);\r\nargs->offset = omap_gem_mmap_offset(obj);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int dev_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct omap_drm_private *priv;\r\nint ret;\r\nDBG("load: dev=%p", dev);\r\ndrm_device = dev;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(dev->dev, "could not allocate priv\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dev_private = priv;\r\npriv->wq = alloc_workqueue("omapdrm",\r\nWQ_UNBOUND | WQ_NON_REENTRANT, 1);\r\nINIT_LIST_HEAD(&priv->obj_list);\r\nomap_gem_init(dev);\r\nret = omap_modeset_init(dev);\r\nif (ret) {\r\ndev_err(dev->dev, "omap_modeset_init failed: ret=%d\n", ret);\r\ndev->dev_private = NULL;\r\nkfree(priv);\r\nreturn ret;\r\n}\r\npriv->fbdev = omap_fbdev_init(dev);\r\nif (!priv->fbdev) {\r\ndev_warn(dev->dev, "omap_fbdev_init failed\n");\r\n}\r\ndrm_kms_helper_poll_init(dev);\r\nret = drm_vblank_init(dev, priv->num_crtcs);\r\nif (ret) {\r\ndev_warn(dev->dev, "could not init vblank\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int dev_unload(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nDBG("unload: dev=%p", dev);\r\ndrm_vblank_cleanup(dev);\r\ndrm_kms_helper_poll_fini(dev);\r\nomap_fbdev_free(dev);\r\nomap_modeset_free(dev);\r\nomap_gem_deinit(dev);\r\nflush_workqueue(priv->wq);\r\ndestroy_workqueue(priv->wq);\r\nkfree(dev->dev_private);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nstatic int dev_open(struct drm_device *dev, struct drm_file *file)\r\n{\r\nfile->driver_priv = NULL;\r\nDBG("open: dev=%p, file=%p", dev, file);\r\nreturn 0;\r\n}\r\nstatic int dev_firstopen(struct drm_device *dev)\r\n{\r\nDBG("firstopen: dev=%p", dev);\r\nreturn 0;\r\n}\r\nstatic void dev_lastclose(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nint ret;\r\nDBG("lastclose: dev=%p", dev);\r\nret = drm_fb_helper_restore_fbdev_mode(priv->fbdev);\r\nif (ret)\r\nDBG("failed to restore crtc mode");\r\n}\r\nstatic void dev_preclose(struct drm_device *dev, struct drm_file *file)\r\n{\r\nDBG("preclose: dev=%p", dev);\r\n}\r\nstatic void dev_postclose(struct drm_device *dev, struct drm_file *file)\r\n{\r\nDBG("postclose: dev=%p, file=%p", dev, file);\r\n}\r\nstatic int dev_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nDBG("enable_vblank: dev=%p, crtc=%d", dev, crtc);\r\nreturn 0;\r\n}\r\nstatic void dev_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nDBG("disable_vblank: dev=%p, crtc=%d", dev, crtc);\r\n}\r\nstatic irqreturn_t dev_irq_handler(DRM_IRQ_ARGS)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dev_irq_preinstall(struct drm_device *dev)\r\n{\r\nDBG("irq_preinstall: dev=%p", dev);\r\n}\r\nstatic int dev_irq_postinstall(struct drm_device *dev)\r\n{\r\nDBG("irq_postinstall: dev=%p", dev);\r\nreturn 0;\r\n}\r\nstatic void dev_irq_uninstall(struct drm_device *dev)\r\n{\r\nDBG("irq_uninstall: dev=%p", dev);\r\n}\r\nstatic int pdev_suspend(struct platform_device *pDevice, pm_message_t state)\r\n{\r\nDBG("");\r\nreturn 0;\r\n}\r\nstatic int pdev_resume(struct platform_device *device)\r\n{\r\nDBG("");\r\nreturn 0;\r\n}\r\nstatic void pdev_shutdown(struct platform_device *device)\r\n{\r\nDBG("");\r\n}\r\nstatic int pdev_probe(struct platform_device *device)\r\n{\r\nDBG("%s", device->name);\r\nreturn drm_platform_init(&omap_drm_driver, device);\r\n}\r\nstatic int pdev_remove(struct platform_device *device)\r\n{\r\nDBG("");\r\ndrm_platform_exit(&omap_drm_driver, device);\r\nplatform_driver_unregister(&omap_dmm_driver);\r\nreturn 0;\r\n}\r\nstatic int __init omap_drm_init(void)\r\n{\r\nDBG("init");\r\nif (platform_driver_register(&omap_dmm_driver)) {\r\ndev_err(NULL, "DMM registration failed\n");\r\n}\r\nreturn platform_driver_register(&pdev);\r\n}\r\nstatic void __exit omap_drm_fini(void)\r\n{\r\nDBG("fini");\r\nplatform_driver_unregister(&pdev);\r\n}
