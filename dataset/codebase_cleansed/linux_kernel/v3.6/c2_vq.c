int vq_init(struct c2_dev *c2dev)\r\n{\r\nsprintf(c2dev->vq_cache_name, "c2-vq:dev%c",\r\n(char) ('0' + c2dev->devnum));\r\nc2dev->host_msg_cache =\r\nkmem_cache_create(c2dev->vq_cache_name, c2dev->rep_vq.msg_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (c2dev->host_msg_cache == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid vq_term(struct c2_dev *c2dev)\r\n{\r\nkmem_cache_destroy(c2dev->host_msg_cache);\r\n}\r\nstruct c2_vq_req *vq_req_alloc(struct c2_dev *c2dev)\r\n{\r\nstruct c2_vq_req *r;\r\nr = kmalloc(sizeof(struct c2_vq_req), GFP_KERNEL);\r\nif (r) {\r\ninit_waitqueue_head(&r->wait_object);\r\nr->reply_msg = 0;\r\nr->event = 0;\r\nr->cm_id = NULL;\r\nr->qp = NULL;\r\natomic_set(&r->refcnt, 1);\r\natomic_set(&r->reply_ready, 0);\r\n}\r\nreturn r;\r\n}\r\nvoid vq_req_free(struct c2_dev *c2dev, struct c2_vq_req *r)\r\n{\r\nr->reply_msg = 0;\r\nif (atomic_dec_and_test(&r->refcnt)) {\r\nkfree(r);\r\n}\r\n}\r\nvoid vq_req_get(struct c2_dev *c2dev, struct c2_vq_req *r)\r\n{\r\natomic_inc(&r->refcnt);\r\n}\r\nvoid vq_req_put(struct c2_dev *c2dev, struct c2_vq_req *r)\r\n{\r\nif (atomic_dec_and_test(&r->refcnt)) {\r\nif (r->reply_msg != 0)\r\nvq_repbuf_free(c2dev,\r\n(void *) (unsigned long) r->reply_msg);\r\nkfree(r);\r\n}\r\n}\r\nvoid *vq_repbuf_alloc(struct c2_dev *c2dev)\r\n{\r\nreturn kmem_cache_alloc(c2dev->host_msg_cache, GFP_ATOMIC);\r\n}\r\nint vq_send_wr(struct c2_dev *c2dev, union c2wr *wr)\r\n{\r\nvoid *msg;\r\nwait_queue_t __wait;\r\nspin_lock(&c2dev->vqlock);\r\nmsg = c2_mq_alloc(&c2dev->req_vq);\r\nwhile (msg == NULL) {\r\npr_debug("%s:%d no available msg in VQ, waiting...\n",\r\n__func__, __LINE__);\r\ninit_waitqueue_entry(&__wait, current);\r\nadd_wait_queue(&c2dev->req_vq_wo, &__wait);\r\nspin_unlock(&c2dev->vqlock);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!c2_mq_full(&c2dev->req_vq)) {\r\nbreak;\r\n}\r\nif (!signal_pending(current)) {\r\nschedule_timeout(1 * HZ);\r\ncontinue;\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&c2dev->req_vq_wo, &__wait);\r\nreturn -EINTR;\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&c2dev->req_vq_wo, &__wait);\r\nspin_lock(&c2dev->vqlock);\r\nmsg = c2_mq_alloc(&c2dev->req_vq);\r\n}\r\nmemcpy(msg, wr, c2dev->req_vq.msg_size);\r\nc2_mq_produce(&c2dev->req_vq);\r\nspin_unlock(&c2dev->vqlock);\r\nreturn 0;\r\n}\r\nint vq_wait_for_reply(struct c2_dev *c2dev, struct c2_vq_req *req)\r\n{\r\nif (!wait_event_timeout(req->wait_object,\r\natomic_read(&req->reply_ready),\r\n60*HZ))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nvoid vq_repbuf_free(struct c2_dev *c2dev, void *reply)\r\n{\r\nkmem_cache_free(c2dev->host_msg_cache, reply);\r\n}
