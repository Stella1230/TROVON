static void samsung_keypad_scan(struct samsung_keypad *keypad,\r\nunsigned int *row_state)\r\n{\r\nunsigned int col;\r\nunsigned int val;\r\nfor (col = 0; col < keypad->cols; col++) {\r\nif (keypad->type == KEYPAD_TYPE_S5PV210) {\r\nval = S5PV210_KEYIFCOLEN_MASK;\r\nval &= ~(1 << col) << 8;\r\n} else {\r\nval = SAMSUNG_KEYIFCOL_MASK;\r\nval &= ~(1 << col);\r\n}\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCOL);\r\nmdelay(1);\r\nval = readl(keypad->base + SAMSUNG_KEYIFROW);\r\nrow_state[col] = ~val & ((1 << keypad->rows) - 1);\r\n}\r\nwritel(0, keypad->base + SAMSUNG_KEYIFCOL);\r\n}\r\nstatic bool samsung_keypad_report(struct samsung_keypad *keypad,\r\nunsigned int *row_state)\r\n{\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nunsigned int changed;\r\nunsigned int pressed;\r\nunsigned int key_down = 0;\r\nunsigned int val;\r\nunsigned int col, row;\r\nfor (col = 0; col < keypad->cols; col++) {\r\nchanged = row_state[col] ^ keypad->row_state[col];\r\nkey_down |= row_state[col];\r\nif (!changed)\r\ncontinue;\r\nfor (row = 0; row < keypad->rows; row++) {\r\nif (!(changed & (1 << row)))\r\ncontinue;\r\npressed = row_state[col] & (1 << row);\r\ndev_dbg(&keypad->input_dev->dev,\r\n"key %s, row: %d, col: %d\n",\r\npressed ? "pressed" : "released", row, col);\r\nval = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, val);\r\ninput_report_key(input_dev,\r\nkeypad->keycodes[val], pressed);\r\n}\r\ninput_sync(keypad->input_dev);\r\n}\r\nmemcpy(keypad->row_state, row_state, sizeof(keypad->row_state));\r\nreturn key_down;\r\n}\r\nstatic irqreturn_t samsung_keypad_irq(int irq, void *dev_id)\r\n{\r\nstruct samsung_keypad *keypad = dev_id;\r\nunsigned int row_state[SAMSUNG_MAX_COLS];\r\nunsigned int val;\r\nbool key_down;\r\npm_runtime_get_sync(&keypad->pdev->dev);\r\ndo {\r\nval = readl(keypad->base + SAMSUNG_KEYIFSTSCLR);\r\nwritel(~0x0, keypad->base + SAMSUNG_KEYIFSTSCLR);\r\nsamsung_keypad_scan(keypad, row_state);\r\nkey_down = samsung_keypad_report(keypad, row_state);\r\nif (key_down)\r\nwait_event_timeout(keypad->wait, keypad->stopped,\r\nmsecs_to_jiffies(50));\r\n} while (key_down && !keypad->stopped);\r\npm_runtime_put(&keypad->pdev->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void samsung_keypad_start(struct samsung_keypad *keypad)\r\n{\r\nunsigned int val;\r\npm_runtime_get_sync(&keypad->pdev->dev);\r\nkeypad->stopped = false;\r\nclk_enable(keypad->clk);\r\nval = readl(keypad->base + SAMSUNG_KEYIFCON);\r\nval |= SAMSUNG_KEYIFCON_INT_F_EN | SAMSUNG_KEYIFCON_INT_R_EN;\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCON);\r\nwritel(0, keypad->base + SAMSUNG_KEYIFCOL);\r\npm_runtime_put(&keypad->pdev->dev);\r\n}\r\nstatic void samsung_keypad_stop(struct samsung_keypad *keypad)\r\n{\r\nunsigned int val;\r\npm_runtime_get_sync(&keypad->pdev->dev);\r\nkeypad->stopped = true;\r\nwake_up(&keypad->wait);\r\ndisable_irq(keypad->irq);\r\nwritel(~0x0, keypad->base + SAMSUNG_KEYIFSTSCLR);\r\nval = readl(keypad->base + SAMSUNG_KEYIFCON);\r\nval &= ~(SAMSUNG_KEYIFCON_INT_F_EN | SAMSUNG_KEYIFCON_INT_R_EN);\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCON);\r\nclk_disable(keypad->clk);\r\nenable_irq(keypad->irq);\r\npm_runtime_put(&keypad->pdev->dev);\r\n}\r\nstatic int samsung_keypad_open(struct input_dev *input_dev)\r\n{\r\nstruct samsung_keypad *keypad = input_get_drvdata(input_dev);\r\nsamsung_keypad_start(keypad);\r\nreturn 0;\r\n}\r\nstatic void samsung_keypad_close(struct input_dev *input_dev)\r\n{\r\nstruct samsung_keypad *keypad = input_get_drvdata(input_dev);\r\nsamsung_keypad_stop(keypad);\r\n}\r\nstatic struct samsung_keypad_platdata *samsung_keypad_parse_dt(\r\nstruct device *dev)\r\n{\r\nstruct samsung_keypad_platdata *pdata;\r\nstruct matrix_keymap_data *keymap_data;\r\nuint32_t *keymap, num_rows = 0, num_cols = 0;\r\nstruct device_node *np = dev->of_node, *key_np;\r\nunsigned int key_count = 0;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(dev, "could not allocate memory for platform data\n");\r\nreturn NULL;\r\n}\r\nof_property_read_u32(np, "samsung,keypad-num-rows", &num_rows);\r\nof_property_read_u32(np, "samsung,keypad-num-columns", &num_cols);\r\nif (!num_rows || !num_cols) {\r\ndev_err(dev, "number of keypad rows/columns not specified\n");\r\nreturn NULL;\r\n}\r\npdata->rows = num_rows;\r\npdata->cols = num_cols;\r\nkeymap_data = devm_kzalloc(dev, sizeof(*keymap_data), GFP_KERNEL);\r\nif (!keymap_data) {\r\ndev_err(dev, "could not allocate memory for keymap data\n");\r\nreturn NULL;\r\n}\r\npdata->keymap_data = keymap_data;\r\nfor_each_child_of_node(np, key_np)\r\nkey_count++;\r\nkeymap_data->keymap_size = key_count;\r\nkeymap = devm_kzalloc(dev, sizeof(uint32_t) * key_count, GFP_KERNEL);\r\nif (!keymap) {\r\ndev_err(dev, "could not allocate memory for keymap\n");\r\nreturn NULL;\r\n}\r\nkeymap_data->keymap = keymap;\r\nfor_each_child_of_node(np, key_np) {\r\nu32 row, col, key_code;\r\nof_property_read_u32(key_np, "keypad,row", &row);\r\nof_property_read_u32(key_np, "keypad,column", &col);\r\nof_property_read_u32(key_np, "linux,code", &key_code);\r\n*keymap++ = KEY(row, col, key_code);\r\n}\r\nif (of_get_property(np, "linux,input-no-autorepeat", NULL))\r\npdata->no_autorepeat = true;\r\nif (of_get_property(np, "linux,input-wakeup", NULL))\r\npdata->wakeup = true;\r\nreturn pdata;\r\n}\r\nstatic void samsung_keypad_parse_dt_gpio(struct device *dev,\r\nstruct samsung_keypad *keypad)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nint gpio, ret, row, col;\r\nfor (row = 0; row < keypad->rows; row++) {\r\ngpio = of_get_named_gpio(np, "row-gpios", row);\r\nkeypad->row_gpios[row] = gpio;\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(dev, "keypad row[%d]: invalid gpio %d\n",\r\nrow, gpio);\r\ncontinue;\r\n}\r\nret = gpio_request(gpio, "keypad-row");\r\nif (ret)\r\ndev_err(dev, "keypad row[%d] gpio request failed\n",\r\nrow);\r\n}\r\nfor (col = 0; col < keypad->cols; col++) {\r\ngpio = of_get_named_gpio(np, "col-gpios", col);\r\nkeypad->col_gpios[col] = gpio;\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(dev, "keypad column[%d]: invalid gpio %d\n",\r\ncol, gpio);\r\ncontinue;\r\n}\r\nret = gpio_request(gpio, "keypad-col");\r\nif (ret)\r\ndev_err(dev, "keypad column[%d] gpio request failed\n",\r\ncol);\r\n}\r\n}\r\nstatic void samsung_keypad_dt_gpio_free(struct samsung_keypad *keypad)\r\n{\r\nint cnt;\r\nfor (cnt = 0; cnt < keypad->rows; cnt++)\r\nif (gpio_is_valid(keypad->row_gpios[cnt]))\r\ngpio_free(keypad->row_gpios[cnt]);\r\nfor (cnt = 0; cnt < keypad->cols; cnt++)\r\nif (gpio_is_valid(keypad->col_gpios[cnt]))\r\ngpio_free(keypad->col_gpios[cnt]);\r\n}\r\nstatic\r\nstruct samsung_keypad_platdata *samsung_keypad_parse_dt(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void samsung_keypad_dt_gpio_free(struct samsung_keypad *keypad)\r\n{\r\n}\r\nstatic int __devinit samsung_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct samsung_keypad_platdata *pdata;\r\nconst struct matrix_keymap_data *keymap_data;\r\nstruct samsung_keypad *keypad;\r\nstruct resource *res;\r\nstruct input_dev *input_dev;\r\nunsigned int row_shift;\r\nunsigned int keymap_size;\r\nint error;\r\nif (pdev->dev.of_node)\r\npdata = samsung_keypad_parse_dt(&pdev->dev);\r\nelse\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nkeymap_data = pdata->keymap_data;\r\nif (!keymap_data) {\r\ndev_err(&pdev->dev, "no keymap data defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->rows || pdata->rows > SAMSUNG_MAX_ROWS)\r\nreturn -EINVAL;\r\nif (!pdata->cols || pdata->cols > SAMSUNG_MAX_COLS)\r\nreturn -EINVAL;\r\nif (pdata->cfg_gpio)\r\npdata->cfg_gpio(pdata->rows, pdata->cols);\r\nrow_shift = get_count_order(pdata->cols);\r\nkeymap_size = (pdata->rows << row_shift) * sizeof(keypad->keycodes[0]);\r\nkeypad = kzalloc(sizeof(*keypad) + keymap_size, GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!keypad || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerror = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\nkeypad->base = ioremap(res->start, resource_size(res));\r\nif (!keypad->base) {\r\nerror = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\nkeypad->clk = clk_get(&pdev->dev, "keypad");\r\nif (IS_ERR(keypad->clk)) {\r\ndev_err(&pdev->dev, "failed to get keypad clk\n");\r\nerror = PTR_ERR(keypad->clk);\r\ngoto err_unmap_base;\r\n}\r\nkeypad->input_dev = input_dev;\r\nkeypad->pdev = pdev;\r\nkeypad->row_shift = row_shift;\r\nkeypad->rows = pdata->rows;\r\nkeypad->cols = pdata->cols;\r\nkeypad->stopped = true;\r\ninit_waitqueue_head(&keypad->wait);\r\nif (pdev->dev.of_node) {\r\n#ifdef CONFIG_OF\r\nsamsung_keypad_parse_dt_gpio(&pdev->dev, keypad);\r\nkeypad->type = of_device_is_compatible(pdev->dev.of_node,\r\n"samsung,s5pv210-keypad");\r\n#endif\r\n} else {\r\nkeypad->type = platform_get_device_id(pdev)->driver_data;\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = samsung_keypad_open;\r\ninput_dev->close = samsung_keypad_close;\r\nerror = matrix_keypad_build_keymap(keymap_data, NULL,\r\npdata->rows, pdata->cols,\r\nkeypad->keycodes, input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to build keymap\n");\r\ngoto err_put_clk;\r\n}\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\nif (!pdata->no_autorepeat)\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_drvdata(input_dev, keypad);\r\nkeypad->irq = platform_get_irq(pdev, 0);\r\nif (keypad->irq < 0) {\r\nerror = keypad->irq;\r\ngoto err_put_clk;\r\n}\r\nerror = request_threaded_irq(keypad->irq, NULL, samsung_keypad_irq,\r\nIRQF_ONESHOT, dev_name(&pdev->dev), keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register keypad interrupt\n");\r\ngoto err_put_clk;\r\n}\r\ndevice_init_wakeup(&pdev->dev, pdata->wakeup);\r\nplatform_set_drvdata(pdev, keypad);\r\npm_runtime_enable(&pdev->dev);\r\nerror = input_register_device(keypad->input_dev);\r\nif (error)\r\ngoto err_free_irq;\r\nif (pdev->dev.of_node) {\r\ndevm_kfree(&pdev->dev, (void *)pdata->keymap_data->keymap);\r\ndevm_kfree(&pdev->dev, (void *)pdata->keymap_data);\r\ndevm_kfree(&pdev->dev, (void *)pdata);\r\n}\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(keypad->irq, keypad);\r\npm_runtime_disable(&pdev->dev);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nplatform_set_drvdata(pdev, NULL);\r\nerr_put_clk:\r\nclk_put(keypad->clk);\r\nsamsung_keypad_dt_gpio_free(keypad);\r\nerr_unmap_base:\r\niounmap(keypad->base);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(keypad);\r\nreturn error;\r\n}\r\nstatic int __devexit samsung_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nplatform_set_drvdata(pdev, NULL);\r\ninput_unregister_device(keypad->input_dev);\r\nfree_irq(keypad->irq, keypad);\r\nclk_put(keypad->clk);\r\nsamsung_keypad_dt_gpio_free(keypad);\r\niounmap(keypad->base);\r\nkfree(keypad);\r\nreturn 0;\r\n}\r\nstatic int samsung_keypad_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\r\nunsigned int val;\r\nint error;\r\nif (keypad->stopped)\r\nreturn 0;\r\nerror = enable_irq_wake(keypad->irq);\r\nif (!error)\r\nkeypad->wake_enabled = true;\r\nval = readl(keypad->base + SAMSUNG_KEYIFCON);\r\nval |= SAMSUNG_KEYIFCON_WAKEUPEN;\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCON);\r\nclk_disable(keypad->clk);\r\nreturn 0;\r\n}\r\nstatic int samsung_keypad_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\r\nunsigned int val;\r\nif (keypad->stopped)\r\nreturn 0;\r\nclk_enable(keypad->clk);\r\nval = readl(keypad->base + SAMSUNG_KEYIFCON);\r\nval &= ~SAMSUNG_KEYIFCON_WAKEUPEN;\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCON);\r\nif (keypad->wake_enabled)\r\ndisable_irq_wake(keypad->irq);\r\nreturn 0;\r\n}\r\nstatic void samsung_keypad_toggle_wakeup(struct samsung_keypad *keypad,\r\nbool enable)\r\n{\r\nunsigned int val;\r\nclk_enable(keypad->clk);\r\nval = readl(keypad->base + SAMSUNG_KEYIFCON);\r\nif (enable) {\r\nval |= SAMSUNG_KEYIFCON_WAKEUPEN;\r\nif (device_may_wakeup(&keypad->pdev->dev))\r\nenable_irq_wake(keypad->irq);\r\n} else {\r\nval &= ~SAMSUNG_KEYIFCON_WAKEUPEN;\r\nif (device_may_wakeup(&keypad->pdev->dev))\r\ndisable_irq_wake(keypad->irq);\r\n}\r\nwritel(val, keypad->base + SAMSUNG_KEYIFCON);\r\nclk_disable(keypad->clk);\r\n}\r\nstatic int samsung_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nsamsung_keypad_stop(keypad);\r\nsamsung_keypad_toggle_wakeup(keypad, true);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int samsung_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct samsung_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nsamsung_keypad_toggle_wakeup(keypad, false);\r\nif (input_dev->users)\r\nsamsung_keypad_start(keypad);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}
