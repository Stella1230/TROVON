static int ehea_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ehea_port *port = netdev_priv(dev);\r\nu32 speed;\r\nint ret;\r\nret = ehea_sense_port_attr(port);\r\nif (ret)\r\nreturn ret;\r\nif (netif_carrier_ok(dev)) {\r\nswitch (port->port_speed) {\r\ncase EHEA_SPEED_10M:\r\nspeed = SPEED_10;\r\nbreak;\r\ncase EHEA_SPEED_100M:\r\nspeed = SPEED_100;\r\nbreak;\r\ncase EHEA_SPEED_1G:\r\nspeed = SPEED_1000;\r\nbreak;\r\ncase EHEA_SPEED_10G:\r\nspeed = SPEED_10000;\r\nbreak;\r\ndefault:\r\nspeed = -1;\r\nbreak;\r\n}\r\ncmd->duplex = port->full_duplex == 1 ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\n} else {\r\nspeed = ~0;\r\ncmd->duplex = -1;\r\n}\r\nethtool_cmd_speed_set(cmd, speed);\r\nif (cmd->speed == SPEED_10000) {\r\ncmd->supported = (SUPPORTED_10000baseT_Full | SUPPORTED_FIBRE);\r\ncmd->advertising = (ADVERTISED_10000baseT_Full | ADVERTISED_FIBRE);\r\ncmd->port = PORT_FIBRE;\r\n} else {\r\ncmd->supported = (SUPPORTED_1000baseT_Full | SUPPORTED_100baseT_Full\r\n| SUPPORTED_100baseT_Half | SUPPORTED_10baseT_Full\r\n| SUPPORTED_10baseT_Half | SUPPORTED_Autoneg\r\n| SUPPORTED_TP);\r\ncmd->advertising = (ADVERTISED_1000baseT_Full | ADVERTISED_Autoneg\r\n| ADVERTISED_TP);\r\ncmd->port = PORT_TP;\r\n}\r\ncmd->autoneg = port->autoneg == 1 ? AUTONEG_ENABLE : AUTONEG_DISABLE;\r\nreturn 0;\r\n}\r\nstatic int ehea_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ehea_port *port = netdev_priv(dev);\r\nint ret = 0;\r\nu32 sp;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nsp = EHEA_SPEED_AUTONEG;\r\ngoto doit;\r\n}\r\nswitch (cmd->speed) {\r\ncase SPEED_10:\r\nif (cmd->duplex == DUPLEX_FULL)\r\nsp = H_SPEED_10M_F;\r\nelse\r\nsp = H_SPEED_10M_H;\r\nbreak;\r\ncase SPEED_100:\r\nif (cmd->duplex == DUPLEX_FULL)\r\nsp = H_SPEED_100M_F;\r\nelse\r\nsp = H_SPEED_100M_H;\r\nbreak;\r\ncase SPEED_1000:\r\nif (cmd->duplex == DUPLEX_FULL)\r\nsp = H_SPEED_1G_F;\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ncase SPEED_10000:\r\nif (cmd->duplex == DUPLEX_FULL)\r\nsp = H_SPEED_10G_F;\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret)\r\ngoto out;\r\ndoit:\r\nret = ehea_set_portspeed(port, sp);\r\nif (!ret)\r\nnetdev_info(dev,\r\n"Port speed successfully set: %dMbps %s Duplex\n",\r\nport->port_speed,\r\nport->full_duplex == 1 ? "Full" : "Half");\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ehea_nway_reset(struct net_device *dev)\r\n{\r\nstruct ehea_port *port = netdev_priv(dev);\r\nint ret;\r\nret = ehea_set_portspeed(port, EHEA_SPEED_AUTONEG);\r\nif (!ret)\r\nnetdev_info(port->netdev,\r\n"Port speed successfully set: %dMbps %s Duplex\n",\r\nport->port_speed,\r\nport->full_duplex == 1 ? "Full" : "Half");\r\nreturn ret;\r\n}\r\nstatic void ehea_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\n}\r\nstatic u32 ehea_get_msglevel(struct net_device *dev)\r\n{\r\nstruct ehea_port *port = netdev_priv(dev);\r\nreturn port->msg_enable;\r\n}\r\nstatic void ehea_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct ehea_port *port = netdev_priv(dev);\r\nport->msg_enable = value;\r\n}\r\nstatic void ehea_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nif (stringset == ETH_SS_STATS) {\r\nmemcpy(data, &ehea_ethtool_stats_keys,\r\nsizeof(ehea_ethtool_stats_keys));\r\n}\r\n}\r\nstatic int ehea_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(ehea_ethtool_stats_keys);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void ehea_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nint i, k, tmp;\r\nstruct ehea_port *port = netdev_priv(dev);\r\nfor (i = 0; i < ehea_get_sset_count(dev, ETH_SS_STATS); i++)\r\ndata[i] = 0;\r\ni = 0;\r\ndata[i++] = port->sig_comp_iv;\r\ndata[i++] = port->port_res[0].swqe_refill_th;\r\ndata[i++] = port->resets;\r\nfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\r\ntmp += port->port_res[k].p_stats.poll_receive_errors;\r\ndata[i++] = tmp;\r\nfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\r\ntmp += port->port_res[k].p_stats.err_tcp_cksum;\r\ndata[i++] = tmp;\r\nfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\r\ntmp += port->port_res[k].p_stats.err_ip_cksum;\r\ndata[i++] = tmp;\r\nfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\r\ntmp += port->port_res[k].p_stats.err_frame_crc;\r\ndata[i++] = tmp;\r\nfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\r\ntmp += port->port_res[k].p_stats.queue_stopped;\r\ndata[i++] = tmp;\r\nfor (k = 0; k < 16; k++)\r\ndata[i++] = atomic_read(&port->port_res[k].swqe_avail);\r\n}\r\nvoid ehea_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nSET_ETHTOOL_OPS(netdev, &ehea_ethtool_ops);\r\n}
