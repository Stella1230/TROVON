static void update_edgeport_E2PROM(struct edgeport_serial *edge_serial)\r\n{\r\n__u32 BootCurVer;\r\n__u32 BootNewVer;\r\n__u8 BootMajorVersion;\r\n__u8 BootMinorVersion;\r\n__u16 BootBuildNumber;\r\n__u32 Bootaddr;\r\nconst struct ihex_binrec *rec;\r\nconst struct firmware *fw;\r\nconst char *fw_name;\r\nint response;\r\nswitch (edge_serial->product_info.iDownloadFile) {\r\ncase EDGE_DOWNLOAD_FILE_I930:\r\nfw_name = "edgeport/boot.fw";\r\nbreak;\r\ncase EDGE_DOWNLOAD_FILE_80251:\r\nfw_name = "edgeport/boot2.fw";\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nresponse = request_ihex_firmware(&fw, fw_name,\r\n&edge_serial->serial->dev->dev);\r\nif (response) {\r\nprintk(KERN_ERR "Failed to load image \"%s\" err %d\n",\r\nfw_name, response);\r\nreturn;\r\n}\r\nrec = (const struct ihex_binrec *)fw->data;\r\nBootMajorVersion = rec->data[0];\r\nBootMinorVersion = rec->data[1];\r\nBootBuildNumber = (rec->data[2] << 8) | rec->data[3];\r\nBootCurVer = (edge_serial->boot_descriptor.MajorVersion << 24) +\r\n(edge_serial->boot_descriptor.MinorVersion << 16) +\r\nle16_to_cpu(edge_serial->boot_descriptor.BuildNumber);\r\nBootNewVer = (BootMajorVersion << 24) +\r\n(BootMinorVersion << 16) +\r\nBootBuildNumber;\r\ndbg("Current Boot Image version %d.%d.%d",\r\nedge_serial->boot_descriptor.MajorVersion,\r\nedge_serial->boot_descriptor.MinorVersion,\r\nle16_to_cpu(edge_serial->boot_descriptor.BuildNumber));\r\nif (BootNewVer > BootCurVer) {\r\ndbg("**Update Boot Image from %d.%d.%d to %d.%d.%d",\r\nedge_serial->boot_descriptor.MajorVersion,\r\nedge_serial->boot_descriptor.MinorVersion,\r\nle16_to_cpu(edge_serial->boot_descriptor.BuildNumber),\r\nBootMajorVersion, BootMinorVersion, BootBuildNumber);\r\ndbg("Downloading new Boot Image");\r\nfor (rec = ihex_next_binrec(rec); rec;\r\nrec = ihex_next_binrec(rec)) {\r\nBootaddr = be32_to_cpu(rec->addr);\r\nresponse = rom_write(edge_serial->serial,\r\nBootaddr >> 16,\r\nBootaddr & 0xFFFF,\r\nbe16_to_cpu(rec->len),\r\n&rec->data[0]);\r\nif (response < 0) {\r\ndev_err(&edge_serial->serial->dev->dev,\r\n"rom_write failed (%x, %x, %d)\n",\r\nBootaddr >> 16, Bootaddr & 0xFFFF,\r\nbe16_to_cpu(rec->len));\r\nbreak;\r\n}\r\n}\r\n} else {\r\ndbg("Boot Image -- already up to date");\r\n}\r\nrelease_firmware(fw);\r\n}\r\nstatic void dump_product_info(struct edgeport_product_info *product_info)\r\n{\r\ndbg("**Product Information:");\r\ndbg(" ProductId %x", product_info->ProductId);\r\ndbg(" NumPorts %d", product_info->NumPorts);\r\ndbg(" ProdInfoVer %d", product_info->ProdInfoVer);\r\ndbg(" IsServer %d", product_info->IsServer);\r\ndbg(" IsRS232 %d", product_info->IsRS232);\r\ndbg(" IsRS422 %d", product_info->IsRS422);\r\ndbg(" IsRS485 %d", product_info->IsRS485);\r\ndbg(" RomSize %d", product_info->RomSize);\r\ndbg(" RamSize %d", product_info->RamSize);\r\ndbg(" CpuRev %x", product_info->CpuRev);\r\ndbg(" BoardRev %x", product_info->BoardRev);\r\ndbg(" BootMajorVersion %d.%d.%d", product_info->BootMajorVersion,\r\nproduct_info->BootMinorVersion,\r\nle16_to_cpu(product_info->BootBuildNumber));\r\ndbg(" FirmwareMajorVersion %d.%d.%d",\r\nproduct_info->FirmwareMajorVersion,\r\nproduct_info->FirmwareMinorVersion,\r\nle16_to_cpu(product_info->FirmwareBuildNumber));\r\ndbg(" ManufactureDescDate %d/%d/%d",\r\nproduct_info->ManufactureDescDate[0],\r\nproduct_info->ManufactureDescDate[1],\r\nproduct_info->ManufactureDescDate[2]+1900);\r\ndbg(" iDownloadFile 0x%x", product_info->iDownloadFile);\r\ndbg(" EpicVer %d", product_info->EpicVer);\r\n}\r\nstatic void get_product_info(struct edgeport_serial *edge_serial)\r\n{\r\nstruct edgeport_product_info *product_info = &edge_serial->product_info;\r\nmemset(product_info, 0, sizeof(struct edgeport_product_info));\r\nproduct_info->ProductId = (__u16)(le16_to_cpu(edge_serial->serial->dev->descriptor.idProduct) & ~ION_DEVICE_ID_80251_NETCHIP);\r\nproduct_info->NumPorts = edge_serial->manuf_descriptor.NumPorts;\r\nproduct_info->ProdInfoVer = 0;\r\nproduct_info->RomSize = edge_serial->manuf_descriptor.RomSize;\r\nproduct_info->RamSize = edge_serial->manuf_descriptor.RamSize;\r\nproduct_info->CpuRev = edge_serial->manuf_descriptor.CpuRev;\r\nproduct_info->BoardRev = edge_serial->manuf_descriptor.BoardRev;\r\nproduct_info->BootMajorVersion =\r\nedge_serial->boot_descriptor.MajorVersion;\r\nproduct_info->BootMinorVersion =\r\nedge_serial->boot_descriptor.MinorVersion;\r\nproduct_info->BootBuildNumber =\r\nedge_serial->boot_descriptor.BuildNumber;\r\nmemcpy(product_info->ManufactureDescDate,\r\nedge_serial->manuf_descriptor.DescDate,\r\nsizeof(edge_serial->manuf_descriptor.DescDate));\r\nif (le16_to_cpu(edge_serial->serial->dev->descriptor.idProduct)\r\n& ION_DEVICE_ID_80251_NETCHIP)\r\nproduct_info->iDownloadFile = EDGE_DOWNLOAD_FILE_80251;\r\nelse\r\nproduct_info->iDownloadFile = EDGE_DOWNLOAD_FILE_I930;\r\nswitch (DEVICE_ID_FROM_USB_PRODUCT_ID(product_info->ProductId)) {\r\ncase ION_DEVICE_ID_EDGEPORT_COMPATIBLE:\r\ncase ION_DEVICE_ID_EDGEPORT_4T:\r\ncase ION_DEVICE_ID_EDGEPORT_4:\r\ncase ION_DEVICE_ID_EDGEPORT_2:\r\ncase ION_DEVICE_ID_EDGEPORT_8_DUAL_CPU:\r\ncase ION_DEVICE_ID_EDGEPORT_8:\r\ncase ION_DEVICE_ID_EDGEPORT_421:\r\ncase ION_DEVICE_ID_EDGEPORT_21:\r\ncase ION_DEVICE_ID_EDGEPORT_2_DIN:\r\ncase ION_DEVICE_ID_EDGEPORT_4_DIN:\r\ncase ION_DEVICE_ID_EDGEPORT_16_DUAL_CPU:\r\nproduct_info->IsRS232 = 1;\r\nbreak;\r\ncase ION_DEVICE_ID_EDGEPORT_2I:\r\nproduct_info->IsRS422 = 1;\r\nproduct_info->IsRS485 = 1;\r\nbreak;\r\ncase ION_DEVICE_ID_EDGEPORT_8I:\r\ncase ION_DEVICE_ID_EDGEPORT_4I:\r\nproduct_info->IsRS422 = 1;\r\nbreak;\r\n}\r\ndump_product_info(product_info);\r\n}\r\nstatic int get_epic_descriptor(struct edgeport_serial *ep)\r\n{\r\nint result;\r\nstruct usb_serial *serial = ep->serial;\r\nstruct edgeport_product_info *product_info = &ep->product_info;\r\nstruct edge_compatibility_descriptor *epic = &ep->epic_descriptor;\r\nstruct edge_compatibility_bits *bits;\r\nep->is_epic = 0;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nUSB_REQUEST_ION_GET_EPIC_DESC,\r\n0xC0, 0x00, 0x00,\r\n&ep->epic_descriptor,\r\nsizeof(struct edge_compatibility_descriptor),\r\n300);\r\ndbg("%s result = %d", __func__, result);\r\nif (result > 0) {\r\nep->is_epic = 1;\r\nmemset(product_info, 0, sizeof(struct edgeport_product_info));\r\nproduct_info->NumPorts = epic->NumPorts;\r\nproduct_info->ProdInfoVer = 0;\r\nproduct_info->FirmwareMajorVersion = epic->MajorVersion;\r\nproduct_info->FirmwareMinorVersion = epic->MinorVersion;\r\nproduct_info->FirmwareBuildNumber = epic->BuildNumber;\r\nproduct_info->iDownloadFile = epic->iDownloadFile;\r\nproduct_info->EpicVer = epic->EpicVer;\r\nproduct_info->Epic = epic->Supports;\r\nproduct_info->ProductId = ION_DEVICE_ID_EDGEPORT_COMPATIBLE;\r\ndump_product_info(product_info);\r\nbits = &ep->epic_descriptor.Supports;\r\ndbg("**EPIC descriptor:");\r\ndbg(" VendEnableSuspend: %s", bits->VendEnableSuspend ? "TRUE": "FALSE");\r\ndbg(" IOSPOpen : %s", bits->IOSPOpen ? "TRUE": "FALSE");\r\ndbg(" IOSPClose : %s", bits->IOSPClose ? "TRUE": "FALSE");\r\ndbg(" IOSPChase : %s", bits->IOSPChase ? "TRUE": "FALSE");\r\ndbg(" IOSPSetRxFlow : %s", bits->IOSPSetRxFlow ? "TRUE": "FALSE");\r\ndbg(" IOSPSetTxFlow : %s", bits->IOSPSetTxFlow ? "TRUE": "FALSE");\r\ndbg(" IOSPSetXChar : %s", bits->IOSPSetXChar ? "TRUE": "FALSE");\r\ndbg(" IOSPRxCheck : %s", bits->IOSPRxCheck ? "TRUE": "FALSE");\r\ndbg(" IOSPSetClrBreak : %s", bits->IOSPSetClrBreak ? "TRUE": "FALSE");\r\ndbg(" IOSPWriteMCR : %s", bits->IOSPWriteMCR ? "TRUE": "FALSE");\r\ndbg(" IOSPWriteLCR : %s", bits->IOSPWriteLCR ? "TRUE": "FALSE");\r\ndbg(" IOSPSetBaudRate : %s", bits->IOSPSetBaudRate ? "TRUE": "FALSE");\r\ndbg(" TrueEdgeport : %s", bits->TrueEdgeport ? "TRUE": "FALSE");\r\n}\r\nreturn result;\r\n}\r\nstatic void edge_interrupt_callback(struct urb *urb)\r\n{\r\nstruct edgeport_serial *edge_serial = urb->context;\r\nstruct edgeport_port *edge_port;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint length = urb->actual_length;\r\nint bytes_avail;\r\nint position;\r\nint txCredits;\r\nint portNumber;\r\nint result;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d", __func__, status);\r\ngoto exit;\r\n}\r\nif (length) {\r\nusb_serial_debug_data(debug, &edge_serial->serial->dev->dev,\r\n__func__, length, data);\r\nif (length > 1) {\r\nbytes_avail = data[0] | (data[1] << 8);\r\nif (bytes_avail) {\r\nspin_lock(&edge_serial->es_lock);\r\nedge_serial->rxBytesAvail += bytes_avail;\r\ndbg("%s - bytes_avail=%d, rxBytesAvail=%d, read_in_progress=%d", __func__, bytes_avail, edge_serial->rxBytesAvail, edge_serial->read_in_progress);\r\nif (edge_serial->rxBytesAvail > 0 &&\r\n!edge_serial->read_in_progress) {\r\ndbg("%s - posting a read", __func__);\r\nedge_serial->read_in_progress = true;\r\nresult = usb_submit_urb(edge_serial->read_urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err(&edge_serial->serial->dev->dev, "%s - usb_submit_urb(read bulk) failed with result = %d\n", __func__, result);\r\nedge_serial->read_in_progress = false;\r\n}\r\n}\r\nspin_unlock(&edge_serial->es_lock);\r\n}\r\n}\r\nposition = 2;\r\nportNumber = 0;\r\nwhile ((position < length) &&\r\n(portNumber < edge_serial->serial->num_ports)) {\r\ntxCredits = data[position] | (data[position+1] << 8);\r\nif (txCredits) {\r\nport = edge_serial->serial->port[portNumber];\r\nedge_port = usb_get_serial_port_data(port);\r\nif (edge_port->open) {\r\nspin_lock(&edge_port->ep_lock);\r\nedge_port->txCredits += txCredits;\r\nspin_unlock(&edge_port->ep_lock);\r\ndbg("%s - txcredits for port%d = %d",\r\n__func__, portNumber,\r\nedge_port->txCredits);\r\ntty = tty_port_tty_get(\r\n&edge_port->port->port);\r\nif (tty) {\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\nsend_more_port_data(edge_serial,\r\nedge_port);\r\n}\r\n}\r\nposition += 2;\r\n++portNumber;\r\n}\r\n}\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&urb->dev->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, result);\r\n}\r\nstatic void edge_bulk_in_callback(struct urb *urb)\r\n{\r\nstruct edgeport_serial *edge_serial = urb->context;\r\nunsigned char *data = urb->transfer_buffer;\r\nint retval;\r\n__u16 raw_data_length;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nif (status) {\r\ndbg("%s - nonzero read bulk status received: %d",\r\n__func__, status);\r\nedge_serial->read_in_progress = false;\r\nreturn;\r\n}\r\nif (urb->actual_length == 0) {\r\ndbg("%s - read bulk callback with no data", __func__);\r\nedge_serial->read_in_progress = false;\r\nreturn;\r\n}\r\nraw_data_length = urb->actual_length;\r\nusb_serial_debug_data(debug, &edge_serial->serial->dev->dev,\r\n__func__, raw_data_length, data);\r\nspin_lock(&edge_serial->es_lock);\r\nedge_serial->rxBytesAvail -= raw_data_length;\r\ndbg("%s - Received = %d, rxBytesAvail %d", __func__,\r\nraw_data_length, edge_serial->rxBytesAvail);\r\nprocess_rcvd_data(edge_serial, data, urb->actual_length);\r\nif (edge_serial->rxBytesAvail > 0) {\r\ndbg("%s - posting a read", __func__);\r\nretval = usb_submit_urb(edge_serial->read_urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_err(&urb->dev->dev,\r\n"%s - usb_submit_urb(read bulk) failed, "\r\n"retval = %d\n", __func__, retval);\r\nedge_serial->read_in_progress = false;\r\n}\r\n} else {\r\nedge_serial->read_in_progress = false;\r\n}\r\nspin_unlock(&edge_serial->es_lock);\r\n}\r\nstatic void edge_bulk_out_data_callback(struct urb *urb)\r\n{\r\nstruct edgeport_port *edge_port = urb->context;\r\nstruct tty_struct *tty;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\nif (status) {\r\ndbg("%s - nonzero write bulk status received: %d",\r\n__func__, status);\r\n}\r\ntty = tty_port_tty_get(&edge_port->port->port);\r\nif (tty && edge_port->open) {\r\ntty_wakeup(tty);\r\n}\r\ntty_kref_put(tty);\r\nedge_port->write_in_progress = false;\r\nsend_more_port_data((struct edgeport_serial *)\r\n(usb_get_serial_data(edge_port->port->serial)), edge_port);\r\n}\r\nstatic void edge_bulk_out_cmd_callback(struct urb *urb)\r\n{\r\nstruct edgeport_port *edge_port = urb->context;\r\nstruct tty_struct *tty;\r\nint status = urb->status;\r\ndbg("%s", __func__);\r\natomic_dec(&CmdUrbs);\r\ndbg("%s - FREE URB %p (outstanding %d)", __func__,\r\nurb, atomic_read(&CmdUrbs));\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\nif (status) {\r\ndbg("%s - nonzero write bulk status received: %d",\r\n__func__, status);\r\nreturn;\r\n}\r\ntty = tty_port_tty_get(&edge_port->port->port);\r\nif (tty && edge_port->open)\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\nedge_port->commandPending = false;\r\nwake_up(&edge_port->wait_command);\r\n}\r\nstatic int edge_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial;\r\nstruct edgeport_serial *edge_serial;\r\nint response;\r\ndbg("%s - port %d", __func__, port->number);\r\nif (edge_port == NULL)\r\nreturn -ENODEV;\r\nserial = port->serial;\r\nedge_serial = usb_get_serial_data(serial);\r\nif (edge_serial == NULL)\r\nreturn -ENODEV;\r\nif (edge_serial->interrupt_in_buffer == NULL) {\r\nstruct usb_serial_port *port0 = serial->port[0];\r\nedge_serial->interrupt_in_buffer =\r\nport0->interrupt_in_buffer;\r\nedge_serial->interrupt_in_endpoint =\r\nport0->interrupt_in_endpointAddress;\r\nedge_serial->interrupt_read_urb = port0->interrupt_in_urb;\r\nedge_serial->bulk_in_buffer = port0->bulk_in_buffer;\r\nedge_serial->bulk_in_endpoint =\r\nport0->bulk_in_endpointAddress;\r\nedge_serial->read_urb = port0->read_urb;\r\nedge_serial->bulk_out_endpoint =\r\nport0->bulk_out_endpointAddress;\r\nusb_fill_int_urb(edge_serial->interrupt_read_urb,\r\nserial->dev,\r\nusb_rcvintpipe(serial->dev,\r\nport0->interrupt_in_endpointAddress),\r\nport0->interrupt_in_buffer,\r\nedge_serial->interrupt_read_urb->transfer_buffer_length,\r\nedge_interrupt_callback, edge_serial,\r\nedge_serial->interrupt_read_urb->interval);\r\nusb_fill_bulk_urb(edge_serial->read_urb, serial->dev,\r\nusb_rcvbulkpipe(serial->dev,\r\nport0->bulk_in_endpointAddress),\r\nport0->bulk_in_buffer,\r\nedge_serial->read_urb->transfer_buffer_length,\r\nedge_bulk_in_callback, edge_serial);\r\nedge_serial->read_in_progress = false;\r\nresponse = usb_submit_urb(edge_serial->interrupt_read_urb,\r\nGFP_KERNEL);\r\nif (response) {\r\ndev_err(&port->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, response);\r\n}\r\n}\r\ninit_waitqueue_head(&edge_port->wait_open);\r\ninit_waitqueue_head(&edge_port->wait_chase);\r\ninit_waitqueue_head(&edge_port->delta_msr_wait);\r\ninit_waitqueue_head(&edge_port->wait_command);\r\nmemset(&(edge_port->icount), 0x00, sizeof(edge_port->icount));\r\nedge_port->txCredits = 0;\r\nedge_port->shadowMCR = MCR_MASTER_IE;\r\nedge_port->chaseResponsePending = false;\r\nedge_port->openPending = true;\r\nedge_port->open = false;\r\nresponse = send_iosp_ext_cmd(edge_port, IOSP_CMD_OPEN_PORT, 0);\r\nif (response < 0) {\r\ndev_err(&port->dev, "%s - error sending open port command\n",\r\n__func__);\r\nedge_port->openPending = false;\r\nreturn -ENODEV;\r\n}\r\nwait_event_timeout(edge_port->wait_open, !edge_port->openPending,\r\nOPEN_TIMEOUT);\r\nif (!edge_port->open) {\r\ndbg("%s - open timedout", __func__);\r\nedge_port->openPending = false;\r\nreturn -ENODEV;\r\n}\r\nedge_port->txfifo.head = 0;\r\nedge_port->txfifo.tail = 0;\r\nedge_port->txfifo.count = 0;\r\nedge_port->txfifo.size = edge_port->maxTxCredits;\r\nedge_port->txfifo.fifo = kmalloc(edge_port->maxTxCredits, GFP_KERNEL);\r\nif (!edge_port->txfifo.fifo) {\r\ndbg("%s - no memory", __func__);\r\nedge_close(port);\r\nreturn -ENOMEM;\r\n}\r\nedge_port->write_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nedge_port->write_in_progress = false;\r\nif (!edge_port->write_urb) {\r\ndbg("%s - no memory", __func__);\r\nedge_close(port);\r\nreturn -ENOMEM;\r\n}\r\ndbg("%s(%d) - Initialize TX fifo to %d bytes",\r\n__func__, port->number, edge_port->maxTxCredits);\r\ndbg("%s exited", __func__);\r\nreturn 0;\r\n}\r\nstatic void block_until_chase_response(struct edgeport_port *edge_port)\r\n{\r\nDEFINE_WAIT(wait);\r\n__u16 lastCredits;\r\nint timeout = 1*HZ;\r\nint loop = 10;\r\nwhile (1) {\r\nlastCredits = edge_port->txCredits;\r\nif (!edge_port->chaseResponsePending) {\r\ndbg("%s - Got Chase Response", __func__);\r\nif (edge_port->txCredits == edge_port->maxTxCredits) {\r\ndbg("%s - Got all credits", __func__);\r\nreturn;\r\n}\r\n}\r\nprepare_to_wait(&edge_port->wait_chase, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nschedule_timeout(timeout);\r\nfinish_wait(&edge_port->wait_chase, &wait);\r\nif (lastCredits == edge_port->txCredits) {\r\nloop--;\r\nif (loop == 0) {\r\nedge_port->chaseResponsePending = false;\r\ndbg("%s - Chase TIMEOUT", __func__);\r\nreturn;\r\n}\r\n} else {\r\ndbg("%s - Last %d, Current %d", __func__,\r\nlastCredits, edge_port->txCredits);\r\nloop = 10;\r\n}\r\n}\r\n}\r\nstatic void block_until_tx_empty(struct edgeport_port *edge_port)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct TxFifo *fifo = &edge_port->txfifo;\r\n__u32 lastCount;\r\nint timeout = HZ/10;\r\nint loop = 30;\r\nwhile (1) {\r\nlastCount = fifo->count;\r\nif (lastCount == 0) {\r\ndbg("%s - TX Buffer Empty", __func__);\r\nreturn;\r\n}\r\nprepare_to_wait(&edge_port->wait_chase, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nschedule_timeout(timeout);\r\nfinish_wait(&edge_port->wait_chase, &wait);\r\ndbg("%s wait", __func__);\r\nif (lastCount == fifo->count) {\r\nloop--;\r\nif (loop == 0) {\r\ndbg("%s - TIMEOUT", __func__);\r\nreturn;\r\n}\r\n} else {\r\nloop = 30;\r\n}\r\n}\r\n}\r\nstatic void edge_close(struct usb_serial_port *port)\r\n{\r\nstruct edgeport_serial *edge_serial;\r\nstruct edgeport_port *edge_port;\r\nint status;\r\ndbg("%s - port %d", __func__, port->number);\r\nedge_serial = usb_get_serial_data(port->serial);\r\nedge_port = usb_get_serial_port_data(port);\r\nif (edge_serial == NULL || edge_port == NULL)\r\nreturn;\r\nblock_until_tx_empty(edge_port);\r\nedge_port->closePending = true;\r\nif ((!edge_serial->is_epic) ||\r\n((edge_serial->is_epic) &&\r\n(edge_serial->epic_descriptor.Supports.IOSPChase))) {\r\nedge_port->chaseResponsePending = true;\r\ndbg("%s - Sending IOSP_CMD_CHASE_PORT", __func__);\r\nstatus = send_iosp_ext_cmd(edge_port, IOSP_CMD_CHASE_PORT, 0);\r\nif (status == 0)\r\nblock_until_chase_response(edge_port);\r\nelse\r\nedge_port->chaseResponsePending = false;\r\n}\r\nif ((!edge_serial->is_epic) ||\r\n((edge_serial->is_epic) &&\r\n(edge_serial->epic_descriptor.Supports.IOSPClose))) {\r\ndbg("%s - Sending IOSP_CMD_CLOSE_PORT", __func__);\r\nsend_iosp_ext_cmd(edge_port, IOSP_CMD_CLOSE_PORT, 0);\r\n}\r\nedge_port->closePending = false;\r\nedge_port->open = false;\r\nedge_port->openPending = false;\r\nusb_kill_urb(edge_port->write_urb);\r\nif (edge_port->write_urb) {\r\nkfree(edge_port->write_urb->transfer_buffer);\r\nusb_free_urb(edge_port->write_urb);\r\nedge_port->write_urb = NULL;\r\n}\r\nkfree(edge_port->txfifo.fifo);\r\nedge_port->txfifo.fifo = NULL;\r\ndbg("%s exited", __func__);\r\n}\r\nstatic int edge_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *data, int count)\r\n{\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nstruct TxFifo *fifo;\r\nint copySize;\r\nint bytesleft;\r\nint firsthalf;\r\nint secondhalf;\r\nunsigned long flags;\r\ndbg("%s - port %d", __func__, port->number);\r\nif (edge_port == NULL)\r\nreturn -ENODEV;\r\nfifo = &edge_port->txfifo;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\ncopySize = min((unsigned int)count,\r\n(edge_port->txCredits - fifo->count));\r\ndbg("%s(%d) of %d byte(s) Fifo room %d -- will copy %d bytes",\r\n__func__, port->number, count,\r\nedge_port->txCredits - fifo->count, copySize);\r\nif (copySize == 0) {\r\ndbg("%s - copySize = Zero", __func__);\r\ngoto finish_write;\r\n}\r\nbytesleft = fifo->size - fifo->head;\r\nfirsthalf = min(bytesleft, copySize);\r\ndbg("%s - copy %d bytes of %d into fifo ", __func__,\r\nfirsthalf, bytesleft);\r\nmemcpy(&fifo->fifo[fifo->head], data, firsthalf);\r\nusb_serial_debug_data(debug, &port->dev, __func__,\r\nfirsthalf, &fifo->fifo[fifo->head]);\r\nfifo->head += firsthalf;\r\nfifo->count += firsthalf;\r\nif (fifo->head == fifo->size)\r\nfifo->head = 0;\r\nsecondhalf = copySize-firsthalf;\r\nif (secondhalf) {\r\ndbg("%s - copy rest of data %d", __func__, secondhalf);\r\nmemcpy(&fifo->fifo[fifo->head], &data[firsthalf], secondhalf);\r\nusb_serial_debug_data(debug, &port->dev, __func__,\r\nsecondhalf, &fifo->fifo[fifo->head]);\r\nfifo->count += secondhalf;\r\nfifo->head += secondhalf;\r\n}\r\nfinish_write:\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nsend_more_port_data((struct edgeport_serial *)\r\nusb_get_serial_data(port->serial), edge_port);\r\ndbg("%s wrote %d byte(s) TxCredits %d, Fifo %d", __func__,\r\ncopySize, edge_port->txCredits, fifo->count);\r\nreturn copySize;\r\n}\r\nstatic void send_more_port_data(struct edgeport_serial *edge_serial,\r\nstruct edgeport_port *edge_port)\r\n{\r\nstruct TxFifo *fifo = &edge_port->txfifo;\r\nstruct urb *urb;\r\nunsigned char *buffer;\r\nint status;\r\nint count;\r\nint bytesleft;\r\nint firsthalf;\r\nint secondhalf;\r\nunsigned long flags;\r\ndbg("%s(%d)", __func__, edge_port->port->number);\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nif (edge_port->write_in_progress ||\r\n!edge_port->open ||\r\n(fifo->count == 0)) {\r\ndbg("%s(%d) EXIT - fifo %d, PendingWrite = %d",\r\n__func__, edge_port->port->number,\r\nfifo->count, edge_port->write_in_progress);\r\ngoto exit_send;\r\n}\r\nif (edge_port->txCredits < EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(edge_port->maxTxCredits, EDGE_FW_BULK_MAX_PACKET_SIZE)) {\r\ndbg("%s(%d) Not enough credit - fifo %d TxCredit %d",\r\n__func__, edge_port->port->number, fifo->count,\r\nedge_port->txCredits);\r\ngoto exit_send;\r\n}\r\nedge_port->write_in_progress = true;\r\nurb = edge_port->write_urb;\r\nkfree(urb->transfer_buffer);\r\nurb->transfer_buffer = NULL;\r\ncount = fifo->count;\r\nbuffer = kmalloc(count+2, GFP_ATOMIC);\r\nif (buffer == NULL) {\r\ndev_err_console(edge_port->port,\r\n"%s - no more kernel memory...\n", __func__);\r\nedge_port->write_in_progress = false;\r\ngoto exit_send;\r\n}\r\nbuffer[0] = IOSP_BUILD_DATA_HDR1(edge_port->port->number\r\n- edge_port->port->serial->minor, count);\r\nbuffer[1] = IOSP_BUILD_DATA_HDR2(edge_port->port->number\r\n- edge_port->port->serial->minor, count);\r\nbytesleft = fifo->size - fifo->tail;\r\nfirsthalf = min(bytesleft, count);\r\nmemcpy(&buffer[2], &fifo->fifo[fifo->tail], firsthalf);\r\nfifo->tail += firsthalf;\r\nfifo->count -= firsthalf;\r\nif (fifo->tail == fifo->size)\r\nfifo->tail = 0;\r\nsecondhalf = count-firsthalf;\r\nif (secondhalf) {\r\nmemcpy(&buffer[2+firsthalf], &fifo->fifo[fifo->tail],\r\nsecondhalf);\r\nfifo->tail += secondhalf;\r\nfifo->count -= secondhalf;\r\n}\r\nif (count)\r\nusb_serial_debug_data(debug, &edge_port->port->dev,\r\n__func__, count, &buffer[2]);\r\nusb_fill_bulk_urb(urb, edge_serial->serial->dev,\r\nusb_sndbulkpipe(edge_serial->serial->dev,\r\nedge_serial->bulk_out_endpoint),\r\nbuffer, count+2,\r\nedge_bulk_out_data_callback, edge_port);\r\nedge_port->txCredits -= count;\r\nedge_port->icount.tx += count;\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\ndev_err_console(edge_port->port,\r\n"%s - usb_submit_urb(write bulk) failed, status = %d, data lost\n",\r\n__func__, status);\r\nedge_port->write_in_progress = false;\r\nedge_port->txCredits += count;\r\nedge_port->icount.tx -= count;\r\n}\r\ndbg("%s wrote %d byte(s) TxCredit %d, Fifo %d",\r\n__func__, count, edge_port->txCredits, fifo->count);\r\nexit_send:\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\n}\r\nstatic int edge_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint room;\r\nunsigned long flags;\r\ndbg("%s", __func__);\r\nif (edge_port == NULL)\r\nreturn 0;\r\nif (edge_port->closePending)\r\nreturn 0;\r\ndbg("%s - port %d", __func__, port->number);\r\nif (!edge_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nroom = edge_port->txCredits - edge_port->txfifo.count;\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\ndbg("%s - returns %d", __func__, room);\r\nreturn room;\r\n}\r\nstatic int edge_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint num_chars;\r\nunsigned long flags;\r\ndbg("%s", __func__);\r\nif (edge_port == NULL)\r\nreturn 0;\r\nif (edge_port->closePending)\r\nreturn 0;\r\nif (!edge_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nnum_chars = edge_port->maxTxCredits - edge_port->txCredits +\r\nedge_port->txfifo.count;\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nif (num_chars) {\r\ndbg("%s(port %d) - returns %d", __func__,\r\nport->number, num_chars);\r\n}\r\nreturn num_chars;\r\n}\r\nstatic void edge_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint status;\r\ndbg("%s - port %d", __func__, port->number);\r\nif (edge_port == NULL)\r\nreturn;\r\nif (!edge_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\nif (I_IXOFF(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nstatus = edge_write(tty, port, &stop_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\nedge_port->shadowMCR &= ~MCR_RTS;\r\nstatus = send_cmd_write_uart_register(edge_port, MCR,\r\nedge_port->shadowMCR);\r\nif (status != 0)\r\nreturn;\r\n}\r\n}\r\nstatic void edge_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint status;\r\ndbg("%s - port %d", __func__, port->number);\r\nif (edge_port == NULL)\r\nreturn;\r\nif (!edge_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\nif (I_IXOFF(tty)) {\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus = edge_write(tty, port, &start_char, 1);\r\nif (status <= 0)\r\nreturn;\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS) {\r\nedge_port->shadowMCR |= MCR_RTS;\r\nsend_cmd_write_uart_register(edge_port, MCR,\r\nedge_port->shadowMCR);\r\n}\r\n}\r\nstatic void edge_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nunsigned int cflag;\r\ncflag = tty->termios->c_cflag;\r\ndbg("%s - clfag %08x iflag %08x", __func__,\r\ntty->termios->c_cflag, tty->termios->c_iflag);\r\ndbg("%s - old clfag %08x old iflag %08x", __func__,\r\nold_termios->c_cflag, old_termios->c_iflag);\r\ndbg("%s - port %d", __func__, port->number);\r\nif (edge_port == NULL)\r\nreturn;\r\nif (!edge_port->open) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\nchange_port_settings(tty, edge_port, old_termios);\r\n}\r\nstatic int get_lsr_info(struct edgeport_port *edge_port,\r\nunsigned int __user *value)\r\n{\r\nunsigned int result = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nif (edge_port->maxTxCredits == edge_port->txCredits &&\r\nedge_port->txfifo.count == 0) {\r\ndbg("%s -- Empty", __func__);\r\nresult = TIOCSER_TEMT;\r\n}\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nif (copy_to_user(value, &result, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int edge_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nunsigned int mcr;\r\ndbg("%s - port %d", __func__, port->number);\r\nmcr = edge_port->shadowMCR;\r\nif (set & TIOCM_RTS)\r\nmcr |= MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr |= MCR_DTR;\r\nif (set & TIOCM_LOOP)\r\nmcr |= MCR_LOOPBACK;\r\nif (clear & TIOCM_RTS)\r\nmcr &= ~MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\nmcr &= ~MCR_DTR;\r\nif (clear & TIOCM_LOOP)\r\nmcr &= ~MCR_LOOPBACK;\r\nedge_port->shadowMCR = mcr;\r\nsend_cmd_write_uart_register(edge_port, MCR, edge_port->shadowMCR);\r\nreturn 0;\r\n}\r\nstatic int edge_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nunsigned int result = 0;\r\nunsigned int msr;\r\nunsigned int mcr;\r\ndbg("%s - port %d", __func__, port->number);\r\nmsr = edge_port->shadowMSR;\r\nmcr = edge_port->shadowMCR;\r\nresult = ((mcr & MCR_DTR) ? TIOCM_DTR: 0)\r\n| ((mcr & MCR_RTS) ? TIOCM_RTS: 0)\r\n| ((msr & EDGEPORT_MSR_CTS) ? TIOCM_CTS: 0)\r\n| ((msr & EDGEPORT_MSR_CD) ? TIOCM_CAR: 0)\r\n| ((msr & EDGEPORT_MSR_RI) ? TIOCM_RI: 0)\r\n| ((msr & EDGEPORT_MSR_DSR) ? TIOCM_DSR: 0);\r\ndbg("%s -- %x", __func__, result);\r\nreturn result;\r\n}\r\nstatic int edge_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nstruct async_icount cnow;\r\ncnow = edge_port->icount;\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\ndbg("%s (%d) TIOCGICOUNT RX=%d, TX=%d",\r\n__func__, port->number, icount->rx, icount->tx);\r\nreturn 0;\r\n}\r\nstatic int get_serial_info(struct edgeport_port *edge_port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.line = edge_port->port->serial->minor;\r\ntmp.port = edge_port->port->number;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = edge_port->maxTxCredits;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = 30*HZ;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int edge_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nDEFINE_WAIT(wait);\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nstruct async_icount cnow;\r\nstruct async_icount cprev;\r\ndbg("%s - port %d, cmd = 0x%x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCSERGETLSR:\r\ndbg("%s (%d) TIOCSERGETLSR", __func__, port->number);\r\nreturn get_lsr_info(edge_port, (unsigned int __user *) arg);\r\ncase TIOCGSERIAL:\r\ndbg("%s (%d) TIOCGSERIAL", __func__, port->number);\r\nreturn get_serial_info(edge_port, (struct serial_struct __user *) arg);\r\ncase TIOCMIWAIT:\r\ndbg("%s (%d) TIOCMIWAIT", __func__, port->number);\r\ncprev = edge_port->icount;\r\nwhile (1) {\r\nprepare_to_wait(&edge_port->delta_msr_wait,\r\n&wait, TASK_INTERRUPTIBLE);\r\nschedule();\r\nfinish_wait(&edge_port->delta_msr_wait, &wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\ncnow = edge_port->icount;\r\nif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\r\ncnow.dcd == cprev.dcd && cnow.cts == cprev.cts)\r\nreturn -EIO;\r\nif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {\r\nreturn 0;\r\n}\r\ncprev = cnow;\r\n}\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void edge_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nstruct edgeport_serial *edge_serial = usb_get_serial_data(port->serial);\r\nint status;\r\nif ((!edge_serial->is_epic) ||\r\n((edge_serial->is_epic) &&\r\n(edge_serial->epic_descriptor.Supports.IOSPChase))) {\r\nedge_port->chaseResponsePending = true;\r\ndbg("%s - Sending IOSP_CMD_CHASE_PORT", __func__);\r\nstatus = send_iosp_ext_cmd(edge_port, IOSP_CMD_CHASE_PORT, 0);\r\nif (status == 0) {\r\nblock_until_chase_response(edge_port);\r\n} else {\r\nedge_port->chaseResponsePending = false;\r\n}\r\n}\r\nif ((!edge_serial->is_epic) ||\r\n((edge_serial->is_epic) &&\r\n(edge_serial->epic_descriptor.Supports.IOSPSetClrBreak))) {\r\nif (break_state == -1) {\r\ndbg("%s - Sending IOSP_CMD_SET_BREAK", __func__);\r\nstatus = send_iosp_ext_cmd(edge_port,\r\nIOSP_CMD_SET_BREAK, 0);\r\n} else {\r\ndbg("%s - Sending IOSP_CMD_CLEAR_BREAK", __func__);\r\nstatus = send_iosp_ext_cmd(edge_port,\r\nIOSP_CMD_CLEAR_BREAK, 0);\r\n}\r\nif (status)\r\ndbg("%s - error sending break set/clear command.",\r\n__func__);\r\n}\r\n}\r\nstatic void process_rcvd_data(struct edgeport_serial *edge_serial,\r\nunsigned char *buffer, __u16 bufferLength)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct edgeport_port *edge_port;\r\nstruct tty_struct *tty;\r\n__u16 lastBufferLength;\r\n__u16 rxLen;\r\ndbg("%s", __func__);\r\nlastBufferLength = bufferLength + 1;\r\nwhile (bufferLength > 0) {\r\nif (lastBufferLength == bufferLength) {\r\ndbg("%s - stuck in loop, exiting it.", __func__);\r\nbreak;\r\n}\r\nlastBufferLength = bufferLength;\r\nswitch (edge_serial->rxState) {\r\ncase EXPECT_HDR1:\r\nedge_serial->rxHeader1 = *buffer;\r\n++buffer;\r\n--bufferLength;\r\nif (bufferLength == 0) {\r\nedge_serial->rxState = EXPECT_HDR2;\r\nbreak;\r\n}\r\ncase EXPECT_HDR2:\r\nedge_serial->rxHeader2 = *buffer;\r\n++buffer;\r\n--bufferLength;\r\ndbg("%s - Hdr1=%02X Hdr2=%02X", __func__,\r\nedge_serial->rxHeader1, edge_serial->rxHeader2);\r\nif (IS_CMD_STAT_HDR(edge_serial->rxHeader1)) {\r\nedge_serial->rxPort =\r\nIOSP_GET_HDR_PORT(edge_serial->rxHeader1);\r\nedge_serial->rxStatusCode =\r\nIOSP_GET_STATUS_CODE(\r\nedge_serial->rxHeader1);\r\nif (!IOSP_STATUS_IS_2BYTE(\r\nedge_serial->rxStatusCode)) {\r\nedge_serial->rxStatusParam\r\n= edge_serial->rxHeader2;\r\nedge_serial->rxState = EXPECT_HDR3;\r\nbreak;\r\n}\r\nprocess_rcvd_status(edge_serial,\r\nedge_serial->rxHeader2, 0);\r\nedge_serial->rxState = EXPECT_HDR1;\r\nbreak;\r\n} else {\r\nedge_serial->rxPort =\r\nIOSP_GET_HDR_PORT(edge_serial->rxHeader1);\r\nedge_serial->rxBytesRemaining =\r\nIOSP_GET_HDR_DATA_LEN(\r\nedge_serial->rxHeader1,\r\nedge_serial->rxHeader2);\r\ndbg("%s - Data for Port %u Len %u",\r\n__func__,\r\nedge_serial->rxPort,\r\nedge_serial->rxBytesRemaining);\r\nif (bufferLength == 0) {\r\nedge_serial->rxState = EXPECT_DATA;\r\nbreak;\r\n}\r\n}\r\ncase EXPECT_DATA:\r\nif (bufferLength < edge_serial->rxBytesRemaining) {\r\nrxLen = bufferLength;\r\nedge_serial->rxState = EXPECT_DATA;\r\n} else {\r\nrxLen = edge_serial->rxBytesRemaining;\r\nedge_serial->rxState = EXPECT_HDR1;\r\n}\r\nbufferLength -= rxLen;\r\nedge_serial->rxBytesRemaining -= rxLen;\r\nif (rxLen) {\r\nport = edge_serial->serial->port[\r\nedge_serial->rxPort];\r\nedge_port = usb_get_serial_port_data(port);\r\nif (edge_port->open) {\r\ntty = tty_port_tty_get(\r\n&edge_port->port->port);\r\nif (tty) {\r\ndbg("%s - Sending %d bytes to TTY for port %d",\r\n__func__, rxLen, edge_serial->rxPort);\r\nedge_tty_recv(&edge_serial->serial->dev->dev, tty, buffer, rxLen);\r\ntty_kref_put(tty);\r\n}\r\nedge_port->icount.rx += rxLen;\r\n}\r\nbuffer += rxLen;\r\n}\r\nbreak;\r\ncase EXPECT_HDR3:\r\nedge_serial->rxHeader3 = *buffer;\r\n++buffer;\r\n--bufferLength;\r\nprocess_rcvd_status(edge_serial,\r\nedge_serial->rxStatusParam,\r\nedge_serial->rxHeader3);\r\nedge_serial->rxState = EXPECT_HDR1;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void process_rcvd_status(struct edgeport_serial *edge_serial,\r\n__u8 byte2, __u8 byte3)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct edgeport_port *edge_port;\r\nstruct tty_struct *tty;\r\n__u8 code = edge_serial->rxStatusCode;\r\nport = edge_serial->serial->port[edge_serial->rxPort];\r\nedge_port = usb_get_serial_port_data(port);\r\nif (edge_port == NULL) {\r\ndev_err(&edge_serial->serial->dev->dev,\r\n"%s - edge_port == NULL for port %d\n",\r\n__func__, edge_serial->rxPort);\r\nreturn;\r\n}\r\ndbg("%s - port %d", __func__, edge_serial->rxPort);\r\nif (code == IOSP_EXT_STATUS) {\r\nswitch (byte2) {\r\ncase IOSP_EXT_STATUS_CHASE_RSP:\r\ndbg("%s - Port %u EXT CHASE_RSP Data = %02x",\r\n__func__, edge_serial->rxPort, byte3);\r\nedge_port->chaseResponsePending = false;\r\nwake_up(&edge_port->wait_chase);\r\nreturn;\r\ncase IOSP_EXT_STATUS_RX_CHECK_RSP:\r\ndbg("%s ========== Port %u CHECK_RSP Sequence = %02x =============", __func__, edge_serial->rxPort, byte3);\r\nreturn;\r\n}\r\n}\r\nif (code == IOSP_STATUS_OPEN_RSP) {\r\nedge_port->txCredits = GET_TX_BUFFER_SIZE(byte3);\r\nedge_port->maxTxCredits = edge_port->txCredits;\r\ndbg("%s - Port %u Open Response Initial MSR = %02x TxBufferSize = %d", __func__, edge_serial->rxPort, byte2, edge_port->txCredits);\r\nhandle_new_msr(edge_port, byte2);\r\ntty = tty_port_tty_get(&edge_port->port->port);\r\nif (tty) {\r\nchange_port_settings(tty,\r\nedge_port, tty->termios);\r\ntty_kref_put(tty);\r\n}\r\nedge_port->openPending = false;\r\nedge_port->open = true;\r\nwake_up(&edge_port->wait_open);\r\nreturn;\r\n}\r\nif (!edge_port->open || edge_port->closePending)\r\nreturn;\r\nswitch (code) {\r\ncase IOSP_STATUS_LSR:\r\ndbg("%s - Port %u LSR Status = %02x",\r\n__func__, edge_serial->rxPort, byte2);\r\nhandle_new_lsr(edge_port, false, byte2, 0);\r\nbreak;\r\ncase IOSP_STATUS_LSR_DATA:\r\ndbg("%s - Port %u LSR Status = %02x, Data = %02x",\r\n__func__, edge_serial->rxPort, byte2, byte3);\r\nhandle_new_lsr(edge_port, true, byte2, byte3);\r\nbreak;\r\ncase IOSP_STATUS_MSR:\r\ndbg("%s - Port %u MSR Status = %02x",\r\n__func__, edge_serial->rxPort, byte2);\r\nhandle_new_msr(edge_port, byte2);\r\nbreak;\r\ndefault:\r\ndbg("%s - Unrecognized IOSP status code %u", __func__, code);\r\nbreak;\r\n}\r\n}\r\nstatic void edge_tty_recv(struct device *dev, struct tty_struct *tty,\r\nunsigned char *data, int length)\r\n{\r\nint cnt;\r\ncnt = tty_insert_flip_string(tty, data, length);\r\nif (cnt < length) {\r\ndev_err(dev, "%s - dropping data, %d bytes lost\n",\r\n__func__, length - cnt);\r\n}\r\ndata += cnt;\r\nlength -= cnt;\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic void handle_new_msr(struct edgeport_port *edge_port, __u8 newMsr)\r\n{\r\nstruct async_icount *icount;\r\ndbg("%s %02x", __func__, newMsr);\r\nif (newMsr & (EDGEPORT_MSR_DELTA_CTS | EDGEPORT_MSR_DELTA_DSR |\r\nEDGEPORT_MSR_DELTA_RI | EDGEPORT_MSR_DELTA_CD)) {\r\nicount = &edge_port->icount;\r\nif (newMsr & EDGEPORT_MSR_DELTA_CTS)\r\nicount->cts++;\r\nif (newMsr & EDGEPORT_MSR_DELTA_DSR)\r\nicount->dsr++;\r\nif (newMsr & EDGEPORT_MSR_DELTA_CD)\r\nicount->dcd++;\r\nif (newMsr & EDGEPORT_MSR_DELTA_RI)\r\nicount->rng++;\r\nwake_up_interruptible(&edge_port->delta_msr_wait);\r\n}\r\nedge_port->shadowMSR = newMsr & 0xf0;\r\n}\r\nstatic void handle_new_lsr(struct edgeport_port *edge_port, __u8 lsrData,\r\n__u8 lsr, __u8 data)\r\n{\r\n__u8 newLsr = (__u8) (lsr & (__u8)\r\n(LSR_OVER_ERR | LSR_PAR_ERR | LSR_FRM_ERR | LSR_BREAK));\r\nstruct async_icount *icount;\r\ndbg("%s - %02x", __func__, newLsr);\r\nedge_port->shadowLSR = lsr;\r\nif (newLsr & LSR_BREAK) {\r\nnewLsr &= (__u8)(LSR_OVER_ERR | LSR_BREAK);\r\n}\r\nif (lsrData) {\r\nstruct tty_struct *tty =\r\ntty_port_tty_get(&edge_port->port->port);\r\nif (tty) {\r\nedge_tty_recv(&edge_port->port->dev, tty, &data, 1);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nicount = &edge_port->icount;\r\nif (newLsr & LSR_BREAK)\r\nicount->brk++;\r\nif (newLsr & LSR_OVER_ERR)\r\nicount->overrun++;\r\nif (newLsr & LSR_PAR_ERR)\r\nicount->parity++;\r\nif (newLsr & LSR_FRM_ERR)\r\nicount->frame++;\r\n}\r\nstatic int sram_write(struct usb_serial *serial, __u16 extAddr, __u16 addr,\r\n__u16 length, const __u8 *data)\r\n{\r\nint result;\r\n__u16 current_length;\r\nunsigned char *transfer_buffer;\r\ndbg("%s - %x, %x, %d", __func__, extAddr, addr, length);\r\ntransfer_buffer = kmalloc(64, GFP_KERNEL);\r\nif (!transfer_buffer) {\r\ndev_err(&serial->dev->dev, "%s - kmalloc(%d) failed.\n",\r\n__func__, 64);\r\nreturn -ENOMEM;\r\n}\r\nresult = 0;\r\nwhile (length > 0) {\r\nif (length > 64)\r\ncurrent_length = 64;\r\nelse\r\ncurrent_length = length;\r\nmemcpy(transfer_buffer, data, current_length);\r\nresult = usb_control_msg(serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\nUSB_REQUEST_ION_WRITE_RAM,\r\n0x40, addr, extAddr, transfer_buffer,\r\ncurrent_length, 300);\r\nif (result < 0)\r\nbreak;\r\nlength -= current_length;\r\naddr += current_length;\r\ndata += current_length;\r\n}\r\nkfree(transfer_buffer);\r\nreturn result;\r\n}\r\nstatic int rom_write(struct usb_serial *serial, __u16 extAddr, __u16 addr,\r\n__u16 length, const __u8 *data)\r\n{\r\nint result;\r\n__u16 current_length;\r\nunsigned char *transfer_buffer;\r\ntransfer_buffer = kmalloc(64, GFP_KERNEL);\r\nif (!transfer_buffer) {\r\ndev_err(&serial->dev->dev, "%s - kmalloc(%d) failed.\n",\r\n__func__, 64);\r\nreturn -ENOMEM;\r\n}\r\nresult = 0;\r\nwhile (length > 0) {\r\nif (length > 64)\r\ncurrent_length = 64;\r\nelse\r\ncurrent_length = length;\r\nmemcpy(transfer_buffer, data, current_length);\r\nresult = usb_control_msg(serial->dev,\r\nusb_sndctrlpipe(serial->dev, 0),\r\nUSB_REQUEST_ION_WRITE_ROM, 0x40,\r\naddr, extAddr,\r\ntransfer_buffer, current_length, 300);\r\nif (result < 0)\r\nbreak;\r\nlength -= current_length;\r\naddr += current_length;\r\ndata += current_length;\r\n}\r\nkfree(transfer_buffer);\r\nreturn result;\r\n}\r\nstatic int rom_read(struct usb_serial *serial, __u16 extAddr,\r\n__u16 addr, __u16 length, __u8 *data)\r\n{\r\nint result;\r\n__u16 current_length;\r\nunsigned char *transfer_buffer;\r\ndbg("%s - %x, %x, %d", __func__, extAddr, addr, length);\r\ntransfer_buffer = kmalloc(64, GFP_KERNEL);\r\nif (!transfer_buffer) {\r\ndev_err(&serial->dev->dev,\r\n"%s - kmalloc(%d) failed.\n", __func__, 64);\r\nreturn -ENOMEM;\r\n}\r\nresult = 0;\r\nwhile (length > 0) {\r\nif (length > 64)\r\ncurrent_length = 64;\r\nelse\r\ncurrent_length = length;\r\nresult = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\nUSB_REQUEST_ION_READ_ROM,\r\n0xC0, addr, extAddr, transfer_buffer,\r\ncurrent_length, 300);\r\nif (result < 0)\r\nbreak;\r\nmemcpy(data, transfer_buffer, current_length);\r\nlength -= current_length;\r\naddr += current_length;\r\ndata += current_length;\r\n}\r\nkfree(transfer_buffer);\r\nreturn result;\r\n}\r\nstatic int send_iosp_ext_cmd(struct edgeport_port *edge_port,\r\n__u8 command, __u8 param)\r\n{\r\nunsigned char *buffer;\r\nunsigned char *currentCommand;\r\nint length = 0;\r\nint status = 0;\r\ndbg("%s - %d, %d", __func__, command, param);\r\nbuffer = kmalloc(10, GFP_ATOMIC);\r\nif (!buffer) {\r\ndev_err(&edge_port->port->dev,\r\n"%s - kmalloc(%d) failed.\n", __func__, 10);\r\nreturn -ENOMEM;\r\n}\r\ncurrentCommand = buffer;\r\nMAKE_CMD_EXT_CMD(&currentCommand, &length,\r\nedge_port->port->number - edge_port->port->serial->minor,\r\ncommand, param);\r\nstatus = write_cmd_usb(edge_port, buffer, length);\r\nif (status) {\r\nkfree(buffer);\r\n}\r\nreturn status;\r\n}\r\nstatic int write_cmd_usb(struct edgeport_port *edge_port,\r\nunsigned char *buffer, int length)\r\n{\r\nstruct edgeport_serial *edge_serial =\r\nusb_get_serial_data(edge_port->port->serial);\r\nint status = 0;\r\nstruct urb *urb;\r\nusb_serial_debug_data(debug, &edge_port->port->dev,\r\n__func__, length, buffer);\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\nreturn -ENOMEM;\r\natomic_inc(&CmdUrbs);\r\ndbg("%s - ALLOCATE URB %p (outstanding %d)",\r\n__func__, urb, atomic_read(&CmdUrbs));\r\nusb_fill_bulk_urb(urb, edge_serial->serial->dev,\r\nusb_sndbulkpipe(edge_serial->serial->dev,\r\nedge_serial->bulk_out_endpoint),\r\nbuffer, length, edge_bulk_out_cmd_callback, edge_port);\r\nedge_port->commandPending = true;\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status) {\r\ndev_err(&edge_port->port->dev,\r\n"%s - usb_submit_urb(write command) failed, status = %d\n",\r\n__func__, status);\r\nusb_kill_urb(urb);\r\nusb_free_urb(urb);\r\natomic_dec(&CmdUrbs);\r\nreturn status;\r\n}\r\n#if 0\r\nwait_event(&edge_port->wait_command, !edge_port->commandPending);\r\nif (edge_port->commandPending) {\r\ndbg("%s - command timed out", __func__);\r\nstatus = -EINVAL;\r\n}\r\n#endif\r\nreturn status;\r\n}\r\nstatic int send_cmd_write_baud_rate(struct edgeport_port *edge_port,\r\nint baudRate)\r\n{\r\nstruct edgeport_serial *edge_serial =\r\nusb_get_serial_data(edge_port->port->serial);\r\nunsigned char *cmdBuffer;\r\nunsigned char *currCmd;\r\nint cmdLen = 0;\r\nint divisor;\r\nint status;\r\nunsigned char number =\r\nedge_port->port->number - edge_port->port->serial->minor;\r\nif (edge_serial->is_epic &&\r\n!edge_serial->epic_descriptor.Supports.IOSPSetBaudRate) {\r\ndbg("SendCmdWriteBaudRate - NOT Setting baud rate for port = %d, baud = %d",\r\nedge_port->port->number, baudRate);\r\nreturn 0;\r\n}\r\ndbg("%s - port = %d, baud = %d", __func__,\r\nedge_port->port->number, baudRate);\r\nstatus = calc_baud_rate_divisor(baudRate, &divisor);\r\nif (status) {\r\ndev_err(&edge_port->port->dev, "%s - bad baud rate\n",\r\n__func__);\r\nreturn status;\r\n}\r\ncmdBuffer = kmalloc(0x100, GFP_ATOMIC);\r\nif (!cmdBuffer) {\r\ndev_err(&edge_port->port->dev,\r\n"%s - kmalloc(%d) failed.\n", __func__, 0x100);\r\nreturn -ENOMEM;\r\n}\r\ncurrCmd = cmdBuffer;\r\nMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, number, LCR, LCR_DL_ENABLE);\r\nMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, number, DLL, LOW8(divisor));\r\nMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, number, DLM, HIGH8(divisor));\r\nMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, number, LCR,\r\nedge_port->shadowLCR);\r\nstatus = write_cmd_usb(edge_port, cmdBuffer, cmdLen);\r\nif (status) {\r\nkfree(cmdBuffer);\r\n}\r\nreturn status;\r\n}\r\nstatic int calc_baud_rate_divisor(int baudrate, int *divisor)\r\n{\r\nint i;\r\n__u16 custom;\r\ndbg("%s - %d", __func__, baudrate);\r\nfor (i = 0; i < ARRAY_SIZE(divisor_table); i++) {\r\nif (divisor_table[i].BaudRate == baudrate) {\r\n*divisor = divisor_table[i].Divisor;\r\nreturn 0;\r\n}\r\n}\r\nif (baudrate > 50 && baudrate < 230400) {\r\ncustom = (__u16)((230400L + baudrate/2) / baudrate);\r\n*divisor = custom;\r\ndbg("%s - Baud %d = %d", __func__, baudrate, custom);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int send_cmd_write_uart_register(struct edgeport_port *edge_port,\r\n__u8 regNum, __u8 regValue)\r\n{\r\nstruct edgeport_serial *edge_serial =\r\nusb_get_serial_data(edge_port->port->serial);\r\nunsigned char *cmdBuffer;\r\nunsigned char *currCmd;\r\nunsigned long cmdLen = 0;\r\nint status;\r\ndbg("%s - write to %s register 0x%02x",\r\n(regNum == MCR) ? "MCR" : "LCR", __func__, regValue);\r\nif (edge_serial->is_epic &&\r\n!edge_serial->epic_descriptor.Supports.IOSPWriteMCR &&\r\nregNum == MCR) {\r\ndbg("SendCmdWriteUartReg - Not writing to MCR Register");\r\nreturn 0;\r\n}\r\nif (edge_serial->is_epic &&\r\n!edge_serial->epic_descriptor.Supports.IOSPWriteLCR &&\r\nregNum == LCR) {\r\ndbg("SendCmdWriteUartReg - Not writing to LCR Register");\r\nreturn 0;\r\n}\r\ncmdBuffer = kmalloc(0x10, GFP_ATOMIC);\r\nif (cmdBuffer == NULL)\r\nreturn -ENOMEM;\r\ncurrCmd = cmdBuffer;\r\nMAKE_CMD_WRITE_REG(&currCmd, &cmdLen,\r\nedge_port->port->number - edge_port->port->serial->minor,\r\nregNum, regValue);\r\nstatus = write_cmd_usb(edge_port, cmdBuffer, cmdLen);\r\nif (status) {\r\nkfree(cmdBuffer);\r\n}\r\nreturn status;\r\n}\r\nstatic void change_port_settings(struct tty_struct *tty,\r\nstruct edgeport_port *edge_port, struct ktermios *old_termios)\r\n{\r\nstruct edgeport_serial *edge_serial =\r\nusb_get_serial_data(edge_port->port->serial);\r\nint baud;\r\nunsigned cflag;\r\n__u8 mask = 0xff;\r\n__u8 lData;\r\n__u8 lParity;\r\n__u8 lStop;\r\n__u8 rxFlow;\r\n__u8 txFlow;\r\nint status;\r\ndbg("%s - port %d", __func__, edge_port->port->number);\r\nif (!edge_port->open &&\r\n!edge_port->openPending) {\r\ndbg("%s - port not opened", __func__);\r\nreturn;\r\n}\r\ncflag = tty->termios->c_cflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nlData = LCR_BITS_5; mask = 0x1f;\r\ndbg("%s - data bits = 5", __func__);\r\nbreak;\r\ncase CS6:\r\nlData = LCR_BITS_6; mask = 0x3f;\r\ndbg("%s - data bits = 6", __func__);\r\nbreak;\r\ncase CS7:\r\nlData = LCR_BITS_7; mask = 0x7f;\r\ndbg("%s - data bits = 7", __func__);\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nlData = LCR_BITS_8;\r\ndbg("%s - data bits = 8", __func__);\r\nbreak;\r\n}\r\nlParity = LCR_PAR_NONE;\r\nif (cflag & PARENB) {\r\nif (cflag & CMSPAR) {\r\nif (cflag & PARODD) {\r\nlParity = LCR_PAR_MARK;\r\ndbg("%s - parity = mark", __func__);\r\n} else {\r\nlParity = LCR_PAR_SPACE;\r\ndbg("%s - parity = space", __func__);\r\n}\r\n} else if (cflag & PARODD) {\r\nlParity = LCR_PAR_ODD;\r\ndbg("%s - parity = odd", __func__);\r\n} else {\r\nlParity = LCR_PAR_EVEN;\r\ndbg("%s - parity = even", __func__);\r\n}\r\n} else {\r\ndbg("%s - parity = none", __func__);\r\n}\r\nif (cflag & CSTOPB) {\r\nlStop = LCR_STOP_2;\r\ndbg("%s - stop bits = 2", __func__);\r\n} else {\r\nlStop = LCR_STOP_1;\r\ndbg("%s - stop bits = 1", __func__);\r\n}\r\nrxFlow = txFlow = 0x00;\r\nif (cflag & CRTSCTS) {\r\nrxFlow |= IOSP_RX_FLOW_RTS;\r\ntxFlow |= IOSP_TX_FLOW_CTS;\r\ndbg("%s - RTS/CTS is enabled", __func__);\r\n} else {\r\ndbg("%s - RTS/CTS is disabled", __func__);\r\n}\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nunsigned char start_char = START_CHAR(tty);\r\nif ((!edge_serial->is_epic) ||\r\n((edge_serial->is_epic) &&\r\n(edge_serial->epic_descriptor.Supports.IOSPSetXChar))) {\r\nsend_iosp_ext_cmd(edge_port,\r\nIOSP_CMD_SET_XON_CHAR, start_char);\r\nsend_iosp_ext_cmd(edge_port,\r\nIOSP_CMD_SET_XOFF_CHAR, stop_char);\r\n}\r\nif (I_IXOFF(tty)) {\r\nrxFlow |= IOSP_RX_FLOW_XON_XOFF;\r\ndbg("%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x",\r\n__func__, start_char, stop_char);\r\n} else {\r\ndbg("%s - INBOUND XON/XOFF is disabled", __func__);\r\n}\r\nif (I_IXON(tty)) {\r\ntxFlow |= IOSP_TX_FLOW_XON_XOFF;\r\ndbg("%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x",\r\n__func__, start_char, stop_char);\r\n} else {\r\ndbg("%s - OUTBOUND XON/XOFF is disabled", __func__);\r\n}\r\n}\r\nif ((!edge_serial->is_epic) ||\r\n((edge_serial->is_epic) &&\r\n(edge_serial->epic_descriptor.Supports.IOSPSetRxFlow)))\r\nsend_iosp_ext_cmd(edge_port, IOSP_CMD_SET_RX_FLOW, rxFlow);\r\nif ((!edge_serial->is_epic) ||\r\n((edge_serial->is_epic) &&\r\n(edge_serial->epic_descriptor.Supports.IOSPSetTxFlow)))\r\nsend_iosp_ext_cmd(edge_port, IOSP_CMD_SET_TX_FLOW, txFlow);\r\nedge_port->shadowLCR &= ~(LCR_BITS_MASK | LCR_STOP_MASK | LCR_PAR_MASK);\r\nedge_port->shadowLCR |= (lData | lParity | lStop);\r\nedge_port->validDataMask = mask;\r\nstatus = send_cmd_write_uart_register(edge_port, LCR,\r\nedge_port->shadowLCR);\r\nif (status != 0)\r\nreturn;\r\nedge_port->shadowMCR = MCR_MASTER_IE;\r\nif (cflag & CBAUD)\r\nedge_port->shadowMCR |= (MCR_DTR | MCR_RTS);\r\nstatus = send_cmd_write_uart_register(edge_port, MCR,\r\nedge_port->shadowMCR);\r\nif (status != 0)\r\nreturn;\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud) {\r\nbaud = 9600;\r\n}\r\ndbg("%s - baud rate = %d", __func__, baud);\r\nstatus = send_cmd_write_baud_rate(edge_port, baud);\r\nif (status == -1) {\r\nbaud = tty_termios_baud_rate(old_termios);\r\ntty_encode_baud_rate(tty, baud, baud);\r\n}\r\n}\r\nstatic void unicode_to_ascii(char *string, int buflen,\r\n__le16 *unicode, int unicode_size)\r\n{\r\nint i;\r\nif (buflen <= 0)\r\nreturn;\r\n--buflen;\r\nfor (i = 0; i < unicode_size; i++) {\r\nif (i >= buflen)\r\nbreak;\r\nstring[i] = (char)(le16_to_cpu(unicode[i]));\r\n}\r\nstring[i] = 0x00;\r\n}\r\nstatic void get_manufacturing_desc(struct edgeport_serial *edge_serial)\r\n{\r\nint response;\r\ndbg("getting manufacturer descriptor");\r\nresponse = rom_read(edge_serial->serial,\r\n(EDGE_MANUF_DESC_ADDR & 0xffff0000) >> 16,\r\n(__u16)(EDGE_MANUF_DESC_ADDR & 0x0000ffff),\r\nEDGE_MANUF_DESC_LEN,\r\n(__u8 *)(&edge_serial->manuf_descriptor));\r\nif (response < 1)\r\ndev_err(&edge_serial->serial->dev->dev,\r\n"error in getting manufacturer descriptor\n");\r\nelse {\r\nchar string[30];\r\ndbg("**Manufacturer Descriptor");\r\ndbg(" RomSize: %dK",\r\nedge_serial->manuf_descriptor.RomSize);\r\ndbg(" RamSize: %dK",\r\nedge_serial->manuf_descriptor.RamSize);\r\ndbg(" CpuRev: %d",\r\nedge_serial->manuf_descriptor.CpuRev);\r\ndbg(" BoardRev: %d",\r\nedge_serial->manuf_descriptor.BoardRev);\r\ndbg(" NumPorts: %d",\r\nedge_serial->manuf_descriptor.NumPorts);\r\ndbg(" DescDate: %d/%d/%d",\r\nedge_serial->manuf_descriptor.DescDate[0],\r\nedge_serial->manuf_descriptor.DescDate[1],\r\nedge_serial->manuf_descriptor.DescDate[2]+1900);\r\nunicode_to_ascii(string, sizeof(string),\r\nedge_serial->manuf_descriptor.SerialNumber,\r\nedge_serial->manuf_descriptor.SerNumLength/2);\r\ndbg(" SerialNumber: %s", string);\r\nunicode_to_ascii(string, sizeof(string),\r\nedge_serial->manuf_descriptor.AssemblyNumber,\r\nedge_serial->manuf_descriptor.AssemblyNumLength/2);\r\ndbg(" AssemblyNumber: %s", string);\r\nunicode_to_ascii(string, sizeof(string),\r\nedge_serial->manuf_descriptor.OemAssyNumber,\r\nedge_serial->manuf_descriptor.OemAssyNumLength/2);\r\ndbg(" OemAssyNumber: %s", string);\r\ndbg(" UartType: %d",\r\nedge_serial->manuf_descriptor.UartType);\r\ndbg(" IonPid: %d",\r\nedge_serial->manuf_descriptor.IonPid);\r\ndbg(" IonConfig: %d",\r\nedge_serial->manuf_descriptor.IonConfig);\r\n}\r\n}\r\nstatic void get_boot_desc(struct edgeport_serial *edge_serial)\r\n{\r\nint response;\r\ndbg("getting boot descriptor");\r\nresponse = rom_read(edge_serial->serial,\r\n(EDGE_BOOT_DESC_ADDR & 0xffff0000) >> 16,\r\n(__u16)(EDGE_BOOT_DESC_ADDR & 0x0000ffff),\r\nEDGE_BOOT_DESC_LEN,\r\n(__u8 *)(&edge_serial->boot_descriptor));\r\nif (response < 1)\r\ndev_err(&edge_serial->serial->dev->dev,\r\n"error in getting boot descriptor\n");\r\nelse {\r\ndbg("**Boot Descriptor:");\r\ndbg(" BootCodeLength: %d",\r\nle16_to_cpu(edge_serial->boot_descriptor.BootCodeLength));\r\ndbg(" MajorVersion: %d",\r\nedge_serial->boot_descriptor.MajorVersion);\r\ndbg(" MinorVersion: %d",\r\nedge_serial->boot_descriptor.MinorVersion);\r\ndbg(" BuildNumber: %d",\r\nle16_to_cpu(edge_serial->boot_descriptor.BuildNumber));\r\ndbg(" Capabilities: 0x%x",\r\nle16_to_cpu(edge_serial->boot_descriptor.Capabilities));\r\ndbg(" UConfig0: %d",\r\nedge_serial->boot_descriptor.UConfig0);\r\ndbg(" UConfig1: %d",\r\nedge_serial->boot_descriptor.UConfig1);\r\n}\r\n}\r\nstatic void load_application_firmware(struct edgeport_serial *edge_serial)\r\n{\r\nconst struct ihex_binrec *rec;\r\nconst struct firmware *fw;\r\nconst char *fw_name;\r\nconst char *fw_info;\r\nint response;\r\n__u32 Operaddr;\r\n__u16 build;\r\nswitch (edge_serial->product_info.iDownloadFile) {\r\ncase EDGE_DOWNLOAD_FILE_I930:\r\nfw_info = "downloading firmware version (930)";\r\nfw_name = "edgeport/down.fw";\r\nbreak;\r\ncase EDGE_DOWNLOAD_FILE_80251:\r\nfw_info = "downloading firmware version (80251)";\r\nfw_name = "edgeport/down2.fw";\r\nbreak;\r\ncase EDGE_DOWNLOAD_FILE_NONE:\r\ndbg("No download file specified, skipping download");\r\nreturn;\r\ndefault:\r\nreturn;\r\n}\r\nresponse = request_ihex_firmware(&fw, fw_name,\r\n&edge_serial->serial->dev->dev);\r\nif (response) {\r\nprintk(KERN_ERR "Failed to load image \"%s\" err %d\n",\r\nfw_name, response);\r\nreturn;\r\n}\r\nrec = (const struct ihex_binrec *)fw->data;\r\nbuild = (rec->data[2] << 8) | rec->data[3];\r\ndbg("%s %d.%d.%d", fw_info, rec->data[0], rec->data[1], build);\r\nedge_serial->product_info.FirmwareMajorVersion = rec->data[0];\r\nedge_serial->product_info.FirmwareMinorVersion = rec->data[1];\r\nedge_serial->product_info.FirmwareBuildNumber = cpu_to_le16(build);\r\nfor (rec = ihex_next_binrec(rec); rec;\r\nrec = ihex_next_binrec(rec)) {\r\nOperaddr = be32_to_cpu(rec->addr);\r\nresponse = sram_write(edge_serial->serial,\r\nOperaddr >> 16,\r\nOperaddr & 0xFFFF,\r\nbe16_to_cpu(rec->len),\r\n&rec->data[0]);\r\nif (response < 0) {\r\ndev_err(&edge_serial->serial->dev->dev,\r\n"sram_write failed (%x, %x, %d)\n",\r\nOperaddr >> 16, Operaddr & 0xFFFF,\r\nbe16_to_cpu(rec->len));\r\nbreak;\r\n}\r\n}\r\ndbg("sending exec_dl_code");\r\nresponse = usb_control_msg (edge_serial->serial->dev,\r\nusb_sndctrlpipe(edge_serial->serial->dev, 0),\r\nUSB_REQUEST_ION_EXEC_DL_CODE,\r\n0x40, 0x4000, 0x0001, NULL, 0, 3000);\r\nrelease_firmware(fw);\r\n}\r\nstatic int edge_startup(struct usb_serial *serial)\r\n{\r\nstruct edgeport_serial *edge_serial;\r\nstruct edgeport_port *edge_port;\r\nstruct usb_device *dev;\r\nint i, j;\r\nint response;\r\nbool interrupt_in_found;\r\nbool bulk_in_found;\r\nbool bulk_out_found;\r\nstatic __u32 descriptor[3] = { EDGE_COMPATIBILITY_MASK0,\r\nEDGE_COMPATIBILITY_MASK1,\r\nEDGE_COMPATIBILITY_MASK2 };\r\ndev = serial->dev;\r\nedge_serial = kzalloc(sizeof(struct edgeport_serial), GFP_KERNEL);\r\nif (edge_serial == NULL) {\r\ndev_err(&serial->dev->dev, "%s - Out of memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&edge_serial->es_lock);\r\nedge_serial->serial = serial;\r\nusb_set_serial_data(serial, edge_serial);\r\ni = usb_string(dev, dev->descriptor.iManufacturer,\r\n&edge_serial->name[0], MAX_NAME_LEN+1);\r\nif (i < 0)\r\ni = 0;\r\nedge_serial->name[i++] = ' ';\r\nusb_string(dev, dev->descriptor.iProduct,\r\n&edge_serial->name[i], MAX_NAME_LEN+2 - i);\r\ndev_info(&serial->dev->dev, "%s detected\n", edge_serial->name);\r\nif (get_epic_descriptor(edge_serial) <= 0) {\r\nmemcpy(&edge_serial->epic_descriptor.Supports, descriptor,\r\nsizeof(struct edge_compatibility_bits));\r\nget_manufacturing_desc(edge_serial);\r\nget_boot_desc(edge_serial);\r\nget_product_info(edge_serial);\r\n}\r\nif ((!edge_serial->is_epic) &&\r\n(edge_serial->product_info.NumPorts != serial->num_ports)) {\r\ndev_warn(&serial->dev->dev, "Device Reported %d serial ports "\r\n"vs. core thinking we have %d ports, email "\r\n"greg@kroah.com this information.\n",\r\nedge_serial->product_info.NumPorts,\r\nserial->num_ports);\r\n}\r\ndbg("%s - time 1 %ld", __func__, jiffies);\r\nif (!edge_serial->is_epic) {\r\nload_application_firmware(edge_serial);\r\ndbg("%s - time 2 %ld", __func__, jiffies);\r\nupdate_edgeport_E2PROM(edge_serial);\r\ndbg("%s - time 3 %ld", __func__, jiffies);\r\n}\r\ndbg(" FirmwareMajorVersion %d.%d.%d",\r\nedge_serial->product_info.FirmwareMajorVersion,\r\nedge_serial->product_info.FirmwareMinorVersion,\r\nle16_to_cpu(edge_serial->product_info.FirmwareBuildNumber));\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nedge_port = kzalloc(sizeof(struct edgeport_port), GFP_KERNEL);\r\nif (edge_port == NULL) {\r\ndev_err(&serial->dev->dev, "%s - Out of memory\n",\r\n__func__);\r\nfor (j = 0; j < i; ++j) {\r\nkfree(usb_get_serial_port_data(serial->port[j]));\r\nusb_set_serial_port_data(serial->port[j],\r\nNULL);\r\n}\r\nusb_set_serial_data(serial, NULL);\r\nkfree(edge_serial);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&edge_port->ep_lock);\r\nedge_port->port = serial->port[i];\r\nusb_set_serial_port_data(serial->port[i], edge_port);\r\n}\r\nresponse = 0;\r\nif (edge_serial->is_epic) {\r\ninterrupt_in_found = bulk_in_found = bulk_out_found = false;\r\nfor (i = 0; i < serial->interface->altsetting[0]\r\n.desc.bNumEndpoints; ++i) {\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint buffer_size;\r\nendpoint = &serial->interface->altsetting[0].\r\nendpoint[i].desc;\r\nbuffer_size = usb_endpoint_maxp(endpoint);\r\nif (!interrupt_in_found &&\r\n(usb_endpoint_is_int_in(endpoint))) {\r\ndbg("found interrupt in");\r\nedge_serial->interrupt_read_urb =\r\nusb_alloc_urb(0, GFP_KERNEL);\r\nif (!edge_serial->interrupt_read_urb) {\r\ndev_err(&dev->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nedge_serial->interrupt_in_buffer =\r\nkmalloc(buffer_size, GFP_KERNEL);\r\nif (!edge_serial->interrupt_in_buffer) {\r\ndev_err(&dev->dev, "out of memory\n");\r\nusb_free_urb(edge_serial->interrupt_read_urb);\r\nreturn -ENOMEM;\r\n}\r\nedge_serial->interrupt_in_endpoint =\r\nendpoint->bEndpointAddress;\r\nusb_fill_int_urb(\r\nedge_serial->interrupt_read_urb,\r\ndev,\r\nusb_rcvintpipe(dev,\r\nendpoint->bEndpointAddress),\r\nedge_serial->interrupt_in_buffer,\r\nbuffer_size,\r\nedge_interrupt_callback,\r\nedge_serial,\r\nendpoint->bInterval);\r\ninterrupt_in_found = true;\r\n}\r\nif (!bulk_in_found &&\r\n(usb_endpoint_is_bulk_in(endpoint))) {\r\ndbg("found bulk in");\r\nedge_serial->read_urb =\r\nusb_alloc_urb(0, GFP_KERNEL);\r\nif (!edge_serial->read_urb) {\r\ndev_err(&dev->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nedge_serial->bulk_in_buffer =\r\nkmalloc(buffer_size, GFP_KERNEL);\r\nif (!edge_serial->bulk_in_buffer) {\r\ndev_err(&dev->dev, "out of memory\n");\r\nusb_free_urb(edge_serial->read_urb);\r\nreturn -ENOMEM;\r\n}\r\nedge_serial->bulk_in_endpoint =\r\nendpoint->bEndpointAddress;\r\nusb_fill_bulk_urb(edge_serial->read_urb, dev,\r\nusb_rcvbulkpipe(dev,\r\nendpoint->bEndpointAddress),\r\nedge_serial->bulk_in_buffer,\r\nusb_endpoint_maxp(endpoint),\r\nedge_bulk_in_callback,\r\nedge_serial);\r\nbulk_in_found = true;\r\n}\r\nif (!bulk_out_found &&\r\n(usb_endpoint_is_bulk_out(endpoint))) {\r\ndbg("found bulk out");\r\nedge_serial->bulk_out_endpoint =\r\nendpoint->bEndpointAddress;\r\nbulk_out_found = true;\r\n}\r\n}\r\nif (!interrupt_in_found || !bulk_in_found || !bulk_out_found) {\r\ndev_err(&dev->dev, "Error - the proper endpoints "\r\n"were not found!\n");\r\nreturn -ENODEV;\r\n}\r\nresponse = usb_submit_urb(edge_serial->interrupt_read_urb,\r\nGFP_KERNEL);\r\nif (response)\r\ndev_err(&dev->dev,\r\n"%s - Error %d submitting control urb\n",\r\n__func__, response);\r\n}\r\nreturn response;\r\n}\r\nstatic void edge_disconnect(struct usb_serial *serial)\r\n{\r\nstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\r\ndbg("%s", __func__);\r\nif (edge_serial->is_epic) {\r\nusb_kill_urb(edge_serial->interrupt_read_urb);\r\nusb_free_urb(edge_serial->interrupt_read_urb);\r\nkfree(edge_serial->interrupt_in_buffer);\r\nusb_kill_urb(edge_serial->read_urb);\r\nusb_free_urb(edge_serial->read_urb);\r\nkfree(edge_serial->bulk_in_buffer);\r\n}\r\n}\r\nstatic void edge_release(struct usb_serial *serial)\r\n{\r\nstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\r\nint i;\r\ndbg("%s", __func__);\r\nfor (i = 0; i < serial->num_ports; ++i)\r\nkfree(usb_get_serial_port_data(serial->port[i]));\r\nkfree(edge_serial);\r\n}
