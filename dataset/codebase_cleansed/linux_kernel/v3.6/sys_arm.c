asmlinkage int sys_fork(struct pt_regs *regs)\r\n{\r\n#ifdef CONFIG_MMU\r\nreturn do_fork(SIGCHLD, regs->ARM_sp, regs, 0, NULL, NULL);\r\n#else\r\nreturn(-EINVAL);\r\n#endif\r\n}\r\nasmlinkage int sys_clone(unsigned long clone_flags, unsigned long newsp,\r\nint __user *parent_tidptr, int tls_val,\r\nint __user *child_tidptr, struct pt_regs *regs)\r\n{\r\nif (!newsp)\r\nnewsp = regs->ARM_sp;\r\nreturn do_fork(clone_flags, newsp, regs, 0, parent_tidptr, child_tidptr);\r\n}\r\nasmlinkage int sys_vfork(struct pt_regs *regs)\r\n{\r\nreturn do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->ARM_sp, regs, 0, NULL, NULL);\r\n}\r\nasmlinkage int sys_execve(const char __user *filenamei,\r\nconst char __user *const __user *argv,\r\nconst char __user *const __user *envp, struct pt_regs *regs)\r\n{\r\nint error;\r\nchar * filename;\r\nfilename = getname(filenamei);\r\nerror = PTR_ERR(filename);\r\nif (IS_ERR(filename))\r\ngoto out;\r\nerror = do_execve(filename, argv, envp, regs);\r\nputname(filename);\r\nout:\r\nreturn error;\r\n}\r\nint kernel_execve(const char *filename,\r\nconst char *const argv[],\r\nconst char *const envp[])\r\n{\r\nstruct pt_regs regs;\r\nint ret;\r\nmemset(&regs, 0, sizeof(struct pt_regs));\r\nret = do_execve(filename,\r\n(const char __user *const __user *)argv,\r\n(const char __user *const __user *)envp, &regs);\r\nif (ret < 0)\r\ngoto out;\r\nregs.ARM_r0 = ret;\r\nasm( "add r0, %0, %1\n\t"\r\n"mov r1, %2\n\t"\r\n"mov r2, %3\n\t"\r\n"bl memmove\n\t"\r\n"mov r8, #0\n\t"\r\n"mov r9, %0\n\t"\r\n"mov sp, r0\n\t"\r\n"b ret_to_user"\r\n:\r\n: "r" (current_thread_info()),\r\n"Ir" (THREAD_START_SP - sizeof(regs)),\r\n"r" (&regs),\r\n"Ir" (sizeof(regs))\r\n: "r0", "r1", "r2", "r3", "r8", "r9", "ip", "lr", "memory");\r\nout:\r\nreturn ret;\r\n}\r\nasmlinkage long sys_arm_fadvise64_64(int fd, int advice,\r\nloff_t offset, loff_t len)\r\n{\r\nreturn sys_fadvise64_64(fd, offset, len, advice);\r\n}
