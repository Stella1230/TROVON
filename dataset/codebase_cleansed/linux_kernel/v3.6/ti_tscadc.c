static unsigned int tscadc_readl(struct tscadc *ts, unsigned int reg)\r\n{\r\nreturn readl(ts->tsc_base + reg);\r\n}\r\nstatic void tscadc_writel(struct tscadc *tsc, unsigned int reg,\r\nunsigned int val)\r\n{\r\nwritel(val, tsc->tsc_base + reg);\r\n}\r\nstatic void tscadc_step_config(struct tscadc *ts_dev)\r\n{\r\nunsigned int config;\r\nint i;\r\nconfig = STEPCONFIG_MODE_HWSYNC |\r\nSTEPCONFIG_SAMPLES_AVG | STEPCONFIG_XPP;\r\nswitch (ts_dev->wires) {\r\ncase 4:\r\nconfig |= STEPCONFIG_INP | STEPCONFIG_XNN;\r\nbreak;\r\ncase 5:\r\nconfig |= STEPCONFIG_YNN |\r\nSTEPCONFIG_INP_5 | STEPCONFIG_XNN |\r\nSTEPCONFIG_YPP;\r\nbreak;\r\ncase 8:\r\nconfig |= STEPCONFIG_INP | STEPCONFIG_XNN;\r\nbreak;\r\n}\r\nfor (i = 1; i < 7; i++) {\r\ntscadc_writel(ts_dev, REG_STEPCONFIG(i), config);\r\ntscadc_writel(ts_dev, REG_STEPDELAY(i), STEPCONFIG_OPENDLY);\r\n}\r\nconfig = 0;\r\nconfig = STEPCONFIG_MODE_HWSYNC |\r\nSTEPCONFIG_SAMPLES_AVG | STEPCONFIG_YNN |\r\nSTEPCONFIG_INM | STEPCONFIG_FIFO1;\r\nswitch (ts_dev->wires) {\r\ncase 4:\r\nconfig |= STEPCONFIG_YPP;\r\nbreak;\r\ncase 5:\r\nconfig |= STEPCONFIG_XPP | STEPCONFIG_INP_5 |\r\nSTEPCONFIG_XNP | STEPCONFIG_YPN;\r\nbreak;\r\ncase 8:\r\nconfig |= STEPCONFIG_YPP;\r\nbreak;\r\n}\r\nfor (i = 7; i < 13; i++) {\r\ntscadc_writel(ts_dev, REG_STEPCONFIG(i), config);\r\ntscadc_writel(ts_dev, REG_STEPDELAY(i), STEPCONFIG_OPENDLY);\r\n}\r\nconfig = 0;\r\nconfig = STEPCONFIG_XPP | STEPCONFIG_YNN |\r\nSTEPCHARGE_RFP | STEPCHARGE_RFM |\r\nSTEPCHARGE_INM | STEPCHARGE_INP;\r\ntscadc_writel(ts_dev, REG_CHARGECONFIG, config);\r\ntscadc_writel(ts_dev, REG_CHARGEDELAY, STEPCHARGE_DELAY);\r\nconfig = 0;\r\nconfig = STEPCONFIG_MODE_HWSYNC |\r\nSTEPCONFIG_SAMPLES_AVG | STEPCONFIG_YPP |\r\nSTEPCONFIG_XNN | STEPCONFIG_INM;\r\ntscadc_writel(ts_dev, REG_STEPCONFIG13, config);\r\ntscadc_writel(ts_dev, REG_STEPDELAY13, STEPCONFIG_OPENDLY);\r\nconfig |= STEPCONFIG_Z1 | STEPCONFIG_FIFO1;\r\ntscadc_writel(ts_dev, REG_STEPCONFIG14, config);\r\ntscadc_writel(ts_dev, REG_STEPDELAY14, STEPCONFIG_OPENDLY);\r\ntscadc_writel(ts_dev, REG_SE, STPENB_STEPENB);\r\n}\r\nstatic void tscadc_idle_config(struct tscadc *ts_config)\r\n{\r\nunsigned int idleconfig;\r\nidleconfig = STEPCONFIG_YNN |\r\nSTEPCONFIG_INM |\r\nSTEPCONFIG_YPN | STEPIDLE_INP;\r\ntscadc_writel(ts_config, REG_IDLECONFIG, idleconfig);\r\n}\r\nstatic void tscadc_read_coordinates(struct tscadc *ts_dev,\r\nunsigned int *x, unsigned int *y)\r\n{\r\nunsigned int fifocount = tscadc_readl(ts_dev, REG_FIFO0CNT);\r\nunsigned int prev_val_x = ~0, prev_val_y = ~0;\r\nunsigned int prev_diff_x = ~0, prev_diff_y = ~0;\r\nunsigned int read, diff;\r\nunsigned int i;\r\nfor (i = 0; i < fifocount - 1; i++) {\r\nread = tscadc_readl(ts_dev, REG_FIFO0) & 0xfff;\r\ndiff = abs(read - prev_val_x);\r\nif (diff < prev_diff_x) {\r\nprev_diff_x = diff;\r\n*x = read;\r\n}\r\nprev_val_x = read;\r\nread = tscadc_readl(ts_dev, REG_FIFO1) & 0xfff;\r\ndiff = abs(read - prev_val_y);\r\nif (diff < prev_diff_y) {\r\nprev_diff_y = diff;\r\n*y = read;\r\n}\r\nprev_val_y = read;\r\n}\r\n}\r\nstatic irqreturn_t tscadc_irq(int irq, void *dev)\r\n{\r\nstruct tscadc *ts_dev = dev;\r\nstruct input_dev *input_dev = ts_dev->input;\r\nunsigned int status, irqclr = 0;\r\nunsigned int x = 0, y = 0;\r\nunsigned int z1, z2, z;\r\nunsigned int fsm;\r\nstatus = tscadc_readl(ts_dev, REG_IRQSTATUS);\r\nif (status & IRQENB_FIFO1THRES) {\r\ntscadc_read_coordinates(ts_dev, &x, &y);\r\nz1 = tscadc_readl(ts_dev, REG_FIFO0) & 0xfff;\r\nz2 = tscadc_readl(ts_dev, REG_FIFO1) & 0xfff;\r\nif (ts_dev->pen_down && z1 != 0 && z2 != 0) {\r\nz = z2 - z1;\r\nz *= x;\r\nz *= ts_dev->x_plate_resistance;\r\nz /= z1;\r\nz = (z + 2047) >> 12;\r\nif (z <= MAX_12BIT) {\r\ninput_report_abs(input_dev, ABS_X, x);\r\ninput_report_abs(input_dev, ABS_Y, y);\r\ninput_report_abs(input_dev, ABS_PRESSURE, z);\r\ninput_report_key(input_dev, BTN_TOUCH, 1);\r\ninput_sync(input_dev);\r\n}\r\n}\r\nirqclr |= IRQENB_FIFO1THRES;\r\n}\r\nudelay(SEQ_SETTLE);\r\nstatus = tscadc_readl(ts_dev, REG_RAWIRQSTATUS);\r\nif (status & IRQENB_PENUP) {\r\nfsm = tscadc_readl(ts_dev, REG_ADCFSM);\r\nif (fsm == ADCFSM_STEPID) {\r\nts_dev->pen_down = false;\r\ninput_report_key(input_dev, BTN_TOUCH, 0);\r\ninput_report_abs(input_dev, ABS_PRESSURE, 0);\r\ninput_sync(input_dev);\r\n} else {\r\nts_dev->pen_down = true;\r\n}\r\nirqclr |= IRQENB_PENUP;\r\n}\r\ntscadc_writel(ts_dev, REG_IRQSTATUS, irqclr);\r\ntscadc_writel(ts_dev, REG_IRQEOI, 0x0);\r\ntscadc_writel(ts_dev, REG_SE, STPENB_STEPENB);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit tscadc_probe(struct platform_device *pdev)\r\n{\r\nconst struct tsc_data *pdata = pdev->dev.platform_data;\r\nstruct resource *res;\r\nstruct tscadc *ts_dev;\r\nstruct input_dev *input_dev;\r\nstruct clk *clk;\r\nint err;\r\nint clk_value, ctrl, irq;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "missing platform data.\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no memory resource defined.\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq ID is specified.\n");\r\nreturn -EINVAL;\r\n}\r\nts_dev = kzalloc(sizeof(struct tscadc), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts_dev || !input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate memory.\n");\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nts_dev->input = input_dev;\r\nts_dev->irq = irq;\r\nts_dev->wires = pdata->wires;\r\nts_dev->x_plate_resistance = pdata->x_plate_resistance;\r\nres = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to reserve registers.\n");\r\nerr = -EBUSY;\r\ngoto err_free_mem;\r\n}\r\nts_dev->tsc_base = ioremap(res->start, resource_size(res));\r\nif (!ts_dev->tsc_base) {\r\ndev_err(&pdev->dev, "failed to map registers.\n");\r\nerr = -ENOMEM;\r\ngoto err_release_mem_region;\r\n}\r\nerr = request_irq(ts_dev->irq, tscadc_irq,\r\n0, pdev->dev.driver->name, ts_dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to allocate irq.\n");\r\ngoto err_unmap_regs;\r\n}\r\nts_dev->tsc_ick = clk_get(&pdev->dev, "adc_tsc_ick");\r\nif (IS_ERR(ts_dev->tsc_ick)) {\r\ndev_err(&pdev->dev, "failed to get TSC ick\n");\r\ngoto err_free_irq;\r\n}\r\nclk_enable(ts_dev->tsc_ick);\r\nclk = clk_get(&pdev->dev, "adc_tsc_fck");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get TSC fck\n");\r\nerr = PTR_ERR(clk);\r\ngoto err_disable_clk;\r\n}\r\nclk_value = clk_get_rate(clk) / ADC_CLK;\r\nclk_put(clk);\r\nif (clk_value < 7) {\r\ndev_err(&pdev->dev, "clock input less than min clock requirement\n");\r\ngoto err_disable_clk;\r\n}\r\ntscadc_writel(ts_dev, REG_CLKDIV, clk_value - 1);\r\ntscadc_writel(ts_dev, REG_IRQWAKEUP, IRQWKUP_ENB);\r\nctrl = CNTRLREG_STEPCONFIGWRT |\r\nCNTRLREG_TSCENB |\r\nCNTRLREG_STEPID;\r\nswitch (ts_dev->wires) {\r\ncase 4:\r\nctrl |= CNTRLREG_4WIRE;\r\nbreak;\r\ncase 5:\r\nctrl |= CNTRLREG_5WIRE;\r\nbreak;\r\ncase 8:\r\nctrl |= CNTRLREG_8WIRE;\r\nbreak;\r\n}\r\ntscadc_writel(ts_dev, REG_CTRL, ctrl);\r\ntscadc_idle_config(ts_dev);\r\ntscadc_writel(ts_dev, REG_IRQENABLE, IRQENB_FIFO1THRES);\r\ntscadc_step_config(ts_dev);\r\ntscadc_writel(ts_dev, REG_FIFO1THR, 6);\r\nctrl |= CNTRLREG_TSCSSENB;\r\ntscadc_writel(ts_dev, REG_CTRL, ctrl);\r\ninput_dev->name = "ti-tsc-adc";\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, MAX_12BIT, 0, 0);\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_disable_clk;\r\nplatform_set_drvdata(pdev, ts_dev);\r\nreturn 0;\r\nerr_disable_clk:\r\nclk_disable(ts_dev->tsc_ick);\r\nclk_put(ts_dev->tsc_ick);\r\nerr_free_irq:\r\nfree_irq(ts_dev->irq, ts_dev);\r\nerr_unmap_regs:\r\niounmap(ts_dev->tsc_base);\r\nerr_release_mem_region:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ts_dev);\r\nreturn err;\r\n}\r\nstatic int __devexit tscadc_remove(struct platform_device *pdev)\r\n{\r\nstruct tscadc *ts_dev = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nfree_irq(ts_dev->irq, ts_dev);\r\ninput_unregister_device(ts_dev->input);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niounmap(ts_dev->tsc_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_disable(ts_dev->tsc_ick);\r\nclk_put(ts_dev->tsc_ick);\r\nkfree(ts_dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
