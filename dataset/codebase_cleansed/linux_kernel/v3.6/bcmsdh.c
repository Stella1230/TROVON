static irqreturn_t brcmf_sdio_irqhandler(int irq, void *dev_id)\r\n{\r\nstruct brcmf_sdio_dev *sdiodev = dev_get_drvdata(dev_id);\r\nbrcmf_dbg(INTR, "oob intr triggered\n");\r\nif (sdiodev->irq_en) {\r\ndisable_irq_nosync(irq);\r\nsdiodev->irq_en = false;\r\n}\r\nbrcmf_sdbrcm_isr(sdiodev->bus);\r\nreturn IRQ_HANDLED;\r\n}\r\nint brcmf_sdio_intr_register(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nint ret = 0;\r\nu8 data;\r\nunsigned long flags;\r\nbrcmf_dbg(TRACE, "Entering\n");\r\nbrcmf_dbg(ERROR, "requesting irq %d\n", sdiodev->irq);\r\nret = request_irq(sdiodev->irq, brcmf_sdio_irqhandler,\r\nsdiodev->irq_flags, "brcmf_oob_intr",\r\n&sdiodev->func[1]->card->dev);\r\nif (ret != 0)\r\nreturn ret;\r\nspin_lock_init(&sdiodev->irq_en_lock);\r\nspin_lock_irqsave(&sdiodev->irq_en_lock, flags);\r\nsdiodev->irq_en = true;\r\nspin_unlock_irqrestore(&sdiodev->irq_en_lock, flags);\r\nret = enable_irq_wake(sdiodev->irq);\r\nif (ret != 0)\r\nreturn ret;\r\nsdiodev->irq_wake = true;\r\ndata = brcmf_sdio_regrb(sdiodev, SDIO_CCCR_IENx, &ret);\r\ndata |= 1 << SDIO_FUNC_1 | 1 << SDIO_FUNC_2 | 1;\r\nbrcmf_sdio_regwb(sdiodev, SDIO_CCCR_IENx, data, &ret);\r\ndata = SDIO_SEPINT_MASK | SDIO_SEPINT_OE;\r\nif (sdiodev->irq_flags & IRQF_TRIGGER_HIGH)\r\ndata |= SDIO_SEPINT_ACT_HI;\r\nbrcmf_sdio_regwb(sdiodev, SDIO_CCCR_BRCM_SEPINT, data, &ret);\r\nreturn 0;\r\n}\r\nint brcmf_sdio_intr_unregister(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nbrcmf_dbg(TRACE, "Entering\n");\r\nbrcmf_sdio_regwb(sdiodev, SDIO_CCCR_BRCM_SEPINT, 0, NULL);\r\nbrcmf_sdio_regwb(sdiodev, SDIO_CCCR_IENx, 0, NULL);\r\nif (sdiodev->irq_wake) {\r\ndisable_irq_wake(sdiodev->irq);\r\nsdiodev->irq_wake = false;\r\n}\r\nfree_irq(sdiodev->irq, &sdiodev->func[1]->card->dev);\r\nsdiodev->irq_en = false;\r\nreturn 0;\r\n}\r\nstatic void brcmf_sdio_irqhandler(struct sdio_func *func)\r\n{\r\nstruct brcmf_sdio_dev *sdiodev = dev_get_drvdata(&func->card->dev);\r\nbrcmf_dbg(INTR, "ib intr triggered\n");\r\nbrcmf_sdbrcm_isr(sdiodev->bus);\r\n}\r\nstatic void brcmf_sdio_dummy_irqhandler(struct sdio_func *func)\r\n{\r\n}\r\nint brcmf_sdio_intr_register(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nbrcmf_dbg(TRACE, "Entering\n");\r\nsdio_claim_host(sdiodev->func[1]);\r\nsdio_claim_irq(sdiodev->func[1], brcmf_sdio_irqhandler);\r\nsdio_claim_irq(sdiodev->func[2], brcmf_sdio_dummy_irqhandler);\r\nsdio_release_host(sdiodev->func[1]);\r\nreturn 0;\r\n}\r\nint brcmf_sdio_intr_unregister(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nbrcmf_dbg(TRACE, "Entering\n");\r\nsdio_claim_host(sdiodev->func[1]);\r\nsdio_release_irq(sdiodev->func[2]);\r\nsdio_release_irq(sdiodev->func[1]);\r\nsdio_release_host(sdiodev->func[1]);\r\nreturn 0;\r\n}\r\nint\r\nbrcmf_sdcard_set_sbaddr_window(struct brcmf_sdio_dev *sdiodev, u32 address)\r\n{\r\nint err = 0, i;\r\nu8 addr[3];\r\ns32 retry;\r\naddr[0] = (address >> 8) & SBSDIO_SBADDRLOW_MASK;\r\naddr[1] = (address >> 16) & SBSDIO_SBADDRMID_MASK;\r\naddr[2] = (address >> 24) & SBSDIO_SBADDRHIGH_MASK;\r\nfor (i = 0; i < 3; i++) {\r\nretry = 0;\r\ndo {\r\nif (retry)\r\nusleep_range(1000, 2000);\r\nerr = brcmf_sdioh_request_byte(sdiodev, SDIOH_WRITE,\r\nSDIO_FUNC_1, SBSDIO_FUNC1_SBADDRLOW + i,\r\n&addr[i]);\r\n} while (err != 0 && retry++ < SDIOH_API_ACCESS_RETRY_LIMIT);\r\nif (err) {\r\nbrcmf_dbg(ERROR, "failed at addr:0x%0x\n",\r\nSBSDIO_FUNC1_SBADDRLOW + i);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nbrcmf_sdio_regrw_helper(struct brcmf_sdio_dev *sdiodev, u32 addr,\r\nvoid *data, bool write)\r\n{\r\nu8 func_num, reg_size;\r\nu32 bar;\r\ns32 retry = 0;\r\nint ret;\r\nif ((addr & ~REG_F0_REG_MASK) == 0) {\r\nfunc_num = SDIO_FUNC_0;\r\nreg_size = 1;\r\n} else if ((addr & ~REG_F1_MISC_MASK) == 0) {\r\nfunc_num = SDIO_FUNC_1;\r\nreg_size = 1;\r\n} else {\r\nfunc_num = SDIO_FUNC_1;\r\nreg_size = 4;\r\nbar = addr & ~SBSDIO_SB_OFT_ADDR_MASK;\r\nif (bar != sdiodev->sbwad) {\r\nret = brcmf_sdcard_set_sbaddr_window(sdiodev, bar);\r\nif (ret != 0) {\r\nmemset(data, 0xFF, reg_size);\r\nreturn ret;\r\n}\r\nsdiodev->sbwad = bar;\r\n}\r\naddr &= SBSDIO_SB_OFT_ADDR_MASK;\r\naddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\r\n}\r\ndo {\r\nif (!write)\r\nmemset(data, 0, reg_size);\r\nif (retry)\r\nusleep_range(1000, 2000);\r\nif (reg_size == 1)\r\nret = brcmf_sdioh_request_byte(sdiodev, write,\r\nfunc_num, addr, data);\r\nelse\r\nret = brcmf_sdioh_request_word(sdiodev, write,\r\nfunc_num, addr, data, 4);\r\n} while (ret != 0 && retry++ < SDIOH_API_ACCESS_RETRY_LIMIT);\r\nif (ret != 0)\r\nbrcmf_dbg(ERROR, "failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nu8 brcmf_sdio_regrb(struct brcmf_sdio_dev *sdiodev, u32 addr, int *ret)\r\n{\r\nu8 data;\r\nint retval;\r\nbrcmf_dbg(INFO, "addr:0x%08x\n", addr);\r\nretval = brcmf_sdio_regrw_helper(sdiodev, addr, &data, false);\r\nbrcmf_dbg(INFO, "data:0x%02x\n", data);\r\nif (ret)\r\n*ret = retval;\r\nreturn data;\r\n}\r\nu32 brcmf_sdio_regrl(struct brcmf_sdio_dev *sdiodev, u32 addr, int *ret)\r\n{\r\nu32 data;\r\nint retval;\r\nbrcmf_dbg(INFO, "addr:0x%08x\n", addr);\r\nretval = brcmf_sdio_regrw_helper(sdiodev, addr, &data, false);\r\nbrcmf_dbg(INFO, "data:0x%08x\n", data);\r\nif (ret)\r\n*ret = retval;\r\nreturn data;\r\n}\r\nvoid brcmf_sdio_regwb(struct brcmf_sdio_dev *sdiodev, u32 addr,\r\nu8 data, int *ret)\r\n{\r\nint retval;\r\nbrcmf_dbg(INFO, "addr:0x%08x, data:0x%02x\n", addr, data);\r\nretval = brcmf_sdio_regrw_helper(sdiodev, addr, &data, true);\r\nif (ret)\r\n*ret = retval;\r\n}\r\nvoid brcmf_sdio_regwl(struct brcmf_sdio_dev *sdiodev, u32 addr,\r\nu32 data, int *ret)\r\n{\r\nint retval;\r\nbrcmf_dbg(INFO, "addr:0x%08x, data:0x%08x\n", addr, data);\r\nretval = brcmf_sdio_regrw_helper(sdiodev, addr, &data, true);\r\nif (ret)\r\n*ret = retval;\r\n}\r\nstatic int brcmf_sdcard_recv_prepare(struct brcmf_sdio_dev *sdiodev, uint fn,\r\nuint flags, uint width, u32 *addr)\r\n{\r\nuint bar0 = *addr & ~SBSDIO_SB_OFT_ADDR_MASK;\r\nint err = 0;\r\nif (flags & SDIO_REQ_ASYNC)\r\nreturn -ENOTSUPP;\r\nif (bar0 != sdiodev->sbwad) {\r\nerr = brcmf_sdcard_set_sbaddr_window(sdiodev, bar0);\r\nif (err)\r\nreturn err;\r\nsdiodev->sbwad = bar0;\r\n}\r\n*addr &= SBSDIO_SB_OFT_ADDR_MASK;\r\nif (width == 4)\r\n*addr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\r\nreturn 0;\r\n}\r\nint\r\nbrcmf_sdcard_recv_buf(struct brcmf_sdio_dev *sdiodev, u32 addr, uint fn,\r\nuint flags, u8 *buf, uint nbytes)\r\n{\r\nstruct sk_buff *mypkt;\r\nint err;\r\nmypkt = brcmu_pkt_buf_get_skb(nbytes);\r\nif (!mypkt) {\r\nbrcmf_dbg(ERROR, "brcmu_pkt_buf_get_skb failed: len %d\n",\r\nnbytes);\r\nreturn -EIO;\r\n}\r\nerr = brcmf_sdcard_recv_pkt(sdiodev, addr, fn, flags, mypkt);\r\nif (!err)\r\nmemcpy(buf, mypkt->data, nbytes);\r\nbrcmu_pkt_buf_free_skb(mypkt);\r\nreturn err;\r\n}\r\nint\r\nbrcmf_sdcard_recv_pkt(struct brcmf_sdio_dev *sdiodev, u32 addr, uint fn,\r\nuint flags, struct sk_buff *pkt)\r\n{\r\nuint incr_fix;\r\nuint width;\r\nint err = 0;\r\nbrcmf_dbg(INFO, "fun = %d, addr = 0x%x, size = %d\n",\r\nfn, addr, pkt->len);\r\nwidth = (flags & SDIO_REQ_4BYTE) ? 4 : 2;\r\nerr = brcmf_sdcard_recv_prepare(sdiodev, fn, flags, width, &addr);\r\nif (err)\r\nreturn err;\r\nincr_fix = (flags & SDIO_REQ_FIXED) ? SDIOH_DATA_FIX : SDIOH_DATA_INC;\r\nerr = brcmf_sdioh_request_buffer(sdiodev, incr_fix, SDIOH_READ,\r\nfn, addr, pkt);\r\nreturn err;\r\n}\r\nint brcmf_sdcard_recv_chain(struct brcmf_sdio_dev *sdiodev, u32 addr, uint fn,\r\nuint flags, struct sk_buff_head *pktq)\r\n{\r\nuint incr_fix;\r\nuint width;\r\nint err = 0;\r\nbrcmf_dbg(INFO, "fun = %d, addr = 0x%x, size = %d\n",\r\nfn, addr, pktq->qlen);\r\nwidth = (flags & SDIO_REQ_4BYTE) ? 4 : 2;\r\nerr = brcmf_sdcard_recv_prepare(sdiodev, fn, flags, width, &addr);\r\nif (err)\r\nreturn err;\r\nincr_fix = (flags & SDIO_REQ_FIXED) ? SDIOH_DATA_FIX : SDIOH_DATA_INC;\r\nerr = brcmf_sdioh_request_chain(sdiodev, incr_fix, SDIOH_READ, fn, addr,\r\npktq);\r\nreturn err;\r\n}\r\nint\r\nbrcmf_sdcard_send_buf(struct brcmf_sdio_dev *sdiodev, u32 addr, uint fn,\r\nuint flags, u8 *buf, uint nbytes)\r\n{\r\nstruct sk_buff *mypkt;\r\nint err;\r\nmypkt = brcmu_pkt_buf_get_skb(nbytes);\r\nif (!mypkt) {\r\nbrcmf_dbg(ERROR, "brcmu_pkt_buf_get_skb failed: len %d\n",\r\nnbytes);\r\nreturn -EIO;\r\n}\r\nmemcpy(mypkt->data, buf, nbytes);\r\nerr = brcmf_sdcard_send_pkt(sdiodev, addr, fn, flags, mypkt);\r\nbrcmu_pkt_buf_free_skb(mypkt);\r\nreturn err;\r\n}\r\nint\r\nbrcmf_sdcard_send_pkt(struct brcmf_sdio_dev *sdiodev, u32 addr, uint fn,\r\nuint flags, struct sk_buff *pkt)\r\n{\r\nuint incr_fix;\r\nuint width;\r\nuint bar0 = addr & ~SBSDIO_SB_OFT_ADDR_MASK;\r\nint err = 0;\r\nbrcmf_dbg(INFO, "fun = %d, addr = 0x%x, size = %d\n",\r\nfn, addr, pkt->len);\r\nif (flags & SDIO_REQ_ASYNC)\r\nreturn -ENOTSUPP;\r\nif (bar0 != sdiodev->sbwad) {\r\nerr = brcmf_sdcard_set_sbaddr_window(sdiodev, bar0);\r\nif (err)\r\nreturn err;\r\nsdiodev->sbwad = bar0;\r\n}\r\naddr &= SBSDIO_SB_OFT_ADDR_MASK;\r\nincr_fix = (flags & SDIO_REQ_FIXED) ? SDIOH_DATA_FIX : SDIOH_DATA_INC;\r\nwidth = (flags & SDIO_REQ_4BYTE) ? 4 : 2;\r\nif (width == 4)\r\naddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\r\nreturn brcmf_sdioh_request_buffer(sdiodev, incr_fix, SDIOH_WRITE, fn,\r\naddr, pkt);\r\n}\r\nint brcmf_sdcard_rwdata(struct brcmf_sdio_dev *sdiodev, uint rw, u32 addr,\r\nu8 *buf, uint nbytes)\r\n{\r\nstruct sk_buff *mypkt;\r\nbool write = rw ? SDIOH_WRITE : SDIOH_READ;\r\nint err;\r\naddr &= SBSDIO_SB_OFT_ADDR_MASK;\r\naddr |= SBSDIO_SB_ACCESS_2_4B_FLAG;\r\nmypkt = brcmu_pkt_buf_get_skb(nbytes);\r\nif (!mypkt) {\r\nbrcmf_dbg(ERROR, "brcmu_pkt_buf_get_skb failed: len %d\n",\r\nnbytes);\r\nreturn -EIO;\r\n}\r\nif (write)\r\nmemcpy(mypkt->data, buf, nbytes);\r\nerr = brcmf_sdioh_request_buffer(sdiodev, SDIOH_DATA_INC, write,\r\nSDIO_FUNC_1, addr, mypkt);\r\nif (!err && !write)\r\nmemcpy(buf, mypkt->data, nbytes);\r\nbrcmu_pkt_buf_free_skb(mypkt);\r\nreturn err;\r\n}\r\nint brcmf_sdcard_abort(struct brcmf_sdio_dev *sdiodev, uint fn)\r\n{\r\nchar t_func = (char)fn;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbrcmf_sdioh_request_byte(sdiodev, SDIOH_WRITE, SDIO_FUNC_0,\r\nSDIO_CCCR_ABORT, &t_func);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn 0;\r\n}\r\nint brcmf_sdio_probe(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nu32 regs = 0;\r\nint ret = 0;\r\nret = brcmf_sdioh_attach(sdiodev);\r\nif (ret)\r\ngoto out;\r\nregs = SI_ENUM_BASE;\r\nsdiodev->sbwad = SI_ENUM_BASE;\r\nsdiodev->bus = brcmf_sdbrcm_probe(regs, sdiodev);\r\nif (!sdiodev->bus) {\r\nbrcmf_dbg(ERROR, "device attach failed\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nout:\r\nif (ret)\r\nbrcmf_sdio_remove(sdiodev);\r\nreturn ret;\r\n}\r\nint brcmf_sdio_remove(struct brcmf_sdio_dev *sdiodev)\r\n{\r\nif (sdiodev->bus) {\r\nbrcmf_sdbrcm_disconnect(sdiodev->bus);\r\nsdiodev->bus = NULL;\r\n}\r\nbrcmf_sdioh_detach(sdiodev);\r\nsdiodev->sbwad = 0;\r\nreturn 0;\r\n}\r\nvoid brcmf_sdio_wdtmr_enable(struct brcmf_sdio_dev *sdiodev, bool enable)\r\n{\r\nif (enable)\r\nbrcmf_sdbrcm_wd_timer(sdiodev->bus, BRCMF_WD_POLL_MS);\r\nelse\r\nbrcmf_sdbrcm_wd_timer(sdiodev->bus, 0);\r\n}
