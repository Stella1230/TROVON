static int cxd2820r_wr_regs_i2c(struct cxd2820r_priv *priv, u8 i2c, u8 reg,\r\nu8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[len+1];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = i2c,\r\n.flags = 0,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\nwarn("i2c wr failed ret:%d reg:%02x len:%d", ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_rd_regs_i2c(struct cxd2820r_priv *priv, u8 i2c, u8 reg,\r\nu8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[len];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = i2c,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = i2c,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(buf),\r\n.buf = buf,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\nwarn("i2c rd failed ret:%d reg:%02x len:%d", ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nint cxd2820r_wr_regs(struct cxd2820r_priv *priv, u32 reginfo, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 i2c_addr;\r\nu8 reg = (reginfo >> 0) & 0xff;\r\nu8 bank = (reginfo >> 8) & 0xff;\r\nu8 i2c = (reginfo >> 16) & 0x01;\r\nif (i2c)\r\ni2c_addr = priv->cfg.i2c_address | (1 << 1);\r\nelse\r\ni2c_addr = priv->cfg.i2c_address;\r\nif (bank != priv->bank[i2c]) {\r\nret = cxd2820r_wr_regs_i2c(priv, i2c_addr, 0x00, &bank, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->bank[i2c] = bank;\r\n}\r\nreturn cxd2820r_wr_regs_i2c(priv, i2c_addr, reg, val, len);\r\n}\r\nint cxd2820r_rd_regs(struct cxd2820r_priv *priv, u32 reginfo, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 i2c_addr;\r\nu8 reg = (reginfo >> 0) & 0xff;\r\nu8 bank = (reginfo >> 8) & 0xff;\r\nu8 i2c = (reginfo >> 16) & 0x01;\r\nif (i2c)\r\ni2c_addr = priv->cfg.i2c_address | (1 << 1);\r\nelse\r\ni2c_addr = priv->cfg.i2c_address;\r\nif (bank != priv->bank[i2c]) {\r\nret = cxd2820r_wr_regs_i2c(priv, i2c_addr, 0x00, &bank, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->bank[i2c] = bank;\r\n}\r\nreturn cxd2820r_rd_regs_i2c(priv, i2c_addr, reg, val, len);\r\n}\r\nint cxd2820r_wr_reg(struct cxd2820r_priv *priv, u32 reg, u8 val)\r\n{\r\nreturn cxd2820r_wr_regs(priv, reg, &val, 1);\r\n}\r\nint cxd2820r_rd_reg(struct cxd2820r_priv *priv, u32 reg, u8 *val)\r\n{\r\nreturn cxd2820r_rd_regs(priv, reg, val, 1);\r\n}\r\nint cxd2820r_wr_reg_mask(struct cxd2820r_priv *priv, u32 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = cxd2820r_rd_reg(priv, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn cxd2820r_wr_reg(priv, reg, val);\r\n}\r\nint cxd2820r_gpio(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret, i;\r\nu8 *gpio, tmp0, tmp1;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\ngpio = priv->cfg.gpio_dvbt;\r\nbreak;\r\ncase SYS_DVBT2:\r\ngpio = priv->cfg.gpio_dvbt2;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_AC:\r\ngpio = priv->cfg.gpio_dvbc;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (!memcmp(gpio, priv->gpio, sizeof(priv->gpio)))\r\nreturn 0;\r\ntmp0 = 0x00;\r\ntmp1 = 0x00;\r\nfor (i = 0; i < sizeof(priv->gpio); i++) {\r\nif (gpio[i] & CXD2820R_GPIO_E)\r\ntmp0 |= (2 << 6) >> (2 * i);\r\nelse\r\ntmp0 |= (1 << 6) >> (2 * i);\r\nif (gpio[i] & CXD2820R_GPIO_I)\r\ntmp1 |= (1 << (3 + i));\r\nelse\r\ntmp1 |= (0 << (3 + i));\r\nif (gpio[i] & CXD2820R_GPIO_H)\r\ntmp1 |= (1 << (0 + i));\r\nelse\r\ntmp1 |= (0 << (0 + i));\r\ndbg("%s: GPIO i=%d %02x %02x", __func__, i, tmp0, tmp1);\r\n}\r\ndbg("%s: wr gpio=%02x %02x", __func__, tmp0, tmp1);\r\nret = cxd2820r_wr_reg_mask(priv, 0x00089, tmp0, 0xfc);\r\nif (ret)\r\ngoto error;\r\nret = cxd2820r_wr_reg_mask(priv, 0x0008e, tmp1, 0x3f);\r\nif (ret)\r\ngoto error;\r\nmemcpy(priv->gpio, gpio, sizeof(priv->gpio));\r\nreturn ret;\r\nerror:\r\ndbg("%s: failed:%d", __func__, ret);\r\nreturn ret;\r\n}\r\nu32 cxd2820r_div_u64_round_closest(u64 dividend, u32 divisor)\r\n{\r\nreturn div_u64(dividend + (divisor / 2), divisor);\r\n}\r\nstatic int cxd2820r_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_init_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_init_t(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_t2(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_init_c(fe);\r\nif (ret < 0)\r\ngoto err;\r\nret = cxd2820r_set_frontend_c(fe);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ndefault:\r\ndbg("%s: error state=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_status_t(fe, status);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_status_t2(fe, status);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_status_c(fe, status);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nif (priv->delivery_system == SYS_UNDEFINED)\r\nreturn 0;\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_get_frontend_t(fe);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_get_frontend_t2(fe);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_get_frontend_c(fe);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_ber_t(fe, ber);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_ber_t2(fe, ber);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_ber_c(fe, ber);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_signal_strength_t(fe, strength);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_signal_strength_t2(fe, strength);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_signal_strength_c(fe, strength);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_snr_t(fe, snr);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_snr_t2(fe, snr);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_snr_c(fe, snr);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_read_ucblocks_t(fe, ucblocks);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_read_ucblocks_t2(fe, ucblocks);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_read_ucblocks_c(fe, ucblocks);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_init(struct dvb_frontend *fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cxd2820r_sleep(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_sleep_t(fe);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_sleep_t2(fe);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_sleep_c(fe);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cxd2820r_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\nint ret;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nswitch (fe->dtv_property_cache.delivery_system) {\r\ncase SYS_DVBT:\r\nret = cxd2820r_get_tune_settings_t(fe, s);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2820r_get_tune_settings_t2(fe, s);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2820r_get_tune_settings_c(fe, s);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic enum dvbfe_search cxd2820r_search(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nfe_status_t status = 0;\r\ndbg("%s: delsys=%d", __func__, fe->dtv_property_cache.delivery_system);\r\nif (priv->last_tune_failed) {\r\nif (priv->delivery_system == SYS_DVBT) {\r\nret = cxd2820r_sleep_t(fe);\r\nif (ret)\r\ngoto error;\r\nc->delivery_system = SYS_DVBT2;\r\n} else if (priv->delivery_system == SYS_DVBT2) {\r\nret = cxd2820r_sleep_t2(fe);\r\nif (ret)\r\ngoto error;\r\nc->delivery_system = SYS_DVBT;\r\n}\r\n}\r\nret = cxd2820r_set_frontend(fe);\r\nif (ret)\r\ngoto error;\r\nswitch (priv->delivery_system) {\r\ncase SYS_DVBT:\r\ncase SYS_DVBC_ANNEX_A:\r\ni = 20;\r\nbreak;\r\ncase SYS_DVBT2:\r\ni = 40;\r\nbreak;\r\ncase SYS_UNDEFINED:\r\ndefault:\r\ni = 0;\r\nbreak;\r\n}\r\nfor (; i > 0; i--) {\r\ndbg("%s: LOOP=%d", __func__, i);\r\nmsleep(50);\r\nret = cxd2820r_read_status(fe, &status);\r\nif (ret)\r\ngoto error;\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\n}\r\nif (status & FE_HAS_LOCK) {\r\npriv->last_tune_failed = 0;\r\nreturn DVBFE_ALGO_SEARCH_SUCCESS;\r\n} else {\r\npriv->last_tune_failed = 1;\r\nreturn DVBFE_ALGO_SEARCH_AGAIN;\r\n}\r\nerror:\r\ndbg("%s: failed:%d", __func__, ret);\r\nreturn DVBFE_ALGO_SEARCH_ERROR;\r\n}\r\nstatic int cxd2820r_get_frontend_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_CUSTOM;\r\n}\r\nstatic void cxd2820r_release(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\ndbg("%s", __func__);\r\nkfree(priv);\r\nreturn;\r\n}\r\nstatic int cxd2820r_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\ndbg("%s: %d", __func__, enable);\r\nreturn cxd2820r_wr_reg_mask(priv, 0xdb, enable ? 1 : 0, 0x1);\r\n}\r\nstruct dvb_frontend *cxd2820r_attach(const struct cxd2820r_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct cxd2820r_priv *priv = NULL;\r\nint ret;\r\nu8 tmp;\r\npriv = kzalloc(sizeof (struct cxd2820r_priv), GFP_KERNEL);\r\nif (!priv)\r\ngoto error;\r\npriv->i2c = i2c;\r\nmemcpy(&priv->cfg, cfg, sizeof (struct cxd2820r_config));\r\npriv->bank[0] = priv->bank[1] = 0xff;\r\nret = cxd2820r_rd_reg(priv, 0x000fd, &tmp);\r\ndbg("%s: chip id=%02x", __func__, tmp);\r\nif (ret || tmp != 0xe1)\r\ngoto error;\r\nmemcpy(&priv->fe.ops, &cxd2820r_ops, sizeof (struct dvb_frontend_ops));\r\npriv->fe.demodulator_priv = priv;\r\nreturn &priv->fe;\r\nerror:\r\nkfree(priv);\r\nreturn NULL;\r\n}
