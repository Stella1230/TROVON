static inline int\r\nwaitforHIA(struct IsdnCardState *cs, int timeout)\r\n{\r\nwhile ((cs->BC_Read_Reg(cs, 0, ISAR_HIA) & 1) && timeout) {\r\nudelay(1);\r\ntimeout--;\r\n}\r\nif (!timeout)\r\nprintk(KERN_WARNING "HiSax: ISAR waitforHIA timeout\n");\r\nreturn (timeout);\r\n}\r\nstatic int\r\nsendmsg(struct IsdnCardState *cs, u_char his, u_char creg, u_char len,\r\nu_char *msg)\r\n{\r\nint i;\r\nif (!waitforHIA(cs, 4000))\r\nreturn (0);\r\n#if DUMP_MBOXFRAME\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "sendmsg(%02x,%02x,%d)", his, creg, len);\r\n#endif\r\ncs->BC_Write_Reg(cs, 0, ISAR_CTRL_H, creg);\r\ncs->BC_Write_Reg(cs, 0, ISAR_CTRL_L, len);\r\ncs->BC_Write_Reg(cs, 0, ISAR_WADR, 0);\r\nif (msg && len) {\r\ncs->BC_Write_Reg(cs, 1, ISAR_MBOX, msg[0]);\r\nfor (i = 1; i < len; i++)\r\ncs->BC_Write_Reg(cs, 2, ISAR_MBOX, msg[i]);\r\n#if DUMP_MBOXFRAME > 1\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar tmp[256], *t;\r\ni = len;\r\nwhile (i > 0) {\r\nt = tmp;\r\nt += sprintf(t, "sendmbox cnt %d", len);\r\nQuickHex(t, &msg[len-i], (i > 64) ? 64 : i);\r\ndebugl1(cs, tmp);\r\ni -= 64;\r\n}\r\n}\r\n#endif\r\n}\r\ncs->BC_Write_Reg(cs, 1, ISAR_HIS, his);\r\nwaitforHIA(cs, 10000);\r\nreturn (1);\r\n}\r\nstatic inline void\r\nrcv_mbox(struct IsdnCardState *cs, struct isar_reg *ireg, u_char *msg)\r\n{\r\nint i;\r\ncs->BC_Write_Reg(cs, 1, ISAR_RADR, 0);\r\nif (msg && ireg->clsb) {\r\nmsg[0] = cs->BC_Read_Reg(cs, 1, ISAR_MBOX);\r\nfor (i = 1; i < ireg->clsb; i++)\r\nmsg[i] = cs->BC_Read_Reg(cs, 2, ISAR_MBOX);\r\n#if DUMP_MBOXFRAME > 1\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar tmp[256], *t;\r\ni = ireg->clsb;\r\nwhile (i > 0) {\r\nt = tmp;\r\nt += sprintf(t, "rcv_mbox cnt %d", ireg->clsb);\r\nQuickHex(t, &msg[ireg->clsb - i], (i > 64) ? 64 : i);\r\ndebugl1(cs, tmp);\r\ni -= 64;\r\n}\r\n}\r\n#endif\r\n}\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\n}\r\nstatic inline void\r\nget_irq_infos(struct IsdnCardState *cs, struct isar_reg *ireg)\r\n{\r\nireg->iis = cs->BC_Read_Reg(cs, 1, ISAR_IIS);\r\nireg->cmsb = cs->BC_Read_Reg(cs, 1, ISAR_CTRL_H);\r\nireg->clsb = cs->BC_Read_Reg(cs, 1, ISAR_CTRL_L);\r\n#if DUMP_MBOXFRAME\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "irq_stat(%02x,%02x,%d)", ireg->iis, ireg->cmsb,\r\nireg->clsb);\r\n#endif\r\n}\r\nstatic int\r\nwaitrecmsg(struct IsdnCardState *cs, u_char *len,\r\nu_char *msg, int maxdelay)\r\n{\r\nint timeout = 0;\r\nstruct isar_reg *ir = cs->bcs[0].hw.isar.reg;\r\nwhile ((!(cs->BC_Read_Reg(cs, 0, ISAR_IRQBIT) & ISAR_IRQSTA)) &&\r\n(timeout++ < maxdelay))\r\nudelay(1);\r\nif (timeout > maxdelay) {\r\nprintk(KERN_WARNING"isar recmsg IRQSTA timeout\n");\r\nreturn (0);\r\n}\r\nget_irq_infos(cs, ir);\r\nrcv_mbox(cs, ir, msg);\r\n*len = ir->clsb;\r\nreturn (1);\r\n}\r\nint\r\nISARVersion(struct IsdnCardState *cs, char *s)\r\n{\r\nint ver;\r\nu_char msg[] = ISAR_MSG_HWVER;\r\nu_char tmp[64];\r\nu_char len;\r\nu_long flags;\r\nint debug;\r\ncs->cardmsg(cs, CARD_RESET, NULL);\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->BC_Write_Reg(cs, 0, ISAR_IRQBIT, 0);\r\ndebug = cs->debug;\r\ncs->debug &= ~(L1_DEB_HSCX | L1_DEB_HSCX_FIFO);\r\nif (!sendmsg(cs, ISAR_HIS_VNR, 0, 3, msg)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (-1);\r\n}\r\nif (!waitrecmsg(cs, &len, tmp, 100000)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (-2);\r\n}\r\ncs->debug = debug;\r\nif (cs->bcs[0].hw.isar.reg->iis == ISAR_IIS_VNR) {\r\nif (len == 1) {\r\nver = tmp[0] & 0xf;\r\nprintk(KERN_INFO "%s ISAR version %d\n", s, ver);\r\n} else\r\nver = -3;\r\n} else\r\nver = -4;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (ver);\r\n}\r\nstatic int\r\nisar_load_firmware(struct IsdnCardState *cs, u_char __user *buf)\r\n{\r\nint cfu_ret, ret, size, cnt, debug;\r\nu_char len, nom, noc;\r\nu_short sadr, left, *sp;\r\nu_char __user *p = buf;\r\nu_char *msg, *tmpmsg, *mp, tmp[64];\r\nu_long flags;\r\nstruct isar_reg *ireg = cs->bcs[0].hw.isar.reg;\r\nstruct {u_short sadr;\r\nu_short len;\r\nu_short d_key;\r\n} blk_head;\r\n#define BLK_HEAD_SIZE 6\r\nif (1 != (ret = ISARVersion(cs, "Testing"))) {\r\nprintk(KERN_ERR"isar_load_firmware wrong isar version %d\n", ret);\r\nreturn (1);\r\n}\r\ndebug = cs->debug;\r\n#if DBG_LOADFIRM < 2\r\ncs->debug &= ~(L1_DEB_HSCX | L1_DEB_HSCX_FIFO);\r\n#endif\r\ncfu_ret = copy_from_user(&size, p, sizeof(int));\r\nif (cfu_ret) {\r\nprintk(KERN_ERR "isar_load_firmware copy_from_user ret %d\n", cfu_ret);\r\nreturn -EFAULT;\r\n}\r\np += sizeof(int);\r\nprintk(KERN_DEBUG"isar_load_firmware size: %d\n", size);\r\ncnt = 0;\r\ncs->BC_Write_Reg(cs, 0, ISAR_IRQBIT, 0);\r\nif (!(msg = kmalloc(256, GFP_KERNEL))) {\r\nprintk(KERN_ERR"isar_load_firmware no buffer\n");\r\nreturn (1);\r\n}\r\nif (!(tmpmsg = kmalloc(256, GFP_KERNEL))) {\r\nprintk(KERN_ERR"isar_load_firmware no tmp buffer\n");\r\nkfree(msg);\r\nreturn (1);\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->BC_Write_Reg(cs, 0, ISAR_IRQBIT, 0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nwhile (cnt < size) {\r\nif ((ret = copy_from_user(&blk_head, p, BLK_HEAD_SIZE))) {\r\nprintk(KERN_ERR"isar_load_firmware copy_from_user ret %d\n", ret);\r\ngoto reterror;\r\n}\r\n#ifdef __BIG_ENDIAN\r\nsadr = (blk_head.sadr & 0xff) * 256 + blk_head.sadr / 256;\r\nblk_head.sadr = sadr;\r\nsadr = (blk_head.len & 0xff) * 256 + blk_head.len / 256;\r\nblk_head.len = sadr;\r\nsadr = (blk_head.d_key & 0xff) * 256 + blk_head.d_key / 256;\r\nblk_head.d_key = sadr;\r\n#endif\r\ncnt += BLK_HEAD_SIZE;\r\np += BLK_HEAD_SIZE;\r\nprintk(KERN_DEBUG"isar firmware block (%#x,%5d,%#x)\n",\r\nblk_head.sadr, blk_head.len, blk_head.d_key & 0xff);\r\nsadr = blk_head.sadr;\r\nleft = blk_head.len;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (!sendmsg(cs, ISAR_HIS_DKEY, blk_head.d_key & 0xff, 0, NULL)) {\r\nprintk(KERN_ERR"isar sendmsg dkey failed\n");\r\nret = 1; goto reterr_unlock;\r\n}\r\nif (!waitrecmsg(cs, &len, tmp, 100000)) {\r\nprintk(KERN_ERR"isar waitrecmsg dkey failed\n");\r\nret = 1; goto reterr_unlock;\r\n}\r\nif ((ireg->iis != ISAR_IIS_DKEY) || ireg->cmsb || len) {\r\nprintk(KERN_ERR"isar wrong dkey response (%x,%x,%x)\n",\r\nireg->iis, ireg->cmsb, len);\r\nret = 1; goto reterr_unlock;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nwhile (left > 0) {\r\nif (left > 126)\r\nnoc = 126;\r\nelse\r\nnoc = left;\r\nnom = 2 * noc;\r\nmp = msg;\r\n*mp++ = sadr / 256;\r\n*mp++ = sadr % 256;\r\nleft -= noc;\r\n*mp++ = noc;\r\nif ((ret = copy_from_user(tmpmsg, p, nom))) {\r\nprintk(KERN_ERR"isar_load_firmware copy_from_user ret %d\n", ret);\r\ngoto reterror;\r\n}\r\np += nom;\r\ncnt += nom;\r\nnom += 3;\r\nsp = (u_short *)tmpmsg;\r\n#if DBG_LOADFIRM\r\nprintk(KERN_DEBUG"isar: load %3d words at %04x left %d\n",\r\nnoc, sadr, left);\r\n#endif\r\nsadr += noc;\r\nwhile (noc) {\r\n#ifdef __BIG_ENDIAN\r\n*mp++ = *sp % 256;\r\n*mp++ = *sp / 256;\r\n#else\r\n*mp++ = *sp / 256;\r\n*mp++ = *sp % 256;\r\n#endif\r\nsp++;\r\nnoc--;\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (!sendmsg(cs, ISAR_HIS_FIRM, 0, nom, msg)) {\r\nprintk(KERN_ERR"isar sendmsg prog failed\n");\r\nret = 1; goto reterr_unlock;\r\n}\r\nif (!waitrecmsg(cs, &len, tmp, 100000)) {\r\nprintk(KERN_ERR"isar waitrecmsg prog failed\n");\r\nret = 1; goto reterr_unlock;\r\n}\r\nif ((ireg->iis != ISAR_IIS_FIRM) || ireg->cmsb || len) {\r\nprintk(KERN_ERR"isar wrong prog response (%x,%x,%x)\n",\r\nireg->iis, ireg->cmsb, len);\r\nret = 1; goto reterr_unlock;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\n}\r\nprintk(KERN_DEBUG"isar firmware block %5d words loaded\n",\r\nblk_head.len);\r\n}\r\ncnt = 10;\r\nwhile (cnt--)\r\nudelay(1000);\r\nmsg[0] = 0xff;\r\nmsg[1] = 0xfe;\r\nireg->bstat = 0;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (!sendmsg(cs, ISAR_HIS_STDSP, 0, 2, msg)) {\r\nprintk(KERN_ERR"isar sendmsg start dsp failed\n");\r\nret = 1; goto reterr_unlock;\r\n}\r\nif (!waitrecmsg(cs, &len, tmp, 100000)) {\r\nprintk(KERN_ERR"isar waitrecmsg start dsp failed\n");\r\nret = 1; goto reterr_unlock;\r\n}\r\nif ((ireg->iis != ISAR_IIS_STDSP) || ireg->cmsb || len) {\r\nprintk(KERN_ERR"isar wrong start dsp response (%x,%x,%x)\n",\r\nireg->iis, ireg->cmsb, len);\r\nret = 1; goto reterr_unlock;\r\n} else\r\nprintk(KERN_DEBUG"isar start dsp success\n");\r\ncs->BC_Write_Reg(cs, 0, ISAR_IRQBIT, ISAR_IRQSTA);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ncnt = 1000;\r\nwhile ((!ireg->bstat) && cnt) {\r\nudelay(1000);\r\ncnt--;\r\n}\r\nif (!cnt) {\r\nprintk(KERN_ERR"isar no general status event received\n");\r\nret = 1; goto reterror;\r\n} else {\r\nprintk(KERN_DEBUG"isar general status event %x\n",\r\nireg->bstat);\r\n}\r\ncnt = 10;\r\nwhile (cnt--)\r\nudelay(1000);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nireg->iis = 0;\r\nif (!sendmsg(cs, ISAR_HIS_DIAG, ISAR_CTRL_STST, 0, NULL)) {\r\nprintk(KERN_ERR"isar sendmsg self tst failed\n");\r\nret = 1; goto reterr_unlock;\r\n}\r\ncnt = 10000;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nwhile ((ireg->iis != ISAR_IIS_DIAG) && cnt) {\r\nudelay(10);\r\ncnt--;\r\n}\r\nudelay(1000);\r\nif (!cnt) {\r\nprintk(KERN_ERR"isar no self tst response\n");\r\nret = 1; goto reterror;\r\n}\r\nif ((ireg->cmsb == ISAR_CTRL_STST) && (ireg->clsb == 1)\r\n&& (ireg->par[0] == 0)) {\r\nprintk(KERN_DEBUG"isar selftest OK\n");\r\n} else {\r\nprintk(KERN_DEBUG"isar selftest not OK %x/%x/%x\n",\r\nireg->cmsb, ireg->clsb, ireg->par[0]);\r\nret = 1; goto reterror;\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\nireg->iis = 0;\r\nif (!sendmsg(cs, ISAR_HIS_DIAG, ISAR_CTRL_SWVER, 0, NULL)) {\r\nprintk(KERN_ERR"isar RQST SVN failed\n");\r\nret = 1; goto reterr_unlock;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ncnt = 30000;\r\nwhile ((ireg->iis != ISAR_IIS_DIAG) && cnt) {\r\nudelay(10);\r\ncnt--;\r\n}\r\nudelay(1000);\r\nif (!cnt) {\r\nprintk(KERN_ERR"isar no SVN response\n");\r\nret = 1; goto reterror;\r\n} else {\r\nif ((ireg->cmsb == ISAR_CTRL_SWVER) && (ireg->clsb == 1))\r\nprintk(KERN_DEBUG"isar software version %#x\n",\r\nireg->par[0]);\r\nelse {\r\nprintk(KERN_ERR"isar wrong swver response (%x,%x) cnt(%d)\n",\r\nireg->cmsb, ireg->clsb, cnt);\r\nret = 1; goto reterror;\r\n}\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->debug = debug;\r\nisar_setup(cs);\r\nret = 0;\r\nreterr_unlock:\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreterror:\r\ncs->debug = debug;\r\nif (ret)\r\ncs->BC_Write_Reg(cs, 0, ISAR_IRQBIT, 0);\r\nkfree(msg);\r\nkfree(tmpmsg);\r\nreturn (ret);\r\n}\r\nstatic void\r\nisar_bh(struct work_struct *work)\r\n{\r\nstruct BCState *bcs = container_of(work, struct BCState, tqueue);\r\nBChannel_bh(work);\r\nif (test_and_clear_bit(B_LL_NOCARRIER, &bcs->event))\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_NOCARR);\r\nif (test_and_clear_bit(B_LL_CONNECT, &bcs->event))\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_CONNECT);\r\nif (test_and_clear_bit(B_LL_OK, &bcs->event))\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_OK);\r\n}\r\nstatic void\r\nsend_DLE_ETX(struct BCState *bcs)\r\n{\r\nu_char dleetx[2] = {DLE, ETX};\r\nstruct sk_buff *skb;\r\nif ((skb = dev_alloc_skb(2))) {\r\nmemcpy(skb_put(skb, 2), dleetx, 2);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n} else {\r\nprintk(KERN_WARNING "HiSax: skb out of memory\n");\r\n}\r\n}\r\nstatic inline int\r\ndle_count(unsigned char *buf, int len)\r\n{\r\nint count = 0;\r\nwhile (len--)\r\nif (*buf++ == DLE)\r\ncount++;\r\nreturn count;\r\n}\r\nstatic inline void\r\ninsert_dle(unsigned char *dest, unsigned char *src, int count) {\r\nwhile (count--) {\r\n*dest++ = *src;\r\nif (*src++ == DLE)\r\n*dest++ = DLE;\r\n}\r\n}\r\nstatic void\r\nisar_rcv_frame(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nu_char *ptr;\r\nstruct sk_buff *skb;\r\nstruct isar_reg *ireg = bcs->hw.isar.reg;\r\nif (!ireg->clsb) {\r\ndebugl1(cs, "isar zero len frame");\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nreturn;\r\n}\r\nswitch (bcs->mode) {\r\ncase L1_MODE_NULL:\r\ndebugl1(cs, "isar mode 0 spurious IIS_RDATA %x/%x/%x",\r\nireg->iis, ireg->cmsb, ireg->clsb);\r\nprintk(KERN_WARNING"isar mode 0 spurious IIS_RDATA %x/%x/%x\n",\r\nireg->iis, ireg->cmsb, ireg->clsb);\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nbreak;\r\ncase L1_MODE_TRANS:\r\ncase L1_MODE_V32:\r\nif ((skb = dev_alloc_skb(ireg->clsb))) {\r\nrcv_mbox(cs, ireg, (u_char *)skb_put(skb, ireg->clsb));\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n} else {\r\nprintk(KERN_WARNING "HiSax: skb out of memory\n");\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\n}\r\nbreak;\r\ncase L1_MODE_HDLC:\r\nif ((bcs->hw.isar.rcvidx + ireg->clsb) > HSCX_BUFMAX) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar_rcv_frame: incoming packet too large");\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nbcs->hw.isar.rcvidx = 0;\r\n} else if (ireg->cmsb & HDLC_ERROR) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar frame error %x len %d",\r\nireg->cmsb, ireg->clsb);\r\n#ifdef ERROR_STATISTIC\r\nif (ireg->cmsb & HDLC_ERR_RER)\r\nbcs->err_inv++;\r\nif (ireg->cmsb & HDLC_ERR_CER)\r\nbcs->err_crc++;\r\n#endif\r\nbcs->hw.isar.rcvidx = 0;\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\n} else {\r\nif (ireg->cmsb & HDLC_FSD)\r\nbcs->hw.isar.rcvidx = 0;\r\nptr = bcs->hw.isar.rcvbuf + bcs->hw.isar.rcvidx;\r\nbcs->hw.isar.rcvidx += ireg->clsb;\r\nrcv_mbox(cs, ireg, ptr);\r\nif (ireg->cmsb & HDLC_FED) {\r\nif (bcs->hw.isar.rcvidx < 3) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar frame to short %d",\r\nbcs->hw.isar.rcvidx);\r\n} else if (!(skb = dev_alloc_skb(bcs->hw.isar.rcvidx - 2))) {\r\nprintk(KERN_WARNING "ISAR: receive out of memory\n");\r\n} else {\r\nmemcpy(skb_put(skb, bcs->hw.isar.rcvidx - 2),\r\nbcs->hw.isar.rcvbuf, bcs->hw.isar.rcvidx - 2);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\nbcs->hw.isar.rcvidx = 0;\r\n}\r\n}\r\nbreak;\r\ncase L1_MODE_FAX:\r\nif (bcs->hw.isar.state != STFAX_ACTIV) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar_rcv_frame: not ACTIV");\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nbcs->hw.isar.rcvidx = 0;\r\nbreak;\r\n}\r\nif (bcs->hw.isar.cmd == PCTRL_CMD_FRM) {\r\nrcv_mbox(cs, ireg, bcs->hw.isar.rcvbuf);\r\nbcs->hw.isar.rcvidx = ireg->clsb +\r\ndle_count(bcs->hw.isar.rcvbuf, ireg->clsb);\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "isar_rcv_frame: raw(%d) dle(%d)",\r\nireg->clsb, bcs->hw.isar.rcvidx);\r\nif ((skb = dev_alloc_skb(bcs->hw.isar.rcvidx))) {\r\ninsert_dle((u_char *)skb_put(skb, bcs->hw.isar.rcvidx),\r\nbcs->hw.isar.rcvbuf, ireg->clsb);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nschedule_event(bcs, B_RCVBUFREADY);\r\nif (ireg->cmsb & SART_NMD) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar_rcv_frame: no more data");\r\nbcs->hw.isar.rcvidx = 0;\r\nsend_DLE_ETX(bcs);\r\nsendmsg(cs, SET_DPS(bcs->hw.isar.dpath) |\r\nISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC,\r\n0, NULL);\r\nbcs->hw.isar.state = STFAX_ESCAPE;\r\nschedule_event(bcs, B_LL_NOCARRIER);\r\n}\r\n} else {\r\nprintk(KERN_WARNING "HiSax: skb out of memory\n");\r\n}\r\nbreak;\r\n}\r\nif (bcs->hw.isar.cmd != PCTRL_CMD_FRH) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar_rcv_frame: unknown fax mode %x",\r\nbcs->hw.isar.cmd);\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nbcs->hw.isar.rcvidx = 0;\r\nbreak;\r\n}\r\nif ((bcs->hw.isar.rcvidx + ireg->clsb) > HSCX_BUFMAX) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar_rcv_frame: incoming packet too large");\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nbcs->hw.isar.rcvidx = 0;\r\n} else if (ireg->cmsb & HDLC_ERROR) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar frame error %x len %d",\r\nireg->cmsb, ireg->clsb);\r\nbcs->hw.isar.rcvidx = 0;\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\n} else {\r\nif (ireg->cmsb & HDLC_FSD) {\r\nbcs->hw.isar.rcvidx = 0;\r\n}\r\nptr = bcs->hw.isar.rcvbuf + bcs->hw.isar.rcvidx;\r\nbcs->hw.isar.rcvidx += ireg->clsb;\r\nrcv_mbox(cs, ireg, ptr);\r\nif (ireg->cmsb & HDLC_FED) {\r\nint len = bcs->hw.isar.rcvidx +\r\ndle_count(bcs->hw.isar.rcvbuf, bcs->hw.isar.rcvidx);\r\nif (bcs->hw.isar.rcvidx < 3) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar frame to short %d",\r\nbcs->hw.isar.rcvidx);\r\nprintk(KERN_WARNING "ISAR: frame to short %d\n",\r\nbcs->hw.isar.rcvidx);\r\n} else if (!(skb = dev_alloc_skb(len))) {\r\nprintk(KERN_WARNING "ISAR: receive out of memory\n");\r\n} else {\r\ninsert_dle((u_char *)skb_put(skb, len),\r\nbcs->hw.isar.rcvbuf,\r\nbcs->hw.isar.rcvidx);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nschedule_event(bcs, B_RCVBUFREADY);\r\nsend_DLE_ETX(bcs);\r\nschedule_event(bcs, B_LL_OK);\r\ntest_and_clear_bit(BC_FLG_FRH_WAIT, &bcs->Flag);\r\n}\r\nbcs->hw.isar.rcvidx = 0;\r\n}\r\n}\r\nif (ireg->cmsb & SART_NMD) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar_rcv_frame: no more data");\r\nbcs->hw.isar.rcvidx = 0;\r\nsendmsg(cs, SET_DPS(bcs->hw.isar.dpath) |\r\nISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC, 0, NULL);\r\nbcs->hw.isar.state = STFAX_ESCAPE;\r\nif (test_and_clear_bit(BC_FLG_FRH_WAIT, &bcs->Flag)) {\r\nsend_DLE_ETX(bcs);\r\nschedule_event(bcs, B_LL_NOCARRIER);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR"isar_rcv_frame mode (%x)error\n", bcs->mode);\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nbreak;\r\n}\r\n}\r\nvoid\r\nisar_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint count;\r\nu_char msb;\r\nu_char *ptr;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "isar_fill_fifo");\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\nif (!(bcs->hw.isar.reg->bstat &\r\n(bcs->hw.isar.dpath == 1 ? BSTAT_RDM1 : BSTAT_RDM2)))\r\nreturn;\r\nif (bcs->tx_skb->len > bcs->hw.isar.mml) {\r\nmsb = 0;\r\ncount = bcs->hw.isar.mml;\r\n} else {\r\ncount = bcs->tx_skb->len;\r\nmsb = HDLC_FED;\r\n}\r\nptr = bcs->tx_skb->data;\r\nif (!bcs->hw.isar.txcnt) {\r\nmsb |= HDLC_FST;\r\nif ((bcs->mode == L1_MODE_FAX) &&\r\n(bcs->hw.isar.cmd == PCTRL_CMD_FTH)) {\r\nif (bcs->tx_skb->len > 1) {\r\nif ((ptr[0] == 0xff) && (ptr[1] == 0x13))\r\ntest_and_set_bit(BC_FLG_LASTDATA,\r\n&bcs->Flag);\r\n}\r\n}\r\n}\r\nskb_pull(bcs->tx_skb, count);\r\nbcs->tx_cnt -= count;\r\nbcs->hw.isar.txcnt += count;\r\nswitch (bcs->mode) {\r\ncase L1_MODE_NULL:\r\nprintk(KERN_ERR"isar_fill_fifo wrong mode 0\n");\r\nbreak;\r\ncase L1_MODE_TRANS:\r\ncase L1_MODE_V32:\r\nsendmsg(cs, SET_DPS(bcs->hw.isar.dpath) | ISAR_HIS_SDATA,\r\n0, count, ptr);\r\nbreak;\r\ncase L1_MODE_HDLC:\r\nsendmsg(cs, SET_DPS(bcs->hw.isar.dpath) | ISAR_HIS_SDATA,\r\nmsb, count, ptr);\r\nbreak;\r\ncase L1_MODE_FAX:\r\nif (bcs->hw.isar.state != STFAX_ACTIV) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar_fill_fifo: not ACTIV");\r\n} else if (bcs->hw.isar.cmd == PCTRL_CMD_FTH) {\r\nsendmsg(cs, SET_DPS(bcs->hw.isar.dpath) | ISAR_HIS_SDATA,\r\nmsb, count, ptr);\r\n} else if (bcs->hw.isar.cmd == PCTRL_CMD_FTM) {\r\nsendmsg(cs, SET_DPS(bcs->hw.isar.dpath) | ISAR_HIS_SDATA,\r\n0, count, ptr);\r\n} else {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar_fill_fifo: not FTH/FTM");\r\n}\r\nbreak;\r\ndefault:\r\nif (cs->debug)\r\ndebugl1(cs, "isar_fill_fifo mode(%x) error", bcs->mode);\r\nprintk(KERN_ERR"isar_fill_fifo mode(%x) error\n", bcs->mode);\r\nbreak;\r\n}\r\n}\r\nstatic inline\r\nstruct BCState *sel_bcs_isar(struct IsdnCardState *cs, u_char dpath)\r\n{\r\nif ((!dpath) || (dpath == 3))\r\nreturn (NULL);\r\nif (cs->bcs[0].hw.isar.dpath == dpath)\r\nreturn (&cs->bcs[0]);\r\nif (cs->bcs[1].hw.isar.dpath == dpath)\r\nreturn (&cs->bcs[1]);\r\nreturn (NULL);\r\n}\r\nstatic void\r\nsend_frames(struct BCState *bcs)\r\n{\r\nif (bcs->tx_skb) {\r\nif (bcs->tx_skb->len) {\r\nisar_fill_fifo(bcs);\r\nreturn;\r\n} else {\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->hw.isar.txcnt;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\nif (bcs->mode == L1_MODE_FAX) {\r\nif (bcs->hw.isar.cmd == PCTRL_CMD_FTH) {\r\nif (test_bit(BC_FLG_LASTDATA, &bcs->Flag)) {\r\ntest_and_set_bit(BC_FLG_NMD_DATA, &bcs->Flag);\r\n}\r\n} else if (bcs->hw.isar.cmd == PCTRL_CMD_FTM) {\r\nif (test_bit(BC_FLG_DLEETX, &bcs->Flag)) {\r\ntest_and_set_bit(BC_FLG_LASTDATA, &bcs->Flag);\r\ntest_and_set_bit(BC_FLG_NMD_DATA, &bcs->Flag);\r\n}\r\n}\r\n}\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->hw.isar.txcnt = 0;\r\nbcs->tx_skb = NULL;\r\n}\r\n}\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nbcs->hw.isar.txcnt = 0;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nisar_fill_fifo(bcs);\r\n} else {\r\nif (test_and_clear_bit(BC_FLG_DLEETX, &bcs->Flag)) {\r\nif (test_and_clear_bit(BC_FLG_LASTDATA, &bcs->Flag)) {\r\nif (test_and_clear_bit(BC_FLG_NMD_DATA, &bcs->Flag)) {\r\nu_char dummy = 0;\r\nsendmsg(bcs->cs, SET_DPS(bcs->hw.isar.dpath) |\r\nISAR_HIS_SDATA, 0x01, 1, &dummy);\r\n}\r\ntest_and_set_bit(BC_FLG_LL_OK, &bcs->Flag);\r\n} else {\r\nschedule_event(bcs, B_LL_CONNECT);\r\n}\r\n}\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\nstatic inline void\r\ncheck_send(struct IsdnCardState *cs, u_char rdm)\r\n{\r\nstruct BCState *bcs;\r\nif (rdm & BSTAT_RDM1) {\r\nif ((bcs = sel_bcs_isar(cs, 1))) {\r\nif (bcs->mode) {\r\nsend_frames(bcs);\r\n}\r\n}\r\n}\r\nif (rdm & BSTAT_RDM2) {\r\nif ((bcs = sel_bcs_isar(cs, 2))) {\r\nif (bcs->mode) {\r\nsend_frames(bcs);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nisar_pump_status_rsp(struct BCState *bcs, struct isar_reg *ireg) {\r\nstruct IsdnCardState *cs = bcs->cs;\r\nu_char ril = ireg->par[0];\r\nu_char rim;\r\nif (!test_and_clear_bit(ISAR_RATE_REQ, &bcs->hw.isar.reg->Flags))\r\nreturn;\r\nif (ril > 14) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "wrong pstrsp ril=%d", ril);\r\nril = 15;\r\n}\r\nswitch (ireg->par[1]) {\r\ncase 0:\r\nrim = 0;\r\nbreak;\r\ncase 0x20:\r\nrim = 2;\r\nbreak;\r\ncase 0x40:\r\nrim = 3;\r\nbreak;\r\ncase 0x41:\r\nrim = 4;\r\nbreak;\r\ncase 0x51:\r\nrim = 5;\r\nbreak;\r\ncase 0x61:\r\nrim = 6;\r\nbreak;\r\ncase 0x71:\r\nrim = 7;\r\nbreak;\r\ncase 0x82:\r\nrim = 8;\r\nbreak;\r\ncase 0x92:\r\nrim = 9;\r\nbreak;\r\ncase 0xa2:\r\nrim = 10;\r\nbreak;\r\ndefault:\r\nrim = 1;\r\nbreak;\r\n}\r\nsprintf(bcs->hw.isar.conmsg, "%s %s", dmril[ril], dmrim[rim]);\r\nbcs->conmsg = bcs->hw.isar.conmsg;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump strsp %s", bcs->conmsg);\r\n}\r\nstatic void\r\nisar_pump_statev_modem(struct BCState *bcs, u_char devt) {\r\nstruct IsdnCardState *cs = bcs->cs;\r\nu_char dps = SET_DPS(bcs->hw.isar.dpath);\r\nswitch (devt) {\r\ncase PSEV_10MS_TIMER:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev TIMER");\r\nbreak;\r\ncase PSEV_CON_ON:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev CONNECT");\r\nl1_msg_b(bcs->st, PH_ACTIVATE | REQUEST, NULL);\r\nbreak;\r\ncase PSEV_CON_OFF:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev NO CONNECT");\r\nsendmsg(cs, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\r\nl1_msg_b(bcs->st, PH_DEACTIVATE | REQUEST, NULL);\r\nbreak;\r\ncase PSEV_V24_OFF:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev V24 OFF");\r\nbreak;\r\ncase PSEV_CTS_ON:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev CTS ON");\r\nbreak;\r\ncase PSEV_CTS_OFF:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev CTS OFF");\r\nbreak;\r\ncase PSEV_DCD_ON:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev CARRIER ON");\r\ntest_and_set_bit(ISAR_RATE_REQ, &bcs->hw.isar.reg->Flags);\r\nsendmsg(cs, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\r\nbreak;\r\ncase PSEV_DCD_OFF:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev CARRIER OFF");\r\nbreak;\r\ncase PSEV_DSR_ON:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev DSR ON");\r\nbreak;\r\ncase PSEV_DSR_OFF:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev DSR_OFF");\r\nbreak;\r\ncase PSEV_REM_RET:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev REMOTE RETRAIN");\r\nbreak;\r\ncase PSEV_REM_REN:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev REMOTE RENEGOTIATE");\r\nbreak;\r\ncase PSEV_GSTN_CLR:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev GSTN CLEAR");\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "unknown pump stev %x", devt);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nll_deliver_faxstat(struct BCState *bcs, u_char status)\r\n{\r\nisdn_ctrl ic;\r\nstruct Channel *chanp = (struct Channel *) bcs->st->lli.userdata;\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "HL->LL FAXIND %x", status);\r\nic.driver = bcs->cs->myid;\r\nic.command = ISDN_STAT_FAXIND;\r\nic.arg = chanp->chan;\r\nic.parm.aux.cmd = status;\r\nbcs->cs->iif.statcallb(&ic);\r\n}\r\nstatic void\r\nisar_pump_statev_fax(struct BCState *bcs, u_char devt) {\r\nstruct IsdnCardState *cs = bcs->cs;\r\nu_char dps = SET_DPS(bcs->hw.isar.dpath);\r\nu_char p1;\r\nswitch (devt) {\r\ncase PSEV_10MS_TIMER:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev TIMER");\r\nbreak;\r\ncase PSEV_RSP_READY:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev RSP_READY");\r\nbcs->hw.isar.state = STFAX_READY;\r\nl1_msg_b(bcs->st, PH_ACTIVATE | REQUEST, NULL);\r\nif (test_bit(BC_FLG_ORIG, &bcs->Flag)) {\r\nisar_pump_cmd(bcs, ISDN_FAX_CLASS1_FRH, 3);\r\n} else {\r\nisar_pump_cmd(bcs, ISDN_FAX_CLASS1_FTH, 3);\r\n}\r\nbreak;\r\ncase PSEV_LINE_TX_H:\r\nif (bcs->hw.isar.state == STFAX_LINE) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev LINE_TX_H");\r\nbcs->hw.isar.state = STFAX_CONT;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL, PCTRL_CMD_CONT, 0, NULL);\r\n} else {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "pump stev LINE_TX_H wrong st %x",\r\nbcs->hw.isar.state);\r\n}\r\nbreak;\r\ncase PSEV_LINE_RX_H:\r\nif (bcs->hw.isar.state == STFAX_LINE) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev LINE_RX_H");\r\nbcs->hw.isar.state = STFAX_CONT;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL, PCTRL_CMD_CONT, 0, NULL);\r\n} else {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "pump stev LINE_RX_H wrong st %x",\r\nbcs->hw.isar.state);\r\n}\r\nbreak;\r\ncase PSEV_LINE_TX_B:\r\nif (bcs->hw.isar.state == STFAX_LINE) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev LINE_TX_B");\r\nbcs->hw.isar.state = STFAX_CONT;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL, PCTRL_CMD_CONT, 0, NULL);\r\n} else {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "pump stev LINE_TX_B wrong st %x",\r\nbcs->hw.isar.state);\r\n}\r\nbreak;\r\ncase PSEV_LINE_RX_B:\r\nif (bcs->hw.isar.state == STFAX_LINE) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev LINE_RX_B");\r\nbcs->hw.isar.state = STFAX_CONT;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL, PCTRL_CMD_CONT, 0, NULL);\r\n} else {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "pump stev LINE_RX_B wrong st %x",\r\nbcs->hw.isar.state);\r\n}\r\nbreak;\r\ncase PSEV_RSP_CONN:\r\nif (bcs->hw.isar.state == STFAX_CONT) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev RSP_CONN");\r\nbcs->hw.isar.state = STFAX_ACTIV;\r\ntest_and_set_bit(ISAR_RATE_REQ, &bcs->hw.isar.reg->Flags);\r\nsendmsg(cs, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\r\nif (bcs->hw.isar.cmd == PCTRL_CMD_FTH) {\r\nif (test_and_set_bit(BC_FLG_FTI_RUN, &bcs->Flag))\r\ndel_timer(&bcs->hw.isar.ftimer);\r\nbcs->hw.isar.ftimer.expires =\r\njiffies + ((1000 * HZ) / 1000);\r\ntest_and_set_bit(BC_FLG_LL_CONN,\r\n&bcs->Flag);\r\nadd_timer(&bcs->hw.isar.ftimer);\r\n} else {\r\nschedule_event(bcs, B_LL_CONNECT);\r\n}\r\n} else {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "pump stev RSP_CONN wrong st %x",\r\nbcs->hw.isar.state);\r\n}\r\nbreak;\r\ncase PSEV_FLAGS_DET:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev FLAGS_DET");\r\nbreak;\r\ncase PSEV_RSP_DISC:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev RSP_DISC");\r\nif (bcs->hw.isar.state == STFAX_ESCAPE) {\r\np1 = 5;\r\nswitch (bcs->hw.isar.newcmd) {\r\ncase 0:\r\nbcs->hw.isar.state = STFAX_READY;\r\nbreak;\r\ncase PCTRL_CMD_FTM:\r\np1 = 2;\r\ncase PCTRL_CMD_FTH:\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL,\r\nPCTRL_CMD_SILON, 1, &p1);\r\nbcs->hw.isar.state = STFAX_SILDET;\r\nbreak;\r\ncase PCTRL_CMD_FRM:\r\nif (frm_extra_delay)\r\nmdelay(frm_extra_delay);\r\ncase PCTRL_CMD_FRH:\r\np1 = bcs->hw.isar.mod = bcs->hw.isar.newmod;\r\nbcs->hw.isar.newmod = 0;\r\nbcs->hw.isar.cmd = bcs->hw.isar.newcmd;\r\nbcs->hw.isar.newcmd = 0;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL,\r\nbcs->hw.isar.cmd, 1, &p1);\r\nbcs->hw.isar.state = STFAX_LINE;\r\nbcs->hw.isar.try_mod = 3;\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "RSP_DISC unknown newcmd %x", bcs->hw.isar.newcmd);\r\nbreak;\r\n}\r\n} else if (bcs->hw.isar.state == STFAX_ACTIV) {\r\nif (test_and_clear_bit(BC_FLG_LL_OK, &bcs->Flag)) {\r\nschedule_event(bcs, B_LL_OK);\r\n} else if (bcs->hw.isar.cmd == PCTRL_CMD_FRM) {\r\nsend_DLE_ETX(bcs);\r\nschedule_event(bcs, B_LL_NOCARRIER);\r\n} else {\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_FCERROR);\r\n}\r\nbcs->hw.isar.state = STFAX_READY;\r\n} else {\r\nbcs->hw.isar.state = STFAX_READY;\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_FCERROR);\r\n}\r\nbreak;\r\ncase PSEV_RSP_SILDET:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev RSP_SILDET");\r\nif (bcs->hw.isar.state == STFAX_SILDET) {\r\np1 = bcs->hw.isar.mod = bcs->hw.isar.newmod;\r\nbcs->hw.isar.newmod = 0;\r\nbcs->hw.isar.cmd = bcs->hw.isar.newcmd;\r\nbcs->hw.isar.newcmd = 0;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL,\r\nbcs->hw.isar.cmd, 1, &p1);\r\nbcs->hw.isar.state = STFAX_LINE;\r\nbcs->hw.isar.try_mod = 3;\r\n}\r\nbreak;\r\ncase PSEV_RSP_SILOFF:\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev RSP_SILOFF");\r\nbreak;\r\ncase PSEV_RSP_FCERR:\r\nif (bcs->hw.isar.state == STFAX_LINE) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev RSP_FCERR try %d",\r\nbcs->hw.isar.try_mod);\r\nif (bcs->hw.isar.try_mod--) {\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL,\r\nbcs->hw.isar.cmd, 1,\r\n&bcs->hw.isar.mod);\r\nbreak;\r\n}\r\n}\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev RSP_FCERR");\r\nbcs->hw.isar.state = STFAX_ESCAPE;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL, PCTRL_CMD_ESC, 0, NULL);\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_FCERROR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid\r\nisar_int_main(struct IsdnCardState *cs)\r\n{\r\nstruct isar_reg *ireg = cs->bcs[0].hw.isar.reg;\r\nstruct BCState *bcs;\r\nget_irq_infos(cs, ireg);\r\nswitch (ireg->iis & ISAR_IIS_MSCMSD) {\r\ncase ISAR_IIS_RDATA:\r\nif ((bcs = sel_bcs_isar(cs, ireg->iis >> 6))) {\r\nisar_rcv_frame(cs, bcs);\r\n} else {\r\ndebugl1(cs, "isar spurious IIS_RDATA %x/%x/%x",\r\nireg->iis, ireg->cmsb, ireg->clsb);\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\n}\r\nbreak;\r\ncase ISAR_IIS_GSTEV:\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nireg->bstat |= ireg->cmsb;\r\ncheck_send(cs, ireg->cmsb);\r\nbreak;\r\ncase ISAR_IIS_BSTEV:\r\n#ifdef ERROR_STATISTIC\r\nif ((bcs = sel_bcs_isar(cs, ireg->iis >> 6))) {\r\nif (ireg->cmsb == BSTEV_TBO)\r\nbcs->err_tx++;\r\nif (ireg->cmsb == BSTEV_RBO)\r\nbcs->err_rdo++;\r\n}\r\n#endif\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "Buffer STEV dpath%d msb(%x)",\r\nireg->iis >> 6, ireg->cmsb);\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\nbreak;\r\ncase ISAR_IIS_PSTEV:\r\nif ((bcs = sel_bcs_isar(cs, ireg->iis >> 6))) {\r\nrcv_mbox(cs, ireg, (u_char *)ireg->par);\r\nif (bcs->mode == L1_MODE_V32) {\r\nisar_pump_statev_modem(bcs, ireg->cmsb);\r\n} else if (bcs->mode == L1_MODE_FAX) {\r\nisar_pump_statev_fax(bcs, ireg->cmsb);\r\n} else if (ireg->cmsb == PSEV_10MS_TIMER) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "pump stev TIMER");\r\n} else {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "isar IIS_PSTEV pmode %d stat %x",\r\nbcs->mode, ireg->cmsb);\r\n}\r\n} else {\r\ndebugl1(cs, "isar spurious IIS_PSTEV %x/%x/%x",\r\nireg->iis, ireg->cmsb, ireg->clsb);\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\n}\r\nbreak;\r\ncase ISAR_IIS_PSTRSP:\r\nif ((bcs = sel_bcs_isar(cs, ireg->iis >> 6))) {\r\nrcv_mbox(cs, ireg, (u_char *)ireg->par);\r\nisar_pump_status_rsp(bcs, ireg);\r\n} else {\r\ndebugl1(cs, "isar spurious IIS_PSTRSP %x/%x/%x",\r\nireg->iis, ireg->cmsb, ireg->clsb);\r\ncs->BC_Write_Reg(cs, 1, ISAR_IIA, 0);\r\n}\r\nbreak;\r\ncase ISAR_IIS_DIAG:\r\ncase ISAR_IIS_BSTRSP:\r\ncase ISAR_IIS_IOM2RSP:\r\nrcv_mbox(cs, ireg, (u_char *)ireg->par);\r\nif ((cs->debug & (L1_DEB_HSCX | L1_DEB_HSCX_FIFO))\r\n== L1_DEB_HSCX) {\r\nu_char *tp = debbuf;\r\ntp += sprintf(debbuf, "msg iis(%x) msb(%x)",\r\nireg->iis, ireg->cmsb);\r\nQuickHex(tp, (u_char *)ireg->par, ireg->clsb);\r\ndebugl1(cs, debbuf);\r\n}\r\nbreak;\r\ncase ISAR_IIS_INVMSG:\r\nrcv_mbox(cs, ireg, debbuf);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "invalid msg his:%x",\r\nireg->cmsb);\r\nbreak;\r\ndefault:\r\nrcv_mbox(cs, ireg, debbuf);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "unhandled msg iis(%x) ctrl(%x/%x)",\r\nireg->iis, ireg->cmsb, ireg->clsb);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nftimer_handler(struct BCState *bcs) {\r\nif (bcs->cs->debug)\r\ndebugl1(bcs->cs, "ftimer flags %04lx",\r\nbcs->Flag);\r\ntest_and_clear_bit(BC_FLG_FTI_RUN, &bcs->Flag);\r\nif (test_and_clear_bit(BC_FLG_LL_CONN, &bcs->Flag)) {\r\nschedule_event(bcs, B_LL_CONNECT);\r\n}\r\nif (test_and_clear_bit(BC_FLG_FTI_FTS, &bcs->Flag)) {\r\nschedule_event(bcs, B_LL_OK);\r\n}\r\n}\r\nstatic void\r\nsetup_pump(struct BCState *bcs) {\r\nstruct IsdnCardState *cs = bcs->cs;\r\nu_char dps = SET_DPS(bcs->hw.isar.dpath);\r\nu_char ctrl, param[6];\r\nswitch (bcs->mode) {\r\ncase L1_MODE_NULL:\r\ncase L1_MODE_TRANS:\r\ncase L1_MODE_HDLC:\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCFG, PMOD_BYPASS, 0, NULL);\r\nbreak;\r\ncase L1_MODE_V32:\r\nctrl = PMOD_DATAMODEM;\r\nif (test_bit(BC_FLG_ORIG, &bcs->Flag)) {\r\nctrl |= PCTRL_ORIG;\r\nparam[5] = PV32P6_CTN;\r\n} else {\r\nparam[5] = PV32P6_ATN;\r\n}\r\nparam[0] = para_TOA;\r\nparam[1] = PV32P2_V23R | PV32P2_V22A | PV32P2_V22B |\r\nPV32P2_V22C | PV32P2_V21 | PV32P2_BEL;\r\nparam[2] = PV32P3_AMOD | PV32P3_V32B | PV32P3_V23B;\r\nparam[3] = PV32P4_UT144;\r\nparam[4] = PV32P5_UT144;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCFG, ctrl, 6, param);\r\nbreak;\r\ncase L1_MODE_FAX:\r\nctrl = PMOD_FAX;\r\nif (test_bit(BC_FLG_ORIG, &bcs->Flag)) {\r\nctrl |= PCTRL_ORIG;\r\nparam[1] = PFAXP2_CTN;\r\n} else {\r\nparam[1] = PFAXP2_ATN;\r\n}\r\nparam[0] = para_TOA;\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCFG, ctrl, 2, param);\r\nbcs->hw.isar.state = STFAX_NULL;\r\nbcs->hw.isar.newcmd = 0;\r\nbcs->hw.isar.newmod = 0;\r\ntest_and_set_bit(BC_FLG_FTI_RUN, &bcs->Flag);\r\nbreak;\r\n}\r\nudelay(1000);\r\nsendmsg(cs, dps | ISAR_HIS_PSTREQ, 0, 0, NULL);\r\nudelay(1000);\r\n}\r\nstatic void\r\nsetup_sart(struct BCState *bcs) {\r\nstruct IsdnCardState *cs = bcs->cs;\r\nu_char dps = SET_DPS(bcs->hw.isar.dpath);\r\nu_char ctrl, param[2];\r\nswitch (bcs->mode) {\r\ncase L1_MODE_NULL:\r\nsendmsg(cs, dps | ISAR_HIS_SARTCFG, SMODE_DISABLE, 0,\r\nNULL);\r\nbreak;\r\ncase L1_MODE_TRANS:\r\nsendmsg(cs, dps | ISAR_HIS_SARTCFG, SMODE_BINARY, 2,\r\n"\0\0");\r\nbreak;\r\ncase L1_MODE_HDLC:\r\nparam[0] = 0;\r\nsendmsg(cs, dps | ISAR_HIS_SARTCFG, SMODE_HDLC, 1,\r\nparam);\r\nbreak;\r\ncase L1_MODE_V32:\r\nctrl = SMODE_V14 | SCTRL_HDMC_BOTH;\r\nparam[0] = S_P1_CHS_8;\r\nparam[1] = S_P2_BFT_DEF;\r\nsendmsg(cs, dps | ISAR_HIS_SARTCFG, ctrl, 2,\r\nparam);\r\nbreak;\r\ncase L1_MODE_FAX:\r\nbreak;\r\n}\r\nudelay(1000);\r\nsendmsg(cs, dps | ISAR_HIS_BSTREQ, 0, 0, NULL);\r\nudelay(1000);\r\n}\r\nstatic void\r\nsetup_iom2(struct BCState *bcs) {\r\nstruct IsdnCardState *cs = bcs->cs;\r\nu_char dps = SET_DPS(bcs->hw.isar.dpath);\r\nu_char cmsb = IOM_CTRL_ENA, msg[5] = {IOM_P1_TXD, 0, 0, 0, 0};\r\nif (bcs->channel)\r\nmsg[1] = msg[3] = 1;\r\nswitch (bcs->mode) {\r\ncase L1_MODE_NULL:\r\ncmsb = 0;\r\nmsg[1] = msg[3] = bcs->hw.isar.dpath + 2;\r\nbreak;\r\ncase L1_MODE_TRANS:\r\ncase L1_MODE_HDLC:\r\nbreak;\r\ncase L1_MODE_V32:\r\ncase L1_MODE_FAX:\r\ncmsb |= IOM_CTRL_ALAW | IOM_CTRL_RCV;\r\nbreak;\r\n}\r\nsendmsg(cs, dps | ISAR_HIS_IOM2CFG, cmsb, 5, msg);\r\nudelay(1000);\r\nsendmsg(cs, dps | ISAR_HIS_IOM2REQ, 0, 0, NULL);\r\nudelay(1000);\r\n}\r\nstatic int\r\nmodeisar(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif (bcs->mode == L1_MODE_NULL) {\r\nbcs->channel = bc;\r\nswitch (mode) {\r\ncase L1_MODE_NULL:\r\nif (!bcs->hw.isar.dpath)\r\nreturn (0);\r\nbreak;\r\ncase L1_MODE_TRANS:\r\ncase L1_MODE_HDLC:\r\nif (!test_and_set_bit(ISAR_DP2_USE,\r\n&bcs->hw.isar.reg->Flags))\r\nbcs->hw.isar.dpath = 2;\r\nelse if (!test_and_set_bit(ISAR_DP1_USE,\r\n&bcs->hw.isar.reg->Flags))\r\nbcs->hw.isar.dpath = 1;\r\nelse {\r\nprintk(KERN_WARNING"isar modeisar both pathes in use\n");\r\nreturn (1);\r\n}\r\nbreak;\r\ncase L1_MODE_V32:\r\ncase L1_MODE_FAX:\r\nif (!test_and_set_bit(ISAR_DP1_USE,\r\n&bcs->hw.isar.reg->Flags))\r\nbcs->hw.isar.dpath = 1;\r\nelse {\r\nprintk(KERN_WARNING"isar modeisar analog functions only with DP1\n");\r\ndebugl1(cs, "isar modeisar analog functions only with DP1");\r\nreturn (1);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "isar dp%d mode %d->%d ichan %d",\r\nbcs->hw.isar.dpath, bcs->mode, mode, bc);\r\nbcs->mode = mode;\r\nsetup_pump(bcs);\r\nsetup_iom2(bcs);\r\nsetup_sart(bcs);\r\nif (bcs->mode == L1_MODE_NULL) {\r\nif (bcs->hw.isar.dpath == 1)\r\ntest_and_clear_bit(ISAR_DP1_USE, &bcs->hw.isar.reg->Flags);\r\nelse if (bcs->hw.isar.dpath == 2)\r\ntest_and_clear_bit(ISAR_DP2_USE, &bcs->hw.isar.reg->Flags);\r\nbcs->hw.isar.dpath = 0;\r\n}\r\nreturn (0);\r\n}\r\nstatic void\r\nisar_pump_cmd(struct BCState *bcs, u_char cmd, u_char para)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nu_char dps = SET_DPS(bcs->hw.isar.dpath);\r\nu_char ctrl = 0, nom = 0, p1 = 0;\r\nswitch (cmd) {\r\ncase ISDN_FAX_CLASS1_FTM:\r\ntest_and_clear_bit(BC_FLG_FRH_WAIT, &bcs->Flag);\r\nif (bcs->hw.isar.state == STFAX_READY) {\r\np1 = para;\r\nctrl = PCTRL_CMD_FTM;\r\nnom = 1;\r\nbcs->hw.isar.state = STFAX_LINE;\r\nbcs->hw.isar.cmd = ctrl;\r\nbcs->hw.isar.mod = para;\r\nbcs->hw.isar.newmod = 0;\r\nbcs->hw.isar.newcmd = 0;\r\nbcs->hw.isar.try_mod = 3;\r\n} else if ((bcs->hw.isar.state == STFAX_ACTIV) &&\r\n(bcs->hw.isar.cmd == PCTRL_CMD_FTM) &&\r\n(bcs->hw.isar.mod == para)) {\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_CONNECT);\r\n} else {\r\nbcs->hw.isar.newmod = para;\r\nbcs->hw.isar.newcmd = PCTRL_CMD_FTM;\r\nnom = 0;\r\nctrl = PCTRL_CMD_ESC;\r\nbcs->hw.isar.state = STFAX_ESCAPE;\r\n}\r\nbreak;\r\ncase ISDN_FAX_CLASS1_FTH:\r\ntest_and_clear_bit(BC_FLG_FRH_WAIT, &bcs->Flag);\r\nif (bcs->hw.isar.state == STFAX_READY) {\r\np1 = para;\r\nctrl = PCTRL_CMD_FTH;\r\nnom = 1;\r\nbcs->hw.isar.state = STFAX_LINE;\r\nbcs->hw.isar.cmd = ctrl;\r\nbcs->hw.isar.mod = para;\r\nbcs->hw.isar.newmod = 0;\r\nbcs->hw.isar.newcmd = 0;\r\nbcs->hw.isar.try_mod = 3;\r\n} else if ((bcs->hw.isar.state == STFAX_ACTIV) &&\r\n(bcs->hw.isar.cmd == PCTRL_CMD_FTH) &&\r\n(bcs->hw.isar.mod == para)) {\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_CONNECT);\r\n} else {\r\nbcs->hw.isar.newmod = para;\r\nbcs->hw.isar.newcmd = PCTRL_CMD_FTH;\r\nnom = 0;\r\nctrl = PCTRL_CMD_ESC;\r\nbcs->hw.isar.state = STFAX_ESCAPE;\r\n}\r\nbreak;\r\ncase ISDN_FAX_CLASS1_FRM:\r\ntest_and_clear_bit(BC_FLG_FRH_WAIT, &bcs->Flag);\r\nif (bcs->hw.isar.state == STFAX_READY) {\r\np1 = para;\r\nctrl = PCTRL_CMD_FRM;\r\nnom = 1;\r\nbcs->hw.isar.state = STFAX_LINE;\r\nbcs->hw.isar.cmd = ctrl;\r\nbcs->hw.isar.mod = para;\r\nbcs->hw.isar.newmod = 0;\r\nbcs->hw.isar.newcmd = 0;\r\nbcs->hw.isar.try_mod = 3;\r\n} else if ((bcs->hw.isar.state == STFAX_ACTIV) &&\r\n(bcs->hw.isar.cmd == PCTRL_CMD_FRM) &&\r\n(bcs->hw.isar.mod == para)) {\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_CONNECT);\r\n} else {\r\nbcs->hw.isar.newmod = para;\r\nbcs->hw.isar.newcmd = PCTRL_CMD_FRM;\r\nnom = 0;\r\nctrl = PCTRL_CMD_ESC;\r\nbcs->hw.isar.state = STFAX_ESCAPE;\r\n}\r\nbreak;\r\ncase ISDN_FAX_CLASS1_FRH:\r\ntest_and_set_bit(BC_FLG_FRH_WAIT, &bcs->Flag);\r\nif (bcs->hw.isar.state == STFAX_READY) {\r\np1 = para;\r\nctrl = PCTRL_CMD_FRH;\r\nnom = 1;\r\nbcs->hw.isar.state = STFAX_LINE;\r\nbcs->hw.isar.cmd = ctrl;\r\nbcs->hw.isar.mod = para;\r\nbcs->hw.isar.newmod = 0;\r\nbcs->hw.isar.newcmd = 0;\r\nbcs->hw.isar.try_mod = 3;\r\n} else if ((bcs->hw.isar.state == STFAX_ACTIV) &&\r\n(bcs->hw.isar.cmd == PCTRL_CMD_FRH) &&\r\n(bcs->hw.isar.mod == para)) {\r\nll_deliver_faxstat(bcs, ISDN_FAX_CLASS1_CONNECT);\r\n} else {\r\nbcs->hw.isar.newmod = para;\r\nbcs->hw.isar.newcmd = PCTRL_CMD_FRH;\r\nnom = 0;\r\nctrl = PCTRL_CMD_ESC;\r\nbcs->hw.isar.state = STFAX_ESCAPE;\r\n}\r\nbreak;\r\ncase ISDN_FAXPUMP_HALT:\r\nbcs->hw.isar.state = STFAX_NULL;\r\nnom = 0;\r\nctrl = PCTRL_CMD_HALT;\r\nbreak;\r\n}\r\nif (ctrl)\r\nsendmsg(cs, dps | ISAR_HIS_PUMPCTRL, ctrl, nom, &p1);\r\n}\r\nstatic void\r\nisar_setup(struct IsdnCardState *cs)\r\n{\r\nu_char msg;\r\nint i;\r\nmsg = 61;\r\nfor (i = 0; i < 2; i++) {\r\nsendmsg(cs, (i ? ISAR_HIS_DPS2 : ISAR_HIS_DPS1) |\r\nISAR_HIS_P12CFG, 4, 1, &msg);\r\ncs->bcs[i].hw.isar.mml = msg;\r\ncs->bcs[i].mode = 0;\r\ncs->bcs[i].hw.isar.dpath = i + 1;\r\nmodeisar(&cs->bcs[i], 0, 0);\r\nINIT_WORK(&cs->bcs[i].tqueue, isar_bh);\r\n}\r\n}\r\nstatic void\r\nisar_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nint ret;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "DRQ set BC_FLG_BUSY");\r\nbcs->hw.isar.txcnt = 0;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "isar_l2l1: this shouldn't happen\n");\r\n} else {\r\ntest_and_set_bit(BC_FLG_BUSY, &bcs->Flag);\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "PUI set BC_FLG_BUSY");\r\nbcs->tx_skb = skb;\r\nbcs->hw.isar.txcnt = 0;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nbcs->hw.isar.conmsg[0] = 0;\r\nif (test_bit(FLG_ORIG, &st->l2.flag))\r\ntest_and_set_bit(BC_FLG_ORIG, &bcs->Flag);\r\nelse\r\ntest_and_clear_bit(BC_FLG_ORIG, &bcs->Flag);\r\nswitch (st->l1.mode) {\r\ncase L1_MODE_TRANS:\r\ncase L1_MODE_HDLC:\r\nret = modeisar(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nif (ret)\r\nl1_msg_b(st, PH_DEACTIVATE | REQUEST, arg);\r\nelse\r\nl1_msg_b(st, PH_ACTIVATE | REQUEST, arg);\r\nbreak;\r\ncase L1_MODE_V32:\r\ncase L1_MODE_FAX:\r\nret = modeisar(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nif (ret)\r\nl1_msg_b(st, PH_DEACTIVATE | REQUEST, arg);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\n}\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nswitch (st->l1.mode) {\r\ncase L1_MODE_TRANS:\r\ncase L1_MODE_HDLC:\r\ncase L1_MODE_V32:\r\nbreak;\r\ncase L1_MODE_FAX:\r\nisar_pump_cmd(bcs, ISDN_FAXPUMP_HALT, 0);\r\nbreak;\r\n}\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "PDAC clear BC_FLG_BUSY");\r\nmodeisar(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_isarstate(struct BCState *bcs)\r\n{\r\nmodeisar(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nkfree(bcs->hw.isar.rcvbuf);\r\nbcs->hw.isar.rcvbuf = NULL;\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nif (bcs->cs->debug & L1_DEB_HSCX)\r\ndebugl1(bcs->cs, "closeisar clear BC_FLG_BUSY");\r\n}\r\n}\r\ndel_timer(&bcs->hw.isar.ftimer);\r\n}\r\nstatic int\r\nopen_isarstate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nif (!(bcs->hw.isar.rcvbuf = kmalloc(HSCX_BUFMAX, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for isar.rcvbuf\n");\r\nreturn (1);\r\n}\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "openisar clear BC_FLG_BUSY");\r\nbcs->event = 0;\r\nbcs->hw.isar.rcvidx = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_isar(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_isarstate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = isar_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nint\r\nisar_auxcmd(struct IsdnCardState *cs, isdn_ctrl *ic) {\r\nu_long adr;\r\nint features, i;\r\nstruct BCState *bcs;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "isar_auxcmd cmd/ch %x/%ld", ic->command, ic->arg);\r\nswitch (ic->command) {\r\ncase (ISDN_CMD_FAXCMD):\r\nbcs = cs->channel[ic->arg].bcs;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "isar_auxcmd cmd/subcmd %d/%d",\r\nic->parm.aux.cmd, ic->parm.aux.subcmd);\r\nswitch (ic->parm.aux.cmd) {\r\ncase ISDN_FAX_CLASS1_CTRL:\r\nif (ic->parm.aux.subcmd == ETX)\r\ntest_and_set_bit(BC_FLG_DLEETX,\r\n&bcs->Flag);\r\nbreak;\r\ncase ISDN_FAX_CLASS1_FTS:\r\nif (ic->parm.aux.subcmd == AT_QUERY) {\r\nic->command = ISDN_STAT_FAXIND;\r\nic->parm.aux.cmd = ISDN_FAX_CLASS1_OK;\r\ncs->iif.statcallb(ic);\r\nreturn (0);\r\n} else if (ic->parm.aux.subcmd == AT_EQ_QUERY) {\r\nstrcpy(ic->parm.aux.para, "0-255");\r\nic->command = ISDN_STAT_FAXIND;\r\nic->parm.aux.cmd = ISDN_FAX_CLASS1_QUERY;\r\ncs->iif.statcallb(ic);\r\nreturn (0);\r\n} else if (ic->parm.aux.subcmd == AT_EQ_VALUE) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "isar_auxcmd %s=%d",\r\nFC1_CMD[ic->parm.aux.cmd], ic->parm.aux.para[0]);\r\nif (bcs->hw.isar.state == STFAX_READY) {\r\nif (!ic->parm.aux.para[0]) {\r\nic->command = ISDN_STAT_FAXIND;\r\nic->parm.aux.cmd = ISDN_FAX_CLASS1_OK;\r\ncs->iif.statcallb(ic);\r\nreturn (0);\r\n}\r\nif (!test_and_set_bit(BC_FLG_FTI_RUN, &bcs->Flag)) {\r\nbcs->hw.isar.ftimer.expires =\r\njiffies + ((ic->parm.aux.para[0] * 10 * HZ) / 1000);\r\ntest_and_set_bit(BC_FLG_FTI_FTS, &bcs->Flag);\r\nadd_timer(&bcs->hw.isar.ftimer);\r\nreturn (0);\r\n} else {\r\nif (cs->debug)\r\ndebugl1(cs, "isar FTS=%d and FTI busy",\r\nic->parm.aux.para[0]);\r\n}\r\n} else {\r\nif (cs->debug)\r\ndebugl1(cs, "isar FTS=%d and isar.state not ready(%x)",\r\nic->parm.aux.para[0], bcs->hw.isar.state);\r\n}\r\nic->command = ISDN_STAT_FAXIND;\r\nic->parm.aux.cmd = ISDN_FAX_CLASS1_ERROR;\r\ncs->iif.statcallb(ic);\r\n}\r\nbreak;\r\ncase ISDN_FAX_CLASS1_FRM:\r\ncase ISDN_FAX_CLASS1_FRH:\r\ncase ISDN_FAX_CLASS1_FTM:\r\ncase ISDN_FAX_CLASS1_FTH:\r\nif (ic->parm.aux.subcmd == AT_QUERY) {\r\nsprintf(ic->parm.aux.para,\r\n"%d", bcs->hw.isar.mod);\r\nic->command = ISDN_STAT_FAXIND;\r\nic->parm.aux.cmd = ISDN_FAX_CLASS1_QUERY;\r\ncs->iif.statcallb(ic);\r\nreturn (0);\r\n} else if (ic->parm.aux.subcmd == AT_EQ_QUERY) {\r\nchar *p = ic->parm.aux.para;\r\nfor (i = 0; i < FAXMODCNT; i++)\r\nif ((1 << i) & modmask)\r\np += sprintf(p, "%d,", faxmodulation[i]);\r\np--;\r\n*p = 0;\r\nic->command = ISDN_STAT_FAXIND;\r\nic->parm.aux.cmd = ISDN_FAX_CLASS1_QUERY;\r\ncs->iif.statcallb(ic);\r\nreturn (0);\r\n} else if (ic->parm.aux.subcmd == AT_EQ_VALUE) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "isar_auxcmd %s=%d",\r\nFC1_CMD[ic->parm.aux.cmd], ic->parm.aux.para[0]);\r\nfor (i = 0; i < FAXMODCNT; i++)\r\nif (faxmodulation[i] == ic->parm.aux.para[0])\r\nbreak;\r\nif ((i < FAXMODCNT) && ((1 << i) & modmask) &&\r\ntest_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nisar_pump_cmd(bcs,\r\nic->parm.aux.cmd,\r\nic->parm.aux.para[0]);\r\nreturn (0);\r\n}\r\n}\r\ndefault:\r\nic->command = ISDN_STAT_FAXIND;\r\nic->parm.aux.cmd = ISDN_FAX_CLASS1_ERROR;\r\ncs->iif.statcallb(ic);\r\n}\r\nbreak;\r\ncase (ISDN_CMD_IOCTL):\r\nswitch (ic->arg) {\r\ncase 9:\r\nfeatures = ISDN_FEATURE_L2_MODEM |\r\nISDN_FEATURE_L2_FAX |\r\nISDN_FEATURE_L3_FCLASS1;\r\nmemcpy(&adr, ic->parm.num, sizeof(ulong));\r\nif (isar_load_firmware(cs, (u_char __user *)adr))\r\nreturn (1);\r\nelse\r\nll_run(cs, features);\r\nbreak;\r\ncase 20:\r\nfeatures = *(unsigned int *) ic->parm.num;\r\nprintk(KERN_DEBUG "HiSax: max modulation old(%04x) new(%04x)\n",\r\nmodmask, features);\r\nmodmask = features;\r\nbreak;\r\ncase 21:\r\nfeatures = *(unsigned int *) ic->parm.num;\r\nprintk(KERN_DEBUG "HiSax: FRM extra delay old(%d) new(%d) ms\n",\r\nfrm_extra_delay, features);\r\nif (features >= 0)\r\nfrm_extra_delay = features;\r\nbreak;\r\ncase 22:\r\nfeatures = *(unsigned int *) ic->parm.num;\r\nprintk(KERN_DEBUG "HiSax: TOA old(%d) new(%d) db\n",\r\npara_TOA, features);\r\nif (features >= 0 && features < 32)\r\npara_TOA = features;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "HiSax: invalid ioctl %d\n",\r\n(int) ic->arg);\r\nreturn (-EINVAL);\r\n}\r\nbreak;\r\ndefault:\r\nreturn (-EINVAL);\r\n}\r\nreturn (0);\r\n}\r\nvoid initisar(struct IsdnCardState *cs)\r\n{\r\ncs->bcs[0].BC_SetStack = setstack_isar;\r\ncs->bcs[1].BC_SetStack = setstack_isar;\r\ncs->bcs[0].BC_Close = close_isarstate;\r\ncs->bcs[1].BC_Close = close_isarstate;\r\ncs->bcs[0].hw.isar.ftimer.function = (void *) ftimer_handler;\r\ncs->bcs[0].hw.isar.ftimer.data = (long) &cs->bcs[0];\r\ninit_timer(&cs->bcs[0].hw.isar.ftimer);\r\ncs->bcs[1].hw.isar.ftimer.function = (void *) ftimer_handler;\r\ncs->bcs[1].hw.isar.ftimer.data = (long) &cs->bcs[1];\r\ninit_timer(&cs->bcs[1].hw.isar.ftimer);\r\n}
