int utf8_to_utf32(const u8 *s, int inlen, unicode_t *pu)\r\n{\r\nunsigned long l;\r\nint c0, c, nc;\r\nconst struct utf8_table *t;\r\nnc = 0;\r\nc0 = *s;\r\nl = c0;\r\nfor (t = utf8_table; t->cmask; t++) {\r\nnc++;\r\nif ((c0 & t->cmask) == t->cval) {\r\nl &= t->lmask;\r\nif (l < t->lval || l > UNICODE_MAX ||\r\n(l & SURROGATE_MASK) == SURROGATE_PAIR)\r\nreturn -1;\r\n*pu = (unicode_t) l;\r\nreturn nc;\r\n}\r\nif (inlen <= nc)\r\nreturn -1;\r\ns++;\r\nc = (*s ^ 0x80) & 0xFF;\r\nif (c & 0xC0)\r\nreturn -1;\r\nl = (l << 6) | c;\r\n}\r\nreturn -1;\r\n}\r\nint utf32_to_utf8(unicode_t u, u8 *s, int maxout)\r\n{\r\nunsigned long l;\r\nint c, nc;\r\nconst struct utf8_table *t;\r\nif (!s)\r\nreturn 0;\r\nl = u;\r\nif (l > UNICODE_MAX || (l & SURROGATE_MASK) == SURROGATE_PAIR)\r\nreturn -1;\r\nnc = 0;\r\nfor (t = utf8_table; t->cmask && maxout; t++, maxout--) {\r\nnc++;\r\nif (l <= t->lmask) {\r\nc = t->shift;\r\n*s = (u8) (t->cval | (l >> c));\r\nwhile (c > 0) {\r\nc -= 6;\r\ns++;\r\n*s = (u8) (0x80 | ((l >> c) & 0x3F));\r\n}\r\nreturn nc;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)\r\n{\r\nswitch (endian) {\r\ndefault:\r\n*s = (wchar_t) c;\r\nbreak;\r\ncase UTF16_LITTLE_ENDIAN:\r\n*s = __cpu_to_le16(c);\r\nbreak;\r\ncase UTF16_BIG_ENDIAN:\r\n*s = __cpu_to_be16(c);\r\nbreak;\r\n}\r\n}\r\nint utf8s_to_utf16s(const u8 *s, int inlen, enum utf16_endian endian,\r\nwchar_t *pwcs, int maxout)\r\n{\r\nu16 *op;\r\nint size;\r\nunicode_t u;\r\nop = pwcs;\r\nwhile (inlen > 0 && maxout > 0 && *s) {\r\nif (*s & 0x80) {\r\nsize = utf8_to_utf32(s, inlen, &u);\r\nif (size < 0)\r\nreturn -EINVAL;\r\ns += size;\r\ninlen -= size;\r\nif (u >= PLANE_SIZE) {\r\nif (maxout < 2)\r\nbreak;\r\nu -= PLANE_SIZE;\r\nput_utf16(op++, SURROGATE_PAIR |\r\n((u >> 10) & SURROGATE_BITS),\r\nendian);\r\nput_utf16(op++, SURROGATE_PAIR |\r\nSURROGATE_LOW |\r\n(u & SURROGATE_BITS),\r\nendian);\r\nmaxout -= 2;\r\n} else {\r\nput_utf16(op++, u, endian);\r\nmaxout--;\r\n}\r\n} else {\r\nput_utf16(op++, *s++, endian);\r\ninlen--;\r\nmaxout--;\r\n}\r\n}\r\nreturn op - pwcs;\r\n}\r\nstatic inline unsigned long get_utf16(unsigned c, enum utf16_endian endian)\r\n{\r\nswitch (endian) {\r\ndefault:\r\nreturn c;\r\ncase UTF16_LITTLE_ENDIAN:\r\nreturn __le16_to_cpu(c);\r\ncase UTF16_BIG_ENDIAN:\r\nreturn __be16_to_cpu(c);\r\n}\r\n}\r\nint utf16s_to_utf8s(const wchar_t *pwcs, int inlen, enum utf16_endian endian,\r\nu8 *s, int maxout)\r\n{\r\nu8 *op;\r\nint size;\r\nunsigned long u, v;\r\nop = s;\r\nwhile (inlen > 0 && maxout > 0) {\r\nu = get_utf16(*pwcs, endian);\r\nif (!u)\r\nbreak;\r\npwcs++;\r\ninlen--;\r\nif (u > 0x7f) {\r\nif ((u & SURROGATE_MASK) == SURROGATE_PAIR) {\r\nif (u & SURROGATE_LOW) {\r\ncontinue;\r\n}\r\nif (inlen <= 0)\r\nbreak;\r\nv = get_utf16(*pwcs, endian);\r\nif ((v & SURROGATE_MASK) != SURROGATE_PAIR ||\r\n!(v & SURROGATE_LOW)) {\r\ncontinue;\r\n}\r\nu = PLANE_SIZE + ((u & SURROGATE_BITS) << 10)\r\n+ (v & SURROGATE_BITS);\r\npwcs++;\r\ninlen--;\r\n}\r\nsize = utf32_to_utf8(u, op, maxout);\r\nif (size == -1) {\r\n} else {\r\nop += size;\r\nmaxout -= size;\r\n}\r\n} else {\r\n*op++ = (u8) u;\r\nmaxout--;\r\n}\r\n}\r\nreturn op - s;\r\n}\r\nint register_nls(struct nls_table * nls)\r\n{\r\nstruct nls_table ** tmp = &tables;\r\nif (nls->next)\r\nreturn -EBUSY;\r\nspin_lock(&nls_lock);\r\nwhile (*tmp) {\r\nif (nls == *tmp) {\r\nspin_unlock(&nls_lock);\r\nreturn -EBUSY;\r\n}\r\ntmp = &(*tmp)->next;\r\n}\r\nnls->next = tables;\r\ntables = nls;\r\nspin_unlock(&nls_lock);\r\nreturn 0;\r\n}\r\nint unregister_nls(struct nls_table * nls)\r\n{\r\nstruct nls_table ** tmp = &tables;\r\nspin_lock(&nls_lock);\r\nwhile (*tmp) {\r\nif (nls == *tmp) {\r\n*tmp = nls->next;\r\nspin_unlock(&nls_lock);\r\nreturn 0;\r\n}\r\ntmp = &(*tmp)->next;\r\n}\r\nspin_unlock(&nls_lock);\r\nreturn -EINVAL;\r\n}\r\nstatic struct nls_table *find_nls(char *charset)\r\n{\r\nstruct nls_table *nls;\r\nspin_lock(&nls_lock);\r\nfor (nls = tables; nls; nls = nls->next) {\r\nif (!strcmp(nls->charset, charset))\r\nbreak;\r\nif (nls->alias && !strcmp(nls->alias, charset))\r\nbreak;\r\n}\r\nif (nls && !try_module_get(nls->owner))\r\nnls = NULL;\r\nspin_unlock(&nls_lock);\r\nreturn nls;\r\n}\r\nstruct nls_table *load_nls(char *charset)\r\n{\r\nreturn try_then_request_module(find_nls(charset), "nls_%s", charset);\r\n}\r\nvoid unload_nls(struct nls_table *nls)\r\n{\r\nif (nls)\r\nmodule_put(nls->owner);\r\n}\r\nstatic int uni2char(wchar_t uni, unsigned char *out, int boundlen)\r\n{\r\nconst unsigned char *uni2charset;\r\nunsigned char cl = uni & 0x00ff;\r\nunsigned char ch = (uni & 0xff00) >> 8;\r\nif (boundlen <= 0)\r\nreturn -ENAMETOOLONG;\r\nuni2charset = page_uni2charset[ch];\r\nif (uni2charset && uni2charset[cl])\r\nout[0] = uni2charset[cl];\r\nelse\r\nreturn -EINVAL;\r\nreturn 1;\r\n}\r\nstatic int char2uni(const unsigned char *rawstring, int boundlen, wchar_t *uni)\r\n{\r\n*uni = charset2uni[*rawstring];\r\nif (*uni == 0x0000)\r\nreturn -EINVAL;\r\nreturn 1;\r\n}\r\nstruct nls_table *load_nls_default(void)\r\n{\r\nstruct nls_table *default_nls;\r\ndefault_nls = load_nls(CONFIG_NLS_DEFAULT);\r\nif (default_nls != NULL)\r\nreturn default_nls;\r\nelse\r\nreturn &default_table;\r\n}
