static int __init gcov_persist_setup(char *str)\r\n{\r\nunsigned long val;\r\nif (strict_strtoul(str, 0, &val)) {\r\npr_warning("invalid gcov_persist parameter '%s'\n", str);\r\nreturn 0;\r\n}\r\ngcov_persist = val;\r\npr_info("setting gcov_persist to %d\n", gcov_persist);\r\nreturn 1;\r\n}\r\nstatic void *gcov_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nloff_t i;\r\ngcov_iter_start(seq->private);\r\nfor (i = 0; i < *pos; i++) {\r\nif (gcov_iter_next(seq->private))\r\nreturn NULL;\r\n}\r\nreturn seq->private;\r\n}\r\nstatic void *gcov_seq_next(struct seq_file *seq, void *data, loff_t *pos)\r\n{\r\nstruct gcov_iterator *iter = data;\r\nif (gcov_iter_next(iter))\r\nreturn NULL;\r\n(*pos)++;\r\nreturn iter;\r\n}\r\nstatic int gcov_seq_show(struct seq_file *seq, void *data)\r\n{\r\nstruct gcov_iterator *iter = data;\r\nif (gcov_iter_write(iter, seq))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void gcov_seq_stop(struct seq_file *seq, void *data)\r\n{\r\n}\r\nstatic struct gcov_info *get_node_info(struct gcov_node *node)\r\n{\r\nif (node->num_loaded > 0)\r\nreturn node->loaded_info[0];\r\nreturn node->unloaded_info;\r\n}\r\nstatic struct gcov_info *get_accumulated_info(struct gcov_node *node)\r\n{\r\nstruct gcov_info *info;\r\nint i = 0;\r\nif (node->unloaded_info)\r\ninfo = gcov_info_dup(node->unloaded_info);\r\nelse\r\ninfo = gcov_info_dup(node->loaded_info[i++]);\r\nif (!info)\r\nreturn NULL;\r\nfor (; i < node->num_loaded; i++)\r\ngcov_info_add(info, node->loaded_info[i]);\r\nreturn info;\r\n}\r\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct gcov_node *node = inode->i_private;\r\nstruct gcov_iterator *iter;\r\nstruct seq_file *seq;\r\nstruct gcov_info *info;\r\nint rc = -ENOMEM;\r\nmutex_lock(&node_lock);\r\ninfo = get_accumulated_info(node);\r\nif (!info)\r\ngoto out_unlock;\r\niter = gcov_iter_new(info);\r\nif (!iter)\r\ngoto err_free_info;\r\nrc = seq_open(file, &gcov_seq_ops);\r\nif (rc)\r\ngoto err_free_iter_info;\r\nseq = file->private_data;\r\nseq->private = iter;\r\nout_unlock:\r\nmutex_unlock(&node_lock);\r\nreturn rc;\r\nerr_free_iter_info:\r\ngcov_iter_free(iter);\r\nerr_free_info:\r\ngcov_info_free(info);\r\ngoto out_unlock;\r\n}\r\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\r\n{\r\nstruct gcov_iterator *iter;\r\nstruct gcov_info *info;\r\nstruct seq_file *seq;\r\nseq = file->private_data;\r\niter = seq->private;\r\ninfo = gcov_iter_get_info(iter);\r\ngcov_iter_free(iter);\r\ngcov_info_free(info);\r\nseq_release(inode, file);\r\nreturn 0;\r\n}\r\nstatic struct gcov_node *get_node_by_name(const char *name)\r\n{\r\nstruct gcov_node *node;\r\nstruct gcov_info *info;\r\nlist_for_each_entry(node, &all_head, all) {\r\ninfo = get_node_info(node);\r\nif (info && (strcmp(info->filename, name) == 0))\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void reset_node(struct gcov_node *node)\r\n{\r\nint i;\r\nif (node->unloaded_info)\r\ngcov_info_reset(node->unloaded_info);\r\nfor (i = 0; i < node->num_loaded; i++)\r\ngcov_info_reset(node->loaded_info[i]);\r\n}\r\nstatic ssize_t gcov_seq_write(struct file *file, const char __user *addr,\r\nsize_t len, loff_t *pos)\r\n{\r\nstruct seq_file *seq;\r\nstruct gcov_info *info;\r\nstruct gcov_node *node;\r\nseq = file->private_data;\r\ninfo = gcov_iter_get_info(seq->private);\r\nmutex_lock(&node_lock);\r\nnode = get_node_by_name(info->filename);\r\nif (node) {\r\nif (node->num_loaded == 0)\r\nremove_node(node);\r\nelse\r\nreset_node(node);\r\n}\r\ngcov_info_reset(info);\r\nmutex_unlock(&node_lock);\r\nreturn len;\r\n}\r\nstatic char *link_target(const char *dir, const char *path, const char *ext)\r\n{\r\nchar *target;\r\nchar *old_ext;\r\nchar *copy;\r\ncopy = kstrdup(path, GFP_KERNEL);\r\nif (!copy)\r\nreturn NULL;\r\nold_ext = strrchr(copy, '.');\r\nif (old_ext)\r\n*old_ext = '\0';\r\nif (dir)\r\ntarget = kasprintf(GFP_KERNEL, "%s/%s.%s", dir, copy, ext);\r\nelse\r\ntarget = kasprintf(GFP_KERNEL, "%s.%s", copy, ext);\r\nkfree(copy);\r\nreturn target;\r\n}\r\nstatic char *get_link_target(const char *filename, const struct gcov_link *ext)\r\n{\r\nconst char *rel;\r\nchar *result;\r\nif (strncmp(filename, objtree, strlen(objtree)) == 0) {\r\nrel = filename + strlen(objtree) + 1;\r\nif (ext->dir == SRC_TREE)\r\nresult = link_target(srctree, rel, ext->ext);\r\nelse\r\nresult = link_target(objtree, rel, ext->ext);\r\n} else {\r\nresult = link_target(NULL, filename, ext->ext);\r\n}\r\nreturn result;\r\n}\r\nstatic const char *deskew(const char *basename)\r\n{\r\nif (strncmp(basename, SKEW_PREFIX, sizeof(SKEW_PREFIX) - 1) == 0)\r\nreturn basename + sizeof(SKEW_PREFIX) - 1;\r\nreturn basename;\r\n}\r\nstatic void add_links(struct gcov_node *node, struct dentry *parent)\r\n{\r\nchar *basename;\r\nchar *target;\r\nint num;\r\nint i;\r\nfor (num = 0; gcov_link[num].ext; num++)\r\n;\r\nnode->links = kcalloc(num, sizeof(struct dentry *), GFP_KERNEL);\r\nif (!node->links)\r\nreturn;\r\nfor (i = 0; i < num; i++) {\r\ntarget = get_link_target(get_node_info(node)->filename,\r\n&gcov_link[i]);\r\nif (!target)\r\ngoto out_err;\r\nbasename = strrchr(target, '/');\r\nif (!basename)\r\ngoto out_err;\r\nbasename++;\r\nnode->links[i] = debugfs_create_symlink(deskew(basename),\r\nparent, target);\r\nif (!node->links[i])\r\ngoto out_err;\r\nkfree(target);\r\n}\r\nreturn;\r\nout_err:\r\nkfree(target);\r\nwhile (i-- > 0)\r\ndebugfs_remove(node->links[i]);\r\nkfree(node->links);\r\nnode->links = NULL;\r\n}\r\nstatic void init_node(struct gcov_node *node, struct gcov_info *info,\r\nconst char *name, struct gcov_node *parent)\r\n{\r\nINIT_LIST_HEAD(&node->list);\r\nINIT_LIST_HEAD(&node->children);\r\nINIT_LIST_HEAD(&node->all);\r\nif (node->loaded_info) {\r\nnode->loaded_info[0] = info;\r\nnode->num_loaded = 1;\r\n}\r\nnode->parent = parent;\r\nif (name)\r\nstrcpy(node->name, name);\r\n}\r\nstatic struct gcov_node *new_node(struct gcov_node *parent,\r\nstruct gcov_info *info, const char *name)\r\n{\r\nstruct gcov_node *node;\r\nnode = kzalloc(sizeof(struct gcov_node) + strlen(name) + 1, GFP_KERNEL);\r\nif (!node)\r\ngoto err_nomem;\r\nif (info) {\r\nnode->loaded_info = kcalloc(1, sizeof(struct gcov_info *),\r\nGFP_KERNEL);\r\nif (!node->loaded_info)\r\ngoto err_nomem;\r\n}\r\ninit_node(node, info, name, parent);\r\nif (info) {\r\nnode->dentry = debugfs_create_file(deskew(node->name), 0600,\r\nparent->dentry, node, &gcov_data_fops);\r\n} else\r\nnode->dentry = debugfs_create_dir(node->name, parent->dentry);\r\nif (!node->dentry) {\r\npr_warning("could not create file\n");\r\nkfree(node);\r\nreturn NULL;\r\n}\r\nif (info)\r\nadd_links(node, parent->dentry);\r\nlist_add(&node->list, &parent->children);\r\nlist_add(&node->all, &all_head);\r\nreturn node;\r\nerr_nomem:\r\nkfree(node);\r\npr_warning("out of memory\n");\r\nreturn NULL;\r\n}\r\nstatic void remove_links(struct gcov_node *node)\r\n{\r\nint i;\r\nif (!node->links)\r\nreturn;\r\nfor (i = 0; gcov_link[i].ext; i++)\r\ndebugfs_remove(node->links[i]);\r\nkfree(node->links);\r\nnode->links = NULL;\r\n}\r\nstatic void release_node(struct gcov_node *node)\r\n{\r\nlist_del(&node->list);\r\nlist_del(&node->all);\r\ndebugfs_remove(node->dentry);\r\nremove_links(node);\r\nkfree(node->loaded_info);\r\nif (node->unloaded_info)\r\ngcov_info_free(node->unloaded_info);\r\nkfree(node);\r\n}\r\nstatic void remove_node(struct gcov_node *node)\r\n{\r\nstruct gcov_node *parent;\r\nwhile ((node != &root_node) && list_empty(&node->children)) {\r\nparent = node->parent;\r\nrelease_node(node);\r\nnode = parent;\r\n}\r\n}\r\nstatic struct gcov_node *get_child_by_name(struct gcov_node *parent,\r\nconst char *name)\r\n{\r\nstruct gcov_node *node;\r\nlist_for_each_entry(node, &parent->children, list) {\r\nif (strcmp(node->name, name) == 0)\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstatic ssize_t reset_write(struct file *file, const char __user *addr,\r\nsize_t len, loff_t *pos)\r\n{\r\nstruct gcov_node *node;\r\nmutex_lock(&node_lock);\r\nrestart:\r\nlist_for_each_entry(node, &all_head, all) {\r\nif (node->num_loaded > 0)\r\nreset_node(node);\r\nelse if (list_empty(&node->children)) {\r\nremove_node(node);\r\ngoto restart;\r\n}\r\n}\r\nmutex_unlock(&node_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t reset_read(struct file *file, char __user *addr, size_t len,\r\nloff_t *pos)\r\n{\r\nreturn 0;\r\n}\r\nstatic void add_node(struct gcov_info *info)\r\n{\r\nchar *filename;\r\nchar *curr;\r\nchar *next;\r\nstruct gcov_node *parent;\r\nstruct gcov_node *node;\r\nfilename = kstrdup(info->filename, GFP_KERNEL);\r\nif (!filename)\r\nreturn;\r\nparent = &root_node;\r\nfor (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {\r\nif (curr == next)\r\ncontinue;\r\n*next = 0;\r\nif (strcmp(curr, ".") == 0)\r\ncontinue;\r\nif (strcmp(curr, "..") == 0) {\r\nif (!parent->parent)\r\ngoto err_remove;\r\nparent = parent->parent;\r\ncontinue;\r\n}\r\nnode = get_child_by_name(parent, curr);\r\nif (!node) {\r\nnode = new_node(parent, NULL, curr);\r\nif (!node)\r\ngoto err_remove;\r\n}\r\nparent = node;\r\n}\r\nnode = new_node(parent, info, curr);\r\nif (!node)\r\ngoto err_remove;\r\nout:\r\nkfree(filename);\r\nreturn;\r\nerr_remove:\r\nremove_node(parent);\r\ngoto out;\r\n}\r\nstatic void add_info(struct gcov_node *node, struct gcov_info *info)\r\n{\r\nstruct gcov_info **loaded_info;\r\nint num = node->num_loaded;\r\nloaded_info = kcalloc(num + 1, sizeof(struct gcov_info *), GFP_KERNEL);\r\nif (!loaded_info) {\r\npr_warning("could not add '%s' (out of memory)\n",\r\ninfo->filename);\r\nreturn;\r\n}\r\nmemcpy(loaded_info, node->loaded_info,\r\nnum * sizeof(struct gcov_info *));\r\nloaded_info[num] = info;\r\nif (num == 0) {\r\nif (!gcov_info_is_compatible(node->unloaded_info, info)) {\r\npr_warning("discarding saved data for %s "\r\n"(incompatible version)\n", info->filename);\r\ngcov_info_free(node->unloaded_info);\r\nnode->unloaded_info = NULL;\r\n}\r\n} else {\r\nif (!gcov_info_is_compatible(node->loaded_info[0], info)) {\r\npr_warning("could not add '%s' (incompatible "\r\n"version)\n", info->filename);\r\nkfree(loaded_info);\r\nreturn;\r\n}\r\n}\r\nkfree(node->loaded_info);\r\nnode->loaded_info = loaded_info;\r\nnode->num_loaded = num + 1;\r\n}\r\nstatic int get_info_index(struct gcov_node *node, struct gcov_info *info)\r\n{\r\nint i;\r\nfor (i = 0; i < node->num_loaded; i++) {\r\nif (node->loaded_info[i] == info)\r\nreturn i;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void save_info(struct gcov_node *node, struct gcov_info *info)\r\n{\r\nif (node->unloaded_info)\r\ngcov_info_add(node->unloaded_info, info);\r\nelse {\r\nnode->unloaded_info = gcov_info_dup(info);\r\nif (!node->unloaded_info) {\r\npr_warning("could not save data for '%s' "\r\n"(out of memory)\n", info->filename);\r\n}\r\n}\r\n}\r\nstatic void remove_info(struct gcov_node *node, struct gcov_info *info)\r\n{\r\nint i;\r\ni = get_info_index(node, info);\r\nif (i < 0) {\r\npr_warning("could not remove '%s' (not found)\n",\r\ninfo->filename);\r\nreturn;\r\n}\r\nif (gcov_persist)\r\nsave_info(node, info);\r\nnode->loaded_info[i] = node->loaded_info[node->num_loaded - 1];\r\nnode->num_loaded--;\r\nif (node->num_loaded > 0)\r\nreturn;\r\nkfree(node->loaded_info);\r\nnode->loaded_info = NULL;\r\nnode->num_loaded = 0;\r\nif (!node->unloaded_info)\r\nremove_node(node);\r\n}\r\nvoid gcov_event(enum gcov_action action, struct gcov_info *info)\r\n{\r\nstruct gcov_node *node;\r\nmutex_lock(&node_lock);\r\nnode = get_node_by_name(info->filename);\r\nswitch (action) {\r\ncase GCOV_ADD:\r\nif (node)\r\nadd_info(node, info);\r\nelse\r\nadd_node(info);\r\nbreak;\r\ncase GCOV_REMOVE:\r\nif (node)\r\nremove_info(node, info);\r\nelse {\r\npr_warning("could not remove '%s' (not found)\n",\r\ninfo->filename);\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&node_lock);\r\n}\r\nstatic __init int gcov_fs_init(void)\r\n{\r\nint rc = -EIO;\r\ninit_node(&root_node, NULL, NULL, NULL);\r\nroot_node.dentry = debugfs_create_dir("gcov", NULL);\r\nif (!root_node.dentry)\r\ngoto err_remove;\r\nreset_dentry = debugfs_create_file("reset", 0600, root_node.dentry,\r\nNULL, &gcov_reset_fops);\r\nif (!reset_dentry)\r\ngoto err_remove;\r\ngcov_enable_events();\r\nreturn 0;\r\nerr_remove:\r\npr_err("init failed\n");\r\nif (root_node.dentry)\r\ndebugfs_remove(root_node.dentry);\r\nreturn rc;\r\n}
