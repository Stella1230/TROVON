static void sh_vou_reg_a_write(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value)\r\n{\r\n__raw_writel(value, vou_dev->base + reg);\r\n}\r\nstatic void sh_vou_reg_ab_write(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value)\r\n{\r\n__raw_writel(value, vou_dev->base + reg);\r\n__raw_writel(value, vou_dev->base + reg + 0x1000);\r\n}\r\nstatic void sh_vou_reg_m_write(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value)\r\n{\r\n__raw_writel(value, vou_dev->base + reg + 0x2000);\r\n}\r\nstatic u32 sh_vou_reg_a_read(struct sh_vou_device *vou_dev, unsigned int reg)\r\n{\r\nreturn __raw_readl(vou_dev->base + reg);\r\n}\r\nstatic void sh_vou_reg_a_set(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value, u32 mask)\r\n{\r\nu32 old = __raw_readl(vou_dev->base + reg);\r\nvalue = (value & mask) | (old & ~mask);\r\n__raw_writel(value, vou_dev->base + reg);\r\n}\r\nstatic void sh_vou_reg_b_set(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value, u32 mask)\r\n{\r\nsh_vou_reg_a_set(vou_dev, reg + 0x1000, value, mask);\r\n}\r\nstatic void sh_vou_reg_ab_set(struct sh_vou_device *vou_dev, unsigned int reg,\r\nu32 value, u32 mask)\r\n{\r\nsh_vou_reg_a_set(vou_dev, reg, value, mask);\r\nsh_vou_reg_b_set(vou_dev, reg, value, mask);\r\n}\r\nstatic void sh_vou_schedule_next(struct sh_vou_device *vou_dev,\r\nstruct videobuf_buffer *vb)\r\n{\r\ndma_addr_t addr1, addr2;\r\naddr1 = videobuf_to_dma_contig(vb);\r\nswitch (vou_dev->pix.pixelformat) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV16:\r\naddr2 = addr1 + vou_dev->pix.width * vou_dev->pix.height;\r\nbreak;\r\ndefault:\r\naddr2 = 0;\r\n}\r\nsh_vou_reg_m_write(vou_dev, VOUAD1R, addr1);\r\nsh_vou_reg_m_write(vou_dev, VOUAD2R, addr2);\r\n}\r\nstatic void sh_vou_stream_start(struct sh_vou_device *vou_dev,\r\nstruct videobuf_buffer *vb)\r\n{\r\nunsigned int row_coeff;\r\n#ifdef __LITTLE_ENDIAN\r\nu32 dataswap = 7;\r\n#else\r\nu32 dataswap = 0;\r\n#endif\r\nswitch (vou_dev->pix.pixelformat) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV16:\r\nrow_coeff = 1;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ndataswap ^= 1;\r\ncase V4L2_PIX_FMT_RGB565X:\r\nrow_coeff = 2;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\nrow_coeff = 3;\r\nbreak;\r\n}\r\nsh_vou_reg_a_write(vou_dev, VOUSWR, dataswap);\r\nsh_vou_reg_ab_write(vou_dev, VOUAIR, vou_dev->pix.width * row_coeff);\r\nsh_vou_schedule_next(vou_dev, vb);\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nBUG_ON(in_interrupt());\r\nvideobuf_waiton(vq, vb, 0, 0);\r\nvideobuf_dma_contig_free(vq, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int sh_vou_buf_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct video_device *vdev = vq->priv_data;\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\n*size = vou_fmt[vou_dev->pix_idx].bpp * vou_dev->pix.width *\r\nvou_dev->pix.height / 8;\r\nif (*count < 2)\r\n*count = 2;\r\nif (PAGE_ALIGN(*size) * *count > 4 * 1024 * 1024)\r\n*count = 4 * 1024 * 1024 / PAGE_ALIGN(*size);\r\ndev_dbg(vq->dev, "%s(): count=%d, size=%d\n", __func__, *count, *size);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_buf_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct video_device *vdev = vq->priv_data;\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nstruct v4l2_pix_format *pix = &vou_dev->pix;\r\nint bytes_per_line = vou_fmt[vou_dev->pix_idx].bpp * pix->width / 8;\r\nint ret;\r\ndev_dbg(vq->dev, "%s()\n", __func__);\r\nif (vb->width != pix->width ||\r\nvb->height != pix->height ||\r\nvb->field != pix->field) {\r\nvb->width = pix->width;\r\nvb->height = pix->height;\r\nvb->field = field;\r\nif (vb->state != VIDEOBUF_NEEDS_INIT)\r\nfree_buffer(vq, vb);\r\n}\r\nvb->size = vb->height * bytes_per_line;\r\nif (vb->baddr && vb->bsize < vb->size) {\r\ndev_warn(vq->dev, "User buffer too small: [%u] @ %lx\n",\r\nvb->bsize, vb->baddr);\r\nreturn -EINVAL;\r\n}\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nret = videobuf_iolock(vq, vb, NULL);\r\nif (ret < 0) {\r\ndev_warn(vq->dev, "IOLOCK buf-type %d: %d\n",\r\nvb->memory, ret);\r\nreturn ret;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\n}\r\ndev_dbg(vq->dev,\r\n"%s(): fmt #%d, %u bytes per line, phys 0x%x, type %d, state %d\n",\r\n__func__, vou_dev->pix_idx, bytes_per_line,\r\nvideobuf_to_dma_contig(vb), vb->memory, vb->state);\r\nreturn 0;\r\n}\r\nstatic void sh_vou_buf_queue(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct video_device *vdev = vq->priv_data;\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\ndev_dbg(vq->dev, "%s()\n", __func__);\r\nvb->state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&vb->queue, &vou_dev->queue);\r\nif (vou_dev->status == SH_VOU_RUNNING) {\r\nreturn;\r\n} else if (!vou_dev->active) {\r\nvou_dev->active = vb;\r\nsh_vou_reg_a_write(vou_dev, VOURPR, 1);\r\ndev_dbg(vq->dev, "%s: first buffer status 0x%x\n", __func__,\r\nsh_vou_reg_a_read(vou_dev, VOUSTR));\r\nsh_vou_schedule_next(vou_dev, vb);\r\n} else if (vou_dev->active->queue.next == &vb->queue) {\r\nsh_vou_reg_a_write(vou_dev, VOURPR, 0);\r\nsh_vou_stream_start(vou_dev, vb);\r\nsh_vou_reg_a_write(vou_dev, VOURCR, 5);\r\ndev_dbg(vq->dev, "%s: second buffer status 0x%x\n", __func__,\r\nsh_vou_reg_a_read(vou_dev, VOUSTR));\r\nsh_vou_reg_a_write(vou_dev, VOUIR, 0x10004);\r\nvou_dev->status = SH_VOU_RUNNING;\r\nsh_vou_reg_a_write(vou_dev, VOUER, 0x107);\r\n}\r\n}\r\nstatic void sh_vou_buf_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct video_device *vdev = vq->priv_data;\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nunsigned long flags;\r\ndev_dbg(vq->dev, "%s()\n", __func__);\r\nspin_lock_irqsave(&vou_dev->lock, flags);\r\nif (vou_dev->active == vb) {\r\nsh_vou_reg_a_set(vou_dev, VOUER, 0, 1);\r\nsh_vou_reg_a_set(vou_dev, VOUIR, 0, 0x30000);\r\nvou_dev->active = NULL;\r\n}\r\nif ((vb->state == VIDEOBUF_ACTIVE || vb->state == VIDEOBUF_QUEUED)) {\r\nvb->state = VIDEOBUF_ERROR;\r\nlist_del(&vb->queue);\r\n}\r\nspin_unlock_irqrestore(&vou_dev->lock, flags);\r\nfree_buffer(vq, vb);\r\n}\r\nstatic int sh_vou_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct sh_vou_file *vou_file = priv;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nstrlcpy(cap->card, "SuperH VOU", sizeof(cap->card));\r\ncap->capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct sh_vou_file *vou_file = priv;\r\nif (fmt->index >= ARRAY_SIZE(vou_fmt))\r\nreturn -EINVAL;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nstrlcpy(fmt->description, vou_fmt[fmt->index].desc,\r\nsizeof(fmt->description));\r\nfmt->pixelformat = vou_fmt[fmt->index].pfmt;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nfmt->fmt.pix = vou_dev->pix;\r\nreturn 0;\r\n}\r\nstatic void sh_vou_configure_geometry(struct sh_vou_device *vou_dev,\r\nint pix_idx, int w_idx, int h_idx)\r\n{\r\nstruct sh_vou_fmt *fmt = vou_fmt + pix_idx;\r\nunsigned int black_left, black_top, width_max, height_max,\r\nframe_in_height, frame_out_height, frame_out_top;\r\nstruct v4l2_rect *rect = &vou_dev->rect;\r\nstruct v4l2_pix_format *pix = &vou_dev->pix;\r\nu32 vouvcr = 0, dsr_h, dsr_v;\r\nif (vou_dev->std & V4L2_STD_525_60) {\r\nwidth_max = 858;\r\nheight_max = 262;\r\n} else {\r\nwidth_max = 864;\r\nheight_max = 312;\r\n}\r\nframe_in_height = pix->height / 2;\r\nframe_out_height = rect->height / 2;\r\nframe_out_top = rect->top / 2;\r\nblack_left = width_max - VOU_MAX_IMAGE_WIDTH;\r\nblack_top = 20;\r\ndsr_h = rect->width + rect->left;\r\ndsr_v = frame_out_height + frame_out_top;\r\ndev_dbg(vou_dev->v4l2_dev.dev,\r\n"image %ux%u, black %u:%u, offset %u:%u, display %ux%u\n",\r\npix->width, frame_in_height, black_left, black_top,\r\nrect->left, frame_out_top, dsr_h, dsr_v);\r\nsh_vou_reg_ab_write(vou_dev, VOUISR, (pix->width << 16) | frame_in_height);\r\nsh_vou_reg_ab_write(vou_dev, VOUVPR, (black_left << 16) | black_top);\r\nsh_vou_reg_ab_write(vou_dev, VOUDPR, (rect->left << 16) | frame_out_top);\r\nsh_vou_reg_ab_write(vou_dev, VOUDSR, (dsr_h << 16) | dsr_v);\r\nif (w_idx)\r\nvouvcr |= (1 << 15) | (vou_scale_h_fld[w_idx - 1] << 4);\r\nif (h_idx)\r\nvouvcr |= (1 << 14) | vou_scale_v_fld[h_idx - 1];\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s: scaling 0x%x\n", fmt->desc, vouvcr);\r\nsh_vou_reg_ab_write(vou_dev, VOUVCR, vouvcr);\r\nsh_vou_reg_ab_write(vou_dev, VOUDFR,\r\nfmt->pkf | (fmt->yf << 8) | (fmt->rgb << 16));\r\n}\r\nstatic void vou_adjust_input(struct sh_vou_geometry *geo, v4l2_std_id std)\r\n{\r\nunsigned int best_err = UINT_MAX, best = 0, img_height_max;\r\nint i, idx = 0;\r\nif (std & V4L2_STD_525_60)\r\nimg_height_max = 480;\r\nelse\r\nimg_height_max = 576;\r\nv4l_bound_align_image(&geo->in_width, 0, VOU_MAX_IMAGE_WIDTH, 2,\r\n&geo->in_height, 0, img_height_max, 1, 0);\r\nfor (i = ARRAY_SIZE(vou_scale_h_num) - 1; i >= 0; i--) {\r\nunsigned int err;\r\nunsigned int found = geo->output.width * vou_scale_h_den[i] /\r\nvou_scale_h_num[i];\r\nif (found > VOU_MAX_IMAGE_WIDTH)\r\nbreak;\r\nerr = abs(found - geo->in_width);\r\nif (err < best_err) {\r\nbest_err = err;\r\nidx = i;\r\nbest = found;\r\n}\r\nif (!err)\r\nbreak;\r\n}\r\ngeo->in_width = best;\r\ngeo->scale_idx_h = idx;\r\nbest_err = UINT_MAX;\r\nfor (i = ARRAY_SIZE(vou_scale_v_num) - 1; i >= 0; i--) {\r\nunsigned int err;\r\nunsigned int found = geo->output.height * vou_scale_v_den[i] /\r\nvou_scale_v_num[i];\r\nif (found > img_height_max)\r\nbreak;\r\nerr = abs(found - geo->in_height);\r\nif (err < best_err) {\r\nbest_err = err;\r\nidx = i;\r\nbest = found;\r\n}\r\nif (!err)\r\nbreak;\r\n}\r\ngeo->in_height = best;\r\ngeo->scale_idx_v = idx;\r\n}\r\nstatic void vou_adjust_output(struct sh_vou_geometry *geo, v4l2_std_id std)\r\n{\r\nunsigned int best_err = UINT_MAX, best, width_max, height_max,\r\nimg_height_max;\r\nint i, idx;\r\nif (std & V4L2_STD_525_60) {\r\nwidth_max = 858;\r\nheight_max = 262 * 2;\r\nimg_height_max = 480;\r\n} else {\r\nwidth_max = 864;\r\nheight_max = 312 * 2;\r\nimg_height_max = 576;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vou_scale_h_num); i++) {\r\nunsigned int err;\r\nunsigned int found = geo->in_width * vou_scale_h_num[i] /\r\nvou_scale_h_den[i];\r\nif (found > VOU_MAX_IMAGE_WIDTH)\r\nbreak;\r\nerr = abs(found - geo->output.width);\r\nif (err < best_err) {\r\nbest_err = err;\r\nidx = i;\r\nbest = found;\r\n}\r\nif (!err)\r\nbreak;\r\n}\r\ngeo->output.width = best;\r\ngeo->scale_idx_h = idx;\r\nif (geo->output.left + best > width_max)\r\ngeo->output.left = width_max - best;\r\npr_debug("%s(): W %u * %u/%u = %u\n", __func__, geo->in_width,\r\nvou_scale_h_num[idx], vou_scale_h_den[idx], best);\r\nbest_err = UINT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(vou_scale_v_num); i++) {\r\nunsigned int err;\r\nunsigned int found = geo->in_height * vou_scale_v_num[i] /\r\nvou_scale_v_den[i];\r\nif (found > img_height_max)\r\nbreak;\r\nerr = abs(found - geo->output.height);\r\nif (err < best_err) {\r\nbest_err = err;\r\nidx = i;\r\nbest = found;\r\n}\r\nif (!err)\r\nbreak;\r\n}\r\ngeo->output.height = best;\r\ngeo->scale_idx_v = idx;\r\nif (geo->output.top + best > height_max)\r\ngeo->output.top = height_max - best;\r\npr_debug("%s(): H %u * %u/%u = %u\n", __func__, geo->in_height,\r\nvou_scale_v_num[idx], vou_scale_v_den[idx], best);\r\n}\r\nstatic int sh_vou_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nunsigned int img_height_max;\r\nint pix_idx;\r\nstruct sh_vou_geometry geo;\r\nstruct v4l2_mbus_framefmt mbfmt = {\r\n.code = V4L2_MBUS_FMT_YUYV8_2X8,\r\n.field = V4L2_FIELD_INTERLACED,\r\n.colorspace = V4L2_COLORSPACE_SMPTE170M,\r\n};\r\nint ret;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s(): %ux%u -> %ux%u\n", __func__,\r\nvou_dev->rect.width, vou_dev->rect.height,\r\npix->width, pix->height);\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = V4L2_FIELD_NONE;\r\nif (fmt->type != V4L2_BUF_TYPE_VIDEO_OUTPUT ||\r\npix->field != V4L2_FIELD_NONE)\r\nreturn -EINVAL;\r\nfor (pix_idx = 0; pix_idx < ARRAY_SIZE(vou_fmt); pix_idx++)\r\nif (vou_fmt[pix_idx].pfmt == pix->pixelformat)\r\nbreak;\r\nif (pix_idx == ARRAY_SIZE(vou_fmt))\r\nreturn -EINVAL;\r\nif (vou_dev->std & V4L2_STD_525_60)\r\nimg_height_max = 480;\r\nelse\r\nimg_height_max = 576;\r\nv4l_bound_align_image(&pix->width, 0, VOU_MAX_IMAGE_WIDTH, 2,\r\n&pix->height, 0, img_height_max, 1, 0);\r\ngeo.in_width = pix->width;\r\ngeo.in_height = pix->height;\r\ngeo.output = vou_dev->rect;\r\nvou_adjust_output(&geo, vou_dev->std);\r\nmbfmt.width = geo.output.width;\r\nmbfmt.height = geo.output.height;\r\nret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, video,\r\ns_mbus_fmt, &mbfmt);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s(): %ux%u -> %ux%u\n", __func__,\r\ngeo.output.width, geo.output.height, mbfmt.width, mbfmt.height);\r\nif ((unsigned)mbfmt.width > VOU_MAX_IMAGE_WIDTH ||\r\n(unsigned)mbfmt.height > img_height_max ||\r\nmbfmt.code != V4L2_MBUS_FMT_YUYV8_2X8)\r\nreturn -EIO;\r\nif (mbfmt.width != geo.output.width ||\r\nmbfmt.height != geo.output.height) {\r\ngeo.output.width = mbfmt.width;\r\ngeo.output.height = mbfmt.height;\r\nvou_adjust_input(&geo, vou_dev->std);\r\n}\r\nvou_dev->rect = geo.output;\r\npix->width = geo.in_width;\r\npix->height = geo.in_height;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s(): %ux%u\n", __func__,\r\npix->width, pix->height);\r\nvou_dev->pix_idx = pix_idx;\r\nvou_dev->pix = *pix;\r\nsh_vou_configure_geometry(vou_dev, pix_idx,\r\ngeo.scale_idx_h, geo.scale_idx_v);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct sh_vou_file *vou_file = priv;\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nint i;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\npix->field = V4L2_FIELD_NONE;\r\nv4l_bound_align_image(&pix->width, 0, VOU_MAX_IMAGE_WIDTH, 1,\r\n&pix->height, 0, VOU_MAX_IMAGE_HEIGHT, 1, 0);\r\nfor (i = 0; ARRAY_SIZE(vou_fmt); i++)\r\nif (vou_fmt[i].pfmt == pix->pixelformat)\r\nreturn 0;\r\npix->pixelformat = vou_fmt[0].pfmt;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nstruct sh_vou_file *vou_file = priv;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nif (req->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nreturn videobuf_reqbufs(&vou_file->vbq, req);\r\n}\r\nstatic int sh_vou_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct sh_vou_file *vou_file = priv;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nreturn videobuf_querybuf(&vou_file->vbq, b);\r\n}\r\nstatic int sh_vou_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct sh_vou_file *vou_file = priv;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nreturn videobuf_qbuf(&vou_file->vbq, b);\r\n}\r\nstatic int sh_vou_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct sh_vou_file *vou_file = priv;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nreturn videobuf_dqbuf(&vou_file->vbq, b, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int sh_vou_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type buftype)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nstruct sh_vou_file *vou_file = priv;\r\nint ret;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0,\r\nvideo, s_stream, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nreturn videobuf_streamon(&vou_file->vbq);\r\n}\r\nstatic int sh_vou_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type buftype)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nstruct sh_vou_file *vou_file = priv;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nvideobuf_streamoff(&vou_file->vbq);\r\nv4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, video, s_stream, 0);\r\nreturn 0;\r\n}\r\nstatic u32 sh_vou_ntsc_mode(enum sh_vou_bus_fmt bus_fmt)\r\n{\r\nswitch (bus_fmt) {\r\ndefault:\r\npr_warning("%s(): Invalid bus-format code %d, using default 8-bit\n",\r\n__func__, bus_fmt);\r\ncase SH_VOU_BUS_8BIT:\r\nreturn 1;\r\ncase SH_VOU_BUS_16BIT:\r\nreturn 0;\r\ncase SH_VOU_BUS_BT656:\r\nreturn 3;\r\n}\r\n}\r\nstatic int sh_vou_s_std(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nint ret;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s(): 0x%llx\n", __func__, *std_id);\r\nif (*std_id & ~vdev->tvnorms)\r\nreturn -EINVAL;\r\nret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, video,\r\ns_std_output, *std_id);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nif (*std_id & V4L2_STD_525_60)\r\nsh_vou_reg_ab_set(vou_dev, VOUCR,\r\nsh_vou_ntsc_mode(vou_dev->pdata->bus_fmt) << 29, 7 << 29);\r\nelse\r\nsh_vou_reg_ab_set(vou_dev, VOUCR, 5 << 29, 7 << 29);\r\nvou_dev->std = *std_id;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\n*std = vou_dev->std;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_g_crop(struct file *file, void *fh, struct v4l2_crop *a)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\na->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\na->c = vou_dev->rect;\r\nreturn 0;\r\n}\r\nstatic int sh_vou_s_crop(struct file *file, void *fh, struct v4l2_crop *a)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nstruct v4l2_rect *rect = &a->c;\r\nstruct v4l2_crop sd_crop = {.type = V4L2_BUF_TYPE_VIDEO_OUTPUT};\r\nstruct v4l2_pix_format *pix = &vou_dev->pix;\r\nstruct sh_vou_geometry geo;\r\nstruct v4l2_mbus_framefmt mbfmt = {\r\n.code = V4L2_MBUS_FMT_YUYV8_2X8,\r\n.field = V4L2_FIELD_INTERLACED,\r\n.colorspace = V4L2_COLORSPACE_SMPTE170M,\r\n};\r\nunsigned int img_height_max;\r\nint ret;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s(): %ux%u@%u:%u\n", __func__,\r\nrect->width, rect->height, rect->left, rect->top);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nif (vou_dev->std & V4L2_STD_525_60)\r\nimg_height_max = 480;\r\nelse\r\nimg_height_max = 576;\r\nv4l_bound_align_image(&rect->width, 0, VOU_MAX_IMAGE_WIDTH, 1,\r\n&rect->height, 0, img_height_max, 1, 0);\r\nif (rect->width + rect->left > VOU_MAX_IMAGE_WIDTH)\r\nrect->left = VOU_MAX_IMAGE_WIDTH - rect->width;\r\nif (rect->height + rect->top > img_height_max)\r\nrect->top = img_height_max - rect->height;\r\ngeo.output = *rect;\r\ngeo.in_width = pix->width;\r\ngeo.in_height = pix->height;\r\nsd_crop.c.width = geo.output.width;\r\nsd_crop.c.height = geo.output.height;\r\nv4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, video,\r\ns_crop, &sd_crop);\r\nmbfmt.width = geo.output.width;\r\nmbfmt.height = geo.output.height;\r\nret = v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, video,\r\ns_mbus_fmt, &mbfmt);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((unsigned)mbfmt.width > VOU_MAX_IMAGE_WIDTH ||\r\n(unsigned)mbfmt.height > img_height_max ||\r\nmbfmt.code != V4L2_MBUS_FMT_YUYV8_2X8)\r\nreturn -EIO;\r\ngeo.output.width = mbfmt.width;\r\ngeo.output.height = mbfmt.height;\r\nvou_adjust_input(&geo, vou_dev->std);\r\nvou_dev->rect = geo.output;\r\npix->width = geo.in_width;\r\npix->height = geo.in_height;\r\nsh_vou_configure_geometry(vou_dev, vou_dev->pix_idx,\r\ngeo.scale_idx_h, geo.scale_idx_v);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *a)\r\n{\r\nstruct sh_vou_file *vou_file = priv;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\na->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\na->bounds.left = 0;\r\na->bounds.top = 0;\r\na->bounds.width = VOU_MAX_IMAGE_WIDTH;\r\na->bounds.height = VOU_MAX_IMAGE_HEIGHT;\r\na->defrect.left = 0;\r\na->defrect.top = 0;\r\na->defrect.width = VOU_MAX_IMAGE_WIDTH;\r\na->defrect.height = VOU_MAX_IMAGE_HEIGHT;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sh_vou_isr(int irq, void *dev_id)\r\n{\r\nstruct sh_vou_device *vou_dev = dev_id;\r\nstatic unsigned long j;\r\nstruct videobuf_buffer *vb;\r\nstatic int cnt;\r\nstatic int side;\r\nu32 irq_status = sh_vou_reg_a_read(vou_dev, VOUIR), masked;\r\nu32 vou_status = sh_vou_reg_a_read(vou_dev, VOUSTR);\r\nif (!(irq_status & 0x300)) {\r\nif (printk_timed_ratelimit(&j, 500))\r\ndev_warn(vou_dev->v4l2_dev.dev, "IRQ status 0x%x!\n",\r\nirq_status);\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock(&vou_dev->lock);\r\nif (!vou_dev->active || list_empty(&vou_dev->queue)) {\r\nif (printk_timed_ratelimit(&j, 500))\r\ndev_warn(vou_dev->v4l2_dev.dev,\r\n"IRQ without active buffer: %x!\n", irq_status);\r\nsh_vou_reg_a_set(vou_dev, VOUIR, 0, 0x300);\r\nspin_unlock(&vou_dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nmasked = ~(0x300 & irq_status) & irq_status & 0x30304;\r\ndev_dbg(vou_dev->v4l2_dev.dev,\r\n"IRQ status 0x%x -> 0x%x, VOU status 0x%x, cnt %d\n",\r\nirq_status, masked, vou_status, cnt);\r\ncnt++;\r\nside = vou_status & 0x10000;\r\nsh_vou_reg_a_write(vou_dev, VOUIR, masked);\r\nvb = vou_dev->active;\r\nlist_del(&vb->queue);\r\nvb->state = VIDEOBUF_DONE;\r\ndo_gettimeofday(&vb->ts);\r\nvb->field_count++;\r\nwake_up(&vb->done);\r\nif (list_empty(&vou_dev->queue)) {\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s: queue empty after %d\n",\r\n__func__, cnt);\r\nsh_vou_reg_a_set(vou_dev, VOUER, 0, 1);\r\nvou_dev->active = NULL;\r\nvou_dev->status = SH_VOU_INITIALISING;\r\nsh_vou_reg_a_set(vou_dev, VOUIR, 0, 0x30000);\r\nspin_unlock(&vou_dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nvou_dev->active = list_entry(vou_dev->queue.next,\r\nstruct videobuf_buffer, queue);\r\nif (vou_dev->active->queue.next != &vou_dev->queue) {\r\nstruct videobuf_buffer *new = list_entry(vou_dev->active->queue.next,\r\nstruct videobuf_buffer, queue);\r\nsh_vou_schedule_next(vou_dev, new);\r\n}\r\nspin_unlock(&vou_dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sh_vou_hw_init(struct sh_vou_device *vou_dev)\r\n{\r\nstruct sh_vou_pdata *pdata = vou_dev->pdata;\r\nu32 voucr = sh_vou_ntsc_mode(pdata->bus_fmt) << 29;\r\nint i = 100;\r\nsh_vou_reg_a_write(vou_dev, VOUIR, 0);\r\nsh_vou_reg_a_write(vou_dev, VOUSRR, 0x101);\r\nwhile (--i && (sh_vou_reg_a_read(vou_dev, VOUSRR) & 0x101))\r\nudelay(1);\r\nif (!i)\r\nreturn -ETIMEDOUT;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "Reset took %dus\n", 100 - i);\r\nif (pdata->flags & SH_VOU_PCLK_FALLING)\r\nvoucr |= 1 << 28;\r\nif (pdata->flags & SH_VOU_HSYNC_LOW)\r\nvoucr |= 1 << 27;\r\nif (pdata->flags & SH_VOU_VSYNC_LOW)\r\nvoucr |= 1 << 26;\r\nsh_vou_reg_ab_set(vou_dev, VOUCR, voucr, 0xfc000000);\r\nsh_vou_reg_a_write(vou_dev, VOURCR, 4);\r\nsh_vou_reg_ab_write(vou_dev, VOUMSR, 0x800000);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nstruct sh_vou_file *vou_file = kzalloc(sizeof(struct sh_vou_file),\r\nGFP_KERNEL);\r\nif (!vou_file)\r\nreturn -ENOMEM;\r\ndev_dbg(vou_dev->v4l2_dev.dev, "%s()\n", __func__);\r\nfile->private_data = vou_file;\r\nif (atomic_inc_return(&vou_dev->use_count) == 1) {\r\nint ret;\r\nvou_dev->status = SH_VOU_INITIALISING;\r\npm_runtime_get_sync(vdev->v4l2_dev->dev);\r\nret = sh_vou_hw_init(vou_dev);\r\nif (ret < 0) {\r\natomic_dec(&vou_dev->use_count);\r\npm_runtime_put(vdev->v4l2_dev->dev);\r\nvou_dev->status = SH_VOU_IDLE;\r\nreturn ret;\r\n}\r\n}\r\nvideobuf_queue_dma_contig_init(&vou_file->vbq, &sh_vou_video_qops,\r\nvou_dev->v4l2_dev.dev, &vou_dev->lock,\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT,\r\nV4L2_FIELD_NONE,\r\nsizeof(struct videobuf_buffer), vdev,\r\n&vou_dev->fop_lock);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_release(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nstruct sh_vou_file *vou_file = file->private_data;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nif (!atomic_dec_return(&vou_dev->use_count)) {\r\nvou_dev->status = SH_VOU_IDLE;\r\nsh_vou_reg_a_set(vou_dev, VOUER, 0, 0x101);\r\npm_runtime_put(vdev->v4l2_dev->dev);\r\n}\r\nfile->private_data = NULL;\r\nkfree(vou_file);\r\nreturn 0;\r\n}\r\nstatic int sh_vou_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct sh_vou_file *vou_file = file->private_data;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nreturn videobuf_mmap_mapper(&vou_file->vbq, vma);\r\n}\r\nstatic unsigned int sh_vou_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct sh_vou_file *vou_file = file->private_data;\r\ndev_dbg(vou_file->vbq.dev, "%s()\n", __func__);\r\nreturn videobuf_poll_stream(file, &vou_file->vbq, wait);\r\n}\r\nstatic int sh_vou_g_chip_ident(struct file *file, void *fh,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nreturn v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, core, g_chip_ident, id);\r\n}\r\nstatic int sh_vou_g_register(struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nreturn v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, core, g_register, reg);\r\n}\r\nstatic int sh_vou_s_register(struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct sh_vou_device *vou_dev = video_get_drvdata(vdev);\r\nreturn v4l2_device_call_until_err(&vou_dev->v4l2_dev, 0, core, s_register, reg);\r\n}\r\nstatic int __devinit sh_vou_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_vou_pdata *vou_pdata = pdev->dev.platform_data;\r\nstruct v4l2_rect *rect;\r\nstruct v4l2_pix_format *pix;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct video_device *vdev;\r\nstruct sh_vou_device *vou_dev;\r\nstruct resource *reg_res, *region;\r\nstruct v4l2_subdev *subdev;\r\nint irq, ret;\r\nreg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!vou_pdata || !reg_res || irq <= 0) {\r\ndev_err(&pdev->dev, "Insufficient VOU platform information.\n");\r\nreturn -ENODEV;\r\n}\r\nvou_dev = kzalloc(sizeof(*vou_dev), GFP_KERNEL);\r\nif (!vou_dev)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&vou_dev->queue);\r\nspin_lock_init(&vou_dev->lock);\r\nmutex_init(&vou_dev->fop_lock);\r\natomic_set(&vou_dev->use_count, 0);\r\nvou_dev->pdata = vou_pdata;\r\nvou_dev->status = SH_VOU_IDLE;\r\nrect = &vou_dev->rect;\r\npix = &vou_dev->pix;\r\nvou_dev->std = sh_vou_video_template.current_norm;\r\nrect->left = 0;\r\nrect->top = 0;\r\nrect->width = VOU_MAX_IMAGE_WIDTH;\r\nrect->height = 480;\r\npix->width = VOU_MAX_IMAGE_WIDTH;\r\npix->height = 480;\r\npix->pixelformat = V4L2_PIX_FMT_YVYU;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = VOU_MAX_IMAGE_WIDTH * 2;\r\npix->sizeimage = VOU_MAX_IMAGE_WIDTH * 2 * 480;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nregion = request_mem_region(reg_res->start, resource_size(reg_res),\r\npdev->name);\r\nif (!region) {\r\ndev_err(&pdev->dev, "VOU region already claimed\n");\r\nret = -EBUSY;\r\ngoto ereqmemreg;\r\n}\r\nvou_dev->base = ioremap(reg_res->start, resource_size(reg_res));\r\nif (!vou_dev->base) {\r\nret = -ENOMEM;\r\ngoto emap;\r\n}\r\nret = request_irq(irq, sh_vou_isr, 0, "vou", vou_dev);\r\nif (ret < 0)\r\ngoto ereqirq;\r\nret = v4l2_device_register(&pdev->dev, &vou_dev->v4l2_dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error registering v4l2 device\n");\r\ngoto ev4l2devreg;\r\n}\r\nvdev = video_device_alloc();\r\nif (vdev == NULL) {\r\nret = -ENOMEM;\r\ngoto evdevalloc;\r\n}\r\n*vdev = sh_vou_video_template;\r\nif (vou_pdata->bus_fmt == SH_VOU_BUS_8BIT)\r\nvdev->tvnorms |= V4L2_STD_PAL;\r\nvdev->v4l2_dev = &vou_dev->v4l2_dev;\r\nvdev->release = video_device_release;\r\nvdev->lock = &vou_dev->fop_lock;\r\nset_bit(V4L2_FL_LOCK_ALL_FOPS, &vdev->flags);\r\nvou_dev->vdev = vdev;\r\nvideo_set_drvdata(vdev, vou_dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_resume(&pdev->dev);\r\ni2c_adap = i2c_get_adapter(vou_pdata->i2c_adap);\r\nif (!i2c_adap) {\r\nret = -ENODEV;\r\ngoto ei2cgadap;\r\n}\r\nret = sh_vou_hw_init(vou_dev);\r\nif (ret < 0)\r\ngoto ereset;\r\nsubdev = v4l2_i2c_new_subdev_board(&vou_dev->v4l2_dev, i2c_adap,\r\nvou_pdata->board_info, NULL);\r\nif (!subdev) {\r\nret = -ENOMEM;\r\ngoto ei2cnd;\r\n}\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0)\r\ngoto evregdev;\r\nreturn 0;\r\nevregdev:\r\nei2cnd:\r\nereset:\r\ni2c_put_adapter(i2c_adap);\r\nei2cgadap:\r\nvideo_device_release(vdev);\r\npm_runtime_disable(&pdev->dev);\r\nevdevalloc:\r\nv4l2_device_unregister(&vou_dev->v4l2_dev);\r\nev4l2devreg:\r\nfree_irq(irq, vou_dev);\r\nereqirq:\r\niounmap(vou_dev->base);\r\nemap:\r\nrelease_mem_region(reg_res->start, resource_size(reg_res));\r\nereqmemreg:\r\nkfree(vou_dev);\r\nreturn ret;\r\n}\r\nstatic int __devexit sh_vou_remove(struct platform_device *pdev)\r\n{\r\nint irq = platform_get_irq(pdev, 0);\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct sh_vou_device *vou_dev = container_of(v4l2_dev,\r\nstruct sh_vou_device, v4l2_dev);\r\nstruct v4l2_subdev *sd = list_entry(v4l2_dev->subdevs.next,\r\nstruct v4l2_subdev, list);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct resource *reg_res;\r\nif (irq > 0)\r\nfree_irq(irq, vou_dev);\r\npm_runtime_disable(&pdev->dev);\r\nvideo_unregister_device(vou_dev->vdev);\r\ni2c_put_adapter(client->adapter);\r\nv4l2_device_unregister(&vou_dev->v4l2_dev);\r\niounmap(vou_dev->base);\r\nreg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (reg_res)\r\nrelease_mem_region(reg_res->start, resource_size(reg_res));\r\nkfree(vou_dev);\r\nreturn 0;\r\n}\r\nstatic int __init sh_vou_init(void)\r\n{\r\nreturn platform_driver_probe(&sh_vou, sh_vou_probe);\r\n}\r\nstatic void __exit sh_vou_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_vou);\r\n}
