static int mcs_set_reg(struct mcs_cb *mcs, __u16 reg, __u16 val)\r\n{\r\nstruct usb_device *dev = mcs->usbdev;\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ,\r\nMCS_WR_RTYPE, val, reg, NULL, 0,\r\nmsecs_to_jiffies(MCS_CTRL_TIMEOUT));\r\n}\r\nstatic int mcs_get_reg(struct mcs_cb *mcs, __u16 reg, __u16 * val)\r\n{\r\nstruct usb_device *dev = mcs->usbdev;\r\nint ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,\r\nMCS_RD_RTYPE, 0, reg, val, 2,\r\nmsecs_to_jiffies(MCS_CTRL_TIMEOUT));\r\nreturn ret;\r\n}\r\nstatic inline int mcs_setup_transceiver_vishay(struct mcs_cb *mcs)\r\n{\r\nint ret = 0;\r\n__u16 rval;\r\nret = mcs_get_reg(mcs, MCS_XCVR_REG, &rval);\r\nif (unlikely(ret != 2)) {\r\nret = -EIO;\r\ngoto error;\r\n}\r\nrval |= (MCS_MODE0 | MCS_XCVR_CONF);\r\nrval &= ~MCS_STFIR;\r\nrval &= ~MCS_MODE1;\r\nret = mcs_set_reg(mcs, MCS_XCVR_REG, rval);\r\nif (unlikely(ret))\r\ngoto error;\r\nrval &= ~MCS_MODE0;\r\nret = mcs_set_reg(mcs, MCS_XCVR_REG, rval);\r\nif (unlikely(ret))\r\ngoto error;\r\nrval &= ~MCS_XCVR_CONF;\r\nret = mcs_set_reg(mcs, MCS_XCVR_REG, rval);\r\nif (unlikely(ret))\r\ngoto error;\r\nret = 0;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic inline int mcs_setup_transceiver_agilent(struct mcs_cb *mcs)\r\n{\r\nIRDA_WARNING("This transceiver type is not supported yet.\n");\r\nreturn 1;\r\n}\r\nstatic inline int mcs_setup_transceiver_sharp(struct mcs_cb *mcs)\r\n{\r\nIRDA_WARNING("This transceiver type is not supported yet.\n");\r\nreturn 1;\r\n}\r\nstatic inline int mcs_setup_transceiver(struct mcs_cb *mcs)\r\n{\r\nint ret = 0;\r\n__u16 rval;\r\nchar *msg;\r\nmsg = "Basic transceiver setup error.";\r\nret = mcs_get_reg(mcs, MCS_MODE_REG, &rval);\r\nif(unlikely(ret != 2))\r\ngoto error;\r\nrval |= MCS_DRIVER;\r\nret = mcs_set_reg(mcs, MCS_MODE_REG, rval);\r\nif(unlikely(ret))\r\ngoto error;\r\nrval = 0;\r\nret = mcs_set_reg(mcs, MCS_MINRXPW_REG, rval);\r\nif(unlikely(ret))\r\ngoto error;\r\nret = mcs_get_reg(mcs, MCS_MODE_REG, &rval);\r\nif(unlikely(ret != 2))\r\ngoto error;\r\nrval &= ~MCS_FIR;\r\nif(mcs->sir_tweak)\r\nrval |= MCS_SIR16US;\r\nelse\r\nrval &= ~MCS_SIR16US;\r\nrval &= ~(MCS_BBTG | MCS_ASK);\r\nrval &= ~MCS_SPEED_MASK;\r\nrval |= MCS_SPEED_9600;\r\nmcs->speed = 9600;\r\nmcs->new_speed = 0;\r\nrval &= ~MCS_PLLPWDN;\r\nrval |= MCS_DTD | MCS_SIPEN;\r\nret = mcs_set_reg(mcs, MCS_MODE_REG, rval);\r\nif(unlikely(ret))\r\ngoto error;\r\nmsg = "transceiver model specific setup error.";\r\nswitch (mcs->transceiver_type) {\r\ncase MCS_TSC_VISHAY:\r\nret = mcs_setup_transceiver_vishay(mcs);\r\nbreak;\r\ncase MCS_TSC_SHARP:\r\nret = mcs_setup_transceiver_sharp(mcs);\r\nbreak;\r\ncase MCS_TSC_AGILENT:\r\nret = mcs_setup_transceiver_agilent(mcs);\r\nbreak;\r\ndefault:\r\nIRDA_WARNING("Unknown transceiver type: %d\n",\r\nmcs->transceiver_type);\r\nret = 1;\r\n}\r\nif (unlikely(ret))\r\ngoto error;\r\nif (mcs->transceiver_type != MCS_TSC_SHARP) {\r\nret = mcs_get_reg(mcs, MCS_XCVR_REG, &rval);\r\nif (unlikely(ret != 2))\r\ngoto error;\r\nif (mcs->receive_mode)\r\nrval |= MCS_RXFAST;\r\nelse\r\nrval &= ~MCS_RXFAST;\r\nret = mcs_set_reg(mcs, MCS_XCVR_REG, rval);\r\nif (unlikely(ret))\r\ngoto error;\r\n}\r\nmsg = "transceiver reset.";\r\nret = mcs_get_reg(mcs, MCS_MODE_REG, &rval);\r\nif (unlikely(ret != 2))\r\ngoto error;\r\nrval &= ~MCS_RESET;\r\nret = mcs_set_reg(mcs, MCS_MODE_REG, rval);\r\nif (unlikely(ret))\r\ngoto error;\r\nelse\r\nreturn ret;\r\nerror:\r\nIRDA_ERROR("%s\n", msg);\r\nreturn ret;\r\n}\r\nstatic inline int mcs_wrap_sir_skb(struct sk_buff *skb, __u8 * buf)\r\n{\r\nint wraplen;\r\nwraplen = async_wrap_skb(skb, buf + 2, 4094);\r\nwraplen += 2;\r\nbuf[0] = wraplen & 0xff;\r\nbuf[1] = (wraplen >> 8) & 0xff;\r\nreturn wraplen;\r\n}\r\nstatic unsigned mcs_wrap_fir_skb(const struct sk_buff *skb, __u8 *buf)\r\n{\r\nunsigned int len = 0;\r\n__u32 fcs = ~(crc32_le(~0, skb->data, skb->len));\r\nlen = skb->len + 6;\r\nbuf[0] = len & 0xff;\r\nbuf[1] = (len >> 8) & 0xff;\r\nskb_copy_from_linear_data(skb, buf + 2, skb->len);\r\nbuf[len - 4] = fcs & 0xff;\r\nbuf[len - 3] = (fcs >> 8) & 0xff;\r\nbuf[len - 2] = (fcs >> 16) & 0xff;\r\nbuf[len - 1] = (fcs >> 24) & 0xff;\r\nreturn len;\r\n}\r\nstatic unsigned mcs_wrap_mir_skb(const struct sk_buff *skb, __u8 *buf)\r\n{\r\n__u16 fcs = 0;\r\nint len = skb->len + 4;\r\nfcs = ~(irda_calc_crc16(~fcs, skb->data, skb->len));\r\nbuf[0] = len & 0xff;\r\nbuf[1] = (len >> 8) & 0xff;\r\nskb_copy_from_linear_data(skb, buf + 2, skb->len);\r\nbuf[len - 2] = fcs & 0xff;\r\nbuf[len - 1] = (fcs >> 8) & 0xff;\r\nreturn len;\r\n}\r\nstatic void mcs_unwrap_mir(struct mcs_cb *mcs, __u8 *buf, int len)\r\n{\r\n__u16 fcs;\r\nint new_len;\r\nstruct sk_buff *skb;\r\nnew_len = len - 2;\r\nif(unlikely(new_len <= 0)) {\r\nIRDA_ERROR("%s short frame length %d\n",\r\nmcs->netdev->name, new_len);\r\n++mcs->netdev->stats.rx_errors;\r\n++mcs->netdev->stats.rx_length_errors;\r\nreturn;\r\n}\r\nfcs = 0;\r\nfcs = irda_calc_crc16(~fcs, buf, len);\r\nif(fcs != GOOD_FCS) {\r\nIRDA_ERROR("crc error calc 0x%x len %d\n",\r\nfcs, new_len);\r\nmcs->netdev->stats.rx_errors++;\r\nmcs->netdev->stats.rx_crc_errors++;\r\nreturn;\r\n}\r\nskb = dev_alloc_skb(new_len + 1);\r\nif(unlikely(!skb)) {\r\n++mcs->netdev->stats.rx_dropped;\r\nreturn;\r\n}\r\nskb_reserve(skb, 1);\r\nskb_copy_to_linear_data(skb, buf, new_len);\r\nskb_put(skb, new_len);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nskb->dev = mcs->netdev;\r\nnetif_rx(skb);\r\nmcs->netdev->stats.rx_packets++;\r\nmcs->netdev->stats.rx_bytes += new_len;\r\n}\r\nstatic void mcs_unwrap_fir(struct mcs_cb *mcs, __u8 *buf, int len)\r\n{\r\n__u32 fcs;\r\nint new_len;\r\nstruct sk_buff *skb;\r\nnew_len = len - 4;\r\nif(unlikely(new_len <= 0)) {\r\nIRDA_ERROR("%s short frame length %d\n",\r\nmcs->netdev->name, new_len);\r\n++mcs->netdev->stats.rx_errors;\r\n++mcs->netdev->stats.rx_length_errors;\r\nreturn;\r\n}\r\nfcs = ~(crc32_le(~0, buf, new_len));\r\nif(fcs != get_unaligned_le32(buf + new_len)) {\r\nIRDA_ERROR("crc error calc 0x%x len %d\n", fcs, new_len);\r\nmcs->netdev->stats.rx_errors++;\r\nmcs->netdev->stats.rx_crc_errors++;\r\nreturn;\r\n}\r\nskb = dev_alloc_skb(new_len + 1);\r\nif(unlikely(!skb)) {\r\n++mcs->netdev->stats.rx_dropped;\r\nreturn;\r\n}\r\nskb_reserve(skb, 1);\r\nskb_copy_to_linear_data(skb, buf, new_len);\r\nskb_put(skb, new_len);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nskb->dev = mcs->netdev;\r\nnetif_rx(skb);\r\nmcs->netdev->stats.rx_packets++;\r\nmcs->netdev->stats.rx_bytes += new_len;\r\n}\r\nstatic inline int mcs_setup_urbs(struct mcs_cb *mcs)\r\n{\r\nmcs->rx_urb = NULL;\r\nmcs->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!mcs->tx_urb)\r\nreturn 0;\r\nmcs->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!mcs->rx_urb)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int mcs_receive_start(struct mcs_cb *mcs)\r\n{\r\nmcs->rx_buff.in_frame = FALSE;\r\nmcs->rx_buff.state = OUTSIDE_FRAME;\r\nusb_fill_bulk_urb(mcs->rx_urb, mcs->usbdev,\r\nusb_rcvbulkpipe(mcs->usbdev, mcs->ep_in),\r\nmcs->in_buf, 4096, mcs_receive_irq, mcs);\r\nmcs->rx_urb->status = 0;\r\nreturn usb_submit_urb(mcs->rx_urb, GFP_KERNEL);\r\n}\r\nstatic inline int mcs_find_endpoints(struct mcs_cb *mcs,\r\nstruct usb_host_endpoint *ep, int epnum)\r\n{\r\nint i;\r\nint ret = 0;\r\nif (!ep)\r\nreturn ret;\r\nfor (i = 0; i < epnum; i++) {\r\nif (ep[i].desc.bEndpointAddress & USB_DIR_IN)\r\nmcs->ep_in = ep[i].desc.bEndpointAddress;\r\nelse\r\nmcs->ep_out = ep[i].desc.bEndpointAddress;\r\nif ((mcs->ep_in != 0) && (mcs->ep_out != 0)) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void mcs_speed_work(struct work_struct *work)\r\n{\r\nstruct mcs_cb *mcs = container_of(work, struct mcs_cb, work);\r\nstruct net_device *netdev = mcs->netdev;\r\nmcs_speed_change(mcs);\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic int mcs_speed_change(struct mcs_cb *mcs)\r\n{\r\nint ret = 0;\r\nint rst = 0;\r\nint cnt = 0;\r\n__u16 nspeed;\r\n__u16 rval;\r\nnspeed = mcs_speed_set[(mcs->new_speed >> 8) & 0x0f];\r\ndo {\r\nmcs_get_reg(mcs, MCS_RESV_REG, &rval);\r\n} while(cnt++ < 100 && (rval & MCS_IRINTX));\r\nif (cnt > 100) {\r\nIRDA_ERROR("unable to change speed\n");\r\nret = -EIO;\r\ngoto error;\r\n}\r\nmcs_get_reg(mcs, MCS_MODE_REG, &rval);\r\nif (mcs->new_speed <= 115200) {\r\nrval &= ~MCS_FIR;\r\nif ((rst = (mcs->speed > 115200)))\r\nmcs_set_reg(mcs, MCS_MINRXPW_REG, 0);\r\n} else if (mcs->new_speed <= 1152000) {\r\nrval &= ~MCS_FIR;\r\nif ((rst = !(mcs->speed == 576000 || mcs->speed == 1152000)))\r\nmcs_set_reg(mcs, MCS_MINRXPW_REG, 5);\r\n} else {\r\nrval |= MCS_FIR;\r\nif ((rst = (mcs->speed != 4000000)))\r\nmcs_set_reg(mcs, MCS_MINRXPW_REG, 5);\r\n}\r\nrval &= ~MCS_SPEED_MASK;\r\nrval |= nspeed;\r\nret = mcs_set_reg(mcs, MCS_MODE_REG, rval);\r\nif (unlikely(ret))\r\ngoto error;\r\nif (rst)\r\nswitch (mcs->transceiver_type) {\r\ncase MCS_TSC_VISHAY:\r\nret = mcs_setup_transceiver_vishay(mcs);\r\nbreak;\r\ncase MCS_TSC_SHARP:\r\nret = mcs_setup_transceiver_sharp(mcs);\r\nbreak;\r\ncase MCS_TSC_AGILENT:\r\nret = mcs_setup_transceiver_agilent(mcs);\r\nbreak;\r\ndefault:\r\nret = 1;\r\nIRDA_WARNING("Unknown transceiver type: %d\n",\r\nmcs->transceiver_type);\r\n}\r\nif (unlikely(ret))\r\ngoto error;\r\nmcs_get_reg(mcs, MCS_MODE_REG, &rval);\r\nrval &= ~MCS_RESET;\r\nret = mcs_set_reg(mcs, MCS_MODE_REG, rval);\r\nmcs->speed = mcs->new_speed;\r\nerror:\r\nmcs->new_speed = 0;\r\nreturn ret;\r\n}\r\nstatic int mcs_net_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\r\n{\r\nint ret = 0;\r\nswitch (cmd) {\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mcs_net_close(struct net_device *netdev)\r\n{\r\nint ret = 0;\r\nstruct mcs_cb *mcs = netdev_priv(netdev);\r\nnetif_stop_queue(netdev);\r\nkfree_skb(mcs->rx_buff.skb);\r\nusb_kill_urb(mcs->rx_urb);\r\nusb_free_urb(mcs->rx_urb);\r\nusb_kill_urb(mcs->tx_urb);\r\nusb_free_urb(mcs->tx_urb);\r\nif (mcs->irlap)\r\nirlap_close(mcs->irlap);\r\nmcs->irlap = NULL;\r\nreturn ret;\r\n}\r\nstatic int mcs_net_open(struct net_device *netdev)\r\n{\r\nstruct mcs_cb *mcs = netdev_priv(netdev);\r\nchar hwname[16];\r\nint ret = 0;\r\nret = usb_clear_halt(mcs->usbdev,\r\nusb_sndbulkpipe(mcs->usbdev, mcs->ep_in));\r\nif (ret)\r\ngoto error1;\r\nret = usb_clear_halt(mcs->usbdev,\r\nusb_rcvbulkpipe(mcs->usbdev, mcs->ep_out));\r\nif (ret)\r\ngoto error1;\r\nret = mcs_setup_transceiver(mcs);\r\nif (ret)\r\ngoto error1;\r\nret = -ENOMEM;\r\nmcs->receiving = 0;\r\nmcs->rx_buff.truesize = IRDA_SKB_MAX_MTU;\r\nmcs->rx_buff.skb = dev_alloc_skb(IRDA_SKB_MAX_MTU);\r\nif (!mcs->rx_buff.skb)\r\ngoto error1;\r\nskb_reserve(mcs->rx_buff.skb, 1);\r\nmcs->rx_buff.head = mcs->rx_buff.skb->data;\r\ndo_gettimeofday(&mcs->rx_time);\r\nsprintf(hwname, "usb#%d", mcs->usbdev->devnum);\r\nmcs->irlap = irlap_open(netdev, &mcs->qos, hwname);\r\nif (!mcs->irlap) {\r\nIRDA_ERROR("mcs7780: irlap_open failed\n");\r\ngoto error2;\r\n}\r\nif (!mcs_setup_urbs(mcs))\r\ngoto error3;\r\nret = mcs_receive_start(mcs);\r\nif (ret)\r\ngoto error3;\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\nerror3:\r\nirlap_close(mcs->irlap);\r\nerror2:\r\nkfree_skb(mcs->rx_buff.skb);\r\nerror1:\r\nreturn ret;\r\n}\r\nstatic void mcs_receive_irq(struct urb *urb)\r\n{\r\n__u8 *bytes;\r\nstruct mcs_cb *mcs = urb->context;\r\nint i;\r\nint ret;\r\nif (!netif_running(mcs->netdev))\r\nreturn;\r\nif (urb->status)\r\nreturn;\r\nif (urb->actual_length > 0) {\r\nbytes = urb->transfer_buffer;\r\nif(mcs->speed < 576000) {\r\nasync_unwrap_char(mcs->netdev, &mcs->netdev->stats,\r\n&mcs->rx_buff, 0xc0);\r\nfor (i = 0; i < urb->actual_length; i++)\r\nasync_unwrap_char(mcs->netdev, &mcs->netdev->stats,\r\n&mcs->rx_buff, bytes[i]);\r\nasync_unwrap_char(mcs->netdev, &mcs->netdev->stats,\r\n&mcs->rx_buff, 0xc1);\r\n}\r\nelse if(mcs->speed == 576000 || mcs->speed == 1152000) {\r\nmcs_unwrap_mir(mcs, urb->transfer_buffer,\r\nurb->actual_length);\r\n}\r\nelse {\r\nmcs_unwrap_fir(mcs, urb->transfer_buffer,\r\nurb->actual_length);\r\n}\r\ndo_gettimeofday(&mcs->rx_time);\r\n}\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic void mcs_send_irq(struct urb *urb)\r\n{\r\nstruct mcs_cb *mcs = urb->context;\r\nstruct net_device *ndev = mcs->netdev;\r\nif (unlikely(mcs->new_speed))\r\nschedule_work(&mcs->work);\r\nelse\r\nnetif_wake_queue(ndev);\r\n}\r\nstatic netdev_tx_t mcs_hard_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nunsigned long flags;\r\nstruct mcs_cb *mcs;\r\nint wraplen;\r\nint ret = 0;\r\nnetif_stop_queue(ndev);\r\nmcs = netdev_priv(ndev);\r\nspin_lock_irqsave(&mcs->lock, flags);\r\nmcs->new_speed = irda_get_next_speed(skb);\r\nif (likely(mcs->new_speed == mcs->speed))\r\nmcs->new_speed = 0;\r\nif(mcs->speed < 576000) {\r\nwraplen = mcs_wrap_sir_skb(skb, mcs->out_buf);\r\n}\r\nelse if(mcs->speed == 576000 || mcs->speed == 1152000) {\r\nwraplen = mcs_wrap_mir_skb(skb, mcs->out_buf);\r\n}\r\nelse {\r\nwraplen = mcs_wrap_fir_skb(skb, mcs->out_buf);\r\n}\r\nusb_fill_bulk_urb(mcs->tx_urb, mcs->usbdev,\r\nusb_sndbulkpipe(mcs->usbdev, mcs->ep_out),\r\nmcs->out_buf, wraplen, mcs_send_irq, mcs);\r\nif ((ret = usb_submit_urb(mcs->tx_urb, GFP_ATOMIC))) {\r\nIRDA_ERROR("failed tx_urb: %d\n", ret);\r\nswitch (ret) {\r\ncase -ENODEV:\r\ncase -EPIPE:\r\nbreak;\r\ndefault:\r\nmcs->netdev->stats.tx_errors++;\r\nnetif_start_queue(ndev);\r\n}\r\n} else {\r\nmcs->netdev->stats.tx_packets++;\r\nmcs->netdev->stats.tx_bytes += skb->len;\r\n}\r\ndev_kfree_skb(skb);\r\nspin_unlock_irqrestore(&mcs->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int mcs_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct net_device *ndev = NULL;\r\nstruct mcs_cb *mcs;\r\nint ret = -ENOMEM;\r\nndev = alloc_irdadev(sizeof(*mcs));\r\nif (!ndev)\r\ngoto error1;\r\nIRDA_DEBUG(1, "MCS7780 USB-IrDA bridge found at %d.\n", udev->devnum);\r\nSET_NETDEV_DEV(ndev, &intf->dev);\r\nret = usb_reset_configuration(udev);\r\nif (ret != 0) {\r\nIRDA_ERROR("mcs7780: usb reset configuration failed\n");\r\ngoto error2;\r\n}\r\nmcs = netdev_priv(ndev);\r\nmcs->usbdev = udev;\r\nmcs->netdev = ndev;\r\nspin_lock_init(&mcs->lock);\r\nirda_init_max_qos_capabilies(&mcs->qos);\r\nmcs->qos.baud_rate.bits &=\r\nIR_2400 | IR_9600 | IR_19200 | IR_38400 | IR_57600 | IR_115200\r\n| IR_576000 | IR_1152000 | (IR_4000000 << 8);\r\nmcs->qos.min_turn_time.bits &= qos_mtt_bits;\r\nirda_qos_bits_to_value(&mcs->qos);\r\nINIT_WORK(&mcs->work, mcs_speed_work);\r\nndev->netdev_ops = &mcs_netdev_ops;\r\nif (!intf->cur_altsetting)\r\ngoto error2;\r\nret = mcs_find_endpoints(mcs, intf->cur_altsetting->endpoint,\r\nintf->cur_altsetting->desc.bNumEndpoints);\r\nif (!ret) {\r\nret = -ENODEV;\r\ngoto error2;\r\n}\r\nret = register_netdev(ndev);\r\nif (ret != 0)\r\ngoto error2;\r\nIRDA_DEBUG(1, "IrDA: Registered MosChip MCS7780 device as %s\n",\r\nndev->name);\r\nmcs->transceiver_type = transceiver_type;\r\nmcs->sir_tweak = sir_tweak;\r\nmcs->receive_mode = receive_mode;\r\nusb_set_intfdata(intf, mcs);\r\nreturn 0;\r\nerror2:\r\nfree_netdev(ndev);\r\nerror1:\r\nreturn ret;\r\n}\r\nstatic void mcs_disconnect(struct usb_interface *intf)\r\n{\r\nstruct mcs_cb *mcs = usb_get_intfdata(intf);\r\nif (!mcs)\r\nreturn;\r\ncancel_work_sync(&mcs->work);\r\nunregister_netdev(mcs->netdev);\r\nfree_netdev(mcs->netdev);\r\nusb_set_intfdata(intf, NULL);\r\nIRDA_DEBUG(0, "MCS7780 now disconnected.\n");\r\n}
