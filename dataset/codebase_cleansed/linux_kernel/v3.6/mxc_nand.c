static void memcpy32_fromio(void *trg, const void __iomem *src, size_t size)\r\n{\r\nint i;\r\nu32 *t = trg;\r\nconst __iomem u32 *s = src;\r\nfor (i = 0; i < (size >> 2); i++)\r\n*t++ = __raw_readl(s++);\r\n}\r\nstatic void memcpy32_toio(void __iomem *trg, const void *src, int size)\r\n{\r\nint i;\r\nu32 __iomem *t = trg;\r\nconst u32 *s = src;\r\nfor (i = 0; i < (size >> 2); i++)\r\n__raw_writel(*s++, t++);\r\n}\r\nstatic int check_int_v3(struct mxc_nand_host *host)\r\n{\r\nuint32_t tmp;\r\ntmp = readl(NFC_V3_IPC);\r\nif (!(tmp & NFC_V3_IPC_INT))\r\nreturn 0;\r\ntmp &= ~NFC_V3_IPC_INT;\r\nwritel(tmp, NFC_V3_IPC);\r\nreturn 1;\r\n}\r\nstatic int check_int_v1_v2(struct mxc_nand_host *host)\r\n{\r\nuint32_t tmp;\r\ntmp = readw(NFC_V1_V2_CONFIG2);\r\nif (!(tmp & NFC_V1_V2_CONFIG2_INT))\r\nreturn 0;\r\nif (!host->devtype_data->irqpending_quirk)\r\nwritew(tmp & ~NFC_V1_V2_CONFIG2_INT, NFC_V1_V2_CONFIG2);\r\nreturn 1;\r\n}\r\nstatic void irq_control_v1_v2(struct mxc_nand_host *host, int activate)\r\n{\r\nuint16_t tmp;\r\ntmp = readw(NFC_V1_V2_CONFIG1);\r\nif (activate)\r\ntmp &= ~NFC_V1_V2_CONFIG1_INT_MSK;\r\nelse\r\ntmp |= NFC_V1_V2_CONFIG1_INT_MSK;\r\nwritew(tmp, NFC_V1_V2_CONFIG1);\r\n}\r\nstatic void irq_control_v3(struct mxc_nand_host *host, int activate)\r\n{\r\nuint32_t tmp;\r\ntmp = readl(NFC_V3_CONFIG2);\r\nif (activate)\r\ntmp &= ~NFC_V3_CONFIG2_INT_MSK;\r\nelse\r\ntmp |= NFC_V3_CONFIG2_INT_MSK;\r\nwritel(tmp, NFC_V3_CONFIG2);\r\n}\r\nstatic void irq_control(struct mxc_nand_host *host, int activate)\r\n{\r\nif (host->devtype_data->irqpending_quirk) {\r\nif (activate)\r\nenable_irq(host->irq);\r\nelse\r\ndisable_irq_nosync(host->irq);\r\n} else {\r\nhost->devtype_data->irq_control(host, activate);\r\n}\r\n}\r\nstatic u32 get_ecc_status_v1(struct mxc_nand_host *host)\r\n{\r\nreturn readw(NFC_V1_V2_ECC_STATUS_RESULT);\r\n}\r\nstatic u32 get_ecc_status_v2(struct mxc_nand_host *host)\r\n{\r\nreturn readl(NFC_V1_V2_ECC_STATUS_RESULT);\r\n}\r\nstatic u32 get_ecc_status_v3(struct mxc_nand_host *host)\r\n{\r\nreturn readl(NFC_V3_ECC_STATUS_RESULT);\r\n}\r\nstatic irqreturn_t mxc_nfc_irq(int irq, void *dev_id)\r\n{\r\nstruct mxc_nand_host *host = dev_id;\r\nif (!host->devtype_data->check_int(host))\r\nreturn IRQ_NONE;\r\nirq_control(host, 0);\r\ncomplete(&host->op_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wait_op_done(struct mxc_nand_host *host, int useirq)\r\n{\r\nint max_retries = 8000;\r\nif (useirq) {\r\nif (!host->devtype_data->check_int(host)) {\r\nINIT_COMPLETION(host->op_completion);\r\nirq_control(host, 1);\r\nwait_for_completion(&host->op_completion);\r\n}\r\n} else {\r\nwhile (max_retries-- > 0) {\r\nif (host->devtype_data->check_int(host))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (max_retries < 0)\r\npr_debug("%s: INT not set\n", __func__);\r\n}\r\n}\r\nstatic void send_cmd_v3(struct mxc_nand_host *host, uint16_t cmd, int useirq)\r\n{\r\nwritel(cmd, NFC_V3_FLASH_CMD);\r\nwritel(NFC_CMD, NFC_V3_LAUNCH);\r\nwait_op_done(host, useirq);\r\n}\r\nstatic void send_cmd_v1_v2(struct mxc_nand_host *host, uint16_t cmd, int useirq)\r\n{\r\npr_debug("send_cmd(host, 0x%x, %d)\n", cmd, useirq);\r\nwritew(cmd, NFC_V1_V2_FLASH_CMD);\r\nwritew(NFC_CMD, NFC_V1_V2_CONFIG2);\r\nif (host->devtype_data->irqpending_quirk && (cmd == NAND_CMD_RESET)) {\r\nint max_retries = 100;\r\nwhile (max_retries-- > 0) {\r\nif (readw(NFC_V1_V2_CONFIG2) == 0) {\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (max_retries < 0)\r\npr_debug("%s: RESET failed\n", __func__);\r\n} else {\r\nwait_op_done(host, useirq);\r\n}\r\n}\r\nstatic void send_addr_v3(struct mxc_nand_host *host, uint16_t addr, int islast)\r\n{\r\nwritel(addr, NFC_V3_FLASH_ADDR0);\r\nwritel(NFC_ADDR, NFC_V3_LAUNCH);\r\nwait_op_done(host, 0);\r\n}\r\nstatic void send_addr_v1_v2(struct mxc_nand_host *host, uint16_t addr, int islast)\r\n{\r\npr_debug("send_addr(host, 0x%x %d)\n", addr, islast);\r\nwritew(addr, NFC_V1_V2_FLASH_ADDR);\r\nwritew(NFC_ADDR, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, islast);\r\n}\r\nstatic void send_page_v3(struct mtd_info *mtd, unsigned int ops)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nuint32_t tmp;\r\ntmp = readl(NFC_V3_CONFIG1);\r\ntmp &= ~(7 << 4);\r\nwritel(tmp, NFC_V3_CONFIG1);\r\nwritel(ops, NFC_V3_LAUNCH);\r\nwait_op_done(host, false);\r\n}\r\nstatic void send_page_v2(struct mtd_info *mtd, unsigned int ops)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nwritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\r\nwritew(ops, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, true);\r\n}\r\nstatic void send_page_v1(struct mtd_info *mtd, unsigned int ops)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nint bufs, i;\r\nif (mtd->writesize > 512)\r\nbufs = 4;\r\nelse\r\nbufs = 1;\r\nfor (i = 0; i < bufs; i++) {\r\nwritew((host->active_cs << 4) | i, NFC_V1_V2_BUF_ADDR);\r\nwritew(ops, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, true);\r\n}\r\n}\r\nstatic void send_read_id_v3(struct mxc_nand_host *host)\r\n{\r\nwritel(NFC_ID, NFC_V3_LAUNCH);\r\nwait_op_done(host, true);\r\nmemcpy32_fromio(host->data_buf, host->main_area0, 16);\r\n}\r\nstatic void send_read_id_v1_v2(struct mxc_nand_host *host)\r\n{\r\nstruct nand_chip *this = &host->nand;\r\nwritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\r\nwritew(NFC_ID, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, true);\r\nmemcpy32_fromio(host->data_buf, host->main_area0, 16);\r\nif (this->options & NAND_BUSWIDTH_16) {\r\nhost->data_buf[1] = host->data_buf[2];\r\nhost->data_buf[2] = host->data_buf[4];\r\nhost->data_buf[3] = host->data_buf[6];\r\nhost->data_buf[4] = host->data_buf[8];\r\nhost->data_buf[5] = host->data_buf[10];\r\n}\r\n}\r\nstatic uint16_t get_dev_status_v3(struct mxc_nand_host *host)\r\n{\r\nwritew(NFC_STATUS, NFC_V3_LAUNCH);\r\nwait_op_done(host, true);\r\nreturn readl(NFC_V3_CONFIG1) >> 16;\r\n}\r\nstatic uint16_t get_dev_status_v1_v2(struct mxc_nand_host *host)\r\n{\r\nvoid __iomem *main_buf = host->main_area0;\r\nuint32_t store;\r\nuint16_t ret;\r\nwritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\r\nstore = readl(main_buf);\r\nwritew(NFC_STATUS, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, true);\r\nret = readw(main_buf);\r\nwritel(store, main_buf);\r\nreturn ret;\r\n}\r\nstatic int mxc_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nreturn 1;\r\n}\r\nstatic void mxc_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\n}\r\nstatic int mxc_nand_correct_data_v1(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nuint16_t ecc_status = get_ecc_status_v1(host);\r\nif (((ecc_status & 0x3) == 2) || ((ecc_status >> 2) == 2)) {\r\npr_debug("MXC_NAND: HWECC uncorrectable 2-bit ECC error\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxc_nand_correct_data_v2_v3(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nu32 ecc_stat, err;\r\nint no_subpages = 1;\r\nint ret = 0;\r\nu8 ecc_bit_mask, err_limit;\r\necc_bit_mask = (host->eccsize == 4) ? 0x7 : 0xf;\r\nerr_limit = (host->eccsize == 4) ? 0x4 : 0x8;\r\nno_subpages = mtd->writesize >> 9;\r\necc_stat = host->devtype_data->get_ecc_status(host);\r\ndo {\r\nerr = ecc_stat & ecc_bit_mask;\r\nif (err > err_limit) {\r\nprintk(KERN_WARNING "UnCorrectable RS-ECC Error\n");\r\nreturn -1;\r\n} else {\r\nret += err;\r\n}\r\necc_stat >>= 4;\r\n} while (--no_subpages);\r\nmtd->ecc_stats.corrected += ret;\r\npr_debug("%d Symbol Correctable RS-ECC Error\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mxc_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nreturn 0;\r\n}\r\nstatic u_char mxc_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nuint8_t ret;\r\nif (host->status_request)\r\nreturn host->devtype_data->get_dev_status(host) & 0xFF;\r\nret = *(uint8_t *)(host->data_buf + host->buf_start);\r\nhost->buf_start++;\r\nreturn ret;\r\n}\r\nstatic uint16_t mxc_nand_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nuint16_t ret;\r\nret = *(uint16_t *)(host->data_buf + host->buf_start);\r\nhost->buf_start += 2;\r\nreturn ret;\r\n}\r\nstatic void mxc_nand_write_buf(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nu16 col = host->buf_start;\r\nint n = mtd->oobsize + mtd->writesize - col;\r\nn = min(n, len);\r\nmemcpy(host->data_buf + col, buf, n);\r\nhost->buf_start += n;\r\n}\r\nstatic void mxc_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nu16 col = host->buf_start;\r\nint n = mtd->oobsize + mtd->writesize - col;\r\nn = min(n, len);\r\nmemcpy(buf, host->data_buf + col, n);\r\nhost->buf_start += n;\r\n}\r\nstatic int mxc_nand_verify_buf(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nreturn -EFAULT;\r\n}\r\nstatic void mxc_nand_select_chip_v1_v3(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nif (chip == -1) {\r\nif (host->clk_act) {\r\nclk_disable_unprepare(host->clk);\r\nhost->clk_act = 0;\r\n}\r\nreturn;\r\n}\r\nif (!host->clk_act) {\r\nclk_prepare_enable(host->clk);\r\nhost->clk_act = 1;\r\n}\r\n}\r\nstatic void mxc_nand_select_chip_v2(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nif (chip == -1) {\r\nif (host->clk_act) {\r\nclk_disable(host->clk);\r\nhost->clk_act = 0;\r\n}\r\nreturn;\r\n}\r\nif (!host->clk_act) {\r\nclk_enable(host->clk);\r\nhost->clk_act = 1;\r\n}\r\nhost->active_cs = chip;\r\nwritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\r\n}\r\nstatic void copy_spare(struct mtd_info *mtd, bool bfrom)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct mxc_nand_host *host = this->priv;\r\nu16 i, j;\r\nu16 n = mtd->writesize >> 9;\r\nu8 *d = host->data_buf + mtd->writesize;\r\nu8 __iomem *s = host->spare0;\r\nu16 t = host->devtype_data->spare_len;\r\nj = (mtd->oobsize / n >> 1) << 1;\r\nif (bfrom) {\r\nfor (i = 0; i < n - 1; i++)\r\nmemcpy32_fromio(d + i * j, s + i * t, j);\r\nmemcpy32_fromio(d + i * j, s + i * t, mtd->oobsize - i * j);\r\n} else {\r\nfor (i = 0; i < n - 1; i++)\r\nmemcpy32_toio(&s[i * t], &d[i * j], j);\r\nmemcpy32_toio(&s[i * t], &d[i * j], mtd->oobsize - i * j);\r\n}\r\n}\r\nstatic void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nif (column != -1) {\r\nhost->devtype_data->send_addr(host, 0, page_addr == -1);\r\nif (mtd->writesize > 512)\r\nhost->devtype_data->send_addr(host, 0, false);\r\n}\r\nif (page_addr != -1) {\r\nhost->devtype_data->send_addr(host, (page_addr & 0xff), false);\r\nif (mtd->writesize > 512) {\r\nif (mtd->size >= 0x10000000) {\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 8) & 0xff,\r\nfalse);\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 16) & 0xff,\r\ntrue);\r\n} else\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 8) & 0xff, true);\r\n} else {\r\nif (mtd->size >= 0x4000000) {\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 8) & 0xff,\r\nfalse);\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 16) & 0xff,\r\ntrue);\r\n} else\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 8) & 0xff, true);\r\n}\r\n}\r\n}\r\nstatic int get_eccsize(struct mtd_info *mtd)\r\n{\r\nint oobbytes_per_512 = 0;\r\noobbytes_per_512 = mtd->oobsize * 512 / mtd->writesize;\r\nif (oobbytes_per_512 < 26)\r\nreturn 4;\r\nelse\r\nreturn 8;\r\n}\r\nstatic void preset_v1(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nuint16_t config1 = 0;\r\nif (nand_chip->ecc.mode == NAND_ECC_HW)\r\nconfig1 |= NFC_V1_V2_CONFIG1_ECC_EN;\r\nif (!host->devtype_data->irqpending_quirk)\r\nconfig1 |= NFC_V1_V2_CONFIG1_INT_MSK;\r\nhost->eccsize = 1;\r\nwritew(config1, NFC_V1_V2_CONFIG1);\r\nwritew(0x2, NFC_V1_V2_CONFIG);\r\nwritew(0x0, NFC_V1_UNLOCKSTART_BLKADDR);\r\nwritew(0xffff, NFC_V1_UNLOCKEND_BLKADDR);\r\nwritew(0x4, NFC_V1_V2_WRPROT);\r\n}\r\nstatic void preset_v2(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\nuint16_t config1 = 0;\r\nif (nand_chip->ecc.mode == NAND_ECC_HW)\r\nconfig1 |= NFC_V1_V2_CONFIG1_ECC_EN;\r\nconfig1 |= NFC_V2_CONFIG1_FP_INT;\r\nif (!host->devtype_data->irqpending_quirk)\r\nconfig1 |= NFC_V1_V2_CONFIG1_INT_MSK;\r\nif (mtd->writesize) {\r\nuint16_t pages_per_block = mtd->erasesize / mtd->writesize;\r\nhost->eccsize = get_eccsize(mtd);\r\nif (host->eccsize == 4)\r\nconfig1 |= NFC_V2_CONFIG1_ECC_MODE_4;\r\nconfig1 |= NFC_V2_CONFIG1_PPB(ffs(pages_per_block) - 6);\r\n} else {\r\nhost->eccsize = 1;\r\n}\r\nwritew(config1, NFC_V1_V2_CONFIG1);\r\nwritew(0x2, NFC_V1_V2_CONFIG);\r\nwritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR0);\r\nwritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR1);\r\nwritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR2);\r\nwritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR3);\r\nwritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR0);\r\nwritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR1);\r\nwritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR2);\r\nwritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR3);\r\nwritew(0x4, NFC_V1_V2_WRPROT);\r\n}\r\nstatic void preset_v3(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct mxc_nand_host *host = chip->priv;\r\nuint32_t config2, config3;\r\nint i, addr_phases;\r\nwritel(NFC_V3_CONFIG1_RBA(0), NFC_V3_CONFIG1);\r\nwritel(NFC_V3_IPC_CREQ, NFC_V3_IPC);\r\nwritel(NFC_V3_WRPROT_BLS_UNLOCK | NFC_V3_WRPROT_UNLOCK,\r\nNFC_V3_WRPROT);\r\nfor (i = 0; i < NAND_MAX_CHIPS; i++)\r\nwritel(0x0 | (0xffff << 16),\r\nNFC_V3_WRPROT_UNLOCK_BLK_ADD0 + (i << 2));\r\nwritel(0, NFC_V3_IPC);\r\nconfig2 = NFC_V3_CONFIG2_ONE_CYCLE |\r\nNFC_V3_CONFIG2_2CMD_PHASES |\r\nNFC_V3_CONFIG2_SPAS(mtd->oobsize >> 1) |\r\nNFC_V3_CONFIG2_ST_CMD(0x70) |\r\nNFC_V3_CONFIG2_INT_MSK |\r\nNFC_V3_CONFIG2_NUM_ADDR_PHASE0;\r\nif (chip->ecc.mode == NAND_ECC_HW)\r\nconfig2 |= NFC_V3_CONFIG2_ECC_EN;\r\naddr_phases = fls(chip->pagemask) >> 3;\r\nif (mtd->writesize == 2048) {\r\nconfig2 |= NFC_V3_CONFIG2_PS_2048;\r\nconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases);\r\n} else if (mtd->writesize == 4096) {\r\nconfig2 |= NFC_V3_CONFIG2_PS_4096;\r\nconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases);\r\n} else {\r\nconfig2 |= NFC_V3_CONFIG2_PS_512;\r\nconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases - 1);\r\n}\r\nif (mtd->writesize) {\r\nconfig2 |= NFC_V3_CONFIG2_PPB(ffs(mtd->erasesize / mtd->writesize) - 6);\r\nhost->eccsize = get_eccsize(mtd);\r\nif (host->eccsize == 8)\r\nconfig2 |= NFC_V3_CONFIG2_ECC_MODE_8;\r\n}\r\nwritel(config2, NFC_V3_CONFIG2);\r\nconfig3 = NFC_V3_CONFIG3_NUM_OF_DEVICES(0) |\r\nNFC_V3_CONFIG3_NO_SDMA |\r\nNFC_V3_CONFIG3_RBB_MODE |\r\nNFC_V3_CONFIG3_SBB(6) |\r\nNFC_V3_CONFIG3_ADD_OP(0);\r\nif (!(chip->options & NAND_BUSWIDTH_16))\r\nconfig3 |= NFC_V3_CONFIG3_FW8;\r\nwritel(config3, NFC_V3_CONFIG3);\r\nwritel(0, NFC_V3_DELAY_LINE);\r\n}\r\nstatic void mxc_nand_command(struct mtd_info *mtd, unsigned command,\r\nint column, int page_addr)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct mxc_nand_host *host = nand_chip->priv;\r\npr_debug("mxc_nand_command (cmd = 0x%x, col = 0x%x, page = 0x%x)\n",\r\ncommand, column, page_addr);\r\nhost->status_request = false;\r\nswitch (command) {\r\ncase NAND_CMD_RESET:\r\nhost->devtype_data->preset(mtd);\r\nhost->devtype_data->send_cmd(host, command, false);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nhost->buf_start = 0;\r\nhost->status_request = true;\r\nhost->devtype_data->send_cmd(host, command, true);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\nif (command == NAND_CMD_READ0)\r\nhost->buf_start = column;\r\nelse\r\nhost->buf_start = column + mtd->writesize;\r\ncommand = NAND_CMD_READ0;\r\nhost->devtype_data->send_cmd(host, command, false);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nif (mtd->writesize > 512)\r\nhost->devtype_data->send_cmd(host,\r\nNAND_CMD_READSTART, true);\r\nhost->devtype_data->send_page(mtd, NFC_OUTPUT);\r\nmemcpy32_fromio(host->data_buf, host->main_area0,\r\nmtd->writesize);\r\ncopy_spare(mtd, true);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nif (column >= mtd->writesize)\r\nmxc_nand_command(mtd, NAND_CMD_READ0, 0, page_addr);\r\nhost->buf_start = column;\r\nhost->devtype_data->send_cmd(host, command, false);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nmemcpy32_toio(host->main_area0, host->data_buf, mtd->writesize);\r\ncopy_spare(mtd, false);\r\nhost->devtype_data->send_page(mtd, NFC_INPUT);\r\nhost->devtype_data->send_cmd(host, command, true);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_READID:\r\nhost->devtype_data->send_cmd(host, command, true);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nhost->devtype_data->send_read_id(host);\r\nhost->buf_start = column;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\nhost->devtype_data->send_cmd(host, command, false);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nbreak;\r\n}\r\n}\r\nstatic int __init mxcnd_probe_dt(struct mxc_nand_host *host)\r\n{\r\nstruct device_node *np = host->dev->of_node;\r\nstruct mxc_nand_platform_data *pdata = &host->pdata;\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxcnd_dt_ids, host->dev);\r\nint buswidth;\r\nif (!np)\r\nreturn 1;\r\nif (of_get_nand_ecc_mode(np) >= 0)\r\npdata->hw_ecc = 1;\r\npdata->flash_bbt = of_get_nand_on_flash_bbt(np);\r\nbuswidth = of_get_nand_bus_width(np);\r\nif (buswidth < 0)\r\nreturn buswidth;\r\npdata->width = buswidth / 8;\r\nhost->devtype_data = of_id->data;\r\nreturn 0;\r\n}\r\nstatic int __init mxcnd_probe_dt(struct mxc_nand_host *host)\r\n{\r\nreturn 1;\r\n}\r\nstatic int __init mxcnd_probe_pdata(struct mxc_nand_host *host)\r\n{\r\nstruct mxc_nand_platform_data *pdata = host->dev->platform_data;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nhost->pdata = *pdata;\r\nif (nfc_is_v1()) {\r\nif (cpu_is_mx21())\r\nhost->devtype_data = &imx21_nand_devtype_data;\r\nelse\r\nhost->devtype_data = &imx27_nand_devtype_data;\r\n} else if (nfc_is_v21()) {\r\nhost->devtype_data = &imx25_nand_devtype_data;\r\n} else if (nfc_is_v3_2()) {\r\nhost->devtype_data = &imx51_nand_devtype_data;\r\n} else\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic int __init mxcnd_probe(struct platform_device *pdev)\r\n{\r\nstruct nand_chip *this;\r\nstruct mtd_info *mtd;\r\nstruct mxc_nand_host *host;\r\nstruct resource *res;\r\nint err = 0;\r\nhost = kzalloc(sizeof(struct mxc_nand_host) + NAND_MAX_PAGESIZE +\r\nNAND_MAX_OOBSIZE, GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->data_buf = (uint8_t *)(host + 1);\r\nhost->dev = &pdev->dev;\r\nthis = &host->nand;\r\nmtd = &host->mtd;\r\nmtd->priv = this;\r\nmtd->owner = THIS_MODULE;\r\nmtd->dev.parent = &pdev->dev;\r\nmtd->name = DRIVER_NAME;\r\nthis->chip_delay = 5;\r\nthis->priv = host;\r\nthis->dev_ready = mxc_nand_dev_ready;\r\nthis->cmdfunc = mxc_nand_command;\r\nthis->read_byte = mxc_nand_read_byte;\r\nthis->read_word = mxc_nand_read_word;\r\nthis->write_buf = mxc_nand_write_buf;\r\nthis->read_buf = mxc_nand_read_buf;\r\nthis->verify_buf = mxc_nand_verify_buf;\r\nhost->clk = clk_get(&pdev->dev, "nfc");\r\nif (IS_ERR(host->clk)) {\r\nerr = PTR_ERR(host->clk);\r\ngoto eclk;\r\n}\r\nclk_prepare_enable(host->clk);\r\nhost->clk_act = 1;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerr = -ENODEV;\r\ngoto eres;\r\n}\r\nhost->base = ioremap(res->start, resource_size(res));\r\nif (!host->base) {\r\nerr = -ENOMEM;\r\ngoto eres;\r\n}\r\nhost->main_area0 = host->base;\r\nerr = mxcnd_probe_dt(host);\r\nif (err > 0)\r\nerr = mxcnd_probe_pdata(host);\r\nif (err < 0)\r\ngoto eirq;\r\nif (host->devtype_data->regs_offset)\r\nhost->regs = host->base + host->devtype_data->regs_offset;\r\nhost->spare0 = host->base + host->devtype_data->spare0_offset;\r\nif (host->devtype_data->axi_offset)\r\nhost->regs_axi = host->base + host->devtype_data->axi_offset;\r\nthis->ecc.bytes = host->devtype_data->eccbytes;\r\nhost->eccsize = host->devtype_data->eccsize;\r\nthis->select_chip = host->devtype_data->select_chip;\r\nthis->ecc.size = 512;\r\nthis->ecc.layout = host->devtype_data->ecclayout_512;\r\nif (host->devtype_data->needs_ip) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\nerr = -ENODEV;\r\ngoto eirq;\r\n}\r\nhost->regs_ip = ioremap(res->start, resource_size(res));\r\nif (!host->regs_ip) {\r\nerr = -ENOMEM;\r\ngoto eirq;\r\n}\r\n}\r\nif (host->pdata.hw_ecc) {\r\nthis->ecc.calculate = mxc_nand_calculate_ecc;\r\nthis->ecc.hwctl = mxc_nand_enable_hwecc;\r\nthis->ecc.correct = host->devtype_data->correct_data;\r\nthis->ecc.mode = NAND_ECC_HW;\r\n} else {\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\n}\r\nif (host->pdata.width == 2)\r\nthis->options |= NAND_BUSWIDTH_16;\r\nif (host->pdata.flash_bbt) {\r\nthis->bbt_td = &bbt_main_descr;\r\nthis->bbt_md = &bbt_mirror_descr;\r\nthis->bbt_options |= NAND_BBT_USE_FLASH;\r\n}\r\ninit_completion(&host->op_completion);\r\nhost->irq = platform_get_irq(pdev, 0);\r\nhost->devtype_data->irq_control(host, 0);\r\nerr = request_irq(host->irq, mxc_nfc_irq, IRQF_DISABLED, DRIVER_NAME, host);\r\nif (err)\r\ngoto eirq;\r\nif (host->devtype_data->irqpending_quirk) {\r\ndisable_irq_nosync(host->irq);\r\nhost->devtype_data->irq_control(host, 1);\r\n}\r\nif (nand_scan_ident(mtd, nfc_is_v21() ? 4 : 1, NULL)) {\r\nerr = -ENXIO;\r\ngoto escan;\r\n}\r\nhost->devtype_data->preset(mtd);\r\nif (mtd->writesize == 2048)\r\nthis->ecc.layout = host->devtype_data->ecclayout_2k;\r\nelse if (mtd->writesize == 4096)\r\nthis->ecc.layout = host->devtype_data->ecclayout_4k;\r\nif (this->ecc.mode == NAND_ECC_HW) {\r\nif (nfc_is_v1())\r\nthis->ecc.strength = 1;\r\nelse\r\nthis->ecc.strength = (host->eccsize == 4) ? 4 : 8;\r\n}\r\nif (nand_scan_tail(mtd)) {\r\nerr = -ENXIO;\r\ngoto escan;\r\n}\r\nmtd_device_parse_register(mtd, part_probes,\r\n&(struct mtd_part_parser_data){\r\n.of_node = pdev->dev.of_node,\r\n},\r\nhost->pdata.parts,\r\nhost->pdata.nr_parts);\r\nplatform_set_drvdata(pdev, host);\r\nreturn 0;\r\nescan:\r\nfree_irq(host->irq, host);\r\neirq:\r\nif (host->regs_ip)\r\niounmap(host->regs_ip);\r\niounmap(host->base);\r\neres:\r\nclk_put(host->clk);\r\neclk:\r\nkfree(host);\r\nreturn err;\r\n}\r\nstatic int __devexit mxcnd_remove(struct platform_device *pdev)\r\n{\r\nstruct mxc_nand_host *host = platform_get_drvdata(pdev);\r\nclk_put(host->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nnand_release(&host->mtd);\r\nfree_irq(host->irq, host);\r\nif (host->regs_ip)\r\niounmap(host->regs_ip);\r\niounmap(host->base);\r\nkfree(host);\r\nreturn 0;\r\n}\r\nstatic int __init mxc_nd_init(void)\r\n{\r\nreturn platform_driver_probe(&mxcnd_driver, mxcnd_probe);\r\n}\r\nstatic void __exit mxc_nd_cleanup(void)\r\n{\r\nplatform_driver_unregister(&mxcnd_driver);\r\n}
