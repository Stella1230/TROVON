s32 pch_gbe_phy_get_id(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_phy_info *phy = &hw->phy;\r\ns32 ret;\r\nu16 phy_id1;\r\nu16 phy_id2;\r\nret = pch_gbe_phy_read_reg_miic(hw, PHY_ID1, &phy_id1);\r\nif (ret)\r\nreturn ret;\r\nret = pch_gbe_phy_read_reg_miic(hw, PHY_ID2, &phy_id2);\r\nif (ret)\r\nreturn ret;\r\nphy->id = (u32)phy_id1;\r\nphy->id = ((phy->id << 6) | ((phy_id2 & 0xFC00) >> 10));\r\nphy->revision = (u32) (phy_id2 & 0x000F);\r\npr_debug("phy->id : 0x%08x phy->revision : 0x%08x\n",\r\nphy->id, phy->revision);\r\nreturn 0;\r\n}\r\ns32 pch_gbe_phy_read_reg_miic(struct pch_gbe_hw *hw, u32 offset, u16 *data)\r\n{\r\nstruct pch_gbe_phy_info *phy = &hw->phy;\r\nif (offset > PHY_MAX_REG_ADDRESS) {\r\npr_err("PHY Address %d is out of range\n", offset);\r\nreturn -EINVAL;\r\n}\r\n*data = pch_gbe_mac_ctrl_miim(hw, phy->addr, PCH_GBE_HAL_MIIM_READ,\r\noffset, (u16)0);\r\nreturn 0;\r\n}\r\ns32 pch_gbe_phy_write_reg_miic(struct pch_gbe_hw *hw, u32 offset, u16 data)\r\n{\r\nstruct pch_gbe_phy_info *phy = &hw->phy;\r\nif (offset > PHY_MAX_REG_ADDRESS) {\r\npr_err("PHY Address %d is out of range\n", offset);\r\nreturn -EINVAL;\r\n}\r\npch_gbe_mac_ctrl_miim(hw, phy->addr, PCH_GBE_HAL_MIIM_WRITE,\r\noffset, data);\r\nreturn 0;\r\n}\r\nvoid pch_gbe_phy_sw_reset(struct pch_gbe_hw *hw)\r\n{\r\nu16 phy_ctrl;\r\npch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &phy_ctrl);\r\nphy_ctrl |= MII_CR_RESET;\r\npch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, phy_ctrl);\r\nudelay(1);\r\n}\r\nvoid pch_gbe_phy_hw_reset(struct pch_gbe_hw *hw)\r\n{\r\npch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, PHY_CONTROL_DEFAULT);\r\npch_gbe_phy_write_reg_miic(hw, PHY_AUTONEG_ADV,\r\nPHY_AUTONEG_ADV_DEFAULT);\r\npch_gbe_phy_write_reg_miic(hw, PHY_NEXT_PAGE_TX,\r\nPHY_NEXT_PAGE_TX_DEFAULT);\r\npch_gbe_phy_write_reg_miic(hw, PHY_1000T_CTRL, PHY_1000T_CTRL_DEFAULT);\r\npch_gbe_phy_write_reg_miic(hw, PHY_PHYSP_CONTROL,\r\nPHY_PHYSP_CONTROL_DEFAULT);\r\n}\r\nvoid pch_gbe_phy_power_up(struct pch_gbe_hw *hw)\r\n{\r\nu16 mii_reg;\r\nmii_reg = 0;\r\npch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &mii_reg);\r\nmii_reg &= ~MII_CR_POWER_DOWN;\r\npch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, mii_reg);\r\n}\r\nvoid pch_gbe_phy_power_down(struct pch_gbe_hw *hw)\r\n{\r\nu16 mii_reg;\r\nmii_reg = 0;\r\npch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &mii_reg);\r\nmii_reg |= MII_CR_POWER_DOWN;\r\npch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, mii_reg);\r\nmdelay(1);\r\n}\r\ninline void pch_gbe_phy_set_rgmii(struct pch_gbe_hw *hw)\r\n{\r\npch_gbe_phy_sw_reset(hw);\r\n}\r\nvoid pch_gbe_phy_init_setting(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_adapter *adapter;\r\nstruct ethtool_cmd cmd = { .cmd = ETHTOOL_GSET };\r\nint ret;\r\nu16 mii_reg;\r\nadapter = container_of(hw, struct pch_gbe_adapter, hw);\r\nret = mii_ethtool_gset(&adapter->mii, &cmd);\r\nif (ret)\r\npr_err("Error: mii_ethtool_gset\n");\r\nethtool_cmd_speed_set(&cmd, hw->mac.link_speed);\r\ncmd.duplex = hw->mac.link_duplex;\r\ncmd.advertising = hw->phy.autoneg_advertised;\r\ncmd.autoneg = hw->mac.autoneg;\r\npch_gbe_phy_write_reg_miic(hw, MII_BMCR, BMCR_RESET);\r\nret = mii_ethtool_sset(&adapter->mii, &cmd);\r\nif (ret)\r\npr_err("Error: mii_ethtool_sset\n");\r\npch_gbe_phy_sw_reset(hw);\r\npch_gbe_phy_read_reg_miic(hw, PHY_PHYSP_CONTROL, &mii_reg);\r\nmii_reg |= PHYSP_CTRL_ASSERT_CRS_TX;\r\npch_gbe_phy_write_reg_miic(hw, PHY_PHYSP_CONTROL, mii_reg);\r\n}
