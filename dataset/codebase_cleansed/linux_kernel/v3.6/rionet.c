static int rionet_rx_clean(struct net_device *ndev)\r\n{\r\nint i;\r\nint error = 0;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nvoid *data;\r\ni = rnet->rx_slot;\r\ndo {\r\nif (!rnet->rx_skb[i])\r\ncontinue;\r\nif (!(data = rio_get_inb_message(rnet->mport, RIONET_MAILBOX)))\r\nbreak;\r\nrnet->rx_skb[i]->data = data;\r\nskb_put(rnet->rx_skb[i], RIO_MAX_MSG_SIZE);\r\nrnet->rx_skb[i]->protocol =\r\neth_type_trans(rnet->rx_skb[i], ndev);\r\nerror = netif_rx(rnet->rx_skb[i]);\r\nif (error == NET_RX_DROP) {\r\nndev->stats.rx_dropped++;\r\n} else {\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += RIO_MAX_MSG_SIZE;\r\n}\r\n} while ((i = (i + 1) % RIONET_RX_RING_SIZE) != rnet->rx_slot);\r\nreturn i;\r\n}\r\nstatic void rionet_rx_fill(struct net_device *ndev, int end)\r\n{\r\nint i;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\ni = rnet->rx_slot;\r\ndo {\r\nrnet->rx_skb[i] = dev_alloc_skb(RIO_MAX_MSG_SIZE);\r\nif (!rnet->rx_skb[i])\r\nbreak;\r\nrio_add_inb_buffer(rnet->mport, RIONET_MAILBOX,\r\nrnet->rx_skb[i]->data);\r\n} while ((i = (i + 1) % RIONET_RX_RING_SIZE) != end);\r\nrnet->rx_slot = i;\r\n}\r\nstatic int rionet_queue_tx_msg(struct sk_buff *skb, struct net_device *ndev,\r\nstruct rio_dev *rdev)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nrio_add_outb_message(rnet->mport, rdev, 0, skb->data, skb->len);\r\nrnet->tx_skb[rnet->tx_slot] = skb;\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += skb->len;\r\nif (++rnet->tx_cnt == RIONET_TX_RING_SIZE)\r\nnetif_stop_queue(ndev);\r\n++rnet->tx_slot;\r\nrnet->tx_slot &= (RIONET_TX_RING_SIZE - 1);\r\nif (netif_msg_tx_queued(rnet))\r\nprintk(KERN_INFO "%s: queued skb len %8.8x\n", DRV_NAME,\r\nskb->len);\r\nreturn 0;\r\n}\r\nstatic int rionet_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nint i;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nstruct ethhdr *eth = (struct ethhdr *)skb->data;\r\nu16 destid;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (!spin_trylock(&rnet->tx_lock)) {\r\nlocal_irq_restore(flags);\r\nreturn NETDEV_TX_LOCKED;\r\n}\r\nif ((rnet->tx_cnt + 1) > RIONET_TX_RING_SIZE) {\r\nnetif_stop_queue(ndev);\r\nspin_unlock_irqrestore(&rnet->tx_lock, flags);\r\nprintk(KERN_ERR "%s: BUG! Tx Ring full when queue awake!\n",\r\nndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (is_multicast_ether_addr(eth->h_dest)) {\r\nfor (i = 0; i < RIO_MAX_ROUTE_ENTRIES(rnet->mport->sys_size);\r\ni++)\r\nif (rionet_active[i])\r\nrionet_queue_tx_msg(skb, ndev,\r\nrionet_active[i]);\r\n} else if (RIONET_MAC_MATCH(eth->h_dest)) {\r\ndestid = RIONET_GET_DESTID(eth->h_dest);\r\nif (rionet_active[destid])\r\nrionet_queue_tx_msg(skb, ndev, rionet_active[destid]);\r\n}\r\nspin_unlock_irqrestore(&rnet->tx_lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void rionet_dbell_event(struct rio_mport *mport, void *dev_id, u16 sid, u16 tid,\r\nu16 info)\r\n{\r\nstruct net_device *ndev = dev_id;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nstruct rionet_peer *peer;\r\nif (netif_msg_intr(rnet))\r\nprintk(KERN_INFO "%s: doorbell sid %4.4x tid %4.4x info %4.4x",\r\nDRV_NAME, sid, tid, info);\r\nif (info == RIONET_DOORBELL_JOIN) {\r\nif (!rionet_active[sid]) {\r\nlist_for_each_entry(peer, &rionet_peers, node) {\r\nif (peer->rdev->destid == sid)\r\nrionet_active[sid] = peer->rdev;\r\n}\r\nrio_mport_send_doorbell(mport, sid,\r\nRIONET_DOORBELL_JOIN);\r\n}\r\n} else if (info == RIONET_DOORBELL_LEAVE) {\r\nrionet_active[sid] = NULL;\r\n} else {\r\nif (netif_msg_intr(rnet))\r\nprintk(KERN_WARNING "%s: unhandled doorbell\n",\r\nDRV_NAME);\r\n}\r\n}\r\nstatic void rionet_inb_msg_event(struct rio_mport *mport, void *dev_id, int mbox, int slot)\r\n{\r\nint n;\r\nstruct net_device *ndev = dev_id;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nif (netif_msg_intr(rnet))\r\nprintk(KERN_INFO "%s: inbound message event, mbox %d slot %d\n",\r\nDRV_NAME, mbox, slot);\r\nspin_lock(&rnet->lock);\r\nif ((n = rionet_rx_clean(ndev)) != rnet->rx_slot)\r\nrionet_rx_fill(ndev, n);\r\nspin_unlock(&rnet->lock);\r\n}\r\nstatic void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbox, int slot)\r\n{\r\nstruct net_device *ndev = dev_id;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nspin_lock(&rnet->lock);\r\nif (netif_msg_intr(rnet))\r\nprintk(KERN_INFO\r\n"%s: outbound message event, mbox %d slot %d\n",\r\nDRV_NAME, mbox, slot);\r\nwhile (rnet->tx_cnt && (rnet->ack_slot != slot)) {\r\ndev_kfree_skb_irq(rnet->tx_skb[rnet->ack_slot]);\r\nrnet->tx_skb[rnet->ack_slot] = NULL;\r\n++rnet->ack_slot;\r\nrnet->ack_slot &= (RIONET_TX_RING_SIZE - 1);\r\nrnet->tx_cnt--;\r\n}\r\nif (rnet->tx_cnt < RIONET_TX_RING_SIZE)\r\nnetif_wake_queue(ndev);\r\nspin_unlock(&rnet->lock);\r\n}\r\nstatic int rionet_open(struct net_device *ndev)\r\n{\r\nint i, rc = 0;\r\nstruct rionet_peer *peer, *tmp;\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nif (netif_msg_ifup(rnet))\r\nprintk(KERN_INFO "%s: open\n", DRV_NAME);\r\nif ((rc = rio_request_inb_dbell(rnet->mport,\r\n(void *)ndev,\r\nRIONET_DOORBELL_JOIN,\r\nRIONET_DOORBELL_LEAVE,\r\nrionet_dbell_event)) < 0)\r\ngoto out;\r\nif ((rc = rio_request_inb_mbox(rnet->mport,\r\n(void *)ndev,\r\nRIONET_MAILBOX,\r\nRIONET_RX_RING_SIZE,\r\nrionet_inb_msg_event)) < 0)\r\ngoto out;\r\nif ((rc = rio_request_outb_mbox(rnet->mport,\r\n(void *)ndev,\r\nRIONET_MAILBOX,\r\nRIONET_TX_RING_SIZE,\r\nrionet_outb_msg_event)) < 0)\r\ngoto out;\r\nfor (i = 0; i < RIONET_RX_RING_SIZE; i++)\r\nrnet->rx_skb[i] = NULL;\r\nrnet->rx_slot = 0;\r\nrionet_rx_fill(ndev, 0);\r\nrnet->tx_slot = 0;\r\nrnet->tx_cnt = 0;\r\nrnet->ack_slot = 0;\r\nnetif_carrier_on(ndev);\r\nnetif_start_queue(ndev);\r\nlist_for_each_entry_safe(peer, tmp, &rionet_peers, node) {\r\nif (!(peer->res = rio_request_outb_dbell(peer->rdev,\r\nRIONET_DOORBELL_JOIN,\r\nRIONET_DOORBELL_LEAVE)))\r\n{\r\nprintk(KERN_ERR "%s: error requesting doorbells\n",\r\nDRV_NAME);\r\ncontinue;\r\n}\r\nrio_send_doorbell(peer->rdev, RIONET_DOORBELL_JOIN);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int rionet_close(struct net_device *ndev)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nstruct rionet_peer *peer, *tmp;\r\nint i;\r\nif (netif_msg_ifup(rnet))\r\nprintk(KERN_INFO "%s: close\n", DRV_NAME);\r\nnetif_stop_queue(ndev);\r\nnetif_carrier_off(ndev);\r\nfor (i = 0; i < RIONET_RX_RING_SIZE; i++)\r\nkfree_skb(rnet->rx_skb[i]);\r\nlist_for_each_entry_safe(peer, tmp, &rionet_peers, node) {\r\nif (rionet_active[peer->rdev->destid]) {\r\nrio_send_doorbell(peer->rdev, RIONET_DOORBELL_LEAVE);\r\nrionet_active[peer->rdev->destid] = NULL;\r\n}\r\nrio_release_outb_dbell(peer->rdev, peer->res);\r\n}\r\nrio_release_inb_dbell(rnet->mport, RIONET_DOORBELL_JOIN,\r\nRIONET_DOORBELL_LEAVE);\r\nrio_release_inb_mbox(rnet->mport, RIONET_MAILBOX);\r\nrio_release_outb_mbox(rnet->mport, RIONET_MAILBOX);\r\nreturn 0;\r\n}\r\nstatic void rionet_remove(struct rio_dev *rdev)\r\n{\r\nstruct net_device *ndev = rio_get_drvdata(rdev);\r\nstruct rionet_peer *peer, *tmp;\r\nfree_pages((unsigned long)rionet_active, get_order(sizeof(void *) *\r\nRIO_MAX_ROUTE_ENTRIES(rdev->net->hport->sys_size)));\r\nunregister_netdev(ndev);\r\nfree_netdev(ndev);\r\nlist_for_each_entry_safe(peer, tmp, &rionet_peers, node) {\r\nlist_del(&peer->node);\r\nkfree(peer);\r\n}\r\n}\r\nstatic void rionet_get_drvinfo(struct net_device *ndev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nstrcpy(info->fw_version, "n/a");\r\nstrcpy(info->bus_info, rnet->mport->name);\r\n}\r\nstatic u32 rionet_get_msglevel(struct net_device *ndev)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nreturn rnet->msg_enable;\r\n}\r\nstatic void rionet_set_msglevel(struct net_device *ndev, u32 value)\r\n{\r\nstruct rionet_private *rnet = netdev_priv(ndev);\r\nrnet->msg_enable = value;\r\n}\r\nstatic int rionet_setup_netdev(struct rio_mport *mport, struct net_device *ndev)\r\n{\r\nint rc = 0;\r\nstruct rionet_private *rnet;\r\nu16 device_id;\r\nconst size_t rionet_active_bytes = sizeof(void *) *\r\nRIO_MAX_ROUTE_ENTRIES(mport->sys_size);\r\nrionet_active = (struct rio_dev **)__get_free_pages(GFP_KERNEL,\r\nget_order(rionet_active_bytes));\r\nif (!rionet_active) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemset((void *)rionet_active, 0, rionet_active_bytes);\r\nrnet = netdev_priv(ndev);\r\nrnet->mport = mport;\r\ndevice_id = rio_local_get_device_id(mport);\r\nndev->dev_addr[0] = 0x00;\r\nndev->dev_addr[1] = 0x01;\r\nndev->dev_addr[2] = 0x00;\r\nndev->dev_addr[3] = 0x01;\r\nndev->dev_addr[4] = device_id >> 8;\r\nndev->dev_addr[5] = device_id & 0xff;\r\nndev->netdev_ops = &rionet_netdev_ops;\r\nndev->mtu = RIO_MAX_MSG_SIZE - 14;\r\nndev->features = NETIF_F_LLTX;\r\nSET_ETHTOOL_OPS(ndev, &rionet_ethtool_ops);\r\nspin_lock_init(&rnet->lock);\r\nspin_lock_init(&rnet->tx_lock);\r\nrnet->msg_enable = RIONET_DEFAULT_MSGLEVEL;\r\nrc = register_netdev(ndev);\r\nif (rc != 0)\r\ngoto out;\r\nprintk("%s: %s %s Version %s, MAC %pM\n",\r\nndev->name,\r\nDRV_NAME,\r\nDRV_DESC,\r\nDRV_VERSION,\r\nndev->dev_addr);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int rionet_probe(struct rio_dev *rdev, const struct rio_device_id *id)\r\n{\r\nint rc = -ENODEV;\r\nu32 lsrc_ops, ldst_ops;\r\nstruct rionet_peer *peer;\r\nstruct net_device *ndev = NULL;\r\nif (!rionet_capable)\r\ngoto out;\r\nndev = alloc_etherdev(sizeof(struct rionet_private));\r\nif (ndev == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (!rionet_check) {\r\nrio_local_read_config_32(rdev->net->hport, RIO_SRC_OPS_CAR,\r\n&lsrc_ops);\r\nrio_local_read_config_32(rdev->net->hport, RIO_DST_OPS_CAR,\r\n&ldst_ops);\r\nif (!is_rionet_capable(lsrc_ops, ldst_ops)) {\r\nprintk(KERN_ERR\r\n"%s: local device is not network capable\n",\r\nDRV_NAME);\r\nrionet_check = 1;\r\nrionet_capable = 0;\r\ngoto out;\r\n}\r\nrc = rionet_setup_netdev(rdev->net->hport, ndev);\r\nrionet_check = 1;\r\n}\r\nif (dev_rionet_capable(rdev)) {\r\nif (!(peer = kmalloc(sizeof(struct rionet_peer), GFP_KERNEL))) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\npeer->rdev = rdev;\r\nlist_add_tail(&peer->node, &rionet_peers);\r\n}\r\nrio_set_drvdata(rdev, ndev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int __init rionet_init(void)\r\n{\r\nreturn rio_register_driver(&rionet_driver);\r\n}\r\nstatic void __exit rionet_exit(void)\r\n{\r\nrio_unregister_driver(&rionet_driver);\r\n}
