static void di_int_enable(struct imxdi_dev *imxdi, u32 intr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdi->irq_lock, flags);\r\n__raw_writel(__raw_readl(imxdi->ioaddr + DIER) | intr,\r\nimxdi->ioaddr + DIER);\r\nspin_unlock_irqrestore(&imxdi->irq_lock, flags);\r\n}\r\nstatic void di_int_disable(struct imxdi_dev *imxdi, u32 intr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&imxdi->irq_lock, flags);\r\n__raw_writel(__raw_readl(imxdi->ioaddr + DIER) & ~intr,\r\nimxdi->ioaddr + DIER);\r\nspin_unlock_irqrestore(&imxdi->irq_lock, flags);\r\n}\r\nstatic void clear_write_error(struct imxdi_dev *imxdi)\r\n{\r\nint cnt;\r\ndev_warn(&imxdi->pdev->dev, "WARNING: Register write error!\n");\r\n__raw_writel(DSR_WEF, imxdi->ioaddr + DSR);\r\nfor (cnt = 0; cnt < 1000; cnt++) {\r\nif ((__raw_readl(imxdi->ioaddr + DSR) & DSR_WEF) == 0)\r\nreturn;\r\nudelay(10);\r\n}\r\ndev_err(&imxdi->pdev->dev,\r\n"ERROR: Cannot clear write-error flag!\n");\r\n}\r\nstatic int di_write_wait(struct imxdi_dev *imxdi, u32 val, int reg)\r\n{\r\nint ret;\r\nint rc = 0;\r\nmutex_lock(&imxdi->write_mutex);\r\ndi_int_enable(imxdi, DIER_WCIE);\r\nimxdi->dsr = 0;\r\n__raw_writel(val, imxdi->ioaddr + reg);\r\nret = wait_event_interruptible_timeout(imxdi->write_wait,\r\nimxdi->dsr & (DSR_WCF | DSR_WEF), msecs_to_jiffies(1));\r\nif (ret < 0) {\r\nrc = ret;\r\ngoto out;\r\n} else if (ret == 0) {\r\ndev_warn(&imxdi->pdev->dev,\r\n"Write-wait timeout "\r\n"val = 0x%08x reg = 0x%08x\n", val, reg);\r\n}\r\nif (imxdi->dsr & DSR_WEF) {\r\nclear_write_error(imxdi);\r\nrc = -EIO;\r\n}\r\nout:\r\nmutex_unlock(&imxdi->write_mutex);\r\nreturn rc;\r\n}\r\nstatic int dryice_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nunsigned long now;\r\nnow = __raw_readl(imxdi->ioaddr + DTCMR);\r\nrtc_time_to_tm(now, tm);\r\nreturn 0;\r\n}\r\nstatic int dryice_rtc_set_mmss(struct device *dev, unsigned long secs)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nint rc;\r\nrc = di_write_wait(imxdi, 0, DTCLR);\r\nif (rc == 0)\r\nrc = di_write_wait(imxdi, secs, DTCMR);\r\nreturn rc;\r\n}\r\nstatic int dryice_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nif (enabled)\r\ndi_int_enable(imxdi, DIER_CAIE);\r\nelse\r\ndi_int_disable(imxdi, DIER_CAIE);\r\nreturn 0;\r\n}\r\nstatic int dryice_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nu32 dcamr;\r\ndcamr = __raw_readl(imxdi->ioaddr + DCAMR);\r\nrtc_time_to_tm(dcamr, &alarm->time);\r\nalarm->enabled = (__raw_readl(imxdi->ioaddr + DIER) & DIER_CAIE) != 0;\r\nmutex_lock(&imxdi->write_mutex);\r\nalarm->pending = (__raw_readl(imxdi->ioaddr + DSR) & DSR_CAF) != 0;\r\nmutex_unlock(&imxdi->write_mutex);\r\nreturn 0;\r\n}\r\nstatic int dryice_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct imxdi_dev *imxdi = dev_get_drvdata(dev);\r\nunsigned long now;\r\nunsigned long alarm_time;\r\nint rc;\r\nrc = rtc_tm_to_time(&alarm->time, &alarm_time);\r\nif (rc)\r\nreturn rc;\r\nnow = __raw_readl(imxdi->ioaddr + DTCMR);\r\nif (alarm_time < now)\r\nreturn -EINVAL;\r\nrc = di_write_wait(imxdi, (u32)alarm_time, DCAMR);\r\nif (rc)\r\nreturn rc;\r\nif (alarm->enabled)\r\ndi_int_enable(imxdi, DIER_CAIE);\r\nelse\r\ndi_int_disable(imxdi, DIER_CAIE);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dryice_norm_irq(int irq, void *dev_id)\r\n{\r\nstruct imxdi_dev *imxdi = dev_id;\r\nu32 dsr, dier;\r\nirqreturn_t rc = IRQ_NONE;\r\ndier = __raw_readl(imxdi->ioaddr + DIER);\r\nif ((dier & DIER_WCIE)) {\r\nif (list_empty_careful(&imxdi->write_wait.task_list))\r\nreturn rc;\r\ndsr = __raw_readl(imxdi->ioaddr + DSR);\r\nif ((dsr & (DSR_WCF | DSR_WEF))) {\r\ndi_int_disable(imxdi, DIER_WCIE);\r\nimxdi->dsr |= dsr;\r\nwake_up_interruptible(&imxdi->write_wait);\r\nrc = IRQ_HANDLED;\r\n}\r\n}\r\nif ((dier & DIER_CAIE)) {\r\ndsr = __raw_readl(imxdi->ioaddr + DSR);\r\nif (dsr & DSR_CAF) {\r\ndi_int_disable(imxdi, DIER_CAIE);\r\nschedule_work(&imxdi->work);\r\nrc = IRQ_HANDLED;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void dryice_work(struct work_struct *work)\r\n{\r\nstruct imxdi_dev *imxdi = container_of(work,\r\nstruct imxdi_dev, work);\r\ndi_write_wait(imxdi, DSR_CAF, DSR);\r\nrtc_update_irq(imxdi->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\nstatic int dryice_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct imxdi_dev *imxdi;\r\nint rc;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nimxdi = devm_kzalloc(&pdev->dev, sizeof(*imxdi), GFP_KERNEL);\r\nif (!imxdi)\r\nreturn -ENOMEM;\r\nimxdi->pdev = pdev;\r\nif (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),\r\npdev->name))\r\nreturn -EBUSY;\r\nimxdi->ioaddr = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (imxdi->ioaddr == NULL)\r\nreturn -ENOMEM;\r\nimxdi->irq = platform_get_irq(pdev, 0);\r\nif (imxdi->irq < 0)\r\nreturn imxdi->irq;\r\ninit_waitqueue_head(&imxdi->write_wait);\r\nINIT_WORK(&imxdi->work, dryice_work);\r\nmutex_init(&imxdi->write_mutex);\r\nimxdi->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(imxdi->clk))\r\nreturn PTR_ERR(imxdi->clk);\r\nclk_prepare_enable(imxdi->clk);\r\n__raw_writel(0, imxdi->ioaddr + DIER);\r\nrc = devm_request_irq(&pdev->dev, imxdi->irq, dryice_norm_irq,\r\nIRQF_SHARED, pdev->name, imxdi);\r\nif (rc) {\r\ndev_warn(&pdev->dev, "interrupt not available.\n");\r\ngoto err;\r\n}\r\nif (__raw_readl(imxdi->ioaddr + DSR) & DSR_NVF) {\r\nrc = di_write_wait(imxdi, DSR_NVF | DSR_SVF, DSR);\r\nif (rc)\r\ngoto err;\r\n}\r\nrc = di_write_wait(imxdi, DCAMR_UNSET, DCAMR);\r\nif (rc)\r\ngoto err;\r\nrc = di_write_wait(imxdi, 0, DCALR);\r\nif (rc)\r\ngoto err;\r\nif (__raw_readl(imxdi->ioaddr + DSR) & DSR_CAF) {\r\nrc = di_write_wait(imxdi, DSR_CAF, DSR);\r\nif (rc)\r\ngoto err;\r\n}\r\nif (__raw_readl(imxdi->ioaddr + DTCMR) == 0) {\r\nrc = di_write_wait(imxdi, 0, DTCMR);\r\nif (rc)\r\ngoto err;\r\n}\r\nif (!(__raw_readl(imxdi->ioaddr + DCR) & DCR_TCE)) {\r\nrc = di_write_wait(imxdi,\r\n__raw_readl(imxdi->ioaddr + DCR) | DCR_TCE,\r\nDCR);\r\nif (rc)\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, imxdi);\r\nimxdi->rtc = rtc_device_register(pdev->name, &pdev->dev,\r\n&dryice_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(imxdi->rtc)) {\r\nrc = PTR_ERR(imxdi->rtc);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nclk_disable_unprepare(imxdi->clk);\r\nclk_put(imxdi->clk);\r\nreturn rc;\r\n}\r\nstatic int __devexit dryice_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct imxdi_dev *imxdi = platform_get_drvdata(pdev);\r\nflush_work(&imxdi->work);\r\n__raw_writel(0, imxdi->ioaddr + DIER);\r\nrtc_device_unregister(imxdi->rtc);\r\nclk_disable_unprepare(imxdi->clk);\r\nclk_put(imxdi->clk);\r\nreturn 0;\r\n}\r\nstatic int __init dryice_rtc_init(void)\r\n{\r\nreturn platform_driver_probe(&dryice_rtc_driver, dryice_rtc_probe);\r\n}\r\nstatic void __exit dryice_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&dryice_rtc_driver);\r\n}
