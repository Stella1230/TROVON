static int tca8418_write_byte(struct tca8418_keypad *keypad_data,\r\nint reg, u8 val)\r\n{\r\nint error;\r\nerror = i2c_smbus_write_byte_data(keypad_data->client, reg, val);\r\nif (error < 0) {\r\ndev_err(&keypad_data->client->dev,\r\n"%s failed, reg: %d, val: %d, error: %d\n",\r\n__func__, reg, val, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tca8418_read_byte(struct tca8418_keypad *keypad_data,\r\nint reg, u8 *val)\r\n{\r\nint error;\r\nerror = i2c_smbus_read_byte_data(keypad_data->client, reg);\r\nif (error < 0) {\r\ndev_err(&keypad_data->client->dev,\r\n"%s failed, reg: %d, error: %d\n",\r\n__func__, reg, error);\r\nreturn error;\r\n}\r\n*val = (u8)error;\r\nreturn 0;\r\n}\r\nstatic void tca8418_read_keypad(struct tca8418_keypad *keypad_data)\r\n{\r\nint error, col, row;\r\nu8 reg, state, code;\r\nerror = tca8418_read_byte(keypad_data, REG_KEY_EVENT_A, &reg);\r\nwhile (error >= 0 && reg > 0) {\r\nstate = reg & KEY_EVENT_VALUE;\r\ncode = reg & KEY_EVENT_CODE;\r\nrow = code / TCA8418_MAX_COLS;\r\ncol = code % TCA8418_MAX_COLS;\r\nrow = (col) ? row : row - 1;\r\ncol = (col) ? col - 1 : TCA8418_MAX_COLS - 1;\r\ncode = MATRIX_SCAN_CODE(row, col, keypad_data->row_shift);\r\ninput_event(keypad_data->input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(keypad_data->input,\r\nkeypad_data->keymap[code], state);\r\nerror = tca8418_read_byte(keypad_data, REG_KEY_EVENT_A, &reg);\r\n}\r\nif (error < 0)\r\ndev_err(&keypad_data->client->dev,\r\n"unable to read REG_KEY_EVENT_A\n");\r\ninput_sync(keypad_data->input);\r\n}\r\nstatic irqreturn_t tca8418_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct tca8418_keypad *keypad_data = dev_id;\r\nu8 reg;\r\nint error;\r\nerror = tca8418_read_byte(keypad_data, REG_INT_STAT, &reg);\r\nif (error) {\r\ndev_err(&keypad_data->client->dev,\r\n"unable to read REG_INT_STAT\n");\r\ngoto exit;\r\n}\r\nif (reg & INT_STAT_OVR_FLOW_INT)\r\ndev_warn(&keypad_data->client->dev, "overflow occurred\n");\r\nif (reg & INT_STAT_K_INT)\r\ntca8418_read_keypad(keypad_data);\r\nexit:\r\nreg = 0xff;\r\nerror = tca8418_write_byte(keypad_data, REG_INT_STAT, reg);\r\nif (error)\r\ndev_err(&keypad_data->client->dev,\r\n"unable to clear REG_INT_STAT\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit tca8418_configure(struct tca8418_keypad *keypad_data)\r\n{\r\nint reg, error;\r\nerror = tca8418_write_byte(keypad_data, REG_CFG,\r\nCFG_INT_CFG | CFG_OVR_FLOW_IEN | CFG_KE_IEN);\r\nif (error < 0)\r\nreturn -ENODEV;\r\nreg = ~(~0 << keypad_data->rows);\r\nreg += (~(~0 << keypad_data->cols)) << 8;\r\nkeypad_data->keypad_mask = reg;\r\nerror |= tca8418_write_byte(keypad_data, REG_KP_GPIO1, reg);\r\nerror |= tca8418_write_byte(keypad_data, REG_KP_GPIO2, reg >> 8);\r\nerror |= tca8418_write_byte(keypad_data, REG_KP_GPIO3, reg >> 16);\r\nerror |= tca8418_write_byte(keypad_data, REG_DEBOUNCE_DIS1, reg);\r\nerror |= tca8418_write_byte(keypad_data, REG_DEBOUNCE_DIS2, reg >> 8);\r\nerror |= tca8418_write_byte(keypad_data, REG_DEBOUNCE_DIS3, reg >> 16);\r\nreturn error;\r\n}\r\nstatic int __devinit tca8418_keypad_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct tca8418_keypad_platform_data *pdata =\r\nclient->dev.platform_data;\r\nstruct tca8418_keypad *keypad_data;\r\nstruct input_dev *input;\r\nint error, row_shift, max_keys;\r\nif (!pdata) {\r\ndev_dbg(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->keymap_data) {\r\ndev_err(&client->dev, "no keymap data defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->rows || pdata->rows > TCA8418_MAX_ROWS) {\r\ndev_err(&client->dev, "invalid rows\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->cols || pdata->cols > TCA8418_MAX_COLS) {\r\ndev_err(&client->dev, "invalid columns\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {\r\ndev_err(&client->dev, "%s adapter not supported\n",\r\ndev_driver_string(&client->adapter->dev));\r\nreturn -ENODEV;\r\n}\r\nrow_shift = get_count_order(pdata->cols);\r\nmax_keys = pdata->rows << row_shift;\r\nkeypad_data = kzalloc(sizeof(*keypad_data) +\r\nmax_keys * sizeof(keypad_data->keymap[0]), GFP_KERNEL);\r\nif (!keypad_data)\r\nreturn -ENOMEM;\r\nkeypad_data->rows = pdata->rows;\r\nkeypad_data->cols = pdata->cols;\r\nkeypad_data->client = client;\r\nkeypad_data->row_shift = row_shift;\r\nerror = tca8418_configure(keypad_data);\r\nif (error < 0)\r\ngoto fail1;\r\ninput = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nkeypad_data->input = input;\r\ninput->name = client->name;\r\ninput->dev.parent = &client->dev;\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x001;\r\ninput->id.version = 0x0001;\r\nerror = matrix_keypad_build_keymap(pdata->keymap_data, NULL,\r\npdata->rows, pdata->cols,\r\nkeypad_data->keymap, input);\r\nif (error) {\r\ndev_dbg(&client->dev, "Failed to build keymap\n");\r\ngoto fail2;\r\n}\r\nif (pdata->rep)\r\n__set_bit(EV_REP, input->evbit);\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(input, keypad_data);\r\nif (pdata->irq_is_gpio)\r\nclient->irq = gpio_to_irq(client->irq);\r\nerror = request_threaded_irq(client->irq, NULL, tca8418_irq_handler,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nclient->name, keypad_data);\r\nif (error) {\r\ndev_dbg(&client->dev,\r\n"Unable to claim irq %d; error %d\n",\r\nclient->irq, error);\r\ngoto fail2;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_dbg(&client->dev,\r\n"Unable to register input device, error: %d\n", error);\r\ngoto fail3;\r\n}\r\ni2c_set_clientdata(client, keypad_data);\r\nreturn 0;\r\nfail3:\r\nfree_irq(client->irq, keypad_data);\r\nfail2:\r\ninput_free_device(input);\r\nfail1:\r\nkfree(keypad_data);\r\nreturn error;\r\n}\r\nstatic int __devexit tca8418_keypad_remove(struct i2c_client *client)\r\n{\r\nstruct tca8418_keypad *keypad_data = i2c_get_clientdata(client);\r\nfree_irq(keypad_data->client->irq, keypad_data);\r\ninput_unregister_device(keypad_data->input);\r\nkfree(keypad_data);\r\nreturn 0;\r\n}\r\nstatic int __init tca8418_keypad_init(void)\r\n{\r\nreturn i2c_add_driver(&tca8418_keypad_driver);\r\n}\r\nstatic void __exit tca8418_keypad_exit(void)\r\n{\r\ni2c_del_driver(&tca8418_keypad_driver);\r\n}
