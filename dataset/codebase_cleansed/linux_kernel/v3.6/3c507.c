struct net_device * __init el16_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nstatic const unsigned ports[] = { 0x300, 0x320, 0x340, 0x280, 0};\r\nconst unsigned *port;\r\nint err = -ENODEV;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio = dev->base_addr;\r\nirq = dev->irq;\r\nmem_start = dev->mem_start & 15;\r\n}\r\nif (io > 0x1ff)\r\nerr = el16_probe1(dev, io);\r\nelse if (io != 0)\r\nerr = -ENXIO;\r\nelse {\r\nfor (port = ports; *port; port++) {\r\nerr = el16_probe1(dev, *port);\r\nif (!err)\r\nbreak;\r\n}\r\n}\r\nif (err)\r\ngoto out;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out1;\r\nreturn dev;\r\nout1:\r\nfree_irq(dev->irq, dev);\r\niounmap(((struct net_local *)netdev_priv(dev))->base);\r\nrelease_region(dev->base_addr, EL16_IO_EXTENT);\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init el16_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nstatic unsigned char init_ID_done;\r\nint i, irq, irqval, retval;\r\nstruct net_local *lp;\r\nif (init_ID_done == 0) {\r\nushort lrs_state = 0xff;\r\noutb(0x00, ID_PORT);\r\nfor(i = 0; i < 255; i++) {\r\noutb(lrs_state, ID_PORT);\r\nlrs_state <<= 1;\r\nif (lrs_state & 0x100)\r\nlrs_state ^= 0xe7;\r\n}\r\noutb(0x00, ID_PORT);\r\ninit_ID_done = 1;\r\n}\r\nif (!request_region(ioaddr, EL16_IO_EXTENT, DRV_NAME))\r\nreturn -ENODEV;\r\nif ((inb(ioaddr) != '*') || (inb(ioaddr + 1) != '3') ||\r\n(inb(ioaddr + 2) != 'C') || (inb(ioaddr + 3) != 'O')) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\npr_info("%s: 3c507 at %#x,", dev->name, ioaddr);\r\nirq = inb(ioaddr + IRQ_CONFIG) & 0x0f;\r\nirqval = request_irq(irq, el16_interrupt, 0, DRV_NAME, dev);\r\nif (irqval) {\r\npr_cont("\n");\r\npr_err("3c507: unable to get IRQ %d (irqval=%d).\n", irq, irqval);\r\nretval = -EAGAIN;\r\ngoto out;\r\n}\r\ndev->base_addr = ioaddr;\r\noutb(0x01, ioaddr + MISC_CTRL);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + i);\r\npr_cont(" %pM", dev->dev_addr);\r\nif (mem_start)\r\nnet_debug = mem_start & 7;\r\n#ifdef MEM_BASE\r\ndev->mem_start = MEM_BASE;\r\ndev->mem_end = dev->mem_start + 0x10000;\r\n#else\r\n{\r\nint base;\r\nint size;\r\nchar mem_config = inb(ioaddr + MEM_CONFIG);\r\nif (mem_config & 0x20) {\r\nsize = 64*1024;\r\nbase = 0xf00000 + (mem_config & 0x08 ? 0x080000\r\n: ((mem_config & 3) << 17));\r\n} else {\r\nsize = ((mem_config & 3) + 1) << 14;\r\nbase = 0x0c0000 + ( (mem_config & 0x18) << 12);\r\n}\r\ndev->mem_start = base;\r\ndev->mem_end = base + size;\r\n}\r\n#endif\r\ndev->if_port = (inb(ioaddr + ROM_CONFIG) & 0x80) ? 1 : 0;\r\ndev->irq = inb(ioaddr + IRQ_CONFIG) & 0x0f;\r\npr_cont(", IRQ %d, %sternal xcvr, memory %#lx-%#lx.\n", dev->irq,\r\ndev->if_port ? "ex" : "in", dev->mem_start, dev->mem_end-1);\r\nif (net_debug)\r\npr_debug("%s", version);\r\nlp = netdev_priv(dev);\r\nspin_lock_init(&lp->lock);\r\nlp->base = ioremap(dev->mem_start, RX_BUF_END);\r\nif (!lp->base) {\r\npr_err("3c507: unable to remap memory\n");\r\nretval = -EAGAIN;\r\ngoto out1;\r\n}\r\ndev->netdev_ops = &netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\ndev->flags &= ~IFF_MULTICAST;\r\nreturn 0;\r\nout1:\r\nfree_irq(dev->irq, dev);\r\nout:\r\nrelease_region(ioaddr, EL16_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic int el16_open(struct net_device *dev)\r\n{\r\ninit_82586_mem(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void el16_tx_timeout (struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nvoid __iomem *shmem = lp->base;\r\nif (net_debug > 1)\r\npr_debug("%s: transmit timed out, %s? ", dev->name,\r\nreadw(shmem + iSCB_STATUS) & 0x8000 ? "IRQ conflict" :\r\n"network cable problem");\r\nif (lp->last_restart == dev->stats.tx_packets) {\r\nif (net_debug > 1)\r\npr_cont("Resetting board.\n");\r\ninit_82586_mem (dev);\r\nlp->tx_pkts_in_ring = 0;\r\n} else {\r\nif (net_debug > 1)\r\npr_cont("Kicking board.\n");\r\nwritew(0xf000 | CUC_START | RX_START, shmem + iSCB_CMD);\r\noutb (0, ioaddr + SIGNAL_CA);\r\nlp->last_restart = dev->stats.tx_packets;\r\n}\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue (dev);\r\n}\r\nstatic netdev_tx_t el16_send_packet (struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nshort length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nunsigned char *buf = skb->data;\r\nnetif_stop_queue (dev);\r\nspin_lock_irqsave (&lp->lock, flags);\r\ndev->stats.tx_bytes += length;\r\noutb (0x80, ioaddr + MISC_CTRL);\r\nhardware_send_packet (dev, buf, skb->len, length - skb->len);\r\noutb (0x84, ioaddr + MISC_CTRL);\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\ndev_kfree_skb (skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t el16_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *lp;\r\nint ioaddr, status, boguscount = 0;\r\nushort ack_cmd = 0;\r\nvoid __iomem *shmem;\r\nif (dev == NULL) {\r\npr_err("net_interrupt(): irq %d for unknown device.\n", irq);\r\nreturn IRQ_NONE;\r\n}\r\nioaddr = dev->base_addr;\r\nlp = netdev_priv(dev);\r\nshmem = lp->base;\r\nspin_lock(&lp->lock);\r\nstatus = readw(shmem+iSCB_STATUS);\r\nif (net_debug > 4) {\r\npr_debug("%s: 3c507 interrupt, status %4.4x.\n", dev->name, status);\r\n}\r\noutb(0x80, ioaddr + MISC_CTRL);\r\nwhile (lp->tx_pkts_in_ring) {\r\nunsigned short tx_status = readw(shmem+lp->tx_reap);\r\nif (!(tx_status & 0x8000)) {\r\nif (net_debug > 5)\r\npr_debug("Tx command incomplete (%#x).\n", lp->tx_reap);\r\nbreak;\r\n}\r\nif (!(tx_status & 0x2000) || (tx_status & 0x0f3f)) {\r\ndev->stats.tx_errors++;\r\nif (tx_status & 0x0600) dev->stats.tx_carrier_errors++;\r\nif (tx_status & 0x0100) dev->stats.tx_fifo_errors++;\r\nif (!(tx_status & 0x0040)) dev->stats.tx_heartbeat_errors++;\r\nif (tx_status & 0x0020) dev->stats.tx_aborted_errors++;\r\ndev->stats.collisions += tx_status & 0xf;\r\n}\r\ndev->stats.tx_packets++;\r\nif (net_debug > 5)\r\npr_debug("Reaped %x, Tx status %04x.\n" , lp->tx_reap, tx_status);\r\nlp->tx_reap += TX_BUF_SIZE;\r\nif (lp->tx_reap > RX_BUF_START - TX_BUF_SIZE)\r\nlp->tx_reap = TX_BUF_START;\r\nlp->tx_pkts_in_ring--;\r\nnetif_wake_queue(dev);\r\nif (++boguscount > 10)\r\nbreak;\r\n}\r\nif (status & 0x4000) {\r\nif (net_debug > 5)\r\npr_debug("Received packet, rx_head %04x.\n", lp->rx_head);\r\nel16_rx(dev);\r\n}\r\nack_cmd = status & 0xf000;\r\nif ((status & 0x0700) != 0x0200 && netif_running(dev)) {\r\nif (net_debug)\r\npr_debug("%s: Command unit stopped, status %04x, restarting.\n",\r\ndev->name, status);\r\nack_cmd |= CUC_RESUME;\r\n}\r\nif ((status & 0x0070) != 0x0040 && netif_running(dev)) {\r\nif (net_debug)\r\npr_debug("%s: Rx unit stopped, status %04x, restarting.\n",\r\ndev->name, status);\r\ninit_rx_bufs(dev);\r\nwritew(RX_BUF_START,shmem+iSCB_RFA);\r\nack_cmd |= RX_START;\r\n}\r\nwritew(ack_cmd,shmem+iSCB_CMD);\r\noutb(0, ioaddr + SIGNAL_CA);\r\noutb(0, ioaddr + RESET_IRQ);\r\noutb(0x84, ioaddr + MISC_CTRL);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int el16_close(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ioaddr = dev->base_addr;\r\nvoid __iomem *shmem = lp->base;\r\nnetif_stop_queue(dev);\r\nwritew(RX_SUSPEND | CUC_SUSPEND,shmem+iSCB_CMD);\r\noutb(0, ioaddr + SIGNAL_CA);\r\noutb(0x80, ioaddr + MISC_CTRL);\r\nreturn 0;\r\n}\r\nstatic void init_rx_bufs(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nvoid __iomem *write_ptr;\r\nunsigned short SCB_base = SCB_BASE;\r\nint cur_rxbuf = lp->rx_head = RX_BUF_START;\r\ndo {\r\nwrite_ptr = lp->base + cur_rxbuf;\r\nwritew(0x0000,write_ptr);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(cur_rxbuf + RX_BUF_SIZE,write_ptr+=2);\r\nwritew(cur_rxbuf + 22,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(-1,write_ptr+=2);\r\nwritew(cur_rxbuf + 0x20 + SCB_base,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x8000 + RX_BUF_SIZE-0x20,write_ptr+=2);\r\nlp->rx_tail = cur_rxbuf;\r\ncur_rxbuf += RX_BUF_SIZE;\r\n} while (cur_rxbuf <= RX_BUF_END - RX_BUF_SIZE);\r\nwrite_ptr = lp->base + lp->rx_tail + 2;\r\nwritew(0xC000,write_ptr);\r\nwritew(lp->rx_head,write_ptr+2);\r\n}\r\nstatic void init_82586_mem(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nshort ioaddr = dev->base_addr;\r\nvoid __iomem *shmem = lp->base;\r\noutb(0x20, ioaddr + MISC_CTRL);\r\ninit_words[3] = SCB_BASE;\r\ninit_words[7] = SCB_BASE;\r\nmemcpy_toio(lp->base + RX_BUF_END - 10, init_words, 10);\r\nmemcpy_toio(lp->base, init_words + 5, sizeof(init_words) - 10);\r\nmemcpy_toio(lp->base+SA_OFFSET, dev->dev_addr, ETH_ALEN);\r\nlp->tx_cmd_link = IDLELOOP + 4;\r\nlp->tx_head = lp->tx_reap = TX_BUF_START;\r\ninit_rx_bufs(dev);\r\noutb(0xA0, ioaddr + MISC_CTRL);\r\noutb(0, ioaddr + SIGNAL_CA);\r\n{\r\nint boguscnt = 50;\r\nwhile (readw(shmem+iSCB_STATUS) == 0)\r\nif (--boguscnt == 0) {\r\npr_warning("%s: i82586 initialization timed out with status %04x, cmd %04x.\n",\r\ndev->name, readw(shmem+iSCB_STATUS), readw(shmem+iSCB_CMD));\r\nbreak;\r\n}\r\noutb(0, ioaddr + SIGNAL_CA);\r\n}\r\noutb(0x84, ioaddr + MISC_CTRL);\r\nif (net_debug > 4)\r\npr_debug("%s: Initialized 82586, status %04x.\n", dev->name,\r\nreadw(shmem+iSCB_STATUS));\r\n}\r\nstatic void hardware_send_packet(struct net_device *dev, void *buf, short length, short pad)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nshort ioaddr = dev->base_addr;\r\nushort tx_block = lp->tx_head;\r\nvoid __iomem *write_ptr = lp->base + tx_block;\r\nstatic char padding[ETH_ZLEN];\r\nwritew(0x0000,write_ptr);\r\nwritew(CMD_INTR|CmdTx,write_ptr+=2);\r\nwritew(tx_block+16,write_ptr+=2);\r\nwritew(tx_block+8,write_ptr+=2);\r\nwritew((pad + length) | 0x8000,write_ptr+=2);\r\nwritew(-1,write_ptr+=2);\r\nwritew(tx_block+22+SCB_BASE,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(0x0000,write_ptr+=2);\r\nwritew(CmdNOp,write_ptr+=2);\r\nwritew(tx_block+16,write_ptr+=2);\r\nmemcpy_toio(write_ptr+2, buf, length);\r\nif (pad)\r\nmemcpy_toio(write_ptr+length+2, padding, pad);\r\nwritew(tx_block,lp->base + lp->tx_cmd_link);\r\nlp->tx_cmd_link = tx_block + 20;\r\nlp->tx_head = tx_block + TX_BUF_SIZE;\r\nif (lp->tx_head > RX_BUF_START - TX_BUF_SIZE)\r\nlp->tx_head = TX_BUF_START;\r\nif (net_debug > 4) {\r\npr_debug("%s: 3c507 @%x send length = %d, tx_block %3x, next %3x.\n",\r\ndev->name, ioaddr, length, tx_block, lp->tx_head);\r\n}\r\nif (++lp->tx_pkts_in_ring < NUM_TX_BUFS)\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void el16_rx(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nvoid __iomem *shmem = lp->base;\r\nushort rx_head = lp->rx_head;\r\nushort rx_tail = lp->rx_tail;\r\nushort boguscount = 10;\r\nshort frame_status;\r\nwhile ((frame_status = readw(shmem+rx_head)) < 0) {\r\nvoid __iomem *read_frame = lp->base + rx_head;\r\nushort rfd_cmd = readw(read_frame+2);\r\nushort next_rx_frame = readw(read_frame+4);\r\nushort data_buffer_addr = readw(read_frame+6);\r\nvoid __iomem *data_frame = lp->base + data_buffer_addr;\r\nushort pkt_len = readw(data_frame);\r\nif (rfd_cmd != 0 || data_buffer_addr != rx_head + 22 ||\r\n(pkt_len & 0xC000) != 0xC000) {\r\npr_err("%s: Rx frame at %#x corrupted, "\r\n"status %04x cmd %04x next %04x "\r\n"data-buf @%04x %04x.\n",\r\ndev->name, rx_head, frame_status, rfd_cmd,\r\nnext_rx_frame, data_buffer_addr, pkt_len);\r\n} else if ((frame_status & 0x2000) == 0) {\r\ndev->stats.rx_errors++;\r\nif (frame_status & 0x0800) dev->stats.rx_crc_errors++;\r\nif (frame_status & 0x0400) dev->stats.rx_frame_errors++;\r\nif (frame_status & 0x0200) dev->stats.rx_fifo_errors++;\r\nif (frame_status & 0x0100) dev->stats.rx_over_errors++;\r\nif (frame_status & 0x0080) dev->stats.rx_length_errors++;\r\n} else {\r\nstruct sk_buff *skb;\r\npkt_len &= 0x3fff;\r\nskb = netdev_alloc_skb(dev, pkt_len + 2);\r\nif (skb == NULL) {\r\npr_err("%s: Memory squeeze, dropping packet.\n",\r\ndev->name);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\nskb_reserve(skb,2);\r\nmemcpy_fromio(skb_put(skb,pkt_len), data_frame + 10, pkt_len);\r\nskb->protocol=eth_type_trans(skb,dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n}\r\nwritew(0,read_frame);\r\nwritew(0xC000,read_frame+2);\r\nwritew(0x0000,lp->base + rx_tail + 2);\r\nrx_tail = rx_head;\r\nrx_head = next_rx_frame;\r\nif (--boguscount == 0)\r\nbreak;\r\n}\r\nlp->rx_head = rx_head;\r\nlp->rx_tail = rx_tail;\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->bus_info, "ISA 0x%lx", dev->base_addr);\r\n}\r\nstatic u32 netdev_get_msglevel(struct net_device *dev)\r\n{\r\nreturn debug;\r\n}\r\nstatic void netdev_set_msglevel(struct net_device *dev, u32 level)\r\n{\r\ndebug = level;\r\n}\r\nint __init init_module(void)\r\n{\r\nif (io == 0)\r\npr_notice("3c507: You should not use auto-probing with insmod!\n");\r\ndev_3c507 = el16_probe(-1);\r\nreturn IS_ERR(dev_3c507) ? PTR_ERR(dev_3c507) : 0;\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nstruct net_device *dev = dev_3c507;\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\niounmap(((struct net_local *)netdev_priv(dev))->base);\r\nrelease_region(dev->base_addr, EL16_IO_EXTENT);\r\nfree_netdev(dev);\r\n}
