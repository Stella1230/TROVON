int cx25821_get_format_size(void)\r\n{\r\nreturn ARRAY_SIZE(formats);\r\n}\r\nstruct cx25821_fmt *cx25821_format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nif (fourcc == V4L2_PIX_FMT_Y41P || fourcc == V4L2_PIX_FMT_YUV411P)\r\nreturn formats + 1;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats + i;\r\npr_err("%s(0x%08x) NOT FOUND\n", __func__, fourcc);\r\nreturn NULL;\r\n}\r\nvoid cx25821_video_wakeup(struct cx25821_dev *dev, struct cx25821_dmaqueue *q,\r\nu32 count)\r\n{\r\nstruct cx25821_buffer *buf;\r\nint bc;\r\nfor (bc = 0;; bc++) {\r\nif (list_empty(&q->active)) {\r\ndprintk(1, "bc=%d (=0: active empty)\n", bc);\r\nbreak;\r\n}\r\nbuf = list_entry(q->active.next, struct cx25821_buffer,\r\nvb.queue);\r\nif ((s16) (count - buf->count) < 0)\r\nbreak;\r\ndo_gettimeofday(&buf->vb.ts);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nif (list_empty(&q->active))\r\ndel_timer(&q->timeout);\r\nelse\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\nif (bc != 1)\r\npr_err("%s: %d buffers handled (should be 1)\n", __func__, bc);\r\n}\r\nint cx25821_set_tvnorm(struct cx25821_dev *dev, v4l2_std_id norm)\r\n{\r\ndprintk(1, "%s(norm = 0x%08x) name: [%s]\n",\r\n__func__, (unsigned int)norm, v4l2_norm_to_name(norm));\r\ndev->tvnorm = norm;\r\ncx25821_call_all(dev, core, s_std, norm);\r\nreturn 0;\r\n}\r\nstruct video_device *cx25821_vdev_init(struct cx25821_dev *dev,\r\nstruct pci_dev *pci,\r\nstruct video_device *template,\r\nchar *type)\r\n{\r\nstruct video_device *vfd;\r\ndprintk(1, "%s()\n", __func__);\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s (%s)", dev->name, type,\r\ncx25821_boards[dev->board].name);\r\nvideo_set_drvdata(vfd, dev);\r\nreturn vfd;\r\n}\r\nint cx25821_res_get(struct cx25821_dev *dev, struct cx25821_fh *fh,\r\nunsigned int bit)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nif (fh->resources & bit)\r\nreturn 1;\r\nmutex_lock(&dev->lock);\r\nif (dev->channels[fh->channel_id].resources & bit) {\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nfh->resources |= bit;\r\ndev->channels[fh->channel_id].resources |= bit;\r\ndprintk(1, "res: get %d\n", bit);\r\nmutex_unlock(&dev->lock);\r\nreturn 1;\r\n}\r\nint cx25821_res_check(struct cx25821_fh *fh, unsigned int bit)\r\n{\r\nreturn fh->resources & bit;\r\n}\r\nint cx25821_res_locked(struct cx25821_fh *fh, unsigned int bit)\r\n{\r\nreturn fh->dev->channels[fh->channel_id].resources & bit;\r\n}\r\nvoid cx25821_res_free(struct cx25821_dev *dev, struct cx25821_fh *fh,\r\nunsigned int bits)\r\n{\r\nBUG_ON((fh->resources & bits) != bits);\r\ndprintk(1, "%s()\n", __func__);\r\nmutex_lock(&dev->lock);\r\nfh->resources &= ~bits;\r\ndev->channels[fh->channel_id].resources &= ~bits;\r\ndprintk(1, "res: put %d\n", bits);\r\nmutex_unlock(&dev->lock);\r\n}\r\nint cx25821_video_mux(struct cx25821_dev *dev, unsigned int input)\r\n{\r\nstruct v4l2_routing route;\r\nmemset(&route, 0, sizeof(route));\r\ndprintk(1, "%s(): video_mux: %d [vmux=%d, gpio=0x%x,0x%x,0x%x,0x%x]\n",\r\n__func__, input, INPUT(input)->vmux, INPUT(input)->gpio0,\r\nINPUT(input)->gpio1, INPUT(input)->gpio2, INPUT(input)->gpio3);\r\ndev->input = input;\r\nroute.input = INPUT(input)->vmux;\r\ncx25821_call_all(dev, video, s_routing, INPUT(input)->vmux, 0, 0);\r\nreturn 0;\r\n}\r\nint cx25821_start_video_dma(struct cx25821_dev *dev,\r\nstruct cx25821_dmaqueue *q,\r\nstruct cx25821_buffer *buf,\r\nstruct sram_channel *channel)\r\n{\r\nint tmp = 0;\r\ncx25821_sram_channel_setup(dev, channel, buf->bpl, buf->risc.dma);\r\ncx_write(channel->gpcnt_ctl, 3);\r\nq->count = 1;\r\ncx_set(PCI_INT_MSK, cx_read(PCI_INT_MSK) | (1 << channel->i));\r\ncx_set(channel->int_msk, 0x11);\r\ncx_write(channel->dma_ctl, 0x11);\r\ntmp = cx_read(VID_CH_MODE_SEL);\r\ncx_write(VID_CH_MODE_SEL, tmp & 0xFFFFFE00);\r\nreturn 0;\r\n}\r\nint cx25821_restart_video_queue(struct cx25821_dev *dev,\r\nstruct cx25821_dmaqueue *q,\r\nstruct sram_channel *channel)\r\n{\r\nstruct cx25821_buffer *buf, *prev;\r\nstruct list_head *item;\r\nif (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx25821_buffer,\r\nvb.queue);\r\ncx25821_start_video_dma(dev, q, buf, channel);\r\nlist_for_each(item, &q->active) {\r\nbuf = list_entry(item, struct cx25821_buffer, vb.queue);\r\nbuf->count = q->count++;\r\n}\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nprev = NULL;\r\nfor (;;) {\r\nif (list_empty(&q->queued))\r\nreturn 0;\r\nbuf = list_entry(q->queued.next, struct cx25821_buffer,\r\nvb.queue);\r\nif (NULL == prev) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\ncx25821_start_video_dma(dev, q, buf, channel);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\n} else if (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nprev->risc.jmp[2] = cpu_to_le32(0);\r\n} else {\r\nreturn 0;\r\n}\r\nprev = buf;\r\n}\r\n}\r\nvoid cx25821_vid_timeout(unsigned long data)\r\n{\r\nstruct cx25821_data *timeout_data = (struct cx25821_data *)data;\r\nstruct cx25821_dev *dev = timeout_data->dev;\r\nstruct sram_channel *channel = timeout_data->channel;\r\nstruct cx25821_dmaqueue *q = &dev->channels[channel->i].vidq;\r\nstruct cx25821_buffer *buf;\r\nunsigned long flags;\r\ncx_clear(channel->dma_ctl, 0x11);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx25821_buffer,\r\nvb.queue);\r\nlist_del(&buf->vb.queue);\r\nbuf->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&buf->vb.done);\r\n}\r\ncx25821_restart_video_queue(dev, q, channel);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nint cx25821_video_irq(struct cx25821_dev *dev, int chan_num, u32 status)\r\n{\r\nu32 count = 0;\r\nint handled = 0;\r\nu32 mask;\r\nstruct sram_channel *channel = dev->channels[chan_num].sram_channels;\r\nmask = cx_read(channel->int_msk);\r\nif (0 == (status & mask))\r\nreturn handled;\r\ncx_write(channel->int_stat, status);\r\nif (status & (1 << 16)) {\r\npr_warn("%s, %s: video risc op code error\n",\r\ndev->name, channel->name);\r\ncx_clear(channel->dma_ctl, 0x11);\r\ncx25821_sram_channel_dump(dev, channel);\r\n}\r\nif (status & FLD_VID_DST_RISC1) {\r\nspin_lock(&dev->slock);\r\ncount = cx_read(channel->gpcnt);\r\ncx25821_video_wakeup(dev, &dev->channels[channel->i].vidq,\r\ncount);\r\nspin_unlock(&dev->slock);\r\nhandled++;\r\n}\r\nif (status & 0x10) {\r\ndprintk(2, "stopper video\n");\r\nspin_lock(&dev->slock);\r\ncx25821_restart_video_queue(dev,\r\n&dev->channels[channel->i].vidq, channel);\r\nspin_unlock(&dev->slock);\r\nhandled++;\r\n}\r\nreturn handled;\r\n}\r\nvoid cx25821_videoioctl_unregister(struct cx25821_dev *dev)\r\n{\r\nif (dev->ioctl_dev) {\r\nif (video_is_registered(dev->ioctl_dev))\r\nvideo_unregister_device(dev->ioctl_dev);\r\nelse\r\nvideo_device_release(dev->ioctl_dev);\r\ndev->ioctl_dev = NULL;\r\n}\r\n}\r\nvoid cx25821_video_unregister(struct cx25821_dev *dev, int chan_num)\r\n{\r\ncx_clear(PCI_INT_MSK, 1);\r\nif (dev->channels[chan_num].video_dev) {\r\nif (video_is_registered(dev->channels[chan_num].video_dev))\r\nvideo_unregister_device(\r\ndev->channels[chan_num].video_dev);\r\nelse\r\nvideo_device_release(\r\ndev->channels[chan_num].video_dev);\r\ndev->channels[chan_num].video_dev = NULL;\r\nbtcx_riscmem_free(dev->pci,\r\n&dev->channels[chan_num].vidq.stopper);\r\npr_warn("device %d released!\n", chan_num);\r\n}\r\n}\r\nint cx25821_video_register(struct cx25821_dev *dev)\r\n{\r\nint err;\r\nint i;\r\nstruct video_device cx25821_video_device = {\r\n.name = "cx25821-video",\r\n.fops = &video_fops,\r\n.minor = -1,\r\n.ioctl_ops = &video_ioctl_ops,\r\n.tvnorms = CX25821_NORMS,\r\n.current_norm = V4L2_STD_NTSC_M,\r\n};\r\nspin_lock_init(&dev->slock);\r\nfor (i = 0; i < MAX_VID_CHANNEL_NUM - 1; ++i) {\r\ncx25821_init_controls(dev, i);\r\ncx25821_risc_stopper(dev->pci, &dev->channels[i].vidq.stopper,\r\ndev->channels[i].sram_channels->dma_ctl, 0x11, 0);\r\ndev->channels[i].sram_channels = &cx25821_sram_channels[i];\r\ndev->channels[i].video_dev = NULL;\r\ndev->channels[i].resources = 0;\r\ncx_write(dev->channels[i].sram_channels->int_stat, 0xffffffff);\r\nINIT_LIST_HEAD(&dev->channels[i].vidq.active);\r\nINIT_LIST_HEAD(&dev->channels[i].vidq.queued);\r\ndev->channels[i].timeout_data.dev = dev;\r\ndev->channels[i].timeout_data.channel =\r\n&cx25821_sram_channels[i];\r\ndev->channels[i].vidq.timeout.function = cx25821_vid_timeout;\r\ndev->channels[i].vidq.timeout.data =\r\n(unsigned long)&dev->channels[i].timeout_data;\r\ninit_timer(&dev->channels[i].vidq.timeout);\r\ndev->channels[i].video_dev = cx25821_vdev_init(dev, dev->pci,\r\n&cx25821_video_device, "video");\r\nerr = video_register_device(dev->channels[i].video_dev,\r\nVFL_TYPE_GRABBER, video_nr[dev->nr]);\r\nif (err < 0)\r\ngoto fail_unreg;\r\n}\r\ncx_set(PCI_INT_MSK, 0xff);\r\nmutex_lock(&dev->lock);\r\n#ifdef TUNER_FLAG\r\ndev->tvnorm = cx25821_video_device.current_norm;\r\ncx25821_set_tvnorm(dev, dev->tvnorm);\r\n#endif\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\nfail_unreg:\r\ncx25821_video_unregister(dev, i);\r\nreturn err;\r\n}\r\nint cx25821_buffer_setup(struct videobuf_queue *q, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct cx25821_fh *fh = q->priv_data;\r\n*size = fh->fmt->depth * fh->width * fh->height >> 3;\r\nif (0 == *count)\r\n*count = 32;\r\nif (*size * *count > vid_limit * 1024 * 1024)\r\n*count = (vid_limit * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nint cx25821_buffer_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct cx25821_fh *fh = q->priv_data;\r\nstruct cx25821_dev *dev = fh->dev;\r\nstruct cx25821_buffer *buf =\r\ncontainer_of(vb, struct cx25821_buffer, vb);\r\nint rc, init_buffer = 0;\r\nu32 line0_offset;\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);\r\nint bpl_local = LINE_SIZE_D1;\r\nint channel_opened = fh->channel_id;\r\nBUG_ON(NULL == fh->fmt);\r\nif (fh->width < 48 || fh->width > 720 ||\r\nfh->height < 32 || fh->height > 576)\r\nreturn -EINVAL;\r\nbuf->vb.size = (fh->width * fh->height * fh->fmt->depth) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nif (buf->fmt != fh->fmt ||\r\nbuf->vb.width != fh->width ||\r\nbuf->vb.height != fh->height || buf->vb.field != field) {\r\nbuf->fmt = fh->fmt;\r\nbuf->vb.width = fh->width;\r\nbuf->vb.height = fh->height;\r\nbuf->vb.field = field;\r\ninit_buffer = 1;\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\ninit_buffer = 1;\r\nrc = videobuf_iolock(q, &buf->vb, NULL);\r\nif (0 != rc) {\r\nprintk(KERN_DEBUG pr_fmt("videobuf_iolock failed!\n"));\r\ngoto fail;\r\n}\r\n}\r\ndprintk(1, "init_buffer=%d\n", init_buffer);\r\nif (init_buffer) {\r\nchannel_opened = dev->channel_opened;\r\nif (channel_opened < 0 || channel_opened > 7)\r\nchannel_opened = 7;\r\nif (dev->channels[channel_opened].pixel_formats ==\r\nPIXEL_FRMT_411)\r\nbuf->bpl = (buf->fmt->depth * buf->vb.width) >> 3;\r\nelse\r\nbuf->bpl = (buf->fmt->depth >> 3) * (buf->vb.width);\r\nif (dev->channels[channel_opened].pixel_formats ==\r\nPIXEL_FRMT_411) {\r\nbpl_local = buf->bpl;\r\n} else {\r\nbpl_local = buf->bpl;\r\nif (channel_opened >= 0 && channel_opened <= 7) {\r\nif (dev->channels[channel_opened]\r\n.use_cif_resolution) {\r\nif (dev->tvnorm & V4L2_STD_PAL_BG ||\r\ndev->tvnorm & V4L2_STD_PAL_DK)\r\nbpl_local = 352 << 1;\r\nelse\r\nbpl_local = dev->channels[\r\nchannel_opened].\r\ncif_width << 1;\r\n}\r\n}\r\n}\r\nswitch (buf->vb.field) {\r\ncase V4L2_FIELD_TOP:\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, 0, UNSET,\r\nbuf->bpl, 0, buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, UNSET, 0,\r\nbuf->bpl, 0, buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nline0_offset = 0;\r\ndprintk(1, "top field first\n");\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, line0_offset,\r\nbpl_local, bpl_local, bpl_local,\r\nbuf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist,\r\n0, buf->bpl * (buf->vb.height >> 1),\r\nbuf->bpl, 0, buf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_BT:\r\ncx25821_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist,\r\nbuf->bpl * (buf->vb.height >> 1), 0,\r\nbuf->bpl, 0, buf->vb.height >> 1);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\ndprintk(2, "[%p/%d] buffer_prep - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",\r\nbuf, buf->vb.i, fh->width, fh->height, fh->fmt->depth,\r\nfh->fmt->name, (unsigned long)buf->risc.dma);\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\ncx25821_free_buffer(q, buf);\r\nreturn rc;\r\n}\r\nvoid cx25821_buffer_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx25821_buffer *buf =\r\ncontainer_of(vb, struct cx25821_buffer, vb);\r\ncx25821_free_buffer(q, buf);\r\n}\r\nstruct videobuf_queue *get_queue(struct cx25821_fh *fh)\r\n{\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &fh->vidq;\r\ndefault:\r\nBUG();\r\nreturn NULL;\r\n}\r\n}\r\nint cx25821_get_resource(struct cx25821_fh *fh, int resource)\r\n{\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn resource;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nint cx25821_video_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct cx25821_fh *fh = file->private_data;\r\nreturn videobuf_mmap_mapper(get_queue(fh), vma);\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct cx25821_buffer *buf =\r\ncontainer_of(vb, struct cx25821_buffer, vb);\r\nstruct cx25821_buffer *prev;\r\nstruct cx25821_fh *fh = vq->priv_data;\r\nstruct cx25821_dev *dev = fh->dev;\r\nstruct cx25821_dmaqueue *q = &dev->channels[fh->channel_id].vidq;\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(q->stopper.dma);\r\nbuf->risc.jmp[2] = cpu_to_le32(0);\r\ndprintk(2, "jmp to stopper (0x%x)\n", buf->risc.jmp[1]);\r\nif (!list_empty(&q->queued)) {\r\nlist_add_tail(&buf->vb.queue, &q->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2, "[%p/%d] buffer_queue - append to queued\n", buf,\r\nbuf->vb.i);\r\n} else if (list_empty(&q->active)) {\r\nlist_add_tail(&buf->vb.queue, &q->active);\r\ncx25821_start_video_dma(dev, q, buf,\r\ndev->channels[fh->channel_id].sram_channels);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies + BUFFER_TIMEOUT);\r\ndprintk(2, "[%p/%d] buffer_queue - first active, buf cnt = %d, q->count = %d\n",\r\nbuf, buf->vb.i, buf->count, q->count);\r\n} else {\r\nprev = list_entry(q->active.prev, struct cx25821_buffer,\r\nvb.queue);\r\nif (prev->vb.width == buf->vb.width\r\n&& prev->vb.height == buf->vb.height\r\n&& prev->fmt == buf->fmt) {\r\nlist_add_tail(&buf->vb.queue, &q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nprev->risc.jmp[2] = cpu_to_le32(0);\r\ndprintk(2, "[%p/%d] buffer_queue - append to active, buf->count=%d\n",\r\nbuf, buf->vb.i, buf->count);\r\n} else {\r\nlist_add_tail(&buf->vb.queue, &q->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2, "[%p/%d] buffer_queue - first queued\n", buf,\r\nbuf->vb.i);\r\n}\r\n}\r\nif (list_empty(&q->active))\r\ndprintk(2, "active queue empty!\n");\r\n}\r\nstatic int video_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct cx25821_dev *h, *dev = video_drvdata(file);\r\nstruct cx25821_fh *fh;\r\nstruct list_head *list;\r\nint minor = video_devdata(file)->minor;\r\nenum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nu32 pix_format;\r\nint ch_id = 0;\r\nint i;\r\ndprintk(1, "open dev=%s type=%s\n", video_device_node_name(vdev),\r\nv4l2_type_names[type]);\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (NULL == fh)\r\nreturn -ENOMEM;\r\nmutex_lock(&cx25821_devlist_mutex);\r\nlist_for_each(list, &cx25821_devlist)\r\n{\r\nh = list_entry(list, struct cx25821_dev, devlist);\r\nfor (i = 0; i < MAX_VID_CHANNEL_NUM; i++) {\r\nif (h->channels[i].video_dev &&\r\nh->channels[i].video_dev->minor == minor) {\r\ndev = h;\r\nch_id = i;\r\ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\n}\r\n}\r\n}\r\nif (NULL == dev) {\r\nmutex_unlock(&cx25821_devlist_mutex);\r\nkfree(fh);\r\nreturn -ENODEV;\r\n}\r\nfile->private_data = fh;\r\nfh->dev = dev;\r\nfh->type = type;\r\nfh->width = 720;\r\nfh->channel_id = ch_id;\r\nif (dev->tvnorm & V4L2_STD_PAL_BG || dev->tvnorm & V4L2_STD_PAL_DK)\r\nfh->height = 576;\r\nelse\r\nfh->height = 480;\r\ndev->channel_opened = fh->channel_id;\r\nif (dev->channels[ch_id].pixel_formats == PIXEL_FRMT_411)\r\npix_format = V4L2_PIX_FMT_Y41P;\r\nelse\r\npix_format = V4L2_PIX_FMT_YUYV;\r\nfh->fmt = cx25821_format_by_fourcc(pix_format);\r\nv4l2_prio_open(&dev->channels[ch_id].prio, &fh->prio);\r\nvideobuf_queue_sg_init(&fh->vidq, &cx25821_video_qops, &dev->pci->dev,\r\n&dev->slock, V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED, sizeof(struct cx25821_buffer),\r\nfh, NULL);\r\ndprintk(1, "post videobuf_queue_init()\n");\r\nmutex_unlock(&cx25821_devlist_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t video_read(struct file *file, char __user * data, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct cx25821_fh *fh = file->private_data;\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (cx25821_res_locked(fh, RESOURCE_VIDEO0))\r\nreturn -EBUSY;\r\nreturn videobuf_read_one(&fh->vidq, data, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned int video_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct cx25821_fh *fh = file->private_data;\r\nstruct cx25821_buffer *buf;\r\nif (cx25821_res_check(fh, RESOURCE_VIDEO0)) {\r\nif (list_empty(&fh->vidq.stream))\r\nreturn POLLERR;\r\nbuf = list_entry(fh->vidq.stream.next,\r\nstruct cx25821_buffer, vb.stream);\r\n} else {\r\nbuf = (struct cx25821_buffer *)fh->vidq.read_buf;\r\nif (NULL == buf)\r\nreturn POLLERR;\r\n}\r\npoll_wait(file, &buf->vb.done, wait);\r\nif (buf->vb.state == VIDEOBUF_DONE || buf->vb.state == VIDEOBUF_ERROR) {\r\nif (buf->vb.state == VIDEOBUF_DONE) {\r\nstruct cx25821_dev *dev = fh->dev;\r\nif (dev && dev->channels[fh->channel_id]\r\n.use_cif_resolution) {\r\nu8 cam_id = *((char *)buf->vb.baddr + 3);\r\nmemcpy((char *)buf->vb.baddr,\r\n(char *)buf->vb.baddr + (fh->width * 2),\r\n(fh->width * 2));\r\n*((char *)buf->vb.baddr + 3) = cam_id;\r\n}\r\n}\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int video_release(struct file *file)\r\n{\r\nstruct cx25821_fh *fh = file->private_data;\r\nstruct cx25821_dev *dev = fh->dev;\r\ncx_write(channel0->dma_ctl, 0);\r\nif (cx25821_res_check(fh, RESOURCE_VIDEO0)) {\r\nvideobuf_queue_cancel(&fh->vidq);\r\ncx25821_res_free(dev, fh, RESOURCE_VIDEO0);\r\n}\r\nif (fh->vidq.read_buf) {\r\ncx25821_buffer_release(&fh->vidq, fh->vidq.read_buf);\r\nkfree(fh->vidq.read_buf);\r\n}\r\nvideobuf_mmap_free(&fh->vidq);\r\nv4l2_prio_close(&dev->channels[fh->channel_id].prio, fh->prio);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev = fh->dev;\r\nif (unlikely(fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE))\r\nreturn -EINVAL;\r\nif (unlikely(i != fh->type))\r\nreturn -EINVAL;\r\nif (unlikely(!cx25821_res_get(dev, fh, cx25821_get_resource(fh,\r\nRESOURCE_VIDEO0))))\r\nreturn -EBUSY;\r\nreturn videobuf_streamon(get_queue(fh));\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev = fh->dev;\r\nint err, res;\r\nif (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (i != fh->type)\r\nreturn -EINVAL;\r\nres = cx25821_get_resource(fh, RESOURCE_VIDEO0);\r\nerr = videobuf_streamoff(get_queue(fh));\r\nif (err < 0)\r\nreturn err;\r\ncx25821_res_free(dev, fh, res);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint err;\r\nint pix_format = PIXEL_FRMT_422;\r\nif (fh) {\r\nerr = v4l2_prio_check(&dev->channels[fh->channel_id].prio,\r\nfh->prio);\r\nif (0 != err)\r\nreturn err;\r\n}\r\ndprintk(2, "%s()\n", __func__);\r\nerr = cx25821_vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (0 != err)\r\nreturn err;\r\nfh->fmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\r\nfh->vidq.field = f->fmt.pix.field;\r\nif (cx25821_is_valid_width(f->fmt.pix.width, dev->tvnorm))\r\nfh->width = f->fmt.pix.width;\r\nif (cx25821_is_valid_height(f->fmt.pix.height, dev->tvnorm))\r\nfh->height = f->fmt.pix.height;\r\nif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_Y41P)\r\npix_format = PIXEL_FRMT_411;\r\nelse if (f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV)\r\npix_format = PIXEL_FRMT_422;\r\nelse\r\nreturn -EINVAL;\r\ncx25821_set_pixel_format(dev, SRAM_CH00, pix_format);\r\nif (fh->width == 320 || fh->width == 352)\r\ndev->channels[fh->channel_id].use_cif_resolution = 1;\r\nelse\r\ndev->channels[fh->channel_id].use_cif_resolution = 0;\r\ndev->channels[fh->channel_id].cif_width = fh->width;\r\nmedusa_set_resolution(dev, fh->width, SRAM_CH00);\r\ndprintk(2, "%s(): width=%d height=%d field=%d\n", __func__, fh->width,\r\nfh->height, fh->vidq.field);\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, V4L2_MBUS_FMT_FIXED);\r\ncx25821_call_all(dev, video, s_mbus_fmt, &mbus_fmt);\r\nreturn 0;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nint ret_val = 0;\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nret_val = videobuf_dqbuf(get_queue(fh), p, file->f_flags & O_NONBLOCK);\r\np->sequence = dev->channels[fh->channel_id].vidq.count;\r\nreturn ret_val;\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nstruct cx25821_fh *fh = priv;\r\nchar name[32 + 2];\r\nstruct sram_channel *sram_ch = dev->channels[fh->channel_id]\r\n.sram_channels;\r\nu32 tmp = 0;\r\nsnprintf(name, sizeof(name), "%s/2", dev->name);\r\npr_info("%s/2: ============ START LOG STATUS ============\n",\r\ndev->name);\r\ncx25821_call_all(dev, core, log_status);\r\ntmp = cx_read(sram_ch->dma_ctl);\r\npr_info("Video input 0 is %s\n",\r\n(tmp & 0x11) ? "streaming" : "stopped");\r\npr_info("%s/2: ============= END LOG STATUS =============\n",\r\ndev->name);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nint err;\r\nif (fh) {\r\nerr = v4l2_prio_check(&dev->channels[fh->channel_id].prio,\r\nfh->prio);\r\nif (0 != err)\r\nreturn err;\r\n}\r\nreturn cx25821_set_control(dev, ctl, fh->channel_id);\r\n}\r\nint cx25821_vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nf->fmt.pix.width = fh->width;\r\nf->fmt.pix.height = fh->height;\r\nf->fmt.pix.field = fh->vidq.field;\r\nf->fmt.pix.pixelformat = fh->fmt->fourcc;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * fh->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx25821_fmt *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxw, maxh;\r\nfmt = cx25821_format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nmaxw = 720;\r\nmaxh = 576;\r\nif (V4L2_FIELD_ANY == field) {\r\nif (f->fmt.pix.height > maxh / 2)\r\nfield = V4L2_FIELD_INTERLACED;\r\nelse\r\nfield = V4L2_FIELD_TOP;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nf->fmt.pix.field = field;\r\nif (f->fmt.pix.height < 32)\r\nf->fmt.pix.height = 32;\r\nif (f->fmt.pix.height > maxh)\r\nf->fmt.pix.height = maxh;\r\nif (f->fmt.pix.width < 48)\r\nf->fmt.pix.width = 48;\r\nif (f->fmt.pix.width > maxw)\r\nf->fmt.pix.width = maxw;\r\nf->fmt.pix.width &= ~0x03;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nstrcpy(cap->driver, "cx25821");\r\nstrlcpy(cap->card, cx25821_boards[dev->board].name, sizeof(cap->card));\r\nsprintf(cap->bus_info, "PCIe:%s", pci_name(dev->pci));\r\ncap->version = CX25821_VERSION_CODE;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nif (UNSET != dev->tuner_type)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(formats)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nreturn videobuf_reqbufs(get_queue(fh), p);\r\n}\r\nint cx25821_vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nreturn videobuf_querybuf(get_queue(fh), p);\r\n}\r\nint cx25821_vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nreturn videobuf_qbuf(get_queue(fh), p);\r\n}\r\nint cx25821_vidioc_g_priority(struct file *file, void *f, enum v4l2_priority *p)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)f)->dev;\r\nstruct cx25821_fh *fh = f;\r\n*p = v4l2_prio_max(&dev->channels[fh->channel_id].prio);\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_s_priority(struct file *file, void *f,\r\nenum v4l2_priority prio)\r\n{\r\nstruct cx25821_fh *fh = f;\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)f)->dev;\r\nreturn v4l2_prio_change(&dev->channels[fh->channel_id].prio, &fh->prio,\r\nprio);\r\n}\r\nint cx25821_vidioc_s_std(struct file *file, void *priv, v4l2_std_id * tvnorms)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nint err;\r\ndprintk(1, "%s()\n", __func__);\r\nif (fh) {\r\nerr = v4l2_prio_check(&dev->channels[fh->channel_id].prio,\r\nfh->prio);\r\nif (0 != err)\r\nreturn err;\r\n}\r\nif (dev->tvnorm == *tvnorms)\r\nreturn 0;\r\nmutex_lock(&dev->lock);\r\ncx25821_set_tvnorm(dev, *tvnorms);\r\nmutex_unlock(&dev->lock);\r\nmedusa_set_videostandard(dev);\r\nreturn 0;\r\n}\r\nint cx25821_enum_input(struct cx25821_dev *dev, struct v4l2_input *i)\r\n{\r\nstatic const char * const iname[] = {\r\n[CX25821_VMUX_COMPOSITE] = "Composite",\r\n[CX25821_VMUX_SVIDEO] = "S-Video",\r\n[CX25821_VMUX_DEBUG] = "for debug only",\r\n};\r\nunsigned int n;\r\ndprintk(1, "%s()\n", __func__);\r\nn = i->index;\r\nif (n >= 2)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n)->type)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, iname[INPUT(n)->type]);\r\ni->std = CX25821_NORMS;\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\ndprintk(1, "%s()\n", __func__);\r\nreturn cx25821_enum_input(dev, i);\r\n}\r\nint cx25821_vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\n*i = dev->input;\r\ndprintk(1, "%s(): returns %d\n", __func__, *i);\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nint err;\r\ndprintk(1, "%s(%d)\n", __func__, i);\r\nif (fh) {\r\nerr = v4l2_prio_check(&dev->channels[fh->channel_id].prio,\r\nfh->prio);\r\nif (0 != err)\r\nreturn err;\r\n}\r\nif (i >= CX25821_NR_INPUT) {\r\ndprintk(1, "%s(): -EINVAL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev->lock);\r\ncx25821_video_mux(dev, i);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev = fh->dev;\r\nf->frequency = dev->freq;\r\ncx25821_call_all(dev, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nint cx25821_set_freq(struct cx25821_dev *dev, struct v4l2_frequency *f)\r\n{\r\nmutex_lock(&dev->lock);\r\ndev->freq = f->frequency;\r\ncx25821_call_all(dev, tuner, s_frequency, f);\r\nmsleep(10);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_s_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx25821_fh *fh = priv;\r\nstruct cx25821_dev *dev;\r\nint err;\r\nif (fh) {\r\ndev = fh->dev;\r\nerr = v4l2_prio_check(&dev->channels[fh->channel_id].prio,\r\nfh->prio);\r\nif (0 != err)\r\nreturn err;\r\n} else {\r\npr_err("Invalid fh pointer!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn cx25821_set_freq(dev, f);\r\n}\r\nint cx25821_vidioc_g_register(struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)fh)->dev;\r\nif (!v4l2_chip_match_host(&reg->match))\r\nreturn -EINVAL;\r\ncx25821_call_all(dev, core, g_register, reg);\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_s_register(struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)fh)->dev;\r\nif (!v4l2_chip_match_host(&reg->match))\r\nreturn -EINVAL;\r\ncx25821_call_all(dev, core, s_register, reg);\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_g_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nif (unlikely(UNSET == dev->tuner_type))\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nt->capability = V4L2_TUNER_CAP_NORM;\r\nt->rangehigh = 0xffffffffUL;\r\nt->signal = 0xffff;\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_s_tuner(struct file *file, void *priv, struct v4l2_tuner *t)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nstruct cx25821_fh *fh = priv;\r\nint err;\r\nif (fh) {\r\nerr = v4l2_prio_check(&dev->channels[fh->channel_id].prio,\r\nfh->prio);\r\nif (0 != err)\r\nreturn err;\r\n}\r\ndprintk(1, "%s()\n", __func__);\r\nif (UNSET == dev->tuner_type)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cx25821_ctrl_query(struct v4l2_queryctrl *qctrl)\r\n{\r\nint i;\r\nif (qctrl->id < V4L2_CID_BASE || qctrl->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nfor (i = 0; i < CX25821_CTLS; i++)\r\nif (cx25821_ctls[i].id == qctrl->id)\r\nbreak;\r\nif (i == CX25821_CTLS) {\r\n*qctrl = no_ctl;\r\nreturn 0;\r\n}\r\n*qctrl = cx25821_ctls[i];\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qctrl)\r\n{\r\nreturn cx25821_ctrl_query(qctrl);\r\n}\r\nstatic const struct v4l2_queryctrl *ctrl_by_id(unsigned int id)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < CX25821_CTLS; i++)\r\nif (cx25821_ctls[i].id == id)\r\nreturn cx25821_ctls + i;\r\nreturn NULL;\r\n}\r\nint cx25821_vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nstruct cx25821_fh *fh = priv;\r\nconst struct v4l2_queryctrl *ctrl;\r\nctrl = ctrl_by_id(ctl->id);\r\nif (NULL == ctrl)\r\nreturn -EINVAL;\r\nswitch (ctl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctl->value = dev->channels[fh->channel_id].ctl_bright;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctl->value = dev->channels[fh->channel_id].ctl_hue;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctl->value = dev->channels[fh->channel_id].ctl_contrast;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctl->value = dev->channels[fh->channel_id].ctl_saturation;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint cx25821_set_control(struct cx25821_dev *dev,\r\nstruct v4l2_control *ctl, int chan_num)\r\n{\r\nint err;\r\nconst struct v4l2_queryctrl *ctrl;\r\nerr = -EINVAL;\r\nctrl = ctrl_by_id(ctl->id);\r\nif (NULL == ctrl)\r\nreturn err;\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\nif (ctl->value < ctrl->minimum)\r\nctl->value = ctrl->minimum;\r\nif (ctl->value > ctrl->maximum)\r\nctl->value = ctrl->maximum;\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nswitch (ctl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ndev->channels[chan_num].ctl_bright = ctl->value;\r\nmedusa_set_brightness(dev, ctl->value, chan_num);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ndev->channels[chan_num].ctl_hue = ctl->value;\r\nmedusa_set_hue(dev, ctl->value, chan_num);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ndev->channels[chan_num].ctl_contrast = ctl->value;\r\nmedusa_set_contrast(dev, ctl->value, chan_num);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ndev->channels[chan_num].ctl_saturation = ctl->value;\r\nmedusa_set_saturation(dev, ctl->value, chan_num);\r\nbreak;\r\n}\r\nerr = 0;\r\nreturn err;\r\n}\r\nstatic void cx25821_init_controls(struct cx25821_dev *dev, int chan_num)\r\n{\r\nstruct v4l2_control ctrl;\r\nint i;\r\nfor (i = 0; i < CX25821_CTLS; i++) {\r\nctrl.id = cx25821_ctls[i].id;\r\nctrl.value = cx25821_ctls[i].default_value;\r\ncx25821_set_control(dev, &ctrl, chan_num);\r\n}\r\n}\r\nint cx25821_vidioc_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cropcap)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nif (cropcap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncropcap->bounds.top = 0;\r\ncropcap->bounds.left = 0;\r\ncropcap->bounds.width = 720;\r\ncropcap->bounds.height = dev->tvnorm == V4L2_STD_PAL_BG ? 576 : 480;\r\ncropcap->pixelaspect.numerator =\r\ndev->tvnorm == V4L2_STD_PAL_BG ? 59 : 10;\r\ncropcap->pixelaspect.denominator =\r\ndev->tvnorm == V4L2_STD_PAL_BG ? 54 : 11;\r\ncropcap->defrect = cropcap->bounds;\r\nreturn 0;\r\n}\r\nint cx25821_vidioc_s_crop(struct file *file, void *priv, struct v4l2_crop *crop)\r\n{\r\nstruct cx25821_dev *dev = ((struct cx25821_fh *)priv)->dev;\r\nstruct cx25821_fh *fh = priv;\r\nint err;\r\nif (fh) {\r\nerr = v4l2_prio_check(&dev->channels[fh->channel_id].prio,\r\nfh->prio);\r\nif (0 != err)\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint cx25821_vidioc_g_crop(struct file *file, void *priv, struct v4l2_crop *crop)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint cx25821_vidioc_querystd(struct file *file, void *priv, v4l2_std_id * norm)\r\n{\r\n*norm = CX25821_NORMS;\r\nreturn 0;\r\n}\r\nint cx25821_is_valid_width(u32 width, v4l2_std_id tvnorm)\r\n{\r\nif (tvnorm == V4L2_STD_PAL_BG) {\r\nif (width == 352 || width == 720)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nif (tvnorm == V4L2_STD_NTSC_M) {\r\nif (width == 320 || width == 352 || width == 720)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint cx25821_is_valid_height(u32 height, v4l2_std_id tvnorm)\r\n{\r\nif (tvnorm == V4L2_STD_PAL_BG) {\r\nif (height == 576 || height == 288)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nif (tvnorm == V4L2_STD_NTSC_M) {\r\nif (height == 480 || height == 240)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic long video_ioctl_upstream9(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct cx25821_fh *fh = file->private_data;\r\nstruct cx25821_dev *dev = fh->dev;\r\nint command = 0;\r\nstruct upstream_user_struct *data_from_user;\r\ndata_from_user = (struct upstream_user_struct *)arg;\r\nif (!data_from_user) {\r\npr_err("%s(): Upstream data is INVALID. Returning\n", __func__);\r\nreturn 0;\r\n}\r\ncommand = data_from_user->command;\r\nif (command != UPSTREAM_START_VIDEO && command != UPSTREAM_STOP_VIDEO)\r\nreturn 0;\r\ndev->input_filename = data_from_user->input_filename;\r\ndev->input_audiofilename = data_from_user->input_filename;\r\ndev->vid_stdname = data_from_user->vid_stdname;\r\ndev->pixel_format = data_from_user->pixel_format;\r\ndev->channel_select = data_from_user->channel_select;\r\ndev->command = data_from_user->command;\r\nswitch (command) {\r\ncase UPSTREAM_START_VIDEO:\r\ncx25821_start_upstream_video_ch1(dev, data_from_user);\r\nbreak;\r\ncase UPSTREAM_STOP_VIDEO:\r\ncx25821_stop_upstream_video_ch1(dev);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic long video_ioctl_upstream10(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct cx25821_fh *fh = file->private_data;\r\nstruct cx25821_dev *dev = fh->dev;\r\nint command = 0;\r\nstruct upstream_user_struct *data_from_user;\r\ndata_from_user = (struct upstream_user_struct *)arg;\r\nif (!data_from_user) {\r\npr_err("%s(): Upstream data is INVALID. Returning\n", __func__);\r\nreturn 0;\r\n}\r\ncommand = data_from_user->command;\r\nif (command != UPSTREAM_START_VIDEO && command != UPSTREAM_STOP_VIDEO)\r\nreturn 0;\r\ndev->input_filename_ch2 = data_from_user->input_filename;\r\ndev->input_audiofilename = data_from_user->input_filename;\r\ndev->vid_stdname_ch2 = data_from_user->vid_stdname;\r\ndev->pixel_format_ch2 = data_from_user->pixel_format;\r\ndev->channel_select_ch2 = data_from_user->channel_select;\r\ndev->command_ch2 = data_from_user->command;\r\nswitch (command) {\r\ncase UPSTREAM_START_VIDEO:\r\ncx25821_start_upstream_video_ch2(dev, data_from_user);\r\nbreak;\r\ncase UPSTREAM_STOP_VIDEO:\r\ncx25821_stop_upstream_video_ch2(dev);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic long video_ioctl_upstream11(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct cx25821_fh *fh = file->private_data;\r\nstruct cx25821_dev *dev = fh->dev;\r\nint command = 0;\r\nstruct upstream_user_struct *data_from_user;\r\ndata_from_user = (struct upstream_user_struct *)arg;\r\nif (!data_from_user) {\r\npr_err("%s(): Upstream data is INVALID. Returning\n", __func__);\r\nreturn 0;\r\n}\r\ncommand = data_from_user->command;\r\nif (command != UPSTREAM_START_AUDIO && command != UPSTREAM_STOP_AUDIO)\r\nreturn 0;\r\ndev->input_filename = data_from_user->input_filename;\r\ndev->input_audiofilename = data_from_user->input_filename;\r\ndev->vid_stdname = data_from_user->vid_stdname;\r\ndev->pixel_format = data_from_user->pixel_format;\r\ndev->channel_select = data_from_user->channel_select;\r\ndev->command = data_from_user->command;\r\nswitch (command) {\r\ncase UPSTREAM_START_AUDIO:\r\ncx25821_start_upstream_audio(dev, data_from_user);\r\nbreak;\r\ncase UPSTREAM_STOP_AUDIO:\r\ncx25821_stop_upstream_audio(dev);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic long video_ioctl_set(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct cx25821_fh *fh = file->private_data;\r\nstruct cx25821_dev *dev = fh->dev;\r\nstruct downstream_user_struct *data_from_user;\r\nint command;\r\nint width = 720;\r\nint selected_channel = 0;\r\nint pix_format = 0;\r\nint i = 0;\r\nint cif_enable = 0;\r\nint cif_width = 0;\r\ndata_from_user = (struct downstream_user_struct *)arg;\r\nif (!data_from_user) {\r\npr_err("%s(): User data is INVALID. Returning\n", __func__);\r\nreturn 0;\r\n}\r\ncommand = data_from_user->command;\r\nif (command != SET_VIDEO_STD && command != SET_PIXEL_FORMAT\r\n&& command != ENABLE_CIF_RESOLUTION && command != REG_READ\r\n&& command != REG_WRITE && command != MEDUSA_READ\r\n&& command != MEDUSA_WRITE) {\r\nreturn 0;\r\n}\r\nswitch (command) {\r\ncase SET_VIDEO_STD:\r\nif (!strcmp(data_from_user->vid_stdname, "PAL"))\r\ndev->tvnorm = V4L2_STD_PAL_BG;\r\nelse\r\ndev->tvnorm = V4L2_STD_NTSC_M;\r\nmedusa_set_videostandard(dev);\r\nbreak;\r\ncase SET_PIXEL_FORMAT:\r\nselected_channel = data_from_user->decoder_select;\r\npix_format = data_from_user->pixel_format;\r\nif (!(selected_channel <= 7 && selected_channel >= 0)) {\r\nselected_channel -= 4;\r\nselected_channel = selected_channel % 8;\r\n}\r\nif (selected_channel >= 0)\r\ncx25821_set_pixel_format(dev, selected_channel,\r\npix_format);\r\nbreak;\r\ncase ENABLE_CIF_RESOLUTION:\r\nselected_channel = data_from_user->decoder_select;\r\ncif_enable = data_from_user->cif_resolution_enable;\r\ncif_width = data_from_user->cif_width;\r\nif (cif_enable) {\r\nif (dev->tvnorm & V4L2_STD_PAL_BG\r\n|| dev->tvnorm & V4L2_STD_PAL_DK) {\r\nwidth = 352;\r\n} else {\r\nwidth = cif_width;\r\nif (cif_width != 320 && cif_width != 352)\r\nwidth = 320;\r\n}\r\n}\r\nif (!(selected_channel <= 7 && selected_channel >= 0)) {\r\nselected_channel -= 4;\r\nselected_channel = selected_channel % 8;\r\n}\r\nif (selected_channel <= 7 && selected_channel >= 0) {\r\ndev->channels[selected_channel].use_cif_resolution =\r\ncif_enable;\r\ndev->channels[selected_channel].cif_width = width;\r\n} else {\r\nfor (i = 0; i < VID_CHANNEL_NUM; i++) {\r\ndev->channels[i].use_cif_resolution =\r\ncif_enable;\r\ndev->channels[i].cif_width = width;\r\n}\r\n}\r\nmedusa_set_resolution(dev, width, selected_channel);\r\nbreak;\r\ncase REG_READ:\r\ndata_from_user->reg_data = cx_read(data_from_user->reg_address);\r\nbreak;\r\ncase REG_WRITE:\r\ncx_write(data_from_user->reg_address, data_from_user->reg_data);\r\nbreak;\r\ncase MEDUSA_READ:\r\ncx25821_i2c_read(&dev->i2c_bus[0],\r\n(u16) data_from_user->reg_address,\r\n&data_from_user->reg_data);\r\nbreak;\r\ncase MEDUSA_WRITE:\r\ncx25821_i2c_write(&dev->i2c_bus[0],\r\n(u16) data_from_user->reg_address,\r\ndata_from_user->reg_data);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic long cx25821_video_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret = 0;\r\nstruct cx25821_fh *fh = file->private_data;\r\nif (fh->channel_id == SRAM_CH09) {\r\nret = video_ioctl_upstream9(file, cmd, arg);\r\nreturn ret;\r\n} else if (fh->channel_id == SRAM_CH10) {\r\nret = video_ioctl_upstream10(file, cmd, arg);\r\nreturn ret;\r\n} else if (fh->channel_id == SRAM_CH11) {\r\nret = video_ioctl_upstream11(file, cmd, arg);\r\nret = video_ioctl_set(file, cmd, arg);\r\nreturn ret;\r\n}\r\nreturn video_ioctl2(file, cmd, arg);\r\n}
