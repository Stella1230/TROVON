static bool should_merge(struct fsnotify_event *old, struct fsnotify_event *new)\r\n{\r\npr_debug("%s: old=%p new=%p\n", __func__, old, new);\r\nif (old->to_tell == new->to_tell &&\r\nold->data_type == new->data_type &&\r\nold->tgid == new->tgid) {\r\nswitch (old->data_type) {\r\ncase (FSNOTIFY_EVENT_PATH):\r\nif ((old->path.mnt == new->path.mnt) &&\r\n(old->path.dentry == new->path.dentry))\r\nreturn true;\r\ncase (FSNOTIFY_EVENT_NONE):\r\nreturn true;\r\ndefault:\r\nBUG();\r\n};\r\n}\r\nreturn false;\r\n}\r\nstatic struct fsnotify_event *fanotify_merge(struct list_head *list,\r\nstruct fsnotify_event *event)\r\n{\r\nstruct fsnotify_event_holder *test_holder;\r\nstruct fsnotify_event *test_event = NULL;\r\nstruct fsnotify_event *new_event;\r\npr_debug("%s: list=%p event=%p\n", __func__, list, event);\r\nlist_for_each_entry_reverse(test_holder, list, event_list) {\r\nif (should_merge(test_holder->event, event)) {\r\ntest_event = test_holder->event;\r\nbreak;\r\n}\r\n}\r\nif (!test_event)\r\nreturn NULL;\r\nfsnotify_get_event(test_event);\r\nif (test_event->mask == event->mask)\r\nreturn test_event;\r\nif (atomic_read(&test_event->refcnt) == 2) {\r\ntest_event->mask |= event->mask;\r\nreturn test_event;\r\n}\r\nnew_event = fsnotify_clone_event(test_event);\r\nfsnotify_put_event(test_event);\r\nif (unlikely(!new_event))\r\nreturn ERR_PTR(-ENOMEM);\r\nnew_event->mask = (test_event->mask | event->mask);\r\nfsnotify_replace_event(test_holder, new_event);\r\nreturn new_event;\r\n}\r\nstatic int fanotify_get_response_from_access(struct fsnotify_group *group,\r\nstruct fsnotify_event *event)\r\n{\r\nint ret;\r\npr_debug("%s: group=%p event=%p\n", __func__, group, event);\r\nwait_event(group->fanotify_data.access_waitq, event->response ||\r\natomic_read(&group->fanotify_data.bypass_perm));\r\nif (!event->response)\r\nreturn 0;\r\nspin_lock(&event->lock);\r\nswitch (event->response) {\r\ncase FAN_ALLOW:\r\nret = 0;\r\nbreak;\r\ncase FAN_DENY:\r\ndefault:\r\nret = -EPERM;\r\n}\r\nevent->response = 0;\r\nspin_unlock(&event->lock);\r\npr_debug("%s: group=%p event=%p about to return ret=%d\n", __func__,\r\ngroup, event, ret);\r\nreturn ret;\r\n}\r\nstatic int fanotify_handle_event(struct fsnotify_group *group,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *fanotify_mark,\r\nstruct fsnotify_event *event)\r\n{\r\nint ret = 0;\r\nstruct fsnotify_event *notify_event = NULL;\r\nBUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);\r\nBUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);\r\nBUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\r\nBUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);\r\nBUILD_BUG_ON(FAN_OPEN != FS_OPEN);\r\nBUILD_BUG_ON(FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD);\r\nBUILD_BUG_ON(FAN_Q_OVERFLOW != FS_Q_OVERFLOW);\r\nBUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);\r\nBUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);\r\nBUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);\r\npr_debug("%s: group=%p event=%p\n", __func__, group, event);\r\nnotify_event = fsnotify_add_notify_event(group, event, NULL, fanotify_merge);\r\nif (IS_ERR(notify_event))\r\nreturn PTR_ERR(notify_event);\r\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\r\nif (event->mask & FAN_ALL_PERM_EVENTS) {\r\nif (notify_event)\r\nevent = notify_event;\r\nret = fanotify_get_response_from_access(group, event);\r\n}\r\n#endif\r\nif (notify_event)\r\nfsnotify_put_event(notify_event);\r\nreturn ret;\r\n}\r\nstatic bool fanotify_should_send_event(struct fsnotify_group *group,\r\nstruct inode *to_tell,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmnt_mark,\r\n__u32 event_mask, void *data, int data_type)\r\n{\r\n__u32 marks_mask, marks_ignored_mask;\r\nstruct path *path = data;\r\npr_debug("%s: group=%p to_tell=%p inode_mark=%p vfsmnt_mark=%p "\r\n"mask=%x data=%p data_type=%d\n", __func__, group, to_tell,\r\ninode_mark, vfsmnt_mark, event_mask, data, data_type);\r\nif (data_type != FSNOTIFY_EVENT_PATH)\r\nreturn false;\r\nif (!S_ISREG(path->dentry->d_inode->i_mode) &&\r\n!S_ISDIR(path->dentry->d_inode->i_mode))\r\nreturn false;\r\nif (inode_mark && vfsmnt_mark) {\r\nmarks_mask = (vfsmnt_mark->mask | inode_mark->mask);\r\nmarks_ignored_mask = (vfsmnt_mark->ignored_mask | inode_mark->ignored_mask);\r\n} else if (inode_mark) {\r\nif ((event_mask & FS_EVENT_ON_CHILD) &&\r\n!(inode_mark->mask & FS_EVENT_ON_CHILD))\r\nreturn false;\r\nmarks_mask = inode_mark->mask;\r\nmarks_ignored_mask = inode_mark->ignored_mask;\r\n} else if (vfsmnt_mark) {\r\nmarks_mask = vfsmnt_mark->mask;\r\nmarks_ignored_mask = vfsmnt_mark->ignored_mask;\r\n} else {\r\nBUG();\r\n}\r\nif (S_ISDIR(path->dentry->d_inode->i_mode) &&\r\n(marks_ignored_mask & FS_ISDIR))\r\nreturn false;\r\nif (event_mask & marks_mask & ~marks_ignored_mask)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void fanotify_free_group_priv(struct fsnotify_group *group)\r\n{\r\nstruct user_struct *user;\r\nuser = group->fanotify_data.user;\r\natomic_dec(&user->fanotify_listeners);\r\nfree_uid(user);\r\n}
