static int analyze_baud_rate(struct usb_serial_port *port, speed_t new_rate)\r\n{\r\nstruct cypress_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nif (unstable_bauds)\r\nreturn new_rate;\r\nif (port->serial->dev->speed == USB_SPEED_LOW) {\r\nif (new_rate > 4800) {\r\ndbg("%s - failed setting baud rate, device incapable "\r\n"speed %d", __func__, new_rate);\r\nreturn -1;\r\n}\r\n}\r\nswitch (priv->chiptype) {\r\ncase CT_EARTHMATE:\r\nif (new_rate <= 600) {\r\ndbg("%s - failed setting baud rate, unsupported speed "\r\n"of %d on Earthmate GPS", __func__, new_rate);\r\nreturn -1;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn new_rate;\r\n}\r\nstatic int cypress_serial_control(struct tty_struct *tty,\r\nstruct usb_serial_port *port, speed_t baud_rate, int data_bits,\r\nint stop_bits, int parity_enable, int parity_type, int reset,\r\nint cypress_request_type)\r\n{\r\nint new_baudrate = 0, retval = 0, tries = 0;\r\nstruct cypress_private *priv;\r\nu8 *feature_buffer;\r\nconst unsigned int feature_len = 5;\r\nunsigned long flags;\r\npriv = usb_get_serial_port_data(port);\r\nif (!priv->comm_is_ok)\r\nreturn -ENODEV;\r\nfeature_buffer = kcalloc(feature_len, sizeof(u8), GFP_KERNEL);\r\nif (!feature_buffer)\r\nreturn -ENOMEM;\r\nswitch (cypress_request_type) {\r\ncase CYPRESS_SET_CONFIG:\r\nnew_baudrate = priv->baud_rate;\r\nif (baud_rate && baud_rate != priv->baud_rate) {\r\ndbg("%s - baud rate is changing", __func__);\r\nretval = analyze_baud_rate(port, baud_rate);\r\nif (retval >= 0) {\r\nnew_baudrate = retval;\r\ndbg("%s - New baud rate set to %d",\r\n__func__, new_baudrate);\r\n}\r\n}\r\ndbg("%s - baud rate is being sent as %d",\r\n__func__, new_baudrate);\r\nput_unaligned_le32(new_baudrate, feature_buffer);\r\nfeature_buffer[4] |= data_bits;\r\nfeature_buffer[4] |= (stop_bits << 3);\r\nfeature_buffer[4] |= (parity_enable << 4);\r\nfeature_buffer[4] |= (parity_type << 5);\r\nfeature_buffer[4] |= (reset << 7);\r\ndbg("%s - device is being sent this feature report:",\r\n__func__);\r\ndbg("%s - %02X - %02X - %02X - %02X - %02X", __func__,\r\nfeature_buffer[0], feature_buffer[1],\r\nfeature_buffer[2], feature_buffer[3],\r\nfeature_buffer[4]);\r\ndo {\r\nretval = usb_control_msg(port->serial->dev,\r\nusb_sndctrlpipe(port->serial->dev, 0),\r\nHID_REQ_SET_REPORT,\r\nUSB_DIR_OUT | USB_RECIP_INTERFACE | USB_TYPE_CLASS,\r\n0x0300, 0, feature_buffer,\r\nfeature_len, 500);\r\nif (tries++ >= 3)\r\nbreak;\r\n} while (retval != feature_len &&\r\nretval != -ENODEV);\r\nif (retval != feature_len) {\r\ndev_err(&port->dev, "%s - failed sending serial "\r\n"line settings - %d\n", __func__, retval);\r\ncypress_set_dead(port);\r\n} else {\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->baud_rate = new_baudrate;\r\npriv->current_config = feature_buffer[4];\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (baud_rate)\r\ntty_encode_baud_rate(tty,\r\nnew_baudrate, new_baudrate);\r\n}\r\nbreak;\r\ncase CYPRESS_GET_CONFIG:\r\nif (priv->get_cfg_unsafe) {\r\nretval = -ENOTTY;\r\ngoto out;\r\n}\r\ndbg("%s - retreiving serial line settings", __func__);\r\ndo {\r\nretval = usb_control_msg(port->serial->dev,\r\nusb_rcvctrlpipe(port->serial->dev, 0),\r\nHID_REQ_GET_REPORT,\r\nUSB_DIR_IN | USB_RECIP_INTERFACE | USB_TYPE_CLASS,\r\n0x0300, 0, feature_buffer,\r\nfeature_len, 500);\r\nif (tries++ >= 3)\r\nbreak;\r\n} while (retval != feature_len\r\n&& retval != -ENODEV);\r\nif (retval != feature_len) {\r\ndev_err(&port->dev, "%s - failed to retrieve serial "\r\n"line settings - %d\n", __func__, retval);\r\ncypress_set_dead(port);\r\ngoto out;\r\n} else {\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->current_config = feature_buffer[4];\r\npriv->baud_rate = get_unaligned_le32(feature_buffer);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\n++priv->cmd_count;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nout:\r\nkfree(feature_buffer);\r\nreturn retval;\r\n}\r\nstatic void cypress_set_dead(struct usb_serial_port *port)\r\n{\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->comm_is_ok) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\npriv->comm_is_ok = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_err(&port->dev, "cypress_m8 suspending failing port %d - "\r\n"interval might be too short\n", port->number);\r\n}\r\nstatic int generic_startup(struct usb_serial *serial)\r\n{\r\nstruct cypress_private *priv;\r\nstruct usb_serial_port *port = serial->port[0];\r\npriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->comm_is_ok = !0;\r\nspin_lock_init(&priv->lock);\r\nif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\ninit_waitqueue_head(&priv->delta_msr_wait);\r\nusb_reset_configuration(serial->dev);\r\npriv->cmd_ctrl = 0;\r\npriv->line_control = 0;\r\npriv->termios_initialized = 0;\r\npriv->rx_flags = 0;\r\nif (port->interrupt_out_size > 9)\r\npriv->pkt_fmt = packet_format_1;\r\nelse\r\npriv->pkt_fmt = packet_format_2;\r\nif (interval > 0) {\r\npriv->write_urb_interval = interval;\r\npriv->read_urb_interval = interval;\r\ndbg("%s - port %d read & write intervals forced to %d",\r\n__func__, port->number, interval);\r\n} else {\r\npriv->write_urb_interval = port->interrupt_out_urb->interval;\r\npriv->read_urb_interval = port->interrupt_in_urb->interval;\r\ndbg("%s - port %d intervals: read=%d write=%d",\r\n__func__, port->number,\r\npriv->read_urb_interval, priv->write_urb_interval);\r\n}\r\nusb_set_serial_port_data(port, priv);\r\nreturn 0;\r\n}\r\nstatic int cypress_earthmate_startup(struct usb_serial *serial)\r\n{\r\nstruct cypress_private *priv;\r\nstruct usb_serial_port *port = serial->port[0];\r\nif (generic_startup(serial)) {\r\ndbg("%s - Failed setting up port %d", __func__,\r\nport->number);\r\nreturn 1;\r\n}\r\npriv = usb_get_serial_port_data(port);\r\npriv->chiptype = CT_EARTHMATE;\r\npriv->pkt_fmt = packet_format_1;\r\nif (serial->dev->descriptor.idProduct !=\r\ncpu_to_le16(PRODUCT_ID_EARTHMATEUSB)) {\r\ndbg("%s - Marking this device as unsafe for GET_CONFIG "\r\n"commands", __func__);\r\npriv->get_cfg_unsafe = !0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cypress_hidcom_startup(struct usb_serial *serial)\r\n{\r\nstruct cypress_private *priv;\r\nif (generic_startup(serial)) {\r\ndbg("%s - Failed setting up port %d", __func__,\r\nserial->port[0]->number);\r\nreturn 1;\r\n}\r\npriv = usb_get_serial_port_data(serial->port[0]);\r\npriv->chiptype = CT_CYPHIDCOM;\r\nreturn 0;\r\n}\r\nstatic int cypress_ca42v2_startup(struct usb_serial *serial)\r\n{\r\nstruct cypress_private *priv;\r\nif (generic_startup(serial)) {\r\ndbg("%s - Failed setting up port %d", __func__,\r\nserial->port[0]->number);\r\nreturn 1;\r\n}\r\npriv = usb_get_serial_port_data(serial->port[0]);\r\npriv->chiptype = CT_CA42V2;\r\nreturn 0;\r\n}\r\nstatic void cypress_release(struct usb_serial *serial)\r\n{\r\nstruct cypress_private *priv;\r\npriv = usb_get_serial_port_data(serial->port[0]);\r\nif (priv) {\r\nkfifo_free(&priv->write_fifo);\r\nkfree(priv);\r\n}\r\n}\r\nstatic int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nstruct usb_serial *serial = port->serial;\r\nunsigned long flags;\r\nint result = 0;\r\nif (!priv->comm_is_ok)\r\nreturn -EIO;\r\nusb_clear_halt(serial->dev, 0x81);\r\nusb_clear_halt(serial->dev, 0x02);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->bytes_in = 0;\r\npriv->bytes_out = 0;\r\npriv->cmd_count = 0;\r\npriv->rx_flags = 0;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ncypress_send(port);\r\nif (tty)\r\ncypress_set_termios(tty, port, &priv->tmp_termios);\r\nif (!port->interrupt_in_urb) {\r\ndev_err(&port->dev, "%s - interrupt_in_urb is empty!\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\r\nusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\r\nport->interrupt_in_urb->transfer_buffer,\r\nport->interrupt_in_urb->transfer_buffer_length,\r\ncypress_read_int_callback, port, priv->read_urb_interval);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev,\r\n"%s - failed submitting read urb, error %d\n",\r\n__func__, result);\r\ncypress_set_dead(port);\r\n}\r\nport->port.drain_delay = 256;\r\nreturn result;\r\n}\r\nstatic void cypress_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nspin_lock_irq(&priv->lock);\r\nif (on == 0)\r\npriv->line_control = 0;\r\nelse\r\npriv->line_control = CONTROL_DTR | CONTROL_RTS;\r\npriv->cmd_ctrl = 1;\r\nspin_unlock_irq(&priv->lock);\r\ncypress_write(NULL, port, NULL, 0);\r\n}\r\nstatic void cypress_close(struct usb_serial_port *port)\r\n{\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nmutex_lock(&port->serial->disc_mutex);\r\nif (port->serial->disconnected) {\r\nmutex_unlock(&port->serial->disc_mutex);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nkfifo_reset_out(&priv->write_fifo);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndbg("%s - stopping urbs", __func__);\r\nusb_kill_urb(port->interrupt_in_urb);\r\nusb_kill_urb(port->interrupt_out_urb);\r\nif (stats)\r\ndev_info(&port->dev, "Statistics: %d Bytes In | %d Bytes Out | %d Commands Issued\n",\r\npriv->bytes_in, priv->bytes_out, priv->cmd_count);\r\nmutex_unlock(&port->serial->disc_mutex);\r\n}\r\nstatic int cypress_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\ndbg("%s - port %d, %d bytes", __func__, port->number, count);\r\nif (priv->cmd_ctrl) {\r\ncount = 0;\r\ngoto finish;\r\n}\r\nif (!count)\r\nreturn count;\r\ncount = kfifo_in_locked(&priv->write_fifo, buf, count, &priv->lock);\r\nfinish:\r\ncypress_send(port);\r\nreturn count;\r\n}\r\nstatic void cypress_send(struct usb_serial_port *port)\r\n{\r\nint count = 0, result, offset, actual_size;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nif (!priv->comm_is_ok)\r\nreturn;\r\ndbg("%s - interrupt out size is %d", __func__,\r\nport->interrupt_out_size);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->write_urb_in_use) {\r\ndbg("%s - can't write, urb in use", __func__);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nmemset(port->interrupt_out_urb->transfer_buffer, 0,\r\nport->interrupt_out_size);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nswitch (priv->pkt_fmt) {\r\ndefault:\r\ncase packet_format_1:\r\noffset = 2;\r\nport->interrupt_out_buffer[0] = priv->line_control;\r\nbreak;\r\ncase packet_format_2:\r\noffset = 1;\r\nport->interrupt_out_buffer[0] = priv->line_control;\r\nbreak;\r\n}\r\nif (priv->line_control & CONTROL_RESET)\r\npriv->line_control &= ~CONTROL_RESET;\r\nif (priv->cmd_ctrl) {\r\npriv->cmd_count++;\r\ndbg("%s - line control command being issued", __func__);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ngoto send;\r\n} else\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ncount = kfifo_out_locked(&priv->write_fifo,\r\n&port->interrupt_out_buffer[offset],\r\nport->interrupt_out_size - offset,\r\n&priv->lock);\r\nif (count == 0)\r\nreturn;\r\nswitch (priv->pkt_fmt) {\r\ndefault:\r\ncase packet_format_1:\r\nport->interrupt_out_buffer[1] = count;\r\nbreak;\r\ncase packet_format_2:\r\nport->interrupt_out_buffer[0] |= count;\r\n}\r\ndbg("%s - count is %d", __func__, count);\r\nsend:\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->write_urb_in_use = 1;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (priv->cmd_ctrl)\r\nactual_size = 1;\r\nelse\r\nactual_size = count +\r\n(priv->pkt_fmt == packet_format_1 ? 2 : 1);\r\nusb_serial_debug_data(debug, &port->dev, __func__,\r\nport->interrupt_out_size,\r\nport->interrupt_out_urb->transfer_buffer);\r\nusb_fill_int_urb(port->interrupt_out_urb, port->serial->dev,\r\nusb_sndintpipe(port->serial->dev, port->interrupt_out_endpointAddress),\r\nport->interrupt_out_buffer, port->interrupt_out_size,\r\ncypress_write_int_callback, port, priv->write_urb_interval);\r\nresult = usb_submit_urb(port->interrupt_out_urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err_console(port,\r\n"%s - failed submitting write urb, error %d\n",\r\n__func__, result);\r\npriv->write_urb_in_use = 0;\r\ncypress_set_dead(port);\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->cmd_ctrl)\r\npriv->cmd_ctrl = 0;\r\npriv->bytes_out += count;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nusb_serial_port_softint(port);\r\n}\r\nstatic int cypress_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nint room = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nroom = kfifo_avail(&priv->write_fifo);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndbg("%s - returns %d", __func__, room);\r\nreturn room;\r\n}\r\nstatic int cypress_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\n__u8 status, control;\r\nunsigned int result = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncontrol = priv->line_control;\r\nstatus = priv->current_status;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nresult = ((control & CONTROL_DTR) ? TIOCM_DTR : 0)\r\n| ((control & CONTROL_RTS) ? TIOCM_RTS : 0)\r\n| ((status & UART_CTS) ? TIOCM_CTS : 0)\r\n| ((status & UART_DSR) ? TIOCM_DSR : 0)\r\n| ((status & UART_RI) ? TIOCM_RI : 0)\r\n| ((status & UART_CD) ? TIOCM_CD : 0);\r\ndbg("%s - result = %x", __func__, result);\r\nreturn result;\r\n}\r\nstatic int cypress_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (set & TIOCM_RTS)\r\npriv->line_control |= CONTROL_RTS;\r\nif (set & TIOCM_DTR)\r\npriv->line_control |= CONTROL_DTR;\r\nif (clear & TIOCM_RTS)\r\npriv->line_control &= ~CONTROL_RTS;\r\nif (clear & TIOCM_DTR)\r\npriv->line_control &= ~CONTROL_DTR;\r\npriv->cmd_ctrl = 1;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn cypress_write(tty, port, NULL, 0);\r\n}\r\nstatic int cypress_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\ndbg("%s - port %d, cmd 0x%.4x", __func__, port->number, cmd);\r\nswitch (cmd) {\r\ncase TIOCMIWAIT:\r\nwhile (priv != NULL) {\r\ninterruptible_sleep_on(&priv->delta_msr_wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nelse {\r\nchar diff = priv->diff_status;\r\nif (diff == 0)\r\nreturn -EIO;\r\npriv->diff_status = 0;\r\nif (((arg & TIOCM_RNG) && (diff & UART_RI)) ||\r\n((arg & TIOCM_DSR) && (diff & UART_DSR)) ||\r\n((arg & TIOCM_CD) && (diff & UART_CD)) ||\r\n((arg & TIOCM_CTS) && (diff & UART_CTS)))\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\ndbg("%s - arg not supported - it was 0x%04x - check include/asm/ioctls.h", __func__, cmd);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void cypress_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nint data_bits, stop_bits, parity_type, parity_enable;\r\nunsigned cflag, iflag;\r\nunsigned long flags;\r\n__u8 oldlines;\r\nint linechange = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->termios_initialized) {\r\nif (priv->chiptype == CT_EARTHMATE) {\r\n*(tty->termios) = tty_std_termios;\r\ntty->termios->c_cflag = B4800 | CS8 | CREAD | HUPCL |\r\nCLOCAL;\r\ntty->termios->c_ispeed = 4800;\r\ntty->termios->c_ospeed = 4800;\r\n} else if (priv->chiptype == CT_CYPHIDCOM) {\r\n*(tty->termios) = tty_std_termios;\r\ntty->termios->c_cflag = B9600 | CS8 | CREAD | HUPCL |\r\nCLOCAL;\r\ntty->termios->c_ispeed = 9600;\r\ntty->termios->c_ospeed = 9600;\r\n} else if (priv->chiptype == CT_CA42V2) {\r\n*(tty->termios) = tty_std_termios;\r\ntty->termios->c_cflag = B9600 | CS8 | CREAD | HUPCL |\r\nCLOCAL;\r\ntty->termios->c_ispeed = 9600;\r\ntty->termios->c_ospeed = 9600;\r\n}\r\npriv->termios_initialized = 1;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ntty->termios->c_cflag &= ~(CMSPAR|CRTSCTS);\r\ncflag = tty->termios->c_cflag;\r\niflag = tty->termios->c_iflag;\r\nif (old_termios) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->tmp_termios = *(tty->termios);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstop_bits = cflag & CSTOPB ? 1 : 0;\r\nif (cflag & PARENB) {\r\nparity_enable = 1;\r\nparity_type = cflag & PARODD ? 1 : 0;\r\n} else\r\nparity_enable = parity_type = 0;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\ndata_bits = 0;\r\nbreak;\r\ncase CS6:\r\ndata_bits = 1;\r\nbreak;\r\ncase CS7:\r\ndata_bits = 2;\r\nbreak;\r\ncase CS8:\r\ndata_bits = 3;\r\nbreak;\r\ndefault:\r\ndev_err(&port->dev, "%s - CSIZE was set, but not CS5-CS8\n",\r\n__func__);\r\ndata_bits = 3;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\noldlines = priv->line_control;\r\nif ((cflag & CBAUD) == B0) {\r\ndbg("%s - dropping the lines, baud rate 0bps", __func__);\r\npriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\r\n} else\r\npriv->line_control = (CONTROL_DTR | CONTROL_RTS);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndbg("%s - sending %d stop_bits, %d parity_enable, %d parity_type, "\r\n"%d data_bits (+5)", __func__, stop_bits,\r\nparity_enable, parity_type, data_bits);\r\ncypress_serial_control(tty, port, tty_get_baud_rate(tty),\r\ndata_bits, stop_bits,\r\nparity_enable, parity_type,\r\n0, CYPRESS_SET_CONFIG);\r\ncypress_serial_control(tty, port, 0, 0, 0, 0, 0, 0, CYPRESS_GET_CONFIG);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->chiptype == CT_EARTHMATE && priv->baud_rate == 4800) {\r\ndbg("Using custom termios settings for a baud rate of "\r\n"4800bps.");\r\ntty->termios->c_iflag\r\n&= ~(IGNBRK\r\n| BRKINT\r\n| PARMRK\r\n| ISTRIP\r\n| INLCR\r\n| IGNCR\r\n| ICRNL\r\n| IXON);\r\ntty->termios->c_oflag\r\n&= ~OPOST;\r\ntty->termios->c_lflag\r\n&= ~(ECHO\r\n| ECHONL\r\n| ICANON\r\n| ISIG\r\n| IEXTEN);\r\n}\r\nlinechange = (priv->line_control != oldlines);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (linechange) {\r\npriv->cmd_ctrl = 1;\r\ncypress_write(tty, port, NULL, 0);\r\n}\r\n}\r\nstatic int cypress_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nint chars = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nchars = kfifo_len(&priv->write_fifo);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndbg("%s - returns %d", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic void cypress_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nspin_lock_irq(&priv->lock);\r\npriv->rx_flags = THROTTLED;\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic void cypress_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nint actually_throttled, result;\r\nspin_lock_irq(&priv->lock);\r\nactually_throttled = priv->rx_flags & ACTUALLY_THROTTLED;\r\npriv->rx_flags = 0;\r\nspin_unlock_irq(&priv->lock);\r\nif (!priv->comm_is_ok)\r\nreturn;\r\nif (actually_throttled) {\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result) {\r\ndev_err(&port->dev, "%s - failed submitting read urb, "\r\n"error %d\n", __func__, result);\r\ncypress_set_dead(port);\r\n}\r\n}\r\n}\r\nstatic void cypress_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nunsigned long flags;\r\nchar tty_flag = TTY_NORMAL;\r\nint havedata = 0;\r\nint bytes = 0;\r\nint result;\r\nint i = 0;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ncase -EPIPE:\r\ndefault:\r\ndev_err(&urb->dev->dev,\r\n"%s - unexpected nonzero read status received: %d\n",\r\n__func__, status);\r\ncypress_set_dead(port);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->rx_flags & THROTTLED) {\r\ndbg("%s - now throttling", __func__);\r\npriv->rx_flags |= ACTUALLY_THROTTLED;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty) {\r\ndbg("%s - bad tty pointer - exiting", __func__);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nresult = urb->actual_length;\r\nswitch (priv->pkt_fmt) {\r\ndefault:\r\ncase packet_format_1:\r\npriv->current_status = data[0] & 0xF8;\r\nbytes = data[1] + 2;\r\ni = 2;\r\nif (bytes > 2)\r\nhavedata = 1;\r\nbreak;\r\ncase packet_format_2:\r\npriv->current_status = data[0] & 0xF8;\r\nbytes = (data[0] & 0x07) + 1;\r\ni = 1;\r\nif (bytes > 1)\r\nhavedata = 1;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (result < bytes) {\r\ndbg("%s - wrong packet size - received %d bytes but packet "\r\n"said %d bytes", __func__, result, bytes);\r\ngoto continue_read;\r\n}\r\nusb_serial_debug_data(debug, &port->dev, __func__,\r\nurb->actual_length, data);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->current_status != priv->prev_status) {\r\npriv->diff_status |= priv->current_status ^\r\npriv->prev_status;\r\nwake_up_interruptible(&priv->delta_msr_wait);\r\npriv->prev_status = priv->current_status;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (tty && !(tty->termios->c_cflag & CLOCAL) &&\r\n!(priv->current_status & UART_CD)) {\r\ndbg("%s - calling hangup", __func__);\r\ntty_hangup(tty);\r\ngoto continue_read;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->current_status & CYP_ERROR) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ntty_flag = TTY_PARITY;\r\ndbg("%s - Parity Error detected", __func__);\r\n} else\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (tty && bytes > i) {\r\ntty_insert_flip_string_fixed_flag(tty, data + i,\r\ntty_flag, bytes - i);\r\ntty_flip_buffer_push(tty);\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->bytes_in += bytes;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ncontinue_read:\r\ntty_kref_put(tty);\r\nif (priv->comm_is_ok) {\r\nusb_fill_int_urb(port->interrupt_in_urb, port->serial->dev,\r\nusb_rcvintpipe(port->serial->dev,\r\nport->interrupt_in_endpointAddress),\r\nport->interrupt_in_urb->transfer_buffer,\r\nport->interrupt_in_urb->transfer_buffer_length,\r\ncypress_read_int_callback, port,\r\npriv->read_urb_interval);\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\r\nif (result && result != -EPERM) {\r\ndev_err(&urb->dev->dev, "%s - failed resubmitting "\r\n"read urb, error %d\n", __func__,\r\nresult);\r\ncypress_set_dead(port);\r\n}\r\n}\r\n}\r\nstatic void cypress_write_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct cypress_private *priv = usb_get_serial_port_data(port);\r\nint result;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d",\r\n__func__, status);\r\npriv->write_urb_in_use = 0;\r\nreturn;\r\ncase -EPIPE:\r\nif (!priv->comm_is_ok)\r\nbreak;\r\nusb_clear_halt(port->serial->dev, 0x02);\r\ndbg("%s - nonzero write bulk status received: %d",\r\n__func__, status);\r\nport->interrupt_out_urb->transfer_buffer_length = 1;\r\nresult = usb_submit_urb(port->interrupt_out_urb, GFP_ATOMIC);\r\nif (!result)\r\nreturn;\r\ndev_err(&urb->dev->dev,\r\n"%s - failed resubmitting write urb, error %d\n",\r\n__func__, result);\r\ncypress_set_dead(port);\r\nbreak;\r\ndefault:\r\ndev_err(&urb->dev->dev,\r\n"%s - unexpected nonzero write status received: %d\n",\r\n__func__, status);\r\ncypress_set_dead(port);\r\nbreak;\r\n}\r\npriv->write_urb_in_use = 0;\r\ncypress_send(port);\r\n}
