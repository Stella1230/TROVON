static int it913x_read_reg(struct it913x_fe_state *state,\r\nu32 reg, u8 *data, u8 count)\r\n{\r\nint ret;\r\nu8 pro = PRO_DMOD;\r\nu8 b[4];\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = state->i2c_addr + (pro << 1), .flags = 0,\r\n.buf = b, .len = sizeof(b) },\r\n{ .addr = state->i2c_addr + (pro << 1), .flags = I2C_M_RD,\r\n.buf = data, .len = count }\r\n};\r\nb[0] = (u8) reg >> 24;\r\nb[1] = (u8)(reg >> 16) & 0xff;\r\nb[2] = (u8)(reg >> 8) & 0xff;\r\nb[3] = (u8) reg & 0xff;\r\nret = i2c_transfer(state->i2c_adap, msg, 2);\r\nreturn ret;\r\n}\r\nstatic int it913x_read_reg_u8(struct it913x_fe_state *state, u32 reg)\r\n{\r\nint ret;\r\nu8 b[1];\r\nret = it913x_read_reg(state, reg, &b[0], sizeof(b));\r\nreturn (ret < 0) ? -ENODEV : b[0];\r\n}\r\nstatic int it913x_write(struct it913x_fe_state *state,\r\nu8 pro, u32 reg, u8 buf[], u8 count)\r\n{\r\nu8 b[256];\r\nstruct i2c_msg msg[1] = {\r\n{ .addr = state->i2c_addr + (pro << 1), .flags = 0,\r\n.buf = b, .len = count + 4 }\r\n};\r\nint ret;\r\nb[0] = (u8) reg >> 24;\r\nb[1] = (u8)(reg >> 16) & 0xff;\r\nb[2] = (u8)(reg >> 8) & 0xff;\r\nb[3] = (u8) reg & 0xff;\r\nmemcpy(&b[4], buf, count);\r\nret = i2c_transfer(state->i2c_adap, msg, 1);\r\nif (ret < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int it913x_write_reg(struct it913x_fe_state *state,\r\nu8 pro, u32 reg, u32 data)\r\n{\r\nint ret;\r\nu8 b[4];\r\nu8 s;\r\nb[0] = data >> 24;\r\nb[1] = (data >> 16) & 0xff;\r\nb[2] = (data >> 8) & 0xff;\r\nb[3] = data & 0xff;\r\nif (data < 0x100)\r\ns = 3;\r\nelse if (data < 0x1000)\r\ns = 2;\r\nelse if (data < 0x100000)\r\ns = 1;\r\nelse\r\ns = 0;\r\nret = it913x_write(state, pro, reg, &b[s], sizeof(b) - s);\r\nreturn ret;\r\n}\r\nstatic int it913x_fe_script_loader(struct it913x_fe_state *state,\r\nstruct it913xset *loadscript)\r\n{\r\nint ret, i;\r\nif (loadscript == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 1000; ++i) {\r\nif (loadscript[i].pro == 0xff)\r\nbreak;\r\nret = it913x_write(state, loadscript[i].pro,\r\nloadscript[i].address,\r\nloadscript[i].reg, loadscript[i].count);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int it913x_init_tuner(struct it913x_fe_state *state)\r\n{\r\nint ret, i, reg;\r\nu8 val, nv_val;\r\nu8 nv[] = {48, 32, 24, 16, 12, 8, 6, 4, 2};\r\nu8 b[2];\r\nreg = it913x_read_reg_u8(state, 0xec86);\r\nswitch (reg) {\r\ncase 0:\r\nstate->tun_clk_mode = reg;\r\nstate->tun_xtal = 2000;\r\nstate->tun_fdiv = 3;\r\nval = 16;\r\nbreak;\r\ncase -ENODEV:\r\nreturn -ENODEV;\r\ncase 1:\r\ndefault:\r\nstate->tun_clk_mode = reg;\r\nstate->tun_xtal = 640;\r\nstate->tun_fdiv = 1;\r\nval = 6;\r\nbreak;\r\n}\r\nreg = it913x_read_reg_u8(state, 0xed03);\r\nif (reg < 0)\r\nreturn -ENODEV;\r\nelse if (reg < sizeof(nv))\r\nnv_val = nv[reg];\r\nelse\r\nnv_val = 2;\r\nfor (i = 0; i < 50; i++) {\r\nret = it913x_read_reg(state, 0xed23, &b[0], sizeof(b));\r\nreg = (b[1] << 8) + b[0];\r\nif (reg > 0)\r\nbreak;\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nudelay(2000);\r\n}\r\nstate->tun_fn_min = state->tun_xtal * reg;\r\nstate->tun_fn_min /= (state->tun_fdiv * nv_val);\r\ndeb_info("Tuner fn_min %d", state->tun_fn_min);\r\nif (state->config->chip_ver > 1)\r\nmsleep(50);\r\nelse {\r\nfor (i = 0; i < 50; i++) {\r\nreg = it913x_read_reg_u8(state, 0xec82);\r\nif (reg > 0)\r\nbreak;\r\nif (reg < 0)\r\nreturn -ENODEV;\r\nudelay(2000);\r\n}\r\n}\r\nreturn it913x_write_reg(state, PRO_DMOD, 0xed81, val);\r\n}\r\nstatic int it9137_set_tuner(struct it913x_fe_state *state,\r\nu32 bandwidth, u32 frequency_m)\r\n{\r\nstruct it913xset *set_tuner = set_it9137_template;\r\nint ret, reg;\r\nu32 frequency = frequency_m / 1000;\r\nu32 freq, temp_f, tmp;\r\nu16 iqik_m_cal;\r\nu16 n_div;\r\nu8 n;\r\nu8 l_band;\r\nu8 lna_band;\r\nu8 bw;\r\nif (state->config->firmware_ver == 1)\r\nset_tuner = set_it9135_template;\r\nelse\r\nset_tuner = set_it9137_template;\r\ndeb_info("Tuner Frequency %d Bandwidth %d", frequency, bandwidth);\r\nif (frequency >= 51000 && frequency <= 440000) {\r\nl_band = 0;\r\nlna_band = 0;\r\n} else if (frequency > 440000 && frequency <= 484000) {\r\nl_band = 1;\r\nlna_band = 1;\r\n} else if (frequency > 484000 && frequency <= 533000) {\r\nl_band = 1;\r\nlna_band = 2;\r\n} else if (frequency > 533000 && frequency <= 587000) {\r\nl_band = 1;\r\nlna_band = 3;\r\n} else if (frequency > 587000 && frequency <= 645000) {\r\nl_band = 1;\r\nlna_band = 4;\r\n} else if (frequency > 645000 && frequency <= 710000) {\r\nl_band = 1;\r\nlna_band = 5;\r\n} else if (frequency > 710000 && frequency <= 782000) {\r\nl_band = 1;\r\nlna_band = 6;\r\n} else if (frequency > 782000 && frequency <= 860000) {\r\nl_band = 1;\r\nlna_band = 7;\r\n} else if (frequency > 1450000 && frequency <= 1492000) {\r\nl_band = 1;\r\nlna_band = 0;\r\n} else if (frequency > 1660000 && frequency <= 1685000) {\r\nl_band = 1;\r\nlna_band = 1;\r\n} else\r\nreturn -EINVAL;\r\nset_tuner[0].reg[0] = lna_band;\r\nswitch (bandwidth) {\r\ncase 5000000:\r\nbw = 0;\r\nbreak;\r\ncase 6000000:\r\nbw = 2;\r\nbreak;\r\ncase 7000000:\r\nbw = 4;\r\nbreak;\r\ndefault:\r\ncase 8000000:\r\nbw = 6;\r\nbreak;\r\n}\r\nset_tuner[1].reg[0] = bw;\r\nset_tuner[2].reg[0] = 0xa0 | (l_band << 3);\r\nif (frequency > 53000 && frequency <= 74000) {\r\nn_div = 48;\r\nn = 0;\r\n} else if (frequency > 74000 && frequency <= 111000) {\r\nn_div = 32;\r\nn = 1;\r\n} else if (frequency > 111000 && frequency <= 148000) {\r\nn_div = 24;\r\nn = 2;\r\n} else if (frequency > 148000 && frequency <= 222000) {\r\nn_div = 16;\r\nn = 3;\r\n} else if (frequency > 222000 && frequency <= 296000) {\r\nn_div = 12;\r\nn = 4;\r\n} else if (frequency > 296000 && frequency <= 445000) {\r\nn_div = 8;\r\nn = 5;\r\n} else if (frequency > 445000 && frequency <= state->tun_fn_min) {\r\nn_div = 6;\r\nn = 6;\r\n} else if (frequency > state->tun_fn_min && frequency <= 950000) {\r\nn_div = 4;\r\nn = 7;\r\n} else if (frequency > 1450000 && frequency <= 1680000) {\r\nn_div = 2;\r\nn = 0;\r\n} else\r\nreturn -EINVAL;\r\nreg = it913x_read_reg_u8(state, 0xed81);\r\niqik_m_cal = (u16)reg * n_div;\r\nif (reg < 0x20) {\r\nif (state->tun_clk_mode == 0)\r\niqik_m_cal = (iqik_m_cal * 9) >> 5;\r\nelse\r\niqik_m_cal >>= 1;\r\n} else {\r\niqik_m_cal = 0x40 - iqik_m_cal;\r\nif (state->tun_clk_mode == 0)\r\niqik_m_cal = ~((iqik_m_cal * 9) >> 5);\r\nelse\r\niqik_m_cal = ~(iqik_m_cal >> 1);\r\n}\r\ntemp_f = frequency * (u32)n_div * (u32)state->tun_fdiv;\r\nfreq = temp_f / state->tun_xtal;\r\ntmp = freq * state->tun_xtal;\r\nif ((temp_f - tmp) >= (state->tun_xtal >> 1))\r\nfreq++;\r\nfreq += (u32) n << 13;\r\ntemp_f = freq + (u32)iqik_m_cal;\r\nset_tuner[3].reg[0] = temp_f & 0xff;\r\nset_tuner[4].reg[0] = (temp_f >> 8) & 0xff;\r\ndeb_info("High Frequency = %04x", temp_f);\r\nset_tuner[5].reg[0] = freq & 0xff;\r\nset_tuner[6].reg[0] = (freq >> 8) & 0xff;\r\ndeb_info("low Frequency = %04x", freq);\r\nret = it913x_fe_script_loader(state, set_tuner);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_fe_select_bw(struct it913x_fe_state *state,\r\nu32 bandwidth, u32 adcFrequency)\r\n{\r\nint ret, i;\r\nu8 buffer[256];\r\nu32 coeff[8];\r\nu16 bfsfcw_fftinx_ratio;\r\nu16 fftinx_bfsfcw_ratio;\r\nu8 count;\r\nu8 bw;\r\nu8 adcmultiplier;\r\ndeb_info("Bandwidth %d Adc %d", bandwidth, adcFrequency);\r\nswitch (bandwidth) {\r\ncase 5000000:\r\nbw = 3;\r\nbreak;\r\ncase 6000000:\r\nbw = 0;\r\nbreak;\r\ncase 7000000:\r\nbw = 1;\r\nbreak;\r\ndefault:\r\ncase 8000000:\r\nbw = 2;\r\nbreak;\r\n}\r\nret = it913x_write_reg(state, PRO_DMOD, REG_BW, bw);\r\nif (state->table == NULL)\r\nreturn -EINVAL;\r\ncoeff[0] = state->table[bw].coeff_1_2048;\r\ncoeff[1] = state->table[bw].coeff_2_2k;\r\ncoeff[2] = state->table[bw].coeff_1_8191;\r\ncoeff[3] = state->table[bw].coeff_1_8192;\r\ncoeff[4] = state->table[bw].coeff_1_8193;\r\ncoeff[5] = state->table[bw].coeff_2_8k;\r\ncoeff[6] = state->table[bw].coeff_1_4096;\r\ncoeff[7] = state->table[bw].coeff_2_4k;\r\nbfsfcw_fftinx_ratio = state->table[bw].bfsfcw_fftinx_ratio;\r\nfftinx_bfsfcw_ratio = state->table[bw].fftinx_bfsfcw_ratio;\r\nret = it913x_read_reg_u8(state, ADC_X_2);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nadcmultiplier = ret;\r\ncount = 0;\r\nfor (i = 0; i < 8; i++) {\r\nif (adcmultiplier == 1)\r\ncoeff[i] /= 2;\r\nbuffer[count++] = (coeff[i] >> 24) & 0x3;\r\nbuffer[count++] = (coeff[i] >> 16) & 0xff;\r\nbuffer[count++] = (coeff[i] >> 8) & 0xff;\r\nbuffer[count++] = coeff[i] & 0xff;\r\n}\r\nbuffer[count++] = bfsfcw_fftinx_ratio & 0xff;\r\nbuffer[count++] = (bfsfcw_fftinx_ratio >> 8) & 0xff;\r\nbuffer[count++] = fftinx_bfsfcw_ratio & 0xff;\r\nbuffer[count++] = (fftinx_bfsfcw_ratio >> 8) & 0xff;\r\nret = it913x_write(state, PRO_DMOD, COEFF_1_2048, buffer, count);\r\nfor (i = 0; i < 42; i += 8)\r\ndebug_data_snipet(0x1, "Buffer", &buffer[i]);\r\nreturn ret;\r\n}\r\nstatic int it913x_fe_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nint ret, i;\r\nfe_status_t old_status = state->it913x_status;\r\n*status = 0;\r\nif (state->it913x_status == 0) {\r\nret = it913x_read_reg_u8(state, EMPTY_CHANNEL_STATUS);\r\nif (ret == 0x1) {\r\n*status |= FE_HAS_SIGNAL;\r\nfor (i = 0; i < 40; i++) {\r\nret = it913x_read_reg_u8(state, MP2IF_SYNC_LK);\r\nif (ret == 0x1)\r\nbreak;\r\nmsleep(25);\r\n}\r\nif (ret == 0x1)\r\n*status |= FE_HAS_CARRIER\r\n| FE_HAS_VITERBI\r\n| FE_HAS_SYNC;\r\nstate->it913x_status = *status;\r\n}\r\n}\r\nif (state->it913x_status & FE_HAS_SYNC) {\r\nret = it913x_read_reg_u8(state, TPSD_LOCK);\r\nif (ret == 0x1)\r\n*status |= FE_HAS_LOCK\r\n| state->it913x_status;\r\nelse\r\nstate->it913x_status = 0;\r\nif (old_status != state->it913x_status)\r\nret = it913x_write_reg(state, PRO_LINK, GPIOH3_O, ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int it913x_get_signal_strength(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nu8 code_rate;\r\nint ret, temp;\r\nu8 lna_gain_os;\r\nret = it913x_read_reg_u8(state, VAR_P_INBAND);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state->frequency < 300000000)\r\nlna_gain_os = 7;\r\nelse\r\nlna_gain_os = 14;\r\ntemp = (ret - 100) - lna_gain_os;\r\nif (state->priority == PRIORITY_HIGH)\r\ncode_rate = p->code_rate_HP;\r\nelse\r\ncode_rate = p->code_rate_LP;\r\nif (code_rate >= ARRAY_SIZE(it913x_qpsk_pval))\r\nreturn -EINVAL;\r\ndeb_info("Reg VAR_P_INBAND:%d Calc Offset Value:%d", ret, temp);\r\nswitch (p->modulation) {\r\ncase QPSK:\r\ntemp -= it913x_qpsk_pval[code_rate];\r\nbreak;\r\ncase QAM_16:\r\ntemp -= it913x_16qam_pval[code_rate];\r\nbreak;\r\ncase QAM_64:\r\ntemp -= it913x_64qam_pval[code_rate];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (temp < -15)\r\nret = 0;\r\nelse if ((-15 <= temp) && (temp < 0))\r\nret = (2 * (temp + 15)) / 3;\r\nelse if ((0 <= temp) && (temp < 20))\r\nret = 4 * temp + 10;\r\nelse if ((20 <= temp) && (temp < 35))\r\nret = (2 * (temp - 20)) / 3 + 90;\r\nelse if (temp >= 35)\r\nret = 100;\r\ndeb_info("Signal Strength :%d", ret);\r\nreturn ret;\r\n}\r\nstatic int it913x_fe_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\nif (state->config->read_slevel) {\r\nif (state->it913x_status & FE_HAS_SIGNAL)\r\nret = it913x_read_reg_u8(state, SIGNAL_LEVEL);\r\n} else\r\nret = it913x_get_signal_strength(fe);\r\nif (ret >= 0)\r\n*strength = (u16)((u32)ret * 0xffff / 0x64);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_fe_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 reg[3];\r\nu32 snr_val, snr_min, snr_max;\r\nu32 temp;\r\nret = it913x_read_reg(state, 0x2c, reg, sizeof(reg));\r\nsnr_val = (u32)(reg[2] << 16) | (reg[1] << 8) | reg[0];\r\nret |= it913x_read_reg(state, 0xf78b, reg, 1);\r\nif (reg[0])\r\nsnr_val /= reg[0];\r\nif (state->transmission_mode == TRANSMISSION_MODE_2K)\r\nsnr_val *= 4;\r\nelse if (state->transmission_mode == TRANSMISSION_MODE_4K)\r\nsnr_val *= 2;\r\nif (state->constellation == QPSK) {\r\nsnr_min = 0xb4711;\r\nsnr_max = 0x191451;\r\n} else if (state->constellation == QAM_16) {\r\nsnr_min = 0x4f0d5;\r\nsnr_max = 0xc7925;\r\n} else if (state->constellation == QAM_64) {\r\nsnr_min = 0x256d0;\r\nsnr_max = 0x626be;\r\n} else\r\nreturn -EINVAL;\r\nif (snr_val < snr_min)\r\n*snr = 0;\r\nelse if (snr_val < snr_max) {\r\ntemp = (snr_val - snr_min) >> 5;\r\ntemp *= 0xffff;\r\ntemp /= (snr_max - snr_min) >> 5;\r\n*snr = (u16)temp;\r\n} else\r\n*snr = 0xffff;\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_fe_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nu8 reg[5];\r\nit913x_read_reg(state, RSD_ABORT_PKT_LSB, reg, sizeof(reg));\r\nstate->ucblocks += (u32)(reg[1] << 8) | reg[0];\r\n*ber = (u32)(reg[4] << 16) | (reg[3] << 8) | reg[2];\r\nreturn 0;\r\n}\r\nstatic int it913x_fe_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 reg[2];\r\nret = it913x_read_reg(state, RSD_ABORT_PKT_LSB, reg, sizeof(reg));\r\nstate->ucblocks += (u32)(reg[1] << 8) | reg[0];\r\n*ucblocks = state->ucblocks;\r\nreturn ret;\r\n}\r\nstatic int it913x_fe_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nu8 reg[8];\r\nit913x_read_reg(state, REG_TPSD_TX_MODE, reg, sizeof(reg));\r\nif (reg[3] < 3)\r\np->modulation = fe_con[reg[3]];\r\nif (reg[0] < 3)\r\np->transmission_mode = fe_mode[reg[0]];\r\nif (reg[1] < 4)\r\np->guard_interval = fe_gi[reg[1]];\r\nif (reg[2] < 4)\r\np->hierarchy = fe_hi[reg[2]];\r\nstate->priority = reg[5];\r\np->code_rate_HP = (reg[6] < 6) ? fe_code[reg[6]] : FEC_NONE;\r\np->code_rate_LP = (reg[7] < 6) ? fe_code[reg[7]] : FEC_NONE;\r\nstate->constellation = p->modulation;\r\nstate->transmission_mode = p->transmission_mode;\r\nreturn 0;\r\n}\r\nstatic int it913x_fe_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nint i;\r\nu8 empty_ch, last_ch;\r\nstate->it913x_status = 0;\r\nit913x_fe_select_bw(state, p->bandwidth_hz,\r\nstate->adcFrequency);\r\nit913x_write_reg(state, PRO_LINK, TRAINING_MODE, 0x0);\r\nit913x_write_reg(state, PRO_DMOD, EMPTY_CHANNEL_STATUS, 0x0);\r\nit913x_write_reg(state, PRO_DMOD, MP2IF_SYNC_LK, 0x0);\r\nit913x_write_reg(state, PRO_LINK, GPIOH3_O, 0x1);\r\nif ((p->frequency >= 51000000) && (p->frequency <= 230000000))\r\ni = 0;\r\nelse if ((p->frequency >= 350000000) && (p->frequency <= 900000000))\r\ni = 1;\r\nelse if ((p->frequency >= 1450000000) && (p->frequency <= 1680000000))\r\ni = 2;\r\nelse\r\nreturn -EOPNOTSUPP;\r\nit913x_write_reg(state, PRO_DMOD, FREE_BAND, i);\r\ndeb_info("Frontend Set Tuner Type %02x", state->tuner_type);\r\nswitch (state->tuner_type) {\r\ncase IT9135_38:\r\ncase IT9135_51:\r\ncase IT9135_52:\r\ncase IT9135_60:\r\ncase IT9135_61:\r\ncase IT9135_62:\r\nit9137_set_tuner(state,\r\np->bandwidth_hz, p->frequency);\r\nbreak;\r\ndefault:\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nbreak;\r\n}\r\nit913x_write_reg(state, PRO_LINK, GPIOH3_O, 0x0);\r\nit913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x0);\r\nlast_ch = 2;\r\nfor (i = 0; i < 40; ++i) {\r\nempty_ch = it913x_read_reg_u8(state, EMPTY_CHANNEL_STATUS);\r\nif (last_ch == 1 && empty_ch == 1)\r\nbreak;\r\nif (last_ch == 2 && empty_ch == 2)\r\nreturn 0;\r\nlast_ch = empty_ch;\r\nmsleep(25);\r\n}\r\nfor (i = 0; i < 40; ++i) {\r\nif (it913x_read_reg_u8(state, D_TPSD_LOCK) == 1)\r\nbreak;\r\nmsleep(25);\r\n}\r\nstate->frequency = p->frequency;\r\nreturn 0;\r\n}\r\nstatic int it913x_fe_suspend(struct it913x_fe_state *state)\r\n{\r\nint ret, i;\r\nu8 b;\r\nret = it913x_write_reg(state, PRO_DMOD, SUSPEND_FLAG, 0x1);\r\nret |= it913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x0);\r\nfor (i = 0; i < 128; i++) {\r\nret = it913x_read_reg(state, SUSPEND_FLAG, &b, 1);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nif (b == 0)\r\nbreak;\r\n}\r\nret |= it913x_write_reg(state, PRO_DMOD, AFE_MEM0, 0x8);\r\nret |= it913x_write_reg(state, PRO_LINK, GPIOH3_O, 0x0);\r\nret |= it913x_fe_script_loader(state, it9137_tuner_off);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nreturn it913x_fe_suspend(state);\r\n}\r\nstatic u32 compute_div(u32 a, u32 b, u32 x)\r\n{\r\nu32 res = 0;\r\nu32 c = 0;\r\nu32 i = 0;\r\nif (a > b) {\r\nc = a / b;\r\na = a - c * b;\r\n}\r\nfor (i = 0; i < x; i++) {\r\nif (a >= b) {\r\nres += 1;\r\na -= b;\r\n}\r\na <<= 1;\r\nres <<= 1;\r\n}\r\nres = (c << x) + res;\r\nreturn res;\r\n}\r\nstatic int it913x_fe_start(struct it913x_fe_state *state)\r\n{\r\nstruct it913xset *set_lna;\r\nstruct it913xset *set_mode;\r\nint ret;\r\nu8 adf = (state->config->adf & 0xf);\r\nu32 adc, xtal;\r\nu8 b[4];\r\nif (state->config->chip_ver == 1)\r\nret = it913x_init_tuner(state);\r\ninfo("ADF table value :%02x", adf);\r\nif (adf < 10) {\r\nstate->crystalFrequency = fe_clockTable[adf].xtal ;\r\nstate->table = fe_clockTable[adf].table;\r\nstate->adcFrequency = state->table->adcFrequency;\r\nadc = compute_div(state->adcFrequency, 1000000ul, 19ul);\r\nxtal = compute_div(state->crystalFrequency, 1000000ul, 19ul);\r\n} else\r\nreturn -EINVAL;\r\nret = it913x_write_reg(state, PRO_LINK, GPIOH3_EN, 0x1);\r\nret |= it913x_write_reg(state, PRO_LINK, GPIOH3_ON, 0x1);\r\nret |= it913x_write_reg(state, PRO_LINK, GPIOH3_O, 0x1);\r\nret |= it913x_write_reg(state, PRO_LINK, 0xf641, state->tuner_type);\r\nret |= it913x_write_reg(state, PRO_DMOD, 0xf5ca, 0x01);\r\nret |= it913x_write_reg(state, PRO_DMOD, 0xf715, 0x01);\r\nb[0] = xtal & 0xff;\r\nb[1] = (xtal >> 8) & 0xff;\r\nb[2] = (xtal >> 16) & 0xff;\r\nb[3] = (xtal >> 24);\r\nret |= it913x_write(state, PRO_DMOD, XTAL_CLK, b , 4);\r\nb[0] = adc & 0xff;\r\nb[1] = (adc >> 8) & 0xff;\r\nb[2] = (adc >> 16) & 0xff;\r\nret |= it913x_write(state, PRO_DMOD, ADC_FREQ, b, 3);\r\nif (state->config->adc_x2)\r\nret |= it913x_write_reg(state, PRO_DMOD, ADC_X_2, 0x01);\r\nb[0] = 0;\r\nb[1] = 0;\r\nb[2] = 0;\r\nret |= it913x_write(state, PRO_DMOD, 0x0029, b, 3);\r\ninfo("Crystal Frequency :%d Adc Frequency :%d ADC X2: %02x",\r\nstate->crystalFrequency, state->adcFrequency,\r\nstate->config->adc_x2);\r\ndeb_info("Xtal value :%04x Adc value :%04x", xtal, adc);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nif (state->config->chip_ver > 1)\r\nret = it913x_fe_script_loader(state, it9135_v2);\r\nelse\r\nret = it913x_fe_script_loader(state, it9135_v1);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (state->tuner_type) {\r\ncase IT9135_51:\r\nset_lna = it9135_51;\r\nbreak;\r\ncase IT9135_52:\r\nset_lna = it9135_52;\r\nbreak;\r\ncase IT9135_60:\r\nset_lna = it9135_60;\r\nbreak;\r\ncase IT9135_61:\r\nset_lna = it9135_61;\r\nbreak;\r\ncase IT9135_62:\r\nset_lna = it9135_62;\r\nbreak;\r\ncase IT9135_38:\r\ndefault:\r\nset_lna = it9135_38;\r\n}\r\ninfo("Tuner LNA type :%02x", state->tuner_type);\r\nret = it913x_fe_script_loader(state, set_lna);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state->config->chip_ver == 2) {\r\nret = it913x_write_reg(state, PRO_DMOD, TRIGGER_OFSM, 0x1);\r\nret |= it913x_write_reg(state, PRO_LINK, PADODPU, 0x0);\r\nret |= it913x_write_reg(state, PRO_LINK, AGC_O_D, 0x0);\r\nret |= it913x_init_tuner(state);\r\n}\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nset_mode = set_solo_fe;\r\nret |= it913x_fe_script_loader(state, set_mode);\r\nret |= it913x_fe_suspend(state);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int it913x_fe_init(struct dvb_frontend *fe)\r\n{\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\nret = it913x_write_reg(state, PRO_DMOD, 0xec40, 0x1);\r\nret |= it913x_fe_script_loader(state, init_1);\r\nret |= it913x_write_reg(state, PRO_DMOD, AFE_MEM0, 0x0);\r\nret |= it913x_write_reg(state, PRO_DMOD, 0xfba8, 0x0);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic void it913x_fe_release(struct dvb_frontend *fe)\r\n{\r\nstruct it913x_fe_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *it913x_fe_attach(struct i2c_adapter *i2c_adap,\r\nu8 i2c_addr, struct ite_config *config)\r\n{\r\nstruct it913x_fe_state *state = NULL;\r\nint ret;\r\nstate = kzalloc(sizeof(struct it913x_fe_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nif (config == NULL)\r\ngoto error;\r\nstate->i2c_adap = i2c_adap;\r\nstate->i2c_addr = i2c_addr;\r\nstate->config = config;\r\nswitch (state->config->tuner_id_0) {\r\ncase IT9135_51:\r\ncase IT9135_52:\r\ncase IT9135_60:\r\ncase IT9135_61:\r\ncase IT9135_62:\r\nstate->tuner_type = state->config->tuner_id_0;\r\nbreak;\r\ndefault:\r\ncase IT9135_38:\r\nstate->tuner_type = IT9135_38;\r\n}\r\nret = it913x_fe_start(state);\r\nif (ret < 0)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &it913x_fe_ofdm_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
