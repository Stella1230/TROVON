int drm_gem_prime_handle_to_fd(struct drm_device *dev,\r\nstruct drm_file *file_priv, uint32_t handle, uint32_t flags,\r\nint *prime_fd)\r\n{\r\nstruct drm_gem_object *obj;\r\nvoid *buf;\r\nint ret;\r\nobj = drm_gem_object_lookup(dev, file_priv, handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nmutex_lock(&file_priv->prime.lock);\r\nif (obj->import_attach) {\r\nget_dma_buf(obj->import_attach->dmabuf);\r\n*prime_fd = dma_buf_fd(obj->import_attach->dmabuf, flags);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nmutex_unlock(&file_priv->prime.lock);\r\nreturn 0;\r\n}\r\nif (obj->export_dma_buf) {\r\nget_dma_buf(obj->export_dma_buf);\r\n*prime_fd = dma_buf_fd(obj->export_dma_buf, flags);\r\ndrm_gem_object_unreference_unlocked(obj);\r\n} else {\r\nbuf = dev->driver->gem_prime_export(dev, obj, flags);\r\nif (IS_ERR(buf)) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nmutex_unlock(&file_priv->prime.lock);\r\nreturn PTR_ERR(buf);\r\n}\r\nobj->export_dma_buf = buf;\r\n*prime_fd = dma_buf_fd(buf, flags);\r\n}\r\nret = drm_prime_add_imported_buf_handle(&file_priv->prime,\r\nobj->export_dma_buf, handle);\r\nif (ret) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nmutex_unlock(&file_priv->prime.lock);\r\nreturn ret;\r\n}\r\nmutex_unlock(&file_priv->prime.lock);\r\nreturn 0;\r\n}\r\nint drm_gem_prime_fd_to_handle(struct drm_device *dev,\r\nstruct drm_file *file_priv, int prime_fd, uint32_t *handle)\r\n{\r\nstruct dma_buf *dma_buf;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\ndma_buf = dma_buf_get(prime_fd);\r\nif (IS_ERR(dma_buf))\r\nreturn PTR_ERR(dma_buf);\r\nmutex_lock(&file_priv->prime.lock);\r\nret = drm_prime_lookup_imported_buf_handle(&file_priv->prime,\r\ndma_buf, handle);\r\nif (!ret) {\r\nret = 0;\r\ngoto out_put;\r\n}\r\nobj = dev->driver->gem_prime_import(dev, dma_buf);\r\nif (IS_ERR(obj)) {\r\nret = PTR_ERR(obj);\r\ngoto out_put;\r\n}\r\nret = drm_gem_handle_create(file_priv, obj, handle);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nif (ret)\r\ngoto out_put;\r\nret = drm_prime_add_imported_buf_handle(&file_priv->prime,\r\ndma_buf, *handle);\r\nif (ret)\r\ngoto fail;\r\nmutex_unlock(&file_priv->prime.lock);\r\nreturn 0;\r\nfail:\r\ndrm_gem_object_handle_unreference_unlocked(obj);\r\nout_put:\r\ndma_buf_put(dma_buf);\r\nmutex_unlock(&file_priv->prime.lock);\r\nreturn ret;\r\n}\r\nint drm_prime_handle_to_fd_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_prime_handle *args = data;\r\nuint32_t flags;\r\nif (!drm_core_check_feature(dev, DRIVER_PRIME))\r\nreturn -EINVAL;\r\nif (!dev->driver->prime_handle_to_fd)\r\nreturn -ENOSYS;\r\nif (args->flags & ~DRM_CLOEXEC)\r\nreturn -EINVAL;\r\nflags = args->flags & DRM_CLOEXEC;\r\nreturn dev->driver->prime_handle_to_fd(dev, file_priv,\r\nargs->handle, flags, &args->fd);\r\n}\r\nint drm_prime_fd_to_handle_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_prime_handle *args = data;\r\nif (!drm_core_check_feature(dev, DRIVER_PRIME))\r\nreturn -EINVAL;\r\nif (!dev->driver->prime_fd_to_handle)\r\nreturn -ENOSYS;\r\nreturn dev->driver->prime_fd_to_handle(dev, file_priv,\r\nargs->fd, &args->handle);\r\n}\r\nstruct sg_table *drm_prime_pages_to_sg(struct page **pages, int nr_pages)\r\n{\r\nstruct sg_table *sg = NULL;\r\nstruct scatterlist *iter;\r\nint i;\r\nint ret;\r\nsg = kmalloc(sizeof(struct sg_table), GFP_KERNEL);\r\nif (!sg)\r\ngoto out;\r\nret = sg_alloc_table(sg, nr_pages, GFP_KERNEL);\r\nif (ret)\r\ngoto out;\r\nfor_each_sg(sg->sgl, iter, nr_pages, i)\r\nsg_set_page(iter, pages[i], PAGE_SIZE, 0);\r\nreturn sg;\r\nout:\r\nkfree(sg);\r\nreturn NULL;\r\n}\r\nint drm_prime_sg_to_page_addr_arrays(struct sg_table *sgt, struct page **pages,\r\ndma_addr_t *addrs, int max_pages)\r\n{\r\nunsigned count;\r\nstruct scatterlist *sg;\r\nstruct page *page;\r\nu32 len, offset;\r\nint pg_index;\r\ndma_addr_t addr;\r\npg_index = 0;\r\nfor_each_sg(sgt->sgl, sg, sgt->nents, count) {\r\nlen = sg->length;\r\noffset = sg->offset;\r\npage = sg_page(sg);\r\naddr = sg_dma_address(sg);\r\nwhile (len > 0) {\r\nif (WARN_ON(pg_index >= max_pages))\r\nreturn -1;\r\npages[pg_index] = page;\r\nif (addrs)\r\naddrs[pg_index] = addr;\r\npage++;\r\naddr += PAGE_SIZE;\r\nlen -= PAGE_SIZE;\r\npg_index++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid drm_prime_gem_destroy(struct drm_gem_object *obj, struct sg_table *sg)\r\n{\r\nstruct dma_buf_attachment *attach;\r\nstruct dma_buf *dma_buf;\r\nattach = obj->import_attach;\r\nif (sg)\r\ndma_buf_unmap_attachment(attach, sg, DMA_BIDIRECTIONAL);\r\ndma_buf = attach->dmabuf;\r\ndma_buf_detach(attach->dmabuf, attach);\r\ndma_buf_put(dma_buf);\r\n}\r\nvoid drm_prime_init_file_private(struct drm_prime_file_private *prime_fpriv)\r\n{\r\nINIT_LIST_HEAD(&prime_fpriv->head);\r\nmutex_init(&prime_fpriv->lock);\r\n}\r\nvoid drm_prime_destroy_file_private(struct drm_prime_file_private *prime_fpriv)\r\n{\r\nstruct drm_prime_member *member, *safe;\r\nlist_for_each_entry_safe(member, safe, &prime_fpriv->head, entry) {\r\nlist_del(&member->entry);\r\nkfree(member);\r\n}\r\n}\r\nint drm_prime_add_imported_buf_handle(struct drm_prime_file_private *prime_fpriv, struct dma_buf *dma_buf, uint32_t handle)\r\n{\r\nstruct drm_prime_member *member;\r\nmember = kmalloc(sizeof(*member), GFP_KERNEL);\r\nif (!member)\r\nreturn -ENOMEM;\r\nmember->dma_buf = dma_buf;\r\nmember->handle = handle;\r\nlist_add(&member->entry, &prime_fpriv->head);\r\nreturn 0;\r\n}\r\nint drm_prime_lookup_imported_buf_handle(struct drm_prime_file_private *prime_fpriv, struct dma_buf *dma_buf, uint32_t *handle)\r\n{\r\nstruct drm_prime_member *member;\r\nlist_for_each_entry(member, &prime_fpriv->head, entry) {\r\nif (member->dma_buf == dma_buf) {\r\n*handle = member->handle;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nvoid drm_prime_remove_imported_buf_handle(struct drm_prime_file_private *prime_fpriv, struct dma_buf *dma_buf)\r\n{\r\nstruct drm_prime_member *member, *safe;\r\nmutex_lock(&prime_fpriv->lock);\r\nlist_for_each_entry_safe(member, safe, &prime_fpriv->head, entry) {\r\nif (member->dma_buf == dma_buf) {\r\nlist_del(&member->entry);\r\nkfree(member);\r\n}\r\n}\r\nmutex_unlock(&prime_fpriv->lock);\r\n}
