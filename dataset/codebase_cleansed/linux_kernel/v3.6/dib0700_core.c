int dib0700_get_version(struct dvb_usb_device *d, u32 *hwversion,\r\nu32 *romversion, u32 *ramversion, u32 *fwtype)\r\n{\r\nstruct dib0700_state *st = d->priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nreturn -EINTR;\r\n}\r\nret = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\r\nREQUEST_GET_VERSION,\r\nUSB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\r\nst->buf, 16, USB_CTRL_GET_TIMEOUT);\r\nif (hwversion != NULL)\r\n*hwversion = (st->buf[0] << 24) | (st->buf[1] << 16) |\r\n(st->buf[2] << 8) | st->buf[3];\r\nif (romversion != NULL)\r\n*romversion = (st->buf[4] << 24) | (st->buf[5] << 16) |\r\n(st->buf[6] << 8) | st->buf[7];\r\nif (ramversion != NULL)\r\n*ramversion = (st->buf[8] << 24) | (st->buf[9] << 16) |\r\n(st->buf[10] << 8) | st->buf[11];\r\nif (fwtype != NULL)\r\n*fwtype = (st->buf[12] << 24) | (st->buf[13] << 16) |\r\n(st->buf[14] << 8) | st->buf[15];\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int dib0700_ctrl_wr(struct dvb_usb_device *d, u8 *tx, u8 txlen)\r\n{\r\nint status;\r\ndeb_data(">>> ");\r\ndebug_dump(tx, txlen, deb_data);\r\nstatus = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev,0),\r\ntx[0], USB_TYPE_VENDOR | USB_DIR_OUT, 0, 0, tx, txlen,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (status != txlen)\r\ndeb_data("ep 0 write error (status = %d, len: %d)\n",status,txlen);\r\nreturn status < 0 ? status : 0;\r\n}\r\nint dib0700_ctrl_rd(struct dvb_usb_device *d, u8 *tx, u8 txlen, u8 *rx, u8 rxlen)\r\n{\r\nu16 index, value;\r\nint status;\r\nif (txlen < 2) {\r\nerr("tx buffer length is smaller than 2. Makes no sense.");\r\nreturn -EINVAL;\r\n}\r\nif (txlen > 4) {\r\nerr("tx buffer length is larger than 4. Not supported.");\r\nreturn -EINVAL;\r\n}\r\ndeb_data(">>> ");\r\ndebug_dump(tx,txlen,deb_data);\r\nvalue = ((txlen - 2) << 8) | tx[1];\r\nindex = 0;\r\nif (txlen > 2)\r\nindex |= (tx[2] << 8);\r\nif (txlen > 3)\r\nindex |= tx[3];\r\nstatus = usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev,0), tx[0],\r\nUSB_TYPE_VENDOR | USB_DIR_IN, value, index, rx, rxlen,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (status < 0)\r\ndeb_info("ep 0 read error (status = %d)\n",status);\r\ndeb_data("<<< ");\r\ndebug_dump(rx, rxlen, deb_data);\r\nreturn status;\r\n}\r\nint dib0700_set_gpio(struct dvb_usb_device *d, enum dib07x0_gpios gpio, u8 gpio_dir, u8 gpio_val)\r\n{\r\nstruct dib0700_state *st = d->priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nreturn -EINTR;\r\n}\r\nst->buf[0] = REQUEST_SET_GPIO;\r\nst->buf[1] = gpio;\r\nst->buf[2] = ((gpio_dir & 0x01) << 7) | ((gpio_val & 0x01) << 6);\r\nret = dib0700_ctrl_wr(d, st->buf, 3);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int dib0700_set_usb_xfer_len(struct dvb_usb_device *d, u16 nb_ts_packets)\r\n{\r\nstruct dib0700_state *st = d->priv;\r\nint ret;\r\nif (st->fw_version >= 0x10201) {\r\nif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nreturn -EINTR;\r\n}\r\nst->buf[0] = REQUEST_SET_USB_XFER_LEN;\r\nst->buf[1] = (nb_ts_packets >> 8) & 0xff;\r\nst->buf[2] = nb_ts_packets & 0xff;\r\ndeb_info("set the USB xfer len to %i Ts packet\n", nb_ts_packets);\r\nret = dib0700_ctrl_wr(d, st->buf, 3);\r\nmutex_unlock(&d->usb_mutex);\r\n} else {\r\ndeb_info("this firmware does not allow to change the USB xfer len\n");\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib0700_i2c_xfer_new(struct i2c_adapter *adap, struct i2c_msg *msg,\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct dib0700_state *st = d->priv;\r\nuint8_t bus_mode = 1;\r\nuint8_t gen_mode = 0;\r\nuint8_t en_start = 0;\r\nuint8_t en_stop = 0;\r\nint result, i;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EINTR;\r\nfor (i = 0; i < num; i++) {\r\nif (i == 0) {\r\nen_start = 1;\r\n} else if (!(msg[i].flags & I2C_M_NOSTART)) {\r\nen_start = 1;\r\n} else {\r\nen_start = 0;\r\n}\r\nif (i == (num - 1)) {\r\nen_stop = 1;\r\n}\r\nif (msg[i].flags & I2C_M_RD) {\r\nu16 index, value;\r\nuint8_t i2c_dest;\r\ni2c_dest = (msg[i].addr << 1);\r\nvalue = ((en_start << 7) | (en_stop << 6) |\r\n(msg[i].len & 0x3F)) << 8 | i2c_dest;\r\nindex = ((gen_mode << 6) & 0xC0) |\r\n((bus_mode << 4) & 0x30);\r\nresult = usb_control_msg(d->udev,\r\nusb_rcvctrlpipe(d->udev, 0),\r\nREQUEST_NEW_I2C_READ,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\nvalue, index, msg[i].buf,\r\nmsg[i].len,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (result < 0) {\r\ndeb_info("i2c read error (status = %d)\n", result);\r\nbreak;\r\n}\r\ndeb_data("<<< ");\r\ndebug_dump(msg[i].buf, msg[i].len, deb_data);\r\n} else {\r\nif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn -EINTR;\r\n}\r\nst->buf[0] = REQUEST_NEW_I2C_WRITE;\r\nst->buf[1] = msg[i].addr << 1;\r\nst->buf[2] = (en_start << 7) | (en_stop << 6) |\r\n(msg[i].len & 0x3F);\r\nst->buf[3] = ((gen_mode << 6) & 0xC0) |\r\n((bus_mode << 4) & 0x30);\r\nmemcpy(&st->buf[4], msg[i].buf, msg[i].len);\r\ndeb_data(">>> ");\r\ndebug_dump(st->buf, msg[i].len + 4, deb_data);\r\nresult = usb_control_msg(d->udev,\r\nusb_sndctrlpipe(d->udev, 0),\r\nREQUEST_NEW_I2C_WRITE,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\n0, 0, st->buf, msg[i].len + 4,\r\nUSB_CTRL_GET_TIMEOUT);\r\nmutex_unlock(&d->usb_mutex);\r\nif (result < 0) {\r\ndeb_info("i2c write error (status = %d)\n", result);\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic int dib0700_i2c_xfer_legacy(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct dib0700_state *st = d->priv;\r\nint i,len;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EINTR;\r\nif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn -EINTR;\r\n}\r\nfor (i = 0; i < num; i++) {\r\nst->buf[1] = msg[i].addr << 1;\r\nmemcpy(&st->buf[2], msg[i].buf, msg[i].len);\r\nif (i+1 < num && (msg[i+1].flags & I2C_M_RD)) {\r\nst->buf[0] = REQUEST_I2C_READ;\r\nst->buf[1] |= 1;\r\nlen = dib0700_ctrl_rd(d, st->buf, msg[i].len + 2,\r\nmsg[i+1].buf, msg[i+1].len);\r\nif (len <= 0) {\r\ndeb_info("I2C read failed on address 0x%02x\n",\r\nmsg[i].addr);\r\nbreak;\r\n}\r\nmsg[i+1].len = len;\r\ni++;\r\n} else {\r\nst->buf[0] = REQUEST_I2C_WRITE;\r\nif (dib0700_ctrl_wr(d, st->buf, msg[i].len + 2) < 0)\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&d->usb_mutex);\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic int dib0700_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct dib0700_state *st = d->priv;\r\nif (st->fw_use_new_i2c_api == 1) {\r\nreturn dib0700_i2c_xfer_new(adap, msg, num);\r\n} else {\r\nreturn dib0700_i2c_xfer_legacy(adap, msg, num);\r\n}\r\n}\r\nstatic u32 dib0700_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nint dib0700_identify_state(struct usb_device *udev, struct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc, int *cold)\r\n{\r\ns16 ret;\r\nu8 *b;\r\nb = kmalloc(16, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nREQUEST_GET_VERSION, USB_TYPE_VENDOR | USB_DIR_IN, 0, 0, b, 16, USB_CTRL_GET_TIMEOUT);\r\ndeb_info("FW GET_VERSION length: %d\n",ret);\r\n*cold = ret <= 0;\r\ndeb_info("cold: %d\n", *cold);\r\nkfree(b);\r\nreturn 0;\r\n}\r\nstatic int dib0700_set_clock(struct dvb_usb_device *d, u8 en_pll,\r\nu8 pll_src, u8 pll_range, u8 clock_gpio3, u16 pll_prediv,\r\nu16 pll_loopdiv, u16 free_div, u16 dsuScaler)\r\n{\r\nstruct dib0700_state *st = d->priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nreturn -EINTR;\r\n}\r\nst->buf[0] = REQUEST_SET_CLOCK;\r\nst->buf[1] = (en_pll << 7) | (pll_src << 6) |\r\n(pll_range << 5) | (clock_gpio3 << 4);\r\nst->buf[2] = (pll_prediv >> 8) & 0xff;\r\nst->buf[3] = pll_prediv & 0xff;\r\nst->buf[4] = (pll_loopdiv >> 8) & 0xff;\r\nst->buf[5] = pll_loopdiv & 0xff;\r\nst->buf[6] = (free_div >> 8) & 0xff;\r\nst->buf[7] = free_div & 0xff;\r\nst->buf[8] = (dsuScaler >> 8) & 0xff;\r\nst->buf[9] = dsuScaler & 0xff;\r\nret = dib0700_ctrl_wr(d, st->buf, 10);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nint dib0700_set_i2c_speed(struct dvb_usb_device *d, u16 scl_kHz)\r\n{\r\nstruct dib0700_state *st = d->priv;\r\nu16 divider;\r\nint ret;\r\nif (scl_kHz == 0)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nreturn -EINTR;\r\n}\r\nst->buf[0] = REQUEST_SET_I2C_PARAM;\r\ndivider = (u16) (30000 / scl_kHz);\r\nst->buf[1] = 0;\r\nst->buf[2] = (u8) (divider >> 8);\r\nst->buf[3] = (u8) (divider & 0xff);\r\ndivider = (u16) (72000 / scl_kHz);\r\nst->buf[4] = (u8) (divider >> 8);\r\nst->buf[5] = (u8) (divider & 0xff);\r\ndivider = (u16) (72000 / scl_kHz);\r\nst->buf[6] = (u8) (divider >> 8);\r\nst->buf[7] = (u8) (divider & 0xff);\r\ndeb_info("setting I2C speed: %04x %04x %04x (%d kHz).",\r\n(st->buf[2] << 8) | (st->buf[3]), (st->buf[4] << 8) |\r\nst->buf[5], (st->buf[6] << 8) | st->buf[7], scl_kHz);\r\nret = dib0700_ctrl_wr(d, st->buf, 8);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nint dib0700_ctrl_clock(struct dvb_usb_device *d, u32 clk_MHz, u8 clock_out_gp3)\r\n{\r\nswitch (clk_MHz) {\r\ncase 72: dib0700_set_clock(d, 1, 0, 1, clock_out_gp3, 2, 24, 0, 0x4c); break;\r\ndefault: return -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib0700_jumpram(struct usb_device *udev, u32 address)\r\n{\r\nint ret = 0, actlen;\r\nu8 *buf;\r\nbuf = kmalloc(8, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = REQUEST_JUMPRAM;\r\nbuf[1] = 0;\r\nbuf[2] = 0;\r\nbuf[3] = 0;\r\nbuf[4] = (address >> 24) & 0xff;\r\nbuf[5] = (address >> 16) & 0xff;\r\nbuf[6] = (address >> 8) & 0xff;\r\nbuf[7] = address & 0xff;\r\nif ((ret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, 0x01),buf,8,&actlen,1000)) < 0) {\r\ndeb_fw("jumpram to 0x%x failed\n",address);\r\ngoto out;\r\n}\r\nif (actlen != 8) {\r\ndeb_fw("jumpram to 0x%x failed\n",address);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint dib0700_download_firmware(struct usb_device *udev, const struct firmware *fw)\r\n{\r\nstruct hexline hx;\r\nint pos = 0, ret, act_len, i, adap_num;\r\nu8 *buf;\r\nu32 fw_version;\r\nbuf = kmalloc(260, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nwhile ((ret = dvb_usb_get_hexline(fw, &hx, &pos)) > 0) {\r\ndeb_fwdata("writing to address 0x%08x (buffer: 0x%02x %02x)\n",\r\nhx.addr, hx.len, hx.chk);\r\nbuf[0] = hx.len;\r\nbuf[1] = (hx.addr >> 8) & 0xff;\r\nbuf[2] = hx.addr & 0xff;\r\nbuf[3] = hx.type;\r\nmemcpy(&buf[4],hx.data,hx.len);\r\nbuf[4+hx.len] = hx.chk;\r\nret = usb_bulk_msg(udev,\r\nusb_sndbulkpipe(udev, 0x01),\r\nbuf,\r\nhx.len + 5,\r\n&act_len,\r\n1000);\r\nif (ret < 0) {\r\nerr("firmware download failed at %d with %d",pos,ret);\r\ngoto out;\r\n}\r\n}\r\nif (ret == 0) {\r\nif ((ret = dib0700_jumpram(udev, 0x70000000)) == 0) {\r\ninfo("firmware started successfully.");\r\nmsleep(500);\r\n}\r\n} else\r\nret = -EIO;\r\nif (nb_packet_buffer_size < 1)\r\nnb_packet_buffer_size = 1;\r\nusb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nREQUEST_GET_VERSION,\r\nUSB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\r\nbuf, 16, USB_CTRL_GET_TIMEOUT);\r\nfw_version = (buf[8] << 24) | (buf[9] << 16) | (buf[10] << 8) | buf[11];\r\nfor (i = 0; i < dib0700_device_count; i++) {\r\nfor (adap_num = 0; adap_num < dib0700_devices[i].num_adapters;\r\nadap_num++) {\r\nif (fw_version >= 0x10201) {\r\ndib0700_devices[i].adapter[adap_num].fe[0].stream.u.bulk.buffersize = 188*nb_packet_buffer_size;\r\n} else {\r\ndib0700_devices[i].adapter[adap_num].fe[0].stream.u.bulk.buffersize = ((188*nb_packet_buffer_size+188/2)/512)*512;\r\nif (dib0700_devices[i].adapter[adap_num].fe[0].stream.u.bulk.buffersize < 512)\r\ndib0700_devices[i].adapter[adap_num].fe[0].stream.u.bulk.buffersize = 512;\r\n}\r\n}\r\n}\r\nout:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint dib0700_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct dib0700_state *st = adap->dev->priv;\r\nint ret;\r\nif ((onoff != 0) && (st->fw_version >= 0x10201)) {\r\nret = dib0700_set_usb_xfer_len(adap->dev,\r\nst->nb_packet_buffer_size);\r\nif (ret < 0) {\r\ndeb_info("can not set the USB xfer len\n");\r\nreturn ret;\r\n}\r\n}\r\nif (mutex_lock_interruptible(&adap->dev->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nreturn -EINTR;\r\n}\r\nst->buf[0] = REQUEST_ENABLE_VIDEO;\r\nst->buf[1] = (onoff << 4) | 0x00;\r\nif (st->disable_streaming_master_mode == 1)\r\nst->buf[2] = 0x00;\r\nelse\r\nst->buf[2] = 0x01 << 4;\r\nst->buf[3] = 0x00;\r\ndeb_info("modifying (%d) streaming state for %d\n", onoff, adap->id);\r\nst->channel_state &= ~0x3;\r\nif ((adap->fe_adap[0].stream.props.endpoint != 2)\r\n&& (adap->fe_adap[0].stream.props.endpoint != 3)) {\r\ndeb_info("the endpoint number (%i) is not correct, use the adapter id instead", adap->fe_adap[0].stream.props.endpoint);\r\nif (onoff)\r\nst->channel_state |= 1 << (adap->id);\r\nelse\r\nst->channel_state |= 1 << ~(adap->id);\r\n} else {\r\nif (onoff)\r\nst->channel_state |= 1 << (adap->fe_adap[0].stream.props.endpoint-2);\r\nelse\r\nst->channel_state |= 1 << (3-adap->fe_adap[0].stream.props.endpoint);\r\n}\r\nst->buf[2] |= st->channel_state;\r\ndeb_info("data for streaming: %x %x\n", st->buf[1], st->buf[2]);\r\nret = dib0700_ctrl_wr(adap->dev, st->buf, 4);\r\nmutex_unlock(&adap->dev->usb_mutex);\r\nreturn ret;\r\n}\r\nint dib0700_change_protocol(struct rc_dev *rc, u64 rc_type)\r\n{\r\nstruct dvb_usb_device *d = rc->priv;\r\nstruct dib0700_state *st = d->priv;\r\nint new_proto, ret;\r\nif (mutex_lock_interruptible(&d->usb_mutex) < 0) {\r\nerr("could not acquire lock");\r\nreturn -EINTR;\r\n}\r\nst->buf[0] = REQUEST_SET_RC;\r\nst->buf[1] = 0;\r\nst->buf[2] = 0;\r\nif (rc_type == RC_TYPE_RC5)\r\nnew_proto = 1;\r\nelse if (rc_type == RC_TYPE_NEC)\r\nnew_proto = 0;\r\nelse if (rc_type == RC_TYPE_RC6) {\r\nif (st->fw_version < 0x10200) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnew_proto = 2;\r\n} else {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nst->buf[1] = new_proto;\r\nret = dib0700_ctrl_wr(d, st->buf, 3);\r\nif (ret < 0) {\r\nerr("ir protocol setup failed");\r\ngoto out;\r\n}\r\nd->props.rc.core.protocol = rc_type;\r\nout:\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic void dib0700_rc_urb_completion(struct urb *purb)\r\n{\r\nstruct dvb_usb_device *d = purb->context;\r\nstruct dib0700_rc_response *poll_reply;\r\nu32 uninitialized_var(keycode);\r\nu8 toggle;\r\ndeb_info("%s()\n", __func__);\r\nif (d->rc_dev == NULL) {\r\nkfree(purb->transfer_buffer);\r\nusb_free_urb(purb);\r\nreturn;\r\n}\r\npoll_reply = purb->transfer_buffer;\r\nif (purb->status < 0) {\r\ndeb_info("discontinuing polling\n");\r\nkfree(purb->transfer_buffer);\r\nusb_free_urb(purb);\r\nreturn;\r\n}\r\nif (purb->actual_length != RC_MSG_SIZE_V1_20) {\r\ndeb_info("malformed rc msg size=%d\n", purb->actual_length);\r\ngoto resubmit;\r\n}\r\ndeb_data("IR ID = %02X state = %02X System = %02X %02X Cmd = %02X %02X (len %d)\n",\r\npoll_reply->report_id, poll_reply->data_state,\r\npoll_reply->system, poll_reply->not_system,\r\npoll_reply->data, poll_reply->not_data,\r\npurb->actual_length);\r\nswitch (d->props.rc.core.protocol) {\r\ncase RC_TYPE_NEC:\r\ntoggle = 0;\r\nif ((poll_reply->system == 0x00) && (poll_reply->data == 0x00)\r\n&& (poll_reply->not_data == 0xff)) {\r\npoll_reply->data_state = 2;\r\nbreak;\r\n}\r\nif ((poll_reply->system ^ poll_reply->not_system) != 0xff) {\r\ndeb_data("NEC extended protocol\n");\r\nkeycode = be16_to_cpu(poll_reply->system16) << 8 | poll_reply->data;\r\n} else {\r\ndeb_data("NEC normal protocol\n");\r\nkeycode = poll_reply->system << 8 | poll_reply->data;\r\n}\r\nbreak;\r\ndefault:\r\ndeb_data("RC5 protocol\n");\r\ntoggle = poll_reply->report_id;\r\nkeycode = poll_reply->system << 8 | poll_reply->data;\r\nbreak;\r\n}\r\nif ((poll_reply->data + poll_reply->not_data) != 0xff) {\r\nerr("key failed integrity check: %04x %02x %02x",\r\npoll_reply->system,\r\npoll_reply->data, poll_reply->not_data);\r\ngoto resubmit;\r\n}\r\nrc_keydown(d->rc_dev, keycode, toggle);\r\nresubmit:\r\nmemset(purb->transfer_buffer, 0, RC_MSG_SIZE_V1_20);\r\nusb_submit_urb(purb, GFP_ATOMIC);\r\n}\r\nint dib0700_rc_setup(struct dvb_usb_device *d)\r\n{\r\nstruct dib0700_state *st = d->priv;\r\nstruct urb *purb;\r\nint ret;\r\nif (st->fw_version < 0x10200)\r\nreturn 0;\r\npurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (purb == NULL) {\r\nerr("rc usb alloc urb failed\n");\r\nreturn -ENOMEM;\r\n}\r\npurb->transfer_buffer = kzalloc(RC_MSG_SIZE_V1_20, GFP_KERNEL);\r\nif (purb->transfer_buffer == NULL) {\r\nerr("rc kzalloc failed\n");\r\nusb_free_urb(purb);\r\nreturn -ENOMEM;\r\n}\r\npurb->status = -EINPROGRESS;\r\nusb_fill_bulk_urb(purb, d->udev, usb_rcvbulkpipe(d->udev, 1),\r\npurb->transfer_buffer, RC_MSG_SIZE_V1_20,\r\ndib0700_rc_urb_completion, d);\r\nret = usb_submit_urb(purb, GFP_ATOMIC);\r\nif (ret) {\r\nerr("rc submit urb failed\n");\r\nkfree(purb->transfer_buffer);\r\nusb_free_urb(purb);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib0700_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint i;\r\nstruct dvb_usb_device *dev;\r\nfor (i = 0; i < dib0700_device_count; i++)\r\nif (dvb_usb_device_init(intf, &dib0700_devices[i], THIS_MODULE,\r\n&dev, adapter_nr) == 0) {\r\nstruct dib0700_state *st = dev->priv;\r\nu32 hwversion, romversion, fw_version, fwtype;\r\ndib0700_get_version(dev, &hwversion, &romversion,\r\n&fw_version, &fwtype);\r\ndeb_info("Firmware version: %x, %d, 0x%x, %d\n",\r\nhwversion, romversion, fw_version, fwtype);\r\nst->fw_version = fw_version;\r\nst->nb_packet_buffer_size = (u32)nb_packet_buffer_size;\r\nif (st->fw_version >= 0x10200)\r\ndev->props.rc.core.bulk_mode = true;\r\nelse\r\ndev->props.rc.core.bulk_mode = false;\r\ndib0700_rc_setup(dev);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}
