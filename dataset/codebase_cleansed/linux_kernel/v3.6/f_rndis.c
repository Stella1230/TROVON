static inline struct f_rndis *func_to_rndis(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_rndis, port.func);\r\n}\r\nstatic unsigned int bitrate(struct usb_gadget *g)\r\n{\r\nif (gadget_is_superspeed(g) && g->speed == USB_SPEED_SUPER)\r\nreturn 13 * 1024 * 8 * 1000 * 8;\r\nelse if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)\r\nreturn 13 * 512 * 8 * 1000 * 8;\r\nelse\r\nreturn 19 * 64 * 1 * 1000 * 8;\r\n}\r\nstatic struct sk_buff *rndis_add_header(struct gether *port,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *skb2;\r\nskb2 = skb_realloc_headroom(skb, sizeof(struct rndis_packet_msg_type));\r\nif (skb2)\r\nrndis_add_hdr(skb2);\r\ndev_kfree_skb_any(skb);\r\nreturn skb2;\r\n}\r\nstatic void rndis_response_available(void *_rndis)\r\n{\r\nstruct f_rndis *rndis = _rndis;\r\nstruct usb_request *req = rndis->notify_req;\r\nstruct usb_composite_dev *cdev = rndis->port.func.config->cdev;\r\n__le32 *data = req->buf;\r\nint status;\r\nif (atomic_inc_return(&rndis->notify_count) != 1)\r\nreturn;\r\ndata[0] = cpu_to_le32(1);\r\ndata[1] = cpu_to_le32(0);\r\nstatus = usb_ep_queue(rndis->notify, req, GFP_ATOMIC);\r\nif (status) {\r\natomic_dec(&rndis->notify_count);\r\nDBG(cdev, "notify/0 --> %d\n", status);\r\n}\r\n}\r\nstatic void rndis_response_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_rndis *rndis = req->context;\r\nstruct usb_composite_dev *cdev = rndis->port.func.config->cdev;\r\nint status = req->status;\r\nswitch (status) {\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\natomic_set(&rndis->notify_count, 0);\r\nbreak;\r\ndefault:\r\nDBG(cdev, "RNDIS %s response error %d, %d/%d\n",\r\nep->name, status,\r\nreq->actual, req->length);\r\ncase 0:\r\nif (ep != rndis->notify)\r\nbreak;\r\nif (atomic_dec_and_test(&rndis->notify_count))\r\nbreak;\r\nstatus = usb_ep_queue(rndis->notify, req, GFP_ATOMIC);\r\nif (status) {\r\natomic_dec(&rndis->notify_count);\r\nDBG(cdev, "notify/1 --> %d\n", status);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void rndis_command_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_rndis *rndis = req->context;\r\nstruct usb_composite_dev *cdev = rndis->port.func.config->cdev;\r\nint status;\r\nstatus = rndis_msg_parser(rndis->config, (u8 *) req->buf);\r\nif (status < 0)\r\nERROR(cdev, "RNDIS command error %d, %d/%d\n",\r\nstatus, req->actual, req->length);\r\n}\r\nstatic int\r\nrndis_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_SEND_ENCAPSULATED_COMMAND:\r\nif (w_value || w_index != rndis->ctrl_id)\r\ngoto invalid;\r\nvalue = w_length;\r\nreq->complete = rndis_command_complete;\r\nreq->context = rndis;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_GET_ENCAPSULATED_RESPONSE:\r\nif (w_value || w_index != rndis->ctrl_id)\r\ngoto invalid;\r\nelse {\r\nu8 *buf;\r\nu32 n;\r\nbuf = rndis_get_next_response(rndis->config, &n);\r\nif (buf) {\r\nmemcpy(req->buf, buf, n);\r\nreq->complete = rndis_response_complete;\r\nreq->context = rndis;\r\nrndis_free_response(rndis->config, buf);\r\nvalue = n;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ninvalid:\r\nVDBG(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\nDBG(cdev, "rndis req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = (value < w_length);\r\nreq->length = value;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(cdev, "rndis response on err %d\n", value);\r\n}\r\nreturn value;\r\n}\r\nstatic int rndis_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (intf == rndis->ctrl_id) {\r\nif (rndis->notify->driver_data) {\r\nVDBG(cdev, "reset rndis control %d\n", intf);\r\nusb_ep_disable(rndis->notify);\r\n}\r\nif (!rndis->notify->desc) {\r\nVDBG(cdev, "init rndis ctrl %d\n", intf);\r\nif (config_ep_by_speed(cdev->gadget, f, rndis->notify))\r\ngoto fail;\r\n}\r\nusb_ep_enable(rndis->notify);\r\nrndis->notify->driver_data = rndis;\r\n} else if (intf == rndis->data_id) {\r\nstruct net_device *net;\r\nif (rndis->port.in_ep->driver_data) {\r\nDBG(cdev, "reset rndis\n");\r\ngether_disconnect(&rndis->port);\r\n}\r\nif (!rndis->port.in_ep->desc || !rndis->port.out_ep->desc) {\r\nDBG(cdev, "init rndis\n");\r\nif (config_ep_by_speed(cdev->gadget, f,\r\nrndis->port.in_ep) ||\r\nconfig_ep_by_speed(cdev->gadget, f,\r\nrndis->port.out_ep)) {\r\nrndis->port.in_ep->desc = NULL;\r\nrndis->port.out_ep->desc = NULL;\r\ngoto fail;\r\n}\r\n}\r\nrndis->port.is_zlp_ok = false;\r\nrndis->port.cdc_filter = 0;\r\nDBG(cdev, "RNDIS RX/TX early activation ... \n");\r\nnet = gether_connect(&rndis->port);\r\nif (IS_ERR(net))\r\nreturn PTR_ERR(net);\r\nrndis_set_param_dev(rndis->config, net,\r\n&rndis->port.cdc_filter);\r\n} else\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nstatic void rndis_disable(struct usb_function *f)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (!rndis->notify->driver_data)\r\nreturn;\r\nDBG(cdev, "rndis deactivated\n");\r\nrndis_uninit(rndis->config);\r\ngether_disconnect(&rndis->port);\r\nusb_ep_disable(rndis->notify);\r\nrndis->notify->driver_data = NULL;\r\n}\r\nstatic void rndis_open(struct gether *geth)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(&geth->func);\r\nstruct usb_composite_dev *cdev = geth->func.config->cdev;\r\nDBG(cdev, "%s\n", __func__);\r\nrndis_set_param_medium(rndis->config, RNDIS_MEDIUM_802_3,\r\nbitrate(cdev->gadget) / 100);\r\nrndis_signal_connect(rndis->config);\r\n}\r\nstatic void rndis_close(struct gether *geth)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(&geth->func);\r\nDBG(geth->func.config->cdev, "%s\n", __func__);\r\nrndis_set_param_medium(rndis->config, RNDIS_MEDIUM_802_3, 0);\r\nrndis_signal_disconnect(rndis->config);\r\n}\r\nstatic int\r\nrndis_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nint status;\r\nstruct usb_ep *ep;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nrndis->ctrl_id = status;\r\nrndis_iad_descriptor.bFirstInterface = status;\r\nrndis_control_intf.bInterfaceNumber = status;\r\nrndis_union_desc.bMasterInterface0 = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nrndis->data_id = status;\r\nrndis_data_intf.bInterfaceNumber = status;\r\nrndis_union_desc.bSlaveInterface0 = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_in_desc);\r\nif (!ep)\r\ngoto fail;\r\nrndis->port.in_ep = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_out_desc);\r\nif (!ep)\r\ngoto fail;\r\nrndis->port.out_ep = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_notify_desc);\r\nif (!ep)\r\ngoto fail;\r\nrndis->notify = ep;\r\nep->driver_data = cdev;\r\nstatus = -ENOMEM;\r\nrndis->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);\r\nif (!rndis->notify_req)\r\ngoto fail;\r\nrndis->notify_req->buf = kmalloc(STATUS_BYTECOUNT, GFP_KERNEL);\r\nif (!rndis->notify_req->buf)\r\ngoto fail;\r\nrndis->notify_req->length = STATUS_BYTECOUNT;\r\nrndis->notify_req->context = rndis;\r\nrndis->notify_req->complete = rndis_response_complete;\r\nf->descriptors = usb_copy_descriptors(eth_fs_function);\r\nif (!f->descriptors)\r\ngoto fail;\r\nif (gadget_is_dualspeed(c->cdev->gadget)) {\r\nhs_in_desc.bEndpointAddress =\r\nfs_in_desc.bEndpointAddress;\r\nhs_out_desc.bEndpointAddress =\r\nfs_out_desc.bEndpointAddress;\r\nhs_notify_desc.bEndpointAddress =\r\nfs_notify_desc.bEndpointAddress;\r\nf->hs_descriptors = usb_copy_descriptors(eth_hs_function);\r\nif (!f->hs_descriptors)\r\ngoto fail;\r\n}\r\nif (gadget_is_superspeed(c->cdev->gadget)) {\r\nss_in_desc.bEndpointAddress =\r\nfs_in_desc.bEndpointAddress;\r\nss_out_desc.bEndpointAddress =\r\nfs_out_desc.bEndpointAddress;\r\nss_notify_desc.bEndpointAddress =\r\nfs_notify_desc.bEndpointAddress;\r\nf->ss_descriptors = usb_copy_descriptors(eth_ss_function);\r\nif (!f->ss_descriptors)\r\ngoto fail;\r\n}\r\nrndis->port.open = rndis_open;\r\nrndis->port.close = rndis_close;\r\nstatus = rndis_register(rndis_response_available, rndis);\r\nif (status < 0)\r\ngoto fail;\r\nrndis->config = status;\r\nrndis_set_param_medium(rndis->config, RNDIS_MEDIUM_802_3, 0);\r\nrndis_set_host_mac(rndis->config, rndis->ethaddr);\r\nif (rndis->manufacturer && rndis->vendorID &&\r\nrndis_set_param_vendor(rndis->config, rndis->vendorID,\r\nrndis->manufacturer))\r\ngoto fail;\r\nDBG(cdev, "RNDIS: %s speed IN/%s OUT/%s NOTIFY/%s\n",\r\ngadget_is_superspeed(c->cdev->gadget) ? "super" :\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\nrndis->port.in_ep->name, rndis->port.out_ep->name,\r\nrndis->notify->name);\r\nreturn 0;\r\nfail:\r\nif (gadget_is_superspeed(c->cdev->gadget) && f->ss_descriptors)\r\nusb_free_descriptors(f->ss_descriptors);\r\nif (gadget_is_dualspeed(c->cdev->gadget) && f->hs_descriptors)\r\nusb_free_descriptors(f->hs_descriptors);\r\nif (f->descriptors)\r\nusb_free_descriptors(f->descriptors);\r\nif (rndis->notify_req) {\r\nkfree(rndis->notify_req->buf);\r\nusb_ep_free_request(rndis->notify, rndis->notify_req);\r\n}\r\nif (rndis->notify)\r\nrndis->notify->driver_data = NULL;\r\nif (rndis->port.out_ep->desc)\r\nrndis->port.out_ep->driver_data = NULL;\r\nif (rndis->port.in_ep->desc)\r\nrndis->port.in_ep->driver_data = NULL;\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nstatic void\r\nrndis_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nrndis_deregister(rndis->config);\r\nrndis_exit();\r\nrndis_string_defs[0].id = 0;\r\nif (gadget_is_superspeed(c->cdev->gadget))\r\nusb_free_descriptors(f->ss_descriptors);\r\nif (gadget_is_dualspeed(c->cdev->gadget))\r\nusb_free_descriptors(f->hs_descriptors);\r\nusb_free_descriptors(f->descriptors);\r\nkfree(rndis->notify_req->buf);\r\nusb_ep_free_request(rndis->notify, rndis->notify_req);\r\nkfree(rndis);\r\n}\r\nstatic inline bool can_support_rndis(struct usb_configuration *c)\r\n{\r\nreturn true;\r\n}\r\nint\r\nrndis_bind_config_vendor(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],\r\nu32 vendorID, const char *manufacturer)\r\n{\r\nstruct f_rndis *rndis;\r\nint status;\r\nif (!can_support_rndis(c) || !ethaddr)\r\nreturn -EINVAL;\r\nif (rndis_string_defs[0].id == 0) {\r\nstatus = rndis_init();\r\nif (status < 0)\r\nreturn status;\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nrndis_string_defs[0].id = status;\r\nrndis_control_intf.iInterface = status;\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nrndis_string_defs[1].id = status;\r\nrndis_data_intf.iInterface = status;\r\nstatus = usb_string_id(c->cdev);\r\nif (status < 0)\r\nreturn status;\r\nrndis_string_defs[2].id = status;\r\nrndis_iad_descriptor.iFunction = status;\r\n}\r\nstatus = -ENOMEM;\r\nrndis = kzalloc(sizeof *rndis, GFP_KERNEL);\r\nif (!rndis)\r\ngoto fail;\r\nmemcpy(rndis->ethaddr, ethaddr, ETH_ALEN);\r\nrndis->vendorID = vendorID;\r\nrndis->manufacturer = manufacturer;\r\nrndis->port.cdc_filter = 0;\r\nrndis->port.header_len = sizeof(struct rndis_packet_msg_type);\r\nrndis->port.wrap = rndis_add_header;\r\nrndis->port.unwrap = rndis_rm_hdr;\r\nrndis->port.func.name = "rndis";\r\nrndis->port.func.strings = rndis_strings;\r\nrndis->port.func.bind = rndis_bind;\r\nrndis->port.func.unbind = rndis_unbind;\r\nrndis->port.func.set_alt = rndis_set_alt;\r\nrndis->port.func.setup = rndis_setup;\r\nrndis->port.func.disable = rndis_disable;\r\nstatus = usb_add_function(c, &rndis->port.func);\r\nif (status) {\r\nkfree(rndis);\r\nfail:\r\nrndis_exit();\r\n}\r\nreturn status;\r\n}
