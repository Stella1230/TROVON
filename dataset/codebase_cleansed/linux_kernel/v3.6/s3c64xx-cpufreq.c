static int s3c64xx_cpufreq_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nif (policy->cpu != 0)\r\nreturn -EINVAL;\r\nreturn cpufreq_frequency_table_verify(policy, s3c64xx_freq_table);\r\n}\r\nstatic unsigned int s3c64xx_cpufreq_get_speed(unsigned int cpu)\r\n{\r\nif (cpu != 0)\r\nreturn 0;\r\nreturn clk_get_rate(armclk) / 1000;\r\n}\r\nstatic int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nint ret;\r\nunsigned int i;\r\nstruct cpufreq_freqs freqs;\r\nstruct s3c64xx_dvfs *dvfs;\r\nret = cpufreq_frequency_table_target(policy, s3c64xx_freq_table,\r\ntarget_freq, relation, &i);\r\nif (ret != 0)\r\nreturn ret;\r\nfreqs.cpu = 0;\r\nfreqs.old = clk_get_rate(armclk) / 1000;\r\nfreqs.new = s3c64xx_freq_table[i].frequency;\r\nfreqs.flags = 0;\r\ndvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[i].index];\r\nif (freqs.old == freqs.new)\r\nreturn 0;\r\npr_debug("Transition %d-%dkHz\n", freqs.old, freqs.new);\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\n#ifdef CONFIG_REGULATOR\r\nif (vddarm && freqs.new > freqs.old) {\r\nret = regulator_set_voltage(vddarm,\r\ndvfs->vddarm_min,\r\ndvfs->vddarm_max);\r\nif (ret != 0) {\r\npr_err("Failed to set VDDARM for %dkHz: %d\n",\r\nfreqs.new, ret);\r\ngoto err;\r\n}\r\n}\r\n#endif\r\nret = clk_set_rate(armclk, freqs.new * 1000);\r\nif (ret < 0) {\r\npr_err("Failed to set rate %dkHz: %d\n",\r\nfreqs.new, ret);\r\ngoto err;\r\n}\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n#ifdef CONFIG_REGULATOR\r\nif (vddarm && freqs.new < freqs.old) {\r\nret = regulator_set_voltage(vddarm,\r\ndvfs->vddarm_min,\r\ndvfs->vddarm_max);\r\nif (ret != 0) {\r\npr_err("Failed to set VDDARM for %dkHz: %d\n",\r\nfreqs.new, ret);\r\ngoto err_clk;\r\n}\r\n}\r\n#endif\r\npr_debug("Set actual frequency %lukHz\n",\r\nclk_get_rate(armclk) / 1000);\r\nreturn 0;\r\nerr_clk:\r\nif (clk_set_rate(armclk, freqs.old * 1000) < 0)\r\npr_err("Failed to restore original clock rate\n");\r\nerr:\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\nreturn ret;\r\n}\r\nstatic void __init s3c64xx_cpufreq_config_regulator(void)\r\n{\r\nint count, v, i, found;\r\nstruct cpufreq_frequency_table *freq;\r\nstruct s3c64xx_dvfs *dvfs;\r\ncount = regulator_count_voltages(vddarm);\r\nif (count < 0) {\r\npr_err("Unable to check supported voltages\n");\r\n}\r\nfreq = s3c64xx_freq_table;\r\nwhile (count > 0 && freq->frequency != CPUFREQ_TABLE_END) {\r\nif (freq->frequency == CPUFREQ_ENTRY_INVALID)\r\ncontinue;\r\ndvfs = &s3c64xx_dvfs_table[freq->index];\r\nfound = 0;\r\nfor (i = 0; i < count; i++) {\r\nv = regulator_list_voltage(vddarm, i);\r\nif (v >= dvfs->vddarm_min && v <= dvfs->vddarm_max)\r\nfound = 1;\r\n}\r\nif (!found) {\r\npr_debug("%dkHz unsupported by regulator\n",\r\nfreq->frequency);\r\nfreq->frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\nfreq++;\r\n}\r\nregulator_latency = 1 * 1000 * 1000;\r\n}\r\nstatic int s3c64xx_cpufreq_driver_init(struct cpufreq_policy *policy)\r\n{\r\nint ret;\r\nstruct cpufreq_frequency_table *freq;\r\nif (policy->cpu != 0)\r\nreturn -EINVAL;\r\nif (s3c64xx_freq_table == NULL) {\r\npr_err("No frequency information for this CPU\n");\r\nreturn -ENODEV;\r\n}\r\narmclk = clk_get(NULL, "armclk");\r\nif (IS_ERR(armclk)) {\r\npr_err("Unable to obtain ARMCLK: %ld\n",\r\nPTR_ERR(armclk));\r\nreturn PTR_ERR(armclk);\r\n}\r\n#ifdef CONFIG_REGULATOR\r\nvddarm = regulator_get(NULL, "vddarm");\r\nif (IS_ERR(vddarm)) {\r\nret = PTR_ERR(vddarm);\r\npr_err("Failed to obtain VDDARM: %d\n", ret);\r\npr_err("Only frequency scaling available\n");\r\nvddarm = NULL;\r\n} else {\r\ns3c64xx_cpufreq_config_regulator();\r\n}\r\n#endif\r\nfreq = s3c64xx_freq_table;\r\nwhile (freq->frequency != CPUFREQ_TABLE_END) {\r\nunsigned long r;\r\nr = clk_round_rate(armclk, freq->frequency * 1000);\r\nr /= 1000;\r\nif (r != freq->frequency) {\r\npr_debug("%dkHz unsupported by clock\n",\r\nfreq->frequency);\r\nfreq->frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\nif (!vddarm && freq->frequency > s3c64xx_cpufreq_get_speed(0))\r\nfreq->frequency = CPUFREQ_ENTRY_INVALID;\r\nfreq++;\r\n}\r\npolicy->cur = clk_get_rate(armclk) / 1000;\r\npolicy->cpuinfo.transition_latency = (500 * 1000) + regulator_latency;\r\nret = cpufreq_frequency_table_cpuinfo(policy, s3c64xx_freq_table);\r\nif (ret != 0) {\r\npr_err("Failed to configure frequency table: %d\n",\r\nret);\r\nregulator_put(vddarm);\r\nclk_put(armclk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init s3c64xx_cpufreq_init(void)\r\n{\r\nreturn cpufreq_register_driver(&s3c64xx_cpufreq_driver);\r\n}
