static bool radeon_dig_encoder(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int r600_audio_chipset_supported(struct radeon_device *rdev)\r\n{\r\nreturn (rdev->family >= CHIP_R600 && !ASIC_IS_DCE6(rdev))\r\n|| rdev->family == CHIP_RS600\r\n|| rdev->family == CHIP_RS690\r\n|| rdev->family == CHIP_RS740;\r\n}\r\nstruct r600_audio r600_audio_status(struct radeon_device *rdev)\r\n{\r\nstruct r600_audio status;\r\nuint32_t value;\r\nvalue = RREG32(R600_AUDIO_RATE_BPS_CHANNEL);\r\nstatus.channels = (value & 0x7) + 1;\r\nswitch ((value & 0xF0) >> 4) {\r\ncase 0x0:\r\nstatus.bits_per_sample = 8;\r\nbreak;\r\ncase 0x1:\r\nstatus.bits_per_sample = 16;\r\nbreak;\r\ncase 0x2:\r\nstatus.bits_per_sample = 20;\r\nbreak;\r\ncase 0x3:\r\nstatus.bits_per_sample = 24;\r\nbreak;\r\ncase 0x4:\r\nstatus.bits_per_sample = 32;\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unknown bits per sample 0x%x, using 16\n",\r\n(int)value);\r\nstatus.bits_per_sample = 16;\r\n}\r\nif (value & 0x4000)\r\nstatus.rate = 44100;\r\nelse\r\nstatus.rate = 48000;\r\nstatus.rate *= ((value >> 11) & 0x7) + 1;\r\nstatus.rate /= ((value >> 8) & 0x7) + 1;\r\nvalue = RREG32(R600_AUDIO_STATUS_BITS);\r\nstatus.status_bits = value & 0xff;\r\nstatus.category_code = (value >> 8) & 0xff;\r\nreturn status;\r\n}\r\nvoid r600_audio_update_hdmi(struct work_struct *work)\r\n{\r\nstruct radeon_device *rdev = container_of(work, struct radeon_device,\r\naudio_work);\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct r600_audio audio_status = r600_audio_status(rdev);\r\nstruct drm_encoder *encoder;\r\nbool changed = false;\r\nif (rdev->audio_status.channels != audio_status.channels ||\r\nrdev->audio_status.rate != audio_status.rate ||\r\nrdev->audio_status.bits_per_sample != audio_status.bits_per_sample ||\r\nrdev->audio_status.status_bits != audio_status.status_bits ||\r\nrdev->audio_status.category_code != audio_status.category_code) {\r\nrdev->audio_status = audio_status;\r\nchanged = true;\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (!radeon_dig_encoder(encoder))\r\ncontinue;\r\nif (changed || r600_hdmi_buffer_status_changed(encoder))\r\nr600_hdmi_update_audio_settings(encoder);\r\n}\r\n}\r\nstatic void r600_audio_engine_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nu32 value = 0;\r\nDRM_INFO("%s audio support\n", enable ? "Enabling" : "Disabling");\r\nif (ASIC_IS_DCE4(rdev)) {\r\nif (enable) {\r\nvalue |= 0x81000000;\r\nvalue |= 0x0e1000f0;\r\n}\r\nWREG32(EVERGREEN_AUDIO_ENABLE, value);\r\n} else {\r\nWREG32_P(R600_AUDIO_ENABLE,\r\nenable ? 0x81000000 : 0x0, ~0x81000000);\r\n}\r\nrdev->audio_enabled = enable;\r\n}\r\nint r600_audio_init(struct radeon_device *rdev)\r\n{\r\nif (!radeon_audio || !r600_audio_chipset_supported(rdev))\r\nreturn 0;\r\nr600_audio_engine_enable(rdev, true);\r\nrdev->audio_status.channels = -1;\r\nrdev->audio_status.rate = -1;\r\nrdev->audio_status.bits_per_sample = -1;\r\nrdev->audio_status.status_bits = 0;\r\nrdev->audio_status.category_code = 0;\r\nreturn 0;\r\n}\r\nvoid r600_audio_set_clock(struct drm_encoder *encoder, int clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\r\nint base_rate = 48000;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nWREG32_P(R600_AUDIO_TIMING, 0, ~0x301);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\nWREG32_P(R600_AUDIO_TIMING, 0x100, ~0x301);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unsupported encoder type 0x%02X\n",\r\nradeon_encoder->encoder_id);\r\nreturn;\r\n}\r\nif (ASIC_IS_DCE4(rdev)) {\r\nWREG32(EVERGREEN_AUDIO_PLL1_MUL, base_rate * 10);\r\nWREG32(EVERGREEN_AUDIO_PLL1_DIV, clock * 10);\r\nWREG32(EVERGREEN_AUDIO_PLL1_UNK, 0x00000071);\r\nWREG32(0x5ac, radeon_crtc->crtc_id);\r\n} else {\r\nswitch (dig->dig_encoder) {\r\ncase 0:\r\nWREG32(R600_AUDIO_PLL1_MUL, base_rate * 50);\r\nWREG32(R600_AUDIO_PLL1_DIV, clock * 100);\r\nWREG32(R600_AUDIO_CLK_SRCSEL, 0);\r\nbreak;\r\ncase 1:\r\nWREG32(R600_AUDIO_PLL2_MUL, base_rate * 50);\r\nWREG32(R600_AUDIO_PLL2_DIV, clock * 100);\r\nWREG32(R600_AUDIO_CLK_SRCSEL, 1);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev,\r\n"Unsupported DIG on encoder 0x%02X\n",\r\nradeon_encoder->encoder_id);\r\nreturn;\r\n}\r\n}\r\n}\r\nvoid r600_audio_fini(struct radeon_device *rdev)\r\n{\r\nif (!rdev->audio_enabled)\r\nreturn;\r\nr600_audio_engine_enable(rdev, false);\r\n}
