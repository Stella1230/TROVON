static int check_asic_status(struct echoaudio *chip)\r\n{\r\nu32 asic_status;\r\nsend_vector(chip, DSP_VC_TEST_ASIC);\r\nif (read_dsp(chip, &asic_status) < 0) {\r\nDE_INIT(("check_asic_status: failed on read_dsp\n"));\r\nchip->asic_loaded = FALSE;\r\nreturn -EIO;\r\n}\r\nchip->asic_loaded = (asic_status == ASIC_ALREADY_LOADED);\r\nreturn chip->asic_loaded ? 0 : -EIO;\r\n}\r\nstatic int write_control_reg(struct echoaudio *chip, u32 value, char force)\r\n{\r\nif (chip->digital_in_automute)\r\nvalue |= GML_DIGITAL_IN_AUTO_MUTE;\r\nelse\r\nvalue &= ~GML_DIGITAL_IN_AUTO_MUTE;\r\nDE_ACT(("write_control_reg: 0x%x\n", value));\r\nvalue = cpu_to_le32(value);\r\nif (value != chip->comm_page->control_register || force) {\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->comm_page->control_register = value;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_WRITE_CONTROL_REG);\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_input_auto_mute(struct echoaudio *chip, int automute)\r\n{\r\nDE_ACT(("set_input_auto_mute %d\n", automute));\r\nchip->digital_in_automute = automute;\r\nreturn set_input_clock(chip, chip->input_clock);\r\n}\r\nstatic int set_digital_mode(struct echoaudio *chip, u8 mode)\r\n{\r\nu8 previous_mode;\r\nint err, i, o;\r\nif (chip->bad_board)\r\nreturn -EIO;\r\nif (snd_BUG_ON(chip->pipe_alloc_mask))\r\nreturn -EAGAIN;\r\nif (snd_BUG_ON(!(chip->digital_modes & (1 << mode))))\r\nreturn -EINVAL;\r\nprevious_mode = chip->digital_mode;\r\nerr = dsp_set_digital_mode(chip, mode);\r\nif (err >= 0 && previous_mode != mode &&\r\n(previous_mode == DIGITAL_MODE_ADAT || mode == DIGITAL_MODE_ADAT)) {\r\nspin_lock_irq(&chip->lock);\r\nfor (o = 0; o < num_busses_out(chip); o++)\r\nfor (i = 0; i < num_busses_in(chip); i++)\r\nset_monitor_gain(chip, o, i,\r\nchip->monitor_gain[o][i]);\r\n#ifdef ECHOCARD_HAS_INPUT_GAIN\r\nfor (i = 0; i < num_busses_in(chip); i++)\r\nset_input_gain(chip, i, chip->input_gain[i]);\r\nupdate_input_line_level(chip);\r\n#endif\r\nfor (o = 0; o < num_busses_out(chip); o++)\r\nset_output_gain(chip, o, chip->output_gain[o]);\r\nupdate_output_line_level(chip);\r\nspin_unlock_irq(&chip->lock);\r\n}\r\nreturn err;\r\n}\r\nstatic int set_professional_spdif(struct echoaudio *chip, char prof)\r\n{\r\nu32 control_reg;\r\nint err;\r\ncontrol_reg = le32_to_cpu(chip->comm_page->control_register);\r\ncontrol_reg &= GML_SPDIF_FORMAT_CLEAR_MASK;\r\ncontrol_reg |= GML_SPDIF_TWO_CHANNEL | GML_SPDIF_24_BIT |\r\nGML_SPDIF_COPY_PERMIT;\r\nif (prof) {\r\ncontrol_reg |= GML_SPDIF_PRO_MODE;\r\nswitch (chip->sample_rate) {\r\ncase 32000:\r\ncontrol_reg |= GML_SPDIF_SAMPLE_RATE0 |\r\nGML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 44100:\r\ncontrol_reg |= GML_SPDIF_SAMPLE_RATE0;\r\nbreak;\r\ncase 48000:\r\ncontrol_reg |= GML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\n}\r\n} else {\r\nswitch (chip->sample_rate) {\r\ncase 32000:\r\ncontrol_reg |= GML_SPDIF_SAMPLE_RATE0 |\r\nGML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\ncase 48000:\r\ncontrol_reg |= GML_SPDIF_SAMPLE_RATE1;\r\nbreak;\r\n}\r\n}\r\nif ((err = write_control_reg(chip, control_reg, FALSE)))\r\nreturn err;\r\nchip->professional_spdif = prof;\r\nDE_ACT(("set_professional_spdif to %s\n",\r\nprof ? "Professional" : "Consumer"));\r\nreturn 0;\r\n}
