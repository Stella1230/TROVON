static enum CT_AMIXER_CTL get_amixer_index(enum CTALSA_MIXER_CTL alsa_index)\r\n{\r\nswitch (alsa_index) {\r\ncase MIXER_MASTER_P: return AMIXER_MASTER_F;\r\ncase MIXER_MASTER_C: return AMIXER_MASTER_F_C;\r\ncase MIXER_PCM_P: return AMIXER_PCM_F;\r\ncase MIXER_PCM_C:\r\ncase MIXER_PCM_C_S: return AMIXER_PCM_F_C;\r\ncase MIXER_LINEIN_P: return AMIXER_LINEIN;\r\ncase MIXER_LINEIN_C:\r\ncase MIXER_LINEIN_C_S: return AMIXER_LINEIN_C;\r\ncase MIXER_MIC_P: return AMIXER_MIC;\r\ncase MIXER_MIC_C:\r\ncase MIXER_MIC_C_S: return AMIXER_MIC_C;\r\ncase MIXER_SPDIFI_P: return AMIXER_SPDIFI;\r\ncase MIXER_SPDIFI_C:\r\ncase MIXER_SPDIFI_C_S: return AMIXER_SPDIFI_C;\r\ncase MIXER_SPDIFO_P: return AMIXER_SPDIFO;\r\ncase MIXER_WAVEF_P: return AMIXER_WAVE_F;\r\ncase MIXER_WAVES_P: return AMIXER_WAVE_S;\r\ncase MIXER_WAVEC_P: return AMIXER_WAVE_C;\r\ncase MIXER_WAVER_P: return AMIXER_WAVE_R;\r\ndefault: return NUM_CT_AMIXERS;\r\n}\r\n}\r\nstatic enum CT_AMIXER_CTL get_recording_amixer(enum CT_AMIXER_CTL index)\r\n{\r\nswitch (index) {\r\ncase AMIXER_MASTER_F: return AMIXER_MASTER_F_C;\r\ncase AMIXER_PCM_F: return AMIXER_PCM_F_C;\r\ncase AMIXER_SPDIFI: return AMIXER_SPDIFI_C;\r\ncase AMIXER_LINEIN: return AMIXER_LINEIN_C;\r\ncase AMIXER_MIC: return AMIXER_MIC_C;\r\ndefault: return NUM_CT_AMIXERS;\r\n}\r\n}\r\nstatic unsigned char\r\nget_switch_state(struct ct_mixer *mixer, enum CTALSA_MIXER_CTL type)\r\n{\r\nreturn (mixer->switch_state & (0x1 << (type - SWH_MIXER_START)))\r\n? 1 : 0;\r\n}\r\nstatic void\r\nset_switch_state(struct ct_mixer *mixer,\r\nenum CTALSA_MIXER_CTL type, unsigned char state)\r\n{\r\nif (state)\r\nmixer->switch_state |= (0x1 << (type - SWH_MIXER_START));\r\nelse\r\nmixer->switch_state &= ~(0x1 << (type - SWH_MIXER_START));\r\n}\r\nstatic int ct_alsa_mix_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = VOL_MAX;\r\nreturn 0;\r\n}\r\nstatic int ct_alsa_mix_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nenum CT_AMIXER_CTL type = get_amixer_index(kcontrol->private_value);\r\nstruct amixer *amixer;\r\nint i, val;\r\nfor (i = 0; i < 2; i++) {\r\namixer = ((struct ct_mixer *)atc->mixer)->\r\namixers[type*CHN_NUM+i];\r\nval = amixer->ops->get_scale(amixer) / VOL_SCALE;\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > VOL_MAX)\r\nval = VOL_MAX;\r\nucontrol->value.integer.value[i] = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ct_alsa_mix_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nstruct ct_mixer *mixer = atc->mixer;\r\nenum CT_AMIXER_CTL type = get_amixer_index(kcontrol->private_value);\r\nstruct amixer *amixer;\r\nint i, j, val, oval, change = 0;\r\nfor (i = 0; i < 2; i++) {\r\nval = ucontrol->value.integer.value[i];\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > VOL_MAX)\r\nval = VOL_MAX;\r\nval *= VOL_SCALE;\r\namixer = mixer->amixers[type*CHN_NUM+i];\r\noval = amixer->ops->get_scale(amixer);\r\nif (val != oval) {\r\namixer->ops->set_scale(amixer, val);\r\namixer->ops->commit_write(amixer);\r\nchange = 1;\r\nif (AMIXER_MASTER_F == type || AMIXER_PCM_F == type) {\r\nfor (j = 1; j < 4; j++) {\r\namixer = mixer->\r\namixers[(type+j)*CHN_NUM+i];\r\namixer->ops->set_scale(amixer, val);\r\namixer->ops->commit_write(amixer);\r\n}\r\n}\r\n}\r\n}\r\nreturn change;\r\n}\r\nstatic int output_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[3] = {\r\n"FP Headphones", "Headphones", "Speakers"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 3, names);\r\n}\r\nstatic int output_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = atc->output_switch_get(atc);\r\nreturn 0;\r\n}\r\nstatic int output_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.enumerated.item[0] > 2)\r\nreturn -EINVAL;\r\nreturn atc->output_switch_put(atc, ucontrol->value.enumerated.item[0]);\r\n}\r\nstatic int mic_source_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[3] = {\r\n"Mic", "FP Mic", "Aux"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 3, names);\r\n}\r\nstatic int mic_source_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = atc->mic_source_switch_get(atc);\r\nreturn 0;\r\n}\r\nstatic int mic_source_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.enumerated.item[0] > 2)\r\nreturn -EINVAL;\r\nreturn atc->mic_source_switch_put(atc,\r\nucontrol->value.enumerated.item[0]);\r\n}\r\nstatic void\r\ndo_line_mic_switch(struct ct_atc *atc, enum CTALSA_MIXER_CTL type)\r\n{\r\nif (MIXER_LINEIN_C_S == type) {\r\natc->select_line_in(atc);\r\nset_switch_state(atc->mixer, MIXER_MIC_C_S, 0);\r\nsnd_ctl_notify(atc->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&kctls[1]->id);\r\n} else if (MIXER_MIC_C_S == type) {\r\natc->select_mic_in(atc);\r\nset_switch_state(atc->mixer, MIXER_LINEIN_C_S, 0);\r\nsnd_ctl_notify(atc->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&kctls[0]->id);\r\n}\r\n}\r\nstatic void\r\ndo_digit_io_switch(struct ct_atc *atc, int state)\r\n{\r\nstruct ct_mixer *mixer = atc->mixer;\r\nif (state) {\r\natc->select_digit_io(atc);\r\natc->spdif_out_unmute(atc,\r\nget_switch_state(mixer, MIXER_SPDIFO_P_S));\r\natc->spdif_in_unmute(atc, 1);\r\natc->line_in_unmute(atc, 0);\r\nreturn;\r\n}\r\nif (get_switch_state(mixer, MIXER_LINEIN_C_S))\r\natc->select_line_in(atc);\r\nelse if (get_switch_state(mixer, MIXER_MIC_C_S))\r\natc->select_mic_in(atc);\r\natc->spdif_out_unmute(atc, 0);\r\natc->spdif_in_unmute(atc, 0);\r\natc->line_in_unmute(atc, 1);\r\nreturn;\r\n}\r\nstatic void do_switch(struct ct_atc *atc, enum CTALSA_MIXER_CTL type, int state)\r\n{\r\nstruct ct_mixer *mixer = atc->mixer;\r\nstruct capabilities cap = atc->capabilities(atc);\r\nif ((SWH_CAPTURE_START <= type) && (SWH_CAPTURE_END >= type)) {\r\nif (state) {\r\nct_mixer_recording_select(mixer,\r\nget_amixer_index(type));\r\n} else {\r\nct_mixer_recording_unselect(mixer,\r\nget_amixer_index(type));\r\n}\r\n}\r\nif (!cap.dedicated_mic &&\r\n(MIXER_LINEIN_C_S == type || MIXER_MIC_C_S == type)) {\r\nif (state)\r\ndo_line_mic_switch(atc, type);\r\natc->line_in_unmute(atc, state);\r\n} else if (cap.dedicated_mic && (MIXER_LINEIN_C_S == type))\r\natc->line_in_unmute(atc, state);\r\nelse if (cap.dedicated_mic && (MIXER_MIC_C_S == type))\r\natc->mic_unmute(atc, state);\r\nelse if (MIXER_SPDIFI_C_S == type)\r\natc->spdif_in_unmute(atc, state);\r\nelse if (MIXER_WAVEF_P_S == type)\r\natc->line_front_unmute(atc, state);\r\nelse if (MIXER_WAVES_P_S == type)\r\natc->line_surround_unmute(atc, state);\r\nelse if (MIXER_WAVEC_P_S == type)\r\natc->line_clfe_unmute(atc, state);\r\nelse if (MIXER_WAVER_P_S == type)\r\natc->line_rear_unmute(atc, state);\r\nelse if (MIXER_SPDIFO_P_S == type)\r\natc->spdif_out_unmute(atc, state);\r\nelse if (MIXER_DIGITAL_IO_S == type)\r\ndo_digit_io_switch(atc, state);\r\nreturn;\r\n}\r\nstatic int ct_alsa_mix_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int ct_alsa_mix_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_mixer *mixer =\r\n((struct ct_atc *)snd_kcontrol_chip(kcontrol))->mixer;\r\nenum CTALSA_MIXER_CTL type = kcontrol->private_value;\r\nucontrol->value.integer.value[0] = get_switch_state(mixer, type);\r\nreturn 0;\r\n}\r\nstatic int ct_alsa_mix_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nstruct ct_mixer *mixer = atc->mixer;\r\nenum CTALSA_MIXER_CTL type = kcontrol->private_value;\r\nint state;\r\nstate = ucontrol->value.integer.value[0];\r\nif (get_switch_state(mixer, type) == state)\r\nreturn 0;\r\nset_switch_state(mixer, type, state);\r\ndo_switch(atc, type, state);\r\nreturn 1;\r\n}\r\nstatic int ct_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int ct_spdif_get_mask(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int ct_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nunsigned int status;\r\natc->spdif_out_get_status(atc, &status);\r\nif (status == 0)\r\nstatus = SNDRV_PCM_DEFAULT_CON_SPDIF;\r\nucontrol->value.iec958.status[0] = (status >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (status >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (status >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (status >> 24) & 0xff;\r\nreturn 0;\r\n}\r\nstatic int ct_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct ct_atc *atc = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int status, old_status;\r\nstatus = (ucontrol->value.iec958.status[0] << 0) |\r\n(ucontrol->value.iec958.status[1] << 8) |\r\n(ucontrol->value.iec958.status[2] << 16) |\r\n(ucontrol->value.iec958.status[3] << 24);\r\natc->spdif_out_get_status(atc, &old_status);\r\nchange = (old_status != status);\r\nif (change)\r\natc->spdif_out_set_status(atc, status);\r\nreturn change;\r\n}\r\nstatic int\r\nct_mixer_kcontrol_new(struct ct_mixer *mixer, struct snd_kcontrol_new *new)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nint err;\r\nkctl = snd_ctl_new1(new, mixer->atc);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nif (SNDRV_CTL_ELEM_IFACE_PCM == kctl->id.iface)\r\nkctl->id.device = IEC958;\r\nerr = snd_ctl_add(mixer->atc->card, kctl);\r\nif (err)\r\nreturn err;\r\nswitch (new->private_value) {\r\ncase MIXER_LINEIN_C_S:\r\nkctls[0] = kctl; break;\r\ncase MIXER_MIC_C_S:\r\nkctls[1] = kctl; break;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ct_mixer_kcontrols_create(struct ct_mixer *mixer)\r\n{\r\nenum CTALSA_MIXER_CTL type;\r\nstruct ct_atc *atc = mixer->atc;\r\nstruct capabilities cap = atc->capabilities(atc);\r\nint err;\r\nfor (type = VOL_MIXER_START; type <= VOL_MIXER_END; type++) {\r\nif (ct_kcontrol_init_table[type].ctl) {\r\nvol_ctl.name = ct_kcontrol_init_table[type].name;\r\nvol_ctl.private_value = (unsigned long)type;\r\nerr = ct_mixer_kcontrol_new(mixer, &vol_ctl);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nct_kcontrol_init_table[MIXER_DIGITAL_IO_S].ctl = cap.digit_io_switch;\r\nfor (type = SWH_MIXER_START; type <= SWH_MIXER_END; type++) {\r\nif (ct_kcontrol_init_table[type].ctl) {\r\nswh_ctl.name = ct_kcontrol_init_table[type].name;\r\nswh_ctl.private_value = (unsigned long)type;\r\nerr = ct_mixer_kcontrol_new(mixer, &swh_ctl);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nerr = ct_mixer_kcontrol_new(mixer, &iec958_mask_ctl);\r\nif (err)\r\nreturn err;\r\nerr = ct_mixer_kcontrol_new(mixer, &iec958_default_ctl);\r\nif (err)\r\nreturn err;\r\nerr = ct_mixer_kcontrol_new(mixer, &iec958_ctl);\r\nif (err)\r\nreturn err;\r\nif (cap.output_switch) {\r\nerr = ct_mixer_kcontrol_new(mixer, &output_ctl);\r\nif (err)\r\nreturn err;\r\n}\r\nif (cap.mic_source_switch) {\r\nerr = ct_mixer_kcontrol_new(mixer, &mic_source_ctl);\r\nif (err)\r\nreturn err;\r\n}\r\natc->line_front_unmute(atc, 1);\r\nset_switch_state(mixer, MIXER_WAVEF_P_S, 1);\r\natc->line_surround_unmute(atc, 0);\r\nset_switch_state(mixer, MIXER_WAVES_P_S, 0);\r\natc->line_clfe_unmute(atc, 0);\r\nset_switch_state(mixer, MIXER_WAVEC_P_S, 0);\r\natc->line_rear_unmute(atc, 0);\r\nset_switch_state(mixer, MIXER_WAVER_P_S, 0);\r\natc->spdif_out_unmute(atc, 0);\r\nset_switch_state(mixer, MIXER_SPDIFO_P_S, 0);\r\natc->line_in_unmute(atc, 0);\r\nif (cap.dedicated_mic)\r\natc->mic_unmute(atc, 0);\r\natc->spdif_in_unmute(atc, 0);\r\nset_switch_state(mixer, MIXER_PCM_C_S, 0);\r\nset_switch_state(mixer, MIXER_LINEIN_C_S, 0);\r\nset_switch_state(mixer, MIXER_SPDIFI_C_S, 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nct_mixer_recording_select(struct ct_mixer *mixer, enum CT_AMIXER_CTL type)\r\n{\r\nstruct amixer *amix_d;\r\nstruct sum *sum_c;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\namix_d = mixer->amixers[type*CHN_NUM+i];\r\nsum_c = mixer->sums[SUM_IN_F_C*CHN_NUM+i];\r\namix_d->ops->set_sum(amix_d, sum_c);\r\namix_d->ops->commit_write(amix_d);\r\n}\r\n}\r\nstatic void\r\nct_mixer_recording_unselect(struct ct_mixer *mixer, enum CT_AMIXER_CTL type)\r\n{\r\nstruct amixer *amix_d;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\namix_d = mixer->amixers[type*CHN_NUM+i];\r\namix_d->ops->set_sum(amix_d, NULL);\r\namix_d->ops->commit_write(amix_d);\r\n}\r\n}\r\nstatic int ct_mixer_get_resources(struct ct_mixer *mixer)\r\n{\r\nstruct sum_mgr *sum_mgr;\r\nstruct sum *sum;\r\nstruct sum_desc sum_desc = {0};\r\nstruct amixer_mgr *amixer_mgr;\r\nstruct amixer *amixer;\r\nstruct amixer_desc am_desc = {0};\r\nint err;\r\nint i;\r\nsum_mgr = (struct sum_mgr *)mixer->atc->rsc_mgrs[SUM];\r\nsum_desc.msr = mixer->atc->msr;\r\nfor (i = 0; i < (NUM_CT_SUMS * CHN_NUM); i++) {\r\nerr = sum_mgr->get_sum(sum_mgr, &sum_desc, &sum);\r\nif (err) {\r\nprintk(KERN_ERR "ctxfi:Failed to get sum resources for "\r\n"front output!\n");\r\nbreak;\r\n}\r\nmixer->sums[i] = sum;\r\n}\r\nif (err)\r\ngoto error1;\r\namixer_mgr = (struct amixer_mgr *)mixer->atc->rsc_mgrs[AMIXER];\r\nam_desc.msr = mixer->atc->msr;\r\nfor (i = 0; i < (NUM_CT_AMIXERS * CHN_NUM); i++) {\r\nerr = amixer_mgr->get_amixer(amixer_mgr, &am_desc, &amixer);\r\nif (err) {\r\nprintk(KERN_ERR "ctxfi:Failed to get amixer resources "\r\n"for mixer obj!\n");\r\nbreak;\r\n}\r\nmixer->amixers[i] = amixer;\r\n}\r\nif (err)\r\ngoto error2;\r\nreturn 0;\r\nerror2:\r\nfor (i = 0; i < (NUM_CT_AMIXERS * CHN_NUM); i++) {\r\nif (NULL != mixer->amixers[i]) {\r\namixer = mixer->amixers[i];\r\namixer_mgr->put_amixer(amixer_mgr, amixer);\r\nmixer->amixers[i] = NULL;\r\n}\r\n}\r\nerror1:\r\nfor (i = 0; i < (NUM_CT_SUMS * CHN_NUM); i++) {\r\nif (NULL != mixer->sums[i]) {\r\nsum_mgr->put_sum(sum_mgr, (struct sum *)mixer->sums[i]);\r\nmixer->sums[i] = NULL;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int ct_mixer_get_mem(struct ct_mixer **rmixer)\r\n{\r\nstruct ct_mixer *mixer;\r\nint err;\r\n*rmixer = NULL;\r\nmixer = kzalloc(sizeof(*mixer), GFP_KERNEL);\r\nif (!mixer)\r\nreturn -ENOMEM;\r\nmixer->amixers = kzalloc(sizeof(void *)*(NUM_CT_AMIXERS*CHN_NUM),\r\nGFP_KERNEL);\r\nif (!mixer->amixers) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\nmixer->sums = kzalloc(sizeof(void *)*(NUM_CT_SUMS*CHN_NUM), GFP_KERNEL);\r\nif (!mixer->sums) {\r\nerr = -ENOMEM;\r\ngoto error2;\r\n}\r\n*rmixer = mixer;\r\nreturn 0;\r\nerror2:\r\nkfree(mixer->amixers);\r\nerror1:\r\nkfree(mixer);\r\nreturn err;\r\n}\r\nstatic int ct_mixer_topology_build(struct ct_mixer *mixer)\r\n{\r\nstruct sum *sum;\r\nstruct amixer *amix_d, *amix_s;\r\nenum CT_AMIXER_CTL i, j;\r\nfor (i = AMIXER_MASTER_F, j = SUM_IN_F;\r\ni <= AMIXER_MASTER_S; i++, j++) {\r\namix_d = mixer->amixers[i*CHN_NUM];\r\nsum = mixer->sums[j*CHN_NUM];\r\namix_d->ops->setup(amix_d, &sum->rsc, INIT_VOL, NULL);\r\namix_d = mixer->amixers[i*CHN_NUM+1];\r\nsum = mixer->sums[j*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, &sum->rsc, INIT_VOL, NULL);\r\n}\r\nfor (i = AMIXER_WAVE_F, j = AMIXER_MASTER_F;\r\ni <= AMIXER_WAVE_S; i++, j++) {\r\namix_d = mixer->amixers[i*CHN_NUM];\r\namix_s = mixer->amixers[j*CHN_NUM];\r\namix_d->ops->setup(amix_d, &amix_s->rsc, INIT_VOL, NULL);\r\namix_d = mixer->amixers[i*CHN_NUM+1];\r\namix_s = mixer->amixers[j*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, &amix_s->rsc, INIT_VOL, NULL);\r\n}\r\namix_d = mixer->amixers[AMIXER_SPDIFO*CHN_NUM];\r\namix_s = mixer->amixers[AMIXER_MASTER_F*CHN_NUM];\r\namix_d->ops->setup(amix_d, &amix_s->rsc, INIT_VOL, NULL);\r\namix_d = mixer->amixers[AMIXER_SPDIFO*CHN_NUM+1];\r\namix_s = mixer->amixers[AMIXER_MASTER_F*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, &amix_s->rsc, INIT_VOL, NULL);\r\nfor (i = AMIXER_PCM_F, j = SUM_IN_F; i <= AMIXER_PCM_S; i++, j++) {\r\namix_d = mixer->amixers[i*CHN_NUM];\r\nsum = mixer->sums[j*CHN_NUM];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[i*CHN_NUM+1];\r\nsum = mixer->sums[j*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\n}\r\namix_d = mixer->amixers[AMIXER_LINEIN*CHN_NUM];\r\nsum = mixer->sums[SUM_IN_F*CHN_NUM];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_LINEIN*CHN_NUM+1];\r\nsum = mixer->sums[SUM_IN_F*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_MIC*CHN_NUM];\r\nsum = mixer->sums[SUM_IN_F*CHN_NUM];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_MIC*CHN_NUM+1];\r\nsum = mixer->sums[SUM_IN_F*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_SPDIFI*CHN_NUM];\r\nsum = mixer->sums[SUM_IN_F*CHN_NUM];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_SPDIFI*CHN_NUM+1];\r\nsum = mixer->sums[SUM_IN_F*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_MASTER_F_C*CHN_NUM];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\r\namix_d->ops->setup(amix_d, &sum->rsc, INIT_VOL, NULL);\r\namix_d = mixer->amixers[AMIXER_MASTER_F_C*CHN_NUM+1];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, &sum->rsc, INIT_VOL, NULL);\r\namix_d = mixer->amixers[AMIXER_PCM_F_C*CHN_NUM];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_PCM_F_C*CHN_NUM+1];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_LINEIN_C*CHN_NUM];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_LINEIN_C*CHN_NUM+1];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_MIC_C*CHN_NUM];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_MIC_C*CHN_NUM+1];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_SPDIFI_C*CHN_NUM];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\namix_d = mixer->amixers[AMIXER_SPDIFI_C*CHN_NUM+1];\r\nsum = mixer->sums[SUM_IN_F_C*CHN_NUM+1];\r\namix_d->ops->setup(amix_d, NULL, INIT_VOL, sum);\r\nreturn 0;\r\n}\r\nstatic int mixer_set_input_port(struct amixer *amixer, struct rsc *rsc)\r\n{\r\namixer->ops->set_input(amixer, rsc);\r\namixer->ops->commit_write(amixer);\r\nreturn 0;\r\n}\r\nstatic enum CT_AMIXER_CTL port_to_amixer(enum MIXER_PORT_T type)\r\n{\r\nswitch (type) {\r\ncase MIX_WAVE_FRONT: return AMIXER_WAVE_F;\r\ncase MIX_WAVE_SURROUND: return AMIXER_WAVE_S;\r\ncase MIX_WAVE_CENTLFE: return AMIXER_WAVE_C;\r\ncase MIX_WAVE_REAR: return AMIXER_WAVE_R;\r\ncase MIX_PCMO_FRONT: return AMIXER_MASTER_F_C;\r\ncase MIX_SPDIF_OUT: return AMIXER_SPDIFO;\r\ncase MIX_LINE_IN: return AMIXER_LINEIN;\r\ncase MIX_MIC_IN: return AMIXER_MIC;\r\ncase MIX_SPDIF_IN: return AMIXER_SPDIFI;\r\ncase MIX_PCMI_FRONT: return AMIXER_PCM_F;\r\ncase MIX_PCMI_SURROUND: return AMIXER_PCM_S;\r\ncase MIX_PCMI_CENTLFE: return AMIXER_PCM_C;\r\ncase MIX_PCMI_REAR: return AMIXER_PCM_R;\r\ndefault: return 0;\r\n}\r\n}\r\nstatic int mixer_get_output_ports(struct ct_mixer *mixer,\r\nenum MIXER_PORT_T type,\r\nstruct rsc **rleft, struct rsc **rright)\r\n{\r\nenum CT_AMIXER_CTL amix = port_to_amixer(type);\r\nif (NULL != rleft)\r\n*rleft = &((struct amixer *)mixer->amixers[amix*CHN_NUM])->rsc;\r\nif (NULL != rright)\r\n*rright =\r\n&((struct amixer *)mixer->amixers[amix*CHN_NUM+1])->rsc;\r\nreturn 0;\r\n}\r\nstatic int mixer_set_input_left(struct ct_mixer *mixer,\r\nenum MIXER_PORT_T type, struct rsc *rsc)\r\n{\r\nenum CT_AMIXER_CTL amix = port_to_amixer(type);\r\nmixer_set_input_port(mixer->amixers[amix*CHN_NUM], rsc);\r\namix = get_recording_amixer(amix);\r\nif (amix < NUM_CT_AMIXERS)\r\nmixer_set_input_port(mixer->amixers[amix*CHN_NUM], rsc);\r\nreturn 0;\r\n}\r\nstatic int\r\nmixer_set_input_right(struct ct_mixer *mixer,\r\nenum MIXER_PORT_T type, struct rsc *rsc)\r\n{\r\nenum CT_AMIXER_CTL amix = port_to_amixer(type);\r\nmixer_set_input_port(mixer->amixers[amix*CHN_NUM+1], rsc);\r\namix = get_recording_amixer(amix);\r\nif (amix < NUM_CT_AMIXERS)\r\nmixer_set_input_port(mixer->amixers[amix*CHN_NUM+1], rsc);\r\nreturn 0;\r\n}\r\nstatic int mixer_resume(struct ct_mixer *mixer)\r\n{\r\nint i, state;\r\nstruct amixer *amixer;\r\nfor (i = 0; i < NUM_CT_AMIXERS*CHN_NUM; i++) {\r\namixer = mixer->amixers[i];\r\namixer->ops->commit_write(amixer);\r\n}\r\nfor (i = SWH_MIXER_START; i <= SWH_MIXER_END; i++) {\r\nstate = get_switch_state(mixer, i);\r\ndo_switch(mixer->atc, i, state);\r\n}\r\nreturn 0;\r\n}\r\nint ct_mixer_destroy(struct ct_mixer *mixer)\r\n{\r\nstruct sum_mgr *sum_mgr = (struct sum_mgr *)mixer->atc->rsc_mgrs[SUM];\r\nstruct amixer_mgr *amixer_mgr =\r\n(struct amixer_mgr *)mixer->atc->rsc_mgrs[AMIXER];\r\nstruct amixer *amixer;\r\nint i = 0;\r\nfor (i = 0; i < (NUM_CT_AMIXERS * CHN_NUM); i++) {\r\nif (NULL != mixer->amixers[i]) {\r\namixer = mixer->amixers[i];\r\namixer_mgr->put_amixer(amixer_mgr, amixer);\r\n}\r\n}\r\nfor (i = 0; i < (NUM_CT_SUMS * CHN_NUM); i++) {\r\nif (NULL != mixer->sums[i])\r\nsum_mgr->put_sum(sum_mgr, (struct sum *)mixer->sums[i]);\r\n}\r\nkfree(mixer->sums);\r\nkfree(mixer->amixers);\r\nkfree(mixer);\r\nreturn 0;\r\n}\r\nint ct_mixer_create(struct ct_atc *atc, struct ct_mixer **rmixer)\r\n{\r\nstruct ct_mixer *mixer;\r\nint err;\r\n*rmixer = NULL;\r\nerr = ct_mixer_get_mem(&mixer);\r\nif (err)\r\nreturn err;\r\nmixer->switch_state = 0;\r\nmixer->atc = atc;\r\nmixer->get_output_ports = mixer_get_output_ports;\r\nmixer->set_input_left = mixer_set_input_left;\r\nmixer->set_input_right = mixer_set_input_right;\r\n#ifdef CONFIG_PM\r\nmixer->resume = mixer_resume;\r\n#endif\r\nerr = ct_mixer_get_resources(mixer);\r\nif (err)\r\ngoto error;\r\nct_mixer_topology_build(mixer);\r\n*rmixer = mixer;\r\nreturn 0;\r\nerror:\r\nct_mixer_destroy(mixer);\r\nreturn err;\r\n}\r\nint ct_alsa_mix_create(struct ct_atc *atc,\r\nenum CTALSADEVS device,\r\nconst char *device_name)\r\n{\r\nint err;\r\nerr = ct_mixer_kcontrols_create((struct ct_mixer *)atc->mixer);\r\nif (err)\r\nreturn err;\r\nstrcpy(atc->card->mixername, device_name);\r\nreturn 0;\r\n}
