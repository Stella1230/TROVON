static void rt5631_write_index(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int value)\r\n{\r\nsnd_soc_write(codec, RT5631_INDEX_ADD, reg);\r\nsnd_soc_write(codec, RT5631_INDEX_DATA, value);\r\n}\r\nstatic unsigned int rt5631_read_index(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nunsigned int value;\r\nsnd_soc_write(codec, RT5631_INDEX_ADD, reg);\r\nvalue = snd_soc_read(codec, RT5631_INDEX_DATA);\r\nreturn value;\r\n}\r\nstatic int rt5631_reset(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_write(codec, RT5631_RESET, 0);\r\n}\r\nstatic bool rt5631_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT5631_RESET:\r\ncase RT5631_INT_ST_IRQ_CTRL_2:\r\ncase RT5631_INDEX_ADD:\r\ncase RT5631_INDEX_DATA:\r\ncase RT5631_EQ_CTRL:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic bool rt5631_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT5631_RESET:\r\ncase RT5631_SPK_OUT_VOL:\r\ncase RT5631_HP_OUT_VOL:\r\ncase RT5631_MONO_AXO_1_2_VOL:\r\ncase RT5631_AUX_IN_VOL:\r\ncase RT5631_STEREO_DAC_VOL_1:\r\ncase RT5631_MIC_CTRL_1:\r\ncase RT5631_STEREO_DAC_VOL_2:\r\ncase RT5631_ADC_CTRL_1:\r\ncase RT5631_ADC_REC_MIXER:\r\ncase RT5631_ADC_CTRL_2:\r\ncase RT5631_VDAC_DIG_VOL:\r\ncase RT5631_OUTMIXER_L_CTRL:\r\ncase RT5631_OUTMIXER_R_CTRL:\r\ncase RT5631_AXO1MIXER_CTRL:\r\ncase RT5631_AXO2MIXER_CTRL:\r\ncase RT5631_MIC_CTRL_2:\r\ncase RT5631_DIG_MIC_CTRL:\r\ncase RT5631_MONO_INPUT_VOL:\r\ncase RT5631_SPK_MIXER_CTRL:\r\ncase RT5631_SPK_MONO_OUT_CTRL:\r\ncase RT5631_SPK_MONO_HP_OUT_CTRL:\r\ncase RT5631_SDP_CTRL:\r\ncase RT5631_MONO_SDP_CTRL:\r\ncase RT5631_STEREO_AD_DA_CLK_CTRL:\r\ncase RT5631_PWR_MANAG_ADD1:\r\ncase RT5631_PWR_MANAG_ADD2:\r\ncase RT5631_PWR_MANAG_ADD3:\r\ncase RT5631_PWR_MANAG_ADD4:\r\ncase RT5631_GEN_PUR_CTRL_REG:\r\ncase RT5631_GLOBAL_CLK_CTRL:\r\ncase RT5631_PLL_CTRL:\r\ncase RT5631_INT_ST_IRQ_CTRL_1:\r\ncase RT5631_INT_ST_IRQ_CTRL_2:\r\ncase RT5631_GPIO_CTRL:\r\ncase RT5631_MISC_CTRL:\r\ncase RT5631_DEPOP_FUN_CTRL_1:\r\ncase RT5631_DEPOP_FUN_CTRL_2:\r\ncase RT5631_JACK_DET_CTRL:\r\ncase RT5631_SOFT_VOL_CTRL:\r\ncase RT5631_ALC_CTRL_1:\r\ncase RT5631_ALC_CTRL_2:\r\ncase RT5631_ALC_CTRL_3:\r\ncase RT5631_PSEUDO_SPATL_CTRL:\r\ncase RT5631_INDEX_ADD:\r\ncase RT5631_INDEX_DATA:\r\ncase RT5631_EQ_CTRL:\r\ncase RT5631_VENDOR_ID:\r\ncase RT5631_VENDOR_ID1:\r\ncase RT5631_VENDOR_ID2:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int rt5631_dmic_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = rt5631->dmic_used_flag;\r\nreturn 0;\r\n}\r\nstatic int rt5631_dmic_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nrt5631->dmic_used_flag = ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int check_sysclk1_source(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg;\r\nreg = snd_soc_read(source->codec, RT5631_GLOBAL_CLK_CTRL);\r\nreturn reg & RT5631_SYSCLK_SOUR_SEL_PLL;\r\n}\r\nstatic int check_dmic_used(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(source->codec);\r\nreturn rt5631->dmic_used_flag;\r\n}\r\nstatic int check_dacl_to_outmixl(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg;\r\nreg = snd_soc_read(source->codec, RT5631_OUTMIXER_L_CTRL);\r\nreturn !(reg & RT5631_M_DAC_L_TO_OUTMIXER_L);\r\n}\r\nstatic int check_dacr_to_outmixr(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg;\r\nreg = snd_soc_read(source->codec, RT5631_OUTMIXER_R_CTRL);\r\nreturn !(reg & RT5631_M_DAC_R_TO_OUTMIXER_R);\r\n}\r\nstatic int check_dacl_to_spkmixl(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg;\r\nreg = snd_soc_read(source->codec, RT5631_SPK_MIXER_CTRL);\r\nreturn !(reg & RT5631_M_DAC_L_TO_SPKMIXER_L);\r\n}\r\nstatic int check_dacr_to_spkmixr(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg;\r\nreg = snd_soc_read(source->codec, RT5631_SPK_MIXER_CTRL);\r\nreturn !(reg & RT5631_M_DAC_R_TO_SPKMIXER_R);\r\n}\r\nstatic int check_adcl_select(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg;\r\nreg = snd_soc_read(source->codec, RT5631_ADC_REC_MIXER);\r\nreturn !(reg & RT5631_M_MIC1_TO_RECMIXER_L);\r\n}\r\nstatic int check_adcr_select(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nunsigned int reg;\r\nreg = snd_soc_read(source->codec, RT5631_ADC_REC_MIXER);\r\nreturn !(reg & RT5631_M_MIC2_TO_RECMIXER_R);\r\n}\r\nstatic void onebit_depop_power_stage(struct snd_soc_codec *codec, int enable)\r\n{\r\nunsigned int soft_vol, hp_zc;\r\nsnd_soc_update_bits(codec, RT5631_DEPOP_FUN_CTRL_2,\r\nRT5631_EN_ONE_BIT_DEPOP, 0);\r\nsoft_vol = snd_soc_read(codec, RT5631_SOFT_VOL_CTRL);\r\nsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, 0);\r\nhp_zc = snd_soc_read(codec, RT5631_INT_ST_IRQ_CTRL_2);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);\r\nif (enable) {\r\nrt5631_write_index(codec, RT5631_TEST_MODE_CTRL, 0x84c0);\r\nrt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x309f);\r\nrt5631_write_index(codec, RT5631_CP_INTL_REG2, 0x6530);\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_2,\r\nRT5631_EN_CAP_FREE_DEPOP);\r\n} else {\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_2, 0);\r\nmsleep(100);\r\n}\r\nsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, soft_vol);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc);\r\n}\r\nstatic void onebit_depop_mute_stage(struct snd_soc_codec *codec, int enable)\r\n{\r\nunsigned int soft_vol, hp_zc;\r\nsnd_soc_update_bits(codec, RT5631_DEPOP_FUN_CTRL_2,\r\nRT5631_EN_ONE_BIT_DEPOP, 0);\r\nsoft_vol = snd_soc_read(codec, RT5631_SOFT_VOL_CTRL);\r\nsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, 0);\r\nhp_zc = snd_soc_read(codec, RT5631_INT_ST_IRQ_CTRL_2);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);\r\nif (enable) {\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(10));\r\nrt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x307f);\r\nsnd_soc_update_bits(codec, RT5631_HP_OUT_VOL,\r\nRT5631_L_MUTE | RT5631_R_MUTE, 0);\r\nmsleep(300);\r\n} else {\r\nsnd_soc_update_bits(codec, RT5631_HP_OUT_VOL,\r\nRT5631_L_MUTE | RT5631_R_MUTE,\r\nRT5631_L_MUTE | RT5631_R_MUTE);\r\nmsleep(100);\r\n}\r\nsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, soft_vol);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc);\r\n}\r\nstatic void depop_seq_power_stage(struct snd_soc_codec *codec, int enable)\r\n{\r\nunsigned int soft_vol, hp_zc;\r\nsnd_soc_update_bits(codec, RT5631_DEPOP_FUN_CTRL_2,\r\nRT5631_EN_ONE_BIT_DEPOP, RT5631_EN_ONE_BIT_DEPOP);\r\nsoft_vol = snd_soc_read(codec, RT5631_SOFT_VOL_CTRL);\r\nsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, 0);\r\nhp_zc = snd_soc_read(codec, RT5631_INT_ST_IRQ_CTRL_2);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);\r\nif (enable) {\r\nrt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x303e);\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD3,\r\nRT5631_PWR_CHARGE_PUMP | RT5631_PWR_HP_L_AMP |\r\nRT5631_PWR_HP_R_AMP,\r\nRT5631_PWR_CHARGE_PUMP | RT5631_PWR_HP_L_AMP |\r\nRT5631_PWR_HP_R_AMP);\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_1,\r\nRT5631_POW_ON_SOFT_GEN | RT5631_EN_DEPOP2_FOR_HP);\r\nmsleep(100);\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD3,\r\nRT5631_PWR_HP_DEPOP_DIS, RT5631_PWR_HP_DEPOP_DIS);\r\n} else {\r\nrt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x303F);\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_1,\r\nRT5631_POW_ON_SOFT_GEN | RT5631_EN_MUTE_UNMUTE_DEPOP |\r\nRT5631_PD_HPAMP_L_ST_UP | RT5631_PD_HPAMP_R_ST_UP);\r\nmsleep(75);\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_1,\r\nRT5631_POW_ON_SOFT_GEN | RT5631_PD_HPAMP_L_ST_UP |\r\nRT5631_PD_HPAMP_R_ST_UP);\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD3,\r\nRT5631_PWR_HP_DEPOP_DIS, 0);\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_1,\r\nRT5631_POW_ON_SOFT_GEN | RT5631_EN_DEPOP2_FOR_HP |\r\nRT5631_PD_HPAMP_L_ST_UP | RT5631_PD_HPAMP_R_ST_UP);\r\nmsleep(80);\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_1,\r\nRT5631_POW_ON_SOFT_GEN);\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD3,\r\nRT5631_PWR_CHARGE_PUMP | RT5631_PWR_HP_L_AMP |\r\nRT5631_PWR_HP_R_AMP, 0);\r\n}\r\nsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, soft_vol);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc);\r\n}\r\nstatic void depop_seq_mute_stage(struct snd_soc_codec *codec, int enable)\r\n{\r\nunsigned int soft_vol, hp_zc;\r\nsnd_soc_update_bits(codec, RT5631_DEPOP_FUN_CTRL_2,\r\nRT5631_EN_ONE_BIT_DEPOP, RT5631_EN_ONE_BIT_DEPOP);\r\nsoft_vol = snd_soc_read(codec, RT5631_SOFT_VOL_CTRL);\r\nsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, 0);\r\nhp_zc = snd_soc_read(codec, RT5631_INT_ST_IRQ_CTRL_2);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);\r\nif (enable) {\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(10));\r\nrt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x302f);\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_1,\r\nRT5631_POW_ON_SOFT_GEN | RT5631_EN_MUTE_UNMUTE_DEPOP |\r\nRT5631_EN_HP_R_M_UN_MUTE_DEPOP |\r\nRT5631_EN_HP_L_M_UN_MUTE_DEPOP);\r\nsnd_soc_update_bits(codec, RT5631_HP_OUT_VOL,\r\nRT5631_L_MUTE | RT5631_R_MUTE, 0);\r\nmsleep(160);\r\n} else {\r\nrt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x302f);\r\nsnd_soc_write(codec, RT5631_DEPOP_FUN_CTRL_1,\r\nRT5631_POW_ON_SOFT_GEN | RT5631_EN_MUTE_UNMUTE_DEPOP |\r\nRT5631_EN_HP_R_M_UN_MUTE_DEPOP |\r\nRT5631_EN_HP_L_M_UN_MUTE_DEPOP);\r\nsnd_soc_update_bits(codec, RT5631_HP_OUT_VOL,\r\nRT5631_L_MUTE | RT5631_R_MUTE,\r\nRT5631_L_MUTE | RT5631_R_MUTE);\r\nmsleep(150);\r\n}\r\nsnd_soc_write(codec, RT5631_SOFT_VOL_CTRL, soft_vol);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc);\r\n}\r\nstatic int hp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nif (rt5631->codec_version) {\r\nonebit_depop_mute_stage(codec, 0);\r\nonebit_depop_power_stage(codec, 0);\r\n} else {\r\ndepop_seq_mute_stage(codec, 0);\r\ndepop_seq_power_stage(codec, 0);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (rt5631->codec_version) {\r\nonebit_depop_power_stage(codec, 1);\r\nonebit_depop_mute_stage(codec, 1);\r\n} else {\r\ndepop_seq_power_stage(codec, 1);\r\ndepop_seq_mute_stage(codec, 1);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_dmic_params(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nswitch (rt5631->rx_rate) {\r\ncase 44100:\r\ncase 48000:\r\nsnd_soc_update_bits(codec, RT5631_DIG_MIC_CTRL,\r\nRT5631_DMIC_CLK_CTRL_MASK,\r\nRT5631_DMIC_CLK_CTRL_TO_32FS);\r\nbreak;\r\ncase 32000:\r\ncase 22050:\r\nsnd_soc_update_bits(codec, RT5631_DIG_MIC_CTRL,\r\nRT5631_DMIC_CLK_CTRL_MASK,\r\nRT5631_DMIC_CLK_CTRL_TO_64FS);\r\nbreak;\r\ncase 16000:\r\ncase 11025:\r\ncase 8000:\r\nsnd_soc_update_bits(codec, RT5631_DIG_MIC_CTRL,\r\nRT5631_DMIC_CLK_CTRL_MASK,\r\nRT5631_DMIC_CLK_CTRL_TO_128FS);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_coeff(int mclk, int rate, int timesofbclk)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\r\nif (coeff_div[i].mclk == mclk && coeff_div[i].rate == rate &&\r\n(coeff_div[i].bclk / coeff_div[i].rate) == timesofbclk)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int rt5631_hifi_pcm_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nint timesofbclk = 32, coeff;\r\nunsigned int iface = 0;\r\ndev_dbg(codec->dev, "enter %s\n", __func__);\r\nrt5631->bclk_rate = snd_soc_params_to_bclk(params);\r\nif (rt5631->bclk_rate < 0) {\r\ndev_err(codec->dev, "Fail to get BCLK rate\n");\r\nreturn rt5631->bclk_rate;\r\n}\r\nrt5631->rx_rate = params_rate(params);\r\nif (rt5631->master)\r\ncoeff = get_coeff(rt5631->sysclk, rt5631->rx_rate,\r\nrt5631->bclk_rate / rt5631->rx_rate);\r\nelse\r\ncoeff = get_coeff(rt5631->sysclk, rt5631->rx_rate,\r\ntimesofbclk);\r\nif (coeff < 0) {\r\ndev_err(codec->dev, "Fail to get coeff\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\niface |= RT5631_SDP_I2S_DL_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niface |= RT5631_SDP_I2S_DL_24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S8:\r\niface |= RT5631_SDP_I2S_DL_8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, RT5631_SDP_CTRL,\r\nRT5631_SDP_I2S_DL_MASK, iface);\r\nsnd_soc_write(codec, RT5631_STEREO_AD_DA_CLK_CTRL,\r\ncoeff_div[coeff].reg_val);\r\nreturn 0;\r\n}\r\nstatic int rt5631_hifi_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int iface = 0;\r\ndev_dbg(codec->dev, "enter %s\n", __func__);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nrt5631->master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\niface |= RT5631_SDP_MODE_SEL_SLAVE;\r\nrt5631->master = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= RT5631_SDP_I2S_DF_LEFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= RT5631_SDP_I2S_DF_PCM_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface |= RT5631_SDP_I2S_DF_PCM_B;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= RT5631_SDP_I2S_BCLK_POL_CTRL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, RT5631_SDP_CTRL, iface);\r\nreturn 0;\r\n}\r\nstatic int rt5631_hifi_codec_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "enter %s, syclk=%d\n", __func__, freq);\r\nif ((freq >= (256 * 8000)) && (freq <= (512 * 96000))) {\r\nrt5631->sysclk = freq;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int rt5631_codec_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nint i, ret = -EINVAL;\r\ndev_dbg(codec->dev, "enter %s\n", __func__);\r\nif (!freq_in || !freq_out) {\r\ndev_dbg(codec->dev, "PLL disabled\n");\r\nsnd_soc_update_bits(codec, RT5631_GLOBAL_CLK_CTRL,\r\nRT5631_SYSCLK_SOUR_SEL_MASK,\r\nRT5631_SYSCLK_SOUR_SEL_MCLK);\r\nreturn 0;\r\n}\r\nif (rt5631->master) {\r\nfor (i = 0; i < ARRAY_SIZE(codec_master_pll_div); i++)\r\nif (freq_in == codec_master_pll_div[i].pll_in &&\r\nfreq_out == codec_master_pll_div[i].pll_out) {\r\ndev_info(codec->dev,\r\n"change PLL in master mode\n");\r\nsnd_soc_write(codec, RT5631_PLL_CTRL,\r\ncodec_master_pll_div[i].reg_val);\r\nschedule_timeout_uninterruptible(\r\nmsecs_to_jiffies(20));\r\nsnd_soc_update_bits(codec,\r\nRT5631_GLOBAL_CLK_CTRL,\r\nRT5631_SYSCLK_SOUR_SEL_MASK |\r\nRT5631_PLLCLK_SOUR_SEL_MASK,\r\nRT5631_SYSCLK_SOUR_SEL_PLL |\r\nRT5631_PLLCLK_SOUR_SEL_MCLK);\r\nret = 0;\r\nbreak;\r\n}\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(codec_slave_pll_div); i++)\r\nif (freq_in == codec_slave_pll_div[i].pll_in &&\r\nfreq_out == codec_slave_pll_div[i].pll_out) {\r\ndev_info(codec->dev,\r\n"change PLL in slave mode\n");\r\nsnd_soc_write(codec, RT5631_PLL_CTRL,\r\ncodec_slave_pll_div[i].reg_val);\r\nschedule_timeout_uninterruptible(\r\nmsecs_to_jiffies(20));\r\nsnd_soc_update_bits(codec,\r\nRT5631_GLOBAL_CLK_CTRL,\r\nRT5631_SYSCLK_SOUR_SEL_MASK |\r\nRT5631_PLLCLK_SOUR_SEL_MASK,\r\nRT5631_SYSCLK_SOUR_SEL_PLL |\r\nRT5631_PLLCLK_SOUR_SEL_BCLK);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int rt5631_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD2,\r\nRT5631_PWR_MICBIAS1_VOL | RT5631_PWR_MICBIAS2_VOL,\r\nRT5631_PWR_MICBIAS1_VOL | RT5631_PWR_MICBIAS2_VOL);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD3,\r\nRT5631_PWR_VREF | RT5631_PWR_MAIN_BIAS,\r\nRT5631_PWR_VREF | RT5631_PWR_MAIN_BIAS);\r\nmsleep(80);\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD3,\r\nRT5631_PWR_FAST_VREF_CTRL,\r\nRT5631_PWR_FAST_VREF_CTRL);\r\nregcache_cache_only(rt5631->regmap, false);\r\nregcache_sync(rt5631->regmap);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, RT5631_PWR_MANAG_ADD1, 0x0000);\r\nsnd_soc_write(codec, RT5631_PWR_MANAG_ADD2, 0x0000);\r\nsnd_soc_write(codec, RT5631_PWR_MANAG_ADD3, 0x0000);\r\nsnd_soc_write(codec, RT5631_PWR_MANAG_ADD4, 0x0000);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int rt5631_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nint ret;\r\ncodec->control_data = rt5631->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nval = rt5631_read_index(codec, RT5631_ADDA_MIXER_INTL_REG3);\r\nif (val & 0x0002)\r\nrt5631->codec_version = 1;\r\nelse\r\nrt5631->codec_version = 0;\r\nrt5631_reset(codec);\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD3,\r\nRT5631_PWR_VREF | RT5631_PWR_MAIN_BIAS,\r\nRT5631_PWR_VREF | RT5631_PWR_MAIN_BIAS);\r\nmsleep(80);\r\nsnd_soc_update_bits(codec, RT5631_PWR_MANAG_ADD3,\r\nRT5631_PWR_FAST_VREF_CTRL, RT5631_PWR_FAST_VREF_CTRL);\r\nsnd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, 0x0f18);\r\nif (rt5631->codec_version)\r\nsnd_soc_update_bits(codec, RT5631_INT_ST_IRQ_CTRL_2,\r\n0x2000, 0x2000);\r\nelse\r\nsnd_soc_update_bits(codec, RT5631_INT_ST_IRQ_CTRL_2,\r\n0x2000, 0);\r\nif (rt5631->dmic_used_flag) {\r\nsnd_soc_update_bits(codec, RT5631_GPIO_CTRL,\r\nRT5631_GPIO_PIN_FUN_SEL_MASK |\r\nRT5631_GPIO_DMIC_FUN_SEL_MASK,\r\nRT5631_GPIO_PIN_FUN_SEL_GPIO_DIMC |\r\nRT5631_GPIO_DMIC_FUN_SEL_DIMC);\r\nsnd_soc_update_bits(codec, RT5631_DIG_MIC_CTRL,\r\nRT5631_DMIC_L_CH_LATCH_MASK |\r\nRT5631_DMIC_R_CH_LATCH_MASK,\r\nRT5631_DMIC_L_CH_LATCH_FALLING |\r\nRT5631_DMIC_R_CH_LATCH_RISING);\r\n}\r\ncodec->dapm.bias_level = SND_SOC_BIAS_STANDBY;\r\nreturn 0;\r\n}\r\nstatic int rt5631_remove(struct snd_soc_codec *codec)\r\n{\r\nrt5631_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int rt5631_suspend(struct snd_soc_codec *codec)\r\n{\r\nrt5631_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int rt5631_resume(struct snd_soc_codec *codec)\r\n{\r\nrt5631_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int rt5631_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rt5631_priv *rt5631;\r\nint ret;\r\nrt5631 = devm_kzalloc(&i2c->dev, sizeof(struct rt5631_priv),\r\nGFP_KERNEL);\r\nif (NULL == rt5631)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, rt5631);\r\nrt5631->regmap = devm_regmap_init_i2c(i2c, &rt5631_regmap_config);\r\nif (IS_ERR(rt5631->regmap))\r\nreturn PTR_ERR(rt5631->regmap);\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5631,\r\nrt5631_dai, ARRAY_SIZE(rt5631_dai));\r\nreturn ret;\r\n}\r\nstatic __devexit int rt5631_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
