static inline int at91mci_is_mci1rev2xx(void)\r\n{\r\nreturn ( cpu_is_at91sam9260()\r\n|| cpu_is_at91sam9263()\r\n|| cpu_is_at91sam9rl()\r\n|| cpu_is_at91sam9g10()\r\n|| cpu_is_at91sam9g20()\r\n);\r\n}\r\nstatic void at91_reset_host(struct at91mci_host *host)\r\n{\r\nunsigned long flags;\r\nu32 mr;\r\nu32 sdcr;\r\nu32 dtor;\r\nu32 imr;\r\nlocal_irq_save(flags);\r\nimr = at91_mci_read(host, AT91_MCI_IMR);\r\nat91_mci_write(host, AT91_MCI_IDR, 0xffffffff);\r\nmr = at91_mci_read(host, AT91_MCI_MR) & 0x7fff;\r\nsdcr = at91_mci_read(host, AT91_MCI_SDCR);\r\ndtor = at91_mci_read(host, AT91_MCI_DTOR);\r\nat91_mci_write(host, AT91_MCI_CR, AT91_MCI_MCIDIS | AT91_MCI_SWRST);\r\nat91_mci_write(host, AT91_MCI_CR, AT91_MCI_MCIEN);\r\nat91_mci_write(host, AT91_MCI_MR, mr);\r\nat91_mci_write(host, AT91_MCI_SDCR, sdcr);\r\nat91_mci_write(host, AT91_MCI_DTOR, dtor);\r\nat91_mci_write(host, AT91_MCI_IER, imr);\r\nat91_mci_read(host, AT91_MCI_SR);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void at91_timeout_timer(unsigned long data)\r\n{\r\nstruct at91mci_host *host;\r\nhost = (struct at91mci_host *)data;\r\nif (host->request) {\r\ndev_err(host->mmc->parent, "Timeout waiting end of packet\n");\r\nif (host->cmd && host->cmd->data) {\r\nhost->cmd->data->error = -ETIMEDOUT;\r\n} else {\r\nif (host->cmd)\r\nhost->cmd->error = -ETIMEDOUT;\r\nelse\r\nhost->request->cmd->error = -ETIMEDOUT;\r\n}\r\nat91_reset_host(host);\r\nmmc_request_done(host->mmc, host->request);\r\n}\r\n}\r\nstatic inline void at91_mci_sg_to_dma(struct at91mci_host *host, struct mmc_data *data)\r\n{\r\nunsigned int len, i, size;\r\nunsigned *dmabuf = host->buffer;\r\nsize = data->blksz * data->blocks;\r\nlen = data->sg_len;\r\nif (at91mci_is_mci1rev2xx())\r\nif (host->total_length == 12)\r\nmemset(dmabuf, 0, 12);\r\nfor (i = 0; i < len; i++) {\r\nstruct scatterlist *sg;\r\nint amount;\r\nunsigned int *sgbuffer;\r\nsg = &data->sg[i];\r\nsgbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\r\namount = min(size, sg->length);\r\nsize -= amount;\r\nif (cpu_is_at91rm9200()) {\r\nint index;\r\nfor (index = 0; index < (amount / 4); index++)\r\n*dmabuf++ = swab32(sgbuffer[index]);\r\n} else {\r\nchar *tmpv = (char *)dmabuf;\r\nmemcpy(tmpv, sgbuffer, amount);\r\ntmpv += amount;\r\ndmabuf = (unsigned *)tmpv;\r\n}\r\nkunmap_atomic(sgbuffer);\r\nif (size == 0)\r\nbreak;\r\n}\r\nBUG_ON(size != 0);\r\n}\r\nstatic void at91_mci_post_dma_read(struct at91mci_host *host)\r\n{\r\nstruct mmc_command *cmd;\r\nstruct mmc_data *data;\r\nunsigned int len, i, size;\r\nunsigned *dmabuf = host->buffer;\r\npr_debug("post dma read\n");\r\ncmd = host->cmd;\r\nif (!cmd) {\r\npr_debug("no command\n");\r\nreturn;\r\n}\r\ndata = cmd->data;\r\nif (!data) {\r\npr_debug("no data\n");\r\nreturn;\r\n}\r\nsize = data->blksz * data->blocks;\r\nlen = data->sg_len;\r\nat91_mci_write(host, AT91_MCI_IDR, AT91_MCI_ENDRX);\r\nat91_mci_write(host, AT91_MCI_IER, AT91_MCI_RXBUFF);\r\nfor (i = 0; i < len; i++) {\r\nstruct scatterlist *sg;\r\nint amount;\r\nunsigned int *sgbuffer;\r\nsg = &data->sg[i];\r\nsgbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\r\namount = min(size, sg->length);\r\nsize -= amount;\r\nif (cpu_is_at91rm9200()) {\r\nint index;\r\nfor (index = 0; index < (amount / 4); index++)\r\nsgbuffer[index] = swab32(*dmabuf++);\r\n} else {\r\nchar *tmpv = (char *)dmabuf;\r\nmemcpy(sgbuffer, tmpv, amount);\r\ntmpv += amount;\r\ndmabuf = (unsigned *)tmpv;\r\n}\r\nflush_kernel_dcache_page(sg_page(sg));\r\nkunmap_atomic(sgbuffer);\r\ndata->bytes_xfered += amount;\r\nif (size == 0)\r\nbreak;\r\n}\r\npr_debug("post dma read done\n");\r\n}\r\nstatic void at91_mci_handle_transmitted(struct at91mci_host *host)\r\n{\r\nstruct mmc_command *cmd;\r\nstruct mmc_data *data;\r\npr_debug("Handling the transmit\n");\r\nat91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);\r\nat91_mci_write(host, AT91_MCI_IDR, AT91_MCI_TXBUFE);\r\ncmd = host->cmd;\r\nif (!cmd) return;\r\ndata = cmd->data;\r\nif (!data) return;\r\nif (cmd->data->blocks > 1) {\r\npr_debug("multiple write : wait for BLKE...\n");\r\nat91_mci_write(host, AT91_MCI_IER, AT91_MCI_BLKE);\r\n} else\r\nat91_mci_write(host, AT91_MCI_IER, AT91_MCI_NOTBUSY);\r\n}\r\nstatic void at91_mci_update_bytes_xfered(struct at91mci_host *host)\r\n{\r\nstruct mmc_data *data;\r\nif (host->request->cmd && host->request->cmd->error != 0)\r\nreturn;\r\nif (host->request->data) {\r\ndata = host->request->data;\r\nif (data->flags & MMC_DATA_WRITE) {\r\npr_debug("-> bytes_xfered %d, total_length = %d\n",\r\ndata->bytes_xfered, host->total_length);\r\ndata->bytes_xfered = data->blksz * data->blocks;\r\n}\r\n}\r\n}\r\nstatic int at91_mci_handle_cmdrdy(struct at91mci_host *host)\r\n{\r\nif (!host->cmd)\r\nreturn 1;\r\nelse if (!host->cmd->data) {\r\nif (host->flags & FL_SENT_STOP) {\r\nat91_mci_write(host, AT91_MCI_IER, AT91_MCI_NOTBUSY);\r\n} else return 1;\r\n} else if (host->cmd->data->flags & MMC_DATA_WRITE) {\r\nat91_mci_write(host, AT91_MCI_IER, AT91_MCI_TXBUFE | AT91_MCI_BLKE);\r\nat91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\r\n}\r\nreturn 0;\r\n}\r\nstatic void at91_mci_enable(struct at91mci_host *host)\r\n{\r\nunsigned int mr;\r\nat91_mci_write(host, AT91_MCI_CR, AT91_MCI_MCIEN);\r\nat91_mci_write(host, AT91_MCI_IDR, 0xffffffff);\r\nat91_mci_write(host, AT91_MCI_DTOR, AT91_MCI_DTOMUL_1M | AT91_MCI_DTOCYC);\r\nmr = AT91_MCI_PDCMODE | 0x34a;\r\nif (at91mci_is_mci1rev2xx())\r\nmr |= AT91_MCI_RDPROOF | AT91_MCI_WRPROOF;\r\nat91_mci_write(host, AT91_MCI_MR, mr);\r\nat91_mci_write(host, AT91_MCI_SDCR, host->board->slot_b);\r\n}\r\nstatic void at91_mci_disable(struct at91mci_host *host)\r\n{\r\nat91_mci_write(host, AT91_MCI_CR, AT91_MCI_MCIDIS | AT91_MCI_SWRST);\r\n}\r\nstatic void at91_mci_send_command(struct at91mci_host *host, struct mmc_command *cmd)\r\n{\r\nunsigned int cmdr, mr;\r\nunsigned int block_length;\r\nstruct mmc_data *data = cmd->data;\r\nunsigned int blocks;\r\nunsigned int ier = 0;\r\nhost->cmd = cmd;\r\nif ((at91_mci_read(host, AT91_MCI_SR) & AT91_MCI_RTOE) && (cmd->opcode == 1)) {\r\npr_debug("Clearing timeout\n");\r\nat91_mci_write(host, AT91_MCI_ARGR, 0);\r\nat91_mci_write(host, AT91_MCI_CMDR, AT91_MCI_OPDCMD);\r\nwhile (!(at91_mci_read(host, AT91_MCI_SR) & AT91_MCI_CMDRDY)) {\r\npr_debug("Clearing: SR = %08X\n", at91_mci_read(host, AT91_MCI_SR));\r\n}\r\n}\r\ncmdr = cmd->opcode;\r\nif (mmc_resp_type(cmd) == MMC_RSP_NONE)\r\ncmdr |= AT91_MCI_RSPTYP_NONE;\r\nelse {\r\ncmdr |= AT91_MCI_MAXLAT;\r\nif (mmc_resp_type(cmd) == MMC_RSP_R2)\r\ncmdr |= AT91_MCI_RSPTYP_136;\r\nelse\r\ncmdr |= AT91_MCI_RSPTYP_48;\r\n}\r\nif (data) {\r\nif (cpu_is_at91rm9200() || cpu_is_at91sam9261()) {\r\nif (data->blksz & 0x3) {\r\npr_debug("Unsupported block size\n");\r\ncmd->error = -EINVAL;\r\nmmc_request_done(host->mmc, host->request);\r\nreturn;\r\n}\r\nif (data->flags & MMC_DATA_STREAM) {\r\npr_debug("Stream commands not supported\n");\r\ncmd->error = -EINVAL;\r\nmmc_request_done(host->mmc, host->request);\r\nreturn;\r\n}\r\n}\r\nblock_length = data->blksz;\r\nblocks = data->blocks;\r\nif (data->flags & MMC_DATA_READ)\r\ncmdr |= (AT91_MCI_TRDIR | AT91_MCI_TRCMD_START);\r\nelse if (data->flags & MMC_DATA_WRITE)\r\ncmdr |= AT91_MCI_TRCMD_START;\r\nif (cmd->opcode == SD_IO_RW_EXTENDED) {\r\ncmdr |= AT91_MCI_TRTYP_SDIO_BLOCK;\r\n} else {\r\nif (data->flags & MMC_DATA_STREAM)\r\ncmdr |= AT91_MCI_TRTYP_STREAM;\r\nif (data->blocks > 1)\r\ncmdr |= AT91_MCI_TRTYP_MULTIPLE;\r\n}\r\n}\r\nelse {\r\nblock_length = 0;\r\nblocks = 0;\r\n}\r\nif (host->flags & FL_SENT_STOP)\r\ncmdr |= AT91_MCI_TRCMD_STOP;\r\nif (host->bus_mode == MMC_BUSMODE_OPENDRAIN)\r\ncmdr |= AT91_MCI_OPDCMD;\r\npr_debug("Sending command %d as %08X, arg = %08X, blocks = %d, length = %d (MR = %08X)\n",\r\ncmd->opcode, cmdr, cmd->arg, blocks, block_length, at91_mci_read(host, AT91_MCI_MR));\r\nif (!data) {\r\nat91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS | ATMEL_PDC_RXTDIS);\r\nat91_mci_write(host, ATMEL_PDC_RPR, 0);\r\nat91_mci_write(host, ATMEL_PDC_RCR, 0);\r\nat91_mci_write(host, ATMEL_PDC_RNPR, 0);\r\nat91_mci_write(host, ATMEL_PDC_RNCR, 0);\r\nat91_mci_write(host, ATMEL_PDC_TPR, 0);\r\nat91_mci_write(host, ATMEL_PDC_TCR, 0);\r\nat91_mci_write(host, ATMEL_PDC_TNPR, 0);\r\nat91_mci_write(host, ATMEL_PDC_TNCR, 0);\r\nier = AT91_MCI_CMDRDY;\r\n} else {\r\nmr = at91_mci_read(host, AT91_MCI_MR) & 0x5fff;\r\nmr |= (data->blksz & 0x3) ? AT91_MCI_PDCFBYTE : 0;\r\nmr |= (block_length << 16);\r\nmr |= AT91_MCI_PDCMODE;\r\nat91_mci_write(host, AT91_MCI_MR, mr);\r\nif (!(cpu_is_at91rm9200() || cpu_is_at91sam9261()))\r\nat91_mci_write(host, AT91_MCI_BLKR,\r\nAT91_MCI_BLKR_BCNT(blocks) |\r\nAT91_MCI_BLKR_BLKLEN(block_length));\r\nat91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);\r\nif (cmdr & AT91_MCI_TRCMD_START) {\r\ndata->bytes_xfered = 0;\r\nhost->transfer_index = 0;\r\nhost->in_use_index = 0;\r\nif (cmdr & AT91_MCI_TRDIR) {\r\nhost->total_length = 0;\r\nat91_mci_write(host, ATMEL_PDC_RPR, host->physical_address);\r\nat91_mci_write(host, ATMEL_PDC_RCR, (data->blksz & 0x3) ?\r\n(blocks * block_length) : (blocks * block_length) / 4);\r\nat91_mci_write(host, ATMEL_PDC_RNPR, 0);\r\nat91_mci_write(host, ATMEL_PDC_RNCR, 0);\r\nier = AT91_MCI_ENDRX ;\r\n}\r\nelse {\r\nhost->total_length = block_length * blocks;\r\nif (at91mci_is_mci1rev2xx())\r\nif (host->total_length < 12)\r\nhost->total_length = 12;\r\nat91_mci_sg_to_dma(host, data);\r\npr_debug("Transmitting %d bytes\n", host->total_length);\r\nat91_mci_write(host, ATMEL_PDC_TPR, host->physical_address);\r\nat91_mci_write(host, ATMEL_PDC_TCR, (data->blksz & 0x3) ?\r\nhost->total_length : host->total_length / 4);\r\nier = AT91_MCI_CMDRDY;\r\n}\r\n}\r\n}\r\nat91_mci_write(host, AT91_MCI_ARGR, cmd->arg);\r\nat91_mci_write(host, AT91_MCI_CMDR, cmdr);\r\nif (cmdr & AT91_MCI_TRCMD_START) {\r\nif (cmdr & AT91_MCI_TRDIR)\r\nat91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN);\r\n}\r\nat91_mci_write(host, AT91_MCI_IER, AT91_MCI_ERRORS | ier);\r\n}\r\nstatic void at91_mci_process_next(struct at91mci_host *host)\r\n{\r\nif (!(host->flags & FL_SENT_COMMAND)) {\r\nhost->flags |= FL_SENT_COMMAND;\r\nat91_mci_send_command(host, host->request->cmd);\r\n}\r\nelse if ((!(host->flags & FL_SENT_STOP)) && host->request->stop) {\r\nhost->flags |= FL_SENT_STOP;\r\nat91_mci_send_command(host, host->request->stop);\r\n} else {\r\ndel_timer(&host->timer);\r\nif (cpu_is_at91rm9200())\r\nat91_reset_host(host);\r\nmmc_request_done(host->mmc, host->request);\r\n}\r\n}\r\nstatic void at91_mci_completed_command(struct at91mci_host *host, unsigned int status)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nstruct mmc_data *data = cmd->data;\r\nat91_mci_write(host, AT91_MCI_IDR, 0xffffffff & ~(AT91_MCI_SDIOIRQA | AT91_MCI_SDIOIRQB));\r\ncmd->resp[0] = at91_mci_read(host, AT91_MCI_RSPR(0));\r\ncmd->resp[1] = at91_mci_read(host, AT91_MCI_RSPR(1));\r\ncmd->resp[2] = at91_mci_read(host, AT91_MCI_RSPR(2));\r\ncmd->resp[3] = at91_mci_read(host, AT91_MCI_RSPR(3));\r\npr_debug("Status = %08X/%08x [%08X %08X %08X %08X]\n",\r\nstatus, at91_mci_read(host, AT91_MCI_SR),\r\ncmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);\r\nif (status & AT91_MCI_ERRORS) {\r\nif ((status & AT91_MCI_RCRCE) && !(mmc_resp_type(cmd) & MMC_RSP_CRC)) {\r\ncmd->error = 0;\r\n}\r\nelse {\r\nif (status & (AT91_MCI_DTOE | AT91_MCI_DCRCE)) {\r\nif (data) {\r\nif (status & AT91_MCI_DTOE)\r\ndata->error = -ETIMEDOUT;\r\nelse if (status & AT91_MCI_DCRCE)\r\ndata->error = -EILSEQ;\r\n}\r\n} else {\r\nif (status & AT91_MCI_RTOE)\r\ncmd->error = -ETIMEDOUT;\r\nelse if (status & AT91_MCI_RCRCE)\r\ncmd->error = -EILSEQ;\r\nelse\r\ncmd->error = -EIO;\r\n}\r\npr_debug("Error detected and set to %d/%d (cmd = %d, retries = %d)\n",\r\ncmd->error, data ? data->error : 0,\r\ncmd->opcode, cmd->retries);\r\n}\r\n}\r\nelse\r\ncmd->error = 0;\r\nat91_mci_process_next(host);\r\n}\r\nstatic void at91_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct at91mci_host *host = mmc_priv(mmc);\r\nhost->request = mrq;\r\nhost->flags = 0;\r\nmod_timer(&host->timer, jiffies + msecs_to_jiffies(2000));\r\nat91_mci_process_next(host);\r\n}\r\nstatic void at91_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nint clkdiv;\r\nstruct at91mci_host *host = mmc_priv(mmc);\r\nunsigned long at91_master_clock = clk_get_rate(host->mci_clk);\r\nhost->bus_mode = ios->bus_mode;\r\nif (ios->clock == 0) {\r\nat91_mci_write(host, AT91_MCI_CR, AT91_MCI_MCIDIS);\r\nclkdiv = 0;\r\n}\r\nelse {\r\nat91_mci_write(host, AT91_MCI_CR, AT91_MCI_MCIEN);\r\nif ((at91_master_clock % (ios->clock * 2)) == 0)\r\nclkdiv = ((at91_master_clock / ios->clock) / 2) - 1;\r\nelse\r\nclkdiv = (at91_master_clock / ios->clock) / 2;\r\npr_debug("clkdiv = %d. mcck = %ld\n", clkdiv,\r\nat91_master_clock / (2 * (clkdiv + 1)));\r\n}\r\nif (ios->bus_width == MMC_BUS_WIDTH_4 && host->board->wire4) {\r\npr_debug("MMC: Setting controller bus width to 4\n");\r\nat91_mci_write(host, AT91_MCI_SDCR, at91_mci_read(host, AT91_MCI_SDCR) | AT91_MCI_SDCBUS);\r\n}\r\nelse {\r\npr_debug("MMC: Setting controller bus width to 1\n");\r\nat91_mci_write(host, AT91_MCI_SDCR, at91_mci_read(host, AT91_MCI_SDCR) & ~AT91_MCI_SDCBUS);\r\n}\r\nat91_mci_write(host, AT91_MCI_MR, (at91_mci_read(host, AT91_MCI_MR) & ~AT91_MCI_CLKDIV) | clkdiv);\r\nif (gpio_is_valid(host->board->vcc_pin)) {\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\ngpio_set_value(host->board->vcc_pin, 0);\r\nbreak;\r\ncase MMC_POWER_UP:\r\ngpio_set_value(host->board->vcc_pin, 1);\r\nbreak;\r\ncase MMC_POWER_ON:\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t at91_mci_irq(int irq, void *devid)\r\n{\r\nstruct at91mci_host *host = devid;\r\nint completed = 0;\r\nunsigned int int_status, int_mask;\r\nint_status = at91_mci_read(host, AT91_MCI_SR);\r\nint_mask = at91_mci_read(host, AT91_MCI_IMR);\r\npr_debug("MCI irq: status = %08X, %08X, %08X\n", int_status, int_mask,\r\nint_status & int_mask);\r\nint_status = int_status & int_mask;\r\nif (int_status & AT91_MCI_ERRORS) {\r\ncompleted = 1;\r\nif (int_status & AT91_MCI_UNRE)\r\npr_debug("MMC: Underrun error\n");\r\nif (int_status & AT91_MCI_OVRE)\r\npr_debug("MMC: Overrun error\n");\r\nif (int_status & AT91_MCI_DTOE)\r\npr_debug("MMC: Data timeout\n");\r\nif (int_status & AT91_MCI_DCRCE)\r\npr_debug("MMC: CRC error in data\n");\r\nif (int_status & AT91_MCI_RTOE)\r\npr_debug("MMC: Response timeout\n");\r\nif (int_status & AT91_MCI_RENDE)\r\npr_debug("MMC: Response end bit error\n");\r\nif (int_status & AT91_MCI_RCRCE)\r\npr_debug("MMC: Response CRC error\n");\r\nif (int_status & AT91_MCI_RDIRE)\r\npr_debug("MMC: Response direction error\n");\r\nif (int_status & AT91_MCI_RINDE)\r\npr_debug("MMC: Response index error\n");\r\n} else {\r\nif (int_status & AT91_MCI_TXBUFE) {\r\npr_debug("TX buffer empty\n");\r\nat91_mci_handle_transmitted(host);\r\n}\r\nif (int_status & AT91_MCI_ENDRX) {\r\npr_debug("ENDRX\n");\r\nat91_mci_post_dma_read(host);\r\n}\r\nif (int_status & AT91_MCI_RXBUFF) {\r\npr_debug("RX buffer full\n");\r\nat91_mci_write(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);\r\nat91_mci_write(host, AT91_MCI_IDR, AT91_MCI_RXBUFF | AT91_MCI_ENDRX);\r\ncompleted = 1;\r\n}\r\nif (int_status & AT91_MCI_ENDTX)\r\npr_debug("Transmit has ended\n");\r\nif (int_status & AT91_MCI_NOTBUSY) {\r\npr_debug("Card is ready\n");\r\nat91_mci_update_bytes_xfered(host);\r\ncompleted = 1;\r\n}\r\nif (int_status & AT91_MCI_DTIP)\r\npr_debug("Data transfer in progress\n");\r\nif (int_status & AT91_MCI_BLKE) {\r\npr_debug("Block transfer has ended\n");\r\nif (host->request->data && host->request->data->blocks > 1) {\r\ncompleted = 1;\r\n} else {\r\nat91_mci_write(host, AT91_MCI_IER, AT91_MCI_NOTBUSY);\r\n}\r\n}\r\nif (int_status & AT91_MCI_SDIOIRQA)\r\nmmc_signal_sdio_irq(host->mmc);\r\nif (int_status & AT91_MCI_SDIOIRQB)\r\nmmc_signal_sdio_irq(host->mmc);\r\nif (int_status & AT91_MCI_TXRDY)\r\npr_debug("Ready to transmit\n");\r\nif (int_status & AT91_MCI_RXRDY)\r\npr_debug("Ready to receive\n");\r\nif (int_status & AT91_MCI_CMDRDY) {\r\npr_debug("Command ready\n");\r\ncompleted = at91_mci_handle_cmdrdy(host);\r\n}\r\n}\r\nif (completed) {\r\npr_debug("Completed command\n");\r\nat91_mci_write(host, AT91_MCI_IDR, 0xffffffff & ~(AT91_MCI_SDIOIRQA | AT91_MCI_SDIOIRQB));\r\nat91_mci_completed_command(host, int_status);\r\n} else\r\nat91_mci_write(host, AT91_MCI_IDR, int_status & ~(AT91_MCI_SDIOIRQA | AT91_MCI_SDIOIRQB));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t at91_mmc_det_irq(int irq, void *_host)\r\n{\r\nstruct at91mci_host *host = _host;\r\nint present;\r\npresent = !gpio_get_value(host->board->det_pin);\r\nif (present != host->present) {\r\nhost->present = present;\r\npr_debug("%s: card %s\n", mmc_hostname(host->mmc),\r\npresent ? "insert" : "remove");\r\nif (!present) {\r\npr_debug("****** Resetting SD-card bus width ******\n");\r\nat91_mci_write(host, AT91_MCI_SDCR, at91_mci_read(host, AT91_MCI_SDCR) & ~AT91_MCI_SDCBUS);\r\n}\r\nmmc_detect_change(host->mmc, msecs_to_jiffies(500));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int at91_mci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct at91mci_host *host = mmc_priv(mmc);\r\nif (gpio_is_valid(host->board->wp_pin))\r\nreturn !!gpio_get_value(host->board->wp_pin);\r\nreturn -ENOSYS;\r\n}\r\nstatic void at91_mci_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct at91mci_host *host = mmc_priv(mmc);\r\npr_debug("%s: sdio_irq %c : %s\n", mmc_hostname(host->mmc),\r\nhost->board->slot_b ? 'B':'A', enable ? "enable" : "disable");\r\nat91_mci_write(host, enable ? AT91_MCI_IER : AT91_MCI_IDR,\r\nhost->board->slot_b ? AT91_MCI_SDIOIRQB : AT91_MCI_SDIOIRQA);\r\n}\r\nstatic int __init at91_mci_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct at91mci_host *host;\r\nstruct resource *res;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nif (!request_mem_region(res->start, resource_size(res), DRIVER_NAME))\r\nreturn -EBUSY;\r\nmmc = mmc_alloc_host(sizeof(struct at91mci_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ndev_dbg(&pdev->dev, "couldn't allocate mmc host\n");\r\ngoto fail6;\r\n}\r\nmmc->ops = &at91_mci_ops;\r\nmmc->f_min = 375000;\r\nmmc->f_max = 25000000;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->caps = 0;\r\nmmc->max_blk_size = MCI_MAXBLKSIZE;\r\nmmc->max_blk_count = MCI_BLKATONCE;\r\nmmc->max_req_size = MCI_BUFSIZE;\r\nmmc->max_segs = MCI_BLKATONCE;\r\nmmc->max_seg_size = MCI_BUFSIZE;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->bus_mode = 0;\r\nhost->board = pdev->dev.platform_data;\r\nif (host->board->wire4) {\r\nif (at91mci_is_mci1rev2xx())\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nelse\r\ndev_warn(&pdev->dev, "4 wire bus mode not supported"\r\n" - using 1 wire\n");\r\n}\r\nhost->buffer = dma_alloc_coherent(&pdev->dev, MCI_BUFSIZE,\r\n&host->physical_address, GFP_KERNEL);\r\nif (!host->buffer) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "Can't allocate transmit buffer\n");\r\ngoto fail5;\r\n}\r\nif (at91mci_is_mci1rev2xx()) {\r\nif (host->board->wire4 || !host->board->slot_b)\r\nmmc->caps |= MMC_CAP_SDIO_IRQ;\r\n}\r\nif (gpio_is_valid(host->board->det_pin)) {\r\nret = gpio_request(host->board->det_pin, "mmc_detect");\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "couldn't claim card detect pin\n");\r\ngoto fail4b;\r\n}\r\n}\r\nif (gpio_is_valid(host->board->wp_pin)) {\r\nret = gpio_request(host->board->wp_pin, "mmc_wp");\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "couldn't claim wp sense pin\n");\r\ngoto fail4;\r\n}\r\n}\r\nif (gpio_is_valid(host->board->vcc_pin)) {\r\nret = gpio_request(host->board->vcc_pin, "mmc_vcc");\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "couldn't claim vcc switch pin\n");\r\ngoto fail3;\r\n}\r\n}\r\nhost->mci_clk = clk_get(&pdev->dev, "mci_clk");\r\nif (IS_ERR(host->mci_clk)) {\r\nret = -ENODEV;\r\ndev_dbg(&pdev->dev, "no mci_clk?\n");\r\ngoto fail2;\r\n}\r\nhost->baseaddr = ioremap(res->start, resource_size(res));\r\nif (!host->baseaddr) {\r\nret = -ENOMEM;\r\ngoto fail1;\r\n}\r\nclk_enable(host->mci_clk);\r\nat91_mci_disable(host);\r\nat91_mci_enable(host);\r\nhost->irq = platform_get_irq(pdev, 0);\r\nret = request_irq(host->irq, at91_mci_irq, IRQF_SHARED,\r\nmmc_hostname(mmc), host);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "request MCI interrupt failed\n");\r\ngoto fail0;\r\n}\r\nsetup_timer(&host->timer, at91_timeout_timer, (unsigned long)host);\r\nplatform_set_drvdata(pdev, mmc);\r\nif (gpio_is_valid(host->board->det_pin)) {\r\nhost->present = !gpio_get_value(host->board->det_pin);\r\n}\r\nelse\r\nhost->present = -1;\r\nmmc_add_host(mmc);\r\nif (gpio_is_valid(host->board->det_pin)) {\r\nret = request_irq(gpio_to_irq(host->board->det_pin),\r\nat91_mmc_det_irq, 0, mmc_hostname(mmc), host);\r\nif (ret)\r\ndev_warn(&pdev->dev, "request MMC detect irq failed\n");\r\nelse\r\ndevice_init_wakeup(&pdev->dev, 1);\r\n}\r\npr_debug("Added MCI driver\n");\r\nreturn 0;\r\nfail0:\r\nclk_disable(host->mci_clk);\r\niounmap(host->baseaddr);\r\nfail1:\r\nclk_put(host->mci_clk);\r\nfail2:\r\nif (gpio_is_valid(host->board->vcc_pin))\r\ngpio_free(host->board->vcc_pin);\r\nfail3:\r\nif (gpio_is_valid(host->board->wp_pin))\r\ngpio_free(host->board->wp_pin);\r\nfail4:\r\nif (gpio_is_valid(host->board->det_pin))\r\ngpio_free(host->board->det_pin);\r\nfail4b:\r\nif (host->buffer)\r\ndma_free_coherent(&pdev->dev, MCI_BUFSIZE,\r\nhost->buffer, host->physical_address);\r\nfail5:\r\nmmc_free_host(mmc);\r\nfail6:\r\nrelease_mem_region(res->start, resource_size(res));\r\ndev_err(&pdev->dev, "probe failed, err %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int __exit at91_mci_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct at91mci_host *host;\r\nstruct resource *res;\r\nif (!mmc)\r\nreturn -1;\r\nhost = mmc_priv(mmc);\r\nif (host->buffer)\r\ndma_free_coherent(&pdev->dev, MCI_BUFSIZE,\r\nhost->buffer, host->physical_address);\r\nif (gpio_is_valid(host->board->det_pin)) {\r\nif (device_can_wakeup(&pdev->dev))\r\nfree_irq(gpio_to_irq(host->board->det_pin), host);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\ngpio_free(host->board->det_pin);\r\n}\r\nat91_mci_disable(host);\r\ndel_timer_sync(&host->timer);\r\nmmc_remove_host(mmc);\r\nfree_irq(host->irq, host);\r\nclk_disable(host->mci_clk);\r\nclk_put(host->mci_clk);\r\nif (gpio_is_valid(host->board->vcc_pin))\r\ngpio_free(host->board->vcc_pin);\r\nif (gpio_is_valid(host->board->wp_pin))\r\ngpio_free(host->board->wp_pin);\r\niounmap(host->baseaddr);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nmmc_free_host(mmc);\r\nplatform_set_drvdata(pdev, NULL);\r\npr_debug("MCI Removed\n");\r\nreturn 0;\r\n}\r\nstatic int at91_mci_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct at91mci_host *host = mmc_priv(mmc);\r\nint ret = 0;\r\nif (gpio_is_valid(host->board->det_pin) && device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(host->board->det_pin);\r\nif (mmc)\r\nret = mmc_suspend_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int at91_mci_resume(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct at91mci_host *host = mmc_priv(mmc);\r\nint ret = 0;\r\nif (gpio_is_valid(host->board->det_pin) && device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(host->board->det_pin);\r\nif (mmc)\r\nret = mmc_resume_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int __init at91_mci_init(void)\r\n{\r\nreturn platform_driver_probe(&at91_mci_driver, at91_mci_probe);\r\n}\r\nstatic void __exit at91_mci_exit(void)\r\n{\r\nplatform_driver_unregister(&at91_mci_driver);\r\n}
