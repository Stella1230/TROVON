static struct timeval itimer_get_remtime(struct hrtimer *timer)\r\n{\r\nktime_t rem = hrtimer_get_remaining(timer);\r\nif (hrtimer_active(timer)) {\r\nif (rem.tv64 <= 0)\r\nrem.tv64 = NSEC_PER_USEC;\r\n} else\r\nrem.tv64 = 0;\r\nreturn ktime_to_timeval(rem);\r\n}\r\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\r\nstruct itimerval *const value)\r\n{\r\ncputime_t cval, cinterval;\r\nstruct cpu_itimer *it = &tsk->signal->it[clock_id];\r\nspin_lock_irq(&tsk->sighand->siglock);\r\ncval = it->expires;\r\ncinterval = it->incr;\r\nif (cval) {\r\nstruct task_cputime cputime;\r\ncputime_t t;\r\nthread_group_cputimer(tsk, &cputime);\r\nif (clock_id == CPUCLOCK_PROF)\r\nt = cputime.utime + cputime.stime;\r\nelse\r\nt = cputime.utime;\r\nif (cval < t)\r\ncval = cputime_one_jiffy;\r\nelse\r\ncval = cval - t;\r\n}\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\ncputime_to_timeval(cval, &value->it_value);\r\ncputime_to_timeval(cinterval, &value->it_interval);\r\n}\r\nint do_getitimer(int which, struct itimerval *value)\r\n{\r\nstruct task_struct *tsk = current;\r\nswitch (which) {\r\ncase ITIMER_REAL:\r\nspin_lock_irq(&tsk->sighand->siglock);\r\nvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);\r\nvalue->it_interval =\r\nktime_to_timeval(tsk->signal->it_real_incr);\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\nbreak;\r\ncase ITIMER_VIRTUAL:\r\nget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);\r\nbreak;\r\ncase ITIMER_PROF:\r\nget_cpu_itimer(tsk, CPUCLOCK_PROF, value);\r\nbreak;\r\ndefault:\r\nreturn(-EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nenum hrtimer_restart it_real_fn(struct hrtimer *timer)\r\n{\r\nstruct signal_struct *sig =\r\ncontainer_of(timer, struct signal_struct, real_timer);\r\ntrace_itimer_expire(ITIMER_REAL, sig->leader_pid, 0);\r\nkill_pid_info(SIGALRM, SEND_SIG_PRIV, sig->leader_pid);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic inline u32 cputime_sub_ns(cputime_t ct, s64 real_ns)\r\n{\r\nstruct timespec ts;\r\ns64 cpu_ns;\r\ncputime_to_timespec(ct, &ts);\r\ncpu_ns = timespec_to_ns(&ts);\r\nreturn (cpu_ns <= real_ns) ? 0 : cpu_ns - real_ns;\r\n}\r\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\r\nconst struct itimerval *const value,\r\nstruct itimerval *const ovalue)\r\n{\r\ncputime_t cval, nval, cinterval, ninterval;\r\ns64 ns_ninterval, ns_nval;\r\nu32 error, incr_error;\r\nstruct cpu_itimer *it = &tsk->signal->it[clock_id];\r\nnval = timeval_to_cputime(&value->it_value);\r\nns_nval = timeval_to_ns(&value->it_value);\r\nninterval = timeval_to_cputime(&value->it_interval);\r\nns_ninterval = timeval_to_ns(&value->it_interval);\r\nerror = cputime_sub_ns(nval, ns_nval);\r\nincr_error = cputime_sub_ns(ninterval, ns_ninterval);\r\nspin_lock_irq(&tsk->sighand->siglock);\r\ncval = it->expires;\r\ncinterval = it->incr;\r\nif (cval || nval) {\r\nif (nval > 0)\r\nnval += cputime_one_jiffy;\r\nset_process_cpu_timer(tsk, clock_id, &nval, &cval);\r\n}\r\nit->expires = nval;\r\nit->incr = ninterval;\r\nit->error = error;\r\nit->incr_error = incr_error;\r\ntrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\r\nITIMER_VIRTUAL : ITIMER_PROF, value, nval);\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\nif (ovalue) {\r\ncputime_to_timeval(cval, &ovalue->it_value);\r\ncputime_to_timeval(cinterval, &ovalue->it_interval);\r\n}\r\n}\r\nint do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct hrtimer *timer;\r\nktime_t expires;\r\nif (!timeval_valid(&value->it_value) ||\r\n!timeval_valid(&value->it_interval))\r\nreturn -EINVAL;\r\nswitch (which) {\r\ncase ITIMER_REAL:\r\nagain:\r\nspin_lock_irq(&tsk->sighand->siglock);\r\ntimer = &tsk->signal->real_timer;\r\nif (ovalue) {\r\novalue->it_value = itimer_get_remtime(timer);\r\novalue->it_interval\r\n= ktime_to_timeval(tsk->signal->it_real_incr);\r\n}\r\nif (hrtimer_try_to_cancel(timer) < 0) {\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\ngoto again;\r\n}\r\nexpires = timeval_to_ktime(value->it_value);\r\nif (expires.tv64 != 0) {\r\ntsk->signal->it_real_incr =\r\ntimeval_to_ktime(value->it_interval);\r\nhrtimer_start(timer, expires, HRTIMER_MODE_REL);\r\n} else\r\ntsk->signal->it_real_incr.tv64 = 0;\r\ntrace_itimer_state(ITIMER_REAL, value, 0);\r\nspin_unlock_irq(&tsk->sighand->siglock);\r\nbreak;\r\ncase ITIMER_VIRTUAL:\r\nset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\r\nbreak;\r\ncase ITIMER_PROF:\r\nset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int alarm_setitimer(unsigned int seconds)\r\n{\r\nstruct itimerval it_new, it_old;\r\n#if BITS_PER_LONG < 64\r\nif (seconds > INT_MAX)\r\nseconds = INT_MAX;\r\n#endif\r\nit_new.it_value.tv_sec = seconds;\r\nit_new.it_value.tv_usec = 0;\r\nit_new.it_interval.tv_sec = it_new.it_interval.tv_usec = 0;\r\ndo_setitimer(ITIMER_REAL, &it_new, &it_old);\r\nif ((!it_old.it_value.tv_sec && it_old.it_value.tv_usec) ||\r\nit_old.it_value.tv_usec >= 500000)\r\nit_old.it_value.tv_sec++;\r\nreturn it_old.it_value.tv_sec;\r\n}
