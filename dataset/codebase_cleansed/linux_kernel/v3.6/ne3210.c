static int __init ne3210_eisa_probe (struct device *device)\r\n{\r\nunsigned long ioaddr, phys_mem;\r\nint i, retval, port_index;\r\nstruct eisa_device *edev = to_eisa_device (device);\r\nstruct net_device *dev;\r\nif (!(dev = alloc_ei_netdev ())) {\r\nprintk ("ne3210.c: unable to allocate memory for dev!\n");\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(dev, device);\r\ndev_set_drvdata(device, dev);\r\nioaddr = edev->base_addr;\r\nif (!request_region(ioaddr, NE3210_IO_EXTENT, DRV_NAME)) {\r\nretval = -EBUSY;\r\ngoto out;\r\n}\r\nif (!request_region(ioaddr + NE3210_CFG1,\r\nNE3210_CFG_EXTENT, DRV_NAME)) {\r\nretval = -EBUSY;\r\ngoto out1;\r\n}\r\n#if NE3210_DEBUG & NE3210_D_PROBE\r\nprintk("ne3210-debug: probe at %#x, ID %s\n", ioaddr, edev->id.sig);\r\nprintk("ne3210-debug: config regs: %#x %#x\n",\r\ninb(ioaddr + NE3210_CFG1), inb(ioaddr + NE3210_CFG2));\r\n#endif\r\nport_index = inb(ioaddr + NE3210_CFG2) >> 6;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = inb(ioaddr + NE3210_SA_PROM + i);\r\nprintk("ne3210.c: NE3210 in EISA slot %d, media: %s, addr: %pM.\n",\r\nedev->slot, ifmap[port_index], dev->dev_addr);\r\ndev->irq = irq_map[(inb(ioaddr + NE3210_CFG2) >> 3) & 0x07];\r\nprintk("ne3210.c: using IRQ %d, ", dev->irq);\r\nretval = request_irq(dev->irq, ei_interrupt, 0, DRV_NAME, dev);\r\nif (retval) {\r\nprintk (" unable to get IRQ %d.\n", dev->irq);\r\ngoto out2;\r\n}\r\nphys_mem = shmem_map[inb(ioaddr + NE3210_CFG2) & 0x07] * 0x1000;\r\nif (phys_mem > 1024*1024) {\r\nif (phys_mem < virt_to_phys(high_memory)) {\r\nprintk(KERN_CRIT "ne3210.c: Card RAM overlaps with normal memory!!!\n");\r\nprintk(KERN_CRIT "ne3210.c: Use EISA SCU to set card memory below 1MB,\n");\r\nprintk(KERN_CRIT "ne3210.c: or to an address above 0x%llx.\n",\r\n(u64)virt_to_phys(high_memory));\r\nprintk(KERN_CRIT "ne3210.c: Driver NOT installed.\n");\r\nretval = -EINVAL;\r\ngoto out3;\r\n}\r\n}\r\nif (!request_mem_region (phys_mem, NE3210_STOP_PG*0x100, DRV_NAME)) {\r\nprintk ("ne3210.c: Unable to request shared memory at physical address %#lx\n",\r\nphys_mem);\r\ngoto out3;\r\n}\r\nprintk("%dkB memory at physical address %#lx\n",\r\nNE3210_STOP_PG/4, phys_mem);\r\nei_status.mem = ioremap(phys_mem, NE3210_STOP_PG*0x100);\r\nif (!ei_status.mem) {\r\nprintk(KERN_ERR "ne3210.c: Unable to remap card memory !!\n");\r\nprintk(KERN_ERR "ne3210.c: Driver NOT installed.\n");\r\nretval = -EAGAIN;\r\ngoto out4;\r\n}\r\nprintk("ne3210.c: remapped %dkB card memory to virtual address %p\n",\r\nNE3210_STOP_PG/4, ei_status.mem);\r\ndev->mem_start = (unsigned long)ei_status.mem;\r\ndev->mem_end = dev->mem_start + (NE3210_STOP_PG - NE3210_START_PG)*256;\r\ndev->base_addr = ioaddr;\r\nei_status.name = "NE3210";\r\nei_status.tx_start_page = NE3210_START_PG;\r\nei_status.rx_start_page = NE3210_START_PG + TX_PAGES;\r\nei_status.stop_page = NE3210_STOP_PG;\r\nei_status.word16 = 1;\r\nei_status.priv = phys_mem;\r\nif (ei_debug > 0)\r\nprintk("ne3210 loaded.\n");\r\nei_status.reset_8390 = &ne3210_reset_8390;\r\nei_status.block_input = &ne3210_block_input;\r\nei_status.block_output = &ne3210_block_output;\r\nei_status.get_8390_hdr = &ne3210_get_8390_hdr;\r\ndev->netdev_ops = &ei_netdev_ops;\r\ndev->if_port = ifmap_val[port_index];\r\nif ((retval = register_netdev (dev)))\r\ngoto out5;\r\nNS8390_init(dev, 0);\r\nreturn 0;\r\nout5:\r\niounmap(ei_status.mem);\r\nout4:\r\nrelease_mem_region (phys_mem, NE3210_STOP_PG*0x100);\r\nout3:\r\nfree_irq (dev->irq, dev);\r\nout2:\r\nrelease_region (ioaddr + NE3210_CFG1, NE3210_CFG_EXTENT);\r\nout1:\r\nrelease_region (ioaddr, NE3210_IO_EXTENT);\r\nout:\r\nfree_netdev (dev);\r\nreturn retval;\r\n}\r\nstatic int __devexit ne3210_eisa_remove (struct device *device)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(device);\r\nunsigned long ioaddr = to_eisa_device (device)->base_addr;\r\nunregister_netdev (dev);\r\niounmap(ei_status.mem);\r\nrelease_mem_region (ei_status.priv, NE3210_STOP_PG*0x100);\r\nfree_irq (dev->irq, dev);\r\nrelease_region (ioaddr + NE3210_CFG1, NE3210_CFG_EXTENT);\r\nrelease_region (ioaddr, NE3210_IO_EXTENT);\r\nfree_netdev (dev);\r\nreturn 0;\r\n}\r\nstatic void ne3210_reset_8390(struct net_device *dev)\r\n{\r\nunsigned short ioaddr = dev->base_addr;\r\noutb(0x04, ioaddr + NE3210_RESET_PORT);\r\nif (ei_debug > 1) printk("%s: resetting the NE3210...", dev->name);\r\nmdelay(2);\r\nei_status.txing = 0;\r\noutb(0x01, ioaddr + NE3210_RESET_PORT);\r\nif (ei_debug > 1) printk("reset done\n");\r\n}\r\nstatic void\r\nne3210_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nvoid __iomem *hdr_start = ei_status.mem + ((ring_page - NE3210_START_PG)<<8);\r\nmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\r\nhdr->count = (hdr->count + 3) & ~3;\r\n}\r\nstatic void ne3210_block_input(struct net_device *dev, int count, struct sk_buff *skb,\r\nint ring_offset)\r\n{\r\nvoid __iomem *start = ei_status.mem + ring_offset - NE3210_START_PG*256;\r\nif (ring_offset + count > NE3210_STOP_PG*256) {\r\nint semi_count = NE3210_STOP_PG*256 - ring_offset;\r\nmemcpy_fromio(skb->data, start, semi_count);\r\ncount -= semi_count;\r\nmemcpy_fromio(skb->data + semi_count,\r\nei_status.mem + TX_PAGES*256, count);\r\n} else {\r\nmemcpy_fromio(skb->data, start, count);\r\n}\r\n}\r\nstatic void ne3210_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nvoid __iomem *shmem = ei_status.mem + ((start_page - NE3210_START_PG)<<8);\r\ncount = (count + 3) & ~3;\r\nmemcpy_toio(shmem, buf, count);\r\n}\r\nstatic int ne3210_init(void)\r\n{\r\nreturn eisa_driver_register (&ne3210_eisa_driver);\r\n}\r\nstatic void ne3210_cleanup(void)\r\n{\r\neisa_driver_unregister (&ne3210_eisa_driver);\r\n}
