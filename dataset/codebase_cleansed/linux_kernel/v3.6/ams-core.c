void ams_sensors(s8 *x, s8 *y, s8 *z)\r\n{\r\nu32 orient = ams_info.vflag? ams_info.orient1 : ams_info.orient2;\r\nif (orient & 0x80)\r\nams_info.get_xyz(y, x, z);\r\nelse\r\nams_info.get_xyz(x, y, z);\r\nif (orient & 0x04)\r\n*z = ~(*z);\r\nif (orient & 0x02)\r\n*y = ~(*y);\r\nif (orient & 0x01)\r\n*x = ~(*x);\r\n}\r\nstatic ssize_t ams_show_current(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\ns8 x, y, z;\r\nmutex_lock(&ams_info.lock);\r\nams_sensors(&x, &y, &z);\r\nmutex_unlock(&ams_info.lock);\r\nreturn snprintf(buf, PAGE_SIZE, "%d %d %d\n", x, y, z);\r\n}\r\nstatic void ams_handle_irq(void *data)\r\n{\r\nenum ams_irq irq = *((enum ams_irq *)data);\r\nspin_lock(&ams_info.irq_lock);\r\nams_info.worker_irqs |= irq;\r\nschedule_work(&ams_info.worker);\r\nspin_unlock(&ams_info.irq_lock);\r\n}\r\nstatic void ams_worker(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nu8 irqs_to_clear;\r\nmutex_lock(&ams_info.lock);\r\nspin_lock_irqsave(&ams_info.irq_lock, flags);\r\nirqs_to_clear = ams_info.worker_irqs;\r\nif (ams_info.worker_irqs & AMS_IRQ_FREEFALL) {\r\nif (verbose)\r\nprintk(KERN_INFO "ams: freefall detected!\n");\r\nams_info.worker_irqs &= ~AMS_IRQ_FREEFALL;\r\n}\r\nif (ams_info.worker_irqs & AMS_IRQ_SHOCK) {\r\nif (verbose)\r\nprintk(KERN_INFO "ams: shock detected!\n");\r\nams_info.worker_irqs &= ~AMS_IRQ_SHOCK;\r\n}\r\nspin_unlock_irqrestore(&ams_info.irq_lock, flags);\r\nams_info.clear_irq(irqs_to_clear);\r\nmutex_unlock(&ams_info.lock);\r\n}\r\nint ams_sensor_attach(void)\r\n{\r\nint result;\r\nconst u32 *prop;\r\nprop = of_get_property(ams_info.of_node, "orientation", NULL);\r\nif (!prop)\r\nreturn -ENODEV;\r\nams_info.orient1 = *prop;\r\nams_info.orient2 = *(prop + 1);\r\nresult = pmf_register_irq_client(ams_info.of_node,\r\n"accel-int-1",\r\n&ams_freefall_client);\r\nif (result < 0)\r\nreturn -ENODEV;\r\nams_info.worker_irqs = 0;\r\nresult = pmf_register_irq_client(ams_info.of_node,\r\n"accel-int-2",\r\n&ams_shock_client);\r\nif (result < 0)\r\ngoto release_freefall;\r\nams_info.of_dev = of_platform_device_create(ams_info.of_node, "ams", NULL);\r\nif (!ams_info.of_dev) {\r\nresult = -ENODEV;\r\ngoto release_shock;\r\n}\r\nresult = device_create_file(&ams_info.of_dev->dev, &dev_attr_current);\r\nif (result)\r\ngoto release_of;\r\nams_info.vflag = !!(ams_info.get_vendor() & 0x10);\r\nresult = ams_input_init();\r\nif (result)\r\ngoto release_device_file;\r\nreturn result;\r\nrelease_device_file:\r\ndevice_remove_file(&ams_info.of_dev->dev, &dev_attr_current);\r\nrelease_of:\r\nof_device_unregister(ams_info.of_dev);\r\nrelease_shock:\r\npmf_unregister_irq_client(&ams_shock_client);\r\nrelease_freefall:\r\npmf_unregister_irq_client(&ams_freefall_client);\r\nreturn result;\r\n}\r\nint __init ams_init(void)\r\n{\r\nstruct device_node *np;\r\nspin_lock_init(&ams_info.irq_lock);\r\nmutex_init(&ams_info.lock);\r\nINIT_WORK(&ams_info.worker, ams_worker);\r\n#ifdef CONFIG_SENSORS_AMS_I2C\r\nnp = of_find_node_by_name(NULL, "accelerometer");\r\nif (np && of_device_is_compatible(np, "AAPL,accelerometer_1"))\r\nreturn ams_i2c_init(np);\r\n#endif\r\n#ifdef CONFIG_SENSORS_AMS_PMU\r\nnp = of_find_node_by_name(NULL, "sms");\r\nif (np && of_device_is_compatible(np, "sms"))\r\nreturn ams_pmu_init(np);\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nvoid ams_sensor_detach(void)\r\n{\r\nams_input_exit();\r\ndevice_remove_file(&ams_info.of_dev->dev, &dev_attr_current);\r\nflush_work_sync(&ams_info.worker);\r\nof_device_unregister(ams_info.of_dev);\r\npmf_unregister_irq_client(&ams_shock_client);\r\npmf_unregister_irq_client(&ams_freefall_client);\r\n}\r\nstatic void __exit ams_exit(void)\r\n{\r\nams_info.exit();\r\n}
