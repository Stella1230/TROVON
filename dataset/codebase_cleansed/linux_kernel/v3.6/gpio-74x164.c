static struct gen_74x164_chip *gpio_to_74x164_chip(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct gen_74x164_chip, gpio_chip);\r\n}\r\nstatic int __gen_74x164_write_config(struct gen_74x164_chip *chip)\r\n{\r\nreturn spi_write(chip->spi,\r\n&chip->port_config, sizeof(chip->port_config));\r\n}\r\nstatic int gen_74x164_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct gen_74x164_chip *chip = gpio_to_74x164_chip(gc);\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = (chip->port_config >> offset) & 0x1;\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic void gen_74x164_set_value(struct gpio_chip *gc,\r\nunsigned offset, int val)\r\n{\r\nstruct gen_74x164_chip *chip = gpio_to_74x164_chip(gc);\r\nmutex_lock(&chip->lock);\r\nif (val)\r\nchip->port_config |= (1 << offset);\r\nelse\r\nchip->port_config &= ~(1 << offset);\r\n__gen_74x164_write_config(chip);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic int gen_74x164_direction_output(struct gpio_chip *gc,\r\nunsigned offset, int val)\r\n{\r\ngen_74x164_set_value(gc, offset, val);\r\nreturn 0;\r\n}\r\nstatic int __devinit gen_74x164_probe(struct spi_device *spi)\r\n{\r\nstruct gen_74x164_chip *chip;\r\nstruct gen_74x164_chip_platform_data *pdata;\r\nint ret;\r\npdata = spi->dev.platform_data;\r\nif (!pdata || !pdata->base) {\r\ndev_dbg(&spi->dev, "incorrect or missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nspi->bits_per_word = 8;\r\nret = spi_setup(spi);\r\nif (ret < 0)\r\nreturn ret;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nmutex_init(&chip->lock);\r\ndev_set_drvdata(&spi->dev, chip);\r\nchip->spi = spi;\r\nchip->gpio_chip.label = spi->modalias;\r\nchip->gpio_chip.direction_output = gen_74x164_direction_output;\r\nchip->gpio_chip.get = gen_74x164_get_value;\r\nchip->gpio_chip.set = gen_74x164_set_value;\r\nchip->gpio_chip.base = pdata->base;\r\nchip->gpio_chip.ngpio = 8;\r\nchip->gpio_chip.can_sleep = 1;\r\nchip->gpio_chip.dev = &spi->dev;\r\nchip->gpio_chip.owner = THIS_MODULE;\r\nret = __gen_74x164_write_config(chip);\r\nif (ret) {\r\ndev_err(&spi->dev, "Failed writing: %d\n", ret);\r\ngoto exit_destroy;\r\n}\r\nret = gpiochip_add(&chip->gpio_chip);\r\nif (ret)\r\ngoto exit_destroy;\r\nreturn ret;\r\nexit_destroy:\r\ndev_set_drvdata(&spi->dev, NULL);\r\nmutex_destroy(&chip->lock);\r\nkfree(chip);\r\nreturn ret;\r\n}\r\nstatic int __devexit gen_74x164_remove(struct spi_device *spi)\r\n{\r\nstruct gen_74x164_chip *chip;\r\nint ret;\r\nchip = dev_get_drvdata(&spi->dev);\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\ndev_set_drvdata(&spi->dev, NULL);\r\nret = gpiochip_remove(&chip->gpio_chip);\r\nif (!ret) {\r\nmutex_destroy(&chip->lock);\r\nkfree(chip);\r\n} else\r\ndev_err(&spi->dev, "Failed to remove the GPIO controller: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic int __init gen_74x164_init(void)\r\n{\r\nreturn spi_register_driver(&gen_74x164_driver);\r\n}\r\nstatic void __exit gen_74x164_exit(void)\r\n{\r\nspi_unregister_driver(&gen_74x164_driver);\r\n}
