static int lowlevel_buffer_allocate(struct drm_device *dev,\r\nunsigned int flags, struct exynos_drm_gem_buf *buf)\r\n{\r\ndma_addr_t start_addr;\r\nunsigned int npages, i = 0;\r\nstruct scatterlist *sgl;\r\nint ret = 0;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (IS_NONCONTIG_BUFFER(flags)) {\r\nDRM_DEBUG_KMS("not support allocation type.\n");\r\nreturn -EINVAL;\r\n}\r\nif (buf->dma_addr) {\r\nDRM_DEBUG_KMS("already allocated.\n");\r\nreturn 0;\r\n}\r\nif (buf->size >= SZ_1M) {\r\nnpages = buf->size >> SECTION_SHIFT;\r\nbuf->page_size = SECTION_SIZE;\r\n} else if (buf->size >= SZ_64K) {\r\nnpages = buf->size >> 16;\r\nbuf->page_size = SZ_64K;\r\n} else {\r\nnpages = buf->size >> PAGE_SHIFT;\r\nbuf->page_size = PAGE_SIZE;\r\n}\r\nbuf->sgt = kzalloc(sizeof(struct sg_table), GFP_KERNEL);\r\nif (!buf->sgt) {\r\nDRM_ERROR("failed to allocate sg table.\n");\r\nreturn -ENOMEM;\r\n}\r\nret = sg_alloc_table(buf->sgt, npages, GFP_KERNEL);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to initialize sg table.\n");\r\nkfree(buf->sgt);\r\nbuf->sgt = NULL;\r\nreturn -ENOMEM;\r\n}\r\nbuf->kvaddr = dma_alloc_writecombine(dev->dev, buf->size,\r\n&buf->dma_addr, GFP_KERNEL);\r\nif (!buf->kvaddr) {\r\nDRM_ERROR("failed to allocate buffer.\n");\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nbuf->pages = kzalloc(sizeof(struct page) * npages, GFP_KERNEL);\r\nif (!buf->pages) {\r\nDRM_ERROR("failed to allocate pages.\n");\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nsgl = buf->sgt->sgl;\r\nstart_addr = buf->dma_addr;\r\nwhile (i < npages) {\r\nbuf->pages[i] = phys_to_page(start_addr);\r\nsg_set_page(sgl, buf->pages[i], buf->page_size, 0);\r\nsg_dma_address(sgl) = start_addr;\r\nstart_addr += buf->page_size;\r\nsgl = sg_next(sgl);\r\ni++;\r\n}\r\nDRM_DEBUG_KMS("vaddr(0x%lx), dma_addr(0x%lx), size(0x%lx)\n",\r\n(unsigned long)buf->kvaddr,\r\n(unsigned long)buf->dma_addr,\r\nbuf->size);\r\nreturn ret;\r\nerr2:\r\ndma_free_writecombine(dev->dev, buf->size, buf->kvaddr,\r\n(dma_addr_t)buf->dma_addr);\r\nbuf->dma_addr = (dma_addr_t)NULL;\r\nerr1:\r\nsg_free_table(buf->sgt);\r\nkfree(buf->sgt);\r\nbuf->sgt = NULL;\r\nreturn ret;\r\n}\r\nstatic void lowlevel_buffer_deallocate(struct drm_device *dev,\r\nunsigned int flags, struct exynos_drm_gem_buf *buf)\r\n{\r\nDRM_DEBUG_KMS("%s.\n", __FILE__);\r\nif (IS_NONCONTIG_BUFFER(flags)) {\r\nDRM_DEBUG_KMS("not support allocation type.\n");\r\nreturn;\r\n}\r\nif (!buf->dma_addr) {\r\nDRM_DEBUG_KMS("dma_addr is invalid.\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("vaddr(0x%lx), dma_addr(0x%lx), size(0x%lx)\n",\r\n(unsigned long)buf->kvaddr,\r\n(unsigned long)buf->dma_addr,\r\nbuf->size);\r\nsg_free_table(buf->sgt);\r\nkfree(buf->sgt);\r\nbuf->sgt = NULL;\r\nkfree(buf->pages);\r\nbuf->pages = NULL;\r\ndma_free_writecombine(dev->dev, buf->size, buf->kvaddr,\r\n(dma_addr_t)buf->dma_addr);\r\nbuf->dma_addr = (dma_addr_t)NULL;\r\n}\r\nstruct exynos_drm_gem_buf *exynos_drm_init_buf(struct drm_device *dev,\r\nunsigned int size)\r\n{\r\nstruct exynos_drm_gem_buf *buffer;\r\nDRM_DEBUG_KMS("%s.\n", __FILE__);\r\nDRM_DEBUG_KMS("desired size = 0x%x\n", size);\r\nbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\r\nif (!buffer) {\r\nDRM_ERROR("failed to allocate exynos_drm_gem_buf.\n");\r\nreturn NULL;\r\n}\r\nbuffer->size = size;\r\nreturn buffer;\r\n}\r\nvoid exynos_drm_fini_buf(struct drm_device *dev,\r\nstruct exynos_drm_gem_buf *buffer)\r\n{\r\nDRM_DEBUG_KMS("%s.\n", __FILE__);\r\nif (!buffer) {\r\nDRM_DEBUG_KMS("buffer is null.\n");\r\nreturn;\r\n}\r\nkfree(buffer);\r\nbuffer = NULL;\r\n}\r\nint exynos_drm_alloc_buf(struct drm_device *dev,\r\nstruct exynos_drm_gem_buf *buf, unsigned int flags)\r\n{\r\nif (lowlevel_buffer_allocate(dev, flags, buf) < 0)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid exynos_drm_free_buf(struct drm_device *dev,\r\nunsigned int flags, struct exynos_drm_gem_buf *buffer)\r\n{\r\nlowlevel_buffer_deallocate(dev, flags, buffer);\r\n}
