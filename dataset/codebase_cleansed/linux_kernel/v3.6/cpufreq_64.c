static void g5_smu_switch_volt(int speed_mode)\r\n{\r\nstruct smu_simple_cmd cmd;\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nsmu_queue_simple(&cmd, SMU_CMD_POWER_COMMAND, 8, smu_done_complete,\r\n&comp, 'V', 'S', 'L', 'E', 'W',\r\n0xff, g5_fvt_cur+1, speed_mode);\r\nwait_for_completion(&comp);\r\n}\r\nstatic void g5_vdnap_switch_volt(int speed_mode)\r\n{\r\nstruct pmf_args args;\r\nu32 slew, done = 0;\r\nunsigned long timeout;\r\nslew = (speed_mode == CPUFREQ_LOW) ? 1 : 0;\r\nargs.count = 1;\r\nargs.u[0].p = &slew;\r\npmf_call_one(pfunc_set_vdnap0, &args);\r\ntimeout = jiffies + HZ/10;\r\nwhile(!time_after(jiffies, timeout)) {\r\nargs.count = 1;\r\nargs.u[0].p = &done;\r\npmf_call_one(pfunc_vdnap0_complete, &args);\r\nif (done)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (done == 0)\r\nprintk(KERN_WARNING "cpufreq: Timeout in clock slewing !\n");\r\n}\r\nstatic int g5_scom_switch_freq(int speed_mode)\r\n{\r\nunsigned long flags;\r\nint to;\r\nif (speed_mode < g5_pmode_cur)\r\ng5_switch_volt(speed_mode);\r\nlocal_irq_save(flags);\r\nscom970_write(SCOM_PCR, 0);\r\nscom970_write(SCOM_PCR, PCR_HILO_SELECT | 0);\r\nscom970_write(SCOM_PCR, PCR_HILO_SELECT |\r\ng5_pmode_data[speed_mode]);\r\nfor (to = 0; to < 10; to++) {\r\nunsigned long psr = scom970_read(SCOM_PSR);\r\nif ((psr & PSR_CMD_RECEIVED) == 0 &&\r\n(((psr >> PSR_CUR_SPEED_SHIFT) ^\r\n(g5_pmode_data[speed_mode] >> PCR_SPEED_SHIFT)) & 0x3)\r\n== 0)\r\nbreak;\r\nif (psr & PSR_CMD_COMPLETED)\r\nbreak;\r\nudelay(100);\r\n}\r\nlocal_irq_restore(flags);\r\nif (speed_mode > g5_pmode_cur)\r\ng5_switch_volt(speed_mode);\r\ng5_pmode_cur = speed_mode;\r\nppc_proc_freq = g5_cpu_freqs[speed_mode].frequency * 1000ul;\r\nreturn 0;\r\n}\r\nstatic int g5_scom_query_freq(void)\r\n{\r\nunsigned long psr = scom970_read(SCOM_PSR);\r\nint i;\r\nfor (i = 0; i <= g5_pmode_max; i++)\r\nif ((((psr >> PSR_CUR_SPEED_SHIFT) ^\r\n(g5_pmode_data[i] >> PCR_SPEED_SHIFT)) & 0x3) == 0)\r\nbreak;\r\nreturn i;\r\n}\r\nstatic void g5_dummy_switch_volt(int speed_mode)\r\n{\r\n}\r\nstatic void g5_pfunc_switch_volt(int speed_mode)\r\n{\r\nif (speed_mode == CPUFREQ_HIGH) {\r\nif (pfunc_cpu0_volt_high)\r\npmf_call_one(pfunc_cpu0_volt_high, NULL);\r\nif (pfunc_cpu1_volt_high)\r\npmf_call_one(pfunc_cpu1_volt_high, NULL);\r\n} else {\r\nif (pfunc_cpu0_volt_low)\r\npmf_call_one(pfunc_cpu0_volt_low, NULL);\r\nif (pfunc_cpu1_volt_low)\r\npmf_call_one(pfunc_cpu1_volt_low, NULL);\r\n}\r\nmsleep(10);\r\n}\r\nstatic int g5_pfunc_switch_freq(int speed_mode)\r\n{\r\nstruct pmf_args args;\r\nu32 done = 0;\r\nunsigned long timeout;\r\nint rc;\r\nDBG("g5_pfunc_switch_freq(%d)\n", speed_mode);\r\nif (speed_mode < g5_pmode_cur)\r\ng5_switch_volt(speed_mode);\r\nif (speed_mode == CPUFREQ_HIGH)\r\nrc = pmf_call_one(pfunc_cpu_setfreq_high, NULL);\r\nelse\r\nrc = pmf_call_one(pfunc_cpu_setfreq_low, NULL);\r\nif (rc)\r\nprintk(KERN_WARNING "cpufreq: pfunc switch error %d\n", rc);\r\ntimeout = jiffies + HZ/10;\r\nwhile(!time_after(jiffies, timeout)) {\r\nargs.count = 1;\r\nargs.u[0].p = &done;\r\npmf_call_one(pfunc_slewing_done, &args);\r\nif (done)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (done == 0)\r\nprintk(KERN_WARNING "cpufreq: Timeout in clock slewing !\n");\r\nif (speed_mode > g5_pmode_cur)\r\ng5_switch_volt(speed_mode);\r\ng5_pmode_cur = speed_mode;\r\nppc_proc_freq = g5_cpu_freqs[speed_mode].frequency * 1000ul;\r\nreturn 0;\r\n}\r\nstatic int g5_pfunc_query_freq(void)\r\n{\r\nstruct pmf_args args;\r\nu32 val = 0;\r\nargs.count = 1;\r\nargs.u[0].p = &val;\r\npmf_call_one(pfunc_cpu_getfreq, &args);\r\nreturn val ? CPUFREQ_HIGH : CPUFREQ_LOW;\r\n}\r\nstatic int g5_cpufreq_verify(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy, g5_cpu_freqs);\r\n}\r\nstatic int g5_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq, unsigned int relation)\r\n{\r\nunsigned int newstate = 0;\r\nstruct cpufreq_freqs freqs;\r\nint rc;\r\nif (cpufreq_frequency_table_target(policy, g5_cpu_freqs,\r\ntarget_freq, relation, &newstate))\r\nreturn -EINVAL;\r\nif (g5_pmode_cur == newstate)\r\nreturn 0;\r\nmutex_lock(&g5_switch_mutex);\r\nfreqs.old = g5_cpu_freqs[g5_pmode_cur].frequency;\r\nfreqs.new = g5_cpu_freqs[newstate].frequency;\r\nfreqs.cpu = 0;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\nrc = g5_switch_freq(newstate);\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\nmutex_unlock(&g5_switch_mutex);\r\nreturn rc;\r\n}\r\nstatic unsigned int g5_cpufreq_get_speed(unsigned int cpu)\r\n{\r\nreturn g5_cpu_freqs[g5_pmode_cur].frequency;\r\n}\r\nstatic int g5_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\npolicy->cpuinfo.transition_latency = transition_latency;\r\npolicy->cur = g5_cpu_freqs[g5_query_freq()].frequency;\r\ncpumask_copy(policy->cpus, cpu_online_mask);\r\ncpufreq_frequency_table_get_attr(g5_cpu_freqs, policy->cpu);\r\nreturn cpufreq_frequency_table_cpuinfo(policy,\r\ng5_cpu_freqs);\r\n}\r\nstatic int __init g5_neo2_cpufreq_init(struct device_node *cpus)\r\n{\r\nstruct device_node *cpunode;\r\nunsigned int psize, ssize;\r\nunsigned long max_freq;\r\nchar *freq_method, *volt_method;\r\nconst u32 *valp;\r\nu32 pvr_hi;\r\nint use_volts_vdnap = 0;\r\nint use_volts_smu = 0;\r\nint rc = -ENODEV;\r\nif (of_machine_is_compatible("PowerMac8,1") ||\r\nof_machine_is_compatible("PowerMac8,2") ||\r\nof_machine_is_compatible("PowerMac9,1"))\r\nuse_volts_smu = 1;\r\nelse if (of_machine_is_compatible("PowerMac11,2"))\r\nuse_volts_vdnap = 1;\r\nelse\r\nreturn -ENODEV;\r\nfor (cpunode = NULL;\r\n(cpunode = of_get_next_child(cpus, cpunode)) != NULL;) {\r\nconst u32 *reg = of_get_property(cpunode, "reg", NULL);\r\nif (reg == NULL || (*reg) != 0)\r\ncontinue;\r\nif (!strcmp(cpunode->type, "cpu"))\r\nbreak;\r\n}\r\nif (cpunode == NULL) {\r\nprintk(KERN_ERR "cpufreq: Can't find any CPU 0 node\n");\r\nreturn -ENODEV;\r\n}\r\nvalp = of_get_property(cpunode, "cpu-version", NULL);\r\nif (!valp) {\r\nDBG("No cpu-version property !\n");\r\ngoto bail_noprops;\r\n}\r\npvr_hi = (*valp) >> 16;\r\nif (pvr_hi != 0x3c && pvr_hi != 0x44) {\r\nprintk(KERN_ERR "cpufreq: Unsupported CPU version\n");\r\ngoto bail_noprops;\r\n}\r\ng5_pmode_data = of_get_property(cpunode, "power-mode-data",&psize);\r\nif (!g5_pmode_data) {\r\nDBG("No power-mode-data !\n");\r\ngoto bail_noprops;\r\n}\r\ng5_pmode_max = psize / sizeof(u32) - 1;\r\nif (use_volts_smu) {\r\nconst struct smu_sdbp_header *shdr;\r\nshdr = smu_get_sdb_partition(SMU_SDB_FVT_ID, NULL);\r\nif (!shdr)\r\ngoto bail_noprops;\r\ng5_fvt_table = (struct smu_sdbp_fvt *)&shdr[1];\r\nssize = (shdr->len * sizeof(u32)) -\r\nsizeof(struct smu_sdbp_header);\r\ng5_fvt_count = ssize / sizeof(struct smu_sdbp_fvt);\r\ng5_fvt_cur = 0;\r\nif (g5_fvt_count < 1 || g5_pmode_max < 1)\r\ngoto bail_noprops;\r\ng5_switch_volt = g5_smu_switch_volt;\r\nvolt_method = "SMU";\r\n} else if (use_volts_vdnap) {\r\nstruct device_node *root;\r\nroot = of_find_node_by_path("/");\r\nif (root == NULL) {\r\nprintk(KERN_ERR "cpufreq: Can't find root of "\r\n"device tree\n");\r\ngoto bail_noprops;\r\n}\r\npfunc_set_vdnap0 = pmf_find_function(root, "set-vdnap0");\r\npfunc_vdnap0_complete =\r\npmf_find_function(root, "slewing-done");\r\nif (pfunc_set_vdnap0 == NULL ||\r\npfunc_vdnap0_complete == NULL) {\r\nprintk(KERN_ERR "cpufreq: Can't find required "\r\n"platform function\n");\r\ngoto bail_noprops;\r\n}\r\ng5_switch_volt = g5_vdnap_switch_volt;\r\nvolt_method = "GPIO";\r\n} else {\r\ng5_switch_volt = g5_dummy_switch_volt;\r\nvolt_method = "none";\r\n}\r\nvalp = of_get_property(cpunode, "clock-frequency", NULL);\r\nif (!valp)\r\nreturn -ENODEV;\r\nmax_freq = (*valp)/1000;\r\ng5_cpu_freqs[0].frequency = max_freq;\r\ng5_cpu_freqs[1].frequency = max_freq/2;\r\ntransition_latency = 12000;\r\ng5_switch_freq = g5_scom_switch_freq;\r\ng5_query_freq = g5_scom_query_freq;\r\nfreq_method = "SCOM";\r\ng5_switch_volt(CPUFREQ_HIGH);\r\nmsleep(10);\r\ng5_pmode_cur = -1;\r\ng5_switch_freq(g5_query_freq());\r\nprintk(KERN_INFO "Registering G5 CPU frequency driver\n");\r\nprintk(KERN_INFO "Frequency method: %s, Voltage method: %s\n",\r\nfreq_method, volt_method);\r\nprintk(KERN_INFO "Low: %d Mhz, High: %d Mhz, Cur: %d MHz\n",\r\ng5_cpu_freqs[1].frequency/1000,\r\ng5_cpu_freqs[0].frequency/1000,\r\ng5_cpu_freqs[g5_pmode_cur].frequency/1000);\r\nrc = cpufreq_register_driver(&g5_cpufreq_driver);\r\nreturn rc;\r\nbail_noprops:\r\nof_node_put(cpunode);\r\nreturn rc;\r\n}\r\nstatic int __init g5_pm72_cpufreq_init(struct device_node *cpus)\r\n{\r\nstruct device_node *cpuid = NULL, *hwclock = NULL, *cpunode = NULL;\r\nconst u8 *eeprom = NULL;\r\nconst u32 *valp;\r\nu64 max_freq, min_freq, ih, il;\r\nint has_volt = 1, rc = 0;\r\nDBG("cpufreq: Initializing for PowerMac7,2, PowerMac7,3 and"\r\n" RackMac3,1...\n");\r\nfor (cpunode = NULL;\r\n(cpunode = of_get_next_child(cpus, cpunode)) != NULL;) {\r\nif (!strcmp(cpunode->type, "cpu"))\r\nbreak;\r\n}\r\nif (cpunode == NULL) {\r\nprintk(KERN_ERR "cpufreq: Can't find any CPU node\n");\r\nreturn -ENODEV;\r\n}\r\ncpuid = of_find_node_by_path("/u3@0,f8000000/i2c@f8001000/cpuid@a0");\r\nif (cpuid != NULL)\r\neeprom = of_get_property(cpuid, "cpuid", NULL);\r\nif (eeprom == NULL) {\r\nprintk(KERN_ERR "cpufreq: Can't find cpuid EEPROM !\n");\r\nrc = -ENODEV;\r\ngoto bail;\r\n}\r\nfor (hwclock = NULL;\r\n(hwclock = of_find_node_by_name(hwclock, "i2c-hwclock")) != NULL;){\r\nconst char *loc = of_get_property(hwclock,\r\n"hwctrl-location", NULL);\r\nif (loc == NULL)\r\ncontinue;\r\nif (strcmp(loc, "CPU CLOCK"))\r\ncontinue;\r\nif (!of_get_property(hwclock, "platform-get-frequency", NULL))\r\ncontinue;\r\nbreak;\r\n}\r\nif (hwclock == NULL) {\r\nprintk(KERN_ERR "cpufreq: Can't find i2c clock chip !\n");\r\nrc = -ENODEV;\r\ngoto bail;\r\n}\r\nDBG("cpufreq: i2c clock chip found: %s\n", hwclock->full_name);\r\npfunc_cpu_getfreq =\r\npmf_find_function(hwclock, "get-frequency");\r\npfunc_cpu_setfreq_high =\r\npmf_find_function(hwclock, "set-frequency-high");\r\npfunc_cpu_setfreq_low =\r\npmf_find_function(hwclock, "set-frequency-low");\r\npfunc_slewing_done =\r\npmf_find_function(hwclock, "slewing-done");\r\npfunc_cpu0_volt_high =\r\npmf_find_function(hwclock, "set-voltage-high-0");\r\npfunc_cpu0_volt_low =\r\npmf_find_function(hwclock, "set-voltage-low-0");\r\npfunc_cpu1_volt_high =\r\npmf_find_function(hwclock, "set-voltage-high-1");\r\npfunc_cpu1_volt_low =\r\npmf_find_function(hwclock, "set-voltage-low-1");\r\nif (pfunc_cpu_getfreq == NULL || pfunc_cpu_setfreq_high == NULL ||\r\npfunc_cpu_setfreq_low == NULL || pfunc_slewing_done == NULL) {\r\nprintk(KERN_ERR "cpufreq: Can't find platform functions !\n");\r\nrc = -ENODEV;\r\ngoto bail;\r\n}\r\nif (pfunc_cpu0_volt_high == NULL || pfunc_cpu0_volt_low == NULL) {\r\npmf_put_function(pfunc_cpu0_volt_high);\r\npmf_put_function(pfunc_cpu0_volt_low);\r\npfunc_cpu0_volt_high = pfunc_cpu0_volt_low = NULL;\r\nhas_volt = 0;\r\n}\r\nif (!has_volt ||\r\npfunc_cpu1_volt_high == NULL || pfunc_cpu1_volt_low == NULL) {\r\npmf_put_function(pfunc_cpu1_volt_high);\r\npmf_put_function(pfunc_cpu1_volt_low);\r\npfunc_cpu1_volt_high = pfunc_cpu1_volt_low = NULL;\r\n}\r\nvalp = of_get_property(cpunode, "clock-frequency", NULL);\r\nif (!valp) {\r\nprintk(KERN_ERR "cpufreq: Can't find CPU frequency !\n");\r\nrc = -ENODEV;\r\ngoto bail;\r\n}\r\nmax_freq = (*valp)/1000;\r\nih = *((u32 *)(eeprom + 0x10));\r\nil = *((u32 *)(eeprom + 0x20));\r\nif (il == ih) {\r\nprintk(KERN_WARNING "cpufreq: No low frequency mode available"\r\n" on this model !\n");\r\nrc = -ENODEV;\r\ngoto bail;\r\n}\r\nmin_freq = 0;\r\nif (ih != 0 && il != 0)\r\nmin_freq = (max_freq * il) / ih;\r\nif (min_freq >= max_freq || min_freq < 1000) {\r\nprintk(KERN_ERR "cpufreq: Can't calculate low frequency !\n");\r\nrc = -ENXIO;\r\ngoto bail;\r\n}\r\ng5_cpu_freqs[0].frequency = max_freq;\r\ng5_cpu_freqs[1].frequency = min_freq;\r\ntransition_latency = CPUFREQ_ETERNAL;\r\ng5_switch_volt = g5_pfunc_switch_volt;\r\ng5_switch_freq = g5_pfunc_switch_freq;\r\ng5_query_freq = g5_pfunc_query_freq;\r\ng5_switch_volt(CPUFREQ_HIGH);\r\nmsleep(10);\r\ng5_pmode_cur = -1;\r\ng5_switch_freq(g5_query_freq());\r\nprintk(KERN_INFO "Registering G5 CPU frequency driver\n");\r\nprintk(KERN_INFO "Frequency method: i2c/pfunc, "\r\n"Voltage method: %s\n", has_volt ? "i2c/pfunc" : "none");\r\nprintk(KERN_INFO "Low: %d Mhz, High: %d Mhz, Cur: %d MHz\n",\r\ng5_cpu_freqs[1].frequency/1000,\r\ng5_cpu_freqs[0].frequency/1000,\r\ng5_cpu_freqs[g5_pmode_cur].frequency/1000);\r\nrc = cpufreq_register_driver(&g5_cpufreq_driver);\r\nbail:\r\nif (rc != 0) {\r\npmf_put_function(pfunc_cpu_getfreq);\r\npmf_put_function(pfunc_cpu_setfreq_high);\r\npmf_put_function(pfunc_cpu_setfreq_low);\r\npmf_put_function(pfunc_slewing_done);\r\npmf_put_function(pfunc_cpu0_volt_high);\r\npmf_put_function(pfunc_cpu0_volt_low);\r\npmf_put_function(pfunc_cpu1_volt_high);\r\npmf_put_function(pfunc_cpu1_volt_low);\r\n}\r\nof_node_put(hwclock);\r\nof_node_put(cpuid);\r\nof_node_put(cpunode);\r\nreturn rc;\r\n}\r\nstatic int __init g5_cpufreq_init(void)\r\n{\r\nstruct device_node *cpus;\r\nint rc = 0;\r\ncpus = of_find_node_by_path("/cpus");\r\nif (cpus == NULL) {\r\nDBG("No /cpus node !\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_machine_is_compatible("PowerMac7,2") ||\r\nof_machine_is_compatible("PowerMac7,3") ||\r\nof_machine_is_compatible("RackMac3,1"))\r\nrc = g5_pm72_cpufreq_init(cpus);\r\n#ifdef CONFIG_PMAC_SMU\r\nelse\r\nrc = g5_neo2_cpufreq_init(cpus);\r\n#endif\r\nof_node_put(cpus);\r\nreturn rc;\r\n}
