static void\r\ndummyf(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nprintk(KERN_WARNING "HiSax: hfcd dummy fifo called\n");\r\n}\r\nstatic inline u_char\r\nReadReg(struct IsdnCardState *cs, int data, u_char reg)\r\n{\r\nregister u_char ret;\r\nif (data) {\r\nif (cs->hw.hfcD.cip != reg) {\r\ncs->hw.hfcD.cip = reg;\r\nbyteout(cs->hw.hfcD.addr | 1, reg);\r\n}\r\nret = bytein(cs->hw.hfcD.addr);\r\n#ifdef HFC_REG_DEBUG\r\nif (cs->debug & L1_DEB_HSCX_FIFO && (data != 2))\r\ndebugl1(cs, "t3c RD %02x %02x", reg, ret);\r\n#endif\r\n} else\r\nret = bytein(cs->hw.hfcD.addr | 1);\r\nreturn (ret);\r\n}\r\nstatic inline void\r\nWriteReg(struct IsdnCardState *cs, int data, u_char reg, u_char value)\r\n{\r\nif (cs->hw.hfcD.cip != reg) {\r\ncs->hw.hfcD.cip = reg;\r\nbyteout(cs->hw.hfcD.addr | 1, reg);\r\n}\r\nif (data)\r\nbyteout(cs->hw.hfcD.addr, value);\r\n#ifdef HFC_REG_DEBUG\r\nif (cs->debug & L1_DEB_HSCX_FIFO && (data != HFCD_DATA_NODEB))\r\ndebugl1(cs, "t3c W%c %02x %02x", data ? 'D' : 'C', reg, value);\r\n#endif\r\n}\r\nstatic u_char\r\nreadreghfcd(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (ReadReg(cs, HFCD_DATA, offset));\r\n}\r\nstatic void\r\nwritereghfcd(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nWriteReg(cs, HFCD_DATA, offset, value);\r\n}\r\nstatic inline int\r\nWaitForBusy(struct IsdnCardState *cs)\r\n{\r\nint to = 130;\r\nwhile (!(ReadReg(cs, HFCD_DATA, HFCD_STAT) & HFCD_BUSY) && to) {\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to)\r\nprintk(KERN_WARNING "HiSax: WaitForBusy timeout\n");\r\nreturn (to);\r\n}\r\nstatic inline int\r\nWaitNoBusy(struct IsdnCardState *cs)\r\n{\r\nint to = 130;\r\nwhile ((ReadReg(cs, HFCD_STATUS, HFCD_STATUS) & HFCD_BUSY) && to) {\r\nudelay(1);\r\nto--;\r\n}\r\nif (!to)\r\nprintk(KERN_WARNING "HiSax: WaitNoBusy timeout\n");\r\nreturn (to);\r\n}\r\nstatic int\r\nSelFiFo(struct IsdnCardState *cs, u_char FiFo)\r\n{\r\nu_char cip;\r\nif (cs->hw.hfcD.fifo == FiFo)\r\nreturn (1);\r\nswitch (FiFo) {\r\ncase 0: cip = HFCB_FIFO | HFCB_Z1 | HFCB_SEND | HFCB_B1;\r\nbreak;\r\ncase 1: cip = HFCB_FIFO | HFCB_Z1 | HFCB_REC | HFCB_B1;\r\nbreak;\r\ncase 2: cip = HFCB_FIFO | HFCB_Z1 | HFCB_SEND | HFCB_B2;\r\nbreak;\r\ncase 3: cip = HFCB_FIFO | HFCB_Z1 | HFCB_REC | HFCB_B2;\r\nbreak;\r\ncase 4: cip = HFCD_FIFO | HFCD_Z1 | HFCD_SEND;\r\nbreak;\r\ncase 5: cip = HFCD_FIFO | HFCD_Z1 | HFCD_REC;\r\nbreak;\r\ndefault:\r\ndebugl1(cs, "SelFiFo Error");\r\nreturn (0);\r\n}\r\ncs->hw.hfcD.fifo = FiFo;\r\nWaitNoBusy(cs);\r\ncs->BC_Write_Reg(cs, HFCD_DATA, cip, 0);\r\nWaitForBusy(cs);\r\nreturn (2);\r\n}\r\nstatic int\r\nGetFreeFifoBytes_B(struct BCState *bcs)\r\n{\r\nint s;\r\nif (bcs->hw.hfc.f1 == bcs->hw.hfc.f2)\r\nreturn (bcs->cs->hw.hfcD.bfifosize);\r\ns = bcs->hw.hfc.send[bcs->hw.hfc.f1] - bcs->hw.hfc.send[bcs->hw.hfc.f2];\r\nif (s <= 0)\r\ns += bcs->cs->hw.hfcD.bfifosize;\r\ns = bcs->cs->hw.hfcD.bfifosize - s;\r\nreturn (s);\r\n}\r\nstatic int\r\nGetFreeFifoBytes_D(struct IsdnCardState *cs)\r\n{\r\nint s;\r\nif (cs->hw.hfcD.f1 == cs->hw.hfcD.f2)\r\nreturn (cs->hw.hfcD.dfifosize);\r\ns = cs->hw.hfcD.send[cs->hw.hfcD.f1] - cs->hw.hfcD.send[cs->hw.hfcD.f2];\r\nif (s <= 0)\r\ns += cs->hw.hfcD.dfifosize;\r\ns = cs->hw.hfcD.dfifosize - s;\r\nreturn (s);\r\n}\r\nstatic int\r\nReadZReg(struct IsdnCardState *cs, u_char reg)\r\n{\r\nint val;\r\nWaitNoBusy(cs);\r\nval = 256 * ReadReg(cs, HFCD_DATA, reg | HFCB_Z_HIGH);\r\nWaitNoBusy(cs);\r\nval += ReadReg(cs, HFCD_DATA, reg | HFCB_Z_LOW);\r\nreturn (val);\r\n}\r\nstatic struct sk_buff\r\n*hfc_empty_fifo(struct BCState *bcs, int count)\r\n{\r\nu_char *ptr;\r\nstruct sk_buff *skb;\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint idx;\r\nint chksum;\r\nu_char stat, cip;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "hfc_empty_fifo");\r\nidx = 0;\r\nif (count > HSCX_BUFMAX + 3) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfc_empty_fifo: incoming packet too large");\r\ncip = HFCB_FIFO | HFCB_FIFO_OUT | HFCB_REC | HFCB_CHANNEL(bcs->channel);\r\nwhile (idx++ < count) {\r\nWaitNoBusy(cs);\r\nReadReg(cs, HFCD_DATA_NODEB, cip);\r\n}\r\nskb = NULL;\r\n} else if (count < 4) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfc_empty_fifo: incoming packet too small");\r\ncip = HFCB_FIFO | HFCB_FIFO_OUT | HFCB_REC | HFCB_CHANNEL(bcs->channel);\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_inv++;\r\n#endif\r\nwhile ((idx++ < count) && WaitNoBusy(cs))\r\nReadReg(cs, HFCD_DATA_NODEB, cip);\r\nskb = NULL;\r\n} else if (!(skb = dev_alloc_skb(count - 3)))\r\nprintk(KERN_WARNING "HFC: receive out of memory\n");\r\nelse {\r\nptr = skb_put(skb, count - 3);\r\nidx = 0;\r\ncip = HFCB_FIFO | HFCB_FIFO_OUT | HFCB_REC | HFCB_CHANNEL(bcs->channel);\r\nwhile (idx < (count - 3)) {\r\nif (!WaitNoBusy(cs))\r\nbreak;\r\n*ptr = ReadReg(cs, HFCD_DATA_NODEB, cip);\r\nptr++;\r\nidx++;\r\n}\r\nif (idx != count - 3) {\r\ndebugl1(cs, "RFIFO BUSY error");\r\nprintk(KERN_WARNING "HFC FIFO channel %d BUSY Error\n", bcs->channel);\r\ndev_kfree_skb_irq(skb);\r\nskb = NULL;\r\n} else {\r\nWaitNoBusy(cs);\r\nchksum = (ReadReg(cs, HFCD_DATA, cip) << 8);\r\nWaitNoBusy(cs);\r\nchksum += ReadReg(cs, HFCD_DATA, cip);\r\nWaitNoBusy(cs);\r\nstat = ReadReg(cs, HFCD_DATA, cip);\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_empty_fifo %d chksum %x stat %x",\r\nbcs->channel, chksum, stat);\r\nif (stat) {\r\ndebugl1(cs, "FIFO CRC error");\r\ndev_kfree_skb_irq(skb);\r\nskb = NULL;\r\n#ifdef ERROR_STATISTIC\r\nbcs->err_crc++;\r\n#endif\r\n}\r\n}\r\n}\r\nWaitForBusy(cs);\r\nWaitNoBusy(cs);\r\nstat = ReadReg(cs, HFCD_DATA, HFCB_FIFO | HFCB_F2_INC |\r\nHFCB_REC | HFCB_CHANNEL(bcs->channel));\r\nWaitForBusy(cs);\r\nreturn (skb);\r\n}\r\nstatic void\r\nhfc_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint idx, fcnt;\r\nint count;\r\nu_char cip;\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\nSelFiFo(cs, HFCB_SEND | HFCB_CHANNEL(bcs->channel));\r\ncip = HFCB_FIFO | HFCB_F1 | HFCB_SEND | HFCB_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nbcs->hw.hfc.f1 = ReadReg(cs, HFCD_DATA, cip);\r\nWaitNoBusy(cs);\r\ncip = HFCB_FIFO | HFCB_F2 | HFCB_SEND | HFCB_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nbcs->hw.hfc.f2 = ReadReg(cs, HFCD_DATA, cip);\r\nbcs->hw.hfc.send[bcs->hw.hfc.f1] = ReadZReg(cs, HFCB_FIFO | HFCB_Z1 | HFCB_SEND | HFCB_CHANNEL(bcs->channel));\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_fifo %d f1(%d) f2(%d) z1(%x)",\r\nbcs->channel, bcs->hw.hfc.f1, bcs->hw.hfc.f2,\r\nbcs->hw.hfc.send[bcs->hw.hfc.f1]);\r\nfcnt = bcs->hw.hfc.f1 - bcs->hw.hfc.f2;\r\nif (fcnt < 0)\r\nfcnt += 32;\r\nif (fcnt > 30) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_fifo more as 30 frames");\r\nreturn;\r\n}\r\ncount = GetFreeFifoBytes_B(bcs);\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_fifo %d count(%u/%d),%lx",\r\nbcs->channel, bcs->tx_skb->len,\r\ncount, current->state);\r\nif (count < bcs->tx_skb->len) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_fifo no fifo mem");\r\nreturn;\r\n}\r\ncip = HFCB_FIFO | HFCB_FIFO_IN | HFCB_SEND | HFCB_CHANNEL(bcs->channel);\r\nidx = 0;\r\nWaitForBusy(cs);\r\nWaitNoBusy(cs);\r\nWriteReg(cs, HFCD_DATA_NODEB, cip, bcs->tx_skb->data[idx++]);\r\nwhile (idx < bcs->tx_skb->len) {\r\nif (!WaitNoBusy(cs))\r\nbreak;\r\nWriteReg(cs, HFCD_DATA_NODEB, cip, bcs->tx_skb->data[idx]);\r\nidx++;\r\n}\r\nif (idx != bcs->tx_skb->len) {\r\ndebugl1(cs, "FIFO Send BUSY error");\r\nprintk(KERN_WARNING "HFC S FIFO channel %d BUSY Error\n", bcs->channel);\r\n} else {\r\nbcs->tx_cnt -= bcs->tx_skb->len;\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->tx_skb->len;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\n}\r\nWaitForBusy(cs);\r\nWaitNoBusy(cs);\r\nReadReg(cs, HFCD_DATA, HFCB_FIFO | HFCB_F1_INC | HFCB_SEND | HFCB_CHANNEL(bcs->channel));\r\nWaitForBusy(cs);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nreturn;\r\n}\r\nstatic void\r\nhfc_send_data(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "send_data %d blocked", bcs->channel);\r\n}\r\nstatic void\r\nmain_rec_2bds0(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint z1, z2, rcnt;\r\nu_char f1, f2, cip;\r\nint receive, count = 5;\r\nstruct sk_buff *skb;\r\nBegin:\r\ncount--;\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ndebugl1(cs, "rec_data %d blocked", bcs->channel);\r\nreturn;\r\n}\r\nSelFiFo(cs, HFCB_REC | HFCB_CHANNEL(bcs->channel));\r\ncip = HFCB_FIFO | HFCB_F1 | HFCB_REC | HFCB_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nf1 = ReadReg(cs, HFCD_DATA, cip);\r\ncip = HFCB_FIFO | HFCB_F2 | HFCB_REC | HFCB_CHANNEL(bcs->channel);\r\nWaitNoBusy(cs);\r\nf2 = ReadReg(cs, HFCD_DATA, cip);\r\nif (f1 != f2) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc rec %d f1(%d) f2(%d)",\r\nbcs->channel, f1, f2);\r\nz1 = ReadZReg(cs, HFCB_FIFO | HFCB_Z1 | HFCB_REC | HFCB_CHANNEL(bcs->channel));\r\nz2 = ReadZReg(cs, HFCB_FIFO | HFCB_Z2 | HFCB_REC | HFCB_CHANNEL(bcs->channel));\r\nrcnt = z1 - z2;\r\nif (rcnt < 0)\r\nrcnt += cs->hw.hfcD.bfifosize;\r\nrcnt++;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc rec %d z1(%x) z2(%x) cnt(%d)",\r\nbcs->channel, z1, z2, rcnt);\r\nif ((skb = hfc_empty_fifo(bcs, rcnt))) {\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\nrcnt = f1 - f2;\r\nif (rcnt < 0)\r\nrcnt += 32;\r\nif (rcnt > 1)\r\nreceive = 1;\r\nelse\r\nreceive = 0;\r\n} else\r\nreceive = 0;\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nif (count && receive)\r\ngoto Begin;\r\nreturn;\r\n}\r\nstatic void\r\nmode_2bs0(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HFCD bchannel mode %d bchan %d/%d",\r\nmode, bc, bcs->channel);\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\nswitch (mode) {\r\ncase (L1_MODE_NULL):\r\nif (bc) {\r\ncs->hw.hfcD.conn |= 0x18;\r\ncs->hw.hfcD.sctrl &= ~SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcD.conn |= 0x3;\r\ncs->hw.hfcD.sctrl &= ~SCTRL_B1_ENA;\r\n}\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\nif (bc) {\r\ncs->hw.hfcD.ctmt |= 2;\r\ncs->hw.hfcD.conn &= ~0x18;\r\ncs->hw.hfcD.sctrl |= SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcD.ctmt |= 1;\r\ncs->hw.hfcD.conn &= ~0x3;\r\ncs->hw.hfcD.sctrl |= SCTRL_B1_ENA;\r\n}\r\nbreak;\r\ncase (L1_MODE_HDLC):\r\nif (bc) {\r\ncs->hw.hfcD.ctmt &= ~2;\r\ncs->hw.hfcD.conn &= ~0x18;\r\ncs->hw.hfcD.sctrl |= SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcD.ctmt &= ~1;\r\ncs->hw.hfcD.conn &= ~0x3;\r\ncs->hw.hfcD.sctrl |= SCTRL_B1_ENA;\r\n}\r\nbreak;\r\n}\r\nWriteReg(cs, HFCD_DATA, HFCD_SCTRL, cs->hw.hfcD.sctrl);\r\nWriteReg(cs, HFCD_DATA, HFCD_CTMT, cs->hw.hfcD.ctmt);\r\nWriteReg(cs, HFCD_DATA, HFCD_CONN, cs->hw.hfcD.conn);\r\n}\r\nstatic void\r\nhfc_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "hfc_l2l1: this shouldn't happen\n");\r\n} else {\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nmode_2bs0(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nmode_2bs0(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_2bs0(struct BCState *bcs)\r\n{\r\nmode_2bs0(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nstatic int\r\nopen_hfcstate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_2b(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_hfcstate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = hfc_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nstatic void\r\nhfcd_bh(struct work_struct *work)\r\n{\r\nstruct IsdnCardState *cs =\r\ncontainer_of(work, struct IsdnCardState, tqueue);\r\nif (test_and_clear_bit(D_L1STATECHANGE, &cs->event)) {\r\nswitch (cs->dc.hfcd.ph_state) {\r\ncase (0):\r\nl1_msg(cs, HW_RESET | INDICATION, NULL);\r\nbreak;\r\ncase (3):\r\nl1_msg(cs, HW_DEACTIVATE | INDICATION, NULL);\r\nbreak;\r\ncase (8):\r\nl1_msg(cs, HW_RSYNC | INDICATION, NULL);\r\nbreak;\r\ncase (6):\r\nl1_msg(cs, HW_INFO2 | INDICATION, NULL);\r\nbreak;\r\ncase (7):\r\nl1_msg(cs, HW_INFO4_P8 | INDICATION, NULL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (test_and_clear_bit(D_RCVBUFREADY, &cs->event))\r\nDChannel_proc_rcv(cs);\r\nif (test_and_clear_bit(D_XMTBUFREADY, &cs->event))\r\nDChannel_proc_xmt(cs);\r\n}\r\nstatic\r\nint receive_dmsg(struct IsdnCardState *cs)\r\n{\r\nstruct sk_buff *skb;\r\nint idx;\r\nint rcnt, z1, z2;\r\nu_char stat, cip, f1, f2;\r\nint chksum;\r\nint count = 5;\r\nu_char *ptr;\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ndebugl1(cs, "rec_dmsg blocked");\r\nreturn (1);\r\n}\r\nSelFiFo(cs, 4 | HFCD_REC);\r\ncip = HFCD_FIFO | HFCD_F1 | HFCD_REC;\r\nWaitNoBusy(cs);\r\nf1 = cs->readisac(cs, cip) & 0xf;\r\ncip = HFCD_FIFO | HFCD_F2 | HFCD_REC;\r\nWaitNoBusy(cs);\r\nf2 = cs->readisac(cs, cip) & 0xf;\r\nwhile ((f1 != f2) && count--) {\r\nz1 = ReadZReg(cs, HFCD_FIFO | HFCD_Z1 | HFCD_REC);\r\nz2 = ReadZReg(cs, HFCD_FIFO | HFCD_Z2 | HFCD_REC);\r\nrcnt = z1 - z2;\r\nif (rcnt < 0)\r\nrcnt += cs->hw.hfcD.dfifosize;\r\nrcnt++;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfcd recd f1(%d) f2(%d) z1(%x) z2(%x) cnt(%d)",\r\nf1, f2, z1, z2, rcnt);\r\nidx = 0;\r\ncip = HFCD_FIFO | HFCD_FIFO_OUT | HFCD_REC;\r\nif (rcnt > MAX_DFRAME_LEN + 3) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "empty_fifo d: incoming packet too large");\r\nwhile (idx < rcnt) {\r\nif (!(WaitNoBusy(cs)))\r\nbreak;\r\nReadReg(cs, HFCD_DATA_NODEB, cip);\r\nidx++;\r\n}\r\n} else if (rcnt < 4) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "empty_fifo d: incoming packet too small");\r\nwhile ((idx++ < rcnt) && WaitNoBusy(cs))\r\nReadReg(cs, HFCD_DATA_NODEB, cip);\r\n} else if ((skb = dev_alloc_skb(rcnt - 3))) {\r\nptr = skb_put(skb, rcnt - 3);\r\nwhile (idx < (rcnt - 3)) {\r\nif (!(WaitNoBusy(cs)))\r\nbreak;\r\n*ptr = ReadReg(cs, HFCD_DATA_NODEB, cip);\r\nidx++;\r\nptr++;\r\n}\r\nif (idx != (rcnt - 3)) {\r\ndebugl1(cs, "RFIFO D BUSY error");\r\nprintk(KERN_WARNING "HFC DFIFO channel BUSY Error\n");\r\ndev_kfree_skb_irq(skb);\r\nskb = NULL;\r\n#ifdef ERROR_STATISTIC\r\ncs->err_rx++;\r\n#endif\r\n} else {\r\nWaitNoBusy(cs);\r\nchksum = (ReadReg(cs, HFCD_DATA, cip) << 8);\r\nWaitNoBusy(cs);\r\nchksum += ReadReg(cs, HFCD_DATA, cip);\r\nWaitNoBusy(cs);\r\nstat = ReadReg(cs, HFCD_DATA, cip);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "empty_dfifo chksum %x stat %x",\r\nchksum, stat);\r\nif (stat) {\r\ndebugl1(cs, "FIFO CRC error");\r\ndev_kfree_skb_irq(skb);\r\nskb = NULL;\r\n#ifdef ERROR_STATISTIC\r\ncs->err_crc++;\r\n#endif\r\n} else {\r\nskb_queue_tail(&cs->rq, skb);\r\nschedule_event(cs, D_RCVBUFREADY);\r\n}\r\n}\r\n} else\r\nprintk(KERN_WARNING "HFC: D receive out of memory\n");\r\nWaitForBusy(cs);\r\ncip = HFCD_FIFO | HFCD_F2_INC | HFCD_REC;\r\nWaitNoBusy(cs);\r\nstat = ReadReg(cs, HFCD_DATA, cip);\r\nWaitForBusy(cs);\r\ncip = HFCD_FIFO | HFCD_F2 | HFCD_REC;\r\nWaitNoBusy(cs);\r\nf2 = cs->readisac(cs, cip) & 0xf;\r\n}\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nreturn (1);\r\n}\r\nstatic void\r\nhfc_fill_dfifo(struct IsdnCardState *cs)\r\n{\r\nint idx, fcnt;\r\nint count;\r\nu_char cip;\r\nif (!cs->tx_skb)\r\nreturn;\r\nif (cs->tx_skb->len <= 0)\r\nreturn;\r\nSelFiFo(cs, 4 | HFCD_SEND);\r\ncip = HFCD_FIFO | HFCD_F1 | HFCD_SEND;\r\nWaitNoBusy(cs);\r\ncs->hw.hfcD.f1 = ReadReg(cs, HFCD_DATA, cip) & 0xf;\r\nWaitNoBusy(cs);\r\ncip = HFCD_FIFO | HFCD_F2 | HFCD_SEND;\r\ncs->hw.hfcD.f2 = ReadReg(cs, HFCD_DATA, cip) & 0xf;\r\ncs->hw.hfcD.send[cs->hw.hfcD.f1] = ReadZReg(cs, HFCD_FIFO | HFCD_Z1 | HFCD_SEND);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfc_fill_Dfifo f1(%d) f2(%d) z1(%x)",\r\ncs->hw.hfcD.f1, cs->hw.hfcD.f2,\r\ncs->hw.hfcD.send[cs->hw.hfcD.f1]);\r\nfcnt = cs->hw.hfcD.f1 - cs->hw.hfcD.f2;\r\nif (fcnt < 0)\r\nfcnt += 16;\r\nif (fcnt > 14) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "hfc_fill_Dfifo more as 14 frames");\r\nreturn;\r\n}\r\ncount = GetFreeFifoBytes_D(cs);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfc_fill_Dfifo count(%u/%d)",\r\ncs->tx_skb->len, count);\r\nif (count < cs->tx_skb->len) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "hfc_fill_Dfifo no fifo mem");\r\nreturn;\r\n}\r\ncip = HFCD_FIFO | HFCD_FIFO_IN | HFCD_SEND;\r\nidx = 0;\r\nWaitForBusy(cs);\r\nWaitNoBusy(cs);\r\nWriteReg(cs, HFCD_DATA_NODEB, cip, cs->tx_skb->data[idx++]);\r\nwhile (idx < cs->tx_skb->len) {\r\nif (!(WaitNoBusy(cs)))\r\nbreak;\r\nWriteReg(cs, HFCD_DATA_NODEB, cip, cs->tx_skb->data[idx]);\r\nidx++;\r\n}\r\nif (idx != cs->tx_skb->len) {\r\ndebugl1(cs, "DFIFO Send BUSY error");\r\nprintk(KERN_WARNING "HFC S DFIFO channel BUSY Error\n");\r\n}\r\nWaitForBusy(cs);\r\nWaitNoBusy(cs);\r\nReadReg(cs, HFCD_DATA, HFCD_FIFO | HFCD_F1_INC | HFCD_SEND);\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_skb = NULL;\r\nWaitForBusy(cs);\r\nreturn;\r\n}\r\nstatic\r\nstruct BCState *Sel_BCS(struct IsdnCardState *cs, int channel)\r\n{\r\nif (cs->bcs[0].mode && (cs->bcs[0].channel == channel))\r\nreturn (&cs->bcs[0]);\r\nelse if (cs->bcs[1].mode && (cs->bcs[1].channel == channel))\r\nreturn (&cs->bcs[1]);\r\nelse\r\nreturn (NULL);\r\n}\r\nvoid\r\nhfc2bds0_interrupt(struct IsdnCardState *cs, u_char val)\r\n{\r\nu_char exval;\r\nstruct BCState *bcs;\r\nint count = 15;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFCD irq %x %s", val,\r\ntest_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags) ?\r\n"locked" : "unlocked");\r\nval &= cs->hw.hfcD.int_m1;\r\nif (val & 0x40) {\r\nexval = cs->readisac(cs, HFCD_STATES) & 0xf;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ph_state chg %d->%d", cs->dc.hfcd.ph_state,\r\nexval);\r\ncs->dc.hfcd.ph_state = exval;\r\nschedule_event(cs, D_L1STATECHANGE);\r\nval &= ~0x40;\r\n}\r\nwhile (val) {\r\nif (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ncs->hw.hfcD.int_s1 |= val;\r\nreturn;\r\n}\r\nif (cs->hw.hfcD.int_s1 & 0x18) {\r\nexval = val;\r\nval = cs->hw.hfcD.int_s1;\r\ncs->hw.hfcD.int_s1 = exval;\r\n}\r\nif (val & 0x08) {\r\nif (!(bcs = Sel_BCS(cs, 0))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcd spurious 0x08 IRQ");\r\n} else\r\nmain_rec_2bds0(bcs);\r\n}\r\nif (val & 0x10) {\r\nif (!(bcs = Sel_BCS(cs, 1))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcd spurious 0x10 IRQ");\r\n} else\r\nmain_rec_2bds0(bcs);\r\n}\r\nif (val & 0x01) {\r\nif (!(bcs = Sel_BCS(cs, 0))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcd spurious 0x01 IRQ");\r\n} else {\r\nif (bcs->tx_skb) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\n}\r\nif (val & 0x02) {\r\nif (!(bcs = Sel_BCS(cs, 1))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcd spurious 0x02 IRQ");\r\n} else {\r\nif (bcs->tx_skb) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\n}\r\nif (val & 0x20) {\r\nreceive_dmsg(cs);\r\n}\r\nif (val & 0x04) {\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nif (cs->tx_skb->len) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else {\r\ndebugl1(cs, "hfc_fill_dfifo irq blocked");\r\n}\r\ngoto afterXPR;\r\n} else {\r\ndev_kfree_skb_irq(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\n}\r\n}\r\nif ((cs->tx_skb = skb_dequeue(&cs->sq))) {\r\ncs->tx_cnt = 0;\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else {\r\ndebugl1(cs, "hfc_fill_dfifo irq blocked");\r\n}\r\n} else\r\nschedule_event(cs, D_XMTBUFREADY);\r\n}\r\nafterXPR:\r\nif (cs->hw.hfcD.int_s1 && count--) {\r\nval = cs->hw.hfcD.int_s1;\r\ncs->hw.hfcD.int_s1 = 0;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFCD irq %x loop %d", val, 15-count);\r\n} else\r\nval = 0;\r\n}\r\n}\r\nstatic void\r\nHFCD_l1hw(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nskb_queue_tail(&cs->sq, skb);\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA Queued", 0);\r\n#endif\r\n} else {\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA", 0);\r\n#endif\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "hfc_fill_dfifo blocked");\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, " l2l1 tx_skb exist this shouldn't happen");\r\nskb_queue_tail(&cs->sq, skb);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\n}\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA_PULLED", 0);\r\n#endif\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfc_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "hfc_fill_dfifo blocked");\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\ndebugl1(cs, "-> PH_REQUEST_PULL");\r\n#endif\r\nif (!cs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (HW_RESET | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->writeisac(cs, HFCD_STATES, HFCD_LOAD_STATE | 3);\r\nudelay(6);\r\ncs->writeisac(cs, HFCD_STATES, 3);\r\ncs->hw.hfcD.mst_m |= HFCD_MASTER;\r\ncs->writeisac(cs, HFCD_MST_MODE, cs->hw.hfcD.mst_m);\r\ncs->writeisac(cs, HFCD_STATES, HFCD_ACTIVATE | HFCD_DO_ACTION);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nl1_msg(cs, HW_POWERUP | CONFIRM, NULL);\r\nbreak;\r\ncase (HW_ENABLE | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->writeisac(cs, HFCD_STATES, HFCD_ACTIVATE | HFCD_DO_ACTION);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_DEACTIVATE | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcD.mst_m &= ~HFCD_MASTER;\r\ncs->writeisac(cs, HFCD_MST_MODE, cs->hw.hfcD.mst_m);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_INFO3 | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcD.mst_m |= HFCD_MASTER;\r\ncs->writeisac(cs, HFCD_MST_MODE, cs->hw.hfcD.mst_m);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfcd_l1hw unknown pr %4x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nsetstack_hfcd(struct PStack *st, struct IsdnCardState *cs)\r\n{\r\nst->l1.l1hw = HFCD_l1hw;\r\n}\r\nstatic void\r\nhfc_dbusy_timer(struct IsdnCardState *cs)\r\n{\r\n}\r\nstatic unsigned int\r\n*init_send_hfcd(int cnt)\r\n{\r\nint i;\r\nunsigned *send;\r\nif (!(send = kmalloc(cnt * sizeof(unsigned int), GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax: No memory for hfcd.send\n");\r\nreturn (NULL);\r\n}\r\nfor (i = 0; i < cnt; i++)\r\nsend[i] = 0x1fff;\r\nreturn (send);\r\n}\r\nvoid\r\ninit2bds0(struct IsdnCardState *cs)\r\n{\r\ncs->setstack_d = setstack_hfcd;\r\nif (!cs->hw.hfcD.send)\r\ncs->hw.hfcD.send = init_send_hfcd(16);\r\nif (!cs->bcs[0].hw.hfc.send)\r\ncs->bcs[0].hw.hfc.send = init_send_hfcd(32);\r\nif (!cs->bcs[1].hw.hfc.send)\r\ncs->bcs[1].hw.hfc.send = init_send_hfcd(32);\r\ncs->BC_Send_Data = &hfc_send_data;\r\ncs->bcs[0].BC_SetStack = setstack_2b;\r\ncs->bcs[1].BC_SetStack = setstack_2b;\r\ncs->bcs[0].BC_Close = close_2bs0;\r\ncs->bcs[1].BC_Close = close_2bs0;\r\nmode_2bs0(cs->bcs, 0, 0);\r\nmode_2bs0(cs->bcs + 1, 0, 1);\r\n}\r\nvoid\r\nrelease2bds0(struct IsdnCardState *cs)\r\n{\r\nkfree(cs->bcs[0].hw.hfc.send);\r\ncs->bcs[0].hw.hfc.send = NULL;\r\nkfree(cs->bcs[1].hw.hfc.send);\r\ncs->bcs[1].hw.hfc.send = NULL;\r\nkfree(cs->hw.hfcD.send);\r\ncs->hw.hfcD.send = NULL;\r\n}\r\nvoid\r\nset_cs_func(struct IsdnCardState *cs)\r\n{\r\ncs->readisac = &readreghfcd;\r\ncs->writeisac = &writereghfcd;\r\ncs->readisacfifo = &dummyf;\r\ncs->writeisacfifo = &dummyf;\r\ncs->BC_Read_Reg = &ReadReg;\r\ncs->BC_Write_Reg = &WriteReg;\r\ncs->dbusytimer.function = (void *) hfc_dbusy_timer;\r\ncs->dbusytimer.data = (long) cs;\r\ninit_timer(&cs->dbusytimer);\r\nINIT_WORK(&cs->tqueue, hfcd_bh);\r\n}
