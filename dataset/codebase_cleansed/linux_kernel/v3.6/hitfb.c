static inline void hitfb_accel_wait(void)\r\n{\r\nwhile (fb_readw(HD64461_GRCFGR) & HD64461_GRCFGR_ACCSTATUS) ;\r\n}\r\nstatic inline void hitfb_accel_start(int truecolor)\r\n{\r\nif (truecolor) {\r\nfb_writew(6, HD64461_GRCFGR);\r\n} else {\r\nfb_writew(7, HD64461_GRCFGR);\r\n}\r\n}\r\nstatic inline void hitfb_accel_set_dest(int truecolor, u16 dx, u16 dy,\r\nu16 width, u16 height)\r\n{\r\nu32 saddr = WIDTH * dy + dx;\r\nif (truecolor)\r\nsaddr <<= 1;\r\nfb_writew(width-1, HD64461_BBTDWR);\r\nfb_writew(height-1, HD64461_BBTDHR);\r\nfb_writew(saddr & 0xffff, HD64461_BBTDSARL);\r\nfb_writew(saddr >> 16, HD64461_BBTDSARH);\r\n}\r\nstatic inline void hitfb_accel_bitblt(int truecolor, u16 sx, u16 sy, u16 dx,\r\nu16 dy, u16 width, u16 height, u16 rop,\r\nu32 mask_addr)\r\n{\r\nu32 saddr, daddr;\r\nu32 maddr = 0;\r\nheight--;\r\nwidth--;\r\nfb_writew(rop, HD64461_BBTROPR);\r\nif ((sy < dy) || ((sy == dy) && (sx <= dx))) {\r\nsaddr = WIDTH * (sy + height) + sx + width;\r\ndaddr = WIDTH * (dy + height) + dx + width;\r\nif (mask_addr) {\r\nif (truecolor)\r\nmaddr = ((width >> 3) + 1) * (height + 1) - 1;\r\nelse\r\nmaddr =\r\n(((width >> 4) + 1) * (height + 1) - 1) * 2;\r\nfb_writew((1 << 5) | 1, HD64461_BBTMDR);\r\n} else\r\nfb_writew(1, HD64461_BBTMDR);\r\n} else {\r\nsaddr = WIDTH * sy + sx;\r\ndaddr = WIDTH * dy + dx;\r\nif (mask_addr) {\r\nfb_writew((1 << 5), HD64461_BBTMDR);\r\n} else {\r\nfb_writew(0, HD64461_BBTMDR);\r\n}\r\n}\r\nif (truecolor) {\r\nsaddr <<= 1;\r\ndaddr <<= 1;\r\n}\r\nfb_writew(width, HD64461_BBTDWR);\r\nfb_writew(height, HD64461_BBTDHR);\r\nfb_writew(saddr & 0xffff, HD64461_BBTSSARL);\r\nfb_writew(saddr >> 16, HD64461_BBTSSARH);\r\nfb_writew(daddr & 0xffff, HD64461_BBTDSARL);\r\nfb_writew(daddr >> 16, HD64461_BBTDSARH);\r\nif (mask_addr) {\r\nmaddr += mask_addr;\r\nfb_writew(maddr & 0xffff, HD64461_BBTMARL);\r\nfb_writew(maddr >> 16, HD64461_BBTMARH);\r\n}\r\nhitfb_accel_start(truecolor);\r\n}\r\nstatic void hitfb_fillrect(struct fb_info *p, const struct fb_fillrect *rect)\r\n{\r\nif (rect->rop != ROP_COPY)\r\ncfb_fillrect(p, rect);\r\nelse {\r\nhitfb_accel_wait();\r\nfb_writew(0x00f0, HD64461_BBTROPR);\r\nfb_writew(16, HD64461_BBTMDR);\r\nif (p->var.bits_per_pixel == 16) {\r\nfb_writew(((u32 *) (p->pseudo_palette))[rect->color],\r\nHD64461_GRSCR);\r\nhitfb_accel_set_dest(1, rect->dx, rect->dy, rect->width,\r\nrect->height);\r\nhitfb_accel_start(1);\r\n} else {\r\nfb_writew(rect->color, HD64461_GRSCR);\r\nhitfb_accel_set_dest(0, rect->dx, rect->dy, rect->width,\r\nrect->height);\r\nhitfb_accel_start(0);\r\n}\r\n}\r\n}\r\nstatic void hitfb_copyarea(struct fb_info *p, const struct fb_copyarea *area)\r\n{\r\nhitfb_accel_wait();\r\nhitfb_accel_bitblt(p->var.bits_per_pixel == 16, area->sx, area->sy,\r\narea->dx, area->dy, area->width, area->height,\r\n0x00cc, 0);\r\n}\r\nstatic int hitfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint xoffset = var->xoffset;\r\nint yoffset = var->yoffset;\r\nif (xoffset != 0)\r\nreturn -EINVAL;\r\nfb_writew((yoffset*info->fix.line_length)>>10, HD64461_LCDCBAR);\r\nreturn 0;\r\n}\r\nint hitfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nunsigned short v;\r\nif (blank_mode) {\r\nv = fb_readw(HD64461_LDR1);\r\nv &= ~HD64461_LDR1_DON;\r\nfb_writew(v, HD64461_LDR1);\r\nv = fb_readw(HD64461_LCDCCR);\r\nv |= HD64461_LCDCCR_MOFF;\r\nfb_writew(v, HD64461_LCDCCR);\r\nv = fb_readw(HD64461_STBCR);\r\nv |= HD64461_STBCR_SLCDST;\r\nfb_writew(v, HD64461_STBCR);\r\n} else {\r\nv = fb_readw(HD64461_STBCR);\r\nv &= ~HD64461_STBCR_SLCDST;\r\nfb_writew(v, HD64461_STBCR);\r\nv = fb_readw(HD64461_LCDCCR);\r\nv &= ~(HD64461_LCDCCR_MOFF | HD64461_LCDCCR_STREQ);\r\nfb_writew(v, HD64461_LCDCCR);\r\ndo {\r\nv = fb_readw(HD64461_LCDCCR);\r\n} while(v&HD64461_LCDCCR_STBACK);\r\nv = fb_readw(HD64461_LDR1);\r\nv |= HD64461_LDR1_DON;\r\nfb_writew(v, HD64461_LDR1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hitfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *info)\r\n{\r\nif (regno >= 256)\r\nreturn 1;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nfb_writew(regno << 8, HD64461_CPTWAR);\r\nfb_writew(red >> 10, HD64461_CPTWDR);\r\nfb_writew(green >> 10, HD64461_CPTWDR);\r\nfb_writew(blue >> 10, HD64461_CPTWDR);\r\nbreak;\r\ncase 16:\r\nif (regno >= 16)\r\nreturn 1;\r\n((u32 *) (info->pseudo_palette))[regno] =\r\n((red & 0xf800)) |\r\n((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hitfb_sync(struct fb_info *info)\r\n{\r\nhitfb_accel_wait();\r\nreturn 0;\r\n}\r\nstatic int hitfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nint maxy;\r\nvar->xres = info->var.xres;\r\nvar->xres_virtual = info->var.xres;\r\nvar->yres = info->var.yres;\r\nif ((var->bits_per_pixel != 8) && (var->bits_per_pixel != 16))\r\nvar->bits_per_pixel = info->var.bits_per_pixel;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nmaxy = info->fix.smem_len / var->xres;\r\nif (var->bits_per_pixel == 16)\r\nmaxy /= 2;\r\nif (var->yres_virtual > maxy)\r\nvar->yres_virtual = maxy;\r\nvar->xoffset = 0;\r\nvar->yoffset = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hitfb_set_par(struct fb_info *info)\r\n{\r\nunsigned short ldr3;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\ninfo->fix.line_length = info->var.xres;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.ypanstep = 16;\r\nbreak;\r\ncase 16:\r\ninfo->fix.line_length = info->var.xres*2;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.ypanstep = 8;\r\nbreak;\r\n}\r\nfb_writew(info->fix.line_length, HD64461_LCDCLOR);\r\nldr3 = fb_readw(HD64461_LDR3);\r\nldr3 &= ~15;\r\nldr3 |= (info->var.bits_per_pixel == 8) ? 4 : 8;\r\nfb_writew(ldr3, HD64461_LDR3);\r\nreturn 0;\r\n}\r\nstatic int __devinit hitfb_probe(struct platform_device *dev)\r\n{\r\nunsigned short lcdclor, ldr3, ldvndr;\r\nstruct fb_info *info;\r\nint ret;\r\nif (fb_get_options("hitfb", NULL))\r\nreturn -ENODEV;\r\nhitfb_fix.mmio_start = HD64461_IO_OFFSET(0x1000);\r\nhitfb_fix.mmio_len = 0x1000;\r\nhitfb_fix.smem_start = HD64461_IO_OFFSET(0x02000000);\r\nhitfb_fix.smem_len = 512 * 1024;\r\nlcdclor = fb_readw(HD64461_LCDCLOR);\r\nldvndr = fb_readw(HD64461_LDVNDR);\r\nldr3 = fb_readw(HD64461_LDR3);\r\nswitch (ldr3 & 15) {\r\ndefault:\r\ncase 4:\r\nhitfb_var.bits_per_pixel = 8;\r\nhitfb_var.xres = lcdclor;\r\nbreak;\r\ncase 8:\r\nhitfb_var.bits_per_pixel = 16;\r\nhitfb_var.xres = lcdclor / 2;\r\nbreak;\r\n}\r\nhitfb_fix.line_length = lcdclor;\r\nhitfb_fix.visual = (hitfb_var.bits_per_pixel == 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\nhitfb_var.yres = ldvndr + 1;\r\nhitfb_var.xres_virtual = hitfb_var.xres;\r\nhitfb_var.yres_virtual = hitfb_fix.smem_len / lcdclor;\r\nswitch (hitfb_var.bits_per_pixel) {\r\ncase 8:\r\nhitfb_var.red.offset = 0;\r\nhitfb_var.red.length = 8;\r\nhitfb_var.green.offset = 0;\r\nhitfb_var.green.length = 8;\r\nhitfb_var.blue.offset = 0;\r\nhitfb_var.blue.length = 8;\r\nhitfb_var.transp.offset = 0;\r\nhitfb_var.transp.length = 0;\r\nbreak;\r\ncase 16:\r\nhitfb_var.red.offset = 11;\r\nhitfb_var.red.length = 5;\r\nhitfb_var.green.offset = 5;\r\nhitfb_var.green.length = 6;\r\nhitfb_var.blue.offset = 0;\r\nhitfb_var.blue.length = 5;\r\nhitfb_var.transp.offset = 0;\r\nhitfb_var.transp.length = 0;\r\nbreak;\r\n}\r\ninfo = framebuffer_alloc(sizeof(u32) * 16, &dev->dev);\r\nif (unlikely(!info))\r\nreturn -ENOMEM;\r\ninfo->fbops = &hitfb_ops;\r\ninfo->var = hitfb_var;\r\ninfo->fix = hitfb_fix;\r\ninfo->pseudo_palette = info->par;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN |\r\nFBINFO_HWACCEL_FILLRECT | FBINFO_HWACCEL_COPYAREA;\r\ninfo->screen_base = (void *)hitfb_fix.smem_start;\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (unlikely(ret < 0))\r\ngoto err_fb;\r\nret = register_framebuffer(info);\r\nif (unlikely(ret < 0))\r\ngoto err;\r\nplatform_set_drvdata(dev, info);\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\nreturn 0;\r\nerr:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_fb:\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int __devexit hitfb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int hitfb_suspend(struct device *dev)\r\n{\r\nu16 v;\r\nhitfb_blank(1,0);\r\nv = fb_readw(HD64461_STBCR);\r\nv |= HD64461_STBCR_SLCKE_IST;\r\nfb_writew(v, HD64461_STBCR);\r\nreturn 0;\r\n}\r\nstatic int hitfb_resume(struct device *dev)\r\n{\r\nu16 v;\r\nv = fb_readw(HD64461_STBCR);\r\nv &= ~HD64461_STBCR_SLCKE_OST;\r\nmsleep(100);\r\nv = fb_readw(HD64461_STBCR);\r\nv &= ~HD64461_STBCR_SLCKE_IST;\r\nfb_writew(v, HD64461_STBCR);\r\nhitfb_blank(0,0);\r\nreturn 0;\r\n}\r\nstatic int __init hitfb_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&hitfb_driver);\r\nif (!ret) {\r\nret = platform_device_register(&hitfb_device);\r\nif (ret)\r\nplatform_driver_unregister(&hitfb_driver);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit hitfb_exit(void)\r\n{\r\nplatform_device_unregister(&hitfb_device);\r\nplatform_driver_unregister(&hitfb_driver);\r\n}
