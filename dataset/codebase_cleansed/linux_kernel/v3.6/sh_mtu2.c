static inline unsigned long sh_mtu2_read(struct sh_mtu2_priv *p, int reg_nr)\r\n{\r\nstruct sh_timer_config *cfg = p->pdev->dev.platform_data;\r\nvoid __iomem *base = p->mapbase;\r\nunsigned long offs;\r\nif (reg_nr == TSTR)\r\nreturn ioread8(base + cfg->channel_offset);\r\noffs = mtu2_reg_offs[reg_nr];\r\nif ((reg_nr == TCNT) || (reg_nr == TGR))\r\nreturn ioread16(base + offs);\r\nelse\r\nreturn ioread8(base + offs);\r\n}\r\nstatic inline void sh_mtu2_write(struct sh_mtu2_priv *p, int reg_nr,\r\nunsigned long value)\r\n{\r\nstruct sh_timer_config *cfg = p->pdev->dev.platform_data;\r\nvoid __iomem *base = p->mapbase;\r\nunsigned long offs;\r\nif (reg_nr == TSTR) {\r\niowrite8(value, base + cfg->channel_offset);\r\nreturn;\r\n}\r\noffs = mtu2_reg_offs[reg_nr];\r\nif ((reg_nr == TCNT) || (reg_nr == TGR))\r\niowrite16(value, base + offs);\r\nelse\r\niowrite8(value, base + offs);\r\n}\r\nstatic void sh_mtu2_start_stop_ch(struct sh_mtu2_priv *p, int start)\r\n{\r\nstruct sh_timer_config *cfg = p->pdev->dev.platform_data;\r\nunsigned long flags, value;\r\nraw_spin_lock_irqsave(&sh_mtu2_lock, flags);\r\nvalue = sh_mtu2_read(p, TSTR);\r\nif (start)\r\nvalue |= 1 << cfg->timer_bit;\r\nelse\r\nvalue &= ~(1 << cfg->timer_bit);\r\nsh_mtu2_write(p, TSTR, value);\r\nraw_spin_unlock_irqrestore(&sh_mtu2_lock, flags);\r\n}\r\nstatic int sh_mtu2_enable(struct sh_mtu2_priv *p)\r\n{\r\nint ret;\r\nret = clk_enable(p->clk);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "cannot enable clock\n");\r\nreturn ret;\r\n}\r\nsh_mtu2_start_stop_ch(p, 0);\r\np->rate = clk_get_rate(p->clk) / 64;\r\np->periodic = (p->rate + HZ/2) / HZ;\r\nsh_mtu2_write(p, TCR, 0x23);\r\nsh_mtu2_write(p, TIOR, 0);\r\nsh_mtu2_write(p, TGR, p->periodic);\r\nsh_mtu2_write(p, TCNT, 0);\r\nsh_mtu2_write(p, TMDR, 0);\r\nsh_mtu2_write(p, TIER, 0x01);\r\nsh_mtu2_start_stop_ch(p, 1);\r\nreturn 0;\r\n}\r\nstatic void sh_mtu2_disable(struct sh_mtu2_priv *p)\r\n{\r\nsh_mtu2_start_stop_ch(p, 0);\r\nclk_disable(p->clk);\r\n}\r\nstatic irqreturn_t sh_mtu2_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sh_mtu2_priv *p = dev_id;\r\nsh_mtu2_read(p, TSR);\r\nsh_mtu2_write(p, TSR, 0xfe);\r\np->ced.event_handler(&p->ced);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct sh_mtu2_priv *ced_to_sh_mtu2(struct clock_event_device *ced)\r\n{\r\nreturn container_of(ced, struct sh_mtu2_priv, ced);\r\n}\r\nstatic void sh_mtu2_clock_event_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct sh_mtu2_priv *p = ced_to_sh_mtu2(ced);\r\nint disabled = 0;\r\nswitch (ced->mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nsh_mtu2_disable(p);\r\ndisabled = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\ndev_info(&p->pdev->dev, "used for periodic clock events\n");\r\nsh_mtu2_enable(p);\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\nif (!disabled)\r\nsh_mtu2_disable(p);\r\nbreak;\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sh_mtu2_register_clockevent(struct sh_mtu2_priv *p,\r\nchar *name, unsigned long rating)\r\n{\r\nstruct clock_event_device *ced = &p->ced;\r\nint ret;\r\nmemset(ced, 0, sizeof(*ced));\r\nced->name = name;\r\nced->features = CLOCK_EVT_FEAT_PERIODIC;\r\nced->rating = rating;\r\nced->cpumask = cpumask_of(0);\r\nced->set_mode = sh_mtu2_clock_event_mode;\r\ndev_info(&p->pdev->dev, "used for clock events\n");\r\nclockevents_register_device(ced);\r\nret = setup_irq(p->irqaction.irq, &p->irqaction);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "failed to request irq %d\n",\r\np->irqaction.irq);\r\nreturn;\r\n}\r\n}\r\nstatic int sh_mtu2_register(struct sh_mtu2_priv *p, char *name,\r\nunsigned long clockevent_rating)\r\n{\r\nif (clockevent_rating)\r\nsh_mtu2_register_clockevent(p, name, clockevent_rating);\r\nreturn 0;\r\n}\r\nstatic int sh_mtu2_setup(struct sh_mtu2_priv *p, struct platform_device *pdev)\r\n{\r\nstruct sh_timer_config *cfg = pdev->dev.platform_data;\r\nstruct resource *res;\r\nint irq, ret;\r\nret = -ENXIO;\r\nmemset(p, 0, sizeof(*p));\r\np->pdev = pdev;\r\nif (!cfg) {\r\ndev_err(&p->pdev->dev, "missing platform data\n");\r\ngoto err0;\r\n}\r\nplatform_set_drvdata(pdev, p);\r\nres = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&p->pdev->dev, "failed to get I/O memory\n");\r\ngoto err0;\r\n}\r\nirq = platform_get_irq(p->pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&p->pdev->dev, "failed to get irq\n");\r\ngoto err0;\r\n}\r\np->mapbase = ioremap_nocache(res->start, resource_size(res));\r\nif (p->mapbase == NULL) {\r\ndev_err(&p->pdev->dev, "failed to remap I/O memory\n");\r\ngoto err0;\r\n}\r\np->irqaction.name = dev_name(&p->pdev->dev);\r\np->irqaction.handler = sh_mtu2_interrupt;\r\np->irqaction.dev_id = p;\r\np->irqaction.irq = irq;\r\np->irqaction.flags = IRQF_DISABLED | IRQF_TIMER | \\r\nIRQF_IRQPOLL | IRQF_NOBALANCING;\r\np->clk = clk_get(&p->pdev->dev, "mtu2_fck");\r\nif (IS_ERR(p->clk)) {\r\ndev_err(&p->pdev->dev, "cannot get clock\n");\r\nret = PTR_ERR(p->clk);\r\ngoto err1;\r\n}\r\nreturn sh_mtu2_register(p, (char *)dev_name(&p->pdev->dev),\r\ncfg->clockevent_rating);\r\nerr1:\r\niounmap(p->mapbase);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int __devinit sh_mtu2_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mtu2_priv *p = platform_get_drvdata(pdev);\r\nint ret;\r\nif (!is_early_platform_device(pdev))\r\npm_genpd_dev_always_on(&pdev->dev, true);\r\nif (p) {\r\ndev_info(&pdev->dev, "kept as earlytimer\n");\r\nreturn 0;\r\n}\r\np = kmalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\nret = sh_mtu2_setup(p, pdev);\r\nif (ret) {\r\nkfree(p);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devexit sh_mtu2_remove(struct platform_device *pdev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __init sh_mtu2_init(void)\r\n{\r\nreturn platform_driver_register(&sh_mtu2_device_driver);\r\n}\r\nstatic void __exit sh_mtu2_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_mtu2_device_driver);\r\n}
