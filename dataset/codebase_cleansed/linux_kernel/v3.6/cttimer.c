static void ct_systimer_callback(unsigned long data)\r\n{\r\nstruct ct_timer_instance *ti = (struct ct_timer_instance *)data;\r\nstruct snd_pcm_substream *substream = ti->substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct ct_atc_pcm *apcm = ti->apcm;\r\nunsigned int period_size = runtime->period_size;\r\nunsigned int buffer_size = runtime->buffer_size;\r\nunsigned long flags;\r\nunsigned int position, dist, interval;\r\nposition = substream->ops->pointer(substream);\r\ndist = (position + buffer_size - ti->position) % buffer_size;\r\nif (dist >= period_size ||\r\nposition / period_size != ti->position / period_size) {\r\napcm->interrupt(apcm);\r\nti->position = position;\r\n}\r\ninterval = ((period_size - (position % period_size))\r\n* HZ + (runtime->rate - 1)) / runtime->rate + HZ * 5 / 1000;\r\nspin_lock_irqsave(&ti->lock, flags);\r\nif (ti->running)\r\nmod_timer(&ti->timer, jiffies + interval);\r\nspin_unlock_irqrestore(&ti->lock, flags);\r\n}\r\nstatic void ct_systimer_init(struct ct_timer_instance *ti)\r\n{\r\nsetup_timer(&ti->timer, ct_systimer_callback,\r\n(unsigned long)ti);\r\n}\r\nstatic void ct_systimer_start(struct ct_timer_instance *ti)\r\n{\r\nstruct snd_pcm_runtime *runtime = ti->substream->runtime;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ti->lock, flags);\r\nti->running = 1;\r\nmod_timer(&ti->timer,\r\njiffies + (runtime->period_size * HZ +\r\n(runtime->rate - 1)) / runtime->rate);\r\nspin_unlock_irqrestore(&ti->lock, flags);\r\n}\r\nstatic void ct_systimer_stop(struct ct_timer_instance *ti)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ti->lock, flags);\r\nti->running = 0;\r\ndel_timer(&ti->timer);\r\nspin_unlock_irqrestore(&ti->lock, flags);\r\n}\r\nstatic void ct_systimer_prepare(struct ct_timer_instance *ti)\r\n{\r\nct_systimer_stop(ti);\r\ntry_to_del_timer_sync(&ti->timer);\r\n}\r\nstatic void ct_xfitimer_irq_rearm(struct ct_timer *atimer, int ticks)\r\n{\r\nstruct hw *hw = atimer->atc->hw;\r\nif (ticks > MAX_TICKS)\r\nticks = MAX_TICKS;\r\nhw->set_timer_tick(hw, ticks);\r\nif (!atimer->running)\r\nhw->set_timer_irq(hw, 1);\r\natimer->running = 1;\r\n}\r\nstatic void ct_xfitimer_irq_stop(struct ct_timer *atimer)\r\n{\r\nif (atimer->running) {\r\nstruct hw *hw = atimer->atc->hw;\r\nhw->set_timer_irq(hw, 0);\r\nhw->set_timer_tick(hw, 0);\r\natimer->running = 0;\r\n}\r\n}\r\nstatic inline unsigned int ct_xfitimer_get_wc(struct ct_timer *atimer)\r\n{\r\nstruct hw *hw = atimer->atc->hw;\r\nreturn hw->get_wc(hw);\r\n}\r\nstatic int ct_xfitimer_reprogram(struct ct_timer *atimer, int can_update)\r\n{\r\nstruct ct_timer_instance *ti;\r\nunsigned int min_intr = (unsigned int)-1;\r\nint updates = 0;\r\nunsigned int wc, diff;\r\nif (list_empty(&atimer->running_head)) {\r\nct_xfitimer_irq_stop(atimer);\r\natimer->reprogram = 0;\r\nreturn 0;\r\n}\r\nwc = ct_xfitimer_get_wc(atimer);\r\ndiff = wc - atimer->wc;\r\natimer->wc = wc;\r\nlist_for_each_entry(ti, &atimer->running_head, running_list) {\r\nif (ti->frag_count > diff)\r\nti->frag_count -= diff;\r\nelse {\r\nunsigned int pos;\r\nunsigned int period_size, rate;\r\nperiod_size = ti->substream->runtime->period_size;\r\nrate = ti->substream->runtime->rate;\r\npos = ti->substream->ops->pointer(ti->substream);\r\nif (pos / period_size != ti->position / period_size) {\r\nti->need_update = 1;\r\nti->position = pos;\r\nupdates++;\r\n}\r\npos %= period_size;\r\npos = period_size - pos;\r\nti->frag_count = div_u64((u64)pos * CT_TIMER_FREQ +\r\nrate - 1, rate);\r\n}\r\nif (ti->need_update && !can_update)\r\nmin_intr = 0;\r\nif (ti->frag_count < min_intr)\r\nmin_intr = ti->frag_count;\r\n}\r\nif (min_intr < MIN_TICKS)\r\nmin_intr = MIN_TICKS;\r\nct_xfitimer_irq_rearm(atimer, min_intr);\r\natimer->reprogram = 0;\r\nreturn updates;\r\n}\r\nstatic void ct_xfitimer_check_period(struct ct_timer *atimer)\r\n{\r\nstruct ct_timer_instance *ti;\r\nunsigned long flags;\r\nspin_lock_irqsave(&atimer->list_lock, flags);\r\nlist_for_each_entry(ti, &atimer->instance_head, instance_list) {\r\nif (ti->running && ti->need_update) {\r\nti->need_update = 0;\r\nti->apcm->interrupt(ti->apcm);\r\n}\r\n}\r\nspin_unlock_irqrestore(&atimer->list_lock, flags);\r\n}\r\nstatic void ct_xfitimer_callback(struct ct_timer *atimer)\r\n{\r\nint update;\r\nunsigned long flags;\r\nspin_lock_irqsave(&atimer->lock, flags);\r\natimer->irq_handling = 1;\r\ndo {\r\nupdate = ct_xfitimer_reprogram(atimer, 1);\r\nspin_unlock(&atimer->lock);\r\nif (update)\r\nct_xfitimer_check_period(atimer);\r\nspin_lock(&atimer->lock);\r\n} while (atimer->reprogram);\r\natimer->irq_handling = 0;\r\nspin_unlock_irqrestore(&atimer->lock, flags);\r\n}\r\nstatic void ct_xfitimer_prepare(struct ct_timer_instance *ti)\r\n{\r\nti->frag_count = ti->substream->runtime->period_size;\r\nti->running = 0;\r\nti->need_update = 0;\r\n}\r\nstatic void ct_xfitimer_update(struct ct_timer *atimer)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&atimer->lock, flags);\r\nif (atimer->irq_handling) {\r\natimer->reprogram = 1;\r\nspin_unlock_irqrestore(&atimer->lock, flags);\r\nreturn;\r\n}\r\nct_xfitimer_irq_stop(atimer);\r\nct_xfitimer_reprogram(atimer, 0);\r\nspin_unlock_irqrestore(&atimer->lock, flags);\r\n}\r\nstatic void ct_xfitimer_start(struct ct_timer_instance *ti)\r\n{\r\nstruct ct_timer *atimer = ti->timer_base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&atimer->lock, flags);\r\nif (list_empty(&ti->running_list))\r\natimer->wc = ct_xfitimer_get_wc(atimer);\r\nti->running = 1;\r\nti->need_update = 0;\r\nlist_add(&ti->running_list, &atimer->running_head);\r\nspin_unlock_irqrestore(&atimer->lock, flags);\r\nct_xfitimer_update(atimer);\r\n}\r\nstatic void ct_xfitimer_stop(struct ct_timer_instance *ti)\r\n{\r\nstruct ct_timer *atimer = ti->timer_base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&atimer->lock, flags);\r\nlist_del_init(&ti->running_list);\r\nti->running = 0;\r\nspin_unlock_irqrestore(&atimer->lock, flags);\r\nct_xfitimer_update(atimer);\r\n}\r\nstatic void ct_xfitimer_free_global(struct ct_timer *atimer)\r\n{\r\nct_xfitimer_irq_stop(atimer);\r\n}\r\nstruct ct_timer_instance *\r\nct_timer_instance_new(struct ct_timer *atimer, struct ct_atc_pcm *apcm)\r\n{\r\nstruct ct_timer_instance *ti;\r\nti = kzalloc(sizeof(*ti), GFP_KERNEL);\r\nif (!ti)\r\nreturn NULL;\r\nspin_lock_init(&ti->lock);\r\nINIT_LIST_HEAD(&ti->instance_list);\r\nINIT_LIST_HEAD(&ti->running_list);\r\nti->timer_base = atimer;\r\nti->apcm = apcm;\r\nti->substream = apcm->substream;\r\nif (atimer->ops->init)\r\natimer->ops->init(ti);\r\nspin_lock_irq(&atimer->list_lock);\r\nlist_add(&ti->instance_list, &atimer->instance_head);\r\nspin_unlock_irq(&atimer->list_lock);\r\nreturn ti;\r\n}\r\nvoid ct_timer_prepare(struct ct_timer_instance *ti)\r\n{\r\nif (ti->timer_base->ops->prepare)\r\nti->timer_base->ops->prepare(ti);\r\nti->position = 0;\r\nti->running = 0;\r\n}\r\nvoid ct_timer_start(struct ct_timer_instance *ti)\r\n{\r\nstruct ct_timer *atimer = ti->timer_base;\r\natimer->ops->start(ti);\r\n}\r\nvoid ct_timer_stop(struct ct_timer_instance *ti)\r\n{\r\nstruct ct_timer *atimer = ti->timer_base;\r\natimer->ops->stop(ti);\r\n}\r\nvoid ct_timer_instance_free(struct ct_timer_instance *ti)\r\n{\r\nstruct ct_timer *atimer = ti->timer_base;\r\natimer->ops->stop(ti);\r\nif (atimer->ops->free_instance)\r\natimer->ops->free_instance(ti);\r\nspin_lock_irq(&atimer->list_lock);\r\nlist_del(&ti->instance_list);\r\nspin_unlock_irq(&atimer->list_lock);\r\nkfree(ti);\r\n}\r\nstatic void ct_timer_interrupt(void *data, unsigned int status)\r\n{\r\nstruct ct_timer *timer = data;\r\nif ((status & IT_INT) && timer->ops->interrupt)\r\ntimer->ops->interrupt(timer);\r\n}\r\nstruct ct_timer *ct_timer_new(struct ct_atc *atc)\r\n{\r\nstruct ct_timer *atimer;\r\nstruct hw *hw;\r\natimer = kzalloc(sizeof(*atimer), GFP_KERNEL);\r\nif (!atimer)\r\nreturn NULL;\r\nspin_lock_init(&atimer->lock);\r\nspin_lock_init(&atimer->list_lock);\r\nINIT_LIST_HEAD(&atimer->instance_head);\r\nINIT_LIST_HEAD(&atimer->running_head);\r\natimer->atc = atc;\r\nhw = atc->hw;\r\nif (!use_system_timer && hw->set_timer_irq) {\r\nsnd_printd(KERN_INFO "ctxfi: Use xfi-native timer\n");\r\natimer->ops = &ct_xfitimer_ops;\r\nhw->irq_callback_data = atimer;\r\nhw->irq_callback = ct_timer_interrupt;\r\n} else {\r\nsnd_printd(KERN_INFO "ctxfi: Use system timer\n");\r\natimer->ops = &ct_systimer_ops;\r\n}\r\nreturn atimer;\r\n}\r\nvoid ct_timer_free(struct ct_timer *atimer)\r\n{\r\nstruct hw *hw = atimer->atc->hw;\r\nhw->irq_callback = NULL;\r\nif (atimer->ops->free_global)\r\natimer->ops->free_global(atimer);\r\nkfree(atimer);\r\n}
