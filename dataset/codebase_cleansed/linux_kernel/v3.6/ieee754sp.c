int ieee754sp_class(ieee754sp x)\r\n{\r\nCOMPXSP;\r\nEXPLODEXSP;\r\nreturn xc;\r\n}\r\nint ieee754sp_isnan(ieee754sp x)\r\n{\r\nreturn ieee754sp_class(x) >= IEEE754_CLASS_SNAN;\r\n}\r\nint ieee754sp_issnan(ieee754sp x)\r\n{\r\nassert(ieee754sp_isnan(x));\r\nreturn (SPMANT(x) & SP_MBIT(SP_MBITS-1));\r\n}\r\nieee754sp ieee754sp_xcpt(ieee754sp r, const char *op, ...)\r\n{\r\nstruct ieee754xctx ax;\r\nif (!TSTX())\r\nreturn r;\r\nax.op = op;\r\nax.rt = IEEE754_RT_SP;\r\nax.rv.sp = r;\r\nva_start(ax.ap, op);\r\nieee754_xcpt(&ax);\r\nva_end(ax.ap);\r\nreturn ax.rv.sp;\r\n}\r\nieee754sp ieee754sp_nanxcpt(ieee754sp r, const char *op, ...)\r\n{\r\nstruct ieee754xctx ax;\r\nassert(ieee754sp_isnan(r));\r\nif (!ieee754sp_issnan(r))\r\nreturn r;\r\nif (!SETANDTESTCX(IEEE754_INVALID_OPERATION)) {\r\nSPMANT(r) &= (~SP_MBIT(SP_MBITS-1));\r\nif (ieee754sp_isnan(r))\r\nreturn r;\r\nelse\r\nreturn ieee754sp_indef();\r\n}\r\nax.op = op;\r\nax.rt = 0;\r\nax.rv.sp = r;\r\nva_start(ax.ap, op);\r\nieee754_xcpt(&ax);\r\nva_end(ax.ap);\r\nreturn ax.rv.sp;\r\n}\r\nieee754sp ieee754sp_bestnan(ieee754sp x, ieee754sp y)\r\n{\r\nassert(ieee754sp_isnan(x));\r\nassert(ieee754sp_isnan(y));\r\nif (SPMANT(x) > SPMANT(y))\r\nreturn x;\r\nelse\r\nreturn y;\r\n}\r\nstatic unsigned get_rounding(int sn, unsigned xm)\r\n{\r\nif (xm & (SP_MBIT(3) - 1)) {\r\nswitch (ieee754_csr.rm) {\r\ncase IEEE754_RZ:\r\nbreak;\r\ncase IEEE754_RN:\r\nxm += 0x3 + ((xm >> 3) & 1);\r\nbreak;\r\ncase IEEE754_RU:\r\nif (!sn)\r\nxm += 0x8;\r\nbreak;\r\ncase IEEE754_RD:\r\nif (sn)\r\nxm += 0x8;\r\nbreak;\r\n}\r\n}\r\nreturn xm;\r\n}\r\nieee754sp ieee754sp_format(int sn, int xe, unsigned xm)\r\n{\r\nassert(xm);\r\nassert((xm >> (SP_MBITS + 1 + 3)) == 0);\r\nassert(xm & (SP_HIDDEN_BIT << 3));\r\nif (xe < SP_EMIN) {\r\nint es = SP_EMIN - xe;\r\nif (ieee754_csr.nod) {\r\nSETCX(IEEE754_UNDERFLOW);\r\nSETCX(IEEE754_INEXACT);\r\nswitch(ieee754_csr.rm) {\r\ncase IEEE754_RN:\r\ncase IEEE754_RZ:\r\nreturn ieee754sp_zero(sn);\r\ncase IEEE754_RU:\r\nif(sn == 0)\r\nreturn ieee754sp_min(0);\r\nelse\r\nreturn ieee754sp_zero(1);\r\ncase IEEE754_RD:\r\nif(sn == 0)\r\nreturn ieee754sp_zero(0);\r\nelse\r\nreturn ieee754sp_min(1);\r\n}\r\n}\r\nif (xe == SP_EMIN - 1\r\n&& get_rounding(sn, xm) >> (SP_MBITS + 1 + 3))\r\n{\r\nSETCX(IEEE754_INEXACT);\r\nxm = get_rounding(sn, xm);\r\nxm >>= 1;\r\nxm &= ~(SP_MBIT(3) - 1);\r\nxe++;\r\n}\r\nelse {\r\nSPXSRSXn(es);\r\nassert((xm & (SP_HIDDEN_BIT << 3)) == 0);\r\nassert(xe == SP_EMIN);\r\n}\r\n}\r\nif (xm & (SP_MBIT(3) - 1)) {\r\nSETCX(IEEE754_INEXACT);\r\nif ((xm & (SP_HIDDEN_BIT << 3)) == 0) {\r\nSETCX(IEEE754_UNDERFLOW);\r\n}\r\nxm = get_rounding(sn, xm);\r\nif (xm >> (SP_MBITS + 1 + 3)) {\r\nxm >>= 1;\r\nxe++;\r\n}\r\n}\r\nxm >>= 3;\r\nassert((xm >> (SP_MBITS + 1)) == 0);\r\nassert(xe >= SP_EMIN);\r\nif (xe > SP_EMAX) {\r\nSETCX(IEEE754_OVERFLOW);\r\nSETCX(IEEE754_INEXACT);\r\nswitch (ieee754_csr.rm) {\r\ncase IEEE754_RN:\r\nreturn ieee754sp_inf(sn);\r\ncase IEEE754_RZ:\r\nreturn ieee754sp_max(sn);\r\ncase IEEE754_RU:\r\nif (sn == 0)\r\nreturn ieee754sp_inf(0);\r\nelse\r\nreturn ieee754sp_max(1);\r\ncase IEEE754_RD:\r\nif (sn == 0)\r\nreturn ieee754sp_max(0);\r\nelse\r\nreturn ieee754sp_inf(1);\r\n}\r\n}\r\nif ((xm & SP_HIDDEN_BIT) == 0) {\r\nassert(xe == SP_EMIN);\r\nif (ieee754_csr.mx & IEEE754_UNDERFLOW)\r\nSETCX(IEEE754_UNDERFLOW);\r\nreturn buildsp(sn, SP_EMIN - 1 + SP_EBIAS, xm);\r\n} else {\r\nassert((xm >> (SP_MBITS + 1)) == 0);\r\nassert(xm & SP_HIDDEN_BIT);\r\nreturn buildsp(sn, xe + SP_EBIAS, xm & ~SP_HIDDEN_BIT);\r\n}\r\n}
