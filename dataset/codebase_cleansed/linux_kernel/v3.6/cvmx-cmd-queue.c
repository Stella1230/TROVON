static cvmx_cmd_queue_result_t __cvmx_cmd_queue_init_state_ptr(void)\r\n{\r\nchar *alloc_name = "cvmx_cmd_queues";\r\n#if defined(CONFIG_CAVIUM_RESERVE32) && CONFIG_CAVIUM_RESERVE32\r\nextern uint64_t octeon_reserve32_memory;\r\n#endif\r\nif (likely(__cvmx_cmd_queue_state_ptr))\r\nreturn CVMX_CMD_QUEUE_SUCCESS;\r\n#if defined(CONFIG_CAVIUM_RESERVE32) && CONFIG_CAVIUM_RESERVE32\r\nif (octeon_reserve32_memory)\r\n__cvmx_cmd_queue_state_ptr =\r\ncvmx_bootmem_alloc_named_range(sizeof(*__cvmx_cmd_queue_state_ptr),\r\nocteon_reserve32_memory,\r\nocteon_reserve32_memory +\r\n(CONFIG_CAVIUM_RESERVE32 <<\r\n20) - 1, 128, alloc_name);\r\nelse\r\n#endif\r\n__cvmx_cmd_queue_state_ptr =\r\ncvmx_bootmem_alloc_named(sizeof(*__cvmx_cmd_queue_state_ptr),\r\n128,\r\nalloc_name);\r\nif (__cvmx_cmd_queue_state_ptr)\r\nmemset(__cvmx_cmd_queue_state_ptr, 0,\r\nsizeof(*__cvmx_cmd_queue_state_ptr));\r\nelse {\r\nstruct cvmx_bootmem_named_block_desc *block_desc =\r\ncvmx_bootmem_find_named_block(alloc_name);\r\nif (block_desc)\r\n__cvmx_cmd_queue_state_ptr =\r\ncvmx_phys_to_ptr(block_desc->base_addr);\r\nelse {\r\ncvmx_dprintf\r\n("ERROR: cvmx_cmd_queue_initialize: Unable to get named block %s.\n",\r\nalloc_name);\r\nreturn CVMX_CMD_QUEUE_NO_MEMORY;\r\n}\r\n}\r\nreturn CVMX_CMD_QUEUE_SUCCESS;\r\n}\r\ncvmx_cmd_queue_result_t cvmx_cmd_queue_initialize(cvmx_cmd_queue_id_t queue_id,\r\nint max_depth, int fpa_pool,\r\nint pool_size)\r\n{\r\n__cvmx_cmd_queue_state_t *qstate;\r\ncvmx_cmd_queue_result_t result = __cvmx_cmd_queue_init_state_ptr();\r\nif (result != CVMX_CMD_QUEUE_SUCCESS)\r\nreturn result;\r\nqstate = __cvmx_cmd_queue_get_state(queue_id);\r\nif (qstate == NULL)\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\nif (CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH) {\r\nif ((max_depth < 0) || (max_depth > 1 << 20))\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\n} else if (max_depth != 0)\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\nif ((fpa_pool < 0) || (fpa_pool > 7))\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\nif ((pool_size < 128) || (pool_size > 65536))\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\nif (qstate->base_ptr_div128) {\r\nif (max_depth != (int)qstate->max_depth) {\r\ncvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: "\r\n"Queue already initialized with different "\r\n"max_depth (%d).\n",\r\n(int)qstate->max_depth);\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\n}\r\nif (fpa_pool != qstate->fpa_pool) {\r\ncvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: "\r\n"Queue already initialized with different "\r\n"FPA pool (%u).\n",\r\nqstate->fpa_pool);\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\n}\r\nif ((pool_size >> 3) - 1 != qstate->pool_size_m1) {\r\ncvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: "\r\n"Queue already initialized with different "\r\n"FPA pool size (%u).\n",\r\n(qstate->pool_size_m1 + 1) << 3);\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\n}\r\nCVMX_SYNCWS;\r\nreturn CVMX_CMD_QUEUE_ALREADY_SETUP;\r\n} else {\r\nunion cvmx_fpa_ctl_status status;\r\nvoid *buffer;\r\nstatus.u64 = cvmx_read_csr(CVMX_FPA_CTL_STATUS);\r\nif (!status.s.enb) {\r\ncvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: "\r\n"FPA is not enabled.\n");\r\nreturn CVMX_CMD_QUEUE_NO_MEMORY;\r\n}\r\nbuffer = cvmx_fpa_alloc(fpa_pool);\r\nif (buffer == NULL) {\r\ncvmx_dprintf("ERROR: cvmx_cmd_queue_initialize: "\r\n"Unable to allocate initial buffer.\n");\r\nreturn CVMX_CMD_QUEUE_NO_MEMORY;\r\n}\r\nmemset(qstate, 0, sizeof(*qstate));\r\nqstate->max_depth = max_depth;\r\nqstate->fpa_pool = fpa_pool;\r\nqstate->pool_size_m1 = (pool_size >> 3) - 1;\r\nqstate->base_ptr_div128 = cvmx_ptr_to_phys(buffer) / 128;\r\n__cvmx_cmd_queue_state_ptr->\r\nticket[__cvmx_cmd_queue_get_index(queue_id)] = 0;\r\nCVMX_SYNCWS;\r\nreturn CVMX_CMD_QUEUE_SUCCESS;\r\n}\r\n}\r\ncvmx_cmd_queue_result_t cvmx_cmd_queue_shutdown(cvmx_cmd_queue_id_t queue_id)\r\n{\r\n__cvmx_cmd_queue_state_t *qptr = __cvmx_cmd_queue_get_state(queue_id);\r\nif (qptr == NULL) {\r\ncvmx_dprintf("ERROR: cvmx_cmd_queue_shutdown: Unable to "\r\n"get queue information.\n");\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\n}\r\nif (cvmx_cmd_queue_length(queue_id) > 0) {\r\ncvmx_dprintf("ERROR: cvmx_cmd_queue_shutdown: Queue still "\r\n"has data in it.\n");\r\nreturn CVMX_CMD_QUEUE_FULL;\r\n}\r\n__cvmx_cmd_queue_lock(queue_id, qptr);\r\nif (qptr->base_ptr_div128) {\r\ncvmx_fpa_free(cvmx_phys_to_ptr\r\n((uint64_t) qptr->base_ptr_div128 << 7),\r\nqptr->fpa_pool, 0);\r\nqptr->base_ptr_div128 = 0;\r\n}\r\n__cvmx_cmd_queue_unlock(qptr);\r\nreturn CVMX_CMD_QUEUE_SUCCESS;\r\n}\r\nint cvmx_cmd_queue_length(cvmx_cmd_queue_id_t queue_id)\r\n{\r\nif (CVMX_ENABLE_PARAMETER_CHECKING) {\r\nif (__cvmx_cmd_queue_get_state(queue_id) == NULL)\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\n}\r\nswitch ((cvmx_cmd_queue_id_t) (queue_id & 0xff0000)) {\r\ncase CVMX_CMD_QUEUE_PKO_BASE:\r\ncvmx_write_csr(CVMX_PKO_REG_READ_IDX, queue_id & 0xffff);\r\nif (OCTEON_IS_MODEL(OCTEON_CN3XXX)) {\r\nunion cvmx_pko_mem_debug9 debug9;\r\ndebug9.u64 = cvmx_read_csr(CVMX_PKO_MEM_DEBUG9);\r\nreturn debug9.cn38xx.doorbell;\r\n} else {\r\nunion cvmx_pko_mem_debug8 debug8;\r\ndebug8.u64 = cvmx_read_csr(CVMX_PKO_MEM_DEBUG8);\r\nreturn debug8.cn58xx.doorbell;\r\n}\r\ncase CVMX_CMD_QUEUE_ZIP:\r\ncase CVMX_CMD_QUEUE_DFA:\r\ncase CVMX_CMD_QUEUE_RAID:\r\nreturn 0;\r\ncase CVMX_CMD_QUEUE_DMA_BASE:\r\n{\r\nunion cvmx_npei_dmax_counts dmax_counts;\r\ndmax_counts.u64 =\r\ncvmx_read_csr(CVMX_PEXP_NPEI_DMAX_COUNTS\r\n(queue_id & 0x7));\r\nreturn dmax_counts.s.dbell;\r\n}\r\ncase CVMX_CMD_QUEUE_END:\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\n}\r\nreturn CVMX_CMD_QUEUE_INVALID_PARAM;\r\n}\r\nvoid *cvmx_cmd_queue_buffer(cvmx_cmd_queue_id_t queue_id)\r\n{\r\n__cvmx_cmd_queue_state_t *qptr = __cvmx_cmd_queue_get_state(queue_id);\r\nif (qptr && qptr->base_ptr_div128)\r\nreturn cvmx_phys_to_ptr((uint64_t) qptr->base_ptr_div128 << 7);\r\nelse\r\nreturn NULL;\r\n}
