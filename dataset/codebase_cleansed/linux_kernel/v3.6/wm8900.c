static int wm8900_volatile_register(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8900_REG_ID:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void wm8900_reset(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_write(codec, WM8900_REG_RESET, 0);\r\nmemcpy(codec->reg_cache, wm8900_reg_defaults,\r\nsizeof(wm8900_reg_defaults));\r\n}\r\nstatic int wm8900_hp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nu16 hpctl1 = snd_soc_read(codec, WM8900_REG_HPCTL1);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nhpctl1 = WM8900_REG_HPCTL1_HP_CLAMP_IP |\r\nWM8900_REG_HPCTL1_HP_CLAMP_OP;\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nhpctl1 &= ~WM8900_REG_HPCTL1_HP_CLAMP_IP;\r\nhpctl1 |= WM8900_REG_HPCTL1_HP_SHORT |\r\nWM8900_REG_HPCTL1_HP_SHORT2 |\r\nWM8900_REG_HPCTL1_HP_IPSTAGE_ENA;\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);\r\nmsleep(400);\r\nhpctl1 &= ~WM8900_REG_HPCTL1_HP_CLAMP_OP;\r\nhpctl1 |= WM8900_REG_HPCTL1_HP_OPSTAGE_ENA;\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);\r\nhpctl1 &= ~WM8900_REG_HPCTL1_HP_SHORT2;\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);\r\nhpctl1 &= ~WM8900_REG_HPCTL1_HP_SHORT;\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nhpctl1 |= WM8900_REG_HPCTL1_HP_SHORT;\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);\r\nhpctl1 &= ~WM8900_REG_HPCTL1_HP_OPSTAGE_ENA;\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);\r\nhpctl1 |= WM8900_REG_HPCTL1_HP_CLAMP_IP |\r\nWM8900_REG_HPCTL1_HP_CLAMP_OP;\r\nhpctl1 &= ~WM8900_REG_HPCTL1_HP_IPSTAGE_ENA;\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, 0);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8900_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 reg;\r\nreg = snd_soc_read(codec, WM8900_REG_AUDIO1) & ~0x60;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nreg |= 0x20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nreg |= 0x40;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nreg |= 0x60;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8900_REG_AUDIO1, reg);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nreg = snd_soc_read(codec, WM8900_REG_DACCTRL);\r\nif (params_rate(params) <= 24000)\r\nreg |= WM8900_REG_DACCTRL_DAC_SB_FILT;\r\nelse\r\nreg &= ~WM8900_REG_DACCTRL_DAC_SB_FILT;\r\nsnd_soc_write(codec, WM8900_REG_DACCTRL, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod, target;\r\nunsigned int div;\r\nBUG_ON(!Fout);\r\ntarget = Fout;\r\ndiv = 1;\r\nwhile (target < 90000000) {\r\ndiv *= 2;\r\ntarget *= 2;\r\n}\r\nif (target > 100000000)\r\nprintk(KERN_WARNING "wm8900: FLL rate %u out of range, Fref=%u"\r\n" Fout=%u\n", target, Fref, Fout);\r\nif (div > 32) {\r\nprintk(KERN_ERR "wm8900: Invalid FLL division rate %u, "\r\n"Fref=%u, Fout=%u, target=%u\n",\r\ndiv, Fref, Fout, target);\r\nreturn -EINVAL;\r\n}\r\nfll_div->fllclk_div = div >> 2;\r\nif (Fref < 48000)\r\nfll_div->fll_slow_lock_ref = 1;\r\nelse\r\nfll_div->fll_slow_lock_ref = 0;\r\nNdiv = target / Fref;\r\nif (Fref < 1000000)\r\nfll_div->fll_ratio = 8;\r\nelse\r\nfll_div->fll_ratio = 1;\r\nfll_div->n = Ndiv / fll_div->fll_ratio;\r\nNmod = (target / fll_div->fll_ratio) % Fref;\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, Fref);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nfll_div->k = K / 10;\r\nBUG_ON(target != Fout * (fll_div->fllclk_div << 2));\r\nBUG_ON(!K && target != Fref * fll_div->fll_ratio * fll_div->n);\r\nreturn 0;\r\n}\r\nstatic int wm8900_set_fll(struct snd_soc_codec *codec,\r\nint fll_id, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);\r\nstruct _fll_div fll_div;\r\nif (wm8900->fll_in == freq_in && wm8900->fll_out == freq_out)\r\nreturn 0;\r\nsnd_soc_update_bits(codec, WM8900_REG_POWER1,\r\nWM8900_REG_POWER1_FLL_ENA, 0);\r\nif (!freq_in || !freq_out) {\r\nsnd_soc_update_bits(codec, WM8900_REG_CLOCKING1,\r\nWM8900_REG_CLOCKING1_MCLK_SRC, 0);\r\nsnd_soc_update_bits(codec, WM8900_REG_FLLCTL1,\r\nWM8900_REG_FLLCTL1_OSC_ENA, 0);\r\nwm8900->fll_in = freq_in;\r\nwm8900->fll_out = freq_out;\r\nreturn 0;\r\n}\r\nif (fll_factors(&fll_div, freq_in, freq_out) != 0)\r\ngoto reenable;\r\nwm8900->fll_in = freq_in;\r\nwm8900->fll_out = freq_out;\r\nsnd_soc_write(codec, WM8900_REG_FLLCTL1,\r\nfll_div.fll_ratio | WM8900_REG_FLLCTL1_OSC_ENA);\r\nsnd_soc_write(codec, WM8900_REG_FLLCTL4, fll_div.n >> 5);\r\nsnd_soc_write(codec, WM8900_REG_FLLCTL5,\r\n(fll_div.fllclk_div << 6) | (fll_div.n & 0x1f));\r\nif (fll_div.k) {\r\nsnd_soc_write(codec, WM8900_REG_FLLCTL2,\r\n(fll_div.k >> 8) | 0x100);\r\nsnd_soc_write(codec, WM8900_REG_FLLCTL3, fll_div.k & 0xff);\r\n} else\r\nsnd_soc_write(codec, WM8900_REG_FLLCTL2, 0);\r\nif (fll_div.fll_slow_lock_ref)\r\nsnd_soc_write(codec, WM8900_REG_FLLCTL6,\r\nWM8900_REG_FLLCTL6_FLL_SLOW_LOCK_REF);\r\nelse\r\nsnd_soc_write(codec, WM8900_REG_FLLCTL6, 0);\r\nsnd_soc_update_bits(codec, WM8900_REG_POWER1,\r\nWM8900_REG_POWER1_FLL_ENA,\r\nWM8900_REG_POWER1_FLL_ENA);\r\nreenable:\r\nsnd_soc_update_bits(codec, WM8900_REG_CLOCKING1,\r\nWM8900_REG_CLOCKING1_MCLK_SRC,\r\nWM8900_REG_CLOCKING1_MCLK_SRC);\r\nreturn 0;\r\n}\r\nstatic int wm8900_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nreturn wm8900_set_fll(codec_dai->codec, pll_id, freq_in, freq_out);\r\n}\r\nstatic int wm8900_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nswitch (div_id) {\r\ncase WM8900_BCLK_DIV:\r\nsnd_soc_update_bits(codec, WM8900_REG_CLOCKING1,\r\nWM8900_REG_CLOCKING1_BCLK_MASK, div);\r\nbreak;\r\ncase WM8900_OPCLK_DIV:\r\nsnd_soc_update_bits(codec, WM8900_REG_CLOCKING1,\r\nWM8900_REG_CLOCKING1_OPCLK_MASK, div);\r\nbreak;\r\ncase WM8900_DAC_LRCLK:\r\nsnd_soc_update_bits(codec, WM8900_REG_AUDIO4,\r\nWM8900_LRC_MASK, div);\r\nbreak;\r\ncase WM8900_ADC_LRCLK:\r\nsnd_soc_update_bits(codec, WM8900_REG_AUDIO3,\r\nWM8900_LRC_MASK, div);\r\nbreak;\r\ncase WM8900_DAC_CLKDIV:\r\nsnd_soc_update_bits(codec, WM8900_REG_CLOCKING2,\r\nWM8900_REG_CLOCKING2_DAC_CLKDIV, div);\r\nbreak;\r\ncase WM8900_ADC_CLKDIV:\r\nsnd_soc_update_bits(codec, WM8900_REG_CLOCKING2,\r\nWM8900_REG_CLOCKING2_ADC_CLKDIV, div);\r\nbreak;\r\ncase WM8900_LRCLK_MODE:\r\nsnd_soc_update_bits(codec, WM8900_REG_DACCTRL,\r\nWM8900_REG_DACCTRL_AIF_LRCLKRATE, div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8900_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nunsigned int clocking1, aif1, aif3, aif4;\r\nclocking1 = snd_soc_read(codec, WM8900_REG_CLOCKING1);\r\naif1 = snd_soc_read(codec, WM8900_REG_AUDIO1);\r\naif3 = snd_soc_read(codec, WM8900_REG_AUDIO3);\r\naif4 = snd_soc_read(codec, WM8900_REG_AUDIO4);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nclocking1 &= ~WM8900_REG_CLOCKING1_BCLK_DIR;\r\naif3 &= ~WM8900_REG_AUDIO3_ADCLRC_DIR;\r\naif4 &= ~WM8900_REG_AUDIO4_DACLRC_DIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nclocking1 &= ~WM8900_REG_CLOCKING1_BCLK_DIR;\r\naif3 |= WM8900_REG_AUDIO3_ADCLRC_DIR;\r\naif4 |= WM8900_REG_AUDIO4_DACLRC_DIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nclocking1 |= WM8900_REG_CLOCKING1_BCLK_DIR;\r\naif3 |= WM8900_REG_AUDIO3_ADCLRC_DIR;\r\naif4 |= WM8900_REG_AUDIO4_DACLRC_DIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nclocking1 |= WM8900_REG_CLOCKING1_BCLK_DIR;\r\naif3 &= ~WM8900_REG_AUDIO3_ADCLRC_DIR;\r\naif4 &= ~WM8900_REG_AUDIO4_DACLRC_DIR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif1 |= WM8900_REG_AUDIO1_AIF_FMT_MASK;\r\naif1 &= ~WM8900_REG_AUDIO1_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif1 |= WM8900_REG_AUDIO1_AIF_FMT_MASK;\r\naif1 |= WM8900_REG_AUDIO1_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif1 &= ~WM8900_REG_AUDIO1_AIF_FMT_MASK;\r\naif1 |= 0x10;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\naif1 &= ~WM8900_REG_AUDIO1_AIF_FMT_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif1 &= ~WM8900_REG_AUDIO1_AIF_FMT_MASK;\r\naif1 |= 0x8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\naif1 &= ~WM8900_REG_AUDIO1_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8900_REG_AUDIO1_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\naif1 &= ~WM8900_REG_AUDIO1_BCLK_INV;\r\naif1 &= ~WM8900_REG_AUDIO1_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif1 |= WM8900_REG_AUDIO1_BCLK_INV;\r\naif1 |= WM8900_REG_AUDIO1_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8900_REG_AUDIO1_BCLK_INV;\r\naif1 &= ~WM8900_REG_AUDIO1_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif1 &= ~WM8900_REG_AUDIO1_BCLK_INV;\r\naif1 |= WM8900_REG_AUDIO1_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8900_REG_CLOCKING1, clocking1);\r\nsnd_soc_write(codec, WM8900_REG_AUDIO1, aif1);\r\nsnd_soc_write(codec, WM8900_REG_AUDIO3, aif3);\r\nsnd_soc_write(codec, WM8900_REG_AUDIO4, aif4);\r\nreturn 0;\r\n}\r\nstatic int wm8900_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nreg = snd_soc_read(codec, WM8900_REG_DACCTRL);\r\nif (mute)\r\nreg |= WM8900_REG_DACCTRL_MUTE;\r\nelse\r\nreg &= ~WM8900_REG_DACCTRL_MUTE;\r\nsnd_soc_write(codec, WM8900_REG_DACCTRL, reg);\r\nreturn 0;\r\n}\r\nstatic int wm8900_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 reg;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nsnd_soc_update_bits(codec, WM8900_REG_GPIO,\r\nWM8900_REG_GPIO_TEMP_ENA,\r\nWM8900_REG_GPIO_TEMP_ENA);\r\nsnd_soc_update_bits(codec, WM8900_REG_ADDCTL,\r\nWM8900_REG_ADDCTL_TEMP_SD,\r\nWM8900_REG_ADDCTL_TEMP_SD);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nsnd_soc_write(codec, WM8900_REG_POWER1,\r\nWM8900_REG_POWER1_STARTUP_BIAS_ENA);\r\nsnd_soc_write(codec, WM8900_REG_ADDCTL,\r\nWM8900_REG_ADDCTL_BIAS_SRC |\r\nWM8900_REG_ADDCTL_VMID_SOFTST);\r\nsnd_soc_write(codec, WM8900_REG_POWER1,\r\nWM8900_REG_POWER1_STARTUP_BIAS_ENA | 0x1);\r\nschedule_timeout_interruptible(msecs_to_jiffies(400));\r\nsnd_soc_write(codec, WM8900_REG_POWER1,\r\nWM8900_REG_POWER1_STARTUP_BIAS_ENA |\r\nWM8900_REG_POWER1_BIAS_ENA | 0x1);\r\nsnd_soc_write(codec, WM8900_REG_ADDCTL, 0);\r\nsnd_soc_write(codec, WM8900_REG_POWER1,\r\nWM8900_REG_POWER1_BIAS_ENA | 0x1);\r\n}\r\nreg = snd_soc_read(codec, WM8900_REG_POWER1);\r\nsnd_soc_write(codec, WM8900_REG_POWER1,\r\n(reg & WM8900_REG_POWER1_FLL_ENA) |\r\nWM8900_REG_POWER1_BIAS_ENA | 0x1);\r\nsnd_soc_write(codec, WM8900_REG_POWER2,\r\nWM8900_REG_POWER2_SYSCLK_ENA);\r\nsnd_soc_write(codec, WM8900_REG_POWER3, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nreg = snd_soc_read(codec, WM8900_REG_POWER1);\r\nsnd_soc_write(codec, WM8900_REG_POWER1,\r\nreg & WM8900_REG_POWER1_STARTUP_BIAS_ENA);\r\nsnd_soc_write(codec, WM8900_REG_ADDCTL,\r\nWM8900_REG_ADDCTL_BIAS_SRC |\r\nWM8900_REG_ADDCTL_VMID_SOFTST);\r\nsnd_soc_write(codec, WM8900_REG_POWER1,\r\nWM8900_REG_POWER1_STARTUP_BIAS_ENA);\r\nschedule_timeout_interruptible(msecs_to_jiffies(500));\r\nsnd_soc_write(codec, WM8900_REG_HPCTL1, 0);\r\nsnd_soc_write(codec, WM8900_REG_ADDCTL, 0);\r\nsnd_soc_write(codec, WM8900_REG_POWER1, 0);\r\nsnd_soc_write(codec, WM8900_REG_POWER2, 0);\r\nsnd_soc_write(codec, WM8900_REG_POWER3, 0);\r\nschedule_timeout_interruptible(msecs_to_jiffies(1));\r\nsnd_soc_write(codec, WM8900_REG_POWER2,\r\nWM8900_REG_POWER2_SYSCLK_ENA);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8900_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);\r\nint fll_out = wm8900->fll_out;\r\nint fll_in = wm8900->fll_in;\r\nint ret;\r\nret = wm8900_set_fll(codec, 0, 0, 0);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to stop FLL\n");\r\nreturn ret;\r\n}\r\nwm8900->fll_out = fll_out;\r\nwm8900->fll_in = fll_in;\r\nwm8900_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8900_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);\r\nu16 *cache;\r\nint i, ret;\r\ncache = kmemdup(codec->reg_cache, sizeof(wm8900_reg_defaults),\r\nGFP_KERNEL);\r\nwm8900_reset(codec);\r\nwm8900_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nif (wm8900->fll_out) {\r\nint fll_out = wm8900->fll_out;\r\nint fll_in = wm8900->fll_in;\r\nwm8900->fll_in = 0;\r\nwm8900->fll_out = 0;\r\nret = wm8900_set_fll(codec, 0, fll_in, fll_out);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to restart FLL\n");\r\nkfree(cache);\r\nreturn ret;\r\n}\r\n}\r\nif (cache) {\r\nfor (i = 0; i < WM8900_MAXREG; i++)\r\nsnd_soc_write(codec, i, cache[i]);\r\nkfree(cache);\r\n} else\r\ndev_err(codec->dev, "Unable to allocate register cache\n");\r\nreturn 0;\r\n}\r\nstatic int wm8900_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0, reg;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, wm8900->control_type);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nreg = snd_soc_read(codec, WM8900_REG_ID);\r\nif (reg != 0x8900) {\r\ndev_err(codec->dev, "Device is not a WM8900 - ID %x\n", reg);\r\nreturn -ENODEV;\r\n}\r\nwm8900_reset(codec);\r\nwm8900_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_update_bits(codec, WM8900_REG_LINVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_RINVOL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_LOUT1CTL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_ROUT1CTL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_LOUT2CTL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_ROUT2CTL, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_LDAC_DV, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_RDAC_DV, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_LADC_DV, 0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8900_REG_RADC_DV, 0x100, 0x100);\r\nsnd_soc_write(codec, WM8900_REG_OUTBIASCTL, 0x81);\r\nreturn 0;\r\n}\r\nstatic int wm8900_remove(struct snd_soc_codec *codec)\r\n{\r\nwm8900_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int __devinit wm8900_spi_probe(struct spi_device *spi)\r\n{\r\nstruct wm8900_priv *wm8900;\r\nint ret;\r\nwm8900 = kzalloc(sizeof(struct wm8900_priv), GFP_KERNEL);\r\nif (wm8900 == NULL)\r\nreturn -ENOMEM;\r\nwm8900->control_type = SND_SOC_SPI;\r\nspi_set_drvdata(spi, wm8900);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_wm8900, &wm8900_dai, 1);\r\nif (ret < 0)\r\nkfree(wm8900);\r\nreturn ret;\r\n}\r\nstatic int __devexit wm8900_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nkfree(spi_get_drvdata(spi));\r\nreturn 0;\r\n}\r\nstatic __devinit int wm8900_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8900_priv *wm8900;\r\nint ret;\r\nwm8900 = kzalloc(sizeof(struct wm8900_priv), GFP_KERNEL);\r\nif (wm8900 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8900);\r\nwm8900->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8900, &wm8900_dai, 1);\r\nif (ret < 0)\r\nkfree(wm8900);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm8900_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int __init wm8900_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&wm8900_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8900 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&wm8900_spi_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8900 SPI driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8900_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&wm8900_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&wm8900_spi_driver);\r\n#endif\r\n}
