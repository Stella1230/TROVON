static struct i2c_client *at24_translate_offset(struct at24_data *at24,\r\nunsigned *offset)\r\n{\r\nunsigned i;\r\nif (at24->chip.flags & AT24_FLAG_ADDR16) {\r\ni = *offset >> 16;\r\n*offset &= 0xffff;\r\n} else {\r\ni = *offset >> 8;\r\n*offset &= 0xff;\r\n}\r\nreturn at24->client[i];\r\n}\r\nstatic ssize_t at24_eeprom_read(struct at24_data *at24, char *buf,\r\nunsigned offset, size_t count)\r\n{\r\nstruct i2c_msg msg[2];\r\nu8 msgbuf[2];\r\nstruct i2c_client *client;\r\nunsigned long timeout, read_time;\r\nint status, i;\r\nmemset(msg, 0, sizeof(msg));\r\nclient = at24_translate_offset(at24, &offset);\r\nif (count > io_limit)\r\ncount = io_limit;\r\nswitch (at24->use_smbus) {\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nif (count > I2C_SMBUS_BLOCK_MAX)\r\ncount = I2C_SMBUS_BLOCK_MAX;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ncount = 2;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\ncount = 1;\r\nbreak;\r\ndefault:\r\ni = 0;\r\nif (at24->chip.flags & AT24_FLAG_ADDR16)\r\nmsgbuf[i++] = offset >> 8;\r\nmsgbuf[i++] = offset;\r\nmsg[0].addr = client->addr;\r\nmsg[0].buf = msgbuf;\r\nmsg[0].len = i;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].buf = buf;\r\nmsg[1].len = count;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(write_timeout);\r\ndo {\r\nread_time = jiffies;\r\nswitch (at24->use_smbus) {\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nstatus = i2c_smbus_read_i2c_block_data(client, offset,\r\ncount, buf);\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nstatus = i2c_smbus_read_word_data(client, offset);\r\nif (status >= 0) {\r\nbuf[0] = status & 0xff;\r\nbuf[1] = status >> 8;\r\nstatus = count;\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nstatus = i2c_smbus_read_byte_data(client, offset);\r\nif (status >= 0) {\r\nbuf[0] = status;\r\nstatus = count;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = i2c_transfer(client->adapter, msg, 2);\r\nif (status == 2)\r\nstatus = count;\r\n}\r\ndev_dbg(&client->dev, "read %zu@%d --> %d (%ld)\n",\r\ncount, offset, status, jiffies);\r\nif (status == count)\r\nreturn count;\r\nmsleep(1);\r\n} while (time_before(read_time, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t at24_read(struct at24_data *at24,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nssize_t retval = 0;\r\nif (unlikely(!count))\r\nreturn count;\r\nmutex_lock(&at24->lock);\r\nwhile (count) {\r\nssize_t status;\r\nstatus = at24_eeprom_read(at24, buf, off, count);\r\nif (status <= 0) {\r\nif (retval == 0)\r\nretval = status;\r\nbreak;\r\n}\r\nbuf += status;\r\noff += status;\r\ncount -= status;\r\nretval += status;\r\n}\r\nmutex_unlock(&at24->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t at24_bin_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct at24_data *at24;\r\nat24 = dev_get_drvdata(container_of(kobj, struct device, kobj));\r\nreturn at24_read(at24, buf, off, count);\r\n}\r\nstatic ssize_t at24_eeprom_write(struct at24_data *at24, const char *buf,\r\nunsigned offset, size_t count)\r\n{\r\nstruct i2c_client *client;\r\nstruct i2c_msg msg;\r\nssize_t status;\r\nunsigned long timeout, write_time;\r\nunsigned next_page;\r\nclient = at24_translate_offset(at24, &offset);\r\nif (count > at24->write_max)\r\ncount = at24->write_max;\r\nnext_page = roundup(offset + 1, at24->chip.page_size);\r\nif (offset + count > next_page)\r\ncount = next_page - offset;\r\nif (!at24->use_smbus) {\r\nint i = 0;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.buf = at24->writebuf;\r\nif (at24->chip.flags & AT24_FLAG_ADDR16)\r\nmsg.buf[i++] = offset >> 8;\r\nmsg.buf[i++] = offset;\r\nmemcpy(&msg.buf[i], buf, count);\r\nmsg.len = i + count;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(write_timeout);\r\ndo {\r\nwrite_time = jiffies;\r\nif (at24->use_smbus) {\r\nstatus = i2c_smbus_write_i2c_block_data(client,\r\noffset, count, buf);\r\nif (status == 0)\r\nstatus = count;\r\n} else {\r\nstatus = i2c_transfer(client->adapter, &msg, 1);\r\nif (status == 1)\r\nstatus = count;\r\n}\r\ndev_dbg(&client->dev, "write %zu@%d --> %zd (%ld)\n",\r\ncount, offset, status, jiffies);\r\nif (status == count)\r\nreturn count;\r\nmsleep(1);\r\n} while (time_before(write_time, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic ssize_t at24_write(struct at24_data *at24, const char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nssize_t retval = 0;\r\nif (unlikely(!count))\r\nreturn count;\r\nmutex_lock(&at24->lock);\r\nwhile (count) {\r\nssize_t status;\r\nstatus = at24_eeprom_write(at24, buf, off, count);\r\nif (status <= 0) {\r\nif (retval == 0)\r\nretval = status;\r\nbreak;\r\n}\r\nbuf += status;\r\noff += status;\r\ncount -= status;\r\nretval += status;\r\n}\r\nmutex_unlock(&at24->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t at24_bin_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct at24_data *at24;\r\nat24 = dev_get_drvdata(container_of(kobj, struct device, kobj));\r\nreturn at24_write(at24, buf, off, count);\r\n}\r\nstatic ssize_t at24_macc_read(struct memory_accessor *macc, char *buf,\r\noff_t offset, size_t count)\r\n{\r\nstruct at24_data *at24 = container_of(macc, struct at24_data, macc);\r\nreturn at24_read(at24, buf, offset, count);\r\n}\r\nstatic ssize_t at24_macc_write(struct memory_accessor *macc, const char *buf,\r\noff_t offset, size_t count)\r\n{\r\nstruct at24_data *at24 = container_of(macc, struct at24_data, macc);\r\nreturn at24_write(at24, buf, offset, count);\r\n}\r\nstatic void at24_get_ofdata(struct i2c_client *client,\r\nstruct at24_platform_data *chip)\r\n{\r\nconst __be32 *val;\r\nstruct device_node *node = client->dev.of_node;\r\nif (node) {\r\nif (of_get_property(node, "read-only", NULL))\r\nchip->flags |= AT24_FLAG_READONLY;\r\nval = of_get_property(node, "pagesize", NULL);\r\nif (val)\r\nchip->page_size = be32_to_cpup(val);\r\n}\r\n}\r\nstatic void at24_get_ofdata(struct i2c_client *client,\r\nstruct at24_platform_data *chip)\r\n{ }\r\nstatic int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct at24_platform_data chip;\r\nbool writable;\r\nint use_smbus = 0;\r\nstruct at24_data *at24;\r\nint err;\r\nunsigned i, num_addresses;\r\nkernel_ulong_t magic;\r\nif (client->dev.platform_data) {\r\nchip = *(struct at24_platform_data *)client->dev.platform_data;\r\n} else {\r\nif (!id->driver_data) {\r\nerr = -ENODEV;\r\ngoto err_out;\r\n}\r\nmagic = id->driver_data;\r\nchip.byte_len = BIT(magic & AT24_BITMASK(AT24_SIZE_BYTELEN));\r\nmagic >>= AT24_SIZE_BYTELEN;\r\nchip.flags = magic & AT24_BITMASK(AT24_SIZE_FLAGS);\r\nchip.page_size = 1;\r\nat24_get_ofdata(client, &chip);\r\nchip.setup = NULL;\r\nchip.context = NULL;\r\n}\r\nif (!is_power_of_2(chip.byte_len))\r\ndev_warn(&client->dev,\r\n"byte_len looks suspicious (no power of 2)!\n");\r\nif (!chip.page_size) {\r\ndev_err(&client->dev, "page_size must not be 0!\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (!is_power_of_2(chip.page_size))\r\ndev_warn(&client->dev,\r\n"page_size looks suspicious (no power of 2)!\n");\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nif (chip.flags & AT24_FLAG_ADDR16) {\r\nerr = -EPFNOSUPPORT;\r\ngoto err_out;\r\n}\r\nif (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\r\nuse_smbus = I2C_SMBUS_I2C_BLOCK_DATA;\r\n} else if (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA)) {\r\nuse_smbus = I2C_SMBUS_WORD_DATA;\r\n} else if (i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE_DATA)) {\r\nuse_smbus = I2C_SMBUS_BYTE_DATA;\r\n} else {\r\nerr = -EPFNOSUPPORT;\r\ngoto err_out;\r\n}\r\n}\r\nif (chip.flags & AT24_FLAG_TAKE8ADDR)\r\nnum_addresses = 8;\r\nelse\r\nnum_addresses = DIV_ROUND_UP(chip.byte_len,\r\n(chip.flags & AT24_FLAG_ADDR16) ? 65536 : 256);\r\nat24 = kzalloc(sizeof(struct at24_data) +\r\nnum_addresses * sizeof(struct i2c_client *), GFP_KERNEL);\r\nif (!at24) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nmutex_init(&at24->lock);\r\nat24->use_smbus = use_smbus;\r\nat24->chip = chip;\r\nat24->num_addresses = num_addresses;\r\nsysfs_bin_attr_init(&at24->bin);\r\nat24->bin.attr.name = "eeprom";\r\nat24->bin.attr.mode = chip.flags & AT24_FLAG_IRUGO ? S_IRUGO : S_IRUSR;\r\nat24->bin.read = at24_bin_read;\r\nat24->bin.size = chip.byte_len;\r\nat24->macc.read = at24_macc_read;\r\nwritable = !(chip.flags & AT24_FLAG_READONLY);\r\nif (writable) {\r\nif (!use_smbus || i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) {\r\nunsigned write_max = chip.page_size;\r\nat24->macc.write = at24_macc_write;\r\nat24->bin.write = at24_bin_write;\r\nat24->bin.attr.mode |= S_IWUSR;\r\nif (write_max > io_limit)\r\nwrite_max = io_limit;\r\nif (use_smbus && write_max > I2C_SMBUS_BLOCK_MAX)\r\nwrite_max = I2C_SMBUS_BLOCK_MAX;\r\nat24->write_max = write_max;\r\nat24->writebuf = kmalloc(write_max + 2, GFP_KERNEL);\r\nif (!at24->writebuf) {\r\nerr = -ENOMEM;\r\ngoto err_struct;\r\n}\r\n} else {\r\ndev_warn(&client->dev,\r\n"cannot write due to controller restrictions.");\r\n}\r\n}\r\nat24->client[0] = client;\r\nfor (i = 1; i < num_addresses; i++) {\r\nat24->client[i] = i2c_new_dummy(client->adapter,\r\nclient->addr + i);\r\nif (!at24->client[i]) {\r\ndev_err(&client->dev, "address 0x%02x unavailable\n",\r\nclient->addr + i);\r\nerr = -EADDRINUSE;\r\ngoto err_clients;\r\n}\r\n}\r\nerr = sysfs_create_bin_file(&client->dev.kobj, &at24->bin);\r\nif (err)\r\ngoto err_clients;\r\ni2c_set_clientdata(client, at24);\r\ndev_info(&client->dev, "%zu byte %s EEPROM, %s, %u bytes/write\n",\r\nat24->bin.size, client->name,\r\nwritable ? "writable" : "read-only", at24->write_max);\r\nif (use_smbus == I2C_SMBUS_WORD_DATA ||\r\nuse_smbus == I2C_SMBUS_BYTE_DATA) {\r\ndev_notice(&client->dev, "Falling back to %s reads, "\r\n"performance will suffer\n", use_smbus ==\r\nI2C_SMBUS_WORD_DATA ? "word" : "byte");\r\n}\r\nif (chip.setup)\r\nchip.setup(&at24->macc, chip.context);\r\nreturn 0;\r\nerr_clients:\r\nfor (i = 1; i < num_addresses; i++)\r\nif (at24->client[i])\r\ni2c_unregister_device(at24->client[i]);\r\nkfree(at24->writebuf);\r\nerr_struct:\r\nkfree(at24);\r\nerr_out:\r\ndev_dbg(&client->dev, "probe error %d\n", err);\r\nreturn err;\r\n}\r\nstatic int __devexit at24_remove(struct i2c_client *client)\r\n{\r\nstruct at24_data *at24;\r\nint i;\r\nat24 = i2c_get_clientdata(client);\r\nsysfs_remove_bin_file(&client->dev.kobj, &at24->bin);\r\nfor (i = 1; i < at24->num_addresses; i++)\r\ni2c_unregister_device(at24->client[i]);\r\nkfree(at24->writebuf);\r\nkfree(at24);\r\nreturn 0;\r\n}\r\nstatic int __init at24_init(void)\r\n{\r\nif (!io_limit) {\r\npr_err("at24: io_limit must not be 0!\n");\r\nreturn -EINVAL;\r\n}\r\nio_limit = rounddown_pow_of_two(io_limit);\r\nreturn i2c_add_driver(&at24_driver);\r\n}\r\nstatic void __exit at24_exit(void)\r\n{\r\ni2c_del_driver(&at24_driver);\r\n}
