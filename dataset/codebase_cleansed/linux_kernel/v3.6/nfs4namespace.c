static inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\r\nchar *buffer, ssize_t buflen)\r\n{\r\nchar *end = buffer + buflen;\r\nint n;\r\n*--end = '\0';\r\nbuflen--;\r\nn = pathname->ncomponents;\r\nwhile (--n >= 0) {\r\nconst struct nfs4_string *component = &pathname->components[n];\r\nbuflen -= component->len + 1;\r\nif (buflen < 0)\r\ngoto Elong;\r\nend -= component->len;\r\nmemcpy(end, component->data, component->len);\r\n*--end = '/';\r\n}\r\nreturn end;\r\nElong:\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\n}\r\nstatic char *nfs_path_component(const char *nfspath, const char *end)\r\n{\r\nchar *p;\r\nif (*nfspath == '[') {\r\np = strchr(nfspath, ']');\r\nif (p != NULL && ++p < end && *p == ':')\r\nreturn p + 1;\r\n} else {\r\np = strchr(nfspath, ':');\r\nif (p != NULL && p < end)\r\nreturn p + 1;\r\n}\r\nreturn NULL;\r\n}\r\nstatic char *nfs4_path(struct dentry *dentry, char *buffer, ssize_t buflen)\r\n{\r\nchar *limit;\r\nchar *path = nfs_path(&limit, dentry, buffer, buflen);\r\nif (!IS_ERR(path)) {\r\nchar *path_component = nfs_path_component(path, limit);\r\nif (path_component)\r\nreturn path_component;\r\n}\r\nreturn path;\r\n}\r\nstatic int nfs4_validate_fspath(struct dentry *dentry,\r\nconst struct nfs4_fs_locations *locations,\r\nchar *page, char *page2)\r\n{\r\nconst char *path, *fs_path;\r\npath = nfs4_path(dentry, page, PAGE_SIZE);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nfs_path = nfs4_pathname_string(&locations->fs_path, page2, PAGE_SIZE);\r\nif (IS_ERR(fs_path))\r\nreturn PTR_ERR(fs_path);\r\nif (strncmp(path, fs_path, strlen(fs_path)) != 0) {\r\ndprintk("%s: path %s does not begin with fsroot %s\n",\r\n__func__, path, fs_path);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t nfs_parse_server_name(char *string, size_t len,\r\nstruct sockaddr *sa, size_t salen, struct nfs_server *server)\r\n{\r\nstruct net *net = rpc_net_ns(server->client);\r\nssize_t ret;\r\nret = rpc_pton(net, string, len, sa, salen);\r\nif (ret == 0) {\r\nret = nfs_dns_resolve_name(net, string, len, sa, salen);\r\nif (ret < 0)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nrpc_authflavor_t nfs_find_best_sec(struct nfs4_secinfo_flavors *flavors)\r\n{\r\nstruct gss_api_mech *mech;\r\nstruct xdr_netobj oid;\r\nint i;\r\nrpc_authflavor_t pseudoflavor = RPC_AUTH_UNIX;\r\nfor (i = 0; i < flavors->num_flavors; i++) {\r\nstruct nfs4_secinfo_flavor *flavor;\r\nflavor = &flavors->flavors[i];\r\nif (flavor->flavor == RPC_AUTH_NULL || flavor->flavor == RPC_AUTH_UNIX) {\r\npseudoflavor = flavor->flavor;\r\nbreak;\r\n} else if (flavor->flavor == RPC_AUTH_GSS) {\r\noid.len = flavor->gss.sec_oid4.len;\r\noid.data = flavor->gss.sec_oid4.data;\r\nmech = gss_mech_get_by_OID(&oid);\r\nif (!mech)\r\ncontinue;\r\npseudoflavor = gss_svc_to_pseudoflavor(mech, flavor->gss.service);\r\ngss_mech_put(mech);\r\nbreak;\r\n}\r\n}\r\nreturn pseudoflavor;\r\n}\r\nstatic rpc_authflavor_t nfs4_negotiate_security(struct inode *inode, struct qstr *name)\r\n{\r\nstruct page *page;\r\nstruct nfs4_secinfo_flavors *flavors;\r\nrpc_authflavor_t flavor;\r\nint err;\r\npage = alloc_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nflavors = page_address(page);\r\nerr = nfs4_proc_secinfo(inode, name, flavors);\r\nif (err < 0) {\r\nflavor = err;\r\ngoto out;\r\n}\r\nflavor = nfs_find_best_sec(flavors);\r\nout:\r\nput_page(page);\r\nreturn flavor;\r\n}\r\nstruct rpc_clnt *nfs4_create_sec_client(struct rpc_clnt *clnt, struct inode *inode,\r\nstruct qstr *name)\r\n{\r\nstruct rpc_clnt *clone;\r\nstruct rpc_auth *auth;\r\nrpc_authflavor_t flavor;\r\nflavor = nfs4_negotiate_security(inode, name);\r\nif ((int)flavor < 0)\r\nreturn ERR_PTR(flavor);\r\nclone = rpc_clone_client(clnt);\r\nif (IS_ERR(clone))\r\nreturn clone;\r\nauth = rpcauth_create(flavor, clone);\r\nif (!auth) {\r\nrpc_shutdown_client(clone);\r\nclone = ERR_PTR(-EIO);\r\n}\r\nreturn clone;\r\n}\r\nstatic struct vfsmount *try_location(struct nfs_clone_mount *mountdata,\r\nchar *page, char *page2,\r\nconst struct nfs4_fs_location *location)\r\n{\r\nconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\r\nstruct vfsmount *mnt = ERR_PTR(-ENOENT);\r\nchar *mnt_path;\r\nunsigned int maxbuflen;\r\nunsigned int s;\r\nmnt_path = nfs4_pathname_string(&location->rootpath, page2, PAGE_SIZE);\r\nif (IS_ERR(mnt_path))\r\nreturn ERR_CAST(mnt_path);\r\nmountdata->mnt_path = mnt_path;\r\nmaxbuflen = mnt_path - 1 - page2;\r\nmountdata->addr = kmalloc(addr_bufsize, GFP_KERNEL);\r\nif (mountdata->addr == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (s = 0; s < location->nservers; s++) {\r\nconst struct nfs4_string *buf = &location->servers[s];\r\nif (buf->len <= 0 || buf->len >= maxbuflen)\r\ncontinue;\r\nif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))\r\ncontinue;\r\nmountdata->addrlen = nfs_parse_server_name(buf->data, buf->len,\r\nmountdata->addr, addr_bufsize,\r\nNFS_SB(mountdata->sb));\r\nif (mountdata->addrlen == 0)\r\ncontinue;\r\nrpc_set_port(mountdata->addr, NFS_PORT);\r\nmemcpy(page2, buf->data, buf->len);\r\npage2[buf->len] = '\0';\r\nmountdata->hostname = page2;\r\nsnprintf(page, PAGE_SIZE, "%s:%s",\r\nmountdata->hostname,\r\nmountdata->mnt_path);\r\nmnt = vfs_kern_mount(&nfs4_referral_fs_type, 0, page, mountdata);\r\nif (!IS_ERR(mnt))\r\nbreak;\r\n}\r\nkfree(mountdata->addr);\r\nreturn mnt;\r\n}\r\nstatic struct vfsmount *nfs_follow_referral(struct dentry *dentry,\r\nconst struct nfs4_fs_locations *locations)\r\n{\r\nstruct vfsmount *mnt = ERR_PTR(-ENOENT);\r\nstruct nfs_clone_mount mountdata = {\r\n.sb = dentry->d_sb,\r\n.dentry = dentry,\r\n.authflavor = NFS_SB(dentry->d_sb)->client->cl_auth->au_flavor,\r\n};\r\nchar *page = NULL, *page2 = NULL;\r\nint loc, error;\r\nif (locations == NULL || locations->nlocations <= 0)\r\ngoto out;\r\ndprintk("%s: referral at %s/%s\n", __func__,\r\ndentry->d_parent->d_name.name, dentry->d_name.name);\r\npage = (char *) __get_free_page(GFP_USER);\r\nif (!page)\r\ngoto out;\r\npage2 = (char *) __get_free_page(GFP_USER);\r\nif (!page2)\r\ngoto out;\r\nerror = nfs4_validate_fspath(dentry, locations, page, page2);\r\nif (error < 0) {\r\nmnt = ERR_PTR(error);\r\ngoto out;\r\n}\r\nfor (loc = 0; loc < locations->nlocations; loc++) {\r\nconst struct nfs4_fs_location *location = &locations->locations[loc];\r\nif (location == NULL || location->nservers <= 0 ||\r\nlocation->rootpath.ncomponents == 0)\r\ncontinue;\r\nmnt = try_location(&mountdata, page, page2, location);\r\nif (!IS_ERR(mnt))\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long) page);\r\nfree_page((unsigned long) page2);\r\ndprintk("%s: done\n", __func__);\r\nreturn mnt;\r\n}\r\nstatic struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)\r\n{\r\nstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\r\nstruct dentry *parent;\r\nstruct nfs4_fs_locations *fs_locations = NULL;\r\nstruct page *page;\r\nint err;\r\ndprintk("%s: enter\n", __func__);\r\npage = alloc_page(GFP_KERNEL);\r\nif (page == NULL)\r\ngoto out;\r\nfs_locations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\r\nif (fs_locations == NULL)\r\ngoto out_free;\r\nmnt = ERR_PTR(-ENOENT);\r\nparent = dget_parent(dentry);\r\ndprintk("%s: getting locations for %s/%s\n",\r\n__func__, parent->d_name.name, dentry->d_name.name);\r\nerr = nfs4_proc_fs_locations(client, parent->d_inode, &dentry->d_name, fs_locations, page);\r\ndput(parent);\r\nif (err != 0 ||\r\nfs_locations->nlocations <= 0 ||\r\nfs_locations->fs_path.ncomponents <= 0)\r\ngoto out_free;\r\nmnt = nfs_follow_referral(dentry, fs_locations);\r\nout_free:\r\n__free_page(page);\r\nkfree(fs_locations);\r\nout:\r\ndprintk("%s: done\n", __func__);\r\nreturn mnt;\r\n}\r\nstruct vfsmount *nfs4_submount(struct nfs_server *server, struct dentry *dentry,\r\nstruct nfs_fh *fh, struct nfs_fattr *fattr)\r\n{\r\nstruct dentry *parent = dget_parent(dentry);\r\nstruct rpc_clnt *client;\r\nstruct vfsmount *mnt;\r\nclient = nfs4_proc_lookup_mountpoint(parent->d_inode, &dentry->d_name, fh, fattr);\r\ndput(parent);\r\nif (IS_ERR(client))\r\nreturn ERR_CAST(client);\r\nif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\r\nmnt = nfs_do_refmount(client, dentry);\r\nelse\r\nmnt = nfs_do_submount(dentry, fh, fattr, client->cl_auth->au_flavor);\r\nrpc_shutdown_client(client);\r\nreturn mnt;\r\n}
