static void evdev_pass_event(struct evdev_client *client,\r\nstruct input_event *event,\r\nktime_t mono, ktime_t real)\r\n{\r\nevent->time = ktime_to_timeval(client->clkid == CLOCK_MONOTONIC ?\r\nmono : real);\r\nspin_lock(&client->buffer_lock);\r\nclient->buffer[client->head++] = *event;\r\nclient->head &= client->bufsize - 1;\r\nif (unlikely(client->head == client->tail)) {\r\nclient->tail = (client->head - 2) & (client->bufsize - 1);\r\nclient->buffer[client->tail].time = event->time;\r\nclient->buffer[client->tail].type = EV_SYN;\r\nclient->buffer[client->tail].code = SYN_DROPPED;\r\nclient->buffer[client->tail].value = 0;\r\nclient->packet_head = client->tail;\r\n}\r\nif (event->type == EV_SYN && event->code == SYN_REPORT) {\r\nclient->packet_head = client->head;\r\nkill_fasync(&client->fasync, SIGIO, POLL_IN);\r\n}\r\nspin_unlock(&client->buffer_lock);\r\n}\r\nstatic void evdev_event(struct input_handle *handle,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct evdev *evdev = handle->private;\r\nstruct evdev_client *client;\r\nstruct input_event event;\r\nktime_t time_mono, time_real;\r\ntime_mono = ktime_get();\r\ntime_real = ktime_sub(time_mono, ktime_get_monotonic_offset());\r\nevent.type = type;\r\nevent.code = code;\r\nevent.value = value;\r\nrcu_read_lock();\r\nclient = rcu_dereference(evdev->grab);\r\nif (client)\r\nevdev_pass_event(client, &event, time_mono, time_real);\r\nelse\r\nlist_for_each_entry_rcu(client, &evdev->client_list, node)\r\nevdev_pass_event(client, &event, time_mono, time_real);\r\nrcu_read_unlock();\r\nif (type == EV_SYN && code == SYN_REPORT)\r\nwake_up_interruptible(&evdev->wait);\r\n}\r\nstatic int evdev_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct evdev_client *client = file->private_data;\r\nreturn fasync_helper(fd, file, on, &client->fasync);\r\n}\r\nstatic int evdev_flush(struct file *file, fl_owner_t id)\r\n{\r\nstruct evdev_client *client = file->private_data;\r\nstruct evdev *evdev = client->evdev;\r\nint retval;\r\nretval = mutex_lock_interruptible(&evdev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!evdev->exist)\r\nretval = -ENODEV;\r\nelse\r\nretval = input_flush_device(&evdev->handle, file);\r\nmutex_unlock(&evdev->mutex);\r\nreturn retval;\r\n}\r\nstatic void evdev_free(struct device *dev)\r\n{\r\nstruct evdev *evdev = container_of(dev, struct evdev, dev);\r\ninput_put_device(evdev->handle.dev);\r\nkfree(evdev);\r\n}\r\nstatic int evdev_grab(struct evdev *evdev, struct evdev_client *client)\r\n{\r\nint error;\r\nif (evdev->grab)\r\nreturn -EBUSY;\r\nerror = input_grab_device(&evdev->handle);\r\nif (error)\r\nreturn error;\r\nrcu_assign_pointer(evdev->grab, client);\r\nreturn 0;\r\n}\r\nstatic int evdev_ungrab(struct evdev *evdev, struct evdev_client *client)\r\n{\r\nstruct evdev_client *grab = rcu_dereference_protected(evdev->grab,\r\nlockdep_is_held(&evdev->mutex));\r\nif (grab != client)\r\nreturn -EINVAL;\r\nrcu_assign_pointer(evdev->grab, NULL);\r\nsynchronize_rcu();\r\ninput_release_device(&evdev->handle);\r\nreturn 0;\r\n}\r\nstatic void evdev_attach_client(struct evdev *evdev,\r\nstruct evdev_client *client)\r\n{\r\nspin_lock(&evdev->client_lock);\r\nlist_add_tail_rcu(&client->node, &evdev->client_list);\r\nspin_unlock(&evdev->client_lock);\r\n}\r\nstatic void evdev_detach_client(struct evdev *evdev,\r\nstruct evdev_client *client)\r\n{\r\nspin_lock(&evdev->client_lock);\r\nlist_del_rcu(&client->node);\r\nspin_unlock(&evdev->client_lock);\r\nsynchronize_rcu();\r\n}\r\nstatic int evdev_open_device(struct evdev *evdev)\r\n{\r\nint retval;\r\nretval = mutex_lock_interruptible(&evdev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!evdev->exist)\r\nretval = -ENODEV;\r\nelse if (!evdev->open++) {\r\nretval = input_open_device(&evdev->handle);\r\nif (retval)\r\nevdev->open--;\r\n}\r\nmutex_unlock(&evdev->mutex);\r\nreturn retval;\r\n}\r\nstatic void evdev_close_device(struct evdev *evdev)\r\n{\r\nmutex_lock(&evdev->mutex);\r\nif (evdev->exist && !--evdev->open)\r\ninput_close_device(&evdev->handle);\r\nmutex_unlock(&evdev->mutex);\r\n}\r\nstatic void evdev_hangup(struct evdev *evdev)\r\n{\r\nstruct evdev_client *client;\r\nspin_lock(&evdev->client_lock);\r\nlist_for_each_entry(client, &evdev->client_list, node)\r\nkill_fasync(&client->fasync, SIGIO, POLL_HUP);\r\nspin_unlock(&evdev->client_lock);\r\nwake_up_interruptible(&evdev->wait);\r\n}\r\nstatic int evdev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct evdev_client *client = file->private_data;\r\nstruct evdev *evdev = client->evdev;\r\nmutex_lock(&evdev->mutex);\r\nevdev_ungrab(evdev, client);\r\nmutex_unlock(&evdev->mutex);\r\nevdev_detach_client(evdev, client);\r\nkfree(client);\r\nevdev_close_device(evdev);\r\nput_device(&evdev->dev);\r\nreturn 0;\r\n}\r\nstatic unsigned int evdev_compute_buffer_size(struct input_dev *dev)\r\n{\r\nunsigned int n_events =\r\nmax(dev->hint_events_per_packet * EVDEV_BUF_PACKETS,\r\nEVDEV_MIN_BUFFER_SIZE);\r\nreturn roundup_pow_of_two(n_events);\r\n}\r\nstatic int evdev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct evdev *evdev;\r\nstruct evdev_client *client;\r\nint i = iminor(inode) - EVDEV_MINOR_BASE;\r\nunsigned int bufsize;\r\nint error;\r\nif (i >= EVDEV_MINORS)\r\nreturn -ENODEV;\r\nerror = mutex_lock_interruptible(&evdev_table_mutex);\r\nif (error)\r\nreturn error;\r\nevdev = evdev_table[i];\r\nif (evdev)\r\nget_device(&evdev->dev);\r\nmutex_unlock(&evdev_table_mutex);\r\nif (!evdev)\r\nreturn -ENODEV;\r\nbufsize = evdev_compute_buffer_size(evdev->handle.dev);\r\nclient = kzalloc(sizeof(struct evdev_client) +\r\nbufsize * sizeof(struct input_event),\r\nGFP_KERNEL);\r\nif (!client) {\r\nerror = -ENOMEM;\r\ngoto err_put_evdev;\r\n}\r\nclient->bufsize = bufsize;\r\nspin_lock_init(&client->buffer_lock);\r\nclient->evdev = evdev;\r\nevdev_attach_client(evdev, client);\r\nerror = evdev_open_device(evdev);\r\nif (error)\r\ngoto err_free_client;\r\nfile->private_data = client;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\nerr_free_client:\r\nevdev_detach_client(evdev, client);\r\nkfree(client);\r\nerr_put_evdev:\r\nput_device(&evdev->dev);\r\nreturn error;\r\n}\r\nstatic ssize_t evdev_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct evdev_client *client = file->private_data;\r\nstruct evdev *evdev = client->evdev;\r\nstruct input_event event;\r\nint retval = 0;\r\nif (count != 0 && count < input_event_size())\r\nreturn -EINVAL;\r\nretval = mutex_lock_interruptible(&evdev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!evdev->exist) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nwhile (retval + input_event_size() <= count) {\r\nif (input_event_from_user(buffer + retval, &event)) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nretval += input_event_size();\r\ninput_inject_event(&evdev->handle,\r\nevent.type, event.code, event.value);\r\n}\r\nout:\r\nmutex_unlock(&evdev->mutex);\r\nreturn retval;\r\n}\r\nstatic int evdev_fetch_next_event(struct evdev_client *client,\r\nstruct input_event *event)\r\n{\r\nint have_event;\r\nspin_lock_irq(&client->buffer_lock);\r\nhave_event = client->packet_head != client->tail;\r\nif (have_event) {\r\n*event = client->buffer[client->tail++];\r\nclient->tail &= client->bufsize - 1;\r\n}\r\nspin_unlock_irq(&client->buffer_lock);\r\nreturn have_event;\r\n}\r\nstatic ssize_t evdev_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct evdev_client *client = file->private_data;\r\nstruct evdev *evdev = client->evdev;\r\nstruct input_event event;\r\nsize_t read = 0;\r\nint error;\r\nif (count != 0 && count < input_event_size())\r\nreturn -EINVAL;\r\nfor (;;) {\r\nif (!evdev->exist)\r\nreturn -ENODEV;\r\nif (client->packet_head == client->tail &&\r\n(file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nif (count == 0)\r\nbreak;\r\nwhile (read + input_event_size() <= count &&\r\nevdev_fetch_next_event(client, &event)) {\r\nif (input_event_to_user(buffer + read, &event))\r\nreturn -EFAULT;\r\nread += input_event_size();\r\n}\r\nif (read)\r\nbreak;\r\nif (!(file->f_flags & O_NONBLOCK)) {\r\nerror = wait_event_interruptible(evdev->wait,\r\nclient->packet_head != client->tail ||\r\n!evdev->exist);\r\nif (error)\r\nreturn error;\r\n}\r\n}\r\nreturn read;\r\n}\r\nstatic unsigned int evdev_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct evdev_client *client = file->private_data;\r\nstruct evdev *evdev = client->evdev;\r\nunsigned int mask;\r\npoll_wait(file, &evdev->wait, wait);\r\nmask = evdev->exist ? POLLOUT | POLLWRNORM : POLLHUP | POLLERR;\r\nif (client->packet_head != client->tail)\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic int bits_to_user(unsigned long *bits, unsigned int maxbit,\r\nunsigned int maxlen, void __user *p, int compat)\r\n{\r\nint len, i;\r\nif (compat) {\r\nlen = BITS_TO_LONGS_COMPAT(maxbit) * sizeof(compat_long_t);\r\nif (len > maxlen)\r\nlen = maxlen;\r\nfor (i = 0; i < len / sizeof(compat_long_t); i++)\r\nif (copy_to_user((compat_long_t __user *) p + i,\r\n(compat_long_t *) bits +\r\ni + 1 - ((i % 2) << 1),\r\nsizeof(compat_long_t)))\r\nreturn -EFAULT;\r\n} else {\r\nlen = BITS_TO_LONGS(maxbit) * sizeof(long);\r\nif (len > maxlen)\r\nlen = maxlen;\r\nif (copy_to_user(p, bits, len))\r\nreturn -EFAULT;\r\n}\r\nreturn len;\r\n}\r\nstatic int bits_to_user(unsigned long *bits, unsigned int maxbit,\r\nunsigned int maxlen, void __user *p, int compat)\r\n{\r\nint len = compat ?\r\nBITS_TO_LONGS_COMPAT(maxbit) * sizeof(compat_long_t) :\r\nBITS_TO_LONGS(maxbit) * sizeof(long);\r\nif (len > maxlen)\r\nlen = maxlen;\r\nreturn copy_to_user(p, bits, len) ? -EFAULT : len;\r\n}\r\nstatic int bits_to_user(unsigned long *bits, unsigned int maxbit,\r\nunsigned int maxlen, void __user *p, int compat)\r\n{\r\nint len = BITS_TO_LONGS(maxbit) * sizeof(long);\r\nif (len > maxlen)\r\nlen = maxlen;\r\nreturn copy_to_user(p, bits, len) ? -EFAULT : len;\r\n}\r\nstatic int str_to_user(const char *str, unsigned int maxlen, void __user *p)\r\n{\r\nint len;\r\nif (!str)\r\nreturn -ENOENT;\r\nlen = strlen(str) + 1;\r\nif (len > maxlen)\r\nlen = maxlen;\r\nreturn copy_to_user(p, str, len) ? -EFAULT : len;\r\n}\r\nstatic int handle_eviocgbit(struct input_dev *dev,\r\nunsigned int type, unsigned int size,\r\nvoid __user *p, int compat_mode)\r\n{\r\nstatic unsigned long keymax_warn_time;\r\nunsigned long *bits;\r\nint len;\r\nswitch (type) {\r\ncase 0: bits = dev->evbit; len = EV_MAX; break;\r\ncase EV_KEY: bits = dev->keybit; len = KEY_MAX; break;\r\ncase EV_REL: bits = dev->relbit; len = REL_MAX; break;\r\ncase EV_ABS: bits = dev->absbit; len = ABS_MAX; break;\r\ncase EV_MSC: bits = dev->mscbit; len = MSC_MAX; break;\r\ncase EV_LED: bits = dev->ledbit; len = LED_MAX; break;\r\ncase EV_SND: bits = dev->sndbit; len = SND_MAX; break;\r\ncase EV_FF: bits = dev->ffbit; len = FF_MAX; break;\r\ncase EV_SW: bits = dev->swbit; len = SW_MAX; break;\r\ndefault: return -EINVAL;\r\n}\r\nif (type == EV_KEY && size == OLD_KEY_MAX) {\r\nlen = OLD_KEY_MAX;\r\nif (printk_timed_ratelimit(&keymax_warn_time, 10 * 1000))\r\npr_warning("(EVIOCGBIT): Suspicious buffer size %u, "\r\n"limiting output to %zu bytes. See "\r\n"http://userweb.kernel.org/~dtor/eviocgbit-bug.html\n",\r\nOLD_KEY_MAX,\r\nBITS_TO_LONGS(OLD_KEY_MAX) * sizeof(long));\r\n}\r\nreturn bits_to_user(bits, len, size, p, compat_mode);\r\n}\r\nstatic int evdev_handle_get_keycode(struct input_dev *dev, void __user *p)\r\n{\r\nstruct input_keymap_entry ke = {\r\n.len = sizeof(unsigned int),\r\n.flags = 0,\r\n};\r\nint __user *ip = (int __user *)p;\r\nint error;\r\nif (copy_from_user(ke.scancode, p, sizeof(unsigned int)))\r\nreturn -EFAULT;\r\nerror = input_get_keycode(dev, &ke);\r\nif (error)\r\nreturn error;\r\nif (put_user(ke.keycode, ip + 1))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int evdev_handle_get_keycode_v2(struct input_dev *dev, void __user *p)\r\n{\r\nstruct input_keymap_entry ke;\r\nint error;\r\nif (copy_from_user(&ke, p, sizeof(ke)))\r\nreturn -EFAULT;\r\nerror = input_get_keycode(dev, &ke);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(p, &ke, sizeof(ke)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int evdev_handle_set_keycode(struct input_dev *dev, void __user *p)\r\n{\r\nstruct input_keymap_entry ke = {\r\n.len = sizeof(unsigned int),\r\n.flags = 0,\r\n};\r\nint __user *ip = (int __user *)p;\r\nif (copy_from_user(ke.scancode, p, sizeof(unsigned int)))\r\nreturn -EFAULT;\r\nif (get_user(ke.keycode, ip + 1))\r\nreturn -EFAULT;\r\nreturn input_set_keycode(dev, &ke);\r\n}\r\nstatic int evdev_handle_set_keycode_v2(struct input_dev *dev, void __user *p)\r\n{\r\nstruct input_keymap_entry ke;\r\nif (copy_from_user(&ke, p, sizeof(ke)))\r\nreturn -EFAULT;\r\nif (ke.len > sizeof(ke.scancode))\r\nreturn -EINVAL;\r\nreturn input_set_keycode(dev, &ke);\r\n}\r\nstatic int evdev_handle_mt_request(struct input_dev *dev,\r\nunsigned int size,\r\nint __user *ip)\r\n{\r\nconst struct input_mt_slot *mt = dev->mt;\r\nunsigned int code;\r\nint max_slots;\r\nint i;\r\nif (get_user(code, &ip[0]))\r\nreturn -EFAULT;\r\nif (!input_is_mt_value(code))\r\nreturn -EINVAL;\r\nmax_slots = (size - sizeof(__u32)) / sizeof(__s32);\r\nfor (i = 0; i < dev->mtsize && i < max_slots; i++)\r\nif (put_user(input_mt_get_value(&mt[i], code), &ip[1 + i]))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long evdev_do_ioctl(struct file *file, unsigned int cmd,\r\nvoid __user *p, int compat_mode)\r\n{\r\nstruct evdev_client *client = file->private_data;\r\nstruct evdev *evdev = client->evdev;\r\nstruct input_dev *dev = evdev->handle.dev;\r\nstruct input_absinfo abs;\r\nstruct ff_effect effect;\r\nint __user *ip = (int __user *)p;\r\nunsigned int i, t, u, v;\r\nunsigned int size;\r\nint error;\r\nswitch (cmd) {\r\ncase EVIOCGVERSION:\r\nreturn put_user(EV_VERSION, ip);\r\ncase EVIOCGID:\r\nif (copy_to_user(p, &dev->id, sizeof(struct input_id)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase EVIOCGREP:\r\nif (!test_bit(EV_REP, dev->evbit))\r\nreturn -ENOSYS;\r\nif (put_user(dev->rep[REP_DELAY], ip))\r\nreturn -EFAULT;\r\nif (put_user(dev->rep[REP_PERIOD], ip + 1))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase EVIOCSREP:\r\nif (!test_bit(EV_REP, dev->evbit))\r\nreturn -ENOSYS;\r\nif (get_user(u, ip))\r\nreturn -EFAULT;\r\nif (get_user(v, ip + 1))\r\nreturn -EFAULT;\r\ninput_inject_event(&evdev->handle, EV_REP, REP_DELAY, u);\r\ninput_inject_event(&evdev->handle, EV_REP, REP_PERIOD, v);\r\nreturn 0;\r\ncase EVIOCRMFF:\r\nreturn input_ff_erase(dev, (int)(unsigned long) p, file);\r\ncase EVIOCGEFFECTS:\r\ni = test_bit(EV_FF, dev->evbit) ?\r\ndev->ff->max_effects : 0;\r\nif (put_user(i, ip))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase EVIOCGRAB:\r\nif (p)\r\nreturn evdev_grab(evdev, client);\r\nelse\r\nreturn evdev_ungrab(evdev, client);\r\ncase EVIOCSCLOCKID:\r\nif (copy_from_user(&i, p, sizeof(unsigned int)))\r\nreturn -EFAULT;\r\nif (i != CLOCK_MONOTONIC && i != CLOCK_REALTIME)\r\nreturn -EINVAL;\r\nclient->clkid = i;\r\nreturn 0;\r\ncase EVIOCGKEYCODE:\r\nreturn evdev_handle_get_keycode(dev, p);\r\ncase EVIOCSKEYCODE:\r\nreturn evdev_handle_set_keycode(dev, p);\r\ncase EVIOCGKEYCODE_V2:\r\nreturn evdev_handle_get_keycode_v2(dev, p);\r\ncase EVIOCSKEYCODE_V2:\r\nreturn evdev_handle_set_keycode_v2(dev, p);\r\n}\r\nsize = _IOC_SIZE(cmd);\r\n#define EVIOC_MASK_SIZE(nr) ((nr) & ~(_IOC_SIZEMASK << _IOC_SIZESHIFT))\r\nswitch (EVIOC_MASK_SIZE(cmd)) {\r\ncase EVIOCGPROP(0):\r\nreturn bits_to_user(dev->propbit, INPUT_PROP_MAX,\r\nsize, p, compat_mode);\r\ncase EVIOCGMTSLOTS(0):\r\nreturn evdev_handle_mt_request(dev, size, ip);\r\ncase EVIOCGKEY(0):\r\nreturn bits_to_user(dev->key, KEY_MAX, size, p, compat_mode);\r\ncase EVIOCGLED(0):\r\nreturn bits_to_user(dev->led, LED_MAX, size, p, compat_mode);\r\ncase EVIOCGSND(0):\r\nreturn bits_to_user(dev->snd, SND_MAX, size, p, compat_mode);\r\ncase EVIOCGSW(0):\r\nreturn bits_to_user(dev->sw, SW_MAX, size, p, compat_mode);\r\ncase EVIOCGNAME(0):\r\nreturn str_to_user(dev->name, size, p);\r\ncase EVIOCGPHYS(0):\r\nreturn str_to_user(dev->phys, size, p);\r\ncase EVIOCGUNIQ(0):\r\nreturn str_to_user(dev->uniq, size, p);\r\ncase EVIOC_MASK_SIZE(EVIOCSFF):\r\nif (input_ff_effect_from_user(p, size, &effect))\r\nreturn -EFAULT;\r\nerror = input_ff_upload(dev, &effect, file);\r\nif (put_user(effect.id, &(((struct ff_effect __user *)p)->id)))\r\nreturn -EFAULT;\r\nreturn error;\r\n}\r\nif (_IOC_TYPE(cmd) != 'E')\r\nreturn -EINVAL;\r\nif (_IOC_DIR(cmd) == _IOC_READ) {\r\nif ((_IOC_NR(cmd) & ~EV_MAX) == _IOC_NR(EVIOCGBIT(0, 0)))\r\nreturn handle_eviocgbit(dev,\r\n_IOC_NR(cmd) & EV_MAX, size,\r\np, compat_mode);\r\nif ((_IOC_NR(cmd) & ~ABS_MAX) == _IOC_NR(EVIOCGABS(0))) {\r\nif (!dev->absinfo)\r\nreturn -EINVAL;\r\nt = _IOC_NR(cmd) & ABS_MAX;\r\nabs = dev->absinfo[t];\r\nif (copy_to_user(p, &abs, min_t(size_t,\r\nsize, sizeof(struct input_absinfo))))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nif (_IOC_DIR(cmd) == _IOC_WRITE) {\r\nif ((_IOC_NR(cmd) & ~ABS_MAX) == _IOC_NR(EVIOCSABS(0))) {\r\nif (!dev->absinfo)\r\nreturn -EINVAL;\r\nt = _IOC_NR(cmd) & ABS_MAX;\r\nif (copy_from_user(&abs, p, min_t(size_t,\r\nsize, sizeof(struct input_absinfo))))\r\nreturn -EFAULT;\r\nif (size < sizeof(struct input_absinfo))\r\nabs.resolution = 0;\r\nif (t == ABS_MT_SLOT)\r\nreturn -EINVAL;\r\nspin_lock_irq(&dev->event_lock);\r\ndev->absinfo[t] = abs;\r\nspin_unlock_irq(&dev->event_lock);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long evdev_ioctl_handler(struct file *file, unsigned int cmd,\r\nvoid __user *p, int compat_mode)\r\n{\r\nstruct evdev_client *client = file->private_data;\r\nstruct evdev *evdev = client->evdev;\r\nint retval;\r\nretval = mutex_lock_interruptible(&evdev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (!evdev->exist) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nretval = evdev_do_ioctl(file, cmd, p, compat_mode);\r\nout:\r\nmutex_unlock(&evdev->mutex);\r\nreturn retval;\r\n}\r\nstatic long evdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn evdev_ioctl_handler(file, cmd, (void __user *)arg, 0);\r\n}\r\nstatic long evdev_ioctl_compat(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn evdev_ioctl_handler(file, cmd, compat_ptr(arg), 1);\r\n}\r\nstatic int evdev_install_chrdev(struct evdev *evdev)\r\n{\r\nevdev_table[evdev->minor] = evdev;\r\nreturn 0;\r\n}\r\nstatic void evdev_remove_chrdev(struct evdev *evdev)\r\n{\r\nmutex_lock(&evdev_table_mutex);\r\nevdev_table[evdev->minor] = NULL;\r\nmutex_unlock(&evdev_table_mutex);\r\n}\r\nstatic void evdev_mark_dead(struct evdev *evdev)\r\n{\r\nmutex_lock(&evdev->mutex);\r\nevdev->exist = false;\r\nmutex_unlock(&evdev->mutex);\r\n}\r\nstatic void evdev_cleanup(struct evdev *evdev)\r\n{\r\nstruct input_handle *handle = &evdev->handle;\r\nevdev_mark_dead(evdev);\r\nevdev_hangup(evdev);\r\nevdev_remove_chrdev(evdev);\r\nif (evdev->open) {\r\ninput_flush_device(handle, NULL);\r\ninput_close_device(handle);\r\n}\r\n}\r\nstatic int evdev_connect(struct input_handler *handler, struct input_dev *dev,\r\nconst struct input_device_id *id)\r\n{\r\nstruct evdev *evdev;\r\nint minor;\r\nint error;\r\nfor (minor = 0; minor < EVDEV_MINORS; minor++)\r\nif (!evdev_table[minor])\r\nbreak;\r\nif (minor == EVDEV_MINORS) {\r\npr_err("no more free evdev devices\n");\r\nreturn -ENFILE;\r\n}\r\nevdev = kzalloc(sizeof(struct evdev), GFP_KERNEL);\r\nif (!evdev)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&evdev->client_list);\r\nspin_lock_init(&evdev->client_lock);\r\nmutex_init(&evdev->mutex);\r\ninit_waitqueue_head(&evdev->wait);\r\ndev_set_name(&evdev->dev, "event%d", minor);\r\nevdev->exist = true;\r\nevdev->minor = minor;\r\nevdev->handle.dev = input_get_device(dev);\r\nevdev->handle.name = dev_name(&evdev->dev);\r\nevdev->handle.handler = handler;\r\nevdev->handle.private = evdev;\r\nevdev->dev.devt = MKDEV(INPUT_MAJOR, EVDEV_MINOR_BASE + minor);\r\nevdev->dev.class = &input_class;\r\nevdev->dev.parent = &dev->dev;\r\nevdev->dev.release = evdev_free;\r\ndevice_initialize(&evdev->dev);\r\nerror = input_register_handle(&evdev->handle);\r\nif (error)\r\ngoto err_free_evdev;\r\nerror = evdev_install_chrdev(evdev);\r\nif (error)\r\ngoto err_unregister_handle;\r\nerror = device_add(&evdev->dev);\r\nif (error)\r\ngoto err_cleanup_evdev;\r\nreturn 0;\r\nerr_cleanup_evdev:\r\nevdev_cleanup(evdev);\r\nerr_unregister_handle:\r\ninput_unregister_handle(&evdev->handle);\r\nerr_free_evdev:\r\nput_device(&evdev->dev);\r\nreturn error;\r\n}\r\nstatic void evdev_disconnect(struct input_handle *handle)\r\n{\r\nstruct evdev *evdev = handle->private;\r\ndevice_del(&evdev->dev);\r\nevdev_cleanup(evdev);\r\ninput_unregister_handle(handle);\r\nput_device(&evdev->dev);\r\n}\r\nstatic int __init evdev_init(void)\r\n{\r\nreturn input_register_handler(&evdev_handler);\r\n}\r\nstatic void __exit evdev_exit(void)\r\n{\r\ninput_unregister_handler(&evdev_handler);\r\n}
