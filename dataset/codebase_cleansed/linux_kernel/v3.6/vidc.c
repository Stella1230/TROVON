static void\r\nvidc_mixer_set(int mdev, unsigned int level)\r\n{\r\nunsigned int lev_l = level & 0x007f;\r\nunsigned int lev_r = (level & 0x7f00) >> 8;\r\nunsigned int mlev_l, mlev_r;\r\nif (lev_l > 100)\r\nlev_l = 100;\r\nif (lev_r > 100)\r\nlev_r = 100;\r\n#define SCALE(lev,master) ((lev) * (master) * 65536 / 10000)\r\nmlev_l = vidc_level_l[SOUND_MIXER_VOLUME];\r\nmlev_r = vidc_level_r[SOUND_MIXER_VOLUME];\r\nswitch (mdev) {\r\ncase SOUND_MIXER_VOLUME:\r\ncase SOUND_MIXER_PCM:\r\nvidc_level_l[mdev] = lev_l;\r\nvidc_level_r[mdev] = lev_r;\r\nvidc_audio_volume_l = SCALE(lev_l, mlev_l);\r\nvidc_audio_volume_r = SCALE(lev_r, mlev_r);\r\nbreak;\r\n}\r\n#undef SCALE\r\n}\r\nstatic int vidc_mixer_ioctl(int dev, unsigned int cmd, void __user *arg)\r\n{\r\nunsigned int val;\r\nunsigned int mdev;\r\nif (_SIOC_TYPE(cmd) != 'M')\r\nreturn -EINVAL;\r\nmdev = _SIOC_NR(cmd);\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE) {\r\nif (get_user(val, (unsigned int __user *)arg))\r\nreturn -EFAULT;\r\nif (mdev < SOUND_MIXER_NRDEVICES)\r\nvidc_mixer_set(mdev, val);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nswitch (mdev) {\r\ncase SOUND_MIXER_RECSRC:\r\nval = 0;\r\nbreak;\r\ncase SOUND_MIXER_DEVMASK:\r\nval = SOUND_MASK_VOLUME | SOUND_MASK_PCM | SOUND_MASK_SYNTH;\r\nbreak;\r\ncase SOUND_MIXER_STEREODEVS:\r\nval = SOUND_MASK_VOLUME | SOUND_MASK_PCM | SOUND_MASK_SYNTH;\r\nbreak;\r\ncase SOUND_MIXER_RECMASK:\r\nval = 0;\r\nbreak;\r\ncase SOUND_MIXER_CAPS:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nif (mdev < SOUND_MIXER_NRDEVICES)\r\nval = vidc_level_l[mdev] | vidc_level_r[mdev] << 8;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn put_user(val, (unsigned int __user *)arg) ? -EFAULT : 0;\r\n}\r\nstatic unsigned int vidc_audio_set_format(int dev, unsigned int fmt)\r\n{\r\nswitch (fmt) {\r\ndefault:\r\nfmt = AFMT_S16_LE;\r\ncase AFMT_U8:\r\ncase AFMT_S8:\r\ncase AFMT_S16_LE:\r\nvidc_audio_format = fmt;\r\nvidc_update_filler(vidc_audio_format, vidc_audio_channels);\r\ncase AFMT_QUERY:\r\nbreak;\r\n}\r\nreturn vidc_audio_format;\r\n}\r\nstatic int vidc_audio_set_speed(int dev, int rate)\r\n{\r\nif (rate) {\r\nunsigned int hwctrl, hwrate, hwrate_ext, rate_int, rate_ext;\r\nunsigned int diff_int, diff_ext;\r\nunsigned int newsize, new2size;\r\nhwctrl = 0x00000003;\r\nhwrate = (((VIDC_SOUND_CLOCK * 2) / rate) + 1) >> 1;\r\nif (hwrate < 3)\r\nhwrate = 3;\r\nif (hwrate > 255)\r\nhwrate = 255;\r\nhwrate_ext = (((VIDC_SOUND_CLOCK_EXT * 2) / rate) + 1) >> 1;\r\nif (hwrate_ext < 3)\r\nhwrate_ext = 3;\r\nif (hwrate_ext > 255)\r\nhwrate_ext = 255;\r\nrate_int = VIDC_SOUND_CLOCK / hwrate;\r\nrate_ext = VIDC_SOUND_CLOCK_EXT / hwrate_ext;\r\ndiff_int = my_abs(rate_ext-rate);\r\ndiff_ext = my_abs(rate_int-rate);\r\nif (diff_ext < diff_int) {\r\nhwrate=hwrate_ext;\r\nhwctrl=0x00000002;\r\nif (diff_ext > (rate/256))\r\nrate=rate_ext;\r\n} else {\r\nhwctrl=0x00000003;\r\nif (diff_int > (rate/256))\r\nrate=rate_int;\r\n}\r\nvidc_writel(0xb0000000 | (hwrate - 2));\r\nvidc_writel(0xb1000000 | hwctrl);\r\nnewsize = (10000 / hwrate) & ~3;\r\nif (newsize < 208)\r\nnewsize = 208;\r\nif (newsize > 4096)\r\nnewsize = 4096;\r\nfor (new2size = 128; new2size < newsize; new2size <<= 1);\r\nif (new2size - newsize > newsize - (new2size >> 1))\r\nnew2size >>= 1;\r\nif (new2size > 4096) {\r\nprintk(KERN_ERR "VIDC: error: dma buffer (%d) %d > 4K\n",\r\nnewsize, new2size);\r\nnew2size = 4096;\r\n}\r\ndma_bufsize = new2size;\r\nvidc_audio_rate = rate;\r\n}\r\nreturn vidc_audio_rate;\r\n}\r\nstatic short vidc_audio_set_channels(int dev, short channels)\r\n{\r\nswitch (channels) {\r\ndefault:\r\nchannels = 2;\r\ncase 1:\r\ncase 2:\r\nvidc_audio_channels = channels;\r\nvidc_update_filler(vidc_audio_format, vidc_audio_channels);\r\ncase 0:\r\nbreak;\r\n}\r\nreturn vidc_audio_channels;\r\n}\r\nstatic int vidc_audio_open(int dev, int mode)\r\n{\r\nif (mode == OPEN_READ)\r\nreturn -EPERM;\r\nif (vidc_busy)\r\nreturn -EBUSY;\r\nvidc_busy = 1;\r\nreturn 0;\r\n}\r\nstatic void vidc_audio_close(int dev)\r\n{\r\nvidc_busy = 0;\r\n}\r\nstatic void\r\nvidc_audio_output_block(int dev, unsigned long buf, int total_count, int one)\r\n{\r\nstruct dma_buffparms *dmap = audio_devs[dev]->dmap_out;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ndma_start = buf - (unsigned long)dmap->raw_buf_phys + (unsigned long)dmap->raw_buf;\r\ndma_count = total_count;\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void\r\nvidc_audio_start_input(int dev, unsigned long buf, int count, int intrflag)\r\n{\r\n}\r\nstatic int vidc_audio_prepare_for_input(int dev, int bsize, int bcount)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t vidc_audio_dma_interrupt(void)\r\n{\r\nDMAbuf_outputintr(vidc_adev, 1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vidc_audio_prepare_for_output(int dev, int bsize, int bcount)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\ndma_interrupt = NULL;\r\nadev->dmap_out->flags |= DMA_NODMA;\r\nreturn 0;\r\n}\r\nstatic void vidc_audio_reset(int dev)\r\n{\r\ndma_interrupt = NULL;\r\n}\r\nstatic int vidc_audio_local_qlen(int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vidc_audio_trigger(int dev, int enable_bits)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nif (enable_bits & PCM_ENABLE_OUTPUT) {\r\nif (!(adev->dmap_out->flags & DMA_ACTIVE)) {\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nadev->dmap_out->flags |= DMA_ACTIVE;\r\ndma_interrupt = vidc_audio_dma_interrupt;\r\nvidc_sound_dma_irq(0, NULL);\r\niomd_writeb(DMA_CR_E | 0x10, IOMD_SD0CR);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\n}\r\nvoid vidc_update_filler(int format, int channels)\r\n{\r\n#define TYPE(fmt,ch) (((fmt)<<2) | ((ch)&3))\r\nswitch (TYPE(format, channels)) {\r\ndefault:\r\ncase TYPE(AFMT_U8, 1):\r\nvidc_filler = vidc_fill_1x8_u;\r\nbreak;\r\ncase TYPE(AFMT_U8, 2):\r\nvidc_filler = vidc_fill_2x8_u;\r\nbreak;\r\ncase TYPE(AFMT_S8, 1):\r\nvidc_filler = vidc_fill_1x8_s;\r\nbreak;\r\ncase TYPE(AFMT_S8, 2):\r\nvidc_filler = vidc_fill_2x8_s;\r\nbreak;\r\ncase TYPE(AFMT_S16_LE, 1):\r\nvidc_filler = vidc_fill_1x16_s;\r\nbreak;\r\ncase TYPE(AFMT_S16_LE, 2):\r\nvidc_filler = vidc_fill_2x16_s;\r\nbreak;\r\n}\r\n}\r\nstatic void __init attach_vidc(struct address_info *hw_config)\r\n{\r\nchar name[32];\r\nint i, adev;\r\nsprintf(name, "VIDC %d-bit sound", hw_config->card_subtype);\r\nconf_printf(name, hw_config);\r\nmemset(dma_buf, 0, sizeof(dma_buf));\r\nadev = sound_install_audiodrv(AUDIO_DRIVER_VERSION, name,\r\n&vidc_audio_driver, sizeof(vidc_audio_driver),\r\nDMA_AUTOMODE, AFMT_U8 | AFMT_S8 | AFMT_S16_LE,\r\nNULL, hw_config->dma, hw_config->dma2);\r\nif (adev < 0)\r\ngoto audio_failed;\r\naudio_devs[adev]->min_fragment = 10;\r\naudio_devs[adev]->mixer_dev = num_mixers;\r\naudio_devs[adev]->mixer_dev =\r\nsound_install_mixer(MIXER_DRIVER_VERSION,\r\nname, &vidc_mixer_operations,\r\nsizeof(vidc_mixer_operations), NULL);\r\nif (audio_devs[adev]->mixer_dev < 0)\r\ngoto mixer_failed;\r\nfor (i = 0; i < 2; i++) {\r\ndma_buf[i] = get_zeroed_page(GFP_KERNEL);\r\nif (!dma_buf[i]) {\r\nprintk(KERN_ERR "%s: can't allocate required buffers\n",\r\nname);\r\ngoto mem_failed;\r\n}\r\ndma_pbuf[i] = virt_to_phys((void *)dma_buf[i]);\r\n}\r\nif (sound_alloc_dma(hw_config->dma, hw_config->name)) {\r\nprintk(KERN_ERR "%s: DMA %d is in use\n", name, hw_config->dma);\r\ngoto dma_failed;\r\n}\r\nif (request_irq(hw_config->irq, vidc_sound_dma_irq, 0,\r\nhw_config->name, &dma_start)) {\r\nprintk(KERN_ERR "%s: IRQ %d is in use\n", name, hw_config->irq);\r\ngoto irq_failed;\r\n}\r\nvidc_adev = adev;\r\nvidc_mixer_set(SOUND_MIXER_VOLUME, (85 | 85 << 8));\r\nreturn;\r\nirq_failed:\r\nsound_free_dma(hw_config->dma);\r\ndma_failed:\r\nmem_failed:\r\nfor (i = 0; i < 2; i++)\r\nfree_page(dma_buf[i]);\r\nsound_unload_mixerdev(audio_devs[adev]->mixer_dev);\r\nmixer_failed:\r\nsound_unload_audiodev(adev);\r\naudio_failed:\r\nreturn;\r\n}\r\nstatic int __init probe_vidc(struct address_info *hw_config)\r\n{\r\nhw_config->irq = IRQ_DMAS0;\r\nhw_config->dma = DMA_VIRTUAL_SOUND;\r\nhw_config->dma2 = -1;\r\nhw_config->card_subtype = 16;\r\nhw_config->name = "VIDC20";\r\nreturn 1;\r\n}\r\nstatic void __exit unload_vidc(struct address_info *hw_config)\r\n{\r\nint i, adev = vidc_adev;\r\nvidc_adev = -1;\r\nfree_irq(hw_config->irq, &dma_start);\r\nsound_free_dma(hw_config->dma);\r\nif (adev >= 0) {\r\nsound_unload_mixerdev(audio_devs[adev]->mixer_dev);\r\nsound_unload_audiodev(adev);\r\nfor (i = 0; i < 2; i++)\r\nfree_page(dma_buf[i]);\r\n}\r\n}\r\nstatic int __init init_vidc(void)\r\n{\r\nif (probe_vidc(&cfg) == 0)\r\nreturn -ENODEV;\r\nattach_vidc(&cfg);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_vidc(void)\r\n{\r\nunload_vidc(&cfg);\r\n}
