static inline u32 mc_readl(struct tegra20_mc *mc, u32 offs)\r\n{\r\nu32 val = 0;\r\nif (offs < 0x24)\r\nval = readl(mc->regs[0] + offs);\r\nif (offs < 0x400)\r\nval = readl(mc->regs[1] + offs - 0x3c);\r\nreturn val;\r\n}\r\nstatic inline void mc_writel(struct tegra20_mc *mc, u32 val, u32 offs)\r\n{\r\nif (offs < 0x24) {\r\nwritel(val, mc->regs[0] + offs);\r\nreturn;\r\n}\r\nif (offs < 0x400) {\r\nwritel(val, mc->regs[1] + offs - 0x3c);\r\nreturn;\r\n}\r\n}\r\nstatic void tegra20_mc_decode(struct tegra20_mc *mc, int n)\r\n{\r\nu32 addr, req;\r\nconst char *client = "Unknown";\r\nint idx, cid;\r\nconst struct reg_info {\r\nu32 offset;\r\nu32 write_bit;\r\nint cid_shift;\r\nchar *message;\r\n} reg[] = {\r\n{\r\n.offset = MC_DECERR_EMEM_OTHERS_STATUS,\r\n.write_bit = 31,\r\n.message = "MC_DECERR",\r\n},\r\n{\r\n.offset = MC_GART_ERROR_REQ,\r\n.cid_shift = 1,\r\n.message = "MC_GART_ERR",\r\n},\r\n{\r\n.offset = MC_SECURITY_VIOLATION_STATUS,\r\n.write_bit = 31,\r\n.message = "MC_SECURITY_ERR",\r\n},\r\n};\r\nidx = n - MC_INT_ERR_SHIFT;\r\nif ((idx < 0) || (idx >= ARRAY_SIZE(reg))) {\r\ndev_err_ratelimited(mc->dev, "Unknown interrupt status %08lx\n",\r\nBIT(n));\r\nreturn;\r\n}\r\nreq = mc_readl(mc, reg[idx].offset);\r\ncid = (req >> reg[idx].cid_shift) & MC_CLIENT_ID_MASK;\r\nif (cid < ARRAY_SIZE(tegra20_mc_client))\r\nclient = tegra20_mc_client[cid];\r\naddr = mc_readl(mc, reg[idx].offset + sizeof(u32));\r\ndev_err_ratelimited(mc->dev, "%s (0x%08x): 0x%08x %s (%s %s)\n",\r\nreg[idx].message, req, addr, client,\r\n(req & BIT(reg[idx].write_bit)) ? "write" : "read",\r\n(reg[idx].offset == MC_SECURITY_VIOLATION_STATUS) ?\r\n((req & SECURITY_VIOLATION_TYPE) ?\r\n"carveout" : "trustzone") : "");\r\n}\r\nstatic irqreturn_t tegra20_mc_isr(int irq, void *data)\r\n{\r\nu32 stat, mask, bit;\r\nstruct tegra20_mc *mc = data;\r\nstat = mc_readl(mc, MC_INTSTATUS);\r\nmask = mc_readl(mc, MC_INTMASK);\r\nmask &= stat;\r\nif (!mask)\r\nreturn IRQ_NONE;\r\nwhile ((bit = ffs(mask)) != 0)\r\ntegra20_mc_decode(mc, bit - 1);\r\nmc_writel(mc, stat, MC_INTSTATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit tegra20_mc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *irq;\r\nstruct tegra20_mc *mc;\r\nint i, err;\r\nu32 intmask;\r\nmc = devm_kzalloc(&pdev->dev, sizeof(*mc), GFP_KERNEL);\r\nif (!mc)\r\nreturn -ENOMEM;\r\nmc->dev = &pdev->dev;\r\nfor (i = 0; i < ARRAY_SIZE(mc->regs); i++) {\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res)\r\nreturn -ENODEV;\r\nmc->regs[i] = devm_request_and_ioremap(&pdev->dev, res);\r\nif (!mc->regs[i])\r\nreturn -EBUSY;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq)\r\nreturn -ENODEV;\r\nerr = devm_request_irq(&pdev->dev, irq->start, tegra20_mc_isr,\r\nIRQF_SHARED, dev_name(&pdev->dev), mc);\r\nif (err)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, mc);\r\nintmask = MC_INT_INVALID_GART_PAGE |\r\nMC_INT_DECERR_EMEM | MC_INT_SECURITY_VIOLATION;\r\nmc_writel(mc, intmask, MC_INTMASK);\r\nreturn 0;\r\n}
