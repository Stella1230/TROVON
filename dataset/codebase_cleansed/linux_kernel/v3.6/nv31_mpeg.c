static int\r\nnv31_mpeg_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nv31_mpeg_engine *pmpeg = nv_engine(chan->dev, engine);\r\nif (!atomic_add_unless(&pmpeg->refcount, 1, 1))\r\nreturn -EBUSY;\r\nchan->engctx[engine] = (void *)0xdeadcafe;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv31_mpeg_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nv31_mpeg_engine *pmpeg = nv_engine(chan->dev, engine);\r\natomic_dec(&pmpeg->refcount);\r\nchan->engctx[engine] = NULL;\r\n}\r\nstatic int\r\nnv40_mpeg_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *ctx = NULL;\r\nunsigned long flags;\r\nint ret;\r\nNV_DEBUG(dev, "ch%d\n", chan->id);\r\nret = nouveau_gpuobj_new(dev, NULL, 264 * 4, 16, NVOBJ_FLAG_ZERO_ALLOC |\r\nNVOBJ_FLAG_ZERO_FREE, &ctx);\r\nif (ret)\r\nreturn ret;\r\nnv_wo32(ctx, 0x78, 0x02001ec1);\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_mask(dev, 0x002500, 0x00000001, 0x00000000);\r\nif ((nv_rd32(dev, 0x003204) & 0x1f) == chan->id)\r\nnv_wr32(dev, 0x00330c, ctx->pinst >> 4);\r\nnv_wo32(chan->ramfc, 0x54, ctx->pinst >> 4);\r\nnv_mask(dev, 0x002500, 0x00000001, 0x00000001);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nchan->engctx[engine] = ctx;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv40_mpeg_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = chan->dev->dev_private;\r\nstruct nouveau_gpuobj *ctx = chan->engctx[engine];\r\nstruct drm_device *dev = chan->dev;\r\nunsigned long flags;\r\nu32 inst = 0x80000000 | (ctx->pinst >> 4);\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_mask(dev, 0x00b32c, 0x00000001, 0x00000000);\r\nif (nv_rd32(dev, 0x00b318) == inst)\r\nnv_mask(dev, 0x00b318, 0x80000000, 0x00000000);\r\nnv_mask(dev, 0x00b32c, 0x00000001, 0x00000001);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nnouveau_gpuobj_ref(NULL, &ctx);\r\nchan->engctx[engine] = NULL;\r\n}\r\nstatic int\r\nnv31_mpeg_object_new(struct nouveau_channel *chan, int engine,\r\nu32 handle, u16 class)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct nouveau_gpuobj *obj = NULL;\r\nint ret;\r\nret = nouveau_gpuobj_new(dev, chan, 20, 16, NVOBJ_FLAG_ZERO_ALLOC |\r\nNVOBJ_FLAG_ZERO_FREE, &obj);\r\nif (ret)\r\nreturn ret;\r\nobj->engine = 2;\r\nobj->class = class;\r\nnv_wo32(obj, 0x00, class);\r\nret = nouveau_ramht_insert(chan, handle, obj);\r\nnouveau_gpuobj_ref(NULL, &obj);\r\nreturn ret;\r\n}\r\nstatic int\r\nnv31_mpeg_init(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv31_mpeg_engine *pmpeg = nv_engine(dev, engine);\r\nint i;\r\nnv_mask(dev, 0x000200, 0x00000002, 0x00000000);\r\nnv_mask(dev, 0x000200, 0x00000002, 0x00000002);\r\nnv_wr32(dev, 0x00b0e0, 0x00000020);\r\nnv_wr32(dev, 0x00b0e8, 0x00000020);\r\nfor (i = 0; i < dev_priv->engine.fb.num_tiles; i++)\r\npmpeg->base.set_tile_region(dev, i);\r\nnv_wr32(dev, 0x00b32c, 0x00000000);\r\nnv_wr32(dev, 0x00b314, 0x00000100);\r\nnv_wr32(dev, 0x00b220, nv44_graph_class(dev) ? 0x00000044 : 0x00000031);\r\nnv_wr32(dev, 0x00b300, 0x02001ec1);\r\nnv_mask(dev, 0x00b32c, 0x00000001, 0x00000001);\r\nnv_wr32(dev, 0x00b100, 0xffffffff);\r\nnv_wr32(dev, 0x00b140, 0xffffffff);\r\nif (!nv_wait(dev, 0x00b200, 0x00000001, 0x00000000)) {\r\nNV_ERROR(dev, "PMPEG init: 0x%08x\n", nv_rd32(dev, 0x00b200));\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv31_mpeg_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nnv_mask(dev, 0x00b32c, 0x00000001, 0x00000000);\r\nnv_wr32(dev, 0x00b140, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv31_mpeg_mthd_dma(struct nouveau_channel *chan, u32 class, u32 mthd, u32 data)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nu32 inst = data << 4;\r\nu32 dma0 = nv_ri32(dev, inst + 0);\r\nu32 dma1 = nv_ri32(dev, inst + 4);\r\nu32 dma2 = nv_ri32(dev, inst + 8);\r\nu32 base = (dma2 & 0xfffff000) | (dma0 >> 20);\r\nu32 size = dma1 + 1;\r\nif (!(dma0 & 0x00002000))\r\nreturn -EINVAL;\r\nif (mthd == 0x0190) {\r\nnv_mask(dev, 0x00b300, 0x00030000, (dma0 & 0x00030000));\r\nnv_wr32(dev, 0x00b334, base);\r\nnv_wr32(dev, 0x00b324, size);\r\n} else\r\nif (mthd == 0x01a0) {\r\nnv_mask(dev, 0x00b300, 0x000c0000, (dma0 & 0x00030000) << 2);\r\nnv_wr32(dev, 0x00b360, base);\r\nnv_wr32(dev, 0x00b364, size);\r\n} else {\r\nif (dma0 & 0x000c0000)\r\nreturn -EINVAL;\r\nnv_wr32(dev, 0x00b370, base);\r\nnv_wr32(dev, 0x00b374, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv31_mpeg_isr_chid(struct drm_device *dev, u32 inst)\r\n{\r\nstruct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *ctx;\r\nunsigned long flags;\r\nint i;\r\nif (dev_priv->card_type < NV_40)\r\nreturn 0;\r\nspin_lock_irqsave(&dev_priv->channels.lock, flags);\r\nfor (i = 0; i < pfifo->channels; i++) {\r\nif (!dev_priv->channels.ptr[i])\r\ncontinue;\r\nctx = dev_priv->channels.ptr[i]->engctx[NVOBJ_ENGINE_MPEG];\r\nif (ctx && ctx->pinst == inst)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dev_priv->channels.lock, flags);\r\nreturn i;\r\n}\r\nstatic void\r\nnv31_vpe_set_tile_region(struct drm_device *dev, int i)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_tile_reg *tile = &dev_priv->tile.reg[i];\r\nnv_wr32(dev, 0x00b008 + (i * 0x10), tile->pitch);\r\nnv_wr32(dev, 0x00b004 + (i * 0x10), tile->limit);\r\nnv_wr32(dev, 0x00b000 + (i * 0x10), tile->addr);\r\n}\r\nstatic void\r\nnv31_mpeg_isr(struct drm_device *dev)\r\n{\r\nu32 inst = (nv_rd32(dev, 0x00b318) & 0x000fffff) << 4;\r\nu32 chid = nv31_mpeg_isr_chid(dev, inst);\r\nu32 stat = nv_rd32(dev, 0x00b100);\r\nu32 type = nv_rd32(dev, 0x00b230);\r\nu32 mthd = nv_rd32(dev, 0x00b234);\r\nu32 data = nv_rd32(dev, 0x00b238);\r\nu32 show = stat;\r\nif (stat & 0x01000000) {\r\nif (type == 0x00000020 && mthd == 0x0000) {\r\nnv_mask(dev, 0x00b308, 0x00000000, 0x00000000);\r\nshow &= ~0x01000000;\r\n}\r\nif (type == 0x00000010) {\r\nif (!nouveau_gpuobj_mthd_call2(dev, chid, 0x3174, mthd, data))\r\nshow &= ~0x01000000;\r\n}\r\n}\r\nnv_wr32(dev, 0x00b100, stat);\r\nnv_wr32(dev, 0x00b230, 0x00000001);\r\nif (show && nouveau_ratelimit()) {\r\nNV_INFO(dev, "PMPEG: Ch %d [0x%08x] 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\nchid, inst, stat, type, mthd, data);\r\n}\r\n}\r\nstatic void\r\nnv31_vpe_isr(struct drm_device *dev)\r\n{\r\nif (nv_rd32(dev, 0x00b100))\r\nnv31_mpeg_isr(dev);\r\nif (nv_rd32(dev, 0x00b800)) {\r\nu32 stat = nv_rd32(dev, 0x00b800);\r\nNV_INFO(dev, "PMSRCH: 0x%08x\n", stat);\r\nnv_wr32(dev, 0xb800, stat);\r\n}\r\n}\r\nstatic void\r\nnv31_mpeg_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nv31_mpeg_engine *pmpeg = nv_engine(dev, engine);\r\nnouveau_irq_unregister(dev, 0);\r\nNVOBJ_ENGINE_DEL(dev, MPEG);\r\nkfree(pmpeg);\r\n}\r\nint\r\nnv31_mpeg_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv31_mpeg_engine *pmpeg;\r\npmpeg = kzalloc(sizeof(*pmpeg), GFP_KERNEL);\r\nif (!pmpeg)\r\nreturn -ENOMEM;\r\natomic_set(&pmpeg->refcount, 0);\r\npmpeg->base.destroy = nv31_mpeg_destroy;\r\npmpeg->base.init = nv31_mpeg_init;\r\npmpeg->base.fini = nv31_mpeg_fini;\r\nif (dev_priv->card_type < NV_40) {\r\npmpeg->base.context_new = nv31_mpeg_context_new;\r\npmpeg->base.context_del = nv31_mpeg_context_del;\r\n} else {\r\npmpeg->base.context_new = nv40_mpeg_context_new;\r\npmpeg->base.context_del = nv40_mpeg_context_del;\r\n}\r\npmpeg->base.object_new = nv31_mpeg_object_new;\r\npmpeg->base.set_tile_region = nv31_vpe_set_tile_region;\r\nnouveau_irq_register(dev, 0, nv31_vpe_isr);\r\nNVOBJ_ENGINE_ADD(dev, MPEG, &pmpeg->base);\r\nNVOBJ_CLASS(dev, 0x3174, MPEG);\r\nNVOBJ_MTHD (dev, 0x3174, 0x0190, nv31_mpeg_mthd_dma);\r\nNVOBJ_MTHD (dev, 0x3174, 0x01a0, nv31_mpeg_mthd_dma);\r\nNVOBJ_MTHD (dev, 0x3174, 0x01b0, nv31_mpeg_mthd_dma);\r\n#if 0\r\nNVOBJ_ENGINE_ADD(dev, ME, &pme->base);\r\nNVOBJ_CLASS(dev, 0x4075, ME);\r\n#endif\r\nreturn 0;\r\n}
