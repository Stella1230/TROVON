static void start_timing(void)\r\n{\r\ntiming_stats.start_time = jiffies;\r\n}\r\nstatic void end_read_timing(unsigned length)\r\n{\r\ntiming_stats.read_time += (jiffies - start_time);\r\ntiming_stats.read_bytes += length + 2;\r\nreport_timing();\r\n}\r\nstatic void end_write_timing(unsigned length)\r\n{\r\ntiming_stats.write_time += (jiffies - start_time);\r\ntiming_stats.write_bytes += length + 2;\r\nreport_timing();\r\n}\r\nstatic void report_timing(void)\r\n{\r\nunsigned long since = jiffies - timing_stats.last_report_time;\r\nif (since >= HZ) {\r\nint first = (timing_stats.last_report_time == 0);\r\ntiming_stats.last_report_time = jiffies;\r\nif (!first)\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": %u us elapsed - read %lu bytes in %u us, wrote %lu bytes in %u us\n",\r\njiffies_to_usecs(since),\r\ntiming_stats.read_bytes,\r\njiffies_to_usecs(timing_stats.read_time),\r\ntiming_stats.write_bytes,\r\njiffies_to_usecs(timing_stats.write_time));\r\ntiming_stats.read_time = 0;\r\ntiming_stats.write_time = 0;\r\ntiming_stats.read_bytes = 0;\r\ntiming_stats.write_bytes = 0;\r\n}\r\n}\r\nstatic void start_timing(void) { }\r\nstatic void end_read_timing(unsigned length) { }\r\nstatic void end_write_timing(unsigned length) { }\r\nstatic char *data_type(const unsigned char *buf, unsigned length)\r\n{\r\nstruct nl_packet_header *hdr = (struct nl_packet_header *) buf;\r\nif (length == 0)\r\nreturn " ";\r\nif (hdr->packet_rank & NL_FIRST_PACKET) {\r\nswitch (hdr->protocol) {\r\ncase TL_PROTOCOLID_COM_DATA: return "DATA ";\r\ncase TL_PROTOCOLID_COM_CTRL: return "CTRL ";\r\ncase TL_PROTOCOLID_SETUP: return "SETUP";\r\ndefault: return "???? ";\r\n}\r\n} else\r\nreturn " ";\r\n}\r\nstatic void dump_data_bytes(const char *type, const unsigned char *data,\r\nunsigned length)\r\n{\r\nchar prefix[56];\r\nsprintf(prefix, IPWIRELESS_PCCARD_NAME ": %s %s ",\r\ntype, data_type(data, length));\r\nprint_hex_dump_bytes(prefix, 0, (void *)data,\r\nlength < DUMP_MAX_BYTES ? length : DUMP_MAX_BYTES);\r\n}\r\nstatic void swap_packet_bitfield_to_le(unsigned char *data)\r\n{\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\nunsigned char tmp = *data, ret = 0;\r\nret |= tmp & 0xc0 >> 6;\r\nret |= tmp & 0x38 >> 1;\r\nret |= tmp & 0x07 << 5;\r\n*data = ret & 0xff;\r\n#endif\r\n}\r\nstatic void swap_packet_bitfield_from_le(unsigned char *data)\r\n{\r\n#ifdef __BIG_ENDIAN_BITFIELD\r\nunsigned char tmp = *data, ret = 0;\r\nret |= tmp & 0xe0 >> 5;\r\nret |= tmp & 0x1c << 1;\r\nret |= tmp & 0x03 << 6;\r\n*data = ret & 0xff;\r\n#endif\r\n}\r\nstatic void do_send_fragment(struct ipw_hardware *hw, unsigned char *data,\r\nunsigned length)\r\n{\r\nunsigned i;\r\nunsigned long flags;\r\nstart_timing();\r\nBUG_ON(length > hw->ll_mtu);\r\nif (ipwireless_debug)\r\ndump_data_bytes("send", data, length);\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->tx_ready = 0;\r\nswap_packet_bitfield_to_le(data);\r\nif (hw->hw_version == HW_VERSION_1) {\r\noutw((unsigned short) length, hw->base_port + IODWR);\r\nfor (i = 0; i < length; i += 2) {\r\nunsigned short d = data[i];\r\n__le16 raw_data;\r\nif (i + 1 < length)\r\nd |= data[i + 1] << 8;\r\nraw_data = cpu_to_le16(d);\r\noutw(raw_data, hw->base_port + IODWR);\r\n}\r\noutw(DCR_TXDONE, hw->base_port + IODCR);\r\n} else if (hw->hw_version == HW_VERSION_2) {\r\noutw((unsigned short) length, hw->base_port);\r\nfor (i = 0; i < length; i += 2) {\r\nunsigned short d = data[i];\r\n__le16 raw_data;\r\nif (i + 1 < length)\r\nd |= data[i + 1] << 8;\r\nraw_data = cpu_to_le16(d);\r\noutw(raw_data, hw->base_port);\r\n}\r\nwhile ((i & 3) != 2) {\r\noutw((unsigned short) 0xDEAD, hw->base_port);\r\ni += 2;\r\n}\r\nwritew(MEMRX_RX, &hw->memory_info_regs->memreg_rx);\r\n}\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nend_write_timing(length);\r\n}\r\nstatic void do_send_packet(struct ipw_hardware *hw, struct ipw_tx_packet *packet)\r\n{\r\nunsigned short fragment_data_len;\r\nunsigned short data_left = packet->length - packet->offset;\r\nunsigned short header_size;\r\nunion nl_packet pkt;\r\nheader_size =\r\n(packet->fragment_count == 0)\r\n? NL_FIRST_PACKET_HEADER_SIZE\r\n: NL_FOLLOWING_PACKET_HEADER_SIZE;\r\nfragment_data_len = hw->ll_mtu - header_size;\r\nif (data_left < fragment_data_len)\r\nfragment_data_len = data_left;\r\npkt.hdr_first.protocol = packet->protocol;\r\npkt.hdr_first.address = packet->dest_addr;\r\npkt.hdr_first.packet_rank = 0;\r\nif (packet->fragment_count == 0) {\r\npkt.hdr_first.packet_rank |= NL_FIRST_PACKET;\r\npkt.hdr_first.length_lsb = (unsigned char) packet->length;\r\npkt.hdr_first.length_msb =\r\n(unsigned char) (packet->length >> 8);\r\n}\r\nmemcpy(pkt.rawpkt + header_size,\r\n((unsigned char *) packet) + sizeof(struct ipw_tx_packet) +\r\npacket->offset, fragment_data_len);\r\npacket->offset += fragment_data_len;\r\npacket->fragment_count++;\r\nif (packet->offset == packet->length)\r\npkt.hdr_first.packet_rank |= NL_LAST_PACKET;\r\ndo_send_fragment(hw, pkt.rawpkt, header_size + fragment_data_len);\r\nif (packet->offset < packet->length) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nlist_add(&packet->queue, &hw->tx_queue[0]);\r\nhw->tx_queued++;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n} else {\r\nif (packet->packet_callback)\r\npacket->packet_callback(packet->callback_data,\r\npacket->length);\r\nkfree(packet);\r\n}\r\n}\r\nstatic void ipw_setup_hardware(struct ipw_hardware *hw)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nif (hw->hw_version == HW_VERSION_1) {\r\noutw(DCR_RXRESET, hw->base_port + IODCR);\r\noutw(DCR_TXRESET, hw->base_port + IODCR);\r\noutw(IER_TXENABLED | IER_RXENABLED, hw->base_port + IOIER);\r\n} else {\r\nunsigned short csr = readw(&hw->memregs_CCR->reg_config_and_status);\r\ncsr |= 1;\r\nwritew(csr, &hw->memregs_CCR->reg_config_and_status);\r\n}\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\nstatic struct ipw_rx_packet *pool_allocate(struct ipw_hardware *hw,\r\nstruct ipw_rx_packet *packet,\r\nint minimum_free_space)\r\n{\r\nif (!packet) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nif (!list_empty(&hw->rx_pool)) {\r\npacket = list_first_entry(&hw->rx_pool,\r\nstruct ipw_rx_packet, queue);\r\nhw->rx_pool_size--;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nlist_del(&packet->queue);\r\n} else {\r\nconst int min_capacity =\r\nipwireless_ppp_mru(hw->network) + 2;\r\nint new_capacity;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nnew_capacity =\r\n(minimum_free_space > min_capacity\r\n? minimum_free_space\r\n: min_capacity);\r\npacket = kmalloc(sizeof(struct ipw_rx_packet)\r\n+ new_capacity, GFP_ATOMIC);\r\nif (!packet)\r\nreturn NULL;\r\npacket->capacity = new_capacity;\r\n}\r\npacket->length = 0;\r\n}\r\nif (packet->length + minimum_free_space > packet->capacity) {\r\nstruct ipw_rx_packet *old_packet = packet;\r\npacket = kmalloc(sizeof(struct ipw_rx_packet) +\r\nold_packet->length + minimum_free_space,\r\nGFP_ATOMIC);\r\nif (!packet) {\r\nkfree(old_packet);\r\nreturn NULL;\r\n}\r\nmemcpy(packet, old_packet,\r\nsizeof(struct ipw_rx_packet)\r\n+ old_packet->length);\r\npacket->capacity = old_packet->length + minimum_free_space;\r\nkfree(old_packet);\r\n}\r\nreturn packet;\r\n}\r\nstatic void pool_free(struct ipw_hardware *hw, struct ipw_rx_packet *packet)\r\n{\r\nif (hw->rx_pool_size > 6)\r\nkfree(packet);\r\nelse {\r\nhw->rx_pool_size++;\r\nlist_add(&packet->queue, &hw->rx_pool);\r\n}\r\n}\r\nstatic void queue_received_packet(struct ipw_hardware *hw,\r\nunsigned int protocol,\r\nunsigned int address,\r\nconst unsigned char *data, int length,\r\nint is_last)\r\n{\r\nunsigned int channel_idx = address - 1;\r\nstruct ipw_rx_packet *packet = NULL;\r\nunsigned long flags;\r\nif (channel_idx >= NL_NUM_OF_ADDRESSES) {\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": data packet has bad address %u\n", address);\r\nreturn;\r\n}\r\nif (protocol == TL_PROTOCOLID_COM_DATA) {\r\nstruct ipw_rx_packet **assem =\r\n&hw->packet_assembler[channel_idx];\r\n(*assem) = pool_allocate(hw, *assem, length);\r\nif (!(*assem)) {\r\nprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\r\n": no memory for incomming data packet, dropped!\n");\r\nreturn;\r\n}\r\n(*assem)->protocol = protocol;\r\n(*assem)->channel_idx = channel_idx;\r\nmemcpy((unsigned char *)(*assem) +\r\nsizeof(struct ipw_rx_packet)\r\n+ (*assem)->length, data, length);\r\n(*assem)->length += length;\r\nif (is_last) {\r\npacket = *assem;\r\n*assem = NULL;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->rx_bytes_queued += packet->length;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\n} else {\r\npacket = pool_allocate(hw, NULL, length);\r\nif (!packet) {\r\nprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\r\n": no memory for incomming ctrl packet, dropped!\n");\r\nreturn;\r\n}\r\npacket->protocol = protocol;\r\npacket->channel_idx = channel_idx;\r\nmemcpy((unsigned char *)packet + sizeof(struct ipw_rx_packet),\r\ndata, length);\r\npacket->length = length;\r\n}\r\nif (packet) {\r\nspin_lock_irqsave(&hw->lock, flags);\r\nlist_add_tail(&packet->queue, &hw->rx_queue);\r\nhw->blocking_rx =\r\n(hw->rx_bytes_queued >= IPWIRELESS_RX_QUEUE_SIZE);\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nschedule_work(&hw->work_rx);\r\n}\r\n}\r\nstatic void ipw_receive_data_work(struct work_struct *work_rx)\r\n{\r\nstruct ipw_hardware *hw =\r\ncontainer_of(work_rx, struct ipw_hardware, work_rx);\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nwhile (!list_empty(&hw->rx_queue)) {\r\nstruct ipw_rx_packet *packet =\r\nlist_first_entry(&hw->rx_queue,\r\nstruct ipw_rx_packet, queue);\r\nif (hw->shutting_down)\r\nbreak;\r\nlist_del(&packet->queue);\r\nif (packet->protocol == TL_PROTOCOLID_COM_DATA) {\r\nif (hw->network != NULL) {\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nipwireless_network_packet_received(\r\nhw->network,\r\npacket->channel_idx,\r\n(unsigned char *)packet\r\n+ sizeof(struct ipw_rx_packet),\r\npacket->length);\r\nspin_lock_irqsave(&hw->lock, flags);\r\n}\r\nhw->rx_bytes_queued -= packet->length;\r\n} else {\r\nhandle_received_CTRL_packet(hw, packet->channel_idx,\r\n(unsigned char *)packet\r\n+ sizeof(struct ipw_rx_packet),\r\npacket->length);\r\n}\r\npool_free(hw, packet);\r\nhw->blocking_rx =\r\nhw->rx_bytes_queued >= IPWIRELESS_RX_QUEUE_SIZE;\r\nif (hw->shutting_down)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\nstatic void handle_received_CTRL_packet(struct ipw_hardware *hw,\r\nunsigned int channel_idx,\r\nconst unsigned char *data, int len)\r\n{\r\nconst struct ipw_control_packet_body *body =\r\n(const struct ipw_control_packet_body *) data;\r\nunsigned int changed_mask;\r\nif (len != sizeof(struct ipw_control_packet_body)) {\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": control packet was %d bytes - wrong size!\n",\r\nlen);\r\nreturn;\r\n}\r\nswitch (body->sig_no) {\r\ncase COMCTRL_CTS:\r\nchanged_mask = IPW_CONTROL_LINE_CTS;\r\nbreak;\r\ncase COMCTRL_DCD:\r\nchanged_mask = IPW_CONTROL_LINE_DCD;\r\nbreak;\r\ncase COMCTRL_DSR:\r\nchanged_mask = IPW_CONTROL_LINE_DSR;\r\nbreak;\r\ncase COMCTRL_RI:\r\nchanged_mask = IPW_CONTROL_LINE_RI;\r\nbreak;\r\ndefault:\r\nchanged_mask = 0;\r\n}\r\nif (changed_mask != 0) {\r\nif (body->value)\r\nhw->control_lines[channel_idx] |= changed_mask;\r\nelse\r\nhw->control_lines[channel_idx] &= ~changed_mask;\r\nif (hw->network)\r\nipwireless_network_notify_control_line_change(\r\nhw->network,\r\nchannel_idx,\r\nhw->control_lines[channel_idx],\r\nchanged_mask);\r\n}\r\n}\r\nstatic void handle_received_packet(struct ipw_hardware *hw,\r\nconst union nl_packet *packet,\r\nunsigned short len)\r\n{\r\nunsigned int protocol = packet->hdr.protocol;\r\nunsigned int address = packet->hdr.address;\r\nunsigned int header_length;\r\nconst unsigned char *data;\r\nunsigned int data_len;\r\nint is_last = packet->hdr.packet_rank & NL_LAST_PACKET;\r\nif (packet->hdr.packet_rank & NL_FIRST_PACKET)\r\nheader_length = NL_FIRST_PACKET_HEADER_SIZE;\r\nelse\r\nheader_length = NL_FOLLOWING_PACKET_HEADER_SIZE;\r\ndata = packet->rawpkt + header_length;\r\ndata_len = len - header_length;\r\nswitch (protocol) {\r\ncase TL_PROTOCOLID_COM_DATA:\r\ncase TL_PROTOCOLID_COM_CTRL:\r\nqueue_received_packet(hw, protocol, address, data, data_len,\r\nis_last);\r\nbreak;\r\ncase TL_PROTOCOLID_SETUP:\r\nhandle_received_SETUP_packet(hw, address, data, data_len,\r\nis_last);\r\nbreak;\r\n}\r\n}\r\nstatic void acknowledge_data_read(struct ipw_hardware *hw)\r\n{\r\nif (hw->hw_version == HW_VERSION_1)\r\noutw(DCR_RXDONE, hw->base_port + IODCR);\r\nelse\r\nwritew(MEMRX_PCINTACKK,\r\n&hw->memory_info_regs->memreg_pc_interrupt_ack);\r\n}\r\nstatic void do_receive_packet(struct ipw_hardware *hw)\r\n{\r\nunsigned len;\r\nunsigned i;\r\nunsigned char pkt[LL_MTU_MAX];\r\nstart_timing();\r\nif (hw->hw_version == HW_VERSION_1) {\r\nlen = inw(hw->base_port + IODRR);\r\nif (len > hw->ll_mtu) {\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": received a packet of %u bytes - longer than the MTU!\n", len);\r\noutw(DCR_RXDONE | DCR_RXRESET, hw->base_port + IODCR);\r\nreturn;\r\n}\r\nfor (i = 0; i < len; i += 2) {\r\n__le16 raw_data = inw(hw->base_port + IODRR);\r\nunsigned short data = le16_to_cpu(raw_data);\r\npkt[i] = (unsigned char) data;\r\npkt[i + 1] = (unsigned char) (data >> 8);\r\n}\r\n} else {\r\nlen = inw(hw->base_port);\r\nif (len > hw->ll_mtu) {\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": received a packet of %u bytes - longer than the MTU!\n", len);\r\nwritew(MEMRX_PCINTACKK,\r\n&hw->memory_info_regs->memreg_pc_interrupt_ack);\r\nreturn;\r\n}\r\nfor (i = 0; i < len; i += 2) {\r\n__le16 raw_data = inw(hw->base_port);\r\nunsigned short data = le16_to_cpu(raw_data);\r\npkt[i] = (unsigned char) data;\r\npkt[i + 1] = (unsigned char) (data >> 8);\r\n}\r\nwhile ((i & 3) != 2) {\r\ninw(hw->base_port);\r\ni += 2;\r\n}\r\n}\r\nacknowledge_data_read(hw);\r\nswap_packet_bitfield_from_le(pkt);\r\nif (ipwireless_debug)\r\ndump_data_bytes("recv", pkt, len);\r\nhandle_received_packet(hw, (union nl_packet *) pkt, len);\r\nend_read_timing(len);\r\n}\r\nstatic int get_current_packet_priority(struct ipw_hardware *hw)\r\n{\r\nreturn (hw->to_setup || hw->initializing\r\n? PRIO_SETUP + 1 : NL_NUM_OF_PRIORITIES);\r\n}\r\nstatic int get_packets_from_hw(struct ipw_hardware *hw)\r\n{\r\nint received = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nwhile (hw->rx_ready && !hw->blocking_rx) {\r\nreceived = 1;\r\nhw->rx_ready--;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\ndo_receive_packet(hw);\r\nspin_lock_irqsave(&hw->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nreturn received;\r\n}\r\nstatic int send_pending_packet(struct ipw_hardware *hw, int priority_limit)\r\n{\r\nint more_to_send = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nif (hw->tx_queued && hw->tx_ready) {\r\nint priority;\r\nstruct ipw_tx_packet *packet = NULL;\r\nfor (priority = 0; priority < priority_limit; priority++) {\r\nif (!list_empty(&hw->tx_queue[priority])) {\r\npacket = list_first_entry(\r\n&hw->tx_queue[priority],\r\nstruct ipw_tx_packet,\r\nqueue);\r\nhw->tx_queued--;\r\nlist_del(&packet->queue);\r\nbreak;\r\n}\r\n}\r\nif (!packet) {\r\nhw->tx_queued = 0;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\ndo_send_packet(hw, packet);\r\nspin_lock_irqsave(&hw->lock, flags);\r\nfor (priority = 0; priority < priority_limit; priority++)\r\nif (!list_empty(&hw->tx_queue[priority])) {\r\nmore_to_send = 1;\r\nbreak;\r\n}\r\nif (!more_to_send)\r\nhw->tx_queued = 0;\r\n}\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nreturn more_to_send;\r\n}\r\nstatic void ipwireless_do_tasklet(unsigned long hw_)\r\n{\r\nstruct ipw_hardware *hw = (struct ipw_hardware *) hw_;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nif (hw->shutting_down) {\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nreturn;\r\n}\r\nif (hw->to_setup == 1) {\r\nhw->to_setup = 2;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nipw_setup_hardware(hw);\r\nipw_send_setup_packet(hw);\r\nsend_pending_packet(hw, PRIO_SETUP + 1);\r\nget_packets_from_hw(hw);\r\n} else {\r\nint priority_limit = get_current_packet_priority(hw);\r\nint again;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\ndo {\r\nagain = send_pending_packet(hw, priority_limit);\r\nagain |= get_packets_from_hw(hw);\r\n} while (again);\r\n}\r\n}\r\nstatic int is_card_present(struct ipw_hardware *hw)\r\n{\r\nif (hw->hw_version == HW_VERSION_1)\r\nreturn inw(hw->base_port + IOIR) != 0xFFFF;\r\nelse\r\nreturn readl(&hw->memory_info_regs->memreg_card_present) ==\r\nCARD_PRESENT_VALUE;\r\n}\r\nstatic irqreturn_t ipwireless_handle_v1_interrupt(int irq,\r\nstruct ipw_hardware *hw)\r\n{\r\nunsigned short irqn;\r\nirqn = inw(hw->base_port + IOIR);\r\nif (irqn == 0xFFFF)\r\nreturn IRQ_NONE;\r\nelse if (irqn != 0) {\r\nunsigned short ack = 0;\r\nunsigned long flags;\r\nif (irqn & IR_TXINTR) {\r\nack |= IR_TXINTR;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->tx_ready = 1;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\nif (irqn & IR_RXINTR) {\r\nack |= IR_RXINTR;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->rx_ready++;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\nif (ack != 0) {\r\noutw(ack, hw->base_port + IOIR);\r\ntasklet_schedule(&hw->tasklet);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void acknowledge_pcmcia_interrupt(struct ipw_hardware *hw)\r\n{\r\nunsigned short csr = readw(&hw->memregs_CCR->reg_config_and_status);\r\ncsr &= 0xfffd;\r\nwritew(csr, &hw->memregs_CCR->reg_config_and_status);\r\n}\r\nstatic irqreturn_t ipwireless_handle_v2_v3_interrupt(int irq,\r\nstruct ipw_hardware *hw)\r\n{\r\nint tx = 0;\r\nint rx = 0;\r\nint rx_repeat = 0;\r\nint try_mem_tx_old;\r\nunsigned long flags;\r\ndo {\r\nunsigned short memtx = readw(hw->memreg_tx);\r\nunsigned short memtx_serial;\r\nunsigned short memrxdone =\r\nreadw(&hw->memory_info_regs->memreg_rx_done);\r\ntry_mem_tx_old = 0;\r\nif (!(memtx & MEMTX_TX) && !(memrxdone & MEMRX_RX_DONE)) {\r\nif (hw->memreg_tx == &hw->memory_info_regs->memreg_tx_new) {\r\nmemtx = readw(&hw->memory_info_regs->memreg_tx_old);\r\nif (memtx & MEMTX_TX) {\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": Using memreg_tx_old\n");\r\nhw->memreg_tx =\r\n&hw->memory_info_regs->memreg_tx_old;\r\n} else {\r\nreturn IRQ_NONE;\r\n}\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nif (!is_card_present(hw)) {\r\nacknowledge_pcmcia_interrupt(hw);\r\nreturn IRQ_HANDLED;\r\n}\r\nmemtx_serial = memtx & (unsigned short) 0xff00;\r\nif (memtx & MEMTX_TX) {\r\nwritew(memtx_serial, hw->memreg_tx);\r\nif (hw->serial_number_detected) {\r\nif (memtx_serial != hw->last_memtx_serial) {\r\nhw->last_memtx_serial = memtx_serial;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->rx_ready++;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nrx = 1;\r\n} else\r\nrx_repeat = 1;\r\n} else {\r\nif (memtx_serial != 0) {\r\nhw->serial_number_detected = 1;\r\nprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\r\n": memreg_tx serial num detected\n");\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->rx_ready++;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\n}\r\nrx = 1;\r\n}\r\n}\r\nif (memrxdone & MEMRX_RX_DONE) {\r\nwritew(0, &hw->memory_info_regs->memreg_rx_done);\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->tx_ready = 1;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\ntx = 1;\r\n}\r\nif (tx)\r\nwritew(MEMRX_PCINTACKK,\r\n&hw->memory_info_regs->memreg_pc_interrupt_ack);\r\nacknowledge_pcmcia_interrupt(hw);\r\nif (tx || rx)\r\ntasklet_schedule(&hw->tasklet);\r\nelse if (!rx_repeat) {\r\nif (hw->memreg_tx == &hw->memory_info_regs->memreg_tx_new) {\r\nif (hw->serial_number_detected)\r\nprintk(KERN_WARNING IPWIRELESS_PCCARD_NAME\r\n": spurious interrupt - new_tx mode\n");\r\nelse {\r\nprintk(KERN_WARNING IPWIRELESS_PCCARD_NAME\r\n": no valid memreg_tx value - switching to the old memreg_tx\n");\r\nhw->memreg_tx =\r\n&hw->memory_info_regs->memreg_tx_old;\r\ntry_mem_tx_old = 1;\r\n}\r\n} else\r\nprintk(KERN_WARNING IPWIRELESS_PCCARD_NAME\r\n": spurious interrupt - old_tx mode\n");\r\n}\r\n} while (try_mem_tx_old == 1);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t ipwireless_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ipw_dev *ipw = dev_id;\r\nif (ipw->hardware->hw_version == HW_VERSION_1)\r\nreturn ipwireless_handle_v1_interrupt(irq, ipw->hardware);\r\nelse\r\nreturn ipwireless_handle_v2_v3_interrupt(irq, ipw->hardware);\r\n}\r\nstatic void flush_packets_to_hw(struct ipw_hardware *hw)\r\n{\r\nint priority_limit;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\npriority_limit = get_current_packet_priority(hw);\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nwhile (send_pending_packet(hw, priority_limit));\r\n}\r\nstatic void send_packet(struct ipw_hardware *hw, int priority,\r\nstruct ipw_tx_packet *packet)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nlist_add_tail(&packet->queue, &hw->tx_queue[priority]);\r\nhw->tx_queued++;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nflush_packets_to_hw(hw);\r\n}\r\nstatic void *alloc_data_packet(int data_size,\r\nunsigned char dest_addr,\r\nunsigned char protocol)\r\n{\r\nstruct ipw_tx_packet *packet = kzalloc(\r\nsizeof(struct ipw_tx_packet) + data_size,\r\nGFP_ATOMIC);\r\nif (!packet)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&packet->queue);\r\npacket->dest_addr = dest_addr;\r\npacket->protocol = protocol;\r\npacket->length = data_size;\r\nreturn packet;\r\n}\r\nstatic void *alloc_ctrl_packet(int header_size,\r\nunsigned char dest_addr,\r\nunsigned char protocol,\r\nunsigned char sig_no)\r\n{\r\nstruct ipw_control_packet *packet = kzalloc(header_size, GFP_ATOMIC);\r\nif (!packet)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&packet->header.queue);\r\npacket->header.dest_addr = dest_addr;\r\npacket->header.protocol = protocol;\r\npacket->header.length = header_size - sizeof(struct ipw_tx_packet);\r\npacket->body.sig_no = sig_no;\r\nreturn packet;\r\n}\r\nint ipwireless_send_packet(struct ipw_hardware *hw, unsigned int channel_idx,\r\nconst unsigned char *data, unsigned int length,\r\nvoid (*callback) (void *cb, unsigned int length),\r\nvoid *callback_data)\r\n{\r\nstruct ipw_tx_packet *packet;\r\npacket = alloc_data_packet(length, (channel_idx + 1),\r\nTL_PROTOCOLID_COM_DATA);\r\nif (!packet)\r\nreturn -ENOMEM;\r\npacket->packet_callback = callback;\r\npacket->callback_data = callback_data;\r\nmemcpy((unsigned char *) packet + sizeof(struct ipw_tx_packet), data,\r\nlength);\r\nsend_packet(hw, PRIO_DATA, packet);\r\nreturn 0;\r\n}\r\nstatic int set_control_line(struct ipw_hardware *hw, int prio,\r\nunsigned int channel_idx, int line, int state)\r\n{\r\nstruct ipw_control_packet *packet;\r\nint protocolid = TL_PROTOCOLID_COM_CTRL;\r\nif (prio == PRIO_SETUP)\r\nprotocolid = TL_PROTOCOLID_SETUP;\r\npacket = alloc_ctrl_packet(sizeof(struct ipw_control_packet),\r\n(channel_idx + 1), protocolid, line);\r\nif (!packet)\r\nreturn -ENOMEM;\r\npacket->header.length = sizeof(struct ipw_control_packet_body);\r\npacket->body.value = (state == 0 ? 0 : 1);\r\nsend_packet(hw, prio, &packet->header);\r\nreturn 0;\r\n}\r\nstatic int set_DTR(struct ipw_hardware *hw, int priority,\r\nunsigned int channel_idx, int state)\r\n{\r\nif (state != 0)\r\nhw->control_lines[channel_idx] |= IPW_CONTROL_LINE_DTR;\r\nelse\r\nhw->control_lines[channel_idx] &= ~IPW_CONTROL_LINE_DTR;\r\nreturn set_control_line(hw, priority, channel_idx, COMCTRL_DTR, state);\r\n}\r\nstatic int set_RTS(struct ipw_hardware *hw, int priority,\r\nunsigned int channel_idx, int state)\r\n{\r\nif (state != 0)\r\nhw->control_lines[channel_idx] |= IPW_CONTROL_LINE_RTS;\r\nelse\r\nhw->control_lines[channel_idx] &= ~IPW_CONTROL_LINE_RTS;\r\nreturn set_control_line(hw, priority, channel_idx, COMCTRL_RTS, state);\r\n}\r\nint ipwireless_set_DTR(struct ipw_hardware *hw, unsigned int channel_idx,\r\nint state)\r\n{\r\nreturn set_DTR(hw, PRIO_CTRL, channel_idx, state);\r\n}\r\nint ipwireless_set_RTS(struct ipw_hardware *hw, unsigned int channel_idx,\r\nint state)\r\n{\r\nreturn set_RTS(hw, PRIO_CTRL, channel_idx, state);\r\n}\r\nstatic void __handle_setup_get_version_rsp(struct ipw_hardware *hw)\r\n{\r\nstruct ipw_setup_config_packet *config_packet;\r\nstruct ipw_setup_config_done_packet *config_done_packet;\r\nstruct ipw_setup_open_packet *open_packet;\r\nstruct ipw_setup_info_packet *info_packet;\r\nint port;\r\nunsigned int channel_idx;\r\nfor (port = 1; port <= NL_NUM_OF_ADDRESSES; port++) {\r\nconfig_packet = alloc_ctrl_packet(\r\nsizeof(struct ipw_setup_config_packet),\r\nADDR_SETUP_PROT,\r\nTL_PROTOCOLID_SETUP,\r\nTL_SETUP_SIGNO_CONFIG_MSG);\r\nif (!config_packet)\r\ngoto exit_nomem;\r\nconfig_packet->header.length = sizeof(struct tl_setup_config_msg);\r\nconfig_packet->body.port_no = port;\r\nconfig_packet->body.prio_data = PRIO_DATA;\r\nconfig_packet->body.prio_ctrl = PRIO_CTRL;\r\nsend_packet(hw, PRIO_SETUP, &config_packet->header);\r\n}\r\nconfig_done_packet = alloc_ctrl_packet(\r\nsizeof(struct ipw_setup_config_done_packet),\r\nADDR_SETUP_PROT,\r\nTL_PROTOCOLID_SETUP,\r\nTL_SETUP_SIGNO_CONFIG_DONE_MSG);\r\nif (!config_done_packet)\r\ngoto exit_nomem;\r\nconfig_done_packet->header.length = sizeof(struct tl_setup_config_done_msg);\r\nsend_packet(hw, PRIO_SETUP, &config_done_packet->header);\r\nfor (port = 1; port <= NL_NUM_OF_ADDRESSES; port++) {\r\nopen_packet = alloc_ctrl_packet(\r\nsizeof(struct ipw_setup_open_packet),\r\nADDR_SETUP_PROT,\r\nTL_PROTOCOLID_SETUP,\r\nTL_SETUP_SIGNO_OPEN_MSG);\r\nif (!open_packet)\r\ngoto exit_nomem;\r\nopen_packet->header.length = sizeof(struct tl_setup_open_msg);\r\nopen_packet->body.port_no = port;\r\nsend_packet(hw, PRIO_SETUP, &open_packet->header);\r\n}\r\nfor (channel_idx = 0;\r\nchannel_idx < NL_NUM_OF_ADDRESSES; channel_idx++) {\r\nint ret;\r\nret = set_DTR(hw, PRIO_SETUP, channel_idx,\r\n(hw->control_lines[channel_idx] &\r\nIPW_CONTROL_LINE_DTR) != 0);\r\nif (ret) {\r\nprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\r\n": error setting DTR (%d)\n", ret);\r\nreturn;\r\n}\r\nset_RTS(hw, PRIO_SETUP, channel_idx,\r\n(hw->control_lines [channel_idx] &\r\nIPW_CONTROL_LINE_RTS) != 0);\r\nif (ret) {\r\nprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\r\n": error setting RTS (%d)\n", ret);\r\nreturn;\r\n}\r\n}\r\ninfo_packet = alloc_ctrl_packet(sizeof(struct ipw_setup_info_packet),\r\nADDR_SETUP_PROT,\r\nTL_PROTOCOLID_SETUP,\r\nTL_SETUP_SIGNO_INFO_MSG);\r\nif (!info_packet)\r\ngoto exit_nomem;\r\ninfo_packet->header.length = sizeof(struct tl_setup_info_msg);\r\ninfo_packet->body.driver_type = NDISWAN_DRIVER;\r\ninfo_packet->body.major_version = NDISWAN_DRIVER_MAJOR_VERSION;\r\ninfo_packet->body.minor_version = NDISWAN_DRIVER_MINOR_VERSION;\r\nsend_packet(hw, PRIO_SETUP, &info_packet->header);\r\nhw->to_setup = 0;\r\nreturn;\r\nexit_nomem:\r\nprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\r\n": not enough memory to alloc control packet\n");\r\nhw->to_setup = -1;\r\n}\r\nstatic void handle_setup_get_version_rsp(struct ipw_hardware *hw,\r\nunsigned char vers_no)\r\n{\r\ndel_timer(&hw->setup_timer);\r\nhw->initializing = 0;\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME ": card is ready.\n");\r\nif (vers_no == TL_SETUP_VERSION)\r\n__handle_setup_get_version_rsp(hw);\r\nelse\r\nprintk(KERN_ERR IPWIRELESS_PCCARD_NAME\r\n": invalid hardware version no %u\n",\r\n(unsigned int) vers_no);\r\n}\r\nstatic void ipw_send_setup_packet(struct ipw_hardware *hw)\r\n{\r\nstruct ipw_setup_get_version_query_packet *ver_packet;\r\nver_packet = alloc_ctrl_packet(\r\nsizeof(struct ipw_setup_get_version_query_packet),\r\nADDR_SETUP_PROT, TL_PROTOCOLID_SETUP,\r\nTL_SETUP_SIGNO_GET_VERSION_QRY);\r\nver_packet->header.length = sizeof(struct tl_setup_get_version_qry);\r\nsend_packet(hw, PRIO_SETUP, &ver_packet->header);\r\n}\r\nstatic void handle_received_SETUP_packet(struct ipw_hardware *hw,\r\nunsigned int address,\r\nconst unsigned char *data, int len,\r\nint is_last)\r\n{\r\nconst union ipw_setup_rx_msg *rx_msg = (const union ipw_setup_rx_msg *) data;\r\nif (address != ADDR_SETUP_PROT) {\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": setup packet has bad address %d\n", address);\r\nreturn;\r\n}\r\nswitch (rx_msg->sig_no) {\r\ncase TL_SETUP_SIGNO_GET_VERSION_RSP:\r\nif (hw->to_setup)\r\nhandle_setup_get_version_rsp(hw,\r\nrx_msg->version_rsp_msg.version);\r\nbreak;\r\ncase TL_SETUP_SIGNO_OPEN_MSG:\r\nif (ipwireless_debug) {\r\nunsigned int channel_idx = rx_msg->open_msg.port_no - 1;\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": OPEN_MSG [channel %u] reply received\n",\r\nchannel_idx);\r\n}\r\nbreak;\r\ncase TL_SETUP_SIGNO_INFO_MSG_ACK:\r\nif (ipwireless_debug)\r\nprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\r\n": card successfully configured as NDISWAN\n");\r\nbreak;\r\ncase TL_SETUP_SIGNO_REBOOT_MSG:\r\nif (hw->to_setup)\r\nprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\r\n": Setup not completed - ignoring reboot msg\n");\r\nelse {\r\nstruct ipw_setup_reboot_msg_ack *packet;\r\nprintk(KERN_DEBUG IPWIRELESS_PCCARD_NAME\r\n": Acknowledging REBOOT message\n");\r\npacket = alloc_ctrl_packet(\r\nsizeof(struct ipw_setup_reboot_msg_ack),\r\nADDR_SETUP_PROT, TL_PROTOCOLID_SETUP,\r\nTL_SETUP_SIGNO_REBOOT_MSG_ACK);\r\npacket->header.length =\r\nsizeof(struct TlSetupRebootMsgAck);\r\nsend_packet(hw, PRIO_SETUP, &packet->header);\r\nif (hw->reboot_callback)\r\nhw->reboot_callback(hw->reboot_callback_data);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": unknown setup message %u received\n",\r\n(unsigned int) rx_msg->sig_no);\r\n}\r\n}\r\nstatic void do_close_hardware(struct ipw_hardware *hw)\r\n{\r\nunsigned int irqn;\r\nif (hw->hw_version == HW_VERSION_1) {\r\noutw(0, hw->base_port + IOIER);\r\nirqn = inw(hw->base_port + IOIR);\r\nif (irqn & IR_TXINTR)\r\noutw(IR_TXINTR, hw->base_port + IOIR);\r\nif (irqn & IR_RXINTR)\r\noutw(IR_RXINTR, hw->base_port + IOIR);\r\nsynchronize_irq(hw->irq);\r\n}\r\n}\r\nstruct ipw_hardware *ipwireless_hardware_create(void)\r\n{\r\nint i;\r\nstruct ipw_hardware *hw =\r\nkzalloc(sizeof(struct ipw_hardware), GFP_KERNEL);\r\nif (!hw)\r\nreturn NULL;\r\nhw->irq = -1;\r\nhw->initializing = 1;\r\nhw->tx_ready = 1;\r\nhw->rx_bytes_queued = 0;\r\nhw->rx_pool_size = 0;\r\nhw->last_memtx_serial = (unsigned short) 0xffff;\r\nfor (i = 0; i < NL_NUM_OF_PRIORITIES; i++)\r\nINIT_LIST_HEAD(&hw->tx_queue[i]);\r\nINIT_LIST_HEAD(&hw->rx_queue);\r\nINIT_LIST_HEAD(&hw->rx_pool);\r\nspin_lock_init(&hw->lock);\r\ntasklet_init(&hw->tasklet, ipwireless_do_tasklet, (unsigned long) hw);\r\nINIT_WORK(&hw->work_rx, ipw_receive_data_work);\r\nsetup_timer(&hw->setup_timer, ipwireless_setup_timer,\r\n(unsigned long) hw);\r\nreturn hw;\r\n}\r\nvoid ipwireless_init_hardware_v1(struct ipw_hardware *hw,\r\nunsigned int base_port,\r\nvoid __iomem *attr_memory,\r\nvoid __iomem *common_memory,\r\nint is_v2_card,\r\nvoid (*reboot_callback) (void *data),\r\nvoid *reboot_callback_data)\r\n{\r\nif (hw->removed) {\r\nhw->removed = 0;\r\nenable_irq(hw->irq);\r\n}\r\nhw->base_port = base_port;\r\nhw->hw_version = (is_v2_card ? HW_VERSION_2 : HW_VERSION_1);\r\nhw->ll_mtu = (hw->hw_version == HW_VERSION_1 ? LL_MTU_V1 : LL_MTU_V2);\r\nhw->memregs_CCR = (struct MEMCCR __iomem *)\r\n((unsigned short __iomem *) attr_memory + 0x200);\r\nhw->memory_info_regs = (struct MEMINFREG __iomem *) common_memory;\r\nhw->memreg_tx = &hw->memory_info_regs->memreg_tx_new;\r\nhw->reboot_callback = reboot_callback;\r\nhw->reboot_callback_data = reboot_callback_data;\r\n}\r\nvoid ipwireless_init_hardware_v2_v3(struct ipw_hardware *hw)\r\n{\r\nhw->initializing = 1;\r\nhw->init_loops = 0;\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": waiting for card to start up...\n");\r\nipwireless_setup_timer((unsigned long) hw);\r\n}\r\nstatic void ipwireless_setup_timer(unsigned long data)\r\n{\r\nstruct ipw_hardware *hw = (struct ipw_hardware *) data;\r\nhw->init_loops++;\r\nif (hw->init_loops == TL_SETUP_MAX_VERSION_QRY &&\r\nhw->hw_version == HW_VERSION_2 &&\r\nhw->memreg_tx == &hw->memory_info_regs->memreg_tx_new) {\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": failed to startup using TX2, trying TX\n");\r\nhw->memreg_tx = &hw->memory_info_regs->memreg_tx_old;\r\nhw->init_loops = 0;\r\n}\r\nif (hw->init_loops == TL_SETUP_MAX_VERSION_QRY) {\r\nprintk(KERN_INFO IPWIRELESS_PCCARD_NAME\r\n": card failed to start up!\n");\r\nhw->initializing = 0;\r\n} else {\r\nif (is_card_present(hw)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nhw->to_setup = 1;\r\nhw->tx_ready = 1;\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\ntasklet_schedule(&hw->tasklet);\r\n}\r\nmod_timer(&hw->setup_timer,\r\njiffies + msecs_to_jiffies(TL_SETUP_VERSION_QRY_TMO));\r\n}\r\n}\r\nvoid ipwireless_stop_interrupts(struct ipw_hardware *hw)\r\n{\r\nif (!hw->shutting_down) {\r\nhw->shutting_down = 1;\r\ndel_timer(&hw->setup_timer);\r\ndo_close_hardware(hw);\r\n}\r\n}\r\nvoid ipwireless_hardware_free(struct ipw_hardware *hw)\r\n{\r\nint i;\r\nstruct ipw_rx_packet *rp, *rq;\r\nstruct ipw_tx_packet *tp, *tq;\r\nipwireless_stop_interrupts(hw);\r\nflush_work_sync(&hw->work_rx);\r\nfor (i = 0; i < NL_NUM_OF_ADDRESSES; i++)\r\nif (hw->packet_assembler[i] != NULL)\r\nkfree(hw->packet_assembler[i]);\r\nfor (i = 0; i < NL_NUM_OF_PRIORITIES; i++)\r\nlist_for_each_entry_safe(tp, tq, &hw->tx_queue[i], queue) {\r\nlist_del(&tp->queue);\r\nkfree(tp);\r\n}\r\nlist_for_each_entry_safe(rp, rq, &hw->rx_queue, queue) {\r\nlist_del(&rp->queue);\r\nkfree(rp);\r\n}\r\nlist_for_each_entry_safe(rp, rq, &hw->rx_pool, queue) {\r\nlist_del(&rp->queue);\r\nkfree(rp);\r\n}\r\nkfree(hw);\r\n}\r\nvoid ipwireless_associate_network(struct ipw_hardware *hw,\r\nstruct ipw_network *network)\r\n{\r\nhw->network = network;\r\n}
