static void usbtmc_delete(struct kref *kref)\r\n{\r\nstruct usbtmc_device_data *data = to_usbtmc_data(kref);\r\nusb_put_dev(data->usb_dev);\r\nkfree(data);\r\n}\r\nstatic int usbtmc_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct usb_interface *intf;\r\nstruct usbtmc_device_data *data;\r\nint retval = 0;\r\nintf = usb_find_interface(&usbtmc_driver, iminor(inode));\r\nif (!intf) {\r\nprintk(KERN_ERR KBUILD_MODNAME\r\n": can not find device for minor %d", iminor(inode));\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\ndata = usb_get_intfdata(intf);\r\nkref_get(&data->kref);\r\nfilp->private_data = data;\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int usbtmc_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usbtmc_device_data *data = file->private_data;\r\nkref_put(&data->kref, usbtmc_delete);\r\nreturn 0;\r\n}\r\nstatic int usbtmc_ioctl_abort_bulk_in(struct usbtmc_device_data *data)\r\n{\r\nu8 *buffer;\r\nstruct device *dev;\r\nint rv;\r\nint n;\r\nint actual;\r\nstruct usb_host_interface *current_setting;\r\nint max_size;\r\ndev = &data->intf->dev;\r\nbuffer = kmalloc(USBTMC_SIZE_IOBUFFER, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_INITIATE_ABORT_BULK_IN,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\r\ndata->bTag_last_read, data->bulk_in,\r\nbuffer, 2, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INITIATE_ABORT_BULK_IN returned %x\n", buffer[0]);\r\nif (buffer[0] == USBTMC_STATUS_FAILED) {\r\nrv = 0;\r\ngoto exit;\r\n}\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "INITIATE_ABORT_BULK_IN returned %x\n",\r\nbuffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nmax_size = 0;\r\ncurrent_setting = data->intf->cur_altsetting;\r\nfor (n = 0; n < current_setting->desc.bNumEndpoints; n++)\r\nif (current_setting->endpoint[n].desc.bEndpointAddress ==\r\ndata->bulk_in)\r\nmax_size = usb_endpoint_maxp(&current_setting->endpoint[n].desc);\r\nif (max_size == 0) {\r\ndev_err(dev, "Couldn't get wMaxPacketSize\n");\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\ndev_dbg(&data->intf->dev, "wMaxPacketSize is %d\n", max_size);\r\nn = 0;\r\ndo {\r\ndev_dbg(dev, "Reading from bulk in EP\n");\r\nrv = usb_bulk_msg(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev,\r\ndata->bulk_in),\r\nbuffer, USBTMC_SIZE_IOBUFFER,\r\n&actual, USBTMC_TIMEOUT);\r\nn++;\r\nif (rv < 0) {\r\ndev_err(dev, "usb_bulk_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\n} while ((actual == max_size) &&\r\n(n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN));\r\nif (actual == max_size) {\r\ndev_err(dev, "Couldn't clear device buffer within %d cycles\n",\r\nUSBTMC_MAX_READS_TO_CLEAR_BULK_IN);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nn = 0;\r\nusbtmc_abort_bulk_in_status:\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_CHECK_ABORT_BULK_IN_STATUS,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\r\n0, data->bulk_in, buffer, 0x08,\r\nUSBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INITIATE_ABORT_BULK_IN returned %x\n", buffer[0]);\r\nif (buffer[0] == USBTMC_STATUS_SUCCESS) {\r\nrv = 0;\r\ngoto exit;\r\n}\r\nif (buffer[0] != USBTMC_STATUS_PENDING) {\r\ndev_err(dev, "INITIATE_ABORT_BULK_IN returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nif (buffer[1] == 1)\r\ndo {\r\ndev_dbg(dev, "Reading from bulk in EP\n");\r\nrv = usb_bulk_msg(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev,\r\ndata->bulk_in),\r\nbuffer, USBTMC_SIZE_IOBUFFER,\r\n&actual, USBTMC_TIMEOUT);\r\nn++;\r\nif (rv < 0) {\r\ndev_err(dev, "usb_bulk_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\n} while ((actual == max_size) &&\r\n(n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN));\r\nif (actual == max_size) {\r\ndev_err(dev, "Couldn't clear device buffer within %d cycles\n",\r\nUSBTMC_MAX_READS_TO_CLEAR_BULK_IN);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\ngoto usbtmc_abort_bulk_in_status;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic int usbtmc_ioctl_abort_bulk_out(struct usbtmc_device_data *data)\r\n{\r\nstruct device *dev;\r\nu8 *buffer;\r\nint rv;\r\nint n;\r\ndev = &data->intf->dev;\r\nbuffer = kmalloc(8, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_INITIATE_ABORT_BULK_OUT,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\r\ndata->bTag_last_write, data->bulk_out,\r\nbuffer, 2, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INITIATE_ABORT_BULK_OUT returned %x\n", buffer[0]);\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "INITIATE_ABORT_BULK_OUT returned %x\n",\r\nbuffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nn = 0;\r\nusbtmc_abort_bulk_out_check_status:\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_CHECK_ABORT_BULK_OUT_STATUS,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\r\n0, data->bulk_out, buffer, 0x08,\r\nUSBTMC_TIMEOUT);\r\nn++;\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "CHECK_ABORT_BULK_OUT returned %x\n", buffer[0]);\r\nif (buffer[0] == USBTMC_STATUS_SUCCESS)\r\ngoto usbtmc_abort_bulk_out_clear_halt;\r\nif ((buffer[0] == USBTMC_STATUS_PENDING) &&\r\n(n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN))\r\ngoto usbtmc_abort_bulk_out_check_status;\r\nrv = -EPERM;\r\ngoto exit;\r\nusbtmc_abort_bulk_out_clear_halt:\r\nrv = usb_clear_halt(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev, data->bulk_out));\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\nrv = 0;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic ssize_t usbtmc_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nstruct usbtmc_device_data *data;\r\nstruct device *dev;\r\nu32 n_characters;\r\nu8 *buffer;\r\nint actual;\r\nsize_t done;\r\nsize_t remaining;\r\nint retval;\r\nsize_t this_part;\r\ndata = filp->private_data;\r\ndev = &data->intf->dev;\r\nbuffer = kmalloc(USBTMC_SIZE_IOBUFFER, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmutex_lock(&data->io_mutex);\r\nif (data->zombie) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nremaining = count;\r\ndone = 0;\r\nwhile (remaining > 0) {\r\nif (remaining > USBTMC_SIZE_IOBUFFER - 12 - 3)\r\nthis_part = USBTMC_SIZE_IOBUFFER - 12 - 3;\r\nelse\r\nthis_part = remaining;\r\nbuffer[0] = 2;\r\nbuffer[1] = data->bTag;\r\nbuffer[2] = ~(data->bTag);\r\nbuffer[3] = 0;\r\nbuffer[4] = (this_part) & 255;\r\nbuffer[5] = ((this_part) >> 8) & 255;\r\nbuffer[6] = ((this_part) >> 16) & 255;\r\nbuffer[7] = ((this_part) >> 24) & 255;\r\nbuffer[8] = data->TermCharEnabled * 2;\r\nbuffer[9] = data->TermChar;\r\nbuffer[10] = 0;\r\nbuffer[11] = 0;\r\nretval = usb_bulk_msg(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev,\r\ndata->bulk_out),\r\nbuffer, 12, &actual, USBTMC_TIMEOUT);\r\ndata->bTag_last_write = data->bTag;\r\ndata->bTag++;\r\nif (!data->bTag)\r\n(data->bTag)++;\r\nif (retval < 0) {\r\ndev_err(dev, "usb_bulk_msg returned %d\n", retval);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_out(data);\r\ngoto exit;\r\n}\r\nretval = usb_bulk_msg(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev,\r\ndata->bulk_in),\r\nbuffer, USBTMC_SIZE_IOBUFFER, &actual,\r\nUSBTMC_TIMEOUT);\r\ndata->bTag_last_read = data->bTag;\r\nif (retval < 0) {\r\ndev_err(dev, "Unable to read data, error %d\n", retval);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_in(data);\r\ngoto exit;\r\n}\r\nn_characters = buffer[4] +\r\n(buffer[5] << 8) +\r\n(buffer[6] << 16) +\r\n(buffer[7] << 24);\r\nif(n_characters > actual - 12) {\r\ndev_err(dev, "Device lies about message size: %u > %d\n", n_characters, actual - 12);\r\nn_characters = actual - 12;\r\n}\r\nif(n_characters > this_part) {\r\ndev_err(dev, "Device returns more than requested: %zu > %zu\n", done + n_characters, done + this_part);\r\nn_characters = this_part;\r\n}\r\nif (n_characters > this_part)\r\nn_characters = this_part;\r\nif (copy_to_user(buf + done, &buffer[12], n_characters)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\ndone += n_characters;\r\nif ((buffer[8] & 0x01) && (actual >= n_characters + 12))\r\nremaining = 0;\r\nelse\r\nremaining -= n_characters;\r\n}\r\n*f_pos = *f_pos + done;\r\nretval = done;\r\nexit:\r\nmutex_unlock(&data->io_mutex);\r\nkfree(buffer);\r\nreturn retval;\r\n}\r\nstatic ssize_t usbtmc_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nstruct usbtmc_device_data *data;\r\nu8 *buffer;\r\nint retval;\r\nint actual;\r\nunsigned long int n_bytes;\r\nint remaining;\r\nint done;\r\nint this_part;\r\ndata = filp->private_data;\r\nbuffer = kmalloc(USBTMC_SIZE_IOBUFFER, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmutex_lock(&data->io_mutex);\r\nif (data->zombie) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nremaining = count;\r\ndone = 0;\r\nwhile (remaining > 0) {\r\nif (remaining > USBTMC_SIZE_IOBUFFER - 12) {\r\nthis_part = USBTMC_SIZE_IOBUFFER - 12;\r\nbuffer[8] = 0;\r\n} else {\r\nthis_part = remaining;\r\nbuffer[8] = 1;\r\n}\r\nbuffer[0] = 1;\r\nbuffer[1] = data->bTag;\r\nbuffer[2] = ~(data->bTag);\r\nbuffer[3] = 0;\r\nbuffer[4] = this_part & 255;\r\nbuffer[5] = (this_part >> 8) & 255;\r\nbuffer[6] = (this_part >> 16) & 255;\r\nbuffer[7] = (this_part >> 24) & 255;\r\nbuffer[9] = 0;\r\nbuffer[10] = 0;\r\nbuffer[11] = 0;\r\nif (copy_from_user(&buffer[12], buf + done, this_part)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\nn_bytes = roundup(12 + this_part, 4);\r\nmemset(buffer + 12 + this_part, 0, n_bytes - (12 + this_part));\r\ndo {\r\nretval = usb_bulk_msg(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev,\r\ndata->bulk_out),\r\nbuffer, n_bytes,\r\n&actual, USBTMC_TIMEOUT);\r\nif (retval != 0)\r\nbreak;\r\nn_bytes -= actual;\r\n} while (n_bytes);\r\ndata->bTag_last_write = data->bTag;\r\ndata->bTag++;\r\nif (!data->bTag)\r\ndata->bTag++;\r\nif (retval < 0) {\r\ndev_err(&data->intf->dev,\r\n"Unable to send data, error %d\n", retval);\r\nif (data->auto_abort)\r\nusbtmc_ioctl_abort_bulk_out(data);\r\ngoto exit;\r\n}\r\nremaining -= this_part;\r\ndone += this_part;\r\n}\r\nretval = count;\r\nexit:\r\nmutex_unlock(&data->io_mutex);\r\nkfree(buffer);\r\nreturn retval;\r\n}\r\nstatic int usbtmc_ioctl_clear(struct usbtmc_device_data *data)\r\n{\r\nstruct usb_host_interface *current_setting;\r\nstruct usb_endpoint_descriptor *desc;\r\nstruct device *dev;\r\nu8 *buffer;\r\nint rv;\r\nint n;\r\nint actual;\r\nint max_size;\r\ndev = &data->intf->dev;\r\ndev_dbg(dev, "Sending INITIATE_CLEAR request\n");\r\nbuffer = kmalloc(USBTMC_SIZE_IOBUFFER, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_INITIATE_CLEAR,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, 0, buffer, 1, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INITIATE_CLEAR returned %x\n", buffer[0]);\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "INITIATE_CLEAR returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nmax_size = 0;\r\ncurrent_setting = data->intf->cur_altsetting;\r\nfor (n = 0; n < current_setting->desc.bNumEndpoints; n++) {\r\ndesc = &current_setting->endpoint[n].desc;\r\nif (desc->bEndpointAddress == data->bulk_in)\r\nmax_size = usb_endpoint_maxp(desc);\r\n}\r\nif (max_size == 0) {\r\ndev_err(dev, "Couldn't get wMaxPacketSize\n");\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "wMaxPacketSize is %d\n", max_size);\r\nn = 0;\r\nusbtmc_clear_check_status:\r\ndev_dbg(dev, "Sending CHECK_CLEAR_STATUS request\n");\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_CHECK_CLEAR_STATUS,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, 0, buffer, 2, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "CHECK_CLEAR_STATUS returned %x\n", buffer[0]);\r\nif (buffer[0] == USBTMC_STATUS_SUCCESS)\r\ngoto usbtmc_clear_bulk_out_halt;\r\nif (buffer[0] != USBTMC_STATUS_PENDING) {\r\ndev_err(dev, "CHECK_CLEAR_STATUS returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nif (buffer[1] == 1)\r\ndo {\r\ndev_dbg(dev, "Reading from bulk in EP\n");\r\nrv = usb_bulk_msg(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev,\r\ndata->bulk_in),\r\nbuffer, USBTMC_SIZE_IOBUFFER,\r\n&actual, USBTMC_TIMEOUT);\r\nn++;\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n",\r\nrv);\r\ngoto exit;\r\n}\r\n} while ((actual == max_size) &&\r\n(n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN));\r\nif (actual == max_size) {\r\ndev_err(dev, "Couldn't clear device buffer within %d cycles\n",\r\nUSBTMC_MAX_READS_TO_CLEAR_BULK_IN);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\ngoto usbtmc_clear_check_status;\r\nusbtmc_clear_bulk_out_halt:\r\nrv = usb_clear_halt(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev, data->bulk_out));\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\nrv = 0;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic int usbtmc_ioctl_clear_out_halt(struct usbtmc_device_data *data)\r\n{\r\nu8 *buffer;\r\nint rv;\r\nbuffer = kmalloc(2, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_clear_halt(data->usb_dev,\r\nusb_sndbulkpipe(data->usb_dev, data->bulk_out));\r\nif (rv < 0) {\r\ndev_err(&data->usb_dev->dev, "usb_control_msg returned %d\n",\r\nrv);\r\ngoto exit;\r\n}\r\nrv = 0;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic int usbtmc_ioctl_clear_in_halt(struct usbtmc_device_data *data)\r\n{\r\nu8 *buffer;\r\nint rv;\r\nbuffer = kmalloc(2, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_clear_halt(data->usb_dev,\r\nusb_rcvbulkpipe(data->usb_dev, data->bulk_in));\r\nif (rv < 0) {\r\ndev_err(&data->usb_dev->dev, "usb_control_msg returned %d\n",\r\nrv);\r\ngoto exit;\r\n}\r\nrv = 0;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic int get_capabilities(struct usbtmc_device_data *data)\r\n{\r\nstruct device *dev = &data->usb_dev->dev;\r\nchar *buffer;\r\nint rv = 0;\r\nbuffer = kmalloc(0x18, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev, usb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_GET_CAPABILITIES,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, 0, buffer, 0x18, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto err_out;\r\n}\r\ndev_dbg(dev, "GET_CAPABILITIES returned %x\n", buffer[0]);\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "GET_CAPABILITIES returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto err_out;\r\n}\r\ndev_dbg(dev, "Interface capabilities are %x\n", buffer[4]);\r\ndev_dbg(dev, "Device capabilities are %x\n", buffer[5]);\r\ndev_dbg(dev, "USB488 interface capabilities are %x\n", buffer[14]);\r\ndev_dbg(dev, "USB488 device capabilities are %x\n", buffer[15]);\r\ndata->capabilities.interface_capabilities = buffer[4];\r\ndata->capabilities.device_capabilities = buffer[5];\r\ndata->capabilities.usb488_interface_capabilities = buffer[14];\r\ndata->capabilities.usb488_device_capabilities = buffer[15];\r\nrv = 0;\r\nerr_out:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic ssize_t show_TermChar(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usbtmc_device_data *data = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%c\n", data->TermChar);\r\n}\r\nstatic ssize_t store_TermChar(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usbtmc_device_data *data = usb_get_intfdata(intf);\r\nif (count < 1)\r\nreturn -EINVAL;\r\ndata->TermChar = buf[0];\r\nreturn count;\r\n}\r\nstatic int usbtmc_ioctl_indicator_pulse(struct usbtmc_device_data *data)\r\n{\r\nstruct device *dev;\r\nu8 *buffer;\r\nint rv;\r\ndev = &data->intf->dev;\r\nbuffer = kmalloc(2, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nrv = usb_control_msg(data->usb_dev,\r\nusb_rcvctrlpipe(data->usb_dev, 0),\r\nUSBTMC_REQUEST_INDICATOR_PULSE,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, 0, buffer, 0x01, USBTMC_TIMEOUT);\r\nif (rv < 0) {\r\ndev_err(dev, "usb_control_msg returned %d\n", rv);\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "INDICATOR_PULSE returned %x\n", buffer[0]);\r\nif (buffer[0] != USBTMC_STATUS_SUCCESS) {\r\ndev_err(dev, "INDICATOR_PULSE returned %x\n", buffer[0]);\r\nrv = -EPERM;\r\ngoto exit;\r\n}\r\nrv = 0;\r\nexit:\r\nkfree(buffer);\r\nreturn rv;\r\n}\r\nstatic long usbtmc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct usbtmc_device_data *data;\r\nint retval = -EBADRQC;\r\ndata = file->private_data;\r\nmutex_lock(&data->io_mutex);\r\nif (data->zombie) {\r\nretval = -ENODEV;\r\ngoto skip_io_on_zombie;\r\n}\r\nswitch (cmd) {\r\ncase USBTMC_IOCTL_CLEAR_OUT_HALT:\r\nretval = usbtmc_ioctl_clear_out_halt(data);\r\nbreak;\r\ncase USBTMC_IOCTL_CLEAR_IN_HALT:\r\nretval = usbtmc_ioctl_clear_in_halt(data);\r\nbreak;\r\ncase USBTMC_IOCTL_INDICATOR_PULSE:\r\nretval = usbtmc_ioctl_indicator_pulse(data);\r\nbreak;\r\ncase USBTMC_IOCTL_CLEAR:\r\nretval = usbtmc_ioctl_clear(data);\r\nbreak;\r\ncase USBTMC_IOCTL_ABORT_BULK_OUT:\r\nretval = usbtmc_ioctl_abort_bulk_out(data);\r\nbreak;\r\ncase USBTMC_IOCTL_ABORT_BULK_IN:\r\nretval = usbtmc_ioctl_abort_bulk_in(data);\r\nbreak;\r\n}\r\nskip_io_on_zombie:\r\nmutex_unlock(&data->io_mutex);\r\nreturn retval;\r\n}\r\nstatic int usbtmc_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usbtmc_device_data *data;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint n;\r\nint retcode;\r\ndev_dbg(&intf->dev, "%s called\n", __func__);\r\ndata = kmalloc(sizeof(struct usbtmc_device_data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&intf->dev, "Unable to allocate kernel memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->intf = intf;\r\ndata->id = id;\r\ndata->usb_dev = usb_get_dev(interface_to_usbdev(intf));\r\nusb_set_intfdata(intf, data);\r\nkref_init(&data->kref);\r\nmutex_init(&data->io_mutex);\r\ndata->zombie = 0;\r\ndata->bTag = 1;\r\ndata->TermCharEnabled = 0;\r\ndata->TermChar = '\n';\r\niface_desc = data->intf->cur_altsetting;\r\nfor (n = 0; n < iface_desc->desc.bNumEndpoints; n++) {\r\nendpoint = &iface_desc->endpoint[n].desc;\r\nif (usb_endpoint_is_bulk_in(endpoint)) {\r\ndata->bulk_in = endpoint->bEndpointAddress;\r\ndev_dbg(&intf->dev, "Found bulk in endpoint at %u\n",\r\ndata->bulk_in);\r\nbreak;\r\n}\r\n}\r\nfor (n = 0; n < iface_desc->desc.bNumEndpoints; n++) {\r\nendpoint = &iface_desc->endpoint[n].desc;\r\nif (usb_endpoint_is_bulk_out(endpoint)) {\r\ndata->bulk_out = endpoint->bEndpointAddress;\r\ndev_dbg(&intf->dev, "Found Bulk out endpoint at %u\n",\r\ndata->bulk_out);\r\nbreak;\r\n}\r\n}\r\nretcode = get_capabilities(data);\r\nif (retcode)\r\ndev_err(&intf->dev, "can't read capabilities\n");\r\nelse\r\nretcode = sysfs_create_group(&intf->dev.kobj,\r\n&capability_attr_grp);\r\nretcode = sysfs_create_group(&intf->dev.kobj, &data_attr_grp);\r\nretcode = usb_register_dev(intf, &usbtmc_class);\r\nif (retcode) {\r\ndev_err(&intf->dev, "Not able to get a minor"\r\n" (base %u, slice default): %d\n", USBTMC_MINOR_BASE,\r\nretcode);\r\ngoto error_register;\r\n}\r\ndev_dbg(&intf->dev, "Using minor number %d\n", intf->minor);\r\nreturn 0;\r\nerror_register:\r\nsysfs_remove_group(&intf->dev.kobj, &capability_attr_grp);\r\nsysfs_remove_group(&intf->dev.kobj, &data_attr_grp);\r\nkref_put(&data->kref, usbtmc_delete);\r\nreturn retcode;\r\n}\r\nstatic void usbtmc_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usbtmc_device_data *data;\r\ndev_dbg(&intf->dev, "usbtmc_disconnect called\n");\r\ndata = usb_get_intfdata(intf);\r\nusb_deregister_dev(intf, &usbtmc_class);\r\nsysfs_remove_group(&intf->dev.kobj, &capability_attr_grp);\r\nsysfs_remove_group(&intf->dev.kobj, &data_attr_grp);\r\nmutex_lock(&data->io_mutex);\r\ndata->zombie = 1;\r\nmutex_unlock(&data->io_mutex);\r\nkref_put(&data->kref, usbtmc_delete);\r\n}\r\nstatic int usbtmc_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usbtmc_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}
