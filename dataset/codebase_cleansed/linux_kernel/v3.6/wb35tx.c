unsigned char\r\nWb35Tx_get_tx_buffer(struct hw_data * pHwData, u8 **pBuffer)\r\n{\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\n*pBuffer = pWb35Tx->TxBuffer[0];\r\nreturn true;\r\n}\r\nstatic void Wb35Tx_complete(struct urb * pUrb)\r\n{\r\nstruct wbsoft_priv *adapter = pUrb->context;\r\nstruct hw_data * pHwData = &adapter->sHwData;\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\nstruct wb35_mds *pMds = &adapter->Mds;\r\nprintk("wb35: tx complete\n");\r\npWb35Tx->EP4vm_state = VM_COMPLETED;\r\npWb35Tx->EP4VM_status = pUrb->status;\r\npMds->TxOwner[ pWb35Tx->TxSendIndex ] = 0;\r\npWb35Tx->TxSendIndex++;\r\npWb35Tx->TxSendIndex %= MAX_USB_TX_BUFFER_NUMBER;\r\nif (pHwData->SurpriseRemove)\r\ngoto error;\r\nif (pWb35Tx->tx_halt)\r\ngoto error;\r\nif (pWb35Tx->EP4VM_status != 0) {\r\nprintk("URB submission failed\n");\r\npWb35Tx->EP4vm_state = VM_STOP;\r\ngoto error;\r\n}\r\nMds_Tx(adapter);\r\nWb35Tx(adapter);\r\nreturn;\r\nerror:\r\natomic_dec(&pWb35Tx->TxFireCounter);\r\npWb35Tx->EP4vm_state = VM_STOP;\r\n}\r\nstatic void Wb35Tx(struct wbsoft_priv *adapter)\r\n{\r\nstruct hw_data * pHwData = &adapter->sHwData;\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\nu8 *pTxBufferAddress;\r\nstruct wb35_mds *pMds = &adapter->Mds;\r\nstruct urb * pUrb = (struct urb *)pWb35Tx->Tx4Urb;\r\nint retv;\r\nu32 SendIndex;\r\nif (pHwData->SurpriseRemove)\r\ngoto cleanup;\r\nif (pWb35Tx->tx_halt)\r\ngoto cleanup;\r\nSendIndex = pWb35Tx->TxSendIndex;\r\nif (!pMds->TxOwner[SendIndex])\r\ngoto cleanup;\r\npTxBufferAddress = pWb35Tx->TxBuffer[SendIndex];\r\nusb_fill_bulk_urb(pUrb, pHwData->udev,\r\nusb_sndbulkpipe(pHwData->udev, 4),\r\npTxBufferAddress, pMds->TxBufferSize[ SendIndex ],\r\nWb35Tx_complete, adapter);\r\npWb35Tx->EP4vm_state = VM_RUNNING;\r\nretv = usb_submit_urb(pUrb, GFP_ATOMIC);\r\nif (retv<0) {\r\nprintk("EP4 Tx Irp sending error\n");\r\ngoto cleanup;\r\n}\r\npWb35Tx->TxFillCount += pMds->TxCountInBuffer[SendIndex];\r\nif (pWb35Tx->TxFillCount > 12)\r\nWb35Tx_EP2VM_start(adapter);\r\npWb35Tx->ByteTransfer += pMds->TxBufferSize[SendIndex];\r\nreturn;\r\ncleanup:\r\npWb35Tx->EP4vm_state = VM_STOP;\r\natomic_dec(&pWb35Tx->TxFireCounter);\r\n}\r\nvoid Wb35Tx_start(struct wbsoft_priv *adapter)\r\n{\r\nstruct hw_data * pHwData = &adapter->sHwData;\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\nif (atomic_inc_return(&pWb35Tx->TxFireCounter) == 1) {\r\npWb35Tx->EP4vm_state = VM_RUNNING;\r\nWb35Tx(adapter);\r\n} else\r\natomic_dec(&pWb35Tx->TxFireCounter);\r\n}\r\nunsigned char Wb35Tx_initial(struct hw_data * pHwData)\r\n{\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\npWb35Tx->Tx4Urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!pWb35Tx->Tx4Urb)\r\nreturn false;\r\npWb35Tx->Tx2Urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!pWb35Tx->Tx2Urb)\r\n{\r\nusb_free_urb( pWb35Tx->Tx4Urb );\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid Wb35Tx_stop(struct hw_data * pHwData)\r\n{\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\nif (pWb35Tx->EP2vm_state == VM_RUNNING)\r\nusb_unlink_urb( pWb35Tx->Tx2Urb );\r\npr_debug("EP2 Tx stop\n");\r\nif (pWb35Tx->EP4vm_state == VM_RUNNING)\r\nusb_unlink_urb( pWb35Tx->Tx4Urb );\r\npr_debug("EP4 Tx stop\n");\r\n}\r\nvoid Wb35Tx_destroy(struct hw_data * pHwData)\r\n{\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\ndo {\r\nmsleep(10);\r\n} while( (pWb35Tx->EP2vm_state != VM_STOP) && (pWb35Tx->EP4vm_state != VM_STOP) );\r\nmsleep(10);\r\nif (pWb35Tx->Tx4Urb)\r\nusb_free_urb( pWb35Tx->Tx4Urb );\r\nif (pWb35Tx->Tx2Urb)\r\nusb_free_urb( pWb35Tx->Tx2Urb );\r\npr_debug("Wb35Tx_destroy OK\n");\r\n}\r\nvoid Wb35Tx_CurrentTime(struct wbsoft_priv *adapter, u32 TimeCount)\r\n{\r\nstruct hw_data * pHwData = &adapter->sHwData;\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\nunsigned char Trigger = false;\r\nif (pWb35Tx->TxTimer > TimeCount)\r\nTrigger = true;\r\nelse if (TimeCount > (pWb35Tx->TxTimer+500))\r\nTrigger = true;\r\nif (Trigger) {\r\npWb35Tx->TxTimer = TimeCount;\r\nWb35Tx_EP2VM_start(adapter);\r\n}\r\n}\r\nstatic void Wb35Tx_EP2VM_complete(struct urb * pUrb)\r\n{\r\nstruct wbsoft_priv *adapter = pUrb->context;\r\nstruct hw_data * pHwData = &adapter->sHwData;\r\nstruct T02_descriptor T02, TSTATUS;\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\nu32 * pltmp = (u32 *)pWb35Tx->EP2_buf;\r\nu32 i;\r\nu16 InterruptInLength;\r\npWb35Tx->EP2vm_state = VM_COMPLETED;\r\npWb35Tx->EP2VM_status = pUrb->status;\r\nif (pHwData->SurpriseRemove)\r\ngoto error;\r\nif (pWb35Tx->tx_halt)\r\ngoto error;\r\nif (pWb35Tx->EP2VM_status != 0) {\r\nprintk("EP2 IoCompleteRoutine return error\n");\r\npWb35Tx->EP2vm_state= VM_STOP;\r\ngoto error;\r\n}\r\nInterruptInLength = pUrb->actual_length;\r\nT02.value = cpu_to_le32(pltmp[0]) >> 8;\r\nInterruptInLength -= 1;\r\nInterruptInLength >>= 2;\r\nfor (i = 1; i <= InterruptInLength; i++) {\r\nT02.value |= ((cpu_to_le32(pltmp[i]) & 0xff) << 24);\r\nTSTATUS.value = T02.value;\r\nMds_SendComplete( adapter, &TSTATUS );\r\nT02.value = cpu_to_le32(pltmp[i]) >> 8;\r\n}\r\nreturn;\r\nerror:\r\natomic_dec(&pWb35Tx->TxResultCount);\r\npWb35Tx->EP2vm_state = VM_STOP;\r\n}\r\nstatic void Wb35Tx_EP2VM(struct wbsoft_priv *adapter)\r\n{\r\nstruct hw_data * pHwData = &adapter->sHwData;\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\nstruct urb * pUrb = (struct urb *)pWb35Tx->Tx2Urb;\r\nu32 * pltmp = (u32 *)pWb35Tx->EP2_buf;\r\nint retv;\r\nif (pHwData->SurpriseRemove)\r\ngoto error;\r\nif (pWb35Tx->tx_halt)\r\ngoto error;\r\nusb_fill_int_urb( pUrb, pHwData->udev, usb_rcvintpipe(pHwData->udev,2),\r\npltmp, MAX_INTERRUPT_LENGTH, Wb35Tx_EP2VM_complete, adapter, 32);\r\npWb35Tx->EP2vm_state = VM_RUNNING;\r\nretv = usb_submit_urb(pUrb, GFP_ATOMIC);\r\nif (retv < 0) {\r\npr_debug("EP2 Tx Irp sending error\n");\r\ngoto error;\r\n}\r\nreturn;\r\nerror:\r\npWb35Tx->EP2vm_state = VM_STOP;\r\natomic_dec(&pWb35Tx->TxResultCount);\r\n}\r\nvoid Wb35Tx_EP2VM_start(struct wbsoft_priv *adapter)\r\n{\r\nstruct hw_data * pHwData = &adapter->sHwData;\r\nstruct wb35_tx *pWb35Tx = &pHwData->Wb35Tx;\r\nif (atomic_inc_return(&pWb35Tx->TxResultCount) == 1) {\r\npWb35Tx->EP2vm_state = VM_RUNNING;\r\nWb35Tx_EP2VM(adapter);\r\n} else\r\natomic_dec(&pWb35Tx->TxResultCount);\r\n}
