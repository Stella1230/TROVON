static void set_dma_ctrl(struct fbd *fb_desc, u32 ctrl)\r\n{\r\nfb_desc->dma_ctrl = ctrl;\r\n}\r\nstatic void isi_writel(struct atmel_isi *isi, u32 reg, u32 val)\r\n{\r\nwritel(val, isi->regs + reg);\r\n}\r\nstatic u32 isi_readl(struct atmel_isi *isi, u32 reg)\r\n{\r\nreturn readl(isi->regs + reg);\r\n}\r\nstatic int configure_geometry(struct atmel_isi *isi, u32 width,\r\nu32 height, enum v4l2_mbus_pixelcode code)\r\n{\r\nu32 cfg2, cr;\r\nswitch (code) {\r\ncase V4L2_MBUS_FMT_Y8_1X8:\r\ncr = ISI_CFG2_GRAYSCALE;\r\nbreak;\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ncr = ISI_CFG2_YCC_SWAP_MODE_3;\r\nbreak;\r\ncase V4L2_MBUS_FMT_VYUY8_2X8:\r\ncr = ISI_CFG2_YCC_SWAP_MODE_2;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\ncr = ISI_CFG2_YCC_SWAP_MODE_1;\r\nbreak;\r\ncase V4L2_MBUS_FMT_YVYU8_2X8:\r\ncr = ISI_CFG2_YCC_SWAP_DEFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\ncfg2 = isi_readl(isi, ISI_CFG2);\r\ncfg2 |= cr;\r\ncfg2 &= ~(ISI_CFG2_IM_HSIZE_MASK);\r\ncfg2 |= ((width - 1) << ISI_CFG2_IM_HSIZE_OFFSET) &\r\nISI_CFG2_IM_HSIZE_MASK;\r\ncfg2 &= ~(ISI_CFG2_IM_VSIZE_MASK);\r\ncfg2 |= ((height - 1) << ISI_CFG2_IM_VSIZE_OFFSET)\r\n& ISI_CFG2_IM_VSIZE_MASK;\r\nisi_writel(isi, ISI_CFG2, cfg2);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t atmel_isi_handle_streaming(struct atmel_isi *isi)\r\n{\r\nif (isi->active) {\r\nstruct vb2_buffer *vb = &isi->active->vb;\r\nstruct frame_buffer *buf = isi->active;\r\nlist_del_init(&buf->list);\r\ndo_gettimeofday(&vb->v4l2_buf.timestamp);\r\nvb->v4l2_buf.sequence = isi->sequence++;\r\nvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\r\n}\r\nif (list_empty(&isi->video_buffer_list)) {\r\nisi->active = NULL;\r\n} else {\r\nisi->active = list_entry(isi->video_buffer_list.next,\r\nstruct frame_buffer, list);\r\nisi_writel(isi, ISI_DMA_C_DSCR,\r\nisi->active->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_C_CTRL,\r\nISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_C_CH);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t isi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_isi *isi = dev_id;\r\nu32 status, mask, pending;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&isi->lock);\r\nstatus = isi_readl(isi, ISI_STATUS);\r\nmask = isi_readl(isi, ISI_INTMASK);\r\npending = status & mask;\r\nif (pending & ISI_CTRL_SRST) {\r\ncomplete(&isi->complete);\r\nisi_writel(isi, ISI_INTDIS, ISI_CTRL_SRST);\r\nret = IRQ_HANDLED;\r\n} else if (pending & ISI_CTRL_DIS) {\r\ncomplete(&isi->complete);\r\nisi_writel(isi, ISI_INTDIS, ISI_CTRL_DIS);\r\nret = IRQ_HANDLED;\r\n} else {\r\nif ((pending & ISI_SR_VSYNC) &&\r\n(isi->state == ISI_STATE_IDLE)) {\r\nisi->state = ISI_STATE_READY;\r\nwake_up_interruptible(&isi->vsync_wq);\r\nret = IRQ_HANDLED;\r\n}\r\nif (likely(pending & ISI_SR_CXFR_DONE))\r\nret = atmel_isi_handle_streaming(isi);\r\n}\r\nspin_unlock(&isi->lock);\r\nreturn ret;\r\n}\r\nstatic int atmel_isi_wait_status(struct atmel_isi *isi, int wait_reset)\r\n{\r\nunsigned long timeout;\r\ninit_completion(&isi->complete);\r\nif (wait_reset) {\r\nisi_writel(isi, ISI_INTEN, ISI_CTRL_SRST);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_SRST);\r\n} else {\r\nisi_writel(isi, ISI_INTEN, ISI_CTRL_DIS);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\n}\r\ntimeout = wait_for_completion_timeout(&isi->complete,\r\nmsecs_to_jiffies(100));\r\nif (timeout == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nunsigned long size;\r\nint ret;\r\nret = atmel_isi_wait_status(isi, WAIT_ISI_RESET);\r\nif (ret < 0) {\r\ndev_err(icd->parent, "Reset ISI timed out\n");\r\nreturn ret;\r\n}\r\nisi_writel(isi, ISI_INTDIS, ~0UL);\r\nsize = icd->sizeimage;\r\nif (!*nbuffers || *nbuffers > MAX_BUFFER_NUM)\r\n*nbuffers = MAX_BUFFER_NUM;\r\nif (size * *nbuffers > VID_LIMIT_BYTES)\r\n*nbuffers = VID_LIMIT_BYTES / size;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = isi->alloc_ctx;\r\nisi->sequence = 0;\r\nisi->active = NULL;\r\ndev_dbg(icd->parent, "%s, count=%d, size=%ld\n", __func__,\r\n*nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic int buffer_init(struct vb2_buffer *vb)\r\n{\r\nstruct frame_buffer *buf = container_of(vb, struct frame_buffer, vb);\r\nbuf->p_dma_desc = NULL;\r\nINIT_LIST_HEAD(&buf->list);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct frame_buffer *buf = container_of(vb, struct frame_buffer, vb);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nunsigned long size;\r\nstruct isi_dma_desc *desc;\r\nsize = icd->sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndev_err(icd->parent, "%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(&buf->vb, 0, size);\r\nif (!buf->p_dma_desc) {\r\nif (list_empty(&isi->dma_desc_head)) {\r\ndev_err(icd->parent, "Not enough dma descriptors.\n");\r\nreturn -EINVAL;\r\n} else {\r\ndesc = list_entry(isi->dma_desc_head.next,\r\nstruct isi_dma_desc, list);\r\nlist_del_init(&desc->list);\r\ndesc->p_fbd->fb_address =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\ndesc->p_fbd->next_fbd_address = 0;\r\nset_dma_ctrl(desc->p_fbd, ISI_DMA_CTRL_WB);\r\nbuf->p_dma_desc = desc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void buffer_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct frame_buffer *buf = container_of(vb, struct frame_buffer, vb);\r\nif (buf->p_dma_desc)\r\nlist_add(&buf->p_dma_desc->list, &isi->dma_desc_head);\r\n}\r\nstatic void start_dma(struct atmel_isi *isi, struct frame_buffer *buffer)\r\n{\r\nu32 ctrl, cfg1;\r\ncfg1 = isi_readl(isi, ISI_CFG1);\r\nisi_writel(isi, ISI_INTEN,\r\nISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\r\nif (isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) {\r\ndev_err(isi->icd->parent, "Already in frame handling.\n");\r\nreturn;\r\n}\r\nisi_writel(isi, ISI_DMA_C_DSCR, buffer->p_dma_desc->fbd_phys);\r\nisi_writel(isi, ISI_DMA_C_CTRL, ISI_DMA_CTRL_FETCH | ISI_DMA_CTRL_DONE);\r\nisi_writel(isi, ISI_DMA_CHER, ISI_DMA_CHSR_C_CH);\r\ncfg1 |= isi->pdata->frate | ISI_CFG1_DISCR;\r\nctrl = ISI_CTRL_CDC | ISI_CTRL_EN;\r\nisi_writel(isi, ISI_CTRL, ctrl);\r\nisi_writel(isi, ISI_CFG1, cfg1);\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct frame_buffer *buf = container_of(vb, struct frame_buffer, vb);\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&isi->lock, flags);\r\nlist_add_tail(&buf->list, &isi->video_buffer_list);\r\nif (isi->active == NULL) {\r\nisi->active = buf;\r\nif (vb2_is_streaming(vb->vb2_queue))\r\nstart_dma(isi, buf);\r\n}\r\nspin_unlock_irqrestore(&isi->lock, flags);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nu32 sr = 0;\r\nint ret;\r\nspin_lock_irq(&isi->lock);\r\nisi->state = ISI_STATE_IDLE;\r\nsr = isi_readl(isi, ISI_STATUS);\r\nisi_writel(isi, ISI_INTEN, ISI_SR_VSYNC);\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_EN);\r\nspin_unlock_irq(&isi->lock);\r\ndev_dbg(icd->parent, "Waiting for SOF\n");\r\nret = wait_event_interruptible(isi->vsync_wq,\r\nisi->state != ISI_STATE_IDLE);\r\nif (ret)\r\ngoto err;\r\nif (isi->state != ISI_STATE_READY) {\r\nret = -EIO;\r\ngoto err;\r\n}\r\nspin_lock_irq(&isi->lock);\r\nisi->state = ISI_STATE_WAIT_SOF;\r\nisi_writel(isi, ISI_INTDIS, ISI_SR_VSYNC);\r\nif (count)\r\nstart_dma(isi, isi->active);\r\nspin_unlock_irq(&isi->lock);\r\nreturn 0;\r\nerr:\r\nisi->active = NULL;\r\nisi->sequence = 0;\r\nINIT_LIST_HEAD(&isi->video_buffer_list);\r\nreturn ret;\r\n}\r\nstatic int stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct frame_buffer *buf, *node;\r\nint ret = 0;\r\nunsigned long timeout;\r\nspin_lock_irq(&isi->lock);\r\nisi->active = NULL;\r\nlist_for_each_entry_safe(buf, node, &isi->video_buffer_list, list) {\r\nlist_del_init(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irq(&isi->lock);\r\ntimeout = jiffies + FRAME_INTERVAL_MILLI_SEC * HZ;\r\nwhile ((isi_readl(isi, ISI_STATUS) & ISI_CTRL_CDC) &&\r\ntime_before(jiffies, timeout))\r\nmsleep(1);\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(icd->parent,\r\n"Timeout waiting for finishing codec request\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nisi_writel(isi, ISI_INTDIS,\r\nISI_SR_CXFR_DONE | ISI_SR_PXFR_DONE);\r\nret = atmel_isi_wait_status(isi, WAIT_ISI_DISABLE);\r\nif (ret < 0)\r\ndev_err(icd->parent, "Disable ISI timed out\n");\r\nreturn ret;\r\n}\r\nstatic int isi_camera_init_videobuf(struct vb2_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP;\r\nq->drv_priv = icd;\r\nq->buf_struct_size = sizeof(struct frame_buffer);\r\nq->ops = &isi_video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nreturn vb2_queue_init(q);\r\n}\r\nstatic int isi_camera_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(icd->parent, "Plan to set format %dx%d\n",\r\npix->width, pix->height);\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mf.code != xlate->code)\r\nreturn -EINVAL;\r\nret = configure_geometry(isi, pix->width, pix->height, xlate->code);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\nicd->current_fmt = xlate;\r\ndev_dbg(icd->parent, "Finally set format %dx%d\n",\r\npix->width, pix->height);\r\nreturn ret;\r\n}\r\nstatic int isi_camera_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\nu32 pixfmt = pix->pixelformat;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (pixfmt && !xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\nif (pix->height > MAX_SUPPORT_HEIGHT)\r\npix->height = MAX_SUPPORT_HEIGHT;\r\nif (pix->width > MAX_SUPPORT_WIDTH)\r\npix->width = MAX_SUPPORT_WIDTH;\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->colorspace = mf.colorspace;\r\nswitch (mf.field) {\r\ncase V4L2_FIELD_ANY:\r\npix->field = V4L2_FIELD_NONE;\r\nbreak;\r\ncase V4L2_FIELD_NONE:\r\nbreak;\r\ndefault:\r\ndev_err(icd->parent, "Field type %d unsupported.\n",\r\nmf.field);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool isi_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)\r\n{\r\nreturn fmt->packing == SOC_MBUS_PACKING_NONE ||\r\n(fmt->bits_per_sample == 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_2X8_PADHI) ||\r\n(fmt->bits_per_sample > 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_EXTEND16);\r\n}\r\nstatic int isi_camera_try_bus_param(struct soc_camera_device *icd,\r\nunsigned char buswidth)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long common_flags;\r\nint ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nISI_BUS_PARAM);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%x\n",\r\ncfg.flags, ISI_BUS_PARAM);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n}\r\nif ((1 << (buswidth - 1)) & isi->width_flags)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int isi_camera_get_formats(struct soc_camera_device *icd,\r\nunsigned int idx,\r\nstruct soc_camera_format_xlate *xlate)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nint formats = 0, ret;\r\nenum v4l2_mbus_pixelcode code;\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = soc_mbus_get_fmtdesc(code);\r\nif (!fmt) {\r\ndev_err(icd->parent,\r\n"Invalid format code #%u: %d\n", idx, code);\r\nreturn 0;\r\n}\r\nret = isi_camera_try_bus_param(icd, fmt->bits_per_sample);\r\nif (ret < 0) {\r\ndev_err(icd->parent,\r\n"Fail to try the bus parameters.\n");\r\nreturn 0;\r\n}\r\nswitch (code) {\r\ncase V4L2_MBUS_FMT_UYVY8_2X8:\r\ncase V4L2_MBUS_FMT_VYUY8_2X8:\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\ncase V4L2_MBUS_FMT_YVYU8_2X8:\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = &isi_camera_formats[0];\r\nxlate->code = code;\r\nxlate++;\r\ndev_dbg(icd->parent, "Providing format %s using code %d\n",\r\nisi_camera_formats[0].name, code);\r\n}\r\nbreak;\r\ndefault:\r\nif (!isi_camera_packing_supported(fmt))\r\nreturn 0;\r\nif (xlate)\r\ndev_dbg(icd->parent,\r\n"Providing format %s in pass-through mode\n",\r\nfmt->name);\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code;\r\nxlate++;\r\n}\r\nreturn formats;\r\n}\r\nstatic int isi_camera_add_device(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nint ret;\r\nif (isi->icd)\r\nreturn -EBUSY;\r\nret = clk_enable(isi->pclk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_enable(isi->mck);\r\nif (ret) {\r\nclk_disable(isi->pclk);\r\nreturn ret;\r\n}\r\nisi->icd = icd;\r\ndev_dbg(icd->parent, "Atmel ISI Camera driver attached to camera %d\n",\r\nicd->devnum);\r\nreturn 0;\r\n}\r\nstatic void isi_camera_remove_device(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nBUG_ON(icd != isi->icd);\r\nclk_disable(isi->mck);\r\nclk_disable(isi->pclk);\r\nisi->icd = NULL;\r\ndev_dbg(icd->parent, "Atmel ISI Camera driver detached from camera %d\n",\r\nicd->devnum);\r\n}\r\nstatic unsigned int isi_camera_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nreturn vb2_poll(&icd->vb2_vidq, file, pt);\r\n}\r\nstatic int isi_camera_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrcpy(cap->driver, "atmel-isi");\r\nstrcpy(cap->card, "Atmel Image Sensor Interface");\r\ncap->capabilities = (V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING);\r\nreturn 0;\r\n}\r\nstatic int isi_camera_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct atmel_isi *isi = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long common_flags;\r\nint ret;\r\nu32 cfg1 = 0;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nISI_BUS_PARAM);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%x\n",\r\ncfg.flags, ISI_BUS_PARAM);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = ISI_BUS_PARAM;\r\n}\r\ndev_dbg(icd->parent, "Flags cam: 0x%x host: 0x%x common: 0x%lx\n",\r\ncfg.flags, ISI_BUS_PARAM, common_flags);\r\nif ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {\r\nif (isi->pdata->hsync_act_low)\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {\r\nif (isi->pdata->vsync_act_low)\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (isi->pdata->pclk_act_falling)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\nif (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\ncfg1 |= ISI_CFG1_HSYNC_POL_ACTIVE_LOW;\r\nif (common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\ncfg1 |= ISI_CFG1_VSYNC_POL_ACTIVE_LOW;\r\nif (common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\ncfg1 |= ISI_CFG1_PIXCLK_POL_ACTIVE_FALLING;\r\nif (isi->pdata->has_emb_sync)\r\ncfg1 |= ISI_CFG1_EMB_SYNC;\r\nif (isi->pdata->full_mode)\r\ncfg1 |= ISI_CFG1_FULL_MODE;\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\nisi_writel(isi, ISI_CFG1, cfg1);\r\nreturn 0;\r\n}\r\nstatic int __devexit atmel_isi_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct atmel_isi *isi = container_of(soc_host,\r\nstruct atmel_isi, soc_host);\r\nfree_irq(isi->irq, isi);\r\nsoc_camera_host_unregister(soc_host);\r\nvb2_dma_contig_cleanup_ctx(isi->alloc_ctx);\r\ndma_free_coherent(&pdev->dev,\r\nsizeof(struct fbd) * MAX_BUFFER_NUM,\r\nisi->p_fb_descriptors,\r\nisi->fb_descriptors_phys);\r\niounmap(isi->regs);\r\nclk_unprepare(isi->mck);\r\nclk_put(isi->mck);\r\nclk_unprepare(isi->pclk);\r\nclk_put(isi->pclk);\r\nkfree(isi);\r\nreturn 0;\r\n}\r\nstatic int __devinit atmel_isi_probe(struct platform_device *pdev)\r\n{\r\nunsigned int irq;\r\nstruct atmel_isi *isi;\r\nstruct clk *pclk;\r\nstruct resource *regs;\r\nint ret, i;\r\nstruct device *dev = &pdev->dev;\r\nstruct soc_camera_host *soc_host;\r\nstruct isi_platform_data *pdata;\r\npdata = dev->platform_data;\r\nif (!pdata || !pdata->data_width_flags || !pdata->mck_hz) {\r\ndev_err(&pdev->dev,\r\n"No config available for Atmel ISI\n");\r\nreturn -EINVAL;\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs)\r\nreturn -ENXIO;\r\npclk = clk_get(&pdev->dev, "isi_clk");\r\nif (IS_ERR(pclk))\r\nreturn PTR_ERR(pclk);\r\nret = clk_prepare(pclk);\r\nif (ret)\r\ngoto err_clk_prepare_pclk;\r\nisi = kzalloc(sizeof(struct atmel_isi), GFP_KERNEL);\r\nif (!isi) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "Can't allocate interface!\n");\r\ngoto err_alloc_isi;\r\n}\r\nisi->pclk = pclk;\r\nisi->pdata = pdata;\r\nisi->active = NULL;\r\nspin_lock_init(&isi->lock);\r\ninit_waitqueue_head(&isi->vsync_wq);\r\nINIT_LIST_HEAD(&isi->video_buffer_list);\r\nINIT_LIST_HEAD(&isi->dma_desc_head);\r\nisi->mck = clk_get(dev, "isi_mck");\r\nif (IS_ERR(isi->mck)) {\r\ndev_err(dev, "Failed to get isi_mck\n");\r\nret = PTR_ERR(isi->mck);\r\ngoto err_clk_get;\r\n}\r\nret = clk_prepare(isi->mck);\r\nif (ret)\r\ngoto err_clk_prepare_mck;\r\nret = clk_set_rate(isi->mck, pdata->mck_hz);\r\nif (ret < 0)\r\ngoto err_set_mck_rate;\r\nisi->p_fb_descriptors = dma_alloc_coherent(&pdev->dev,\r\nsizeof(struct fbd) * MAX_BUFFER_NUM,\r\n&isi->fb_descriptors_phys,\r\nGFP_KERNEL);\r\nif (!isi->p_fb_descriptors) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "Can't allocate descriptors!\n");\r\ngoto err_alloc_descriptors;\r\n}\r\nfor (i = 0; i < MAX_BUFFER_NUM; i++) {\r\nisi->dma_desc[i].p_fbd = isi->p_fb_descriptors + i;\r\nisi->dma_desc[i].fbd_phys = isi->fb_descriptors_phys +\r\ni * sizeof(struct fbd);\r\nlist_add(&isi->dma_desc[i].list, &isi->dma_desc_head);\r\n}\r\nisi->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(isi->alloc_ctx)) {\r\nret = PTR_ERR(isi->alloc_ctx);\r\ngoto err_alloc_ctx;\r\n}\r\nisi->regs = ioremap(regs->start, resource_size(regs));\r\nif (!isi->regs) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nif (pdata->data_width_flags & ISI_DATAWIDTH_8)\r\nisi->width_flags = 1 << 7;\r\nif (pdata->data_width_flags & ISI_DATAWIDTH_10)\r\nisi->width_flags |= 1 << 9;\r\nisi_writel(isi, ISI_CTRL, ISI_CTRL_DIS);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto err_req_irq;\r\n}\r\nret = request_irq(irq, isi_interrupt, 0, "isi", isi);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to request irq %d\n", irq);\r\ngoto err_req_irq;\r\n}\r\nisi->irq = irq;\r\nsoc_host = &isi->soc_host;\r\nsoc_host->drv_name = "isi-camera";\r\nsoc_host->ops = &isi_soc_camera_host_ops;\r\nsoc_host->priv = isi;\r\nsoc_host->v4l2_dev.dev = &pdev->dev;\r\nsoc_host->nr = pdev->id;\r\nret = soc_camera_host_register(soc_host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to register soc camera host\n");\r\ngoto err_register_soc_camera_host;\r\n}\r\nreturn 0;\r\nerr_register_soc_camera_host:\r\nfree_irq(isi->irq, isi);\r\nerr_req_irq:\r\niounmap(isi->regs);\r\nerr_ioremap:\r\nvb2_dma_contig_cleanup_ctx(isi->alloc_ctx);\r\nerr_alloc_ctx:\r\ndma_free_coherent(&pdev->dev,\r\nsizeof(struct fbd) * MAX_BUFFER_NUM,\r\nisi->p_fb_descriptors,\r\nisi->fb_descriptors_phys);\r\nerr_alloc_descriptors:\r\nerr_set_mck_rate:\r\nclk_unprepare(isi->mck);\r\nerr_clk_prepare_mck:\r\nclk_put(isi->mck);\r\nerr_clk_get:\r\nkfree(isi);\r\nerr_alloc_isi:\r\nclk_unprepare(pclk);\r\nerr_clk_prepare_pclk:\r\nclk_put(pclk);\r\nreturn ret;\r\n}\r\nstatic int __init atmel_isi_init_module(void)\r\n{\r\nreturn platform_driver_probe(&atmel_isi_driver, &atmel_isi_probe);\r\n}\r\nstatic void __exit atmel_isi_exit(void)\r\n{\r\nplatform_driver_unregister(&atmel_isi_driver);\r\n}
