static irqreturn_t iio_gpio_trigger_poll(int irq, void *private)\r\n{\r\niio_trigger_poll(private, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int iio_gpio_trigger_probe(struct platform_device *pdev)\r\n{\r\nstruct iio_gpio_trigger_info *trig_info;\r\nstruct iio_trigger *trig, *trig2;\r\nunsigned long irqflags;\r\nstruct resource *irq_res;\r\nint irq, ret = 0, irq_res_cnt = 0;\r\ndo {\r\nirq_res = platform_get_resource(pdev,\r\nIORESOURCE_IRQ, irq_res_cnt);\r\nif (irq_res == NULL) {\r\nif (irq_res_cnt == 0)\r\ndev_err(&pdev->dev, "No GPIO IRQs specified");\r\nbreak;\r\n}\r\nirqflags = (irq_res->flags & IRQF_TRIGGER_MASK) | IRQF_SHARED;\r\nfor (irq = irq_res->start; irq <= irq_res->end; irq++) {\r\ntrig = iio_trigger_alloc("irqtrig%d", irq);\r\nif (!trig) {\r\nret = -ENOMEM;\r\ngoto error_free_completed_registrations;\r\n}\r\ntrig_info = kzalloc(sizeof(*trig_info), GFP_KERNEL);\r\nif (!trig_info) {\r\nret = -ENOMEM;\r\ngoto error_put_trigger;\r\n}\r\ntrig->private_data = trig_info;\r\ntrig_info->irq = irq;\r\ntrig->ops = &iio_gpio_trigger_ops;\r\nret = request_irq(irq, iio_gpio_trigger_poll,\r\nirqflags, trig->name, trig);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"request IRQ-%d failed", irq);\r\ngoto error_free_trig_info;\r\n}\r\nret = iio_trigger_register(trig);\r\nif (ret)\r\ngoto error_release_irq;\r\nlist_add_tail(&trig->alloc_list,\r\n&iio_gpio_trigger_list);\r\n}\r\nirq_res_cnt++;\r\n} while (irq_res != NULL);\r\nreturn 0;\r\nerror_release_irq:\r\nfree_irq(irq, trig);\r\nerror_free_trig_info:\r\nkfree(trig_info);\r\nerror_put_trigger:\r\niio_trigger_put(trig);\r\nerror_free_completed_registrations:\r\nlist_for_each_entry_safe(trig,\r\ntrig2,\r\n&iio_gpio_trigger_list,\r\nalloc_list) {\r\ntrig_info = trig->private_data;\r\nfree_irq(gpio_to_irq(trig_info->irq), trig);\r\nkfree(trig_info);\r\niio_trigger_unregister(trig);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iio_gpio_trigger_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_trigger *trig, *trig2;\r\nstruct iio_gpio_trigger_info *trig_info;\r\nmutex_lock(&iio_gpio_trigger_list_lock);\r\nlist_for_each_entry_safe(trig,\r\ntrig2,\r\n&iio_gpio_trigger_list,\r\nalloc_list) {\r\ntrig_info = trig->private_data;\r\niio_trigger_unregister(trig);\r\nfree_irq(trig_info->irq, trig);\r\nkfree(trig_info);\r\niio_trigger_put(trig);\r\n}\r\nmutex_unlock(&iio_gpio_trigger_list_lock);\r\nreturn 0;\r\n}
