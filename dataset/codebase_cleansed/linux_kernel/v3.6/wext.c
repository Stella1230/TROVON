static int orinoco_set_key(struct orinoco_private *priv, int index,\r\nenum orinoco_alg alg, const u8 *key, int key_len,\r\nconst u8 *seq, int seq_len)\r\n{\r\nkzfree(priv->keys[index].key);\r\nkzfree(priv->keys[index].seq);\r\nif (key_len) {\r\npriv->keys[index].key = kzalloc(key_len, GFP_ATOMIC);\r\nif (!priv->keys[index].key)\r\ngoto nomem;\r\n} else\r\npriv->keys[index].key = NULL;\r\nif (seq_len) {\r\npriv->keys[index].seq = kzalloc(seq_len, GFP_ATOMIC);\r\nif (!priv->keys[index].seq)\r\ngoto free_key;\r\n} else\r\npriv->keys[index].seq = NULL;\r\npriv->keys[index].key_len = key_len;\r\npriv->keys[index].seq_len = seq_len;\r\nif (key_len)\r\nmemcpy(priv->keys[index].key, key, key_len);\r\nif (seq_len)\r\nmemcpy(priv->keys[index].seq, seq, seq_len);\r\nswitch (alg) {\r\ncase ORINOCO_ALG_TKIP:\r\npriv->keys[index].cipher = WLAN_CIPHER_SUITE_TKIP;\r\nbreak;\r\ncase ORINOCO_ALG_WEP:\r\npriv->keys[index].cipher = (key_len > SMALL_KEY_SIZE) ?\r\nWLAN_CIPHER_SUITE_WEP104 : WLAN_CIPHER_SUITE_WEP40;\r\nbreak;\r\ncase ORINOCO_ALG_NONE:\r\ndefault:\r\npriv->keys[index].cipher = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\nfree_key:\r\nkfree(priv->keys[index].key);\r\npriv->keys[index].key = NULL;\r\nnomem:\r\npriv->keys[index].key_len = 0;\r\npriv->keys[index].seq_len = 0;\r\npriv->keys[index].cipher = 0;\r\nreturn -ENOMEM;\r\n}\r\nstatic struct iw_statistics *orinoco_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct hermes *hw = &priv->hw;\r\nstruct iw_statistics *wstats = &priv->wstats;\r\nint err;\r\nunsigned long flags;\r\nif (!netif_device_present(dev)) {\r\nprintk(KERN_WARNING "%s: get_wireless_stats() called while device not present\n",\r\ndev->name);\r\nreturn NULL;\r\n}\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn wstats;\r\nhermes_inquire(hw, HERMES_INQ_TALLIES);\r\nif (priv->iw_mode == NL80211_IFTYPE_ADHOC) {\r\nmemset(&wstats->qual, 0, sizeof(wstats->qual));\r\nif (SPY_NUMBER(priv)) {\r\nwstats->qual.qual = priv->spy_data.spy_stat[0].qual;\r\nwstats->qual.level = priv->spy_data.spy_stat[0].level;\r\nwstats->qual.noise = priv->spy_data.spy_stat[0].noise;\r\nwstats->qual.updated =\r\npriv->spy_data.spy_stat[0].updated;\r\n}\r\n} else {\r\nstruct {\r\n__le16 qual, signal, noise, unused;\r\n} __packed cq;\r\nerr = HERMES_READ_RECORD(hw, USER_BAP,\r\nHERMES_RID_COMMSQUALITY, &cq);\r\nif (!err) {\r\nwstats->qual.qual = (int)le16_to_cpu(cq.qual);\r\nwstats->qual.level = (int)le16_to_cpu(cq.signal) - 0x95;\r\nwstats->qual.noise = (int)le16_to_cpu(cq.noise) - 0x95;\r\nwstats->qual.updated =\r\nIW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\r\n}\r\n}\r\norinoco_unlock(priv, &flags);\r\nreturn wstats;\r\n}\r\nstatic int orinoco_ioctl_setwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *ap_addr,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint err = -EINPROGRESS;\r\nunsigned long flags;\r\nstatic const u8 off_addr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nstatic const u8 any_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nif (memcmp(&ap_addr->sa_data, off_addr, ETH_ALEN) == 0 ||\r\nmemcmp(&ap_addr->sa_data, any_addr, ETH_ALEN) == 0) {\r\npriv->bssid_fixed = 0;\r\nmemset(priv->desired_bssid, 0, ETH_ALEN);\r\nif (ap_addr->sa_data[0] == 0) {\r\n__orinoco_hw_set_wap(priv);\r\nerr = 0;\r\n}\r\ngoto out;\r\n}\r\nif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\r\nprintk(KERN_WARNING "%s: Lucent/Agere firmware doesn't "\r\n"support manual roaming\n",\r\ndev->name);\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (priv->iw_mode != NL80211_IFTYPE_STATION) {\r\nprintk(KERN_WARNING "%s: Manual roaming supported only in "\r\n"managed mode\n", dev->name);\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\r\nstrlen(priv->desired_essid) == 0) {\r\nprintk(KERN_WARNING "%s: Desired ESSID must be set for "\r\n"manual roaming\n", dev->name);\r\nerr = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\npriv->bssid_fixed = 1;\r\nmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\r\nout:\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_getwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *ap_addr,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint err = 0;\r\nunsigned long flags;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nap_addr->sa_family = ARPHRD_ETHER;\r\nerr = orinoco_hw_get_current_bssid(priv, ap_addr->sa_data);\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_setiwencode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq,\r\nchar *keybuf)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint index = (erq->flags & IW_ENCODE_INDEX) - 1;\r\nint setindex = priv->tx_key;\r\nenum orinoco_alg encode_alg = priv->encode_alg;\r\nint restricted = priv->wep_restrict;\r\nint err = -EINPROGRESS;\r\nunsigned long flags;\r\nif (!priv->has_wep)\r\nreturn -EOPNOTSUPP;\r\nif (erq->pointer) {\r\nif (erq->length > LARGE_KEY_SIZE)\r\nreturn -E2BIG;\r\nif ((erq->length > SMALL_KEY_SIZE) && !priv->has_big_wep)\r\nreturn -E2BIG;\r\n}\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nif ((priv->has_wpa) && (priv->encode_alg == ORINOCO_ALG_TKIP))\r\n(void) orinoco_clear_tkip_key(priv, setindex);\r\nif (erq->length > 0) {\r\nif ((index < 0) || (index >= ORINOCO_MAX_KEYS))\r\nindex = priv->tx_key;\r\nif (encode_alg != ORINOCO_ALG_WEP) {\r\nsetindex = index;\r\nencode_alg = ORINOCO_ALG_WEP;\r\n}\r\n} else {\r\nif ((index < 0) || (index >= ORINOCO_MAX_KEYS)) {\r\nif ((index != -1) || (erq->flags == 0)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\nif (priv->keys[index].key_len == 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nsetindex = index;\r\n}\r\n}\r\nif (erq->flags & IW_ENCODE_DISABLED)\r\nencode_alg = ORINOCO_ALG_NONE;\r\nif (erq->flags & IW_ENCODE_OPEN)\r\nrestricted = 0;\r\nif (erq->flags & IW_ENCODE_RESTRICTED)\r\nrestricted = 1;\r\nif (erq->pointer && erq->length > 0) {\r\nerr = orinoco_set_key(priv, index, ORINOCO_ALG_WEP, keybuf,\r\nerq->length, NULL, 0);\r\n}\r\npriv->tx_key = setindex;\r\nif ((priv->encode_alg == encode_alg) &&\r\n(priv->wep_restrict == restricted) &&\r\nnetif_carrier_ok(dev)) {\r\nerr = __orinoco_hw_setup_wepkeys(priv);\r\ngoto out;\r\n}\r\npriv->encode_alg = encode_alg;\r\npriv->wep_restrict = restricted;\r\nout:\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_getiwencode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq,\r\nchar *keybuf)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint index = (erq->flags & IW_ENCODE_INDEX) - 1;\r\nunsigned long flags;\r\nif (!priv->has_wep)\r\nreturn -EOPNOTSUPP;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nif ((index < 0) || (index >= ORINOCO_MAX_KEYS))\r\nindex = priv->tx_key;\r\nerq->flags = 0;\r\nif (!priv->encode_alg)\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nerq->flags |= index + 1;\r\nif (priv->wep_restrict)\r\nerq->flags |= IW_ENCODE_RESTRICTED;\r\nelse\r\nerq->flags |= IW_ENCODE_OPEN;\r\nerq->length = priv->keys[index].key_len;\r\nmemcpy(keybuf, priv->keys[index].key, erq->length);\r\norinoco_unlock(priv, &flags);\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_setessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq,\r\nchar *essidbuf)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nunsigned long flags;\r\nif (erq->length > IW_ESSID_MAX_SIZE)\r\nreturn -E2BIG;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nmemset(priv->desired_essid, 0, sizeof(priv->desired_essid));\r\nif (erq->flags)\r\nmemcpy(priv->desired_essid, essidbuf, erq->length);\r\norinoco_unlock(priv, &flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int orinoco_ioctl_getessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *erq,\r\nchar *essidbuf)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint active;\r\nint err = 0;\r\nunsigned long flags;\r\nif (netif_running(dev)) {\r\nerr = orinoco_hw_get_essid(priv, &active, essidbuf);\r\nif (err < 0)\r\nreturn err;\r\nerq->length = err;\r\n} else {\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\r\nerq->length = strlen(priv->desired_essid);\r\norinoco_unlock(priv, &flags);\r\n}\r\nerq->flags = 1;\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_setfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *frq,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint chan = -1;\r\nunsigned long flags;\r\nint err = -EINPROGRESS;\r\nif (priv->iw_mode == NL80211_IFTYPE_STATION)\r\nreturn -EBUSY;\r\nif ((frq->e == 0) && (frq->m <= 1000)) {\r\nchan = frq->m;\r\n} else {\r\nint denom = 1;\r\nint i;\r\nfor (i = 0; i < (6 - frq->e); i++)\r\ndenom *= 10;\r\nchan = ieee80211_freq_to_dsss_chan(frq->m / denom);\r\n}\r\nif ((chan < 1) || (chan > NUM_CHANNELS) ||\r\n!(priv->channel_mask & (1 << (chan - 1))))\r\nreturn -EINVAL;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\npriv->channel = chan;\r\nif (priv->iw_mode == NL80211_IFTYPE_MONITOR) {\r\nstruct hermes *hw = &priv->hw;\r\nerr = hw->ops->cmd_wait(hw, HERMES_CMD_TEST |\r\nHERMES_TEST_SET_CHANNEL,\r\nchan, NULL);\r\n}\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_getfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *frq,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint tmp;\r\ntmp = orinoco_hw_get_freq(priv);\r\nif (tmp < 0)\r\nreturn tmp;\r\nfrq->m = tmp * 100000;\r\nfrq->e = 1;\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_getsens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *srq,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct hermes *hw = &priv->hw;\r\nu16 val;\r\nint err;\r\nunsigned long flags;\r\nif (!priv->has_sensitivity)\r\nreturn -EOPNOTSUPP;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nerr = hermes_read_wordrec(hw, USER_BAP,\r\nHERMES_RID_CNFSYSTEMSCALE, &val);\r\norinoco_unlock(priv, &flags);\r\nif (err)\r\nreturn err;\r\nsrq->value = val;\r\nsrq->fixed = 0;\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_setsens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *srq,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint val = srq->value;\r\nunsigned long flags;\r\nif (!priv->has_sensitivity)\r\nreturn -EOPNOTSUPP;\r\nif ((val < 1) || (val > 3))\r\nreturn -EINVAL;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\npriv->ap_density = val;\r\norinoco_unlock(priv, &flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int orinoco_ioctl_setrate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint ratemode;\r\nint bitrate;\r\nunsigned long flags;\r\nif (rrq->value == -1)\r\nbitrate = 110;\r\nelse {\r\nif (rrq->value % 100000)\r\nreturn -EINVAL;\r\nbitrate = rrq->value / 100000;\r\n}\r\nratemode = orinoco_get_bitratemode(bitrate, !rrq->fixed);\r\nif (ratemode == -1)\r\nreturn -EINVAL;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\npriv->bitratemode = ratemode;\r\norinoco_unlock(priv, &flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int orinoco_ioctl_getrate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *rrq,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint err = 0;\r\nint bitrate, automatic;\r\nunsigned long flags;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\norinoco_get_ratemode_cfg(priv->bitratemode, &bitrate, &automatic);\r\nif (netif_running(dev)) {\r\nint act_bitrate;\r\nint lerr;\r\nlerr = orinoco_hw_get_act_bitrate(priv, &act_bitrate);\r\nif (!lerr)\r\nbitrate = act_bitrate;\r\n}\r\norinoco_unlock(priv, &flags);\r\nrrq->value = bitrate;\r\nrrq->fixed = !automatic;\r\nrrq->disabled = 0;\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_setpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *prq,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint err = -EINPROGRESS;\r\nunsigned long flags;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nif (prq->disabled) {\r\npriv->pm_on = 0;\r\n} else {\r\nswitch (prq->flags & IW_POWER_MODE) {\r\ncase IW_POWER_UNICAST_R:\r\npriv->pm_mcast = 0;\r\npriv->pm_on = 1;\r\nbreak;\r\ncase IW_POWER_ALL_R:\r\npriv->pm_mcast = 1;\r\npriv->pm_on = 1;\r\nbreak;\r\ncase IW_POWER_ON:\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (prq->flags & IW_POWER_TIMEOUT) {\r\npriv->pm_on = 1;\r\npriv->pm_timeout = prq->value / 1000;\r\n}\r\nif (prq->flags & IW_POWER_PERIOD) {\r\npriv->pm_on = 1;\r\npriv->pm_period = prq->value / 1000;\r\n}\r\nif (!priv->pm_on) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nout:\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_getpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *prq,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct hermes *hw = &priv->hw;\r\nint err = 0;\r\nu16 enable, period, timeout, mcast;\r\nunsigned long flags;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nerr = hermes_read_wordrec(hw, USER_BAP,\r\nHERMES_RID_CNFPMENABLED, &enable);\r\nif (err)\r\ngoto out;\r\nerr = hermes_read_wordrec(hw, USER_BAP,\r\nHERMES_RID_CNFMAXSLEEPDURATION, &period);\r\nif (err)\r\ngoto out;\r\nerr = hermes_read_wordrec(hw, USER_BAP,\r\nHERMES_RID_CNFPMHOLDOVERDURATION, &timeout);\r\nif (err)\r\ngoto out;\r\nerr = hermes_read_wordrec(hw, USER_BAP,\r\nHERMES_RID_CNFMULTICASTRECEIVE, &mcast);\r\nif (err)\r\ngoto out;\r\nprq->disabled = !enable;\r\nif ((prq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\r\nprq->flags = IW_POWER_TIMEOUT;\r\nprq->value = timeout * 1000;\r\n} else {\r\nprq->flags = IW_POWER_PERIOD;\r\nprq->value = period * 1000;\r\n}\r\nif (mcast)\r\nprq->flags |= IW_POWER_ALL_R;\r\nelse\r\nprq->flags |= IW_POWER_UNICAST_R;\r\nout:\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_set_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint idx, alg = ext->alg, set_key = 1;\r\nunsigned long flags;\r\nint err = -EINVAL;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif ((idx < 1) || (idx > 4))\r\ngoto out;\r\nidx--;\r\n} else\r\nidx = priv->tx_key;\r\nif (encoding->flags & IW_ENCODE_DISABLED)\r\nalg = IW_ENCODE_ALG_NONE;\r\nif (priv->has_wpa && (alg != IW_ENCODE_ALG_TKIP)) {\r\n(void) orinoco_clear_tkip_key(priv, priv->tx_key);\r\n}\r\nif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\r\npriv->tx_key = idx;\r\nset_key = ((alg == IW_ENCODE_ALG_TKIP) ||\r\n(ext->key_len > 0)) ? 1 : 0;\r\n}\r\nif (set_key) {\r\nswitch (alg) {\r\ncase IW_ENCODE_ALG_NONE:\r\npriv->encode_alg = ORINOCO_ALG_NONE;\r\nerr = orinoco_set_key(priv, idx, ORINOCO_ALG_NONE,\r\nNULL, 0, NULL, 0);\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nif (ext->key_len <= 0)\r\ngoto out;\r\npriv->encode_alg = ORINOCO_ALG_WEP;\r\nerr = orinoco_set_key(priv, idx, ORINOCO_ALG_WEP,\r\next->key, ext->key_len, NULL, 0);\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\n{\r\nu8 *tkip_iv = NULL;\r\nif (!priv->has_wpa ||\r\n(ext->key_len > sizeof(struct orinoco_tkip_key)))\r\ngoto out;\r\npriv->encode_alg = ORINOCO_ALG_TKIP;\r\nif (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)\r\ntkip_iv = &ext->rx_seq[0];\r\nerr = orinoco_set_key(priv, idx, ORINOCO_ALG_TKIP,\r\next->key, ext->key_len, tkip_iv,\r\nORINOCO_SEQ_LEN);\r\nerr = __orinoco_hw_set_tkip_key(priv, idx,\r\next->ext_flags & IW_ENCODE_EXT_SET_TX_KEY,\r\npriv->keys[idx].key,\r\ntkip_iv, ORINOCO_SEQ_LEN, NULL, 0);\r\nif (err)\r\nprintk(KERN_ERR "%s: Error %d setting TKIP key"\r\n"\n", dev->name, err);\r\ngoto out;\r\n}\r\ndefault:\r\ngoto out;\r\n}\r\n}\r\nerr = -EINPROGRESS;\r\nout:\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_get_encodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint idx, max_key_len;\r\nunsigned long flags;\r\nint err;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nerr = -EINVAL;\r\nmax_key_len = encoding->length - sizeof(*ext);\r\nif (max_key_len < 0)\r\ngoto out;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif ((idx < 1) || (idx > 4))\r\ngoto out;\r\nidx--;\r\n} else\r\nidx = priv->tx_key;\r\nencoding->flags = idx + 1;\r\nmemset(ext, 0, sizeof(*ext));\r\nswitch (priv->encode_alg) {\r\ncase ORINOCO_ALG_NONE:\r\next->alg = IW_ENCODE_ALG_NONE;\r\next->key_len = 0;\r\nencoding->flags |= IW_ENCODE_DISABLED;\r\nbreak;\r\ncase ORINOCO_ALG_WEP:\r\next->alg = IW_ENCODE_ALG_WEP;\r\next->key_len = min(priv->keys[idx].key_len, max_key_len);\r\nmemcpy(ext->key, priv->keys[idx].key, ext->key_len);\r\nencoding->flags |= IW_ENCODE_ENABLED;\r\nbreak;\r\ncase ORINOCO_ALG_TKIP:\r\next->alg = IW_ENCODE_ALG_TKIP;\r\next->key_len = min(priv->keys[idx].key_len, max_key_len);\r\nmemcpy(ext->key, priv->keys[idx].key, ext->key_len);\r\nencoding->flags |= IW_ENCODE_ENABLED;\r\nbreak;\r\n}\r\nerr = 0;\r\nout:\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct hermes *hw = &priv->hw;\r\nstruct iw_param *param = &wrqu->param;\r\nunsigned long flags;\r\nint ret = -EINPROGRESS;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nbreak;\r\ncase IW_AUTH_MFP:\r\nif (param->value == IW_AUTH_MFP_REQUIRED)\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_KEY_MGMT:\r\npriv->key_mgmt = param->value;\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nif (param->value) {\r\npriv->tkip_cm_active = 1;\r\nret = hermes_disable_port(hw, 0);\r\n} else {\r\npriv->tkip_cm_active = 0;\r\nret = hermes_enable_port(hw, 0);\r\n}\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif (param->value & IW_AUTH_ALG_SHARED_KEY)\r\npriv->wep_restrict = 1;\r\nelse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\r\npriv->wep_restrict = 0;\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nif (priv->has_wpa) {\r\npriv->wpa_enabled = param->value ? 1 : 0;\r\n} else {\r\nif (param->value)\r\nret = -EOPNOTSUPP;\r\npriv->wpa_enabled = 0;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\norinoco_unlock(priv, &flags);\r\nreturn ret;\r\n}\r\nstatic int orinoco_ioctl_get_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct iw_param *param = &wrqu->param;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_KEY_MGMT:\r\nparam->value = priv->key_mgmt;\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nparam->value = priv->tkip_cm_active;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif (priv->wep_restrict)\r\nparam->value = IW_AUTH_ALG_SHARED_KEY;\r\nelse\r\nparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nparam->value = priv->wpa_enabled;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\norinoco_unlock(priv, &flags);\r\nreturn ret;\r\n}\r\nstatic int orinoco_ioctl_set_genie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nu8 *buf;\r\nunsigned long flags;\r\nif ((wrqu->data.length > IEEE80211_MAX_DATA_LEN) ||\r\n(wrqu->data.length && (extra == NULL)))\r\nreturn -EINVAL;\r\nif (wrqu->data.length) {\r\nbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\n} else\r\nbuf = NULL;\r\nif (orinoco_lock(priv, &flags) != 0) {\r\nkfree(buf);\r\nreturn -EBUSY;\r\n}\r\nkfree(priv->wpa_ie);\r\npriv->wpa_ie = buf;\r\npriv->wpa_ie_len = wrqu->data.length;\r\nif (priv->wpa_ie) {\r\n}\r\norinoco_unlock(priv, &flags);\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_get_genie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nunsigned long flags;\r\nint err = 0;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nif ((priv->wpa_ie_len == 0) || (priv->wpa_ie == NULL)) {\r\nwrqu->data.length = 0;\r\ngoto out;\r\n}\r\nif (wrqu->data.length < priv->wpa_ie_len) {\r\nerr = -E2BIG;\r\ngoto out;\r\n}\r\nwrqu->data.length = priv->wpa_ie_len;\r\nmemcpy(extra, priv->wpa_ie, priv->wpa_ie_len);\r\nout:\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_set_mlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct iw_mlme *mlme = (struct iw_mlme *)extra;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\nbreak;\r\ncase IW_MLME_DISASSOC:\r\nret = orinoco_hw_disassociate(priv, mlme->addr.sa_data,\r\nmlme->reason_code);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\norinoco_unlock(priv, &flags);\r\nreturn ret;\r\n}\r\nstatic int orinoco_ioctl_reset(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (info->cmd == (SIOCIWFIRSTPRIV + 0x1)) {\r\nprintk(KERN_DEBUG "%s: Forcing reset!\n", dev->name);\r\norinoco_reset(&priv->reset_work);\r\n} else {\r\nprintk(KERN_DEBUG "%s: Force scheduling reset!\n", dev->name);\r\nschedule_work(&priv->reset_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_setibssport(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint val = *((int *) extra);\r\nunsigned long flags;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\npriv->ibss_port = val;\r\nset_port_type(priv);\r\norinoco_unlock(priv, &flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int orinoco_ioctl_getibssport(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint *val = (int *) extra;\r\n*val = priv->ibss_port;\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_setport3(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint val = *((int *) extra);\r\nint err = 0;\r\nunsigned long flags;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nswitch (val) {\r\ncase 0:\r\nif (!priv->has_ibss) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\npriv->prefer_port3 = 0;\r\nbreak;\r\ncase 1:\r\nif (!priv->has_port3) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\npriv->prefer_port3 = 1;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (!err) {\r\nset_port_type(priv);\r\nerr = -EINPROGRESS;\r\n}\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_getport3(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint *val = (int *) extra;\r\n*val = priv->prefer_port3;\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_setpreamble(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nunsigned long flags;\r\nint val;\r\nif (!priv->has_preamble)\r\nreturn -EOPNOTSUPP;\r\nval = *((int *) extra);\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nif (val)\r\npriv->preamble = 1;\r\nelse\r\npriv->preamble = 0;\r\norinoco_unlock(priv, &flags);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int orinoco_ioctl_getpreamble(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nint *val = (int *) extra;\r\nif (!priv->has_preamble)\r\nreturn -EOPNOTSUPP;\r\n*val = priv->preamble;\r\nreturn 0;\r\n}\r\nstatic int orinoco_ioctl_getrid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *data,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nstruct hermes *hw = &priv->hw;\r\nint rid = data->flags;\r\nu16 length;\r\nint err;\r\nunsigned long flags;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (rid < 0xfc00 || rid > 0xffff)\r\nreturn -EINVAL;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn -EBUSY;\r\nerr = hw->ops->read_ltv(hw, USER_BAP, rid, MAX_RID_LEN, &length,\r\nextra);\r\nif (err)\r\ngoto out;\r\ndata->length = min_t(u16, HERMES_RECLEN_TO_BYTES(length),\r\nMAX_RID_LEN);\r\nout:\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}\r\nstatic int orinoco_ioctl_commit(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrqu,\r\nchar *extra)\r\n{\r\nstruct orinoco_private *priv = ndev_priv(dev);\r\nunsigned long flags;\r\nint err = 0;\r\nif (!priv->open)\r\nreturn 0;\r\nif (orinoco_lock(priv, &flags) != 0)\r\nreturn err;\r\nerr = orinoco_commit(priv);\r\norinoco_unlock(priv, &flags);\r\nreturn err;\r\n}
