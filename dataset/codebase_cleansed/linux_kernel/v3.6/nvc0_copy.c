static int\r\nnvc0_copy_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nvc0_copy_engine *pcopy = nv_engine(chan->dev, engine);\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *ramin = chan->ramin;\r\nstruct nouveau_gpuobj *ctx = NULL;\r\nint ret;\r\nret = nouveau_gpuobj_new(dev, chan, 256, 256,\r\nNVOBJ_FLAG_VM | NVOBJ_FLAG_VM_USER |\r\nNVOBJ_FLAG_ZERO_ALLOC, &ctx);\r\nif (ret)\r\nreturn ret;\r\nnv_wo32(ramin, pcopy->ctx + 0, lower_32_bits(ctx->linst));\r\nnv_wo32(ramin, pcopy->ctx + 4, upper_32_bits(ctx->linst));\r\ndev_priv->engine.instmem.flush(dev);\r\nchan->engctx[engine] = ctx;\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_copy_object_new(struct nouveau_channel *chan, int engine,\r\nu32 handle, u16 class)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nnvc0_copy_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nvc0_copy_engine *pcopy = nv_engine(chan->dev, engine);\r\nstruct nouveau_gpuobj *ctx = chan->engctx[engine];\r\nstruct drm_device *dev = chan->dev;\r\nu32 inst;\r\ninst = (chan->ramin->vinst >> 12);\r\ninst |= 0x40000000;\r\nnv_wr32(dev, pcopy->fuc + 0x048, 0x00000000);\r\nif (nv_rd32(dev, pcopy->fuc + 0x050) == inst)\r\nnv_mask(dev, pcopy->fuc + 0x050, 0x40000000, 0x00000000);\r\nif (nv_rd32(dev, pcopy->fuc + 0x054) == inst)\r\nnv_mask(dev, pcopy->fuc + 0x054, 0x40000000, 0x00000000);\r\nnv_wr32(dev, pcopy->fuc + 0x048, 0x00000003);\r\nnv_wo32(chan->ramin, pcopy->ctx + 0, 0x00000000);\r\nnv_wo32(chan->ramin, pcopy->ctx + 4, 0x00000000);\r\nnouveau_gpuobj_ref(NULL, &ctx);\r\nchan->engctx[engine] = ctx;\r\n}\r\nstatic int\r\nnvc0_copy_init(struct drm_device *dev, int engine)\r\n{\r\nstruct nvc0_copy_engine *pcopy = nv_engine(dev, engine);\r\nint i;\r\nnv_mask(dev, 0x000200, pcopy->pmc, 0x00000000);\r\nnv_mask(dev, 0x000200, pcopy->pmc, pcopy->pmc);\r\nnv_wr32(dev, pcopy->fuc + 0x014, 0xffffffff);\r\nnv_wr32(dev, pcopy->fuc + 0x1c0, 0x01000000);\r\nfor (i = 0; i < sizeof(nvc0_pcopy_data) / 4; i++)\r\nnv_wr32(dev, pcopy->fuc + 0x1c4, nvc0_pcopy_data[i]);\r\nnv_wr32(dev, pcopy->fuc + 0x180, 0x01000000);\r\nfor (i = 0; i < sizeof(nvc0_pcopy_code) / 4; i++) {\r\nif ((i & 0x3f) == 0)\r\nnv_wr32(dev, pcopy->fuc + 0x188, i >> 6);\r\nnv_wr32(dev, pcopy->fuc + 0x184, nvc0_pcopy_code[i]);\r\n}\r\nnv_wr32(dev, pcopy->fuc + 0x084, engine - NVOBJ_ENGINE_COPY0);\r\nnv_wr32(dev, pcopy->fuc + 0x10c, 0x00000000);\r\nnv_wr32(dev, pcopy->fuc + 0x104, 0x00000000);\r\nnv_wr32(dev, pcopy->fuc + 0x100, 0x00000002);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_copy_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nstruct nvc0_copy_engine *pcopy = nv_engine(dev, engine);\r\nnv_mask(dev, pcopy->fuc + 0x048, 0x00000003, 0x00000000);\r\nnv_wait(dev, pcopy->fuc + 0x008, 0x0000000c, 0x00000000);\r\nnv_mask(dev, pcopy->fuc + 0x054, 0x40000000, 0x00000000);\r\nnv_wr32(dev, pcopy->fuc + 0x000, 0x00000008);\r\nnv_wait(dev, pcopy->fuc + 0x008, 0x00000008, 0x00000000);\r\nnv_wr32(dev, pcopy->fuc + 0x014, 0xffffffff);\r\nreturn 0;\r\n}\r\nstatic void\r\nnvc0_copy_isr(struct drm_device *dev, int engine)\r\n{\r\nstruct nvc0_copy_engine *pcopy = nv_engine(dev, engine);\r\nu32 disp = nv_rd32(dev, pcopy->fuc + 0x01c);\r\nu32 stat = nv_rd32(dev, pcopy->fuc + 0x008) & disp & ~(disp >> 16);\r\nu64 inst = (u64)(nv_rd32(dev, pcopy->fuc + 0x050) & 0x0fffffff) << 12;\r\nu32 chid = nvc0_graph_isr_chid(dev, inst);\r\nu32 ssta = nv_rd32(dev, pcopy->fuc + 0x040) & 0x0000ffff;\r\nu32 addr = nv_rd32(dev, pcopy->fuc + 0x040) >> 16;\r\nu32 mthd = (addr & 0x07ff) << 2;\r\nu32 subc = (addr & 0x3800) >> 11;\r\nu32 data = nv_rd32(dev, pcopy->fuc + 0x044);\r\nif (stat & 0x00000040) {\r\nNV_INFO(dev, "PCOPY: DISPATCH_ERROR [");\r\nnouveau_enum_print(nvc0_copy_isr_error_name, ssta);\r\nprintk("] ch %d [0x%010llx] subc %d mthd 0x%04x data 0x%08x\n",\r\nchid, inst, subc, mthd, data);\r\nnv_wr32(dev, pcopy->fuc + 0x004, 0x00000040);\r\nstat &= ~0x00000040;\r\n}\r\nif (stat) {\r\nNV_INFO(dev, "PCOPY: unhandled intr 0x%08x\n", stat);\r\nnv_wr32(dev, pcopy->fuc + 0x004, stat);\r\n}\r\n}\r\nstatic void\r\nnvc0_copy_isr_0(struct drm_device *dev)\r\n{\r\nnvc0_copy_isr(dev, NVOBJ_ENGINE_COPY0);\r\n}\r\nstatic void\r\nnvc0_copy_isr_1(struct drm_device *dev)\r\n{\r\nnvc0_copy_isr(dev, NVOBJ_ENGINE_COPY1);\r\n}\r\nstatic void\r\nnvc0_copy_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nvc0_copy_engine *pcopy = nv_engine(dev, engine);\r\nnouveau_irq_unregister(dev, pcopy->irq);\r\nif (engine == NVOBJ_ENGINE_COPY0)\r\nNVOBJ_ENGINE_DEL(dev, COPY0);\r\nelse\r\nNVOBJ_ENGINE_DEL(dev, COPY1);\r\nkfree(pcopy);\r\n}\r\nint\r\nnvc0_copy_create(struct drm_device *dev, int engine)\r\n{\r\nstruct nvc0_copy_engine *pcopy;\r\npcopy = kzalloc(sizeof(*pcopy), GFP_KERNEL);\r\nif (!pcopy)\r\nreturn -ENOMEM;\r\npcopy->base.destroy = nvc0_copy_destroy;\r\npcopy->base.init = nvc0_copy_init;\r\npcopy->base.fini = nvc0_copy_fini;\r\npcopy->base.context_new = nvc0_copy_context_new;\r\npcopy->base.context_del = nvc0_copy_context_del;\r\npcopy->base.object_new = nvc0_copy_object_new;\r\nif (engine == 0) {\r\npcopy->irq = 5;\r\npcopy->pmc = 0x00000040;\r\npcopy->fuc = 0x104000;\r\npcopy->ctx = 0x0230;\r\nnouveau_irq_register(dev, pcopy->irq, nvc0_copy_isr_0);\r\nNVOBJ_ENGINE_ADD(dev, COPY0, &pcopy->base);\r\nNVOBJ_CLASS(dev, 0x90b5, COPY0);\r\n} else {\r\npcopy->irq = 6;\r\npcopy->pmc = 0x00000080;\r\npcopy->fuc = 0x105000;\r\npcopy->ctx = 0x0240;\r\nnouveau_irq_register(dev, pcopy->irq, nvc0_copy_isr_1);\r\nNVOBJ_ENGINE_ADD(dev, COPY1, &pcopy->base);\r\nNVOBJ_CLASS(dev, 0x90b8, COPY1);\r\n}\r\nreturn 0;\r\n}
