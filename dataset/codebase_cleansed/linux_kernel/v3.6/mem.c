static void __init find_tempdir(void)\r\n{\r\nconst char *dirs[] = { "TMP", "TEMP", "TMPDIR", NULL };\r\nint i;\r\nchar *dir = NULL;\r\nif (tempdir != NULL)\r\nreturn;\r\nfor (i = 0; dirs[i]; i++) {\r\ndir = getenv(dirs[i]);\r\nif ((dir != NULL) && (*dir != '\0'))\r\nbreak;\r\n}\r\nif ((dir == NULL) || (*dir == '\0'))\r\ndir = default_tmpdir;\r\ntempdir = malloc(strlen(dir) + 2);\r\nif (tempdir == NULL) {\r\nfprintf(stderr, "Failed to malloc tempdir, "\r\n"errno = %d\n", errno);\r\nreturn;\r\n}\r\nstrcpy(tempdir, dir);\r\nstrcat(tempdir, "/");\r\n}\r\nstatic int next(int fd, char *buf, size_t size, char c)\r\n{\r\nssize_t n;\r\nsize_t len;\r\nchar *ptr;\r\nwhile ((ptr = strchr(buf, c)) == NULL) {\r\nn = read(fd, buf, size - 1);\r\nif (n == 0)\r\nreturn 0;\r\nelse if (n < 0)\r\nreturn -errno;\r\nbuf[n] = '\0';\r\n}\r\nptr++;\r\nlen = strlen(ptr);\r\nmemmove(buf, ptr, len + 1);\r\nn = read(fd, &buf[len], size - len - 1);\r\nif (n < 0)\r\nreturn -errno;\r\nbuf[len + n] = '\0';\r\nreturn 1;\r\n}\r\nstatic void which_tmpdir(void)\r\n{\r\nint fd, found;\r\nchar buf[128] = { '\0' };\r\nif (checked_tmpdir)\r\nreturn;\r\nchecked_tmpdir = 1;\r\nprintf("Checking for tmpfs mount on /dev/shm...");\r\nfd = open("/proc/mounts", O_RDONLY);\r\nif (fd < 0) {\r\nprintf("failed to open /proc/mounts, errno = %d\n", errno);\r\nreturn;\r\n}\r\nwhile (1) {\r\nfound = next(fd, buf, ARRAY_SIZE(buf), ' ');\r\nif (found != 1)\r\nbreak;\r\nif (!strncmp(buf, "/dev/shm", strlen("/dev/shm")))\r\ngoto found;\r\nfound = next(fd, buf, ARRAY_SIZE(buf), '\n');\r\nif (found != 1)\r\nbreak;\r\n}\r\nerr:\r\nif (found == 0)\r\nprintf("nothing mounted on /dev/shm\n");\r\nelse if (found < 0)\r\nprintf("read returned errno %d\n", -found);\r\nout:\r\nclose(fd);\r\nreturn;\r\nfound:\r\nfound = next(fd, buf, ARRAY_SIZE(buf), ' ');\r\nif (found != 1)\r\ngoto err;\r\nif (strncmp(buf, "tmpfs", strlen("tmpfs"))) {\r\nprintf("not tmpfs\n");\r\ngoto out;\r\n}\r\nprintf("OK\n");\r\ndefault_tmpdir = "/dev/shm";\r\ngoto out;\r\n}\r\nstatic int __init make_tempfile(const char *template, char **out_tempname,\r\nint do_unlink)\r\n{\r\nchar *tempname;\r\nint fd;\r\nwhich_tmpdir();\r\ntempname = malloc(MAXPATHLEN);\r\nif (tempname == NULL)\r\nreturn -1;\r\nfind_tempdir();\r\nif ((tempdir == NULL) || (strlen(tempdir) >= MAXPATHLEN))\r\ngoto out;\r\nif (template[0] != '/')\r\nstrcpy(tempname, tempdir);\r\nelse\r\ntempname[0] = '\0';\r\nstrncat(tempname, template, MAXPATHLEN-1-strlen(tempname));\r\nfd = mkstemp(tempname);\r\nif (fd < 0) {\r\nfprintf(stderr, "open - cannot create %s: %s\n", tempname,\r\nstrerror(errno));\r\ngoto out;\r\n}\r\nif (do_unlink && (unlink(tempname) < 0)) {\r\nperror("unlink");\r\ngoto close;\r\n}\r\nif (out_tempname) {\r\n*out_tempname = tempname;\r\n} else\r\nfree(tempname);\r\nreturn fd;\r\nclose:\r\nclose(fd);\r\nout:\r\nfree(tempname);\r\nreturn -1;\r\n}\r\nstatic int __init create_tmp_file(unsigned long long len)\r\n{\r\nint fd, err;\r\nchar zero;\r\nfd = make_tempfile(TEMPNAME_TEMPLATE, NULL, 1);\r\nif (fd < 0)\r\nexit(1);\r\nerr = fchmod(fd, 0777);\r\nif (err < 0) {\r\nperror("fchmod");\r\nexit(1);\r\n}\r\nif (lseek64(fd, len - 1, SEEK_SET) < 0) {\r\nperror("lseek64");\r\nexit(1);\r\n}\r\nzero = 0;\r\nerr = write(fd, &zero, 1);\r\nif (err != 1) {\r\nperror("write");\r\nexit(1);\r\n}\r\nreturn fd;\r\n}\r\nint __init create_mem_file(unsigned long long len)\r\n{\r\nint err, fd;\r\nfd = create_tmp_file(len);\r\nerr = os_set_exec_close(fd);\r\nif (err < 0) {\r\nerrno = -err;\r\nperror("exec_close");\r\n}\r\nreturn fd;\r\n}\r\nvoid __init check_tmpexec(void)\r\n{\r\nvoid *addr;\r\nint err, fd = create_tmp_file(UM_KERN_PAGE_SIZE);\r\naddr = mmap(NULL, UM_KERN_PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, 0);\r\nprintf("Checking PROT_EXEC mmap in %s...",tempdir);\r\nfflush(stdout);\r\nif (addr == MAP_FAILED) {\r\nerr = errno;\r\nperror("failed");\r\nclose(fd);\r\nif (err == EPERM)\r\nprintf("%s must be not mounted noexec\n",tempdir);\r\nexit(1);\r\n}\r\nprintf("OK\n");\r\nmunmap(addr, UM_KERN_PAGE_SIZE);\r\nclose(fd);\r\n}
