static void __rtl8139_cleanup_dev (struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nstruct pci_dev *pdev;\r\nassert (dev != NULL);\r\nassert (tp->pci_dev != NULL);\r\npdev = tp->pci_dev;\r\nif (tp->mmio_addr)\r\npci_iounmap (pdev, tp->mmio_addr);\r\npci_release_regions (pdev);\r\nfree_netdev(dev);\r\npci_set_drvdata (pdev, NULL);\r\n}\r\nstatic void rtl8139_chip_reset (void __iomem *ioaddr)\r\n{\r\nint i;\r\nRTL_W8 (ChipCmd, CmdReset);\r\nfor (i = 1000; i > 0; i--) {\r\nbarrier();\r\nif ((RTL_R8 (ChipCmd) & CmdReset) == 0)\r\nbreak;\r\nudelay (10);\r\n}\r\n}\r\nint rtl8139_set_features(struct net_device *dev, netdev_features_t features)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nunsigned long flags;\r\nnetdev_features_t changed = features ^ dev->features;\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nif (!(changed & (NETIF_F_RXALL)))\r\nreturn 0;\r\nspin_lock_irqsave(&tp->lock, flags);\r\nif (changed & NETIF_F_RXALL) {\r\nint rx_mode = tp->rx_config;\r\nif (features & NETIF_F_RXALL)\r\nrx_mode |= (AcceptErr | AcceptRunt);\r\nelse\r\nrx_mode &= ~(AcceptErr | AcceptRunt);\r\ntp->rx_config = rtl8139_rx_config | rx_mode;\r\nRTL_W32_F(RxConfig, tp->rx_config);\r\n}\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __devinit rtl8139_init_one (struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct rtl8139_private *tp;\r\nint i, addr_len, option;\r\nvoid __iomem *ioaddr;\r\nstatic int board_idx = -1;\r\nassert (pdev != NULL);\r\nassert (ent != NULL);\r\nboard_idx++;\r\n#ifndef MODULE\r\n{\r\nstatic int printed_version;\r\nif (!printed_version++)\r\npr_info(RTL8139_DRIVER_NAME "\n");\r\n}\r\n#endif\r\nif (pdev->vendor == PCI_VENDOR_ID_REALTEK &&\r\npdev->device == PCI_DEVICE_ID_REALTEK_8139 && pdev->revision >= 0x20) {\r\ndev_info(&pdev->dev,\r\n"This (id %04x:%04x rev %02x) is an enhanced 8139C+ chip, use 8139cp\n",\r\npdev->vendor, pdev->device, pdev->revision);\r\nreturn -ENODEV;\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_REALTEK &&\r\npdev->device == PCI_DEVICE_ID_REALTEK_8139 &&\r\npdev->subsystem_vendor == PCI_VENDOR_ID_ATHEROS &&\r\npdev->subsystem_device == PCI_DEVICE_ID_REALTEK_8139) {\r\npr_info("OQO Model 2 detected. Forcing PIO\n");\r\nuse_io = 1;\r\n}\r\ndev = rtl8139_init_board (pdev);\r\nif (IS_ERR(dev))\r\nreturn PTR_ERR(dev);\r\nassert (dev != NULL);\r\ntp = netdev_priv(dev);\r\ntp->dev = dev;\r\nioaddr = tp->mmio_addr;\r\nassert (ioaddr != NULL);\r\naddr_len = read_eeprom (ioaddr, 0, 8) == 0x8129 ? 8 : 6;\r\nfor (i = 0; i < 3; i++)\r\n((__le16 *) (dev->dev_addr))[i] =\r\ncpu_to_le16(read_eeprom (ioaddr, i + 7, addr_len));\r\nmemcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);\r\ndev->netdev_ops = &rtl8139_netdev_ops;\r\ndev->ethtool_ops = &rtl8139_ethtool_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nnetif_napi_add(dev, &tp->napi, rtl8139_poll, 64);\r\ndev->features |= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_HIGHDMA;\r\ndev->vlan_features = dev->features;\r\ndev->hw_features |= NETIF_F_RXALL;\r\ndev->hw_features |= NETIF_F_RXFCS;\r\ntp = netdev_priv(dev);\r\ntp->drv_flags = board_info[ent->driver_data].hw_flags;\r\ntp->mmio_addr = ioaddr;\r\ntp->msg_enable =\r\n(debug < 0 ? RTL8139_DEF_MSG_ENABLE : ((1 << debug) - 1));\r\nspin_lock_init (&tp->lock);\r\nspin_lock_init (&tp->rx_lock);\r\nINIT_DELAYED_WORK(&tp->thread, rtl8139_thread);\r\ntp->mii.dev = dev;\r\ntp->mii.mdio_read = mdio_read;\r\ntp->mii.mdio_write = mdio_write;\r\ntp->mii.phy_id_mask = 0x3f;\r\ntp->mii.reg_num_mask = 0x1f;\r\npr_debug("about to register device named %s (%p)...\n",\r\ndev->name, dev);\r\ni = register_netdev (dev);\r\nif (i) goto err_out;\r\npci_set_drvdata (pdev, dev);\r\nnetdev_info(dev, "%s at 0x%p, %pM, IRQ %d\n",\r\nboard_info[ent->driver_data].name,\r\nioaddr, dev->dev_addr, pdev->irq);\r\nnetdev_dbg(dev, "Identified 8139 chip type '%s'\n",\r\nrtl_chip_info[tp->chipset].name);\r\n#ifdef CONFIG_8139TOO_8129\r\nif (tp->drv_flags & HAS_MII_XCVR) {\r\nint phy, phy_idx = 0;\r\nfor (phy = 0; phy < 32 && phy_idx < sizeof(tp->phys); phy++) {\r\nint mii_status = mdio_read(dev, phy, 1);\r\nif (mii_status != 0xffff && mii_status != 0x0000) {\r\nu16 advertising = mdio_read(dev, phy, 4);\r\ntp->phys[phy_idx++] = phy;\r\nnetdev_info(dev, "MII transceiver %d status 0x%04x advertising %04x\n",\r\nphy, mii_status, advertising);\r\n}\r\n}\r\nif (phy_idx == 0) {\r\nnetdev_info(dev, "No MII transceivers found! Assuming SYM transceiver\n");\r\ntp->phys[0] = 32;\r\n}\r\n} else\r\n#endif\r\ntp->phys[0] = 32;\r\ntp->mii.phy_id = tp->phys[0];\r\noption = (board_idx >= MAX_UNITS) ? 0 : media[board_idx];\r\nif (option > 0) {\r\ntp->mii.full_duplex = (option & 0x210) ? 1 : 0;\r\ntp->default_port = option & 0xFF;\r\nif (tp->default_port)\r\ntp->mii.force_media = 1;\r\n}\r\nif (board_idx < MAX_UNITS && full_duplex[board_idx] > 0)\r\ntp->mii.full_duplex = full_duplex[board_idx];\r\nif (tp->mii.full_duplex) {\r\nnetdev_info(dev, "Media type forced to Full Duplex\n");\r\ntp->mii.force_media = 1;\r\n}\r\nif (tp->default_port) {\r\nnetdev_info(dev, " Forcing %dMbps %s-duplex operation\n",\r\n(option & 0x20 ? 100 : 10),\r\n(option & 0x10 ? "full" : "half"));\r\nmdio_write(dev, tp->phys[0], 0,\r\n((option & 0x20) ? 0x2000 : 0) |\r\n((option & 0x10) ? 0x0100 : 0));\r\n}\r\nif (rtl_chip_info[tp->chipset].flags & HasHltClk)\r\nRTL_W8 (HltClk, 'H');\r\nreturn 0;\r\nerr_out:\r\n__rtl8139_cleanup_dev (dev);\r\npci_disable_device (pdev);\r\nreturn i;\r\n}\r\nstatic void __devexit rtl8139_remove_one (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nassert (dev != NULL);\r\ncancel_delayed_work_sync(&tp->thread);\r\nunregister_netdev (dev);\r\n__rtl8139_cleanup_dev (dev);\r\npci_disable_device (pdev);\r\n}\r\nstatic int __devinit read_eeprom (void __iomem *ioaddr, int location, int addr_len)\r\n{\r\nint i;\r\nunsigned retval = 0;\r\nint read_cmd = location | (EE_READ_CMD << addr_len);\r\nRTL_W8 (Cfg9346, EE_ENB & ~EE_CS);\r\nRTL_W8 (Cfg9346, EE_ENB);\r\neeprom_delay ();\r\nfor (i = 4 + addr_len; i >= 0; i--) {\r\nint dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;\r\nRTL_W8 (Cfg9346, EE_ENB | dataval);\r\neeprom_delay ();\r\nRTL_W8 (Cfg9346, EE_ENB | dataval | EE_SHIFT_CLK);\r\neeprom_delay ();\r\n}\r\nRTL_W8 (Cfg9346, EE_ENB);\r\neeprom_delay ();\r\nfor (i = 16; i > 0; i--) {\r\nRTL_W8 (Cfg9346, EE_ENB | EE_SHIFT_CLK);\r\neeprom_delay ();\r\nretval =\r\n(retval << 1) | ((RTL_R8 (Cfg9346) & EE_DATA_READ) ? 1 :\r\n0);\r\nRTL_W8 (Cfg9346, EE_ENB);\r\neeprom_delay ();\r\n}\r\nRTL_W8(Cfg9346, 0);\r\neeprom_delay ();\r\nreturn retval;\r\n}\r\nstatic void mdio_sync (void __iomem *ioaddr)\r\n{\r\nint i;\r\nfor (i = 32; i >= 0; i--) {\r\nRTL_W8 (Config4, MDIO_WRITE1);\r\nmdio_delay ();\r\nRTL_W8 (Config4, MDIO_WRITE1 | MDIO_CLK);\r\nmdio_delay ();\r\n}\r\n}\r\nstatic int mdio_read (struct net_device *dev, int phy_id, int location)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nint retval = 0;\r\n#ifdef CONFIG_8139TOO_8129\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint mii_cmd = (0xf6 << 10) | (phy_id << 5) | location;\r\nint i;\r\n#endif\r\nif (phy_id > 31) {\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nreturn location < 8 && mii_2_8139_map[location] ?\r\nRTL_R16 (mii_2_8139_map[location]) : 0;\r\n}\r\n#ifdef CONFIG_8139TOO_8129\r\nmdio_sync (ioaddr);\r\nfor (i = 15; i >= 0; i--) {\r\nint dataval = (mii_cmd & (1 << i)) ? MDIO_DATA_OUT : 0;\r\nRTL_W8 (Config4, MDIO_DIR | dataval);\r\nmdio_delay ();\r\nRTL_W8 (Config4, MDIO_DIR | dataval | MDIO_CLK);\r\nmdio_delay ();\r\n}\r\nfor (i = 19; i > 0; i--) {\r\nRTL_W8 (Config4, 0);\r\nmdio_delay ();\r\nretval = (retval << 1) | ((RTL_R8 (Config4) & MDIO_DATA_IN) ? 1 : 0);\r\nRTL_W8 (Config4, MDIO_CLK);\r\nmdio_delay ();\r\n}\r\n#endif\r\nreturn (retval >> 1) & 0xffff;\r\n}\r\nstatic void mdio_write (struct net_device *dev, int phy_id, int location,\r\nint value)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\n#ifdef CONFIG_8139TOO_8129\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint mii_cmd = (0x5002 << 16) | (phy_id << 23) | (location << 18) | value;\r\nint i;\r\n#endif\r\nif (phy_id > 31) {\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nif (location == 0) {\r\nRTL_W8 (Cfg9346, Cfg9346_Unlock);\r\nRTL_W16 (BasicModeCtrl, value);\r\nRTL_W8 (Cfg9346, Cfg9346_Lock);\r\n} else if (location < 8 && mii_2_8139_map[location])\r\nRTL_W16 (mii_2_8139_map[location], value);\r\nreturn;\r\n}\r\n#ifdef CONFIG_8139TOO_8129\r\nmdio_sync (ioaddr);\r\nfor (i = 31; i >= 0; i--) {\r\nint dataval =\r\n(mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;\r\nRTL_W8 (Config4, dataval);\r\nmdio_delay ();\r\nRTL_W8 (Config4, dataval | MDIO_CLK);\r\nmdio_delay ();\r\n}\r\nfor (i = 2; i > 0; i--) {\r\nRTL_W8 (Config4, 0);\r\nmdio_delay ();\r\nRTL_W8 (Config4, MDIO_CLK);\r\nmdio_delay ();\r\n}\r\n#endif\r\n}\r\nstatic int rtl8139_open (struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nconst int irq = tp->pci_dev->irq;\r\nint retval;\r\nretval = request_irq(irq, rtl8139_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (retval)\r\nreturn retval;\r\ntp->tx_bufs = dma_alloc_coherent(&tp->pci_dev->dev, TX_BUF_TOT_LEN,\r\n&tp->tx_bufs_dma, GFP_KERNEL);\r\ntp->rx_ring = dma_alloc_coherent(&tp->pci_dev->dev, RX_BUF_TOT_LEN,\r\n&tp->rx_ring_dma, GFP_KERNEL);\r\nif (tp->tx_bufs == NULL || tp->rx_ring == NULL) {\r\nfree_irq(irq, dev);\r\nif (tp->tx_bufs)\r\ndma_free_coherent(&tp->pci_dev->dev, TX_BUF_TOT_LEN,\r\ntp->tx_bufs, tp->tx_bufs_dma);\r\nif (tp->rx_ring)\r\ndma_free_coherent(&tp->pci_dev->dev, RX_BUF_TOT_LEN,\r\ntp->rx_ring, tp->rx_ring_dma);\r\nreturn -ENOMEM;\r\n}\r\nnapi_enable(&tp->napi);\r\ntp->mii.full_duplex = tp->mii.force_media;\r\ntp->tx_flag = (TX_FIFO_THRESH << 11) & 0x003f0000;\r\nrtl8139_init_ring (dev);\r\nrtl8139_hw_start (dev);\r\nnetif_start_queue (dev);\r\nnetif_dbg(tp, ifup, dev,\r\n"%s() ioaddr %#llx IRQ %d GP Pins %02x %s-duplex\n",\r\n__func__,\r\n(unsigned long long)pci_resource_start (tp->pci_dev, 1),\r\nirq, RTL_R8 (MediaStatus),\r\ntp->mii.full_duplex ? "full" : "half");\r\nrtl8139_start_thread(tp);\r\nreturn 0;\r\n}\r\nstatic void rtl_check_media (struct net_device *dev, unsigned int init_media)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nif (tp->phys[0] >= 0) {\r\nmii_check_media(&tp->mii, netif_msg_link(tp), init_media);\r\n}\r\n}\r\nstatic void rtl8139_hw_start (struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu32 i;\r\nu8 tmp;\r\nif (rtl_chip_info[tp->chipset].flags & HasHltClk)\r\nRTL_W8 (HltClk, 'R');\r\nrtl8139_chip_reset (ioaddr);\r\nRTL_W8_F (Cfg9346, Cfg9346_Unlock);\r\nRTL_W32_F (MAC0 + 0, le32_to_cpu (*(__le32 *) (dev->dev_addr + 0)));\r\nRTL_W32_F (MAC0 + 4, le16_to_cpu (*(__le16 *) (dev->dev_addr + 4)));\r\ntp->cur_rx = 0;\r\nRTL_W32_F (RxBuf, tp->rx_ring_dma);\r\nRTL_W8 (ChipCmd, CmdRxEnb | CmdTxEnb);\r\ntp->rx_config = rtl8139_rx_config | AcceptBroadcast | AcceptMyPhys;\r\nRTL_W32 (RxConfig, tp->rx_config);\r\nRTL_W32 (TxConfig, rtl8139_tx_config);\r\nrtl_check_media (dev, 1);\r\nif (tp->chipset >= CH_8139B) {\r\nRTL_W8 (Config3, RTL_R8 (Config3) & ~Cfg3_Magic);\r\n}\r\nnetdev_dbg(dev, "init buffer addresses\n");\r\nRTL_W8 (Cfg9346, Cfg9346_Lock);\r\nfor (i = 0; i < NUM_TX_DESC; i++)\r\nRTL_W32_F (TxAddr0 + (i * 4), tp->tx_bufs_dma + (tp->tx_buf[i] - tp->tx_bufs));\r\nRTL_W32 (RxMissed, 0);\r\nrtl8139_set_rx_mode (dev);\r\nRTL_W16 (MultiIntr, RTL_R16 (MultiIntr) & MultiIntrClear);\r\ntmp = RTL_R8 (ChipCmd);\r\nif ((!(tmp & CmdRxEnb)) || (!(tmp & CmdTxEnb)))\r\nRTL_W8 (ChipCmd, CmdRxEnb | CmdTxEnb);\r\nRTL_W16 (IntrMask, rtl8139_intr_mask);\r\n}\r\nstatic void rtl8139_init_ring (struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nint i;\r\ntp->cur_rx = 0;\r\ntp->cur_tx = 0;\r\ntp->dirty_tx = 0;\r\nfor (i = 0; i < NUM_TX_DESC; i++)\r\ntp->tx_buf[i] = &tp->tx_bufs[i * TX_BUF_SIZE];\r\n}\r\nstatic inline void rtl8139_tune_twister (struct net_device *dev,\r\nstruct rtl8139_private *tp) {}\r\nstatic void rtl8139_tune_twister (struct net_device *dev,\r\nstruct rtl8139_private *tp)\r\n{\r\nint linkcase;\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nswitch (tp->twistie) {\r\ncase 1:\r\nif (RTL_R16 (CSCR) & CSCR_LinkOKBit) {\r\nRTL_W16 (CSCR, CSCR_LinkDownOffCmd);\r\ntp->twistie = 2;\r\nnext_tick = HZ / 10;\r\n} else {\r\nRTL_W16 (CSCR, CSCR_LinkDownCmd);\r\nRTL_W32 (FIFOTMS, 0x20);\r\nRTL_W32 (PARA78, PARA78_default);\r\nRTL_W32 (PARA7c, PARA7c_default);\r\ntp->twistie = 0;\r\n}\r\nbreak;\r\ncase 2:\r\nlinkcase = RTL_R16 (CSCR) & CSCR_LinkStatusBits;\r\nif (linkcase == 0x7000)\r\ntp->twist_row = 3;\r\nelse if (linkcase == 0x3000)\r\ntp->twist_row = 2;\r\nelse if (linkcase == 0x1000)\r\ntp->twist_row = 1;\r\nelse\r\ntp->twist_row = 0;\r\ntp->twist_col = 0;\r\ntp->twistie = 3;\r\nnext_tick = HZ / 10;\r\nbreak;\r\ncase 3:\r\nif (tp->twist_col == 0)\r\nRTL_W16 (FIFOTMS, 0);\r\nRTL_W32 (PARA7c, param[(int) tp->twist_row]\r\n[(int) tp->twist_col]);\r\nnext_tick = HZ / 10;\r\nif (++tp->twist_col >= 4) {\r\ntp->twistie =\r\n(tp->twist_row == 3) ? 4 : 0;\r\n}\r\nbreak;\r\ncase 4:\r\nif ((RTL_R16 (CSCR) &\r\nCSCR_LinkStatusBits) == 0x7000) {\r\ntp->twistie = 0;\r\nbreak;\r\n} else {\r\nRTL_W32 (PARA7c, 0xfb38de03);\r\ntp->twistie = 5;\r\nnext_tick = HZ / 10;\r\n}\r\nbreak;\r\ncase 5:\r\nRTL_W32 (FIFOTMS, 0x20);\r\nRTL_W32 (PARA78, PARA78_default);\r\nRTL_W32 (PARA7c, PARA7c_default);\r\nRTL_W32 (FIFOTMS, 0x00);\r\ntp->twist_row = 2;\r\ntp->twist_col = 0;\r\ntp->twistie = 3;\r\nnext_tick = HZ / 10;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic inline void rtl8139_thread_iter (struct net_device *dev,\r\nstruct rtl8139_private *tp,\r\nvoid __iomem *ioaddr)\r\n{\r\nint mii_lpa;\r\nmii_lpa = mdio_read (dev, tp->phys[0], MII_LPA);\r\nif (!tp->mii.force_media && mii_lpa != 0xffff) {\r\nint duplex = ((mii_lpa & LPA_100FULL) ||\r\n(mii_lpa & 0x01C0) == 0x0040);\r\nif (tp->mii.full_duplex != duplex) {\r\ntp->mii.full_duplex = duplex;\r\nif (mii_lpa) {\r\nnetdev_info(dev, "Setting %s-duplex based on MII #%d link partner ability of %04x\n",\r\ntp->mii.full_duplex ? "full" : "half",\r\ntp->phys[0], mii_lpa);\r\n} else {\r\nnetdev_info(dev, "media is unconnected, link down, or incompatible connection\n");\r\n}\r\n#if 0\r\nRTL_W8 (Cfg9346, Cfg9346_Unlock);\r\nRTL_W8 (Config1, tp->mii.full_duplex ? 0x60 : 0x20);\r\nRTL_W8 (Cfg9346, Cfg9346_Lock);\r\n#endif\r\n}\r\n}\r\nnext_tick = HZ * 60;\r\nrtl8139_tune_twister (dev, tp);\r\nnetdev_dbg(dev, "Media selection tick, Link partner %04x\n",\r\nRTL_R16(NWayLPAR));\r\nnetdev_dbg(dev, "Other registers are IntMask %04x IntStatus %04x\n",\r\nRTL_R16(IntrMask), RTL_R16(IntrStatus));\r\nnetdev_dbg(dev, "Chip config %02x %02x\n",\r\nRTL_R8(Config0), RTL_R8(Config1));\r\n}\r\nstatic void rtl8139_thread (struct work_struct *work)\r\n{\r\nstruct rtl8139_private *tp =\r\ncontainer_of(work, struct rtl8139_private, thread.work);\r\nstruct net_device *dev = tp->mii.dev;\r\nunsigned long thr_delay = next_tick;\r\nrtnl_lock();\r\nif (!netif_running(dev))\r\ngoto out_unlock;\r\nif (tp->watchdog_fired) {\r\ntp->watchdog_fired = 0;\r\nrtl8139_tx_timeout_task(work);\r\n} else\r\nrtl8139_thread_iter(dev, tp, tp->mmio_addr);\r\nif (tp->have_thread)\r\nschedule_delayed_work(&tp->thread, thr_delay);\r\nout_unlock:\r\nrtnl_unlock ();\r\n}\r\nstatic void rtl8139_start_thread(struct rtl8139_private *tp)\r\n{\r\ntp->twistie = 0;\r\nif (tp->chipset == CH_8139_K)\r\ntp->twistie = 1;\r\nelse if (tp->drv_flags & HAS_LNK_CHNG)\r\nreturn;\r\ntp->have_thread = 1;\r\ntp->watchdog_fired = 0;\r\nschedule_delayed_work(&tp->thread, next_tick);\r\n}\r\nstatic inline void rtl8139_tx_clear (struct rtl8139_private *tp)\r\n{\r\ntp->cur_tx = 0;\r\ntp->dirty_tx = 0;\r\n}\r\nstatic void rtl8139_tx_timeout_task (struct work_struct *work)\r\n{\r\nstruct rtl8139_private *tp =\r\ncontainer_of(work, struct rtl8139_private, thread.work);\r\nstruct net_device *dev = tp->mii.dev;\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint i;\r\nu8 tmp8;\r\nnetdev_dbg(dev, "Transmit timeout, status %02x %04x %04x media %02x\n",\r\nRTL_R8(ChipCmd), RTL_R16(IntrStatus),\r\nRTL_R16(IntrMask), RTL_R8(MediaStatus));\r\nnetdev_dbg(dev, "Tx queue start entry %ld dirty entry %ld\n",\r\ntp->cur_tx, tp->dirty_tx);\r\nfor (i = 0; i < NUM_TX_DESC; i++)\r\nnetdev_dbg(dev, "Tx descriptor %d is %08x%s\n",\r\ni, RTL_R32(TxStatus0 + (i * 4)),\r\ni == tp->dirty_tx % NUM_TX_DESC ?\r\n" (queue head)" : "");\r\ntp->xstats.tx_timeouts++;\r\ntmp8 = RTL_R8 (ChipCmd);\r\nif (tmp8 & CmdTxEnb)\r\nRTL_W8 (ChipCmd, CmdRxEnb);\r\nspin_lock_bh(&tp->rx_lock);\r\nRTL_W16 (IntrMask, 0x0000);\r\nspin_lock_irq(&tp->lock);\r\nrtl8139_tx_clear (tp);\r\nspin_unlock_irq(&tp->lock);\r\nif (netif_running(dev)) {\r\nrtl8139_hw_start (dev);\r\nnetif_wake_queue (dev);\r\n}\r\nspin_unlock_bh(&tp->rx_lock);\r\n}\r\nstatic void rtl8139_tx_timeout (struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\ntp->watchdog_fired = 1;\r\nif (!tp->have_thread) {\r\nINIT_DELAYED_WORK(&tp->thread, rtl8139_thread);\r\nschedule_delayed_work(&tp->thread, next_tick);\r\n}\r\n}\r\nstatic netdev_tx_t rtl8139_start_xmit (struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nunsigned int entry;\r\nunsigned int len = skb->len;\r\nunsigned long flags;\r\nentry = tp->cur_tx % NUM_TX_DESC;\r\nif (likely(len < TX_BUF_SIZE)) {\r\nif (len < ETH_ZLEN)\r\nmemset(tp->tx_buf[entry], 0, ETH_ZLEN);\r\nskb_copy_and_csum_dev(skb, tp->tx_buf[entry]);\r\ndev_kfree_skb(skb);\r\n} else {\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nspin_lock_irqsave(&tp->lock, flags);\r\nwmb();\r\nRTL_W32_F (TxStatus0 + (entry * sizeof (u32)),\r\ntp->tx_flag | max(len, (unsigned int)ETH_ZLEN));\r\ntp->cur_tx++;\r\nif ((tp->cur_tx - NUM_TX_DESC) == tp->dirty_tx)\r\nnetif_stop_queue (dev);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\nnetif_dbg(tp, tx_queued, dev, "Queued Tx packet size %u to slot %d\n",\r\nlen, entry);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void rtl8139_tx_interrupt (struct net_device *dev,\r\nstruct rtl8139_private *tp,\r\nvoid __iomem *ioaddr)\r\n{\r\nunsigned long dirty_tx, tx_left;\r\nassert (dev != NULL);\r\nassert (ioaddr != NULL);\r\ndirty_tx = tp->dirty_tx;\r\ntx_left = tp->cur_tx - dirty_tx;\r\nwhile (tx_left > 0) {\r\nint entry = dirty_tx % NUM_TX_DESC;\r\nint txstatus;\r\ntxstatus = RTL_R32 (TxStatus0 + (entry * sizeof (u32)));\r\nif (!(txstatus & (TxStatOK | TxUnderrun | TxAborted)))\r\nbreak;\r\nif (txstatus & (TxOutOfWindow | TxAborted)) {\r\nnetif_dbg(tp, tx_err, dev, "Transmit error, Tx status %08x\n",\r\ntxstatus);\r\ndev->stats.tx_errors++;\r\nif (txstatus & TxAborted) {\r\ndev->stats.tx_aborted_errors++;\r\nRTL_W32 (TxConfig, TxClearAbt);\r\nRTL_W16 (IntrStatus, TxErr);\r\nwmb();\r\n}\r\nif (txstatus & TxCarrierLost)\r\ndev->stats.tx_carrier_errors++;\r\nif (txstatus & TxOutOfWindow)\r\ndev->stats.tx_window_errors++;\r\n} else {\r\nif (txstatus & TxUnderrun) {\r\nif (tp->tx_flag < 0x00300000)\r\ntp->tx_flag += 0x00020000;\r\ndev->stats.tx_fifo_errors++;\r\n}\r\ndev->stats.collisions += (txstatus >> 24) & 15;\r\nu64_stats_update_begin(&tp->tx_stats.syncp);\r\ntp->tx_stats.packets++;\r\ntp->tx_stats.bytes += txstatus & 0x7ff;\r\nu64_stats_update_end(&tp->tx_stats.syncp);\r\n}\r\ndirty_tx++;\r\ntx_left--;\r\n}\r\n#ifndef RTL8139_NDEBUG\r\nif (tp->cur_tx - dirty_tx > NUM_TX_DESC) {\r\nnetdev_err(dev, "Out-of-sync dirty pointer, %ld vs. %ld\n",\r\ndirty_tx, tp->cur_tx);\r\ndirty_tx += NUM_TX_DESC;\r\n}\r\n#endif\r\nif (tp->dirty_tx != dirty_tx) {\r\ntp->dirty_tx = dirty_tx;\r\nmb();\r\nnetif_wake_queue (dev);\r\n}\r\n}\r\nstatic void rtl8139_rx_err (u32 rx_status, struct net_device *dev,\r\nstruct rtl8139_private *tp, void __iomem *ioaddr)\r\n{\r\nu8 tmp8;\r\n#ifdef CONFIG_8139_OLD_RX_RESET\r\nint tmp_work;\r\n#endif\r\nnetif_dbg(tp, rx_err, dev, "Ethernet frame had errors, status %08x\n",\r\nrx_status);\r\ndev->stats.rx_errors++;\r\nif (!(rx_status & RxStatusOK)) {\r\nif (rx_status & RxTooLong) {\r\nnetdev_dbg(dev, "Oversized Ethernet frame, status %04x!\n",\r\nrx_status);\r\n}\r\nif (rx_status & (RxBadSymbol | RxBadAlign))\r\ndev->stats.rx_frame_errors++;\r\nif (rx_status & (RxRunt | RxTooLong))\r\ndev->stats.rx_length_errors++;\r\nif (rx_status & RxCRCErr)\r\ndev->stats.rx_crc_errors++;\r\n} else {\r\ntp->xstats.rx_lost_in_ring++;\r\n}\r\n#ifndef CONFIG_8139_OLD_RX_RESET\r\ntmp8 = RTL_R8 (ChipCmd);\r\nRTL_W8 (ChipCmd, tmp8 & ~CmdRxEnb);\r\nRTL_W8 (ChipCmd, tmp8);\r\nRTL_W32 (RxConfig, tp->rx_config);\r\ntp->cur_rx = 0;\r\n#else\r\nRTL_W8_F (ChipCmd, CmdTxEnb);\r\ntmp_work = 200;\r\nwhile (--tmp_work > 0) {\r\nudelay(1);\r\ntmp8 = RTL_R8 (ChipCmd);\r\nif (!(tmp8 & CmdRxEnb))\r\nbreak;\r\n}\r\nif (tmp_work <= 0)\r\nnetdev_warn(dev, "rx stop wait too long\n");\r\ntmp_work = 200;\r\nwhile (--tmp_work > 0) {\r\nRTL_W8_F (ChipCmd, CmdRxEnb | CmdTxEnb);\r\nudelay(1);\r\ntmp8 = RTL_R8 (ChipCmd);\r\nif ((tmp8 & CmdRxEnb) && (tmp8 & CmdTxEnb))\r\nbreak;\r\n}\r\nif (tmp_work <= 0)\r\nnetdev_warn(dev, "tx/rx enable wait too long\n");\r\nRTL_W8_F (Cfg9346, Cfg9346_Unlock);\r\nRTL_W8 (ChipCmd, CmdRxEnb | CmdTxEnb);\r\ntp->rx_config = rtl8139_rx_config | AcceptBroadcast | AcceptMyPhys;\r\nRTL_W32 (RxConfig, tp->rx_config);\r\ntp->cur_rx = 0;\r\nnetdev_dbg(dev, "init buffer addresses\n");\r\nRTL_W8 (Cfg9346, Cfg9346_Lock);\r\nRTL_W32_F (RxBuf, tp->rx_ring_dma);\r\n__set_rx_mode (dev);\r\n#endif\r\n}\r\nstatic inline void wrap_copy(struct sk_buff *skb, const unsigned char *ring,\r\nu32 offset, unsigned int size)\r\n{\r\nu32 left = RX_BUF_LEN - offset;\r\nif (size > left) {\r\nskb_copy_to_linear_data(skb, ring + offset, left);\r\nskb_copy_to_linear_data_offset(skb, left, ring, size - left);\r\n} else\r\nskb_copy_to_linear_data(skb, ring + offset, size);\r\n}\r\nstatic void rtl8139_isr_ack(struct rtl8139_private *tp)\r\n{\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu16 status;\r\nstatus = RTL_R16 (IntrStatus) & RxAckBits;\r\nif (likely(status != 0)) {\r\nif (unlikely(status & (RxFIFOOver | RxOverflow))) {\r\ntp->dev->stats.rx_errors++;\r\nif (status & RxFIFOOver)\r\ntp->dev->stats.rx_fifo_errors++;\r\n}\r\nRTL_W16_F (IntrStatus, RxAckBits);\r\n}\r\n}\r\nstatic int rtl8139_rx(struct net_device *dev, struct rtl8139_private *tp,\r\nint budget)\r\n{\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint received = 0;\r\nunsigned char *rx_ring = tp->rx_ring;\r\nunsigned int cur_rx = tp->cur_rx;\r\nunsigned int rx_size = 0;\r\nnetdev_dbg(dev, "In %s(), current %04x BufAddr %04x, free to %04x, Cmd %02x\n",\r\n__func__, (u16)cur_rx,\r\nRTL_R16(RxBufAddr), RTL_R16(RxBufPtr), RTL_R8(ChipCmd));\r\nwhile (netif_running(dev) && received < budget &&\r\n(RTL_R8 (ChipCmd) & RxBufEmpty) == 0) {\r\nu32 ring_offset = cur_rx % RX_BUF_LEN;\r\nu32 rx_status;\r\nunsigned int pkt_size;\r\nstruct sk_buff *skb;\r\nrmb();\r\nrx_status = le32_to_cpu (*(__le32 *) (rx_ring + ring_offset));\r\nrx_size = rx_status >> 16;\r\nif (likely(!(dev->features & NETIF_F_RXFCS)))\r\npkt_size = rx_size - 4;\r\nelse\r\npkt_size = rx_size;\r\nnetif_dbg(tp, rx_status, dev, "%s() status %04x, size %04x, cur %04x\n",\r\n__func__, rx_status, rx_size, cur_rx);\r\n#if RTL8139_DEBUG > 2\r\nprint_hex_dump(KERN_DEBUG, "Frame contents: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\n&rx_ring[ring_offset], 70, true);\r\n#endif\r\nif (unlikely(rx_size == 0xfff0)) {\r\nif (!tp->fifo_copy_timeout)\r\ntp->fifo_copy_timeout = jiffies + 2;\r\nelse if (time_after(jiffies, tp->fifo_copy_timeout)) {\r\nnetdev_dbg(dev, "hung FIFO. Reset\n");\r\nrx_size = 0;\r\ngoto no_early_rx;\r\n}\r\nnetif_dbg(tp, intr, dev, "fifo copy in progress\n");\r\ntp->xstats.early_rx++;\r\nbreak;\r\n}\r\nno_early_rx:\r\ntp->fifo_copy_timeout = 0;\r\nif (unlikely((rx_size > (MAX_ETH_FRAME_SIZE+4)) ||\r\n(rx_size < 8) ||\r\n(!(rx_status & RxStatusOK)))) {\r\nif ((dev->features & NETIF_F_RXALL) &&\r\n(rx_size <= (MAX_ETH_FRAME_SIZE + 4)) &&\r\n(rx_size >= 8) &&\r\n(!(rx_status & RxStatusOK))) {\r\ndev->stats.rx_errors++;\r\nif (rx_status & RxCRCErr) {\r\ndev->stats.rx_crc_errors++;\r\ngoto keep_pkt;\r\n}\r\nif (rx_status & RxRunt) {\r\ndev->stats.rx_length_errors++;\r\ngoto keep_pkt;\r\n}\r\n}\r\nrtl8139_rx_err (rx_status, dev, tp, ioaddr);\r\nreceived = -1;\r\ngoto out;\r\n}\r\nkeep_pkt:\r\nskb = netdev_alloc_skb_ip_align(dev, pkt_size);\r\nif (likely(skb)) {\r\n#if RX_BUF_IDX == 3\r\nwrap_copy(skb, rx_ring, ring_offset+4, pkt_size);\r\n#else\r\nskb_copy_to_linear_data (skb, &rx_ring[ring_offset + 4], pkt_size);\r\n#endif\r\nskb_put (skb, pkt_size);\r\nskb->protocol = eth_type_trans (skb, dev);\r\nu64_stats_update_begin(&tp->rx_stats.syncp);\r\ntp->rx_stats.packets++;\r\ntp->rx_stats.bytes += pkt_size;\r\nu64_stats_update_end(&tp->rx_stats.syncp);\r\nnetif_receive_skb (skb);\r\n} else {\r\nif (net_ratelimit())\r\nnetdev_warn(dev, "Memory squeeze, dropping packet\n");\r\ndev->stats.rx_dropped++;\r\n}\r\nreceived++;\r\ncur_rx = (cur_rx + rx_size + 4 + 3) & ~3;\r\nRTL_W16 (RxBufPtr, (u16) (cur_rx - 16));\r\nrtl8139_isr_ack(tp);\r\n}\r\nif (unlikely(!received || rx_size == 0xfff0))\r\nrtl8139_isr_ack(tp);\r\nnetdev_dbg(dev, "Done %s(), current %04x BufAddr %04x, free to %04x, Cmd %02x\n",\r\n__func__, cur_rx,\r\nRTL_R16(RxBufAddr), RTL_R16(RxBufPtr), RTL_R8(ChipCmd));\r\ntp->cur_rx = cur_rx;\r\nif (tp->fifo_copy_timeout)\r\nreceived = budget;\r\nout:\r\nreturn received;\r\n}\r\nstatic void rtl8139_weird_interrupt (struct net_device *dev,\r\nstruct rtl8139_private *tp,\r\nvoid __iomem *ioaddr,\r\nint status, int link_changed)\r\n{\r\nnetdev_dbg(dev, "Abnormal interrupt, status %08x\n", status);\r\nassert (dev != NULL);\r\nassert (tp != NULL);\r\nassert (ioaddr != NULL);\r\ndev->stats.rx_missed_errors += RTL_R32 (RxMissed);\r\nRTL_W32 (RxMissed, 0);\r\nif ((status & RxUnderrun) && link_changed &&\r\n(tp->drv_flags & HAS_LNK_CHNG)) {\r\nrtl_check_media(dev, 0);\r\nstatus &= ~RxUnderrun;\r\n}\r\nif (status & (RxUnderrun | RxErr))\r\ndev->stats.rx_errors++;\r\nif (status & PCSTimeout)\r\ndev->stats.rx_length_errors++;\r\nif (status & RxUnderrun)\r\ndev->stats.rx_fifo_errors++;\r\nif (status & PCIErr) {\r\nu16 pci_cmd_status;\r\npci_read_config_word (tp->pci_dev, PCI_STATUS, &pci_cmd_status);\r\npci_write_config_word (tp->pci_dev, PCI_STATUS, pci_cmd_status);\r\nnetdev_err(dev, "PCI Bus error %04x\n", pci_cmd_status);\r\n}\r\n}\r\nstatic int rtl8139_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct rtl8139_private *tp = container_of(napi, struct rtl8139_private, napi);\r\nstruct net_device *dev = tp->dev;\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint work_done;\r\nspin_lock(&tp->rx_lock);\r\nwork_done = 0;\r\nif (likely(RTL_R16(IntrStatus) & RxAckBits))\r\nwork_done += rtl8139_rx(dev, tp, budget);\r\nif (work_done < budget) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&tp->lock, flags);\r\n__napi_complete(napi);\r\nRTL_W16_F(IntrMask, rtl8139_intr_mask);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\n}\r\nspin_unlock(&tp->rx_lock);\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t rtl8139_interrupt (int irq, void *dev_instance)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_instance;\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu16 status, ackstat;\r\nint link_changed = 0;\r\nint handled = 0;\r\nspin_lock (&tp->lock);\r\nstatus = RTL_R16 (IntrStatus);\r\nif (unlikely((status & rtl8139_intr_mask) == 0))\r\ngoto out;\r\nhandled = 1;\r\nif (unlikely(status == 0xFFFF))\r\ngoto out;\r\nif (unlikely(!netif_running(dev))) {\r\nRTL_W16 (IntrMask, 0);\r\ngoto out;\r\n}\r\nif (unlikely(status & RxUnderrun))\r\nlink_changed = RTL_R16 (CSCR) & CSCR_LinkChangeBit;\r\nackstat = status & ~(RxAckBits | TxErr);\r\nif (ackstat)\r\nRTL_W16 (IntrStatus, ackstat);\r\nif (status & RxAckBits){\r\nif (napi_schedule_prep(&tp->napi)) {\r\nRTL_W16_F (IntrMask, rtl8139_norx_intr_mask);\r\n__napi_schedule(&tp->napi);\r\n}\r\n}\r\nif (unlikely(status & (PCIErr | PCSTimeout | RxUnderrun | RxErr)))\r\nrtl8139_weird_interrupt (dev, tp, ioaddr,\r\nstatus, link_changed);\r\nif (status & (TxOK | TxErr)) {\r\nrtl8139_tx_interrupt (dev, tp, ioaddr);\r\nif (status & TxErr)\r\nRTL_W16 (IntrStatus, TxErr);\r\n}\r\nout:\r\nspin_unlock (&tp->lock);\r\nnetdev_dbg(dev, "exiting interrupt, intr_status=%#4.4x\n",\r\nRTL_R16(IntrStatus));\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void rtl8139_poll_controller(struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nconst int irq = tp->pci_dev->irq;\r\ndisable_irq(irq);\r\nrtl8139_interrupt(irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic int rtl8139_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nspin_lock_irq(&tp->lock);\r\nRTL_W8_F(Cfg9346, Cfg9346_Unlock);\r\nRTL_W32_F(MAC0 + 0, cpu_to_le32 (*(u32 *) (dev->dev_addr + 0)));\r\nRTL_W32_F(MAC0 + 4, cpu_to_le32 (*(u32 *) (dev->dev_addr + 4)));\r\nRTL_W8_F(Cfg9346, Cfg9346_Lock);\r\nspin_unlock_irq(&tp->lock);\r\nreturn 0;\r\n}\r\nstatic int rtl8139_close (struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nnapi_disable(&tp->napi);\r\nnetif_dbg(tp, ifdown, dev, "Shutting down ethercard, status was 0x%04x\n",\r\nRTL_R16(IntrStatus));\r\nspin_lock_irqsave (&tp->lock, flags);\r\nRTL_W8 (ChipCmd, 0);\r\nRTL_W16 (IntrMask, 0);\r\ndev->stats.rx_missed_errors += RTL_R32 (RxMissed);\r\nRTL_W32 (RxMissed, 0);\r\nspin_unlock_irqrestore (&tp->lock, flags);\r\nfree_irq(tp->pci_dev->irq, dev);\r\nrtl8139_tx_clear (tp);\r\ndma_free_coherent(&tp->pci_dev->dev, RX_BUF_TOT_LEN,\r\ntp->rx_ring, tp->rx_ring_dma);\r\ndma_free_coherent(&tp->pci_dev->dev, TX_BUF_TOT_LEN,\r\ntp->tx_bufs, tp->tx_bufs_dma);\r\ntp->rx_ring = NULL;\r\ntp->tx_bufs = NULL;\r\nRTL_W8 (Cfg9346, Cfg9346_Unlock);\r\nif (rtl_chip_info[tp->chipset].flags & HasHltClk)\r\nRTL_W8 (HltClk, 'H');\r\nreturn 0;\r\n}\r\nstatic void rtl8139_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nspin_lock_irq(&tp->lock);\r\nif (rtl_chip_info[tp->chipset].flags & HasLWake) {\r\nu8 cfg3 = RTL_R8 (Config3);\r\nu8 cfg5 = RTL_R8 (Config5);\r\nwol->supported = WAKE_PHY | WAKE_MAGIC\r\n| WAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\nwol->wolopts = 0;\r\nif (cfg3 & Cfg3_LinkUp)\r\nwol->wolopts |= WAKE_PHY;\r\nif (cfg3 & Cfg3_Magic)\r\nwol->wolopts |= WAKE_MAGIC;\r\nif (cfg5 & Cfg5_UWF)\r\nwol->wolopts |= WAKE_UCAST;\r\nif (cfg5 & Cfg5_MWF)\r\nwol->wolopts |= WAKE_MCAST;\r\nif (cfg5 & Cfg5_BWF)\r\nwol->wolopts |= WAKE_BCAST;\r\n}\r\nspin_unlock_irq(&tp->lock);\r\n}\r\nstatic int rtl8139_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu32 support;\r\nu8 cfg3, cfg5;\r\nsupport = ((rtl_chip_info[tp->chipset].flags & HasLWake)\r\n? (WAKE_PHY | WAKE_MAGIC\r\n| WAKE_UCAST | WAKE_MCAST | WAKE_BCAST)\r\n: 0);\r\nif (wol->wolopts & ~support)\r\nreturn -EINVAL;\r\nspin_lock_irq(&tp->lock);\r\ncfg3 = RTL_R8 (Config3) & ~(Cfg3_LinkUp | Cfg3_Magic);\r\nif (wol->wolopts & WAKE_PHY)\r\ncfg3 |= Cfg3_LinkUp;\r\nif (wol->wolopts & WAKE_MAGIC)\r\ncfg3 |= Cfg3_Magic;\r\nRTL_W8 (Cfg9346, Cfg9346_Unlock);\r\nRTL_W8 (Config3, cfg3);\r\nRTL_W8 (Cfg9346, Cfg9346_Lock);\r\ncfg5 = RTL_R8 (Config5) & ~(Cfg5_UWF | Cfg5_MWF | Cfg5_BWF);\r\nif (wol->wolopts & WAKE_UCAST)\r\ncfg5 |= Cfg5_UWF;\r\nif (wol->wolopts & WAKE_MCAST)\r\ncfg5 |= Cfg5_MWF;\r\nif (wol->wolopts & WAKE_BCAST)\r\ncfg5 |= Cfg5_BWF;\r\nRTL_W8 (Config5, cfg5);\r\nspin_unlock_irq(&tp->lock);\r\nreturn 0;\r\n}\r\nstatic void rtl8139_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(tp->pci_dev), sizeof(info->bus_info));\r\ninfo->regdump_len = tp->regs_len;\r\n}\r\nstatic int rtl8139_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nspin_lock_irq(&tp->lock);\r\nmii_ethtool_gset(&tp->mii, cmd);\r\nspin_unlock_irq(&tp->lock);\r\nreturn 0;\r\n}\r\nstatic int rtl8139_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&tp->lock);\r\nrc = mii_ethtool_sset(&tp->mii, cmd);\r\nspin_unlock_irq(&tp->lock);\r\nreturn rc;\r\n}\r\nstatic int rtl8139_nway_reset(struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nreturn mii_nway_restart(&tp->mii);\r\n}\r\nstatic u32 rtl8139_get_link(struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nreturn mii_link_ok(&tp->mii);\r\n}\r\nstatic u32 rtl8139_get_msglevel(struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nreturn tp->msg_enable;\r\n}\r\nstatic void rtl8139_set_msglevel(struct net_device *dev, u32 datum)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\ntp->msg_enable = datum;\r\n}\r\nstatic int rtl8139_get_regs_len(struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp;\r\nif (use_io)\r\nreturn 0;\r\ntp = netdev_priv(dev);\r\nreturn tp->regs_len;\r\n}\r\nstatic void rtl8139_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *regbuf)\r\n{\r\nstruct rtl8139_private *tp;\r\nif (use_io)\r\nreturn;\r\ntp = netdev_priv(dev);\r\nregs->version = RTL_REGS_VER;\r\nspin_lock_irq(&tp->lock);\r\nmemcpy_fromio(regbuf, tp->mmio_addr, regs->len);\r\nspin_unlock_irq(&tp->lock);\r\n}\r\nstatic int rtl8139_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn RTL_NUM_STATS;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void rtl8139_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\ndata[0] = tp->xstats.early_rx;\r\ndata[1] = tp->xstats.tx_buf_mapped;\r\ndata[2] = tp->xstats.tx_timeouts;\r\ndata[3] = tp->xstats.rx_lost_in_ring;\r\n}\r\nstatic void rtl8139_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nmemcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));\r\n}\r\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nint rc;\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nspin_lock_irq(&tp->lock);\r\nrc = generic_mii_ioctl(&tp->mii, if_mii(rq), cmd, NULL);\r\nspin_unlock_irq(&tp->lock);\r\nreturn rc;\r\n}\r\nstatic struct rtnl_link_stats64 *\r\nrtl8139_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nunsigned long flags;\r\nunsigned int start;\r\nif (netif_running(dev)) {\r\nspin_lock_irqsave (&tp->lock, flags);\r\ndev->stats.rx_missed_errors += RTL_R32 (RxMissed);\r\nRTL_W32 (RxMissed, 0);\r\nspin_unlock_irqrestore (&tp->lock, flags);\r\n}\r\nnetdev_stats_to_stats64(stats, &dev->stats);\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&tp->rx_stats.syncp);\r\nstats->rx_packets = tp->rx_stats.packets;\r\nstats->rx_bytes = tp->rx_stats.bytes;\r\n} while (u64_stats_fetch_retry_bh(&tp->rx_stats.syncp, start));\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&tp->tx_stats.syncp);\r\nstats->tx_packets = tp->tx_stats.packets;\r\nstats->tx_bytes = tp->tx_stats.bytes;\r\n} while (u64_stats_fetch_retry_bh(&tp->tx_stats.syncp, start));\r\nreturn stats;\r\n}\r\nstatic void __set_rx_mode (struct net_device *dev)\r\n{\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu32 mc_filter[2];\r\nint rx_mode;\r\nu32 tmp;\r\nnetdev_dbg(dev, "rtl8139_set_rx_mode(%04x) done -- Rx config %08x\n",\r\ndev->flags, RTL_R32(RxConfig));\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode =\r\nAcceptBroadcast | AcceptMulticast | AcceptMyPhys |\r\nAcceptAllPhys;\r\nmc_filter[1] = mc_filter[0] = 0xffffffff;\r\n} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nrx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;\r\nmc_filter[1] = mc_filter[0] = 0xffffffff;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nrx_mode = AcceptBroadcast | AcceptMyPhys;\r\nmc_filter[1] = mc_filter[0] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\nrx_mode |= AcceptMulticast;\r\n}\r\n}\r\nif (dev->features & NETIF_F_RXALL)\r\nrx_mode |= (AcceptErr | AcceptRunt);\r\ntmp = rtl8139_rx_config | rx_mode;\r\nif (tp->rx_config != tmp) {\r\nRTL_W32_F (RxConfig, tmp);\r\ntp->rx_config = tmp;\r\n}\r\nRTL_W32_F (MAR0 + 0, mc_filter[0]);\r\nRTL_W32_F (MAR0 + 4, mc_filter[1]);\r\n}\r\nstatic void rtl8139_set_rx_mode (struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nspin_lock_irqsave (&tp->lock, flags);\r\n__set_rx_mode(dev);\r\nspin_unlock_irqrestore (&tp->lock, flags);\r\n}\r\nstatic int rtl8139_suspend (struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\nstruct rtl8139_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nunsigned long flags;\r\npci_save_state (pdev);\r\nif (!netif_running (dev))\r\nreturn 0;\r\nnetif_device_detach (dev);\r\nspin_lock_irqsave (&tp->lock, flags);\r\nRTL_W16 (IntrMask, 0);\r\nRTL_W8 (ChipCmd, 0);\r\ndev->stats.rx_missed_errors += RTL_R32 (RxMissed);\r\nRTL_W32 (RxMissed, 0);\r\nspin_unlock_irqrestore (&tp->lock, flags);\r\npci_set_power_state (pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int rtl8139_resume (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata (pdev);\r\npci_restore_state (pdev);\r\nif (!netif_running (dev))\r\nreturn 0;\r\npci_set_power_state (pdev, PCI_D0);\r\nrtl8139_init_ring (dev);\r\nrtl8139_hw_start (dev);\r\nnetif_device_attach (dev);\r\nreturn 0;\r\n}\r\nstatic int __init rtl8139_init_module (void)\r\n{\r\n#ifdef MODULE\r\npr_info(RTL8139_DRIVER_NAME "\n");\r\n#endif\r\nreturn pci_register_driver(&rtl8139_pci_driver);\r\n}\r\nstatic void __exit rtl8139_cleanup_module (void)\r\n{\r\npci_unregister_driver (&rtl8139_pci_driver);\r\n}
