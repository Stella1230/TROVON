static void s6gmac_rx_fillfifo(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nwhile ((((u8)(pd->rx_skb_i - pd->rx_skb_o)) < S6_NUM_RX_SKB) &&\r\n(!s6dmac_fifo_full(pd->rx_dma, pd->rx_chan)) &&\r\n(skb = netdev_alloc_skb(dev, S6_MAX_FRLEN + 2))) {\r\npd->rx_skb[(pd->rx_skb_i++) % S6_NUM_RX_SKB] = skb;\r\ns6dmac_put_fifo_cache(pd->rx_dma, pd->rx_chan,\r\npd->io, (u32)skb->data, S6_MAX_FRLEN);\r\n}\r\n}\r\nstatic void s6gmac_rx_interrupt(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nu32 pfx;\r\nstruct sk_buff *skb;\r\nwhile (((u8)(pd->rx_skb_i - pd->rx_skb_o)) >\r\ns6dmac_pending_count(pd->rx_dma, pd->rx_chan)) {\r\nskb = pd->rx_skb[(pd->rx_skb_o++) % S6_NUM_RX_SKB];\r\npfx = readl(pd->reg + S6_GMAC_BURST_POSTRD);\r\nif (pfx & (1 << S6_GMAC_BURST_POSTRD_DROP)) {\r\ndev_kfree_skb_irq(skb);\r\n} else {\r\nskb_put(skb, (pfx >> S6_GMAC_BURST_POSTRD_LEN)\r\n& S6_GMAC_BURST_POSTRD_LEN_MASK);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnetif_rx(skb);\r\n}\r\n}\r\n}\r\nstatic void s6gmac_tx_interrupt(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nwhile (((u8)(pd->tx_skb_i - pd->tx_skb_o)) >\r\ns6dmac_pending_count(pd->tx_dma, pd->tx_chan)) {\r\ndev_kfree_skb_irq(pd->tx_skb[(pd->tx_skb_o++) % S6_NUM_TX_SKB]);\r\n}\r\nif (!s6dmac_fifo_full(pd->tx_dma, pd->tx_chan))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void s6gmac_stats_collect(struct s6gmac *pd,\r\nconst struct s6gmac_statinf *inf)\r\n{\r\nint b;\r\nfor (b = 0; b < S6_STATS_B; b++) {\r\nif (inf[b].reg_size) {\r\npd->stats[inf[b].net_index] +=\r\nreadl(pd->reg + S6_GMAC_STAT_REGS\r\n+ sizeof(u32) * inf[b].reg_off);\r\n}\r\n}\r\n}\r\nstatic void s6gmac_stats_carry(struct s6gmac *pd,\r\nconst struct s6gmac_statinf *inf, u32 mask)\r\n{\r\nint b;\r\nwhile (mask) {\r\nb = fls(mask) - 1;\r\nmask &= ~(1 << b);\r\npd->carry[inf[b].net_index] += (1 << inf[b].reg_size);\r\n}\r\n}\r\nstatic inline u32 s6gmac_stats_pending(struct s6gmac *pd, int carry)\r\n{\r\nint r = readl(pd->reg + S6_GMAC_STATCARRY(carry)) &\r\n~readl(pd->reg + S6_GMAC_STATCARRYMSK(carry));\r\nreturn r;\r\n}\r\nstatic inline void s6gmac_stats_interrupt(struct s6gmac *pd, int carry)\r\n{\r\nu32 mask;\r\nmask = s6gmac_stats_pending(pd, carry);\r\nif (mask) {\r\nwritel(mask, pd->reg + S6_GMAC_STATCARRY(carry));\r\ns6gmac_stats_carry(pd, &statinf[carry][0], mask);\r\n}\r\n}\r\nstatic irqreturn_t s6gmac_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nif (!dev)\r\nreturn IRQ_NONE;\r\nspin_lock(&pd->lock);\r\nif (s6dmac_termcnt_irq(pd->rx_dma, pd->rx_chan))\r\ns6gmac_rx_interrupt(dev);\r\ns6gmac_rx_fillfifo(dev);\r\nif (s6dmac_termcnt_irq(pd->tx_dma, pd->tx_chan))\r\ns6gmac_tx_interrupt(dev);\r\ns6gmac_stats_interrupt(pd, 0);\r\ns6gmac_stats_interrupt(pd, 1);\r\nspin_unlock(&pd->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void s6gmac_set_dstaddr(struct s6gmac *pd, int n,\r\nu32 addrlo, u32 addrhi, u32 masklo, u32 maskhi)\r\n{\r\nwritel(addrlo, pd->reg + S6_GMAC_HOST_DSTADDRLO(n));\r\nwritel(addrhi, pd->reg + S6_GMAC_HOST_DSTADDRHI(n));\r\nwritel(masklo, pd->reg + S6_GMAC_HOST_DSTMASKLO(n));\r\nwritel(maskhi, pd->reg + S6_GMAC_HOST_DSTMASKHI(n));\r\n}\r\nstatic inline void s6gmac_stop_device(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nwritel(0, pd->reg + S6_GMAC_MACCONF1);\r\n}\r\nstatic inline void s6gmac_init_device(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nint is_rgmii = !!(pd->phydev->supported\r\n& (SUPPORTED_1000baseT_Full | SUPPORTED_1000baseT_Half));\r\n#if 0\r\nwritel(1 << S6_GMAC_MACCONF1_SYNCTX |\r\n1 << S6_GMAC_MACCONF1_SYNCRX |\r\n1 << S6_GMAC_MACCONF1_TXFLOWCTRL |\r\n1 << S6_GMAC_MACCONF1_RXFLOWCTRL |\r\n1 << S6_GMAC_MACCONF1_RESTXFUNC |\r\n1 << S6_GMAC_MACCONF1_RESRXFUNC |\r\n1 << S6_GMAC_MACCONF1_RESTXMACCTRL |\r\n1 << S6_GMAC_MACCONF1_RESRXMACCTRL,\r\npd->reg + S6_GMAC_MACCONF1);\r\n#endif\r\nwritel(1 << S6_GMAC_MACCONF1_SOFTRES, pd->reg + S6_GMAC_MACCONF1);\r\nudelay(1000);\r\nwritel(1 << S6_GMAC_MACCONF1_TXENA | 1 << S6_GMAC_MACCONF1_RXENA,\r\npd->reg + S6_GMAC_MACCONF1);\r\nwritel(1 << S6_GMAC_HOST_PBLKCTRL_TXSRES |\r\n1 << S6_GMAC_HOST_PBLKCTRL_RXSRES,\r\npd->reg + S6_GMAC_HOST_PBLKCTRL);\r\nwritel(S6_GMAC_HOST_PBLKCTRL_SIZ_128 << S6_GMAC_HOST_PBLKCTRL_TXBSIZ |\r\nS6_GMAC_HOST_PBLKCTRL_SIZ_128 << S6_GMAC_HOST_PBLKCTRL_RXBSIZ |\r\n1 << S6_GMAC_HOST_PBLKCTRL_STATENA |\r\n1 << S6_GMAC_HOST_PBLKCTRL_STATCLEAR |\r\nis_rgmii << S6_GMAC_HOST_PBLKCTRL_RGMII,\r\npd->reg + S6_GMAC_HOST_PBLKCTRL);\r\nwritel(1 << S6_GMAC_MACCONF1_TXENA |\r\n1 << S6_GMAC_MACCONF1_RXENA |\r\n(dev->flags & IFF_LOOPBACK ? 1 : 0)\r\n<< S6_GMAC_MACCONF1_LOOPBACK,\r\npd->reg + S6_GMAC_MACCONF1);\r\nwritel(dev->mtu && (dev->mtu < (S6_MAX_FRLEN - ETH_HLEN-ETH_FCS_LEN)) ?\r\ndev->mtu+ETH_HLEN+ETH_FCS_LEN : S6_MAX_FRLEN,\r\npd->reg + S6_GMAC_MACMAXFRAMELEN);\r\nwritel((pd->link.full ? 1 : 0) << S6_GMAC_MACCONF2_FULL |\r\n1 << S6_GMAC_MACCONF2_PADCRCENA |\r\n1 << S6_GMAC_MACCONF2_LENGTHFCHK |\r\n(pd->link.giga ?\r\nS6_GMAC_MACCONF2_IFMODE_BYTE :\r\nS6_GMAC_MACCONF2_IFMODE_NIBBLE)\r\n<< S6_GMAC_MACCONF2_IFMODE |\r\n7 << S6_GMAC_MACCONF2_PREAMBLELEN,\r\npd->reg + S6_GMAC_MACCONF2);\r\nwritel(0, pd->reg + S6_GMAC_MACSTATADDR1);\r\nwritel(0, pd->reg + S6_GMAC_MACSTATADDR2);\r\nwritel(1 << S6_GMAC_FIFOCONF0_WTMENREQ |\r\n1 << S6_GMAC_FIFOCONF0_SRFENREQ |\r\n1 << S6_GMAC_FIFOCONF0_FRFENREQ |\r\n1 << S6_GMAC_FIFOCONF0_STFENREQ |\r\n1 << S6_GMAC_FIFOCONF0_FTFENREQ,\r\npd->reg + S6_GMAC_FIFOCONF0);\r\nwritel(128 << S6_GMAC_FIFOCONF3_CFGFTTH |\r\n128 << S6_GMAC_FIFOCONF3_CFGHWMFT,\r\npd->reg + S6_GMAC_FIFOCONF3);\r\nwritel((S6_GMAC_FIFOCONF_RSV_MASK & ~(\r\n1 << S6_GMAC_FIFOCONF_RSV_RUNT |\r\n1 << S6_GMAC_FIFOCONF_RSV_CRCERR |\r\n1 << S6_GMAC_FIFOCONF_RSV_OK |\r\n1 << S6_GMAC_FIFOCONF_RSV_DRIBBLE |\r\n1 << S6_GMAC_FIFOCONF_RSV_CTRLFRAME |\r\n1 << S6_GMAC_FIFOCONF_RSV_PAUSECTRL |\r\n1 << S6_GMAC_FIFOCONF_RSV_UNOPCODE |\r\n1 << S6_GMAC_FIFOCONF_RSV_TRUNCATED)) |\r\n1 << S6_GMAC_FIFOCONF5_DROPLT64 |\r\npd->link.giga << S6_GMAC_FIFOCONF5_CFGBYTM |\r\n1 << S6_GMAC_FIFOCONF5_RXDROPSIZE,\r\npd->reg + S6_GMAC_FIFOCONF5);\r\nwritel(1 << S6_GMAC_FIFOCONF_RSV_RUNT |\r\n1 << S6_GMAC_FIFOCONF_RSV_CRCERR |\r\n1 << S6_GMAC_FIFOCONF_RSV_DRIBBLE |\r\n1 << S6_GMAC_FIFOCONF_RSV_CTRLFRAME |\r\n1 << S6_GMAC_FIFOCONF_RSV_PAUSECTRL |\r\n1 << S6_GMAC_FIFOCONF_RSV_UNOPCODE |\r\n1 << S6_GMAC_FIFOCONF_RSV_TRUNCATED,\r\npd->reg + S6_GMAC_FIFOCONF4);\r\ns6gmac_set_dstaddr(pd, 0,\r\n0xFFFFFFFF, 0x0000FFFF, 0xFFFFFFFF, 0x0000FFFF);\r\ns6gmac_set_dstaddr(pd, 1,\r\ndev->dev_addr[5] |\r\ndev->dev_addr[4] << 8 |\r\ndev->dev_addr[3] << 16 |\r\ndev->dev_addr[2] << 24,\r\ndev->dev_addr[1] |\r\ndev->dev_addr[0] << 8,\r\n0xFFFFFFFF, 0x0000FFFF);\r\ns6gmac_set_dstaddr(pd, 2,\r\n0x00000000, 0x00000100, 0x00000000, 0x00000100);\r\ns6gmac_set_dstaddr(pd, 3,\r\n0x00000000, 0x00000000, 0x00000000, 0x00000000);\r\nwritel(1 << S6_GMAC_HOST_PBLKCTRL_TXENA |\r\n1 << S6_GMAC_HOST_PBLKCTRL_RXENA |\r\nS6_GMAC_HOST_PBLKCTRL_SIZ_128 << S6_GMAC_HOST_PBLKCTRL_TXBSIZ |\r\nS6_GMAC_HOST_PBLKCTRL_SIZ_128 << S6_GMAC_HOST_PBLKCTRL_RXBSIZ |\r\n1 << S6_GMAC_HOST_PBLKCTRL_STATENA |\r\n1 << S6_GMAC_HOST_PBLKCTRL_STATCLEAR |\r\nis_rgmii << S6_GMAC_HOST_PBLKCTRL_RGMII,\r\npd->reg + S6_GMAC_HOST_PBLKCTRL);\r\n}\r\nstatic void s6mii_enable(struct s6gmac *pd)\r\n{\r\nwritel(readl(pd->reg + S6_GMAC_MACCONF1) &\r\n~(1 << S6_GMAC_MACCONF1_SOFTRES),\r\npd->reg + S6_GMAC_MACCONF1);\r\nwritel((readl(pd->reg + S6_GMAC_MACMIICONF)\r\n& ~(S6_GMAC_MACMIICONF_CSEL_MASK << S6_GMAC_MACMIICONF_CSEL))\r\n| (S6_GMAC_MACMIICONF_CSEL_DIV168 << S6_GMAC_MACMIICONF_CSEL),\r\npd->reg + S6_GMAC_MACMIICONF);\r\n}\r\nstatic int s6mii_busy(struct s6gmac *pd, int tmo)\r\n{\r\nwhile (readl(pd->reg + S6_GMAC_MACMIIINDI)) {\r\nif (--tmo == 0)\r\nreturn -ETIME;\r\nudelay(64);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s6mii_read(struct mii_bus *bus, int phy_addr, int regnum)\r\n{\r\nstruct s6gmac *pd = bus->priv;\r\ns6mii_enable(pd);\r\nif (s6mii_busy(pd, 256))\r\nreturn -ETIME;\r\nwritel(phy_addr << S6_GMAC_MACMIIADDR_PHY |\r\nregnum << S6_GMAC_MACMIIADDR_REG,\r\npd->reg + S6_GMAC_MACMIIADDR);\r\nwritel(1 << S6_GMAC_MACMIICMD_READ, pd->reg + S6_GMAC_MACMIICMD);\r\nwritel(0, pd->reg + S6_GMAC_MACMIICMD);\r\nif (s6mii_busy(pd, 256))\r\nreturn -ETIME;\r\nreturn (u16)readl(pd->reg + S6_GMAC_MACMIISTAT);\r\n}\r\nstatic int s6mii_write(struct mii_bus *bus, int phy_addr, int regnum, u16 value)\r\n{\r\nstruct s6gmac *pd = bus->priv;\r\ns6mii_enable(pd);\r\nif (s6mii_busy(pd, 256))\r\nreturn -ETIME;\r\nwritel(phy_addr << S6_GMAC_MACMIIADDR_PHY |\r\nregnum << S6_GMAC_MACMIIADDR_REG,\r\npd->reg + S6_GMAC_MACMIIADDR);\r\nwritel(value, pd->reg + S6_GMAC_MACMIICTRL);\r\nif (s6mii_busy(pd, 256))\r\nreturn -ETIME;\r\nreturn 0;\r\n}\r\nstatic int s6mii_reset(struct mii_bus *bus)\r\n{\r\nstruct s6gmac *pd = bus->priv;\r\ns6mii_enable(pd);\r\nif (s6mii_busy(pd, PHY_INIT_TIMEOUT))\r\nreturn -ETIME;\r\nreturn 0;\r\n}\r\nstatic void s6gmac_set_rgmii_txclock(struct s6gmac *pd)\r\n{\r\nu32 pllsel = readl(S6_REG_GREG1 + S6_GREG1_PLLSEL);\r\npllsel &= ~(S6_GREG1_PLLSEL_GMAC_MASK << S6_GREG1_PLLSEL_GMAC);\r\nswitch (pd->link.mbit) {\r\ncase 10:\r\npllsel |= S6_GREG1_PLLSEL_GMAC_2500KHZ << S6_GREG1_PLLSEL_GMAC;\r\nbreak;\r\ncase 100:\r\npllsel |= S6_GREG1_PLLSEL_GMAC_25MHZ << S6_GREG1_PLLSEL_GMAC;\r\nbreak;\r\ncase 1000:\r\npllsel |= S6_GREG1_PLLSEL_GMAC_125MHZ << S6_GREG1_PLLSEL_GMAC;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nwritel(pllsel, S6_REG_GREG1 + S6_GREG1_PLLSEL);\r\n}\r\nstatic inline void s6gmac_linkisup(struct net_device *dev, int isup)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nstruct phy_device *phydev = pd->phydev;\r\npd->link.full = phydev->duplex;\r\npd->link.giga = (phydev->speed == 1000);\r\nif (pd->link.mbit != phydev->speed) {\r\npd->link.mbit = phydev->speed;\r\ns6gmac_set_rgmii_txclock(pd);\r\n}\r\npd->link.isup = isup;\r\nif (isup)\r\nnetif_carrier_on(dev);\r\nphy_print_status(phydev);\r\n}\r\nstatic void s6gmac_adjust_link(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nstruct phy_device *phydev = pd->phydev;\r\nif (pd->link.isup &&\r\n(!phydev->link ||\r\n(pd->link.mbit != phydev->speed) ||\r\n(pd->link.full != phydev->duplex))) {\r\npd->link.isup = 0;\r\nnetif_tx_disable(dev);\r\nif (!phydev->link) {\r\nnetif_carrier_off(dev);\r\nphy_print_status(phydev);\r\n}\r\n}\r\nif (!pd->link.isup && phydev->link) {\r\nif (pd->link.full != phydev->duplex) {\r\nu32 maccfg = readl(pd->reg + S6_GMAC_MACCONF2);\r\nif (phydev->duplex)\r\nmaccfg |= 1 << S6_GMAC_MACCONF2_FULL;\r\nelse\r\nmaccfg &= ~(1 << S6_GMAC_MACCONF2_FULL);\r\nwritel(maccfg, pd->reg + S6_GMAC_MACCONF2);\r\n}\r\nif (pd->link.giga != (phydev->speed == 1000)) {\r\nu32 fifocfg = readl(pd->reg + S6_GMAC_FIFOCONF5);\r\nu32 maccfg = readl(pd->reg + S6_GMAC_MACCONF2);\r\nmaccfg &= ~(S6_GMAC_MACCONF2_IFMODE_MASK\r\n<< S6_GMAC_MACCONF2_IFMODE);\r\nif (phydev->speed == 1000) {\r\nfifocfg |= 1 << S6_GMAC_FIFOCONF5_CFGBYTM;\r\nmaccfg |= S6_GMAC_MACCONF2_IFMODE_BYTE\r\n<< S6_GMAC_MACCONF2_IFMODE;\r\n} else {\r\nfifocfg &= ~(1 << S6_GMAC_FIFOCONF5_CFGBYTM);\r\nmaccfg |= S6_GMAC_MACCONF2_IFMODE_NIBBLE\r\n<< S6_GMAC_MACCONF2_IFMODE;\r\n}\r\nwritel(fifocfg, pd->reg + S6_GMAC_FIFOCONF5);\r\nwritel(maccfg, pd->reg + S6_GMAC_MACCONF2);\r\n}\r\nif (!s6dmac_fifo_full(pd->tx_dma, pd->tx_chan))\r\nnetif_wake_queue(dev);\r\ns6gmac_linkisup(dev, 1);\r\n}\r\n}\r\nstatic inline int s6gmac_phy_start(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nint i = 0;\r\nstruct phy_device *p = NULL;\r\nwhile ((i < PHY_MAX_ADDR) && (!(p = pd->mii.bus->phy_map[i])))\r\ni++;\r\np = phy_connect(dev, dev_name(&p->dev), &s6gmac_adjust_link, 0,\r\nPHY_INTERFACE_MODE_RGMII);\r\nif (IS_ERR(p)) {\r\nprintk(KERN_ERR "%s: Could not attach to PHY\n", dev->name);\r\nreturn PTR_ERR(p);\r\n}\r\np->supported &= PHY_GBIT_FEATURES;\r\np->advertising = p->supported;\r\npd->phydev = p;\r\nreturn 0;\r\n}\r\nstatic inline void s6gmac_init_stats(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nu32 mask;\r\nmask = 1 << S6_GMAC_STATCARRY1_RDRP |\r\n1 << S6_GMAC_STATCARRY1_RJBR |\r\n1 << S6_GMAC_STATCARRY1_RFRG |\r\n1 << S6_GMAC_STATCARRY1_ROVR |\r\n1 << S6_GMAC_STATCARRY1_RUND |\r\n1 << S6_GMAC_STATCARRY1_RCDE |\r\n1 << S6_GMAC_STATCARRY1_RFLR |\r\n1 << S6_GMAC_STATCARRY1_RALN |\r\n1 << S6_GMAC_STATCARRY1_RMCA |\r\n1 << S6_GMAC_STATCARRY1_RFCS |\r\n1 << S6_GMAC_STATCARRY1_RPKT |\r\n1 << S6_GMAC_STATCARRY1_RBYT;\r\nwritel(mask, pd->reg + S6_GMAC_STATCARRY(0));\r\nwritel(~mask, pd->reg + S6_GMAC_STATCARRYMSK(0));\r\nmask = 1 << S6_GMAC_STATCARRY2_TDRP |\r\n1 << S6_GMAC_STATCARRY2_TNCL |\r\n1 << S6_GMAC_STATCARRY2_TXCL |\r\n1 << S6_GMAC_STATCARRY2_TEDF |\r\n1 << S6_GMAC_STATCARRY2_TPKT |\r\n1 << S6_GMAC_STATCARRY2_TBYT |\r\n1 << S6_GMAC_STATCARRY2_TFRG |\r\n1 << S6_GMAC_STATCARRY2_TUND |\r\n1 << S6_GMAC_STATCARRY2_TOVR |\r\n1 << S6_GMAC_STATCARRY2_TFCS |\r\n1 << S6_GMAC_STATCARRY2_TJBR;\r\nwritel(mask, pd->reg + S6_GMAC_STATCARRY(1));\r\nwritel(~mask, pd->reg + S6_GMAC_STATCARRYMSK(1));\r\n}\r\nstatic inline void s6gmac_init_dmac(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\ns6dmac_disable_chan(pd->tx_dma, pd->tx_chan);\r\ns6dmac_disable_chan(pd->rx_dma, pd->rx_chan);\r\ns6dmac_disable_error_irqs(pd->tx_dma, 1 << S6_HIFDMA_GMACTX);\r\ns6dmac_disable_error_irqs(pd->rx_dma, 1 << S6_HIFDMA_GMACRX);\r\n}\r\nstatic int s6gmac_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pd->lock, flags);\r\nwritel(skb->len << S6_GMAC_BURST_PREWR_LEN |\r\n0 << S6_GMAC_BURST_PREWR_CFE |\r\n1 << S6_GMAC_BURST_PREWR_PPE |\r\n1 << S6_GMAC_BURST_PREWR_FCS |\r\n((skb->len < ETH_ZLEN) ? 1 : 0) << S6_GMAC_BURST_PREWR_PAD,\r\npd->reg + S6_GMAC_BURST_PREWR);\r\ns6dmac_put_fifo_cache(pd->tx_dma, pd->tx_chan,\r\n(u32)skb->data, pd->io, skb->len);\r\nif (s6dmac_fifo_full(pd->tx_dma, pd->tx_chan))\r\nnetif_stop_queue(dev);\r\nif (((u8)(pd->tx_skb_i - pd->tx_skb_o)) >= S6_NUM_TX_SKB) {\r\nprintk(KERN_ERR "GMAC BUG: skb tx ring overflow [%x, %x]\n",\r\npd->tx_skb_o, pd->tx_skb_i);\r\nBUG();\r\n}\r\npd->tx_skb[(pd->tx_skb_i++) % S6_NUM_TX_SKB] = skb;\r\nspin_unlock_irqrestore(&pd->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void s6gmac_tx_timeout(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&pd->lock, flags);\r\ns6gmac_tx_interrupt(dev);\r\nspin_unlock_irqrestore(&pd->lock, flags);\r\n}\r\nstatic int s6gmac_open(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nunsigned long flags;\r\nphy_read_status(pd->phydev);\r\nspin_lock_irqsave(&pd->lock, flags);\r\npd->link.mbit = 0;\r\ns6gmac_linkisup(dev, pd->phydev->link);\r\ns6gmac_init_device(dev);\r\ns6gmac_init_stats(dev);\r\ns6gmac_init_dmac(dev);\r\ns6gmac_rx_fillfifo(dev);\r\ns6dmac_enable_chan(pd->rx_dma, pd->rx_chan,\r\n2, 1, 0, 1, 0, 0, 0, 7, -1, 2, 0, 1);\r\ns6dmac_enable_chan(pd->tx_dma, pd->tx_chan,\r\n2, 0, 1, 0, 0, 0, 0, 7, -1, 2, 0, 1);\r\nwritel(0 << S6_GMAC_HOST_INT_TXBURSTOVER |\r\n0 << S6_GMAC_HOST_INT_TXPREWOVER |\r\n0 << S6_GMAC_HOST_INT_RXBURSTUNDER |\r\n0 << S6_GMAC_HOST_INT_RXPOSTRFULL |\r\n0 << S6_GMAC_HOST_INT_RXPOSTRUNDER,\r\npd->reg + S6_GMAC_HOST_INTMASK);\r\nspin_unlock_irqrestore(&pd->lock, flags);\r\nphy_start(pd->phydev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int s6gmac_stop(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nphy_stop(pd->phydev);\r\nspin_lock_irqsave(&pd->lock, flags);\r\ns6gmac_init_dmac(dev);\r\ns6gmac_stop_device(dev);\r\nwhile (pd->tx_skb_i != pd->tx_skb_o)\r\ndev_kfree_skb(pd->tx_skb[(pd->tx_skb_o++) % S6_NUM_TX_SKB]);\r\nwhile (pd->rx_skb_i != pd->rx_skb_o)\r\ndev_kfree_skb(pd->rx_skb[(pd->rx_skb_o++) % S6_NUM_RX_SKB]);\r\nspin_unlock_irqrestore(&pd->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *s6gmac_stats(struct net_device *dev)\r\n{\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nstruct net_device_stats *st = (struct net_device_stats *)&pd->stats;\r\nint i;\r\ndo {\r\nunsigned long flags;\r\nspin_lock_irqsave(&pd->lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(pd->stats); i++)\r\npd->stats[i] =\r\npd->carry[i] << (S6_GMAC_STAT_SIZE_MIN - 1);\r\ns6gmac_stats_collect(pd, &statinf[0][0]);\r\ns6gmac_stats_collect(pd, &statinf[1][0]);\r\ni = s6gmac_stats_pending(pd, 0) |\r\ns6gmac_stats_pending(pd, 1);\r\nspin_unlock_irqrestore(&pd->lock, flags);\r\n} while (i);\r\nst->rx_errors = st->rx_crc_errors +\r\nst->rx_frame_errors +\r\nst->rx_length_errors +\r\nst->rx_missed_errors;\r\nst->tx_errors += st->tx_aborted_errors;\r\nreturn st;\r\n}\r\nstatic int __devinit s6gmac_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct s6gmac *pd;\r\nint res;\r\nunsigned long i;\r\nstruct mii_bus *mb;\r\ndev = alloc_etherdev(sizeof(*pd));\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->open = s6gmac_open;\r\ndev->stop = s6gmac_stop;\r\ndev->hard_start_xmit = s6gmac_tx;\r\ndev->tx_timeout = s6gmac_tx_timeout;\r\ndev->watchdog_timeo = HZ;\r\ndev->get_stats = s6gmac_stats;\r\ndev->irq = platform_get_irq(pdev, 0);\r\npd = netdev_priv(dev);\r\nmemset(pd, 0, sizeof(*pd));\r\nspin_lock_init(&pd->lock);\r\npd->reg = platform_get_resource(pdev, IORESOURCE_MEM, 0)->start;\r\ni = platform_get_resource(pdev, IORESOURCE_DMA, 0)->start;\r\npd->tx_dma = DMA_MASK_DMAC(i);\r\npd->tx_chan = DMA_INDEX_CHNL(i);\r\ni = platform_get_resource(pdev, IORESOURCE_DMA, 1)->start;\r\npd->rx_dma = DMA_MASK_DMAC(i);\r\npd->rx_chan = DMA_INDEX_CHNL(i);\r\npd->io = platform_get_resource(pdev, IORESOURCE_IO, 0)->start;\r\nres = request_irq(dev->irq, s6gmac_interrupt, 0, dev->name, dev);\r\nif (res) {\r\nprintk(KERN_ERR DRV_PRMT "irq request failed: %d\n", dev->irq);\r\ngoto errirq;\r\n}\r\nres = register_netdev(dev);\r\nif (res) {\r\nprintk(KERN_ERR DRV_PRMT "error registering device %s\n",\r\ndev->name);\r\ngoto errdev;\r\n}\r\nmb = mdiobus_alloc();\r\nif (!mb) {\r\nprintk(KERN_ERR DRV_PRMT "error allocating mii bus\n");\r\ngoto errmii;\r\n}\r\nmb->name = "s6gmac_mii";\r\nmb->read = s6mii_read;\r\nmb->write = s6mii_write;\r\nmb->reset = s6mii_reset;\r\nmb->priv = pd;\r\nsnprintf(mb->id, MII_BUS_ID_SIZE, "%s-%x", pdev->name, pdev->id);\r\nmb->phy_mask = ~(1 << 0);\r\nmb->irq = &pd->mii.irq[0];\r\nfor (i = 0; i < PHY_MAX_ADDR; i++) {\r\nint n = platform_get_irq(pdev, i + 1);\r\nif (n < 0)\r\nn = PHY_POLL;\r\npd->mii.irq[i] = n;\r\n}\r\nmdiobus_register(mb);\r\npd->mii.bus = mb;\r\nres = s6gmac_phy_start(dev);\r\nif (res)\r\nreturn res;\r\nplatform_set_drvdata(pdev, dev);\r\nreturn 0;\r\nerrmii:\r\nunregister_netdev(dev);\r\nerrdev:\r\nfree_irq(dev->irq, dev);\r\nerrirq:\r\nfree_netdev(dev);\r\nreturn res;\r\n}\r\nstatic int __devexit s6gmac_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nif (dev) {\r\nstruct s6gmac *pd = netdev_priv(dev);\r\nmdiobus_unregister(pd->mii.bus);\r\nunregister_netdev(dev);\r\nfree_irq(dev->irq, dev);\r\nfree_netdev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init s6gmac_init(void)\r\n{\r\nprintk(KERN_INFO DRV_PRMT "S6 GMAC ethernet driver\n");\r\nreturn platform_driver_register(&s6gmac_driver);\r\n}\r\nstatic void __exit s6gmac_exit(void)\r\n{\r\nplatform_driver_unregister(&s6gmac_driver);\r\n}
