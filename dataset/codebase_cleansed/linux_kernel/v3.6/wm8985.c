static bool wm8985_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8985_SOFTWARE_RESET:\r\ncase WM8985_POWER_MANAGEMENT_1:\r\ncase WM8985_POWER_MANAGEMENT_2:\r\ncase WM8985_POWER_MANAGEMENT_3:\r\ncase WM8985_AUDIO_INTERFACE:\r\ncase WM8985_COMPANDING_CONTROL:\r\ncase WM8985_CLOCK_GEN_CONTROL:\r\ncase WM8985_ADDITIONAL_CONTROL:\r\ncase WM8985_GPIO_CONTROL:\r\ncase WM8985_JACK_DETECT_CONTROL_1:\r\ncase WM8985_DAC_CONTROL:\r\ncase WM8985_LEFT_DAC_DIGITAL_VOL:\r\ncase WM8985_RIGHT_DAC_DIGITAL_VOL:\r\ncase WM8985_JACK_DETECT_CONTROL_2:\r\ncase WM8985_ADC_CONTROL:\r\ncase WM8985_LEFT_ADC_DIGITAL_VOL:\r\ncase WM8985_RIGHT_ADC_DIGITAL_VOL:\r\ncase WM8985_EQ1_LOW_SHELF:\r\ncase WM8985_EQ2_PEAK_1:\r\ncase WM8985_EQ3_PEAK_2:\r\ncase WM8985_EQ4_PEAK_3:\r\ncase WM8985_EQ5_HIGH_SHELF:\r\ncase WM8985_DAC_LIMITER_1:\r\ncase WM8985_DAC_LIMITER_2:\r\ncase WM8985_NOTCH_FILTER_1:\r\ncase WM8985_NOTCH_FILTER_2:\r\ncase WM8985_NOTCH_FILTER_3:\r\ncase WM8985_NOTCH_FILTER_4:\r\ncase WM8985_ALC_CONTROL_1:\r\ncase WM8985_ALC_CONTROL_2:\r\ncase WM8985_ALC_CONTROL_3:\r\ncase WM8985_NOISE_GATE:\r\ncase WM8985_PLL_N:\r\ncase WM8985_PLL_K_1:\r\ncase WM8985_PLL_K_2:\r\ncase WM8985_PLL_K_3:\r\ncase WM8985_3D_CONTROL:\r\ncase WM8985_OUT4_TO_ADC:\r\ncase WM8985_BEEP_CONTROL:\r\ncase WM8985_INPUT_CTRL:\r\ncase WM8985_LEFT_INP_PGA_GAIN_CTRL:\r\ncase WM8985_RIGHT_INP_PGA_GAIN_CTRL:\r\ncase WM8985_LEFT_ADC_BOOST_CTRL:\r\ncase WM8985_RIGHT_ADC_BOOST_CTRL:\r\ncase WM8985_OUTPUT_CTRL0:\r\ncase WM8985_LEFT_MIXER_CTRL:\r\ncase WM8985_RIGHT_MIXER_CTRL:\r\ncase WM8985_LOUT1_HP_VOLUME_CTRL:\r\ncase WM8985_ROUT1_HP_VOLUME_CTRL:\r\ncase WM8985_LOUT2_SPK_VOLUME_CTRL:\r\ncase WM8985_ROUT2_SPK_VOLUME_CTRL:\r\ncase WM8985_OUT3_MIXER_CTRL:\r\ncase WM8985_OUT4_MONO_MIX_CTRL:\r\ncase WM8985_OUTPUT_CTRL1:\r\ncase WM8985_BIAS_CTRL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int eqmode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg;\r\nreg = snd_soc_read(codec, WM8985_EQ1_LOW_SHELF);\r\nif (reg & WM8985_EQ3DMODE)\r\nucontrol->value.integer.value[0] = 1;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int eqmode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int regpwr2, regpwr3;\r\nunsigned int reg_eq;\r\nif (ucontrol->value.integer.value[0] != 0\r\n&& ucontrol->value.integer.value[0] != 1)\r\nreturn -EINVAL;\r\nreg_eq = snd_soc_read(codec, WM8985_EQ1_LOW_SHELF);\r\nswitch ((reg_eq & WM8985_EQ3DMODE) >> WM8985_EQ3DMODE_SHIFT) {\r\ncase 0:\r\nif (!ucontrol->value.integer.value[0])\r\nreturn 0;\r\nbreak;\r\ncase 1:\r\nif (ucontrol->value.integer.value[0])\r\nreturn 0;\r\nbreak;\r\n}\r\nregpwr2 = snd_soc_read(codec, WM8985_POWER_MANAGEMENT_2);\r\nregpwr3 = snd_soc_read(codec, WM8985_POWER_MANAGEMENT_3);\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_2,\r\nWM8985_ADCENR_MASK | WM8985_ADCENL_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_3,\r\nWM8985_DACENR_MASK | WM8985_DACENL_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8985_ADDITIONAL_CONTROL,\r\nWM8985_M128ENB_MASK, WM8985_M128ENB);\r\nsnd_soc_update_bits(codec, WM8985_EQ1_LOW_SHELF,\r\nWM8985_EQ3DMODE_MASK,\r\nucontrol->value.integer.value[0]\r\n<< WM8985_EQ3DMODE_SHIFT);\r\nsnd_soc_write(codec, WM8985_POWER_MANAGEMENT_2, regpwr2);\r\nsnd_soc_write(codec, WM8985_POWER_MANAGEMENT_3, regpwr3);\r\nreturn 0;\r\n}\r\nstatic int wm8985_reset(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_write(codec, WM8985_SOFTWARE_RESET, 0x0);\r\n}\r\nstatic int wm8985_dac_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nreturn snd_soc_update_bits(codec, WM8985_DAC_CONTROL,\r\nWM8985_SOFTMUTE_MASK,\r\n!!mute << WM8985_SOFTMUTE_SHIFT);\r\n}\r\nstatic int wm8985_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec;\r\nu16 format, master, bcp, lrp;\r\ncodec = dai->codec;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nformat = 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nformat = 0x0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nformat = 0x1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nformat = 0x3;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown dai format\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8985_AUDIO_INTERFACE,\r\nWM8985_FMT_MASK, format << WM8985_FMT_SHIFT);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmaster = 0;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown master/slave configuration\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8985_CLOCK_GEN_CONTROL,\r\nWM8985_MS_MASK, master << WM8985_MS_SHIFT);\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nreturn -EINVAL;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbcp = lrp = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbcp = lrp = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbcp = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrp = 1;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown polarity configuration\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8985_AUDIO_INTERFACE,\r\nWM8985_LRP_MASK, lrp << WM8985_LRP_SHIFT);\r\nsnd_soc_update_bits(codec, WM8985_AUDIO_INTERFACE,\r\nWM8985_BCP_MASK, bcp << WM8985_BCP_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int wm8985_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint i;\r\nstruct snd_soc_codec *codec;\r\nstruct wm8985_priv *wm8985;\r\nu16 blen, srate_idx;\r\nunsigned int tmp;\r\nint srate_best;\r\ncodec = dai->codec;\r\nwm8985 = snd_soc_codec_get_drvdata(codec);\r\nwm8985->bclk = snd_soc_params_to_bclk(params);\r\nif ((int)wm8985->bclk < 0)\r\nreturn wm8985->bclk;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nblen = 0x0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nblen = 0x1;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nblen = 0x2;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nblen = 0x3;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unsupported word length %u\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, WM8985_AUDIO_INTERFACE,\r\nWM8985_WL_MASK, blen << WM8985_WL_SHIFT);\r\nsrate_idx = 0;\r\nsrate_best = abs(srates[0] - params_rate(params));\r\nfor (i = 1; i < ARRAY_SIZE(srates); ++i) {\r\nif (abs(srates[i] - params_rate(params)) >= srate_best)\r\ncontinue;\r\nsrate_idx = i;\r\nsrate_best = abs(srates[i] - params_rate(params));\r\n}\r\ndev_dbg(dai->dev, "Selected SRATE = %d\n", srates[srate_idx]);\r\nsnd_soc_update_bits(codec, WM8985_ADDITIONAL_CONTROL,\r\nWM8985_SR_MASK, srate_idx << WM8985_SR_SHIFT);\r\ndev_dbg(dai->dev, "Target BCLK = %uHz\n", wm8985->bclk);\r\ndev_dbg(dai->dev, "SYSCLK = %uHz\n", wm8985->sysclk);\r\nfor (i = 0; i < ARRAY_SIZE(fs_ratios); ++i) {\r\nif (wm8985->sysclk / params_rate(params)\r\n== fs_ratios[i].ratio)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fs_ratios)) {\r\ndev_err(dai->dev, "Unable to configure MCLK ratio %u/%u\n",\r\nwm8985->sysclk, params_rate(params));\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "MCLK ratio = %dfs\n", fs_ratios[i].ratio);\r\nsnd_soc_update_bits(codec, WM8985_CLOCK_GEN_CONTROL,\r\nWM8985_MCLKDIV_MASK, i << WM8985_MCLKDIV_SHIFT);\r\ntmp = (wm8985->sysclk / fs_ratios[i].div) * 10;\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); ++i) {\r\nif (wm8985->bclk == tmp / bclk_divs[i])\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(bclk_divs)) {\r\ndev_err(dai->dev, "No matching BCLK divider found\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "BCLK div = %d\n", i);\r\nsnd_soc_update_bits(codec, WM8985_CLOCK_GEN_CONTROL,\r\nWM8985_BCLKDIV_MASK, i << WM8985_BCLKDIV_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int pll_factors(struct pll_div *pll_div, unsigned int target,\r\nunsigned int source)\r\n{\r\nu64 Kpart;\r\nunsigned long int K, Ndiv, Nmod;\r\npll_div->div2 = 0;\r\nNdiv = target / source;\r\nif (Ndiv < 6) {\r\nsource >>= 1;\r\npll_div->div2 = 1;\r\nNdiv = target / source;\r\n}\r\nif (Ndiv < 6 || Ndiv > 12) {\r\nprintk(KERN_ERR "%s: WM8985 N value is not within"\r\n" the recommended range: %lu\n", __func__, Ndiv);\r\nreturn -EINVAL;\r\n}\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (u64)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xffffffff;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div->k = K;\r\nreturn 0;\r\n}\r\nstatic int wm8985_set_pll(struct snd_soc_dai *dai, int pll_id,\r\nint source, unsigned int freq_in,\r\nunsigned int freq_out)\r\n{\r\nint ret;\r\nstruct snd_soc_codec *codec;\r\nstruct pll_div pll_div;\r\ncodec = dai->codec;\r\nif (freq_in && freq_out) {\r\nret = pll_factors(&pll_div, freq_out * 4 * 2, freq_in);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,\r\nWM8985_PLLEN_MASK, 0);\r\nif (!freq_in || !freq_out)\r\nreturn 0;\r\nsnd_soc_write(codec, WM8985_PLL_N,\r\n(pll_div.div2 << WM8985_PLL_PRESCALE_SHIFT)\r\n| pll_div.n);\r\nsnd_soc_write(codec, WM8985_PLL_K_3, pll_div.k & 0x1ff);\r\nsnd_soc_write(codec, WM8985_PLL_K_2, (pll_div.k >> 9) & 0x1ff);\r\nsnd_soc_write(codec, WM8985_PLL_K_1, (pll_div.k >> 18));\r\nsnd_soc_update_bits(codec, WM8985_CLOCK_GEN_CONTROL,\r\nWM8985_CLKSEL_MASK, WM8985_CLKSEL);\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,\r\nWM8985_PLLEN_MASK, WM8985_PLLEN);\r\nreturn 0;\r\n}\r\nstatic int wm8985_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct wm8985_priv *wm8985;\r\ncodec = dai->codec;\r\nwm8985 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase WM8985_CLKSRC_MCLK:\r\nsnd_soc_update_bits(codec, WM8985_CLOCK_GEN_CONTROL,\r\nWM8985_CLKSEL_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,\r\nWM8985_PLLEN_MASK, 0);\r\nbreak;\r\ncase WM8985_CLKSRC_PLL:\r\nsnd_soc_update_bits(codec, WM8985_CLOCK_GEN_CONTROL,\r\nWM8985_CLKSEL_MASK, WM8985_CLKSEL);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Unknown clock source %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nwm8985->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int wm8985_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint ret;\r\nstruct wm8985_priv *wm8985;\r\nwm8985 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,\r\nWM8985_VMIDSEL_MASK,\r\n1 << WM8985_VMIDSEL_SHIFT);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8985->supplies),\r\nwm8985->supplies);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregcache_sync(wm8985->regmap);\r\nsnd_soc_update_bits(codec, WM8985_OUT4_TO_ADC,\r\nWM8985_POBCTRL_MASK,\r\nWM8985_POBCTRL);\r\nsnd_soc_update_bits(codec, WM8985_OUTPUT_CTRL0,\r\nWM8985_TSDEN_MASK, WM8985_TSDEN);\r\nsnd_soc_update_bits(codec, WM8985_OUTPUT_CTRL0,\r\nWM8985_TSOPCTRL_MASK,\r\nWM8985_TSOPCTRL);\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,\r\nWM8985_BIASEN_MASK, WM8985_BIASEN);\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,\r\nWM8985_VMIDSEL_MASK,\r\n1 << WM8985_VMIDSEL_SHIFT);\r\nmsleep(500);\r\nsnd_soc_update_bits(codec, WM8985_OUT4_TO_ADC,\r\nWM8985_POBCTRL_MASK, 0);\r\n}\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,\r\nWM8985_VMIDSEL_MASK,\r\n2 << WM8985_VMIDSEL_SHIFT);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8985_OUTPUT_CTRL0,\r\nWM8985_TSOPCTRL_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8985_OUTPUT_CTRL0,\r\nWM8985_TSDEN_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,\r\nWM8985_VMIDSEL_MASK | WM8985_BIASEN_MASK,\r\n0);\r\nsnd_soc_write(codec, WM8985_POWER_MANAGEMENT_1, 0);\r\nsnd_soc_write(codec, WM8985_POWER_MANAGEMENT_2, 0);\r\nsnd_soc_write(codec, WM8985_POWER_MANAGEMENT_3, 0);\r\nregcache_mark_dirty(wm8985->regmap);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8985->supplies),\r\nwm8985->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8985_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8985_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8985_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8985_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8985_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8985_priv *wm8985;\r\nwm8985 = snd_soc_codec_get_drvdata(codec);\r\nwm8985_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nregulator_bulk_free(ARRAY_SIZE(wm8985->supplies), wm8985->supplies);\r\nreturn 0;\r\n}\r\nstatic int wm8985_probe(struct snd_soc_codec *codec)\r\n{\r\nsize_t i;\r\nstruct wm8985_priv *wm8985;\r\nint ret;\r\nwm8985 = snd_soc_codec_get_drvdata(codec);\r\ncodec->control_data = wm8985->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 7, 9, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache i/o: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm8985->supplies); i++)\r\nwm8985->supplies[i].supply = wm8985_supply_names[i];\r\nret = regulator_bulk_get(codec->dev, ARRAY_SIZE(wm8985->supplies),\r\nwm8985->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8985->supplies),\r\nwm8985->supplies);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n", ret);\r\ngoto err_reg_get;\r\n}\r\nret = wm8985_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset: %d\n", ret);\r\ngoto err_reg_enable;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(volume_update_regs); ++i)\r\nsnd_soc_update_bits(codec, volume_update_regs[i],\r\n0x100, 0x100);\r\nsnd_soc_update_bits(codec, WM8985_BIAS_CTRL, WM8985_BIASCUT,\r\nWM8985_BIASCUT);\r\nwm8985_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\nerr_reg_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8985->supplies), wm8985->supplies);\r\nerr_reg_get:\r\nregulator_bulk_free(ARRAY_SIZE(wm8985->supplies), wm8985->supplies);\r\nreturn ret;\r\n}\r\nstatic int __devinit wm8985_spi_probe(struct spi_device *spi)\r\n{\r\nstruct wm8985_priv *wm8985;\r\nint ret;\r\nwm8985 = devm_kzalloc(&spi->dev, sizeof *wm8985, GFP_KERNEL);\r\nif (!wm8985)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, wm8985);\r\nwm8985->regmap = regmap_init_spi(spi, &wm8985_regmap);\r\nif (IS_ERR(wm8985->regmap)) {\r\nret = PTR_ERR(wm8985->regmap);\r\ndev_err(&spi->dev, "Failed to allocate register map: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_dev_wm8985, &wm8985_dai, 1);\r\nif (ret != 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nregmap_exit(wm8985->regmap);\r\nreturn ret;\r\n}\r\nstatic int __devexit wm8985_spi_remove(struct spi_device *spi)\r\n{\r\nstruct wm8985_priv *wm8985 = spi_get_drvdata(spi);\r\nsnd_soc_unregister_codec(&spi->dev);\r\nregmap_exit(wm8985->regmap);\r\nreturn 0;\r\n}\r\nstatic __devinit int wm8985_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8985_priv *wm8985;\r\nint ret;\r\nwm8985 = devm_kzalloc(&i2c->dev, sizeof *wm8985, GFP_KERNEL);\r\nif (!wm8985)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm8985);\r\nwm8985->regmap = regmap_init_i2c(i2c, &wm8985_regmap);\r\nif (IS_ERR(wm8985->regmap)) {\r\nret = PTR_ERR(wm8985->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8985, &wm8985_dai, 1);\r\nif (ret != 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nregmap_exit(wm8985->regmap);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm8985_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct wm8985_priv *wm8985 = i2c_get_clientdata(i2c);\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nregmap_exit(wm8985->regmap);\r\nreturn 0;\r\n}\r\nstatic int __init wm8985_modinit(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&wm8985_i2c_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed to register wm8985 I2C driver: %d\n",\r\nret);\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&wm8985_spi_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8985 SPI driver: %d\n",\r\nret);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit wm8985_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&wm8985_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&wm8985_spi_driver);\r\n#endif\r\n}
